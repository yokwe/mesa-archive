-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- ParseSystemDescriptionImpl.mesa-- Takes a System description in the form specified in X-- and returns an AdobeOps.ARSystemHandle -- Freedman       9-Jun-83 11:37:07-- RSF	  	 17-Jan-85 15:43:30-- JCS	       	 19-May-86 15:03:48  DIRECTORY  Ascii USING [NUL],  AdobeOps USING [    ARSystemHandle, ARSystemObject, DefaultInfoHandle,     DefaultInfoObject, DependsOnIndex, EnumeratedSequence,     EnumeratedSequenceType, FieldItemHandle, FieldItemObject,    FieldList, FieldListArray, FieldType, KeyedPossibilities,     KeyedPossibilitiesSeq, nilEnum, nullDependsOnIndex,    ToolType],  AdobeServerOps,    Heap,  MyCmFile USING [    Close, Error, FreeString, Handle, NextSection, NextItem, NextValue,    Open, TableError],  FormSW USING [Enumerated],  ParseSystemDescription,  String,  StringLookUp USING [InTable, noMatch, TableDesc],  Token USING [    Alphabetic, AlphaNumeric, Brackets, Filtered, FilterProcType, FreeStringHandle,    FreeTokenString, Handle, LongDecimal, MaybeQuoted, StringToHandle,    SyntaxError, UnterminatedQuote];ParseSystemDescriptionImpl: PROGRAM  IMPORTS AdobeServerOps, Heap, MyCmFile, String, StringLookUp, Token EXPORTS ParseSystemDescription =  BEGIN  --sequence used for Table Lookup  ValueSequencePtr: TYPE = LONG POINTER TO ValueSequence;  ValueSequence: TYPE = RECORD [seq: SEQUENCE length: CARDINAL OF LONG STRING];  ParsingError: PUBLIC ERROR [    type: ParseSystemDescription.ProblemType,    sectionName: LONG STRING, field: LONG STRING,    fieldIndex: CARDINAL ¬ LAST[CARDINAL]] = CODE;      --count for how many fields have been proccessed (need not correspond to  --number of field in Text file because some may be duplicates)  numOfFieldsProcessed: CARDINAL ¬ 0;  --total number of fields to process (gotten from system description)  numOfFields: CARDINAL ¬ 0;    --to insure there is exactly one arId field  arIdFound: BOOLEAN ¬ FALSE;    --value to be processed by our parser  token, attribute: LONG STRING ¬ NIL;  --z: UNCOUNTED ZONE ¬ AdobeOps.z;  z: UNCOUNTED ZONE ¬ AdobeServerOps.data.z;  ProcessDescription: PUBLIC PROCEDURE [fileName: LONG STRING]    RETURNS [handle: AdobeOps.ARSystemHandle] =    BEGIN    cmH: MyCmFile.Handle ¬ MyCmFile.Open[      fileName !      MyCmFile.Error => IF code = fileNotFound THEN        ERROR ParsingError[fileNotFound, NIL, NIL]];    arIdFound ¬ FALSE;    BEGIN ENABLE UNWIND => cmH ¬ MyCmFile.Close[cmH];    handle ¬ BuildSystemHandle[cmH];    cmH ¬ MyCmFile.Close[cmH];    END;    END;      FreeDescription: PUBLIC PROCEDURE[handle: AdobeOps.ARSystemHandle]    RETURNS [nilHandle: AdobeOps.ARSystemHandle ¬ NIL] =    BEGIN    END;       FreeSystemDescription: PUBLIC PROCEDURE [    handle: AdobeOps.ARSystemHandle]    RETURNS [nilHandle: AdobeOps.ARSystemHandle ¬ NIL] =    BEGIN    z.FREE[@handle.name];    z.FREE[@handle.host];    z.FREE[@handle.directory];    DeallocateFieldList[handle.fieldList];    FOR tool: AdobeOps.ToolType IN AdobeOps.ToolType DO      IF handle.formSWOrderArray[tool] # NIL       THEN z.FREE[@handle.formSWOrderArray[tool]]    ENDLOOP;    z.FREE[@handle];    END;      DeallocateFieldList: PROCEDURE[fieldList: AdobeOps.FieldList] =    BEGIN    IF fieldList # NIL THEN    BEGIN     FOR i: CARDINAL IN [0..fieldList.len) DO    z.FREE[@fieldList[i].name];    FreeDefaultInfo[fieldList[i].defaultInfo];    FreeFLBody[@fieldList[i]];     ENDLOOP;    z.FREE[@fieldList];    END;    END;      FreeDefaultInfo: PROCEDURE[defaultInfo: ARRAY AdobeOps.ToolType OF AdobeOps.DefaultInfoHandle] = <<INLINE>>    BEGIN    FOR i: AdobeOps.ToolType IN AdobeOps.ToolType DO      IF defaultInfo[i] # NIL THEN      BEGIN        IF defaultInfo[i].default # NIL THEN          z.FREE[@defaultInfo[i].default];          z.FREE[@defaultInfo[i]];      END;    ENDLOOP;     END;          FreeFLBody: PROCEDURE[fieldList: AdobeOps.FieldItemHandle] = <<INLINE>>      BEGIN    WITH item: fieldList SELECT FROM      enumerated =>	BEGIN	FreePossibilities[item.possibilities];	z.FREE[@item.possibilities];	END;    ENDCASE --nothing to FREE    END;      FreePossibilities: PROCEDURE[poss: AdobeOps.KeyedPossibilities] = <<INLINE>>    BEGIN    IF poss # NIL THEN     BEGIN    FOR i: CARDINAL IN [0..poss.len) DO      FreeEnumRecs[poss[i].enumRecs];    ENDLOOP;    END;    END;      FreeEnumRecs: PROCEDURE[enumSeq: AdobeOps.EnumeratedSequence] = <<INLINE>>    BEGIN    IF enumSeq # NIL THEN     BEGIN    FOR i: CARDINAL IN [0..enumSeq.length) DO      z.FREE[@enumSeq[i].string]    ENDLOOP;    z.FREE[@enumSeq];    END;    END;  BuildSystemHandle: PUBLIC PROCEDURE [cmH: MyCmFile.Handle]    RETURNS [handle: AdobeOps.ARSystemHandle] =    BEGIN    ENABLE UNWIND => {      handle ¬ FreeSystemDescription[handle];      arIdFound ¬ FALSE};    name: LONG STRING ¬ NIL;    arIdFound ¬ FALSE;    handle ¬ z.NEW[AdobeOps.ARSystemObject ¬ []];    --get the first section which describes the system    ParseVersionSection[cmH, handle];    --the rest of the description describes the field list; Parse it.    BuildFieldList[cmH, handle.fieldList];    IF ~arIdFound THEN ParsingError[noarIdGiven, NIL, NIL];    END;  ParseVersionSection: PROCEDURE [    cmH: MyCmFile.Handle, handle: AdobeOps.ARSystemHandle] =    BEGIN    Option: TYPE = MACHINE DEPENDENT{      systemName(0), host(1), directory(2), version(3),      numberOfFields(4), usedEnumeratedValues(5), noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = Option [systemName..usedEnumeratedValues];    RequiredOptions: TYPE = Option [systemName..numberOfFields];    optionTable: ARRAY DefinedOption OF LONG STRING ¬ [      systemName: "SystemName"L, usedEnumeratedValues: "UsedEnumeratedValues"L,      host: "Host"L, directory: "Directory"L, version: "Version"L,      numberOfFields: "NumberOfFields"L];    --each of these fields must be present    optionsWereFound: ARRAY RequiredOptions OF BOOLEAN ¬ ALL[FALSE];    i: Option ¬ noMatch;    value: LONG STRING ¬ NIL;    section: LONG STRING ¬ MyCmFile.NextSection[cmH];      AllTrue: PROCEDURE[bA: LONG DESCRIPTOR FOR ARRAY RequiredOptions OF BOOLEAN]  RETURNS[yes: BOOLEAN ¬ TRUE] = INLINE  BEGIN  FOR i: RequiredOptions IN [systemName..numberOfFields] DO    IF ~bA[i] THEN RETURN[FALSE];  ENDLOOP;  END;    CheckType: PROCEDURE [h: MyCmFile.Handle, table: StringLookUp.TableDesc]      RETURNS [index: CARDINAL] = MyCmFile.NextValue;    MyNextValue: PROCEDURE [      h: MyCmFile.Handle,      table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]      RETURNS [index: Option] = LOOPHOLE[CheckType];    IF section # NIL THEN BEGIN      DO        ENABLE          UNWIND => {            section ¬ MyCmFile.FreeString[section];            value ¬ Token.FreeTokenString[value]};        SELECT i ¬ MyNextValue[        h: cmH, table: DESCRIPTOR[optionTable] ! MyCmFile.TableError => RESUME ]        FROM          noMatch => EXIT;          systemName =>            BEGIN	    value ¬ Token.MaybeQuoted[	      h: cmH,data: NIL,filter: Token.AlphaNumeric];	    FOR i: CARDINAL IN [0..value.length) DO	      IF value[i] = ': THEN {value.length ¬ i; EXIT};	      ENDLOOP;            handle.name ¬ String.CopyToNewString[s: value, z: z];            value ¬ Token.FreeTokenString[value];	    optionsWereFound[systemName] ¬ TRUE;            END;          usedEnumeratedValues => NULL;          --do not need this to build data structure          host =>            BEGIN            handle.host ¬ String.CopyToNewString[s: value ¬ Token.MaybeQuoted[h: cmH,data: NIL,filter: Token.AlphaNumeric], z: z];            value ¬ Token.FreeTokenString[value];	    optionsWereFound[host] ¬ TRUE;            END;          directory =>            BEGIN            handle.directory ¬ String.CopyToNewString[              s: value ¬ Token.MaybeQuoted[h: cmH,data: NIL,filter: Token.AlphaNumeric], z: z];            value ¬ Token.FreeTokenString[value];	    optionsWereFound[directory] ¬ TRUE;            END;          version => {handle.version ¬ Token.LongDecimal[cmH];	     optionsWereFound[version] ¬ TRUE};          numberOfFields =>            BEGIN            handle.fieldList ¬ z.NEW[              AdobeOps.FieldListArray[numOfFields ¬ CARDINAL[              Token.LongDecimal[              cmH !              Token.SyntaxError =>                ERROR ParsingError[missingOrBadAttribute, section, "NumberOfFields"L]]]]];	    FOR i: CARDINAL IN [0..numOfFields) DO	      handle.fieldList[i] ¬ [NIL, ALL[NIL], arId[]];	    ENDLOOP;            numOfFieldsProcessed ¬ 0;	    optionsWereFound[numberOfFields] ¬ TRUE            END;          ENDCASE;        ENDLOOP;    END    ELSE ERROR ParsingError[emptyDescription, section, NIL];    --because optionsWereFound comes from a sparse type it can not    --be check for ALL[TRUE] but must be looped    IF ~AllTrue[DESCRIPTOR[optionsWereFound]]  THEN ERROR ParsingError[missingOrBadAttribute, section, NIL];    section ¬ MyCmFile.FreeString[section];    END;        BuildFieldList: PROCEDURE [cmH: MyCmFile.Handle, fL: AdobeOps.FieldList] =    BEGIN    section: LONG STRING ¬ NIL;    Duplicate: PROCEDURE [section: LONG STRING] RETURNS [itIs: BOOLEAN ¬ FALSE] =      INLINE      BEGIN      FOR i: CARDINAL IN [0..numOfFieldsProcessed) DO        IF String.Equal[fL[i].name, section] THEN RETURN[TRUE] ENDLOOP;      RETURN[FALSE];      END;          UNTIL (section ¬ MyCmFile.NextSection[cmH]) = NIL DO      ENABLE UNWIND => section ¬ MyCmFile.FreeString[section];      duplicate: BOOLEAN ¬ FALSE;      [attribute, token] ¬ GetToken[cmH];      --see if its a duplicate section      IF ~(duplicate ¬ Duplicate[section]) THEN        BEGIN	--if it is not then copy section name        fL[numOfFieldsProcessed].name ¬ String.CopyToNewString[s: section, z: z];        --do default stuff here        DoSectionDesc[          cmH: cmH, fL: fL, item: numOfFieldsProcessed, duplicate: duplicate];        numOfFieldsProcessed ¬ numOfFieldsProcessed + 1;        END      ELSE        DoSectionDesc[          cmH: cmH, fL: fL, item: numOfFieldsProcessed - 1, duplicate: duplicate];      section ¬ MyCmFile.FreeString[section];      attribute ¬ MyCmFile.FreeString[attribute];      token ¬ MyCmFile.FreeString[token];      ENDLOOP;    IF numOfFieldsProcessed # numOfFields THEN      ERROR ParsingError[notAsManyFieldsAsDescribed, NIL, NIL];    END;      GetToken: PROCEDURE[cmH: MyCmFile.Handle] RETURNS[attribute, value: LONG STRING] = {[attribute, value] ¬ MyCmFile.NextItem[cmH]};      DoSectionDesc: PROCEDURE [    cmH: MyCmFile.Handle, fL: AdobeOps.FieldList, item: CARDINAL,    duplicate: BOOLEAN] =    BEGIN    typeFieldArray: ARRAY [0..6) OF LONG STRING ¬ [      "ARID"L, "DateTime"L, "Numeric"L, "BoundedString"L,      "Enumerated"L, "UnboundedString"L];    sectionType: AdobeOps.FieldType ¬ arId;    IF String.Equal[attribute, "Type"L] THEN       BEGIN      sectionType ¬ VAL[StringLookUp.InTable[token,        DESCRIPTOR[typeFieldArray]]];      IF sectionType ~IN AdobeOps.FieldType THEN        ERROR ParsingError[missingOrBadAttributeValue, fL[item].name, "Type"L];      attribute ¬ MyCmFile.FreeString[attribute];      token ¬ MyCmFile.FreeString[token];      IF (sectionType = enumerated) OR ~duplicate       THEN [attribute, token] ¬ GetToken[cmH]      ELSE ERROR ParsingError[duplicateSection, fL[item].name, NIL];      InitializeBody[sectionType, cmH, fL, item, duplicate];      GetSystemDefaults[item: @fL[item], cmH: cmH];      END    ELSE ERROR ParsingError[missingOrBadAttribute, fL[item].name, "Type"L];    END;      InitializeBody: PROCEDURE [    sectionType: AdobeOps.FieldType, cmH: MyCmFile.Handle, fL: AdobeOps.FieldList, item: CARDINAL, duplicate: BOOLEAN] =    BEGIN        SELECT sectionType FROM        arId  => 	  IF arIdFound THEN 	    ERROR ParsingError[moreThanOnearId, fL[item].name, "Type"L]	  ELSE { 	    fL[item].body ¬ arId[];	    arIdFound ¬ TRUE};        dateTime => fL[item].body ¬ dateTime[];         numeric => fL[item].body ¬ numeric[];        fixedLengthString =>	  IF String.Equal[attribute, "MaxLength"L]          THEN	  BEGIN          fL[item].body ¬ fixedLengthString[            maxLength: String.StringToNumber[            s: token, radix: 10 !            String.InvalidNumber =>             ERROR ParsingError[missingOrBadAttributeValue, fL[item].name, "MaxLength"L]]];	  attribute ¬ MyCmFile.FreeString[attribute];          token ¬ MyCmFile.FreeString[token];	  [attribute, token] ¬ GetToken[cmH];	  END          ELSE ERROR ParsingError[missingOrBadAttribute, fL[item].name, "MaxLength"L];        string => fL[item].body ¬ string[];        enumerated =>          BEGIN	  <<if a ParsingError is found, any i.possibilities were	    freed in GetEnumeratedItems so it is NIL'd out so	    DeallocateFieldList doesn't try to free it again>>	  ENABLE ParsingError => WITH i: fL[item] SELECT FROM	    enumerated => i.possibilities ¬ NIL;	    ENDCASE; --          dependencyValue: CARDINAL ¬ LAST[CARDINAL];          field: AdobeOps.DependsOnIndex ¬ AdobeOps.nullDependsOnIndex;          IF String.Equal[attribute, "DependsOn"L]          THEN	[field, dependencyValue] ¬ GetDependentInfo[	    fL: fL, item: item, cmH: cmH]	  ELSE ERROR ParsingError[missingOrBadAttribute, fL[item].name, "DependsOn"L];          fL[item].body ¬ enumerated[                field, GetEnumeratedItems[                item: @fL[item], cmH: cmH, dependencyValue: dependencyValue, duplicate: duplicate]];          END        ENDCASE => ERROR ParsingError[missingOrBadAttributeValue, fL[item].name, attribute];    END;      GetSystemDefaults: PROCEDURE [    item: AdobeOps.FieldItemHandle, cmH: MyCmFile.Handle] =    BEGIN    defaultIndex: AdobeOps.ToolType ¬ edit;    defaultHandle: AdobeOps.DefaultInfoHandle ¬ NIL;    labels: ARRAY [0..2) OF LONG STRING ¬ ["tool"L, "default"L];    --the order of the strings in this array must correspond to the order    --of enumerated in AdobeOps.ToolType    tools: ARRAY [0..5) OF LONG STRING ¬ ["edit"L, "submit"L, "report"L, "query"L, "sort"L];    values: ValueSequencePtr ¬ NIL;    FOR tool:AdobeOps.ToolType IN AdobeOps.ToolType DO      item.defaultInfo[tool] ¬ z.NEW[AdobeOps.DefaultInfoObject ¬ [default: String.MakeString[z, 0]]];    ENDLOOP;       WHILE String.Equal[attribute, "Default"L] DO      ENABLE UNWIND => IF values # NIL THEN {        z.FREE[@values[0]]; z.FREE[@values[1]]};      --get the values associated with the fields "tool" and "default"      values ¬ ParseBracketedValues[        DESCRIPTOR[labels] !        ParsingError =>	  --fill in the section name and field          IF type = missingOrBadAttributeValue THEN            ERROR ParsingError[type, item.name, "Default"L]];      --store this information in defaultInfo array      defaultIndex ¬ VAL[StringLookUp.InTable[key: values[0],        table: DESCRIPTOR[tools]]];      String.Replace[        to: @item.defaultInfo[defaultIndex].default,        from: values[1], z: z];      item.defaultInfo[defaultIndex].systemMust ¬ TRUE;      z.FREE[@values[0]];      z.FREE[@values[1]];      z.FREE[@values];      attribute ¬ MyCmFile.FreeString[attribute];      token ¬ MyCmFile.FreeString[token];      [attribute, token] ¬ GetToken[cmH];    ENDLOOP;    IF values # NIL THEN z.FREE[@values]; --*!    END;  GetEnumeratedItems: PROCEDURE [    item: AdobeOps.FieldItemHandle, cmH: MyCmFile.Handle,    dependencyValue: CARDINAL, duplicate: BOOLEAN]    RETURNS [possibilities: AdobeOps.KeyedPossibilities ¬ NIL] =    BEGIN    ENABLE UNWIND => FreePossibilities[possibilities];    labels: ARRAY [0..2) OF LONG STRING ¬ ["name"L, "key"L];    increment: CARDINAL = 5;    values: ValueSequencePtr ¬ NIL;    tempEnumRecs: AdobeOps.EnumeratedSequence ¬ NIL;    seqIndex: CARDINAL ¬ 0;    --initial size to twenty, grow as needed shrink in end if too much    tempEnumRecs ¬ GrowEnumSeq[NIL, 20];    --grow the possibilities sequence by one checking first to see if    --you are growing a new one or an old one     possibilities ¬ GrowPossiblities[      oldPos: IF ~duplicate THEN NIL ELSE      WITH i: item SELECT FROM enumerated => i.possibilities, ENDCASE => ERROR];      --check to make sure there is at least one EnumeratedItem    IF ~String.Equal[attribute, "EnumeratedItem"L] THEN      ERROR ParsingError[missingOrBadAttribute, item.name, "EnumeratedItem"L];    WHILE String.Equal[attribute, "EnumeratedItem"L]  DO      ENABLE UNWIND => {z.FREE[@tempEnumRecs];IF values # NIL THEN { z.FREE[@values[0]]; z.FREE[@values[1]]; z.FREE[@values]}};      --two field names for EnumeratedItem attribute      values ¬ ParseBracketedValues[        DESCRIPTOR[labels] !        ParsingError =>	  --fill in section name and field here          IF type = missingOrBadAttributeValue THEN            ERROR ParsingError[	      type, item.name, "EnumeratedItem"L, seqIndex]];      --add the item you just found      tempEnumRecs[seqIndex] ¬ [        IF values[0] # NIL THEN String.CopyToNewString[values[0], z]        ELSE ERROR ParsingError[	  missingOrBadAttributeValue, item.name, "EnumeratedItem"L,	  seqIndex],        IF values[1] # NIL THEN String.StringToDecimal[values[1]]        ELSE ERROR ParsingError[	  missingOrBadAttributeValue, item.name, "EnumeratedItem"L,	  seqIndex]];      seqIndex ¬ seqIndex + 1;      IF seqIndex >= tempEnumRecs.length THEN        tempEnumRecs ¬ GrowEnumSeq[tempEnumRecs, 10];      z.FREE[@values[0]];      z.FREE[@values[1]];      z.FREE[@values];      attribute ¬ MyCmFile.FreeString[attribute];      token ¬ MyCmFile.FreeString[token];      [attribute, token] ¬ GetToken[cmH];    ENDLOOP;    IF values # NIL THEN z.FREE[@values]; --*!    --copy contents of nilPossibilities, don't just put in pointer--   -- tempEnumRecs[seqIndex] ¬ [String.CopyToNewString[    -- AdobeOps.nilPossibilities[0].string,z],    --  AdobeOps.nilPossibilities[0].value];      tempEnumRecs[seqIndex] ¬ [String.CopyToNewString[        "Nil"L,z], AdobeOps.nilEnum];    -- cut the sequence to exact size and return the possibilities record    possibilities[possibilities.len - 1] ¬ [        dependencyValue, CutSeqToSize[tempEnumRecs, seqIndex + 1]];    z.FREE[@tempEnumRecs];    END;  CutSeqToSize: PROCEDURE [oldArray: AdobeOps.EnumeratedSequence, size: CARDINAL]    RETURNS [concatenatedArray: AdobeOps.EnumeratedSequence] = INLINE    BEGIN    concatenatedArray ¬ z.NEW[AdobeOps.EnumeratedSequenceType [size]];    FOR i: CARDINAL IN [0..size) DO      concatenatedArray[i] ¬ oldArray[i]; ENDLOOP;    END;  GrowPossiblities: PROCEDURE [oldPos: AdobeOps.KeyedPossibilities]    RETURNS [newPos: AdobeOps.KeyedPossibilities] =     BEGIN    IF oldPos = NIL THEN {      newPos ¬ z.NEW[AdobeOps.KeyedPossibilitiesSeq[1]];      newPos[0] ¬ [0, NIL]}    ELSE      BEGIN      newPos ¬ z.NEW[AdobeOps .KeyedPossibilitiesSeq[oldPos.len + 1]];      FOR i: CARDINAL IN [0..oldPos.len) DO newPos[i] ¬ oldPos[i]; ENDLOOP;      z.FREE[@oldPos];      END;    --initialize newly added possibility    newPos[newPos.len - 1] ¬ [0, NIL];    END;  GrowEnumSeq: PROCEDURE [oldSeq: AdobeOps.EnumeratedSequence, increment: CARDINAL]    RETURNS [newSeq: AdobeOps.EnumeratedSequence] =    BEGIN    IF oldSeq = NIL    THEN       BEGIN      newSeq ¬ z.NEW[AdobeOps.EnumeratedSequenceType [increment]];      FOR i: CARDINAL IN [0..increment) DO        newSeq[i] ¬ [NIL, 0];      ENDLOOP;      RETURN[newSeq]      END    ELSE      BEGIN      newSeq ¬ z.NEW[AdobeOps.EnumeratedSequenceType [oldSeq.length + increment]];      FOR i: CARDINAL IN [0..oldSeq.length) DO newSeq[i] ¬ oldSeq[i]; ENDLOOP;      FOR i: CARDINAL IN [oldSeq.length..oldSeq.length + increment) DO        newSeq[i] ¬ [NIL, 0];      ENDLOOP;      z.FREE[@oldSeq];      END;    END;  ParseBracketedValues: PROCEDURE [    labels: StringLookUp.TableDesc]    RETURNS [values: ValueSequencePtr] =    BEGIN    index: CARDINAL ¬ 0;    sh: Token.Handle ¬ NIL;    temp, string, s: LONG STRING ¬ NIL;        MustBeBracketed: Token.FilterProcType = {RETURN[FALSE]};    --allocated return record to size of table     values ¬ z.NEW[ValueSequence [LENGTH[labels]]];    --parse the attribute's value    IF (String.Length[token] > 0) AND (token[0] = '[) THEN       BEGIN      ENABLE UNWIND => {string ¬ Token.FreeTokenString[string]; sh ¬ Token.FreeStringHandle[sh];};      sh ¬ Token.StringToHandle[token];      --strip off brackets      string ¬ Token.MaybeQuoted[        sh, NIL, MustBeBracketed, Token.Brackets        ! Token.UnterminatedQuote => ERROR ParsingError[	  missingOrBadAttributeValue, NIL, NIL]];      sh ¬ Token.FreeStringHandle[sh];      sh ¬ Token.StringToHandle[string];      DO        ENABLE          UNWIND => {temp ¬ Token.FreeTokenString[temp];	     s ¬ Token.FreeTokenString[s];	     sh ¬ Token.FreeStringHandle[sh];	     string ¬ Token.FreeTokenString[string]};        temp ¬ Token.Filtered[sh, NIL, Token.Alphabetic];        -- ': was consumed and now is in sh.break        IF sh.break = Ascii.NUL THEN {temp ¬ Token.FreeTokenString[temp]; EXIT};	        IF (index ¬ StringLookUp.InTable[temp, labels]) < LENGTH[labels] THEN 	 BEGIN	 s ¬ Token.MaybeQuoted[	   h: sh, data: NIL, filter: Token.AlphaNumeric 	   ! Token.UnterminatedQuote => ERROR ParsingError[	     missingOrBadAttributeValue, NIL, NIL]];         values[index] ¬ String.CopyToNewString[            s: s, z: z];         s ¬ Token.FreeTokenString[s]	 END	--the fieldName and item parameters gets filled in one level up        ELSE ERROR ParsingError[missingOrBadAttributeValue, NIL, NIL];        temp ¬ Token.FreeTokenString[temp];        ENDLOOP;      sh ¬ Token.FreeStringHandle[sh];      string ¬ Token.FreeTokenString[string];      END    --the fieldName and item parameters gets filled in one level up    ELSE ERROR ParsingError[missingOrBadAttributeValue, NIL, NIL];    END;  GetDependentInfo: PROCEDURE [    fL: AdobeOps.FieldList, item: CARDINAL, cmH: MyCmFile.Handle]    RETURNS [      dependentField: AdobeOps.DependsOnIndex,      dependentValue: CARDINAL] =    BEGIN    labels: ARRAY [0..2) OF LONG STRING ¬ ["field"L, "item"L];    values: ValueSequencePtr ¬ ParseBracketedValues[DESCRIPTOR[labels] !      ParsingError =>        --fill in the section name and filed item and pass along        IF type = missingOrBadAttributeValue THEN          ERROR ParsingError[type, fL[item].name, "DependsOn"L]];    field: LONG STRING ¬      IF values[0] # NIL THEN String.CopyToNewString[values[0], z]      ELSE ERROR ParsingError[missingOrBadAttributeValue, fL[item].name, "DependsOn"L];    value: LONG STRING ¬      IF values[1] # NIL THEN String.CopyToNewString[values[1], z]      ELSE ERROR ParsingError[missingOrBadAttributeValue, fL[item].name, "DependsOn"L];    [dependentField, dependentValue] ¬ FindDependentEnumerated[field, value, fL];    z.FREE[@field];    z.FREE[@value];    z.FREE[@values[0]];    z.FREE[@values[1]];    z.FREE[@values];    --Token look ahead    attribute ¬ MyCmFile.FreeString[attribute];    token ¬ MyCmFile.FreeString[token];    [attribute, token] ¬ GetToken[cmH];    END;  FindDependentEnumerated: PROCEDURE [    dependentField: LONG STRING, dependentItem: LONG STRING,    fL: AdobeOps.FieldList]    RETURNS [      field: AdobeOps.DependsOnIndex, key: CARDINAL] =    BEGIN    --no dependency    IF String.Equivalent[dependentField, "NIL"L] AND      String.Equivalent[dependentItem, "NIL"L] THEN       RETURN[AdobeOps.nullDependsOnIndex, LAST[CARDINAL]];    FOR i: CARDINAL IN [0..numOfFieldsProcessed) DO      WITH f: fL[i] SELECT FROM        enumerated =>          IF String.Equal[dependentField, f.name] THEN            BEGIN            match: BOOLEAN ¬ FALSE;            field ¬ i;            FOR j: CARDINAL IN [0..f.possibilities.len) DO              FOR k: CARDINAL IN [0..f.possibilities[j].enumRecs.length) DO                IF String.Equal[                  dependentItem, f.possibilities[j].enumRecs[k].string] THEN {                  key ¬ f.possibilities[j].enumRecs[k].value; match ¬ TRUE; EXIT}                ENDLOOP;              ENDLOOP;            IF ~match THEN              ERROR ParsingError[                dependentItemNotFound, fL[numOfFieldsProcessed - 1].name, NIL];            END        ENDCASE;      ENDLOOP;    END;      TellParsingError: PUBLIC PROCEDURE [    type: ParseSystemDescription.ProblemType,    sectionName: LONG STRING, field: LONG STRING,    fieldIndex: CARDINAL ¬ LAST[CARDINAL]]     RETURNS [msgSWMsg, fileSWMsg: LONG STRING ¬ NIL] =  BEGIN ENABLE String.StringBoundsFault => {    String.ExpandString[@fileSWMsg, 20, Heap.systemZone];    RESUME[fileSWMsg]};        fileSWMsg ¬ String.MakeString[Heap.systemZone, 60];    SELECT type FROM    emptyDescription => {      msgSWMsg ¬ "Error - Empty Description!"L;      String.AppendString[fileSWMsg, "Error - "L];      String.AppendString[fileSWMsg, sectionName];      String.AppendString[fileSWMsg, " has an empty description!"L]};    duplicateSection => {      msgSWMsg ¬ "Error - Duplicate Section!"L;      String.AppendString[fileSWMsg, "Error - "L];      String.AppendString[fileSWMsg, sectionName];      String.AppendString[fileSWMsg, " is duplicated!"L]};    dependentItemNotFound => {      msgSWMsg ¬ "Error - Dependent item not found!"L;      String.AppendString[fileSWMsg, "Error - Dependent item not found for section "L];      String.AppendString[fileSWMsg, sectionName]};    notAsManyFieldsAsDescribed => {      msgSWMsg ¬ "Error - Not as many fields as described!"L;      String.AppendString[fileSWMsg, "Error - Not as many fields as described!"L]};    missingOrBadAttribute => {      msgSWMsg ¬ "Error - Missing or bad attribute!"L;      String.AppendString[fileSWMsg, "Error - Missing or bad attribute  "L];      String.AppendString[fileSWMsg, field];      String.AppendString[fileSWMsg, " in "];      String.AppendString[fileSWMsg, sectionName]};    missingOrBadAttributeValue => {      msgSWMsg ¬ "Error - Missing or bad attribute value!"L;      String.AppendString[fileSWMsg, "Error - Missing or bad attribute value for "L];      String.AppendString[fileSWMsg, field];      IF fieldIndex # LAST[CARDINAL] THEN {	String.AppendString[fileSWMsg, " ("L];	String.AppendDecimal[fileSWMsg, fieldIndex];	String.AppendString[fileSWMsg, "th field) "L]};      String.AppendString[fileSWMsg, " in "];      String.AppendString[fileSWMsg, sectionName]};    noarIdGiven => {      msgSWMsg ¬ "Error - No ARId field specified!"L;      fileSWMsg ¬ "Error - No ARId field specified!"L};    moreThanOnearId => {      msgSWMsg ¬ "Error - More than one ARId field specified!"L;      String.AppendString[fileSWMsg, "Error - "L];      String.AppendString[fileSWMsg, sectionName];      String.AppendString[fileSWMsg, " has type ARId but an ARId field has already been defined!"]};    fileNotFound => {      msgSWMsg ¬ "Error - File not found!"L;      fileSWMsg ¬ "Error - File not found!"L};    ENDCASE;    END;  END....
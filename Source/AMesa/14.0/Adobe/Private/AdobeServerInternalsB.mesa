-- File: AdobeServerInternalsB.mesa - created by JCS. Last edit:-- JCS                  4-May-86 18:21:29-- Copyright (C) 1985 , 1986, 1986 by Xerox Corporation. All rights reserved. -- AdobeServerInternalsB.mesa-- RSF      	 4-Apr-86 15:53:50-- JCS      	18-Feb-86 21:18:14-- RLC		 5-Sep-86 14:23:07-- Implements Change Fieldlist DIRECTORY  AdobeCourier USING [DescribeFieldItemObject, LocationOfARs],  AdobeOps USING [    ARNumber, ARSystemHandle, DefaultInfoObject, DependsOnIndex,    EnumeratedSequence, EnumeratedSequenceType, FieldItemHandle,    FieldItemObject, FieldList, FieldListArray, FieldType,    KeyedPossibilities, KeyedPossibilitiesSeq, nilEnum,    nullDependsOnIndex, Possibilities, ToolType],  AdobeServer USING [ChangeType, Reference],  AdobeServerOps USING [    AccTable, AccTableRecord, CreateAcceleratorFile, Data, data,    GetAcceleratorFile, GetLocationOfARsInternal,    MakeAcceleratorFileForFieldInternal, ReadLastARNumberInternal,    SystemIndex, UpdateAcceleratorFieldInternal],  AdobeSetUpdate USING [    CreateStream, GetValueFromTable, PutValueIntoTable, ResetStream],  ARFileAccess USING [    Create, Destroy, Error, ErrorCode, Logon, RetrieveAR, Session,    StoreAR],  Auth USING [IdentityHandle],  Courier USING [Free],  Environment USING [bytesPerPage, wordsPerPage],  NSExec USING [    GetTTY, Handle, PutErrorMessage, PutIndentedMessage, PutMessage],  NSFile USING [    Attribute, AttributesRecord, ChangeAttributes, Delete,    GetAttributes, Handle, Selections, Service, Session],  NSSegment USING [CopyOut, Origin, SetSizeInPages],  NSString USING [    AppendNumber, AppendString, AppendToMesaString, CompareStrings,    CopyString, FreeString, MakeString, nullString, String,    StringFromMesaString],  Space USING [Interval, ScratchMap, Unmap],  Stream USING [Delete, Handle],  String USING [    AppendLongNumber, CopyToNewString, EmptyString, Equal, Equivalent,    MakeString],  TextInput USING [    ChoiceIndex, GetChoice, GetDecimal, GetText, GetYesNo, nilDecimal,    nilString, YesOrNo],  TTY USING [Handle, PutLine, PutString];AdobeServerInternalsB: MONITOR LOCKS data USING data:  AdobeServerOps.Data  IMPORTS    AdobeCourier, AdobeServerOps, AdobeSetUpdate, ARFileAccess,    Courier, NSExec, NSFile, NSSegment, NSString, Space, Stream,    String, TextInput, TTY  EXPORTS AdobeServerOps =  BEGIN OPEN AS: AdobeServerOps;  Modifications: TYPE = RECORD [name, enum, length: BOOLEAN ¬ FALSE];  data: AS.Data = @AS.data;  RemoveField: PUBLIC PROCEDURE [    exec: NSExec.Handle, arSH: AdobeOps.ARSystemHandle, fli: CARDINAL]    RETURNS [newFL: AdobeOps.FieldList, changeMade: BOOLEAN] = {    confirm: TextInput.YesOrNo;    dependedOn: BOOLEAN ¬ FALSE;    dependedOnBy: CARDINAL;    okToDelete: BOOLEAN ¬ TRUE;    string: NSString.String ¬ NSString.MakeString[data.z, 100];    success: BOOLEAN;    newFL ¬ arSH.fieldList;    IF IsARId[@arSH.fieldList[fli]] THEN {      okToDelete ¬ FALSE;      NSExec.PutErrorMessage[exec, S["Can't delete arId field"L]]}    ELSE {      [dependedOn, dependedOnBy] ¬ IsDependedOn[arSH.fieldList, fli];      IF dependedOn THEN {        string ¬ NSString.AppendString[          string, S[          "Can't delete field because it is depended on by "L]];        string ¬ NSString.AppendString[          string, S[arSH.fieldList[dependedOnBy].name]];        NSExec.PutMessage[exec, string];        okToDelete ¬ FALSE}};    IF ~okToDelete THEN RETURN;    string ¬ NSString.AppendString[string, S["Remove "L]];    string ¬ NSString.AppendString[      string, S[arSH.fieldList[fli].name]];    string ¬ NSString.AppendString[string, S["?"L]];    confirm ¬ TextInput.GetYesNo[      tty: NSExec.GetTTY[exec], prompt: string];    string.length ¬ 0;    string ¬ NSString.AppendString[      string, S[arSH.fieldList[fli].name]];    IF confirm # yes THEN {      changeMade ¬ FALSE;      string ¬ NSString.AppendString[string, S[" not removed."L]]}    ELSE {      newFL ¬ data.z.NEW[        AdobeOps .FieldListArray[arSH.fieldList.len - 1]];      FOR i: CARDINAL IN [0..fli) DO        newFL[i] ¬ arSH.fieldList[i]; ENDLOOP;      FOR i: CARDINAL IN [fli + 1..arSH.fieldList.len) DO        newFL[i - 1] ¬ arSH.fieldList[i]; ENDLOOP;      --fix enumerateds dependent on fields whose index changed due to the removal of this field.        AdjustDependsOnIndices[newFL, fli];      success ¬ EditARs[arSH, newFL, remove, fli, exec];      IF success THEN {        WITH arSH.fieldList[fli] SELECT FROM          string => NULL;  --no accel for unbounded string          ENDCASE =>            DeleteAccelerator[              data, arSH.fieldList[fli].name, arSH.name];        -- FREE arSH.fieldList and contents of deleted item. Don't        -- free contents of other items since we just copied the        -- pointers into the new fieldList.        Courier.Free[          [          @arSH.fieldList[fli], AdobeCourier.DescribeFieldItemObject],          data.z];        data.z.FREE[@arSH.fieldList];        string ¬ NSString.AppendString[string, S[" removed."L]];        changeMade ¬ TRUE}      ELSE {        changeMade ¬ FALSE;        string ¬ NSString.AppendString[string, S[" not removed."L]]}};    NSExec.PutIndentedMessage[exec, string];    NSString.FreeString[data.z, string]};  AddField: PUBLIC PROCEDURE [    exec: NSExec.Handle, arSH: AdobeOps.ARSystemHandle,    nextEnum: CARDINAL]    RETURNS [      newEnumStart: CARDINAL, newFL: AdobeOps.FieldList,      changeMade: BOOLEAN] = {    fieldType: AdobeOps.FieldType;    confirm: TextInput.YesOrNo;    tty: TTY.Handle ¬ NSExec.GetTTY[exec];    ns: NSString.String;    newI: CARDINAL ¬ arSH.fieldList.len;    newFL ¬ data.z.NEW[AdobeOps .FieldListArray[newI + 1]];    newEnumStart ¬ nextEnum;    changeMade ¬ TRUE;    --Get type and name    fieldType ¬ GetFieldType[exec];    GetFieldName[TextInput.nilString, @newFL[newI], tty];    IF FindFieldListIndex[newFL[newI].name, arSH.fieldList] # LAST[      CARDINAL] THEN {      NSExec.PutMessage[        exec, S["Field with that name already exists!"L]];      data.z.FREE[@newFL[newI].name];      data.z.FREE[@newFL];      RETURN[nextEnum, arSH.fieldList, FALSE]};    --Get type-dependent attributes    newEnumStart ¬ GetTypeDependentAttributes[      exec, fieldType, arSH.fieldList, LAST[CARDINAL], NIL, @newFL[      newI], newEnumStart];    --Get systemMust defaults    GetSystemMustValues[tty, NIL, @newFL[newI]];    ns ¬ NSString.MakeString[data.z, 100];    ns ¬ NSString.AppendString[ns, S[newFL[newI].name]];    confirm ¬ TextInput.GetYesNo[      tty: tty, prompt: S["Is this right?"L]];    IF confirm # yes THEN {      ns ¬ NSString.AppendString[ns, S[" not added."L]];      changeMade ¬ FALSE;      data.z.FREE[@newFL];      newFL ¬ arSH.fieldList}    ELSE {      ns ¬ NSString.AppendString[ns, S[" added."L]];      AddAccelerator[data, newFL[newI], arSH.name];      FOR i: CARDINAL IN [0..arSH.fieldList.len) DO        newFL[i] ¬ arSH.fieldList[i]; ENDLOOP};    NSExec.PutIndentedMessage[exec, ns];    NSString.FreeString[data.z, ns]};  ModifyField: PUBLIC PROCEDURE [    exec: NSExec.Handle, arSH: AdobeOps.ARSystemHandle,    fieldIndex: CARDINAL, nextEnum: CARDINAL]    RETURNS [newEnumStart: CARDINAL, changeMade: BOOLEAN] = {    confirm: TextInput.YesOrNo;    modified: Modifications;    newFlItem: AdobeOps.FieldItemObject;    newFL: AdobeOps.FieldList;    ns: NSString.String;    success: BOOLEAN;    tty: TTY.Handle ¬ NSExec.GetTTY[exec];    GetFieldName[S[arSH.fieldList[fieldIndex].name], @newFlItem, tty];    modified.name ¬ ~String.Equal[      newFlItem.name, arSH.fieldList[fieldIndex].name];    newEnumStart ¬ GetTypeDependentAttributes[      exec, arSH.fieldList[fieldIndex].type, arSH.fieldList,      fieldIndex, @arSH.fieldList[fieldIndex], @newFlItem, nextEnum];    ns ¬ NSString.MakeString[data.z, 100];    ns ¬ NSString.AppendString[ns, S[newFlItem.name]];    GetSystemMustValues[tty, @arSH.fieldList[fieldIndex], @newFlItem];    confirm ¬ TextInput.GetYesNo[      tty: NSExec.GetTTY[exec], prompt: S["Is this right?"L]];    IF confirm # yes THEN {      ns ¬ NSString.AppendString[ns, S[" not modified."L]];      changeMade ¬ FALSE}    ELSE {      newFL ¬ data.z.NEW[        AdobeOps .FieldListArray[arSH.fieldList.len]];      FOR i: CARDINAL IN [0..fieldIndex) DO        newFL[i] ¬ arSH.fieldList[i]; ENDLOOP;      newFL[fieldIndex] ¬ newFlItem;      FOR i: CARDINAL IN (fieldIndex..arSH.fieldList.len) DO        newFL[i] ¬ arSH.fieldList[i]; ENDLOOP;      modified.enum ¬ CheckEnumState[        arSH.fieldList[fieldIndex], newFlItem];      modified.length ¬        WITH old: arSH.fieldList[fieldIndex] SELECT FROM          fixedLengthString =>            WITH new: newFlItem SELECT FROM              fixedLengthString =>                IF old.maxLength # new.maxLength THEN TRUE ELSE FALSE,              ENDCASE => FALSE          ENDCASE => FALSE;      success ¬        IF ~modified.name AND ~modified.enum THEN TRUE        ELSE EditARs[arSH, newFL, modify, fieldIndex, exec, modified];      IF success THEN {        ModifyAccelerator[          data, arSH.name, newFL, fieldIndex, arSH.fieldList[          fieldIndex].name, exec, modified];        -- FREE arSH.fieldList and contents of replaced item. Don't        -- free contents of other items since we just copied the        -- pointers into the new fieldList.        Courier.Free[          [          @arSH.fieldList[fieldIndex],          AdobeCourier.DescribeFieldItemObject], data.z];        data.z.FREE[@arSH.fieldList];        arSH.fieldList ¬ newFL;        ns ¬ NSString.AppendString[ns, S[" modified."L]];        changeMade ¬ TRUE}      ELSE {        changeMade ¬ FALSE;        ns ¬ NSString.AppendString[ns, S[" not modified."L]]}};    NSExec.PutIndentedMessage[exec, ns];    NSString.FreeString[data.z, ns]};  EditARs: PROCEDURE [    arSH: AdobeOps.ARSystemHandle, newFL: AdobeOps.FieldList,    change: AdobeServer.ChangeType, which: CARDINAL,    exec: NSExec.Handle, modified: Modifications ¬ []]    RETURNS [success: BOOLEAN ¬ TRUE] = {    ar: AdobeOps.ARNumber;    arLoc: AdobeServer.Reference;    attrRec: NSFile.AttributesRecord;    edited: BOOLEAN;    i: CARDINAL ¬ 0;    lastAR: AdobeOps.ARNumber;    newAR, oldAR: Stream.Handle ¬ NIL;    refNum: LONG STRING ¬ "000000"L;    session: ARFileAccess.Session ¬ NIL;    tty: TTY.Handle;    Cleanup: PROCEDURE = {      IF session # NIL THEN ARFileAccess.Destroy[session];      IF newAR # NIL THEN Stream.Delete[newAR];      IF oldAR # NIL THEN Stream.Delete[oldAR]};    BEGIN    ENABLE      ARFileAccess.Error => {        SELECT why FROM          invalidLogin, accessDenied =>            NSExec.PutErrorMessage[              exec, S[              "Adobe service doesn't have correct access to edit ARs."L]];          communicationError =>            NSExec.PutErrorMessage[              exec, S[              "Unable to reach File service containing ARs"L]];          fileServerFull =>            NSExec.PutErrorMessage[              exec, S["File server containing ARs is full"L]];          directoryFull =>            NSExec.PutErrorMessage[              exec, S["Directory containing ARs is full"L]];          ENDCASE;        Cleanup[];        MarkEditFailure[arSH, ar, why];        success ¬ FALSE;        GOTO error};    arLoc ¬ AS.GetLocationOfARsInternal[arSH.name, @attrRec];    lastAR ¬ AS.ReadLastARNumberInternal[arSH.name];    newAR ¬ AdobeSetUpdate.CreateStream[newFL];    oldAR ¬ AdobeSetUpdate.CreateStream[arSH.fieldList];    session ¬ ARFileAccess.Create[data.z, arLoc];    tty ¬ NSExec.GetTTY[exec];    ARFileAccess.Logon[session, data.serviceId];    refNum.length ¬ 0;    TTY.PutString[tty, "Editing ARs: 1"L];    FOR ar IN [1..lastAR] DO      ARFileAccess.RetrieveAR[        session, ar, oldAR !        ARFileAccess.Error =>          SELECT why FROM            arNotFound, invalidARNumber => LOOP;            ENDCASE];      SELECT change FROM        modify => {          IF modified.enum THEN            edited ¬ VerifyEnum[oldAR, newFL, which]          ELSE edited ¬ FALSE;          IF edited THEN            AS.UpdateAcceleratorFieldInternal[              arSH.name, ar, arSH.fieldList[which].name, [              enumerated[AdobeOps.nilEnum]]];          IF modified.name OR edited THEN {            CopyFields[              new: newAR, old: oldAR, from: 0, thru: newFL.len - 1,              to: 0];            ARFileAccess.StoreAR[session, ar, newAR]}};        --add => no editing required for addition        remove => {          CopyFields[            new: newAR, old: oldAR, from: 0, thru: which - 1, to: 0];          CopyFields[            new: newAR, old: oldAR, from: which + 1,            thru: newFL.len - 1, to: which];          ARFileAccess.StoreAR[session, ar, newAR]};        ENDCASE;      IF ar MOD 20 = 0 THEN {        TTY.PutString[tty, ".."L];        String.AppendLongNumber[refNum, ar];        TTY.PutString[tty, refNum];        refNum.length ¬ 0};      AdobeSetUpdate.ResetStream[newAR];      AdobeSetUpdate.ResetStream[oldAR];      ENDLOOP;    IF ar MOD 20 # 0 THEN {      TTY.PutString[tty, ".."L];      String.AppendLongNumber[refNum, ar];      TTY.PutLine[tty, refNum]};    Cleanup[];    EXITS error => NULL;    END};  CopyFields: PROCEDURE [    new, old: Stream.Handle, from, thru, to: CARDINAL] = {    i: CARDINAL ¬ 0;    oldValue: LONG STRING ¬ NIL;    FOR i IN [from..thru] DO      oldValue ¬ AdobeSetUpdate.GetValueFromTable[i, old, data.z];      AdobeSetUpdate.PutValueIntoTable[to, new, oldValue];      to ¬ to + 1;      data.z.FREE[@oldValue];      ENDLOOP};  VerifyEnum: PROCEDURE [    arStream: Stream.Handle, fieldList: AdobeOps.FieldList,    flIndex: CARDINAL] RETURNS [edited: BOOLEAN] = {    oldValue: LONG STRING ¬ AdobeSetUpdate.GetValueFromTable[      flIndex, arStream, data.z];    independentValue: LONG STRING;    key: CARDINAL;    IF String.EmptyString[oldValue] THEN {      data.z.FREE[@oldValue]; RETURN[FALSE]};    WITH fieldList[flIndex] SELECT FROM      enumerated =>        IF field = AdobeOps.nullDependsOnIndex THEN {          IF StillValid[oldValue, possibilities[0]] THEN {            data.z.FREE[@oldValue]; RETURN[FALSE]}          ELSE {            AdobeSetUpdate.PutValueIntoTable[flIndex, arStream, ""L];            data.z.FREE[@oldValue];            RETURN[TRUE]}}        ELSE {          independentValue ¬ AdobeSetUpdate.GetValueFromTable[            field, arStream, data.z];          WITH indep: fieldList[field] SELECT FROM            enumerated =>              FOR i: CARDINAL IN [0..indep.possibilities.len) DO                key ¬ FindValueInPossibilities[                  independentValue, indep.possibilities[i].enumRecs];                IF key # 0 THEN EXIT;                ENDLOOP;            ENDCASE;          FOR i: CARDINAL IN [0..possibilities.len) DO            IF possibilities[i].keyedDependency = key THEN              IF StillValid[oldValue, possibilities[i]] THEN {                data.z.FREE[@oldValue]; RETURN[FALSE]};            ENDLOOP;          AdobeSetUpdate.PutValueIntoTable[flIndex, arStream, ""L]};      ENDCASE};  FindValueInPossibilities: PROCEDURE [    s: LONG STRING, poss: AdobeOps.EnumeratedSequence]    RETURNS [value: CARDINAL] =    BEGIN    FOR i: CARDINAL IN [0..poss.length) DO      IF String.Equivalent[s, poss[i].string] THEN        RETURN[poss[i].value]      ENDLOOP;    RETURN[0];    END;  CheckEnumState: PROCEDURE [    oldItem, newItem: AdobeOps.FieldItemObject]    RETURNS [needToEdit: BOOLEAN ¬ FALSE] = {    WITH new: newItem SELECT FROM      enumerated =>        WITH old: oldItem SELECT FROM          enumerated => {            oldPoss, newPoss: AdobeOps.Possibilities;            i, j: CARDINAL ¬ 0;            IF new.field # old.field THEN RETURN[TRUE];            FOR i IN [0..old.possibilities.len) DO              oldPoss ¬ old.possibilities[i];              FOR j IN [0..new.possibilities.len) DO                IF new.possibilities[j].keyedDependency =                  oldPoss.keyedDependency THEN {                  newPoss ¬ new.possibilities[j]; EXIT};                REPEAT FINISHED => RETURN[TRUE];                ENDLOOP;              FOR j IN [0..oldPoss.enumRecs.length) DO                IF ~StillValid[oldPoss.enumRecs[j].string, newPoss]                  THEN RETURN[TRUE];                ENDLOOP;              ENDLOOP};          ENDCASE => RETURN[FALSE];      ENDCASE => RETURN[FALSE]};  AdjustDependsOnIndices: PROCEDURE [    fL: AdobeOps.FieldList, deleteIndex: CARDINAL] = {    FOR i: CARDINAL IN [0..fL.len) DO      WITH item: fL[i] SELECT FROM        enumerated => {          IF item.field = AdobeOps.nilEnum THEN LOOP;          IF item.field > deleteIndex THEN            item.field ¬ item.field - 1};        ENDCASE;      ENDLOOP};  StillValid: PROCEDURE [    enumString: LONG STRING, poss: AdobeOps.Possibilities]    RETURNS [BOOLEAN] = {    FOR i: CARDINAL IN [0..poss.enumRecs.length) DO      IF String.Equal[enumString, poss.enumRecs[i].string] THEN        RETURN[TRUE];      ENDLOOP;    RETURN[FALSE]};  MarkEditFailure: PROCEDURE [    arSH: AdobeOps.ARSystemHandle, whichAR: AdobeOps.ARNumber,    why: ARFileAccess.ErrorCode] = {    --to allow a change which got killed in the middle to be resumed later when the error condition has been righted.    };  GetFieldType: PROCEDURE [exec: NSExec.Handle]    RETURNS [fieldType: AdobeOps.FieldType] = {    type: CARDINAL;    fields: ARRAY [0..5) OF NSString.String;    fields[0] ¬ S["DateTime"L];    fields[1] ¬ S["Numeric"L];    fields[2] ¬ S["Bounded String"L];    fields[3] ¬ S["Enumerated"L];    fields[4] ¬ S["Unbounded String"L];    type ¬ TextInput.GetChoice[      tty: NSExec.GetTTY[exec], prompt: S["Field Type?"L],      choices: DESCRIPTOR[fields]];    RETURN[VAL[type + 1]]};  GetFieldName: PROCEDURE [    default: NSString.String, newItem: AdobeOps.FieldItemHandle,    tty: TTY.Handle] = {    ns: NSString.String;    newItem.name ¬ String.MakeString[data.z, 40];    ns ¬ S[newItem.name];    ns ¬ TextInput.GetText[      tty: tty, prompt: S["Field Name"L], text: ns, maxLength: 40,      default: default];    newItem.name.length ¬ ns.length};  GetTypeDependentAttributes: PROCEDURE [    exec: NSExec.Handle, fieldType: AdobeOps.FieldType,    fieldList: AdobeOps.FieldList, fieldIndex: CARDINAL,    oldItem, newItem: AdobeOps.FieldItemHandle, nextEnum: CARDINAL]    RETURNS [newEnumStart: CARDINAL] = {    tty: TTY.Handle ¬ NSExec.GetTTY[exec];    SELECT fieldType FROM      arId => newItem.body ¬ arId[];      dateTime => newItem.body ¬ dateTime[];      numeric => newItem.body ¬ numeric[];      fixedLengthString => {        newItem.body ¬ fixedLengthString[];        WITH newItem SELECT FROM          fixedLengthString => {            default: INTEGER;            IF oldItem # NIL THEN              WITH o: oldItem SELECT FROM                fixedLengthString => default ¬ o.maxLength;                ENDCASE            ELSE default ¬ TextInput.nilDecimal;            maxLength ¬ TextInput.GetDecimal[              tty: tty, prompt: S["MaxLength"L], min: 1,              max: Environment.bytesPerPage, default: default]};          ENDCASE};      enumerated => {        newItem.body ¬ enumerated[];        WITH newItem SELECT FROM          enumerated => {            oldDependsOn: INTEGER;            oldDependsOnCard: CARDINAL;            oldPossibilities: AdobeOps.KeyedPossibilities;            IF oldItem # NIL THEN              WITH o: oldItem SELECT FROM                enumerated => {                  oldDependsOn ¬                    IF o.field = AdobeOps.nullDependsOnIndex THEN 0                    ELSE o.field;                  oldDependsOnCard ¬ o.field;                  oldPossibilities ¬ o.possibilities};                ENDCASE            ELSE oldDependsOn ¬ TextInput.nilDecimal;            field ¬ GetDependsOnField[              exec, fieldList, oldItem, oldDependsOn];            IF oldItem = NIL THEN              --enumerated field being added              [possibilities, newEnumStart] ¬ GetNewPossibilities[                exec, field, fieldList, nextEnum]            ELSE              --modifying existing enumerated field               IF field # oldDependsOnCard THEN                --all possibilities change because field depended on                --is now different.                [possibilities, newEnumStart] ¬ GetNewPossibilities[                  exec, field, fieldList, nextEnum]              ELSE                --possibilities will still be dependent on same field                [possibilities, newEnumStart] ¬ ModifyPossibilities[                  exec, field, fieldList, fieldIndex, nextEnum,                  oldPossibilities]};          ENDCASE};      string => newItem.body ¬ string[];      ENDCASE};  GetSystemMustValues: PROCEDURE [    tty: TTY.Handle, oldItem, newItem: AdobeOps.FieldItemHandle] = {    sysMustString: LONG STRING ¬ "SystemMust Default for "L;    ns: NSString.String ¬ NSString.MakeString[data.z, 40];    default: NSString.String ¬ NSString.MakeString[data.z, 100];    ns ¬ NSString.AppendString[ns, S[sysMustString]];    FOR t: AdobeOps.ToolType IN AdobeOps.ToolType DO      newItem.defaultInfo[t] ¬ data.z.NEW[AdobeOps.DefaultInfoObject];      ns.length ¬ sysMustString.length;      ns ¬ NSString.AppendString[ns, ToolTypeString[t]];      default ¬ TextInput.GetText[        tty: tty, prompt: ns, text: default, minLength: 0,        maxLength: 100,        default:        IF oldItem = NIL THEN TextInput.nilString        ELSE S[oldItem.defaultInfo[t].default]];      IF default.length # 0 THEN {        newItem.defaultInfo[t].systemMust ¬ TRUE;        newItem.defaultInfo[t].default ¬ String.MakeString[          data.z, default.length];        NSString.AppendToMesaString[          newItem.defaultInfo[t].default, default]};      ENDLOOP;      NSString.FreeString[data.z, ns];      NSString.FreeString[data.z, default]};  ListEnumeratedSequence: PROCEDURE [    exec: NSExec.Handle, enumRecs: AdobeOps.EnumeratedSequence] = {    s: NSString.String ¬ NSString.MakeString[data.z, 100];    FOR i: CARDINAL IN [0..enumRecs.length) DO      IF enumRecs[i].value = AdobeOps.nilEnum THEN LOOP;      s ¬ NSString.AppendNumber[s, i + 1];      s ¬ NSString.AppendString[s, S[". "L]];      s ¬ NSString.AppendString[s, S[enumRecs[i].string]];      NSExec.PutIndentedMessage[exec, s];      s.length ¬ 0;      ENDLOOP;    NSString.FreeString[data.z, s]};  GetDependsOnField: PROCEDURE [    exec: NSExec.Handle, fieldList: AdobeOps.FieldList,    oldItem: AdobeOps.FieldItemHandle, default: INTEGER]    RETURNS [fLIndex: CARDINAL] = {    index: CARDINAL;    s: NSString.String ¬ NSString.MakeString[data.z, 100];    DO      FOR i: CARDINAL IN [0..fieldList.len) DO        WITH fieldList[i] SELECT FROM          enumerated => {            s.length ¬ 0;            s ¬ NSString.AppendNumber[s, i + 1];            s ¬ NSString.AppendString[s, S[". "L]];            s ¬ NSString.AppendString[s, S[fieldList[i].name]];            NSExec.PutIndentedMessage[exec, s];            s.length ¬ 0};          ENDCASE;        ENDLOOP;      --add one to correspond to printed list.      IF default # 0 THEN default ¬ default + 1;      index ¬ TextInput.GetDecimal[        tty: NSExec.GetTTY[exec],        prompt: S["Enter number (0 if NIL DependsOn"L], min: 0,        max: fieldList.len, default: default];      IF index = 0 THEN {fLIndex ¬ AdobeOps.nullDependsOnIndex; EXIT}      ELSE        WITH fieldList[index - 1] SELECT FROM          enumerated => {            IF String.Equal[fieldList[index - 1].name, oldItem.name]              THEN              NSExec.PutMessage[                exec, S["Can't be dependent on itself."L]]            ELSE {fLIndex ¬ index - 1; EXIT}};          ENDCASE =>            NSExec.PutMessage[              exec, S["You must select an enumerated field!!"L]];      ENDLOOP};  GetNewPossibilities: PROCEDURE [    exec: NSExec.Handle, dependsOn: AdobeOps.DependsOnIndex,    fieldList: AdobeOps.FieldList, nextEnum: CARDINAL]    RETURNS [      possibilities: AdobeOps.KeyedPossibilities,      newNextEnum: CARDINAL] = {    prompt: NSString.String ¬ NSString.MakeString[data.z, 100];    tempPoss: AdobeOps.KeyedPossibilities;    insertPoint, possIndex: CARDINAL ¬ 0;    prompt ¬ NSString.AppendString[      prompt, S["EnumeratedItems dependent on "L]];    insertPoint ¬ prompt.length;    IF dependsOn = AdobeOps.nullDependsOnIndex THEN {      possibilities ¬ data.z.NEW[AdobeOps .KeyedPossibilitiesSeq[1]];      NSExec.PutIndentedMessage[        exec, S["Independent EnumeratedItems"L]];      [possibilities[0].enumRecs, newNextEnum] ¬        GetNewEnumeratedSequence[exec, nextEnum];      possibilities[0].keyedDependency ¬ AdobeOps.nilEnum;      RETURN}    ELSE      WITH f: fieldList[dependsOn] SELECT FROM        enumerated => {          newNextEnum ¬ nextEnum;          tempPoss ¬ data.z.NEW[            AdobeOps .KeyedPossibilitiesSeq[f.possibilities[            0].enumRecs.length]];          FOR i: CARDINAL IN [0..tempPoss.len) DO            IF f.possibilities[0].enumRecs[i].value = AdobeOps.nilEnum              THEN LOOP;            prompt ¬ NSString.AppendString[              prompt, S[f.possibilities[0].enumRecs[i].string]];            NSExec.PutIndentedMessage[exec, prompt];            [tempPoss[possIndex].enumRecs, newNextEnum] ¬              GetNewEnumeratedSequence[exec, newNextEnum];            prompt.length ¬ insertPoint;            IF tempPoss[possIndex].enumRecs # NIL THEN {              tempPoss[possIndex].keyedDependency ¬ f.possibilities[                0].enumRecs[i].value;              possIndex ¬ possIndex + 1};            ENDLOOP;          possibilities ¬ data.z.NEW[            AdobeOps .KeyedPossibilitiesSeq[possIndex]];          FOR i: CARDINAL IN [0..possIndex) DO            possibilities[i] ¬ tempPoss[i]; ENDLOOP};        ENDCASE};  ModifyPossibilities: PROCEDURE [    exec: NSExec.Handle, dependsOn: AdobeOps.DependsOnIndex,    fieldList: AdobeOps.FieldList, fieldIndex: CARDINAL,    nextEnum: CARDINAL, oldPossibilities: AdobeOps.KeyedPossibilities]    RETURNS [      possibilities: AdobeOps.KeyedPossibilities,      newNextEnum: CARDINAL] = {    prompt: NSString.String ¬ NSString.MakeString[data.z, 100];    tempPoss: AdobeOps.KeyedPossibilities;    oldEnumSeq: AdobeOps.EnumeratedSequence;    insertPoint, possIndex: CARDINAL ¬ 0;    prompt ¬ NSString.AppendString[      prompt, S["EnumeratedItems dependent on "L]];    insertPoint ¬ prompt.length;    IF dependsOn = AdobeOps.nullDependsOnIndex THEN {      possibilities ¬ data.z.NEW[AdobeOps .KeyedPossibilitiesSeq[1]];      NSExec.PutIndentedMessage[        exec, S["Independent EnumeratedItems are:"L]];      [possibilities[0].enumRecs, newNextEnum] ¬        ModifyEnumeratedSequence[        exec, fieldList, fieldIndex, nextEnum, oldPossibilities[        0].enumRecs];      possibilities[0].keyedDependency ¬ AdobeOps.nilEnum;      RETURN}    ELSE  --dependent enumerated      WITH f: fieldList[dependsOn] SELECT FROM        enumerated => {          newNextEnum ¬ nextEnum;          tempPoss ¬ data.z.NEW[            AdobeOps .KeyedPossibilitiesSeq[f.possibilities[            0].enumRecs.length]];          FOR i: CARDINAL IN [0..tempPoss.len) DO            IF f.possibilities[0].enumRecs[i].value = AdobeOps.nilEnum              THEN LOOP;            prompt ¬ NSString.AppendString[              prompt, S[f.possibilities[0].enumRecs[i].string]];            prompt ¬ NSString.AppendString[prompt, S[" are:"L]];            oldEnumSeq ¬ NIL;            NSExec.PutIndentedMessage[exec, prompt];            FOR b: CARDINAL IN [0..oldPossibilities.len) DO              IF oldPossibilities[b].keyedDependency =                f.possibilities[0].enumRecs[i].value THEN {                oldEnumSeq ¬ oldPossibilities[b].enumRecs; EXIT};              ENDLOOP;            [tempPoss[possIndex].enumRecs, newNextEnum] ¬              ModifyEnumeratedSequence[              exec, fieldList, fieldIndex, newNextEnum, oldEnumSeq];            prompt.length ¬ insertPoint;            IF tempPoss[possIndex].enumRecs # NIL THEN {              tempPoss[possIndex].keyedDependency ¬ f.possibilities[                0].enumRecs[i].value;              possIndex ¬ possIndex + 1};            ENDLOOP;          possibilities ¬ data.z.NEW[            AdobeOps .KeyedPossibilitiesSeq[possIndex]];          FOR i: CARDINAL IN [0..possIndex) DO            possibilities[i] ¬ tempPoss[i]; ENDLOOP};        ENDCASE};  GetNewEnumeratedSequence: PROCEDURE [    exec: NSExec.Handle, nextAvailValue: CARDINAL]    RETURNS [      enumRecs: AdobeOps.EnumeratedSequence,      newAvailValue: CARDINAL] = {    enumItem: NSString.String ¬ NSString.MakeString[data.z, 100];    listIndex: CARDINAL ¬ 0;    temp: AdobeOps.EnumeratedSequence ¬ data.z.NEW[      AdobeOps .EnumeratedSequenceType[10]];    newAvailValue ¬ nextAvailValue;    DO      enumItem ¬ TextInput.GetText[        tty: NSExec.GetTTY[exec], prompt: S["EnumeratedItem"L],        text: enumItem, minLength: 0, maxLength: enumItem.maxlength];      IF enumItem.length = 0 THEN {        IF listIndex > 0 THEN {          temp[listIndex].string ¬ String.CopyToNewString[            "Nil"L, data.z];          temp[listIndex].value ¬ AdobeOps.nilEnum;          listIndex ¬ listIndex + 1};        EXIT}      ELSE {        temp[listIndex].string ¬ String.MakeString[          data.z, enumItem.length];        NSString.AppendToMesaString[temp[listIndex].string, enumItem];        temp[listIndex].value ¬ newAvailValue;        newAvailValue ¬ newAvailValue + 1;        listIndex ¬ listIndex + 1;        enumItem.length ¬ 0};      ENDLOOP;    IF listIndex = 0 THEN {      data.z.FREE[@temp]; RETURN[NIL, nextAvailValue]}    ELSE {      enumRecs ¬ data.z.NEW[        AdobeOps .EnumeratedSequenceType[listIndex]];      FOR i: CARDINAL IN [0..listIndex) DO        enumRecs[i] ¬ temp[i]; ENDLOOP}};  ModifyEnumeratedSequence: PROCEDURE [    exec: NSExec.Handle, fieldList: AdobeOps.FieldList,    fieldIndex: CARDINAL, nextAvailValue: CARDINAL,    oldEnumSeq: AdobeOps.EnumeratedSequence]    RETURNS [      enumRecs: AdobeOps.EnumeratedSequence,      newAvailValue: CARDINAL] = {    dependedOnBy: CARDINAL ¬ AdobeOps.nilEnum;    enumItem: NSString.String ¬ NSString.MakeString[data.z, 100];    listIndex, delIndex, deletions, finalIndex: CARDINAL ¬ 0;    temp: AdobeOps.EnumeratedSequence ¬ data.z.NEW[      AdobeOps .EnumeratedSequenceType[10]];    toDo: TextInput.ChoiceIndex;    addItem: TextInput.ChoiceIndex ¬ 0;    deleteItem: TextInput.ChoiceIndex ¬ 1;    changes: ARRAY [0..3) OF NSString.String;    changes[addItem] ¬ S["Add"L];    changes[deleteItem] ¬ S["Delete"L];    changes[deleteItem + 1] ¬ S["Done"L];    newAvailValue ¬ nextAvailValue;    --display current values    IF oldEnumSeq = NIL THEN      NSExec.PutIndentedMessage[exec, S["none"L]]    ELSE ListEnumeratedSequence[exec, oldEnumSeq];    [, dependedOnBy] ¬ IsDependedOn[fieldList, fieldIndex];    DO      toDo ¬ TextInput.GetChoice[        tty: NSExec.GetTTY[exec], prompt: S["Indicate change"L],        choices: DESCRIPTOR[changes]];      SELECT toDo FROM        addItem => {          enumItem ¬ TextInput.GetText[            tty: NSExec.GetTTY[exec],            prompt: S["New EnumeratedItem"L], text: enumItem,            minLength: 0, maxLength: enumItem.maxlength];          IF enumItem.length = 0 THEN LOOP;          temp[listIndex].string ¬ String.MakeString[            data.z, enumItem.length];          NSString.AppendToMesaString[            temp[listIndex].string, enumItem];          temp[listIndex].value ¬ newAvailValue;          newAvailValue ¬ newAvailValue + 1;          listIndex ¬ listIndex + 1;          enumItem.length ¬ 0;          IF listIndex = temp.length THEN {            extraTemp: AdobeOps.EnumeratedSequence ¬ data.z.NEW[              AdobeOps .EnumeratedSequenceType[temp.length + 5]];            FOR i: CARDINAL IN [0..temp.length) DO              extraTemp[i] ¬ temp[i]; ENDLOOP;            data.z.FREE[@temp];            temp ¬ extraTemp}};        deleteItem => {          IF oldEnumSeq = NIL THEN {            NSExec.PutIndentedMessage[              exec, S["No values to delete"L]];            LOOP};          ListEnumeratedSequence[exec, oldEnumSeq];          delIndex ¬ TextInput.GetDecimal[            tty: NSExec.GetTTY[exec],            prompt: S["Enter index of item to delete"L], min: 1,            max: oldEnumSeq.length - 1, default: 0];          --need to make sure that nobody depends on this value          IF dependedOnBy = AdobeOps.nilEnum THEN	    oldEnumSeq[delIndex - 1].value ¬ 0	    ELSE IF ~HasDependents[	      NSExec.GetTTY[exec], @fieldList[dependedOnBy],	      oldEnumSeq[delIndex - 1].value] THEN	      oldEnumSeq[delIndex - 1].value ¬ 0};        ENDCASE => EXIT;      ENDLOOP;    --assemble new enumerated sequence based on adds and delete.       IF oldEnumSeq = NIL THEN {      deletions ¬ 0;      IF listIndex = 0 THEN {enumRecs ¬ NIL; RETURN}      ELSE        enumRecs ¬ data.z.NEW[          AdobeOps .EnumeratedSequenceType[listIndex + 1]];      enumRecs[enumRecs.length - 1] ¬ [        String.CopyToNewString["Nil"L, data.z], AdobeOps.nilEnum];      }    ELSE {      FOR i: CARDINAL IN [0..oldEnumSeq.length) DO        IF oldEnumSeq[i].value = 0 THEN deletions ¬ deletions + 1;        ENDLOOP;      enumRecs ¬ data.z.NEW[        AdobeOps        .EnumeratedSequenceType[listIndex + oldEnumSeq.length -                                  deletions]];      enumRecs[enumRecs.length - 1] ¬ [        String.CopyToNewString["Nil"L, data.z], AdobeOps.nilEnum];      FOR i: CARDINAL IN [0..oldEnumSeq.length - 1) DO        IF oldEnumSeq[i].value # 0 THEN {          --must copy out the strings from the old because          --old fieldItem will be freed          enumRecs[finalIndex] ¬ [            String.CopyToNewString[oldEnumSeq[i].string, data.z],            oldEnumSeq[i].value];          finalIndex ¬ finalIndex + 1};        ENDLOOP};    FOR i: CARDINAL IN [0..listIndex) DO      enumRecs[finalIndex] ¬ temp[i];      finalIndex ¬ finalIndex + 1;      ENDLOOP};  ToolTypeString: PROCEDURE [tool: AdobeOps.ToolType]    RETURNS [NSString.String] = {    RETURN[      SELECT tool FROM        edit => S[String.CopyToNewString["Edit"L, data.z]],        submit => S[String.CopyToNewString["Submit"L, data.z]],        report => S[String.CopyToNewString["Report"L, data.z]],        query => S[String.CopyToNewString["Query"L, data.z]],        sort => S[String.CopyToNewString["Sort"L, data.z]],        queryList => S[String.CopyToNewString["QueryList"L, data.z]],        ENDCASE => NSString.nullString]};  DeleteAccelerator: ENTRY PROCEDURE [    data: AS.Data, field, system: LONG STRING] = {    newTable: AS.AccTable;    sysIndex: CARDINAL ¬ AS.SystemIndex[system];    old, new: CARDINAL ¬ 0;    DeleteAcceleratorFile[field, system];    newTable ¬ data.z.NEW[      AS .AccTableRecord[data.systems[sysIndex].accTable.length - 1]];    FOR old IN [0..data.systems[sysIndex].accTable.length) DO      IF NSString.CompareStrings[        data.systems[sysIndex].accTable[old].name, S[field]] = equal        THEN LOOP;      newTable[new] ¬ data.systems[sysIndex].accTable[old];      new ¬ new + 1;      ENDLOOP;    data.z.FREE[@data.systems[sysIndex].accTable];    data.systems[sysIndex].accTable ¬ newTable};  DeleteAcceleratorFile: PROCEDURE [    name: LONG STRING, system: LONG STRING] = {    NSFile.Delete[      AS.GetAcceleratorFile[system, name], data.fileSession]};  AddAccelerator: ENTRY PROCEDURE [    data: AS.Data, fieldItem: AdobeOps.FieldItemObject,    system: LONG STRING] = {    Buffer: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF UNSPECIFIED];    buffer: LONG POINTER TO Buffer;    newAcc: NSFile.Handle;    newTable: AS.AccTable;    numPgs: LONG CARDINAL ¬ 0;    lastAR: AdobeOps.ARNumber ¬ 0;    origin: NSSegment.Origin;    perPg, emptyVal: CARDINAL ¬ 0;    sysIndex: CARDINAL;    WITH fieldItem SELECT FROM      arId, dateTime, numeric => perPg ¬ Environment.wordsPerPage / 2;      fixedLengthString =>        perPg ¬ Environment.bytesPerPage / maxLength;      enumerated => {        perPg ¬ Environment.wordsPerPage;        emptyVal ¬ AdobeOps.nilEnum};      ENDCASE => RETURN;  --this field doesn't have an accelerator file    sysIndex ¬ AS.SystemIndex[system];    newTable ¬ data.z.NEW[      AS .AccTableRecord[data.systems[sysIndex].accTable.length + 1]];    FOR i: CARDINAL IN [0..data.systems[sysIndex].accTable.length) DO      newTable[i] ¬ data.systems[sysIndex].accTable[i]; ENDLOOP;    newTable[data.systems[sysIndex].accTable.length].name ¬      NSString.CopyString[data.z, S[fieldItem.name]];    newTable[data.systems[sysIndex].accTable.length].file ¬ newAcc ¬      AS.CreateAcceleratorFile[      parent: data.systems[sysIndex].adH, fieldName: fieldItem.name];    lastAR ¬ AS.ReadLastARNumberInternal[system];    IF lastAR = 0 THEN {      data.z.FREE[@data.systems[sysIndex].accTable];      data.systems[sysIndex].accTable ¬ newTable;      RETURN};    --Zero out new accelerator file    buffer ¬ Space.ScratchMap[count: 1];    FOR i: CARDINAL IN [0..Environment.wordsPerPage) DO      buffer[i] ¬ emptyVal; ENDLOOP;    numPgs ¬ (lastAR - 1) / perPg;    NSSegment.SetSizeInPages[      file: newAcc, pages: numPgs + 1, session: data.fileSession];    origin ¬ [file: newAcc, base: 0, count: 1];    FOR i: LONG CARDINAL IN [0..numPgs) DO      origin.base ¬ i;      [] ¬ NSSegment.CopyOut[        pointer: buffer, origin: origin, session: data.fileSession];      ENDLOOP;    buffer ¬ Space.Unmap[buffer];    data.z.FREE[@data.systems[sysIndex].accTable];    data.systems[sysIndex].accTable ¬ newTable};  ModifyAccelerator: ENTRY PROCEDURE [    data: AS.Data, systemName: LONG STRING,    newFieldList: AdobeOps.FieldList, fieldIndex: CARDINAL,    oldName: LONG STRING, exec: NSExec.Handle,    modified: Modifications] = {    WITH newFieldList[fieldIndex] SELECT FROM      string => NULL;  --no accelerator for unbounded string      ENDCASE => {        IF modified.name THEN {          --Rename accelerator file          a: ARRAY [0..1) OF NSFile.Attribute ¬ [            [name[value: S[newFieldList[fieldIndex].name]]]];          fH: NSFile.Handle ¬ AS.GetAcceleratorFile[            systemName, oldName];          sysIndex: CARDINAL ¬ AS.SystemIndex[systemName];          NSFile.ChangeAttributes[            fH, DESCRIPTOR[a], data.fileSession];          --fixup accTable sequence          FOR i: CARDINAL IN            [0..data.systems[sysIndex].accTable.length) DO            IF NSString.CompareStrings[              data.systems[sysIndex].accTable[i].name, S[oldName]] =              equal THEN {              NSString.FreeString[                data.z, data.systems[sysIndex].accTable[i].name];              data.systems[sysIndex].accTable[i].name ¬                NSString.CopyString[                data.z, S[newFieldList[fieldIndex].name]];              EXIT};            ENDLOOP};        IF modified.length THEN          AS.MakeAcceleratorFileForFieldInternal[            systemName, fieldIndex, newFieldList, exec]}};  NumberOfChildren: PROCEDURE [directory: NSFile.Handle]    RETURNS [n: CARDINAL] =    BEGIN    attr: NSFile.AttributesRecord;    selections: NSFile.Selections _ [];    selections.interpreted[numberOfChildren] _ TRUE;    NSFile.GetAttributes[      file: directory, selections: selections, attributes: @attr,      session: data.fileSession];    RETURN[attr.numberOfChildren];    END;  FindFieldListIndex: PROCEDURE [    fieldName: LONG STRING, fl: AdobeOps.FieldList]    RETURNS [CARDINAL] = {    FOR i: CARDINAL IN [0..fl.len) DO      IF String.Equal[fl[i].name, fieldName] THEN RETURN[i]; ENDLOOP;    RETURN[LAST[CARDINAL]]};  IsEnumerated: PROCEDURE [fl: AdobeOps.FieldItemHandle]    RETURNS [BOOLEAN] = {    WITH fl­ SELECT FROM      enumerated => RETURN[TRUE];      ENDCASE => RETURN[FALSE]};  IsDependedOn: PROCEDURE [fL: AdobeOps.FieldList, item: CARDINAL]    RETURNS [is: BOOLEAN, by: CARDINAL] = {    FOR i: CARDINAL IN [0..fL.len) DO      WITH f: fL[i] SELECT FROM        enumerated => IF f.field = item THEN RETURN[TRUE, i];        ENDCASE;      ENDLOOP;    RETURN[FALSE, AdobeOps.nilEnum]};  IsARId: PROCEDURE [fl: AdobeOps.FieldItemHandle] RETURNS [BOOLEAN] =    {    WITH fl­ SELECT FROM      arId => RETURN[TRUE];      ENDCASE => RETURN[FALSE]};  HasDependents: PROCEDURE [    tty: TTY.Handle, dependent: AdobeOps.FieldItemHandle,    enumValue: CARDINAL] RETURNS [has: BOOLEAN ¬ FALSE] = {    WITH dependent­ SELECT FROM      enumerated => {        FOR i: CARDINAL IN [0..possibilities.len) DO          IF possibilities[i].keyedDependency = enumValue THEN {            TTY.PutString[              tty, "Cannot delete this enumerated because "L];            TTY.PutString[tty, dependent.name];            TTY.PutLine[tty, " has values depedent on it"L];            RETURN[TRUE]};          ENDLOOP};      ENDCASE};  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  END.  -- RLC		 5-Sep-86 13:19:43 fix NSString leaky sieve
-- File: AdobeCommonImplD.mesa - created by RSF. Last edit:-- JCS                   2-Mar-86 14:43:37-- RSF			10-Apr-86 18:48:07-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved. DIRECTORY  AdobeCommon USING [    DataHandle, GetData, GetDataSW, InitialSetStatus,    PostMessage, StringArray],  AdobeCommonInternal USING [CreateEditSW, CreateReportSW, CreateQuerySW, CreateQuerylistSW, CreateSortSW, CreateSubmitSW, InstanceDataHandle, InstanceData, SetTinyName],  AdobeOps USING [    ARNumber, ARSystemHandle, DependsOnIndex, EnumeratedSequence,    FieldItemObject, FieldList, nilARNumber, nilEnum,    nilPossibilities, nullDependsOnIndex, ToolType, UserOrderSequence,    z],  AdobeToolContext USING [    EnumError, FindPossibilities, FreeUserContext, GetEnumValueFromUC,    GetValueFromEnumString, InitializeUserContext, UserContext,    UserContextHandle],  AdobeToolDriver USING [AddToolDriver],  Cursor USING [GetInfo, Set, Type],  Date USING [PackedToString],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, defaultBoxWidth,    Display, DisplayItem, EnumeratedHandle, EnumeratedItem,    EnumeratedNotifyProcType, FindItem, FreeAllItems, ItemHandle,    ItemObject, LongNumberItem, MenuProcType, newLine, ProcType,    StringItem, ToggleFlag],  Heap USING [systemZone],  Menu USING [Free, Handle, Uninstantiate],  Profile USING [GetUser],  Stream USING [Delete],  String USING [    AppendString, AppendStringAndGrow, Copy, CopyToNewString,    EqualString, ExpandString, FreeString, MakeString, Replace,    StringBoundsFault, StringToLongNumber],  Time USING [Current],  Tool USING [DeleteThisSW, MakeFormSW],  ToolWindow USING [SetName],  UserInput USING [CreatePeriodicNotify, PeriodicProcType,    WaitForConfirmation],  Window USING [Handle];AdobeCommonImplD: MONITOR  IMPORTS    AdobeCommon, AdobeCommonInternal, AdobeOps, AdobeToolContext,    AdobeToolDriver, Cursor, Date, FormSW, Heap, Menu, Profile, Stream,    String, Time, Tool, ToolWindow, UserInput  EXPORTS AdobeCommon, AdobeCommonInternal =  BEGIN  EnumeratedFIH: TYPE = LONG POINTER TO enumerated    AdobeOps.FieldItemObject;  MakeARFormSW: PUBLIC FormSW.ClientItemsProcType = {    i: CARDINAL;    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    context: AdobeToolContext.UserContext ¬ data.context;    tool: AdobeOps.ToolType ¬ data.tool;    arSH: AdobeOps.ARSystemHandle;    arIdPtr: LONG POINTER TO AdobeOps.ARNumber;    stringPtr: LONG POINTER TO LONG STRING;    dateTimePtr: LONG POINTER TO LONG STRING;    numericPtr: LONG POINTER TO LONG CARDINAL;    enumeratedPtr: LONG POINTER TO CARDINAL;    IF context = NIL THEN RETURN;  --No Adobe(System) in User.cm--    arSH ¬ data.context.arSH;    freeDesc ¬ TRUE;    items ¬ FormSW.AllocateItemDescriptor[      arSH.formSWOrderArray[tool].length, data.heap];    FOR i IN [0..arSH.formSWOrderArray[tool].length) DO      --get value address--      WITH c: context.context[arSH.formSWOrderArray[tool][i]] SELECT      FROM        displayedField =>          WITH c.editableField SELECT FROM            arId => arIdPtr ¬ @arn;            fixedLengthString, string => stringPtr ¬ @s;            dateTime => dateTimePtr ¬ @temp;            numeric => numericPtr ¬ @num;            enumerated => enumeratedPtr ¬ @value;            ENDCASE;        ENDCASE => ERROR;      --set up each item --      WITH f: arSH.fieldList[arSH.formSWOrderArray[tool][i]] SELECT      FROM        arId =>          items[i] ¬ FormSW.LongNumberItem[            tag: f.name, readOnly: TRUE,            place: f.defaultInfo[tool].place,            default: AdobeOps.nilARNumber, value: arIdPtr,            boxWidth: f.defaultInfo[tool].width, z: data.heap];        numeric =>          items[i] ¬ FormSW.LongNumberItem[            tag: f.name, readOnly: f.defaultInfo[tool].systemMust,            place: f.defaultInfo[tool].place, value: numericPtr,            default: 0, boxWidth: f.defaultInfo[tool].width,            z: data.heap];        dateTime =>          items[i] ¬ FormSW.StringItem[            tag: f.name, place: f.defaultInfo[tool].place,            string: dateTimePtr, inHeap: TRUE,            boxWidth: f.defaultInfo[tool].width, z: data.heap];        fixedLengthString =>          items[i] ¬ FormSW.StringItem[            tag: f.name, place: f.defaultInfo[tool].place,            string: stringPtr, inHeap: FALSE,            boxWidth: f.defaultInfo[tool].width, z: data.heap];        string =>          items[i] ¬ FormSW.StringItem[            tag: f.name, place: f.defaultInfo[tool].place,            string: stringPtr, inHeap: TRUE,            boxWidth: f.defaultInfo[tool].width, z: data.heap];        enumerated =>          items[i] ¬ FormSW.EnumeratedItem[            tag: f.name, place: f.defaultInfo[tool].place,            value: enumeratedPtr, proc: EnumeratedNotifyProc,            z: data.heap, copyChoices: FALSE,            choices: DESCRIPTOR[GetPossibilities[@f, context].seq]];        ENDCASE => ERROR;      ENDLOOP};  GetPossibilities: PROCEDURE [    item: EnumeratedFIH, context: AdobeToolContext.UserContext]    RETURNS [possibilities: AdobeOps.EnumeratedSequence] =    BEGIN    IF item.field = AdobeOps.nullDependsOnIndex THEN      possibilities ¬ item.possibilities[0].enumRecs    ELSE {      possibilities ¬ AdobeToolContext.FindPossibilities[        AdobeToolContext.GetEnumValueFromUC[context, item.field],        item.possibilities !        AdobeToolContext.EnumError => {          possibilities ¬ AdobeOps.nilPossibilities; CONTINUE}]};    END;  EnumeratedNotifyProc: FormSW.EnumeratedNotifyProcType =    BEGIN    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    arSh: AdobeOps.ARSystemHandle ¬ data.context.arSH;    IF data.context # NIL THEN {  --could it ever be NIL at all?--      instanceData.formDirty ¬ TRUE;      data.context[arSh.formSWOrderArray[data.tool][index]].dirty ¬        TRUE;      FixupEnumeratedItems[        sw, data, arSh.formSWOrderArray[data.tool][index]]};    END;  FixupEnumeratedItems: PROCEDURE [    sw: Window.Handle, windowData: AdobeCommon.DataHandle,    fli: AdobeOps.DependsOnIndex] =    BEGIN    i, itemIndex: CARDINAL;    formItem: FormSW.ItemHandle;    inst: AdobeCommonInternal.InstanceDataHandle ¬ windowData.instanceData;    FOR i IN      [0..windowData.context.arSH.formSWOrderArray[         windowData.tool].length) DO      itemIndex ¬ windowData.context.arSH.formSWOrderArray[        windowData.tool][i];      WITH f: windowData.context.arSH.fieldList[itemIndex] SELECT FROM        enumerated => {          --if changed item is depended on by f--	  formItem ¬ FormSW.FindItem[inst.formSW, i];          IF fli = f.field THEN {	    formItem.flags.invisible ¬ TRUE;            SetChoicesForEnumerated[              sw, windowData, itemIndex, fli, i, TRUE];	    formItem.flags.invisible ¬ FALSE;            IF sw # NIL THEN FormSW.DisplayItem[sw, i]}};        ENDCASE;      ENDLOOP;    END;  SetChoicesForEnumerated: PUBLIC PROCEDURE [    sw: Window.Handle, windowData: AdobeCommon.DataHandle,    itemIndex: CARDINAL, fli: AdobeOps.DependsOnIndex,    displayIndex: CARDINAL, reset: BOOLEAN] =    BEGIN    j: CARDINAL;    effectedItemHandle: LONG POINTER TO enumerated FormSW.ItemObject;    value: CARDINAL;    WITH f: windowData.context.arSH.fieldList[itemIndex] SELECT FROM      enumerated =>        BEGIN        foundOne: BOOLEAN ¬ FALSE;        FOR j IN [0..f.possibilities.len) DO          value ¬ AdobeToolContext.GetEnumValueFromUC[            windowData.context, fli];          IF f.possibilities[j].keyedDependency = value THEN            BEGIN            foundOne ¬ TRUE;            effectedItemHandle ¬ LOOPHOLE[FormSW.FindItem[              sw, displayIndex]];            effectedItemHandle.choices ¬ DESCRIPTOR[              f.possibilities[j].enumRecs];            effectedItemHandle.value ¬ GetEnumValueAddr[              windowData.context, itemIndex];            IF reset THEN              effectedItemHandle.value^ ¬ AdobeOps.nilEnum;            EXIT;            END;          ENDLOOP --FOR j-- ;        IF ~foundOne THEN  --map into "Nil"--          BEGIN  -- nilPossibility may need work          effectedItemHandle ¬ LOOPHOLE[FormSW.FindItem[            sw, displayIndex]];          effectedItemHandle.choices ¬ DESCRIPTOR[            AdobeOps.nilPossibilities];          effectedItemHandle.value ¬ @AdobeOps.nilPossibilities[            0].value;          WITH c: windowData.context.context[itemIndex] SELECT FROM            displayedField =>              WITH c.editableField SELECT FROM                enumerated =>                  value ¬ AdobeOps.nilPossibilities[0].value;                ENDCASE;            ENDCASE;          END;        END;  --enumerated      ENDCASE;  --with f    END;  GetEnumValueAddr: PROCEDURE [    uC: AdobeToolContext.UserContext, index: CARDINAL]    RETURNS [value: LONG POINTER TO UNSPECIFIED] =    BEGIN    WITH displayed: uC[index] SELECT FROM      displayedField =>        WITH body: displayed.editableField SELECT FROM          enumerated => RETURN[@body.value]          ENDCASE => ERROR;      ENDCASE => ERROR;    END;  SetTheDefaults: PUBLIC PROCEDURE [    data: AdobeCommon.DataHandle, sysMustOnly: BOOLEAN] =    BEGIN    index, pos: CARDINAL;    formItem: FormSW.ItemHandle;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    arSH: AdobeOps.ARSystemHandle ¬ data.context.arSH;    fL: AdobeOps.FieldList ¬ arSH.fieldList;    OKToSet: PROCEDURE RETURNS [ok: BOOLEAN] = INLINE {      IF sysMustOnly THEN        ok ¬ fL[index].defaultInfo[data.tool].systemMust      ELSE        ok ¬ (fL[index].defaultInfo[data.tool].default.length # 0)};    LocatePos: PROCEDURE RETURNS [fswIndex: CARDINAL] = {      FOR j: CARDINAL IN [0..arSH.formSWOrderArray[data.tool].length)        DO        IF index = arSH.formSWOrderArray[data.tool][j] THEN RETURN[j];        ENDLOOP;      RETURN[LAST[CARDINAL]]};    FOR index IN [0..arSH.fieldList.len) DO      IF fL[index].defaultInfo[data.tool].default.length = 0 THEN        LOOP;  --don't bother if no default given      IF OKToSet[] THEN {        IF (pos ¬ LocatePos[]) # LAST[CARDINAL] THEN {          formItem ¬ FormSW.FindItem[instanceData.formSW, pos];	  formItem.flags.invisible ¬ TRUE};        SELECT data.tool FROM          submit, edit => {            SetDefault[              data, index, fL[index].defaultInfo[data.tool].default,              data.heap !              AdobeToolContext.EnumError =>                IF why = noMatch THEN {                  AdobeCommon.PostMessage[                    data.msgSW, TRUE, "Invalid defaults!"L];                  CONTINUE}];  --improve this!!            WITH c: data.context[index] SELECT FROM              displayedField =>                WITH c.editableField SELECT FROM                  enumerated =>                    FixupEnumeratedItems[                      instanceData.formSW, data, index];                  ENDCASE;              ENDCASE};          query =>            SetQueryDefault[              data, index, fL[index].defaultInfo[data.tool].default,              data.heap];          report =>            SetReportDefault[              data, index, fL[index].defaultInfo[data.tool].default,              data.heap];          ENDCASE;        IF pos # LAST[CARDINAL] THEN {	  formItem.flags.invisible ¬ FALSE;          FormSW.DisplayItem[instanceData.formSW, pos]};        data.context[index].dirty ¬ TRUE};      ENDLOOP;    END;  SetDefault: PROCEDURE [    data: AdobeCommon.DataHandle, index: CARDINAL,    default: LONG STRING, z: UNCOUNTED ZONE] =    BEGIN    uContext: AdobeToolContext.UserContextHandle ¬      @data.context.context[index];    WITH display: uContext SELECT FROM      nonDisplayedField =>        SetDefaultString[          s: @display.readOnlyField, default: default, z: z];  --what happens if exceeds maxLength of fixedLengthString?      displayedField =>        WITH body: display.editableField SELECT FROM          --never default arId          arId => NULL;          string =>            SetDefaultString[s: @body.s, default: default, z: z];          fixedLengthString =>            SetFixedLengthDefaultString[              s: body.s, default: default, z: z];          dateTime =>            SetDefaultString[s: @body.temp, default: default, z: z];          numeric =>            body.num ¬ CARDINAL[SetDefaultValue[default: default]];          enumerated =>            body.value ¬ SetEnumeratedValue[              data: data, index: index, default: default,              tool: data.tool, z: z];          ENDCASE;      ENDCASE;    END;  SetQueryDefault: PROCEDURE [    data: AdobeCommon.DataHandle, index: CARDINAL,    default: LONG STRING, z: UNCOUNTED ZONE] =    BEGIN    instanceData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    WITH instanceData SELECT FROM      query => SetDefaultString[@queryStrings[index], default, z];      ENDCASE;    END;  SetReportDefault: PROCEDURE [    data: AdobeCommon.DataHandle, index: CARDINAL,    default: LONG STRING, z: UNCOUNTED ZONE] = BEGIN END;  SetDefaultString: PROCEDURE [    s: LONG POINTER TO LONG STRING, default: LONG STRING,    z: UNCOUNTED ZONE] =    BEGIN    reservedDefault: LONG STRING ¬ NIL;    reservedDefault ¬ IsItAReservedDefault[default: default, z: z];    IF reservedDefault # NIL THEN {      String.Replace[to: s, from: reservedDefault, z: z];      z.FREE[@reservedDefault];      }    ELSE String.Replace[to: s, from: default, z: z];    END;  SetFixedLengthDefaultString: PROCEDURE [    s: LONG STRING, default: LONG STRING, z: UNCOUNTED ZONE] =    BEGIN    reservedDefault: LONG STRING ¬ NIL;    reservedDefault ¬ IsItAReservedDefault[default: default, z: z];    IF reservedDefault # NIL THEN {      String.Copy[        to: s, from: reservedDefault !        String.StringBoundsFault => RESUME [NIL]        --copy only what fits-- ];      z.FREE[@reservedDefault];      }    ELSE      String.Copy[        to: s, from: default !        String.StringBoundsFault => RESUME [NIL]        --copy only what fits-- ];    END;  IsItAReservedDefault: PROCEDURE [    default: LONG STRING, z: UNCOUNTED ZONE]    RETURNS [reserved: LONG STRING ¬ NIL] = INLINE    BEGIN    GetName: PROCEDURE [name, password: LONG STRING] =      BEGIN reserved ¬ String.CopyToNewString[name, z]; END;    <<MyStringProc: Format.StringProc = {      reserved ¬ String.CopyToNewString[s, z]};>>    SELECT TRUE FROM      String.EqualString[default, "CurrentTOD"L] => {        temp: LONG STRING ¬ NIL;        reserved ¬ String.CopyToNewString[          temp ¬ Date.PackedToString[Time.Current[]], z];        String.FreeString[z: Heap.systemZone, s: temp]};      String.EqualString[default, "LoginName"] =>        Profile.GetUser[GetName, clearinghouse];      --old code uses PupDefs to get these      <<String.EqualString[default, "HostAddress"L] =>          Format.NetworkAddress[	  MyStringProc,	  AddressTranslation.StringToNetworkAddress[s: "ME"L].addr,	  octal];      String.EqualString[default, "HostName"L] => >>      ENDCASE;    END;  SetDefaultValue: PROCEDURE [default: LONG STRING]    RETURNS [value: LONG CARDINAL] = INLINE    BEGIN    --there is probably some error(s) which should be caught here    value ¬ String.StringToLongNumber[default, 10];    END;  SetEnumeratedValue: PROCEDURE [    data: AdobeCommon.DataHandle, index: CARDINAL,    default: LONG STRING, tool: AdobeOps.ToolType, z: UNCOUNTED ZONE]    RETURNS [value: CARDINAL] = {    value ¬ AdobeToolContext.GetValueFromEnumString[      s: default, uC: data.context, index: index]};  CreateOtherSWs: PUBLIC PROCEDURE [    w: Window.Handle, makeCmdSW: BOOLEAN ¬ TRUE] =    BEGIN    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetData[w];    initialMsg: LONG STRING ¬      SELECT data.tool FROM        edit => AdobeCommonInternal.CreateEditSW[w, makeCmdSW],        submit => AdobeCommonInternal.CreateSubmitSW[w, makeCmdSW],        report => AdobeCommonInternal.CreateReportSW[w, makeCmdSW],        query => AdobeCommonInternal.CreateQuerySW[w, makeCmdSW],        sort => AdobeCommonInternal.CreateSortSW[w, makeCmdSW],        queryList => AdobeCommonInternal.CreateQuerylistSW[          w, makeCmdSW],        ENDCASE => NIL;    AdobeCommon.PostMessage[data.msgSW, TRUE, initialMsg];    AdobeOps.z.FREE[@initialMsg];    AdobeToolDriver.AddToolDriver[data];    END;  DestroyOtherSWs: PUBLIC PROCEDURE [    data: AdobeCommon.DataHandle, killCmdSW: BOOLEAN ¬ TRUE] =    BEGIN    instanceData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    IF instanceData = NIL THEN RETURN;    --delete and/or free formSW-related things    IF instanceData.formSW # NIL THEN {      FormSW.FreeAllItems[instanceData.formSW];      Tool.DeleteThisSW[instanceData.formSW];      instanceData.formSW ¬ NIL};    --  deallocation of instanceData related to formSW only --    WITH i: instanceData SELECT FROM      query =>        IF i.queryStrings # NIL THEN {          FOR j: CARDINAL IN [0..i.queryStrings.length) DO            data.heap.FREE[@i.queryStrings[j]]; ENDLOOP;          data.heap.FREE[@i.queryStrings]};      ENDCASE;    IF killCmdSW THEN {  --delete and/or free all cmdSW-related things      FormSW.FreeAllItems[instanceData.cmdSW];      Tool.DeleteThisSW[instanceData.cmdSW];      instanceData.cmdSW ¬ NIL;      --  deallocation of instanceData for cmdSW --      WITH i: instanceData SELECT FROM        edit => {          Menu.Uninstantiate[menu: i.editMenu, window: data.window];          Menu.Free[menu: i.editMenu, freeStrings: TRUE];          data.heap.FREE[@i.fileName];          IF i.sH # NIL THEN Stream.Delete[i.sH]};        submit => data.heap.FREE[@i.fileName];        report => {          data.heap.FREE[@i.outputFile];          data.heap.FREE[@i.templateFile]};        query => NULL;        sort => {          data.heap.FREE[@i.maxLen];          data.heap.FREE[@i.sortInputFile];          data.heap.FREE[@i.sortOutputFile];          data.heap.FREE[@i.keySpecs]};        --data.heap.FREE[@i.qlName]};        queryList => {          data.heap.FREE[@i.operand1];          data.heap.FREE[@i.operand2];          data.heap.FREE[@i.result]};        ENDCASE;      data.heap.FREE[@data.instanceData]}    ELSE {      --reset form items in the cmdSW (strings get length set to 0 to simplify (de)allocation)      WITH i: instanceData SELECT FROM        edit => {          i.arIdNumber ¬ AdobeOps.nilARNumber;          IF i.sH # NIL THEN {Stream.Delete[i.sH]; i.sH ¬ NIL};          i.useQL ¬ FALSE;          IF i.fileName # NIL THEN i.fileName.length ¬ 0;          IF i.qlName # NIL THEN i.qlName.length ¬ 0;          i.qlSetStatus ¬ AdobeCommon.InitialSetStatus;          i.qlHandle ¬ NIL};        submit => {          IF i.sH # NIL THEN {Stream.Delete[i.sH]; i.sH ¬ NIL};          IF i.fileName # NIL THEN i.fileName.length ¬ 0};        report => {          i.format ¬ plain;          i.overwrite ¬ FALSE;          IF i.outputFile # NIL THEN i.outputFile.length ¬ 0;          IF i.templateFile # NIL THEN i.templateFile.length ¬ 0;          IF i.qlName # NIL THEN i.qlName.length ¬ 0;          };        query => NULL;        sort => {          IF i.maxLen # NIL THEN i.maxLen.length ¬ 0;          IF i.sortInputFile # NIL THEN i.sortInputFile.length ¬ 0;          IF i.sortOutputFile # NIL THEN i.sortOutputFile.length ¬ 0;          IF i.keySpecs # NIL THEN i.keySpecs.length ¬ 0};        --IF i.qlName # NIL THEN        -- i.qlName.length ¬ 0};        queryList => {          IF i.operand1 # NIL THEN i.operand1.length ¬ 0;          IF i.operand2 # NIL THEN i.operand2.length ¬ 0;          IF i.result # NIL THEN i.result.length ¬ 0};        ENDCASE;      FormSW.Display[instanceData.cmdSW]};    END;  SetWindowName: PUBLIC PROCEDURE [    w: Window.Handle, system, toolName: LONG STRING] =    BEGIN    name: LONG STRING ¬ String.CopyToNewString[      s: toolName, z: Heap.systemZone, longer: 25];    toolData: AdobeCommon.DataHandle ¬ AdobeCommon.GetData[w];    IF system # NIL THEN {      String.AppendString[name, " using "L];      String.AppendString[        name, system !        String.StringBoundsFault => {          String.ExpandString[@name, 15, Heap.systemZone];          RESUME [name]}]};    ToolWindow.SetName[w, name];    AdobeCommonInternal.SetTinyName[toolData];    Heap.systemZone.FREE[@name];    END;  FixOrdering: PUBLIC PROCEDURE [    data: AdobeCommon.DataHandle,    formProc: FormSW.ClientItemsProcType, w: Window.Handle,    index: CARDINAL] RETURNS [msg: LONG STRING] =    --Ordering specified is incorrect. Return message and use default    --ordering (ie as though there were no entry for this tool).    --Default values for field items remain unchanged    BEGIN    --have to hang on to ARSystemHandle for use after FreeUserContext    arSH: AdobeOps.ARSystemHandle ¬ data.context.arSH;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    badItem: CARDINAL ¬ arSH.formSWOrderArray[data.tool][index];    msg ¬ String.MakeString[AdobeOps.z, 50];    String.AppendString[msg, "Place given for "L];    String.AppendStringAndGrow[      @msg, arSH.fieldList[badItem].name, AdobeOps.z];    String.AppendStringAndGrow[      @msg, " is illegal. Defaulted to all displayed."L, AdobeOps.z];    AdobeOps.z.FREE[@arSH.formSWOrderArray[data.tool]];    arSH.formSWOrderArray[data.tool] ¬ AdobeOps.z.NEW[      AdobeOps .UserOrderSequence[arSH.fieldList.len]];    FOR i: CARDINAL IN [0..arSH.fieldList.len) DO      arSH.formSWOrderArray[data.tool][i] ¬ i;      arSH.fieldList[i].defaultInfo[data.tool].place ¬ FormSW.newLine;      arSH.fieldList[i].defaultInfo[data.tool].width ¬        FormSW.defaultBoxWidth;      ENDLOOP;    AdobeToolContext.FreeUserContext[@data.context, data.heap];    data.context ¬ AdobeToolContext.InitializeUserContext[      arSH, data.tool, data.heap];    instanceData.formSW ¬ Tool.MakeFormSW[      window: w, formProc: formProc, zone: data.heap];    END;  AllocateInstanceData: PUBLIC PROCEDURE [    data: AdobeCommon.DataHandle]    RETURNS [instanceData: AdobeCommonInternal.InstanceDataHandle] =    BEGIN    instanceData ¬ data.heap.NEW[AdobeCommonInternal.InstanceData];    SELECT data.tool FROM      edit => instanceData.toolData ¬ edit[];      submit => instanceData.toolData ¬ submit[];      report => instanceData.toolData ¬ report[];      query => instanceData.toolData ¬ query[];      sort => instanceData.toolData ¬ sort[];      queryList => instanceData.toolData ¬ queryList[];      ENDCASE;    data.instanceData ¬ instanceData;    END;  SetReadOnlys: PUBLIC PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    itemIndex: CARDINAL;    formItem: FormSW.ItemHandle;    arSH: AdobeOps.ARSystemHandle ¬ data.context.arSH;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    FOR i: CARDINAL IN [0..arSH.formSWOrderArray[data.tool].length) DO      formItem ¬ FormSW.FindItem[instanceData.formSW, i];      itemIndex ¬ arSH.formSWOrderArray[data.tool][i];      formItem.flags.readOnly ¬ arSH.fieldList[itemIndex].defaultInfo[        data.tool].systemMust;      --Make the arId readonly for any tool except query      IF data.tool # query THEN        WITH arSH.fieldList[itemIndex] SELECT FROM          arId => formItem.flags.readOnly ¬ TRUE;          ENDCASE;      ENDLOOP;    END;  SetFieldDirty: PUBLIC FormSW.ProcType = {    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instData: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    instData.formDirty ¬ TRUE;    data.context[      data.context.arSH.formSWOrderArray[data.tool][index]].dirty ¬      TRUE;    FormSW.ToggleFlag[sw, index, modified]};      --this should go into AdobeCommonImplA  waiting: BOOLEAN;  continue: BOOLEAN ¬ FALSE;  Finished: CONDITION;  <<Must make this happen in the Notifier if useBackground is true      (we're coming from a forked process). Else have no control of    cursor form and user could accidentally confirm, thinking he was    doing something else because cursor changed form.>>  ClickToConfirm: PUBLIC ENTRY PROCEDURE [    data: AdobeCommon.DataHandle, couldBeForked: BOOLEAN ¬ TRUE]    RETURNS [confirmed: BOOLEAN] =    BEGIN    inst: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    IF ~inst.background OR ~couldBeForked THEN {      oldCursor: Cursor.Type ¬ Cursor.GetInfo[].type;      Cursor.Set[mouseRed];      confirmed ¬ UserInput.WaitForConfirmation[].okay;      Cursor.Set[oldCursor];      RETURN};    --else we were forked    waiting ¬ TRUE;    continue ¬ FALSE;    [] ¬ UserInput.CreatePeriodicNotify[      WaitForConfirm, data.window, 0];    WHILE waiting DO WAIT Finished ENDLOOP;    confirmed ¬ continue;    END;  WaitForConfirm: ENTRY UserInput.PeriodicProcType = {    oldCursor: Cursor.Type ¬ Cursor.GetInfo[].type;    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetData[window];    Cursor.Set[mouseRed];    continue ¬ UserInput.WaitForConfirmation[].okay;    Cursor.Set[oldCursor];    waiting ¬ FALSE;    NOTIFY Finished;    };    END.
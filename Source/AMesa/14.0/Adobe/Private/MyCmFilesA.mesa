-- Copyright (C) 1981, 1982, 1983, 1985  by Xerox Corporation. All rights reserved. -- File: MyCmFilesA.mesa - last edit:-- SXW   ,	10-Jul-81 17:46:35-- BXM  ,	16-Jul-81 16:28:10-- JGS,		 2-Sep-81  9:47:44-- Tom,		Aug 28, 1979 6:01 PM-- Mark,	15-Jul-81 11:02:48-- PXK    ,	 8-Jan-82 18:20:19-- RXR   ,	13-Oct-81 16:02:24-- SXS   ,	14-Oct-81 10:09:17-- LXR    ,	23-Feb-83 15:04:58-- AXD    ,	21-Sep-82 16:17:38-- CXH   ,	16-Dec-82 17:30:57-- JCS   ,	31-Jul-85 15:51:41DIRECTORY  Ascii USING [CR, NUL, SP, TAB],  MyCmFile USING [ErrorCode, Handle],  Heap: TYPE USING [systemZone],  MFile USING     [dontRelease, Error, GetProperties, Handle, maxNameLength, ReadOnly, Release],  MStream USING [Create, Error, GetFile, Handle, PleaseReleaseProc, ReadOnly],  NSFile USING [Error, Handle, OpenByName, Session],  NSFileStream USING [Create, Handle],  NSString USING [String],  Stream USING [defaultInputOptions, EndOfStream, GetChar, GetPosition, Handle, InputOptions, SetInputOptions, SetPosition],  String USING [    AppendChar, AppendString, Compare, CopyToNewString, EquivalentString,    EquivalentSubString, StringBoundsFault, SubStringDescriptor],  StringLookUp USING [InTable, noMatch, TableDesc],  Token USING [    Brackets, Filtered, FilterProcType, FreeTokenString, FreeStringHandle,    GetCharProcType, Handle, Line, MaybeQuoted, nonQuote, Object,    StringToHandle, QuoteProcType, WhiteSpace],  Volume USING [GetLabelString, systemID];MyCmFilesA: MONITOR  IMPORTS    Heap, MFile, MStream, NSFile, NSFileStream, Stream, String, StringLookUp, Token, Volume  EXPORTS MyCmFile =  BEGIN  -- Global Data  lineSize: CARDINAL = 250;  noSection: LONG CARDINAL = LAST[LONG CARDINAL];  sectionHints: HintHandle ¬ NIL;  userCm: MStream.Handle ¬ NIL;  readingCount: CARDINAL ¬ 0;    z: UNCOUNTED ZONE = Heap.systemZone;  HintHandle: TYPE = LONG POINTER TO HintObject;  HintObject: TYPE = RECORD [    name: LONG STRING ¬ NIL,    position: LONG CARDINAL ¬ 0,    next: HintHandle ¬ NIL];  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE = MACHINE DEPENDENT RECORD [    tokenData: Token.Object,    sh: Stream.Handle,    specificIndex: LONG CARDINAL ¬ noSection];  AbsToRep: PROCEDURE [h: MyCmFile.Handle] RETURNS [Handle] = {RETURN[LOOPHOLE[h]]};  RepToAbs: PROCEDURE [h: Handle] RETURNS [MyCmFile.Handle] = {    RETURN[@h.tokenData]};  Validate: PROCEDURE [h: MyCmFile.Handle] RETURNS [repH: Handle] =    BEGIN    repH ¬ AbsToRep[h];    IF repH.tokenData.getChar # GetChar THEN ERROR Error[invalidHandle];    END;  -- Syntax of a Cm file is:  --   MyCmFile ::= Section | MyCmFile Section  --   Section ::= SectionName SectionBody  --   SectionName ::= beginSectionName NameBody endSectionName  --     NameBody ::= NameBody ~endSectionName | ~endSectionName  --   SectionBody ::= SectionBody SectionLine | SectionLine |  --     SectionLine ::= Name nameBreak MiscLine | MiscLine  --     Name ::= Name ~nameBreak | ~nameBreak  --   MiscLines ::= MiscLines MiscLine | MiscLine |  -- Any line that begins with two commentChar's is ignored, as is any  --   SectionLine that is only a MiscLine.   beginSectionName: CHARACTER = '[;  commentChar: CHARACTER = '-;  endSectionName: CHARACTER = '];  nameBreak: CHARACTER = ':;  separateSectionName: CHARACTER = ':;  -- SIGNALs  Error: PUBLIC SIGNAL [code: MyCmFile.ErrorCode] = CODE;  TableError: PUBLIC SIGNAL [h: MyCmFile.Handle, name: LONG STRING] = CODE;  -- Simple Interface Procedures  FreeString: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [nil: LONG STRING ¬ NIL] =    {Heap.systemZone.FREE[@s]};  Close: PUBLIC PROCEDURE [h: MyCmFile.Handle] RETURNS [nil: MyCmFile.Handle] = {    repH: Handle ¬ Validate[h];    repH.sh.delete[repH.sh];    repH.tokenData.getChar ¬ NIL;  -- make sure deallocated object will not look valid    Heap.systemZone.FREE[@h];    RETURN[h]};  Line: PUBLIC PROCEDURE [fileName, title, name: LONG STRING]    RETURNS [s: LONG STRING] =    -- This is not as quick as it could be, but minimizes code.    -- Note that NextItem will automatically go from generic to specific section.    BEGIN    h: MyCmFile.Handle;    s ¬ NIL;    h ¬ Open[fileName ! Error => GOTO NoFile];    IF FindSection[h, title] THEN      DO        tag, value: LONG STRING;        [tag, value] ¬ NextItem[h ! UNWIND => h ¬ Close[h]];        IF tag = NIL THEN EXIT;        IF String.EquivalentString[name, tag] THEN {          temp: LONG STRING ¬ s; s ¬ value; value ¬ temp};        Heap.systemZone.FREE[@tag];        Heap.systemZone.FREE[@value];        ENDLOOP;    h ¬ Close[h];    EXITS NoFile => NULL;    END;  Open: PUBLIC PROCEDURE [fileName: LONG STRING] RETURNS [h: MyCmFile.Handle] =    BEGIN    repH: Handle;    BEGIN    shortFileName: STRING ¬ [100];    fh: MFile.Handle;    sh: Stream.Handle;    String.AppendString[shortFileName, fileName];    fh ¬ MFile.ReadOnly[      shortFileName, MFile.dontRelease ! MFile.Error => GOTO Lose];    sh ¬ MStream.Create[fh, []       ! MStream.Error => {MFile.Release[fh]; GOTO Lose}];    repH ¬ Heap.systemZone.NEW[      Object ¬ [tokenData: [getChar: GetChar, break: ---- ], sh: sh]];    EXITS Lose => {SIGNAL Error[fileNotFound]; RETURN[NIL]};    END;    h ¬ RepToAbs[repH];    END;      NSOpen: PUBLIC PROCEDURE [fileName: NSString.String, directory: NSFile.Handle, session: NSFile.Session] RETURNS [h: MyCmFile.Handle] =    BEGIN    repH: Handle;    options: Stream.InputOptions  ¬ Stream.defaultInputOptions;    options.signalEndOfStream ¬ TRUE;    BEGIN    fh: NSFile.Handle;    sh: NSFileStream.Handle;    fh ¬ NSFile.OpenByName[directory:directory, path:fileName, session:session      ! NSFile.Error => GOTO Lose];    sh ¬ NSFileStream.Create[      file: fh, session: session ! NSFile.Error => GOTO Lose];    Stream.SetInputOptions[sh, options];    repH ¬ Heap.systemZone.NEW[      Object ¬ [tokenData: [getChar: GetChar, break: ---- ], sh: sh]];    EXITS Lose => {SIGNAL Error[fileNotFound]; RETURN[NIL]};    END;    h ¬ RepToAbs[repH];    END;  ReadLineOrToken: PUBLIC PROCEDURE [    h: Token.Handle, buffer: LONG STRING, terminator: CHARACTER] =    -- Output assertion: h.break is one of terminator, Ascii.CR, or Ascii.NUL    BEGIN    buffer.length ¬ 0;    -- Skip over leading white space    WHILE      SELECT (h.break ¬ h.getChar[h]) FROM        Ascii.SP, Ascii.TAB => TRUE,        ENDCASE => FALSE DO ENDLOOP;    -- Now pick up token (or the line)    DO      SELECT h.break FROM        terminator, Ascii.CR, Ascii.NUL => EXIT;        ENDCASE;      String.AppendChar[        buffer, h.break ! String.StringBoundsFault => GOTO TooMany];      h.break ¬ h.getChar[h];      ENDLOOP;    EXITS TooMany => NULL;    END;  TitleMatch: PUBLIC PROCEDURE [buffer, title: LONG STRING] RETURNS [BOOLEAN] =    BEGIN    llSubString, titleSubString: String.SubStringDescriptor;    IF buffer.length < title.length + 2 OR buffer[0] # beginSectionName      OR buffer[title.length + 1] # endSectionName THEN RETURN[FALSE];    llSubString ¬ [buffer, 1, title.length];    titleSubString ¬ [title, 0, title.length];    RETURN[String.EquivalentSubString[@llSubString, @titleSubString]];    END;      NextSection: PUBLIC PROCEDURE [h: MyCmFile.Handle] RETURNS[title: LONG STRING ¬ NIL] =    BEGIN    localLine: STRING ¬ [lineSize];    repH: Handle = Validate[h];    MustBeBracketed: Token.FilterProcType = {RETURN[FALSE]};    DO      ReadLine[h, localLine];      IF h.break = Ascii.NUL THEN EXIT;      IF localLine.length # 0 AND localLine[0] = beginSectionName THEN	BEGIN	 sh: Token.Handle = Token.StringToHandle[localLine];	 tempString: LONG STRING ¬ Token.MaybeQuoted[	    sh, NIL, MustBeBracketed, Token.Brackets];	 title ¬ String.CopyToNewString[tempString, z];	 [] ¬ Token.FreeTokenString[tempString];	 [] ¬ Token.FreeStringHandle[sh];	 EXIT	END;    ENDLOOP;    END;  -- More efficient ones   FindSection: PUBLIC PROCEDURE [h: MyCmFile.Handle, title: LONG STRING]    RETURNS [opened: BOOLEAN] =    BEGIN    localLine: STRING ¬ [lineSize];    repH: Handle = Validate[h];    genericIndex: LONG CARDINAL ¬ noSection;    qualifiedTitle: LONG STRING;    Volume.GetLabelString[Volume.systemID, localLine];    String.AppendChar[localLine, separateSectionName];    String.AppendString[localLine, title];    qualifiedTitle ¬ String.CopyToNewString[localLine, Heap.systemZone];    -- First try to locate both generic and specific sections    IF IsUserDotCm[repH] THEN {      str: LONG STRING;      doneOne: BOOLEAN ¬ FALSE;      temp: HintHandle;      SELECT String.Compare[qualifiedTitle, title] FROM        -1 => str ¬ qualifiedTitle;	1 => str ¬ title;	ENDCASE;      CheckHints[];      FOR l: HintHandle ¬ sectionHints, temp UNTIL l = NIL DO        SELECT String.Compare[str, l.name] FROM	  0 => {	    IF str = title THEN genericIndex ¬ l.position	    ELSE repH.specificIndex ¬ l.position;	    IF doneOne THEN EXIT;	    temp ¬ l.next};	  1 => {temp ¬ l.next; LOOP};	  ENDCASE => temp ¬ l; -- didn't find first title, so advance to second title	IF doneOne THEN EXIT;	doneOne ¬ TRUE;	IF str = qualifiedTitle THEN str ¬ title ELSE str ¬ qualifiedTitle;	ENDLOOP;      DoneReading[]}    ELSE {     Stream.SetPosition[repH.sh, 0];     DO      ENABLE UNWIND => Heap.systemZone.FREE[@qualifiedTitle];      ReadLine[h, localLine];      IF h.break = Ascii.NUL THEN EXIT;      IF localLine.length # 0 AND localLine[0] = beginSectionName THEN        BEGIN        IF TitleMatch[localLine, qualifiedTitle] THEN          BEGIN          repH.specificIndex ¬ Stream.GetPosition[repH.sh];          IF genericIndex # noSection THEN EXIT;          END;        IF TitleMatch[localLine, title] THEN          BEGIN          genericIndex ¬ Stream.GetPosition[repH.sh];          IF repH.specificIndex # noSection THEN EXIT;          END;        END;      ENDLOOP};    Heap.systemZone.FREE[@qualifiedTitle];    -- Process generic section, then specific section    IF opened ¬ (genericIndex # noSection) THEN      Stream.SetPosition[repH.sh, genericIndex]    ELSE opened ¬ ~TrySpecific[h];    END;  TrySpecific: PROCEDURE [h: MyCmFile.Handle] RETURNS [alreadyDone: BOOLEAN] =    BEGIN    repH: Handle = Validate[h];    IF ~(alreadyDone ¬ (repH.specificIndex = noSection)) THEN {      Stream.SetPosition[repH.sh, repH.specificIndex];      repH.specificIndex ¬ noSection};    END;  NextItem: PUBLIC PROCEDURE [h: MyCmFile.Handle]    RETURNS [name, value: LONG STRING] =    BEGIN    localLine: STRING ¬ [lineSize];    DO      ReadName[h, localLine];      IF h.break = nameBreak THEN EXIT;      IF TrySpecific[h] THEN RETURN[NIL, NIL];      ENDLOOP;    name ¬ String.CopyToNewString[localLine, Heap.systemZone];    value ¬ Token.Filtered[h: h, data: NIL, filter: Token.Line,       skip: whiteSpace, temporary: FALSE];    FOR i: CARDINAL DECREASING IN [0..value.length) DO      IF ~Token.WhiteSpace[value[i], NIL] THEN {value.length ¬ i+1; EXIT};      ENDLOOP;    END;  FindItem: PUBLIC PROCEDURE [h: MyCmFile.Handle, title, name: LONG STRING] RETURNS [found: BOOLEAN] =    BEGIN    localLine: STRING ¬ [lineSize];    IF title # NIL AND ~FindSection[h, title] THEN RETURN[FALSE];    DO      GobbleRestOfLine[h]; -- consume any parts of preceding line left over by client      ReadName[h, localLine];      IF h.break = nameBreak THEN        SELECT TRUE FROM	  String.EquivalentString[name, localLine] => RETURN[TRUE];	  ENDCASE => LOOP;      IF TrySpecific[h] THEN RETURN[FALSE];      ENDLOOP;    END;  NextValue: PUBLIC PROCEDURE [h: MyCmFile.Handle, table: StringLookUp.TableDesc]    RETURNS [index: CARDINAL] =    BEGIN    localLine: STRING ¬ [lineSize];    DO      GobbleRestOfLine[h];  -- consume any parts of preceding line left over by client      ReadName[h, localLine];      IF h.break # nameBreak THEN        IF TrySpecific[h] THEN RETURN[StringLookUp.noMatch]        ELSE {h.break ¬ Ascii.CR; LOOP};      index ¬ StringLookUp.InTable[localLine, table, TRUE, TRUE].index;      IF index < LENGTH[table] THEN EXIT;      SIGNAL TableError[h, localLine];      ENDLOOP;    END;  -- Use "User.cm" as fileName in above  UserDotCmOpen: PUBLIC PROCEDURE RETURNS [h: MyCmFile.Handle] =    BEGIN h ¬ Open["User.cm"L]; END;  UserDotCmLine: PUBLIC PROCEDURE [title, name: LONG STRING]    RETURNS [s: LONG STRING] =    BEGIN s ¬ Line[fileName: "User.cm"L, title: title, name: name]; END;  -- Private Procedures  GetChar: PRIVATE Token.GetCharProcType =    BEGIN    repH: Handle = AbsToRep[h];    c ¬ Stream.GetChar[repH.sh ! Stream.EndOfStream => {c ¬ Ascii.NUL; CONTINUE}]    END;  GobbleRestOfLine: PRIVATE PROCEDURE [h: MyCmFile.Handle] =    BEGIN    WHILE SELECT h.break FROM Ascii.CR, Ascii.NUL => FALSE, ENDCASE => TRUE DO      h.break ¬ h.getChar[h]; ENDLOOP;    END;  IsCommentLine: PRIVATE PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN] =    BEGIN RETURN[s.length > 1 AND s[0] = commentChar AND s[1] = commentChar]; END;  IsUserDotCm: PRIVATE PROCEDURE [repH: Handle] RETURNS [BOOLEAN] =    BEGIN    name: LONG STRING ¬ [MFile.maxNameLength];    [] ¬ MFile.GetProperties[MStream.GetFile[repH.sh], name];    RETURN[String.EquivalentString[name, "User.cm"L]];    END;  ReadLine: PRIVATE PROCEDURE [h: MyCmFile.Handle, buffer: LONG STRING] =    -- Suppresses comment lines    BEGIN    DO      ReadLineOrToken[h, buffer, Ascii.CR];      IF h.break # Ascii.CR OR ~IsCommentLine[buffer] THEN EXIT;      ENDLOOP;    END;  ReadName: PRIVATE PROCEDURE [h: MyCmFile.Handle, buffer: LONG STRING] =    -- Suppresses comment lines and any line that is neither a SectionName    --  nor a SectionLine     -- Output assertion: h.break = Ascii.NUL OR h.break = nameBreak OR    --   h.getChar is positioned just after Ascii.CR    BEGIN    DO      ReadLineOrToken[h, buffer, nameBreak];      IF h.break = Ascii.NUL THEN EXIT;      SELECT buffer.length FROM         # 0 => IF buffer[0] = beginSectionName THEN {          GobbleRestOfLine[h]; h.break ¬ Ascii.NUL; EXIT}        ELSE IF h.break = nameBreak THEN EXIT;	 0 => IF h.break = Ascii.CR THEN EXIT; --end of section      ENDCASE;      GobbleRestOfLine[h];      ENDLOOP;    END;  MyCmFileQuote: Token.QuoteProcType =    BEGIN RETURN[SELECT c FROM '" => c, ENDCASE => Token.nonQuote]; END;  CheckHints: ENTRY PROCEDURE =    BEGIN     localLine: STRING ¬ [lineSize];    list, l: HintHandle ¬ NIL;    position: LONG CARDINAL;    name: LONG STRING ¬ NIL;    index: CARDINAL ¬ 0;    tokenHandle: Token.Object ¬ [getChar, Ascii.NUL];    getChar: Token.GetCharProcType = {    c ¬ Stream.GetChar[userCm ! Stream.EndOfStream => {c ¬ Ascii.NUL; CONTINUE}]};        IF sectionHints # NIL THEN {readingCount ¬ readingCount + 1; RETURN};    userCm ¬ MStream.ReadOnly["User.cm"L, [myRelease, NIL] ! MStream.Error => CONTINUE];    IF userCm = NIL THEN {SIGNAL Error[fileNotFound]; RETURN};    DO      ReadLine[@tokenHandle, localLine];      IF tokenHandle.break = Ascii.NUL THEN EXIT;      IF localLine.length = 0 OR localLine[0] # beginSectionName THEN LOOP;      position ¬ Stream.GetPosition[userCm];      FOR index IN [1..localLine.length) DO        IF localLine[index] = endSectionName THEN EXIT;        REPEAT FINISHED => LOOP;	ENDLOOP;      name ¬ z.NEW[StringBody[index - 1]];      FOR i: CARDINAL  IN [1..index) DO name[i - 1] ¬ localLine[i] ENDLOOP;      name.length ¬ index - 1;      IF list = NIL THEN list ¬ z.NEW[HintObject ¬ [name, position, list]]      ELSE SELECT String.Compare[name, list.name] FROM        -1 => list  ¬ z.NEW[HintObject ¬ [name, position, list]];        0 => z.FREE[@name];        ENDCASE => {          FOR l ¬ list, l.next UNTIL l.next = NIL DO             SELECT String.Compare[name, l.next.name] FROM              -1 => EXIT;              0 => {z.FREE[@name]; EXIT};              ENDCASE;	    ENDLOOP;	  IF name # NIL THEN 	    l.next  ¬ z.NEW[HintObject ¬ [name, position, l.next]]};       ENDLOOP;    sectionHints ¬ list;    readingCount ¬ readingCount + 1;    END;  DoneReading: ENTRY PROCEDURE = {readingCount ¬ readingCount - 1};  myRelease: ENTRY MStream.PleaseReleaseProc =    BEGIN    list: HintHandle ¬ sectionHints;    IF readingCount > 0 THEN RETURN[no];    WHILE sectionHints # NIL DO      list ¬ sectionHints.next;      z.FREE[@sectionHints.name];      z.FREE[@sectionHints];      sectionHints ¬ list      ENDLOOP;    sectionHints ¬ NIL;    userCm ¬ NIL;    RETURN[goAhead]    END;END.  -- of MyCmFilesA
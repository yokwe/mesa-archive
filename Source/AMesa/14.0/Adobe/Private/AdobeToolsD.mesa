-- File: AdobeToolsD.mesa - created by JCS. Last edit:-- JCS                   4-Mar-86 14:08:06-- RSF			17-Apr-86 18:14:39-- RLC			14-May-87 13:54:20 -- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved. -- SortDIRECTORY  AdobeCommon USING [    CatchErrors, DataHandle, DisableAdobeAborts, GetData, GetDataSW,    PostMessage, PostNumber],  AdobeCommonInternal USING [    AllocateInstanceData, InstanceDataHandle, SetWindowName,    sortHeraldName],  Ascii USING [CR, NUL],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, DisplayItem, FindItem, ItemHandle, line0, nextLine,    ProcType, sameLine, StringItem],  GSort USING [CompareProcType, GetProcType, PutProcType, Sort],  Heap,  MsgSW USING [Clear],  MStream USING [    EndOf, Error, Handle, ReadOnly, ReleaseData, WriteOnly],  Process USING [Detach, GetCurrent],  Stream USING [    Delete, EndOfStream, GetChar, PutChar, PutString, SetPosition],  String USING [    AppendChar, AppendCharAndGrow, AppendNumber, AppendString,    AppendStringAndGrow, CopyToNewString, Equivalent, ExpandString,    FreeString, MakeString, StringBoundsFault, StringToLongNumber,    UpperCase, WordsForString],  TajoMisc USING [toolDriverRunning],  Tool USING [MakeFormSW],  Window USING [Handle];AdobeToolsD: PROGRAM  IMPORTS    AdobeCommon, AdobeCommonInternal, FormSW, GSort, Heap, MsgSW,    MStream, Process, Stream, String, TajoMisc, Tool  EXPORTS AdobeCommonInternal =  BEGIN  --globals for sort  sortPos: CARDINAL = 0;  showPos: CARDINAL = 1;  sortBkgdPos: CARDINAL = 2;  maxLenPos: CARDINAL = 3;  inputPos: CARDINAL = 4;  outputPos: CARDINAL = 5;  keyspecsPos: CARDINAL = 6;  nSortParams: CARDINAL = 7;  LT: INTEGER = -1;  EQ: INTEGER = 0;  GT: INTEGER = 1;  adobeBytesPerPage: LONG CARDINAL = 65536;  SortKeySpec: TYPE = LONG POINTER TO SortKeySpecItem;  SortKeySpecItem: TYPE = RECORD [    posInSortKeyFile: CARDINAL,    ascending: BOOLEAN,    next: SortKeySpec];  SortStringBuffer: TYPE = RECORD [s: LONG STRING];  CreateSortSW: PUBLIC PROCEDURE [    w: Window.Handle, makeCmdSW: BOOLEAN ¬ TRUE]    RETURNS [initialMsg: LONG STRING ¬ NIL] =    BEGIN    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetData[w];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    IF makeCmdSW THEN {      instanceData ¬ AdobeCommonInternal.AllocateInstanceData[data];      instanceData.cmdSW ¬ Tool.MakeFormSW[        window: w, formProc: SortCmdSW, zone: data.heap]};    --has no formSW    instanceData.formSW ¬ NIL;    AdobeCommon.DisableAdobeAborts[w];    AdobeCommonInternal.SetWindowName[      w,      IF data.knownSystems # NIL AND data.context # NIL      AND data.system # LAST[CARDINAL] THEN data.knownSystems[      data.system] ELSE NIL, AdobeCommonInternal.sortHeraldName];    END;  SortCmdSW: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    WITH sortToolData: instanceData SELECT FROM      sort => {        items ¬ AllocateItemDescriptor[nSortParams, windowData.heap];        freeDesc ¬ TRUE;        items[sortPos] ¬ CommandItem[          tag: "Sort"L, place: [0, line0], proc: SortCommandProc,          z: windowData.heap];        items[showPos] ¬ CommandItem[          tag: "Show Sortkeys"L, proc: SortCommandProc,          z: windowData.heap];        items[sortBkgdPos] ¬ BooleanItem[          tag: "Use background"L, switch: @sortToolData.background,          z: windowData.heap];        items[maxLenPos] ¬ StringItem[          tag: "Max output file length"L,          string: @sortToolData.maxLen, z: windowData.heap,          inHeap: TRUE];        items[inputPos] ¬ StringItem[          tag: "Input File"L, place: [0, nextLine],          string: @sortToolData.sortInputFile, z: windowData.heap,          inHeap: TRUE];        items[outputPos] ¬ StringItem[          tag: "Output File"L, string: @sortToolData.sortOutputFile,          place: [225, sameLine], z: windowData.heap, inHeap: TRUE];        items[keyspecsPos] ¬ StringItem[          tag: "Key specs"L, string: @sortToolData.keySpecs,          place: [0, nextLine], z: windowData.heap, inHeap: TRUE]};      ENDCASE => ERROR;  --shouldn't happen    END;  SortCommandProc: FormSW.ProcType =    BEGIN    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    MsgSW.Clear[windowData.msgSW];    IF windowData.system = LAST[CARDINAL] OR windowData.context = NIL      OR windowData.knownSystems = NIL      OR windowData.knownSystems.next = 0 THEN {      AdobeCommon.PostMessage[        windowData.msgSW, TRUE, "No available systems"L];      RETURN};    IF windowData.isBusy THEN      AdobeCommon.PostMessage[        windowData.msgSW, TRUE,        "Adobe system is Busy.  Please try again later. "L]    ELSE {      windowData.isBusy ¬ TRUE;      IF instanceData.background AND ~TajoMisc.toolDriverRunning THEN        Process.Detach[          windowData.processID ¬ FORK AdobeCommon.CatchErrors[          sw, item, index, windowData, ChooseSortCmd]]      ELSE {        windowData.processID ¬ Process.GetCurrent[];        AdobeCommon.CatchErrors[          sw, item, index, windowData, ChooseSortCmd]}};    END;  ChooseSortCmd: FormSW.ProcType =    BEGIN    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    BEGIN    ENABLE UNWIND => windowData.isBusy ¬ FALSE;    SELECT index FROM      sortPos => Sort[windowData];      showPos => ShowSortKeys[windowData];      ENDCASE => ERROR;    windowData.isBusy ¬ FALSE;    windowData.processID ¬ NIL;    AdobeCommon.PostMessage[windowData.msgSW, TRUE, "Done. "L];    END;    END;  Sort: PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    outputFileName: LONG STRING ¬ NIL;    sortKeySpec: SortKeySpec ¬ NIL;    numberOfKeySpecsEntered: CARDINAL ¬ 0;    maxCharsAllStrings: CARDINAL ¬ 100;  --will be reset later    headerLength, currentFileLength, maxFileLength: LONG CARDINAL ¬ 0;    maxWordsThisString, maxWordsAllStrings: CARDINAL ¬ SIZE[      StringBody];    sortStringBuffer: LONG STRING ¬ String.MakeString[      Heap.systemZone, 100];    sortKeyStringBuffer: LONG STRING ¬ String.MakeString[      Heap.systemZone, 100];    tempstring: LONG STRING ¬ String.MakeString[data.heap, 10];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    WITH sortData: instanceData SELECT FROM      sort => {        ENABLE          BEGIN          UNWIND => {            IF sortData.inputSH # NIL THEN              sortData.inputSH ¬ CleanUpStream[sortData.inputSH];            IF sortData.outputSH # NIL THEN              sortData.outputSH ¬ CleanUpStream[sortData.outputSH];            IF sortData.sortKeysSH # NIL THEN              sortData.sortKeysSH ¬ CleanUpStream[                sortData.sortKeysSH];            Heap.systemZone.FREE[@sortStringBuffer];            Heap.systemZone.FREE[@sortKeyStringBuffer];            data.heap.FREE[@tempstring];            data.heap.FREE[@outputFileName];            IF sortKeySpec # NIL THEN              FreeSortKeySpec[data, sortKeySpec];            };          END;        SortKeysGetString: PROCEDURE [sortKeyString: LONG STRING]          RETURNS [CARDINAL] =          BEGIN          char: CHARACTER;          result: CARDINAL ¬ 0;          keySpec: SortKeySpec ¬ sortKeySpec;          --put a single line of the sortkeys file into a buffer called sortStringBuffer          sortStringBuffer.length ¬ 0;          --sortKeyString.length ¬ 0;          sortKeyString­ ¬ [            length: 0, maxlength: maxCharsAllStrings, text:];          IF ~MStream.EndOf[stream: sortData.sortKeysSH] THEN            char ¬ Stream.GetChar[sortData.sortKeysSH];          WHILE ~MStream.EndOf[stream: sortData.sortKeysSH]            AND char # Ascii.CR DO            String.AppendChar[              sortStringBuffer, char !              String.StringBoundsFault => {                String.ExpandString[                  @sortStringBuffer, 40, Heap.systemZone];                RESUME [ns ¬ sortStringBuffer]}];            char ¬ Stream.GetChar[sortData.sortKeysSH];            ENDLOOP;          --this creates a new string with the fields in sorted order          IF sortStringBuffer.length = 0 THEN RETURN[0];          UNTIL keySpec = NIL DO            pos, index: CARDINAL ¬ 0;            --finds the position of the field in the sortstringbuffer            WHILE keySpec.posInSortKeyFile # pos DO              WHILE sortStringBuffer[index] # Ascii.NUL DO                index ¬ index + 1; ENDLOOP;              pos ¬ pos + 1;              index ¬ index + 1;              ENDLOOP;  --of while loop            WHILE sortStringBuffer[index] # Ascii.NUL DO              String.AppendChar[                sortKeyString, sortStringBuffer[index] !                String.StringBoundsFault => {                  String.ExpandString[                    @sortKeyString, 40, Heap.systemZone];                  RESUME [ns ¬ sortKeyString]}];              index ¬ index + 1;              ENDLOOP;  --of while loop;            String.AppendChar[              sortKeyString, Ascii.NUL !              String.StringBoundsFault => {                String.ExpandString[                  @sortKeyString, 40, Heap.systemZone];                RESUME [ns ¬ sortKeyString]}];            keySpec ¬ keySpec.next;            ENDLOOP;  --of until loop          RETURN[String.WordsForString[sortKeyString.length]];          END;  --of SortKeysGetString        SortKeysPutString: PROCEDURE [s: LONG STRING, len: CARDINAL] =          BEGIN          count, index: CARDINAL ¬ 0;          i, pagePos, bytePos, lenPos: LONG CARDINAL ¬ 0;          GetString: PROCEDURE RETURNS [LONG CARDINAL ¬ 0] =            BEGIN            tempstring.length ¬ 0;            WHILE s[index] # Ascii.NUL DO              String.AppendChar[tempstring, s[index]];              index ¬ index + 1;              ENDLOOP;            index ¬ index + 1;            RETURN[String.StringToLongNumber[tempstring, 10]];            END;  --of GetString          --pass the beginning of s until the position values are reached          --x is number or character          --n is a number          --z is the nul character          --s looks like x..xzx..xz...x..xzn..nzn..nzn..n          UNTIL count = numberOfKeySpecsEntered DO            WHILE s[index] # Ascii.NUL DO index ¬ index + 1; ENDLOOP;            count ¬ count + 1;            index ¬ index + 1;            ENDLOOP;          pagePos ¬ GetString[];          bytePos ¬ GetString[];          lenPos ¬ GetString[];          IF currentFileLength + lenPos > maxFileLength THEN {            sortData.outputSH ¬ CleanUpStream[sortData.outputSH];            currentFileLength ¬ GetNextFileAndPutHeader[              data, outputFileName, headerLength];            sortData.fileNumber ¬ sortData.fileNumber + 1};          Stream.SetPosition[            sortData.inputSH,            (adobeBytesPerPage * pagePos + bytePos)];          FOR i IN [1..lenPos] DO            Stream.PutChar[              sortData.outputSH, Stream.GetChar[sortData.inputSH]];            ENDLOOP;  --of for loop          currentFileLength ¬ currentFileLength + lenPos;          END;  --of SortKeysPutString        CompareStrings: PROCEDURE [p1: LONG STRING, p2: LONG STRING]          RETURNS [INTEGER] =          BEGIN          index, count: CARDINAL ¬ 0;          keySpecPtr: SortKeySpec ¬ sortKeySpec;          DO            IF p1[index] = Ascii.NUL AND p2[index] = Ascii.NUL THEN {              index ¬ index + 1;              count ¬ count + 1;              keySpecPtr ¬ keySpecPtr.next;              IF count = numberOfKeySpecsEntered THEN RETURN[EQ]}  --0 means equal            ELSE {              IF p1[index] = Ascii.NUL THEN {                IF keySpecPtr.ascending THEN RETURN[LT]                ELSE RETURN[GT]}              ELSE                IF p2[index] = Ascii.NUL THEN {                  IF keySpecPtr.ascending THEN RETURN[GT]                  ELSE RETURN[LT]};	      p1[index] ¬ String.UpperCase[p1[index]];	      p2[index] ¬ String.UpperCase[p2[index]];	      SELECT TRUE FROM		p1[index] < p2[index] =>		  IF keySpecPtr.ascending THEN RETURN[LT]		  ELSE RETURN[GT];		p1[index] > p2[index] =>		  IF keySpecPtr.ascending THEN RETURN[GT]		  ELSE RETURN[LT];		ENDCASE;	      index ¬ index + 1};            ENDLOOP;  --of DO          END;  --of CompareStrings        AdobeCommon.PostMessage[data.msgSW, TRUE, "Sorting."];        [currentFileLength, maxFileLength, headerLength,          numberOfKeySpecsEntered, outputFileName] ¬          InitializeSortVariables[data, @sortKeySpec];        ReadFirstLine[sortData.sortKeysSH];        WHILE maxWordsThisString # 0 DO          maxWordsThisString ¬ SortKeysGetString[sortKeyStringBuffer];          maxWordsAllStrings ¬ MAX[            maxWordsThisString, maxWordsAllStrings];          ENDLOOP;        maxCharsAllStrings ¬ 2 * maxWordsAllStrings;        sortStringBuffer ¬ String.MakeString[          Heap.systemZone, maxCharsAllStrings];        ReadFirstLine[sortData.sortKeysSH];        IF sortKeySpec = NIL THEN          CopyInputFileToOutputFile[            data, outputFileName, maxFileLength, tempstring,            headerLength]          --no sorting necessary        ELSE          GSort.Sort[            get: LOOPHOLE[SortKeysGetString],            put: LOOPHOLE[SortKeysPutString],            compare: LOOPHOLE[CompareStrings],            expectedItemSize: maxWordsAllStrings,            maxItemSize: maxWordsAllStrings, pagesInHeap: 127];        IF maxFileLength # LAST[LONG CARDINAL] THEN {          AdobeCommon.PostMessage[            data.msgSW, FALSE, "Output Files: "L];          AdobeCommon.PostMessage[data.msgSW, FALSE, outputFileName];          AdobeCommon.PostMessage[data.msgSW, FALSE, "1.."L];          AdobeCommon.PostMessage[data.msgSW, FALSE, outputFileName];          AdobeCommon.PostNumber[            data.msgSW, TRUE, sortData.fileNumber - 1]};        --free storage        Heap.systemZone.FREE[@sortStringBuffer];        Heap.systemZone.FREE[@sortKeyStringBuffer];        data.heap.FREE[@tempstring];        data.heap.FREE[@outputFileName];        IF sortKeySpec # NIL THEN FreeSortKeySpec[data, sortKeySpec];        sortData.sortKeysSH ¬ CleanUpStream[sortData.sortKeysSH];        sortData.inputSH ¬ CleanUpStream[sortData.inputSH];        sortData.outputSH ¬ CleanUpStream[sortData.outputSH];        };      ENDCASE;    END;  --of Sort  ShowSortKeys: PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    char: CHARACTER;    --not sure about the size of string    sortKey: LONG STRING ¬ String.MakeString[data.heap, 16];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    WITH sortData: instanceData SELECT FROM      sort => {        ENABLE {          UNWIND => {            IF sortData.sortKeysSH # NIL THEN              sortData.sortKeysSH ¬ CleanUpStream[                sortData.sortKeysSH];            String.FreeString[data.heap, sortKey]}};        IF sortData.sortInputFile = NIL          OR sortData.sortInputFile.length = 0 THEN {          AdobeCommon.PostMessage[            data.msgSW, TRUE, "No input file specified."L];          ERROR ABORTED};        GetSortKeysFile[data];        IF sortData.sortKeysSH # NIL THEN {          AdobeCommon.PostMessage[            data.msgSW, FALSE, "Choose from these sort keys: "L];          char ¬ Stream.GetChar[sortData.sortKeysSH];          WHILE char # Ascii.CR DO            IF char = Ascii.NUL THEN {              AdobeCommon.PostMessage[data.msgSW, FALSE, sortKey];              --ClearString[sortKey];              sortKey.length ¬ 0;              char ¬ Stream.GetChar[sortData.sortKeysSH];              IF char # Ascii.CR THEN {                AdobeCommon.PostMessage[data.msgSW, FALSE, ", "L];                String.AppendCharAndGrow[@sortKey, char, data.heap]}              ELSE EXIT;              }            ELSE String.AppendCharAndGrow[@sortKey, char, data.heap];            char ¬ Stream.GetChar[sortData.sortKeysSH];            ENDLOOP;          AdobeCommon.PostMessage[data.msgSW, TRUE, " "L]}        ELSE {          AdobeCommon.PostMessage[            data.msgSW, TRUE, "the sortkeys file does not exist"L];          ERROR ABORTED};        sortData.sortKeysSH ¬ CleanUpStream[sortData.sortKeysSH];        };      ENDCASE;  --should not happen    String.FreeString[data.heap, sortKey];    END;  --of ShowSortKeys  InitializeSortVariables: PROCEDURE [    data: AdobeCommon.DataHandle,    ptrToSortKeySpec: POINTER TO SortKeySpec]    RETURNS [      currentFileLength: LONG CARDINAL,      maxFileLength, headerLength: LONG CARDINAL,      numberOfKeySpecsEntered: CARDINAL,      outputFileName: LONG STRING] =    BEGIN    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    numberofSortKeys: CARDINAL ¬ 0;    currentFileLength ¬ 0;    WITH sortData: instanceData SELECT FROM      sort => {        IF sortData.sortInputFile = NIL          OR sortData.sortInputFile.length = 0 THEN {          AdobeCommon.PostMessage[            data.msgSW, TRUE, "ERROR--no input file specified."L];          ERROR ABORTED};        IF sortData.sortOutputFile = NIL          OR sortData.sortOutputFile.length = 0 THEN {          AdobeCommon.PostMessage[            data.msgSW, TRUE, "ERROR--no output file specified."L];          ERROR ABORTED};        IF sortData.keySpecs = NIL OR sortData.keySpecs.length = 0          THEN {          AdobeCommon.PostMessage[            data.msgSW, TRUE, "ERROR--no key specs were specified."L];          ERROR ABORTED};        sortData.inputSH ¬ GetFile[          data, sortData.sortInputFile, TRUE];        GetSortKeysFile[data];        outputFileName ¬ String.CopyToNewString[          sortData.sortOutputFile, data.heap];        [numberofSortKeys, numberOfKeySpecsEntered] ¬ GetKeySpec[          data, ptrToSortKeySpec];        headerLength ¬ GetHeaderLength[data, numberofSortKeys];        sortData.fileNumber ¬ 1;        IF sortData.maxLen = NIL OR sortData.maxLen.length = 0 THEN {          maxFileLength ¬ LAST[LONG CARDINAL];          sortData.outputSH ¬ GetFile[            data, sortData.sortOutputFile, FALSE];          currentFileLength ¬ PutHeader[            data, outputFileName, headerLength]}        ELSE {          maxFileLength ¬ String.StringToLongNumber[            sortData.maxLen, 10];          currentFileLength ¬ GetNextFileAndPutHeader[            data, outputFileName, headerLength];          sortData.fileNumber ¬ sortData.fileNumber + 1}};      ENDCASE;  --should not happen	    END;  --of InitializeSortVariables  GetFile: PROCEDURE [    data: AdobeCommon.DataHandle, fileName: LONG STRING,    read: BOOLEAN] RETURNS [fileHandle: MStream.Handle ¬ NIL] =    BEGIN    mfRD: MStream.ReleaseData ¬ [NIL, NIL];    fileHandle ¬      IF read THEN MStream.ReadOnly[      fileName, mfRD !      MStream.Error => {        AdobeCommon.PostMessage[data.msgSW, FALSE, fileName];        AdobeCommon.PostMessage[          data.msgSW, TRUE, " cannot be acquired."L];        ERROR ABORTED;        }]      ELSE MStream.WriteOnly[        fileName, mfRD, text !        MStream.Error => {          AdobeCommon.PostMessage[data.msgSW, FALSE, fileName];          AdobeCommon.PostMessage[            data.msgSW, TRUE, " cannot be acquired."L];          ERROR ABORTED;          }];    END;  GetNextFileAndPutHeader: PROCEDURE [    data: AdobeCommon.DataHandle, outputFileName: LONG STRING,    headerLength: LONG CARDINAL]    RETURNS [currentFileLength: LONG CARDINAL] =    BEGIN    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    mfRD: MStream.ReleaseData ¬ [NIL, NIL];    newFileName: LONG STRING ¬ String.CopyToNewString[      s: outputFileName, z: Heap.systemZone, longer: 5];    WITH sortData: instanceData SELECT FROM      sort => {        String.AppendNumber[newFileName, sortData.fileNumber];        sortData.outputSH ¬ MStream.WriteOnly[          newFileName, mfRD, text];        currentFileLength ¬ 0;        currentFileLength ¬ PutHeader[          data, newFileName, headerLength];        }      ENDCASE => ERROR;  --shouldn't happen    Heap.systemZone.FREE[@newFileName];    END;  --of GetNextFileAndPutHeader  ReadFirstLine: PROCEDURE [sortSH: MStream.Handle] =    BEGIN    --read first line of the sortSH file    --stops at the Ascii.CR which is the current character    char: CHARACTER ¬ ' ;    Stream.SetPosition[sortSH, 0];    WHILE (char ¬ Stream.GetChar[sortSH]) # Ascii.CR DO ENDLOOP;    END;  --of ReadFirstLine   GetKeySpec: PROCEDURE [    data: AdobeCommon.DataHandle,    ptrToSortKeySpec: POINTER TO SortKeySpec]    RETURNS [numberOfSortKeys, numberOfKeySpecsEntered: CARDINAL] =    BEGIN    index: CARDINAL ¬ 0;    sortKeySpec, newSortKeySpec, endOfSortKeySpec: SortKeySpec ¬ NIL;    char: CHARACTER ¬ ' ;    keySpecAscending: BOOLEAN ¬ TRUE;    keySpecsString: LONG STRING ¬ NIL;    keySpecToken: LONG STRING ¬ String.MakeString[data.heap, 20];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    formItem: FormSW.ItemHandle;    WITH sortData: instanceData SELECT FROM      sort => {        numberOfSortKeys ¬ numberOfKeySpecsEntered ¬ 0;        IF sortData.keySpecs = NIL OR sortData.keySpecs.length = 0          THEN RETURN;        formItem ¬ FormSW.FindItem[instanceData.cmdSW, keyspecsPos];        formItem.flags.invisible ¬ TRUE;        {        ENABLE          UNWIND => {            formItem.flags.invisible ¬ FALSE;            data.heap.FREE[@keySpecsString];            FormSW.DisplayItem[instanceData.cmdSW, keyspecsPos]};        keySpecsString ¬ String.MakeString[	  data.heap, sortData.keySpecs.length+10];        --sortData.keySpecs.length ¬ 0;        WHILE index < sortData.keySpecs.length DO          keySpecAscending ¬ TRUE;  --default switch value;          WHILE index < sortData.keySpecs.length            AND sortData.keySpecs[index] # '/ DO            IF sortData.keySpecs[index] = '' THEN {              index ¬ index + 1;              IF sortData.keySpecs[index] # '/ THEN {                AdobeCommon.PostMessage[                  data.msgSW, TRUE, "ERROR--invalid field name"L];                ERROR ABORTED}};            String.AppendCharAndGrow[              @keySpecToken, sortData.keySpecs[index], data.heap];            String.AppendCharAndGrow[              @keySpecsString, sortData.keySpecs[index], data.heap];            index ¬ index + 1;            ENDLOOP;          String.AppendCharAndGrow[@keySpecsString, '/, data.heap];          index ¬ index + 1;          IF index < sortData.keySpecs.length THEN            SELECT sortData.keySpecs[index] FROM              'a, 'A, 'u, 'U => {                keySpecAscending ¬ TRUE;                String.AppendCharAndGrow[                  @keySpecsString, sortData.keySpecs[index],                  data.heap];                index ¬ index + 1;                };              'd, 'D => {                keySpecAscending ¬ FALSE;                String.AppendCharAndGrow[                  @keySpecsString, sortData.keySpecs[index],                  data.heap];                index ¬ index + 1;                };              '  => {                AdobeCommon.PostMessage[                  data.msgSW, TRUE,                  "no switch was entered--the default switch is ascending. "L];                String.AppendCharAndGrow[                  @keySpecsString, 'a, data.heap]};              ENDCASE => {                AdobeCommon.PostMessage[                  data.msgSW, TRUE,                  "invalid switch--the default switch is ascending. "L];                String.AppendCharAndGrow[                  @keySpecsString, 'a, data.heap]}          ELSE {            AdobeCommon.PostMessage[              data.msgSW, TRUE,              "no switch was entered--the default switch is ascending. "L];            String.AppendCharAndGrow[@keySpecsString, 'a, data.heap]};          String.AppendCharAndGrow[@keySpecsString, ' , data.heap];          numberOfKeySpecsEntered ¬ numberOfKeySpecsEntered + 1;          --create another SortKeySpecItem and append to sortKeySpec          newSortKeySpec ¬ data.heap.NEW[SortKeySpecItem];          newSortKeySpec.posInSortKeyFile ¬ FindPosOfKeySpec[            keySpecToken, data];          --ClearString[keySpecToken];          keySpecToken.length ¬ 0;          newSortKeySpec.ascending ¬ keySpecAscending;          newSortKeySpec.next ¬ NIL;          IF ptrToSortKeySpec­ = NIL THEN {            ptrToSortKeySpec­ ¬ newSortKeySpec;            sortKeySpec ¬ ptrToSortKeySpec­;            endOfSortKeySpec ¬ newSortKeySpec;            }            --sortKeySpec ¬ newSortKeySpec; endOfSortKeySpec ¬ newSortKeySpec;}          ELSE {            endOfSortKeySpec.next ¬ newSortKeySpec;            endOfSortKeySpec ¬ newSortKeySpec};          index ¬ index + 1;          ENDLOOP};        formItem.flags.invisible ¬ FALSE;        sortData.keySpecs.length ¬ 0;        String.AppendStringAndGrow[          @sortData.keySpecs, keySpecsString, data.heap];        FormSW.DisplayItem[sortData.cmdSW, keyspecsPos];        --this appends page pos, byte pos and length pos to sortKeySpec        numberOfSortKeys ¬ CountSortKeys[sortData.sortKeysSH];        FOR index IN [numberOfSortKeys..numberOfSortKeys + 2] DO          newSortKeySpec ¬ data.heap.NEW[SortKeySpecItem];          newSortKeySpec.posInSortKeyFile ¬ index;          newSortKeySpec.next ¬ NIL;          endOfSortKeySpec.next ¬ newSortKeySpec;          endOfSortKeySpec ¬ newSortKeySpec;          ENDLOOP;        };      ENDCASE;    data.heap.FREE[@keySpecToken];    data.heap.FREE[@keySpecsString];    END;  --of GetKeySpec  CopyInputFileToOutputFile: PROCEDURE [    data: AdobeCommon.DataHandle, outputFileName: LONG STRING,    maxFileLength: LONG CARDINAL, tempstring: LONG STRING,    headerLength: LONG CARDINAL] =    BEGIN    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    WITH sortData: instanceData SELECT FROM      sort => {        GetNumber: PROCEDURE RETURNS [LONG CARDINAL ¬ 0] =          BEGIN          tempstring.length ¬ 0;          WHILE char # Ascii.NUL DO            String.AppendChar[tempstring, char];            char ¬ Stream.GetChar[sortData.sortKeysSH];            ENDLOOP;          char ¬ Stream.GetChar[sortData.sortKeysSH];          RETURN[String.StringToLongNumber[tempstring, 10]];          END;  --of GetNumber        count: CARDINAL ¬ 0;        i, pagePos, bytePos, lenPos, currentFileLength: LONG          CARDINAL ¬ 0;        char: CHARACTER ¬ ' ;        numberOfSortKeys: CARDINAL ¬ CountSortKeys[          sortData.sortKeysSH];        UNTIL MStream.EndOf[sortData.sortKeysSH] DO          WHILE count # numberOfSortKeys DO            WHILE char # Ascii.NUL DO              char ¬ Stream.GetChar[sortData.sortKeysSH]; ENDLOOP;            count ¬ count + 1;            char ¬ Stream.GetChar[sortData.sortKeysSH];            ENDLOOP;          pagePos ¬ GetNumber[];          bytePos ¬ GetNumber[];          lenPos ¬ GetNumber[];          count ¬ 0;          IF currentFileLength + lenPos > maxFileLength THEN {            sortData.outputSH ¬ CleanUpStream[sortData.outputSH];            currentFileLength ¬ GetNextFileAndPutHeader[              data, outputFileName, headerLength];            sortData.fileNumber ¬ sortData.fileNumber + 1};          Stream.SetPosition[            sortData.inputSH,            (adobeBytesPerPage * pagePos + bytePos)];          FOR i IN [1..lenPos] DO            Stream.PutChar[              sortData.outputSH, Stream.GetChar[sortData.inputSH]];            ENDLOOP;  --of for loop          currentFileLength ¬ currentFileLength + lenPos;          ENDLOOP;  --of until loop        };      ENDCASE => ERROR;  --shouldn't happen    END;  --of CopyInputFileToOutputFile  CountSortKeys: PROCEDURE [sortSH: MStream.Handle]    RETURNS [count: CARDINAL ¬ 0] =    BEGIN    char: CHARACTER ¬ ' ;    Stream.SetPosition[sortSH, 0];    UNTIL char = Ascii.CR DO      WHILE char # Ascii.NUL DO        char ¬ Stream.GetChar[sortSH]; ENDLOOP;      count ¬ count + 1;      char ¬ Stream.GetChar[sortSH];      ENDLOOP;  --of until loop    END;  --of CountSortKeys  FreeSortKeySpec: PROCEDURE [    data: AdobeCommon.DataHandle, sortKeySpec: SortKeySpec] =    BEGIN    tempSortKeySpec: SortKeySpec;    UNTIL sortKeySpec = NIL DO      tempSortKeySpec ¬ sortKeySpec.next;      data.heap.FREE[@sortKeySpec];      sortKeySpec ¬ tempSortKeySpec;      ENDLOOP;    END;  --of FreeSortKeySpec  FindPosOfKeySpec: PROCEDURE [    token: LONG STRING, data: AdobeCommon.DataHandle]    RETURNS [pos: CARDINAL ¬ 0] =    BEGIN    char: CHARACTER ¬ ' ;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    WITH sortData: instanceData SELECT FROM      sort => {        field: LONG STRING ¬ String.MakeString[data.heap, 20];        --ClearString[field];        Stream.SetPosition[sortData.sortKeysSH, 0];        UNTIL char = Ascii.CR DO          WHILE            ((char ¬ Stream.GetChar[sortData.sortKeysSH]) # Ascii.NUL)            AND (char # Ascii.CR) DO            String.AppendCharAndGrow[@field, char, data.heap];            ENDLOOP;  --of while loop          IF String.Equivalent[token, field] THEN {            data.heap.FREE[@field]; RETURN[pos]};          pos ¬ pos + 1;          field.length ¬ 0;          ENDLOOP;  --of until loop        AdobeCommon.PostMessage[data.msgSW, FALSE, token];        AdobeCommon.PostMessage[          data.msgSW, TRUE,          "--this field cannot be used as a sortkey"L];        ERROR ABORTED};      ENDCASE;  --should not happen    END;  --of FindPosOfKeySpec  GetSortKeysFile: PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    sortKeyFile: LONG STRING ¬ NIL;    index: CARDINAL ¬ 0;    mfRD: MStream.ReleaseData ¬ [NIL, NIL];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    WITH sortData: instanceData SELECT FROM      sort => {        sortKeyFile ¬ String.MakeString[          data.heap, sortData.sortInputFile.length + 9];        UNTIL index = sortData.sortInputFile.length          OR sortData.sortInputFile[index] = '. DO          String.AppendChar[            sortKeyFile, sortData.sortInputFile[index]];          index ¬ index + 1;          ENDLOOP;        String.AppendString[sortKeyFile, ".sortKeys"L];        sortData.sortKeysSH ¬ MStream.ReadOnly[          sortKeyFile, mfRD !          MStream.Error => {            AdobeCommon.PostMessage[              data.msgSW, TRUE, " ERROR--file cannot be obtained"L];            ERROR ABORTED}];        data.heap.FREE[@sortKeyFile]};      ENDCASE;  --should not happen    END;  --of GetSortKeysFile  GetHeaderLength: PROCEDURE [    data: AdobeCommon.DataHandle, numberofSortKeys: CARDINAL]    RETURNS [n: LONG CARDINAL] =    BEGIN    count: CARDINAL ¬ 0;    char: CHARACTER ¬ ' ;    tempString: LONG STRING ¬ String.MakeString[Heap.systemZone, 30];    page, byte: LONG CARDINAL ¬ 0;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    WITH sortData: instanceData SELECT FROM      sort => {        ReadFirstLine[sortData.sortKeysSH];        --checks to see if there are any entries in the sortkeys file        char ¬ Stream.GetChar[          sortData.sortKeysSH !          Stream.EndOfStream => {            AdobeCommon.PostMessage[              data.msgSW, TRUE,              "There are no ARs in the sortkeys file"L];            ERROR ABORTED}];        IF char = Ascii.NUL THEN count ¬ count + 1;        UNTIL count = numberofSortKeys DO          WHILE (char ¬ Stream.GetChar[sortData.sortKeysSH]) #            Ascii.NUL DO ENDLOOP;          count ¬ count + 1;          ENDLOOP;        WHILE (char ¬ Stream.GetChar[sortData.sortKeysSH]) # Ascii.NUL          DO          String.AppendCharAndGrow[            @tempString, char, Heap.systemZone];          ENDLOOP;        page ¬ String.StringToLongNumber[tempString, 10];        tempString.length ¬ 0;        WHILE (char ¬ Stream.GetChar[sortData.sortKeysSH]) # Ascii.NUL          DO          String.AppendCharAndGrow[            @tempString, char, Heap.systemZone];          ENDLOOP;        byte ¬ String.StringToLongNumber[tempString, 10];        n ¬ page * adobeBytesPerPage + byte};      ENDCASE;  --should not happen    Heap.systemZone.FREE[@tempString];    END;  --of GetHeaderLength  PutHeader: PROCEDURE [    data: AdobeCommon.DataHandle, fileName: LONG STRING,    headerLength: LONG CARDINAL]    RETURNS [currentFileLength: LONG CARDINAL] =    BEGIN    char: CHARACTER ¬ Ascii.NUL;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    WITH sortData: instanceData SELECT FROM      sort => {        PutIt: PROCEDURE [s: LONG STRING, CR: BOOLEAN ¬ FALSE] =          BEGIN          IF s # NIL THEN            Stream.PutString[sH: sortData.outputSH, string: s];          IF CR THEN Stream.PutChar[sortData.outputSH, Ascii.CR];          END;  --of PutIt        currentFileLength ¬ 0;        PutIt[s: "This is file: "L, CR: FALSE];        PutIt[s: fileName, CR: TRUE];        PutIt[s: "Generated by AdobeSort using: "L, CR: FALSE];        PutIt[s: sortData.keySpecs, CR: TRUE];        PutIt[s: "Original "L];        IF sortData.keySpecs = NIL THEN          currentFileLength ¬ fileName.length + 55        ELSE          currentFileLength ¬            fileName.length + sortData.keySpecs.length + 55;        Stream.SetPosition[sortData.inputSH, 0];        --outputs report name which is the first line of the input file        THROUGH [0..headerLength) DO          Stream.PutChar[            sortData.outputSH, Stream.GetChar[sortData.inputSH]];          ENDLOOP;        currentFileLength ¬ currentFileLength + headerLength}      ENDCASE => ERROR;  --shouldn't happen    END;  --of PutHeader  CleanUpStream: PROCEDURE [streamHandle: MStream.Handle]    RETURNS [MStream.Handle] =    BEGIN    Stream.Delete[streamHandle];    streamHandle ¬ NIL;    RETURN[streamHandle];    END;  --of CleanUpStream  END.  14-May-87 13:54:20 - rlc - fix CompareStrings. remainder of proc wants to be part of the ELSE clause. As is was the key spec wasn't being incremented properly in the case of an empty field.
-- Copyright (C) 1982, 1985, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- File: AdobeCommonImplB.mesa - last edit by:-- Freedman, 	27-Dec-82 15:59:00-- RSF, 	14-Apr-86 10:39:57-- JCS, 	 9-Oct-85 15:45:49-- RLC,          2-Mar-88 11:55:21  DIRECTORY  AccessCH USING [Problem],  AdobeCommon USING [    DataHandle, DestroyOtherSWs, LockedSysDescPtr, PostMessage,    SetFSWOrderAndDefaultFromUserFile, SysDescPtr, SysDesc, Systems,    SystemsHandle],  AdobeCommonInternal USING [    NoServer, NoService, OpenAccessSession, SystemNotFound],  AdobeOps USING [    ARSystemHandle, DefaultInfoHandle, EnumeratedSequence,    FieldItemHandle, FieldList, KeyedPossibilities, ToolType, z],  AdobeServer USING [    Error, FreeLocationOfARs, FreeSystemDescription, GetLocationOfARs,    GetSystemDescription, Reference],  AdobeToolContext USING [FreeUserContext, InitializeUserContext],  ARAccess USING [Create, --Destroy, Error,-- Logon, Session],  Auth USING [IdentityHandle],  Heap USING [systemZone],  NSName USING [maxFullNameLength],  Profile USING [GetID],  String USING [CopyToNewString, Equal, MakeString],  System USING [nullNetworkAddress];AdobeCommonImplB: MONITOR LOCKS head USING head:  AdobeCommon.LockedSysDescPtr  IMPORTS    AccessCH, AdobeOps, AdobeCommon, AdobeCommonInternal, AdobeServer,    AdobeToolContext, ARAccess, Heap, Profile, String  EXPORTS AdobeCommon, AdobeCommonInternal =  BEGIN  --Signal declarations  SystemNotFound: PUBLIC SIGNAL [system: LONG STRING] = CODE;  InvalidService: PUBLIC SIGNAL = CODE;  SearchKnownSysDescList: PUBLIC ENTRY PROCEDURE [    head: AdobeCommon.LockedSysDescPtr, systemName: LONG STRING]    RETURNS [arSH: AdobeOps.ARSystemHandle ¬ NIL] =    BEGIN    ENABLE UNWIND => NULL;    arSH ¬ SearchKnownSysDescListInternal[head, systemName];    END;  SearchKnownSysDescListInternal: INTERNAL PROCEDURE [    head: AdobeCommon.LockedSysDescPtr, systemName: LONG STRING]    RETURNS [arSH: AdobeOps.ARSystemHandle ¬ NIL] =    BEGIN    IF head = NIL THEN RETURN[NIL]    ELSE      BEGIN      p: AdobeCommon.SysDescPtr ¬ head.nodePtr;      WHILE p # NIL DO        IF String.Equal[p.arSH.name, systemName] THEN RETURN[p.arSH];        p ¬ p.nextNode;        ENDLOOP;      END;    END;  AddToKnownSysDescList: PUBLIC ENTRY PROCEDURE [    head: AdobeCommon.LockedSysDescPtr,    arSH: AdobeOps.ARSystemHandle] =    BEGIN    ENABLE UNWIND => NULL;    AddToKnownSysDescListInternal[head, arSH];    END;  AddToKnownSysDescListInternal: INTERNAL PROCEDURE [    head: AdobeCommon.LockedSysDescPtr,    arSH: AdobeOps.ARSystemHandle] =    BEGIN    IF head.nodePtr = NIL THEN      head.nodePtr ¬ Heap.systemZone.NEW[        AdobeCommon.SysDesc ¬ [arSH: arSH, nextNode: NIL]]    ELSE      BEGIN      p: AdobeCommon.SysDescPtr ¬ head.nodePtr;      head.nodePtr ¬ Heap.systemZone.NEW[        AdobeCommon.SysDesc ¬ [arSH: arSH, nextNode: p]];      END;    END;  DeleteSysDescList: PUBLIC ENTRY PROCEDURE [    head: AdobeCommon.LockedSysDescPtr]    RETURNS [nilHead: AdobeCommon.LockedSysDescPtr ¬ NIL] =    BEGIN    ENABLE UNWIND => NULL;    p: AdobeCommon.SysDescPtr ¬ NIL;    IF head # NIL THEN p ¬ head.nodePtr ELSE RETURN[NIL];    IF p # NIL THEN DeleteNode[p];  --frees all node of desc list    END;      ModifyKnownSysDescList: INTERNAL PROCEDURE [    head: AdobeCommon.LockedSysDescPtr, arSH: AdobeOps.ARSystemHandle,    systemName: LONG STRING] =    BEGIN    ENABLE UNWIND => NULL;    p: AdobeCommon.SysDescPtr ¬ head.nodePtr;    IF p = NIL THEN      p ¬ Heap.systemZone.NEW[        AdobeCommon.SysDesc ¬ [arSH: arSH, nextNode: NIL]]    ELSE       BEGIN      WHILE p # NIL DO        IF String.Equal[p.arSH.name, systemName] THEN {	  p.arSH ¬ arSH; EXIT};        p ¬ p.nextNode;        ENDLOOP;      END    END;  DeleteNode: INTERNAL PROCEDURE [node: AdobeCommon.SysDescPtr] =    BEGIN    IF node.nextNode # NIL THEN DeleteNode[node.nextNode];    -- [] ¬ DeallocateARSystemObject[node.arSH];    -- AdobeOps.z.FREE[@node.arSH];    --free formSWOrderArray    FOR tool: AdobeOps.ToolType IN AdobeOps.ToolType DO      IF node.arSH.formSWOrderArray[tool] # NIL THEN        AdobeOps.z.FREE[@node.arSH.formSWOrderArray[tool]]      ENDLOOP;    [] ¬ AdobeServer.FreeSystemDescription[node.arSH];    Heap.systemZone.FREE[@node];    END;  DeallocateARSystemObject: PROCEDURE [arSH: AdobeOps.ARSystemHandle]    RETURNS [nilPtr: AdobeOps.ARSystemHandle ¬ NIL] =    BEGIN    heap: UNCOUNTED ZONE ¬ AdobeOps.z;    heap.FREE[@arSH.name];    heap.FREE[@arSH.host];    heap.FREE[@arSH.directory];    --free fieldList    DeallocateFieldList[arSH.fieldList];    --free formSWOrderArray    FOR tool: AdobeOps.ToolType IN [edit..queryList] DO      IF arSH.formSWOrderArray[tool] # NIL THEN        heap.FREE[@arSH.formSWOrderArray[tool]]      ENDLOOP;    END;  DeallocateFieldList: PROCEDURE [fieldList: AdobeOps.FieldList] =    BEGIN    IF fieldList # NIL THEN      BEGIN      FOR i: CARDINAL IN [0..fieldList.len) DO        AdobeOps.z.FREE[@fieldList[i].name];        FreeDefaultInfo[fieldList[i].defaultInfo];        FreeFLBody[@fieldList[i]];        ENDLOOP;      AdobeOps.z.FREE[@fieldList];      END;    END;  FreeDefaultInfo: PROCEDURE [    defaultInfo: ARRAY AdobeOps.ToolType OF      AdobeOps.DefaultInfoHandle] =  <<INLINE>>    BEGIN    FOR i: AdobeOps.ToolType IN AdobeOps.ToolType DO      IF defaultInfo[i] # NIL THEN        BEGIN        IF defaultInfo[i].default # NIL THEN          AdobeOps.z.FREE[@defaultInfo[i].default];        AdobeOps.z.FREE[@defaultInfo[i]];        END;      ENDLOOP;    END;  FreeFLBody: PROCEDURE [fieldList: AdobeOps.FieldItemHandle] = INLINE    BEGIN    WITH item: fieldList SELECT FROM      enumerated =>        BEGIN        FreePossibilities[item.possibilities];        AdobeOps.z.FREE[@item.possibilities];        END;      ENDCASE  --nothing to FREE    END;  FreePossibilities: PROCEDURE [poss: AdobeOps.KeyedPossibilities] =    INLINE    BEGIN    IF poss # NIL THEN      BEGIN      FOR i: CARDINAL IN [0..poss.len) DO        FreeEnumRecs[poss[i].enumRecs]; ENDLOOP;      END;    END;  FreeEnumRecs: PROCEDURE [enumSeq: AdobeOps.EnumeratedSequence] =    INLINE    BEGIN    IF enumSeq # NIL THEN      BEGIN      FOR i: CARDINAL IN [0..enumSeq.length) DO        AdobeOps.z.FREE[@enumSeq[i].string] ENDLOOP;      AdobeOps.z.FREE[@enumSeq];      END;    END;  LocateSystemInKnownSystems: PUBLIC PROCEDURE [    name: LONG STRING, systems: AdobeCommon.SystemsHandle]    RETURNS [system: CARDINAL] =    BEGIN    IF systems = NIL THEN SIGNAL AdobeCommonInternal.SystemNotFound[system: name];    FOR i: CARDINAL IN [0..systems.next) DO      IF String.Equal[name, systems[i]] THEN RETURN[i] ENDLOOP;    --system not found in known systems     SIGNAL AdobeCommonInternal.SystemNotFound[system: name];    END;  AddSystemToKnownSystems: PUBLIC PROCEDURE [    name: LONG STRING,    systems: LONG POINTER TO AdobeCommon.SystemsHandle,    heap: UNCOUNTED ZONE] =    BEGIN    IF systems^ = NIL THEN      systems^ ¬ AllocateKnownSystems[systems^, heap];    IF systems.next = systems.maxLength THEN      systems^ ¬ AllocateKnownSystems[systems^, heap];    systems[systems.next] ¬ String.CopyToNewString[name, heap];    systems.next ¬ systems.next + 1;    END;  RemoveSystemFromKnownSystems: PUBLIC PROCEDURE [    name: LONG STRING,    systems: LONG POINTER TO AdobeCommon.SystemsHandle,    z: UNCOUNTED ZONE] =    BEGIN    FOR i: CARDINAL IN [0..systems.next) DO      IF String.Equal[name, systems[i]] THEN {        z.FREE[@systems[i]];        FOR j: CARDINAL IN [i + 1..systems.next) DO          systems[j - 1] ¬ systems[j]; ENDLOOP;        systems.next ¬ systems.next - 1;        EXIT};      ENDLOOP;    END;  AllocateKnownSystems: PUBLIC PROCEDURE [    oldSeq: AdobeCommon.SystemsHandle, z: UNCOUNTED ZONE]    RETURNS [newSeq: AdobeCommon.SystemsHandle] =    BEGIN    incr: CARDINAL = 5;    IF oldSeq # NIL THEN      BEGIN      newSeq ¬ z.NEW[AdobeCommon .Systems[oldSeq.maxLength + incr]];      FOR i: CARDINAL IN [0..oldSeq.next) DO        newSeq[i] ¬ oldSeq[i]; ENDLOOP;      newSeq.next ¬ oldSeq.next;      z.FREE[@oldSeq];      END    ELSE  --oldSeq = NIL--      BEGIN      newSeq ¬ z.NEW[AdobeCommon .Systems[incr]];      FOR i: CARDINAL IN [0..newSeq.maxLength) DO        newSeq[i] ¬ NIL; ENDLOOP;      newSeq.next ¬ 0;      END;    END;  FlushCurrentSystem: PUBLIC PROCEDURE [    toolData: AdobeCommon.DataHandle] =    BEGIN    AdobeCommon.DestroyOtherSWs[data: toolData, killCmdSW: FALSE];    IF toolData.context # NIL THEN      AdobeToolContext.FreeUserContext[        @toolData.context, toolData.heap];    IF toolData.context # NIL THEN      toolData.context.arSH.service ¬ System.nullNetworkAddress;    END;  SetDefaultsAndUserContext: PUBLIC PROCEDURE [    toolData: AdobeCommon.DataHandle, arSH: AdobeOps.ARSystemHandle] =    BEGIN    AdobeCommon.SetFSWOrderAndDefaultFromUserFile[      toolData.knownSystems[toolData.system], arSH];    toolData.context ¬ AdobeToolContext.InitializeUserContext[      arSH, toolData.tool, toolData.heap];    END;  GetSystemDescriptionFromParent: PUBLIC PROCEDURE [    toolData, parent: AdobeCommon.DataHandle]    RETURNS [arSH: AdobeOps.ARSystemHandle] = BEGIN END;  OpenAccessSession: PUBLIC PROCEDURE [    toolData: AdobeCommon.DataHandle] =    BEGIN    ENABLE {      AdobeServer.Error =>        SELECT why FROM	  unknownSystem => GOTO systemNotFound; 	  serverUnreachable, serverDown =>            ERROR AdobeCommonInternal.NoServer;          noAdobeServiceAtServer => AdobeCommonInternal.NoService;	  sysDescChanging => {	    AdobeCommon.PostMessage[	      toolData.msgSW, FALSE, "The Adobe database is changing.  Contact support for more information. "L];            ERROR ABORTED};	  tooManyConnections => {	    AdobeCommon.PostMessage[	      toolData.msgSW, FALSE, "Too many connections to Adobe service. Try again later."L];            ERROR ABORTED};	  ENDCASE;      AccessCH.Problem =>         SELECT type FROM	  badDatabaseName => GOTO systemNotFound;           authProblem => GOTO authProblem          ENDCASE}; --may want more later     locOfARs: AdobeServer.Reference ¬ AdobeServer.GetLocationOfARs[      server: IF toolData.context # NIL THEN        toolData.context.arSH.service        ELSE System.nullNetworkAddress,      systemName: toolData.knownSystems[toolData.system]];    toolData.accessSession ¬ ARAccess.Create[      zone: toolData.heap, arLocation: locOfARs];    SetLogin[toolData.accessSession];    AdobeServer.FreeLocationOfARs[locOfARs];    EXITS    systemNotFound => SIGNAL AdobeCommonInternal.SystemNotFound[	    system: toolData.knownSystems[toolData.system]];    authProblem => NULL;    END;      FindSystem: PUBLIC ENTRY PROCEDURE [    head: AdobeCommon.LockedSysDescPtr,    toolData: AdobeCommon.DataHandle, systemName: LONG STRING,     useDescList: BOOLEAN]    RETURNS [arSH: AdobeOps.ARSystemHandle] =    BEGIN    ENABLE {      UNWIND => NULL;      AdobeServer.Error =>        SELECT why FROM          serverUnreachable, serverDown => GOTO noServer;          noAdobeServiceAtServer => GOTO noService;          unknownSystem => GOTO unknownSystem;	  illegalLogin => GOTO illegalLogin;	  sysDescChanging => {	    AdobeCommon.PostMessage[	      toolData.msgSW, FALSE, "The Adobe database is changing.  Contact support for more information. "L];            ERROR ABORTED};	  tooManyConnections => {	    AdobeCommon.PostMessage[	      toolData.msgSW, FALSE, "Too many connections to Adobe service. Try again later."L];            ERROR ABORTED};	  spare1 => {	    AdobeCommon.PostMessage[	      toolData.msgSW, FALSE, "Protocol version mismatch with server."L];            ERROR ABORTED};          ENDCASE => {	    AdobeCommon.PostMessage[	      toolData.msgSW, FALSE, "Server problem. "L];            ERROR ABORTED};      AccessCH.Problem =>         SELECT type FROM          badDatabaseName => GOTO unknownSystem;	  ENDCASE};     i: CARDINAL ¬ 0;    localName: LONG STRING;    IF systemName = NIL THEN GOTO unknownSystem;    localName ¬ String.MakeString[      toolData.heap, systemName.length];    WHILE systemName[i] # ': AND i < systemName.length      AND i < NSName.maxFullNameLength DO      localName[i] ¬ systemName[i]; i ¬ i + 1; ENDLOOP;    localName.length ¬ i;    IF useDescList THEN {      arSH ¬ AdobeServer.GetSystemDescription[        System.nullNetworkAddress, systemName];      ModifyKnownSysDescList[head, arSH, systemName]}    ELSE {      IF (arSH ¬ SearchKnownSysDescListInternal[head, localName]) = NIL	THEN {	arSH ¬ AdobeServer.GetSystemDescription[	  System.nullNetworkAddress, systemName];	AddToKnownSysDescListInternal[head, arSH]}};    toolData.heap.FREE[@localName];    EXITS      unknownSystem =>        RETURN WITH ERROR AdobeCommonInternal.SystemNotFound[          systemName];      illegalLogin => AdobeCommon.PostMessage[          toolData.msgSW, FALSE, "Invalid login. "L];      noService => RETURN WITH ERROR AdobeCommonInternal.NoService;      noServer => RETURN WITH ERROR AdobeCommonInternal.NoServer;    END;  SetLogin: PUBLIC PROCEDURE [session: ARAccess.Session] =    BEGIN    DoLogon: PROCEDURE [id: Auth.IdentityHandle] =      BEGIN ARAccess.Logon[session, id]; END;    Profile.GetID[proc: DoLogon];    END;  StartSystem: PUBLIC PROCEDURE [    toolData: AdobeCommon.DataHandle, arSH: AdobeOps.ARSystemHandle] =    BEGIN    AdobeCommonInternal.OpenAccessSession[toolData];    SetDefaultsAndUserContext[toolData, arSH];    toolData.context.arSH ¬ arSH;    END;  END....  23-Feb-88 17:24:34 - rlc - add tooManyConnections25-Feb-88 18:17:17 - rlc - change AdobeService. tooManyConnections now a REAL error. 2-Mar-88 11:55:21 - rlc - FindSystem catches spare1 now. This is a protocol version mismatch.
-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- File:  AdobeQueueImpl.mesa-- Last modified by:-- PAD       	16-Jan-85 16:11:04-- RSF       	25-Sep-85 13:57:34-- RLC		11-Jun-87 12:40:54DIRECTORY  AdobeOps USING [ARSystemHandle, nilARNumber, RunOfARs],  AdobeQOps USING [    IndexObject, nEntriesPerBlock, PriorityType, PutUpdaterToSleep, Q,    QEntryObject, QObject, StatusType, Updater, WakeUpdater],  AdobeServer USING [Time],  AdobeServerOps USING [    CloseFile, data, Data, FreeTime, GetLocationOfARsInternal,    GetStartOrStopTimeInternal, OpenFile, ReadLastARNumberInternal,    RetrieveSystemDescriptionInternal, SystemIndex,    updaterBackingFile],  AdobeUpdater USING [UpdaterObject],  ARFileAccess USING [Create, Logon, Session],  Date USING [PackedToString],  Heap USING [systemZone],  NSFile USING [    Attribute, AttributesRecord, AttributeType, ChangeAttributes,    ClearAttributeList, ClearAttributes, DecodeCardinal,    DecodeLongCardinal, EncodeCardinal, EncodeLongCardinal,    ExtendedAttributeType, GetAttributes, Handle, Reference, Session,    String, Time],  NSSegment USING [    CopyIn, CopyOut, GetSizeInPages, Origin, Session, SetSizeInPages],  NSString USING [    AppendToMesaString, CompareStrings, LogicalLength, String,    StringFromMesaString],  Process USING [Abort, Detach, Seconds, SecondsToTicks, SetTimeout],  Space USING [ScratchMap, Unmap],  String USING [    AppendLongNumber, AppendString, CopyToNewString, MakeString,    StringBoundsFault],  System USING [GreenwichMeanTime],  Time USING [Current, defaultTime, Pack, Unpack, Unpacked];AdobeQueueImpl: MONITOR LOCKS q USING q: Q  IMPORTS    AdobeQOps, AdobeServerOps, ARFileAccess, Date, Heap, NSFile,    NSSegment, NSString, Process, Space, String, Time  EXPORTS AdobeQOps, AdobeUpdater =  BEGIN OPEN AdobeQOps;  Q: TYPE = AdobeQOps.Q;  QObject: TYPE = AdobeQOps.QObject;  UpdaterObject: PUBLIC TYPE = QObject;  nBlocksType: NSFile.ExtendedAttributeType =    ORD[LAST[NSFile.AttributeType]] + 1;  numQElementsType: NSFile.ExtendedAttributeType = nBlocksType + 1;  perARNumType: NSFile.ExtendedAttributeType = numQElementsType + 1;  data: AdobeServerOps.Data = @AdobeServerOps.data;  stoppingService: BOOLEAN ¬ FALSE;  secsToWait: Process.Seconds = 2;  aBit: CONDITION;  AboutToStore: PUBLIC PROCEDURE [    systemName: LONG STRING, arNumber: LONG CARDINAL] =    BEGIN    q: Q;    successful: BOOLEAN ¬ FALSE;    q ¬ GetQHandle[systemName];    successful ¬ AboutToStoreInternal[      q: q, updateType: updateImmeadiate, arNumber: arNumber,      length: 1, systemIndex: AdobeServerOps.SystemIndex[systemName]];    END;  AboutToStoreInternal: ENTRY PROCEDURE [    q: Q, updateType: AdobeQOps.PriorityType, arNumber: LONG CARDINAL,    length: LONG CARDINAL, systemIndex: CARDINAL]    RETURNS [successful: BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    found, addedElement: BOOLEAN ¬ FALSE;    block, index: CARDINAL ¬ 0;    page: LONG CARDINAL;    origin: NSSegment.Origin;    successful ¬ FALSE;    WHILE NOT addedElement DO      [found, block, index] ¬ FindElement[q, null, empty, 0, 0];      origin ¬ [file: q.fHToBackingFile, base: block, count: 1];      [] ¬ NSSegment.CopyIn[        pointer: q.buffer, origin: origin, session: data.fileSession];      IF found THEN {        q.buffer[index].priority ¬ updateType;        q.buffer[index].arSequence ¬ [arNumber, length];        q.buffer[index].timeStamp ¬ TimePlus5Min[];        SELECT updateType FROM          updateImmeadiate => q.buffer[index].status ¬ waiting;          updateExplicit => q.buffer[index].status ¬ needsToBeUpdated;          ENDCASE => NULL;        [] ¬ NSSegment.CopyOut[          pointer: q.buffer, origin: origin,          session: data.fileSession];        PutNumElements[q.fHToBackingFile, q.numOfQElements + 1];        q.numOfQElements ¬ q.numOfQElements + 1;        successful ¬ TRUE;        addedElement ¬ TRUE;        IF NOT stoppingService THEN          AdobeQOps.WakeUpdater[systemIndex];        RETURN[successful]}      ELSE {  -- add another page to the queue.        page ¬ NSSegment.GetSizeInPages[          file: q.fHToBackingFile, session: data.fileSession];        NSSegment.SetSizeInPages[          file: q.fHToBackingFile, pages: page + 1,          session: data.fileSession];        InitNewPage[q, page];        PutNBlocks[q.fHToBackingFile, q.nBlocks + 1];        q.nBlocks ¬ q.nBlocks + 1;        addedElement ¬ FALSE};      ENDLOOP;    END;  CompactQueue: INTERNAL PROCEDURE [q: Q] =    BEGIN    ENABLE UNWIND => NULL;    q.nBlocks ¬ GetNBlocks[q.fHToBackingFile];    WHILE q.nBlocks > 1 DO      NSSegment.SetSizeInPages[        file: q.fHToBackingFile, pages: q.nBlocks - 1,        session: data.fileSession];      PutNBlocks[q.fHToBackingFile, q.nBlocks - 1];      q.nBlocks ¬ q.nBlocks - 1;      ENDLOOP;    END;  CompareTimes: PUBLIC PROCEDURE [    startTime, stopTime: AdobeServer.Time] RETURNS [equal: BOOLEAN] =    BEGIN    currentTime: AdobeServer.Time;    SP: CHARACTER = ' ;    timeOnly: LONG STRING ¬ "00:00:00"L;  --assures correct lead zeroes    currentTimeString: LONG STRING ¬ Date.PackedToString[      Time.Current[]];    dtI: CARDINAL ¬ currentTimeString.length - 1;    tI: CARDINAL ¬ timeOnly.length - 1;    WHILE currentTimeString[dtI] # SP DO      timeOnly[tI] ¬ currentTimeString[dtI];      tI ¬ tI - 1;      dtI ¬ dtI - 1;      ENDLOOP;    Heap.systemZone.FREE[@currentTimeString];    currentTime ¬ NSString.StringFromMesaString[timeOnly];    --determine if there's a date cross and handle accordingly    SELECT NSString.CompareStrings[startTime, stopTime] FROM      greater =>  --date cross (eg start 23:00:00, stop 01:00:00        IF (NSString.CompareStrings[currentTime, startTime] = greater)          OR (NSString.CompareStrings[currentTime, stopTime] = less)          THEN RETURN[TRUE]        ELSE RETURN[FALSE];      less =>  --all w/in same day (eg start 01:00:00 stop 03:00:00        IF (NSString.CompareStrings[currentTime, startTime] = greater)          AND (NSString.CompareStrings[currentTime, stopTime] = less)          THEN RETURN[TRUE]        ELSE RETURN[FALSE];      ENDCASE => RETURN[FALSE];    END;  CompletedUpdate: PUBLIC PROCEDURE [    systemName: LONG STRING, arNumber: LONG CARDINAL] =    BEGIN    q: Q;    q ¬ GetQHandle[systemName];    CompletedUpdateInternal[      q: q, arNumber: arNumber,      systemIndex: AdobeServerOps.SystemIndex[systemName]];    END;  CompletedUpdateInternal: ENTRY PROCEDURE [    q: Q, arNumber: LONG CARDINAL, systemIndex: CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    origin: NSSegment.Origin;    found: BOOLEAN ¬ FALSE;    block, i: CARDINAL ¬ 0;    IF q.numOfQElements > 0 THEN      [block, i, found] ¬ FindAR[q, arNumber];    IF NOT found THEN GOTO notFound;    IF      (q.buffer[i].status # empty        AND q.buffer[i].arSequence.startingARNumber > 0	AND q.buffer[i].arSequence.sequenceLength > 0) THEN {      q.buffer[i].arSequence.sequenceLength ¬        q.buffer[i].arSequence.sequenceLength - 1;      q.buffer[i].arSequence.startingARNumber ¬        q.buffer[i].arSequence.startingARNumber + 1};    IF q.buffer[i].arSequence.sequenceLength = 0 THEN {      q.buffer[i].priority ¬ null;      q.buffer[i].status ¬ empty;      q.buffer[i].arSequence ¬ [0, 0];      q.buffer[i].timeStamp ¬ Time.defaultTime;      PutNumElements[q.fHToBackingFile, q.numOfQElements - 1];      q.numOfQElements ¬ q.numOfQElements - 1}    ELSE      IF q.buffer[i].priority = updateExplicit THEN        q.buffer[i].status ¬ isBeingUpdated;    origin ¬ [file: q.fHToBackingFile, base: block, count: 1];    [] ¬ NSSegment.CopyOut[      pointer: q.buffer, origin: origin, session: data.fileSession];    IF q.numOfQElements # 0 AND NOT stoppingService THEN      AdobeQOps.WakeUpdater[systemIndex];    EXITS      notFound =>        IF q.numOfQElements # 0 AND NOT stoppingService THEN          AdobeQOps.WakeUpdater[systemIndex];    END;  FindAR: INTERNAL PROCEDURE [q: Q, arNumber: LONG CARDINAL]    RETURNS [block, i: CARDINAL, found: BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    found: BOOLEAN ¬ FALSE;    origin: NSSegment.Origin;    FOR block IN [0..q.nBlocks) DO  << loop through blocks >>      origin ¬ [file: q.fHToBackingFile, base: block, count: 1];      [] ¬ NSSegment.CopyIn[        pointer: q.buffer, origin: origin, session: data.fileSession];      FOR i IN [0..31] DO        IF (q.buffer[i].arSequence.startingARNumber = arNumber) THEN {          found ¬ TRUE; RETURN[block, i, found]};        ENDLOOP;      ENDLOOP;    RETURN[0, 0, found];    END;  FindElement: INTERNAL PROCEDURE [    q: Q, p: PriorityType, s: StatusType,    startBlock, startNum: CARDINAL]    RETURNS [found: BOOLEAN, block: CARDINAL, index: CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    origin: NSSegment.Origin;    found ¬ FALSE;    FOR block IN [startBlock..q.nBlocks) DO  << loop through blocks >>      origin ¬ [file: q.fHToBackingFile, base: block, count: 1];      [] ¬ NSSegment.CopyIn[  -- read in first/next block        pointer: q.buffer, origin: origin, session: data.fileSession];      FOR index IN [startNum..31] DO  << loop through queue >>        SELECT TRUE FROM	  (q.buffer[index].arSequence.startingARNumber = 0 AND	    (q.buffer[index].priority # null OR	     q.buffer[index].status # empty)) => {	       q.buffer[index].priority  ¬ null;	       q.buffer[index].status ¬ empty;	       [] ¬ NSSegment.CopyOut[ -- clean out zeroes                 pointer: q.buffer, origin: origin, session: data.fileSession]};          (p = q.buffer[index].priority            AND s = q.buffer[index].status) =>            RETURN[TRUE, block, index];  << any empty entry >>          (s > waiting AND q.buffer[index].status > waiting) =>            RETURN[TRUE, block, index];  << any non empty entry >>          q.buffer[index].status = waiting =>            IF              (q.buffer[index].priority = updateImmeadiate                AND Time.Current[] >= q.buffer[index].timeStamp) THEN              {              q.buffer[index].status ¬ needsToBeUpdated;              [] ¬ NSSegment.CopyOut[  -- change entry status                 pointer: q.buffer, origin: origin,                session: data.fileSession]};  << change crash update >>          ENDCASE;        ENDLOOP;      startNum ¬ 0;  << reinitialize for next block >>      ENDLOOP;    RETURN[FALSE, 0, 0];    END;  FindElementToBeUpdated: PUBLIC PROCEDURE [systemIndex: CARDINAL]    RETURNS [found: BOOLEAN, arNumber: LONG CARDINAL] =    BEGIN    q: Q;    successful: BOOLEAN ¬ FALSE;    q ¬ data.systems[systemIndex].updaterInfo;    [successful, arNumber] ¬ FindElementToBeUpdatedInternal[      q, systemIndex];    RETURN[successful, arNumber];    END;  FindElementToBeUpdatedInternal: ENTRY PROCEDURE [    q: Q, systemIndex: CARDINAL]    RETURNS [successful: BOOLEAN, arNumToBeUpdated: LONG CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    origin: NSSegment.Origin;    found: BOOLEAN ¬ FALSE;    block, index, blockI, startI: CARDINAL;    currentEntry, tempEntry: AdobeQOps.QEntryObject;    successful ¬ FALSE;    arNumToBeUpdated ¬ AdobeOps.nilARNumber;    q.numOfQElements ¬ GetNumElements[q.fHToBackingFile];    IF q.numOfQElements = 0 THEN      [successful, arNumToBeUpdated] ¬ PeriodicUpdate[q, systemIndex]    ELSE {      [found, block, index] ¬ FindElement[        q, null, needsToBeUpdated, 0, 0];  << any non empty element >>      IF found THEN        BEGIN  << explicit or immeadiate update >>        origin ¬ [file: q.fHToBackingFile, base: block, count: 1];        [] ¬ NSSegment.CopyIn[          pointer: q.buffer, origin: origin,          session: data.fileSession];        currentEntry ¬ q.buffer[index];        arNumToBeUpdated ¬ q.buffer[          index].arSequence.startingARNumber;        successful ¬ TRUE;        --look on for higher priorities, statuses        DO          blockI ¬ block;          startI ¬ index + 1;          IF startI = nEntriesPerBlock THEN {            startI ¬ 0;            blockI ¬ blockI + 1;            IF blockI > q.nBlocks THEN              RETURN[TRUE, arNumToBeUpdated]};          [found, block, index] ¬ FindElement[            q, null, needsToBeUpdated, blockI, startI];          IF ~found THEN EXIT;  --no more entries          origin ¬ [file: q.fHToBackingFile, base: block, count: 1];          [] ¬ NSSegment.CopyIn[            pointer: q.buffer, origin: origin,            session: data.fileSession];          tempEntry ¬ q.buffer[index];          IF tempEntry.priority > currentEntry.priority THEN {            currentEntry ¬ tempEntry;            arNumToBeUpdated ¬              currentEntry.arSequence.startingARNumber}          ELSE            IF tempEntry.priority = currentEntry.priority THEN              IF tempEntry.status > currentEntry.status THEN {                currentEntry ¬ tempEntry;                arNumToBeUpdated ¬                  currentEntry.arSequence.startingARNumber};          ENDLOOP;        END;      };    RETURN[successful, arNumToBeUpdated];    END;  GetQHandle: PUBLIC PROCEDURE [systemName: LONG STRING]    RETURNS [q: Q] =    BEGIN    index: CARDINAL;    index ¬ AdobeServerOps.SystemIndex[systemName];    q ¬ data.systems[index].updaterInfo;    END;  << GetTimes: PUBLIC PROCEDURE [systemIndex: CARDINAL]    RETURNS [startTime, stopTime: AdobeServer.Time] =    BEGIN    q: Q ¬ data.systems[systemIndex].updaterInfo;    [startTime, stopTime] ¬ GetTimesEntry[q]    END; Looks like no one uses this>>  --this protects GetTimes and also allows other entry procs access to start and stop times    GetTimesEntry: ENTRY PROCEDURE [q: Q]    RETURNS [startTime, stopTime: AdobeServer.Time] =    BEGIN    ENABLE UNWIND => NULL;    [startTime, stopTime] ¬ GetTimesInternal[q];    END;  GetTimesInternal: INTERNAL PROCEDURE [q: Q]    RETURNS [startTime, stopTime: AdobeServer.Time] =    BEGIN    ENABLE UNWIND => NULL;    systemName: LONG STRING ¬ q.systemName;    startTime ¬ AdobeServerOps.GetStartOrStopTimeInternal[      systemName, start];    stopTime ¬ AdobeServerOps.GetStartOrStopTimeInternal[      systemName, stop];    END;  GetNBlocks: PROCEDURE [fH: NSFile.Handle]    RETURNS [nBlocks: CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    extSelections: ARRAY [0..1) OF NSFile.ExtendedAttributeType ¬ [      nBlocksType];    attrRec: NSFile.AttributesRecord;    NSFile.GetAttributes[      file: fH, selections: [extended: DESCRIPTOR[extSelections]],      attributes: @attrRec, session: data.fileSession];    nBlocks ¬ NSFile.DecodeCardinal[attrRec.extended[0].value];    NSFile.ClearAttributes[@attrRec];    END;  GetNumElements: PROCEDURE [fH: NSFile.Handle]    RETURNS [numQElements: CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    extSelections: ARRAY [0..1) OF NSFile.ExtendedAttributeType ¬ [      numQElementsType];    attrRec: NSFile.AttributesRecord;    NSFile.GetAttributes[      file: fH, selections: [extended: DESCRIPTOR[extSelections]],      attributes: @attrRec, session: data.fileSession];    numQElements ¬ NSFile.DecodeCardinal[attrRec.extended[0].value];    NSFile.ClearAttributes[@attrRec];    END;  GetPerARNum: PROCEDURE [fH: NSFile.Handle]    RETURNS [perARNum: LONG CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    extSelections: ARRAY [0..1) OF NSFile.ExtendedAttributeType ¬ [      perARNumType];    attrRec: NSFile.AttributesRecord;    NSFile.GetAttributes[      file: fH, selections: [extended: DESCRIPTOR[extSelections]],      attributes: @attrRec, session: data.fileSession];    perARNum ¬ NSFile.DecodeLongCardinal[attrRec.extended[0].value];    NSFile.ClearAttributes[@attrRec];    END;  InitNewPage: INTERNAL PROCEDURE [q: Q, page: LONG CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    origin: NSSegment.Origin ¬ [      file: q.fHToBackingFile, base: page, count: 1];    FOR i: CARDINAL IN [0..31] DO      q.buffer[i].priority ¬ null;      q.buffer[i].status ¬ empty;      q.buffer[i].arSequence ¬ [0, 0];      q.buffer[i].timeStamp ¬ Time.defaultTime;      ENDLOOP;    [] ¬ NSSegment.CopyOut[      pointer: q.buffer, origin: origin, session: data.fileSession];    END;  InitQueue: PROCEDURE [q: Q, systemIndex: CARDINAL] =    BEGIN    attsRec: NSFile.AttributesRecord;    accessSession: ARFileAccess.Session;    sysDescription: AdobeOps.ARSystemHandle;    arLocation: NSFile.Reference;    origin: NSSegment.Origin ¬ [      file: q.fHToBackingFile, base: 0, count: 1];    q.systemName ¬ String.MakeString[      data.z, NSString.LogicalLength[data.systems[systemIndex].name]];    NSString.AppendToMesaString[      q.systemName, data.systems[systemIndex].name];    arLocation ¬ AdobeServerOps.GetLocationOfARsInternal[      q.systemName, @attsRec];    accessSession ¬ ARFileAccess.Create[data.z, arLocation];    ARFileAccess.Logon[accessSession, data.serviceId];    sysDescription ¬ AdobeServerOps.RetrieveSystemDescriptionInternal[      data.systems[systemIndex].dfH, data.z];    q.nBlocks ¬ GetNBlocks[q.fHToBackingFile];    q.numOfQElements ¬ GetNumElements[q.fHToBackingFile];    q.periodicUpdateARNum ¬ GetPerARNum[q.fHToBackingFile];    q.processID ¬ FORK AdobeQOps.Updater[      systemIndex, accessSession, sysDescription];    Process.Detach[q.processID];    END;  InitStorage: PROCEDURE [index: CARDINAL] RETURNS [q: Q] =    BEGIN    q ¬ data.systems[index].updaterInfo ¬ data.z.NEW[QObject];    q.buffer ¬ Space.ScratchMap[count: 1];    q.index ¬ data.z.NEW[AdobeQOps.IndexObject ¬ [0, 0]];    END;  InitUpdaterFile: PUBLIC PROCEDURE [parent: NSFile.Handle] =    BEGIN  << initialize first page and set up file attributes >>    q: Q;    origin: NSSegment.Origin;    q ¬ data.z.NEW[QObject];    q.buffer ¬ Space.ScratchMap[count: 1];    q.fHToBackingFile ¬ AdobeServerOps.OpenFile[      parent, S[AdobeServerOps.updaterBackingFile]];    NSSegment.SetSizeInPages[      file: q.fHToBackingFile, pages: 1, session: data.fileSession];    origin ¬ [file: q.fHToBackingFile, base: 0, count: 1];    FOR i: CARDINAL IN [0..31] DO      q.buffer[i].priority ¬ null;      q.buffer[i].status ¬ empty;      q.buffer[i].arSequence ¬ [0, 0];      q.buffer[i].timeStamp ¬ Time.defaultTime;      ENDLOOP;    [] ¬ NSSegment.CopyOut[      pointer: q.buffer, origin: origin, session: data.fileSession];    PutNBlocks[q.fHToBackingFile, 1];    PutNumElements[q.fHToBackingFile, 0];    PutPerARNum[q.fHToBackingFile, 1];    AdobeServerOps.CloseFile[q.fHToBackingFile];    q.buffer ¬ Space.Unmap[q.buffer];    data.z.FREE[@q];    END;  PeriodicUpdate: INTERNAL PROCEDURE [q: Q, systemIndex: CARDINAL]    RETURNS [successful: BOOLEAN ¬ FALSE, arNum: LONG CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    startTime, stopTime: AdobeServer.Time;    lastAR: LONG CARDINAL;    CompactQueue[q];  <<shrink the queue,if possible>>    [startTime, stopTime] ¬ GetTimesInternal[q];    IF CompareTimes[startTime, stopTime] THEN {      q.periodicUpdateARNum ¬ GetPerARNum[q.fHToBackingFile];      arNum ¬ q.periodicUpdateARNum;      lastAR ¬ AdobeServerOps.ReadLastARNumberInternal[q.systemName];      q.periodicUpdateARNum ¬        SELECT arNum FROM          = lastAR => 1,          < lastAR => arNum + 1,          ENDCASE => 1;      PutPerARNum[q.fHToBackingFile, q.periodicUpdateARNum];      IF NOT stoppingService THEN AdobeQOps.WakeUpdater[systemIndex];      AdobeServerOps.FreeTime[startTime];      AdobeServerOps.FreeTime[stopTime];      RETURN[TRUE, arNum]}    ELSE AdobeQOps.PutUpdaterToSleep[systemIndex];    AdobeServerOps.FreeTime[startTime];    AdobeServerOps.FreeTime[stopTime];    END;  PutNBlocks: PROCEDURE [fH: NSFile.Handle, nBlocks: CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    a: ARRAY [0..1) OF NSFile.Attribute ¬ [      [      extended[      type: nBlocksType, value: NSFile.EncodeCardinal[nBlocks]]]];    NSFile.ChangeAttributes[fH, DESCRIPTOR[a], data.fileSession];    NSFile.ClearAttributeList[DESCRIPTOR[a]];    END;  PutNumElements: PROCEDURE [    fH: NSFile.Handle, numQElements: CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    a: ARRAY [0..1) OF NSFile.Attribute ¬ [      [      extended[      type: numQElementsType,      value: NSFile.EncodeCardinal[numQElements]]]];    NSFile.ChangeAttributes[fH, DESCRIPTOR[a], data.fileSession];    NSFile.ClearAttributeList[DESCRIPTOR[a]];    END;  PutPerARNum: PROCEDURE [    fH: NSFile.Handle, perARNum: LONG CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    a: ARRAY [0..1) OF NSFile.Attribute ¬ [      [      extended[      type: perARNumType,      value: NSFile.EncodeLongCardinal[perARNum]]]];    NSFile.ChangeAttributes[fH, DESCRIPTOR[a], data.fileSession];    NSFile.ClearAttributeList[DESCRIPTOR[a]];    END;  StartUpdaterService: PUBLIC PROCEDURE [systemIndex: CARDINAL] =    BEGIN    q: Q;    q ¬ InitStorage[systemIndex];    q.fHToBackingFile ¬ AdobeServerOps.OpenFile[      data.systems[systemIndex].sysH, S[      AdobeServerOps.updaterBackingFile]];    InitQueue[q, systemIndex];    stoppingService ¬ FALSE;    END;  StopUpdaterService: PUBLIC PROCEDURE [systemIndex: CARDINAL] =    BEGIN    q: Q ¬ data.systems[systemIndex].updaterInfo;    stoppingService ¬ TRUE;    StopUpdaterServiceInternal[q, systemIndex];    q.buffer ¬ Space.Unmap[q.buffer];    data.z.FREE[@q.index];    data.z.FREE[@q];    END;  StopUpdaterServiceInternal: ENTRY PROCEDURE [    q: Q, systemIndex: CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    AdobeQOps.PutUpdaterToSleep[systemIndex];  --stop updater cycle    AllowUpdaterToComplete[q, systemIndex];    Process.Abort[q.processID];  -- kill updater process    AdobeServerOps.CloseFile[q.fHToBackingFile];    END;  AllowUpdaterToComplete: INTERNAL PROCEDURE [q: Q, systemIndex: CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    Process.SetTimeout[@aBit, Process.SecondsToTicks[secsToWait]];    WHILE NOT data.systems[systemIndex].updaterSleep DO WAIT aBit; ENDLOOP;    END;  StoppingService: PUBLIC PROCEDURE RETURNS [BOOLEAN] =    BEGIN RETURN[stoppingService] END;  TimePlus5Min: PROCEDURE []    RETURNS [time: System.GreenwichMeanTime] =    BEGIN    unpacked: Time.Unpacked;    unpacked ¬ Time.Unpack[Time.Current[]];    IF unpacked.minute + 5 < 60 THEN      unpacked.minute ¬ unpacked.minute + 5    ELSE {      unpacked.minute ¬ (unpacked.minute + 5) MOD 60;      unpacked.hour ¬ unpacked.hour + 1};    IF unpacked.hour = 24 THEN {      unpacked.hour ¬ 0;      unpacked.day ¬ unpacked.day + 1;      unpacked.weekday ¬ unpacked.weekday + 1};    IF unpacked.weekday = 7 THEN unpacked.weekday ¬ 0;    SELECT unpacked.month FROM      3, 5, 8, 10 =>        IF (unpacked.day = 0 OR unpacked.day = 31) THEN {          unpacked.day ¬ 1; unpacked.month ¬ unpacked.month + 1};      0, 2, 4, 6, 7, 9, 11 =>        IF (unpacked.day = 0 OR unpacked.day = 32) THEN {          unpacked.day ¬ 1; unpacked.month ¬ unpacked.month + 1};      ENDCASE =>        SELECT TRUE FROM          ((unpacked.year MOD 4) = 0) =>            IF (unpacked.day = 0 OR unpacked.day = 30) THEN {              unpacked.day ¬ 1; unpacked.month ¬ unpacked.month + 1};          ENDCASE =>            IF (unpacked.day = 0 OR unpacked.day = 29) THEN {              unpacked.day ¬ 1; unpacked.month ¬ unpacked.month + 1};    IF unpacked.month = 12 THEN {      unpacked.month ¬ 0; unpacked.year ¬ unpacked.year + 1};    time ¬ Time.Pack[unpacked];    END;  UpdateTheseARs: PUBLIC PROCEDURE [    systemName: LONG STRING, arNumber: AdobeOps.RunOfARs] =    BEGIN    q: Q;    successful: BOOLEAN ¬ FALSE;    q ¬ GetQHandle[systemName];    successful ¬ AboutToStoreInternal[      q: q, updateType: updateExplicit, arNumber: arNumber.startValue,      length: arNumber.runLength,      systemIndex: AdobeServerOps.SystemIndex[systemName]];    END;  GetUpdateList: PUBLIC PROCEDURE [systemName: LONG STRING]    RETURNS [updateList: LONG STRING] = {    ENABLE UNWIND => NULL;    q: Q;    q ¬ GetQHandle[systemName];    updateList ¬ GetUpdateListInternal[q]};  GetUpdateListInternal: ENTRY PROCEDURE [q: Q]    RETURNS [updateList: LONG STRING] = {    length: LONG CARDINAL;    origin: NSSegment.Origin;    IF q.numOfQElements = 0 THEN RETURN[NIL]    ELSE updateList ¬ String.MakeString[data.z, 50];    FOR block: CARDINAL IN [0..q.nBlocks) DO      ENABLE        String.StringBoundsFault => {          ns ¬ String.CopyToNewString[s, data.z, s.length + 20];          data.z.FREE[@s];          RESUME [updateList ¬ ns]};      origin ¬ [file: q.fHToBackingFile, base: block, count: 1];      [] ¬ NSSegment.CopyIn[        pointer: q.buffer, origin: origin, session: data.fileSession];      FOR entry: CARDINAL IN [0..31] DO        IF q.buffer[entry].status = empty THEN LOOP;        String.AppendLongNumber[          updateList, q.buffer[entry].arSequence.startingARNumber];        IF (length ¬ q.buffer[entry].arSequence.sequenceLength) > 1          THEN {          String.AppendString[updateList, " - "];          String.AppendLongNumber[            updateList,            q.buffer[entry].arSequence.startingARNumber + q.buffer[              entry].arSequence.sequenceLength - 1]};        String.AppendString[updateList, ", "L];        ENDLOOP;      ENDLOOP;    IF updateList.length > 2 THEN -- in case no entries were found      updateList.length ¬ updateList.length - 2;  --kill last comma    };  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  END.  12-Mar-87 15:33:32 - rlc - add check for 0 arNumber in AboutToStore. Also add cleanup code to FindElement13-Mar-87  9:41:17 - rlc - fix ar10090 StringBoundsFault processing in GetUpdateListInternal10-Jun-87 13:12:16 - rlc - check length of updateList before subtracton 2 in GetUpdateListInternal11-Jun-87 12:40:54 - rlc - AR 10303. shoot QObject.updaterCV and SetCV PROC. use data.updaterSleep instead. 
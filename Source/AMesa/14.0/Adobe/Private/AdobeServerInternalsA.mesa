-- File: AdobeServerInternalsA.mesa - created by JCS. Last edit:-- JCS                  4-May-86 18:09:46-- Copyright (C) 1984, 1985 , 1986 by Xerox Corporation. All rights reserved. -- AdobeServerInternalsA.mesa-- BJD		24-May-84 17:22:07-- RSF		14-Oct-85 14:52:19-- PAD		 9-Jan-85 11:20:41-- JCS		22-Jan-85  9:44:04-- RLC		22-Sep-86 14:11:44DIRECTORY  AdobeCourier USING [    DescribeSystemDescription, LocationOfARs, maxSDPageSize,    RetrieveFromCourierStream, SendToCourierStream],  AdobeOps USING [    ARNumber, ARSystemHandle, ARSystemObject, ARVersion],  AdobeServer USING [Error, StartOrStop, Time],  AdobeServerOps USING [    AccTableRecord, AdobeError, Bug, data, Data, defaultUserFile,    GetDescriptionFile, OpenFile, ReplaceSystemDescription,    SystemEntry, SystemEntryRecord, SystemSequenceRecord],  AdobeUpdater USING [CompletedUpdate, StartUpdaterService],  Courier USING [Arguments, DeserializeParameters, Free, Results],  Environment USING [Block],  Inline USING [LowHalf],  MemoryStream USING [Create, Destroy],  NSAssignedTypes USING [tDirectory],  NSExec USING [SystemDirectory],  NSFile USING [    Attribute, AttributeList, Attributes, AttributesProc,    AttributesRecord, AttributeType, ChangeAttributes,    ClearAttributeList, ClearAttributes, Close, CopyWords, Create,    DecodeLongCardinal, DecodeReference, DecodeString,    EncodeLongCardinal, EncodeReference, EncodeString, Error,    ExtendedAttributeType, GetAttributes, GetReference, Handle, List,    Lock, Logoff, Logon, LogonDirect, nullHandle, OpenByName,    OpenByReference, OpenChild, Selections, ServiceRecord, Session,    String, SystemElement, Time, Words],  NSFileStream USING [Create, Handle],  NSName USING [FreeNameFields, NameFieldsFromString],  NSSegment USING [GetSizeInBytes, GetSizeInPages, Map, Origin],  NSString USING [    CopyString, EquivalentStrings, FreeString, String,    StringFromMesaString],  Process USING [SecondsToTicks, SetTimeout],  Space USING [Deallocate, Interval, UnmapAt],  SpecialNSFile USING [EnablePrivileges],  Stream USING [Delete, Handle, SendNow],  String USING [Replace];AdobeServerInternalsA: MONITOR  << monitor access to:     - the current submit no. for each system     - the location of ARs for each system     - the start and stop times for each system     - version ID     - default user file     monitoring all these together shouldn't cause much waiting. >>  IMPORTS    AdobeCourier, AdobeServer, AdobeServerOps, AdobeUpdater, Courier,    Inline, MemoryStream, NSExec, NSFile,  NSFileStream,    NSName, NSSegment, NSString, Process, Space, SpecialNSFile, Stream, String  EXPORTS AdobeServerOps =  BEGIN OPEN AS: AdobeServerOps;  versionIDType: NSFile.ExtendedAttributeType =    ORD[LAST[NSFile.AttributeType]] + 1;  submitNumberType: NSFile.ExtendedAttributeType = versionIDType + 1;  locOfARsType: NSFile.ExtendedAttributeType = submitNumberType + 1;  startTimeType: NSFile.ExtendedAttributeType = locOfARsType + 1;  stopTimeType: NSFile.ExtendedAttributeType = startTimeType + 1;  nullHandle: NSFile.Handle = NSFile.nullHandle;  adobeSystemExt: LONG STRING = ".as";  data: AS.Data = @AS.data;  -- Adobe server global data  adobeFolder: PUBLIC LONG STRING;  AdobeFolder: NSString.String;  acceleratorsDir: PUBLIC LONG STRING;  AcceleratorsDir: NSString.String;  descriptionFile: PUBLIC LONG STRING;  DescriptionFile: NSString.String;  defaultUserFile: PUBLIC LONG STRING;  DefaultUserFile: NSString.String;  updaterBackingFile: PUBLIC LONG STRING;  UpdaterBackingFile: NSString.String;  ChangeLocationOfARsInternal: PUBLIC PROCEDURE [    systemName, newHost, newDirectory: LONG STRING] = {    DoChangeLoc[data, systemName, newHost, newDirectory]};  --This is a kludge to avoid recompiling now. Fix interface when able  DoChangeLoc: PROCEDURE [    data: AS.Data, systemName, newHost, newDirectory: LONG STRING] = {    service: NSFile.ServiceRecord;    newLoc: AdobeCourier.LocationOfARs;    arSH: AdobeOps.ARSystemHandle;    session: NSFile.Session;    locfH: NSFile.Handle;    descFH: NSFile.Handle ¬ AS.GetDescriptionFile[systemName];    -- create NSFile.Reference    NSName.NameFieldsFromString[      z: data.z, s: S[newHost], destination: @service.name];    << We need to find a workaround for the fact that      NSFile.DecodeReference caches what it finds - valid or invalid.      If we don't force the service to get the address of the FS anew,      it will use what's in the cache; if the cache entry is      incorrect, we can't change it to be correct.  So far I haven't      found a way to make it validate the cache contents before use.>>    session ¬ NSFile.LogonDirect[      identity: data.serviceId, service: @service];    locfH _ NSFile.OpenByName[      directory: NSFile.nullHandle, path: S[newDirectory],      session: session];    newLoc ¬ NSFile.GetReference[file: locfH, session: session];    -- reset attributes    PutLocationOfARsInternal[systemName, newLoc];    -- fix description file    arSH ¬ RetrieveSystemDescriptionInternal[descFH, data.z];    String.Replace[@arSH.host, newHost, data.z];    String.Replace[@arSH.directory, newDirectory, data.z];    arSH.version ¬ arSH.version + 1;    AS.ReplaceSystemDescription[descFH, arSH];    PutVersionIDInternal[systemName, arSH.version];    Courier.Free[      [arSH, AdobeCourier.DescribeSystemDescription], data.z];    data.z.FREE[@arSH];    NSFile.Logoff[session];  --will close any files opened on it    NSName.FreeNameFields[data.z, @service.name]};  FreeSystemDescriptionInternal: PUBLIC PROCEDURE [    arSH: AdobeOps.ARSystemHandle, z: UNCOUNTED ZONE] =    BEGIN    Courier.Free[[arSH, AdobeCourier.DescribeSystemDescription], z];    END;  FreeTime: PUBLIC PROCEDURE [time: AdobeServer.Time] = {    NSString.FreeString[data.z, time]};  GetLocationOfARsInternal: PUBLIC ENTRY PROCEDURE [    system: LONG STRING, attributes: NSFile.Attributes]    RETURNS [location: AdobeCourier.LocationOfARs] =    BEGIN    ENABLE UNWIND => NULL;    extSelections: ARRAY [0..1) OF NSFile.ExtendedAttributeType ¬ [      locOfARsType];    fH: NSFile.Handle ¬ GetDescriptionFile[system];    NSFile.GetAttributes[      file: fH, selections: [extended: DESCRIPTOR[extSelections]],      attributes: attributes, session: data.fileSession];    location ¬ NSFile.DecodeReference[attributes.extended[0].value];    END;  GetNextSubmitNumberInternal: PUBLIC ENTRY PROCEDURE [    system: LONG STRING] RETURNS [arNumber: LONG CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    nextNumber: LONG CARDINAL;    extSelections: ARRAY [0..1) OF NSFile.ExtendedAttributeType ¬ [      submitNumberType];    a: ARRAY [0..1) OF NSFile.Attribute;    attrRec: NSFile.AttributesRecord;    fH: NSFile.Handle ¬ GetDescriptionFile[system];    NSFile.GetAttributes[      file: fH, selections: [extended: DESCRIPTOR[extSelections]],      attributes: @attrRec, session: data.fileSession];    arNumber ¬ NSFile.DecodeLongCardinal[attrRec.extended[0].value];    nextNumber ¬ arNumber + 1;    a ¬ [      [      extended[      type: submitNumberType,      value: NSFile.EncodeLongCardinal[nextNumber]]]];    NSFile.ChangeAttributes[fH, DESCRIPTOR[a], data.fileSession];    NSFile.ClearAttributes[@attrRec];    NSFile.ClearAttributeList[DESCRIPTOR[a]];    END;  GetResidentSystemStringsInternal: PUBLIC PROCEDURE [    arguments: Courier.Arguments, results: Courier.Results] =    BEGIN END;  GetStartOrStopTimeInternal: PUBLIC ENTRY PROCEDURE [    system: LONG STRING, which: AdobeServer.StartOrStop]    RETURNS [startOrStopTime: AdobeServer.Time] =    BEGIN    ENABLE UNWIND => NULL;    extSelections: ARRAY [0..1) OF NSFile.ExtendedAttributeType;    attrRec: NSFile.AttributesRecord;    fH: NSFile.Handle ¬ GetDescriptionFile[system];    SELECT which FROM      start => extSelections ¬ [startTimeType];      stop => extSelections ¬ [stopTimeType];      ENDCASE;    NSFile.GetAttributes[      file: fH, selections: [extended: DESCRIPTOR[extSelections]],      attributes: @attrRec, session: data.fileSession];    startOrStopTime ¬ NSString.CopyString[      data.z, NSFile.DecodeString[attrRec.extended[0].value]];    NSFile.ClearAttributes[@attrRec]    END;  GetSytemDefaultUserFileInternal: PUBLIC ENTRY PROCEDURE [    system: LONG STRING, to: Stream.Handle] =    BEGIN    ENABLE UNWIND => NULL;    from: NSFileStream.Handle;    userFH: NSFile.Handle ¬ AS.OpenFile[      parent: data.systems[SystemIndex[system]].sysH,      path: S[AS.defaultUserFile]];    IF userFH = NSFile.nullHandle THEN {  --there is no user file      Stream.SendNow[to, TRUE];      AS.AdobeError[fileNotFound]};    from ¬ NSFileStream.Create[      file: userFH, closeOnDelete: TRUE, session: data.fileSession];    AdobeCourier.SendToCourierStream[from, to];    Stream.Delete[from];  --also closes file    END;  GetVersionInternal: PUBLIC ENTRY PROCEDURE [system: LONG STRING]    RETURNS [version: AdobeOps.ARVersion] =    BEGIN    ENABLE UNWIND => NULL;    extSelections: ARRAY [0..1) OF NSFile.ExtendedAttributeType ¬ [      versionIDType];    attrRec: NSFile.AttributesRecord;    fH: NSFile.Handle ¬ GetDescriptionFile[system];    NSFile.GetAttributes[      file: fH, selections: [extended: DESCRIPTOR[extSelections]],      attributes: @attrRec, session: data.fileSession];    version ¬ NSFile.DecodeLongCardinal[attrRec.extended[0].value];    RETURN[version];    END;  PutLocationOfARsInternal: PUBLIC ENTRY PROCEDURE [    system: LONG STRING, location: AdobeCourier.LocationOfARs] =    BEGIN    ENABLE UNWIND => NULL;    a: ARRAY [0..1) OF NSFile.Attribute ¬ [      [      extended[      type: locOfARsType, value: NSFile.EncodeReference[location]]]];    fH: NSFile.Handle ¬ OpenDescriptionFile[system];    NSFile.ChangeAttributes[fH, DESCRIPTOR[a], data.fileSession];    NSFile.ClearAttributeList[DESCRIPTOR[a]];    CloseFile[fH];    END;  PutVersionIDInternal: PUBLIC ENTRY PROCEDURE [    system: LONG STRING, version: AdobeOps.ARVersion] =    BEGIN    ENABLE UNWIND => NULL;    a: ARRAY [0..1) OF NSFile.Attribute ¬ [      [      extended[      type: versionIDType,      value: NSFile.EncodeLongCardinal[version]]]];    fH: NSFile.Handle ¬ OpenDescriptionFile[system];    NSFile.ChangeAttributes[fH, DESCRIPTOR[a], data.fileSession];    NSFile.ClearAttributeList[DESCRIPTOR[a]];    CloseFile[fH];    END;  PutStartOrStopTimeInternal: PUBLIC ENTRY PROCEDURE [    system: LONG STRING, which: AdobeServer.StartOrStop,    startOrStopTime: AdobeServer.Time] =    BEGIN    ENABLE UNWIND => NULL;    a: ARRAY [0..1) OF NSFile.Attribute ¬ [      [      extended[      type:      SELECT which FROM        start => startTimeType,        ENDCASE => stopTimeType,      value: NSFile.EncodeString[startOrStopTime]]]];    fH: NSFile.Handle ¬ GetDescriptionFile[system];    NSFile.ChangeAttributes[fH, DESCRIPTOR[a], data.fileSession];    NSFile.ClearAttributeList[DESCRIPTOR[a]];    END;  PutSubmitNumberInternal: PUBLIC ENTRY PROCEDURE [    system: LONG STRING, submitNumber: AdobeOps.ARNumber] =    BEGIN    ENABLE UNWIND => NULL;    a: ARRAY [0..1) OF NSFile.Attribute ¬ [      [      extended[      type: submitNumberType,      value: NSFile.EncodeLongCardinal[submitNumber]]]];    fH: NSFile.Handle ¬ GetDescriptionFile[system];    NSFile.ChangeAttributes[fH, DESCRIPTOR[a], data.fileSession];    NSFile.ClearAttributeList[DESCRIPTOR[a]];    END;  PutSytemDefaultUserFileInternal: PUBLIC ENTRY PROCEDURE [    system: LONG STRING, from: Stream.Handle] =    BEGIN    ENABLE UNWIND => NULL;    to: NSFileStream.Handle;    userFH: NSFile.Handle ¬ AS.OpenFile[      parent: data.systems[SystemIndex[system]].sysH,      path: S[AS.defaultUserFile]];    IF userFH = NSFile.nullHandle THEN {  --must create      fileAttrs: ARRAY [0..1) OF NSFile.Attribute ¬ [        [name[DefaultUserFile]]];      userFH ¬ CreateFile[        directory: data.systems[SystemIndex[system]].sysH,        attributes: DESCRIPTOR[fileAttrs]]};    to ¬ NSFileStream.Create[      file: userFH, closeOnDelete: TRUE, session: data.fileSession];    [] ¬ AdobeCourier.RetrieveFromCourierStream[from, to];    Stream.Delete[to];  --also closes file    END;  ReadLastARNumberInternal: PUBLIC ENTRY PROCEDURE [    system: LONG STRING] RETURNS [lastAR: LONG CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    extSelections: ARRAY [0..1) OF NSFile.ExtendedAttributeType ¬ [      submitNumberType];    attrRec: NSFile.AttributesRecord;    fH: NSFile.Handle ¬ GetDescriptionFile[system];    NSFile.GetAttributes[      file: fH, selections: [extended: DESCRIPTOR[extSelections]],      attributes: @attrRec, session: data.fileSession];    lastAR ¬ NSFile.DecodeLongCardinal[attrRec.extended[0].value] - 1;    NSFile.ClearAttributes[@attrRec];    END;  RetrieveSystemDescription: PUBLIC PROCEDURE [    system: LONG STRING, z: UNCOUNTED ZONE]    RETURNS [arSH: AdobeOps.ARSystemHandle] =    BEGIN    fH: NSFile.Handle ¬ AS.GetDescriptionFile[system];    arSH ¬ RetrieveSystemDescriptionInternal[fH, z];    END;  RetrieveSystemDescriptionInternal: PUBLIC PROCEDURE [    descFH: NSFile.Handle, z: UNCOUNTED ZONE]    RETURNS [arSH: AdobeOps.ARSystemHandle] =    BEGIN    origin: NSSegment.Origin ¬ [      file: descFH, base: 0, count: AdobeCourier.maxSDPageSize];    interval: Space.Interval ¬ NSSegment.Map[      origin: origin, session: data.fileSession];    sH: Stream.Handle ¬ MemoryStream.Create[      b: [      interval.pointer, 0, CARDINAL[      NSSegment.GetSizeInBytes[      file: descFH, session: data.fileSession]]]];    arSH ¬ z.NEW[AdobeOps.ARSystemObject ¬ []];    Courier.DeserializeParameters[      parameters: [      location: arSH,      description: AdobeCourier.DescribeSystemDescription], sH: sH,      zone: z];    MemoryStream.Destroy[sH];    [interval] ¬ Space.UnmapAt[interval.pointer];    Space.Deallocate[interval];    END;  SubmitFailedInternal: PUBLIC ENTRY PROCEDURE [    system: LONG STRING, arNumber: LONG CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    --fixup submit no (bump back by one) if still possible    currentSubmitNo: LONG CARDINAL;    extSelections: ARRAY [0..1) OF NSFile.ExtendedAttributeType ¬ [      submitNumberType];    attrRec: NSFile.AttributesRecord;    fH: NSFile.Handle ¬ GetDescriptionFile[system];    NSFile.GetAttributes[      file: fH, selections: [extended: DESCRIPTOR[extSelections]],      attributes: @attrRec, session: data.fileSession];    currentSubmitNo ¬      NSFile.DecodeLongCardinal[attrRec.extended[0].value] - 1;    IF currentSubmitNo = arNumber THEN {  --no one else has submitted since us      a: ARRAY [0..1) OF NSFile.Attribute ¬ [        [        extended[        type: submitNumberType,        value: NSFile.EncodeLongCardinal[currentSubmitNo]]]];      NSFile.ChangeAttributes[fH, DESCRIPTOR[a], data.fileSession];      NSFile.ClearAttributeList[DESCRIPTOR[a]]};    --else must live with a submit no lost    NSFile.ClearAttributes[@attrRec];    --notify updater    --this routine notifies updater that this AR needn't    --be kept track of any longer (ie drop from in-progress list).    AdobeUpdater.CompletedUpdate[system, arNumber];    END;  VerifyVersionInternal: PUBLIC ENTRY PROCEDURE [    system: LONG STRING, version: AdobeOps.ARVersion]    RETURNS [ok: BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    existingVersion: AdobeOps.ARVersion;    extSelections: ARRAY [0..1) OF NSFile.ExtendedAttributeType ¬ [      versionIDType];    attrRec: NSFile.AttributesRecord;    fH: NSFile.Handle ¬ GetDescriptionFile[system];    NSFile.GetAttributes[      file: fH, selections: [extended: DESCRIPTOR[extSelections]],      attributes: @attrRec, session: data.fileSession];    existingVersion ¬ NSFile.DecodeLongCardinal[      attrRec.extended[0].value];    NSFile.ClearAttributes[@attrRec]; -- RLC 22-Sep-86 14:11:55    RETURN[existingVersion = version];    END;  -- Initialization Procedures  StartUpAdobeDirectory: PUBLIC PROCEDURE =    BEGIN    InitStrings[];    data.fileSession ¬ NSFile.Logon[data.serviceId];    SpecialNSFile.EnablePrivileges[data.fileSession];    -- adobeDir remains open;    data.adobeDir ¬ OpenOrCreateAdobeFolder[];    EnumerateAndOpenAdobeSystems[parent: data.adobeDir];    -- CheckThatTheseSystemsAreEnteredInTheClearinghouse[];    END;  TakeDownAdobeDirectory: PUBLIC PROCEDURE =    BEGIN    -- Logoff will close all files open within the session.    NSFile.Logoff[data.fileSession];    Cleanup[];    END;  InitStrings: PROCEDURE =    BEGIN    adobeFolder ¬ "AdobeFolder";    AdobeFolder ¬ S[adobeFolder];    acceleratorsDir ¬ "Accelerators.dir";    AcceleratorsDir ¬ S[acceleratorsDir];    descriptionFile ¬ "Description.file";    DescriptionFile ¬ S[descriptionFile];    defaultUserFile ¬ "DefaultUser.file";    DefaultUserFile ¬ S[defaultUserFile];    updaterBackingFile ¬ "UpdaterBackingFile";    UpdaterBackingFile ¬ S[updaterBackingFile];    END;  Cleanup: PROCEDURE =    BEGIN    -- if only called from TakeDown which Deletes zone, then no need to deallocate;    END;  OpenOrCreateAdobeFolder: PROCEDURE RETURNS [folder: NSFile.Handle] =    BEGIN    sysDir: NSFile.Handle ¬ NSFile.OpenByReference[      reference: NSFile.GetReference[file: NSExec.SystemDirectory[]],      session: data.fileSession];    IF (folder ¬ OpenByName[sysDir, AdobeFolder]) = nullHandle THEN {      a: ARRAY [0..4) OF NSFile.Attribute ¬ [        [name[AdobeFolder]], [isDirectory[TRUE]], [        type[NSAssignedTypes.tDirectory]], [        childrenUniquelyNamed[TRUE]]];      folder ¬ CreateFile[        directory: sysDir, attributes: DESCRIPTOR[a]]};    CloseFile[sysDir];    END;  CreateResidentSystemStringsFile: PROCEDURE [    directory: NSFile.Handle] RETURNS [fH: NSFile.Handle] = BEGIN END;  LoadResidentSystemStrings: PROCEDURE [fH: NSFile.Handle] =    BEGIN END;  -- Utilities  -- Have this simply enumerate, taking a proc, so that I can open or close these files;  EnumerateAndOpenAdobeSystems: PROC [parent: NSFile.Handle] =    BEGIN  -- Future: filter on ".as" ext    nSystems: CARDINAL = NumberOfChildren[directory: parent];    i: CARDINAL ¬ 0;    AddSystemToSequence: NSFile.AttributesProc =      -- PROC [attributes: NSFile.Attributes]      BEGIN  -- the order will change on subsequent startups;      IF i >= data.systems.length THEN ERROR AS.Bug;      AddSystemEntry[        sysEntry: data.systems[i],        sysH: NSFile.OpenChild[        directory: parent, id: attributes.fileID,        session: data.fileSession],        name: NSString.CopyString[data.z, attributes.name]];      AdobeUpdater.StartUpdaterService[i];      i ¬ i + 1;      END;    data.systems ¬ data.z.NEW[AS .SystemSequenceRecord[nSystems]];    FOR j: CARDINAL IN [0..nSystems) DO      data.systems[j] ¬ data.z.NEW[AS.SystemEntryRecord ¬ []];      ENDLOOP;    NSFile.List[      directory: parent, proc: AddSystemToSequence,      selections: DesiredSelections[], session: data.fileSession];    END;  AddSystemEntry: PROC [    sysEntry: AS.SystemEntry, sysH: NSFile.Handle,    name: NSString.String] =    BEGIN    i: CARDINAL ¬ 0;    -- the order of entries will change on subsequent startups;    proc: NSFile.AttributesProc = {      IF i >= sysEntry.accTable.length THEN ERROR AS.Bug;      sysEntry.accTable[i] ¬ [        file: NSFile.OpenChild[        directory: sysEntry.adH, id: attributes.fileID,        session: data.fileSession],        name: NSString.CopyString[data.z, attributes.name]];      i ¬ i + 1;      };    sysEntry.sysH ¬ sysH;    sysEntry.adH ¬ OpenAcceleratorsDir[parent: sysH];    sysEntry.dfH ¬ OpenFile[parent: sysH, path: DescriptionFile];    sysEntry.name ¬ name;    Process.SetTimeout[      @sysEntry.systemCV, Process.SecondsToTicks[15]];    sysEntry.accTable ¬ data.z.NEW[      AS .AccTableRecord[NumberOfChildren[sysEntry.adH]]];    EnumerateAcceleratorFiles[parent: sysEntry.adH, proc: proc];    END;  EnumerateAcceleratorFiles: PUBLIC PROC [    parent: NSFile.Handle, proc: NSFile.AttributesProc] =    BEGIN  -- Future: filter on ".acc" ext    NSFile.List[      directory: parent, proc: proc, selections: DesiredSelections[],      session: data.fileSession];    END;  DesiredSelections: PROC    RETURNS [selections: NSFile.Selections ¬ []] = {    selections.interpreted[name] ¬ TRUE;    selections.interpreted[fileID] ¬ TRUE;    selections.interpreted[numberOfChildren] ¬ TRUE;    };  OpenByName: PROCEDURE [    directory: NSFile.Handle, path: NSString.String,    lock: NSFile.Lock ¬ share] RETURNS [fH: NSFile.Handle] =    BEGIN    fH ¬ NSFile.OpenByName[      directory: directory, path: path, controls: [lock: lock],      session: data.fileSession !      NSFile.Error =>        WITH error SELECT FROM          access =>            IF problem = fileNotFound THEN {              fH ¬ nullHandle; GOTO return}          ENDCASE];    EXITS return => NULL    END;  GetSystemDirectory: PUBLIC PROC [systemName: LONG STRING]    RETURNS [dH: NSFile.Handle] =    BEGIN RETURN[data.systems[SystemIndex[systemName]].sysH] END;  CreateSystemDirectory: PUBLIC PROCEDURE [systemName: LONG STRING]    RETURNS [sysH: NSFile.Handle] =    BEGIN  -- for now service must be restarted in order to access this new system;  call AddSystemEntry for this system; ???    adobeFolder: NSFile.Handle = data.adobeDir;    nsSystemName: NSString.String = SystemNameToFileName[systemName];    fileAttrs: ARRAY [0..4) OF NSFile.Attribute ¬ [      [name[nsSystemName]], [isDirectory[TRUE]], [      type[NSAssignedTypes.tDirectory]], [      childrenUniquelyNamed[TRUE]]];    sysH ¬ CreateFile[      directory: adobeFolder, attributes: DESCRIPTOR[fileAttrs]];    fileAttrs ¬ [      [name[AcceleratorsDir]], [isDirectory[TRUE]], [      type[NSAssignedTypes.tDirectory]], [      childrenUniquelyNamed[TRUE]]];    CloseFile[      CreateFile[directory: sysH, attributes: DESCRIPTOR[fileAttrs]]];    fileAttrs ¬ [[name[DefaultUserFile]], TRASH, TRASH, TRASH];    CloseFile[      CreateFile[      directory: sysH, attributes: DESCRIPTOR[BASE[fileAttrs], 1]]];    fileAttrs ¬ [      [name[DescriptionFile]], [      extended[      type: submitNumberType, value: NSFile.EncodeLongCardinal[0]]],      TRASH, TRASH];    CloseFile[      CreateFile[      directory: sysH, attributes: DESCRIPTOR[BASE[fileAttrs], 2]]];    fileAttrs ¬ [[name[UpdaterBackingFile]], TRASH, TRASH, TRASH];    CloseFile[      CreateFile[      directory: sysH, attributes: DESCRIPTOR[BASE[fileAttrs], 2]]];    END;  GetAcceleratorsDir: PUBLIC PROC [systemName: LONG STRING]    RETURNS [dH: NSFile.Handle] =    BEGIN RETURN[data.systems[SystemIndex[systemName]].adH] END;  GetAcceleratorFile: PUBLIC PROCEDURE [    systemName: LONG STRING, fieldName: LONG STRING]    RETURNS [fH: NSFile.Handle] =    BEGIN    sysIndex: CARDINAL = SystemIndex[systemName];    FOR i: CARDINAL IN [0..data.systems[sysIndex].accTable.length) DO      IF EquivalentStrings[        ns: data.systems[sysIndex].accTable[i].name, mesa: fieldName]        THEN RETURN[data.systems[sysIndex].accTable[i].file];      ENDLOOP;    ERROR AS.Bug;    END;  OpenAcceleratorFile: PUBLIC PROC [    parent: NSFile.Handle, lock: NSFile.Lock ¬ none,    fieldName: LONG STRING] RETURNS [fH: NSFile.Handle] =    BEGIN    fH ¬ OpenByName[      directory: parent, lock: lock,      path: FieldNameToAccelName[fieldName]];    END;  CreateAcceleratorFile: PUBLIC PROC [    parent: NSFile.Handle, lock: NSFile.Lock ¬ none,    fieldName: LONG STRING] RETURNS [fH: NSFile.Handle] =    BEGIN    fileAttrs: ARRAY [0..1) OF NSFile.Attribute ¬ [      [name[FieldNameToAccelName[fieldName]]]];    fH ¬ CreateFile[      directory: parent, attributes: DESCRIPTOR[fileAttrs]];    END;  SystemNameToFileName: PUBLIC PROC [systemName: LONG STRING]    RETURNS [fileName: NSString.String] =    BEGIN RETURN[S[systemName]] END;  FieldNameToAccelName: PUBLIC PROC [fieldName: LONG STRING]    RETURNS [fileName: NSString.String] =    BEGIN RETURN[S[fieldName]] END;  GetDescriptionFile: PUBLIC PROC [systemName: LONG STRING]    RETURNS [fH: NSFile.Handle] =    BEGIN RETURN[data.systems[SystemIndex[systemName]].dfH] END;  OpenDescriptionFile: PUBLIC PROC [systemName: LONG STRING]    RETURNS [fH: NSFile.Handle] =    BEGIN    sys: NSFile.Handle ¬ OpenByName[      directory: data.adobeDir,      path: SystemNameToFileName[systemName]];    IF sys = nullHandle THEN ERROR AdobeServer.Error[unknownSystem];    fH ¬ OpenFile[parent: sys, path: DescriptionFile];    END;  OpenDefaultUserFile: PUBLIC PROC [    parent: NSFile.Handle, lock: NSFile.Lock]    RETURNS [fH: NSFile.Handle] =    BEGIN    fH ¬ OpenByName[      directory: parent, lock: lock, path: DefaultUserFile];    END;  OpenAcceleratorsDir: PROC [    parent: NSFile.Handle, lock: NSFile.Lock ¬ none]    RETURNS [dH: NSFile.Handle] =    BEGIN    dH ¬ OpenByName[      directory: parent, lock: lock, path: AcceleratorsDir];    END;  OpenMemoryStreamFile: PROCEDURE [fH: NSFile.Handle]    RETURNS [sH: Stream.Handle] =    BEGIN    fileSizeInBytes: LONG CARDINAL ¬ NSSegment.GetSizeInBytes[      file: fH];    IF fileSizeInBytes = 0 THEN RETURN[NIL]    ELSE {      fileSizeInPages: LONG CARDINAL ¬ NSSegment.GetSizeInPages[        file: fH];      origin: NSSegment.Origin ¬ [        file: fH, base: 0, count: fileSizeInPages];      space: Space.Interval ¬ NSSegment.Map[origin: origin];      stop: CARDINAL = Inline.LowHalf[fileSizeInBytes];      block: Environment.Block ¬ [        blockPointer: space.pointer, startIndex: 0,        stopIndexPlusOne: stop];      sH ¬ MemoryStream.Create[block]};    END;  DeleteStreamMemoryStream: PROCEDURE [sH: Stream.Handle] =    BEGIN Stream.Delete[sH]; MemoryStream.Destroy[sH]; END;  OpenFile: PUBLIC PROC [parent: NSFile.Handle, path: NSString.String]    RETURNS [fH: NSFile.Handle] =    BEGIN fH ¬ OpenByName[directory: parent, path: path]; END;  CloseFile: PUBLIC PROCEDURE [fH: NSFile.Handle] =    BEGIN    IF fH # nullHandle THEN NSFile.Close[fH, data.fileSession];    END;  CreateFile: PUBLIC PROC [    directory: NSFile.Handle, attributes: NSFile.AttributeList]    RETURNS [fH: NSFile.Handle] =    BEGIN    RETURN[      NSFile.Create[        directory: directory, attributes: attributes,        session: data.fileSession]];    END;  EncodeSystemElement: PROCEDURE [se: NSFile.SystemElement]    RETURNS [NSFile.Words] =    BEGIN    w: ARRAY [0..6) OF WORD ¬ LOOPHOLE[se];    RETURN[NSFile.CopyWords[DESCRIPTOR[w]]];    END;  DecodeSystemElement: PROCEDURE [words: NSFile.Words]    RETURNS [se: NSFile.SystemElement] =    BEGIN    net: ARRAY [0..2) OF UNSPECIFIED ¬ [words[0], words[1]];    host: ARRAY [0..3) OF UNSPECIFIED ¬ [      words[2], words[3], words[4]];    socket: UNSPECIFIED ¬ words[5];    se ¬ [      net: LOOPHOLE[net], host: LOOPHOLE[host],      socket: LOOPHOLE[socket]];    END;  NumberOfChildren: PROCEDURE [directory: NSFile.Handle]    RETURNS [n: CARDINAL] =    BEGIN    attr: NSFile.AttributesRecord;    selections: NSFile.Selections ¬ [];    selections.interpreted[numberOfChildren] ¬ TRUE;    NSFile.GetAttributes[      file: directory, selections: selections, attributes: @attr,      session: data.fileSession];    RETURN[attr.numberOfChildren];    END;  SystemIndex: PUBLIC PROCEDURE [systemName: LONG STRING]    RETURNS [index: CARDINAL] =    BEGIN    FOR i: CARDINAL IN [0..data.systems.length) DO      IF EquivalentStrings[systemName, data.systems[i].name] THEN        RETURN[i]      ENDLOOP;    ERROR AdobeServer.Error[unknownSystem];    END;  EquivalentStrings: PROC [mesa: LONG STRING, ns: NSString.String]    RETURNS [BOOLEAN] =    BEGIN RETURN[NSString.EquivalentStrings[S[mesa], ns]] END;  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  END.-- RLC		 5-Sep-86 12:55:11 storage leak in Changelocation of ars-- RLC		22-Sep-86 14:11:55 storage leak in VerifyVersionInternal
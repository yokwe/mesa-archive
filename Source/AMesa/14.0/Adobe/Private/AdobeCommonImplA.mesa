-- File: AdobeCommonImplA.mesa - created by MXF. Last edit:-- JCS                   3-Apr-86 10:46:09-- MXF      		19-Oct-83 12:39:44-- RSF       		17-Apr-86 20:01:32 -- RLC			18-Sep-86 15:19:47  -- Copyright (C) 1983, 1985 ,1986 by Xerox Corporation. All rights reserved. DIRECTORY  AccessCH USING [Problem],  AdobeCommon USING [   AddSystemToKnownSystems, AllocateKnownSystems, DeleteSysDescList,   CreateOtherSWs, Data, DataHandle, DestroyOtherSWs, FindSystem,   LocateSystemInKnownSystems, LockedPtr, LockedSysDescPtr,   PostMessage, RemoveSystemFromKnownSystems,   SetFSWOrderAndDefaultFromUserFile, SystemsHandle],  AdobeCommonInternal USING [   ClickToConfirm, FlushCurrentSystem, InstanceDataHandle, NoServer,   NoService, OpenAccessSession, ProcessUserDotCM,   SetDefaultsAndUserContext, SetLogin, StartSystem, SystemNotFound],  AdobeOps USING [ARSystemHandle, CleanUp, Initialize, ToolType],  AdobeToolContext USING [    FreeUserContext, InitializeUserContext, UserContext],  AdobeToolDriver USING [RemoveToolDriver],  ARAccess USING [Destroy, Error, Logoff, Session],  Context USING [Create, Data, Destroy, Find, NopDestroyProc,   Type, UniqueType],  Cursor USING [GetInfo, Set, Type],  Event USING [    aboutToSwap, --DoneWithProcess,-- primaryCredentials,     -- StartingProcess,-- toolWindow],  EventTypes USING [    aboutToAbortSession, aboutToBoot, aboutToBootPhysicalVolume,    aboutToResume, deactivate, primaryCredentials],  Exec USING [AddCommand, ExecProc, RemoveCommand],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, Destroy,    DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    FindItem, ItemHandle, line0, MenuProcType, NopFreeHintsProc,     ProcType, StringItem],  Heap USING [Create, Delete, systemZone],  Menu USING [    Free, Handle, Instantiate, Make, MCRType, Uninstantiate],  MsgSW USING [Clear],  Process USING [Abort, Detach, GetCurrent],  Put USING [CR, LongNumber, Text],  Runtime USING [GetBcdTime],  Selection USING [Set, SetInsertion],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem,    DeleteSubsystem, EnumerationAborted,    nullSubsystem, RemoveDependency, SubsystemHandle],  String USING [AppendString, CopyToNewString, Equal],  TajoMisc USING [toolDriverRunning],  Time USING [Append, Unpack],  Tool USING [Create, Destroy, MakeFormSW, MakeMsgSW, MakeSWsProc],  ToolWindow USING [    Activate, Box, Deactivate, Destroy,      EnumerateInactiveWindows, EnumerateProcType, GetName,    nullBox, --SetName,-- SetTinyName, TransitionProcType, Type,    WindowForSubwindow],  UserInput USING [    AttentionProcType, SetAttention, WaitForConfirmation],  Version USING [Append],  Window USING [EnumerateTree, GetBox, GetParent, Handle, rootWindow];AdobeCommonImplA: MONITOR   LOCKS toolState.lock USING toolState: ToolStateHandle  IMPORTS    AccessCH, AdobeCommon, AdobeCommonInternal, AdobeOps,    AdobeToolContext, AdobeToolDriver, ARAccess, Context, Cursor,    Event, Exec, FormSW, Heap, Menu, MsgSW, Process, Put, Runtime,    Selection, String, Supervisor, TajoMisc, Time, Tool, ToolWindow,    UserInput, Version, Window  EXPORTS AdobeCommon, AdobeCommonInternal =  BEGIN    --Type declarations  FormIndex: TYPE = {tool, another, destroy, change, newSystem};  ToolState: TYPE = {active, inactive};  ToolStateProc: TYPE = PROCEDURE[inState: BOOLEAN]     RETURNS[didIt: BOOLEAN];  ToolStateHandle: TYPE = LONG POINTER TO ToolStateType;  ToolStateType: TYPE = MONITORED RECORD[    lock: MONITORLOCK,    activeTools: CARDINAL ¬ 0,    toolList: ToolList ¬ NIL,    inactiveTools: CARDINAL ¬ 0];  ToolList: TYPE = LONG POINTER TO WindowOfTool;  WindowOfTool: TYPE = RECORD [    w: Window.Handle,    next: ToolList];      -- Global Variable declarations  stateInfo: ToolStateHandle ¬ NIL;  initialHeapSize: CARDINAL = 100;  dataType: Context.Type = Context.UniqueType[];      --Public herald names  editHeraldName: PUBLIC LONG STRING ¬ NIL;  editCkdOutHeraldName: PUBLIC LONG STRING ¬ NIL;  submitHeraldName: PUBLIC LONG STRING ¬ NIL;  reportHeraldName: PUBLIC LONG STRING ¬ NIL;  queryHeraldName: PUBLIC LONG STRING ¬ NIL;  sortHeraldName: PUBLIC LONG STRING ¬ NIL;  queryListHeraldName: PUBLIC LONG STRING ¬ NIL;    --linked list of current system descriptions  sentinal: AdobeCommon.LockedSysDescPtr ¬ NIL;    --Provide the sentinal to outside clients (never used by us)  GetDescList: PUBLIC PROCEDURE[] RETURNS [descListHead: AdobeCommon.LockedSysDescPtr] = {RETURN[sentinal]};  --Find the instance data, given a window handle  GetData: PUBLIC PROCEDURE [w: Window.Handle] RETURNS [AdobeCommon.DataHandle] = {    RETURN Context.Find[dataType, w]};  --Find the instance data, given a subwindow handle  GetDataSW: PUBLIC PROCEDURE [sw: Window.Handle]    RETURNS [AdobeCommon.DataHandle] = {    RETURN Context.Find[dataType, GetToolWindow[sw]]};  <<This procedure is used in place of ToolWindow.WindowForSubwindow.  It will keep us from trying to do a GetParent if we already  have the parent.>>    GetToolWindow: PROCEDURE [window: Window.Handle] RETURNS [Window.Handle] =  { RETURN[      SELECT ToolWindow.Type[window] FROM      tool => window,      clipping => window.GetParent[],      sub => window.GetParent[].GetParent[],      ENDCASE => NIL] };    CheckState: ENTRY PROCEDURE[toolState: ToolStateHandle,   state: ToolState, proc: ToolStateProc] RETURNS[action: BOOLEAN ¬ FALSE] =   BEGIN   ENABLE UNWIND => NULL;   SELECT state FROM    active => IF toolState.activeTools > 0        THEN RETURN[proc[TRUE]]      ELSE RETURN[proc[FALSE]];    inactive => IF toolState.inactiveTools > 0      THEN RETURN[proc[TRUE]]      ELSE RETURN[proc[FALSE]];   ENDCASE;   END;     IncrementState: ENTRY PROCEDURE[toolState: ToolStateHandle,   state: ToolState] =   BEGIN   ENABLE UNWIND => NULL;   SELECT state FROM     active => toolState.activeTools ¬ toolState.activeTools + 1;     inactive => toolState.inactiveTools ¬ toolState.inactiveTools + 1;   ENDCASE;   END;      DecrementState: ENTRY PROCEDURE[toolState: ToolStateHandle,   state: ToolState] =   BEGIN   ENABLE UNWIND => NULL;   SELECT state FROM     active => toolState.activeTools ¬ toolState.activeTools - 1;     inactive => toolState.inactiveTools ¬ toolState.inactiveTools - 1;   ENDCASE;   END;      RemoveWindowFromList: ENTRY PROCEDURE[    toolState: ToolStateHandle, w: Window.Handle] =    BEGIN    t: ToolList;    wPtr: LONG POINTER TO ToolList ¬ @stateInfo.toolList;    WHILE wPtr^ # NIL DO      IF wPtr.w = w THEN {        t ¬ wPtr^;	wPtr^ ¬ wPtr.next;        Heap.systemZone.FREE[@t];	EXIT}      ELSE wPtr ¬ @wPtr.next;      ENDLOOP;    END;      AddWindowToList: ENTRY PROCEDURE[    toolState: ToolStateHandle, w: Window.Handle] =    BEGIN    wPtr: LONG POINTER TO ToolList ¬ @stateInfo.toolList;    WHILE wPtr^ # NIL DO      wPtr ¬ @wPtr.next;      ENDLOOP;    wPtr^ ¬ Heap.systemZone.NEW[WindowOfTool ¬ [w, NIL]];    END;         PostMessage: PUBLIC PROCEDURE [sw: Window.Handle, postCR: BOOLEAN, message: LONG STRING] = {    Put.Text[sw, message];    IF postCR THEN Put.CR[sw]};  PostNumber: PUBLIC PROCEDURE [sw: Window.Handle, postCR: BOOLEAN, number: LONG UNSPECIFIED] = {    Put.LongNumber[sw, number, [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];    IF postCR THEN Put.CR[sw]};  WatchLogin: Supervisor.AgentProcedure =    BEGIN    toolData: AdobeCommon.DataHandle ¬ instanceData;    BEGIN    ENABLE {    AdobeCommonInternal.SystemNotFound => {      AdobeCommon.PostMessage[toolData.msgSW, FALSE, system];      AdobeCommon.PostMessage[toolData.msgSW, TRUE, " is an unknown system!"L];      AdobeCommon.RemoveSystemFromKnownSystems[	system, @toolData.knownSystems, toolData.heap];     << UpdateSystemMenu[toolData];>>      GOTO nope};    AdobeCommonInternal.NoService =>{      AdobeCommon.PostMessage[        toolData.msgSW, TRUE, "No Adobe Service at server!"L];      GOTO nope};    AdobeCommonInternal.NoServer => {      AdobeCommon.PostMessage[        toolData.msgSW, TRUE, "Adobe server is unreachable or down!"L];      GOTO nope}};    IF event = EventTypes.primaryCredentials      AND toolData.window # NIL THEN      IF toolData.accessSession # NIL THEN        AdobeCommonInternal.SetLogin[toolData.accessSession]      ELSE IF toolData.knownSystems # NIL AND         toolData.system # LAST[CARDINAL]  AND        toolData.knownSystems[toolData.system] # NIL THEN           AdobeCommonInternal.OpenAccessSession[toolData];    EXITS      nope => NULL;    END;    END;  CheckDeactivate: Supervisor.AgentProcedure =    BEGIN    toolData: AdobeCommon.DataHandle ¬ instanceData;    toolInstanceData: AdobeCommonInternal.InstanceDataHandle ¬ toolData.instanceData;    IF event = EventTypes.deactivate AND toolData.window # NIL      AND toolData.window = eventData THEN {      IF toolData.isBusy THEN {      PostMessage[        toolData.msgSW, FALSE,         "Adobe is still processsing a command:  aborting deactivation!  "L];      ERROR Supervisor.EnumerationAborted};      IF toolData.accessSession # NIL THEN	ARAccess.Logoff[toolData.accessSession ! ARAccess.Error => 	  { SELECT why FROM	      currentlyCheckedOut =>PostMessage[		toolData.msgSW, FALSE,		"You still have an AR checked out:  aborting deactivation!  "L];	    ENDCASE =>PostMessage[	      toolData.msgSW, FALSE,	      "Unexpected ARAccess error: aborting deactivation!  "L];	    ERROR Supervisor.EnumerationAborted}];      WITH submitData: toolInstanceData SELECT FROM        submit => {	  IF submitData.formDirty THEN {	    AdobeCommon.PostMessage[              toolData.msgSW, TRUE,              "Form has been edited.  Click to confirm! "L];	  IF ~AdobeCommonInternal.ClickToConfirm[	    data: toolData, couldBeForked: FALSE] THEN 	    ERROR Supervisor.EnumerationAborted}};	ENDCASE};    END;      CheckSwapping: Supervisor.AgentProcedure =    BEGIN    SELECT event FROM      EventTypes.aboutToBoot, EventTypes.aboutToAbortSession,      EventTypes.aboutToResume, EventTypes.aboutToBootPhysicalVolume => {      toolData: AdobeCommon.DataHandle ¬ instanceData;      IF toolData.isBusy THEN {      PostMessage[        toolData.msgSW, FALSE,         "Adobe is busy. Aborting swap."L];      PostMessage[ --post to herald also.        NIL, FALSE, "Adobe is busy. Aborting swap."L];      ERROR Supervisor.EnumerationAborted}};      ENDCASE;    END;  SwitchSystems: Menu.MCRType =    BEGIN    toolData: AdobeCommon.DataHandle ¬ GetData[window];    instData: AdobeCommonInternal.InstanceDataHandle ¬ toolData.instanceData;    IF toolData.isBusy THEN      BEGIN      PostMessage[toolData.msgSW, TRUE, "Adobe is busy, cannot switch systems!  "L];      RETURN;      END;    IF index = toolData.system THEN RETURN    ELSE {      toolData.isBusy ¬ TRUE;      toolData.changingSystem ¬ TRUE;      IF instData.background AND ~TajoMisc.toolDriverRunning THEN        Process.Detach[          toolData.processID ¬ FORK ChangeSystem[	  toolData, index, FALSE]]      ELSE {        toolData.processID ¬ Process.GetCurrent[];	ChangeSystem[toolData, index, FALSE]}};    END;      -- Tool needed routines    ClientTransition: ToolWindow.TransitionProcType =    BEGIN    ok: BOOLEAN ¬ TRUE;    toolData: AdobeCommon.DataHandle ¬ GetData[window];    arSH: AdobeOps.ARSystemHandle;    SELECT TRUE FROM      old = inactive =>        BEGIN        IF toolData = NIL THEN	  toolData ¬ InitContext[window, TRUE];	IF --User.cm entry present          toolData.knownSystems # NIL	  AND toolData.knownSystems.next # 0	  --InitialSystem given	  AND toolData.system # LAST[CARDINAL] THEN {	  ENABLE BEGIN	  AccessCH.Problem => {	    SELECT type FROM	      noClearinghouse => 	        AdobeCommon.PostMessage[		  toolData.msgSW, TRUE, "Clearinghouse is unavailable."L];	      authProblem => AdobeCommon.PostMessage[		  toolData.msgSW, TRUE, "Authentication problem."L];	      badDatabaseName => AdobeCommon.PostMessage[		  toolData.msgSW, TRUE, "badDatabaseName."L];	      accessProblem => AdobeCommon.PostMessage[		  toolData.msgSW, TRUE, "access problem in reaching clearinghouse."L]	      ENDCASE => AdobeCommon.PostMessage[		  toolData.msgSW, TRUE, "AccessCH.Problem"L];	    GOTO errors};	  AdobeCommonInternal.SystemNotFound => {	    AdobeCommon.PostMessage[toolData.msgSW, TRUE, "Initial system specified is invalid!"L];	    AdobeCommon.RemoveSystemFromKnownSystems[	      toolData.knownSystems[toolData.system], @toolData.knownSystems, toolData.heap];	   << UpdateSystemMenu[toolData];>>    	    GOTO errors};	  AdobeCommonInternal.NoServer => {	    AdobeCommon.PostMessage[toolData.msgSW, TRUE, "Server down or unreachable!"L];	    GOTO errors};	  AdobeCommonInternal.NoService => {	    AdobeCommon.PostMessage[toolData.msgSW, TRUE, "There is no Adobe Service at the server!"L];	    GOTO errors};	  ABORTED => CONTINUE;	  END;	     	  arSH ¬ AdobeCommon.FindSystem[	    sentinal, toolData,	    toolData.knownSystems[toolData.system], FALSE];	  IF arSH # NIL THEN AdobeCommonInternal.StartSystem[toolData, arSH];	EXITS	  errors => {	    toolData.system ¬ LAST[CARDINAL]; arSH ¬ NIL}};	IF stateInfo.inactiveTools > 0 THEN	  DecrementState[stateInfo, inactive];        IncrementState[stateInfo, active];        IF new = tiny THEN SetTinyName[toolData];        END;      new = inactive =>        BEGIN        IF toolData # NIL THEN	BEGIN	  AdobeToolDriver.RemoveToolDriver[toolData, toolData.tool];	  --prevents Addr fault in FormSWsD which can result if selection left in tool window when window taken down	  Selection.Set[NIL, NIL, NIL];	  Selection.SetInsertion[NIL, NIL, NIL];	  <<IF Selection.Convert[window] = toolData.window THEN	    Selection.Clear[];>> 	  Context.Destroy[type: dataType, window: window];	  toolData ¬ FreeContext[toolData];	END;        DecrementState[stateInfo, active];        IncrementState[stateInfo, inactive];	--only free if there are no instances, active or inactive	IF ~CheckState[stateInfo, inactive, AreThereAnyInactive] THEN	 IF CheckState[stateInfo, active, FreeGlobalStorage]	  THEN Heap.systemZone.FREE[@stateInfo];	--ToolWindow.SetName[window, "Adobe"L];	--Above call does not currently work as advertised because the code which determines the name to use on the Inactive list does not use the variable set by ToolWindow.SetName. Instead it uses the concatenation of the tiny names of the tool. So we must do the following:	ToolWindow.SetTinyName[window, "Adobe"L];        END;      new = tiny =>        BEGIN	 instanceData: AdobeCommonInternal.InstanceDataHandle ¬ 	   toolData.instanceData;	 SetTinyName[toolData];	 IF toolData.tool = edit THEN	 BEGIN	   WITH editData: instanceData SELECT FROM	     edit => ok ¬ ~editData.checkedOut;	   ENDCASE;	 END;	 IF ok AND (toolData.accessSession # NIL) THEN	   ARAccess.Logoff[toolData.accessSession];	END;      ENDCASE    END;      InitContext: PROCEDURE[window: Window.Handle, processUserCm: BOOLEAN]    RETURNS[toolData: AdobeCommon.DataHandle] =    BEGIN    heap: UNCOUNTED ZONE ¬ InitHeap[];    Context.Create[       type: dataType, data: toolData ¬ heap.NEW[    AdobeCommon.Data ¬ [       deacAgent: Supervisor.nullSubsystem,       logonAgent: Supervisor.nullSubsystem,       swapAgent: Supervisor.nullSubsystem,       processID: LOOPHOLE[0]]],       proc: Context.NopDestroyProc,--frees done in transition proc       window: window];    toolData.heap ¬ heap;    toolData.window ¬ window;    IF processUserCm THEN      AdobeCommonInternal.ProcessUserDotCM[toolData];    END;      FreeContext: PROCEDURE[toolData: AdobeCommon.DataHandle]    RETURNS[nilData: AdobeCommon.DataHandle ¬ NIL] =    BEGIN    heap: UNCOUNTED ZONE ¬ toolData.heap;    IF toolData.logonAgent # Supervisor.nullSubsystem THEN {       Supervisor.RemoveDependency[	client: toolData.logonAgent,        implementor: Event.primaryCredentials];      Supervisor.DeleteSubsystem[toolData.logonAgent]};    IF toolData.deacAgent # Supervisor.nullSubsystem THEN {      Supervisor.RemoveDependency[	client: toolData.deacAgent, implementor: Event.toolWindow];      Supervisor.DeleteSubsystem[toolData.deacAgent]};    IF toolData.swapAgent # Supervisor.nullSubsystem THEN {      Supervisor.RemoveDependency[	client: toolData.swapAgent, implementor: Event.aboutToSwap];      Supervisor.DeleteSubsystem[toolData.swapAgent]};    AdobeCommon.DestroyOtherSWs[toolData];    FormSW.Destroy[toolData.cmdSW];    IF toolData.systemMenu # NIL THEN --there are some known systems      {Menu.Uninstantiate[menu: toolData.systemMenu,      window: toolData.window];       Menu.Free[menu: toolData.systemMenu, freeStrings: FALSE]};    FreeToolDataInards[toolData];    Heap.Delete[heap];     END;      FreeGlobalStorage: ToolStateProc =    BEGIN    IF inState THEN RETURN[FALSE]    ELSE       BEGIN      Heap.systemZone.FREE[@editHeraldName];      Heap.systemZone.FREE[@editCkdOutHeraldName];      Heap.systemZone.FREE[@submitHeraldName];      Heap.systemZone.FREE[@reportHeraldName];      Heap.systemZone.FREE[@queryHeraldName];      Heap.systemZone.FREE[@sortHeraldName];      Heap.systemZone.FREE[@queryListHeraldName];      [] ¬ AdobeCommon.DeleteSysDescList[sentinal];      Heap.systemZone.FREE[@sentinal];      RETURN[TRUE]      END;     END;  FreeToolDataInards: PROCEDURE [toolData: AdobeCommon.DataHandle] =    BEGIN    --Free knownSystems      --taken care of by heap delete     --Free user Context      --taken care of by heap delete     --close the access session    IF toolData.accessSession # NIL THEN ARAccess.Destroy[toolData.accessSession];    END;  SetTinyName: PUBLIC PROCEDURE [toolData: AdobeCommon.DataHandle] =    BEGIN        SetEditLine: PROCEDURE RETURNS [LONG STRING ¬ NIL] = INLINE    BEGIN      instanceData: AdobeCommonInternal.InstanceDataHandle ¬ toolData.instanceData;      WITH editData: instanceData SELECT FROM edit =>         IF editData.checkedOut THEN RETURN["**Edit**"L]	ELSE RETURN["Edit"L];      ENDCASE;    END;         name: LONG STRING ¬ "Adobe"L;    name2: LONG STRING ¬      SELECT toolData.tool FROM        edit => IF toolData.instanceData = NIL THEN "Edit"L ELSE SetEditLine[],        submit => "Submit"L,        report => "Report"L,        query => "Query"L,        sort => "Sort"L,	queryList => "QueryList"L,        ENDCASE => NIL;    ToolWindow.SetTinyName[toolData.window, name, name2];    END;  Help: Exec.ExecProc = BEGIN END;  Unload: Exec.ExecProc =   BEGIN    ft, t: ToolList;    data: AdobeCommon.DataHandle;    t ¬ IF stateInfo # NIL THEN stateInfo.toolList ELSE NIL;    WHILE t # NIL DO      data ¬ GetData[t.w];      IF data # NIL THEN {  --not sure if we should remove/delete dependency here or if the tool gets inactive	Supervisor.RemoveDependency[	  client: data.logonAgent,	  implementor: Event.primaryCredentials];	Supervisor.DeleteSubsystem[data.logonAgent];	Supervisor.RemoveDependency[	  client: data.deacAgent, implementor: Event.toolWindow];	Supervisor.DeleteSubsystem[data.deacAgent];	Supervisor.RemoveDependency[	  client: data.swapAgent, implementor: Event.aboutToSwap];	Supervisor.DeleteSubsystem[data.swapAgent];	data.logonAgent ¬ Supervisor.nullSubsystem;	data.deacAgent ¬ Supervisor.nullSubsystem;	data.swapAgent ¬ Supervisor.nullSubsystem};      Tool.Destroy[t.w];      ft ¬ t;      t ¬ t.next;      Heap.systemZone.FREE[@ft];      ENDLOOP;    Exec.RemoveCommand[h, "Adobe.~"L];    AdobeOps.CleanUp[]; --destroy AdobeOps.z  END;  InitHeap: PROCEDURE RETURNS [heap: UNCOUNTED ZONE] = INLINE    BEGIN    RETURN[      Heap.Create[        initial: initialHeapSize, increment: 10, ownerChecking: TRUE,        checking: TRUE]];    END;  MakeHeraldNames: PROCEDURE =  BEGIN    z: UNCOUNTED ZONE ¬ Heap.systemZone;    --make version info    versionStuff: LONG STRING ¬ z.NEW[StringBody [60]];    Version.Append[versionStuff];    String.AppendString[versionStuff, " of "L];    Time.Append[versionStuff, Time.Unpack[Runtime.GetBcdTime[]]];    versionStuff.length ¬ versionStuff.length - 3;  -- gun the seconds    --make the herald messages    editHeraldName ¬ z.NEW[StringBody [60]];    String.AppendString[editHeraldName, "Adobe Edit "L];    String.AppendString[editHeraldName, versionStuff];    editCkdOutHeraldName ¬ z.NEW[StringBody [60]];    String.AppendString[editCkdOutHeraldName, "Adobe Edit "L];    String.AppendString[editCkdOutHeraldName, versionStuff];    String.AppendString[editCkdOutHeraldName, " **checked out**"L];    submitHeraldName ¬ z.NEW[StringBody [60]];    String.AppendString[submitHeraldName, "Adobe Submit "L];    String.AppendString[submitHeraldName, versionStuff];    reportHeraldName ¬ z.NEW[StringBody [60]];    String.AppendString[reportHeraldName, "Adobe Report "L];    String.AppendString[reportHeraldName, versionStuff];    queryHeraldName ¬ z.NEW[StringBody [60]];    String.AppendString[queryHeraldName, "Adobe Query "L];    String.AppendString[queryHeraldName, versionStuff];    sortHeraldName ¬ z.NEW[StringBody [60]];    String.AppendString[sortHeraldName, "Adobe Sort "L];    String.AppendString[sortHeraldName, versionStuff];    queryListHeraldName ¬ z.NEW[StringBody [60]];    String.AppendString[queryListHeraldName, "Adobe Query List "L];    String.AppendString[queryListHeraldName, versionStuff];    z.FREE[@versionStuff];  END;  MakeTool: PROCEDURE [parentData: AdobeCommon.DataHandle, initialBox: ToolWindow.Box] =    BEGIN    w: Window.Handle;    IF parentData = NIL THEN {       w ¬ Tool.Create[         makeSWsProc: MakeSWs, initialState: active,	 initialBox: initialBox,         clientTransition: ClientTransition, name: "Adobe"L,         --Bypassing User.cm if coming from 'Another' speeds up tool creation	 cmSection: IF initialBox = ToolWindow.nullBox THEN "Adobe"L	   ELSE NIL];       AddWindowToList[stateInfo, w]}    ELSE      BEGIN      toolData: AdobeCommon.DataHandle;      w ¬ Tool.Create[         makeSWsProc: MakeSWs, initialState: inactive,	 initialBox: initialBox,         clientTransition: ClientTransition, name: "Adobe"L,         --Bypassing User.cm if coming from 'Another' speeds up tool creation	 cmSection: IF initialBox = ToolWindow.nullBox THEN "Adobe"L	   ELSE NIL];      toolData ¬ InitContext[w, FALSE];      AddWindowToList[stateInfo, w];      toolData.tool ¬ parentData.tool;      IF parentData.knownSystems # NIL THEN {	toolData.knownSystems ¬	  AdobeCommon.AllocateKnownSystems[	    NIL, toolData.heap];	--toolData.knownSystems.next ¬ parentData.knownSystems.next;	FOR i: CARDINAL IN [0..parentData.knownSystems.next) DO	  IF i = toolData.knownSystems.maxLength THEN {	    toolData.knownSystems.next ¬ toolData.knownSystems.maxLength;	    toolData.knownSystems ¬	      AdobeCommon.AllocateKnownSystems[	      toolData.knownSystems, toolData.heap]};	  toolData.knownSystems[i] ¬ String.CopyToNewString[	    parentData.knownSystems[i], toolData.heap];	  ENDLOOP;	toolData.knownSystems.next ¬ parentData.knownSystems.next;	--this should be done in AllocateKnownSystems	FOR j: CARDINAL IN [toolData.knownSystems.next..	  toolData.knownSystems.maxLength) DO	  toolData.knownSystems[j] ¬ NIL; ENDLOOP;	--need to check whether parentData.system indexes to same system in toolData.knownsystems	IF parentData.system = LAST[CARDINAL] THEN	  toolData.system ¬ parentData.system	ELSE IF String.Equal[	  parentData.knownSystems[parentData.system],	  toolData.knownSystems[parentData.system]] THEN	    toolData.system ¬ parentData.system	  ELSE toolData.system ¬ 0};      ToolWindow.Activate[w];      END;    END;    MakeGlobalData: ToolStateProc =   BEGIN   IF inState THEN RETURN[FALSE]   ELSE     BEGIN     MakeHeraldNames[];     sentinal ¬ Heap.systemZone.NEW[        AdobeCommon.LockedPtr ¬ [nodePtr: NIL]];     RETURN[TRUE];     END;   END;    LookOnInactiveList: ToolStateProc =   BEGIN   IF inState THEN      BEGIN     ToolWindow.EnumerateInactiveWindows[SearchForAdobeInInactive];     RETURN[TRUE];     END   ELSE RETURN[FALSE];   END;     AreThereAnyInactive: ToolStateProc =  --This is just returns truth of whether there are any tools of the specified state.   BEGIN    RETURN[inState];  END;     ChangeTools: FormSW.EnumeratedNotifyProcType =   BEGIN    arSH: AdobeOps.ARSystemHandle;    toolData: AdobeCommon.DataHandle ¬ GetDataSW[sw];    formItem: FormSW.ItemHandle;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬ toolData.instanceData;    IF toolData.isBusy THEN {      AdobeCommon.PostMessage[toolData.msgSW, TRUE,	"Can't change tools while busy!"L];      formItem ¬ FormSW.FindItem[instanceData.formSW, index];      formItem.flags.invisible ¬ TRUE;      toolData.tool ¬ oldValue;      formItem.flags.invisible ¬ FALSE;      FormSW.DisplayItem[sw, index];       RETURN};     WITH inst: instanceData SELECT FROM      edit => 	IF inst.checkedOut THEN {	  AdobeCommon.PostMessage[toolData.msgSW, TRUE,	    "Can't change tools while AR checked out!"L];	  formItem ¬ FormSW.FindItem[instanceData.formSW, index];          formItem.flags.invisible ¬ TRUE;	  toolData.tool ¬ oldValue;	  formItem.flags.invisible ¬ FALSE;	  FormSW.DisplayItem[sw, index]; 	  RETURN};      submit => 	IF inst.formDirty THEN {	  oldCursor: Cursor.Type ¬ Cursor.GetInfo[].type;	  AdobeCommon.PostMessage[toolData.msgSW, TRUE,	    "Form has been edited!  Click to confirm!"L];	  Cursor.Set[mouseRed];	  IF UserInput.WaitForConfirmation[].okay THEN 	    Cursor.Set[oldCursor]	  ELSE {	    formItem ¬ FormSW.FindItem[instanceData.formSW, index];            formItem.flags.invisible ¬ TRUE;	    toolData.tool ¬ oldValue;	    formItem.flags.invisible ¬ FALSE;	    FormSW.DisplayItem[sw, index];	    Cursor.Set[oldCursor];	    RETURN}}      ENDCASE;    AdobeToolDriver.RemoveToolDriver[toolData, oldValue];    MsgSW.Clear[toolData.msgSW];    AdobeCommon.DestroyOtherSWs[toolData];    IF toolData.context # NIL THEN { --there is something to free    --want to hang on to same ARSystemHandle      arSH ¬ toolData.context.arSH;      AdobeToolContext.FreeUserContext[	@toolData.context, toolData.heap];      toolData.context ¬ AdobeToolContext.InitializeUserContext[	arSH, toolData.tool, toolData.heap]};    AdobeCommon.CreateOtherSWs[toolData.window];    EnableAdobeAborts[toolData.window];  END;  AdobeCommand: Exec.ExecProc =    BEGIN    IF stateInfo = NIL THEN stateInfo ¬ Heap.systemZone.NEW[        ToolStateType ¬ []];    IF CheckState[stateInfo, inactive, AreThereAnyInactive] THEN      [] ¬ LookOnInactiveList[TRUE]    ELSE BEGIN      [] ¬ CheckState[stateInfo, active, MakeGlobalData];      MakeTool[NIL, ToolWindow.nullBox];      END;    END;  SearchForAdobeInInactive: ToolWindow.EnumerateProcType =    BEGIN    IF String.Equal["Adobe"L, ToolWindow.GetName[window]] THEN {      ToolWindow.Activate[window]; RETURN[TRUE]}    ELSE RETURN[FALSE]    END;  CommandProc: FormSW.ProcType =    BEGIN    toolData: AdobeCommon.DataHandle ¬ GetDataSW[sw];    type: FormIndex ¬ tool;    BEGIN ENABLE ABORTED => AdobeCommon.PostMessage[toolData.msgSW, TRUE, "Aborted!"L];     --if changing system, then another is disallowed.    SELECT type ¬ VAL[index] FROM      another => {	tempBox: ToolWindow.Box;	window: Window.Handle = ToolWindow.WindowForSubwindow [sw];	initialBox: ToolWindow.Box ¬ Window.GetBox[window];	ok: BOOLEAN;	IF toolData.changingSystem THEN {	  AdobeCommon.PostMessage[toolData.msgSW, TRUE, "Unable to create another Adobe tool which changing systems.  Please try again later."L];	  RETURN};	--Ask user for location of top left corner of new window	Cursor.Set [mouseRed];	[initialBox.place, ok] ¬ UserInput.WaitForConfirmation [];	IF NOT ok THEN {Cursor.Set [textPointer]; RETURN};	--Clip window at right and bottom edges of bitmap, so top left corner goes where the user wants it	tempBox ¬ Window.GetBox[Window.rootWindow];	initialBox.dims.w ¬ MIN [initialBox.dims.w, tempBox.dims.w - initialBox.place.x];	initialBox.dims.h ¬ MIN [initialBox.dims.h, tempBox.dims.h - initialBox.place.y];        Cursor.Set [hourGlass];	MakeTool[toolData, initialBox];	Cursor.Set [textPointer]};      destroy =>{         <<Tool.Destroy[toolData.window]; need fix to Tool            interim, do as Tool.Destroy would (should)>>	toolDataWindow: Window.Handle ¬ toolData.window;	IF ~ToolWindow.Deactivate[toolDataWindow]	THEN {	  ToolWindow.Destroy[toolDataWindow];	  RemoveWindowFromList[stateInfo, toolDataWindow];	  IF stateInfo # NIL THEN 	    DecrementState[stateInfo, inactive];	  IF ~CheckState[	    stateInfo, inactive, AreThereAnyInactive] THEN	  IF CheckState[stateInfo, active, FreeGlobalStorage] THEN	    Heap.systemZone.FREE[@stateInfo]}};      change => {        instData: AdobeCommonInternal.InstanceDataHandle ¬ toolData.instanceData;        IF toolData.newSystem = NIL OR toolData.newSystem.length = 0 THEN {	  AdobeCommon.PostMessage[toolData.msgSW, TRUE, "No system specified!"L];	  RETURN};	IF toolData.system # LAST[CARDINAL]          AND toolData.knownSystems # NIL THEN	  IF String.Equal[	    toolData.knownSystems[toolData.system],	    toolData.newSystem] THEN {	    AdobeCommon.PostMessage[toolData.msgSW, FALSE, toolData.newSystem];	    AdobeCommon.PostMessage[toolData.msgSW, TRUE, " is the current Database. No Change made."L];	    RETURN};	IF ~toolData.isBusy THEN {	  toolData.isBusy ¬ TRUE;	  toolData.changingSystem ¬ TRUE;	  IF instData.background AND ~TajoMisc.toolDriverRunning THEN{	    Process.Detach[	      toolData.processID ¬ FORK ChangeSystem[	      toolData, AdobeCommon.LocateSystemInKnownSystems[	      toolData.newSystem, toolData.knownSystems !	      AdobeCommonInternal.SystemNotFound => {		AdobeCommon.AddSystemToKnownSystems[		  system, @toolData.knownSystems, toolData.heap];		<<UpdateSystemMenu[toolData]; >> 	      RETRY}], FALSE]]}	  ELSE {	    toolData.processID ¬ Process.GetCurrent[];	    ChangeSystem[	      toolData, AdobeCommon.LocateSystemInKnownSystems[	      toolData.newSystem, toolData.knownSystems !	      AdobeCommonInternal.SystemNotFound => {		AdobeCommon.AddSystemToKnownSystems[		  system, @toolData.knownSystems, toolData.heap];		<<UpdateSystemMenu[toolData];>>  	      RETRY}], FALSE]}}	ELSE AdobeCommon.PostMessage[toolData.msgSW, TRUE, "Adobe is busy, cannot switch systems!"L];};      ENDCASE;    END;    END;      UpdateSystemMenu: PROCEDURE [data: AdobeCommon.DataHandle] = {    IF data.systemMenu # NIL THEN --there are some known systems      {Menu.Uninstantiate[menu: data.systemMenu,      window: data.window];       Menu.Free[menu: data.systemMenu, freeStrings: FALSE]};    IF data.knownSystems # NIL THEN      data.systemMenu ¬ Menu.Make[	name: "Adobe Systems"L,	strings: DESCRIPTOR[	  @data.knownSystems[0], data.knownSystems.next],        copyStrings: FALSE, mcrProc: SwitchSystems];    Menu.Instantiate[data.systemMenu, data.window]};  ChangeSystem: PUBLIC PROCEDURE [    toolData: AdobeCommon.DataHandle, systemIndex: CARDINAL,    useDescList: BOOLEAN] =    BEGIN    previousSystem: CARDINAL ¬ toolData.system;    {ENABLE {      UNWIND => {	toolData.isBusy ¬ FALSE;	toolData.changingSystem ¬ FALSE};      AccessCH.Problem => {	SELECT type FROM	  noClearinghouse => AdobeCommon.PostMessage[	    toolData.msgSW, TRUE, "Clearinghouse is unavailable."L];	  authProblem => AdobeCommon.PostMessage[	    toolData.msgSW, TRUE, "Authentication problem."L];	  badDatabaseName => AdobeCommon.PostMessage[	    toolData.msgSW, TRUE, "badDatabaseName."L];	  accessProblem => 	    AdobeCommon.PostMessage[	      toolData.msgSW, TRUE, 	      "access problem in reaching clearinghouse."L];	  ENDCASE => AdobeCommon.PostMessage[	    toolData.msgSW, TRUE, "AccessCH.Problem"L];	  GOTO noChange};      AdobeCommonInternal.SystemNotFound => {	AdobeCommon.PostMessage[toolData.msgSW, FALSE, system];	AdobeCommon.PostMessage[	  toolData.msgSW, TRUE, " is an unknown system!"L];	AdobeCommon.RemoveSystemFromKnownSystems[	  system, @toolData.knownSystems, toolData.heap];	<<UpdateSystemMenu[toolData];>>	toolData.system ¬ previousSystem;	GOTO noChange};      AdobeCommonInternal.NoServer => {	AdobeCommon.PostMessage[	  toolData.msgSW, TRUE, 	  "Adobe server is unreachable or down!"L];	toolData.system ¬ previousSystem;	GOTO noChange};      AdobeCommonInternal.NoService => {	AdobeCommon.PostMessage[	  toolData.msgSW, TRUE, "No Adobe Service at server!"L];	toolData.system ¬ previousSystem;	GOTO noChange};      ABORTED => {	AdobeCommon.PostMessage[toolData.msgSW, TRUE, "Aborted!"L];	GOTO noChange}};        arSH: AdobeOps.ARSystemHandle;      oldContext: AdobeToolContext.UserContext ¬ toolData.context;      instanceData: AdobeCommonInternal.InstanceDataHandle ¬        toolData.instanceData;      WITH idata: instanceData SELECT FROM	submit => {	  IF idata.formDirty THEN {	      AdobeCommon.PostMessage[		toolData.msgSW, TRUE,		"Form has been edited!  Click to confirm! "L];	      IF ~AdobeCommonInternal.ClickToConfirm[	        toolData, TRUE] THEN {		GOTO noChange}}};	edit =>	  IF idata.checkedOut THEN	    {PostMessage[	      toolData.msgSW, FALSE, 	      "Cannot change systems while AR is checked out!"L];	     GOTO noChange};	ENDCASE;      PostMessage[toolData.msgSW, FALSE, "Changing Systems..."L];      arSH ¬ AdobeCommon.FindSystem[	sentinal, toolData, toolData.knownSystems[systemIndex],        useDescList];      DisableAdobeAborts[toolData.window];      toolData.system ¬ systemIndex;      <<AdobeCommonInternal.FlushCurrentSystem[toolData];      AdobeCommonInternal.StartSystem[toolData, arSH];>>      ReplaceSystem[toolData, arSH];      AdobeCommon.CreateOtherSWs[toolData.window, FALSE];      EnableAdobeAborts[toolData.window];      PostMessage[toolData.msgSW, TRUE, "Done."L];      toolData.isBusy ¬ FALSE;      toolData.processID ¬ NIL;      toolData.changingSystem ¬ FALSE;    EXITS      noChange => {	toolData.isBusy ¬ FALSE;	toolData.processID ¬ NIL;	toolData.changingSystem ¬ FALSE}};    END;    ReplaceSystem: PROCEDURE [    toolData: AdobeCommon.DataHandle, arSH: AdobeOps.ARSystemHandle] = {    oldSession: ARAccess.Session ¬ toolData.accessSession;    oldContext: AdobeToolContext.UserContext ¬ toolData.context;    {ENABLE UNWIND => IF oldSession # toolData.accessSession THEN {      ARAccess.Destroy[toolData.accessSession ! ARAccess.Error =>        IF why = invalidSession THEN CONTINUE];      toolData.accessSession ¬ oldSession;      toolData.context ¬ oldContext};    --set context to NIL so OpenAccessSession will know this is a new database    toolData.context ¬ NIL;    AdobeCommonInternal.OpenAccessSession[toolData];    AdobeCommon.SetFSWOrderAndDefaultFromUserFile[      toolData.knownSystems[toolData.system], arSH];    <<If we've reached this point successfully, the system change will      complete so we can free the old database's information and      replace it with the new>>    ARAccess.Destroy[oldSession !      ARAccess.Error => IF why = invalidSession THEN CONTINUE];    AdobeCommonInternal.FlushCurrentSystem[toolData];    AdobeCommonInternal.SetDefaultsAndUserContext[toolData, arSH];    toolData.context.arSH ¬ arSH}};   MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    -- This procedure creates a sample FormSW.    formItems: LONG POINTER TO ARRAY FormIndex OF FormSW.ItemHandle ¬ NIL;    toolSeq: TYPE = RECORD [seq: SEQUENCE length: CARDINAL OF Enumerated];    toolData: AdobeCommon.DataHandle ¬ GetDataSW[sw];    tools: LONG POINTER TO toolSeq ¬ toolData.heap.NEW[      toolSeq [AdobeOps.ToolType.LAST.ORD + 1]];    tools[ORD[AdobeOps.ToolType.edit]] ¬ ["Edit"L, AdobeOps.ToolType.edit];    tools[ORD[AdobeOps.ToolType.submit]] ¬ ["Submit"L, AdobeOps.ToolType.submit];    tools[ORD[AdobeOps.ToolType.report]] ¬ ["Report"L, AdobeOps.ToolType.report];    tools[ORD[AdobeOps.ToolType.query]] ¬ ["Query"L, AdobeOps.ToolType.query];    tools[ORD[AdobeOps.ToolType.sort]] ¬ ["Sort"L, AdobeOps.ToolType.sort];    tools[ORD[AdobeOps.ToolType.queryList]] ¬ [      "QueryList"L, AdobeOps.ToolType.queryList];    items ¬ AllocateItemDescriptor[      nItems: FormIndex.LAST.ORD + 1, z: toolData.heap];    formItems ¬ LOOPHOLE[BASE[items]];    formItems^ ¬ [      tool: EnumeratedItem[       tag: "Tool"L, place: [0, line0], z: toolData.heap,       feedback: one, value: @toolData.tool, copyChoices: TRUE,       proc: ChangeTools, choices: DESCRIPTOR[tools]],      another: CommandItem[      tag: "Another"L, z: toolData.heap, proc: CommandProc],      destroy: CommandItem[      tag: "Destroy"L, z: toolData.heap, proc: CommandProc],      change: CommandItem[      tag: "ChangeSystem"L, z: toolData.heap,      proc: CommandProc],      newSystem: StringItem[      tag: "System"L, z: toolData.heap,      string: @toolData.newSystem, inHeap: TRUE, menuProc: DatabaseHintsProc]];    RETURN[items: items, freeDesc: TRUE]    END;          DatabaseHintsProc: FormSW.MenuProcType =    BEGIN    toolData: AdobeCommon.DataHandle ¬ GetDataSW[sw];    toolData.newSystem ¬ NIL;    FormSW.DisplayItem[sw, index];    IF toolData.knownSystems # NIL THEN      RETURN[hints: DESCRIPTOR[@toolData.knownSystems[0],                               toolData.knownSystems.next],	     freeHintsProc: FormSW.NopFreeHintsProc, 	     replace: FALSE]        ELSE -- if no user.cm would crash AR9698      AdobeCommon.PostMessage[toolData.msgSW, TRUE,         "No known systems. Type in a system name and bug ChangeSystem."L];      RETURN[hints: DESCRIPTOR[NIL,0],             freeHintsProc: FormSW.NopFreeHintsProc, 	     replace: FALSE];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    toolData: AdobeCommon.DataHandle ¬ GetData[window];    IF toolData.deacAgent = Supervisor.nullSubsystem THEN      toolData.deacAgent ¬ Supervisor.CreateSubsystem[        agent: CheckDeactivate, instanceData: toolData];    IF toolData.logonAgent = Supervisor.nullSubsystem THEN      toolData.logonAgent ¬ Supervisor.CreateSubsystem[        agent: WatchLogin, instanceData: toolData];    IF toolData.swapAgent = Supervisor.nullSubsystem THEN      toolData.swapAgent ¬ Supervisor.CreateSubsystem[        agent: CheckSwapping, instanceData: toolData];    <<    IF toolData.systemMenu # NIL THEN --there are some known systems      {Menu.Uninstantiate[menu: toolData.systemMenu,      window: toolData.window];       Menu.Free[menu: toolData.systemMenu, freeStrings: FALSE]};    IF toolData.knownSystems # NIL THEN      toolData.systemMenu ¬ Menu.Make[	name: "Adobe Systems"L,	strings: DESCRIPTOR[	  @toolData.knownSystems[0], toolData.knownSystems.next],        copyStrings: FALSE, mcrProc: SwitchSystems];    Menu.Instantiate[toolData.systemMenu, window];     >>    toolData.msgSW ¬ Tool.MakeMsgSW[window: window, lines: 2];    toolData.cmdSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: toolData.heap];    AdobeCommon.CreateOtherSWs[window];    EnableAdobeAborts[toolData.window];    Supervisor.AddDependency[      client: toolData.deacAgent, implementor: Event.toolWindow];    Supervisor.AddDependency[      client: toolData.logonAgent, implementor: Event.primaryCredentials];    Supervisor.AddDependency[      client: toolData.swapAgent, implementor: Event.aboutToSwap];    END;      SetAttns: PROCEDURE [window: Window.Handle] = {    UserInput.SetAttention[window, AttentionProc]};  ClearAttns: PROCEDURE [window: Window.Handle] = {    UserInput.SetAttention[window, StallAbort]};      EnableAdobeAborts: PUBLIC PROCEDURE [w: Window.Handle] = {    Window.EnumerateTree[w, SetAttns];    UserInput.SetAttention[w, AttentionProc]};    DisableAdobeAborts: PUBLIC PROCEDURE [w: Window.Handle] = {    Window.EnumerateTree[w, ClearAttns];    UserInput.SetAttention[w, StallAbort]};  AttentionProc: UserInput.AttentionProcType = {    Attention: ENTRY PROCEDURE [toolState: ToolStateHandle] = {      ENABLE UNWIND => NULL;      toolData: AdobeCommon.DataHandle ¬ GetDataSW[window];      p: PROCESS ¬ toolData.processID;      IF toolData.isBusy AND p # NIL THEN {	  Process.Abort[p];	  toolData.processID ¬ NIL}};    Attention[stateInfo]};      StallAbort: UserInput.AttentionProcType = {    Stall: ENTRY PROCEDURE [toolState: ToolStateHandle] = {      ENABLE UNWIND => NULL;      toolData: AdobeCommon.DataHandle ¬ GetDataSW[window];      AdobeCommon.PostMessage[        toolData.msgSW, FALSE,        "ABORT temporarily disabled, retry... "L]};    Stall[stateInfo]};  Init: PROCEDURE = {    AdobeOps.Initialize[]; --creates zone and nilPossibilities    Exec.AddCommand["Adobe.~"L, AdobeCommand, Help, Unload]};  -- Mainline code  Init[];  -- this gets string out of global frame  END...  -- RLC			21-Jul-86  8:33:28 Update and SwitchSystems no longer used -- RLC			18-Sep-86 15:19:47 AR9698
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- File: ARAccess.mesa  Edited by:-- BJD    	 9-May-84 12:14:39-- Somers	 5-May-83 12:03:21-- LXR    	 5-May-83 13:59:09-- JCS    	 4-Sep-85 11:04:45-- RSF		18-Sep-85 17:42:31DIRECTORY  Auth USING [IdentityHandle],  NSFile USING [Reference],  Stream USING [Handle];ARAccess: DEFINITIONS =  BEGIN  -- Types and data  Session: TYPE = LONG POINTER TO SessionObject;  SessionObject: TYPE;  ARHandle: TYPE = LONG POINTER TO ARObject;  ARObject: TYPE;  -- Procedures  -- zone is from where any storage is allocated; arLocation is the NSFile.ID and NSFile.Service of the AR directory; this is returned from AdobeServer.GetLocationOfARs;  Create: PROCEDURE [    zone: UNCOUNTED ZONE, arLocation: NSFile.Reference]    RETURNS [session: Session];  Destroy: PROCEDURE [session: Session];  Logon: PROCEDURE [session: Session, user: Auth.IdentityHandle];  Logoff: PROCEDURE [session: Session];  -- In order to operate on any AR, the client must first call GetAR to find the associated file.  This handle is then passed to any of the AR routines; GetAR opens a connection to the file server;  If a communication error occurs between a GetAR and another AR routine, the client must do a FreeAR and another GetAR; there must not be any long delays between GetAR and any operation taking the returned ARHandle;  GetAR: PROCEDURE [session: Session, arNumber: LONG CARDINAL]    RETURNS [arH: ARHandle];  ExamineAR: PROCEDURE [    session: Session, arH: ARHandle, to: Stream.Handle];  FreeAR: PROCEDURE [session: Session, arH: ARHandle]    RETURNS [nil: ARHandle];  --CheckOut always retrieves the AR, in case someone else has done a CheckIn between your Examine and CheckOut;  CheckOutAR: PROCEDURE [    session: Session, arH: ARHandle, to: Stream.Handle];  CheckInAR: PROCEDURE [    session: Session, arH: ARHandle, from: Stream.Handle];  AbortCheckOut: PROCEDURE [session: Session, arH: ARHandle];  SubmitAR: PROCEDURE [  -- stores a modified AR --    session: Session, arNumber: LONG CARDINAL, from: Stream.Handle];  -- Signals and Errors  ErrorCode: TYPE = MACHINE DEPENDENT {    -- client bugs    invalidARHandle(0), invalidARNumber, invalidSession,    youMustFirstCheckIn,    -- to be caught by client         invalidLogin(4), authError, accessDenied, accessUndetermined,    arNotFound, directoryNotFound, hostNotFound, serverNotResponding,    communicationError, crashDuringCheckOut, notCheckedOut,    currentlyCheckedOut, fileServerFull, directoryFull,    -- unknown error    unknown(31)};  Error: ERROR [session: Session, why: ErrorCode];  END.
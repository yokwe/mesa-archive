-- Copyright (C) 1984, 1985, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- AdobeCourierServerImplA.mesa-- BJD    	24-May-84 17:32:44-- RSF      	16-Oct-85 17:35:16-- PAD           5-Dec-84 11:11:03-- JCS           6-Oct-85 20:36:11-- RLC		25-Feb-88 15:05:33-- Adobe Courier server stubDIRECTORY  AccessCH USING [Problem],  AdobeCourier USING [    CourierToAdobeError, DescribeBoolean, DescribeLocationOfARs,    DescribeSubmitFailedArguments, DescribeSubmitNumber,    DescribeSystemName, DescribeVerifyVersionArguments, highVersion,    LocationOfARs, lowVersion, maxSDPageSize, ProcedureIndex,    ProcedureType, programNumber, ServiceProc, SubmitFailedArguments,    VerifyVersionArguments, versionRange],  AdobeOps USING [ARVersion],  AdobeQOps USING [WakeUpdater],  AdobeServer USING [Error, ErrorType],  AdobeServerOps USING [    AboutToStore, CompletedUpdate, data, Data, GetAcceleratorInfo,    GetDescriptionFile, GetLocationOfARsInternal,    GetNextSubmitNumberInternal, GetSystemDirectory,    GetSytemDefaultUserFileInternal, LookupARs,    MakeAcceleratorFileForField, ReadLastARNumberInternal,    StartUpAdobeDirectory, SystemIndex, SubmitFailedInternal,    TakeDownAdobeDirectory, UpdateAcceleratorField,    UpdateAccelerators, VerifyVersionInternal],  AdobeUpdater USING [StopUpdaterService],  Courier USING [    Description, Dispatcher, Error, ExportRemoteProgram, Free,    NoSuchProcedureNumber, nullParameters, SignalRemoteError,    UnexportRemoteProgram],  Heap USING [systemZone],  NSFile USING [    Attribute, AttributesRecord, ClearAttributes, Handle, String,    Time],  NSName USING [maxLocalLength],  NSSegment USING [    GetSizeInBytes, Map, Origin],  NSString USING [String, StringFromMesaString],  Process USING [Seconds, SecondsToTicks, SetTimeout],  Space USING [Unmap],  Stream USING [Handle],  String USING [AppendChar, MakeString];AdobeCourierServerImplA: MONITOR LOCKS data USING data: Data  -- Monitor access to the currentClients counter  IMPORTS    AccessCH, AdobeCourier, AdobeQOps, AdobeServer, AdobeServerOps,    AdobeUpdater, Courier, Heap, NSFile, NSSegment, NSString,    Process, Space, String  EXPORTS AdobeServerOps =  BEGIN OPEN AS: AdobeServerOps;      maxClients: CARDINAL ¬ 20;  -- [Rasp:]<Test>AdobeTest>  net: ARRAY [0..2) OF WORD ¬ [0, 74B];  h: ARRAY [0..3) OF WORD ¬ [0, 125000B, 10643B];  id: ARRAY [0..5) OF WORD ¬ [0, 125000B, 10643B, 73510B, 16502B];  Data: TYPE = AS.Data;  data: Data = @AS.data;  procArray: ARRAY AdobeCourier.ProcedureType OF    AdobeCourier.ServiceProc = [    GetNextSubmitNumber, PutSubmitNumber, ReadLastARNumber,    SubmitFailed, AdobeServerOps.LookupARs,    AdobeServerOps.UpdateAccelerators, AdobeServerOps.AboutToStore,    AdobeServerOps.UpdateAcceleratorField,    AdobeServerOps.CompletedUpdate, GetLocationOfARs,    PutLocationOfARs, PutVersionID, GetVersion, PutSystemDescription,    GetSystemDescription, PutSystemDefaultUserFile,    GetSystemDefaultUserFile, GetResidentSystemStrings, VerifyVersion,    PutStartOrStopTime, GetStartOrStopTime,    AdobeServerOps.GetAcceleratorInfo,    AdobeServerOps.MakeAcceleratorFileForField];  translateProc: ARRAY AdobeCourier.ProcedureIndex OF    AdobeCourier.ProcedureType = [    getSubmitNumber, putSubmitNumber, readLastARNumber, submitFailed,    lookupARs, updateAccelerators, aboutToStore,    updateAcceleratorField, completedUpdate, getLocationOfARs,    putLocationOfARs, putVersionID, getVersion, putSystemDescription,    getSystemDescription, putSystemDefaultUser, getSystemDefaultUser,    getResidentSystemStrings, verifyVersion, putStartOrStopTime,    getStartOrStopTime, getAcceleratorInfo, makeAccelFileForField];  secsToWait: Process.Seconds = 1;  aBit: CONDITION;  GetNextSubmitNumber: AdobeCourier.ServiceProc =    BEGIN    submitNumber: LONG CARDINAL;    systemName: LONG STRING ¬ NIL;    proc: PROC = {      arguments[[@systemName, AdobeCourier.DescribeSystemName]];      submitNumber ¬ AS.GetNextSubmitNumberInternal[systemName];      [] ¬ results[        [@submitNumber, AdobeCourier.DescribeSubmitNumber]];      };    CatchErrors[proc];    Courier.Free[      [@systemName, AdobeCourier.DescribeSystemName], data.z]    END;  PutSubmitNumber: AdobeCourier.ServiceProc =    BEGIN    << not allowed remotely    args: AdobeCourier.PutSubmitNumberArguments;    proc: PROC = {      arguments[        [@args, AdobeCourier.DescribePutSubmitNumberArguments]];      AS.PutSubmitNumberInternal[args.systemName, args.submitNumber];      [] ¬ results[];      };    CatchErrors[proc];    Courier.Free[      [@args, AdobeCourier.DescribePutSubmitNumberArguments], data.z]>>    END;  ReadLastARNumber: AdobeCourier.ServiceProc =    BEGIN    lastAR: LONG CARDINAL;    systemName: LONG STRING ¬ NIL;    proc: PROC = {      arguments[[@systemName, AdobeCourier.DescribeSystemName]];      lastAR ¬ AS.ReadLastARNumberInternal[systemName];      [] ¬ results[[@lastAR, AdobeCourier.DescribeSubmitNumber]];      };    CatchErrors[proc];    Courier.Free[      [@systemName, AdobeCourier.DescribeSystemName], data.z]    END;  SubmitFailed: AdobeCourier.ServiceProc =    BEGIN    args: AdobeCourier.SubmitFailedArguments;    proc: PROC = {      arguments[[@args, AdobeCourier.DescribeSubmitFailedArguments]];      --don't want to check version because someone can fail because of his having an obsolete version.      AS.SubmitFailedInternal[args.systemName, args.arNumber];      [] ¬ results[];      };    CatchErrors[proc];    Courier.Free[      [@args, AdobeCourier.DescribeSubmitFailedArguments], data.z]    END;  GetLocationOfARs: AdobeCourier.ServiceProc =    BEGIN    locOfARs: AdobeCourier.LocationOfARs;    systemName: LONG STRING ¬ NIL;    attrRec: NSFile.AttributesRecord;  -- local locOfARs depends on existence of attrRec     proc: PROC = {      arguments[[@systemName, AdobeCourier.DescribeSystemName]];      IF ~data.systems[AdobeServerOps.SystemIndex[systemName]].stable THEN        AdobeError[sysDescChanging];      locOfARs ¬ AS.GetLocationOfARsInternal[systemName, @attrRec];      [] ¬ results[[@locOfARs, AdobeCourier.DescribeLocationOfARs]];      };    CatchErrors[proc];    Courier.Free[      [@systemName, AdobeCourier.DescribeSystemName], data.z];    NSFile.ClearAttributes[@attrRec];    END;  PutLocationOfARs: AdobeCourier.ServiceProc =    BEGIN  << not to be allowed remotely    args: AdobeCourier.PutLocationOfARsArguments;    proc: PROC = {      arguments[        [@args, AdobeCourier.DescribePutLocationOfARsArguments]];      AS.PutLocationOfARsInternal[args.systemName, args.loc];      [] ¬ results[];      };    CatchErrors[proc];    Courier.Free[      [@args, AdobeCourier.DescribePutLocationOfARsArguments], data.z]    >>    END;  PutVersionID: AdobeCourier.ServiceProc =    BEGIN  << not to be allowed remotely    args: AdobeCourier.PutVersionIDArguments;    proc: PROC = {      arguments[[@args, AdobeCourier.DescribePutVersionIDArguments]];      AS.PutVersionIDInternal[args.systemName, args.versionID];      [] ¬ results[];      };    CatchErrors[proc];    Courier.Free[      [@args, AdobeCourier.DescribePutVersionIDArguments], data.z] >>    END;  PutStartOrStopTime: AdobeCourier.ServiceProc =    BEGIN  << not to be allowed remotely    args: AdobeCourier.PutTimeArguments;    proc: PROCEDURE = {      arguments[[@args, AdobeCourier.DescribePutTimeArguments]];      AS.PutStartOrStopTimeInternal[        args.systemName, args.which, args.startOrStopTime];      [] ¬ results[]};    CatchErrors[proc];    Courier.Free[      [@args, AdobeCourier.DescribePutTimeArguments], data.z];>>    END;  GetStartOrStopTime: AdobeCourier.ServiceProc =    BEGIN  << not needed remotely    startOrStopTime: AdobeServer.Time;    args: AdobeCourier.GetTimeArguments;    proc: PROCEDURE = {      arguments[[@args, AdobeCourier.DescribeGetTimeArguments]];      startOrStopTime ¬ AS.GetStartOrStopTimeInternal[        args.systemName, args.which];      [] ¬ results[[@startOrStopTime, AdobeCourier.DescribeTime]];      };    CatchErrors[proc];    Courier.Free[      [@args, AdobeCourier.DescribeGetTimeArguments], data.z];    Courier.Free[      [@startOrStopTime, AdobeCourier.DescribeTime], data.z];>>    END;  GetLocalPart: PROCEDURE [qualifiedName: LONG STRING]    RETURNS [localPart: LONG STRING] = {    i: CARDINAL ¬ 0;    localPart ¬ String.MakeString[      Heap.systemZone, NSName.maxLocalLength];    DO      IF qualifiedName[i] = ': THEN EXIT;      String.AppendChar[s: localPart, c: qualifiedName[i]];      i ¬ i + 1;      ENDLOOP};  PutSystemDescription: AdobeCourier.ServiceProc =    BEGIN    --  Put a new system description; in order for it to be recognized by users, service must be restarted;  << not to be allowed remotely    args: AdobeCourier.PutSystemDescriptionArguments;    origin: NSSegment.Origin;    systemName: NSName.Name;    sdFH, sDH, acDH, acFH: NSFile.Handle ¬ NSFile.nullHandle;    interval: Space.Interval;    DescribePutSystemDescriptionArguments: Courier.Description = {      p: LONG POINTER TO AdobeCourier.PutSystemDescriptionArguments ¬        notes.noteSize[        SIZE[AdobeCourier.PutSystemDescriptionArguments]];      systemExists: BOOLEAN ¬ FALSE;      localSystemName: LONG STRING;      --see AdobeServerInternals for other ExtendedAttributeType's      submitNumberType: NSFile.ExtendedAttributeType =        ORD[LAST[NSFile.AttributeType]] + 2;      startTimeType: NSFile.ExtendedAttributeType =        submitNumberType + 2;      stopTimeType: NSFile.ExtendedAttributeType = startTimeType + 1;      a: ARRAY [0..3) OF NSFile.Attribute ¬ [  --initial attributes        [        extended[        type: submitNumberType, value: NSFile.EncodeLongCardinal[1]]],        [        extended[        type: startTimeType,        value: NSFile.EncodeString[S["00:00:00"L]]]], [        extended[        type: stopTimeType,        value: NSFile.EncodeString[S["00:00:00"L]]]]];      notes.noteString[@p.systemName];  -- ** need to free on unwind somewhere      IF notes.operation = store THEN        localSystemName ¬ GetLocalPart[p.systemName];      IF SystemExists[localSystemName] THEN        AdobeError[systemAlreadyExists];      SELECT notes.operation FROM        store => {          sDH ¬ AS.CreateSystemDirectory[localSystemName];          sdFH ¬ AS.OpenFile[            parent: sDH, path: S[AS.descriptionFile]];          notes.noteDeadSpace[@p.sd, SIZE[LONG POINTER]];          NSSegment.SetSizeInBytes[            file: sdFH, bytes: p.length * 2,            session: data.fileSession];          origin ¬ [            file: sdFH, base: 0,            count: (p.length / Environment.wordsPerPage) + 1];          interval ¬ NSSegment.Map[            origin: origin, session: data.fileSession];          NSSegment.MakeWritable[            interval: interval, file: sdFH,            session: data.fileSession];          p.sd ¬ interval.pointer;          notes.noteSpace[p.sd, p.length];          [] ¬ NSSegment.CopyOut[            pointer: p.sd, origin: origin, session: data.fileSession];          NSFile.ChangeAttributes[            sdFH, DESCRIPTOR[a], data.fileSession];          NSFile.ClearAttributeList[DESCRIPTOR[a]]};        free => interval.pointer ¬ Space.Unmap[interval.pointer];        ENDCASE => ERROR AS.Bug};    putNewSystem: PROC = {      ok: BOOLEAN ¬ FALSE;      arguments[[@args, DescribePutSystemDescriptionArguments]];      BEGIN      description: AdobeOps.ARSystemHandle ¬        AS.RetrieveSystemDescriptionInternal[sdFH, data.z];      -- create accelerator files for those fields that require one;      acDH ¬ AS.OpenFile[parent: sDH, path: S[AS.acceleratorsDir]];      FOR i: CARDINAL IN [0..description.fieldList.len) DO        IF description.fieldList[i].type # string THEN          AS.CloseFile[            AS.CreateAcceleratorFile[            parent: acDH, fieldName: description.fieldList[i].name]];        ENDLOOP;      --create updater's backing file and initialize contents      AdobeUpdater.InitUpdaterFile[parent: sDH];      systemName ¬ NSName.NameFromString[        z: data.z, s: S[args.systemName]];      ok ¬ AccessCH.RegisterDatabase[        database: systemName, service: data.serviceName,        primaryPID: AccessCH.adobeSystemPID,        genericPIDs: AccessCH.adobeGenericPIDs,        secondaryPIDs: AccessCH.adobeSecondaryPIDs,        desc: NSString.nullString, execHandle: data.execHandle,        z: data.z];      AS.FreeSystemDescriptionInternal[description, data.z];      data.z.FREE[@description];      END;      Courier.Free[        parameters: [@args, DescribePutSystemDescriptionArguments],        zone: data.z];      AS.CloseFile[acDH];      AS.CloseFile[sdFH];      AS.CloseFile[sDH];      IF ~ok THEN AdobeError[systemNotRegistered];      [] ¬ results[]};    CatchErrors[putNewSystem];>>    END;  GetSystemDescription: AdobeCourier.ServiceProc =    BEGIN    systemName: LONG STRING ¬ NIL;    sd: LONG POINTER;    lengthInwords: CARDINAL;    fH: NSFile.Handle;    origin: NSSegment.Origin;    DescribeGetSystemDescriptionResults: Courier.Description = {      [] ¬ notes.noteSize[0]; notes.noteSpace[sd, lengthInwords]};    proc: PROC = {      arguments[[@systemName, AdobeCourier.DescribeSystemName]];      IF ~data.systems[AS.SystemIndex[systemName]].stable THEN        AdobeError[sysDescChanging];      fH ¬ AS.GetDescriptionFile[systemName];      origin ¬ [file: fH, base: 0, count: AdobeCourier.maxSDPageSize];      lengthInwords ¬ CARDINAL[        (NSSegment.GetSizeInBytes[file: fH, session: data.fileSession]           + 1) / 2];      [[pointer: sd]] ¬ NSSegment.Map[        origin: origin, session: data.fileSession];      [] ¬ results[[sd, DescribeGetSystemDescriptionResults]];      sd ¬ Space.Unmap[sd];      Courier.Free[        [@systemName, AdobeCourier.DescribeSystemName], data.z]};    CatchErrors[proc];    END;  PutSystemDefaultUserFile: AdobeCourier.ServiceProc =    BEGIN  << not to be allowed remotely    systemName: LONG STRING;    proc: PROC = {      arguments[[@systemName, AdobeCourier.DescribeSystemName]];      AS.PutSytemDefaultUserFileInternal[systemName, cH.sH];      [] ¬ results[];      };    CatchErrors[proc];>>    END;  GetSystemDefaultUserFile: AdobeCourier.ServiceProc =    BEGIN    systemName: LONG STRING;    proc: PROC = {      arguments[[@systemName, AdobeCourier.DescribeSystemName]];      AS.GetSytemDefaultUserFileInternal[systemName, cH.sH];      [] ¬ results[];      };    CatchErrors[proc];    Courier.Free[[@systemName, AdobeCourier.DescribeSystemName], data.z];    END;  GetResidentSystemStrings: AdobeCourier.ServiceProc =    BEGIN    << not used    proc: PROC = {      AS.GetResidentSystemStringsInternal[arguments, results]; };    CatchErrors[proc]>>    END;  VerifyVersion: AdobeCourier.ServiceProc =    BEGIN    args: AdobeCourier.VerifyVersionArguments;    ok: BOOLEAN;    proc: PROC = {      arguments[[@args, AdobeCourier.DescribeVerifyVersionArguments]];      ok ¬ AS.VerifyVersionInternal[args.systemName, args.version];      [] ¬ results[[@ok, AdobeCourier.DescribeBoolean]];      };    CatchErrors[proc];    Courier.Free[      [@args, AdobeCourier.DescribeVerifyVersionArguments], data.z]    END;  GetVersion: AdobeCourier.ServiceProc =    BEGIN    << not needed remotely    system: LONG STRING;    version: AdobeOps.ARVersion;    proc: PROC = {      arguments[[@system, AdobeCourier.DescribeSystemName]];      version ¬ AS.GetVersionInternal[system];      [] ¬ results[[@version, AdobeCourier.DescribeARVersion]];      };    CatchErrors[proc];    Courier.Free[[@system, AdobeCourier.DescribeSystemName], data.z]>>    END;  CatchErrors: PUBLIC PROCEDURE [proc: PROC] = {    reason: AdobeServer.ErrorType;    BEGIN    ENABLE {      Courier.Error => {        reason ¬ AdobeCourier.CourierToAdobeError[errorCode];        GOTO raiseError};      AdobeServer.Error => {reason ¬ why; GOTO raiseError};      --fix when add notRegistered as an AdobeServer.ErrorType      AccessCH.Problem => {reason ¬ others; GOTO raiseError};      };    proc[];    EXITS raiseError => AdobeError[reason]    END};  AdobeError: PUBLIC PROC [why: AdobeServer.ErrorType] =    BEGIN    --This routine never returns.    --It always raises Courier.SignalRemoteError.    ERROR Courier.SignalRemoteError[LOOPHOLE[why], Courier.nullParameters];    END;  --  Server Initialization  Dispatcher: Courier.Dispatcher =    BEGIN    ENABLE ABORTED, UNWIND => {DecrementClientUsers[data]; CONTINUE};    proc: AdobeCourier.ProcedureType;    IF procedureNumber ~IN AdobeCourier.ProcedureIndex THEN      ERROR Courier.NoSuchProcedureNumber;    proc ¬ translateProc[procedureNumber];    IncrementClientUsers[data, cH.versionNumber];    procArray[proc][cH, proc, arguments, results];    DecrementClientUsers[data];    END;  --Dispatcher  ExportRemoteProgram: PROC =    BEGIN    ENABLE Courier.Error => CONTINUE;  --ignore if already exported    Courier.ExportRemoteProgram[      programNumber: AdobeCourier.programNumber,      versionRange: [      AdobeCourier.lowVersion, AdobeCourier.highVersion],      dispatcher: Dispatcher, serviceName: "Adobe Service 83"L,      zone: data.z, classOfService: transactional];    END;  UnexportRemoteProgram: PROCEDURE =    BEGIN    ENABLE Courier.Error => CONTINUE;  --ignore if not exported    Courier.UnexportRemoteProgram[      programNumber: AdobeCourier.programNumber,      versionRange: AdobeCourier.versionRange];    END;  StartUpService: PUBLIC PROCEDURE =    BEGIN AS.StartUpAdobeDirectory[]; ExportRemoteProgram[]; END;  TakeDownService: PUBLIC PROCEDURE =    BEGIN    UnexportRemoteProgram[];    AllowCurrentClientCallsToComplete[data];    FOR i: CARDINAL IN [0..data.systems.length) DO      AdobeUpdater.StopUpdaterService[i];      AdobeQOps.WakeUpdater[i];  --make them take note of aborts      ENDLOOP;    AS.TakeDownAdobeDirectory[];    Cleanup[];    END;  -- Utilities  IncrementClientUsers: ENTRY PROC [data: Data, protocolVersion: CARDINAL] = {    ENABLE UNWIND => NULL;    data.currentClients ¬ data.currentClients + 1;    IF data.currentClients > maxClients THEN       IF protocolVersion = 2 THEN -- if using new tool, give good msg        AdobeError[tooManyConnections]      ELSE -- old tool, do the best we can        AdobeError[others]};  DecrementClientUsers: ENTRY PROC [data: Data] = {    data.currentClients ¬ data.currentClients - 1};  AllowCurrentClientCallsToComplete: ENTRY PROC [data: Data] =    -- allow all others (besides me) to finish;    BEGIN    ENABLE UNWIND => NULL;    Process.SetTimeout[@aBit, Process.SecondsToTicks[secsToWait]];    WHILE data.currentClients > 0  OR DatabaseInFlux[] DO      WAIT aBit; ENDLOOP;    END;      DatabaseInFlux: PROCEDURE RETURNS [inFlux: BOOLEAN] = {    FOR i: CARDINAL IN [0..data.systems.length) DO      IF ~data.systems[i].stable THEN RETURN[TRUE];      ENDLOOP;    RETURN[FALSE]};  Cleanup: PROC = BEGIN END;  SystemExists: PROC [system: LONG STRING] RETURNS [exists: BOOLEAN] =    {    [] ¬ AS.GetSystemDirectory[      system !      AdobeServer.Error =>        IF why = unknownSystem THEN {exists ¬ FALSE; GOTO return}];    RETURN[TRUE];    EXITS return => NULL};  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  -- MAINLINE  END.    19-Sep-86 13:23:23 - RLC -	fix systemName leak in GetSystemDefaultUserFile11-Jun-87 12:43:50 - RLC -	wait until client count <= 0 before stopping service 23-Feb-88 11:14:42 - rlc - Raise AdobeError[tooManyConnections] when more than maxClients try to connect.25-Feb-88 15:05:33 - rlc - bump protocol verison. IF = 2 then raise AdobeError[tooManyConnections] else AdobeError[others] to be compatible with old tools
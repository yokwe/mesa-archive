-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- ARFileAccessImpl.mesa-- PAD    	 2-Jan-85 12:12:34-- RSF		 4-Mar-85 13:21:41-- JCS		25-Jul-85 15:37:15-- RLC		18-Apr-88 10:04:52DIRECTORY  Auth USING [CopyIdentity, FreeIdentity, IdentityHandle],  ARFileAccess,  Courier  USING [Error],  Environment  USING [bytesPerPage],  NSAssignedTypes USING [tText],  NSDataStream  USING [Abort, Aborted, SinkStream, SourceStream],  NSFile  USING [Attribute, Close, Controls, Error, ErrorRecord, Handle, ID,     Lock, Logoff, LogonDirect, nullHandle, nullID, nullString,     nullSession, Open, OpenByName, Probe, readAccess, Reference, Retrieve,     ServiceRecord, Session, Store, String],  NSName  USING [ClearName, CopyNameFields],  NSString  USING [String, StringFromMesaString],  Process USING [Seconds],  Space  USING [ScratchMap, Unmap],  Stream  USING [Block, CompletionCode, defaultInputOptions, Delete,         EndOfStream, Handle, SubSequenceType],  String USING [AppendChar, AppendString, AppendLongNumber];ARFileAccessImpl: MONITOR LOCKS session USING session: Session  IMPORTS Auth, Courier, NSDataStream, NSFile, NSName, NSString,  Space, Stream, String  EXPORTS ARFileAccess =  BEGIN OPEN ARFileAccess;    Session: TYPE = LONG POINTER TO SessionObject;  SessionObject: PUBLIC TYPE = MONITORED RECORD [    sessionPassword: CARDINAL ¬ SessionPassword,    z: UNCOUNTED ZONE ¬ NIL,    nsFileSession: NSFile.Session ¬ NSFile.nullSession,    referenceToARs: NSFile.Reference ¬ [fileID: NSFile.nullID, service: NIL],    dirH: NSFile.Handle ¬ NSFile.nullHandle,    userId: Auth.IdentityHandle ¬ NIL,    buffer: LONG POINTER ¬ NIL,    sessionError: BOOLEAN ¬ FALSE];   ARHandle: TYPE = LONG POINTER TO ARObject;  ARObject: PUBLIC TYPE = RECORD [    password: CARDINAL ¬ ARPassword,    parentID: NSFile.ID ¬ NSFile.nullID,    fH: NSFile.Handle ¬ NSFile.nullHandle,    name: NSFile.String ¬ NSFile.nullString,    number: LONG CARDINAL ¬ LAST[LONG CARDINAL]];      CommandType: TYPE = {retrieve, store, null};    SessionPassword: CARDINAL = 567B;  ARPassword: CARDINAL = 234B;  maxFileName: CARDINAL = 100;  maxDigits: CARDINAL = 5;  -- constant length of an AR filename  secondsToWaitForCheckedOutAR: Process.Seconds = 0;     Error: PUBLIC ERROR [session: Session, why: ErrorCode] = CODE;  Create: PUBLIC PROCEDURE [    zone: UNCOUNTED ZONE, arLocation: NSFile.Reference]    RETURNS [session: Session] =    BEGIN    session ¬ zone.NEW[SessionObject ¬ [      z: zone,       referenceToARs: [        fileID: arLocation.fileID,	service: zone.NEW[	  NSFile.ServiceRecord ¬ [          systemElement: arLocation.service.systemElement]]]    ]];    NSName.CopyNameFields[      z: zone, source: @arLocation.service.name,      destination: @session.referenceToARs.service.name];    END;  Destroy: PUBLIC PROCEDURE [session: Session] =    BEGIN    z: UNCOUNTED ZONE;     ValidateSession[session];    IF session.nsFileSession # NSFile.nullSession THEN      CloseFileSession[session];    z ¬ session.z;--wait to extract z til here in case session=NIL    IF session.userId # NIL THEN      Auth.FreeIdentity[identityPtr: @session.userId];    NSName.ClearName[z, @session.referenceToARs.service.name];    z.FREE[@session.referenceToARs.service];    z.FREE[@session]    END;      Logon: PUBLIC PROCEDURE [session: Session, user: Auth.IdentityHandle] =    BEGIN    ValidateSession[session];    IF session.userId # NIL THEN      Auth.FreeIdentity[identityPtr: @session.userId];    session.userId ¬ Auth.CopyIdentity[identity: user, z: session.z];    END;  OpenFileHandleOnAR: PROCEDURE [session: Session, arNumber: LONG CARDINAL]     RETURNS [fH: NSFile.Handle] = {    arFileName: LONG STRING ¬ [maxFileName];    dH: NSFile.Handle  ¬ OpenSubDirectory[session, arNumber];    fH ¬ NSFile.OpenByName[      directory: dH, path: ARNumberToFileName[arNumber, arFileName],      session: session.nsFileSession,      controls:        [ lock: share, access: NSFile.readAccess,	  timeout: secondsToWaitForCheckedOutAR]];    -- ** with current impl of OpenSubDirectory, for now don't close;    -- CloseFile[@dH, session] -- };      RetrieveAR: PUBLIC PROCEDURE [    session: Session, arNumber: LONG CARDINAL, to: Stream.Handle] =    BEGIN    retrieveAR: PROC = {      arH: ARHandle ¬ NIL;      BEGIN ENABLE {      UNWIND => IF arH # NIL THEN session.z.FREE[@arH]};	arH ¬ session.z.NEW[ARObject ¬ [	  fH: OpenFileHandleOnAR[session, arNumber], number: arNumber]];	IF arH = NIL OR arH.password # ARPassword THEN	     ERROR Error[session, invalidARHandle];	NSFile.Retrieve[arH.fH, [proc [Sink]], session.nsFileSession];	CloseFile[@arH.fH, session];	session.z.FREE[@arH];	END;    };    Sink: PROC [source: NSDataStream.SourceStream] =      BEGIN	BEGIN	ENABLE {	  NSDataStream.Aborted => CONTINUE;	  UNWIND => Stream.Delete[source]}; 	  [] ¬ CopyAR[session: session, from: source, to: to !	    UNWIND => NSDataStream.Abort[source !	      NSDataStream.Aborted => CONTINUE]];	END;      Stream.Delete[source ! NSDataStream.Aborted => CONTINUE]      END;    CatchErrors[session, retrieveAR, retrieve];    END;      StoreAR: PUBLIC PROCEDURE[    session: Session, arNumber: LONG CARDINAL, from: Stream.Handle]=    BEGIN    Source: PROC [sink: NSDataStream.SinkStream] =      BEGIN         BEGIN 	ENABLE {	  NSDataStream.Aborted => CONTINUE;          UNWIND => Stream.Delete[sink]};	  [] ¬ CopyAR[session: session, from: from, to: sink !	    UNWIND => NSDataStream.Abort[sink !	      NSDataStream.Aborted => CONTINUE]]        END;      Stream.Delete[sink ! NSDataStream.Aborted => CONTINUE]      END;    storeAR: PROC = {      fileName: LONG STRING ¬ [maxFileName];      fH, dH: NSFile.Handle ¬ NSFile.nullHandle;      a: ARRAY [0..2) OF NSFile.Attribute ¬ [         [name[ARNumberToFileName[arNumber, fileName]]],        [type[NSAssignedTypes.tText]] ];      dH ¬ OpenSubDirectory[session, arNumber];      fH ¬ NSFile.Store[ -- stores new version        directory: dH, source: [proc [Source]],        attributes: DESCRIPTOR[a], session: session.nsFileSession];    -- ** with current impl of OpenSubDirectory, for now don't close;    -- CloseFile[@dH, session];      CloseFile[@fH, session]    };    CatchErrors[session, storeAR, store];    END;      CatchErrors: PROCEDURE [session: Session, proc: PROC, type: CommandType] =    BEGIN ENABLE {-- Let the session stay open; If it times out, fine. Force client to close it explicitly;      NSFile.Error => NSError[session, error];      Courier.Error => ERROR Error[session, communicationError]};    ValidateSession[session];    IF SessionError[session] THEN ERROR Error[session, communicationError];    IF NOT FileSessionIsOpen[session] THEN OpenFileSession[session];    proc[];    END;      NSError: PROC [session: Session, error: NSFile.ErrorRecord] =    BEGIN    WITH error SELECT FROM      access =>        SELECT problem FROM        accessRightsInsufficient, accessRightsIndeterminate =>	  ERROR Error[session, accessDenied];        fileNotFound => ERROR Error[session, arNotFound];	ENDCASE => ERROR Error[session, communicationError];      authentication => ERROR Error[session, invalidLogin];      space =>        IF problem = allocationExceeded THEN ERROR Error[session, directoryFull]       ELSE IF problem = mediumFull THEN ERROR Error[session, fileServerFull]      ENDCASE => ERROR Error[session, communicationError];    END;   OpenFileSession: PROCEDURE [session: Session] = {    attr: ARRAY [0..1) OF NSFile.Attribute ¬ [ [fileID[session.referenceToARs.fileID]] ];    session.nsFileSession ¬ NSFile.LogonDirect[      identity: session.userId, service: session.referenceToARs.service];    session.dirH ¬ NSFile.Open[      attributes: DESCRIPTOR[attr], session: session.nsFileSession]};  CloseFileSession: PROCEDURE [session: Session] = {    NSFile.Logoff[session.nsFileSession !      NSFile.Error, Courier.Error => CONTINUE]; -- closes session.dirH    session.nsFileSession ¬ NSFile.nullSession};              -- Utilities    ARNumberToFileName: PROCEDURE [number: LONG CARDINAL, name: LONG STRING]     RETURNS [NSString.String] = {    temp: LONG STRING ¬ [maxFileName];    String.AppendLongNumber[temp, number];    FOR i: CARDINAL IN [0..maxDigits - temp.length) DO      String.AppendChar[name, '0] ENDLOOP;    String.AppendString[name, temp];    String.AppendString[name, ".AR"L];    RETURN[NSString.StringFromMesaString[name]]};    ValidateSession: PROCEDURE [session: Session] = {    IF session = NIL OR session.sessionPassword # SessionPassword THEN      ERROR Error[session, invalidSession]};    bufferPages: CARDINAL = 4;  bufferBytes: CARDINAL = bufferPages*Environment.bytesPerPage;    CopyAR: PROC [session: Session, from, to: Stream.Handle]     RETURNS [bytes: LONG CARDINAL] = {    buffer: LONG POINTER = AssertBuffer[session];    bytes ¬ 0;    DO      bytesTransferred: CARDINAL;      why: Stream.CompletionCode;      savedSST: Stream.SubSequenceType;      block: Stream.Block ¬ [buffer, 0, bufferBytes];      [bytesTransferred, why, savedSST] ¬ from.get[        from, block, Stream.defaultInputOptions !        Stream.EndOfStream => {          why ¬ endOfStream; bytesTransferred ¬ nextIndex; CONTINUE}];      block.stopIndexPlusOne ¬ bytesTransferred;      bytes ¬ bytes + bytesTransferred;      to.put[to, block, FALSE];      IF why = endOfStream THEN EXIT;      ENDLOOP;    session.buffer ¬ Space.Unmap[session.buffer]};        AssertBuffer: PROC [session: Session] RETURNS [LONG POINTER] = {    IF session.buffer = NIL THEN      session.buffer ¬ Space.ScratchMap[count: bufferPages];    RETURN[session.buffer]};      CloseFile: PROC [fH: LONG POINTER TO NSFile.Handle, session: Session] = {    IF fH­ # NSFile.nullHandle THEN {      NSFile.Close[fH­, session.nsFileSession !        NSFile.Error, Courier.Error => CONTINUE];      fH­ ¬ NSFile.nullHandle}};    FileSessionIsOpen: PROCEDURE [session: Session] RETURNS [BOOLEAN] = {    IF session.nsFileSession # NSFile.nullSession THEN       [] ¬ NSFile.Probe[session.nsFileSession !       NSFile.Error =>	 BEGIN	 WITH error SELECT FROM	   session => 	     IF problem = sessionInvalid	     THEN session.nsFileSession ¬ NSFile.nullSession           ENDCASE;	 CONTINUE	 END;       Courier.Error => CONTINUE];    RETURN[session.nsFileSession # NSFile.nullSession]};          SessionError: ENTRY PROCEDURE [session: Session] RETURNS [BOOLEAN] = {    RETURN[session.sessionError]};      OpenSubDirectory: PROCEDURE [session: Session, arNumber: LONG CARDINAL]     RETURNS [dH: NSFile.Handle] = {    -- FindSubDirectory[xxx]; ** i.e. Map name to subdirectory **    RETURN[dH: session.dirH] -- ** for now ** --};    END.18-Apr-88 10:04:52 - rlc - AR 12991 : Fix error catching for NSDataStream in RetrieveAR and StoreAR.
-- Copyright (C) 1983, 1985, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- AdobeCommonImplE.mesa -- MXF       	29-Jul-83 14:17:45-- RSF       	17-Apr-86 20:23:54-- JCS   	10-Oct-85 16:47:23-- RLC  	25-Feb-88 18:18:25DIRECTORY  AccessCH USING [Problem],  AdobeCommon USING [    ChangeSystem, DataHandle, FreeHintStrings, GetDataSW, GetDescList,    InitialSetStatus, LockedSysDescPtr, PostMessage, ReportFields,    ReportFieldsSeq, SetStatus, StringArray],  AdobeCommonInternal USING [ClickToConfirm, InstanceDataHandle],  AdobeOps USING [    ARNumber, ARSystemHandle, DefaultInfoObject, FieldList,    nilARNumber, QLHandle, QueryList, SetOfARs, ToolType,    UserOrderSequence, UserSpecifiedOrder, z],  AdobeServer USING [Error, GetSystemDefaultUserFile],  AdobeToolContext,  ARAccess,  Ascii USING [NUL],  FormSW USING [ItemHandle, line0, MenuProcType, ProcType],  MFile USING [Acquire, Delete, Handle],  MStream USING [WriteOnly],  CmFile USING [    Close, Error, FindSection, FreeString, Handle, NextItem, Open],  NSName USING [maxFullNameLength],  Put USING [CR, Text],  Stream USING [Delete, Handle],  String USING [    AppendExtensionIfNeeded, CopyToNewString, Equal, Equivalent,    Length, MakeString, StringToDecimal],  System USING [nullNetworkAddress],  Token USING [    Alphabetic, AlphaNumeric, Brackets, Decimal, Filtered,    FilterProcType, FreeTokenString, FreeStringHandle, Line,    MaybeQuoted, NonWhiteSpace, Handle, StringToHandle, SyntaxError],  Window USING [Handle, Place];AdobeCommonImplE: PROGRAM  IMPORTS    AccessCH, AdobeCommon, AdobeCommonInternal, AdobeOps, AdobeServer,    AdobeToolContext, ARAccess, MFile, MStream, CmFile, Put, Stream,    String, Token  EXPORTS AdobeCommon =  BEGIN    --sequence used for Table Lookup  ValueSequencePtr: TYPE = LONG POINTER TO ValueSequence;  ValueSequence: TYPE = RECORD [    seq: SEQUENCE length: CARDINAL OF LONG STRING];  InvalidFieldName: SIGNAL = CODE;  SyntaxError: SIGNAL = CODE;  CatchErrors: PUBLIC PROCEDURE [    sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    windowData: AdobeCommon.DataHandle, proc: FormSW.ProcType] = {    errorMessage: LONG STRING;    BEGIN    ENABLE {      AccessCH.Problem => {        SELECT type FROM          noClearinghouse =>            errorMessage ¬ "Clearinghouse is unavailable."L;          authProblem => errorMessage ¬ "Authentication problem."L;          badDatabaseName => errorMessage ¬ "badDatabaseName."L;          accessProblem =>            errorMessage ¬              "access problem in reaching clearinghouse."L;          ENDCASE => errorMessage ¬ "AccessCH.Problem"L};      ARAccess.Error => {        SELECT why FROM          accessDenied => errorMessage ¬ "Access Denied! "L;          accessUndetermined =>            errorMessage ¬ "Can't determine if user has access"L;          arNotFound => errorMessage ¬ "AR not found! "L;          authError => errorMessage ¬ "Authentication Error"L;          communicationError =>            errorMessage ¬ "File service unavailable or down"L;          crashDuringCheckOut =>            errorMessage ¬              "Checkout session lost.  You must check the AR out again."L;          currentlyCheckedOut => {            iData: AdobeCommonInternal.InstanceDataHandle ¬              windowData.instanceData;            WITH iData SELECT FROM              submit =>                errorMessage ¬                  "Another session has this directory locked."L;              ENDCASE =>                errorMessage ¬                  "Sorry, this AR is already checked out by another. "L};          directoryFull =>            errorMessage ¬ "Directory is full! Contact support."L;          fileServerFull =>            errorMessage ¬ "File Server is full! Contact support."L;          invalidARNumber => errorMessage ¬ "Invalid AR Number! "L;          invalidLogin => errorMessage ¬ "Invalid Login."L;          ENDCASE => REJECT;        GOTO ErrorExit};      AdobeToolContext.StreamError => {        errorMessage ¬          "AR File contains bad data - contact support!"L;        GOTO ErrorExit};      AdobeToolContext.EnumError => {        errorMessage ¬          "AR File contains an invalid enumerated value - contact support!"L;        GOTO ErrorExit};      AdobeServer.Error => {        SELECT why FROM	  communicationError =>	    errorMessage ¬ "Problems communicating with Adobe service."L;	  unknownSystem =>	    errorMessage ¬ "Unknown Adobe system."L;          cantDetermineLocOfARs =>            errorMessage ¬ "Can't determine location of AR files."L;          illegalLogin => errorMessage ¬ "Invalid login."L;	  systemAlreadyExists => errorMessage ¬ "systemAlreadyExists."L; -- should never happen	  fileNotFound => errorMessage ¬ "File not found."L;          serverUnreachable =>            errorMessage ¬ "Unable to reach Adobe server."L;          serverDown => errorMessage ¬ "Adobe server is down."L;          noAdobeServiceAtServer =>            errorMessage ¬ "Adobe service not running on server."L;          courierTimedOut => errorMessage ¬ "Courier timed out."L;          parameterInconsistency =>            errorMessage ¬              "Parameter Inconsistency - this tool and the Adobe service aren't compatible!"L;          obsoleteVersion => GOTO GetNewSystemDescription;	  systemNotRegistered => errorMessage ¬ "systemNotRegistered."L; -- should never happen          sysDescChanging =>            errorMessage ¬ "The Adobe database is changing. Try again later."L;	  others => errorMessage ¬ "Unknown Adobe service problem."L;	  tooManyConnections => errorMessage ¬ "Too many connections to Adobe service. Try again later."L;          ENDCASE => errorMessage ¬ "Unexpected Adobe service problem."L;        GOTO ErrorExit};      ABORTED => {errorMessage ¬ "Aborted!"L; GOTO ErrorExit}};    proc[sw, item, index];    EXITS      GetNewSystemDescription => {        sentinal: AdobeCommon.LockedSysDescPtr ¬          AdobeCommon.GetDescList[];        AdobeCommon.PostMessage[          windowData.msgSW, TRUE,          "This system description has become obsolete! "L];        AdobeCommon.PostMessage[          windowData.msgSW, TRUE,          "Retrieve new system description?  Click to confirm."L];        IF AdobeCommonInternal.ClickToConfirm[windowData, TRUE] THEN {          windowData.isBusy ¬ TRUE;          AdobeCommon.PostMessage[            windowData.msgSW, FALSE,            "Retrieving new system description..."L];          AdobeCommon.ChangeSystem[            windowData, windowData.system, TRUE]}};      ErrorExit => {        AdobeCommon.PostMessage[windowData.msgSW, TRUE, errorMessage];        windowData.isBusy ¬ FALSE};    END};  SetFSWOrderAndDefaultFromUserFile: PUBLIC PROCEDURE [    systemName: LONG STRING, arSH: AdobeOps.ARSystemHandle] =    BEGIN    fL: AdobeOps.FieldList ¬ arSH.fieldList;    localName: LONG STRING ¬ GetLocalName[systemName];    userFile: LONG STRING ¬ String.CopyToNewString[      localName, AdobeOps.z];    cmH: CmFile.Handle ¬ NIL;    noUserFile: BOOLEAN ¬ FALSE;    FreeLocalName[localName];    ConvertToUserFileName[@userFile];    [] ¬ String.AppendExtensionIfNeeded[      @userFile, ".user"L, AdobeOps.z];    --open local user file    cmH ¬ CmFile.Open[      userFile !      CmFile.Error =>        IF code = fileNotFound THEN {          [cmH, noUserFile] ¬ GetUserFileFromService[            systemName, userFile];          IF noUserFile THEN CONTINUE ELSE RETRY}];    FOR tool: AdobeOps.ToolType IN AdobeOps.ToolType DO      --free old value      AdobeOps.z.FREE[@arSH.formSWOrderArray[tool]];      IF noUserFile THEN        arSH.formSWOrderArray[tool] ¬ AllDisplayed[fL.len]      ELSE        arSH.formSWOrderArray[tool] ¬ SearchUserFileForDisplayed[          cmH, fL, tool];      ENDLOOP;    --use IF only until can go to service for noUserFile    IF ~noUserFile THEN cmH ¬ CmFile.Close[cmH];    AdobeOps.z.FREE[@userFile];    END;  AllDisplayed: PROCEDURE [length: CARDINAL]    RETURNS [formSWOrder: AdobeOps.UserSpecifiedOrder] =    BEGIN    ENABLE UNWIND => AdobeOps.z.FREE[@formSWOrder];    formSWOrder ¬ AdobeOps.z.NEW[AdobeOps .UserOrderSequence[length]];    FOR i: CARDINAL IN [0..length) DO      formSWOrder[i] ¬ i;      --do not need to set place, width positions in DefaultInfo      --because the default values are fine.      ENDLOOP;    END;  SearchUserFileForDisplayed: PROCEDURE [    cmH: CmFile.Handle, fL: AdobeOps.FieldList,    tool: AdobeOps.ToolType]    RETURNS [formSWOrder: AdobeOps.UserSpecifiedOrder] =    BEGIN    toolNames: ARRAY AdobeOps.ToolType OF LONG STRING ¬ [      "Edit"L, "Submit"L, "Report"L, "Query"L, "Sort"L, "QueryList"L];    isADefault: BOOLEAN ¬ FALSE;    values: ValueSequencePtr ¬ NIL;    name, value, default: LONG STRING ¬ NIL;    TempOrderType: TYPE = RECORD [      index: CARDINAL ¬ 0, order: AdobeOps.UserSpecifiedOrder ¬ NIL];    tempOrder: TempOrderType ¬ [];    incr: CARDINAL = 1;    TruncateSequence: PROCEDURE [order: TempOrderType]      RETURNS [formSWOrder: AdobeOps.UserSpecifiedOrder] =      BEGIN      IF tool # report THEN {        formSWOrder ¬ AdobeOps.z.NEW[          AdobeOps .UserOrderSequence[order.index]];        FOR i: CARDINAL IN [0..formSWOrder.length) DO          formSWOrder[i] ¬ order.order[i]; ENDLOOP}      ELSE {        hasOrder: AdobeCommon.ReportFields ¬ AdobeOps.z.NEW[          AdobeCommon .ReportFieldsSeq[order.order.length]];        reportCount: CARDINAL ¬ 0;        FOR i: CARDINAL IN [0..hasOrder.length) DO          hasOrder[i] ¬ FALSE; ENDLOOP;        formSWOrder ¬ AdobeOps.z.NEW[          AdobeOps .UserOrderSequence[order.order.length]];        FOR i: CARDINAL IN [0..order.order.length) DO          IF order.order[i] # LAST[CARDINAL] THEN {            formSWOrder[reportCount] ¬ order.order[i];            hasOrder[order.order[i]] ¬ TRUE;            reportCount ¬ reportCount + 1};          ENDLOOP;        FOR i: CARDINAL IN [0..order.order.length) DO          IF ~hasOrder[i] THEN {            formSWOrder[reportCount] ¬ i;            reportCount ¬ reportCount + 1};          ENDLOOP;        AdobeOps.z.FREE[@hasOrder]};      AdobeOps.z.FREE[@order.order];      END;    IF CmFile.FindSection[h: cmH, title: toolNames[tool]] THEN      BEGIN      ENABLE        UNWIND => {          AdobeOps.z.FREE[@tempOrder.order];          name ¬ CmFile.FreeString[name];          value ¬ CmFile.FreeString[value];          IF values # NIL THEN {            AdobeOps.z.FREE[@values[0]];            AdobeOps.z.FREE[@values[1]];            AdobeOps.z.FREE[@values]}};      tempOrder ¬ [        index: 0,        order: AdobeOps.z.NEW[AdobeOps .UserOrderSequence[fL.len]]];      IF tool = report THEN        FOR i: CARDINAL IN [0..tempOrder.order.length) DO          tempOrder.order[i] ¬ LAST[CARDINAL]; ENDLOOP;      [name, value] ¬ CmFile.NextItem[h: cmH];      WHILE name # NIL DO        fLIndex: CARDINAL ¬ FindFieldInFL[          name, fL !          InvalidFieldName => {            Put.Text[NIL, "Invalid field name: \""L];            Put.Text[NIL, name];            Put.Text[NIL, "\" found in .user file."L];            Put.CR[NIL];            name ¬ CmFile.FreeString[name];            value ¬ CmFile.FreeString[value];            [name, value] ¬ CmFile.NextItem[h: cmH];            LOOP}];        --get default information        [fL[fLIndex].defaultInfo[tool].place, fL[fLIndex].defaultInfo[          tool].width, default] ¬ ParseValueToken[          value !          SyntaxError => {            Put.Text[NIL, "Syntax Error in .user entry for "L];            Put.Text[NIL, name];            Put.Text[NIL, ". Defaulted to all displayed."L];            GOTO syntaxError}];        <<IF fL[fLIndex].defaultInfo[tool].width # 0 THEN          fL[fLIndex].defaultInfo[tool].width ¬ MAX[            fL[fLIndex].defaultInfo[tool].width, name.length]; fix AR9504>>        IF default # NIL THEN          IF  --there is no systemMust value --            (fL[fLIndex].defaultInfo[tool].default.length = 0) THEN            fL[fLIndex].defaultInfo[tool].default ¬ default          ELSE AdobeOps.z.FREE[@default];        IF tool # report THEN {          tempOrder.order[tempOrder.index] ¬ fLIndex;          tempOrder.index ¬ tempOrder.index + incr}        ELSE {          IF fL[fLIndex].defaultInfo[tool].place.x # 0            AND CARDINAL[fL[fLIndex].defaultInfo[tool].place.x] <=              fL.len THEN {            tempOrder.order[fL[fLIndex].defaultInfo[tool].place.x - 1]              ¬ fLIndex;            tempOrder.index ¬ tempOrder.index + incr}};        name ¬ CmFile.FreeString[name];        value ¬ CmFile.FreeString[value];        [name, value] ¬ CmFile.NextItem[h: cmH];        ENDLOOP;      name ¬ CmFile.FreeString[name];      value ¬ CmFile.FreeString[value];      RETURN[TruncateSequence[tempOrder]]      END    ELSE RETURN[AllDisplayed[fL.len]];    EXITS syntaxError => RETURN[AllDisplayed[fL.len]];    END;  << Not Apparently used  GetDefault: PROCEDURE [cmH: CmFile.Handle] RETURNS [default: LONG STRING] =    BEGIN    tempString: LONG STRING ¬ Token.Filtered[cmH, NIL, Token.Alphabetic];    default ¬ String.CopyToNewString[tempString, AdobeOps.z];    tempString ¬ Token.FreeTokenString[tempString];    END; >>  FindFieldInFL: PROCEDURE [name: LONG STRING, fL: AdobeOps.FieldList]    RETURNS [index: CARDINAL] =    BEGIN    FOR i: CARDINAL IN [0..fL.len) DO      IF String.Equal[s1: name, s2: fL[i].name] THEN RETURN[i];      ENDLOOP;    ERROR InvalidFieldName;    END;  ParseValueToken: PROCEDURE [token: LONG STRING]    RETURNS [      place: Window.Place, width: CARDINAL,      default: LONG STRING ¬ NIL] =    BEGIN    index: CARDINAL ¬ 0;    labels: ARRAY [0..2) OF LONG STRING ¬ ["x"L, "y"L];    sH: Token.Handle ¬ NIL;    temp, string: LONG STRING ¬ NIL;    thereIsADefault: BOOLEAN ¬ FALSE;    MustBeBracketed: Token.FilterProcType = {RETURN[FALSE]};    --parse the attribute's value    IF (String.Length[token] > 0) AND (token[0] = '[) THEN      BEGIN      ENABLE        UNWIND => {          [] ¬ Token.FreeTokenString[string];          [] ¬ Token.FreeStringHandle[sH];          };      sH ¬ Token.StringToHandle[token];      --strip off brakets      string ¬ Token.MaybeQuoted[        sH, NIL, MustBeBracketed, Token.Brackets];      [place, width] ¬ GetXYFromString[        string ! Token.SyntaxError => ERROR SyntaxError];      string ¬ Token.FreeTokenString[string];      IF sH.break # Ascii.NUL THEN        BEGIN        temp ¬ Token.MaybeQuoted[sH, NIL, Token.Line];        default ¬ String.CopyToNewString[temp, AdobeOps.z];        temp ¬ Token.FreeTokenString[temp];        END;      sH ¬ Token.FreeStringHandle[sH];      END    ELSE ERROR SyntaxError;    END;  GetXYFromString: PROCEDURE [string: LONG STRING]    RETURNS [place: Window.Place, width: CARDINAL ¬ 0] =    BEGIN    temp: LONG STRING ¬ NIL;    sh: Token.Handle ¬ Token.StringToHandle[string];    gotOne: BOOLEAN ¬ FALSE;    Numeric: Token.FilterProcType =      BEGIN      RETURN[SELECT c FROM IN ['0..'9] => TRUE, ENDCASE => FALSE];      END;    DO      ENABLE        UNWIND => {          [] ¬ Token.FreeTokenString[temp];          [] ¬ Token.FreeStringHandle[sh]};      temp ¬ Token.Filtered[sh, NIL, Token.Alphabetic];      -- ': was consumed and now is in sh.break      IF sh.break = Ascii.NUL THEN EXIT;      SELECT TRUE FROM        String.Equal[temp, "x"L] => place.x ¬ Token.Decimal[h: sh];        String.Equal[temp, "y"L] =>          BEGIN          temp ¬ Token.FreeTokenString[temp];          temp ¬ Token.MaybeQuoted[            h: sh, data: NIL, filter: Token.AlphaNumeric];          IF String.Length[temp] > 4 THEN            BEGIN            tempHandle: Token.Handle ¬ Token.StringToHandle[temp];            lineNumStr: LONG STRING ¬ Token.Filtered[              h: tempHandle, data: NIL, filter: Numeric,              skip: nonToken];            place.y ¬              FormSW.line0 - String.StringToDecimal[lineNumStr];            lineNumStr ¬ Token.FreeTokenString[lineNumStr];            [] ¬ Token.FreeStringHandle[tempHandle];            END          ELSE place.y ¬ String.StringToDecimal[temp];          END;        String.Equal[temp, "w"L] => width ¬ Token.Decimal[h: sh];        ENDCASE => ERROR SyntaxError;      temp ¬ Token.FreeTokenString[temp];      ENDLOOP;    [] ¬ Token.FreeStringHandle[sh];    RETURN[place, width];    END;  GetUserFileFromService: PROCEDURE [    systemName, userFileName: LONG STRING]    RETURNS [cmH: CmFile.Handle, noUserFile: BOOLEAN ¬ FALSE] =    BEGIN    userSH: Stream.Handle ¬ MStream.WriteOnly[      name: userFileName, release: [], type: text];    {    ENABLE AdobeServer.Error => GOTO noUserFileExit;    noUserFile ¬      (AdobeServer.GetSystemDefaultUserFile[        server: System.nullNetworkAddress, systemName: systemName,        to: userSH] = 0);    Stream.Delete[userSH];    IF noUserFile THEN      MFile.Delete[MFile.Acquire[userFileName, delete, []]];    EXITS      noUserFileExit => {        IF userSH # NIL THEN Stream.Delete[userSH];        MFile.Delete[MFile.Acquire[userFileName, delete, []]];        RETURN[NIL, TRUE]}};    END;  ConvertToUserFileName: PROCEDURE [    userFileName: LONG POINTER TO LONG STRING] = {    i, offset: CARDINAL ¬ 0;    WHILE i < userFileName.length DO      IF userFileName[i] = '  THEN offset ¬ offset + 1      ELSE userFileName[i - offset] ¬ userFileName[i];      i ¬ i + 1;      ENDLOOP;    userFileName.length ¬ userFileName.length - offset};  QLNameHints: PUBLIC FormSW.MenuProcType =    BEGIN    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    arSH: AdobeOps.ARSystemHandle;    hintsLength, hintsIndex: CARDINAL ¬ 0;    hintSeq: LONG POINTER TO AdobeCommon.StringArray;    list: AdobeOps.QLHandle;    CountOtherQLs: PROCEDURE RETURNS [count: CARDINAL ¬ 0] =      BEGIN      list: AdobeOps.QLHandle ¬ arSH.otherQLs;      WHILE list # NIL DO        count ¬ count + 1; list ¬ list.next; ENDLOOP;      END;    IF data.context = NIL THEN {hints ¬ NIL; RETURN};    arSH ¬ data.context.arSH;    freeHintsProc ¬ AdobeCommon.FreeHintStrings;    replace ¬ TRUE;    hintsLength ¬ CountOtherQLs[];    IF arSH.sysQL # NIL OR data.tool = query      OR        (data.tool = queryList AND index = 8          << AdobeCommon.resultPos>> ) THEN      hintsLength ¬ hintsLength + 1;    IF hintsLength = 0 THEN {      hintSeq ¬ AdobeOps.z.NEW[AdobeCommon .StringArray[1]];      hintSeq[0] ¬ String.CopyToNewString[""L, AdobeOps.z];      hints ¬ DESCRIPTOR[hintSeq];      RETURN};    hintSeq ¬ AdobeOps.z.NEW[AdobeCommon .StringArray[hintsLength]];    IF arSH.sysQL # NIL OR data.tool = query      OR        (data.tool = queryList AND index = 8          << AdobeCommon.resultPos>> ) THEN {      hintSeq[0] ¬ String.CopyToNewString["SysQL"L, AdobeOps.z];      hintsIndex ¬ hintsIndex + 1};    list ¬ arSH.otherQLs;    WHILE list # NIL DO      hintSeq[hintsIndex] ¬ String.CopyToNewString[        list.qL.name, AdobeOps.z];      hintsIndex ¬ hintsIndex + 1;      list ¬ list.next;      ENDLOOP;    hints ¬ DESCRIPTOR[hintSeq];    END;  GetNextAR: PUBLIC PROCEDURE [    set: AdobeOps.SetOfARs, current: AdobeCommon.SetStatus]    RETURNS [      nextAR: AdobeOps.ARNumber, newStatus: AdobeCommon.SetStatus] =    --returning AR=nilARNumber means set exhausted    BEGIN    newStatus ¬ current;    IF set = NIL OR set.len = 0 THEN      RETURN[AdobeOps.nilARNumber, newStatus];    IF newStatus = AdobeCommon.InitialSetStatus THEN      RETURN[set[0].startValue, [0, 0]];    IF set[current.setIndex].runLength <= current.runOffset + 1 THEN {      newStatus.runOffset ¬ 0;      newStatus.setIndex ¬ newStatus.setIndex + 1;      IF newStatus.setIndex >= set.len THEN        RETURN[AdobeOps.nilARNumber, newStatus]}    ELSE newStatus.runOffset ¬ newStatus.runOffset + 1;    nextAR ¬ set[newStatus.setIndex].startValue + newStatus.runOffset;    END;  GetPreviousAR: PUBLIC PROCEDURE [    set: AdobeOps.SetOfARs, current: AdobeCommon.SetStatus]    RETURNS [      nextAR: AdobeOps.ARNumber, newStatus: AdobeCommon.SetStatus] =    --returning AR=0 means set exhausted    BEGIN    newStatus ¬ current;    IF current = AdobeCommon.InitialSetStatus THEN      RETURN[        set[set.len - 1].startValue + set[set.len - 1].runLength - 1,          [          runOffset: CARDINAL[set[set.len - 1].runLength - 1],          setIndex: set.len - 1]];    IF current.runOffset < 1 THEN {      IF newStatus.setIndex = 0 THEN RETURN[0, newStatus];      newStatus.setIndex ¬ newStatus.setIndex - 1;      newStatus.runOffset ¬ CARDINAL[        set[newStatus.setIndex].runLength - 1]}    ELSE newStatus.runOffset ¬ newStatus.runOffset - 1;    nextAR ¬ set[newStatus.setIndex].startValue + newStatus.runOffset;    END;  FindThisQL: PUBLIC PROCEDURE [    qlName: LONG STRING, arSH: AdobeOps.ARSystemHandle]    RETURNS [qlHandle: AdobeOps.QueryList] =    BEGIN    qlH: AdobeOps.QLHandle;    IF String.Equivalent[qlName, "SysQL"L] OR qlName = NIL      OR qlName.length = 0 THEN RETURN[arSH.sysQL];    qlH ¬ arSH.otherQLs;    WHILE qlH # NIL DO      IF String.Equal[qlName, qlH.qL.name] THEN RETURN[qlH.qL];      qlH ¬ qlH.next;      ENDLOOP;    RETURN[NIL];    END;  GetLocalName: PROCEDURE [fullName: LONG STRING]    RETURNS [localName: LONG STRING] = {    i: CARDINAL ¬ 0;    localName ¬ String.MakeString[AdobeOps.z, fullName.length];    WHILE fullName[i] # ': AND i < fullName.length      AND i < NSName.maxFullNameLength DO      localName[i] ¬ fullName[i]; i ¬ i + 1; ENDLOOP;    localName.length ¬ i};  FreeLocalName: PROCEDURE [name: LONG STRING] = {    AdobeOps.z.FREE[@name]};  END..  -- RLC  	 8-Aug-86 18:03:09 MyCmFile ¬ CmFile-- RLC		23-Feb-88 17:20:30 add toomanyconnections -- RLC		25-Feb-88 18:18:25 tooManyConnections now a REAL error
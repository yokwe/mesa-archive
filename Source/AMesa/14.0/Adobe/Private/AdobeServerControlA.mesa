-- File: AdobeServerControlA.mesa - created by JCS. Last edit:-- BJD		11-May-84 17:29:11-- RSF		10-Oct-85 20:48:58-- JCS          19-May-86 16:17:32-- RLC          25-Feb-88 17:00:54 -- Copyright (C) 1984, 1985 , 1986 by Xerox Corporation. All rights reserved. DIRECTORY  AccessCH USING [    adobeGenericPIDs, adobeSecondaryPIDs, adobeServicePID,    EnumerateGroup, EnumerateProc, Problem, RegisterService],  AdobeCourier USING [DescribeSystemDescription],  AdobeOps USING [    ARNumber, ARSystemHandle, FieldList, SetOfARs, SetOfARsObject],  AdobeServer USING [Error, StartOrStop, Time],  AdobeServerOps USING [    acceleratorsDir, Bug, ChangeFieldList,    ChangeLocationOfARsInternal, CloseFile, CreateAcceleratorFile,    CreateSystemDirectory, DataObject, DestroyARSystem,    FreeSystemDescriptionInternal, FreeTime, GetDefUserFile,    GetDesiredSystem, GetStartOrStopTimeInternal, GetVersionInternal,    MakeAcceleratorFileForFieldInternal, OpenFile, PutDefaultUserFile,    PutLocationOfARsInternal, PutStartOrStopTimeInternal,    PutSubmitNumberInternal, PutVersionIDInternal,    ReadLastARNumberInternal, RegisterSystem, RestoreARSystem,    RetrieveSystemDescriptionInternal, StartUpService,    TakeDownService, TryBackup, UnRegisterSystem,    UpdateAcceleratorsInternal],  AdobeUpdater USING [GetUpdateList, InitUpdaterFile],  Ascii USING [CR, NUL],  Auth USING [IdentityHandle],  CHPIDs USING [adobeService],  Courier USING [LocalSystemElement, SerializeParameters],  Environment USING [],  Heap USING [Create, Delete],  MyCmFile USING [Close, Handle, NSOpen],  NetMgtServiceSupport USING [RegisterService],  --NSAssignedTypes USING [AssignedType],  NSExec USING [    AddClientCommands, AssignClientID, BroadcastAsyncMessage,    ClientProcs, ClientStatus, Command, CreateClient, ExecProc,    GetTTY, Handle, Predicate, PutErrorMessage, PutIndentedMessage,    PutMessage, StopMode, SystemFilingSession, UserEnabled,    UserIdentity, UserLoggedOn, UserAServerSA, WorkingDirectory],  NSFile USING [    Attribute, Attributes, AttributesRecord, AttributeType,    ChangeAttributes, ClearAttributeList, Close, Controls, Copy,    EncodeLongCardinal, EncodeString, Error, ExtendedAttributeType,    GetAttributes, GetReference, Handle, Lock, LogonDirect,    nullHandle, nullSession, Open, OpenByName, OpenByReference,    Reference, Selections, ServiceRecord, Session],  NSFileStream USING [Create, Handle],  NSFileName USING [Error, VPNFieldsFromString, VPNRecord],  NSName USING [    AppendNameToString, Error, FreeName, maxFullNameLength, Name,    NameFieldsFromString, NameFromString, NameRecord],  NSString USING [    AppendNumber, AppendString, AppendToMesaString, CompareStrings,    FreeString, InvalidNumber, InvalidString, MakeString, nullString,    String, StringBoundsFault, StringFromMesaString],  ParseSystemDescription USING [    BuildSystemHandle, FreeSystemDescription, ParsingError,    TellParsingError],  PilotSwitches USING [heapOwnerChecking],  Runtime USING [GetBcdTime],  --ServicesAssignedTypes USING [firstAdobeType],  ServicesError USING [SetCatching],  Stream USING [Delete, EndOfStream, GetChar, Handle],  String USING [    AppendChar, AppendLongNumber, AppendString, AppendStringAndGrow,    CopyToNewString, MakeString],  System USING [switches],  TextInput USING [    GetDecimal, GetLongDecimal, GetText, GetYesNo, nilYesNo, YesOrNo],  Token USING [GetCharProcType, Object],  TTY USING [CharStatus, GetEditedString, Handle, PutCR, PutString],  UserProfile USING [    EntryKey, File, GetCurrentProfileFile, RegisterEntriesProc,    RegisterSection, SetCurrentProfileFile],  XString USING [FromNSString];AdobeServerControlA: MONITOR  IMPORTS    AccessCH, AdobeCourier, AdobeServer, AdobeServerOps,    AdobeUpdater, Courier, Heap, MyCmFile, NetMgtServiceSupport,     NSExec, NSFile, NSFileName, NSFileStream, NSName, NSString,     ParseSystemDescription, Runtime, ServicesError, Stream, String,     System, TextInput, TTY, UserProfile, XString  EXPORTS AdobeServerOps =  BEGIN<<  -- this is used to have our own type to store the service into stable storage  adobeServiceDataType: NSAssignedTypes.AssignedType =    ServicesAssignedTypes.firstUnassigned2 + 2;>>  ChoiceSequence: TYPE = RECORD [    seq: SEQUENCE length: CARDINAL OF NSString.String];  data: PUBLIC AdobeServerOps.DataObject _ [    id: NSExec.AssignClientID[], me: Courier.LocalSystemElement[],    tracing: TRUE];  noSection: LONG CARDINAL = LAST[LONG CARDINAL];  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE = MACHINE DEPENDENT RECORD [    tokenData: Token.Object,    sh: Stream.Handle,    specificIndex: LONG CARDINAL _ noSection];  serviceNameString: LONG STRING = [NSName.maxFullNameLength];  name: NSString.String ¬ S[serviceNameString];  procs: NSExec.ClientProcs = [    init: InitAdobeService, start: StartAdobeService,    stop: StopAdobeService, unload: UnloadAdobeService,    expunge: ExpungeAdobeService, name: NameAdobeService,    status: StatusAdobeService];  -- the ClientProcs  InitAdobeService: PROC [exec: NSExec.Handle, normal: BOOLEAN] = {    commands: ARRAY [0..22) OF NSExec.Command _ [      [      S["Backup Systems"L], AdobeServerOps.TryBackup,      ServiceStartedAndUserEnabled], [      S["Change FieldList"L], AdobeServerOps.ChangeFieldList,      ServiceStartedAndUserEnabled], [      S["Change Location of ARs"L], ChangeLocOfARs,      ServiceStartedAndUserEnabled], [      S["Destroy AR System"L], AdobeServerOps.DestroyARSystem,      DestroyPred], [      S["Examine UpdateList"L], ExamineUpdateList, ServiceStarted], [      S["Find DataBase/Service"L], FindDBOrService, UserLoggedIn], [      S["Get Default User File"L], AdobeServerOps.GetDefUserFile,       ServiceStartedAndUserEnabled],      --[S["Init Profile"L], NoOp, ServiceStarted],      [S["List Systems"L], ListSystems, ServiceStarted], [      S["Make Accelerator File"L], MakeAcceleratorFile,      ServiceStartedAndUserEnabled], [      S["Put Default User File"L], AdobeServerOps.PutDefaultUserFile,      ServiceStoppedAndUserEnabled], [      S["Put Submit Number"L], PutSubmitNo,      ServiceStartedAndUserEnabled], [      S["Put System Description"L], PutSystemDesc,      ServiceStartedAndUserEnabled], [      S["Restore AR System"L], AdobeServerOps.RestoreARSystem,      RestorePred], [      S["Register System"L], AdobeServerOps.RegisterSystem,      ServiceStartedAndUserEnabled], [      --S["Set Backup Path"L], AdobeServerOps.SetBackupPath,      --ServiceStartedAndUserEnabled], [      S["Set Start Time"L], SetStartTime,      ServiceStartedAndUserEnabled], [      S["Set Stop Time"L], SetStopTime, ServiceStartedAndUserEnabled],      [S["Show Client Activity"L], ShowClientCount, ServiceStarted], [      S["Show Accelerator Activity"L], ShowAcceleratorCount,      ServiceStarted], [      S["Show System Parameters"L], ShowSystemParms, ServiceStarted],      [      S["UnRegister System"L], AdobeServerOps.UnRegisterSystem,      ServiceStartedAndUserEnabled], [      S["Update All ARs"L], UpdateAllARs,      ServiceStartedAndUserEnabled], [      S["Update Specified ARs"L], ExplicitUpdate,      ServiceStartedAndUserEnabled]];    NSExec.AddClientCommands[data.id, DESCRIPTOR[commands]];    StartAdobeService[exec ! ServicesError.SetCatching => RESUME ]};  StartAdobeService: NSExec.ExecProc = {    IF data.status = starting OR data.status = started THEN RETURN;    data.status _ starting;    ServicesError.SetCatching[on: FALSE];    NSExec.PutMessage[exec, S["Starting Adobe Service"L]];    data.execHandle ¬ exec;    IF data.z = NIL THEN  -- must be first time or last was a 'quitCold'      data.z _ Heap.Create[        ownerChecking: System.switches[PilotSwitches.heapOwnerChecking] = down,	checking: System.switches[PilotSwitches.heapOwnerChecking] = down,  -- ** DEBUGGING ** --        initial: 8, increment: 4, swapUnitSize: 4];    IF data.serviceId = NIL THEN      GetServerId[        exec ! AccessCH.Problem => GOTO registrationProblems];    IF data.serviceId = NIL THEN {      noId: NSString.String = S[        "Authentication problem: Adobe Service id."L];      NSExec.PutErrorMessage[exec, noId];      data.status _ stopped;      RETURN};    AdobeServerOps.StartUpService[];    data.status _ started;    EXITS      registrationProblems => {        noId: NSString.String = S[          "Registration problem: Adobe Service NOT started.\n"L];        NSExec.PutErrorMessage[exec, noId];        data.status ¬ stopped}};  StopAdobeService: PROC [    exec: NSExec.Handle, stopMode: NSExec.StopMode] = {    data.status _ stopping;    AdobeServerOps.TakeDownService[];    IF stopMode = quitCold THEN {  -- probably does not work      Heap.Delete[data.z];      --reset fields which pointed to objects out of data.z      data.z ¬ NIL;      data.serviceId ¬ NIL;      data.systems ¬ NIL;      };    data.status _ stopped};  UnloadAdobeService: NSExec.ExecProc = {ERROR};  ExpungeAdobeService: NSExec.ExecProc = {ERROR};  NameAdobeService: PROC [    nameProc: PROCEDURE [clientName: NSString.String]] = {    nameProc[name]};  StatusAdobeService: PROC [    statusProc: PROC [      status: NSExec.ClientStatus, comment: NSString.String]] = {    comment: ARRAY NSExec.ClientStatus OF LONG STRING = [      started: "up and running", starting: "on the way up",      stopped: "ready to be started", stopping: "shutting down"];    statusProc[data.status, S[comment[data.status]]]};  -- predicate procs  DestroyPred: NSExec.Predicate = {    RETURN[NSExec.UserAServerSA[exec] AND data.status = stopped]};  RestorePred: NSExec.Predicate = {    RETURN[NSExec.UserAServerSA[exec] AND data.status = started]};  ServiceStarted: NSExec.Predicate = {RETURN[data.status = started]};  ServiceStartedAndUserLoggedIn: NSExec.Predicate = {    RETURN[data.status = started AND NSExec.UserLoggedOn[exec]]};  ServiceStartedAndUserEnabled: NSExec.Predicate = {    RETURN[NSExec.UserEnabled[exec] AND data.status = started]};  ServiceStoppedAndUserEnabled: NSExec.Predicate = {    RETURN[NSExec.UserEnabled[exec] AND data.status = stopped]};  UserLoggedIn: NSExec.Predicate = {    RETURN[NSExec.UserLoggedOn[exec]]};  -- command procs  ChangeLocOfARs: NSExec.ExecProc = {    changeLocOfARs: PROCEDURE = {      systemIndex: CARDINAL;      tty: TTY.Handle ¬ NSExec.GetTTY[exec];      systemName: LONG STRING ¬ [50];      host: LONG STRING ¬ [50];      directory: LONG STRING ¬ [50];      t: PROCEDURE [c: CHARACTER] RETURNS [TTY.CharStatus] = {        IF c = Ascii.CR THEN RETURN[stop] ELSE RETURN[ok]};      systemIndex ¬ GetDesiredSystem[exec];      IF systemIndex IN [0..data.systems.length) THEN {        NSString.AppendToMesaString[          systemName, data.systems[systemIndex].name];        PutIndentedString[          tty, "Enter New Host (host:domain:organization):  "L];        [] ¬ TTY.GetEditedString[tty, host, t];        IF host.length = 0 THEN {          NSExec.PutMessage[exec, S["no host entered."L]]; RETURN};        TTY.PutCR[tty];        PutIndentedString[tty, "Enter New Directory:  "L];        [] ¬ TTY.GetEditedString[tty, directory, t];        IF directory.length = 0 THEN {          NSExec.PutMessage[exec, S["no directory entered."L]];          RETURN};        TTY.PutCR[tty];        AdobeServerOps.ChangeLocationOfARsInternal[          systemName: systemName, newHost: host,          newDirectory: directory]}      ELSE NSExec.PutMessage[exec, S["invalid number was entered"L]]};    CatchErrorsFromExec[changeLocOfARs, exec];    };  FindDBOrService: NSExec.ExecProc = {    findDBOrService: PROCEDURE = {      dbName: NSString.String ¬ NSString.MakeString[        data.z, NSName.maxFullNameLength];      name: NSName.Name ¬ NIL;      userId: Auth.IdentityHandle;      tty: TTY.Handle ¬ NSExec.GetTTY[exec];      BEGIN      ENABLE {        UNWIND => {          NSString.FreeString[data.z, dbName];          IF name # NIL THEN NSName.FreeName[data.z, name]};	NSName.Error => {	  NSExec.PutMessage[	    exec, S["Name not entered in proper format"L]];	  NSString.FreeString[data.z, dbName];	  IF name # NIL THEN NSName.FreeName[data.z, name];	  GOTO badNameFormat}};      lookupProc: AccessCH.EnumerateProc = {        --[currentName: CH.Element] RETURNS [BOOLEAN]        nameString: NSString.String ¬ NSString.MakeString[          data.z, NSName.maxFullNameLength];        nameString ¬ NSName.AppendNameToString[          name: currentName, s: nameString];        NSExec.PutMessage[exec, nameString];        NSString.FreeString[data.z, nameString]};      dbName ¬ TextInput.GetText[        tty: NSExec.GetTTY[exec],        prompt: S["Enter Fully-qualified DataBase or Service Name"L],        text: dbName, maxLength: dbName.maxlength];      IF dbName.length # 0 THEN {        userId ¬ GetIdentity[exec];        name ¬ NSName.NameFromString[data.z, dbName];        AccessCH.EnumerateGroup[          name: name, enumProc: lookupProc, identity: userId,          z: data.z !          AccessCH.Problem => {            SELECT type FROM              badDatabaseName =>                NSExec.PutMessage[                  exec, S["DataBase/Service does not exist"L]];              ENDCASE => NSExec.PutMessage[exec, S["Unknown error"L]];            CONTINUE}]}      ELSE NSExec.PutMessage[exec, S["No name was entered"L]];      NSName.FreeName[data.z, name];      NSString.FreeString[data.z, dbName];      EXITS        badNameFormat => NULL;      END};    CatchErrorsFromExec[findDBOrService, exec];    };  MakeAcceleratorFile: NSExec.ExecProc = {    systemIndex, fieldIndex: CARDINAL;    systemName: LONG STRING ¬ [50];    tty: TTY.Handle ¬ NSExec.GetTTY[exec];    arSH: AdobeOps.ARSystemHandle ¬ NIL;    fieldName: LONG STRING ¬ [20];    t: PROCEDURE [c: CHARACTER] RETURNS [TTY.CharStatus] = {      IF c = Ascii.CR THEN RETURN[stop] ELSE RETURN[ok]};    makeAcceleratorFile: PROCEDURE = {      BEGIN      ENABLE {        UNWIND =>          IF arSH # NIL THEN{            AdobeServerOps.FreeSystemDescriptionInternal[              arSH, data.z];	     data.z.FREE[@arSH]}};      systemIndex ¬ GetDesiredSystem[exec];      arSH ¬ AdobeServerOps.RetrieveSystemDescriptionInternal[	data.systems[systemIndex].dfH, data.z];      NSString.AppendToMesaString[	systemName, data.systems[systemIndex].name];      fieldIndex ¬ GetDesiredField[exec, arSH];      WITH arSH.fieldList[fieldIndex] SELECT FROM        string => NSExec.PutMessage[exec, S["No accelerator file for this field because it is an unbounded string"L]];	ENDCASE => AdobeServerOps.MakeAcceleratorFileForFieldInternal[	  systemName, fieldIndex, arSH.fieldList, exec];      [] ¬ AdobeServerOps.FreeSystemDescriptionInternal[	arSH, data.z];      data.z.FREE[@arSH]; -- minor storage leak      END};    CatchErrorsFromExec[makeAcceleratorFile, exec]};  PutSubmitNo: NSExec.ExecProc = {    systemIndex: CARDINAL;    lastAR: LONG CARDINAL;    systemName: LONG STRING ¬ [50];    confirm: TextInput.YesOrNo ¬ TextInput.nilYesNo;    BEGIN    ENABLE {      NSString.InvalidString => {        NSExec.PutMessage[exec, S["invalid string"L]]; GOTO nope};      NSString.StringBoundsFault => {        NSExec.PutMessage[exec, S["string too long"L]]; GOTO nope}};    systemIndex ¬ GetDesiredSystem[exec];    IF systemIndex IN [0..data.systems.length) THEN {      lastAR ¬ TextInput.GetLongDecimal[        tty: NSExec.GetTTY[exec],        prompt: S["Enter Next Submit Number"L], min: 1, default: 1];      confirm ¬ TextInput.GetYesNo[        tty: NSExec.GetTTY[exec], prompt: S["Confirm"L]];      IF confirm = yes THEN {        NSString.AppendToMesaString[          systemName, data.systems[systemIndex].name];        AdobeServerOps.PutSubmitNumberInternal[systemName, lastAR]}}    ELSE NSExec.PutMessage[exec, S["invalid number was entered"L]];    EXITS nope => NULL    END};  GetIdentity: PROCEDURE [exec: NSExec.Handle]    RETURNS [id: Auth.IdentityHandle] =    BEGIN    RETURN[NSExec.UserIdentity[exec]];  --maybe we want ServerIdentity    END;  ExamineUpdateList: NSExec.ExecProc = {    examineUpdateList: PROCEDURE = {      updateList: LONG STRING;      systemIndex: CARDINAL;      systemName: LONG STRING ¬ [50];      tty: TTY.Handle ¬ NSExec.GetTTY[exec];      BEGIN      ENABLE UNWIND => GOTO quit;      systemIndex ¬ GetDesiredSystem[exec];      IF systemIndex IN [0..data.systems.length) THEN {        NSString.AppendToMesaString[          systemName, data.systems[systemIndex].name];        updateList ¬ AdobeUpdater.GetUpdateList[          systemName !          AdobeServer.Error =>            IF why = unknownSystem THEN {              PutIndentedString[tty, "Unknown System"L]; GOTO quit}            ELSE REJECT];        IF updateList = NIL THEN          PutIndentedString[tty, "Update List is empty"L]        ELSE {          PutIndentedString[tty, "Update List contains: "];          TTY.PutString[tty, updateList];          data.z.FREE[@updateList]}}      ELSE NSExec.PutMessage[exec, S["invalid number entered."L]];      EXITS quit => NULL;      END};    CatchErrorsFromExec[examineUpdateList, exec]};  --ExamineUpdateList  PutSystemDesc: NSExec.ExecProc = {    putSystemDescription: PROCEDURE = {      arSH: AdobeOps.ARSystemHandle ¬ NIL;      session: NSFile.Session ¬ NSExec.SystemFilingSession[];      descFileName, sysname: NSString.String;      cmH: MyCmFile.Handle;      msgSWMsg, logSWMsg: LONG STRING ¬ NIL;      descFH, workingDir, fH: NSFile.Handle ¬ NSFile.nullHandle;      fileAttrs: ARRAY [0..1) OF NSFile.Attribute;      arIdFound: BOOLEAN;      tty: TTY.Handle ¬ NSExec.GetTTY[exec];      confirm: TextInput.YesOrNo ¬ TextInput.nilYesNo;      newsession: NSFile.Session;      location: NSFile.Reference;      service: NSFile.ServiceRecord;      BEGIN      ENABLE {        UNWIND => {          IF descFH # NSFile.nullHandle THEN            NSFile.Close[descFH, data.fileSession];          IF workingDir # NSFile.nullHandle THEN            NSFile.Close[workingDir, data.fileSession];          IF fH # NSFile.nullHandle THEN            NSFile.Close[fH, data.fileSession];          IF arSH # NIL THEN            arSH ¬ ParseSystemDescription.FreeSystemDescription[              arSH]};        ParseSystemDescription.ParsingError => {          [msgSWMsg, logSWMsg] ¬            ParseSystemDescription.TellParsingError[            type, sectionName, field, fieldIndex];          GOTO errorExit}};      workingDir ¬ NSFile.OpenByReference[        reference: NSFile.GetReference[        file: NSExec.WorkingDirectory[]], session: data.fileSession];      [descFileName, descFH] ¬ GetDescriptionFile[        exec, workingDir, data.fileSession];      IF descFH = NSFile.nullHandle THEN GOTO errorExit;      confirm ¬ TextInput.GetYesNo[        tty: NSExec.GetTTY[exec], prompt: S["Parse Only"L]];      cmH ¬ MyCmFile.NSOpen[        descFileName, workingDir, data.fileSession];      arIdFound ¬ FALSE;      BEGIN      ENABLE UNWIND => cmH ¬ MyCmFile.Close[cmH];      PutIndentedString[tty, "Parsing Description..."L];      arSH ¬ ParseSystemDescription.BuildSystemHandle[cmH];      cmH ¬ MyCmFile.Close[cmH];      END;      TTY.PutString[tty, "ok."L];      IF confirm = no THEN {        PutIndentedString[tty, "Storing Description ..."L];        --AdobeServer.PutSystemDescription        sysname ¬ S[arSH.name];        FOR j: CARDINAL IN [0..data.systems.length) DO          IF NSString.CompareStrings[data.systems[j].name, sysname] =            equal THEN {            NSExec.PutMessage[              exec, S["Adobe system already exists."L]];            logSWMsg ¬ NIL;	    GOTO errorExit};          ENDLOOP;        --set up LocationOfARs info first so that if it can't be        --obtained we can back out of the Put        NSName.NameFieldsFromString[          z: data.z, s: S[arSH.host], destination: @service.name];        fileAttrs ¬ [[pathname[S[arSH.directory]]]];        newsession ¬ NSFile.LogonDirect[GetIdentity[exec], @service];        fH ¬ NSFile.Open[          attributes: DESCRIPTOR[fileAttrs], session: newsession];        location ¬ [          fileID: NSFile.GetReference[          file: fH, session: newsession].fileID, service: @service];        --Store the database description.        StoreDescription[          exec, descFileName, workingDir, arSH, data.fileSession];        AdobeServerOps.PutLocationOfARsInternal[arSH.name, location];        AdobeServerOps.PutVersionIDInternal[arSH.name, arSH.version];        TTY.PutString[tty, "ok."L]};      arSH ¬ ParseSystemDescription.FreeSystemDescription[arSH];      IF fH # NSFile.nullHandle THEN NSFile.Close[fH, newsession];      IF descFH # NSFile.nullHandle THEN        NSFile.Close[descFH, data.fileSession];      IF workingDir # NSFile.nullHandle THEN        NSFile.Close[workingDir, data.fileSession];      NSExec.PutMessage[exec, S["Done."L]];      EXITS        errorExit => {          IF descFH # NSFile.nullHandle THEN            NSFile.Close[descFH, data.fileSession];          IF workingDir # NSFile.nullHandle THEN            NSFile.Close[workingDir, data.fileSession];          IF arSH # NIL THEN            arSH ¬ ParseSystemDescription.FreeSystemDescription[arSH];          IF logSWMsg # NIL THEN NSExec.PutMessage[exec, S[logSWMsg]]};      END};    CatchErrorsFromExec[putSystemDescription, exec];    };  --PutSystemDesc  StoreDescription: PROCEDURE [    exec: NSExec.Handle, descFileName: NSString.String,    directory: NSFile.Handle, description: AdobeOps.ARSystemHandle,    session: NSFile.Session] = {    ok: BOOLEAN ¬ FALSE;    descSH, sdSH: NSFileStream.Handle;    sDH, sdFH, acDH, descFH: NSFile.Handle;    fileSizeInBytes: LONG CARDINAL ¬ 0;    --see AdobeServerInternals for other ExtendedAttributeType's    submitNumberType: NSFile.ExtendedAttributeType =      ORD[LAST[NSFile.AttributeType]] + 2;    startTimeType: NSFile.ExtendedAttributeType =      submitNumberType + 2;    stopTimeType: NSFile.ExtendedAttributeType = startTimeType + 1;    a: ARRAY [0..3) OF NSFile.Attribute ¬ [  --initial attributes      [      extended[      type: submitNumberType, value: NSFile.EncodeLongCardinal[1]]], [      extended[      type: startTimeType,      value: NSFile.EncodeString[S["00:00:00"L]]]], [      extended[      type: stopTimeType,      value: NSFile.EncodeString[S["00:00:00"L]]]]];    descFH ¬ NSFile.OpenByName[      directory: directory, path: descFileName, session: session];    descSH ¬ NSFileStream.Create[file: descFH, session: session];    --check if system already exists    --create system directory    sDH ¬ AdobeServerOps.CreateSystemDirectory[      description.name !      NSFile.Error => {        WITH error SELECT FROM          insertion => {            SELECT problem FROM              fileNotUnique =>                NSExec.PutMessage[                  exec, S["this system already exists"L]];              ENDCASE};          ENDCASE}];    sdFH ¬ AdobeServerOps.OpenFile[      parent: sDH, path: S["Description.File"L]];    sdSH ¬ NSFileStream.Create[file: sdFH, session: session];    Courier.SerializeParameters[      parameters: [      location: description,      description: AdobeCourier.DescribeSystemDescription], sH: sdSH];    NSFile.ChangeAttributes[sdFH, DESCRIPTOR[a], data.fileSession];    NSFile.ClearAttributeList[DESCRIPTOR[a]];    Stream.Delete[sdSH];    --create accelerator files    acDH ¬ AdobeServerOps.OpenFile[      parent: sDH, path: S[AdobeServerOps.acceleratorsDir]];    FOR i: CARDINAL IN [0..description.fieldList.len) DO      IF description.fieldList[i].type # string THEN        AdobeServerOps.CloseFile[          AdobeServerOps.CreateAcceleratorFile[          parent: acDH, fieldName: description.fieldList[i].name]];      ENDLOOP;    --create updater's backing file and initialize contents    AdobeUpdater.InitUpdaterFile[parent: sDH];    };  GetDescriptionFile: PROCEDURE [    exec: NSExec.Handle, workingDir: NSFile.Handle,    session: NSFile.Session]    RETURNS [file: NSString.String, descFH: NSFile.Handle] = {    descFile: NSString.String ¬ NSString.MakeString[data.z, 100];    vpn: NSFileName.VPNRecord;    fH: NSFile.Handle;    localFile: BOOLEAN ¬ FALSE;    attrs: ARRAY [0..1) OF NSFile.Attribute;    fileAttrs: ARRAY [0..2) OF NSFile.Attribute;    attrRec: NSFile.AttributesRecord;    attrPtr: NSFile.Attributes;    controls: NSFile.Controls ¬ [lock: exclusive];    selections: NSFile.Selections;    descFile ¬ TextInput.GetText[      tty: NSExec.GetTTY[exec], prompt: S["Enter description file"L],      text: descFile, maxLength: descFile.maxlength];    NSFileName.VPNFieldsFromString[      z: data.z, s: descFile, destination: @vpn !      NSFileName.Error => {localFile ¬ TRUE; CONTINUE}];    IF vpn.service # NIL AND ~localFile THEN {      fileAttrs ¬ [[service[vpn.service]], [pathname[vpn.pathname]]];      fH ¬ NSFile.Open[        attributes: DESCRIPTOR[fileAttrs], session: session];      selections.interpreted[name] ¬ TRUE;      selections.interpreted[isDirectory] ¬ TRUE;      attrPtr ¬ @attrRec;      NSFile.GetAttributes[        file: fH, selections: selections, attributes: attrPtr,        session: session];      IF attrRec.isDirectory THEN {        NSExec.PutMessage[exec, S["Invalid description file specified."L]];        descFH ¬ NSFile.nullHandle; RETURN};      attrs ¬ [[name[attrRec.name]]];      descFH ¬ NSFile.Copy[        fH, workingDir, DESCRIPTOR[attrs], controls, session];      RETURN[attrRec.name, descFH]}    ELSE {      attrs ¬ [[name[descFile]]];      descFH ¬ NSFile.Open[        directory: workingDir, session: session,        attributes: DESCRIPTOR[attrs]];      RETURN[descFile, descFH]};    };  SetStartTime: NSExec.ExecProc = {    systemIndex: CARDINAL;    systemName: LONG STRING ¬ [50];    timeString: LONG STRING ¬ [10];    nsTime: NSString.String;    tty: TTY.Handle ¬ NSExec.GetTTY[exec];    t: PROCEDURE [c: CHARACTER] RETURNS [TTY.CharStatus] = {      IF c = Ascii.CR THEN RETURN[stop] ELSE RETURN[ok]};    setStartTime: PROCEDURE = {      systemIndex ¬ GetDesiredSystem[exec];      IF systemIndex IN [0..data.systems.length) THEN {        NSString.AppendToMesaString[          systemName, data.systems[systemIndex].name];        PutIndentedString[tty, "Enter Start Time:  "L];        [] ¬ TTY.GetEditedString[tty, timeString, t];        IF (nsTime ¬ ValidateTime[exec, start, timeString]) =          NSString.nullString THEN RETURN;        AdobeServerOps.PutStartOrStopTimeInternal[          system: systemName, which: start, startOrStopTime: nsTime]}      ELSE NSExec.PutMessage[exec, S["invalid number entered."L]]};    CatchErrorsFromExec[setStartTime, exec]};  SetStopTime: NSExec.ExecProc = {    systemIndex: CARDINAL;    systemName: LONG STRING ¬ [50];    timeString: LONG STRING ¬ [10];    nsTime: NSString.String;    tty: TTY.Handle ¬ NSExec.GetTTY[exec];    t: PROCEDURE [c: CHARACTER] RETURNS [TTY.CharStatus] = {      IF c = Ascii.CR THEN RETURN[stop] ELSE RETURN[ok]};    setStopTime: PROCEDURE = {      systemIndex ¬ GetDesiredSystem[exec];      IF systemIndex IN [0..data.systems.length) THEN {        NSString.AppendToMesaString[          systemName, data.systems[systemIndex].name];        PutIndentedString[tty, "Enter Stop Time:  "L];        [] ¬ TTY.GetEditedString[tty, timeString, t];        IF (nsTime ¬ ValidateTime[exec, stop, timeString]) =          NSString.nullString THEN RETURN;        AdobeServerOps.PutStartOrStopTimeInternal[          system: systemName, which: stop, startOrStopTime: nsTime]}      ELSE NSExec.PutMessage[exec, S["invalid number entered."L]]};    CatchErrorsFromExec[setStopTime, exec]};  ListSystems: NSExec.ExecProc = {    ServicesError.SetCatching[on: FALSE];    FOR i: NATURAL IN [0..data.systems.length) DO      NSExec.PutIndentedMessage[exec, data.systems[i].name]; ENDLOOP};  ShowClientCount: NSExec.ExecProc = {    string: NSString.String ¬ NSString.MakeString[data.z, 23];    string ¬ NSString.AppendString[string, S["Client Count: "L]];    string ¬ NSString.AppendNumber[string, data.currentClients];    NSExec.PutIndentedMessage[exec, string];    NSString.FreeString[data.z, string];    };  ShowAcceleratorCount: NSExec.ExecProc = {    index: CARDINAL ¬ 0;    string: NSString.String ¬ NSString.MakeString[data.z, 50];    BEGIN    ENABLE {      NSString.InvalidString => {        NSExec.PutMessage[exec, S["invalid string"L]]; GOTO nope};      NSString.InvalidNumber => {        NSExec.PutMessage[exec, S["invalid number"L]]; GOTO nope};      NSString.StringBoundsFault => {        NSExec.PutMessage[exec, S["string too long"L]]; GOTO nope}};    index ¬ GetDesiredSystem[exec];    IF index IN [0..data.systems.length) THEN {      string.length ¬ 0;      string ¬ NSString.AppendString[        string, S["Accelerator Reader Count: "L]];      string ¬ NSString.AppendNumber[        string, data.systems[index].readerCount];      NSExec.PutIndentedMessage[exec, string];      string.length ¬ 0;      string ¬ NSString.AppendString[        string, S["Accelerator Status: "L]];      SELECT data.systems[index].status FROM        readerIn =>          string ¬ NSString.AppendString[string, S["readerIn"L]];        writerWaiting =>          string ¬ NSString.AppendString[string, S["writerWaiting"L]];        writerIn =>          string ¬ NSString.AppendString[string, S["writerIn"L]];        open => string ¬ NSString.AppendString[string, S["open"L]];        ENDCASE =>          string ¬ NSString.AppendString[            string, S["unknown status"L]];      NSExec.PutIndentedMessage[exec, string]}    ELSE NSExec.PutMessage[exec, S["number entered is incorrect"L]];    NSString.FreeString[data.z, string];    EXITS nope => {NSString.FreeString[data.z, string]};    END;    };  ShowSystemParms: NSExec.ExecProc = {    time: AdobeServer.Time;    arSH: AdobeOps.ARSystemHandle;    systemIndex: CARDINAL;    systemName: LONG STRING ¬ [50];    lastAR, version: LONG CARDINAL ¬ 0;    msg: LONG STRING ¬ [100];    BEGIN    ENABLE {      NSString.InvalidString => {        NSExec.PutMessage[exec, S["invalid string"L]]; GOTO exit};      NSString.InvalidNumber => {        NSExec.PutMessage[exec, S["invalid number"L]]; GOTO exit};      NSString.StringBoundsFault => {        NSExec.PutMessage[exec, S["string too long"L]]; GOTO exit}};    systemIndex ¬ GetDesiredSystem[exec];    IF systemIndex IN [0..data.systems.length) THEN {      NSString.AppendToMesaString[        systemName, data.systems[systemIndex].name];      arSH ¬ AdobeServerOps.RetrieveSystemDescriptionInternal[        data.systems[systemIndex].dfH, data.z];      msg.length ¬ 0;      String.AppendString[msg, "System Parameters for "L];      String.AppendString[msg, systemName];      String.AppendString[msg, ": "L];      NSExec.PutMessage[exec, S[msg]];      msg.length ¬ 0;      String.AppendString[msg, "Host: "L];      String.AppendString[msg, arSH.host];      NSExec.PutIndentedMessage[exec, S[msg]];      msg.length ¬ 0;      String.AppendString[msg, "Directory: "L];      String.AppendString[msg, arSH.directory];      NSExec.PutIndentedMessage[exec, S[msg]];      msg.length ¬ 0;      version ¬ AdobeServerOps.GetVersionInternal[systemName];      String.AppendString[msg, "Version: "L];      String.AppendLongNumber[msg, version];      NSExec.PutIndentedMessage[exec, S[msg]];      msg.length ¬ 0;      lastAR ¬        AdobeServerOps.ReadLastARNumberInternal[systemName] + 1;      String.AppendString[msg, "Next Submit Number: "L];      String.AppendLongNumber[msg, lastAR];      NSExec.PutIndentedMessage[exec, S[msg]];      msg.length ¬ 0;      time ¬ AdobeServerOps.GetStartOrStopTimeInternal[        systemName, start];      String.AppendString[msg, "Start Time: "L];      NSString.AppendToMesaString[to: msg, from: time];      NSExec.PutIndentedMessage[exec, S[msg]];      msg.length ¬ 0;      AdobeServerOps.FreeTime[time];      time ¬ AdobeServerOps.GetStartOrStopTimeInternal[        systemName, stop];      String.AppendString[msg, "Stop Time: "L];      NSString.AppendToMesaString[to: msg, from: time];      NSExec.PutIndentedMessage[exec, S[msg]];      msg.length ¬ 0;      AdobeServerOps.FreeTime[time];      [] ¬ AdobeServerOps.FreeSystemDescriptionInternal[arSH, data.z];      data.z.FREE[@arSH]-- minor storage leak --}    ELSE NSExec.PutMessage[exec, S["invalid number was entered"L]];    END;    EXITS exit => NULL;    };  UpdateAllARs: NSExec.ExecProc = {    systemIndex: CARDINAL;    systemName: LONG STRING ¬ [50];    arSet: AdobeOps.SetOfARs ¬ NIL;    updateAllArs: PROCEDURE = {      BEGIN      ENABLE { UNWIND => IF arSet # NIL THEN data.z.FREE[@arSet]};      systemIndex ¬ GetDesiredSystem[exec];      IF systemIndex IN [0..data.systems.length) THEN {        NSString.AppendToMesaString[          systemName, data.systems[systemIndex].name];        arSet ¬ data.z.NEW[AdobeOps .SetOfARsObject[1]];        arSet[0].startValue ¬ 1;        arSet[0].runLength ¬ CARDINAL[          AdobeServerOps.ReadLastARNumberInternal[systemName]];        AdobeServerOps.UpdateAcceleratorsInternal[          systemName, arSet[0]];        --AdobeUpdater.UpdateTheseARs[systemName, arSet[0]];        <<AdobeServerOps.UpdateAccelerators[	server: System.nullNetworkAddress,	systemName: systemName, ars: arSet];>>        data.z.FREE[@arSet]}      ELSE NSExec.PutMessage[exec, S["invalid number was entered"L]];      END};    CatchErrorsFromExec[updateAllArs, exec]};  ExplicitUpdate: NSExec.ExecProc = {    arSet: AdobeOps.SetOfARs ¬ NIL;    systemName: LONG STRING ¬ [50];    first, last: AdobeOps.ARNumber;    systemIndex: CARDINAL;    explicitUpdate: PROCEDURE = {      systemIndex ¬ GetDesiredSystem[exec];      IF systemIndex IN [0..data.systems.length) THEN {        NSString.AppendToMesaString[          systemName, data.systems[systemIndex].name];        NSExec.PutMessage[exec, S["Enter a range of AR numbers."L]];        first ¬ TextInput.GetLongDecimal[          tty: NSExec.GetTTY[exec],          prompt: S["Enter first number in range"L], min: 1];        last ¬ TextInput.GetLongDecimal[          tty: NSExec.GetTTY[exec],          prompt: S["Enter last number in range"L], min: first];        arSet ¬ data.z.NEW[AdobeOps .SetOfARsObject[1]];        arSet[0].startValue ¬ first;        arSet[0].runLength ¬          IF last = 0 THEN 1 ELSE CARDINAL[last - first + 1];        AdobeServerOps.UpdateAcceleratorsInternal[          systemName, arSet[0]];        --AdobeUpdater.UpdateTheseARs[systemName, arSet[0]];        data.z.FREE[@arSet]}      ELSE        NSExec.PutMessage[          exec, S["invalid system number was entered"L]];      };    CatchErrorsFromExec[explicitUpdate, exec]};  InitProfile: NSExec.ExecProc = {    initProf: PROCEDURE = {      systemIndex: CARDINAL;      profileFile: UserProfile.File;      regentry: UserProfile.RegisterEntriesProc = {        register.string[          entry: XString.FromNSString[S["Backup Path"]], default:,          set: FALSE];        register.string[          entry: XString.FromNSString[S["Access List"]], default:,          set: TRUE];        };      systemIndex ¬ AdobeServerOps.GetDesiredSystem[exec];      UserProfile.RegisterSection[        name: XString.FromNSString[data.systems[systemIndex].name],        numberOfEntries: 2, registerEntries: regentry, change: NIL];      profileFile ¬ UserProfile.GetCurrentProfileFile[];      [] ¬ UserProfile.SetCurrentProfileFile[        file: profileFile, updatePrevious: FALSE, readNow: TRUE]};    CatchErrorsFromExec[initProf, exec];    };  --InitProfile  -- utilities  GetDesiredSystem: PUBLIC PROCEDURE [exec: NSExec.Handle]    RETURNS [index: CARDINAL ¬ LAST[CARDINAL]] = {    string: NSString.String ¬ NSString.MakeString[data.z, 50];    NSExec.PutMessage[exec, S["Adobe systems"L]];    FOR j: CARDINAL IN [0..data.systems.length) DO      string ¬ NSString.AppendNumber[string, j + 1];      string ¬ NSString.AppendString[string, S[". "L]];      string ¬ NSString.AppendString[string, data.systems[j].name];      NSExec.PutIndentedMessage[exec, string];      string.length ¬ 0;      ENDLOOP;    index ¬ TextInput.GetDecimal[      tty: NSExec.GetTTY[exec], prompt: S["Enter System number"L],      min: 1, max: data.systems.length];    NSString.FreeString[data.z, string];    RETURN[index - 1]};      GetDesiredField: PROCEDURE [    exec: NSExec.Handle, arSH: AdobeOps.ARSystemHandle]    RETURNS [fLIndex: CARDINAL] = {    index: CARDINAL;    s: NSString.String ¬ NSString.MakeString[data.z, 100];    FOR i: CARDINAL IN [0..arSH.fieldList.len) DO      s.length ¬ 0;      s ¬ NSString.AppendNumber[s, i+1];      s ¬ NSString.AppendString[s, S[". "L]];      s ¬ NSString.AppendString[s, S[arSH.fieldList[i].name]];      NSExec.PutIndentedMessage[exec, s];      s.length ¬ 0;      ENDLOOP;    index ¬ TextInput.GetDecimal[      tty: NSExec.GetTTY[exec], prompt: S["Enter number"L], min: 1,      max: arSH.fieldList.len, default: 0];    NSString.FreeString[data.z, s]; -- minor storage leak    RETURN[index-1]};  ListFields: PROCEDURE [    exec: NSExec.Handle, fieldList: AdobeOps.FieldList,    system: LONG STRING] = {    msg: LONG STRING ¬ [100];    String.AppendString[msg, "Fields of "L];    String.AppendString[msg, system];    String.AppendString[msg, ":"L];    NSExec.PutMessage[exec, S[msg]];    FOR i: CARDINAL IN [0..fieldList.len) DO      NSExec.PutIndentedMessage[exec, S[fieldList[i].name]]; ENDLOOP};  CatchErrorsFromExec: PUBLIC PROCEDURE [    proc: PROC, exec: NSExec.Handle] = {    errorMessage: LONG STRING;    BEGIN    ENABLE      BEGIN      AdobeServerOps.Bug => {        errorMessage ¬ "problem encountered...AdobeServerOps.Bug"L;        GOTO somethingWrong};      NSFile.Error => {        WITH error SELECT FROM          access => {	    SELECT problem FROM	      accessRightsInsufficient => errorMessage ¬ "insufficient access"L;	      accessRightsIndeterminate => 	        errorMessage ¬ "cannot determine if user has access"L;	      fileInUse, fileOpen => errorMessage ¬ "File is open or in use."L;	      fileNotFound, fileNotLocal => 	        errorMessage ¬ "file or directory not found"L;	      ENDCASE => errorMessage ¬ "access problem"L};          authentication => {	    SELECT problem FROM	      cannotReachAS => 	        errorMessage ¬ "cannot reach authentication service"L;	      credentialsInvalid, credentialsTooWeak, keysUnavailable,	      simpleKeyDoesNotExist, strongKeyDoesNotExist => 	        errorMessage ¬ "credentials invalid"L;	      tooBusy => errorMessage ¬ "Authentication service is busy."L;	      ENDCASE => errorMessage ¬ "authentication problem"L};	  clearingHouse => {	    SELECT problem FROM	      illegalOrgName, illegalDomainName, illegalLocalName, noSuchOrg, noSuchDomain, noSuchLocal => errorMessage ¬ "clearingHouse name not found"L;	      allDown, wasUpNowDown, rejectedTooBusy =>	        errorMessage ¬ "ClearingHouse is busy or down."L; 	      ENDCASE =>  errorMessage ¬ "clearinghouse problem"L};	  handle => {	    SELECT problem FROM	      invalid => errorMessage ¬ "handle is invalid"L;	      nullDisallowed => errorMessage ¬ "nullHandle is not allowed"L;	      directoryRequired => errorMessage ¬ "directory required"L;	      ENDCASE => errorMessage ¬ "NSFile.error--Handle problem"L};          insertion => {	    SELECT problem FROM	      fileNotUnique => errorMessage ¬ "File already exists."L;	      ENDCASE => errorMessage ¬ "NSFile.error--insertion problem"L};          service => {	    SELECT problem FROM	      cannotAuthenticate => 	        errorMessage ¬ "File service cannot authenticate."L;	      serviceFull => errorMessage ¬ "File service is full."L;	      serviceUnavailable, sessionInUse => 	        errorMessage ¬ "File service is busy or unavailable."L;	      serviceUnknown => errorMessage ¬ "unknown file service problem"L;	      ENDCASE => errorMessage ¬ "NSFile.error--service problem"L};          session => errorMessage ¬ "invalid session"L;           space => {	    SELECT problem FROM	      allocationExceeded => 	        errorMessage ¬ "allocation exceeded on file service"L;	      mediumFull => errorMessage ¬ "file service is full"L;	      ENDCASE => errorMessage ¬ "NSFile error--space problem"L};          ENDCASE => errorMessage ¬ "NSFile error"L;        GOTO somethingWrong};      NSFileName.Error => GOTO doNothing;      NSString.InvalidString => {        errorMessage ¬ "invalid string"L;        GOTO somethingWrong};      NSString.InvalidNumber => {        errorMessage ¬ "invalid number"L;        GOTO somethingWrong};      NSString.StringBoundsFault => {        errorMessage ¬ "string too long"L;        GOTO somethingWrong};      NSName.Error => {        SELECT type FROM          tooManySeparators =>            errorMessage ¬ "invalid name"L;          ENDCASE => errorMessage ¬ "NSName error"L;        GOTO somethingWrong};      END;    proc[];    EXITS     somethingWrong => NSExec.PutMessage[exec, S[errorMessage]];    doNothing => NULL;    END;    };  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  T: PROCEDURE [c: CHARACTER] RETURNS [TTY.CharStatus] = {    IF c = Ascii.CR THEN RETURN[stop] ELSE RETURN[ok]};  PutIndentedString: PROCEDURE [tty: TTY.Handle, s: LONG STRING] =    BEGIN TTY.PutString[tty, "        "L]; TTY.PutString[tty, s]; END;  AbsToRep: PROCEDURE [h: MyCmFile.Handle] RETURNS [Handle] = {    RETURN[LOOPHOLE[h]]};  RepToAbs: PROCEDURE [h: Handle] RETURNS [MyCmFile.Handle] = {    RETURN[@h.tokenData]};  GetChar: PRIVATE Token.GetCharProcType =    BEGIN    repH: Handle = AbsToRep[h];    c _ Stream.GetChar[      repH.sh ! Stream.EndOfStream => {c _ Ascii.NUL; CONTINUE}]    END;  NoteEvent: PUBLIC PROC [s: LONG STRING] = {    NSExec.BroadcastAsyncMessage[S[s], data.id]};  PutString: PROC [e: NSExec.Handle, s: LONG STRING] = {    NSExec.PutMessage[e, S[s]]};  NoOp: NSExec.ExecProc = {};  GetServerId: PROCEDURE [exec: NSExec.Handle] =    BEGIN    ok: BOOLEAN _ FALSE;    desc: NSString.String;    [name: data.serviceName, desc: desc, identity: data.serviceId] ¬      AccessCH.RegisterService[      primaryPID: AccessCH.adobeServicePID,      genericPIDs: AccessCH.adobeGenericPIDs,      secondaryPIDs: AccessCH.adobeSecondaryPIDs, authLevel: neither,      execHandle: exec, clientID: data.id, z: data.z !      AccessCH.Problem => IF type = entryExisted THEN CONTINUE];    name.length ¬ 0;    name ¬ NSName.AppendNameToString[name, data.serviceName];    IF desc # NSString.nullString THEN      NSString.FreeString[data.z, desc];    --[data.chConv, ok] _ CH.MakeConversationHandle[data.serviceId, data.z];    --IF ~ok THEN Auth.FreeIdentity[@data.serviceId, data.z];    END;  ValidateTime: PROCEDURE [    exec: NSExec.Handle, which: AdobeServer.StartOrStop,    timeString: LONG STRING]    RETURNS [nsTime: AdobeServer.Time ¬ NSString.nullString] =    BEGIN    --of course we must check for times in valid formats etc. but this will do for initial test    --parse for form [N]N:NN[:NN].    chI: CARDINAL ¬ 0;    Complain: PROCEDURE = {      NSExec.PutMessage[exec, S["Invalid Time Entered!"L]]};    WHILE chI < timeString.length DO      IF chI # 0 THEN {        IF timeString[chI] # ': THEN {Complain[]; RETURN};        chI ¬ chI + 1};      IF timeString[chI] NOT IN ['0..'9] THEN {Complain[]; RETURN};      chI ¬ chI + 1;      IF timeString[chI] NOT IN ['0..'9] THEN        IF chI = 1 AND timeString[chI] = ': THEN LOOP        ELSE {Complain[]; RETURN};      chI ¬ chI + 1;      ENDLOOP;    IF chI < 4 THEN {Complain[]; RETURN};    IF chI <= 5 --secs omitted-- THEN      String.AppendStringAndGrow[@timeString, ":00"L, data.z];    IF timeString[2] # ': THEN {  --need lead 0      temp: LONG STRING ¬ String.CopyToNewString[timeString, data.z];      timeString ¬ String.MakeString[data.z, 8];      String.AppendChar[timeString, '0];      String.AppendString[timeString, temp];      data.z.FREE[@temp]};    nsTime ¬ NSString.StringFromMesaString[timeString];    END;  DesiredSelections: PROC    RETURNS [selections: NSFile.Selections _ []] = {    selections.interpreted[name] _ TRUE; };      Services: <<ProductFactoring.Product>> CARDINAL = 1;  -- until Euclid conversion  adobe: <<ServicesPFOptions.Option>> RECORD [CARDINAL[0..15], CARDINAL[0..27]] = [Services, 24];  InitModule: PROC = {    acronym: NSString.String = S["Adobe"L];    name ¬ NSString.AppendString[name, S["Adobe Service"L]];    NSExec.CreateClient[      id: data.id, command: [name: name, proc: NoOp], procs: procs,      acronym: acronym];    NetMgtServiceSupport.RegisterService[      clientID: data.id, serviceOption: LOOPHOLE[adobe],      pid: CHPIDs.adobeService,      bcdTime: Runtime.GetBcdTime[]]};        -- main line code  InitModule[];  END...  -- of AdobeServerControl-- RLC          1-Aug-86 10:20:44 10.0-- RLC         21-Aug-86 10:20:44 PutSystemDesc: IF adobe db already exists remember to close files-- RLC          5-Sep-86 10:52:06  minor storage leak when freeing arSH after calling AdobeServerOps.FreeSystemDescriptionInternal-- RLC          5-Sep-86 11:34:27  minor storage leak in NSString when getting the desired field in MakeAcceleratorFile-- RLC          10-Sep-86 17:16:09 OwnerChecking and Checking on AdobeOps.z are now dependent on the 6 swith being down.-- RLC		 25-Feb-88 17:00:54 fix service name bug (NameAdobeService)
-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- AdobeCourierUtilities.mesa    Edited by:-- BJD    	18-May-84 11:26:41-- RSF      	16-Oct-85 17:27:39-- JCS  	31-Jan-85 15:30:18DIRECTORY  AdobeCourier USING [    ChangeFieldListArguments, ChangeLocationOfARsArguments,    GetAcceleratorInfoArguments, GetNextSubmitNumberArguments,    GetTimeArguments, LookupARsArguments,    MakeAccelFileForFieldArguments, PutLocationOfARsArguments,    PutSubmitNumberArguments, PutTimeArguments, PutVersionIDArguments,    sendingInfo, SetOfARsRecord, streamInputOptions,    SubmitFailedArguments, UpdateAcceleratorFieldArguments,    UpdateAcceleratorsArguments, UpdaterArguments,    VerifyVersionArguments],  AdobeOps USING [    ARSystemHandle, ARSystemObject, ARVersion, DefaultInfoHandle,    DefaultInfoObject, EnumeratedSequence, FieldItemHandle,    FieldItemObject, FieldList, FieldType, FieldTypeIndex,    KeyedPossibilities, Possibilities, RunOfARs, SetOfARs, ToolType],  AdobeServer USING [    ChangeItem, ChangeList, ErrorType, FieldItemQueryValue,    FieldItemValue, StringArray],  Courier USING [Description, ErrorCode, InvalidArguments],  Environment USING [Block, bytesPerPage],  FormSW USING [Enumerated],  NSFile USING [Reference, ServiceRecord],  NSName USING [DescribeNameRecord],  NSString USING [DescribeString],  Space USING [ScratchMap, Unmap],  Stream USING [    Block, CompletionCode, Handle, SendNow, SetSST, SubSequenceType],  System USING [NetworkAddress];AdobeCourierUtilities: PROGRAM  IMPORTS Courier, NSName, NSString, Space, Stream  EXPORTS AdobeCourier =  BEGIN OPEN AdobeOps, AdobeServer;  SystemStringDescriptor, FieldNameDescriptor: TYPE = LONG DESCRIPTOR    FOR ARRAY OF LONG STRING;  maxSystems: CARDINAL = 10;  DescribeSubmitNumber: PUBLIC Courier.Description = {    p: LONG POINTER TO LONG CARDINAL = notes.noteSize[      SIZE[LONG CARDINAL]];    notes.noteLongCardinal[p]};      DescribeBoolean: PUBLIC Courier.Description = {    p: LONG POINTER TO BOOLEAN = notes.noteSize[SIZE[BOOLEAN]];    notes.noteSpace[p, SIZE[BOOLEAN]]};  DescribePutSubmitNumberArguments: PUBLIC Courier.Description = {    p: LONG POINTER TO AdobeCourier.PutSubmitNumberArguments =      notes.noteSize[SIZE[AdobeCourier.PutSubmitNumberArguments]];    notes.noteString[@p.systemName];    notes.noteLongCardinal[@p.submitNumber]};  DescribeARVersion: PUBLIC Courier.Description = {    p: LONG POINTER TO AdobeOps.ARVersion = notes.noteSize[      SIZE[AdobeOps.ARVersion]];    notes.noteLongCardinal[p]};  DescribeSystemName: PUBLIC Courier.Description = {    p: LONG POINTER TO LONG STRING = notes.noteSize[      SIZE[LONG STRING]];    notes.noteString[p]};  DescribeSubmitFailedArguments: PUBLIC Courier.Description = {    p: LONG POINTER TO AdobeCourier.SubmitFailedArguments =      notes.noteSize[SIZE[AdobeCourier.SubmitFailedArguments]];    notes.noteString[@p.systemName];    notes.noteLongCardinal[@p.arNumber];    notes.noteParameters[@p.version, DescribeARVersion]};  DescribeLocationOfARs, DescribeReference: PUBLIC    Courier.Description =    BEGIN OPEN notes;    parameters: LONG POINTER TO NSFile.Reference ¬ noteSize[      SIZE[NSFile.Reference]];    noteDisjointData[@parameters.service, DescribeServiceRecord];    END;  -- of DescribeReference  DescribeServiceRecord: Courier.Description =    BEGIN OPEN notes;    parameters: LONG POINTER TO NSFile.ServiceRecord ¬ noteSize[      SIZE[NSFile.ServiceRecord]];    noteParameters[@parameters.name, NSName.DescribeNameRecord];    END;  -- of DescribeServiceRecord  DescribeGetNextSubmitNumberArguments: Courier.Description = {    p: LONG POINTER TO AdobeCourier.GetNextSubmitNumberArguments =      notes.noteSize[SIZE[AdobeCourier.GetNextSubmitNumberArguments]];    notes.noteString[@p.systemName];    notes.noteParameters[@p.version, DescribeARVersion]};  DescribePutLocationOfARsArguments: PUBLIC Courier.Description = {    p: LONG POINTER TO AdobeCourier.PutLocationOfARsArguments =      notes.noteSize[SIZE[AdobeCourier.PutLocationOfARsArguments]];    notes.noteString[@p.systemName];    notes.noteParameters[@p.loc, DescribeLocationOfARs]};  DescribePutVersionIDArguments: PUBLIC Courier.Description = {    p: LONG POINTER TO AdobeCourier.PutVersionIDArguments =      notes.noteSize[SIZE[AdobeCourier.PutVersionIDArguments]];    notes.noteString[@p.systemName];    notes.noteLongCardinal[@p.versionID]};  DescribeVerifyVersionArguments: PUBLIC Courier.Description = {    p: LONG POINTER TO AdobeCourier.VerifyVersionArguments =      notes.noteSize[SIZE[AdobeCourier.VerifyVersionArguments]];    notes.noteString[@p.systemName];    notes.noteParameters[@p.version, DescribeARVersion]};  DescribeResidentSystemStrings: PUBLIC Courier.Description =    BEGIN    p: LONG POINTER TO SystemStringDescriptor ¬ notes.noteSize[      SIZE[SystemStringDescriptor]];    notes.noteArrayDescriptor[p, SIZE[LONG STRING], maxSystems];    FOR i: CARDINAL IN [0..LENGTH[p­]) DO      notes.noteString[@p­[i]] ENDLOOP    END;  DescribeSystemDescription: PUBLIC Courier.Description = {    aH: AdobeOps.ARSystemHandle ¬ notes.noteSize[      SIZE[AdobeOps.ARSystemObject]];    length: CARDINAL;    DescribeFieldListSequence: Courier.Description = {      fl: FieldList ¬ notes.noteSize[        length * SIZE[FieldItemObject] + SIZE[CARDINAL]];      notes.noteDeadSpace[fl --@fl.len-- , SIZE[CARDINAL]];      FOR i: CARDINAL IN [0..length) DO        notes.noteParameters[@fl[i], DescribeFieldItemObject];        ENDLOOP;      };    notes.noteString[@aH.name];    notes.noteString[@aH.host];    notes.noteString[@aH.directory];    notes.noteDeadSpace[@aH.sysQL, SIZE[LONG POINTER]];  -- NIL long ptr.    notes.noteDeadSpace[@aH.otherQLs, SIZE[LONG POINTER]];  -- NIL long ptr.    notes.noteLongCardinal[@aH.version];    notes.noteDeadSpace[@aH.service, SIZE[System.NetworkAddress]];    SELECT notes.operation FROM      fetch => length ¬ aH.fieldList.len;      store => NULL;      free => length ¬ aH.fieldList.len;      ENDCASE;    notes.noteSpace[@length, SIZE[CARDINAL]];    notes.noteDisjointData[@aH.fieldList, DescribeFieldListSequence];    LOOPHOLE[aH.fieldList, LONG POINTER TO CARDINAL]­ ¬ length;    -- i.e., aH.fieldList.len ¬ length;    FOR tool: ToolType IN ToolType DO  -- these are just ALL[NIL] long ptrs.      notes.noteDeadSpace[        @aH.formSWOrderArray[tool], SIZE[LONG POINTER]];      ENDLOOP};  DescribeFieldItemObject: PUBLIC Courier.Description =    BEGIN    fl: FieldItemHandle ¬ notes.noteSize[SIZE[FieldItemObject]];    lengths: ARRAY FieldTypeIndex OF CARDINAL ¬ [      SIZE[arId FieldItemObject], SIZE[dateTime FieldItemObject],      SIZE[numeric FieldItemObject], SIZE[      fixedLengthString FieldItemObject], SIZE[      enumerated FieldItemObject], SIZE[string FieldItemObject]];    notes.noteChoice[      fl, SIZE[FieldItemObject], DESCRIPTOR[lengths], @fl.body];    notes.noteString[@fl.name];    FOR t: ToolType IN ToolType DO      notes.noteDisjointData[@fl.defaultInfo[t], DescribeDefaultInfo];      ENDLOOP;    WITH fl­ SELECT FROM      arId => NULL;      dateTime => NULL;      numeric => NULL;      fixedLengthString => NULL;      string => NULL;      enumerated => {        length: CARDINAL;        DescribeKeyedPossibilitiesSeq: Courier.Description = {          p: KeyedPossibilities ¬ notes.noteSize[            length * SIZE[Possibilities] + SIZE[CARDINAL]];          notes.noteDeadSpace[p --@p.len-- , SIZE[CARDINAL]];          FOR i: CARDINAL IN [0..length) DO            length: CARDINAL;            DescribeEnumeratedSequenceType: Courier.Description = {              es: EnumeratedSequence ¬ notes.noteSize[                length * SIZE[FormSW.Enumerated] + SIZE[CARDINAL]];              notes.noteDeadSpace[es --@es.length-- , SIZE[CARDINAL]];              FOR j: CARDINAL IN [0..length) DO                notes.noteParameters[@es[j], DescribeFormSWEnumerated]                ENDLOOP};            SELECT notes.operation FROM              fetch => length ¬ p[i].enumRecs.length;              store => NULL;              free => length ¬ p[i].enumRecs.length;              ENDCASE;            notes.noteSpace[@length, SIZE[CARDINAL]];            notes.noteDisjointData[              @p[i].enumRecs, DescribeEnumeratedSequenceType];            LOOPHOLE[p[i].enumRecs, LONG POINTER TO CARDINAL]­ ¬              length;            -- i.e., p[i].enumRecs.length ¬ length;            ENDLOOP;          };        --  notes.noteCardinal[@field];        SELECT notes.operation FROM          fetch => length ¬ possibilities.len;          store => NULL;          free => length ¬ possibilities.len;          ENDCASE;        notes.noteSpace[@length, SIZE[CARDINAL]];        notes.noteDisjointData[          @possibilities, DescribeKeyedPossibilitiesSeq];        LOOPHOLE[possibilities, LONG POINTER TO CARDINAL]­ ¬ length;        -- i.e., possibilities.len ¬ length;        };      ENDCASE => ERROR Courier.InvalidArguments;    END;  DescribeFormSWEnumerated: Courier.Description =    BEGIN    p: LONG POINTER TO FormSW.Enumerated ¬ notes.noteSize[      SIZE[FormSW.Enumerated]];    notes.noteString[@p.string];    END;  DescribeDefaultInfo: Courier.Description =    BEGIN    p: DefaultInfoHandle ¬ notes.noteSize[SIZE[DefaultInfoObject]];    notes.noteString[@p.default];    << notes.xxx[@p.place];  -- RECORD[x,y: INTEGER] >>    END;  DescribeUpdateAcceleratorFieldArguments: PUBLIC    Courier.Description =    BEGIN    p: LONG POINTER TO AdobeCourier.UpdateAcceleratorFieldArguments ¬      notes.noteSize[      SIZE[AdobeCourier.UpdateAcceleratorFieldArguments]];    notes.noteString[@p.systemName];    notes.noteLongCardinal[@p.arNumber];    notes.noteParameters[@p.version, DescribeARVersion];    notes.noteString[@p.fieldName];    notes.noteParameters[@p.value, DescribeFieldItemValue];    END;  DescribeFieldItemValue: PUBLIC Courier.Description =    BEGIN    fv: LONG POINTER TO FieldItemValue = notes.noteSize[      SIZE[FieldItemValue]];    lengths: ARRAY FieldTypeIndex [0..ORD[FieldType[enumerated]]] OF      CARDINAL ¬ [      SIZE[arId FieldItemValue], SIZE[dateTime FieldItemValue], SIZE[      numeric FieldItemValue], SIZE[fixedLengthString FieldItemValue],      SIZE[enumerated FieldItemValue]];    notes.noteChoice[      fv, SIZE[FieldItemValue], DESCRIPTOR[lengths], @fv.body];    WITH fv­ SELECT FROM      arId => notes.noteLongCardinal[@ar];      dateTime => NULL;  -- noteGreenwichMeanTime      numeric => NULL;  -- noteLongUnspecified      fixedLengthString => notes.noteString[@string];      enumerated => NULL;  -- noteCardinal      ENDCASE => ERROR Courier.InvalidArguments;    END;  DescribeLookupARsArguments: PUBLIC Courier.Description =    BEGIN    DescribeSetOfARsSequence: Courier.Description =      BEGIN      setH: AdobeOps.SetOfARs ¬ notes.noteSize[        SIZE[CARDINAL] + p.setLength * SIZE[AdobeOps.RunOfARs]];      FOR i: CARDINAL IN [0..p.setLength) DO        notes.noteLongCardinal[@setH[i].startValue];        notes.noteSpace[@setH[i].runLength, SIZE[CARDINAL]];        ENDLOOP;      END;    p: LONG POINTER TO AdobeCourier.LookupARsArguments ¬      notes.noteSize[      SIZE[CARDINAL] + SIZE[AdobeCourier.LookupARsArguments]];    notes.noteString[@p.systemName];    notes.noteParameters[@p.version, DescribeARVersion];    notes.noteString[@p.fieldName];    notes.noteParameters[@p.value, DescribeFieldItemQueryValue];    notes.noteSpace[@p.setLength, SIZE[CARDINAL]];    notes.noteDisjointData[@p.set, DescribeSetOfARsSequence];    END;  DescribeGetAcceleratorInfoArguments: PUBLIC Courier.Description =    BEGIN    DescribeSetOfARsSequence: Courier.Description =      BEGIN      setH: AdobeOps.SetOfARs ¬ notes.noteSize[        SIZE[CARDINAL] + p.qlLength * SIZE[AdobeOps.RunOfARs]];      FOR i: CARDINAL IN [0..p.qlLength) DO        notes.noteLongCardinal[@setH[i].startValue];        notes.noteSpace[@setH[i].runLength, SIZE[CARDINAL]];        ENDLOOP;      END;    DescribeStringSequence: Courier.Description =      BEGIN      stringSequence: LONG POINTER TO AdobeServer.StringArray;      stringSequence ¬ notes.noteSize[        SIZE[CARDINAL] + p.fieldListLength * SIZE[LONG STRING]];      FOR i: CARDINAL IN [0..p.fieldListLength) DO        notes.noteString[@stringSequence[i]]; ENDLOOP      END;    p: LONG POINTER TO AdobeCourier.GetAcceleratorInfoArguments ¬      notes.noteSize[SIZE[AdobeCourier.GetAcceleratorInfoArguments]];    notes.noteString[@p.systemName];    notes.noteParameters[@p.version, DescribeARVersion];    notes.noteSpace[@p.qlLength, SIZE[CARDINAL]];    notes.noteDisjointData[@p.ql, DescribeSetOfARsSequence];    notes.noteSpace[@p.fieldListLength, SIZE[CARDINAL]];    notes.noteDisjointData[@p.fieldList, DescribeStringSequence];    --notes.noteDisjointData[@p.fieldType, DescribeStringSequence];    -- DescribeStringSequence[notes];    END;  DescribeFieldItemQueryValue: Courier.Description =    BEGIN    fiq: LONG POINTER TO FieldItemQueryValue ¬ notes.noteSize[      SIZE[FieldItemQueryValue]];    notes.noteSpace[@fiq.relationalOp, SIZE[CARDINAL]];  --noteRelation    notes.noteParameters[@fiq.value, DescribeFieldItemValue];    END;  DescribeSetOfARs: PUBLIC Courier.Description =    BEGIN    DescribeSetOfARsSequence: Courier.Description =      BEGIN      setH: AdobeOps.SetOfARs ¬ notes.noteSize[        SIZE[CARDINAL] + length * SIZE[AdobeOps.RunOfARs]];      FOR i: CARDINAL IN [0..length) DO        notes.noteLongCardinal[@setH[i].startValue];        notes.noteSpace[@setH[i].runLength, SIZE[CARDINAL]];        ENDLOOP;      END;    s: LONG POINTER TO AdobeCourier.SetOfARsRecord ¬ notes.noteSize[      SIZE[AdobeCourier.SetOfARsRecord]];    length: CARDINAL;    SELECT notes.operation FROM      fetch, free =>        IF s.set # NIL THEN length ¬ s.set.len ELSE length ¬ 0;      ENDCASE;    notes.noteSpace[@length, SIZE[CARDINAL]];    notes.noteDisjointData[@s.set, DescribeSetOfARsSequence];    END;  DescribeUpdateAcceleratorsArguments: PUBLIC Courier.Description =    BEGIN    DescribeSetOfARsSequence: Courier.Description =      BEGIN      setH: AdobeOps.SetOfARs ¬ notes.noteSize[        SIZE[CARDINAL] + p.setLength * SIZE[AdobeOps.RunOfARs]];      FOR i: CARDINAL IN [0..p.setLength) DO        notes.noteLongCardinal[@setH[i].startValue];        notes.noteSpace[@setH[i].runLength, SIZE[CARDINAL]];        ENDLOOP;      END;    p: LONG POINTER TO AdobeCourier.UpdateAcceleratorsArguments =      notes.noteSize[SIZE[AdobeCourier.UpdateAcceleratorsArguments]];    notes.noteString[@p.systemName];    notes.noteSpace[@p.setLength, SIZE[CARDINAL]];    notes.noteDisjointData[@p.ars, DescribeSetOfARsSequence];    END;  DescribeUpdaterArguments: PUBLIC Courier.Description =    BEGIN    p: LONG POINTER TO AdobeCourier.UpdaterArguments = notes.noteSize[      SIZE[AdobeCourier.UpdaterArguments]];    notes.noteString[@p.systemName];    notes.noteLongCardinal[@p.arNumber];    notes.noteParameters[@p.version, DescribeARVersion];    END;  DescribeTime: PUBLIC Courier.Description =    BEGIN NSString.DescribeString[notes]; END;  DescribePutTimeArguments: PUBLIC Courier.Description =    BEGIN    p: LONG POINTER TO AdobeCourier.PutTimeArguments = notes.noteSize[      SIZE[AdobeCourier.PutTimeArguments]];    notes.noteString[@p.systemName];    notes.noteSpace[@p.which, SIZE[CARDINAL]];    notes.noteParameters[@p.startOrStopTime, DescribeTime];    END;  DescribeGetTimeArguments: PUBLIC Courier.Description =    BEGIN    p: LONG POINTER TO AdobeCourier.GetTimeArguments = notes.noteSize[      SIZE[AdobeCourier.GetTimeArguments]];    notes.noteString[@p.systemName];    notes.noteSpace[@p.which, SIZE[CARDINAL]];    END;  DescribeMakeAccelFileForFieldArguments: PUBLIC Courier.Description =    {    p: LONG POINTER TO AdobeCourier.MakeAccelFileForFieldArguments =      notes.noteSize[      SIZE[AdobeCourier.MakeAccelFileForFieldArguments]];    DescribeFieldListSequence: Courier.Description = {      fl: FieldList ¬ notes.noteSize[        p.listLength * SIZE[FieldItemObject] + SIZE[CARDINAL]];      FOR i: CARDINAL IN [0..p.listLength) DO        notes.noteParameters[@fl[i], DescribeFieldItemObject];        ENDLOOP;      };    notes.noteString[@p.systemName];    notes.noteString[@p.fieldName];    notes.noteSpace[@p.listLength, SIZE[CARDINAL]];    notes.noteDisjointData[@p.fieldList, DescribeFieldListSequence]};  DescribeChangeLocationOfARsArguments: PUBLIC Courier.Description = {    p: LONG POINTER TO AdobeCourier.ChangeLocationOfARsArguments =      notes.noteSize[SIZE[AdobeCourier.ChangeLocationOfARsArguments]];    notes.noteString[@p.systemName];    notes.noteString[@p.newHost];    notes.noteString[@p.newDirectory]};  DescribeChangeFieldListArguments: PUBLIC Courier.Description = {    DescribeChangeList: Courier.Description = {      changeList: AdobeServer.ChangeList ¬ notes.noteSize[        SIZE[CARDINAL] +          p.changeCount * SIZE[AdobeServer.ChangeItem]];      lengths: ARRAY [0..3) OF CARDINAL ¬ [        SIZE[modify AdobeServer.ChangeItem], SIZE[        add AdobeServer.ChangeItem], SIZE[        remove AdobeServer.ChangeItem]];      FOR i: CARDINAL IN [0..p.changeCount) DO        notes.noteChoice[          @changeList[i], SIZE[AdobeServer.ChangeItem], DESCRIPTOR[          lengths], @changeList[i].newItem];        notes.noteString[@changeList[i].oldFieldName];        WITH changeList[i] SELECT FROM          add, modify =>            notes.noteParameters[@newFlItem, DescribeFieldItemObject];          ENDCASE;        ENDLOOP};    p: LONG POINTER TO AdobeCourier.ChangeFieldListArguments =      notes.noteSize[SIZE[AdobeCourier.ChangeFieldListArguments]];    notes.noteString[@p.systemName];    notes.noteParameters[@p.oldVersion, DescribeARVersion];    notes.noteSpace[@p.changeCount, SIZE[CARDINAL]];    notes.noteDisjointData[@p.changeList, DescribeChangeList]};  RetrieveFromCourierStream: PUBLIC PROCEDURE [    courierStream, destStream: Stream.Handle]    RETURNS [bytesRetrieved: CARDINAL ¬ 0] =    BEGIN    buffer: LONG POINTER ¬ Space.ScratchMap[count: 1];    DO      bytesTransferred: CARDINAL;      why: Stream.CompletionCode;      savedSST: Stream.SubSequenceType;      block: Stream.Block ¬ [buffer, 0, Environment.bytesPerPage];      Stream.SetSST[courierStream, AdobeCourier.sendingInfo];      [bytesTransferred, why, savedSST] ¬ courierStream.get[        courierStream, block, AdobeCourier.streamInputOptions];      block.stopIndexPlusOne ¬ bytesTransferred;      bytesRetrieved ¬ bytesRetrieved + bytesTransferred;      Stream.SetSST[destStream, AdobeCourier.sendingInfo];      destStream.put[destStream, block, FALSE];      IF why = endRecord THEN {        Stream.SendNow[sH: destStream, endRecord: TRUE]; EXIT}      ELSE Stream.SendNow[sH: destStream, endRecord: FALSE];      ENDLOOP;    buffer ¬ Space.Unmap[buffer];    END;  --RetrieveFromCourierStream  SendToCourierStream: PUBLIC PROCEDURE [    sourceStream, courierStream: Stream.Handle] =    BEGIN    buffer: LONG POINTER ¬ Space.ScratchMap[count: 1];    DO      bytesTransferred: CARDINAL;      why: Stream.CompletionCode;      savedSST: Stream.SubSequenceType;      block: Stream.Block ¬ [buffer, 0, Environment.bytesPerPage];      Stream.SetSST[sourceStream, AdobeCourier.sendingInfo];      [bytesTransferred, why, savedSST] ¬ sourceStream.get[        sourceStream, block, AdobeCourier.streamInputOptions];      block.stopIndexPlusOne ¬ bytesTransferred;      Stream.SetSST[courierStream, AdobeCourier.sendingInfo];  -- non-0      courierStream.put[courierStream, block, FALSE];      IF why = endOfStream THEN {        Stream.SendNow[sH: courierStream, endRecord: TRUE]; EXIT};      ENDLOOP;    buffer ¬ Space.Unmap[buffer];    END;  --SendToCourierStream  CourierToAdobeError: PUBLIC PROC [courierError: Courier.ErrorCode]    RETURNS [why: AdobeServer.ErrorType] = {    SELECT courierError FROM      transmissionMediumHardwareProblem,        transmissionMediumUnavailable, transmissionMediumNotReady,        noAnswerOrBusy, noRouteToSystemElement, transportTimeout =>        why ¬ serverUnreachable;      remoteSystemElementNotResponding => why ¬ serverDown;      noCourierAtRemoteSite, noSuchProgramNumber =>        why ¬ noAdobeServiceAtServer;      returnTimedOut => why ¬ courierTimedOut;      parameterInconsistency, invalidArguments, noSuchProcedureNumber        => why ¬ parameterInconsistency;      invalidHandle => why ¬ others; --essentially, a bug if we get it      ENDCASE => why ¬ communicationError};  END.  
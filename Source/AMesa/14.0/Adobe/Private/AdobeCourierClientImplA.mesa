-- Copyright (C) 1984, 1985, 1986, 1987, 1988  by Xerox Corporation. All rights reserved. -- AdobeCourierClientImplA.mesa    Edited by:-- BJD    	24-May-84 14:24:44-- RSF      	14-Apr-86 12:46:58-- JCS      	24-Jul-85 15:38:45-- RLC		 2-Mar-88 11:52:22-- Courier client stub.DIRECTORY  AccessCH USING [EnumerateGroup, EnumerateProc],  AddressTranslation USING [    Error, NetworkAddress, StringToNetworkAddress],  AdobeCourier USING [    CourierToAdobeError, DescribeARVersion, DescribeBoolean,    DescribeGetTimeArguments, DescribeLocationOfARs,    DescribePutLocationOfARsArguments,    DescribePutSubmitNumberArguments, DescribePutTimeArguments,    DescribePutVersionIDArguments, DescribeResidentSystemStrings,    DescribeSubmitFailedArguments, DescribeSubmitNumber,    DescribeSystemDescription, DescribeSystemName, DescribeTime,    DescribeVerifyVersionArguments, ErrorIndex,    GetNextSubmitNumberArguments, GetTimeArguments, highVersion,    maxSDByteSize, maxSDPageSize, programNumber,    PutLocationOfARsArguments,    PutSubmitNumberArguments, PutSystemDescriptionArguments,    PutTimeArguments, PutVersionIDArguments,    RetrieveFromCourierStream, SendToCourierStream,    SubmitFailedArguments, translateProc, VerifyVersionArguments],  AdobeOps USING [    ARSystemHandle, ARSystemObject, ARVersion, EnumeratedSequence,    EnumeratedSequenceType, nilEnum, z],  AdobeServer USING [    Error, ErrorType, StartOrStop, SystemElement, Time],  Auth USING [    ConversationHandle, CopyIdentity, FreeIdentity, IdentityHandle],  Courier USING [    Call, Create, Delete, Description, Error, Free, Handle,    RemoteErrorSignalled, SerializeParameters, SystemElement,    VersionMismatch],  Event USING [tajoDefaults],  EventTypes USING [domain, organization],  Heap USING [Create, Delete],  MemoryStream USING [Create, Destroy],  NSFile USING [    Close, Error, GetReference, Handle, LogonDirect, nullHandle,    OpenByName, Reference, Service, ServiceRecord, Session,    SystemElement],  NSName USING [    AppendNameToString, ClearName, CopyName, Error,    FreeName, maxDomainLength, maxFullNameLength, maxLocalLength,    maxOrgLength, Name, NameFieldsFromString, NameFromString,    NameRecord, String],  NSString USING [AppendString, String, StringFromMesaString],  Profile USING [    GetDefaultDomain, GetDefaultOrganization, GetID],  Space USING [ScratchMap, Unmap],  Stream USING [GetPosition, Handle],  String USING [AppendString, EmptyString, MakeString, Replace],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, DeleteSubsystem,    RemoveDependency, SubsystemHandle],  System USING [NetworkAddress, nullNetworkAddress];AdobeCourierClientImplA: MONITOR  IMPORTS    AccessCH, AddressTranslation, AdobeCourier, AdobeOps,    AdobeServer, Auth, Courier, Event, Heap, MemoryStream, NSFile,    NSName, NSString, Profile, Stream, Space, String, Supervisor  EXPORTS AdobeOps, AdobeServer, AdobeCourier =  BEGIN OPEN AdobeServer;  Error: PUBLIC SIGNAL [why: AdobeServer.ErrorType] = CODE;    TranslateError: PROCEDURE [index: CARDINAL]     RETURNS [error: AdobeServer.ErrorType] = INLINE {    RETURN [VAL[index]]};        -- default clearinghouse entries are monitored;  agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[    UpdateDefaults];  defaultOrg: LONG STRING ¬ [NSName.maxOrgLength];  defaultDomain: LONG STRING ¬ [NSName.maxDomainLength];  defaultCHNameRec: NSName.NameRecord ¬ [    org: S[defaultOrg], domain: S[defaultDomain]];  UpdateDefaults: ENTRY Supervisor.AgentProcedure =    BEGIN    ENABLE UNWIND => NULL;    SELECT event FROM      EventTypes.organization => {        appendOrg: PROCEDURE [organization: LONG STRING] = {          defaultOrg.length ¬ 0;          String.AppendString[defaultOrg, organization];          defaultCHNameRec.org.length ¬ defaultOrg.length};        Profile.GetDefaultOrganization[appendOrg]};      EventTypes.domain => {        appendDomain: PROCEDURE [domain: LONG STRING] = {          defaultDomain.length ¬ 0;          String.AppendString[defaultDomain, domain];          defaultCHNameRec.domain.length ¬ defaultDomain.length};        Profile.GetDefaultDomain[appendDomain]};      ENDCASE;    END;  --IMPLEMENT THE INTERFACE   GetNextSubmitNumber: PUBLIC PROC [    server: SystemElement, systemName: LONG STRING,    version: AdobeOps.ARVersion]    RETURNS [submitNumber: LONG CARDINAL] =    BEGIN    localName: LONG STRING ¬ GetLocalName[systemName];    BEGIN    ENABLE UNWIND => FreeLocalName[localName];    localName: LONG STRING ¬ GetLocalName[systemName];    getSubmitNumber: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH,        procedureNumber: AdobeCourier.translateProc[getSubmitNumber],        arguments: [@localName, AdobeCourier.DescribeSystemName],        results: [@submitNumber, AdobeCourier.DescribeSubmitNumber]];      END;    arguments: AdobeCourier.GetNextSubmitNumberArguments ¬ [      localName, version];    SignalCatcher[server, getSubmitNumber, systemName];    FreeLocalName[localName];    END;    END;  PutSubmitNumber: PUBLIC PROC [    server: SystemElement, systemName: LONG STRING,    submitNumber: LONG CARDINAL] =    BEGIN    localName: LONG STRING ¬ GetLocalName[systemName];    BEGIN    ENABLE UNWIND => FreeLocalName[localName];    localName: LONG STRING ¬ GetLocalName[systemName];    putSubmitNumber: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH,        procedureNumber: AdobeCourier.translateProc[putSubmitNumber],        arguments: [        @arguments, AdobeCourier.DescribePutSubmitNumberArguments]];      END;    arguments: AdobeCourier.PutSubmitNumberArguments ¬ [      localName, submitNumber];    SignalCatcher[server, putSubmitNumber, systemName];    FreeLocalName[localName];    END;    END;  SubmitFailed: PUBLIC PROC [    server: SystemElement, systemName: LONG STRING,    arNumber: LONG CARDINAL, version: AdobeOps.ARVersion] =    BEGIN    localName: LONG STRING ¬ GetLocalName[systemName];    BEGIN    ENABLE UNWIND => FreeLocalName[localName];    submitFailed: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH,        procedureNumber: AdobeCourier.translateProc[submitFailed],        arguments: [        @arguments, AdobeCourier.DescribeSubmitFailedArguments]];      END;    arguments: AdobeCourier.SubmitFailedArguments ¬ [      localName, arNumber, version];    SignalCatcher[server, submitFailed, systemName];    FreeLocalName[localName];    END;    END;  ReadLastARNumber: PUBLIC PROCEDURE [    server: SystemElement, system: LONG STRING]    RETURNS [lastAR: LONG CARDINAL] =    BEGIN    localName: LONG STRING ¬ GetLocalName[system];    BEGIN    ENABLE UNWIND => FreeLocalName[localName];    readLastARNumber: PROCEDURE [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH,        procedureNumber: AdobeCourier.translateProc[readLastARNumber],        arguments: [@localName, AdobeCourier.DescribeSystemName],        results: [@lastAR, AdobeCourier.DescribeSubmitNumber]];      END;    SignalCatcher[server, readLastARNumber, system];    FreeLocalName[localName];    END;    END;  GetLocationOfARs: PUBLIC PROCEDURE [    server: SystemElement, systemName: LONG STRING]    RETURNS [referenceToARs: NSFile.Reference] =    BEGIN    localName: LONG STRING ¬ GetLocalName[systemName];    BEGIN    ENABLE UNWIND => FreeLocalName[localName];    getLocationOfARs: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH, 	procedureNumber: AdobeCourier.translateProc[getLocationOfARs],        arguments: [@localName, AdobeCourier.DescribeSystemName],        results: [        @referenceToARs, AdobeCourier.DescribeLocationOfARs]];      END;    SignalCatcher[server, getLocationOfARs, systemName];    FreeLocalName[localName];    END;    END;  FreeLocationOfARs: PUBLIC PROCEDURE [    referenceToARs: NSFile.Reference] = {    Courier.Free[      parameters: [      @referenceToARs, AdobeCourier.DescribeLocationOfARs], zone: z]};  PutSystemDescription: PUBLIC PROCEDURE [    server: LONG STRING, systemName: LONG STRING,    description: AdobeOps.ARSystemHandle] =    BEGIN    putSDArgs: AdobeCourier.PutSystemDescriptionArguments;    putLocArgs: AdobeCourier.PutLocationOfARsArguments;    putVersionIDArgs: AdobeCourier.PutVersionIDArguments;    serverAddress: System.NetworkAddress ¬ System.nullNetworkAddress;    fullServerName: NSName.Name;    fullSystemName: NSName.Name;    localSystemName: LONG STRING ¬ [NSName.maxLocalLength];    localNSSystemName: NSString.String ¬ S[localSystemName];    fullString: LONG STRING ¬ [NSName.maxFullNameLength];    fullNSString: NSString.String ¬ S[fullString];    user: Auth.IdentityHandle;    lengthInWords: CARDINAL ¬ 0;    getId: PROCEDURE [id: Auth.IdentityHandle] = {      user ¬ Auth.CopyIdentity[id, z]};    DescribePutSystemDescriptionArguments: Courier.Description = {      p: LONG POINTER TO AdobeCourier.PutSystemDescriptionArguments ¬        notes.noteSize[        SIZE[AdobeCourier.PutSystemDescriptionArguments]];      notes.noteString[@p.systemName];      notes.noteDeadSpace[@p.sd, SIZE[LONG POINTER]];      notes.noteSpace[p.sd, lengthInWords]};    putSystemDescription: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH, 	procedureNumber: AdobeCourier.translateProc[putSystemDescription],        arguments: [        @putSDArgs, DescribePutSystemDescriptionArguments]];      END;    putLocationOfARs: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH, procedureNumber: AdobeCourier.translateProc[putLocationOfARs],        arguments: [        @putLocArgs, AdobeCourier.DescribePutLocationOfARsArguments]];      END;    putVersionID: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH, procedureNumber: AdobeCourier.translateProc[putVersionID],        arguments: [        @putVersionIDArgs,        AdobeCourier.DescribePutVersionIDArguments]];      END;    CleanUp: PROC = {      MemoryStream.Destroy[sH]; [] ¬ Space.Unmap[space]};    -- Set up for putting ARSystemObject    space: LONG POINTER ¬ Space.ScratchMap[      count: AdobeCourier.maxSDPageSize];    sH: Stream.Handle ¬ MemoryStream.Create[      [space, 0, AdobeCourier.maxSDByteSize]];    {    ENABLE UNWIND => CleanUp[];    --get full service name    fullServerName ¬ MakeFullNameWithDefaults[server, z];    fullNSString ¬ NSName.AppendNameToString[      fullNSString, fullServerName];    fullString.length ¬ fullNSString.length;    Profile.GetID[proc: getId];    --lookup service address    [addr: serverAddress] ¬ AddressTranslation.StringToNetworkAddress[      s: fullString, id: user];    fullNSString.length ¬ 0;    --get full system name    fullSystemName ¬ MakeFullNameWithDefaults[systemName, z];    fullNSString ¬ NSName.AppendNameToString[      fullNSString, fullSystemName];    fullString.length ¬ fullNSString.length;    --make sure that the name in the description has had    -- domain/org stripped from it    localNSSystemName ¬ NSString.AppendString[      to: localNSSystemName, from: fullSystemName.local];    localSystemName.length ¬ localNSSystemName.length;    String.Replace[@description.name, localSystemName, z];    Courier.SerializeParameters[      parameters: [      location: description,      description: AdobeCourier.DescribeSystemDescription], sH: sH];    lengthInWords ¬ CARDINAL[(Stream.GetPosition[sH] + 1) / 2];    --putsystem description must use the fully qualified system name    putSDArgs ¬ [      systemName: fullString, length: lengthInWords, sd: space];    --putLoc and putVersion must only use the local system name    putLocArgs ¬ [      localSystemName, DetermineLocationOfARs[description]];    putVersionIDArgs ¬ [localSystemName, description.version];    SignalCatcher[serverAddress, putSystemDescription, fullString];    SignalCatcher[serverAddress, putLocationOfARs, fullString];    SignalCatcher[serverAddress, putVersionID, fullString];    CleanUp[];    }    END;  GetSystemDescription: PUBLIC PROCEDURE [    server: SystemElement, systemName: LONG STRING]    RETURNS [description: AdobeOps.ARSystemHandle] =    BEGIN    user: Auth.IdentityHandle ¬ NIL;    localName: LONG STRING;    BEGIN    ENABLE UNWIND => FreeLocalName[localName];    getId: PROCEDURE [id: Auth.IdentityHandle] = {      user ¬ Auth.CopyIdentity[id, z]};    getSystemDescription: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH, procedureNumber: AdobeCourier.translateProc[getSystemDescription],        arguments: [@localName, AdobeCourier.DescribeSystemName],        results: [        description, AdobeCourier.DescribeSystemDescription]];      END;    description ¬ AdobeOps.z.NEW[AdobeOps.ARSystemObject ¬ []];    Profile.GetID[proc: getId];    localName ¬ GetLocalName[systemName];    [element: server] ¬ HostForDataBase[      zone: z, system: systemName, userId: user];    SignalCatcher[server, getSystemDescription, systemName];    description.service ¬ server;    IF user # NIL THEN Auth.FreeIdentity[@user, z];    FreeLocalName[localName];    END;    END;  FreeSystemDescription: PUBLIC PROCEDURE [    description: AdobeOps.ARSystemHandle]    RETURNS [nil: AdobeOps.ARSystemHandle] =    BEGIN    Courier.Free[      [description, AdobeCourier.DescribeSystemDescription],      AdobeOps.z];    AdobeOps.z.FREE[@description];    RETURN[NIL];    END;  GetResidentSystemStrings: PUBLIC PROCEDURE [server: SystemElement]    RETURNS [systemStrings: DESCRIPTOR FOR ARRAY OF LONG STRING] =    BEGIN    getResidentSystemStrings: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH,        procedureNumber: AdobeCourier.translateProc[getResidentSystemStrings],        results: [        @systemStrings, AdobeCourier.DescribeResidentSystemStrings]];      END;    SignalCatcher[server, getResidentSystemStrings, NIL];    END;  FreeResidentSystemStrings: PUBLIC PROCEDURE [    systemStrings: DESCRIPTOR FOR ARRAY OF LONG STRING] =    BEGIN    Courier.Free[      [@systemStrings, AdobeCourier.DescribeResidentSystemStrings],      AdobeOps.z]    END;  VerifyVersion: PUBLIC PROCEDURE [    server: SystemElement, systemName: LONG STRING,    version: AdobeOps.ARVersion] RETURNS [ok: BOOLEAN] =    BEGIN    localName: LONG STRING ¬ GetLocalName[systemName];    {    ENABLE UNWIND => FreeLocalName[localName];    verifyVersion: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH, procedureNumber: AdobeCourier.translateProc[verifyVersion],        arguments: [        @arguments, AdobeCourier.DescribeVerifyVersionArguments],        results: [@ok, AdobeCourier.DescribeBoolean]];      END;    arguments: AdobeCourier.VerifyVersionArguments ¬ [      localName, version];    SignalCatcher[server, verifyVersion, systemName];    FreeLocalName[localName]};    END;  GetVersion: PUBLIC PROCEDURE [    server: SystemElement, systemName: LONG STRING]    RETURNS [version: AdobeOps.ARVersion] =    BEGIN    localName: LONG STRING ¬ GetLocalName[systemName];    {    ENABLE UNWIND => FreeLocalName[localName];    verifyVersion: PROC [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH, procedureNumber: AdobeCourier.translateProc[getVersion],        arguments: [@localName, AdobeCourier.DescribeSystemName],        results: [@version, AdobeCourier.DescribeARVersion]];      END;    SignalCatcher[server, verifyVersion, systemName];    FreeLocalName[localName]};    END;  GetSystemDefaultUserFile: PUBLIC PROCEDURE [    server: SystemElement, systemName: LONG STRING, to: Stream.Handle]    RETURNS [bytesInFile: CARDINAL] =    BEGIN    localName: LONG STRING ¬ GetLocalName[systemName];    {    ENABLE UNWIND => FreeLocalName[localName];    streamCheckout: PROCEDURE [cH: Courier.Handle] = {      bytesInFile ¬ AdobeCourier.RetrieveFromCourierStream[        cH.sH, to]};    getSystemDefaultUserFile: PROCEDURE [cH: Courier.Handle] = {      [] ¬ Courier.Call[        cH: cH, procedureNumber: AdobeCourier.translateProc[getSystemDefaultUser],        arguments: [@localName, AdobeCourier.DescribeSystemName],        streamCheckoutProc: streamCheckout]};    SignalCatcher[server, getSystemDefaultUserFile, systemName];    FreeLocalName[localName]};    END;  PutSystemDefaultUserFile: PUBLIC PROCEDURE [    server: SystemElement, systemName: LONG STRING,    from: Stream.Handle] =    BEGIN    localName: LONG STRING ¬ GetLocalName[systemName];    {    ENABLE UNWIND => FreeLocalName[localName];    streamCheckout: PROCEDURE [cH: Courier.Handle] = {      AdobeCourier.SendToCourierStream[from, cH.sH]};    putSystemDefaultUserFile: PROCEDURE [cH: Courier.Handle] = {      [] ¬ Courier.Call[        cH: cH, procedureNumber: AdobeCourier.translateProc[putSystemDefaultUser],        arguments: [@localName, AdobeCourier.DescribeSystemName],        streamCheckoutProc: streamCheckout]};    SignalCatcher[server, putSystemDefaultUserFile, systemName];    FreeLocalName[localName]};    END;  PutStartOrStopTime: PUBLIC PROCEDURE [    server: SystemElement, systemName: LONG STRING,    which: StartOrStop, startOrStopTime: AdobeServer.Time] =    BEGIN    localName: LONG STRING ¬ GetLocalName[systemName];    {    ENABLE UNWIND => FreeLocalName[localName];    putStartOrStopTime: PROCEDURE [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH, procedureNumber: AdobeCourier.translateProc[putStartOrStopTime],        arguments: [        @arguments, AdobeCourier.DescribePutTimeArguments]];      END;    arguments: AdobeCourier.PutTimeArguments ¬ [      localName, which, startOrStopTime];    SignalCatcher[server, putStartOrStopTime, systemName];    FreeLocalName[localName]};    END;  GetStartOrStopTime: PUBLIC PROCEDURE [    server: SystemElement, systemName: LONG STRING,    which: StartOrStop] RETURNS [startOrStopTime: AdobeServer.Time] =    BEGIN    localName: LONG STRING ¬ GetLocalName[systemName];    {    ENABLE UNWIND => FreeLocalName[localName];    getStartOrStopTime: PROCEDURE [cH: Courier.Handle] =      BEGIN      [] ¬ Courier.Call[        cH: cH, procedureNumber: AdobeCourier.translateProc[getStartOrStopTime],        arguments: [        @arguments, AdobeCourier.DescribeGetTimeArguments],        results: [@startOrStopTime, AdobeCourier.DescribeTime]];      END;    arguments: AdobeCourier.GetTimeArguments ¬ [localName, which];    SignalCatcher[server, getStartOrStopTime, systemName];    FreeLocalName[localName]};    END;  ProcessRemoteError: PROC [errorNumber: CARDINAL]    RETURNS [errorType: AdobeServer.ErrorType] =    BEGIN    IF errorNumber ~IN AdobeCourier.ErrorIndex THEN ERROR;    errorType ¬ TranslateError[errorNumber];    END;  --ProcessRemoteError  SignalCatcher: PUBLIC PROCEDURE [    server: Courier.SystemElement, proc: PROC [cH: Courier.Handle],    adobeSystem: LONG STRING] =    BEGIN    why: AdobeServer.ErrorType;    cH: Courier.Handle;    user: Auth.IdentityHandle ¬ NIL;    getId: PROCEDURE [id: Auth.IdentityHandle] = {      user ¬ Auth.CopyIdentity[id, z]};    IF server = System.nullNetworkAddress THEN {      --caller doesn't know where this system lives      Profile.GetID[proc: getId];      [element: server] ¬ HostForDataBase[        zone: z, system: adobeSystem, userId: user];      Auth.FreeIdentity[@user, z]};    cH ¬ Courier.Create[      remote: server, programNumber: AdobeCourier.programNumber,      versionNumber: AdobeCourier.highVersion, zone: AdobeOps.z,      classOfService: transactional];    BEGIN    ENABLE      BEGIN      Courier.VersionMismatch => {        why ¬ spare1; GOTO delete}; -- signals protocol version mismatch      Courier.Error => {        why ¬ AdobeCourier.CourierToAdobeError[errorCode];        GOTO delete};      UNWIND => {        IF user # NIL THEN Auth.FreeIdentity[@user, z]; REJECT};      Courier.RemoteErrorSignalled => {        why ¬ ProcessRemoteError[errorNumber]; GOTO delete};      END;    proc[cH];    Courier.Delete[cH];    EXITS      delete => {Courier.Delete[cH]; ERROR AdobeServer.Error[why]};    END;    END;  --SignalCatcher  HostForDataBase: PROCEDURE [    zone: UNCOUNTED ZONE, system: LONG STRING,    userId: Auth.IdentityHandle]    RETURNS [      element: System.NetworkAddress, conv: Auth.ConversationHandle] =    {    hostName, dbName: NSName.Name ¬ NIL;    lookupProc: AccessCH.EnumerateProc = {      string: LONG STRING = [NSName.maxFullNameLength];      nameString: NSString.String ¬ S[string];      hostName ¬ NSName.CopyName[zone, currentName];  -- assumes one member      nameString ¬ NSName.AppendNameToString[        name: currentName, s: nameString];      string.length ¬ nameString.length;      [addr: element] ¬ AddressTranslation.StringToNetworkAddress[        s: string, id: userId]};    {    ENABLE {      AddressTranslation.Error => AdobeServer.Error[unknownSystem];      --AccessCH.Problem => AccessCHError[type];      --Auth.CallError => AuthCallError[reason, whichArg];      --Auth.AuthenticationError => AuthenticationError[reason];      UNWIND => {        IF hostName # NIL THEN NSName.FreeName[zone, hostName];        IF dbName # NIL THEN NSName.FreeName[zone, dbName]}};    dbName ¬ MakeFullNameWithDefaults[shortName: system, z: zone];    IF userId = NIL THEN ERROR AdobeServer.Error[illegalLogin];    AccessCH.EnumerateGroup[      name: dbName, enumProc: lookupProc, identity: userId, z: zone];    --don't bother for now    --conv ¬ Auth.Initiate[userId, hostName, element.host, zone];    NSName.FreeName[zone, hostName];    NSName.FreeName[zone, dbName];    }};  -- of HostForDataBase  MakeFullNameWithDefaults: PROC [    shortName: LONG STRING, z: UNCOUNTED ZONE]    RETURNS [fullName: NSName.Name] = {    fullName ¬ NSName.NameFromString[      z: z, s: S[shortName], clientDefaults: @defaultCHNameRec]};  <<private heap which should be used by clients of AdobeOps    (i.e. the stream stuff)>>  z: PUBLIC UNCOUNTED ZONE;  -- AdobeOps.z  nilPossibilities: PUBLIC AdobeOps.EnumeratedSequence;  Initialize: PUBLIC PROCEDURE =    BEGIN    z ¬ Heap.Create[      initial: 50, increment: 10, ownerChecking: TRUE,       checking: TRUE];    nilPossibilities ¬ z.NEW[AdobeOps .EnumeratedSequenceType[1]];    nilPossibilities[0] ¬ ["Nil", AdobeOps.nilEnum];    END;  CleanUp: PUBLIC PROCEDURE =    BEGIN    Heap.Delete[z];    Supervisor.RemoveDependency[      client: agent, implementor: Event.tajoDefaults];    Supervisor.DeleteSubsystem[agent];    END;  -- Utilities  DetermineLocationOfARs: PROCEDURE [    description: AdobeOps.ARSystemHandle]    RETURNS [location: NSFile.Reference] =    BEGIN    reason: AdobeServer.ErrorType;    session: NSFile.Session;    fH: NSFile.Handle ¬ NSFile.nullHandle;    service: NSFile.Service ¬ z.NEW[NSFile.ServiceRecord ¬ []];    logon: PROC [id: Auth.IdentityHandle] = {      [addr: service.systemElement] ¬        AddressTranslation.StringToNetworkAddress[        description.host, id, @service.name];      session ¬ NSFile.LogonDirect[identity: id, service: service]};    {    ENABLE {      --was ProfileExtra.Error here. May need to catch something else.      Courier.Error => {reason ¬ cantDetermineLocOfARs; GOTO error};      NSFile.Error => {reason ¬ cantDetermineLocOfARs; GOTO error};      NSName.Error => ERROR AdobeServer.Error[cantDetermineLocOfARs]};    NSName.NameFieldsFromString[      z: z, s: S[description.host], destination: @service.name];    Profile.GetID[proc: logon];    fH ¬ NSFile.OpenByName[      directory: NSFile.nullHandle, path: S[description.directory],      session: session];    location ¬ [      fileID: NSFile.GetReference[file: fH, session: session].fileID,      service: service];    NSFile.Close[fH, session];    EXITS      error => {        NSName.ClearName[z, @service.name];        IF fH # NSFile.nullHandle THEN NSFile.Close[fH, session];        ERROR AdobeServer.Error[reason]};    }    END;  GetLocalName: PROCEDURE [fullName: LONG STRING]    RETURNS [localName: LONG STRING] = {    i: CARDINAL ¬ 0;    IF String.EmptyString[fullName] THEN RETURN[NIL];    localName ¬ String.MakeString[z, fullName.length];    WHILE fullName[i] # ': AND i < fullName.length      AND i < NSName.maxFullNameLength DO      localName[i] ¬ fullName[i]; i ¬ i + 1; ENDLOOP;    localName.length ¬ i};  FreeLocalName: PROCEDURE [name: LONG STRING] = {z.FREE[@name]};  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  Init: PROCEDURE =    BEGIN    Supervisor.AddDependency[      client: agent, implementor: Event.tajoDefaults];    UpdateDefaults[EventTypes.organization, NIL, NIL];    UpdateDefaults[EventTypes.domain, NIL, NIL];    END;  -- main line code  Init[];  END. -- AdobeCourierClientImplA    25-Feb-88 18:23:42 - RLC - use new AdobeServer.ErrorCode definition. 2-Mar-88 11:52:22 - rlc - use AdobeServer.Error[spare1] to siganl protocol version mismatch  
-- Copyright (C) 1982, 1985  by Xerox Corporation. All rights reserved. -- File: AdobeCommon.mesa - last edit by:-- MXF		27-Dec-82 15:59:00-- RSF		25-Apr-85 19:17:17-- JCS		 9-Oct-85 15:19:03DIRECTORY  AdobeOps USING [ARNumber, ARSystemHandle, DependsOnIndex,    FieldType, QueryList, SetOfARs, ToolType],  AdobeToolContext USING [UserContext],  AdobeServer USING [Relation, StringArray],  ARAccess USING [Session],  FormSW USING [    FreeHintsProcType, ItemHandle, MenuProcType, ProcType],  Menu USING [Handle],  Supervisor USING [SubsystemHandle],  Window USING [Handle];AdobeCommon: DEFINITIONS =   BEGIN   -- data types    OtherSWsHandle: TYPE = LONG POINTER TO OtherSWs;  OtherSWs: TYPE = RECORD[    handles: SEQUENCE length: CARDINAL OF Window.Handle];      SystemsHandle: TYPE = LONG POINTER TO Systems;  Systems: TYPE = RECORD[    next: CARDINAL ¬ 0,    system: SEQUENCE maxLength: CARDINAL OF LONG STRING];      SysDescPtr: TYPE = LONG POINTER TO SysDesc;  SysDesc: TYPE = RECORD[    arSH: AdobeOps.ARSystemHandle ¬ NIL,    nextNode: SysDescPtr ¬ NIL];  LockedSysDescPtr: TYPE = LONG POINTER TO LockedPtr;  LockedPtr: TYPE = MONITORED RECORD[    nodePtr: SysDescPtr];      StringArray: TYPE = AdobeServer.StringArray;      DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    window(0): Window.Handle ¬ NIL,    msgSW(2): Window.Handle ¬ NIL,    cmdSW(4): Window.Handle ¬ NIL,    deacAgent(6): Supervisor.SubsystemHandle,    logonAgent(7): Supervisor.SubsystemHandle,    swapAgent(8): Supervisor.SubsystemHandle,    processID(9): PROCESS,    tool(10): AdobeOps.ToolType ¬ submit,    knownSystems(11): SystemsHandle ¬ NIL,    system(13): CARDINAL ¬ LAST[CARDINAL],    newSystem(14): LONG STRING ¬ NIL,    systemMenu(16): Menu.Handle ¬ NIL,    changingSystem(18): BOOLEAN ¬ FALSE,    isBusy(19): BOOLEAN ¬ FALSE,    dontCleanUp(20): BOOLEAN ¬ FALSE,    heap(21): UNCOUNTED ZONE ¬ NIL,    context(23): AdobeToolContext.UserContext ¬ NIL,    accessSession(25): ARAccess.Session ¬ NIL,    --non-specific pointer to allow other tools implemented on Adobe's    --interfaces to define their own instanceData    instanceData(27): LONG POINTER ¬ NIL];      ReportFields: TYPE = LONG POINTER TO ReportFieldsSeq;  ReportFieldsSeq: TYPE = RECORD [    seq: SEQUENCE length: CARDINAL OF BOOLEAN];  OrderInfo: TYPE = LONG POINTER TO OrderInfoObject;  OrderInfoObject: TYPE = RECORD [    widths: SEQUENCE length: CARDINAL OF OrderItem];  OrderItem: TYPE = RECORD [    flName: LONG STRING ¬ NIL,    flIndex: CARDINAL ¬ 0,    colWidth: CARDINAL ¬ 0,    colIndex: CARDINAL ¬ 0];  RowBuffer: TYPE = RECORD [s: LONG STRING, next: LONG POINTER TO RowBuffer];  TemplateEntry: TYPE = {fixed, variable, string};  Template: TYPE = LONG POINTER TO TemplateObject;  TemplateObject: TYPE = RECORD [    next: Template ¬ NIL,    body:      SELECT type: TemplateEntry FROM	fixed => [width: CARDINAL ¬ 0],	variable => NULL,	string => [	  s: LONG STRING ¬ NIL, 	  suppressFieldName: BOOLEAN ¬ FALSE, 	  nameStart, nameLength: CARDINAL ¬ 0],	ENDCASE];  FormatType: TYPE = {plain, columns, template};  SetStatus: TYPE = RECORD [runOffset, setIndex: CARDINAL];    --constants  InitialSetStatus: SetStatus = [LAST[CARDINAL], LAST[CARDINAL]];  ColSpace: CARDINAL = 2;  --Allowable relations for field types  ValidRelations: TYPE = ARRAY AdobeOps.FieldType OF Operations;  Operations: TYPE = PACKED ARRAY AdobeServer.Relation OF BOOLEAN;      validRelations: ValidRelations = [    arId: [      equal: TRUE, notEqual: TRUE, lessThan: TRUE,      lessThanOrEqual: TRUE, greaterThan: TRUE,      greaterThanOrEqual: TRUE, in: FALSE, notIn: FALSE],    dateTime: [      equal: TRUE, notEqual: TRUE, lessThan: TRUE,      lessThanOrEqual: TRUE, greaterThan: TRUE,      greaterThanOrEqual: TRUE, in: FALSE, notIn: FALSE],    numeric: [      equal: TRUE, notEqual: TRUE, lessThan: TRUE,      lessThanOrEqual: TRUE, greaterThan: TRUE,      greaterThanOrEqual: TRUE, in: FALSE, notIn: FALSE],    fixedLengthString: [      equal: TRUE, notEqual: TRUE, lessThan: FALSE,      lessThanOrEqual: FALSE, greaterThan: FALSE,      greaterThanOrEqual: FALSE, in: TRUE, notIn: TRUE],    enumerated: [      equal: TRUE, notEqual: TRUE, lessThan: FALSE,      lessThanOrEqual: FALSE, greaterThan: FALSE,      greaterThanOrEqual: FALSE, in: FALSE, notIn: FALSE],    string: ALL[FALSE]];      --procedures    CatchErrors: PROCEDURE[    sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    windowData: AdobeCommon.DataHandle, proc: FormSW.ProcType];      EnableAdobeAborts: PROCEDURE[w: Window.Handle];  DisableAdobeAborts: PROCEDURE[w: Window.Handle];      SetFSWOrderAndDefaultFromUserFile: PROCEDURE[systemName: LONG STRING, arSH: AdobeOps.ARSystemHandle];    GetData: PROCEDURE[w: Window.Handle] RETURNS [DataHandle];  GetDataSW: PROCEDURE[sw: Window.Handle] RETURNS [DataHandle];    CreateOtherSWs: PROCEDURE[    w: Window.Handle, makeCmdSW: BOOLEAN ¬ TRUE];  DestroyOtherSWs: PROCEDURE[    data: DataHandle, killCmdSW: BOOLEAN ¬ TRUE];  ChangeFormSW: PROCEDURE[w: Window.Handle];    PostMessage: PROCEDURE[sw: Window.Handle, postCR: BOOLEAN, message: LONG STRING];  PostNumber: PROCEDURE[sw: Window.Handle, postCR: BOOLEAN, number: LONG UNSPECIFIED];--number to agree with Put.LongNumber's parameter    --Routines to handle DescList       SearchKnownSysDescList: PROCEDURE[head: LockedSysDescPtr,    systemName: LONG STRING]    RETURNS[arSH: AdobeOps.ARSystemHandle ¬ NIL];  AddToKnownSysDescList: PROCEDURE[head: LockedSysDescPtr,    arSH: AdobeOps.ARSystemHandle];  DeleteSysDescList: PROCEDURE[head: LockedSysDescPtr]    RETURNS[nilHead: LockedSysDescPtr ¬ NIL];  GetDescList: PROCEDURE RETURNS [LockedSysDescPtr];  FindSystem: PROCEDURE[    head: LockedSysDescPtr, toolData: DataHandle,    systemName: LONG STRING, useDescList: BOOLEAN]    RETURNS [arSH: AdobeOps.ARSystemHandle];      --Routine to change systems  ChangeSystem: PROCEDURE [toolData: DataHandle, systemIndex: CARDINAL, useDescList: BOOLEAN];      --Routines to manage known systems    LocateSystemInKnownSystems: PROCEDURE[name: LONG STRING,    systems: SystemsHandle] RETURNS[system: CARDINAL];  AddSystemToKnownSystems: PROCEDURE[name: LONG STRING,       systems: LONG POINTER TO SystemsHandle,      heap: UNCOUNTED ZONE];  RemoveSystemFromKnownSystems: PROCEDURE[name: LONG STRING,    systems: LONG POINTER TO SystemsHandle,    z: UNCOUNTED ZONE];  AllocateKnownSystems: PROCEDURE[oldSeq: SystemsHandle,    z: UNCOUNTED ZONE] RETURNS[newSeq: SystemsHandle];        --Procedures for QueryLists  QLNameHints: FormSW.MenuProcType; --provides list of available query lists  FreeHintStrings: FormSW.FreeHintsProcType; --should work for any hint menu.  CountARs:  PROCEDURE [set: AdobeOps.SetOfARs]    RETURNS [n: LONG CARDINAL]; --counts the number of ars in a query list.  GetNextAR: PROCEDURE[    set: AdobeOps.SetOfARs, current: SetStatus]    RETURNS[nextAR: AdobeOps.ARNumber, newStatus: SetStatus];--get next ar in query list/SetOfARs  GetPreviousAR: PROCEDURE[    set: AdobeOps.SetOfARs, current: SetStatus]    RETURNS[nextAR: AdobeOps.ARNumber, newStatus: SetStatus];--get previous ar in query list/SetOfARs  FindThisQL: PROCEDURE[qlName: LONG STRING,    arSH: AdobeOps.ARSystemHandle]     RETURNS [qlHandle: AdobeOps.QueryList];--get queryList given name  AndSets: PROCEDURE[    set1, set2: AdobeOps.SetOfARs] RETURNS [resultSet: AdobeOps.SetOfARs];--ANDs set1 and set2 and returns the resulting set  OrSets: PROCEDURE[    set1, set2: AdobeOps.SetOfARs] RETURNS[resultSet: AdobeOps.SetOfARs];--ORs set1 and set2 and returns the resulting set  AddToSet: PROCEDURE[    arNum: AdobeOps.ARNumber, set: LONG POINTER TO AdobeOps.SetOfARs,    lastRef: CARDINAL]     RETURNS[thisRef: CARDINAL];--adds arNum to set  GrowSet: PROCEDURE [oldSet: LONG POINTER TO AdobeOps.SetOfARs];  AddToOtherQLList: PROCEDURE [arSH: AdobeOps.ARSystemHandle, ql: AdobeOps.QueryList];--adds ql to otherQLs of the arSH    --Procedure to reset dependent enumerated item after item it depends on has been changed  SetChoicesForEnumerated: PROCEDURE[sw: Window.Handle,    windowData: DataHandle, itemIndex: CARDINAL,    fli: AdobeOps.DependsOnIndex, displayIndex: CARDINAL,    reset: BOOLEAN];    END....
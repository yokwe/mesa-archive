-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- AdobeServerControlB.mesa -last edit:-- JCS		13-Oct-85 23:32:19-- RSF		10-Apr-86 11:49:05-- RLC		 5-Aug-86 17:36:11DIRECTORY  AccessCH USING [    adobeGenericPIDs, adobeSecondaryPIDs, adobeSystemPID,    RegisterDatabase, UnRegisterDatabase],  AdobeServerOps USING [    acceleratorsDir, adobeFolder, CatchErrorsFromExec,    defaultUserFile, descriptionFile, data, Data, GetDesiredSystem,    updaterBackingFile],  Ascii USING [CR],  Auth USING [IdentityHandle],  Backup USING [File, RecoverFile],  Heap USING [systemZone],  NSAssignedTypes USING [tDirectory],  NSExec USING [    ExecProc, GetTTY, Handle, PutIndentedMessage, PutMessage, WorkingDirectory,    SystemDirectory, SystemFilingSession, UserIdentity],  NSFile USING [    Attribute, Attributes, AttributesProc, Close, Controls,     Copy, Create, Delete, Error, GetReference, Handle, List,     Lock, Logoff, Logon, nullHandle, nullSession, Open, OpenByName,    OpenByReference, OpenChild, Scope, Selections, Session, String],  NSFileName USING [Error, VPNFieldsFromString, VPNRecord],  NSName USING [    Error, FreeName, MakeName, maxDomainLength, maxFullNameLength,    maxLocalLength, maxOrgLength, Name, NameFromString],  NSString USING [    AppendString, AppendToMesaString, CompareStrings, FreeString,    MakeString, nullString, String, StringFromMesaString],  NSTTY USING [PutLine],  ServicesError USING [SetCatching],  SpecialNSFile USING [EnablePrivileges],  String USING [AppendChar, CompareStrings],  TextInput USING [GetText, GetYesNo, nilYesNo, YesOrNo],  TTY USING [CharStatus, GetEditedString, Handle, PutCR, PutString];AdobeServerControlB: MONITOR  IMPORTS    AccessCH, AdobeServerOps, Backup, Heap, NSExec, NSFile, NSName,    NSFileName, NSString, NSTTY, ServicesError, SpecialNSFile, String,    TextInput, TTY  EXPORTS AdobeServerOps =  BEGIN  data: AdobeServerOps.Data = @AdobeServerOps.data;  DestroyARSystem: PUBLIC NSExec.ExecProc = {    <<Remember that Destroy happens when service is stopped; hence      no files are open and the global data object has no       systems information in it, no zone, no session.  A new session      is created to store files to the backup directory.>>    adobeDir, arSysHandle: NSFile.Handle ¬ NSFile.nullHandle;    session: NSFile.Session ¬ NSFile.Logon[GetIdentity[exec]];    sysDir, fh: NSFile.Handle;    dbName: NSString.String ¬ NSString.MakeString[      Heap.systemZone, NSName.maxFullNameLength];    tty: TTY.Handle ¬ NSExec.GetTTY[exec];    systemName: LONG STRING ¬ [100];    hostAndPath: NSString.String ¬ NSString.nullString;    ok: BOOLEAN;    msg: NSString.String;    confirm, confirmBackupPath: TextInput.YesOrNo ¬ TextInput.nilYesNo;    control: NSFile.Controls ¬ [lock: exclusive];    destroy: PROCEDURE = {      BEGIN      ENABLE {        UNWIND => {          NSString.FreeString[Heap.systemZone, dbName];          IF session # NSFile.nullSession THEN            NSFile.Logoff[session]}};      FindARSystem: NSFile.AttributesProc = {        IF NSString.CompareStrings[attributes.name, S[systemName]] =          equal THEN {          arSysHandle ¬ NSFile.OpenChild[            directory: adobeDir, id: attributes.fileID,            controls: control, session: session];          RETURN[continue: FALSE]}};      --get name of system to be destroyed      ServicesError.SetCatching[on: FALSE];      SpecialNSFile.EnablePrivileges[session];      sysDir _ NSFile.OpenByReference[        reference: NSFile.GetReference[        file: NSExec.SystemDirectory[]], session: session];      dbName ¬ TextInput.GetText[        tty: NSExec.GetTTY[exec],        prompt: S["Name of system to delete"L], text: dbName,        maxLength: dbName.maxlength];      NSString.AppendToMesaString[systemName, dbName];      IF        (adobeDir ¬ OpenByName[          sysDir, S[AdobeServerOps.adobeFolder], session, exclusive])        = NSFile.nullHandle THEN {        PutIndentedString[tty, "No adobe directory!"L]; GOTO cleanup};      NSFile.List[        directory: adobeDir, proc: FindARSystem,        selections: DesiredSelections[], session: session];      IF arSysHandle = NSFile.nullHandle THEN {        PutIndentedString[tty, "No AR system by that name!"L];        NSFile.Close[adobeDir, session];        RETURN};      --ask if anything should be saved - maybe provide here to copy accels, etc. for the requestor to some other place of his choosing      confirm ¬ TextInput.GetYesNo[        tty: tty, prompt: S["Save/Backup anything relating to this AR System"L]];      <<there are:  DescriptionFile, DefaultUserFile, UpdaterBackingFile,    and all the Accelerator files w/in AcceleratorsDir.>>      IF confirm = yes THEN {        [hostAndPath, ] ¬ GetBackUpPath[exec, Heap.systemZone, session];        TTY.PutString[tty, "Backup path is set to: "L];        NSTTY.PutLine[tty, hostAndPath];        confirmBackupPath ¬ TextInput.GetYesNo[          tty: NSExec.GetTTY[exec], prompt: S["Confirm"L]];        IF confirmBackupPath = no THEN GOTO cleanup;	confirm ¬ TextInput.GetYesNo[          tty: tty, prompt: S["Save Description File"L]];        IF confirm = yes THEN {          [ok, msg] ¬ Backup.File[            hostAndPath: hostAndPath,            name: S[AdobeServerOps.descriptionFile],            file: fh ¬ OpenByName[            arSysHandle, S[AdobeServerOps.descriptionFile], session],            session: session, versionsToKeep: 2,            messageZone: Heap.systemZone, for: GetIdentity[exec]];          NSFile.Close[fh, session];          IF msg.length > 0 THEN NSTTY.PutLine[tty, msg]};	confirm ¬ TextInput.GetYesNo[          tty: tty, prompt: S["Save Default User File"L]];        IF confirm = yes THEN {          [ok, msg] ¬ Backup.File[            hostAndPath: hostAndPath,            name: S[AdobeServerOps.defaultUserFile],            file: fh ¬ OpenByName[            arSysHandle, S[AdobeServerOps.defaultUserFile], session],            session: session, versionsToKeep: 2,            messageZone: Heap.systemZone, for: GetIdentity[exec]];          NSFile.Close[fh, session];          IF msg.length > 0 THEN NSTTY.PutLine[tty, msg]};	confirm ¬ TextInput.GetYesNo[          tty: tty, prompt: S["Save Updater Backing File"L]];        IF confirm = yes THEN {          [ok, msg] ¬ Backup.File[            hostAndPath: hostAndPath,            name: S[AdobeServerOps.updaterBackingFile],            file: fh ¬ OpenByName[            arSysHandle, S[AdobeServerOps.updaterBackingFile],            session], session: session, versionsToKeep: 2,            messageZone: Heap.systemZone, for: GetIdentity[exec]];          NSFile.Close[fh, session];          IF msg.length > 0 THEN NSTTY.PutLine[tty, msg]};	confirm ¬ TextInput.GetYesNo[          tty: tty, prompt: S["Save Accelerator File"L]];        IF confirm = yes THEN {          accDir: NSFile.Handle ¬ OpenByName[            arSysHandle, S[AdobeServerOps.acceleratorsDir], session];          [ok, msg] ¬ Backup.File[            hostAndPath: hostAndPath,            name: S[AdobeServerOps.acceleratorsDir],            file: fh ¬ OpenByName[            arSysHandle, S[AdobeServerOps.acceleratorsDir], session],            session: session, versionsToKeep: 2,            messageZone: Heap.systemZone, for: GetIdentity[exec]];	  IF msg.length > 0 THEN NSTTY.PutLine[tty, msg];          NSFile.Close[fh, session];          NSFile.Close[accDir, session]}};      --confirm      confirm ¬ TextInput.GetYesNo[        tty: tty, prompt: S["Go ahead with Destroy"L]];      IF confirm = no THEN {        PutIndentedString[tty, "Destroy request canceled."L];        NSFile.Close[adobeDir, session];        RETURN};      confirm ¬ TextInput.GetYesNo[tty: tty, prompt: S["Are you sure"L]];      --Perform Destruction      IF confirm = yes THEN NSFile.Delete[arSysHandle, session]      ELSE {PutIndentedString[tty, "Delete request canceled."L]};      NSFile.Logoff[session];  -- Closes any files/dirs remaining open      END      EXITS        cleanup => {          NSString.FreeString[Heap.systemZone, dbName];          IF session # NSFile.nullSession THEN            NSFile.Logoff[session]}};    AdobeServerOps.CatchErrorsFromExec[destroy, exec]};       GetDefUserFile: PUBLIC NSExec.ExecProc = {    getUserFile: PROCEDURE = {      systemIndex: CARDINAL;      systemName: LONG STRING ¬ [50];      workDefUserFile, sysDefUserFile, workingDir:         NSFile.Handle ¬ NSFile.nullHandle;      userFileName: NSString.String ¬ NSString.MakeString[data.z, 100];      fileNameAttr: ARRAY [0..1) OF NSFile.Attribute;      BEGIN      ENABLE {        UNWIND => {	  IF workDefUserFile # NSFile.nullHandle THEN NSFile.Close[	    workDefUserFile, data.fileSession];	  IF sysDefUserFile # NSFile.nullHandle THEN NSFile.Close[	    sysDefUserFile, data.fileSession];	  IF workingDir # NSFile.nullHandle THEN NSFile.Close[	    workingDir, data.fileSession];	  NSString.FreeString[data.z, userFileName]}};	        systemIndex ¬ AdobeServerOps.GetDesiredSystem[exec];      IF systemIndex IN [0..data.systems.length) THEN {	NSString.AppendToMesaString[	  systemName, data.systems[systemIndex].name];	workingDir ¬ NSFile.OpenByReference[reference: NSFile.GetReference[	  file: NSExec.WorkingDirectory[]], session: data.fileSession];	FOR i: CARDINAL IN [0..systemName.length) DO	  IF systemName[i] = '  THEN {	    FOR j: CARDINAL IN [i..systemName.length - 1) DO	      systemName[j] ¬ systemName[j+1]; ENDLOOP;	    systemName.length ¬ systemName.length - 1}	  ENDLOOP;	      	userFileName ¬ NSString.AppendString[userFileName, S[systemName]];	userFileName ¬ NSString.AppendString[userFileName, S[".user"L]];	fileNameAttr ¬ [[name[userFileName]]];	sysDefUserFile ¬ NSFile.OpenByName[	  directory: data.systems[systemIndex].sysH, path:          S[AdobeServerOps.defaultUserFile], session: data.fileSession];	IF sysDefUserFile # NSFile.nullHandle THEN {	  workDefUserFile ¬ NSFile.Copy[	  file: sysDefUserFile,  destination: workingDir, 	  attributes: DESCRIPTOR[fileNameAttr], session: data.fileSession!	  NSFile.Error => {	    WITH error SELECT FROM	      insertion => {		SELECT problem FROM		  fileNotUnique => {		    userFileName ¬ NSString.AppendString[		      userFileName, S[		      " already exists on working directory."L]];		    NSExec.PutMessage[exec, userFileName];		    CONTINUE};		  ENDCASE};	      ENDCASE}];	  IF sysDefUserFile # NSFile.nullHandle THEN             NSFile.Close[sysDefUserFile, data.fileSession];	  IF workDefUserFile # NSFile.nullHandle THEN 	    NSFile.Close[workDefUserFile, data.fileSession]}	ELSE NSExec.PutMessage[exec, S["Default User file does not exist."L]];	NSFile.Close[workingDir, data.fileSession];	NSString.FreeString[data.z, userFileName]}    ELSE NSExec.PutMessage[exec, S["invalid number entered."L]];    END};    AdobeServerOps.CatchErrorsFromExec[getUserFile, exec];    };  --GetDefUserFile         PutDefaultUserFile: PUBLIC NSExec.ExecProc = {    userFileName: NSString.String ¬ NSString.MakeString[      Heap.systemZone, 50];    systemNameString: NSString.String ¬ NSString.MakeString[      Heap.systemZone, 100];    text: NSString.String ¬ NSString.MakeString[      Heap.systemZone, 50];    adobeSystemHandle, adobeFolderHandle, defaultUserFileHandle, userFH:       NSFile.Handle ¬ NSFile.nullHandle;    sysDir: NSFile.Handle ¬ NSExec.SystemDirectory[];    workingDir: NSFile.Handle ¬ NSExec.WorkingDirectory[];    --logged on user does not have access to list the Adobe systems     --in the Adobe folder    sessionHandle: NSFile.Session¬ NSExec.SystemFilingSession[];    select: NSFile.Selections;    enumAllFilesScope: NSFile.Scope ¬ [filter: [matches[[name[S["*"L]]]]]];    confirm: TextInput.YesOrNo ¬ TextInput.nilYesNo;    attrs: ARRAY [0..1) OF NSFile.Attribute;        putUserFile: PROCEDURE = {      BEGIN      ENABLE {        UNWIND => {	  IF adobeSystemHandle # NSFile.nullHandle THEN             NSFile.Close[adobeSystemHandle, sessionHandle];	  IF adobeFolderHandle # NSFile.nullHandle THEN             NSFile.Close[adobeFolderHandle, sessionHandle];	  IF defaultUserFileHandle # NSFile.nullHandle THEN             NSFile.Close[defaultUserFileHandle, sessionHandle];	  IF userFH # NSFile.nullHandle THEN             NSFile.Close[userFH, sessionHandle];	  NSString.FreeString[Heap.systemZone, userFileName];	  NSString.FreeString[Heap.systemZone, systemNameString];	  NSString.FreeString[Heap.systemZone, text]}};	       ListFile:NSFile.AttributesProc ={	filename: NSFile.String;	filename ¬ attributes.name;	NSExec.PutIndentedMessage[exec, filename]};            [userFileName, userFH] ¬ GetLocalFile[exec, workingDir, sessionHandle];      IF userFH = NSFile.nullHandle THEN RETURN;            --list adobe systems      adobeFolderHandle ¬ NSFile.OpenByName[	directory: sysDir, path: S["AdobeFolder"L], 	session: sessionHandle];      IF adobeFolderHandle # NSFile.nullHandle THEN {	NSExec.PutMessage[exec, S["Adobe Systems: "L]]}      ELSE {	NSExec.PutMessage[exec, S["AdobeFolder does not exist."L]]; RETURN};      select.interpreted[name] ¬ TRUE;      NSFile.List[	directory: adobeFolderHandle, proc: ListFile, selections: select, 	scope: enumAllFilesScope , session: sessionHandle];	      text ¬ TextInput.GetText[	tty: NSExec.GetTTY[exec], prompt: S["Adobe System"L], text: text,	maxLength: text.maxlength];      IF text.length > 0 THEN {	confirm ¬ TextInput.GetYesNo[	  tty: NSExec.GetTTY[exec], prompt: S["Confirm"L]];	IF confirm = yes THEN {	  systemNameString ¬ NSString.AppendString[	    systemNameString, S["AdobeFolder/"L]];	  systemNameString ¬ NSString.AppendString[	    to: systemNameString, from:text];	  adobeSystemHandle ¬ NSFile.OpenByName[	    directory: sysDir, path: systemNameString, session: sessionHandle!	    NSFile.Error => {	      WITH error SELECT FROM                access => {                  SELECT problem FROM                    fileNotFound =>  {                      NSExec.PutMessage[exec, 		        S["this system does not exist"L]];		      GOTO cleanup};              ENDCASE};          ENDCASE}];	  IF adobeSystemHandle # NSFile.nullHandle THEN  { 	    defaultUserFileHandle ¬ NSFile.OpenByName[	      directory: adobeSystemHandle, path: S["DefaultUser.file"L], 	      session: sessionHandle];	    IF defaultUserFileHandle # NSFile.nullHandle THEN	      NSFile.Delete[defaultUserFileHandle, sessionHandle];  	    attrs ¬ [[name[S["DefaultUser.file"L]]]];	    [defaultUserFileHandle] ¬ NSFile.Copy[	      file: userFH,  destination: adobeSystemHandle, 	      attributes: DESCRIPTOR[attrs], session: sessionHandle];	    NSExec.PutMessage[exec, S["Done."L]]};	  IF adobeSystemHandle # NSFile.nullHandle THEN             NSFile.Close[adobeSystemHandle, sessionHandle];	  IF adobeFolderHandle # NSFile.nullHandle THEN             NSFile.Close[adobeFolderHandle, sessionHandle];	  IF defaultUserFileHandle # NSFile.nullHandle THEN             NSFile.Close[defaultUserFileHandle, sessionHandle];	  IF userFH # NSFile.nullHandle THEN             NSFile.Close[userFH, sessionHandle];	  NSString.FreeString[Heap.systemZone, userFileName];	  NSString.FreeString[Heap.systemZone, systemNameString];	  NSString.FreeString[Heap.systemZone, text]}};      EXITS       cleanup => {        IF adobeSystemHandle # NSFile.nullHandle THEN 	  NSFile.Close[adobeSystemHandle, sessionHandle];	IF adobeFolderHandle # NSFile.nullHandle THEN 	  NSFile.Close[adobeFolderHandle, sessionHandle];	IF defaultUserFileHandle # NSFile.nullHandle THEN 	  NSFile.Close[defaultUserFileHandle, sessionHandle];	IF userFH # NSFile.nullHandle THEN 	  NSFile.Close[userFH, sessionHandle];	NSString.FreeString[Heap.systemZone, userFileName];	NSString.FreeString[Heap.systemZone, systemNameString];	NSString.FreeString[Heap.systemZone, text]};      END};    AdobeServerOps.CatchErrorsFromExec[putUserFile, exec];    };  --PutDefaultUserFile   RegisterSystem: PUBLIC NSExec.ExecProc = {    registerSys: PROCEDURE = {      ok: BOOLEAN ¬ TRUE;      dbName: NSString.String ¬ NSString.MakeString[        data.z, NSName.maxFullNameLength];      name: NSName.Name ¬ NIL;      confirm: TextInput.YesOrNo ¬ TextInput.nilYesNo;      BEGIN      ENABLE {        UNWIND => {          NSString.FreeString[data.z, dbName];          IF name # NIL THEN NSName.FreeName[data.z, name]};	NSName.Error => {	  NSExec.PutIndentedMessage[	    exec, S["Name not entered in proper format"L]];	  NSString.FreeString[data.z, dbName];          IF name # NIL THEN NSName.FreeName[data.z, name]}};      dbName ¬ TextInput.GetText[        tty: NSExec.GetTTY[exec], prompt: S["Enter Fully-qualified DataBase Name"L],        text: dbName, maxLength: dbName.maxlength];      IF dbName.length # 0 THEN {        name ¬ NSName.NameFromString[data.z, dbName];        dbName.length ¬ 0;        dbName ¬ NSString.AppendString[dbName, S["Registering "L]];        dbName ¬ NSString.AppendString[dbName, name.local];        dbName ¬ NSString.AppendString[dbName, S[":"L]];        dbName ¬ NSString.AppendString[dbName, name.domain];        dbName ¬ NSString.AppendString[dbName, S[":"L]];        dbName ¬ NSString.AppendString[dbName, name.org];        NSExec.PutMessage[exec, dbName];        confirm ¬ TextInput.GetYesNo[          tty: NSExec.GetTTY[exec], prompt: S["Confirm"L]];        IF confirm = yes THEN {          ok ¬ AccessCH.RegisterDatabase[            database: name, service: data.serviceName,            primaryPID: AccessCH.adobeSystemPID,            genericPIDs: AccessCH.adobeGenericPIDs,            secondaryPIDs: AccessCH.adobeSecondaryPIDs,            desc: NSString.nullString, execHandle: exec,            z: data.z];          IF ok THEN NSExec.PutMessage[exec, S["Done."L]]          ELSE            NSExec.PutMessage[              exec, S["RegisterDatabase not successful."L]]}}      ELSE NSExec.PutMessage[exec, S["No name was entered."L]];      NSString.FreeString[data.z, dbName];      NSName.FreeName[data.z, name];      END};    AdobeServerOps.CatchErrorsFromExec[registerSys, exec];    };  --RegisterSystem  RestoreARSystem: PUBLIC NSExec.ExecProc =    BEGIN    <<Service must be started for a restore to occur.  This means that      the Adobe folder is open and we have its handle. >>    tty: TTY.Handle ¬ NSExec.GetTTY[exec];    adobeFolderHandle, adobeSystemHandle, dirFH: NSFile.Handle ¬      NSFile.nullHandle;    systemName: LONG STRING ¬ [30];    hostAndDirName: LONG STRING ¬ [65];    ok: BOOLEAN;    msg: NSString.String;    dbName: NSName.Name ¬ NSName.MakeName[      data.z, NSName.maxOrgLength, NSName.maxDomainLength,      NSName.maxLocalLength];    fileAttrs: ARRAY [0..4) OF NSFile.Attribute;    dirfileAttrs: ARRAY [0..2) OF NSFile.Attribute;    backupVPN: NSFileName.VPNRecord;    confirm: TextInput.YesOrNo ¬ TextInput.nilYesNo;    restore: PROCEDURE = {      BEGIN      ENABLE {        UNWIND => {          IF adobeSystemHandle # NSFile.nullHandle THEN            NSFile.Close[adobeSystemHandle, data.fileSession];          IF dbName # NIL THEN NSName.FreeName[data.z, dbName]}};      ServicesError.SetCatching[on: FALSE];      dbName.local ¬ TextInput.GetText[        tty: NSExec.GetTTY[exec],        prompt: S["Name of AR System to restore"L],        text: dbName.local, maxLength: dbName.local.maxlength];      NSString.AppendToMesaString[systemName, dbName.local];            NSExec.PutIndentedMessage[exec, S["Restore From: "L]];      NSExec.PutIndentedMessage[        exec, S["  Enter location as follows: "L]];      NSExec.PutIndentedMessage[        exec, S[        "    (file service:domain:xerox)file drawer/file folder "L]];      PutIndentedString[tty, "Restore From: "L];      [] ¬ TTY.GetEditedString[tty, hostAndDirName, t];      TTY.PutCR[tty];      NSFileName.VPNFieldsFromString[        z: data.z, s: S[hostAndDirName], destination: @backupVPN !        NSFileName.Error => {	 NSExec.PutIndentedMessage[exec, S["Invalid location entered."L]]}];      dirfileAttrs ¬ [[service[backupVPN.service]], [	pathname[backupVPN.pathname]]];      dirFH ¬ NSFile.Open[	directory: dirFH, attributes: DESCRIPTOR[dirfileAttrs],	session: data.fileSession];      confirm ¬ TextInput.GetYesNo[        tty: tty, prompt: S["Confirm"L]];      IF confirm = yes THEN {	fileAttrs ¬ [	  [name[S[systemName]]], [isDirectory[TRUE]], [	  type[NSAssignedTypes.tDirectory]], [	  childrenUniquelyNamed[TRUE]]];	adobeFolderHandle ¬ data.adobeDir;	adobeSystemHandle ¬ NSFile.Create[	  directory: adobeFolderHandle,	  attributes: DESCRIPTOR[fileAttrs], session: data.fileSession !	  NSFile.Error => {	    WITH error SELECT FROM	      insertion => {		SELECT problem FROM		  fileNotUnique => {		    NSExec.PutMessage[		      exec, S["this system already exists"L]];		    GOTO cleanup};		  ENDCASE};	      ENDCASE}];  	confirm ¬ TextInput.GetYesNo[	  tty: tty, prompt: S["Restore System Description"L]];	IF confirm = yes THEN {	  [ok, msg] ¬ Backup.RecoverFile[	    hostAndPath: S[hostAndDirName],	    name: S[AdobeServerOps.descriptionFile],	    destination: adobeSystemHandle, session: data.fileSession,	    messageZone: Heap.systemZone, for: GetIdentity[exec]];	  IF ~ok THEN NSExec.PutMessage[exec, msg]};	confirm ¬ TextInput.GetYesNo[	  tty: tty, prompt: S["Restore Default User File"L]];	IF confirm = yes THEN {	  [ok, msg] ¬ Backup.RecoverFile[	    hostAndPath: S[hostAndDirName],	    name: S[AdobeServerOps.defaultUserFile],	    destination: adobeSystemHandle, session: data.fileSession,	    messageZone: Heap.systemZone, for: GetIdentity[exec]];	  IF ~ok THEN NSExec.PutMessage[exec, msg]};	confirm ¬ TextInput.GetYesNo[	  tty: tty, prompt: S["Restore Updater Backing File"L]];	IF confirm = yes THEN {	  [ok, msg] ¬ Backup.RecoverFile[	    hostAndPath: S[hostAndDirName],	    name: S[AdobeServerOps.updaterBackingFile],	    destination: adobeSystemHandle, session: data.fileSession,	    messageZone: Heap.systemZone, for: GetIdentity[exec]];	  IF ~ok THEN NSExec.PutMessage[exec, msg]};	confirm ¬ TextInput.GetYesNo[	  tty: tty, prompt: S["Restore Accelerator Files"L]];	IF confirm = yes THEN {	  [ok, msg] ¬ Backup.RecoverFile[	    hostAndPath: S[hostAndDirName],	    name: S[AdobeServerOps.acceleratorsDir],	    destination: adobeSystemHandle, session: data.fileSession,	    messageZone: Heap.systemZone, for: GetIdentity[exec]];	  IF ~ok THEN NSExec.PutMessage[exec, msg]}};      IF adobeSystemHandle # NSFile.nullHandle THEN        NSFile.Close[adobeSystemHandle, data.fileSession];      NSName.FreeName[data.z, dbName];      EXITS        cleanup => {	  IF adobeSystemHandle # NSFile.nullHandle THEN            NSFile.Close[adobeSystemHandle, data.fileSession];          NSName.FreeName[data.z, dbName];};      END};    AdobeServerOps.CatchErrorsFromExec[restore, exec];    END; << SetBackupPath: PUBLIC NSExec.ExecProc = {    setBackupInternal: PROCEDURE = {      systemIndex: CARDINAL;      session: NSFile.Session ¬ data.fileSession;      tty: TTY.Handle ¬ NSExec.GetTTY[exec];      fileAttrs: ARRAY [0..2) OF NSFile.Attribute;      filenameAttr: ARRAY [0..1) OF NSFile.Attribute;      pathname: LONG STRING ¬ [100];      dir: LONG STRING ¬ [100];      index: CARDINAL;      dirFH: NSFile.Handle ¬ NSFile.nullHandle;      -- key: UserProfile.EntryKey;      --nsString1: NSString.String ¬ S["Backup Path"L];      --nsString2: NSString.String ¬ S["Access List"L];        regentry: UserProfile.RegisterEntriesProc = {	  	register.string[	  entry: XString.FromNSString[S["Backup Path"]],	  default: XString.FromNSString[S["foobar"]],	  set: FALSE];	register.string[	  entry: XString.FromNSString[S["Access List"]],	  default: ,	  set: TRUE];        --XString.FromSTRING["Backup Path"L] and XString.FromSTRING["Access List"L] did not work??        };      IF AdobeServerOpsExtra.backupPath = NSString.nullString THEN        AdobeServerOpsExtra.backupPath ¬ NSString.MakeString[          data.z, 100]      ELSE AdobeServerOpsExtra.backupPath.length ¬ 0;      AdobeServerOpsExtra.backupPath.length ¬ 0;      systemIndex ¬ AdobeServerOpsExtra.GetDesiredSystem[exec];      IF systemIndex IN [0..data.systems.length) THEN {        AdobeServerOpsExtra.backupPath ¬ TextInput.GetText[          tty: tty, prompt: S["Backup Path"L],          text: AdobeServerOpsExtra.backupPath,          maxLength: AdobeServerOpsExtra.backupPath.maxlength];        NSFileName.VPNFieldsFromString[          z: data.z, s: AdobeServerOpsExtra.backupPath,          destination: @AdobeServerOpsExtra.backupVPN !          NSFileName.Error => {            NSExec.PutIndentedMessage[exec, S["Illegal syntax"L]]}];        fileAttrs ¬ [          [service[AdobeServerOpsExtra.backupVPN.service]], [          pathname[AdobeServerOpsExtra.backupVPN.pathname]]];        NSString.AppendToMesaString[          pathname, AdobeServerOpsExtra.backupVPN.pathname];        index ¬ 0;        dir.length ¬ 0;        WHILE pathname[index] # '/ AND index < pathname.length DO          String.AppendChar[dir, pathname[index]];          index ¬ index + 1;          ENDLOOP;        index ¬ index + 1;        fileAttrs ¬ [          [service[AdobeServerOpsExtra.backupVPN.service]], [          pathname[S[dir]]]];        dirFH ¬ NSFile.Open[          directory: dirFH, attributes: DESCRIPTOR[fileAttrs],          session: session !          NSFile.Error => {            WITH error SELECT FROM              access => {                IF problem = fileNotFound THEN                  NSExec.PutMessage[                    exec, S["File drawer does not exist"L]];                GOTO cleanup}              ENDCASE}];        WHILE index < pathname.length DO          dir.length ¬ 0;          WHILE pathname[index] # '/ AND index < pathname.length DO            String.AppendChar[dir, pathname[index]];            index ¬ index + 1;            ENDLOOP;          IF pathname[index] = '/ THEN index ¬ index + 1;          filenameAttr ¬ [[name[S[dir]]]];          dirFH ¬ NSFile.Open[            directory: dirFH, attributes: DESCRIPTOR[filenameAttr],            session: session !            NSFile.Error => {              WITH error SELECT FROM                access => {                  fileAttrs ¬ [[name[S[dir]]], [isDirectory[TRUE]]];                  IF problem = fileNotFound THEN                    dirFH ¬ NSFile.Create[                      directory: dirFH,                      attributes: DESCRIPTOR[fileAttrs],                      session: session !                      NSFile.Error => {                        NSExec.PutMessage[                          exec, S["directory cannot be created."L]];                        GOTO cleanup}];                  CONTINUE};                ENDCASE}];          ENDLOOP;        UserProfile.RegisterSection[	  name: XString.FromNSString[data.systems[systemIndex].name],	  numberOfEntries: 2,	  registerEntries: regentry,	  change: NIL];	key ¬ [          section: XString.FromNSString[data.systems[systemIndex].name],	  entry: XString.FromSTRING["Access List"L]];	UserProfile.SetStringValue[key:key,	  value: XString.FromSTRING["Sawai:OSBU North:Xerox"L],	  action: add];	UserProfile.SetStringValue[key:key,	  value: XString.FromSTRING["BrainBusters:OSBU North:Xerox"L],	  action: add];	  	UserProfile.UpdateCurrentProfileFile[]};      ELSE NSExec.PutMessage[exec, S["invalid number entered."L]];      TTY.PutString[tty, "Backup Path not implemented "L];      --EXITS cleanup => NULL      };    AdobeServerOps.CatchErrorsFromExec[setBackupInternal, exec];    NSExec.PutMessage[exec, S["Set BackupPath not implemented "L]];    };  --SetBackupPath>>  TryBackup: PUBLIC NSExec.ExecProc = {    adobeDir, arSysHandle: NSFile.Handle ¬ NSFile.nullHandle;    session: NSFile.Session ¬ data.fileSession;    systemIndex: CARDINAL;    FindARSystem: NSFile.AttributesProc = {      IF NSString.CompareStrings[        attributes.name, data.systems[systemIndex].name] = equal THEN        {        arSysHandle ¬ NSFile.OpenChild[          directory: adobeDir, id: attributes.fileID,          session: session];        RETURN[continue: FALSE]}};    tryBackup: PROCEDURE = {      confirm: TextInput.YesOrNo ¬ TextInput.nilYesNo;      fh: NSFile.Handle;      ok: BOOLEAN;      backupPath, msg: NSString.String;      tty: TTY.Handle ¬ NSExec.GetTTY[exec];      systemIndex ¬ AdobeServerOps.GetDesiredSystem[exec];      IF systemIndex IN [0..data.systems.length) THEN {        [backupPath, ] ¬ GetBackUpPath[exec, data.z, session];        TTY.PutString[tty, "Backup path is set to: "L];        NSTTY.PutLine[tty, backupPath];        confirm ¬ TextInput.GetYesNo[          tty: NSExec.GetTTY[exec], prompt: S["Confirm"L]];        IF confirm = yes THEN {          PutIndentedString[tty, "Storing System Description..."L];          [ok, msg] ¬ Backup.File[            hostAndPath: backupPath,            name: S[AdobeServerOps.descriptionFile],            file: data.systems[systemIndex].dfH, session: session,            versionsToKeep: 2, messageZone: Heap.systemZone,            for: GetIdentity[exec]];          IF ok THEN NSTTY.PutLine[tty, S["Done."L]]          ELSE {            NSTTY.PutLine[tty, S["Problems..."]];            NSTTY.PutLine[tty, msg]};          PutIndentedString[tty, "Storing .user file..."L];          [ok, msg] ¬ Backup.File[            hostAndPath: backupPath,            name: S[AdobeServerOps.defaultUserFile],            file: fh ¬ OpenByName[            data.systems[systemIndex].sysH, S[            AdobeServerOps.defaultUserFile], session],            session: session, versionsToKeep: 2,            messageZone: Heap.systemZone, for: GetIdentity[exec]];          NSFile.Close[fh, session];          IF ok THEN NSTTY.PutLine[tty, S["Done."L]]          ELSE {            NSTTY.PutLine[tty, S["Problems..."]];            NSTTY.PutLine[tty, msg]};          PutIndentedString[tty, "Storing ...Updater Backing..."L];          [ok, msg] ¬ Backup.File[            hostAndPath: backupPath,            name: S[AdobeServerOps.updaterBackingFile],            file: fh ¬ OpenByName[            data.systems[systemIndex].sysH, S[            AdobeServerOps.updaterBackingFile], session],            session: session, versionsToKeep: 2,            messageZone: Heap.systemZone, for: GetIdentity[exec]];          NSFile.Close[fh, session];          IF ok THEN NSTTY.PutLine[tty, S["Done."L]]          ELSE {            NSTTY.PutLine[tty, S["Problems..."]];            NSTTY.PutLine[tty, msg]};          PutIndentedString[tty, "Storing ...Accelerator Files..."L];          [ok, msg] ¬ Backup.File[            hostAndPath: backupPath,            name: S[AdobeServerOps.acceleratorsDir],            file: data.systems[systemIndex].adH, session: session,            versionsToKeep: 2, messageZone: Heap.systemZone,            for: GetIdentity[exec]];          IF ok THEN NSTTY.PutLine[tty, S["Done."L]]           ELSE {            NSTTY.PutLine[tty, S["Problems..."]];            NSTTY.PutLine[tty, msg]}}}};    AdobeServerOps.CatchErrorsFromExec[tryBackup, exec];    };  --TryBackUp  UnRegisterSystem: PUBLIC NSExec.ExecProc = {    unRegSys: PROCEDURE = {      ok: BOOLEAN ¬ TRUE;      userId: Auth.IdentityHandle;      dbName: NSString.String ¬ NSString.MakeString[data.z, 82];      name: NSName.Name ¬ NIL;      confirm: TextInput.YesOrNo ¬ TextInput.nilYesNo;      BEGIN      ENABLE {        UNWIND => {          NSString.FreeString[data.z, dbName];          IF name # NIL THEN NSName.FreeName[data.z, name]}};      dbName ¬ TextInput.GetText[        tty: NSExec.GetTTY[exec], prompt: S["Enter Fully-qualified DataBase Name"L],        text: dbName, maxLength: dbName.maxlength];      IF dbName.length # 0 THEN {        userId ¬ GetIdentity[exec];        name ¬ NSName.NameFromString[data.z, dbName];        dbName.length ¬ 0;        dbName ¬ NSString.AppendString[dbName, S["Unregistering "L]];        dbName ¬ NSString.AppendString[dbName, name.local];        dbName ¬ NSString.AppendString[dbName, S[":"L]];        dbName ¬ NSString.AppendString[dbName, name.domain];        dbName ¬ NSString.AppendString[dbName, S[":"L]];        dbName ¬ NSString.AppendString[dbName, name.org];        NSExec.PutMessage[exec, dbName];        confirm ¬ TextInput.GetYesNo[          tty: NSExec.GetTTY[exec], prompt: S["Confirm"L]];        IF confirm = yes THEN {          ok ¬ AccessCH.UnRegisterDatabase[            database: name, service: data.serviceName,            execHandle: exec, z: data.z];          IF ok THEN NSExec.PutMessage[exec, S["Done."L]]          ELSE            NSExec.PutMessage[              exec, S["Unsuccessful in unregistering database."L]]}}      ELSE NSExec.PutMessage[exec, S["No name was entered."L]];      NSName.FreeName[data.z, name];      NSString.FreeString[data.z, dbName];      END};    AdobeServerOps.CatchErrorsFromExec[unRegSys, exec]};  Answer: PROCEDURE [tty: TTY.Handle] RETURNS [yes: BOOLEAN] =    BEGIN    yesOrNo: LONG STRING ¬ [5];    t: PROCEDURE [c: CHARACTER] RETURNS [TTY.CharStatus] = {      IF c = Ascii.CR THEN RETURN[stop] ELSE RETURN[ok]};    [] ¬ TTY.GetEditedString[tty, yesOrNo, t];    TTY.PutCR[tty];    IF String.CompareStrings[yesOrNo, "Y"L] = 0 THEN RETURN[TRUE]    ELSE RETURN[FALSE];    END;  OpenByName: PUBLIC PROCEDURE [    directory: NSFile.Handle, path: NSString.String,    session: NSFile.Session ¬ NSFile.nullSession,    lock: NSFile.Lock _ share] RETURNS [fH: NSFile.Handle] =    BEGIN    fH _ NSFile.OpenByName[      directory: directory, path: path, controls: [lock: lock],      session: session !      NSFile.Error =>        WITH error SELECT FROM          access =>            IF problem = fileNotFound THEN {              fH _ NSFile.nullHandle; GOTO return}          ENDCASE];    EXITS return => NULL    END;      GetBackUpPath: PROCEDURE [exec: NSExec.Handle, z:UNCOUNTED ZONE, session: NSFile.Session] RETURNS [backupPath: NSString.String, backupVPN: NSFileName.VPNRecord] =     BEGIN    tty: TTY.Handle ¬ NSExec.GetTTY[exec];    fileAttrs: ARRAY [0..2) OF NSFile.Attribute;    filenameAttr: ARRAY [0..1) OF NSFile.Attribute;    pathname: LONG STRING ¬ [100];    dir: LONG STRING ¬ [100];    index: CARDINAL;    dirFH: NSFile.Handle ¬ NSFile.nullHandle;          backupPath ¬ NSString.MakeString[z, 100];    backupPath ¬ TextInput.GetText[      tty: tty, prompt: S["Backup Path"L], text: backupPath,       maxLength: backupPath.maxlength];    NSFileName.VPNFieldsFromString[      z: z, s: backupPath, destination: @backupVPN !      NSFileName.Error => {	NSExec.PutIndentedMessage[exec, S["Illegal syntax"L]]}];    fileAttrs ¬ [[service[backupVPN.service]], [      pathname[backupVPN.pathname]]];    NSString.AppendToMesaString[pathname, backupVPN.pathname];    index ¬ 0;    dir.length ¬ 0;    WHILE pathname[index] # '/ AND index < pathname.length DO      String.AppendChar[dir, pathname[index]];      index ¬ index + 1;      ENDLOOP;    index ¬ index + 1;    fileAttrs ¬ [[service[backupVPN.service]], [pathname[S[dir]]]];    dirFH ¬ NSFile.Open[      directory: dirFH, attributes: DESCRIPTOR[fileAttrs],      session: session];    WHILE index < pathname.length DO      dir.length ¬ 0;      WHILE pathname[index] # '/ AND index < pathname.length DO	String.AppendChar[dir, pathname[index]];	index ¬ index + 1;	ENDLOOP;      IF pathname[index] = '/ THEN index ¬ index + 1;      filenameAttr ¬ [[name[S[dir]]]];      dirFH ¬ NSFile.Open[	directory: dirFH, attributes: DESCRIPTOR[filenameAttr],	session: session !	NSFile.Error => {	  WITH error SELECT FROM	    access => {	      fileAttrs ¬ [[name[S[dir]]], [isDirectory[TRUE]]];	      IF problem = fileNotFound THEN		dirFH ¬ NSFile.Create[		  directory: dirFH,		  attributes: DESCRIPTOR[fileAttrs],		  session: session !		  NSFile.Error => {		    NSExec.PutMessage[		      exec, S["directory cannot be created."L]]; GOTO cleanup}];	      CONTINUE};	    ENDCASE}];      ENDLOOP;    EXITS cleanup => NULL;    END;          GetLocalFile: PROCEDURE [    exec: NSExec.Handle, workingDir: NSFile.Handle,    session: NSFile.Session]    RETURNS [file: NSString.String, userFH: NSFile.Handle] = {    userFile: NSString.String ¬ NSString.MakeString[Heap.systemZone, 100];    vpn: NSFileName.VPNRecord;    localFile: BOOLEAN ¬ FALSE;    attrs: ARRAY [0..1) OF NSFile.Attribute;    --fileAttrs: ARRAY [0..2) OF NSFile.Attribute;    --attrRec: NSFile.AttributesRecord;    --attrPtr: NSFile.Attributes;    controls: NSFile.Controls ¬ [lock: exclusive];    --selections: NSFile.Selections;    userSession: NSFile.Session ¬ NSFile.nullSession;    userFile ¬ TextInput.GetText[      tty: NSExec.GetTTY[exec], prompt: S["Enter user file"L],      text: userFile, maxLength: userFile.maxlength];    NSFileName.VPNFieldsFromString[      z: Heap.systemZone, s: userFile, destination: @vpn !      NSFileName.Error => {localFile ¬ TRUE; CONTINUE}];    IF vpn.service # NIL AND ~localFile THEN {      NSExec.PutMessage[exec, S["file must be local."L]];      userFH ¬ NSFile.nullHandle;      -- to retrieve remote file      <<fileAttrs ¬ [[service[vpn.service]], [pathname[vpn.pathname]]];      userSession ¬ NSFile.Logon[GetIdentity[exec]];      fH ¬ NSFile.Open[        attributes: DESCRIPTOR[fileAttrs], session: userSession];      selections.interpreted[name] ¬ TRUE;      attrPtr ¬ @attrRec;      NSFile.GetAttributes[        file: fH, selections: selections, attributes: attrPtr,        session: userSession];      attrs ¬ [[name[attrRec.name]]];      workingDir2 ¬ NSFile.OpenByReference[        reference: NSFile.GetReference[        file: workingDir], session: userSession];      userSessionFH ¬ NSFile.Copy[        fH, workingDir2, DESCRIPTOR[attrs], controls, userSession];      NSFile.Close[workingDir2, userSession];      NSFile.Close[userSessionFH, userSession];      userFH ¬ NSFile.Open[attributes: DESCRIPTOR[attrs],         directory: workingDir, session: session];      RETURN[attrRec.name, userFH]>>}    ELSE {      attrs ¬ [[name[userFile]]];      userFH ¬ NSFile.Open[        directory: workingDir, session: session,        attributes: DESCRIPTOR[attrs]];      RETURN[userFile, userFH]};    };  GetIdentity: PUBLIC PROCEDURE [exec: NSExec.Handle]    RETURNS [id: Auth.IdentityHandle] =    BEGIN    RETURN[NSExec.UserIdentity[exec]];  --maybe we want ServerIdentity    END;  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  t: PROCEDURE [c: CHARACTER] RETURNS [TTY.CharStatus] = {    IF c = Ascii.CR THEN RETURN[stop] ELSE RETURN[ok]};  PutIndentedString: PROCEDURE [tty: TTY.Handle, s: LONG STRING] =    BEGIN TTY.PutString[tty, "        "L]; TTY.PutString[tty, s]; END;  DesiredSelections: PROC    RETURNS [selections: NSFile.Selections _ []] = {    selections.interpreted[name] _ TRUE;    selections.interpreted[fileID] _ TRUE;    selections.interpreted[numberOfChildren] _ TRUE;    };  END..  -- RLC		 5-Aug-86 17:36:17 replace NSFileExtra with SpecialNSFile Services 10.0 conversion
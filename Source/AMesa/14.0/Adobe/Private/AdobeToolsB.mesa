-- File: AdobeToolsB.mesa - created by RSF. Last edit:-- JCS                   2-Mar-86 14:51:19-- RSF			11-Apr-86 10:09:33-- RLC			17-Jul-87 13:54:56-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved. DIRECTORY  AdobeCommon USING [    CatchErrors, DataHandle, DisableAdobeAborts, FindThisQL, GetData,     GetDataSW, GetNextAR, InitialSetStatus, PostMessage, PostNumber,    QLNameHints, SetStatus, StringArray, validRelations],  AdobeCommonInternal USING [    AllocateInstanceData, FixOrdering, InstanceDataHandle,    queryHeraldName, SetFieldDirty, SetReadOnlys, SetTheDefaults,    SetWindowName],  AdobeOps USING [    ARSystemHandle, ARNumber, EnumeratedSequence, FieldItemObject,    FieldList, FieldType, nilARNumber, nilEnum, nilPossibilities,    nullDependsOnIndex, QLHandle, QLObject, QueryList, QueryListBody,    SetOfARs, SetOfARsObject, ToolType, z],  AdobeServer USING [    FieldItemQueryValue, FieldItemValue, LookupARs, ReadLastARNumber,    Relation],  AdobeToolContext USING [    EnumError, FindPossibilities, GetEnumValueFromUC,    GetValueFromEnumString, UserContext],  Ascii USING [CR, NUL, SP, TAB],  Date USING [Packed, StringToPacked, Unintelligible],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, Display, FindItem, FreeHintsProcType, ItemError, ItemHandle,    ItemObject, line0, MenuProcType, nextLine, ProcType,    SetModifyNotificationProc, StringItem],  Heap USING [systemZone],  MsgSW USING [Clear],  Process USING [Detach, GetCurrent],  String USING [    AppendCharAndGrow, AppendString, AppendStringAndGrow,    CopyToNewString, EmptyString, Equivalent, Equal, InvalidNumber,    Length, MakeString, StringBoundsFault, StringToLongNumber],  System USING [GreenwichMeanTime],  TajoMisc USING [toolDriverRunning],  Token USING [    FilterProcType, FreeTokenString, GetCharProcType, Handle,    MaybeQuoted, nonQuote, Object, QuoteProcType, StringToHandle],  Tool USING [MakeFormSW],  UserInput USING [UserAbort],  Window USING [Handle];AdobeToolsB: PROGRAM  IMPORTS    AdobeCommon, AdobeCommonInternal, AdobeOps, AdobeServer,    AdobeToolContext, Date, FormSW, Heap, MsgSW, Process,    String, TajoMisc, Token, Tool, UserInput  EXPORTS AdobeCommon, AdobeCommonInternal =  BEGIN  EnumeratedFIH: TYPE = LONG POINTER TO enumerated    AdobeOps.FieldItemObject;  backStr: LONG STRING ¬ NIL;  --for NilFormProc  --globals for query  queryPos: CARDINAL = 0;  clearFormPos: CARDINAL = 1;  showElemPos: CARDINAL = 2;  resetQLPos: CARDINAL = 3;  qyBkgdPos: CARDINAL = 4;  qlNamePos: CARDINAL = 5;  nQueryParams: CARDINAL = 6;  --types for query  ParseError: SIGNAL [errType: ParseErrorType] = CODE;  --make more specific later  ParseErrorType: TYPE = {    badNumber, badDate, notValidEnumerated, strayQuote,    badQuerySyntax};  LSHandle: TYPE = LONG POINTER TO LSObject;  LSObject: TYPE = MACHINE DEPENDENT RECORD [    object: Token.Object, s: LONG STRING, i: CARDINAL];  TokenType: TYPE = {op, string, andor};  QueryItemHandle: TYPE = LONG POINTER TO QueryItemSeq;  QueryItemSeq: TYPE = RECORD [    fLIndex: CARDINAL, seq: SEQUENCE len: CARDINAL OF DistilledToken];  DistilledToken: TYPE = RECORD [    SELECT type: TokenType FROM    op => [op: AdobeServer.Relation],    string => [s: LONG STRING],    andor => [andOr: {and, or}]    ENDCASE];  ParseStateType: TYPE = {start, op, andor, string, end};  ProcessedQueryHandle: TYPE = LONG POINTER TO ProcessedQuery;  ProcessedQuery: TYPE = RECORD [    seq: SEQUENCE len: CARDINAL OF QueryItemHandle];  FieldItemHandle: TYPE = LONG POINTER TO FieldItemSeq;  FieldItemSeq: TYPE = RECORD [    seq: SEQUENCE len: CARDINAL OF AdobeServer.FieldItemQueryValue];  MakeQueryFormSW: FormSW.ClientItemsProcType =    BEGIN    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    arSH: AdobeOps.ARSystemHandle ¬ data.context.arSH;    tool: AdobeOps.ToolType ¬ data.tool;    IF data.context = NIL THEN RETURN;  --no systems in User.cm    freeDesc ¬ TRUE;    items ¬ FormSW.AllocateItemDescriptor[      arSH.formSWOrderArray[tool].length, data.heap];    WITH instanceData SELECT FROM      query => {        queryStrings ¬ data.heap.NEW[          AdobeCommon .StringArray[arSH.fieldList.len]];        FOR j: CARDINAL IN [0..arSH.fieldList.len) DO          queryStrings[j] ¬ NIL; ENDLOOP;        FOR i: CARDINAL IN [0..arSH.formSWOrderArray[tool].length) DO          WITH f: arSH.fieldList[arSH.formSWOrderArray[tool][i]]          SELECT FROM            string =>              items[i] ¬ FormSW.StringItem[                invisible: TRUE,                string: @queryStrings[arSH.formSWOrderArray[tool][i]],                inHeap: TRUE, z: data.heap];            --right now, queries on unbounded strings are not allowed.  If they become allowable later, this will cease to be an invisible item.             ENDCASE =>              items[i] ¬ FormSW.StringItem[                tag: f.name, place: f.defaultInfo[tool].place,                string: @queryStrings[arSH.formSWOrderArray[tool][i]],                inHeap: TRUE, boxWidth: f.defaultInfo[tool].width,                z: data.heap, menuProc: HintMenuProc];          ENDLOOP};      ENDCASE => ERROR;  --shouldn't be possible    END;  NilFormProc: FormSW.ClientItemsProcType = {    freeDesc ¬ TRUE;    items ¬ FormSW.AllocateItemDescriptor[1];    items[0] ¬ FormSW.StringItem[invisible: TRUE, string: @backStr]};  HintMenuProc: FormSW.MenuProcType =    BEGIN    --use AdobeOps.z heap so that the FreeHintsProc knows what heap to free from    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬       data.instanceData;    arSH: AdobeOps.ARSystemHandle ¬ data.context.arSH;    fL: AdobeOps.FieldList ¬ data.context.arSH.fieldList;    flIndex: CARDINAL ¬ arSH.formSWOrderArray[data.tool][index];    enumValue, i: CARDINAL;    enumStrings: AdobeOps.EnumeratedSequence ¬ NIL;    relStrings, hintSeq: LONG POINTER TO AdobeCommon.StringArray;    WITH fItem: fL[flIndex] SELECT FROM      arId => hintSeq ¬ GetValidRelations[arId, AdobeOps.z];      dateTime => hintSeq ¬ GetValidRelations[dateTime, AdobeOps.z];      numeric => hintSeq ¬ GetValidRelations[numeric, AdobeOps.z];      fixedLengthString =>        hintSeq ¬ GetValidRelations[fixedLengthString, AdobeOps.z];      enumerated => {        IF fItem.field # AdobeOps.nullDependsOnIndex THEN          WITH inst: instanceData SELECT FROM            query => {  --must get the right value in the depended on              -- field item so that GetPossibilities will work right                enumValue ¬ AdobeToolContext.GetValueFromEnumString[                inst.queryStrings[fItem.field], data.context,                fItem.field !                AdobeToolContext.EnumError => {                  enumValue ¬ AdobeOps.nilEnum; CONTINUE}];              WITH disp: data.context[fItem.field] SELECT FROM                displayedField =>                  WITH body: disp.editableField SELECT FROM                    enumerated => body.value ¬ enumValue                    ENDCASE;                ENDCASE};            ENDCASE;        enumStrings ¬ GetPossibilities[@fItem, data.context];        relStrings ¬ GetValidRelations[enumerated, AdobeOps.z];        hintSeq ¬ AdobeOps.z.NEW[          AdobeCommon          .StringArray[enumStrings.length + relStrings.length]];        FOR i IN [0..enumStrings.length) DO          hintSeq[i] ¬ String.CopyToNewString[            enumStrings[i].string, AdobeOps.z];          ENDLOOP;        FOR i IN [0..relStrings.length) DO          hintSeq[i + enumStrings.length] ¬ relStrings[i]; ENDLOOP;        AdobeOps.z.FREE[@relStrings]};      ENDCASE;    hints ¬ DESCRIPTOR[hintSeq];    replace ¬ FALSE;    freeHintsProc ¬ FreeHintStrings;    END;  FreeHintStrings: PUBLIC FormSW.FreeHintsProcType =    BEGIN    base: LONG POINTER;    IF BASE[hints] # NIL THEN {      --subtract size of the sequence's length field so base now points to the beginning of the sequence as created by NEW.  When we took DESCRIPTOR of the sequence, the base pointer is set to point to the objects in the sequence which follow the length field.       base ¬ BASE[hints] - SIZE[CARDINAL];      FOR i: CARDINAL IN [0..hints.LENGTH) DO        AdobeOps.z.FREE[@hints[i]]; ENDLOOP;      AdobeOps.z.FREE[@base]};    END;  GetValidRelations: PROCEDURE [    type: AdobeOps.FieldType, z: UNCOUNTED ZONE]    RETURNS [relStrings: LONG POINTER TO AdobeCommon.StringArray] =    BEGIN    numValid, index: CARDINAL ¬ 0;    op: AdobeServer.Relation;    FOR op IN AdobeServer.Relation DO      IF AdobeCommon.validRelations[type][op] THEN        numValid ¬ numValid + 1;      ENDLOOP;    IF type = enumerated THEN numValid ¬ numValid + 2  --OR, AND #    ELSE numValid ¬ numValid + 3;  --OR, AND, NIL    relStrings ¬ z.NEW[AdobeCommon .StringArray[numValid]];    FOR op IN AdobeServer.Relation DO      IF AdobeCommon.validRelations[type][op] THEN {        relStrings[index] ¬ String.CopyToNewString[          SELECT op FROM            equal => " = "L,            notEqual => " # "L,            lessThan => " < "L,            lessThanOrEqual => " <= "L,            greaterThan => " > "L,            greaterThanOrEqual => " >= "L,            in => " HAS "L,            notIn => " ~HAS "L,            ENDCASE => ""L, z];        index ¬ index + 1};      ENDLOOP;    relStrings[index] ¬ String.CopyToNewString[" OR "L, z];    IF type = enumerated THEN      relStrings[index ¬ index + 1] ¬ String.CopyToNewString[        " AND # "L, z]    ELSE {      relStrings[index ¬ index + 1] ¬ String.CopyToNewString[        " AND "L, z];      relStrings[index ¬ index + 1] ¬ String.CopyToNewString[        " NIL "L, z]};    END;  GetPossibilities: PROCEDURE [    item: EnumeratedFIH, context: AdobeToolContext.UserContext]    RETURNS [possibilities: AdobeOps.EnumeratedSequence] =    BEGIN    IF item.field = AdobeOps.nullDependsOnIndex THEN      possibilities ¬ item.possibilities[0].enumRecs    ELSE {      possibilities ¬ AdobeToolContext.FindPossibilities[        AdobeToolContext.GetEnumValueFromUC[context, item.field],        item.possibilities !        AdobeToolContext.EnumError => {          possibilities ¬ AdobeOps.nilPossibilities; CONTINUE}]};    END;  CountARs:  PUBLIC PROCEDURE [set: AdobeOps.SetOfARs]    RETURNS [n: LONG CARDINAL] =     BEGIN    n ¬ 0;    FOR i: CARDINAL IN [0..set.len) DO      n ¬ n + set[i].runLength; ENDLOOP;    END;  --Query routines    CreateQuerySW: PUBLIC PROCEDURE [    w: Window.Handle, makeCmdSW: BOOLEAN ¬ TRUE]    RETURNS [initialMsg: LONG STRING ¬ NIL] =    BEGIN    data: AdobeCommon.DataHandle ¬ AdobeCommon.GetData[w];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    IF makeCmdSW THEN {  --there is no instanceData hanging around        instanceData ¬ AdobeCommonInternal.AllocateInstanceData[data];      instanceData.cmdSW ¬ Tool.MakeFormSW[        window: w, formProc: QueryCmdSW, zone: data.heap]};    --following IF is checking for whether a valid initialSystem    --was given in the User.cm    IF data.knownSystems # NIL AND data.context # NIL THEN      instanceData.formSW ¬ Tool.MakeFormSW[        window: w, formProc: MakeQueryFormSW, zone: data.heap !        FormSW.ItemError =>          IF code = illegalCoordinate THEN {            initialMsg ¬ AdobeCommonInternal.FixOrdering[              data, MakeQueryFormSW, w, index];            CONTINUE}]    ELSE      instanceData.formSW ¬ Tool.MakeFormSW[        window: w, formProc: NilFormProc];    AdobeCommon.DisableAdobeAborts[w];    IF data.context # NIL THEN {      --add > 0 for arId if no other default given for it      FOR i: CARDINAL IN [0..data.context.arSH.fieldList.len) DO        WITH fLItem: data.context.arSH.fieldList[i] SELECT FROM          arId =>            WITH instanceData SELECT FROM              query => {                IF fLItem.defaultInfo[data.tool].default = NIL                  OR fLItem.defaultInfo[data.tool].default.length = 0                  THEN                  fLItem.defaultInfo[data.tool].default ¬                    String.CopyToNewString["> 0"L, AdobeOps.z];                --must be from AdobeOps.z so later FreeDesc will work ok                EXIT};              ENDCASE;          ENDCASE;        ENDLOOP;      AdobeCommonInternal.SetTheDefaults[data, FALSE];      AdobeCommonInternal.SetReadOnlys[data];      FormSW.SetModifyNotificationProc[        instanceData.formSW, AdobeCommonInternal.SetFieldDirty]};    AdobeCommonInternal.SetWindowName[      w,      IF data.knownSystems # NIL AND data.context # NIL AND       data.system # LAST[CARDINAL] THEN      data.knownSystems[data.system] ELSE NIL,      AdobeCommonInternal.queryHeraldName];    END;  QueryCmdSW: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    WITH queryToolData: instanceData SELECT FROM      query => {        items ¬ AllocateItemDescriptor[nQueryParams, windowData.heap];        freeDesc ¬ TRUE;        items[queryPos] ¬ CommandItem[          tag: "Query"L, place: [0, line0], proc: QueryCommandProc,          z: windowData.heap];        items[clearFormPos] ¬ CommandItem[          tag: "Clear Form"L, proc: QueryCommandProc,          z: windowData.heap];        items[showElemPos] ¬ CommandItem[          tag: "Show Elements"L, proc: QueryCommandProc,          z: windowData.heap];        items[resetQLPos] ¬ CommandItem[          tag: "ResetQL"L, proc: QueryCommandProc,          z: windowData.heap];        items[qyBkgdPos] ¬ BooleanItem[          tag: "Use background"L, switch: @queryToolData.background,          z: windowData.heap];        items[qlNamePos] ¬ StringItem[          tag: "Query List Name"L, string: @queryToolData.qlName,          inHeap: TRUE, place: [0, nextLine],          menuProc: AdobeCommon.QLNameHints, z: windowData.heap]};      ENDCASE => ERROR;  --shouldn't happen    END;  QueryCommandProc: FormSW.ProcType =    BEGIN    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      windowData.instanceData;    MsgSW.Clear[windowData.msgSW];    IF windowData.system = LAST[CARDINAL] OR windowData.context = NIL OR windowData.knownSystems = NIL OR windowData.knownSystems.next = 0 THEN {      AdobeCommon.PostMessage[        windowData.msgSW, TRUE, "No available systems"L];      RETURN};    IF windowData.isBusy THEN      AdobeCommon.PostMessage[        windowData.msgSW, TRUE,        "Adobe system is Busy.  Please try again later. "L]    ELSE {      windowData.isBusy ¬ TRUE;      IF instanceData.background AND ~TajoMisc.toolDriverRunning THEN        Process.Detach[	  windowData.processID ¬ FORK AdobeCommon.CatchErrors[	    sw, item, index, windowData, ChooseQueryCmd]]      ELSE {        windowData.processID ¬ Process.GetCurrent[];        AdobeCommon.CatchErrors[	  sw, item, index, windowData, ChooseQueryCmd]}};    END;  ChooseQueryCmd: FormSW.ProcType =    BEGIN    windowData: AdobeCommon.DataHandle ¬ AdobeCommon.GetDataSW[sw];    BEGIN ENABLE UNWIND => windowData.isBusy ¬ FALSE;    SELECT index FROM      queryPos => QueryProc[windowData];      clearFormPos => ClearQueryForm[windowData];      showElemPos => ShowElementsProc[windowData];      resetQLPos => ResetQLProc[windowData];      ENDCASE => ERROR;    windowData.isBusy ¬ FALSE;    windowData.processID ¬ NIL;    END;    END;  ClearQueryForm: PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    WITH instanceData SELECT FROM      query => {        AdobeCommon.PostMessage[data.msgSW, FALSE, "Clearing ... "L];	SetFormSWFieldInvisible[data, instanceData.formSW, TRUE, , TRUE];        FOR i: CARDINAL IN [0..data.context.arSH.fieldList.len) DO          IF queryStrings[i] # NIL THEN {            queryStrings[i].length ¬ 0;  --saves everyone from needing to reallocate            data.context[i].dirty ¬ FALSE};          ENDLOOP;        AdobeCommonInternal.SetTheDefaults[data, FALSE];	SetFormSWFieldInvisible[data, instanceData.formSW, FALSE, , TRUE];        FormSW.Display[formSW]};      ENDCASE;    AdobeCommon.PostMessage[data.msgSW, TRUE, "Done."L];    END;  ShowElementsProc: PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    ql: AdobeOps.QueryList;    ar: AdobeOps.ARNumber ¬ AdobeOps.nilARNumber;    status: AdobeCommon.SetStatus ¬ AdobeCommon.InitialSetStatus;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    WITH instanceData SELECT FROM      query => {        IF (ql ¬ AdobeCommon.FindThisQL[qlName, data.context.arSH]) =          NIL THEN {          AdobeCommon.PostMessage[            data.msgSW, TRUE, "Empty QueryList!"L];          RETURN};        AdobeCommon.PostMessage[NIL, FALSE, "Query Elements for "L];        AdobeCommon.PostMessage[NIL, FALSE, ql.name];	AdobeCommon.PostMessage[NIL, FALSE, ": "L];        [ar, status] ¬ AdobeCommon.GetNextAR[ql.list, status];        WHILE ar # AdobeOps.nilARNumber DO	  AdobeCommon.PostNumber[NIL, FALSE, ar];          [ar, status] ¬ AdobeCommon.GetNextAR[ql.list, status];          IF ar = AdobeOps.nilARNumber THEN EXIT;	  AdobeCommon.PostMessage[NIL, FALSE, ", "L];          ENDLOOP;        AdobeCommon.PostMessage[NIL, TRUE, "."L];        AdobeCommon.PostMessage[          data.msgSW, TRUE,          " Query List displayed in system default window."L]};      ENDCASE => ERROR;    END;  ResetQLProc: PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    qlH: AdobeOps.QLHandle;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    WITH instanceData SELECT FROM      query => {        IF String.Equivalent[qlName, "SysQL"L] OR qlName = NIL          OR qlName.length = 0 THEN {	  IF data.context.arSH.sysQL # NIL AND 	    data.context.arSH.sysQL.list # NIL THEN {	    AdobeOps.z.FREE[@data.context.arSH.sysQL.list];	    data.context.arSH.sysQL.list ¬ NIL}}        ELSE {          qlH ¬ data.context.arSH.otherQLs;          WHILE qlH # NIL DO            IF qlH.qL # NIL AND String.Equal[qlName, qlH.qL.name] THEN {	      IF qlH.qL.list # NIL THEN AdobeOps.z.FREE[@qlH.qL.list];	      qlH.qL.list ¬ NIL;	      RETURN};            qlH ¬ qlH.next;            ENDLOOP}};      ENDCASE => ERROR;    END;  QueryProc: PROCEDURE [data: AdobeCommon.DataHandle] =    BEGIN    ql: AdobeOps.QueryList;    usingSysQL: BOOLEAN;    qH: ProcessedQueryHandle;    ok: BOOLEAN;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    AdobeCommonInternal.SetTheDefaults[data, TRUE];    WITH queryData: instanceData SELECT FROM      query => {        usingSysQL ¬	  (queryData.qlName = NIL OR queryData.qlName.length = 0	    OR String.Equal[queryData.qlName, "SysQL"]);        [ok, qH] ¬ ParseQueryGiven[data];        IF UserInput.UserAbort[data.window] THEN ERROR ABORTED;        IF ok THEN {          AdobeCommon.PostMessage[            data.msgSW, FALSE, "Querying into "L];          AdobeCommon.PostMessage[            data.msgSW, FALSE,	    IF usingSysQL THEN "SysQL"L ELSE queryData.qlName];	  AdobeCommon.PostMessage[            data.msgSW, FALSE, " ... "L]};        IF ~ok THEN RETURN;        ql ¬ PerformQuery[qH, data ! ParseError => GOTO quit];        IF UserInput.UserAbort[data.window] THEN {          FreeQueryList[@ql]; ERROR ABORTED};        IF ql = NIL THEN {	  ql ¬ AdobeOps.z.NEW[AdobeOps.QueryListBody];	  ql.name ¬ NIL; ql.list ¬ NIL;          AdobeCommon.PostMessage[data.msgSW, FALSE, "0 matches... "L];          }        ELSE {          AdobeCommon.PostNumber[            data.msgSW, FALSE, CountARs[ql.list]];          AdobeCommon.PostMessage[data.msgSW, FALSE, " matches... "L]};        IF usingSysQL THEN          ql.name ¬ String.CopyToNewString["SysQL"L, AdobeOps.z]        ELSE          ql.name ¬ String.CopyToNewString[            queryData.qlName, AdobeOps.z];        IF usingSysQL THEN {          FreeQueryList[@data.context.arSH.sysQL];          data.context.arSH.sysQL ¬ ql}        ELSE AddToOtherQLList[data.context.arSH, ql];        AdobeCommon.PostMessage[data.msgSW, TRUE, "Done."L]};      ENDCASE => ERROR;  --shouldn't happen      EXITS quit => NULL;    END;  ParseQueryGiven: PROCEDURE [data: AdobeCommon.DataHandle]    RETURNS [goodParse: BOOLEAN, processedQH: ProcessedQueryHandle] =    BEGIN    queryCount: CARDINAL ¬ 0;    instanceData: AdobeCommonInternal.InstanceDataHandle ¬      data.instanceData;    goodParse ¬ TRUE;    WITH instanceData SELECT FROM      query => {        --find out how many items are being queried on         FOR i: CARDINAL IN [0..queryStrings.length) DO          IF ~String.EmptyString[queryStrings[i]]THEN            queryCount ¬ queryCount + 1;          ENDLOOP;        processedQH ¬ data.heap.NEW[ProcessedQuery [queryCount]];        queryCount ¬ 0;        FOR i: CARDINAL IN [0..queryStrings.length) DO          IF ~String.EmptyString[queryStrings[i]] THEN {	    [goodParse, processedQH[queryCount]] ¬ ParseQueryItem[	      queryStrings[i], data.context.arSH.fieldList[i],	      data.heap];	    IF goodParse THEN {	      processedQH[queryCount].fLIndex ¬ i;	      queryCount ¬ queryCount + 1}	    ELSE {	      AdobeCommon.PostMessage[		data.msgSW, FALSE, "Query for "L];	      AdobeCommon.PostMessage[		data.msgSW, FALSE, data.context.arSH.fieldList[		i].name];	      AdobeCommon.PostMessage[		data.msgSW, TRUE, " is illegal"L];	      FOR i: CARDINAL IN [0..queryCount) DO		data.heap.FREE[@processedQH[i]]; ENDLOOP;	      data.heap.FREE[@processedQH];	      EXIT}};          ENDLOOP};      ENDCASE;    END;  ParseQueryItem: PROCEDURE [    s: LONG STRING, fItem: AdobeOps.FieldItemObject,    z: UNCOUNTED ZONE]    RETURNS [ok: BOOLEAN, queryTokens: QueryItemHandle] =    BEGIN    collected: LONG STRING;    last, current: ParseStateType;    tempQueryTokens: QueryItemHandle ¬ z.NEW[QueryItemSeq [10]];    qtIndex: CARDINAL ¬ 0;    escaped, lastWasString: BOOLEAN ¬ FALSE;    MyGetChar: Token.GetCharProcType = {      lsh: LSHandle ¬ LOOPHOLE[h];      IF lsh.i < String.Length[lsh.s] THEN {        c ¬ lsh.s[lsh.i];        lsh.i ¬ lsh.i + 1;        IF c = '' THEN          IF lsh.i >= String.Length[lsh.s] THEN            ERROR ParseError[strayQuote]          ELSE {c ¬ lsh.s[lsh.i]; lsh.i ¬ lsh.i + 1; escaped ¬ TRUE}}      ELSE c ¬ Ascii.NUL};    MyUngetChar: PROCEDURE [h: Token.Handle] = {      lsh: LSHandle ¬ LOOPHOLE[h]; lsh.i ¬ lsh.i - 1};    DoubleQuote: Token.QuoteProcType = {      IF c = '" THEN RETURN['"] ELSE RETURN[Token.nonQuote]};    NonQueryChars: Token.FilterProcType = {      IF escaped THEN {  --char preceded by apostrophe; don't check it        escaped ¬ FALSE;  --reset         RETURN[TRUE]};      RETURN[        SELECT c FROM          Ascii.SP, Ascii.TAB, Ascii.CR, '=, '>, '<, '#, '" => FALSE,          ENDCASE => TRUE]};    AnalyzeTokenAndAdd: PROCEDURE =      BEGIN      SELECT TRUE FROM        String.Equal["HAS"L, collected] => {          IF lastWasString THEN qtIndex ¬ qtIndex + 1;          tempQueryTokens[qtIndex] ¬ [op[in]];          lastWasString ¬ FALSE;          qtIndex ¬ qtIndex + 1};        String.Equal["~HAS"L, collected] => {          IF lastWasString THEN qtIndex ¬ qtIndex + 1;          tempQueryTokens[qtIndex] ¬ [op[notIn]];          lastWasString ¬ FALSE;          qtIndex ¬ qtIndex + 1};        String.Equal["AND"L, collected] => {          IF lastWasString THEN qtIndex ¬ qtIndex + 1;          tempQueryTokens[qtIndex] ¬ [andor[and]];          lastWasString ¬ FALSE;          qtIndex ¬ qtIndex + 1};        String.Equal["OR"L, collected] => {          IF lastWasString THEN qtIndex ¬ qtIndex + 1;          tempQueryTokens[qtIndex] ¬ [andor[or]];          lastWasString ¬ FALSE;          qtIndex ¬ qtIndex + 1};        ENDCASE => {          IF lastWasString THEN            WITH tempQueryTokens[qtIndex] SELECT FROM              string => {                String.AppendCharAndGrow[@s, Ascii.SP, z];                String.AppendStringAndGrow[@s, collected, z, 10]};              ENDCASE          ELSE            tempQueryTokens[qtIndex] ¬ [              string[String.CopyToNewString[collected, z]]];          lastWasString ¬ TRUE};      END;    nextChar: CHARACTER ¬ Ascii.NUL;    sH: Token.Handle ¬ Token.StringToHandle[s];    sH.getChar ¬ MyGetChar;    collected ¬ Token.MaybeQuoted[      h: sH, data: NIL, filter: NonQueryChars, isQuote: DoubleQuote];    DO      IF collected # NIL THEN {        --compare with tempQueryTokens.len-2 because if collected is a 	--string operator, qtIndex is incremented and then the assignment 	--is done.        IF qtIndex >= tempQueryTokens.len - 2 THEN          GrowQueryItemSeq[@tempQueryTokens, z];        AnalyzeTokenAndAdd[];        [] ¬ Token.FreeTokenString[collected]}      ELSE {        IF qtIndex >= tempQueryTokens.len THEN          GrowQueryItemSeq[@tempQueryTokens, z];        IF lastWasString THEN qtIndex ¬ qtIndex + 1;        SELECT sH.break FROM          '< => {            nextChar ¬ sH.getChar[sH];            IF nextChar = '= THEN              tempQueryTokens[qtIndex] ¬ [op[lessThanOrEqual]]            ELSE {              MyUngetChar[sH];              tempQueryTokens[qtIndex] ¬ [op[lessThan]]};            qtIndex ¬ qtIndex + 1};          '> => {            nextChar ¬ sH.getChar[sH];            IF nextChar = '= THEN              tempQueryTokens[qtIndex] ¬ [op[greaterThanOrEqual]]            ELSE {              MyUngetChar[sH];              tempQueryTokens[qtIndex] ¬ [op[greaterThan]]};            qtIndex ¬ qtIndex + 1};          '" => MyUngetChar[sH];  --put back so MaybeQuoted finds it          '= => {            tempQueryTokens[qtIndex] ¬ [op[equal]];            qtIndex ¬ qtIndex + 1};          '# => {            tempQueryTokens[qtIndex] ¬ [op[notEqual]];            qtIndex ¬ qtIndex + 1};          Ascii.NUL => {[] ¬ Token.FreeTokenString[collected]; EXIT};          --all done with this string          ENDCASE};      collected ¬ Token.MaybeQuoted[        h: sH, data: NIL, filter: NonQueryChars,        isQuote: DoubleQuote];      ENDLOOP;    ok ¬ TRUE;    --need to do something special with enumerated items    last ¬ start;    IF qtIndex = 0 THEN ok ¬ FALSE;    FOR i: CARDINAL IN [0..qtIndex) DO      WITH tempQueryTokens[i] SELECT FROM        op => {          current ¬ op;          IF ~ValidOperator[fItem, op] THEN {ok ¬ FALSE; EXIT}};        string => current ¬ string;        andor => current ¬ andor;        ENDCASE;      ParseNextToken[        last, current, fItem ! ParseError => {ok ¬ FALSE; EXIT}];      last ¬ current;      ENDLOOP;    ParseNextToken[      last, end, fItem ! ParseError => {ok ¬ FALSE; CONTINUE}];    IF ok THEN {  --trim to size needed       queryTokens ¬ z.NEW[QueryItemSeq [qtIndex]];      FOR i: CARDINAL IN [0..qtIndex) DO        queryTokens[i] ¬ tempQueryTokens[i]; ENDLOOP}    ELSE queryTokens ¬ NIL;    z.FREE[@tempQueryTokens];    END;  ParseNextToken: PROCEDURE [    last, this: ParseStateType, item: AdobeOps.FieldItemObject] =    BEGIN    SELECT last FROM      start =>        SELECT this FROM          andor => ERROR ParseError[badQuerySyntax];          ENDCASE;      op =>        SELECT this FROM          op, andor, end => ERROR ParseError[badQuerySyntax];          ENDCASE;      andor =>        SELECT this FROM          andor, end => ERROR ParseError[badQuerySyntax];          ENDCASE;      string =>        SELECT this FROM          op => ERROR ParseError[badQuerySyntax];          ENDCASE;      ENDCASE;    END;  <<Parsing table used: last|  this ->     V 	op		andor		string			endstart	yes		no		yes(implied = before)	yes---=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-op	no		no		yes			no-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=--=-=-=-=-=-=-==-=-==-=-=-=andor	yes		no		yes(implied = before)	no-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=string	no		yes		yes			yes-=-==-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=>>  ValidOperator: PROCEDURE [    item: AdobeOps.FieldItemObject, op: AdobeServer.Relation]    RETURNS [valid: BOOLEAN] =    BEGIN    WITH item SELECT FROM      arId => RETURN[AdobeCommon.validRelations[arId][op]];      dateTime => RETURN[AdobeCommon.validRelations[dateTime][op]];      numeric => RETURN[AdobeCommon.validRelations[numeric][op]];      fixedLengthString =>        RETURN[AdobeCommon.validRelations[fixedLengthString][op]];      enumerated =>        RETURN[AdobeCommon.validRelations[enumerated][op]];      string => NULL;  --not currently allowed      ENDCASE;    END;  GrowQueryItemSeq: PROCEDURE [    h: LONG POINTER TO QueryItemHandle, z: UNCOUNTED ZONE] =    BEGIN    temp: QueryItemHandle ¬ z.NEW[QueryItemSeq [h.len + 5]];    FOR i: CARDINAL IN [0..h.len) DO temp[i] ¬ h[i]; ENDLOOP;    z.FREE[h];    h^ ¬ temp;    END;  PerformQuery: PROCEDURE [    qH: ProcessedQueryHandle, data: AdobeCommon.DataHandle]    RETURNS [qL: AdobeOps.QueryList] =    BEGIN    qHIndex: CARDINAL ¬ 0;    queryItem: QueryItemHandle;    queryValue: FieldItemHandle;    numberOfEnum, itemIndex: CARDINAL;    boolOp: {and, or, new};    fieldSet, set: AdobeOps.SetOfARs ¬ NIL;    BEGIN ENABLE UNWIND =>  {IF qL # NIL THEN {      AdobeOps.z.FREE[@qL.list];      AdobeOps.z.FREE[@qL]};      IF queryValue # NIL THEN AdobeOps.z.FREE[@queryValue]};    qL ¬ AdobeOps.z.NEW[AdobeOps.QueryListBody ¬ [NIL, NIL]];    qL.list ¬ AdobeOps.z.NEW[AdobeOps.SetOfARsObject[1]];    queryValue ¬ AdobeOps.z.NEW[FieldItemSeq[3]];    qL.list[0] ¬ [      startValue: 1,      runLength: AdobeServer.ReadLastARNumber[      server: data.context.arSH.service,      system: data.knownSystems.system[data.system]]];  --initial    FOR qHIndex IN [0..qH.len) DO      queryItem ¬ qH[qHIndex];      itemIndex ¬ 0;      boolOp ¬ new;      DO  --make queries for this field        IF UserInput.UserAbort[data.window] THEN {          qL ¬ NIL; ERROR ABORTED}; --leaks!        WITH token: queryItem[itemIndex] SELECT FROM          op => {            queryValue[0].relationalOp ¬ token.op;            itemIndex ¬ itemIndex + 1};          string => queryValue[0].relationalOp ¬ equal;          ENDCASE;	numberOfEnum ¬ 0;        WITH queryItem[itemIndex] SELECT FROM          string =>            numberOfEnum ¬ MakeFieldItemValue[              s, data.context.arSH.fieldList[queryItem.fLIndex], @queryValue ! 	      ParseError => SELECT errType FROM	        badNumber => {		  AdobeCommon.PostMessage[		    data.msgSW, FALSE, "Invalid Number in "L];		  AdobeCommon.PostMessage[		    data.msgSW, TRUE,	    data.context.arSH.fieldList[queryItem.fLIndex].name]};		badDate => {		  AdobeCommon.PostMessage[		    data.msgSW, FALSE, "Invalid Date in "L];		  AdobeCommon.PostMessage[		    data.msgSW, TRUE,	    data.context.arSH.fieldList[queryItem.fLIndex].name]};		ENDCASE => {		  AdobeCommon.PostMessage[		    data.msgSW, FALSE, "Unknown problem with "L];		  AdobeCommon.PostMessage[		    data.msgSW, TRUE,	    data.context.arSH.fieldList[queryItem.fLIndex].name]}];          ENDCASE;        itemIndex ¬ itemIndex + 1;	IF numberOfEnum > 0 THEN set ¬ GetEnumeratedSet[data, qL.list, queryItem.fLIndex, numberOfEnum, queryValue]	ELSE         set ¬ AdobeServer.LookupARs[          data.context.arSH.service, data.knownSystems.system[data.system],	  data.context.arSH.version,          data.context.arSH.fieldList[queryItem.fLIndex].name,          queryValue[0], qL.list];        SELECT boolOp FROM          new => fieldSet ¬ set;          and => fieldSet ¬ AndSets[fieldSet, set];          or => fieldSet ¬ OrSets[fieldSet, set];          ENDCASE;        IF itemIndex = queryItem.len THEN EXIT;        WITH queryItem[itemIndex] SELECT FROM          andor =>            boolOp ¬ SELECT andOr FROM and => and, ENDCASE => or;  --has to be if not and          ENDCASE;        itemIndex ¬ itemIndex + 1;        ENDLOOP;      --for now, we're using implicit AND's between fields. Need different scheme if we allow choice of AND/OR between fields.      qL.list ¬ AndSets[qL.list, fieldSet];      IF qL.list = NIL THEN  --no AR's fit criteria        RETURN[NIL];      ENDLOOP;    AdobeOps.z.FREE[@queryValue];    --qL.list ¬ fieldSet;    END;    END;      GetEnumeratedSet: PROCEDURE[data: AdobeCommon.DataHandle, list: AdobeOps.SetOfARs, flIndex, numberOfEnum: CARDINAL, fieldItem: FieldItemHandle] RETURNS [fieldSet: AdobeOps.SetOfARs] =    BEGIN    set: AdobeOps.SetOfARs ¬ NIL;    FOR i: CARDINAL IN [0..numberOfEnum) DO      set ¬ AdobeServer.LookupARs[	data.context.arSH.service, data.knownSystems.system[data.system],	data.context.arSH.version,	data.context.arSH.fieldList[flIndex].name,	fieldItem[i], list];      IF i = 0 THEN fieldSet ¬ set      ELSE {        IF fieldItem[0].relationalOp = equal THEN	  fieldSet ¬ OrSets[fieldSet, set]	ELSE IF fieldItem[0].relationalOp = notEqual THEN	  fieldSet ¬ AndSets[fieldSet, set]};      ENDLOOP;    END;  MakeFieldItemValue: PROCEDURE [    s: LONG STRING, fLItem: AdobeOps.FieldItemObject, f: LONG POINTER TO FieldItemHandle]    RETURNS [numberOfEnum: CARDINAL ¬ 0] =    BEGIN    ENABLE Date.Unintelligible => {};  --do something here    --want to add code to recognize special strings    fIndex: CARDINAL ¬ 0;    IF String.Equivalent[s, "NIL"L] THEN  --want empties      WITH fLItem SELECT FROM        arId => f[fIndex].value ¬ [arId[AdobeOps.nilARNumber]];        dateTime => f[fIndex].value ¬ [dateTime[LOOPHOLE[LONG[0], Date.Packed]]];        numeric => f[fIndex].value ¬ [numeric[LONG[0]]];        fixedLengthString => f[fIndex].value ¬ [fixedLengthString[NIL, maxLength]];        enumerated => f[fIndex].value ¬ [enumerated[AdobeOps.nilEnum]];        ENDCASE    ELSE      WITH fLItem SELECT FROM        arId =>          f[fIndex].value ¬ [arId[String.StringToLongNumber[s !	     String.InvalidNumber => ParseError[badNumber]]]];        dateTime => f[fIndex].value ¬ [dateTime[ConvertDate[s]]];        numeric =>          f[fIndex].value ¬ [numeric[String.StringToLongNumber[s !	     String.InvalidNumber => ParseError[badNumber]]]];        fixedLengthString => f[fIndex].value ¬ [fixedLengthString[s, maxLength]];        enumerated =>          numberOfEnum ¬ ObtainEnumeratedValue[s, fLItem, f];        ENDCASE;    END;  ConvertDate: PROCEDURE [s: LONG STRING]    RETURNS [dt: System.GreenwichMeanTime] =    BEGIN    ENABLE      Date.Unintelligible => {        temp: LONG STRING ¬ String.MakeString[Heap.systemZone, 18];        String.AppendString[temp, s];        String.AppendString[temp, " 00:00:00"L !	  String.StringBoundsFault => {	    Heap.systemZone.FREE[@temp]; GOTO badDate}];        dt ¬ Date.StringToPacked[          temp !          Date.Unintelligible => {            Heap.systemZone.FREE[@temp]; GOTO badDate}].dt;        GOTO ok};    dt ¬ Date.StringToPacked[s].dt;    EXITS badDate => ERROR ParseError[badDate]; ok => NULL;  --return dt    END;  ObtainEnumeratedValue: PROCEDURE [    s: LONG STRING, item: AdobeOps.FieldItemObject, fieldSeq: LONG POINTER TO FieldItemHandle]    RETURNS [numberOfEnum: CARDINAL ¬ 0] =    BEGIN    temp, tempFieldSeq: FieldItemHandle;    WITH item SELECT FROM      enumerated => {        FOR i: CARDINAL IN [0..possibilities.len) DO          FOR j: CARDINAL IN [0..possibilities[i].enumRecs.length) DO            IF String.Equal[s, possibilities[i].enumRecs[j].string]              THEN {	        --if necessary, grow fieldSeq by 10		IF numberOfEnum >= fieldSeq.len THEN {		  tempFieldSeq ¬ AdobeOps.z.NEW[FieldItemSeq[fieldSeq.len + 10]];		  FOR k: CARDINAL IN [0..numberOfEnum) DO		    tempFieldSeq[k].value ¬ fieldSeq[k].value;		    tempFieldSeq[k].relationalOp ¬ fieldSeq[k].relationalOp;		    ENDLOOP;		  temp ¬ fieldSeq­;		  fieldSeq­ ¬ tempFieldSeq;		  AdobeOps.z.FREE[@temp]};	        fieldSeq[numberOfEnum].value ¬ 	          [enumerated[possibilities[i].enumRecs[j].value]];		fieldSeq[numberOfEnum].relationalOp ¬ fieldSeq[0].relationalOp;		numberOfEnum ¬ numberOfEnum + 1};            ENDLOOP;          ENDLOOP;        IF numberOfEnum = 0 THEN ERROR ParseError[notValidEnumerated]};      ENDCASE;    END;  AndSets: PUBLIC PROCEDURE [set1, set2: AdobeOps.SetOfARs]    RETURNS [resultSet: AdobeOps.SetOfARs] =    BEGIN    --assume that ARs given are in numeric order    ar1, ar2: AdobeOps.ARNumber;    set1Status, set2Status: AdobeCommon.SetStatus ¬      AdobeCommon.InitialSetStatus;    resultState: CARDINAL ¬ 0;    tempSet: AdobeOps.SetOfARs;    IF set1 = NIL THEN {      IF set2 # NIL THEN AdobeOps.z.FREE[@set2]; RETURN[NIL]}    ELSE IF set2 = NIL THEN {AdobeOps.z.FREE[@set1]; RETURN[NIL]};    tempSet ¬ AdobeOps.z.NEW[      AdobeOps .SetOfARsObject[MAX[set1.len, set2.len]]];    [ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status];    [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];    --initialize temp    FOR i: CARDINAL IN [0..tempSet.len) DO      tempSet[i] ¬ [0, 0]; ENDLOOP;    --For AND, when one set is exhausted, we've got all that are    -- common to both so can just exit knowing we're done    WHILE set1Status.setIndex < set1.len      AND set2Status.setIndex < set2.len DO      SELECT TRUE FROM        ar1 = ar2 => {          resultState ¬ AddToSet[ar1, @tempSet, resultState];          [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];          [ar1, set1Status] ¬ AdobeCommon.GetNextAR[            set1, set1Status]};        ar1 > ar2 =>          [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];        ar1 < ar2 =>          [ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status];        ENDCASE;      ENDLOOP;    IF resultState = 0 AND tempSet[0].startValue = 0 THEN {  --empty set      AdobeOps.z.FREE[@tempSet];      AdobeOps.z.FREE[@set1];      AdobeOps.z.FREE[@set2];      RETURN[NIL]};    --prune to just fit    IF resultState + 1 = MAX[set1.len, set2.len] THEN {      AdobeOps.z.FREE[@set1];      AdobeOps.z.FREE[@set2];      RETURN[tempSet]}    ELSE {      resultSet ¬ AdobeOps.z.NEW[        AdobeOps .SetOfARsObject[resultState + 1]];      FOR i: CARDINAL IN [0..resultSet.len) DO        resultSet[i] ¬ tempSet[i]; ENDLOOP;      AdobeOps.z.FREE[@tempSet];      AdobeOps.z.FREE[@set1];      AdobeOps.z.FREE[@set2]};    END;  OrSets: PUBLIC PROCEDURE [set1, set2: AdobeOps.SetOfARs]    RETURNS [resultSet: AdobeOps.SetOfARs] =    BEGIN    --assume that ARs given are in numeric order    ar1, ar2: AdobeOps.ARNumber;    set1Status, set2Status: AdobeCommon.SetStatus ¬ [0, 0];    resultState: CARDINAL ¬ 0;    tempSet: AdobeOps.SetOfARs;    IF set1 = NIL THEN RETURN[set2];    IF set2 = NIL THEN RETURN[set1];    tempSet ¬ AdobeOps.z.NEW[      AdobeOps .SetOfARsObject[set1.len + set2.len]];    ar1 ¬ set1[0].startValue;    ar2 ¬ set2[0].startValue;    --initialize temp    FOR i: CARDINAL IN [0..tempSet.len) DO      tempSet[i] ¬ [0, 0]; ENDLOOP;    --For OR, when one set is exhausted, we've got to append what     -- remains of the unexhausted set to the result.    WHILE set1Status.setIndex < set1.len      AND set2Status.setIndex < set2.len DO      SELECT TRUE FROM        ar1 = ar2 => {  --add only once          resultState ¬ AddToSet[ar1, @tempSet, resultState];          [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];          [ar1, set1Status] ¬ AdobeCommon.GetNextAR[            set1, set1Status]};        ar1 > ar2 => {          resultState ¬ AddToSet[ar2, @tempSet, resultState];          [ar2, set2Status] ¬ AdobeCommon.GetNextAR[            set2, set2Status]};        ar1 < ar2 => {          resultState ¬ AddToSet[ar1, @tempSet, resultState];          [ar1, set1Status] ¬ AdobeCommon.GetNextAR[            set1, set1Status]};        ENDCASE;      ENDLOOP;    IF set1Status.setIndex < set1.len THEN  --add rest of set1      WHILE set1Status.setIndex < set1.len DO        resultState ¬ AddToSet[ar1, @tempSet, resultState];        [ar1, set1Status] ¬ AdobeCommon.GetNextAR[set1, set1Status];        ENDLOOP    ELSE  --add rest of set2      WHILE set2Status.setIndex < set2.len DO        resultState ¬ AddToSet[ar2, @tempSet, resultState];        [ar2, set2Status] ¬ AdobeCommon.GetNextAR[set2, set2Status];        ENDLOOP;    IF resultState + 1 = (set1.len + set2.len) THEN {      AdobeOps.z.FREE[@set1];      AdobeOps.z.FREE[@set2];      RETURN[tempSet]}    ELSE {      resultSet ¬ AdobeOps.z.NEW[        AdobeOps .SetOfARsObject[resultState + 1]];      FOR i: CARDINAL IN [0..resultSet.len) DO        resultSet[i] ¬ tempSet[i]; ENDLOOP;      AdobeOps.z.FREE[@tempSet];      AdobeOps.z.FREE[@set1];      AdobeOps.z.FREE[@set2]};    END;  AddToSet: PUBLIC PROCEDURE [    arNum: AdobeOps.ARNumber, set: LONG POINTER TO AdobeOps.SetOfARs,    lastRef: CARDINAL] RETURNS [thisRef: CARDINAL] =    BEGIN    thisRef ¬ lastRef;    IF set[lastRef].startValue = 0 THEN set[lastRef] ¬ [arNum, 1]    ELSE      IF (set[lastRef].startValue + set[lastRef].runLength) = arNum        THEN set[lastRef].runLength ¬ set[lastRef].runLength + 1      ELSE {        thisRef ¬ thisRef + 1;        IF thisRef >= set.len THEN GrowSet[set];        set[thisRef].startValue ¬ arNum;        set[thisRef].runLength ¬ 1};    END;  GrowSet: PUBLIC PROCEDURE [    oldSet: LONG POINTER TO AdobeOps.SetOfARs] =    BEGIN    newSet: AdobeOps.SetOfARs ¬ AdobeOps.z.NEW[      AdobeOps .SetOfARsObject[oldSet.len + 50]];    FOR i: CARDINAL IN [0..oldSet.len) DO      newSet[i] ¬ oldSet[i]; ENDLOOP;    AdobeOps.z.FREE[oldSet];    oldSet^ ¬ newSet;    END;  FreeQueryList: PROCEDURE [ql: LONG POINTER TO AdobeOps.QueryList] =    BEGIN    IF ql­ = NIL THEN RETURN;    IF ql.name # NIL THEN AdobeOps.z.FREE[@ql.name];    IF ql.list # NIL THEN AdobeOps.z.FREE[@ql.list];    AdobeOps.z.FREE[ql];    END;  AddToOtherQLList: PUBLIC PROCEDURE [    arSH: AdobeOps.ARSystemHandle, ql: AdobeOps.QueryList] =    BEGIN    qlH: LONG POINTER TO AdobeOps.QLHandle ¬ @arSH.otherQLs;    DO      SELECT TRUE FROM        qlH^ = NIL => {          qlH^ ¬ AdobeOps.z.NEW[AdobeOps.QLObject ¬ [NIL, NIL]];          qlH.qL ¬ ql;          EXIT};        String.Equal[qlH.qL.name, ql.name] => {          FreeQueryList[@qlH.qL]; qlH.qL ¬ ql; EXIT};        ENDCASE;      qlH ¬ @qlH.next;      ENDLOOP;    END;  << NotDoneYet: PROCEDURE [windowData: AdobeCommon.DataHandle] =    BEGIN    AdobeCommon.PostMessage[windowData.msgSW, TRUE, "Not Done Yet. "L];    END;>>  SetFormSWFieldInvisible: PROCEDURE [    data: AdobeCommon.DataHandle, wH: Window.Handle, invisible: BOOLEAN,    index: CARDINAL ¬ 0, all: BOOLEAN ¬ FALSE] =    BEGIN    inst: AdobeCommonInternal.InstanceDataHandle ¬ data.instanceData;    formItem: FormSW.ItemHandle;    IF all THEN {      FOR i: CARDINAL IN         [0..data.context.arSH.formSWOrderArray[data.tool].length) DO	formItem ¬ FormSW.FindItem[inst.formSW, i];	formItem.flags.invisible ¬ invisible;	ENDLOOP}    ELSE {      formItem ¬ FormSW.FindItem[inst.formSW, index];      formItem.flags.invisible ¬ invisible};    END;  END. . .17-Jul-87 13:54:56 - rlc - Use String.StringToLongNumber rather than LONG[String.StringToNumber]. Good Grief CB!
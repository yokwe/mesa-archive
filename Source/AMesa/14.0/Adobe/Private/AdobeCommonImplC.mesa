-- Copyright (C) 1982, 1985  by Xerox Corporation. All rights reserved. -- File: AdobeCommonImplC.mesa - last edit by:-- MXF     , 	27-Dec-82 15:59:00-- RSF      ,	 3-Apr-85 17:05:30-- JCS  ,	31-Jan-85 21:13:14DIRECTORY  AdobeCommon USING [    AddSystemToKnownSystems, DataHandle, AllocateKnownSystems,    LocateSystemInKnownSystems, SystemsHandle],  AdobeCommonInternal USING [SystemNotFound],  AdobeOps USING [ToolType],  CmFile USING [    Close, Error, FindSection, Handle, NextValue, TableError,    UserDotCmOpen],  Heap USING [systemZone],  String USING [CopyToNewString],  StringLookUp USING [InTable, noMatch],  Token USING [    AlphaNumeric, Brackets, FilterProcType, FreeTokenString,    FreeStringHandle, Handle, Item, MaybeQuoted, StringToHandle];AdobeCommonImplC: PROGRAM  IMPORTS    AdobeCommon, AdobeCommonInternal, CmFile, Heap, String,    StringLookUp, Token  EXPORTS AdobeCommonInternal =  BEGIN  ProcessUserDotCM: PUBLIC PROCEDURE [    toolData: AdobeCommon.DataHandle] =    BEGIN    CMOption: TYPE = MACHINE DEPENDENT{      firstTool(0), knownSystems(1), firstSystem(2),      noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = CMOption [firstTool..firstSystem];    cmOptionTable: ARRAY DefinedOption OF LONG STRING ¬ [      firstTool: "InitialTool"L, knownSystems: "KnownSystems"L,      firstSystem: "InitialSystem"L];    cmIndex: CMOption;    NextValue: PROCEDURE [      h: CmFile.Handle,      table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]      RETURNS [index: CMOption] = LOOPHOLE[CmFile.NextValue];    systemName: LONG STRING ¬ NIL;    cmFile: CmFile.Handle ¬ CmFile.UserDotCmOpen[      ! CmFile.Error => IF code = fileNotFound THEN GOTO return];    IF CmFile.FindSection[cmFile, "Adobe"L] THEN      BEGIN      DO        SELECT        (cmIndex ¬ NextValue[          h: cmFile, table: DESCRIPTOR[cmOptionTable] !          CmFile.TableError => RESUME ]) FROM          noMatch => EXIT;          firstTool => toolData.tool ¬ GetToolName[cmFile];          knownSystems =>            toolData.knownSystems ¬ GetKnownSystems[              cmFile, toolData.heap];          firstSystem => systemName ¬ GetInitialSystem[cmFile];          ENDCASE;        ENDLOOP;      IF systemName # NIL THEN {	toolData.system ¬ AdobeCommon.LocateSystemInKnownSystems[	  systemName, toolData.knownSystems !	  AdobeCommonInternal.SystemNotFound => {	    AdobeCommon.AddSystemToKnownSystems[	      system, @toolData.knownSystems, toolData.heap];	    RETRY}];	Heap.systemZone.FREE[@systemName]}      ELSE toolData.system ¬ LAST[CARDINAL]; --no initial system given      END;    [] ¬ CmFile.Close[cmFile];    EXITS return => NULL;    END;  GetInitialSystem: PROCEDURE [cmH: CmFile.Handle]    RETURNS [system: LONG STRING] =    BEGIN    temp: LONG STRING ¬ NIL;    system ¬ String.CopyToNewString[      temp ¬ Token.MaybeQuoted[h: cmH, data: NIL], Heap.systemZone];    temp ¬ Token.FreeTokenString[temp];    RETURN[system];    END;  GetToolName: PROCEDURE [cmH: CmFile.Handle]    RETURNS [tool: AdobeOps.ToolType] =    BEGIN    toolTable: ARRAY AdobeOps.ToolType OF LONG STRING ¬ [      edit: "edit"L, submit: "submit"L, report: "report"L,      query: "query"L, sort: "sort"L, queryList: "queryList"];    toolIndex: CARDINAL ¬ StringLookUp.noMatch;    value: LONG STRING = Token.Item[cmH];    LookUp: PROCEDURE [      value: LONG STRING,      table: LONG DESCRIPTOR FOR ARRAY AdobeOps.ToolType OF LONG        STRING, caseFold: BOOLEAN ¬ TRUE,      noAbbreviation: BOOLEAN ¬ FALSE] RETURNS [index: CARDINAL] =      LOOPHOLE[StringLookUp.InTable];    SELECT toolIndex ¬ LookUp[value, DESCRIPTOR[toolTable]] FROM      StringLookUp.noMatch => NULL;      ENDCASE => tool ¬ VAL[toolIndex];    [] ¬ Token.FreeTokenString[value];    END;  GetKnownSystems: PROCEDURE [cmH: CmFile.Handle, z: UNCOUNTED ZONE]    RETURNS [knownSystems: AdobeCommon.SystemsHandle] =    BEGIN    MustBeBracketed: Token.FilterProcType = {RETURN[FALSE]};    ksString: LONG STRING ¬ Token.MaybeQuoted[      h: cmH, data: NIL, filter: MustBeBracketed,      isQuote: Token.Brackets];    sH: Token.Handle ¬ Token.StringToHandle[ksString];    system: LONG STRING ¬ NIL;    knownSystems ¬ AdobeCommon.AllocateKnownSystems[NIL, z];    WHILE      (system ¬ Token.MaybeQuoted[        h: sH, data: NIL, filter: Token.AlphaNumeric]) # NIL DO      IF knownSystems.next = knownSystems.maxLength THEN        knownSystems ¬ AdobeCommon.AllocateKnownSystems[          knownSystems, z];      knownSystems[knownSystems.next] ¬ String.CopyToNewString[        system, z];      knownSystems.next ¬ knownSystems.next + 1;      system ¬ Token.FreeTokenString[system];      ENDLOOP;    sH ¬ Token.FreeStringHandle[sH];    ksString ¬ Token.FreeTokenString[ksString];    END;  END...
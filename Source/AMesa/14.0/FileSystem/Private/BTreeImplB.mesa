-- File: BTreeImplB.mesa - last edit:-- KAM                 17-Apr-85 11:08:46-- PXK                 1-Oct-81 14:26:46-- LGR                 1-Nov-83 15:10:52-- WDE                 4-Aug-83 15:21:02-- Copyright (C) 1981, 1983, 1984, 1985 by Xerox Corporation. All rights reserved. DIRECTORY  BTree USING [    defaultValueSize, maxNameLength, ReadOnly, Tree, TreeObject, Value, ValueSize,    VolumeNotOpen, ValueTooSmall],  BTreeInternal USING [    bTreePage, CheckVolumeAccess, CopyValue, debug, emptySize, EntryHandle,    EntryName, EntryPointer, EntryPointerPointer, EntrySize, EntryValue,    FirstEntry, FirstFreeEntry, firstPagePointer, FlushGNCache, heap,    InsertInNode, InternalFind,    LastEntry, maxTreeSize, MoveLongString, NextEntry,    nilPagePointer, Overhead, PagePointerFromEntryHandle, PageHandle,    PagePointer, SnapShot, Successor, treeIncrement, TreeObject, ValuePointer],  ByteBlt USING [ByteBlt],  Environment USING [bytesPerPage, PageCount, wordsPerPage],  File USING [File, GetSize, nullFile, SetSize],  Inline USING [<<LongCOPY, LongDivMod,>> LowHalf],  MFile USING [Error, Handle, SetLength],--  MUsage USING [bTreeDebug],  Space USING [    Allocate, Deallocate, ForceOut, Interval, Map, MapAt,     nullInterval, Unmap, UnmapAt, Usage, Window],  SpecialBTree USING [Error, Unmapped],  SpecialMFile USING [GetCapaWithAccess],  Volume USING [GetStatus];BTreeImplB: MONITOR LOCKS tree USING tree: Tree  IMPORTS    BTree, BTreeInternal, ByteBlt, File, Inline, MFile, Space, SpecialBTree,    SpecialMFile, Volume  EXPORTS BTree, BTreeInternal, SpecialBTree =  BEGIN  TreeObject: PUBLIC TYPE = BTreeInternal.TreeObject;  Tree: TYPE = LONG POINTER TO TreeObject;  bTreePage: CARDINAL = BTreeInternal.bTreePage;  maxTreeSize: CARDINAL = BTreeInternal.maxTreeSize;  -- (disk pages)  emptySize: CARDINAL = BTreeInternal.emptySize;  -- the size of an empty page  PageHandle: TYPE = BTreeInternal.PageHandle;  PagePointer: TYPE = BTreeInternal.PagePointer;  nilPagePointer: PagePointer = BTreeInternal.nilPagePointer;  EntryHandle: TYPE = BTreeInternal.EntryHandle;  snapShot: PageHandle ¬ NIL;  snapShotSpace: Space.Interval ¬ Space.nullInterval;  initialReadOnlyMaps: BOOLEAN ¬ TRUE;  -- PUBLIC procedures and signals  -- SpecialBTree  AutoForceOut: PUBLIC ENTRY PROCEDURE [tree: Tree, auto: BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    tree.autoForceOut ¬ auto;    IF auto AND tree.base # NIL THEN Space.ForceOut[tree.space];    END;  -- BTree  Delete: PUBLIC PROCEDURE [tree: Tree] =    -- Get rid of a B-Tree.    BEGIN    LocalDelete: ENTRY PROCEDURE [tree: Tree] =      BEGIN      ENABLE UNWIND => NULL;      BTreeInternal.FlushGNCache[tree];      IF tree.base # NIL THEN         tree.space.pointer ¬ Space.Unmap[tree.space.pointer];      END;    LocalDelete[tree];    IF tree.file # NIL THEN      MFile.SetLength[        tree.file, (File.GetSize[tree.cap] - 1)*Environment.bytesPerPage	! MFile.Error => CONTINUE];  -- this will fail if file was readOnly    BTreeInternal.heap.FREE[@tree];    END;  -- BTree   Empty: PUBLIC ENTRY PROCEDURE [tree: Tree] RETURNS [BOOLEAN] =    -- B-Tree predicate    BEGIN    ENABLE UNWIND => NULL;    IF tree.base = NIL THEN {SIGNAL Unmapped[tree]; MapInternal[tree]};    RETURN[tree.base[tree.top].size = emptySize]    END;  -- SpecialBTree    ForceOut: PUBLIC ENTRY PROCEDURE [tree: Tree] =    BEGIN    ENABLE UNWIND => NULL;    IF tree.base = NIL THEN {SIGNAL Unmapped[tree]; MapInternal[tree]};    Space.ForceOut[tree.space];    END;  -- BTree    GetInfo: PUBLIC ENTRY PROCEDURE [tree: Tree]    RETURNS [valueSize: BTree.ValueSize,      file: MFile.Handle, usage: Space.Usage] = {    RETURN[tree.valueSize, tree.file, tree.usage]};  -- SpecialBTree    GetSpecialInfo: PUBLIC ENTRY PROCEDURE [tree: Tree]    RETURNS [cap: File.File, lpSize: CARDINAL] = {RETURN[tree.cap, tree.lpSize]};  -- SpecialBTree  Invalid: PUBLIC SIGNAL [error: SpecialBTree.Error] = CODE;  -- BTree   Make: PUBLIC PROCEDURE [    file: MFile.Handle ¬ NIL,    usage: Space.Usage,    valueSize: BTree.ValueSize ¬ BTree.defaultValueSize,     reset: BOOLEAN ¬ FALSE]    RETURNS [tree: Tree] =    BEGIN    tree ¬ MakeFromCapa[      IF file = NIL THEN File.nullFile ELSE SpecialMFile.GetCapaWithAccess[file],      usage, 1, valueSize, reset];    tree.file ¬ file;    END;  -- SpecialBTree  MakeFromCapa: PUBLIC PROCEDURE [      cap: File.File ¬ File.nullFile,      usage: Space.Usage,      lpSize: CARDINAL ¬ 1,      valueSize: BTree.ValueSize ¬ BTree.defaultValueSize,      reset: BOOLEAN ¬ FALSE]    RETURNS [tree: Tree] =    -- Make a new B-Tree.  If cap is File.nullFile, use a data space    BEGIN    pPage: PageHandle;    p: PagePointer;    window: Space.Window;    oddSize: BOOLEAN ¬ FALSE;    tree ¬ BTreeInternal.heap.NEW[      TreeObject ¬ [      lpSize: lpSize, cap: cap, usage: usage,      valueSize: valueSize, autoForceOut: TRUE]];    IF cap = File.nullFile THEN      BEGIN      tree.size ¬ maxTreeSize;      tree.lpSize ¬ 0;      window ¬ [file: File.nullFile, base: NULL, count: maxTreeSize];      tree.spaceReadOnly ¬ FALSE;      END     ELSE      BEGIN      tree.size ¬ File.GetSize[cap];       IF tree.size <= tree.lpSize THEN        SELECT Volume.GetStatus[tree.cap.volumeID] FROM          openRead  => ERROR BTree.ReadOnly[NIL];	  openReadWrite => {	    File.SetSize[              tree.cap, BTreeInternal.treeIncrement*bTreePage + tree.lpSize];            tree.size ¬ BTreeInternal.treeIncrement*bTreePage};	  ENDCASE => ERROR BTree.VolumeNotOpen[tree.cap.volumeID]      ELSE tree.size ¬ tree.size - tree.lpSize;      window ¬ [        file: cap, base: tree.lpSize, count: tree.size -- MIN[maxTreeSize, tree.size] --];      SELECT Volume.GetStatus[tree.cap.volumeID] FROM        openRead  => tree.spaceReadOnly ¬ TRUE;	openReadWrite => tree.spaceReadOnly ¬ initialReadOnlyMaps;	ENDCASE => ERROR BTree.VolumeNotOpen[tree.cap.volumeID];      END;    -- Create a space big enough for the tree and two expansions    tree.space ¬ Space.Map[      window: window,      usage: tree.usage,      swapUnits: [uniform[bTreePage]],       access: IF tree.spaceReadOnly THEN readOnly ELSE readWrite];     tree.base ¬ tree.space.pointer;    -- See if we have a real B-Tree or not.    -- IF YOU WISH TO BE MORE ROBUST, use Validate.    IF reset OR (tree.base[tree.base.top].size = 0) THEN {      --  We have a new file      BTreeInternal.CheckVolumeAccess[tree];      IF tree.size MOD 2 # 0 THEN {        tree.space.pointer ¬ Space.Unmap[tree.space.pointer];	tree.size ¬ tree.size + 1;	File.SetSize[tree.cap, tree.size];	window.count ¬ window.count + 1;	tree.space ¬ Space.Map[window: window, usage: tree.usage, 	        swapUnits: [uniform[bTreePage]], access: readWrite]};      tree.top ¬ BTreeInternal.firstPagePointer;      --  Set up the first page      tree.base­ ¬ [        size: emptySize, free: FALSE, sizeValue: tree.valueSize, top: tree.top,        parent: nilPagePointer, lastPointer: nilPagePointer, entries:];      --  initialize the rest of the tree to free pages      p ¬ BTreeInternal.firstPagePointer + Environment.wordsPerPage*bTreePage;      pPage ¬ @tree.base[p];      THROUGH [1..tree.size/bTreePage) DO        pPage.free ¬ TRUE;        pPage ¬ pPage + bTreePage*Environment.wordsPerPage;        ENDLOOP;      Space.ForceOut[tree.space]}    ELSE -- This is a bonifide B-Tree --      BEGIN      tree.top ¬ tree.base.top;      tree.valueSize ¬        IF tree.base.sizeValue = 0 THEN BTree.defaultValueSize	ELSE tree.base.sizeValue;      END;    END;  -- SpecialBTree   Map: PUBLIC ENTRY PROCEDURE [tree: Tree] =    BEGIN    ENABLE UNWIND => NULL;    IF tree.cap # File.nullFile AND tree.base = NIL THEN MapInternal[tree];    END;  -- BTree  Remove: PUBLIC ENTRY PROCEDURE [    tree: Tree, name: LONG STRING, value: BTree.Value] RETURNS [ok: BOOLEAN] =    -- remove an entry from the B-Tree and return the value    BEGIN    ENABLE UNWIND => NULL;    pEntry: EntryHandle;    vp: BTreeInternal.ValuePointer;    IF tree.base = NIL THEN {      SIGNAL SpecialBTree.Unmapped[tree]; MapInternal[tree]};    BTreeInternal.CheckVolumeAccess[tree];    [ok: ok, value: vp, ent: pEntry] ¬ BTreeInternal.InternalFind[tree, name];    IF ~ok THEN RETURN;    IF BTreeInternal.debug THEN BTreeInternal.SnapShot[tree];    IF value # NIL THEN ok ¬ ~BTreeInternal.CopyValue[value, vp, tree.valueSize];    DeleteInternal[tree, pEntry];    IF tree.autoForceOut THEN Space.ForceOut[tree.space];    BTreeInternal.FlushGNCache[tree];    IF BTreeInternal.debug THEN InternalValidateBTree[tree];    IF ~ok THEN ERROR BTree.ValueTooSmall[tree];    END;  -- SpecialBTree    Unmap: PUBLIC ENTRY PROCEDURE [tree: Tree] =    BEGIN    ENABLE UNWIND => NULL;    IF (tree.cap # File.nullFile) AND (tree.base # NIL) THEN      BEGIN tree.space ¬ Space.UnmapAt[tree.space.pointer]; tree.base ¬ NIL; END;    END;  -- SpecialBTree  Unmapped: PUBLIC SIGNAL [tree: Tree] = CODE;  -- SpecialBTree  Validate: PUBLIC ENTRY PROCEDURE [tree: Tree] = {};<<  BEGIN    ENABLE UNWIND => NULL;    IF tree.base = NIL THEN {SIGNAL Unmapped[tree]; MapInternal[tree]};    InternalValidateBTree[tree ! InvalidTree => {SIGNAL Invalid[error]; RESUME }];    END; >>  -- private procedures and signals  BalanceBrothers: INTERNAL PROCEDURE [    tree: Tree, low, high: PagePointer, parent: PageHandle,    parentEntry: EntryHandle, totalSize: CARDINAL] =    BEGIN    lowPage: PageHandle ¬ @tree.base[low];    highPage: PageHandle ¬ @tree.base[high];    midName: STRING ¬ [BTree.maxNameLength];    midValue: PACKED ARRAY [0..LAST[BTree.ValueSize]) OF CARDINAL;    pE1, pE2, pE3: EntryHandle;    copySize, loopSize, parentEntrySize: CARDINAL;    parentEntrySize ¬ BTreeInternal.EntrySize[tree, parentEntry];    IF lowPage.size > highPage.size THEN      BEGIN      -- move entries into the "higher" page      pE1 ¬ BTreeInternal.FirstEntry[lowPage];      pE2 ¬ BTreeInternal.LastEntry[tree, lowPage];      loopSize ¬ emptySize + BTreeInternal.EntrySize[tree, pE1];      WHILE loopSize < totalSize/2 DO        pE1 ¬ BTreeInternal.NextEntry[tree, pE1];        loopSize ¬ loopSize + BTreeInternal.EntrySize[tree, pE1];        IF pE1 = pE2 THEN RETURN;  -- leave well enough alone!        ENDLOOP;      loopSize ¬ loopSize - BTreeInternal.EntrySize[tree, pE1];      -- save the middle name, value      BTreeInternal.MoveLongString[midName, BTreeInternal.EntryName[tree, pE1]];      Copy[        from: BTreeInternal.EntryValue[tree, pE1], to: @midValue,        size: tree.valueSize];      -- make room in the more empty node      copySize ¬        lowPage.size - loopSize - BTreeInternal.EntrySize[tree, pE1] +          parentEntrySize;      pE2 ¬ pE3 ¬ BTreeInternal.FirstEntry[highPage];      Copy[from: pE2, to: pE2 + copySize, size: highPage.size - emptySize];      -- move in the entries from the brother      Copy[        from: BTreeInternal.NextEntry[tree, pE1], to: pE2,        size: copySize - parentEntrySize];      pE2 ¬ pE2 + copySize - parentEntrySize;      -- move parent entry      Copy[from: parentEntry, to: pE2, size: parentEntrySize];      BTreeInternal.EntryPointerPointer[tree, pE2]­ ¬ lowPage.lastPointer;      lowPage.lastPointer ¬ BTreeInternal.EntryPointer[tree, pE1];      lowPage.size ¬ loopSize;      highPage.size ¬ highPage.size + copySize;      IF highPage.lastPointer # nilPagePointer THEN        BEGIN        --  change parent pointers of moved children        pE2 ¬ BTreeInternal.NextEntry[tree, pE2];        WHILE pE3 # pE2 DO          tree.base[BTreeInternal.EntryPointer[tree, pE3]].parent ¬ high;          pE3 ¬ BTreeInternal.NextEntry[tree, pE3];          ENDLOOP        END      END    ELSE      BEGIN      -- move entries into the "lower" page      -- copy the parent entry into the page      pE2 ¬ pE3 ¬ BTreeInternal.FirstFreeEntry[lowPage];      Copy[from: parentEntry, to: pE2, size: parentEntrySize];      BTreeInternal.EntryPointerPointer[tree, pE2]­ ¬ lowPage.lastPointer;      -- copy from the brother until the node is about 1/2 full      pE1 ¬ BTreeInternal.FirstEntry[highPage];      pE2 ¬ pE2 + parentEntrySize;      copySize ¬ BTreeInternal.EntrySize[tree, pE1];      loopSize ¬ lowPage.size + parentEntrySize + copySize;      WHILE loopSize < totalSize/2 DO        pE1 ¬ BTreeInternal.NextEntry[tree, pE1];        copySize ¬ copySize + BTreeInternal.EntrySize[tree, pE1];        loopSize ¬ lowPage.size + parentEntrySize + copySize;        ENDLOOP;      copySize ¬ copySize - BTreeInternal.EntrySize[tree, pE1];      Copy[from: BTreeInternal.FirstEntry[highPage], to: pE2, size: copySize];      lowPage.lastPointer ¬ BTreeInternal.EntryPointer[tree, pE1];      --  save the new parent name, tree      BTreeInternal.MoveLongString[midName, BTreeInternal.EntryName[tree, pE1]];      Copy[        from: BTreeInternal.EntryValue[tree, pE1], to: @midValue,        size: tree.valueSize];      --move entries over in page we copied from      Copy[        from: BTreeInternal.NextEntry[tree, pE1],        to: BTreeInternal.FirstEntry[highPage],        size:        highPage.size - copySize - emptySize - BTreeInternal.EntrySize[          tree, pE1]];      lowPage.size ¬ lowPage.size + parentEntrySize + copySize;      highPage.size ¬        highPage.size - copySize - BTreeInternal.Overhead[tree] - SIZE[          StringBody [midName.length]];      IF lowPage.lastPointer # nilPagePointer THEN        BEGIN        --  change parent pointers of moved children        tree.base[lowPage.lastPointer].parent ¬ low;        WHILE pE3 # BTreeInternal.FirstFreeEntry[lowPage] DO          tree.base[BTreeInternal.EntryPointer[tree, pE3]].parent ¬ low;          pE3 ¬ BTreeInternal.NextEntry[tree, pE3];          ENDLOOP;        END;      END;    -- Remove the old parent entry and put in the new parent entry    IF parent.parent = nilPagePointer      AND parent.size = emptySize + BTreeInternal.EntrySize[tree, parentEntry]      THEN      BEGIN      --  this is the parent with one entry... do differently      BTreeInternal.EntryName[tree, parentEntry]­ ¬ [        length: 0, maxlength: midName.length, text:];      Copy[        from: midName, to: BTreeInternal.EntryName[tree, parentEntry],        size: SIZE[StringBody [midName.length]]];      Copy[        from: @midValue, to: BTreeInternal.EntryValue[tree, parentEntry],        size: tree.valueSize];      parent.size ¬ emptySize + BTreeInternal.EntrySize[tree, parentEntry];      END    ELSE      BEGIN      Squeeze[tree, parentEntry];      -- replace entry with successor entry      [] ¬ BTreeInternal.InsertInNode[        tree, lowPage.parent, midName, LOOPHOLE[LONG[@midValue]], high];      END;    END;  ChooseBrother: INTERNAL PROCEDURE [tree: Tree, p: PagePointer]    RETURNS [low, high: PagePointer, parentEntry: EntryHandle] =    BEGIN    pParent: PageHandle ¬ @tree.base[tree.base[p].parent];    pLast, pNext: EntryHandle;    IF pParent.lastPointer = p THEN      BEGIN      high ¬ p;      parentEntry ¬ BTreeInternal.LastEntry[tree, pParent];      low ¬ BTreeInternal.EntryPointer[tree, parentEntry];      RETURN      END;    parentEntry ¬ BTreeInternal.FirstEntry[pParent];    IF BTreeInternal.EntryPointer[tree, parentEntry] = p THEN      BEGIN      low ¬ p;      pNext ¬ BTreeInternal.NextEntry[tree, parentEntry];      high ¬        IF pNext = BTreeInternal.FirstFreeEntry[pParent] THEN pParent.lastPointer        ELSE BTreeInternal.EntryPointer[tree, pNext];      RETURN;      END;    pLast ¬ BTreeInternal.NextEntry[tree, parentEntry];    UNTIL BTreeInternal.EntryPointer[tree, parentEntry] = p DO      pLast ¬ parentEntry;      parentEntry ¬ BTreeInternal.NextEntry[tree, parentEntry];      ENDLOOP;    pNext ¬ BTreeInternal.NextEntry[tree, parentEntry];    high ¬      IF pNext = BTreeInternal.FirstFreeEntry[pParent] THEN pParent.lastPointer      ELSE BTreeInternal.EntryPointer[tree, pNext];    IF tree.base[BTreeInternal.EntryPointer[tree, pLast]].size < tree.base[      high].size THEN low ¬ p    ELSE      BEGIN      low ¬ BTreeInternal.EntryPointer[tree, pLast];      high ¬ p;      parentEntry ¬ pLast      END;    END;  Compress: INTERNAL PROCEDURE [tree: Tree, pE: EntryHandle] =    -- remove entry i, with fill from a brother if necessary    BEGIN    dPage: PageHandle;    p: PagePointer ¬ BTreeInternal.PagePointerFromEntryHandle[tree, pE];    high: PagePointer;  -- the node of the two brothers with the higher keys    low: PagePointer;  -- the node of the two brothers with the lower keys    pParent: PageHandle;    parentEntry: EntryHandle;    totalSize: CARDINAL;    dPage ¬ @tree.base[p];    -- compress out the old entry    Squeeze[tree, pE];    IF (dPage.size >= bTreePage*Environment.wordsPerPage/2)      OR (dPage.parent = nilPagePointer) THEN RETURN;    -- the node is too small, so fill in from a brother    pParent ¬ @tree.base[dPage.parent];    [low, high, parentEntry] ¬ ChooseBrother[tree, p];    totalSize ¬      tree.base[high].size + tree.base[low].size + BTreeInternal.EntrySize[        tree, parentEntry] - emptySize;    (IF totalSize <= bTreePage*Environment.wordsPerPage THEN MergeBrothers     ELSE BalanceBrothers)[tree, low, high, pParent, parentEntry, totalSize];    END;  Copy: INTERNAL PROCEDURE [from, to: LONG POINTER, size: CARDINAL] = --INLINE-- {    [] ¬ ByteBlt.ByteBlt[      from: [from, 0, size*2], to: [to, 0, size*2], overLap: move]};  DeleteInternal: INTERNAL PROCEDURE [tree: Tree, i: EntryHandle] =    -- delete node p entry i    BEGIN    p: PagePointer ¬ BTreeInternal.PagePointerFromEntryHandle[tree, i];    page: PageHandle = @tree.base[p];    succPage, after: PagePointer;    pE: EntryHandle;    IF BTreeInternal.EntryPointer[tree, i] = nilPagePointer THEN Compress[tree, i]    ELSE      BEGIN      [succPage, after] ¬ BTreeInternal.Successor[tree, i];      pE ¬ BTreeInternal.FirstEntry[@tree.base[succPage]];  -- pointer to successor entry      IF (page.parent = nilPagePointer)        AND (page.size = emptySize + BTreeInternal.EntrySize[tree, i]) THEN {        -- this is the parent with one entry... do differently        Copy[          from: BTreeInternal.EntryName[tree, pE],          to: BTreeInternal.EntryName[tree, i],          size: SIZE[StringBody [BTreeInternal.EntryName[tree, pE].length]]];        Copy[          from: BTreeInternal.EntryValue[tree, pE],          to: BTreeInternal.EntryValue[tree, i], size: tree.valueSize];        page.size ¬ emptySize + BTreeInternal.EntrySize[tree, pE]}      ELSE        BEGIN        Squeeze[tree, i];  -- replace entry with successor entry        [] ¬ BTreeInternal.InsertInNode[          tree, p, BTreeInternal.EntryName[tree, pE], BTreeInternal.EntryValue[          tree, pE], after];        END;      DeleteInternal[tree, pE]  -- Delete the successor entry      END;    END;  -- BTreeInternal   InternalValidateBTree: PUBLIC INTERNAL PROCEDURE [tree: Tree] = {};<<>  --  Perform some tests on this B-Tree    BEGIN    pPage: PagePointer;    iPage: CARDINAL;    pageTouched: ARRAY [0..maxTreeSize/bTreePage) OF BOOLEAN ¬ ALL[FALSE];    PointerToIndex: INTERNAL PROCEDURE [p: PagePointer]      RETURNS [index: CARDINAL] =      --change a page pointer to an index, doing some checking as we go      BEGIN      pNumber: LONG CARDINAL = LOOPHOLE[p, LONG CARDINAL];      mod: CARDINAL;      -- pointer must be multiple of page size      [index, mod] ¬ Inline.LongDivMod[        pNumber, bTreePage*Environment.wordsPerPage];      IF mod # 0 THEN ERROR InvalidTree[BadPointer, tree.base, p, NIL];      RETURN[index];      END;    ValidatePage: INTERNAL PROCEDURE [p, parent: PagePointer] =      --check this page for validity      BEGIN      pE: EntryHandle;      pP: PageHandle;      iP: CARDINAL;      size: CARDINAL;      leafPage: BOOLEAN;      iP ¬ PointerToIndex[p];      IF iP > tree.size - 1 THEN SIGNAL InvalidTree[SizeError, tree.base, p, NIL];      pP ¬ @tree.base[p];      IF pageTouched[iP] THEN {        SIGNAL InvalidTree[Cycle, tree.base, p, NIL]; RETURN};      pageTouched[iP] ¬ TRUE;      IF pP.free THEN {        SIGNAL InvalidTree[BadPointer, tree.base, parent, NIL]; RETURN};      IF pP.size < emptySize OR pP.size > bTreePage*Environment.wordsPerPage THEN        {SIGNAL InvalidTree[SizeError, tree.base, p, NIL]; RETURN};      IF pP.size = emptySize AND (pP.parent # nilPagePointer) THEN {        SIGNAL InvalidTree[SizeError, tree.base, p, NIL]; RETURN};      IF pP.parent # parent THEN {        SIGNAL InvalidTree[BadPointer, tree.base, p, NIL]; RETURN};      leafPage ¬ pP.lastPointer = nilPagePointer;      size ¬ emptySize;      pE ¬ BTreeInternal.FirstEntry[pP];      WHILE size < pP.size DO        IF          (BTreeInternal.EntryName[tree, pE].length > BTreeInternal.EntryName[            tree, pE].maxlength)          OR (BTreeInternal.EntryName[tree, pE].length > BTree.maxNameLength)          OR (BTreeInternal.EntryName[tree, pE].length = 0) THEN {          SIGNAL InvalidTree[SizeError, tree.base, p, pE]; RETURN};        IF BTreeInternal.EntryPointer[tree, pE] # nilPagePointer THEN          BEGIN          IF leafPage THEN SIGNAL InvalidTree[LeafError, tree.base, p, pE];          ValidatePage[p: BTreeInternal.EntryPointer[tree, pE], parent: p];          END        ELSE IF ~leafPage THEN SIGNAL InvalidTree[LeafError, tree.base, p, pE];        size ¬ size ¬ size + BTreeInternal.EntrySize[tree, pE];        pE ¬ BTreeInternal.NextEntry[tree, pE];        ENDLOOP;      IF ~leafPage THEN ValidatePage[p: pP.lastPointer, parent: p];      RETURN      END;  -- ValidatePage    ValidatePage[tree.top, nilPagePointer];    pPage ¬ BTreeInternal.firstPagePointer;    iPage ¬ 0;    THROUGH [0..tree.size/bTreePage) DO  --  test for orphan pages      IF ~tree.base[pPage].free AND ~pageTouched[iPage] THEN        SIGNAL InvalidTree[Orphan, tree.base, pPage, NIL];      pPage ¬ pPage + bTreePage*Environment.wordsPerPage;      iPage ¬ iPage + 1;      ENDLOOP;    RETURN    END; >>  -- BTreeInternal  MapInternal: PUBLIC INTERNAL PROCEDURE [tree: Tree] =    BEGIN    newSize: Environment.PageCount = File.GetSize[tree.cap];    IF newSize > tree.size + tree.lpSize THEN      BEGIN      tree.size ¬ newSize - tree.lpSize;      Space.Deallocate[tree.space];      tree.space ¬ Space.Allocate[        count: tree.size + 2*BTreeInternal.treeIncrement*bTreePage];      --  MIN[maxTreeSize, tree.size + 2*BTreeInternal.treeIncrement*bTreePage]];      END;    SELECT Volume.GetStatus[tree.cap.volumeID] FROM        openRead  => tree.spaceReadOnly ¬ TRUE;	openReadWrite => tree.spaceReadOnly ¬ initialReadOnlyMaps;	ENDCASE => ERROR BTree.VolumeNotOpen[tree.cap.volumeID];    [] ¬ Space.MapAt[at: tree.space,      window: [        tree.cap, tree.lpSize,	tree.size + 2*BTreeInternal.treeIncrement*bTreePage],     -- MIN[maxTreeSize, tree.size + 2*BTreeInternal.treeIncrement*bTreePage]],      usage: tree.usage,      swapUnits: [uniform[bTreePage]],      access: IF tree.spaceReadOnly THEN readOnly ELSE readWrite];    tree.base ¬ tree.space.pointer;    tree.top ¬ tree.base.top;    END;  MergeBrothers: INTERNAL PROCEDURE [    tree: Tree, low, high: PagePointer, parent: PageHandle,    parentEntry: EntryHandle, totalSize: CARDINAL] =    BEGIN    lowPage: PageHandle ¬ @tree.base[low];    highPage: PageHandle ¬ @tree.base[high];    parentEntrySize: CARDINAL = BTreeInternal.EntrySize[tree, parentEntry];    pChange, pFillEnd: EntryHandle;    pChange ¬ pFillEnd ¬ BTreeInternal.FirstFreeEntry[lowPage];    Copy[from: parentEntry, to: pFillEnd, size: parentEntrySize];    BTreeInternal.EntryPointerPointer[tree, pFillEnd]­ ¬ lowPage.lastPointer;    pFillEnd ¬ pFillEnd + parentEntrySize;    Copy[      from: BTreeInternal.FirstEntry[highPage], to: pFillEnd,      size: highPage.size - emptySize];    lowPage.lastPointer ¬ highPage.lastPointer;    lowPage.size ¬ totalSize;    OldPage[tree, high];    IF lowPage.lastPointer # nilPagePointer THEN      BEGIN      --  change parent pointers of new children      tree.base[lowPage.lastPointer].parent ¬ low;      WHILE pChange # BTreeInternal.FirstFreeEntry[lowPage] DO        tree.base[BTreeInternal.EntryPointer[tree, pChange]].parent ¬ low;        pChange ¬ BTreeInternal.NextEntry[tree, pChange];        ENDLOOP;      END;    IF tree.top = lowPage.parent AND parent.size = parentEntrySize + emptySize      THEN      BEGIN      -- this compress shrinks the tree      tree.top ¬ tree.base.top ¬ low;      OldPage[tree, lowPage.parent];      lowPage.parent ¬ nilPagePointer;      END    ELSE Compress[tree, parentEntry];    END;  InvalidTree: SIGNAL [    error: SpecialBTree.Error, base: PageHandle, page: PagePointer,    entry: EntryHandle] = CODE;  OldPage: INTERNAL PROCEDURE [tree: Tree, p: PagePointer] = INLINE {    tree.base[p].free ¬ TRUE};  -- BTreeInternal  SnapShot: PUBLIC INTERNAL PROCEDURE [tree: Tree] = {};  <<  --  Copy the b-tree into the debug space    BEGIN    from, to: LONG POINTER;    IF snapShot = NIL THEN      BEGIN      snapShotSpace ¬ Space.Map[        window: [file: File.nullFile, base: NULL, count: maxTreeSize],	usage: MUsage.bTreeDebug, 	swapUnits: [uniform[bTreePage]]];      snapShot ¬ snapShotSpace.pointer;      END;    from ¬ tree.base;    to ¬ snapShot;    FOR wordsLeft: LONG CARDINAL ¬ tree.size*Environment.wordsPerPage,         wordsLeft - LAST[CARDINAL] DO      Inline.LongCOPY[        from: from, to: to, nwords: CARDINAL[MIN[wordsLeft, LAST[CARDINAL]]]];      IF wordsLeft <= LAST[CARDINAL] THEN EXIT;      from ¬ from + LAST[CARDINAL];      to ¬ to + LAST[CARDINAL];      ENDLOOP;    END; >>  Squeeze: INTERNAL PROCEDURE [tree: Tree, pE: EntryHandle] =    -- squeeze out the entry pointed to by pE    BEGIN    p: PagePointer ¬ BTreeInternal.PagePointerFromEntryHandle[tree, pE];    compress, copy: CARDINAL;    pNext: EntryHandle ¬ BTreeInternal.NextEntry[tree, pE];    compress ¬ BTreeInternal.EntrySize[tree, pE];    copy ¬      tree.base[p].size - Inline.LowHalf[        LOOPHOLE[pNext, LONG CARDINAL] - LOOPHOLE[@tree.base[p], LONG CARDINAL]];    IF copy # 0 THEN      BEGIN      BTreeInternal.EntryPointerPointer[tree, pNext]­ ¬        BTreeInternal.EntryPointer[tree, pE];      Copy[from: pNext, to: pE, size: copy];      END    ELSE tree.base[p].lastPointer ¬ BTreeInternal.EntryPointer[tree, pE];    tree.base[p].size ¬ tree.base[p].size - compress;    RETURN    END;  END.           LOG      Time: 8-Jun-81 11:53:00 AM By: Keith	Action: Created from DirectoryTreesImpl      Time: 22-Sep-81 17:20:41 By: KAM	Action: BTreeGetNext now returns the entry that would follow name, even if name is not in    the b-tree.  Changed the get next cache from an array to a linked list, so it will never run out of room.      Time:  1-Oct-81 12:20:46 By: PXK	Action: MONITORizing it and making Validation public, now has own heap.      Time:  5-Oct-81 16:11:09 By: KAM	Action: Added PROCs SwapValue and SnapShot, attached cache entry to a b-tree descriptor,    added parameters reset and lpSize to Make.      Time:  January 27, 1982  5:45 PM By: KAM	Action: Made less greedy in creating spaces for BTrees.      Time:  11-Mar-82  8:55:08 By: KAM	Action: Added Map and Unmap plus support.   Time:  20-Sep-82 16:25:15 By: KAM	Action: Split from BTreeImpl. Added MFile Make and variable value size.   Time:   9-Nov-82 14:22:38 By: KAM	Action: MapInternal didn't check to see if tree has changed whilst unmapped.   Time:  29-Nov-82 19:34:30 By: KAM	Action: Remove deleted the entry before copying the value to the client storage.   Time:  12-May-83 18:31:54 By: KAM	Action: Added read only stuff.   Time:  27-Jul-83 10:28:12 By: WDE  Action: added usage parameter.   Time:   4-Apr-85 16:34:00 By: KAM	Action: Uses BTreeInternal.PagePointerFromEntryHandle.      
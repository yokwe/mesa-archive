-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File: MFileImplA.mesa - last edited by-- PXK    ,	 6-Apr-82 17:59:07-- LXR    ,	 8-Dec-83 13:15:44-- SXS   ,	25-Nov-81 14:58:14-- JGS,		24-Nov-81 10:13:04-- RXJ     ,	26-Oct-82 18:33:24-- DWE    ,	28-Jul-83 11:39:12DIRECTORY  Environment USING [bytesPerPage],  Event USING [fileSystem],  EventTypes USING [directoryDeleted],  File USING [    Create, Delete, File, GetAttributes, GetSize, ID, nullID, nullFile,     PageCount, Type, Unknown],  Heap USING [Create],  MDirectory USING [    DirDelete, DirError, DirInfo, DirRename, EnumerateState, ErrorCode,     FindFirstWriteable, GetNext, Insert, IsValid, LookUp, SetID, Swap,    ValidateFile],  MesaDEFileTypes USING [MesaDEFileType, tNormal],  MFile USING [    Access, dontCare, dontRelease, EnumerateState, EnumerationType, ErrorCode,    GetFullName, Handle, InitialLength, maxNameLength, Object, PropertyError,    ReleaseData, SetReleaseData, SetTimes, SetType, Type],  MFileOps USING [    AskPilotToMakePermanent, AskPilotToMakeTemp, FHandle, fHandleLock,     FileObject, FileLoc, GetFilePart, GetName, Handle,     IncrementCeiling, InitLeader, InvalidLeader,    LeaderPage, leaderPages, MapLeader, maxNameLength,    Object, PageForBytes, NoteCaller, SetDir, SetFileDataSize,    SetName, UnmapLeader, ValidateHandle],  MUsage USING [mFileLeaderPage],  NotifyOps USING [AccessStatus, AddHandle, AddToNotificationListInternal,    AddToWriteableList, LockedSetAccess, notifyList, RemoteFileName,    SetTimesGivenAccess, TakeHandleOffList],  RFile USING [Acquire, Delete, Handle, ReadLeaderPage, Release, SetAccess,    UnlockLeader],  Runtime USING [CallDebugger, GetCaller],  Space USING [GetSwapUnitAttributes, Interval, Kill, MakeWritable, ScratchMap],  SpecialMFile USING [],  String USING [AppendOctal, AppendString],  Supervisor USING [EnumerationAborted, NotifyDirectSubsystems],  Time USING [Current, Packed],  Volume USING [GetStatus, ID, InsufficientSpace, nullID, systemID];MFileImplA: MONITOR LOCKS MFileOps.fHandleLock -- locks fHandles  IMPORTS    Event, MDirectory, MFile, MFileOps, File, Heap, NotifyOps,    RFile, Runtime, Space, String, Supervisor, Time, Volume  EXPORTS MFile, MFileOps, NotifyOps, SpecialMFile =  BEGIN  Handle: TYPE = MFileOps.Handle;  Object: PUBLIC TYPE = MFileOps.Object;  FHandle: TYPE = MFileOps.FHandle;  ReleaseData: TYPE = MFile.ReleaseData;  LeaderPage: TYPE = MFileOps.LeaderPage;  -- errors  Error: PUBLIC SIGNAL [file: MFile.Handle, code: MFile.ErrorCode] = CODE;  NameForError: PUBLIC SIGNAL RETURNS [errorName: LONG STRING] = CODE;  InvalidLeader: PUBLIC SIGNAL = CODE;  ImplementationError: ERROR [what: LONG STRING] = CODE;  -- acquiring and releasing files  heap: PUBLIC UNCOUNTED ZONE ¬ Heap.Create[    initial: 4, swapUnitSize: 4, increment: 4];  -- the following items should be used only by MFileImplE  fHandles: PUBLIC FHandle ¬ NIL;  -- list of allocated FileObjects  fHandleLock: PUBLIC MONITORLOCK;  -- lock for FHandles    Acquire: PUBLIC PROCEDURE [    name: LONG STRING, access: MFile.Access, release: MFile.ReleaseData,    mightWrite: BOOLEAN ¬ FALSE, initialLength: MFile.InitialLength ¬ MFile.dontCare,    type: MFile.Type ¬ unknown] RETURNS [file: Handle] = {    ENABLE NameForError => RESUME [name];    fo: FHandle;    protectedSP: BOOLEAN;    status: NotifyOps.AccessStatus;    IF access = null THEN ERROR Error[NIL, nullAccess];    IF release = MFile.dontRelease THEN      release.clientInstanceData ¬ MFileOps.NoteCaller[Runtime.GetCaller[]];    [] ¬ NotifyOps.RemoteFileName[name]; -- ***************************************    DO      [fo, protectedSP, file] ¬ GetObject[name, access, initialLength, type, mightWrite];  -- adds to refCount to hold on to fo      IF file # NIL THEN {MFile.SetReleaseData[file, release]; status ¬ good}       ELSE [status, file] ¬ NotifyOps.AddHandle[        fo: fo, access: access, release: release, protectedSP: protectedSP];      ReleaseObject[fo, access, status # good];  -- decrement fo refCount      SELECT status FROM        retry => LOOP;        good => EXIT;        protected => ERROR Error[NIL, protectionFault];        conflicting => ERROR Error[NIL, conflictingAccess];        ENDCASE => ImplementationError["Bad status"L];      ENDLOOP;    WITH file.fo.location SELECT FROM     local => IF f.volumeID # Volume.systemID AND                  Volume.GetStatus[f.volumeID] # openReadWrite THEN RETURN;     ENDCASE;    NotifyOps.SetTimesGivenAccess[file.fo, file.fo.lp, access];    IF type # unknown AND file.fo.lp.fp.dirInfo.type # type THEN       MFile.SetType[file, type]};  AcquireID: PUBLIC PROCEDURE [    id: File.File, access: MFile.Access, release: MFile.ReleaseData]    RETURNS [file: Handle] = {    fo: FHandle;    status: NotifyOps.AccessStatus;    name: LONG STRING ¬ [15];    GetObject: ENTRY PROCEDURE  = {      ENABLE UNWIND => NULL;      fileType: File.Type;      [type: fileType] ¬ File.GetAttributes[id        ! File.Unknown => Error[NIL, noSuchFile]];      IF ~(fileType IN MesaDEFileTypes.MesaDEFileType) THEN        Error[NIL, noSuchFile];      fo ¬ GetFO[[local[f: id]], NIL, FALSE]};    {ENABLE NameForError => {      f: RECORD[a,b: UNSPECIFIED] = LOOPHOLE[id.fileID];      String.AppendOctal[name, f.a];       String.AppendString[to: name, from: ", "L];      String.AppendOctal[name, f.b];      RESUME [name]};    DO      GetObject[];  -- increments refCount in fo      [status, file] ¬ NotifyOps.AddHandle[fo, access, release];      ReleaseObject[fo, access, status # good];  -- decrement refCount in fo      SELECT status FROM        good => EXIT;        retry => LOOP;        protected => ERROR Error[NIL, protectionFault];        conflicting => ERROR Error[NIL, conflictingAccess];        ENDCASE => ImplementationError["Bad status"L];      ENDLOOP;    WITH file.fo.location SELECT FROM     local => IF f.volumeID # Volume.systemID AND               Volume.GetStatus[f.volumeID] # openReadWrite THEN RETURN;     ENDCASE;    NotifyOps.SetTimesGivenAccess[file.fo, file.fo.lp, access]}};  GetObject: ENTRY PROCEDURE [    name: LONG STRING, access: MFile.Access,    initialLength: MFile.InitialLength, type: MFile.Type,    mightWrite: BOOLEAN]     RETURNS [fo: FHandle, protectedSP: BOOLEAN ¬ FALSE, file: Handle ¬ NIL] =    {    ENABLE UNWIND => NULL;    rec: MFileOps.FileLoc;    id: File.ID ¬ File.nullID;    dir: File.File ¬ File.nullFile;    dirInfo: MDirectory.DirInfo ¬ [];    lp: LeaderPage;    newFile, readOnlyVolume, remote: BOOLEAN ¬ FALSE;    failure: MFile.ErrorCode;    fileName: STRING = [MFile.maxNameLength];    mightWrite ¬ SELECT access FROM      readWrite, writeOnly, log, delete, rename => TRUE,      ENDCASE => mightWrite;    {SELECT remote ¬ NotifyOps.RemoteFileName[name] FROM      TRUE => {        h: RFile.Handle ¬ RFile.Acquire[name, access];	lp ¬ Space.ScratchMap[count: MFileOps.leaderPages,	  usage: MUsage.mFileLeaderPage].pointer;	RFile.ReadLeaderPage[h, lp];	RFile.UnlockLeader[h];	rec ¬ [remote[h: h]]};      FALSE => {    [id, dir, dirInfo, protectedSP] ¬ MDirectory.LookUp[      name, mightWrite !      MDirectory.DirError =>        SELECT type FROM          fileNotFound =>            SELECT access FROM              anchor, readOnly, delete, rename => {                failure ¬ noSuchFile; GOTO Fail};              ENDCASE => CONTINUE;          invalidFileName => {failure ¬ illegalName; GOTO Fail};          invalidVolume => {failure ¬ noSuchVolume; GOTO Fail};          volumeNotOpen => {failure ¬ volumeNotOpen; GOTO Fail};          readOnlyDirectory => {failure ¬ volumeReadOnly; GOTO Fail};          noRootDirectory => {failure ¬ noRootDirectory; GOTO Fail};          ENDCASE => {failure ¬ other; GOTO Fail}];    IF id = File.nullID THEN {      fileSize: File.PageCount = MFileOps.IncrementCeiling[        MFileOps.PageForBytes[IF initialLength = MFile.dontCare THEN 1 ELSE initialLength]];      newFile ¬ TRUE;      [id, dir] ¬ MDirectory.Insert[        name, fileSize, [type: type] !        MDirectory.DirError =>          SELECT type FROM            directoryFull => {failure ¬ directoryFull; GOTO Fail};            invalidFileName, invalidVolume => {failure ¬ illegalName; GOTO Fail};            invalidPathName => {failure ¬ noSuchDirectory; GOTO Fail};            volumeNotOpen => {failure ¬ volumeNotOpen; GOTO Fail};            readOnlyDirectory => {failure ¬ volumeReadOnly; GOTO Fail};            noRootDirectory => {failure ¬ noRootDirectory; GOTO Fail};            noRoomOnVolume => {failure ¬ noRoomOnVolume; GOTO Fail};            protectedDirectory => {failure ¬ protectionFault; GOTO Fail};            ENDCASE => {failure ¬ other; GOTO Fail}];      lp ¬ MFileOps.MapLeader[[id, dir.volumeID] ! InvalidLeader => RESUME ]; --  can map for write since new file and fHandles locked      MFileOps.GetFilePart[from: name, to: fileName];      MFileOps.InitLeader[lp, dir.fileID, type, fileName, 0];      dirInfo ¬ [type: type]}    ELSE {      [] ¬ MDirectory.ValidateFile[[id, dir.volumeID]]; -- if user proceeds from error, he want it anyway      lp ¬ NIL;      IF initialLength # MFile.dontCare AND access IN [readWrite..log] THEN {        pages: File.PageCount = MFileOps.PageForBytes[initialLength];        IF File.GetSize[[id, dir.volumeID]] < pages THEN          MFileOps.SetFileDataSize[[id, dir.volumeID], pages]}};     rec ¬ [local[f: [id, dir.volumeID]]]};    ENDCASE;    fo ¬ GetFO[rec, lp, FALSE];    IF newFile THEN { -- we know that the AddHandle must succeed, so do it here to avoid race with readers      file ¬ heap.NEW[        MFileOps.Object ¬ [        fo: fo, next: fo.freeList, release: [], access: access,        protectedSP: protectedSP, length: fo.lp.fp.length]];      fo.freeList ¬ file;      fo.refCount ¬ fo.refCount + 1};    EXITS Fail => RETURN WITH ERROR Error[NIL, failure]}};  GetObjectForEnumerate: PUBLIC ENTRY PROCEDURE [id: File.File, state: MDirectory.EnumerateState] RETURNS [fo: FHandle] = {     ENABLE UNWIND => NULL;     IF ~MDirectory.IsValid[id.fileID, state] THEN {Error[NIL, noSuchFile]};      fo ¬ GetFO[[local[id]], NIL, FALSE]};	  GetFO: INTERNAL PROCEDURE [    info: MFileOps.FileLoc, lp: LeaderPage, tempFile: BOOLEAN]    RETURNS [fo: FHandle ¬ NIL] = {    volumeReadWrite: BOOLEAN ¬ TRUE;    FOR fo ¬ fHandles, fo.next UNTIL fo = NIL DO      WITH a:fo.location SELECT FROM         local => WITH b:info SELECT FROM	           local => IF a.f # b.f THEN LOOP 		            ELSE volumeReadWrite ¬ 			          Volume.GetStatus[a.f.volumeID] = openReadWrite;		   remote => LOOP;		   ENDCASE;        remote => WITH b: info SELECT FROM		   local => LOOP;	           remote => IF a.h # b.h THEN LOOP ELSE volumeReadWrite ¬ TRUE;		   ENDCASE;        ENDCASE;      fo.refCount ¬ fo.refCount + 1;      lp ¬ fo.lp;  -- IF lp wasn't NIL and wasn't =fo.lp it is error. Enforce?      IF volumeReadWrite AND Space.GetSwapUnitAttributes[lp].access # readWrite THEN         Space.MakeWritable[[lp, MFileOps.leaderPages]];      EXIT;      REPEAT        FINISHED => {          IF lp = NIL THEN WITH info SELECT FROM             local =>              lp ¬ MFileOps.MapLeader[ f, 	        (f.volumeID # Volume.systemID AND 		 Volume.GetStatus[f.volumeID] # openReadWrite) !                  InvalidLeader => ERROR ImplementationError["bad leader page"L]];            ENDCASE => ERROR; -- should never happen!         fo ¬ heap.NEW[           MFileOps.FileObject ¬ [           next: fHandles, tempFile: tempFile, lp: lp,           readLengthForLog: lp.fp.length,           location: info]];         fHandles ¬ fo};      ENDLOOP};  ReleaseObject: PUBLIC ENTRY PROCEDURE [    fo: FHandle, access: MFile.Access, doNotification: BOOLEAN] = {    ENABLE UNWIND => NULL;    fo.refCount ¬ fo.refCount - 1;    WITH fo.location SELECT FROM      remote => {        IF fo.refCount # 0 THEN RETURN;         MFileOps.UnmapLeader[fo.lp];        RFile.Release[h ! Error => CONTINUE];	IF fHandles = fo THEN fHandles ¬ fo.next          ELSE {          prev: FHandle ¬ fHandles;          FOR t: FHandle ¬ prev.next, t.next UNTIL t = NIL DO            IF t = fo THEN {prev.next ¬ t.next; EXIT};            prev ¬ t;            REPEAT FINISHED => ERROR ImplementationError["Handle not in freeList"L];            ENDLOOP};        heap.FREE[@fo]};       local => IF doNotification THEN         NotifyOps.AddToNotificationListInternal[fo, access];      ENDCASE};  AcquireTemp: PUBLIC PROCEDURE [    type: MFile.Type, initialLength: MFile.InitialLength ¬ MFile.dontCare,    volume: Volume.ID ¬ Volume.nullID]    RETURNS [file: Handle] = {    name: LONG STRING ¬ [20];    {ENABLE NameForError => {      String.AppendString[to: name, from: "(temporary file)"L]; RESUME [name]};    capa: File.File = File.Create[      volume: IF volume = Volume.nullID THEN        MDirectory.FindFirstWriteable[].volumeID ELSE volume,      initialSize: IF initialLength = MFile.dontCare THEN        1 ELSE MFileOps.IncrementCeiling[MFileOps.PageForBytes[initialLength]],      type: MesaDEFileTypes.tNormal !       Volume.InsufficientSpace => ERROR Error[NIL, noRoomOnVolume]];    lp: LeaderPage;    fo: FHandle;    GetObject: ENTRY PROCEDURE = {      ENABLE UNWIND => NULL;       fo ¬ GetFO[[local[capa]], lp, TRUE]};    lp ¬ MFileOps.MapLeader[capa ! MFileOps.InvalidLeader => RESUME ];    MFileOps.InitLeader[lp, File.nullID, type, NIL, 0];    GetObject[];    file ¬ NotifyOps.AddHandle[fo, readWrite, MFile.dontRelease].file;    ReleaseObject[fo, null, FALSE];  -- decrement fo refCount    }};  CopyFileHandle: PUBLIC PROCEDURE [    file: Handle, release: MFile.ReleaseData, access: MFile.Access ¬ null]    RETURNS [newFile: Handle] = {    fo: FHandle;    status: NotifyOps.AccessStatus;    MFileOps.ValidateHandle[file];    IF release = MFile.dontRelease THEN      release.clientInstanceData ¬ MFileOps.NoteCaller[Runtime.GetCaller[]];    fo ¬ file.fo;    DO      [status, newFile] ¬ NotifyOps.AddHandle[        fo: fo,        access: IF access = null THEN file.access ELSE access, release: release,        checkAccess: IsStrongerThan[old: file.access, new: access],        ignoreConflict: file, protectedSP: file.protectedSP];      SELECT status FROM        retry => LOOP;        protected => ERROR Error[NIL, protectionFault];        conflicting => ERROR Error[NIL, conflictingAccess];        ENDCASE => EXIT;      ENDLOOP};  Release: PUBLIC PROCEDURE [file: Handle] = {    MFileOps.ValidateHandle[file];    NotifyOps.TakeHandleOffList[file.fo, file, TRUE];    };  IsStrongerThan: PROCEDURE [old, new: MFile.Access] RETURNS [BOOLEAN] = {    Access: TYPE = MFile.Access;    strength: ARRAY Access OF PACKED ARRAY Access OF BOOLEAN = [      anchor: [      anchor: FALSE, readOnly: TRUE, readWrite: TRUE, writeOnly: TRUE, log: TRUE,      delete: TRUE, rename: TRUE, null: FALSE],      readOnly: [      anchor: FALSE, readOnly: FALSE, readWrite: TRUE, writeOnly: TRUE, log: TRUE,      delete: TRUE, rename: TRUE, null: FALSE],      readWrite: [      anchor: FALSE, readOnly: FALSE, readWrite: FALSE, writeOnly: FALSE,      log: TRUE, delete: TRUE, rename: TRUE, null: FALSE],      writeOnly: [      anchor: FALSE, readOnly: TRUE, readWrite: TRUE, writeOnly: FALSE, log: TRUE,      delete: TRUE, rename: TRUE, null: FALSE],      log: [      anchor: FALSE, readOnly: TRUE, readWrite: TRUE, writeOnly: TRUE, log: TRUE,      delete: TRUE, rename: TRUE, null: FALSE],      delete: [      anchor: FALSE, readOnly: TRUE, readWrite: TRUE, writeOnly: TRUE, log: TRUE,      delete: TRUE, rename: TRUE, null: FALSE],      rename: [      anchor: FALSE, readOnly: TRUE, readWrite: TRUE, writeOnly: TRUE, log: TRUE,      delete: TRUE, rename: TRUE, null: FALSE],      null: [      anchor: FALSE, readOnly: FALSE, readWrite: FALSE, writeOnly: FALSE,      log: TRUE, delete: TRUE, rename: TRUE, null: TRUE]];    RETURN[strength[old][new]]};  SetAccess: PUBLIC PROCEDURE [file: Handle, access: MFile.Access] = {    MFileOps.ValidateHandle[file];    IF file.access = access THEN RETURN;    IF file.protectedSP THEN      SELECT access FROM        readWrite, writeOnly, log, rename, delete => ERROR Error[file, protectionFault];	ENDCASE;    WITH file.fo.location SELECT FROM      remote => {       RFile.SetAccess[h, access];      file.access ¬ access}; -- monitored?     local => NotifyOps.LockedSetAccess[file.fo, file, access];     ENDCASE};  -- directory manipulation  InternalDelete: ENTRY PROCEDURE [file: Handle] = {    ENABLE UNWIND => NULL;    fo: FHandle ¬ file.fo;    isDir: BOOLEAN;    name: STRING = [MFile.maxNameLength];    fullName: STRING = [MFile.maxNameLength];    WITH file.fo.location SELECT FROM      remote => Error[file, fileIsRemote];     local => BEGIN    MFile.GetFullName[file, fullName ! MFile.PropertyError => CONTINUE];    MFileOps.GetName[file.fo.lp, name];    isDir ¬ file.fo.lp.fp.dirInfo.type = directory;    MDirectory.DirDelete[      f, fo.lp !      MDirectory.DirError =>        SELECT type FROM          deletingDirectoryOnSearchPath => Error[file, directoryOnSearchPath];          directoryNotEmpty => Error[file, directoryNotEmpty];          ENDCASE => Error[file, other]];    MFileOps.AskPilotToMakeTemp[fo, f];    fo.tempFile ¬ TRUE;    IF isDir THEN Supervisor.NotifyDirectSubsystems[        event: EventTypes.directoryDeleted, which: clients,        subsystem: Event.fileSystem, eventData: fullName !        Supervisor.EnumerationAborted => CONTINUE];    IF fo.refCount = 1 THEN {  -- we have the only handle: release space      fo.fileIsDeleted ¬ TRUE;      fo.lengthChanged ¬ FALSE;      MFileOps.UnmapLeader[fo.lp];      File.Delete[f !        File.Unknown => {          Runtime.CallDebugger["bad file in directory"L]; CONTINUE}]};    IF name.length # 0 THEN NotifyOps.AddToWriteableList[name];    END;    ENDCASE};  Delete: PUBLIC PROCEDURE [file: Handle] = {    MFileOps.ValidateHandle[file];    IF file.access # delete THEN ERROR Error[file, insufficientAccess];    WITH file.fo.location SELECT FROM      local => InternalDelete[file];     remote => RFile.Delete[h];     ENDCASE;    NotifyOps.TakeHandleOffList[file.fo, file, TRUE]};  DeleteWhenReleased: PUBLIC PROCEDURE [file: Handle] = {    MFileOps.ValidateHandle[file];    IF file.fo.lp.fp.dirInfo.type = directory THEN       ERROR Error[file, fileIsDirectory];    InternalDelete[file];    NotifyOps.TakeHandleOffList[file.fo, file, TRUE]};  GetObjectForReading: PUBLIC ENTRY PROCEDURE [    filter, name: LONG STRING, lastState: MFile.EnumerateState,    stopNow: BOOLEAN]    RETURNS [status: NotifyOps.AccessStatus, fo: FHandle,       state: MFile.EnumerateState] = {    ENABLE UNWIND => NULL;    id: File.File;    dirInfo: MDirectory.DirInfo;    [state, id, dirInfo, ] ¬ MDirectory.GetNext[      filter, name, filesOnly, lastState, stopNow !      MDirectory.DirError => {        ENABLE NameForError => RESUME [filter];        SELECT type FROM          volumeNotOpen => Error[NIL, volumeNotOpen];          invalidVolume => Error[NIL, noSuchVolume];          invalidPathName => Error[NIL, noSuchDirectory];          invalidFileName => Error[NIL, illegalName];          noRootDirectory => Error[NIL, noRootDirectory]          ENDCASE => Error[NIL, other]}];    IF stopNow OR name.length = 0 THEN RETURN[good, NIL, NIL];    IF dirInfo.readProtect THEN RETURN[protected, NIL, state];    [] ¬ MDirectory.ValidateFile[id]; -- if user proceeds, he wants this file anyway    fo ¬ GetFO[[local[id]], NIL, FALSE];    status ¬ good};  ReleaseFO: PUBLIC ENTRY PROCEDURE [fo: FHandle] = {    ENABLE UNWIND => NULL;    bpp: CARDINAL = Environment.bytesPerPage;    p: FHandle;    IF NotifyOps.notifyList.notifyAccess # ALL[FALSE] THEN {      fo.refCount ¬ fo.refCount - 1; RETURN};    IF NotifyOps.notifyList = fo THEN       NotifyOps.notifyList ¬ NotifyOps.notifyList.notifyList    ELSE {      p ¬ NotifyOps.notifyList;      WHILE p # NIL AND p.notifyList # fo DO p ¬ p.notifyList ENDLOOP;      IF p = NIL THEN ERROR ImplementationError["File not on Notification list"L]      ELSE p.notifyList ¬ fo.notifyList};    IF (fo.refCount ¬ fo.refCount - 1) # 0 THEN RETURN;    WITH fo.location SELECT FROM --assert no remote files on Notification List     local =>       IF ~fo.fileIsDeleted THEN {        length: LONG CARDINAL ¬ 0;        IF f.volumeID = Volume.systemID THEN length ¬ fo.lp.fp.length -- assert readable volume	ELSE SELECT Volume.GetStatus[f.volumeID] FROM          openReadWrite, openRead => length ¬ fo.lp.fp.length	  ENDCASE => {  -- volume closed	   Space.Kill[[fo.lp, MFileOps.leaderPages]];	   fo.lengthChanged ¬ FALSE;	   fo.tempFile ¬ FALSE}; -- at least we wont blow up...        MFileOps.UnmapLeader[fo.lp];        SELECT TRUE FROM          fo.tempFile => File.Delete[f !            File.Unknown => {	      Runtime.CallDebugger["bad file in directory"L]; CONTINUE}];          fo.lengthChanged => MFileOps.SetFileDataSize[f, (length + (bpp - 1))/bpp];          ENDCASE};      ENDCASE;    IF fHandles = fo THEN fHandles ¬ fo.next    ELSE {      prev: FHandle ¬ fHandles;      FOR t: FHandle ¬ prev.next, t.next UNTIL t = NIL DO        IF t = fo THEN {prev.next ¬ t.next; EXIT};        prev ¬ t;        REPEAT FINISHED => ERROR ImplementationError["Handle not in freeList"L];        ENDLOOP};    heap.FREE[@fo]};  LockedRename: PUBLIC ENTRY PROCEDURE [file: Handle, newName: LONG STRING] = {    ENABLE UNWIND => NULL;    oldName: STRING = [MFileOps.maxNameLength];    temp: STRING = [MFileOps.maxNameLength];    failure: MFile.ErrorCode;    WITH file.fo.location SELECT FROM      remote => RETURN WITH ERROR Error[file, fileIsRemote];      local => {        MFileOps.GetName[file.fo.lp, oldName];        MFileOps.SetDir[	  file.fo,  	  MDirectory.DirRename[            oldName, newName, f.fileID, [file.fo.lp.fp.dir, f.volumeID] !            MDirectory.DirError =>              SELECT type FROM                volumeNotOpen => {failure ¬ volumeNotOpen; GOTO Fail};                readOnlyDirectory => {failure ¬ volumeReadOnly; GOTO Fail};                invalidVolume => {failure ¬ noSuchVolume; GOTO Fail};                directoryFull => {failure ¬ directoryFull; GOTO Fail};                invalidFileName => {failure ¬ illegalName; GOTO Fail};                crossingVolumes => {failure ¬ crossingVolumes; GOTO Fail};                invalidPathName => {failure ¬ noSuchDirectory; GOTO Fail};                noRootDirectory => {failure ¬ noRootDirectory; GOTO Fail};                fileAlreadyExists => {failure ¬ fileAlreadyExists; GOTO Fail};                ENDCASE => {failure ¬ other; GOTO Fail}].fileID];        MFileOps.GetFilePart[from: newName, to: temp];        MFileOps.SetName[file.fo, temp];        MFile.SetTimes[file: file, write: Time.Current[]];        NotifyOps.AddToWriteableList[oldName];        EXITS Fail => RETURN WITH ERROR Error[file, failure]};      ENDCASE;};	  LockedSwapNames: PUBLIC ENTRY PROCEDURE [f1, f2: Handle, volume: Volume.ID] = {    ENABLE UNWIND => NULL;    oldName1: STRING = [MFileOps.maxNameLength];    oldName2: STRING = [MFileOps.maxNameLength];    f1Dir: File.File = [f1.fo.lp.fp.dir, volume];    f2Dir: File.File = [f2.fo.lp.fp.dir, volume];    failure: MFile.ErrorCode;    {    SELECT TRUE FROM      f1.fo.tempFile AND f2.fo.tempFile => {        location: MFileOps.FileLoc = f1.fo.location; 	f1.fo.location ¬ f2.fo.location; 	f2.fo.location ¬ location};      f1.fo.tempFile AND ~f2.fo.tempFile =>         SwapWithTemp[temp: f1, perm: f2, volume: volume];      f2.fo.tempFile AND ~f1.fo.tempFile =>         SwapWithTemp[temp: f2, perm: f1, volume: volume];      ENDCASE =>        BEGIN	now: Time.Packed;        MFileOps.GetName[f1.fo.lp, oldName1];        MFileOps.GetName[f2.fo.lp, oldName2];        WITH id1: f1.fo.location SELECT FROM	  local => WITH id2: f2.fo.location SELECT FROM	    local => MDirectory.Swap[              name1: oldName1, file1: id1.f.fileID, dir1: f1Dir, 	      name2: oldName2, file2: id2.f.fileID, dir2: f2Dir !          MDirectory.DirError =>            SELECT type FROM              volumeNotOpen => {failure ¬ volumeNotOpen; GOTO Fail};              readOnlyDirectory => {failure ¬ volumeReadOnly; GOTO Fail};              invalidVolume => {failure ¬ noSuchVolume; GOTO Fail};              invalidPathName => {failure ¬ noSuchDirectory; GOTO Fail};              directoryFull => {failure ¬ directoryFull; GOTO Fail};              invalidFileName => {failure ¬ illegalName; GOTO Fail};              noRootDirectory => {failure ¬ noRootDirectory; GOTO Fail};              ENDCASE => {failure ¬ other; GOTO Fail}];	   ENDCASE;	 ENDCASE;        MFileOps.SetName[f1.fo, oldName2];        MFileOps.SetName[f2.fo, oldName1];        MFileOps.SetDir[f1.fo, f2Dir.fileID];        MFileOps.SetDir[f2.fo, f1Dir.fileID];        now ¬ Time.Current[];        MFile.SetTimes[file: f1, write: now];        MFile.SetTimes[file: f2, write: now];        END;    EXITS Fail => RETURN WITH ERROR Error[NIL, failure]}};	  SwapWithTemp: INTERNAL PROCEDURE [temp, perm: Handle, volume: Volume.ID] =    BEGIN --assert temp and perm both local    name: STRING = [MFileOps.maxNameLength];    dir: File.File = [perm.fo.lp.fp.dir, volume];    MFileOps.GetName[perm.fo.lp, name];    temp.fo.tempFile ¬ FALSE;    MFileOps.SetDir[temp.fo, dir.fileID];    MFileOps.SetName[temp.fo, name];    WITH temp.fo.location SELECT FROM      local => {        MFileOps.AskPilotToMakePermanent[temp.fo, f];        MDirectory.SetID[          name: name, dir: dir, newFile: f.fileID !          MDirectory.DirError => Error[perm, noSuchFile]]};       ENDCASE;    WITH perm.fo.location SELECT FROM      local => MFileOps.AskPilotToMakeTemp[perm.fo, f];      ENDCASE;    perm.fo.tempFile ¬ TRUE;    MFile.SetTimes[file: temp, write: Time.Current[]];    MFile.SetTimes[file: perm, write: Time.Current[]];    END;	    MakeTemp: PUBLIC ENTRY PROCEDURE [file: Handle] = {    ENABLE UNWIND => NULL;    name: STRING = [MFile.maxNameLength];    {    MFileOps.GetName[file.fo.lp, name];    WITH file.fo.location SELECT FROM      local => {        MDirectory.DirDelete[          f, file.fo.lp ! MDirectory.DirError => GOTO Fail];        MFileOps.AskPilotToMakeTemp[file.fo, f]};      ENDCASE => Error[file, fileIsRemote];    file.fo.tempFile ¬ TRUE;    MFile.SetTimes[file: file, write: Time.Current[]];    EXITS Fail => RETURN WITH ERROR Error[file, other]}};      RenameTemp: PUBLIC ENTRY PROCEDURE [file: Handle, name: LONG STRING] = {    ENABLE UNWIND => NULL;    temp: File.ID;    dir: File.File;    exists: BOOLEAN ¬ TRUE;    failure: MFile.ErrorCode;    {[] ¬ MDirectory.LookUp[      name, TRUE ! MDirectory.DirError => {exists ¬ FALSE; CONTINUE}];    IF exists THEN RETURN WITH ERROR Error[file, fileAlreadyExists];    [temp, dir] ¬ MDirectory.Insert[name, 0, [] ! MDirectory.DirError =>           SELECT type FROM            directoryFull => {failure ¬ directoryFull; GOTO Fail};            invalidFileName, invalidVolume => {failure ¬ illegalName; GOTO Fail};            invalidPathName => {failure ¬ noSuchDirectory; GOTO Fail};            noRoomOnVolume => {failure ¬ noRoomOnVolume; GOTO Fail};            protectedDirectory => {failure ¬ protectionFault; GOTO Fail};            ENDCASE => {failure ¬ other; GOTO Fail}];    MFileOps.SetDir[file.fo, dir.fileID];    MFileOps.SetName[file.fo, name];    BEGIN ENABLE UNWIND => MDirectory.DirDelete[[temp, dir.volumeID], file.fo.lp ! MDirectory.DirError => CONTINUE];    file.fo.tempFile ¬ FALSE;    WITH file.fo.location SELECT FROM      local => {        MFileOps.AskPilotToMakePermanent[file.fo, f];        MFile.SetTimes[file: file, write: Time.Current[]];        MDirectory.SetID[          name: name, dir: dir, newFile: f.fileID !          MDirectory.DirError => {            File.Delete[[temp, dir.volumeID]]; 	    failure ¬ other; GOTO Fail}]};      ENDCASE;    File.Delete[[temp, dir.volumeID]];    END; -- ENABLE    EXITS Fail => RETURN WITH ERROR Error[file, failure]}};        IsFileDeleted: PUBLIC ENTRY PROCEDURE [fo: FHandle] RETURNS [BOOLEAN] = {      ENABLE UNWIND => NULL; RETURN[fo.fileIsDeleted]};          IncrRefCount: PUBLIC ENTRY PROCEDURE [fo: FHandle] = {      ENABLE UNWIND => NULL; fo.refCount ¬ fo.refCount + 1};  EnumerateFHandles: PUBLIC ENTRY PROCEDURE [       proc: PROCEDURE [FHandle] RETURNS [BOOLEAN]]    RETURNS [fo: FHandle] =    BEGIN    FOR fo ¬ fHandles, fo.next UNTIL fo = NIL DO      IF proc[fo] THEN EXIT;      ENDLOOP;    END;  END.
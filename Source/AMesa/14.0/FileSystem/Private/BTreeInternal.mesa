-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. --  File: BTreeInternal.mesa; last edited by: --  KAM,	  4-Apr-85 16:19:50--  LGR,	 11-Apr-83 11:35:31--  WDE,	 26-Jul-83 18:23:14DIRECTORY  BTree USING [defaultValueSize, maxNameLength, Value, ValueSize],  Environment USING [PageCount, wordsPerPage],  File USING [File, nullFile],  MFile USING [Handle],  Space USING [Interval, nullInterval, Usage];BTreeInternal: DEFINITIONS =  BEGIN  Tree: TYPE = LONG POINTER TO TreeObject;    TreeObject: PUBLIC TYPE = MONITORED RECORD [    base: PageHandle ¬ NIL,    top: PagePointer ¬ nilPagePointer,    size: Environment.PageCount ¬ treeIncrement,  -- in pages    lpSize: CARDINAL ¬ 0,  -- in pages    file: MFile.Handle ¬ NIL,  -- MFile handle of tree    cap: File.File ¬ File.nullFile,  -- cap. where BTree is stored    space: Space.Interval ¬ Space.nullInterval,  -- space BTree is mapped to    spaceReadOnly: BOOLEAN ¬ FALSE, -- the above space is read only    usage: Space.Usage,    pCache: PCache ¬ NIL,  -- pointer to cached info on enumeration    valueSize: BTree.ValueSize ¬ BTree.defaultValueSize,  -- size of value in tree    autoForceOut: BOOLEAN ¬ TRUE];  -- force out after modification  bTreePage: CARDINAL = 2;  -- number of disk pages in a b-tree page  -- if you change this, check the size of  -- the field Page.size  maxTreeSize: CARDINAL = 512;  -- (disk pages)  treeIncrement: CARDINAL = 8;  -- (b-tree pages)  -- Cached information on b-tree enumeration  PCache: TYPE = LONG POINTER TO Cache;  Cache: TYPE = RECORD [    lastName: StringBody ¬ [length: 0, maxlength: BTree.maxNameLength, text:],    array: PACKED ARRAY [0..BTree.maxNameLength) OF CHARACTER ¬ ALL[' ],    lastpP: PagePointer ¬ nilPagePointer,    lastpE: EntryHandle ¬ NIL];  PageHandle: TYPE = LONG BASE POINTER TO Page;  PagePointer: TYPE = PageHandle RELATIVE LONG POINTER TO Page;  nilPagePointer: PagePointer = LOOPHOLE[377777B];  firstPagePointer: PagePointer = LOOPHOLE[LONG[0]];  Page: TYPE = MACHINE DEPENDENT RECORD [    size(0:0..9): [0..512],  -- number of words used in this page    free(0:10..10): BOOLEAN,  -- TRUE if page is not in use    sizeValue(0:11..15): [0..32),  -- first page only - zero means default    top(1): PagePointer,  -- first page only - points to the root     parent(3): PagePointer,  -- the parent of this page    lastPointer(5): PagePointer,  -- the last pointer in this page    entries(emptySize:0..(bTreePage*Environment.wordsPerPage - emptySize)*16 - 1):      ARRAY [0..bTreePage*Environment.wordsPerPage - emptySize) OF UNSPECIFIED];  -- the entries  EntryHandle: TYPE = LONG POINTER TO Entry;  Entry: TYPE = UNSPECIFIED;    ValuePointer: TYPE = LONG POINTER TO ARRAY OF CARDINAL;  --Entry: TYPE = MACHINE DEPENDENT RECORD [  --  value: ARRAY [0.. tree.sizeValue) OF CARDINAL,  --  pointer: PagePointer,  --  name: StringBody ¬ [length: 0, maxlength: BTree.maxNameLength, text:]];  EntryName: PROCEDURE [tree: Tree, entry: EntryHandle]    RETURNS [LONG STRING] = INLINE {    RETURN[LOOPHOLE[entry + tree.valueSize + SIZE[PagePointer]]]};  EntryPointer: PROCEDURE [tree: Tree, entry: EntryHandle]    RETURNS [PagePointer] = INLINE {    RETURN[LOOPHOLE[entry + tree.valueSize, LONG POINTER TO PagePointer]­]};      EntryPointerPointer: PROCEDURE [tree: Tree, entry: EntryHandle]    RETURNS [LONG POINTER TO PagePointer] = INLINE {    RETURN[LOOPHOLE[entry + tree.valueSize]]};      EntrySize: PROCEDURE [tree: Tree, p: EntryHandle] RETURNS [CARDINAL] =    -- returns the size of an entry    INLINE {RETURN[Overhead[tree] + SIZE[      StringBody[BTreeInternal.EntryName[tree, p].length]]]};          EntryValue: PROCEDURE [tree: Tree, entry: EntryHandle]    RETURNS [ValuePointer] = INLINE {RETURN[LOOPHOLE[entry]]};      FirstEntry: PROCEDURE [d: PageHandle] RETURNS [EntryHandle] =    -- return pointer to first entry of this page    INLINE {RETURN[LOOPHOLE[@d.entries]]};      FirstFreeEntry: PROCEDURE [d: PageHandle] RETURNS [EntryHandle] =    -- return pointer to first free entry of this page    INLINE {RETURN[LOOPHOLE[d + d.size]]};      NextEntry: PROCEDURE [tree: Tree, p: EntryHandle]    RETURNS [EntryHandle] =    -- return pointer to next entry in this page    INLINE {RETURN[p + Overhead[tree] + SIZE[      StringBody[BTreeInternal.EntryName[tree, p].length]]]};       Overhead: PROCEDURE [tree: Tree] RETURNS [CARDINAL] =    -- returns the overhead size of an entry    INLINE {RETURN[tree.valueSize + SIZE[PagePointer]]};    PagePointerFromEntryHandle: PROCEDURE [tree: Tree, pE: EntryHandle]    RETURNS [pP: PagePointer] = INLINE {    bpp: LONG CARDINAL = bTreePage * Environment.wordsPerPage;    RETURN[LOOPHOLE[((pE - tree.base)/bpp) * bpp]]};      emptySize: CARDINAL = 7;  -- the size of an empty page    -- internal procedures and variables used by BTree implementation    CheckVolumeAccess: PROCEDURE [tree: Tree];  CopyValue: PROCEDURE [    to: BTree.Value, from: ValuePointer, size: BTree.ValueSize]    RETURNS [targetTooSmall: BOOLEAN];  debug: READONLY BOOLEAN;  FlushGNCache: PROCEDURE [tree: Tree];  heap: READONLY UNCOUNTED ZONE;  InsertInNode: PROCEDURE [    tree: Tree, p: PagePointer, n: LONG STRING, c: ValuePointer,    after: PagePointer] RETURNS [ok, noRoom: BOOLEAN, ent: EntryHandle];  InternalFind: PROCEDURE [tree: Tree, name: LONG STRING]    RETURNS [      ok: BOOLEAN, value: ValuePointer, page: PagePointer, ent: EntryHandle];  InternalValidateBTree: PROCEDURE [tree: Tree];  LastEntry: PROCEDURE [tree: Tree, d: PageHandle] RETURNS [p: EntryHandle];  MapInternal: PROCEDURE [tree: Tree];  MoveLongString: PROCEDURE [to, from: LONG STRING];  SnapShot: PROCEDURE [tree: Tree];  Successor: PROCEDURE [tree: Tree, pE: EntryHandle]    RETURNS [pg, after: PagePointer];    END.
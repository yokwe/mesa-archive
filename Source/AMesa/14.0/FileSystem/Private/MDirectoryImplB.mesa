-- Copyright (C) 1981, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: MDirectoryImplB.mesa - last edit -- PXK    ,	17-Dec-81 12:40:37-- LXR    ,	26-Sep-83 16:18:01-- RXJ     ,	26-Nov-81 11:34:23-- DWE    ,	 5-Aug-83 17:05:54-- KAM  ,	17-Jul-84 12:15:28DIRECTORY  BTree USING [    Delete, Empty, Find, Insert, maxNameLength, ReadOnly, Remove,    SwapValue, Tree, Value, VolumeNotOpen],  File USING [    Create, Delete, File, ID, MakePermanent, nullFile,    nullID, PageCount, SetSize],  MDirectory USING [    CantFindPath, directoryZone, DirError, DirInfo, ErrorCode, EvalInDir,    FindFirstWriteable, FreeTree, GetTree, IsFilename, IsProtected,     LegalName, lock, LookUpDirectory, MapCacheEntry, MarkChanged,    MarkChanging, MValue, MValueRec, MValueToValue, NoRootDir, nullValue,    SearchDirTree, searchPathFile, SplitName, ValidateFile, ValueToMValue],  MesaDEFileTypes USING [tDirectory, tNormal, tRootDirectory],  MFile USING [maxNameLength, Type],  MFileOps USING [    GetName, InitLeader, InvalidLeader, LeaderPage, leaderPages,    MapLeader, UnmapLeader],    MUsage USING [mFileDirectory],  Runtime USING [CallDebugger],  SpecialBTree USING [MakeFromCapa, Unmapped],  String USING [EmptyString, EquivalentString],  Volume USING [    GetStatus, ID, InsufficientSpace, NotOpen, RootDirectoryError,     RemoveRootFile, systemID];MDirectoryImplB: MONITOR LOCKS MDirectory.lock  IMPORTS    File, BTree, MDirectory, MFileOps, Runtime, SpecialBTree, String,    Volume  EXPORTS MDirectory =  BEGIN  ASSERT: BOOLEAN [TRUE..TRUE] = (MFile.maxNameLength = BTree.maxNameLength);  debugging: BOOLEAN ¬ FALSE;  Tree: TYPE = BTree.Tree;  -- Directory Procedures  -- fileName may be completely qualified or may be evaluated in the current search path  -- oldName, and newName must contain no directory information  -- newDirectory will be evaluated in the current search path if necessary  DirCreateDirectory: PUBLIC ENTRY PROCEDURE [path: LONG STRING]    RETURNS [dir: File.File] = {    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    RETURN[      MDirectory.LookUpDirectory[        path, TRUE ! MDirectory.NoRootDir => RESUME ]]};  DirDelete: PUBLIC ENTRY PROCEDURE [file: File.File, lp: MFileOps.LeaderPage] =    BEGIN    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      MDirectory.NoRootDir => ERROR MDirectory.DirError[noRootDirectory];      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    fileName: STRING ¬ [MFile.maxNameLength];    EmptyDir: PROCEDURE [bTree: Tree] = {      IF ~BTree.Empty[bTree] THEN MDirectory.DirError[directoryNotEmpty]};    DeleteFile: PROCEDURE [bTree: Tree] = {      MFileOps.GetName[lp, fileName];      [] ¬ BTree.Remove[tree: bTree, name: fileName, value: NIL]};    IF lp.fp.dirInfo.type = directory THEN      BEGIN      FOR i: CARDINAL IN [0..MDirectory.searchPathFile.length) DO        IF file = MDirectory.searchPathFile[i] THEN          ERROR MDirectory.DirError[deletingDirectoryOnSearchPath];        ENDLOOP;      MDirectory.EvalInDir[file, EmptyDir];      END;    IF lp.fp.dir = file.fileID THEN -- root directory      BEGIN      IF file.volumeID = Volume.systemID THEN ERROR MDirectory.DirError[unknown]      ELSE Volume.RemoveRootFile[        type: MesaDEFileTypes.tRootDirectory, volume: file.volumeID ! 	Volume.RootDirectoryError => CONTINUE;	Volume.NotOpen => ERROR MDirectory.DirError[volumeNotOpen]]      END    ELSE {      MDirectory.MarkChanging[file.volumeID];      MDirectory.EvalInDir[[lp.fp.dir, [file.volumeID]], DeleteFile];      MDirectory.MarkChanged[file.volumeID]};    END;  Insert: PUBLIC ENTRY PROCEDURE [    fileName: LONG STRING, initialSize: LONG CARDINAL,    dirInfo: MDirectory.DirInfo]    RETURNS [id: File.ID ¬ File.nullID, dir: File.File ¬ File.nullFile] =    BEGIN    ENABLE {      MDirectory.NoRootDir => ERROR MDirectory.DirError[noRootDirectory];      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      UNWIND => NULL};    name, pathName: LONG STRING ¬ NIL;    InsertFile: PROCEDURE [bTree: Tree] =      BEGIN      cap: File.File ¬ File.nullFile;      rec: MDirectory.MValueRec;      value: MDirectory.MValue = @rec;      ok, noRoom: BOOLEAN;      IF BTree.Find[bTree, name, MDirectory.MValueToValue[value]] THEN {        IF MDirectory.ValidateFile[[value.fID, dir.volumeID]] THEN {          id ¬ value.fID;          IF Volume.GetStatus[dir.volumeID] = openReadWrite THEN            File.SetSize[[id, dir.volumeID], initialSize];          RETURN}        ELSE [] ¬ BTree.Remove[bTree, name, NIL]};      cap ¬ File.Create[        volume: dir.volumeID, initialSize: MAX[initialSize, 1], 	type: MesaDEFileTypes.tNormal !        Volume.InsufficientSpace => MDirectory.DirError[noRoomOnVolume]];      BEGIN      ENABLE UNWIND => File.Delete[cap];      rec ¬ [cap.fileID, dirInfo]; -- changes value      MDirectory.MarkChanging[dir.volumeID];      [ok, noRoom] ¬ BTree.Insert[bTree, name, MDirectory.MValueToValue[value]];      IF ~ok THEN        SELECT noRoom FROM          TRUE => MDirectory.DirError[directoryFull];          FALSE => {            Runtime.CallDebugger["File has appeared in directory while locked"L];            MDirectory.DirError[unknown]};          ENDCASE;      File.MakePermanent[cap];      MDirectory.MarkChanged[dir.volumeID];      id ¬ cap.fileID;      END;  -- enable      END;    IF String.EmptyString[fileName] THEN RETURN;    MDirectory.LegalName[fileName];    [name, pathName] ¬ MDirectory.SplitName[fileName];    {    ENABLE      UNWIND => {        MDirectory.directoryZone.FREE[@pathName];        MDirectory.directoryZone.FREE[@name]};    firstDir: File.File ¬ File.nullFile;    needFirstWriteable: BOOLEAN =       fileName[0] # '< AND MDirectory.searchPathFile # NIL;    IF ~MDirectory.IsFilename[name] THEN MDirectory.DirError[invalidFileName];    IF needFirstWriteable THEN       firstDir ¬ MDirectory.FindFirstWriteable[];    dir ¬ MDirectory.SearchDirTree[      name: pathName,      startDir: IF needFirstWriteable THEN firstDir ELSE File.nullFile,      createIfMissing: FALSE !      MDirectory.CantFindPath => MDirectory.DirError[invalidPathName]];    IF Volume.GetStatus[dir.volumeID] # openReadWrite THEN      MDirectory.DirError[volumeNotOpen];    IF dir # File.nullFile THEN       IF MDirectory.IsProtected[dir] THEN MDirectory.DirError[protectedDirectory]       ELSE MDirectory.EvalInDir[dir, InsertFile]};    MDirectory.directoryZone.FREE[@pathName];    MDirectory.directoryZone.FREE[@name];    END;  DirRename: PUBLIC ENTRY PROCEDURE [    oldName, newName: LONG STRING, file: File.ID, dir: File.File]    RETURNS [newDir: File.File ¬ File.nullFile] =    BEGIN OPEN MDirectory;    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      NoRootDir => ERROR MDirectory.DirError[noRootDirectory];      UNWIND => NULL};    ok, noRoom: BOOLEAN;    rec: MDirectory.MValueRec;    value: BTree.Value = MDirectory.MValueToValue[@rec];    name, pathName: LONG STRING ¬ NIL;    oldTree, newTree: Tree;    LegalName[oldName];    LegalName[newName];    [name, pathName] ¬ SplitName[newName];    {    ENABLE UNWIND => {directoryZone.FREE[@name]; directoryZone.FREE[@pathName]};    IF ~IsFilename[name] THEN MDirectory.DirError[invalidFileName];    newDir ¬ LookUpDirectory[pathName, FALSE];    IF newDir = File.nullFile THEN MDirectory.DirError[invalidPathName];    IF dir.volumeID # newDir.volumeID      THEN ERROR MDirectory.DirError[crossingVolumes];    oldTree ¬ GetTree[dir];    newTree ¬ GetTree[newDir ! UNWIND => FreeTree[oldTree]];    BEGIN    ENABLE UNWIND => {FreeTree[oldTree]; FreeTree[newTree]};    MDirectory.MarkChanging[dir.volumeID];    IF oldTree = newTree AND String.EquivalentString[name, oldName] THEN {      -- changing capitalization on file      ok ¬ BTree.Find[oldTree, oldName, value];      IF ~ok OR MDirectory.ValueToMValue[value].fID # file THEN {        MDirectory.MarkChanged[dir.volumeID]; MDirectory.DirError[fileNotFound]};      ok ¬ BTree.Remove[oldTree, oldName, value];      [ok, noRoom] ¬ BTree.Insert[tree: newTree, name: name, value: value];      IF NOT ok THEN        SELECT noRoom FROM          TRUE => MDirectory.DirError[directoryFull];          FALSE => MDirectory.DirError[unknown];          ENDCASE}    ELSE {      [ok, noRoom] ¬ BTree.Insert[        tree: newTree, name: name, value: MDirectory.nullValue];      IF ~ok THEN        SELECT noRoom FROM          TRUE => MDirectory.DirError[directoryFull];          FALSE => MDirectory.DirError[fileAlreadyExists];          ENDCASE;      {      ENABLE UNWIND => [] ¬ BTree.Remove[newTree, name, NIL];      ok ¬ BTree.Find[oldTree, oldName, value];      IF ~ok OR MDirectory.ValueToMValue[value].fID # file THEN {        MDirectory.MarkChanged[dir.volumeID]; MDirectory.DirError[fileNotFound]};      ok ¬ BTree.Remove[oldTree, oldName, value]};  -- end enable       ok ¬ BTree.SwapValue[tree: newTree, name: name, newValue: value,         oldValue: NIL]};  -- end ELSE    END;  -- end enable and ELSE    MDirectory.MarkChanged[dir.volumeID];    FreeTree[oldTree];    FreeTree[newTree]};  -- end enable    directoryZone.FREE[@name];    directoryZone.FREE[@pathName];    IF ~ok THEN      Runtime.CallDebugger[        "File System error: File disappeared from directory while locked"L];    END;  Swap: PUBLIC ENTRY PROCEDURE [    name1, name2: LONG STRING, file1, file2: File.ID, dir1, dir2: File.File] =    BEGIN OPEN MDirectory;    ENABLE {      SpecialBTree.Unmapped => {MDirectory.MapCacheEntry[tree]; RESUME };      BTree.ReadOnly => ERROR MDirectory.DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR MDirectory.DirError[volumeNotOpen];      NoRootDir => ERROR MDirectory.DirError[noRootDirectory];      UNWIND => NULL};    ok1, ok2: BOOLEAN;    rec1, rec2: MDirectory.MValueRec;    value1: BTree.Value = MDirectory.MValueToValue[@rec1];    value2: BTree.Value = MDirectory.MValueToValue[@rec2];    tree1, tree2: Tree;    LegalName[name1];    LegalName[name2];    tree1 ¬ GetTree[dir1];    tree2 ¬ GetTree[dir2 ! UNWIND => FreeTree[tree1]];    BEGIN    ENABLE UNWIND => {FreeTree[tree1]; FreeTree[tree2]};    ok1 ¬ BTree.Find[tree1, name1, value1];    ok2 ¬ BTree.Find[tree2, name2, value2];    IF ~ok1 OR ~ok2 THEN MDirectory.DirError[fileNotFound];    ok1 ¬ BTree.SwapValue[      tree: tree1, name: name1, newValue: value2, oldValue: NIL];    ok2 ¬ BTree.SwapValue[      tree: tree2, name: name2, newValue: value1, oldValue: NIL];    END;    FreeTree[tree1];    FreeTree[tree2];    END;  -- Utilities  CreateNewSubdirectory: PUBLIC PROCEDURE [    dir: File.File, name: LONG STRING]    RETURNS [newDir: File.File ¬ File.nullFile] =    BEGIN    bTree: Tree;    IF ~MDirectory.IsFilename[name] THEN MDirectory.DirError[invalidFileName];    bTree ¬ MDirectory.GetTree[dir];    newDir ¬ InternalCreateSubDir[      bTree, name, dir ! UNWIND => MDirectory.FreeTree[bTree]];    MDirectory.FreeTree[bTree];    END;  InternalCreateSubDir: PUBLIC PROCEDURE [    dir: BTree.Tree, name: LONG STRING, dirID: File.File]    RETURNS [newDir: File.File ¬ File.nullFile] =    BEGIN    ok, noRoom: BOOLEAN;    lp: MFileOps.LeaderPage;    rec: MDirectory.MValueRec;    value: BTree.Value = MDirectory.MValueToValue[@rec];    IF ~MDirectory.IsFilename[name] THEN MDirectory.DirError[invalidFileName];    MDirectory.MarkChanging[dirID.volumeID];    [ok, noRoom] ¬ BTree.Insert[dir, name, MDirectory.nullValue];    IF ~ok THEN      SELECT noRoom FROM        TRUE => MDirectory.DirError[directoryFull];        FALSE => {	  MDirectory.MarkChanged[dirID.volumeID];          MDirectory.DirError[fileAlreadyExists]};        ENDCASE;    MDirectory.MarkChanged[dirID.volumeID];    newDir ¬ File.Create[      volume: dirID.volumeID, initialSize: 5, type: MesaDEFileTypes.tDirectory !      Volume.InsufficientSpace => {        [] ¬ BTree.Remove[dir, name, NIL];	MDirectory.MarkChanged[dirID.volumeID];	MDirectory.DirError[noRoomOnVolume]}];    {    ENABLE UNWIND => {File.Delete[newDir]; newDir ¬ File.nullFile};    BTree.Delete[SpecialBTree.MakeFromCapa[ -- initialize to empty BTree      cap: newDir,      usage: MUsage.mFileDirectory,      lpSize: MFileOps.leaderPages,       valueSize: SIZE[MDirectory.MValueRec]]];     lp ¬ MFileOps.MapLeader[newDir ! MFileOps.InvalidLeader => RESUME ]; -- can be safely mapped for write because not yet in directory structure     MFileOps.InitLeader[lp, dirID.fileID, directory, name, 0];    lp.fp.dirInfo.writeProtect ¬ TRUE;    MFileOps.UnmapLeader[lp];    rec ¬ [newDir.fileID, [type: directory, writeProtect: TRUE]];    ok ¬ BTree.SwapValue[      tree: dir, name: name, newValue: value, oldValue: NIL];    IF ok THEN File.MakePermanent[newDir]    ELSE {      Runtime.CallDebugger["Implementation Error in File System"L];      [] ¬ BTree.Remove[dir, name, NIL];      File.Delete[newDir];      newDir ¬ File.nullFile}};  -- end of ENABLE    END;  StartMDirectoryImplB: PUBLIC PROCEDURE = {};  -- cause start trap  END.. of MDirectoryImplB
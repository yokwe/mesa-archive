-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File; [Igor]<Emerson>FileSystem>Private>MScavengeImplB.mesa - last edit by-- PXK    ,	21-Jan-82 16:23:14-- LXR    ,	28-Dec-83 10:09:34-- DWE    	28-Jul-83 12:09:46DIRECTORY  Environment USING [wordsPerPage],  File USING [    Create, Error, File, GetAttributes, GetSize, ID, MissingPages,     nullFile, nullID, PageCount, PageNumber, SetSize, Type, Unknown],  FileTypes USING [tUntypedFile],  Format USING [LongDecimal],  MesaDEFileTypes USING [Directory, MesaDEFileType, tNormal],  MFileOps USING [    GetName, InitLeader, InvalidLeader, LeaderPage, MapLeader, maxNameLength,    UnmapLeader],  MScavenge USING [Error],  MScavengeOps USING [Handle],  MUsage USING [mFileScavenge],  Runtime USING [CallDebugger],  Scavenger USING [    DeleteOrphanPage, Error, FileEntry, GetLog,    Header, MakeFileList, OrphanHandle,    Problem, ReadBadPage, ReadOrphanPage, ReplaceBadPage, RewritePage],  Space USING [    CopyOut, GetMapUnitAttributes, Interval, LongPointerFromPage, Map, MapAt,    PageFromLongPointer, PageNumber, Unmap, UnmapAt, Window],  String USING [AppendLongNumber, AppendNumber, AppendOctal, AppendString],  Volume USING [    GetAttributes, ID, InsufficientSpace, NotOpen, nullID, systemID, Unknown];MScavengeImplB: PROGRAM  IMPORTS    File, Format, MFileOps, MScavenge, Runtime, Scavenger, Space, String, Volume  EXPORTS MScavengeOps =  BEGIN  -- Global "Constants"  spaceHSize: CARDINAL = 1;  pilotLogSpaceSize: CARDINAL = 1;  unfillableHoleSize: CARDINAL ¬ 50;  -- somewhat arbitrary threshold beyond which holes probably shouldn't be  -- filled because they represent a random page with a damaged label. This  -- is a global variable so it can be adjusted from the debugger if necessary.  retryCount: CARDINAL ¬ 10;  -- number of read retries on unreadable page  -- Exported procedures  -- ClosePilotLogFile:  Delete the pilotLogFile space.  ClosePilotLogFile: PUBLIC PROC [pilotLogSpace: Space.Interval] =    BEGIN pilotLogSpace.pointer ¬ Space.Unmap[pilotLogSpace.pointer]; END;  -- ClosePilotLogFile  -- GetWords:  Get the next count words from the Pilot scavenger log.  GetWords: PUBLIC PROC [    toPointer, bufferPointer: LONG POINTER TO UNSPECIFIED,    currentWord, count: CARDINAL, pilotLogSpace: Space.Interval]    RETURNS [nextWord: CARDINAL] =    BEGIN    pilotLogWindow: Space.Window;    THROUGH [0..count) DO      IF currentWord >= (Environment.wordsPerPage*pilotLogSpaceSize) THEN {        pilotLogWindow ¬ Space.GetMapUnitAttributes[pilotLogSpace.pointer].window;        pilotLogWindow.base ¬ pilotLogWindow.base + pilotLogSpaceSize;        currentWord ¬ 0;        pilotLogSpace ¬ Space.UnmapAt[pilotLogSpace.pointer];        pilotLogSpace ¬ Space.MapAt[at: pilotLogSpace, window: pilotLogWindow,	  access: readOnly, usage: MUsage.mFileScavenge];        };      toPointer­ ¬ (bufferPointer + currentWord)­;      toPointer ¬ toPointer + 1;      currentWord ¬ currentWord + 1;      ENDLOOP;    nextWord ¬ currentWord;    END;  -- GetWords  -- HandleProblems:  Scan the Pilot Scavenger log for Problem entries, report  -- any found, and repair the damaged files if in repair mode.  HandleProblems: PUBLIC PROC [context: MScavengeOps.Handle]    RETURNS [garbage: File.File] =    BEGIN    file: File.File;    fileEntryCopy: Scavenger.FileEntry;    fileEntry: POINTER TO Scavenger.FileEntry ¬ @fileEntryCopy;    garbageCount: File.PageCount ¬ 0;    nextWord: CARDINAL ¬ SIZE[Scavenger.Header];    numberOfFiles: LONG CARDINAL;    pilotLogPointer: LONG POINTER TO UNSPECIFIED;    pilotLogSpace: Space.Interval;    problemCopy: Scavenger.Problem;    problem: POINTER TO Scavenger.Problem ¬ @problemCopy;    repairProblems: BOOLEAN;    spaceH: Space.Interval ¬ Space.Map[window: [file: File.nullFile, base: NULL, count: spaceHSize], usage: MUsage.mFileScavenge];    spacePage: Space.PageNumber;    type: File.Type;    incompleteLog: BOOLEAN;    spacePage ¬ Space.PageFromLongPointer[spaceH.pointer];    garbage ¬ File.nullFile;    [pilotLogPointer, pilotLogSpace] ¬ OpenPilotLogFile[context];    [numberOfFiles, incompleteLog] ¬ CheckHeader[context, pilotLogPointer];    FOR counter: LONG CARDINAL ¬ 1, counter + 1 WHILE counter <= numberOfFiles DO      nextWord ¬ GetWords[        fileEntry, pilotLogPointer, nextWord, SIZE[Scavenger.FileEntry],        pilotLogSpace];      IF fileEntry.numberOfProblems # 0 THEN {        [file, type, repairProblems] ¬ LogInfo[context, fileEntry];        THROUGH [0..fileEntry.numberOfProblems) DO          nextWord ¬ GetWords[            problem, pilotLogPointer, nextWord, SIZE[Scavenger.Problem],            pilotLogSpace];          [garbage, garbageCount] ¬ ProcessProblem[            context, fileEntry, problem, type, spaceH, spacePage, garbage,            garbageCount, repairProblems];          ENDLOOP};      ENDLOOP;    IF garbage # File.nullFile THEN File.SetSize[garbage, garbageCount];    -- shrink back to just the pages needed.    ClosePilotLogFile[pilotLogSpace];    spaceH.pointer ¬ Space.Unmap[spaceH.pointer];    IF incompleteLog THEN      Runtime.CallDebugger[        "Incomplete Pilot Scavenger log. Please reinvoke the Pilot scavenger and reboot."L];    END;  -- HandleProblems  -- LogFileCapability:  Log a File.File in the form:  -- "FID[aaaaaaB, bbbbbbB, ccccccB, ddddddB, eeeeeeB, ffffffB, ggggggB]"  LogFileCapability: PUBLIC PROC [context: MScavengeOps.Handle, file: File.File] =    BEGIN    fileCapString: STRING ¬      "FID[aaaaaaB, bbbbbbB, ccccccB, ddddddB, eeeeeeB, ffffffB, ggggggB]"L;    RepFID: TYPE = RECORD [ARRAY [0..sizeFID) OF CARDINAL];    rep: RepFID ¬ LOOPHOLE[file, RepFID];    sizeFID: CARDINAL = SIZE[File.File];    fileCapString.length ¬ 4;    FOR i: CARDINAL IN [0..sizeFID) DO      String.AppendOctal[fileCapString, rep[i]];      IF i ~= sizeFID - 1 THEN String.AppendString[fileCapString, ", "L];      ENDLOOP;    context.logProc[fileCapString];    END;  -- LogFileCapability  -- OpenPilotLogFile:  Map the Pilot scavenger log into a space and return  -- a pointer to the header information.  OpenPilotLogFile: PUBLIC PROC [context: MScavengeOps.Handle]    RETURNS [      bufferPointer: LONG POINTER TO UNSPECIFIED, pilotLogSpace: Space.Interval] =    BEGIN    IF context.volume = Volume.nullID THEN context.volume ¬ Volume.systemID;    context.pilotLogFile ¬ File.nullFile;    context.pilotLogFile ¬ Scavenger.GetLog[      context.volume ! Volume.Unknown => CONTINUE];    IF context.pilotLogFile = File.nullFile THEN      context.pilotLogFile ¬ Scavenger.MakeFileList[        context.volume, context.volume ! Volume.Unknown => CONTINUE];    IF context.pilotLogFile = File.nullFile THEN      ERROR MScavenge.Error[internalFailure];    -- for now, really should get Pilot to enumerate the IDs on this volume    pilotLogSpace ¬ Space.Map[      window: [context.pilotLogFile, 0, pilotLogSpaceSize],      access: readOnly, usage: MUsage.mFileScavenge];    bufferPointer ¬ pilotLogSpace.pointer;    END;  -- OpenPilotLogFile  -- Internal Procs  -- AllocGarbagePage:  Allocate one page in Garbage.$ file for a copy of an  -- orphan page.  AllocGarbagePage: PROC [    garbage: File.File, garbageCount: File.PageCount, context: MScavengeOps.Handle]    RETURNS [      newGarbage: File.File, newGarbageCount: File.PageCount,      garbageWindow: Space.Window, noRoom: BOOLEAN] =    BEGIN    leaderPageSize: CARDINAL = 1;  -- temporary expedient    increment: CARDINAL ¬ 5;    initialSize: CARDINAL ¬ 5 + leaderPageSize;    noRoom ¬ FALSE;    garbageWindow ¬ [garbage, garbageCount, 1];    newGarbage ¬ garbage;    newGarbageCount ¬ garbageCount;    IF newGarbage = File.nullFile THEN {      lp: MFileOps.LeaderPage;      garbageWindow.file ¬ newGarbage ¬ File.Create[        context.volume, initialSize, MesaDEFileTypes.tNormal !        Volume.InsufficientSpace =>          IF (initialSize ¬ initialSize - 1) > leaderPageSize THEN RETRY          ELSE GOTO NoRoomExit];      -- insert Garbage.$ later into SysDir (in ValidateSysDir) when it's safe to do so      garbageWindow.base ¬ newGarbageCount ¬ leaderPageSize;      lp ¬ MFileOps.MapLeader[newGarbage ! MFileOps.InvalidLeader => RESUME ];      MFileOps.InitLeader[lp, File.nullID, binary, "Garbage.$"L, 0];      MFileOps.UnmapLeader[lp]}    ELSE      IF File.GetSize[newGarbage] <= newGarbageCount THEN        File.SetSize[          newGarbage, newGarbageCount + increment !          Volume.InsufficientSpace =>            IF (increment ¬ increment - 1) > 0 THEN RETRY ELSE GOTO NoRoomExit];    RETURN;    EXITS      NoRoomExit => {        noRoom ¬ TRUE;        context.logProc["**CANNOT** be added to Garbage.$ (no room on volume)."L];        RETURN};    END;  -- AllocGarbagePage  -- CheckHeader:  Check the entries in the Pilot Scavenger log header, and  -- return the number of files.  CheckHeader: PROC [    context: MScavengeOps.Handle, bufferPointer: LONG POINTER TO UNSPECIFIED]    RETURNS [numberOfFiles: LONG CARDINAL, incompleteLog: BOOLEAN] =    BEGIN    header: LONG POINTER TO Scavenger.Header ¬ LOOPHOLE[bufferPointer];    IF header.volume # context.volume THEN ERROR MScavenge.Error[internalFailure];    IF context.repair AND NOT header.repaired THEN      context.logProc[        "**Warning:  Pilot file system not repaired; continuing..."L];    IF header.incomplete THEN      context.logProc[        "**Warning:  Incomplete Pilot Scavenger log; continuing..."L];    RETURN[header.numberOfFiles, header.incomplete];    END;  -- CheckHeader  -- DeleteOrphanPage:  Call Scavenger.DeleteOrphanPage and handle all the errors.  DeleteOrphanPage: PROC [    volume: Volume.ID, id: Scavenger.OrphanHandle, context: MScavengeOps.Handle] =    BEGIN    Scavenger.DeleteOrphanPage[      volume, id !      Scavenger.Error => {        context.logProc["  **ERROR** (couldn't delete old orphan page: "L];        SELECT error FROM          orphanNotFound => context.logProc["not found on volume)."L];          ENDCASE => context.logProc["unknown error)."L];        CONTINUE};      Volume.Unknown => {        context.logProc[          "  **ERROR** (couldn't delete old orphan page: volume not found)."L];        CONTINUE};      Volume.NotOpen => {        context.logProc[          "  **ERROR** (couldn't delete old orphan page: volume not open)."L];        CONTINUE}; ];    RETURN;    END;  -- DeleteOrphanPage  -- LogFileCapAndNumber:  Log file capability and number of problems for a  -- file with problems:  -- "FID[aaaaaaB,bbbbbbB,ccccccB,ddddddB,eeeeeeB,fffffB, ggggggB] has n problems."  LogFileCapAndNumber: PROC [    context: MScavengeOps.Handle, file: File.File, numberOfProblems: CARDINAL] =    BEGIN    hasN: STRING ¬ " has XXXXX"L;    LogFileCapability[context, file];    IF numberOfProblems = 1 THEN context.logProc[" has 1 problem."L]    ELSE {      hasN.length ¬ 5;      String.AppendNumber[hasN, numberOfProblems, 10];      context.logProc[hasN];      context.logProc[" problems."L]};    END;  -- LogFileCapAndNumber  -- LogInfo:  Log appropriate information for a file with a problem.  LogInfo: PROC [    context: MScavengeOps.Handle, fileEntry: LONG POINTER TO Scavenger.FileEntry]    RETURNS [file: File.File, type: File.Type, repairProblems: BOOLEAN] =    BEGIN    name: STRING ¬ [MFileOps.maxNameLength];    repairProblems ¬ TRUE;    file ¬ [fileEntry.file, context.volume];    type ¬ FileTypes.tUntypedFile;    LogFileCapAndNumber[context, file, fileEntry.numberOfProblems];    context.logProc["File name:  "L];    name.length ¬ 0;    IF fileEntry.file # File.nullID THEN {      [type: type] ¬ File.GetAttributes[        file !        File.Unknown, Volume.Unknown => {          context.logProc[            "(Unknown:  File.Unknown; this file's problems cannot be repaired.)"L];          repairProblems ¬ FALSE;          CONTINUE}];      IF repairProblems THEN {        IF type NOT IN MesaDEFileTypes.MesaDEFileType THEN {          context.logProc[            "(None:  foreign file type; this file's problems will not be repaired.)"L];          repairProblems ¬ FALSE}        ELSE {          lp: MFileOps.LeaderPage ¬ NIL;          lp ¬ MFileOps.MapLeader[            file !            MFileOps.InvalidLeader, File.MissingPages => {              context.logProc["(Unknown:  leader page error.)"L]; CONTINUE}];          IF lp # NIL THEN {            MFileOps.GetName[lp, name]; MFileOps.UnmapLeader[lp]}}}}    ELSE context.logProc["(Unknown:  File.nullID)"L];    IF name.length # 0 THEN context.logProc[name];    context.logProc[""L];    END;  -- LogInfo  -- LogProblem:  Log appropriate information for a single Problem.  LogProblem: PROC [    context: MScavengeOps.Handle, problem: LONG POINTER TO Scavenger.Problem] =    BEGIN    missingString: STRING ¬ "  Missing pages [aaaaaaaaaa..bbbbbbbbbb)...   "L;    orphanString: STRING ¬ "  Orphan page with OrphanHandle[aaaaaaaaaa]...   "L;    duplicateString: STRING ¬ "  Duplicate page with OrphanHandle[aaaaaaaaaa]...   "L;    unreadableString: STRING ¬      "  Unreadable pages [aaaaaaaaaa..bbbbbbbbbb)...   "L;    WITH problem­ SELECT FROM      duplicate => {        duplicateString.length ¬ 35;  -- truncate to just before "aaaaaaaaaa"        String.AppendLongNumber[duplicateString, LOOPHOLE[id, LONG CARDINAL], 10];        String.AppendString[to: duplicateString, from: "]..."L];        context.logProc[duplicateString]};      missing => {        missingString.length ¬ 17;  -- truncate to just before "aaaaaaaaaa"        String.AppendLongNumber[missingString, first, 10];        String.AppendString[to: missingString, from: ".."L];        String.AppendLongNumber[missingString, first + count, 10];        String.AppendString[to: missingString, from: ")..."L];        context.logProc[missingString]};      orphan => {        orphanString.length ¬ 32;  -- truncate to just before "aaaaaaaaaa"        String.AppendLongNumber[orphanString, LOOPHOLE[id, LONG CARDINAL], 10];        String.AppendString[to: orphanString, from: "]..."L];        context.logProc[orphanString]};      unreadable => {        unreadableString.length ¬ 20;  -- truncate to just before "aaaaaaaaaa"        String.AppendLongNumber[unreadableString, first, 10];        String.AppendString[to: unreadableString, from: ".."L];        String.AppendLongNumber[unreadableString, first + count, 10];        String.AppendString[to: unreadableString, from: ")..."L];        context.logProc[unreadableString]};      ENDCASE;    END;  -- LogProblem  -- MissingPages:  Take care of one missing Problem entry from the Pilot  -- Scavenger log.  MissingPages: PROC [    context: MScavengeOps.Handle, fileEntry: LONG POINTER TO Scavenger.FileEntry,    problem: LONG POINTER TO Scavenger.Problem, type: File.Type,    spacePage: Space.PageNumber, repairProblems: BOOLEAN] =    BEGIN    fudge: CARDINAL = 10;  -- fudge factor => avoid Volume.InsufficientSpace    spacePtr: LONG POINTER TO UNSPECIFIED;    succeeded: BOOLEAN;    WITH problem­ SELECT FROM      missing => {        IF context.repair AND repairProblems THEN {          IF ((count + fudge) > Volume.GetAttributes[context.volume].freePageCount)            OR (count >= unfillableHoleSize) THEN {            context.logProc[              "**NOT** replaced (too few free pages or too many missing pages)."L];            RETURN};          spacePtr ¬ Space.LongPointerFromPage[spacePage];          FOR i: LONG CARDINAL ¬ 0, i + 1 WHILE i < Environment.wordsPerPage DO            (spacePtr + i)­ ¬ 0; ENDLOOP;          FOR i: LONG CARDINAL ¬ 0, i + 1 WHILE i < count DO            succeeded ¬ FALSE;            THROUGH [0..retryCount) DO              IF RewritePage[                [fileEntry.file, context.volume], first + i, spacePage, context]                THEN {succeeded ¬ TRUE; EXIT};              ENDLOOP;            IF ~succeeded THEN {              context.logProc["could not be rewritten on page "L];              Format.LongDecimal[context.logProc, i];              succeeded ¬ ~Scavenger.ReplaceBadPage[                [fileEntry.file, context.volume], first + i, spacePage !                Scavenger.Error, File.Unknown, File.Error, Volume.InsufficientSpace                  => CONTINUE];              IF succeeded THEN context.logProc["; successfully replaced. "L]              ELSE {context.logProc["; could ***NOT*** be replaced. "L]; RETURN}};            ENDLOOP;          context.logProc["replaced."L]}        ELSE {          context.logProc[""L];          IF type IN MesaDEFileTypes.Directory THEN            ERROR MScavenge.Error[fatalBTreeErrorInCheckMode]}};      ENDCASE => ERROR;    END;  -- MissingPages  -- OrphanPage:  Take care of one orphan Problem entry from the Pilot  -- Scavenger log.  OrphanPage: PROC [    context: MScavengeOps.Handle, problem: LONG POINTER TO Scavenger.Problem,    spaceH: Space.Interval, spacePage: Space.PageNumber, garbage: File.File,    garbageCount: File.PageCount, repairProblems: BOOLEAN]    RETURNS [newGarbage: File.File, newGarbageCount: File.PageCount] =    BEGIN    garbageWindow: Space.Window;    noRoom: BOOLEAN;    newGarbage ¬ garbage;    newGarbageCount ¬ garbageCount;    WITH problem­ SELECT FROM      orphan, duplicate => {        IF context.repair AND repairProblems THEN {          IF ~ReadOrphanPage[context.volume, id, spacePage, context].ok THEN            RETURN;          -- for now, assume all orphan pages are pages with permanently          -- trashed labels, so ignore the fileID, etc. returned by          -- ReadOrphanPage.          [newGarbage, newGarbageCount, garbageWindow, noRoom] ¬ AllocGarbagePage[            newGarbage, newGarbageCount, context];          IF noRoom THEN RETURN;          [] ¬ Space.CopyOut[spaceH.pointer, garbageWindow];          newGarbageCount ¬ newGarbageCount + 1;          context.logProc["added to Garbage.$ file."L];          DeleteOrphanPage[context.volume, id, context]}        ELSE context.logProc[""L]};      ENDCASE => ERROR;    END;  -- OrphanPage  -- ProcessProblem:  Take care of one Problem entry from the Pilot Scavenger log.  ProcessProblem: PROC [    context: MScavengeOps.Handle, fileEntry: LONG POINTER TO Scavenger.FileEntry,    problem: LONG POINTER TO Scavenger.Problem, type: File.Type,    spaceH: Space.Interval, spacePage: Space.PageNumber, garbage: File.File,    garbageCount: File.PageCount, repairProblems: BOOLEAN]    RETURNS [newGarbage: File.File, newGarbageCount: File.PageCount] =    BEGIN    newGarbage ¬ garbage;    newGarbageCount ¬ garbageCount;    LogProblem[context, problem];    WITH problem­ SELECT FROM      missing =>        MissingPages[context, fileEntry, problem, type, spacePage, repairProblems];      duplicate, orphan =>        [newGarbage, newGarbageCount] ¬ OrphanPage[          context, problem, spaceH, spacePage, garbage, garbageCount,          repairProblems];      unreadable =>        UnreadablePages[          context, fileEntry, problem, type, spacePage, repairProblems];      ENDCASE => ERROR;    END;  -- ProcessProblem  -- ReadBadPage:  Call Scavenger.ReadBadPage and handle all the possible errors.  ReadBadPage: PROC [    fileID: File.File, page: File.PageNumber, destination: Space.PageNumber,    context: MScavengeOps.Handle] RETURNS [ok: BOOLEAN] =    BEGIN    THROUGH [0..retryCount) DO      IF ~Scavenger.ReadBadPage[        fileID, page, destination !        Scavenger.Error => {          context.logProc["**ERROR** "L];          SELECT error FROM            noSuchPage => context.logProc["(no such page in this file)."L];            diskNotReady => context.logProc["(disk not ready)."L];            diskHardwareError => context.logProc["(disk hardware error)."L];            ENDCASE => context.logProc["(unknown error)."L];          GOTO FailExit};        File.Unknown => {          context.logProc[            "**ERROR** (file unknown or volume containing file not open)."L];          GOTO FailExit}; ] THEN RETURN[TRUE];      ENDLOOP;    context.logProc["**ERROR** (unable to read page). "L];    RETURN[FALSE];    EXITS FailExit => RETURN[FALSE];    END;  -- ReadBadPage  -- ReadOrphanPage:  Call Scavenger.ReadOrphanPage and handle all the  -- possible errors.  Note that return parameter ok = FALSE implies the  -- other return parameters are undefined.  ReadOrphanPage: PROC [    volume: Volume.ID, id: Scavenger.OrphanHandle, destination: Space.PageNumber,    context: MScavengeOps.Handle]    RETURNS [      file: File.File, type: File.Type, pageNumber: File.PageNumber,      readErrors: BOOLEAN, ok: BOOLEAN] =    BEGIN    [file, type, pageNumber, readErrors] ¬ Scavenger.ReadOrphanPage[      volume, id, destination !      Scavenger.Error => {        context.logProc["**ERROR** "L];        SELECT error FROM          orphanNotFound => context.logProc["(not found on volume)."L];          diskNotReady => context.logProc["(disk not ready)."L];          diskHardwareError => context.logProc["(disk hardware error)."L];          ENDCASE => context.logProc["(unknown error)."L];        GOTO FailExit};      Volume.Unknown => {        context.logProc["**ERROR** (volume not found)."L]; GOTO FailExit};      Volume.NotOpen => {        context.logProc["**ERROR** (volume not open)."L]; GOTO FailExit}; ];    RETURN[file, type, pageNumber, readErrors, TRUE];    EXITS FailExit => RETURN[file, type, pageNumber, readErrors, FALSE];    END;  -- ReadOrphanPage  -- RewritePage:  Call Scavenger.RewritePage and handle all the possible errors.  RewritePage: PROC [    fileID: File.File, page: File.PageNumber, source: Space.PageNumber,    context: MScavengeOps.Handle] RETURNS [ok: BOOLEAN] =    BEGIN    IF Scavenger.RewritePage[      fileID, page, source !      Scavenger.Error => {        context.logProc["**ERROR** "L];        SELECT error FROM          noSuchPage => context.logProc["(page beyond end of file)."L];          diskNotReady => context.logProc["(disk not ready)."L];          diskHardwareError => context.logProc["(disk hardware error)."L];          ENDCASE => context.logProc["(unknown error)."L];        GOTO FailExit};      File.Error => {        context.logProc["**NOT** replaced or rewritten "L];        context.logProc["(unknown file error)."L];        GOTO FailExit};      File.Unknown => {        context.logProc["**NOT** replaced or rewritten (file unknown)."L];        GOTO FailExit};      Volume.InsufficientSpace => {        context.logProc["**NOT** replaced (too few free pages)."L];        GOTO FailExit}; ] THEN {      context.logProc["**ERROR** (bad pages in file)"L]; GOTO FailExit};    RETURN[TRUE];    EXITS FailExit => RETURN[FALSE];    END;  -- RewritePage  -- UnreadablePages:  Take care of one unreadable Problem entry from the  -- Pilot Scavenger log.  UnreadablePages: PROC [    context: MScavengeOps.Handle, fileEntry: LONG POINTER TO Scavenger.FileEntry,    problem: LONG POINTER TO Scavenger.Problem, type: File.Type,    spacePage: Space.PageNumber, repairProblems: BOOLEAN] =    BEGIN    giveup: BOOLEAN;    WITH problem­ SELECT FROM      unreadable => {        IF context.repair AND repairProblems THEN {          FOR i: LONG CARDINAL ¬ 0, i + 1 WHILE i < count DO            IF ~ReadBadPage[              [fileEntry.file, context.volume], first + i, spacePage, context] THEN              context.logProc["Can't read page; will try to rewrite anyway"L];            IF RewritePage[              [fileEntry.file, context.volume], first + i, spacePage, context] THEN              LOOP;            giveup ¬ FALSE;            context.logProc["Will try to replace page..."L];            giveup ¬ Scavenger.ReplaceBadPage[              [fileEntry.file, context.volume], first + i, spacePage !              Scavenger.Error, File.Unknown, File.Error, Volume.InsufficientSpace                => {giveup ¬ TRUE; CONTINUE}];            IF giveup THEN {              context.logProc["failed to replace page; giving up..."L]; RETURN}            ELSE context.logProc["page replaced"L];            ENDLOOP;          context.logProc["rewritten."L]}        ELSE {          context.logProc[""L];          IF type IN MesaDEFileTypes.Directory THEN            ERROR MScavenge.Error[fatalBTreeErrorInCheckMode]}};      ENDCASE => ERROR;    END;  -- UnreadablePages  END. of MScavengeImplB
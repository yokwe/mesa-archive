-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: MFileImplB.mesa - last edited by-- PXK    ,	26-Jul-83 12:00:04-- LXR    ,	12-Jan-84 14:15:34-- RXJ     ,	15-Sep-82 14:20:07-- DWE    ,	 4-Aug-83 17:11:28DIRECTORY  ByteBlt USING [ByteBlt],  CmFile USING [Error, UserDotCmLine],  Environment USING [bytesPerPage],  Event USING [fileSystem],  EventTypes USING [    abortedSearchPathChange, aboutToChangeSearchPath, directoryCreated,     newSearchPath],  File USING [    File, GetSize, ID, nullFile, PageCount, SetSize],  Inline USING [LongCOPY],  MDirectory USING [    DirCreateDirectory, DirError, DirFreeSearchPath, DirGetSearchPath, DirInfo,    DirSetSearchPath, EnumerateState, ErrorCode, GetNext],  MFile USING [    Access, Acquire, CopyFileHandle, CopyProperties, dontCare, dontRelease,    EnumerateProc, EnumerateState, EnumerationType, Error, ErrorCode,    FileAcquireProc, GetFullName, GetLength, GetTimes, Handle, InitialLength,     maxNameLength, NameForError, Object, PropertyError, Release, ReleaseData,     SearchPath, SetLength, SetReadProtect, SetTimes, Type],  MFileOps USING [    filePassword, FHandle, fixedPropertiesSize,    Handle, heap, IncrementCeiling, InvalidLeader, LeaderPage, leaderPages,    leaderVersionID,    LockedRename, LockedSwapNames, MakeTemp, Match, maxNameLength, NoteCaller,    Object, ReleaseObject, RenameTemp, validityCheckValue],  MStream USING [Create, Handle],  MUsage USING [mFileLeaderPage],  NotifyOps USING [    AccessStatus, AddHandle, GetObjectForEnumerate, GetObjectForReading,    SetTimesGivenAccess],  RFile USING [Handle, Rename, SetMinimumFileDataPages, SwapNames],  Runtime USING [GetCaller],  Space USING [    Allocate, CopyIn, Deallocate, Error, ForceOut, Interval, Map, MapAt,    PageOffset, Unmap, UnmapAt, Window],  SpecialMFile USING [],  Stream USING [EndOfStream],  String USING [    AppendChar, AppendString, AppendSubString, Empty, LowerCase,     StringBoundsFault, SubStringDescriptor],  Supervisor USING [EnumerationAborted, NotifyDirectSubsystems, SubsystemHandle],  System USING [GetGreenwichMeanTime, gmtEpoch],  Time USING [Current, Packed],  Token USING [Boolean, FreeTokenString, FreeStringHandle, Handle, StringToHandle],  Volume USING [GetStatus, ID, InsufficientSpace, nullID, systemID];MFileImplB: MONITOR -- locks release data  IMPORTS    ByteBlt, CmFile, Event, File, Inline, MDirectory, MFile, MFileOps, MStream,    NotifyOps, RFile, Runtime, Space, Stream, String, Supervisor, System,     Time, Token, Volume  EXPORTS MFile, MFileOps, NotifyOps, SpecialMFile =  BEGIN  remoteFilesOk: BOOLEAN ¬ FALSE;  checkedUserCm: BOOLEAN ¬ FALSE;    BadAccessForGettingCapa: PUBLIC SIGNAL = CODE;  Handle: TYPE = MFileOps.Handle;  Object: PUBLIC TYPE = MFileOps.Object;  FHandle: TYPE = MFileOps.FHandle;  ImplementationError: ERROR [what: LONG STRING] = CODE;  AppendErrorMessage: PUBLIC PROCEDURE [    msg: LONG STRING, code: MFile.ErrorCode, file: Handle] =     BEGIN    ENABLE String.StringBoundsFault => RESUME[NIL];    name: LONG STRING ¬ [100];    SELECT code FROM     invalidHandle, illegalSearchPath => NULL;     ENDCASE => SELECT TRUE FROM       file = NIL => name ¬ SIGNAL MFile.NameForError[];       ENDCASE =>          MFile.GetFullName[file, name ! MFile.PropertyError => CONTINUE];    SELECT code FROM      noSuchFile => {        String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " does not exist."L]};      conflictingAccess => {        String.AppendString[to: msg, from: "Access requested for "L];	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " conflicts with other current use."]};       insufficientAccess => {        String.AppendString[to: msg, from: "Access for "L];	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " not sufficient for current operation."L]};      directoryFull => {        String.AppendString[to: msg, from: "Directory "L];	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " is full."L]};       directoryNotEmpty => {        String.AppendString[to: msg, from: "Directory "L];	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " cannot be deleted because it is not empty."L]};       illegalName => {	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " is an illegal name."L]};       noSuchDirectory => {        String.AppendString[to: msg, from: "There is no directory named "L];	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: "."L]};       noRootDirectory => {        String.AppendString[to: msg, from: "There is no root directory for the volume specified for  "L];	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: "."L]};       nullAccess => {	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: "used with null access."L]};       protectionFault => {	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " protected against the access requested."L]};       directoryOnSearchPath => {        String.AppendString[to: msg, from: "Directory "L];	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " cannot be deleted because it is on the search path."L]};       illegalSearchPath =>	String.AppendString[to: msg, from: "Search path is not well-formed."L];       volumeNotOpen => {        String.AppendString[to: msg, from: "The volume containing "L];	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " is not open."L]};       volumeReadOnly => {        String.AppendString[to: msg, from: "The volume containing "L];	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " is read only."L]};       noRoomOnVolume => {        String.AppendString[to: msg, from: "The volume containing "L];	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " is full."L]};       noSuchVolume => {        String.AppendString[to: msg, from: "The volume containing "L];	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " does not exist."L]};       crossingVolumes =>	String.AppendString[to: msg, from: "Files cannot be renamed or swapped across volumes."L];       fileAlreadyExists => { 	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " already exists."L]};       fileIsRemote => {        String.AppendString[to: msg, from: "The current operation on "L];	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " is not allowed on remote files."L]};       fileIsDirectory => {        String.AppendString[to: msg, from: "The current operation on "L];	String.AppendString[to: msg, from: name]; 	String.AppendString[to: msg, from: " is not allowed on directories."L]};       invalidHandle =>         String.AppendString[to: msg, from: "Invalid file handle."L];      courierError =>          String.AppendString[to: msg, from: "Courier error accessing remote file."L];      addressTranslationError =>         String.AppendString[to: msg, from: "Address translation error accessing remote file."L];      connectionSuspended =>         String.AppendString[to: msg, from: "Connection suspended while accessing remote file."L];      ENDCASE =>         String.AppendString[to: msg, from: "Unknown file system error."L];    END;  SameFile: PUBLIC PROCEDURE [file1, file2: Handle] RETURNS [same: BOOLEAN] =    BEGIN    IF file1 = NIL THEN MFile.Error[file1, invalidHandle];    IF file2 = NIL THEN MFile.Error[file2, invalidHandle];    RETURN[file1.fo = file2.fo]; -- won't work for remote files...    END;  GetVolume: PUBLIC PROCEDURE [file: Handle] RETURNS [Volume.ID] =    BEGIN    WITH file.fo.location SELECT FROM      local => RETURN[f.volumeID];      ENDCASE;    RETURN[Volume.nullID];    END;  ComputeFileType: PUBLIC PROCEDURE [file: MFile.Handle] RETURNS [type: MFile.Type] =    BEGIN    copy: MFile.Handle;    s: MStream.Handle;    copy ¬ MFile.CopyFileHandle[file, [], readOnly !       MFile.Error => {copy ¬ NIL; CONTINUE}];    IF copy = NIL THEN RETURN[unknown];    s ¬ MStream.Create[copy, []];    DO      IF s.getByte[s ! Stream.EndOfStream => {type ¬ text; EXIT}] > 177B THEN {        type ¬ binary; EXIT};      ENDLOOP;    s.delete[s];    END;  Rename: PUBLIC PROCEDURE [file: Handle, newName: LONG STRING] = {    ValidateHandle[file];    IF file.access # rename THEN MFile.Error[file, insufficientAccess];    IF file.fo.lp.fp.dirInfo.type = directory THEN       MFile.Error[file, fileIsDirectory];    WITH file.fo.location SELECT FROM      remote => RFile.Rename[h, newName];      local =>        BEGIN        IF f.volumeID # Volume.systemID THEN            SELECT Volume.GetStatus[f.volumeID] FROM	     openReadWrite => NULL;	     openRead => MFile.Error[file, volumeReadOnly];	     ENDCASE => ERROR MFile.Error[file, volumeNotOpen];	SELECT file.fo.tempFile FROM          TRUE =>            IF newName = NIL OR newName.length = 0 THEN RETURN            ELSE MFileOps.RenameTemp[file, newName];          FALSE =>            IF newName = NIL OR newName.length = 0 THEN MFileOps.MakeTemp[file]            ELSE MFileOps.LockedRename[file, newName];          ENDCASE;	 END;      ENDCASE};  SwapNames: PUBLIC PROCEDURE [f1, f2: Handle] = {    ValidateHandle[f1];    ValidateHandle[f2];    IF f1.access # rename THEN MFile.Error[f1, insufficientAccess];    IF f2.access # rename THEN MFile.Error[f2, insufficientAccess];    WITH fo1: f1.fo.location SELECT FROM      remote =>        WITH fo2: f2.fo.location SELECT FROM          remote => RFile.SwapNames[fo1.h, fo2.h];          local => ERROR MFile.Error[f1, crossingVolumes];          ENDCASE;      local =>        WITH fo2: f2.fo.location SELECT FROM          remote => ERROR MFile.Error[f1, crossingVolumes];          local => {            IF fo1.f.volumeID # fo2.f.volumeID THEN 	      ERROR MFile.Error[f1, crossingVolumes];            IF fo1.f.volumeID # Volume.systemID THEN               SELECT Volume.GetStatus[fo1.f.volumeID] FROM	         openReadWrite => NULL;		 openRead => MFile.Error[f1, volumeReadOnly];		 ENDCASE => ERROR MFile.Error[f1, volumeNotOpen];	    MFileOps.LockedSwapNames[f1, f2, fo1.f.volumeID]};          ENDCASE;      ENDCASE};  SetSearchPath: PUBLIC PROCEDURE [sp: MFile.SearchPath]    RETURNS [succeeded: BOOLEAN ¬ TRUE] = {    Supervisor.NotifyDirectSubsystems[      event: EventTypes.aboutToChangeSearchPath, which: clients,      subsystem: Event.fileSystem !      Supervisor.EnumerationAborted => {succeeded ¬ FALSE; CONTINUE}];    IF ~succeeded THEN      Supervisor.NotifyDirectSubsystems[        event: EventTypes.abortedSearchPathChange, which: clients,        subsystem: Event.fileSystem ! Supervisor.EnumerationAborted => CONTINUE]    ELSE {      succeeded ¬ MDirectory.DirSetSearchPath[        sp !        MDirectory.DirError =>          SELECT type FROM            fileNotFound => MFile.Error[NIL, noSuchFile];            volumeNotOpen => MFile.Error[NIL, volumeNotOpen];            invalidVolume => MFile.Error[NIL, noSuchVolume];            invalidPathName => MFile.Error[NIL, noSuchDirectory];            noRootDirectory => MFile.Error[NIL, noRootDirectory];            invalidSearchPath => MFile.Error[NIL, illegalSearchPath];            invalidFileName => MFile.Error[NIL, illegalName];            ENDCASE => MFile.Error[NIL, other]];      Supervisor.NotifyDirectSubsystems[        event: EventTypes.newSearchPath, which: clients,        subsystem: Event.fileSystem !        Supervisor.EnumerationAborted => CONTINUE]}};  GetSearchPath: PUBLIC PROCEDURE RETURNS [sp: MFile.SearchPath] = {    sp ¬ MDirectory.DirGetSearchPath[      ! MDirectory.DirError => MFile.Error[NIL, other]]};  FreeSearchPath: PUBLIC PROCEDURE [sp: MFile.SearchPath] = {    MDirectory.DirFreeSearchPath[      sp ! MDirectory.DirError => MFile.Error[NIL, other]]};  CreateDirectory: PUBLIC PROCEDURE [dir: LONG STRING] = {    ENABLE MFile.NameForError => RESUME [dir];    f: MFile.Handle ¬ NIL;    name: LONG STRING ¬ [100];     [] ¬ MDirectory.DirCreateDirectory[      dir !      MDirectory.DirError =>        SELECT type FROM          directoryFull => MFile.Error[NIL, directoryFull];          invalidFileName => MFile.Error[NIL, illegalName];          volumeNotOpen => MFile.Error[NIL, volumeNotOpen];          readOnlyDirectory => MFile.Error[NIL, volumeReadOnly];          noRoomOnVolume => MFile.Error[NIL, noRoomOnVolume];          noRootDirectory => MFile.Error[NIL, noRootDirectory];          fileAlreadyExists => MFile.Error[NIL, fileAlreadyExists];          ENDCASE => MFile.Error[NIL, other]];      f ¬ MFile.Acquire[dir, anchor, [] ! MFile.Error => CONTINUE];      IF f # NIL THEN {        MFile.GetFullName[f, name ! MFile.PropertyError => CONTINUE];        MFile.Release[f]};      Supervisor.NotifyDirectSubsystems[        event: EventTypes.directoryCreated, which: clients,        subsystem: Event.fileSystem, eventData: name !        Supervisor.EnumerationAborted => CONTINUE]};  Copy: PUBLIC PROCEDURE [file: Handle, newName: LONG STRING] = {    bpp: CARDINAL = Environment.bytesPerPage;    dest: Handle ¬ NIL;    base: Space.PageOffset;    space: Space.Interval;    read, create: Time.Packed;    fileLength: LONG CARDINAL;    sourceWindow, destWindow: Space.Window ¬ [      file: File.nullFile, base: 0, count: 50];    ValidateHandle[file];    WITH file.fo.location SELECT FROM      remote => ERROR MFile.Error[file, fileIsRemote];      local =>        BEGIN        IF ~(file.access = readOnly OR file.access = readWrite) THEN          ERROR MFile.Error[file, insufficientAccess];        IF file.fo.lp.fp.dirInfo.readProtect THEN          ERROR MFile.Error[file, protectionFault];        IF file.fo.lp.fp.dirInfo.type = directory THEN          ERROR MFile.Error[file, fileIsDirectory];        dest ¬ MFile.Acquire[          name: newName, access: writeOnly, release: [],          initialLength: MFile.GetLength[file], type: file.fo.lp.fp.dirInfo.type];        WITH dest.fo.location SELECT FROM          local => destWindow.file ¬ f;          ENDCASE => ERROR MFile.Error[file, fileIsRemote];        MFile.SetLength[dest, MFile.GetLength[file]];        sourceWindow.file ¬ f;        space ¬ Space.Allocate[50];        fileLength ¬ (MFile.GetLength[file] + (bpp - 1))/bpp;        FOR base ¬ 0, base + 50 WHILE base < fileLength DO          sourceWindow.base ¬ destWindow.base ¬ base + MFileOps.leaderPages;	  [] ¬ Space.MapAt[at: space, window: destWindow,	    swapUnits: [unitary[]]];          [] ¬ Space.CopyIn[space.pointer, sourceWindow 	        ! Space.Error => CONTINUE];          [] ¬ Space.UnmapAt[space.pointer];          ENDLOOP;        Space.Deallocate[space];        MFile.CopyProperties[from: file, to: dest];        MFile.SetReadProtect[file: dest, readProtected: FALSE];        [read: read, create: create] ¬ MFile.GetTimes[file];        MFile.SetTimes[          file: dest, create: create, read: read,          write: System.GetGreenwichMeanTime[]];        MFile.Release[dest];        END;      ENDCASE};  GetCapa, GetCapaWithAccess: PUBLIC PROCEDURE [file: Handle]    RETURNS [capa: File.File] = {    ValidateHandle[file];    WITH file.fo.location SELECT FROM      remote => ERROR;      local => {capa ¬ f};      ENDCASE};  NoteCaller: PUBLIC PROCEDURE [p: PROGRAM] RETURNS [LONG POINTER] = {    RETURN[LOOPHOLE[p]]};  ValidFilename: PUBLIC PROCEDURE [name: LONG STRING] RETURNS [ok: BOOLEAN] = {    IF name = NIL OR name.length = 0 THEN RETURN[FALSE];    FOR i: CARDINAL IN [0..name.length) DO      SELECT name[i] FROM        IN ['a..'z], IN ['A..'Z], IN ['0..'9], '., '$, '+, '-, '<, '>, '[, '],          '{, '} => LOOP;        ENDCASE => RETURN[FALSE];      ENDLOOP;    RETURN[TRUE]};  wildString: CHARACTER = '*;  wildChar: CHARACTER = '#;  CompleteFilename: PUBLIC PROCEDURE [name, addedPart: LONG STRING]    RETURNS [exactMatch: BOOLEAN, matches: CARDINAL] = {    addedPartIndex: CARDINAL ¬ 0;    pattern: STRING ¬ [MFile.maxNameLength];    tempDesc: String.SubStringDescriptor;    noWildCards: BOOLEAN ¬ TRUE;    fullMatch: BOOLEAN ¬ FALSE;    EscMatch: MFile.EnumerateProc =      BEGIN      addedPartIndex ¬ EscapeMatch[fullName, pattern, pattern.length - 1];      IF matches = 0 THEN {        matches ¬ 1;        fullMatch ¬ TRUE;        tempDesc ¬ [          base: fullName, offset: addedPartIndex,          length: fullName.length - addedPartIndex];        String.AppendSubString[addedPart, @tempDesc]}      ELSE {        i: CARDINAL ¬ 0;        WHILE i + addedPartIndex < fullName.length AND i < addedPart.length DO          IF String.LowerCase[fullName[i + addedPartIndex]] # String.LowerCase[            addedPart[i]] THEN {matches ¬ matches + 1; EXIT};          i ¬ i + 1;          ENDLOOP;        IF i + addedPartIndex = fullName.length          OR (i = addedPart.length AND fullMatch) THEN fullMatch ¬ TRUE        ELSE fullMatch ¬ FALSE;        addedPart.length ¬ i};      RETURN[FALSE]      END;    matches ¬ 0;    FOR i: CARDINAL IN [0..name.length) DO      IF name[i] = wildString OR name[i] = wildChar THEN {        noWildCards ¬ FALSE; EXIT};      ENDLOOP;    addedPart.length ¬ 0;    String.AppendString[pattern, name];    String.AppendChar[pattern, '*];    EnumerateDirectory[pattern, EscMatch, filesOnly];    IF matches = 0 THEN MFile.Error[NIL, noSuchFile];    RETURN[noWildCards AND fullMatch, matches]};  EscapeMatch: PUBLIC PROCEDURE [string, pattern: LONG STRING, pos: CARDINAL]    RETURNS [correspondingingPos: CARDINAL] =    BEGIN    match: BOOLEAN;    [match, correspondingingPos] ¬ MFileOps.Match[string, 0, pattern, 0, pos];    IF ~match THEN correspondingingPos ¬ 0;    END;  LeaderPages: PUBLIC PROCEDURE RETURNS [CARDINAL] = {    RETURN[MFileOps.leaderPages]};  ValidateHandle: PUBLIC PROCEDURE [file: Handle] = {    IF file = NIL OR file.password # MFileOps.filePassword THEN      MFile.Error[file, invalidHandle]};  GetAccess: PUBLIC PROCEDURE [file: Handle] RETURNS [access: MFile.Access] = {    ValidateHandle[file]; access ¬ file.access};  GetReleaseData: PUBLIC PROCEDURE [file: Handle]    RETURNS [release: MFile.ReleaseData] = {    ValidateHandle[file]; release ¬ LockedGetReleaseData[file]};  LockedGetReleaseData: PUBLIC ENTRY PROCEDURE [file: Handle]    RETURNS [release: MFile.ReleaseData] = {release ¬ file.release};  SetReleaseData: PUBLIC PROCEDURE [file: Handle, release: MFile.ReleaseData] = {    DoSet: ENTRY PROCEDURE [fo: FHandle] = {file.release ¬ release};    ValidateHandle[file];    IF release = MFile.dontRelease THEN      release.clientInstanceData ¬ MFileOps.NoteCaller[Runtime.GetCaller[]];    DoSet[file.fo ! UNWIND => NULL]};      Log: PUBLIC PROCEDURE [    name: LONG STRING, release: MFile.ReleaseData,    initialLength: MFile.InitialLength ¬ MFile.dontCare] RETURNS [MFile.Handle] =    {    IF release = MFile.dontRelease THEN      release.clientInstanceData ¬ MFileOps.NoteCaller[Runtime.GetCaller[]];    RETURN[MFile.Acquire[name, log, release, TRUE, initialLength, text]]};  ReadOnly: PUBLIC PROCEDURE [    name: LONG STRING, release: MFile.ReleaseData, mightWrite: BOOLEAN ¬ FALSE]    RETURNS [MFile.Handle] = {    IF release = MFile.dontRelease THEN      release.clientInstanceData ¬ MFileOps.NoteCaller[Runtime.GetCaller[]];    RETURN[      MFile.Acquire[        name, readOnly, release, mightWrite, MFile.dontCare, unknown]]};  ReadWrite: PUBLIC PROCEDURE [    name: LONG STRING, release: MFile.ReleaseData, type: MFile.Type,    initialLength: MFile.InitialLength ¬ MFile.dontCare] RETURNS [MFile.Handle] =    {    IF release = MFile.dontRelease THEN      release.clientInstanceData ¬ MFileOps.NoteCaller[Runtime.GetCaller[]];    RETURN[MFile.Acquire[name, readWrite, release, TRUE, initialLength, type]]};  WriteOnly: PUBLIC PROCEDURE [    name: LONG STRING, release: MFile.ReleaseData, type: MFile.Type,    initialLength: MFile.InitialLength ¬ MFile.dontCare] RETURNS [MFile.Handle] =    {    IF release = MFile.dontRelease THEN      release.clientInstanceData ¬ MFileOps.NoteCaller[Runtime.GetCaller[]];    RETURN[MFile.Acquire[name, writeOnly, release, TRUE, initialLength, type]]};  GetName: PUBLIC PROCEDURE [lp: MFileOps.LeaderPage, name: LONG STRING] = {    name.length ¬ ByteBlt.ByteBlt[      from: [@lp.fp.name.bytes, 0, lp.fp.name.length],      to: [LOOPHOLE[@name.text], 0, name.maxlength]]};  CopyString: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [ns: LONG STRING] = {    IF s = NIL THEN RETURN[NIL];    ns ¬ MFileOps.heap.NEW[StringBody [s.length]];    ns.length ¬ s.length;    Inline.LongCOPY[from: @s.text, to: @ns.text, nwords: (s.length + 1)/2]};  FreeString: PUBLIC PROCEDURE [s: LONG STRING] = {    IF s # NIL THEN MFileOps.heap.FREE[@s]};<< Klamath conversion: Piloteers recommend against caching spaces  leaderCacheSize: CARDINAL = 10;  leaderCache: ARRAY [0..leaderCacheSize) OF Space.Handle ¬ ALL[Space.nullHandle];  GetLeader: PUBLIC PROCEDURE RETURNS [space: Space.Handle, lp: MFileOps.LeaderPage] = {    FOR i: CARDINAL IN [0..leaderCacheSize) DO      IF leaderCache[i] # Space.nullHandle THEN {        space ¬ leaderCache[i]; leaderCache[i] ¬ Space.nullHandle; EXIT};      REPEAT        FINISHED => space ¬ Space.Create[size: 1, parent: Space.virtualMemory];      ENDLOOP;    lp ¬ Space.LongPointer[space]};>>  MapLeader: PUBLIC PROCEDURE [file: File.File, readOnly: BOOLEAN ¬ FALSE]    RETURNS [lp: MFileOps.LeaderPage] = {    lp ¬ Space.Map[      window: [file, 0, MFileOps.leaderPages],      usage: MUsage.mFileLeaderPage,      access: IF readOnly THEN readOnly ELSE readWrite].pointer;    IF lp.fp.versionID # MFileOps.leaderVersionID      OR lp.fp.validityCheck # MFileOps.validityCheckValue THEN      SIGNAL MFileOps.InvalidLeader};  UnmapLeader: PUBLIC PROCEDURE [lp: MFileOps.LeaderPage] = {    [] ¬ Space.Unmap[lp];    <<FOR i: CARDINAL IN [0..leaderCacheSize) DO      IF leaderCache[i] = Space.nullHandle THEN {leaderCache[i] ¬ space; RETURN};      REPEAT FINISHED => Delete[space];      ENDLOOP>>};  ForceOutLeader: PUBLIC PROCEDURE [lp: MFileOps.LeaderPage] = {    Space.ForceOut[[lp, MFileOps.leaderPages]]};  InitLeader: PUBLIC PROCEDURE [    lp: MFileOps.LeaderPage, dirID: File.ID, type: MFile.Type, name: LONG STRING,    initialSizeHint: MFile.InitialLength] = {    now: Time.Packed = Time.Current[];    lp­ ¬ [      fp: [      versionID: MFileOps.leaderVersionID, dir: dirID,      dirInfo: [      type: type, deleteProtect: FALSE, writeProtect: FALSE, readProtect: FALSE],      create: now, write: System.gmtEpoch, read: System.gmtEpoch,      length: IF initialSizeHint = MFile.dontCare THEN 0 ELSE initialSizeHint,      freeWords: 256 - MFileOps.fixedPropertiesSize - MFileOps.maxNameLength/2,      name: [      length: IF name = NIL THEN 0 ELSE name.length,      maxlength: MFileOps.maxNameLength, bytes: NULL]], props: NULL];    IF name # NIL THEN {      IF name.length > MFileOps.maxNameLength THEN        ERROR MFile.Error[NIL, illegalName ! MFile.NameForError => RESUME [name]];      lp.fp.name.length ¬ ByteBlt.ByteBlt[        to: [@lp.fp.name.bytes, 0, MFileOps.maxNameLength],        from: [LOOPHOLE[@name.text], 0, name.length]]};    ForceOutLeader[lp]};  GetFilePart: PUBLIC PROCEDURE [from, to: LONG STRING] = {    j: CARDINAL ¬ 0;    to.length ¬ 0;    IF from = NIL THEN RETURN;    FOR i: CARDINAL DECREASING IN [0..from.length) DO      IF from[i] = '> THEN {j ¬ i + 1; EXIT}; ENDLOOP;    FOR i: CARDINAL IN [j..from.length) DO      String.AppendChar[to, from[i]]; ENDLOOP;    };  RemoteFileName: PUBLIC PROCEDURE [name: LONG STRING] RETURNS [remote: BOOLEAN] =    BEGIN    IF String.Empty[name] THEN RETURN[FALSE];    remote ¬ name[0] = '[ OR name[0] = '{ ;    IF remote AND ~checkedUserCm THEN {      checkedUserCm ¬ TRUE;      ProcessUserCm[]};    remote ¬ remote AND remoteFilesOk;     END;  VolumeOpenForWrite: PUBLIC PROCEDURE [fo: FHandle] RETURNS [BOOLEAN] =    BEGIN    WITH fo.location SELECT FROM      local => {IF f.volumeID = Volume.systemID THEN RETURN[TRUE];                IF Volume.GetStatus[f.volumeID] # openReadWrite THEN 	         RETURN[FALSE]};      ENDCASE;    RETURN[TRUE];    END;  SetFileDataSize: PUBLIC PROCEDURE [id: File.File, dataPages: File.PageCount] = {    pages: File.PageCount ¬ MFileOps.IncrementCeiling[dataPages];    File.SetSize[file: id, size: pages]};  SetMinimumFileDataPages: PUBLIC PROCEDURE [    file: Handle, pages: File.PageCount] = {    ValidateHandle[file];    WITH file.fo.location SELECT FROM      remote => {RFile.SetMinimumFileDataPages[h, pages]; RETURN};      local =>        IF File.GetSize[f] < pages + MFileOps.leaderPages          THEN          SetFileDataSize[            f, pages !            Volume.InsufficientSpace => MFile.Error[file, noRoomOnVolume]];      ENDCASE};  EnumerateDirectory: PUBLIC PROCEDURE [    name: LONG STRING, proc: MFile.EnumerateProc, which: MFile.EnumerationType] =    {    ENABLE MFile.NameForError => RESUME [name];    item: STRING = [MFileOps.maxNameLength];    state: MDirectory.EnumerateState ¬ NIL;    id: File.File;    done: BOOLEAN;    dirInfo: MDirectory.DirInfo;    fullName: LONG STRING;    spIndex: CARDINAL;    FileCreate: MFile.FileAcquireProc = {      fo: FHandle;      f: Handle;      status: NotifyOps.AccessStatus;      IF release = MFile.dontRelease THEN        release.clientInstanceData ¬ MFileOps.NoteCaller[Runtime.GetCaller[]];      DO        fo ¬ NotifyOps.GetObjectForEnumerate[id, state];        [status, f] ¬ NotifyOps.AddHandle[fo, access, release];        MFileOps.ReleaseObject[fo, access, status # good];        SELECT status FROM          retry => LOOP;          good => EXIT;          protected => ERROR MFile.Error[NIL, protectionFault];          conflicting => ERROR MFile.Error[NIL, conflictingAccess];          ENDCASE => ImplementationError["Bad status"L];        ENDLOOP;      IF ~VolumeOpenForWrite[fo] THEN RETURN[f];      NotifyOps.SetTimesGivenAccess[fo, fo.lp, access];      RETURN[f]};    DO      [state, id, dirInfo, fullName, spIndex] ¬ MDirectory.GetNext[        name, item, which, state !        MDirectory.DirError => {          ENABLE MFile.NameForError => RESUME [name];          SELECT type FROM            volumeNotOpen => MFile.Error[NIL, volumeNotOpen];            invalidVolume => MFile.Error[NIL, noSuchVolume];            invalidPathName => MFile.Error[NIL, noSuchDirectory];            invalidFileName => MFile.Error[NIL, illegalName];            noRootDirectory => MFile.Error[NIL, noRootDirectory]            ENDCASE => MFile.Error[NIL, other]}];      IF item.length = 0 THEN EXIT;      done ¬ proc[        item, fullName, FileCreate, dirInfo.type, spIndex !        MFile.NameForError => RESUME [item];        UNWIND =>          [, , , , ] ¬ MDirectory.GetNext[NIL, NIL, which, state, TRUE]; ];      IF done THEN {        [, , , , ] ¬ MDirectory.GetNext[NIL, NIL, which, state, TRUE];        EXIT};      ENDLOOP};  GetNextHandleForReading: PUBLIC PROCEDURE [    filter, name: LONG STRING, release: MFile.ReleaseData,    lastState: MFile.EnumerateState, stopNow: BOOLEAN ¬ FALSE]    RETURNS [file: Handle ¬ NIL, state: MFile.EnumerateState] =    BEGIN    ENABLE MFile.NameForError => RESUME [filter];    status: NotifyOps.AccessStatus ¬ protected;    IF release = MFile.dontRelease THEN      release.clientInstanceData ¬ MFileOps.NoteCaller[Runtime.GetCaller[]];    state ¬ lastState;    WHILE status # good DO      fo: FHandle;      [status, fo, state] ¬ NotifyOps.GetObjectForReading[        filter, name, state, stopNow];      IF status = protected THEN LOOP;      IF fo = NIL THEN {name.length ¬ 0; RETURN[NIL, NIL]};      [status, file] ¬ NotifyOps.AddHandle[fo, readOnly, release];      MFileOps.ReleaseObject[fo, readOnly, status # good];      IF status = good AND VolumeOpenForWrite[file.fo] THEN        NotifyOps.SetTimesGivenAccess[file.fo, file.fo.lp, readOnly];      ENDLOOP;    END;  ProcessUserCm: PROCEDURE =    BEGIN    value: LONG STRING ¬ NIL;    value ¬ CmFile.UserDotCmLine["System"L, "RemoteFiles"L !       CmFile.Error => CONTINUE];    IF value # NIL THEN {      h: Token.Handle ¬ Token.StringToHandle[value];      remoteFilesOk ¬ Token.Boolean[h, FALSE];      h ¬ Token.FreeStringHandle[h];      [] ¬ Token.FreeTokenString[value]};     END;    END.    
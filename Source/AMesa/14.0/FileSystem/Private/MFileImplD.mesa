-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- File: MFileImplD.mesa - last edited by-- LXR    ,	27-Dec-83 16:05:44DIRECTORY  MFile USING [    Access, Filter, Handle, maxNameLength, NotifyProc, Object, ReleaseData,    Type],  MFileOps USING [    CopyString, FHandle, heap, Handle, IsFileDeleted,    LeaderPage, LockedGetName, Object, ReleaseFO],  NotifyOps USING [    AddHandle, ConflictingAccess, Conflicts, GetNextNotification, Notification,     TakeHandleOffList, WHandle],  Process USING [Detach, GetPriority, Priority, priorityBackground, SetPriority],  SpecialMFile USING [],  String USING [EquivalentString, LowerCase],  Volume USING [GetStatus, Status, systemID];MFileImplD: MONITOR -- locks the notification list  IMPORTS    MFileOps, NotifyOps, Process, String, Volume  EXPORTS MFile =  BEGIN  Handle: TYPE = MFileOps.Handle;  Object: PUBLIC TYPE = MFileOps.Object;  FHandle: TYPE = MFileOps.FHandle;  ReleaseData: TYPE = MFile.ReleaseData;  LeaderPage: TYPE = MFileOps.LeaderPage;  -- errors  -- change notification   notifyProcs: NotifyProcList ¬ NIL;  NotifyProcList: TYPE = LONG POINTER TO NotifyProcObject;  NotifyProcObject: TYPE = RECORD [    next: NotifyProcList,    proc: MFile.NotifyProc,    filter: MFile.Filter,    clientInstanceData: LONG POINTER];  DoNotifications: PROCEDURE = {    fo: NotifyOps.Notification;    DO      fo ¬ NotifyOps.GetNextNotification[];      WITH notif: fo SELECT FROM        normal => {          DoNotification[notif.fo];          MFileOps.ReleaseFO[notif.fo]};        writeable => DoWriteableNotification[notif.p];        ENDCASE;      ENDLOOP};  Interested: PROCEDURE [access: MFile.Access, fo: FHandle] RETURNS [BOOLEAN] = {    FOR a: MFile.Access IN MFile.Access DO      IF fo.copy[a] AND NotifyOps.ConflictingAccess[a, access] = nope THEN RETURN[TRUE]      ENDLOOP;    RETURN[FALSE]};  Possible: PROCEDURE [    filter: MFile.Filter, fo: FHandle, f: Handle, name: LONG STRING]    RETURNS [BOOLEAN] = {    SELECT TRUE FROM      (filter.type # null AND filter.type # fo.lp.fp.dirInfo.type) =>        RETURN[FALSE];      (filter.name # NIL AND ~NameMatch[name, filter.name]) => RETURN[FALSE];      filter.access # null AND NotifyOps.Conflicts[fo, filter, f] =>        RETURN[FALSE];      ENDCASE;    RETURN[Interested[filter.access, fo]]};  DoNotification: ENTRY PROCEDURE [fo: FHandle] = {    ENABLE UNWIND => NULL;    f: Handle ¬ NIL;    prev, next, nProc: NotifyProcList;    name: LONG STRING = [MFile.maxNameLength];    IF ~VolumeOpen[fo] OR MFileOps.IsFileDeleted[fo] THEN RETURN;    MFileOps.LockedGetName[fo, name];    IF name.length = 0 THEN RETURN;    f ¬ NotifyOps.AddHandle[fo, null, [], FALSE, FALSE, NIL].file;    prev ¬ NIL;    FOR nProc ¬ notifyProcs, next UNTIL nProc = NIL DO      IF MFileOps.IsFileDeleted[fo] THEN EXIT;      next ¬ nProc.next;      IF Possible[nProc.filter, fo, f, name] THEN        IF nProc.proc[name, f, nProc.clientInstanceData] THEN {          IF prev = NIL THEN notifyProcs ¬ next ELSE prev.next ¬ next;          MFileOps.heap.FREE[@nProc.filter.name];          MFileOps.heap.FREE[@nProc]};      IF nProc # NIL THEN prev ¬ nProc;      ENDLOOP;    NotifyOps.TakeHandleOffList[fo, f, FALSE]};  VolumeOpen: PROCEDURE [fo: FHandle] RETURNS [BOOLEAN] = INLINE    BEGIN    WITH fo.location SELECT FROM      local => {        IF f.volumeID = Volume.systemID THEN RETURN[TRUE];	SELECT Volume.GetStatus[f.volumeID] FROM	  openReadWrite, openRead => RETURN[TRUE];	  ENDCASE => RETURN[FALSE]};      ENDCASE => RETURN[TRUE];    END;    WPossible: PROCEDURE [filter: MFile.Filter, name: LONG STRING]    RETURNS [ok: BOOLEAN] = {    ok ¬      SELECT filter.access FROM        anchor, readOnly, delete, rename => FALSE,        ENDCASE => TRUE;    IF ok THEN RETURN[(filter.name = NIL OR NameMatch[name, filter.name])]};  DoWriteableNotification: PROCEDURE [f: NotifyOps.WHandle] = {    prev, next, nProc: NotifyProcList;    prev ¬ NIL;    FOR nProc ¬ notifyProcs, next UNTIL nProc = NIL DO      next ¬ nProc.next;      IF WPossible[nProc.filter, f.name] THEN        IF nProc.proc[f.name, NIL, nProc.clientInstanceData] THEN {          IF prev = NIL THEN notifyProcs ¬ next ELSE prev.next ¬ next;          IF nProc.filter.name # NIL THEN MFileOps.heap.FREE[@nProc.filter.name];          MFileOps.heap.FREE[@nProc]};      IF nProc # NIL THEN prev ¬ nProc;      ENDLOOP;    MFileOps.heap.FREE[@f.name];    MFileOps.heap.FREE[@f]};  AddNotifyProc: PUBLIC ENTRY PROCEDURE [    proc: MFile.NotifyProc, filter: MFile.Filter,    clientInstanceData: LONG POINTER] = {    ENABLE UNWIND => NULL;    x: NotifyProcList;    n: NotifyProcList = MFileOps.heap.NEW[      NotifyProcObject ¬ [      next: NIL, proc: proc,      filter: [MFileOps.CopyString[filter.name], filter.type, filter.access],      clientInstanceData: clientInstanceData]];    IF notifyProcs = NIL THEN notifyProcs ¬ n    ELSE {      FOR x ¬ notifyProcs, x.next UNTIL x.next = NIL DO ENDLOOP;      x.next ¬ n}};  RemoveNotifyProc: PUBLIC ENTRY PROCEDURE [    proc: MFile.NotifyProc, filter: MFile.Filter,    clientInstanceData: LONG POINTER] = {    ENABLE UNWIND => NULL;    prev: NotifyProcList ¬ NIL;    cur: NotifyProcList;    FOR cur ¬ notifyProcs, cur.next UNTIL cur = NIL DO      IF cur.proc = proc AND (filter.type = null OR filter.type = cur.filter.type)        AND          (filter.name = NIL            OR String.EquivalentString[filter.name, cur.filter.name])        AND          (clientInstanceData = NIL            OR cur.clientInstanceData = clientInstanceData) THEN {        IF prev = NIL THEN notifyProcs ¬ cur.next ELSE prev.next ¬ cur.next;        MFileOps.heap.FREE[@cur.filter.name];        MFileOps.heap.FREE[@cur];        EXIT};      prev ¬ cur;      ENDLOOP};  wildString: CHARACTER = '*;  wildChar: CHARACTER = '#;  NameMatch: PROCEDURE [s, pat: LONG STRING] RETURNS [matched: BOOLEAN] = {    RETURN[Match[s, 0, pat, 0]]};  Match: PROCEDURE [    file: LONG STRING, fileIndex: CARDINAL, mask: LONG STRING,    maskIndex: CARDINAL] RETURNS [outcome: BOOLEAN] =    BEGIN    -- local variables    i, j: CARDINAL;    -- process each character in mask    FOR i IN [maskIndex..mask.length) DO      SELECT mask[i] FROM        wildString =>  -- matches any string of zero or more characters          BEGIN          IF file[fileIndex] = '> THEN            IF i < mask.length - 1 AND mask[i + 1] = wildString THEN              RETURN[Match[file, fileIndex + 1, mask, i]]            ELSE RETURN[FALSE];          FOR j IN [fileIndex..file.length] DO            IF Match[file, j, mask, i + 1] THEN RETURN[TRUE]; ENDLOOP;          RETURN[FALSE];          END;        wildChar =>  -- matches any single character          BEGIN          IF (file[fileIndex] = '> OR file[fileIndex] = '<) THEN RETURN[FALSE];          IF fileIndex = file.length THEN RETURN[FALSE];          fileIndex ¬ fileIndex + 1;          END;        ENDCASE =>          IF fileIndex = file.length            OR String.LowerCase[file[fileIndex]] # String.LowerCase[mask[i]] THEN            RETURN[FALSE]          ELSE fileIndex ¬ fileIndex + 1;      ENDLOOP;    -- filename passes mask if entire filename has been consumed    outcome ¬ fileIndex = file.length;    END;  --  main line code  Init: PROCEDURE = {    priority: Process.Priority = Process.GetPriority[];    Process.SetPriority[Process.priorityBackground];    Process.Detach[FORK DoNotifications[]];    Process.SetPriority[priority]};  Init[];  END.
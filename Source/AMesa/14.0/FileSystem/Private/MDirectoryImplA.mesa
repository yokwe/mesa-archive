-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- File: MDirectoryImplA.mesa - last edit -- PXK    ,	22-Apr-83 14:24:38-- LXR    ,	29-Nov-83 13:24:07-- RXJ     ,	15-Nov-83 16:14:48-- DWE    ,	 4-Aug-83 15:13:26-- RLC		10-Jul-87 12:15:37DIRECTORY  BTree USING [    Delete, Find, GetNext, maxNameLength, ReadOnly, Remove, Tree, Value,    VolumeNotOpen],  Event USING [fileSystem, swapping],  EventTypes USING [    aboutToCloseVolume, tellFileSystemSwappingIn, tellFileSystemSwappingOut],  File USING [File, ID, nullFile, nullID],  Inline USING [LongCOPY],  MDirectory USING [    CreateNewSubdirectory, directoryZone, DirInfo, ErrorCode,    InternalLookupRootDir, lock, MValue, MValueToValue, MValueRec,     SearchPathBTree, SearchPathFile],  MFile USING [    EnumerationType, Error, maxNameLength, SearchPath, searchPathNotUsed, Type],  MFileOps USING [LeaderPage, leaderPages, MapLeader, UnmapLeader],  MUsage USING [mFileDirectory],  SpecialBTree USING [MakeFromCapa, Map, Unmap, Unmapped],  SpecialMFile USING [],  String USING [    AppendChar, AppendString, EmptyString, EquivalentString, Length, LowerCase],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, SubsystemHandle],  Volume USING [    ID, GetLabelString, GetNext, GetStatus, maxNameLength, nullID, systemID];MDirectoryImplA: MONITOR LOCKS MDirectory.lock  IMPORTS    BTree, Event, --File,-- Inline, MDirectory, MFile, MFileOps, SpecialBTree,    String, Supervisor, Volume  EXPORTS MDirectory, MFile, MFileOps, SpecialMFile =  BEGIN  ASSERT: BOOLEAN [TRUE..TRUE] = (MFile.maxNameLength = BTree.maxNameLength);  debugging: BOOLEAN ¬ FALSE;    nullRec: MDirectory.MValueRec ¬ [];  nullMValue: PUBLIC MDirectory.MValue ¬ @nullRec;  nullValue: PUBLIC BTree.Value ¬ MDirectory.MValueToValue[@nullRec];  Tree: TYPE = BTree.Tree;  wildString: CHARACTER = '*;  wildChar: CHARACTER = '#;  -- Types  EnumerateState: TYPE = LONG POINTER TO EnumRec;  EnumRec: PUBLIC TYPE = RECORD [    lastMatch: LONG STRING ¬ NIL,    index, fullNameIndex: CARDINAL ¬ 0,    tree: Tree ¬ NIL,    taskList: TaskHandle ¬ NIL,    fullName: LONG STRING ¬ NIL,    volume: Volume.ID,    sp: CARDINAL];  TaskHandle: TYPE = LONG POINTER TO Task;  Task: TYPE = RECORD [    next: TaskHandle,    dir: File.File ¬ File.nullFile,    dirName: LONG STRING ¬ NIL,    index: CARDINAL ¬ 0,    dirIndex: CARDINAL ¬ 0,    searchPathIndex: CARDINAL ¬ MFile.searchPathNotUsed];  -- Errors  DirError: PUBLIC SIGNAL [type: MDirectory.ErrorCode] = CODE;  CantFindPath: PUBLIC SIGNAL [name: LONG STRING] = CODE;  NoRootDir: PUBLIC SIGNAL = CODE;  ActivityDuringWorldSwap: PUBLIC ERROR = CODE;  -- Search Path Procedures  searchPathNames: PUBLIC MFile.SearchPath ¬ NIL;  searchPathFile: PUBLIC MDirectory.SearchPathFile ¬ NIL;  searchPathBTree: PUBLIC MDirectory.SearchPathBTree ¬ NIL;    FindFirstWriteable: PUBLIC PROCEDURE RETURNS [dir: File.File] =    BEGIN    IF searchPathFile = NIL THEN RETURN[[File.nullID, Volume.systemID]];    FOR i: CARDINAL IN [0..searchPathFile.length) DO      IF ~IsProtected[searchPathFile[i]] THEN         RETURN[searchPathFile[i]];      ENDLOOP;    ERROR MFile.Error[NIL, illegalSearchPath];    END;    -- Enumeration types and objects  GetNext: PUBLIC ENTRY PROCEDURE [    filter, name: LONG STRING, which: MFile.EnumerationType,    lastState: EnumerateState, stopNow: BOOLEAN ¬ FALSE]    RETURNS [      state: EnumerateState ¬ NIL, file: File.File ¬ File.nullFile,       dirInfo: MDirectory.DirInfo ¬ [],      fullName: LONG STRING ¬ NIL,       spIndex: CARDINAL ¬ MFile.searchPathNotUsed] =    BEGIN    ENABLE {      SpecialBTree.Unmapped => {MapCacheEntry[tree]; RESUME };      NoRootDir => ERROR DirError[noRootDirectory];      BTree.ReadOnly => ERROR DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR DirError[volumeNotOpen];      UNWIND => NULL};    matched: BOOLEAN ¬ FALSE;    LegalPattern[filter];    IF stopNow THEN {FreeTaskList[lastState]; RETURN};    state ¬ lastState;    name.length ¬ 0;    IF ~String.EmptyString[filter] AND filter[filter.length-1] = '> THEN      -- can only match directories with this pattern      SELECT which FROM        filesOnly => RETURN; -- no matches possible        ENDCASE => which ¬ directoriesOnly;    IF state = NIL THEN [state, matched, file] ¬ SetUpTaskList[filter];    IF matched AND which # filesOnly THEN {      lp: MFileOps.LeaderPage;      volumeLabel: STRING ¬ [Volume.maxNameLength];      lp ¬ MFileOps.MapLeader[file, TRUE];      dirInfo ¬ lp.fp.dirInfo;      MFileOps.UnmapLeader[lp];      Volume.GetLabelString[state.volume, volumeLabel];      String.AppendChar[name, '<];      String.AppendString[to: name, from: volumeLabel];      String.AppendChar[name, '>]}    ELSE {      UNTIL state.tree = NIL DO        [file, dirInfo] ¬ GetNextTreeEntry[filter, name, which, state];        IF name.length # 0 THEN EXIT;        GetNextTask[state];        ENDLOOP};    IF name.length = 0 THEN {FreeTaskList[state]; state ¬ NIL}    ELSE {fullName ¬ state.fullName; spIndex ¬ state.sp};    END;  IsValid: PUBLIC ENTRY PROCEDURE [file: File.ID, state: EnumerateState]    RETURNS [ok: BOOLEAN] =    BEGIN    ENABLE {      SpecialBTree.Unmapped => {MapCacheEntry[tree]; RESUME };       BTree.ReadOnly => ERROR DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR DirError[volumeNotOpen];UNWIND => NULL};    rec: MDirectory.MValueRec;    value: BTree.Value = MDirectory.MValueToValue[@rec];    fileTest: File.File ¬ File.nullFile; -- used below to test if root dir    [] ¬ ValidateFile[[file, [state.volume]]]; -- if user proceeds from error, he want it anyway    fileTest ¬ GetDir[state.tree];    IF fileTest.fileID = file AND fileTest.volumeID = state.volume THEN      RETURN[TRUE]; -- root directory    -- test above avoids lousy code warning on next stmt RLC 10-Jul-87 12:15:37    --IF GetDir[state.tree] = [file, [state.volume]] THEN RETURN[TRUE];     ok ¬ BTree.Find[state.tree, state.lastMatch, value];    RETURN[ok AND (rec.fID = file)];    END;  LookUp: PUBLIC ENTRY PROCEDURE [    fileName: LONG STRING, skipProtectedDirs: BOOLEAN]    RETURNS [      file: File.ID ¬ File.nullID, dir: File.File ¬ File.nullFile,       dirInfo: MDirectory.DirInfo ¬ [], protectedDir: BOOLEAN] =    BEGIN    ENABLE {      SpecialBTree.Unmapped => {MapCacheEntry[tree]; RESUME };      NoRootDir => ERROR DirError[noRootDirectory];      BTree.ReadOnly => ERROR DirError[readOnlyDirectory];      BTree.VolumeNotOpen => ERROR DirError[volumeNotOpen];      UNWIND => NULL};    rec: MDirectory.MValueRec;    value: BTree.Value = MDirectory.MValueToValue[@rec];    name, pathName: LONG STRING ¬ NIL;    FileInDirectory: PROCEDURE [bTree: Tree] = {      IF BTree.Find[bTree, name, value] THEN { -- sets rec        IF ~ValidateFile[[rec.fID, dir.volumeID]] THEN {          IF Volume.GetStatus[dir.volumeID] = openReadWrite THEN            [] ¬ BTree.Remove[bTree, name, value];          DirError[fileNotFound]};        file ¬ rec.fID;        dirInfo ¬ rec.dirInfo}      ELSE DirError[fileNotFound]};    LegalName[fileName];    IF String.EmptyString[fileName] THEN DirError[invalidFileName];    [name, pathName] ¬ SplitName[fileName];    {    ENABLE      UNWIND => {        MDirectory.directoryZone.FREE[@name];        MDirectory.directoryZone.FREE[@pathName]};    SELECT name.length = 0 FROM      TRUE => IF pathName.length = 0 THEN DirError[invalidFileName];      FALSE => IF ~IsFilename[name] THEN DirError[invalidFileName];      ENDCASE;    IF pathName.length # 0 AND pathName[0] = '< THEN {      dir ¬ SearchDirTree[        name: pathName, startDir: File.nullFile, createIfMissing: FALSE !        CantFindPath => RESUME ];      SELECT TRUE FROM        dir = File.nullFile => DirError[fileNotFound];        name.length = 0 => file ¬ dir.fileID;  -- must be root directory        ENDCASE => EvalInDir[dir, FileInDirectory];	IF (protectedDir ¬ IsJustProtected[dir]) AND skipProtectedDirs THEN	  DirError[fileNotFound];}    ELSE {      State: TYPE = {notFound, readOnlyVolume, protected};      errorState: State ¬ notFound;      IF searchPathFile = NIL THEN DirError[fileNotFound];      FOR i: CARDINAL IN [0..searchPathNames.length) DO        dir ¬ SearchDirTree[          name: pathName, startDir: searchPathFile[i], createIfMissing: FALSE !          CantFindPath => RESUME ];        IF dir = File.nullFile THEN LOOP;        EvalInDir[dir, FileInDirectory ! DirError => LOOP];         IF (protectedDir ¬ IsJustProtected[dir]) AND skipProtectedDirs THEN	    {IF errorState = notFound THEN errorState ¬ protected; LOOP};        IF dir.volumeID # Volume.systemID AND Volume.GetStatus[dir.volumeID] # openReadWrite AND skipProtectedDirs THEN	    {IF errorState = notFound THEN errorState ¬ readOnlyVolume; LOOP};        EXIT;        REPEAT FINISHED => DirError[	  SELECT errorState FROM	    protected => readOnlyDirectory, 	    readOnlyVolume => volumeNotOpen, 	    ENDCASE => fileNotFound];        ENDLOOP}};  -- end enable    MDirectory.directoryZone.FREE[@pathName];    MDirectory.directoryZone.FREE[@name];    END;  -- BTree Cache  cacheInfo: TYPE = RECORD [    isMapped, protected: BOOLEAN ¬ FALSE,     tree: BTree.Tree ¬ NIL,     count: CARDINAL ¬ 0,     dir: File.File ¬ File.nullFile];  infoSeq: TYPE = RECORD [seq: SEQUENCE COMPUTED CARDINAL OF cacheInfo];  initTableSize: CARDINAL = 8;  tableInc: CARDINAL = 1;  tableSize: CARDINAL ¬ initTableSize;  cacheCount: CARDINAL ¬ 0;  roundRobinPtr: CARDINAL ¬ 0;  info: LONG POINTER TO infoSeq ¬ NIL;  swapAgent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[    AdjustBTreeCache];  closeAgent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[    FlushDirsOnVolume];  inSwap: BOOLEAN ¬ FALSE;  GetTree: PUBLIC PROCEDURE [dir: File.File] RETURNS [tree: Tree] =    BEGIN    i: CARDINAL;    lp: MFileOps.LeaderPage;    FOR i IN [0..tableSize) DO      IF info[i].dir = dir THEN        BEGIN        info[i].count ¬ info[i].count + 1;        IF ~info[i].isMapped THEN {          IF inSwap THEN ERROR ActivityDuringWorldSwap;          SpecialBTree.Map[info[i].tree];          info[i].isMapped ¬ TRUE};        RETURN[info[i].tree]        END;      ENDLOOP;    IF cacheCount = tableSize THEN ExpandTables[tableInc];  -- so we will always find an empty slot    FOR i ¬ roundRobinPtr, IF i = tableSize - 1 THEN 0 ELSE i + 1 UNTIL i =      roundRobinPtr DO IF info[i].count = 0 THEN EXIT; ENDLOOP;    roundRobinPtr ¬ IF i = tableSize - 1 THEN 0 ELSE i + 1;    IF info[i].dir # File.nullFile THEN BTree.Delete[info[i].tree];    info[i].tree ¬ SpecialBTree.MakeFromCapa[      cap: dir,      usage: MUsage.mFileDirectory,      lpSize: MFileOps.leaderPages,      valueSize: SIZE[MDirectory.MValueRec]];    tree ¬ info[i].tree;    info[i].count ¬ 1;    info[i].dir ¬ dir;    info[i].isMapped ¬ TRUE;    lp ¬ MFileOps.MapLeader[dir, TRUE];    info[i].protected ¬  lp.fp.dirInfo.dirProtect;    MFileOps.UnmapLeader[lp];    cacheCount ¬ cacheCount + 1;    END;  FreeTree: PUBLIC PROCEDURE [tree: Tree] =    BEGIN    FOR i: CARDINAL IN [0..tableSize) DO      IF tree = info[i].tree AND info[i].count # 0 THEN        BEGIN        info[i].count ¬ info[i].count - 1;        IF info[i].count = 0 THEN {cacheCount ¬ cacheCount - 1; RETURN};        END;      ENDLOOP;    -- Error if we get here?    END;  ExpandTables: PROCEDURE [increment: CARDINAL] =    BEGIN    newInfo: LONG POINTER TO infoSeq ¬ MDirectory.directoryZone.NEW[      infoSeq [tableSize + increment]];    FOR i: CARDINAL IN [tableSize..tableSize + increment) DO       newInfo[i] ¬ [];        ENDLOOP;    Inline.LongCOPY[from: info, nwords: tableSize*SIZE[cacheInfo], to: newInfo];    MDirectory.directoryZone.FREE[@info];    tableSize ¬ tableSize + increment;    info ¬ newInfo;    END;  IsProtected: PUBLIC PROCEDURE [dir: File.File] RETURNS [BOOLEAN] =    BEGIN      FOR i: CARDINAL IN [0..tableSize) DO      IF info[i].dir # dir THEN LOOP;      IF info[i].protected THEN RETURN[TRUE];      IF dir.volumeID = Volume.systemID THEN RETURN[FALSE];      IF Volume.GetStatus[dir.volumeID] # openReadWrite THEN RETURN[TRUE];      ENDLOOP;    RETURN[FALSE];    END;   IsJustProtected: PROCEDURE [dir: File.File] RETURNS [BOOLEAN] = INLINE    BEGIN      FOR i: CARDINAL IN [0..tableSize) DO      IF info[i].dir # dir THEN LOOP;      IF info[i].protected THEN RETURN[TRUE];      ENDLOOP;    RETURN[FALSE];    END;   GetDir: PROCEDURE [tree: Tree] RETURNS [dir: File.File] =    BEGIN      FOR i: CARDINAL IN [0..tableSize) DO      IF info[i].tree = tree THEN RETURN[info[i].dir];      ENDLOOP;    -- error if we get here?    RETURN[File.nullFile];    END;   UpdateDirCache: PUBLIC PROCEDURE [dir: File.File, protect: BOOLEAN] =    BEGIN      FOR i: CARDINAL IN [0..tableSize) DO      IF info[i].dir = dir THEN {        info[i].protected ¬ protect;	RETURN};      ENDLOOP;    END;   SetMinCacheSize: PUBLIC PROCEDURE [size: CARDINAL] =    BEGIN IF tableSize < size THEN ExpandTables[size - tableSize]; END;  MapCacheEntry: PUBLIC PROCEDURE [tree: Tree] =    BEGIN    IF inSwap THEN ERROR ActivityDuringWorldSwap;    FOR i: CARDINAL IN [0..tableSize) DO      IF tree = info[i].tree THEN {        IF ~info[i].isMapped THEN info[i].isMapped ¬ TRUE;  -- BTree does actual map        -- else error? race condition?        RETURN};      ENDLOOP;    -- Error if we get here?    END;  AdjustBTreeCache: ENTRY Supervisor.AgentProcedure =    BEGIN    ENABLE UNWIND => NULL;    SELECT event FROM      EventTypes.tellFileSystemSwappingOut => {        inSwap ¬ TRUE;        FOR i: CARDINAL IN [0..tableSize) DO          IF info[i].isMapped THEN {            SpecialBTree.Unmap[info[i].tree]; info[i].isMapped ¬ FALSE};          ENDLOOP};      EventTypes.tellFileSystemSwappingIn => {        inSwap ¬ FALSE;        FOR i: CARDINAL IN [0..tableSize) DO          -- no point mapping spaces that aren't in use; map them when next accessed          IF ~info[i].isMapped AND info[i].count > 0 THEN {            SpecialBTree.Map[info[i].tree];	    info[i].isMapped ¬ TRUE};          ENDLOOP};      ENDCASE    END;  FlushDirsOnVolume: ENTRY Supervisor.AgentProcedure =    BEGIN    ENABLE UNWIND => NULL;    volume: LONG POINTER TO Volume.ID = eventData;    IF event # EventTypes.aboutToCloseVolume THEN RETURN;     FOR i: CARDINAL IN [0..tableSize) DO          IF info[i].dir.volumeID # volume­ OR	     info[i].count # 0 THEN LOOP; -- error condition?	  BTree.Delete[info[i].tree];	  info[i] ¬ [isMapped: FALSE,protected: FALSE, tree: NIL, count: 0,	       dir:  File.nullFile]          ENDLOOP;    END;  -- Utilities  AddTask: PROCEDURE [    state: EnumerateState, file: File.File, index: CARDINAL, name: LONG STRING] =    INLINE    BEGIN    state.taskList ¬ MDirectory.directoryZone.NEW[      Task ¬ [      next: state.taskList, dir: file,      dirName: MDirectory.directoryZone.NEW[StringBody [name.length + 1]],      index: index, dirIndex: state.fullNameIndex]];    String.AppendString[state.taskList.dirName, name];    String.AppendChar[state.taskList.dirName, '>];    END;  AppendToFullName: PROCEDURE [state: EnumerateState, name: LONG STRING] =    BEGIN    IF state.fullName = NIL THEN      state.fullName ¬ MDirectory.directoryZone.NEW[StringBody [name.length]]    ELSE      IF state.fullName.maxlength < state.fullName.length + name.length THEN        BEGIN        temp: LONG STRING = MDirectory.directoryZone.NEW[          StringBody [state.fullName.length + name.length]];        String.AppendString[to: temp, from: state.fullName];        MDirectory.directoryZone.FREE[@state.fullName];        state.fullName ¬ temp;        END;    String.AppendString[to: state.fullName, from: name];    END;  CopyStr: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [ns: LONG STRING] = {    IF s = NIL THEN RETURN[NIL];    ns ¬ MDirectory.directoryZone.NEW[StringBody [s.length]];    ns.length ¬ s.length;    Inline.LongCOPY[from: @s.text, to: @ns.text, nwords: (s.length + 1)/2]};  EvalInDir: PUBLIC PROCEDURE [dir: File.File, proc: PROCEDURE [bTree: Tree]] =    BEGIN    bTree: Tree ¬ GetTree[dir];    proc[bTree ! UNWIND => FreeTree[bTree]];    FreeTree[bTree];    END;  FreeTaskList: PROCEDURE [state: EnumerateState] =    BEGIN    temp, task: TaskHandle;    IF state = NIL THEN RETURN;    IF state.lastMatch # NIL THEN MDirectory.directoryZone.FREE[@state.lastMatch];    IF state.tree # NIL THEN FreeTree[state.tree];    IF state.fullName # NIL THEN MDirectory.directoryZone.FREE[@state.fullName];    FOR task ¬ state.taskList, temp UNTIL task = NIL DO      temp ¬ task.next;      IF task.dirName # NIL THEN MDirectory.directoryZone.FREE[@task.dirName];      MDirectory.directoryZone.FREE[@task];      ENDLOOP;    MDirectory.directoryZone.FREE[@state];    END;  GetNextTask: PROCEDURE [state: EnumerateState] =    BEGIN    temp: TaskHandle;    IF state.tree # NIL THEN {FreeTree[state.tree]; state.tree ¬ NIL};    IF state.taskList = NIL THEN RETURN;    state.lastMatch.length ¬ 0;    state.index ¬ state.taskList.index;    state.tree ¬ GetTree[state.taskList.dir];    SELECT state.taskList.searchPathIndex FROM      MFile.searchPathNotUsed =>         BEGIN        IF state.fullName # NIL THEN 	  state.fullName.length ¬ state.taskList.dirIndex;        AppendToFullName[state, state.taskList.dirName];        END;      ENDCASE =>        IF state.fullName # NIL THEN state.fullName.length ¬ 0;    state.sp ¬ state.taskList.searchPathIndex;    state.fullNameIndex ¬ String.Length[state.fullName];    state.volume ¬ state.taskList.dir.volumeID;    temp ¬ state.taskList;    state.taskList ¬ state.taskList.next;    IF temp.dirName # NIL THEN MDirectory.directoryZone.FREE[@temp.dirName];    MDirectory.directoryZone.FREE[@temp];    END;  GetNextTreeEntry: PROCEDURE [    filter, name: LONG STRING, which: MFile.EnumerationType,    state: EnumerateState]    RETURNS [file: File.File ¬ File.nullFile, dirInfo: MDirectory.DirInfo] =    BEGIN    rec: MDirectory.MValueRec;    value: MDirectory.MValue = @rec;    match, endOfLevel: BOOLEAN ¬ FALSE;    pattern: STRING ¬ [100];  -- do this right later: allocate dynamically?    newindex: CARDINAL;    name.length ¬ 0;    IF filter = NIL OR filter.length = 0 OR state.index = filter.length THEN      RETURN;    FOR i: CARDINAL IN [state.index..filter.length) DO      SELECT filter[i] FROM        '> => {endOfLevel ¬ TRUE; EXIT};        '* => {          String.AppendChar[pattern, '*];          IF i < filter.length - 1 AND filter[i + 1] = '* THEN EXIT};        ENDCASE => String.AppendChar[pattern, filter[i]];      ENDLOOP;    DO      IF state.fullName # NIL THEN state.fullName.length ¬ state.fullNameIndex;      BTree.GetNext[        tree: state.tree, name: state.lastMatch, nextName: name, 	value: MDirectory.MValueToValue[value], mask: pattern];      IF name.length = 0 THEN RETURN[File.nullFile, []];      state.lastMatch.length ¬ 0;      AppendToFullName[state, name];      String.AppendString[to: state.lastMatch, from: name];      file ¬ [value.fID, [state.volume]];      dirInfo ¬ value.dirInfo;      SELECT dirInfo.type FROM        directory =>          BEGIN          [match, newindex] ¬ MatchLevel[            state.fullName, 0, filter, 0, state.index + pattern.length];          IF newindex # filter.length THEN            AddTask[              state, file, IF endOfLevel THEN newindex + 1 ELSE newindex, name];          -- check if we really matched this name, too          IF which = filesOnly THEN LOOP;          IF newindex = filter.length THEN EXIT;  -- return this one          match ¬ TRUE;          FOR i: CARDINAL IN [newindex..filter.length - 1) DO            IF filter[i] # wildString THEN {match ¬ FALSE; EXIT}; ENDLOOP;          match ¬ match            AND              (filter[filter.length - 1] = '>                OR filter[filter.length - 1] = wildString);          IF match THEN EXIT;  -- return this one          END;        ENDCASE =>          IF which # directoriesOnly AND ~endOfLevel            AND Match[state.fullName, 0, filter, 0, filter.length].outcome THEN            EXIT;  -- return this one      name.length ¬ 0;      ENDLOOP;    state.lastMatch.length ¬ 0;    String.AppendString[to: state.lastMatch, from: name];    END;  IsFilename: PUBLIC PROCEDURE [name: LONG STRING] RETURNS [BOOLEAN] =    BEGIN    IF name = NIL OR name.length = 0 OR name.length > BTree.maxNameLength THEN      RETURN[FALSE];    FOR i: CARDINAL IN [0..name.length) DO      SELECT name[i] FROM        IN ['a..'z], IN ['A..'Z], IN ['0..'9], '., '$, '+, '- => LOOP;        ENDCASE => RETURN[FALSE];      ENDLOOP;    RETURN[TRUE];    END;  LegalName: PUBLIC PROCEDURE [name: LONG STRING] =    BEGIN    IF name = NIL OR name.length = 0 THEN RETURN;    FOR i: CARDINAL IN [0..name.length) DO      SELECT name[i] FROM        IN ['a..'z], IN ['A..'Z], IN ['0..'9], '., '$, '+, '-, '> => LOOP;        '< => IF i # 0 THEN DirError[invalidFileName];        ENDCASE => DirError[invalidFileName];      ENDLOOP;    END;  LegalPattern: PROCEDURE [name: LONG STRING] =    BEGIN    IF name = NIL OR name.length = 0 THEN RETURN;    FOR i: CARDINAL IN [0..name.length) DO      SELECT name[i] FROM        IN ['a..'z], IN ['A..'Z], IN ['0..'9], '., '$, '+, '-, '>, '*, '# =>          LOOP;        '< => IF i # 0 THEN DirError[invalidFileName];        ENDCASE => DirError[invalidFileName];      ENDLOOP;    END;  LookUpDirectory: PUBLIC PROCEDURE [path: LONG STRING, createIfMissing: BOOLEAN]    RETURNS [dir: File.File] =    BEGIN    LegalName[path];    IF path[0] = '< THEN      dir ¬ SearchDirTree[        name: path, startDir: File.nullFile, createIfMissing: createIfMissing !        CantFindPath => RESUME ]    ELSE {      IF searchPathFile = NIL THEN RETURN[File.nullFile];      FOR i: CARDINAL IN [0..searchPathNames.length) DO        dir ¬ SearchDirTree[          name: path, startDir: searchPathFile[i],          createIfMissing: createIfMissing ! CantFindPath => RESUME ];        IF dir # File.nullFile THEN EXIT;        ENDLOOP};    END;  Match: PUBLIC PROCEDURE [    file: LONG STRING, fileIndex: CARDINAL, mask: LONG STRING,    maskIndex: CARDINAL, posToBeFound: CARDINAL]    RETURNS [outcome: BOOLEAN, correspondingingPos: CARDINAL] =    BEGIN    -- local variables    i, j: CARDINAL;    -- process each character in mask    FOR i IN [maskIndex..mask.length) DO      IF i = posToBeFound THEN correspondingingPos ¬ fileIndex;      SELECT mask[i] FROM        wildString =>  -- matches any string of zero or more characters          BEGIN          FOR j IN [fileIndex..file.length] DO            IF Match[file, j, mask, i + 1, posToBeFound].outcome THEN              RETURN[TRUE, correspondingingPos];            ENDLOOP;          RETURN[FALSE, 0];          END;        wildChar =>  -- matches any single character          IF fileIndex = file.length THEN RETURN[FALSE, correspondingingPos]          ELSE fileIndex ¬ fileIndex + 1;        ENDCASE =>          IF fileIndex = file.length            OR String.LowerCase[file[fileIndex]] # String.LowerCase[mask[i]] THEN            RETURN[FALSE, 0]          ELSE fileIndex ¬ fileIndex + 1;      ENDLOOP;    -- filename passes mask if entire filename has been consumed    outcome ¬ fileIndex = file.length;    END;  MatchLevel: PROCEDURE [    file: LONG STRING, fileIndex: CARDINAL, mask: LONG STRING,     maskIndex, endOfMask: CARDINAL]    RETURNS [outcome: BOOLEAN, newIndex: CARDINAL] =    BEGIN    -- local variables    i, j: CARDINAL;    -- process each character in mask    FOR i IN [maskIndex..endOfMask) DO      SELECT mask[i] FROM        wildString =>  -- matches any string of zero or more characters          BEGIN          IF i + 1 < mask.length AND mask[i + 1] = wildString THEN RETURN[TRUE, i];          FOR j IN [fileIndex..file.length] DO            [outcome, newIndex] ¬ MatchLevel[file, j, mask, i + 1, endOfMask];            IF outcome = TRUE THEN RETURN;            ENDLOOP;          RETURN[FALSE, maskIndex];          END;        wildChar =>   -- matches any single character          IF fileIndex = file.length THEN RETURN[TRUE, maskIndex]          ELSE fileIndex ¬ fileIndex + 1;        ENDCASE =>          BEGIN          IF fileIndex = file.length             OR String.LowerCase[file[fileIndex]] # String.LowerCase[mask[i]] THEN	    RETURN[FALSE, maskIndex]          ELSE fileIndex ¬ fileIndex + 1;	  END;      ENDLOOP;    -- filename passes mask if entire filename has been consumed   newIndex ¬  endOfMask;   outcome ¬ fileIndex = file.length;   END;  SearchDirTree: PUBLIC PROCEDURE [    name: LONG STRING, startDir: File.File, createIfMissing: BOOLEAN]    RETURNS [dir: File.File] =    BEGIN    subDirectoryName: STRING = [MFile.maxNameLength];    offset: CARDINAL ¬ 0;    ok: BOOLEAN;    rec: MDirectory.MValueRec;    value: BTree.Value = MDirectory.MValueToValue[@rec];    GetFileFromDirectory: PROCEDURE [bTree: Tree] = {      ok ¬ BTree.Find[bTree, subDirectoryName, value]; -- sets rec      IF ok THEN {        dir.fileID ¬ rec.fID;        IF rec.dirInfo.type # directory THEN          DirError[fileNotSD]}};    IF startDir = File.nullFile THEN       [dir, offset] ¬ VolumeRootDir[name, createIfMissing]    ELSE dir ¬ startDir;    DO      subDirectoryName.length ¬ 0;      WHILE offset < name.length DO        SELECT name[offset] FROM          IN ['a..'z], IN ['A..'Z], IN ['0..'9], '!, ';, '-, '., '$, '+ =>            String.AppendChar[subDirectoryName, name[offset]];          ENDCASE => {offset ¬ offset + 1; EXIT};        offset ¬ offset + 1;        ENDLOOP;      IF subDirectoryName.length = 0 THEN EXIT;      EvalInDir[dir, GetFileFromDirectory];      IF ~ok THEN        SELECT createIfMissing FROM          FALSE => {            SIGNAL CantFindPath[subDirectoryName]; dir ¬ File.nullFile; EXIT};          ENDCASE =>            dir ¬ MDirectory.CreateNewSubdirectory[dir, subDirectoryName];      ENDLOOP;    END;  SetUpTaskList: INTERNAL PROCEDURE [filter: LONG STRING]    RETURNS [state: EnumerateState, rootMatched: BOOLEAN ¬ FALSE, dir: File.File] =    BEGIN    state ¬ MDirectory.directoryZone.NEW[EnumRec];    state.lastMatch ¬ MDirectory.directoryZone.NEW[      StringBody [MFile.maxNameLength]];    state.fullName ¬ NIL;    IF filter # NIL AND filter.length # 0 AND filter[0] = '< THEN      BEGIN      [dir, state.index] ¬ VolumeRootDir[filter, FALSE];  -- no wild cards in volume name!      state.volume ¬  dir.volumeID;      rootMatched ¬ TRUE;      FOR i: CARDINAL IN [state.index..filter.length) DO        IF filter[i] # '* THEN {rootMatched ¬ FALSE; EXIT}; ENDLOOP;      state.tree ¬ GetTree[dir];      state.fullName ¬ MDirectory.directoryZone.NEW[StringBody [state.index]];      FOR i: CARDINAL IN [0..state.index) DO        String.AppendChar[state.fullName, filter[i]]; ENDLOOP;      state.fullNameIndex ¬ state.index;      state.sp ¬ MFile.searchPathNotUsed;      END    ELSE      BEGIN      IF searchPathFile = NIL THEN RETURN;      state.tree ¬ GetTree[searchPathFile[0]];      state.volume ¬ searchPathFile[0].volumeID;      state.fullNameIndex ¬ 0;      state.sp ¬ 0;      FOR i: CARDINAL DECREASING IN [1..searchPathNames.length) DO        state.taskList ¬ MDirectory.directoryZone.NEW[          Task ¬ [          next: state.taskList, dir: searchPathFile[i], searchPathIndex: i]];        ENDLOOP;      END;    END;  SplitName: PUBLIC PROCEDURE [path: LONG STRING]    RETURNS [name, pathName: LONG STRING] =    BEGIN    i: CARDINAL;    pathName ¬ MDirectory.directoryZone.NEW[StringBody [path.length]];    FOR i DECREASING IN [0..path.length) DO      IF path[i] = '> THEN {i ¬ i + 1; EXIT}; ENDLOOP;    name ¬ MDirectory.directoryZone.NEW[StringBody [path.length - i]];    FOR j: CARDINAL IN [0..i) DO String.AppendChar[pathName, path[j]]; ENDLOOP;    FOR j: CARDINAL IN [i..path.length) DO      String.AppendChar[name, path[j]]; ENDLOOP;    END;  ValidateFile: PUBLIC PROCEDURE [file: File.File] RETURNS [ok: BOOLEAN ¬ TRUE] =    BEGIN    <<type: File.Type;    temporary: BOOLEAN;    [type, temporary] ¬ File.GetAttributes[      file: file ! File.Unknown => {ok ¬ FALSE; CONTINUE}];    IF ~ok OR temporary OR ~(type IN MesaDEFileTypes.MesaDEFileType)      THEN Runtime.CallDebugger["Bad file in directory."];>>    END;  VolumeRootDir: PROCEDURE [path: LONG STRING, createIfMissing: BOOLEAN]    RETURNS [rootDir: File.File, offset: CARDINAL ¬ 0] =    BEGIN    volumeName: LONG STRING ¬ [Volume.maxNameLength];    IF path[0] # '< THEN rootDir.volumeID ¬ Volume.systemID    ELSE      BEGIN      WHILE (offset ¬ offset + 1) < path.length AND path[offset] # '> DO        String.AppendChar[volumeName, path[offset]]; ENDLOOP;      IF volumeName.length = 0 THEN rootDir.volumeID ¬ Volume.systemID      ELSE {        rootDir.volumeID ¬ Volume.nullID;	UNTIL (rootDir.volumeID ¬ Volume.GetNext[rootDir.volumeID, ALL[TRUE]]) = Volume.nullID DO          volumeLabel: STRING ¬ [Volume.maxNameLength];          Volume.GetLabelString[rootDir.volumeID, volumeLabel];          IF String.EquivalentString[volumeLabel, volumeName] THEN EXIT;          ENDLOOP};      IF rootDir.volumeID = Volume.nullID THEN DirError[invalidVolume];      END;    IF path[offset] = '> THEN offset ¬ offset + 1;  -- skip "closing" >    rootDir ¬ MDirectory.InternalLookupRootDir[      rootDir.volumeID !      NoRootDir =>        IF createIfMissing THEN RESUME ELSE ERROR DirError[noRootDirectory]];    END;  -- main body  RegisterWithSupervisor: PUBLIC PROCEDURE = {    Supervisor.AddDependency[client: swapAgent, implementor: Event.swapping];    Supervisor.AddDependency[client: closeAgent, implementor: Event.fileSystem]};  StartMDirectoryImplA: PUBLIC PROCEDURE = {    info ¬ MDirectory.directoryZone.NEW[infoSeq [initTableSize]];    FOR i: CARDINAL IN [0..initTableSize) DO      info[i].tree ¬ NIL;      info[i].count ¬ 0;      info[i].dir ¬ File.nullFile;      info[i].isMapped ¬ FALSE;      ENDLOOP};  END.. of MDirectoryImplA  10-Jul-87 12:15:37 - rlc - avoid lousy code warning in IsValid
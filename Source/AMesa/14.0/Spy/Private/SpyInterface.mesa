-- Copyright (C) 1981, 1982, 1983, 1986  by Xerox Corporation. All rights reserved. -- SpyInterface.mesa - last edited by-- JBD    	15-Sep-86  8:53:25-- AXD    	24-Oct-83 15:59:23-- BXM  	23-Feb-82 15:39:48-- RXL  	 2-Nov-81 18:14:12    DIRECTORY  Ascii USING [CR, NUL, SP],  DebugUsefulDefs USING [    LongCopyREAD, LongCopyWRITE, MultipleFrames, NotFound,     LongREAD, LongWRITE],  DebugUsefulDefsExtras USING [ApplyProcedure, ArgsOrResults, ControlLink,     Frame, Numeric, Valid, WordSeq, GFlong, GFshort, Started],  Environment USING [wordsPerPage],  EventTypes USING [aboutToAbortSession,    aboutToResume, newSession, resumeDebuggee, resumeSession, spare2, spare3],  GFHash USING [Fetch, Insert, Nil, Pairs, Table],  GFHashDebug USING [Acquire, Release],  Heap USING [systemZone],  PrincOpsExtras2 USING [GFTHandle, nullGFH, LongGlobalFrameHandle],  PSB USING [PsbIndex, PsbNull],  SpyFormat USING [    Bracket, Buckets, Count, Ignore, LevelData, Map,    MapBase, MapHandle, MapPos, PcMap, ProcessAction, ProcessTable],  SpyKernel USING [    active, Allocator, hist, levelData, maps, notScheduled, pails,    priority, processTable, skips, variableStorageAllocated, wakeups],  SpyOps USING [    AddAllProcsForModule, AddModuleForExistingProcs, AddProcForModule,    AddSourceForProc, BuildingTables,    Complain, FreeWords, IgnoreExistingProc,    ignoreProcs, KernelFrame, Line, priorityToWatch, processAction,    processes, rebuildTables, sorted, spyOn,    watchProcs, Words, zeroData],  String USING [AppendChar, InvalidNumber, StringToNumber, StringToLongNumber],  SwordUsefulDefs,  Supervisor USING [AgentProcedure, EnumerationAborted, Event],  SymbolTable USING [Missing];      SpyInterface: PROGRAM   IMPORTS     DebugUsefulDefs, DebugUsefulDefsExtras,     GFHash, GFHashDebug, Heap, SpyOps, String, Supervisor,     SymbolTable, SwordUsefulDefs  EXPORTS SpyOps  SHARES SpyKernel, SwordUsefulDefs =  BEGIN  -- TYPEs --  GFTHandle: TYPE = PrincOpsExtras2.GFTHandle;    -- Imported compile-time constants --  nullGFH: GFTHandle = PrincOpsExtras2.nullGFH;  -- Global Exported Variables --  kernel: PUBLIC SpyOps.KernelFrame ¬ NIL;  hist: PUBLIC GFHash.Table ¬ GFHash.Nil;  maps: PUBLIC SpyFormat.MapBase ¬ NIL;  mapsStorageSpace: PUBLIC CARDINAL ¬ Environment.wordsPerPage;  lastMap: PUBLIC SpyFormat.MapPos;  pails: PUBLIC SpyFormat.Buckets ¬ NIL;  pailStorageSpace: PUBLIC CARDINAL ¬ Environment.wordsPerPage;  -- Other Global Variables --  processTable: SpyFormat.ProcessTable;  -- Table Construction --    kernelSpaceNeeded: CARDINAL;  callingKernel: BOOLEAN ¬ FALSE;  blowingWorldAway: BOOLEAN ¬ FALSE;    SameWorld: PUBLIC Supervisor.AgentProcedure = {    IF SwordUsefulDefs.defaultWorld # SwordUsefulDefs.localWorld       AND SwordUsefulDefs.defaultWorld # NIL THEN RETURN;    SELECT event FROM      EventTypes.aboutToResume, EventTypes.aboutToAbortSession =>         TryToBuildTables[event, eventData, instanceData];      EventTypes.resumeDebuggee, EventTypes.resumeSession =>        Notify[event, eventData, instanceData];      ENDCASE;    };  TryToBuildTables: PUBLIC Supervisor.AgentProcedure = {    fake: LONG POINTER TO Supervisor.Event = eventData;    SELECT TRUE FROM      event # EventTypes.aboutToResume AND       (event # EventTypes.spare2 OR fake = NIL OR        fake­ # EventTypes.aboutToResume) => {blowingWorldAway ¬ TRUE; RETURN};      ~SpyOps.spyOn => RETURN;      ~KernelLocated[] => RETURN;      SpyOps.zeroData => SpyOps.rebuildTables ¬ TRUE;      ENDCASE;    IF SpyOps.rebuildTables THEN {      SpyOps.BuildingTables[started];      BuildTables[ ! UNWIND => SpyOps.BuildingTables[done]];      SpyOps.BuildingTables[done]}};    BuildTables: PROC = {    {ZeroCount: PROC [      gf: GFTHandle, p: LONG POINTER TO SpyFormat.Count]      RETURNS [BOOLEAN] = {p­ ¬ 0; RETURN[FALSE]};    IF hist = GFHash.Nil THEN {      kHist: GFHash.Table;      DebugUsefulDefs.LongCopyREAD[        from: @kernel.hist, nwords: GFHash.Table.SIZE, to: @kHist];      hist ¬ GFHashDebug.Acquire[kHist]};    [] ¬ hist.Pairs[ZeroCount]};    lastMap.index ¬ 0;    pails ¬ DESCRIPTOR[pails.BASE, 0];    ParseProcedures[ignore: FALSE];    ParseProcedures[ignore: TRUE];    ParseProcesses[];    EnsureAdequateKernelSpace[]};    HistEntry: PUBLIC PROC [gf: GFTHandle]    RETURNS [p: LONG POINTER TO SpyFormat.Count] = {    p ¬ hist.Fetch[gf];    IF p = NIL THEN {p ¬ hist.Insert[gf];  IF p # NIL THEN p­ ¬ 0}};        ParseProcedures: PROC [ignore: BOOLEAN] = {    procs: LONG STRING ¬       IF ignore THEN SpyOps.ignoreProcs ELSE SpyOps.watchProcs;    charIndex: CARDINAL ¬ 0;    Get: PROC RETURNS [c: CHARACTER] = {      IF procs = NIL OR charIndex >= procs.length THEN RETURN[Ascii.NUL];      c ¬ procs[charIndex]; charIndex ¬ charIndex + 1};    SortMap: PROC [mapStart, nextMap: SpyFormat.MapPos] = {      length: CARDINAL = (nextMap.index - mapStart.index)/SpyFormat.Bracket.SIZE;      map: SpyFormat.MapHandle = @maps[mapStart.ptr];      IF length = 0 THEN RETURN;      FOR i: CARDINAL IN [0..length) DO        FOR j: CARDINAL IN [i..length) DO	  IF map[i].origin > map[j].origin THEN {	    temp: SpyFormat.Bracket ¬ map[i];	    map[i] ¬ map[j]; map[j] ¬ temp};	  ENDLOOP;        ENDLOOP};    map: SpyFormat.MapPos ¬ lastMap;    DO      gf: GFTHandle ¬ nullGFH;      module: STRING ¬ [40];      source: BOOLEAN;      term: CHARACTER;      nextMap: SpyFormat.MapPos ¬ map;      ParseProcs: PROC [action: PROC [LONG STRING]] = {	proc: STRING ¬ [40];	UNTIL term = '; DO	  [term: term, slash: source] ¬ GetToken[Get, proc];	  IF proc.length = 0 THEN EXIT;	  action[proc];	  ENDLOOP};      [term: term, slash: source] ¬ GetToken[Get, module];      IF module.length = 0 THEN EXIT;      IF DebugUsefulDefsExtras.Numeric[module] THEN {        long: PrincOpsExtras2.LongGlobalFrameHandle;	long ¬ String.StringToLongNumber[module, 8  ! String.InvalidNumber => 	  {SpyOps.Complain[invalidNumber, module]; GO TO veto}];	IF long ~= NIL AND 	  ~DebugUsefulDefsExtras.Valid[DebugUsefulDefsExtras.GFshort[long]] THEN	  {SpyOps.Complain[invalidFrame, @gf]; GO TO veto};	gf ¬ DebugUsefulDefsExtras.GFshort[long] }      ELSE 	gf ¬ DebugUsefulDefsExtras.Frame[module !	  DebugUsefulDefs.MultipleFrames =>		  {SpyOps.Complain[ambiguous, module]; GO TO veto};	  DebugUsefulDefs.NotFound => CONTINUE];      IF gf = nullGFH THEN {SpyOps.Complain[noSymbols, module]; GO TO veto};      IF HistEntry[gf]­ >= SpyFormat.Ignore THEN {	SpyOps.Complain[repeatedModule, module]; GO TO veto};      IF ignore THEN        IF term = ': THEN {	  IgnoreProc: PROC [proc: LONG STRING] = {	    SpyOps.IgnoreExistingProc[gf, proc]};	  nextMap ¬ SpyOps.AddAllProcsForModule[gf, map ! SymbolTable.Missing =>			{SpyOps.Complain[noSymbols, module]; GO TO veto}];	  SortMap[map, nextMap];	  ParseProcs[IgnoreProc]}	ELSE HistEntry[gf]­ ¬ SpyFormat.Ignore      ELSE        IF term = ': THEN {	  index: CARDINAL ¬ 0;	  AddOneProc: PROC [proc: LONG STRING] = {	    OPEN SpyOps;	    index ¬	      (IF source THEN AddSourceForProc ELSE AddProcForModule)[	        gf, proc, map, index]};	  ParseProcs[AddOneProc];	  nextMap ¬ SpyOps.AddModuleForExistingProcs[gf, map, index];	  SortMap[map, nextMap]}	ELSE {	  nextMap ¬ SpyOps.AddAllProcsForModule[gf, map ! SymbolTable.Missing =>			{SpyOps.Complain[noSymbols, module]; GO TO veto}];	  SortMap[map, nextMap]};      map ¬ nextMap;      ENDLOOP;    lastMap ¬ map;    EXITS      veto => ERROR Supervisor.EnumerationAborted};    ParseProcesses: PROC = {    processes: LONG STRING ¬ SpyOps.processes;    charIndex: CARDINAL ¬ 0;    Get: PROC RETURNS [c: CHARACTER] ={      IF processes = NIL OR charIndex >= processes.length THEN RETURN[Ascii.NUL];      c ¬ processes[charIndex]; charIndex ¬ charIndex + 1};    firstTime: BOOLEAN ¬ TRUE;    processTable ¬ ALL[SpyFormat.ProcessAction[watch]];    DO      psb, lastPsb: PSB.PsbIndex ¬ PSB.PsbNull;      process: STRING ¬ [40];      term: CHARACTER;      slash: BOOLEAN;      [term: term, slash: slash] ¬ GetToken[Get, process];      IF slash THEN {SpyOps.Complain[illegalSlash, process]; GO TO veto};      IF process.length = 0 THEN EXIT;      IF DebugUsefulDefsExtras.Numeric[process] THEN 	psb ¬ String.StringToNumber[	  process, 8 ! String.InvalidNumber => CONTINUE];      IF psb = PSB.PsbNull THEN {        SpyOps.Complain[invalidNumber, process]; GO TO veto};      IF term = '. THEN {	IF Get[] ~= '. THEN {SpyOps.Complain[illegalRange, process]; GO TO veto};	[term: , slash: slash] ¬ GetToken[Get, process];	IF slash THEN {SpyOps.Complain[illegalSlash, process]; GO TO veto};	IF DebugUsefulDefsExtras.Numeric[process] THEN	  lastPsb ¬ String.StringToNumber[	    process, 8 ! String.InvalidNumber => CONTINUE];        IF lastPsb = PSB.PsbNull THEN {	  SpyOps.Complain[invalidNumber, process]; GO TO veto}}      ELSE lastPsb ¬ psb;      IF firstTime THEN {	firstTime ¬ FALSE;	IF SpyOps.processAction = watch THEN	  processTable ¬ ALL[SpyFormat.ProcessAction[ignore]]};      FOR psb IN [psb..lastPsb] DO	processTable[psb] ¬ SpyOps.processAction;	ENDLOOP;      ENDLOOP;    EXITS      veto => ERROR Supervisor.EnumerationAborted};    GetToken: PROC [get: PROC RETURNS [CHARACTER], token: STRING]    RETURNS [term: CHARACTER, slash: BOOLEAN] = {    OPEN Ascii;    trashbin: STRING ¬ [40];    s: STRING ¬ token;    token.length ¬ 0;    slash ¬ FALSE;    WHILE (term ¬ get[]) ~= NUL DO      SELECT term FROM	SP, CR, ':, ',, ';, '. =>	  IF token.length # 0 OR s.length # 0 THEN RETURN;	'/ => {s ¬ trashbin; slash ¬ TRUE};	ENDCASE => String.AppendChar[s, term];      ENDLOOP};  EnsureAdequateKernelSpace: PROC = {    pailSpace: CARDINAL = pails.LENGTH*SpyFormat.PcMap.SIZE;    kernelSpace: CARDINAL =       DebugUsefulDefs.LongREAD[@kernel.variableStorageAllocated];    mapsSpace: CARDINAL = lastMap.index;    kernelSpaceNeeded ¬ mapsSpace + pailSpace;    IF kernelSpace < kernelSpaceNeeded THEN {      Cleanup: PROC = {AdjustActiveCount[-1]; callingKernel ¬ FALSE};      AdjustActiveCount[1]; callingKernel ¬ TRUE;      CallUser[ ! UNWIND => Cleanup[]];      Cleanup[]}};  CallUser: PROC = {    -- Note This procedure must be called from CoPilot's notifier process.    args: DebugUsefulDefsExtras.ArgsOrResults ¬ Heap.systemZone.NEW[DebugUsefulDefsExtras.WordSeq[1]];    results: DebugUsefulDefsExtras.ArgsOrResults ¬ NIL;    cl: DebugUsefulDefsExtras.ControlLink;    SpyOps.Line["Allocating extra bucket storage."L];    args[0] ¬ kernelSpaceNeeded;     DebugUsefulDefs.LongCopyREAD[      from: @kernel.Allocator, to: @cl, nwords: DebugUsefulDefsExtras.ControlLink.SIZE];  DebugUsefulDefsExtras.ApplyProcedure[cl, args, results] };    -- Transition Procedures --  Activate: PUBLIC PROC = {    maps ¬ SpyOps.Words[mapsStorageSpace].p;    pails ¬ DESCRIPTOR[SpyOps.Words[pailStorageSpace].p, 0];    lastMap.index ¬ 0;    ResetKernel[]};  Deactivate: PUBLIC PROC = {    maps ¬ SpyOps.FreeWords[maps];    [] ¬ SpyOps.FreeWords[pails.BASE];    pails ¬ NIL;    IF hist # GFHash.Nil THEN {      GFHashDebug.Release[hist, FALSE]; hist ¬ GFHash.Nil}};  -- Table Installation --  Notify: PUBLIC Supervisor.AgentProcedure = {    fake: LONG POINTER TO Supervisor.Event = eventData;    SELECT TRUE FROM      event = EventTypes.newSession,       event = EventTypes.spare3 AND fake # NIL AND        fake­ = EventTypes.newSession => {	SpyOps.sorted ¬ SpyOps.rebuildTables ¬ blowingWorldAway ¬ FALSE;	ResetKernel[]};      event = EventTypes.resumeSession,      event = EventTypes.spare3 AND fake # NIL AND        fake­ = EventTypes.resumeSession =>        IF ~callingKernel THEN {	  SpyOps.sorted ¬ SpyOps.rebuildTables ¬ FALSE;          IF KernelLocated[] THEN ReadTable[]};      event = EventTypes.resumeDebuggee,      event = EventTypes.spare3 AND fake # NIL AND        fake­ = EventTypes.resumeDebuggee =>        IF ~callingKernel AND ~blowingWorldAway AND KernelLocated[]	  THEN WriteTable[];      ENDCASE};    ResetKernel: PROC = {SpyOps.spyOn ¬ FALSE; kernel ¬ NIL};      KernelLocated: PUBLIC PROC RETURNS [BOOLEAN] = {    many: BOOLEAN ¬ FALSE;    IF blowingWorldAway THEN RETURN [FALSE];    IF kernel = NIL THEN {      kernel ¬ LOOPHOLE[DebugUsefulDefsExtras.GFlong[        DebugUsefulDefsExtras.Frame["SpyKernel"L 	! DebugUsefulDefs.NotFound => GOTO Continue;	  DebugUsefulDefs.MultipleFrames => {many ¬ TRUE; GOTO Continue}]]];      EXITS Continue => NULL };    SELECT TRUE FROM      many => SpyOps.Complain[multipleKernels];      kernel = NIL => IF SpyOps.spyOn THEN SpyOps.Complain[noKernel];      ~DebugUsefulDefsExtras.Started[DebugUsefulDefsExtras.GFshort[LOOPHOLE[kernel]]] => {        kernel ¬ NIL;        IF SpyOps.spyOn THEN SpyOps.Complain[kernelNotStarted]};      ENDCASE;    RETURN[kernel ~= NIL]};  ReadTable: PROC = {    OPEN DebugUsefulDefs;    kHist: GFHash.Table;    kmaps: SpyFormat.MapBase;    SpyOps.priorityToWatch ¬ LongREAD[@kernel.priority];    AdjustActiveCount[-1];    LongCopyREAD[      from: @kernel.hist, nwords: GFHash.Table.SIZE, to: @kHist];    IF hist # GFHash.Nil THEN GFHashDebug.Release[hist, FALSE];    hist ¬ GFHashDebug.Acquire[kHist];    LongCopyREAD[      from: @kernel.maps, nwords: SpyFormat.MapBase.SIZE, to: @kmaps];    LongCopyREAD[from: kmaps, to: maps, nwords: lastMap.index]};   WriteTable: PROC = {    OPEN DebugUsefulDefs;    kMaps: SpyFormat.MapBase;    InitializeKernelCounters: PROC = INLINE {      zero: SpyFormat.Count ¬ 0;      zerodata: SpyFormat.LevelData ¬ ALL[0];      kLevelData: LONG POINTER TO SpyFormat.LevelData;      LongCopyWRITE[        from: @zero, to: @kernel.wakeups, nwords: SpyFormat.Count.SIZE];      LongCopyWRITE[        from: @zero, to: @kernel.notScheduled, nwords: SpyFormat.Count.SIZE];      LongCopyWRITE[        from: @zero, to: @kernel.skips, nwords: SpyFormat.Count.SIZE];      LongCopyREAD[        from: @kernel.levelData, to: @kLevelData, nwords: SIZE[LONG POINTER]];      LongCopyWRITE[        from: @zerodata, to: kLevelData, nwords: SpyFormat.LevelData.SIZE]};    MoveHistogram: PROC = INLINE {      GFHashDebug.Release[hist, TRUE]; hist ¬ GFHash.Nil};    MoveProcessTable: PROC = INLINE {      kProcessTable: LONG POINTER TO SpyFormat.ProcessTable;      LongCopyREAD[        from: @kernel.processTable, to: @kProcessTable,	nwords: SIZE[LONG POINTER]];      LongCopyWRITE[        from: @processTable, to: kProcessTable,	nwords: SpyFormat.ProcessTable.SIZE]};    MoveMaps: PROC = INLINE {      LongCopyREAD[        from: @kernel.maps, to: @kMaps, nwords: SpyFormat.MapBase.SIZE];      LongCopyWRITE[from: maps, to: kMaps, nwords: lastMap.index]};    MovePails: PROC = INLINE {      kPails: SpyFormat.Buckets ¬ DESCRIPTOR[@kMaps[lastMap.ptr], pails.LENGTH];      LongCopyWRITE[        from: @kPails, to: @kernel.pails, nwords: SpyFormat.Buckets.SIZE];      LongCopyWRITE[        from: pails.BASE, to: kPails.BASE,	nwords: kPails.LENGTH * SpyFormat.PcMap.SIZE]};    AdjustActiveCount[1];    IF ~SpyOps.rebuildTables OR callingKernel THEN RETURN;    LongWRITE[@kernel.priority, SpyOps.priorityToWatch];    InitializeKernelCounters[];    IF hist # GFHash.Nil THEN MoveHistogram[];    MoveProcessTable[];    IF lastMap.index ~= 0 THEN {MoveMaps[]; MovePails[]}};  AdjustActiveCount: PROC [amount: INTEGER] = {    active: INTEGER ¬ DebugUsefulDefs.LongREAD[@kernel.active];    IF ~SpyOps.spyOn THEN RETURN;    DebugUsefulDefs.LongWRITE[@kernel.active, active + amount]};  END.
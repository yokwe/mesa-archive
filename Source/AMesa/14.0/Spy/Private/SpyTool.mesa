-- Copyright (C) 1981, 1982, 1983, 1986  by Xerox Corporation. All rights reserved. -- SpyTool.mesa - last edit-- JBD    	 9-Sep-86 18:04:03-- AXD    	25-Oct-83 15:24:14-- BXM  	28-Jan-82 16:30:25-- RXL  	 2-Nov-81 17:46:28DIRECTORY  Ascii: TYPE USING [SP],  DebugUsefulDefs: TYPE USING [    InvalidFrame, LongCopyREAD, UserAborted],  DebugUsefulDefsExtras: TYPE USING [CBti, Copied, ExitPC, Name, Valid],  Environment: TYPE USING [PageCount, wordsPerPage],  Event: TYPE USING [aboutToSwap, swapping, spare2],  Format: TYPE USING [    LongDecimal, LongOctal, Number, NumberFormat, Octal, StringProc],  FormSW: TYPE USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    EnumeratedItem, EnumeratedNotifyProcType, FilterProcType, ItemHandle,    LabelItem, line0, line1, line2, line3, line4, ModifyEditable,    NotifyProcType, SetTypeIn, StringEditProc, StringItem, ToggleVisibility],  GFHash: TYPE USING [Pairs],  Heap: TYPE USING [systemZone],  Inline: TYPE USING [LongCOPY],  Menu: TYPE USING [Handle, Instantiate, Make, MCRType],  PrincOps: TYPE USING [BytePC],   PrincOpsExtras2: TYPE USING [GFTHandle],  Process: TYPE USING [Priority],  ProcessPriorities: TYPE USING [    priorityClientLow, priorityClient, priorityClientHigh, priorityPageFaultLow,    priorityPageFaultHigh, priorityIOLow],  Put: TYPE USING [Char, CR, Line, SubString, Number, Text],  Runtime: TYPE USING [GetBcdTime],  Selection: TYPE USING [Convert],  Space: TYPE USING [Error, ScratchMap, Unmap],  SpyFormat: TYPE USING [    All, Bracket, BracketHandle, Count, Ignore, LevelData,    Map, MapBase, PcMapHandle, ProcessAction],  SpyKernel: TYPE USING [levelData, notScheduled, skips, wakeups],  SpyOps: TYPE USING [    Activate, BuildingState, CallWithCatches, Complaint, Deactivate,    GetProcName, GFTHandle, hist, HistEntry, kernel, KernelLocated, maps, Notify,    pails, PrintSource, SameWorld, TryToBuildTables],  String: TYPE USING [AppendChar, AppendString, SubString, SubStringDescriptor],  Supervisor: TYPE USING [    CreateSubsystem, AddDependency, RemoveDependency, SubsystemHandle],  Time: TYPE USING [Append, Unpack],  Tool: TYPE USING [Create, MakeFileSW, MakeFormSW, MakeSWsProc],  ToolWindow: TYPE USING [GetState, TransitionProcType],  UserInput: TYPE USING [UserAbort],  Window: TYPE USING [Dims, GetBox, Handle, rootWindow],  WindowFont: TYPE USING [CharWidth];SpyTool: PROGRAM  IMPORTS    DebugUsefulDefs, DebugUsefulDefsExtras, Event, Format, FormSW,    GFHash, Heap, Inline, Menu, Put, Runtime, Selection, Space, SpyOps,    String,  Supervisor, Time, Tool, ToolWindow, UserInput, Window, WindowFont  EXPORTS SpyOps  SHARES SpyKernel =  BEGIN  -- Types and Related Constants --    GFTHandle: TYPE = SpyOps.GFTHandle;  ParamIndex: TYPE = MACHINE DEPENDENT {    counting, display, zero, building, priority, toolsBug, processAction, process,    watchProcs, ignoreProcs};  ParamArray: TYPE = ARRAY ParamIndex OF FormSW.ItemHandle;  Params: TYPE = LONG DESCRIPTOR FOR ParamArray;    SGFItem: TYPE = RECORD [gf: GFTHandle, count: SpyFormat.Count];  SortedGF: TYPE = RECORD [    ngf: CARDINAL, array: SEQUENCE COMPUTED CARDINAL OF SGFItem];    -- Global Exported Variables --  window: PUBLIC Window.Handle ¬ NIL;  formSW, fileSW: PUBLIC Window.Handle ¬ NIL;  spyOn: PUBLIC BOOLEAN ¬ FALSE;  priorityToWatch: PUBLIC Process.Priority ¬ ProcessPriorities.priorityClient;  processes: PUBLIC LONG STRING ¬ NIL;  processAction: PUBLIC SpyFormat.ProcessAction ¬ watch;  watchProcs: PUBLIC LONG STRING ¬ NIL;  ignoreProcs: PUBLIC LONG STRING ¬ NIL;  zeroData: PUBLIC BOOLEAN ¬ TRUE;  sorted: PUBLIC BOOLEAN ¬ FALSE;  rebuildTables: PUBLIC BOOLEAN ¬ FALSE;  -- Other Global Variables --  sortedGF: LONG POINTER TO SortedGF ¬ NIL;  printModuleCopiedWarnings: BOOLEAN ¬ FALSE;  -- Tool Setup --  sp: CARDINAL = WindowFont.CharWidth[Ascii.SP];-- **** The formSW looks like this *** ----           1         2         3         4         5         6         7-- 01234567890123456789012345678901234567890123456789012345678901234567890-- Spy: {off, on}   DisplayData!     ZeroData             building tables-- Priority: {background, normal, foreground, All}-- {Watch, Ignore} processes: P1, P2..P3, P4-- Watch procedures: Module: Proc[/s],...;-- Ignore procedures: Module: Proc[/s],...;  MakeMySWs: Tool.MakeSWsProc = {    h: Menu.Handle;    strings: ARRAY [0..2) OF LONG STRING ¬ ["Watch Module"L, "Ignore Module"L];    formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    fileSW ¬ Tool.MakeFileSW[window: window, name: "Spy.log"L];    h ¬ Menu.Make["Spy"L, DESCRIPTOR[strings], SpyMCR];    h.Instantiate[window]};  PriorityStrings: ARRAY Process.Priority OF LONG STRING = [    "clientLow", "client", "clientHigh", "pageFaultLow", "pageFaultHigh",     "IOLow", "PageFaultIO", "FrameFault"];    MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nParams: CARDINAL = ParamIndex.LAST.ORD + 1;    params: Params ¬ LOOPHOLE[AllocateItemDescriptor[nParams]];    paramArray: LONG POINTER TO ParamArray = params.BASE;    Switch: TYPE = {off, on};    SwitchEnumerated: TYPE = RECORD [LONG STRING, Switch];    ProcessActionEnumerated: TYPE = RECORD [LONG STRING, SpyFormat.ProcessAction];    PriorityEnumerated: TYPE = RECORD [LONG STRING, Process.Priority];    switches: ARRAY Switch OF SwitchEnumerated ¬      [["off"L, off], ["on"L, on]];    processActions: ARRAY SpyFormat.ProcessAction OF ProcessActionEnumerated ¬      [["Watch"L, watch], ["Ignore"L, ignore]];    prios: ARRAY [0..7) OF PriorityEnumerated ¬ [      [PriorityStrings[ProcessPriorities.priorityClientLow],         ProcessPriorities.priorityClientLow],       [PriorityStrings[ProcessPriorities.priorityClient],        ProcessPriorities.priorityClient],       [PriorityStrings[ProcessPriorities.priorityClientHigh],        ProcessPriorities.priorityClientHigh],       [PriorityStrings[ProcessPriorities.priorityPageFaultLow],        ProcessPriorities.priorityPageFaultLow],       [PriorityStrings[ProcessPriorities.priorityPageFaultHigh],        ProcessPriorities.priorityPageFaultHigh],       [PriorityStrings[ProcessPriorities.priorityIOLow],        ProcessPriorities.priorityIOLow],       ["All"L, SpyFormat.All]];    paramArray­ ¬ [      counting: EnumeratedItem[	tag: "Spy"L, place: [0*sp, line0], feedback: all,	choices: DESCRIPTOR[switches.BASE.LONG, switches.LENGTH], 	value: @spyOn],      display: CommandItem[	tag: "DisplayData"L, place: [17*sp, line0], proc: ParamNotify],      zero: BooleanItem[	tag: "ZeroData"L, place: [34*sp, line0], switch: @zeroData],      building: LabelItem[	tag: "building tables"L, invisible: TRUE, drawBox: TRUE,	place: [55*sp, line0]],      priority: EnumeratedItem[	tag: "Priority"L, place: [0*sp, line1], feedback: all, proc: EnumChanged,	choices: DESCRIPTOR[prios.BASE.LONG, prios.LENGTH], 	value: @priorityToWatch],      toolsBug: LabelItem[        tag: "{"L, place: [0*sp, line2]],      processAction: EnumeratedItem[	tag: ""L, place: [1*sp, line2], feedback: all, proc: EnumChanged,	choices: DESCRIPTOR[processActions.BASE.LONG, processActions.LENGTH], 	value: @processAction],      process: StringItem[	tag: "processes"L, place: [16*sp, line2], string: @processes,	inHeap: TRUE, filterProc: StringChanged],      watchProcs: StringItem[	tag: "Watch procedures"L, place: [0*sp, line3], string: @watchProcs,	inHeap: TRUE, filterProc: StringChanged],      ignoreProcs: StringItem[	tag: "Ignore procedures"L, place: [0*sp, line4], string: @ignoreProcs,	inHeap: TRUE, filterProc: StringChanged]];    RETURN[items: LOOPHOLE[params], freeDesc: TRUE]};  -- Tool Output --  samples: SpyFormat.Count;  moduleHeaderNeeded: BOOLEAN;  BuildingTables: PUBLIC PROC [state: SpyOps.BuildingState] = {    -- the conditional programs around a Tajo bug    IF ToolWindow.GetState[window] # tiny THEN      FormSW.ToggleVisibility[formSW, ParamIndex[building].ORD]};  EnumChanged: FormSW.EnumeratedNotifyProcType = {rebuildTables ¬ TRUE};  StringChanged: FormSW.FilterProcType = {    rebuildTables ¬ TRUE;    FormSW.StringEditProc[sw, item, insert, string]};  ParamNotify: FormSW.NotifyProcType = {    ENABLE DebugUsefulDefs.UserAborted => {Line[" ...aborted"L]; CR[]; CONTINUE};    SELECT LOOPHOLE[index, ParamIndex] FROM      display => DisplayData[];      ENDCASE};        DisplayData: PROC = {    wakeups, notScheduled, skips: SpyFormat.Count;    time: STRING ¬ [30];    IF ~SpyOps.KernelLocated[] THEN {Complain[noKernel]; RETURN};    DebugUsefulDefs.LongCopyREAD[      from: @SpyOps.kernel.wakeups, nwords: SpyFormat.Count.SIZE,      to: @wakeups];    DebugUsefulDefs.LongCopyREAD[      from: @SpyOps.kernel.notScheduled, nwords: SpyFormat.Count.SIZE,      to: @notScheduled];    DebugUsefulDefs.LongCopyREAD[      from: @SpyOps.kernel.skips, nwords: SpyFormat.Count.SIZE,      to: @skips];    CR[]; CR[]; Line["=========================================================="L];    Time.Append[time, Time.Unpack[]]; Line[time];    samples ¬ wakeups - notScheduled - skips;    Text["Watching procedures: "L]; Line[watchProcs];    Text["Ignoring procedures: "L]; Line[ignoreProcs];    Text[IF processAction = watch THEN "Watching"L ELSE "Ignoring"L];    Text[" processes: "L]; Line[processes]; CR[];    Count[wakeups, 0]; Line[" Spy wakeups"L];    LongPerCent[skips, wakeups]; Text["% of wakeups ("L];    Count[skips, 0]; Line[") found no bucket to increment"L];    LongPerCent[notScheduled, wakeups]; Text["% of wakeups ("L];    Count[notScheduled, 0]; Line[") found no interesting process scheduled"L]; CR[];    DisplayLevelData[wakeups]; CR[];    Text["Module Summary ("L]; Count[samples, 0]; Line[" total counts):"L];    SortData[];    moduleHeaderNeeded ¬ TRUE;    FOR i: CARDINAL IN [0..sortedGF.ngf) DO      Inner: PROC = {DisplayModuleData[sortedGF[i].count, sortedGF[i].gf]};      IF sortedGF[i].count # 0 THEN SpyOps.CallWithCatches[Inner];      IF UserInput.UserAbort[window] THEN ERROR DebugUsefulDefs.UserAborted;      ENDLOOP;    CR[]};      ModuleHeader: PROC = {    IF moduleHeaderNeeded THEN {      CR[];      Line["      Count   %    frame   name"L];      moduleHeaderNeeded ¬ FALSE}};    DisplayLevelData: PROC [wakeups: SpyFormat.Count] = {    count: SpyFormat.Count;    kLevelData: LONG POINTER TO SpyFormat.LevelData;    levelData: SpyFormat.LevelData;    DebugUsefulDefs.LongCopyREAD[to: @kLevelData,      from: @SpyOps.kernel.levelData, nwords: SIZE[LONG POINTER]];    DebugUsefulDefs.LongCopyREAD[      to: @levelData, from: kLevelData, nwords: SpyFormat.LevelData.SIZE];    Line["Scheduled Process-Priority Summary"L];    FOR i: Process.Priority IN Process.Priority DO      IF (count ¬ levelData[i]) # 0 THEN {	Text["priority "L]; Text[PriorityStrings[i]]; Text[" scheduled "L];	Count[count, 0]; Text[" => "L];	LongPerCent[count, wakeups]; Line["% of all wakeups."L]};      ENDLOOP};        DisplayModuleData: PROC [    count: SpyFormat.Count, gf: GFTHandle] = {    map: SpyFormat.PcMapHandle = GetMap[gf];    ModuleHeader[];    Count[count]; Spaces[2];  LongPerCent[count, samples];    Spaces[2]; Octal[gf, 5]; Spaces[2]; ModuleName[gf]; CR[];    IF map # NIL THEN DisplayProcData[map, count, gf]};      DisplayProcData: PROC [    map: SpyFormat.PcMapHandle, count: SpyFormat.Count,    gf: GFTHandle] = {    Cleanup: PROC = {      next, sh: SourceHandle;      [] ¬ FreeWords[sort];      FOR sh ¬ head, next UNTIL sh = NIL DO	bh: SpyFormat.BracketHandle = @SpyOps.maps[map.pcVals][sh.first];        next ¬ sh.link;	bh.length ¬ 0; bh.count ¬ 0;	Heap.systemZone.FREE[@sh];	ENDLOOP};    ProcHdr: STRING = "   <<<Count   %   size           name>>>"L;    sort: LONG POINTER TO ARRAY [0..0) OF SortRec = Words[map.length].p;    totalUnused, totalSize, sortSize: CARDINAL ¬ 0;    i, procsCounted: CARDINAL;    head: SourceHandle ¬ NIL;    FOR i ¬ 0, i + 1 UNTIL i >= map.length DO      bh: SpyFormat.BracketHandle = @SpyOps.maps[map.pcVals][i];      sort[i] ¬ LOOPHOLE[	LOOPHOLE[map.pcVals, CARDINAL] + i*SpyFormat.Bracket.SIZE];      sortSize ¬ sortSize + 1;      IF bh.length = 0 THEN        {head ¬ CollapseSourceData[gf, map, i, head]; i ¬ i + head.length};      ENDLOOP;    FOR i IN [0..sortSize) DO      FOR j: CARDINAL IN [i..sortSize) DO	IF SpyOps.maps[sort[i]].count < SpyOps.maps[sort[j]].count THEN	  {temp: SortRec ¬ sort[i]; sort[i] ¬ sort[j]; sort[j] ¬ temp};	ENDLOOP;      ENDLOOP;    moduleHeaderNeeded ¬ TRUE;    Line[ProcHdr];    FOR procsCounted ¬ 0, procsCounted + 1 UNTIL procsCounted = sortSize DO      bh: SpyFormat.BracketHandle = @SpyOps.maps[sort[procsCounted]];      IF bh.count = 0 THEN EXIT;      totalSize ¬ totalSize + bh.length;      Count[bh.count]; Spaces[2]; LongPerCent[bh.count, samples]; Spaces[2];      IF bh.length # 0 THEN Decimal[bh.length, 4] ELSE Text["  ??"L];      Spaces[11]; ProcName[gf, bh.origin ! UNWIND => Cleanup[]]; CR[];      PrintSource[gf, map, head, procsCounted ! UNWIND => Cleanup[]];      IF UserInput.UserAbort[window] THEN ERROR DebugUsefulDefs.UserAborted;      ENDLOOP;    FOR i IN [procsCounted..sortSize) DO      bh: SpyFormat.BracketHandle = @SpyOps.maps[sort[i]];      totalSize ¬ totalSize + bh.length;      IF ~bh.ignore THEN {	totalUnused ¬ totalUnused + bh.length;        Spaces[8]; Text["No counts in "L]; ProcName[gf, bh.origin ! UNWIND => Cleanup[]];        Text["; "L]; Decimal[bh.length]; Text[" unreferenced code bytes."L]; CR[]};      IF UserInput.UserAbort[window] THEN ERROR DebugUsefulDefs.UserAborted;      ENDLOOP;    Cleanup[];    IF totalUnused > 0 THEN {      Spaces[5]; Decimal[totalUnused, 5]; Text[" bytes, "L]; PerCent[totalUnused, totalSize];      Line["%, of unreferenced code."L]};    Spaces[5]; Decimal[totalSize, 5]; Text[" bytes of code watched in "L];    ModuleName[gf]; CR[]};      SortRec: TYPE = SpyFormat.MapBase RELATIVE POINTER TO SpyFormat.Bracket;    SourceHandle: TYPE = LONG POINTER TO SourceRec;  SourceRec: TYPE = RECORD [    link: SourceHandle,    first, length: CARDINAL];    CollapseSourceData: PROC [      gf: GFTHandle, map: SpyFormat.PcMapHandle, i: CARDINAL,      head: SourceHandle]    RETURNS [new: SourceHandle] = {    bh: SpyFormat.BracketHandle = @SpyOps.maps[map.pcVals][i];    current: SpyFormat.BracketHandle ¬ bh;    pc: PrincOps.BytePC ¬ bh.origin;    exit: PrincOps.BytePC = DebugUsefulDefsExtras.ExitPC[       DebugUsefulDefsExtras.CBti[pc, gf]];    new ¬ Heap.systemZone.NEW[SourceRec ¬ [link: head, first: i, length: 0]];    UNTIL pc >= exit DO      current ¬ current + SpyFormat.Bracket.SIZE;      pc ¬ [pc + current.length];       bh.length ¬ bh.length + current.length;      bh.count ¬ bh.count + current.count;      new.length ¬ new.length + 1;      ENDLOOP};    PrintSource: PROC [    gf: GFTHandle, map: SpyFormat.PcMapHandle,    head: SourceHandle, index: CARDINAL] = {    next: SourceHandle;    i: CARDINAL;    FOR sh: SourceHandle ¬ head, next UNTIL sh = NIL DO      next ¬ sh.link;      IF sh.first # index THEN LOOP;      i ¬ sh.first;      THROUGH [0..sh.length) DO	bh: SpyFormat.BracketHandle = @SpyOps.maps[map.pcVals][i];        SpyOps.PrintSource[gf, bh.origin, bh.count];	IF i = sh.first THEN i ¬ i + 1; -- skip second fgt entry	i ¬ i + 1;	IF UserInput.UserAbort[window] THEN ERROR DebugUsefulDefs.UserAborted;	ENDLOOP;      EXIT      ENDLOOP};    SortData: PROC = {    count, i: CARDINAL ¬ 0;    IF sorted THEN RETURN;    IF sortedGF # NIL THEN sortedGF ¬ FreeWords[sortedGF];    {CountThem: PROC [      gf: GFTHandle, p: LONG POINTER] RETURNS [BOOLEAN] = {      count ¬ count + 1; RETURN[FALSE]};    [] ¬ SpyOps.hist.Pairs[CountThem]};    sortedGF ¬ Words[SortedGF[count].SIZE].p;    sortedGF.ngf ¬ count;    {EnterFrame: PROC [      gf: GFTHandle, p: LONG POINTER TO SpyFormat.Count]      RETURNS [BOOLEAN] = {      sortedGF[i].gf ¬ gf;      IF DebugUsefulDefsExtras.Valid[gf] AND DebugUsefulDefsExtras.Copied[gf]         AND printModuleCopiedWarnings THEN {	Text["Module, "L]; ModuleName[gf];	Text[", is copied. gf = "L]; Octal[gf]; CR[]};      IF p­ >= SpyFormat.Ignore THEN        sortedGF[i].count ¬ CollapseBucketData[gf, p]      ELSE sortedGF[i].count ¬ p­;      i ¬ i + 1;      RETURN[FALSE]};    [] ¬ SpyOps.hist.Pairs[EnterFrame]};    IF i # count THEN ERROR;    FOR i IN [0..count) DO      FOR j: CARDINAL IN [i..count) DO	IF sortedGF[i].count < sortedGF[j].count THEN {	  temp: SGFItem = sortedGF[i];	  sortedGF[i] ¬ sortedGF[j]; sortedGF[j] ¬ temp};	ENDLOOP;      ENDLOOP;    sorted ¬ TRUE};      CollapseBucketData: PROC [    gf: GFTHandle, p: LONG POINTER TO SpyFormat.Count]    RETURNS [count: SpyFormat.Count ¬ 0] = {    map: SpyFormat.PcMapHandle = GetMap[gf];    IF map # NIL THEN      FOR i: CARDINAL IN [0..map.length) DO        h: SpyFormat.BracketHandle ¬ @SpyOps.maps[map.pcVals][i];        IF ~h.ignore THEN count ¬ count + h.count;        ENDLOOP};      GetMap: PROC [    gf: GFTHandle] RETURNS [SpyFormat.PcMapHandle] = {    count: LONG POINTER TO SpyFormat.Count = SpyOps.HistEntry[gf];    IF count = NIL OR count­ <= SpyFormat.Ignore THEN RETURN[NIL]    ELSE RETURN[@SpyOps.pails[CARDINAL[count­ - SpyFormat.Ignore.SUCC]]]};      -- Menu Handling --  SpyMCR: Menu.MCRType = {    s: LONG STRING ¬ Selection.Convert[string];    new: STRING = [42];    IF s = NIL THEN RETURN;    IF s.length <= 40 THEN {      paramIndex: ParamIndex;      SELECT index FROM        0 => paramIndex ¬ watchProcs;	1 => paramIndex ¬ ignoreProcs;	ENDCASE => ERROR;      String.AppendChar[new, Ascii.SP];      String.AppendString[new, s];      String.AppendChar[new, ';];      FormSW.SetTypeIn[formSW, paramIndex.ORD, CARDINAL.LAST];      FormSW.ModifyEditable[formSW, paramIndex.ORD, CARDINAL.LAST, 0, new]};    Heap.systemZone.FREE[@s]};              -- Tool Transition --  maySwap: Supervisor.SubsystemHandle =     Supervisor.CreateSubsystem[SpyOps.TryToBuildTables];  swap: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[SpyOps.Notify];  sameWorld: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[SpyOps.SameWorld];      StateChanged: ToolWindow.TransitionProcType = {    OPEN SpyOps;    IF old = new THEN RETURN;    SELECT TRUE FROM      old = inactive => {	Supervisor.AddDependency[client: maySwap, implementor: Event.aboutToSwap];	Supervisor.AddDependency[client: swap, implementor: Event.swapping];	Supervisor.AddDependency[client: sameWorld, implementor: Event.spare2];	spyOn ¬ FALSE;	Activate[]};      new = inactive => {	formSW ¬ fileSW ¬ NIL;	Supervisor.RemoveDependency[	  client: maySwap, implementor: Event.aboutToSwap];	Supervisor.RemoveDependency[client: swap, implementor: Event.swapping];	Supervisor.RemoveDependency[client: sameWorld, implementor: Event.spare2];	IF sortedGF # NIL THEN sortedGF ¬ FreeWords[sortedGF];	sorted ¬ FALSE;	Deactivate[]};      ENDCASE};      -- Storage Allocation Utilities --  Words: PUBLIC PROC [n: CARDINAL] RETURNS [p: LONG POINTER, size: CARDINAL] = {    pages: Environment.PageCount = (      n + Environment.wordsPerPage - 1)/Environment.wordsPerPage;    p ¬ Space.ScratchMap[count: pages];    SetBlock[p, n, 0];    size ¬ CARDINAL[pages*Environment.wordsPerPage]};      FreeWords: PUBLIC PROC [p: LONG POINTER] RETURNS [LONG POINTER ¬ NIL] = {    RETURN[Space.Unmap[p ! Space.Error => CONTINUE]]};  -- I/O Utilities --  format10: Format.NumberFormat = [10, FALSE, FALSE, 0];    PerCent: PUBLIC PROC [n1: LONG CARDINAL, n2: CARDINAL] = {    d1: LONG CARDINAL;    q, r: CARDINAL;    IF n2 = 0 THEN n2 ¬ 1;    d1 ¬ n1*1000;    q ¬ CARDINAL[d1/n2]; -- q => xxy    r ¬ q MOD 10; -- r => y    q ¬ q/10; -- q => xx    Decimal[CARDINAL[q], 2]; Char['.]; Decimal[r, 1]};      LongPerCent: PUBLIC PROC [num, den: LONG CARDINAL] = {    t: LONG CARDINAL; -- gets num*1000/den    IF den = 0 THEN den ¬ 1;    t ¬ num*1000;    t ¬ t/den;    PerCent[t, 1000]};      Char: PUBLIC PROC [c: CHARACTER] = {Put.Char[fileSW, c]};  CR: PUBLIC PROC = {Put.CR[fileSW]};  Line: PUBLIC Format.StringProc = {Put.Line[fileSW, s]};  SubString: PUBLIC PROC [ss: String.SubString] = {    Put.SubString[fileSW, LOOPHOLE[ss]]};  Number: PUBLIC PROC [n: UNSPECIFIED, f: Format.NumberFormat] = {    Put.Number[fileSW, n, f]};  Text: PUBLIC Format.StringProc = {Put.Text[fileSW, s]};    Spaces: PUBLIC PROC [n: CARDINAL] = {    THROUGH [0..n) DO Put.Char[fileSW, Ascii.SP] ENDLOOP};  columns: CARDINAL;      Count: PUBLIC PROC [n: SpyFormat.Count, width: CARDINAL ¬ 10] = {    columns ¬ width; Format.LongDecimal[Out, n]};  Decimal: PUBLIC PROC [n: UNSPECIFIED, width: CARDINAL ¬ 0] = {    columns ¬ width; Format.Number[Out, n, format10]};  Octal: PUBLIC PROC [n: UNSPECIFIED, width: CARDINAL ¬ 0] = {    columns ¬ width; Format.Octal[Out, n]};      LongOctal: PUBLIC PROC [n: LONG UNSPECIFIED, width: CARDINAL ¬ 0] = {    columns ¬ width; Format.LongOctal[Out, n]};  Out: Format.StringProc = {    THROUGH [s.length..columns) DO Put.Char[fileSW, Ascii.SP] ENDLOOP;    Put.Text[fileSW, s]};  ModuleName: PROC [gf: GFTHandle] = {    module: STRING = [40];    DebugUsefulDefsExtras.Name[module, gf ! DebugUsefulDefs.InvalidFrame => {      String.AppendString[module, "Invalid global frame"L]; CONTINUE}];    Text[module]};    ProcName: PROC [gf: GFTHandle, origin: PrincOps.BytePC] = {    ss: String.SubStringDescriptor ¬ SpyOps.GetProcName[gf, origin];    SubString[@ss]};   -- Miscellaneous Utilities --  SetBlock: PUBLIC PROC [p: LONG POINTER, nwords: CARDINAL, val: CARDINAL ¬ 0] = {    IF nwords = 0 THEN RETURN;    p­ ¬ val; Inline.LongCOPY[from: p, nwords: nwords - 1, to: p + 1]};      -- Error Reporting --  Complain: PUBLIC PROC [error: SpyOps.Complaint, arg: LONG POINTER ¬ NIL] = {    CR[];    SELECT error FROM      ambiguous => {Text[arg]; Text[" is ambiguous!"L]};      crossjumped => {Octal[arg­]; Text[" is crossjumped!"L]};      noFGT => {	Text["Module containing "L];	Text[arg]; 	Text[" has compressed symbols!"L]};      noSyms => {	Text["Symbol table for module containing "L];	Text[arg]; 	Text[" is missing!"L]};      invalidFrame => {Octal[arg­]; Text[" is an invalid global frame!"L]};      invalidModule => {Text[arg]; Text[" is not a module!"L]};      invalidNumber => {Text[arg]; Text[" is not a number!"L]};      illegalSlash => {Text["/... is illegal after "L]; Text[arg]};      illegalRange => {Text[arg]; Text[" begins an illegal process range."]};      kernelNotStarted => Text["SpyNub not started!"L];      multipleKernels => Text["More than one instance of SpyNub found!"L];      noKernel => Text["SpyNub not found!"L];      noSymbols => {Text["No symbols for "L]; Text[arg]; Text["!"L]};      repeatedModule => {Text[arg]; Text[" is mentioned more than once!"L]};      ENDCASE => Text["???"L];    CR[]};  Init: PROC = {rootDims: Window.Dims = Window.rootWindow.GetBox.dims;  herald: STRING ¬ [40];  String.AppendString[to: herald, from: "Spy of "L];  Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];  herald.length ¬ herald.length - 3;  window ¬ Tool.Create[    makeSWsProc: MakeMySWs, clientTransition: StateChanged,    initialBox: [[x: rootDims.w - 512, y: rootDims.h - 450], [w: 512, h: 450]],    name: herald, cmSection: "Spy"L, tinyName1: "Spy"L]};        -- Main Body  Init[];  END.
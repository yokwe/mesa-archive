-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- SpySyms.mesa - last edit-- JBD    	19-Sep-86 10:51:05-- AXD    	25-Aug-83 15:34:05-- BXM  	28-Jan-82 15:32:36-- RXL  	29-Oct-81 18:32:39DIRECTORY  Alloc USING [AddNotify, Failure, Notifier, Overflow],  BcdOps USING [ENHandle],  DebugUsefulDefs USING [LongCopyREAD],  DebugUsefulDefsExtras USING [    BitAddress, CBti, CrossJumped, DerefProcDesc, EntryPC, FindFrame, Foo,    GetAlloc, GetControlLink, GetSym, GFrameMdi, GetPc, MakeFoo, MapRealToEnh,    NoFGT, Open, ResetSymbols, SearchCtxList, SpecialDisplay, StringToHti],  Environment USING [wordsPerPage],  Heap USING [systemZone],  Inline USING [LongCOPY, LowHalf],  PrincOps USING [BytePC],  PrincOpsExtras2 USING [nullGFH, ControlLink, GFT, LongGlobalFrameHandle],  Space USING [Unmap],  SpyFormat USING [Bracket, Count, Ignore, Map, MapHandle, MapPos, PcMap],  SpyOps USING [    Complain, GFTHandle, HistEntry, maps, mapsStorageSpace, pails,    pailStorageSpace, Text, Words],  String USING [    AppendLongDecimal, CopyToNewString, EqualString, SubStringDescriptor],  Symbols USING [    bodyType, CBTIndex, CBTNull, HTIndex, ISEIndex, ISENull, MDIndex, seType],  SymbolOps USING [SubStringForHash],  SymbolTable USING [Handle, Missing],  Table USING [Base];SpySyms: PROGRAM  IMPORTS    Alloc, DebugUsefulDefs, DebugUsefulDefsExtras, Heap, Inline, Space, SpyOps,    String, SymbolOps, SymbolTable  EXPORTS SpyOps =  BEGIN OPEN DUDE: DebugUsefulDefsExtras, DUD: DebugUsefulDefs;  seb: Table.Base;  -- se table  bb: Table.Base;  -- body table  Notify: Alloc.Notifier = {    seb ¬ base[Symbols.seType]; bb ¬ base[Symbols.bodyType]};  CallWithCatches: PUBLIC PROC [proc: PROC] = {    DO      exit: BOOLEAN ¬ TRUE;      proc[        ! Alloc.Overflow => IF h = DUDE.GetAlloc[] THEN RESUME [4];        Alloc.Failure => IF h = DUDE.GetAlloc[] THEN {exit ¬ FALSE; CONTINUE}];      IF exit THEN RETURN;      DUDE.ResetSymbols[];      ENDLOOP};  -- Bucket Construction --  AddAllProcsForModule: PUBLIC PROC [gf: SpyOps.GFTHandle, map: SpyFormat.MapPos]    RETURNS [nextMap: SpyFormat.MapPos ¬ [index[0]]] = {    Inner: PROC = {      count: LONG POINTER TO SpyFormat.Count = SpyOps.HistEntry[gf];      mdi: Symbols.MDIndex ¬ DUDE.GFrameMdi[        gf ! SymbolTable.Missing => count­ ¬ 0];      enh: BcdOps.ENHandle = DUDE.MapRealToEnh[gf];      EnsureAdequateMapStorage[map.ptr, enh.nEntries];      count­ ¬ AddPail[enh.nEntries, map.ptr];      FOR i: CARDINAL IN [0..enh.nEntries) DO        cbti: Symbols.CBTIndex = DUDE.CBti[pc: enh.initialPC[i], gf: gf];        PutProcInMap[gf, cbti, map.ptr, i];        ENDLOOP;      nextMap.ptr ¬ map.ptr + (enh.nEntries * SpyFormat.Bracket.SIZE)};    CallWithCatches[Inner]};  AddModuleForExistingProcs: PUBLIC PROC [    gf: SpyOps.GFTHandle, map: SpyFormat.MapPos, nProcs: CARDINAL]    RETURNS [nextMap: SpyFormat.MapPos] = {    SpyOps.HistEntry[gf]­ ¬ AddPail[nProcs, map.ptr];    nextMap.ptr ¬ map.ptr + (nProcs * SpyFormat.Bracket.SIZE)};  AddProcForModule: PUBLIC PROC [    gf: SpyOps.GFTHandle, proc: LONG STRING, map: SpyFormat.MapPos,    index: CARDINAL] RETURNS [nextIndex: CARDINAL ¬ 0] = {    Inner: PROC = {      found: BOOLEAN;      mdi: Symbols.MDIndex;      cbti: Symbols.CBTIndex;      [found, mdi, cbti] ¬ GetProcInfo[gf, proc, FALSE];      IF ~found THEN RETURN;      nextIndex ¬ index + 1;      EnsureAdequateMapStorage[map.ptr, nextIndex];      PutProcInMap[gf, cbti, map.ptr, index]};    CallWithCatches[Inner]};  AddSourceForProc: PUBLIC PROC [    gf: SpyOps.GFTHandle, proc: LONG STRING, map: SpyFormat.MapPos,    index: CARDINAL] RETURNS [nextIndex: CARDINAL ¬ 0] = {    Inner: PROC = {      found: BOOLEAN;      mdi: Symbols.MDIndex;      cbti: Symbols.CBTIndex;      [found, mdi, cbti] ¬ GetProcInfo[gf, proc, TRUE];      IF ~found THEN RETURN;      nextIndex ¬ AddSource[gf, mdi, cbti, map.ptr, index]};    CallWithCatches[Inner]};  IgnoreExistingProc: PUBLIC PROC [gf: SpyOps.GFTHandle, proc: LONG STRING] = {    Inner: PROC = {      cbti: Symbols.CBTIndex;      found: BOOLEAN;      entryPc: PrincOps.BytePC;      [found: found, cbti: cbti] ¬ GetProcInfo[gf, proc, FALSE];      IF ~found THEN RETURN;      entryPc ¬ DUDE.EntryPC[gf, bb[cbti].entryIndex];      WITH bb[cbti].info SELECT FROM        External => {          pcMap: SpyFormat.PcMap;          map: SpyFormat.MapHandle;          bottom, top, probe: CARDINAL;          IF SpyOps.HistEntry[gf]­ <= SpyFormat.Ignore THEN ERROR;          pcMap ¬ SpyOps.pails[            Inline.LowHalf[SpyOps.HistEntry[gf]­ - SpyFormat.Ignore - 1]];          map ¬ @SpyOps.maps[pcMap.pcVals];          bottom ¬ 0;          top ¬ pcMap.length - 1;          DO            probe ¬ (bottom + top) / 2;            SELECT map[probe].origin FROM              < entryPc =>                IF probe = pcMap.length - 1 THEN ERROR ELSE bottom ¬ probe + 1;              > entryPc => IF probe = 0 THEN ERROR ELSE top ¬ probe - 1;              ENDCASE => {                IF map[probe].length # bytes THEN ERROR;                map[probe].ignore ¬ TRUE;                EXIT};            IF top < bottom THEN ERROR;            ENDLOOP};        ENDCASE => ERROR};    CallWithCatches[Inner]};  PutProcInMap: PROC [    gf: SpyOps.GFTHandle, cbti: Symbols.CBTIndex, map: SpyFormat.Map,    index: CARDINAL] = {    entryPc: PrincOps.BytePC = DUDE.EntryPC[gf, bb[cbti].entryIndex];    WITH bb[cbti].info SELECT FROM      External =>        SpyOps.maps[map][index] ¬ [          origin: entryPc, ignore: FALSE, length: bytes, count: 0];      ENDCASE => ERROR};  jumped: SpyOps.GFTHandle ¬ PrincOpsExtras2.nullGFH;  AddSource: PROC [    gf: SpyOps.GFTHandle, mdi: Symbols.MDIndex, cbti: Symbols.CBTIndex,    map: SpyFormat.Map, index: CARDINAL] RETURNS [nextIndex: CARDINAL] = {    pc: PrincOps.BytePC ¬ DUDE.EntryPC[gf, bb[cbti].entryIndex];    startFG, fgLength: CARDINAL;    AddSourceBucket: PROC [pc: PrincOps.BytePC, length: CARDINAL] = {      EnsureAdequateMapStorage[map, index + 1];      SpyOps.maps[map][index] ¬ [        origin: pc, ignore: FALSE, length: length, count: 0];      index ¬ index + 1};    AddFGBuckets: PROC [handle: SymbolTable.Handle] = {      FOR i: CARDINAL IN (startFG..startFG + fgLength) DO        WITH handle.fgTable[i] SELECT FROM          normal =>            IF deltaObject > 0 THEN {              AddSourceBucket[pc, deltaObject]; pc ¬ [pc + deltaObject]};          step =>            IF which = object THEN {              AddSourceBucket[pc, delta]; pc ¬ [pc + delta]};          ENDCASE;        ENDLOOP};    IF jumped # gf AND DUDE.CrossJumped[gf] THEN {      jumped ¬ gf; SpyOps.Complain[crossjumped, @gf]};    WITH bb[cbti].info SELECT FROM      External => {        exitpc: PrincOps.BytePC = [pc + bytes];        startFG ¬ startIndex;        fgLength ¬ indexLength;        AddSourceBucket[pc, 0];        DUDE.Open[mdi, AddFGBuckets];        AddSourceBucket[pc, exitpc - pc]};      ENDCASE => ERROR;    RETURN[index]};  GFTHandleToLongGF: PROCEDURE [gf: SpyOps.GFTHandle]    RETURNS [gfh: PrincOpsExtras2.LongGlobalFrameHandle] = INLINE {    DUD.LongCopyREAD[from: @PrincOpsExtras2.GFT[gf], nwords: 2, to: @gfh]};  GetProcInfo: PROC [gf: SpyOps.GFTHandle, proc: LONG STRING, source: BOOLEAN]    RETURNS [found: BOOLEAN, mdi: Symbols.MDIndex, cbti: Symbols.CBTIndex] = {    found ¬ FALSE;    mdi ¬ DUDE.GFrameMdi[      gf, source !      SymbolTable.Missing => {SpyOps.Complain[noSyms, proc]; GO TO noGood};      DUDE.NoFGT => {SpyOps.Complain[noFGT, proc]; GO TO noGood}];    IF String.EqualString[proc, main] THEN {      cbti ¬ DUDE.CBti[DUDE.GetPc[gf, 0], gf]; found ¬ TRUE}    ELSE {      isei: Symbols.ISEIndex;      hti: Symbols.HTIndex = DUDE.StringToHti[proc];      ba: DUDE.BitAddress = [        base: GFTHandleToLongGF[gf], offset: 0, local: FALSE];      f: DUDE.Foo;      found ¬ (isei ¬ DUDE.SearchCtxList[hti, DUDE.FindFrame[gf].outerCtx]) #        Symbols.ISENull AND (f ¬ DUDE.MakeFoo[isei, ba]) # NIL;      IF found THEN {        link: longProc PrincOpsExtras2.ControlLink = LOOPHOLE[DUDE.DerefProcDesc[          DUDE.GetControlLink[f]]];  -- this LOOPHOLE because pc is defined twice in PrincOpsExtras2.ControlLink... should cause a compilation error when we fix PrincOpsExtras2.        found ¬ (cbti ¬ DUDE.CBti[link.pc, gf]) # Symbols.CBTNull}};    EXITS noGood => NULL};  -- Output Routines --  main: LONG STRING ¬ String.CopyToNewString[s: "MAIN", z: Heap.systemZone];  GetProcName: PUBLIC PROC [gf: SpyOps.GFTHandle, origin: PrincOps.BytePC]    RETURNS [ss: String.SubStringDescriptor] = {    cbti: Symbols.CBTIndex = DUDE.CBti[origin, gf];    IF cbti = DUDE.CBti[DUDE.GetPc[gf, 0], gf] THEN      ss ¬ [base: main, offset: 0, length: main.length]    ELSE SymbolOps.SubStringForHash[DUDE.GetSym[], @ss, seb[bb[cbti].id].hash]};  PrintSource: PUBLIC PROC [    gf: SpyOps.GFTHandle, pc: PrincOps.BytePC, count: LONG CARDINAL] = {    s: STRING ¬ [20];    String.AppendLongDecimal[s, count];    DUDE.SpecialDisplay[      out: SpyOps.Text, gf: gf, pc: pc, load: FALSE, msg: s,      suppressErrors: TRUE]};  -- Storage Allocation --  AddPail: PROC [len: CARDINAL, map: SpyFormat.Map] RETURNS [SpyFormat.Count] = {    oldLength: CARDINAL = SpyOps.pails.LENGTH;    newLength: CARDINAL = oldLength + 1;    IF newLength * SpyFormat.PcMap.SIZE > SpyOps.pailStorageSpace THEN {      newBase: LONG POINTER;      newSize: CARDINAL;      [newBase, newSize] ¬ SpyOps.Words[        SpyOps.pailStorageSpace + Environment.wordsPerPage];      Inline.LongCOPY[        from: SpyOps.pails.BASE, to: newBase, nwords: SpyOps.pailStorageSpace];      [] ¬ Space.Unmap[SpyOps.pails.BASE];      SpyOps.pails ¬ DESCRIPTOR[newBase, oldLength];      SpyOps.pailStorageSpace ¬ newSize};    SpyOps.pails ¬ DESCRIPTOR[SpyOps.pails.BASE, newLength];    SpyOps.pails[oldLength] ¬ [length: len, pcVals: map];    RETURN[SpyFormat.Ignore + oldLength + 1]};  EnsureAdequateMapStorage: PROC [map: SpyFormat.Map, index: CARDINAL ¬ 0] = {    newBase: LONG POINTER;    newSize: CARDINAL;    last: SpyFormat.MapPos = [pointer[map + (index * SpyFormat.Bracket.SIZE)]];    IF last.index <= SpyOps.mapsStorageSpace THEN RETURN;    [newBase, newSize] ¬ SpyOps.Words[last.index];    Inline.LongCOPY[      from: SpyOps.maps, to: newBase, nwords: SpyOps.mapsStorageSpace];    [] ¬ Space.Unmap[SpyOps.maps];    SpyOps.maps ¬ newBase;    SpyOps.mapsStorageSpace ¬ newSize};  Alloc.AddNotify[DUDE.GetAlloc[], Notify, NIL];  END.
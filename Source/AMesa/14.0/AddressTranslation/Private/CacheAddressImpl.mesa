-- File: CacheAddressImpl.mesa - last edit:-- AOF                 10-Sep-86 18:16:30-- BY                  22-Aug-84 13:59:37-- Copyright (C) 1984, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  AddressCache,  AddressTranslation,  Exec,  Format,  Heap,  MStream,  Runtime,  Stream,  String,  System;CacheAddressImpl: PROGRAM  IMPORTS     AddressCache, AddressTranslation, Exec, Format, Heap, MStream,    Runtime, Stream, String = {    zone: UNCOUNTED ZONE = Heap.systemZone;    CacheManager: Exec.ExecProc = {    Write: Format.StringProc ¬ h.OutputProc[];    command, arg: LONG STRING ¬ NIL;    DO      [command, arg] ¬ h.GetToken[];      IF String.Length[command] = 0 THEN EXIT;      String.AppendChar[command, '*];      SELECT TRUE FROM        Exec.MatchPattern["SetSize"L, command] => {	  size: CARDINAL ¬ 0;	  IF String.Length[arg] = 0 THEN GOTO noSize 	  ELSE size ¬ String.StringToNumber[arg!	    String.InvalidNumber => GOTO noSize];	  AddressCache.SetSize[size];	  EXITS noSize => Write["Invalid size argument\n"L];	  };        Exec.MatchPattern["GetSize"L, command] => {	  Write["Size is "L]; Format.Number[Write, AddressCache.GetSize[], []];	  Write["\n"L];	  };        Exec.MatchPattern["Flush"L, command] => {AddressCache.Flush[]};        Exec.MatchPattern["List"L, command] => {	  Lister: PROC[name: LONG STRING, addr: System.NetworkAddress] ={	    Write["  "L]; Format.NetworkAddress[Write, addr, octal];	    Write[" "L]; Write[name]; Write["\n"L]};	  Write["Contents of address cache:\n"L];	  AddressCache.Enumerate[Lister];	  };        Exec.MatchPattern["Certify"L, command] => CertifyCache[arg, Write];        Exec.MatchPattern["Load"L, command] => LoadFile[arg, Write];        Exec.MatchPattern["Store"L, command] => StoreFile[arg, Write];	Exec.MatchPattern["Statistics"L, command] => {	  avail, used, hits, accesses: CARDINAL;	  avail ¬ AddressCache.GetSize[];	  [used, hits, accesses] ¬ AddressCache.GetStatistics[];	  Write["Used/available (%) = "L]; Format.Decimal[Write, used];	  Write["/"L]; Format.Decimal[Write, avail];	  IF avail = 0 THEN avail ¬ 1;  --don't trap	  Write[" ("L]; Format.Decimal[Write, (used * 100) / avail];	  Write["%)\nHits/accesses (%) = "L]; Format.Decimal[Write, hits];	  Write["/"L]; Format.Decimal[Write, accesses];	  IF accesses = 0 THEN accesses ¬ 1;  --don't trap	  Write[" ("L]; Format.Decimal[Write, (hits * 100) / accesses];	  Write["%)\n"L];	  }; 	ENDCASE => {	  Write["Command: "L];	  command.length ¬ command.length - 1;	  Write[command]; Write[" not found.\n"L]};      IF String.Length[command] > 0 THEN command ¬ Exec.FreeTokenString[command];      IF String.Length[arg] > 0 THEN arg ¬ Exec.FreeTokenString[arg];      ENDLOOP;    IF String.Length[command] > 0 THEN command ¬ Exec.FreeTokenString[command];    IF String.Length[arg] > 0 THEN arg ¬ Exec.FreeTokenString[arg];    Write["\n"L];    };    CacheEntry: TYPE = RECORD[    name: LONG STRING ¬ NIL,     address: System.NetworkAddress ¬ System.nullNetworkAddress,    validate: BOOLEAN ¬ FALSE];      CacheHandle: TYPE = LONG POINTER TO CacheObject;  CacheObject: TYPE = RECORD [    SEQUENCE length: CARDINAL OF CacheEntry];      CertifyCache: PROC[arg: LONG STRING, Write: Format.StringProc] = {    cache: CacheHandle ¬ NIL;    size: CARDINAL ¬ AddressCache.GetSize[] + 4;    index, i: CARDINAL ¬ 0;    na: System.NetworkAddress;    pattern: LONG STRING ¬ [100];    CopyEntry: PROC [name: LONG STRING, addr: System.NetworkAddress] ={      cache[index] ¬ [        name: String.CopyToNewString[name, zone],	address: addr,	validate: Exec.MatchPattern[name, pattern]];      index ¬ index + 1;      };    IF size = 0 THEN RETURN;    Write["Validating \n"L];    String.AppendString[pattern, arg];    String.AppendChar[pattern , '*];    cache ¬ zone.NEW[CacheObject[size]];    FOR i IN [0..size) DO cache[i] ¬ CacheEntry[] ENDLOOP;    AddressCache.Enumerate[CopyEntry];    AddressCache.Flush[];    FOR i IN [0..index) DO      IF String.Length[cache[i].name] = 0 THEN LOOP;      IF cache[i].validate THEN {        Write["  "L];        na ¬ AddressTranslation.StringToNetworkAddress[cache[i].name!	  AddressTranslation.Error => {	    Write["*** "L]; Write[cache[i].name]; Write["  "L];	    AddressTranslation.PrintError[errorRecord, Write];	    Write["\n"L];	    LOOP}].addr;	Format.NetworkAddress[Write, na, octal];	Write["\t"L]; Write[cache[i].name]; Write["\n"L];	}      ELSE AddressCache.AddEntry[cache[i].name, cache[i].address];      ENDLOOP;    FOR i IN [0..index) DO zone.FREE[@cache[i].name] ENDLOOP;    zone.FREE[@cache];    };    LoadFile: PROC[file: LONG STRING, Write: Format.StringProc] = {    stream: Stream.Handle ¬ NIL;    BEGIN ENABLE Stream.EndOfStream => GOTO quit;    addr: LONG STRING ¬ [50];    name: LONG STRING ¬ [100];    na: System.NetworkAddress;    ch: CHARACTER;    addrPos, namePos: LONG CARDINAL ¬ 0;    count, oldSize: CARDINAL ¬ 0;    IF String.Length[file] = 0 THEN GOTO nofile;    stream ¬ MStream.ReadOnly[file, []!      MStream.Error => GOTO cantAcquire];    DO      ch ¬ stream.GetChar[!Stream.EndOfStream => EXIT];      IF ch = '\n THEN count ¬ count + 1;      ENDLOOP;    stream.SetPosition[0];    oldSize ¬ AddressCache.GetSize[];    IF count > oldSize THEN AddressCache.SetSize[count];    DO      BEGIN ENABLE {        String.StringBoundsFault => {	  Write["String too long at "L];	  Format.LongNumber[Write, stream.GetPosition[], []];	  Write[".\n"L]; WHILE stream.GetChar[] # '\n DO ENDLOOP; LOOP};	AddressTranslation.Error =>{	  AddressTranslation.PrintError[errorRecord, Write];	  Write["\n"L]; WHILE stream.GetChar[] # '\n DO ENDLOOP; LOOP};	};      addr.length ¬ name.length ¬ 0;      WHILE (ch ¬ stream.GetChar[]) # '  DO String.AppendChar[addr, ch] ENDLOOP;      addrPos ¬ stream.GetPosition[] - 1;      WHILE (ch ¬ stream.GetChar[]) # '\n DO String.AppendChar[name, ch] ENDLOOP;      namePos ¬ stream.GetPosition[] - 1;      IF String.Length[name] = 0 THEN {        Write["Invalid name at "L]; Format.LongNumber[Write, namePos, []];	Write[".\n"L]; LOOP};      na ¬ AddressTranslation.StringToNetworkAddress[addr].addr;      AddressCache.AddEntry[name, na];      END;      ENDLOOP;    EXITS      quit => NULL;      nofile => Write["No file specified to load.\n"L];      cantAcquire => {Write["Cant acquire file "L]; Write[file]; Write[".\n"L]};    END;    IF stream # NIL THEN stream.Delete[];    };    StoreFile: PROC[file: LONG STRING, Write: Format.StringProc] = {    stream: Stream.Handle ¬ NIL;    PutString: Format.StringProc = {stream.PutString[s]};    WriteEntry: PROC[name: LONG STRING, addr: System.NetworkAddress] ={      Format.NetworkAddress[PutString, addr, octal];      PutString[" "L];      PutString[name];      PutString["\n"L];      };    BEGIN ENABLE Stream.EndOfStream => GOTO quit;    IF String.Length[file] = 0 THEN GOTO nofile;    stream ¬ MStream.WriteOnly[file, [], text!      MStream.Error => GOTO cantAcquire];    AddressCache.Enumerate[WriteEntry];    MStream.SetLength[stream, stream.GetPosition[]];    EXITS      quit => NULL;      nofile => Write["No file specified to load.\n"L];      cantAcquire => {Write["Cant acquire file "L]; Write[file]; Write[".\n"L]};    END;    IF stream # NIL THEN stream.Delete[];    };    CacheHelp: Exec.ExecProc = {    Write: Format.StringProc ¬ h.OutputProc[];    Write["CacheAddress.~  command/arg command/arg ...  Command/Arg    SetSize/n		address cache size is set to n.    GetSize		returns address cache size.    Flush		flushes the content of the cache, size remains the same.    List		lists contents of the cache.    Certify/entry	validates cache entry.    Load/file		loads contents of file into cache.    Store/file		stores contents of cache into file.    Statistics		lists local statistics.  Example:  CacheAddress.~  SetSize/20 List Store/foo.cache  "L];    };    Init: PROC = {    IF Runtime.IsBound[LOOPHOLE[Exec.AddCommand]] THEN Exec.AddCommand[      name:"CacheAddress.~"L, proc: CacheManager, help: CacheHelp]    ELSE AddressCache.SetSize[10];    };    Init[];    }.
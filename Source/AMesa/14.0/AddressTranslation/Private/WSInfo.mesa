-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- WSInfo.mesa, last edited by:-- KAM		 8-Apr-85 17:20:47-- AOF		15-Mar-85 11:06:03DIRECTORY  Courier USING [VersionRange],  CourierProtocol USING [MessageType, ProtocolRange, RejectCode],  Listener,  NSConstantsExtras USING [wsInfoSocket],  NSTypes USING [maxDataWordsPerExchange, wordsPerExchangeHeader],  System USING [GreenwichMeanTime, HostNumber, SocketNumber];  WSInfo: DEFINITIONS =  BEGIN    -- This protocol is Expedited Courier compatable. The message body starts on  -- b.ns.packetExchangeBody. The size of the packet must include the  -- overhead pexOverhead.    version: CARDINAL = 6;  program: LONG CARDINAL = 23;  procedure: CARDINAL = 1;  --  there is only one exported procedure  socket: System.SocketNumber = NSConstantsExtras.wsInfoSocket;    pexOverhead: CARDINAL = NSTypes.wordsPerExchangeHeader;  callOverhead: CARDINAL = 8;  returnOverhead: CARDINAL = 4;  strMax: CARDINAL = 40;  verMax: CARDINAL = 6;     sizeLocateRequest: PROCEDURE [count: CARDINAL] RETURNS [CARDINAL] = INLINE {    RETURN[      pexOverhead + callOverhead + SIZE[locateRequest Request]      + count * SIZE[System.HostNumber]]};  sizeLocateReply: CARDINAL = pexOverhead + returnOverhead    + SIZE[locateReply Response];  sizePilotInfoRequest: CARDINAL = pexOverhead + callOverhead    + SIZE[pilotInfoRequest Request];  sizePilotInfoReply: CARDINAL = pexOverhead + returnOverhead    + SIZE[pilotInfoReply Response];  sizeXdeInfoRequest: CARDINAL = pexOverhead + callOverhead    + SIZE[xdeInfoRequest Request];  sizeXdeInfoReply: CARDINAL = pexOverhead + returnOverhead    + SIZE[xdeInfoReply Response];  sizeXdeData: CARDINAL =     SIZE[xdeInfoReply Response] - SIZE[locateReply Response];  sizePilotData: CARDINAL =     SIZE[pilotInfoReply Response] - SIZE[locateReply Response];    maxHostCount: CARDINAL = (    NSTypes.maxDataWordsPerExchange - sizeLocateRequest[0])/      SIZE[System.HostNumber];    PacketType: TYPE = Listener.PacketType;  Message: TYPE = MACHINE DEPENDENT RECORD[    protRange(0): CourierProtocol.ProtocolRange ¬ [protocol3, protocol3],    body(2): SELECT type(2): CourierProtocol.MessageType FROM      call => [	transaction(3): CARDINAL,	program(4): LONG CARDINAL,	version(6), procedure(7): CARDINAL,	request(callOverhead): Request],      reject => [	transaction(3): CARDINAL,	rejectBody(4): SELECT reject(4): CourierProtocol.RejectCode FROM	  noSuchProgramNumber, noSuchProcedureValue, invalidArguments => [],	  noSuchVersionNumber => [range(5): Courier.VersionRange],	  ENDCASE],      return => [transaction(3): CARDINAL, response(returnOverhead): Response],      abort => [transaction(3), abort(4): CARDINAL],      ENDCASE];    Request: TYPE = MACHINE DEPENDENT RECORD[    request(0): SELECT type(0): PacketType FROM      pilotInfoRequest, xdeInfoRequest => [],      locateRequest => [        first(1), last(4): System.HostNumber,	count(7): CARDINAL,	hosts(8): ARRAY [0.. 0) OF System.HostNumber],      ENDCASE];  CourierString: TYPE = RECORD[    length: CARDINAL,    string: PACKED ARRAY[0..strMax) OF CHARACTER];    ShortCourierString: TYPE = RECORD[    length: CARDINAL,    string: PACKED ARRAY[0..verMax) OF CHARACTER];    CourierTime: TYPE = System.GreenwichMeanTime;    Response: TYPE = MACHINE DEPENDENT RECORD[    response(0): SELECT type(0): PacketType FROM      locateReply => [size(1): CARDINAL],      pilotInfoReply => [        size(1): CARDINAL,        time(2): CourierTime,	timeBooted(4): CourierTime,	bfCreateDate(6): CourierTime,	sysVolName(8): CourierString,	pVName(29): CourierString],      xdeInfoReply => [        size(1): CARDINAL,	loggedIn(2): BOOLEAN,	bfVersion(3): ShortCourierString,	userName(7): CourierString],      ENDCASE];	  END...
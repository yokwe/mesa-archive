-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- NetTopologyImpl.mesa, last edited by:-- Keith	18-Apr-84 15:37:04DIRECTORY  Context USING [Create, Find, Type, UniqueType],  Dependency USING [    Create, Destroy, DisplayGraph, Error, Finalize, Handle, IncludeNodeProc,    Initialize, MakeDepSW, Node, PlaceNodes, RecordDependency, ReduceGraph,    ResetDepSW],  Exec USING [    AddCommand, EndOfCommandLine, ExecProc, FreeTokenString, GetToken,    Handle, OutputProc],  Format USING [    Char, CR, Decimal, HostNumber, LongOctal, NetworkAddress, StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, DisplayItem,    LongNumberItem, newLine, NumberItem, ProcType],  Heap USING [systemZone],  NetTopologyOps USING [    BuildGraph, FreeGraph, GetNNet, GetPairType, GetPNet, Graph,    LongCardinalToNet, MyNet, Net, NetToLongCardinal, Pair, Server],  Process USING [Detach],  Put USING [LongString],  Router USING [infinity],  String USING [AppendLongNumber, AppendString, InvalidNumber, StringToDecimal],  System USING [HostNumber, NetworkAddress, NetworkNumber],  Tool USING [    Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [Destroy, TransitionProcType, WindowForSubwindow],  UserTerminal USING [BlinkDisplay],  Window USING [Dims, GetBox, Handle],  WindowFont USING [CharWidth, FontHeight];NetTopologyImpl: MONITOR  IMPORTS    Context, Dependency, Exec, Format, FormSW, Heap, NetTopologyOps, Process,    Put, String, Tool, ToolWindow, UserTerminal, Window, WindowFont =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;  infinity: CARDINAL = LAST[CARDINAL];  minXGap: CARDINAL = WindowFont.CharWidth['M];  -- pixel width of char;  minYGap: CARDINAL = 2 * WindowFont.FontHeight[];  -- pixel height of char;  infoCxt: Context.Type = Context.UniqueType[];  aroundItem, hopsItem: CARDINAL ¬ 0;  WindowInfo: TYPE = LONG POINTER TO WindowInfoRecord;  WindowInfoRecord: TYPE = RECORD [    msg, form, log, plot: Window.Handle ¬ NIL,    busy: BOOLEAN ¬ TRUE,    hops, drawHops: CARDINAL ¬ 1,    from, to, around: LONG CARDINAL ¬ 0,    graph: Graph ¬ NIL,    graphObject: Dependency.Handle ¬ NIL,    nodes: Node ¬ NIL];  Graph: TYPE = NetTopologyOps.Graph;  Net: TYPE = NetTopologyOps.Net;  Pair: TYPE = NetTopologyOps.Pair;  Server: TYPE = NetTopologyOps.Server;    Node: TYPE = LONG POINTER TO NodeRecord;  NodeRecord: TYPE = RECORD [who: Net, hops: CARDINAL, next: Node];  AppendNetworkName: PROCEDURE [s: LONG STRING, net: Net] =    BEGIN    WITH n: net SELECT FROM      net => String.AppendLongNumber[	s, NetTopologyOps.NetToLongCardinal[n.who], 8];      phone => {	String.AppendString[s, "Phone "L];	String.AppendLongNumber[s, n.who, 8]};      ENDCASE;    END;        CalculateDistances: PROCEDURE [graph: Graph, from: Net]    RETURNS [nodes: Node] =    BEGIN    Find: PROCEDURE [who: Net] RETURNS [last: Node] =      BEGIN      FOR last ¬ nodes, last.next DO        IF last.who = who THEN RETURN[NIL];        IF last.next = NIL THEN RETURN[last];        ENDLOOP;      END;    add: Node;    IF FirstEdge[graph, from] = graph.size THEN RETURN[NIL];    nodes ¬ z.NEW[NodeRecord ¬ [from, 0, NIL]];    FOR at: Node ¬ nodes, at.next UNTIL at = NIL DO      FOR pair: CARDINAL IN [FirstEdge[graph, at.who].. graph.size)       UNTIL graph[pair].a # at.who DO        add ¬ Find[graph[pair].b];        IF add # NIL THEN          add.next ¬ z.NEW[NodeRecord ¬ [graph[pair].b, SUCC[at.hops], NIL]];        ENDLOOP;      ENDLOOP;    END;  CountNodes: PROCEDURE [i: WindowInfo] RETURNS [c: CARDINAL] =    BEGIN    n: Node ¬ i.nodes;    c ¬ 0;    UNTIL n = NIL DO c ¬ SUCC[c]; n ¬ n.next ENDLOOP;    END;  CreateTool: PROCEDURE [hops: CARDINAL] RETURNS [window: Window.Handle] = {    window ¬ Tool.Create[      name: "Network topology"L, makeSWsProc: MakeSWs,      clientTransition: Transition]};  DestroyCxt: PROCEDURE [info: WindowInfo, window: Window.Handle] = {    Dependency.Finalize[]; z.FREE[@info]};  DestroyTool: FormSW.ProcType =    BEGIN    info: WindowInfo ¬ Context.Find[infoCxt, ToolWindow.WindowForSubwindow[sw]];    IF info.busy THEN {UserTerminal.BlinkDisplay[]; RETURN};    NetTopologyOps.FreeGraph[@info.graph];    FreeNodeStructure[@info.nodes];    ToolWindow.Destroy[      ToolWindow.WindowForSubwindow[sw] ! Dependency.Error => CONTINUE];    END;  DisplayGraph: PROCEDURE [info: WindowInfo] =    BEGIN    AllRootNodes: Dependency.IncludeNodeProc = {RETURN[TRUE]};    InDAG: PROCEDURE [p: Pair] RETURNS [BOOLEAN] =      BEGIN      hops: CARDINAL = MAX[info.drawHops, 1];      d1: CARDINAL = Distance[p.a, nodes];      d2: CARDINAL = Distance[p.b, nodes];      RETURN[        SELECT TRUE FROM          (d1 > hops) OR (d2 > hops) => FALSE,          d1 < d2 => TRUE,          d1 > d2 => FALSE,          ENDCASE =>	    SELECT NetTopologyOps.GetPairType[p] FROM	      pn => TRUE,	      np => FALSE,	      pp =>	        NetTopologyOps.GetPNet[p, a].who 		  < NetTopologyOps.GetPNet[p, b].who,	      nn =>	        NetTopologyOps.NetToLongCardinal[		    NetTopologyOps.GetNNet[p, a].who] <                  NetTopologyOps.NetToLongCardinal[		    NetTopologyOps.GetNNet[p, b].who],	      ENDCASE => FALSE];      END;    Out: Format.StringProc = {Put.LongString[info.msg, s]};    dims: Window.Dims = info.plot.GetBox[].dims;    nodes: Node ¬ GetDistances[info, [net [NetTopologyOps.MyNet[]]]];    aroundNet: System.NetworkNumber = NetTopologyOps.LongCardinalToNet[      info.around];    n1: LONG STRING ¬ [12];    n2: LONG STRING ¬ [12];    IF info.graph = NIL THEN RETURN;    IF aroundNet # NetTopologyOps.MyNet[] THEN      BEGIN      IF Distance[[net [aroundNet]], nodes] = infinity THEN        BEGIN        Format.LongOctal[Out, info.around];        Out[" is not in the graph"L];        Format.CR[Out];        info.around ¬ NetTopologyOps.NetToLongCardinal[NetTopologyOps.MyNet[]];        FormSW.DisplayItem[info.form, aroundItem];        RETURN;        END      ELSE nodes ¬ GetDistances[info, [net [aroundNet]]];      END;    IF info.graphObject # NIL THEN [] ¬ info.graphObject.Destroy[];    info.graphObject ¬ Dependency.Create[CountNodes[info]];    FOR p: CARDINAL IN [0.. info.graph.size) DO      IF InDAG[info.graph[p]] THEN        BEGIN        n1.length ¬ n2.length ¬ 0;        AppendNetworkName[n1, info.graph[p].a];        AppendNetworkName[n2, info.graph[p].b];        info.graphObject.RecordDependency[n1, n2];        END;      ENDLOOP;    Dependency.ResetDepSW[info.plot];    Out["placing nodes... "L];    info.graphObject.ReduceGraph[];    info.graphObject.PlaceNodes[AllRootNodes, dims.w, dims.h, minXGap, minYGap];    Out["drawing graph... "L];    info.graphObject.DisplayGraph[info.plot];    Format.CR[Out];    END;  Distance: PROCEDURE [net: Net, d: Node] RETURNS [CARDINAL] =    BEGIN    FOR node: Node ¬ d, node.next UNTIL node = NIL DO      IF node.who = net THEN RETURN[node.hops]; ENDLOOP;    RETURN[infinity];    END;  DistancesCommand: FormSW.ProcType =    BEGIN    info: WindowInfo ¬ Context.Find[infoCxt, ToolWindow.WindowForSubwindow[sw]];    Out: Format.StringProc = {Put.LongString[info.log, s]};    netFrom: System.NetworkNumber ¬ NetTopologyOps.LongCardinalToNet[      info.around];    distances: Node;    IF info.busy THEN {UserTerminal.BlinkDisplay[]; RETURN};    Out["Distances from net "L];    Format.LongOctal[Out, info.around];    Format.CR[Out];    distances ¬ GetDistances[info, [net [netFrom]]];    IF distances = NIL THEN      BEGIN      Format.LongOctal[Out, info.around];      Out[" is not in the net"L];      Format.CR[Out];      RETURN;      END;    FOR n: Node ¬ distances, n.next UNTIL n = NIL DO      FormatNetworkName[Out, n.who];      Out[" = "L];      Format.Decimal[Out, n.hops];      Format.Char[Out, ' ];      ENDLOOP;    Format.CR[Out];    END;  FirstEdge: PROCEDURE [graph: Graph, who: Net] RETURNS [first: CARDINAL] =    BEGIN    FOR first IN [0.. graph.size) DO      IF graph[first].a = who THEN RETURN[first] ENDLOOP;    RETURN[graph.size];    END;  Form: FormSW.ClientItemsProcType =    BEGIN    windowInfo: WindowInfo ¬ Context.Find[      infoCxt, ToolWindow.WindowForSubwindow[sw]];    i: CARDINAL ¬ 0;    numberItems: CARDINAL = 11;    items ¬ FormSW.AllocateItemDescriptor[numberItems];    items[i] ¬ FormSW.CommandItem[      tag: "Destroy"L, place: FormSW.newLine, proc: DestroyTool];    items[i ¬ i + 1] ¬ FormSW.CommandItem[tag: "Redo"L, proc: RedoCommand];    items[i ¬ i + 1] ¬ FormSW.NumberItem[tag: "hops"L, value: @windowInfo.hops];    hopsItem ¬ i;    items[i ¬ i + 1] ¬ FormSW.CommandItem[      tag: "Path"L, proc: PathCommand, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "from"L, radix: octal, value: @windowInfo.from];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "to"L, radix: octal, value: @windowInfo.to];    items[i ¬ i + 1] ¬ FormSW.CommandItem[      tag: "Redraw"L, proc: RedrawCommand, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "around"L, radix: octal, value: @windowInfo.around];    aroundItem ¬ i;    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "hops"L, value: @windowInfo.drawHops];    items[i ¬ i + 1] ¬ FormSW.CommandItem[      tag: "Distances"L, proc: DistancesCommand];    items[i ¬ i + 1] ¬ FormSW.CommandItem[tag: "Routers"L, proc: InfoCommand];    IF i + 1 # numberItems THEN ERROR;    RETURN[items, TRUE];    END;    FormatNetworkName: PROCEDURE [Out: Format.StringProc, net: Net] = {    s: STRING ¬ [24]; AppendNetworkName[s, net]; Out[s]};        FreeNodeStructure: PROCEDURE [nodes: LONG POINTER TO Node] =    BEGIN    n, free: Node;    n ¬ nodes­;    UNTIL n = NIL DO free ¬ n; n ¬ n.next; z.FREE[@free] ENDLOOP;    nodes­ ¬ NIL;    END;  GetDistances: PROCEDURE [info: WindowInfo, who: Net]    RETURNS [Node] =    BEGIN    IF info.nodes # NIL AND info.nodes.who = who THEN RETURN[info.nodes];    IF info.nodes # NIL THEN FreeNodeStructure[@info.nodes];    info.nodes ¬ CalculateDistances[info.graph, who];    RETURN[info.nodes];    END;  Init: PROCEDURE = {Exec.AddCommand["NetTopology.~"L, TopologyCommand]};  InfoCommand: FormSW.ProcType =    BEGIN    info: WindowInfo ¬ Context.Find[infoCxt, ToolWindow.WindowForSubwindow[sw]];    Out: Format.StringProc = {Put.LongString[info.log, s]};    DisplayPair: PROCEDURE [p: LONG POINTER TO Pair] =      BEGIN      first: BOOLEAN ¬ TRUE;      name: STRING ¬ [20];      name.length ¬ 0;      Out["Net "L];      AppendNetworkName[name, p.b];      Out[name];      FOR s: Server ¬ p.servers, s.next UNTIL s = NIL DO        IF first THEN {Out[" servers "L]; first ¬ FALSE} ELSE Out[", "L];        Format.HostNumber[Out, s.who.host, octal];        ENDLOOP;      Format.CR[Out];      END;    i: CARDINAL;    net: System.NetworkNumber ¬ NetTopologyOps.LongCardinalToNet[info.around];    IF info.busy THEN {UserTerminal.BlinkDisplay[]; RETURN};    i ¬ FirstEdge[info.graph, [net [net]]];    IF i = info.graph.size THEN      BEGIN      Format.LongOctal[Out, info.around];      Out[" is not in the graph!"L];      Format.CR[Out];      RETURN;      END;    Out["Edges including net "L];    Format.LongOctal[Out, info.around];    Format.Char[Out, ':];    Format.CR[Out];    UNTIL i = info.graph.size      OR NetTopologyOps.GetNNet[info.graph[i], a].who # net      DO DisplayPair[@info.graph[i]]; i ¬ SUCC[i] ENDLOOP;    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: LONG STRING ¬ [20];    windowInfo: WindowInfo ¬ Context.Find[infoCxt, window];    windowInfo.msg ¬ Tool.MakeMsgSW[window, 2];    windowInfo.form ¬ Tool.MakeFormSW[window, Form];    Tool.UnusedLogName[logName, "Topology.log"L];    windowInfo.log ¬ Tool.MakeFileSW[window, logName];    windowInfo.plot ¬ Dependency.MakeDepSW[window];    END;  Path: PROCEDURE [info: WindowInfo, Out: Format.StringProc] =    BEGIN    -- note the next two values are "reversed", because the path is calculated    -- backwards    from: Net ¬ [net [NetTopologyOps.LongCardinalToNet[info.to]]];    to: Net ¬ [net [NetTopologyOps.LongCardinalToNet[info.from]]];    graph: Graph ¬ info.graph;    OnPath: SIGNAL = CODE;    Host: PROCEDURE [s: Server] =      BEGIN      first: BOOLEAN ¬ TRUE;      UNTIL s = NIL DO        IF first THEN first ¬ FALSE ELSE Out[", "L];        Format.NetworkAddress[Out, s.who, octal];        s ¬ s.next;        ENDLOOP;      Out[" => "L];      END;    RecursivePath: PROCEDURE [at: Net] RETURNS [on: BOOLEAN] =      BEGIN      distance: CARDINAL = Distance[at, distances];      IF distance = infinity THEN RETURN[FALSE];      on ¬ FALSE;      IF at = to THEN {SIGNAL OnPath; RETURN[TRUE]};      FOR p: CARDINAL IN [FirstEdge[graph, at].. graph.size)	WHILE graph[p].a = at DO        IF Distance[graph[p].b, distances] < distance THEN          -- don't reverse the order of the next two operands!          on ¬ RecursivePath[graph[p].b ! OnPath => {	    FormatNetworkName[Out, graph[p].b];	    Out[": "L]; Host[graph[p].servers]}]	  OR on;        ENDLOOP;      RETURN[on]      END;    distances: Node ¬ GetDistances[info, to];    IF distances = NIL THEN {Out["no path found"L]; Format.CR[Out]; RETURN};    IF NOT RecursivePath[ from ! OnPath => {      FormatNetworkName[Out, from]; Format.CR[Out]; RESUME}]    THEN {Out["no path found"L]; Format.CR[Out]};    END;  PathCommand: FormSW.ProcType =    BEGIN    info: WindowInfo ¬ Context.Find[infoCxt, ToolWindow.WindowForSubwindow[sw]];    Out: Format.StringProc = {Put.LongString[info.log, s]};    IF info.busy THEN {UserTerminal.BlinkDisplay[]; RETURN};    Out["Path from net "L];    Format.LongOctal[Out, info.from];    Out[" to "L];    Format.LongOctal[Out, info.to];    Out["... "L];    Format.CR[Out];    Path[info, Out];    END;  RedoCommand: ENTRY FormSW.ProcType =    BEGIN    info: WindowInfo ¬ Context.Find[infoCxt, ToolWindow.WindowForSubwindow[sw]];    IF info.busy THEN {UserTerminal.BlinkDisplay[]; RETURN};    info.busy ¬ TRUE;    Process.Detach[FORK RedoProcess[info]];    END;  RedoProcess: PROCEDURE [info: WindowInfo] =    BEGIN    MsgOut: Format.StringProc = {Put.LongString[info.msg, s]};    NetTopologyOps.FreeGraph[@info.graph];    FreeNodeStructure[@info.nodes];    info.graph ¬ NetTopologyOps.BuildGraph[info.hops, MsgOut];    DisplayGraph[info];    info.busy ¬ FALSE;    END;  RedrawCommand: ENTRY FormSW.ProcType =    BEGIN    info: WindowInfo ¬ Context.Find[infoCxt, ToolWindow.WindowForSubwindow[sw]];    IF info.busy THEN {UserTerminal.BlinkDisplay[]; RETURN};    info.busy ¬ TRUE;    Process.Detach[FORK RedrawProcess[info]];    END;  RedrawProcess: PROCEDURE [info: WindowInfo] = {    DisplayGraph[info]; info.busy ¬ FALSE};  TopologyCommand: Exec.ExecProc =    BEGIN    Out: Format.StringProc = Exec.OutputProc[h];    maxHops: CARDINAL ¬ Router.infinity;    IF Exec.EndOfCommandLine[h] THEN Out["Full network topology"L]    ELSE      BEGIN      ok: BOOLEAN ¬ TRUE;      token, switches: LONG STRING;      [token, switches] ¬ Exec.GetToken[h];      switches ¬ Exec.FreeTokenString[switches];      maxHops ¬ String.StringToDecimal[        token ! String.InvalidNumber => {ok ¬ FALSE; CONTINUE}];      IF ok THEN {Out["Topology out to "L]; Out[token]; Out[" hops"L]}      ELSE {Out[token]; Out[" is not a valid number - will use infinity"L]};      token ¬ Exec.FreeTokenString[token];      END;    Format.CR[Out];    Process.Detach[FORK TopologyProcess[maxHops]];    END;  TopologyProcess: PROCEDURE [maxHops: CARDINAL] =    BEGIN    info: WindowInfo;    MsgOut: Format.StringProc = {Put.LongString[info.msg, s]};    window: Window.Handle ¬ CreateTool[maxHops];    info ¬ Context.Find[infoCxt, window];    info.hops ¬ maxHops;    info.graph ¬ NetTopologyOps.BuildGraph[maxHops, MsgOut];    FormSW.DisplayItem[info.form, hopsItem];    DisplayGraph[info];    info.busy ¬ FALSE;    END;  Transition: ToolWindow.TransitionProcType =    BEGIN    IF old = inactive AND Context.Find[infoCxt, window] = NIL THEN      BEGIN      info: WindowInfo ¬ z.NEW[WindowInfoRecord ¬ []];      info.from ¬ info.to ¬ info.around ¬ NetTopologyOps.NetToLongCardinal[        NetTopologyOps.MyNet[]];      Context.Create[infoCxt, info, DestroyCxt, window];      Dependency.Initialize[];      END;    END;  Init[];  END...
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- DepNameImpl.mesa - Last edited by--   Lewis	19-Jan-84 14:39:09DIRECTORY  DepName,  Inline USING [BITAND, LongNumber],  String USING [Compare, CopyToNewString, Empty, FreeString]; DepNameImpl: PROGRAM    IMPORTS Inline, String    EXPORTS DepName =  BEGIN OPEN DepName;    TooManyNames: PUBLIC SIGNAL [h: Handle] = CODE;    Handle: PUBLIC TYPE = LONG POINTER TO HandleObject;  HandleObject: PUBLIC TYPE = RECORD [    maxNames:	CARDINAL ¬ 0,    zone:	UNCOUNTED ZONE ¬ NIL,    count:	CARDINAL ¬ 0,    root:	IdNode ¬ NIL,    idTable:	IdTable ¬ NIL];  IdTable: TYPE = LONG POINTER TO IdTableRep;  IdTableRep: TYPE = RECORD [SEQUENCE maxSize: CARDINAL OF IdNode];    IdNode: TYPE = LONG POINTER TO IdNodeRec;  IdNodeRec: TYPE = RECORD [    hash: Hash,    left, right: IdNode ¬ NIL,    str:  LONG STRING,  -- only one copy of each string is kept    id:   Id];      nullHash: Hash = GetHash[""L];  Hash: TYPE = LONG CARDINAL;      Create: PUBLIC PROC [      maxNames: CARDINAL, zone: UNCOUNTED ZONE] RETURNS [h: Handle] = {    h ¬ zone.NEW[HandleObject ¬ [maxNames: maxNames, zone: zone]];     h.idTable ¬ zone.NEW[IdTableRep[maxNames]];    FOR i: CARDINAL IN [0..maxNames) DO h.idTable[i] ¬ NIL ENDLOOP};  Destroy: PUBLIC PROC [h: Handle] RETURNS [nil: Handle] = {    IF h # NIL THEN {      FOR i: CARDINAL IN [0..h.maxNames) DO        IF h.idTable[i] # NIL AND h.idTable[i].str # NIL THEN	  String.FreeString[h.zone, h.idTable[i].str];        h.zone.FREE[@h.idTable[i]];	ENDLOOP;      h.zone.FREE[@h.idTable];      h.zone.FREE[@h];      RETURN[NIL]}};      Record: PUBLIC PROC [      h: Handle, name: LONG STRING] RETURNS [id: Id, regName: LONG STRING] = {    hash: LONG CARDINAL;    inp: LONG POINTER TO IdNode;    n: LONG STRING;    IF String.Empty[name] THEN RETURN[DummyId, ""];    [inp, hash] ¬ FindId[h, name];    IF inp­ # NIL THEN RETURN[id: inp.id, regName: inp.str];    -- a new name    IF h.count >= h.maxNames THEN SIGNAL TooManyNames[h];    id ¬ h.count;  h.count ¬ (h.count + 1);    n ¬ String.CopyToNewString[name, h.zone];    inp­ ¬ h.zone.NEW[IdNodeRec ¬ [hash: hash, str: n, id: id]];    h.idTable[id] ¬ inp­;    RETURN[id: id, regName: n]};      FindId: PROC [        h: Handle, name: LONG STRING]      RETURNS [inp: LONG POINTER TO IdNode, hash: Hash] = {    IF String.Empty[name] THEN RETURN[NIL, nullHash];    inp ¬ @h.root;  hash ¬ GetHash[name];    WHILE inp­ # NIL DO      SELECT hash FROM        < inp.hash => inp ¬ @inp.left;	> inp.hash => inp ¬ @inp.right;	ENDCASE =>	  SELECT String.Compare[s1: name, s2: inp.str, ignoreCase: TRUE] FROM	    < 0 => inp ¬ @inp.left;	    > 0 => inp ¬ @inp.right;	    ENDCASE => RETURN[inp, hash];      ENDLOOP};  CharBits: PROC [CHARACTER, WORD] RETURNS [WORD] = LOOPHOLE[Inline.BITAND];  CharMask: WORD = 337B;  -- mask out case shifts      GetHash: PROC [s: LONG STRING] RETURNS [Hash] = {  -- ASSERT s # NIL    temp: CARDINAL;    dummy: Inline.LongNumber;    dummy.lc ¬ 0;    FOR i: CARDINAL IN [0..s.length) DO      temp ¬ CharBits[s[i], CharMask];      dummy.lowbits ¬ dummy.lowbits*31 + temp;      dummy.highbits ¬ dummy.highbits + temp;      ENDLOOP;    RETURN[dummy.lc]};    END.
-- File: NetTopologyData.mesa - last edit:-- AOF                 18-Jun-87  8:25:29-- Keith               18-Apr-84 15:30:41-- Copyright (C) 1984, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Ascii USING [NUL],  CmFile USING [FreeString, UserDotCmLine],  Format USING [Char, CR, LongOctal, StringProc],  Heap USING [Create],  NetTopologyOps USING [    Graph, GraphSequence, Net, Pair, PairType, Position, Server, ServerRecord],  NSBuffer USING [Buffer],  NSConstants USING [routingInformationSocket],  NSTypes USING [    bytesPerRoutingHeader, maxRoutingTuplesPerPacket, RoutingInfoTuple,    wordsPerRoutingHeader],  Process USING [Detach, Pause, SecondsToTicks],  QuickSort USING [CompareProc, Sort, SwapProc],  Router USING [    endEnumeration, EnumerateRoutingTable, FillRoutingTable, infinity,    startEnumeration],  Socket USING [    AssignNetworkAddress, ChannelHandle, Create, Delete, GetPacket,    GetPacketBytes, GetSendBuffer, PutPacket, ReturnBuffer, SetPacketWords,    SetWaitTime, TimeOut],  System USING [    broadcastHostNumber, NetworkAddress, NetworkNumber, nullNetworkNumber,    nullSocketNumber],  Token USING [FreeStringHandle, Handle, NetworkNumber, StringToHandle];NetTopologyData: MONITOR  IMPORTS CmFile, Format, Heap, Process, QuickSort, Router, Socket, Token  EXPORTS NetTopologyOps =  BEGIN  z: UNCOUNTED ZONE = Heap.Create[initial: 8];  pauseForRoutingTableToFill: CARDINAL = 2;  -- seconds  probes: CARDINAL = 3;  me: System.NetworkAddress;  ignoreThese: DummyNets м NIL;  DoThisProc: TYPE = PROCEDURE [    who: System.NetworkAddress, info: RoutingTuples];  GiveMeANetProc: TYPE = PROCEDURE RETURNS [net: System.NetworkNumber];  Graph: TYPE = RECORD [pairs: Pair м NIL];  Pair: TYPE = LONG POINTER TO PairRecord;  PairRecord: TYPE = RECORD [    a, b: System.NetworkNumber,  -- edge    hops: CARDINAL,  -- length of edge (one or two)    servers: Server,  -- IR servers which implement this edge    next: Pair];  Server: TYPE = NetTopologyOps.Server;  ServerRecord: TYPE = NetTopologyOps.ServerRecord;  RoutingTuples: TYPE = LONG DESCRIPTOR FOR ARRAY OF NSTypes.RoutingInfoTuple;  DummyNets: TYPE = LONG POINTER TO DummyNetsSequence;  DummyNetsSequence: TYPE = RECORD [    body: SEQUENCE size: CARDINAL OF System.NetworkNumber];  AddEdge: ENTRY PROCEDURE [    graph: LONG POINTER TO Graph, who: System.NetworkAddress,    a, b: System.NetworkNumber, hops: CARDINAL] =    BEGIN    Compare: PROCEDURE [with: Pair] RETURNS [equal: BOOLEAN] = {      RETURN[with.a = a AND with.b = b]};    Ignore: PROCEDURE RETURNS [BOOLEAN] =      BEGIN      IF a = b THEN RETURN[TRUE];      IF ignoreThese = NIL THEN RETURN[FALSE];      FOR i: CARDINAL IN [0..ignoreThese.size) DO        IF ignoreThese[i] = a OR ignoreThese[i] = b THEN RETURN[TRUE] ENDLOOP;      RETURN[FALSE];      END;    IF Ignore[] THEN RETURN;    IF GreaterThan[a, b] THEN {c: System.NetworkNumber; c м a; a м b; b м c};    IF graph.pairs = NIL THEN      graph.pairs м z.NEW[        PairRecord м [        a, b, hops, z.NEW[NetTopologyOps.ServerRecord м [who, NIL]], NIL]]    ELSE      FOR p: Pair м graph.pairs, p.next UNTIL p = NIL DO        IF Compare[p] THEN          BEGIN          SELECT p.hops FROM            > hops =>              BEGIN              s: Server м p.servers;              UNTIL s = NIL DO                p.servers м s.next; z.FREE[@s]; s м p.servers ENDLOOP;              p.servers м z.NEW[NetTopologyOps.ServerRecord м [who, NIL]];              p.hops м hops;              END;            = hops =>              FOR s: Server м p.servers, s.next UNTIL s = NIL DO                IF s.who = who THEN EXIT;                REPEAT                  FINISHED =>                    p.servers м z.NEW[                      NetTopologyOps.ServerRecord м [who, p.servers]]                ENDLOOP;            ENDCASE;          EXIT;          END;        REPEAT          FINISHED =>            graph.pairs м z.NEW[              PairRecord м [              a, b, hops, z.NEW[NetTopologyOps.ServerRecord м [who, NIL]],              graph.pairs]];        ENDLOOP;    END;  AddEdges: PROCEDURE [    maxHops: CARDINAL, graph: LONG POINTER TO Graph, Out: Format.StringProc] =    BEGIN    processes: CARDINAL м 0;    done: CONDITION;    maxProcesses: CARDINAL = 16;    PollerProcess: PROCEDURE [net: System.NetworkNumber, hops: CARDINAL] = {      AddThisNetsNeighbors[graph, net, hops]; Stop[]};    Start: ENTRY PROCEDURE = {processes м SUCC[processes]};    Stop: ENTRY PROCEDURE = {processes м PRED[processes]; NOTIFY done};    WaitForStart: ENTRY PROCEDURE = {      WHILE processes >= maxProcesses DO WAIT done ENDLOOP};    WaitForStop: ENTRY PROCEDURE = {WHILE processes > 0 DO WAIT done ENDLOOP};    Router.FillRoutingTable[maxHops];    Process.Pause[Process.SecondsToTicks[pauseForRoutingTableToFill]];    AddMyNeighbors[graph, Out];    FOR hops: CARDINAL IN [1..maxHops) DO      FOR net: System.NetworkNumber м Router.EnumerateRoutingTable[        Router.startEnumeration, hops], Router.EnumerateRoutingTable[net, hops]        UNTIL net = Router.endEnumeration DO        WaitForStart[];        Format.Char[Out, ' ];        Format.LongOctal[Out, NetToLongCardinal[net]];        Start[];        Process.Detach[FORK PollerProcess[net, hops]];        ENDLOOP;      ENDLOOP;    WaitForStop[];    END;  AddMyNeighbors: PROCEDURE [    graph: LONG POINTER TO Graph, Out: Format.StringProc] =    BEGIN    Format.Char[Out, ' ];    Format.LongOctal[Out, NetToLongCardinal[me.net]];    AddThisNetsNeighbors[graph, me.net, 0];    END;  AddReverseEdges: PROCEDURE [graph: LONG POINTER TO Graph] =    BEGIN    FOR p: Pair м graph.pairs, p.next.next UNTIL p = NIL DO      p.next м z.NEW[PairRecord м [p.b, p.a, p.hops, NIL, p.next]];      FOR s: Server м p.servers, s.next UNTIL s = NIL DO        p.next.servers м z.NEW[          NetTopologyOps.ServerRecord м [s.who, p.next.servers]]        ENDLOOP;      ENDLOOP;    END;  AddThisNetsNeighbors: PROCEDURE [    graph: LONG POINTER TO Graph, net: System.NetworkNumber, hops: CARDINAL] =    BEGIN    socket: Socket.ChannelHandle;    currentHops: CARDINAL м IF hops > 2 THEN hops - 2 ELSE 0;    currentNet: System.NetworkNumber м Router.endEnumeration;    GiveANet: GiveMeANetProc =      BEGIN      IF currentNet # Router.endEnumeration THEN        currentNet м Router.EnumerateRoutingTable[currentNet, currentHops];      UNTIL currentNet # Router.endEnumeration DO        currentHops м SUCC[currentHops];        IF currentHops > hops + 2 THEN RETURN[System.nullNetworkNumber];        currentNet м Router.EnumerateRoutingTable[          Router.startEnumeration, currentHops];        ENDLOOP;      RETURN[currentNet];      END;    UseReply: DoThisProc =      BEGIN      FOR i: CARDINAL IN [0..LENGTH[info]) DO        IF info[i].interrouterDelay IN [1..2] THEN          AddEdge[            graph, who, net, info[i].objectNetID, info[i].interrouterDelay]        ENDLOOP;      END;    socket м Socket.Create[System.nullSocketNumber, 1, 20];    GetRoutingInfo[socket, net, hops, GiveANet, UseReply];    Socket.Delete[socket];    END;  BuildGraph: PUBLIC PROCEDURE [hops: CARDINAL, Out: Format.StringProc]    RETURNS [graph: NetTopologyOps.Graph] =    BEGIN    g: Graph м [];    Out["Collecting routing information..."L];    AddEdges[hops, @g, Out];    IF g.pairs = NIL THEN {Out[" no nets found"L]; Format.CR[Out]; RETURN[NIL]};    Format.CR[Out];    TrimExtraEdges[@g, Out];    graph м InducePhoneLines[@g];    Router.FillRoutingTable[0];    END;  FirstEdge: PROCEDURE [g: Graph, n: System.NetworkNumber] RETURNS [p: Pair] = {    FOR p м g.pairs, p.next UNTIL p = NIL OR p.a = n DO ENDLOOP};  FreeGraph: PUBLIC PROCEDURE [graph: LONG POINTER TO NetTopologyOps.Graph] =    BEGIN    FOR i: CARDINAL IN [0..graph.size) DO      s: Server м graph[i].servers;      UNTIL s = NIL DO        graph[i].servers м s.next; z.FREE[@s]; s м graph[i].servers ENDLOOP;      ENDLOOP;    z.FREE[graph];    END;  GetNNet: PUBLIC PROCEDURE [    p: NetTopologyOps.Pair, pos: NetTopologyOps.Position]    RETURNS [net NetTopologyOps.Net] = {    RETURN[      WITH net: (IF pos = a THEN p.a ELSE p.b) SELECT FROM        net => net,        ENDCASE => ERROR]};  GetPNet: PUBLIC PROCEDURE [    p: NetTopologyOps.Pair, pos: NetTopologyOps.Position]    RETURNS [phone NetTopologyOps.Net] = {    RETURN[      WITH net: (IF pos = a THEN p.a ELSE p.b) SELECT FROM        phone => net,        ENDCASE => ERROR]};  GetPairType: PUBLIC PROCEDURE [p: NetTopologyOps.Pair]    RETURNS [type: NetTopologyOps.PairType] = {    RETURN[      WITH p.a SELECT FROM        phone => WITH p.b SELECT FROM phone => pp, ENDCASE => pn,        ENDCASE => WITH p.b SELECT FROM phone => np, ENDCASE => nn]};  GetRoutingInfo: PROCEDURE [    socket: Socket.ChannelHandle, net: System.NetworkNumber, hops: CARDINAL,    getNet: GiveMeANetProc, do: DoThisProc] =    BEGIN    count: CARDINAL м 0;    sizeTuple: CARDINAL = SIZE[NSTypes.RoutingInfoTuple];    nets: ARRAY [0..NSTypes.maxRoutingTuplesPerPacket) OF System.NetworkNumber;    SendAndProcess: PROCEDURE =      BEGIN      b: NSBuffer.Buffer;      THROUGH [0..probes) DO        b м Socket.GetSendBuffer[socket];        b.ns.packetType м routingInformation;        b.ns.destination м [          net, System.broadcastHostNumber,          NSConstants.routingInformationSocket];        b.ns.routingType м routingInfoRequest;        Socket.SetPacketWords[          b, NSTypes.wordsPerRoutingHeader + count * sizeTuple];        FOR i: CARDINAL IN [0..count) DO          b.ns.routingTuple[i] м [nets[i], Router.infinity] ENDLOOP;        Socket.PutPacket[socket, b];        DO          b м Socket.GetPacket[socket ! Socket.TimeOut => EXIT];          IF b.ns.packetType = routingInformation            AND b.ns.routingType = routingInfoResponse THEN            do[b.ns.source, Tuples[b]];          Socket.ReturnBuffer[b];          ENDLOOP;        ENDLOOP;      count м 0;      END;    Socket.SetWaitTime[socket, (IF hops < 3 THEN 3 ELSE hops) * 1000];    FOR about: System.NetworkNumber м getNet[], getNet[] UNTIL about =      System.nullNetworkNumber DO      nets[count] м about;      count м SUCC[count];      IF count = NSTypes.maxRoutingTuplesPerPacket THEN SendAndProcess[];      ENDLOOP;    IF count # 0 THEN SendAndProcess[];    END;  GreaterThan: PROCEDURE [a, b: System.NetworkNumber] RETURNS [BOOLEAN] = {    RETURN[NetToLongCardinal[a] > NetToLongCardinal[b]]};  InducePhoneLines: PROCEDURE [g: LONG POINTER TO Graph]    RETURNS [graph: NetTopologyOps.Graph] =    BEGIN    AddAllPhoneLinesAndFreeOldGraph: PROCEDURE      RETURNS [lastLine: CARDINAL м 0] =      BEGIN      CopyServers: PROCEDURE [from, to: CARDINAL] =        BEGIN	graph[to].servers м NIL;	FOR s: Server м graph[from].servers, s.next UNTIL s = NIL DO	  graph[to].servers м z.NEW[ServerRecord м [s.who, graph[to].servers]];	  ENDLOOP;	END;      i: CARDINAL м 0;      UNTIL g.pairs = NIL DO        p: Pair м g.pairs;        g.pairs м p.next;        SELECT p.hops FROM          1 => {graph[i] м [[net[p.a]], [net[p.b]], p.servers]; i м i + 1};          2 =>	    IF NetToLongCardinal[p.a] < NetToLongCardinal[p.b] THEN	      BEGIN	      lastLine м SUCC[lastLine];	      graph[i] м [[net[p.a]], [phone[lastLine, 0]], NIL];	      graph[i + 1] м [[phone[lastLine, 0]], [net[p.b]], NIL];	      UNTIL p.servers = NIL DO		s: Server м p.servers;		p.servers м s.next;		IF s.who.net = p.a THEN {		  s.next м graph[i].servers; graph[i].servers м s}		ELSE {s.next м graph[i + 1].servers; graph[i + 1].servers м s};		ENDLOOP;	      graph[i + 2] м [graph[i].b, graph[i].a, NIL];	      CopyServers[i, i + 2];	      graph[i + 3] м [graph[i + 1].b, graph[i + 1].a, NIL];	      CopyServers[i + 1, i + 3];	      i м i + 4;	      END;          ENDCASE;        g.pairs м p.next;        z.FREE[@p];        p м g.pairs;        ENDLOOP;      Sort[];      END;    Compare: QuickSort.CompareProc =      BEGIN      N: TYPE = MACHINE DEPENDENT RECORD [one(0), two(3): NetTopologyOps.Net];      CompareType: TYPE = ARRAY [0..6) OF UNSPECIFIED;      Less: PROCEDURE [a, b: CompareType] RETURNS [BOOLEAN] = {        FOR i: CARDINAL IN [0..6) DO          SELECT a[i] FROM            < b[i] => RETURN[TRUE];            > b[i] => RETURN[FALSE]            ENDCASE;          ENDLOOP;        RETURN[FALSE]};      v1: CompareType м LOOPHOLE[N[graph[one].a, graph[one].b]];      v2: CompareType м LOOPHOLE[N[graph[two].a, graph[two].b]];      RETURN[        SELECT TRUE FROM          v1 = v2 => same,          Less[v1, v2] => smaller,          ENDCASE => bigger]      END;    CountEdges: PROCEDURE RETURNS [c: CARDINAL м 0] = {      FOR p: Pair м g.pairs, p.next UNTIL p = NIL DO c м c + p.hops ENDLOOP};    MergeCommonLines: PROCEDURE [numberLines: CARDINAL] =      BEGIN      MinimumP: PROCEDURE [i: CARDINAL] RETURNS [min: CARDINAL] =        BEGIN        a: System.NetworkNumber = GetNNet[graph[i], a].who;        min м renumberTable[GetPNet[graph[i], b].who];        FOR i: CARDINAL IN [i..graph.size) DO          IF GetPairType[graph[i]] # np THEN EXIT;          IF GetNNet[graph[i], a].who # a THEN EXIT;          min м MIN[min, renumberTable[GetPNet[graph[i], b].who]];          ENDLOOP;        END;      NextNP: PROCEDURE [i: CARDINAL] RETURNS [first: CARDINAL] =        -- By now, the graph is sorted, so graph[0] is of type pn or nn        BEGIN        skip: System.NetworkNumber м IF GetPairType[graph[i]] = np	  THEN GetNNet[graph[i], a].who ELSE System.nullNetworkNumber;        FOR first IN [i..graph.size) DO          IF GetPairType[graph[first]] = np	    AND GetNNet[graph[first], a].who # skip THEN RETURN[first];          REPEAT FINISHED => RETURN[graph.size];          ENDLOOP;        END;      RenameALines: PROCEDURE =        BEGIN        FOR i: CARDINAL IN [0..graph.size) DO          SELECT GetPairType[graph[i]] FROM            pp, pn =>              graph[i].a м [phone[renumberTable[GetPNet[graph[i], a].who], 0]]            ENDCASE;          ENDLOOP;        END;      RenameBLines: PROCEDURE [i, value: CARDINAL] =        BEGIN        a: System.NetworkNumber = GetNNet[graph[i], a].who;        WHILE (i < graph.size)	  AND (GetPairType[graph[i]] = np) AND (GetNNet[graph[i], a].who = a) DO          old: CARDINAL м renumberTable[GetPNet[graph[i], b].who];	  graph[i].b м [phone[old, 0]];          IF old # value THEN	    BEGIN	    renamed м TRUE;	    renumberTable[old] м value;	    graph[i].b м [phone[value, 0]];	    END;	  i м SUCC[i];          ENDLOOP;        END;      RemoveDuplicateEdges: PROCEDURE =        BEGIN        insert, at: CARDINAL м 0;        oldGraph: NetTopologyOps.Graph м graph;        FOR at IN [1..oldGraph.size) DO          IF Compare[at - 1, at, NIL] # same THEN            oldGraph[insert м SUCC[insert]] м oldGraph[at];          ENDLOOP;        graph м z.NEW[NetTopologyOps .GraphSequence[insert + 1]];        FOR i: CARDINAL IN [0..insert] DO graph[i] м oldGraph[i] ENDLOOP;        z.FREE[@oldGraph];        END;      RTRecord: TYPE = RECORD [body: SEQUENCE size: CARDINAL OF CARDINAL];      renumberTable: LONG POINTER TO RTRecord м z.NEW[        RTRecord [numberLines + 1]];      renamed: BOOLEAN м FALSE;      index: CARDINAL;      FOR index IN [0..numberLines] DO renumberTable[index] м index ENDLOOP;      FOR index м NextNP[0], NextNP[index] UNTIL index = graph.size DO        RenameBLines[index, MinimumP[index]] ENDLOOP;      IF renamed THEN {RenameALines[]; Sort[]; RemoveDuplicateEdges[]};      z.FREE[@renumberTable];      END;    Sort: PROCEDURE =      BEGIN      Swap: QuickSort.SwapProc =        BEGIN        x: NetTopologyOps.Pair м graph[one];        graph[one] м graph[two];        graph[two] м x;        END;      QuickSort.Sort[        min: 0, max: graph.size - 1, compare: Compare, swap: Swap, data: graph];      END;    graph м z.NEW[NetTopologyOps .GraphSequence[CountEdges[]]];    MergeCommonLines[AddAllPhoneLinesAndFreeOldGraph[]];    END;  Init: PROCEDURE =    BEGIN    me м Socket.AssignNetworkAddress[];    me.socket м NSConstants.routingInformationSocket;    ignoreThese м ProcessCmFile[];    END;  TwoWords: TYPE = MACHINE DEPENDENT RECORD [one, two: WORD];  LongCardinalToNet: PUBLIC PROCEDURE [x: LONG CARDINAL]    RETURNS [net: System.NetworkNumber] =    BEGIN    x2: TwoWords м LOOPHOLE[x];    y2: TwoWords м [x2.two, x2.one];    RETURN[LOOPHOLE[y2]];    END;  MyNet: PUBLIC PROCEDURE RETURNS [System.NetworkNumber] = {RETURN[me.net]};  NetToLongCardinal: PUBLIC PROCEDURE [net: System.NetworkNumber]    RETURNS [x: LONG CARDINAL] =    BEGIN    x2: TwoWords м LOOPHOLE[net];    y2: TwoWords м [x2.two, x2.one];    RETURN[LOOPHOLE[y2]];    END;  ProcessCmFile: PROCEDURE RETURNS [ignore: DummyNets] =    BEGIN    count: CARDINAL м 0;    Net: TYPE = LONG POINTER TO NetRecord;    NetRecord: TYPE = RECORD [net: System.NetworkNumber, next: Net];    net: System.NetworkNumber;    first, this: Net м NIL;    line: LONG STRING м CmFile.UserDotCmLine["NetTopology"L, "Ignore"];    h: Token.Handle;    IF line = NIL THEN RETURN[NIL];    h м Token.StringToHandle[line];    DO      net м h.NetworkNumber[signalOnError: FALSE];      IF net = System.nullNetworkNumber THEN        IF h.break = Ascii.NUL THEN EXIT ELSE LOOP;      first м z.NEW[NetRecord м [net, first]];      count м SUCC[count];      ENDLOOP;    ignore м IF count = 0 THEN NIL ELSE z.NEW[DummyNetsSequence [count]];    count м 0;    UNTIL first = NIL DO      this м first;      first м first.next;      ignore[count] м this.net;      count м SUCC[count];      z.FREE[@this];      ENDLOOP;    h м h.FreeStringHandle[];    line м CmFile.FreeString[line];    END;  TrimExtraEdges: PROCEDURE [    graph: LONG POINTER TO Graph, Out: Format.StringProc] =    BEGIN    Sort: PROCEDURE [graph: LONG POINTER TO Graph] =      BEGIN      Handle: TYPE = LONG POINTER TO Object;      Object: TYPE = RECORD [s: SEQUENCE size: INTEGER OF Pair];      Compare: QuickSort.CompareProc = {        RETURN[          SELECT TRUE FROM            h[one].a = h[two].a AND h[one].b = h[two].b => same,            GreaterThan[h[one].a, h[two].a]              OR (h[one].a = h[two].a AND GreaterThan[h[one].b, h[two].b]) =>              bigger,            ENDCASE => smaller]};      CountEdges: PROCEDURE RETURNS [c: CARDINAL] =        BEGIN        c м 0;        FOR p: Pair м graph.pairs, p.next UNTIL p = NIL DO c м SUCC[c] ENDLOOP;        END;      Swap: QuickSort.SwapProc = {        x: Pair м h[one]; h[one] м h[two]; h[two] м x};      h: Handle м z.NEW[Object [CountEdges[]]];      index: INTEGER м 0;      FOR p: Pair м graph.pairs, p.next UNTIL p = NIL DO        h[index] м p; index м SUCC[index] ENDLOOP;      QuickSort.Sort[        min: 0, max: h.size - 1, compare: Compare, swap: Swap, data: h];      graph.pairs м h[0];      FOR index IN [0..h.size - 1) DO h[index].next м h[SUCC[index]] ENDLOOP;      h[h.size - 1].next м NIL;      z.FREE[@h];      END;    Transitive: PROCEDURE [graph: Graph, a, b: System.NetworkNumber]      RETURNS [BOOLEAN] =      BEGIN      -- returns TRUE if there exists for some x the two edges (a, x) and (x, b)      -- Equivalently, if there exists for some x the edges (a, x) and (b, x)      pA, pB: Pair;      pA м FirstEdge[graph, a];      pB м FirstEdge[graph, b];      WHILE (pA # NIL AND pA.a = a) AND (pB # NIL AND pB.a = b) DO        SELECT TRUE FROM          pA.b = pB.b =>            IF pA.hops = 1 AND pB.hops = 1 THEN RETURN[TRUE]            ELSE {pA м pA.next; pB м pB.next};          GreaterThan[pA.b, pB.b] => pB м pB.next;          ENDCASE => pA м pA.next;        ENDLOOP;      RETURN[FALSE];      END;    TrimZeroHops: PROCEDURE =      BEGIN      p: LONG POINTER TO Pair м @graph.pairs;      kill: Pair;      UNTIL pн = NIL DO        IF pнн.hops = 0 THEN {kill м pн; pн м pнн.next; z.FREE[@kill]}        ELSE p м @(pнн.next);        ENDLOOP;      END;    Out["Adding reverse edges... "L];    AddReverseEdges[graph];    Out["sorting graph... "L];    Sort[graph];    Out["trimming extra edges... "L];    FOR p: Pair м graph.pairs, p.next UNTIL p = NIL DO      IF p.hops = 2 AND Transitive[graphн, p.a, p.b] THEN p.hops м 0 ENDLOOP;    TrimZeroHops[];    Format.CR[Out];    END;  Tuples: PROCEDURE [b: NSBuffer.Buffer] RETURNS [RoutingTuples] = INLINE {    RETURN[      DESCRIPTOR[        @b.ns.routingTuple,          (Socket.GetPacketBytes[b] - NSTypes.bytesPerRoutingHeader) /            (2 * SIZE[NSTypes.RoutingInfoTuple])]]};  Init[];  END...
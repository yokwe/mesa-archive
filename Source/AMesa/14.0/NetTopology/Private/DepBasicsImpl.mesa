-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- DepBasicsImpl.mesa - Last edited by--   Lewis	20-Jan-84 16:32:42--   Keith	 7-Mar-84 14:57:33DIRECTORY  Dependency,  DepName,  Heap USING [Create, Delete],  QuickSort USING [CompareProc, Sort, SwapProc],  String USING [Compare],  WindowFont; DepBasicsImpl: PROGRAM    IMPORTS DepName, Heap, QuickSort, String, WindowFont    EXPORTS Dependency =  BEGIN OPEN Dependency;    Error: PUBLIC SIGNAL [code: Dependency.ErrorCode] = CODE;    zone: PUBLIC UNCOUNTED ZONE ¬ NIL;  cw: CARDINAL = WindowFont.CharWidth['M];  -- pixel width of char  ch: CARDINAL = WindowFont.FontHeight[];   -- pixel height of char   -- Graph instances  Handle: PUBLIC TYPE = LONG POINTER TO InstanceObject;  InstanceObject: PUBLIC TYPE = RECORD [    nodeCount, maxNodeCount: CARDINAL ¬ 0, -- max, actual # of nodes    node:		NodeList ¬ NIL,    labels:		DepName.Handle ¬ NIL,  -- node labels    c, p:		BitMatrix ¬ NIL,   -- conn, path matrices    cliqueList:		Clique ¬ NIL,      -- info. about each clique    fullHeight:		CARDINAL ¬ 0,      -- in full graph; (max level + 1)    fullWidth:		CARDINAL ¬ 0,      -- in full graph    -- set by PlaceNodes    nLevels:		CARDINAL ¬ 0,    levelList:		Level ¬ NIL,       -- info. about each level       xIndent, yIndent, maxWidth, maxHeight, yGap: CARDINAL ¬ 0,    minimizeWidth:	BOOLEAN ¬ FALSE,    nodeArray:	        NodeArray ¬ NIL]; -- Nodes  NodeList: TYPE = LONG POINTER TO NodeListSeq;  NodeListSeq: TYPE = RECORD [body: SEQUENCE size: NodeIndex OF NodeObject];  NodeIndex: TYPE = CARDINAL[0..LAST[CARDINAL]/SIZE[NodeObject]);  Lambda: NodeIndex = LAST[NodeIndex];	-- not a valid node  Node: PUBLIC TYPE = LONG POINTER TO NodeObject;  NodeObject: PUBLIC TYPE = RECORD [    name:	LONG STRING ¬ NIL, -- (unique) id for node's name    self:	CARDINAL ¬ 0,	   -- index of node; in [0..n)    indegree:	CARDINAL ¬ 0,	     supernode:	BOOLEAN ¬ FALSE,   -- represents clique (others marked ignore)    ignore:	BOOLEAN ¬ FALSE,   -- if removed since part of clique    tag:	BOOLEAN ¬ FALSE,   -- used by graph traversers    placed:	BOOLEAN ¬ FALSE,   -- T if placed by PlaceNodes    level:	CARDINAL ¬ 0,	     count:	CARDINAL ¬ 0,	   -- for topological sort    link:	CARDINAL ¬ 0,	   -- (NodeIndex) for topological sort queue    x, y:	CARDINAL ¬ 0,	   -- after PlaceNodes: center of placed node    height, width: CARDINAL ¬ 0,   -- after PlaceNodes: height, width of node    weightedX:	CARDINAL ¬ 0,    sumWeightedXPos: LONG CARDINAL ¬ 0,    sumWeights: CARDINAL ¬ 0]; -- Matrices  BitMatrix: TYPE = LONG POINTER TO BitRowSeq;  -- n*n elements  BitRowSeq: TYPE = RECORD [row: SEQUENCE COMPUTED BitRowIndex OF BitRow];  BitRowIndex: TYPE = CARDINAL[0..LAST[CARDINAL]/SIZE[BitRow]);  BitRow: TYPE = LONG POINTER TO BitSeq;  BitSeq: TYPE = RECORD [column: PACKED SEQUENCE COMPUTED CARDINAL OF BOOLEAN];   -- Levels within graph  Level: TYPE = LONG POINTER TO LevelSeq;  LevelSeq: TYPE = RECORD [body: SEQUENCE size: CARDINAL OF LevelRecord];  LevelRecord: TYPE = RECORD [    count:	 CARDINAL ¬ 0,    first, last: NodeIndex ¬ Lambda,    width:	 CARDINAL ¬ 0,  -- including internode gaps    height:	 CARDINAL ¬ 0,  -- max of node heights     scrunchedX, scrunchedY: BOOLEAN ¬ FALSE];     -- Supernode to clique table  Clique: TYPE = LONG POINTER TO CliqueRecord;  CliqueRecord: TYPE = RECORD [    next:	  Clique ¬ NIL,    superNode:    Node ¬ NIL,    domNodeCount: CARDINAL ¬ 0,    domNodeList:  DomNodeList ¬ NIL];  DomNodeList: TYPE = LONG POINTER TO DomNodeRecord;  DomNodeRecord: TYPE = RECORD [    next:    DomNodeList ¬ NIL,    domNode: Node ¬ NIL];       NodeArray: TYPE = LONG POINTER TO NodeArraySeq;  NodeArraySeq: TYPE = RECORD [SEQUENCE size: CARDINAL OF Node];      Initialize: PUBLIC PROC = {    IF zone = NIL THEN       zone ¬ Heap.Create[initial: 24, increment: 4, swapUnitSize: 4]};        Finalize: PUBLIC PROC = {    IF zone # NIL THEN Heap.Delete[zone];    zone ¬ NIL};    Create: PUBLIC PROC [maxNodeCount: CARDINAL] RETURNS [h: Handle] = {    i, j: CARDINAL;    IF zone = NIL THEN SIGNAL Error[initNotCalled];    h ¬ zone.NEW[InstanceObject ¬ [maxNodeCount: maxNodeCount]];     -- node and matrix initialization    h.node ¬ zone.NEW[NodeListSeq[maxNodeCount]];    FOR i IN [0..maxNodeCount) DO      h.node[i] ¬ NodeObject[];      h.node[i].self ¬ i;      ENDLOOP;    h.c ¬ zone.NEW[BitRowSeq[maxNodeCount]];    h.p ¬ zone.NEW[BitRowSeq[maxNodeCount]];    FOR i IN [0..maxNodeCount) DO      h.c[i] ¬ zone.NEW[BitSeq[maxNodeCount]];      h.p[i] ¬ zone.NEW[BitSeq[maxNodeCount]];      FOR j IN [0..maxNodeCount) DO        h.c[i][j] ¬ h.p[i][j] ¬ FALSE;	ENDLOOP;      ENDLOOP;    h.labels ¬ DepName.Create[maxNames: maxNodeCount, zone: zone]};  Destroy: PUBLIC PROC [h: Handle] RETURNS [nil: Handle] = {    IF h # NIL THEN {      -- nodes and matrices      IF h.node # NIL THEN zone.FREE[@h.node];      zone.FREE[@h.c];  zone.FREE[@h.p];      zone.FREE[@h.levelList];      zone.FREE[@h.nodeArray];      zone.FREE[@h];      RETURN[NIL]}};        RecordDependency: PUBLIC PROC [h: Handle, n1, n2: LONG STRING] = {    id1, id2: DepName.Id;    s1, s2: LONG STRING;    [id1, s1] ¬ DepName.Record[h.labels, n1 ! DepName.TooManyNames => GOTO cant];    [id2, s2] ¬ DepName.Record[h.labels, n2 ! DepName.TooManyNames => GOTO cant];    h.nodeCount ¬ MAX[h.nodeCount, id1, id2];    h.node[id1].name ¬ s1;  h.node[id2].name ¬ s2;    h.c[id1][id2] ¬ TRUE;    EXITS cant => SIGNAL Error[tooManyDependencies]};     -- Reduce graph: remove cliques and redundant arcs      ReduceGraph: PUBLIC PROC [      h: Handle, loopNodesProc: NodeProc ¬ NIL, cliqueProc: CliqueProc ¬ NIL] = {    m: BitMatrix ¬ NIL;    i, j, k: CARDINAL;    iIsInClique: BOOLEAN;        CreateCliqueGraph: PROC = {      m ¬ zone.NEW[BitRowSeq[h.maxNodeCount]];      FOR i IN [0..h.maxNodeCount) DO	m[i] ¬ zone.NEW[BitSeq[h.maxNodeCount]];	FOR j IN [0..h.maxNodeCount) DO m[i][j] ¬ FALSE ENDLOOP;	ENDLOOP};        DestroyCliqueGraph: PROC = {IF m # NIL THEN zone.FREE[@m]};          BEGIN ENABLE UNWIND => DestroyCliqueGraph[];    RemoveLoops[h, loopNodesProc];    ConstructPrecedenceGraph[h];    CreateCliqueGraph[];    -- find cliques by forming (p AND (p transpose)) in m    FOR i IN [0..h.nodeCount] DO      FOR j IN [0..h.nodeCount] DO        m[i][j] ¬ h.p[i][j] AND h.p[j][i];	ENDLOOP;      ENDLOOP;    -- collapse cliques to supernodes named by numerically first component node    FOR i IN [0..h.nodeCount] DO      IF h.node[i].ignore THEN LOOP;      iIsInClique ¬ FALSE;      FOR j IN [0..h.nodeCount] DO        IF m[i][j] THEN {iIsInClique ¬ TRUE;  EXIT};        ENDLOOP;      IF iIsInClique THEN {        h.node[i].supernode ¬ TRUE;  -- i will represent this clique        h.p[i][i] ¬ FALSE;        FOR j IN [(i+1)..h.nodeCount] DO          IF m[i][j] THEN {            ReportClique[h, i, j, cliqueProc];            h.node[j].ignore ¬ TRUE;	    FOR k IN [0..h.nodeCount] DO	      IF ~(k=j OR k=i OR h.node[k].ignore) THEN {	        IF h.c[k][j] THEN h.c[k][i] ¬ TRUE;   -- make k a predecessor of i	        IF h.c[j][k] THEN h.c[i][k] ¬ TRUE};  -- make k a successor of i	      h.c[j][k] ¬ h.p[j][k] ¬ h.c[k][j] ¬ h.p[k][j] ¬ FALSE;	      ENDLOOP};          ENDLOOP};      ENDLOOP;    DestroyCliqueGraph[];--  RemoveRedundantArcs[h];    ComputeNodeIndegree[h];    ComputeAllNodeLevels[h];  -- and h.fullHeight, h.fullWidth    -- set up quicksort array for nodes in each level; used by PlaceNodes    IF h.nodeArray # NIL THEN zone.FREE[@h.nodeArray];    h.nodeArray ¬ zone.NEW[NodeArraySeq[h.fullWidth]];    FOR i IN [0..h.fullWidth) DO h.nodeArray[i] ¬ NIL ENDLOOP;    END};      RemoveLoops: PROC [h: Handle, loopNodesProc: NodeProc] = {    FOR i: CARDINAL IN [0..h.nodeCount] DO      IF h.c[i][i] THEN {	IF loopNodesProc # NIL THEN loopNodesProc[@h.node[i]];	h.c[i][i] ¬ FALSE};      ENDLOOP};        ConstructPrecedenceGraph: PROC [h: Handle] = {    i, j: CARDINAL;    FOR i IN [0..h.nodeCount] DO      FOR j IN [0..h.nodeCount] DO        h.p[i][j] ¬ h.c[i][j];	ENDLOOP;      ENDLOOP;    FOR j IN [0..h.nodeCount] DO      FOR i IN [0..h.nodeCount] DO        IF h.p[i][j] THEN  -- i is a predecessor of j	  FOR k: CARDINAL IN [0..h.nodeCount] DO	    h.p[i][k] ¬ h.p[i][k] OR h.p[j][k];	    ENDLOOP;	ENDLOOP;      ENDLOOP};        ReportClique: PROC [h: Handle, super, dom: CARDINAL, cliqueProc: CliqueProc] = {    superNode: Node = @h.node[super];    domNode:   Node = @h.node[dom];    m: Clique;    d: DomNodeList;    IF cliqueProc # NIL THEN cliqueProc[superNode, domNode];    FOR m ¬ h.cliqueList, m.next UNTIL m = NIL DO      IF m.superNode = superNode THEN GOTO superNodeAlreadyThere;      REPEAT        superNodeAlreadyThere => NULL;        FINISHED => {	  -- insert new CliqueRecord at FRONT of list (better locality)	  m ¬ zone.NEW[CliqueRecord ¬ [next: h.cliqueList, superNode: superNode]];	  h.cliqueList ¬ m};      ENDLOOP;    -- now insert domNode into m's domNodeList    FOR d ¬ m.domNodeList, d.next UNTIL d = NIL DO      IF d.domNode = domNode THEN GOTO domNodeAlreadyThere;      REPEAT        domNodeAlreadyThere => NULL;	FINISHED => {	  d ¬ zone.NEW[DomNodeRecord ¬ [next: m.domNodeList, domNode: domNode]];	  m.domNodeList ¬ d;	  m.domNodeCount ¬ (m.domNodeCount + 1)};      ENDLOOP};    <<RemoveRedundantArcs: PROC [h: Handle] = {    i, j, k: CARDINAL;    FOR i IN [0..h.nodeCount] DO      IF h.node[i].ignore THEN LOOP;      FOR j IN [0..h.nodeCount] DO        IF h.node[j].ignore OR j=i THEN LOOP;	IF h.c[i][j] THEN   -- consider removing (i,j)	  FOR k IN [0..h.nodeCount] DO            IF h.node[k].ignore OR k=i OR k=j THEN LOOP;	    IF h.c[i][k] AND h.p[k][j] THEN {  -- there is longer path through k	      h.c[i][j] ¬ FALSE;  EXIT};	    ENDLOOP;	ENDLOOP;      ENDLOOP};>>   ComputeNodeIndegree: PROC [h: Handle] = {    i, j, jIndegree: CARDINAL;    FOR j IN [0..h.nodeCount] DO      IF h.node[j].ignore THEN LOOP;      jIndegree ¬ 0;      FOR i IN [0..h.nodeCount] DO        IF h.node[i].ignore THEN LOOP;	IF h.c[i][j] THEN jIndegree ¬ (jIndegree + 1);	ENDLOOP;      h.node[j].indegree ¬ jIndegree;      ENDLOOP};        ComputeAllNodeLevels: PROC [h: Handle] = {    IncludeAll: IncludeNodeProc = {RETURN[TRUE]};    h.fullHeight ¬ FullGraphHeight[h];    ComputeNodeLevels[h, IncludeAll];  -- this needs h.fullHeight    h.fullWidth ¬ 0;    FOR i: CARDINAL IN [0..h.fullHeight) DO      h.fullWidth ¬ MAX[h.levelList[i].count, h.fullWidth];      ENDLOOP};        FullGraphHeight: PROC [h: Handle] RETURNS [CARDINAL] = {    maxLevel: CARDINAL ¬ 0;    InitNode: NodeProc = {NARROW[n, Node].level ¬ 0};    PlaceSubGraphBelowRoot: NodeProc = {PlaceSubGraph[root: n, level: 0]};    PlaceSubGraph: PROC [root: Node, level: CARDINAL] = {      PlaceSon: NodeProc = {PlaceSubGraph[root: n, level: (level+1)]};      root.level ¬ MAX[root.level, level];       EnumSons[h, root, PlaceSon]};    CheckLevel: NodeProc = {maxLevel ¬ MAX[maxLevel, NARROW[n, Node].level]};    EnumNodes[h, InitNode];    EnumRoots[h, PlaceSubGraphBelowRoot];    EnumNodes[h, CheckLevel];    RETURN[maxLevel + 1]};  ComputeNodeLevels: PROC [h: Handle, includeNode: IncludeNodeProc] = {    InitNode: NodeProc = {      node: Node = NARROW[n, Node];      node.tag ¬ FALSE;  node.level ¬ 0};    EnterNodeIfDesired: NodeProc = {      IF includeNode[n] THEN PlaceSubGraph[root: n, level: 0]};    PlaceSubGraph: PROC [root: Node, level: CARDINAL] = {      ProcessDescendant: NodeProc = {PlaceSubGraph[root: n, level: (level+1)]};      root.tag ¬ TRUE;  root.level ¬ MAX[root.level, level];       EnumSons[h, root, ProcessDescendant]};    PlaceNodeIfTagged: NodeProc = {      node: Node = NARROW[n, Node];      IF node.tag THEN {  -- enter node n into its level        l: CARDINAL = node.level;	IF l >= h.fullHeight THEN SIGNAL Error[implementationError];	h.nLevels ¬ MAX[h.nLevels, (l + 1)];  -- node.level is 0 origin        h.levelList[l].count ¬ (h.levelList[l].count + 1);        IF h.levelList[l].first = Lambda THEN   -- root is first in list          h.levelList[l].first ¬ h.levelList[l].last ¬ node.self        ELSE {	  h.node[h.levelList[l].last].link ¬ node.self;	  h.levelList[l].last ¬ node.self};        h.node[h.levelList[l].last].link ¬ Lambda}};    h.nLevels ¬ 0;    -- set up level information    IF h.levelList # NIL THEN zone.FREE[@h.levelList];    h.levelList ¬ zone.NEW[LevelSeq[h.fullHeight]];    FOR i: CARDINAL IN [0..h.fullHeight) DO      h.levelList[i] ¬ LevelRecord[];      ENDLOOP;    -- now enter desired nodes (and descendents) into level sequence     EnumNodes[h, InitNode];    EnumNodes[h, EnterNodeIfDesired];    EnumNodes[h, PlaceNodeIfTagged]};       -- Topological sort   SortTopologically: PUBLIC PROC [h: Handle, proc: NodeProc] = {    i, j: CARDINAL;    -- queue of nodes with 0 count (all predecessors output) but not yet output    first, last: NodeIndex ¬ Lambda;    FOR i IN [0..h.nodeCount] DO      IF h.node[i].ignore THEN LOOP;      h.node[i].count ¬ h.node[i].indegree;      IF h.node[i].count = 0 THEN {        IF first = Lambda THEN first ¬ last ¬ i  -- first in queue	ELSE {h.node[last].link ¬ i;  last ¬ i};	h.node[last].link ¬ Lambda};      ENDLOOP;    WHILE first # Lambda DO      proc[@h.node[first]];      FOR j IN [0..h.nodeCount] DO        IF h.c[first][j] THEN {	  h.node[j].count ¬ h.node[j].count - 1;	  IF h.node[j].count = 0 THEN {  -- add to end of queue	    h.node[last].link ¬ j;  last ¬ j;  h.node[last].link ¬ Lambda}};	ENDLOOP;      first ¬ h.node[first].link;      ENDLOOP};       -- Graph inquiry        NodeCount: PUBLIC PROC [h: Handle] RETURNS [CARDINAL] = {    IF h = NIL THEN RETURN[0] ELSE RETURN[h.nodeCount]};      NodeName: PUBLIC PROC [n: Node] RETURNS [LONG STRING] = {RETURN[n.name]};      IsSuperNode: PUBLIC PROC [n: Node] RETURNS [BOOLEAN] = {RETURN[n.supernode]};  EnumRoots: PUBLIC PROC [h: Handle, proc: NodeProc] = {    IF h = NIL OR h.node = NIL THEN RETURN;    FOR i: CARDINAL IN [0..h.nodeCount] DO      IF h.node[i].ignore THEN LOOP;      IF h.node[i].indegree = 0 THEN proc[@h.node[i]];      ENDLOOP};      EnumNodes: PUBLIC PROC [h: Handle, proc: NodeProc] = {    IF h = NIL OR h.node = NIL THEN RETURN;    FOR i: CARDINAL IN [0..h.nodeCount] DO      IF h.node[i].ignore THEN LOOP;      proc[@h.node[i]];      ENDLOOP};      EnumParents: PUBLIC PROC [h: Handle, n: Node, proc: NodeProc] = {    ni: CARDINAL = n.self;    FOR i: CARDINAL IN [0..h.nodeCount] DO      IF h.node[i].ignore THEN LOOP;      IF h.c[i][ni] THEN proc[@h.node[i]];      ENDLOOP};      EnumAllParents: PUBLIC PROC [h: Handle, n: Node, proc: NodeProc] = {    EnumGraphAboveNode: NodeProc = {      proc[n];      EnumParents[h, n, EnumGraphAboveNode]};    EnumParents[h, n, EnumGraphAboveNode]};      EnumSons: PUBLIC PROC [h: Handle, n: Node, proc: NodeProc] = {    ni: CARDINAL = n.self;    FOR j: CARDINAL IN [0..h.nodeCount] DO      IF h.node[j].ignore THEN LOOP;      IF h.c[ni][j] THEN proc[@h.node[j]];      ENDLOOP};      EnumAllSons: PUBLIC PROC [h: Handle, n: Node, proc: NodeProc] = {    EnumGraphBelowNode: NodeProc = {      proc[n];      EnumSons[h, n, EnumGraphBelowNode]};    EnumSons[h, n, EnumGraphBelowNode]};        EnumNodesInClique: PUBLIC PROC [h: Handle, superNode: Node, proc: NodeProc] = {    FOR m: Clique ¬ h.cliqueList, m.next UNTIL m = NIL DO      IF m.superNode = superNode THEN {        FOR d: DomNodeList ¬ m.domNodeList, d.next UNTIL d = NIL DO	  proc[d.domNode];	  ENDLOOP;	RETURN};      ENDLOOP};     -- Node placement   PlaceNodes: PUBLIC PROC [      h: Handle, includeNode: IncludeNodeProc,      desiredWidth, desiredHeight: CARDINAL,  -- fit here if possible      minXGap, minYGap: CARDINAL] = {    nodesPlaced: BOOLEAN ¬ TRUE;    y, newY: CARDINAL;    ClearPlacedBit: NodeProc = {NARROW[n, Node].placed ¬ FALSE};    EnumNodes[h, ClearPlacedBit];    -- set up state    h.maxWidth ¬ h.maxHeight ¬ 0;    h.xIndent ¬ h.yIndent ¬ h.yGap ¬ 0;    h.minimizeWidth ¬ FALSE;    -- find all nodes in subgraph and enter into levels    ComputeNodeLevels[h, includeNode];    -- now do actual placement within levels    InitPlacement[h, includeNode, desiredWidth, desiredHeight, minXGap, minYGap];    y ¬ h.yIndent;    FOR level: CARDINAL IN [0..h.nLevels) DO      [nodesPlaced, newY] ¬ PlaceLevel[h, level, y, minXGap];      IF ~nodesPlaced THEN EXIT;      y ¬ newY;      ENDLOOP;    h.maxHeight ¬ (y - h.yIndent)};      InitPlacement: PROC [      h: Handle, includeNode: IncludeNodeProc,      desiredWidth, desiredHeight: CARDINAL,      minXGap, minYGap: CARDINAL] = {    maxNodeH, maxNodeW, sumMaxNodeH, count, l: CARDINAL;    InitNode: NodeProc = {       node: Node = NARROW[n, Node];      nodeName: LONG STRING = NodeName[node];      node.x ¬ node.y ¬ 0;      node.weightedX ¬ 0;  node.sumWeightedXPos ¬ 0;  node.sumWeights ¬ 0;      IF node.supernode THEN { -- find count and max width of all nodes in clique        c: CARDINAL ¬ 1;        maxLen: CARDINAL ¬ nodeName.length;	NoteDomNode: NodeProc = {	  maxLen ¬ MAX[maxLen, NodeName[n].length];  c ¬ c + 1};	EnumNodesInClique[h, node, NoteDomNode];	node.width ¬ cw*maxLen+4;  node.height ¬ c*ch + (c-1)*2 + 4}      ELSE {node.width ¬ cw*nodeName.length+4;  node.height ¬ ch+4};         maxNodeW ¬ MAX[node.width, maxNodeW];      maxNodeH ¬ MAX[node.height, maxNodeH]};        -- see how wide the widest level is    -- also compute sum of level heights, for yGap computation    h.maxWidth ¬ 0;  sumMaxNodeH ¬ 0;      FOR l IN [0..h.nLevels) DO      count ¬ h.levelList[l].count;      maxNodeW ¬ maxNodeH ¬ 0;      EnumOneLevel[h, l, InitNode];      sumMaxNodeH ¬ (sumMaxNodeH + maxNodeH);      h.levelList[l].height ¬ maxNodeH;      h.levelList[l].width  ¬ count*maxNodeW + (count-1)*minXGap;      h.maxWidth ¬ MAX[h.maxWidth, h.levelList[l].width];       ENDLOOP;    -- see if to minimize graph width and recompute h.maxWidth accordingly    IF h.maxWidth <= desiredWidth THEN {  -- graph fits in visible area      h.minimizeWidth ¬ FALSE;      h.xIndent ¬ (desiredWidth - h.maxWidth)/2}    ELSE {  -- scrunch widest level(s)      newMaxWidth: CARDINAL ¬ 0;      MinimizeNodeWidth: NodeProc = {        h.levelList[l].width ¬ (h.levelList[l].width + (	  NARROW[n, Node].width + minXGap))};      h.minimizeWidth ¬ TRUE;      h.xIndent ¬ 2;  -- avoid running into window LHS      FOR l IN [0..h.nLevels) DO        IF h.levelList[l].width = h.maxWidth THEN {  -- scrunch this level          h.levelList[l].scrunchedX ¬ TRUE;          h.levelList[l].width ¬ 0;          EnumOneLevel[h, l, MinimizeNodeWidth];          h.levelList[l].width ¬ (h.levelList[l].width - minXGap); -- 1 too many          newMaxWidth ¬ MAX[newMaxWidth, h.levelList[l].width]}	ELSE newMaxWidth ¬ MAX[newMaxWidth, h.levelList[l].width];         ENDLOOP;      h.maxWidth ¬ newMaxWidth};    -- now compute yGap    IF (sumMaxNodeH + (h.nLevels-1)*minYGap) >= desiredHeight THEN        h.yGap ¬ minYGap  -- scrunch graph in vertical direction    ELSE {       h.yGap ¬ (desiredHeight - sumMaxNodeH)/MAX[1, h.nLevels-1];      h.yGap ¬ MIN[h.yGap, (5 * minYGap)/3]};  -- don't make too large    -- set y indention    h.yIndent ¬ h.yGap/2};      PlaceLevel: PROC [        h: Handle, level, y, minXGap: CARDINAL]      RETURNS [nodesPlaced: BOOLEAN, newY: CARDINAL] = {    levCount: CARDINAL = h.levelList[level].count;    levWidth: CARDINAL = h.levelList[level].width;    wideLevel: BOOLEAN = (~h.minimizeWidth OR ~h.levelList[level].scrunchedX);    nodesPlaced ¬ FALSE;  newY ¬ 0;    BEGIN  -- update weightedXs for level      c: CARDINAL ¬ 0;      UpdateRelativePlace: NodeProc = {	node: Node = NARROW[n, Node];	nodesPlaced ¬ TRUE;	h.nodeArray[c] ¬ n;  c ¬ c+1;	node.weightedX ¬ ( 	  IF node.sumWeights = 0 THEN 1	  ELSE CARDINAL[node.sumWeightedXPos/node.sumWeights])};      EnumOneLevel[h, level, UpdateRelativePlace];      IF ~nodesPlaced THEN RETURN;    END;    BEGIN  -- sort by the weightedX (a constraint) computed so far      Compare: QuickSort.CompareProc = {	SELECT h.nodeArray[one].weightedX FROM	  < h.nodeArray[two].weightedX => RETURN[smaller];	  > h.nodeArray[two].weightedX => RETURN[bigger];	  ENDCASE;	SELECT String.Compare[h.nodeArray[one].name, h.nodeArray[two].name] FROM	  -1 => RETURN[smaller];	  +1 => RETURN[bigger];	  ENDCASE => RETURN[same]};      Swap: QuickSort.SwapProc = {	t: Node = h.nodeArray[one];	h.nodeArray[one] ¬ h.nodeArray[two];  h.nodeArray[two] ¬ t};      QuickSort.Sort[        min: 0, max: (levCount - 1), compare: Compare, swap: Swap, data: NIL];    END;    BEGIN  -- place nodes in level by sorted weightedX      boxX: CARDINAL ¬ h.maxWidth/levCount;  -- node width if wideLevel      boxY: CARDINAL = h.levelList[level].height;  -- node height      skinnyGap, x: CARDINAL;      PlaceOneNode: NodeProc = {	node: Node = NARROW[n, Node];	width: CARDINAL = (IF wideLevel THEN boxX ELSE (node.width + skinnyGap)); 	node.placed ¬ TRUE;	node.x ¬ (x + (width+1)/2);  node.y ¬ (y + (boxY+1)/2);	IF h.levelList[level].first = Lambda THEN   -- root is now first in level	  h.levelList[level].first ¬ h.levelList[level].last ¬ node.self	ELSE {	  h.node[ h.levelList[level].last ].link ¬ node.self;	  h.levelList[level].last ¬ node.self};	  h.node[ h.levelList[level].last ].link ¬ Lambda;	UpdatePlacementOfChildren[node];	x ¬ (x + width)};      UpdatePlacementOfChildren: PROC [parent: Node] = {	UpdateChildsPlacement: NodeProc = {	  node: Node = NARROW[n, Node];	  delta: CARDINAL;	  delta ¬ (node.level - parent.level);	  node.sumWeightedXPos ¬ (node.sumWeightedXPos + delta*parent.x);	  node.sumWeights ¬ (node.sumWeights + delta)};      EnumSons[h, parent, UpdateChildsPlacement]};      IF ~wideLevel THEN {	skinnyGap ¬ minXGap;	IF levWidth < h.maxWidth THEN {	  skinnyGap ¬ (minXGap + (h.maxWidth-levWidth)/(levCount+1));	  h.levelList[level].width ¬ h.maxWidth}};      h.levelList[level].first ¬ h.levelList[level].last ¬ Lambda;      x ¬ h.xIndent;      FOR i: CARDINAL IN [0..levCount) DO PlaceOneNode[h.nodeArray[i]] ENDLOOP;      newY ¬ (y + boxY + h.yGap);    END;    RETURN[nodesPlaced, newY]};      PlacedXMax: PUBLIC PROC [h: Handle] RETURNS [CARDINAL] = {    RETURN[h.maxWidth + h.xIndent]};      PlacedYMax: PUBLIC PROC [h: Handle] RETURNS [CARDINAL] = {    RETURN[h.maxHeight + h.yIndent]};  EnumPlacedSons: PUBLIC PROC [h: Handle, n: Node, proc: NodeProc] = {    ni: CARDINAL = n.self;    FOR j: CARDINAL IN [0..h.nodeCount] DO      IF h.node[j].ignore OR ~h.node[j].placed THEN LOOP;      IF h.c[ni][j] THEN proc[@h.node[j]];      ENDLOOP};  EnumPlacedParents: PUBLIC PROC [h: Handle, n: Node, proc: NodeProc] = {    ni: CARDINAL = n.self;    FOR j: CARDINAL IN [0..h.nodeCount] DO      IF h.node[j].ignore OR ~h.node[j].placed THEN LOOP;      IF h.c[j][ni] THEN proc[@h.node[j]];      ENDLOOP};      LevelCount: PUBLIC PROC [h: Handle] RETURNS [CARDINAL] = {RETURN[h.nLevels]};        NodeCountInLevel: PUBLIC PROC [      h: Handle, level: CARDINAL] RETURNS [count: CARDINAL] = {    IF h.levelList = NIL THEN RETURN[0];      RETURN[h.levelList[level].count]};        EnumOneLevel: PUBLIC PROC [h: Handle, level: CARDINAL, proc: NodeProc] = {    IF h.levelList = NIL THEN RETURN;    FOR i: NodeIndex ¬ h.levelList[level].first, h.node[i].link    UNTIL i = Lambda DO      proc[@h.node[i]];      ENDLOOP};  X: PUBLIC PROC [n: Node] RETURNS [CARDINAL] = {RETURN[n.x]};  Y: PUBLIC PROC [n: Node] RETURNS [CARDINAL] = {RETURN[n.y]};  Height: PUBLIC PROC [n: Node] RETURNS [CARDINAL] = {RETURN[n.height]};  Width: PUBLIC PROC [n: Node] RETURNS [CARDINAL] = {RETURN[n.width]};  Bottom: PUBLIC PROC [n: Node] RETURNS [CARDINAL] = {RETURN[n.y + n.height/2]};  Top: PUBLIC PROC [n: Node] RETURNS [CARDINAL] = {    RETURN[IF n.y > n.height/2 THEN (n.y - n.height/2) ELSE 0]};  Left: PUBLIC PROC [n: Node] RETURNS [CARDINAL] = {    RETURN[IF n.x > n.width/2 THEN (n.x - n.width/2) ELSE 0]};  Right: PUBLIC PROC [n: Node] RETURNS [CARDINAL] = {RETURN[n.x + n.width/2]};  UpdateX: PUBLIC PROC [n: Node, x: CARDINAL] = {n.x ¬ x};  UpdateY: PUBLIC PROC [n: Node, y: CARDINAL] = {n.y ¬ y};      END.
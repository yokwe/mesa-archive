-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- DepSWImpl.mesa - Last edited by--   Lewis	20-Jan-84 17:00:30--   Keith	15-Mar-84 13:36:40--   AO 	28-Dec-84 10:49:49DIRECTORY  Atom USING [ATOM, MakeAtom],  BitBlt USING [BitBltFlags, DstFunc],  Context USING [Create, Data, Find, Type, UniqueType],  Dependency USING [    Bottom, EnumNodesInClique, EnumOneLevel, EnumPlacedParents, EnumPlacedSons,    Error, Handle, Height, IsSuperNode, Left, LevelCount, Node, NodeName,     NodeProc, PlacedXMax, PlacedYMax, Right, Top, UpdateX, UpdateY, Width, X,     Y, zone],  Display USING [    BitBltFlags, Black, DstFunc, Gray, Handle, paintGrayFlags, replaceFlags,    Shift, Text, White, xorGrayFlags],  Heap USING [systemZone],  Inline USING [LongMult, LowHalf],  Scrollbar USING [Create, Percent, ScrollbarProcType, ScrollProcType, Type],  Selection USING [ActOnProcType, ConvertProcType, Set],  SpecialDisplay USING [Handle, LineStyleObject, SpecialLine],  String USING [CopyToNewString],  TIP USING [    CreateClient, CreateTable, DestroyClient, First, InvalidTable, NotifyProc,    Rest, Results, SetNotifyProc, Table],  Tool USING [AddThisSW, RegisterSWType, SWType],  ToolWindow USING [AdjustProcType, Box, CreateSubwindow, WindowForSubwindow],  UserInput USING [ClearInputFocusOnMatch, SetInputFocus],  UserTerminal USING [BlinkDisplay],  Window USING [    Box, Dims, GetBox, Handle, InvalidateBox, Place, SetDisplayProc, Validate],  WindowFont USING [CharWidth, defaultFont, FontHeight],  WindowOps USING [GetBpl]; DepSWImpl: MONITOR LOCKS data USING data: Data    IMPORTS      Atom, Context, Dependency, Display, Heap, Inline, Scrollbar, Selection,      SpecialDisplay, String, TIP, Tool, ToolWindow, UserInput, UserTerminal,      Window, WindowFont, WindowOps    EXPORTS Dependency =  BEGIN  mySWType: Tool.SWType ¬ Tool.RegisterSWType[adjust: Adjust];  dep: Context.Type = Context.UniqueType[];  Data: TYPE = LONG POINTER TO DataObject;  DataObject: TYPE = MONITORED RECORD [    depSW: Window.Handle ¬ NIL,  -- sw with which this context is associated    dep: Dependency.Handle ¬ NIL,    xOffset, yOffset: NAT ¬ 0,   -- ul point of viewport on graph plane    selNode: Dependency.Node ¬ NIL,    doingMove: BOOLEAN ¬ FALSE,    trackedUL, trackedLR: Window.Place ¬ [0,0]];      selectOrFinishMove, simpleSelect, startMove, track, jumpToBeginning: Atom.ATOM;  border: CARDINAL = 2;  Shade: TYPE = {black, white, gray};  Arrowhead: TYPE = {top, bottom, left, right};  cw: CARDINAL = WindowFont.CharWidth['M];  -- pixel width of char  ch: CARDINAL = WindowFont.FontHeight[];   -- pixel height of char   -- Utilities	  LocalFind: PROC [sw: Window.Handle] RETURNS [data: Data] = INLINE {    data ¬ Context.Find[dep, sw];    IF data = NIL THEN SIGNAL Dependency.Error[notADepSW]};      Box: PROC [sw: Window.Handle] RETURNS [Window.Box] = INLINE {    RETURN[ [[0, 0], sw.GetBox[].dims] ]};      NodeBox: PROC [node: Dependency.Node] RETURNS [Window.Box] = {    RETURN[[      [x: Dependency.Left[node], y: Dependency.Top[node]],      [w: Dependency.Width[node], h: Dependency.Height[node]]]]};    ScreenXFor: PROC [virtualX: CARDINAL, data: Data] RETURNS [realX: INTEGER] = {    RETURN[INTEGER[virtualX] - data.xOffset]};    ScreenYFor: PROC [virtualY: CARDINAL, data: Data] RETURNS [realY: INTEGER] = {    RETURN[INTEGER[virtualY] - data.yOffset]};    VirtualXFor: PROC [realX: CARDINAL, data: Data] RETURNS [virtualX: CARDINAL] = {    RETURN[realX + data.xOffset]};    VirtualYFor: PROC [realY: CARDINAL, data: Data] RETURNS [virtualY: CARDINAL] = {    RETURN[realY + data.yOffset]};     -- Creation and destruction    MakeDepSW: PUBLIC PROC [window: Window.Handle] RETURNS [sw: Window.Handle] = {    data: Data;    myTIP: TIP.Table;    sw ¬ ToolWindow.CreateSubwindow[parent: window, display: DisplayProc];    Tool.AddThisSW[window: window, sw: sw, swType: mySWType];    data ¬ Dependency.zone.NEW[DataObject ¬ [depSW: sw]];    Context.Create[type: dep, data: data, proc: DestroyContext, window: sw];    Scrollbar.Create[      window: sw, type: vertical,      scroll: ScrollVertical, scrollbar: VerticalScrollbarInfo];     Scrollbar.Create[      window: sw, type: horizontal,      scroll: ScrollHorizontal, scrollbar: HorizontalScrollbarInfo];    myTIP ¬ TIP.CreateTable[      file: "DepSW.TIP"L,      contents: "-- DepSW.TIP  Last edited 15-Mar-84 10:26:48SELECT TRIGGER FROM  Point Down =>     SELECT ENABLE FROM      COPY Down => COORDS, simpleSelect;      ENDCASE => COORDS, selectOrFinishMove;  MOVE Down => startMove;  MOUSE => COORDS, track;  JFIRST Down => jumpToBeginning;  ENDCASE..."L      ! TIP.InvalidTable => RESUME];    TIP.CreateClient[window: sw, table: myTIP, notify: TIPNotify]};    DisplayGraph: PUBLIC PROC [h: Dependency.Handle, sw: Window.Handle] = {    LockedDisplay: ENTRY PROC [data: Data] = {      ENABLE UNWIND => NULL;      IF data.dep # NIL THEN SIGNAL Dependency.Error[depSWNotReset];      data.dep ¬ h;      data.xOffset ¬ data.yOffset ¬ 0;      data.selNode ¬ NIL;  data.doingMove ¬ FALSE;      data.trackedUL ¬ data.trackedLR ¬ [0,0];      Window.InvalidateBox[window: sw, box: Box[sw]]};    LockedDisplay[LocalFind[sw]];    sw.Validate[]};  ResetDepSW: PUBLIC PROC [sw: Window.Handle] = {    LockedReset: ENTRY PROC [data: Data] = {      ENABLE UNWIND => NULL;      Reset[sw, data]};    LockedReset[LocalFind[sw]]};      Reset: PROC [sw: Window.Handle, data: Data] = {    UserInput.ClearInputFocusOnMatch[sw];    Display.White[sw, Box[sw]];    data.dep ¬ NIL;    data.xOffset ¬ data.yOffset ¬ 0;    data.selNode ¬ NIL;  data.doingMove ¬ FALSE;    data.trackedUL ¬ data.trackedLR ¬ [0,0]};      DestroyContext: PROC [contextData: Data, sw: Window.Handle] = {    LockedDestroy: ENTRY PROC [data: Data] = {      ENABLE UNWIND => NULL;      Reset[sw, data];      [] ¬ Window.SetDisplayProc[sw, NIL];      [] ¬ TIP.SetNotifyProc[sw, NIL];      TIP.DestroyClient[sw]};    LockedDestroy[LocalFind[sw]];    Dependency.zone.FREE[@contextData]};  -- is this OK here?      Adjust: ToolWindow.AdjustProcType = {    sw: Window.Handle = window;    IF when = after THEN Window.InvalidateBox[window: sw, box: Box[sw]]};  DisplayProc: PROC [sw: Window.Handle] = {    LockedDisplay: ENTRY PROC [data: Data] = {      ENABLE UNWIND => NULL;      lc, l: CARDINAL;      DrawOneNode: Dependency.NodeProc = {	DrawNode[	  data: data, node: n,	  fillColor: IF n = data.selNode THEN gray ELSE black]};      DrawArcsOfNode: Dependency.NodeProc = {        DrawArcsFrom[data: data, node: n, color: black]};      Display.White[window: sw, box: Box[sw]];      IF data.dep = NIL THEN RETURN;      lc ¬ data.dep.LevelCount[];      FOR l IN [0..lc) DO	data.dep.EnumOneLevel[l, DrawOneNode];	ENDLOOP;      FOR l IN [0..lc) DO	data.dep.EnumOneLevel[l, DrawArcsOfNode];	ENDLOOP};    LockedDisplay[LocalFind[sw]]};      DrawNode: PROC [data: Data, node: Dependency.Node, fillColor: Shade] = {    label: LONG STRING = Dependency.NodeName[node];    labelWidth: CARDINAL ¬ (label.length * cw);    labelY: CARDINAL ¬ (Dependency.Top[node] + border);       labelX: CARDINAL;    DrawNodeBox[data, node, fillColor];    IF Dependency.IsSuperNode[node] THEN {      DrawDomName: Dependency.NodeProc = {	domName: LONG STRING = Dependency.NodeName[n];	labelWidth ¬ (domName.length * cw);	labelX ¬ (Dependency.X[node] - labelWidth/2);	labelY ¬ (labelY + (ch+2));	Text[data, domName, [labelX, labelY]]};      labelX ¬ (Dependency.X[node] - labelWidth/2);      Text[data, label, [labelX, labelY]];      data.dep.EnumNodesInClique[node, DrawDomName]}    ELSE {      labelX ¬ (Dependency.X[node] - labelWidth/2);      Text[data, label, [labelX, labelY]]}};      DrawNodeBox: PROC [      data: Data, node: Dependency.Node,      fillColor: Shade, dstFunc: BitBlt.DstFunc ¬ or] = {    left:   CARDINAL = Dependency.Left[node];    right:  CARDINAL = (Dependency.Right[node] - 1);  -- one bit left for border    top:    CARDINAL = Dependency.Top[node];    bottom: CARDINAL = (Dependency.Bottom[node] - 1); -- one bit up for border    ul: Window.Place = [x: left,  y: top];    ll: Window.Place = [x: left,  y: bottom];    lr: Window.Place = [x: right, y: bottom];    ur: Window.Place = [x: right, y: top];    -- fill interior    SELECT fillColor FROM      white => White[data, NodeBox[node]];      gray  => Gray[data, NodeBox[node], dstFunc];      ENDCASE;    -- draw border     Line[data, ul, ll, black, dstFunc];  Line[data, ll, lr, black, dstFunc];    Line[data, lr, ur, black, dstFunc];  Line[data, ur, ul, black, dstFunc]};      DrawArcsFrom: PROC [      data: Data, node: Dependency.Node,      color: Shade, dstFunc: BitBlt.DstFunc ¬ or] = {    DrawArcToSon: Dependency.NodeProc = {      DrawArcBetween[data, node, n, color, dstFunc]};    data.dep.EnumPlacedSons[node, DrawArcToSon]};      DrawArcsTo: PROC [      data: Data, node: Dependency.Node,      color: Shade, dstFunc: BitBlt.DstFunc ¬ or] = {    DrawArcToParent: Dependency.NodeProc = {      DrawArcBetween[data, n, node, color, dstFunc]};    data.dep.EnumPlacedParents[node, DrawArcToParent]};  DrawArcBetween: PROC [      data: Data, parent, child: Dependency.Node,      color: Shade, dstFunc: BitBlt.DstFunc ¬ or] = {        (IF ABS[INTEGER[Dependency.Y[parent]] - INTEGER[Dependency.Y[child]]] >         ABS[INTEGER[Dependency.X[parent]] - INTEGER[Dependency.X[child]]]       THEN DrawArcBetweenVertical      ELSE DrawArcBetweenHorizontal)[data, parent, child, color, dstFunc]};        DrawArcBetweenHorizontal: PROC [      data: Data, parent, child: Dependency.Node,      color: Shade, dstFunc: BitBlt.DstFunc] = {     left: Dependency.Node = (      IF Dependency.X[parent] < Dependency.X[child] THEN parent ELSE child);    right: Dependency.Node = (IF left = parent THEN child ELSE parent);    rightLeft: CARDINAL = Dependency.Left[right];    leftY: CARDINAL = Dependency.Y[left];    rightY: CARDINAL ¬ Dependency.Y[right];    -- avoid jagged near-horizontal lines    IF (MAX[leftY, rightY] - MIN[leftY, rightY]) <= 2 THEN rightY ¬ leftY;    Line[      data: data, color: color, dstFunc: dstFunc, thickness: 2,      start: [Dependency.Right[left], leftY], stop: [rightLeft, rightY]];    IF dstFunc = or THEN DrawArrowhead[      data, child, color, IF child = left THEN right ELSE left]};  DrawArcBetweenVertical: PROC [      data: Data, parent, child: Dependency.Node,      color: Shade, dstFunc: BitBlt.DstFunc] = {     upper: Dependency.Node = (      IF Dependency.Y[parent] < Dependency.Y[child] THEN parent ELSE child);    lower: Dependency.Node = (IF upper = parent THEN child ELSE parent);    lowerTop: CARDINAL = Dependency.Top[lower];    upperX: CARDINAL = Dependency.X[upper];    lowerX: CARDINAL ¬ Dependency.X[lower];    -- avoid jagged near-vertical lines    IF (MAX[lowerX, upperX] - MIN[lowerX, upperX]) <= 2 THEN lowerX ¬ upperX;    Line[      data: data, color: color, dstFunc: dstFunc, thickness: 2,      start: [upperX, Dependency.Bottom[upper]], stop: [lowerX, lowerTop]];    IF dstFunc = or THEN DrawArrowhead[      data, child, color, IF child = upper THEN bottom ELSE top]};      DrawArrowhead: PROC [    data: Data, node: Dependency.Node, color: Shade, head: Arrowhead] = {    box: Window.Box;    box.dims ¬ SELECT head FROM      top, bottom => [w: 6, h: 3], ENDCASE -- left, right -- => [w: 3, h: 6];    box.place ¬ SELECT head FROM      top => [x: Dependency.X[node] - 2, y: Dependency.Top[node] - 2],      bottom => [x: Dependency.X[node] - 2, y: Dependency.Bottom[node]],      left => [x: Dependency.Left[node] - 2, y: Dependency.Y[node] - 2],      ENDCASE -- right -- => [        x: Dependency.Right[node], y: Dependency.Y[node] - 2];    SELECT color FROM      black => Black[data, box]; white => White[data, box]; ENDCASE}; 	 -- Graphics primitives (do virtual-to-screen coordinate transformations)  Text: PROC [data: Data, string: LONG STRING, place: Window.Place] = {    [] ¬ Display.Text[      window: data.depSW, string: string, font: WindowFont.defaultFont,       place: [ScreenXFor[place.x, data], ScreenYFor[place.y, data]],      flags: Display.replaceFlags]};      mySolidLine: SpecialDisplay.LineStyleObject ¬ [    widths: [0, 0, 0, 0, 0, 0], thickness: 1];  Line: PROC [      data: Data, start, stop: Window.Place, color: Shade ¬ black,      dstFunc: BitBlt.DstFunc ¬ or, thickness: CARDINAL ¬ 1] = {    flags: BitBlt.BitBltFlags;    SELECT color FROM      gray, black => flags ¬ (        IF dstFunc = or THEN Display.paintGrayFlags ELSE Display.xorGrayFlags);      white => flags ¬ Display.xorGrayFlags;      ENDCASE;    mySolidLine.thickness ¬ thickness;    mySolidLine.widths[0] ¬ WindowOps.GetBpl[LOOPHOLE[data.depSW]];    SpecialDisplay.SpecialLine[      window: data.depSW, bounds: NIL, dashes: @mySolidLine, flags: flags,      start: [ScreenXFor[start.x, data], ScreenYFor[start.y, data]],      stop:  [ScreenXFor[stop.x, data],  ScreenYFor[stop.y, data]]]};    Gray: PROC [      data: Data, box: Window.Box, dstFunc: BitBlt.DstFunc ¬ null] = {    Display.Gray[      window: data.depSW, dstFunc: dstFunc,      box: [        [ScreenXFor[box.place.x, data], ScreenYFor[box.place.y, data]],	box.dims]]};      Black: PROC [data: Data, box: Window.Box] = {    Display.Black[      window: data.depSW,      box: [        [ScreenXFor[box.place.x, data], ScreenYFor[box.place.y, data]],	box.dims]]};      White: PROC [data: Data, box: Window.Box] = {    Display.White[      window: data.depSW,      box: [[ScreenXFor[box.place.x, data], ScreenYFor[box.place.y, data]],      box.dims]]};   -- Window scrolling (assertion: td.*Offset >= 0 AND <= td.*Max)   ScrollVertical: Scrollbar.ScrollProcType = {    LockedScrollV: ENTRY PROC [data: Data] RETURNS [scroll: BOOLEAN] = {      ENABLE UNWIND => NULL;      dims: Window.Dims = window.GetBox[].dims;      yMax: CARDINAL;      shift: INTEGER;      IF data.dep = NIL THEN RETURN[FALSE];      yMax ¬ data.dep.PlacedYMax[];      shift ¬        SELECT direction FROM	  relative => PercentOf[yMax, percent] - data.yOffset,	  backward => -MIN[data.yOffset, PercentOf[dims.h, percent]], 	  forward  => +MIN[(yMax - data.yOffset), PercentOf[dims.h, percent]], 	  ENDCASE  => ERROR;      IF shift # 0 THEN {        data.yOffset ¬ (data.yOffset + shift);	Display.Shift[window: window, box: [[0,shift], dims], newPlace: [0,0]];	RETURN[TRUE]}      ELSE RETURN[FALSE]};    IF LockedScrollV[LocalFind[window]] THEN window.Validate[]};   VerticalScrollbarInfo: Scrollbar.ScrollbarProcType = {    LockedVScrollbar: ENTRY PROC [data: Data]      RETURNS [        box: Window.Box, offset: Scrollbar.Percent,         portion: Scrollbar.Percent] = {      ENABLE UNWIND => NULL;      dims: Window.Dims = window.GetBox[].dims;      yMax, screenPortion: INTEGER;      IF data.dep = NIL THEN        RETURN[box: [[x: 0, y: 0], dims], offset: 0, portion: 1];      yMax ¬ data.dep.PlacedYMax[];      IF yMax = 0 THEN        RETURN[box: [[x: 0, y: 0], dims], offset: 0, portion: 1];      offset ¬ FindPercent[data.yOffset, yMax];      screenPortion ¬ (	IF yMax >= (data.yOffset + dims.h) THEN dims.h	ELSE yMax - data.yOffset);  -- last portion is visible      portion ¬ FindPercent[MIN[yMax, screenPortion], yMax];      RETURN[box: [[x: 0, y: 0], dims], offset: offset, portion: portion]};    RETURN LockedVScrollbar[LocalFind[window]]};   ScrollHorizontal: Scrollbar.ScrollProcType = {    LockedScrollH: ENTRY PROC [data: Data] RETURNS [scroll: BOOLEAN] = {      ENABLE UNWIND => NULL;      dims: Window.Dims = window.GetBox[].dims;      xMax: CARDINAL;      shift: INTEGER;      IF data.dep = NIL THEN RETURN[FALSE];      xMax ¬ data.dep.PlacedXMax[];      shift ¬        SELECT direction FROM	  relative => PercentOf[xMax, percent] - data.xOffset,	  backward => -MIN[data.xOffset, PercentOf[dims.w, percent]], 	  forward  => +MIN[(xMax - data.xOffset), PercentOf[dims.w, percent]], 	  ENDCASE  => ERROR;      IF shift # 0 THEN {	data.xOffset ¬ (data.xOffset + shift);	Display.Shift[	  window: data.depSW, box: [[shift,0], dims], newPlace: [0,0]];	RETURN[TRUE]}      ELSE RETURN[FALSE]};    IF LockedScrollH[LocalFind[window]] THEN window.Validate[]};   HorizontalScrollbarInfo: Scrollbar.ScrollbarProcType = {    LockedHScrollbar: ENTRY PROC [data: Data]      RETURNS [        box: Window.Box, offset: Scrollbar.Percent,         portion: Scrollbar.Percent] = {      ENABLE UNWIND => NULL;      dims: Window.Dims = window.GetBox[].dims;      xMax, screenPortion: INTEGER;      IF data.dep = NIL THEN        RETURN[box: [[x: 0, y: 0], dims], offset: 0, portion: 1];      xMax ¬ data.dep.PlacedXMax[];      IF xMax = 0 THEN        RETURN[box: [[x: 0, y: 0], dims], offset: 0, portion: 1];      offset ¬ FindPercent[data.xOffset, xMax];      screenPortion ¬ (	IF xMax >= (data.xOffset + dims.w) THEN dims.w	ELSE xMax - data.xOffset);  -- last portion is visible      portion ¬ FindPercent[MIN[xMax, screenPortion], xMax];      RETURN[box: [[x: 0, y: 0], dims], offset: offset, portion: portion]};    RETURN LockedHScrollbar[LocalFind[window]]};      FindPercent: PROC [num, den: INTEGER] RETURNS [Scrollbar.Percent] = INLINE {    RETURN[Inline.LowHalf[Inline.LongMult[100, num]/den]]};  PercentOf: PROC [val: INTEGER, percent: Scrollbar.Percent] RETURNS [INTEGER] =    INLINE {RETURN[Inline.LowHalf[Inline.LongMult[percent, val]/100]]};     -- TIP table and selection management    TIPNotify: TIP.NotifyProc = {    data: Data = LocalFind[window];    place: Window.Place ¬ [0, 0];    IF data.dep = NIL THEN RETURN;    FOR r: TIP.Results ¬ results, r.Rest UNTIL r = NIL DO      WITH z: r.First SELECT FROM	coords => place ¬ ClipMouse[z.place, data];	atom => SELECT z.a FROM	  selectOrFinishMove => { 	    IF data.doingMove THEN FinishMove[data]	    ELSE SelectNode[place, data, TRUE]};	  simpleSelect => SelectNode[place, data, FALSE];  	  startMove => StartMove[data];	  track => IF data.doingMove THEN Track[place, data];	  jumpToBeginning => IF ~data.doingMove THEN JumpToBeginning[data]; 	  ENDCASE;	ENDCASE;      ENDLOOP};        ClipMouse: PROC [      place: Window.Place, data: Data] RETURNS [clipped: Window.Place] = {    dims: Window.Dims = data.depSW.GetBox[].dims;    clipped ¬ place;    clipped.x ¬ MAX[clipped.x, 0];    clipped.x ¬ MIN[clipped.x, (dims.w - 1)];    clipped.y ¬ MAX[clipped.y, 0];    clipped.y ¬ MIN[clipped.y, (dims.h - 1)]};    SelectNode: PROC [place: Window.Place, data: Data, takeInsertion: BOOLEAN] = {    LockedSelect: ENTRY PROC [data: Data] = {      ENABLE UNWIND => NULL;      sel: Dependency.Node ¬ NIL;      lc: CARDINAL = data.dep.LevelCount[];      SeeIfSelected: Dependency.NodeProc = {  -- only if inside node's outline        vx: NAT = VirtualXFor[place.x, data];        vy: NAT = VirtualYFor[place.y, data];	IF sel # NIL THEN RETURN;	IF vx < Dependency.Left[n] OR vx > Dependency.Right[n] THEN RETURN;	IF vy < Dependency.Top[n] OR vy > Dependency.Bottom[n] THEN RETURN;	sel ¬ n};      FOR l: CARDINAL IN [0..lc) WHILE sel = NIL DO	data.dep.EnumOneLevel[l, SeeIfSelected];	ENDLOOP;      SetSelection[sel, data, takeInsertion];      data.doingMove ¬ FALSE};    LockedSelect[data]};    ClearSelection: INTERNAL PROC [data: Data] = {    IF data.selNode # NIL THEN {      DrawNode[data, data.selNode, white]; data.selNode ¬ NIL}};    SetSelection: INTERNAL PROC [    sel: Dependency.Node, data: Data, takeInsertion: BOOLEAN] = {    Selection.Set[data, ConvertProc, ActOnProc];    IF sel # NIL THEN DrawNode[data, sel, gray];    IF takeInsertion THEN UserInput.SetInputFocus[      w: data.depSW, notify: NIL, takesInput: FALSE, data: NIL];    data.selNode ¬ sel};    ActOnProc: INTERNAL Selection.ActOnProcType = {    myData: Data ¬ data;    SELECT action FROM      clear, unmark, clearIfHasInsert => ClearSelection[myData];      delete => UserTerminal.BlinkDisplay[];      ENDCASE};    ConvertProc: Selection.ConvertProcType = {    myData: Data ¬ data;    LockedConvertProc: ENTRY PROC [data: Data] RETURNS [p: LONG POINTER] = {      ENABLE UNWIND => NULL;      z: UNCOUNTED ZONE = Heap.systemZone;      RETURN[        SELECT target FROM	  window => ToolWindow.WindowForSubwindow[data.depSW],	  subwindow => data.depSW,	  string => IF data.selNode # NIL	    THEN String.CopyToNewString[Dependency.NodeName[data.selNode], z]	    ELSE z.NEW[StringBody[0]],	  length => IF data.selNode = NIL THEN z.NEW[LONG CARDINAL ¬ 0]	    ELSE z.NEW[LONG CARDINAL ¬ Dependency.NodeName[data.selNode].length],	  ENDCASE => NIL]};    RETURN LockedConvertProc[myData]};      StartMove: ENTRY PROC [data: Data] = {    ENABLE UNWIND => NULL;    sel: Dependency.Node = data.selNode;    IF sel = NIL THEN {UserTerminal.BlinkDisplay[];  RETURN};    data.doingMove ¬ TRUE;    data.trackedUL ¬ [Dependency.Left[sel], Dependency.Top[sel]];    data.trackedLR ¬ [Dependency.Right[sel], Dependency.Bottom[sel]];    -- erase node in original position    White[data, NodeBox[sel]];    DrawArcsTo[data, sel, white];  DrawArcsFrom[data, sel, white];    -- now XOR in node's bits    DrawNodeBox[data, sel, gray, xor];    DrawArcsTo[data, sel, black, xor];  DrawArcsFrom[data, sel, black, xor]};      Track: PROC [place: Window.Place, data: Data] = {    LockedTrack: ENTRY PROC [data: Data] = {      ENABLE UNWIND => NULL;      sel: Dependency.Node = data.selNode;      vx, vy: NAT;      IF sel = NIL THEN ERROR;      place.x ¬ MAX[place.x, Dependency.Width[sel]/2];      place.y ¬ MAX[place.y, Dependency.Height[sel]/2];      vx ¬ VirtualXFor[place.x, data];  vy ¬ VirtualYFor[place.y, data];      IF vx = Dependency.X[sel] AND vy = Dependency.Y[sel] THEN RETURN;      -- erase node at old position by XOR'ing in its bits      DrawNodeBox[data, sel, gray, xor];      DrawArcsTo[data, sel, black, xor];  DrawArcsFrom[data, sel, black, xor];       -- now XOR in node's bits at new location      Dependency.UpdateX[sel, vx];  Dependency.UpdateY[sel, vy];         DrawNodeBox[data, sel, gray, xor];      DrawArcsTo[data, sel, black, xor];  DrawArcsFrom[data, sel, black, xor];      -- enlarge, if necessary, region to invalidate when done moving node      UpdateTrackedBox[data, sel]};     LockedTrack[data]};      UpdateTrackedBox: PROC [data: Data, sel: Dependency.Node] = {    ConsiderNode: Dependency.NodeProc = {      data.trackedUL ¬ [        x: MIN[Dependency.Left[n], data.trackedUL.x], 	y: MIN[Dependency.Top[n], data.trackedUL.y]];      data.trackedLR ¬ [        x: MAX[Dependency.Right[n], data.trackedLR.x], 	y: MAX[Dependency.Bottom[n], data.trackedLR.y]]};    -- account for new position of selected node    ConsiderNode[sel];    -- now account for any arcs to or from selected node    data.dep.EnumPlacedParents[sel, ConsiderNode];    data.dep.EnumPlacedSons[sel, ConsiderNode]};       FinishMove: PROC [data: Data] = {    LockedFinish: ENTRY PROC [data: Data] = {      ENABLE UNWIND => NULL;      trackedBox: Window.Box = [        place: data.trackedUL,	dims: [	  w: (data.trackedLR.x - data.trackedUL.x),	  h: (data.trackedLR.y - data.trackedUL.y)]];      Window.InvalidateBox[window: data.depSW, box: trackedBox];      data.doingMove ¬ FALSE};    LockedFinish[data];    data.depSW.Validate[]};    JumpToBeginning: PROC [data: Data] = {    LockedJump: ENTRY PROC [data: Data] = {      ENABLE UNWIND => NULL;      hShift: INTEGER ¬ -data.xOffset;      vShift: INTEGER ¬ -data.yOffset;      data.xOffset ¬ 0;  data.yOffset ¬ 0;        Display.Shift[	window: data.depSW,	box: [[hShift, vShift], data.depSW.GetBox[].dims], newPlace: [0,0]]};    LockedJump[data];    data.depSW.Validate[]};     -- Initialization   InitTIP: PROC = {    selectOrFinishMove ¬ Atom.MakeAtom["selectOrFinishMove"L];    simpleSelect ¬ Atom.MakeAtom["simpleSelect"L];    startMove ¬ Atom.MakeAtom["startMove"L];    track ¬ Atom.MakeAtom["track"L];    jumpToBeginning ¬ Atom.MakeAtom["jumpToBeginning"L]};      InitTIP[];    END.
-- File: DepToolImpl.mesa - last edit:-- AOF                 18-Jun-87  8:28:25-- Copyright (C) 1984 , 1987 by Xerox Corporation. All rights reserved. -- DepToolImpl.mesa - Last edited by--   Lewis	19-Jan-84 14:52:54DIRECTORY  CWF USING [SetWriteProcedure, WF0, WF1, WF3],  Dependency,  Exec USING [AddCommand, ExecProc, Handle, RemoveCommand],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, LineN,    NumberItem, ProcType, StringItem],  Heap USING [systemZone],  MFile USING [AppendErrorMessage, Error, GetProperties, maxNameLength],  MsgSW USING [Clear],  MStream USING [Error, GetFile, Handle, ReadOnly],  Process USING [Detach],  Put USING [Char, CR, Line, Text],  Runtime USING [GetBcdTime],  Stream USING [Delete, EndOfStream, GetChar],  String USING [    AppendChar, AppendExtensionIfNeeded, AppendString, CopyToNewString,    Empty, Equivalent, FreeString, InvalidNumber, MakeString, StringToDecimal],  TextSW USING [ForceOutput],  Time USING [Append, Unpack],  Tool,  ToolFont USING [StringWidth],  ToolWindow,  UserInput,  Window,  WindowFont; DepToolImpl: MONITOR    IMPORTS      CWF, Dependency, Exec, FormSW, Heap, MFile, MsgSW, MStream, Process,      Put, Runtime, Stream, String, TextSW, Time, Tool, ToolFont,      UserInput, Window, WindowFont =  BEGIN  BadDepFile: ERROR = CODE;      systemZone: UNCOUNTED ZONE ¬ NIL;  td: Data ¬ NIL;  Data: TYPE = LONG POINTER TO DataObject;  DataObject: TYPE = MACHINE DEPENDENT RECORD [    toolWindow(0):	Window.Handle ¬ NIL,    msgSW(2):		Window.Handle ¬ NIL,    ttySW(4):		Window.Handle ¬ NIL,    formSW(6):		Window.Handle ¬ NIL,    graphicSW(8):	Window.Handle ¬ NIL,    toolBusy(10):	BOOLEAN ¬ FALSE,    untilDone(11):	CONDITION,    dependencyFile(13):	LONG STRING ¬ NIL,    rootNodes(15):	LONG STRING ¬ NIL,    minXGap(17):	CARDINAL ¬ cw,		-- e.g. 6    minYGap(18):	CARDINAL ¬ 2*ch,	-- e.g. 24    dep(19):		Dependency.Handle ¬ NIL,    depStream(21):	MStream.Handle ¬ NIL,     streamPos(23):	LONG CARDINAL ¬ 0,        eof(25):		BOOLEAN ¬ FALSE,        token(26):		LONG STRING ¬ NIL,        nextChar(28):	CHARACTER ¬ 0C];      cw: CARDINAL = WindowFont.CharWidth['M];  -- pixel width of char  ch: CARDINAL = WindowFont.FontHeight[];   -- pixel height of char      FireUpWindow: PROC = {    box: Window.Box = [[x: 0, y: 30], [w: 512, h: 718]];      herald: LONG STRING ¬ [100];    String.AppendString[herald, "DependencyTool of "L];    Time.Append[herald, Time.Unpack[LOOPHOLE[Runtime.GetBcdTime[]]]];    [] ¬ Tool.Create[  -- td.toolWindow is set in MakeSWs below      makeSWsProc: MakeSWs, initialState: default, name: herald,      initialBox: box,      clientTransition: ClientTransition, cmSection: "DependencyTool"L,      tinyName1: "Dependency"L, tinyName2: "Tool"L]};  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      (old = inactive) => WakeUp[];      (new = inactive) => Sleep[];      ENDCASE};	  WakeUp: PROC = {    IF td = NIL THEN {      systemZone ¬ Heap.systemZone;       td ¬ systemZone.NEW[DataObject ¬ []];      td.token ¬ String.MakeString[systemZone, 150];      Dependency.Initialize[]}};        Sleep: ENTRY PROC = {    IF td # NIL THEN {      WHILE td.toolBusy DO WAIT td.untilDone ENDLOOP;      IF td.dep # NIL THEN         td.dep ¬ Dependency.Destroy[td.dep];      Dependency.Finalize[];      IF td.token # NIL THEN {        String.FreeString[systemZone, td.token];  td.token ¬ NIL};      IF td # NIL THEN systemZone.FREE[@td];      systemZone ¬ NIL}};        MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [100];    Tool.UnusedLogName[unused: logName, root: "DependencyTool.log"L];    td.toolWindow ¬ window;    td.msgSW  ¬ Tool.MakeMsgSW[window:  window, lines: 1];    td.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    td.ttySW  ¬ Tool.MakeTTYSW[window:  window, name: logName, h: 2*ch];    td.graphicSW ¬ Dependency.MakeDepSW[window: window];    [] ¬ CWF.SetWriteProcedure[ToolPutProc]};  -- i/o is via td.ttySW        ToolPutProc: PROC [c: CHARACTER] = {Put.Char[td.ttySW, c]};  MakeForm: FormSW.ClientItemsProcType = {    nItems: CARDINAL = 8;    depFileCol: INTEGER ¬      ToolFont.StringWidth["    "L] + ToolFont.StringWidth["Read Dependencies"L];    cmdCol2: INTEGER ¬      ToolFont.StringWidth["    "L] + ToolFont.StringWidth["Graph All Nodes"L];    cmdCol3: INTEGER ¬      cmdCol2 + ToolFont.StringWidth["    "L] +      ToolFont.StringWidth["Include Nodes"L];    items ¬ FormSW.AllocateItemDescriptor[nItems];    --     items[0] ¬ FormSW.CommandItem[      tag: "Read Dependencies"L, place: [x: 0, y: FormSW.LineN[0]],      proc: DoReadDependencies];    items[1] ¬ FormSW.StringItem[      tag: "Dependency File"L, inHeap: TRUE,      place: [x: depFileCol, y: FormSW.LineN[0]], string: @td.dependencyFile];    --    items[2] ¬ FormSW.StringItem[      tag: "Nodes"L, inHeap: TRUE, place: [x: 0, y: FormSW.LineN[1]],      string: @td.rootNodes];    --    items[3] ¬ FormSW.NumberItem[      tag: "Min X gap"L, place: [x: 0, y: FormSW.LineN[2]], signed: FALSE,      notNegative: TRUE, value: @td.minXGap];    items[4] ¬ FormSW.NumberItem[      tag: "Min Y gap"L, place: [x: 100, y: FormSW.LineN[2]], signed: FALSE,      notNegative: TRUE, value: @td.minYGap];    --    items[5] ¬ FormSW.CommandItem[      tag: "Graph All Nodes"L, place: [x: 0, y: FormSW.LineN[3]],      proc: DoGraphAllNodes];    items[6] ¬ FormSW.CommandItem[      tag: "Include Nodes"L, place: [x: cmdCol2, y: FormSW.LineN[3]],      proc: DoIncludeNodes];    items[7] ¬ FormSW.CommandItem[      tag: "Reset"L, place: [x: cmdCol3, y: FormSW.LineN[3]],      proc: DoReset];    RETURN[items: items, freeDesc: TRUE]};     -- Tool operations  StartCommand: PROC RETURNS [ok: BOOLEAN] = {    IF ~Enter[] THEN {      PostLine["DependencyTool already running!"L];  RETURN[FALSE]};    Put.CR[td.msgSW];    RETURN[TRUE]};    FinishCommand: PROC = {TextSW.ForceOutput[td.msgSW];  Leave[]};    Enter: ENTRY PROC RETURNS [ok: BOOLEAN] = {    ENABLE UNWIND => NULL;    IF td.toolBusy THEN RETURN[FALSE];    td.toolBusy ¬ TRUE;    RETURN[TRUE]};    Leave: ENTRY PROC = {    ENABLE UNWIND => NULL;    td.toolBusy ¬ FALSE;  NOTIFY td.untilDone};    PostLine: PROC [msg: LONG STRING] = {    Put.Line[td.msgSW, msg];  TextSW.ForceOutput[td.msgSW]};    PostText: PROC [msg: LONG STRING] = {    Put.Text[td.msgSW, msg];  TextSW.ForceOutput[td.msgSW]};   IsAborted: PROC RETURNS [BOOLEAN] = {    RETURN[UserInput.UserAbort[td.toolWindow]]};  DoReadDependencies: FormSW.ProcType = {    IF ~StartCommand[] THEN RETURN;    Process.Detach[FORK Umbrella[ReadDependencies, "ReadDependencies"L]]};      DoGraphAllNodes: FormSW.ProcType = {    IF ~StartCommand[] THEN RETURN;    Process.Detach[FORK Umbrella[GraphAllNodes, "GraphAllNodes"L]]};  DoIncludeNodes: FormSW.ProcType = {    IF ~StartCommand[] THEN RETURN;    Process.Detach[FORK Umbrella[IncludeNodes, "IncludeNodes"L]]};      DoReset: FormSW.ProcType = {    IF ~StartCommand[] THEN RETURN;    Process.Detach[FORK Umbrella[ResetGraph, "ResetGraph"L]]};    Umbrella: PROC [cmdProc: PROC, cmdName: LONG STRING] = {    BEGIN ENABLE {      UNWIND => FinishCommand[];      ABORTED => {        CWF.WF1["...%s aborted.\n"L, cmdName];	PostLine["...aborted"L];        GOTO leave};      Dependency.Error => {	s: LONG STRING ¬ (	  SELECT code FROM	    initNotCalled => "Dependency.Initialize not called!"L,	    tooManyDependencies => "Too many dependencies!"L,	    implementationError => "Dependency implementation error!"L,	    notADepSW => "Not a DepSW!"L,	    depSWNotReset => "DepSW not reset!"L,	    ENDCASE => "Unknown Dependency.Error"L);	CWF.WF1["\n%s\n"L, s];        PostLine[s];        GOTO leave};      MFile.Error => {	msg: STRING ¬ [100];	MFile.AppendErrorMessage[msg, code, file];	CWF.WF1["MFile error: %s\n"L, msg];   	PostLine["...MFile error"L];	GOTO leave};      MStream.Error => {	name: LONG STRING ¬ [MFile.maxNameLength];        SELECT TRUE FROM	  (stream = NIL) => name ¬ "unknown"L;	  (code = invalidHandle) => name ¬ "unknown"L;	  ENDCASE => [] ¬ MFile.GetProperties[MStream.GetFile[stream], name];        CWF.WF1[	  "\n...Error accessing stream on file %s.\n"L, 	  (IF name.length > 0 THEN name ELSE "unknown"L)];	PostLine["...MStream error"L];        GOTO leave}};    MsgSW.Clear[td.msgSW];    cmdProc[];    EXITS leave => NULL;    END;    FinishCommand[]};  ReadDependencies: PROC = {    depFile: LONG STRING ¬ NIL;    CleanUp: PROC = {      IF depFile # NIL THEN String.FreeString[systemZone, depFile];      depFile ¬ NIL};    BEGIN ENABLE UNWIND => CleanUp[];    PostText["Reading dependencies..."L];    IF IsAborted[] THEN ERROR ABORTED;    Dependency.ResetDepSW[td.graphicSW];    depFile ¬ String.CopyToNewString[td.dependencyFile, systemZone];    [] ¬ String.AppendExtensionIfNeeded[@depFile, ".dep"L, systemZone];    GetDirectDependencies[depFile      ! BadDepFile => {          CWF.WF0["\nBad dependency file!\n"L];          PostLine["Bad dependency file!"L];          GOTO BadDependencyFile};        Dependency.Error => {	  s: LONG STRING;	  SELECT code FROM	    initNotCalled => s ¬ "Dependency.Initialize not called!"L;	    tooManyDependencies => s ¬ "Too many dependencies!"L;	    implementationError => s ¬ "Dependency implementation error!"L;	    ENDCASE => s ¬ "Unknown Dependency.Error"L;	  CWF.WF1["\n%s\n"L, s];          PostLine[s];	  GOTO DependencyError}];    PostText["making graph acyclic..."L];    IF IsAborted[] THEN ERROR ABORTED;    ReduceGraph[];    PostLine["done."L];    EXITS      BadDependencyFile => NULL;      DependencyError => NULL;    END;    CleanUp[]};    GetDirectDependencies: PROC [depFile: LONG STRING] = {    n, count: CARDINAL;    CleanUp: PROC = {      IF td.depStream # NIL THEN {        Stream.Delete[td.depStream];  td.depStream ¬ NIL}};    BEGIN ENABLE UNWIND => CleanUp[];    td.depStream ¬ NIL;  td.streamPos ¬ 0;  td.eof ¬ FALSE;    td.nextChar ¬ ' ;    td.depStream ¬ MStream.ReadOnly[depFile, []      ! MStream.Error => {          CWF.WF1["\nUnable to open %s for reading.\n"L, depFile];	  GOTO badFile}];    td.depStream.options.signalEndOfStream ¬ TRUE;    GetToken[];  -- prime the pump    n ¬ GetNumber[];    CWF.WF1["%u nodes maximum"L, @n];    IF td.dep # NIL THEN       td.dep ¬ Dependency.Destroy[td.dep];    td.dep ¬ Dependency.Create[maxNodeCount: n];     WHILE ~td.eof DO GetDependenciesOfOneNode[] ENDLOOP;    count ¬ td.dep.NodeCount[];    CWF.WF1[", %u nodes actually read.\n"L, @count];    EXITS badFile => ERROR BadDepFile;    END;    CleanUp[]};      GetDependenciesOfOneNode: PROC = {    nodeName: STRING ¬ [100];    Skip["("L];    String.AppendString[nodeName, td.token];    GetToken[];  -- advance over nodeName    Skip[":"L];    WHILE ~String.Equivalent[td.token, ")"L] DO      td.dep.RecordDependency[nodeName, td.token];      GetToken[];  -- advance over name of node that nodeName depends upon      ENDLOOP;    Skip[")"L]};    ReduceGraph: PROC = {    lastSuperNode: Dependency.Node ¬ NIL;    PrintLoopNode: Dependency.NodeProc = {      CWF.WF1[        "  Node %s is in a cycle (depends on itself).\n"L, 	Dependency.NodeName[n]]};    [] ¬ td.dep.ReduceGraph[loopNodesProc: PrintLoopNode];    IF lastSuperNode # NIL THEN CWF.WF0[".\n"L]};         GraphAllNodes: PROC = {    dims: Window.Dims = td.graphicSW.GetBox[].dims;    AllRootNodes: Dependency.IncludeNodeProc = {RETURN[yes: TRUE]};    IF td.dep = NIL THEN {      CWF.WF0["No dependencies read!"L];      PostLine["No dependencies read!"L];      RETURN};    PostText["Placing nodes..."L];    IF IsAborted[] THEN ERROR ABORTED;    Dependency.ResetDepSW[td.graphicSW];    td.dep.PlaceNodes[      includeNode: AllRootNodes,      desiredWidth: dims.w, desiredHeight: dims.h,      minXGap: td.minXGap, minYGap: td.minYGap];    PostText["drawing graph..."L];    IF IsAborted[] THEN ERROR ABORTED;    Dependency.DisplayGraph[td.dep, td.graphicSW];    PostLine["done."L]};        IncludeNodes: PROC = {    dims: Window.Dims = td.graphicSW.GetBox[].dims;    nodeList: LONG STRING ¬ NIL;    oneNodeMatched: BOOLEAN ¬ FALSE;    CleanUp: PROC = {      IF nodeList # NIL THEN String.FreeString[systemZone, nodeList];      nodeList ¬ NIL};    SeeIfToIncludeNode: Dependency.IncludeNodeProc = {      rootName: LONG STRING = Dependency.NodeName[n];      match: BOOLEAN = NameInList[rootName, nodeList];      IF match THEN oneNodeMatched ¬ TRUE;      RETURN[match]};          BEGIN ENABLE UNWIND => CleanUp[];    IF td.dep = NIL THEN {      CWF.WF0["No dependencies read!\n"L];      PostLine["No dependencies read!"L];      RETURN};    PostText["Placing nodes..."L];    IF IsAborted[] THEN ERROR ABORTED;    Dependency.ResetDepSW[td.graphicSW];    nodeList ¬ String.CopyToNewString[td.rootNodes, systemZone];    td.dep.PlaceNodes[      includeNode: SeeIfToIncludeNode,      desiredWidth: dims.w, desiredHeight: dims.h,      minXGap: td.minXGap, minYGap: td.minYGap];    IF ~oneNodeMatched THEN {      CWF.WF0["No node specified was found!\n"L];      PostLine["No node specified was found!"L];      CleanUp[];      RETURN};     PostText["drawing graph..."L];    IF IsAborted[] THEN ERROR ABORTED;    Dependency.DisplayGraph[td.dep, td.graphicSW];    PostLine["done."L];    END;    CleanUp[]};        NameInList: PROC [name, list: LONG STRING] RETURNS [yes: BOOLEAN] = {    nameLength, listLength: CARDINAL;    IF String.Empty[name] OR String.Empty[list] THEN RETURN[FALSE];    nameLength ¬ name.length;  listLength ¬ list.length;    IF nameLength > listLength THEN RETURN[FALSE];    FOR i: CARDINAL IN [0..(listLength - nameLength)] DO      BEGIN      IF LowerCase[name[0]] = LowerCase[list[i]] THEN { -- possible match start        FOR j: CARDINAL IN [1..nameLength) DO          IF i+j >= listLength OR LowerCase[list[i+j]] # LowerCase[name[j]] THEN            GOTO outer;          ENDLOOP;	IF ( (i = 0 OR list[i - 1] = ' )  	 AND ((i + nameLength) >= listLength OR list[i + nameLength] = ' ) ) THEN	  RETURN[TRUE]};      EXITS outer => NULL;      END;      ENDLOOP;    RETURN[FALSE]};        LowerCase: PROC [c: CHARACTER] RETURNS [CHARACTER] = INLINE {    IF c IN ['A..'Z] THEN c ¬ c + ('a - 'A);  RETURN[c]};  ResetGraph: PROC = {    PostText["Resetting graph..."L];    Dependency.ResetDepSW[td.graphicSW];    PostLine["done."L]};     -- Dependency file parsing  GetToken: PROC = {    pos: CARDINAL;    td.token.length ¬ 0;      WHILE td.nextChar = '  OR td.nextChar = '\t OR td.nextChar = '\n DO      GetChar[];      ENDLOOP;    IF td.nextChar = '( OR td.nextChar = ') OR td.nextChar = ': THEN {      String.AppendChar[td.token, td.nextChar];      GetChar[];  -- advance over special char      RETURN};    pos ¬ 0;    UNTIL td.nextChar = '  OR td.nextChar = '\t OR td.nextChar = '\n     OR td.nextChar = '( OR td.nextChar = ') OR td.nextChar = ':     OR td.nextChar = 0C DO      IF (pos ¬ pos+1) > td.token.maxlength THEN {        CWF.WF1["Token '%s' is too long.\n"L, td.token];  RETURN};      String.AppendChar[td.token, td.nextChar];      GetChar[];  -- advance over char      ENDLOOP};        Skip: PROC [tok: LONG STRING] = {    IF ~String.Equivalent[tok, td.token] THEN {      CWF.WF3[        "Error - expected %s at position %lu, but found %s.\n"L,	tok, @td.streamPos, td.token];      ERROR BadDepFile};    GetToken[]};  -- advance over tok        GetChar: PROC = {    IF td.eof THEN {td.nextChar ¬ 0C;  RETURN};    td.streamPos ¬ td.streamPos + 1;      td.nextChar ¬ Stream.GetChar[td.depStream      ! Stream.EndOfStream => {td.eof ¬ TRUE;  td.nextChar ¬ 0C;  CONTINUE}]};          GetNumber: PROC RETURNS [i: CARDINAL] = {    i ¬ String.StringToDecimal[td.token      ! String.InvalidNumber => {          CWF.WF1["Error - invalid number at position %lu.\n"L, @td.streamPos];	  ERROR BadDepFile}];    GetToken[]};       -- Initialization  Init: PROC = {    Exec.AddCommand[      name: "DependencyTool.~"L, proc: ExecCall, unload: DestroyWindow];    FireUpWindow[]};      ExecCall: Exec.ExecProc = {};        DestroyWindow: Exec.ExecProc = {    IF td # NIL AND td.toolWindow # NIL THEN Tool.Destroy[td.toolWindow];    h.RemoveCommand["DependencyTool.~"L]};  Init[];    END.
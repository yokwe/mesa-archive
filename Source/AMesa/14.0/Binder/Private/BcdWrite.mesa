-- Copyright (C) 1981, 1982, 1983, 1984, 1985, 1986  by Xerox Corporation. All rights reserved. -- BcdWrite.mesa - Last edited by--   Satterthwaite	July 14, 1980  11:32 AM--   Schmidt	September 23, 1980  2:15 PM--   JGS	23-Sep-82 13:40:10--   Bruce	 5-Nov-81  9:24:13--   Loretta	 2-Dec-81 23:26:20--   Lewis	18-Apr-83 17:07:51--   Johnsson	24-Feb-84  9:42:02--   Wagner	16-Jun-86 10:32:38DIRECTORY  Alloc USING [AddNotify, Bounds, DropNotify, Handle, Notifier, Top, Trim, Words],  BcdControlDefs USING [BinderData, data, Zero],  BcdDefs USING [    aptype, ATIndex, attype, BCD, CTIndex, CTRecord, cttype,    cxtype, ENIndex, entype, EXPIndex,    EXPRecord, exptype, FPIndex, FPRecord, fptype, FTIndex, FTNull, FTSelf,    fttype, IMPIndex, IMPNull, imptype, LFNull, lftype, Link,     MTIndex, MTNull, MTRecord, mttype, Namee, NameRecord, NTIndex, NTRecord,    nttype, NullVersion, PackedString, SegClass, SGIndex,    SGNull, SGRecord, sgtype, SpaceID, SPIndex, SPRecord, sptype, sstype,    sttype, tmtype, treetype, TYPIndex, typtype, VersionID, VersionStamp],  BcdErrorDefs USING [ErrorHti, ErrorName, ErrorNameBase, GetSti],  BcdOps: TYPE USING [BcdBase, NameString],  BcdUtilDefs USING [    --anyNewModules,-- BcdBasePtr, BcdBases, ContextForTree, EnterExport, EnterFile,    EnterImport, GetGfi, GetGfiForMti, MapName, MergeFile, NameForHti, SetFileVersion],  Environment USING [bytesPerPage, bytesPerWord, PageNumber, wordsPerPage],  Exec USING [CheckForAbort],  Inline USING [LongCOPY],  MFile USING [    dontRelease, Error, GetTimes, Handle, maxNameLength, ReadOnly,    Release, SetReadProtect, WriteOnly],  MSegment USING [Address, CopyIn, Create, Delete, Handle, Reset],  MStream USING [Create, GetFile, Handle],  PrincOps USING [ControlLink],  Stream USING [Delete, PutBlock, PutWord, SetPosition],  String USING [AppendString, AppendSubString, SubStringDescriptor],  Symbols: FROM "BcdSymbols" USING [CXIndex, HTIndex, HTNull, STIndex, STNull],  SymbolOps: FROM "BcdSymbolOps" USING [Reset],  Table USING [Base, Selector],  Tree: FROM "BcdTree" USING [Index, Link, Scan, Null],  TreeOps: FROM "BcdTreeOps" USING [GetNode, ListLength, ScanList];BcdWrite: PROGRAM     IMPORTS      Alloc, BcdControlDefs, BcdErrorDefs, BcdUtilDefs, Exec, Inline,      MFile, MSegment, MStream, Stream, String, SymbolOps, TreeOps    EXPORTS BcdControlDefs =  BEGIN OPEN BcdDefs;  Alignment: CARDINAL = 4;  -- Code Segments must start at 0 MOD Alignment  BcdWriteError: PUBLIC ERROR = CODE;  Error: PROC = {ERROR BcdWriteError};    gd: BcdControlDefs.BinderData ¬ NIL;  zone: UNCOUNTED ZONE ¬ NIL;  table: Alloc.Handle ¬ NIL;    bcd: BcdUtilDefs.BcdBasePtr ¬ NIL;  header: BcdOps.BcdBase ¬ NIL;  savedTables: LONG POINTER ¬ NIL;  -- saved Bcd tables  abortSignalled, packing: BOOLEAN;  saveIndex, nSgis: CARDINAL;  approxCodePages, approxSymbolPages: CARDINAL ¬ 0;  bcdFile: MFile.Handle ¬ NIL;  bcdStream: MStream.Handle ¬ NIL;  nextBcdPage: CARDINAL;  -- 0 origin  -- if code or symbols are copied to files other than the Bcd file  codeFile, symFile: MFile.Handle ¬ NIL;  codeStream, symbolStream: MStream.Handle ¬ NIL;  copySeg: MSegment.Handle ¬ NIL;  copySegSize: CARDINAL ¬ 0;    codemap, symbolmap: LONG POINTER TO Map ¬ NIL;  Map: TYPE = RECORD [    fti: FTIndex,    type: SegClass,    filename: LONG STRING];  copyMap: BoolMap ¬ NIL;  BoolMap: TYPE = LONG POINTER TO BoolMapSeq;  BoolMapSeq: TYPE = RECORD [SEQUENCE length: CARDINAL OF BOOLEAN];  sgMap: SGMap ¬ NIL;  SGMap: TYPE = LONG POINTER TO SGMapSeq;  SGMapSeq: TYPE = RECORD [SEQUENCE length: CARDINAL OF SGIndex];  phHead, phTail: PackHandle ¬ NIL;  PackHandle: TYPE = LONG POINTER TO PackItem;  PackItem: TYPE = RECORD [    link: PackHandle,    newsgi: SGIndex,  -- in the new table    item: SEQUENCE count: CARDINAL OF MTIndex];  tb, stb, ctb, mtb, lfb, etb, itb, sgb, tyb, tmb, ftb, ntb: Table.Base;  spb, fpb, cxb: Table.Base;  ssb: BcdOps.NameString;  Notifier: Alloc.Notifier = {    tb  ¬ base[treetype];  stb ¬ base[sttype];    ctb ¬ base[cttype];    mtb ¬ base[mttype];  lfb ¬ base[lftype];    tyb ¬ base[typtype];   tmb ¬ base[tmtype];    etb ¬ base[exptype];   itb ¬ base[imptype];    sgb ¬ base[sgtype];    ftb ¬ base[fttype];    spb ¬ base[sptype];    fpb ¬ base[fptype];    ntb ¬ base[nttype];    ssb ¬ base[sstype];    cxb ¬ base[cxtype];    IF bcd # NIL THEN {      bcd.ctb ¬ ctb;  bcd.mtb ¬ mtb;  bcd.tyb ¬ tyb;  bcd.tmb ¬ tmb;      IF ~packing THEN bcd.sgb ¬ sgb}};  CreateBcd: PUBLIC PROC [root: Tree.Link] RETURNS [userAbort: BOOLEAN] = {    rootNode: Tree.Index;    gd ¬ BcdControlDefs.data;    zone ¬ gd.zone;    table ¬ gd.ownTable;    table.AddNotify[Notifier, NIL];    saveIndex ¬ gd.textIndex;    abortSignalled ¬ FALSE;    rootNode ¬ TreeOps.GetNode[root];    packing ¬ (tb[rootNode].son[2] # Tree.Null AND gd.copyCode);    Initialize[];    IF packing THEN {      MakePackItem[tb[rootNode].son[2]];      gd.textIndex ¬ saveIndex;      FillInSgMap[]};    CopyConfigs[];    CopyModules[];    CopyTypes[];    CopySpaces[];  CopyFramePacks[];    WITH config: tb[rootNode].son[3] SELECT FROM      subtree => { 	OPEN Symbols, c: tb[config.index];	gd.textIndex ¬ c.info;	TreeOps.ScanList[c.son[1], CopyImport];	TreeOps.ScanList[c.son[2], CopyExport];	IF c.attr2 THEN  -- EXPORTS ALL	  ExportAllInterfaceRecords[outerConfig: config.index]};       ENDCASE;    RETURN[abortSignalled]};      WriteBcd: PUBLIC PROC RETURNS [userAbort: BOOLEAN] = {    ENABLE      UNWIND => {        CloseOutputStream[];	MarkFileBad[gd.bcdName];	Finalize[]};    abortSignalled ¬ FALSE;     approxCodePages ¬ approxSymbolPages ¬ 0;    IF gd.copyCode OR gd.copySymbols THEN {      ApproximateCopiedPages[];      IF gd.copySymbols THEN EnterMissingSymbolFiles[]};    InitBcdHeader[];    OpenOutputStream[];    WriteBcdToStream[];    CloseOutputStream[];    gd.textIndex ¬ saveIndex;    Finalize[];    RETURN[abortSignalled]};           Initialize: PROC = {    Seq: TYPE = RECORD[SEQUENCE COMPUTED CARDINAL OF CARDINAL];    impBase, expBase, sgBase, fBase, nBase, ssBase: Table.Base;    impSize, expSize, sgSize, fSize, nSize, ssSize: CARDINAL;    b: Table.Base;    IF gd.copyCode OR gd.copySymbols THEN InitCodeSymbolCopy[];    bcd ¬ zone.NEW[BcdUtilDefs.BcdBases];    header ¬ zone.NEW[BCD];    [impBase, impSize] ¬ table.Bounds[imptype];    [expBase, expSize] ¬ table.Bounds[exptype];    [sgBase, sgSize]   ¬ table.Bounds[sgtype];    nSgis ¬ sgSize/SIZE[SGRecord];    IF ~packing THEN sgSize ¬ 0;    [fBase, fSize]    ¬ table.Bounds[fttype];    [nBase, nSize]    ¬ table.Bounds[nttype];    [ssBase, ssSize]  ¬ table.Bounds[sstype];    savedTables ¬      zone.NEW[Seq[impSize + expSize + sgSize + fSize + nSize + ssSize]];    b ¬ LOOPHOLE[savedTables, Table.Base];    Inline.LongCOPY[to: (bcd.etb ¬ b), from: expBase, nwords: expSize];      b ¬ b + expSize;  table.Trim[exptype,0];    Inline.LongCOPY[to: (bcd.itb ¬ b), from: impBase, nwords: impSize];      b ¬ b + impSize;  table.Trim[imptype,0];    Inline.LongCOPY[to: (bcd.ftb ¬ b), from: fBase, nwords: fSize];      b ¬ b + fSize;  table.Trim[fttype,0];    Inline.LongCOPY[to: (bcd.ntb ¬ b), from: nBase, nwords: nSize];      b ¬ b + nSize;  table.Trim[nttype,0];    Inline.LongCOPY[to: (bcd.ssb ¬ b), from: ssBase, nwords: ssSize];      b ¬ b + ssSize;    SymbolOps.Reset[];    IF packing THEN {  -- save old segment table in heap      Inline.LongCOPY[to: (bcd.sgb ¬ b), from: sgBase, nwords: sgSize];      b ¬ b + sgSize;  table.Trim[sgtype,0]};    bcd.ctb ¬ table.Bounds[cttype].base;    bcd.mtb ¬ table.Bounds[mttype].base;    bcd.tyb ¬ table.Bounds[typtype].base;    bcd.tmb ¬ table.Bounds[tmtype].base;    bcd.spb ¬ table.Bounds[sptype].base;    bcd.fpb ¬ table.Bounds[fptype].base;    InitHeader[  -- version stamp is set by OpenOutputStream      header: header,       sourceFile: EnterSource[gd.sourceName, gd.sourceVersion],      typeExported: gd.typeExported];    IF gd.copyCode OR gd.copySymbols THEN {       MapCodeSymbolFiles[];      InitCopyMap[nSgis]};    IF packing THEN InitSgMap[nSgis]    ELSE {      bcd.sgb ¬ table.Bounds[sgtype].base;      IF ~gd.copyCode THEN MapSegments[code];      IF ~gd.copySymbols THEN MapSegments[symbols]};    bcdFile ¬ NIL;  bcdStream ¬ NIL};  EnterSource: PROC [name: LONG STRING, version: BcdDefs.VersionStamp]    RETURNS [fti: FTIndex] = {    fti ¬ BcdUtilDefs.EnterFile[name]; ftb[fti].version ¬ version};      Finalize: PROC = {    ReleaseCodeSymbolCopy[];    IF bcd # NIL THEN zone.FREE[@bcd];    IF header # NIL THEN zone.FREE[@header];    IF zone # NIL AND savedTables # NIL THEN zone.FREE[@savedTables];    FreeSgMap[];  FreeCopyMap[];  FreePackItems[];    DestroyCopySegSpace[];    IF table # NIL THEN {table.DropNotify[Notifier, NIL];  table ¬ NIL};    zone ¬ NIL;  gd ¬ NIL};  InitHeader: PROC [      header: BcdOps.BcdBase,      sourceFile: FTIndex ¬ FTNull,      typeExported: BOOLEAN ¬ FALSE] = {    BcdControlDefs.Zero[header, SIZE[BcdDefs.BCD]];    header.versionIdent ¬       --IF BcdUtilDefs.anyNewModules THEN--      --BcdDefsExtras.GFTVersionID ELSE-- BcdDefs.VersionID;    header.version ¬ BcdDefs.NullVersion;  -- must be set by caller    header.creator ¬ gd.binderVersion;    header.sourceFile ¬ sourceFile;    header.unpackagedFile ¬ FTNull;    header.definitions ¬ FALSE;    header.repackaged ¬       (table.Bounds[sptype].size # 0 OR table.Bounds[fptype].size # 0);    header.tableCompiled ¬ FALSE;    header.typeExported ¬ typeExported;    header.spare ¬ ALL[FALSE]};      ExportAllInterfaceRecords: PROC [outerConfig: Tree.Index] = {    OPEN Symbols;    outerCx: CXIndex = BcdUtilDefs.ContextForTree[tb[outerConfig].son[4]];    neweti, oldeti: EXPIndex;    FOR sti: STIndex ¬ cxb[outerCx].link, stb[sti].link UNTIL sti = STNull DO      BEGIN      IF ~stb[sti].filename THEN         WITH s: stb[sti] SELECT FROM          external =>            WITH m: s.map SELECT FROM              interface => {                  OPEN old: bcd.etb[oldeti], new: etb[neweti];  	        -- first make sure that old is not already exported  	        existingEti: EXPIndex ¬ FIRST[EXPIndex];  	        etLimit: EXPIndex = LOOPHOLE[table.Top[exptype]];  	        oldeti ¬ m.expi;  	        UNTIL existingEti = etLimit DO  	          IF old = etb[existingEti] THEN GO TO AlreadyExported;  		  existingEti ¬   		    existingEti + SIZE[EXPRecord] +		    etb[existingEti].size*SIZE[BcdDefs.Link];  		  ENDLOOP;                  neweti ¬ BcdUtilDefs.EnterExport[bcd, oldeti, TRUE];                Inline.LongCOPY[                  from: @old.links, to: @new.links,		  nwords: new.size*SIZE[BcdDefs.Link]];                new.file ¬ BcdUtilDefs.MergeFile[bcd, new.file];  	        header.nExports ¬ header.nExports + 1};              ENDCASE;          ENDCASE;      EXITS AlreadyExported => NULL;      END;     ENDLOOP}; -- Code and symbol copying      InitCodeSymbolCopy: PROC = {    Setup: PROC [        name: LONG STRING, type: SegClass] RETURNS [p: LONG POINTER TO Map] = {      p ¬ zone.NEW[Map];      p.type ¬ type;      p.filename ¬ name;      p.fti ¬ (IF name = NIL THEN FTSelf ELSE BcdUtilDefs.EnterFile[name])};    IF gd.copyCode THEN codemap ¬ Setup[gd.codeName, code];    IF gd.copySymbols THEN symbolmap ¬ Setup[gd.symbolName, symbols]};  MapCodeSymbolFiles: PROC = {    IF gd.copyCode THEN       codemap.fti ¬ BcdUtilDefs.MergeFile[bcd, codemap.fti];    IF gd.copySymbols THEN       symbolmap.fti ¬ BcdUtilDefs.MergeFile[bcd, symbolmap.fti]};  ReleaseCodeSymbolCopy: PROC = {    IF gd.copyCode THEN zone.FREE[@codemap];    IF gd.copySymbols THEN zone.FREE[@symbolmap];    codemap ¬ symbolmap ¬ NIL};  InitCopyMap: PROC [nSgis: CARDINAL] = {    copyMap ¬ zone.NEW[BoolMapSeq[nSgis]];    FOR i: CARDINAL IN [0..nSgis) DO copyMap[i] ¬ FALSE ENDLOOP};  FreeCopyMap: PROC = {    IF gd.copyCode OR gd.copySymbols THEN       IF copyMap # NIL THEN zone.FREE[@copyMap]};  SetCopied: PROC [sgi: SGIndex] = {copyMap[IndexForSgi[sgi]] ¬ TRUE};  Copied: PROC [sgi: SGIndex] RETURNS [reply: BOOLEAN] = {    RETURN[copyMap[IndexForSgi[sgi]]]};  IndexForSgi: PROC [sgi: SGIndex] RETURNS [index: CARDINAL] = INLINE {    RETURN[ LOOPHOLE[sgi,CARDINAL]/SIZE[SGRecord] ]}; -- Code packing  MakePackItem: Tree.Scan = {    -- t is Tree.Null, a list of ids, or a list of lists of ids    ph: PackHandle;    i, nsons: CARDINAL;    Item: Tree.Scan = {      itemId: Symbols.HTIndex;      WITH t SELECT FROM	symbol => {	  itemId ¬ stb[index].hti;	  WITH stb[index] SELECT FROM	    external =>	      WITH m: map SELECT FROM		module => {		  ph.item[i] ¬ m.mti;		  SELECT TRUE FROM		     ~mtb[m.mti].packageable =>			BcdErrorDefs.ErrorNameBase[			  error, "is packaged and cannot be PACKed"L,			  mtb[m.mti].name, bcd.ssb];		     (ReadSgMap[mtb[m.mti].code.sgi] # SGNull) =>			BcdErrorDefs.ErrorNameBase[			  error, "cannot be PACKed twice"L,			  mtb[m.mti].name, bcd.ssb];		     ENDCASE =>		       SetSgMap[old: mtb[m.mti].code.sgi, new: ph.newsgi]};		ENDCASE => GOTO cant;	    ENDCASE => GOTO cant;	  EXITS	    cant => 		BcdErrorDefs.ErrorHti[	          error, "cannot be PACKed"L, itemId		  ! BcdErrorDefs.GetSti => RESUME[errorSti: Symbols.STNull]]};        ENDCASE;      i ¬ i+1};    IF t = Tree.Null THEN RETURN;    WITH t SELECT FROM      subtree => {	OPEN tt: tb[index];	IF tt.name # list THEN Error[];	gd.textIndex ¬ tt.info;	IF tt.son[1].tag = subtree THEN {	  TreeOps.ScanList[t, MakePackItem];  RETURN}};      ENDCASE;    nsons ¬ TreeOps.ListLength[t];    ph ¬ zone.NEW[PackItem[nsons] ¬ [      link: NIL, newsgi: table.Words[sgtype, SIZE[SGRecord]], item: ]];    FOR j: CARDINAL IN [0..nsons) DO ph.item[j] ¬ BcdDefs.MTNull ENDLOOP;    sgb[ph.newsgi] ¬ [      class: code, file: codemap.fti, base:0, pages:0, extraPages:0];    i ¬ 0;  TreeOps.ScanList[t, Item];    IF phTail = NIL THEN phHead ¬ phTail ¬ ph    ELSE {phTail.link ¬ ph;  phTail ¬ ph}};  FreePackItems: PROC = {    next: PackHandle;    p: PackHandle ¬ phHead;    UNTIL p = NIL DO      next ¬ p.link;  zone.FREE[@p];      p ¬ next;      ENDLOOP;    phHead ¬ phTail ¬ NIL};  InitSgMap: PROC [nsgis: CARDINAL] = {    sgMap ¬ zone.NEW[SGMapSeq[nsgis]];    FOR i: CARDINAL IN [0..nsgis) DO sgMap[i] ¬ BcdDefs.SGNull ENDLOOP};  FreeSgMap: PROC = {    IF packing THEN       IF sgMap # NIL THEN zone.FREE[@sgMap]};  SetSgMap: PROC [old, new: SGIndex] = {    IF (packing AND old # SGNull) THEN sgMap[IndexForSgi[old]] ¬ new};  ReadSgMap: PROC [old: SGIndex] RETURNS [SGIndex] = {    RETURN[IF (~packing OR old = SGNull) THEN old ELSE sgMap[IndexForSgi[old]] ]};  FillInSgMap: PROC = {    -- called only when packing (i.e. packing requested AND copyCode = TRUE)    FOR i: CARDINAL IN [0..sgMap.length) DO      IF sgMap[i] = SGNull THEN {	oldsgi: SGIndex = LOOPHOLE[i * SIZE[SGRecord]];	newsgi: SGIndex = table.Words[sgtype, SIZE[SGRecord]];	sgb[newsgi] ¬ bcd.sgb[oldsgi];	sgb[newsgi].file ¬	  (IF sgb[newsgi].class = symbols THEN              (IF gd.copySymbols THEN symbolmap.fti	      ELSE BcdUtilDefs.MergeFile[bcd, sgb[newsgi].file])	   ELSE codemap.fti);	sgMap[i] ¬ newsgi};      ENDLOOP};  FixAllSgis: PROC = {    -- replace all sgis with ReadSgMap[sgi]    FixModule: PROC [mti: MTIndex] RETURNS [BOOLEAN] = {      OPEN m: mtb[mti];      m.code.sgi ¬ ReadSgMap[m.code.sgi];      m.sseg ¬ ReadSgMap[m.sseg];      RETURN[FALSE]};    FixSpace: PROC [spi: SPIndex] RETURNS [BOOLEAN] = {      OPEN sp: spb[spi];      sp.seg ¬ ReadSgMap[sp.seg];      RETURN[FALSE]};    EnumerateModules[FixModule];    EnumerateSpaces[FixSpace]}; -- Bcd table mapping  CopyName: PROC [olditem, newitem: Namee] = {    nti, newnti: NTIndex;    newnti ¬ table.Words[nttype, SIZE[NTRecord]];    FOR nti ¬ FIRST[NTIndex], nti+SIZE[NTRecord] DO      OPEN old: bcd.ntb[nti];      IF old.item = olditem THEN {        OPEN new: ntb[newnti];        new.item ¬ newitem; new.name ¬ BcdUtilDefs.MapName[bcd, old.name];        RETURN};      ENDLOOP};  CopyConfigs: PROC = {    -- configs are already copied, only map names and files    cti: CTIndex ¬ FIRST[CTIndex];    ctLimit: CTIndex = LOOPHOLE[table.Top[cttype]];    UNTIL cti = ctLimit DO      header.nConfigs ¬ (header.nConfigs + 1);      ctb[cti].name ¬ BcdUtilDefs.MapName[bcd, ctb[cti].name];      ctb[cti].file ¬ BcdUtilDefs.MergeFile[bcd, ctb[cti].file];      IF ctb[cti].namedInstance THEN CopyName[[config[cti]], [config[cti]]];      cti ¬ cti + (SIZE[CTRecord] + ctb[cti].nControls*SIZE[Namee]);      ENDLOOP};  CopyModules: PROC = {    -- modules are already copied, only map names and files        MapOne: PROC [mti: MTIndex] RETURNS [BOOLEAN] = {      OPEN m: mtb[mti];      header.nModules ¬ (header.nModules + 1);      m.name ¬ BcdUtilDefs.MapName[bcd, m.name];      m.file ¬ BcdUtilDefs.MergeFile[bcd, m.file];      IF m.namedInstance THEN CopyName[[module[mti]], [module[mti]]];      RETURN[FALSE]};          EnumerateModules[MapOne]};  EnumerateModules: PROC [p: PROC [MTIndex] RETURNS [BOOLEAN]] = {    mtLimit: MTIndex = table.Top[mttype];    FOR mti: MTIndex ¬ FIRST[MTIndex], mti + SIZE[MTRecord]    UNTIL mti = mtLimit DO      IF p[mti] THEN EXIT;      ENDLOOP};  CopyTypes: PROC = {};    -- types are already copied, nothing need be done (current typeIds)  CopySpaces: PROC = {    -- spaces are already copied, only map names (and segments?)    MapOne: PROC [spi: SPIndex] RETURNS [BOOLEAN] = {      spb[spi].name ¬ BcdUtilDefs.MapName[bcd, spb[spi].name];      FOR i: CARDINAL IN [0..spb[spi].length) DO	spb[spi].spaces[i].name ¬ BcdUtilDefs.MapName[bcd, spb[spi].spaces[i].name];	ENDLOOP;      RETURN[FALSE]};    EnumerateSpaces[MapOne]};  EnumerateSpaces: PROC [p: PROC [SPIndex] RETURNS [BOOLEAN]] = {    spi: SPIndex ¬ FIRST[SPIndex];     spLimit: SPIndex = LOOPHOLE[table.Top[sptype]];    UNTIL spi = spLimit DO      IF p[spi] THEN EXIT;      spi ¬ spi + SIZE[SPRecord] + spb[spi].length*SIZE[SpaceID];      ENDLOOP};  CopyFramePacks: PROC = {    -- framepacks are already copied, only map names    MapOne: PROC [fpi: FPIndex] RETURNS [BOOLEAN] = {      fpb[fpi].name ¬ BcdUtilDefs.MapName[bcd, fpb[fpi].name];      RETURN[FALSE]};    EnumerateFramePacks[MapOne]};  EnumerateFramePacks: PROC [p: PROC [FPIndex] RETURNS [BOOLEAN]] = {    fpi: FPIndex ¬ FIRST[FPIndex];    fpLimit: FPIndex = LOOPHOLE[table.Top[fptype]];    UNTIL fpi = fpLimit DO      IF p[fpi] THEN RETURN;      fpi ¬ fpi + SIZE[FPRecord] + fpb[fpi].length*SIZE[MTIndex];      ENDLOOP};  MapSegments: PROC [type: SegClass] = {    CopySegment: PROC [sgi: SGIndex] = {      IF sgb[sgi].class = type THEN         sgb[sgi].file ¬ BcdUtilDefs.MergeFile[bcd, sgb[sgi].file]};    EnumerateSegments[CopySegment]};  CopyImport: Tree.Scan = {    OPEN Symbols;    sti: STIndex ¬ STNull;    olditi, iti: IMPIndex;    WITH t SELECT FROM      symbol => {sti ¬ index; olditi ¬ stb[sti].impi};      subtree =>        WITH s1:tb[index].son[1] SELECT FROM          symbol => {sti ¬ s1.index; olditi ¬ stb[sti].impi};          ENDCASE => Error[];      ENDCASE => Error[];    IF sti = STNull OR olditi = IMPNull THEN RETURN;    iti ¬ BcdUtilDefs.EnterImport[bcd, olditi, TRUE];    itb[iti].file ¬ BcdUtilDefs.MergeFile[bcd, itb[iti].file];    IF header.firstdummy = 0 THEN header.firstdummy ¬ itb[iti].gfi;    header.nImports ¬ header.nImports + 1;    header.nDummies ¬ header.nDummies + 1};  CopyExport: Tree.Scan = {    OPEN Symbols;    sti: STIndex ¬ STNull;    hti: HTIndex ¬ HTNull;    neweti: EXPIndex;    oldeti: EXPIndex;    WITH t SELECT FROM      symbol => sti ¬ index;      subtree =>	WITH s1:tb[index].son[1] SELECT FROM	  symbol => {sti ¬ s1.index; hti ¬ stb[sti].hti};	  ENDCASE => Error[];      ENDCASE => Error[];    WITH s:stb[sti] SELECT FROM      external =>         WITH m:s.map SELECT FROM          interface => {            OPEN new: etb[neweti];            oldeti ¬ m.expi;            neweti ¬ BcdUtilDefs.EnterExport[bcd, oldeti, TRUE];            Inline.LongCOPY[              from: @bcd.etb[oldeti].links,              to: @new.links,              nwords: new.size*SIZE[Link]];            new.file ¬ BcdUtilDefs.MergeFile[bcd, new.file]};          module => [] ¬ NewExportForModule[m.mti, HTNull];          ENDCASE => RETURN;      ENDCASE => RETURN;    header.nExports ¬ header.nExports + 1};  NewExportForModule: PROC [mti: MTIndex, name: Symbols.HTIndex]      RETURNS [eti: EXPIndex] = {    OPEN Symbols;    eti ¬ table.Words[exptype, SIZE[EXPRecord]+SIZE[BcdDefs.Link]];    etb[eti] ¬ [      name: mtb[mti].name,      size: 1,      port: module,      namedInstance: name # HTNull,      typeExported: FALSE,      file: mtb[mti].file,      links: ];    etb[eti].links[0] ¬ [variable[gfi: BcdUtilDefs.GetGfiForMti[mti], offset: 0]];    IF name # HTNull THEN {      nti: NTIndex = table.Words[nttype,SIZE[NTRecord]];      ntb[nti] ¬ [name: BcdUtilDefs.NameForHti[name], item: [module[mti]]]};    RETURN};     -- ********* Bcd Output *********   PagesForWords: PROCEDURE [words: CARDINAL] RETURNS [CARDINAL] =    {RETURN[      CARDINAL[        (LONG[words] + (Environment.wordsPerPage - 1)) / Environment.wordsPerPage      ] ] };      ApproximateCopiedPages: PROC = {        AddLength: PROC [oldSgi: SGIndex] = {       OPEN seg: bcd.sgb[oldSgi];      SELECT seg.class FROM        code =>          IF gd.copyCode THEN	    approxCodePages ¬ approxCodePages + (seg.pages + seg.extraPages);	symbols =>	  IF gd.copySymbols THEN	    approxSymbolPages ¬ approxSymbolPages + (seg.pages + seg.extraPages);	ENDCASE};	    EnumerateOldSegments[AddLength];    IF gd.copyCode THEN  -- add in fudge factor for code links      approxCodePages ¬ approxCodePages + approxCodePages/10};   InitBcdHeader: PROC = {    OPEN header;    d, s: CARDINAL;    IF firstdummy = 0 THEN firstdummy ¬ BcdUtilDefs.GetGfi[0];    d ¬ SIZE[BCD];    ssOffset ¬ d;  d ¬ d + (ssLimit ¬ table.Bounds[sstype].size);    ctOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[cttype].size);    ctLimit ¬ LOOPHOLE[s];    mtOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[mttype].size);      mtLimit ¬ LOOPHOLE[s];      impOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[imptype].size);    impLimit ¬ LOOPHOLE[s];    expOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[exptype].size);    expLimit ¬ LOOPHOLE[s];    enOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[entype].size);    enLimit ¬ LOOPHOLE[s, ENIndex];    sgOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[sgtype].size);    sgLimit ¬ LOOPHOLE[s];    ftOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[fttype].size);    ftLimit ¬ LOOPHOLE[s];    ntOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[nttype].size);    ntLimit ¬ LOOPHOLE[s];    typOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[typtype].size);    typLimit ¬ LOOPHOLE[s];    tmOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[tmtype].size);    tmLimit ¬ LOOPHOLE[s];    spOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[sptype].size);    spLimit ¬ LOOPHOLE[s];    fpOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[fptype].size);    fpLimit ¬ LOOPHOLE[s];    lfOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[lftype].size);    lfLimit ¬ LOOPHOLE[s];    atOffset ¬ d;  d ¬ d + (s ¬ table.Bounds[attype].size);    atLimit ¬ LOOPHOLE[s];    apOffset ¬ d;  d ¬ d + (apLimit ¬ table.Bounds[aptype].size);    nPages ¬ PagesForWords[d]};      WriteBcdToStream: PROC = {    headerBytes: CARDINAL = (SIZE[BCD] * Environment.bytesPerWord);     afterBcd: CARDINAL;    nextBcdPage ¬ afterBcd ¬ header.nPages;    -- copy code and symbols    IF gd.copyCode OR gd.copySymbols THEN {      CreateCopySegSpace[];      IF gd.copyCode THEN        MoveCodeSegments[ ! ABORTED => GOTO AbortRequested];      IF gd.copySymbols THEN        MoveSymbolSegments[ ! ABORTED => GOTO AbortRequested];      DestroyCopySegSpace[]};    IF packing THEN FixAllSgis[];    -- now write Bcd itself    Stream.SetPosition[bcdStream, 0];    [] ¬ Stream.PutBlock[      bcdStream,       [blockPointer: LOOPHOLE[header],       startIndex: 0, stopIndexPlusOne: headerBytes]];    WriteTables[];    IF nextBcdPage # afterBcd THEN PositionAtPage[bcdStream, nextBcdPage];    gd.outModules  ¬ header.nModules;    gd.outConfigs  ¬ header.nConfigs;    gd.outBcdPages ¬ header.nPages;    EXITS AbortRequested => abortSignalled ¬ TRUE};        WriteTables: PROC = {    WriteSubTable[sstype];    WriteSubTable[cttype];    WriteSubTable[mttype];    WriteSubTable[imptype];    WriteSubTable[exptype];    WriteSubTable[entype];    WriteSubTable[sgtype];    WriteSubTable[fttype];    WriteSubTable[nttype];    WriteSubTable[typtype];    WriteSubTable[tmtype];    WriteSubTable[sptype];    WriteSubTable[fptype];    WriteSubTable[lftype];    WriteSubTable[attype];    WriteSubTable[aptype]};  WriteSubTable: PROC [t: Table.Selector] = {    base: Table.Base;    size, bytes: CARDINAL;    [base, size] ¬ table.Bounds[t];    bytes ¬ (size * Environment.bytesPerWord);    [] ¬ Stream.PutBlock[      bcdStream,       [blockPointer: base, startIndex: 0, stopIndexPlusOne: bytes]]};       -- Code copying  MoveCodeSegments: PROC = {    stream: MStream.Handle;    nextPage: CARDINAL;    AddLinks: PROC [mti: MTIndex] RETURNS [stop: BOOLEAN] = {      OPEN m: mtb[mti];      wordsWritten, pagesWritten: CARDINAL;      newSgi: SGIndex;      IF (m.linkLoc = code AND ~m.linkspace) AND m.packageable THEN {        IF Exec.CheckForAbort[gd.exec] THEN ERROR ABORTED;	IF m.packed THEN BcdErrorDefs.ErrorName[	  error,	  "was previously PACKed and can not now have code links added"L, m.name]	ELSE {  	  PositionAtPage[stream, nextPage];          wordsWritten ¬ AddLinksToCodeSegment[  	    stream: stream, mti: mti, offset: 0, packed: FALSE];          pagesWritten ¬ PagesForWords[wordsWritten];          newSgi ¬ ReadSgMap[m.code.sgi];          sgb[newSgi].file ¬ codemap.fti;          sgb[newSgi].base ¬ BcdBaseForFilePage[nextPage];          sgb[newSgi].pages ¬ pagesWritten;          nextPage ¬ nextPage + pagesWritten}};      RETURN[FALSE]};    MoveOne: PROC [oldSgi: SGIndex] = {       OPEN seg: bcd.sgb[oldSgi];      newSgi: SGIndex;      segPages: CARDINAL;      IF seg.class = code AND seg.file # FTNull AND ~Copied[oldSgi] THEN {        IF Exec.CheckForAbort[gd.exec] THEN ERROR ABORTED;	SetCopied[oldSgi];	PositionAtPage[stream, nextPage];	MoveOldCodeSegment[stream, oldSgi];	segPages ¬ (seg.pages + seg.extraPages);        newSgi ¬ ReadSgMap[oldSgi];        sgb[newSgi].file ¬ codemap.fti;        sgb[newSgi].base ¬ BcdBaseForFilePage[nextPage];        nextPage ¬ (nextPage + segPages)}};    IF codemap.fti = FTSelf THEN {stream ¬ bcdStream;  nextPage ¬ nextBcdPage}    ELSE {      nextPage ¬ OpenCopiedCodeStream[];      stream ¬ codeStream};    BEGIN      ENABLE UNWIND => {CloseCopiedCodeStream[]; MarkFileBad[codemap.filename]};    nextPage ¬ PackCodeSegments[stream, nextPage];    EnumerateModules[AddLinks];    EnumerateOldSegments[MoveOne];  -- copy remaining code segments    END;    IF codemap.fti = FTSelf THEN nextBcdPage ¬ nextPage    ELSE CloseCopiedCodeStream[]};  OpenCopiedCodeStream: PROC RETURNS [nextPage: CARDINAL] = {    file: MFile.Handle ¬ NIL;    codeHeader: BcdOps.BcdBase ¬ zone.NEW[BCD];    headerBytes: CARDINAL = (SIZE[BCD] * Environment.bytesPerWord);     headerPages: CARDINAL = PagesForWords[SIZE[BCD]];    BcdUtilDefs.SetFileVersion[codemap.fti, BumpVersion[header.version, 1]];    InitHeader[header: codeHeader];    codeHeader.version ¬ ftb[codemap.fti].version;    -- write "Bcd header" to output stream    file ¬ MFile.WriteOnly[      name: codemap.filename, release: MFile.dontRelease, type: binary,      initialLength: (headerPages + approxCodePages)];    codeStream ¬ MStream.Create[file: file, release: []];    [] ¬ Stream.PutBlock[codeStream, [LOOPHOLE[codeHeader], 0, headerBytes]];    zone.FREE[@codeHeader];    RETURN[headerPages]};      CloseCopiedCodeStream: PROC = {    IF codeStream # NIL THEN {      file: MFile.Handle = MStream.GetFile[codeStream];      IF file # NIL THEN        MFile.SetReadProtect[file: file, readProtected: FALSE];      Stream.Delete[codeStream];  codeStream ¬ NIL}};      PackCodeSegments: PROC [      out: MStream.Handle, startPage: CARDINAL] RETURNS [nextPage: CARDINAL] = {    ENABLE UNWIND => ReleaseOldCodeSeg[];    offset: CARDINAL;    validLength: CARDINAL;    oldSgi: SGIndex;    mti: MTIndex;    FixUpOneModule: PROC [mti: MTIndex] RETURNS [stop: BOOLEAN] = {      OPEN module: mtb[mti];      length: CARDINAL;      IF module.code.sgi = oldSgi THEN {	length ¬ module.code.offset + (module.code.length+1)/2;	module.code.offset ¬ (module.code.offset + offset);	module.packed ¬ TRUE;	IF length > validLength THEN validLength ¬ length};      RETURN[FALSE]};    nextPage ¬ startPage;    FOR ph: PackHandle ¬ phHead, ph.link UNTIL ph = NIL DO      PositionAtPage[out, nextPage];      offset ¬ 0;      sgb[ph.newsgi].base ¬ BcdBaseForFilePage[nextPage];      FOR pi: CARDINAL IN [0..ph.count) DO	BEGIN OPEN module: mtb[mti];	mti ¬ ph.item[pi];	IF mti = BcdDefs.MTNull THEN GOTO ignore;  -- probably bad module name	IF module.linkLoc = code AND ~module.linkspace THEN {	  wordsWritten: CARDINAL = 	    AddLinksToCodeSegment[	      stream: out, mti: mti, offset: offset, packed: TRUE];	  IF LAST[CARDINAL] - offset < wordsWritten THEN GOTO tooBig	    ELSE offset ¬ (offset + wordsWritten);	  GOTO ignore};        oldSgi ¬ module.code.sgi;        IF Copied[oldSgi] OR bcd.sgb[oldSgi].file = FTNull THEN GOTO ignore;	SetCopied[oldSgi];        IF ~ReadOldCodeSeg[oldSgi] THEN GOTO ignore;	IF (offset MOD Alignment) # 0 THEN	  FOR i: CARDINAL IN [(offset MOD Alignment)..Alignment) DO	    Stream.PutWord[out, 0];	    IF LAST[CARDINAL] - offset < 1 THEN GOTO tooBig	      ELSE offset ¬ offset + 1 	    ENDLOOP;	validLength ¬ 0;  EnumerateModules[FixUpOneModule];        WriteFromCopySeg[out, validLength];	ReleaseOldCodeSeg[];        IF LAST[CARDINAL] - offset < validLength THEN GOTO tooBig	  ELSE offset ¬ offset + validLength;        EXITS ignore => NULL;        END;        REPEAT 	  tooBig => BcdErrorDefs.ErrorNameBase[error, 	              " is in a PACK which is too large"L, mtb[mti].name, ssb];        ENDLOOP;      IF offset > LAST[CARDINAL]-Environment.wordsPerPage THEN         BcdErrorDefs.ErrorNameBase[error, 	  " is in a PACK which is too large"L, mtb[mti].name, ssb]      ELSE {	sgb[ph.newsgi].pages ¬ PagesForWords[CARDINAL[offset]]; 	nextPage ¬ (nextPage + sgb[ph.newsgi].pages);	}      ENDLOOP};  AddLinksToCodeSegment: PROC [        stream: MStream.Handle, mti: MTIndex, offset: CARDINAL, packed: BOOLEAN]      RETURNS [wordsWritten: CARDINAL] = {    ENABLE UNWIND => ReleaseOldCodeSeg[];    sgi: SGIndex ¬ mtb[mti].code.sgi;    codeWords: CARDINAL ¬ (mtb[mti].code.length+1)/2;    linkWords: CARDINAL;    prefixWords: CARDINAL ¬ 0;    FixOffset: PROC [mti: MTIndex] RETURNS [stop: BOOLEAN] = {      OPEN m: mtb[mti];      IF m.code.sgi = sgi THEN {        m.linkspace ¬ TRUE;	m.code.offset ¬ m.code.offset+offset;  m.packed ¬ packed};      RETURN[FALSE]};    IF Copied[sgi] OR bcd.sgb[sgi].file = FTNull THEN RETURN[0];    IF ~ReadOldCodeSeg[sgi] THEN RETURN[0];    SetCopied[sgi];    linkWords ¬ IF mtb[mti].links = LFNull THEN 0      ELSE (lfb[mtb[mti].links].length*SIZE[PrincOps.ControlLink]);    IF offset = 0 AND linkWords # 0 THEN {      prefixWords ¬ 1;      Stream.PutWord[	stream, linkWords + Alignment - (linkWords MOD Alignment)];      offset ¬ offset+1};    IF (offset+linkWords) MOD Alignment # 0 THEN      linkWords ¬ linkWords + Alignment - ((offset+linkWords) MOD Alignment);    offset ¬ offset + linkWords;    EnumerateModules[FixOffset];    FOR i: CARDINAL IN [0..linkWords) DO Stream.PutWord[stream, 0] ENDLOOP;    WriteFromCopySeg[stream, codeWords];    ReleaseOldCodeSeg[];    RETURN[prefixWords + linkWords + codeWords]};      ReadOldCodeSeg: PROC [oldSgi: SGIndex] RETURNS [read: BOOLEAN] = {    OPEN oldSeg: bcd.sgb[oldSgi];    codePages: CARDINAL;    h: BcdOps.BcdBase;    codeFile ¬ FileForSgi[oldSgi];    IF codeFile = NIL THEN {      BcdErrorDefs.ErrorNameBase[	class: error, s: "could not be opened to copy code"L, 	name: bcd.ftb[oldSeg.file].name, base: bcd.ssb];      header.versionIdent ¬ 0;      RETURN[FALSE]};    -- check version    MSegment.CopyIn[segment: copySeg, file: codeFile, fileBase: 0, count: 1];    h ¬ MSegment.Address[copySeg];    IF h.version # bcd.ftb[oldSeg.file].version THEN {      BcdErrorDefs.ErrorNameBase[	class: error, s: "on disk has an incorrect version"L,	name: bcd.ftb[oldSeg.file].name, base: bcd.ssb];      header.versionIdent ¬ 0;      ReleaseOldCodeSeg[];      RETURN[FALSE]};    -- now read the entire code segment    codePages ¬ (oldSeg.pages + oldSeg.extraPages);    IF codePages > copySegSize THEN GrowCopySegSpace[minPages: codePages];     MSegment.CopyIn[      segment: copySeg, file: codeFile,      fileBase: (oldSeg.base - 1), count: codePages];    RETURN[TRUE]};      ReleaseOldCodeSeg: PROC = {    IF codeFile # NIL THEN {MFile.Release[codeFile]; codeFile ¬ NIL}};      FileForSgi: PROC [sgi: SGIndex] RETURNS [file: MFile.Handle] = {    OPEN seg: bcd.sgb[sgi];    name: BcdDefs.NameRecord;    ssd: String.SubStringDescriptor;    s: STRING ¬ [MFile.maxNameLength];    file ¬ NIL;    IF sgi = BcdDefs.SGNull OR seg.file = BcdDefs.FTNull     OR seg.file = BcdDefs.FTSelf THEN RETURN[NIL];    name ¬ bcd.ftb[seg.file].name;    ssd ¬ [      base: @bcd.ssb.string,      offset: name, length: bcd.ssb.size[name]];    String.AppendSubString[s, @ssd];  String.AppendString[s, ".bcd"L];    file ¬ MFile.ReadOnly[name: s, release: [] ! MFile.Error => CONTINUE];    IF file = NIL THEN {  -- try again, without a ".bcd" suffix      s.length ¬ 0;      String.AppendSubString[s, @ssd];      file ¬ MFile.ReadOnly[name: s, release: [] ! MFile.Error => CONTINUE]}};        WriteFromCopySeg: PROC [stream: MStream.Handle, words: CARDINAL] = {    bytes: LONG CARDINAL ¬ words.LONG * 2;    base: LONG POINTER ¬ MSegment.Address[copySeg];    chunkPages: CARDINAL = 100;    chunkBytes: CARDINAL = chunkPages * Environment.bytesPerPage;    WHILE bytes # 0 DO      chunk: CARDINAL = CARDINAL[MIN[bytes, chunkBytes]];      [] ¬ Stream.PutBlock[stream, [base, 0, chunk]];      bytes ¬ bytes - chunk;      base ¬ base + (chunk/Environment.bytesPerWord);      ENDLOOP};        MoveOldCodeSegment: PROC [stream: MStream.Handle, oldSgi: SGIndex] = {    OPEN oldSeg: bcd.sgb[oldSgi];    ENABLE UNWIND => ReleaseOldCodeSeg[];    pages, pagesToTransfer, bytesToTransfer: CARDINAL;    codeBase: Environment.PageNumber;    h: BcdOps.BcdBase;    codeFile ¬ FileForSgi[oldSgi];    IF codeFile = NIL THEN {      BcdErrorDefs.ErrorNameBase[	class: error, s: "could not be opened to copy code"L, 	name: bcd.ftb[oldSeg.file].name, base: bcd.ssb];      header.versionIdent ¬ 0;      RETURN};    -- check version    MSegment.CopyIn[segment: copySeg, file: codeFile, fileBase: 0, count: 1];    h ¬ MSegment.Address[copySeg];    IF h.version # bcd.ftb[oldSeg.file].version THEN {      BcdErrorDefs.ErrorNameBase[	class: error, s: "on disk has an incorrect version"L,	name: bcd.ftb[oldSeg.file].name, base: bcd.ssb];      header.versionIdent ¬ 0;      ReleaseOldCodeSeg[];      RETURN};    -- copy code segment in chunks no larger than current copySeg size    codeBase ¬ (oldSeg.base - 1);    pages ¬ (oldSeg.pages + oldSeg.extraPages);    WHILE pages > 0 DO      pagesToTransfer ¬ MIN[pages, copySegSize];      bytesToTransfer ¬ (pagesToTransfer * Environment.bytesPerPage);      MSegment.CopyIn[        segment: copySeg, file: codeFile,	fileBase: codeBase, count: pagesToTransfer];      [] ¬ Stream.PutBlock[        stream, [MSegment.Address[copySeg], 0, bytesToTransfer]];      codeBase ¬ (codeBase + pagesToTransfer);      pages ¬ (pages - pagesToTransfer);      ENDLOOP;    ReleaseOldCodeSeg[]};       -- Copy symbol segments      EnterMissingSymbolFiles: PROC = {    f: MFile.Handle;    CheckOneSymbolsFileSeg: PROC [sgi: SGIndex] = {       OPEN seg: bcd.sgb[sgi];      IF seg.class = symbols AND seg.file # FTNull AND ~Copied[sgi] THEN {        f ¬ FileForSgi[sgi];        IF f = NIL THEN [] ¬ BcdUtilDefs.MergeFile[bcd, seg.file]	ELSE MFile.Release[f]}};          -- insure that a file entry exists for each copied symbol segment    EnumerateOldSegments[CheckOneSymbolsFileSeg]};  MoveSymbolSegments: PROC = {    stream: MStream.Handle;    nextPage: CARDINAL;    MoveOne: PROC [oldSgi: SGIndex] = {       OPEN seg: bcd.sgb[oldSgi];      newSgi: SGIndex;      notFound: BOOLEAN;      segPages: CARDINAL;      IF seg.class = symbols AND seg.file # FTNull AND ~Copied[oldSgi] THEN {        IF Exec.CheckForAbort[gd.exec] THEN ERROR ABORTED;        SetCopied[oldSgi];	segPages ¬ (seg.pages + seg.extraPages);        newSgi ¬ ReadSgMap[oldSgi];	PositionAtPage[stream, nextPage];        notFound ¬ MoveOldSymbolSegment[stream, oldSgi, newSgi];	IF notFound THEN {  -- point at old symbols file	  sgb[newSgi] ¬ bcd.sgb[oldSgi];          sgb[newSgi].file ¬ BcdUtilDefs.MergeFile[bcd, seg.file]}	ELSE {	  sgb[newSgi].file ¬ symbolmap.fti;          sgb[newSgi].base ¬ BcdBaseForFilePage[nextPage];	  nextPage ¬ (nextPage + segPages)}}};    IF symbolmap.fti = FTSelf THEN {stream ¬ bcdStream;  nextPage ¬ nextBcdPage}    ELSE {      nextPage ¬ OpenCopiedSymbolStream[];      stream ¬ symbolStream};    EnumerateOldSegments[MoveOne       ! UNWIND => {CloseCopiedSymbolStream[]; MarkFileBad[symbolmap.filename]}];    IF symbolmap.fti = FTSelf THEN nextBcdPage ¬ nextPage    ELSE CloseCopiedSymbolStream[]};  OpenCopiedSymbolStream: PROC RETURNS [nextPage: CARDINAL] = {    symbolFile: MFile.Handle ¬ NIL;    symbolHeader: BcdOps.BcdBase ¬ zone.NEW[BCD];    headerBytes: CARDINAL = (SIZE[BCD] * Environment.bytesPerWord);     headerPages: CARDINAL = PagesForWords[SIZE[BCD]];    BcdUtilDefs.SetFileVersion[symbolmap.fti, BumpVersion[header.version, 2]];    InitHeader[header: symbolHeader];    symbolHeader.version ¬ ftb[symbolmap.fti].version;    -- write "Bcd header" to output stream    symbolFile ¬ MFile.WriteOnly[      name: symbolmap.filename, release: MFile.dontRelease, type: binary,      initialLength: (headerPages + approxSymbolPages)];    symbolStream ¬ MStream.Create[file: symbolFile, release: []];    [] ¬ Stream.PutBlock[symbolStream, [LOOPHOLE[symbolHeader], 0, headerBytes]];    zone.FREE[@symbolHeader];    RETURN[headerPages]};      CloseCopiedSymbolStream: PROC = {    IF symbolStream # NIL THEN {      file: MFile.Handle = MStream.GetFile[symbolStream];      IF file # NIL THEN        MFile.SetReadProtect[file: file, readProtected: FALSE];      Stream.Delete[symbolStream];  symbolStream ¬ NIL}};      MoveOldSymbolSegment: PROC [        stream: MStream.Handle, oldSgi, newSgi: SGIndex]      RETURNS [notFound: BOOLEAN] = {    OPEN oldSeg: bcd.sgb[oldSgi];    ENABLE UNWIND => ReleaseOldSymbolSegment[];    pages, pagesToTransfer, bytesToTransfer: CARDINAL;    symBase: Environment.PageNumber;    h: BcdOps.BcdBase;    symFile ¬ FileForSgi[oldSgi];    IF symFile = NIL THEN {      BcdErrorDefs.ErrorNameBase[	class: warning, s: "could not be opened to copy symbols"L, 	name: bcd.ftb[oldSeg.file].name, base: bcd.ssb];      RETURN[notFound: TRUE]};    -- check version    MSegment.CopyIn[segment: copySeg, file: symFile, fileBase: 0, count: 1];    h ¬ MSegment.Address[copySeg];    IF h.version # bcd.ftb[oldSeg.file].version THEN {      BcdErrorDefs.ErrorNameBase[	class: error, s: "on disk has an incorrect version"L,	name: bcd.ftb[oldSeg.file].name, base: bcd.ssb];      header.versionIdent ¬ 0;      ReleaseOldSymbolSegment[];      RETURN[notFound: TRUE]};    -- copy symbol segment in chunks no larger than current copySeg size    symBase ¬ (oldSeg.base - 1);    pages ¬ (oldSeg.pages + oldSeg.extraPages);    WHILE pages > 0 DO      pagesToTransfer ¬ MIN[pages, copySegSize];      bytesToTransfer ¬ (pagesToTransfer * Environment.bytesPerPage);      MSegment.CopyIn[        segment: copySeg, file: symFile, 	fileBase: symBase, count: pagesToTransfer];      [] ¬ Stream.PutBlock[        stream, [MSegment.Address[copySeg], 0, bytesToTransfer]];      symBase ¬ (symBase + pagesToTransfer);      pages ¬ (pages - pagesToTransfer);      ENDLOOP;    ReleaseOldSymbolSegment[];    RETURN[notFound: FALSE]};      ReleaseOldSymbolSegment: PROC = {    IF symFile # NIL THEN {MFile.Release[symFile]; symFile ¬ NIL}};           -- Management of output stream  OpenOutputStream: PROC = {    approxBcdPages: CARDINAL ¬ header.nPages;    IF gd.copyCode AND codemap.fti = FTSelf THEN      approxBcdPages ¬ approxBcdPages + approxCodePages;    IF gd.copySymbols AND symbolmap.fti = FTSelf THEN      approxBcdPages ¬ approxBcdPages + approxSymbolPages;    bcdFile ¬ MFile.WriteOnly[      name: gd.bcdName, release: MFile.dontRelease, type: binary,      initialLength: approxBcdPages];    header.version ¬ [      time: MFile.GetTimes[bcdFile].create, net: gd.network, host: gd.host];    bcdStream ¬ MStream.Create[file: bcdFile, release: []]};  CloseOutputStream: PROC = {      IF bcdFile # NIL THEN        MFile.SetReadProtect[file: bcdFile, readProtected: FALSE];      IF bcdStream # NIL THEN Stream.Delete[bcdStream];      bcdStream ¬ NIL;  bcdFile ¬ NIL};  PositionAtPage: PROC [s: MStream.Handle, page: Environment.PageNumber] = {    Stream.SetPosition[s, (page * Environment.bytesPerPage)]};      MarkFileBad: PUBLIC PROC [name: LONG STRING] = {    outFile: MFile.Handle ¬ NIL;    IF name # NIL THEN {      outFile ¬ MFile.ReadOnly[        name: name, release: MFile.dontRelease, mightWrite: TRUE        ! MFile.Error => CONTINUE];      IF outFile # NIL THEN {        MFile.SetReadProtect[file: outFile, readProtected: TRUE];        MFile.Release[outFile]}}};         -- Management of segment (space) for copied code and symbols  CreateCopySegSpace: PROC = {    IF copySeg = NIL THEN {      copySegSize ¬ 20;      copySeg ¬ MSegment.Create[        file: NIL, release: [],        fileBase: 0, pages: copySegSize, swapInfo: [uniform[size: 4]]]}};      GrowCopySegSpace: PROC [minPages: CARDINAL] = {    copySegSize ¬ ((minPages+3)/4 * 4);    MSegment.Reset[      segment: copySeg, pages: copySegSize, swapInfo: [uniform[size: 4]]]};      DestroyCopySegSpace: PROC = {    IF copySeg # NIL THEN MSegment.Reset[segment: copySeg, file: NIL];    IF codeFile # NIL THEN {MFile.Release[codeFile];  codeFile ¬ NIL};    IF symFile # NIL THEN {MFile.Release[symFile];  symFile ¬ NIL};    IF copySeg # NIL THEN {      MSegment.Delete[copySeg];  copySeg ¬ NIL;  copySegSize ¬ 0}};         -- Subroutines  EnumerateOldSegments: PROC [proc: PROC[SGIndex]] = {    sgLimit: SGIndex;    IF ~packing THEN EnumerateSegments[proc]    ELSE {      sgLimit ¬ LOOPHOLE[sgMap.length*SIZE[SGRecord]];      FOR sgi: SGIndex ¬ FIRST[SGIndex], sgi + SIZE[SGRecord]      UNTIL sgi = sgLimit DO proc[sgi] ENDLOOP}};  EnumerateSegments: PROC [proc: PROC[SGIndex]] = {    sgLimit: SGIndex = LOOPHOLE[table.Top[sgtype]];    FOR sgi: SGIndex ¬ FIRST[SGIndex], sgi + SIZE[SGRecord] UNTIL sgi = sgLimit DO       proc[sgi];       ENDLOOP};  BumpVersion: PROC [v: VersionStamp, n: CARDINAL] RETURNS [VersionStamp] = {    v.time ¬ v.time + n;    RETURN[v]};      BcdBaseForFilePage: PROC [      filePage: CARDINAL] RETURNS [bcdBasePage: CARDINAL] = {    RETURN[filePage + 1]};  -- Bcds use 1 offset page numbering      END.
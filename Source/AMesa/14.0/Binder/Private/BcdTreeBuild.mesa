-- file BcdTreeBuild.mesa rewritten by PGS,  7-Jan-87  1:52-- file BcdTreeBuild.mesa rewritten by PGS, 28-Sep-84 16:10-- file BcdTreeBuild.mesa rewritten by PGS, 28-Sep-84 16:07-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- file BcdTreeBuild.mesa rewritten by PGS,  9-Sep-83 10:16-- file BcdTreeBuild.mesa rewritten by PGS, 17-Aug-83 17:03-- file BcdTreeBuild.mesa rewritten by PGS, 25-Oct-82 15:04-- file BcdTreeBuild.mesa rewritten by PGS,  5-Oct-82 10:10-- file BcdTreeBuild.mesa rewritten by PGS, 23-Sep-82 14:55-- file BcdTreeBuild.mesa rewritten by PGS, 23-Sep-82 12:08-- file BcdTreeBuild.mesa rewritten by PGS,  7-Jan-82 11:08-- file BcdTreeBuild.mesa rewritten by PGS,  7-Jan-82 10:55-- file BcdTreeBuild.mesa rewritten by PGS,  7-Jan-82 10:49-- file BcdTreeBuild.mesa rewritten by PGS, 16-Nov-81 16:51-- BcdTreeBuild.mesa--   grammar edited by Satterthwaite on July 14, 1980  2:22 PM--   grammar edited by Lewis on  6-Jan-82 17:12:28 --   rules   edited by Satterthwaite on July 14, 1980  2:22 PM --   rules   edited by Lewis on  7-Jan-82 11:07:57 --   converted to new PGS by JGS on 31-Jul-81 10:08:48 DIRECTORY  BcdDefs USING [LinkLocation],  P1: FROM "BcdParseDefs" USING [InputLoc],  ParseTable: FROM "BcdParseTable" USING [    ActionEntry, Production, ProductionInfo, Symbol, tokenID],  Symbols: FROM "BcdSymbols" USING [HTNull],  Tree: FROM "BcdTree" USING [Link, Null],  TreeOps: FROM "BcdTreeOps" USING [    PopTree, PushTree, PushHash, PushList, PushNode, SetAttr, SetInfo];BcdTreeBuild: PROGRAM    IMPORTS P1, TreeOps    EXPORTS P1 =  BEGIN OPEN TreeOps; -- Local data base (supplied by parser)  v: LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED;  l: LONG DESCRIPTOR FOR ARRAY OF CARDINAL;  q: LONG DESCRIPTOR FOR ARRAY OF ParseTable.ActionEntry;    proddata: LONG POINTER TO ProdData;  ProdData: TYPE = ARRAY ParseTable.Production OF ParseTable.ProductionInfo;    AssignDescriptors: PUBLIC PROC [	qd: LONG DESCRIPTOR FOR ARRAY OF ParseTable.ActionEntry,	vd: LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED,	ld: LONG DESCRIPTOR FOR ARRAY OF CARDINAL,	pp: LONG POINTER TO	  ARRAY ParseTable.Production OF ParseTable.ProductionInfo] = {    q ¬ qd;  v ¬ vd;  l ¬ ld;  proddata ¬ pp}; -- Node attributes:  --   attr1 - code links  --   attr2 - exports all  --   attr3 - frame links (ordering is historical)  -- NB: (~attr1 AND ~attr3) - don't care about link placement (default)    links: BcdDefs.LinkLocation;  exportsALL: BOOLEAN;     -- Interpretation rules  ProcessQueue: PUBLIC PROC [qI, top: CARDINAL] =    BEGIN    save: Tree.Link;    vTop: UNSPECIFIED;    FOR i: CARDINAL IN [0 .. qI)      DO      top ¬ top-q[i].tag.pLength+1;  vTop ¬ v[top];      SELECT proddata[q[i].transition].rule FROM        0  =>	--	    --TYPE: ParseTable	    --TABLE: BcdParseData    EXPORTS: SELF	    --GOAL:  goal	    --TERMINALS:	    --    id 	str	,	:	    --    _		;	=	]	    --    [	}	{	.	    --  DIRECTORY	FROM	PACK	CONFIGURATION	CONFIG	    --  IMPORTS	EXPORTS	CONTROL	BEGIN	    --  END 	PLUS	THEN	LINKS	    --  CODE	FRAME   ALL	    --ALIASES:	    --  id       tokenID	    --  str      tokenSTR	    --  .        InitialSymbol	    --  PRODUCTIONS:		-- goal		  ::= . source           NULL;        1  =>	-- source         ::= directory packing init config .          {PushNode[source,3];  LinkToSource[top]};        2  =>	-- directory      ::= DIRECTORY includelist ;          PushList[v[top+1]];        3  =>	-- includeitem    ::= id : FROM str          BEGIN          PushHash[v[top]];  PushHash[v[top+3]];  PushNode[item,2];          LinkToSource[top];          END;        4  =>	-- packing        ::= packlist ;          PushList[v[top]];        5  =>	-- packlist       ::= PACK idlist           {PushList[v[top+1]];  LinkToSource[top];  vTop ¬ 1};        6  =>	-- packlist       ::= packlist ; PACK idlist          {PushList[v[top+3]];  LinkToSource[top];  vTop ¬ v[top]+1};        7  =>	-- init           ::=           {links ¬ dontcare;  exportsALL ¬ FALSE};        8  =>	-- config         ::= id : CONFIG links imports exports control = body              	-- config         ::= id : CONFIGURATION links imports exports control = body           BEGIN          save ¬ PopTree[];	  PushHash[v[top]];  PushTree[save];  PushNode[config,5];          SetAttr[2, exportsALL];  LinkToSource[top];          links ¬ v[top+3];  exportsALL ¬ v[top+5];  -- restore old values          END;        9  =>	-- links          ::=           vTop ¬ links;   -- inherit link location       10  =>	-- links          ::= LINKS : CODE          {vTop ¬ links;  links ¬ code};       11  =>	-- links          ::= LINKS : FRAME          {vTop ¬ links;  links ¬ frame};       12  =>	-- imports        ::= IMPORTS itemlist		-- body           ::= BEGIN statementlist END		-- body           ::= { statementlist }		-- leftside       ::= [ itemlist ]          PushList[v[top+1]];       13  =>	-- control        ::= CONTROL idlist           PushList[v[top+1]];       14  =>	-- statement      ::= leftside _ module           {PushNode[assign,2];  LinkToSource[top]};       15  =>	-- statement      ::= leftside _ interface           {PushNode[assign,2];  LinkToSource[top]};       16  =>	-- statement      ::= item links          BEGIN          SetLinkAttributes[];          PushTree[Tree.Null];	  PushNode[module, 2];  SetLinkAttributes[];  LinkToSource[top];          links ¬ v[top+1];          END;	         17  =>	-- module         ::= item [ ] links          BEGIN          SetLinkAttributes[];          PushTree[Tree.Null];	  PushNode[module, 2];  SetLinkAttributes[];  LinkToSource[top];          links ¬ v[top+3];          END;       18  =>	-- module         ::= item [ idlist ] links          BEGIN          PushList[v[top+2]];  save ¬ PopTree[];          SetLinkAttributes[];          PushTree[save];	  PushNode[module, 2];  SetLinkAttributes[];  LinkToSource[top];          links ¬ v[top+4];          END;       19  =>	-- interface      ::= id           PushHash[v[top]];       20  =>	-- interface      ::= interface THEN id           {PushHash[v[top+2]];  PushNode[then, 2];  LinkToSource[top]};       21  =>	-- interface      ::= interface PLUS id           {PushHash[v[top+2]];  PushNode[plus, 2];  LinkToSource[top]};       22  =>	-- item           ::= id           BEGIN          PushHash[v[top]];  PushTree[Tree.Null];	  PushNode[item, 2];  LinkToSource[top];          END;       23  =>	-- item           ::= id : id           BEGIN          PushHash[v[top]];  PushHash[v[top+2]];	  PushNode[item, 2];  LinkToSource[top];          END;       24  =>	-- idlist         ::= id           {PushHash[v[top]];  vTop ¬ 1};       25  =>	-- idlist         ::= idlist , id           {PushHash[v[top+2]];  vTop ¬ v[top]+1};       26  =>	--  statementlist	::= statementlist ;		--  statement		::= module		--  statement		::= config		--  leftside		::= item          NULL;       27  =>	-- imports        ::= 		-- control        ::= 		-- directory      ::= 		-- packing        ::=           {PushTree[Tree.Null];  l[top] ¬ P1.InputLoc[]};       28  =>	-- includelist    ::= includeitem		-- statementlist  ::= statement		-- itemlist       ::= item          vTop ¬ 1;       29  =>	-- includelist    ::= includelist , includeitem		-- statementlist  ::= statementlist ; statement		-- itemlist       ::= itemlist , item          vTop ¬ v[top]+1;       30  =>	-- exports        ::= EXPORTS expinit exportlist          {vTop ¬ v[top+1];  PushList[v[top+2]]};	         31  =>	-- exports        ::=           {PushTree[Tree.Null];  l[top] ¬ P1.InputLoc[];  vTop ¬ exportsALL};	         32  =>   -- expinit        ::=           {vTop ¬ exportsALL;  exportsALL ¬ FALSE};       33  =>   -- exportlist     ::= item          vTop ¬ 1;       34  =>	-- exportlist     ::= ALL          {exportsALL ¬ TRUE;  vTop ¬ 0};       35  =>   -- exportlist     ::= exportlist , item          vTop ¬ v[top]+1;       36  =>	-- exportlist     ::= exportlist , ALL          {exportsALL ¬ TRUE;  vTop ¬ v[top]};       ENDCASE => ERROR;      v[top] ¬ vTop;      ENDLOOP;    END;      LinkToSource: PROC [index: CARDINAL] = INLINE {SetInfo[l[index]]};    SetLinkAttributes: PROC = {    SELECT links FROM      dontcare => {SetAttr[1, FALSE];  SetAttr[3, FALSE]};      frame    => {SetAttr[1, FALSE];  SetAttr[3, TRUE]};      code     => {SetAttr[1, TRUE];   SetAttr[3, FALSE]};      ENDCASE => ERROR};          TokenValue: PUBLIC PROC [s: ParseTable.Symbol] RETURNS [UNSPECIFIED] = {    RETURN[      SELECT s FROM        ParseTable.tokenID => Symbols.HTNull,        ENDCASE => 0]};  END.
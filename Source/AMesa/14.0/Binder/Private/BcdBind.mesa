-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- BcdBind.mesa--   Satterthwaite	June 2, 1980  11:24 AM--   Lewis		 4-Mar-82 17:58:07--   Johnsson		10-Aug-83 12:35:24DIRECTORY  Alloc USING [AddNotify, Bounds, DropNotify, Handle, Notifier, Top],  BcdBindDefs USING [RelocHandle],  BcdControlDefs USING [BinderData, data],  BcdDefs USING [    CTIndex, cttype, cxtype, EXPIndex, EXPNull, exptype,    FTIndex, FTNull, fttype, GFIndex, IMPIndex, IMPNull, IMPRecord, imptype,    LFIndex, LFNull, lftype, Link, MTIndex, MTRecord, mttype,    NameRecord, nullLink, NullName, sstype, sttype, treetype, unboundLink],  BcdErrorDefs USING [    ErrorHti, ErrorInterface, ErrorSti, GetModule, GetSti, WrongImportVersion],  BcdOps USING [NameString],  BcdUtilDefs USING [    EqVersions, GetDummyGfi, GetGfi, GetGfiForLink, GetGfiForMti, InstanceName,    NameForSti],  String USING [SubStringDescriptor],  Symbols: FROM "BcdSymbols" USING [    CXIndex, CXNull, HTIndex, STIndex, STNull, STRecord],  SymbolOps: FROM "BcdSymbolOps" USING [FindString],  Table USING [Base],  Tree: FROM "BcdTree" USING [Scan, Null],  TreeOps: FROM "BcdTreeOps" USING [ScanList];BcdBind: PROGRAM    IMPORTS Alloc, BcdControlDefs, BcdErrorDefs, BcdUtilDefs, SymbolOps, TreeOps    EXPORTS BcdControlDefs =  BEGIN OPEN BcdDefs, Symbols;    gd: BcdControlDefs.BinderData ¬ NIL;  zone: UNCOUNTED ZONE ¬ NIL;  table: Alloc.Handle ¬ NIL;  tb, stb, ctb, cxb, mtb, lfb, etb, itb, ftb: Table.Base;  ssb: BcdOps.NameString;  Notifier: Alloc.Notifier = {    tb  ¬ base[treetype];  stb ¬ base[sttype];  cxb ¬ base[cxtype];    ctb ¬ base[cttype];    mtb ¬ base[mttype];  lfb ¬ base[lftype];    etb ¬ base[exptype];   itb ¬ base[imptype];    ftb ¬ base[fttype];    ssb ¬ base[sstype]};  BindError: PUBLIC ERROR = CODE;  Error: PROC = {ERROR BindError};  ItiToIndex: PROC [impi: IMPIndex] RETURNS [CARDINAL] = INLINE {    RETURN[LOOPHOLE[impi, CARDINAL]/SIZE[IMPRecord]]};  relocationHead: BcdBindDefs.RelocHandle ¬ NIL;  rel: BcdBindDefs.RelocHandle ¬ NIL;  BindRoot: PUBLIC PROC [relocationRoot: BcdBindDefs.RelocHandle] = {    ENABLE UNWIND => CleanupBinding[];    gd ¬ BcdControlDefs.data;    zone ¬ gd.zone;    table ¬ gd.ownTable;    table.AddNotify[Notifier, NIL];    relocationHead ¬ relocationRoot;    SetupGFMap[];    AssignImports[      ! BcdErrorDefs.GetSti => {          IF rel # NIL THEN            RESUME[StiForContext[              IF rel.type = inner THEN rel.parentcx ELSE rel.context]]}];    BindModules[];    CleanupBinding[]};      CleanupBinding: PROC = {    ReleaseGFMap[];    IF table # NIL THEN {table.DropNotify[Notifier, NIL];  table ¬ NIL};    zone ¬ NIL;    gd ¬ NIL};  LinkType: TYPE = RECORD [    SELECT tag:* FROM      gfi    => [gfi: GFIndex],      import => [impi: IMPIndex],      ENDCASE];  GFMapItem: TYPE = RECORD [    linkItem: LinkType,    expi: EXPIndex];  GFMap: TYPE = RECORD [SEQUENCE length: CARDINAL OF GFMapItem];  RelMap: TYPE = RECORD [SEQUENCE length: CARDINAL OF CARDINAL];  finalFirstDummy: GFIndex;  gfMap: LONG POINTER TO GFMap ¬ NIL;  relMap: LONG POINTER TO RelMap ¬ NIL;  SetupGFMap: PROC = {    nDummies: CARDINAL ¬ BcdUtilDefs.GetDummyGfi[0]-1;    nImports: CARDINAL = table.Bounds[imptype].size/SIZE[IMPRecord];    finalFirstDummy ¬ BcdUtilDefs.GetGfi[0];    IF nDummies # 0 THEN nDummies ¬ nDummies + 1;    gfMap ¬ zone.NEW[GFMap[nDummies]];    FOR i: CARDINAL IN [0..nDummies) DO gfMap[i] ¬ [[gfi[0]], EXPNull] ENDLOOP;    relMap ¬ zone.NEW[RelMap[nImports]];    FOR rel: BcdBindDefs.RelocHandle ¬ relocationHead, rel.link UNTIL rel = NIL DO      FOR iti: IMPIndex ¬ FIRST[IMPIndex]+rel.import, iti+SIZE[IMPRecord]        UNTIL iti = rel.importLimit DO        relMap[ItiToIndex[iti]] ¬          itb[iti].gfi + rel.dummygfi-rel.originalfirstdummy;        ENDLOOP;      ENDLOOP};  RelocatedGfi: PROC [iti: IMPIndex] RETURNS [CARDINAL] = {    RETURN[IF iti = IMPNull THEN 0 ELSE relMap[ItiToIndex[iti]]]};  ReleaseGFMap: PROC = {    IF gfMap # NIL THEN zone.FREE[@gfMap];    IF relMap # NIL THEN zone.FREE[@relMap]};  NameToHti: PROC [name: NameRecord] RETURNS [hti: HTIndex] = {    found: BOOLEAN;    ss: String.SubStringDescriptor ¬ [      base: @ssb.string, offset: name, length: ssb.size[name]];    [found, hti] ¬ SymbolOps.FindString[@ss];    IF ~found THEN Error[]};  ExpiForSti: PROC [sti: STIndex] RETURNS [EXPIndex] = {    RETURN [IF sti = STNull      THEN EXPNull      ELSE	WITH s:stb[sti] SELECT FROM	  external => WITH m:s.map SELECT FROM interface => m.expi, ENDCASE => EXPNull,	  ENDCASE => EXPNull]};  AssignImports: PROC = {    saveIndex: CARDINAL = gd.textIndex;    saveName: NameRecord = gd.currentName;    FOR rel ¬ relocationHead, rel.link UNTIL rel = NIL DO      gd.textIndex ¬ rel.textIndex;      gd.currentName ¬ BcdUtilDefs.NameForSti[StiForContext[rel.context]];      SELECT TRUE FROM	(rel.type = outer) =>  AssignOuter[rel];	(rel.parameters # Tree.Null) =>  AssignByPosition[rel];	ENDCASE =>  AssignByName[rel];      ENDLOOP;    gd.textIndex ¬ saveIndex;  gd.currentName ¬ saveName};    AssignOuter: PROC [rel: BcdBindDefs.RelocHandle] = {    FOR iti: IMPIndex ¬ FIRST[IMPIndex]+rel.import, iti+SIZE[IMPRecord]      UNTIL iti = rel.importLimit DO      sti: STIndex = LookupInstance[iti, rel.context];      IF sti = STNull THEN LOOP;      IF stb[sti].impi # IMPNull	THEN {	  OPEN imp: itb[stb[sti].impi];	  stb[sti].impgfi ¬ imp.gfi ¬ BcdUtilDefs.GetGfi[]}        ELSE BcdErrorDefs.ErrorSti[error, "is not imported by any module"L, sti];      ENDLOOP};  AssignByName: PROC [rel: BcdBindDefs.RelocHandle] = {    iti, import: IMPIndex;    export: EXPIndex;    defgfi: CARDINAL;    sti, parentSti: STIndex;    FOR iti ¬ FIRST[IMPIndex]+rel.import, iti+SIZE[IMPRecord]    UNTIL iti = rel.importLimit DO      sti ¬ IF rel.type = inner		THEN LookupInstance[iti, rel.context]		ELSE LookupInterface[iti, rel.context];      IF sti = STNull THEN LOOP;      defgfi ¬ stb[sti].impgfi;      IF stb[sti].impi # IMPNull	THEN          SELECT rel.type FROM            inner => {              IF (parentSti ¬ LookupInterface[iti, rel.parentcx]) = STNull                THEN LOOP;              import ¬ stb[parentSti].impi;  export ¬ ExpiForSti[parentSti];              defgfi ¬ stb[parentSti].impgfi;              sti ¬ parentSti};            ENDCASE => {import ¬ stb[sti].impi; export ¬ ExpiForSti[sti]}        ELSE {import ¬ IMPNull; export ¬ ExpiForSti[sti]};      WITH s: stb[sti] SELECT FROM	external =>	  WITH m:s.map SELECT FROM	    module => AssignModule[defgfi, m.mti, iti];	    interface => AssignInterface[defgfi, import, export, iti];	    unknown => AssignImport[defgfi, import, iti];	    ENDCASE => Error[];	unknown => AssignImport[defgfi, import, iti];	ENDCASE => Error[];      ENDLOOP};  LookupInstance: PROC [iti: IMPIndex, cxi: CXIndex] RETURNS [STIndex] = {    RETURN[IF cxi = CXNull      THEN STNull      ELSE Lookup[	      hti: NameToHti[IF itb[iti].namedInstance			THEN BcdUtilDefs.InstanceName[[import[iti]]]			ELSE itb[iti].name],	      cxi: rel.context]]};  LookupInterface: PROC [iti: IMPIndex, cxi: CXIndex] RETURNS [STIndex] = {    RETURN[      IF cxi = CXNull THEN STNull ELSE Lookup[NameToHti[itb[iti].name], cxi]]};  AssignByPosition: PROC [rel: BcdBindDefs.RelocHandle] = {    iti: IMPIndex;    TooManyParameters: ERROR = CODE;    AssignPosition: Tree.Scan = {      sti: STIndex = WITH t SELECT FROM symbol => index, ENDCASE => ERROR;      import: IMPIndex = stb[sti].impi;      export: EXPIndex = ExpiForSti[sti];      defgfi: CARDINAL = stb[sti].impgfi;      IF iti = rel.importLimit THEN ERROR TooManyParameters;      WITH s: stb[sti] SELECT FROM        external =>          WITH m:s.map SELECT FROM            module => AssignModule[defgfi, m.mti, iti];            interface => AssignInterface[defgfi, import, export, iti];            unknown => AssignImport[defgfi, import, iti];            ENDCASE => Error[];        ENDCASE => BcdErrorDefs.ErrorSti[error, "is undeclared"L, sti];      iti ¬ iti + SIZE[BcdDefs.IMPRecord]};    iti ¬ FIRST[IMPIndex] + rel.import;    TreeOps.ScanList[rel.parameters, AssignPosition !       TooManyParameters => {GOTO tooMany}];    IF iti # rel.importLimit THEN GOTO tooFew;    EXITS      tooMany =>  BcdErrorDefs.ErrorHti[error,	  "has too many parameters"L, HtiForRelocation[rel]];      tooFew =>  BcdErrorDefs.ErrorHti[error,	  "has too few parameters"L, HtiForRelocation[rel]]};  MakeLink: PROC [defgfi: CARDINAL, import: IMPIndex]      RETURNS [LinkType] = {    RETURN[SELECT TRUE FROM      (defgfi # 0) => [gfi[defgfi]],      (import = IMPNull) => [gfi[0]],      ENDCASE => [import[import]]]};  AssignModule: PROC [defgfi: GFIndex, mti: MTIndex, iti: IMPIndex] = {    OPEN imp: itb[iti];    gfi: CARDINAL = RelocatedGfi[iti];    IF imp.port # module OR ~BcdUtilDefs.EqVersions[imp.file, mtb[mti].file]     THEN      BcdErrorDefs.WrongImportVersion[	class: error, avail: mtb[mti].file, req: imp.file];    gfMap[gfi] ¬ [      linkItem: [gfi[IF defgfi # 0 THEN defgfi ELSE BcdUtilDefs.GetGfiForMti[mti]]],      expi: EXPNull]};  AssignInterface: PROC [      defgfi: GFIndex, import: IMPIndex, expi: EXPIndex, iti: IMPIndex] = {    OPEN exp: etb[expi], imp: itb[iti];    gfi: CARDINAL = RelocatedGfi[iti];    IF expi # EXPNull AND     (imp.port # exp.port OR ~BcdUtilDefs.EqVersions[imp.file, exp.file]) THEN        BcdErrorDefs.WrongImportVersion[	  class: error, avail: exp.file, req: imp.file];    IF imp.port = module THEN        gfMap[gfi] ¬ [          linkItem: [gfi[BcdUtilDefs.GetGfiForLink[etb[expi].links[0]]]],          expi: EXPNull]    ELSE gfMap[gfi] ¬ [        linkItem: MakeLink[defgfi, import],        expi: expi]};  AssignImport: PROC [defgfi: GFIndex, import: IMPIndex, iti: IMPIndex] = {    OPEN imp: itb[iti];    gfi: CARDINAL = RelocatedGfi[iti];    IF import # IMPNull AND     (imp.port # itb[import].port OR      ~BcdUtilDefs.EqVersions[imp.file, itb[import].file]) THEN        BcdErrorDefs.WrongImportVersion[	  class: error, avail: itb[import].file, req: imp.file];    gfMap[gfi] ¬ [        linkItem: MakeLink[defgfi, import],        expi: EXPNull]};  Lookup: PROC [hti: HTIndex, cxi: CXIndex] RETURNS [sti: STIndex] = {    FOR sti ¬ cxb[cxi].link, stb[sti].link UNTIL sti = STNull DO      IF stb[sti].hti = hti THEN RETURN ENDLOOP;    RETURN [STNull]};  StiForContext: PROC [cxi: CXIndex] RETURNS [sti: STIndex] = {    stLimit: STIndex = table.Top[sttype];    FOR sti ¬ FIRST[STIndex], sti+SIZE[STRecord] UNTIL sti = stLimit DO      WITH s:stb[sti] SELECT FROM        local => IF s.context = cxi THEN RETURN;        ENDCASE;      ENDLOOP;    RETURN[STNull]};  HtiForRelocation: PROC [rel: BcdBindDefs.RelocHandle] RETURNS [HTIndex] = {    sti: STIndex;    mti: MTIndex;    cti: CTIndex;    IF rel.type # file THEN {      sti ¬ StiForContext[rel.context];  RETURN [stb[sti].hti]};    mti ¬ FIRST[MTIndex] + rel.module;  cti ¬ FIRST[CTIndex] + rel.config;    RETURN[      NameToHti[IF mtb[mti].config = cti THEN ctb[cti].name ELSE mtb[mti].name]]};  BindModules: PROC = {    saveIndex: CARDINAL = gd.textIndex;    saveName: NameRecord = gd.currentName;    mtLimit: MTIndex = table.Top[mttype];    rel ¬ relocationHead;    FOR mti: MTIndex ¬ FIRST[MTIndex], mti + SIZE[MTRecord] UNTIL mti = mtLimit DO      SetRelocationForModule[mti];      BindFragment[mti, mtb[mti].links];      ENDLOOP;    gd.textIndex ¬ saveIndex;  gd.currentName ¬ saveName};  SetRelocationForModule: PROC [mti: MTIndex] = {    gfi: GFIndex = BcdUtilDefs.GetGfiForMti[mti];    FOR rel ¬ rel, rel.link UNTIL rel = NIL DO      IF gfi IN [rel.firstgfi..rel.lastgfi] THEN GOTO found ENDLOOP;    FOR rel ¬ relocationHead, rel.link UNTIL rel = NIL DO      IF gfi IN [rel.firstgfi..rel.lastgfi] THEN GOTO found ENDLOOP;    Error[];    EXITS found => {      gd.textIndex ¬ rel.textIndex;      gd.currentName ¬ BcdUtilDefs.NameForSti[StiForContext[rel.context]]}};  BindFragment: PROC [mti: MTIndex, lfi: LFIndex] = {    IF lfi # LFNull THEN      FOR i: CARDINAL IN [0 .. lfb[lfi].length) DO	lfb[lfi].frag[i] ¬ RelocateLink[lfb[lfi].frag[i]	    ! BcdErrorDefs.GetModule => {RESUME [mti, i*SIZE[BcdDefs.Link]]}];	ENDLOOP};      SetLinkGfi: PROC [link: POINTER TO BcdDefs.Link, gfi: BcdDefs.GFIndex] = {    WITH l: link SELECT FROM      procedure => l.gfi ¬ gfi;      signal => l.gfi ¬ gfi;      variable => l.gfi ¬ gfi;      ENDCASE => ERROR};    RelocateLink: PROC [cl: BcdDefs.Link] RETURNS [BcdDefs.Link] = {    gfi, originalGfi: GFIndex;    ep: CARDINAL;    WITH l: cl SELECT FROM      procedure => {gfi ¬ l.gfi; ep ¬ l.ep};       variable => {gfi ¬ l.gfi; ep ¬ l.offset};      signal => {gfi ¬ l.gfi; ep ¬ l.index};      ENDCASE => ERROR;    originalGfi ¬ gfi;    SELECT TRUE FROM      (gfi = 0) => NULL;      (gfi < rel.originalfirstdummy) => SetLinkGfi[@cl, gfi + rel.firstgfi-1];      ENDCASE => {	expi: EXPIndex;	map: LONG POINTER TO GFMapItem;	gfi ¬ gfi + rel.dummygfi-rel.originalfirstdummy;	DO	  map ¬ @gfMap[gfi];	  IF (expi¬map.expi) # EXPNull THEN {	    newCl: BcdDefs.Link = etb[expi].links[ep];	    IF newCl # nullLink THEN RETURN[newCl]};	  WITH m: map.linkItem SELECT FROM	    gfi => {	      IF (gfi¬m.gfi) = 0 THEN GOTO unbindable;	      IF gfi < finalFirstDummy AND ep = 0 THEN 		RETURN[[variable[gfi: gfi, offset: 0]]]; -- imported module	      EXIT};	    import => gfi ¬ RelocatedGfi[m.impi];	    ENDCASE;	  REPEAT	    unbindable => {	      importName: NameRecord;	      importFti: FTIndex;	      [importName, importFti] ¬ LookupImport[originalGfi];	      BcdErrorDefs.ErrorInterface[		class: warning, s: "is unbindable"L, 	        importName: importName, ep: ep, 		importFti: importFti];	      RETURN [IF cl.tag = variable THEN nullLink ELSE unboundLink]};	  ENDLOOP;	SetLinkGfi[@cl, gfi]};    RETURN [cl]};  LookupImport: PROC [gfi: GFIndex]       RETURNS [importName: NameRecord, importFti: FTIndex] = {    FOR iti: IMPIndex ¬ (FIRST[IMPIndex] + rel.import),      (iti + SIZE[IMPRecord]) UNTIL iti = rel.importLimit DO        OPEN imp: itb[iti];      IF gfi = imp.gfi THEN RETURN[importName: imp.name, importFti: imp.file];      ENDLOOP;    RETURN[importName: NullName, importFti: FTNull]};  END.
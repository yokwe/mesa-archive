-- Copyright (C) 1981, 1983, 1986 by Xerox Corporation. All rights reserved. -- BcdUtilities.mesa--   Satterthwaite	July 11, 1980  8:39 AM--   Lewis		15-Dec-81 10:45:01--   Johnsson		 8-Jul-83 10:47:20--   MEW		16-Jun-86 10:29:05DIRECTORY  Alloc USING [AddNotify, Bounds, DropNotify, Handle, Notifier, Top, Words],  BcdDefs USING [    ATIndex, ATNull, ATRecord, attype, CTIndex, CTRecord, cttype, cxtype,    ENIndex, ENNull, ENRecord, entype,    EXPIndex, EXPRecord, exptype, FPIndex, FPRecord, fptype,    FTIndex, FTNull, FTRecord, FTSelf, fttype, GFIndex,    IMPIndex, IMPNull, IMPRecord, imptype, LFIndex, LFNull, lftype, Link,    LinkFrag, MTIndex, MTRecord, mttype, Namee, NameRecord, NTIndex,    NTRecord, nttype, NullLink, NullName, NullVersion, SGIndex, SGRecord,    sgtype, SpaceID, SPIndex, SPRecord, sptype, sttype, TMIndex, TMRecord,    tmtype, TYPIndex, TYPNull, TYPRecord, typtype, VersionStamp],  BcdDefsExtras,  BcdErrorDefs USING [RefInTwoVersions],  BcdUtilDefs USING [BcdBasePtr],  Inline USING [LongCOPY],  PrincOps USING [BytePC],  String USING [EquivalentSubString, SubString, SubStringDescriptor],  Symbols: FROM "BcdSymbols" USING [    CXIndex, CXRecord, HTIndex, HTNull, STIndex, STNull, STRecord],  SymbolOps: FROM "BcdSymbolOps" USING [    EnterString, FindEquivalentString, FindString, SubStringForHash],  Table USING [Base],  Tree: FROM "BcdTree" USING [Link];BcdUtilities: PROGRAM    IMPORTS Alloc, BcdErrorDefs, Inline, SymbolOps, String    EXPORTS BcdUtilDefs = PUBLIC  BEGIN OPEN BcdUtilDefs, BcdDefs;  STIndex: TYPE = Symbols.STIndex;  STNull: STIndex = Symbols.STNull;  HTIndex: PRIVATE TYPE = Symbols.HTIndex;  HTNull: HTIndex = Symbols.HTNull;  SubStringDescriptor: TYPE = String.SubStringDescriptor;  SubString: TYPE = String.SubString;  table: PRIVATE Alloc.Handle ¬ NIL;    mtb, lfb, sgb, ftb, ctb, itb, etb, ntb, stb, cxb: Table.Base;  enb, tyb, tmb, spb, fpb, atb: Table.Base;  Notifier: PRIVATE Alloc.Notifier = {    mtb ¬ base[mttype];  lfb ¬ base[lftype];    sgb ¬ base[sgtype];  ftb ¬ base[fttype];    ctb ¬ base[cttype];  itb ¬ base[imptype];  etb ¬ base[exptype];    ntb ¬ base[nttype];  stb ¬ base[sttype];   cxb ¬ base[cxtype];    enb ¬ base[entype];  tyb ¬ base[typtype];  tmb ¬ base[tmtype];    spb ¬ base[sptype];  fpb ¬ base[fptype]};  EnterName: PROC [ss: SubString] RETURNS [NameRecord] = {    lss: SubStringDescriptor;    hti: HTIndex = SymbolOps.EnterString[ss];    SymbolOps.SubStringForHash[@lss, hti];    RETURN[[lss.offset]]};  MapName: PROC [bcd: BcdBasePtr, n: NameRecord] RETURNS [NameRecord] = {    ss: SubStringDescriptor ¬ [      base: @bcd.ssb.string, offset: n, length: bcd.ssb.size[n]];    RETURN[EnterName[@ss]]};  MapEquivalentName: PRIVATE PROC [bcd: BcdBasePtr, n: NameRecord]      RETURNS [NameRecord] = {    ss: SubStringDescriptor ¬ [      base: @bcd.ssb.string, offset: n, length: bcd.ssb.size[n]];    found: BOOLEAN;    hti: HTIndex;    [found, hti] ¬ SymbolOps.FindString[@ss];    IF ~found THEN [found, hti] ¬ SymbolOps.FindEquivalentString[@ss];    RETURN[[IF found THEN NameForHti[hti] ELSE EnterName[@ss]]]};  HtiForName: PROC [bcd: BcdBasePtr, n: NameRecord] RETURNS [HTIndex] = {    ss: SubStringDescriptor ¬ [      base: @bcd.ssb.string, offset: n, length: bcd.ssb.size[n]];    RETURN[SymbolOps.EnterString[@ss]]};  NameForHti: PROC [hti: HTIndex] RETURNS [NameRecord] = {    ss: SubStringDescriptor;    SymbolOps.SubStringForHash[@ss, hti];    RETURN[[ss.offset]]};  NameForSti: PROC [sti: STIndex] RETURNS [NameRecord] = {    RETURN[NameForHti[stb[sti].hti]]};  ContextForTree: PROC [t: Tree.Link] RETURNS [Symbols.CXIndex] = {    RETURN[WITH t SELECT FROM      symbol => WITH stb[index] SELECT FROM local => context, ENDCASE => ERROR,      ENDCASE => ERROR]};  EqVersions: PROC [fti1, fti2: FTIndex] RETURNS [BOOLEAN] = {    RETURN[fti1 = fti2 OR ftb[fti1].version = ftb[fti2].version]};  EquivalentVersions: PROC [v1, v2: VersionStamp] RETURNS [BOOLEAN] =     {RETURN[v1 = v2]};  InsertFile: PRIVATE PROC [      fn: NameRecord, version: VersionStamp] RETURNS [fti: FTIndex] = {    ftLimit: FTIndex = LOOPHOLE[table.Bounds[fttype].size];    mismatched: BOOLEAN ¬ FALSE;    otherVersion: VersionStamp;    FOR fti ¬ FIRST[FTIndex], fti+SIZE[FTRecord] UNTIL fti = ftLimit DO      IF ftb[fti].name = fn THEN        SELECT TRUE FROM          (ftb[fti].version = NullVersion) => {ftb[fti].version ¬ version; EXIT};          EquivalentVersions[ftb[fti].version, version],	   (version = NullVersion) => EXIT;          ENDCASE => {mismatched ¬ TRUE;  otherVersion ¬ ftb[fti].version};      REPEAT	FINISHED => {	  fti ¬ table.Words[fttype, SIZE[FTRecord]];	  ftb[fti] ¬ [name: fn, version: version];	  IF mismatched THEN BcdErrorDefs.RefInTwoVersions[	    class: warning, fileName: fn, v1: version, v2: otherVersion]};      ENDLOOP;    RETURN};  MergeFile: PROC [bcd: BcdBasePtr, oldFti: FTIndex] RETURNS [FTIndex] = {    fn: NameRecord;    IF oldFti = FTSelf OR oldFti = FTNull THEN RETURN[oldFti];    fn ¬ MapEquivalentName[bcd, bcd.ftb[oldFti].name];    RETURN[InsertFile[fn, bcd.ftb[oldFti].version]]};  EnterFile: PROC [name: LONG STRING] RETURNS [FTIndex] = {    ss: SubStringDescriptor ¬ [base:name, offset:0, length:name.length];    fn: NameRecord;    found: BOOLEAN;    hti: HTIndex;    nullV: VersionStamp ¬ NullVersion;    IF ss.base[ss.offset+ss.length-1] = '. THEN ss.length ¬ ss.length-1;    IF ss.length > 4 THEN {      ext: SubStringDescriptor ¬ [base:".bcd"L, offset:0, length:4];      st: SubStringDescriptor ¬ [base: ss.base, offset: ss.offset+ss.length-4, length: 4];      IF String.EquivalentSubString[@st, @ext] THEN ss.length ¬ ss.length-4};    [found, hti] ¬ SymbolOps.FindString[@ss];    IF ~found THEN [found, hti] ¬ SymbolOps.FindEquivalentString[@ss];    fn ¬ IF found THEN NameForHti[hti] ELSE EnterName[@ss];    RETURN[InsertFile[fn, nullV]]};  SetFileVersion: PROC [fti: FTIndex, v: VersionStamp] = {    OPEN file: ftb[fti];    SELECT TRUE FROM      (file.version = NullVersion) => file.version ¬ v;      EquivalentVersions[file.version, v] => NULL;      ENDCASE => 	BcdErrorDefs.RefInTwoVersions[	  class: warning, fileName: file.name, v1: v, v2: file.version]};	    GetGfiForLink: PROC [link: BcdDefs.Link] RETURNS [gfi: BcdDefs.GFIndex] =     BEGIN    RETURN[WITH l: link SELECT FROM      procedure => l.gfi,      variable => l.gfi,      signal => l.gfi,      ENDCASE => ERROR]    END;      nextGfi: CARDINAL;  nextDummyGfi: CARDINAL;  GetGfi: PROC [n: CARDINAL ¬ 1] RETURNS [gfi: GFIndex] = {    -- can be called with n = 0!    gfi ¬ nextGfi;    nextGfi ¬ nextGfi + n};  GetDummyGfi: PROC [n: CARDINAL ¬ 1] RETURNS [gfi: CARDINAL] = {    -- can be called with n = 0!    gfi ¬ nextDummyGfi;    nextDummyGfi ¬ nextDummyGfi + n};      NewContext: PROC RETURNS [ctx: Symbols.CXIndex] = {    ctx ¬ table.Words[cxtype, SIZE[Symbols.CXRecord]];    cxb[ctx] ¬ [link: STNull]};  NewSemanticEntry: PROC [hti: HTIndex] RETURNS [sti: STIndex] = {    sti ¬ table.Words[sttype, SIZE[Symbols.STRecord]];    stb[sti] ¬ [      filename: FALSE, assigned: FALSE,      imported: FALSE, exported: FALSE,      hti: HTNull,      link: STNull,      impi: IMPNull, impgfi: 0,      body: unknown[]];    stb[sti].hti ¬ hti};  EnterConfig: PROC [        bcd: BcdBasePtr, oldCti: CTIndex, name: HTIndex]      RETURNS [cti: CTIndex] = {    OPEN old: bcd.ctb[oldCti];    size: CARDINAL = SIZE[CTRecord] + old.nControls*SIZE[Namee];    cti ¬ table.Words[cttype, size];    Inline.LongCOPY[from: @old, to: @ctb[cti], nwords: size];    ctb[cti].name ¬ MapName[bcd, old.name];    IF name # HTNull THEN {      ctb[cti].namedInstance ¬ TRUE; CreateInstanceName[name, [config[cti]]]}    ELSE IF old.namedInstance THEN       CopyInstanceName[bcd, [config[oldCti]], [config[cti]]]};    anyNewModules: PUBLIC BOOLEAN ¬ FALSE;  EnterModule: PROC [bcd: BcdBasePtr, oldMti: MTIndex, name: HTIndex]      RETURNS [mti: MTIndex] = {    OPEN old: bcd.mtb[oldMti];    mti ¬ table.Words[mttype, SIZE[MTRecord]];    Inline.LongCOPY[to: @mtb[mti], from: @old, nwords: SIZE[MTRecord]];    mtb[mti].name ¬ MapName[bcd, old.name];    anyNewModules ¬ anyNewModules OR (old.spare = BcdDefsExtras.NewMesaModule);    IF name # HTNull THEN {      mtb[mti].namedInstance ¬ TRUE; CreateInstanceName[name, [module[mti]]]}    ELSE IF old.namedInstance THEN       CopyInstanceName[bcd, [module[oldMti]], [module[mti]]];    IF old.atoms # ATNull THEN mtb[mti].atoms ¬ EnterAtoms[bcd, old.atoms];    mtb[mti].entries ¬ EnterEntries[bcd, old.entries];    mtb[mti].links ¬ EnterLinks[bcd, old.links]};  EnterAtomName: PRIVATE PROC [ss: SubString] RETURNS [NameRecord] = {    ERROR};  MapAtomName: PRIVATE PROC [bcd: BcdBasePtr, n: NameRecord] RETURNS [NameRecord] = {    ss: SubStringDescriptor ¬ [      base: @bcd.apb.string, offset: n, length: bcd.apb.size[n]];    RETURN[EnterAtomName[@ss]]};  EnterAtoms: PRIVATE PROC [bcd: BcdBasePtr, oldAti: ATIndex] RETURNS [ati: ATIndex] = {    OPEN old: bcd.atb[oldAti];    size: CARDINAL = SIZE[ATRecord[old.nAtoms]];    ati ¬ table.Words[attype, size];    Inline.LongCOPY[from: @old, to: @atb[ati], nwords: size];    FOR i: CARDINAL IN [0..atb[ati].nAtoms) DO      atb[ati].atom[i] ¬ MapAtomName[bcd, atb[ati].atom[i]];      ENDLOOP};  EnterEntries: PRIVATE PROC [      bcd: BcdBasePtr, oldEni: ENIndex] RETURNS [eni: ENIndex] = {    IF oldEni = ENNull THEN eni ¬ ENNull    ELSE {      OPEN old: bcd.enb[oldEni];      nWords: CARDINAL = old.nEntries*SIZE[PrincOps.BytePC];      eni ¬ table.Words[entype, SIZE[ENRecord]+nWords];      Inline.LongCOPY[to: @enb[eni], from: @old, nwords: SIZE[ENRecord]+nWords];      RETURN}};  EnterLinks: PRIVATE PROC [      bcd: BcdBasePtr, oldLfi: LFIndex] RETURNS [lfi: LFIndex] = {    IF oldLfi = LFNull THEN lfi ¬ LFNull    ELSE {      OPEN old: bcd.lfb[oldLfi];      size: CARDINAL = SIZE[LinkFrag[old.length]];      lfi ¬ table.Words[lftype, size];      Inline.LongCOPY[to: @lfb[lfi], from: @old, nwords: size]}};  EnterSegment: PROC [seg: SGRecord] RETURNS [sgi: SGIndex] = {    sgLimit: SGIndex = LOOPHOLE[table.Bounds[sgtype].size];    FOR sgi ¬ FIRST[SGIndex], sgi+SIZE[SGRecord] UNTIL sgi = sgLimit DO       IF sgb[sgi] = seg THEN RETURN;      ENDLOOP;    sgi ¬ table.Words[sgtype, SIZE[SGRecord]];    sgb[sgi] ¬ seg};  EnterImport: PROC [bcd: BcdBasePtr, oldIti: IMPIndex, copyName: BOOLEAN]      RETURNS [iti: IMPIndex] = {    OPEN old: bcd.itb[oldIti];    iti ¬ table.Words[imptype, SIZE[IMPRecord]];    itb[iti] ¬ old;    itb[iti].name ¬ MapName[bcd, old.name];    IF copyName AND old.namedInstance THEN      CopyInstanceName[bcd, [import[oldIti]], [import[iti]]]    ELSE itb[iti].namedInstance ¬ FALSE};  EnterExport: PROC [        bcd: BcdBasePtr, oldEti: EXPIndex, copyName: BOOLEAN]      RETURNS [eti: EXPIndex] = {    OPEN old: bcd.etb[oldEti];    size: CARDINAL = old.size*SIZE[BcdDefs.Link] + SIZE[EXPRecord];    eti ¬ table.Words[exptype, size];    etb[eti] ¬ old;    FOR i: CARDINAL IN [0..etb[eti].size) DO etb[eti].links[i] ¬ NullLink ENDLOOP;    etb[eti].name ¬ MapName[bcd, old.name];    IF copyName AND old.namedInstance THEN      CopyInstanceName[bcd, [export[oldEti]], [export[eti]]]    ELSE etb[eti].namedInstance ¬ FALSE};  EnterType: PROC [bcd: BcdBasePtr, oldTypi: TYPIndex] RETURNS [typi: TYPIndex] = {    OPEN old: bcd.tyb[oldTypi];    typLimit: TYPIndex = FIRST[TYPIndex] + table.Bounds[typtype].size;    FOR typi ¬ FIRST[TYPIndex], typi + SIZE[TYPRecord] UNTIL typi = typLimit DO      IF tyb[typi] = old THEN EXIT;      REPEAT FINISHED => {	typi ¬ table.Words[typtype, SIZE[TYPRecord]]; tyb[typi] ¬ old};      ENDLOOP};  EnterTypeMap: PROC [bcd: BcdBasePtr, oldTmi: TMIndex] RETURNS [tmi: TMIndex] = {    OPEN old: bcd.tmb[oldTmi];    tmLimit: TMIndex = table.Top[tmtype];    FOR tmi ¬ FIRST[TMIndex], tmi + SIZE[TMRecord] UNTIL tmi = tmLimit DO      IF tmb[tmi].offset = old.offset AND tmb[tmi].version = old.version THEN EXIT;      REPEAT	FINISHED => {	  tmi ¬ table.Words[tmtype, SIZE[TMRecord]];	  tmb[tmi] ¬ [version: old.version, offset: old.offset, map: TYPNull]};      ENDLOOP};  EnterSpace: PROC [bcd: BcdBasePtr, oldSpi: SPIndex] RETURNS [spi: SPIndex] = {    OPEN old: bcd.spb[oldSpi];    size: CARDINAL = SIZE[SPRecord] + old.length*SIZE[SpaceID];    spi ¬ table.Words[sptype, size];    Inline.LongCOPY[from: @old, to: @spb[spi], nwords: size];    FOR i: CARDINAL IN [0 .. spb[spi].length) DO      spb[spi].spaces[i].name ¬ MapName[bcd, old.spaces[i].name];      ENDLOOP};  EnterFramePack: PROC [      bcd: BcdBasePtr, oldFpi: FPIndex] RETURNS [fpi: FPIndex] = {    OPEN old: bcd.fpb[oldFpi];    size: CARDINAL = SIZE[FPRecord] + old.length*SIZE[MTIndex];    fpi ¬ table.Words[fptype, size];    Inline.LongCOPY[from: @old, to: @fpb[fpi], nwords: size];    fpb[fpi].name ¬ MapName[bcd, old.name]};  CreateInstanceName: PROC [hti: HTIndex, item: Namee] = {    nti: NTIndex = table.Words[nttype, SIZE[NTRecord]];    ntb[nti] ¬ [item: item, name: NameForHti[hti]]};  InstanceName: PROC [item: Namee] RETURNS [NameRecord] = {    ntLimit: NTIndex = LOOPHOLE[table.Bounds[nttype].size];    FOR nti: NTIndex ¬ FIRST[NTIndex], nti + SIZE[NTRecord] UNTIL nti = ntLimit DO      IF ntb[nti].item = item THEN RETURN[ntb[nti].name];      ENDLOOP;    RETURN[NullName]};  CopyInstanceName: PRIVATE PROC [bcd: BcdBasePtr, old, new: Namee] = {    nti: NTIndex = table.Words[nttype, SIZE[NTRecord]];    FOR oldNti: NTIndex ¬ FIRST[NTIndex], oldNti + SIZE[NTRecord] DO      IF (bcd.ntb[oldNti]).item = old THEN {	ntb[nti] ¬ [item: new, name: MapName[bcd, bcd.ntb[oldNti].name]];	RETURN};      ENDLOOP};  -- Administrative Procedures  Init: PROC [ownTable: Alloc.Handle] = {    table ¬ ownTable;    table.AddNotify[Notifier, NIL];     nextGfi ¬ nextDummyGfi ¬ 1;    anyNewModules ¬ FALSE};  Reset: PROC = {    table.DropNotify[Notifier, NIL];    table ¬ NIL};  END.
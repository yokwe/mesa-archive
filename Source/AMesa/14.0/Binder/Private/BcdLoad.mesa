-- Copyright (C) 1981, 1982, 1983, 1985, 1986 by Xerox Corporation. All rights reserved. -- BcdLoad.mesa - last edited by--   Satterthwaite	July 11, 1980  3:36 PM--   JGS		 4-Nov-81  8:27:34--   Lewis		29-Nov-82 10:45:41--   Johnsson		12-Sep-83 21:14:40--   Saxe                1-Apr-85 10:23:37--   MEW		16-Jun-86 10:18:31DIRECTORY  Alloc USING [AddNotify, Bounds, DropNotify, Handle, Notifier, Top, Words],  BcdBindDefs USING [BcdRelocations, RelocationType, RelocHandle],  BcdControlDefs USING [BinderData, data, Zero],  BcdDefs USING [    aptype, attype, CTIndex, CTNull, CTRecord, cttype, cxtype, entype,    EXPIndex, EXPNull, EXPRecord, exptype, FPIndex, FPNull, FPRecord, fptype,    FTIndex, FTNull, FTRecord, FTSelf, fttype, GFIndex,    IMPIndex, IMPNull, IMPRecord, imptype, Link, LinkLocation, lftype,    MTIndex, MTNull, MTRecord, mttype, Namee, NameRecord, nttype, NullLink,    NullName, SGIndex, SGRecord, sgtype, SpaceID, SPIndex, SPNull, SPRecord,    sptype, sstype, sttype, treetype, TMIndex, TMRecord, tmtype, TYPIndex,    TYPNull, typtype, VersionID],  BcdDefsExtras,  BcdErrorDefs USING [    Error, ErrorFile, ErrorHti, ErrorItem, ErrorModule, ErrorName, ErrorSti,    GetInterface, GetSti, WrongExportVersion],  BcdOps USING [BcdBase],  BcdUtilDefs USING [    BcdBasePtr, BcdBases, BcdLimits, ContextForTree,    CreateInstanceName, EnterConfig, EnterExport, EnterFramePack,    EnterImport, EnterModule, EnterSegment, EnterSpace, EnterType,    EnterTypeMap, EqVersions, GetDummyGfi, GetGfi, GetGfiForLink,    GetMtiForGfi, HtiForName, MergeFile, NameForSti, NewSemanticEntry,    SetFileVersion],  Environment USING [PageCount],  MFile USING [Error, Handle, maxNameLength, ReadOnly, Release],  MSegment USING [Address, CopyIn, Create, Delete, Error, Handle, Reset],  PrincOps USING [Port],  String USING [    AppendString, AppendSubString, EqualSubString, SubStringDescriptor],  SymbolOps: FROM "BcdSymbolOps" USING [SubStringForHash],  Symbols: FROM "BcdSymbols" USING [    CXIndex, CXNull, HTIndex, HTNull, STIndex, STMap, STNull],  Table USING [Base],  Tree: FROM "BcdTree" USING [Index, Link, NodeName, Scan, Null, NullIndex],  TreeOps: FROM "BcdTreeOps" USING [GetNode, ListLength, ScanList, UpdateList];BcdLoad: PROGRAM    IMPORTS      Alloc, BcdControlDefs, BcdErrorDefs, BcdUtilDefs, MFile, MSegment,      String, SymbolOps, TreeOps    EXPORTS BcdControlDefs =  BEGIN OPEN BcdDefs, Symbols;  BcdRelocations: TYPE = BcdBindDefs.BcdRelocations;  InterfaceOp: TYPE = Tree.NodeName [plus..then];  ExportAssigner: TYPE = PROC;  LoadError: PUBLIC ERROR = CODE;  Error: PROC = {ERROR LoadError};      DefsFile: ERROR = CODE;  IncompatibleVersion: ERROR = CODE;    gd: BcdControlDefs.BinderData ¬ NIL;  zone: UNCOUNTED ZONE ¬ NIL;  table: Alloc.Handle ¬ NIL;  tb, stb, cxb: Table.Base;    localBases: BcdUtilDefs.BcdBases;  limits: BcdUtilDefs.BcdLimits;  bcd: BcdUtilDefs.BcdBasePtr;  currentCx, loadCx: CXIndex;  loadTree: Tree.Index;  loadExpi: EXPIndex;  packSti: STIndex;  currentCti: CTIndex;  currentOp: InterfaceOp;  currentParms: Tree.Link;  exportsALL, anyTypeExportingModules: BOOLEAN;    bcdSeg: MSegment.Handle ¬ NIL;  bcdSegSize: Environment.PageCount ¬ 0;  bcdFti: BcdDefs.FTIndex;  bcdFile: MFile.Handle ¬ NIL;  bHeader: BcdOps.BcdBase ¬ NIL;  Notifier: Alloc.Notifier = {    tb ¬ base[treetype];  stb ¬ base[sttype];  cxb ¬ base[cxtype];    localBases ¬ [      ssb: LOOPHOLE[base[sstype]],      ctb: base[cttype],   mtb: base[mttype],      lfb: base[lftype],      etb: base[exptype],  enb: base[entype],      itb: base[imptype],      sgb: base[sgtype],   ftb: base[fttype],      tyb: base[typtype],  tmb: base[tmtype],      ntb: base[nttype],      spb: base[sptype],   fpb: base[fptype],      atb: base[attype],   apb: base[aptype]]};  LoadRoot: PUBLIC PROC [root: Tree.Link] RETURNS [BcdBindDefs.RelocHandle] = {     ENABLE UNWIND => CleanupLoading[];    node: Tree.Index;    gd ¬ BcdControlDefs.data;    zone ¬ gd.zone;    table ¬ gd.ownTable;    table.AddNotify[Notifier, NIL];    CreateBcdSpace[];    anyTypeExportingModules ¬ FALSE;    bcd ¬ @localBases;    currentCti ¬ CTNull;  currentOp ¬ plus;  currentParms ¬ Tree.Null;    processExports ¬ VerifyExports;    relocationHead ¬ NIL;    loadExpi ¬ EXPNull;  loadTree ¬ Tree.NullIndex;  loadCx ¬ CXNull;    exportsALL ¬ FALSE;    node ¬ TreeOps.GetNode[root];    SELECT tb[node].name FROM      source => {	packSti ¬ FindSti[tb[node].son[2]];	[] ¬ LoadLocalConfig[TreeOps.GetNode[tb[node].son[3]], outer, HTNull]};      ENDCASE => Error[];    gd.typeExported ¬ anyTypeExportingModules;    CleanupLoading[];    RETURN[relocationHead]};      CleanupLoading: PROC = {    DestroyBcdSpace[];    IF fileMap # NIL THEN zone.FREE[@fileMap];    IF table # NIL THEN {table.DropNotify[Notifier, NIL];  table ¬ NIL};    zone ¬ NIL;    gd ¬ NIL};            FindSti: PROC [t: Tree.Link] RETURNS [STIndex] = {    RETURN[      IF t = Tree.Null THEN STNull      ELSE	WITH t SELECT FROM	  symbol => index,	  subtree => FindSti[tb[index].son[1]],	  ENDCASE => ERROR LoadError]};  LoadLocalConfig: PROC [        node: Tree.Index, level: BcdBindDefs.RelocationType, name: HTIndex]      RETURNS [STMap] = {    saveCx: CXIndex = currentCx;    saveCti: CTIndex = currentCti;    newCti: CTIndex;    saveExportsAll: BOOLEAN = exportsALL;    saveLhs: Tree.Link = lhs;    saveAssigner: ExportAssigner = processExports;    saveName: NameRecord = gd.currentName;    saveIndex: CARDINAL = gd.textIndex;    firstImport: IMPIndex = LOOPHOLE[table.Bounds[imptype].size];    localRel: BcdBindDefs.RelocHandle;    nControls: CARDINAL = TreeOps.ListLength[tb[node].son[3]];    gd.textIndex ¬ tb[node].info;    lhs ¬ Tree.Null;  processExports ¬ NormalExports;    currentCx ¬ BcdUtilDefs.ContextForTree[tb[node].son[4]];    currentCti ¬ newCti ¬ table.Words[        cttype, SIZE[CTRecord] + nControls*SIZE[Namee]];      BEGIN  OPEN newConfig: localBases.ctb[currentCti];      i: CARDINAL;      AssignControl: Tree.Scan = {	newConfig.controls[i] ¬ ControlForTreeLink[t];  i ¬ i+1};      gd.currentName ¬ newConfig.name ¬ NameForLink[tb[node].son[4]];      IF name = HTNull THEN newConfig.namedInstance ¬ FALSE      ELSE {	newConfig.namedInstance ¬ TRUE;	BcdUtilDefs.CreateInstanceName[name, [config[currentCti]]]};      newConfig.file ¬ FTSelf;  newConfig.config ¬ saveCti;      newConfig.nControls ¬ nControls;      AllocateRelocations[level];      localRel ¬ rel;  localRel.parentcx ¬ saveCx;            BodyWalk[tb[node].son[5]];  -- process body of config            i ¬ 0;      TreeOps.ScanList[tb[node].son[3], AssignControl];      END;    lhs ¬ saveLhs;  processExports ¬ saveAssigner;    loadTree ¬ node;  loadCx ¬ currentCx;  currentCx ¬ saveCx;    exportsALL ¬ tb[node].attr2;     processExports[];    currentCx ¬ loadCx;    localRel.import ¬ table.Bounds[imptype].size;    localRel.dummygfi ¬ BcdUtilDefs.GetDummyGfi[0];    ProcessLocalImports[firstImport];    localRel.importLimit ¬ LOOPHOLE[table.Bounds[imptype].size];    loadTree ¬ Tree.NullIndex;  loadCx ¬ CXNull;    exportsALL ¬ saveExportsAll;    currentCti ¬ saveCti;      currentCx ¬ saveCx;      gd.currentName ¬ saveName;    gd.textIndex ¬ saveIndex;    RETURN[ STMap[config[cti: newCti]] ]};      BodyWalk: Tree.Scan = {    WITH t SELECT FROM      symbol => LoadSti[index, HTNull];      subtree => {	node: Tree.Index = index;	saveIndex: CARDINAL = gd.textIndex;	gd.textIndex ¬ tb[node].info;	SELECT tb[node].name FROM	  list   => TreeOps.ScanList[t, BodyWalk];	  item   => LoadItem[t];	  config => NULL;	  assign => LoadAssign[t];	  module => {currentParms ¬ tb[node].son[2];  LoadItem[tb[node].son[1]]};	  ENDCASE => Error[];        gd.textIndex ¬ saveIndex};      ENDCASE => Error[]};  ControlForTreeLink: PROC [t: Tree.Link] RETURNS [control: Namee] = {    WITH t SELECT FROM      symbol => {	WITH s: stb[index] SELECT FROM	  external =>	    WITH m: s.map SELECT FROM	      module => RETURN[ Namee[module[mti: m.mti]] ];	      config => RETURN[ Namee[config[cti: m.cti]] ];	      interface =>		IF localBases.etb[m.expi].port = module THEN {		  gfi: GFIndex = BcdUtilDefs.GetGfiForLink[		    localBases.etb[m.expi].links[0]];		  cModule: MTIndex = BcdUtilDefs.GetMtiForGfi[gfi];		  RETURN[ Namee[module[mti: cModule]] ]}		ELSE GOTO notvalid;	      ENDCASE => GOTO notvalid;	  local => 	    WITH m: s.map SELECT FROM	      config => RETURN[ Namee[config[cti: m.cti]] ];	      ENDCASE => GOTO notvalid;	  ENDCASE => GOTO notvalid;	EXITS	  notvalid => 	    BcdErrorDefs.ErrorHti[	      error, "is not valid as a CONTROL"L, stb[index].hti]};      ENDCASE => Error[];    RETURN[  Namee[module[mti: MTNull]] ]};      NameForLink: PROC [t: Tree.Link] RETURNS [NameRecord] = {    RETURN[      WITH t SELECT FROM        symbol => BcdUtilDefs.NameForSti[index],        ENDCASE => NullName]};  LoadSti: PROC [sti: STIndex, name: HTIndex] = {    ENABLE BcdErrorDefs.GetSti => RESUME [sti];    WITH s: stb[sti] SELECT FROM      external =>        WITH p:s SELECT FROM          file     => s.map ¬ Load[sti, name];          instance => s.map ¬ Load[p.sti, name];          ENDCASE  => Error[];      local => s.map ¬ LoadLocalConfig[s.info, inner, name];      ENDCASE => NotLoadable[sti]};  NotLoadable: PROC [sti: STIndex] = {    BcdErrorDefs.ErrorSti[error, "is not loadable (probably needs ""[]"")"L, sti]};  FileForSti: PROC [sti: STIndex] RETURNS [FTIndex] = {    RETURN[      IF sti = STNull THEN FTNull      ELSE	WITH s: stb[sti] SELECT FROM	  unknown => FTNull,	  external =>	    WITH p:s SELECT FROM	      file     => p.fti,	      instance => FileForSti[p.sti],	      ENDCASE  => ERROR LoadError,	  ENDCASE => ERROR LoadError]};  FileForPortableItem: PROC [p: PortableItem] RETURNS [FTIndex] = {    RETURN[      WITH p SELECT FROM        interface => MapFile[bcd.etb[expi].file],        module    => MapFile[bcd.mtb[mti].file],        ENDCASE   => ERROR LoadError]};  DeclarePortableItem: PROC [sti: STIndex, p: PortableItem] = {    WITH p SELECT FROM      interface => DeclareInterface[sti, expi, TRUE];      module    => DeclareModule[sti, mti, TRUE];      ENDCASE   => Error[]};  DeclareInterface: PROC [sti: STIndex, eti: EXPIndex, setMap: BOOLEAN] = {    fti: FTIndex = MapFile[bcd.etb[eti].file];    WITH s:stb[sti] SELECT FROM      external => {        IF setMap THEN s.map ¬ [interface[EXPNull]];        WITH p:s SELECT FROM          instance =>            IF p.sti = STNull THEN {	    	IF CorrectType[sti,fti] THEN s.pointer ¬ file[fti]		ELSE BcdErrorDefs.ErrorSti[error,"is incorrect type"L,sti]}	    ELSE DeclareInterface[p.sti, eti, FALSE];          file => p.fti ¬ fti;          ENDCASE => Error[]};      unknown =>        stb[sti].body ¬ external[		pointer: file[fti],		map: IF setMap THEN [interface[EXPNull]] ELSE [unknown[]]];      ENDCASE => Error[]};  DeclareModule: PROC [sti: STIndex, mti: MTIndex, setMap: BOOLEAN] = {    WITH s:stb[sti] SELECT FROM      external => {        IF setMap THEN s.map ¬ [module[MTNull]];        WITH p:s SELECT FROM          instance => DeclareModule[p.sti, mti, FALSE];          file => p.fti ¬ MapFile[bcd.mtb[mti].file];          ENDCASE => Error[]};      unknown => {        fti: FTIndex = MapFile[bcd.mtb[mti].file];        stb[sti].body ¬ external[		pointer: file[fti],		map: IF setMap THEN [module[MTNull]] ELSE [unknown[]]]};      ENDCASE => Error[]};    CorrectType:PROCEDURE[typeDeclared:STIndex,FileExported:FTIndex] RETURNS[BOOLEAN] = {  -- Added 29-Mar-85. Checks that declared type of left side is correct --    leftSsd,rightSsd:String.SubStringDescriptor;    name:BcdDefs.NameRecord = localBases.ftb[FileExported].name;    SymbolOps.SubStringForHash[@leftSsd,stb[typeDeclared].hti];    rightSsd ¬ [    	base:@localBases.ssb.string, offset:name,	length:localBases.ssb.size[name]];    RETURN[String.EqualSubString[@leftSsd,@rightSsd]];  };    currentItemLinks: BcdDefs.LinkLocation ¬ dontcare;  LoadItem: PROC [t: Tree.Link] = {    node: Tree.Index = TreeOps.GetNode[t];    IF tb[node].name # item THEN Error[];    WITH s1: tb[node].son[1] SELECT FROM      symbol => {	sti: STIndex = s1.index;	SELECT TRUE FROM	  tb[node].attr1 AND tb[node].attr3 => Error[];	  tb[node].attr1 => currentItemLinks ¬ code;	  tb[node].attr3 => currentItemLinks ¬ frame;	  ENDCASE => -- no particular links were requested in config	    currentItemLinks ¬ dontcare;	LoadSti[	  sti, 	  (IF tb[node].son[2] = Tree.Null THEN HTNull ELSE stb[sti].hti)] };      ENDCASE => Error[]};        relocationHead, rel: BcdBindDefs.RelocHandle;  fileMap: LONG POINTER TO FileMap ¬ NIL;  FileMap: TYPE = RECORD [SEQUENCE length: CARDINAL OF FTIndex];  MapFile: PROC [fti: FTIndex] RETURNS [FTIndex] = {    SELECT TRUE FROM      (bcd = @localBases) => RETURN[fti];      (fti = FTSelf)      => RETURN[bcdFti];      (fti = FTNull)      => RETURN[FTNull];      ENDCASE => {	fileIndex: CARDINAL = LOOPHOLE[fti, CARDINAL]/SIZE[FTRecord];	IF fileMap[fileIndex] = FTNull	  THEN fileMap[fileIndex] ¬ BcdUtilDefs.MergeFile[bcd, fti];	RETURN[fileMap[fileIndex]]}};  AllocateRelocations: PROC [type: BcdBindDefs.RelocationType] = {    p: BcdBindDefs.RelocHandle = zone.NEW[BcdRelocations];    BcdControlDefs.Zero[p, SIZE[BcdRelocations]];    p.link ¬ NIL;    IF relocationHead = NIL THEN relocationHead ¬ rel ¬ p    ELSE {rel.link ¬ p;  rel ¬ p};    rel.type ¬ type;    SELECT type FROM      file => {        rel.firstgfi ¬ rel.lastgfi ¬ BcdUtilDefs.GetGfi[0];        rel.dummygfi ¬ BcdUtilDefs.GetDummyGfi[0];        rel.import ¬ table.Bounds[imptype].size;        rel.importLimit ¬ LOOPHOLE[rel.import];        rel.module ¬ table.Bounds[mttype].size;        rel.config ¬ table.Bounds[cttype].size;        rel.parentcx ¬ CXNull};      outer, inner => rel.originalfirstdummy ¬ 1;      ENDCASE;    rel.textIndex ¬ gd.textIndex;    rel.context ¬ currentCx;    rel.parameters ¬ currentParms;  currentParms ¬ Tree.Null};  processExports: ExportAssigner;  Load: PROC [sti: STIndex, name: HTIndex] RETURNS [map: Symbols.STMap] = {    ENABLE UNWIND => {UnloadBcd[];  IF fileMap # NIL THEN zone.FREE[@fileMap]};    fti: FTIndex = FileForSti[sti];    nFiles: CARDINAL;    IF fti = FTNull THEN {NotLoadable[SIGNAL BcdErrorDefs.GetSti]; GOTO fail};    IF fti = gd.outputFti THEN       BcdErrorDefs.Error[error, "Output file referenced as input"L];    LoadBcd[fti      ! MFile.Error, MSegment.Error => {          BcdErrorDefs.ErrorFile[error, "cannot be opened"L, fti];           GOTO fail};        DefsFile => {          BcdErrorDefs.ErrorFile[error, "is a definitions file"L, fti];           GOTO fail};        IncompatibleVersion => {          BcdErrorDefs.ErrorFile[error, "has an incompatible version"L, fti];          GOTO fail}];    CheckInternalName[sti];    anyTypeExportingModules ¬ (anyTypeExportingModules OR bHeader.typeExported);    nFiles ¬ LOOPHOLE[limits.ft, CARDINAL]/SIZE[FTRecord];    fileMap ¬ zone.NEW[FileMap[nFiles]];    FOR i: CARDINAL IN [0..fileMap.length) DO fileMap[i] ¬ FTNull ENDLOOP;    IF limits.ct # FIRST[CTIndex] THEN {   -- configuration      map ¬ [config[LOOPHOLE[table.Top[cttype]]]];      LoadConfigs[name];       name ¬ HTNull}    ELSE map ¬ [module[LOOPHOLE[table.Top[mttype]]]];    LoadModules[name];    ProcessTypeMap[];    processExports[];    ProcessImports[];    LoadSpaces[];    LoadFramePacks[];    rel.lastgfi ¬ BcdUtilDefs.GetGfi[0]-1;    rel.importLimit ¬ LOOPHOLE[table.Bounds[imptype].size];    UnloadBcd[];    IF fileMap # NIL THEN zone.FREE[@fileMap];    RETURN[map];    EXITS fail => RETURN[Symbols.STMap[unknown[]]]};  CheckInternalName: PROC [sti: STIndex] = {     iName: NameRecord =      (IF limits.ct = FIRST[CTIndex] THEN bcd.mtb[FIRST[MTIndex]].name       ELSE bcd.ctb[FIRST[CTIndex]].name);    iHti: HTIndex = BcdUtilDefs.HtiForName[bcd, iName];    IF iHti # stb[sti].hti THEN       BcdErrorDefs.ErrorSti[        error,	"does not match the module or configuration name in the Bcd"L, sti]};  LoadBcd: PROC [fti: FTIndex] = {    bcdFti ¬ fti;    bcdFile ¬ FileForFti[bcdFti];    MSegment.CopyIn[      segment: bcdSeg, file: bcdFile, fileBase: 0, count: bcdSegSize];    IF bHeader.versionIdent # VersionID  AND       bHeader.versionIdent # BcdDefsExtras.GFTVersionID THEN ERROR IncompatibleVersion;    IF bHeader.definitions THEN ERROR DefsFile;    IF bHeader.nPages > bcdSegSize THEN {      GrowBcdSpace[minPages: bHeader.nPages];      MSegment.CopyIn[        segment: bcdSeg, file: bcdFile, fileBase: 0, count: bcdSegSize]};    BcdUtilDefs.SetFileVersion[fti, bHeader.version];    bcd ¬ zone.NEW[BcdUtilDefs.BcdBases ¬ [	ctb: LOOPHOLE[bHeader + bHeader.ctOffset],	mtb: LOOPHOLE[bHeader + bHeader.mtOffset],	lfb: LOOPHOLE[bHeader + bHeader.lfOffset],	etb: LOOPHOLE[bHeader + bHeader.expOffset],	itb: LOOPHOLE[bHeader + bHeader.impOffset],	sgb: LOOPHOLE[bHeader + bHeader.sgOffset],	ftb: LOOPHOLE[bHeader + bHeader.ftOffset],	ssb: LOOPHOLE[bHeader + bHeader.ssOffset],	enb: LOOPHOLE[bHeader + bHeader.enOffset],	tyb: LOOPHOLE[bHeader + bHeader.typOffset],	tmb: LOOPHOLE[bHeader + bHeader.tmOffset],	ntb: LOOPHOLE[bHeader + bHeader.ntOffset],	spb: LOOPHOLE[bHeader + bHeader.spOffset],	fpb: LOOPHOLE[bHeader + bHeader.fpOffset],	atb: LOOPHOLE[bHeader + bHeader.atOffset],	apb: LOOPHOLE[bHeader + bHeader.apOffset] ]];    limits ¬ [	ct: bHeader.ctLimit,  mt: bHeader.mtLimit,	et: bHeader.expLimit, it: bHeader.impLimit,	sg: bHeader.sgLimit,  ft: bHeader.ftLimit,	tm: bHeader.tmLimit,  nt: bHeader.ntLimit,	sp: bHeader.spLimit,  fp: bHeader.fpLimit];    AllocateRelocations[file];    rel.originalfirstdummy ¬ bHeader.firstdummy};      FileForFti: PROC [fti: BcdDefs.FTIndex] RETURNS [file: MFile.Handle] = {    name: BcdDefs.NameRecord = localBases.ftb[fti].name;    ssd: String.SubStringDescriptor ¬ [      base: @localBases.ssb.string,      offset: name, length: localBases.ssb.size[name]];    s: STRING ¬ [MFile.maxNameLength];    file ¬ NIL;    String.AppendSubString[s, @ssd];  String.AppendString[s, ".bcd"L];    file ¬ MFile.ReadOnly[name: s, release: [] ! MFile.Error => CONTINUE];    IF file = NIL THEN {  -- try again, without a ".bcd" suffix      s.length ¬ 0;      String.AppendSubString[s, @ssd];  -- this time, allow MFile.Error to go up      file ¬ MFile.ReadOnly[name: s, release: []]}};  UnloadBcd: PROC = {    IF bcdFile # NIL THEN {MFile.Release[bcdFile];  bcdFile ¬ NIL};    IF bcd # NIL THEN zone.FREE[@bcd];    bcd ¬ @localBases};      LoadConfigs: PROC [name: HTIndex] = {    LoadConfig: PROC [cti: CTIndex] = {      newCti: CTIndex = BcdUtilDefs.EnterConfig[bcd, cti, name];        BEGIN OPEN new: localBases.ctb[newCti];        name ¬ HTNull;        new.config ¬ 	  (IF new.config = CTNull THEN currentCti ELSE new.config + rel.config);        new.file ¬ MapFile[new.file];	FOR i: CARDINAL IN [0 .. new.nControls) DO  -- relocate controls	  WITH c: new.controls[i] SELECT FROM	    module => c.mti ¬ (c.mti + rel.module);	    config => c.cti ¬ (c.cti + rel.config);	    ENDCASE;	  ENDLOOP;        END};    EnumerateConfigurations[LoadConfig]};  EnumerateConfigurations: PROC [proc: PROC [CTIndex]] = {    cti: CTIndex ¬ FIRST[CTIndex];    UNTIL cti = limits.ct DO      proc[cti];      cti ¬ cti + (SIZE[CTRecord] + bcd.ctb[cti].nControls*SIZE[Namee]);      ENDLOOP};      LoadModules: PROC [name: HTIndex] = {    LoadModule: PROC [mti: MTIndex] RETURNS [BOOLEAN] = {      newMti: MTIndex = BcdUtilDefs.EnterModule[bcd, mti, name];        BEGIN OPEN new: localBases.mtb[newMti];        name ¬ HTNull;        new.config ¬ 	  (IF new.config = CTNull THEN currentCti ELSE new.config + rel.config);        [--new.gfi--] ¬ BcdUtilDefs.GetGfi[];        new.file ¬ MapFile[new.file];        new.code.sgi ¬ MapSegment[new.code.sgi];        new.sseg ¬ MapSegment[new.sseg];	CheckPacking[newMti];	IF new.linkLoc = dontcare THEN     -- we can override old link setting	  new.linkLoc ¬ currentItemLinks;  -- possibly also dontcare        END;      gd.nModules ¬ gd.nModules + 1;      RETURN[FALSE]};    [] ¬ EnumerateModules[LoadModule]};  EnumerateModules: PROC [      proc: PROC [MTIndex] RETURNS [BOOLEAN]] RETURNS [mti: MTIndex] = {    FOR mti ¬ FIRST[MTIndex], mti + SIZE[MTRecord] UNTIL mti = limits.mt DO      IF proc[mti] THEN RETURN;      ENDLOOP;    RETURN[MTNull]};  CheckPacking: PROC [mti: MTIndex] = {    name: NameRecord = localBases.mtb[mti].name;    FOR sti: STIndex ¬ packSti, stb[sti].link UNTIL sti = STNull DO      IF BcdUtilDefs.NameForSti[sti] = name THEN {	  stb[sti].body ¬ external[	    map: [module[mti]], pointer: file[localBases.mtb[mti].file]];	  EXIT};      ENDLOOP};  MapSegment: PROC [oldSgi: SGIndex] RETURNS [SGIndex] = {    seg: SGRecord ¬ bcd.sgb[oldSgi];    seg.file ¬ MapFile[seg.file];    RETURN[BcdUtilDefs.EnterSegment[seg]]};  ProcessTypeMap: PROC = {    FOR tmi: TMIndex ¬ FIRST[TMIndex], tmi + SIZE[TMRecord]    UNTIL tmi = limits.tm DO      newTypi: TYPIndex = BcdUtilDefs.EnterType[bcd, bcd.tmb[tmi].map];      newTmi: TMIndex = BcdUtilDefs.EnterTypeMap[bcd, tmi];	BEGIN OPEN new: localBases.tmb[newTmi];	SELECT new.map FROM	  TYPNull => new.map ¬ newTypi;	  newTypi =>  NULL;	  ENDCASE => BcdErrorDefs.Error[error, "Exported type clash"L];	END;      ENDLOOP};  LoadSpaces: PROC = {    LoadSpace: PROC [spi: SPIndex] RETURNS [BOOLEAN] = {      newSpi: SPIndex = BcdUtilDefs.EnterSpace[bcd, spi];      localBases.spb[newSpi].seg ¬ MapSegment[bcd.spb[spi].seg];      RETURN[FALSE]};    [] ¬ EnumerateSpaces[LoadSpace]};  EnumerateSpaces: PROC [proc: PROC [SPIndex] RETURNS [BOOLEAN]]      RETURNS [spi: SPIndex] = {    spi ¬ FIRST[SPIndex];    UNTIL spi = limits.sp DO      IF proc[spi] THEN RETURN;      spi ¬ spi + SIZE[SPRecord] + bcd.spb[spi].length*SIZE[SpaceID];      ENDLOOP;    RETURN[SPNull]};      LoadFramePacks: PROC = {    LoadFramePack: PROC [fpi: FPIndex] RETURNS [BOOLEAN] = {      newFpi: FPIndex = BcdUtilDefs.EnterFramePack[bcd, fpi];      FOR i: CARDINAL IN [0..localBases.fpb[newFpi].length) DO	localBases.fpb[newFpi].modules[i] ¬ 	  localBases.fpb[newFpi].modules[i] + rel.module;	ENDLOOP;      RETURN[FALSE]};    [] ¬ EnumerateFramePacks[LoadFramePack]};  EnumerateFramePacks: PROC [proc: PROC [FPIndex] RETURNS [BOOLEAN]]      RETURNS [fpi: FPIndex] = {    fpi ¬ FIRST[FPIndex];    UNTIL fpi = limits.fp DO      IF proc[fpi] THEN RETURN;      fpi ¬ fpi + SIZE[FPRecord] + bcd.fpb[fpi].length*SIZE[MTIndex];      ENDLOOP;    RETURN[FPNull]};  ProcessImports: PROC = {    FOR impi: IMPIndex ¬ FirstImport[], NextImport[impi] UNTIL impi = IMPNull DO      newImpi: IMPIndex = BcdUtilDefs.EnterImport[bcd, impi, TRUE];      localBases.itb[newImpi].file ¬ MapFile[localBases.itb[newImpi].file];      [] ¬ BcdUtilDefs.GetDummyGfi[];      ENDLOOP};  FirstImport: PROC RETURNS [IMPIndex] = INLINE {    OPEN localBases;    RETURN[IF limits.it = FIRST[IMPIndex] THEN IMPNull ELSE FIRST[IMPIndex]]};  NextImport: PROC [impi: IMPIndex] RETURNS [IMPIndex] = INLINE {    OPEN localBases;    IF impi = IMPNull THEN RETURN[IMPNull];    impi ¬ impi + SIZE[IMPRecord];    RETURN[IF impi = limits.it THEN IMPNull ELSE impi]};      nextLocalGfi: CARDINAL;  GetLocalGfi: PROC RETURNS [gfi: GFIndex] = {    gfi ¬ nextLocalGfi;    nextLocalGfi ¬ nextLocalGfi + 1;  [] ¬ BcdUtilDefs.GetDummyGfi[]};      ProcessLocalImports: PROC [start: IMPIndex] = {    nextLocalGfi ¬ 1;    FOR sti: STIndex ¬ FirstLocalImport[], NextLocalImport[sti]    UNTIL sti = STNull DO      WITH s: stb[sti] SELECT FROM        unknown => DeclareImportByName[sti, start];        external =>          WITH m: s.map SELECT FROM            interface => DeclareImport[sti, m.expi];            unknown   => DeclareImportByName[sti, start];	    config, module => 	      BcdErrorDefs.ErrorHti[	        error, "has been loaded, and is not a valid IMPORT"L, s.hti];            ENDCASE   => Error[];        local => 	  BcdErrorDefs.ErrorHti[	    error, "is a local configuration, and not a valid IMPORT"L, s.hti];	ENDCASE;      ENDLOOP};  FirstLocalImport: PROC RETURNS [STIndex] = {    OPEN localBases;    FOR sti: STIndex ¬ cxb[loadCx].link, stb[sti].link UNTIL sti = STNull DO      IF stb[sti].imported THEN RETURN [sti];      ENDLOOP;    RETURN [STNull]};  NextLocalImport: PROC [sti: STIndex] RETURNS [STIndex] = {    OPEN localBases;    IF sti = STNull THEN RETURN [STNull];    UNTIL (sti ¬ stb[sti].link) = STNull DO      IF stb[sti].imported THEN RETURN [sti];      ENDLOOP;    RETURN [STNull]};  DeclareImportByName: PROC [sti: STIndex, start: IMPIndex] = {    impi: IMPIndex;    firstImpi: IMPIndex ¬ IMPNull;    impLimit: IMPIndex = LOOPHOLE[table.Bounds[imptype].size];    name: NameRecord =       WITH s:stb[sti] SELECT FROM        external =>          WITH p:s SELECT FROM            file     => BcdUtilDefs.NameForSti[sti],            instance => BcdUtilDefs.NameForSti[p.sti],            ENDCASE  => ERROR LoadError,        unknown => BcdUtilDefs.NameForSti[sti],        ENDCASE => ERROR LoadError;    FOR impi ¬ start, impi+SIZE[IMPRecord] UNTIL impi = impLimit DO      IF localBases.itb[impi].name = name THEN {	IF firstImpi = IMPNull THEN firstImpi ¬ impi};      ENDLOOP;    IF firstImpi = IMPNull THEN {      BcdErrorDefs.ErrorName[warning, "is not IMPORTed by any modules"L, name];      stb[sti].imported ¬ FALSE;      RETURN};    stb[sti].impi ¬ impi ¬ BcdUtilDefs.EnterImport[@localBases, firstImpi, FALSE];    WITH s:stb[sti] SELECT FROM      external =>	IF s.ptype = instance THEN {	  BcdUtilDefs.CreateInstanceName[s.hti, [import[impi]]];	  localBases.itb[impi].namedInstance ¬ TRUE};      ENDCASE;    localBases.itb[impi].gfi ¬ GetLocalGfi[];    IF stb[sti].type = unknown THEN       stb[sti].body ¬ external[	map: [unknown[]], pointer: file[localBases.itb[impi].file]]};  DeclareImport: PROC [sti: STIndex, expi: EXPIndex] = {    OPEN localBases, exp: localBases.etb[expi];    impi: IMPIndex = table.Words[imptype, SIZE[IMPRecord]];    itb[impi] ¬ [      port: interface, namedInstance: FALSE, file: exp.file,      name: BcdUtilDefs.NameForSti[sti], gfi: GetLocalGfi[]];    stb[sti].impi ¬ impi;    IF stb[sti].type = unknown THEN       stb[sti].body ¬ external[map:[unknown[]], pointer:file[exp.file]]};  Lookup: PROC [hti: HTIndex] RETURNS [sti: STIndex] = {    last: STIndex;    IF hti = HTNull THEN RETURN [STNull];    FOR sti ¬ cxb[currentCx].link, stb[sti].link UNTIL sti = STNull DO      IF stb[sti].hti = hti THEN EXIT;        last ¬ sti;      REPEAT	FINISHED => {	  sti ¬ BcdUtilDefs.NewSemanticEntry[hti];	  stb[sti].hti ¬ hti;  stb[last].link ¬ sti};      ENDLOOP;    RETURN};      PortableItem: TYPE = MACHINE DEPENDENT RECORD [    rep(0): SELECT type(0): * FROM      interface => [expi(1): EXPIndex],      module    => [mti(1): MTIndex],      unknown   => [name(1): HTIndex],      null      => [null(1): CARDINAL ¬ 0],      ENDCASE];  PortNull: PortableItem = [null[]];  HtiForPortable: PROC [p: PortableItem] RETURNS [HTIndex] = {    RETURN [      WITH p SELECT FROM       interface => BcdUtilDefs.HtiForName[bcd, bcd.etb[expi].name],       module    => BcdUtilDefs.HtiForName[bcd, bcd.mtb[mti].name],       ENDCASE   => HTNull]};         EnumerateExports: PROC [proc: PROC [PortableItem]] RETURNS [PortableItem] = {    OPEN localBases;    FindItem: Tree.Scan = {      sti: STIndex = FindSti[t];      IF stb[sti].exported THEN	WITH s:stb[sti] SELECT FROM	  external =>	    WITH m:s.map SELECT FROM	      interface => proc[[interface[m.expi]]];	      module => proc[[module[m.mti]]];	      ENDCASE => proc[[unknown[s.hti]]];	  ENDCASE => proc[[unknown[s.hti]]]};    SELECT TRUE FROM      (loadExpi # EXPNull) => proc[[interface[loadExpi]]];      (loadTree = Tree.NullIndex) =>        FOR eti: EXPIndex ¬ FIRST[EXPIndex],	  eti+SIZE[EXPRecord]+bcd.etb[eti].size*SIZE[BcdDefs.Link]          UNTIL eti = limits.et	  DO  proc[[interface[eti]]]  ENDLOOP;      ENDCASE => {	IF exportsALL THEN {	  FOR sti: STIndex ¬ cxb[loadCx].link, stb[sti].link UNTIL sti = STNull DO            IF ~stb[sti].filename THEN               WITH s: stb[sti] SELECT FROM                external =>                  WITH m: s.map SELECT FROM                    interface => 		      {s.exported ¬ TRUE;  proc[[interface[m.expi]]]};                   ENDCASE;                ENDCASE            ENDLOOP};	TreeOps.ScanList[tb[loadTree].son[2], FindItem]};    RETURN[PortNull]};  VerifyExports: ExportAssigner = {    VerifyExport: PROC [p: PortableItem] = {      WITH p SELECT FROM        unknown =>          BcdErrorDefs.ErrorHti[warning, "is not EXPORTed by any modules"L, name];        ENDCASE};    [] ¬ EnumerateExports[VerifyExport]};  NormalExports: ExportAssigner = {      NormalExport: PROC [p: PortableItem] = {      CombineExport[Lookup[HtiForPortable[p]], p, currentOp]};          [] ¬ EnumerateExports[NormalExport]};  lhs: Tree.Link;  AssignedExports: ExportAssigner = {    Port: TYPE = PrincOps.Port;    left: PORT [Tree.Link] RETURNS [Tree.Link];    right: PORT RETURNS [PortableItem];    t: Tree.Link;    p: PortableItem;    nExports: CARDINAL ¬ 0;    LOOPHOLE[left,Port].out ¬ LOOPHOLE[TreeOps.UpdateList];    LOOPHOLE[right,Port].out ¬ LOOPHOLE[EnumerateExports];    t ¬ LOOPHOLE[left,PORT[Tree.Link, LONG POINTER] RETURNS [Tree.Link]][lhs, @left];    p ¬ LOOPHOLE[right,PORT[LONG POINTER] RETURNS [PortableItem]][@right];    UNTIL p = PortNull      DO      nExports ¬ nExports+1;      WITH t SELECT FROM        symbol => CombineExport[index, p, currentOp];        subtree => {          OPEN tb[index];          IF name # item THEN Error[];          WITH son[1] SELECT FROM            symbol => CombineExport[index, p, currentOp];            ENDCASE => Error[]};        ENDCASE => Error[];      t ¬ left[t];  p ¬ right[];      IF t = lhs THEN EXIT;      ENDLOOP;    UNTIL p = PortNull DO nExports ¬ nExports+1; p ¬ right[] ENDLOOP;    UNTIL t = lhs DO t ¬ left[t] ENDLOOP;    SELECT TreeOps.ListLength[lhs] FROM      < nExports =>	BcdErrorDefs.Error[	  error, "The right hand side exports more interfaces than required by the left hand side"L];      > nExports =>	BcdErrorDefs.Error[	  error, "The left hand side requires more interfaces than exported by the right hand side"L];      ENDCASE};  LoadAssign: PROC [t: Tree.Link] = {    node: Tree.Index = TreeOps.GetNode[t];    saveAssigner: ExportAssigner = processExports;    processExports ¬ AssignedExports;    lhs ¬ tb[node].son[1];  LoadRhs[tb[node].son[2]];    processExports ¬ saveAssigner};  NewExport: PROC [expi: EXPIndex] RETURNS [newExpi: EXPIndex] = {    newExpi ¬ BcdUtilDefs.EnterExport[bcd, expi, TRUE];    localBases.etb[newExpi].file ¬ MapFile[localBases.etb[newExpi].file]};  CombineExport: PROC [sti: STIndex, p: PortableItem, op: InterfaceOp] = {    target: FTIndex = FileForSti[sti];    WITH p SELECT FROM      unknown => {        BcdErrorDefs.ErrorHti[warning, "is not EXPORTed by any modules"L, name];        RETURN};      ENDCASE;    IF target = FTNull THEN DeclarePortableItem[sti, p]    ELSE {      source: FTIndex = FileForPortableItem[p];      IF ~BcdUtilDefs.EqVersions[source, target] THEN        BcdErrorDefs.WrongExportVersion[	  class: error, avail: source, req: target]};    WITH p SELECT FROM      interface => CombineInterface[sti, expi, op];      module    => CombineModule[sti, mti, op];      ENDCASE};  CombineModule: PROC [sti: STIndex, mti: MTIndex, op: InterfaceOp] = {    WITH s:stb[sti] SELECT FROM      external =>        WITH m:s.map SELECT FROM          module =>	    IF m.mti = MTNull THEN m.mti ¬ mti	    ELSE IF op = plus THEN 	      BcdErrorDefs.ErrorModule[warning, "is a duplicate export"L, m.mti];          unknown => s.map ¬ [	    module[BcdUtilDefs.EnterModule[bcd, mti, HTNull]]];          ENDCASE => Error[];      ENDCASE => Error[]};  CombineInterface: PROC [sti: STIndex, eti: EXPIndex, op: InterfaceOp] = {    newEti: EXPIndex;    WITH s:stb[sti] SELECT FROM      external =>        WITH m:s.map SELECT FROM          interface => {            IF m.expi = EXPNull THEN m.expi ¬ NewExport[eti];            newEti ¬ m.expi};          unknown => {            newEti ¬ NewExport[eti]; s.map ¬ [interface[newEti]]};          ENDCASE => Error[];      ENDCASE => Error[];    BEGIN OPEN old: bcd.etb[eti], new: localBases.etb[newEti];    FOR i: CARDINAL IN [0..old.size) DO      IF old.links[i] # NullLink THEN        SELECT TRUE FROM	  (old.links[i].tag = type) => WITH l:old.links[i] SELECT FROM	    type => {	      cl: BcdDefs.Link = [type[		typeID: BcdUtilDefs.EnterType[bcd, l.typeID],		fill: 0]];	      IF new.links[i] # NullLink AND new.links[i] # cl THEN                BcdErrorDefs.ErrorItem[	          error, "is an incompatible type definition"L, i		    ! BcdErrorDefs.GetInterface => RESUME[newEti]];	      new.links[i] ¬ cl};	    ENDCASE;	  (new.links[i] = NullLink) =>	    new.links[i] ¬ RelocateExportLink[old.links[i]];	  (op = plus) =>	    BcdErrorDefs.ErrorItem[warning, "is a duplicate export"L, i             ! BcdErrorDefs.GetInterface => RESUME[newEti]];	  ENDCASE;      ENDLOOP;    END};  RelocateExportLink: PROC [cl: BcdDefs.Link] RETURNS [BcdDefs.Link] = {    IF loadExpi = EXPNull AND loadCx = CXNull THEN      WITH c: cl SELECT FROM	variable => c.gfi ¬ c.gfi + rel.firstgfi-1;	procedure => c.gfi ¬ c.gfi + rel.firstgfi-1;	signal => c.gfi ¬ c.gfi + rel.firstgfi-1;	type =>	ERROR;	ENDCASE;    RETURN [cl]};  LoadRhs: PROC [exp: Tree.Link] = {    WITH exp SELECT FROM      subtree =>        SELECT tb[index].name FROM          module => {            currentParms ¬ tb[index].son[2];  LoadItem[tb[index].son[1]]};          ENDCASE => LoadOperand[exp];      ENDCASE => LoadOperand[exp]};  LoadOperand: PROC [exp: Tree.Link] = {    WITH exp SELECT FROM      symbol => LoadOperandSti[index];      subtree =>        SELECT tb[index].name FROM          item =>	    WITH s1: tb[index].son[1] SELECT FROM	      symbol =>  LoadOperandSti[s1.index];	      ENDCASE => Error[];          module => {            BcdErrorDefs.ErrorSti[error,	      "must name an interface (no ""[]"")"L,	      FindSti[tb[index].son[1]]];            currentParms ¬ tb[index].son[2];  LoadItem[tb[index].son[1]]};          plus, then => {            LoadOperand[tb[index].son[1]];            currentOp ¬ tb[index].name;            LoadOperand[tb[index].son[2]];            currentOp ¬ plus};          ENDCASE => Error[];      ENDCASE => Error[]};  NotOperand: PROC [sti: STIndex] = {    BcdErrorDefs.ErrorSti[error, "must name an interface"L, sti];    LoadSti[sti, HTNull]};  LoadOperandSti: PROC [sti: STIndex] = {    WITH s: stb[sti] SELECT FROM      external =>        WITH m:s.map SELECT FROM          interface => {            IF m.expi = EXPNull THEN Error[];            loadExpi ¬ m.expi;  processExports[];  loadExpi ¬ EXPNull};	  unknown =>	    BcdErrorDefs.ErrorSti[error, "cannot be an operand"L, sti];          ENDCASE => NotOperand[sti];      unknown =>	IF s.imported THEN 	  BcdErrorDefs.ErrorSti[error, "is imported and cannot be an operand"L, sti]	ELSE NotOperand[sti];      ENDCASE => NotOperand[sti]};         -- Input Bcd segment operations    CreateBcdSpace: PROC = {    IF bcdSeg = NIL THEN {      bcdSegSize ¬ 10;      bcdSeg ¬ MSegment.Create[        file: NIL, release: [],        fileBase: 0, pages: bcdSegSize, swapInfo: [uniform[size: 5]]];      bHeader ¬ MSegment.Address[bcdSeg]}};      GrowBcdSpace: PROC [minPages: Environment.PageCount] = {    bcdSegSize ¬ ((minPages+1)/2 * 2);    MSegment.Reset[      segment: bcdSeg, pages: bcdSegSize, swapInfo: [uniform[size: 2]]];    bHeader ¬ MSegment.Address[bcdSeg]};        DestroyBcdSpace: PROC = {    IF bcdSeg # NIL THEN {      MSegment.Delete[bcdSeg];  bcdSeg ¬ NIL;      bcdSegSize ¬ 0;  bHeader ¬ NIL}};  END.
-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- BcdScan.mesa--   Satterthwaite	May 30, 1980  11:32 AM--   Schmidt	September 18, 1980  1:59 PM--   JGS	23-Sep-82 15:18:28--   Lewis	23-Feb-82 15:54:41--   Johnsson	18-Aug-83  9:01:16--   Daniels	27-Apr-84 17:21:00-- Derived from Compiler>Scanner.MesaDIRECTORY  BcdErrorDefs USING [AcquireErrorStream, OpenErrorStream],  CharIO USING [CR, TAB, PutChar, PutNumber, PutString],  Environment USING [wordsPerPage, charsPerPage, charsPerWord],  MSegment USING [GetPages, FreePages],  MStream USING [Handle],  P1: FROM "BcdParseDefs" USING [Token],  ParseTable: FROM "BcdParseTable" USING [    TableRef, HashIndex, TSymbol, VocabHashEntry, EndMarker, tokenID, tokenSTR,    HashTable, ScanTable],  Stream USING [defaultInputOptions, EndOfStream],  String USING [AppendString, SubStringDescriptor],  SymbolOps: FROM "BcdSymbolOps" USING [EnterString];BcdScan: PROGRAM    IMPORTS BcdErrorDefs, CharIO, Stream, MSegment, String, SymbolOps     EXPORTS P1 =  BEGIN OPEN ParseTable;    z: UNCOUNTED ZONE ¬ NIL;    wordsPerPage: CARDINAL = Environment.wordsPerPage;  charsPerWord: CARDINAL = Environment.charsPerWord;  charsPerPage: CARDINAL = Environment.charsPerPage;    NUL: CHARACTER = 0C;  CR: CHARACTER = CharIO.CR;  ControlZ: CHARACTER = 32C;  -- Bravo escape char  TextPages: CARDINAL = 6;  TextWords: CARDINAL = TextPages * wordsPerPage;  TextChars: CARDINAL = TextWords * charsPerWord;  hashTab: LONG POINTER TO ParseTable.HashTable;  scanTab: LONG POINTER TO ParseTable.ScanTable;  vocab: LONG STRING;  vocabIndex: LONG POINTER TO ARRAY TSymbol OF CARDINAL;  stream: MStream.Handle;	-- the input stream  streamOrigin: LONG CARDINAL;  errorStream: MStream.Handle;	-- the error stream  tB: LONG POINTER TO PACKED ARRAY [0..TextChars) OF CHARACTER;  tI, tMax: [0..TextChars];  tOrigin, tLimit: CARDINAL;  tEnded: BOOLEAN;    FillBuffer: PROC = {    tOrigin ¬ tLimit;    IF tEnded THEN tMax ¬ 0    ELSE {      tMax ¬ stream.get[        stream, 	[blockPointer: LOOPHOLE[tB], startIndex: 0, stopIndexPlusOne: TextChars], 	Stream.defaultInputOptions].bytesTransferred;      IF tMax < TextChars THEN tEnded ¬ TRUE;      tLimit ¬ tOrigin + tMax};    IF tMax = 0 THEN {tB[0] ¬ NUL; tMax ¬ 1};    tI ¬ 0};  buffer: LONG STRING ¬ NIL;		-- token assembly area  iMax: CARDINAL;			-- iMax = buffer.maxlength  desc: String.SubStringDescriptor;	-- initial buffer segment  nTokens: CARDINAL;			-- token count  nErrors: CARDINAL;			-- lexical errors  BufferOverflow: ERROR = CODE;  ExpandBuffer: PROC = {    oldBuffer: LONG STRING ¬ buffer;    IF oldBuffer.length > 2000 THEN ERROR BufferOverflow;    buffer ¬ z.NEW[StringBody[2*oldBuffer.length]];    String.AppendString[buffer, oldBuffer];    iMax ¬ buffer.length ¬ buffer.maxlength;    z.FREE[@oldBuffer];    desc.base ¬ buffer};  char: CHARACTER;	-- current (most recently scanned) character  qDot: BOOLEAN;	-- used to resolved decimal point vs. interval  NextChar: PROC = {	-- also expanded inline within Atom    IF (tI¬tI+1) = tMax THEN FillBuffer[]; char ¬ tB[tI]};  Atom: PUBLIC PROC RETURNS [token: P1.Token] = {    OPEN token;      DO      WHILE char IN [NUL..' ] DO	SELECT char FROM	  ControlZ =>	    UNTIL char = CR DO	      IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GO TO EndFile; FillBuffer[]};	      char ¬ tB[tI];	      ENDLOOP;	  NUL => {		-- ­@­@ is Tioga escape seq	    IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GO TO EndFile; FillBuffer[]};	    char ¬ tB[tI];	    IF char = NUL THEN GO TO EndFile};	  ENDCASE => {	    IF (tI¬tI+1) = tMax THEN {	      IF tEnded THEN GO TO EndFile; FillBuffer[]};	    char ¬ tB[tI]};	ENDLOOP;      index ¬ tOrigin + tI;  value ¬ 0;            BEGIN      SELECT char FROM	'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm,	'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y, 'z  => {	  i: CARDINAL;	  i ¬ 0;	    DO	    buffer[i] ¬ char;	    IF (tI¬tI+1) = tMax THEN FillBuffer[];	    char ¬ tB[tI];	    SELECT char FROM	      IN ['a..'z], IN ['A..'Z], IN ['0..'9] =>		IF (i ¬ i+1) >= iMax THEN ExpandBuffer[];	      ENDCASE =>  EXIT;	    ENDLOOP;	  desc.length ¬ i+1;	  class ¬ tokenID;  value ¬ SymbolOps.EnterString[@desc];	  GO TO GotNext};	'A, 'B, 'C, 'D, 'E, 'F, 'G, 'H, 'I, 'J, 'K, 'L, 'M,	'N, 'O, 'P, 'Q, 'R, 'S, 'T, 'U, 'V, 'W, 'X, 'Y, 'Z  => {	  first, last: CARDINAL;	  uId: BOOLEAN;	  i, j: CARDINAL;	  h: HashIndex;	  s1, s2: CARDINAL;	  i ¬ 0;  uId ¬ TRUE;  first ¬ last ¬ char-0C;	    DO	    buffer[i] ¬ char;	    IF (tI¬tI+1) = tMax THEN FillBuffer[];	    char ¬ tB[tI];	    SELECT char FROM	      IN ['A..'Z] => {		last ¬ char-0C; IF (i ¬ i+1) >= iMax THEN ExpandBuffer[]};	      IN ['a..'z], IN ['0..'9] => {		uId ¬ FALSE; IF (i ¬ i+1) >= iMax THEN ExpandBuffer[]};	      ENDCASE =>  EXIT;	    ENDLOOP;	  i ¬ i+1;	  IF uId	    THEN {	      h ¬ ((first*128-first) + last) MOD LAST[HashIndex] + 1;	      WHILE (j ¬ hashTab[h].symbol) # 0 		DO		IF vocabIndex[j]-(s2¬vocabIndex[j-1]) = i		  THEN		    FOR s1 IN [0 .. i) 		      DO		      IF buffer[s1] # vocab[s2] THEN EXIT;		      s2 ¬ s2+1;		      REPEAT			FINISHED => {class ¬ j; GO TO GotNext};		      ENDLOOP;		IF (h ¬ hashTab[h].link) = 0 THEN EXIT;		ENDLOOP};	  desc.length ¬ i;	  class ¬ tokenID;  value ¬ SymbolOps.EnterString[@desc];	  GO TO GotNext};	',, ';, ':, '_, '=, '., '[, '] => {	  class ¬ scanTab[char]; GO TO GetNext};	'" => {	  i: CARDINAL;	  i ¬ 0;	    DO 	    IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GO TO EOFEnd;  FillBuffer[]};	    char ¬ tB[tI];	    SELECT char FROM	      '" => {		IF (tI¬tI+1) = tMax THEN FillBuffer[];		char ¬ tB[tI];		IF char # '" THEN GO TO QuoteEnd};	      ENDCASE;	    IF i >= iMax	      THEN ExpandBuffer[		! BufferOverflow => {ScanError[string, tOrigin+tI]; i ¬ 0; CONTINUE}];	    buffer[i] ¬ char;  i ¬ i+1;	    REPEAT	      QuoteEnd => NULL;	      EOFEnd => {FillBuffer[];  char ¬ tB[tI]};	    ENDLOOP;	  desc.length ¬ i;	  value ¬ SymbolOps.EnterString[@desc];	  class ¬ tokenSTR; GO TO GotNext};	'- => {	  pChar: CHARACTER;	  NextChar[];	  IF char # '- THEN {class ¬ scanTab['-]; GO TO GotNext};	  char ¬ NUL;	    DO	    pChar ¬ char;	    IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GO TO EndFile;  FillBuffer[]};	    char ¬ tB[tI];	    SELECT char FROM	      '- =>  IF pChar = '- THEN EXIT;	      CR =>  EXIT;	      ENDCASE;	    ENDLOOP;	  NextChar[]};	'< => {	  NextChar[];	  IF char = '< THEN GO TO ScanComment ELSE ScanError[char, index]};		253c => GO TO ScanComment;	-- character mappings	254c => { -- left arrow	  class ¬ scanTab['_]; GO TO GetNext};	  	ENDCASE => {	  class ¬ scanTab[char];	  IF class # 0 THEN  GO TO GetNext;	  NextChar[];	  ScanError[char, index]};            EXITS ScanComment => {	state: {plain, leftBrocket, rightBrocket} ¬ plain;	nest: CARDINAL ¬ 1;	DO	  IF (tI¬tI+1) = tMax THEN {	    IF tEnded THEN GO TO EndFile; FillBuffer[]};	  char ¬ tB[tI];	  SELECT char FROM	    '> => SELECT state FROM	      plain, leftBrocket => state ¬ rightBrocket;	      rightBrocket => {		state ¬ plain; nest ¬ nest - 1; IF nest = 0 THEN EXIT};	      ENDCASE;	    '< => SELECT state FROM	      plain, rightBrocket => state ¬ leftBrocket;	      leftBrocket => {state ¬ plain; nest ¬ nest + 1};	      ENDCASE;	    253c => {state ¬ plain; nest ¬ nest + 1};	    273c => {state ¬ plain; nest ¬ nest - 1; IF nest = 0 THEN EXIT};	    ENDCASE => state ¬ plain;	  ENDLOOP;	NextChar[]};      END;      REPEAT	GetNext => {IF (tI¬tI+1) = tMax THEN FillBuffer[]; char ¬ tB[tI]};	GotNext => NULL;	EndFile => {	  FillBuffer[];  char ¬ tB[tI];	  class ¬ EndMarker;  index ¬ tOrigin;  value ¬ 0};      ENDLOOP;    nTokens ¬ nTokens + 1;    RETURN};  -- called for each binding  ScanInit: PUBLIC PROC [    sourceStream: MStream.Handle, table: ParseTable.TableRef, uz: UNCOUNTED ZONE] = {    z ¬ uz;    hashTab ¬ @table[table.scanTable.hashTab];    scanTab ¬ @table[table.scanTable.scanTab];    vocab ¬ LOOPHOLE[@table[table.scanTable.vocabBody], LONG STRING];    vocabIndex ¬ @table[table.scanTable.vocabIndex];    IF buffer = NIL THEN buffer ¬ uz.NEW[StringBody[256]];    iMax ¬ buffer.length ¬ buffer.maxlength;    desc.base ¬ buffer;  desc.offset ¬ 0;    stream ¬ sourceStream;    streamOrigin ¬ stream.getPosition[stream];    tB ¬ MSegment.GetPages[TextPages];    tOrigin ¬ tLimit ¬ 0;  tMax ¬ 0;  tEnded ¬ FALSE;    FillBuffer[];  char ¬ tB[tI];  qDot ¬ FALSE;    nTokens ¬ nErrors ¬ 0};  ScanReset: PUBLIC PROC RETURNS [CARDINAL, CARDINAL] = {    MSegment.FreePages[tB];    IF buffer # NIL THEN z.FREE[@buffer];    RETURN[nTokens, nErrors]}; -- error handling  ResetScanIndex: PUBLIC PROC [index: CARDINAL] = {    page: CARDINAL;    IF index ~IN [tOrigin .. tLimit) THEN {      page ¬ index/charsPerPage;      tOrigin ¬ tLimit ¬ page*charsPerPage;      tMax ¬ 0;  tEnded ¬ FALSE;      stream.setPosition[stream, (streamOrigin + index)];      FillBuffer[]};    tI ¬ index - tOrigin;    IF tI >= tMax THEN FillBuffer[];    char ¬ tB[tI]};      ScanError: PROC [code: {number, string, char, atom}, tokenIndex: CARDINAL] = {    OPEN CharIO;    BcdErrorDefs.OpenErrorStream[];    errorStream ¬ BcdErrorDefs.AcquireErrorStream[];    nErrors ¬ nErrors + 1;    ErrorContext[      message: SELECT code FROM	number => "invalid number"L,	string => "string too long"L,	char   => "invalid character"L,	ENDCASE => NIL,      tokenIndex: tokenIndex,      errorStream: errorStream];    PutChar[errorStream, CR]};  ErrorContext: PUBLIC PROC [      message: STRING, tokenIndex: CARDINAL, errorStream: MStream.Handle] = {    OPEN CharIO;    saveIndex: LONG CARDINAL = stream.getPosition[stream];    origin: LONG CARDINAL = (streamOrigin + tokenIndex);    char: CHARACTER;    stream.setPosition[      stream,       PrintTextLine[origin: origin, errorStream: errorStream]];    UNTIL stream.getPosition[stream] = origin DO      char ¬ LOOPHOLE[stream.getByte[stream ! Stream.EndOfStream => GOTO eof]];      PutChar[errorStream, IF char = TAB THEN TAB ELSE ' ];      REPEAT eof => NULL;      ENDLOOP;    PutString[errorStream, "­ "L];  PutString[errorStream, message];    PutString[errorStream, " ["L];    PutNumber[      errorStream, tokenIndex,       [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    PutChar[errorStream, ']];   PutChar[errorStream, CR];    stream.setPosition[stream, saveIndex]};  PrintTextLine: PROC [        origin: LONG CARDINAL, errorStream: MStream.Handle]      RETURNS [start: LONG CARDINAL] = {    OPEN CharIO;    lineIndex: LONG CARDINAL;    char: CHARACTER;    start ¬ lineIndex ¬ origin;    THROUGH [1..200] UNTIL lineIndex = 0 DO      lineIndex ¬ lineIndex - 1;      stream.setPosition[stream, lineIndex];      IF stream.getByte[stream] = LOOPHOLE[CR] THEN EXIT;      start ¬ lineIndex;      ENDLOOP;    stream.setPosition[stream, start];    THROUGH [1..100] DO      char ¬ LOOPHOLE[stream.getByte[stream ! Stream.EndOfStream => GOTO eof]];      SELECT char FROM	CR, ControlZ => EXIT;	ENDCASE => PutChar[errorStream, char];      REPEAT eof => NULL;      ENDLOOP;    PutChar[errorStream, CR]};  END.
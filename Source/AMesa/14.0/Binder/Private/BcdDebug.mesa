-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- BcdDebug.mesa--   Satterthwaite	May 30, 1980  12:34 PM--   Lewis		17-Nov-82 17:09:39--   Johnsson		 5-Jul-83 11:24:30DIRECTORY  Alloc USING [AddNotify, DropNotify, Handle, Notifier, Top],  BcdBindDefs USING [RelocHandle, RelocationType],  BcdControlDefs USING [BinderData, data],  BcdDefs USING [    aptype, ATIndex, ATRecord, ATNull, attype, CTIndex, CTNull, CTRecord,    cttype, cxtype, ENIndex, ENRecord, ENNull,    entype, EXPIndex, EXPRecord, exptype, fptype, FTIndex, FTNull, FTRecord,    FTSelf, fttype, IMPIndex, IMPNull, IMPRecord, imptype,    LFIndex, LFNull, lftype, Link,    MTIndex, MTNull, MTRecord, mttype, Namee, NameRecord, NTIndex, NTRecord,    nttype, nullLink, SGIndex, sgtype, SpaceID, SPIndex, SPRecord, sptype,    sstype, sttype, treetype, TMIndex, TMRecord, tmtype,    TYPIndex, TYPNull, TYPRecord, typtype, unboundLink, VersionStamp],  BcdErrorDefs USING [    OpenErrorStream, WriteBlanks, WriteChar, WriteCR, WriteDecimal,    WriteNumber, WriteOctal, WriteString, WriteSubString],  BcdOps USING [NameString],  BcdUtilDefs USING [GetGfiForMti],  Format USING [NumberFormat],  PrincOps USING [BytePC],  String USING [SubString, SubStringDescriptor],  Symbols: FROM "BcdSymbols" USING [    CXIndex, CXRecord, HTIndex, HTNull, STIndex, STNull],  SymbolOps: FROM "BcdSymbolOps" USING [SubStringForHash],  Table USING [Base, Limit],  Time USING [Append, Unpack],  Tree: FROM "BcdTree" USING [Index, Link, Map, NodeName, NullIndex],  TreeOps: FROM "BcdTreeOps" USING [UpdateTree];BcdDebug: PROGRAM    IMPORTS    Alloc, BcdControlDefs, BcdErrorDefs, BcdUtilDefs, SymbolOps, Time, TreeOps    EXPORTS BcdControlDefs =  BEGIN OPEN BcdErrorDefs, BcdDefs;  SubString: TYPE = String.SubString;    gd: BcdControlDefs.BinderData ¬ NIL;  table: Alloc.Handle ¬ NIL;    initialized, streamOpened: BOOLEAN ¬ FALSE;  desc: String.SubStringDescriptor;  ss: SubString = @desc;    tb, cxb, stb, mtb, lfb, etb, enb, itb, ctb, sgb, ftb, typb, tmb: Table.Base;  ntb, spb, fpb, atb: Table.Base;  ssb, apb: BcdOps.NameString;  DebugNotify: Alloc.Notifier = {    tb   ¬ base[treetype];  stb ¬ base[sttype];  cxb ¬ base[cxtype];    ctb  ¬ base[cttype];    mtb ¬ base[mttype];  lfb ¬ base[lftype];    etb  ¬ base[exptype];   enb ¬ base[entype];  itb ¬ base[imptype];    sgb  ¬ base[sgtype];    ftb ¬ base[fttype];    typb ¬ base[typtype];   tmb ¬ base[tmtype];  atb ¬ base[attype];    ntb  ¬ base[nttype];    ssb ¬ base[sstype];  apb ¬ base[aptype];    spb  ¬ base[sptype];    fpb ¬ base[fptype]};          Initialize: PROC = {    IF ~initialized THEN {      gd ¬ BcdControlDefs.data;      table ¬ gd.ownTable;      table.AddNotify[DebugNotify, NIL];      IF ~streamOpened THEN {BcdErrorDefs.OpenErrorStream[];  streamOpened ¬ TRUE};      initialized ¬ TRUE}};      Finalize: PROC = {    IF initialized THEN {      table.DropNotify[DebugNotify, NIL];  table ¬ NIL;      gd ¬ NIL;      initialized ¬ streamOpened ¬ FALSE}}; -- Parse tree printing  PrintTree: PUBLIC PROC [t: Tree.Link] = {    Initialize[];    PrintSubTree[t, 0];    WriteCR[];  WriteCR[];    Finalize[]};  WriteNodeName: PROC [n: Tree.NodeName] = {    NodePrintName: ARRAY Tree.NodeName OF STRING = [      "list"L, "item"L, "source"L, "config"L,      "module"L, "assign"L, "plus"L, "then"L, "null"L];    WriteString[NodePrintName[n]]};  PrintSubTree: PROC [t: Tree.Link, nBlanks: CARDINAL] = {    OPEN Tree;    Printer: Tree.Map = {      Indent[nBlanks];      WITH s: t SELECT FROM	hash => PrintHti[s.index];	symbol => {PrintHti[stb[s.index].hti]; PrintIndex[s.index]};	subtree => {	  node: Tree.Index = s.index;	  IF node = Tree.NullIndex THEN WriteString["<empty>"L]	  ELSE {	    OPEN tb[node];	    WriteNodeName[name];  PrintIndex[node];	    SELECT TRUE FROM	      attr1 AND attr3 => WriteString[" (***Bad Links***)"L];	      attr1 => WriteString[" (Code Links)"L];	      attr3 => WriteString[" (Frame Links)"L];	      ENDCASE => WriteString[" (DontCare Links)"L];	    IF attr2 AND name = config THEN WriteString[" (EXPORTS ALL)"L];	    PutOctal[" ["L, info];  WriteChar[']];	    nBlanks ¬ nBlanks + 2;	    [] ¬ TreeOps.UpdateTree[s, Printer];	    nBlanks ¬ nBlanks - 2}};	ENDCASE;      RETURN [t]};    [] ¬ Printer[t]};  PrintHti: PROC [hti: Symbols.HTIndex] = {    desc: String.SubStringDescriptor;    s: SubString = @desc;    IF hti = Symbols.HTNull THEN WriteString["(anonymous)"L]    ELSE {SymbolOps.SubStringForHash[s, hti]; WriteSubString[s]}}; -- Context and semantic entry printing  PrintSemanticEntries: PUBLIC PROC = {    OPEN Symbols;    cxLimit: CXIndex;    Initialize[];    cxLimit ¬ table.Top[cxtype];    FOR cxi: CXIndex ¬ FIRST[CXIndex], cxi+SIZE[CXRecord] UNTIL cxi = cxLimit DO      PrintContext[cxi];      WriteCR[];      ENDLOOP;    Finalize[]};  PrintContext: PROC [cxi: Symbols.CXIndex] = {    OPEN BcdDefs, Symbols;    PutDecimal["Context: "L, LOOPHOLE[cxi]];    FOR sti: STIndex ¬ cxb[cxi].link, stb[sti].link UNTIL sti = STNull DO      OPEN stb[sti];      Indent[2];      PrintHti[hti]; PrintIndex[sti];      IF filename THEN WriteString[", filename"L];      IF assigned THEN WriteString[", assigned"L];      IF imported THEN {        WriteString[", imported"L]; IF impi # IMPNull THEN PrintIndex[impi]};      IF exported THEN WriteString[", exported"L];      WITH s:stb[sti] SELECT FROM        external =>          BEGIN          WriteString[", external["L];          WITH m:s.map SELECT FROM            config =>  PutIndex["config"L, m.cti];            module =>  PutIndex["module"L, m.mti];            interface =>  PutIndex["interface"L, m.expi];            ENDCASE;          WITH p:s SELECT FROM            file =>  PutIndex[", file"L, p.fti];            instance =>  PutIndex[", instance"L, p.sti];            ENDCASE;          WriteChar[']];          END;        local => {	  PutIndex[", local"L, s.info];          WITH m:s.map SELECT FROM            config => PutIndex["config"L, m.cti];            ENDCASE;	  PutIndex[", context"L, s.context]};        unknown =>  WriteString[", unknown[]"L];        ENDCASE;      ENDLOOP;    WriteCR[]}; -- Bcd table printing  PrintBcd: PUBLIC PROC = {    Initialize[];    PrintConfigs[];    PrintImports[];    PrintExports[];    PrintEntries[];    PrintTypes[];    PrintTypeMap[];    PrintModules[];    PrintAtoms[];    PrintFiles[];    Finalize[]};  PrintConfigs: PROC = {    cti: CTIndex ¬ FIRST[CTIndex];    ctLimit: CTIndex = table.Top[cttype];    WriteCR[];    WriteString["Configurations:"L];    UNTIL cti = ctLimit DO      PrintConfig[cti];      cti ¬ cti + (SIZE[CTRecord] + ctb[cti].nControls*SIZE[Namee]);      ENDLOOP;    WriteCR[]};  PrintConfig: PROC [cti: CTIndex] = {    OPEN ctb[cti];    Indent[2];    WriteName[name];  PrintIndex[cti];    IF namedInstance THEN {       WriteString[", instance: "L]; WriteNameFromTable[[config[cti]]]};    WriteString[", file: "L];    PrintFileName[file];  PrintIndex[file];    IF config # CTNull THEN {       WriteString[", parent: "L]; WriteName[ctb[config].name]; PrintIndex[config]};    IF nControls # 0 THEN {      WriteString[", controls: ["L];      FOR i: CARDINAL IN [0..nControls) DO        WITH c: ctb[cti].controls[i] SELECT FROM	  module => {	    WriteString["module "L]; WriteName[mtb[c.mti].name];	    PrintIndex[c.mti]};	  config => {	    WriteString["config "L];  WriteName[ctb[c.cti].name];	    PrintIndex[c.cti]};	  ENDCASE;	WriteString[IF i+1 # nControls THEN ", "L ELSE "]"L];	ENDLOOP}};  PrintImports: PROC = {    iti: IMPIndex ¬ FIRST[IMPIndex];    impLimit: IMPIndex = table.Top[imptype];    WriteCR[];    WriteString["Imports:"L];    UNTIL iti = impLimit DO PrintImport[iti]; iti ¬ iti + SIZE[IMPRecord] ENDLOOP;    WriteCR[]};  PrintImport: PROC [iti: IMPIndex] = {    OPEN itb[iti];    Indent[2];    WriteName[name];  PrintIndex[iti];    SELECT port FROM      module => WriteString[" (module)"L];      ENDCASE;    IF namedInstance THEN       {WriteString[", instance: "L]; WriteNameFromTable[[import[iti]]]};    WriteString[", version: "L]; PrintFileVersion[file]; PrintIndex[file];    PutDecimal[", gfi: "L, gfi]};  PrintExports: PROC = {    eti: EXPIndex ¬ FIRST[EXPIndex];    expLimit: EXPIndex = table.Top[exptype];    WriteCR[];    WriteString["Exports:"L];    UNTIL eti = expLimit DO      PrintExport[eti];      eti ¬ eti + etb[eti].size*SIZE[BcdDefs.Link]+SIZE[EXPRecord];      ENDLOOP;    WriteCR[]};  PrintExport: PROC [eti: EXPIndex] = {    OPEN etb[eti];    Indent[2];    WriteName[name];  PrintIndex[eti];    IF port = module THEN WriteString[" (module)"L];    IF namedInstance THEN {       WriteString[", instance: "L];  WriteNameFromTable[[export[eti]]]};    WriteString[", file: "L]; PrintFileVersion[file]; PrintIndex[file];    PutDecimal[", size: "L, size];    WriteString[", links:"L];    FOR i: CARDINAL IN [0..size) DO      IF i MOD 8 = 0 THEN Indent[4] ELSE WriteChar[' ];      PrintControlLink[links[i]];      IF i+1 # size THEN WriteChar[',];      ENDLOOP};  PrintEntries: PROC = {    eni: ENIndex ¬ FIRST[ENIndex];    enLimit: ENIndex = table.Top[entype];    WriteCR[];    WriteString["Entry vectors:"L];    UNTIL eni = enLimit DO       PrintEV[eni];      eni ¬ eni + SIZE[ENRecord] + enb[eni].nEntries*SIZE[PrincOps.BytePC];      ENDLOOP;    WriteCR[]};  PrintEV: PROC [eni: ENIndex] = {    OPEN enb[eni];    Indent[2];    PrintIndex[eni];    PutDecimal[", nEntries: "L, nEntries];    WriteString[", pcs:"L];    FOR i: CARDINAL IN [0..nEntries] DO      IF i MOD 8 = 0 THEN Indent[4] ELSE WriteChar[' ];      PutOctal[NIL, initialPC[i]];      IF i # nEntries THEN WriteChar[',];      ENDLOOP};  PrintTypes: PROC = {    typi: TYPIndex ¬ FIRST[TYPIndex];    typLimit: TYPIndex = table.Top[typtype];    WriteCR[];    WriteString["Exported types:"L];    UNTIL typi = typLimit DO      PrintType[typi];  typi ¬ typi + SIZE[TYPRecord];      ENDLOOP;    WriteCR[]};  PrintType: PROC [typi: TYPIndex] = {    OPEN typb[typi];    Indent[2];    PrintIndex[typi];    PutDecimal[", id: "L, id];    WriteString[", from: "L];  PrintVersion[version]};  PrintTypeMap: PROC = {    tmi: TMIndex ¬ FIRST[TMIndex];    tmLimit: TMIndex = table.Top[tmtype];    WriteCR[];    WriteString["Type map:"L];    UNTIL tmi = tmLimit DO PrintMapEntry[tmi]; tmi ¬ tmi + SIZE[TMRecord] ENDLOOP;    WriteCR[]};  PrintMapEntry: PROC [tmi: TMIndex] = {    OPEN tmb[tmi];    Indent[2];    PrintIndex[tmi];    PutDecimal[", entry: "L, offset];    WriteString[", in: "L];  PrintVersion[version];    PutIndex[", mapped to: "L, map]};  PrintSpaces: PROC = {    spi: SPIndex ¬ FIRST[SPIndex];    spLimit: SPIndex = table.Top[sptype];    WriteCR[];    WriteString["Spaces:"L];    UNTIL spi = spLimit DO      PrintSpace[spi];  spi ¬ spi + spb[spi].length*SIZE[SpaceID]+SIZE[SPRecord];      ENDLOOP;    WriteCR[]};  PrintSpace: PROC [spi: SPIndex] = {    OPEN spb[spi];    Indent[2];    PrintIndex[spi];    PutIndex[", segment: "L, seg];  PutDecimal[", length: "L, length];    FOR i: CARDINAL IN [0..length) DO      Indent[4];      IF spaces[i].resident THEN WriteString[", resident"L];      PutOctal[", offset: "L, spaces[i].offset];      PutDecimal[", pages: "L, spaces[i].pages];      WriteCR[];      ENDLOOP};  PrintModules: PROC = {    mtLimit: MTIndex = table.Top[mttype];    WriteCR[];    WriteString["Modules:"L];    FOR mti: MTIndex ¬ FIRST[MTIndex], mti + SIZE[MTRecord] UNTIL mti = mtLimit DO      PrintModule[mti];        ENDLOOP;    WriteCR[]};  PrintModule: PROC [mti: MTIndex] = {    OPEN mtb[mti];    Indent[2];    WriteName[name];  PrintIndex[mti];    IF namedInstance THEN {      WriteString["instance: "L]; WriteNameFromTable[[module[mti]]]};    WriteString[", file: "L];  PrintFileName[file];    WriteChar[' ];  PrintFileVersion[file]; PrintIndex[file];    IF config # CTNull THEN {       WriteString[", config: "L]; WriteName[ctb[config].name]; PrintIndex[config]};    Indent[4];    IF ~tableCompiled THEN WriteChar['~];      WriteString["table compiled, "L];    IF ~packageable THEN WriteChar['~];      WriteString["packageable, "L];    IF ~residentFrame THEN WriteChar['~];      WriteString["resident frame, "L];    IF ~initial THEN WriteChar['~];      WriteString["initial"L];    Indent[4];    WriteString["  "L];    IF ~boundsChecks THEN WriteChar['~];      WriteString["bounds cks, "L];    IF ~nilChecks THEN WriteChar['~];      WriteString["nil cks, "L];    IF ~crossJumped THEN WriteChar['~];      WriteString["cross jumped"L];    IF spare # ALL[FALSE] THEN {      Indent[4];      FOR i: CARDINAL IN [0..LENGTH[spare]) DO        IF spare[i] THEN {PutDecimal["spare["L, i]; WriteString["], "L]};	ENDLOOP};    Indent[4];    PutDecimal["framesize: "L, framesize];    PutDecimal[", gfi: "L, BcdUtilDefs.GetGfiForMti[mti]];    WriteString[", linkLoc: "L];    WriteString[      (SELECT linkLoc FROM         frame   => "frame"L,	 code    => "code"L,	 ENDCASE => "dontcare"L)];    Indent[4];    WriteString["code: "L];  PrintSegment[code.sgi];    PutOctal[", offset: "L, code.offset];    PutOctal[", length: "L, code.length];    IF linkspace THEN WriteString[", link space available"L];    IF packed THEN WriteString[", packed"L];    Indent[4];    WriteString["symbols: "L];  PrintSegment[sseg];    IF entries # ENNull THEN {Indent[4]; PutIndex["entry vector: "L, entries]};    IF atoms # ATNull THEN {Indent[4]; PutIndex["atoms: "L, atoms]};    IF mtb[mti].links # LFNull THEN PrintLinkFrag[mtb[mti].links]};  PrintLinkFrag: PROC [lfi: LFIndex] = {    Indent[4];    PutDecimal["number of links: "L, lfb[lfi].length];    WriteString[", control links:"L];    FOR i: CARDINAL IN [0..lfb[lfi].length) DO      IF i MOD 8 = 0 THEN Indent[6] ELSE WriteChar[' ];      PrintControlLink[lfb[lfi].frag[i]];      IF (i+1) # lfb[lfi].length THEN WriteChar[',];      ENDLOOP};  PrintSegment: PROC [sgi: SGIndex] = {    OPEN sd: sgb[sgi];    PrintFileName[sd.file];    PutDecimal[" [base: "L, sd.base]; PutDecimal[", pages: "L, sd.pages];    IF sd.extraPages # 0 THEN PutDecimal["+"L, sd.extraPages];    WriteChar[']]};  PrintFiles: PROC = {    fti: FTIndex ¬ FIRST[FTIndex];    ftLimit: FTIndex = table.Top[fttype];    WriteCR[];    WriteString["Files:"L];    UNTIL fti = ftLimit DO PrintFile[fti]; fti ¬ fti + SIZE[FTRecord] ENDLOOP;    WriteCR[]};  PrintFile: PROC [fti: FTIndex] = {    OPEN ftb[fti];    Indent[2];    WriteName[name];  PrintIndex[fti];    WriteString[", version: "L];  PrintFileVersion[fti]};  PrintAtoms: PROC = {    ati: ATIndex ¬ FIRST[ATIndex];    atLimit: ATIndex = table.Top[attype];    WriteCR[];    WriteString["Atoms:"L];    UNTIL ati = atLimit DO      PrintAtom[ati]; ati ¬ ati + SIZE[ATRecord[atb[ati].nAtoms]] ENDLOOP;    WriteCR[]};  PrintAtom: PROC [ati: ATIndex] = {    OPEN atb[ati];        Indent[2];    PrintIndex[ati];    PutDecimal[", nAtoms: "L, nAtoms]; PutDecimal[", offset: "L, offset];    FOR i: CARDINAL IN [0..nAtoms] DO      ssd: String.SubStringDescriptor ¬ [        base: @apb.string, offset: atom[i], length: apb.size[atom[i]]];      Indent[4]; WriteSubString[@ssd];      ENDLOOP}; -- Relocation printing  PrintRelocations: PUBLIC PROC [relHead: BcdBindDefs.RelocHandle] = {    Initialize[];    WriteCR[];    WriteString["Relocations:"L];    FOR rel: BcdBindDefs.RelocHandle ¬ relHead, rel.link UNTIL rel = NIL DO      PrintRel[rel];      ENDLOOP;    WriteCR[];    Finalize[]};  PrintRel: PROC [rel: BcdBindDefs.RelocHandle] = {    RelType: ARRAY BcdBindDefs.RelocationType OF STRING =      [outer:"outer"L, inner:"inner"L, file:"file "L];    mti: MTIndex;    Indent[2];    WriteString[RelType[rel.type]];    IF rel.import < CARDINAL[rel.importLimit-FIRST[IMPIndex]] THEN {      PutDecimal[" imports: ["L, rel.import];      PutDecimal[".."L, (rel.importLimit-FIRST[IMPIndex])-SIZE[IMPRecord]];      WriteString["],"]};    PutDecimal[" context: "L, LOOPHOLE[rel.context]];    IF rel.type = file AND (mti ¬ rel.module+FIRST[MTIndex]) # MTNull THEN {      WriteString[", module: "L];  WriteName[mtb[mti].name]; PrintIndex[mti]};    PutDecimal[", firstgfi: "L, LOOPHOLE[rel.firstgfi]];    PutDecimal[", lastgfi: "L, LOOPHOLE[rel.lastgfi]];    PutDecimal[", dummygfi: "L, LOOPHOLE[rel.dummygfi]];    PutDecimal[", orig1stdummy: "L, LOOPHOLE[rel.originalfirstdummy]]}; -- Utility Writes  WriteName: PROC [n: NameRecord] = {    ssd: String.SubStringDescriptor ¬ [      base: @ssb.string, offset: n, length: ssb.size[n]];    WriteSubString[@ssd]};  WriteTime: PROC [t: LONG CARDINAL] = {    s: STRING ¬ [20];    Time.Append[s, Time.Unpack[LOOPHOLE[t]]];    WriteString[s]};  Indent: PROC [n: CARDINAL] = {    WriteCR[];    WriteBlanks[n]};      PrintControlLink: PROC [link: BcdDefs.Link] = {    SELECT TRUE FROM      (link = BcdDefs.nullLink) => WriteString["(null)"L];      (link = BcdDefs.unboundLink) => WriteString["(unbound)"L];      ENDCASE => {WITH l: link SELECT FROM        procedure =>  	  BEGIN          PutDecimal["proc["L, l.gfi];  WriteChar[',];  PutDecimal[NIL, l.ep];  	  END;        signal =>  	  BEGIN          PutDecimal["sig["L, l.gfi];  WriteChar[',];  PutDecimal[NIL, l.index];  	  END;        variable =>  	  BEGIN	  PutDecimal["var["L, l.gfi]; WriteChar[',]; PutDecimal[NIL, l.offset];	  END;        type =>  	  BEGIN	  IF l.typeID = BcdDefs.TYPNull THEN WriteString["type[null"L] 	  ELSE PutDecimal["type["L, LOOPHOLE[l.typeID]];	  END;        ENDCASE;      WriteChar[']]}};  PrintMachine: PROC [stamp: BcdDefs.VersionStamp] = {    octal: Format.NumberFormat = [8,FALSE,FALSE,1];    WriteNumber[stamp.net, octal];   WriteChar['#];    WriteNumber[stamp.host, octal];  WriteChar['#]};  PrintFileName: PROC [fti: FTIndex] = {    SELECT fti FROM      FTNull  => WriteString["(null)"L];      FTSelf  => WriteString["(self)"L];      ENDCASE => WriteName[ftb[fti].name]};  PrintFileVersion: PROC [fti: FTIndex] = {PrintVersion[ftb[fti].version]};  PrintVersion: PROC [version: VersionStamp] = {    WriteChar['(];    IF version.time = 0 THEN WriteString ["Null Version"L]    ELSE {WriteTime[LOOPHOLE[version.time]]; WriteChar[' ]; PrintMachine[version]};    WriteChar[')]};  PrintIndex: PROC [index: UNSPECIFIED] = {    WriteChar['[];    IF index = Table.Limit-1 THEN WriteString["Null"L]    ELSE WriteDecimal[index];    WriteChar[']]};  WriteNameFromTable: PROC [n: Namee] = {    nti: NTIndex;    ntLimit: NTIndex = table.Top[nttype];    FOR nti ¬ FIRST[NTIndex], nti + SIZE[NTRecord] UNTIL nti = ntLimit DO      IF ntb[nti].item = n THEN {WriteName[ntb[nti].name];  EXIT};      ENDLOOP};       -- Annotated printing  PutDecimal: PROC [id: STRING, n: INTEGER] = {    IF id # NIL THEN WriteString[id];    WriteDecimal[n]};  PutOctal: PROC [id: STRING, n: UNSPECIFIED] = {    IF id # NIL THEN WriteString[id];    WriteOctal[n]};  PutIndex: PROC [id: STRING, index: UNSPECIFIED] = {    IF id # NIL THEN WriteString[id];    PrintIndex[index]};  END.
-- Copyright (C) 1982  by Xerox Corporation. All rights reserved. -- BcdSEBuild.mesa-- Last edited by Satterthwaite on June 2, 1980  11:20 AM-- Last edited by Lewis on  6-Jan-82 16:52:08-- Last edited by Saxe on  1-Apr-85 10:24:58DIRECTORY  Alloc USING [AddNotify, Bounds, DropNotify, Handle, Notifier, Words],  BcdControlDefs USING [BinderData, data],  BcdDefs USING [    cttype, cxtype, FTIndex, FTNull, FTRecord, fttype, NameRecord,    NullVersion, sttype, treetype],  BcdUtilDefs USING [    EnterFile, NameForHti, NameForSti, NewContext, NewSemanticEntry],  CommandUtil USING [GetNthPair, ListLength, PairList],  MFile USING [maxNameLength],  String USING [AppendSubString, SubStringDescriptor],  Symbols: FROM "BcdSymbols" USING [    CXIndex, HTIndex, STIndex, STNull, STRecord],  SymbolOps: FROM "BcdSymbolOps" USING [EnterString, SubStringForHash],  Table USING [Base],  Tree: FROM "BcdTree" USING [Index, Link, Map, Null],  TreeOps: FROM "BcdTreeOps" USING [GetNode, UpdateList];BcdSEBuild: PROGRAM    IMPORTS       Alloc, BcdControlDefs, BcdUtilDefs, CommandUtil, String, SymbolOps, TreeOps    EXPORTS BcdControlDefs =  BEGIN OPEN BcdDefs, Symbols;  BuildSEError: PUBLIC ERROR = CODE;    gd: BcdControlDefs.BinderData ¬ NIL;  table: Alloc.Handle ¬ NIL;  tb, stb, ctb, cxb, ftb: Table.Base;  Notifier: Alloc.Notifier = {    tb  ¬ base[treetype];  stb ¬ base[sttype];      cxb ¬ base[cxtype];    ctb ¬ base[cttype];    ftb ¬ base[fttype]};  currentCtx, directoryCtx: CXIndex;  BuildSemanticEntries: PUBLIC PROC [root: Tree.Link] = {    node: Tree.Index;    gd ¬ BcdControlDefs.data;    table ¬ gd.ownTable;    table.AddNotify[Notifier, NIL];    node ¬ TreeOps.GetNode[root];    IF tb[node].name # source THEN ERROR BuildSEError;    currentCtx ¬ directoryCtx ¬ BcdUtilDefs.NewContext[];    IF CommandUtil.ListLength[gd.cmdLineArgList] > 0 THEN EnterArgsAsDirItems[];    tb[node].son[1] ¬ TreeOps.UpdateList[tb[node].son[1], DirItem];    currentCtx ¬ BcdUtilDefs.NewContext[];    tb[node].son[2] ¬ TreeOps.UpdateList[tb[node].son[2], PackId];    currentCtx ¬ BcdUtilDefs.NewContext[];    tb[node].son[3] ¬ Stmt[tb[node].son[3]];    EnterFileNames[];    table.DropNotify[Notifier, NIL];    table ¬ NIL;  gd ¬ NIL};  EnterArgsAsDirItems: PROC =     BEGIN  -- enter Idi: FileNamei pairs from command line as DIRECTORY entries    lhs, rhs: LONG STRING;    lhsSS: String.SubStringDescriptor;    lhsHti: Symbols.HTIndex;    sti, last: Symbols.STIndex;    rhsFti: BcdDefs.FTIndex;    FOR n: CARDINAL IN [0 .. CommandUtil.ListLength[gd.cmdLineArgList]) DO      BEGIN       [lhs, rhs] ¬ CommandUtil.GetNthPair[list: gd.cmdLineArgList, n: n];       lhsSS ¬ [base: lhs, offset: 0, length: lhs.length];      lhsHti ¬ SymbolOps.EnterString[@lhsSS];       last ¬ Symbols.STNull;      FOR sti ¬ cxb[directoryCtx].link, stb[sti].link 	UNTIL sti = Symbols.STNull DO        IF stb[sti].hti = lhsHti THEN GOTO AlreadyEntered;        last ¬ sti;        ENDLOOP;      sti ¬ BcdUtilDefs.NewSemanticEntry[lhsHti];       IF last = Symbols.STNull THEN cxb[directoryCtx].link ¬ sti		               ELSE stb[last].link ¬ sti;      rhsFti ¬ BcdUtilDefs.EnterFile[rhs];      stb[sti].body ¬ external[map: [unknown[]], pointer: file[rhsFti]];      EXITS        AlreadyEntered => NULL;      END;      ENDLOOP;    END;   DirItem: Tree.Map = {    lhs: Tree.Link;    lhsHti: Symbols.HTIndex;    dirSti, sti: STIndex;    stl: symbol Tree.Link;    fileName: STRING ¬ [MFile.maxNameLength];    fti: FTIndex;    name: String.SubStringDescriptor;    WITH t SELECT FROM      subtree => {        lhs ¬ tb[index].son[1];         WITH lhs SELECT FROM	  hash => lhsHti ¬ index;	  ENDCASE => ERROR BuildSEError;         FOR dirSti ¬ cxb[directoryCtx].link, stb[dirSti].link 	UNTIL dirSti = Symbols.STNull DO          IF stb[dirSti].hti = lhsHti THEN RETURN[t];  -- already inserted          ENDLOOP;        stl ¬ SemanticEntry[lhs];        sti ¬ stl.index;        WITH s2: tb[index].son[2] SELECT FROM          hash => SymbolOps.SubStringForHash[@name, s2.index];          ENDCASE};      ENDCASE;    String.AppendSubString[fileName, @name];    fti ¬ BcdUtilDefs.EnterFile[fileName];    stb[sti].body ¬ external[map: [unknown[]], pointer: file[fti]];    RETURN[t]};   PackId: Tree.Map = {    RETURN [WITH t SELECT FROM      hash => SemanticEntry[t],      subtree => TreeOps.UpdateList[t, PackId],      ENDCASE => ERROR BuildSEError]};  Stmt: Tree.Map = {    WITH t SELECT FROM      hash => v ¬ Item[t];      symbol => v ¬ Item[t];      subtree => {	node: Tree.Index = index;        saveIndex: CARDINAL = gd.textIndex;        gd.textIndex ¬ tb[node].info;	v ¬ SELECT tb[node].name FROM          list   =>  TreeOps.UpdateList[t, Stmt],          item   =>  Item[t],          config =>  Config[node],          assign =>  Assign[node],          plus, then => Expression[t],          module =>  Module[node],          ENDCASE => ERROR BuildSEError;        gd.textIndex ¬ saveIndex};      ENDCASE => ERROR BuildSEError;    RETURN};  Item: Tree.Map = {    st1, st2: STIndex;    [v, st1, st2] ¬ ProcessItem[t];    SetFilename[IF st2 = STNull THEN st1 ELSE st2];    RETURN};   ProcessItem: PROC [t: Tree.Link] RETURNS [tl: Tree.Link, st1,st2: STIndex] = {    stl: symbol Tree.Link;    st2 ¬ STNull;    WITH tt: t SELECT FROM      symbol => {tl ¬ tt; st1 ¬ tt.index};      hash => {tl ¬ stl ¬ SemanticEntry[t]; st1 ¬ stl.index};      subtree => {        OPEN tb[tt.index];        tl ¬ t;        son[1] ¬ stl ¬ SemanticEntry[son[1]];  st1 ¬ stl.index;        IF son[2] # Tree.Null THEN {	  stb[st1].filename ¬ FALSE;	  son[2] ¬ stl ¬ SemanticEntry[son[2]];  st2 ¬ stl.index;	  stb[st1].body ¬ external[pointer: instance[st2], map: [unknown[]]]}};      ENDCASE => ERROR BuildSEError;    RETURN};  SetFilename: PROC [sti: STIndex] = {    OPEN stb[sti];    IF ~stb[sti].filename AND stb[sti].type = unknown THEN {      stb[sti].filename ¬ TRUE;      stb[sti].body ¬ external[pointer: file[FTNull], map: [unknown[]]]}};  Config: PROC [node: Tree.Index] RETURNS [Tree.Link] = {    OPEN tb[node];    saveCx: CXIndex = currentCtx;    saveName: NameRecord = gd.currentName;    SeEntry: Tree.Map = {RETURN[SemanticEntry[t]]};    EnterConfig[node];  -- name    son[1] ¬ TreeOps.UpdateList[son[1], ImpItem];	-- IMPORTS    son[2] ¬ TreeOps.UpdateList[son[2], ExpItem];	-- EXPORTS    son[3] ¬ TreeOps.UpdateList[son[3], SeEntry];	-- CONTROL    son[5] ¬ TreeOps.UpdateList[son[5], Stmt];		-- body    currentCtx ¬ saveCx;  gd.currentName ¬ saveName;    RETURN[[subtree[node]]]};  EnterConfig: PROC [node: Tree.Index] = {    sti: STIndex;    stl: symbol Tree.Link = SemanticEntry[tb[node].son[4]];    tb[node].son[4] ¬ stl;    stb[(sti ¬ stl.index)].filename ¬ FALSE;    currentCtx ¬ BcdUtilDefs.NewContext[];    gd.currentName ¬ BcdUtilDefs.NameForSti[sti];    SELECT stb[sti].type FROM      unknown =>         stb[sti].body ¬ local[info: node, context: currentCtx, map: [unknown[]]];      ENDCASE => ERROR BuildSEError};  ImpItem: Tree.Map = {    st1: STIndex;    [v, st1, ] ¬ ProcessItem[t];  stb[st1].imported ¬ TRUE};   ExpItem: Tree.Map = {    st1: STIndex;    [v, st1, ] ¬ ProcessItem[t];  stb[st1].exported ¬ TRUE};   AssignItem: Tree.Map = {    st1, st2: STIndex;    [v, st1, st2] ¬ ProcessItem[t];    stb[st1].assigned ¬ TRUE;    IF stb[st1].filename THEN {      OPEN stb[st1];      filename ¬ FALSE;      body ¬ external[pointer: instance[st2], map: [unknown[]]]};    IF st2 # STNull THEN {      OPEN stb[st2];      assigned ¬ TRUE;      filename ¬ FALSE;      WITH st:stb[st2] SELECT FROM        external => {	  WITH r:st SELECT FROM	    file => NULL; <<If it was in directory clause, then it's 	         already known to be a file, so leave it alone>>	    ENDCASE => {<<If it's external but not a file,	         it's because st1 = st2. In this case the directory context	         has not been checked.  Check it, and if the identifier is there 	         then copy.  Otherwise set pointer field to null to avoid a	         circular pointer.>>	       dirSti:STIndex;	       saveLink:STIndex = stb[st1].link;	       FOR dirSti ¬ cxb[directoryCtx].link, stb[dirSti].link	       UNTIL dirSti = STNull DO		 IF stb[dirSti].hti = stb[st2].hti THEN EXIT;	       ENDLOOP;	       IF dirSti # STNull THEN {stb[st1] ¬ stb[dirSti];	          stb[st1].link ¬ saveLink;}	       ELSE r.pointer ¬ instance[STNull];	    };};	ENDCASE => body ¬ external[pointer: instance[STNull], map: [unknown[]]];      }};   Assign: PROC [node: Tree.Index] RETURNS [Tree.Link] = {    tb[node].son[1] ¬ TreeOps.UpdateList[tb[node].son[1], AssignItem];    tb[node].son[2] ¬ Expression[tb[node].son[2]];    RETURN[[subtree[node]]]};  Expression: Tree.Map = {    WITH t SELECT FROM      symbol => v ¬ ProcessItem[t].tl;      hash => v ¬ ProcessItem[t].tl;      subtree =>        SELECT tb[index].name FROM          item => v ¬ ProcessItem[t].tl;          module => v ¬ Module[index];          plus, then => {            OPEN tb[index];            son[1] ¬ Expression[son[1]];  son[2] ¬ Expression[son[2]];	    v ¬ t};          ENDCASE => ERROR BuildSEError;      ENDCASE => ERROR BuildSEError;    RETURN};  ModItem: Tree.Map = {    RETURN [WITH t SELECT FROM       symbol => t,      hash => SemanticEntry[t],      ENDCASE => ERROR BuildSEError]};  Module: PROC [node: Tree.Index] RETURNS [Tree.Link] = {    tb[node].son[1] ¬ Item[tb[node].son[1]];    tb[node].son[2] ¬ TreeOps.UpdateList[tb[node].son[2], ModItem];    RETURN [[subtree[node]]]};  SemanticEntry: PROC [tl: Tree.Link] RETURNS [symbol Tree.Link] = {    sti, dirSti: STIndex;    last: STIndex ¬ STNull;    WITH t:tl SELECT FROM      symbol => RETURN [t];      hash => {        FOR sti ¬ cxb[currentCtx].link, stb[sti].link UNTIL sti = STNull DO          IF stb[sti].hti = t.index THEN RETURN[ [symbol[sti]] ];          last ¬ sti;          ENDLOOP;        FOR dirSti ¬ cxb[directoryCtx].link, stb[dirSti].link	UNTIL dirSti = STNull DO 	  IF stb[dirSti].hti = t.index THEN EXIT;	  ENDLOOP;        sti ¬ BcdUtilDefs.NewSemanticEntry[t.index];        IF last = STNull THEN cxb[currentCtx].link ¬ sti			 ELSE stb[last].link ¬ sti;        IF dirSti # STNull THEN {stb[sti] ¬ stb[dirSti]; stb[sti].link ¬ STNull};        RETURN[ [symbol[sti]] ]};      ENDCASE => ERROR BuildSEError};        EnterFileNames: PROC = {    stLimit: STIndex = LOOPHOLE[table.Bounds[sttype].size];    FOR sti: STIndex ¬ FIRST[STIndex], sti+SIZE[STRecord] UNTIL sti=stLimit DO      WITH s:stb[sti] SELECT FROM        external =>          WITH p: s SELECT FROM            file => IF p.fti = FTNull THEN p.fti ¬ AddFile[s.hti];            ENDCASE;        ENDCASE;      ENDLOOP};  AddFile: PROC [hti: HTIndex] RETURNS [fti: FTIndex] = {    ftLimit: FTIndex = LOOPHOLE[table.Bounds[fttype].size];    name: NameRecord ¬ BcdUtilDefs.NameForHti[hti];    FOR fti ¬ FIRST[FTIndex], fti + SIZE[FTRecord] UNTIL fti = ftLimit DO      IF ftb[fti].name = name THEN RETURN;      ENDLOOP;    fti ¬ table.Words[fttype, SIZE[FTRecord]];    ftb[fti] ¬ [name: name, version: NullVersion]};  END.
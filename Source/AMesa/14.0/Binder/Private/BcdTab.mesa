-- Copyright (C) 1981  by Xerox Corporation. All rights reserved. -- BcdTab.mesa-- last edited by Sandman on October 8, 1980  4:06 PM-- last edited by Lewis on 17-Dec-81 13:33:56DIRECTORY  Alloc USING [AddNotify, DropNotify, Handle, Notifier, Trim, Words],  BcdDefs USING [httype, PackedString, sstype],  Environment USING [charsPerWord],  Inline USING [BITAND, BITXOR],  String USING [    AppendChar, AppendSubString, EqualSubStrings, EquivalentSubStrings,    SubString, SubStringDescriptor],  Symbols: FROM "BcdSymbols" USING [HTIndex, HTNull, HTRecord, HVIndex, HVLength],  SymbolOps: FROM "BcdSymbolOps" USING [],  Table USING [Base, Index];BcdTab: PROGRAM     IMPORTS Alloc, Inline, String     EXPORTS SymbolOps =  BEGIN OPEN Symbols;  SubString: TYPE = String.SubString;  SubStringDescriptor: TYPE = String.SubStringDescriptor;    -- tables defining the current symbol table  table: Alloc.Handle ¬ NIL;  hashVec: LONG POINTER TO ARRAY HVIndex OF HTIndex;  ht: LONG DESCRIPTOR FOR ARRAY --HTIndex-- OF HTRecord;  htb: Table.Base; -- hash table  ssb: LONG POINTER TO BcdDefs.PackedString; -- id string  UpdateBases: Alloc.Notifier = {    OPEN BcdDefs;    htb ¬ base[httype];    ssb ¬ LOOPHOLE[base[sstype]];    hashVec ¬ htb;    ht ¬ DESCRIPTOR[htb + LENGTH[hashVec­]*SIZE[HTIndex], LENGTH[ht]]};  AllocateHash: PROC RETURNS [hti: HTIndex] = {    next: Table.Index = table.Words[BcdDefs.httype, SIZE[HTRecord]];    hti ¬ LENGTH[ht];    IF hti*SIZE[HTRecord] + LENGTH[hashVec­] # LOOPHOLE[next, INTEGER] THEN ERROR;    ht ¬ DESCRIPTOR[BASE[ht], LENGTH[ht] + 1];    ht[hti] ¬ HTRecord[link: HTNull, offset: ssb.string.length + 1];    RETURN[hti - 1]};  -- variables for building the symbol string  ssw: Table.Index;  initialized: BOOLEAN ¬ FALSE;  Initialize: PUBLIC PROC [ownTable: Alloc.Handle] = {    IF initialized THEN Finalize[];    table ¬ ownTable;    hashVec ¬ NIL;    table.AddNotify[UpdateBases, NIL];    Reset[];    initialized ¬ TRUE};  Finalize: PUBLIC PROC = {    table.DropNotify[UpdateBases, NIL];    table ¬ NIL;    initialized ¬ FALSE};  Reset: PUBLIC PROC = {    nullSS: SubStringDescriptor ¬ [base: "null"L, offset: 0, length: 0];    table.Trim[BcdDefs.sstype, 0];    table.Trim[BcdDefs.httype, 0];    [] ¬ table.Words[BcdDefs.httype, HVLength*SIZE[HTIndex]];    hashVec ¬ htb;    hashVec­ ¬ ALL[HTNull];    ht ¬ DESCRIPTOR[htb + LENGTH[hashVec­]*SIZE[HTIndex], 0];    ssw ¬ table.Words[BcdDefs.sstype, SIZE[StringBody]] + SIZE[StringBody];    ssb.string ¬ [length: 0, maxlength: 0, text: ];    [] ¬ AllocateHash[];    IF EnterString[@nullSS] # HTNull THEN ERROR};      -- hash entry creation  EnterString: PUBLIC PROC [s: SubString] RETURNS [hti: HTIndex] = {    hvi: HVIndex = HashValue[s];    desc: SubStringDescriptor ¬ [base: @ssb.string, offset:, length:];    CharsPerWord: CARDINAL = Environment.charsPerWord;    offset, length, nw: CARDINAL;    ssi: Table.Index;    FOR hti ¬ hashVec[hvi], ht[hti].link UNTIL hti = HTNull DO      SubStringForHash[@desc, hti];      IF String.EqualSubStrings[s, @desc] THEN RETURN[hti];      ENDLOOP;    offset ¬ ssb.string.length;    length ¬ s.length + 1;    nw ¬ (offset + length + (CharsPerWord-1) - ssb.string.maxlength)/CharsPerWord;    IF nw # 0 THEN {      IF (ssi ¬ table.Words[BcdDefs.sstype, nw]) # ssw THEN ERROR;      ssw ¬ ssw + nw;      ssb.string ¬ [        text: ,	length: ssb.string.length, maxlength: ssb.string.maxlength + nw*CharsPerWord]};    String.AppendChar[@ssb.string, LOOPHOLE[s.length, CHARACTER]];    String.AppendSubString[@ssb.string, s];    hti ¬ AllocateHash[];    ht[hti].link ¬ hashVec[hvi];    hashVec[hvi] ¬ hti};      -- the following copied from symboltable.mesa  ignoreCases: BOOLEAN ¬ FALSE;  HashValue: PROC [s: SubString] RETURNS [HVIndex] = {    CharBits: PROC [CHARACTER, WORD] RETURNS [WORD] = LOOPHOLE[Inline.BITAND];    Mask: WORD = 337B; -- masks out ASCII case shifts    n: CARDINAL = s.length;    b: LONG STRING = s.base;    v: WORD ¬ CharBits[b[s.offset], Mask]*177B;    IF n > 0 THEN v ¬ v + CharBits[b[s.offset + (n-1)], Mask];    RETURN[Inline.BITXOR[v, n*17B] MOD LENGTH[hashVec­]]};  FindString: PUBLIC PROC [s: SubString] RETURNS [found: BOOLEAN, hti: HTIndex] = {    desc: SubStringDescriptor;    ss: SubString = @desc;    hti ¬ hashVec[HashValue[s]];    WHILE hti # HTNull DO      SubStringForHash[ss, hti];      found ¬	(IF ignoreCases THEN String.EquivalentSubStrings[s, ss]	 ELSE String.EqualSubStrings[s, ss]);      IF found THEN RETURN;      hti ¬ ht[hti].link;      ENDLOOP;    RETURN[FALSE, HTNull]};  FindEquivalentString: PUBLIC PROC [      s: SubString] RETURNS [found: BOOLEAN, hti: HTIndex] = {    oldcase: BOOLEAN = ignoreCases;    ignoreCases ¬ TRUE;    [found, hti] ¬ FindString[s];    ignoreCases ¬ oldcase};  SubStringForHash: PUBLIC PROC [s: SubString, hti: HTIndex] = {    s.base ¬ @ssb.string;    IF hti = HTNull THEN s.offset ¬ s.length ¬ 0    ELSE {s.offset ¬ ht[hti].offset; s.length ¬ ssb.size[ht[hti].offset]}};  END.
-- Copyright (C) 1982  by Xerox Corporation. All rights reserved. -- BindErrors.mesa-- Last edited by Satterthwaite on June 2, 1980  11:19 AM-- Last edited by Schmidt on November 6, 1980  8:08 PM-- Last edited by Lewis on 22-Feb-82 16:43:59DIRECTORY  Alloc USING [Bounds, Handle],  Ascii USING [ControlZ, CR, SP],  BcdControlDefs USING [BinderData, data, NullSourceIndex],  BcdDefs USING [    EXPIndex, EXPNull, exptype, FTIndex, fttype, MTIndex, MTNull,    mttype, NameRecord, NullName, sstype, sttype, VersionStamp],  BcdErrorDefs USING [ErrorClass],  BcdItemName USING [Print],  BcdOps USING [NameString],  Environment USING [Byte],  Format USING [    Blanks, Char, CR, Decimal, Line, Number, NumberFormat, Octal,    StringProc, SubString],  MFile USING [Acquire, Delete, Error, Handle, maxNameLength],  MStream USING [Handle, Log],  Stream USING [EndOfStream, SendNow],  String USING [AppendString, SubString, SubStringDescriptor],  Symbols: FROM "BcdSymbols" USING [HTIndex, HTNull, STIndex, STNull],  SymbolOps: FROM "BcdSymbolOps" USING [SubStringForHash],  Table USING [Base],  Time USING [Append, AppendCurrent, Unpack],  Version USING [Append];BindErrors: PROGRAM    IMPORTS       Alloc, BcdControlDefs, BcdItemName, Format, MFile, MStream, Stream,      String, SymbolOps, Time, Version    EXPORTS BcdErrorDefs =  BEGIN OPEN Symbols, BcdDefs;  ErrorClass: TYPE = BcdErrorDefs.ErrorClass;  SubStringDescriptor: TYPE = String.SubStringDescriptor;  SubString: TYPE = String.SubString;    GetModule: PUBLIC SIGNAL RETURNS [errorMti: MTIndex, linkOffset: CARDINAL] =    CODE;  GetInterface: PUBLIC SIGNAL RETURNS [errorExpi: EXPIndex] = CODE;  GetSti: PUBLIC SIGNAL RETURNS [errorSti: STIndex] = CODE;      gd: BcdControlDefs.BinderData ¬ NIL;  table: Alloc.Handle ¬ NIL;      Initialize: PUBLIC PROC = {    gd ¬ BcdControlDefs.data;    table ¬ gd.ownTable;    gd.errlogOpened ¬ FALSE};      Finalize: PUBLIC PROC = {    IF gd.errlogOpened THEN CloseErrorStream[] ELSE DestroyAnyOldErrlogFile[];    gd.errlogOpened ¬ FALSE;    table ¬ NIL;  gd ¬ NIL};    Error: PUBLIC PROC [class: ErrorClass, s: STRING] = {    Prefix[class];    WriteString[s];    ErrorLog[class]};  ErrorSti: PUBLIC PROC [class: ErrorClass, s: STRING, sti: STIndex] = {    Prefix[class];    WriteHti[HtiForSti[sti]]; WriteSpace[]; WriteString[s];    ErrorLog[class]};  ErrorHti: PUBLIC PROC [class: ErrorClass, s: STRING, hti: HTIndex] = {    sti: STIndex = SIGNAL GetSti;    Prefix[class];    WriteHti[hti];  WriteSpace[];  WriteString[s];    IF sti # STNull THEN {      WriteString[" (in "L];  WriteHti[HtiForSti[sti]];  WriteChar[')]};    ErrorLog[class]};  ErrorName: PUBLIC PROC [class: ErrorClass, s: STRING, name: NameRecord] = {    Prefix[class];    WriteName[name];  WriteSpace[];  WriteString[s];    ErrorLog[class]};  ErrorItem: PUBLIC PROC [class: ErrorClass, s: STRING, i: CARDINAL] = {    expi: EXPIndex = SIGNAL GetInterface;    sti: STIndex = SIGNAL GetSti;    Prefix[class];    WriteString["Item "L];  WriteDecimal[i];    IF expi # EXPNull THEN {       WriteString[" in interface "L];  WriteName[InterfaceName[expi]]};    WriteSpace[];  WriteString[s];    IF sti # STNull THEN {       WriteString[" (in "L];  WriteHti[HtiForSti[sti]];  WriteChar[')]};    ErrorLog[class]};  ErrorModule: PUBLIC PROC [class: ErrorClass, s: STRING, mti: MTIndex] = {    sti: STIndex = SIGNAL GetSti;    Prefix[class];  WriteName[ModuleName[mti]]; WriteSpace[]; WriteString[s];    IF sti # STNull THEN {      WriteString[" (in "L];  WriteHti[HtiForSti[sti]];  WriteChar[')]};    ErrorLog[class]};  ErrorInterface: PUBLIC PROC [      class: ErrorClass, s: STRING,       importName: NameRecord, ep: CARDINAL, importFti: FTIndex] = {    mti: MTIndex;    linkOffset: CARDINAL;    printed: BOOLEAN ¬ FALSE;    PrintItem: PROC [s: SubString] = {WriteSubString[s];  printed ¬ TRUE};    [mti, linkOffset] ¬ SIGNAL GetModule;    Prefix[class];    IF mti # MTNull THEN      BcdItemName.Print[        importerMti: mti, importName: importName, importFti: importFti, 	linkOffset: linkOffset, ep: ep, 	userProc: PrintItem];    IF ~printed THEN {       WriteString["(item "L];  WriteDecimal[ep];  WriteChar[')]};    WriteString[" from "L];    IF importName = NullName THEN WriteString["(unknown)"L]    ELSE WriteName[importName];    WriteSpace[];  WriteString[s];    IF mti # MTNull THEN {      WriteString[" (imported by "L];  WriteName[ModuleName[mti]];  WriteChar[')]};    ErrorLog[class]};  ErrorNameBase: PUBLIC PROC [      class: ErrorClass, s: STRING,       name: NameRecord, base: BcdOps.NameString] = {    Prefix[class];    WriteNameBase[name, base];  WriteSpace[];  WriteString[s];    ErrorLog[class]};  RefInTwoVersions: PUBLIC PROC [      class: ErrorClass,       fileName: NameRecord, v1, v2: VersionStamp] = {    ftb: Table.Base = table.Bounds[fttype].base;    Prefix[class];    WriteName[fileName]; WriteString[" is referenced in two versions: "L];    WriteVersion[v1];  WriteString[" and "L];  WriteVersion[v2];    ErrorLog[class]};  WrongImportVersion: PUBLIC PROC [class: ErrorClass, avail, req: FTIndex] = {    ftb: Table.Base = table.Bounds[fttype].base;    Prefix[class];    WriteName[ftb[req].name];  WriteVersion[ftb[req].version];    WriteString[" is required for import, but only "L];    WriteName[ftb[avail].name];  WriteVersion[ftb[avail].version];    WriteString[" is available"L];    ErrorLog[class]};  WrongExportVersion: PUBLIC PROC [class: ErrorClass, avail, req: FTIndex] = {    ftb: Table.Base = table.Bounds[fttype].base;    Prefix[class];    WriteName[ftb[avail].name];  WriteVersion[ftb[avail].version];    WriteString[" is being exported, but "L];    WriteName[ftb[req].name];  WriteVersion[ftb[req].version];    WriteString[" is required"L];    ErrorLog[class]};  ErrorFile: PUBLIC PROC [class: ErrorClass, s: STRING, fti: FTIndex] = {    ftb: Table.Base = table.Bounds[fttype].base;    Prefix[class];    WriteName[ftb[fti].name]; WriteSpace[]; WriteString[s];    ErrorLog[class]};  Error2Files: PUBLIC PROC [class: ErrorClass, s: STRING, ft1, ft2: FTIndex] = {    ftb: Table.Base = table.Bounds[fttype].base;    Prefix[class];    WriteName[ftb[ft1].name];  WriteVersion[ftb[ft1].version];    WriteSpace[]; WriteString[s];  WriteSpace[];    WriteName[ftb[ft2].name];  WriteVersion[ftb[ft2].version];    ErrorLog[class]}; -- Subroutines   out: MStream.Handle ¬ NIL;  WriteString: PUBLIC Format.StringProc = {    out.put[      sH: out, block: [LOOPHOLE[@s.text], 0, s.length],      endRecord: FALSE]};  WriteLine: PUBLIC PROC [s: LONG STRING] = {Format.Line[WriteString, s]};  WriteChar: PUBLIC PROC [c: CHARACTER] = {Format.Char[WriteString, c]};  WriteCR: PUBLIC PROC = {Format.CR[WriteString]};  WriteSpace: PUBLIC PROC = {Format.Char[WriteString, Ascii.SP]};  WriteBlanks: PUBLIC PROC [n: CARDINAL] = {Format.Blanks[WriteString, n]};  WriteNumber: PUBLIC PROC [n: UNSPECIFIED, format: Format.NumberFormat] = {    Format.Number[WriteString, n, format]};  WriteDecimal: PUBLIC PROC [n: INTEGER] = {Format.Decimal[WriteString, n]};  WriteOctal: PUBLIC PROC [n: INTEGER] = {Format.Octal[WriteString, n]};  WriteSubString: PUBLIC PROC [ss: String.SubString] = {    Format.SubString[WriteString, ss]};  OpenErrorStream: PUBLIC PROC = {    IF ~gd.errlogOpened THEN {      IF gd.errorStream # NIL THEN ERROR;      IF gd.mergeErrlogs THEN  -- just use Binder.log stream        out ¬ gd.errorStream ¬ gd.logStream      ELSE {        errorName: STRING ¬ [MFile.maxNameLength];	String.AppendString[errorName, gd.rootName];	String.AppendString[errorName, ".errlog"L];        out ¬ gd.errorStream ¬ MStream.Log[name: errorName, release: []];        HeraldToErrlog[errorName];          CommandToErrlog[]};      gd.errlogOpened ¬ TRUE}};        AcquireErrorStream: PUBLIC PROC RETURNS [errorStream: MStream.Handle] = {    OpenErrorStream[];    RETURN[gd.errorStream]};    HeraldToErrlog: PROC [errorName: LONG STRING] = {     s: STRING ¬ [60];    String.AppendString[s, "Mesa Binder "L];  Version.Append[s];    String.AppendString[s, " of "L];    Time.Append[s, Time.Unpack[LOOPHOLE[gd.binderVersion.time]]];    s.length ¬ s.length - 3;    WriteLine[s];    s.length ¬ 0;    Time.AppendCurrent[s];  s.length ¬ s.length - 3;    WriteString[errorName];  WriteString[" -- "L];  WriteLine[s]};  CommandToErrlog: PROC = {    WriteCR[];    WriteString["Binding "L];  WriteString[gd.sourceName];    IF gd.renamedOutput THEN {WriteString[", Bcd to "L];  WriteString[gd.bcdName]};    IF gd.copyCode THEN {      WriteString[", code to "L];      WriteString[IF gd.codeName = NIL THEN "Bcd"L ELSE gd.codeName]};    IF gd.copySymbols THEN {      WriteString[", symbols to "L];      WriteString[IF gd.symbolName = NIL THEN "Bcd"L ELSE gd.symbolName]};    WriteCR[]};      CloseErrorStream: PROC = {    IF gd.errlogOpened THEN {      IF gd.mergeErrlogs THEN   -- we have been writing to Binder.log        Stream.SendNow[out]     -- force out messages      ELSE IF out # NIL THEN out.delete[out];       out ¬ gd.errorStream ¬ NIL}};      DestroyAnyOldErrlogFile: PROC = {  -- called if there were no errors    errlogFile: MFile.Handle ¬ NIL;    errorName: STRING ¬ [MFile.maxNameLength];    String.AppendString[errorName, gd.rootName];    String.AppendString[errorName, ".errlog"L];    errlogFile ¬ MFile.Acquire[name: errorName, access: delete, release: []      ! MFile.Error => CONTINUE];    IF errlogFile # NIL THEN MFile.Delete[errlogFile ! MFile.Error => CONTINUE]};      Prefix: PROC [class: ErrorClass] = {  -- all errors pass through here first    IF ~gd.errlogOpened THEN OpenErrorStream[];    WriteCR[];    -- need new feedback scheme    IF class = warning THEN WriteString["Warning: "L]};	     ErrorLog: PROC [class: ErrorClass] = {    decimal: Format.NumberFormat =      [base:10, columns:1, unsigned:TRUE, zerofill: FALSE];    IF gd.textIndex # BcdControlDefs.NullSourceIndex THEN {      WriteString[", at "L];  WriteName[gd.currentName];      WriteChar['[];  WriteNumber[gd.textIndex, decimal];      WriteChar[']];  WriteCR[];      PrintTextLine[gd.textIndex]};    SELECT class FROM      error =>   {gd.errors ¬ TRUE;    gd.nErrors ¬ gd.nErrors + 1};      warning => {gd.warnings ¬ TRUE;  gd.nWarnings ¬ gd.nWarnings + 1};      ENDCASE};  PrintTextLine: PROC [origin: LONG CARDINAL] = {    in: MStream.Handle = gd.sourceStream;    start, lineIndex: LONG CARDINAL ¬ origin;    char: CHARACTER;    THROUGH [1..200] UNTIL lineIndex = 0 DO      lineIndex ¬ lineIndex - 1;      in.setPosition[in, lineIndex];      IF in.getByte[in] = LOOPHOLE[Ascii.CR] THEN EXIT;      start ¬ lineIndex;      ENDLOOP;    in.setPosition[in, start];    THROUGH [1..100] DO      char ¬ LOOPHOLE[in.getByte[in ! Stream.EndOfStream => GOTO eof]];      SELECT char FROM	Ascii.CR, Ascii.ControlZ => EXIT;	ENDCASE => WriteChar[char];      REPEAT eof => NULL;      ENDLOOP;    WriteCR[]};  WriteNameBase: PROC [name: NameRecord, s: BcdOps.NameString] = {    offset: CARDINAL = name;    length: CARDINAL = s.size[name];    IF offset+length > s.string.length THEN RETURN;    FOR i: CARDINAL IN [offset..offset+MIN[length,100]) DO      WriteChar[s.string.text[i]];      ENDLOOP};  WriteName: PROC [name: NameRecord] = {    WriteNameBase[name, LOOPHOLE[table.Bounds[sstype].base]]};  WriteVersion: PROC [v: VersionStamp] = {    octal: Format.NumberFormat =       [base:8, zerofill:FALSE, unsigned:TRUE, columns:1];    s: STRING = [20];    IF v.time = 0 THEN WriteString["(Null Version)"L]    ELSE {      Time.Append[s, Time.Unpack[LOOPHOLE[v.time]]];      WriteChar['(];  WriteString[s];  WriteSpace[];      WriteNumber[v.net, octal];   WriteChar['#];      WriteNumber[v.host, octal];  WriteChar['#];      WriteChar[')]}};  WriteHti: PROC [hti: HTIndex] = {    IF hti = HTNull THEN WriteString["(anon)"L]    ELSE {      ss: SubStringDescriptor;      SymbolOps.SubStringForHash[@ss, hti];      WriteSubString[@ss]}};  HtiForSti: PROC [sti: STIndex] RETURNS [HTIndex] = {    RETURN[      (IF sti = STNull THEN HTNull      ELSE table.Bounds[sttype].base[sti].hti) ]};  InterfaceName: PROC [expi: EXPIndex] RETURNS [NameRecord] = {    RETURN[      (IF expi = EXPNull THEN NullName      ELSE table.Bounds[exptype].base[expi].name) ]};  ModuleName: PROC [mti: MTIndex] RETURNS [NameRecord] = {    RETURN[      (IF mti = MTNull THEN NullName      ELSE table.Bounds[mttype].base[mti].name) ]};  END.
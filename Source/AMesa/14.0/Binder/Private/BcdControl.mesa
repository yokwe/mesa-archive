-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- BcdControl.mesa - last edited by--   Satterthwaite	July 1, 1980  9:00 AM--   Schmidt	November 6, 1980  8:24 PM--   JGS	 5-Oct-82 10:40:38--   SHayes	 1-Sep-81 17:38:01--   Bruce	 4-Nov-81 18:08:32--   Lewis	13-Dec-83 16:08:04--   Johnsson	13-Jun-83 15:36:28DIRECTORY  Alloc USING [    Chunkify, Create, defaultChunkType, Destroy, Failure, Overflow, Reset,    TableInfo, defaultIndexBits],  BcdBindDefs USING [RelocHandle],  BcdControlDefs USING [    BinderData, BinderDataRecord, BindRoot, BuildSemanticEntries,    CreateBcd, LoadRoot, MarkFileBad, NullSourceIndex, PrintBcd, PrintRelocations,    PrintSemanticEntries, PrintTree, WriteBcd],  BcdDefs USING [    BinderNTables, EXPNull, FTNull, MTNull, NullName, NullVersion, VersionStamp],  BcdErrorDefs USING [Finalize, GetInterface, GetModule, GetSti, Initialize],  BcdParseData USING [],  BcdUtilDefs USING [EnterFile, Init, Reset],  CommandUtil USING [    CommandPtr, CopyString, Create, Destroy, Echo, Failed, FreePairList,    FreeString, GetNthPair, ListLength,  PairList, Parse, SetExtension],  Exec USING [    AddCommand, CheckForAbort, ExecProc, GetChar, Handle, Outcome, OutputProc],  Format USING [Char, CR, Line, StringProc],  Heap USING [Create, Delete],  Inline USING [BITXOR, HighByte, LowByte, LowHalf],  MFile USING [Error, GetProperties, GetTimes, maxNameLength, NameForError],  MSegment USING [Error, GetFile],  MStream USING [Error, GetFile, ReadOnly, WriteOnly],  P1: FROM "BcdParseDefs" USING [Parse],  ProcessorFace USING [processorID],  Runtime USING [GetTableBase, CallDebugger, GetBcdTime],   SpecialExec USING [binderSwitches],  Stream USING [Delete],  String USING [AppendChar, AppendDecimal, AppendString, EquivalentStrings],  Symbols: FROM "BcdSymbols" USING [STNull],  SymbolOps: FROM "BcdSymbolOps" USING [Finalize, Initialize],  Time USING [Append, AppendCurrent, Current, Unpack],  Tree: FROM "BcdTree" USING [Link],  TreeOps: FROM "BcdTreeOps" USING [PopTree, Finalize, Initialize],  Version USING [Append],  Volume USING [InsufficientSpace];BcdControl: MONITOR []     IMPORTS      Alloc, BcdControlDefs, BcdErrorDefs, BcdParseData, BcdUtilDefs,      CommandUtil, Exec, Format, Heap, Inline, MFile, MSegment, MStream,      P1, ProcessorFace, Runtime, SpecialExec, Stream, String,      SymbolOps, Time, TreeOps, Version, Volume    EXPORTS BcdControlDefs     SHARES ProcessorFace =  BEGIN   gd: BcdControlDefs.BinderData ¬ NIL;  -- copy of "data"  nowBinding: BOOLEAN ¬ FALSE;  execProc: Format.StringProc;  cmdPtr: CommandUtil.CommandPtr ¬ NIL;  results: CommandUtil.PairList;  key, value, switches: LONG STRING ¬ NIL;  abortRequested: BOOLEAN ¬ FALSE;    parsed: BOOLEAN;  root: Tree.Link;  relocationHead: BcdBindDefs.RelocHandle ¬ NIL;  globalErrors, globalWarnings: BOOLEAN ¬ FALSE;  startTime: LONG CARDINAL;    globalCopyCode, globalCopySymbols, globalCopyAll, copyAll: BOOLEAN;  globalPause, globalPauseOnWarnings: BOOLEAN;  globalMergeErrlogs, globalDebugging: BOOLEAN;  globalDebugPass, debugPass: CARDINAL;   -- Binder startup and closedown   StartBinder: PROC = {    execProc ¬ Exec.OutputProc[gd.exec];    NoteHerald[];    OpenLog[];    cmdPtr ¬ CommandUtil.Create[Get];    abortRequested ¬ FALSE;    SetupGlobalDefaults[];    ProcessGlobalSwitches[SpecialExec.binderSwitches]};      Get: PROC RETURNS [CHARACTER] = {RETURN[Exec.GetChar[gd.exec]]};    SetupGlobalDefaults: PROC = {    globalCopyCode ¬ TRUE;    globalCopySymbols ¬ globalCopyAll ¬ FALSE;    globalMergeErrlogs ¬ FALSE;    globalPause ¬ FALSE;    globalPauseOnWarnings ¬ TRUE;    globalDebugging ¬ FALSE;  globalDebugPass ¬ LAST[CARDINAL];    globalErrors ¬ globalWarnings ¬ FALSE};      StopBinder: PROC = {    FinalizeOneBinding[];  -- make sure everything is cleaned up    IF freeTablesAfterBind THEN FreeAllocTables[];    CloseLog[];    IF cmdPtr # NIL THEN CommandUtil.Destroy[cmdPtr];    cmdPtr ¬ NIL;    gd ¬ NIL;    DoneBinding[]};      FreeAllocTables: PROC = {    IF gd.ownTable # NIL THEN {Alloc.Destroy[gd.ownTable];  gd.ownTable ¬ NIL}}; -- Exec window feedback   worstErrorSeverity: {none, warnings, errors} ¬ none;   InitializeFeedback: PROC = {worstErrorSeverity ¬ none};    NoteHerald: PROC = {     s: STRING ¬ [60];    String.AppendString[s, "Mesa Binder "L];  Version.Append[s];    String.AppendString[s, " of "L];    Time.Append[s, Time.Unpack[LOOPHOLE[gd.binderVersion.time]]];    s.length ¬ s.length - 3;    String.AppendString[s, "..."L];    execProc[s];  Format.CR[execProc]};   NoteCommand: PROC = {    OPEN String;    item: STRING ¬ [60];    AppendString[item, gd.rootName];    IF ~gd.copyCode OR gd.copySymbols OR gd.mergeErrlogs OR gd.debug       OR gd.pause OR ~gd.pauseOnWarnings THEN AppendChar[item, '/];     IF copyAll THEN AppendChar[item, 'a]    ELSE {      IF ~gd.copyCode THEN AppendString[item, "-c"L];      IF gd.copySymbols THEN AppendChar[item, 's]};    IF gd.mergeErrlogs THEN AppendChar[item, 'e];    IF gd.pause THEN AppendChar[item, 'p];    IF ~gd.pauseOnWarnings THEN AppendString[item, "-w"L];    IF gd.debug THEN AppendChar[item, 'd];    execProc[item]};      NoteProgress: PROC [pass: CARDINAL] = {execProc["."L]};        NoteWarnings: PUBLIC PROC = {    SELECT worstErrorSeverity FROM      none => {execProc[" Warnings "L];  worstErrorSeverity ¬ warnings};      ENDCASE};        NoteErrors: PUBLIC PROC = {    SELECT worstErrorSeverity FROM      none, warnings => {execProc[" Errors "L];  worstErrorSeverity ¬ errors};      ENDCASE};        NoteStatistics: PROC [stats: STRING] = {    execProc[stats];  Format.CR[execProc]};     -- Binder log  LogString: Format.StringProc = {    IF s # NIL THEN       gd.logStream.put[        sH: gd.logStream, block: [LOOPHOLE[@s.text], 0, s.length],        endRecord: FALSE]};  LogLine: PROC [s: LONG STRING] = {LogString[s];  LogCR[]};  LogChar: PROC [c: CHARACTER] = {Format.Char[LogString, c]};  LogCR: PROC = {Format.CR[LogString]};    OpenLog: PROC = {    gd.logStream ¬ MStream.WriteOnly[      name: "Binder.Log"L, release: [], type: text];    HeraldToLog[]};      CloseLog: PROC = {    IF gd.logStream # NIL THEN Stream.Delete[gd.logStream];    gd.logStream ¬ NIL};    HeraldToLog: PROC = {     s: STRING ¬ [60];    String.AppendString[s, "Mesa Binder "L];  Version.Append[s];    String.AppendString[s, " of "L];    Time.Append[s, Time.Unpack[LOOPHOLE[gd.binderVersion.time]]];    s.length ¬ s.length - 3;    LogLine[s];    s.length ¬ 0;    Time.AppendCurrent[s];  s.length ¬ s.length - 3;    LogLine[s]};      EchoCommand: PROC = {    LogCR[];    LogString["Command: "];    CommandUtil.Echo[      d: LogString,      operator: gd.sourceName, argList: gd.cmdLineArgList,       resultList: results, switches: switches]};  LogInterpretedCommand: PROC = {    LogCR[];    LogString["Binding "L];  LogString[gd.sourceName];    IF gd.renamedOutput THEN {LogString[", Bcd to "L];  LogString[gd.bcdName]};    IF gd.copyCode THEN {      LogString[", code to "L];      LogString[IF gd.codeName = NIL THEN "Bcd"L ELSE gd.codeName]};    IF gd.copySymbols THEN {      LogString[", symbols to "L];      LogString[IF gd.symbolName = NIL THEN "Bcd"L ELSE gd.symbolName]};    LogCR[]};       -- Initialization and finalization on each binding pass   SetupLocalDefaults: PROC = {    gd.rootName.length ¬ 0;    gd.renamedOutput ¬ gd.typeExported ¬ FALSE;    gd.copyCode        ¬ (globalCopyCode OR globalCopyAll);    gd.copySymbols     ¬ (globalCopySymbols OR globalCopyAll);    gd.pause           ¬ globalPause;    gd.pauseOnWarnings ¬ globalPauseOnWarnings;    gd.mergeErrlogs    ¬ globalMergeErrlogs;    gd.debug           ¬ globalDebugging;    gd.errors ¬ gd.warnings ¬ FALSE;    gd.nErrors ¬ gd.nWarnings ¬ 0;    gd.nModules        ¬ 0;    gd.outModules ¬ gd.outConfigs ¬ gd.outBcdPages ¬ 0;    gd.currentName     ¬ BcdDefs.NullName;    gd.textIndex       ¬ BcdControlDefs.NullSourceIndex;      copyAll            ¬ globalCopyAll;    debugPass          ¬ globalDebugPass};      bindingInitialized: BOOLEAN ¬ FALSE;    InitializeOneBinding: PROC = {    weights: ARRAY [0..BcdDefs.BinderNTables) OF Alloc.TableInfo ¬ [      [Alloc.defaultIndexBits, 3, 6],   -- trees      [Alloc.defaultIndexBits, 3, 6],   -- hash table      [Alloc.defaultIndexBits, 4, 8],   -- (packed) string table      [Alloc.defaultIndexBits, 3, 6],   -- config table      [Alloc.defaultIndexBits, 4, 8],   -- module table      [Alloc.defaultIndexBits, 3, 6],   -- import table      [Alloc.defaultIndexBits, 3, 6],   -- export table      [Alloc.defaultIndexBits, 3, 6],   -- segment table      [Alloc.defaultIndexBits, 3, 6],   -- file table      [Alloc.defaultIndexBits, 3, 6],   -- semantic table      [Alloc.defaultIndexBits, 3, 6],   -- context table      [Alloc.defaultIndexBits, 1, 2],   -- name table      [Alloc.defaultIndexBits, 3, 6],   -- external variable table      [Alloc.defaultIndexBits, 1, 4],   -- space table      [Alloc.defaultIndexBits, 1, 4],   -- frame pack table      [Alloc.defaultIndexBits, 1, 2],   -- type table      [Alloc.defaultIndexBits, 1, 2],   -- type map table      [Alloc.defaultIndexBits, 4, 8],   -- link fragment table      [Alloc.defaultIndexBits, 1, 2],   -- atom table table      [Alloc.defaultIndexBits, 1, 2]];  -- atom printname (packed string)    OpenInput[];    IF gd.ownTable = NIL THEN {      gd.ownTable ¬ Alloc.Create[weights: DESCRIPTOR[weights]];      Alloc.Chunkify[h: gd.ownTable, table: Alloc.defaultChunkType]}    ELSE Alloc.Reset[gd.ownTable];     gd.zone ¬ Heap.Create[initial: 9, increment: 3, swapUnitSize: 3];      SymbolOps.Initialize[gd.ownTable];      TreeOps.Initialize[];    BcdUtilDefs.Init[gd.ownTable];    BcdErrorDefs.Initialize[];    bindingInitialized ¬ TRUE};  FinalizeOneBinding: PROC = {    IF bindingInitialized THEN {      CloseInput[];      TreeOps.Finalize[];  SymbolOps.Finalize[];      Heap.Delete[gd.zone];  gd.zone ¬ NIL;      BcdUtilDefs.Reset[];      Alloc.Reset[gd.ownTable];      IF gd.errlogOpened AND ~gd.mergeErrlogs THEN {        LogString["See "L];  LogString[gd.rootName];  LogLine[".errlog"]};      BcdErrorDefs.Finalize[];      IF gd.nErrors # 0 OR abortRequested THEN        BcdControlDefs.MarkFileBad[gd.bcdName];      ReportStatistics[];      bindingInitialized ¬ FALSE}};        ReportStatistics: PROC = {    OPEN String;    stats: STRING ¬ [90];    SELECT TRUE FROM      abortRequested => AppendString[stats, " Aborted"L];      gd.errors => {        AppendString[stats, "err: "L];	AppendDecimal[stats, gd.nErrors]};      ENDCASE => {        IF gd.outConfigs > 1 THEN {	    AppendString[stats, "configs: "L];	    AppendDecimal[stats, gd.outConfigs];	    AppendString[stats, ", modules: "L]}	ELSE AppendString[stats, "modules: "L];        AppendDecimal[stats, gd.outModules];  	AppendString[stats, ", pages: "L];        AppendDecimal[stats, gd.outBcdPages];	IF gd.warnings THEN {          AppendString[stats, ", warn: "L];	  AppendDecimal[stats, gd.nWarnings]}};    AppendString[stats, ", time: "L];    AppendDecimal[stats, Inline.LowHalf[(Time.Current[] - startTime)]];    LogLine[stats];    NoteStatistics[stats]}; -- Command processing    ProcessCommand: PROC = {    ProcessResultList[];  SetRootName[];  ProcessLocalSwitches[];    SetupFileNames[]};        ProcessResultList: PROC = {    FOR n: CARDINAL IN [0..CommandUtil.ListLength[results]) DO      [key, value] ¬ CommandUtil.GetNthPair[list: results, n: n];      SELECT TRUE FROM	(key = NIL), String.EquivalentStrings[key, "bcd"] => { 	  gd.bcdName ¬ value;  gd.renamedOutput ¬ TRUE};	String.EquivalentStrings[key, "code"] => { 	  gd.codeName ¬ value;  gd.copyCode ¬ TRUE};	String.EquivalentStrings[key, "symbols"] => {  	  gd.symbolName ¬ value;  gd.copySymbols ¬ TRUE};	ENDCASE => ERROR ABORTED;      ENDLOOP};   SetRootName: PROC = {    result: LONG STRING ¬       (IF gd.bcdName # NIL THEN gd.bcdName ELSE gd.sourceName);    gd.rootName.length ¬ 0;    FOR i: CARDINAL IN [0..result.length) DO       IF result[i] = '. THEN EXIT;        String.AppendChar[gd.rootName, result[i]];       ENDLOOP};	  ProcessLocalSwitches: PROC = {    IF switches # NIL THEN {      sense: BOOLEAN ¬ TRUE;      FOR i: CARDINAL IN [0..switches.length) DO        c: CHARACTER = switches[i];        SELECT c FROM          'c, 'C => {gd.copyCode     ¬ sense;  sense ¬ TRUE};          's, 'S => {gd.copySymbols  ¬ sense;  sense ¬ TRUE};          'e, 'E => {gd.mergeErrlogs ¬ sense;  sense ¬ TRUE};          'p, 'P => {gd.pause        ¬ sense;  sense ¬ TRUE};          'd, 'D => {gd.debug        ¬ sense;  sense ¬ TRUE};          'a, 'A => {            IF (copyAll ¬ sense) THEN gd.copySymbols ¬ gd.copyCode ¬ TRUE;            sense ¬ TRUE};          'w, 'W => {gd.pauseOnWarnings ¬ sense;  sense ¬ TRUE};          IN ['0..'5] => {gd.debug ¬ sense;  debugPass ¬ c-'0;  sense ¬ TRUE};          '! => {Runtime.CallDebugger["Called from Binder"L];  sense ¬ TRUE};          '-, '~ => sense ¬ ~sense;          ENDCASE;        ENDLOOP;      switches ¬ CommandUtil.FreeString[switches]}};        ProcessGlobalSwitches: PROC [switches: LONG STRING] = {    sense: BOOLEAN ¬ TRUE;    IF switches # NIL THEN {      SetupGlobalDefaults[];      FOR i: CARDINAL IN [0..switches.length) DO        c: CHARACTER = switches[i];        SELECT c FROM          'c, 'C => {globalCopyCode     ¬ sense;  sense ¬ TRUE};          's, 'S => {globalCopySymbols  ¬ sense;  sense ¬ TRUE};          'e, 'E => {globalMergeErrlogs ¬ sense;  sense ¬ TRUE};          'p, 'P => {globalPause        ¬ sense;  sense ¬ TRUE};          'd, 'D => {globalDebugging    ¬ sense;  sense ¬ TRUE};          'a, 'A => {globalCopyAll      ¬ sense;  sense ¬ TRUE};          'w, 'W => {globalPauseOnWarnings ¬ sense;  sense ¬ TRUE};          IN ['0..'5] => {globalDebugPass ¬ c-'0;  sense ¬ TRUE};          '! => Runtime.CallDebugger["Called from Binder"L];          '-, '~ => sense ¬ ~sense;          ENDCASE;        ENDLOOP}};    SetupFileNames: PROC = {    gd.sourceName ¬ SetFileName[gd.sourceName, "config"];    gd.bcdName    ¬ SetFileName[gd.bcdName, "bcd"];    IF gd.copyCode AND gd.codeName # NIL THEN {      gd.codeName ¬ SetFileName[gd.codeName, "code"];      IF String.EquivalentStrings[gd.codeName, gd.bcdName] THEN        gd.codeName ¬ CommandUtil.FreeString[gd.codeName]};    IF gd.copySymbols AND ~(copyAll AND gd.symbolName = NIL) THEN {      gd.symbolName ¬ SetFileName[gd.symbolName, "symbols"];      IF String.EquivalentStrings[gd.symbolName, gd.bcdName] THEN        gd.symbolName ¬ CommandUtil.FreeString[gd.symbolName]}};  SetFileName: PROC [      fileName, extension: LONG STRING] RETURNS [LONG STRING] = {    root: LONG STRING =       (IF fileName # NIL THEN fileName       ELSE CommandUtil.CopyString[gd.rootName, 2+extension.length]);    RETURN[CommandUtil.SetExtension[root, extension]]};      FreeCommand: PROC = {    IF gd.sourceName # NIL THEN      gd.sourceName ¬ CommandUtil.FreeString[gd.sourceName];    IF gd.bcdName # NIL THEN      gd.bcdName ¬ CommandUtil.FreeString[gd.bcdName];    IF gd.codeName # NIL THEN      gd.codeName ¬ CommandUtil.FreeString[gd.codeName];    IF gd.symbolName # NIL THEN      gd.symbolName ¬ CommandUtil.FreeString[gd.symbolName];    gd.cmdLineArgList ¬ CommandUtil.FreePairList[gd.cmdLineArgList];    IF switches # NIL THEN switches ¬ CommandUtil.FreeString[switches]};   -- Input stream    OpenInput: PROC = {    gd.sourceStream ¬ MStream.ReadOnly[      name: gd.sourceName, release: [] ! MStream.Error => GOTO NotFound];    gd.sourceVersion ¬ BcdDefs.VersionStamp[      net: 0, host: 0,      time: MFile.GetTimes[MStream.GetFile[gd.sourceStream]].create];    EXITS NotFound => {gd.sourceStream ¬ NIL;  ERROR ABORTED}};        CloseInput: PROC = {    IF gd.sourceStream # NIL THEN Stream.Delete[gd.sourceStream];    gd.sourceStream ¬ NIL};         -- Debugging    Debug: PROC [pass: CARDINAL] = {    OPEN BcdControlDefs;    IF gd.debug AND pass >= debugPass THEN {      PrintTree[root];  PrintSemanticEntries[];      SELECT pass FROM        1 => NULL;	2 => {PrintBcd[];  PrintRelocations[relocationHead]};	3 => PrintRelocations[relocationHead];	ENDCASE}};      -- Binder serialization    AlreadyBinding: ENTRY PROC RETURNS [BOOLEAN] = {    IF nowBinding THEN RETURN[TRUE];    nowBinding ¬ TRUE;    RETURN[FALSE]};    DoneBinding: ENTRY PROC = {nowBinding ¬ FALSE};    -- ################  M A I N   B O D Y   C O D E  ################  Bind: Exec.ExecProc = {     BEGIN ENABLE UNWIND => StopBinder[];        IF AlreadyBinding[] THEN {       Exec.OutputProc[h][" Binder already running!"L];      RETURN[abort]};       gd ¬ data;  gd.exec ¬ h;      StartBinder[ ! MFile.Error, MStream.Error => GOTO NoLogFile];    DO  -- until no bind commands remain      BEGIN                ENABLE {           ABORTED => GOTO AbortBinder;          Volume.InsufficientSpace => GOTO VolumeFull;	  MFile.Error => {            name: LONG STRING ¬ [MFile.maxNameLength];            SELECT TRUE FROM	      (code = invalidHandle) => name ¬ "unknown"L;	      (file = NIL) => name ¬ (SIGNAL MFile.NameForError[]);	      ENDCASE => [] ¬ MFile.GetProperties[file, name];	    LogCR[];  	    LogString["Error accessing file "L];  LogString[name];            SELECT code FROM	      noSuchFile	 => LogLine[": noSuchFile"L];	      conflictingAccess	 => LogLine[": conflictingAccess"L];	      directoryFull	 => LogLine[": directoryFull"L];	      directoryNotEmpty  => LogLine[": directoryNotEmpty"L];	      illegalName	 => LogLine[": illegalName"L];	      insufficientAccess => LogLine[": insufficientAccess"L];	      volumeNotOpen	 => LogLine[": volumeNotOpen"L];	      noRootDirectory	 => LogLine[": noRootDirectory"L];	      directoryOnSearchPath => LogLine[": directoryOnSearchPath"L];	      nullAccess	 => LogLine[": nullAccess"L];	      protectionFault	 => LogLine[": protectionFault"L];	      illegalSearchPath  => LogLine[": illegalSearchPath"L];	      noRoomOnVolume	 => LogLine[": noRoomOnVolume"L];	      fileAlreadyExists  => LogLine[": fileAlreadyExists"L];	      invalidHandle	 => LogLine[": invalidHandle"L];	      other		 => LogLine[": other"L];	      ENDCASE		 => LogLine[": (unknown MFile.Error)"L];   	    GOTO FileProblemWhileBinding};          MStream.Error => { 	    name: LONG STRING ¬ [MFile.maxNameLength];            SELECT TRUE FROM	      (stream = NIL) => name ¬ "unknown"L;	      (code = invalidHandle) => name ¬ "unknown"L;	      ENDCASE => [] ¬ MFile.GetProperties[MStream.GetFile[stream], name];	    LogCR[];  	    LogString["Error accessing stream on file "L];	    LogString[IF name.length > 0 THEN name ELSE "unknown"L];	    SELECT code FROM	      invalidHandle    => LogLine[": invalidHandle"L];	      indexOutOfRange  => LogLine[": indexOutOfRange"L];	      invalidOperation => LogLine[": invalidOperation"L];	      fileTooLong      => LogLine[": fileTooLong"L];	      fileNotAvailable => LogLine[": fileNotAvailable"L];	      other            => LogLine[": other"L];	      ENDCASE          => LogLine[": (unknown MStream.Error)"L];	    GOTO FileProblemWhileBinding};	  MSegment.Error => { 	    name: LONG STRING ¬ [MFile.maxNameLength];            SELECT TRUE FROM	      (segment = NIL) => name ¬ "unknown"L;	      (code = noSuchSegment) => name ¬ "unknown"L;	      ENDCASE => [] ¬ MFile.GetProperties[MSegment.GetFile[segment], name];	    LogCR[];  	    LogString["Error accessing segment on file "L];	    LogString[IF name.length > 0 THEN name ELSE "unknown"L];	    SELECT code FROM	      zeroLength         => LogLine[": zeroLength"L];	      insufficientVM     => LogLine[": insufficientVM"L];	      noSuchSegment      => LogLine[": noSuchSegment"L];	      sharedSegment      => LogLine[": sharedSegment"L];	      baseOutOfRange     => LogLine[": baseOutOfRange"L];	      conflictingAccess  => LogLine[": conflictingAccess"L];	      illegalAccess      => LogLine[": illegalAccess"L];	      other              => LogLine[": other"L];              ENDCASE            => LogLine[": (unknown MSegment.Error)"L];	    GOTO FileProblemWhileBinding}};      startTime ¬ Time.Current[];      InitializeFeedback[];      SetupLocalDefaults[];      [resultList: results, operator: gd.sourceName, argList: gd.cmdLineArgList,       switches: switches] ¬          CommandUtil.Parse[  	    cmd: cmdPtr, opX: 2+("config").length, resultX: 2+("symbols").length,  	    allowNoTagParm: TRUE  	    ! CommandUtil.Failed => GOTO BadSyntax];      IF gd.sourceName = NIL AND switches = NIL THEN EXIT;  -- done binding      EchoCommand[];        IF gd.sourceName = NIL THEN GOTO GlobalSwitches;      ProcessCommand[ ! ABORTED => GOTO BadSemantics];      LogInterpretedCommand[];  NoteCommand[];       InitializeOneBinding[ ! ABORTED => GOTO NoSource];        BEGIN  	  ENABLE {	    ABORTED => GOTO Abort;  	    BcdErrorDefs.GetModule    => RESUME[BcdDefs.MTNull, 0];  	    BcdErrorDefs.GetInterface => RESUME[BcdDefs.EXPNull];  	    BcdErrorDefs.GetSti       => RESUME[Symbols.STNull];	    Alloc.Overflow => RESUME[8];	    Alloc.Failure => GOTO Overflow};        NoteProgress[pass: 1];        IF Exec.CheckForAbort[h] THEN GOTO Abort;        [complete: parsed, nErrors: gd.nErrors] ¬ P1.Parse[  	  sourceStream: gd.sourceStream,  	  table: Runtime.GetTableBase[LOOPHOLE[BcdParseData]],	  zone: gd.zone];        IF gd.nErrors > 0 THEN {gd.errors ¬ TRUE;  NoteErrors[]};        IF ~parsed THEN GOTO ParseFailed;        IF Exec.CheckForAbort[h] THEN GOTO Abort;        root ¬ TreeOps.PopTree[];        BcdControlDefs.BuildSemanticEntries[root];        gd.outputFti ¬ BcdUtilDefs.EnterFile[gd.bcdName];        Debug[pass: 1];        NoteProgress[pass: 2];        IF Exec.CheckForAbort[h] THEN GOTO Abort;        relocationHead ¬ BcdControlDefs.LoadRoot[root];        Debug[pass: 2];        NoteProgress[pass: 3];        IF Exec.CheckForAbort[h] THEN GOTO Abort;        BcdControlDefs.BindRoot[relocationHead];        Debug[pass: 3];        IF ~gd.errors THEN {          abort: BOOLEAN;          NoteProgress[pass: 4];          IF Exec.CheckForAbort[h] THEN GOTO Abort;          abort ¬ BcdControlDefs.CreateBcd[root];  	  NoteProgress[pass: 5];  	  abort ¬ BcdControlDefs.WriteBcd[];  	  IF abort OR Exec.CheckForAbort[h] THEN GOTO Abort};        EXITS  	  Abort => {abortRequested ¬ TRUE};          ParseFailed => NULL;          Overflow => {  	    LogCR[];  LogLine["Storage Overflow"];  	    gd.errors ¬ TRUE;  NoteErrors[]};        END;      FinalizeOneBinding[];      EXITS        AbortBinder => {          LogCR[];  LogLine["...Binder aborted."];          abortRequested ¬ TRUE};        VolumeFull => {          LogCR[];  LogLine["...Volume full."];          gd.errors ¬ TRUE;  gd.nErrors ¬ gd.nErrors+1;  NoteErrors[]};        NoSource => {          LogCR[];  LogString["Can't open "];  LogLine[gd.sourceName];          gd.errors ¬ TRUE;  gd.nErrors ¬ gd.nErrors+1;  NoteErrors[]};        GlobalSwitches => {          results ¬ CommandUtil.FreePairList[results];  	  ProcessGlobalSwitches[switches];	  switches ¬ CommandUtil.FreeString[switches]};        BadSemantics => {          LogCR[];  LogLine[" -- Illegal command"L];          results ¬ CommandUtil.FreePairList[results];          gd.errors ¬ TRUE;  NoteErrors[]};	FileProblemWhileBinding => {	  gd.errors ¬ TRUE;  gd.nErrors ¬ gd.nErrors+1;  NoteErrors[]};      END;      FreeCommand[];      IF gd.errors THEN globalErrors ¬ TRUE;      IF gd.warnings THEN globalWarnings ¬ TRUE;      IF abortRequested      OR (gd.pause AND (globalErrors OR (globalWarnings AND gd.pauseOnWarnings)))        THEN EXIT;  -- stop binding      REPEAT        BadSyntax => {          LogCR[];  LogLine["-- Illegal syntax"];          gd.errors ¬ globalErrors ¬ TRUE;  NoteErrors[]};      ENDLOOP;  -- main binding loop    EXITS      NoLogFile => {        Format.CR[execProc];	Format.Line[execProc, "Problem acquiring Binder.log"L];	globalErrors ¬ TRUE;  gd.nErrors ¬ 1};    END;    StopBinder[];    RETURN[      (SELECT TRUE FROM        abortRequested => abort,         globalErrors   => error,        (globalWarnings AND globalPauseOnWarnings) => warning,        ENDCASE        => normal)]};      -- ##############  G L O B A L   I N I T I A L I Z A T I O N  #############  data: PUBLIC BcdControlDefs.BinderData ¬ @dataRecord;  dataRecord: PUBLIC BcdControlDefs.BinderDataRecord;  freeTablesAfterBind: BOOLEAN ¬ TRUE;  rootName: LONG STRING = [MFile.maxNameLength];    Init: PROC = {    net, host: [0..255];    [net, host] ¬ GetNetAndHost[];     data­ ¬ BcdControlDefs.BinderDataRecord[      exec:          NIL,      ownTable:      NIL,      zone:          NIL,      cmdLineArgList: LOOPHOLE[LONG[NIL]],      rootName:      rootName,      sourceName:    NIL,      bcdName:       NIL,      codeName:      NIL,      symbolName:    NIL,      sourceStream:  NIL,      logStream:     NIL,      errorStream:   NIL,      sourceVersion: BcdDefs.NullVersion,      binderVersion: [time: Runtime.GetBcdTime[], net: 0, host: 0],      debug:         FALSE,      copyCode:      TRUE,      copySymbols:   FALSE,      pause:         FALSE,      pauseOnWarnings: FALSE,      mergeErrlogs:  FALSE,      renamedOutput: FALSE,      errlogOpened:  FALSE,      typeExported:  FALSE,      errors:        FALSE,      warnings:      FALSE,      nErrors:       0,      nWarnings:     0,      outputFti:     BcdDefs.FTNull,      currentName:   BcdDefs.NullName,      textIndex:     BcdControlDefs.NullSourceIndex,      network:       net,      host:          host,      nModules:      0,      outModules:    0,      outConfigs:    0,      outBcdPages:   0];    Exec.AddCommand["Binder.~"L, Bind]};      GetNetAndHost: PROC RETURNS [net, host: [0..255]] = {     sum: UNSPECIFIED ¬       Inline.BITXOR[        ProcessorFace.processorID.a,        Inline.BITXOR[          ProcessorFace.processorID.b,           ProcessorFace.processorID.c]];    net ¬ LOOPHOLE[Inline.HighByte[sum]];    host ¬ LOOPHOLE[Inline.LowByte[sum]]};        Init[];    END.  
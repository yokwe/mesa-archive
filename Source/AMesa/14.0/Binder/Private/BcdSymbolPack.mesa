-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- File BcdSymbolPack.mesa--   Satterthwaite	 9-Jun-81 10:42:14--   Bruce	21-Oct-81 12:08:41--   Lewis	17-Nov-82 16:44:09--   Johnsson	13-Sep-83 17:07:44DIRECTORY  Alloc USING [AddNotify, DropNotify, Handle, Notifier],  BcdDefs USING [    fttype, FTIndex, lftype, Link, mttype, MTIndex, MTNull, NameRecord,    sgtype, SGIndex, SGNull, sstype, VersionID],  BcdControlDefs USING [BinderData, data],  BcdItemName USING [],  BcdOps USING [BcdBase, NameString],  MFile USING [CopyFileHandle, Error, Handle, maxNameLength, ReadOnly, Release],  MSegment USING [Address, Create, Delete, Error, Handle, Reset],  String USING [    AppendString, AppendSubString, EqualSubStrings, SubString,    SubStringDescriptor],  --SymbolPack,  SymbolOps,  Symbols USING [    ISEIndex, CSEIndex, CTXIndex, BitAddress, ISENull],  SymbolSegment USING [STHeader],  SymbolTable USING [Handle, Acquire, Release],  Table USING [Base];BcdSymbolPack: PROGRAM    IMPORTS       Alloc, BcdControlDefs, MFile, MSegment, String, SymbolOps, SymbolTable      --ownSymbolPack: SymbolPack    EXPORTS BcdItemName, SymbolTable = {  OPEN BcdDefs;  SymSegHandle: PUBLIC TYPE = MSegment.Handle;  gd: BcdControlDefs.BinderData ¬ NIL;  table: Alloc.Handle ¬ NIL;    InvalidSymbols: ERROR = CODE;  symbolSeg, bcdSeg: MSegment.Handle ¬ NIL;  symbolPackInitialized: BOOLEAN ¬ FALSE;  bcdSsb: BcdOps.NameString;  bcdMtb, bcdSgb: Table.Base;    mtb, lfb, sgb, ftb: Table.Base;  ssb: BcdOps.NameString;  Notifier: Alloc.Notifier = {    mtb ¬ base[mttype];  lfb ¬ base[lftype];    sgb ¬ base[sgtype];  ftb ¬ base[fttype];    ssb ¬ base[sstype]};    Print: PUBLIC PROC [      importerMti: MTIndex, importName: NameRecord, importFti: FTIndex,      linkOffset: CARDINAL, ep: CARDINAL,      userProc: PROC [String.SubString]] = {    ENABLE UNWIND => Finalize[];    IF importerMti = MTNull THEN RETURN;    Initialize[];    -- try importer's symbols first, then interface's symbols    IF GotImportersSymbols[importerMti] THEN        PrintUsingImporter[importerMti, linkOffset, userProc]    ELSE IF GotInterfacesSymbols[importName, importFti] THEN      PrintUsingInterface[ep, userProc];    Finalize[]};      Initialize: PROC = {    gd ¬ BcdControlDefs.data;    table ¬ gd.ownTable;     table.AddNotify[Notifier, NIL];    IF ~symbolPackInitialized THEN {      --START ownSymbolPack;      symbolPackInitialized ¬ TRUE}};      Finalize: PROC = {    DestroyBcd[];  ReleaseSymbolSeg[NIL --ownSymbolPack--];    table.DropNotify[Notifier, NIL];    table ¬ NIL;  gd ¬ NIL};      GotImportersSymbols: PROC [importerMti: MTIndex] RETURNS [BOOLEAN] = {     sgi: SGIndex = mtb[importerMti].sseg;    fti: FTIndex;    s: STRING ¬ [MFile.maxNameLength];    file: MFile.Handle ¬ NIL;    symbolSeg ¬ NIL;    IF sgi # SGNull THEN {       fti ¬ sgb[sgi].file;      GetBcdName[s, ftb[fti].name];      file ¬ MFile.ReadOnly[name: s, release: [] ! MFile.Error => GOTO NotFound];      symbolSeg ¬ MSegment.Create[	file: file, release: [],	fileBase: (sgb[sgi].base - 1), pages: sgb[sgi].pages	! MSegment.Error => {MFile.Release[file];  GOTO NotFound}]};    RETURN[TRUE];    EXITS       NotFound => RETURN[FALSE]};   PrintUsingImporter: PROC [      importerMti: MTIndex, linkOffset: CARDINAL,      userProc: PROC [String.SubString]] = {    symbols: SymbolTable.Handle ¬ SymbolTable.Acquire[symbolSeg];    IF symbols # NIL THEN {       OPEN Symbols;      key: Symbols.BitAddress = ComputeAddress[importerMti, linkOffset];      iCtx: CTXIndex = symbols.stHandle.importCtx;      sei: ISEIndex;      type: CSEIndex;      ss: String.SubStringDescriptor;      Imported: PROC [sei: Symbols.ISEIndex] RETURNS [BOOLEAN] = INLINE {        RETURN[symbols.seb[sei].linkSpace AND ~symbols.seb[sei].extended]};      FOR iSei: ISEIndex ¬ SymbolOps.FirstCtxSe[symbols, iCtx], SymbolOps.NextSe[symbols, iSei]      UNTIL iSei = ISENull DO        type ¬ SymbolOps.UnderType[symbols, symbols.seb[iSei].idType];        WITH symbols.seb[type] SELECT FROM          definition =>            FOR sei ¬ SymbolOps.FirstCtxSe[symbols, defCtx], SymbolOps.NextSe[symbols, sei]	    UNTIL sei = ISENull DO      	      IF Imported[sei] AND SymbolOps.ToBitAddr[symbols.seb[sei].idValue] = key THEN GO TO Found;      	      ENDLOOP;          ref =>            IF Imported[iSei] AND SymbolOps.ToBitAddr[symbols.seb[iSei].idValue] = key THEN {	      sei ¬ iSei;  GO TO Found};          ENDCASE => NULL;        REPEAT          Found => {            SymbolOps.SubStringForHash[symbols, @ss, symbols.seb[sei].hash];            userProc[@ss ! UNWIND => ReleaseSymbolSeg[symbols]]};        ENDLOOP;      ReleaseSymbolSeg[symbols]}};  ComputeAddress: PROC [        mti: MTIndex, linkOffset: CARDINAL]       RETURNS [Symbols.BitAddress] = {    linkLength: CARDINAL = lfb[mtb[mti].links].length;    RETURN[[wd: (linkLength-1)*SIZE[BcdDefs.Link] - linkOffset, bd: 0]]};      GotInterfacesSymbols: PROC [      interfaceName: NameRecord, interfaceFti: FTIndex] RETURNS [BOOLEAN] = {    ENABLE UNWIND => DestroyBcd[];    bcdName: STRING ¬ [MFile.maxNameLength];    bcdFile: MFile.Handle ¬ NIL;    bcdPages: CARDINAL;    bcd: BcdOps.BcdBase ¬ NIL;    tb: Table.Base;    symbolSeg ¬ bcdSeg ¬ NIL;     GetBcdName[bcdName, interfaceName];    bcdFile ¬ MFile.ReadOnly[name: bcdName, release: []      ! MFile.Error => GOTO NoFile];    bcdSeg ¬ MSegment.Create[      file: bcdFile, release: [], fileBase: 0, pages: 10      ! MSegment.Error => {MFile.Release[bcdFile]; GOTO NoFile}];    bcd ¬ MSegment.Address[bcdSeg];    IF bcd.versionIdent # VersionID THEN GOTO NoFile;    IF (bcdPages ¬ bcd.nPages) > 10 THEN {      MSegment.Reset[segment: bcdSeg, pages: bcdPages         ! MSegment.Error => GOTO NoFile];      bcd ¬ MSegment.Address[bcdSeg]};    tb ¬ LOOPHOLE[bcd];    bcdSsb ¬ LOOPHOLE[bcd + bcd.ssOffset];    bcdMtb ¬ tb + bcd.mtOffset;    bcdSgb ¬ tb + bcd.sgOffset;      BEGIN      internalName: NameRecord = bcdMtb[FIRST[MTIndex]].name;      symSgi: SGIndex = bcdMtb[FIRST[MTIndex]].sseg;      moduleName: STRING ¬ [MFile.maxNameLength];      AppendNameFromBcd[moduleName, internalName];      IF bcd.definitions         AND bcd.nModules = 1         AND EqualNames[bcdName, moduleName]         AND ftb[interfaceFti].version = bcd.version         AND bcdSgb[symSgi].pages # 0        AND bcdSgb[symSgi].extraPages = 0 THEN {	  copy: MFile.Handle = MFile.CopyFileHandle[	    file: bcdFile, release: [], access: readOnly 	    ! MFile.Error => GOTO NoFile];          symbolSeg ¬ MSegment.Create[            file: copy, release: [],	    fileBase: (bcdSgb[symSgi].base - 1), pages: bcdSgb[symSgi].pages             ! MSegment.Error => {MFile.Release[copy]; GOTO NoFile}]};      END;    DestroyBcd[]; RETURN[TRUE];    EXITS NoFile => {DestroyBcd[]; RETURN[FALSE]}};      DestroyBcd: PROC = {    IF bcdSeg # NIL THEN {MSegment.Delete[bcdSeg]; bcdSeg ¬ NIL}};      GetBcdName: PROC [s: STRING, n: NameRecord] = {    ssd: String.SubStringDescriptor ¬      [base: @ssb.string,       offset: n, length: MIN[ssb.size[n], MFile.maxNameLength]];    s.length ¬ 0;    String.AppendSubString[s, @ssd];    FOR i: CARDINAL IN [0..s.length) DO IF s[i] = '. THEN RETURN ENDLOOP;    String.AppendString[s, ".bcd"L]};      AppendNameFromBcd: PROC [s: STRING, n: NameRecord] = {    ssd: String.SubStringDescriptor ¬      [base: @bcdSsb.string,       offset: n, length: MIN[bcdSsb.size[n], MFile.maxNameLength]];    String.AppendSubString[s, @ssd]};      EqualNames: PROC [bcdFileName, moduleName: STRING] RETURNS [reply: BOOLEAN] = {    bcdSsd, moduleSsd: String.SubStringDescriptor;    end: CARDINAL;    FOR i: CARDINAL IN [0..bcdFileName.length) DO       IF bcdFileName[i] = '. THEN {end ¬ i;  EXIT};      REPEAT FINISHED => end ¬ bcdFileName.length;       ENDLOOP;    bcdSsd ¬ [base: bcdFileName, offset: 0, length: end];     FOR i: CARDINAL IN [0..moduleName.length) DO       IF moduleName[i] = '. THEN {end ¬ i;  EXIT};      REPEAT FINISHED => end ¬ moduleName.length;       ENDLOOP;    moduleSsd ¬ [base: moduleName, offset: 0, length: end];    RETURN[String.EqualSubStrings[@bcdSsd, @moduleSsd]]};  PrintUsingInterface: PROC [      ep: CARDINAL,      userProc: PROC [String.SubString]] = {     symbols: SymbolTable.Handle ¬ SymbolTable.Acquire[symbolSeg];    IF symbols # NIL THEN {       OPEN Symbols;      outerCtx: CTXIndex = symbols.stHandle.outerCtx;      ss: String.SubStringDescriptor;      FOR sei: ISEIndex ¬ SymbolOps.FirstCtxSe[symbols, outerCtx], SymbolOps.NextSe[symbols, sei]       UNTIL sei = ISENull DO	SELECT SymbolOps.LinkMode[symbols, sei] FROM	  val, ref => 	    IF SymbolOps.ToCard[symbols.seb[sei].idValue] = ep THEN {	      SymbolOps.SubStringForHash[symbols, @ss, symbols.seb[sei].hash];              userProc[@ss ! UNWIND => ReleaseSymbolSeg[symbols]]};	  ENDCASE;        ENDLOOP;      ReleaseSymbolSeg[symbols]}};  ReleaseSymbolSeg: PROC [base: SymbolTable.Handle] = {    IF base # NIL THEN SymbolTable.Release[base];    IF symbolSeg # NIL THEN {MSegment.Delete[symbolSeg]; symbolSeg ¬ NIL}};    }.
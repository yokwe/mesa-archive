-- File: ListUnbound.mesa - last edit:-- JBD                  4-Mar-87 14:00:46--  RES  	 7-Dec-83  9:25:37--  RXJ     	12-Jun-83 12:40:18--  BTL  	 2-Dec-81 16:42:07--  RXR   	 5-Oct-81 20:44:03--  LXR    	24-Aug-81 15:15:45--  BXM  	13-Jan-81 11:06:19-- Copyright (C) 1981, 1983, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  BcdDefs USING [    Base, BCD, EXPIndex, EXPRecord, FTIndex, FTNull, FTSelf, Link, NameRecord,    nullLink],  BcdOps USING [BcdBase, NameString],  CommandUtil USING [GetNth],  ListerDefs USING [    AddCommand, HelpProc, ListerProc, Load, NoFGT, OpenOutput,     PutSei, Put, PutBcdID, PutCR, PutIndent,     PutSubString, symbolsOnly, ReleaseSymbols, write],  String USING [AppendString, AppendSubString, SubStringDescriptor],  SymbolOps USING [FirstCtxSe, LinkMode, NextSe, ToCard],  Symbols USING [ISEIndex, ISENull],  SymbolTable USING [Handle];ListUnbound: PROGRAM    IMPORTS CommandUtil, ListerDefs, String, SymbolOps =  BEGIN OPEN ListerDefs;    bcd: BcdOps.BcdBase;    tb: BcdDefs.Base;  ssb: BcdOps.NameString;  spb: BcdDefs.Base;  ctb: BcdDefs.Base;  mtb: BcdDefs.Base;  itb: BcdDefs.Base;  etb: BcdDefs.Base;  sgb: BcdDefs.Base;  ftb: BcdDefs.Base;  ntb: BcdDefs.Base;    InstallBcd: PROC [] = {    tb ¬ LOOPHOLE[bcd];    ssb ¬ tb + bcd.ssOffset;    ctb ¬ tb + bcd.ctOffset;    mtb ¬ tb + bcd.mtOffset;    itb ¬ tb + bcd.impOffset;    etb ¬ tb + bcd.expOffset;    sgb ¬ tb + bcd.sgOffset;    ftb ¬ tb + bcd.ftOffset;    ntb ¬ tb + bcd.ntOffset;    spb ¬ tb + bcd.spOffset};      PrintUnbound: PROC = {    eti: BcdDefs.EXPIndex ¬ FIRST[BcdDefs.EXPIndex];    UNTIL eti = bcd.expLimit DO      CheckExport[eti];      UnloadSymbols[];      eti ¬ eti + etb[eti].size * SIZE[BcdDefs.Link] + SIZE[BcdDefs.EXPRecord];      IF LOOPHOLE[eti, CARDINAL] > LOOPHOLE[bcd.expLimit, CARDINAL] THEN	GO TO Bogus;      REPEAT Bogus => PrintGarbage[];      ENDLOOP};      CheckExport: PUBLIC PROC [eti: BcdDefs.EXPIndex] = {    OPEN etb[eti];    n: CARDINAL ¬ 0;    sei: Symbols.ISEIndex;    FOR i: CARDINAL IN [0..etb[eti].size) DO      IF etb[eti].links[i] = BcdDefs.nullLink THEN {	IF ~loaded THEN LoadSymbols[etb[eti].file];	sei ¬ SeiForItem[i];	IF sei = Symbols.ISENull THEN LOOP;	IF n = 0 THEN {Put["Unbound exports to "L];  PutName[name];  Put[": "L]};	IF n MOD 3 = 0 THEN PutIndent[2] ELSE Put[", "L];	n ¬ n + 1;	ListerDefs.PutSei[sH, sei]};      ENDLOOP;    IF n # 0 THEN {PutCR[]; PutCR[]}};      SeiForItem: PROC [item: CARDINAL] RETURNS [sei: Symbols.ISEIndex] = {    OPEN sH;    FOR sei ¬ SymbolOps.FirstCtxSe[sH, stHandle.outerCtx], SymbolOps.NextSe[sH, sei]    UNTIL sei = Symbols.ISENull DO      IF SymbolOps.ToCard[seb[sei].idValue] = item THEN	SELECT SymbolOps.LinkMode[sH, sei] FROM	  val => IF seb[sei].extended THEN RETURN[Symbols.ISENull] ELSE RETURN;	  ref => RETURN[sei];	  manifest => LOOP; -- constant	  ENDCASE => RETURN[Symbols.ISENull];      ENDLOOP;    ERROR};      sH: SymbolTable.Handle ¬ NIL;    loaded: BOOLEAN ¬ FALSE;    LoadSymbols: PROC [file: BcdDefs.FTIndex] = {    s: STRING ¬ [100];    IF file = BcdDefs.FTNull OR file = BcdDefs.FTSelf OR sH # NIL THEN ERROR;    GetBcdName[s, ftb[file].name];    [sH: sH] ¬ ListerDefs.Load[root: s, flags: ListerDefs.symbolsOnly !      ListerDefs.NoFGT => RESUME];    loaded ¬ TRUE};      UnloadSymbols: PROC = {    IF sH # NIL THEN ListerDefs.ReleaseSymbols[sH];    sH ¬ NIL;    loaded ¬ FALSE};          -- Utility Prints    PrintGarbage: PROC =    BEGIN    PutIndent[2];    Put["? looks like garbage to me ..."L];    PutCR[];    END;      GetBcdName: PUBLIC PROC [s: STRING, n: BcdDefs.NameRecord] =    BEGIN    ssd: String.SubStringDescriptor ¬      [base: @ssb.string, offset: n, length: MIN[ssb.size[n], 100]];    s.length ¬ 0;    String.AppendSubString[s, @ssd];    FOR i: CARDINAL IN [0..s.length) DO IF s[i] = '. THEN RETURN ENDLOOP;    String.AppendString[s, ".bcd"L];    END;  PutName: PUBLIC PROCEDURE [n: BcdDefs.NameRecord] =    BEGIN    ssd: String.SubStringDescriptor ¬      [base: @ssb.string, offset: n, length: MIN[ssb.size[n], 100]];    PutSubString[@ssd];    END;          UnboundExports: PROC [root: LONG STRING] = {    bcd ¬ ListerDefs.Load[root: root].bcd;    InstallBcd[];    ListerDefs.OpenOutput[root, "xl"L];    ListerDefs.PutBcdID[bcd];    PrintUnbound[];    };      CallUnboundExports: ListerDefs.ListerProc =     BEGIN    UnboundExports[CommandUtil.GetNth[argList, 0]];    END;      HelpUnboundExports: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["UnboundExports[""Filename""] "L];    END;      Init: PROCEDURE =    BEGIN    ListerDefs.AddCommand[      "UnboundExports"L, CallUnboundExports, HelpUnboundExports];    END;      Init[];    END.
-- File: ListSymbols.mesa - last edit:-- JBD                  2-Mar-87 12:11:34-- MEW                 23-Jan-86  8:29:43-- Sweet               24-May-83 10:40:50-- Loretta             17-Nov-82 12:00:16-- Lewis                2-Dec-81 16:32:51-- Rhonda               5-Oct-81 20:40:27-- Bruce               13-Jan-81 11:02:17-- Sandman             July 8, 1980  9:29 AM-- Copyright (C) 1981, 1982, 1983, 1986, 1987  by Xerox Corporation. All rights reserved. DIRECTORY  Alloc USING [AddNotify, Create, Destroy, DropNotify, Notifier, TableInfo],  AllocOps USING [Handle],  BcdOps USING [BcdBase],  CommandUtil USING [    CopyString, FreeString, GetNth, GetNthPair, ListLength, PairList],  ComData USING [interface, ownSymbols],  CompilerUtil USING [PrintSymbols, PrintBodies],  Environment USING [PageNumber, PageCount],  Exec USING [Outcome],  ListerDefs USING [    AddCommand, HelpProc, Load, ListerProc,     LoadSymSegment, NoCode, noCode, NoFGT,     OpenOutput, Put, PutBcdID, PutCR, PutDecimal, PutVersions,     ReleaseSymbols, write],  LiteralOps USING [LitInitialize],  Space USING [Error],  String USING [EquivalentString, StringToNumber],  SymbolSegment,  SymbolTable USING [Handle],  Table USING [Base, Selector],  TreeOps USING [TreeInitialize];ListSymbols: PROGRAM    IMPORTS      Alloc, CommandUtil, CompilerUtil, ListerDefs, LiteralOps,      Space, String, TreeOps,      data: ComData =  BEGIN OPEN ListerDefs;    sH: SymbolTable.Handle ¬ NIL;  commandType: {bodies, symbols};    <<Special temporary debugs JBD>>  doTrees: BOOLEAN ¬ FALSE;  doLiterals: BOOLEAN ¬ FALSE;    PrintSyms: PROC = {    data.interface ¬ sH.stHandle.definitionsFile;    SELECT commandType FROM      symbols => CompilerUtil.PrintSymbols[sH.table, sH.stHandle.definitionsFile];      bodies  => CompilerUtil.PrintBodies[sH.table];      ENDCASE};      GetSymbolTable: PROC = {    tableInfo: ARRAY SymbolSegment.Tables OF Alloc.TableInfo ¬      ALL[[initialPages: 0, initialVMemPages: 0]]; -- allocate tables, not memory    data.ownSymbols ¬ sH;    sH.table ¬ Alloc.Create[weights: DESCRIPTOR[tableInfo]];    <<suspend initialization stuff to see what happens in CompilerUtil>>    UpdateBases[DESCRIPTOR[NIL,0], sH];    Alloc.AddNotify[sH.table, CatchMakeNode, sH];    IF doTrees THEN TreeOps.TreeInitialize[sH];    IF doLiterals THEN LiteralOps.LitInitialize[sH];    };  AllocOnReadOnlySegment: SIGNAL = CODE;  numberOfAllocs: CARDINAL ¬ 0;  CatchMakeNode: Alloc.Notifier = { -- No one should call Alloc.MakeNode    -- but allow one for the original Alloc.AddNotify    IF numberOfAllocs > 0 THEN SIGNAL AllocOnReadOnlySegment;    numberOfAllocs ¬ numberOfAllocs+1};  UpdateBases: Alloc.Notifier = {    s: SymbolTable.Handle ¬ clientData;    h: AllocOps.Handle = LOOPHOLE[s.table];    stH: LONG POINTER TO SymbolSegment.STHeader = s.stHandle;    symbase: Table.Base ¬ LOOPHOLE[stH];    -- This hack updates the bases inside the (opaque) Alloc.Handle    Set: PROC [selector: Table.Selector, desc: SymbolSegment.BlockDescriptor] = {      h.base[selector] ¬ symbase + desc.offset;      h.top[selector] ¬ desc.size;      };    Set[SymbolSegment.treeType, stH.treeBlock];    Set[SymbolSegment.seType, stH.seBlock];    Set[SymbolSegment.treeType, stH.treeBlock];    Set[SymbolSegment.seType, stH.seBlock];    Set[SymbolSegment.htType, stH.htBlock];    Set[SymbolSegment.ssType, stH.ssBlock];    Set[SymbolSegment.ctxType, stH.ctxBlock];    Set[SymbolSegment.mdType, stH.mdBlock];    Set[SymbolSegment.bodyType, stH.bodyBlock];    Set[SymbolSegment.ltType, stH.litBlock];    Set[SymbolSegment.extType, stH.extBlock];    Set[SymbolSegment.atType, [0, 0]];    Set[SymbolSegment.constType, [0, 0]];    Set[SymbolSegment.codeType, [0, 0]];    };  ReleaseSymbolTable: PROC [] = {    Alloc.DropNotify[sH.table, CatchMakeNode, sH];    Alloc.Destroy[sH.table! Space.Error => {      IF type = notMapped THEN CONTINUE ELSE REJECT}];    ListerDefs.ReleaseSymbols[sH];    sH ¬ data.ownSymbols ¬ NIL};      DoSymbols: PROC [root: LONG STRING] = {    bcd: BcdOps.BcdBase;    [bcd: bcd, sH: sH] ¬ ListerDefs.Load[root: root, flags: ListerDefs.noCode       ! NoCode, NoFGT => RESUME];    GetSymbolTable[];    ListerDefs.OpenOutput[root, "sl"L];    ListerDefs.PutBcdID[bcd];    PrintSyms[];    ReleaseSymbolTable[];    };      DoSymbolSegment: PROC [      root: LONG STRING,      base: Environment.PageNumber, pages: Environment.PageCount] = {    sH ¬ ListerDefs.LoadSymSegment[root, base, pages];    GetSymbolTable[];    ListerDefs.OpenOutput[root, "sl"L];    Put["Symbol Table in file: "L];  Put[root];    Put[", base: "L];  PutDecimal[CARDINAL[base]];    Put[", pages: "L];  PutDecimal[CARDINAL[pages]];    PutCR[];    ListerDefs.PutVersions[@sH.stHandle.version, @sH.stHandle.creator];    PrintSyms[];    ReleaseSymbolTable[];    };      Call3: PROC [        proc: PROC [          root: LONG STRING,	  base: Environment.PageNumber, pages: Environment.PageCount],         argList: CommandUtil.PairList]       RETURNS [outcome: Exec.Outcome ¬ normal] = {     OPEN CommandUtil;     filename, key, value: LONG STRING ¬ NIL;    base, pages: INTEGER ¬ -1;    FOR i: CARDINAL IN [0..ListLength[argList]) DO      ENABLE UNWIND => filename ¬ FreeString[filename];       [key, value] ¬ GetNthPair[argList, i];      SELECT TRUE FROM	String.EquivalentString[key, "Filename"L] => 	  filename ¬ CopyString[value];	String.EquivalentString[key, "Base"L] => 	  base ¬ String.StringToNumber[value];	String.EquivalentString[key, "Pages"L] => 	  pages ¬ String.StringToNumber[value];	ENDCASE =>	  SELECT i FROM	    0 --FileName-- => filename ¬ CopyString[value];	    1 --Bases-- =>    base ¬ String.StringToNumber[value];	    2 --Pages-- =>    pages ¬ String.StringToNumber[value];	    ENDCASE;       ENDLOOP;    SELECT TRUE FROM       (filename = NIL) => {         ListerDefs.write["No Filename parameter."L]; outcome ¬ error};       base = -1 => {ListerDefs.write["No Base parameter."L]; outcome ¬ error};       pages = -1 => {ListerDefs.write["No Pages parameter."L]; outcome ¬ error};       ENDCASE =>         proc[filename, base, pages ! UNWIND => filename ¬ FreeString[filename]];    filename ¬ FreeString[filename]};  CallSymbols: ListerDefs.ListerProc =     BEGIN     commandType ¬ symbols;     DoSymbols[CommandUtil.GetNth[argList, 0]];    END;      HelpSymbols: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["Symbols[""Filename""] "L];    END;  CallBodies: ListerDefs.ListerProc =     BEGIN     commandType ¬ bodies;     DoSymbols[CommandUtil.GetNth[argList, 0]];    END;      HelpBodies: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["Bodies[""Filename""] "L];    END;  CallSymbolSegment: ListerDefs.ListerProc =     BEGIN     commandType ¬ symbols;     RETURN[Call3[DoSymbolSegment, argList]];    END;      HelpSymbolSegment: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["SymbolSegment[""Filename"", Base, Pages] "L];    END;  CallBodySegment: ListerDefs.ListerProc =     BEGIN     commandType ¬ bodies;     RETURN[Call3[DoSymbolSegment, argList]];    END;      HelpBodySegment: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["BodySegment[""Filename"", Base, Pages] "L];    END;  Init: PROC =    BEGIN    ListerDefs.AddCommand["Symbols"L, CallSymbols, HelpSymbols];    ListerDefs.AddCommand["Bodies"L, CallBodies, HelpBodies];    ListerDefs.AddCommand["SymbolSegment"L, CallSymbolSegment, HelpSymbolSegment];    ListerDefs.AddCommand["BodySegment"L, CallBodySegment, HelpBodySegment];    END;      Init[];    END.
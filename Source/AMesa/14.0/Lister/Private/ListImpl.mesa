-- File: ListImpl.mesa - last edit:-- JBD                  3-Mar-87 18:37:01-- LXR                 24-Aug-81 15:11:26-- BXM                 13-Jan-81 11:01:26-- RES                 12-Dec-83 16:22:24-- RXR                  5-Oct-81 20:19:58-- BTL                  2-Dec-81 16:31:02-- RXJ                 11-Jun-83 21:56:41-- Copyright (C) 1981, 1983, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  BcdDefs USING [    Base, EXPIndex, EXPRecord, FTIndex, FTNull, FTSelf, Link, MTIndex, NameRecord,    NullLink],  BcdOps USING [BcdBase, NameString],  CommandUtil USING [GetNth],  Format USING [CR],  GSort USING [    CompareProcType, Port, PutProcType, Sort, SortItemPort, SortStarter,    SortStopper],  ListerDefs USING [    AddCommand, HelpProc, IncorrectVersion, ListerProc, Load,    NextNameInList, NoFGT, OpenFileList, OpenOutput, Put, PutChar, PutCR,    PutSubString, ReleaseBcd, ReleaseSymbols, symbolsOnly, write],  String USING [    AppendString, AppendSubString, Compare, CompareStrings,    EqualString, SubStringDescriptor, WordsForString],  SymbolOps USING [    FirstCtxSe, FromCard, Handle, HashForSe, LinkMode, NextSe, SubStringForHash],  Symbols USING [Base, ISEIndex, ISENull, Unspec];ListImpl: PROGRAM  IMPORTS    CommandUtil, Format, GSort, ListerDefs,     String, SymbolOps =  BEGIN OPEN ListerDefs;  bcd: BcdOps.BcdBase;  tb: BcdDefs.Base;  ssb: BcdOps.NameString;  spb: BcdDefs.Base;  ctb: BcdDefs.Base;  mtb: BcdDefs.Base;  itb: BcdDefs.Base;  etb: BcdDefs.Base;  sgb: BcdDefs.Base;  ftb: BcdDefs.Base;  ntb: BcdDefs.Base;  typb: BcdDefs.Base;  InstallBcd: PROC = {    tb ¬ LOOPHOLE[bcd];    ssb ¬ tb + bcd.ssOffset;    ctb ¬ tb + bcd.ctOffset;    mtb ¬ tb + bcd.mtOffset;    itb ¬ tb + bcd.impOffset;    etb ¬ tb + bcd.expOffset;    sgb ¬ tb + bcd.sgOffset;    ftb ¬ tb + bcd.ftOffset;    ntb ¬ tb + bcd.ntOffset;    spb ¬ tb + bcd.spOffset;    typb ¬ tb + bcd.typOffset};  ScanExports: PROC = {    eti: BcdDefs.EXPIndex ¬ FIRST[BcdDefs.EXPIndex];    UNTIL eti = bcd.expLimit DO      ExportsToSort[eti];      UnloadSymbols[];      eti ¬ eti + etb[eti].size * SIZE[BcdDefs.Link] + SIZE[BcdDefs.EXPRecord];      IF LOOPHOLE[eti, CARDINAL] > LOOPHOLE[bcd.expLimit, CARDINAL] THEN        GO TO Bogus;      REPEAT Bogus => PrintGarbage[];      ENDLOOP};  ExportsToSort: PROC [eti: BcdDefs.EXPIndex] = {    n: CARDINAL ¬ 0;    link: BcdDefs.Link;    sei: Symbols.ISEIndex;    interfaceName.length ¬ 0;    AppendName[interfaceName, etb[eti].name];    FOR i: CARDINAL IN [0..etb[eti].size) DO      link ¬ etb[eti].links[i];      IF link # BcdDefs.NullLink THEN {        IF ~loaded THEN LoadSymbols[etb[eti].file];        sei ¬ SeiForItem[SymbolOps.FromCard[i]];        IF sei = Symbols.ISENull THEN LOOP;        RecordExport[sei, TRUE]};      ENDLOOP};  sH: SymbolOps.Handle ¬ NIL;  SeiForItem: PROC [item: Symbols.Unspec] RETURNS [sei: Symbols.ISEIndex] = {    FOR sei ¬ SymbolOps.FirstCtxSe[sH, sH.stHandle.outerCtx], SymbolOps.NextSe[      sH, sei] UNTIL sei = Symbols.ISENull DO      IF sH.seb[sei].idValue = item THEN        SELECT SymbolOps.LinkMode[sH, sei] FROM          val => IF sH.seb[sei].extended THEN RETURN[Symbols.ISENull] ELSE RETURN;          ref => RETURN[sei];          manifest => LOOP;  -- constant          ENDCASE => RETURN[Symbols.ISENull];      ENDLOOP;    ERROR};  AddInterface: PROC = {    interfaceName.length ¬ 0;    String.AppendString[interfaceName, moduleName];    LoadSymbolsName[moduleName];    FOR sei: Symbols.ISEIndex ¬ SymbolOps.FirstCtxSe[sH, sH.stHandle.outerCtx],      SymbolOps.NextSe[sH, sei] UNTIL sei = Symbols.ISENull DO      SELECT SymbolOps.LinkMode[sH, sei] FROM        val, ref => RecordExport[sei, FALSE];        ENDCASE;      ENDLOOP;    UnloadSymbols[]};  loaded: BOOLEAN ¬ FALSE;  LoadSymbols: PROC [file: BcdDefs.FTIndex] = {    s: STRING ¬ [60];    IF file = BcdDefs.FTNull OR file = BcdDefs.FTSelf OR sH # NIL THEN ERROR;    GetBcdName[s, ftb[file].name];    LoadSymbolsName[s];    IF ftb[file].version # sH.stHandle.version THEN      SIGNAL ListerDefs.IncorrectVersion[name: s, expected: ftb[file].version,        found: sH.stHandle.version]};  LoadSymbolsName: PROC [s: LONG STRING] = {    ListerDefs.write["    "L]; -- indent    [sH: sH] ¬ ListerDefs.Load[root: s, flags: ListerDefs.symbolsOnly !      ListerDefs.NoFGT => RESUME];    loaded ¬ TRUE;    };  UnloadSymbols: PROC = {    IF sH # NIL THEN ListerDefs.ReleaseSymbols[sH];    sH ¬ NIL;    loaded ¬ FALSE};  -- Utility Prints  PrintGarbage: PROC = BEGIN Put["? looks like garbage to me ..."L]; PutCR[]; END;  GetBcdName: PUBLIC PROC [s: STRING, n: BcdDefs.NameRecord] =    BEGIN    ssd: String.SubStringDescriptor ¬ [      base: @ssb.string, offset: n, length: MIN[ssb.size[n], 100]];    s.length ¬ 0;    String.AppendSubString[s, @ssd];    END;  PutName: PUBLIC PROC [n: BcdDefs.NameRecord] =    BEGIN    ssd: String.SubStringDescriptor ¬ [      base: @ssb.string, offset: n, length: MIN[ssb.size[n], 100]];    PutSubString[@ssd];    END;  AppendName: PUBLIC PROC [s: LONG STRING, n: BcdDefs.NameRecord] =    BEGIN    ssd: String.SubStringDescriptor ¬ [      base: @ssb.string, offset: n, length: MIN[ssb.size[n], 100]];    String.AppendSubString[s, @ssd];    END;  RecordExport: PROC [item: Symbols.ISEIndex, present: BOOLEAN] =    BEGIN    desc: String.SubStringDescriptor;    sortLength: KeyPtr <<actually a CARDINAL>>;      FixUpBuffer: PROC [buffer: KeyBase, s: KeyPtr] RETURNS [next: KeyPtr] =      BEGIN      length: CARDINAL ¬ String.WordsForString[buffer[s].length];      next ¬ s+length;      -- set the next stringbody, even if not needed.      buffer[next] ¬ [length: 0, maxlength: buffer[s].maxlength-2*length, text:];      buffer[s] ¬ [length: buffer[s].length, maxlength: buffer[s].length, text:];      END;    buffer.item ¬ [length:0, maxlength: maxItemChars, text:];    SymbolOps.SubStringForHash[sH, @desc, SymbolOps.HashForSe[sH, item]];    String.AppendSubString[@buffer.item, @desc];    buffer.interface ¬ FixUpBuffer[buffer,       LOOPHOLE[2*SIZE[KeyPtr],KeyPtr] <<points at buffer.item>>];    String.AppendString[@buffer[buffer.interface], interfaceName];    buffer.module ¬ sortLength ¬ FixUpBuffer[buffer, buffer.interface];    IF ~present THEN buffer.module ¬ NullString    ELSE      BEGIN      String.AppendString[@buffer[buffer.module ¬ sortLength], moduleName];      sortLength ¬ FixUpBuffer[buffer, buffer.module];      END;    buffer ¬ OutToSortH­[LOOPHOLE[sortLength, CARDINAL]];    END;  Compare: PROC [p1, p2: LONG POINTER] RETURNS [i: INTEGER] =    BEGIN    k1: KeyBase = p1;    k2: KeyBase = p2;    i ¬ String.CompareStrings[@k1[k1.interface], @k2[k2.interface]];    IF i = 0 THEN i ¬ String.CompareStrings[@k1.item, @k2.item];    IF i = 0 THEN i ¬ String.CompareStrings[@k1[k1.module], @k2[k2.module]];    END;  lastInterface: LONG STRING ¬ [60];  lastItem: LONG STRING ¬ [60];  first: BOOLEAN ¬ TRUE;  Print: PROC [p: LONG POINTER, len: CARDINAL] =    BEGIN    key: KeyBase = p;    NextItem[      interface: @key[key.interface], item: @key.item,      module: IF key.module = NullString THEN NIL ELSE @key[key.module]];    END;  NextItem: PROC [interface, item, module: LONG STRING] =    BEGIN    IF ~String.EqualString[interface, lastInterface] THEN      BEGIN      IF ~first THEN PutChar[')];      first ¬ TRUE;      PutCR[];      PutCR[];      Put[interface];      lastInterface.length ¬ 0;      String.AppendString[lastInterface, interface];      lastItem.length ¬ 0;      END;    IF ~String.EqualString[item, lastItem] THEN {      IF ~first THEN PutChar[')];      PutCR[];      Put["    "L];      Put[item];      lastItem.length ¬ 0;      String.AppendString[lastItem, item];      first ¬ TRUE};    IF module # NIL THEN      BEGIN      IF first THEN {Put["  ("L]; first ¬ FALSE} ELSE Put[", "L];      Put[module];      END;    END;  KeyBase: TYPE = LONG BASE POINTER TO SortKey;  KeyPtr: TYPE = KeyBase RELATIVE POINTER TO StringBody;  SortKey: TYPE = RECORD [interface, module: KeyPtr, item: StringBody];  NullString: KeyPtr = LOOPHOLE[0];  buffer: KeyBase;  maxItemChars: CARDINAL = 140;  -- Add size of StringBody to allow FixUpBuffer to initialize next StringBody  maxItemSize: CARDINAL = String.WordsForString[maxItemChars]+SIZE[StringBody];  interfaceName: LONG STRING ¬ [60];  moduleName: LONG STRING ¬ [100];  OutToSortH: POINTER TO GSort.SortItemPort ¬ NIL;  onLine: CARDINAL;  firstFile: BOOLEAN ¬ TRUE;  Implementors: PROC [fileList: LONG STRING] = {    s: LONG STRING;    -- allocate the port in MDS    -- In this PROC we can use OutToSort instead of OutToSortH­    OutToSort: GSort.SortItemPort;    -- open list of names    ListerDefs.OpenFileList[fileList];    -- crank up the sort package    OutToSortH ¬ @OutToSort;    LOOPHOLE[OutToSort, GSort.Port].out ¬ GSort.Sort;    buffer ¬ LOOPHOLE[OutToSort, GSort.SortStarter][      nextItem: OutToSortH, put: Print, compare: Compare, expectedItemSize: 40,      maxItemSize: maxItemSize];    ListerDefs.OpenOutput[fileList, "iml"L];    Put["Interface items implemented by:"L];    PutCR[];    onLine ¬ 0;    -- go through list of names, calling OutToSortH    UNTIL (s ¬ ListerDefs.NextNameInList[]) = NIL DO      ProcessFile[s];      ENDLOOP;    Format.CR[ListerDefs.write];    PutCR[];    -- get ready to write output    lastInterface.length ¬ 0;    lastItem.length ¬ 0;    -- shut down the sort package (and call Print many times)    LOOPHOLE[OutToSort, GSort.SortStopper][];    IF ~first THEN PutChar[')];    PutCR[]};  ProcessFile: PROC [root: LONG STRING] = {    ListerDefs.write["    "L]; -- indent    bcd ¬ ListerDefs.Load[root].bcd;    InstallBcd[];    IF bcd.nConfigs # 0 OR bcd.tableCompiled THEN ListerDefs.write[" -- ignored"L]    ELSE      BEGIN      name: BcdDefs.NameRecord = mtb[FIRST[BcdDefs.MTIndex]].name;      moduleName.length ¬ 0;      AppendName[moduleName, name];      IF firstFile THEN firstFile ¬ FALSE ELSE PutChar[',];      IF (onLine + moduleName.length) > 70 THEN {PutCR[]; onLine ¬ 0}      ELSE {PutChar[' ]; onLine ¬ onLine + 2};  -- 1 for the comma      Put[moduleName];      onLine ¬ (onLine + moduleName.length);      IF bcd.definitions THEN AddInterface[] ELSE ScanExports[];      ListerDefs.ReleaseBcd[bcd];      END;    };  CallImplementors: ListerDefs.ListerProc =    BEGIN    Implementors[CommandUtil.GetNth[argList, 0]];    END;  HelpImplementors: ListerDefs.HelpProc =    BEGIN ListerDefs.write["Implementors[""Filelist""] "L]; END;  Init: PROC =    BEGIN    ListerDefs.AddCommand["Implementors"L, CallImplementors, HelpImplementors];    END;  Init[];  END.
-- File: ListXref.mesa - last edit:-- JBD                  4-Mar-87 12:59:59-- MEW                 23-Jan-86  8:32:42-- Sweet               25-Jan-84 11:37:26-- Johnsson            12-Jun-83 12:40:42-- Rhonda              28-Sep-82 13:40:49-- Lewis                2-Dec-81 17:08:23-- Loretta             24-Aug-81 15:17:08  -- Copyright (C) 1981, 1982, 1983, 1984, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  BcdDefs USING [Base, ENNull, MTIndex],  BcdOps USING [BcdBase, ENHandle, MTHandle],  CommandUtil USING [GetNth],  Format USING [Line, NumberFormat],  GSort USING [    CompareProcType, GetProcType, PutProcType, Port,    Sort, SortItemPort, SortStarter, SortStopper],  Heap USING [systemZone],  ListerDefs USING [    AddCommand, all, HelpProc, ListerProc, Load, NextNameInList,     NoCode, NoFGT, OpenFileList, OpenOutput, Put, PutCR,    ReleaseSymbols, write],  Mopcodes USING [    zAL0IB, zEFC0, zEFC12, zEFCB, zJ2, zJIW, zLA0, zLAW, zLFC, zNOOP, zSFC],  OpTableDefs USING [InstLength],  String USING [    AppendChar, AppendString, AppendSubString, CompareStrings, EquivalentString,    SubString, SubStringDescriptor, WordsForString],  SymbolOps USING [EnumerateBodies, FirstCtxSe, Handle, HashForSe, NextSe,     SubStringForHash, ToBitAddr, UnderType],  Symbols USING [    BitAddress, BTIndex, BTNull, CTXIndex, HTIndex, ISEIndex, ISENull, SENull];ListXref: PROGRAM    IMPORTS      CommandUtil, Format, GSort, Heap, ListerDefs,      OpTableDefs, String, SymbolOps =  BEGIN OPEN ListerDefs;    NumberFormat: TYPE = Format.NumberFormat;  BYTE: TYPE = [0..256);  opcode: TYPE = BYTE;    z: UNCOUNTED ZONE = Heap.systemZone;    JumpOp: TYPE = [Mopcodes.zJ2..Mopcodes.zJIW];  InstWord: TYPE = MACHINE DEPENDENT RECORD [evenbyte, oddbyte: BYTE];    codebase: LONG POINTER ¬ NIL;  ev: BcdOps.ENHandle ¬ NIL;  offset: CARDINAL;  sH: SymbolOps.Handle;  Tinst, Tbytes, Pinst, Pbytes: CARDINAL ¬ 0;    KeyBase: TYPE = LONG BASE POINTER TO SortKey;  SortKey: TYPE = RECORD [    callee: KeyBase RELATIVE POINTER TO StringBody, caller: StringBody];  buffer: KeyBase;  callerName: LONG STRING ¬ [80];  moduleName: LONG STRING ¬ [40];    RecordLocal: PROC [pc: CARDINAL] =    BEGIN    desc: String.SubStringDescriptor;    buffer­ ¬ [callee: NULL, caller: [length: 0, maxlength: 100, text:]];    String.AppendString[@buffer.caller, callerName];    buffer.callee ¬ LOOPHOLE[String.WordsForString[buffer.caller.length] + 1];    buffer[buffer.callee] ¬ [length: 0, maxlength: 100, text:];    IF epMap = NIL THEN ERROR;    FOR ep: CARDINAL IN [0..ev.nEntries) DO      IF ev.initialPC[ep] = pc THEN {        SymbolOps.SubStringForHash[sH, @desc, epMap[ep]];	EXIT};      REPEAT FINISHED => ERROR;      ENDLOOP;    String.AppendSubString[@buffer[buffer.callee], @desc];    String.AppendString[@buffer[buffer.callee], moduleName];    buffer ¬ OutToSortH­[      String.WordsForString[buffer.caller.length] + String.WordsForString[	buffer[buffer.callee].length] + 1];    END;      RecordExternal: PROC [link: CARDINAL] =    BEGIN    desc: String.SubStringDescriptor;    buffer­ ¬ [callee: NULL, caller: [length: 0, maxlength: 100, text:]];    String.AppendString[@buffer.caller, callerName];    buffer.callee ¬ LOOPHOLE[String.WordsForString[buffer.caller.length] + 1];    buffer[buffer.callee] ¬ [length: 0, maxlength: 100, text:];    IF linkMap = NIL THEN ERROR;    SymbolOps.SubStringForHash[sH, @desc, linkMap[link].hti];    String.AppendSubString[@buffer[buffer.callee], @desc];    String.AppendChar[@buffer[buffer.callee], '[];    String.AppendSubString[@buffer[buffer.callee], @linkMap[link].ssd];    String.AppendChar[@buffer[buffer.callee], ']];    buffer ¬ OutToSortH­[      String.WordsForString[buffer.caller.length] + String.WordsForString[	buffer[buffer.callee].length] + 1];    END;      RecordUnknown: PROC =    BEGIN    buffer­ ¬ [callee: NULL, caller: [length: 0, maxlength: 100, text:]];    String.AppendString[@buffer.caller, callerName];    buffer.callee ¬ LOOPHOLE[String.WordsForString[buffer.caller.length] + 1];    buffer[buffer.callee] ¬ [length: 1, maxlength: 100, text:];    buffer[buffer.callee].text[0] ¬ '*;    buffer ¬ OutToSortH­[String.WordsForString[buffer.caller.length] + 3 + 1];    END;      CompareCallers: PROC [p1, p2: LONG POINTER] RETURNS [i: INTEGER] =    BEGIN    k1: KeyBase = p1;    k2: KeyBase = p2;    i ¬ String.CompareStrings[@k1.caller, @k2.caller];    IF i = 0 THEN i ¬ String.CompareStrings[@k1[k1.callee], @k2[k2.callee]];    END;      CompareCallees: PROC [p1, p2: LONG POINTER] RETURNS [i: INTEGER] =    BEGIN    k1: KeyBase = p1;    k2: KeyBase = p2;    i ¬ String.CompareStrings[@k1[k1.callee], @k2[k2.callee]];    IF i = 0 THEN i ¬ String.CompareStrings[@k1.caller, @k2.caller];    END;      lastMajor: LONG STRING ¬ [80];  lastMinor: LONG STRING ¬ [80];  onThisLine: CARDINAL ¬ 0;  MaxOnLine: CARDINAL ¬ 80;  first: BOOLEAN ¬ TRUE;    NextItem: PROC [major, minor: LONG STRING] =    BEGIN    IF ~String.EquivalentString[major, lastMajor] THEN      BEGIN      PutCR[];  PutCR[];      Put[major];      PutCR[];      Put["    "L];      onThisLine ¬ 4;      first ¬ TRUE;      lastMajor.length ¬ 0;      String.AppendString[lastMajor, major];      END;    IF ~first THEN      BEGIN      IF String.EquivalentString[minor, lastMinor] THEN RETURN;      Put[", "L];      onThisLine ¬ onThisLine + 2;      IF onThisLine + minor.length > MaxOnLine THEN	{PutCR[]; Put["    "L]; onThisLine ¬ 4};      END;    Put[minor];    onThisLine ¬ onThisLine + minor.length;    lastMinor.length ¬ 0;    String.AppendString[lastMinor, minor];    first ¬ FALSE;    END;      PutByCaller: PROC [p: LONG POINTER, len: CARDINAL] =    BEGIN    key: KeyBase = p;    NextItem[major: @key.caller, minor: @key[key.callee]];    END;      PutByCallee: PROC [p: LONG POINTER, len: CARDINAL] =    BEGIN    key: KeyBase = p;    NextItem[major: @key[key.callee], minor: @key.caller];    END;      epMap: LONG POINTER TO EPMapSeq ¬ NIL;  EPMapSeq: TYPE = RECORD [epm: SEQUENCE length: CARDINAL OF Symbols.HTIndex];    CreateEpMap: PROC =    BEGIN    n: CARDINAL ¬ 0;        Enter: PROC [h: SymbolOps.Handle, bti: Symbols.BTIndex] RETURNS [stop: BOOLEAN] =      BEGIN      stop ¬ FALSE;      WITH b: h.bb[bti] SELECT FROM	Callable =>	  WITH b SELECT FROM	    Outer, Inner => {	      IF b.entryIndex > ev.nEntries THEN ERROR; 	      IF ~b.inline THEN epMap[b.entryIndex] ¬ SymbolOps.HashForSe[h, b.id]};	    ENDCASE;	ENDCASE;      END;          epMap ¬ Heap.systemZone.NEW[EPMapSeq[ev.nEntries]];    [] ¬ SymbolOps.EnumerateBodies[sH, FIRST[Symbols.BTIndex], Enter];    END;      linkMap: LONG POINTER TO LinkMapSeq ¬ NIL;  LinkMapItem: TYPE = RECORD [    hti: Symbols.HTIndex, ssd: String.SubStringDescriptor];  LinkMapSeq: TYPE = RECORD [lms: SEQUENCE length: CARDINAL OF LinkMapItem];    CreateLinkMap: PROC =    BEGIN    m: CARDINAL ¬ 0;        FindMax: PROC [sei: Symbols.ISEIndex, mname: String.SubString] =      BEGIN      IF sH.seb[sei].linkSpace AND ~sH.seb[sei].constant AND ~sH.seb[sei].extended THEN	BEGIN a: Symbols.BitAddress = SymbolOps.ToBitAddr[sH.seb[sei].idValue]; m ¬ MAX[m, a.wd/2]; END;      END;          Insert: PROC [sei: Symbols.ISEIndex, mname: String.SubString] =      BEGIN      IF sH.seb[sei].linkSpace AND ~sH.seb[sei].constant AND ~sH.seb[sei].extended THEN	BEGIN	a: Symbols.BitAddress = SymbolOps.ToBitAddr[sH.seb[sei].idValue];	linkMap[a.wd/2] ¬ [SymbolOps.HashForSe[sH, sei], mname­];	END;      END;          GenImports[FindMax];    linkMap ¬ Heap.systemZone.NEW[LinkMapSeq[m+1]];    GenImports[Insert];    END;      GenCtx: PROC [ctx: Symbols.CTXIndex, p: PROC [Symbols.ISEIndex]] =    BEGIN    sei: Symbols.ISEIndex;    FOR sei ¬ SymbolOps.FirstCtxSe[sH, ctx], SymbolOps.NextSe[sH, sei]       UNTIL sei = Symbols.SENull DO p[sei]; ENDLOOP;    END;      GenImports: PROC [    action: PROC [sei: Symbols.ISEIndex, mname: String.SubString]] =    BEGIN    sei: Symbols.ISEIndex;    ctx: Symbols.CTXIndex;    modnameSS: String.SubStringDescriptor;        DoAction: PROC [sei: Symbols.ISEIndex] = BEGIN action[sei, @modnameSS]; END;          FOR sei ¬ SymbolOps.FirstCtxSe[sH, sH.stHandle.importCtx],       SymbolOps.NextSe[sH, sei] UNTIL sei = Symbols.ISENull DO      SymbolOps.SubStringForHash[sH, @modnameSS, sH.seb[sei].hash];      WITH sH.seb[SymbolOps.UnderType[sH, sH.seb[sei].idType]] SELECT FROM	definition =>	  BEGIN	  isei: Symbols.ISEIndex;	  ctx ¬ defCtx;	  FOR isei ¬ SymbolOps.FirstCtxSe[sH, sH.stHandle.importCtx], SymbolOps.NextSe[sH, isei] 	  UNTIL isei =	    Symbols.ISENull DO	    WITH sH.seb[SymbolOps.UnderType[sH, sH.seb[isei].idType]] SELECT FROM	      definition =>		WITH sH.ctxb[defCtx] SELECT FROM		  imported =>		    IF includeLink = ctx THEN BEGIN ctx ¬ defCtx; EXIT END;		  ENDCASE;	      ENDCASE;	    ENDLOOP;	  END;	ENDCASE => LOOP; -- main body. Can't call procs of included modules      GenCtx[ctx, DoAction];      WITH sH.ctxb[ctx] SELECT FROM	included => NULL;	imported => GenCtx[includeLink, DoAction];	ENDCASE => LOOP; -- main body      ENDLOOP;    END;      EvenUp: PROC [n: CARDINAL] RETURNS [CARDINAL] =     -- Round up to an even number    BEGIN RETURN[n + n MOD 2]; END;      getbyte: PROC [pc: CARDINAL] RETURNS [b: BYTE] =     -- pc is a byte address    BEGIN    w: LONG POINTER TO InstWord;    w ¬ codebase + pc/2;    b ¬ (IF pc MOD 2 = 0 THEN w.evenbyte ELSE w.oddbyte);    END;      getword: PROC [pc: CARDINAL] RETURNS [WORD] =     -- pc is a word address    BEGIN RETURN[(codebase + pc)­]; END;      ExamineCode: PROC [startcode, endcode: CARDINAL] =    BEGIN -- list opcodes for indicated segment of code    OPEN Mopcodes;    inst, byte, lastInst: BYTE;    il: [0..3];    lastInst ¬ zNOOP;    FOR offset IN [startcode..endcode) DO      lastInst ¬ inst;      inst ¬ getbyte[offset];      il ¬ OpTableDefs.InstLength[inst];      SELECT il FROM	0, 1 =>	  SELECT inst FROM	    IN [zEFC0..zEFC12] => RecordExternal[inst - zEFC0];	    zSFC => 	      IF ~(lastInst IN [zLA0..zLAW] OR lastInst = zAL0IB) THEN 	        RecordUnknown[];	    ENDCASE;	2 =>	  BEGIN	  byte ¬ getbyte[(offset ¬ offset + 1)];	  SELECT inst FROM	    zEFCB => RecordExternal[byte];	    ENDCASE;	  END;	3 =>	  BEGIN	  ab: CARDINAL ¬ getbyte[(offset ¬ offset + 1)] * 256;	  ab ¬ ab + getbyte[(offset ¬ offset + 1)];	  SELECT inst FROM	    zLFC => RecordLocal[ab];	    ENDCASE;	  END;	ENDCASE;      ENDLOOP;    END;      ProcessFile: PROC [root: LONG STRING] = {    OPEN String, Symbols;    bcd: BcdOps.BcdBase;    mth: BcdOps.MTHandle;    prevBti: BTIndex ¬ BTNull;    desc: SubStringDescriptor;        SearchBody: PROC [h: SymbolOps.Handle, bti: BTIndex] RETURNS [stop: BOOLEAN] = {      ipc: CARDINAL;      WITH b: h.bb[bti] SELECT FROM	Callable =>	  IF ~b.inline THEN {	    desc: SubStringDescriptor;	    hti: HTIndex;	    WITH b SELECT FROM Catch => RETURN[FALSE]; ENDCASE;	    hti ¬ SymbolOps.HashForSe[h, b.id];	    SymbolOps.SubStringForHash[h, @desc, hti];	    callerName.length ¬ 0;	    AppendSubString[callerName, @desc];	    AppendString[callerName, moduleName];	    ipc ¬ ev.initialPC[b.entryIndex];	    WITH bi: b.info SELECT FROM	      External => IF bi.bytes # 0 THEN ExamineCode[ipc, ipc + bi.bytes];	      ENDCASE => ERROR};	ENDCASE;      RETURN[FALSE]};          BEGIN    sH ¬ NIL;    [bcd: bcd, sH: sH, code: codebase] ¬ ListerDefs.Load[root: root,      flags: ListerDefs.all        ! NoFGT => RESUME;        NoCode => GOTO definitions];    mth ¬ @LOOPHOLE[bcd + bcd.mtOffset, BcdDefs.Base][FIRST[BcdDefs.MTIndex]];    IF mth.entries = BcdDefs.ENNull THEN GOTO noentries;    ev ¬ @LOOPHOLE[bcd + bcd.enOffset, BcdDefs.Base][mth.entries];        BEGIN    main: BTIndex = FIRST[BTIndex];    hti: HTIndex;    CreateEpMap[];    CreateLinkMap[];    WITH m: sH.bb[main] SELECT FROM      Callable => hti ¬ SymbolOps.HashForSe[sH, m.id];      ENDCASE => ERROR;    moduleName.length ¬ 0;    AppendChar[moduleName, '[];    SymbolOps.SubStringForHash[sH, @desc, hti];    AppendSubString[moduleName, @desc];  AppendChar[moduleName, ']];    [] ¬ SymbolOps.EnumerateBodies[sH, FIRST[BTIndex], SearchBody];    END;    EXITS      noentries => Format.Line[ListerDefs.write, "      ignored (no entries)"L];    END;        IF sH # NIL THEN ListerDefs.ReleaseSymbols[sH];    IF epMap # NIL THEN z.FREE[@epMap];    IF linkMap # NIL THEN z.FREE[@linkMap];    EXITS      definitions => Format.Line[ListerDefs.write, "      ignored (defs)"L];    };      OutToSortH: POINTER TO GSort.SortItemPort;    DoXref: PROC [      fileList: LONG STRING, Compare: GSort.CompareProcType,      Print: GSort.PutProcType, ext: LONG STRING] = {    s: LONG STRING;    -- allocate the port in MDS.    -- In this PROC we can use OutToSort instead of OutToSortH­    OutToSort: GSort.SortItemPort;    -- open list of names    ListerDefs.OpenFileList[fileList];    -- crank up the sort package    OutToSortH ¬ @OutToSort;    LOOPHOLE[OutToSort, GSort.Port].out ¬ GSort.Sort;    buffer ¬ LOOPHOLE[OutToSort, GSort.SortStarter][      nextItem: OutToSortH, put: Print,      compare: Compare, expectedItemSize: 40, maxItemSize: 70, pagesInHeap: 90];    -- go through list of names, calling OutToSortH    UNTIL (s ¬ ListerDefs.NextNameInList[]) = NIL DO      ListerDefs.write["    "]; -- indent name      ProcessFile[s];      ENDLOOP;    -- get ready to ListerDefs.write output    ListerDefs.OpenOutput[fileList, ext];    lastMajor.length ¬ 0;  lastMinor.length ¬ 0;    -- shut down the sort package (and call Print many times)    LOOPHOLE[OutToSort, GSort.SortStopper][];    PutCR[]};      XrefByCaller: PROC [fileList: LONG STRING] =    BEGIN DoXref[fileList, CompareCallers, PutByCaller, "xlr"L]; END;      XrefByCallee: PROC [fileList: LONG STRING] =    BEGIN DoXref[fileList, CompareCallees, PutByCallee, "xle"L]; END;      CallXrefByCaller: ListerDefs.ListerProc =     BEGIN    XrefByCaller[CommandUtil.GetNth[argList, 0]];    END;      HelpXrefByCaller: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["XrefByCaller[""FileList""] "L];    END;  CallXrefByCallee: ListerDefs.ListerProc =     BEGIN    XrefByCallee[CommandUtil.GetNth[argList, 0]];    END;      HelpXrefByCallee: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["XrefByCallee[""FileList""] "L];    END;      Init: PROC =    BEGIN    ListerDefs.AddCommand["XrefByCaller"L, CallXrefByCaller, HelpXrefByCaller];    ListerDefs.AddCommand["XrefByCallee"L, CallXrefByCallee, HelpXrefByCallee];    END;      Init[];  END. 
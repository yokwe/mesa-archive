-- File: ListerRoutines.mesa - last edit:-- JBD                 31-Mar-87 10:14:02-- MEW                 14-Aug-86 15:42:41-- Johnsson            14-Jun-83 14:29:49-- Sweet               24-May-83 10:12:47-- Rhonda              28-Sep-82 15:19:13-- Lewis               20-Nov-81 16:06:26-- Loretta              8-Sep-81 15:23:50-- Bruce               20-Jun-81 17:08:55-- Sandman             October 14, 1980  11:06 AM-- Copyright (C) 1981, 1982, 1983, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Ascii USING [CR, SP, TAB],  BcdDefs USING [Base, FTIndex, FTSelf, MTIndex, MTNull, MTRecord,     VersionID, VersionStamp],  BcdDefsExtras USING [GFTVersionID],  BcdOps USING [BcdBase, SGHandle, MTHandle, NameString],  CommandUtil USING [CommandPtr, CopyString, Create, Destroy, Failed,     FreePairList, FreeString, PairList, Parse, SetExtension],  Environment USING [PageCount, PageNumber],  Exec USING [AddCommand, ExecProc, GetChar, Handle, Outcome, OutputProc],  Format USING [Blanks, Char, CR, Date, DateFormat, Decimal, Line,     LongDecimal, LongNumber, Number, NumberFormat, StringProc, SubString],  Heap USING [systemZone],  ListerDefs USING [bcdOnly, HelpProc, ListerProc, LoadFlags, LookupCommand],  MFile USING [AcquireTemp, CopyFileHandle, Error, Handle,     ReadOnly, Release, ReleaseData],  MSegment USING [Address, Create, Delete, GetFile, Handle, Pages,     ReleaseData, Reset],  MStream USING [Create, Error, Handle, ReleaseData, WriteOnly],  Runtime USING [GetBcdTime],  SpecialMFile USING [LeaderPages],  Stream USING [EndOfStream, GetChar, PutString],  String USING [AppendChar, AppendCharAndGrow, AppendLongNumber, AppendNumber,     AppendString, AppendSubString, Empty, EquivalentSubStrings, SubString,     SubStringDescriptor],  SymbolOps USING [Handle, SubStringForHash],  Symbols USING [Base, HTIndex, HTNull, ISEIndex, SENull],  SymbolTable USING [Acquire, Handle, Release, SymSegHandle],  Time USING [Append, Unpack],  Version USING [Append];ListerRoutines: MONITOR    IMPORTS       CommandUtil, Exec, Format, Heap, ListerDefs, MFile, MSegment,      MStream, Runtime, SpecialMFile, Stream, String, SymbolOps, SymbolTable,      Time, Version    EXPORTS ListerDefs =   BEGIN    fileExt: LONG STRING = "bcd";    FileSignal: TYPE = SIGNAL [name: LONG STRING];  NotABcd: PUBLIC FileSignal = CODE;  MultipleModules: PUBLIC FileSignal = CODE;  NoCode: PUBLIC FileSignal = CODE;  NoSymbols: PUBLIC FileSignal = CODE;  NoFGT: PUBLIC FileSignal = CODE;  FileUnavailable: PUBLIC FileSignal = CODE;  FileNotFound: PUBLIC FileSignal = CODE;  IncorrectVersion: PUBLIC SIGNAL [name: LONG STRING,    expected, found: BcdDefs.VersionStamp] = CODE;  ModuleNotFound: PUBLIC SIGNAL [config, module: LONG STRING];  z: UNCOUNTED ZONE = Heap.systemZone;    -- list of open file handles  openFiles: FilePtr ¬ NIL;  fpH: LONG POINTER TO FilePtr;  FilePtr: TYPE = LONG POINTER TO FileRecord;  FileRecord: TYPE = RECORD[next: FilePtr, seg: MSegment.Handle,    name: LONG STRING, sH: SymbolTable.Handle];  EnumProc: TYPE = PROC [p: FilePtr] RETURNS [stop: BOOLEAN ¬ FALSE];  EnumerateHandles: PROC [proc: EnumProc] RETURNS [stopped: BOOLEAN] = {    fpH ¬ @openFiles;    FOR p: FilePtr ¬ fpH­, fpH­ UNTIL p = NIL DO      IF proc[p] THEN RETURN[TRUE];      IF fpH­ # p THEN NULL -- DeleteHandle updated fpH­ so leave fpH alone.      ELSE fpH ¬ @p.next;      REPEAT        FINISHED => RETURN[FALSE];      ENDLOOP};  DeleteHandle: PROC [this: FilePtr] = { -- call from an EnumProc    IF this.sH # NIL THEN SymbolTable.Release[this.sH];    IF this.name # NIL THEN this.name ¬ CommandUtil.FreeString[this.name];    IF this.seg # NIL THEN MSegment.Delete[this.seg];    fpH­ ¬ this.next;    z.FREE[@this]};  -- Symbol table base maintenance      AcquireSymbols: PROC [sseg: MSegment.Handle]    RETURNS [sH: SymbolTable.Handle]  = {    -- sseg may already be in the openFiles. If there, sH replaces it.    ForEach: EnumProc = {IF p.seg = sseg THEN {p.sH ¬ sH; RETURN[TRUE]}};    sH ¬ SymbolTable.Acquire[LOOPHOLE[sseg]];    IF EnumerateHandles[ForEach] THEN NULL    ELSE openFiles ¬ z.NEW[FileRecord ¬ [openFiles, sseg, NIL, sH]];    };    ReleaseSymbols: PUBLIC PROC [sH: SymbolTable.Handle] = {    ForEach: EnumProc = {IF p.sH = sH THEN {DeleteHandle[p]; RETURN[TRUE]}};    [] ¬ EnumerateHandles[ForEach];    };  ReleaseBcd: PUBLIC PROC [bcd: BcdOps.BcdBase] = {    ForEach: EnumProc = {      IF MSegment.Address[p.seg] = bcd THEN {DeleteHandle[p]; RETURN[TRUE]}};    [] ¬ EnumerateHandles[ForEach];    }; -- Load a module's bcd, code, and symbol segments  Load: PUBLIC PROC [root: LONG STRING, flags: ListerDefs.LoadFlags]    RETURNS [bcd: BcdOps.BcdBase, sH: SymbolTable.Handle, code: LONG POINTER] = {    cseg, sseg: MSegment.Handle;    bseg: FilePtr ¬ OpenBcd[root, "object ", 0, 0];    tb, sgb: BcdDefs.Base;    mth: BcdOps.MTHandle;    sH ¬ code ¬ NIL;        tb ¬ LOOPHOLE[bcd ¬ MSegment.Address[bseg.seg]];    -- we are done if only the bcd is sought    IF flags = ListerDefs.bcdOnly THEN RETURN;    IF bcd.nModules # 1 THEN SIGNAL MultipleModules[bseg.name];        -- create segment on code    sgb ¬ tb + bcd.sgOffset;    mth ¬ @(tb + bcd.mtOffset)[FIRST[BcdDefs.MTIndex]];    IF flags.getCode THEN {      IF bcd.definitions OR sgb[mth.code.sgi].pages = 0 THEN        SIGNAL NoCode[bseg.name];      cseg ¬ OpenSegment[bseg, @sgb[mth.code.sgi], "code "];      code ¬ MSegment.Address[cseg] + mth.code.offset};	    -- create segment on symbols    IF flags.getSyms THEN {      IF sgb[mth.sseg].pages = 0 THEN SIGNAL NoSymbols[bseg.name];      IF sgb[mth.sseg].extraPages = 0 THEN SIGNAL NoFGT[bseg.name];      sseg ¬ OpenSegment[bseg, @sgb[mth.sseg], "symbol "];      sH ¬ AcquireSymbols[sseg]};    IF ~ flags.getBcd THEN ReleaseBcd[bcd]};           -- Load a module's Bcd, code, and symbol segments from a config's Bcd  LoadFromConfig: PUBLIC PROC [root, module: LONG STRING,    flags: ListerDefs.LoadFlags]    RETURNS [bcd: BcdOps.BcdBase, sH: SymbolTable.Handle, code: LONG POINTER,    mti: BcdDefs.MTIndex] = {    cseg, sseg: MSegment.Handle;    bseg: FilePtr;    tb, sgb: BcdDefs.Base;    ssb: BcdOps.NameString;    mth: BcdOps.MTHandle;    ss1, ss2: String.SubStringDescriptor;        SeeIfTheNeededModule: PROC [        mth: BcdOps.MTHandle, mti: BcdDefs.MTIndex] RETURNS [BOOLEAN] = {      ss2.offset ¬ mth.name;      ss2.length ¬ ssb.size[mth.name];      RETURN[String.EquivalentSubStrings[@ss1, @ss2]]};    bcd ¬ sH ¬ code ¬ NIL;        bseg ¬ OpenBcd[root, "object ", 0, 0];    tb ¬ LOOPHOLE[bcd ¬ MSegment.Address[bseg.seg]];    -- we are done if only the bcd is sought    IF flags = ListerDefs.bcdOnly THEN RETURN;        -- locate needed module    IF String.Empty[module] THEN      SIGNAL ModuleNotFound[config: bseg.name, module: module];    sgb ¬ tb + bcd.sgOffset;    ssb ¬ tb + bcd.ssOffset;    ss1 ¬ [base: module, offset: 0, length: module.length];    ss2.base ¬ @ssb.string;    [mth: mth, mti: mti] ¬ ProcessModules[bcd, SeeIfTheNeededModule];    IF mth = NIL THEN SIGNAL ModuleNotFound[config: bseg.name, module: module];        -- create segment on code    IF flags.getCode THEN {      IF bcd.definitions OR sgb[mth.code.sgi].pages = 0 THEN        SIGNAL NoCode[bseg.name];      cseg ¬ OpenSegment[bseg, @sgb[mth.code.sgi], "code "];      code ¬ MSegment.Address[cseg] + mth.code.offset};	    -- create segment on symbols    IF flags.getSyms THEN {      IF sgb[mth.sseg].pages = 0 THEN SIGNAL NoSymbols[bseg.name];      IF sgb[mth.sseg].extraPages = 0 THEN SIGNAL NoFGT[bseg.name];      sseg ¬ OpenSegment[bseg, @sgb[mth.sseg], "symbol "];      sH ¬ AcquireSymbols[sseg]};    IF ~ flags.getBcd THEN ReleaseBcd[bcd]};  LoadBcdSegment: PUBLIC PROC [root: LONG STRING, base: Environment.PageNumber,    pages: Environment.PageCount]    RETURNS [bcd: BcdOps.BcdBase] = {    bseg: FilePtr ¬ OpenBcd[root, "object segment ", base, pages];    bcd ¬ MSegment.Address[bseg.seg]};  LoadSymSegment: PUBLIC PROC [root: LONG STRING, base: Environment.PageNumber,    pages: Environment.PageCount]    RETURNS [sH: SymbolTable.Handle] = {    sseg: FilePtr ¬ OpenBcd[root, "object segment ", base, pages !      NotABcd => RESUME];    sH ¬ AcquireSymbols[sseg.seg] <<AcquireSymbols saves sH in openFiles>>};  OpenBcd: PROCEDURE [root, type: LONG STRING,    base: Environment.PageNumber, pages: Environment.PageCount]    RETURNS [FilePtr] = {    bcdFile: MFile.Handle ¬ NIL;    bcd: BcdOps.BcdBase;    name: LONG STRING ¬ CommandUtil.CopyString[root];    bcdseg: MSegment.Handle ¬ NIL;    BEGIN ENABLE UNWIND => {	name ¬ CommandUtil.FreeString[name];	IF bcdseg # NIL THEN MSegment.Delete[bcdseg]	ELSE IF bcdFile # NIL THEN MFile.Release[bcdFile]};      name ¬ CommandUtil.SetExtension[name, fileExt];      writeToExec["Opening "]; writeToExec[type]; writeToExec["file: "];      Format.Line[writeToExec, name];        -- open object file      bcdFile ¬ MFile.ReadOnly[name, MFile.ReleaseData[] 	! MFile.Error =>	  IF code = noSuchFile THEN ERROR FileNotFound[name]	  ELSE ERROR FileUnavailable[name]];      IF bcdFile = NIL THEN ERROR;        -- create segment on Bcd itself      IF pages = 0 THEN pages ¬ 1;      IF base # 0 THEN base ¬ base - SpecialMFile.LeaderPages[];      bcdseg ¬ MSegment.Create[	file: bcdFile, release: [], fileBase: base, pages: pages];      bcd ¬ MSegment.Address[bcdseg];        -- sanity checks. Can proceed from SIGNAL at own risk      SELECT TRUE FROM        (bcd.versionIdent # BcdDefs.VersionID AND 	  bcd.versionIdent # BcdDefsExtras.GFTVersionID) => SIGNAL NotABcd[name];        bcd.nPages > MSegment.Pages[bcdseg] => MSegment.Reset[	  segment: bcdseg, pages: bcd.nPages];        ENDCASE;      END;    openFiles ¬ z.NEW[FileRecord ¬ [openFiles, bcdseg, name, NIL]];    RETURN[openFiles];    };  OpenSegment: PROCEDURE [bseg: FilePtr, sgh: BcdOps.SGHandle,    type: LONG STRING]    RETURNS [seg: MSegment.Handle] = {    bcd: BcdOps.BcdBase ¬ MSegment.Address[bseg.seg];    tb: BcdDefs.Base ¬ LOOPHOLE[bcd];    ftb: BcdDefs.Base ¬ tb + bcd.ftOffset;    ssb: BcdOps.NameString ¬ tb + bcd.ssOffset;    fti: BcdDefs.FTIndex ¬ sgh.file;    name: LONG STRING ¬ NIL;    IF fti = BcdDefs.FTSelf THEN {      openFiles ¬ z.NEW[FileRecord ¬ [openFiles, NIL,	CommandUtil.CopyString[bseg.name], NIL]];      seg ¬ openFiles.seg ¬ MSegment.Create[	file: MFile.CopyFileHandle[MSegment.GetFile[bseg.seg], [], readOnly],	release: [],	fileBase: (sgh.base - SpecialMFile.LeaderPages[]),	pages: (sgh.pages + sgh.extraPages)]}    ELSE {      ENABLE UNWIND => name ¬ CommandUtil.FreeString[name];      ss: String.SubStringDescriptor ¬ [base: @ssb.string,        offset: ftb[fti].name, length: ssb.size[ftb[fti].name]];      name ¬ CommandUtil.CopyString[s: ""L, extra: ss.length];      String.AppendSubString[name, @ss];      seg ¬ OpenBcd[name, type, 0, 1].seg;      name ¬ CommandUtil.FreeString[name];      bcd ¬ MSegment.Address[seg];      IF bcd.version # ftb[fti].version THEN        SIGNAL IncorrectVersion[name: name, expected: ftb[fti].version,	  found:bcd.version];      MSegment.Reset[segment: seg,	fileBase: (sgh.base - SpecialMFile.LeaderPages[]),	pages: sgh.pages + sgh.extraPages]};    };  ProcessModules: PROC [    bcd: BcdOps.BcdBase,    proc: PROC[BcdOps.MTHandle, BcdDefs.MTIndex] RETURNS [BOOLEAN]]    RETURNS [mth: BcdOps.MTHandle, mti: BcdDefs.MTIndex] = {    mtb: BcdDefs.Base = LOOPHOLE[bcd+bcd.mtOffset];    FOR mti ¬ FIRST[BcdDefs.MTIndex], mti + SIZE[BcdDefs.MTRecord] UNTIL mti = bcd.mtLimit DO      IF proc[mth ¬ @mtb[mti], mti] THEN RETURN;      ENDLOOP;    RETURN[NIL, BcdDefs.MTNull]};      -- File list stuff   fileList: MStream.Handle ¬ NIL;  listItem: LONG STRING ¬ NIL;  nextChar: CHARACTER;  nextPos: LONG CARDINAL;  BadFileList: PUBLIC SIGNAL [position: LONG CARDINAL] = CODE;  OpenFileList: PUBLIC PROC [fileName: LONG STRING] = {    listFile: MFile.Handle ¬ NIL;    IF fileList # NIL OR listItem # NIL THEN ERROR;    listFile ¬ MFile.ReadOnly[fileName, MFile.ReleaseData[]       ! MFile.Error =>	IF code = noSuchFile THEN ERROR FileNotFound[fileName]	ELSE ERROR FileUnavailable[fileName]];    fileList ¬ MStream.Create[      file: listFile, release: MStream.ReleaseData[] !      MStream.Error => ERROR FileUnavailable[fileName]];    listItem ¬ z.NEW[StringBody[40]];    nextPos ¬ 0; nextChar ¬ ' ;    };  NextNameInList: PUBLIC PROC RETURNS [LONG STRING] = {    ENABLE Stream.EndOfStream => GOTO eof;    -- legal separators: space, comma, semicolon, tab, CR    listItem.length ¬ 0;    DO      SELECT nextChar FROM        ' , ',, ';, Ascii.TAB, Ascii.CR => NULL;	ENDCASE => EXIT;      nextChar ¬ Stream.GetChar[fileList];      nextPos ¬ nextPos + 1      ENDLOOP;    DO      SELECT nextChar FROM        IN ['a..'z], IN ['A..'Z], IN ['0..'9], '<, '>, '., 	 '+, '-, '~, '!, '$ => String.AppendCharAndGrow[@listItem, nextChar, z];	ENDCASE => EXIT;      nextChar ¬ Stream.GetChar[fileList];      nextPos ¬ nextPos + 1;      ENDLOOP;    IF listItem.length = 0 THEN ERROR BadFileList[nextPos-1]    ELSE RETURN[listItem];    EXITS eof => {      nextChar ¬ ' ;      RETURN[IF listItem.length = 0 THEN NIL ELSE listItem]};    };  CloseFileList: PROCEDURE = {    IF fileList # NIL THEN fileList.delete[fileList];    fileList ¬ NIL;    IF listItem # NIL THEN z.FREE[@listItem];    };  -- Output utilities  out: PUBLIC MStream.Handle ¬ NIL;  OpenOutput: PUBLIC PROC [name, ext: LONG STRING] = {    IF out # NIL THEN ERROR;    IF ext = NIL THEN ext ¬ ""L;    IF String.Empty[name] THEN {  -- a temp file is needed	file: MFile.Handle = MFile.AcquireTemp[type: text];	out ¬ MStream.Create[file: file, release: MStream.ReleaseData[]]}    ELSE {ENABLE UNWIND => name ¬ CommandUtil.FreeString[name];        dif: INTEGER = name.length-INTEGER[fileExt.length];	name ¬ CommandUtil.CopyString[name, ext.length + 2];	-- Catch the common mistake of appending "bcd"	IF dif>0 AND name[dif-1] = '. THEN {	  ss1: String.SubStringDescriptor ¬	    [base: name, offset: dif, length: fileExt.length];	  ss2: String.SubStringDescriptor ¬	    [base: fileExt, offset: 0, length: fileExt.length];	  IF String.EquivalentSubStrings[@ss1, @ss2] THEN name.length ¬ dif-1};	name ¬ CommandUtil.SetExtension[name, ext];	out ¬ MStream.WriteOnly[	  name: name, release: MStream.ReleaseData[], type: text	  ! MStream.Error => CONTINUE];	IF out = NIL THEN { -- perhaps name is an (open readonly) input file list	  -- strip off any existing extension and try again	  period: CARDINAL;	  FOR period DECREASING IN [0..name.length) DO	    IF name[period] = '. THEN EXIT;	    REPEAT FINISHED => GOTO unAvailable;	    ENDLOOP;	  name.length ¬ period;	  name ¬ CommandUtil.SetExtension[name, ext]; 	  out ¬ MStream.WriteOnly[	    name: name, release: MStream.ReleaseData[], type: text	    ! MStream.Error => CONTINUE];	  EXITS unAvailable => NULL;	  };	writeToExec["Opening output file: "];	Format.Line[writeToExec, name];	IF out = NIL THEN ERROR FileUnavailable[name];	name ¬ CommandUtil.FreeString[name]}};    CloseOutput: PUBLIC PROC = {IF out # NIL THEN out.delete[out]; out ¬ NIL};  put: Format.StringProc ¬ OutPut;  SetPutProc: PUBLIC PROC[new: Format.StringProc] = {put ¬ new};  ResetPutProc: PUBLIC PROC = {put ¬ OutPut};    OutPut: Format.StringProc =    {Stream.PutString[sH: out, string: s, endRecord: FALSE]};    Put: PUBLIC Format.StringProc = {put[s, clientData]};  PutLine: PUBLIC PROC [s: LONG STRING] = {put[s];  PutCR[]};  PutSubString: PUBLIC PROC [ss: String.SubString] = {Format.SubString[put, ss]};  PutCR: PUBLIC PROC = {Format.CR[put]};  PutChar: PUBLIC PROC [c: CHARACTER] = {Format.Char[put, c]};  PutVersionTime: PUBLIC PROC [date: BcdDefs.VersionStamp, format: Format.DateFormat] = {    Format.Date[put, LOOPHOLE[date.time], format]};  PutDecimal: PUBLIC PROC [n: INTEGER] = {Format.Decimal[put, n]};  PutNumber: PUBLIC PROC [n: UNSPECIFIED, format: Format.NumberFormat] = {    s: LONG STRING ¬ [20];    IF LOOPHOLE[n, INTEGER]<0 AND ~format.unsigned THEN {       n ¬ -LOOPHOLE[n, INTEGER]; -- correct even if n=8000H      format.unsigned ¬ TRUE --usurp the semantics of unsigned--};    String.AppendNumber[s, n, format.base];    -- usurp base too    IF LOOPHOLE[n, CARDINAL]<MIN[10,format.base] THEN format.base ¬ 2;    FormatNumber[format, s]};  PutLongNumber: PUBLIC PROC [n: LONG UNSPECIFIED, format: Format.NumberFormat] = {    s: LONG STRING ¬ [36];    IF LOOPHOLE[n, LONG INTEGER]<0 AND ~format.unsigned THEN {       n ¬ -LOOPHOLE[n, LONG INTEGER]; -- correct even if n=80000000H      format.unsigned ¬ TRUE --usurp the semantics of unsigned--};    String.AppendLongNumber[s, n, format.base];    -- usurp base too    IF LOOPHOLE[n, LONG CARDINAL]<MIN[10,format.base] THEN format.base ¬ 2;    FormatNumber[format, s]};  FormatNumber: PROC [format: Format.NumberFormat, s: LONG STRING] = {    fill: LONG STRING ¬ (IF format.zerofill THEN "00000000" ELSE "        ");    signs: LONG STRING ¬ [2];    fillChars: INTEGER;    fill.length ¬ 8; -- global frame strings can be smashed    IF ~format.unsigned THEN String.AppendChar[signs, '-]; --semantics usurped    IF ~format.zerofill THEN {      SELECT format.base FROM -- semantics usurped	16 => String.AppendChar[s, 'H];	8 => String.AppendChar[s, 'B];	ENDCASE;      IF s[0]>'9 THEN String.AppendChar[signs, '0]; -- leading zero      };    SELECT TRUE FROM      (fillChars ¬ format.columns-INTEGER[s.length+signs.length])>0 => {	IF signs.length>0 AND format.zerofill THEN put[signs];	THROUGH [0..fillChars/8) DO put[fill]; ENDLOOP;	IF (fill.length ¬ fillChars MOD 8) # 0 THEN put[fill];	IF signs.length>0 AND ~format.zerofill THEN put[signs]};      signs.length>0 => put[signs];      ENDCASE;    put[s];    };  octal: Format.NumberFormat =    [base: 8, columns: 0, zerofill: FALSE, unsigned: TRUE];  hex: Format.NumberFormat =    [base: 16, columns: 0, zerofill: FALSE, unsigned: TRUE];  PutOctal: PUBLIC PROC [o: UNSPECIFIED] = {PutNumber[o, octal]};  PutHex: PUBLIC PROC [n: UNSPECIFIED] = {PutNumber[n, hex]};  PutLongHex: PUBLIC PROC [n: LONG UNSPECIFIED] = {PutLongNumber[n, hex]};  PutBlanks: PUBLIC PROC [n: CARDINAL] = {Format.Blanks[put, n]};    PutIndent: PUBLIC PROC [n: CARDINAL] = {    PutCR[];    THROUGH [1..n/8] DO PutChar[Ascii.TAB] ENDLOOP;    THROUGH [1..n MOD 8] DO PutChar[Ascii.SP] ENDLOOP};      PutOneVersion: PROC [tag: LONG STRING,       version: LONG POINTER TO BcdDefs.VersionStamp] = {    IF version = NIL THEN RETURN;    put[tag];  PutVersionTime[version­, full];    put["  on "L];  PutMachine[version­];    PutCR[]};      PutVersions: PUBLIC PROC [      version, creator, source: LONG POINTER TO BcdDefs.VersionStamp ¬ NIL] = {    PutOneVersion[" created    ", version];    PutOneVersion["    creator ", creator];    PutOneVersion["    source  ", source];    PutCR[]};      PutMachine: PUBLIC PROC [stamp: BcdDefs.VersionStamp] = {    PutNumber[stamp.net, octal];  PutChar['#];    PutNumber[stamp.host, octal];  PutChar['#]};  PutHti: PUBLIC PROC [sH: SymbolTable.Handle, hti: Symbols.HTIndex] = {    desc: String.SubStringDescriptor;    s: String.SubString = @desc;    IF hti = Symbols.HTNull THEN put["(anonymous)"L]    ELSE {      SymbolOps.SubStringForHash[sH, s, hti]; PutSubString[s]}};      PutSei: PUBLIC PROC [sH: SymbolTable.Handle, sei: Symbols.ISEIndex] = {    PutHti[sH,      IF sei = Symbols.SENull THEN Symbols.HTNull ELSE sH.seb[sei].hash]};  PutSelf: PUBLIC PROC [bcd: BcdOps.BcdBase] = {    ForEach: EnumProc = {      IF MSegment.Address[p.seg] = bcd THEN {put[p.name]; RETURN[TRUE]}};    [] ¬ EnumerateHandles[ForEach];    }; -- Lister commands      write: PUBLIC Format.StringProc = {writeToExec[s]};  -- ouput to exec window  writeToExec: Format.StringProc ¬ NIL;    herald: LONG STRING ¬ [60];    CallLister: Exec.ExecProc = {    cmd: CommandUtil.CommandPtr;    argList, resultList: CommandUtil.PairList;    operator, switches: LONG STRING ¬ NIL;        Get: PROC RETURNS [CHARACTER] ¬ {RETURN[Exec.GetChar[h]]};    Cleanup: PROC  = {      CommandUtil.Destroy[cmd];      writeToExec ¬ NIL;      ReleaseLister[]};    CleanupOne: PROC  = {      ReleaseFiles[];      operator ¬ CommandUtil.FreeString[operator];      argList ¬ CommandUtil.FreePairList[argList];      resultList ¬  CommandUtil.FreePairList[resultList];      switches ¬ CommandUtil.FreeString[switches]};           tallyNormal, tallyWarning, tallyError: CARDINAL ¬ 0;    lProc: ListerDefs.ListerProc ¬ NIL;        IF LockLister[] THEN {      Exec.OutputProc[h]["Lister already busy!"L];      RETURN[warning]};    writeToExec ¬ Exec.OutputProc[h];    writeToExec[herald];    cmd ¬ CommandUtil.Create[Get];    DO ENABLE UNWIND => {CleanupOne[]; Cleanup[]};      [operator, argList, resultList, switches] ¬ CommandUtil.Parse[        cmd: cmd, allowNoTagParm: TRUE !          CommandUtil.Failed => {	    Format.Line[writeToExec, "Error parsing command line."L];	    tallyError ¬ tallyError + 1;	    EXIT}];      IF operator = NIL THEN EXIT;      lProc ¬ ListerDefs.LookupCommand[operator].proc;      writeToExec[operator]; Format.Line[writeToExec, "..."];      IF lProc = NIL THEN {	Format.Line[writeToExec, "No such command."];	outcome ¬ warning;	}      ELSE        outcome ¬ lProc[argList, resultList, switches !	  NotABcd => {	    outcome ¬ Complain[name, " is not an object file"];	    CONTINUE};	  IncorrectVersion => {	    temp: Format.StringProc = put;	    outcome ¬ Complain[name, " has the wrong time stamp", ' ];	    put ¬ writeToExec;	    PutOneVersion["(expected:", @expected];	    PutOneVersion[", found:", @found];	    Format.Line[writeToExec, ")"];	    put ¬ temp;	    CONTINUE};	  NoCode => {	    outcome ¬ Complain[name, " is a defs file or has no code segment"];	    CONTINUE};	  NoSymbols => {	    outcome ¬ Complain[name, " has no symbol segment"];	    CONTINUE};	  NoFGT => {	    outcome ¬ Complain[name, " has no fine grain table"];	    CONTINUE};	  MultipleModules => {	    outcome ¬ Complain[name, " is a config, not a module"];	    CONTINUE};	  FileUnavailable => {	    outcome ¬ Complain[name, " is not available"];	    CONTINUE};	  FileNotFound => {outcome ¬ Complain[name, " not found"]; CONTINUE};	  BadFileList => {	    outcome ¬ error;	    writeToExec["Error in file list at position "];	    Format.LongDecimal[writeToExec, position];	    Format.CR[writeToExec];	    CONTINUE};	  ModuleNotFound => {	    outcome ¬ Complain[config, " contains no module named", ' ];	    Format.Line[writeToExec, module];	    CONTINUE}	  ];      SELECT outcome FROM        normal  => tallyNormal ¬ tallyNormal + 1;        warning => tallyWarning ¬ tallyWarning + 1;        error   => tallyError ¬ tallyError + 1;        ENDCASE;      CleanupOne[];      ENDLOOP;    Format.CR[writeToExec];    IF tallyNormal > 0 THEN {      Format.Decimal[writeToExec, tallyNormal];      writeToExec[" successful. "L];      outcome ¬ normal};     IF tallyWarning > 0 THEN {      Format.Decimal[writeToExec, tallyWarning];      writeToExec[" with warnings. "L];      outcome ¬ warning};     IF tallyError > 0 THEN {      Format.Decimal[writeToExec, tallyError];      writeToExec[" with errors. "L];      outcome ¬ error};     Cleanup[]};  Complain: PROCEDURE [name, reason: LONG STRING, tag: CHARACTER ¬ Ascii.CR]    RETURNS [Exec.Outcome] = {    Format.CR[writeToExec];    writeToExec["Error: file "];    writeToExec[name];    writeToExec[reason];    Format.Char[writeToExec, tag];    RETURN[error]};  HelpLister: Exec.ExecProc = {    IF LockLister[] THEN {      Exec.OutputProc[h]["Lister already busy!"L];      RETURN[warning]};    writeToExec ¬ Exec.OutputProc[h];    -- Calls ListerCommands.HelpHelp    outcome ¬ ListerDefs.LookupCommand["Help"L].help[writeToExec];    writeToExec ¬ NIL;    ReleaseLister[];    };     -- Lister locking    lock: BOOLEAN ¬ FALSE;    LockLister: PUBLIC ENTRY PROC RETURNS [locked: BOOLEAN] = {     ENABLE UNWIND => NULL;    locked ¬ lock; lock ¬ TRUE};      ReleaseLister: PUBLIC ENTRY PROC = {    ENABLE UNWIND => NULL;    lock ¬ FALSE};  ReleaseFiles: PROC = { -- an idempotent operation    ForEach: EnumProc = {DeleteHandle[p]};    [] ¬ EnumerateHandles[ForEach];    CloseOutput[];    CloseFileList[]};    -- Lister initialization    RegisterLister: PROC = {    String.AppendString[to: herald, from: "Mesa Lister "L];    Version.Append[herald];    String.AppendString[to: herald, from: " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 3;    String.AppendChar[herald, Ascii.CR];    Exec.AddCommand[name: "Lister.~"L, proc: CallLister, help: HelpLister]};    RegisterLister[];    END.
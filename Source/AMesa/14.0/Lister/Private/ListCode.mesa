-- File: ListCode.mesa - last edit:-- JBD                  4-Mar-87 14:28:40--   Wagner;	23-Jan-86 12:26:18--   Sweet;	12-Aug-83 15:09:40--   Johnsson;	16-Jun-83 10:27:59--   Lewis;	29-Dec-82 19:04:38--   Karlton;	29-Dec-82 18:56:39--   Davirro;	 7-Dec-82 17:43:29--   Rhonda;	28-Sep-82 15:27:51--   JGS; 	 6-Nov-81  7:24:45--   Loretta;	24-Aug-81 15:10:42--   Bruce;	13-Jan-81 11:00:33-- Copyright (C) 1981, 1982, 1983, 1984, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Ascii USING [ControlZ, CR, SP, TAB],  BcdDefs USING [Base, MTIndex],  BcdOps USING [BcdBase, ENHandle, MTHandle],  CatchFormat USING [    CatchEV, CatchEVBody, CatchEVHandle, Codebase,     EnableHandle, EnableTableBody],  CommandUtil USING [GetNthPair, ListLength, PairList],  Environment USING [Byte],  Exec USING [Outcome],  Format USING [Number, NumberFormat],  Heap USING [systemZone],  Inline USING [BITAND, BITOR, LongCOPY],  ListerDefs USING [    AddCommand, HelpProc, ListerProc,    Load, LoadFromConfig,     OpenOutput, Put, PutBcdID, PutBlanks, PutChar, PutCR,     PutNumber, PutSubString, ReleaseSymbols, write],  Mopcodes,  MopOps USING [AppendEscAlpha, AppendMopcodeName, AppendSdName],  MStream USING [Error, Handle, ReadOnly, ReleaseData],  OpTableDefs USING [InstAligned, InstLength, PopStack, PushStack],  Stream USING [Byte, EndOfStream, Handle],  String USING [EquivalentString, StringLength, SubStringDescriptor],  SymbolOps USING [SubStringForHash],  Symbols USING [    Base, BodyInfo, BodyRecord, BTIndex, BTNull, CBTIndex,    HTIndex, HTNull, ISEIndex, SENull],  SymbolSegment USING [FGTEntry],  SymbolTable USING [Handle];  ListCode: PROGRAM    IMPORTS      CommandUtil, Format, Heap, Inline, ListerDefs,      MopOps, MStream, OpTableDefs, Stream, String,      SymbolOps =  BEGIN  OPEN LD: ListerDefs;    MTIndex: TYPE = BcdDefs.MTIndex;  NumberFormat: TYPE = Format.NumberFormat;  BYTE: TYPE = Environment.Byte;  opcode: TYPE = BYTE;    JumpOp: TYPE = [Mopcodes.zJ2..Mopcodes.zJIW];  InstWord: TYPE = MACHINE DEPENDENT RECORD [evenbyte, oddbyte: BYTE];    myFGT: LONG POINTER TO FGTSeq ¬ NIL;  FGTSeq: TYPE = RECORD[length: CARDINAL, fgt: SEQUENCE max: CARDINAL OF FineGrainInfo];  FineGrainInfo: TYPE = RECORD [    firstSource, lastSource: CARDINAL ¬ NullSource,    pc: CARDINAL,    procEnd: BOOLEAN,    bti: Symbols.CBTIndex];      NullSource: CARDINAL = LAST[CARDINAL]; -- if lastSource, causes to EOF    z: UNCOUNTED ZONE = Heap.systemZone;    DigestFGT: PROC [ev: BcdOps.ENHandle] =    BEGIN    i, n: CARDINAL;    bti, prev: Symbols.BTIndex;    cspp: CatchFormat.Codebase = codebase;    catchEV: CatchFormat.CatchEV = LOOPHOLE[cspp.header.catchCode/2];    catchEntry: CatchFormat.CatchEVHandle = @cspp[catchEV];    discardedCatch: BOOLEAN = (catchEV = LOOPHOLE[0]);        AddMyEntry: PROC [      source: CARDINAL ¬ NullSource, object: CARDINAL, procEnd: BOOLEAN ¬ FALSE] =      BEGIN      IF n = myFGT.max THEN	BEGIN	oldFGT: LONG POINTER TO FGTSeq ¬ myFGT;	myFGT ¬ z.NEW[FGTSeq[oldFGT.max + 10]];	Inline.LongCOPY[from: oldFGT, to: myFGT, nwords: SIZE[FGTSeq[n]]];	z.FREE[@oldFGT];      	END;      myFGT[n] ¬	[firstSource: source, pc: object, procEnd: procEnd, bti: LOOPHOLE[bti]];      n ¬ n + 1;      END;          AddBodyFGT: PROC [bti: Symbols.CBTIndex] =      BEGIN      body: LONG POINTER TO Callable Symbols.BodyRecord = @sH.bb[bti];      procstart: CARDINAL;      discarded: BOOLEAN;      first: BOOLEAN ¬ TRUE;      info: External Symbols.BodyInfo;      i, fgLast, lastSource, lastObject: CARDINAL;      f: SymbolSegment.FGTEntry;      WITH brc: body SELECT FROM        Catch => procstart ¬ IF discardedCatch THEN 0 ELSE catchEntry[brc.index];	ENDCASE => procstart ¬ ev.initialPC[body.entryIndex];      WITH bi: body.info SELECT FROM External => info ¬ bi; ENDCASE => GOTO nope;      fgLast ¬ info.startIndex + info.indexLength - 1;      lastSource ¬ sH.bb[bti].sourceIndex;      lastObject ¬ procstart;      discarded ¬ lastObject = 0;      FOR i IN [info.startIndex..fgLast] DO	f ¬ sH.fgTable[i];	WITH f SELECT FROM	  normal =>	    BEGIN	    lastSource ¬ lastSource + deltaSource;	    lastObject ¬ lastObject + deltaObject;	    IF ~discarded OR first THEN {	      AddMyEntry[source: lastSource, object: lastObject];	      first ¬ FALSE};	    END;	  step =>	    IF which = source THEN lastSource ¬ lastSource + delta	    ELSE lastObject ¬ lastObject + delta;	  ENDCASE;	ENDLOOP;      IF discarded THEN AddMyEntry[source: lastSource, object: 0]      ELSE AddMyEntry[object: procstart + info.bytes, procEnd: TRUE];      EXITS nope => NULL;      END;          BySource: PROC [r1, r2: LONG POINTER TO FineGrainInfo] RETURNS [BOOLEAN] =      BEGIN      IF r1.firstSource > r2.firstSource THEN RETURN[TRUE];      IF r1.firstSource = r2.firstSource THEN RETURN[r1.pc > r2.pc];      RETURN[FALSE];      END;          ByPC: PROC [r1, r2: LONG POINTER TO FineGrainInfo] RETURNS [BOOLEAN] =      BEGIN      IF r1.pc > r2.pc THEN RETURN[TRUE];      IF r1.pc < r2.pc THEN RETURN[FALSE];      IF r1.procEnd THEN RETURN[FALSE];      IF r2.procEnd THEN RETURN[TRUE];      RETURN[r1.firstSource > r2.firstSource];      END;          Sort: PROC [        greater: PROC [r1, r2: LONG POINTER TO FineGrainInfo] RETURNS [BOOLEAN]] =      BEGIN      i: CARDINAL;      temp: FineGrainInfo;      SiftUp: PROC [l, u: CARDINAL] =        BEGIN	s: CARDINAL;	key: FineGrainInfo ¬ myFGT[l-1];	DO	  s ¬ l*2;	  IF s > u THEN EXIT;	  IF s < u AND greater[@myFGT[s+1-1], @myFGT[s-1]] THEN s ¬ s+1;	  IF greater[@key, @myFGT[s-1]] THEN EXIT;	  myFGT[l-1] ¬ myFGT[s-1];	  l ¬ s;	  ENDLOOP;	myFGT[l-1] ¬ key;	END;      FOR i DECREASING IN [2..n/2] DO SiftUp[i, n]; ENDLOOP;      FOR i DECREASING IN [2..n] DO	SiftUp[1, i];	temp ¬ myFGT[1-1];	myFGT[1-1] ¬ myFGT[i-1];	myFGT[i-1] ¬ temp;	ENDLOOP;      END;          myFGT ¬ z.NEW[FGTSeq[(3*LENGTH[sH.fgTable])/2]];    n ¬ 0; -- n is a local cache for myFGT.length    bti ¬ LOOPHOLE[0];    IF sH.bb[bti].sourceIndex # 0 THEN       AddMyEntry[source: 0, object: ev.initialPC[0]];    DO      WITH sH.bb[bti] SELECT FROM	Callable => IF ~inline THEN AddBodyFGT[LOOPHOLE[bti]];	ENDCASE;      IF sH.bb[bti].firstSon # Symbols.BTNull THEN bti ¬ sH.bb[bti].firstSon      ELSE	DO	  prev ¬ bti;	  bti ¬ sH.bb[bti].link.index;	  IF bti = Symbols.BTNull THEN GO TO Done;	  IF sH.bb[prev].link.which # parent THEN EXIT;	  ENDLOOP;      REPEAT Done => NULL;      ENDLOOP;    myFGT.length ¬ n; -- set length correctly    Sort[BySource];    FOR i DECREASING IN [0..n - 1) DO      IF myFGT[i].firstSource = NullSource THEN LOOP;      IF myFGT[i].firstSource = myFGT[i+1].firstSource THEN {        myFGT[i].lastSource ¬ myFGT[i+1].lastSource; 	myFGT[i+1].firstSource ¬ myFGT[i+1].lastSource}      ELSE myFGT[i].lastSource ¬ myFGT[i + 1].firstSource;      ENDLOOP;    Sort[ByPC];    END;      offset: CARDINAL ¬ LAST[CARDINAL];  codebase: LONG POINTER ¬ NIL;  sH: SymbolTable.Handle ¬ NIL;  Tinst, Tbytes, Pinst, Pbytes: CARDINAL ¬ 0;  freqing: BOOLEAN ¬ FALSE;  absolute: BOOLEAN ¬ FALSE;    -- number formats    decimal: NumberFormat = NumberFormat[    base: 10, columns: 1, zerofill: FALSE, unsigned: TRUE];  decimal3: NumberFormat = NumberFormat[    base: 10, columns: 3, zerofill: FALSE, unsigned: TRUE];  hoctal3: NumberFormat ¬ NumberFormat[    base: 8, columns: 3, zerofill: FALSE, unsigned: TRUE];  hoctal3z: NumberFormat ¬ NumberFormat[    base: 8, columns: 3, zerofill: TRUE, unsigned: TRUE];  hoctal5: NumberFormat ¬ NumberFormat[    base: 8, columns: 5, zerofill: FALSE, unsigned: TRUE];  hoctal6: NumberFormat ¬ NumberFormat[    base: 8, columns: 6, zerofill: FALSE, unsigned: TRUE];  hoctal1: NumberFormat ¬ NumberFormat[    base: 8, columns: 1, zerofill: FALSE, unsigned: TRUE];  hoctal0: NumberFormat ¬ NumberFormat[    base: 8, columns: 0, zerofill: FALSE, unsigned: TRUE];    -- set base for listings    Decify: PROC =    BEGIN    hoctal3 ¬ NumberFormat[base: 8, columns: 3, zerofill: FALSE, unsigned: TRUE];    hoctal3z ¬ NumberFormat[      base: 8, columns: 3, zerofill: TRUE, unsigned: TRUE];    hoctal5 ¬ NumberFormat[base: 8, columns: 5, zerofill: FALSE, unsigned: TRUE];    hoctal6 ¬ NumberFormat[base: 8, columns: 6, zerofill: FALSE, unsigned: TRUE];    hoctal1 ¬ NumberFormat[base: 8, columns: 1, zerofill: FALSE, unsigned: TRUE];    END;      Hexify: PROC =    BEGIN    hoctal3 ¬ NumberFormat[base: 16, columns: 3, zerofill: FALSE, unsigned: TRUE];    hoctal3z ¬ NumberFormat[      base: 16, columns: 3, zerofill: FALSE, unsigned: TRUE];    hoctal5 ¬ NumberFormat[base: 16, columns: 5, zerofill: FALSE, unsigned: TRUE];    hoctal6 ¬ NumberFormat[base: 16, columns: 6, zerofill: FALSE, unsigned: TRUE];    hoctal1 ¬ NumberFormat[base: 16, columns: 1, zerofill: FALSE, unsigned: TRUE];    END;      Octify: PROC =    BEGIN    hoctal3 ¬ NumberFormat[base: 8, columns: 3, zerofill: FALSE, unsigned: TRUE];    hoctal3z ¬ NumberFormat[base: 8, columns: 3, zerofill: TRUE, unsigned: TRUE];    hoctal5 ¬ NumberFormat[base: 8, columns: 5, zerofill: FALSE, unsigned: TRUE];    hoctal6 ¬ NumberFormat[base: 8, columns: 6, zerofill: FALSE, unsigned: TRUE];    hoctal1 ¬ NumberFormat[base: 8, columns: 1, zerofill: FALSE, unsigned: TRUE];    END;      -- generate list of opcode lengths    OpcodeLengths: PROC [root: LONG STRING] =    BEGIN    i: opcode;    digit: STRING = "0123456789"L;    ListerDefs.OpenOutput[root, "list"L];    LD.Put["  OpcodeLengths: PACKED ARRAY [0..255] OF [0..3] = ["L];    FOR i IN opcode DO      IF i MOD 32 = 0 THEN {LD.PutCR[]; LD.Put["    "L]};      LD.PutChar[digit[OpTableDefs.InstLength[i]]];      IF i # LAST[opcode] THEN LD.PutChar[',];      ENDLOOP;    LD.Put["];"L];    LD.PutCR[];    END;      -- generate list of opcodes    OpcodeList: PROC [root: LONG STRING] =    BEGIN    op: STRING ¬ [16];    length: [0..3];    i: opcode;    digit: STRING = "0123456789"L;    ListerDefs.OpenOutput[root, "list"L];    LD.Put[      "-- Mesa Opcodes-- Format: name hoctal(decimal)push,pop,length,aligned"L];    FOR i IN opcode DO      op.length ¬ 0;      MopOps.AppendMopcodeName[op, i];      IF (length ¬ OpTableDefs.InstLength[i]) = 0 THEN op.length ¬ 0;      LD.Put[op];      THROUGH (op.length..8] DO LD.PutChar[' ] ENDLOOP;      LD.PutNumber[i, hoctal3];      LD.PutChar['(];      LD.PutNumber[i, decimal3];      LD.PutChar[')];      LD.PutChar[digit[OpTableDefs.PushStack[i]]];      LD.PutChar[',];      LD.PutChar[digit[OpTableDefs.PopStack[i]]];      LD.PutChar[',];      LD.PutChar[digit[length]];      LD.PutChar[',];      LD.PutChar[IF OpTableDefs.InstAligned[i] THEN 'T ELSE 'F];      IF i MOD 4 = 3 THEN         BEGIN LD.PutChar[';]; LD.PutCR[] END       ELSE LD.Put[";  "L];      ENDLOOP;    END;      -- source file procedures    sourceStream: MStream.Handle ¬ NIL;  sourceAvailable: BOOLEAN ¬ FALSE;      SetupSource: PROC = {    sourceAvailable ¬ TRUE;  sourceStream ¬ NIL;    sourceStream ¬ MStream.ReadOnly[      name: sH.sourceFile, release: MStream.ReleaseData[]       ! MStream.Error => {sourceAvailable ¬ FALSE; CONTINUE}]};      CloseSource: PROC = {    IF sourceAvailable THEN sourceStream.delete[sourceStream];    sourceStream ¬ NIL};    PrintSource: PROC [xfirst: CARDINAL, xlast: CARDINAL] = {    c: CHARACTER;    lastcr: CARDINAL;    IF ~sourceAvailable THEN RETURN;    FOR lastcr ¬ xfirst, lastcr - 1 UNTIL lastcr = 0 DO      sourceStream.setPosition[sourceStream, lastcr];      c ¬ LOOPHOLE[sourceStream.getByte[sourceStream], CHARACTER];      IF c = Ascii.CR THEN EXIT;      ENDLOOP;    THROUGH (lastcr..xfirst) DO LD.PutChar[Ascii.SP] ENDLOOP;    sourceStream.setPosition[sourceStream, xfirst];    WHILE xfirst # xlast DO      c ¬ LOOPHOLE[        sourceStream.getByte[sourceStream ! Stream.EndOfStream => GOTO eof],	CHARACTER];      xfirst ¬ xfirst + 1;      IF c = Ascii.ControlZ THEN	WHILE c # Ascii.CR DO	  c ¬ LOOPHOLE[	    sourceStream.getByte[sourceStream ! Stream.EndOfStream => GOTO eof],	    CHARACTER];	  xfirst ¬ xfirst + 1;	  ENDLOOP;      LD.PutChar[c];      REPEAT eof => NULL;      ENDLOOP;    IF c # Ascii.CR THEN LD.PutChar[Ascii.CR]};      PrintBodyName: PROC [bti: Symbols.BTIndex] =    BEGIN    sei: Symbols.ISEIndex;    hti: Symbols.HTIndex;    ss: String.SubStringDescriptor;    IF sourceAvailable THEN RETURN;    WITH sH.bb[bti] SELECT FROM      Callable =>	IF (sei ¬ id) = Symbols.SENull 	OR (hti ¬ sH.seb[sei].hash) = Symbols.HTNull THEN RETURN;      ENDCASE => RETURN;    SymbolOps.SubStringForHash[sH, @ss, hti];    LD.PutSubString[@ss];    LD.PutChar[':];    LD.PutCR[];    END;      EvenUp: PROC [n: CARDINAL] RETURNS [CARDINAL] =     -- Round up to an even number    BEGIN RETURN[n + n MOD 2]; END;      getbyte: PROC [pc: CARDINAL] RETURNS [b: BYTE] =     -- pc is a byte address    BEGIN    w: LONG POINTER TO InstWord;    w ¬ codebase + pc/2;    b ¬ IF Inline.BITAND[pc, 1] = 0 THEN w.evenbyte ELSE w.oddbyte;    END;      getword: PROC [pc: CARDINAL] RETURNS [WORD] =     -- pc is a word address    BEGIN    RETURN[(codebase + pc)­];    END;      jumpaddress: PROC [jop: opcode, arg: INTEGER] RETURNS [CARDINAL] =    BEGIN -- given a jump operator and its argument, return    -- its target address    OPEN Mopcodes;    SELECT OpTableDefs.InstLength[jop] FROM      1 =>	SELECT jop FROM	  IN [zJ2..zJ8] => arg ¬ jop - zJ2 + 2;	  IN [zJZ3..zJZ4] => arg ¬ jop - zJZ3 + 3;	  IN [zJNZ3..zJNZ4] => arg ¬ jop - zJNZ3 + 3;	  ENDCASE => ERROR;      2 => SELECT jop FROM        zJEP, zJNEP => arg ¬ arg MOD 16 + 4 - 1;        ENDCASE => 	  BEGIN	  IF arg > 177B THEN arg ¬ Inline.BITOR[arg, 177400B];	  arg ¬ arg - 1;	  END;      ENDCASE => {        SELECT jop FROM          zJEBB, zJNEBB => IF arg > 177B THEN arg ¬ Inline.BITOR[arg, 177400B];          ENDCASE;	arg ¬ arg - 2};    RETURN[INTEGER[offset] + arg]    END;      outwjtab: PROC [    tabstart, tablength: CARDINAL, octal: BOOLEAN, stripped: BOOLEAN] =    BEGIN    w: INTEGER;    pc: CARDINAL;    Pbytes ¬ Pbytes + tablength*2;    FOR pc IN [tabstart..tabstart + tablength) DO      w ¬ getword[pc];      LD.PutCR[];      LD.PutChar[Ascii.TAB] ;      LD.PutChar[Ascii.TAB] ;      IF stripped THEN BEGIN LD.PutNumber[w, hoctal5]; LOOP END;      IF octal THEN {        LD.PutChar[Ascii.TAB]; 	LD.PutChar[Ascii.TAB]};      LD.Put[" ("L];      LD.PutNumber[jumpaddress[Mopcodes.zJIW, w], hoctal5];      LD.PutChar[')];      ENDLOOP;    END;      outbjtab: PROC [    tabstart, tablength: CARDINAL, octal: BOOLEAN, stripped: BOOLEAN] =    BEGIN    b: BYTE;    pc: CARDINAL;    Pbytes ¬ Pbytes + EvenUp[tablength];    FOR pc IN [tabstart*2..tabstart*2 + tablength) DO      b ¬ getbyte[pc];      LD.PutCR[];      LD.PutChar[Ascii.TAB] ;      LD.PutChar[Ascii.TAB] ;      IF stripped THEN BEGIN LD.PutNumber[b, hoctal5]; LOOP END;      IF octal THEN {        LD.PutChar[Ascii.TAB]; 	LD.PutChar[Ascii.TAB]};      LD.Put[" ("L];      LD.PutNumber[jumpaddress[Mopcodes.zJIB, b], hoctal5];      LD.PutChar[')];      ENDLOOP;    END;      PutPair: PROC [byte: CARDINAL] =    BEGIN    a: CARDINAL = byte/16;    b: CARDINAL = byte MOD 16;    IF a < 8 AND b < 8 THEN LD.Put["  "L];    LD.PutChar['[];    -- Can't use LD.PutNumber here because we don't want trailing blanks on    -- octal numbers less than 8    Format.Number[LD.Put, a, hoctal1];    IF hoctal1.base = 8 AND a > 7 THEN LD.PutChar['B];    LD.PutChar[',];    Format.Number[LD.Put, b, hoctal1];    IF hoctal1.base = 8 AND b > 7 THEN LD.PutChar['B];    LD.PutChar[']];    END;      printcode: PROC [      startcode, endcode: CARDINAL, octal, stripped, wideCatch: BOOLEAN] =    BEGIN -- list opcodes for indicated segment of code    OPEN Inline, Mopcodes;    inst, byte: BYTE;    lastconstant, v: INTEGER;    mopString: STRING = [16];    il: [0..3];    FOR offset IN [startcode..endcode) DO      inst ¬ getbyte[offset];      -- loginst[inst];      Pinst ¬ Pinst + 1;      LD.PutChar[Ascii.TAB];      IF ~stripped THEN	BEGIN	IF octal THEN	  BEGIN	  LD.PutNumber[offset/2, hoctal5];	  LD.Put[(IF offset MOD 2 = 0 THEN ",E "L ELSE ",O "L)];	  END;	LD.PutNumber[offset, hoctal5];	LD.PutChar[':];	END;      IF octal THEN	BEGIN 	LD.PutChar[Ascii.TAB]; 	LD.PutChar['[];	LD.PutNumber[inst, hoctal3z]; 	LD.PutChar[']]; 	END;      LD.PutChar[Ascii.TAB];      IF wideCatch AND offset = startcode+1 THEN {        LD.PutNumber[inst, hoctal1];	LD.PutCR[];	LOOP};      mopString.length ¬ 0;      MopOps.AppendMopcodeName[mopString, inst];      LD.Put[mopString];      il ¬ OpTableDefs.InstLength[inst];      SELECT il FROM	0, 1 =>	  BEGIN	  Pbytes ¬ Pbytes + 1;	  IF inst IN [zLI0..zLI10] THEN lastconstant ¬ inst - zLI0	  ELSE IF inst = zLID0 THEN lastconstant ¬ 0	  ELSE	    IF inst IN JumpOp AND ~stripped THEN	      BEGIN	      LD.PutChar[Ascii.TAB] ;	      LD.Put["        ("L];	      LD.PutNumber[jumpaddress[inst, 0], hoctal1];	      LD.PutChar[')];	      END;	  END;	2 =>	  BEGIN	  Pbytes ¬ Pbytes + 2;	  byte ¬ getbyte[(offset ¬ offset + 1)];	  LD.PutChar[Ascii.TAB] ;	  SELECT inst FROM	    zRLIP, zRLILP, zRLDIP, zRLDILP, zRGIP, zRGILP, 	    zWLIP, zWLILP, zWLDILP, zR0F, zRL0F, zW0F, 	    zWL0F, zWS0F, zPS0F, zJEP, zJNEP => PutPair[byte];	    zESC => {	      IF octal THEN LD.PutNumber[byte, hoctal6];	      EscName[byte]};	    zKFCB => {	      IF octal THEN LD.PutNumber[byte, hoctal6];	      SdName[byte]};	    ENDCASE => LD.PutNumber[byte, hoctal6];	  IF inst = zLIB THEN lastconstant ¬ byte	  ELSE	    IF inst IN JumpOp AND ~stripped THEN	      BEGIN	      LD.Put[" ("L];	      LD.PutNumber[jumpaddress[inst, byte], hoctal1];	      LD.PutChar[')];	      END;	  END;	3 =>	  BEGIN	  ab: RECORD [first, second: BYTE];	  Pbytes ¬ Pbytes + 3;	  ab.first ¬ getbyte[(offset ¬ offset + 1)];	  ab.second ¬ getbyte[(offset ¬ offset + 1)];	  LD.PutChar[Ascii.TAB] ;	  SELECT inst FROM	    zRF, zWF, zRLF, zWLF, zPSF, zPSLF =>	      BEGIN	      LD.PutNumber[ab.first, hoctal6];	      LD.Put[", "L];	      PutPair[ab.second];	      END;	    ENDCASE =>	      BEGIN	      SELECT inst FROM	        zRLIPF, zRLILPF =>		  BEGIN		  PutPair[ab.first];		  LD.Put[", "L];		  PutPair[ab.second];		  END;	        zJEBB, zJNEBB =>		  BEGIN		  LD.PutNumber[ab.first, hoctal6];		  LD.Put[", "L];		  LD.PutNumber[ab.second, hoctal6];		  v ¬ ab.second;		  END;	        zESCL =>		  BEGIN		  IF octal THEN LD.PutNumber[ab.first, hoctal3];		  EscName[ab.first];		  LD.PutNumber[ab.second, hoctal6];		  END;	        ENDCASE => LD.PutNumber[(v ¬ ab.first*256 + ab.second), hoctal6];	      SELECT inst FROM		zJIB => outbjtab[v, lastconstant, octal, stripped];		zJIW => outwjtab[v, lastconstant, octal, stripped];		zLIW => lastconstant ¬ v;		IN JumpOp =>		  IF ~stripped THEN		    BEGIN		    LD.Put[" ("L];		    LD.PutNumber[jumpaddress[inst, v], hoctal1];		    LD.PutChar[')];		    END;		ENDCASE;	      END;	  END;	ENDCASE;      LD.PutCR[];      ENDLOOP;    END;      EscName: PROC [alpha: BYTE] = {    s: STRING ¬ [20];    MopOps.AppendEscAlpha[s, alpha];    IF s.length < 8 THEN LD.PutBlanks[8-s.length] ELSE LD.PutBlanks[1];    LD.Put[s]};      SdName: PROC [op: BYTE] = {    s: STRING ¬ [20];    MopOps.AppendSdName[s, op];    IF s.length < 8 THEN LD.PutBlanks[8-s.length] ELSE LD.PutBlanks[1];    LD.Put[s]};  ListFile: PROC [root: LONG STRING, octal, stripped: BOOLEAN] = {    bcd: BcdOps.BcdBase;    [bcd: bcd, sH: sH, code: codebase] ¬ ListerDefs.Load[root: root,       flags: [TRUE, TRUE, TRUE]];    DoCodeListing[root, bcd, FIRST[MTIndex], octal, stripped];    };      ListModInConfig: PROC [config, module: LONG STRING, octal, stripped: BOOLEAN] = {    bcd: BcdOps.BcdBase;    mti: MTIndex;    [bcd: bcd, sH: sH, code: codebase, mti: mti] ¬ ListerDefs.LoadFromConfig[       root: config, module: module, flags: [TRUE, TRUE, TRUE]];    DoCodeListing[module, bcd, mti, octal, stripped];    };      DoCodeListing: PROC [root: LONG STRING, bcd: BcdOps.BcdBase,    mti: MTIndex, octal, stripped: BOOLEAN] = {    OPEN BcdDefs, Symbols;    procFirst: CARDINAL ¬ 0;    ff: FineGrainInfo;    base: BcdDefs.Base ¬ LOOPHOLE[bcd];    ev: BcdOps.ENHandle;    mth: BcdOps.MTHandle;    prevBti: BTIndex ¬ BTNull;    wideCatch: BOOLEAN;        mth ¬ @(base + bcd.mtOffset)[mti];    ev ¬ @(base + bcd.enOffset)[mth.entries];        SetupSource[];        ListerDefs.OpenOutput[root, "cl"L];    BEGIN ENABLE UNWIND => CloseSource[];    ListerDefs.PutBcdID[bcd];    IF mth.crossJumped THEN {       LD.PutCR[];       LD.Put["Cross Jumped"L];  LD.PutCR[]};    LD.Put["Global frame size:  "L];  LD.PutNumber[mth.framesize, decimal];    LD.PutCR[];  LD.PutCR[];        ShowEntryVectors[ev];    ShowEnableTable[];        Tbytes ¬ Tinst ¬ 0;    DigestFGT[ev];    FOR i: CARDINAL IN [0..myFGT.length) DO      ff ¬ myFGT[i];      IF ff.pc = 0 THEN LOOP;      IF ff.bti # prevBti AND prevBti # BTNull THEN ShowTotals[];      IF ff.firstSource # NullSource THEN	IF ff.lastSource = ff.firstSource THEN LD.PutCR[]	ELSE PrintSource[ff.firstSource, ff.lastSource];      wideCatch ¬ FALSE;      IF ff.bti # prevBti THEN        WITH brc: sH.bb[ff.bti] SELECT FROM	  Catch => {	    fsi: CARDINAL ¬ 1;	    IF ~sourceAvailable THEN LD.PutCR[];	    LD.Put["   Catch entry point: "L];  LD.PutNumber[brc.index, decimal];	    IF getbyte[ff.pc] = Mopcodes.zJ2 THEN {	      fsi ¬ getbyte[ff.pc+1];  	      wideCatch ¬ TRUE};  -- display second byte in octal (as fsi)	    LD.Put[",  frame size index: "L];  LD.PutNumber[fsi, decimal];	    LD.PutCR[]};	  ENDCASE => {	    ep: CARDINAL = sH.bb[ff.bti].entryIndex;	    PrintBodyName[ff.bti];	    IF octal THEN LD.PutChar[Ascii.TAB] ;	    LD.Put["   Entry point: "L];  LD.PutNumber[ep, decimal];	    LD.Put[",   Frame size index:  "L];  LD.PutNumber[getbyte[ff.pc], decimal];	    LD.PutCR[];	    procFirst ¬ ff.pc};      IF ~ff.procEnd THEN {        first: CARDINAL ¬ ff.pc;	IF first = procFirst THEN first ¬ first + 1;	printcode[first, myFGT[i + 1].pc, octal, stripped, wideCatch]};      LD.PutCR[];      prevBti ¬ ff.bti;      ENDLOOP;    IF prevBti # Symbols.BTNull THEN ShowTotals[];    LD.PutCR[];    IF octal THEN LD.PutChar[Ascii.TAB] ;    LD.Put["Total instructions: "L];  LD.PutNumber[Tinst, decimal];    LD.Put[", Bytes: "L];  LD.PutNumber[Tbytes, decimal];    LD.PutCR[];  LD.PutCR[];        z.FREE[@myFGT];    ListerDefs.ReleaseSymbols[sH];    END; -- of enable UNWIND    CloseSource[]};      ShowTotals: PROC =    BEGIN    LD.Put["Instructions: "L];  LD.PutNumber[Pinst, decimal];    LD.Put[", Bytes: "L];  LD.PutNumber[(Pbytes ¬ EvenUp[Pbytes]), decimal];    LD.PutCR[];  LD.PutCR[];    Tinst ¬ Tinst + Pinst;  Pinst ¬ 0;    Tbytes ¬ Tbytes + Pbytes;  Pbytes ¬ 0;    END;      ShowEntryVectors: PROC [ev: BcdOps.ENHandle] = {    cspp: CatchFormat.Codebase = codebase;    -- first word after EV is rel. byte ptr to catch ev    catchEV: CatchFormat.CatchEV = LOOPHOLE[cspp.header.catchCode/2];    catchEntry: CatchFormat.CatchEVHandle = @cspp[catchEV];    LD.Put["Entry Vector:  evi [bytePC]"L];    LD.PutCR[];    FOR evi: CARDINAL IN [0..ev.nEntries) DO      LD.Put["  "L];      LD.PutNumber[evi, decimal];      LD.Put[" ["L];      LD.PutNumber[ev.initialPC[evi], hoctal0];      LD.Put["]"L];      LD.PutCR[];      ENDLOOP;    LD.PutCR[];    LD.Put["Catch Entry Vector:  cevi [bytePC]"L];    LD.PutCR[];    IF catchEV = LOOPHOLE[0] THEN LD.Put["  None"L]    ELSE FOR cevi: CARDINAL IN [0..catchEntry.count) DO      LD.Put["  "L];      LD.PutNumber[cevi, decimal];      LD.Put[" ["L];      LD.PutNumber[catchEntry[cevi], hoctal0];      LD.Put["]"L];      LD.PutCR[];      ENDLOOP;    LD.PutCR[];    LD.PutCR[]};      ShowEnableTable: PROC = {    cspp: CatchFormat.Codebase = codebase;    catchEV: CatchFormat.CatchEV = LOOPHOLE[cspp.header.catchCode/2];    catchEntry: CatchFormat.CatchEVHandle = @cspp[catchEV];    -- the (outermost, level 0) enable table follows the catch entry vector    outerET: CatchFormat.EnableHandle =       LOOPHOLE[catchEntry + SIZE[CatchFormat.CatchEVBody[catchEntry.count]]];          PrintEnableEntries: PROC [firstPC, lastPC, level: CARDINAL] = {      et: CatchFormat.EnableHandle ¬ outerET;      i: CARDINAL;      FOR i IN [0..level) DO        et ¬ et + SIZE[CatchFormat.EnableTableBody[et.count]];	ENDLOOP;      FOR i IN [0..et.count) DO        start: CARDINAL = et[i].start;	end: CARDINAL = (et[i].start + et[i].length - 1);        IF firstPC <= start AND end <= lastPC THEN {	  FOR j: CARDINAL IN [0..level] DO	    LD.Put["   "L];	    ENDLOOP;	  LD.PutChar['[];	  LD.PutNumber[start, hoctal0];	  LD.Put[".."L];	  LD.PutNumber[end, hoctal0];	  LD.Put["]  "L];	  LD.PutNumber[et[i].index, decimal];          LD.PutCR[];	  IF et[i].alsoNested THEN	    PrintEnableEntries[firstPC: start, lastPC: end, level: (level+1)]};	ENDLOOP};          IF catchEV = LOOPHOLE[0] THEN RETURN;    LD.Put["Enable Items:  [firstPC..lastPC]  catchIndex"L];    LD.PutCR[];    PrintEnableEntries[firstPC: 0, lastPC: LAST[NAT], level: 0];    LD.PutCR[]};  filename, modname: LONG STRING;  SetArgs: PROC [argList: CommandUtil.PairList, switches: LONG STRING] =    BEGIN    key, value: LONG STRING ¬ NIL;    i: CARDINAL;    filename ¬ modname ¬ NIL;    Decify[];       FOR i IN [0..String.StringLength[switches]) DO        SELECT switches[i] FROM         'o, 'O => Octify[];	 'h, 'H => Hexify[];	 'd, 'D => Decify[];         ENDCASE;	ENDLOOP;     FOR i IN [0..CommandUtil.ListLength[argList]) DO       [key,value] ¬ CommandUtil.GetNthPair[argList, i];       SELECT TRUE FROM	 String.EquivalentString[key, "ConfigName"L] => filename ¬ value;	 String.EquivalentString[key, "FileName"L] => filename ¬ value;	 String.EquivalentString[key, "ModName"L] => modname ¬ value;	 i=1 => modname ¬ value;	 ENDCASE => filename ¬ value       ENDLOOP;     END;  CallOpcodeLengths: ListerDefs.ListerProc =     BEGIN     SetArgs[argList, switches];    OpcodeLengths[filename];    END;      HelpOpcodeLengths: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["OpcodeLengths[""Filename""] "L];    END;  CallOpcodeList: ListerDefs.ListerProc =     BEGIN     SetArgs[argList, switches];    OpcodeList[filename];    END;      HelpOpcodeList: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["OpcodeList[""Filename""] "L];    END;  CallOctalCode: ListerDefs.ListerProc =     BEGIN     SetArgs[argList, switches];    ListFile[filename, TRUE, FALSE];    END;      HelpOctalCode: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["OctalCode[""Filename""] "L];    END;  CallCode: ListerDefs.ListerProc =     BEGIN     SetArgs[argList, switches];    ListFile[filename, FALSE, FALSE];    END;      HelpCode: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["Code[""Filename""] "L];    END;  CallStrippedCode: ListerDefs.ListerProc =     BEGIN     SetArgs[argList, switches];    ListFile[filename, FALSE, TRUE];    END;      HelpStrippedCode: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["StrippedCode[""Filename""] "L];    END;  CallOctalCodeInConfig: ListerDefs.ListerProc =     BEGIN     SetArgs[argList, switches];    ListModInConfig[filename, modname, TRUE, FALSE];    END;      HelpOctalCodeInConfig: ListerDefs.HelpProc =     BEGIN    ListerDefs.write["OctalCodeInConfig[""Config"", ""Module""] "L];    END;  CallCodeInConfig: ListerDefs.ListerProc =     BEGIN     SetArgs[argList, switches];    ListModInConfig[filename, modname, FALSE, FALSE];    END;      HelpCodeInConfig: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["CodeInConfig[""Config"", ""Module""] "L];    END;  CallStrippedCodeInConfig: ListerDefs.ListerProc =     BEGIN     SetArgs[argList, switches];    ListModInConfig[filename, modname, FALSE, TRUE];    END;      HelpStrippedCodeInConfig: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["StrippedCodeInConfig[""Config"", ""Module""] "L];    END;  Init: PROC =    BEGIN    ListerDefs.AddCommand["OpcodeLengths"L, CallOpcodeLengths, HelpOpcodeLengths];    ListerDefs.AddCommand["OpcodeList"L, CallOpcodeList, HelpOpcodeList];    ListerDefs.AddCommand["OctalCode"L, CallOctalCode, HelpOctalCode];    ListerDefs.AddCommand["Code"L, CallCode, HelpCode];    ListerDefs.AddCommand["StrippedCode"L, CallStrippedCode, HelpStrippedCode];    ListerDefs.AddCommand[      "OctalCodeInConfig"L, CallOctalCodeInConfig, HelpOctalCodeInConfig];    ListerDefs.AddCommand["CodeInConfig"L, CallCodeInConfig, HelpCodeInConfig];    ListerDefs.AddCommand[      "StrippedCodeInConfig"L, CallStrippedCodeInConfig, HelpStrippedCodeInConfig];    END;      Init[];    END.
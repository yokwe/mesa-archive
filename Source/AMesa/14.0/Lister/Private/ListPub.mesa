-- File: ListPub.mesa - last edit:-- JBD                  3-Mar-87 16:01:36-- MEW                 18-Jun-86  9:15:45-- Newman               5-Nov-83  2:01:31-- Sweet               24-May-83  9:55:42-- Guarino             17-Nov-82 11:42:49-- Rhonda               4-Oct-82 14:19:56-- Copyright (C) 1982, 1983, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Ascii USING [CR, SP],  CommandUtil USING [CopyString, FreeString, GetNth],  Exec USING [Outcome],  Format USING [CR, LongNumber, Number, StringProc],  GSort USING [GetProcType, PutProcType, Sort],  Inline USING [LongNumber, LowHalf],  ListerDefs USING [    AddCommand, CloseOutput, HelpProc, ListerProc,    Load, NextNameInList, NoFGT, OpenFileList, OpenOutput, out,    Put, PutChar, PutCR, PutDecimal, PutHti, PutOctal, PutSei,     ReleaseSymbols, symbolsOnly, write],  MFile USING [CopyFileHandle, Handle],  MStream USING [Create, EndOf, GetFile, Handle],  Stream USING [Delete, GetChar, GetPosition, Handle, SendNow],  String USING [    AppendChar, AppendDecimal, AppendString, AppendSubString,    CompareStrings, InvalidNumber, StringLength, StringToLongNumber,    SubStringDescriptor, WordsForString],  SymbolOps USING [FindExtension, FirstCtxSe, NextSe, NormalType,     SubStringForHash, ToBitAddr, ToCard, ToSei, TypeLink, UnderType, XferMode],  Symbols USING [    Base, BitAddress, BodyRecord, BTIndex, codeANY, codeCHAR,    codeINT, CSEIndex, CSENull, CTXIndex, ExtensionType, HTIndex, HTNull,    ISEIndex, ISENull, Limit, lZ, RecordSEIndex,    SEIndex, SENull, SERecord, StandardContext, TransferMode, typeANY, typeTYPE],  SymbolTable USING [Handle],  Tree USING [Base, Link, Node, Null];  ListPub: PROGRAM  IMPORTS    CommandUtil, Format, GSort, Inline, ListerDefs,     MFile, MStream, Stream, String, SymbolOps =  BEGIN OPEN Symbols;    CR: CHARACTER = Ascii.CR;  wordlength: CARDINAL = 16;  FileTooBig: SIGNAL = CODE;  largestItem: CARDINAL;  lastItem: LONG CARDINAL;  currentModule: LONG STRING ¬ [60];  sortSh: MStream.Handle;  sH: SymbolTable.Handle;  maxFileSize: LONG CARDINAL ¬ 30000;  myOutcome: Exec.Outcome;    alwaysMD: BOOLEAN ¬ FALSE;    VfTag: TYPE = {signed, unsigned, char, enum, array, transfer, ref, other};    ValFormat: TYPE = RECORD [    bias: INTEGER ¬ 0,    var: SELECT tag: VfTag FROM      signed => [], --an INTEGER or subrange with base < 0      unsigned => [], -- a CARDINAL, WORD, UNSPECIFIED, or subrange w/ base >= 0      char => [], --a character      enum => [esei: EnumeratedSEIndex], --an enumerated type      array => [componentType: SEIndex],      transfer => [mode: TransferMode], --a PROC, SIGNAL, ERROR, PROGRAM, or PORT      ref => [], --a pointer      other => [], --anything else (whether single word or multi-word)      ENDCASE];    PutString: Format.StringProc = ListerDefs.Put;  WriteString: Format.StringProc = ListerDefs.write;  WriteCR: PROC = {Format.CR[ListerDefs.write]};    PutCharConst: PROC [val: UNSPECIFIED] = {    Format.Number [PutString, val,      [base: 8, zerofill: FALSE, unsigned: TRUE, columns: 0]];      ListerDefs.PutChar['C]};  octalThreshold: NATURAL ¬ 1024;    PutSigned: PROC [val: UNSPECIFIED] = {    IF INTEGER[val] > octalThreshold THEN      Format.Number [PutString, val,        [base: 8, zerofill: FALSE, unsigned: FALSE, columns: 0]]    ELSE Format.Number [PutString, val,      [base: 10, zerofill: FALSE, unsigned: FALSE, columns: 0]]};        PutUnsigned: PROC [val: UNSPECIFIED] = {    IF CARDINAL[val] > octalThreshold THEN      Format.Number [PutString, val,        [base: 8, zerofill: FALSE, unsigned: TRUE, columns: 0]]    ELSE Format.Number [PutString, val,      [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]]};        PutLongSigned: PROC [val: LONG UNSPECIFIED] = {    IF LOOPHOLE[val, LONG INTEGER] > octalThreshold THEN      Format.LongNumber [PutString, val,        [base: 8, zerofill: FALSE, unsigned: FALSE, columns: 0]]    ELSE Format.LongNumber [PutString, val,      [base: 10, zerofill: FALSE, unsigned: FALSE, columns: 0]]};        PutLongUnsigned: PROC [val: LONG UNSPECIFIED] = {    IF LOOPHOLE[val, LONG CARDINAL] > octalThreshold THEN      Format.LongNumber [PutString, val,        [base: 8, zerofill: FALSE, unsigned: TRUE, columns: 0]]    ELSE Format.LongNumber [PutString, val,      [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]]};     CompareStrings: PROCEDURE [p1, p2: LONG POINTER] RETURNS [INTEGER] = {    RETURN [String.CompareStrings[p1, p2]]};      GetItem: GSort.GetProcType =    BEGIN    char: CHARACTER;    s: LONG STRING ¬ p;    s­ ¬ [length: 0, maxlength: largestItem - 2, text:];    UNTIL MStream.EndOf[sortSh] DO      char ¬ Stream.GetChar[sortSh];      IF char = CR THEN EXIT ELSE String.AppendChar[s, char];      REPEAT FINISHED => IF s.length = 0 THEN RETURN[0];      ENDLOOP;    RETURN[String.WordsForString[s.length]]    END;      PutItem: GSort.PutProcType =    BEGIN    IF firstOut THEN {      firstOut ¬ FALSE;      WriteString["-- writing .xref"L];      WriteCR[]};    PutString[p];    ListerDefs.PutCR[];    IF Stream.GetPosition[ListerDefs.out] > maxFileSize THEN SIGNAL FileTooBig;    END;      doPriv: BOOLEAN;    PrintSymbols: PROCEDURE =    BEGIN    modname: STRING ¬ [50];     ss: String.SubStringDescriptor;    mySei, sei: ISEIndex;    thisItem: LONG CARDINAL;    String.AppendString[modname, ": --"L]; -- set up modname    FOR sei ¬ SymbolOps.FirstCtxSe[sH, sH.stHandle.directoryCtx], SymbolOps.NextSe[sH, sei]     UNTIL sei = ISENull      DO mySei ¬ sei; ENDLOOP;    SymbolOps.SubStringForHash[sH, @ss, sH.seb[mySei].hash];    String.AppendSubString[modname, @ss];    String.AppendString[modname, "-- "L];    String.AppendSubString[currentModule, @ss];    FOR sei ¬ SymbolOps.FirstCtxSe[sH, sH.stHandle.outerCtx], SymbolOps.NextSe[sH, sei]     UNTIL sei = ISENull DO      IF (doPriv OR sH.seb[sei].public) THEN	BEGIN	defaultPublic ¬ TRUE;	PrintSym[sei, modname]; ListerDefs.PutChar[';];	ListerDefs.PutCR[];	thisItem ¬ Stream.GetPosition[ListerDefs.out];	largestItem ¬ MAX[	  CARDINAL[Inline.LowHalf[thisItem - lastItem]],	  largestItem];	lastItem ¬ thisItem;	END;      ENDLOOP;    END;      defaultPublic: BOOLEAN;    PrintSym: PROCEDURE [sei: ISEIndex, colonstring: STRING] =    BEGIN    savePublic: BOOLEAN ¬ defaultPublic;    typeSei: SEIndex;    IF sH.seb[sei].hash # HTNull THEN      BEGIN ListerDefs.PutSei[sH, sei]; PutString[colonstring]; END;    IF sH.seb[sei].public # defaultPublic THEN      BEGIN      defaultPublic ¬ sH.seb[sei].public;      PutString[IF defaultPublic THEN "PUBLIC "L ELSE "PRIVATE "L];      END;    IF sH.seb[sei].idType = typeTYPE THEN      BEGIN      vf: ValFormat;      typeSei ¬ SymbolOps.ToSei[sH.seb[sei].idInfo];      PutString["TYPE "L];      WITH t: sH.seb[typeSei] SELECT FROM        cons => WITH t SELECT FROM	  opaque => NULL;          ENDCASE => PutString["= "L];        ENDCASE => PutString["= "L];      vf ¬ PrintType[typeSei, NoSub];      PrintDefaultValue [sei, vf];      END    ELSE      BEGIN      vf: ValFormat;      typeSei ¬ sH.seb[sei].idType;      IF sH.seb[sei].immutable        AND NOT sH.seb[sei].constant	AND (SELECT SymbolOps.XferMode[sH, typeSei] FROM	  none, process => TRUE, ENDCASE => FALSE)	    --it's not a proc, signal, error, program, or port        THEN PutString ["READONLY "L];      vf ¬ PrintType[typeSei, NoSub];      IF sH.seb[sei].constant AND vf.tag <= enum THEN	BEGIN	PutString[" = "L];	IF sH.seb[sei].extended THEN 	  PrintTreeLink [SymbolOps.FindExtension[sH, sei].tree, vf]	ELSE PrintTypedVal[sH.seb[sei].idValue, vf];	END;      END;    defaultPublic ¬ savePublic;    END;      PrintTypedVal: PROCEDURE [val: UNSPECIFIED, vf: ValFormat] =    BEGIN    loophole: BOOLEAN ¬ FALSE;     val ¬ val + vf.bias;    WITH vf SELECT FROM      signed => PutSigned [val];      unsigned => PutUnsigned [val];      char => PutCharConst[val];      enum => PutEnum[val, esei];      transfer, ref => IF val = 0 THEN PutString ["NIL"L] ELSE loophole ¬ TRUE;      ENDCASE => loophole ¬ TRUE;    IF loophole THEN      {PutString ["LOOPHOLE ["L];      PutUnsigned [val];      ListerDefs.PutChar[']]};    END;      GetBitSpec: PROCEDURE [isei: ISEIndex, bitspec: STRING] =    BEGIN    a: BitAddress = SymbolOps.ToBitAddr[sH.seb[isei].idValue];    s: CARDINAL = SymbolOps.ToCard[sH.seb[isei].idInfo];    bitspec.length ¬ 0;    String.AppendString[bitspec, " ("L];    String.AppendDecimal[bitspec, a.wd];    IF s # 0 THEN {      String.AppendChar[bitspec, ':];      String.AppendDecimal[bitspec, a.bd];      String.AppendString[bitspec, ".."L];      String.AppendDecimal[bitspec, a.bd+s-1]};    String.AppendString[bitspec, "): "L]    END;      PrintFieldCtx: PROCEDURE [ctx: CTXIndex, md: BOOLEAN ¬ FALSE] =    BEGIN OPEN sH;    isei: ISEIndex ¬ SymbolOps.FirstCtxSe[sH, ctx];    bitspec: STRING ¬ [20];    first: BOOLEAN ¬ TRUE;    IF ~md THEN String.AppendString[bitspec, ": "L];    IF isei # ISENull AND sH.seb[isei].idCtx # ctx THEN isei ¬ SymbolOps.NextSe[sH, isei];    IF isei = ISENull THEN BEGIN PutString["NULL"L]; RETURN END;    ListerDefs.PutChar['[];    FOR isei ¬ isei, SymbolOps.NextSe[sH, isei] UNTIL isei = ISENull DO      IF first THEN first ¬ FALSE ELSE PutString[", "L];      IF md OR alwaysMD THEN GetBitSpec[isei, bitspec];      PrintSym[isei, bitspec];      PrintDefaultValue [isei, GetValFormat [sH.seb [isei].idType]];      ENDLOOP;    ListerDefs.PutChar[']];    END;      PrintValue: PROCEDURE [value: UNSPECIFIED] =    BEGIN    IF LOOPHOLE[value, CARDINAL] < 1000 THEN ListerDefs.PutDecimal[value]    ELSE ListerDefs.PutOctal[value];    END;      NoSub: PROCEDURE = BEGIN RETURN END;        EnumeratedSEIndex: TYPE =     Symbols.Base RELATIVE POINTER [0..Limit) TO enumerated cons SERecord;      PutEnum: PROCEDURE [val: UNSPECIFIED, esei: EnumeratedSEIndex] =    BEGIN OPEN Symbols, sH;    sei: ISEIndex;    FOR sei ¬ SymbolOps.FirstCtxSe[sH, sH.seb[esei].valueCtx], SymbolOps.NextSe[sH, sei]       WHILE sei # ISENull DO      IF sH.seb[sei].idValue = val THEN {ListerDefs.PutSei[sH, sei]; RETURN};      ENDLOOP;    PutString["LOOPHOLE ["L];    PrintValue[val];    ListerDefs.PutChar[']];    END;      GetValFormat: PROC [tsei: SEIndex] RETURNS [vf: ValFormat] =    BEGIN    WITH t: sH.seb[tsei] SELECT FROM      id => RETURN [GetValFormat [SymbolOps.UnderType[sH, tsei]]];      cons =>	WITH t SELECT FROM	  basic =>  	    SELECT code FROM	      codeANY => vf ¬ [,unsigned []];	      codeINT => vf ¬ [,signed []];	      codeCHAR => vf ¬ [,char[]];	      ENDCASE;	  enumerated => vf ¬ [,enum [LOOPHOLE [tsei]]];	  array => vf ¬ [,array [componentType]];	  transfer => vf ¬ [,transfer[mode]];	  relative => vf ¬ GetValFormat [offsetType];	  subrange =>	     {vf ¬ GetValFormat [rangeType];	     IF vf.tag = signed AND origin >= 0 THEN vf ¬ [,unsigned[]];	     vf.bias ¬ origin};	  long => vf ¬ GetValFormat [rangeType];	  ref => vf ¬ [,ref []];	  ENDCASE => vf ¬ [,other[]];       ENDCASE => vf ¬ [,other[]];     END;	  PrintType: PROCEDURE [tsei: SEIndex, dosub: PROCEDURE]    RETURNS [vf: ValFormat] =    BEGIN OPEN Symbols, ListerDefs, sH;    bitspec: STRING = [20];    vf ¬ GetValFormat[tsei];    WITH t: sH.seb[tsei] SELECT FROM      id =>	BEGIN	printBase: BOOLEAN ¬ TRUE;	multiSubrange: BOOLEAN ¬ FALSE;	bsei: SEIndex ¬ tsei;	csei: CSEIndex;	--print adjectives, if any        tseiNext: SEIndex;	BEGIN	l1: SEIndex = SymbolOps.ToSei[t.idInfo];	IF sH.seb[l1].seTag = id THEN GO TO noAdj;	UNTIL (tseiNext ¬ SymbolOps.TypeLink[sH, tsei]) = SENull DO	  WITH sH.seb[tsei] SELECT FROM	    id => BEGIN PutSei[sH, LOOPHOLE[tsei]]; ListerDefs.PutChar[Ascii.SP]; END;	    ENDCASE;	  tsei ¬ tseiNext;	  ENDLOOP;	EXITS	  noAdj => NULL;	END;	--print module qualification of last ID in chain	IF t.idCtx NOT IN Symbols.StandardContext THEN	  WITH c: ctxb [t.idCtx] SELECT FROM	    included =>	      BEGIN  	      hti: HTIndex = mdb [c.module].moduleId;  	      ListerDefs.PutHti[sH, hti]; --interface name  	      ListerDefs.PutChar['.]; -- dot qualification  	      END;  	    -- simple => PutCurrentModuleDot[];	    ENDCASE;	      	--finally print that last ID		DO	  csei ¬ SymbolOps.UnderType[sH, bsei];	  WITH sH.seb[csei] SELECT FROM	    basic =>	      BEGIN	      SELECT code FROM		codeINT => printBase ¬ multiSubrange;		ENDCASE;	      EXIT;	      END;	    subrange => {bsei ¬ rangeType; multiSubrange ¬ TRUE};	    enumerated => {printBase ¬ TRUE; EXIT};	    ENDCASE => EXIT;	  ENDLOOP;	IF printBase OR dosub = NoSub THEN PutSei[sH, LOOPHOLE[tsei]];	dosub[];	END;      cons =>	WITH t SELECT FROM	  --basic =>  won't see one, see the id first.	  	  enumerated =>	    BEGIN	    isei: ISEIndex;	    v: CARDINAL ¬ 0;	    sv: CARDINAL;	    md: BOOLEAN = machineDep;	    first: BOOLEAN ¬ TRUE;	    IF md THEN PutString["MACHINE DEPENDENT "L];	    ListerDefs.PutChar['{];	    FOR isei ¬ SymbolOps.FirstCtxSe[sH, valueCtx], SymbolOps.NextSe[sH, isei] 	    UNTIL isei = ISENull DO	      IF first THEN first ¬ FALSE ELSE PutString[", "L];	      IF md THEN {	        hti: Symbols.HTIndex = sH.seb[isei].hash;	        sv ¬ SymbolOps.ToCard[sH.seb[isei].idValue];		IF hti # HTNull THEN PutSei[sH, isei];		IF hti = HTNull OR sv # v THEN 		  {ListerDefs.PutChar['(]; PutUnsigned[sv]; ListerDefs.PutChar[')]};		v ¬ sv + 1}	      ELSE PutSei[sH, isei];	      ENDLOOP;	    ListerDefs.PutChar['}];	    END;	  record =>	    BEGIN	    IF ctxb[fieldCtx].level # lZ THEN	      BEGIN	      fctx: CTXIndex = fieldCtx;	      bti: BTIndex ¬ FIRST[BTIndex];	      btlimit: BTIndex = bti + sH.stHandle.bodyBlock.size;	      PutString["FRAME ["L];	      UNTIL bti = btlimit DO		WITH entry: bb[bti] SELECT FROM		  Callable =>		    BEGIN		    IF entry.localCtx = fctx THEN		      BEGIN PutSei[sH, entry.id]; ListerDefs.PutChar[']]; EXIT END;		    bti ¬		      bti +			(WITH entry SELECT FROM			   Inner => SIZE[Inner Callable BodyRecord],			   ENDCASE => SIZE[Outer Callable BodyRecord]);		    END;		  ENDCASE => bti ¬ bti + SIZE[Other BodyRecord];		ENDLOOP;	      END	    ELSE	      BEGIN	      dp: BOOLEAN ¬ defaultPublic;	      IF defaultPublic AND hints.privateFields THEN {	        PutString["PRIVATE "L];		defaultPublic ¬ FALSE};	      IF monitored THEN PutString["MONITORED "L];	      IF machineDep THEN PutString["MACHINE DEPENDENT "L];	      PutString["RECORD "L];	      PrintFieldCtx[fieldCtx, machineDep];	      defaultPublic ¬ dp;	      END;	    END;	  ref =>	    BEGIN	    IF var	      THEN IF readOnly	        THEN PutString ["READONLY "L]		ELSE PutString ["VAR "L]	      ELSE	        BEGIN	        IF ordered THEN PutString["ORDERED "L];	        IF basing THEN PutString["BASE "L];	        PutString["POINTER "L];	        IF dosub # NoSub THEN dosub[];	        WITH sH.seb[SymbolOps.UnderType[sH, refType]] SELECT FROM	           basic => IF code = Symbols.codeANY AND ~readOnly THEN		     GO TO noprint;	           ENDCASE;	        PutString["TO "L];	        IF readOnly THEN PutString["READONLY "L];		END;	    [] ¬ PrintType[refType, NoSub];	    EXITS noprint => NULL;	    END;	  array =>	    BEGIN	    IF packed THEN PutString["PACKED "L];	    PutString["ARRAY "L];	    [] ¬ PrintType[indexType, NoSub];	    PutString[" OF "L];	    [] ¬ PrintType[componentType, NoSub];	    END;	  arraydesc =>	    BEGIN	    PutString["DESCRIPTOR FOR "L];	    IF readOnly THEN PutString["READONLY "L];	    [] ¬ PrintType[describedType, NoSub];	    END;	  transfer =>	    BEGIN	    PutModeName[mode];	    IF typeIn # CSENull THEN	      BEGIN ListerDefs.PutChar[' ]; 	      WITH tt: sH.seb[typeIn] SELECT FROM	        record => PrintFieldCtx[tt.fieldCtx]; 		ENDCASE => ERROR;	      END;	    IF typeOut # CSENull THEN	      BEGIN	      PutString[" RETURNS "L];	      WITH tt: sH.seb[typeOut] SELECT FROM	        record => PrintFieldCtx[tt.fieldCtx];	        ENDCASE => ERROR;	      END;	    END;	  union =>	    BEGIN	    tagType: SEIndex;	    PutString["SELECT "L];	    IF ~controlled THEN	      IF overlaid THEN PutString["OVERLAID "L]	      ELSE PutString["COMPUTED "L]	    ELSE 	      BEGIN 	      PutSei[sH, tagSei]; 	      IF machineDep OR alwaysMD THEN {	        GetBitSpec[tagSei, bitspec]; PutString[bitspec]}	      ELSE PutString[": "L];	      END;	    tagType ¬ sH.seb[tagSei].idType;	    IF sH.seb[tagSei].public # defaultPublic THEN	      PutString[		IF defaultPublic THEN "PRIVATE "L ELSE "PUBLIC "L];	    WITH sH.seb[tagType] SELECT FROM	      id => [] ¬ PrintType[tagType, NoSub];	      cons => ListerDefs.PutChar['*];	      ENDCASE;	    PutString[" FROM "L];	    BEGIN	    isei: ISEIndex;	    varRec: RecordSEIndex;	    FOR isei ¬ SymbolOps.FirstCtxSe[sH, caseCtx], SymbolOps.NextSe[sH, isei] 	    UNTIL isei = ISENull DO	      PutSei[sH, isei];	      PutString[" => "L];	      varRec ¬ LOOPHOLE[SymbolOps.UnderType[sH,  SymbolOps.ToSei[sH.seb[isei].idInfo]]];	      PrintFieldCtx[sH.seb[varRec].fieldCtx, machineDep];	      PutString[", "L];	      ENDLOOP;	    PutString[" ENDCASE"L];	    END;	    END;	  relative =>	    BEGIN	    IF baseType # SENull THEN [] ¬ PrintType[baseType, NoSub];	    PutString[" RELATIVE "L];	    [] ¬ PrintType[offsetType, dosub];	    END;	  sequence =>	    BEGIN	    tagType: SEIndex;	    IF packed THEN PutString["PACKED "L];	    PutString["SEQUENCE "];	    IF ~controlled THEN PutString["COMPUTED "L]	    ELSE 	      BEGIN 	      PutSei[sH, tagSei]; 	      IF machineDep OR alwaysMD THEN {	        GetBitSpec[tagSei, bitspec]; PutString[bitspec]}	      ELSE PutString[": "L];	      END;	    tagType ¬ sH.seb[tagSei].idType;	    IF sH.seb[tagSei].public # defaultPublic THEN	      PutString[		IF defaultPublic THEN "PRIVATE "L ELSE "PUBLIC "L];	    [] ¬ PrintType[tagType, NoSub];	    PutString[" OF "L];	    [] ¬ PrintType[componentType, NoSub];	    END;	  subrange =>	    BEGIN	    org: INTEGER ¬ origin;	    size: CARDINAL ¬ range;	    mt: BOOLEAN ¬ empty;	    	    doit: PROCEDURE =	      BEGIN	      vfSub: ValFormat ¬ vf;	      vfSub.bias ¬ 0;	      ListerDefs.PutChar['[];	      PrintTypedVal[org, vfSub];	      PutString[".."L];	      IF mt THEN {PrintTypedVal[org, vfSub]; ListerDefs.PutChar[')]}	      ELSE {PrintTypedVal[org + size, vfSub]; ListerDefs.PutChar[']]};	      END;	      	    [] ¬ PrintType[rangeType, doit];	    vf.bias ¬ org;	    END;	  zone => SELECT TRUE FROM	    counted => PutString["ZONE"L];	    mds => PutString["MDSZone"L];	    ENDCASE => PutString["UNCOUNTED ZONE"L];	  opaque => {	    IF lengthKnown THEN {	      ListerDefs.PutChar['[]; 	      ListerDefs.PutDecimal[length / wordlength]; 	      ListerDefs.PutChar[']]}};	  long =>	      BEGIN	      IF NOT IsVar [rangeType] THEN PutString["LONG "L];	      [] ¬ PrintType[rangeType, NoSub];	      END;	  real => PutString["REAL "L];	  ENDCASE => PutString[" LISTXREF CAN'T TELL YOU "L];      ENDCASE;    END;      IsVar: PROC [tsei: Symbols.SEIndex] RETURNS [BOOLEAN] =    BEGIN    WITH t: sH.seb[tsei] SELECT FROM      id => RETURN [FALSE];      cons => WITH t2: t SELECT FROM        ref => RETURN [t2.var]	ENDCASE => RETURN [FALSE];      ENDCASE => RETURN [FALSE];    END;        PutModeName: PROCEDURE [n: TransferMode] =    BEGIN    ModePrintName: ARRAY TransferMode OF STRING =      ["PROCEDURE"L, "PORT"L, "SIGNAL"L, "ERROR"L, "PROCESS"L, "PROGRAM"L,	"NONE"L];    PutString[ModePrintName[n]]    END;  LUP: TYPE = LONG POINTER TO LONG UNSPECIFIED;  NodePointer: TYPE = LONG POINTER TO Tree.Node;    PrintDefaultValue: PROC [sei: ISEIndex, vf: ValFormat] =    BEGIN    extType: ExtensionType;    tree: Tree.Link;    [extType, tree] ¬ SymbolOps.FindExtension[sH, sei];    IF extType # default THEN RETURN;    PutString [" ¬ "L];    PrintTreeLink [tree, vf];    END;    PrintTreeLink: PROC [tree: Tree.Link, vf: ValFormat] =    BEGIN    IF tree = Tree.Null THEN RETURN;    WITH t: tree SELECT FROM      subtree =>        BEGIN	node: NodePointer = @sH.tb[t.index];	SELECT node.name FROM	  all =>	    BEGIN	    PutString ["ALL["L];	    WITH v: vf SELECT FROM	      array => PrintTreeLink[node.son [1], GetValFormat[v.componentType]];	      ENDCASE;	    ListerDefs.PutChar[']];	    END;	  mwconst, cast, loophole => PrintTreeLink[node.son [1], vf];	  nil => PutString ["NIL"L];	  void => PutString ["NULL"L];	  dot, cdot =>	    BEGIN	    PrintTreeLink[node.son[1], [,other[]]];	    ListerDefs.PutChar['.]; --dot	    PrintTreeLink[node.son[2], [,other[]]];	    END;	  first, last, size => 	    BEGIN	    PutString[SELECT node.name FROM 	      first => "FIRST["L, 	      last => "LAST["L, 	      ENDCASE => "SIZE["L];	    PrintTreeLink[node.son[1], vf];	    ListerDefs.PutChar[']];	    END;	  lengthen => 	    BEGIN	    s1: Tree.Link = node.son[1];	    IF s1.tag = literal THEN PrintTreeLink[s1, vf]	    ELSE {	      PutString["LONG["L];	      PrintTreeLink[s1, vf];	      ListerDefs.PutChar[']]};	    END;	  construct => 	    BEGIN	    s1: Tree.Link = node.son[1];	    ListerDefs.PutChar['[];	    IF node.nSons = 2 THEN PrintTreeLink [node.son[2], vf];	    ListerDefs.PutChar[']];	    END;	  union => PutString[" xxxx "L];	    --  BEGIN	    --  PrintTreeLink [node.son[1], vf];	    --  ListerDefs.PutChar['[];	    --  PrintTreeLink [node.son[2], vf];	    --  ListerDefs.PutChar[']];	    --  END;	  list => IF node.nSons # 0 THEN PutString[" xxxx "L];	    --  BEGIN	    --  FOR j: CARDINAL IN [1..node.nSons) DO	      --  PrintTreeLink [node.son[j], [other[]]];	      --  PutString [", "L];	      --  ENDLOOP;	    --  IF node.nSons # 0	      --  THEN PrintTreeLink [node.son[node.nSons], [other[]]]; 	    --  END;	  longTC =>	    BEGIN	    PutString ["LONG "L];	    PrintTreeLink [node.son[1], vf];	    END;	  uparrow =>	    BEGIN	    ptr: Tree.Link = node.son[1];	    type: Symbols.CSEIndex;	    WITH p: ptr SELECT FROM	      symbol =>	        type ¬ SymbolOps.NormalType[sH, SymbolOps.UnderType[sH, 		  sH.seb[p.index].idType]];	      subtree => type ¬ LOOPHOLE[sH.tb[p.index].info];	      ENDCASE => type ¬ Symbols.typeANY;	    PrintTreeLink[node.son[1], [,other[]]];	    WITH q: sH.seb[type] SELECT FROM	      ref => IF ~q.var THEN ListerDefs.PutChar['­];	      ENDCASE => ListerDefs.PutChar['­];	    END;	  ENDCASE => PutString ["xxxx "L];	END;      hash => ListerDefs.PutHti[sH, t.index];      symbol => ListerDefs.PutSei[sH, t.index];      literal =>	BEGIN	WITH lr: t.info SELECT FROM	  word =>	    WITH sH.ltb[lr.index] SELECT FROM	      short => PrintTypedVal [value, vf];	      long =>	        SELECT length FROM	          2 =>		    BEGIN		    loophole: BOOLEAN ¬ FALSE;		    SELECT vf.tag FROM		      signed => PutLongSigned [LOOPHOLE [@value, LUP]­];		      unsigned => PutLongUnsigned [LOOPHOLE [@value, LUP]­];		      transfer, ref =>		        IF LOOPHOLE[@value, LUP]­ = 0			  THEN PutString ["NIL"L]			  ELSE loophole ¬ TRUE;		      ENDCASE => loophole ¬ TRUE;		    IF loophole THEN		      BEGIN		      PutString ["LOOPHOLE ["L];		      PutLongUnsigned [LOOPHOLE [@value, LUP]­];		      ListerDefs.PutChar[']];		      END;		    END;		  ENDCASE => PutString["xxx"];	      ENDCASE; --shouldn't happen! 	    ENDCASE --string-- => PutString ["(STRING)"L];	  END;      ENDCASE; --shouldn't happen!    END;    		            DoSymbols: PROCEDURE [bcdFile: LONG STRING] =    BEGIN    defs: BOOLEAN ¬ FALSE;    WriteString["    "]; -- indent name    [sH: sH] ¬ ListerDefs.Load[bcdFile, ListerDefs.symbolsOnly !      ListerDefs.NoFGT => RESUME];    PrintSymbols[];    ListerDefs.ReleaseSymbols[sH];    END; -- Of DoSymbols    globalRoot: LONG STRING;  firstOut: BOOLEAN;    DoIt: PROCEDURE [root: LONG STRING, privateToo: BOOLEAN] =    BEGIN    outExt: STRING ¬ [10];    fileNum: CARDINAL ¬ 2;    globalRoot ¬ root;    doPriv ¬ privateToo;        WriteString["Cross reference listing"L];    IF privateToo THEN WriteString[" including private symbols"L];    WriteCR[];        largestItem ¬ 0;    lastItem ¬ 0;    ListerDefs.OpenOutput[NIL, NIL]; -- temporaray file    ListerDefs.OpenFileList[root];    GSort.Sort[      get: GetName, put: PutName, compare: CompareStrings,       expectedItemSize: 22, maxItemSize: 32];    ListerDefs.PutCR[]; -- trailer for module list    ListerDefs.PutCR[]; -- skip a line    WriteCR[];    WriteCR[]; WriteString["-- sorting --"L];    firstOut ¬ TRUE;    largestItem ¬ largestItem + 20; -- a little slop    GSort.Sort[        get: GetItem, put: PutItem, compare: CompareStrings, 	expectedItemSize: 100, maxItemSize: largestItem/2 !      FileTooBig =>	BEGIN	ListerDefs.PutCR[]; PutString["END."L]; ListerDefs.PutCR[];	ListerDefs.CloseOutput[];	outExt.length ¬ 0;	String.AppendDecimal[outExt, fileNum];	String.AppendString[outExt, "xref"L];	ListerDefs.OpenOutput[root, outExt];	fileNum ¬ fileNum + 1;	PutString["Dummy: DEFINITIONS = BEGIN"L];	ListerDefs.PutCR[];	ListerDefs.PutCR[];	WriteString["-- writing "L];	WriteString[outExt];        WriteCR[];	RESUME	END];    Stream.Delete[sortSh];    ListerDefs.PutCR[]; PutString["END."L]; ListerDefs.PutCR[];    ListerDefs.CloseOutput[];    END;      ChangeOutput: PROCEDURE =    BEGIN    fh: MFile.Handle;    Stream.SendNow[ListerDefs.out];     fh ¬ MFile.CopyFileHandle[MStream.GetFile[ListerDefs.out], [], readOnly];    ListerDefs.CloseOutput[];    sortSh ¬ MStream.Create[fh, []];    ListerDefs.OpenOutput[globalRoot, "xref"L];    PutString["Dummy: DEFINITIONS = BEGIN"L]; ListerDefs.PutCR[]; ListerDefs.PutCR[];    PutString["-- PUBLIC SYMBOLS FOR "L];    END;      GetName: GSort.GetProcType =    BEGIN OPEN String;    file: LONG STRING ¬ ListerDefs.NextNameInList[];    s: LONG STRING ¬ p;    s­ ¬ [length: 0, maxlength: 60, text:];    IF file = NIL THEN {      ChangeOutput[];      ListerDefs.PutCR[]; -- trailer for heading      PutString["-- "L];      RETURN[0];      };    DoSymbols[file];    AppendString[s, currentModule];    AppendChar[s, Ascii.SP];    currentModule.length ¬ 0;    RETURN[WordsForString[s.length]]    END;      PutName: GSort.PutProcType = {s: LONG STRING ¬ LOOPHOLE[p]; PutString[s]};    CallXref: ListerDefs.ListerProc =     BEGIN    privateToo: BOOLEAN ¬ FALSE;    name: LONG STRING;    sense: BOOLEAN ¬ TRUE;    myOutcome ¬ normal; alwaysMD ¬ FALSE;    FOR i: CARDINAL IN [0..String.StringLength[switches]) DO       SELECT switches[i] FROM        'p, 'P => {privateToo ¬ sense; sense ¬ TRUE};	'~, '- => sense ¬ NOT sense;	'm, 'M => {alwaysMD ¬ sense; sense ¬ TRUE};        ENDCASE;      ENDLOOP;    name ¬ CommandUtil.CopyString[CommandUtil.GetNth[argList,0]];    DoIt[name, privateToo ! UNWIND => name ¬ CommandUtil.FreeString[name]];    name ¬ CommandUtil.FreeString[name];    RETURN [myOutcome];    END;        SetFileSize: ListerDefs.ListerProc =     BEGIN    size: LONG STRING ¬ CommandUtil.GetNth[argList,0];    BEGIN    maxFileSize ¬       String.StringToLongNumber[size, 10 ! String.InvalidNumber => GO TO bad];    RETURN [normal];    EXITS      bad => {ListerDefs.write[" Invalid number"L]; RETURN [error]};    END;    END;            HelpXref: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["Xref[""fileList""](/p --for private also) "L];    END;  HelpFileSize: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["XrefFileSize[bytecount] -- break output into files this size "L];    END;  Init: PROC =    BEGIN    ListerDefs.AddCommand["Xref"L, CallXref, HelpXref];    ListerDefs.AddCommand["XrefFileSize"L, SetFileSize, HelpFileSize];    END;      -- mainline    Init[];    END...
-- File: ListerCommands.mesa - last edit:-- JBD                 17-Feb-87  9:09:57-- MEW		21-Jan-86 15:29:40   -- Rhonda	28-Sep-82 10:52:23-- Loretta,	21-Aug-81 13:33:15-- Copyright (C) 1981, 1982, 1986 , 1987, 1987, 1987, 1987, 1987, 1987, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  CommandUtil USING[GetNth, ListLength],  Heap USING [systemZone],  Inline USING [LongCOPY],  ListerDefs USING [HelpProc, ListerProc, LookupCommand, write],  String USING [EquivalentString],  StringLookUp USING [InTable];ListerCommands: MONITOR   IMPORTS     CommandUtil, Heap, Inline, ListerDefs, String,  StringLookUp  EXPORTS ListerDefs =  BEGIN OPEN LD: ListerDefs;    CRString: LONG STRING = "";  initTableSize: CARDINAL = 30;  tableInc: CARDINAL = 10;  tableSize: CARDINAL ¬ initTableSize;  commandCount: CARDINAL ¬ 0;    z: UNCOUNTED ZONE = Heap.systemZone;  -- Command tables: length = commandCount, maxlength = tableSize  CommandSeq: TYPE = RECORD[commands: SEQUENCE COMPUTED CARDINAL OF LONG STRING];  ProcSeq: TYPE = RECORD[procs: SEQUENCE COMPUTED CARDINAL OF LD.ListerProc];  HelpSeq: TYPE = RECORD[helps: SEQUENCE COMPUTED CARDINAL OF LD.HelpProc];  Procs: LONG POINTER TO ProcSeq ¬ z.NEW[ProcSeq[initTableSize]];  Commands: LONG POINTER TO CommandSeq ¬ z.NEW[CommandSeq[initTableSize]];  Helps: LONG POINTER TO HelpSeq ¬ z.NEW[HelpSeq[initTableSize]];  AddCommand: PUBLIC ENTRY PROCEDURE        [name: LONG STRING, proc: LD.ListerProc, help: LD.HelpProc] =    BEGIN    ENABLE UNWIND => NULL;    index: CARDINAL;    index ¬ StringLookUp.InTable[name, DESCRIPTOR[Commands, commandCount]];    IF index < commandCount THEN {      IF Commands[index].length = name.length THEN         {Procs[index] ¬ proc; Helps[index] ¬ help; RETURN}};	    IF commandCount = tableSize THEN EnlargeTable[];    Commands[commandCount] ¬ z.NEW[StringBody [name.length]];    Commands[commandCount].length ¬ name.length;    FOR i: CARDINAL IN [0..name.length) DO      Commands[commandCount][i] ¬ name[i] ENDLOOP;    Procs[commandCount] ¬ proc;    Helps[commandCount] ¬ help;    commandCount ¬ commandCount + 1;    END;  RemoveCommand: PUBLIC ENTRY PROCEDURE [name: LONG STRING] =    BEGIN    ENABLE UNWIND => NULL;    index: CARDINAL;    index ¬ StringLookUp.InTable[name, DESCRIPTOR[Commands, commandCount]];    IF index >= commandCount THEN RETURN;    z.FREE[@Commands[index]];    IF commandCount > 1 THEN      BEGIN      Commands[index] ¬ Commands[commandCount - 1];      Procs[index] ¬ Procs[commandCount - 1];      Helps[index] ¬ Helps[commandCount - 1];      END;    commandCount ¬ commandCount - 1;    END;  LookupCommand: PUBLIC ENTRY PROCEDURE [command: LONG STRING]    RETURNS [      name: LONG STRING ¬ NIL, proc: LD.ListerProc ¬ NIL, help: LD.HelpProc ¬ NIL,      didExpand: BOOLEAN ¬ FALSE] =    BEGIN    ENABLE UNWIND => NULL;    index: CARDINAL;    index ¬ StringLookUp.InTable[command, DESCRIPTOR[Commands, commandCount]];    IF index >= commandCount THEN RETURN;    name ¬ Commands[index];    proc ¬ Procs[index];    help ¬ Helps[index];    didExpand ¬ command.length # Commands[index].length;    END;      EnumerateCommands: PUBLIC ENTRY PROCEDURE [    userProc: PROCEDURE [name: LONG STRING, proc: LD.ListerProc, hProc: LD.HelpProc]      RETURNS [stop: BOOLEAN]] =    BEGIN    ENABLE UNWIND => NULL;    i: CARDINAL;    FOR i IN [0..commandCount) DO      IF userProc[Commands[i], Procs[i], Helps[i]] THEN EXIT; ENDLOOP;    END;  EnlargeTable: INTERNAL PROCEDURE =    BEGIN    oldCommands: LONG POINTER TO CommandSeq ¬ Commands;    oldProcs: LONG POINTER TO ProcSeq ¬ Procs;    oldHelps: LONG POINTER TO HelpSeq ¬ Helps;    newSize: CARDINAL = tableSize + tableInc;    Commands ¬ z.NEW[CommandSeq[newSize]];    Procs ¬ z.NEW[ProcSeq[newSize]];    Helps ¬ z.NEW[HelpSeq[newSize]];    Inline.LongCOPY[      from: oldCommands, nwords: SIZE[CommandSeq[tableSize]], to: Commands];    Inline.LongCOPY[      from: oldProcs, nwords: SIZE[ProcSeq[tableSize]], to: Procs];    Inline.LongCOPY[      from: oldHelps, nwords: SIZE[HelpSeq[tableSize]], to: Helps];    z.FREE[@oldCommands];    z.FREE[@oldProcs];    z.FREE[@oldHelps];    tableSize ¬ newSize;    END;      --Help procedure definitions    EnumerateHelpsPass1: PROC[name: LONG STRING, proc: LD.ListerProc, hProc: LD.HelpProc]     RETURNS [stop: BOOLEAN] =        BEGIN       IF (hProc # NIL) AND (~String.EquivalentString[name, "help"L]) THEN         {[] ¬ hProc[LD.write];          LD.write[CRString]};       RETURN[FALSE];       END;           EnumerateHelpsPass2: PROC[name: LONG STRING, proc: LD.ListerProc, hProc: LD.HelpProc]     RETURNS [stop: BOOLEAN] =        BEGIN         IF (hProc = NIL) AND (~String.EquivalentString[name, "help"L]) THEN           {LD.write[name]; LD.write[": "L];            LD.write[CRString]};       RETURN[FALSE];       END;         HelpHelp: LD.HelpProc =     BEGIN    LD.write["Commands with HELP procedures: "L];    LD.write[CRString];    EnumerateCommands[EnumerateHelpsPass1];    LD.write[CRString];    LD.write["Commands without HELP procedures: "L];    LD.write[CRString];    EnumerateCommands[EnumerateHelpsPass2];    LD.write[CRString];    END;    CallHelp: LD.ListerProc =     BEGIN    lProc : LD.ListerProc;    hProc: LD.HelpProc;        IF CommandUtil.ListLength[argList] = 0 THEN       [] ¬ HelpHelp[LD.write]    ELSE      BEGIN      name: LONG STRING ¬ CommandUtil.GetNth[argList, 0];      [proc: lProc, help: hProc] ¬ LD.LookupCommand[name];      IF hProc # NIL THEN [] ¬ hProc[LD.write]      ELSE	 BEGIN	 LD.write["No command named "];	 LD.write[name];	 END;       END;     LD.write[CRString];     END;        InitListerCommands: PROCEDURE =      BEGIN     AddCommand["Help"L, CallHelp, HelpHelp];     END;        InitListerCommands[];       END.
-- File: ListFGT.mesa - last edit:-- JBD                  4-Mar-87 14:39:05--   MEW	18-Jun-86  9:12:36--   Johnsson,	11-Jun-83 23:45:18--   Rhonda,	 28-Sep-82 10:59:39--   Lewis,	 2-Dec-81 16:40:24--   Loretta,	24-Aug-81 15:13:25--   Bruce,	13-Jan-81 11:03:14-- Copyright (C) 1981, 1982, 1983, 1986 , 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Ascii USING [SP],  BcdDefs USING [Base, ENIndex],  BcdOps USING [BcdBase, ENHandle],  CatchFormat USING [CatchEV, CatchEVHandle, Codebase],  CommandUtil USING [GetNth],  Format USING [NumberFormat],  Heap USING [systemZone],  ListerDefs USING [    AddCommand, all, HelpProc, ListerProc, Load,     OpenOutput, PutSei,     Put, PutBcdID, PutChar, PutCR, PutDecimal, PutNumber, PutOctal,     write],  Symbols USING [BTIndex, BTNull],  SymbolTable USING [Handle];ListFGT: PROGRAM    IMPORTS CommandUtil, Heap, ListerDefs =  BEGIN OPEN LD: ListerDefs;    z: UNCOUNTED ZONE = Heap.systemZone;  sH: SymbolTable.Handle ¬ NIL;  ev: BcdOps.ENHandle ¬ NIL;  catchEntry: CatchFormat.CatchEVHandle ¬ NIL;    NameSeq: TYPE = RECORD[name: SEQUENCE length: CARDINAL OF BodyData];  SortByFirstFG: PROC [na: LONG POINTER TO NameSeq] =    BEGIN    j: INTEGER;    key: BodyData;    FOR i: CARDINAL IN [1..na.length) DO      key ¬ na[i];      j ¬ i - 1;      WHILE j >= 0 AND na[j].firstFG > key.firstFG DO	na[j + 1] ¬ na[j]; j ¬ j - 1; 	ENDLOOP;      na[j + 1] ¬ key;      ENDLOOP;    END;      GenBT: PROC [p: PROC [Symbols.BTIndex]] =    BEGIN    bti, prev: Symbols.BTIndex;    bti ¬ FIRST[Symbols.BTIndex];    DO      p[bti];      IF sH.bb[bti].firstSon # Symbols.BTNull THEN bti ¬ sH.bb[bti].firstSon      ELSE	DO	  prev ¬ bti;	  bti ¬ sH.bb[bti].link.index;	  IF bti = Symbols.BTNull THEN GO TO Done;	  IF sH.bb[prev].link.which # parent THEN EXIT;	  ENDLOOP;      REPEAT Done => NULL;      ENDLOOP;    END;      PrintByColumns: PROC [      PrintOne: PROC [item: CARDINAL, lastOnLine: BOOLEAN],      firstItem, nItems, nColumns, spaceBetween: CARDINAL] =    BEGIN    i, j, nc: CARDINAL;    delta: CARDINAL ¬ (nItems + nColumns - 1)/nColumns;    last: BOOLEAN;    FOR i IN [0..delta) DO      nc ¬ 0;      last ¬ FALSE;      FOR j ¬ i, j + delta WHILE ~last AND j < nItems DO	nc ¬ nc + 1;	last ¬ nc = nColumns;	PrintOne[firstItem + j, last];	IF ~last THEN THROUGH [0..spaceBetween) DO 	  LD.PutChar[Ascii.SP]; 	  ENDLOOP;	ENDLOOP;      LD.PutCR[];      ENDLOOP;    END;      BodyData: TYPE = RECORD [firstFG, lastFG: CARDINAL, bti: Symbols.BTIndex];    lastSource, lastObject, bodyObject: CARDINAL;    PrintFGT: PROC =    BEGIN OPEN Symbols;    cbti: Symbols.BTIndex;    i, n, cfirst, clast: CARDINAL;    na: LONG POINTER TO NameSeq;        countBti: PROC [bti: Symbols.BTIndex] =      BEGIN      WITH sH.bb[bti] SELECT FROM Callable => IF inline THEN RETURN ENDCASE;      n ¬ n + 1;      END;          insertBti: PROC [bti: Symbols.BTIndex] =      BEGIN OPEN sH;      WITH sH.bb[bti] SELECT FROM Callable => IF inline THEN RETURN; ENDCASE;      WITH sH.bb[bti].info SELECT FROM	External => na[i] ¬ [startIndex, startIndex + indexLength - 1, bti];	ENDCASE;      i ¬ i + 1;      END;          PrintBodyLine: PROC [depth: CARDINAL] =      BEGIN      first, last: CARDINAL;      origin: CARDINAL;      bti: Symbols.BTIndex;      [first, last, bti] ¬ na[i];      THROUGH [0..depth*2) DO LD.PutChar[Ascii.SP] ENDLOOP;      LD.Put["  ["L];  LD.PutDecimal[LOOPHOLE[bti]];      LD.Put["] fg: ["L];  LD.PutDecimal[first];      LD.Put[".."L];  LD.PutDecimal[last];      LD.Put["], pc: ["L];      WITH br: sH.bb[bti] SELECT FROM	Callable =>	  BEGIN	  bodyObject ¬ origin ¬ 	    (WITH br SELECT FROM	      Catch   => catchEntry[index],	      ENDCASE => ev.initialPC[br.entryIndex]);	  lastObject ¬ 0;	  lastSource ¬ br.sourceIndex;	  END;	Other => origin ¬ bodyObject + br.relOffset;	ENDCASE;      WITH bi: sH.bb[bti].info SELECT FROM	External =>	  BEGIN	  LD.PutOctal[origin];  LD.Put[".."L];	  LD.PutOctal[origin + bi.bytes - 1];  LD.PutChar[']];	  END;	ENDCASE;      LD.Put[", source: "L];      LD.PutDecimal[sH.bb[bti].sourceIndex];      WITH br: sH.bb[bti] SELECT FROM	Callable => {	  WITH br SELECT FROM	    Catch => {LD.Put[", catchEp: "L];  LD.PutDecimal[index]};	    ENDCASE => {LD.Put[", ep: "L];  LD.PutDecimal[br.entryIndex]}};	Other => {LD.Put[", relO: "L];  LD.PutOctal[br.relOffset]};	ENDCASE;      LD.PutCR[];      i ¬ i + 1;      END;          PrintBodyStuff: PROC [depth: CARDINAL] =      BEGIN      myLast: CARDINAL = na[i].lastFG;      PrintBodyLine[depth];      WHILE i < n AND na[i].firstFG <= myLast DO	PrintBodyStuff[depth + 1]; 	ENDLOOP;      END;          PrintFGEntry: PROC [item: CARDINAL, lastOnLine: BOOLEAN] =      BEGIN      LD.PutNumber[item, decimal5];      LD.Put[": "L];      WITH ff: sH.fgTable[item] SELECT FROM	normal =>	  BEGIN -- 34 chars wide?	  LD.PutNumber[ff.deltaObject, octal3];	  LD.Put[", "L];	  LD.PutNumber[ff.deltaSource, decimal3];	  LD.Put[" = "L];	  LD.PutNumber[absFGT[item - cfirst].object, octal5];	  LD.Put[", "L];	  LD.PutNumber[absFGT[item - cfirst].source, decimal5];	  LD.Put[" ("L];	  LD.PutNumber[absFGT[item - cfirst].object + bodyObject, octal6];	  LD.Put[")"L];	  END;	step =>	  BEGIN	  LD.Put["Step "L];	  IF ff.which = source THEN	    BEGIN	    LD.Put["source:"L];	    LD.PutNumber[ff.delta, decimal5];	    LD.PutChar[Ascii.SP];	    END	  ELSE	    BEGIN	    LD.Put["object:"L];	    LD.PutNumber[ff.delta, octal5];	    END;	  IF ~lastOnLine THEN THROUGH [17..34) DO 	    LD.PutChar[Ascii.SP]; 	    ENDLOOP;	  END;	ENDCASE;      END;          absFGT: LONG POINTER TO AbsFGTSeq;    AbsFGTSeq: TYPE = RECORD[absFGT: SEQUENCE length: CARDINAL OF AbsFGTEntry];    AbsFGTEntry: TYPE = RECORD [object, source: CARDINAL];    GenAbsFGT: PROC =      BEGIN      absFGT ¬ z.NEW[AbsFGTSeq[(clast - cfirst + 1)]];      FOR i: CARDINAL IN [cfirst..clast] DO	WITH ff: sH.fgTable[i] SELECT FROM	  normal =>	    BEGIN	    lastSource ¬ lastSource + ff.deltaSource;	    lastObject ¬ lastObject + ff.deltaObject;	    END;	  step =>	    IF ff.which = source THEN lastSource ¬ lastSource + ff.delta	    ELSE lastObject ¬ lastObject + ff.delta;	  ENDCASE;	absFGT[i - cfirst] ¬ [source: lastSource, object: lastObject];	ENDLOOP;      END;          n ¬ 0;    GenBT[countBti];    na ¬ z.NEW[NameSeq[n]];    i ¬ 0;    GenBT[insertBti];    SortByFirstFG[na];    i ¬ 0;    WHILE i < n DO      [cfirst, clast, cbti] ¬ na[i];      WITH br: sH.bb[cbti] SELECT FROM	Callable =>	  IF ~br.inline THEN	    BEGIN	    WITH br SELECT FROM	      Catch => {	        LD.Put["Catch EP: "L]; 	        LD.PutNumber[index, octal3]};	      ENDCASE => LD.PutSei[sH, br.id];	    LD.PutCR[];	    PrintBodyStuff[0];	    GenAbsFGT[];	    PrintByColumns[	      PrintOne: PrintFGEntry, firstItem: cfirst,	      nItems: clast - cfirst + 1, nColumns: 2, spaceBetween: 2];	    z.FREE[@absFGT];	    LD.PutCR[];	    END;	ENDCASE => ERROR;      ENDLOOP;    z.FREE[@na];    END;      octal3: Format.NumberFormat =    [base: 8, columns: 3, zerofill: FALSE, unsigned: TRUE];  decimal3: Format.NumberFormat =    [base: 10, columns: 3, zerofill: FALSE, unsigned: TRUE];  octal4: Format.NumberFormat =    [base: 8, columns: 4, zerofill: FALSE, unsigned: TRUE];  octal5: Format.NumberFormat =    [base: 8, columns: 5, zerofill: FALSE, unsigned: TRUE];  decimal5: Format.NumberFormat =    [base: 10, columns: 5, zerofill: FALSE, unsigned: TRUE];  octal6: Format.NumberFormat =    [base: 8, columns: 6, zerofill: FALSE, unsigned: TRUE];    FGTable: PROC [root: LONG STRING] = {    defs: BOOLEAN ¬ FALSE;    code: CatchFormat.Codebase;    bcd: BcdOps.BcdBase;    cev: CatchFormat.CatchEV;    [bcd: bcd, sH: sH, code: code] ¬ ListerDefs.Load[root, ListerDefs.all];    ev ¬ @LOOPHOLE[bcd + bcd.enOffset, BcdDefs.Base][BcdDefs.ENIndex.FIRST];        cev ¬ LOOPHOLE[code.header.catchCode/2];    catchEntry ¬ @code[cev];  -- make it an absolute ptr    LD.OpenOutput[root, "fl"L];    LD.PutBcdID[bcd];    IF sH.sourceFile # NIL THEN {      LD.Put["  Source: "L];  LD.Put[sH.sourceFile]; LD.PutCR[]};    PrintFGT[];    };      CallFGTable: LD.ListerProc =     BEGIN    FGTable[CommandUtil.GetNth[argList, 0]];    END;      HelpFGTable: LD.HelpProc =    BEGIN    LD.write["FGTable[""Filename""] "L];    END;      Init: PROC =    BEGIN    LD.AddCommand["FGTable"L, CallFGTable, HelpFGTable];    END;      Init[];    END.
-- File: ListBcd.mesa - last edit:-- JBD                  4-Mar-87 13:31:18--  MEW		18-Jun-86  9:07:23--  Sweet	31-Oct-83 13:43:03--  Johnsson	16-Jun-83 15:02:35--  Rhonda	17-Dec-81 10:37:15--  Lewis	 2-Dec-81 16:24:21--  JGS 	 7-Nov-81 11:43:42--  Loretta	24-Aug-81 15:08:40-- Copyright (C) 1981, 1983, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  BcdDefs USING [    ATIndex, ATNull, ATRecord, Base, Link, CTIndex, CTNull, CTRecord,     ENNull, EXPIndex, EXPRecord, FPIndex, FPRecord, FTIndex, FTNull,     FTRecord, FTSelf, GFIndex, IMPIndex, IMPRecord,     LFNull, MTIndex, MTRecord, Namee, NameRecord, NTIndex,     NTNull, NTRecord, nullLink,SGIndex, SGNull, SpaceID, SPIndex,     SPRecord, TMIndex, TMRecord, TYPIndex, TYPNull, TYPRecord,     unboundLink,VersionID],  BcdDefsExtras,  BcdOps USING [BcdBase, MTHandle, NameString],  CommandUtil USING [    CopyString, FreeString, GetNth, GetNthPair, ListLength],  Environment USING [PageCount, PageNumber],  Format USING [Char, CR, Decimal, NumberFormat, StringProc, Text],  ListerDefs USING [    AddCommand, HelpProc, ListerProc, Load, LoadBcdSegment, NotABcd,     OpenOutput, Put, PutChar, PutCR, PutDecimal, PutIndent, PutMachine,     PutNumber, PutOctal, PutSelf, PutSubString, PutVersionTime, ResetPutProc,     SetPutProc, write],  String USING [AppendString, EquivalentString, StringToNumber, SubStringDescriptor];ListBcd: PROGRAM    IMPORTS CommandUtil, Format, ListerDefs, String EXPORTS ListerDefs =  BEGIN OPEN BD: BcdDefs, ListerDefs;    bcd: BcdOps.BcdBase;    tb:  BD.Base;  ssb: BcdOps.NameString;  ctb: BD.Base;  mtb: BD.Base;  itb: BD.Base;  etb: BD.Base;  enb: BD.Base;  sgb: BD.Base;  ftb: BD.Base;  spb: BD.Base;  ntb: BD.Base;  typb: BD.Base;  tmb: BD.Base;  fpb: BD.Base;  lfb: BD.Base;  atb: BD.Base;  apb: BcdOps.NameString;  InstallBcd: PROC [xbcd: BcdOps.BcdBase] = {    tb ¬ LOOPHOLE[bcd ¬ xbcd];    ssb ¬ tb + bcd.ssOffset;    ctb ¬ tb + bcd.ctOffset;    mtb ¬ tb + bcd.mtOffset;    itb ¬ tb + bcd.impOffset;    etb ¬ tb + bcd.expOffset;    enb ¬ tb + bcd.enOffset;    sgb ¬ tb + bcd.sgOffset;    ftb ¬ tb + bcd.ftOffset;    spb ¬ tb + bcd.spOffset;    ntb ¬ tb + bcd.ntOffset;    typb ¬ tb + bcd.typOffset;    tmb ¬ tb + bcd.tmOffset;    fpb ¬ tb + bcd.fpOffset;    lfb ¬ tb + bcd.lfOffset;    atb ¬ tb + bcd.atOffset;    apb ¬ tb + bcd.apOffset};      PutBcdID: PUBLIC PROC [bcd: BcdOps.BcdBase] =    BEGIN    InstallBcd[bcd];    ListerDefs.PutSelf[bcd];    Put[" Configured "L];    PutVersionTime[bcd.version, full];    IF bcd.sourceFile # BD.FTNull THEN {      Put[" from "L]; PrintFile[bcd.sourceFile]};    PutCR[];    IF bcd.unpackagedFile # BD.FTNull THEN {      Put["  unpackaged file: "L]; PrintFile[bcd.unpackagedFile]; PutCR[]};    IF bcd.versionIdent = BD.VersionID THEN       Put["  Old modules ID"L]    ELSE IF bcd.versionIdent = BcdDefsExtras.GFTVersionID THEN       Put["  New modules ID"L]    ELSE BEGIN      Put["  Bad or obsolete VersionID = "L];      PutDecimal[bcd.versionIdent];      PutCR[];      END;    Put["  Configured by "L];    PutVersionTime[bcd.creator, full];    Put[" "L];    ListerDefs.PutMachine[bcd.creator];    Put[" on "L];    ListerDefs.PutMachine[bcd.version];    PutCR[];  PutCR[];    END;  PrintStamps: PROC =    BEGIN    Put["Imports:"L]; PutCR[]; PutCR[];    FOR impi: BD.IMPIndex ¬ FIRST[BD.IMPIndex], impi + SIZE[BD.IMPRecord]      UNTIL impi = bcd.impLimit DO      IF OutOfRange[impi, bcd.impLimit] THEN        {PrintGarbage[impi, bcd.impLimit]; EXIT};      IF itb[impi].namedInstance THEN	{PutInstanceName[[import[impi]]];  Put[": "L]};      PutName[itb[impi].name];      PutFileStamp[itb[impi].file, itb[impi].name];      ENDLOOP;    PutCR[];    Put["Exports:"L]; PutCR[]; PutCR[];    FOR expi: BD.EXPIndex ¬ FIRST[BD.EXPIndex],       expi + etb[expi].size * SIZE[BD.Link] + SIZE[BD.EXPRecord]      UNTIL expi = bcd.expLimit DO      IF OutOfRange[expi, bcd.expLimit] THEN        {PrintGarbage[expi, bcd.expLimit]; EXIT};      IF etb[expi].namedInstance THEN	{PutInstanceName[[export[expi]]];  Put[": "L]};      PutName[etb[expi].name];      PutFileStamp[etb[expi].file, etb[expi].name];      ENDLOOP;    PutCR[];    Put["Modules:"L]; PutCR[]; PutCR[];    FOR mti: BD.MTIndex ¬ FIRST[BD.MTIndex], mti + SIZE[BD.MTRecord]      UNTIL mti = bcd.mtLimit DO      IF OutOfRange[mti, bcd.mtLimit] THEN        {PrintGarbage[mti, bcd.mtLimit]; EXIT};      IF mtb[mti].namedInstance THEN {        PutInstanceName[[module[mti]]];  Put[": "L]};      PutName[mtb[mti].name];      PutFileStamp[mtb[mti].file, mtb[mti].name];      ENDLOOP;    END;      PutFileStamp: PROC [fti: BD.FTIndex, mName: BD.NameRecord] =    BEGIN    SELECT fti FROM      BD.FTNull => Put["(null)"L];      BD.FTSelf => Put["(self)"L];      ENDCASE =>	BEGIN	IF ftb[fti].name # mName THEN {Put[", file: "L];  PutName[ftb[fti].name]};	Put[", time: "L];	PutVersionTime[ftb[fti].version, full];	Put[", machine: "L];	ListerDefs.PutMachine[ftb[fti].version];	END;    PutCR[];    END;      PrintBcd: PROC =    BEGIN    PrintHeader[];    PrintConfigs[];    PrintImports[];    PrintExports[];    PrintModules[];    PrintFiles[];    PrintFramePacks[];    PrintSpaces[];    PrintAtoms[];    PrintTypes[];    END;      PrintHeader: PROC =    BEGIN    Put["Configurations: "L];  PutDecimal[bcd.nConfigs];    Put[", Modules: "L];  PutDecimal[bcd.nModules];    Put[", Imports: "L];  PutDecimal[bcd.nImports];    Put[", Exports: "L];  PutDecimal[bcd.nExports];    Put[", Dummy: "L];  PutDecimal[bcd.firstdummy];    Put[", #Dummies: "L];  PutDecimal[bcd.nDummies];    PutCR[];    IF ~bcd.definitions THEN PutChar['~];      Put["definitions, "L];    IF ~bcd.repackaged THEN PutChar['~];      Put["repackaged, "L];    IF ~bcd.typeExported THEN PutChar['~];      Put["type exported, "L];    IF ~bcd.tableCompiled THEN PutChar['~];      Put["table compiled, "L];    IF bcd.spare # ALL[FALSE] THEN {      FOR i: CARDINAL IN [0..LENGTH[bcd.spare]) DO        IF bcd.spare[i] THEN {Put["spare["L]; PutDecimal[i]; Put["], "L]};	ENDLOOP};    PutCR[];    PutCR[];    END;      PrintConfigs: PROC =    BEGIN    Put["Configurations"L];    PrintIndex[bcd.ctOffset];    PutChar[':];    PutCR[];    FOR cti: BD.CTIndex ¬ FIRST[BD.CTIndex],      cti + SIZE[BD.CTRecord] + ctb[cti].nControls * SIZE[BD.Namee]      UNTIL cti = bcd.ctLimit DO      IF OutOfRange[cti, bcd.ctLimit] THEN        {PrintGarbage[cti, bcd.ctLimit]; EXIT};      PrintConfig[cti];      ENDLOOP;    PutCR[];    END;      PrintConfig: PROC [cti: BD.CTIndex] =    BEGIN OPEN ctb[cti];    Tab[2];    PutName[name];    PrintIndex[cti];    IF namedInstance THEN      {Put[", instance name: "L];  PutInstanceName[[config[cti]]]};    Put[", file: "L];    PrintFileName[file];    PrintIndex[file];    IF config # BD.CTNull THEN      BEGIN      Put[", parent: "L];      PutName[ctb[config].name];      PrintIndex[config];      END;    Put[", #controls: "L];    PutDecimal[nControls];    IF nControls # 0 THEN      BEGIN      Put[", controls:"L];      FOR i: CARDINAL IN [0..nControls) DO	Tab[6];	WITH c: controls[i] SELECT FROM	  config => {	    Put["config "L];  PutName[ctb[c.cti].name];	    PrintIndex[c.cti]};	  module => {	    Put["module "L];  PutName[mtb[c.mti].name];	    PrintIndex[c.mti]};	  ENDCASE => Put["? Garbage (neither config nor module)"];  	ENDLOOP;      END;    PutCR[];    END;      PrintImports: PROC =    BEGIN    Put["Imports"L];    PrintIndex[bcd.impOffset];    PutChar[':];    PutCR[];    FOR impi: BD.IMPIndex ¬ FIRST[BD.IMPIndex], impi + SIZE[BD.IMPRecord]      UNTIL impi = bcd.impLimit DO      IF OutOfRange[impi, bcd.impLimit] THEN        {PrintGarbage[impi, bcd.impLimit]; EXIT};      PrintImport[impi];      ENDLOOP;    PutCR[];    PutCR[];    END;      PrintImport: PROC [impi: BD.IMPIndex] =    BEGIN OPEN itb[impi];    Tab[2];    PutName[name];    PrintIndex[impi];    IF port = module THEN Put[" (module)"L];    IF namedInstance THEN      {Put[", instance name: "L];  PutInstanceName[[import[impi]]]};    Put[", file: "L];    PrintFileName[file];    PrintIndex[file];    Put[", gfi: "L];  PutDecimal[gfi];    END;      PrintExports: PROC =    BEGIN    Put["Exports"L];    PrintIndex[bcd.expOffset];    PutChar[':];    PutCR[];    FOR expi: BD.EXPIndex ¬ FIRST[BD.EXPIndex],      expi + SIZE[BD.EXPRecord] + etb[expi].size * SIZE[BD.Link]      UNTIL expi = bcd.expLimit DO      IF OutOfRange[expi, bcd.expLimit] THEN        {PrintGarbage[expi, bcd.expLimit]; EXIT};      PrintExport[expi];      ENDLOOP;    IF ~DumpLinks THEN PutCR[];    PutCR[];    END;      PrintExport: PROC [expi: BD.EXPIndex] =    BEGIN OPEN etb[expi];    Tab[2];    PutName[name];    PrintIndex[expi];    IF port = module THEN Put[" (module)"L];    IF namedInstance THEN      {Put[", instance name: "L];  PutInstanceName[[export[expi]]]};    Put[", file: "L];    PrintFileName[file];    PrintIndex[file];    Put[", "L];     IF ~typeExported THEN PutChar['~];      Put["typeExported"L];    Put[", #links: "L];  PutDecimal[size];    IF DumpLinks THEN      BEGIN      Put[", links:"L];      FOR i: CARDINAL IN [0..size) DO	IF i MOD 4 = 0 THEN Tab[4] ELSE PutChar[' ];	PrintControlLink[links[i]];	IF i + 1 # size THEN PutChar[',];	ENDLOOP;      PutCR[];      END;    END;      PrintSpaces: PROC =    BEGIN    Put["Spaces:"L];    PutCR[];    FOR spi: BD.SPIndex ¬ FIRST[BD.SPIndex],      spi + SIZE[BD.SPRecord] + spb[spi].length*SIZE[BD.SpaceID]      UNTIL spi = bcd.spLimit DO      IF OutOfRange[spi, bcd.spLimit] THEN        {PrintGarbage[spi, bcd.spLimit]; EXIT};      PrintSpace[spi];      ENDLOOP;    PutCR[];    END;      PrintSpace: PROC [spi: BD.SPIndex] =    BEGIN OPEN spb[spi];    Tab[2];    PutName[name];    PrintIndex[spi];    Put[", segment: "L];  PrintIndex[seg];    Put[", #code packs: "L];  PutDecimal[length];    IF length # 0 THEN Put[", code packs: "L];    FOR i: CARDINAL IN [0..length) DO      Tab[4];      Put["  code pack "L];  PutName[spaces[i].name];      Put[", "L];      IF ~spaces[i].resident THEN PutChar['~];      Put["resident, offset: "L];      PutOctal[spaces[i].offset];      Put[", pages: "L];      PutDecimal[spaces[i].pages];      PutCR[];      ENDLOOP;    END;      PrintModules: PROC =    BEGIN    Put["Modules"L];    PrintIndex[bcd.mtOffset];    PutChar[':];    PutCR[];    FOR mti: BD.MTIndex ¬ FIRST[BD.MTIndex], mti + SIZE[BD.MTRecord]      UNTIL mti = bcd.mtLimit DO      IF OutOfRange[mti, bcd.mtLimit] THEN        {PrintGarbage[mti, bcd.mtLimit]; EXIT};      PrintModule[@mtb[mti], mti];      ENDLOOP;    PutCR[];    END;      GfiForMti: PROC [mti: BD.MTIndex] RETURNS [BD.GFIndex] = INLINE {    RETURN[LOOPHOLE[mti,CARDINAL]/SIZE[BD.MTRecord]+1]};   PrintModule: PROC [mth: BcdOps.MTHandle, mti: BD.MTIndex] =    BEGIN OPEN mth;    Tab[2];    PutName[name];    PrintIndex[mti];    Put[", gfi: "L]; PutDecimal[GfiForMti[mti]];    IF namedInstance THEN      {Put["instance name: "L];  PutInstanceName[[module[mti]]]};    Put[", file: "L];    PrintFileName[file];    PrintIndex[file];    IF config # BD.CTNull THEN      BEGIN      Put[", config: "L];      PutName[ctb[config].name];      PrintIndex[config];      END;    Tab[4];    IF ~tableCompiled THEN PutChar['~];      Put["table compiled, "L];    IF ~packageable THEN PutChar['~];      Put["packageable, "L];    IF ~residentFrame THEN PutChar['~];      Put["resident frame, "L];    IF ~initial THEN PutChar['~];      Put["initial"L];    Tab[4];    IF ~boundsChecks THEN PutChar['~];      Put["bounds cks, "L];    IF ~nilChecks THEN PutChar['~];      Put["nil cks, "L];    IF ~crossJumped THEN PutChar['~];      Put["cross jumped"L];    IF spare[0] THEN Put[",  New module"L]    ELSE Put[",  Old module"L];    IF spare # BcdDefsExtras.OldMesaModule AND spare # BcdDefsExtras.NewMesaModule THEN {      Tab[4];      FOR i: CARDINAL IN [1..LENGTH[spare]) DO        IF spare[i] THEN {Put["spare["L]; PutDecimal[i]; Put["], "L]};	ENDLOOP};    Tab[4];    Put["framesize: "L];  PutDecimal[framesize];    Put[", linkLoc: "L];      Put[SELECT linkLoc FROM      frame   => "frame"L,       code    => "code"L,      ENDCASE => "dontcare"L];    Tab[4];    Put["code: "L];  PrintSegment[code.sgi];    Put[", offset: "L];  PutOctal[code.offset];    Put[", length: "L];  PutOctal[code.length];    IF linkspace THEN Put[", link space available"L];    IF packed THEN Put[", packed"L];    Tab[4];    Put["symbols: "L];  PrintSegment[sseg];    IF mth.links # BD.LFNull THEN {      OPEN indirectExt: lfb[mth.links];      Tab[4]; Put["Links: "L]; PrintIndex[mth.links];      Put[", number of links: "L];      PutDecimal[indirectExt.length];      IF DumpLinks THEN         FOR i: CARDINAL IN [0..indirectExt.length) DO          IF i # 0 THEN PutChar[',];          IF i MOD 4 = 0 THEN Tab[6] ELSE PutChar[' ];          PrintControlLink[indirectExt.frag[i]];          ENDLOOP};    IF mth.entries # BD.ENNull THEN {      OPEN en: enb[mth.entries];      Tab[4]; Put["Entries: "L]; PrintIndex[mth.entries];      Put[", number of entries: "L];      PutDecimal[en.nEntries];      IF DumpLinks THEN {        fmt: Format.NumberFormat =          [base: 8, unsigned: TRUE, zerofill: FALSE, columns: 6];        FOR i: CARDINAL IN [0..en.nEntries) DO          IF i # 0 THEN PutChar[',];          IF i MOD 8 = 0 THEN Tab[6] ELSE PutChar[' ];          PutNumber[en.initialPC[i], fmt];          ENDLOOP};	PutCR[]};    IF mth.atoms # BD.ATNull THEN {      Tab[4]; Put["Atoms: L"]; PrintIndex[mth.atoms]};    END;      PrintFramePacks: PROC =    BEGIN    Put["Frame Packs:"L];    PutCR[];    FOR fpi: BD.FPIndex ¬ FIRST[BD.FPIndex],      fpi + SIZE[BD.FPRecord] + fpb[fpi].length*SIZE[BD.MTIndex]      UNTIL fpi = bcd.fpLimit DO      IF OutOfRange[fpi, bcd.fpLimit] THEN        {PrintGarbage[fpi, bcd.fpLimit]; EXIT};      PrintFramePack[fpi];      ENDLOOP;    PutCR[];    END;      PrintFramePack: PROC [fpi: BD.FPIndex] =    BEGIN OPEN fpb[fpi];    Tab[2];    PutName[name];    PrintIndex[fpi];    Put[", #modules: "L];    PutDecimal[length];    Put[", modules:"L];    PutCR[];    FOR i: CARDINAL IN [0..length) DO      IF i # 0 THEN PutChar[',];      IF i MOD 4 = 0 THEN Tab[4] ELSE PutChar[' ];      PutName[mtb[modules[i]].name];      PrintIndex[modules[i]];      ENDLOOP;    PutCR[];    END;      PrintTypes: PROC =    BEGIN    Put["Type Table:"L];    PutCR[];    FOR typi: BD.TYPIndex ¬ FIRST[BD.TYPIndex], typi + SIZE[BD.TYPRecord]      UNTIL typi = bcd.typLimit DO      IF OutOfRange[typi, bcd.typLimit] THEN        {PrintGarbage[typi, bcd.typLimit]; EXIT};      PrintType[typi];      ENDLOOP;    PutCR[];    Put["Type Map Table:"L];    PutCR[];    FOR tmi: BD.TMIndex ¬ FIRST[BD.TMIndex], tmi + SIZE[BD.TMRecord]      UNTIL tmi = bcd.tmLimit DO      IF OutOfRange[tmi, bcd.tmLimit] THEN        {PrintGarbage[tmi, bcd.tmLimit]; EXIT};      PrintTypeMap[tmi];      ENDLOOP;    PutCR[];    END;      PrintType: PROC [typi: BD.TYPIndex] =    BEGIN    Tab[2];    PrintIndex[typi];    Put[": version: [time: "L];    PutVersionTime[typb[typi].version, full];    Put[", machine: "L];    ListerDefs.PutMachine[typb[typi].version];    Put["], id: "L];    PutOctal[typb[typi].id];    PutCR[];    END;      PrintTypeMap: PROC [tmi: BD.TMIndex] =    BEGIN    Tab[2];    PrintIndex[tmi];    Put[": version: [time: "L];    PutVersionTime[tmb[tmi].version, full];    Put[", machine: "L];    ListerDefs.PutMachine[tmb[tmi].version];    Put["], offset: "L];    PutOctal[tmb[tmi].offset];    Put[", map: "L];    PutOctal[tmb[tmi].map];    PutCR[];    END;      PrintSegment: PROC [sgi: BD.SGIndex] =    BEGIN    IF sgi = BD.SGNull THEN Put["(null)"L]    ELSE      BEGIN      PrintFileName[sgb[sgi].file];      Put[" [base: "L];  PutDecimal[sgb[sgi].base];      Put[", pages: "L];  PutDecimal[sgb[sgi].pages];      IF sgb[sgi].extraPages # 0 THEN {        PutChar['+];  PutDecimal[sgb[sgi].extraPages]};      PutChar[']];      END;    END;      PrintFiles: PROC =    BEGIN    Put["Files"L];    PrintIndex[bcd.ftOffset];    PutChar[':];    PutCR[];    FOR fti: BD.FTIndex ¬ FIRST[BD.FTIndex], fti + SIZE[BD.FTRecord]      UNTIL fti = bcd.ftLimit DO      IF OutOfRange[fti, bcd.ftLimit] THEN EXIT;      PrintFile[fti];      ENDLOOP;    PutCR[];    PutCR[];    END;      PrintFile: PROC [fti: BD.FTIndex] =    BEGIN OPEN ftb[fti];    Tab[2];    SELECT fti FROM      BD.FTNull => Put["(null)"L];      BD.FTSelf => Put["(self)"L];      ENDCASE =>	IF OutOfRange[fti, bcd.ftLimit] THEN PrintGarbage[fti, bcd.ftLimit]	ELSE {	  PutName[ftb[fti].name];	  PrintIndex[fti];	  Put[", time: "L];	  PutVersionTime[ftb[fti].version, full];	  Put[", machine: "L];	  ListerDefs.PutMachine[ftb[fti].version];	  };    END;      PrintAtoms: PROC =    BEGIN    Put["Atoms:"L];    PutCR[];    FOR ati: BD.ATIndex ¬ FIRST[BD.ATIndex],      ati + SIZE[BD.ATRecord[atb[ati].nAtoms]]      UNTIL ati = bcd.atLimit DO      IF OutOfRange[ati, bcd.atLimit] THEN         {PrintGarbage[ati, bcd.atLimit]; EXIT};      PrintAtom[ati];      ENDLOOP;    PutCR[];    END;  PrintAtom: PROC [ati: BD.ATIndex] = {    OPEN atb[ati];    Tab[2];    PrintIndex[ati];    Put[", nAtoms: "L]; PutDecimal[nAtoms];    Put[", offset: "L]; PutDecimal[offset];    FOR i: CARDINAL IN [0..nAtoms) DO      IF bcd.apLimit # 0 THEN {   -- must be some printnames	ssd: String.SubStringDescriptor ¬ [	  base: @apb.string, offset: atom[i], length: apb.size[atom[i]]];	Tab[4]; PutSubString[@ssd] }      ELSE {  -- Must be bogus atoms put in by the C software        Tab[4]; PutDecimal[atom[i]]}      ENDLOOP};  -- Utilities    OutOfRange: PROCEDURE [index, limit: BD.Base RELATIVE POINTER]    RETURNS [BOOLEAN] = INLINE {RETURN[      LOOPHOLE[index, BD.Base RELATIVE ORDERED POINTER] >      LOOPHOLE[limit, BD.Base RELATIVE ORDERED POINTER]]};    -- Utility Prints    PrintControlLink: PROC [link: BD.Link, width: CARDINAL ¬ 16] =    BEGIN    linkString: STRING = [20];    w: Format.StringProc = {String.AppendString[linkString, s]};    SELECT TRUE FROM      (link = BD.nullLink) => Format.Text[w, "[null]"L];      (link = BD.unboundLink) => Format.Text[w, "[unbound]"L];      ENDCASE => WITH l: link SELECT FROM      procedure =>  	BEGIN	Format.Text[w, "proc["L];          Format.Decimal[w, l.gfi];  Format.Char[w, ',];  Format.Decimal[w, l.ep];  	Format.Char[w, ']];	END;      signal =>  	BEGIN	Format.Text[w, "sig["L];          Format.Decimal[w, l.gfi];  Format.Char[w, ',];  Format.Decimal[w, l.index];  	Format.Char[w, ']];	END;      variable =>  	BEGIN	Format.Text[w, "var["L];	Format.Decimal[w, l.gfi]; Format.Char[w, ',]; Format.Decimal[w, l.offset];	Format.Char[w, ']];	END;      type =>  	BEGIN	Format.Text[w, "type["L];  	IF l.typeID = BD.TYPNull THEN Format.Text[w, "null"L] 	ELSE Format.Decimal[w, LOOPHOLE[l.typeID]];        Format.Char[w, ']];	END;      ENDCASE;    IF linkString.length < width THEN      FOR i: CARDINAL IN [0..width-linkString.length) DO PutChar[' ] ENDLOOP;    Put[linkString];    END;      PrintFileName: PROC [fti: BD.FTIndex] =    BEGIN    SELECT fti FROM      BD.FTNull => Put["(null)"L];      BD.FTSelf => Put["(self)"L];      ENDCASE => PutName[ftb[fti].name];    END;      PrintIndex: PROC [index: UNSPECIFIED] = {    Put[" ["L];  PutDecimal[index];      PutChar[']]};      PrintGarbage: PROC [index, limit: BD.Base RELATIVE POINTER] =    BEGIN    Put[" [Seems to be garbage: Index"]; PrintIndex[index];    Put[" is beyond the limit:"]; PrintIndex[limit];    PutChar[']];    END;      PrintAnonName: PROC = {Put[" (anon) "L]};        -- Utility Puts    PutName: PROC [n: BD.NameRecord] =    BEGIN    ssd: String.SubStringDescriptor ¬      [base: @ssb.string, offset: n, length: MIN[ssb.size[n], 100]];    PutSubString[@ssd];    END;      Tab: PROC [n: CARDINAL] = INLINE {ListerDefs.PutIndent[n]};      PutInstanceName: PROC [n: BD.Namee] =    BEGIN        FindName: PROC [ntb: BD.Base, nti: BD.NTIndex] RETURNS [stop: BOOLEAN] =      {RETURN[ntb[nti].item = n]};          nti: BD.NTIndex ¬ EnumerateNameTable[FindName];    IF nti = BD.NTNull THEN PrintAnonName[] ELSE PutName[ntb[nti].name];    END;      EnumerateNameTable: PROC [proc: PROC [BD.Base, BD.NTIndex] RETURNS [BOOLEAN]]    RETURNS [nti: BD.NTIndex] =    BEGIN    FOR nti ¬ FIRST[BD.NTIndex], nti + SIZE[BD.NTRecord]      UNTIL nti = bcd.ntLimit DO      IF OutOfRange[nti, bcd.ntLimit] THEN        {PrintGarbage[nti, bcd.ntLimit]; EXIT};      IF proc[ntb, nti] THEN RETURN[nti];       ENDLOOP;    RETURN[BD.NTNull];    END;      Version: PROC [root:  LONG STRING] = {    [bcd: bcd] ¬ ListerDefs.Load[root !      ListerDefs.NotABcd => {	ListerDefs.write["Warning: File "];	ListerDefs.write[name];	ListerDefs.write[" does not appear to be a bcd"];	RESUME}];    Format.CR[ListerDefs.write];    ListerDefs.SetPutProc[ListerDefs.write];    PutBcdID[bcd]; -- calls InstallBcd    ListerDefs.ResetPutProc[];    };      Stamps: PROC [root: LONG STRING] = {    bcd ¬ ListerDefs.Load[root].bcd;    ListerDefs.OpenOutput[root, "bl"L];    PutBcdID[bcd]; -- calls InstallBcd    PrintStamps[];    };      Files: PROC [root: LONG STRING] = {    bcd ¬ ListerDefs.Load[root].bcd;    ListerDefs.OpenOutput[root, "bl"L];    PutBcdID[bcd]; -- calls InstallBcd    PrintFiles[];    };      Bcd: PROC [root: LONG STRING] = {    bcd ¬ ListerDefs.Load[root].bcd;    ListerDefs.OpenOutput[root, "bl"L];    PutBcdID[bcd]; -- calls InstallBcd    PrintBcd[];    };          BcdLinks: PROC [root: LONG STRING] = {    DumpLinks ¬ TRUE;      Bcd[root];      DumpLinks ¬ FALSE};      BcdSegment: PROC [      root: LONG STRING,      base: Environment.PageNumber, pages: Environment.PageCount,      links: BOOLEAN] = {    bcd ¬ ListerDefs.LoadBcdSegment[root, base, pages].bcd;    ListerDefs.OpenOutput[root, "bl"L];    PutBcdID[bcd]; -- calls InstallBcd    PrintBcd[];    DumpLinks ¬ FALSE;    };      DumpLinks: BOOLEAN ¬ FALSE;    CallBcd: ListerDefs.ListerProc =     BEGIN     Bcd[CommandUtil.GetNth[argList, 0]];    END;      HelpBcd: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["Bcd[""Filename""] "L];    END;  CallBcdLinks: ListerDefs.ListerProc =     BEGIN     BcdLinks[CommandUtil.GetNth[argList, 0]];    END;      HelpBcdLinks: ListerDefs.HelpProc =     BEGIN    ListerDefs.write["BcdLinks[""Filename""] "L];    END;      CallVersion: ListerDefs.ListerProc =     BEGIN     Version[CommandUtil.GetNth[argList, 0]];    END;      HelpVersion: ListerDefs.HelpProc =     BEGIN    ListerDefs.write["Version[""Filename""] "L];    END;    CallStamps: ListerDefs.ListerProc =     BEGIN     Stamps[CommandUtil.GetNth[argList, 0]];    END;      HelpStamps: ListerDefs.HelpProc =     BEGIN    ListerDefs.write["Stamps[""Filename""] "L];    END;    CallFiles: ListerDefs.ListerProc =     BEGIN     Files[CommandUtil.GetNth[argList, 0]];    END;       HelpFiles: ListerDefs.HelpProc =     BEGIN    ListerDefs.write["Files[""Filename""] "L];    END;     CallBcdSegment: ListerDefs.ListerProc =     BEGIN OPEN CommandUtil;    filename, key, value: LONG STRING ¬ NIL;    bases, pages: INTEGER ¬ -1;    links: BOOLEAN ¬ FALSE;    FOR i: CARDINAL IN [0..ListLength[argList]) DO      ENABLE UNWIND => filename ¬ FreeString[filename];      [key, value] ¬ GetNthPair[argList, i];      SELECT TRUE FROM	 String.EquivalentString[key, "FileName"L] => 	   filename ¬ CopyString[value];	 String.EquivalentString[key, "Bases"L] => 	   bases ¬ String.StringToNumber[value];	 String.EquivalentString[key, "Pages"L] => 	   pages ¬ String.StringToNumber[value];	 String.EquivalentString[key, "Links"L] =>            links ¬ IF String.EquivalentString[value, "TRUE"L] THEN TRUE ELSE FALSE;	 ENDCASE =>	   SELECT i FROM	     0 --FileName-- => filename ¬ CopyString[value];	     1 --Bases-- =>    bases ¬ String.StringToNumber[value];	     2 --Pages-- =>    pages ¬ String.StringToNumber[value];	     3 --Links-- =>    	       links ¬ (IF String.EquivalentString[value, "TRUE"L]	                 THEN TRUE	                 ELSE FALSE);	     ENDCASE;      ENDLOOP;    SELECT TRUE FROM      filename = NIL => {        ListerDefs.write["No FileName parameter."L]; outcome ¬ error};      bases = -1 => {        ListerDefs.write["No Bases parameter."L]; outcome ¬ error};      pages = -1 => {        ListerDefs.write["No Pages parameter."L]; outcome ¬ error};      ENDCASE =>         BcdSegment[filename, bases, pages, links 	  ! UNWIND => filename ¬ FreeString[filename]];    filename ¬ FreeString[filename];    END;      HelpBcdSegment: ListerDefs.HelpProc =    BEGIN    ListerDefs.write["BcdSegment[""Filename"", Base, Pages, Links] "L];    END;        Init: PROC =    BEGIN    ListerDefs.AddCommand["Bcd"L, CallBcd, HelpBcd];    ListerDefs.AddCommand["BcdLinks"L, CallBcdLinks, HelpBcdLinks];    ListerDefs.AddCommand["Version"L, CallVersion, HelpVersion];    ListerDefs.AddCommand["Stamps"L, CallStamps, HelpStamps];    ListerDefs.AddCommand["Files"L, CallFiles, HelpFiles];    ListerDefs.AddCommand["BcdSegment"L, CallBcdSegment, HelpBcdSegment];    END;     Init[];    END.
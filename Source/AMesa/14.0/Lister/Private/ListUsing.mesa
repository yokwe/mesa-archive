-- File: ListUsing.mesa - last edit:-- JBD                  3-Mar-87 10:14:58-- modified by MEW,	23-Jan-86  8:31:42-- modified by Rhonda,	 4-Oct-82 14:10:39 -- modified by Lewis,	15-Jun-82 11:00:54-- modified by Loretta,	24-Aug-81 15:16:28-- modified by Bruce,	13-Jan-81 11:05:04-- modified by Sweet,	May 16, 1980  9:37 AM-- Copyright (C) 1981, 1982, 1983, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Ascii USING [SP, CR, NUL],  BcdOps USING [BcdBase],  CommandUtil USING [GetNth],  Format USING [Line],  Heap USING [Create, Delete, Error, Expand],  ListerDefs USING [    AddCommand, CloseOutput, HelpProc, ListerProc, Load, NextNameInList,     noCode, NoFGT, OpenFileList, OpenOutput, out, Put,    PutBcdID, PutChar, PutCR, PutSubString, ReleaseSymbols, write],  MFile USING [CopyFileHandle, Handle, ReleaseData, SetAccess],  MStream USING [Create, GetFile, Handle, ReleaseData],  Stream USING [EndOfStream],  String USING [    AppendChar, AppendString, EquivalentSubStrings, SubString,    SubStringDescriptor, UpperCase],  SymbolOps USING [FirstCtxSe, NextSe, SubStringForHash, UnderType],  Symbols USING [BTIndex, CTXIndex, HTIndex, ISEIndex, ISENull, MDIndex, SENull],  SymbolTable USING [Handle];ListUsing: PROGRAM  IMPORTS    CommandUtil, Format, Heap, ListerDefs, MFile, MStream, Stream,    String, SymbolOps =  BEGIN OPEN ListerDefs, Symbols;  sH: SymbolTable.Handle;  myHeap: UNCOUNTED ZONE ¬ NIL;  InitHeap: PROCEDURE = {    IF myHeap = NIL THEN      myHeap ¬ Heap.Create[initial: 10, increment: 10, swapUnitSize: 10]};  EraseHeap: PROCEDURE = {    IF myHeap # NIL THEN {Heap.Delete[myHeap]; myHeap ¬ NIL}};  AllocString: PROCEDURE [nchars: CARDINAL] RETURNS [s: LONG STRING] =    BEGIN    s ¬ myHeap.NEW[      StringBody [nchars] !      Heap.Error =>        IF type = insufficientSpace THEN {Heap.Expand[myHeap, 10]; RETRY}]    END;  FreeString: PROCEDURE [s: LONG STRING] = {myHeap.FREE[@s]};  StringCompare: PROCEDURE [s1, s2: LONG STRING] RETURNS [INTEGER] =    BEGIN    i: CARDINAL;    c1, c2: CHARACTER;    FOR i IN [0..MIN[s1.length, s2.length]) DO      c1 ¬ String.UpperCase[s1[i]];      c2 ¬ String.UpperCase[s2[i]];      IF c1 < c2 THEN RETURN[-1];      IF c1 > c2 THEN RETURN[1];      ENDLOOP;    RETURN[      SELECT TRUE FROM        s1.length < s2.length => -1,        s1.length > s2.length => 1,        ENDCASE => 0]    END;  CompareNames: PROCEDURE [n1, n2: String.SubString] RETURNS [INTEGER] =    BEGIN    i: CARDINAL;    c1, c2: CHARACTER;    FOR i IN [0..MIN[n1.length, n2.length]) DO      c1 ¬ String.UpperCase[n1.base[n1.offset + i]];      c2 ¬ String.UpperCase[n2.base[n2.offset + i]];      SELECT c1 - c2 FROM < 0 => RETURN[-1]; > 0 => RETURN[1]; ENDCASE;      ENDLOOP;    SELECT INTEGER[n1.length - n2.length] FROM      < 0 => RETURN[-1];      > 0 => RETURN[1];      ENDCASE => RETURN[0];    END;  NameSeq: TYPE = RECORD [name: SEQUENCE length: CARDINAL OF String.SubStringDescriptor];  SortNames: PROCEDURE [na: LONG POINTER TO NameSeq] =    BEGIN    i: CARDINAL;    j: INTEGER;    key: String.SubStringDescriptor;    FOR i IN [1..na.length) DO      key ¬ na[i];      j ¬ i - 1;      WHILE j >= 0 AND CompareNames[@na[j], @key] > 0 DO        temp: CARDINAL = j + 1; na[temp] ¬ na[j]; j ¬ j - 1; ENDLOOP;      j ¬ j + 1;      na[j] ¬ key;      ENDLOOP;    END;  GenCtx: PROCEDURE [ctx: Symbols.CTXIndex, p: PROCEDURE [Symbols.ISEIndex]] =    BEGIN    FOR sei: Symbols.ISEIndex ¬ SymbolOps.FirstCtxSe[sH, ctx], SymbolOps.NextSe[      sH, sei] UNTIL sei = SENull DO p[sei]; ENDLOOP;    END;  PrintUsing: PROCEDURE =    BEGIN    bti: BTIndex;    ctx: CTXIndex;    sei: ISEIndex;    hti: HTIndex;    mdi: MDIndex;    i, n, idir, ndir: CARDINAL;    first: BOOLEAN ¬ TRUE;    desc: String.SubStringDescriptor;    modname: String.SubString = @desc;    desc2: String.SubStringDescriptor;    filename: String.SubString = @desc2;    mname: String.SubString;    DirRec: TYPE = RECORD [dirname: String.SubStringDescriptor, dirsei: ISEIndex];    DirSeq: TYPE = RECORD [dir: SEQUENCE length: CARDINAL OF DirRec];    da: LONG POINTER TO DirSeq;    na: LONG POINTER TO NameSeq;    firstCopiedHash: Symbols.HTIndex;    countids: PROCEDURE [sei: ISEIndex] =      BEGIN IF sH.seb[sei].hash < firstCopiedHash THEN n ¬ n + 1; END;    insertid: PROCEDURE [sei: ISEIndex] =      BEGIN      IF sH.seb[sei].hash < firstCopiedHash THEN {        ss: String.SubStringDescriptor;        SymbolOps.SubStringForHash[sH, @ss, sH.seb[sei].hash];        na[i] ¬ ss;        i ¬ i + 1};      END;    PutCR[];    FOR hti IN (0..LENGTH[sH.ht]) DO      IF sH.ht[hti].ssIndex = sH.ht[hti - 1].ssIndex THEN {        firstCopiedHash ¬ hti; EXIT};      REPEAT FINISHED => firstCopiedHash ¬ LENGTH[sH.ht];      ENDLOOP;    ndir ¬ 0;    FOR sei ¬ SymbolOps.FirstCtxSe[sH, sH.stHandle.directoryCtx],      SymbolOps.NextSe[sH, sei] UNTIL sei = ISENull DO ndir ¬ ndir + 1; ENDLOOP;    IF ndir = 0 THEN RETURN;    da ¬ myHeap.NEW[DirSeq[ndir]];    ndir ¬ 0;    FOR sei ¬ SymbolOps.FirstCtxSe[sH, sH.stHandle.directoryCtx],      SymbolOps.NextSe[sH, sei] UNTIL sei = ISENull DO      i: INTEGER ¬ (ndir - 1);      SymbolOps.SubStringForHash[sH, LOOPHOLE[modname], sH.seb[sei].hash];      WHILE i >= 0 AND CompareNames[@da[i].dirname, modname] > 0 DO        da[i + 1] ¬ da[i]; i ¬ i - 1; ENDLOOP;      i ¬ i + 1;  -- for compiler      da[i] ¬ [modname­, sei];      ndir ¬ ndir + 1;      ENDLOOP;    FOR idir IN [0..ndir) DO      mname ¬ @da[idir].dirname;      sei ¬ da[idir].dirsei;      WITH sH.seb[SymbolOps.UnderType[sH, sH.seb[sei].idType]] SELECT FROM        definition => {          isei: ISEIndex;          ctx ¬ defCtx;          FOR isei ¬ SymbolOps.FirstCtxSe[sH, sH.stHandle.importCtx],            SymbolOps.NextSe[sH, isei] UNTIL isei = ISENull DO            WITH sH.seb[SymbolOps.UnderType[sH, sH.seb[isei].idType]] SELECT FROM              definition =>                WITH sH.ctxb[defCtx] SELECT FROM                  imported => IF includeLink = ctx THEN {ctx ¬ defCtx; EXIT};                  ENDCASE;              ENDCASE;            ENDLOOP};        transfer => {          bti ¬ LOOPHOLE[sH.seb[sei].idInfo]; ctx ¬ sH.bb[bti].localCtx};        ENDCASE => ERROR;      n ¬ 0;      GenCtx[ctx, countids];      WITH sH.ctxb[ctx] SELECT FROM        included => mdi ¬ module;        imported => {          mdi ¬ sH.ctxb[includeLink].module; GenCtx[includeLink, countids]};        ENDCASE => LOOP;  -- main body      IF n > 0 THEN na ¬ myHeap.NEW[NameSeq[n]];      IF n = 0 AND ~sH.mdb[mdi].exported THEN LOOP;      i ¬ 0;      GenCtx[ctx, insertid];      WITH sH.ctxb[ctx] SELECT FROM        imported => GenCtx[includeLink, insertid];        ENDCASE;      IF first THEN Put["DIRECTORY"L] ELSE PutChar[',];      PutCR[];      first ¬ FALSE;      Put["  "L];      PutSubString[mname];      SymbolOps.SubStringForHash[sH, LOOPHOLE[filename], sH.mdb[mdi].fileId];      FOR j: CARDINAL IN [0..filename.length) DO        IF filename.base[filename.offset + j] = '. THEN {          filename.length ¬ j; EXIT};        ENDLOOP;      IF ~String.EquivalentSubStrings[mname, filename] THEN {        Put[": FROM """L]; PutSubString[filename]; PutChar['"]};      Put[" USING ["L];      IF n > 0 THEN {        SortNames[na];        PutSubString[@na[0]];        FOR i IN (0..na.length) DO Put[", "L]; PutSubString[@na[i]]; ENDLOOP;        myHeap.FREE[@na]};      PutChar[']];      ENDLOOP;    myHeap.FREE[@da];    PutChar[';];    PutCR[];    PutCR[];    PutCR[];    END;  Head: LONG POINTER TO Item ¬ NIL;  Item: TYPE = RECORD [    link: LONG POINTER TO Item,    value: LONG STRING,    sublink: LONG POINTER TO Item];  CopyString: PROCEDURE [old: LONG STRING] RETURNS [copy: LONG STRING] =    BEGIN    IF old = NIL THEN RETURN[NIL];    copy ¬ AllocString[old.length];    String.AppendString[copy, old];    END;  MakeItem: PROCEDURE [value: LONG STRING, link: LONG POINTER TO Item]    RETURNS [item: LONG POINTER TO Item] =    BEGIN    item ¬ myHeap.NEW[Item ¬ [link: link, value: value, sublink: NIL]];    END;  AddItem: PROCEDURE [    value: LONG STRING, list: LONG POINTER TO LONG POINTER TO Item,    copyString: BOOLEAN ¬ TRUE] RETURNS [item: LONG POINTER TO Item] =    BEGIN    prev: LONG POINTER TO Item ¬ NIL;    FOR item ¬ list­, item.link UNTIL item = NIL DO      SELECT StringCompare[item.value, value] FROM        0 => EXIT;        1 =>          BEGIN          item ¬ MakeItem[IF copyString THEN CopyString[value] ELSE value, item];          IF prev = NIL THEN list­ ¬ item ELSE prev.link ¬ item;          EXIT          END;        ENDCASE;      prev ¬ item;      REPEAT        FINISHED =>          BEGIN          item ¬ MakeItem[IF copyString THEN CopyString[value] ELSE value, NIL];          IF prev = NIL THEN list­ ¬ item ELSE prev.link ¬ item;          END;      ENDLOOP;    END;  compressing: BOOLEAN ¬ FALSE;  list: BOOLEAN ¬ FALSE;  Compress: PROC [name: LONG STRING] = {    fh: MFile.Handle ¬ NIL;    dh: MStream.Handle ¬ NIL;    Cleanup: PROC = {EraseHeap[]; Head ¬ NIL; compressing ¬ FALSE};    compressing ¬ TRUE;    InitHeap[];    Format.Line[ListerDefs.write, "UsingList:"L];    ListerDefs.OpenOutput[NIL, NIL];    UsingList[name ! UNWIND => Cleanup[]];    -- before destroying temporary "using" file, get handle on it    fh ¬ MFile.CopyFileHandle[      file: MStream.GetFile[ListerDefs.out], release: MFile.ReleaseData[],      access: anchor];    ListerDefs.CloseOutput[];    -- open input stream on temporary "using" file    Format.Line[ListerDefs.write, "Compressing:"L];    MFile.SetAccess[file: fh, access: readOnly];    dh ¬ MStream.Create[file: fh, release: MStream.ReleaseData[]];    ListerDefs.OpenOutput[name, "ul"L];    CompressIt[dh];    ListerDefs.CloseOutput[];    dh.delete[dh];    Cleanup[]};  UsingList: PROC [name: LONG STRING] = {    ENABLE UNWIND => IF ~compressing THEN EraseHeap[];    s: LONG STRING;    ListerDefs.OpenFileList[name];    list ¬ TRUE;    IF ~compressing THEN InitHeap[];    UNTIL (s ¬ ListerDefs.NextNameInList[]) = NIL DO      IF compressing THEN ListerDefs.write["    "L]; -- indent names      Using[s];      ENDLOOP;    IF ~compressing THEN EraseHeap[];    list ¬ FALSE};  Using: PROCEDURE [root: LONG STRING] = {    defs: BOOLEAN ¬ FALSE;    bcd: BcdOps.BcdBase;    IF ~list AND ~compressing THEN InitHeap[];    [bcd: bcd, sH: sH] ¬ Load[root: root, flags: ListerDefs.noCode!      NoFGT => RESUME];    IF ~compressing THEN ListerDefs.OpenOutput[root, "ul"L];    PutBcdID[bcd];    IF sH.sourceFile # NIL THEN {Put["  Source: "L]; Put[sH.sourceFile]; PutCR[]};    PrintUsing[];    ListerDefs.ReleaseSymbols[sH];    IF ~compressing THEN ListerDefs.CloseOutput[];    IF ~list AND ~compressing THEN EraseHeap[];    };  CompressIt: PROC [input: MStream.Handle] = {    OPEN Ascii;    term: CHARACTER;    user: STRING ¬ [60];    userCopy: LONG STRING;    interface: STRING ¬ [60];    used: STRING ¬ [60];    int: LONG POINTER TO Item;    DO      userCopy ¬ NIL;      IF (term ¬ GetToken[input, user]) = NUL THEN EXIT;      ListerDefs.write["    "L];      Format.Line[ListerDefs.write, user];      UNTIL term = '; OR term = CR AND StringCompare[interface, "DIRECTORY"L] = 0        DO term ¬ GetToken[input, interface]; ENDLOOP;      IF term = '; THEN LOOP;      UNTIL term = '; DO        term ¬ GetToken[input, interface];        UNTIL term = ', OR term = '[ OR term = '; DO          term ¬ GetToken[input, used]; ENDLOOP;        IF term = '; THEN EXIT;        IF term = '[ THEN {          intitem: LONG POINTER TO Item ¬ AddItem[interface, @Head];          item: LONG POINTER TO Item;          IF userCopy = NIL THEN userCopy ¬ CopyString[user];          DO            term ¬ GetToken[input, used];            item ¬ AddItem[used, @intitem.sublink];            [] ¬ AddItem[userCopy, @item.sublink, FALSE];            IF term = '] THEN EXIT;            ENDLOOP;          term ¬ GetToken[input, used]};        ENDLOOP;      ENDLOOP;    FOR int ¬ Head, int.link UNTIL int = NIL DO      item, user: LONG POINTER TO Item;      c: CHARACTER;      IF int.sublink = NIL THEN LOOP;      Put[int.value];      PutCR[];      FOR item ¬ int.sublink, item.link UNTIL item = NIL DO        Put["  "L];        Put[item.value];        PutChar[SP];        c ¬ '(;        FOR user ¬ item.sublink, user.link UNTIL user = NIL DO          PutChar[c]; c ¬ SP; Put[user.value]; ENDLOOP;        PutChar[')];        PutCR[];        ENDLOOP;      PutCR[];      ENDLOOP};  GetToken: PROC [in: MStream.Handle, s: LONG STRING] RETURNS [term: CHARACTER] =    BEGIN    ENABLE Stream.EndOfStream => GOTO eof;    s.length ¬ 0;    WHILE (term ¬ LOOPHOLE[in.getByte[in]]) <= Ascii.SP DO NULL ENDLOOP;    WHILE term IN ['a..'z] OR term IN ['A..'Z] OR term IN ['0..'9] DO      String.AppendChar[s, term]; term ¬ LOOPHOLE[in.getByte[in]]; ENDLOOP;    EXITS eof => term ¬ Ascii.NUL;    END;  CallUsing: ListerDefs.ListerProc =    BEGIN Using[CommandUtil.GetNth[argList, 0]]; END;  HelpUsing: ListerDefs.HelpProc =    BEGIN ListerDefs.write["Using[""Filename""] "L]; END;  CallUsingList: ListerDefs.ListerProc =    BEGIN UsingList[CommandUtil.GetNth[argList, 0]]; END;  HelpUsingList: ListerDefs.HelpProc =    BEGIN ListerDefs.write["UsingList[""FileList""] "L]; END;  CallCompress: ListerDefs.ListerProc =    BEGIN Compress[CommandUtil.GetNth[argList, 0]]; END;  HelpCompress: ListerDefs.HelpProc =    BEGIN ListerDefs.write["Compress[""FileList""] "L]; END;  Init: PROCEDURE =    BEGIN    ListerDefs.AddCommand["Using"L, CallUsing, HelpUsing];    ListerDefs.AddCommand["UsingList"L, CallUsingList, HelpUsingList];    ListerDefs.AddCommand["Compress"L, CallCompress, HelpCompress];    END;  Init[];  END.
-- File: ListPackageInfo.mesa - last edit:-- JBD                  4-Mar-87 14:44:44--  MEW		18-Jun-86  9:13:34--  Sweet	15-Jul-83 10:21:08--  Johnsson	11-Jun-83 23:27:43--  Rhonda	28-Sep-82 11:48:11--  Lewis	 2-Dec-81 16:39:12--  Loretta	24-Aug-81 15:14:48-- Copyright (C) 1981, 1982, 1983, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Ascii USING [SP],  BcdDefs,  BcdOps,  CommandUtil USING [    CopyString, FreeString, GetNth, GetNthPair, ListLength],  Format USING [NumberFormat],  Heap USING [systemZone],  ListerDefs USING [    AddCommand, all, HelpProc, ListerProc, Load,    LoadFromConfig, NoCode, NoFGT,    OpenOutput, Put, PutBcdID, PutChar, PutCR, PutDecimal, PutHti,     PutNumber, PutOctal, write],  PackageSymbols,  String USING [EquivalentString],  SymbolOps USING [EnumerateBodies, Handle, HashForSe],  Symbols USING [BTIndex, HTIndex];ListPackageInfo: PROGRAM  IMPORTS CommandUtil, Heap, ListerDefs, String, SymbolOps =  BEGIN OPEN ListerDefs, PackageSymbols;  sH: SymbolOps.Handle;  z: UNCOUNTED ZONE = Heap.systemZone;  Decimal3: Format.NumberFormat = [    base: 10, unsigned: TRUE, zerofill: FALSE, columns: 3];  Decimal5: Format.NumberFormat = [    base: 10, unsigned: TRUE, zerofill: FALSE, columns: 5];  Octal5: Format.NumberFormat = [    base: 8, unsigned: TRUE, zerofill: FALSE, columns: 5];  epMap: LONG POINTER TO EPMapSeq;  EPMapSeq: TYPE = RECORD[epm: SEQUENCE length: CARDINAL OF Symbols.HTIndex];  CreateEpMap: PROC =    BEGIN    max: CARDINAL ¬ 0;    Count: PROC [h: SymbolOps.Handle, bti: Symbols.BTIndex] RETURNS [stop: BOOLEAN] =      BEGIN      stop ¬ FALSE;      WITH b: h.bb[bti] SELECT FROM        Callable =>          IF ~b.inline AND b.nesting # Catch THEN max ¬ MAX[b.entryIndex, max];        ENDCASE;      END;    Enter: PROC [h: SymbolOps.Handle, bti: Symbols.BTIndex] RETURNS [stop: BOOLEAN] =      BEGIN      stop ¬ FALSE;      WITH b: h.bb[bti] SELECT FROM        Callable =>          IF ~b.inline AND b.nesting # Catch THEN            epMap[b.entryIndex] ¬ SymbolOps.HashForSe[sH, b.id];        ENDCASE;      END;    [] ¬ SymbolOps.EnumerateBodies[sH, FIRST[Symbols.BTIndex], Count];    epMap ¬ Heap.systemZone.NEW[EPMapSeq[max + 1]];    [] ¬ SymbolOps.EnumerateBodies[sH, FIRST[Symbols.BTIndex], Enter];    END;  PrintOuterPackTable: PROC =    BEGIN    opb: LONG DESCRIPTOR FOR ARRAY OF OuterPackRecord ¬ DESCRIPTOR[      (sH.stHandle + sH.stHandle.outerPackBlock.offset),        (sH.stHandle.outerPackBlock.size / SIZE[OuterPackRecord])];    opr: OuterPackRecord;    Put["OuterPackTable"L];    PutCR[];    PutCR[];    FOR i: OPIndex IN [0..LENGTH[opb]) DO      opr ¬ opb[i];      PutNumber[i, Decimal3];      Put[": hti:"L];      PutNumber[opr.hti, Decimal5];      Put[" ("L];      IF i = (LENGTH[opb] - 1) THEN Put["CATCH CODE"L] ELSE PutHti[sH, opr.hti];      Put["), ep: "L];      PutOctal[opr.entryIndex];      Put[" ("L];      PutOctal[ev.initialPC[opr.entryIndex]];      Put["), len: "L];      PutOctal[opr.length];      IF opr.firstSon # IPNull THEN {Put[", son: "L]; PutDecimal[opr.firstSon]};      IF opr.resident THEN Put[", resident"L];      IF opr.placed THEN Put[", placed"L];      IF opr.needsFixup THEN Put[", needsFixup"L];      PutCR[];      ENDLOOP;    PutCR[];    PutCR[];    END;  PrintInnerPackTable: PROC =    BEGIN    ipb: LONG DESCRIPTOR FOR ARRAY OF InnerPackRecord ¬ DESCRIPTOR[      (sH.stHandle + sH.stHandle.innerPackBlock.offset),        (sH.stHandle.innerPackBlock.size / SIZE[InnerPackRecord])];    ipr: InnerPackRecord;    Put["InnerPackTable"L];    PutCR[];    PutCR[];    FOR i: IPIndex IN [0..LENGTH[ipb]) DO      ipr ¬ ipb[i];      PutNumber[i, Decimal3];      Put[": ("L];      PutHti[sH, epMap[ipr.entryIndex]];      Put["), ep: "L];      PutOctal[ipr.entryIndex];      Put[" ("L];      PutOctal[ev.initialPC[ipr.entryIndex]];      Put["), len: "L];      PutOctal[ipr.length];      IF ipr.needsFixup THEN Put[", needsFixup"L];      IF ipr.lastSon THEN Put[", lastSon"L];      PutCR[];      ENDLOOP;    PutCR[];    PutCR[];    END;  PrintConstantTable: PROC =    BEGIN    cstSizePtr: LONG POINTER TO CARDINAL =      LOOPHOLE[sH.stHandle + sH.stHandle.constBlock.offset];    totalSize: CARDINAL = sH.stHandle.constBlock.size;    cstb: LONG DESCRIPTOR FOR ARRAY OF ConstRecord ¬ DESCRIPTOR[      cstSizePtr + 1, cstSizePtr­];    loadOffsetTable: PCSeq =      LOOPHOLE[BASE[cstb] + cstSizePtr­ * SIZE[ConstRecord]];    loadByteOffsetTable: PCSeq =      loadOffsetTable + SIZE[PCSeqBody [loadOffsetTable.length]];    jumpIndirectTable: JISeq =      LOOPHOLE[loadByteOffsetTable + SIZE[                 PCSeqBody [loadByteOffsetTable.length]]];    PrintConstEntry: PROC [i: CARDINAL] =      BEGIN      cstr: ConstRecord = cstb[i];      PutNumber[cstr.offset, Octal5];      Put[", len:"L];      PutNumber[cstr.length, Decimal3];      END;    PrintLCOEntry: PROC [i: CARDINAL] =      BEGIN PutNumber[loadOffsetTable[i], Octal5]; END;    PrintLIOEntry: PROC [i: CARDINAL] =      BEGIN PutNumber[loadByteOffsetTable[i], Octal5]; END;    PrintJIEntry: PROC [i: CARDINAL] =      BEGIN      jid: JIData = jumpIndirectTable[i];      PutNumber[jid.pc, Octal5];      Put[", branches:"L];      PutNumber[jid.tableSize, Decimal3];      END;    Put["ConstantTable"L];    PutCR[];    PutCR[];    PrintByColumns[PrintConstEntry, LENGTH[cstb], 3, 4];    PutCR[];    PutCR[];    IF loadOffsetTable.length # 0 THEN {      Put["Load code offset"L];      PutCR[];      PutCR[];      PrintByColumns[PrintLCOEntry, loadOffsetTable.length, 3, 4];      PutCR[];      PutCR[]};    IF loadByteOffsetTable.length # 0 THEN {      Put["Load instruction offset"L];      PutCR[];      PutCR[];      PrintByColumns[PrintLIOEntry, loadByteOffsetTable.length, 3, 4];      PutCR[];      PutCR[]};    IF jumpIndirectTable.length # 0 THEN {      Put["Jump indirect"L];      PutCR[];      PutCR[];      PrintByColumns[PrintJIEntry, jumpIndirectTable.length, 3, 4];      PutCR[];      PutCR[]};    END;  PrintByColumns: PROC [    PrintOne: PROC [i: CARDINAL], nItems, nColumns, spaceBetween: CARDINAL] =    BEGIN    nc: CARDINAL;    delta: CARDINAL ¬ (nItems + nColumns - 1) / nColumns;    last: BOOLEAN;    FOR i: CARDINAL IN [0..delta) DO      nc ¬ 0;      last ¬ FALSE;      FOR j: CARDINAL ¬ i, j + delta WHILE ~last AND j < nItems DO        nc ¬ nc + 1;        last ¬ nc = nColumns;        PrintOne[j];        IF ~last THEN THROUGH [0..spaceBetween) DO PutChar[Ascii.SP]; ENDLOOP;        ENDLOOP;      PutCR[];      ENDLOOP;    END;  ev: LONG POINTER TO BcdDefs.ENRecord;  PackInfo: PROC [root: LONG STRING] = {    bcd: BcdOps.BcdBase;    -- discard the code, but insure that it is there, error is caught elsewhere    [bcd: bcd, sH: sH] ¬ ListerDefs.Load[root: root, flags: ListerDefs.all !        NoFGT => RESUME];    ev ¬ @LOOPHOLE[bcd + bcd.enOffset, BcdDefs.Base][BcdDefs.ENIndex.FIRST];    CreateEpMap[];    ListerDefs.OpenOutput[root, "pl"L];    PutBcdID[bcd];    PrintOuterPackTable[];    PrintInnerPackTable[];    PrintConstantTable[];    z.FREE[@epMap];    };  PackInfoInConfig: PROC [config, module: LONG STRING] = {    mti: BcdDefs.MTIndex;    mth: BcdOps.MTHandle;    bcd: BcdOps.BcdBase;    -- discard the code, but insure that it is there    [bcd: bcd, sH: sH, mti: mti] ¬ LoadFromConfig[      root: config, module: module, flags: ListerDefs.all !        NoFGT, NoCode => RESUME];    mth ¬ @LOOPHOLE[bcd + bcd.mtOffset, BcdDefs.Base][mti];    ev ¬ @LOOPHOLE[bcd + bcd.enOffset, BcdDefs.Base][mth.entries];    CreateEpMap[];    ListerDefs.OpenOutput[module, "pl"L];    PutBcdID[bcd];    PrintOuterPackTable[];    PrintInnerPackTable[];    PrintConstantTable[];    z.FREE[@epMap];    };  CallPackInfo: ListerDefs.ListerProc =    BEGIN PackInfo[CommandUtil.GetNth[argList, 0]]; END;  HelpPackInfo: ListerDefs.HelpProc =    BEGIN ListerDefs.write["PackInfo[""Filename""L] "L]; END;  CallPackInfoInConfig: ListerDefs.ListerProc =    BEGIN    configname, modname, key, value: LONG STRING ¬ NIL;    FOR i: CARDINAL IN [0..CommandUtil.ListLength[argList]) DO      ENABLE        UNWIND => {          configname ¬ CommandUtil.FreeString[configname];          modname ¬ CommandUtil.FreeString[modname]};      [key, value] ¬ CommandUtil.GetNthPair[argList, i];      SELECT TRUE FROM        String.EquivalentString[key, "Config"L] =>          configname ¬ CommandUtil.CopyString[value];        String.EquivalentString[key, "Module"L] =>          modname ¬ CommandUtil.CopyString[value];        ENDCASE =>          IF i = 0 THEN configname ¬ CommandUtil.CopyString[value]          ELSE IF i = 1 THEN modname ¬ CommandUtil.CopyString[value];      ENDLOOP;    SELECT TRUE FROM      configname = NIL => {        ListerDefs.write["No Config parameter."L]; outcome ¬ error};      modname = NIL => {        ListerDefs.write["No Module parameter."L]; outcome ¬ error};      ENDCASE =>        PackInfoInConfig[          configname, modname !          UNWIND => {            configname ¬ CommandUtil.FreeString[configname];            modname ¬ CommandUtil.FreeString[modname]}];    configname ¬ CommandUtil.FreeString[configname];    modname ¬ CommandUtil.FreeString[modname];    END;  HelpPackInfoInConfig: ListerDefs.HelpProc =    BEGIN ListerDefs.write["PackInfoInConfig[""Config"", ""Module""] "L]; END;  Init: PROC =    BEGIN    ListerDefs.AddCommand["PackInfo"L, CallPackInfo, HelpPackInfo];    ListerDefs.AddCommand[      "PackInfoInConfig"L, CallPackInfoInConfig, HelpPackInfoInConfig];    END;  Init[];  END.
-- File: NetworkBindingTool.mesa - last edit:-- AOF                  6-Nov-87 18:41:41-- NetworkBindingTool.mesa-- Create by FormSWLayoutTool on  1-Sep-87 19:46-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AddressTranslation USING [    Error, NetworkAddress, PrintError, StringToNetworkAddress],  Courier USING [nullParameters],  Exec USING [AddCommand, ExecProc, Handle, OutputProc, RemoveCommand],  Format USING [LongNumber, NetworkAddress, NumberFormat, StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, Enumerated,    EnumeratedItem, line0, line1, LongNumberItem, NumberItem, ProcType,    StringItem, TagOnlyItem],  Heap USING [Create, Delete],  NetworkBinding USING [    BindToAllOnNet, BindToFirstNearby, BindToFirstOnNet, NoBinding,    PredicateRecord, Responses, VerifyBinding],  NetworkBindingInternal USING [BindToAllNearby],  Process USING [Detach, priorityNormal, SetPriority],  Put USING [Text],  System USING [    GetClockPulses, NetworkAddress, nullNetworkAddress, PulsesToMicroseconds],  Time USING [Append, Unpack],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Handle],  WindowFont USING [CharWidth];NetworkBindingTool: MONITOR  IMPORTS    AddressTranslation, NetworkBinding, NetworkBindingInternal, Exec, Format,    FormSW, Heap, Process, Put, System, Time, Tool, WindowFont = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    procedure(6): UNSPECIFIED ¬ 0,    radius(7): CARDINAL ¬ 0,    remote(8): LONG STRING ¬ NIL,    program(10): LONG CARDINAL ¬ 0,    version(12): CARDINAL ¬ 0,    conjunct(13): LONG CARDINAL ¬ 0];  FormItems: TYPE = {    doit, procedure, radius, remote, program, version, conjunct, foo000};  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.Create[initial: 4];  busyBit: BOOLEAN ¬ FALSE;  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    ENABLE UNWIND => NULL;    isBusy ¬ busyBit;    busyBit ¬ TRUE };  Done: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    busyBit ¬ FALSE};  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};  Doit:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK DoitInternal[]]};  DoitInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    duration: LONG CARDINAL;    time: LONG STRING ¬ [24];    predicate: NetworkBinding.PredicateRecord;    msecs: Format.NumberFormat = [10, TRUE, TRUE, 3];    Process.SetPriority[Process.priorityNormal];    predicate.pred.program ¬ [data.program, data.version];    predicate.pred.conjunct ¬ [data.conjunct];    predicate.param ¬ Courier.nullParameters;    BEGIN    ENABLE NetworkBinding.NoBinding =>      {duration ¬ System.GetClockPulses[] - duration; GOTO noBinding};    SELECT data.procedure FROM      0 =>        BEGIN	response: LONG POINTER;	responder: System.NetworkAddress;	remote: System.NetworkAddress = ConvertRemote[];	Write["\nCalling NetworkBinding.BindToFirstOnNet\n"L];	Write["  time started: "L];	Time.Append[time, Time.Unpack[]]; Write[time]; Write["\n"L];	duration ¬ System.GetClockPulses[];	[responder, response] ¬ NetworkBinding.BindToFirstOnNet[	  predicate, NIL, remote.net, zone];	duration ¬ System.GetClockPulses[] - duration;	duration ¬ System.PulsesToMicroseconds[[duration / 1000]];	Write["  duration of call: "L];	Format.LongNumber[Write, (duration / 1000), []];	Write["."L];	Format.LongNumber[Write, (duration MOD 1000), msecs];	Write["\n  response from "L];	Format.NetworkAddress[Write, responder, octal];	Write["\n"L];	zone.FREE[@response];	END;      1 =>        BEGIN	response: LONG POINTER;	responder: System.NetworkAddress;	remote: System.NetworkAddress = ConvertRemote[];	Write["\nCalling NetworkBinding.BindToFirstNearby\n"L];	Write["  time started: "L];	Time.Append[time, Time.Unpack[]]; Write[time]; Write["\n"L];	duration ¬ System.GetClockPulses[];	[responder, response] ¬ NetworkBinding.BindToFirstNearby[	  predicate, NIL, data.radius, zone];	duration ¬ System.GetClockPulses[] - duration;	duration ¬ System.PulsesToMicroseconds[[duration / 1000]];	Write["  duration of call: "L];	Format.LongNumber[Write, (duration / 1000), []];	Write["."L];	Format.LongNumber[Write, (duration MOD 1000), msecs];	Write["\n  response from "L];	Format.NetworkAddress[Write, responder, octal];	Write["\n"L];	zone.FREE[@response];	END;      2 =>        BEGIN	responses: NetworkBinding.Responses;	remote: System.NetworkAddress = ConvertRemote[];	Write["\nCalling NetworkBinding.BindToAllOnNet\n"L];	Write["  time started: "L];	Time.Append[time, Time.Unpack[]]; Write[time]; Write["\n"L];	duration ¬ System.GetClockPulses[];	responses ¬ NetworkBinding.BindToAllOnNet[	  predicate, NIL, remote.net, zone];	IF responses = NIL THEN GOTO noBinding;	duration ¬ System.GetClockPulses[] - duration;	duration ¬ System.PulsesToMicroseconds[[duration / 1000]];	Write["  duration of call: "L];	Format.LongNumber[Write, (duration / 1000), []];	Write["."L];	Format.LongNumber[Write, (duration MOD 1000), msecs];	Write["\n  responses from "L];	PrintResponsesList[responses];	Write["\n"L];	zone.FREE[@responses];	END;      3 =>        BEGIN	response: LONG POINTER;	remote: System.NetworkAddress = ConvertRemote[];	Write["\nCalling NetworkBinding.VerifyBinding\n"L];	Write["  time started: "L];	Time.Append[time, Time.Unpack[]]; Write[time]; Write["\n"L];	duration ¬ System.GetClockPulses[];	response ¬ NetworkBinding.VerifyBinding[	  predicate, NIL, remote, zone];	duration ¬ System.GetClockPulses[] - duration;	duration ¬ System.PulsesToMicroseconds[[duration / 1000]];	Write["  duration of call: "L];	Format.LongNumber[Write, (duration / 1000), []];	Write["."L];	Format.LongNumber[Write, (duration MOD 1000), msecs];	Write["\n"L];	zone.FREE[@response];	END;      4 =>        BEGIN	responses: NetworkBinding.Responses;	Write["\nCalling NetworkBindingInternal.BindToAllNearby\n"L];	Write["  time started: "L];	Time.Append[time, Time.Unpack[]]; Write[time]; Write["\n"L];	duration ¬ System.GetClockPulses[];	responses ¬ NetworkBindingInternal.BindToAllNearby[	  predicate, NIL, data.radius, zone];	IF responses = NIL THEN GOTO noBinding;	duration ¬ System.GetClockPulses[] - duration;	duration ¬ System.PulsesToMicroseconds[[duration / 1000]];	Write["  duration of call: "L];	Format.LongNumber[Write, (duration / 1000), []];	Write["."L];	Format.LongNumber[Write, (duration MOD 1000), msecs];	Write["\n  responses from "L];	PrintResponsesList[responses];	Write["\n"L];	zone.FREE[@responses];	END;      ENDCASE;    EXITS noBinding =>      BEGIN      Write["No binding\n"L];      duration ¬ System.PulsesToMicroseconds[[duration / 1000]];      Write["  duration of call: "L];      Format.LongNumber[Write, (duration / 1000), []];      Write["."L];      Format.LongNumber[Write, (duration MOD 1000), msecs];      Write["\n"L];      END;    END;    Done[] };  ConvertRemote: PROC RETURNS[na: System.NetworkAddress] =    BEGIN    ENABLE AddressTranslation.Error =>      BEGIN      Msg["\nAddressTranslation error: "L];      AddressTranslation.PrintError[errorRecord, Msg];      Msg["\n"L];      na ¬ System.nullNetworkAddress;      CONTINUE;      END;    na ¬ AddressTranslation.StringToNetworkAddress[data.remote].addr;    END;  --ConvertRemote  PrintResponsesList: PROC[responses: NetworkBinding.Responses] =    BEGIN    al: LONG POINTER TO AddressList = LOOPHOLE[responses];    AddressList: TYPE = RECORD[elementSize: NATURAL,      seq: SEQUENCE elementCount: NATURAL OF System.NetworkAddress];    FOR i: NATURAL IN[0..al.elementCount) DO      Format.NetworkAddress[Write, al[i], octal]; Write["  "L];      ENDLOOP;    END;  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];      new = inactive =>        IF data # NIL THEN zone.FREE[@data];      ENDCASE;    };  Init: PROCEDURE = {    Exec.AddCommand["NetworkBindingTool.~"L, NoOp, NIL, Unload];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "NetworkBindingTool"L,      cmSection: "NetworkBindingTool"L];    };      NoOp: Exec.ExecProc = { };    Unload: Exec.ExecProc = {    IF Busy[] THEN {      Exec.OutputProc[h]["Tool is busy. Sorry.\n"L];      RETURN[error] };    Tool.Destroy[wh];    Exec.RemoveCommand[h, "NetworkBindingTool.~"L];    Heap.Delete[zone];    Done[] };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [25];    Tool.UnusedLogName[unused: logName, root: "NetworkBindingTool.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: zone];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};  MakeForm: FormSW.ClientItemsProcType = {    nItems: CARDINAL = FormItems.LAST.ORD + 1;    procedure: ARRAY[0..5) OF FormSW.Enumerated ¬ [      ["to first"L, 0], ["first nearby"L, 1],      ["to all"L, 2], ["verify"L, 3],      ["all nearby"L, 4]];    items ¬ FormSW.AllocateItemDescriptor[nItems, zone];    items[FormItems.doit.ORD] ¬ FormSW.CommandItem[      tag: "Doit"L, place: [CharPos[1], FormSW.line0], proc: Doit, z: zone];    items[FormItems.procedure.ORD] ¬ FormSW.EnumeratedItem[      tag: "Procedure"L, place: [CharPos[11], FormSW.line0],      choices: DESCRIPTOR[procedure], value: @data.procedure, z: zone];    items[FormItems.radius.ORD] ¬ FormSW.NumberItem[      tag: "Radius"L, place: [CharPos[39], FormSW.line0],      signed: FALSE, boxWidth: 16, default: 3, value: @data.radius, z: zone];    items[FormItems.remote.ORD] ¬ FormSW.StringItem[      tag: "Remote"L, place: [CharPos[52], FormSW.line0],      inHeap: TRUE, string: @data.remote, z: zone];    items[FormItems.program.ORD] ¬ FormSW.LongNumberItem[      tag: "Predicate = [program: [programNumber"L,      place: [CharPos[1], FormSW.line1], signed: FALSE, boxWidth: 32,      default: 0, value: @data.program, z: zone];    items[FormItems.version.ORD] ¬ FormSW.NumberItem[      tag: "version"L, place: [CharPos[44], FormSW.line1],      signed: FALSE, boxWidth: 24, default: 0, value: @data.version, z: zone];    items[FormItems.conjunct.ORD] ¬ FormSW.LongNumberItem[      tag: "] conjunct"L, place: [CharPos[56], FormSW.line1],      signed: FALSE, boxWidth: 32, default: 0,      value: @data.conjunct, z: zone];    items[FormItems.foo000.ORD] ¬ FormSW.TagOnlyItem[      tag: "]"L, place: [CharPos[72], FormSW.line1], z: zone];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
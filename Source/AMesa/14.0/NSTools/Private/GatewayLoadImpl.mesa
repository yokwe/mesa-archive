-- File: GatewayLoadImpl.mesa - last edit:-- AOF                 18-May-88  8:31:53-- Copyright (C) 1984, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. -- GatewayLoad.mesaDIRECTORY  AddressTranslation USING [Error, StringToNetworkAddress, StringToNetworkNumber],  Buffer USING [    Buffer, MakePool, DestroyPool, AccessHandle, ReturnBuffer, Type],  BufferOps USING [Defaults, GetDefaults, SetDefaults],  DataLinkControl USING [AdjustInputQueueLength],  Display USING [Black, Gray, Text, White],  Driver USING [ChangeNumberOfInputBuffers, Device, GetDeviceChain],  IEEE8023 USING [Encapsulation, EncapObject, minBytesPerEthernetPacket],  File USING [nullFile],  Format USING [HostNumber, NetworkNumber, StringProc],  FormSW USING [AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, Enumerated, EnumeratedItem, newLine, NotifyProcType, NumberItem,    ProcType, sameLine, StringItem],  Inline USING [LowHalf],  NSBuffer USING [Body],  Process USING [Abort, EnableAborts, SetTimeout, SecondsToTicks,    priorityBackground, SetPriority],  Protocol1 USING [SetMaximumBufferSize],  Put USING [CR, Line, LongDecimal, Text],  PupDefs USING [Body],  Router USING [AssignAddress, FindMyHostID],  Runtime USING [GetBcdTime],  SpecialCommunication USING [SetEthernetListener, SetSpyProc, SpyProc, SpyType],  Space USING [Interval, Kill, Map, Unmap],  SpecialSystem USING [    broadcastHostNumber, HostNumber, NetworkNumber, nullNetworkNumber],  String USING [AppendChar, AppendString],  Time USING [Append, Unpack],  System USING [broadcastHostNumber, GetClockPulses, GetGreenwichMeanTime,    GreenwichMeanTime, MicrosecondsToPulses, NetworkAddress,    PulsesToMicroseconds, HostNumber],  Tool USING [AddThisSW, Create, Destroy, MakeFileSW, MakeFormSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [CreateSubwindow, DisplayProcType, TransitionProcType],  UserTerminal USING [BlinkDisplay],  Version USING [Append],  Window USING [Handle],  WindowFont USING [CharWidth, FontHeight];  GatewayLoadImpl: MONITOR  IMPORTS    AddressTranslation, Buffer, BufferOps, Display, Driver, Format, FormSW,    Inline, Process, Put, Protocol1, Router, Runtime, SpecialCommunication,    Space, String, System, Time, Tool, ToolWindow, UserTerminal, Version,    WindowFont, DataLinkControl  EXPORTS Buffer, System =  BEGIN  HostNumber: PUBLIC TYPE = SpecialSystem.HostNumber;  NetworkNumber: PUBLIC TYPE = SpecialSystem.NetworkNumber;  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  wh: Window.Handle;  form, graph: Window.Handle ¬ NIL;  oldSpy: ARRAY Buffer.Type OF SpecialCommunication.SpyProc;    -- Histogram data.  barHeight: INTEGER = 14;  tickHeight: INTEGER = 2;  tickWidth: INTEGER = 2;  graphHeight: INTEGER = 300;  margin: INTEGER = 10;  width: INTEGER = 1024 - 2*margin;  netWidth: INTEGER = WindowFont.CharWidth['0] * 18;  barWidth: INTEGER = width - netWidth;  height: INTEGER = tickHeight+graphHeight+2*margin;  borderBottom: INTEGER = height-margin;  borderTop: INTEGER = borderBottom-tickHeight;    updater: PROCESS;  interval: CONDITION;  scale: INTEGER ¬ 1;  secondsPerInterval: CARDINAL = 1;  pulsesPerInterval: LONG CARDINAL = System.MicrosecondsToPulses[1000000];  stopTime: LONG CARDINAL;  -- when the tool was last stopped (in pulses).  running: BOOLEAN ¬ FALSE;  buffers: Buffer.AccessHandle ¬ NIL;  space: Space.Interval;  dispatcherBuffers: CARDINAL  = 90;  host: HostNumber ¬ LOOPHOLE[SpecialSystem.broadcastHostNumber];  logTool, logSW: Window.Handle ¬ NIL;  oldBufInfo, newBufInfo: ARRAY BufferOps.Defaults OF CARDINAL;  newBias: CARDINAL = 30;  -- Buffer bias so we don't miss as many packets.    unit: CARDINAL = 1;  me: HostNumber = Router.FindMyHostID[];  all: HostNumber = System.broadcastHostNumber;      Range: TYPE = CARDINAL[0..graphHeight/barHeight);  History: TYPE = PACKED ARRAY Range OF RECORD [old, new: INTEGER];  history: LONG DESCRIPTOR FOR History;    Mode: TYPE = {bytes, pkts};            -- for displaying the histogram.      DataRecord: TYPE = RECORD [    n1, n2: NetworkNumber,                -- networks involved (non-directional)    value: LONG INTEGER,                  -- for making histogram (pkts or bytes).    pkts: LONG INTEGER,                   -- number of packets seen.    bytes: LONG INTEGER,                  -- number of bytes seen.    age: LONG CARDINAL];                  -- last time packet seen on route.      null: DataRecord ¬ [    SpecialSystem.nullNetworkNumber, SpecialSystem.nullNetworkNumber, 0, 0, 0, 0];  allNets: NetworkNumber ¬ [177777B, 177777B];  -- catch all entry.  Data: TYPE = PACKED ARRAY Range OF DataRecord;  data: LONG DESCRIPTOR FOR Data;  finger: Range ¬ 0;    tool: RECORD [    mode: Mode ¬ pkts,                     -- hist based on pkts or bytes seen.    ageTO: LONG CARDINAL ¬ 0,              -- for flushing old entries.    hostString: LONG STRING ¬ NIL,         -- host we are watching.    netString: LONG STRING ¬ NIL,          -- net numbers parameter.    started: System.GreenwichMeanTime,     -- time the histogram was started.    stopped: System.GreenwichMeanTime,     -- time the histogram was stopped.    log: BOOLEAN ¬ FALSE];                 -- toggle for displaying log.     -- PROCEDURES    ClientTransition: ToolWindow.TransitionProcType =    BEGIN    Area: TYPE = RECORD[history: History, data: Data];    SELECT TRUE FROM      old = inactive =>        BEGIN	area: LONG POINTER TO Area;	length: CARDINAL = (SIZE[Area]+255)/255;	space ¬ Space.Map[window: [File.nullFile, 0, length], class: data]; 	area ¬ space.pointer;	history ¬ DESCRIPTOR[area.history];	data ¬ DESCRIPTOR[area.data];	FOR i: Range IN Range DO history[i] ¬ [0, 0]; data[i] ¬ null; ENDLOOP;	IF graph # NIL THEN ResetData[];	-- Set up buffer bias so we miss as few packets as possible.	oldBufInfo ¬ BufferOps.GetDefaults[];	newBufInfo ¬ [oldBufInfo[send], oldBufInfo[receive], newBias];	BufferOps.SetDefaults[newBufInfo];	Stop[];	[] ¬ SpecialCommunication.SetEthernetListener[unit, all];	FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	  oldSpy[type] ¬ SpecialCommunication.SetSpyProc[SpyProc, type];	  ENDLOOP;	END;      new = inactive =>        BEGIN	[] ¬ SpecialCommunication.SetEthernetListener[unit, me];	FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	  [] ¬ SpecialCommunication.SetSpyProc[NIL, type];  --wipe out spy	  ENDLOOP;	form ¬ graph ¬ NIL;	Space.Kill[space];	[] ¬ Space.Unmap[space.pointer];	BufferOps.SetDefaults[oldBufInfo];  -- Reset buffer bias.	END;      ENDCASE;    END;  -- ClientTransition          DisplayBar: PROC [i: Range] =    BEGIN    barBottom: INTEGER = borderTop - (barHeight * i) - margin - tickHeight - 1;    grayRight: INTEGER = history[i].old;    blackRight: INTEGER ¬ history[i].new;    IF graph = NIL THEN RETURN;    Display.White[      graph, [[netWidth, barBottom], [barWidth, barHeight]]];    Display.Gray[      graph, [[netWidth, barBottom], [grayRight, barHeight - 2]]];    IF blackRight > barWidth THEN      BEGIN      Display.Black[graph,        [[netWidth+grayRight, barBottom], [barWidth-grayRight, barHeight - 2]]];      history[i].new ¬ blackRight ¬ blackRight MOD barWidth;      END;    Display.Black[graph,      [[netWidth+grayRight, barBottom], [blackRight-grayRight, barHeight - 2]]];    END;  -- DisplayBar          DisplayGraph: ToolWindow.DisplayProcType =    BEGIN    DrawGraphPaper[];    ShowDots[];    END;  -- DisplayGraph        MakeLogSW: Tool.MakeSWsProc =    BEGIN    string: LONG STRING ¬ [40];    Tool.UnusedLogName[unused: string, root: "GatewayLoad.log"L];    logSW ¬ Tool.MakeFileSW[window: window, name: string];    END;  -- MakeLogSW          DisplayLog: FormSW.NotifyProcType =    BEGIN    IF tool.log THEN      BEGIN      string: LONG STRING ¬ [40];      stringProc: Format.StringProc = {String.AppendString[string, s]};      logTool ¬ Tool.Create[        makeSWsProc: MakeLogSW, initialState: default,	initialBox: [place: [x:620, y: 530], dims: [w:350, h:400]],	name: "GatewayLoad log", tinyName1: "GatewayLoad"L,	  tinyName2: "log"L];      Put.Text[logSW, "From "L];      Time.Append[string, Time.Unpack[tool.started]];      Put.Text[logSW, string];      string.length ¬ 0;      Put.Text[logSW, " to "L];      Time.Append[string, Time.Unpack[        IF running THEN System.GetGreenwichMeanTime[]	ELSE tool.stopped]];      Put.Line[logSW, string];      string.length ¬ 0;      Put.CR[logSW];      Put.Text[logSW, "  nets:  "L];      Put.Text[logSW, "packets, "L];       Put.Text[logSW, "bytes, "L];       Put.Line[logSW, "idle (msecs)"L];      Put.CR[logSW];      FOR i: Range IN Range DO        IF data[i] # null THEN	  BEGIN	  current: LONG CARDINAL ¬ System.GetClockPulses[] - data[i].age;	  Format.NetworkNumber[stringProc, LOOPHOLE[data[i].n1], octal];          String.AppendChar[string, '-];          Format.NetworkNumber[stringProc, LOOPHOLE[data[i].n2], octal];	  Put.Text[logSW, "  "L];	  Put.Text[logSW, string];	  string.length ¬ 0;	  Put.Text[logSW, ":  "L];	  Put.LongDecimal[logSW, data[i].pkts];	  Put.Text[logSW, ", "L];	  Put.LongDecimal[logSW, data[i].bytes];	  Put.Text[logSW, ", "L];	  Put.LongDecimal[logSW, System.PulsesToMicroseconds[[current]]/1000];	  Put.Line[logSW, string];	  string.length ¬ 0;	  END;        ENDLOOP;      END  -- if log    ELSE      BEGIN      IF logSW # NIL THEN        {Tool.Destroy[logTool];	logSW ¬ NIL};      END;    END;  -- DisplayLog          DisplayNet: PROC [i: Range] =    BEGIN    stringProc: Format.StringProc = {String.AppendString[nets, s]};    nets: STRING ¬ [40];    stringLeft: INTEGER ¬ 0;    barBottom: INTEGER = borderTop - (barHeight * i) - margin - tickHeight;    stringBottom: INTEGER = barBottom + (barHeight - WindowFont.FontHeight[])/2;    Display.White[graph,[[0, barBottom],[netWidth, barHeight]]];    IF data[i] # null THEN      BEGIN      Format.NetworkNumber[stringProc, LOOPHOLE[data[i].n1], octal];      String.AppendChar[nets, '-];      Format.NetworkNumber[stringProc, LOOPHOLE[data[i].n2], octal];      FOR j: CARDINAL IN[0..nets.length) DO        stringLeft ¬ stringLeft + WindowFont.CharWidth[nets[j]]; ENDLOOP;      stringLeft ¬ (netWidth - stringLeft)/2 - 2;      [] ¬ Display.Text[graph, nets, [stringLeft, stringBottom]];      END;     END;  -- DisplayNet          DrawGraphPaper: PROCEDURE =    BEGIN    delta: CARDINAL = 100;    Display.White[graph,[[0,0],[width, height]]];    Display.Black[      graph,[[margin, borderBottom],[width, tickHeight]]];    FOR i: CARDINAL IN[0..1000) DO  -- hundreds markers      IF (i MOD delta) # 0 THEN LOOP;      Display.White[        graph,[[margin+netWidth+i, borderBottom], [tickWidth, tickHeight]]];      Display.Black[        graph,[[margin+netWidth+i, borderBottom - tickHeight],	[tickWidth, tickHeight]]];      ENDLOOP;    END;  -- DrawGraphPaper          EntryPresent: PROC [d: DataRecord, n1, n2: NetworkNumber]    RETURNS [BOOLEAN] =    BEGIN    RETURN [((d.n1 = n1) AND (d.n2 = n2)) OR ((d.n1 = n2) AND (d.n2 = n1))];    END;  -- EntryPresent          Flush: ENTRY FormSW.ProcType =    BEGIN    now: LONG CARDINAL ¬ IF running THEN System.GetClockPulses[]      ELSE stopTime;    FOR i: Range IN Range DO      IF (data[i] # null) AND        (data[i].age + System.MicrosecondsToPulses[tool.ageTO *1000000] <=	  now) THEN	  BEGIN	  data[i] ¬ null;	  history[i] ¬ [0,0];	  DisplayNet[i];          DisplayBar[i];	  END;      ENDLOOP;    END;  -- Flush          Include: ENTRY FormSW.ProcType =    BEGIN    n1, n2: NetworkNumber;    newIndex: Range ¬ LAST[Range];    [n1, n2] ¬ TranslateEntry[tool.netString];    IF (n1 = SpecialSystem.nullNetworkNumber) OR      (n2 = SpecialSystem.nullNetworkNumber) THEN RETURN;    FOR i: Range IN Range DO      SELECT TRUE FROM        EntryPresent[data[i], n1, n2] => {UserTerminal.BlinkDisplay[]; RETURN};        (newIndex = LAST[Range]) AND (data[i] = null) => newIndex ¬ i;	ENDCASE;      ENDLOOP;    IF newIndex # LAST[Range] THEN      BEGIN      data[newIndex] ¬ [n1, n2, 0, 0, 0, 0];      history[newIndex] ¬ [0, 0];      DisplayNet[newIndex];      DisplayBar[newIndex];      END    ELSE UserTerminal.BlinkDisplay[];    END;  -- Include      TranslateEntry: PROC [netsString: LONG STRING]    RETURNS [net1: NetworkNumber ¬ SpecialSystem.nullNetworkNumber,      net2: NetworkNumber ¬ SpecialSystem.nullNetworkNumber] =    BEGIN    ENABLE    AddressTranslation.Error => GOTO error;    j: CARDINAL ¬ 0;    ns: LONG STRING ¬ [20];    IF (netsString = NIL) OR (netsString.length = 0) THEN RETURN;    -- Get first net.    WHILE (j < netsString.length) DO      IF netsString[j] = '- THEN        BEGIN	IF ns.length = 0 THEN GOTO error;  -- no first net.        net1 ¬ LOOPHOLE[AddressTranslation.StringToNetworkNumber[ns]];	j ¬ j + 1;	EXIT;	END;      String.AppendChar[ns, netsString[j]];      j ¬ j + 1;      REPEAT FINISHED => GOTO error;  -- reached end of string w/o finding dash.      ENDLOOP;    ns.length ¬ 0;    -- Get second net.    WHILE (j < netsString.length) DO      String.AppendChar[ns, netsString[j]];      j ¬ j + 1;      ENDLOOP;      IF ns.length = 0 THEN GOTO error;  -- no first net.      net2 ¬ LOOPHOLE[AddressTranslation.StringToNetworkNumber[ns]];    EXITS error =>       {UserTerminal.BlinkDisplay[];      net1 ¬ net2 ¬ SpecialSystem.nullNetworkNumber};    END;  -- TranslateEntry          Init: PROC =    BEGIN    lnA: System.NetworkAddress ¬ Router.AssignAddress[];    stringProc: Format.StringProc = {String.AppendString[name, s]};    name: STRING ¬ [120];    String.AppendString[name, "Gateway Load Tool "L];    Version.Append[name];    String.AppendString[name, " of "L];    Time.Append[name, Time.Unpack[Runtime.GetBcdTime[]]];    String.AppendString[name, " running on "L];    String.AppendString[      name, "(Dandelion) "L];    Format.NetworkNumber[stringProc, lnA.net, octal];    String.AppendChar[name, '.];    Format.HostNumber[stringProc, lnA.host, octal];    String.AppendChar[name, '.];    Process.SetTimeout[@interval, Process.SecondsToTicks[secondsPerInterval]];    Process.EnableAborts[@interval];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: name,      tinyName1: "Gateway "L, tinyName2: "Load"L,      initialBox: [[x: 0, y: 619], [w: 1024, h: graphHeight + 59]]];    END;  -- Init          MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    nItems: CARDINAL = 12;    modes: ARRAY[0..2) OF Enumerated ¬ [      ["bytes"L, Mode[bytes]],      ["packets"L, Mode[pkts]]];    j: CARDINAL ¬ 0;    items ¬ AllocateItemDescriptor[nItems];    items[j] ¬ CommandItem[tag: "Start"L, proc: Start, place: newLine];    items[j¬j+1] ¬ CommandItem[tag: "Stop"L, proc: Stop, place: [50, sameLine]];    items[j¬j+1] ¬ CommandItem[tag: "Clear"L, proc: Clear,      place: [95, sameLine]];    items[j¬j+1] ¬ CommandItem[tag: "Reset"L, proc: ResetData,      place: [140, sameLine]];    items[j¬j+1] ¬ CommandItem[tag: "Remove"L, proc: Remove,      place: [187, sameLine]];    items[j¬j+1] ¬ CommandItem[tag: "Include"L, proc: Include,      place: [235, sameLine]];    items[j¬j+1] ¬ EnumeratedItem[tag: "Histogram mode"L, place: [297, sameLine],      choices: DESCRIPTOR[modes], value: @tool.mode];    items[j¬j+1] ¬ StringItem[tag: "Net entry"L, string: @tool.netString,      place: [465, sameLine], inHeap: TRUE];    items[j¬j+1] ¬ StringItem[tag: "Target host"L, string: @tool.hostString,      place: [600, sameLine], inHeap: TRUE];    items[j¬j+1] ¬ CommandItem[tag: "Flush old"L, proc: Flush,      place: [797, sameLine]];    items[j¬j+1] ¬ NumberItem[tag: "seconds"L, value: @tool.ageTO,      place: [863, sameLine], signed: FALSE, notNegative: TRUE];    items[j¬j+1] ¬ BooleanItem[tag: "Log"L, switch: @tool.log, proc: DisplayLog,      place: [980, sameLine]];    IF (j+1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;          MakeSWs: Tool.MakeSWsProc =    BEGIN    graph ¬ ToolWindow.CreateSubwindow[parent: window, display: DisplayGraph];    Tool.AddThisSW[window: window, sw: graph, swType: vanilla, h: height];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    END;  -- MakeSWs          ResetData: ENTRY FormSW.ProcType =    BEGIN    FOR i: Range IN Range DO      history[i] ¬ [0, 0];      data[i].value ¬ 0;      data[i].pkts ¬ 0;      data[i].bytes ¬ 0;      data[i].age ¬ 0;      DisplayBar[i];      ENDLOOP;    END;  -- ResetData          Remove: ENTRY FormSW.ProcType =    BEGIN    n1, n2: NetworkNumber;    [n1, n2] ¬ TranslateEntry[tool.netString];    IF (n1 = SpecialSystem.nullNetworkNumber) OR      (n2 = SpecialSystem.nullNetworkNumber) THEN RETURN;    FOR i: Range IN Range DO      IF EntryPresent[data[i], n1, n2] THEN	BEGIN	data[i] ¬ null;	history[i] ¬ [0, 0];	DisplayNet[i];	DisplayBar[i];	RETURN;	END;      ENDLOOP;    UserTerminal.BlinkDisplay[];    END;  -- Remove      Clear: FormSW.ProcType =    BEGIN    ResetData[];    FOR i: Range IN Range DO data[i] ¬ null; ENDLOOP;    DrawGraphPaper[];    END;  -- Clear          ShowDots: PROCEDURE =    BEGIN    FOR i: Range IN Range DO DisplayNet[i]; DisplayBar[i]; ENDLOOP;    END;  -- ShowDots          SpyProc: SpecialCommunication.SpyProc =    BEGIN    index: Range;    dll: IEEE8023.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];     <<    We don't hook and unhook the Spy proc every time the user starts and stops    the tool (because we don't want to smash the entire chain), so check if we    are actually running.    >>    IF b.fo.driver.length < IEEE8023.minBytesPerEthernetPacket THEN      {Buffer.ReturnBuffer[b]; RETURN[NIL]};    IF oldSpy[b.fo.type] # NIL THEN      {b ¬ oldSpy[b.fo.type][b, function]; IF b = NIL THEN RETURN[b]};    IF running THEN      BEGIN      -- level 0 source/destination host always in ns form.      IF (dll.ethernetSource = host) OR	(dll.ethernetDest = host) OR	(host = all) THEN	BEGIN  -- interesting host.	FOR index IN Range DO	  SELECT dll.ethernetType FROM	    ns =>	      BEGIN	      bb: NSBuffer.Body = LOOPHOLE[	        dll + SIZE[ethernet IEEE8023.EncapObject]];	      SELECT TRUE FROM		EntryPresent[  -- update histogram for existing entry.		  data[index], bb.source.net, bb.destination.net] => NULL;		data[index] = null =>  -- create new entry.		  data[index] ¬ [bb.source.net, bb.destination.net, 0, 0, 0, 0];		(data[index].n1 = allNets) AND (data[index].n2 = allNets) =>		  NULL;  -- catch all.		ENDCASE => LOOP;	      data[index].age ¬ System.GetClockPulses[];	      data[index].bytes ¬ data[index].bytes + bb.pktLength;	      data[index].pkts ¬ data[index].pkts + 1;	      IF tool.mode = bytes THEN		data[index].value ¬ data[index].value ¬ bb.pktLength	      ELSE data[index].value ¬ data[index].value + 1;	      EXIT;	      END;  -- ns	    pup =>	      BEGIN	      bb: PupDefs.Body = LOOPHOLE[	        dll + SIZE[ethernet IEEE8023.EncapObject]];	      sn: WORD ¬ bb.source.net;	      dn: WORD ¬ bb.dest.net;	      SELECT TRUE FROM		EntryPresent[data[index], [0, sn], [0, dn]] =>  -- existing entry.		  NULL;		data[index] = null =>  -- create new entry.		  data[index] ¬ [[0, sn], [0, dn], 0, 0, 0, 0];		(data[index].n1 = allNets) AND (data[index].n2 = allNets) =>		   NULL;  -- catch all.		ENDCASE => LOOP;	      data[index].age ¬ System.GetClockPulses[];	      data[index].bytes ¬ data[index].bytes + bb.pupLength;	      data[index].pkts ¬ data[index].pkts + 1;	      IF tool.mode = bytes THEN		data[index].value ¬ data[index].value + bb.pupLength	      ELSE data[index].value ¬ data[index].value + 1;	      EXIT;	      END;  -- pup	    ENDCASE => NULL;  -- other garbage we don't know how to interpret.	  ENDLOOP;	END;  -- interesting host.      END;  -- if running.    SELECT TRUE FROM      (function = send) => RETURN[b];      (dll.ethernetDest = me) => RETURN[b];      (dll.ethernetDest = all) => RETURN[b];      ENDCASE => {Buffer.ReturnBuffer[b]; RETURN[NIL]};    END;  -- Spy          Start: FormSW.ProcType =    BEGIN    ENABLE      AddressTranslation.Error => GOTO chError;    IF running THEN RETURN;    IF (tool.hostString # NIL) AND (tool.hostString.length # 0) THEN      host ¬ LOOPHOLE[      AddressTranslation.StringToNetworkAddress[tool.hostString].addr.host];    tool.started ¬ System.GetGreenwichMeanTime[];    IF tool.mode = pkts THEN scale ¬ 1    ELSE scale ¬ 100;    data[LAST[Range]] ¬ [allNets, allNets, 0, 0, 0, 0];    updater ¬ FORK Updater[];    [] ¬ DataLinkControl.AdjustInputQueueLength[      ethernet, 0, dispatcherBuffers / 2];    buffers ¬ Buffer.MakePool[dispatcherBuffers, 0];  --get large pool    Driver.ChangeNumberOfInputBuffers[TRUE];    FOR device: Device ¬ Driver.GetDeviceChain[], device.next      UNTIL device = NIL DO      IF device.device = ethernet THEN        Protocol1.SetMaximumBufferSize[device, NIL, 1500];      ENDLOOP;    EXITS chError => UserTerminal.BlinkDisplay[];    END;  -- Start          Stop: FormSW.ProcType =    BEGIN    IF ~running THEN RETURN;    Driver.ChangeNumberOfInputBuffers[FALSE];    FOR device: Device ¬ Driver.GetDeviceChain[], device.next      UNTIL device = NIL DO      IF device.device = ethernet THEN        Protocol1.SetMaximumBufferSize[device, NIL, 0];      ENDLOOP;    [] ¬ DataLinkControl.AdjustInputQueueLength[ethernet, 0, 5];    Buffer.DestroyPool[buffers];  --give pool back    running ¬ FALSE;     stopTime ¬ System.GetClockPulses[];    tool.stopped ¬ System.GetGreenwichMeanTime[];    Process.Abort[updater];    JOIN updater;    END;  -- Stop          Updater: ENTRY PROC =    BEGIN    running ¬ TRUE;    Process.SetPriority[Process.priorityBackground];    DO      ENABLE ABORTED => EXIT;      WAIT interval;  --one second      IF graph = NIL THEN LOOP;      FOR index: Range IN Range DO        value: LONG CARDINAL ¬ data[index].value;        data[index].value ¬ 0;	IF value # 0 THEN	  BEGIN          IF history[index].new = 0 THEN DisplayNet[index];	  history[index].old ¬ history[index].new;	  value ¬ value + scale/2 + 1;	  value ¬ value/LONG[scale];	  history[index].new ¬ history[index].new + Inline.LowHalf[value];	  DisplayBar[index];	  END;	ENDLOOP;      ENDLOOP;    END;      -- Mainline code    Init[];      END...    
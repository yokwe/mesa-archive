-- File: SppConnectImpl.mesa - last edit:-- AOF                 28-Jun-87 13:58:11-- Copyright (C) 1984, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [Error, PrintError, StringToNetworkAddress],  Buffer USING [ReturnBuffer],  CourierProtocol USING [dataSST, Protocol3Body],  Driver USING [ChangeNumberOfInputBuffers, Device, GetDeviceChain],  IEEE8023 USING [Encapsulation, EncapObject],  Exec USING [    AddCommand, ExecProc, FreeTokenString, GetToken, OutputProc, RemoveCommand],  Format USING [Decimal, StringProc, LongDecimal, HostNumber],  Heap USING [Create, Delete],  Inline USING [DBITSHIFT, HighHalf, LongDiv],  NetworkStream USING [closeReplySST],  NSBuffer USING [AccessHandle, Body, DestroyPool, MakePool],  NSTypes USING [ConnectionID],  PacketStream USING [unknownConnID],  Protocol1 USING [SetMaximumBufferSize],  Router USING [FindMyHostID],  Runtime USING [DivideCheck],  SpecialCommunication USING [SetSpyProc, SpyProc, SetEthernetListener],  String USING [AppendChar, AppendString, AppendLongDecimal, StringToNumber],  System USING [    GetGreenwichMeanTime, HostNumber, broadcastHostNumber, GetClockPulses,    PulsesToMicroseconds, Pulses, MicrosecondsToPulses, nullHostNumber],  Time USING [Append, Unpack];    SppConnectImpl: PROGRAM  <<  This is not a monitor 'cause it has only a single process muck'n  with the tables.  >>    IMPORTS      AddressTranslation, Buffer, NSBuffer, Driver, Exec, Format, Protocol1,      Router, SpecialCommunication, String, System, Time, Heap, Inline, Runtime    EXPORTS Buffer =  BEGIN  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  unit: CARDINAL = 1;  time: LONG CARDINAL;  zone: UNCOUNTED ZONE;  program: CARDINAL ¬ 0;  deadTime: LONG CARDINAL;  aH: NSBuffer.AccessHandle;  collected: LONG POINTER TO Collected;  oldSpy: SpecialCommunication.SpyProc ¬ NIL;  me: System.HostNumber = Router.FindMyHostID[];  all: System.HostNumber = System.broadcastHostNumber;  apparent: System.HostNumber ¬ System.nullHostNumber;  list: RECORD[head, tail: List, count: CARDINAL];  Index: TYPE = CARDINAL[0..256);  History: TYPE = LONG POINTER TO Histogram;  Histogram: TYPE = RECORD[    total: LONG CARDINAL, count: ARRAY Index OF LONG CARDINAL];  Allocates: TYPE = RECORD[    total: LONG CARDINAL, count: ARRAY INTEGER[0..6) OF LONG CARDINAL];  Collected: TYPE = RECORD[    bulk, system, data, attn: LONG CARDINAL ¬ 0,    open, close, duration, program, procedure: Histogram ¬ [0, ALL[0]],    alloc: Allocates ¬ [0, ALL[0]]];  logOpen: CARDINAL = 8;  logClose: CARDINAL = 2;  logDuration: CARDINAL = 8;  logProgram: CARDINAL = 0;  logProcedure: CARDINAL = 0;  logAlloc: CARDINAL = 0;  List: TYPE = LONG POINTER TO ListObject;  ListObject: TYPE = RECORD[    fwd, bwd: List ¬ NIL, cu, cs: Connection ¬ NULL,    state: State ¬ establishing, time: System.Pulses ¬ NULL];  Connection: TYPE = RECORD[host: System.HostNumber, conn: NSTypes.ConnectionID];  State: TYPE = {establishing, established, idle, busy, dead};    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      Initialize: PROCEDURE =    BEGIN    zone ¬ Heap.Create[4];  --to build from    collected ¬ zone.NEW[Collected];    aH ¬ NSBuffer.MakePool[send: 0, receive: 50];    deadTime ¬ System.MicrosecondsToPulses[LONG[30] * 1000000];  --30 seconds    Driver.ChangeNumberOfInputBuffers[TRUE];  --allocates extra buffers    FOR device: Device ¬ Driver.GetDeviceChain[], device.next      UNTIL device = NIL DO      IF device.device = ethernet THEN        Protocol1.SetMaximumBufferSize[device, NIL, 1500];      ENDLOOP;    oldSpy ¬ SpecialCommunication.SetSpyProc[SpyProc, ns];    [] ¬ SpecialCommunication.SetEthernetListener[unit, all];    collected­ ¬ []; list ¬ [NIL, NIL, 0];    time ¬ System.GetGreenwichMeanTime[];    Exec.AddCommand["SppConnect.~"L, ExecEntry, Unload];    END;  --Initialize  Unload: Exec.ExecProc =    BEGIN    Exec.RemoveCommand[h, "SppConnect.~"L];    [] ¬ SpecialCommunication.SetEthernetListener[unit, me];    [] ¬ SpecialCommunication.SetSpyProc[NIL, ns]; oldSpy ¬ NIL;    Driver.ChangeNumberOfInputBuffers[FALSE];    FOR device: Device ¬ Driver.GetDeviceChain[], device.next      UNTIL device = NIL DO      IF device.device = ethernet THEN        Protocol1.SetMaximumBufferSize[device, NIL, 0];      ENDLOOP;    NSBuffer.DestroyPool[aH];  --gun the buffers    Heap.Delete[zone];  --lots easier than deleting each node    END;  --Unload  ExecEntry: Exec.ExecProc =    BEGIN    output: Format.StringProc = Exec.OutputProc[h];    stringProc: Format.StringProc = {String.AppendString[string, s]};    print: PROC[length, log: CARDINAL, data: History, compress: CARDINAL] =      BEGIN      i, j: CARDINAL;      percent, value: LONG CARDINAL;      FOR i IN[0..length] DO        value ¬ 0;	j ¬ i;	FOR i IN[i..length] DO 	  IF (value ¬ value + data.count[i]) = 0 THEN EXIT;	  percent ¬ (value * LONG[100]) / data.total;	  SELECT TRUE FROM	    (i = length) => NULL;  --have to print now	    (percent <= compress) => LOOP;  --wait till next time	    ENDCASE;	  UNTIL (string.length MOD 26) = 0 DO	    String.AppendChar[string, ' ]; ENDLOOP;	  String.AppendChar[string, '[];	  String.AppendLongDecimal[string, Inline.DBITSHIFT[LONG[j], log]];	  String.AppendString[string, ".."L];	  String.AppendLongDecimal[string, Inline.DBITSHIFT[LONG[i + 1], log]];	  String.AppendString[string, "): "L];	  String.AppendLongDecimal[string, value];	  String.AppendChar[string, '(];	  String.AppendLongDecimal[string, percent];	  String.AppendString[string, ")%"L];	  IF string.length > 60 THEN	    {String.AppendChar[string, 15C]; output[string]; string.length ¬ 0};	  EXIT;  --get's us to the outer loop	  ENDLOOP;	REPEAT FINISHED =>	  IF string.length # 0 THEN	    {String.AppendChar[string, 15C]; output[string]; string.length ¬ 0};	ENDLOOP;      END;  --print    name, switch, string: LONG STRING ¬ NIL;    string ¬ zone.NEW[StringBody[120]];    output["SPP information collected from "L];    Time.Append[string, Time.Unpack[[time]]];    String.AppendString[string, " to "L];    time ¬ System.GetGreenwichMeanTime[];    Time.Append[string, Time.Unpack[[time]]];    output[string]; string.length ¬ 0;    output[" with the apparent host set to ."L];    Format.HostNumber[output, apparent, octal];    output[".\n"L];    IF collected.alloc.total = 0 THEN output["No packets collected\n"L]    ELSE      BEGIN      Format.LongDecimal[output, collected.alloc.total];      output[" total SPP packets observed\n"L];        Format.LongDecimal[output, collected.data]; output["("L];      Format.LongDecimal[output,	((collected.data * 100) / collected.alloc.total)];      output["%) data, "L];        Format.LongDecimal[output, collected.system]; output["("L];      Format.LongDecimal[output,	((collected.system * 100) / collected.alloc.total)];      output["%) system, and "L];        Format.LongDecimal[output, collected.attn]; output["("L];      Format.LongDecimal[output,	((collected.attn * 100) / collected.alloc.total)];      output["%) were attention packets\n"L];        Format.LongDecimal[output, collected.duration.total];      output[" calls were observed, "L];        Format.LongDecimal[output, collected.bulk]; output["("L];      Format.LongDecimal[output,	((collected.bulk * 100) / collected.alloc.total)];      output["%) bulk data packets observed\n"L];        output["Duration of calls matrix (msecs)\n"L];      print[LAST[Index], logDuration, @collected.duration, 2];        output["Frequency of programs called\n"L];      print[LAST[Index], logProgram, @collected.program, 0];        IF program # 0 THEN  	BEGIN	output["Frequency of procedures called in program "L];	Format.Decimal[output, program]; output["\n"L];	print[LAST[Index], logProcedure, @collected.procedure, 0];	END;        Format.LongDecimal[output, collected.open.total];      output[" connection establishments observed\n"L];        output["Time for establishment matrix (msecs)\n"L];      print[LAST[Index], logOpen, @collected.open, 2];        Format.LongDecimal[output, collected.close.total];      output[" connection closings observed\n"L];        output["Matrix of sequence numbers at close\n"L];      print[LAST[Index], logClose, @collected.close, 2];        output["Matrix of allocations observed\n"L];      print[5, logAlloc, LOOPHOLE[@collected.alloc], 0];      END;    collected­ ¬ [];  --reset the counters    time ¬ System.GetGreenwichMeanTime[];  --reset time    zone.FREE[@string];  --give string back    --UNTIL switch = NIL-- DO      [name, switch] ¬ Exec.GetToken[h];      IF switch = NIL THEN EXIT;  --that's how we get out      SELECT switch[0] FROM	'h, 'H =>	  BEGIN	  ENABLE AddressTranslation.Error =>	    {AddressTranslation.PrintError[errorRecord, output]; CONTINUE};	  apparent ¬ IF name = NIL THEN System.nullHostNumber	  ELSE AddressTranslation.StringToNetworkAddress[name].addr.host;	  output["Apparent host set to ."L];	  Format.HostNumber[output, apparent, octal]; output[".\n"L];	  END;	'p, 'P =>	  BEGIN	  program ¬ IF name = NIL THEN 0 ELSE String.StringToNumber[name];	  output["Collecting procedure matrix for program "L];	  output[name]; output["\n"L];	  END;	ENDCASE;      switch ¬ Exec.FreeTokenString[switch];  --drop him ot      IF name # NIL THEN name ¬ Exec.FreeTokenString[name];  --even if failed      ENDLOOP;    IF name # NIL THEN name ¬ Exec.FreeTokenString[name];  --even if failed    END;  --ExecEntry  AddConnection: PROC[t: List] =    BEGIN    IF (t.fwd ¬ list.head) # NIL THEN list.head.bwd ¬ t ELSE list.tail ¬ t;    list.head ¬ t; list.count ¬ list.count + 1;    END;  --AddConnection  LocateConnection: PROC[bb: NSBuffer.Body] RETURNS[t: List] =    BEGIN    fwd: List;    time: System.Pulses = System.GetClockPulses[];    c1: Connection ¬ [bb.source.host, bb.sourceConnectionID];    c2: Connection ¬ [bb.destination.host, bb.destinationConnectionID];    FOR t ¬ list.head, fwd UNTIL t = NIL DO      IF (c1 = t.cu) THEN {t.cs ¬ c2; EXIT};      IF (c2 = t.cu) THEN {t.cs ¬ c1; EXIT};      fwd ¬ t.fwd;  --just in case we delete the node      IF (time - t.time) > deadTime THEN {RemoveConnection[t]; zone.FREE[@t]};      ENDLOOP;    END;  --LocateConnection  RemoveConnection: PROC[t: List] =    BEGIN    IF t.bwd = NIL THEN list.head ¬ t.fwd  --beginning of list    ELSE t.bwd.fwd ¬ t.fwd;  --copy back pointer    IF t.fwd = NIL THEN list.tail ¬ t.bwd  --end of list    ELSE t.fwd.bwd ¬ t.bwd;  --copy forward pointer    list.count ¬ list.count - 1;  --obviously    END;  --RemoveConnection  EnterConnection: PROC[bb: NSBuffer.Body] =    BEGIN    t: List;    IF (t ¬ LocateConnection[bb]) # NIL THEN      t.time ¬ System.GetClockPulses[]    ELSE      BEGIN      t ¬ zone.NEW[ListObject ¬ [	time: System.GetClockPulses[], state: establishing,	cu: [bb.source.host, bb.sourceConnectionID],	cs: [bb.destination.host, bb.destinationConnectionID]]];      AddConnection[t];  --put it in the table      END;    END;  --  EnterConnection  LogConnection: PROC[bb: NSBuffer.Body] =    BEGIN    ENABLE Runtime.DivideCheck => CONTINUE;    t: List;    index: Index;    msecs: CARDINAL;    time: System.Pulses;    IF (t ¬ LocateConnection[bb]) = NIL THEN RETURN;  --doesn't exist    IF t.state # establishing THEN RETURN;  --not of interest to me    time ¬ [System.GetClockPulses[] - t.time];  --this is how long it took    msecs ¬ Inline.LongDiv[      System.PulsesToMicroseconds[time], 1000 * logOpen];  --msec/8    index ¬ MIN[(msecs), LAST[Index]];    collected.open.count[index] ¬ collected.open.count[index] + 1;    collected.open.total ¬ collected.open.total + 1;    t.state ¬ established; t.time ¬ System.GetClockPulses[];    END;  --  LogConnection  LogCourierCall: PROC[bb: NSBuffer.Body] =    BEGIN    ENABLE Runtime.DivideCheck => CONTINUE;    t: List;    index: Index;    msecs: CARDINAL;    time: System.Pulses ¬ System.GetClockPulses[];  --record time    p: LONG POINTER TO CourierProtocol.Protocol3Body ¬ LOOPHOLE[@bb.sppBody];    IF (t ¬ LocateConnection[bb]) = NIL THEN RETURN;  --doesn't exist    WITH m: p SELECT FROM      call =>        BEGIN	IF t.state # busy THEN  --ignore if already busy	  {t.state ¬ busy; t.time ¬ time; RETURN};	index ¬ MIN[CARDINAL[Inline.HighHalf[m.program]], CARDINAL[LAST[Index]]];	collected.program.count[index] ¬ collected.program.count[index] + 1;	collected.program.total ¬ collected.program.total + 1;	IF Inline.HighHalf[m.program] = program THEN	  BEGIN	  index ¬ MIN[m.procedure, CARDINAL[LAST[Index]]];	  collected.procedure.count[index] ¬ collected.procedure.count[index] + 1;	  collected.procedure.total ¬ collected.procedure.total + 1;	  END;	END;      return, reject, abort =>        BEGIN	IF t.state # busy THEN RETURN;  --we don't know the start	time ¬ [time - t.time];  --duration of the call	msecs ¬ Inline.LongDiv[	  System.PulsesToMicroseconds[time], 1000 * logDuration];	index ¬ MIN[msecs, LAST[Index]];	collected.duration.count[index] ¬ collected.duration.count[index] + 1;	t.state ¬ idle;  --end of that call	collected.duration.total ¬ collected.duration.total + 1;	END;      ENDCASE;    END;  --  LogCourierCall  LogClose: PROC[bb: NSBuffer.Body] =    BEGIN    t: List;    index: Index = MIN[(bb.sequenceNumber / logOpen), LAST[Index]];    collected.close.count[index] ¬ collected.close.count[index] + 1;    collected.close.total ¬ collected.close.total + 1;    IF (t ¬ LocateConnection[bb]) # NIL THEN      {RemoveConnection[t]; zone.FREE[@t]};    END;  --LogClose  SpyProc: SpecialCommunication.SpyProc =    --PROC[b: Buffer.Buffer] RETURNS[Buffer.Buffer]    BEGIN    Collect: PROC =       BEGIN      alloc ¬ INTEGER[bb.allocationNumber - bb.acknowledgeNumber + 1];      alloc ¬ MAX[MIN[alloc, LENGTH[collected.alloc.count]], 0];      collected.alloc.count[alloc] ¬ collected.alloc.count[alloc] + 1;      collected.alloc.total ¬ collected.alloc.total + 1;      IF bb.attention THEN collected.attn ¬ collected.attn + 1;      IF bb.systemPacket THEN collected.system ¬ collected.system + 1      ELSE collected.data ¬ collected.data + 1;      SELECT TRUE FROM       (bb.destinationConnectionID = PacketStream.unknownConnID) =>         EnterConnection[bb];  --new connection being created       (bb.systemPacket) =>         IF bb.sequenceNumber = 0 THEN LogConnection[bb];  --connection done       (bb.subtype = 1) =>         collected.bulk ¬ collected.bulk + 1;  --just keepin track       (bb.subtype = NetworkStream.closeReplySST) =>         LogClose[bb];  --connection 'bout to die       (bb.subtype = CourierProtocol.dataSST) =>         LogCourierCall[bb];  --call, return, other?       ENDCASE;      END;    alloc: INTEGER;    llc: IEEE8023.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];    bb: NSBuffer.Body = LOOPHOLE[llc + SIZE[IEEE8023.EncapObject]];    IF oldSpy # NIL THEN      {b ¬ oldSpy[b, function]; IF b = NIL THEN RETURN[b]};    SELECT TRUE FROM      (bb.packetType # sequencedPacket) => NULL;      (apparent = System.nullHostNumber) => Collect[];      (llc.ethernetDest = LOOPHOLE[apparent]) => Collect[];      (llc.ethernetSource = LOOPHOLE[apparent])  => Collect[];      ENDCASE;    SELECT TRUE FROM      (b.fo.function = send) => RETURN[b];      (llc.ethernetDest = LOOPHOLE[me]) => RETURN[b];      (llc.ethernetDest = LOOPHOLE[all]) => RETURN[b];      ENDCASE => {Buffer.ReturnBuffer[b]; RETURN[NIL]};    END;      -- Mainline code:    Initialize[];    END.
-- File: WSITest.mesa - last edit:-- KAM                 15-Apr-85 11:28:14-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Exec,  Format,  Heap,  Listener,  Profile,  String,  System,  WSInfoClient;WSITest: PROGRAM  IMPORTS Exec, Format, Heap, Listener, Profile, String, WSInfoClient =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;  Info: TYPE = LONG POINTER TO InfoSeq;  InfoRec: TYPE = RECORD [    who: System.NetworkAddress,    userName: LONG STRING];  InfoSeq: TYPE = RECORD [s: SEQUENCE count: CARDINAL OF InfoRec];  ExecProc: Exec.ExecProc = {    net: System.NetworkNumber ¬ System.nullNetworkNumber;    reply: WSInfoClient.Reply;    probes: CARDINAL;    info: Info;    Out: Format.StringProc = Exec.OutputProc[h];    IF NOT Exec.EndOfCommandLine[h] THEN {      token, switches: LONG STRING;      [token, switches] ¬ Exec.GetToken[h];      switches ¬ Exec.FreeTokenString[switches];      net ¬ Net[        String.StringToLongNumber[token, 8 ! String.InvalidNumber => CONTINUE]];      token ¬ Exec.FreeTokenString[token]};    Out["Searching... "L];    [reply, probes] ¬ WSInfoClient.FindWSOnNet[net];    Format.Decimal[Out, reply.count];    Out[" replies in "L];    Format.Decimal[Out, probes];    Out[" probes\n"L];    IF reply.count = 0 THEN RETURN;    info ¬ z.NEW[InfoSeq [reply.count]];    Out["Collecting information... "L];    FOR i: CARDINAL IN [0..reply.count) DO      ok: BOOLEAN;      info[i].who ¬ [net: net, host: reply[i], socket: System.nullSocketNumber];      info[i].userName ¬ z.NEW[StringBody [100]];      ok ¬ WSInfoClient.GetClientInfo[        info[i].who, firstFree, GetData, info[i].userName];      ENDLOOP;    FOR i: CARDINAL IN [0..info.count) DO      Format.NetworkAddress[Out, info[i].who, octal];      Out["\t"L];      Out[info[i].userName];      Out["\n"L];      ENDLOOP;    FOR i: CARDINAL IN [0..info.count) DO      z.FREE[@info[i].userName];      ENDLOOP;    z.FREE[@info]};  CourierString: TYPE = RECORD[    length: CARDINAL,     chars: PACKED ARRAY [0..0) OF CHARACTER];      GetData: PROC[    data: LONG POINTER, size: CARDINAL, clientData: LONG POINTER] = {    s: LONG STRING ¬ clientData;    cs: LONG POINTER TO CourierString ¬ data;    s.length ¬ 0;    FOR i: CARDINAL IN [0..cs.length) DO      IF cs.chars[i] = '\000 THEN EXIT;      String.AppendChar[s, cs.chars[i]];      ENDLOOP;    };    Net: PROCEDURE [x: LONG UNSPECIFIED] RETURNS [System.NetworkNumber] = {    Long: TYPE = MACHINE DEPENDENT RECORD [a(0), b(1): UNSPECIFIED];    u, v: Long;    u ¬ LOOPHOLE[x];    [a: v.b, b: v.a] ¬ u;    RETURN[LOOPHOLE[v]]};  GetName: Listener.InfoProc = {    cs: LONG POINTER TO CourierString ¬ data;    i: CARDINAL;    GetIt: PROC[name, password: LONG STRING] = {      len: CARDINAL ¬ String.Length[name];      cs.length ¬ len;      FOR i IN [0.. len) DO        cs.chars[i] ¬ name[i];        ENDLOOP;      IF (len MOD 2) = 1 THEN {        cs.chars[len] ¬ '\000;	len ¬ len + 1;	};      length ¬ 1 + len/2;      };    IF packetType # firstFree THEN RETURN;    Profile.GetUser[GetIt, clearinghouse];    };    Init: PROCEDURE = {    Listener.Register[firstFree, GetName];    Exec.AddCommand["WSITest.~"L, ExecProc]};  Init[];  END...
-- File: EtherIOGraphImpl.mesa - last edit:-- AOF                 18-May-88  8:44:35-- Copyright (C) 1984, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [Error, StringToNetworkAddress],  Buffer USING [    Buffer, MakePool, DestroyPool, AccessHandle, ReturnBuffer, Type],  DataLinkControl USING [AdjustInputQueueLength],  Display USING [Black, White],  IEEE8023 USING [Encapsulation],  Driver USING [Device, GetDeviceChain],  Exec USING [AddCommand, ExecProc, RemoveCommand],  File USING [nullFile],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, EnumeratedItem,    Enumerated, EnumeratedNotifyProcType, newLine, ProcType, StringItem,    DisplayItem],  Heap USING [systemZone],  Inline USING [LongDiv, LongMult, LowHalf],  Process USING [    Abort, EnableAborts, SetTimeout, SecondsToTicks, priorityBackground,    SetPriority],  Protocol1 USING [SetMaximumBufferSize],  Router USING [FindMyHostID],  Runtime USING [GetBcdTime, ZeroDivisor],  SpecialCommunication USING [    SetSpyProc, SpyProc, SetEthernetListener, SpyType],  SpecialSystem USING [HostNumber],  Space USING [Interval, Kill, Map, Unmap],  String USING [AppendString],  System USING [    broadcastHostNumber, GetClockPulses, HostNumber, MicrosecondsToPulses],  Time USING [Append, AppendCurrent, Unpack],  Tool USING [AddThisSW, Create, Destroy, MakeFormSW, MakeSWsProc],  ToolWindow USING [CreateSubwindow, DisplayProcType, TransitionProcType],  UserTerminal USING [BlinkDisplay, screenHeight],  Window USING [Handle],  WindowFont USING [CharWidth];EtherIOGraphImpl: MONITOR  IMPORTS    Buffer, DataLinkControl, Driver, Exec, FormSW, Inline, Process,    Protocol1, Router, Runtime, SpecialCommunication, String, System,    Time, Tool, Space, ToolWindow, Display, Heap, WindowFont,    AddressTranslation, UserTerminal  EXPORTS Buffer, System =  BEGIN  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  HostNumber: PUBLIC <<System>> TYPE = SpecialSystem.HostNumber;  wh: Window.Handle;  form, graph: Window.Handle ¬ NIL;  oldSpy: ARRAY Buffer.Type OF SpecialCommunication.SpyProc;    updater: PROCESS;  interval: CONDITION;  secondsPerInterval: CARDINAL ¬ 1;  pulsesPerSec: LONG CARDINAL = System.MicrosecondsToPulses[1000000];  pulsesPerInterval: LONG CARDINAL ¬ pulsesPerSec;  bytesPerSecond: ARRAY LineType OF LONG CARDINAL = [    10000000/LONG[8], 9600/8, 4800/8, 2400/8, 1200/8, 300/8];  running: BOOLEAN ¬ FALSE;  buffers: Buffer.AccessHandle ¬ NIL;  dispatcherBuffers: CARDINAL = 90;  space: Space.Interval;    lineType: LineType ¬ ethernet;  LineType: TYPE = {    ethernet, phone96, phone48, phone24, phone12, phone3};  periodType: PeriodType ¬ seconds;  PeriodType: TYPE = {seconds, minutes, hours};  deflection: Scales ¬ tenth;  scale: LONG CARDINAL ¬ 10;  Scales: TYPE = {full, tenth, hundredth, thousandth};  watch: WatchType ¬ both;  WatchType: TYPE = {input, output, both};  observee: LONG STRING ¬ NIL;  filter: HostNumber ¬ System.broadcastHostNumber;  leftEdgeTime: LONG STRING ¬ NIL;    me: HostNumber = Router.FindMyHostID[];  all: HostNumber = System.broadcastHostNumber;    LongSeen: TYPE = RECORD [in, out: LONG CARDINAL];  bytesSeen: LongSeen ¬ [0, 0];  unit: CARDINAL = 1;    Seen: TYPE = RECORD[in, out: CARDINAL];  Range: TYPE = [0..1000);  History: TYPE = PACKED ARRAY Range OF Seen;  history: LONG DESCRIPTOR FOR History;  finger: Range ¬ 0;  margin: NATURAL = 10;  barHeight: NATURAL = 2;  gridHeight: NATURAL = 1;  barWidth: NATURAL = LAST[Range] + 1;  gridWidth: NATURAL = LAST[Range] + 1;  width: NATURAL = barWidth + (2 * margin);  height: NATURAL = MIN[UserTerminal.screenHeight, 600];  graphHeight: NATURAL = height - barHeight - (2 * margin);  gridSpace: NATURAL = graphHeight / 10;  bottomOfBar: NATURAL = height - margin;  topOfBar: NATURAL = bottomOfBar - barHeight;  axis: NATURAL = (graphHeight / 2) + (2 * barHeight) + margin;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ExecCall: Exec.ExecProc = {};  --ExecCall  Unload: Exec.ExecProc =    BEGIN    Tool.Destroy[wh];  --get rid of tool (calls ClientTransition)    Exec.RemoveCommand[h, "EtherIOGraph.~"L];    END;  --Unload    Initialize: PROCEDURE =    BEGIN    herald: STRING ¬ [60];    Process.SetTimeout[@interval, Process.SecondsToTicks[secondsPerInterval]];    Process.EnableAborts[@interval];    Exec.AddCommand[name: "EtherIOGraph.~"L, proc: ExecCall, unload: Unload];    String.AppendString[to: herald, from: "Ether Input|Output Graph of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 8;  -- omit hours, mins, zone.    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: herald,      initialBox: [[x: 0, y: 619 ],[w: 1024, h: graphHeight + 59]]];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    graph ¬ ToolWindow.CreateSubwindow[parent: window, display: DisplayGraph];    Tool.AddThisSW[window: window, sw: graph, swType: vanilla, h: height];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    END;  DisplayGraph: ToolWindow.DisplayProcType =    BEGIN    DrawGraphPaper[];    ShowDots[];    END;  DrawAnotherLine: PROCEDURE [in, out: CARDINAL] =    BEGIN    thumb: Range = (finger + 10) MOD (LAST[Range] + 1);    pinky: Range = (finger - 10) MOD (LAST[Range] + 1);    in ¬ Inline.LongDiv[Inline.LongMult[in, graphHeight], 100];    out ¬ Inline.LongDiv[Inline.LongMult[out, graphHeight], 100];    history[finger] ¬ [in, out];    ShowNewDots[finger];    IF finger = 0 THEN      BEGIN      leftEdgeTime.length ¬ 0;      Time.AppendCurrent[leftEdgeTime];      FormSW.DisplayItem[form, 6];      END;    finger ¬ IF finger = LAST[Range] THEN 0 ELSE SUCC[finger];    history[thumb] ¬ [0, 0];  -- clear out a bit of space ahead    EraseDots[thumb];    FOR i: CARDINAL IN(0..graphHeight] DO    --redraw grid behind current graph finger      IF (i MOD gridSpace) # 0 THEN LOOP;      Display.Black[        graph,[[margin+pinky,topOfBar-i],[1,gridHeight]]];      ENDLOOP;    Display.Black[graph,[[margin+pinky, axis-barHeight/2], [1, barHeight]]];    END;      DrawGraphPaper: PROCEDURE =    BEGIN    i: CARDINAL;    delta: CARDINAL = SELECT periodType FROM      seconds, minutes => 60, ENDCASE => 24;    Display.White[graph,[[0,0],[width,height]]];    Display.Black[graph,[[margin,topOfBar],[barWidth,barHeight]]];    Display.Black[graph,[[margin,axis-barHeight/2],[gridWidth,barHeight]]];    FOR i IN(0..graphHeight] DO      IF (i MOD gridSpace) # 0 THEN LOOP;      Display.Black[        graph,[[margin, topOfBar-i], [gridWidth, gridHeight]]];      ENDLOOP;    END;      ShowDots: PROCEDURE =    BEGIN    FOR i: Range IN Range DO ShowNewDots[i]; ENDLOOP;    END;      ShowNewDots: PROCEDURE [i: Range] =    BEGIN    in, out: CARDINAL;    in ¬ history[i].in; out ¬ history[i].out;    IF (in+out) # 0 THEN Display.Black[      graph,[[margin+i, axis-out],[1, out+in]]];    END;  EraseDots: PROCEDURE [i: Range] =    BEGIN    Display.White[graph,[[margin+i,topOfBar-graphHeight],[1,graphHeight]]];    END;  MakeForm: FormSW.ClientItemsProcType --RETURNS [items, freeDesc]--  =    BEGIN    nItems: CARDINAL = 7;    scales: ARRAY [0..4) OF FormSW.Enumerated ¬ [      ["50%"L, Scales[full]], ["5%"L, Scales[tenth]],      ["0.5%"L, Scales[hundredth]], ["0.05%"L, Scales[thousandth]]];    lines: ARRAY [0..6) OF FormSW.Enumerated ¬ [      ["10 Mbit"L, LineType[ethernet]], ["9.6 Kbit"L, LineType[phone96]],      ["4.8 Kbit"L, LineType[phone48]], ["2.4 Kbit"L, LineType[phone24]],      ["1.2 Kbit"L, LineType[phone12]], ["300 bps"L, LineType[phone3]]];    periods: ARRAY [0..3) OF FormSW.Enumerated ¬ [      ["seconds"L, PeriodType[seconds]],      ["minutes"L, PeriodType[minutes]],      ["hours"L, PeriodType[hours]]];    watches: ARRAY [0..3) OF FormSW.Enumerated ¬ [      ["input"L, WatchType[input]],      ["output"L, WatchType[output]],      ["both"L, WatchType[both]]];    box: CARDINAL = WindowFont.CharWidth['0]*18;    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[0] ¬ FormSW.CommandItem[      tag: "Reset"L, proc: Reset, place: FormSW.newLine];    items[1] ¬ FormSW.EnumeratedItem[      tag: "Full deflection is"L, choices: DESCRIPTOR[scales],      value: @deflection, proc: Scale];    items[2] ¬ FormSW.EnumeratedItem[      tag: "Period"L, choices: DESCRIPTOR[periods], value: @periodType,      proc: Period];    items[3] ¬ FormSW.EnumeratedItem[      tag: "Medium"L, choices: DESCRIPTOR[lines], value: @lineType];    items[3] ¬ FormSW.CommandItem[      tag: "Interpret Address"L, proc: Translate];    items[4] ¬ FormSW.StringItem[      tag: "Observe only"L, string: @observee, boxWidth: box, inHeap: TRUE];    items[5] ¬ FormSW.EnumeratedItem[      tag: "watching"L, choices: DESCRIPTOR[watches], value: @watch];    items[6] ¬ FormSW.StringItem[      tag: "Time at left edge"L, readOnly: TRUE, string: @leftEdgeTime];    RETURN[items: items, freeDesc: TRUE];    END;    Translate: FormSW.ProcType =    BEGIN    IF observee # NIL AND (observee.length # 0) THEN      BEGIN      filter ¬ AddressTranslation.StringToNetworkAddress[observee !        AddressTranslation.Error => GOTO blink].addr.host;      RETURN;      EXITS blink => UserTerminal.BlinkDisplay[];      END;    filter ¬ System.broadcastHostNumber;    END;    Scale: FormSW.EnumeratedNotifyProcType =    BEGIN    scale ¬ SELECT deflection FROM      full => 1, tenth => 10, hundredth => 100, ENDCASE => 1000;    END;  Period: FormSW.EnumeratedNotifyProcType =    BEGIN    secondsPerInterval ¬ SELECT periodType FROM      seconds => 1, minutes => 60, ENDCASE => 60*60;    pulsesPerInterval ¬ pulsesPerSec * secondsPerInterval;    Process.SetTimeout[@interval, Process.SecondsToTicks[secondsPerInterval]];    Reset[];    END;    Reset: FormSW.ProcType =    BEGIN    FOR i: Range IN Range DO history[i] ¬ [0, 0]; ENDLOOP;    finger ¬ 0;    DrawGraphPaper[];    END;      ClientTransition: ToolWindow.TransitionProcType =    BEGIN    Area: TYPE = RECORD[history: History];    SELECT TRUE FROM      (old = inactive) =>        BEGIN	area: LONG POINTER TO Area;	length: CARDINAL = (SIZE[Area]+255)/255;	space ¬ Space.Map[window: [File.nullFile, 0, length], class: data];	area ¬ space.pointer;	history ¬ DESCRIPTOR[area.history];        FOR i: Range IN Range DO history[i] ¬ [0, 0]; ENDLOOP;	finger ¬ 0;	Translate[];	leftEdgeTime ¬ Heap.systemZone.NEW[StringBody[20] ¬	  [length: 0, maxlength: 20, text: ]];	Time.AppendCurrent[leftEdgeTime];	updater ¬ FORK Updater[];	buffers ¬ Buffer.MakePool[dispatcherBuffers, 0];  --get large pool        --Driver.ChangeNumberOfInputBuffers[TRUE];	[] ¬ DataLinkControl.AdjustInputQueueLength[	  ethernet, 0, dispatcherBuffers / 2];	FOR device: Device ¬ Driver.GetDeviceChain[], device.next	  UNTIL device = NIL DO	  IF device.device = ethernet THEN	    Protocol1.SetMaximumBufferSize[device, NIL, 1500];	  ENDLOOP;	[] ¬ SpecialCommunication.SetEthernetListener[unit, all];	FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	  oldSpy[type] ¬ SpecialCommunication.SetSpyProc[SpyProc, type];	  ENDLOOP;	END;      (new = inactive) =>        BEGIN        [] ¬ SpecialCommunication.SetEthernetListener[unit, me];	FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	  [] ¬ SpecialCommunication.SetSpyProc[NIL, type];  --wipe out spy	  ENDLOOP;        --Driver.ChangeNumberOfInputBuffers[FALSE];	[] ¬ DataLinkControl.AdjustInputQueueLength[ethernet, 0, 5];	FOR device: Device ¬ Driver.GetDeviceChain[], device.next	  UNTIL device = NIL DO	  IF device.device = ethernet THEN	    Protocol1.SetMaximumBufferSize[device, NIL, 0];	  ENDLOOP;        Buffer.DestroyPool[buffers];  --give pool back	running ¬ FALSE; Process.Abort[updater]; JOIN updater;	form ¬ graph ¬ NIL;	Space.Kill[space];	[] ¬ Space.Unmap[space.pointer];	Heap.systemZone.FREE[@leftEdgeTime];	END;      ENDCASE;    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Worker routines:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Updater: ENTRY PROC =    BEGIN        percentIn: LONG CARDINAL;  -- percentage of bandwidth used as input    percentOut: LONG CARDINAL;  -- percentage of bandwidth used as output    fudge: LONG CARDINAL;  --fraction of interval actually elapsed X 100    in: LONG CARDINAL;  --number of input bytes observed in interval    out: LONG CARDINAL;  --number of output bytes observed in interval    awps: LONG CARDINAL;  --adjusted bytes/seconds assuming 100% net utilization    awpi: LONG CARDINAL;  --adjusted bytes/interval if interval not seconds    start: LONG CARDINAL;  --time when interval started in pulses    stop: LONG CARDINAL;  --time when interval stopped in pulses    elapsed: LONG CARDINAL;  --length of interval in pulses    running ¬ TRUE;    start ¬ System.GetClockPulses[];    Process.SetPriority[Process.priorityBackground];    DO      ENABLE {ABORTED => EXIT; Runtime.ZeroDivisor => CONTINUE};      WAIT interval;      IF graph # NIL THEN        BEGIN        stop ¬ System.GetClockPulses[];	elapsed ¬ stop - start;	start ¬ stop;	in ¬ bytesSeen.in; out ¬ bytesSeen.out;        IF (in + out) = 0 THEN DrawAnotherLine[0, 0]	ELSE	  BEGIN 	  bytesSeen ¬ [0, 0];  --clear counter          fudge ¬ elapsed*LONG[100]/pulsesPerInterval;  --amount to adjust * 100          awps ¬ (bytesPerSecond[lineType]*fudge)/100;  --adjusted bytes/second	  awpi ¬ awps * secondsPerInterval;  --adjusted bytes/interval          percentIn ¬ ((in*scale*LONG[100])/awpi);	  percentOut ¬ ((out*scale*LONG[100])/awpi);	  DrawAnotherLine[	    MIN[Inline.LowHalf[percentIn], 50],	    MIN[Inline.LowHalf[percentOut], 50]];	  END; 	END;      ENDLOOP;    END;    SpyProc: --ENTRY-- SpecialCommunication.SpyProc =    --PROC[b: Buffer.Buffer] RETURNS[BOOLEAN]    BEGIN    seen: Seen;    dll: IEEE8023.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];    IF oldSpy[b.fo.type] # NIL THEN      {b ¬ oldSpy[b.fo.type][b, function]; IF b = NIL THEN RETURN[b]};    WITH b.fo.driver SELECT FROM      ethernet =>        BEGIN	length: CARDINAL ¬ b.fo.driver.length;	rcvr: HostNumber ¬ dll.ethernetDest;	trns: HostNumber ¬ dll.ethernetSource;	IF (lineType = ethernet) THEN	  seen ¬ (SELECT TRUE FROM	    filter = System.broadcastHostNumber =>	      [length, length],	    ((watch = input) OR (watch = both)) AND (rcvr = filter) =>	      [length, 0],	    ((watch = output) OR (watch = both)) AND (trns = filter) =>	      [0, length],	    ENDCASE => [0, 0]);	END;      ENDCASE => seen ¬ [0, 0];    bytesSeen.in ¬ bytesSeen.in + seen.in;    bytesSeen.out ¬ bytesSeen.out + seen.out;    SELECT TRUE FROM      (function = send) => RETURN[b];      (dll.ethernetDest = me) => RETURN[b];      (dll.ethernetDest = all) => RETURN[b];      ENDCASE => {Buffer.ReturnBuffer[b]; RETURN[NIL]};    END;      -- Mainline code:  Initialize[];  END.  LOG15-Aug-84 16:05:41  By: AOF: Post Klamath.20-Sep-86 15:33:22  By: AOF: New buffer manager.28-Jun-87 13:53:22  By: AOF: EtherMAC => IEEE8023. 
-- File: RingBufferImpl.mesa - last edit:-- Marzullo            29-Jan-87  9:46:55-- sma                 26-Jan-87 20:55:48-- Nannette             4-Feb-87 15:17:51			-- Copyright (C) 1987 by Mad Dog Enterprises. All rights reserved.DIRECTORY  Buffer USING [Buffer],  Environment USING [Byte, wordsPerPage],  Inline USING [LongCOPY],  RingBuffer USING [],  Space USING [Interval];RingBufferImpl: PROGRAM IMPORTS Inline EXPORTS RingBuffer =  BEGIN  -- the first six words of the ring buffer space contains the following  -- ring buffer header.  RingState: TYPE = RECORD [    firstData, wordsStored: LONG CARDINAL,    countWritten, countOverwritten: CARDINAL];  ring: Buffer.Buffer ¬ NIL;  state: LONG POINTER TO RingState ¬ NIL;  ringSize: LONG CARDINAL ¬ 0;  Mode: TYPE = {collecting, replaying};  mode: Mode ¬ replaying;  Bug: ERROR = CODE;  lastTouched: LONG CARDINAL;  « A packet buffer is stored in the ring buffer preceeded by the sizeof the packet buffer and the offsets of the network and data link portionsfrom the first part of the packet »  entryOverhead: CARDINAL = SIZE[EntryHeader];  EntryHeader: TYPE = RECORD [    size: CARDINAL, highLayerOffset, linkLayerOffset: CARDINAL];  GetHeader: PROCEDURE [at: LONG CARDINAL] RETURNS [LONG POINTER TO EntryHeader] =    INLINE {RETURN[LOOPHOLE[ring + at]]};  -- Exported procedures  Create: PUBLIC PROCEDURE [interval: Space.Interval] =    BEGIN    state ¬ interval.pointer;    ring ¬ interval.pointer + SIZE[RingState];    ringSize ¬ interval.count * Environment.wordsPerPage - SIZE[RingState];    lastTouched ¬ 0;    mode ¬ replaying    END;  Clear: PUBLIC PROCEDURE =    BEGIN    state.countWritten ¬ state.countOverwritten ¬ 0;    state.firstData ¬ state.wordsStored ¬ lastTouched ¬ 0;    mode ¬ collecting    END;  GetStatus: PUBLIC PROCEDURE RETURNS [startIndex, stopIndex: CARDINAL] =    BEGIN    startIndex ¬ state.countOverwritten;    stopIndex ¬ state.countWritten - 1    END;  Write: PUBLIC PROCEDURE [b: Buffer.Buffer, size: CARDINAL] =    BEGIN    firstFree: LONG CARDINAL;    extraWords: LONG CARDINAL;    pLastTouched: LONG POINTER TO EntryHeader = GetHeader[lastTouched];    IF mode = replaying THEN ERROR Bug;    state.countWritten ¬ SUCC[state.countWritten];    firstFree ¬ (state.firstData + state.wordsStored) MOD ringSize;    state.wordsStored ¬ state.wordsStored + size + entryOverhead;    extraWords ¬ ringSize - (lastTouched + pLastTouched.size + entryOverhead);    «   If there isn't enough room at end of buffer to store contiguous packet    increase the previous data's length so it fills up rest of buffer    and store this packet at front of buffer		»    IF extraWords < size + entryOverhead THEN      BEGIN      pLastTouched.size ¬ pLastTouched.size + CARDINAL[extraWords];      state.wordsStored ¬ state.wordsStored + CARDINAL[extraWords];      firstFree ¬ 0      END;    -- drop packets from ring until there is room for the new packet    WHILE state.wordsStored > ringSize DO      pFirstData: LONG POINTER TO EntryHeader = GetHeader[state.firstData];      wordsDropped: CARDINAL = pFirstData.size + entryOverhead;      state.wordsStored ¬ state.wordsStored - wordsDropped;      state.firstData ¬ (state.firstData + wordsDropped) MOD ringSize;      state.countOverwritten ¬ SUCC[state.countOverwritten]      ENDLOOP;    -- move the packet buffer into the ring buffer and set up its entry header      BEGIN    Delta: PROCEDURE [      lp: LONG POINTER TO PACKED ARRAY INTEGER [0..0) OF Environment.Byte]      RETURNS [CARDINAL] = INLINE {      RETURN[CARDINAL[LOOPHOLE[lp, LONG CARDINAL] - LOOPHOLE[b, LONG CARDINAL]]]};    pFirstFree: LONG POINTER TO EntryHeader = GetHeader[firstFree];    pFirstFree.size ¬ size;    pFirstFree.highLayerOffset ¬ Delta[b.highLayer.blockPointer];    pFirstFree.linkLayerOffset ¬ Delta[b.linkLayer.blockPointer];    Inline.LongCOPY[from: b, nwords: size, to: ring + firstFree + entryOverhead]    END;    lastTouched ¬ firstFree    END;  ReadNext: PUBLIC PROCEDURE [start: BOOLEAN] RETURNS [b: Buffer.Buffer] =    BEGIN    at: LONG CARDINAL;    IF mode = collecting THEN {mode ¬ replaying; start ¬ TRUE};    IF state.countWritten = 0 THEN -- no data collected! -- RETURN[NIL];    at ¬      IF start THEN state.firstData      ELSE        (lastTouched + GetHeader[lastTouched].size + entryOverhead) MOD ringSize;    IF at = (state.firstData + state.wordsStored) MOD ringSize THEN b ¬ NIL    ELSE      -- set internal buffer pointers to new relocated value      BEGIN      ApplyDelta: PROCEDURE [delta: CARDINAL]        RETURNS [          lp: LONG POINTER TO PACKED ARRAY INTEGER [0..0) OF Environment.Byte] =        INLINE {RETURN[LOOPHOLE[b + delta]]};      pAt: LONG POINTER TO EntryHeader = GetHeader[at];      b ¬ LOOPHOLE[ring + at + entryOverhead];      b.highLayer.blockPointer ¬ ApplyDelta[pAt.highLayerOffset];      b.linkLayer.blockPointer ¬ ApplyDelta[pAt.linkLayerOffset];      lastTouched ¬ at      END    END;  END...  LOG22-Jan-87  9:44:54  KAM  Created file.28-Jan-87 17:53:11  KAM  Modified to use new Buffer interface. 4-Feb-87 15:15:05  NS   Fixed a bug in Delta.
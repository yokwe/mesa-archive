-- File: EtherWatchImpl.mesa - last edit:-- AOF                 14-Jun-88 16:16:08-- Copyright (C) 1988 by Xerox Corporation. All rights reserved.-- Create by FormSWLayoutTool on  5-Jun-88  9:51DIRECTORY  Buffer USING [    AccessHandle, Buffer, DestroyPool, Device, MakePool, ReturnBuffer, Type],  DataLinkControl USING [AdjustInputQueueLength],  Display USING [Handle, Text, White],  Driver USING [Device, GetDeviceChain],  Environment USING [bitsPerByte, bytesPerWord],  Exec USING [AddCommand, ExecProc, Handle, RemoveCommand],  Heap USING [Create, Delete],  HostNumbers USING [HostNumber, IsMulticastID],  IEEE8023 USING [Encapsulation, EthernetCRC],  Protocol1 USING [SetMaximumBufferSize],  Router USING [FindMyHostID],  SpecialCommunication USING [    SetEthernetListener, SetSpyProc, SpyProc, SpyType],  SpecialSystem USING [HostNumber],  String USING [AppendLongDecimal],  System USING [    broadcastHostNumber, GetClockPulses, HostNumber, MicrosecondsToPulses,    Pulses, PulsesToMicroseconds],  Tool USING [AddThisSW, Create, Destroy, MakeSWsProc],  ToolWindow USING [Box, CreateSubwindow, DisplayProcType, TransitionProcType],  Window USING [Box, Dims, Handle, Place],  WindowFont USING [CharWidth];EtherWatchImpl: MONITOR  IMPORTS    Buffer, Exec, DataLinkControl, Display, Driver, Heap, HostNumbers,    Protocol1, Router, SpecialCommunication, String, System, Tool, ToolWindow,    WindowFont   EXPORTS Buffer, System = {  Data: TYPE = MACHINE DEPENDENT RECORD [    timesThru: CARDINAL ¬ 0,    sw: Window.Handle ¬ NIL,    lastTime: System.Pulses ¬ [0],    p0Interval: System.Pulses ¬ [0]];  oldSpy: ARRAY Buffer.Type OF SpecialCommunication.SpyProc ¬ ALL[NIL];  b0, b1, b2, b3, b4: LONG CARDINAL ¬ 0;  --for bits/second  p0, p1, p2, p3, p4: LONG CARDINAL ¬ 0;  --for packets/second  unit: NATURAL = 1;  p1Times: NATURAL = 4;  p2Times: NATURAL = 4 * p1Times;  running: BOOLEAN ¬ FALSE;  dispatcherBuffers: NATURAL = 90;  buffers: Buffer.AccessHandle ¬ NIL;  basicInterval: LONG CARDINAL ¬ 5D5;  all: HostNumber = System.broadcastHostNumber;  me: HostNumber = Router.FindMyHostID[];  preamble: CARDINAL = 64 / bpb;  --bytes in preamble  crc: CARDINAL = bpw * SIZE[IEEE8023.EthernetCRC];  ipg: CARDINAL = 96 / bpb;  --bytes in 9.6 uSecs  bpb: NATURAL = Environment.bitsPerByte;  bpw: NATURAL = Environment.bytesPerWord;  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  HostNumber: PUBLIC <<System>> TYPE = SpecialSystem.HostNumber;  FormItems: TYPE = {start, stop};  data: Data ¬ [];  wh: Window.Handle ¬ NIL;  number: LONG STRING ¬ [10];  zone: UNCOUNTED ZONE ¬ Heap.Create[initial: 4];  bTagPlace: Window.Place = [x:124B, y:24B];  pTagPlace: Window.Place = [x:372B, y:24B];  b0Place: Window.Place = [x:34B, y:24B];  b1Place: Window.Place = [x:124B, y:24B];  b2Place: Window.Place = [x:214B, y:24B];  p0Place: Window.Place = [x:310B, y:24B];  p1Place: Window.Place = [x:372B, y:24B];  p2Place: Window.Place = [x:454B, y:24B];  numberDims: Window.Dims = [w:54B, h:12B];  initialBox: Window.Box = [place:[x:0, y:0], dims:[w:506B, h:64B]];  Start: PROC[] =    BEGIN    IF running THEN RETURN;    data.timesThru ¬ 0;    b0 ¬ b1 ¬ b2 ¬ b3 ¬ b4 ¬ 0;    p0 ¬ p1 ¬ p2 ¬ p3 ¬ p4 ¬ 0;    data.p0Interval ¬ System.MicrosecondsToPulses[basicInterval];    buffers ¬ Buffer.MakePool[dispatcherBuffers, 0];  --get large pool    [] ¬ DataLinkControl.AdjustInputQueueLength[      ethernet, 0, dispatcherBuffers / 2];    FOR device: Device ¬ Driver.GetDeviceChain[], device.next      UNTIL device = NIL DO      IF device.device = ethernet THEN	Protocol1.SetMaximumBufferSize[device, NIL, 1500];      ENDLOOP;      [] ¬ SpecialCommunication.SetEthernetListener[unit, all];      FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	oldSpy[type] ¬ SpecialCommunication.SetSpyProc[SpyProc, type];	ENDLOOP;    running ¬ TRUE;    END;  --Start  Stop: PROC[] =    BEGIN    IF ~running THEN RETURN;    [] ¬ SpecialCommunication.SetEthernetListener[unit, me];    FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO      [] ¬ SpecialCommunication.SetSpyProc[NIL, type];  --wipe out spy      ENDLOOP;    [] ¬ DataLinkControl.AdjustInputQueueLength[ethernet, 0, 5];    FOR device: Device ¬ Driver.GetDeviceChain[], device.next      UNTIL device = NIL DO      IF device.device = ethernet THEN	Protocol1.SetMaximumBufferSize[device, NIL, 0];      ENDLOOP;    Buffer.DestroyPool[buffers];  --give pool back    running ¬ FALSE;    END;  --Stop  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      (old = inactive) => Start[];      (new = inactive) => Stop[];      ENDCASE;    END;  Init: PROCEDURE = {    Exec.AddCommand["EtherWatch.~"L, NoOp, NIL, Unload];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: initialBox,      clientTransition: ClientTransition, name: "EtherWatch"L,      cmSection: "EtherWatch"L];    };      NoOp: Exec.ExecProc = { };    Unload: Exec.ExecProc = {    Stop[];  --first stip    Tool.Destroy[wh];    Exec.RemoveCommand[h, "EtherWatch.~"L];    Heap.Delete[zone] };  MakeSWs: Tool.MakeSWsProc = {    data.sw ¬ ToolWindow.CreateSubwindow[      parent: window, display: DisplayNumbers];    Tool.AddThisSW[      window: window, sw: data.sw, swType: vanilla, h: numberDims.h];    };  DisplayNumbers: ToolWindow.DisplayProcType =    BEGIN    bps: LONG STRING = "bits/sec"L;    pps: LONG STRING = "pkts/sec"L;    Display.White[data.sw, [[0, 0], numberDims]];  --the whole window    [] ¬ Display.Text[data.sw, bps,      [x: bTagPlace.x - (charWidth * bps.length / 2), y: 4]];    [] ¬ Display.Text[data.sw, pps,      [x: pTagPlace.x - (charWidth * pps.length / 2), y: 4]];    END;  --DisplayNumbers  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};    SpyProc: ENTRY SpecialCommunication.SpyProc =    --PROC[b: Buffer.Buffer, function: Buffer.Function] RETURNS [Buffer.Buffer];    BEGIN    dest: HostNumber;    elapsed: LONG CARDINAL;    IF oldSpy[b.fo.type] # NIL THEN      {b ¬ oldSpy[b.fo.type][b, function]; IF b = NIL THEN RETURN[b]};    p0 ¬ p0.SUCC;  --simple counter    b0 ¬ b0 + b.fo.driver.length + preamble + crc + ipg;  --simple accumulation    --Time to recompute averages?    elapsed ¬ System.GetClockPulses[] - data.lastTime;    IF elapsed > data.p0Interval THEN      BEGIN      data.lastTime ¬ System.GetClockPulses[];  --reset start of interval now      data.timesThru ¬ data.timesThru.SUCC;  --count times through this code      elapsed ¬ System.PulsesToMicroseconds[[elapsed]] / 1D3;  --milliseconds      p0 ¬ (1D3 * p0) / elapsed;  --p0 is now packets/second      p1 ¬ p1 + p0; --accumulator for 1 second counter      p2 ¬ p2 + p0; --accumulator for 5 second counter      b0 ¬ (b0 * 8D3) / elapsed;  --bits/second      b1 ¬ b1 + b0; --accumulator for p1 interval      b2 ¬ b2 + b0; --accumulator for p2 interval      IF data.sw # NIL THEN        BEGIN	number.length ¬ 0; String.AppendLongDecimal[number, p0];  --packets/sec	Display.White[data.sw,	  [[p0Place.x - (numberDims.w / 2), p0Place.y], numberDims]]; 	[] ¬ Display.Text[data.sw, number,	  [p0Place.x - (charWidth * number.length / 2), p0Place.y]];	number.length ¬ 0; String.AppendLongDecimal[number, b0];  --bits/second	Display.White[data.sw,	  [[b0Place.x - (numberDims.w / 2), b0Place.y], numberDims]]; 	[] ¬ Display.Text[data.sw, number,	  [b0Place.x - (charWidth * number.length / 2), b0Place.y]];	b0 ¬ p0 ¬ 0;  --reset accumulators	IF (data.timesThru MOD p1Times) = 0 THEN	  BEGIN	  p1 ¬ p1 / p1Times; b1 ¬ b1 / p1Times;  --makes average over p1 interval	  number.length ¬ 0; String.AppendLongDecimal[number, p1];	  Display.White[data.sw,	    [[p1Place.x - (numberDims.w / 2), p1Place.y], numberDims]]; 	  [] ¬ Display.Text[data.sw, number,	    [p1Place.x - (charWidth * number.length / 2), p1Place.y]];	  number.length ¬ 0; String.AppendLongDecimal[number, b1];  --bits/second	  Display.White[data.sw,	    [[b1Place.x - (numberDims.w / 2), b1Place.y], numberDims]]; 	  [] ¬ Display.Text[data.sw, number,	    [b1Place.x - (charWidth * number.length / 2), b1Place.y]];	  b1 ¬ p1 ¬ 0;  --then reset the accumulators	  IF (data.timesThru MOD p2Times) = 0 THEN	    BEGIN	    p2 ¬ p2 / p2Times; b2 ¬ b2 / p2Times;  --makes average p2Interval	    number.length ¬ 0; String.AppendLongDecimal[number, p2];	    Display.White[data.sw,	      [[p2Place.x - (numberDims.w / 2), p2Place.y], numberDims]]; 	    [] ¬ Display.Text[data.sw, number,	      [p2Place.x - (charWidth * number.length / 2), p2Place.y]];	    number.length ¬ 0; String.AppendLongDecimal[number, b2];	    Display.White[data.sw,	      [[b2Place.x - (numberDims.w / 2), b2Place.y], numberDims]]; 	    [] ¬ Display.Text[data.sw, number,	      [b2Place.x - (charWidth * number.length / 2), b2Place.y]];	    b2 ¬ p2 ¬ 0;  --then reset the accumulator	    END;	  END;        END;      END;    dest ¬ LOOPHOLE[      b.linkLayer.blockPointer, IEEE8023.Encapsulation].ethernetDest;    SELECT TRUE FROM      (function = send) => RETURN[b];  --these always proceed      (b.fo.status # goodCompletion) => {Buffer.ReturnBuffer[b]; RETURN[NIL]};      (dest = me) => RETURN[b];  --it was sent to me      (HostNumbers.IsMulticastID[@dest]) => RETURN[b];  --multicast id      ENDCASE => {Buffer.ReturnBuffer[b]; RETURN[NIL]};  --not me, not *    END;  --SpyProc  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
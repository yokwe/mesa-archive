-- File: XferTool.mesa - last edit:-- AOF                 28-Oct-87 15:28:36-- Create by FormSWLayoutTool on  3-Oct-86 16:46-- Copyright (C) 1986, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AddressTranslation USING [    Error, NetworkAddress, PrintError, StringToNetworkAddress],  Buffer USING [Device],  Courier USING [    Arguments, Call, Create, Delete, Error, ErrorCode, Handle,    RemoteErrorSignalled],  CourierInternal,  Driver USING [Device, nilDevice],  Environment USING [Block, Byte, bytesPerPage, bytesPerWord, wordsPerPage],  Exec USING [AddCommand, ExecProc, Handle, OutputProc, RemoveCommand],  Format USING [Decimal, LongDecimal, LongNumber, StringProc, NetworkAddress],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, Enumerated, EnumeratedItem, line0, line1, line2,    NumberItem, ProcType, StringItem],  Heap USING [Create, Delete],  MFile USING [Acquire, Error, GetProperties, Handle],  MStream USING [Create, Handle],  NSBuffer USING [Body, Buffer],  NSTypes USING [    Byte, bytesPerExchangeHeader, bytesPerIDPHeader, bytesPerSppHeader,    maxIDPBytesPerPacket],  PacketExchange USING [    CreateRequestor, Delete, ExchangeClientType, ExchangeHandle, SendRequest],  PacketStream USING [    ConnectionFailed, ConnectionSuspended, Handle, Make, unknownConnID],  Process USING [Detach, priorityNormal, SetPriority],  Protocol1 USING [GetFamilyUnit, SetMaximumBufferSize],  Put USING [Text],  Router USING [AssignAddress],  Runtime USING [ZeroDivisor],  SppOps USING [    DisableChecksums, SetWindow, sppWindowSize, PacketStreamFromByteStream],  Stream USING [Block, CompletionCode, Handle, Position],  System USING [    GetClockPulses, NetworkAddress, nullNetworkAddress, PulsesToMicroseconds],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Box, GetBox, Handle],  WindowFont USING [CharWidth],  XferProtocol USING [    ClosePacketStream, CommitArguments, CommitResults, DescribeCommitArguments,    DescribeCommitResults, DescribeStoreArguments, DescribeStoreResults, DevNull,    Procedure, program, StoreArguments, StoreResults, TransportType,    versionHigh, DeviceType, StartServer],  XStream;XferTool: MONITOR  IMPORTS    AddressTranslation, Courier, Exec, Format, FormSW, Heap, MFile, MStream,    PacketExchange, PacketStream, Process, Protocol1, Put, Router, Runtime,    SppOps, System, Tool, Window, WindowFont, XferProtocol, XStream  EXPORTS Buffer = {  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  StoreProcType: TYPE = PROC[    args: LONG POINTER TO XferProtocol.StoreArguments,    address: System.NetworkAddress, sH: Stream.Handle]    RETURNS[time: LONG CARDINAL];  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    cmdSW(4): Window.Handle ¬ NIL,    fileSW(6): Window.Handle ¬ NIL,    optionsTool(8): Window.Handle ¬ NIL,    host(10): LONG STRING ¬ NIL,    directory(12): LONG STRING ¬ NIL,    source(14): LONG STRING ¬ NIL,    destn(16): LONG STRING ¬ NIL,    always(18): BOOLEAN ¬ FALSE,    verify(19): BOOLEAN ¬ FALSE,    wild(20): BOOLEAN ¬ FALSE,    older(21): BOOLEAN ¬ FALSE,    equal(22): BOOLEAN ¬ FALSE,    newer(23): BOOLEAN ¬ FALSE,    options(24): OptionsData ¬ []];  OptionsDataHandle: TYPE = LONG POINTER TO OptionsData;  OptionsData: TYPE = RECORD[    checksums: BOOLEAN ¬ TRUE,    formSW: Window.Handle ¬ NIL,    sink: XferProtocol.DeviceType ¬ devnull,    window: NATURAL ¬ 5,    transport: XferProtocol.TransportType ¬ packetstream,    frame: NATURAL ¬ NSTypes.maxIDPBytesPerPacket,    source: XferProtocol.DeviceType ¬ devnull];  FormFormItems: TYPE = {    host, directory, source, destn, always, verify, wild, older, equal, newer};  CmdFormItems: TYPE = {    retrieve, localList, copy, localDelete, options, store, remoteList, close,    remoteDelete};  OptionsFormItems: TYPE = {    apply, window, frame, checksums, default, source, transport, sink};  data: DataHandle ¬ NIL;  wh, swh: Window.Handle ¬ NIL;  optionsData: OptionsDataHandle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.Create[initial: 4];  busyBit: BOOLEAN ¬ FALSE;  bpp: NATURAL = Environment.bytesPerPage;  wpp: NATURAL = Environment.wordsPerPage;  bpw: NATURAL = Environment.bytesPerWord;  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    ENABLE UNWIND => NULL;    isBusy ¬ busyBit;    busyBit ¬ TRUE };  Done: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    busyBit ¬ FALSE};  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};  CourierError: PROC[ec: Courier.ErrorCode] =    {Msg["\nCourier error: ("L]; Format.Decimal[Msg, ec.ORD]; Msg[")"L]};  EmptyString: PROC[s: LONG STRING] RETURNS[BOOLEAN] =    {RETURN[(s = NIL) OR (s.length = 0)]};  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];      new = inactive =>        IF data # NIL THEN {	  zone.FREE[@data]};      ENDCASE;    };  Init: PROCEDURE = {    Exec.AddCommand["XferTest.~"L, NoOp, NIL, Unload];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "XferTool"L,      cmSection: "XferTool"L];    swh ¬ XferProtocol.StartServer[zone];    };      NoOp: Exec.ExecProc = { };  CvtAddr: PROC[s: LONG STRING]    RETURNS[System.NetworkAddress ¬ System.nullNetworkAddress] =    BEGIN    ENABLE AddressTranslation.Error =>      {Msg["\nAddress translation error: "L];      AddressTranslation.PrintError[errorRecord, Msg];      CONTINUE};    RETURN[AddressTranslation.StringToNetworkAddress[s].addr];    END;  --CvtAddr  DisplayOptions: PROC[args: LONG POINTER TO XferProtocol.StoreArguments] =    BEGIN    Write["\n  Store arguments: [name: "L]; Write[args.name];    Write[", length: "L]; Format.LongDecimal[Write, args.length];    Write[", transport: [address: "L];    Format.NetworkAddress[Write, args.transport.address, octal];    Write[", {"L]; WriteDeviceType[args.transport.source];    Write["} => ("L];    Write[SELECT args.transport.type FROM      packetstream => "packetstream"L, bulkdata => "bulkdata"L,      exchange => "exchange"L, netblt => "netblt"L, message => "message"L,      tt0 => "tt0"L, tt1 => "tt1"L, tt2 => "tt2"L, ENDCASE => "tt3"L];    Write[") => {"L]; WriteDeviceType[args.transport.sink];    Write["}, window: "L];  Format.Decimal[Write, args.transport.window];    Write[", frame: "L];    Format.Decimal[Write, args.transport.frame];    Write[", checksums: "L];    Write[IF args.transport.checksums THEN "TRUE"L ELSE "FALSE"L];    Write["]]\n"L];          END;  --DisplayOptions  WriteDeviceType: PROC[dt: XferProtocol.DeviceType] =    BEGIN    Write[SELECT dt FROM      devnull => "devnull"L, rigidDisk => "rigidDisk"L, magtape => "magtape"L,      dt0 => "dt0"L, dt1 => "dt1"L, dt2 => "dt2"L, ENDCASE => "dt3"L];    END;  --WriteDeviceType  Fetch:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["\nTool is busy"L];      RETURN};    Process.Detach[FORK FetchInternal[]]};  FetchInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    Process.SetPriority[Process.priorityNormal];    Write["\nFetch called"L];    Done[] };  LocalList:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["\nTool is busy"L];      RETURN};    Process.Detach[FORK LocalListInternal[]]};  LocalListInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    Process.SetPriority[Process.priorityNormal];    Write["\nLocalList called"L];    Done[] };  Copy:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["\nTool is busy"L];      RETURN};    Process.Detach[FORK CopyInternal[]]};  CopyInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    Process.SetPriority[Process.priorityNormal];    Write["\nCopy called"L];    Done[] };  LocalDelete:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["\nTool is busy"L];      RETURN};    Process.Detach[FORK LocalDeleteInternal[]]};  LocalDeleteInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    Process.SetPriority[Process.priorityNormal];    Write["\nLocalDelete called"L];    Done[] };  Apply:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    data.options ¬ optionsData­;    Tool.Destroy[data.optionsTool];    data.optionsTool ¬ NIL;    Done[] };  Default:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    data.options ¬ [];    Tool.Destroy[data.optionsTool];    data.optionsTool ¬ NIL;    Done[] };  OptionsWindow:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    IF data.optionsTool = NIL THEN OptionsInit[]    ELSE Msg["Options window already exists\n"L];    Done[] };  OptionsClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>	BEGIN        IF optionsData = NIL THEN optionsData ¬ zone.NEW[OptionsData];	optionsData­ ¬ data.options;  --copy current values	END;      new = inactive =>        IF optionsData # NIL THEN {zone.FREE[@optionsData]};      ENDCASE;    };  OptionsInit: PROCEDURE = {  relative: Window.Box ¬ Window.GetBox[wh];  --based on parent's position  relative.dims ¬ [w:444, h:52];  --I pick the size  relative.place ¬ [relative.place.x + 40, relative.place.y - 40];  --parent's    data.optionsTool ¬ Tool.Create[      makeSWsProc: OptionsMakeSWs, initialState: default,      clientTransition: OptionsClientTransition, name: "Options"L,      initialBox: relative];    };    OptionsMakeSWs: Tool.MakeSWsProc = {    optionsData.formSW ¬ Tool.MakeFormSW[      window: window, formProc: OptionsMakeForm, zone: zone]};  OptionsMakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = OptionsFormItems.LAST.ORD + 1;    device: ARRAY[0..4) OF Enumerated ¬ [      ["devnull"L, XferProtocol.DeviceType[devnull].ORD],      ["rigid"L, XferProtocol.DeviceType[rigidDisk].ORD],      ["floppy"L, XferProtocol.DeviceType[floppyDisk].ORD],      ["magtape"L, XferProtocol.DeviceType[magtape].ORD]];    transport: ARRAY[0..5) OF Enumerated ¬ [      ["bulkdata"L, XferProtocol.TransportType[bulkdata].ORD],      ["packetstream"L, XferProtocol.TransportType[packetstream].ORD],      ["exchange"L, XferProtocol.TransportType[exchange].ORD],      ["netblt"L, XferProtocol.TransportType[netblt].ORD],      ["message"L, XferProtocol.TransportType[message].ORD]];    items ¬ AllocateItemDescriptor[nItems, zone];    items[OptionsFormItems.apply.ORD] ¬ FormSW.CommandItem[      tag: "Apply"L, place: [6, FormSW.line0], proc: Apply, z: zone];    items[OptionsFormItems.window.ORD] ¬ FormSW.NumberItem[      tag: "window[1..13]"L, place: [64, FormSW.line0], signed: FALSE,      boxWidth: 24, default: 5, value: @optionsData.window, z: zone];    items[OptionsFormItems.frame.ORD] ¬ FormSW.NumberItem[      tag: "frame[100..1458]"L, place: [180, FormSW.line0], signed: FALSE,      boxWidth: 32, default: 534, value: @optionsData.frame, z: zone];    items[OptionsFormItems.checksums.ORD] ¬ FormSW.BooleanItem[      tag: "checksums"L, place: [340, FormSW.line0],      switch: @optionsData.checksums, z: zone];    items[OptionsFormItems.default.ORD] ¬ FormSW.CommandItem[      tag: "Default"L, place: [6, FormSW.line1], proc: Default, z: zone];    items[OptionsFormItems.source.ORD] ¬ FormSW.EnumeratedItem[      tag: "source"L, place: [64, FormSW.line1],      choices: DESCRIPTOR[device], value: @optionsData.source, z: zone];    items[OptionsFormItems.transport.ORD] ¬ FormSW.EnumeratedItem[      tag: "transport"L, place: [180, FormSW.line1],      choices: DESCRIPTOR[transport], value: @optionsData.transport, z: zone];    items[OptionsFormItems.sink.ORD] ¬ FormSW.EnumeratedItem[      tag: "sink"L, place: [340, FormSW.line1],      choices: DESCRIPTOR[device], value: @optionsData.sink, z: zone];    RETURN[items: items, freeDesc: TRUE];    };  Store:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["\nTool is busy"L];      RETURN};    Process.Detach[FORK StoreInternal[]]};  SppSize: PROC[l: NATURAL] RETURNS[CARDINAL] = INLINE    {RETURN[NSTypes.bytesPerIDPHeader + NSTypes.bytesPerSppHeader + l]};  StoreInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    addr: System.NetworkAddress ¬ CvtAddr[data.host];    bps, time: LONG CARDINAL;    srslts: XferProtocol.StoreResults;    sargs: XferProtocol.StoreArguments;    crslts: XferProtocol.CommitResults;    cargs: XferProtocol.CommitArguments;    Process.SetPriority[Process.priorityNormal];    SELECT TRUE FROM      (addr = System.nullNetworkAddress) => Msg["\nNo host address"L];      (data.source = NIL) => Msg["\nNo source filename"L];      ENDCASE =>        BEGIN	sH: Stream.Handle;	mfH: MFile.Handle ¬ MFile.Acquire[data.source, readOnly, [,] !	  MFile.Error => GOTO noFile];	cH: Courier.Handle ¬ Courier.Create[	  addr, XferProtocol.program, XferProtocol.versionHigh, zone, bulk];	BEGIN	OPEN sargs;	name ¬ IF EmptyString[data.destn] THEN data.source ELSE data.destn;	length ¬ MFile.GetProperties[mfH].length;  --need this for create	transport ¬ [	  address: Router.AssignAddress[],  --a uniqueue address	  source: data.options.source,  --where we get the bits	  type: data.options.transport,  --type we're using for test	  sink: data.options.sink,  --where we put the bits	  window: data.options.window,  --size of the allocation window	  frame: data.options.frame,  --size of each frame	  checksums: data.options.checksums];  --should we or not	END;	sH ¬ IF sargs.transport.source = devnull THEN	  XferProtocol.DevNull[data.options.frame, sargs.length, zone]	ELSE MStream.Create[file: mfH, release: [,]];	Write["Storing "L]; Write[data.source];	IF ~EmptyString[data.destn] THEN	  {Write[" as "L]; Write[data.destn]};	DisplayOptions[@sargs];  --record options in log		BEGIN	time ¬ System.GetClockPulses[];  --starting create	[] ¬ Courier.Call[	  cH: cH, procedureNumber: XferProtocol.Procedure[store].ORD,	  arguments: [@sargs, XferProtocol.DescribeStoreArguments],	  results: [@srslts, XferProtocol.DescribeStoreResults] !	  Courier.Error => {CourierError[errorCode]; GOTO failed}];	time ¬ System.GetClockPulses[] - time;  --elapsed to create	time ¬ System.PulsesToMicroseconds[[time]] / 1000;  --get usable units	Format.LongDecimal[Write, time/1000];  --seconds	Write["."L];	Format.LongNumber[Write, (time MOD 1000), [10, TRUE, TRUE, 3]];	Write[" seconds to create\n"L];	SELECT sargs.transport.type FROM	  bulkdata => time ¬ StoreBulk[@sargs, srslts.address, sH];	  packetstream => time ¬ StoreSpp[@sargs, srslts.address, sH];	  exchange => time ¬ StoreExchange[@sargs, srslts.address, sH];	  ENDCASE => Write["Unsupported transport option\n"L];	time ¬ System.PulsesToMicroseconds[[time]] / 1000;  --in millisecs	Format.LongDecimal[Write, time/1000];  --seconds	Write["."L];	Format.LongNumber[Write, (time MOD 1000), [10, TRUE, TRUE, 3]];	Write[" seconds to transfer file\n"L];	time ¬ time / 100;  --that give deca-seconds	{ENABLE Runtime.ZeroDivisor => {bps ¬ sargs.length * 80; CONTINUE};	bps ¬ (sargs.length * 80) / time};  --that's bits per second	Format.LongDecimal[Write, sargs.length];	Write[" bytes at "L];	Format.LongDecimal[Write, bps];	Write[" bits per second\n"L];	BEGIN	OPEN cargs;	Write["committing ..."L];	address ¬ srslts.address; status ¬ commit;	[create, write, read, length, type, , , ] ¬ MFile.GetProperties[mfH];	END;	time ¬ System.GetClockPulses[];  --starting create	[] ¬ Courier.Call[	  cH: cH, procedureNumber: XferProtocol.Procedure[commit].ORD,	  arguments: [@cargs, XferProtocol.DescribeCommitArguments],	  results: [@crslts, XferProtocol.DescribeCommitResults] !	  Courier.Error => {CourierError[errorCode]; GOTO failed};	  Courier.RemoteErrorSignalled =>	    {ClientError[errorNumber, arguments]; GOTO failed}];	time ¬ System.GetClockPulses[] - time;  --elapsed to create	time ¬ System.PulsesToMicroseconds[[time]] / 1000;  --get usable units 	Format.LongDecimal[Write, time/1000];  --seconds	Write["."L];	Format.LongNumber[Write, (time MOD 1000), [10, TRUE, TRUE, 3]];	Write[" seconds to commit file ..."L];	Write[IF crslts.status = okay THEN "done.\n"L ELSE "store failed.\n"L];	Courier.Delete[cH];  --then get rid of this	EXITS failed => Courier.Delete[cH];	END;	sH.delete[sH];  --gun access to the file	EXITS noFile => {Msg[data.source]; Msg[" is not available"L]};	END;    Done[] };  ClientError: PROC[en: NATURAL, arguments: Courier.Arguments] =    BEGIN    Write["Client error ("L]; Format.Decimal[Write, en]; Write[")\n"L];    END;  --ClientError  StoreBulk: StoreProcType =    BEGIN    PacketFromBulk: PROC[sH: Stream.Handle] RETURNS[PacketStream.Handle] =      BEGIN      sH ¬ @LOOPHOLE[        sH, CourierInternal.AugmentedStream].back.transFilter.object;      sH ¬ LOOPHOLE[@LOOPHOLE[sH, CourierInternal.AugmentedStream].context,	LONG POINTER TO Stream.Handle]­;  --retch!!!! (copied from CourierImplN)      RETURN[SppOps.PacketStreamFromByteStream[sH]];  --more loop-de-loops      END;  --PacketFromBulk    Checkout: PROC[h: XStream.Handle] =      BEGIN      sink: Stream.Handle = XStream.Create[h];      psH: PacketStream.Handle = PacketFromBulk[sink];      IF ~data.options.checksums THEN SppOps.DisableChecksums[psH];      psH.setSenderSizeLimit[  --make it a different size	args.transport.frame -  --that reflects the frame size selected	NSTypes.bytesPerIDPHeader -  --but allows that we're using SPP	NSTypes.bytesPerSppHeader];  --and doesn't dribble off the end      time ¬ System.GetClockPulses[];  --start the clock now      XStream.Copy[source: sH, sink: sink];  --let him do it      time ¬ System.GetClockPulses[] - time;  --compute elapsed time      sink.delete[sink];  --delete stream    END;  --Checkout    cH: Courier.Handle;    window: CARDINAL = SppOps.sppWindowSize;  --save old value;    bulk: XStream.Handle ¬ XStream.Make[[proc[Checkout]]];    Protocol1.SetMaximumBufferSize[  --up the frame size      Driver.nilDevice, Protocol1.GetFamilyUnit[ns], args.transport.frame];    SppOps.SetWindow[PRED[args.transport.window]];  --reset for test    cH ¬ Courier.Create[      address, XferProtocol.program, XferProtocol.versionHigh, zone, bulk];    [] ¬ Courier.Call[cH: cH,      procedureNumber: XferProtocol.Procedure[xfer].ORD,      arguments: [@bulk, XStream.DescribeSource],      streamCheckoutProc: XStream.UserCheckout !      Courier.Error => CONTINUE];    Courier.Delete[cH];    XStream.Destroy[bulk];  --get rid of that    SppOps.SetWindow[window];  --reset to value when we came in    Protocol1.SetMaximumBufferSize[  --back to normal      Driver.nilDevice, Protocol1.GetFamilyUnit[ns],      NSTypes.maxIDPBytesPerPacket];    END;  --StoreBulk  StoreSpp: StoreProcType =    BEGIN    window: CARDINAL;    psH: PacketStream.Handle;    status: Stream.CompletionCode ¬ normal;    Protocol1.SetMaximumBufferSize[      Driver.nilDevice, Protocol1.GetFamilyUnit[ns], args.transport.frame];    window ¬ SppOps.sppWindowSize;  --save old value    SppOps.SetWindow[PRED[args.transport.window]];  --reset for test    psH ¬ PacketStream.Make[      local: args.transport.address, remote: address,      localConnID: PacketStream.unknownConnID,      remoteConnID: PacketStream.unknownConnID,      establishConnection: TRUE, classOfService: bulk !        PacketStream.ConnectionFailed =>	  IF why = noServiceAtDestination THEN RETRY ELSE REJECT];    IF ~data.options.checksums THEN SppOps.DisableChecksums[psH];    psH.setSenderSizeLimit[  --make it a different size      args.transport.frame -  --that reflects the frame size selected      NSTypes.bytesPerIDPHeader -  --but allows that we're using SPP      NSTypes.bytesPerSppHeader];  --and doesn't dribble off the end    time ¬ System.GetClockPulses[];  --start the clock    UNTIL status # normal DO      bytes: NATURAL;      b: NSBuffer.Buffer ¬ psH.getSendBuffer[];      ns: NSBuffer.Body ¬ b.ns;      to: Environment.Block ¬ [        LOOPHOLE[ns], SppSize[0], args.transport.frame];      [bytes, status, ] ¬ sH.get[sH, to, sH.options];      ns.subtype ¬ 1;  --bulk data      ns.endOfMessage ¬ status # normal;      ns.pktLength ¬ SppSize[bytes];      BEGIN      psH.put[b ! PacketStream.ConnectionSuspended => GOTO failed];      EXITS failed => {psH.returnSendBuffer[b]; EXIT};      END;      ENDLOOP;    time ¬ System.GetClockPulses[] - time;  --compute elapsed time    XferProtocol.ClosePacketStream[psH, sendClose];  --so run the close    psH.destroy[psH];  --get rid of stream    SppOps.SetWindow[window];  --reset to value when we came in    Protocol1.SetMaximumBufferSize[      Driver.nilDevice, Protocol1.GetFamilyUnit[ns],      NSTypes.maxIDPBytesPerPacket];  --back to normal    END;  --StoreSpp  StoreExchange: StoreProcType =    BEGIN    bytes: NATURAL;    to: Environment.Block;    pH: PacketExchange.ExchangeHandle;    status: Stream.CompletionCode ¬ normal;    Position: TYPE = LONG POINTER TO Stream.Position;    eod: PacketExchange.ExchangeClientType ¬ unspecified;    Block: TYPE = RECORD[      PACKED SEQUENCE COMPUTED INTEGER OF Environment.Byte];    ovh: NATURAL = NSTypes.bytesPerExchangeHeader + NSTypes.bytesPerIDPHeader;    to.blockPointer ¬ LOOPHOLE[zone.NEW[Block[args.transport.frame - ovh]]];        Protocol1.SetMaximumBufferSize[      Driver.nilDevice, Protocol1.GetFamilyUnit[ns], args.transport.frame];    pH ¬ PacketExchange.CreateRequestor[      waitTime: 2000--msecs--, retransmissionInterval: 200--msecs--];    time ¬ System.GetClockPulses[];  --start the clock    UNTIL status # normal DO      LOOPHOLE[to.blockPointer, Position]­ ¬ sH.getPosition[sH];      to.startIndex ¬ SIZE[Stream.Position] * bpw;      to.stopIndexPlusOne ¬ args.transport.frame - ovh;      [bytes, status, ] ¬ sH.get[sH, to, sH.options];      to.startIndex ¬ 0;  --so we transmit the position      to.stopIndexPlusOne ¬ bytes + SIZE[Stream.Position] * bpw;      IF status # normal THEN eod ¬ SUCC[eod];  --that's end of data      [] ¬ PacketExchange.SendRequest[pH, address, to, to, eod];      ENDLOOP;    time ¬ System.GetClockPulses[] - time;  --compute elapsed time    PacketExchange.Delete[pH];  --get rid of this    Protocol1.SetMaximumBufferSize[      Driver.nilDevice, Protocol1.GetFamilyUnit[ns],      NSTypes.maxIDPBytesPerPacket];  --back to normal    zone.FREE[@to.blockPointer];    END;  --StoreExchange  RemoteList:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["\nTool is busy"L];      RETURN};    Process.Detach[FORK RemoteListInternal[]]};  RemoteListInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    Process.SetPriority[Process.priorityNormal];    Write["\nRemoteList called"L];    Done[] };  Close:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["\nTool is busy"L];      RETURN};    Process.Detach[FORK CloseInternal[]]};  CloseInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    Process.SetPriority[Process.priorityNormal];    Write["\nClose called"L];    Done[] };  RemoteDelete:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["\nTool is busy"L];      RETURN};    Process.Detach[FORK RemoteDeleteInternal[]]};  RemoteDeleteInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    Process.SetPriority[Process.priorityNormal];    Write["\nRemoteDelete called"L];    Done[] };    Unload: Exec.ExecProc = {    IF Busy[] THEN {      Exec.OutputProc[h]["\nTool is busy. Sorry."L];      RETURN[error] };    IF data.optionsTool # NIL THEN Tool.Destroy[data.optionsTool];    Tool.Destroy[swh];  --that's the server tool    Tool.Destroy[wh];  --that's the main tool    Exec.RemoveCommand[h, "XferTest.~"L];    Heap.Delete[zone];    Done[] };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [16];    Tool.UnusedLogName[unused: logName, root: "XferTest.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeFormForm, zone: zone];    data.cmdSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeCmdForm, zone: zone];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};  MakeCmdForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = CmdFormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems, zone];    items[CmdFormItems.retrieve.ORD] ¬ CommandItem[      tag: "Fetch"L, place: [CharPos[0], line0],      proc: Fetch, z: zone];    items[CmdFormItems.localList.ORD] ¬ CommandItem[      tag: "Local-List"L, place: [CharPos[13], line0],      proc: LocalList, z: zone];    items[CmdFormItems.copy.ORD] ¬ CommandItem[      tag: "Copy"L, place: [CharPos[29], line0], proc: Copy, z: zone];    items[CmdFormItems.localDelete.ORD] ¬ CommandItem[      tag: "Local-Delete"L, place: [CharPos[39], line0],      proc: LocalDelete, z: zone];    items[CmdFormItems.options.ORD] ¬ CommandItem[      tag: "Options"L, place: [345, line0], proc: OptionsWindow, z: zone];    items[CmdFormItems.store.ORD] ¬ CommandItem[      tag: "Store"L, place: [CharPos[0], line1],      proc: Store, z: zone];    items[CmdFormItems.remoteList.ORD] ¬ CommandItem[      tag: "Remote-List"L, place: [CharPos[13], line1],      proc: RemoteList, z: zone];    items[CmdFormItems.close.ORD] ¬ CommandItem[      tag: "Close"L, place: [CharPos[29], line1],      proc: Close, z: zone];    items[CmdFormItems.remoteDelete.ORD] ¬ CommandItem[      tag: "Remote-Delete"L, place: [CharPos[39], line1],       proc: RemoteDelete, z: zone];    RETURN[items: items, freeDesc: TRUE];    };  MakeFormForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormFormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems, zone];    items[FormFormItems.host.ORD] ¬ StringItem[      tag: "Host"L, place: [CharPos[0], line0], inHeap: TRUE,      string: @data.host, z: zone];    items[FormFormItems.directory.ORD] ¬ StringItem[      tag: "Directory"L, place: [CharPos[28], line0], inHeap: TRUE,      string: @data.directory, z: zone];    items[FormFormItems.source.ORD] ¬ StringItem[      tag: "Source"L, place: [CharPos[0], line1], inHeap: TRUE,      string: @data.source, z: zone];    items[FormFormItems.destn.ORD] ¬ StringItem[      tag: "Dest'n"L, place: [CharPos[0], line2], inHeap: TRUE,      string: @data.destn, z: zone];    items[FormFormItems.always.ORD] ¬ BooleanItem[      tag: "Always"L, place: [CharPos[28], line2],      switch: @data.always, z: zone];    items[FormFormItems.verify.ORD] ¬ BooleanItem[      tag: "Verify"L, place: [CharPos[37], line2],      switch: @data.verify, z: zone];    items[FormFormItems.wild.ORD] ¬ BooleanItem[      tag: "'*"L, place: [CharPos[46], line2],      switch: @data.wild, z: zone];    items[FormFormItems.older.ORD] ¬ BooleanItem[      tag: " < "L, place: [CharPos[52], line2],      switch: @data.older, z: zone];    items[FormFormItems.equal.ORD] ¬ BooleanItem[      tag: " = "L, place: [CharPos[56], line2],      switch: @data.equal, z: zone];    items[FormFormItems.newer.ORD] ¬ BooleanItem[      tag: " > "L, place: [CharPos[60], line2],      switch: @data.newer, z: zone];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
-- File: PacketExchSpyImpl.mesa - last edit:-- AOF                 30-Jun-87  9:50:36-- JAV                 28-Mar-85 14:26:55-- Copyright (C) 1984, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [Error, PrintError, StringToNetworkAddress],  Buffer USING [ReturnBuffer],  Driver USING [ChangeNumberOfInputBuffers, Device, GetDeviceChain],  IEEE8023 USING [Encapsulation, EncapObject, minBytesPerEthernetPacket],  Exec USING [    AddCommand, ExecProc, FreeTokenString, GetToken, OutputProc, RemoveCommand],  Format USING [StringProc, LongDecimal, HostNumber],  Heap USING [Create, Delete],  Inline USING [DBITSHIFT, LongDiv],  NSBuffer USING [AccessHandle, Body, DestroyPool, MakePool],  PacketExchange USING [ExchangeClientType, ExchangeID],  Protocol1 USING [SetMaximumBufferSize],  Router USING [FindMyHostID],  SpecialCommunication USING [SetSpyProc, SpyProc, SetEthernetListener],  String USING [AppendChar, AppendLongDecimal, AppendString],  System USING [    broadcastHostNumber, GetClockPulses, GetGreenwichMeanTime, HostNumber,    Pulses, PulsesToMicroseconds, MicrosecondsToPulses, nullHostNumber],  Time USING [Append, Unpack];    PacketExchSpyImpl: PROGRAM  <<  This is not a monitor 'cause it has only a single process muck'n  with the tables.  >>    IMPORTS      AddressTranslation, Buffer, Driver, Exec, Format, Inline, Protocol1,      Router, NSBuffer, SpecialCommunication, String, System, Time, Heap    EXPORTS Buffer =  BEGIN  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;    stopSpy: BOOLEAN ¬ FALSE;  unit: CARDINAL = 1;  time: LONG CARDINAL;  zone: UNCOUNTED ZONE;  program: CARDINAL ¬ 0;  deadTime: LONG CARDINAL;  aH: NSBuffer.AccessHandle;  oldSpy: SpecialCommunication.SpyProc ¬ NIL;  me: System.HostNumber = Router.FindMyHostID[];  all: System.HostNumber = System.broadcastHostNumber;  apparent: System.HostNumber ¬ System.nullHostNumber;  packetExchPackets: LONG CARDINAL ¬ 0;  responsesDropped: LONG CARDINAL ¬ 0;  oldPackets: LONG CARDINAL ¬ 0;  totRetries: LONG CARDINAL ¬ 0;  runt: LONG CARDINAL ¬ 0;  ClientTypeHistogram: ARRAY [0..11] OF LONG CARDINAL ¬ ALL[0];    list: RECORD[head, tail: List, count: CARDINAL] ¬ [NIL, NIL, 0];    Index: TYPE = CARDINAL[0..256);  List: TYPE = LONG POINTER TO ListObject;  ListObject: TYPE = RECORD[    fwd, bwd: List ¬ NIL, cu, cs: System.HostNumber ¬ NULL,    timesSeen: CARDINAL ¬ 0,    timeStart, time: System.Pulses ¬ NULL, exchangeID: PacketExchange.ExchangeID ¬ [0,0]];    History: TYPE = LONG POINTER TO Histogram;  Histogram: TYPE = RECORD[    total: LONG CARDINAL ¬ 0, count: ARRAY Index OF LONG CARDINAL ¬ ALL[0]];  timeHisto: History;  retryHisto: History;    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      Initialize: PROCEDURE =    BEGIN    zone ¬ Heap.Create[4];  --to build from    timeHisto ¬ zone.NEW[Histogram];    retryHisto ¬ zone.NEW[Histogram];    aH ¬ NSBuffer.MakePool[send: 0, receive: 50];    deadTime ¬ System.MicrosecondsToPulses[LONG[60] * 1000000];  --60 seconds    Driver.ChangeNumberOfInputBuffers[TRUE];  --allocates extra buffers    FOR device: Device ¬ Driver.GetDeviceChain[], device.next      UNTIL device = NIL DO      IF device.device = ethernet THEN        Protocol1.SetMaximumBufferSize[device, NIL, 1500];      ENDLOOP;    oldSpy ¬ SpecialCommunication.SetSpyProc[SpyProc, ns];    [] ¬ SpecialCommunication.SetEthernetListener[unit, all];    time ¬ System.GetGreenwichMeanTime[];    Exec.AddCommand["PacketExchangeSpy.~"L, ExecEntry, Unload];    END;  --Initialize  Unload: Exec.ExecProc =    BEGIN    Exec.RemoveCommand[h, "PacketExchangeSpy.~"L];    [] ¬ SpecialCommunication.SetEthernetListener[unit, me];    [] ¬ SpecialCommunication.SetSpyProc[NIL, ns]; oldSpy ¬ NIL;    NSBuffer.DestroyPool[aH];  --gun the buffers    Driver.ChangeNumberOfInputBuffers[FALSE];    FOR device: Device ¬ Driver.GetDeviceChain[], device.next      UNTIL device = NIL DO      IF device.device = ethernet THEN        Protocol1.SetMaximumBufferSize[device, NIL, 0];      ENDLOOP;    Heap.Delete[zone];  --lots easier than deleting each node    END;  --Unload  ExecEntry: Exec.ExecProc =    BEGIN    t, fwd: List;    output: Format.StringProc = Exec.OutputProc[h];        print: PROC[length, log: CARDINAL, data: History, compress: CARDINAL] =      BEGIN      i, j: CARDINAL;      percent, value: LONG CARDINAL;      FOR i IN[0..length] DO        value ¬ 0;	j ¬ i;	FOR i IN[i..length] DO 	  IF (value ¬ value + data.count[i]) = 0 THEN EXIT;	  data.count[i] ¬ 0;	  percent ¬ (value * LONG[100]) / data.total;	  SELECT TRUE FROM	    (i = length) => NULL;  --have to print now	    (percent <= compress) => LOOP;  --wait till next time	    ENDCASE;	  UNTIL (string.length MOD 26) = 0 DO	    String.AppendChar[string, ' ]; ENDLOOP;	  String.AppendChar[string, '[];	  String.AppendLongDecimal[string, Inline.DBITSHIFT[LONG[j], log]];	  String.AppendString[string, ".."L];	  String.AppendLongDecimal[string, Inline.DBITSHIFT[LONG[i + 1], log]];	  String.AppendString[string, "): "L];	  String.AppendLongDecimal[string, value];	  String.AppendChar[string, '(];	  String.AppendLongDecimal[string, percent];	  String.AppendString[string, ")%"L];	  IF string.length > 60 THEN	    {String.AppendChar[string, 15C]; output[string]; string.length ¬ 0};	  EXIT;  --get's us to the outer loop	  ENDLOOP;	REPEAT FINISHED =>	  IF string.length # 0 THEN	    {String.AppendChar[string, 15C]; output[string]; string.length ¬ 0};	ENDLOOP;	data.total ¬ 0;	string.length ¬ 0;      END;  --print    name, switch, string: LONG STRING ¬ NIL;    stopSpy ¬ TRUE;    string ¬ zone.NEW[StringBody[120]];    output["Packet Exchange information collected from "L];    Time.Append[string, Time.Unpack[[time]]];    String.AppendString[string, " to "L];    time ¬ System.GetGreenwichMeanTime[];    Time.Append[string, Time.Unpack[[time]]];    output[string]; string.length ¬ 0;    output[".\n"L];    output["Number of packet exchange packets seen = "L];    Format.LongDecimal[output, packetExchPackets];    output[".\n"L];    IF runt # 0 THEN      BEGIN      output["Number of runt packets discarded: "L];      Format.LongDecimal[output, runt];      output[".\n"L];      END;    FOR i: CARDINAL IN [0..11] DO     IF ClientTypeHistogram[i] = 0 THEN LOOP     ELSE {       output[" Client type = "L];       SELECT i FROM         0 => output[" unspecified"L];	 1 => output[" timeService"L];	 2 => output[" clearinghouseService"L];	 3 => output[" teledebug"L];	 4 => output[" electronicMail"L];	 5 => output[" remoteDebug"L];	 6 => output[" acceptanceTestRegistration"L];	 7 => output[" performanceTestData"L];	 8 => output[" protocolCertification"L];	 9 => output[" voyeur"L];	 10 => output[" dixie"L];       ENDCASE => output[" outsideXerox"L];       output[" Number of packets = "L];       Format.LongDecimal[output, ClientTypeHistogram[i]];       output[".\n"L]};     ClientTypeHistogram[i] ¬ 0;  -- zero value while here     ENDLOOP;   output["Duration of calls matrix (msecs) for "L];   Format.LongDecimal[output, timeHisto.total];   output[" connection attempts\n"L];   print[LAST[Index], 8, timeHisto, 2];   output["Retry history for above connections\n"L];   print[LAST[Index], 0, retryHisto, 0];   output["Packet responses dropped "L];   Format.LongDecimal[output, responsesDropped];   output[".\n"L];   output["Packets still queued for responses "L];   Format.LongDecimal[output, list.count];   output[".\n"L];   output["Packets dropped because of age "L];   Format.LongDecimal[output, oldPackets];   output[".\n"L];   output["Total retries "L];   Format.LongDecimal[output, totRetries];   output[".\n"L];   FOR t ¬ list.head, fwd UNTIL t = NIL DO     fwd ¬ t.fwd; RemoveConnection[t]; zone.FREE[@t]; ENDLOOP;   list ¬ [NIL, NIL, 0];   responsesDropped ¬ packetExchPackets ¬ oldPackets ¬ totRetries ¬ runt ¬ 0;     time ¬ System.GetGreenwichMeanTime[];  --reset time    zone.FREE[@string];    DO      [name, switch] ¬ Exec.GetToken[h];      IF switch = NIL THEN EXIT;  --that's how we get out      SELECT switch[0] FROM	'h, 'H =>	  BEGIN	  ENABLE AddressTranslation.Error =>	    {AddressTranslation.PrintError[errorRecord, output]; CONTINUE};	  apparent ¬ IF name = NIL THEN System.nullHostNumber	  ELSE AddressTranslation.StringToNetworkAddress[name].addr.host;	  output["Apparent host set to ."L];	  Format.HostNumber[output, apparent, octal]; output[".\n"L];	  END;	ENDCASE;      switch ¬ Exec.FreeTokenString[switch];  --drop him out      IF name # NIL THEN name ¬ Exec.FreeTokenString[name];    ENDLOOP;    IF name # NIL THEN name ¬ Exec.FreeTokenString[name];  --even if failed    stopSpy ¬ FALSE;    END;  --ExecEntry    TakeTime: PROCEDURE [t1, t2: System.Pulses] ={    time: System.Pulses ¬ [pulses: (t1 - t2)];    index: Index;    msecs: CARDINAL;    msecs ¬ Inline.LongDiv[      System.PulsesToMicroseconds[time], 1000 * 8];  --msec/8    index ¬ MIN[(msecs), LAST[Index]];    timeHisto.count[index] ¬ timeHisto.count[index] + 1;    timeHisto.total ¬ timeHisto.total + 1;  };    TakeRetries: PROCEDURE [retries: CARDINAL] = {    index: Index;    index ¬ MIN[(retries), LAST[Index]];    retryHisto.count[index] ¬ retryHisto.count[index] + 1;    retryHisto.total ¬ retryHisto.total + 1;  };  AddConnection: PROC[t: List] =    BEGIN    IF (t.fwd ¬ list.head) # NIL THEN list.head.bwd ¬ t ELSE list.tail ¬ t;    list.head ¬ t; list.count ¬ list.count + 1;    END;  --AddConnection      LocateConnection: PROC[bb: NSBuffer.Body] RETURNS[t: List] =    BEGIN    response: BOOLEAN ¬ FALSE;    fwd: List;    socket: CARDINAL ¬ LOOPHOLE[bb.source.socket];    time: System.Pulses = System.GetClockPulses[];    c1: System.HostNumber ¬ bb.source.host;    c2: System.HostNumber ¬ bb.destination.host;    IF socket IN [0..2047] THEN response ¬ TRUE;    FOR t ¬ list.head, fwd UNTIL t = NIL DO      IF (c1 = t.cs) OR (t.cs = System.broadcastHostNumber) THEN        IF (c2 = t.cu) THEN	  IF bb.exchangeID = t.exchangeID THEN {	    TakeTime[time, t.timeStart];	    TakeRetries[t.timesSeen];	    RemoveConnection[t];	    zone.FREE[@t];	    RETURN[t]}; -- response packet      IF (c1 = t.cu) THEN        IF (c2 = t.cs) THEN	  IF bb.exchangeID = t.exchangeID THEN {	    t.time ¬ System.GetClockPulses[];	    t.timesSeen ¬ t.timesSeen + 1;	    totRetries ¬ totRetries + 1;	    RETURN[t]};	-- update time      fwd ¬ t.fwd;  --just in case we delete the node      IF response THEN {responsesDropped ¬ responsesDropped + 1; RETURN[t]};      IF (time - t.time) > deadTime THEN {        RemoveConnection[t]; oldPackets ¬ oldPackets + 1; zone.FREE[@t]};      ENDLOOP;    END;  --LocateConnection      RemoveConnection: PROC[t: List] =    BEGIN    IF t.bwd = NIL THEN list.head ¬ t.fwd  --beginning of list    ELSE t.bwd.fwd ¬ t.fwd;  --copy back pointer    IF t.fwd = NIL THEN list.tail ¬ t.bwd  --end of list    ELSE t.fwd.bwd ¬ t.bwd;  --copy forward pointer    list.count ¬ list.count - 1;  --obviously    END;  --RemoveConnection      EnterConnection: PROC[bb: NSBuffer.Body] =    BEGIN    t: List;    IF (t ¬ LocateConnection[bb]) = NIL THEN      BEGIN      t ¬ zone.NEW[ListObject ¬ [	timeStart: System.GetClockPulses[],         time: System.GetClockPulses[], 	exchangeID: bb.exchangeID,	cu: bb.source.host,	cs: bb.destination.host]];      AddConnection[t];  --put it in the table      END;    END;  --  EnterConnection  SpyProc: SpecialCommunication.SpyProc =    --PROC[b: Buffer.Buffer] RETURNS[Buffer.Buffer]    BEGIN        Collect: PROC =       BEGIN      IF stopSpy THEN RETURN;      packetExchPackets ¬ packetExchPackets + 1;	SELECT bb.exchangeType FROM	  unspecified =>	    ClientTypeHistogram[0] ¬ ClientTypeHistogram[0] + 1;	  timeService =>	    ClientTypeHistogram[1] ¬ ClientTypeHistogram[1] + 1;	  clearinghouseService =>	    ClientTypeHistogram[2] ¬ ClientTypeHistogram[2] + 1;	  teledebug =>	    ClientTypeHistogram[3] ¬ ClientTypeHistogram[3] + 1;	  IN [electronicMailFirstPEType..electronicMailLastPEType] =>	    ClientTypeHistogram[4] ¬ ClientTypeHistogram[4] + 1;	  IN [remoteDebugFirstPEType..remoteDebugLastPEType] =>	    ClientTypeHistogram[5] ¬ ClientTypeHistogram[5] + 1;	  acceptanceTestRegistration =>	    ClientTypeHistogram[6] ¬ ClientTypeHistogram[6] + 1;	  performanceTestData =>	    ClientTypeHistogram[7] ¬ ClientTypeHistogram[7] + 1;	  protocolCertification =>	    ClientTypeHistogram[8] ¬ ClientTypeHistogram[8] + 1;	  voyeur =>	    ClientTypeHistogram[9] ¬ ClientTypeHistogram[9] + 1;	  IN [dixieDataPEType..dixieErrorPEType] =>	    ClientTypeHistogram[10] ¬ ClientTypeHistogram[10] + 1;	ENDCASE =>	    ClientTypeHistogram[11] ¬ ClientTypeHistogram[11] + 1;      EnterConnection[bb];      END;    dll: IEEE8023.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];    bb: NSBuffer.Body = LOOPHOLE[dll + SIZE[ethernet IEEE8023.EncapObject]];    IF b.fo.driver.length < IEEE8023.minBytesPerEthernetPacket THEN      {runt ¬ SUCC[runt]; Buffer.ReturnBuffer[b]; RETURN[NIL]};          IF oldSpy # NIL THEN      {b ¬ oldSpy[b, function]; IF b = NIL THEN RETURN[b]};    SELECT TRUE FROM      (bb.packetType # packetExchange) => NULL;      (apparent = System.nullHostNumber) => Collect[];      (dll.ethernetDest = LOOPHOLE[apparent]) => Collect[];      (dll.ethernetSource = LOOPHOLE[apparent])  => Collect[];      ENDCASE;    SELECT TRUE FROM      (function = send) => RETURN[b];      (dll.ethernetDest = LOOPHOLE[me]) => RETURN[b];      (dll.ethernetDest = LOOPHOLE[all]) => RETURN[b];      ENDCASE => {Buffer.ReturnBuffer[b]; RETURN[NIL]};    END;      -- Mainline code:    Initialize[];    END.  
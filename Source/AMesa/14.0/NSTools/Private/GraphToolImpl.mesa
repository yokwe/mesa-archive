-- File: GraphToolImpl.mesa - last edit:-- AOF                 12-Aug-87  9:37:03-- GraphTool.mesa-- Create by FormSWLayoutTool on 17-Apr-87 10:37-- Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  ByteBlt USING [ByteBlt],  Environment USING [Block, Byte],  Exec USING [AddCommand, ExecProc, Handle, OutputProc, RemoveCommand],  Format USING [LongDecimal, StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, DisplayItem,    line0, line1, line2, line3, ProcType, StringItem],  GraphSW USING [DataPair],  GraphToolOps USING [CreateGraph, Data, DataHandle, Pairs],  Heap USING [systemZone],  Process USING [Detach, priorityNormal, SetPriority],  Put USING [Text],  Real,  RealFns,  Selection USING [Convert, Source],  String USING [AppendChar, AppendStringAndGrow, StringToDecimal],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Box, Handle],  WindowFont USING [CharWidth];GraphToolImpl: MONITOR  IMPORTS    ByteBlt, Exec, Format, FormSW, Heap, GraphToolOps, Process, Put,    Real, RealFns, Selection, String, Tool, WindowFont = {  FormItems: TYPE = {title, ts, labelX, x, labelY, y, plot, table, stats};  wh: Window.Handle ¬ NIL;  data: GraphToolOps.DataHandle ¬ NIL;  zone: UNCOUNTED ZONE = Heap.systemZone;  initialBox: Window.Box = [place: [x:787, y: 0], dims: [w: 237, h: 308]];  Finished: SIGNAL = CODE;  busyBit: BOOLEAN ¬ FALSE;  PairArray: TYPE = RECORD[SEQUENCE COMPUTED CARDINAL OF GraphSW.DataPair];  Bytes: TYPE = RECORD[PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte];  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    ENABLE UNWIND => NULL;    isBusy ¬ busyBit;    busyBit ¬ TRUE };  Done: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    busyBit ¬ FALSE};  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};  Title:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    title: LONG STRING;    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    title ¬ Selection.Convert[string];    IF title # NIL THEN      BEGIN      IF data.title # NIL THEN data.title.length ¬ 0;      String.AppendStringAndGrow[@data.title, title, zone];      FormSW.DisplayItem[sw, FormItems[title].ORD];      Heap.systemZone.FREE[@title];      END    ELSE Msg["\nselection is invalid\n"L];    Done[] };  LabelX:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    labelx: LONG STRING;    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    labelx ¬ Selection.Convert[string];    IF labelx # NIL THEN      BEGIN      IF data.labelx # NIL THEN data.labelx.length ¬ 0;      String.AppendStringAndGrow[@data.labelx, labelx, zone];      FormSW.DisplayItem[sw, FormItems[x].ORD];      Heap.systemZone.FREE[@labelx];      END    ELSE Msg["\nselection is invalid\n"L];    Done[] };  LabelY:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    labley: LONG STRING;    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    labley ¬ Selection.Convert[string];    IF labley # NIL THEN      BEGIN      IF data.labely # NIL THEN data.labely.length ¬ 0;      String.AppendStringAndGrow[@data.labely, labley, zone];      FormSW.DisplayItem[sw, FormItems[y].ORD];      Heap.systemZone.FREE[@labley];      END    ELSE Msg["\nselection is invalid\n"L];    Done[] };  ConvertSelection: PROC[] RETURNS[pairs: GraphToolOps.Pairs] =    BEGIN    i: NATURAL ¬ 0;    to: Environment.Block;    x1, x2, y: LONG INTEGER;    selection: Selection.Source;    length: CARDINAL ¬ CARDINAL[Selection.Convert[length]­];    IF length = 0 THEN RETURN[NIL];    selection ¬ Selection.Convert[source];    to ¬ [LOOPHOLE[zone.NEW[Bytes[length]]], 0, length];    --copy selection into an environment block for munging    WHILE i IN[0..length) DO      moved: NATURAL;      from: Environment.Block;      copier: LONG STRING ¬ [50];      selection.proc[selection.data, copier];      from ¬ [LOOPHOLE[@copier.text], 0, copier.length];      moved ¬ ByteBlt.ByteBlt[to: to, from: from];      to.startIndex ¬ to.startIndex + moved;      i ¬ i + moved;      ENDLOOP;    selection.destroy[selection];    BEGIN ENABLE Finished => CONTINUE;    --count how many pairs there are and find minx and maxx    to.startIndex ¬ 0;  --reset the starting point for search    length ¬ 0;  --set it here in case we don't get to the loop    x1 ¬ NextNumber[@to]; x2 ¬ NextNumber[@to]; y ¬ NextNumber[@to];    --UNTIL SIGNAL-- DO      length ¬ SUCC[length];  --count the length; we've already got one      [] ¬ NextNumber[@to]; x2 ¬ NextNumber[@to]; [] ¬ NextNumber[@to];      ENDLOOP;    END;  --ENABLE Finished => EXIT    --now parse the selection into data pairs    IF length = 0 THEN RETURN[NIL];    to.startIndex ¬ 0;  --reset the starting point again for conversion    pairs ¬ DESCRIPTOR[zone.NEW[PairArray[length]], length];    i ¬ 0;  --reset counting index    WHILE i < (LENGTH[pairs]) DO      x1 ¬ NextNumber[@to]; x2 ¬ NextNumber[@to]; y ¬ NextNumber[@to];      pairs[i] ¬ [x1, y]; i ¬ SUCC[i];       ENDLOOP;    --then free up the temp storage we had    zone.FREE[@to.blockPointer];    END;  --ConvertSelection  NextNumber: PROC[to: LONG POINTER TO Environment.Block] RETURNS[CARDINAL ¬ 0] =    BEGIN    string: LONG STRING ¬ [6];    WHILE to.startIndex < to.stopIndexPlusOne DO      c: CHARACTER ¬ LOOPHOLE[to.blockPointer[to.startIndex]];      to.startIndex ¬ SUCC[to.startIndex];      IF c ~IN['0..'9] THEN LOOP;      WHILE to.startIndex < to.stopIndexPlusOne DO        String.AppendChar[string, c];	c ¬ LOOPHOLE[to.blockPointer[to.startIndex]];	to.startIndex ¬ SUCC[to.startIndex];	IF c ~IN['0..'9] THEN	  RETURN[String.StringToDecimal[string]];	ENDLOOP;      ENDLOOP;    SIGNAL Finished;    END;  Plot:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK PlotInternal[]]};  PlotInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    pairs: GraphToolOps.Pairs = ConvertSelection[];    IF pairs # NIL THEN      BEGIN      Process.SetPriority[Process.priorityNormal];      GraphToolOps.CreateGraph[pairs, data];      END;    Done[] };  Table:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK TableInternal[]]};  TableInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    pairs: GraphToolOps.Pairs = ConvertSelection[];    lp: LONG POINTER ¬ pairs.BASE;    Process.SetPriority[Process.priorityNormal];    Write["\n"L]; Write[data.title];    Write["\n"L]; Write[data.labelx];    Write[" vs "L]; Write[data.labely];    Write["\n"L];    FOR i: NATURAL IN[0..LENGTH[pairs]) DO      LongDec[Write, pairs[i].x]; Write[": "L];      LongDec[Write, pairs[i].y]; Write["\n"L];      ENDLOOP;    zone.FREE[LONG[@lp]];    Done[] };  Stats:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK StatsInternal[]]};  StatsInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    mean, sigma, temp: REAL ¬ 0.0;    minx, miny: LONG INTEGER ¬ LAST[LONG INTEGER];    maxx, maxy, totalx, totaly: LONG INTEGER ¬ 0;    pairs: GraphToolOps.Pairs ¬ ConvertSelection[];    lp: LONG POINTER ¬ pairs.BASE;    Process.SetPriority[Process.priorityNormal];    FOR i: NATURAL IN[0..LENGTH[pairs]) DO      IF minx > pairs[i].x THEN minx ¬ pairs[i].x;      IF maxx < pairs[i].x THEN maxx ¬ pairs[i].x;      IF miny > pairs[i].y THEN miny ¬ pairs[i].y;      IF maxy < pairs[i].y THEN maxy ¬ pairs[i].y;      totalx ¬ totalx + pairs[i].y;      totaly ¬ totaly + pairs[i].x * pairs[i].y;      ENDLOOP;    mean ¬ Real.Float[totaly] / Real.Float[totalx];    FOR i: NATURAL IN[0..LENGTH[pairs]) DO      temp ¬ Real.Float[pairs[i].x];      temp ¬ mean - temp;      sigma ¬ sigma + (temp * temp);      ENDLOOP;    sigma ¬ RealFns.SqRt[sigma];    Write["\nTable's statistics"L];    Write["\n  MIN "L]; Write[data.labelx]; Write[": "L]; LongDec[Write, minx];    Write["\n  MAX "L]; Write[data.labelx]; Write[": "L]; LongDec[Write, maxx];    Write["\n  MEAN: "L]; PrintReal[Write, mean];    Write["\n  SIGMA: "L]; PrintReal[Write, sigma];    Write["\n"L];    zone.FREE[LONG[@lp]];    Done[] };  LongDec: PROC[proc: Format.StringProc, n: LONG INTEGER] =    {Format.LongDecimal[proc, n]};  --LongDec  PrintReal: PROC[put: Format.StringProc, real: REAL] =    BEGIN    string: LONG STRING ¬ [40];    Real.AppendReal[string, real];    put[string];    END;  --PutReal  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ zone.NEW[GraphToolOps.Data ¬ []];      new = inactive =>        IF data # NIL THEN {zone.FREE[@data]};      ENDCASE;    };  Init: PROCEDURE = {    Exec.AddCommand["GraphTool.~"L, NoOp, NIL, Unload];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: initialBox,      clientTransition: ClientTransition, name: "GraphTool"L,      cmSection: "GraphTool"L];    };      NoOp: Exec.ExecProc = { };    Unload: Exec.ExecProc = {    IF Busy[] THEN {      Exec.OutputProc[h]["Tool is busy. Sorry.\n"L];      RETURN[error] };    Tool.Destroy[wh];    Exec.RemoveCommand[h, "GraphTool.~"L];    Done[] };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [16];    Tool.UnusedLogName[unused: logName, root: "GraphTool.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: zone];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};  MakeForm: FormSW.ClientItemsProcType = {    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items ¬ FormSW.AllocateItemDescriptor[nItems, zone];    items[FormItems.title.ORD] ¬ FormSW.CommandItem[      tag: "Title"L, place: [CharPos[1], FormSW.line0], proc: Title, z: zone];    items[FormItems.ts.ORD] ¬ FormSW.StringItem[      tag: ""L, place: [CharPos[12], FormSW.line0], drawBox: TRUE, boxWidth: 128, inHeap: TRUE, string: @data.title, z: zone];    items[FormItems.labelX.ORD] ¬ FormSW.CommandItem[      tag: "Label-X"L, place: [CharPos[1], FormSW.line1], proc: LabelX, z: zone];    items[FormItems.x.ORD] ¬ FormSW.StringItem[      tag: ""L, place: [CharPos[12], FormSW.line1], drawBox: TRUE, boxWidth: 128, inHeap: TRUE, string: @data.labelx, z: zone];    items[FormItems.labelY.ORD] ¬ FormSW.CommandItem[      tag: "Label-Y"L, place: [CharPos[1], FormSW.line2], proc: LabelY, z: zone];    items[FormItems.y.ORD] ¬ FormSW.StringItem[      tag: ""L, place: [CharPos[12], FormSW.line2], drawBox: TRUE, boxWidth: 128, inHeap: TRUE, string: @data.labely, z: zone];    items[FormItems.plot.ORD] ¬ FormSW.CommandItem[      tag: "Plot"L, place: [CharPos[1], FormSW.line3], proc: Plot, z: zone];    items[FormItems.table.ORD] ¬ FormSW.CommandItem[      tag: "Table"L, place: [CharPos[12], FormSW.line3], proc: Table, z: zone];    items[FormItems.stats.ORD] ¬ FormSW.CommandItem[      tag: "Stats"L, place: [CharPos[25], FormSW.line3], proc: Stats, z: zone];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
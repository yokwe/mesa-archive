-- File: SptpTool.mesa - last edit:-- AOF                 25-Feb-88 19:55:13-- JAV                 22-Oct-87 11:54:46-- Copyright (C) 1987, 1988 by Xerox Corporation. All rights reserved.-- Create by FormSWLayoutTool on  1-Oct-87 10:40DIRECTORY  ArpaRouter USING [GetAddress],  ArpaSptp USING [AdoptForArpa, DisownFromArpa],  Buffer USING [    AccessHandle, Buffer, DestroyPool, Device, GetBuffer, MakePool,    ReturnBuffer],  Checksums USING [SetChecksum],  Driver USING [Device, GetDeviceChain],  Exec USING [AddCommand, ExecProc, Handle, OutputProc, RemoveCommand],  Format USING [Decimal, HostNumber, LongDecimal, StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, line0, line1, NotifyProcType, NumberItem, ProcType, TagOnlyItem],  Heap USING [Create, Delete],  IEEE8023 USING [maxDataBytesPerEthernetPacket],  Inline USING [LowByte, LowHalf],  NSBuffer USING [    AccessHandle, Body, Buffer, DestroyPool, GetBuffer, MakePool, ReturnBuffer],  NSTypes USING [    bytesPerIDPHeader, maxIDPDataBytes, maxIDPBytesPerPacket, WaitTime],  PhoneAdoption USING [AdoptForNS, DisownFromNS],  PhoneNet USING [Destroy, Initialize],  Process USING [    Abort, Detach, MsecToTicks, Pause, priorityBackground, SetPriority],  Protocol1 USING [    EncapsulateAndTransmit, GetContext, GetFamilyUnit, SetMaximumBufferSize],  Put USING [Text],  Router USING [FindMyHostID],  RoutingTable USING [NetworkContext],  RS232C USING [Create, ChannelHandle, CommParamObject, Delete],  Runtime USING [IsBound],  Socket USING [    ChannelHandle, Create, Delete, GetPacket, SetWaitTime, SocketNumber,    WaitTime],  SptpOps USING [GetDevice, GetProtocolInfo],  SptpProtocol USING [ProtocolObject, State],  System USING [    GetGreenwichMeanTime, HostNumber, NetworkAddress, nullNetworkNumber,    SocketNumber],  Time USING [Append, Unpack],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Box, Handle];SptpTool: MONITOR  IMPORTS    ArpaSptp, ArpaRouter, Checksums, Driver, Exec, Format, FormSW, Heap,    Inline, NSBuffer, PhoneAdoption, PhoneNet, Process, Protocol1, Put,    RS232C, Router, Runtime, Socket, SptpOps, System, Time, Tool, UserInput   EXPORTS Buffer = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    driver(6): BOOLEAN ¬ FALSE,    active(7): BOOLEAN ¬ FALSE,    line(8): CARDINAL ¬ 0,    sending(9): BOOLEAN ¬ FALSE,    sender(10): PROCESS ¬ NIL,    aborted(11): BOOLEAN ¬ FALSE,    duplex(12): BOOLEAN ¬ FALSE,    inflt(13): CARDINAL ¬ 1,    xns(14): BOOLEAN ¬ FALSE,    tcpip(15): BOOLEAN ¬ FALSE,    pup(16): BOOLEAN ¬ FALSE,    iso(17): BOOLEAN ¬ FALSE,    xnsAdopted(18): BOOLEAN ¬ FALSE,    tcpipAdopted(19): BOOLEAN ¬ FALSE,    sink(20): PROCESS ¬ NIL,    channel(21): RS232C.ChannelHandle ¬ TRASH];  FormItems: TYPE = {driver, active, line, sending, inflt, duplex, state, adopt, xns, tcpip, pup, iso};  bpw: NATURAL = 2;  maxBytes: NATURAL;  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  zone: UNCOUNTED ZONE ¬ Heap.Create[initial: 4];  tempSocket: System.SocketNumber = LOOPHOLE[1023];  LineData: TYPE = LONG POINTER TO LineDataObject;  LineDataObject: TYPE = RECORD[    length: NATURAL, seed: CARDINAL[0..256),    data: PACKED SEQUENCE COMPUTED CARDINAL OF CARDINAL[0..256)];  busyBit: BOOLEAN ¬ FALSE;  initialBox: Window.Box = [place: [x:512, y: 30], dims: [w: 512, h: 350]];  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    ENABLE UNWIND => NULL;    isBusy ¬ busyBit;    busyBit ¬ TRUE };  Done: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    busyBit ¬ FALSE};  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};  ToggleDriver:  FormSW.NotifyProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      data.driver ¬ ~data.driver;      FormSW.DisplayItem[sw, index];      RETURN};    Process.Detach[FORK ToggleDriverInternal[]]};  ToggleDriverInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    commParams: RS232C.CommParamObject ¬ [      lineSpeed: bps2400, duplex: IF data.duplex THEN half ELSE full,      lineType: bitSynchronous, accessDetail: directConn[]];    IF data.driver THEN      BEGIN      Write["Creating channel... "L];      data.channel ¬ RS232C.Create[        lineNumber: 0, commParams: @commParams,	preemptOthers: preemptNever, preemptMe: preemptNever];      Write["initializing driver... "L];      PhoneNet.Initialize[	lineNumber: data.line, channel: data.channel, commParams: @commParams,	negotiationMode: active, hardwareStatsAvailable: FALSE,	ourEntityClass: remoteHost];      FOR device: Driver.Device ¬ Driver.GetDeviceChain[], device.next	UNTIL device = NIL DO	IF (device.device = phonenet) AND (device.lineNumber = data.line) THEN	  BEGIN	  UNTIL UserInput.UserAbort[wh] DO	    IF device.alive THEN EXIT ELSE Write["."L];	    Process.Pause[Process.MsecToTicks[500]];	    ENDLOOP;	  data.driver ¬ data.active ¬ device.alive;	  IF ~data.active THEN	    BEGIN	    Write[" failed... deleting driver... "L];	    PhoneNet.Destroy[data.line];	    Write["deleting channel... "L];	    RS232C.Delete[data.channel];	    END	  ELSE	    BEGIN	    Write[" adopting... "L]; 	    IF data.xns AND	      Runtime.IsBound[LOOPHOLE[PhoneAdoption.AdoptForNS]] THEN	      BEGIN	      Write[" xns... "L];	      data.xnsAdopted ¬ TRUE;	      PhoneAdoption.AdoptForNS[data.line];	      Write["starting sink process... "L];	      data.sink ¬ FORK SendingSink[tempSocket];	     END;	   IF data.tcpip AND	      Runtime.IsBound[LOOPHOLE[ArpaSptp.AdoptForArpa]] THEN	      BEGIN	      Write[" tcpip... "L];	      data.tcpipAdopted ¬ TRUE;	      ArpaSptp.AdoptForArpa[ArpaRouter.GetAddress[], device];	      END;	   IF data.pup THEN Write[" no pup adoption... "L];	   IF data.iso THEN Write[" no iso adoption... "L];	   END;	  Write["done\n"L];	  EXIT;	  END;	ENDLOOP;      END    ELSE      BEGIN      IF data.xnsAdopted THEN        BEGIN	Write["Aborting sink... "L];	Process.Abort[data.sink]; JOIN data.sink;	Write["Disowning NS... "L];	PhoneAdoption.DisownFromNS[data.line];	Write["deleting driver... "L];	END      ELSE Write["Deleting driver... "L];      PhoneNet.Destroy[data.line];      Write["deleting channel... "L];      RS232C.Delete[data.channel];      data.driver ¬ data.active ¬ FALSE;      Write["done\n"L];      END;    FormSW.DisplayItem[data.formSW, FormItems.driver.ORD];    FormSW.DisplayItem[data.formSW, FormItems.active.ORD];    Done[] };  ToggleActive:  FormSW.NotifyProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      data.active ¬ ~data.active;      FormSW.DisplayItem[sw, index];      RETURN};    Process.Detach[FORK ToggleActiveInternal[]]};  ToggleActiveInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    FOR device: Driver.Device ¬ Driver.GetDeviceChain[], device.next      UNTIL device = NIL DO      IF (device.device = phonenet) AND (device.lineNumber = data.line) THEN        BEGIN	IF data.active THEN	  BEGIN	  Write["Activating... "L];	  device.activateDriver[];	  Write["adopting... "L];	  IF data.xns THEN {	    Write[" xns... "L];	    data.xnsAdopted ¬ TRUE;	    PhoneAdoption.AdoptForNS[data.line];	    Write["starting sink process... "L];	    data.sink ¬ FORK SendingSink[tempSocket]};	  IF data.tcpip THEN {	    Write[" tcpip... "L];	    data.tcpipAdopted ¬ TRUE;	    ArpaSptp.AdoptForArpa[ArpaRouter.GetAddress[], device]};	  IF data.pup THEN Write[" no pup adoption... "L];	  IF data.iso THEN Write[" no iso adoption... "L];	  END	ELSE	  BEGIN	  Write["Disowning... "L];	  IF data.xnsAdopted THEN {	    Write[" xns... "L];	    data.xnsAdopted ¬ FALSE;	    Process.Abort[data.sink]; JOIN data.sink;	    PhoneAdoption.DisownFromNS[data.line]};	  IF data.tcpipAdopted THEN {	    Write[" tcpip... "L];	    data.tcpipAdopted ¬ FALSE;	    ArpaSptp.DisownFromArpa[device]};	  Write["deactivating... "L];	  device.deactivateDriver[];	  END;	Write["done\n"L];	EXIT;	END;      REPEAT FINISHED => Write["Device not found!\n"L];      ENDLOOP;    Done[] };  ToggleSending:  FormSW.NotifyProcType =    BEGIN    device: Device = SptpOps.GetDevice[data.line];    SELECT TRUE FROM      (device = NIL) => {data.sending ¬ FALSE; Write["No device\n"L]};      (~data.sending) =>        BEGIN	IF data.sender = NIL THEN {Write["No sender running!\n"L]; RETURN};	data.aborted ¬ TRUE;  --so he'll stop	Process.Abort[data.sender]; JOIN data.sender; data.sender ¬ NIL;	Protocol1.SetMaximumBufferSize[  --reset the buffer sizes	  device, Protocol1.GetFamilyUnit[ns], NSTypes.maxIDPBytesPerPacket];	END;      (Busy[]) => {Write["Already sending!\n"L]; data.sending ¬ ~data.sending};      ENDCASE =>        BEGIN	him: System.NetworkAddress;	pi: SptpProtocol.ProtocolObject;	SptpOps.GetProtocolInfo[device, @pi];  --put some info in it	him ¬ [System.nullNetworkNumber, pi.him, tempSocket];	IF pi.protocolVersion # version4 THEN maxBytes ¬ NSTypes.maxIDPDataBytes	ELSE	  BEGIN	  maxBytes ¬ IEEE8023.maxDataBytesPerEthernetPacket - 	    NSTypes.bytesPerIDPHeader;	  Protocol1.SetMaximumBufferSize[	    device, Protocol1.GetFamilyUnit[ns],	    IEEE8023.maxDataBytesPerEthernetPacket];	  END;	data.aborted ¬ FALSE;  --so he'll run	data.sender ¬ FORK SendingSource[him];	END;    FormSW.DisplayItem[sw, index];    END;  --ToggleSending  SendingCompare: PROC[info: LineData] RETURNS[BOOLEAN] =    BEGIN    FOR i: NATURAL IN[0..info.length) DO      IF info[i] # Inline.LowByte[info.seed + i] THEN RETURN[TRUE]; ENDLOOP;    RETURN[FALSE];    END;  --SendingCompare  SendingSink: <<FORKED>> PROC[socket: System.SocketNumber] = {    sunk, bad: LONG CARDINAL ¬ 0;    cH: Socket.ChannelHandle = Socket.Create[socket];    Socket.SetWaitTime[cH, LAST[Socket.WaitTime]];    UNTIL --ABORTED OR-- data.aborted DO      ENABLE ABORTED => EXIT;      b: NSBuffer.Buffer ¬ Socket.GetPacket[cH];      IF SendingCompare[LOOPHOLE[@b.ns.nsBody]] THEN bad ¬ bad.SUCC;      NSBuffer.ReturnBuffer[b];      sunk ¬ sunk.SUCC;      ENDLOOP;    Socket.Delete[cH];    Write["\nPackets sunk: "L];    Format.LongDecimal[Write, sunk];    Write[", packets sunk bad: "L];    Format.LongDecimal[Write, bad];    Write["\n"L];    };  --SendingSink  SendingSource: <<FORKED>> PROC[him: System.NetworkAddress] = {    info: LineData;    b: NSBuffer.Buffer;    body: NSBuffer.Body;    me: System.NetworkAddress;    context: RoutingTable.NetworkContext;    sourced, bad, bytes, speed: LONG CARDINAL ¬ 0;    time: LONG CARDINAL ¬ System.GetGreenwichMeanTime[];    aH: NSBuffer.AccessHandle = NSBuffer.MakePool[data.inflt, 0];    baseL: NATURAL = NSTypes.bytesPerIDPHeader + (bpw * SIZE[LineDataObject]);    device: Device = SptpOps.GetDevice[data.line];    IF device = NIL THEN {Write["No device"L]; RETURN};    me ¬ [System.nullNetworkNumber, Router.FindMyHostID[], tempSocket];    context ¬ Protocol1.GetContext[device, ns];    Process.SetPriority[Process.priorityBackground];  --drop    Write["starting send process\n"L];    UNTIL --ABORTED-- (device = NIL) OR data.aborted OR ~device.alive DO      ENABLE ABORTED => EXIT;      body ¬ (b ¬ NSBuffer.GetBuffer[aH, send]).ns;      b.fo.network ¬ device; b.fo.context ¬ context;      body.source ¬ me; body.destination ¬ him;      body.packetType ¬ private; body.transportControl ¬ [FALSE, 0, 0];      body.pktLength ¬ baseL + CARDINAL[sourced MOD maxBytes];      bytes ¬ bytes + body.pktLength;      info ¬ LOOPHOLE[@body.nsBody];      info.seed ¬ Inline.LowByte[Inline.LowHalf[System.GetGreenwichMeanTime[]]];      info.length ¬ CARDINAL[sourced MOD maxBytes];      FOR i: NATURAL IN[0..info.length) DO info[i] ¬ info.seed + i; ENDLOOP;      Checksums.SetChecksum[body];  --compute check after modifying data      IF SendingCompare[info] THEN bad ¬ bad.SUCC;      Protocol1.EncapsulateAndTransmit[LOOPHOLE[b], @body.destination.host];      sourced ¬ sourced.SUCC;  --count another one out the door      ENDLOOP;    time ¬ System.GetGreenwichMeanTime[] - time;  --duration in seconds    speed ¬ (8 * bytes) / time;  --bits per second    NSBuffer.DestroyPool[aH];    Write["\nPackets sourced: "L];    Format.LongDecimal[Write, sourced];    Write[" ("L];    Format.LongDecimal[Write, speed];    Write[" bps), packets sourced bad: "L];    Format.LongDecimal[Write, bad];    Write["\nStopped send process\n"L];    IF ~data.aborted THEN  --we're stopped, but he has the shutdown code      {data.sending ¬ FALSE; Process.Detach[FORK ToggleSending[]]};    Done[] };  State:  FormSW.ProcType = {    ENABLE ABORTED => CONTINUE;    time: LONG STRING ¬ [30];    pi: SptpProtocol.ProtocolObject;    device: Device = SptpOps.GetDevice[data.line];    IF device = NIL THEN {Write["State not available\n"L]; RETURN};    SptpOps.GetProtocolInfo[device, @pi];    Write["ProtocolObject: [state: {"L];    Write[SELECT pi.state FROM      idle => "idle"L, option1 => "option1"L, option2 => "option2"L,      option3 => "option3"L, option4 => "option4"L, data => "data"L,      terminate1 => "terminate1"L, terminate2 => "terminate2"L,      ENDCASE => "????"L];    Write["}, master: {"L];    Write[SELECT pi.master FROM      me => "me"L, him => "him"L, ENDCASE => "undetermined"L];    Write["}, started: "L];    time.length ¬ 0; Time.Append[time, Time.Unpack[pi.started]]; Write[time];    Write[", established: "L];    time.length ¬ 0; Time.Append[time, Time.Unpack[pi.established]]; Write[time];    Write[", me: "L];    Format.HostNumber[Write, pi.me, hex];    Write[", him: "L];    Format.HostNumber[Write, pi.him, hex];    Write[", protocolVersion: {"L];    Write[SELECT pi.protocolVersion FROM      version4 => "version4"L, version3 => "version3"L,      version2 => "version2"L, ENDCASE => "????"L];    Write["}, linenumber: "L];    Format.Decimal[Write, pi.lineNumber];    Write[", duplex: {"L];    Write[SELECT pi.duplex FROM      full => "full"L, half => "half"L, ENDCASE => "????"L];    Write["}, ourEntityClass: "L];    Write[SELECT pi.ourEntityClass FROM      internetworkRouter => "internetworkRouter"L,      clusterRouter => "clusterRouter"L,      siu => "siu"L, remoteHost => "remoteHost"L, ENDCASE => "????"L];    Write["}, theirEntityClass: {"L];    Write[SELECT pi.theirEntityClass FROM      internetworkRouter => "internetworkRouter"L,      clusterRouter => "clusterRouter"L,      siu => "siu"L, remoteHost => "remoteHost"L, ENDCASE => "????"L];    Write["}]\nDevice throughput is "L];    Format.Decimal[Write, device.getThroughput[]];    Write[" kbits/second\n"L]};  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];      new = inactive =>        IF data # NIL THEN {	  zone.FREE[@data]};      ENDCASE;    };  Init: PROCEDURE = {    Exec.AddCommand["SptpTool.~"L, NoOp, NIL, Unload];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: initialBox,      clientTransition: ClientTransition, name: "SptpTool"L,      cmSection: "SptpTool"L];    };      NoOp: Exec.ExecProc = { };    Unload: Exec.ExecProc = {    IF Busy[] THEN {      Exec.OutputProc[h]["Tool is busy. Sorry.\n"L];      RETURN[error] };    Tool.Destroy[wh];    Exec.RemoveCommand[h, "SptpTool.~"L];    Heap.Delete[zone];    Done[] };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [17];    Tool.UnusedLogName[unused: logName, root: "SptpTool.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: zone];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  MakeForm: FormSW.ClientItemsProcType = {    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items ¬ FormSW.AllocateItemDescriptor[nItems, zone];    items[FormItems.driver.ORD] ¬ FormSW.BooleanItem[      tag: "driver"L, place: [6, FormSW.line0], drawBox: TRUE,      proc: ToggleDriver, switch: @data.driver, z: zone];    items[FormItems.active.ORD] ¬ FormSW.BooleanItem[      tag: "active"L, place: [66, FormSW.line0], drawBox: TRUE,      proc: ToggleActive, switch: @data.active, z: zone];    items[FormItems.line.ORD] ¬ FormSW.NumberItem[      tag: "line#"L, place: [126, FormSW.line0], signed: FALSE,      boxWidth: 16, default: 0, value: @data.line, z: zone];    items[FormItems.sending.ORD] ¬ FormSW.BooleanItem[      tag: "sending"L, place: [190, FormSW.line0], proc: ToggleSending,      switch: @data.sending, z: zone];    items[FormItems.inflt.ORD] ¬ FormSW.NumberItem[      tag: "inflt"L, place: [244, FormSW.line0], signed: FALSE,      boxWidth: 32, default: 0, value: @data.inflt, z: zone];    items[FormItems.duplex.ORD] ¬ FormSW.BooleanItem[      tag: ".5 duplex"L, place: [330, FormSW.line0],      switch: @data.duplex, z: zone];    items[FormItems.state.ORD] ¬ FormSW.CommandItem[      tag: "State"L, place: [412, FormSW.line0], proc: State, z: zone];    items[FormItems.adopt.ORD] ¬ FormSW.TagOnlyItem[      tag: "Adopt:"L, place: [0, FormSW.line1]];    items[FormItems.xns.ORD] ¬ FormSW.BooleanItem[      tag: "xns"L, place: [66, FormSW.line1], drawBox: TRUE,      switch: @data.xns, z: zone];    items[FormItems.tcpip.ORD] ¬ FormSW.BooleanItem[      tag: "tcpip"L, place: [96, FormSW.line1], drawBox: TRUE,      switch: @data.tcpip, z: zone];    items[FormItems.pup.ORD] ¬ FormSW.BooleanItem[      tag: "pup"L, place: [136, FormSW.line1], drawBox: TRUE,      switch: @data.pup, z: zone];    items[FormItems.iso.ORD] ¬ FormSW.BooleanItem[      tag: "iso"L, place: [166, FormSW.line1], drawBox: TRUE,      switch: @data.iso, z: zone];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
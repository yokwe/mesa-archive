-- File: RoutingCollectorImpl.mesa - last edit:-- AOF                 30-Aug-87 17:09:08-- Copyright (C) 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Buffer USING [Buffer, MakePool, DestroyPool, AccessHandle, ReturnBuffer, Type],  Courier USING [LocalSystemElement],  IEEE8023 USING [Encapsulation],  Driver USING [ChangeNumberOfInputBuffers, Device, GetDeviceChain],  Exec,  Format USING [    StringProc, Date, LongNumber, NetworkAddress, Number, NumberFormat],  FormSW,  Heap USING [Create, Delete],  HostNumbers USING [IsMulticastID],  Inline USING [LongDivMod, BITAND],  Mopcodes USING [zEXCH],  NSBuffer USING [Body],  Process,  Protocol1 USING [SetMaximumBufferSize],  Put USING [Line, Text],  Router USING [FindMyHostID],  Runtime USING [GetBcdTime],  SpecialCommunication USING [SetEthernetListener, SetSpyProc, SpyProc],  SpecialSystem USING [HostNumber, NetworkNumber],  String USING [AppendChar, AppendDecimal, AppendString],  System USING [    nullHostNumber, broadcastHostNumber, HostNumber, GetGreenwichMeanTime,    nullSocketNumber, GreenwichMeanTime, NetworkAddress, nullNetworkNumber],  Time USING [Append, Unpack],  Tool USING [    Create, Destroy, MakeFormSW, MakeSWsProc, MakeFileSW, UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Handle],  WSInfoClient USING [GetPilotInfo, GetXDEInfo];  RoutingCollectorImpl: MONITOR  IMPORTS    Buffer, Courier, Driver, SpecialCommunication, Put, FormSW, Router, Inline,    Protocol1, Runtime, String, System, Time, Tool, Heap, Format, WSInfoClient,    HostNumbers, Exec, Process  EXPORTS Buffer, System =  BEGIN    Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  HostNumber: PUBLIC <<System>> TYPE = SpecialSystem.HostNumber;  NetworkNumber: PUBLIC <<System>> TYPE = SpecialSystem.NetworkNumber;      wh: Window.Handle;  data: LONG POINTER TO ToolData ¬ NIL;  ToolData: TYPE = RECORD[    oldSpy: SpecialCommunication.SpyProc ¬ NIL,    form, log: Window.Handle ¬ NIL,    getinfo: BOOLEAN ¬ FALSE,    buffers: Buffer.AccessHandle ¬ NIL,    running: BOOLEAN ¬ FALSE,    started, good, routes, full, notOnes: LONG CARDINAL ¬ 0,    me: HostNumber ¬ NULL,    maxEntry, free: EntryHandle ¬ NIL,     table: ARRAY NATURAL[0..(modulo + 1) * 2) OF EntryObject ¬ TRASH];  FormItems: TYPE = {stop, go, report, reset, getinfo};  EntryHandle: TYPE =  LONG POINTER TO EntryObject;  EntryObject: TYPE = RECORD[    net: NetworkNumber, host: HostNumber, link: EntryHandle,    quests, answers, delayMin, delayMax: CARDINAL];  Hosts: TYPE = ARRAY NATURAL[0..(modulo + 1) * 2) OF HostNumber;  unit: CARDINAL = 1;  modulo: NATURAL = 127;  dispatcherBuffers: CARDINAL = 40;  zone: UNCOUNTED ZONE = Heap.Create[100];  null: HostNumber = System.nullHostNumber;  all: HostNumber = System.broadcastHostNumber;  allOnes: NetworkNumber = [LAST[CARDINAL], LAST[CARDINAL]];  busyBit: BOOLEAN ¬ FALSE;  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    ENABLE UNWIND => NULL;    isBusy ¬ busyBit;    busyBit ¬ TRUE };  Done: ENTRY PROCEDURE = {busyBit ¬ FALSE};  Write: Format.StringProc = {Put.Text[data.log, s]};    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Stop:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Write["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK StopInternal[]]};  StopInternal: PROCEDURE = {    OPEN data;    ENABLE ABORTED => {Done[]; CONTINUE};    IF running THEN      BEGIN      s: STRING ¬ [40];      running ¬ FALSE;      Buffer.DestroyPool[buffers];      [] ¬ SpecialCommunication.SetSpyProc[NIL, ns];      [] ¬ SpecialCommunication.SetEthernetListener[unit, me];      Driver.ChangeNumberOfInputBuffers[FALSE];      FOR device: Device ¬ Driver.GetDeviceChain[], device.next	UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 0];	ENDLOOP;      String.AppendString[s, "Collected stopped at "L];      Time.Append[s, Time.Unpack[]];      Put.Line[log, s];      ReportInternal[];      END;    Done[] };  Go:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Write["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK GoInternal[]]};  GoInternal: PROCEDURE = {    OPEN data;    ENABLE ABORTED => {Done[]; CONTINUE};    IF ~running THEN      BEGIN      s: STRING ¬ [40];      me ¬ Router.FindMyHostID[];      running ¬ TRUE;      String.AppendString[s, "Collected started at "L];      Time.Append[s, Time.Unpack[]];      Put.Line[log, s];      buffers ¬ Buffer.MakePool[dispatcherBuffers, 0];  --get large pool      Driver.ChangeNumberOfInputBuffers[TRUE];      [] ¬ SpecialCommunication.SetEthernetListener[unit, all];      FOR device: Device ¬ Driver.GetDeviceChain[], device.next        UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 1500];	ENDLOOP;      ResetInternal[];  --set all the counters      data.oldSpy ¬ SpecialCommunication.SetSpyProc[SpyProc, ns];      END;    Done[] };  Report:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Write["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK ReportInternal[]]};  ReportInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    h, m, s: CARDINAL;    string: STRING ¬ [80];    d: LONG CARDINAL ¬ System.GetGreenwichMeanTime[];    String.AppendString[string, "Time range: "L];    Time.Append[string, Time.Unpack[[data.started]]];    String.AppendString[string, " to "L];    Time.Append[string, Time.Unpack[[d]]];    Put.Line[data.log, string]; string.length ¬ 0;    d ¬ d - data.started;    String.AppendString[string, "Elpased time: "L];    [h, s] ¬ Inline.LongDivMod[d, 60*60];  --hours    IF h < 10 THEN String.AppendChar[string, '0];    String.AppendDecimal[string, h]; String.AppendChar[string, ':];    [m, s] ¬ Inline.LongDivMod[s, 60];  --minutes    IF m < 10 THEN String.AppendChar[string, '0];    String.AppendDecimal[string, m]; String.AppendChar[string, ':];    IF s < 10 THEN String.AppendChar[string, '0];    String.AppendDecimal[string, s]; Put.Line[data.log, string];    IF data.good # 0 THEN      BEGIN      Write["Total packets observed: "L];      Format.LongNumber[Write, data.good, []];      Write["\n"L];      END;    IF data.routes # 0 THEN      BEGIN      hi: NATURAL ¬ 0;  --to count hosts      hosts: LONG POINTER TO Hosts ¬ zone.NEW[Hosts];      addr: System.NetworkAddress ¬ Courier.LocalSystemElement[];      Write["Number of routing request packets observed: "L];      Format.LongNumber[Write, data.routes, []]; Write["\n"L];      IF data.notOnes # 0 THEN        BEGIN	Format.LongNumber[Write, data.notOnes, []];	Write[" of the requests were not broadcasts packets\n"L];	END;      addr.socket ¬ System.nullSocketNumber;      Write["\nHosts observed transmitting routing request packets\n\n"L];      FOR hash: NATURAL IN[0..modulo] DO	entry: EntryHandle ¬ @data.table[hash];	UNTIL entry.host = null DO	  BEGIN	  FOR i: NATURAL IN[0..hi) DO	    IF hosts[i] = entry.host THEN GOTO skipThisOne;	    REPEAT FINISHED => {hosts[hi] ¬ entry.host; hi ¬ SUCC[hi]};	    ENDLOOP;	  addr.host ¬ entry.host;	  Format.NetworkAddress[Write, addr, octal];	  SELECT TRUE FROM	    (~data.getinfo) => Write["\n"L];	    (~HostNumbers.IsMulticastID[@addr.host]) => WriteInfo[addr];	    ENDCASE => Write["Source is a multicast id\n"L];	  Write["This machine sent routing requests for the following nets\n"L];	  PrintAllNets[entry];	  EXITS skipThisOne => NULL;	  END;	  IF (entry ¬ entry.link) = NIL THEN EXIT;	  ENDLOOP;	ENDLOOP;      zone.FREE[@hosts];      Write["\n"L];      END;    Done[] };  Reset:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Write["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK ResetInternal[]]};  ResetInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    data.good ¬ data.routes ¬ data.full ¬ data.notOnes ¬ 0;    data.table ¬ ALL[[System.nullNetworkNumber, null, NIL, 1, 0, 16, 0]];    data.free ¬ @data.table[modulo + 1];    data.maxEntry ¬ @data.table[LENGTH[data.table] - 1];    data.started ¬ System.GetGreenwichMeanTime[];    Write["Counters reset\n"L];    Done[] };  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      (new = inactive) AND (data # NIL) => {StopInternal[]; zone.FREE[@data]};      (old = inactive) AND (data = NIL) => {data ¬ zone.NEW[ToolData]};      ENDCASE;    };      NoOp: Exec.ExecProc = { };    Unload: Exec.ExecProc = {    IF Busy[] THEN {      Exec.OutputProc[h]["Tool is busy. Sorry.\n"L];      RETURN[error] };    Tool.Destroy[wh]; Heap.Delete[zone];    Exec.RemoveCommand[h, "RoutingCollector.~"L];    Done[] };  MakeForm: FormSW.ClientItemsProcType = {    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items ¬ FormSW.AllocateItemDescriptor[nItems, zone];    items[FormItems.stop.ORD] ¬ FormSW.CommandItem[      tag: "Stop"L, place: [0, FormSW.line0], proc: Stop, z: zone];    items[FormItems.go.ORD] ¬ FormSW.CommandItem[      tag: "Go"L, place: [44, FormSW.line0], proc: Go, z: zone];    items[FormItems.report.ORD] ¬ FormSW.CommandItem[      tag: "Report"L, place: [76, FormSW.line0], proc: Report, z: zone];    items[FormItems.reset.ORD] ¬ FormSW.CommandItem[      tag: "Reset"L, place: [128, FormSW.line0], proc: Reset, z: zone];    items[FormItems.getinfo.ORD] ¬ FormSW.BooleanItem[      tag: "get info"L, place: [178, FormSW.line0], drawBox: TRUE,      switch: @data.getinfo, z: zone];    RETURN[items: items, freeDesc: TRUE];    };      Initialize: PROCEDURE =    BEGIN    herald: STRING ¬ [60];    Exec.AddCommand["RoutingCollector.~"L, NoOp, NIL, Unload];    String.AppendString[to: herald, from: "Routing Packet Collector of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 8;  -- omit hours, mins, zone.    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: herald];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "RoutingCollector.log"L];    data.form ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: zone];    data.log ¬ Tool.MakeFileSW[window: window, name: logName];    END;  PrintAllNets: PROC[entry: EntryHandle] =    BEGIN    Exch: PROC[NetworkNumber] RETURNS [LONG UNSPECIFIED] =      MACHINE CODE {Mopcodes.zEXCH};    him: HostNumber = entry.host;    nf: Format.NumberFormat = [10, FALSE, TRUE, 10];    nnf: Format.NumberFormat = [8, FALSE, TRUE, 10];    Write["       Net  requests   answers       min       max\n"L];    UNTIL entry = NIL DO      IF entry.host = him THEN        BEGIN	IF entry.net = allOnes THEN Write["         *"L]	ELSE Format.LongNumber[Write, Exch[entry.net], nnf];	Format.Number[Write, entry.quests, nf];	Format.Number[Write, entry.answers, nf];	Format.Number[Write, entry.delayMin, nf];	Format.Number[Write, entry.delayMax, nf];	Write["\n"L];	END;      entry ¬ entry.link;  --go to next in list      ENDLOOP;    Write["\n\n"L];    END;  --PrintAllNets    WriteInfo: PROCEDURE [who: System.NetworkAddress] =    BEGIN    bfVersion: LONG STRING ¬ [6];    sysVolName: LONG STRING ¬ [40];    pVName: LONG STRING ¬ [40];    userName: LONG STRING ¬ [40];    answered, loggedIn: BOOLEAN;    time, timeBooted, bfCreateDate: System.GreenwichMeanTime;        [answered, time, timeBooted, bfCreateDate]  ¬ WSInfoClient.GetPilotInfo[      who, sysVolName, pVName];    IF answered THEN {      Write["  Physical volume: "L]; Write[pVName]; Write["\n"L];      Write["  System volume: "L]; Write[sysVolName]; Write["\n"L];      Write["  Processor clock: "L]; Format.Date[Write, time, full]; Write["\n"L];      Write["  Booted on "L]; Format.Date[Write, timeBooted, full]; Write["\n"L];      Write["  Boot file created on "L];        Format.Date[Write, bfCreateDate, full]; Write["\n"L]}    ELSE {Write["  No reply\n\n"L]; RETURN};        [answered, loggedIn] ¬ WSInfoClient.GetXDEInfo[who, bfVersion, userName];    IF answered THEN {      Write["  Boot file version: "L]; Write[bfVersion]; Write["\n"L];      Write["  User: "L];        Write[userName]; IF loggedIn THEN Write[" (logged in)"L]; Write["\n"L]}    ELSE Write["No XDE information available\n"L];    Write["\n"L];    END;  --WriteInfo	  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Worker routines:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SpyProc: SpecialCommunication.SpyProc =   --PROC[b: Buffer.Buffer, function: Buffer.Function] RETURNS[Buffer.Buffer]    BEGIN    dest: SpecialSystem.HostNumber;    e: IEEE8023.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];    body: NSBuffer.Body ¬ LOOPHOLE[b.highLayer.blockPointer];    SELECT TRUE FROM      (function = send) => NULL;  --don't include our own traffic      (body.packetType # routingInformation) => data.good ¬ SUCC[data.good];      (body.routingType = routingInfoRequest) =>	BEGIN	hash: NATURAL = Inline.BITAND[e.ethernetSource.f, modulo];	net: NetworkNumber = body.routingTuple[0].objectNetID;	entry: EntryHandle ¬ @data.table[hash];	data.routes ¬ SUCC[data.routes];	IF net = allOnes THEN GOTO skip;	IF ~HostNumbers.IsMulticastID[@e.ethernetDest] THEN	  {data.notOnes ¬ SUCC[data.notOnes]; GOTO skip};	UNTIL (entry.host = e.ethernetSource) AND (entry.net = net) DO	  SELECT TRUE FROM	    (entry.host = null) =>	      {entry.host ¬ e.ethernetSource; entry.net ¬ net};	    (entry.link # NIL) => {entry ¬ entry.link; LOOP};	    (data.free = data.maxEntry) => data.full ¬ SUCC[data.full];	    ENDCASE =>	      BEGIN	      entry.link ¬ data.free; entry ¬ data.free;	      data.free ¬ data.free + SIZE[EntryObject];	      entry.host ¬ e.ethernetSource; entry.net ¬ net;	      END;	  EXIT;	  REPEAT FINISHED => entry.quests ¬ SUCC[entry.quests];	  ENDLOOP;	EXITS skip => NULL;	END;      (HostNumbers.IsMulticastID[@e.ethernetDest]) => NULL;  --gratuitous      (body.routingType = routingInfoResponse) =>	BEGIN	hash: NATURAL = Inline.BITAND[e.ethernetDest.f, modulo];	net: NetworkNumber = body.routingTuple[0].objectNetID;	delay: NATURAL = body.routingTuple[0].interrouterDelay;	entry: EntryHandle ¬ @data.table[hash];	data.routes ¬ SUCC[data.routes];	IF net = allOnes THEN GOTO skip;	UNTIL (entry.host = e.ethernetDest) AND (entry.net = net) DO	  SELECT TRUE FROM	    (entry.host = null) => EXIT;  --we need a match	    (entry.link = NIL) => EXIT;  --nowhere to go	    ENDCASE => entry ¬ entry.link;  --chase the chain	  REPEAT FINISHED =>	    BEGIN	    IF delay < entry.delayMin THEN entry.delayMin ¬ delay;	    IF delay > entry.delayMax THEN entry.delayMax ¬ delay;	    entry.answers ¬ SUCC[entry.answers];	    END;	  ENDLOOP;	EXITS skip => NULL;	END;      ENDCASE => data.good ¬ SUCC[data.good];    IF data.oldSpy # NIL THEN      {b ¬ data.oldSpy[b, function]; IF b = NIL THEN RETURN[NIL]};    dest ¬ LOOPHOLE[      b.linkLayer.blockPointer, IEEE8023.Encapsulation].ethernetDest;    SELECT TRUE FROM      (function = send) => RETURN[b];      (dest = LOOPHOLE[data.me]) => RETURN[b];      (dest = LOOPHOLE[all]) => RETURN[b];      ENDCASE => {Buffer.ReturnBuffer[b]; RETURN[NIL]};    END;  -- Mainline code:    Initialize[];    END.
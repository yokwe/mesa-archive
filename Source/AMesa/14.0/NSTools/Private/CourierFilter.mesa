-- File: CourierFilter.mesa - last edit:-- AOF                  3-Nov-87 10:16:58-- BKI                  2-Jul-87 18:21:33-- SMA                  3-Dec-85 10:32:58-- Copyright (C) 1983, 1984, 1987 by Xerox Corporation. All rights reserved. -- File: CourierFilter.mesa   The implementation for the Courier spy ToolDIRECTORY  Buffer USING [Buffer, BufferObject],  BufferDisplay USING [AppendHeaderPiece, LineOverflow, Format, PacketData],  CourierProtocol USING [    dataSST, ExchWords, Protocol, ProtocolRange, Protocol2Body, Protocol3Body],  CourierSpy,  IEEE8023 USING [Encapsulation],  Flipper USING [    ClearCounts, Create, Disable, Enable, Enumerated, EnumeratedDescriptor],  Format USING [HostNumber, NetworkNumber, StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, line2, line1,    NotifyProcType],  MataHariInternal USING [z],  NSConstants USING [courierSocket],  NSTypes USING [BufferBody, ConnectionID],  Process USING [Pause, priorityNormal, SecondsToTicks],  Router USING [AssignAddress],  Runtime USING [GetBcdTime],  SpecialSpy USING [    DisplayProc, Mode, SetNSSpyTrigger, SetStateChangeProcs, StartProc,    TriggerProc],  String USING [AppendChar, AppendLongDecimal, AppendLongNumber, AppendString],  System USING [NetworkAddress, Pulses, TimerHandle],  Time USING [Append, Unpack],  Tool USING [Create, Destroy, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  Version USING [Append],  Window USING [Handle];CourierFilter: PROGRAM  IMPORTS    BufferDisplay, CourierProtocol, Flipper, Format, FormSW,    MataHariInternal, Process, Router, Runtime, SpecialSpy, String,    Time, Tool, Version  EXPORTS CourierSpy =  BEGIN  flipperCnt: CARDINAL = 2;  typeFlp, callFlp: LONG CARDINAL ¬ 0;  flipItems: Flipper.EnumeratedDescriptor ¬ DESCRIPTOR[flipItemsArray];  flipItemsArray: ARRAY [0..flipperCnt) OF Flipper.Enumerated ¬ [    ["type"L, @typeFlp], ["calls"L, @callFlp]];  -- TYPES  ConnectionHandle: TYPE = LONG POINTER TO ConnectionObject;  ConnectionObject: TYPE = RECORD [    link: ConnectionHandle ¬ NIL,    unique: CARDINAL,  --a montonically increasing number (queue management)    endOfMessage: BOOLEAN ¬ TRUE,  --used to determine Courier state    streamState: StreamState ¬ unconnected,  --for stream type connections (spp)    protocolState: ProtocolState ¬ unknown,  --Courier's protocol exchange    callInProgress: BOOLEAN ¬ FALSE,  --used to determine Courier state    version: CourierProtocol.Protocol ¬ protocol2,  --version of connection    range: CourierProtocol.ProtocolRange ¬ [protocol2, protocol2],  --just storage    time: System.Pulses,  --that the last packet was displayed on this connection    source, destination: System.NetworkAddress,    sourceID, destinationID: NSTypes.ConnectionID ¬ [0],    established, used: System.TimerHandle];  --connection display data  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    formSW(0): Window.Handle ¬ NIL,    flipperSW(2): Window.Handle ¬ NIL,    courierFields(4): BOOLEAN ¬ TRUE,    data(5): BOOLEAN ¬ TRUE,    flippers(6): BOOLEAN ¬ TRUE];  ProtocolState: TYPE = {unknown, halfKnown, fullyKnown};  StreamState: TYPE = {unconnected, halfConnected, fullyConnected};  -- VARIABLES and CONSTANTS  globalLine: LONG STRING ¬ NIL;  tool: DataHandle ¬ NIL;  displayWidth: CARDINAL = 250;  -- minimum length of display line.  displayFormat: BufferDisplay.Format;  -- From the SetNSSpyTrigger call.  courierFields: BOOLEAN ¬ FALSE;  -- snapshot of the tool parameter.  connect: RECORD [head: ConnectionHandle ¬ NIL];  c: ConnectionHandle ¬ NIL;  data: BOOLEAN ¬ FALSE;  -- snapshot of the tool parameter  trigger: SpecialSpy.TriggerProc ¬ NIL;  clientWh: Window.Handle ¬ NIL;  -- the client handle passed when trigger set.  wh: Window.Handle;  -- our window.  uniqueConn: CARDINAL ¬ 0;  -- PROCEDURES  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        IF tool = NIL THEN tool ¬ MataHariInternal.z.NEW[Data ¬ []];        SpecialSpy.SetStateChangeProcs[Start, Stop];        END;      new = inactive =>        BEGIN        SpecialSpy.SetStateChangeProcs[NIL, NIL];        Stop[];        IF tool # NIL THEN MataHariInternal.z.FREE[@tool];        IF clientWh # NIL THEN  -- Get rid of the client tool.  (if any)           BEGIN Tool.Destroy[clientWh]; clientWh ¬ NIL; END;        END;      ENDCASE;    END;  -- ClientTransition  DisplayCourierPacket: PROC [b: Buffer.Buffer, line: LONG STRING]    RETURNS [LONG POINTER] =    -- Displays a courier packet.    BEGIN    ExchangeProtocol: PROC [      protocol: LONG POINTER TO CourierProtocol.ProtocolRange]      RETURNS [LONG POINTER] =      BEGIN      String.AppendString[line, "protocol["L];      BufferDisplay.AppendHeaderPiece[displayFormat, @protocol.low, 1, line];      String.AppendString[globalLine, ", "L];      BufferDisplay.AppendHeaderPiece[displayFormat, @protocol.high, 1, line];      String.AppendString[line, "]  "L];      c.version ¬ MIN[c.range.high, protocol.high];      c.range ¬ protocol­;      c.protocolState ¬ SUCC[c.protocolState];      RETURN[protocol + SIZE[CourierProtocol.ProtocolRange]];      END;  --ExchangeProtocol    Protocol2Msg: PROC [body: LONG POINTER TO CourierProtocol.Protocol2Body]      RETURNS [msg: LONG POINTER] =      BEGIN      msg ¬ body;      WITH p2b: body SELECT FROM        call =>          BEGIN          String.AppendString[line, "call[transaction: "L];          BufferDisplay.AppendHeaderPiece[            displayFormat, @p2b.transaction, 1, line];          String.AppendString[line, ", program: "L];          BufferDisplay.AppendHeaderPiece[displayFormat, @p2b.program, 1, line];          String.AppendString[line, ", version: "L];          BufferDisplay.AppendHeaderPiece[displayFormat, @p2b.version, 1, line];          String.AppendString[line, ", procedure: "L];          BufferDisplay.AppendHeaderPiece[displayFormat, @p2b.procedure, 1, line];          String.AppendChar[line, ']];          msg ¬ msg + SIZE[call CourierProtocol.Protocol2Body];          c.callInProgress ¬ TRUE;          callFlp ¬ callFlp + 1;          END;        reject =>          BEGIN          String.AppendString[line, "reject[transaction: "L];          BufferDisplay.AppendHeaderPiece[            displayFormat, @p2b.transaction, 1, line];          String.AppendString[line, ", reject: "L];          String.AppendString[            line,            SELECT p2b.reject FROM              noSuchProgramNumber => "noSuchProgramNumber("L,              noSuchVersionNumber => "noSuchVersionNumber("L,              noSuchProcedureValue => "noSuchProcedureValue("L,              invalidArguments => "invalidArguments(",              ENDCASE => "????("L];          BufferDisplay.AppendHeaderPiece[displayFormat, @p2b.reject, 1, line];          String.AppendChar[line, ')];          msg ¬ msg + SIZE[reject CourierProtocol.Protocol2Body];          c.callInProgress ¬ FALSE;          END;        return =>          BEGIN          String.AppendString[line, "return[transaction: "L];          BufferDisplay.AppendHeaderPiece[            displayFormat, @p2b.transaction, 1, line];          String.AppendChar[line, ']];          msg ¬ body + SIZE[return CourierProtocol.Protocol2Body];          c.callInProgress ¬ FALSE;          END;        abort =>          BEGIN          String.AppendString[line, "abort[transaction: "L];          BufferDisplay.AppendHeaderPiece[            displayFormat, @p2b.transaction, 1, line];          String.AppendString[line, ", abort: "L];          BufferDisplay.AppendHeaderPiece[displayFormat, @p2b.abort, 1, line];          String.AppendChar[line, ']];          msg ¬ msg + SIZE[abort CourierProtocol.Protocol2Body];          c.callInProgress ¬ FALSE;          END;        ENDCASE =>          BEGIN          String.AppendString[line, " ????( "L];          BufferDisplay.AppendHeaderPiece[            displayFormat, LOOPHOLE[body, LONG POINTER TO CARDINAL], 1, line];          String.AppendChar[line, ')];          END;      END;  --Protocol2Msg    Protocol3Msg: PROC [body: LONG POINTER TO CourierProtocol.Protocol3Body]      RETURNS [msg: LONG POINTER] =      BEGIN      msg ¬ body;      WITH p3b: body SELECT FROM        call =>          BEGIN          program: LONG CARDINAL ¬ CourierProtocol.ExchWords[p3b.program];          String.AppendString[line, "call[transaction: "L];          BufferDisplay.AppendHeaderPiece[            displayFormat, @p3b.transaction, 1, line];          String.AppendString[line, ", program: "L];          SELECT displayFormat FROM            octal1, octal2, ascii, ebcdic => {              String.AppendLongNumber[line, program, 8];              String.AppendChar[line, 'B]};            hex => {              String.AppendLongNumber[line, program, 16];              String.AppendChar[line, 'H]};            decimal => String.AppendLongDecimal[line, program];            ENDCASE => ERROR;          String.AppendString[line, ", version: "L];          BufferDisplay.AppendHeaderPiece[displayFormat, @p3b.version, 1, line];          String.AppendString[line, ", procedure: "L];          BufferDisplay.AppendHeaderPiece[displayFormat, @p3b.procedure, 1, line];          String.AppendChar[line, ']];          msg ¬ msg + SIZE[call CourierProtocol.Protocol3Body];          c.callInProgress ¬ TRUE;          END;        reject =>          BEGIN          String.AppendString[line, "reject[transaction: "L];          BufferDisplay.AppendHeaderPiece[            displayFormat, @p3b.transaction, 1, line];          String.AppendString[line, ", reject: "L];          WITH rP3b: p3b SELECT FROM            noSuchProgramNumber =>              BEGIN              String.AppendString[line, "noSuchProgramNumber"L];              msg ¬                msg + SIZE[                  noSuchProgramNumber reject CourierProtocol.Protocol3Body];              END;            noSuchVersionNumber =>              BEGIN              String.AppendString[line, "noSuchVersionNumber[range: "L];              BufferDisplay.AppendHeaderPiece[                displayFormat, @rP3b.range.low, 1, line];              String.AppendString[line, ", "L];              BufferDisplay.AppendHeaderPiece[                displayFormat, @rP3b.range.high, 1, line];              String.AppendChar[line, ']];              msg ¬                msg + SIZE[                  noSuchVersionNumber reject CourierProtocol.Protocol3Body];              END;            noSuchProcedureValue =>              BEGIN              String.AppendString[line, "noSuchProcedureValue"L];              msg ¬                msg + SIZE[                  noSuchProcedureValue reject CourierProtocol.Protocol3Body];              END;            ENDCASE =>              BEGIN              String.AppendString[line, "invalidArguments"L];              msg ¬                msg + SIZE[invalidArguments reject CourierProtocol.Protocol3Body];              END;          String.AppendChar[line, ']];          c.callInProgress ¬ FALSE;          END;        return =>          BEGIN          String.AppendString[line, "return[transaction: "L];          BufferDisplay.AppendHeaderPiece[            displayFormat, @p3b.transaction, 1, line];          String.AppendChar[line, ']];          msg ¬ body + SIZE[return CourierProtocol.Protocol3Body];          c.callInProgress ¬ FALSE;          END;        abort =>          BEGIN          String.AppendString[line, "abort[transaction: "L];          BufferDisplay.AppendHeaderPiece[            displayFormat, @p3b.transaction, 1, line];          String.AppendString[line, ", abort: "L];          BufferDisplay.AppendHeaderPiece[displayFormat, @p3b.abort, 1, line];          String.AppendChar[line, ']];          msg ¬ msg + SIZE[abort CourierProtocol.Protocol3Body];          c.callInProgress ¬ FALSE;          END;        ENDCASE =>          BEGIN          String.AppendString[line, " Invalid message("L];          BufferDisplay.AppendHeaderPiece[            displayFormat, LOOPHOLE[body, LONG POINTER TO CARDINAL], 1, line];          String.AppendChar[line, ')];          END;      END;  --Protocol3Msg    msg: LONG POINTER ¬ @np.sppWords;    np: LONG POINTER TO NSTypes.BufferBody = LOOPHOLE[b.linkLayer.blockPointer];    base: POINTER TO Buffer.BufferObject ¬ NIL;    fixedOverhead: CARDINAL ¬      LOOPHOLE[@base.bufferBody, CARDINAL] - LOOPHOLE[base, CARDINAL];    String.AppendString[line, "  "L];    IF c.protocolState # fullyKnown THEN msg ¬ ExchangeProtocol[msg];    IF      (LOOPHOLE[msg, LONG CARDINAL] - LOOPHOLE[b, LONG CARDINAL] - fixedOverhead -         SIZE[IEEE8023.Encapsulation] - (np.pktLength / 2)) # 0 THEN      BEGIN      SELECT c.version FROM        protocol2 => msg ¬ Protocol2Msg[msg];        protocol3 => msg ¬ Protocol3Msg[msg];        ENDCASE;      c.endOfMessage ¬ np.endOfMessage;      END    ELSE c.endOfMessage ¬ TRUE;    IF courierFields THEN SpecialSpy.DisplayProc[line];    line.length ¬ 0;    -- Now display the data    IF data THEN      BEGIN      BufferDisplay.PacketData[        displayFormat, b, msg, line, SpecialSpy.DisplayProc !        BufferDisplay.LineOverflow =>          BEGIN          String.AppendString[line, " ..."L];          SpecialSpy.DisplayProc[line];          CONTINUE;          END];      line.length ¬ 0;      msg ¬ NIL;      END;    RETURN[msg];    END;  -- DisplayCourierPacket  CSpy: SpecialSpy.TriggerProc =    BEGIN  -- The filtering procedure that gets called by the NSSpyTool just     -- before it returns the buffer to the dispatcher.    np: LONG POINTER TO NSTypes.BufferBody = LOOPHOLE[b.linkLayer.blockPointer];    CreateNewConnection: PROC RETURNS [success: BOOLEAN ¬ FALSE] =      BEGIN      -- Does it use the courier well-know socket?      IF (np.source.socket = NSConstants.courierSocket)        OR (np.destination.socket = NSConstants.courierSocket) THEN        BEGIN        c ¬ MataHariInternal.z.NEW[          ConnectionObject ¬ [          link: NIL, source: np.source, destination: np.destination,          sourceID: [0], unique: uniqueConn ¬ uniqueConn + 1,          established: [b.fo.time], time: [b.fo.time], used: [[0]]]];        c.link ¬ connect.head;        connect.head ¬ c;        success ¬ TRUE;        END;      END;  --CreateNewConnection    newDataPtr ¬ oldDataPtr;    save ¬ FALSE;    SELECT mode FROM      collect =>        --test for possible Courier message object        IF np.packetType = sequencedPacket THEN          BEGIN          FOR c ¬ connect.head, c.link UNTIL c = NIL DO  -- look for connection.            IF              ((np.destinationConnectionID = c.sourceID)                AND (np.destination.host = c.source.host))              OR                ((np.sourceConnectionID = c.sourceID)                  AND (np.source.host = c.source.host)) THEN EXIT;  -- got it!            REPEAT              FINISHED =>                IF ~CreateNewConnection[] THEN RETURN                ELSE {c.sourceID ¬ np.sourceConnectionID};            ENDLOOP;          -- Does packet carry Courier DATA?          IF (np.subtype = CourierProtocol.dataSST) AND (c.endOfMessage)            AND (~np.systemPacket) THEN {typeFlp ¬ typeFlp + 1; save ¬ TRUE};          END;  --sequencedPacket      display =>  --we are assuming no other filters at this level!        newDataPtr.blockPointer ¬ DisplayCourierPacket[b, globalLine];      ENDCASE;    END;  -- CSpy  Init: PROCEDURE =    BEGIN    lnA: System.NetworkAddress ¬ Router.AssignAddress[];    stringProc: Format.StringProc = {String.AppendString[name, s]};    name: STRING ¬ [120];    String.AppendString[name, "CourierFilter "L];    Version.Append[name];    String.AppendString[name, " of "L];    Time.Append[name, Time.Unpack[Runtime.GetBcdTime[]]];    String.AppendString[name, " running on "L];    Format.NetworkNumber[stringProc, lnA.net, octal];    String.AppendChar[name, '.];    Format.HostNumber[stringProc, lnA.host, octal];    String.AppendChar[name, '.];    tool ¬ MataHariInternal.z.NEW[Data ¬ []];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: active,      initialBox: [place: [x: 800, y: 500], dims: [w: 300, h: 200]],      clientTransition: ClientTransition, name: name, cmSection: "CourierFilter"L,      tinyName1: "Courier"L, tinyName2: "Filter"L];    END;  -- Init  MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    j: CARDINAL;    nItems: CARDINAL = 3;    items ¬ AllocateItemDescriptor[nItems];    items[j ¬ 0] ¬ BooleanItem[      tag: "Courier fields"L, place: [0, line1], switch: @tool.courierFields];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Data"L, place: [130, line1], switch: @tool.data];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Flippers"L, place: [0, line2], switch: @tool.flippers,      proc: ToggleFlippers];    IF (j + 1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;  -- MakeForm  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "CourierFilter.log"L];    tool.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    tool.flipperSW ¬ Flipper.Create[      parent: window, flippers: flipItems, priority: Process.priorityNormal,      position: leftJustified];    END;  SetCourierTrigger: PUBLIC PROC [    newTrig: SpecialSpy.TriggerProc ¬ NIL, wh: Window.Handle]    RETURNS [oldTrig: SpecialSpy.TriggerProc] =    BEGIN    clientWh ¬ wh;  -- For destroying the client tool if we get destroyed.    oldTrig ¬ trigger;    trigger ¬ newTrig;    END;  -- SetTrigger  Start: SpecialSpy.StartProc =    BEGIN    displayFormat ¬ format;    Flipper.ClearCounts[tool.flipperSW];    courierFields ¬ tool.courierFields;    data ¬ tool.data;    globalLine ¬ MataHariInternal.z.NEW[      StringBody [displayWidth] ¬ [length: 0, maxlength: displayWidth, text:]];    [] ¬ SpecialSpy.SetNSSpyTrigger[CSpy, wh];    END;  -- Start  Stop: PROC =    BEGIN    tmp, next: ConnectionHandle ¬ NIL;    [] ¬ SpecialSpy.SetNSSpyTrigger[NIL, wh];  -- unhook it.    Process.Pause[Process.SecondsToTicks[1]];  -- Give display a chance to finish.    -- Clean house.    MataHariInternal.z.FREE[@globalLine];    next ¬ connect.head;    UNTIL (tmp ¬ next) = NIL DO      next ¬ next.link; MataHariInternal.z.FREE[@tmp]; ENDLOOP;    connect.head ¬ NIL;    END;  -- Stop  ToggleFlippers: FormSW.NotifyProcType =    BEGIN    IF tool.flippers THEN Flipper.Enable[tool.flipperSW]    ELSE Flipper.Disable[tool.flipperSW];    END;  -- ToggleFlippers  -- Mainline code  Init[];  END.   
-- File: TrashCollectorImpl.mesa - last edit:-- AOF                 25-Jul-88 14:26:49-- Copyright (C) 1984, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [    Error, ErrorRecord, NetworkAddress, PrintError, StringToNetworkAddress],  Buffer USING [    AccessHandle, Buffer, DestroyPool, Device, MakePool, ReturnBuffer, Type],  CmFile USING [    Close, Error, FindSection, FreeString, Handle, NextItem, UserDotCmOpen],  Courier USING [LocalSystemElement],  DataLinkControl USING [AdjustInputQueueLength],  Driver USING [Device, GetDeviceChain],  Environment USING [Block],  EthernetDriverFriends USING [EtherStatsInfo, GetEthernetStats],  EthernetFace USING [Status],  Exec USING [    AddCommand, EndOfCommandLine, ExecProc, FreeTokenString, GetToken, Handle,    MatchPattern, OutputProc, RemoveCommand],  ExtendedString USING [AppendNumber],  Format USING [    Date, Decimal, LongDecimal, LongNumber, HostNumber, NetFormat,    NetworkAddress, StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, Enumerated,    EnumeratedItem, NumberItem, ProcType, StringItem, ToggleFlag,    EnumeratedNotifyProcType, line0, line1],  Heap USING [Create, Delete],  HostNumbers USING [HostNumber, IsMulticastID],  IEEE8023 USING [Encapsulation, minBytesPerEthernetPacket],  Inline USING [LongDivMod],  MStream USING [WriteOnly],  Process USING [    Abort, GetPriority, Pause, Priority, priorityBackground, SecondsToTicks,    SetPriority],  Protocol1 USING [SetMaximumBufferSize],  Put USING [Text],  Router USING [FindMyHostID],  Runtime USING [GetBcdTime],  SpecialCommunication USING [    SetEthernetCollectGarbageToo, SetEthernetListener, SetSpyProc, SpyProc,    SpyType],  SpecialSystem USING [HostNumber],  Stream USING [Handle],  String USING [AppendChar, AppendDecimal, AppendString, EquivalentString],  System USING [    broadcastHostNumber, GetGreenwichMeanTime, GreenwichMeanTime,    HostNumber, NetworkAddress, nullHostNumber, nullSocketNumber],  Time USING [Append, AppendCurrent, Unpack],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle],  WindowFont USING [CharWidth],  WSInfoClient USING [GetPilotInfo, GetXDEInfo];  TrashCollectorImpl: PROGRAM  IMPORTS    AddressTranslation, Buffer, CmFile, Courier, Driver, DataLinkControl,    EthernetDriverFriends, Exec, ExtendedString, SpecialCommunication, Put,    FormSW, Router, Inline, Protocol1, Runtime, String, System, Time, Tool,    Heap, Format, WSInfoClient, HostNumbers, UserInput, Process, WindowFont,    MStream  EXPORTS Buffer, System =  BEGIN    HostNumber: PUBLIC TYPE = SpecialSystem.HostNumber;  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;      wh: Window.Handle;  data: ToolData ¬ [];  loggingSH: Stream.Handle ¬ NIL;  topFive: LONG POINTER TO TopFive ¬ NIL;  ToolData: TYPE = RECORD[    oldSpy: ARRAY Buffer.Type OF SpecialCommunication.SpyProc ¬ ALL[NIL],    form, log: Window.Handle ¬ NIL, logging: Logging ¬ never,    buffers: Buffer.AccessHandle ¬ NIL, little: CARDINAL ¬ minEther,    running: BOOLEAN ¬ FALSE, threshold: LONG STRING ¬ NIL,    started, good, bad, full, empty: LONG CARDINAL ¬ 0,    me: HostNumber ¬ NULL, base: Format.NetFormat ¬ octal,    runt, multi, missed, errors: LONG CARDINAL ¬ 0,    logger: PROCESS ¬ NIL, interpret: Interpretation ¬ topN,    maxEntry, free: EntryHandle ¬ NIL, table: LONG POINTER TO Table ¬ NIL];  Interpretation: TYPE = {percentBad, topN};  Logging: TYPE = {never, minutely, hourly, daily};  Table: TYPE = RECORD[SEQUENCE COMPUTED CARDINAL OF EntryObject];  TopFive: TYPE = RECORD[    count, bubble: NATURAL ¬ 0, lowest: LONG CARDINAL ¬ 0,    seq: SEQUENCE COMPUTED NATURAL OF OneOfFive ¬ TRASH];  OneOfFive: TYPE = RECORD[entry: EntryHandle, this: LONG CARDINAL];   FormItems: TYPE = {    stop, go, report, reset, base, runts, interpret, threshold, logging};  builder: ARRAY [0..20) OF Builder ¬ ALL[];  Builder: TYPE = RECORD[    block: HostNumber ¬ null, name: LONG STRING ¬ NIL];   EntryHandle: TYPE =  LONG POINTER TO EntryObject;  EntryObject: TYPE = RECORD[    host: HostNumber,    link: EntryHandle,    bad, good: LONG CARDINAL,    errorType: ARRAY EthernetFace.Status OF CARDINAL];  faceStatus: ARRAY EthernetFace.Status OF LONG STRING = [    "pending", "ok", "overrun", "underrun", "packetTooLong", "tooManyCollisions",    "crc", "crcAndBadAlignment", "badAlignmentButOkCrc", "otherError"];  unit: CARDINAL = 1;  modulo: NATURAL = 255;  accuracy: NATURAL = 10;  sliceName: LONG STRING ¬ NIL;  dispatcherBuffers: CARDINAL = 40;  zone: UNCOUNTED ZONE = Heap.Create[100];  null: HostNumber = System.nullHostNumber;  all: HostNumber = System.broadcastHostNumber;  minEther: NATURAL = IEEE8023.minBytesPerEthernetPacket;  baseAddress: System.NetworkAddress ¬ Courier.LocalSystemElement[];  BadNumber: ERROR = CODE;  --to get out of string conversion problems  Write: Format.StringProc =    BEGIN    IF loggingSH # NIL THEN      BEGIN      block: Environment.Block = [LOOPHOLE[@s.text], 0, s.length];      loggingSH.put[loggingSH, block, FALSE];      END    ELSE Put.Text[data.log, s];    END;  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      Initialize: PROCEDURE =    BEGIN    ENABLE CmFile.Error => {Write["No User.cm\n"L]; CONTINUE};    block: HostNumber;    herald: STRING ¬ [60];    userDot: CmFile.Handle;    Exec.AddCommand["TrashCollector.~"L, NoOp, Help, Unload];    String.AppendString[to: herald, from: "Trash Collector of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 8;  -- omit hours, mins, zone.    baseAddress.socket ¬ System.nullSocketNumber;  --good value    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: herald];    BEGIN    i: NATURAL;    company, seednumber: LONG STRING;    userDot ¬ CmFile.UserDotCmOpen[];    IF CmFile.FindSection[userDot, "TrashCollector"L] THEN      BEGIN      i ¬ 0; WHILE i IN[0..builder.LENGTH) DO	[company, seednumber] ¬ CmFile.NextItem[userDot];	SELECT TRUE FROM	  (company = NIL) => EXIT;  --end of section	  (~String.EquivalentString[company, "LogFile"L]) =>	    BEGIN	    ENABLE AddressTranslation.Error =>	      {PrintATError[errorRecord, seednumber]; CONTINUE};	    block ¬ AddressTranslation.StringToNetworkAddress[	      seednumber].addr.host;	    block.d ¬ block.e ¬ block.f ¬ 0;  --lop off low 24 bits	    builder[i] ¬ [	      name: zone.NEW[StringBody[company.length]], block: block];	    String.AppendString[builder[i].name, company];	    Write[company]; Write["'s address block is "L];	    Format.HostNumber[Write, block, data.base]; Write["\n"L];	    i ¬ i.SUCC;  --move thru the table in orderly fashion	    END;	  (sliceName # NIL) => NULL;  --already have one	  (seednumber = NIL) => NULL;  --don't have one this time	  (seednumber.length < 30) =>	    BEGIN	    sliceName ¬ zone.NEW[StringBody[seednumber.length]];	    String.AppendString[sliceName, seednumber];	    END;	  ENDCASE;	company ¬ CmFile.FreeString[company];	seednumber ¬ CmFile.FreeString[seednumber];	ENDLOOP;      END ELSE Write["No User.cm slice for TrashCollector\n"L];    [] ¬ CmFile.Close[userDot];    END;    END;  PrintATError: PROC[er: AddressTranslation.ErrorRecord, seed: LONG STRING] =    BEGIN    Write["AddressTranslation error ("L];    AddressTranslation.PrintError[er, Write];    Write[") processing the manufactor's block number '"L];    Write[seed]; Write["'\n"];    END;  --PrintATError      NoOp: Exec.ExecProc =    BEGIN    UNTIL Exec.EndOfCommandLine[h] DO      token, switches: LONG STRING ¬ NIL;      [token, switches] ¬ Exec.GetToken[h];      SELECT TRUE FROM        (token = NIL) => NULL;	(token.length = 0) => NULL;	(Exec.MatchPattern["Report"L, token]) =>	  BEGIN	  SELECT TRUE FROM	    (switches = NIL) => Report[];  --going into standard log file	    (switches.length # 0) =>	      BEGIN	      name: LONG STRING ¬ [50];	      String.AppendString[to: name, from: "Trash."L];	      String.AppendString[to: name, from: switches];	      loggingSH ¬ MStream.WriteOnly[name, [,], text];	      Write[name]; Write["\n"L];  --put the file name in the file	      Report[];  --going into user specified file	      loggingSH.delete[loggingSH]; loggingSH ¬ NIL;	      switches ¬ Exec.FreeTokenString[switches];	      END;	    ENDCASE;	  END;	(Exec.MatchPattern["Go"L, token]) => Go[];	(Exec.MatchPattern["Stop"L, token]) => Stop[];	(Exec.MatchPattern["Reset"L, token]) => Reset[];	ENDCASE =>	  {Write["'"L]; Write[token]; Write["' is not recognized\n"L]};      IF switches # NIL THEN        BEGIN	Write["'"L]; Write[token];	Write["' does not take a switch - found '"L];	Write[switches]; Write["'\n"L];	switches ¬ Exec.FreeTokenString[switches];	END;      token ¬ Exec.FreeTokenString[token];      ENDLOOP;    END;  --NoOp  Help: Exec.ExecProc =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];    Write["TrashCollector.~ <command>/<switches>\n"L];    Write["  Unloading is supported and recommended\n"L];    Write["  Executive commands available\n"L];    Write["    Go - reset and start monitoring process with current options\n"L];    Write["    Stop - stop monitoring and log collections to default file\n"L];    Write["    Report/file - log current collections to file indicated\n"L];    Write["      null switch indicates default logging file\n"L];    Write["    Reset - reset counters\n"L];    END;  --Help    Unload: Exec.ExecProc =    BEGIN    Stop[];  --just in case    Tool.Destroy[wh];    Exec.RemoveCommand[h, "TrashCollector.~"L];    Heap.Delete[zone];    END;  --Unload    MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "TrashCollector.log"L];    data.form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm, zone: zone];    data.log ¬ Tool.MakeFileSW[window: window, name: logName];    END;  MergeTopFive: PROC[    entry: EntryHandle, this, threshold: LONG CARDINAL] =    BEGIN    limit: NATURAL = MIN[CARDINAL[threshold] / accuracy, 20];    IF topFive = NIL THEN topFive ¬ zone.NEW[TopFive[limit] ¬ []];    SELECT TRUE FROM      (topFive.count < limit) =>	BEGIN	topFive[topFive.count] ¬ [entry, this];  --record this entry	IF topFive.lowest < this THEN	  BEGIN	  topFive.lowest ¬ this;  --replace the lowest of the worst	  topFive.bubble ¬ topFive.count;  --remember who it was	  END;	topFive.count ¬ topFive.count.SUCC;  --up the count	END;      (topFive.lowest < this) =>        BEGIN	topFive.lowest ¬ this;  --replace the lowest of the worst	topFive[topFive.bubble] ¬ [entry, this];  --record this entry	FOR index: NATURAL IN[0..limit) DO	  IF topFive[index].this < topFive.lowest THEN	    BEGIN	    topFive.lowest ¬ topFive[index].this;  --new lowest	    topFive.bubble ¬ index;  --save the index	    END;	  ENDLOOP;	END;      ENDCASE;    END;  Reset: FormSW.ProcType =    BEGIN    s: STRING ¬ [40];    etherStats: EthernetDriverFriends.EtherStatsInfo;    data.good ¬ data.bad ¬ data.full ¬ data.empty ¬ data.runt ¬ data.multi ¬ 0;    FOR i: NATURAL IN[0..(modulo + 1) * 2) DO      data.table[i] ¬ [null, NIL, 0, 0, ALL[0]];      ENDLOOP;    data.free ¬ @data.table[modulo + 1];    data.maxEntry ¬ @data.table[((modulo + 1) * 2) - 1];    data.started ¬ System.GetGreenwichMeanTime[];    etherStats ¬ EthernetDriverFriends.GetEthernetStats[unit];    data.errors ¬ etherStats.badRecvStatus;    data.missed ¬ etherStats.packetsMissed;    Write["Counters reset at "L];    Time.AppendCurrent[s]; Write[s]; Write["\n"L];    END;  --Reset  Report: FormSW.ProcType =    BEGIN    h, m, s: CARDINAL;    string: STRING ¬ [30];    prio: Process.Priority = Process.GetPriority[];    d: LONG CARDINAL ¬ System.GetGreenwichMeanTime[];    etherStats: EthernetDriverFriends.EtherStatsInfo =      EthernetDriverFriends.GetEthernetStats[unit];    threshold: LONG CARDINAL = ConvertIn[ !  --get threshold      BadNumber => GOTO badNumber];  --and it was bad    Process.SetPriority[Process.priorityBackground];    Write["Time range: "L];    Time.Append[string, Time.Unpack[[data.started]]]; Write[string];    Write[" to "L];    string.length ¬ 0;    Time.Append[string, Time.Unpack[[d]]]; Write[string];    d ¬ d - data.started;    Write["\nElpased time: "L];    [h, s] ¬ Inline.LongDivMod[d, 60*60];  --hours    IF h < 10 THEN Write["0"L];    Format.Decimal[Write, h]; Write[":"L];    [m, s] ¬ Inline.LongDivMod[s, 60];  --minutes    IF m < 10 THEN Write["0"L];    Format.Decimal[Write, m]; Write[":"L];    IF s < 10 THEN Write["0"L];    Format.Decimal[Write, s];    Write["\nTotal good packets observed: "L];    Format.LongDecimal[Write, data.good];    Write[" ("L];    Format.Decimal[Write, CARDINAL[data.good/d]];    Write[" per second)\n"L];    IF (etherStats.packetsMissed - data.missed) > 0 THEN      BEGIN      Format.LongDecimal[Write, etherStats.packetsMissed - data.missed];      Write[" packets have beeen missed by the driver\n"L];      END;    IF (etherStats.badRecvStatus - data.errors) > 0 THEN      BEGIN      Format.LongDecimal[Write, etherStats.badRecvStatus - data.errors];      Write[" packets received with bad status by driver\n"L];      END;    IF data.runt # 0 THEN      BEGIN      Write["Number of runt packets (< "L];      Format.Decimal[Write, data.little];      Write["): "L];      Format.LongDecimal[Write, data.runt];      Write["\nApproximate ratio of runt::good packets: 1::"L];      Format.Decimal[Write, CARDINAL[data.good / data.runt]];      Write["\n"L];      END;    IF data.multi # 0 THEN      BEGIN      Write["Number of multicast source addresses observed: "L];      Format.LongDecimal[Write, data.multi];      Write["\n"L];      END;    IF data.bad # 0 THEN      BEGIN      hosts, random: NATURAL ¬ 0;      Write["Number of bad packets: "L];      Format.LongDecimal[Write, data.bad];      Write["\nApproximate ratio of bad::good packets: 1::"L];      Format.Decimal[Write, CARDINAL[data.good / data.bad]];      SELECT data.interpret FROM        percentBad =>	  BEGIN	  Write["\nHosts observed transmitting "L];	  Format.LongNumber[Write, threshold / 10, []];  --the decimal part	  Write["."L];  --the decimal point	  Format.LongNumber[Write, threshold MOD 10, [10, TRUE, TRUE, 1]];	  Write["% bad packets or more\n\n"L];	  END;	topN =>	  BEGIN	  Write["\nThe top "L];	  Format.LongNumber[Write, threshold / 10, []];	  Write[" host transmitting bad packets\n\n"L];	  END;	ENDCASE;      FOR hash: NATURAL IN[0..modulo] DO	entry: EntryHandle ¬ @data.table[hash];	IF UserInput.UserAbort[wh] THEN {Write["ABORTED\n"L]; EXIT};	UNTIL entry.host = null DO	  hosts ¬ hosts.SUCC;	  SELECT TRUE FROM	    (entry.bad = 0) => NULL;  --not very interesting	    (MatchBuilder[entry.host, threshold] # LAST[NATURAL]) =>	      BEGIN	      this: LONG CARDINAL = (1D3 * entry.bad) / (entry.bad + entry.good);	      SELECT TRUE FROM		(threshold = 0) => ConvertOut[entry, this];  --wants everything		(data.interpret = topN) => MergeTopFive[entry, this, threshold];		(this > threshold) => ConvertOut[entry, this];		ENDCASE;	      END;	  ENDCASE => random ¬ random.SUCC;  --else it's just a random occurrance	  IF (entry ¬ entry.link) = NIL THEN EXIT;	  ENDLOOP;	ENDLOOP;      IF data.interpret = topN THEN ReportTopFive[];  --do it again      Format.Decimal[Write, random]; Write[" single instance reports\n"L];      Format.Decimal[Write, hosts]; Write[" hosts in table\n\n"L];      END;    Process.SetPriority[prio];    EXITS badNumber => Write["\nThreshold specification invalid\n"L];    END;  --Report  ReportTopFive: PROC[] =    BEGIN    IF topFive = NIL THEN RETURN;    FOR index: NATURAL IN[0..topFive.count) DO      entry: EntryHandle ¬ topFive[index].entry;      this: LONG CARDINAL ¬ (1D3 * entry.bad) / (entry.bad + entry.good);      ConvertOut[entry, this];      ENDLOOP;    zone.FREE[@topFive];  --get rid of old list    END;  --ReportTopFive  ConvertIn: PROC[] RETURNS[threshold: LONG CARDINAL ¬ 0] =    BEGIN    fraction: NATURAL ¬ accuracy / 10;    point: BOOLEAN ¬ FALSE;    IF data.threshold = NIL THEN RETURN;    FOR i: NATURAL IN[0..data.threshold.length) DO      c: CHARACTER = data.threshold[i];      IF (point = FALSE) AND (c = '.) THEN {point ¬ TRUE; LOOP};      IF c ~IN['0..'9] THEN RETURN WITH ERROR BadNumber;  --bad character      threshold ¬ threshold * 10 + (c - '0);  --accumulate data      IF point AND (fraction ¬ fraction.PRED) = 0 THEN EXIT;      REPEAT FINISHED =>        THROUGH[0..fraction) DO threshold ¬ 10 * threshold; ENDLOOP;      ENDLOOP;    IF threshold > 1D3 THEN RETURN WITH ERROR BadNumber;  --too big    END;  --ConvertIn  ConvertOut: PROC[entry: EntryHandle, threshold: LONG CARDINAL] =    BEGIN    baseAddress.host ¬ entry.host;    WriteInfo[baseAddress, threshold];    Write["Machine's ratio of bad::good packets: "L];    Format.LongDecimal[Write, entry.bad];    Write["::"L];    Format.LongDecimal[Write, entry.good];    Write[" ("L];    Format.LongNumber[Write, threshold / 10, []];  --the decimal part    Write["."L];  --the decimal point    Format.LongNumber[Write, threshold MOD 10, [10, TRUE, TRUE, accuracy / 10]];    Write["%)\n  "L];    FOR i: EthernetFace.Status IN EthernetFace.Status DO      IF entry.errorType[i] = 0 THEN LOOP;      Write[faceStatus[i]]; Write[": "L];      Format.Decimal[Write, entry.errorType[i]];      Write[" "];      REPEAT FINISHED => Write["\n"L];      ENDLOOP;    Write["\n"L];    END;  --ConvertOut  MatchBuilder: PROC[him: HostNumber, threshold: LONG CARDINAL]    RETURNS[i: NATURAL] =    BEGIN    him.d ¬ him.e ¬ him.f ¬ 0;  --strip low 24 bits    FOR i IN[0..builder.LENGTH) DO      SELECT TRUE FROM        (builder[i].block # null) => NULL;  --check this one out	(threshold # 0) => RETURN[LAST[NATURAL]];  --no match	ENDCASE => builder[i].block ¬ him;  --copy him in      IF builder[i].block = him THEN	BEGIN	IF builder[i].name = NIL THEN	  BEGIN	  builder[i].name ¬ zone.NEW[StringBody[16]];	  ExtendedString.AppendNumber[	    field: @him, size: SIZE[HostNumber], string: builder[i].name,	    base: SELECT data.base FROM octal => 8, hex => 16, ENDCASE => 10];	  END;	EXIT;  --now get out of here	END;      ENDLOOP;    END;  --MatchBuilder    WriteInfo: PROCEDURE [who: System.NetworkAddress, threshold: LONG CARDINAL] =    BEGIN    bfVersion: LONG STRING ¬ [6];    sysVolName: LONG STRING ¬ [40];    pVName: LONG STRING ¬ [40];    userName: LONG STRING ¬ [40];    answered, loggedIn: BOOLEAN;    i: NATURAL = MatchBuilder[who.host, threshold];    time, timeBooted, bfCreateDate: System.GreenwichMeanTime;    Format.NetworkAddress[Write, who, data.base];    IF i # LAST[NATURAL] THEN      {Write["  ("L]; Write[builder[i].name]; Write[")"L]};        [answered, time, timeBooted, bfCreateDate]  ¬ WSInfoClient.GetPilotInfo[      who, sysVolName, pVName];    IF answered THEN {      Write["\n"L];      Write["  Physical volume: "L]; Write[pVName]; Write["\n"L];      Write["  System volume: "L]; Write[sysVolName]; Write["\n"L];      Write["  Processor clock: "L]; Format.Date[Write, time, full]; Write["\n"L];      Write["  Booted on "L]; Format.Date[Write, timeBooted, full]; Write["\n"L];      Write["  Boot file created on "L];        Format.Date[Write, bfCreateDate, full]; Write["\n"L]}    ELSE {Write[" - did not reply\n"L]; RETURN};        [answered, loggedIn] ¬ WSInfoClient.GetXDEInfo[who, bfVersion, userName];    IF answered THEN {      Write["  Boot file version: "L]; Write[bfVersion]; Write["\n"L];      Write["  User: "L];        Write[userName]; IF loggedIn THEN Write[" (logged in)"L]}    ELSE Write["No XDE information available"L];    Write["\n"L];    END;  --WriteInfo  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL = FormItems.LAST.ORD + 1;    base: ARRAY CARDINAL[Format.NetFormat.FIRST.ORD..Format.NetFormat.LAST.ORD]      OF FormSW.Enumerated ¬ [["octal"L, 0], ["hex"L, 1], ["decimal"L, 2]];    logging: ARRAY[0..4) OF FormSW.Enumerated ¬ [      ["never"L, 0], ["minutely"L, 1], ["hourly"L, 2], ["daily"L, 3]];    interpret: ARRAY[0..2) OF FormSW.Enumerated ¬ [      ["% bad"L, Interpretation[percentBad].ORD],      ["top <n>"L, Interpretation[topN].ORD]];    items ¬ FormSW.AllocateItemDescriptor[nItems, zone];    items[FormItems.stop.ORD] ¬ FormSW.CommandItem[      tag: "Stop"L, place: [CharPos[0], FormSW.line0], proc: Stop, z: zone];    items[FormItems.go.ORD] ¬ FormSW.CommandItem[      tag: "Go"L, place: [CharPos[7], FormSW.line0], proc: Go, z: zone];    items[FormItems.report.ORD] ¬ FormSW.CommandItem[      tag: "Report"L, place: [CharPos[12], FormSW.line0], proc: Report, z: zone];    items[FormItems.reset.ORD] ¬ FormSW.CommandItem[      tag: "Reset"L, place: [CharPos[22], FormSW.line0], proc: Reset, z: zone];    items[FormItems.base.ORD] ¬ FormSW.EnumeratedItem[      tag: "base"L, place: [CharPos[31], FormSW.line0],      choices: DESCRIPTOR[base], value: @data.base, z: zone];    items[FormItems.runts.ORD] ¬ FormSW.NumberItem[      tag: "runt length"L, place: [CharPos[50], FormSW.line0],      signed: FALSE, default: 60, value: @data.little, z: zone];    items[FormItems.interpret.ORD] ¬ FormSW.EnumeratedItem[      tag: "Interpret threshold as"L, place: [CharPos[0], FormSW.line1],      choices: DESCRIPTOR[interpret], value: @data.interpret, z: zone];    items[FormItems.threshold.ORD] ¬ FormSW.StringItem[      tag: ">"L, place: [CharPos[35], FormSW.line1], boxWidth: 32,      inHeap: TRUE, string: @data.threshold, z: zone];    items[FormItems.logging.ORD] ¬ FormSW.EnumeratedItem[      tag: "Log and reset"L, place: [CharPos[50], FormSW.line1],      proc: Log, choices: DESCRIPTOR[logging], value: @data.logging, z: zone];    RETURN[items: items, freeDesc: TRUE];    END;  Log: FormSW.EnumeratedNotifyProcType =    BEGIN    IF ~data.running THEN RETURN;  --boring    IF data.logger # NIL THEN      {Process.Abort[data.logger]; JOIN data.logger};    data.logger ¬ SELECT data.logging FROM      (never) => NIL,  --didn't want any logging      (minutely) => (FORK Logger[60]),      (hourly) => (FORK Logger[60 * 60]),      ENDCASE => (FORK Logger[24 * LONG[60 * 60]]);    END;  --Log  Logger: PROC[interval: LONG CARDINAL] =    BEGIN    ENABLE ABORTED => CONTINUE;  --or return if you prefer    sequence: NATURAL ¬ 0;    timein: System.GreenwichMeanTime ¬ System.GetGreenwichMeanTime[];    Process.SetPriority[Process.priorityBackground];  --lazy    --UNTIL ABORTED-- DO      Process.Pause[Process.SecondsToTicks[10]];  --abortable      IF (System.GetGreenwichMeanTime[] - timein) > interval THEN        BEGIN	name: LONG STRING ¬ [50];	IF sequence = 99 THEN sequence ¬ 0;  --don't go too high	String.AppendString[to: name, from: "Trash."L];	String.AppendString[to: name, from: sliceName];	String.AppendChar[name, '.];  --get separator	String.AppendDecimal[name, (sequence ¬ sequence.SUCC)];	loggingSH ¬ MStream.WriteOnly[name, [,], text];	timein ¬ System.GetGreenwichMeanTime[];  --reset time	Write[name]; Write["\n"L];  --put the file name in the file	Report[];  --so report the current status	loggingSH.delete[loggingSH]; loggingSH ¬ NIL;	Reset[];  --then reset the counters	END;      ENDLOOP;    END;  --Logger  Stop: FormSW.ProcType =    BEGIN    OPEN data;    oldLogging: Logging = data.logging;  --save the current value    data.logging ¬ never; Log[];  --stops the tool logging process    data.logging ¬ oldLogging;  --reinstate the logging option    IF running THEN      BEGIN      s: STRING ¬ [40];      running ¬ FALSE;      [] ¬ SpecialCommunication.SetEthernetListener[unit, me];      [] ¬ SpecialCommunication.SetEthernetCollectGarbageToo[unit, FALSE];      FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	[] ¬ SpecialCommunication.SetSpyProc[NIL, type];	ENDLOOP;      Buffer.DestroyPool[buffers];      [] ¬ DataLinkControl.AdjustInputQueueLength[ethernet, 0, 5];      FOR device: Device ¬ Driver.GetDeviceChain[], device.next        UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 0];	ENDLOOP;      String.AppendString[s, "Collected stopped at "L];      Time.Append[s, Time.Unpack[]];      Write[s]; Write["\n"L]; Report[];      FormSW.ToggleFlag[sw, FormItems.runts.ORD, readOnly];  --make it readWrite      END;    END;        Go: FormSW.ProcType =    BEGIN    OPEN data;    IF ~running THEN      BEGIN      s: STRING ¬ [40];      running ¬ TRUE;      me ¬ Router.FindMyHostID[];      FormSW.ToggleFlag[sw, FormItems.runts.ORD, readOnly];  --make it readOnly      Write["\n\n"L];      Reset[];  --set all the counters      Log[];  --set up the logging request      String.AppendString[s, "Collected started at "L];      Time.AppendCurrent[s]; Write[s]; Write["\n"L];      FOR device: Device ¬ Driver.GetDeviceChain[], device.next        UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 1500];	ENDLOOP;      buffers ¬ Buffer.MakePool[dispatcherBuffers, 0];  --get large pool      [] ¬ DataLinkControl.AdjustInputQueueLength[        ethernet, 0, dispatcherBuffers / 2];      FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	data.oldSpy[type] ¬ SpecialCommunication.SetSpyProc[SpyProc, type];	ENDLOOP;      [] ¬ SpecialCommunication.SetEthernetListener[unit, all];      [] ¬ SpecialCommunication.SetEthernetCollectGarbageToo[unit, TRUE];      END;    END;      ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      (new = inactive) => {Stop[]; zone.FREE[@data.table]};      (old = inactive) =>        {data.table ¬ zone.NEW[Table[(modulo + 1) * 2]]};      ENDCASE;    END;	  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Worker routines:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SpyProc: SpecialCommunication.SpyProc =     --PROC[b: Buffer.Buffer] RETURNS[Buffer.Buffer]    BEGIN    host: SpecialSystem.HostNumber ¬ LOOPHOLE[      b.linkLayer.blockPointer, IEEE8023.Encapsulation].ethernetSource;    IF function = receive THEN      BEGIN      WITH s: b.fo.driver SELECT FROM	ethernet =>	  BEGIN	  entry: EntryHandle ¬ @data.table[host.f];	  IF s.length < data.little THEN	    {data.runt ¬ data.runt.SUCC; Buffer.ReturnBuffer[b]; RETURN[NIL]};	  UNTIL entry.host = host DO	    SELECT TRUE FROM	      (HostNumbers.IsMulticastID[@host]) =>	        {data.multi ¬ data.multi.SUCC; EXIT};	      (entry.host = null) =>		BEGIN		entry.host ¬ host;		entry.bad ¬ entry.good ¬ 0;		entry.errorType ¬ ALL[0];		END;	      (entry.link # NIL) => entry ¬ entry.link;	      (data.free = data.maxEntry) =>		{data.full ¬ data.full.SUCC; EXIT};	      ENDCASE =>		BEGIN		entry.link ¬ data.free; entry ¬ data.free;		entry.host ¬ host; entry.bad ¬ entry.good ¬ 0;		entry.errorType ¬ ALL[0];		data.free ¬ data.free + SIZE[EntryObject];		EXIT;		END;	    ENDLOOP;	  IF (s.ethernet # ok) AND (s.ethernet # badAlignmentButOkCrc) THEN	    BEGIN	    data.bad ¬ data.bad.SUCC;	    entry.bad ¬ entry.bad.SUCC;	    entry.errorType[s.ethernet] ¬ entry.errorType[s.ethernet].SUCC;	    Buffer.ReturnBuffer[b];	    RETURN[NIL];	    END	  ELSE entry.good ¬ entry.good.SUCC;	  END;	ENDCASE => {Buffer.ReturnBuffer[b]; RETURN[NIL]};      data.good ¬ data.good.SUCC;      IF data.oldSpy[b.fo.type] # NIL THEN	{b ¬ data.oldSpy[b.fo.type][b, function]; IF b = NIL THEN RETURN[NIL]};      host ¬ LOOPHOLE[	b.linkLayer.blockPointer, IEEE8023.Encapsulation].ethernetDest;      SELECT TRUE FROM	(host = LOOPHOLE[data.me]) => RETURN[b];	(host = LOOPHOLE[all]) => RETURN[b];	ENDCASE => {Buffer.ReturnBuffer[b]; RETURN[NIL]};      END    ELSE      BEGIN      --this is not a receive buffer      IF data.oldSpy[b.fo.type] # NIL THEN        b ¬ data.oldSpy[b.fo.type][b, function];      RETURN[b];  --whatever      END;    END;  -- Mainline code:    Initialize[];    END. 
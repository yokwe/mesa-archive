-- File: CourierStatsImpl.mesa - last edit:-- AOF                 11-Jan-88 13:59:07-- Create by FormSWLayoutTool on 15-Oct-85 11:22-- Copyright (C) 1988 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [CR],  CourierInternal USING [stats, StatType],  Exec USING [AddCommand, ExecProc, Handle, RemoveCommand],  Format USING [LongDecimal, StringProc],  Flipper USING [ClearCounts, Create, Enumerated],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, line0, ProcType],  Heap USING [systemZone],  Put USING [Text],  Time USING [AppendCurrent],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Box, Handle],  WindowFont USING [CharWidth];CourierStatsImpl: PROGRAM  IMPORTS    CourierInternal, Exec, Flipper, Format, FormSW, Heap, Put,    Time, Tool, WindowFont = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    flipperSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL];  FormItems: TYPE = {clearCounters, logCounters};  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  charWidth: CARDINAL = WindowFont.CharWidth['0];  box: Window.Box = [place:[x:0, y:326], dims:[w:512, h:416]];  tags: ARRAY CourierInternal.StatType OF LONG STRING = [    "stackMapped", "stackUnmapped", "stackGot",    "stackPut", "byteRcv", "byteXmt", "byteFlush",    "callRcv", "localRcv", "rejectXmt",    "returnXmt", "abortXmt", "callXmt",    "localCalls", "rejectRcv", "returnRcv",    "abortRcv", "callRetry", "zoneAlloc", "zoneFree",    "streamAcq", "streamCreate", "streamDelete"];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {x ¬ charWidth * char};  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  ClearCounters:  FormSW.ProcType = {Flipper.ClearCounts[data.flipperSW]};  LogCounters:  FormSW.ProcType =    BEGIN    time: LONG STRING ¬ [40];    time[0] ¬ Ascii.CR; time.length ¬ SUCC[time.length];  --append byte!    Time.AppendCurrent[time];    time[time.length] ¬ Ascii.CR; time.length ¬ SUCC[time.length]; --append byte!    Write[time];  --get that out there    FOR i: CourierInternal.StatType IN CourierInternal.StatType DO      Write[tags[i]];      Write[": "L];      Format.LongDecimal[Write, CourierInternal.stats[i]];      IF i < CourierInternal.StatType.LAST THEN Write[", "L];      ENDLOOP;    Write["\n"L];    END;  --LogCounters  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];      new = inactive =>        IF data # NIL THEN {	  zone.FREE[@data]};      ENDCASE;    };  Init: PROCEDURE = {    Exec.AddCommand["CourierStats.~"L, NoOp, NIL, Unload];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: box,      clientTransition: ClientTransition, name: "CourierStats"L,      cmSection: "CourierStats"L];    };      NoOp: Exec.ExecProc = { };    Unload: Exec.ExecProc = {    Tool.Destroy[wh]; Exec.RemoveCommand[h, "CourierStats.~"L]};  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [40];    index: NATURAL = ORD[CourierInternal.StatType.LAST];    flops: ARRAY CARDINAL[0..index] OF Flipper.Enumerated;    Tool.UnusedLogName[unused: logName, root: "CourierStats.log"L];    FOR i: CourierInternal.StatType IN CourierInternal.StatType DO      flops[i.ORD] ¬ [tags[i], @CourierInternal.stats[i]]; ENDLOOP;    data.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    data.flipperSW ¬ Flipper.Create[parent: window, flippers: DESCRIPTOR[flops]];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.clearCounters.ORD] ¬ CommandItem[      tag: "Clear counters"L, place: [CharPos[0], line0], proc: ClearCounters];    items[FormItems.logCounters.ORD] ¬ CommandItem[      tag: "Log counters"L, place: [CharPos[20], line0], proc: LogCounters];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...  
-- File: WSInfoClientImpl.mesa - last edit:-- AOF                 19-Aug-86 16:21:37-- KAM                 15-Apr-85 14:06:03-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii, NSBuffer, CourierInternal, Heap, Inline, Listener, PacketExchange,  Router, Socket, String, System, WSInfo, WSInfoClient;WSInfoClientImpl: PROGRAM  IMPORTS CourierInternal, Heap, Inline, Router, Socket, String, WSInfo   EXPORTS WSInfoClient =  BEGIN    z: UNCOUNTED ZONE ¬ Heap.Create[5];    buffers: CARDINAL = 30;  maxWS: CARDINAL = 1024;    localTimeOut: Socket.WaitTime ¬ 300;  -- msec    Reply: TYPE = WSInfoClient.Reply;  ReplySeq: TYPE = WSInfoClient.ReplySeq;    Range: TYPE = RECORD [from, to: System.HostNumber];  ThreeWords: TYPE = PACKED ARRAY [0.. 3) OF CARDINAL;    FindWSOnNet: PUBLIC PROCEDURE [net: System.NetworkNumber, maxProbes: CARDINAL]    RETURNS [all: Reply, probes: CARDINAL ¬ 0] =     BEGIN        socket: Socket.ChannelHandle ¬ Socket.Create[      System.nullSocketNumber, 1, buffers];    addr: System.NetworkAddress = [      net, System.broadcastHostNumber, WSInfo.socket];          reply: Reply ¬ NewReply[buffers];        vals: ARRAY [0.. WSInfo.maxHostCount) OF System.HostNumber;    tries: CARDINAL ¬ 0;    maxTries: CARDINAL ¬ 4;  -- if get no responses after maxTries, we're done    firstHN: System.HostNumber = LOOPHOLE[ThreeWords[0, 0, 0]];    lastHN: System.HostNumber = LOOPHOLE[ThreeWords[177777B, 177777B, 177777B]];        Send: PROCEDURE RETURNS [noReplies: BOOLEAN ¬ TRUE] = {      intervals: INTEGER =        IF all.count = 0 THEN 1        ELSE (all.count - 1 + WSInfo.maxHostCount)/WSInfo.maxHostCount;      FOR i: INTEGER IN [0.. intervals) DO        start: INTEGER = i * WSInfo.maxHostCount;	stop: INTEGER = MIN[all.count, start + WSInfo.maxHostCount] - 1;        FOR j: INTEGER IN [0.. stop - start] DO vals[j] ¬ all[j + start] ENDLOOP;	noReplies ¬ 	  SendOne[	    IF start = 0 THEN firstHN ELSE Increment[all[start - 1]],	    IF CARDINAL[stop] = all.count - 1 THEN lastHN ELSE all[stop],	    DESCRIPTOR[@vals, stop - start + 1]]	  AND noReplies;	ENDLOOP};          SendOne: PROCEDURE [      start, stop: System.HostNumber,      val: DESCRIPTOR FOR ARRAY OF System.HostNumber]      RETURNS [noReplies: BOOLEAN ¬ TRUE] = {      req: LONG POINTER TO call WSInfo.Message;      msg: LONG POINTER TO locateRequest WSInfo.Request;      b: NSBuffer.Buffer ¬ Socket.GetSendBuffer[socket];      reply.count ¬ 0;      req ¬ LOOPHOLE[@b.ns.exchangeBody];      msg ¬ LOOPHOLE[@req.request];      b.ns.packetType ¬ packetExchange;      b.ns.exchangeType ¬ PacketExchange.ExchangeClientType[unspecified];      b.ns.exchangeID ¬ [0, probes];      b.ns.destination ¬ addr;      Socket.SetPacketWords[b, WSInfo.sizeLocateRequest[val.LENGTH]];      req­ ¬ [[protocol3, protocol3], call [        transaction: 0, program: CourierInternal.ExchWords[WSInfo.program], 	version: WSInfo.version,	procedure: WSInfo.procedure, request: ]];      msg­ ¬ [locateRequest [        first: start, last: stop, count: val.LENGTH, hosts: ]];      FOR i: CARDINAL IN [0.. val.LENGTH) DO msg.hosts[i] ¬ val[i] ENDLOOP;      Socket.PutPacket[socket, b];      DO        b ¬ Socket.GetPacket[socket ! Socket.TimeOut => GOTO NoMore];	WITH m: LOOPHOLE[@b.ns.exchangeBody, LONG POINTER TO WSInfo.Message]	  SELECT FROM	  return => WITH r: LOOPHOLE[	    @m.response, LONG POINTER TO WSInfo.Response] SELECT FROM	    locateReply =>	      IF b.ns.exchangeID.a = 0 AND b.ns.exchangeID.b = probes 	        AND reply.count < reply.max - 1 THEN {		reply[reply.count] ¬ b.ns.source.host;		reply.count ¬ SUCC[reply.count]};	    ENDCASE;	  reject => IF reply.count < reply.max - 1 THEN {	    reply[reply.count] ¬ b.ns.source.host;	    reply.count ¬ SUCC[reply.count]};	  ENDCASE;	Socket.ReturnBuffer[b];	REPEAT NoMore => NULL;	ENDLOOP;      IF reply.count = 0 THEN RETURN[TRUE];      SortReply[reply];      CompressReply[reply];      RETURN[NOT Add[all, reply]]};        all ¬ NewReply[maxWS];    Socket.SetWaitTime[socket, WaitForNet[net]];        UNTIL tries = maxTries OR probes = maxProbes DO      probes ¬ SUCC[probes];      tries ¬ IF Send[].noReplies THEN SUCC[tries] ELSE 0;      ENDLOOP;        Socket.Delete[socket];    FreeReply[@reply];    END;    GetInfo: PROCEDURE [    who: System.NetworkAddress,    Setup: PROCEDURE [req: LONG POINTER TO WSInfo.Request]      RETURNS [size: CARDINAL],    Info: PROCEDURE [      b: NSBuffer.Buffer, resp: LONG POINTER TO WSInfo.Response]] = {    socket: Socket.ChannelHandle ¬ Socket.Create[System.nullSocketNumber, 1, 1];    b: NSBuffer.Buffer ¬ NIL;    req: LONG POINTER TO call WSInfo.Message;    answered: BOOLEAN ¬ FALSE;    Socket.SetWaitTime[socket, WaitForNet[who.net]];    who.socket ¬ WSInfo.socket;    THROUGH [0.. 3) UNTIL answered DO      b ¬ Socket.GetSendBuffer[socket];      req ¬ LOOPHOLE[@b.ns.exchangeBody];      b.ns.packetType ¬ packetExchange;      b.ns.exchangeType ¬ PacketExchange.ExchangeClientType[unspecified];      b.ns.exchangeID ¬ [123, 321];      b.ns.destination ¬ who;      req­ ¬ [[protocol3, protocol3], call [        transaction: 0, program: CourierInternal.ExchWords[WSInfo.program], 	version: WSInfo.version,	procedure: WSInfo.procedure, request: ]];      Socket.SetPacketWords[b, Setup[@req.request]];      Socket.PutPacket[socket, b];      b ¬ Socket.GetPacket[socket ! Socket.TimeOut => LOOP];      IF b.ns.exchangeID.a = 123 AND b.ns.exchangeID.b = 321 THEN        WITH r: LOOPHOLE[@b.ns.exchangeBody, LONG POINTER TO WSInfo.Message]	  SELECT FROM	  return => {	    Info[b, LOOPHOLE[@r.response, LONG POINTER TO WSInfo.Response]];	    answered ¬ TRUE};	  ENDCASE;      Socket.ReturnBuffer[b];      ENDLOOP;    Socket.Delete[socket]};    GetPilotInfo: PUBLIC PROCEDURE [    who: System.NetworkAddress, sysVolName, pVName: LONG STRING]    RETURNS [      answered: BOOLEAN ¬ FALSE,      time, timeBooted, bfCreateDate: System.GreenwichMeanTime] = {        Setup: PROCEDURE [req: LONG POINTER TO WSInfo.Request]      RETURNS [size: CARDINAL] = {      req­ ¬ [pilotInfoRequest[]];      RETURN[WSInfo.sizePilotInfoRequest]};        Info: PROCEDURE [      b: NSBuffer.Buffer, resp: LONG POINTER TO WSInfo.Response] = {      WITH r: resp SELECT FROM        pilotInfoReply => {	  answered ¬ TRUE; 	  time ¬ [CourierInternal.ExchWords[r.time]];	  timeBooted ¬ [CourierInternal.ExchWords[r.timeBooted]]; 	  bfCreateDate ¬ [CourierInternal.ExchWords[r.bfCreateDate]];	  IF sysVolName # NIL THEN FOR i: CARDINAL IN [0.. 40) DO	    IF r.sysVolName.string[i] = Ascii.NUL THEN EXIT	    ELSE String.AppendChar[	      sysVolName, r.sysVolName.string[i] ! String.StringBoundsFault => EXIT]	    ENDLOOP;	  IF pVName # NIL THEN FOR i: CARDINAL IN [0.. 40) DO	    IF r.pVName.string[i] = Ascii.NUL THEN EXIT	    ELSE String.AppendChar[	      pVName, r.pVName.string[i] ! String.StringBoundsFault => EXIT]	    ENDLOOP};	ENDCASE};        GetInfo[who, Setup, Info !      Router.NetworkNonExistent, Router.NoTableEntryForNet => CONTINUE]};      GetXDEInfo: PUBLIC PROCEDURE [    who: System.NetworkAddress, bfVersion, userName: LONG STRING]    RETURNS [answered, loggedIn: BOOLEAN ¬ FALSE] = {        Setup: PROCEDURE [req: LONG POINTER TO WSInfo.Request]      RETURNS [size: CARDINAL] = {      req­ ¬ [xdeInfoRequest[]];      RETURN[WSInfo.sizeXdeInfoRequest]};        Info: PROCEDURE [      b: NSBuffer.Buffer, resp: LONG POINTER TO WSInfo.Response] = {      WITH r: resp SELECT FROM        xdeInfoReply => {	  answered ¬ TRUE; loggedIn ¬ r.loggedIn;	  IF bfVersion # NIL THEN FOR i: CARDINAL IN [0.. 6) DO	    IF r.bfVersion.string[i] = Ascii.NUL THEN EXIT	    ELSE String.AppendChar[	      bfVersion, r.bfVersion.string[i] ! String.StringBoundsFault => EXIT]	    ENDLOOP;	  IF userName # NIL THEN FOR i: CARDINAL IN [0.. 40) DO	    IF r.userName.string[i] = Ascii.NUL THEN EXIT	    ELSE String.AppendChar[	      userName, r.userName.string[i] ! String.StringBoundsFault => EXIT]	    ENDLOOP};	ENDCASE};        GetInfo[who, Setup, Info !      Router.NetworkNonExistent, Router.NoTableEntryForNet => CONTINUE]};  DataRec: TYPE = MACHINE DEPENDENT RECORD[    type(0): Listener.PacketType,     size(1): CARDINAL,    data(2): ARRAY [0..0) OF UNSPECIFIED];    GetClientInfo: PUBLIC PROCEDURE [    who: System.NetworkAddress,     packetType: Listener.PacketType,    proc: WSInfoClient.ProcType, clientData: LONG POINTER ¬ NIL]     RETURNS [answered: BOOLEAN]= {        Setup: PROCEDURE [req: LONG POINTER]      RETURNS [size: CARDINAL] = {      req­ ¬ packetType;      RETURN[WSInfo.sizeXdeInfoRequest]};        Info: PROCEDURE [      b: NSBuffer.Buffer, resp: LONG POINTER] = {        p: LONG POINTER TO DataRec ¬ resp;        IF p.type = packetType THEN {	  answered ¬ TRUE;	  proc[@p.data, p.size, clientData];	  };	};        answered ¬ FALSE;    GetInfo[who, Setup, Info !      Router.NetworkNonExistent, Router.NoTableEntryForNet => CONTINUE]};  Add: PROCEDURE [to, from: Reply] RETURNS [added: BOOLEAN] = {    i, j, k: CARDINAL ¬ 0;    count: CARDINAL ¬ 0;    IF from.count = 0 THEN RETURN[FALSE];    FOR i DECREASING IN [0.. to.count) DO to[i + from.count] ¬ to[i] ENDLOOP;    k ¬ from.count;    i ¬ j ¬ 0;    WHILE i < from.count AND k < to.count + from.count DO      SELECT Compare[from[i], to[k]] FROM	smaller => {to[j] ¬ from[i]; j ¬ SUCC[j]; i ¬ SUCC[i]};	bigger => {to[j] ¬ to[k]; j ¬ SUCC[j]; k ¬ SUCC[k]};	same => {to[j] ¬ to[k]; i ¬ SUCC[i]; j ¬ SUCC[j]; k ¬ SUCC[k]};	ENDCASE;      count ¬ SUCC[count];      ENDLOOP;    WHILE i < from.count DO      to[j] ¬ from[i]; j ¬ SUCC[j]; i ¬ SUCC[i]; count ¬ SUCC[count]; ENDLOOP;    WHILE k < to.count + from.count DO      to[j] ¬ to[k]; j ¬ SUCC[j]; k ¬ SUCC[k]; count ¬ SUCC[count]; ENDLOOP;    added ¬ (to.count # count);    to.count ¬ count};    Compare: PROCEDURE [a, b: System.HostNumber] RETURNS [Comparison ¬ same] = {    IF a # b THEN {      tA: ThreeWords = LOOPHOLE[a];      tB: ThreeWords = LOOPHOLE[b];      FOR i: CARDINAL IN [0.. 3) DO        SELECT tA[i] FROM	  < tB[i] => RETURN[smaller]; > tB[i] => RETURN[bigger]; ENDCASE;	ENDLOOP}};    Increment: PROCEDURE [a: System.HostNumber] RETURNS [System.HostNumber] = {    tA: ThreeWords ¬ LOOPHOLE[a];    temp: LONG CARDINAL ¬ 0;    FOR i: CARDINAL DECREASING IN [0.. 3) DO      temp ¬ LONG[tA[i]] + 1 + LONG[Inline.HighHalf[temp]];      tA[i] ¬ Inline.LowHalf[temp];      ENDLOOP;    RETURN[LOOPHOLE[tA]]};    FreeReply: PUBLIC PROCEDURE [reply: LONG POINTER TO Reply] = {z.FREE[reply]};    NewReply: PROCEDURE [max: CARDINAL] RETURNS [reply: Reply] = {    reply ¬ z.NEW[ReplySeq[max]]; reply.count ¬ 0};    WaitForNet: PROCEDURE [net: System.NetworkNumber]    RETURNS [delay: Socket.WaitTime ¬ Socket.defaultWaitTime] = {    IF net = System.nullNetworkNumber THEN RETURN[localTimeOut];    delay ¬ (2 + 2 * Router.GetDelayToNet[net]) * 1000};    --- Sorting and Compressing    Index: TYPE = INTEGER;  Comparison: TYPE = {smaller, same, bigger};    CompressReply: PROCEDURE [reply: Reply] = {    i, j: CARDINAL ¬ 1;    IF reply.count < 2 THEN RETURN;    WHILE j < reply.count DO      IF reply[j] = reply[j - 1] THEN j ¬ SUCC[j]      ELSE {reply[i] ¬ reply[j]; i ¬ SUCC[i]; j ¬ SUCC[j]};      ENDLOOP;    reply.count ¬ i};    SortReply: PROCEDURE [reply: Reply] = {      CompareProc: PROCEDURE [one, two: Index] RETURNS [Comparison] = {      RETURN Compare[reply[one], reply[two]]};        Swap: PROCEDURE [one, two: Index] = {      temp: System.HostNumber ¬ reply[one];      reply[one] ¬ reply[two]; reply[two] ¬ temp};	    Sort: PROCEDURE [min, max: Index] = {      doMax: BOOLEAN ¬ TRUE;      middle: Index = (max + min) / 2;      i, j: Index;      IF max - min < 8 THEN {InsertionSort[min, max]; RETURN};            -- put the median of min, max, and middle at min      IF CompareProc[middle, max] = bigger THEN Swap[middle, max];      IF CompareProc[middle, min] = bigger THEN Swap[middle, min];      IF CompareProc[min, max] = bigger THEN Swap[min, max];            i ¬ min;      j ¬ max;      WHILE i < j DO	IF CompareProc[i, j] = bigger THEN {Swap[i, j]; doMax ¬ NOT doMax};	IF doMax THEN j ¬ j - 1 ELSE i ¬ i + 1;	ENDLOOP;      Sort[min, i - 1];      Sort[i + 1, max]};        InsertionSort: PROCEDURE [min, max: Index] = {      FOR j: Index IN (min..max] DO	-- ASSERT that elements in range [min..j) are now in order	-- the inner loop drags down the jth element to its proper position	FOR i: Index DECREASING IN [min..j) DO	  IF CompareProc[i, i+1] = bigger THEN Swap[i, i+1]	  ELSE EXIT;  -- the sub range is done	  ENDLOOP;	ENDLOOP};        IF reply.count < 2 THEN RETURN;    Sort[0, reply.count - 1]};  END...
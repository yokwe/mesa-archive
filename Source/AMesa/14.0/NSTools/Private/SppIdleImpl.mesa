-- File: SppIdleImpl.mesa - last edit:-- AOF                 26-Jan-87 22:45:17-- Copyright (C) 1984, 1985 , 1987 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [StringToNetworkAddress, Error, PrintError],   Environment USING [Block, Byte],  EthernetDriverFriends USING [GetEthernetStats, EtherStatsInfo],  Exec USING [    AddCommand, ExecProc, CheckForAbort, OutputProc, GetToken, FreeTokenString],  Format USING [Decimal, LongDecimal, StringProc],  Heap USING [systemZone],  NetworkStream USING [    Close, CloseReply, Create, ConnectionSuspended, ConnectionFailed],  NSConstants USING [echoerSocket],  Process USING [Abort, CancelAbort, GetCurrent, Pause, SecondsToTicks],  Router USING [GetDelayToNet, NoTableEntryForNet],  Stream USING [Handle, SubSequenceType],  String USING [StringToLongNumber],  System USING [NetworkAddress, GetGreenwichMeanTime],  Time USING [AppendCurrent];SppIdleImpl: MONITOR  IMPORTS    AddressTranslation, Format, Exec, Process, Router, System,    String, NetworkStream, Time, Heap, EthernetDriverFriends =  BEGIN  Stat: TYPE = LONG POINTER TO StatsRecord;  StatIndex: TYPE = {packetsRecv, wordsRecv, packetsMissed, badRecvStatus,    okButDribble, badCrc, badAlignmentButOkCrc, crcAndBadAlignment,    packetTooLong, overrun, idleInput, packetsSent, wordsSent, badSendStatus,    tooManyCollisions, lateCollisions, underrun, stuckOutput};  StatsRecord: TYPE = RECORD[    tag: ARRAY StatIndex OF LONG STRING,    copy: ARRAY StatIndex OF LONG CARDINAL,    new: ARRAY StatIndex OF LONG CARDINAL,    loadTable: ARRAY INTEGER[0..15] OF LONG CARDINAL];  userAbort: BOOLEAN;  ExecCall: Exec.ExecProc =    BEGIN    Watcher: PROC =      BEGIN      ENABLE ABORTED => CONTINUE;      UNTIL Exec.CheckForAbort[h] DO        Process.Pause[2]; ENDLOOP;      userAbort ¬ TRUE; Process.Abort[parent];      END;  --Watcher    sH: Stream.Handle;    delay: CARDINAL = 2;    lost, hops: CARDINAL;    process: CARDINAL = 4;    waitTime, idle: LONG CARDINAL;    parent, watcher: PROCESS ¬ NIL;    destination: System.NetworkAddress;    remote, switches: LONG STRING ¬ NIL;    execOut: Format.StringProc = Exec.OutputProc[h];    out: ENTRY Format.StringProc = {execOut[s]};    BEGIN    ENABLE AddressTranslation.Error =>      {AddressTranslation.PrintError[errorRecord, out]; GOTO error};    [remote, switches] ¬ Exec.GetToken[h];    IF remote = NIL THEN GOTO null;    idle ¬ IF switches # NIL THEN String.StringToLongNumber[switches] ELSE 10000;    userAbort ¬ FALSE;  --reset so we don't copy    parent ¬ Process.GetCurrent[];  --so watcher can abort us    watcher ¬ FORK Watcher;  --to see that we don't get in trouble    [destination, ] ¬ AddressTranslation.StringToNetworkAddress[remote];    out[remote]; out[" is "L];    remote ¬ Exec.FreeTokenString[remote];    switches ¬ Exec.FreeTokenString[switches];    destination.socket ¬ NSConstants.echoerSocket;    hops ¬ Router.GetDelayToNet[destination.net !      Router.NoTableEntryForNet => {out["No route to network"L]; GOTO error}];    lost ¬ SELECT hops FROM      0 => 0, IN[1..4) => 2, IN[4..8) => 3, ENDCASE => 4;    waitTime ¬ LONG[process + (delay + lost) * hops] * 1000;    Format.Decimal[out, hops]; out[" hops away\n"L];    IF userAbort THEN GOTO join;    sH ¬ NetworkStream.Create[destination, , waitTime, bulk !      NetworkStream.ConnectionFailed => GOTO connection];    TestIdle[sH, idle, out];  --just to close    sH.delete[sH];    EXITS      error, join => NULL;      null => out["Host name is NULL"L];      connection => out["Connection failed"L];    END;    IF watcher # NIL THEN {Process.Abort[watcher]; JOIN watcher};    IF parent # NIL THEN Process.CancelAbort[parent]; --to make exec happy    END; -- ExecCall  TestIdle: PROC[    sH: Stream.Handle, idle: LONG CARDINAL, out: Format.StringProc] =    BEGIN    SppReceiver: PROC[sH: Stream.Handle] =      BEGIN      ENABLE	BEGIN	ABORTED => CONTINUE;	NetworkStream.ConnectionSuspended => {suspended ¬ TRUE; CONTINUE};	END;      sst: Stream.SubSequenceType;      data: PACKED ARRAY INTEGER[0..40) OF Environment.Byte;      block: Environment.Block ¬ [@data, 0, LENGTH[data]];      sH.setTimeout[sH, LAST[LONG CARDINAL]];  --let's not worry 'bout this      sH.options.terminateOnEndRecord ¬ TRUE;  --so we can break on packets       --UNTIL hell freezes over--DO	sst ¬ sH.get[sH, block, sH.options].sst;	SELECT sst FROM	  0 => --out[LOOPHOLE[@data, STRING]]-- {};	  254, 255 => {[] ¬ NetworkStream.CloseReply[sH]; EXIT};	  ENDCASE;  --just ignore	ENDLOOP;       END;  --SppReceiver    time: LONG STRING ¬ [40];    suspended: BOOLEAN ¬ FALSE;    receiver: PROCESS ¬ FORK SppReceiver[sH];    start: LONG CARDINAL ¬ System.GetGreenwichMeanTime[];    block: Environment.Block ¬ [LOOPHOLE[time], 0, 40];    stat: Stat ¬ Heap.systemZone.NEW[StatsRecord];    stat.tag ¬ [      NIL, NIL, "packetsMissed"L, "badRecvStatus"L,      "okButDribble"L, "badCrc"L, "badAlignmentButOkCrc"L, "crcAndBadAlignment"L,      "packetTooLong"L, "overrun"L, "idleInput"L, NIL, NIL,      "badSendStatus"L, "tooManyCollisions"L, "lateCollisions"L, "underrun"L,      "stuckOutput"L];    stat.copy ¬ ALL[0];    BEGIN    --UNTIL user aborts-- DO      ENABLE ABORTED => EXIT;  --then go close connection      time.length ¬ 0; Time.AppendCurrent[time];      block.stopIndexPlusOne ¬ time.length + 4; sH.put[sH, block, TRUE];      PrintStat[stat, out];      THROUGH[0..10) DO	Process.Pause[Process.SecondsToTicks[CARDINAL[idle/10]]];	IF suspended THEN {out["Connection lost"L]; GOTO lost};	ENDLOOP;      ENDLOOP;    [] ¬ NetworkStream.Close[sH];  --then let the guy go    EXITS lost => NULL;    END;    PrintStat[stat, out];    Process.Abort[receiver]; JOIN receiver;  --get consumer of packets back    Heap.systemZone.FREE[@stat];    END;  --TestIdle  PrintStat: PROC[stat: Stat, out: Format.StringProc] =    BEGIN    time: LONG STRING ¬ [30];    info: LONG POINTER TO EthernetDriverFriends.EtherStatsInfo;    info ¬ LOOPHOLE[@stat.new];    time.length ¬ 0; Time.AppendCurrent[time]; out[time]; out["\n"L];    info­ ¬ EthernetDriverFriends.GetEthernetStats[1];    FOR i: StatIndex IN StatIndex DO      IF (stat.tag[i] # NIL) AND (stat.new[i] # stat.copy[i]) THEN	BEGIN	out[stat.tag[i]]; out[": "L];	Format.LongDecimal[out, stat.new[i] - stat.copy[i]];	out["\n"L];	END;      ENDLOOP;    stat.copy ¬ stat.new;    END;  --PrintStat  ExecHelp: Exec.ExecProc =    BEGIN    out: Format.StringProc ¬ Exec.OutputProc[h];    out["SppIdle <remote name>/<switches>\n"L];    out["Valid <switches> decimal numbers | <empty>\n"L];    out["Example\n>SppIdle.~ FileServer/100D\n"L];    END; -- HelpSwat  Exec.AddCommand[ name: "SppIdle.~"L, proc: ExecCall, help: ExecHelp]  END.Log15-Apr-85 18:38:19 AOF  Created file  
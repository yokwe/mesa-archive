-- File: PingImpl.mesa - last edit:-- AOF                 10-Aug-88 20:01:44-- JAV                 14-Jul-87 15:19:07-- Copyright (C) 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [    Error, NetworkAddress, PrintError, StringToNetworkAddress],  ArpaBuffer USING [Body, Buffer, DataBytesPerRawBuffer, ReturnBuffer],  ArpaConstants USING [echoPort],  ArpaPort USING [    CreateICMPEcho, Delete, GetPacket, GetSendBuffer, Handle, minIPHeaderBytes,    PutPacket, SetIPLengths, SetWaitTime, Timeout],  ArpaRouter USING [    ArpaPackageDestroy, ArpaPackageMake, GetAddress, InternetAddress, Port],  ArpaTypes USING [Byte, IcmpType, InternetAddress],  Environment USING [Block, Byte, bytesPerWord],  Exec USING [    AddCommand, CheckForAbort, ExecProc, FreeTokenString, GetToken, Handle,    OutputProc],  ExtendedString USING [StringToNumber],  Format USING [Decimal, LongDecimal, NetworkAddress, StringProc],  Heap USING [FreeNode, MakeNode, systemZone],  Inline USING [BITSHIFT, DBITSHIFT, LongDiv, LowByte],  NetworkStream USING [closeReplySST, closeSST, WaitTime],  NSBuffer USING [Body, Buffer],  NSConstants USING [echoerSocket],  NSTypes USING [    Byte, bytesPerSppHeader, EchoType, maxDataBytesPerEcho, maxDataBytesPerSpp,    PacketType, WaitTime],  PacketStream USING [    ConnectionFailed, ConnectionSuspended, Handle, Make, unknownConnID],  Process USING [Abort, GetCurrent, Pause],  PupDefs USING [    AppendPupAddress, Body, Buffer, Byte, DataWordsPerPupBuffer, GetBuffer,    GetPupAddress, PupAddress, PupNameTrouble, PupPackageDestroy, PupPackageMake,    PupSocket, PupSocketDestroy, PupSocketMake, ReturnBuffer, SecondsToTocks,    SetPupContentsBytes],  PupPktOps USING [pupBuffers],  PupRouterDefs USING [GetRoutingTable, RoutingTableEntry],  PupTypes USING [    Byte, echoSoc, fillInSocketID, maxDataWordsPerGatewayPup],  Resolve USING [Error, LocalAppendAddr, StringToAddr],  Router USING [GetDelayToNet, NoTableEntryForNet],  Runtime USING [UnboundProcedure],  Socket USING [    ChannelHandle, Create, Delete, GetPacket, GetSendBuffer, PutPacket,    ReturnBuffer, SetPacketBytes, SetWaitTime, SocketNumber, TimeOut, WaitTime],  Stream USING [SubSequenceType],  String USING [    AppendChar, EquivalentString, StringToNumber, SubString, SubStringDescriptor],  System USING [    GetClockPulses, GetGreenwichMeanTime, NetworkAddress, nullNetworkAddress,    nullSocketNumber, PulsesToMicroseconds, SocketNumber],  TcpStream USING [CompletionCode, Failed, Handle, Make, Suspended],  TcpStreamInternal USING [maxTcpDataBytes, UniquePktID];PingImpl: PROGRAM  IMPORTS    ArpaBuffer, AddressTranslation, Resolve, ArpaPort,    ArpaRouter, Format, Exec, Inline, Heap, Process, Router, Socket,    System, ExtendedString, String, PacketStream, PupDefs, PupRouterDefs,    Runtime, PupPktOps, TcpStream, TcpStreamInternal  EXPORTS ArpaRouter =  BEGIN    InternetAddress: PUBLIC TYPE = ArpaTypes.InternetAddress;  hops: CARDINAL;  bias: CARDINAL;  delay: CARDINAL = 2;  process: CARDINAL = 1;  waitTime: Socket.WaitTime;  arpaTarget: InternetAddress;  z: UNCOUNTED ZONE = Heap.systemZone;  bpw: NATURAL = Environment.bytesPerWord;    EchoProcType: TYPE = PROC[    destination: System.NetworkAddress, sends: CARDINAL, hist: HistPointer,    out: Format.StringProc, packetSize: CARDINAL ¬ 0]    RETURNS[good, late, missed, bad: CARDINAL ¬ 0, rate: LONG CARDINAL ¬ 0];  HistPointer: TYPE = LONG DESCRIPTOR FOR Histogram;  Histogram: TYPE = ARRAY CARDINAL[0..128) OF CARDINAL;  EchoHeader: TYPE = LONG POINTER TO EchoObject;  EchoObject: TYPE = RECORD[    SELECT OVERLAID * FROM      desc => [echoType: EchoType, time: LONG CARDINAL, bytes: CARDINAL],      data => [echoBytes: PACKED ARRAY[0..0) OF Environment.Byte],      ENDCASE];  EchoType: TYPE = MACHINE DEPENDENT{    (FIRST[CARDINAL]), echoRequest(1), echoResponse(2), (LAST[CARDINAL])};  bpeh: NATURAL = bpw * SIZE[desc EchoObject];  ExecCall: Exec.ExecProc =    BEGIN    Watcher: PROC =      BEGIN      ENABLE ABORTED => CONTINUE;      UNTIL Exec.CheckForAbort[h] DO        Process.Pause[2]; ENDLOOP;      userAbort ¬ TRUE; Process.Abort[parent];      END;  --Watcher    type: EchoProcType;    rate: LONG CARDINAL;    begin, end: CARDINAL;    userAbort: BOOLEAN ¬ FALSE;    parent, watcher: PROCESS ¬ NIL;    destination: System.NetworkAddress;    remote, switches: LONG STRING ¬ NIL;    missed, bad, late, good, sends: CARDINAL;    where: POINTER TO PupDefs.PupAddress ¬ LOOPHOLE[@destination];    histogram: LONG POINTER TO Histogram ¬ z.NEW[Histogram ¬ ALL[0]];    packetSize: CARDINAL ¬ LAST[CARDINAL];    dots: STRING = " ... "L;    done: STRING = "done\n"L;    echoer: STRING = "Echo to"L;    away: STRING = " hops away"L;    scan: STRING = "scan error"L;    host: STRING = "no host name"L;    other: STRING = "other error"L;    wild: STRING = "can't broadcast"L;    at: STRING = "converting address"L;    send: STRING = "sending requests"L;    timeout: STRING = "timeout set to "L;    net: STRING = "no route to network"L;    pupName: STRING = "PUP name not found"L;    zero: STRING = "number of packet is zero"L;    noPup: STRING = "no PUP protocol support"L;    noArpa: STRING = "no ARPA protocol support"L;    out: Format.StringProc ¬ Exec.OutputProc[h];    BEGIN    ENABLE      BEGIN      ABORTED => GOTO join;      AddressTranslation.Error =>        {AddressTranslation.PrintError[errorRecord, out]; GOTO error};      END;    out[echoer]; out[dots];    [remote, switches] ¬ Exec.GetToken[h];    IF String.EquivalentString[remote, "SIZE"L] THEN {      packetSize ¬ String.StringToNumber[switches];      [remote, switches] ¬ Exec.GetToken[h]};    IF remote = NIL THEN GOTO null;    IF switches # NIL THEN      BEGIN      ss: String.SubStringDescriptor ¬ [switches, 0, switches.length];      SELECT TRUE FROM        EquivalentSubString[@ss, "ECHO"L, ':] => {type ¬ EchoUser};	EquivalentSubString[@ss, "SPP"L, ':] => {type ¬ SppUser};	EquivalentSubString[@ss, "PUP"L, ':] => {type ¬ PupUser};	EquivalentSubString[@ss, "TCP"L, ':] => {type ¬ TcpUser};	EquivalentSubString[@ss, "ICMP"L, ':] => {type ¬ IcmpUser};	ENDCASE =>	  {out["'"L]; out[switches]; out["' not recognized"L]; GOTO join};      SELECT TRUE FROM        (ss.offset = ss.length) => sends ¬ 1000;  --default value	((sends ¬ SubStringToDecimal[@ss]) = 0) => {out[zero]; GOTO join};	ENDCASE;      END    ELSE {type ¬ EchoUser; sends ¬ 1000};    out[remote]; out[dots]; out[at]; out[dots]; out[" ("L];    IF (remote.length = 1) AND (remote[0] = '*) THEN {out[wild]; GOTO join};    parent ¬ Process.GetCurrent[];  --so watcher can abort us    watcher ¬ FORK Watcher;  --to see that we don't get in trouble    bias ¬ IF type = TcpUser THEN 20 ELSE 6;    SELECT type FROM      EchoUser, SppUser =>        BEGIN	[destination, ] ¬ AddressTranslation.StringToNetworkAddress[remote];	remote ¬ Exec.FreeTokenString[remote];	switches ¬ Exec.FreeTokenString[switches];	destination.socket ¬ NSConstants.echoerSocket;	Format.NetworkAddress[out, destination, octal];	hops ¬ Router.GetDelayToNet[destination.net !	  Router.NoTableEntryForNet => {out[net]; GOTO error}];	END;      PupUser =>        BEGIN	pa: STRING ¬ [20];	routing: PupRouterDefs.RoutingTableEntry;	[] ¬ PupDefs.PupPackageMake[ !	  Runtime.UnboundProcedure => {out[noPup]; GOTO error}];	PupDefs.GetPupAddress[where, remote !	  PupDefs.PupNameTrouble => {out[pupName]; GOTO error}];	routing ¬ @PupRouterDefs.GetRoutingTable[][where.net];	IF routing = NIL OR routing.context = NIL THEN {out[net]; GOTO error};	where.socket ¬ PupTypes.echoSoc;	PupDefs.AppendPupAddress[pa, where­]; out[pa];	hops ¬ routing.hop;  --get the hop count out	END;      IcmpUser, TcpUser =>        BEGIN	aa: STRING ¬ [20];	[] ¬ ArpaRouter.ArpaPackageMake[ !	  Runtime.UnboundProcedure => {out[noArpa]; GOTO error}];	hops ¬ 0;  --'cause we only talk local right now.	arpaTarget ¬ Resolve.StringToAddr[remote !	  Resolve.Error => {out["ARPA address syntax error"L]; GOTO error}];	Resolve.LocalAppendAddr[aa, arpaTarget]; out[aa];	END;      ENDCASE;    out[") is "L];    waitTime ¬ LONG[process + delay * hops] * 1000;    Format.Decimal[out, hops]; out[away]; out[dots];    out[timeout]; Format.LongDecimal[out, waitTime]; out[dots];      IF userAbort THEN GOTO join;    out[send]; out[dots];    [good, late, missed, bad, rate] ¬ type[      destination, sends, DESCRIPTOR[histogram], out, packetSize];    out[done];    SELECT type FROM      PupUser => PupDefs.PupPackageDestroy[];      TcpUser, IcmpUser => ArpaRouter.ArpaPackageDestroy[];      ENDCASE;    out["  "L]; Format.Decimal[out, good]; out[" packets echoed\n"L];    out["  "L]; Format.Decimal[out, late]; out[" packets late\n"L];    out["  "L]; Format.Decimal[out, missed]; out[" packets missed\n"L];    out["  "L]; Format.Decimal[out, bad]; out[" packets bad\n"L];    out["  "L]; Format.LongDecimal[out, rate]; out[" bps echoed\n"L];    out["Echo round trip times(msecs)\n"L];    FOR begin IN[0..LENGTH[histogram­]) DO      IF histogram[begin] # 0 THEN EXIT; ENDLOOP;    FOR end DECREASING IN[0..LENGTH[histogram­]) DO      IF histogram[end] # 0 THEN EXIT; ENDLOOP;    FOR i: CARDINAL IN[begin..end] DO      IF histogram[i] = 0 THEN LOOP;      out["  ["L];      Format.Decimal[out, IF hops = 0 THEN (i + bias)        ELSE Inline.BITSHIFT[1, INTEGER[i - 1]]];      out[".."L];      Format.LongDecimal[out, LONG[        IF hops = 0 THEN (i + bias + 1) ELSE Inline.BITSHIFT[1, i]]];      out["): "L]; Format.Decimal[out, histogram[i]]; out["\n"L];      ENDLOOP;    EXITS      null => out[host];      error => out[")"L];      join => NULL;    END;    z.FREE[@histogram];    IF watcher # NIL THEN {Process.Abort[watcher]; JOIN watcher};    END; -- ExecCall  EquivalentSubString: PROC[    tag: String.SubString, match: STRING, stop: CHARACTER]    RETURNS[BOOLEAN] =    BEGIN    <<    a) tag­ cannot describe a NIL STRING | SubString.    b) match is all upper case.    c) tag.offset will point to the character following the stop character       if the test returns TRUE. Else the substring is unmodified.    >>    FOR i: CARDINAL IN[tag.offset..tag.length) DO      c: CHARACTER = tag.base[i];      SELECT TRUE FROM        (c = match[i]) => LOOP;  --upper case	((c - 40B) = match[i]) => LOOP;  --lower case	(i = tag.offset) => RETURN[FALSE];  --nope, not this time	(c = stop) => {tag.offset ¬ i + 1; RETURN[TRUE]};	ENDCASE => RETURN[FALSE];      ENDLOOP;    tag.offset ¬ tag.length;  --the string is empty    RETURN[TRUE];  --but the match was made    END;  --EquivalentSubString  SubStringToDecimal: PROC[ss: String.SubString] RETURNS[n: INTEGER] =    BEGIN    s: LONG STRING ¬ ss.base;    c: CHARACTER;  --individual characters    sf: STRING ¬ [10];  --the substring field    si: CARDINAL ¬ ss.offset;  --the substring index    base: CARDINAL ¬ 0;  --like a 10 with the '1' missing    UNTIL si = ss.length DO      c ¬ s[si]; si ¬ si + 1;      SELECT c FROM        IN['0..'7] => String.AppendChar[sf, c];        '8, '9 => {base ¬ MAX[base, 10]; String.AppendChar[sf, c]};        'A, 'C, 'E, 'F => {base ¬ 16; String.AppendChar[sf, c]};        'B, 'b =>          IF (si = ss.length) THEN base ¬ MAX[base, 8]          ELSE {base ¬ 16; String.AppendChar[sf, c]};        'D, 'd =>          IF (si = ss.length) OR (s[si] = '#) THEN base ¬ MAX[base, 10]          ELSE {base ¬ 16; String.AppendChar[sf, c]};        'H, 'h => IF (si = ss.length) THEN base ¬ 16 ELSE RETURN[0];        ENDCASE => RETURN[0];  --this is a failure      ENDLOOP;    IF sf.length = 0 THEN String.AppendChar[sf, '0];  --after all that!    IF base = 0 THEN base ¬ 10;  --never found any other evidence    ExtendedString.StringToNumber[@n, SIZE[INTEGER], base, sf]    END;  --SubStringToDecimal  PupUser: EchoProcType =    BEGIN    bytes: CARDINAL;    echo: EchoHeader;    bb: PupDefs.Body;    bits: LONG CARDINAL;    cH: PupDefs.PupSocket;    b: PupDefs.Buffer ¬ NIL;    where: POINTER TO PupDefs.PupAddress ¬ LOOPHOLE[@destination];    maxBytes: CARDINAL = bpw * MIN[      PupDefs.DataWordsPerPupBuffer[], PupTypes.maxDataWordsPerGatewayPup];    cH ¬ PupDefs.PupSocketMake[      PupTypes.fillInSocketID, where­,      PupDefs.SecondsToTocks[CARDINAL[waitTime / 1000]]];      bits ¬ 0; rate ¬ System.GetGreenwichMeanTime[];    FOR sent: CARDINAL IN[0..sends) DO      ENABLE ABORTED => EXIT;      bytes ¬ MAX[MIN[packetSize, maxBytes], bpeh];      IF b = NIL THEN b ¬ PupDefs.GetBuffer[        function: send, aH: PupPktOps.pupBuffers];      bb ¬ b.pup;  --get local copy of pointer to data      bb.pupID.a ¬ bb.pupID.b ¬ sent;      bb.pupType ¬ echoMe;      PupDefs.SetPupContentsBytes[b, bytes];      echo ¬ LOOPHOLE[@bb.pupWords[0]];      FOR i: NATURAL IN[0..bytes) DO	echo.echoBytes[i] ¬ Inline.LowByte[i + bytes]; ENDLOOP;      echo.echoType ¬ echoRequest;      echo.time ¬ System.GetClockPulses[];      echo.bytes ¬ bytes;      cH.put[b]; b ¬ NIL;      UNTIL (b ¬ cH.get[]) = NIL DO        bb ¬ b.pup;  --get local copy of pointer to data	echo ¬ LOOPHOLE[@bb.pupWords[0]];	IF bb.pupType # iAmEcho THEN GOTO noEchoServer;	echo ¬ LOOPHOLE[@bb.pupWords[0], EchoHeader];	IF LogTime[echo.time, hist] THEN late ¬ late + 1;	bytes ¬ echo.bytes;	bits ¬ bits + Inline.DBITSHIFT[bytes, 3];	FOR i: CARDINAL IN [bpeh..bytes) DO	  IF echo.echoBytes[i] # Inline.LowByte[i + bytes] THEN	    {bad ¬ bad + 1; EXIT};	  REPEAT FINISHED => good ¬ good + 1;	  ENDLOOP;	EXIT;  --got a response from this try	REPEAT FINISHED => missed ¬ missed + 1;	ENDLOOP;      REPEAT noEchoServer => NULL;      ENDLOOP;    rate ¬ System.GetGreenwichMeanTime[] - rate;  --elapsed time (seconds)    rate ¬ (bits + (rate / bpw)) / MAX[rate, 1];  --and the bit rate / second    IF b # NIL THEN PupDefs.ReturnBuffer[b];  --return the buffer    PupDefs.PupSocketDestroy[cH];  --then kill the socket    END;  --PupUser  EchoUser: EchoProcType =    BEGIN    bytes: CARDINAL;    echo: EchoHeader;    bb: NSBuffer.Body;    bits: LONG CARDINAL;    b: NSBuffer.Buffer ¬ NIL;    cH: Socket.ChannelHandle;    cH ¬ Socket.Create[System.nullSocketNumber];    Socket.SetWaitTime[cH, waitTime];    bits ¬ 0; rate ¬ System.GetGreenwichMeanTime[];    FOR sent: CARDINAL IN[0..sends) DO      ENABLE ABORTED => EXIT;      bytes ¬ MAX[MIN[packetSize, NSTypes.maxDataBytesPerEcho], bpeh];      IF b = NIL THEN b ¬ Socket.GetSendBuffer[cH];  --reuse receive buffer?      bb ¬ b.ns;  --get local copy of pointer      bb.destination ¬ destination;      bb.packetType ¬ echo;      echo ¬ LOOPHOLE[@bb.echoType];      FOR i: CARDINAL IN[0..bytes) DO        echo.echoBytes[i] ¬ Inline.LowByte[i + bytes]; ENDLOOP;      echo.echoType ¬ echoRequest;      echo.time ¬ System.GetClockPulses[];      echo.bytes ¬ bytes;      Socket.SetPacketBytes[b, bytes];      Socket.PutPacket[cH, b]; b ¬ NIL;  --send the packet      b ¬ Socket.GetPacket[cH ! Socket.TimeOut => {missed ¬ SUCC[missed]; LOOP}];      bb ¬ b.ns;  --get local copy of pointer      IF bb.packetType # echo THEN {missed ¬ SUCC[missed]; LOOP};      echo ¬ LOOPHOLE[@bb.echoType];      IF LogTime[echo.time, hist] THEN late ¬ SUCC[late];      bytes ¬ echo.bytes;      bits ¬ bits + Inline.DBITSHIFT[bytes, 3];      FOR i: NATURAL IN[bpeh..bytes) DO        IF echo.echoBytes[i] # Inline.LowByte[i + bytes] THEN	  {bad ¬ bad + 1; EXIT};	REPEAT FINISHED => good ¬ SUCC[good];	ENDLOOP;      ENDLOOP;    rate ¬ System.GetGreenwichMeanTime[] - rate;  --elapsed time (seconds)    rate ¬ (bits + (rate / bpw)) / MAX[rate, 1];  --and the bit rate / second    IF b # NIL THEN Socket.ReturnBuffer[b];  --return the buffer    Socket.Delete[cH];  --then kill the socket    END;  --EchoUser          TcpUser: EchoProcType =    BEGIN    echo: EchoHeader;    n, bytes: CARDINAL;    bits: LONG CARDINAL;    tries: CARDINAL ¬ 1;    tsH: TcpStream.Handle;    block: Environment.Block;    localPort: ArpaRouter.Port = LOOPHOLE[400];    me: InternetAddress ¬ ArpaRouter.GetAddress[];    maxBytes: CARDINAL = TcpStreamInternal.maxTcpDataBytes;    BEGIN    outcome: TcpStream.CompletionCode;    tsH ¬ TcpStream.Make[      me, arpaTarget, localPort, ArpaConstants.echoPort, TRUE, waitTime !        TcpStream.Failed =>	  IF tries > 3 THEN GOTO failed ELSE {tries ¬ tries + 1; RETRY}];    block ¬ [Heap.MakeNode[z, maxBytes / bpw], 0, maxBytes];    bits ¬ 0; rate ¬ System.GetGreenwichMeanTime[];    FOR sent: CARDINAL IN[0..sends) DO      ENABLE {ABORTED => EXIT; TcpStream.Suspended => GOTO suspended};      bytes ¬ MAX[MIN[packetSize, maxBytes], bpeh];      echo ¬ LOOPHOLE[block.blockPointer];      FOR i: CARDINAL IN[0..bytes) DO        echo.echoBytes[i] ¬ Inline.LowByte[i + bytes]; ENDLOOP;      echo.echoType ¬ echoRequest;      echo.time ¬ System.GetClockPulses[];      echo.bytes ¬ bytes;      block.stopIndexPlusOne ¬ bytes;      tsH.put[block, TRUE, FALSE];      DO  --until not timeout        [n, outcome] ¬ tsH.get[block];	IF outcome # timeout THEN EXIT;	ENDLOOP;      IF LogTime[echo.time, hist] THEN late ¬ late + 1;             IF n # (bytes ¬ echo.bytes) THEN bad ¬ bad + 1;      bits ¬ bits + Inline.DBITSHIFT[bytes, 3];      FOR i: CARDINAL IN [bpeh..bytes) DO	IF echo.echoBytes[i] # Inline.LowByte[i + bytes] THEN	    {bad ¬ bad + 1; EXIT};	REPEAT FINISHED => good ¬ good + 1;        ENDLOOP;      ENDLOOP;    rate ¬ System.GetGreenwichMeanTime[] - rate;  --elapsed time (seconds)    tsH.close[];  --tell the remote we're finished    [] ¬ tsH.get[block];  --just to give remote a chance to end gracefully.    EXITS suspended =>      BEGIN      rate ¬ System.GetGreenwichMeanTime[] - rate;  --still interesting?      out["Tcp stream suspended ..."L];  --indicate why we're dropping out      END;    END;    tsH.destroy[tsH];  --get rid of the instance    Heap.FreeNode[z, block.blockPointer];  --free my storage    rate ¬ (bits + (rate / 2)) / MAX[rate, 1];  --and the bit rate / second    EXITS failed => out["can't create Tcp stream ..."L];    END;  --TcpUser      IcmpUser: EchoProcType =    BEGIN    echo: EchoHeader;    pH: ArpaPort.Handle;    bb: ArpaBuffer.Body;    bits: LONG CARDINAL;    b: ArpaBuffer.Buffer ¬ NIL;    bytes, icmpLength: CARDINAL;    icmpHeaderLength: CARDINAL = 8;    me: InternetAddress ¬ ArpaRouter.GetAddress[];        pH ¬ ArpaPort.CreateICMPEcho[1, 1];    ArpaPort.SetWaitTime[pH, waitTime];    bits ¬ 0; rate ¬ System.GetGreenwichMeanTime[];    FOR sent: CARDINAL IN[0..sends) DO      ENABLE ABORTED => {out[" aborted by user... "L]; EXIT};      bb ¬ (b ¬ ArpaPort.GetSendBuffer[pH]).arpa;      icmpLength ¬ ArpaBuffer.DataBytesPerRawBuffer[b] -        ArpaPort.minIPHeaderBytes;      bytes ¬ MAX[MIN[packetSize, icmpLength], bpw * SIZE[EchoObject]];      bb.ipHeader.source ¬ me;      bb.ipHeader.protocol ¬ icmp;      bb.ipHeader.service ¬ [        precedence: routine, delay: FALSE,	throughput: FALSE, reliability: FALSE, reserved: 0];      bb.ipHeader.destination ¬ arpaTarget;      bb.ipHeader.identification ¬ TcpStreamInternal.UniquePktID[];      bb.icmp.body ¬ echo[        code: 0, checksum: 0, identifier: sent, sequence: sent, icmpData: ];      WITH bb.icmp SELECT FROM echo => echo ¬ LOOPHOLE[@icmpData]; ENDCASE;      FOR i: NATURAL IN[0..bytes) DO	echo.echoBytes[i] ¬ Inline.LowByte[i + bytes]; ENDLOOP;      echo.bytes ¬ bytes;  --the number of bytes      echo.echoType ¬ echoRequest;  --causual identifier      echo.time ¬ System.GetClockPulses[];  --time we sent it      ArpaPort.SetIPLengths[bb, 0, bytes + icmpHeaderLength];      ArpaPort.PutPacket[pH, b]; b ¬ NIL;      b ¬ ArpaPort.GetPacket[pH !        ArpaPort.Timeout => {missed ¬ SUCC[missed]; LOOP}];      bb ¬ b.arpa;      IF bb.ipHeader.protocol # icmp THEN {bad ¬ SUCC[bad]; LOOP};      WITH bb.icmp SELECT FROM        echoReply => echo ¬ LOOPHOLE[@icmpData];	ENDCASE => {bad ¬ SUCC[bad]; LOOP};      IF LogTime[echo.time, hist] THEN late ¬ SUCC[late];  --how fast?      bytes ¬ echo.bytes;  --that's what we sent      bits ¬ bits + Inline.DBITSHIFT[bytes, 3];  --and 8 bits/byte      FOR i: NATURAL IN[bpeh..bytes) DO	IF echo.echoBytes[i] # Inline.LowByte[i + bytes] THEN	  {bad ¬ bad + 1; EXIT};	REPEAT FINISHED => good ¬ SUCC[good];	ENDLOOP;      ArpaBuffer.ReturnBuffer[b]; b ¬ NIL      ENDLOOP;    rate ¬ System.GetGreenwichMeanTime[] - rate;  --elapsed time (seconds)    rate ¬ (bits + (rate / bpw)) / MAX[rate, 1];  --and the bit rate / second    IF b # NIL THEN ArpaBuffer.ReturnBuffer[b];  --return the buffer    ArpaPort.Delete[pH];  --then kill the socket    END;  --IcmpUser  SppUser: EchoProcType =    BEGIN    bytes: CARDINAL;    echo: EchoHeader;    bb: NSBuffer.Body;    bits: LONG CARDINAL;    b: NSBuffer.Buffer ¬ NIL;    psH: PacketStream.Handle;    sst: Stream.SubSequenceType ¬ 0;    psH ¬ PacketStream.Make[      System.nullNetworkAddress, destination,      PacketStream.unknownConnID, PacketStream.unknownConnID,      TRUE, waitTime, bulk !      PacketStream.ConnectionFailed => GOTO exit];    bits ¬ 0; rate ¬ System.GetGreenwichMeanTime[];    FOR sent: CARDINAL IN[0..sends) DO      ENABLE        BEGIN	ABORTED => {out[" aborted by user... "L]; EXIT};	PacketStream.ConnectionSuspended =>	  {IF sst # NetworkStream.closeReplySST THEN	    out[" connection suspended... "L]; EXIT};	END;      b ¬ psH.getSendBuffer[];      bb ¬ b.ns;  --create local copy of data area pointer      SELECT TRUE FROM        (sst = NetworkStream.closeSST) =>	  {out[" closed by remote ..."L];	  bb.subtype ¬ NetworkStream.closeReplySST};	(sst = NetworkStream.closeReplySST) =>	  bb.subtype ¬ NetworkStream.closeReplySST;        ((sends - sent) = 1) =>	  bb.subtype ¬ NetworkStream.closeSST;	ENDCASE => bb.subtype ¬ 0;      echo ¬ LOOPHOLE[@bb.sppWords[0]];      bytes ¬ MAX[MIN[packetSize, NSTypes.maxDataBytesPerSpp], bpeh];      FOR i: CARDINAL IN[0..bytes) DO        echo.echoBytes[i] ¬ Inline.LowByte[i + bytes]; ENDLOOP;      echo.echoType ¬ echoRequest;      echo.time ¬ System.GetClockPulses[];      echo.bytes ¬ bytes;      Socket.SetPacketBytes[b, bytes + NSTypes.bytesPerSppHeader];      psH.put[b]; b ¬ NIL;  --send the packet      IF (b ¬ psH.get[]) = NIL THEN {missed ¬ missed + 1; LOOP};      bb ¬ b.ns;  --create local copy of data area pointer      echo ¬ LOOPHOLE[@bb.sppWords[0]];      IF LogTime[echo.time, hist] THEN late ¬ late + 1;      bytes ¬ echo.bytes;      bits ¬ bits + Inline.DBITSHIFT[bytes, 3];      sst ¬ bb.subtype;  --copy out his sst      FOR i: CARDINAL IN[bpeh..bytes) DO        IF echo.echoBytes[i] # Inline.LowByte[i + bytes] THEN	  {bad ¬ bad + 1; EXIT};	REPEAT FINISHED => good ¬ good + 1;	ENDLOOP;      psH.returnReceiveBuffer[b];  --leave b # NIL so we exit      ENDLOOP;    rate ¬ System.GetGreenwichMeanTime[] - rate;  --elapsed time (seconds)    rate ¬ (bits + (rate / bpw)) / MAX[rate, 1];  --and the bit rate / second    psH.destroy[psH];    EXITS exit => out[" connection failed..."L];    END;  --SppUser  LogTime: PROC[time: LONG CARDINAL, hist: HistPointer] RETURNS[late: BOOLEAN] =    BEGIN    word: WORD;    milli: CARDINAL;    micro: LONG CARDINAL;    bitOn: CARDINAL;    micro ¬ System.PulsesToMicroseconds[[System.GetClockPulses[] - time]];    word ¬ milli ¬ Inline.LongDiv[micro, 1000];    IF hops = 0 THEN bitOn ¬ MIN[milli - bias, (LENGTH[hist] - 1)]    ELSE      FOR bitOn ¬ 0, bitOn + 1 UNTIL word = 0 DO	word ¬ Inline.BITSHIFT[word, -1]; ENDLOOP;    hist[bitOn] ¬ hist[bitOn] + 1;    RETURN[milli > waitTime];    END;  --LogTime  ExecHelp: Exec.ExecProc =    BEGIN    out: Format.StringProc ¬ Exec.OutputProc[h];    out["Ping.~ Size/<packet size> <remote name>/<switches>\n"L];    out["Valid <switches> are\n"L];    out[" 'echo:n' | 'spp:n' | 'pup:n' | 'tcp:n' | 'icmp:n'\n"L];    out["  where 'n' is the decimal number of packets to be echoed.\n"L];    out["Example\n>Ping Size/200 FileServer/echo:100\n"L];    END; -- HelpSwat  Exec.AddCommand[ name: "Ping.~"L, proc: ExecCall, help: ExecHelp]  END.Log10-Apr-85 13:39:17 AOF  Created file 7-Oct-85 17:35:21 SMA  Added Tcp echo.19-Nov-85  9:50:07 SMA  ArpaProtocol => Arpa10MBit. 7-Jan-86 10:15:39 SMA  New TcpStream for urgents.24-Sep-86 14:30:51 AOF  Error packets and multiple users23-Apr-87 11:31:19 AOF  ICMP Echo (started) 4-May-87 16:58:50 AOF  Real echo protocol of Spp echo18-May-87 13:25:08 AOF  More ICMP Echo
-- File: EtherMonitorImpl.mesa - last edit:-- AOF                 18-May-88  8:51:21-- SMA                 26-Apr-88 16:28:03-- Copyright (C) 1984, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  ArpaBuffer USING [Body],  Buffer USING [    Buffer, MakePool, DestroyPool, AccessHandle, ReturnBuffer, QueueObject,    QueueCleanup, QueueInitialize, Enqueue, Dequeue, Type],  DataLinkControl USING [AdjustInputQueueLength],  Driver USING [Device, GetDeviceChain],  IEEE8023 USING [Encapsulation, EncapObject],  Environment USING [Byte],  Exec USING [AddCommand, ExecProc, Handle, RemoveCommand],  ExtendedString USING [AppendOctal],  Format USING [StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    newLine, ProcType],  Heap USING [Create, Delete],  Inline USING [LongDivMod],  NSBuffer USING [Body],  Process USING [Abort, EnableAborts, DisableTimeout],  Protocol1 USING [SetMaximumBufferSize],  PupDefs USING [Body],  Put USING [CR, Line, Text],  Router USING [FindMyHostID],  Runtime USING [GetBcdTime],  SpecialCommunication USING [    SetEthernetCollectGarbageToo, SetSpyProc, SpyProc, SetEthernetListener,    SpyType],  SpecialSystem USING [HostNumber],  String USING [AppendChar, AppendDecimal, AppendLongDecimal, AppendString],  System USING [broadcastHostNumber, GetGreenwichMeanTime],  Time USING [Append, Unpack],  Tool USING [    Create, Destroy, MakeFormSW, MakeSWsProc, MakeFileSW, UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Handle];    EtherMonitorImpl: MONITOR  IMPORTS    Buffer, DataLinkControl, Driver, Exec, SpecialCommunication, Put,    FormSW, Process, Router, Inline, Protocol1, Runtime, ExtendedString,    String, System, Time, Tool, Heap  EXPORTS Buffer, System =  BEGIN  HostNumber: PUBLIC TYPE = SpecialSystem.HostNumber;  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;      wh: Window.Handle;  newGarbage: CONDITION;  tool: LONG POINTER TO ToolData ¬ NIL;  ToolData: TYPE = RECORD[    form, log: Window.Handle ¬ NIL,    oldSpy: ARRAY Buffer.Type OF SpecialCommunication.SpyProc ¬ ALL[NIL],    queue: Buffer.QueueObject ¬ NULL,    buffers: Buffer.AccessHandle ¬ NIL,    formatter: PROCESS ¬ NIL,    running: BOOLEAN ¬ FALSE,    started, good, bad, idle, full, empty: LONG CARDINAL ¬ 0,    broadcast, packetType: Collected ¬ [],    me: HostNumber ¬ NULL,    sockets: ARRAY CARDINAL[0..1024) OF LONG CARDINAL ¬ ALL[0]];  unit: CARDINAL = 1;  dispatcherBuffers: CARDINAL = 40;  zone: UNCOUNTED ZONE = Heap.Create[10];  output: Format.StringProc = {Put.Text[tool.log, s]};  all: HostNumber = System.broadcastHostNumber;  lastInput: LONG CARDINAL;  Collected: TYPE = RECORD[    echoMe, echoed, translation, arp, other, total: LONG CARDINAL ¬ 0,    pup: RECORD[      echoMe, iAmEcho, badEcho, error, rfc, abort, end, endRep, data, aData,      ack, mark, int, intRep, aMark, eData, eAck, eEnd, eAbort, rpp,      gatewayRequest, gatewayInfo, dateTenexRequest, dateTenexIs,      dateAltoRequest, dateAltoIs, mailCheck, mailIsNew, mailNotNew,      mailError, mailCheckLaurel, nameLookup, nameIs, nameError, addressLookup,      addressIs, whereIsUser, userIs, userError, netDirVersion, sendNetDir,      bootFileSend, kissOfDeath, request, result, unsolicited, custodian,      sync, pineAck, noop, bootDirReq, bootDirReply, other, total:      LONG CARDINAL ¬ 0],    ns: RECORD[      routingRequest, routingInfo, echoRequest, echoResponse, error, other,      pex, spp, xlate, ubBoot, ubIPC, boot, mail, ubDiag, total:      LONG CARDINAL ¬ 0],     arpa: RECORD[icmp, interGateway, gmcc, st, tcp, ucl, sicure, bbnRccMon,      nvp, pup, pluribus, telnet, xnet, chaos, udp, multiplexing,      dcn, tacMon, localNetwork, satnet, mitSubnet, satnetMon, ipCoreUtil,      backroomSatnetMon, widebandMon, widbandExpak, nd, other,      total: LONG CARDINAL ¬ 0]];    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      Initialize: PROCEDURE =    BEGIN    herald: STRING ¬ [60];    Process.EnableAborts[@newGarbage];    Process.DisableTimeout[@newGarbage];    Exec.AddCommand["EtherMonitor.~"L, NoOp, NIL, Unload];    String.AppendString[to: herald, from: "Ethernet Monitor of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 8;  -- omit hours, mins, zone.    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: herald];    END;      NoOp: Exec.ExecProc = { };    Unload: Exec.ExecProc =    BEGIN    Stop[];  --just in case    Tool.Destroy[wh];    Exec.RemoveCommand[h, "EtherMonitor.~"L];    Heap.Delete[zone];    END;  --Unload    MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "EtherMonitor.log"L];    tool.form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm, zone: zone];    tool.log ¬ Tool.MakeFileSW[window: window, name: logName];    END;  Pnz: PROC[v: LONG CARDINAL, tag: STRING] =    BEGIN    IF v # 0 THEN      BEGIN      string: STRING ¬ [60];      String.AppendString[string, tag];      String.AppendString[string, ": "L];      String.AppendLongDecimal[string, v];      String.AppendString[string, "  "L];      output[string];      END;    END;  --Pnz  Broadcast: FormSW.ProcType =    BEGIN    Put.CR[tool.log];    Put.Line[tool.log, "BROADCASTS"L];    Statistics[];    PrintCollecteds[@tool.broadcast];    END;  --Broadcast  PacketType: FormSW.ProcType =    BEGIN    Put.CR[tool.log];    Put.Line[tool.log, "PACKET TYPES"L];    Statistics[];    PrintCollecteds[@tool.packetType];    END;  --PacketType  Sockets: FormSW.ProcType =    BEGIN    string: STRING ¬ [80];    sockets0to10: ARRAY [0..10] OF STRING = [      "unknown"L, "routing"L, "echo"L, "error"L, "envoy"L, "courier"L,      "x860"L, "clearinghouse"L, "timeserver"L, "xlate"L, "bootserver"L];    sockets16to20: ARRAY [16..20] OF STRING = [      "ubIPC"L, "ubBootServer"L, "ubBootServee"L, "diagnosticsServer"L,      "newClearinghouse"L];    Put.CR[tool.log];    Put.Line[tool.log, "BROADCASTS TO WELL KNOWN SOCKETS"L];    Statistics[];    string.length ¬ 1; string[0] ¬ '	;  --<HT>    FOR i: CARDINAL IN[0..1024) DO      IF tool.sockets[i] # 0 THEN        BEGIN	String.AppendString[string, " ["L];	SELECT i FROM	  IN[0..10] => String.AppendString[string, sockets0to10[i]];	  IN[16..20] => String.AppendString[string, sockets16to20[i]];	  25 => String.AppendString[string, "electronicMailFirst"L];	  26 => String.AppendString[string, "electronicMailLast"L];	  32 => String.AppendString[string, "etherBooteeFirst"L];	  35 => String.AppendString[string, "etherBootGerm"L];	  36 => String.AppendString[string, "etherBooteeLast"L];	  40 => String.AppendString[string, "voyuer"L];	  41 => String.AppendString[string, "network management"L];	  48 => String.AppendString[string, "tele debugging"L];	  60 => String.AppendString[string, "galaxy"L];	  255 => String.AppendString[string, "XNS Compatibility control"L];	  256 => String.AppendString[string, "XNS Compatibility test"L];	  ENDCASE => String.AppendDecimal[string, i];	String.AppendString[string, "]: "L];	String.AppendLongDecimal[string, tool.sockets[i]];	IF string.length > 50 THEN	  {Put.Line[tool.log, string]; string.length ¬ 1};	END;      REPEAT        FINISHED => IF string.length > 1 THEN Put.Line[tool.log, string];      ENDLOOP;    END;  --Sockets      PrintCollecteds: PROC[collection: LONG POINTER TO Collected]  =    BEGIN    sNS: STRING = "NS[ "L;    end: STRING = "]\n\n"L;    sPup: STRING = "Pup[ "L;    sArpa: STRING = "Arpa[ "L;    output[sNS];    PrintNS[collection];    Pnz[collection.ns.total, "total"L];    output[end];    output[sPup];    PrintPup1[collection];    PrintPup2[collection];    PrintPup3[collection];    Pnz[collection.pup.total, "total"L];    output[end];        output[sArpa];    PrintArpa[collection];    Pnz[collection.arpa.total, "total"L];    output[end];    Pnz[collection.echoMe, "echoMe"L];    Pnz[collection.echoed, "echoed"L];    Pnz[collection.other, "other"L];    Pnz[collection.translation, "translation"L];    Pnz[collection.arp, "arp"L];    output[end];        Pnz[collection.total, "TOTAL"L];    Put.CR[tool.log];    END;  --PrintCollecteds  PrintPup1: PROC[collection: LONG POINTER TO Collected] =    BEGIN    Pnz[collection.pup.echoMe, "echoMe"L];    Pnz[collection.pup.iAmEcho, "iAmEcho"L];    Pnz[collection.pup.badEcho, "badEcho"L];    Pnz[collection.pup.error, "error"L];    Pnz[collection.pup.rfc, "rfc"L];    Pnz[collection.pup.abort, "abort"L];    Pnz[collection.pup.end, "end"L];    Pnz[collection.pup.endRep, "endRep"L];    Pnz[collection.pup.data, "data"L];    Pnz[collection.pup.aData, "aData"L];    Pnz[collection.pup.ack, "ack"L];    Pnz[collection.pup.mark, "mark"L];    Pnz[collection.pup.int, "int"L];    Pnz[collection.pup.intRep, "intRep"L];    Pnz[collection.pup.aMark, "aMark"L];    Pnz[collection.pup.eData, "eData"L];    Pnz[collection.pup.eAck, "eAck"L];    Pnz[collection.pup.eEnd, "eEnd"L];    Pnz[collection.pup.eAbort, "eAbort"L];    Pnz[collection.pup.rpp, "rpp"L];    Pnz[collection.pup.other, "other"L];    END;  --PrintPup1  PrintPup2: PROC[collection: LONG POINTER TO Collected] =    BEGIN    OPEN collection.pup;    Pnz[gatewayRequest, "gatewayRequest"L];    Pnz[gatewayInfo, "gatewayInfo"L];    Pnz[dateTenexRequest, "dateTenexRequest"L];    Pnz[dateTenexIs, "dateTenexIs"L];    Pnz[dateAltoRequest, "dateAltoRequest"L];    Pnz[dateAltoIs, "dateAltoIs"L];    Pnz[mailCheck, "mailCheck"L];    Pnz[mailIsNew, "mailIsNew"L];    Pnz[mailNotNew, "mailNotNew"L];    Pnz[mailError, "mailError"L];    Pnz[mailCheckLaurel, "mailCheckLaurel"L];    Pnz[nameLookup, "nameLookup"L];    Pnz[nameIs, "nameIs"L];    Pnz[nameError, "nameError"L];    END;  --PrintPup2  PrintPup3: PROC[collection: LONG POINTER TO Collected] =    BEGIN    OPEN collection.pup;    Pnz[addressLookup, "addressLookup"L];    Pnz[addressIs, "addressIs"L];    Pnz[whereIsUser, "whereIsUser"L];    Pnz[userIs, "userIs"L];    Pnz[userError, "userError"L];    Pnz[netDirVersion, "netDirVersion"L];    Pnz[sendNetDir, "sendNetDir"L];    Pnz[bootFileSend, "bootFileSend"L];    Pnz[kissOfDeath, "kissOfDeath"L];    Pnz[request, "request"L];    Pnz[result, "result "L];    Pnz[unsolicited, "unsolicited"L];    Pnz[custodian, "custodian"L];    Pnz[sync, "sync"L];    Pnz[pineAck, "pineAck"L];    Pnz[noop, "noop"L];    Pnz[bootDirReq, "bootDirReq"L];    Pnz[bootDirReply, "bootDirReply"L];    END;  --PrintPup3  PrintNS: PROC[collection: LONG POINTER TO Collected] =    BEGIN    OPEN collection.ns;    Pnz[routingRequest, "routingRequest"L];    Pnz[routingInfo, "routingInfo"L];    Pnz[echoRequest, "echoRequest"L];    Pnz[echoResponse, "echoResponse"L];    Pnz[error, "error"L];    Pnz[pex, "pex"L];    Pnz[spp, "spp"L];    Pnz[xlate, "xlate"L];    Pnz[ubBoot, "ubBoot"L];    Pnz[ubIPC, "ubIPC"L];    Pnz[boot, "boot"L];    Pnz[mail, "mail"L];    Pnz[ubDiag, "ubDiag"L];    Pnz[other, "other"L];    END;  --PrintNS          PrintArpa: PROC[c: LONG POINTER TO Collected] =    BEGIN    s: STRING ¬ [60];    Pnz[c.arpa.icmp, "icmp"L];    Pnz[c.arpa.interGateway, "interGateway"L];    Pnz[c.arpa.gmcc, "gmcc"L];    Pnz[c.arpa.st, "st"L];    Pnz[c.arpa.tcp, "tcp"L];    Pnz[c.arpa.ucl, "ucl"L];    Pnz[c.arpa.sicure, "sicure"L];    Pnz[c.arpa.bbnRccMon, "bbnRccMon"L];    Pnz[c.arpa.nvp, "nvp"L];    Pnz[c.arpa.pup, "pup"L];    Pnz[c.arpa.pluribus, "pluribus"L];    Pnz[c.arpa.telnet, "telnet"L];    Pnz[c.arpa.xnet, "xnet"L];    Pnz[c.arpa.chaos, "chaos"L];    Pnz[c.arpa.udp, "udp"L];    Pnz[c.arpa.multiplexing, "multiplexing"L];    Pnz[c.arpa.dcn, "dcn"L];    Pnz[c.arpa.tacMon, "tacMon"L];    Pnz[c.arpa.localNetwork, "localNetwork"L];    Pnz[c.arpa.satnet, "satnet"L];    Pnz[c.arpa.mitSubnet, "mitSubnet"L];    Pnz[c.arpa.satnetMon, "satnetMon"L];    Pnz[c.arpa.ipCoreUtil, "ipCoreUtil"L];    Pnz[c.arpa.backroomSatnetMon, "backroomSatnetMon"L];    Pnz[c.arpa.widebandMon, "widebandMon"L];    Pnz[c.arpa.widbandExpak, "widbandExpak"L];    Pnz[c.arpa.nd, "nd"L];    Pnz[c.arpa.other, "other"L];    END;  --PrintArpa  Statistics: FormSW.ProcType =    BEGIN    string: STRING ¬ [80];    h, m, s: CARDINAL;    d: LONG CARDINAL ¬ System.GetGreenwichMeanTime[];    String.AppendString[string, "Time range: "L];    Time.Append[string, Time.Unpack[[tool.started]]];    String.AppendString[string, " to "L];    Time.Append[string, Time.Unpack[[d]]];    Put.Line[tool.log, string]; string.length ¬ 0;    d ¬ d - tool.started;    String.AppendString[string, "Elpased time: "L];    [h, s] ¬ Inline.LongDivMod[d, 60*60];  --hours    IF h < 10 THEN String.AppendChar[string, '0];    String.AppendDecimal[string, h]; String.AppendChar[string, ':];    [m, s] ¬ Inline.LongDivMod[s, 60];  --minutes    IF m < 10 THEN String.AppendChar[string, '0];    String.AppendDecimal[string, m]; String.AppendChar[string, ':];    IF s < 10 THEN String.AppendChar[string, '0];    String.AppendDecimal[string, s]; Put.Line[tool.log, string];    string.length ¬ 0;    String.AppendString[string, "Total packets observed: "L];    String.AppendLongDecimal[string, tool.good]; Put.Line[tool.log, string];    string.length ¬ 0;    String.AppendString[string, "Number of packets requeued: "L];    String.AppendLongDecimal[string, tool.full]; Put.Line[tool.log, string];    string.length ¬ 0;    String.AppendString[string, "Number of consumed: "L];    String.AppendLongDecimal[string, tool.empty]; Put.Line[tool.log, string];    string.length ¬ 0;    String.AppendString[string, "Average packet/sec: "L];    s ¬ CARDINAL[tool.good/d];  --average rate / sec    String.AppendDecimal[string, s]; Put.Line[tool.log, string];    string.length ¬ 0;    String.AppendString[string, "Number of bad packets: "L];    String.AppendLongDecimal[string, tool.bad]; Put.Line[tool.log, string];    string.length ¬ 0;    String.AppendString[string, "Number of times ethernet idle: "L];    String.AppendLongDecimal[string, tool.idle]; Put.Line[tool.log, string];    END;  --Statistics  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL = 6;    items ¬ FormSW.AllocateItemDescriptor[nItems, zone];    items[0] ¬ FormSW.CommandItem[      tag: "Stop"L, proc: Stop, place: FormSW.newLine, z: zone];    items[1] ¬ FormSW.CommandItem[tag: "Go"L, proc: Go, z: zone];    items[2] ¬ FormSW.CommandItem[tag: "Garbage"L, proc: Statistics, z: zone];    items[3] ¬ FormSW.CommandItem[tag: "Broadcast"L, proc: Broadcast, z: zone];    items[4] ¬ FormSW.CommandItem[tag: "PacketType"L, proc: PacketType, z: zone];    items[5] ¬ FormSW.CommandItem[tag: "Sockets"L, proc: Sockets, z: zone];    RETURN[items: items, freeDesc: TRUE];    END;  Stop: FormSW.ProcType =    BEGIN    OPEN tool;    IF running THEN      BEGIN      s: STRING ¬ [40];      running ¬ FALSE;      [] ¬ SpecialCommunication.SetEthernetListener[unit, me];      [] ¬ SpecialCommunication.SetEthernetCollectGarbageToo[unit, FALSE];      FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	[] ¬ SpecialCommunication.SetSpyProc[NIL, type];	ENDLOOP;      --Driver.ChangeNumberOfInputBuffers[FALSE];      [] ¬ DataLinkControl.AdjustInputQueueLength[ethernet, 0, 5];      FOR device: Device ¬ Driver.GetDeviceChain[], device.next        UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 0];	ENDLOOP;      Process.Abort[formatter]; JOIN formatter;      Buffer.QueueCleanup[@queue];      Buffer.DestroyPool[buffers];  --give pool back      String.AppendString[s, "Collected stopped at "L];      Time.Append[s, Time.Unpack[]];      Put.Line[log, s];      Statistics[];      END;    END;        Go: FormSW.ProcType =    BEGIN    OPEN tool;    IF ~running THEN      BEGIN      s: STRING ¬ [40];      tool.sockets ¬ ALL[0];      me ¬ Router.FindMyHostID[];      running ¬ TRUE; good ¬ bad ¬ 0;      tool.broadcast ¬ packetType ¬ [];      started ¬ lastInput ¬ System.GetGreenwichMeanTime[];      String.AppendString[s, "Collected started at "L];      Time.Append[s, Time.Unpack[]];      Put.Line[log, s];      Buffer.QueueInitialize[@queue];      formatter ¬ FORK Formatter[];      FOR device: Device ¬ Driver.GetDeviceChain[], device.next        UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 1500];	ENDLOOP;      buffers ¬ Buffer.MakePool[dispatcherBuffers, 0];  --get large pool      --Driver.ChangeNumberOfInputBuffers[TRUE];      [] ¬ DataLinkControl.AdjustInputQueueLength[        ethernet, 0, dispatcherBuffers / 2];      FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	tool.oldSpy[type] ¬ SpecialCommunication.SetSpyProc[SpyProc, type];	ENDLOOP;      [] ¬ SpecialCommunication.SetEthernetListener[unit, all];      [] ¬ SpecialCommunication.SetEthernetCollectGarbageToo[unit, TRUE];      END;    END;      ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      (new = inactive) AND (tool # NIL) => {Stop[]; zone.FREE[@tool]};      (old = inactive) AND (tool = NIL) => {tool ¬ zone.NEW[ToolData]; Go[]};      ENDCASE;    END;	  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Worker routines:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Formatter: PROC =    BEGIN    OPEN tool;    OffQueue: ENTRY PROC RETURNS[b: Buffer.Buffer ¬ NIL] =      BEGIN      UNTIL b # NIL DO        ENABLE ABORTED => EXIT;        IF queue.length = 0 THEN {WAIT newGarbage; LOOP};	b ¬ Buffer.Dequeue[@queue];        ENDLOOP;      END;    b: Buffer.Buffer;    s: STRING ¬ [100];    WHILE running DO      dll: IEEE8023.Encapsulation;      IF (b ¬ OffQueue[]) = NIL THEN LOOP;      dll ¬ LOOPHOLE[b.linkLayer.blockPointer];      s.length ¬ 0; Time.Append[s, Time.Unpack[]];      Put.Line[log, s];      s.length ¬ 0; String.AppendString[s, "	Packet length:"L];      String.AppendDecimal[s, b.fo.driver.length]; Put.Line[log, s];      s.length ¬ 0; String.AppendString[s, "	Status = ethernet["L];      WITH status: b.fo.driver SELECT FROM        ethernet =>	  BEGIN	    String.AppendString[s, SELECT status.ethernet FROM	      pending =>  "pending"L, ok => "ok"L, overrun => "overrun"L,	      underrun => "underrun"L, packetTooLong => "packetTooLong"L,	      tooManyCollisions => "tooManyCollisions"L,	      crc => "crc"L, crcAndBadAlignment => "crcAndBadAlignment"L,	      badAlignmentButOkCrc => "badAlignmentButOkCrc"L,	      ENDCASE => "otherError"L];	    String.AppendChar[s, ']];	    Put.Line[log, s];	    s.length ¬ 0;	    String.AppendString[s, "	Encapsulation = ethernet[."L];	    ExtendedString.AppendOctal[	      @dll.ethernetDest, SIZE[HostNumber], s];	    String.AppendString[s, ". ¬ ."L];	    ExtendedString.AppendOctal[	      @dll.ethernetSource, SIZE[HostNumber], s];	    String.AppendString[s, "., "L];	    String.AppendString[s, SELECT dll.ethernetType FROM	      echoMe => "echoMe"L, echoed => "echoed"L, pup => "pup"L,	      translation => "translation"L, ns => "ns"L, arpa => "arpa"L,	      arp =>"arp"L, ENDCASE => "other"L];	    String.AppendString[s, "]"L];	    Put.Line[log, s];	  END;	ENDCASE;      Buffer.ReturnBuffer[b];      ENDLOOP;    END;  --Formatter	      SpyProc: SpecialCommunication.SpyProc =    --PROC[b: Buffer.Buffer] RETURNS[Buffer.Buffer]    BEGIN    OPEN tool;    OnQueue: ENTRY PROC = INLINE {Buffer.Enqueue[@queue, b]; NOTIFY newGarbage};    dll: IEEE8023.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];    IF b.fo.function # send THEN      BEGIN      WITH s: b.fo.driver SELECT FROM        ethernet =>	  SELECT s.ethernet FROM	    ok, badAlignmentButOkCrc => NULL;	    ENDCASE => {bad ¬ bad + 1; OnQueue[]; GOTO returnEmpty};	ENDCASE;      END;    good ¬ good + 1;    IF oldSpy[b.fo.type] # NIL THEN      {b ¬ oldSpy[b.fo.type][b, function]; IF b = NIL THEN GOTO returnEmpty};    IF dll.ethernetDest = all THEN      BEGIN      IF dll.ethernetType = ns THEN	BEGIN	socket: CARDINAL ¬ LOOPHOLE[LOOPHOLE[	  dll + SIZE[	    ethernet IEEE8023.EncapObject], NSBuffer.Body].destination.socket];	IF socket IN[0..1024) THEN sockets[socket] ¬ sockets[socket] + 1;	END;      Accumulate[@broadcast, b];      END;    Accumulate[@packetType, b];    SELECT TRUE FROM      (function = send) => GOTO returnFull;      (dll.ethernetDest = LOOPHOLE[me]),      (dll.ethernetDest = LOOPHOLE[all]) =>        BEGIN	delta: LONG CARDINAL ¬ System.GetGreenwichMeanTime[] - lastInput;	IF delta > 40 THEN tool.idle ¬ tool.idle + delta/40;	lastInput ¬ System.GetGreenwichMeanTime[];	GOTO returnFull;	END;      ENDCASE => {Buffer.ReturnBuffer[b]; GOTO returnEmpty};    EXITS      returnFull => {tool.full ¬ tool.full + 1; RETURN[b]};      returnEmpty => {tool.empty ¬ tool.empty + 1; RETURN[NIL]};    END;  Accumulate: PROC[   collection: LONG POINTER TO Collected, b: Buffer.Buffer] =    BEGIN    dll: IEEE8023.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];    collection.total ¬ collection.total + 1;    SELECT dll.ethernetType FROM      echoMe => collection.echoMe ¬ collection.echoMe + 1;      echoed => collection.echoed ¬ collection.echoed + 1;      pup =>	BEGIN	OPEN collection.pup;	bb: PupDefs.Body = LOOPHOLE[dll + SIZE[ethernet IEEE8023.EncapObject]];	total ¬ total + 1;	SELECT bb.pupType FROM	  gatewayRequest => gatewayRequest ¬ gatewayRequest + 1;	  gatewayInfo => gatewayInfo ¬ gatewayInfo + 1;	  dateTenexRequest => dateTenexRequest ¬ dateTenexRequest + 1;	  dateTenexIs => dateTenexIs ¬ dateTenexIs + 1;	  dateAltoRequest => dateAltoRequest ¬ dateAltoRequest + 1;	  dateAltoIs => dateAltoIs ¬ dateAltoIs + 1;	  mailCheck => mailCheck ¬ mailCheck + 1;	  mailIsNew => mailIsNew ¬ mailIsNew + 1;	  mailNotNew => mailNotNew ¬ mailNotNew + 1;	  mailError => mailError ¬ mailError + 1;	  mailCheckLaurel => mailCheckLaurel ¬ mailCheckLaurel + 1;	  nameLookup => nameLookup ¬ nameLookup + 1;	  nameIs => nameIs ¬ nameIs + 1;	  nameError => nameError ¬ nameError + 1;	  addressLookup => addressLookup ¬ addressLookup + 1;	  addressIs => addressIs ¬ addressIs + 1;	  whereIsUser => whereIsUser ¬ whereIsUser + 1;	  userIs => userIs ¬ userIs + 1;	  userError => userError ¬ userError + 1;	  netDirVersion => netDirVersion ¬ netDirVersion + 1;	  sendNetDir => sendNetDir ¬ sendNetDir + 1;	  bootFileSend => bootFileSend ¬ bootFileSend + 1;	  kissOfDeath => kissOfDeath ¬ kissOfDeath + 1;	  request => request ¬ request + 1;	  result => result ¬ result + 1;	  unsolicited => unsolicited ¬ unsolicited + 1;	  custodian => custodian ¬ custodian + 1;	  sync => sync ¬ sync + 1;	  pineAck => pineAck ¬ pineAck + 1;	  noop => noop ¬ noop + 1;	  bootDirReq => bootDirReq ¬ bootDirReq + 1;	  bootDirReply => bootDirReply ¬ bootDirReply + 1;	  echoMe => echoMe ¬ echoMe + 1;	  iAmEcho => iAmEcho ¬ iAmEcho + 1;	  badEcho => badEcho ¬ badEcho + 1;	  error => error ¬ error + 1;	  rfc => rfc ¬ rfc + 1;	  abort => abort ¬ abort + 1;	  end => end ¬ end + 1;	  endRep => endRep ¬ endRep + 1;	  data => data ¬ data + 1;	  aData => aData ¬ aData + 1;	  ack => ack ¬ ack + 1;	  mark => mark ¬ mark + 1;	  int => int ¬ int + 1;	  intRep => intRep ¬ intRep + 1;	  aMark => aMark ¬ aMark + 1;	  eData => eData ¬ eData + 1;	  eAck => eAck ¬ eAck + 1;	  eEnd => eEnd ¬ eEnd + 1;	  eAbort => eAbort ¬ eAbort + 1;	  rpp => rpp ¬ rpp + 1;	  ENDCASE => other ¬ other + 1;	END;      translation => collection.translation ¬ collection.translation + 1;      ns =>	BEGIN	OPEN collection.ns;	bb: NSBuffer.Body = LOOPHOLE[dll + SIZE[ethernet IEEE8023.EncapObject]];	total ¬ total + 1;	SELECT bb.packetType FROM	  routingInformation =>	    SELECT bb.routingType FROM	      routingInfoRequest =>		routingRequest ¬ routingRequest + 1;	      ENDCASE =>		routingInfo ¬ routingInfo + 1; 	  echo =>	    SELECT bb.echoType FROM	      echoRequest =>		echoRequest ¬ echoRequest + 1;	      ENDCASE =>		echoResponse ¬ echoResponse + 1; 	  error => error ¬ error;	  packetExchange => pex ¬ pex + 1;	  sequencedPacket => spp ¬ spp + 1;	  pupAddrTransPacket => xlate ¬ xlate + 1;	  ubBootPacket => ubBoot ¬ ubBoot + 1;	  ubIPCPacket => ubIPC ¬ ubIPC + 1;	  bootServerPacket => boot ¬ boot + 1;	  electronicMailCacheFlushPacket => mail ¬ mail + 1;	  ubDiagnosticPacket => ubDiag ¬ ubDiag + 1;	  ENDCASE => other ¬ other + 1;	END;      arpa =>        BEGIN	OPEN collection.arpa;	bb: ArpaBuffer.Body = LOOPHOLE[dll + SIZE[ethernet IEEE8023.EncapObject]];	total ¬ total + 1;	SELECT bb.ipHeader.protocol FROM	  icmp => icmp ¬ icmp + 1;	  interGateway => interGateway ¬ interGateway + 1;	  gmcc => gmcc ¬ gmcc + 1;	  st => st ¬ st + 1;	  tcp => tcp ¬ tcp + 1;	  ucl => ucl ¬ ucl + 1;	  sicure => sicure ¬ sicure + 1;	  bbnRccMon => bbnRccMon ¬ bbnRccMon + 1;	  nvp => nvp ¬ nvp + 1;	  pup => pup ¬ pup + 1;	  pluribus => pluribus ¬ pluribus + 1;	  telnet => telnet ¬ telnet + 1;	  xnet => xnet ¬ xnet + 1;	  chaos => chaos ¬ chaos + 1;	  userDatagram => udp ¬ udp + 1;	  multiplexing => multiplexing ¬ multiplexing + 1;	  dcn => dcn ¬ dcn + 1;	  tacMon => tacMon ¬ tacMon + 1;	  localNetwork => localNetwork ¬ localNetwork + 1;	  satnet => satnet ¬ satnet + 1;	  mitSubnet => mitSubnet ¬ mitSubnet + 1;	  satnetMon => satnetMon ¬ satnetMon + 1;	  ipCoreUtil => ipCoreUtil ¬ ipCoreUtil + 1;	  backroomSatnetMon => backroomSatnetMon ¬ backroomSatnetMon + 1;	  widebandMon => widebandMon ¬ widebandMon + 1;	  widbandExpak => widbandExpak ¬ widbandExpak + 1;	  ENDCASE =>	    BEGIN	    IF (bb.ipHeader.protocol = LOOPHOLE[77]) THEN nd ¬ nd + 1  --Sun's ND	    ELSE other ¬ other + 1;	    END;	END;  --arpa      arp => collection.arp ¬ collection.arp + 1;      ENDCASE => collection.other ¬ collection.other + 1;    END;  --Accumulate  -- Mainline code:    Initialize[];    END.  LOG16-Aug-84  7:38:12   AOF  Post Klamath.20-Sep-86 16:03:40   AOF  New buffer manager.30-Jun-87  9:20:03   AOF  EtherMAC => IEEE8023.26-Apr-88 16:27:58   SMA  Recognition of arpa, ignore badAlignmentButOkCrc.
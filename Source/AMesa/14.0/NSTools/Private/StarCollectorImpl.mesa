-- File: StarCollectorImpl.mesa - last edit:-- AOF                  5-Nov-87 13:47:25-- Copyright (C) 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Buffer USING [Buffer, MakePool, DestroyPool, AccessHandle, Type],  Courier USING [LocalSystemElement],  IEEE8023 USING [Encapsulation],  Driver USING [ChangeNumberOfInputBuffers, Device, GetDeviceChain],  Exec USING [AddCommand, ExecProc, RemoveCommand],  Format USING [StringProc, Decimal, Date, LongNumber, NetworkAddress],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    Enumerated, EnumeratedItem, newLine, ProcType, NumberItem],  Heap USING [Create, Delete],  HostNumbers USING [IsMulticastID],  Inline USING [LongDivMod, BITAND],  Protocol1 USING [SetMaximumBufferSize],  Put USING [Line, Text],  Router USING [FindMyHostID],  Runtime USING [GetBcdTime],  SpecialCommunication USING [SetSpyProc, SpyProc, SpyType],  SpecialSystem USING [HostNumber],  String USING [AppendChar, AppendDecimal, AppendString],  System USING [    nullHostNumber, broadcastHostNumber, HostNumber, GetGreenwichMeanTime,    nullSocketNumber, GreenwichMeanTime, NetworkAddress],  Time USING [Append, Unpack],  Tool USING [    Create, Destroy, MakeFormSW, MakeSWsProc, MakeFileSW, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle],  WSInfoClient USING [GetPilotInfo, GetXDEInfo];  StarCollectorImpl: PROGRAM  IMPORTS    Buffer, Courier, Driver, Exec, SpecialCommunication, Put, FormSW,    Router, Inline, Protocol1, Runtime, String, System, Time, Tool, Heap,    Format, WSInfoClient, HostNumbers, UserInput  EXPORTS Buffer, System =  BEGIN    HostNumber: PUBLIC TYPE = SpecialSystem.HostNumber;  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;      wh: Window.Handle;  tool: LONG POINTER TO ToolData ¬ NIL;  ToolData: TYPE = RECORD[    oldSpy: ARRAY Buffer.Type OF SpecialCommunication.SpyProc ¬ ALL[NIL],    form, log: Window.Handle ¬ NIL,    choice: Choice ¬ relative,    buffers: Buffer.AccessHandle ¬ NIL,    running: BOOLEAN ¬ FALSE,    started, good, broadcasts, full, empty: LONG CARDINAL ¬ 0,    me: HostNumber ¬ NULL, threshold: CARDINAL ¬ 10,    maxEntry, free: EntryHandle ¬ NIL,     table: ARRAY NATURAL[0..(modulo + 1) * 2) OF EntryObject ¬ TRASH];  EntryHandle: TYPE =  LONG POINTER TO EntryObject;  EntryObject: TYPE = RECORD[    host: HostNumber, link: EntryHandle, count: CARDINAL];  Choice: TYPE = {relative, absolute};  unit: CARDINAL = 1;  modulo: NATURAL = 255;  dispatcherBuffers: CARDINAL = 40;  zone: UNCOUNTED ZONE = Heap.Create[100];  null: HostNumber = System.nullHostNumber;  all: HostNumber = System.broadcastHostNumber;  Write: Format.StringProc = {Put.Text[tool.log, s]};    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      Initialize: PROCEDURE =    BEGIN    herald: STRING ¬ [60];    Exec.AddCommand["StarCollector.~"L, NullProc, , Unload];    String.AppendString[to: herald, from: "Star Collector of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 8;  -- omit hours, mins, zone.    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: herald];    END;  NullProc: Exec.ExecProc = {};  Unload: Exec.ExecProc =    BEGIN    IF tool.running THEN {Write["Tool is running\n"L]; RETURN[abort]};    Tool.Destroy[wh];    Exec.RemoveCommand[h, "StarCollector.~"L];    Heap.Delete[zone];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "StarCollector.log"L];    tool.form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm, zone: zone];    tool.log ¬ Tool.MakeFileSW[window: window, name: logName];    END;  Reset: FormSW.ProcType =    BEGIN    tool.good ¬ tool.broadcasts ¬ tool.full ¬ tool.empty ¬ 0;    tool.table ¬ ALL[[null, NIL, 0]];    tool.free ¬ @tool.table[modulo + 1];    tool.maxEntry ¬ @tool.table[((modulo + 1) * 2) - 1];    tool.started ¬ System.GetGreenwichMeanTime[];    Write["Counters reset\n"L];    END;  --Reset  Report: FormSW.ProcType =    BEGIN    h, m, s: CARDINAL;    string: STRING ¬ [80];    perSecond: LONG INTEGER;    d: LONG CARDINAL ¬ System.GetGreenwichMeanTime[];    String.AppendString[string, "Time range: "L];    Time.Append[string, Time.Unpack[[tool.started]]];    String.AppendString[string, " to "L];    Time.Append[string, Time.Unpack[[d]]];    Put.Line[tool.log, string]; string.length ¬ 0;    d ¬ d - tool.started;    String.AppendString[string, "Elpased time: "L];    [h, s] ¬ Inline.LongDivMod[d, 60*60];  --hours    IF h < 10 THEN String.AppendChar[string, '0];    String.AppendDecimal[string, h]; String.AppendChar[string, ':];    [m, s] ¬ Inline.LongDivMod[s, 60];  --minutes    IF m < 10 THEN String.AppendChar[string, '0];    String.AppendDecimal[string, m]; String.AppendChar[string, ':];    IF s < 10 THEN String.AppendChar[string, '0];    String.AppendDecimal[string, s]; Put.Line[tool.log, string];    IF tool.good # 0 THEN      BEGIN      Write["Total directed packets observed: "L];      Format.LongNumber[Write, tool.good, []];      Write["\n"L];      END;    IF tool.broadcasts # 0 THEN      BEGIN      addr: System.NetworkAddress ¬ Courier.LocalSystemElement[];      Write["Number of broadcasts packets: "L];      Format.LongNumber[Write, tool.broadcasts, []];      Write["\n"L];      Put.Text[tool.log, string]; Write[" ("L];      perSecond ¬ (tool.broadcasts * 100) / d;      Format.LongNumber[Write, perSecond / 100, []]; Write["."L];      Format.LongNumber[Write, perSecond MOD 100, [10, TRUE, TRUE, 2]];      Write[" per second)\n"L];      addr.socket ¬ System.nullSocketNumber;      Write["Hosts observed transmitting "L];      Format.Decimal[Write, tool.threshold];      Write[" or more broadcasts packets"L];      IF tool.choice = relative THEN Write[" packets per second"L];      Write["\n"L];      FOR hash: NATURAL IN[0..modulo] DO	entry: EntryHandle ¬ @tool.table[hash];	UNTIL entry.host = null DO	  perSecond ¬ (LONG[entry.count] * 100) /	    (IF tool.choice = relative THEN d ELSE 1);	  IF perSecond > (INT[tool.threshold] * INTEGER[100]) THEN	    BEGIN	    addr.host ¬ entry.host;	    Format.Decimal[Write, entry.count];	    Write[" broadcasts"];	    IF tool.choice = relative THEN	      BEGIN	      Write[" ("L];	      Format.LongNumber[Write, perSecond / 100, []]; Write["."L];	      Format.LongNumber[Write, perSecond MOD 100, [10, TRUE, TRUE, 2]];	      Write[" per second)"L];	      END;	    Write["\n"L]; 	    IF ~HostNumbers.IsMulticastID[@addr.host] THEN WriteInfo[addr]	    ELSE Write["Source is a multicast id\n\n"L];	    IF UserInput.UserAbort[wh] THEN {Write["ABORTED\n"L]; RETURN};	    END;	  IF (entry ¬ entry.link) = NIL THEN EXIT;	  ENDLOOP;	ENDLOOP;      Write["\n"L];      END;    END;  --Report    WriteInfo: PROCEDURE [who: System.NetworkAddress] =    BEGIN    bfVersion: LONG STRING ¬ [6];    sysVolName: LONG STRING ¬ [40];    pVName: LONG STRING ¬ [40];    userName: LONG STRING ¬ [40];    answered, loggedIn: BOOLEAN;    time, timeBooted, bfCreateDate: System.GreenwichMeanTime;        [answered, time, timeBooted, bfCreateDate]  ¬ WSInfoClient.GetPilotInfo[      who, sysVolName, pVName];    IF answered THEN {      Format.NetworkAddress[Write, who, octal]; Write["\n"L];      Write["  Physical volume: "L]; Write[pVName]; Write["\n"L];      Write["  System volume: "L]; Write[sysVolName]; Write["\n"L];      Write["  Processor clock: "L]; Format.Date[Write, time, full]; Write["\n"L];      Write["  Booted on "L]; Format.Date[Write, timeBooted, full]; Write["\n"L];      Write["  Boot file created on "L];        Format.Date[Write, bfCreateDate, full]; Write["\n"L]}    ELSE {      Write["No reply from "L];      Format.NetworkAddress[Write, who, octal];      Write["\n\n"L];      RETURN};        [answered, loggedIn] ¬ WSInfoClient.GetXDEInfo[who, bfVersion, userName];    IF answered THEN {      Write["  Boot file version: "L]; Write[bfVersion]; Write["\n"L];      Write["  User: "L];        Write[userName]; IF loggedIn THEN Write[" (logged in)"L]; Write["\n"L]}    ELSE Write["No XDE information available\n"L];    Write["\n"L];    END;  --WriteInfo  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL = 6;    choices: ARRAY [0..2) OF FormSW.Enumerated ¬ [      ["relative"L, Choice.relative.ORD], ["absolute"L, Choice.absolute.ORD]];    items ¬ FormSW.AllocateItemDescriptor[nItems, zone];    items[0] ¬ FormSW.CommandItem[      tag: "Stop"L, proc: Stop, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "Go"L, proc: Go];    items[2] ¬ FormSW.CommandItem[tag: "Report"L, proc: Report];    items[3] ¬ FormSW.CommandItem[tag: "Reset"L, proc: Reset];    items[4] ¬ FormSW.EnumeratedItem[      tag: "Using"L, choices: DESCRIPTOR[choices], value: @tool.choice, z: zone];    items[5] ¬ FormSW.NumberItem[      tag: "threshold"L, value: @tool.threshold, z: zone];    RETURN[items: items, freeDesc: TRUE];    END;  Stop: FormSW.ProcType =    BEGIN    OPEN tool;    IF running THEN      BEGIN      s: STRING ¬ [40];      running ¬ FALSE;      Buffer.DestroyPool[buffers];      FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	[] ¬ SpecialCommunication.SetSpyProc[NIL, type];	ENDLOOP;      Driver.ChangeNumberOfInputBuffers[FALSE];      FOR device: Device ¬ Driver.GetDeviceChain[], device.next	UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 0];	ENDLOOP;      String.AppendString[s, "Collected stopped at "L];      Time.Append[s, Time.Unpack[]];      Put.Line[log, s];      Report[];      END;    END;        Go: FormSW.ProcType =    BEGIN    OPEN tool;    IF ~running THEN      BEGIN      s: STRING ¬ [40];      me ¬ Router.FindMyHostID[];      running ¬ TRUE;      Reset[];  --set all the counters      String.AppendString[s, "Collected started at "L];      Time.Append[s, Time.Unpack[]];      Put.Line[log, s];      buffers ¬ Buffer.MakePool[dispatcherBuffers, 0];  --get large pool      Driver.ChangeNumberOfInputBuffers[TRUE];      FOR device: Device ¬ Driver.GetDeviceChain[], device.next        UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 1500];	ENDLOOP;      FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	tool.oldSpy[type] ¬ SpecialCommunication.SetSpyProc[SpyProc, type];	ENDLOOP;      END;    END;      ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      (new = inactive) AND (tool # NIL) => {Stop[]; zone.FREE[@tool]};      (old = inactive) AND (tool = NIL) => {tool ¬ zone.NEW[ToolData]; Go[]};      ENDCASE;    END;	  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Worker routines:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SpyProc: SpecialCommunication.SpyProc =   --PROC[b: Buffer.Buffer, function: Buffer.Function] RETURNS[Buffer.Buffer]    BEGIN    e: IEEE8023.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];    SELECT TRUE FROM      (function = send) => NULL;      (b.fo.driver.device # ethernet) => tool.good ¬ SUCC[tool.good];      (e.ethernetDest = all) =>        BEGIN	hash: NATURAL = Inline.BITAND[e.ethernetSource.f, modulo];	entry: EntryHandle ¬ @tool.table[hash];	tool.broadcasts ¬ SUCC[tool.broadcasts];	UNTIL entry.host = e.ethernetSource DO	  SELECT TRUE FROM	    (entry.host = null) =>	      {entry.host ¬ e.ethernetSource; entry.count ¬ 1};	    (entry.link # NIL) => entry ¬ entry.link;	    (tool.free = tool.maxEntry) =>	      {tool.full ¬ SUCC[tool.full]; EXIT};	    ENDCASE =>	      BEGIN	      entry.link ¬ tool.free; entry ¬ tool.free;	      entry.host ¬ e.ethernetSource; entry.count ¬ 1;	      tool.free ¬ tool.free + SIZE[EntryObject];	      EXIT;	      END;	  REPEAT	    FINISHED => entry.count ¬ SUCC[entry.count];	  ENDLOOP;	END;      ENDCASE => tool.good ¬ SUCC[tool.good];    IF tool.oldSpy[b.fo.type] # NIL THEN      {b ¬ tool.oldSpy[b.fo.type][b, function]; IF b = NIL THEN RETURN[NIL]};    RETURN[b];    END;  -- Mainline code:    Initialize[];    END.
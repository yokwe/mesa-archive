-- File: BufferDisplayImpl2.mesa - last edit:-- AOF                  7-Feb-88 13:42:54-- BKI                 25-Jul-88 12:24:47-- Copyright (C) 1984, 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  ArpaBuffer USING [Body],  ArpaTypes USING [InternetAddress],  Buffer USING [Buffer],  BufferDisplay USING [AppendArpaAddress, AppendHeaderPiece, Encapsulation,    FindBufferBodyAndType, Format, LineOverflow, IDPFields, IPFields,    OsiCltpPacket, OsiCotpPacket, OsiIPFields, OutputProc, PacketData,    PacketDataBlock, PupFields],  Environment USING [Byte],  IEEE8023 USING [EthernetPacketType],  ISO8073Types USING [Code],  NSBuffer USING [Body],  NSTypes USING [Byte, bytesPerIDPHeader, bytesPerRoutingHeader,    ConnectionID, ExchangeID, RoutingInfoTuple, PacketType],  NSTypesExtra USING [Control, finishStage, pauseStage, resetStage,    xmtL0, rcvL0, altL0, xmtL1, rcvL1, altL1, errL1, multiL1, echoUser,    echoServer, routingUser, routingServer, errorUser, errorServer, sppConnect,    sppListen, sppSource, sppSink, sppSst, sppAttn, sppDuplex, sppRetrans,    sppOutOfSeq, sppProbing, sppMulti, sppThruput, pexRequestor, pexReplier,    pexReplierThruput, pexRequestorThruput],  OSICLNetworkTypes USING [Body],  PupDefs USING [Body],  String USING [AppendChar, AppendString],  System USING [HostNumber, NetworkNumber];  BufferDisplayImpl2: PROGRAM  IMPORTS BufferDisplay, String  EXPORTS BufferDisplay =  BEGIN    --TYPES    BootType: TYPE = MACHINE DEPENDENT {  -- For display of ether boot packet.    private(0), simpleRequest(1), simpleData(2), streamRequest(3)};  EtherBootingBody: TYPE = MACHINE DEPENDENT RECORD [    type(0): BootType,    fileNumber(1): System.HostNumber,    body(4): SELECT OVERLAID * FROM      simpleRequest => [],      simpleData => [sequence(4): CARDINAL],      streamRequest => [connection(4): CARDINAL],      ENDCASE];  AppendUnknown: PROC[    line: LONG STRING, unknown: UNSPECIFIED, format: BufferDisplay.Format] =    BEGIN    String.AppendString[line, "??("L];    BufferDisplay.AppendHeaderPiece[format, @unknown, 1, line];    String.AppendChar[line, ')];    END;  --AppendUnknown  BodyAssumingEthernet: PROC[b: Buffer.Buffer] RETURNS[ptr: LONG POINTER] =    {[ptr, ] ¬ BufferDisplay.FindBufferBodyAndType [b]};  BootPacket: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc]    RETURNS [data: LONG POINTER] =    BEGIN    body: NSBuffer.Body = BodyAssumingEthernet[b];    boot: LONG POINTER TO EtherBootingBody ¬ LOOPHOLE[@body.nsBody];    String.AppendString[line, "  Boot[type: {"L];    SELECT boot.type FROM      simpleRequest =>        BEGIN        String.AppendString[line, "simpleRequest}"L];        String.AppendString[line, ", file: "L];        BufferDisplay.AppendHeaderPiece[format, @boot.fileNumber, SIZE[System.HostNumber],line];        data ¬ boot + SIZE[BootType] + SIZE[System.HostNumber];        END;      simpleData =>        BEGIN        String.AppendString[line, "simpleData}"L];        String.AppendString[line, ", file: "L];        BufferDisplay.AppendHeaderPiece[format, @boot.fileNumber, SIZE[System.HostNumber],line];        String.AppendString[line, ", sequence: "L];        BufferDisplay.AppendHeaderPiece[format, @boot.sequence, 1, line];        data ¬ boot + SIZE[BootType] + SIZE[System.HostNumber] + SIZE[CARDINAL];        END;      streamRequest =>        BEGIN        String.AppendString[line, "streamRequest}"L];        String.AppendString[line, ", file: "L];        BufferDisplay.AppendHeaderPiece[format, @boot.fileNumber, SIZE[System.HostNumber],line];        String.AppendString[line, ", connection: "L];        BufferDisplay.AppendHeaderPiece[format, @boot.connection, 1, line];        data ¬ boot + SIZE[BootType] + SIZE[System.HostNumber] + SIZE[CARDINAL];        END;      ENDCASE =>         BEGIN	AppendUnknown[line, boot.type, format];	data ¬ boot + SIZE[CARDINAL];        END;    String.AppendChar[line, ']];    outProc[line];    line.length ¬ 0;    END;  -- BootPacket    	    EchoPacket: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    body: NSBuffer.Body = BodyAssumingEthernet[b];    String.AppendString[line, "  Echo[type: {"L];    SELECT body.echoType FROM      echoRequest => String.AppendString[line, "request"L];      echoResponse => String.AppendString[line, "response"L];      ENDCASE => AppendUnknown[line, body.echoType, format];    String.AppendString[line, "}]"L];    outProc[line];    line.length ¬ 0;    END;  -- EchoPacket          ExchangePacket: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    body: NSBuffer.Body = BodyAssumingEthernet[b];    String.AppendString[line, "  PEX[id: "L];    BufferDisplay.AppendHeaderPiece[      format, @body.exchangeID, SIZE[NSTypes.ExchangeID], line];    String.AppendString[line, ", type: "L];    String.AppendString[line, SELECT body.exchangeType FROM      unspecified => "unspecified("L, timeService => "timeService("L,      clearinghouseService => "clearinghouseService("L, teledebug => "teledebug("L,      IN[electronicMailFirstPEType..electronicMailLastPEType] => "mail("L,      IN[remoteDebugFirstPEType..remoteDebugLastPEType] => "remote debug("L,      IN[dixieDataPEType..dixieErrorPEType] => "dixie("L,      ENDCASE => "??("L];    BufferDisplay.AppendHeaderPiece[format, @body.exchangeType, 1, line];    String.AppendString[line, ")]"L];    outProc[line];    line.length ¬ 0;    END;  -- ExchangePacket         ErrPacket: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN  -- Displays the level 2 portion of an error packet.    body: NSBuffer.Body = BodyAssumingEthernet[b];    String.AppendString[line, "  Error["L];    SELECT body.errorType FROM        unspecified =>          String.AppendString[line, "unspecified"L];        badChecksum =>          String.AppendString[line, "badChecksum"L];        noSocket =>          String.AppendString[line, "noSocket"L];        resourceLimits =>          String.AppendString[line, "resourceLimits"L];        ENDCASE => AppendUnknown[line, body.errorType, format];    String.AppendString[line, ", "L];    BufferDisplay.AppendHeaderPiece[format, @body.errorParameter, 1, line];    String.AppendChar[line, ']];    outProc[line];    line.length ¬ 0;     END;  -- ErrPacket        ICMPPacket: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN  << Displays the level 2 portion of an arpa ICMP packet.  This can be              cleaned up a lot when the varient record in ArpaTypes is made	      overlaid. >>    byteData: RECORD [filler, data: Environment.Byte];    p: LONG ORDERED POINTER;    body: ArpaBuffer.Body = BodyAssumingEthernet[b];        CAndC: PROC =      BEGIN  --Displays code and checksum, which is in same place in every icmp.      checksum: WORD ¬ body.ipWords[1];      byteData ¬ [0, body.ipBytes[1]];  --that's the code.      String.AppendString[line, ", code: "L];      BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];      String.AppendString[line, ", checksum: "L];      BufferDisplay.AppendHeaderPiece[format, @checksum, 1, line];      END;  --CAndC          String.AppendString[line, "  ICMP["L];    SELECT body.icmp.type FROM      unreachable =>        BEGIN	String.AppendString[line, "unreachable["];	CAndC[];	String.AppendString[line, ", unused: "L];	p ¬ LOOPHOLE[@body.ipWords + 2];	BufferDisplay.AppendHeaderPiece[format, @p, 2, line];	String.AppendString[line, ", data: "L];	p ¬ LOOPHOLE[@body.ipWords + 4];	BufferDisplay.PacketData[format, b, @p, line, outProc];	END;  --unreachable	      timeExceeded =>        BEGIN	String.AppendString[line, "timeExceeded["];	CAndC[];	String.AppendString[line, ", unused: "L];	p ¬ LOOPHOLE[@body.ipWords + 2];	BufferDisplay.AppendHeaderPiece[format, @p, 2, line];	String.AppendString[line, ", data: "L];	p ¬ LOOPHOLE[@body.ipWords + 4];	BufferDisplay.PacketData[format, b, @p, line, outProc];	END;  --timeExceeded	      paramProblem =>        BEGIN	String.AppendString[line, "paramProblem["];	CAndC[];	String.AppendString[line, ", ptr: "L];	byteData ¬ [0, body.ipBytes[4]];	BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];	String.AppendString[line, ", data: "L];	p ¬ LOOPHOLE[@body.ipWords + 4];	BufferDisplay.PacketData[format, b, @p, line, outProc];        END;  --paramProblem	      quench =>        BEGIN	String.AppendString[line, "quench["];	CAndC[];	String.AppendString[line, ", unused: "L];	p ¬ LOOPHOLE[@body.ipWords + 2];	BufferDisplay.AppendHeaderPiece[format, @p, 2, line];	String.AppendString[line, ", data: "L];	p ¬ LOOPHOLE[@body.ipWords + 4];	BufferDisplay.PacketData[format, b, @p, line, outProc];	END;  --quench	      redirect =>        BEGIN	a: LONG ORDERED POINTER TO ArpaTypes.InternetAddress ¬	   LOOPHOLE[@body.ipWords + 2];	String.AppendString[line, "redirect["];	CAndC[];	String.AppendString[line, ", unused: "L];	String.AppendString[line, ", redirect: "L];	BufferDisplay.AppendArpaAddress[decimal, line, a­];	p ¬ LOOPHOLE[@body.ipWords + 4];	BufferDisplay.PacketData[format, b, @p, line, outProc];	END;  --redirect	      echo, echoReply =>        BEGIN	String.AppendString[line,	  IF body.icmp.type = echo THEN "echo["L ELSE "echoReply["L];	CAndC[];	String.AppendString[line, ", id: "L];	byteData ¬ [0, body.ipBytes[4]];	BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];	String.AppendString[line, ", seq: "L];	byteData ¬ [0, body.ipBytes[5]];	BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];	p ¬ LOOPHOLE[@body.ipWords + 4];	BufferDisplay.PacketData[format, b, @p, line, outProc];	END;  --echo, echoReply	      timestamp, timestampReply =>        BEGIN	String.AppendString[line,	  IF body.icmp.type = timestamp THEN "timestamp["L	  ELSE "timestampReply["L];	CAndC[];        String.AppendString[line, ", id: "L];	byteData ¬ [0, body.ipBytes[4]];	BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];	String.AppendString[line, ", seq: "L];	byteData ¬ [0, body.ipBytes[5]];	BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];	String.AppendString[line, ", orig: "L];	p ¬ LOOPHOLE[@body.ipWords + 4];	BufferDisplay.AppendHeaderPiece[format, @p, 2, line];	String.AppendString[line, ", rec: "L];	p ¬ LOOPHOLE[@body.ipWords + 6];	BufferDisplay.AppendHeaderPiece[format, @p, 2, line];	String.AppendString[line, ", trans: "L];	p ¬ LOOPHOLE[@body.ipWords + 8];	BufferDisplay.AppendHeaderPiece[format, @p, 2, line];	END;  --timestamp, timestampReply	      infoRequest, infoReply =>        BEGIN	String.AppendString[line,	  IF body.icmp.type = infoReply THEN "infoReply["L	  ELSE "infoRequest["L];	CAndC[];	String.AppendString[line, ", id: "L];	byteData ¬ [0, body.ipBytes[4]];	BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];	String.AppendString[line, ", seq: "L];	byteData ¬ [0, body.ipBytes[5]];	p ¬ LOOPHOLE[@body.ipWords + 4];	BufferDisplay.PacketData[format, b, @p, line, outProc];	END;	      ENDCASE =>         BEGIN	p ¬ LOOPHOLE[@body.ipWords + 4];	BufferDisplay.PacketData[format, b, @p, line, outProc];	END;    END;  --ICMPPacket      Level2Packet: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    <<    Displays level 2 packet (all levels of headers formatted).    for when we don't want the line printed.    >>    ENABLE BufferDisplay.LineOverflow =>      {String.AppendString[line, " ..."L];      outProc[line]; line.length ¬ 0; GOTO exit};    fakeOutput: BufferDisplay.OutputProc = {};    l1Type: IEEE8023.EthernetPacketType;    BufferDisplay.Encapsulation[b, line, format, fakeOutput];    [ ,l1Type] ¬ BufferDisplay.FindBufferBodyAndType [b];    SELECT l1Type FROM      ns =>        BEGIN        body: NSBuffer.Body = BodyAssumingEthernet[b];        BufferDisplay.IDPFields[b, line, format, fakeOutput];        SELECT body.packetType FROM          routingInformation =>	    {RoutingPacket[b, line, format, fakeOutput];	    RoutingData[b, line, format, outProc]};	  echo =>	    {EchoPacket[b, line, format, fakeOutput];	    BufferDisplay.PacketData[	      format, b, @body.echoBody, line, outProc]};	  error => 	    {ErrPacket[b, line, format, fakeOutput];	    BufferDisplay.PacketData[	      format, b, @body.errorBody, line, outProc]};	  packetExchange =>	    {ExchangePacket[b, line, format, fakeOutput];	    BufferDisplay.PacketData[	      format, b, @body.exchangeBody, line, outProc]};	  sequencedPacket =>	    IF SppPacket[TRUE, b, line, format, fakeOutput] THEN	      {BufferDisplay.PacketData[	        format, b, @body.sppBody, line, outProc]};	  bootServerPacket =>	    {beginData: LONG POINTER ¬ BootPacket[b, line, format,	      fakeOutput];	    BufferDisplay.PacketData[format, b, beginData, line, outProc]};	  pccPacket =>	    PccPacket[b, line, format, outProc];	  ubIPCPacket =>	    {UBIPCPacket[b, line, format, outProc];	    SELECT body.nsWords[0] FROM	      2 => BufferDisplay.PacketData[	        format, b, @body.nsWords[11], line, outProc];	      3 => BufferDisplay.PacketData[	        format, b, @body.nsWords[6], line, outProc];	      6 => BufferDisplay.PacketData[	        format, b, @body.nsWords[31], line, outProc];	      ENDCASE =>	        BufferDisplay.PacketData[	          format, b, @body.nsWords[6], line, outProc]};	  ENDCASE =>  -- unknown level 2 type.    	BufferDisplay.PacketData[format, b, @body.nsWords, line, outProc];        END;  -- ns      pup, newpup =>        BEGIN        body: PupDefs.Body = BodyAssumingEthernet[b];        BufferDisplay.PupFields[b, line, format, fakeOutput];        BufferDisplay.PacketData[format, b, @body.pupWords, line, outProc];        END;  -- pup      arpa =>        BEGIN        body: ArpaBuffer.Body = BodyAssumingEthernet[b];        BufferDisplay.IPFields[b, line, format, fakeOutput];        SELECT body.ipHeader.protocol FROM	  tcp =>	    {TCPPacket[b, line, format, fakeOutput];	    BufferDisplay.PacketData[	      format, b, @body.tcp.bytes, line, outProc]};	  userDatagram =>	    {UDPPacket[b, line, format, fakeOutput];	    BufferDisplay.PacketData[	      format, b, @body.user.bytes, line, outProc]};	  icmp =>	    ICMPPacket[b, line, format, outProc];          ENDCASE =>  -- unknown level 2 type.	    BufferDisplay.PacketData[	      format, b, @body.ipWords, line, outProc]        END;  -- arpa      osi =>        BEGIN        body: OSICLNetworkTypes.Body = BodyAssumingEthernet[b];        bytePtr: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte =          LOOPHOLE[body];        BufferDisplay.OsiIPFields[b, line, format, fakeOutput];	IF body.ip.protocolID = standard AND body.ip.type = data THEN	  BEGIN	  SecondOctet: TYPE = MACHINE DEPENDENT RECORD[	    code(0:0..3): ISO8073Types.Code,	    dontCare(0:4..7): [0..0)];	  dataOffset: CARDINAL;	  tpduOffset: CARDINAL = body.ip.initialHeaderLength + 1;          SELECT LOOPHOLE[bytePtr[tpduOffset+1], SecondOctet].code FROM            ed, ea, rj, ak, er, dr, dc, cc, cr, dt => {               BufferDisplay.OsiCotpPacket[b, line, format, fakeOutput];	      dataOffset ¬ tpduOffset + bytePtr[tpduOffset] + 1;	      BufferDisplay.PacketDataBlock[	        format, b, [bytePtr, dataOffset, 0],	        line, outProc]};            ud => {               BufferDisplay.OsiCltpPacket[b, line, format, fakeOutput];              BufferDisplay.PacketDataBlock[                format, b, [bytePtr, tpduOffset, 0], line, outProc]};            ENDCASE =>              BufferDisplay.PacketDataBlock[                format, b, [bytePtr, tpduOffset, 0], line, outProc];	  END;	END;      ENDCASE =>  -- unknown level 1 type.        BufferDisplay.PacketData[	  format, b, b.highLayer.blockPointer, line, outProc];    <<    There's something wrong here. l1Type = osi is already picked off    in the SELECT statement above. This causes the block to be displayed twice.    IF l1Type = osi    THEN BufferDisplay.PacketDataBlock           [format, b, [b.highLayer.blockPointer, 1, 0], line, outProc]    ELSE BufferDisplay.PacketData           [format, b, b.highLayer.blockPointer, line, outProc];    >>    EXITS exit => NULL;    END;  -- Level2Packet             PccPacket: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN OPEN NSTypesExtra;    pc: Control ¬ BodyAssumingEthernet[b];    String.AppendString[line, "  Pcc[operation: "L];    SELECT pc.operation FROM      request => String.AppendString[line, "{request"L];      reply => String.AppendString[line, "{reply"L];      reject => String.AppendString[line, "{reject"L];      end => String.AppendString[line, "{end"L];      ENDCASE => {        String.AppendString[line, " ??("L];        BufferDisplay.AppendHeaderPiece[format, @pc.stage, 2, line];        String.AppendString[line, ")"L]};    String.AppendString[line, "}, suggested stage: "L];    SELECT pc.stage FROM      xmtL0 => String.AppendString[line, " xmtL0"L];      rcvL0 => String.AppendString[line, " rcvL0"L];      altL0 => String.AppendString[line, " altL0"L];      xmtL1 => String.AppendString[line, " xmtL1"L];      rcvL1 => String.AppendString[line, " rcvL1"L];       altL1 => String.AppendString[line, " altL1"L];      errL1 => String.AppendString[line, " errL1"L];      multiL1 => String.AppendString[line, " multiL1"L];      echoUser => String.AppendString[line, " echoUser"L];      echoServer => String.AppendString[line, " echoServer"L];      routingUser => String.AppendString[line, " routingUser"L];      routingServer => String.AppendString[line, " routingServer"L];      errorUser => String.AppendString[line, " errorUser"L];      errorServer => String.AppendString[line, " errorServer"L];      sppConnect => String.AppendString[line, " sppConnect"L];      sppListen => String.AppendString[line, " sppListen"L];      sppSource => String.AppendString[line, " sppSource"L];      sppSink => String.AppendString[line, " sppSink"L];      sppSst => String.AppendString[line, " sppSst"L];      sppAttn => String.AppendString[line, " sppAttn"L];      sppDuplex => String.AppendString[line, " sppDuplex"L];      sppRetrans => String.AppendString[line, " sppRetrans"L];      sppOutOfSeq => String.AppendString[line, " sppOutOfSeq"L];      sppProbing => String.AppendString[line, " sppProbing"L];      sppMulti => String.AppendString[line, " sppMulti"L];      sppThruput => String.AppendString[line, " sppThruput"L];      pexRequestor => String.AppendString[line, " pexRequestor"L];      pexReplier => String.AppendString[line, " pexReplier"L];      pexReplierThruput => String.AppendString[line, " pexReplierThruput"L];      pexRequestorThruput => String.AppendString[line, " pexRequestorThruput"L];      finishStage => String.AppendString[line, " finishStage"L];      pauseStage => String.AppendString[line, " pauseStage"L];      resetStage => String.AppendString[line, " resetStage"L];      ENDCASE => {        String.AppendString[line, " ??("L];        BufferDisplay.AppendHeaderPiece[format, @pc.stage, 2, line];        String.AppendString[line, ")"L]};    IF pc.operation = reply THEN      BEGIN      String.AppendString[line, ", result: "L];      BufferDisplay.AppendHeaderPiece[format, @pc.results, 1, line];      END;          String.AppendString[line, "]"L];    outProc[line];    line.length ¬ 0;    END;  -- PccPacket       RoutingData: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    body: NSBuffer.Body = BodyAssumingEthernet[b];    infoLen: INTEGER ¬ body.pktLength - NSTypes.bytesPerRoutingHeader -    NSTypes.bytesPerIDPHeader;    String.AppendString[line, "  "L];    FOR tuple: INTEGER IN[0..infoLen/(2*SIZE[NSTypes.RoutingInfoTuple])) DO      String.AppendString[line, " [net: "L];      BufferDisplay.AppendHeaderPiece[format,        @body.routingTuple[tuple].objectNetID, SIZE[System.NetworkNumber], line];      String.AppendString[line, ", delay: "L];      BufferDisplay.AppendHeaderPiece[format,        @body.routingTuple[tuple].interrouterDelay, 1, line];      String.AppendChar[line, ']];      IF line.length > line.maxlength - 35 THEN SIGNAL BufferDisplay.LineOverflow;      ENDLOOP;    outProc[line];    line.length ¬ 0;    END;  -- RoutingData          RoutingPacket: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    body: NSBuffer.Body = BodyAssumingEthernet[b];    String.AppendString[line, "  Routing[type: {"L];    SELECT body.routingType FROM      routingInfoRequest => String.AppendString[line, "request"L];      routingInfoResponse => String.AppendString[line, "response"L];      ENDCASE => AppendUnknown[line, body.routingType, format];    String.AppendString[line, "}]"L];    outProc[line];    line.length ¬ 0;    END;  -- RoutingPacket          SppPacket: PUBLIC PROC [sysPkts: BOOLEAN, b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc]    RETURNS [data: BOOLEAN] =    BEGIN    body: NSBuffer.Body = BodyAssumingEthernet[b];    sst: RECORD[filler: Environment.Byte, s: NSTypes.Byte] ¬ [        0, body.subtype];    data ¬ ~body.systemPacket OR (body.unusedType = 4H);    IF body.systemPacket AND ~sysPkts THEN RETURN;  --only data packets    String.AppendString[line, "  SPP["L];    IF body.systemPacket THEN String.AppendString[line, "sys, "L];    IF body.sendAck THEN String.AppendString[line, "ackReq, "L];    IF body.attention THEN String.AppendString[line, "attn, "L];    IF body.endOfMessage THEN String.AppendString[line, "eom, "L];    IF (body.unusedType = 8H) THEN String.AppendString[line, "neg, "L];    IF (body.unusedType = 4H) THEN String.AppendString[line, "param, "L];    String.AppendString[line, "sst["L];    BufferDisplay.AppendHeaderPiece[format, @sst, 1, line];    String.AppendString[line, "], connIDs["L];    BufferDisplay.AppendHeaderPiece[      format, @body.destinationConnectionID, 1, line];    String.AppendString[line, " ¬ "L];    BufferDisplay.AppendHeaderPiece[format, @body.sourceConnectionID, 1, line];    String.AppendString[line, "], seq#s["L];    BufferDisplay.AppendHeaderPiece[format, @body.sequenceNumber, 1, line];    String.AppendString[line, ", "L];    BufferDisplay.AppendHeaderPiece[format, @body.acknowledgeNumber, 1, line];    String.AppendString[line, ", "L];    BufferDisplay.AppendHeaderPiece[format, @body.allocationNumber, 1, line];    String.AppendString[line, "]]"L];    outProc[line];    line.length ¬ 0;    END;  -- SppPacket          TCPPacket: PUBLIC PROC[b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    body: ArpaBuffer.Body = BodyAssumingEthernet[b];    {OPEN tcp: body.tcp;    byteData: RECORD [filler, data: Environment.Byte];    String.AppendString[line, "  TCP["L];    BufferDisplay.AppendHeaderPiece[format, @tcp.destinationPort, 1, line];    String.AppendString[line, " ¬ "L];    BufferDisplay.AppendHeaderPiece[format, @tcp.sourcePort, 1, line];    String.AppendString[line, ", seq#s["L];    BufferDisplay.AppendHeaderPiece[format, @tcp.sequence, 2, line];    String.AppendString[line, ", "L];    BufferDisplay.AppendHeaderPiece[format, @tcp.acknowledgement, 2, line];    String.AppendString[line, ", "L];    BufferDisplay.AppendHeaderPiece[format, @tcp.window, 1, line];    String.AppendString[line, "], offset: "L];    byteData ¬ [0, LOOPHOLE[tcp.dataOffset]];    BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];    String.AppendString[line, ", reserve: "L];    byteData ¬ [0, LOOPHOLE[tcp.reserved]];    BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];    IF tcp.urg THEN String.AppendString[line, ", urg"L];    IF tcp.ack THEN String.AppendString[line, ", ack"L];    IF tcp.psh THEN String.AppendString[line, ", psh"L];    IF tcp.rst THEN String.AppendString[line, ", rst"L];    IF tcp.syn THEN String.AppendString[line, ", syn"L];    IF tcp.fin THEN String.AppendString[line, ", fin"L];    String.AppendString[line, ", checksum: "L];    BufferDisplay.AppendHeaderPiece[format, @tcp.checksum, 1, line];    String.AppendString[line, ", urgPtr: "L];    BufferDisplay.AppendHeaderPiece[format, @tcp.urgentPointer, 1, line];    String.AppendString[line, "]"L];    outProc[line];    line.length ¬ 0};    END;  --TCPPacket          UBIPCPacket: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    body: NSBuffer.Body = BodyAssumingEthernet[b];    byteData: RECORD[filler: Environment.Byte, d: Environment.Byte];    pidString: STRING ¬ [12];        TranslatePid: PROC [index: CARDINAL] =      BEGIN      pidString.length ¬ 0;      SELECT body.nsWords[index] FROM        2 => String.AppendString[pidString, "rpPID)"L];	3 => String.AppendString[pidString, "examPID)"L];	6 => String.AppendString[pidString, "nluPID)"L];	ENDCASE => AppendUnknown[pidString, body.nsWords[index], format];      END;  -- TranslatePid          String.AppendString[line, "  ubIPC[dstPID: "L];    TranslatePid[0];    String.AppendString[line, pidString];    String.AppendString[line, ", srcPID: "L];    TranslatePid[1];    String.AppendString[line, pidString];    String.AppendString[line, ", accessKey: "L];    BufferDisplay.AppendHeaderPiece[format, @body.nsWords[2], 2, line];    String.AppendString[line, ", dstIPCPort: "L];    byteData ¬ [0, body.nsBytes[8]];    BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];    String.AppendString[line, ", srcIPCPort: "L];    byteData ¬ [0, body.nsBytes[9]];    BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];    String.AppendString[line, ", messageID: "L];    byteData ¬ [0, body.nsBytes[10]];    BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];    String.AppendString[line, ", ipcLength: "L];    byteData ¬ [0, body.nsBytes[11]];    BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];    String.AppendString[line, ", version: "L];    byteData ¬ [0, body.nsBytes[12]];    BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];    String.AppendString[line, "]"L];    outProc[line];    line.length ¬ 0;    --now one of the three protocol bodies.    SELECT body.nsWords[0] FROM      2 =>         BEGIN	String.AppendString[line, "    rendezvous[op: "L];	SELECT body.nsBytes[13] FROM	  1 => String.AppendString[line, "hello"L];	  2 => String.AppendString[line, "localOpen"L];	  3 => String.AppendString[line, "remoteSetup"L];	  4 => String.AppendString[line, "remoteBind"L];	  5 => String.AppendString[line, "remoteOpen"L];	  6 => String.AppendString[line, "spoil"L];	  7 => String.AppendString[line, "close"L];	  8 => String.AppendString[line, "goodbye"L];	  LAST[Environment.Byte] => String.AppendString[line, "makeAByte"L];	  ENDCASE => AppendUnknown[line, body.nsBytes[13], format];	String.AppendString[line, ", resp: "L];	SELECT body.nsBytes[14] FROM	  55 => String.AppendString[line, "badDeviceID"L];	  56 => String.AppendString[line, "invalidReq"L];	  58 => String.AppendString[line, "tooManyConn"L];	  60 => String.AppendString[line, "invalidConnInfo"L];	  314 => String.AppendString[line, "helloReject"L];	  LAST[Environment.Byte] => String.AppendString[line, "success"L];	  ENDCASE  => AppendUnknown[line, body.nsBytes[14], format];	String.AppendString[line, ", seq: "L];	byteData ¬ [0, body.nsBytes[15]];	BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];	String.AppendString[line, ", convers: "L];	byteData ¬ [0, body.nsBytes[16]];	BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];	String.AppendString[line, "]"L];   -- we aint interested in the rest.	END;  -- rendezvous      3 =>        BEGIN  -- we aint interested at all.        String.AppendString[line, "    examine"L];	END;  -- examine      6 =>         BEGIN	String.AppendString[line, "    nameLookup[op: "L];	SELECT body.nsBytes[13] FROM	  1 => String.AppendString[line, "nameLookup"L];	  2 => String.AppendString[line, "genericLookup"L];	  3 => String.AppendString[line, "idLookup"L];	  LAST[Environment.Byte] => String.AppendString[line, "makeAByte"L];	  ENDCASE => AppendUnknown[line, body.nsBytes[13], format];        String.AppendString[line, ", resp: "L];	SELECT body.nsBytes[14] FROM	  314B => String.AppendString[line, "noKthName"L];	  LAST[Environment.Byte] => String.AppendString[line, "success"L];	  ENDCASE => AppendUnknown[line, body.nsBytes[14], format];	String.AppendString[line, ", seq: "L];	byteData ¬ [0, body.nsBytes[15]];	BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];        String.AppendString[line, ", param: "L];	byteData ¬ [0, body.nsBytes[16]];	BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];	-- alignment byte here.	String.AppendString[line, ", key: "L];        BufferDisplay.AppendHeaderPiece[format, @body.nsWords[9], 1, line];	String.AppendString[line, ", net: "L];        BufferDisplay.AppendHeaderPiece[format, @body.nsWords[10], 2, line];        String.AppendString[line, ", host: "L];	BufferDisplay.AppendHeaderPiece[format, @body.nsWords[12], 3, line];	String.AppendString[line, ", device: "L];	BufferDisplay.AppendHeaderPiece[format, @body.nsWords[15], 3, line];	String.AppendString[line, ", string: "L];	BufferDisplay.AppendHeaderPiece[format, @body.nsWords[17], 1, line];	END;  -- nameLookup      ENDCASE;    outProc[line];    line.length ¬ 0;    END;  -- UBIPCPacket          UDPPacket: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    body: ArpaBuffer.Body = BodyAssumingEthernet[b];    {OPEN udp: body.user;    String.AppendString[line, "  UDP["L];    BufferDisplay.AppendHeaderPiece[format, @udp.destinationPort, 1, line];    String.AppendString[line, " ¬ "L];    BufferDisplay.AppendHeaderPiece[format, @udp.sourcePort, 1, line];    String.AppendString[line, ", len: "L];    BufferDisplay.AppendHeaderPiece[format, @udp.length, 1, line];    String.AppendString[line, ", checksum: "L];    BufferDisplay.AppendHeaderPiece[format, @udp.checksum, 1, line];    String.AppendString[line, "]"L];    outProc[line];    line.length ¬ 0};    END;  --UDPPacket   END..  LOG 7-Sep-84 10:55:53  SMA  Created file from BufferDisplayImpl. 8-Oct-84 14:36:28  SMA  Post-Klamath communications.25-Oct-84 15:05:21  SMA  Added message exchange.28-Feb-85 17:43:05  SMA  Added arpa stuff. 6-Jun-85 14:23:52  SMA  Fixed tcp display. 9-Oct-85 15:05:41  SMA  Set line.length to 0 after calling outProc.25-Nov-86  9:40:56  AOF  New buffer management.23-Jun-87 18:40:06  BKI  Convert to new OSI definitions.28-Jun-87 13:30:18  AOF  Change EtherMAC => IEEE8023.17-Jul-87 18:50:36  BKI  OSITransportTypes ¬ ISO8073Types.17-Aug-87 17:46:36  BKI  Display OSI NPDU data field only if it exists.30-Aug-87 16:33:52  AOF  Calling PacketData with proper start address.15-Apr-88 22:30:09  BKI  Support odd-byte-aligned TPDU.25-Jul-88 12:24:47  BKI  AppendArpaAddress[format: decimal].
-- File: TimeFilter.mesa - last edit:-- AOF                  3-Nov-87 10:24:20-- BKI                 24-Jun-87 12:31:01-- Copyright (C) 1983, 1984, 1985, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Buffer USING [Buffer, BufferObject],  BufferDisplay USING [AppendHeaderPiece, AppendNSAddress, Format],  Environment USING [Block, nullBlock],  Flipper USING [ClearCounts, Create, Disable, Enable, Enumerated,    EnumeratedDescriptor],   Format USING [HostNumber, NetworkNumber, StringProc],  FormSW USING [AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    line0, line1, NotifyProcType],  MataHariInternal USING[z],  NSTypes,  Process USING [Pause, priorityNormal, SecondsToTicks],  Router USING [AssignAddress],  Runtime USING [GetBcdTime],  SpecialSpy USING [DisplayProc, Mode, SetNSSpyTrigger, SetStateChangeProcs,    StartProc, TriggerProc],  String USING [AppendChar, AppendString],  System USING [NetworkAddress],  Time USING [Append, Unpack],  TimeServerFormat USING [TSPacket, WireLong, WireToGMT],  Tool USING [Create, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  Version USING [Append],  Window USING [Handle];  TimeFilter: PROGRAM  IMPORTS BufferDisplay,Flipper, Format, FormSW, Process, Router, Runtime,  SpecialSpy, String, Time, TimeServerFormat, Tool, Version, MataHariInternal =  BEGIN    flipperCnt: CARDINAL = 1;    pktFlp: LONG CARDINAL ¬ 0;  flipItems: Flipper.EnumeratedDescriptor ¬ DESCRIPTOR[flipItemsArray];  flipItemsArray: ARRAY [0..flipperCnt) OF Flipper.Enumerated ¬[    ["packets"L, @pktFlp]];     -- TYPES    DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    formSW(0): Window.Handle ¬ NIL,    flipperSW(2): Window.Handle ¬ NIL,    timeFields(4): BOOLEAN ¬ TRUE,    flippers(5): BOOLEAN ¬ TRUE];      -- VARIABLES and CONSTANTS    globalLine: LONG STRING ¬ NIL;  tool: DataHandle ¬ NIL;  displayWidth: CARDINAL = 250;         -- minimum length of display line.  displayFormat: BufferDisplay.Format;  -- From the SetNSSpyTrigger call.  timeFields: BOOLEAN ¬ FALSE;          -- snapshot of the tool parameter.  wh: Window.Handle;                    -- our window.    -- PROCEDURES    ClientTransition: ToolWindow.TransitionProcType =     BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        IF tool = NIL THEN tool ¬ MataHariInternal.z.NEW[Data ¬ []];	SpecialSpy.SetStateChangeProcs[Start, Stop];	END;      new = inactive =>        BEGIN	SpecialSpy.SetStateChangeProcs[NIL, NIL];	Stop[];        IF tool # NIL THEN MataHariInternal.z.FREE[@tool];        END;      ENDCASE;    END;  -- ClientTransition          DisplayTimePkt: PROC [b: Buffer.Buffer, line: LONG STRING]    RETURNS [Environment.Block] =    -- Displays a time service packet.    BEGIN OPEN BufferDisplay;    np: LONG POINTER TO NSTypes.BufferBody =      LOOPHOLE[b.linkLayer.blockPointer];    tb: LONG POINTER TO TimeServerFormat.TSPacket ¬      LOOPHOLE[@np.exchangeWords];        String.AppendString[line, "  time[version: "L];    AppendHeaderPiece[displayFormat, @tb.version, 1, line];    WITH t: tb SELECT FROM      timeRequest =>        String.AppendString[line, ", type: timeRequest"L];      timeResponse =>        BEGIN	String.AppendString[line, ", type: timeResponse[time: "L];	Time.Append[line, Time.Unpack[TimeServerFormat.WireToGMT[t.time]]];	String.AppendString[line, ", zoneS: "L];	String.AppendString[line, SELECT t.zoneS FROM	                            west => "west"L,	                            ENDCASE => "east"L];	String.AppendString[line, ", zoneH: "L];	AppendHeaderPiece[displayFormat, @t.zoneH, 1, line];	String.AppendString[line, ", zoneM: "L];	AppendHeaderPiece[displayFormat, @t.zoneM, 1, line];	String.AppendString[line, ", beginDST: "L];	AppendHeaderPiece[displayFormat, @t.beginDST, 1, line];	String.AppendString[line, ", endDST: "L];	AppendHeaderPiece[displayFormat, @t.endDST, 1, line];	IF t.errorAccurate THEN String.AppendString[line, ", errAcc"L];	String.AppendString[line, ", absErr: "L];	AppendHeaderPiece[	  displayFormat, @t.absoluteError, SIZE[TimeServerFormat.WireLong], line];	String.AppendString[line, "]"L];	END;      statisticRequest =>         String.AppendString[line, ", type: statRequest"L];      statisticResponse =>        BEGIN	String.AppendString[line, ", type: statisticResponse[number: "L];	AppendHeaderPiece[displayFormat, @t.numberRequests,	  SIZE[TimeServerFormat.WireLong], line];	IF t.active THEN String.AppendString[line, ", active"L];	IF t.resetting THEN String.AppendString[line, ", resetting"L];	String.AppendString[line, ", timeSet: "L];	Time.Append[line, Time.Unpack[TimeServerFormat.WireToGMT[t.timeSet]]];	String.AppendString[line, ", lastChange: "L];	AppendHeaderPiece[displayFormat, @t.lastChange,	  SIZE[TimeServerFormat.WireLong], line];	String.AppendString[line, ", source: "L];	AppendNSAddress[displayFormat, line, t.source];	String.AppendString[line, "]"L];	END;      startRequest =>         String.AppendString[line, ", type: startRequest"L];      startResponse =>        String.AppendString[line, ", type: startResponse"L];      stopRequest =>        String.AppendString[line, ", type: stopRequest"L];      stopResponse =>        String.AppendString[line, ", type: stopResponse"L];      resetRequest =>        BEGIN	String.AppendString[line, ", type: resetRequest[timeSrc: "L];	AppendNSAddress[displayFormat, line, t.timeSource];	String.AppendString[line, "]"L];	END;      resetResponse =>        String.AppendString[line, ", type: resetResponse"L];      internalTimeRequest =>        String.AppendString[line, ", type: internalRequest"L];      internalTimeResponse =>        BEGIN	String.AppendString[line, ", type: internalResponse[time: "L];	Time.Append[line, Time.Unpack[TimeServerFormat.WireToGMT[t.time]]];	String.AppendString[line, ", absErr: "L];	AppendHeaderPiece[displayFormat, @t.absoluteError,	  SIZE[TimeServerFormat.WireLong], line];	String.AppendString[line, ", timeVersion: "L];	AppendHeaderPiece[displayFormat, @t.timeVersion,          SIZE[TimeServerFormat.WireLong], line];	String.AppendString[line, "]"L];	END;      noteNewVersion =>        BEGIN	String.AppendString[line, ", type: noteNewVersion[timeVersion: "L];	AppendHeaderPiece[displayFormat, @t.timeVersion,	  SIZE[TimeServerFormat.WireLong], line];	END;      ENDCASE;   String.AppendString[line, "]"L];   IF timeFields THEN SpecialSpy.DisplayProc[line];   line.length ¬ 0;   RETURN[Environment.nullBlock];   END;  -- DisplayTimePkt        TimeSpy: SpecialSpy.TriggerProc =    BEGIN  -- The filtering proc which gets called by the NSSpyTool.    np: LONG POINTER TO NSTypes.BufferBody =      LOOPHOLE[b.linkLayer.blockPointer];    newDataPtr ¬ oldDataPtr;    save ¬ FALSE;        --Test for possible time pkt.  We need to test in both collect and display    --mode because who knows what other filters are running.    IF (np.packetType = packetExchange) AND      (np.exchangeType = timeService) THEN      SELECT mode FROM        display => IF timeFields THEN newDataPtr ¬ DisplayTimePkt[b, globalLine];	collect => {pktFlp ¬ pktFlp + 1; save ¬ TRUE};	ENDCASE;    END;  -- TimeSpy        Init: PROCEDURE =    BEGIN    lnA: System.NetworkAddress ¬ Router.AssignAddress[];    stringProc: Format.StringProc = {String.AppendString[name, s]};    name: STRING ¬ [120];    String.AppendString[name, "TimeFilter "L];    Version.Append[name];    String.AppendString[name, " of "L];    Time.Append[name, Time.Unpack[Runtime.GetBcdTime[]]];    String.AppendString[name, " running on "L];     Format.NetworkNumber[stringProc, lnA.net, octal];    String.AppendChar[name, '.];    Format.HostNumber[stringProc, lnA.host, octal];    String.AppendChar[name, '.];    tool ¬ MataHariInternal.z.NEW[Data ¬ []];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: active,      initialBox: [place: [x: 800, y: 500], dims: [w: 300, h: 200]],      clientTransition: ClientTransition, name: name,      cmSection: "TimeFilter"L, tinyName1: "Time"L,        tinyName2: "Filter"L];    END;  -- Init        MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    j: CARDINAL;    nItems: CARDINAL = 2;    items ¬ AllocateItemDescriptor[nItems];    items[j¬0] ¬ BooleanItem[tag: "time fields"L,      place: [0, line0], switch: @tool.timeFields];    items[j¬j+1] ¬ BooleanItem[tag: "Flippers"L,      place: [0, line1], switch: @tool.flippers, proc: ToggleFlippers];    IF (j+1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;  -- MakeForm          MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "TimeSpy.log"L];    tool.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    tool.flipperSW ¬ Flipper.Create[parent: window, flippers: flipItems,      priority: Process.priorityNormal, position: leftJustified];    END;              Start: SpecialSpy.StartProc =     BEGIN    displayFormat ¬ format;    Flipper.ClearCounts[tool.flipperSW];    timeFields ¬ tool.timeFields;    globalLine ¬       MataHariInternal.z.NEW[StringBody[displayWidth]      ¬ [length: 0, maxlength: displayWidth, text: ]];    [] ¬ SpecialSpy.SetNSSpyTrigger[TimeSpy, wh];    END;  -- Start          Stop: PROC =    BEGIN    [] ¬ SpecialSpy.SetNSSpyTrigger[NIL, wh];  -- unhook it.    Process.Pause[Process.SecondsToTicks[1]]; -- Give display a chance to finish.    -- Clean house.    MataHariInternal.z.FREE[@globalLine];    END;  -- Stop          ToggleFlippers: FormSW.NotifyProcType =    BEGIN    IF tool.flippers THEN Flipper.Enable[tool.flipperSW]    ELSE Flipper.Disable[tool.flipperSW];    END;  -- ToggleFlippers              -- Mainline code    Init[];  END.
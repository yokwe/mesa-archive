-- File: MataHariImpl.mesa - last edit:-- AOF                  3-Nov-87 10:14:49-- JAV                 28-Sep-87 17:22:16-- BKI                 27-Apr-88 20:12:27-- NS                  11-Feb-87 16:37:39-- Copyright (C) 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  ArpaTypes USING [BufferBody, ProtocolType],  Buffer USING [Buffer, BufferObject, ReturnBuffer, Type],  BufferDisplay USING [    AppendHeaderPiece, BootPacket, FindBufferBodyAndType, Format, Encapsulation,    EchoPacket, ErrPacket, ExchangePacket, LineOverflow, ICMPPacket, IDPFields,    IPFields, OsiCltpPacket, OsiCotpPacket, OsiIPFields, OutputProc, PacketData,    PacketDataBlock, PupFields, PccPacket, RoutingData, RoutingPacket, SppPacket,    TCPPacket, UBIPCPacket, UDPPacket],  Environment USING [Block, Byte, nullBlock],  IEEE8023 USING [EncapObject, Encapsulation, EthernetPacketType],  ISO8073Types USING [Code, HeaderFixed],  MataHariInternal USING [    clientWh, ConnHandle, ConnObject, firstWKS, params, queued, rawFlp,    tool, typeFlp, z],  NSTypes USING [BufferBody, ConnectionID, PacketType],  OSICLNetworkTypes USING [Address, BufferBody],  PupDefs USING [BufferBody],  Put USING [Line],  RingBuffer USING [Write],  SpecialCommunication USING [SpyProc],  SpecialSpy USING [TriggerProc],  SpecialSystem USING [GetProcessorID, ProcessorID],  System USING [    broadcastHostNumber, HostNumber, Microseconds, NetworkAddress, nullHostNumber,    nullSocketNumber, Pulses, PulsesToMicroseconds, SocketNumber],  String USING [AppendLongDecimal, AppendString, FreeString, MakeString],  Window USING [Handle];MataHariImpl: MONITOR  IMPORTS    Buffer, BufferDisplay,  MataHariInternal, Put, RingBuffer, String,    System, SpecialSystem  EXPORTS MataHariInternal, SpecialSpy =  BEGIN  -- VARIABLES AND CONSTANTS  uniqueConn: CARDINAL ¬ 0;  zone: UNCOUNTED ZONE = MataHariInternal.z;  lastPktTime: System.Pulses ¬ [0];  --for all but connection-oriented.  connect: RECORD [head: MataHariInternal.ConnHandle ¬ NIL, length: CARDINAL ¬ 0];  -- hook for special clients.  trigger: SpecialSpy.TriggerProc ¬ NIL;  myNSId: SpecialSystem.ProcessorID ¬ SpecialSystem.GetProcessorID[];  all: SpecialSystem.ProcessorID = LOOPHOLE[System.broadcastHostNumber];  -- For copying buffers  base: LONG POINTER TO Buffer.BufferObject ¬ NIL;  outProc: BufferDisplay.OutputProc = {    IF (s.length # 0) AND (MataHariInternal.params.driver # etherToDisk) THEN      Put.Line[MataHariInternal.tool.fileSW, s];    s.length ¬ 0};  ArpaSpy: PUBLIC INTERNAL SpecialCommunication.SpyProc =    BEGIN OPEN MataHariInternal;    bp: LONG POINTER TO ArpaTypes.BufferBody = LOOPHOLE[b.highLayer.blockPointer];    IF params.level1Type[arpa] THEN {SaveIt[b]; RETURN[b]};    -- FILTER: level 2.        «   IF b.arpa.ipHeader.protocol IN ArpaTypes.ProtocolType[icmp..tacMon]      AND params.arpaType[b.arpa.ipHeader.protocol] THEN SaveIt[b];  »    IF bp.ipHeader.protocol IN ArpaTypes .ProtocolType[icmp..tacMon]      AND params.arpaType[bp.ipHeader.protocol] THEN SaveIt[b];    RETURN[b];    END;  -- ArpaSpy  CreateOsiConnObj: PROC [b: Buffer.Buffer]    RETURNS [c: MataHariInternal.ConnHandle ¬ NIL] =    BEGIN    op: LONG POINTER TO OSICLNetworkTypes.BufferBody =       LOOPHOLE[b.highLayer.blockPointer];    opDestAddr: LONG POINTER TO OSICLNetworkTypes.Address ¬ LOOPHOLE[@op.destAddr];    CreateConnAddr: PROC [opAddr: LONG POINTER TO OSICLNetworkTypes.Address]      RETURNS [connAddr: LONG STRING ¬ NIL] =      BEGIN      connAddr ¬ String.MakeString [zone, opAddr.length];      connAddr.length ¬ opAddr.length;      connAddr[0] ¬ LOOPHOLE[opAddr.first];      FOR i: CARDINAL IN [0..opAddr.length - 1) DO        connAddr[i + 1] ¬ LOOPHOLE[opAddr.middle[i]];        ENDLOOP;      END;    c ¬ zone.NEW[      osi MataHariInternal.ConnObject ¬ [      link: NIL, unique: uniqueConn ¬ uniqueConn + 1, time: [b.fo.time],      body: osi[]]];    WITH conn: c SELECT FROM      osi => {        conn.destination ¬ CreateConnAddr[opDestAddr];        conn.source ¬ CreateConnAddr[opDestAddr + (opDestAddr.length + 1) / 2]};      ENDCASE;    c.link ¬ connect.head;    connect.head ¬ c;    END;  --CreateOsiConnObj  CreateSPPConnObj: PROC [b: Buffer.Buffer]    RETURNS [c: MataHariInternal.ConnHandle ¬ NIL] =    BEGIN    np: LONG POINTER TO NSTypes.BufferBody = LOOPHOLE[b.highLayer.blockPointer];    c ¬ zone.NEW[      spp MataHariInternal.ConnObject ¬ [      link: NIL, unique: uniqueConn ¬ uniqueConn + 1, time: [b.fo.time],      body: spp[      source: np.source,  -- b.ns.source, ??      destination: np.destination, sourceID: [0], destinationID: [0]]]];    c.link ¬ connect.head;    connect.head ¬ c;    END;  --CreateSPPConnObj  CreateTCPConnObj: PROC [b: Buffer.Buffer]    RETURNS [c: MataHariInternal.ConnHandle ¬ NIL] =    BEGIN    bp: LONG POINTER TO ArpaTypes.BufferBody = LOOPHOLE[b.highLayer.blockPointer];    c ¬ zone.NEW[      tcp MataHariInternal.ConnObject ¬ [      link: NIL, unique: uniqueConn ¬ uniqueConn + 1, time: [b.fo.time],      body: tcp[      source: bp.ipHeader.source, destination: bp.ipHeader.destination,      sourcePort: [0], destinationPort: [0]]]];    c.link ¬ connect.head;    connect.head ¬ c;    END;  --CreateTCPConnObj  -- For clients of SpecialSpy to display in this tool's window.  DisplayProc: PUBLIC BufferDisplay.OutputProc = {    IF s.length # 0 THEN Put.Line[MataHariInternal.tool.fileSW, s]};  DisplayStateHeader: PROC [    c: MataHariInternal.ConnHandle, b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, li: LONG CARDINAL] =    BEGIN  -- Displays the state header.       delta: LONG CARDINAL;    IF c # NIL THEN      BEGIN      WITH conn: c SELECT FROM        spp =>          BEGIN          np: LONG POINTER TO NSTypes.BufferBody =	    LOOPHOLE[b.highLayer.blockPointer];          SELECT c.state FROM            unconnected =>              BEGIN              c.state ¬ halfConnected;              IF np.packetType = sequencedPacket THEN                conn.sourceID ¬ np.sourceConnectionID;              conn.source ¬ np.source;              END;  --unconnected            halfConnected =>              BEGIN              IF np.destination.host = conn.source.host THEN                BEGIN                conn.state ¬ fullyConnected;                IF np.packetType = sequencedPacket THEN                  conn.destinationID ¬ np.sourceConnectionID;                conn.destination ¬ np.source;                END;              END;  --halfConnected            ENDCASE;          String.AppendString[            line,            IF conn.state = halfConnected THEN "Establishing["L            ELSE "Connection["L];          BufferDisplay.AppendHeaderPiece[format, @c.unique, 1, line];          END;  --spp        tcp =>          BEGIN          ap: LONG POINTER TO ArpaTypes.BufferBody =            LOOPHOLE[b.highLayer.blockPointer];          SELECT c.state FROM            unconnected =>              BEGIN              conn.state ¬ halfConnected;              IF ap.ipHeader.protocol = tcp THEN                conn.sourcePort ¬ ap.tcp.sourcePort;              conn.source ¬ ap.ipHeader.source;              END;  --unconnected            halfConnected =>              BEGIN              IF ap.ipHeader.destination = conn.source THEN                BEGIN                conn.state ¬ fullyConnected;                IF ap.ipHeader.protocol = tcp THEN                  conn.destinationPort ¬ ap.tcp.sourcePort;                conn.destination ¬ ap.ipHeader.source;                END;  --halfConnected              END;            ENDCASE;          String.AppendString[            line,            IF conn.state = halfConnected THEN "Establishing["L            ELSE "Connection["L];          BufferDisplay.AppendHeaderPiece[format, @c.unique, 1, line];          END;  --tcp        osi =>          BEGIN          conn.state ¬ fullyConnected;          String.AppendString[line, "Connection["L];          BufferDisplay.AppendHeaderPiece[format, @c.unique, 1, line];          END;  --osi        ENDCASE;      String.AppendString[line, ", "L];      END  --connection header    ELSE String.AppendString[line, "["L];  --non connection oriented.      IF MataHariInternal.params.timing = absolute THEN      String.AppendString[line, "t+"L]    ELSE String.AppendString[line, "delta ="L];    --this is the elapsed time since we last saw a packet on this connection    delta ¬      System.PulsesToMicroseconds[b.fo.time] - System.PulsesToMicroseconds[        IF c # NIL THEN c.time ELSE lastPktTime];    delta ¬ (delta + 500) / 1000;    String.AppendLongDecimal[line, delta];    String.AppendString[line, ", index ="L];    String.AppendLongDecimal[line, li];    String.AppendString[line, "]"L];    IF MataHariInternal.params.timing = relative THEN      IF c # NIL THEN c.time ¬ b.fo.time ELSE lastPktTime ¬ b.fo.time;    Put.Line[MataHariInternal.tool.fileSW, line];    line.length ¬ 0;    END;  -- DisplayStateHeader  DisplayIt: PUBLIC PROC [    b: Buffer.Buffer, c: MataHariInternal.ConnHandle, line: LONG STRING,    format: BufferDisplay.Format, li: LONG CARDINAL]    RETURNS [dataPtr: LONG POINTER, even: BOOLEAN ¬ TRUE] =    BEGIN    ENABLE      BufferDisplay.LineOverflow =>        BEGIN        String.AppendString[MataHariInternal.tool.globalLine, " ..."L];        outProc[MataHariInternal.tool.globalLine];        GOTO exit;        END;    line.length ¬ 0;    dataPtr ¬ b.linkLayer.blockPointer;    IF c # NIL THEN      WITH conn: c SELECT FROM        spp =>          BEGIN          np: LONG POINTER TO NSTypes.BufferBody =	    LOOPHOLE[b.highLayer.blockPointer];          IF conn.socket = MataHariInternal.firstWKS THEN            conn.socket ¬ np.destination.socket;          END;        ENDCASE;    IF MataHariInternal.params.displayParams[conHeader] THEN      DisplayStateHeader[c, b, line, format, li];    IF MataHariInternal.params.displayParams[encap] THEN {      BufferDisplay.Encapsulation[b, line, format, outProc];      dataPtr ¬ b.linkLayer.blockPointer};    IF MataHariInternal.params.displayParams[lvl1Headers] THEN      SELECT b.fo.type FROM        pup => {          pp: LONG POINTER TO PupDefs.BufferBody =            LOOPHOLE[b.highLayer.blockPointer];          BufferDisplay.PupFields[b, line, format, outProc];          dataPtr ¬ @pp.pupWords};        ns => {          np: LONG POINTER TO NSTypes.BufferBody =            LOOPHOLE[b.highLayer.blockPointer];          BufferDisplay.IDPFields[b, line, format, outProc];          dataPtr ¬ @np.nsWords};        arpa => {          ap: LONG POINTER TO ArpaTypes.BufferBody =            LOOPHOLE[b.highLayer.blockPointer];          BufferDisplay.IPFields[b, line, format, outProc];          dataPtr ¬ @ap.ipWords};        osi => {          op: LONG POINTER TO OSICLNetworkTypes.BufferBody =            LOOPHOLE[b.highLayer.blockPointer + b.highLayer.startIndex / 2];          BufferDisplay.OsiIPFields[b, line, format, outProc];          dataPtr ¬ op + (op.ip.initialHeaderLength + 1) / 2;	  even ¬ (op.ip.initialHeaderLength MOD 2 # 0)};        ENDCASE => dataPtr ¬ b.linkLayer.blockPointer;    IF MataHariInternal.params.displayParams[lvl2Headers] THEN      SELECT b.fo.type FROM        ns => {          np: LONG POINTER TO NSTypes.BufferBody =            LOOPHOLE[b.highLayer.blockPointer];          SELECT np.packetType FROM            routingInformation => {              BufferDisplay.RoutingPacket[b, line, format, outProc];              dataPtr ¬ NIL;  -- Special format for routing data.              IF MataHariInternal.params.displayParams[data] THEN                BufferDisplay.RoutingData[b, line, format, outProc]};            echo => {              BufferDisplay.EchoPacket[b, line, format, outProc];              dataPtr ¬ @np.echoWords};            error => {              BufferDisplay.ErrPacket[b, line, format, outProc];              dataPtr ¬ @np.errorBody};            packetExchange => {              BufferDisplay.ExchangePacket[b, line, format, outProc];              dataPtr ¬ @np.exchangeWords};            sequencedPacket => {              data: BOOLEAN ¬ BufferDisplay.SppPacket[                MataHariInternal.params.displayParams[system], b, line, format,                outProc];              IF data THEN	        dataPtr ¬ @np.sppWords	        ELSE dataPtr ¬ NIL};            bootServerPacket =>              dataPtr	        ¬ BufferDisplay.BootPacket[b, line, format, outProc];            pccPacket => {              BufferDisplay.PccPacket[b, line, format, outProc];	      dataPtr ¬ NIL};            ubIPCPacket => {              BufferDisplay.UBIPCPacket[b, line, format, outProc];              SELECT np.nsWords[0] FROM                2 => dataPtr ¬ @np.nsWords[9];                3 => dataPtr ¬ @np.nsWords[6];                6 => dataPtr ¬ @np.nsWords[18];                ENDCASE => dataPtr ¬ @np.nsWords[6]};            ENDCASE =>  -- unknown level 2 type, just format what we can.              dataPtr ¬ @np.nsWords;          };        arpa => {          ap: LONG POINTER TO ArpaTypes.BufferBody =            LOOPHOLE[b.highLayer.blockPointer];          SELECT ap.ipHeader.protocol FROM            tcp => {              BufferDisplay.TCPPacket[b, line, format, outProc];              dataPtr ¬ @ap.tcp.words<< + (ap.ipHeader.ihl * 2) + (ap.tcp.dataOffset * 2) - 2>>};            userDatagram => {              BufferDisplay.UDPPacket[b, line, format, outProc];              dataPtr ¬ @ap.user.words};            icmp => {              BufferDisplay.ICMPPacket[b, line, format, outProc];	      dataPtr ¬ NIL};            ENDCASE;          };        osi => {          bytePtr: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte =            b.highLayer.blockPointer + b.highLayer.startIndex / 2;          op: LONG POINTER TO OSICLNetworkTypes.BufferBody =            LOOPHOLE[bytePtr];          IF op.ip.protocolID = standard AND op.ip.type = data THEN	    BEGIN	    SecondOctet: TYPE = MACHINE DEPENDENT RECORD[	      code(0:0..3): ISO8073Types.Code,	      dontCare(0:4..7): [0..0)];	    dataOffset: CARDINAL;	    tpduOffset: CARDINAL = op.ip.initialHeaderLength + 1;	    SELECT LOOPHOLE[bytePtr[tpduOffset+1], SecondOctet].code FROM              ed, ea, rj, ak, er, dr, dc, cc, cr, dt => {                BufferDisplay.OsiCotpPacket[b, line, format, outProc];		dataOffset ¬ tpduOffset + bytePtr[tpduOffset] + 1};              ud => {                BufferDisplay.OsiCltpPacket[b, line, format, outProc];                dataOffset ¬ tpduOffset};              ENDCASE =>	        dataOffset ¬ tpduOffset;	    dataPtr ¬ bytePtr + dataOffset / 2;	    even ¬ (dataOffset MOD 2 = 0);	    END	  ELSE dataPtr ¬ NIL;          };        ENDCASE => dataPtr ¬ b.linkLayer.blockPointer;    EXITS exit => NULL    END;  -- DisplayIt  FlushPastState: PUBLIC PROC =    BEGIN    pc, c: MataHariInternal.ConnHandle;    IF connect.head # NIL THEN      BEGIN      FOR c ¬ connect.head.link, pc UNTIL c = NIL DO  --then all connections        WITH conn: c SELECT FROM	  osi =>	    BEGIN            String.FreeString [zone, conn.source];            String.FreeString [zone, conn.destination];	    END;	ENDCASE;        pc ¬ c.link; zone.FREE[@c]; ENDLOOP;      uniqueConn ¬ 0;      connect.head ¬ NIL;      END;    END;  -- FlushPastState  DispatcherSpy: PUBLIC ENTRY SpecialCommunication.SpyProc =    BEGIN OPEN MataHariInternal;  --for tool    <<    This is the spy that gets registered with the dispatcher - it does the    multiplexing between protocol families, eliminating the need for the     dispatcher itself to know about the protocol family we are trying to spy    on.    >>    ep: IEEE8023.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];    rawFlp ¬ rawFlp + 1;    -- FILTER: Is this an interesting host?    --(If we want broadcasts only and destination is not broadcast, discard.)    BEGIN    SELECT b.fo.driver.device FROM      ethernet =>        BEGIN        SELECT TRUE FROM          --only want broadcast packets?          (params.broadcasts AND (ep.ethernetDest # all)) => GOTO discard;          tool.processor = System.nullHostNumber => NULL;  --taking anything?          --Destination is specified processor and we want incoming packets.          (ep.ethernetDest = LOOPHOLE[tool.processor]) AND params.incoming =>            NULL;          (~params.outgoing) => GOTO discard;  --but we don't want outgoing          --Source is specified processor and we want outgoing packets.          (ep.ethernetSource = LOOPHOLE[tool.processor]) => NULL;          --Destination is broadcast, we are including broadcasts and we are          --collecting incoming packets.          (ep.ethernetDest = all) AND params.all => NULL;          ENDCASE => GOTO discard;        END;      phonenet => NULL;  --This is point-to-point, so we ignore all level 0       --filters and take whatever comes in.      ENDCASE => GOTO discard;  --don't understand device.    IF b.fo.type = orphan THEN      BEGIN        l1Type: IEEE8023.EthernetPacketType;        [b.highLayer.blockPointer, l1Type] ¬	  BufferDisplay.FindBufferBodyAndType [b];        b.highLayer.startIndex ¬ b.highLayer.stopIndexPlusOne ¬ 0;        b.fo.type ¬ SELECT l1Type FROM	  pup, newpup => pup,          ns=> ns,	  arpa=> arpa,	  osi=> osi,          ENDCASE=> orphan;      END;    IF tool.spyTypes[orphan] # NIL THEN {      b ¬ tool.spyTypes[orphan][b, function];      IF tool.oldSpy # NIL THEN b ¬ tool.oldSpy[b, function];      RETURN[b]};    IF tool.spyTypes[LOOPHOLE[b.fo.type]] # NIL    THEN b ¬ tool.spyTypes[LOOPHOLE[b.fo.type]][b, function];    IF tool.oldSpy # NIL THEN b ¬ tool.oldSpy[b, function];    EXITS      discard =>        BEGIN        SELECT TRUE FROM          (params.driver = diskToDisplay) => NULL;          (b.fo.driver.device = ethernet) AND (ep.ethernetDest # all)          AND (ep.ethernetDest # myNSId) => {Buffer.ReturnBuffer[b]; b ¬ NIL};          ENDCASE;        END;    END;    RETURN[b];    END;  --DispatcherSpy  NSSpy: PUBLIC INTERNAL SpecialCommunication.SpyProc =    BEGIN  --Only ns packets will be handed to us from the dispatcher.    OPEN MataHariInternal;    np: LONG ORDERED POINTER TO NSTypes.BufferBody ¬      LOOPHOLE[b.highLayer.blockPointer];    -- decapsulate it myself    -- FILTER: Is this an interesting socket? (for level 1 and 2)    IF (tool.socket = System.nullSocketNumber)      OR (tool.socket = np.destination.socket) OR (tool.socket = np.source.socket)      THEN      BEGIN  --interesting socket      -- FILTER: level 1      IF params.level1Type[ns] THEN {SaveIt[b]; RETURN[b]; };      -- FILTER: level 2      IF np.packetType IN NSTypes .PacketType[private..pccPacket]        AND params.nsType[np.packetType] THEN SaveIt[b]      ELSE RETURN[b];      END;  --interesting socket    RETURN[b];    END;  -- NSSpy  OsiSpy: PUBLIC INTERNAL SpecialCommunication.SpyProc =    BEGIN OPEN MataHariInternal;    SecondOctet: TYPE = MACHINE DEPENDENT RECORD[      code(0:0..3): ISO8073Types.Code,      dontCare(0:4..7): [0..0)];    ep: IEEE8023.Encapsulation ¬ LOOPHOLE[b.linkLayer.blockPointer];    bytePtr: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte =      b.highLayer.blockPointer + b.highLayer.startIndex / 2;    op: LONG POINTER TO OSICLNetworkTypes.BufferBody =      LOOPHOLE[bytePtr];      -- FILTER: level 1      IF params.level1Type[osi] THEN {SaveIt[b]; RETURN[b]};      -- FILTER: level 2      IF op.ip.protocolID = standard AND op.ip.type = data AND            (params.osiType[iso8073] OR params.osiType[iso8602]) AND        LOOPHOLE[bytePtr[op.ip.initialHeaderLength + 2], SecondOctet].code IN	ISO8073Types.Code THEN        SaveIt[b];    RETURN[b];    END;  -- OsiSpy  PupSpy: PUBLIC INTERNAL SpecialCommunication.SpyProc =    BEGIN OPEN MataHariInternal;    -- FILTER: level 1    IF params.level1Type[pup] THEN SaveIt[b];    -- FILTER: level 2.  (unimplemented)    RETURN[b];    END;  -- PupSpy	  RawSpy: PUBLIC INTERNAL SpecialCommunication.SpyProc =    BEGIN OPEN MataHariInternal;    l1Type: IEEE8023.EthernetPacketType;    -- FILTER: level 0.    [ , l1Type] ¬ BufferDisplay.FindBufferBodyAndType [b];    IF params.allRaw OR (l1Type = LOOPHOLE[params.rawType]) THEN      SaveIt[b];    RETURN[b];    END;  --RawSpy  SaveIt: PROC [b: Buffer.Buffer] =    BEGIN  --c may be NIL.  Gross, huh?!  Someday I'll do something better...    OPEN MataHariInternal;    np: LONG POINTER TO NSTypes.BufferBody = LOOPHOLE[b.highLayer.blockPointer];    ap: LONG POINTER TO ArpaTypes.BufferBody = LOOPHOLE[b.highLayer.blockPointer];    op: LONG POINTER TO OSICLNetworkTypes.BufferBody = LOOPHOLE[b.highLayer.blockPointer];    c: MataHariInternal.ConnHandle ¬ NIL;    -- The pointer to the start of data in the packet.    dp: LONG POINTER ¬ NIL;    even: BOOLEAN ¬ TRUE;    db: Environment.Block ¬ Environment.nullBlock;      typeFlp ¬ typeFlp + 1;    --copy the buffer into the ring, only in buffered mode.    SELECT TRUE FROM      --there is a client and he is not interested.      (trigger # NIL) AND      (~trigger[b, collect, Environment.nullBlock].save) => RETURN;      (params.driver # etherToDisk) => NULL;      ENDCASE =>        BEGIN	WastedSpace: PROC RETURNS[CARDINAL] = INLINE	  BEGIN	  RETURN[CARDINAL[	    LOOPHOLE[b.linkLayer.blockPointer, LONG CARDINAL] -	    LOOPHOLE[@b.bufferBody, LONG CARDINAL]]];	  END;  --WastedSpace	wordsToSave: NATURAL ¬ SIZE[Buffer.BufferObject];  --fixed	wordsToSave ¬ wordsToSave + b.fo.driver.length / 2;  --variable	wordsToSave ¬ wordsToSave + WastedSpace[];         RingBuffer.Write[b, wordsToSave];        queued ¬ queued + 1;        RETURN;        END;    << We will only get here in etherToDisplay or diskToDisplay mode.  This is      where we build the connection object that holds the state for displaying      connection number.  >>    --add to the connection object or allocate a new one.    SELECT TRUE FROM      (b.fo.type = ns) AND (np.packetType = sequencedPacket) =>        BEGIN        --Is this on the list of known spp streams?        FOR c ¬ connect.head, c.link UNTIL c = NIL DO          WITH conn: c SELECT FROM            spp =>              IF                ((np.destinationConnectionID = conn.sourceID)                  AND (np.destination.host = conn.source.host))                OR                  ((np.sourceConnectionID = conn.sourceID)                    AND (np.source.host = conn.source.host)) THEN {                c.packets ¬ c.packets + 1; EXIT};            ENDCASE;          REPEAT            FINISHED =>              BEGIN              c ¬ CreateSPPConnObj[b];              WITH conn: c SELECT FROM                spp => conn.sourceID ¬ np.sourceConnectionID;                ENDCASE;              c.packets ¬ c.packets + 1;              END;          ENDLOOP;  --on list of known spp streams?        END;      (b.fo.type = arpa) AND (ap.ipHeader.protocol = tcp) =>        BEGIN        --Is this on the list of known tcp streams?        FOR c ¬ connect.head, c.link UNTIL c = NIL DO          WITH conn: c SELECT FROM            tcp =>              IF                ((ap.tcp.destinationPort = conn.sourcePort)                  AND (ap.ipHeader.destination = conn.source))                OR                  ((ap.tcp.sourcePort = conn.sourcePort)                    AND (ap.ipHeader.source = conn.source)) THEN {                c.packets ¬ c.packets + 1; EXIT};            ENDCASE;          REPEAT            FINISHED =>              BEGIN              c ¬ CreateTCPConnObj[b];              WITH conn: c SELECT FROM                tcp => conn.sourcePort ¬ ap.tcp.sourcePort;                ENDCASE;              c.packets ¬ c.packets + 1;              END;          ENDLOOP;  --on list of known tcp streams?        END;      (b.fo.type = osi) =>        BEGIN        -- could be any tpdu but cheating via cc tpdu produces more readable code        tpduPtr: LONG POINTER TO ISO8073Types.HeaderFixed.cc ¬          LOOPHOLE[b.highLayer.blockPointer, LONG POINTER] +          (op.ip.initialHeaderLength + 1) / 2;        EqualsOpDestination: PROC [connAddr: LONG STRING] RETURNS [BOOLEAN] =	  BEGIN          IF op.destAddr[0] # connAddr.length THEN RETURN [FALSE];	  FOR i: CARDINAL IN [0..op.destAddr[0]) DO            IF op.destAddr[i+1] # LOOPHOLE[connAddr[i]] THEN RETURN [FALSE];	    ENDLOOP;          RETURN [TRUE];	  END;        SELECT tpduPtr.code FROM	  ed, ea, rj, ak, er, dr, dc, cc, cr, dt =>            IF tpduPtr.dstRef # 0 THEN            --Is this on the list of known tcp streams?              FOR c ¬ connect.head, c.link UNTIL c = NIL DO                WITH conn: c SELECT FROM                  osi =>                     IF                      ((tpduPtr.dstRef = conn.sourceRef) AND                       EqualsOpDestination[conn.source])                      OR                        ((tpduPtr.dstRef = conn.destinationRef) AND                         EqualsOpDestination[conn.destination]) THEN {                      c.packets ¬ c.packets + 1; EXIT};                  ENDCASE;                REPEAT                  FINISHED =>                    IF (tpduPtr.code = cc) AND (tpduPtr.srcRef # 0) THEN		      BEGIN		      c ¬ CreateOsiConnObj[b];                      WITH conn: c SELECT FROM                        osi => {		          conn.sourceRef ¬ tpduPtr.srcRef;			  conn.destinationRef ¬ tpduPtr.dstRef};                        ENDCASE;                      c.packets ¬ c.packets + 1;                      END;                ENDLOOP;  --on list of known osi Transport streams?          ENDCASE;        END;      ENDCASE => c ¬ NIL;  --not connection oriented.    SELECT params.driver FROM      diskToDisplay =>        BEGIN        [dp, even] ¬ DisplayIt[          b, c, tool.globalLine, params.format, rawFlp + params.replayStart - 1];        END;      etherToDisplay =>        BEGIN        [dp, even] ¬ DisplayIt[b, c, tool.globalLine, params.format, typeFlp - 1];        END;      ENDCASE;    db ¬ [dp, IF even THEN 0 ELSE 1, 0];    IF trigger # NIL THEN [, db] ¬ trigger[b, display, db];    IF params.displayParams[data] AND db.blockPointer # NIL THEN      BEGIN      ENABLE        BufferDisplay.LineOverflow =>          BEGIN          String.AppendString[tool.globalLine, " ..."L];          outProc[tool.globalLine];          CONTINUE;          END;        IF b.fo.type = osi	THEN BufferDisplay.PacketDataBlock	       [params.format, b, db, tool.globalLine, outProc ]        ELSE BufferDisplay.PacketData	       [params.format, b, db.blockPointer, tool.globalLine, outProc ];      END;  --data    Put.Line[tool.fileSW, ""L];    END;  --SaveIt  SetNSSpyTrigger: PUBLIC PROC [    newTrig: SpecialSpy.TriggerProc ¬ NIL, wh: Window.Handle]    RETURNS [oldTrig: SpecialSpy.TriggerProc] =    BEGIN    MataHariInternal.clientWh ¬ wh;    oldTrig ¬ trigger;    trigger ¬ newTrig;    END;  -- SetNSSpyTrigger  END...  LOG  30-Mar-84 14:47:49  SMA  Added filtering on <all> to include broadcasts. 2-May-84 15:21:32  SMA  Added BufferDisplay.UBIPCPacket.17-Jul-84 14:56:54  SMA  Added logical index of buffer to display.26-Jul-84 15:23:42  SMA  Added phonenet encapsulation stuff.24-Oct-84 10:58:06  SMA  Added MessageExchange.28-Mar-85 16:55:52  SMA  Stop tool when ready to wrap twice ('till I fix it).19-Nov-85 13:14:23  SMA  Can specify type when collecting raw. 2-Dec-85 16:17:55  SMA  Client filters can specify what to save.20-Jan-86 11:31:08  SMA  Added DispatcherSpy.17-Apr-86 19:11:46  SMA  Don't return buffer to system in buffered mode.17-Apr-86 19:12:16  SMA  Slash and burn on unused queue state code.11-Feb-87 16:38:10  NS   Changes for new buffer munger; put in sma's spiffy new ring buffer code.28-Jun-87 13:45:49  AOF  EtherMAC => IEEE8023 2-Jul-87 20:25:33  BKI  Add support for OSI17-Jul-87 20:11:13  BKI  OSITransportTypes ¬ ISO8073Types.18-Aug-87 11:51:18  BKI  Display OSI NPDU data field only if it exists.25-Aug-87 17:07:16  JAV  got rid of runt stuff 3-Nov-87  9:55:13  AOF  Use of private zone18-Apr-88 12:08:14  BKI  Support odd-byte-aligned TPDU.27-Apr-88 20:12:27  BKI  Fixed uninitialized dataPtr in DisplayIt.
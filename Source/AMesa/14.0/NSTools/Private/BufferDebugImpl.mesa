-- File: BufferDebugImpl.mesa - last edit:-- AOF                 22-Apr-88 15:46:22-- SMA                 14-Mar-84 10:23:21-- Copyright (C) 1984, 1987, 1988 by Xerox Corporation. All rights reserved. <<This module runs in the debugger.  It looks in the users core imageto find and print things.>>DIRECTORY  Buffer USING [    AccessHandle, AccessObject, Buffer, BufferObject, Cluster, Queue,    QueueObject, Seal, Function, Type, TransferStatus],  BufferDisplay USING [Format, Level2Packet, OutputProc],  BufferMgr USING [    bufferSize, Cluster, ClusterObject, maxBuffersPerCluster,    syspool, Use, dataLinkReserve],  BufferOps USING [SizeHint],  DebugUsefulDefs USING [LongCopyREAD, LongREAD, MultipleFrames, Name, NotFound],  DebugUsefulDefsExtras USING [Frame, GFlong, NoSession],  Environment USING [bytesPerPage, bytesPerWord, wordsPerPage],  Event USING [swapping],  EventTypes USING [newSession],  Exec USING [AddCommand, ExecProc, Handle, RemoveCommand],  Format USING [Decimal, LongNumber, Number, NumberFormat, StringProc],  Heap USING [Create, Delete, MakeNode],  Menu USING [Create, Handle, Instantiate, ItemObject, MCRType, Uninstantiate],  PrincOpsExtras2 USING [LongGlobalFrameHandle],  Put USING [Text],  Selection USING [LongNumber, Number],  String USING [InvalidNumber],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, RemoveDependency,    SubsystemHandle],  System USING [PulsesToMicroseconds],  Tool USING [Create, Destroy, MakeFileSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [ TransitionProcType],  Window USING [Box, Handle];          BufferDebugImpl: PROGRAM  IMPORTS    BufferDisplay, DebugUsefulDefs, DebugUsefulDefsExtras,    Event, Exec, Format, Heap, Menu, Selection, String, Supervisor,    System, Put, Tool  EXPORTS Buffer  SHARES BufferMgr =  BEGIN  bpw: NATURAL = Environment.bytesPerWord;  bpp: NATURAL = Environment.bytesPerPage;  wpp: NATURAL = Environment.wordsPerPage;  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    fileSW(2): Window.Handle ¬ NIL];    bufferMgr: LONG POINTER TO FRAME [BufferMgr] ¬ NIL;  nMods: CARDINAL = 1;  -- number of modules we will be digging in.  format: BufferDisplay.Format ¬ octal2;  -- the display format for buffers.  radix: NATURAL ¬ 8;  --equivalent to format for Format.* routines  nf: Format.NumberFormat ¬ [8, , , ];  --used in Format.*Number  sH: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[Agent];  bdOptions, bdMenu: Menu.Handle ¬ NIL;    Cluster: PUBLIC TYPE = BufferMgr.Cluster;  IocbInfo: TYPE = RECORD [ptr: LONG POINTER, state: {free, used}];    -- menu indices  syspool: CARDINAL = 0;  aHChain: CARDINAL = 1;  clusterChain: CARDINAL = 2;  accessHandle: CARDINAL = 3;  cluster: CARDINAL = 4;  buffer: CARDINAL = 5;  aHBuffers: CARDINAL = 6;  queue: CARDINAL = 7;    octal2: CARDINAL = 0;  octal1: CARDINAL = 1;  ebcdic: CARDINAL = 2;  ascii: CARDINAL = 3;  hex: CARDINAL = 4;  decimal: CARDINAL = 5;  lineLength: CARDINAL = 6;    cmdItems: ARRAY [0..8) OF Menu.ItemObject ¬ [    ["syspool", DoDebug], ["aH Chain", DoDebug], ["cluster chain", DoDebug],    -- the following take a user selection.     ["access handle", DoDebug], ["cluster", DoDebug], ["buffer", DoDebug],    ["aH's buffers", DoDebug], ["queue", DoDebug]];     optionItems: ARRAY [0..7) OF Menu.ItemObject ¬ [    ["octal2", SetBufferOptions], ["octal1", SetBufferOptions],    ["ebcdic", SetBufferOptions], ["ascii", SetBufferOptions],    ["hex", SetBufferOptions], ["decimal", SetBufferOptions],    ["set line length"L, SetBufferOptions]];    lineLen: CARDINAL ¬ 0;  -- set by user (eventually)  defaultLine: CARDINAL ¬ 500;  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  z: UNCOUNTED ZONE ¬ Heap.Create[initial: 4];  initialBox: Window.Box = [place: [x:407, y: 106], dims: [w: 512, h: 350]];  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};    Activate: PROC RETURNS[BOOLEAN] =    BEGIN  << Finds the frames for the interesting modules and allocates space    for some of the data structures. >>    IF bufferMgr = NIL THEN GetFrames[];    IF bufferMgr = NIL THEN  -- failed to find the frame.      {Msg["**** Can't find proper modules!"L]; RETURN[FALSE]};    Write["\n"L];    RETURN[TRUE];    END;  -- Activate          Agent: Supervisor.AgentProcedure =    BEGIN  -- if new debug session, need to get new frames.    IF event = EventTypes.newSession THEN bufferMgr ¬ NIL;    END;  -- Agent                DisplayABuffer: PROC [b: Buffer.Buffer] =    BEGIN    HintToWords: PROC[hint: BufferOps.SizeHint] RETURNS[NATURAL] = INLINE      {RETURN[(SELECT hint FROM        smallBuffer => 260, mediumBuffer =>	576,largeBuffer => 1024, ENDCASE => 1500) / bpw]};	    cluster: Cluster;    copy: Buffer.Buffer;    name: LONG STRING ¬ [40];    wordsPerBuffNode: CARDINAL;    stringProc: BufferDisplay.OutputProc = {Write[s]; Write["\n"L]};    line: LONG STRING ¬ z.NEW[StringBody[MAX[defaultLine, lineLen]]];    --all buffers in cluster are the same size--    cluster ¬ LongReadLong[@b.fo.cluster];    wordsPerBuffNode ¬ SIZE[Buffer.BufferObject] +      HintToWords[LongRead[@cluster.hint]];    copy ¬ Heap.MakeNode[z: z, n: wordsPerBuffNode];    LongCopyRead[to: copy, from: b, nwords: wordsPerBuffNode];    --relocate pointers in the buffer    copy.linkLayer.blockPointer ¬ copy.linkLayer.blockPointer + (copy - b);    copy.highLayer.blockPointer ¬ copy.highLayer.blockPointer + (copy - b);    Write["buffer: ("L]; DumpLongNumber[b];    Write["­) [fo: [next: "L]; DumpLongNumber[copy.fo.next];    Write["­, queue: "L]; DumpLongNumber[copy.fo.queue];    Write["­, cluster: "L]; DumpLongNumber[copy.fo.cluster];    Write["­, slot: "L]; DumpShortNumber[copy.fo.slot];    Write[", currentOwner: "L]; DumpLongNumber[copy.fo.currentOwner];    Write["­, seal: {"L]; DumpSeal[copy.fo.seal];    Write["}, network: "L]; DumpLongNumber[LOOPHOLE[copy.fo.network]];    Write["­, context: "L]; DumpLongNumber[copy.fo.context];    Write["­, status: {"L]; DumpStatus[copy.fo.status];    Write["}, time: "L]; DumpLongNumber[copy.fo.time];    Write["­, allNets: "L];    Write[IF copy.fo.allNets THEN "TRUE"L ELSE "FALSE"L];    Write[", bypassZeroNet: "L];    Write[IF copy.fo.allNets THEN "TRUE"L ELSE "FALSE"L];    Write[", type: {"L]; DumpType[copy.fo.type];    Write["}, function: {"L]; DumpFunction[copy.fo.function];    Write["}, debug: "L];    IF copy.fo.debug # NIL THEN      {DumpLongNumber[DebugUsefulDefsExtras.GFlong[copy.fo.debug]];      DebugUsefulDefs.Name[name, copy.fo.debug]; Write["("L]; Write[name]}    ELSE Write["NIL"L];    Write[")], driver: [length: "L];    DumpLongNumber[copy.fo.driver.length];    Write[", iocb: "L];    DumpLongNumber[copy.fo.driver.iocb];    Write["­, faceStatus: "L];    DumpLongNumber[LOOPHOLE[@copy.fo.driver.faceStatus, LONG POINTER TO WORD]­];    Write["], bufferBody: ["L];    BufferDisplay.Level2Packet[copy, line, format, stringProc];    Write["]]\n"L];    z.FREE[@line];    z.FREE[@copy];    END;  -- DisplayABuffer         DisplayAccessObj: PROC [aH: Buffer.AccessHandle]    RETURNS [next: Buffer.AccessHandle] =    BEGIN  -- Displays a single access object, returns the handle of the next    -- access object.    frame: LONG STRING ¬ [40];    copy: Buffer.AccessObject;    LongCopyRead[to: @copy, from: aH, nwords: SIZE[Buffer.AccessObject]];    Write["aH: ("L];    DumpLongNumber[aH];    Write["­) [receiveInUse: "L];    DumpLongNumber[copy.receiveInUse];    Write[", sendInUse: "L];    DumpLongNumber[copy.sendInUse];    Write[", receive: "L];    DumpLongNumber[copy.receive];    Write[", send: "L];    DumpLongNumber[copy.send];    Write[", clientFreeBuffer: "L];    DisplayCondition[copy.clientFreeBuffer];    Write[", next: "L];    next ¬ copy.next;    IF (next ¬ copy.next) = NIL THEN Write["NIL"L]    ELSE DumpLongNumber[next];    Write["­, frame: "L];    IF copy.frame # NIL THEN      {DumpLongNumber[DebugUsefulDefsExtras.GFlong[copy.frame]];      DebugUsefulDefs.Name[frame, copy.frame]; Write["("L]; Write[frame]}    ELSE Write["NIL"L];    Write["), seal: {"L];    DumpSeal[copy.seal];    Write["}]\n"L];    END;  -- DisplayAccessObj          DisplayAHBuffers: PROC =    BEGIN  -- Displays the addresses of the buffers in use by the selected aH.    i: CARDINAL;    bcopy: Buffer.Buffer;    b: Buffer.Buffer ¬ NIL;    ccopy: BufferMgr.Cluster;    frame: LONG STRING ¬ [40];    acopy: Buffer.AccessObject;    cl: Cluster ¬ LongReadLong[@bufferMgr.syspool.cluster.head];    selectedAH: Buffer.AccessHandle ¬ LOOPHOLE[      Selection.LongNumber[radix: radix !	String.InvalidNumber => GOTO notNumber]];    bcopy ¬ z.NEW[Buffer.BufferObject];    ccopy ¬ z.NEW[BufferMgr.ClusterObject[BufferMgr.maxBuffersPerCluster]];    -- Get the access object so we can display the current owner.    LongCopyRead[to: @acopy, from: selectedAH, nwords: SIZE[Buffer.AccessObject]];    Write["aH: ("L];    DumpLongNumber[selectedAH];    Write["­) ["L];    IF acopy.frame # 0 THEN      {Write["("L];      DebugUsefulDefs.Name[frame, acopy.frame];      Write[frame];      Write["), using buffers ["L]};    UNTIL cl = NIL DO      -- get entire cluster object so we can dereference the slot.      LongCopyRead[        to: ccopy, from: cl,	nwords: SIZE[BufferMgr.ClusterObject[BufferMgr.maxBuffersPerCluster]]];      FOR i IN [0..ccopy.buffers) DO        -- get entire buffer object so we can dereference currentOwner (sigh).	LongCopyRead[to: bcopy, from: ccopy.slot[i],	    nwords: SIZE[Buffer.BufferObject]];        IF (bcopy.fo.currentOwner = selectedAH) AND	  (ccopy.useMap[i] = used) THEN	  BEGIN	  IF b # NIL THEN	    BEGIN	    DumpLongNumber[b];	    Write["­, "];	    END;	  b ¬ ccopy.slot[i];	  END;        ENDLOOP;  -- for      cl ¬ ccopy.next;      REPEAT FINISHED =>	IF b # NIL THEN {DumpLongNumber[b]; Write["­"]};      ENDLOOP;  -- until    Write["]\n\n"];    z.FREE[@bcopy]; z.FREE[@ccopy];    EXITS notNumber => Msg["Not a number!\n"L];    END;  -- DisplayAHBuffers        DisplayAHChain: PROC =    BEGIN    aH: Buffer.AccessHandle ¬ LongReadLong[@bufferMgr.syspool.access];    UNTIL aH = NIL DO      aH ¬ DisplayAccessObj[aH];      ENDLOOP;    Write["\n"];    END;  -- DisplayAHChain              <<DisplayIOCBs: PROC =    BEGIN    i: CARDINAL;    icopy: EthernetDriver.FreeIocb ¬ z.NEW[EthernetDriver.IocbObject];    iocbs: ARRAY [0..6) OF IocbInfo;    -- Build the array of IOCB display information.    iocb: EthernetDriver.FreeIocb ¬ LongReadLong[@ethernetDriver.iocbState.first];    FOR i IN [0..6) DO      -- Get the entire iocb so we can dereference the next one.      LongCopyRead[to: icopy, from: iocb,        nwords: SIZE[EthernetDriver.IocbObject]];      iocbs[i] ¬ [iocb, used];      iocb ¬ icopy.next;      ENDLOOP;    -- one more pass to find the free ones.    iocb ¬ LongReadLong[@ethernetDriver.iocbState.free];    FOR i IN [0..6) UNTIL iocb = NIL DO      -- Get the entire iocb so we can dereference the next one.      LongCopyRead[to: icopy, from: iocb,        nwords: SIZE[EthernetDriver.IocbObject]];      iocbs[i].state ¬ free;      iocb ¬ icopy.next;      ENDLOOP;    Write["IOCBs: "L];    FOR i IN [0..6) DO      DumpLongNumber[iocbs[i].ptr];      Write[IF iocbs[i].state = free THEN " (free), "L ELSE " (used), "L];      ENDLOOP;    Write[\n"L];    z.FREE[@icopy];    END;  -- DisplayIOCBs>>                DisplayQueue: PROC =    BEGIN  -- Looks at the user's selection and displays that queue.    b: Buffer.Buffer;    selectedQ: Buffer.Queue ¬ LOOPHOLE[      Selection.LongNumber[radix: radix !	String.InvalidNumber => GOTO notNumber]];    copy: Buffer.Queue ¬ z.NEW[Buffer.QueueObject];    LongCopyRead[to: copy, from: selectedQ, nwords: SIZE[Buffer.QueueObject]];    b ¬ copy.first;    Write["queue: ("L];    DumpLongNumber[selectedQ];    Write["­)  [length: "L];    DumpLongNumber[copy.length];    IF copy.first = copy.last THEN      {Write[", first = last: "L]; DumpLongNumber[copy.first]}    ELSE      BEGIN      Write[", first: "L];      DumpLongNumber[copy.first];      UNTIL b = copy.last DO	LongCopyRead[to: b, from: @b.fo.next, nwords: SIZE[Buffer.Buffer]];	Write["­, "L]; DumpLongNumber[b]; ENDLOOP;      Write["­, last: "L];      DumpLongNumber[copy.last];      END;    Write["­, seal: {"L];    DumpSeal[copy.seal];    Write["}]\n"L];    z.FREE[@copy];    EXITS notNumber => Msg["Not a number!\n"L];     END;  -- DisplayQueue              DisplaySelectedBuffer: PROC =    BEGIN  -- Looks at the user's selection and displays that buffer.    selectedB: Buffer.Buffer ¬ LOOPHOLE[      Selection.LongNumber[radix: radix !	String.InvalidNumber => GOTO notNumber]];    DisplayABuffer[selectedB];    EXITS notNumber => Msg["Not a number!\n"L];      END;  -- DisplaySelectedBuffer          DisplaySelectedAH: PROC =    BEGIN  -- Looks at the user's selection and displays that access handle.    selectedAH: Buffer.AccessHandle ¬ LOOPHOLE[      Selection.LongNumber[radix: radix !	String.InvalidNumber => GOTO notNumber]];    [] ¬ DisplayAccessObj[selectedAH];    EXITS notNumber => Msg["Not a number!\n"L];    END;  -- DisplaySelectedAH         DisplaySelectedCl: PROC =    BEGIN  -- Looks at the user's selection and displays that cluster    selectedCl: Cluster ¬ LOOPHOLE[      Selection.LongNumber[radix: radix !	String.InvalidNumber => GOTO notNumber]];    [] ¬ DisplayACluster[selectedCl];    EXITS notNumber => Msg["Not a number!\n"L];    END;  -- DisplaySelectedCl          DisplayACluster: PROC [cl: Cluster] RETURNS [next: Cluster] =    BEGIN    -- Displays a single cluster, returns the handle of the next cluster.    copy: BufferMgr.Cluster;    copy ¬ z.NEW[BufferMgr.ClusterObject[BufferMgr.maxBuffersPerCluster]];                LongCopyRead[      to: copy, from: cl,      nwords: SIZE[BufferMgr.ClusterObject[BufferMgr.maxBuffersPerCluster]]];    Write["cluster: ("L];    DumpLongNumber[cl];    Write["­) [next: "L];    IF (next ¬ copy.next) = NIL THEN Write["NIL"L]    ELSE DumpLongNumber[next];    Write["­, order: "L];    DumpLongNumber[copy.order];    Write[", time: "L];    DisplayTime[copy.time];    Write[", useMap: ["L];    FOR i: CARDINAL IN [0..BufferMgr.maxBuffersPerCluster) DO      Write[IF copy.useMap[i] = used THEN "used"L ELSE "free"L];      IF copy.mask[SUCC[i]] = used THEN EXIT;      Write[", "L];      ENDLOOP;    Write[", hint: "L]; DisplayHint[copy.hint]; Write[" ("L];    DumpShortNumber[TranslateHint[copy.hint]];    Write[")]"L];    FOR i: CARDINAL IN [0..BufferMgr.maxBuffersPerCluster) DO      b: Buffer.Buffer = copy.slot[i];      Write["\n  slot["L];      Format.Decimal[Write, i];      Write[": "L];      IF b = NIL THEN Write["NIL"L]      ELSE        BEGIN	bytes: CARDINAL ¬ 0;	length: CARDINAL = TranslateHint[copy.hint] +	  LongRead[@bufferMgr.dataLinkReserve];  --that's what he's using	fragment: LONG CARDINAL ¬ LOOPHOLE[@b.bufferBody];	DumpLongNumber[b];  --that's the pointer to the buffer	Write["­, page fragments: ["L];	UNTIL bytes >= length DO	  page: LONG CARDINAL ¬ (fragment / wpp) * wpp;  --round to page boundary	  piece: CARDINAL ¬ CARDINAL[wpp - ((fragment - page) MOD wpp)];	  DumpLongNumber[fragment];  --address of this fragment	  fragment ¬ fragment + piece;  --then we go to the next page fragment	  piece ¬ piece * bpw;  --now its in bytes	  piece ¬ MIN[piece, length - bytes];	  Write[" ["L];	  DumpShortNumber[piece];	  Write["] "L];	  bytes ¬ bytes + piece;  --number of bytes processed	  REPEAT FINISHED =>	    BEGIN	    Write["{EOB @"L];	    DumpLongNumber[b + (bytes / bpw)];	    Write["} "L];	    END;	  ENDLOOP;	END;      IF copy.mask[SUCC[i]] = used THEN EXIT;      Write["], "L];      ENDLOOP;    Write["]\n"L];    z.FREE[@copy];    END;  -- DisplayACluster           DisplayClusterChain: PROC =    BEGIN    cl: Cluster ¬ LongReadLong[@bufferMgr.syspool.cluster.head];    UNTIL cl = NIL DO      cl ¬ DisplayACluster[cl];  -- returns the next cluster handle in the chain;      ENDLOOP;    Write["\n"L];    END;  -- DisplayClusterChain            DisplaySyspool: PROC =    BEGIN    <<    Displays the buffermgr's syspool.  For the access field, only the    head of the chain will be displayed, for the cluster field, the head    and the tail.    >>    cond: LONG CARDINAL;    Write["syspool = [cache: ("L];    DumpLongNumber[SUCC[ORD[BufferOps.SizeHint.LAST]]];    Write[")["L];    FOR i: BufferOps.SizeHint IN BufferOps.SizeHint DO      DumpLongNumber[LongReadLong[@bufferMgr.syspool.cache[i]]];      IF i # BufferOps.SizeHint.LAST THEN Write["­, "L];      ENDLOOP;    Write["­], cluster: [head: "L];    DumpLongNumber[LongReadLong[@bufferMgr.syspool.cluster.head]];    Write["­, tail: "L];    DumpLongNumber[LongReadLong[@bufferMgr.syspool.cluster.tail]];    Write["­, count: "L];    DumpShortNumber[ShortRead[@bufferMgr.syspool.cluster.count]];    Write[", send: "];    DumpShortNumber[ShortRead[@bufferMgr.syspool.send]];    Write[", receive: "];    DumpShortNumber[ShortRead[@bufferMgr.syspool.receive]];    Write[", sendInUse: "];    DumpShortNumber[ShortRead[@bufferMgr.syspool.sendInUse]];    Write[", receiveInUse: "];    DumpShortNumber[ShortRead[@bufferMgr.syspool.receiveInUse]];    Write[", freeBias: "];    DumpShortNumber[ShortRead[@bufferMgr.syspool.freeBias]];    Write[", buffersRequested: "L];    DumpShortNumber[ShortRead[@bufferMgr.syspool.buffersRequested]];    Write[", buffersAllocated: "L];    DumpShortNumber[ShortRead[@bufferMgr.syspool.buffersAllocated]];    Write[", buffersAvailable: ("L];    DumpLongNumber[SUCC[ORD[BufferOps.SizeHint.LAST]]];    Write[")["L];    FOR i: BufferOps.SizeHint IN BufferOps.SizeHint DO      DumpShortNumber[ShortRead[@bufferMgr.syspool.buffersAvailable[i]]];      IF i # BufferOps.SizeHint.LAST THEN Write[", "L];      ENDLOOP;    Write["], access: "L];    DumpLongNumber[LongReadLong[@bufferMgr.syspool.access]];    Write["­, scanInterval: "L];    DisplayTime[LongReadLong[@bufferMgr.syspool.scanInterval]];    Write[", lastTime: "L];    DisplayTime[LongReadLong[@bufferMgr.syspool.lastTime]];    Write[", clusterAgeLimit: "];     DisplayTime[LongReadLong[@bufferMgr.syspool.clusterAgeLimit]];    Write[", lostBufferLimit: "L];    DisplayTime[LongReadLong[@bufferMgr.syspool.lostBufferLimit]];    Write[", defaultSendBuffers: "];    DumpShortNumber[ShortRead[@bufferMgr.syspool.defaultSendBuffers]];    Write[", defaultReceiveBuffers: "];    DumpShortNumber[ShortRead[@bufferMgr.syspool.defaultReceiveBuffers]];    Write[", freeBuffer: "L];    cond ¬ LOOPHOLE[LongReadLong[@bufferMgr.syspool.freeBuffer]];    DisplayCondition[LOOPHOLE[cond]];    cond ¬ LOOPHOLE[LongReadLong[@bufferMgr.syspool.fault]];    Write[", fault: "L];    DisplayCondition[LOOPHOLE[cond]];    <<Write[", flag: "L];    Write[IF ShortRead[@bufferMgr.syspool.flag] = 0 THEN "TRUE"L ELSE "FALSE"L];    Write[", hint: "L];    DisplayHint[ShortRead[@bufferMgr.syspool.hint]];>>    Write[", allocator: PROCESS ["L];    DumpShortNumber[ShortRead[@bufferMgr.syspool.allocator]];    Write["]]\n"L];    END;  -- DisplaySyspool        DisplayCondition: PROC [c: CONDITION] =    BEGIN    Write["[timeout: "L];    DumpLongNumber[c.timeout];    Write[", "L];    DumpShortNumber[LOOPHOLE[@c, POINTER]­];    Write["]"L];    END;  -- DisplayCondition  DisplayHint: PROC[hint: BufferOps.SizeHint] =    BEGIN    Write[SELECT hint FROM      smallBuffer => "smallBuffer"L, mediumBuffer => "mediumBuffer"L,      largeBuffer => "largeBuffer"L, ENDCASE => "maxBuffer"L];    END;  --DisplayHint          DisplayTime: PROC [t: LONG CARDINAL] =    BEGIN  -- displays the time in msecs.    t ¬ System.PulsesToMicroseconds[[t]] / 1000;    DumpLongNumber[t];    END;  -- DisplayTime           DoDebug: Menu.MCRType =    BEGIN  -- Calls the proper proc to display chosen data.    IF Activate[] THEN      SELECT index FROM        syspool => DisplaySyspool[];        aHChain => DisplayAHChain[];        clusterChain => DisplayClusterChain[];        accessHandle => DisplaySelectedAH[];        cluster => DisplaySelectedCl[];        buffer => DisplaySelectedBuffer[];	aHBuffers => DisplayAHBuffers[];	queue => DisplayQueue[];        ENDCASE => ERROR;    END;  -- DoDebug      ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ z.NEW[Data ¬ []];      new = inactive =>        IF data # NIL THEN {	  z.FREE[@data]};      ENDCASE;    };      Init: PROC =    BEGIN    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: initialBox,      clientTransition: ClientTransition, name: "BufferDebug"L,      cmSection: "BufferDebug"L];    Exec.AddCommand[name: "BufferDebug.~"L, proc: NoOp, unload: Unload];    Supervisor.AddDependency[client: sH, implementor: Event.swapping];    bdOptions ¬ Menu.Create[DESCRIPTOR[optionItems], "Buffer display options"L];    bdMenu ¬ Menu.Create[DESCRIPTOR[cmdItems], "BufferDebug"L];    Menu.Instantiate[bdOptions, wh];    Menu.Instantiate[bdMenu, wh];    END;  -- Init  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [17];    Tool.UnusedLogName[unused: logName, root: "SimpleTool.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };      NoOp: Exec.ExecProc = { };  Unload: Exec.ExecProc =    BEGIN    Supervisor.RemoveDependency[client: sH, implementor: Event.swapping];    Menu.Uninstantiate[bdOptions, wh];    Menu.Uninstantiate[bdMenu, wh];    Exec.RemoveCommand[h, "BufferDebug.~"L];    Tool.Destroy[wh];    Heap.Delete[z];    END;  --Unload          SetBufferOptions: Menu.MCRType =    BEGIN  -- sets the buffer display format from the menu.    SELECT index FROM      octal2 => {format ¬ octal2; radix ¬ 8};      octal1 => {format ¬ octal1; radix ¬ 8};      ebcdic => {format ¬ ebcdic; radix ¬ 16};      ascii => {format ¬ ascii; radix ¬ 8};      hex => {format ¬ hex; radix ¬ 16};      decimal => {format ¬ decimal; radix ¬ 10};      lineLength => lineLen ¬ Selection.Number[radix: 10 !	String.InvalidNumber => {Msg["Not a number!\n"L]; CONTINUE}];      ENDCASE;    nf.base ¬ radix;  --record in the number format    END;  -- SetBufferOptions          GetFrames: PROC =    BEGIN    <<    Finds the modules we need and assigns their frame pointers to the    proper variables.    >>    modName: LONG STRING = "BufferMgr"L;    basePtr: LONG POINTER TO PrincOpsExtras2.LongGlobalFrameHandle =      LOOPHOLE[@bufferMgr];    basePtr­ ¬ DebugUsefulDefsExtras.GFlong[      DebugUsefulDefsExtras.Frame[modName ! 	DebugUsefulDefs.NotFound => 	  {Msg["Missing: "L]; Msg[modName]; Msg["\n"L]; CONTINUE};	DebugUsefulDefs.MultipleFrames =>	  {Msg["Duplicate: "L]; Msg[modName]; Msg["\n"L]; CONTINUE};	DebugUsefulDefsExtras.NoSession =>	  {Msg["No session\n"L]; CONTINUE}]];     END;  -- GetFrames  DumpLongNumber: PROC[x: LONG UNSPECIFIED] =    BEGIN    Format.LongNumber[Write, x, nf];    Write[SELECT radix FROM 8 => "B"L, 10 => "D"L, ENDCASE => "H"L];    END;  --DumpLongNumber  DumpShortNumber: PROC[x: UNSPECIFIED] =    BEGIN    Format.Number[Write, x, nf];    Write[SELECT radix FROM 8 => "B"L, 10 => "D"L, ENDCASE => "H"L];    END;  --DumpShortNumber  DumpSeal: PROC[seal: Buffer.Seal] =    BEGIN    Write[SELECT seal FROM      unsealed => "unsealed"L, queueSeal => "queueSeal"L,      bufferSeal => "bufferSeal"L, normalPool => "normalPool"L,      systemPool => "systemPool"L, listenPool => "listenPool"L,      listenerSeal => "listenerSeal"L, ENDCASE => "????"L];     END;  --DumpSeal  DumpStatus: PROC[status: Buffer.TransferStatus] =    BEGIN    Write[SELECT status FROM      pending => "pending"L, goodCompletion => "goodCompletion"L,      aborted => "aborted"L, rejected => "rejected"L,      noRouteToNetwork => "noRouteToNetwork"L,      hardwareProblem => "hardwareProblem"L,      invalidDestAddr => "invalidDestAddr"L,      protocolViolation => "protocolViolation"L,      noAnswerOrBusy => "noAnswerOrBusy"L,      noTranslationForDestination => "noTranslationForDestination"L,      circuitInUse => "circuitInUse"L, circuitNotReady => "circuitNotReady"L,      noDialingHardware => "noDialingHardware"L,      dialerHardwareProblem => "dialerHardwareProblem"L, ENDCASE => "???"L];    END;  --DumpStatus  DumpType: PROC[type: Buffer.Type] =    BEGIN    Write[SELECT type FROM      vagrant => "vagrant"L, ns => "ns"L, pup => "pup"L, arpa => "arpa"L,      osi => "osi"L, upt1 => "upt1"L, upt2 => "upt2"L, ENDCASE => "orphan"L];    END;  --DumpType  DumpFunction: PROC[function: Buffer.Function] =    BEGIN    Write[SELECT function FROM      send => "send"L, receive => "receive"L, driver => "driver"L,      free => "free"L, ENDCASE => "????"L];    END;  --DumpFunction       -- interface to debugger.      LongCopyRead: PROC [to: LONG POINTER, from: LONG POINTER, nwords: CARDINAL] =    INLINE {DebugUsefulDefs.LongCopyREAD[from: from, nwords: nwords, to: to]};      LongRead, ShortRead: PROC [from: LONG POINTER] RETURNS [UNSPECIFIED] = INLINE    {RETURN[DebugUsefulDefs.LongREAD[from]]};      LongReadLong: PROC [from: LONG POINTER] RETURNS [x: LONG UNSPECIFIED] = INLINE    {LongCopyRead[to: @x, from: from, nwords: 2]};       TranslateHint: PROC[hint: BufferOps.SizeHint] RETURNS[length: NATURAL] =    INLINE {RETURN[bufferMgr.bufferSize[hint]]};  Init[];      END.  LOG14-Jun-83 15:46:56  By: SMA  Action: Created file.10-Oct-83 13:48:32  By: SMA  Action: 32-bit proc descriptors.13-Dec-83  9:48:04  By: AOF  Action: Display buffer looks at copy, not b.14-Dec-83 10:54:35  By: SMA  Action: Don't attempt to display frames = 0. 7-Mar-84 10:10:57  By: SMA  Action: Display generic queues.14-Mar-84 10:17:45  By: SMA  Action: Can EthernetDriver queues (now generic).10-Feb-87 14:21:20  By: AOF  Action: Add page fragments to Cluster display.
-- File: ErrorCollectorImpl.mesa - last edit:-- AOF                 25-Aug-87 17:35:21-- Copyright (C) 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Buffer USING [Buffer, MakePool, DestroyPool, AccessHandle, ReturnBuffer, Type],  Courier USING [LocalSystemElement],  IEEE8023 USING [Encapsulation],  Driver USING [ChangeNumberOfInputBuffers, Device, GetDeviceChain],  Format USING [    StringProc, Decimal, Date, LongNumber, NetworkAddress, NetworkNumber],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    newLine, ProcType, NumberItem],  Heap USING [Create],  HostNumbers USING [IsMulticastID],  Inline USING [LongDivMod, BITAND],  NSBuffer USING [Body],  Protocol1 USING [SetMaximumBufferSize],  Put USING [Line, Text],  Router USING [FindMyHostID],  Runtime USING [GetBcdTime],  SpecialCommunication USING [SetEthernetListener, SetSpyProc, SpyProc],  SpecialSystem USING [HostNumber, NetworkNumber],  String USING [AppendChar, AppendDecimal, AppendString],  System USING [    nullHostNumber, broadcastHostNumber, HostNumber, GetGreenwichMeanTime,    nullSocketNumber, GreenwichMeanTime, NetworkAddress, nullNetworkNumber],  Time USING [Append, Unpack],  Tool USING [    Create, MakeFormSW, MakeSWsProc, MakeFileSW, UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Handle],  WSInfoClient USING [GetPilotInfo, GetXDEInfo];  ErrorCollectorImpl: PROGRAM  IMPORTS    Buffer, Courier, Driver, SpecialCommunication, Put, FormSW, Router, Inline,    Protocol1, Runtime, String, System, Time, Tool, Heap, Format, WSInfoClient,    HostNumbers  EXPORTS Buffer, System =  BEGIN    Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  HostNumber: PUBLIC <<System>> TYPE = SpecialSystem.HostNumber;  NetworkNumber: PUBLIC <<System>> TYPE = SpecialSystem.NetworkNumber;      wh: Window.Handle;  tool: LONG POINTER TO ToolData ¬ NIL;  ToolData: TYPE = RECORD[    oldSpy: SpecialCommunication.SpyProc ¬ NIL,    form, log: Window.Handle ¬ NIL,    buffers: Buffer.AccessHandle ¬ NIL,    running: BOOLEAN ¬ FALSE,    started, good, errors, full, empty: LONG CARDINAL ¬ 0,    me: HostNumber ¬ NULL, code: CARDINAL ¬ 10,    maxEntry, free: EntryHandle ¬ NIL,     table: ARRAY NATURAL[0..(modulo + 1) * 2) OF EntryObject ¬ TRASH];  EntryHandle: TYPE =  LONG POINTER TO EntryObject;  EntryObject: TYPE = RECORD[    net: NetworkNumber, host: HostNumber, link: EntryHandle, count: CARDINAL];  unit: CARDINAL = 1;  modulo: NATURAL = 127;  dispatcherBuffers: CARDINAL = 40;  zone: UNCOUNTED ZONE = Heap.Create[100];  null: HostNumber = System.nullHostNumber;  all: HostNumber = System.broadcastHostNumber;  Hosts: TYPE = ARRAY NATURAL[0..(modulo + 1) * 2) OF HostNumber;  Write: Format.StringProc = {Put.Text[tool.log, s]};    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      Initialize: PROCEDURE =    BEGIN    herald: STRING ¬ [60];    String.AppendString[to: herald, from: "Error Packet Collector of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 8;  -- omit hours, mins, zone.    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: herald];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "ErrorCollector.log"L];    tool.form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    tool.log ¬ Tool.MakeFileSW[window: window, name: logName];    END;  Reset: FormSW.ProcType =    BEGIN    tool.good ¬ tool.errors ¬ tool.full ¬ tool.empty ¬ 0;    tool.table ¬ ALL[[System.nullNetworkNumber, null, NIL, 0]];    tool.free ¬ @tool.table[modulo + 1];    tool.maxEntry ¬ @tool.table[((modulo + 1) * 2) - 1];    tool.started ¬ System.GetGreenwichMeanTime[];    Write["Counters reset\n"L];    END;  --Reset  Report: FormSW.ProcType =    BEGIN    h, m, s: CARDINAL;    string: STRING ¬ [80];    d: LONG CARDINAL ¬ System.GetGreenwichMeanTime[];    String.AppendString[string, "Time range: "L];    Time.Append[string, Time.Unpack[[tool.started]]];    String.AppendString[string, " to "L];    Time.Append[string, Time.Unpack[[d]]];    Put.Line[tool.log, string]; string.length ¬ 0;    d ¬ d - tool.started;    String.AppendString[string, "Elpased time: "L];    [h, s] ¬ Inline.LongDivMod[d, 60*60];  --hours    IF h < 10 THEN String.AppendChar[string, '0];    String.AppendDecimal[string, h]; String.AppendChar[string, ':];    [m, s] ¬ Inline.LongDivMod[s, 60];  --minutes    IF m < 10 THEN String.AppendChar[string, '0];    String.AppendDecimal[string, m]; String.AppendChar[string, ':];    IF s < 10 THEN String.AppendChar[string, '0];    String.AppendDecimal[string, s]; Put.Line[tool.log, string];    IF tool.good # 0 THEN      BEGIN      Write["Total packets observed: "L];      Format.LongNumber[Write, tool.good, []];      Write["\n"L];      END;    IF tool.errors # 0 THEN      BEGIN      hi: NATURAL ¬ 0;  --to count hosts      hosts: LONG POINTER TO Hosts ¬ zone.NEW[Hosts];      addr: System.NetworkAddress ¬ Courier.LocalSystemElement[];      Write["Number of error packets observed"L];      IF tool.code # 0 THEN         BEGIN	Write[" with an error code of "L];	Write[SELECT tool.code FROM	1 => "badChecksum"L, 2 => "noSocket"L, 3B => "resourceLimits"L,	4B => "listenerReject"L, 5B => "invalidPacketType"L,	6B => "protocolViolation"L, 1000B => "unspecifiedInRoute"L,	1001B => "inconsistent"L, 1002B => "cantGetThere"L,	1003B => "excessHops"L, 1004B => "tooBig"L,	1005B => "congestionWarning"L, 1006B => "congestionDiscard"L,	10000 => "noError"L, 10001 => "connectionLimit"L,	ENDCASE => "????"L];	Write["("L]; Format.Decimal[Write, tool.code]; Write[")"L];	END;      Write[": "L];      Format.LongNumber[Write, tool.errors, []]; Write["\n"L];      addr.socket ¬ System.nullSocketNumber;      Write["Hosts observed transmitting error packets\n"L];      FOR hash: NATURAL IN[0..modulo] DO	entry: EntryHandle ¬ @tool.table[hash];	UNTIL entry.host = null DO	  BEGIN	  FOR i: NATURAL IN[0..hi) DO	    IF hosts[i] = entry.host THEN GOTO skipThisOne;	    REPEAT FINISHED => {hosts[hi] ¬ entry.host; hi ¬ SUCC[hi]};	    ENDLOOP;	  addr.host ¬ entry.host;	  Format.NetworkAddress[Write, addr, octal];	  IF ~HostNumbers.IsMulticastID[@addr.host] THEN WriteInfo[addr]	  ELSE Write["Source is a multicast id\n\n"L];	  Write["This machine sent error packets with the following nets "L];	  Write["listed as the destination\n"L];	  PrintAllNets[entry];	  EXITS skipThisOne => NULL;	  END;	  IF (entry ¬ entry.link) = NIL THEN EXIT;	  ENDLOOP;	ENDLOOP;      Write["\n"L];      END;    END;  --Report  PrintAllNets: PROC[entry: EntryHandle] =    BEGIN    him: HostNumber = entry.host;    Write["	"L];  --tab over once    UNTIL entry = NIL DO      IF entry.host = him THEN        BEGIN	Format.NetworkNumber[Write, entry.net, octal];	Write["("L]; Format.Decimal[Write, entry.count]; Write[") "L];	END;      entry ¬ entry.link;  --go to next in list      ENDLOOP;    Write["\n\n"L];    END;  --PrintAllNets    WriteInfo: PROCEDURE [who: System.NetworkAddress] =    BEGIN    bfVersion: LONG STRING ¬ [6];    sysVolName: LONG STRING ¬ [40];    pVName: LONG STRING ¬ [40];    userName: LONG STRING ¬ [40];    answered, loggedIn: BOOLEAN;    time, timeBooted, bfCreateDate: System.GreenwichMeanTime;        [answered, time, timeBooted, bfCreateDate]  ¬ WSInfoClient.GetPilotInfo[      who, sysVolName, pVName];    IF answered THEN {      Write["  Physical volume: "L]; Write[pVName]; Write["\n"L];      Write["  System volume: "L]; Write[sysVolName]; Write["\n"L];      Write["  Processor clock: "L]; Format.Date[Write, time, full]; Write["\n"L];      Write["  Booted on "L]; Format.Date[Write, timeBooted, full]; Write["\n"L];      Write["  Boot file created on "L];        Format.Date[Write, bfCreateDate, full]; Write["\n"L]}    ELSE {Write["No reply\n\n"L]; RETURN};        [answered, loggedIn] ¬ WSInfoClient.GetXDEInfo[who, bfVersion, userName];    IF answered THEN {      Write["  Boot file version: "L]; Write[bfVersion]; Write["\n"L];      Write["  User: "L];        Write[userName]; IF loggedIn THEN Write[" (logged in)"L]; Write["\n"L]}    ELSE Write["No XDE information available\n"L];    Write["\n"L];    END;  --WriteInfo  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL = 5;    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[0] ¬ FormSW.CommandItem[      tag: "Stop"L, proc: Stop, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "Go"L, proc: Go];    items[2] ¬ FormSW.CommandItem[tag: "Report"L, proc: Report];    items[3] ¬ FormSW.CommandItem[tag: "Reset"L, proc: Reset];    items[4] ¬ FormSW.NumberItem[      tag: "error code"L, value: @tool.code, z: zone];    RETURN[items: items, freeDesc: TRUE];    END;  Stop: FormSW.ProcType =    BEGIN    OPEN tool;    IF running THEN      BEGIN      s: STRING ¬ [40];      running ¬ FALSE;      Buffer.DestroyPool[buffers];      [] ¬ SpecialCommunication.SetSpyProc[NIL, ns];      [] ¬ SpecialCommunication.SetEthernetListener[unit, me];      Driver.ChangeNumberOfInputBuffers[FALSE];      FOR device: Device ¬ Driver.GetDeviceChain[], device.next	UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 0];	ENDLOOP;      String.AppendString[s, "Collected stopped at "L];      Time.Append[s, Time.Unpack[]];      Put.Line[log, s];      Report[];      END;    END;        Go: FormSW.ProcType =    BEGIN    OPEN tool;    IF ~running THEN      BEGIN      s: STRING ¬ [40];      me ¬ Router.FindMyHostID[];      running ¬ TRUE;      Reset[];  --set all the counters      String.AppendString[s, "Collected started at "L];      Time.Append[s, Time.Unpack[]];      Put.Line[log, s];      buffers ¬ Buffer.MakePool[dispatcherBuffers, 0];  --get large pool      Driver.ChangeNumberOfInputBuffers[TRUE];      [] ¬ SpecialCommunication.SetEthernetListener[unit, all];      FOR device: Device ¬ Driver.GetDeviceChain[], device.next        UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 1500];	ENDLOOP;      tool.oldSpy ¬ SpecialCommunication.SetSpyProc[SpyProc, ns];      END;    END;      ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      (new = inactive) AND (tool # NIL) => {Stop[]; zone.FREE[@tool]};      (old = inactive) AND (tool = NIL) => {tool ¬ zone.NEW[ToolData]};      ENDCASE;    END;	  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Worker routines:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SpyProc: SpecialCommunication.SpyProc =   --PROC[b: Buffer.Buffer, function: Buffer.Function] RETURNS[Buffer.Buffer]    BEGIN    dest: SpecialSystem.HostNumber;    e: IEEE8023.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];    body: NSBuffer.Body ¬ LOOPHOLE[b.highLayer.blockPointer];    SELECT TRUE FROM      (function = send) => tool.good ¬ SUCC[tool.good];      (body.packetType # error) => tool.good ¬ SUCC[tool.good];      (body.errorType.ORD = tool.code), (tool.code = 0) =>	BEGIN	hash: NATURAL = Inline.BITAND[e.ethernetSource.f, modulo];	net: NetworkNumber = LOOPHOLE[	  @body.errorBody, NSBuffer.Body].destination.net;	entry: EntryHandle ¬ @tool.table[hash];	tool.errors ¬ SUCC[tool.errors];	UNTIL (entry.host = e.ethernetSource) AND (entry.net = net) DO	  SELECT TRUE FROM	    (entry.host = null) =>	      {entry.host ¬ e.ethernetSource; entry.net ¬ net; entry.count ¬ 1};	    (entry.link # NIL) => entry ¬ entry.link;	    (tool.free = tool.maxEntry) =>	      {tool.full ¬ SUCC[tool.full]; EXIT};	    ENDCASE =>	      BEGIN	      entry.link ¬ tool.free; entry ¬ tool.free;	      entry.count ¬ 1;	      entry.host ¬ e.ethernetSource; entry.net ¬ net;	      tool.free ¬ tool.free + SIZE[EntryObject];	      EXIT;	      END;	  REPEAT FINISHED => entry.count ¬ SUCC[entry.count];	  ENDLOOP;	END;      ENDCASE => tool.good ¬ SUCC[tool.good];    IF tool.oldSpy # NIL THEN      {b ¬ tool.oldSpy[b, function]; IF b = NIL THEN RETURN[NIL]};    dest ¬ LOOPHOLE[      b.linkLayer.blockPointer, IEEE8023.Encapsulation].ethernetDest;    SELECT TRUE FROM      (function = send) => RETURN[b];      (dest = LOOPHOLE[tool.me]) => RETURN[b];      (dest = LOOPHOLE[all]) => RETURN[b];      ENDCASE => {Buffer.ReturnBuffer[b]; RETURN[NIL]};    END;  -- Mainline code:    Initialize[];    END.
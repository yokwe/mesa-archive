-- File: RexTool.mesa - last edit:-- AOF                 29-Jan-87 19:58:55-- Create by FormSWLayoutTool on 24-Feb-86 11:08-- Copyright (C) 1986, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AddressTranslation USING [StringToNetworkAddress, Error, PrintError],  Format USING [    Decimal, NetworkAddress, LongDecimal, NetworkNumber, StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, line0,    NumberItem, ProcType, StringItem],  Heap USING [Create],  Inline USING [BITSHIFT, DBITSHIFT, LongCOPY],  Process USING [Abort, SetPriority],  Put USING [Line, Text],  Router USING [    endEnumeration, EnumerateRoutingTable, FillRoutingTable, GetDelayToNet,    infinity, NoTableEntryForNet, startEnumeration],  RouterInternal USING [FlushCacheEntry],  RouterOps USING [GetRouteInfo, DetailList, DetailSequence, TableList],  SpecialSystem USING [HostNumber, NetworkNumber],  System USING [    GetClockPulses, GetGreenwichMeanTime, NetworkNumber, PulsesToMicroseconds,    NetworkAddress, nullNetworkAddress],  Tool USING [Create, MakeFileSW, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Box, Handle],  WindowFont USING [CharWidth];RexTool: MONITOR  IMPORTS    AddressTranslation, Format, FormSW, Heap, Inline, Process, Put, Router,    RouterInternal, RouterOps, System, Tool, UserInput, WindowFont  EXPORTS System = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    formSW(0): Window.Handle ¬ NIL,    fileSW(2): Window.Handle ¬ NIL,    hops(4): NATURAL[0..Router.infinity] ¬ Router.infinity,    test(5): PROCESS ¬ NIL,    count(6): NATURAL ¬ 0,    persistency(7): NATURAL ¬ 100,    stop(8): BOOLEAN ¬ FALSE,    time(9): LONG CARDINAL ¬ 0,    to(11): LONG STRING ¬ NIL,    record(13): SEQUENCE COMPUTED NATURAL OF Tuples];  Tuples: TYPE = RECORD[delay: NATURAL ¬ 0, net: System.NetworkNumber ¬ TRASH];  History: TYPE = LONG POINTER TO HistoryObject;  HistoryObject: TYPE = RECORD[    count: LONG CARDINAL, data: SEQUENCE length: NATURAL OF LONG CARDINAL];  NetworkNumber: PUBLIC TYPE = SpecialSystem.NetworkNumber;  HostNumber: PUBLIC TYPE = SpecialSystem.HostNumber;  FormItems: TYPE = {start, stop, persistency, fill, hops, enumerate, record, compare, flush, route, to};  data: DataHandle ¬ NIL;  history: History ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.Create[initial: 4];  OutLine: Format.StringProc = {Put.Line[data.fileSW, s]};  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  initialBox: Window.Box = [place: [x:256, y: 129], dims: [w: 768, h: 312]];  Start:  FormSW.ProcType = {    IF data.test # NIL THEN {OutLine["Test already running"L]; RETURN};    data.stop ¬ FALSE; data.test ¬ FORK StartTest[];    OutLine["Start called"L]};  StartTest: PROC =    BEGIN    index: NATURAL;    clock: LONG CARDINAL;    Process.SetPriority[0];  --ya, ya, I know - background    IF history = NIL THEN history ¬ zone.NEW[HistoryObject[500]];    history.count ¬ history[0] ¬ 0;    Inline.LongCOPY[to: @history[1], from: @history[0],      nwords: SIZE[HistoryObject[history.length]] - SIZE[HistoryObject[1]]];    Write["Filling routing table ("L]; Format.Decimal[Write, data.hops];    Write[")... "L]; Router.FillRoutingTable[data.hops];  --fill it up    Write[" recording table... "L]; Record[];    Write["beginning test... "L];    --UNTIL ABORTED-- UNTIL data.stop DO      ENABLE {ABORTED => EXIT; Router.NoTableEntryForNet => CONTINUE};      index ¬ CARDINAL[System.GetClockPulses[]] MOD data.count;      THROUGH [0..data.persistency) DO	clock ¬ System.GetClockPulses[];	[] ¬ Router.GetDelayToNet[data.record[index].net];	clock ¬ System.GetClockPulses[] - clock;	clock ¬ Inline.DBITSHIFT[System.PulsesToMicroseconds[[clock]], -3];	clock ¬ MIN[(history.length - 1), clock];	history[CARDINAL[clock]] ¬ SUCC[history[CARDINAL[clock]]];	history.count ¬ SUCC[history.count];	ENDLOOP;      ENDLOOP;    END;  --StartTest  Stop:  FormSW.ProcType = {    OutLine["Stop called"L];    IF data.test = NIL THEN {OutLine["No test running"L]; RETURN};    Process.Abort[data.test]; data.stop ¬ TRUE;    JOIN data.test; data.test ¬ NIL;    Write["test complete... filling routing table (0)... "L];    Router.FillRoutingTable[0];    Write["flushing table... "L]; Flush[];  --get rid of them    Write["printing results... "L]; PrintHistory[history];    zone.FREE[@history]};  PrintHistory: PROC[    h: History, zeros: BOOLEAN ¬ FALSE, percent: NATURAL ¬ 5] =    BEGIN    total, v: LONG CARDINAL ¬ 0;    start, stop, last: NATURAL;    IF history.count = 0 THEN {OutLine["The table is empty"L]; RETURN};    Write["\nThe table has "L]; Format.LongDecimal[Write, h.count];    Write[" entries\n"L];    FOR start IN[0..h.length) DO IF h[start] # 0 THEN EXIT; ENDLOOP;    FOR stop DECREASING IN[start..h.length) DO IF h[stop] # 0 THEN EXIT; ENDLOOP;    last ¬ start;    FOR i: NATURAL IN[start..stop] DO      part: LONG CARDINAL;      v ¬ v + h[i];      part ¬ (v * 100) / h.count;      total ¬ total + (h[i] * LONG[Inline.BITSHIFT[i, 3]]);      SELECT TRUE FROM         (zeros), (i = last) => NULL;	(part = 0), (part < percent) => LOOP;	ENDCASE;      Write[IF last = start THEN "  ["L ELSE ", ("L];      Format.Decimal[Write, Inline.BITSHIFT[last, 3]]; Write[".."L];      Format.Decimal[Write, Inline.BITSHIFT[i, 3]]; Write["]: "L];      Format.Decimal[Write, CARDINAL[part]]; Write["% ("L];      Format.LongDecimal[Write, v]; Write[")"L];      v ¬ 0; last ¬ i;      ENDLOOP;    Write["\nThe average value is "L];    Format.LongDecimal[Write, (total / h.count)];    Write[" uSecs/call\n"L];     END;  --PrintHistogram  Flush:  FormSW.ProcType = {    count: NATURAL ¬ 0;    Write["Flush called..."L];    FOR delay: NATURAL IN[0..Router.infinity] DO      net: NetworkNumber ¬ Router.startEnumeration;      DO	net ¬ Router.EnumerateRoutingTable[net, delay];	IF net = Router.endEnumeration THEN EXIT;	RouterInternal.FlushCacheEntry[net];  --gun him	count ¬ SUCC[count];	ENDLOOP;      ENDLOOP;    Format.Decimal[Write, count]; OutLine[" entries flushed"L]};  Enumerate:  FormSW.ProcType =    BEGIN    running, nEntries: NATURAL ¬ 0;    tab: ARRAY NATURAL[0..Router.infinity] OF NATURAL ¬ ALL[0];    OutLine["Enumerate current table"L];    FOR delay: NATURAL IN[0..Router.infinity] DO      count: NATURAL ¬ 0;      net: NetworkNumber ¬ Router.startEnumeration;      Format.Decimal[Write, delay]; Write[" = {"L];      DO	net ¬ Router.EnumerateRoutingTable[net, delay];	IF net = Router.endEnumeration THEN EXIT;	nEntries ¬ SUCC[nEntries];	IF (count ¬ SUCC[count]) # 1 THEN Write[", "L];	IF net.a # 0 THEN Write["***"L];	Format.NetworkNumber[Write, net, octal]; 	IF UserInput.UserAbort[wh] THEN {OutLine["\nABORTED\n"L]; RETURN};	ENDLOOP;      tab[delay] ¬ count;  --keep track of how many / hop      Write["}\n"L];  --end of list at this delay      ENDLOOP;    FOR delay: NATURAL IN[0..Router.infinity] DO      running ¬ running + tab[delay];      Format.Decimal[Write, (tab[delay] * 100) / nEntries];      Write["% ("L]; Format.Decimal[Write, tab[delay]]; Write[") nets are "L];      Format.Decimal[Write, delay]; Write[" hops away and "L];      Format.Decimal[Write, (running * 100) / nEntries];      Write["% ("L]; Format.Decimal[Write, running];      Write[") nets are "L]; Format.Decimal[Write, delay];      Write[" hops away or less\n"L];      ENDLOOP;    END;  --Enumerate  Record:  FormSW.ProcType = {    count: NATURAL ¬ 0;    Write["Record called..."L];    FOR delay: NATURAL IN[0..Router.infinity] DO      net: NetworkNumber ¬ Router.startEnumeration;      DO	net ¬ Router.EnumerateRoutingTable[net, delay];	IF net = Router.endEnumeration THEN EXIT;	data.record[count] ¬ [delay, net];	count ¬ SUCC[count];	ENDLOOP;      ENDLOOP;    data.count ¬ count; data.time ¬ System.GetGreenwichMeanTime[];    Format.Decimal[Write, count]; OutLine[" entries recorded"L]};  Compare:  FormSW.ProcType = {    OutLine["Compare called"L];    FOR delay: NATURAL IN[0..Router.infinity] DO      net: NetworkNumber ¬ Router.startEnumeration;      DO	net ¬ Router.EnumerateRoutingTable[net, delay];	IF net = Router.endEnumeration THEN EXIT;	FOR count: NATURAL IN[0..data.count) DO	  SELECT TRUE FROM	    (data.record[count].net # net) => NULL;	    (data.record[count].delay # delay) =>	      BEGIN	      IF UserInput.UserAbort[wh] THEN {OutLine["\nABORTED\n"L]; RETURN};	      Format.Decimal[Write, count]; Write[" -> "L];	      Format.Decimal[Write, delay]; Write["/"L];	      Format.Decimal[Write, data.record[count].delay];	      Write[" = "L]; Format.NetworkNumber[Write, net, octal];	      Write["\n"];	      END; 	    ENDCASE;	  ENDLOOP;	ENDLOOP;      ENDLOOP};  Fill:  FormSW.ProcType = {Router.FillRoutingTable[data.hops]};  Route:  FormSW.ProcType =    BEGIN    detail: RouterOps.DetailList;    allNets: NetworkNumber = [177777B, 177777B];    remote: System.NetworkAddress = ConvertAddress[data.to];    SELECT TRUE FROM      (remote = System.nullNetworkAddress) => GOTO empty;      (remote.net # allNets) =>	BEGIN	detail ¬ zone.NEW[RouterOps.DetailSequence[1]];  --just one entry long	[, detail[0]] ¬ RouterOps.GetRouteInfo[remote.net !	  Router.NoTableEntryForNet => GOTO nonet];	END;      ENDCASE => detail ¬ RouterOps.TableList[zone];    IF detail = NIL THEN RETURN;  --empty table    FOR i: NATURAL IN[0..detail.nEntries) DO      Write["["L]; Format.Decimal[Write, i];      Write["]  "L];      Format.NetworkNumber[Write, detail[i].driverNetwork, octal];      Write[" is "L];      Format.Decimal[Write, Router.GetDelayToNet[detail[i].driverNetwork]];      Write[" hops away via "L];      Format.NetworkAddress[Write, detail[i].via, octal];      Write[" using the "L];      Write[SELECT detail[i].driverType FROM	ethernet => "ethernet"L, ethernetOne => "ethernetOne"L,	phonenet => "phonenet"L, clusternet => "clusternet"L,	x25 => "x25"L, spare1 => "spare1"L,	spare2 => "spare2"L, ENDCASE => "other"L];      Write[" driver\n"L];      ENDLOOP;    zone.FREE[@detail];    EXITS      nonet => Write["Network not in table\n"L];      empty => Write["Table is empty\n"L];    END;  --Route  ConvertAddress: PROC[him: LONG STRING]    RETURNS[System.NetworkAddress ¬ System.nullNetworkAddress] =    BEGIN    ENABLE AddressTranslation.Error =>      {AddressTranslation.PrintError[errorRecord, Write]; CONTINUE};    RETURN[AddressTranslation.StringToNetworkAddress[him].addr];    END;  --ConvertAddress  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ zone.NEW[Data[350] ¬ [record: ]];      new = inactive =>        IF data # NIL THEN {zone.FREE[@data]};      ENDCASE;    };  Init: PROCEDURE = {    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: initialBox,      clientTransition: ClientTransition, name: "RexTool"L,      cmSection: "RexTool"L];    };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [18];    Tool.UnusedLogName[unused: logName, root: "RexTool.log"L];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: zone];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {x ¬ charWidth * char};  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems, zone];    items[FormItems.start.ORD] ¬ CommandItem[      tag: "Start"L, place: [CharPos[1], line0], proc: Start, z: zone];    items[FormItems.stop.ORD] ¬ CommandItem[      tag: "Stop"L, place: [CharPos[8], line0], proc: Stop, z: zone];    items[FormItems.persistency.ORD] ¬ NumberItem[      tag: "persistency"L, place: [CharPos[14], line0], signed: FALSE,      boxWidth: 32, default: 100, value: @data.persistency, z: zone];    items[FormItems.fill.ORD] ¬ CommandItem[      tag: "Fill"L, place: [CharPos[33], line0], proc: Fill, z: zone];    items[FormItems.hops.ORD] ¬ NumberItem[      tag: "hops"L, place: [CharPos[39], line0], signed: FALSE, boxWidth: 32,      value: @data.hops, z: zone];    items[FormItems.enumerate.ORD] ¬ CommandItem[      tag: "Enumerate"L, place: [CharPos[51], line0], proc: Enumerate, z: zone];    items[FormItems.record.ORD] ¬ CommandItem[      tag: "Record"L, place: [CharPos[63], line0], proc: Record, z: zone];    items[FormItems.compare.ORD] ¬ CommandItem[      tag: "Compare"L, place: [CharPos[71], line0], proc: Compare, z: zone];    items[FormItems.flush.ORD] ¬ CommandItem[      tag: "Flush"L, place: [CharPos[80], line0], proc: Flush, z: zone];    items[FormItems.route.ORD] ¬ CommandItem[      tag: "Route"L, place: [CharPos[87], line0], proc: Route, z: zone];    items[FormItems.to.ORD] ¬ StringItem[      tag: "to"L, place: [CharPos[94], line0], inHeap: TRUE,      string: @data.to, z: zone];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...
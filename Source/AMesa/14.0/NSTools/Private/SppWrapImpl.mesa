-- File: SppWrapImpl.mesa - last edit:-- AOF                 27-Jul-87 19:06:21-- Copyright (C) 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [StringToNetworkAddress, Error, PrintError],   Exec USING [    AddCommand, ExecProc, CheckForAbort, OutputProc, GetToken, FreeTokenString,    RemoveCommand],  Environment USING [Byte, bytesPerWord],  Format USING [Decimal, LongDecimal, NetworkAddress, StringProc],  Inline USING [BITSHIFT, LongDiv, LowByte],  NetworkStream USING [closeSST, closeReplySST],  NSConstants USING [echoerSocket],  NSBuffer USING [Body, Buffer],  NSTypes USING [bytesPerSppHeader, maxDataBytesPerSpp],  PacketStream USING [    Handle, Make, unknownConnID, ConnectionFailed, ConnectionSuspended,    SuspendReason, FailureReason],  Process USING [Abort, CancelAbort, GetCurrent, Pause],  Router USING [GetDelayToNet, NoTableEntryForNet],  Socket USING [SetPacketBytes],  Stream USING [SubSequenceType],  String USING [InvalidNumber, StringToDecimal],  System USING [    NetworkAddress, SocketNumber, GetClockPulses, PulsesToMicroseconds,    nullNetworkAddress, GetGreenwichMeanTime],  Time USING [AppendCurrent];SppWrapImpl: PROGRAM  IMPORTS    AddressTranslation, Format, Exec, Inline, Process, Router, Socket, System,    String, PacketStream, Time =  BEGIN  bpw: NATURAL = Environment.bytesPerWord;  EchoHeader: TYPE = LONG POINTER TO EchoObject;  EchoObject: TYPE = RECORD[    SELECT OVERLAID * FROM      desc => [echoType: EchoType, time: LONG CARDINAL, bytes: CARDINAL],      data => [echoBytes: PACKED ARRAY[0..0) OF Environment.Byte],      ENDCASE];  EchoType: TYPE = MACHINE DEPENDENT{    (FIRST[CARDINAL]), echoRequest(1), echoResponse(2), (LAST[CARDINAL])};  bpeh: NATURAL = bpw * SIZE[desc EchoObject];  Histogram: TYPE = ARRAY [0..16) OF LONG CARDINAL;  HistogramDesc: TYPE = LONG DESCRIPTOR FOR Histogram;  ExecCall: Exec.ExecProc =    BEGIN    Watcher: PROC =      BEGIN      ENABLE ABORTED => CONTINUE;      UNTIL Exec.CheckForAbort[h] DO        Process.Pause[2]; ENDLOOP;      userAbort ¬ TRUE; Process.Abort[parent];      END;  --Watcher    userAbort: BOOLEAN;    rate: LONG CARDINAL;    delay: CARDINAL = 2;    hops, sends: CARDINAL;    time: LONG STRING ¬ [30];    psH: PacketStream.Handle;    parent, watcher: PROCESS ¬ NIL;    reason: PacketStream.FailureReason;    destination: System.NetworkAddress;    remote, switches: LONG STRING ¬ NIL;    out: Format.StringProc = Exec.OutputProc[h];    histogram: Histogram ¬ ALL[0];    BEGIN    ENABLE      AddressTranslation.Error =>	{AddressTranslation.PrintError[errorRecord, out]; GOTO error};    [remote, switches] ¬ Exec.GetToken[h];    IF remote = NIL THEN GOTO null ELSE out[remote];    sends ¬ 0;  --the default id infinity    IF switches # NIL THEN sends ¬ String.StringToDecimal[switches !      String.InvalidNumber => {out["..invalid switch ignored... "L]; CONTINUE}];    userAbort ¬ FALSE;  --reset so we don't copy    parent ¬ Process.GetCurrent[];  --so watcher can abort us    watcher ¬ FORK Watcher;  --to see that we don't get in trouble    [destination, ] ¬ AddressTranslation.StringToNetworkAddress[remote];    remote ¬ Exec.FreeTokenString[remote];    switches ¬ Exec.FreeTokenString[switches];    destination.socket ¬ NSConstants.echoerSocket;    out["("L]; Format.NetworkAddress[out, destination, octal]; out[") is "L];    hops ¬ Router.GetDelayToNet[destination.net !      Router.NoTableEntryForNet => {out["No route to network"L]; GOTO error}];    Format.Decimal[out, hops]; out[" away..."L];    IF userAbort THEN GOTO join;        UNTIL userAbort --possibly forever-- DO      psH ¬ PacketStream.Make[	System.nullNetworkAddress, destination,	PacketStream.unknownConnID, PacketStream.unknownConnID,	TRUE, LONG[(hops * 2) + 20] * 1000, bulk !	PacketStream.ConnectionFailed =>	  IF (reason ¬ why) # timeout THEN GOTO connection	  ELSE {out["connection timed out...retrying..."L]; RETRY}];        out["connection established\n"L];      time.length ¬ 0; Time.AppendCurrent[time]; out[time]; out["\n"L];        rate ¬ SppSender[        psH, sends, out, DESCRIPTOR[histogram], @userAbort];        psH.destroy[psH];      time.length ¬ 0; Time.AppendCurrent[time]; out[time]; out["\n"L];        Format.LongDecimal[out, rate]; out[" bits per second\n"L];      out["Echo round trip times(msecs)\n"L];      FOR i: CARDINAL[0..16) IN[0..LENGTH[histogram]) DO	out["  ["L];	Format.Decimal[out, Inline.BITSHIFT[1, INTEGER[i - 1]]];	out[".."L];	Format.LongDecimal[out, LONG[Inline.BITSHIFT[1, i]]];	out["): "L];	Format.LongDecimal[out, histogram[i]]; out["\n"L];	ENDLOOP;      IF (sends # 0) OR userAbort THEN EXIT;      out["Restarting connection...\n"L];      ENDLOOP;    EXITS      error, join => NULL;      null => out["Host name is NULL\n"L];      connection =>        BEGIN	out["PacketStream.ConnectionFailed: SIGNAL[why: "L];	out[SELECT reason FROM	  timeout => "timeout"L,	  noRouteToDestination => "noRouteToDestination"L,	  noServiceAtDestination => "noServiceAtDestination"L,	  remoteReject => "remoteReject"L,	  tooManyConnections => "tooManyConnections"L,	  noAnswerOrBusy => "noAnswerOrBusy"L,	  noTranslationForDestination => "noTranslationForDestination"L,	  circuitInUse => "circuitInUse"L,	  circuitNotReady => "circuitNotReady"L,	  noDialingHardware => "noDialingHardware"L,	  dialerHardwareProblem => "dialerHardwareProblem"L,	  ENDCASE => "stranger than real life"L];	out["]\n"L];	END;    END;    IF watcher # NIL THEN {Process.Abort[watcher]; JOIN watcher};    IF parent # NIL THEN Process.CancelAbort[parent]; --to make exec happy    END; -- ExecCall  SppSender: PROC[    psH: PacketStream.Handle, sends: CARDINAL,    out: Format.StringProc, hist: HistogramDesc,    userAbort: POINTER TO BOOLEAN]    RETURNS[rate: LONG CARDINAL] =    BEGIN    SppReceiver: PROC[psH: PacketStream.Handle] =      BEGIN      milli: CARDINAL;      micro: LONG CARDINAL;      bitOn: CARDINAL[0..15);      psH.setWaitTime[LAST[LONG CARDINAL]];  --let's not worry 'bout this      UNTIL (sst = NetworkStream.closeReplySST) OR userAbort­ DO	ENABLE ABORTED, PacketStream.ConnectionSuspended => EXIT;	b: NSBuffer.Buffer ¬ psH.get[];  --get next buffer	nsb: NSBuffer.Body = b.ns;	echo: EchoHeader = LOOPHOLE[@nsb.sppWords[0]];	micro ¬ System.PulsesToMicroseconds[[	  System.GetClockPulses[] - echo.time]];	sst ¬ nsb.subtype;  --copy out his sst	bits ¬ bits + echo.bytes;  --multiply by 8 later	milli ¬ Inline.LongDiv[micro, 1000];	FOR bitOn ¬ 0, bitOn + 1 UNTIL milli = 0 DO	  milli ¬ Inline.BITSHIFT[milli, -1]; ENDLOOP;	hist[bitOn] ¬ hist[bitOn] + 1;	psH.returnReceiveBuffer[b];  --give the buffer back	ENDLOOP;    END;  --SppReceiver    echo: EchoHeader;    receiver: PROCESS;    nsb: NSBuffer.Body;    bits: LONG CARDINAL;    bytes, sent: CARDINAL;    b: NSBuffer.Buffer ¬ NIL;    sst: Stream.SubSequenceType ¬ 0;    reason: PacketStream.SuspendReason;    receiver ¬ FORK SppReceiver[psH];    bits ¬ 0; rate ¬ System.GetGreenwichMeanTime[];    sent ¬ 0; --UNTIL sent > sends OR forever OR userAbort­-- DO      ENABLE        BEGIN	ABORTED => {sends ¬ sent + 2; CONTINUE};	PacketStream.ConnectionSuspended => {reason ¬ why; GOTO suspended};	END;      bytes ¬ MAX[(sent MOD NSTypes.maxDataBytesPerSpp), bpeh];      b ¬ psH.getSendBuffer[]; nsb ¬ b.ns;      nsb.subtype ¬ SELECT TRUE FROM        (sends = 0) => 0,  --never quits        (sst = NetworkStream.closeSST),	(sst = NetworkStream.closeReplySST) => NetworkStream.closeReplySST,        ((sends - sent) = 2) => NetworkStream.closeSST,	ENDCASE => 0;	       echo ¬ LOOPHOLE[@nsb.sppWords[0]];      echo.echoType ¬ echoRequest;  --type of data      echo.bytes ¬ bytes;  --that's the sequence number MODULO      FOR i: CARDINAL IN[bpeh..bytes) DO        echo.echoBytes[i] ¬ Inline.LowByte[i + bytes]; ENDLOOP;      Socket.SetPacketBytes[b, bytes + NSTypes.bytesPerSppHeader];      echo.time ¬ System.GetClockPulses[];  --that's when the packet goes out      psH.put[b]; b ¬ NIL;  --send the packet      IF (sent ¬ sent + 1) = LAST[CARDINAL] THEN out["wrapping...\n"L];      IF (sends # 0) AND (sent = sends) THEN {out["finishing...\n"L]; EXIT};      IF userAbort­ THEN {out["aborting...\n"L]; EXIT};      REPEAT        suspended =>	  BEGIN	  out["PacketStream.ConnectionSuspended: ERROR[why: "L];	  out[SELECT reason FROM	    notSuspended => "notSuspended"L,	    transmissionTimeout => "transmissionTimeout"L,	    noRouteToDestination => "noRouteToDestination"L,	    remoteServiceDisappeared => "remoteServiceDisappeared"L,	    ENDCASE => "stranger than real life"L];	  out["]\n"L];	  END;      ENDLOOP;    rate ¬ System.GetGreenwichMeanTime[] - rate;  --elapsed time (seconds)    Process.Abort[receiver]; JOIN receiver;  --get consumer of packets back    rate ¬ (8 * bits) / MAX[rate, 1];  --and the bit rate / second    END;  --SppSender  ExecHelp: Exec.ExecProc =    BEGIN    out: Format.StringProc ¬ Exec.OutputProc[h];    out["SppWrap <remote name>/<switches>\n"L];    out["Valid <switches> decimal numbers | <empty>\n"L];    out["Example\n>SppWrap FileServer/100D\n"L];    END; -- ExecHelp  ExecUnload: Exec.ExecProc = {Exec.RemoveCommand[h, "SppWrap.~"L]};  Exec.AddCommand[    name: "SppWrap.~"L, proc: ExecCall, help: ExecHelp, unload: ExecUnload]  END.Log27-Mar-85 13:37:12 AOF  Created file19-Aug-86 14:07:39 AOF  updated for new buffer mgr 1-May-87  8:38:59 AOF  Unloading + reentrancy  
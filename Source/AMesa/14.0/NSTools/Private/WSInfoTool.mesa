-- File: WSInfoTool.mesa - last edit:-- AOF                 22-Jun-87 18:58:48-- KAM                 16-Apr-85  9:25:21-- Copyright (C) 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [Error, PrintError, StringToNetworkAddress],  Format USING [Date, Decimal, NetworkAddress, StringProc, LongDecimal],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    line0, line1, LongNumberItem, ProcType, StringItem],  Heap USING [Create, Delete],  NetworkBinding USING [BindToAllOnNet, NoBinding, Responses],  Put USING [Text],  System USING [    GetClockPulses, GreenwichMeanTime, NetworkAddress, NetworkNumber,    PulsesToMicroseconds],  Tool USING [    Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Handle],  WSInfoClient USING [GetPilotInfo, GetXDEInfo];WSInfoTool: MONITOR  IMPORTS    AddressTranslation, Format, FormSW, Heap, NetworkBinding, Put,    System, Tool, WSInfoClient =  BEGIN  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    showInfo(6): BOOLEAN ¬ FALSE,    net(7): LONG UNSPECIFIED ¬ 0,    address(9): LONG STRING ¬ NIL,    forked(11): PROCESS ¬ NIL];  FormItems: TYPE = {findWS, showInfo, net, info, address};  zone: UNCOUNTED ZONE;  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  Message: Format.StringProc = {Put.Text[data.msgSW, s]};  FindWSProc: ENTRY FormSW.ProcType = {    IF data.forked = NIL THEN data.forked ¬ FORK FindWS[]    ELSE {Message["busy..."L]}};  DisplayElapsedTime: PROC[    elapsed: LONG CARDINAL, responses: NetworkBinding.Responses] =    BEGIN    Format.LongDecimal[Write, System.PulsesToMicroseconds[[elapsed]] / 1000];    Write[" milliseconds to collect "L];    IF responses = NIL THEN Write[" no responses\n"L]    ELSE      BEGIN      Format.Decimal[Write, responses.elementCount];      Write[	IF responses.elementCount = 1 THEN " response\n"L ELSE " responses\n"L];      END;    END;  --DisplayElapsedTime  FindWS: PROC = {    time: LONG CARDINAL;    net: System.NetworkNumber;    responses: NetworkBinding.Responses ¬ NIL;    ReplyRecord: TYPE = RECORD[      size: NATURAL, station: SEQUENCE length: NATURAL OF System.NetworkAddress];    Two: TYPE = PACKED ARRAY [0.. 2) OF CARDINAL;    two: Two = LOOPHOLE[data.net];    LOOPHOLE[net, Two] ¬ [two[1], two[0]];    Message["Beginning search..."L];    BEGIN    OPEN reply: LOOPHOLE[responses­, ReplyRecord];    time ¬ System.GetClockPulses[];  --this is when we started    responses ¬ NetworkBinding.BindToAllOnNet[net: net, zone: zone !      NetworkBinding.NoBinding => GOTO noNet];    time ¬ System.GetClockPulses[] - time;  --and the elapses    DisplayElapsedTime[time, responses];  --advertise success    IF responses = NIL THEN GOTO noBinding;    FOR i: CARDINAL IN [0.. reply.length) DO      IF data.showInfo THEN WriteInfo[reply[i], FALSE]      ELSE Format.NetworkAddress[Write, reply[i], octal];      Write["  "L];      ENDLOOP;    Write["\n\n"L];    zone.FREE[@responses];    EXITS      noBinding => Write["no responses from network\n\n"L];      noNet => Write["target network is not reachable or no such network\n\n"L];    END;    Message["done\n"L];    data.forked ¬ NIL};  InfoProc: ENTRY FormSW.ProcType = {    IF data.forked = NIL THEN data.forked ¬ FORK Info[]    ELSE {Message["busy..."L]}};  Info: PROC = {    who: System.NetworkAddress;    Message["Checking address..."L];    {who ¬ AddressTranslation.StringToNetworkAddress[data.address      ! AddressTranslation.Error => {        AddressTranslation.PrintError[errorRecord, Write]; Write["\n\n"L];	GOTO NoName}].addr;    WriteInfo[who, TRUE];    EXITS NoName => NULL};    Message["done\n"L];    data.forked ¬ NIL};    WriteInfo: PROCEDURE [who: System.NetworkAddress, useDataAddress: BOOLEAN] = {    bfVersion: LONG STRING ¬ [6];    sysVolName: LONG STRING ¬ [40];    pVName: LONG STRING ¬ [40];    userName: LONG STRING ¬ [40];    answered, loggedIn: BOOLEAN;    time, timeBooted, bfCreateDate: System.GreenwichMeanTime;        [answered, time, timeBooted, bfCreateDate]  ¬ WSInfoClient.GetPilotInfo[      who, sysVolName, pVName];    IF answered THEN {      IF useDataAddress THEN {        Write[data.address];        Write[" ("L]; Format.NetworkAddress[Write, who, octal]; Write["): \n"L]}      ELSE {Format.NetworkAddress[Write, who, octal]; Write["\n"L]};      Write["  Physical volume: "L]; Write[pVName]; Write["\n"L];      Write["  System volume: "L]; Write[sysVolName]; Write["\n"L];      Write["  Processor clock: "L]; Format.Date[Write, time, full]; Write["\n"L];      Write["  Booted on "L]; Format.Date[Write, timeBooted, full]; Write["\n"L];      Write["  Boot file created on "L];        Format.Date[Write, bfCreateDate, full]; Write["\n"L]}    ELSE {      Write["No reply from "L];      IF useDataAddress        THEN Write[data.address] ELSE Format.NetworkAddress[Write, who, octal];      Write["\n\n"L];      RETURN};        [answered, loggedIn] ¬ WSInfoClient.GetXDEInfo[who, bfVersion, userName];    IF answered THEN {      Write["  Boot file version: "L]; Write[bfVersion]; Write["\n"L];      Write["  User: "L];        Write[userName]; IF loggedIn THEN Write[" (logged in)"L]; Write["\n"L]}    ELSE Write["No XDE information available\n"L];    Write["\n"L]};  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        BEGIN	zone ¬ Heap.Create[20];	IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];	END;      new = inactive =>        BEGIN	IF data # NIL THEN zone.FREE[@data];	Heap.Delete[zone];	END;      ENDCASE};  Init: PROCEDURE = {    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "WSTool"L,      cmSection: "WSTool"L]};  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [17];    Tool.UnusedLogName[unused: logName, root: "WSTool.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName]};  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.findWS.ORD] ¬ CommandItem[      tag: "Find WS"L, place: [6, line0], proc: FindWSProc];    items[FormItems.showInfo.ORD] ¬ BooleanItem[      tag: "info"L, place: [72, line0], switch: @data.showInfo];    items[FormItems.net.ORD] ¬ LongNumberItem[      tag: "net"L, place: [132, line0], signed: FALSE, radix: octal,      value: @data.net];    items[FormItems.info.ORD] ¬ CommandItem[      tag: "Info"L, place: [6, line1], proc: InfoProc];    items[FormItems.address.ORD] ¬ StringItem[      tag: "address"L, place: [72, line1], inHeap: TRUE, string: @data.address];    RETURN[items: items, freeDesc: TRUE]};  Init[];  END...    
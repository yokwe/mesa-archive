-- File: MataHariUtilImpl.mesa - last edit:-- AOF                  3-Nov-87 10:16:00-- SMA                  5-Oct-83 16:31:49-- NS                  11-Feb-87 16:54:57-- Copyright (C) 1983, 1984, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  ExtendedString USING [AppendNumber, StringToNumber],  MataHariInternal USING [tool, z],  MataHariUtil USING [Bases],  Put USING [CR, Line],  String USING [AppendChar, AppendDecimal, AppendString, StringBoundsFault];MataHariUtilImpl: PROGRAM  IMPORTS ExtendedString, MataHariInternal, Put, String  EXPORTS MataHariUtil =  BEGIN  -- TYPES  Number: TYPE = ARRAY [0..6) OF WORD;  -- VARIABLES and CONSTANTS  line: LONG STRING ¬ [100];  num: LONG POINTER TO Number;  Convert: PUBLIC PROC [inNum: LONG STRING, base: MataHariUtil.Bases] =    BEGIN    ENABLE      BEGIN      String.StringBoundsFault =>        BEGIN        Put.CR[MataHariInternal.tool.fileSW];        Put.Line[MataHariInternal.tool.fileSW, "Number too long!"L];        Put.CR[MataHariInternal.tool.fileSW];        GOTO exit;        END;      END;  -- enable clause.    fieldPart: CARDINAL ¬ 0;    si: CARDINAL ¬ 0;  -- index into the string.    b: CARDINAL;    EndOfField: PROC [c: CHARACTER] RETURNS [BOOLEAN] = {      RETURN[(c = '#) OR (c = '.)]};    SubField: PROC [f: LONG POINTER] RETURNS [BOOLEAN] =      BEGIN      << Finds out the base of the number in input string, converts that      number and puts it in the field pointed to by <f>. >>      c: CHARACTER;      sf: STRING ¬ [40];      base: CARDINAL ¬ 8;  --up to you to prove me wrong      UNTIL si = inNum.length DO        c ¬ inNum[si];        si ¬ si + 1;        SELECT c FROM          IN ['0..'7] => {sf[sf.length] ¬ c; sf.length ¬ sf.length + 1};          '8, '9 =>            BEGIN            base ¬ MAX[base, 10];            sf[sf.length] ¬ c;            sf.length ¬ sf.length + 1;            END;          'A, 'C, 'E, 'F =>            BEGIN base ¬ 16; sf[sf.length] ¬ c; sf.length ¬ sf.length + 1; END;          'B =>            BEGIN            IF (si = inNum.length) OR EndOfField[c] THEN base ¬ MAX[base, 8]            ELSE {sf[sf.length] ¬ c; sf.length ¬ sf.length + 1; base ¬ 16};            END;          'D =>            BEGIN            IF (si = inNum.length) OR EndOfField[c] THEN base ¬ MAX[base, 10]            ELSE {sf[sf.length] ¬ c; sf.length ¬ sf.length + 1; base ¬ 16};            END;          'H => base ¬ 16;          '#, '., '- => NULL;          ENDCASE => RETURN[FALSE];  --this is a failure        ENDLOOP;      IF sf.length # 0 THEN {        ExtendedString.StringToNumber[f, 6, base, sf]; RETURN[TRUE]}      ELSE RETURN[FALSE];      END;  --SubField    -- start of Convert.    IF (inNum = NIL) OR (inNum.length = 0) THEN      BEGIN      Put.Line[MataHariInternal.tool.fileSW, "Please select a number"L];      RETURN;      END;    num ¬ MataHariInternal.z.NEW[Number];    IF SubField[num] THEN  -- Find out base and get input number.      BEGIN      -- Display in other bases.      line.length ¬ 0;      b ¬ SELECT base FROM hex => 16, decimal => 10, ENDCASE => 8;      DisplayBase[b];      ExtendedString.AppendNumber[num, 6, b, line];      SELECT b FROM        16 => String.AppendChar[line, 'H];        8 => String.AppendChar[line, 'B];        ENDCASE;      Put.Line[MataHariInternal.tool.msgSW, line];      line.length ¬ 0;      MataHariInternal.z.FREE[@num];      END    ELSE Put.Line[MataHariInternal.tool.msgSW, "Not a number!"L];    EXITS exit => {MataHariInternal.z.FREE[@num]; line.length ¬ 0};    END;  -- Convert  DisplayBase: PROC [b: CARDINAL] =    BEGIN  -- Displays the base information for the line.    String.AppendString[line, "Base: "L];    String.AppendDecimal[line, b];    String.AppendString[line, ", "L];    END;  -- DisplayBase   END...
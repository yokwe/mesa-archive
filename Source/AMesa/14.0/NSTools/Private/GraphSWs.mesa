-- File: GraphSWs.mesa - last edit:-- AOF                  4-Feb-87 12:13:20-- Copyright (C) 1983 , 1987 by Xerox Corporation. All rights reserved. --GraphSWs.mesa - (last editted by AOF 25-Nov-83 14:38:23)--Implementation of graphing subwindowDIRECTORY  Context USING [Create, Data, Find, Type, UniqueType],  Display USING [Black, Text, White],  Environment USING [wordsPerPage],  File USING [nullFile],  FormSW USING [    Create, ClientItemsProcType, AllocateItemDescriptor, Enumerated,    EnumeratedItem, CommandItem, ProcType, EnumeratedNotifyProcType, newLine],  GraphSW USING [    Axis, DataPair, defaultSize, defaultOrigin, GraphDescriptor, Smoothing,    SmoothingProcType],  Heap USING[NWords, systemZone],  Process USING [Priority, GetPriority, SetPriority, priorityBackground],  Space USING [Map, PageCount, Unmap],   String USING [AppendLongDecimal, AppendString],  Tool USING[AddThisSW, DeleteThisSW, RegisterSWType, SWType],  ToolWindow USING [AdjustProcType, CreateSubwindow,     Destroy, DisplayProcType],  Window USING[Box, GetBox, Handle, InvalidateBox, Place, Dims],  WindowFont USING[FontHeight, CharWidth];GraphSWs: MONITOR  IMPORTS    Context, Display, Heap, Tool, WindowFont, Window, Space,    String, ToolWindow, FormSW, Process  EXPORTS GraphSW =  BEGIN  zone: UNCOUNTED ZONE = Heap.systemZone;  wpp: CARDINAL = Environment.wordsPerPage;  type: Context.Type = Context.UniqueType[];  typeSW: Tool.SWType = Tool.RegisterSWType[adjust: Adjuster];  fontH: CARDINAL = WindowFont.FontHeight[];  fontW: CARDINAL = WindowFont.CharWidth['0];    clientSmoother: GraphSW.SmoothingProcType ¬ NopSmoother;   Data: TYPE = LONG POINTER TO GraphData;  GraphData: TYPE = RECORD[    sw, formSW: Window.Handle, active: CARDINAL, smoothing: GraphSW.Smoothing,    graphs: SEQUENCE length: CARDINAL OF LONG POINTER TO GraphObject];     GraphObject: TYPE = RECORD[    tag: LONG STRING, parms: Parms, minimum, maximum: GraphSW.DataPair,    plot: SEQUENCE length: CARDINAL OF GraphSW.DataPair];  Parms: TYPE = RECORD[    origin: GraphSW.DataPair, xAxis, yAxis: GraphSW.Axis, index: CARDINAL,    compression, collected: CARDINAL, bucket: GraphSW.DataPair];  UncountedZoneObject: TYPE = MACHINE DEPENDENT RECORD [    procs(0:0..31): LONG POINTER TO Procs, data(2:0..31): LONG POINTER];  Procs: TYPE = MACHINE DEPENDENT RECORD [    Make(0): PROC [UNCOUNTED ZONE, Heap.NWords] RETURNS [LONG POINTER],    Free(2): PROC [UNCOUNTED ZONE, LONG ORDERED POINTER]];  MakeSomePages: PROC [z: UNCOUNTED ZONE, n: Heap.NWords] RETURNS [LONG POINTER] =    BEGIN    pages: Space.PageCount ¬ (n + wpp)/wpp;    RETURN[Space.Map[window: [File.nullFile, 0, pages], class: data].pointer];    END;       FreeSomePages: PROC [z: UNCOUNTED ZONE, p: LONG ORDERED POINTER] =    {[] ¬ Space.Unmap[p, return]};      pageZoneProcs: Procs ¬ [Make: MakeSomePages, Free: FreeSomePages];  pageZoneObject: UncountedZoneObject ¬ [procs: @pageZoneProcs, data: NIL];  pageZone: UNCOUNTED ZONE = LOOPHOLE[@pageZoneObject];  Activate: PUBLIC PROC[sw: Window.Handle, graph: UNSPECIFIED] =    BEGIN    data: Data ¬ Context.Find[type, sw];    data.active ¬ graph; DisplayGraph[sw];    END;  Adjuster: ToolWindow.AdjustProcType =    {IF when = after THEN Window.InvalidateBox[window, [[0, 0], box.dims]]};  ClientSmoothing: PUBLIC PROC[proc: GraphSW.SmoothingProcType] =    {clientSmoother ¬ IF proc # NIL THEN proc ELSE NopSmoother};  Create: PUBLIC PROC[    parent: Window.Handle,    graphs: GraphSW.GraphDescriptor,    smoothing: GraphSW.Smoothing ¬ none,    dims: Window.Dims ¬ GraphSW.defaultSize,    nextSW: Window.Handle ¬ NIL,    formSW: BOOLEAN ¬ TRUE]    RETURNS[sw: Window.Handle] =    BEGIN    MakeForm: FormSW.ClientItemsProcType =      BEGIN      OPEN FormSW;      item: CARDINAL;      nItems: CARDINAL = 4;      tags: LONG POINTER TO Tags;      smooth: ARRAY CARDINAL[0..4) OF Enumerated ¬ [        ["none"L, GraphSW.Smoothing[none]],	["firstOrder"L, GraphSW.Smoothing[firstOrder]],	["fourthOrder"L, GraphSW.Smoothing[forthOrder]],	["other"L, GraphSW.Smoothing[other]]];      Tags: TYPE = ARRAY CARDINAL OF Enumerated;      DamnAllocLoopholeType: TYPE = RECORD[        SEQUENCE COMPUTED CARDINAL OF Enumerated];      items ¬ AllocateItemDescriptor[nItems];      tags ¬ LOOPHOLE[zone.NEW[DamnAllocLoopholeType[data.length]]];      FOR i: CARDINAL IN [0..data.length) DO	tags[i] ¬ [data[i].tag, i]; ENDLOOP;      items[item ¬ 0] ¬ EnumeratedItem[	tag: "Activate"L, place: newLine, value: @data.active,	proc: ActivateProc, choices: DESCRIPTOR[tags, data.length]];      items[item ¬ item + 1] ¬ CommandItem[tag: "Reset"L, proc: ResetProc];      items[item ¬ item + 1] ¬ CommandItem[tag: "Rescale"L, proc: RescaleProc];      items[item ¬ item + 1] ¬ EnumeratedItem[        tag: "Smoothing"L, choices: DESCRIPTOR[smooth],	value: @data.smoothing, proc: SmoothProc];      Context.Create[type, data, FreeFormData, data.formSW];  --for the form      zone.FREE[@tags];      IF (item + 1) # nItems THEN ERROR;      RETURN[items: items, freeDesc: TRUE];      END;  --MakeForm    data: Data ¬ zone.NEW[GraphData[LENGTH[graphs]]];    IF dims = GraphSW.defaultSize THEN dims ¬ [      Window.GetBox[parent].dims.w, 300];    data.sw ¬ sw ¬ ToolWindow.CreateSubwindow[      parent: parent, display: DisplayGraph,      box: [Window.GetBox[parent].place, dims]];    data.active ¬ 0;    data.smoothing ¬ smoothing;    FOR i: CARDINAL IN [0..LENGTH[graphs]) DO      data[i] ¬ pageZone.NEW[GraphObject[graphs[i].dataPoints] ¬ [	tag: ,	minimum: [graphs[i].xAxis.minValue, graphs[i].yAxis.minValue],	maximum: [graphs[i].xAxis.maxValue, graphs[i].yAxis.maxValue], 	parms: [	  origin: graphs[i].origin, index: 0,          xAxis: [  	    tag: ,	    minValue: graphs[i].xAxis.minValue,	    maxValue: graphs[i].xAxis.maxValue],          yAxis: [	    tag: ,	    minValue: graphs[i].yAxis.minValue,	    maxValue: graphs[i].yAxis.maxValue],          compression: graphs[i].compression,	  collected: graphs[i].compression,	  bucket: [0, 0]],	plot: ]];      IF (graphs[i].tag # NIL) AND (graphs[i].tag.length # 0) THEN        BEGIN        data[i].tag ¬ zone.NEW[StringBody[graphs[i].tag.length]];        String.AppendString[data[i].tag, graphs[i].tag];	END      ELSE data[i].tag ¬ NIL;      data[i].parms.xAxis.tag ¬ zone.NEW[StringBody[graphs[i].xAxis.tag.length]];      String.AppendString[data[i].parms.xAxis.tag, graphs[i].xAxis.tag];      data[i].parms.yAxis.tag ¬ zone.NEW[StringBody[graphs[i].yAxis.tag.length]];      String.AppendString[data[i].parms.yAxis.tag, graphs[i].yAxis.tag];      ENDLOOP;    Context.Create[type, data, FreeGraphData, sw];  --for the graph    IF formSW THEN      BEGIN      data.formSW ¬ ToolWindow.CreateSubwindow[parent: parent];      FormSW.Create[sw: data.formSW, clientItemsProc: MakeForm];      Tool.AddThisSW[        window: parent, sw: data.formSW, swType: vanilla, nextSW: nextSW];      nextSW ¬ data.formSW;      END    ELSE data.formSW ¬ NIL;    Tool.AddThisSW[window: parent, sw: sw, swType: typeSW, nextSW: nextSW];    END;  --Create  Destroy: PUBLIC PROCEDURE[sw: Window.Handle] =    BEGIN    data: Data ¬ Context.Find[type, sw];    IF data.formSW # NIL THEN      BEGIN      Tool.DeleteThisSW[data.formSW];      ToolWindow.Destroy[data.formSW];      END;    FreeGraphData[data, sw];    END;  --Destroy  ActivateProc: FormSW.EnumeratedNotifyProcType =    {data: Data ¬ Context.Find[type, sw]; DisplayGraph[data.sw]};    ResetProc: FormSW.ProcType =    {data: Data ¬ Context.Find[type, sw]; Reset[data.sw, data.active]};    RescaleProc: FormSW.ProcType =    {data: Data ¬ Context.Find[type, sw]; Rescale[data.sw, data.active]};    SmoothProc: FormSW.EnumeratedNotifyProcType =     {data: Data ¬ Context.Find[type, sw]; Smooth[data.sw, data.smoothing]};  FreeFormData: PROCEDURE [data: Context.Data, sw: Window.Handle] = {};    FreeGraphData: PROCEDURE [data: Context.Data, sw: Window.Handle] =    BEGIN    --Frees the space, but not the node pointing to it.  Tool will do that.    OPEN myData: LOOPHOLE[data, Data];    FOR i: CARDINAL IN[0..myData.length) DO      zone.FREE[@myData[i].tag];      zone.FREE[@myData[i].parms.xAxis.tag];      zone.FREE[@myData[i].parms.yAxis.tag];      pageZone.FREE[@myData.graphs[i]];      ENDLOOP;    zone.FREE[@data];  --HUM?  Makes one wonder about the comment above.    END;  --FreeGraphData    DisplayGraph: ToolWindow.DisplayProcType =  --PROCEDURE [window: ToolWindow.Handle];    BEGIN    parms: Parms;    x, y: INTEGER;    box: Window.Box;    active: CARDINAL;    label: STRING ¬ [100];    data: Data ¬ Context.Find[type, window];    IF data = NIL THEN RETURN;  --too soon to do anything    active ¬ data.active;    parms ¬ data[active].parms;    box ¬ Window.GetBox[window];    --first draw the graph proper    --whiten entire area first    Display.White[window, [[0, 0], box.dims]];    --axis header .. "xAxis.tag(range)" VS "yAxis.tag(range)"    String.AppendString[label, parms.xAxis.tag];    String.AppendString[label, "(["L];    String.AppendLongDecimal[label, parms.xAxis.minValue];    String.AppendString[label, ".."L];    String.AppendLongDecimal[label, parms.xAxis.maxValue];    String.AppendString[label, "]) VS "L];    String.AppendString[label, parms.yAxis.tag];    String.AppendString[label, "(["L];    String.AppendLongDecimal[label, parms.yAxis.minValue];    String.AppendString[label, ".."L];    String.AppendLongDecimal[label, parms.yAxis.maxValue];    String.AppendString[label, "])"L];    x ¬ (box.dims.w - (fontW*label.length))/2;    y ¬ box.dims.h - fontH - 1;    [] ¬ Display.Text[window, label, [x, y]];    [] ¬ Display.Text[window, label, [x-1, y]];    Smooth[window, data.smoothing];    END;  --DisplayGraph    AddPoint: PUBLIC ENTRY PROC[    sw: Window.Handle, graph: UNSPECIFIED, pair: GraphSW.DataPair] =    BEGIN    data: Data ¬ Context.Find[type, sw];    parms: Parms ¬ data[graph].parms;    parms.bucket ¬ [parms.bucket.x + pair.x, parms.bucket.y + pair.y];    IF (parms.collected ¬ parms.collected - 1) = 0 THEN      BEGIN      index: CARDINAL ¬ parms.index MOD data.graphs[graph].length;      --average the data over the compression interval      parms.bucket ¬ [        parms.bucket.x/parms.compression,	parms.bucket.y/parms.compression];      data[graph].plot[index] ¬ parms.bucket;  --record in array      IF graph = data.active THEN DisplayPoint[sw, parms.bucket];      parms.index ¬ parms.index + 1;      --reset compression bucket      parms.collected ¬ parms.compression;      parms.bucket ¬ [0, 0];      END;    data[graph].parms ¬ parms;  --copy back    END;  --AddPoint    DisplayPoint: PROC[sw: Window.Handle, point: GraphSW.DataPair] =    BEGIN    data: Data ¬ Context.Find[type, sw];    parms: Parms ¬ data[data.active].parms;    box: Window.Box ¬ Window.GetBox[sw];    --normalize x-axis and covert to window parms    point.x ¬ (point.x - parms.xAxis.minValue) * LONG[box.dims.w];    point.x ¬ point.x / (parms.xAxis.maxValue - parms.xAxis.minValue);    --normalize y-axis and covert to window parms    point.y ¬ (point.y - parms.yAxis.minValue) * LONG[box.dims.h - fontH - 6];    point.y ¬ point.y / (parms.yAxis.maxValue - parms.yAxis.minValue);    --[] ¬ Display.White[sw,      --[[INTEGER[point.x], 0], [1, box.dims.h - fontH - 4]]];    [] ¬ Display.Black[sw,      [[INTEGER[point.x], box.dims.h - INTEGER[point.y] - fontH - 4],      [1, INTEGER[point.y]]]];    END;  --DisplayPoint  NopSmoother: GraphSW.SmoothingProcType = {RETURN[pair]};  Smooth: PUBLIC PROC[sw: Window.Handle, smoothing: GraphSW.Smoothing ¬ none] =    BEGIN    data: Data ¬ Context.Find[type, sw];    point: GraphSW.DataPair;    active: CARDINAL ¬ data.active;    parms: Parms ¬ data[active].parms;    box: Window.Box ¬ Window.GetBox[sw];    modulo: CARDINAL ¬ data[active].length;    k0, k1, k2: GraphSW.DataPair ¬ data[active].plot[0];    cPrio: Process.Priority ¬ Process.GetPriority[];    Process.SetPriority[Process.priorityBackground];    --clear the plottable portion of the window first    Display.White[sw, [[0, 0], [box.dims.w, box.dims.h - fontH - 2]]];    --the origin and its axis (origin is in client units)    IF parms.origin.x IN[parms.xAxis.minValue..parms.xAxis.maxValue] THEN      BEGIN      --vertical or Y-axis .. convert to window coords      point.x ¬ parms.origin.x - parms.xAxis.minValue;      point.x ¬ point.x * LONG[box.dims.w - fontW - 6];      point.x ¬ point.x / (parms.xAxis.maxValue - parms.xAxis.minValue);       Display.Black[        sw, [[INTEGER[point.x], 0],[2, box.dims.h - fontH - 2]]];      END;    IF parms.origin.y IN[parms.yAxis.minValue..parms.yAxis.maxValue] THEN      BEGIN      --horizontal or X-axis .. convert to window coords      point.y ¬ parms.origin.y - parms.yAxis.minValue;      point.y ¬ point.y * LONG[box.dims.h - fontH - 6];      point.y ¬ point.y / (parms.yAxis.maxValue - parms.yAxis.minValue);      Display.Black[        sw, [[0, INTEGER[point.y] + box.dims.h - fontH - 4],	[box.dims.w, 2]]];      END;    FOR i: CARDINAL IN[0..data[active].parms.index) DO      point ¬ data[active].plot[i];      SELECT smoothing FROM	none => DisplayPoint[sw, point];	firstOrder =>	  BEGIN	  DisplayPoint[sw, [(k0.x + point.x)/2, (k0.y + point.y)/2]];	  k0 ¬ point;	  END;	forthOrder =>	  BEGIN	  DisplayPoint[sw,	    [(k0.x + 2*k1.x + 2*k2.x + point.x)/6,	    (k0.y + 2*k1.y + 2*k2.y + point.y)/6]];	  k0 ¬ k1; k1 ¬ k2; k2 ¬ point;	  END;	ENDCASE => DisplayPoint[sw, clientSmoother[point]];      ENDLOOP;    Process.SetPriority[cPrio];    END;  --Smooth  Rescale: PUBLIC PROC[sw: Window.Handle, graph: UNSPECIFIED] =    BEGIN    data: Data ¬ Context.Find[type, sw];    min, max: GraphSW.DataPair ¬ data[graph].plot[0];    cPrio: Process.Priority ¬ Process.GetPriority[];    FOR index: CARDINAL IN[1..data[graph].parms.index) DO      pair: GraphSW.DataPair ¬ data[graph].plot[index];      min.x ¬ MIN[min.x, pair.x]; max.x ¬ MAX[max.x, pair.x];      min.y ¬ MIN[min.y, pair.y]; max.y ¬ MAX[max.y, pair.y];      ENDLOOP;    --check for divide by zero condition    IF (min.x # max.y) AND (min.y # max.y) THEN      BEGIN      data[graph].parms.xAxis.minValue ¬ min.x;      data[graph].parms.xAxis.maxValue ¬ max.x;      data[graph].parms.yAxis.minValue ¬ min.y;      data[graph].parms.yAxis.maxValue ¬ max.y;      DisplayGraph[sw];      END;    Process.SetPriority[cPrio];    END;  --Rescale    Reset: PUBLIC PROC[sw: Window.Handle, graph: UNSPECIFIED] =    BEGIN    data: Data ¬ Context.Find[type, sw];    data[graph].parms.index ¬ 0; data[graph].parms.bucket ¬ [0, 0];    data[graph].parms.xAxis.minValue ¬ data[graph].minimum.x;    data[graph].parms.yAxis.minValue ¬ data[graph].minimum.y;    data[graph].parms.xAxis.maxValue ¬ data[graph].maximum.x;    data[graph].parms.yAxis.maxValue ¬ data[graph].maximum.y;    IF graph = data.active THEN DisplayGraph[sw];    END;  --Reset  END...  LOG  
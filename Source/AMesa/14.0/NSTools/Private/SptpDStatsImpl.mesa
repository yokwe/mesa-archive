-- File: SptpDStatsImpl.mesa - last edit:-- AOF                 10-May-88 11:42:37-- Create by FormSWLayoutTool on 15-Oct-85 11:22-- Copyright (C) 1987, 1988 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [CR],  Buffer USING [Device],  Driver USING [Device, GetDeviceChain],  Exec USING [AddCommand, ExecProc, Handle, RemoveCommand],  Flipper USING [ClearCounts, Create, Enumerated],  Format USING [LongDecimal, StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, line0, ProcType],  Heap USING [systemZone],  LedSW USING [Create, Enumerated, SetLed],  NewRS232CFace USING [DeviceStatus],  Process USING [Abort, MsecToTicks, Pause],  Put USING [Text],  Runtime USING [GlobalFrame, InvalidFrame],  SptpDriver USING [rs232c],  SptpOps USING [GetDevice, StatsRecord],  Time USING [AppendCurrent],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Handle],  WindowFont USING [CharWidth];SptpDStatsImpl: PROGRAM  IMPORTS    Driver, Exec, Flipper, Format, FormSW, Heap, LedSW, Put, Process,    Runtime, SptpOps, Time, Tool, WindowFont  EXPORTS Buffer  SHARES SptpDriver = {  Device: PUBLIC <<BUFFER>> TYPE = Driver.Device;  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    statsSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    ledSW(6): Window.Handle ¬ NIL,    lights(8): PROCESS ¬ NIL];  FormItems: TYPE = {clearCounters, logCounters};  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  lineWatcher: PROCESS ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  charWidth: CARDINAL = WindowFont.CharWidth['0];  lineNumber: NATURAL ¬ 0;  stati: NATURAL = SIZE[SptpOps.StatsRecord] / SIZE[LONG CARDINAL];  tags: ARRAY NATURAL[0..stati) OF LONG STRING = [    "pktsRcvd"L, "bytesRcvd"L,    "packetsSent"L, "bytesSent"L,    "cntrlPktRcvd"L, "cntrlPktSent"L,    "sendAborted"L, "rcvAborted"L,    "checksumError"L, "dataLost"L, "deviceError"L,    "disaster"L, "invalidFrame"L, "protocolDown"L,    "protocolUp"L, "masterTmo"L, "cmdInit"L, "cmdLost"L];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {x ¬ charWidth * char};  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  ClearCounters:  FormSW.ProcType = {Flipper.ClearCounts[data.statsSW]};  LogCounters:  FormSW.ProcType =    BEGIN    time: LONG STRING ¬ [40];    device: Device = SptpOps.GetDevice[lineNumber];    lp: LONG POINTER TO ARRAY NATURAL[0..stati) OF LONG CARDINAL;    IF device # NIL THEN lp ¬ device.stats    ELSE {Write["\nNo device\n"L]; RETURN};    time[0] ¬ Ascii.CR; time.length ¬ SUCC[time.length];  --append byte!    Time.AppendCurrent[time];    time[time.length] ¬ Ascii.CR; time.length ¬ SUCC[time.length]; --append byte!    Write[time];  --get that out there    FOR i: NATURAL IN[0..LENGTH[tags]) DO      Write[tags[i]];      Write[": "L];      Format.LongDecimal[Write, lp[i]];      IF i < (LENGTH[tags] - 1) THEN Write[", "L];      ENDLOOP;    Write["\n"L];    END;  --LogCounters  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];      new = inactive =>        IF data # NIL THEN {	  IF data.lights # NIL THEN	    {Process.Abort[data.lights]; JOIN data.lights};	  zone.FREE[@data]};      ENDCASE;    };  Init: PROCEDURE = {    Exec.AddCommand["SptpDStats.~"L, NoOp, NIL, Unload];    lineWatcher ¬ FORK LineWatcher[]}; --Init  LineWatcher: PROC[] = {    --UNTIL I FIND A LINE-- DO      ENABLE ABORTED => EXIT;      FOR device: Device ¬ Driver.GetDeviceChain[], device.next        UNTIL device = NIL DO	IF device.device # phonenet THEN LOOP;	lineNumber ¬ device.lineNumber;	wh ¬ Tool.Create[	  makeSWsProc: MakeSWs, initialState: default,	  cmSection: "SptpStats"L, clientTransition: ClientTransition,	  name: "SptpStats"L];	RETURN;	ENDLOOP;      Process.Pause[Process.MsecToTicks[500]];      ENDLOOP;    };  NoOp: Exec.ExecProc = { };    Unload: Exec.ExecProc = {    Process.Abort[lineWatcher]; JOIN lineWatcher;    IF wh # NIL THEN Tool.Destroy[wh];    Exec.RemoveCommand[h, "SptpDStats.~"L]};  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [20];    device: Device = SptpOps.GetDevice[lineNumber];    flips: ARRAY NATURAL[0..stati) OF Flipper.Enumerated;    lp: LONG POINTER TO ARRAY NATURAL[0..stati) OF LONG CARDINAL;    leds: ARRAY NATURAL[0..6) OF LedSW.Enumerated ¬ [      [tag: "  lost"L, state: off],      [tag: "RING"L, state: off],      [tag: "CTS"L, state: off],      [tag: "CD"L, state: off],      [tag: "DSR"L, state: off],      [tag: "RI"L, state: off]];    IF device # NIL THEN lp ¬ device.stats    ELSE {Write["\nNo device\n"L]; RETURN};    Tool.UnusedLogName[unused: logName, root: "SptpDStats.log"L];    FOR i: NATURAL IN[0..LENGTH[tags]) DO      flips[i] ¬ [tag: tags[i], count: @lp[i]]; ENDLOOP;    data.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    data.statsSW ¬ Flipper.Create[parent: window, flippers: DESCRIPTOR[flips]];    data.ledSW ¬ LedSW.Create[parent: window, leds: DESCRIPTOR[leds]];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    data.lights ¬ FORK Lights[data.ledSW, device];    };  Lights: PROC[sw: Window.Handle, device: Device] =    BEGIN    cached: NewRS232CFace.DeviceStatus ¬ [      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, 0];    --UNTIL ABORTED-- DO ENABLE ABORTED => EXIT;        BEGIN	ENABLE Runtime.InvalidFrame => CONTINUE;	gf: LONG POINTER TO FRAME[SptpDriver] ¬ LOOPHOLE[	  Runtime.GlobalFrame[LOOPHOLE[device.activateDriver]]];	copied: NewRS232CFace.DeviceStatus ¬ gf.rs232c.newStatus;	IF copied.breakDetected # cached.breakDetected THEN	  LedSW.SetLed[sw, 0, IF copied.breakDetected THEN on ELSE off];	IF copied.dataLost # cached.dataLost THEN	  LedSW.SetLed[sw, 1, IF copied.dataLost THEN on ELSE off];	IF copied.ringHeard # cached.ringHeard THEN	  LedSW.SetLed[sw, 2, IF copied.ringHeard THEN on ELSE off];	IF copied.carrierDetect # cached.carrierDetect THEN	  LedSW.SetLed[sw, 3, IF copied.ringHeard THEN on ELSE off];	IF copied.clearToSend # cached.clearToSend THEN	  LedSW.SetLed[sw, 4, IF copied.clearToSend THEN on ELSE off];	IF copied.dataSetReady # cached.dataSetReady THEN	  LedSW.SetLed[sw, 5, IF copied.dataSetReady THEN on ELSE off];	IF copied.ringIndicator # cached.ringIndicator THEN	  LedSW.SetLed[sw, 6, IF copied.ringIndicator THEN on ELSE off];	cached ¬ copied;	END;      Process.Pause[Process.MsecToTicks[100]];      ENDLOOP;    END;  --Lights  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.clearCounters.ORD] ¬ CommandItem[      tag: "Clear counters"L, place: [CharPos[0], line0], proc: ClearCounters];    items[FormItems.logCounters.ORD] ¬ CommandItem[      tag: "Log counters"L, place: [CharPos[20], line0], proc: LogCounters];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...  
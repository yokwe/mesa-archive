-- File: SurveyBFImpl.mesa - last edit:-- AOF                 24-Dec-86  8:24:56-- kam                 19-Aug-85 11:16:31-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  Exec USING [    AddCommand, EndOfCommandLine, ExecProc, FreeTokenString, GetToken,    OutputProc],  Format USING [    Blank, CR, Date, Decimal, NetworkAddress, NetworkNumber, StringProc,    LongDecimal],  Heap USING [Create, Delete],  Inline USING [LongCOPY],  NetworkBinding USING [BindToAllOnNet, NoBinding, Responses],  Process USING [Detach],  QuickSort USING [Comparison, CompareProc, Sort, SwapProc],  String USING [Compare, Equivalent, InvalidNumber, StringToLongNumber],  System USING [    gmtEpoch, GreenwichMeanTime, NetworkAddress, NetworkNumber,    nullNetworkNumber, switches, GetClockPulses, PulsesToMicroseconds],  PilotSwitches USING [heapOwnerChecking],  WSInfoClient USING [GetPilotInfo, GetXDEInfo];SurveyBFImpl: MONITOR  IMPORTS    Exec, Format, Heap, Inline, NetworkBinding, Process, QuickSort,    String, System, WSInfoClient =  BEGIN  Info: TYPE = LONG POINTER TO InfoSeq;  InfoRec: TYPE = RECORD [    who: System.NetworkAddress,    sysVolName, pVName, bfVersion, userName: LONG STRING,    bfCreateDate: System.GreenwichMeanTime];  InfoSeq: TYPE = RECORD [s: SEQUENCE count: CARDINAL OF InfoRec];  ReplyRecord: TYPE = RECORD[size: NATURAL,    station: SEQUENCE length: NATURAL OF System.NetworkAddress];  HelpProc: Exec.ExecProc = {    Exec.OutputProc[h]["SurveyBF.~ net net net... obtains information on which bootfiles are currently being run on the listed networks"L]};    ExecProc: Exec.ExecProc = {    net: System.NetworkNumber ¬ System.nullNetworkNumber;    info: Info ¬ NIL;    z: UNCOUNTED ZONE;    count: CARDINAL ¬ 0;    finished: CONDITION;    countProcesses: CARDINAL ¬ 0;    maxProcesses: CARDINAL = 15;        Out: Format.StringProc = Exec.OutputProc[h];        CountProcess: ENTRY PROCEDURE = {      WHILE countProcesses >= maxProcesses DO WAIT finished ENDLOOP;      countProcesses ¬ SUCC[countProcesses]};        FinishProcess: ENTRY PROCEDURE [net: System.NetworkNumber] = {      Out["Information collected from net "L];      Format.NetworkNumber[Out, net, octal];      Out["\n"L];      countProcesses ¬ PRED[countProcesses];      NOTIFY finished};        WaitDone: ENTRY PROCEDURE = {      WHILE countProcesses > 0 DO WAIT finished ENDLOOP};        DisplayCount: PROCEDURE = {      Out["  Total "L];      Format.Decimal[Out, count];      Out[IF count = 1 THEN " workstation\n" ELSE " workstations\n"L];      count ¬ 0};        DoOneNet: PROCEDURE [net: System.NetworkNumber] =      BEGIN      info: Info ¬ NIL;      time: LONG CARDINAL;      responses: NetworkBinding.Responses ¬ NIL;      OutSearch[net];      BEGIN      OPEN reply: LOOPHOLE[responses­, ReplyRecord];      time ¬ System.GetClockPulses[];  --this is when we started      responses ¬ NetworkBinding.BindToAllOnNet[net: net, zone: z !	NetworkBinding.NoBinding => GOTO NoNet];      DisplayElapsedTime[(System.GetClockPulses[] - time), responses];            info ¬ IncreaseInfo[info, responses.elementCount, z];        FOR i: CARDINAL IN [0..reply.length) DO	ok: BOOLEAN;	info[i].who ¬ reply[i];	info[i].sysVolName ¬ z.NEW[StringBody [40]];	info[i].pVName ¬ z.NEW[StringBody [40]];	info[i].bfVersion ¬ z.NEW[StringBody [6]];	info[i].userName ¬ z.NEW[StringBody [40]];	info[i].bfCreateDate ¬ System.gmtEpoch;	[answered: ok, bfCreateDate: info[i].bfCreateDate] ¬	  WSInfoClient.GetPilotInfo[	    info[i].who, info[i].sysVolName, info[i].pVName];	IF ok THEN	  [answered: ok] ¬ WSInfoClient.GetXDEInfo[	    info[i].who, info[i].bfVersion, info[i].userName];	IF NOT ok THEN {	  info[i].bfCreateDate ¬ System.gmtEpoch; info[i].bfVersion.length ¬ 0};	ENDLOOP;      MergeInfo[info];      z.FREE[@info]; z.FREE[@responses];      EXITS NoNet => Out[	"target network is not reachable or no such network\n\n"L];      END;      FinishProcess[net];      END;        MergeInfo: ENTRY PROCEDURE [i: Info] =      BEGIN      oldCount: CARDINAL = (IF info = NIL THEN 0 ELSE info.count);      info ¬ IncreaseInfo[info, i.count, z];      IF i.count # 0 THEN Inline.LongCOPY[        from: @i[0], to: @info[0], nwords: i.count * SIZE[InfoRec]];      END;        OutSearch: ENTRY PROCEDURE [net: System.NetworkNumber] =       BEGIN      Out["Searching net "L];      Format.NetworkNumber[Out, net, octal];      Out["\n"L];      END;        DisplayElapsedTime: PROC[      elapsed: LONG CARDINAL, responses: NetworkBinding.Responses] =      BEGIN      Format.LongDecimal[Out, System.PulsesToMicroseconds[[elapsed]] / 1000];      Out[" milliseconds to collect "L];      Format.Decimal[Out, responses.elementCount];      Out[        IF responses.elementCount = 1 THEN " response\n"L ELSE " responses\n"L];       END;  --DisplayElapsedTime    IF Exec.EndOfCommandLine[h] THEN RETURN;    z ¬ Heap.Create[initial: 20, increment: 20, swapUnitSize: 20,      ownerChecking: System.switches[PilotSwitches.heapOwnerChecking] = down];    UNTIL Exec.EndOfCommandLine[h] DO      token, switches: LONG STRING;      [token, switches] ¬ Exec.GetToken[h];      switches ¬ Exec.FreeTokenString[switches];      net ¬ Net[        String.StringToLongNumber[token, 8 ! String.InvalidNumber => CONTINUE]];      token ¬ Exec.FreeTokenString[token];      CountProcess[];      Process.Detach[FORK DoOneNet[net]];      ENDLOOP;        WaitDone[];    IF info = NIL THEN {Out["\nNo replies"L]; RETURN};    Out["\nSorting replies... "L];    info ¬ Sort[info];    Format.CR[Out];    FOR i: CARDINAL IN [0..info.count) DO      IF i = 0        OR NOT String.Equivalent[info[i - 1].bfVersion, info[i].bfVersion]        OR info[i - 1].bfCreateDate # info[i].bfCreateDate THEN {	IF count > 0 THEN DisplayCount[];        IF info[i].bfVersion.length = 0 THEN          Out["\nNo information available\n"L]        ELSE {          Format.CR[Out];          Out[info[i].bfVersion];          Format.Blank[Out];          Format.Date[Out, info[i].bfCreateDate, full];          Format.CR[Out]}};      count ¬ SUCC[count];      Format.Blank[Out, 2];      Format.NetworkAddress[Out, info[i].who, octal];      IF info[i].pVName.length > 0 THEN {        Out[" ["L];        Out[info[i].pVName];        Out["]<"L];        Out[info[i].sysVolName];        Out[">"L];        IF info[i].userName.length > 0 THEN {          Out[" user "L]; Out[info[i].userName]}};      Format.CR[Out];      REPEAT FINISHED => DisplayCount[];      ENDLOOP;    Heap.Delete[z, FALSE]};    IncreaseInfo: PROCEDURE [info: Info, count: CARDINAL, z: UNCOUNTED ZONE]    RETURNS [new: Info] = {    oldCount: CARDINAL = (IF info = NIL THEN 0 ELSE info.count);    new ¬ z.NEW[InfoSeq[oldCount + count]];    IF oldCount # 0 THEN Inline.LongCOPY[      from: @info[0], to: @new[count], nwords: oldCount * SIZE[InfoRec]];    z.FREE[@info]};  Net: PROCEDURE [x: LONG UNSPECIFIED] RETURNS [System.NetworkNumber] = {    RETURN[LOOPHOLE[Swap[x]]]};      CompareNet: PROCEDURE [a, b: System.NetworkNumber]    RETURNS [QuickSort.Comparison] = {    N: PROCEDURE [net: System.NetworkNumber] RETURNS [LONG CARDINAL] = {      RETURN Swap[LOOPHOLE[net]]};    nA: LONG CARDINAL = N[a];    nB: LONG CARDINAL = N[b];    RETURN[SELECT nA FROM < nB => smaller, nB => same, ENDCASE => bigger]};  Sort: PROCEDURE [info: Info] RETURNS [Info] = {    CompareProc: QuickSort.CompareProc = {      RETURN[        SELECT String.Compare[info[one].bfVersion, info[two].bfVersion] FROM          -1 => smaller,          1 => bigger,          ENDCASE =>            SELECT info[one].bfCreateDate FROM              < info[two].bfCreateDate => smaller,              > info[two].bfCreateDate => bigger,              ENDCASE => CompareNet[info[one].who.net, info[two].who.net]]};    SwapProc: QuickSort.SwapProc = {      temp: InfoRec = info[one]; info[one] ¬ info[two]; info[two] ¬ temp};    QuickSort.Sort[0, info.count - 1, CompareProc, SwapProc, NIL];    RETURN[info]};    Swap: PROCEDURE [x: LONG UNSPECIFIED] RETURNS [LONG UNSPECIFIED] = {    Long: TYPE = MACHINE DEPENDENT RECORD [a(0), b(1): UNSPECIFIED];    u, v: Long;    u ¬ LOOPHOLE[x];    [a: v.b, b: v.a] ¬ u;    RETURN[LOOPHOLE[v]]};  Init: PROCEDURE = {Exec.AddCommand["SurveyBF.~"L, ExecProc, HelpProc]};  Init[];  END...
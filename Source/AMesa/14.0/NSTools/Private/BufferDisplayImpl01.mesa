-- File: BufferDisplayImpl01.mesa - last edit:-- AOF                 28-Jun-87 13:29:52-- BKI                 25-Jul-88 12:26:56-- Copyright (C) 1984, 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  ArpaBuffer USING [Body],  ArpaTypes USING [InternetAddress, IpHeader],  Ascii USING [SP],  Buffer USING [Buffer, BufferObject],  BufferDisplay,  Checksums USING [TestChecksum],  IEEE8023 USING [Encapsulation, EncapObject, EthernetPacketType, LSAPAddress,    MACHeader, maxDataBytesPerEthernetPacket, minBytesPerEthernetPacket,    uiControl],  Environment USING [bitsPerByte, bitsPerWord, Block, Byte, bytesPerWord],  Inline USING [BITAND, BITNOT, BITOR, BITSHIFT, LongCOPY],  NSBuffer USING [Body],  NSTypes USING [    PacketType, TransportControl, bytesPerIDPHeader],  OSICLNetworkTypes USING [Body],  PupDefs USING [Body],  PupTypes USING [Byte, PupAddress, PupHostID, PupNetID, PupSocketID, PupType],  String USING [AppendChar, AppendNumber, AppendString, StringBoundsFault],  SpecialSystem USING [HostNumber],  System USING [HostNumber, NetworkAddress, NetworkNumber, SocketNumber];  BufferDisplayImpl01: PROGRAM  IMPORTS BufferDisplay, Checksums, Inline, String  EXPORTS BufferDisplay =  BEGIN      -- ERRORS    LineOverflow: PUBLIC SIGNAL = CODE;            -- PROCEDURES for converting arbitrarily long fields to strings.    AppendAscii: PROC [    field: Environment.Byte, string: LONG STRING] =    BEGIN    b2a: PACKED ARRAY [0..128) OF CHARACTER = [      '., '., '., '., '., '., '., '., '., '., '., '., '., '., '., '., '., '.,      '., '., '., '., '., '., '., '., '., '., '., '., '., '., ' , '!, '", '#,      '$, '%, '&, '', '(, '), '*, '+, ',, '-, '., '/, '0, '1, '2, '3, '4, '5,      '6, '7, '8, '9, ':, ';, '<, '=, '>, '?, '@, 'A, 'B, 'C, 'D, 'E, 'F, 'G,      'H, 'I, 'J, 'K, 'L, 'M, 'N, 'O, 'P, 'Q, 'R, 'S, 'T, 'U, 'V, 'W, 'X, 'Y,      'Z, '[, '\\, '], '­, '¬, '., 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k,      'l, 'm, 'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y, 'z, '{, '|, '},      '~, '.];    String.AppendChar[string, b2a[Inline.BITAND[field, 177B]]];    END;  -- AppendAscii          AppendDecimal: PROC [    field: LONG POINTER, sizeInWords: CARDINAL, string: LONG STRING,    suppressZero: BOOLEAN] =    BEGIN AppendNumber[field, sizeInWords, 10, string, suppressZero]; END;  AppendDecimalBlock: PROC [    field: Environment.Block, string: LONG STRING, suppressZero: BOOLEAN] =    BEGIN AppendNumberBlock [field, 10, string, suppressZero]; END;     AppendEbcdic: PROCEDURE [field: Environment.Byte, string: LONG STRING] =    BEGIN    b2e: PACKED ARRAY [0..256) OF CHARACTER = [      '., '., '., '., '., '., '., '., '., '., '., '., '., '., '., '., '., '.,      '., '., '., '., '., '., '., '., '., '., '., '., '., '., '., '., '., '.,      '., '., '., '., '., '., '., '., '., '., '., '., '., '., '., '., '., '.,      '., '., '., '., '., '., '., '., '., '., ' , '., '., '., '., '., '., '.,      '., '., '[, '., '<, '(, '), '|, '&, '., '., '., '., '., '., '., '., '.,      '!, '$, '*, '+, ';, '­, '-, '/, '., '., '., '., '., '., '., '., '|, ',,      '&, '¬, '>, '?, '., '., '., '., '., '., '., '., '., '., ':, '#, '@, '',      '=, '", '., 'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, '., '., '., '., '., '.,      '., 'j, 'k, 'l, 'm, 'n, 'o, 'p, 'q, 'r, '., '., '., '., '., '., '., '~,      's, 't, 'u, 'v, 'w, 'x, 'y, 'z, '., '., '., '., '., '., '., '., '., '.,      '., '., '., '., '., '., '., '., '., '., '., '., '{, 'A, 'B, 'C, 'D, 'E,      'F, 'G, 'H, 'I, '., '., '., '., '., '., '}, 'J, 'L, 'L, 'M, 'N, 'O, 'P,      'Q, 'R, '., '., '., '., '., '., '\\, '., 'S, 'T, 'U, 'V, 'W, 'X, 'Y, 'Z,      '., '., '., '., '., '., '0, '1, '2, '3, '4, '5, '6, '7, '8, '9, '., '.,      '., '., '., '.];          String.AppendChar[string, b2e[field]];    END;  -- AppendEbcdic                  AppendHeaderPiece: PUBLIC PROC [    format: BufferDisplay.Format, ptr: LONG POINTER, size: CARDINAL, --in words --    s: LONG STRING] =    BEGIN    SELECT format FROM      octal2, octal1, ebcdic, ascii => AppendOctal[ptr, size, s, TRUE];      hex => AppendNumber[ptr, size, 16, s, TRUE];      decimal => AppendDecimal[ptr, size, s, TRUE];      ENDCASE => ERROR;    END;  -- AppendHeaderPiece                   AppendHeaderBlock: PUBLIC PROC [    format: BufferDisplay.Format, blk: Environment.Block, s: LONG STRING] =    BEGIN    SELECT format FROM      octal2, octal1, ebcdic, ascii =>          FOR i: CARDINAL IN [blk.startIndex..blk.stopIndexPlusOne) DO          AppendOctal1[blk.blockPointer[i], s];          ENDLOOP;      hex => AppendNumberBlock[blk, 16, s, TRUE];      decimal => AppendDecimalBlock[blk, s, TRUE];      ENDCASE => ERROR;    END;  -- AppendHeaderBlock       AppendHex: PROC [   field: LONG POINTER, sizeInWords: CARDINAL, string: LONG STRING,   suppressZero: BOOLEAN] =   {AppendNumber[field, sizeInWords, 16, string, suppressZero]};   AppendHexBlock: PROC [    field: Environment.Block, string: LONG STRING, suppressZero: BOOLEAN] =    BEGIN AppendNumberBlock [field, 16, string, suppressZero]; END;       AppendArpaAddress: PUBLIC PROC [format: BufferDisplay.Format, s: LONG STRING,    iA: ArpaTypes.InternetAddress] =    BEGIN    AppendNumber: PROC[n: CARDINAL] = {      String.AppendNumber[s, n, radix];      IF radix # 10 THEN String.AppendChar[s, radixChar]};    radix: CARDINAL;    addr: MACHINE DEPENDENT RECORD [      octet1: Environment.Byte,      octet2: Environment.Byte,      octet3: Environment.Byte,      octet4: Environment.Byte];    radixChar: CHARACTER;    addr ¬ LOOPHOLE[iA];    SELECT format FROM      octal2, octal1 => {radix ¬ 8; radixChar ¬ 'B};      hex => {radix ¬ 16; radixChar ¬ 'H};      ENDCASE => {radix ¬ 10};    AppendNumber[addr.octet1];    String.AppendChar[s, '.];    AppendNumber[addr.octet2];    String.AppendChar[s, '.];    AppendNumber[addr.octet3];    String.AppendChar[s, '.];    AppendNumber[addr.octet4];    END;  --AppendArpaAddress        AppendNSAddress: PUBLIC PROC [format: BufferDisplay.Format, s: LONG STRING,    nA: System.NetworkAddress] =    BEGIN    SELECT format FROM      octal2, octal1, ebcdic, ascii =>         BEGIN	AppendOctal[@nA.net, SIZE[System.NetworkNumber], s, TRUE];	String.AppendChar[s, '.];	AppendOctal[@nA.host, SIZE[System.HostNumber], s, TRUE];	String.AppendChar[s, '.];	AppendOctal[@nA.socket, SIZE[System.SocketNumber], s, TRUE];	END;      hex =>      	BEGIN	AppendNumber[@nA.net, SIZE[System.NetworkNumber], 16, s, TRUE];	String.AppendChar[s, '.];	AppendNumber[@nA.host, SIZE[System.HostNumber], 16, s, TRUE];	String.AppendChar[s, '.];	AppendNumber[@nA.socket, SIZE[System.SocketNumber], 16, s, TRUE];	END;      decimal =>        BEGIN	AppendDecimal[@nA.net, SIZE[System.NetworkNumber], s, TRUE];	String.AppendChar[s, '.];	AppendDecimal[@nA.host, SIZE[System.HostNumber], s, TRUE];	String.AppendChar[s, '.];	AppendDecimal[@nA.socket, SIZE[System.SocketNumber], s, TRUE];	END;      ENDCASE => RETURN;    END;  -- AppendNSAddress         AppendNumber: PROC [     field: LONG POINTER, sizeInWords: CARDINAL, base: CARDINAL,     string: LONG STRING, suppressZero: BOOLEAN, leadingZero: BOOLEAN ¬ TRUE] =     BEGIN     digit, index, length: INTEGER;     array: ARRAY[0..20) OF CARDINAL;     char: STRING ¬ "0123456789ABCDEF"L;     IF (length ¬ SELECT base FROM       IN[2..8) => sizeInWords*Environment.bitsPerWord+1,       IN[8..10) => (sizeInWords*Environment.bitsPerWord+3)/3+1,       IN[10..16) => sizeInWords*Environment.bitsPerWord/3+1,       16 => sizeInWords*Environment.bitsPerWord/4+1,       ENDCASE => 0) = 0 THEN ERROR;     ConvertToBase[field, sizeInWords, base, DESCRIPTOR[array]];     FOR index IN[0..length) DO IF array[index] = base THEN EXIT; ENDLOOP;     IF ~suppressZero THEN FOR digit IN [0..length - index - 1) DO       String.AppendChar[string, char[0]];       ENDLOOP     ELSE IF leadingZero AND array[index-1] > 9 THEN       String.AppendChar[string, '0];     FOR digit DECREASING IN [0..index) DO       String.AppendChar[string, char[array[digit]]];       ENDLOOP;     SELECT base FROM       8 => String.AppendChar[string, 'B];       16 => String.AppendChar[string, 'H];       ENDCASE;     END;         AppendNumberBlock: PROC [     field: Environment.Block, base: CARDINAL, string: LONG STRING,     -- suppressZero not yet implemented -- suppressZero: BOOLEAN] =     BEGIN     tempString: STRING ¬ [Environment.bitsPerByte + 1];     digit, index, length, number: CARDINAL;     IF (length ¬ SELECT base FROM       >= 16 => 2,       >= 7 => 3,       >= 4 => 4,       3 => 6,       2 => 8,       ENDCASE => 0) = 0 THEN ERROR;     FOR index IN [field.startIndex..field.stopIndexPlusOne) DO       number ¬ field.blockPointer[index];       tempString.length ¬ 0;       AppendNumber [@number, 1, base, tempString, TRUE, FALSE];       tempString.length ¬ tempString.length - 1;       FOR digit IN [tempString.length..length) DO         String.AppendChar[string, '0];         ENDLOOP;       String.AppendString[string, tempString];       ENDLOOP;     IF field.startIndex < field.stopIndexPlusOne THEN       SELECT base FROM         8 => String.AppendChar[string, 'B];       --16 => String.AppendChar[string, 'H];         ENDCASE;     END;         AppendOctal: PROC [     field: LONG POINTER, sizeInWords: CARDINAL, string: LONG STRING,     suppressZero: BOOLEAN] =     BEGIN AppendNumber[field, sizeInWords, 8, string, suppressZero]; END;  AppendOctal1: PROCEDURE [field: Environment.Byte, s: LONG STRING] =    BEGIN    String.AppendChar[s, Inline.BITAND[Inline.BITSHIFT[field, -6], 3B] + '0];    String.AppendChar[s, Inline.BITAND[Inline.BITSHIFT[field, -3], 7B] + '0];    String.AppendChar[s, Inline.BITAND[field, 7B] + '0];    String.AppendChar[s, 'B];    String.AppendChar[s, Ascii.SP];    END;  -- AppendOctal1    	  AppendPupAddress: PUBLIC PROC [format: BufferDisplay.Format, s: LONG STRING,    pA: PupTypes.PupAddress] =    BEGIN    net: RECORD[filler: Environment.Byte, n: PupTypes.PupNetID] ¬      [0, pA.net];    host: RECORD[filler: Environment.Byte, n: PupTypes.PupHostID] ¬      [0, pA.host];    SELECT format FROM      octal2, octal1, ebcdic, ascii =>        BEGIN	AppendOctal[@net, 1, s, TRUE];	String.AppendChar[s, '#];	AppendOctal[@host, 1, s, TRUE];	String.AppendChar[s, '#];	AppendOctal[@pA.socket, SIZE[PupTypes.PupSocketID], s, TRUE];	END;      hex =>        BEGIN	AppendNumber[@net, 1, 16, s, TRUE];	String.AppendChar[s, '#];	AppendNumber[@host, 1, 16, s, TRUE];	String.AppendChar[s, '#];        AppendNumber[@pA.socket, SIZE[PupTypes.PupSocketID], 16, s, TRUE];	END;      decimal =>        BEGIN	AppendDecimal[@net, 1, s, TRUE];	String.AppendChar[s, '#];	AppendDecimal[@host, 1, s, TRUE];	String.AppendChar[s, '#];	AppendDecimal[@pA.socket, SIZE[PupTypes.PupSocketID], s, TRUE];	END;      ENDCASE => RETURN;    END;  -- AppendPupAddress  BodyAssumingEthernet: PROC[b: Buffer.Buffer] RETURNS[ptr: LONG POINTER] =    BEGIN      [ptr, ] ¬ FindBufferBodyAndType [b];    END;              ConvertToBase: PROC [    field: LONG POINTER, size, base: CARDINAL,    array: LONG DESCRIPTOR FOR ARRAY OF CARDINAL] =    BEGIN    index: INTEGER;    bit: CARDINAL;    copy: ARRAY [0..20] OF CARDINAL;    Inline.LongCOPY[field, size, @copy];    FOR index IN[1..LENGTH[array]) DO      array[index] ¬ base;      ENDLOOP;    array[0] ¬ 0;    THROUGH [0..size*Environment.bitsPerWord) DO      bit ¬ ShiftFieldLeft[@copy, size, 1, 0];      FOR index ¬ 0, index + 1 UNTIL array[index] = base DO        array[index] ¬ array[index] * 2 + bit;	IF array[index] >= base THEN	  BEGIN          array[index] ¬ array[index] - base;	  bit ¬ 1;	  IF array[index+1] = base THEN array[index+1] ¬ 0;	  END	ELSE bit ¬ 0;  	ENDLOOP;      ENDLOOP;    END;  -- ConvertToBase  FindBufferBodyAndType: PUBLIC PROC [b: Buffer.Buffer]     RETURNS [ptr: LONG POINTER, type: IEEE8023.EthernetPacketType] =    BEGIN    e: IEEE8023.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];    eWords: CARDINAL ¬ 0;    MACAdjust: CARDINAL =       ((SIZE[IEEE8023.MACHeader] + 1) * Environment.bytesPerWord);    SELECT TRUE FROM      b.fo.driver.device = phonenet => {        eWords ¬ SIZE[IEEE8023.EncapObject.ethernet];         type ¬ ns};      (e.llc.length <= IEEE8023.maxDataBytesPerEthernetPacket) AND (        IF b.fo.driver.length = IEEE8023.minBytesPerEthernetPacket THEN	  e.llc.length + MACAdjust <= IEEE8023.minBytesPerEthernetPacket	ELSE --e.llc.length + MACAdjust = b.fo.driver.length--	--The above test is insufficient because b.fo.driver.length is	--allowed to be the smallest even number >= actual length.  Thus,	--we need to use the more awkward test:	  b.fo.driver.length - (e.llc.length + MACAdjust) <=	  (e.llc.length + MACAdjust) MOD 2) =>          IF e.llc.dsapAddress = escape THEN {          eWords ¬ SIZE[IEEE8023.EncapObject.osi8022.snap];          type ¬ e.snapType}         ELSE {          eWords ¬ SIZE[IEEE8023.EncapObject.osi8022.standard];          type ¬ osi};      ENDCASE => {        eWords ¬ IF e.ethernetType = osi THEN SIZE[IEEE8023.EncapObject.hybrid]          ELSE SIZE[IEEE8023.EncapObject.ethernet];        type ¬ e.ethernetType};      RETURN [e + eWords, type];    END;        ShiftFieldLeft: PROCEDURE[    ptr: LONG POINTER, size: CARDINAL, shift: INTEGER, new: CARDINAL]    RETURNS [lost: CARDINAL] =  <<  Shift field pointed to by "ptr" and of size (words) "size" left "shift"    places.  Save the bits lost off the left end in "lost" and add bits "new" to right end  of field.  >>   BEGIN   saveMask: CARDINAL = Inline.BITNOT [Inline.BITSHIFT [177777B, -shift]];   ptr ¬ ptr+size;   THROUGH [0..size) DO	 ptr ¬ ptr-1;	 lost ¬ Inline.BITAND [ptr­, saveMask];	 ptr­ ¬ Inline.BITSHIFT [ptr­, shift];	 ptr­ ¬ Inline.BITOR [ptr­, new];	 new ¬ lost ¬ Inline.BITSHIFT [lost, shift-Environment.bitsPerWord];      ENDLOOP;   END;  -- ShiftFieldLeft                      -- PROCEDURES for displaying buffers.           Encapsulation: PUBLIC PROC[b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    AppendBadHeaderPiece: PROC [field: CARDINAL] =      BEGIN      String.AppendString[line, "??("L];      AppendHeaderPiece[format, @field, 1, line];      String.AppendChar[line, ')];      END;    String.AppendString[line, "  Encapsulation["L];    SELECT b.fo.driver.device FROM      ethernet =>        BEGIN	e: IEEE8023.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];        MACAdjust: CARDINAL =           ((SIZE[IEEE8023.MACHeader] + 1) * Environment.bytesPerWord);        AppendEthernetAddresses: PROC =	  BEGIN          String.AppendChar[line, '.];     	  AppendHeaderPiece[format, @e.ethernetDest, 	    SIZE[SpecialSystem.HostNumber], line];	  String.AppendString[line, ". ¬ ."L];	  AppendHeaderPiece[format, @e.ethernetSource,	    SIZE[SpecialSystem.HostNumber], line];          String.AppendChar[line, '.];	  END;        AppendEthernetType: PROC [type: IEEE8023.EthernetPacketType, list: BOOL] =	  BEGIN          IF list THEN 	    String.AppendString[line, ", type: "L]	  ELSE String.AppendString[line, "type: "L];          SELECT type FROM            echoMe => String.AppendString[line, "echoMe"L];	    echoed => String.AppendString[line, "echoed"L]; 	    pup, newpup => String.AppendString[line, "pup"L];	    translation, newtranslation => String.AppendString[line, "translation"L];	    ns => String.AppendString[line, "ns"L];	    arpa => String.AppendString[line, "arpa"L];            osi => String.AppendString[line, "osi"L];	    LOOPHOLE[4007B] => String.AppendString[line, "cts"L];	    ENDCASE => AppendBadHeaderPiece[ORD[type]];	  END;        AppendLLCLength: PROC [maxLength: CARDINAL] =	  BEGIN          String.AppendString[line, ", len: "L];          IF e.llc.length + MACAdjust < maxLength THEN            AppendBadHeaderPiece[e.llc.length]          ELSE AppendHeaderPiece [format, @e.llc.length, 1, line];	  END;        AppendLLCControl: PROC = INLINE	  BEGIN          byteData: RECORD [filler, data: Environment.Byte] ¬ [0, e.control];          String.AppendString[line, "control: "L];          IF e.control = IEEE8023.uiControl THEN            AppendHeaderPiece[format, @byteData, 1, line]          ELSE AppendBadHeaderPiece[e.control];	  END;        AppendLSAP: PROC [LSAP: IEEE8023.LSAPAddress] =	  BEGIN          SELECT LSAP FROM            null=> String.AppendString[line, "null"L];            indMgmtFn => String.AppendString[line, "indMgmt"L];	    grpMgmtFn => String.AppendString[line, "grpMgmt"L];	    escape => String.AppendString[line, "escape"L];	    iso8473 => String.AppendString[line, "iso8473"L];            global => String.AppendString[line, "global"L];          ENDCASE => AppendBadHeaderPiece [ORD[LSAP]];	  END;        AppendLSAPs: PROC = INLINE	  BEGIN          String.AppendString[line, ", ."L];	  AppendLSAP [e.llc.dsapAddress];     	  String.AppendString[line, ". ¬ ."L];	  AppendLSAP [e.llc.ssapAddress];          String.AppendChar[line, '.];	  END;        IF (e.llc.length <= IEEE8023.maxDataBytesPerEthernetPacket) AND	   (IF b.fo.driver.length = IEEE8023.minBytesPerEthernetPacket THEN	      e.llc.length + MACAdjust <= IEEE8023.minBytesPerEthernetPacket	    ELSE --e.llc.length + MACAdjust = b.fo.driver.length--	    --The above test is insufficient because b.fo.driver.length is	    --allowed to be the smallest even number >= actual length.  Thus,	    --we need to use the more awkward test:	      b.fo.driver.length - (e.llc.length + MACAdjust) <=	      (e.llc.length + MACAdjust) MOD 2) THEN	  BEGIN          String.AppendString[line, "802.3["L];          AppendEthernetAddresses [];          IF e.llc.dsapAddress = escape THEN            BEGIN            AppendLLCLength [SIZE[IEEE8023.EncapObject.osi8022.snap]];            String.AppendString[line, "], 802.2 snap["L];            AppendEthernetType [type: e.snapType, list: FALSE];            String.AppendChar[line, ']];    	    END	    ELSE BEGIN            AppendLLCLength [SIZE[IEEE8023.EncapObject.osi8022.standard]];            String.AppendString[line, "], 802.2 standard["L];            AppendLLCControl [];	    AppendLSAPs[];            AppendEthernetType [type: osi, list: TRUE];            String.AppendChar[line, ']];	    END;       	  END	ELSE BEGIN	  String.AppendString[line, "ethernet["L];          AppendEthernetAddresses [];          AppendEthernetType [type: e.ethernetType, list: TRUE];          String.AppendChar[line, ']];          END;	END;  -- ethernet encapsulation.<<	      ethernetOne =>        BEGIN	e: EtherOneMAC.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];        AppendEtherOneAddresses: PROC = INLINE	  BEGIN	  ether1Dest: RECORD[filler, d: Environment.Byte] ¬	    [0, e.ethernetOneDest];	  ether1Source: RECORD[filler, s: Environment.Byte] ¬	    [0, e.ethernetOneSource];          String.AppendChar[line, '#];	  AppendHeaderPiece[format, @ether1Dest, 1, line];	  String.AppendString[line, "# ¬ #"L];	  AppendHeaderPiece[format, @ether1Source, 1, line];          String.AppendChar[line, '#];	  END;        AppendEthernetOneType: PROC = INLINE	  BEGIN          String.AppendString[line, ", type: "L];    	  SELECT e.ethernetOneType FROM	    peekData => String.AppendString[line, "peekData"L];	    breathOfLife => String.AppendString[line, "breathOfLife"L];	    echoMe => String.AppendString[line, "echoMe"L];	    echoed => String.AppendString[line, "echoed"L];	    pup, newpup => String.AppendString[line, "pup"L];	    ns => String.AppendString[line, "ns"L];	    translation => String.AppendString[line, "translation"L];	    ENDCASE => AppendBadHeaderPiece [e.ethernetOneType];	  END;        String.AppendString[line, "ethernetOne["L];        AppendEtherOneAddresses [];        AppendEtherOneType [];        String.AppendChar[line, ']];	END;  -- ethernetOne encapsulation.>>	      	                  ENDCASE => String.AppendString[line, "??[#"L];    String.AppendChar[line, ']];    outProc[line];    line.length ¬ 0;    END;  -- Encapsulation          IPFields: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =      BEGIN      body: ArpaBuffer.Body = BodyAssumingEthernet[b];      ip: LONG POINTER TO ArpaTypes.IpHeader = @body.ipHeader;      frag: CARDINAL ¬ ip.fragment;      byteData: RECORD [filler, data: Environment.Byte];      String.AppendString[line, "  IP[ver: "L];      byteData ¬ [0, LOOPHOLE[ip.version]];      AppendHeaderPiece[format, @byteData, 1, line];      String.AppendString[line, ", ihl: "L];      byteData ¬ [0, ip.ihl];      AppendHeaderPiece[format, @byteData, 1, line];      String.AppendString[line, ", tos["L];      SELECT ip.service.precedence FROM        routine => String.AppendString[line, "routine, "L];	priority => String.AppendString[line, "priority, "L];	immediate => String.AppendString[line, "immediate, "L];	flash => String.AppendString[line, "flash, "L];	flashOverride => String.AppendString[line, "flashOverride, "L];	criticEcp => String.AppendString[line, "criticEcp, "L];	internetControl => String.AppendString[line, "internetControl, "L];	networkControl => String.AppendString[line, "networkControl, "L];	ENDCASE =>	  {String.AppendString[line, "??("L];	  byteData ¬ [0, LOOPHOLE[ip.service.precedence]];	  AppendHeaderPiece[format, @byteData, 1, line];	  String.AppendString[line, "), "L]};      IF ip.service.delay THEN String.AppendString[line, "delay, "L];      IF ip.service.throughput THEN String.AppendString[line, "throughput, "L];      IF ip.service.reliability THEN String.AppendString[line, "reliability, "L];      byteData ¬ [0, LOOPHOLE[ip.service.reserved]];      AppendHeaderPiece[format, @byteData, 1, line];      String.AppendString[line, "], len: "L];      AppendHeaderPiece[format, @ip.length, 1, line];      String.AppendString[line, ", id: "L];      AppendHeaderPiece[format, @ip.identification, 1, line];      String.AppendString[line, ", flags[reserved: "L];      byteData ¬ [0, LOOPHOLE[ip.flags.reserved]];      AppendHeaderPiece[format, @byteData, 1, line];      IF ip.flags.dontFragment THEN String.AppendString[line, ", dontFrag"L];      IF ip.flags.moreFragment THEN String.AppendString[line, ", moreFrag"L];      String.AppendString[line, "], frag: "L];      AppendHeaderPiece[format, @frag, 1, line];      String.AppendString[line, ", lifetime: "L];      byteData ¬ [0, ip.lifetime];      AppendHeaderPiece[format, @byteData, 1, line];      String.AppendString[line, ", protocol: "L];      SELECT ip.protocol FROM        icmp => String.AppendString[line, "icmp"L];	interGateway => String.AppendString[line, "interGateway"L];	gmcc => String.AppendString[line, "gmcc"L];	st => String.AppendString[line, "st"L];	tcp => String.AppendString[line, "tcp"L];	ucl => String.AppendString[line, "ucl"L];	sicure => String.AppendString[line, "sicure"L];	bbnRccMon => String.AppendString[line, "bbnRccMon"L];	nvp => String.AppendString[line, "nvp"L];	pup => String.AppendString[line, "pup"L];	pluribus => String.AppendString[line, "pluribus"L];	telnet => String.AppendString[line, "telnet"L];	xnet => String.AppendString[line, "xnet"L];	chaos => String.AppendString[line, "chaos"L];	userDatagram => String.AppendString[line, "userDatagram"L];	multiplexing => String.AppendString[line, "multiplexing"L];	dcn => String.AppendString[line, "dcn"L];	tacMon => String.AppendString[line, "tacMon"L];	localNetwork => String.AppendString[line, "localNetwork"L];	satnet => String.AppendString[line, "satnet"L];	mitSubnet => String.AppendString[line, "mitSubnet"L];	satnetMon => String.AppendString[line, "satnetMon"L];	ipCoreUtil => String.AppendString[line, "ipCoreUtil"L];	backroomSatnetMon => String.AppendString[line, "backroomSatnetMon"L];	widebandMon => String.AppendString[line, "widebandMon"L];	widbandExpak => String.AppendString[line, "widbandExpak"L];	ENDCASE =>	  {String.AppendString[line, "??("L];	  byteData ¬ [0, LOOPHOLE[ip.protocol]];	  AppendHeaderPiece[format, @byteData, 1, line];	  String.AppendString[line, ")"L]};      String.AppendString[line, ", checksum: "L];      AppendHeaderPiece[format, @ip.checksum, 1, line];      String.AppendString[line, ", "L];      AppendArpaAddress[decimal, line, ip.destination];      String.AppendString[line, " ¬ "L];      AppendArpaAddress[decimal, line, ip.source];      String.AppendString[line, "]"L];      outProc[line];      line.length ¬ 0;      END;  --IPFields     Level0Packet: PUBLIC PROC[b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    --Displays level 0 packet (i.e. treats level 1 and 2 headers as data).    ENABLE LineOverflow =>      {String.AppendString[line, " ..."L];      outProc[line];      line.length ¬ 0;      CONTINUE};    l1Type: IEEE8023.EthernetPacketType;    Encapsulation[b, line, format, outProc];    [ , l1Type] ¬ FindBufferBodyAndType [b];    IF l1Type = osi    THEN PacketDataBlock           [format, b, [LOOPHOLE [@b.rawWords, LONG POINTER], 0, 0],	   line, outProc ]    ELSE PacketData[format, b, @b.rawWords, line, outProc ];    END;  -- Level0Packet          Level1Packet: PUBLIC PROC[b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    -- Displays a level 1 packet (i.e. treats 2 headers as data).    ENABLE LineOverflow =>      {String.AppendString[line, " ..."L];      outProc[line];      line.length ¬ 0;      GOTO exit};    l1Type: IEEE8023.EthernetPacketType;    Encapsulation[b, line, format, outProc];    [ ,l1Type] ¬ FindBufferBodyAndType [b];    SELECT l1Type FROM      ns => IDPFields[b, line, format, outProc];      pup, newpup => PupFields[b, line, format, outProc];      arpa => IPFields[b, line, format, outProc];      osi => BufferDisplay.OsiIPFields[b, line, format, outProc];      ENDCASE =>  -- unknown level 1 type.        {PacketData[format, b, @b.rawWords, line, outProc];        RETURN};    IF l1Type = osi    THEN PacketDataBlock           [format, b, [b.highLayer.blockPointer, 1, 0], line, outProc]    ELSE PacketData[format, b, b.highLayer.blockPointer, line, outProc];    EXITS exit => NULL;    END;  -- Level1Packet    	  IDPFields: PUBLIC PROC[b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    body: NSBuffer.Body = BodyAssumingEthernet[b];    control: RECORD[filler: Environment.Byte, c: NSTypes.TransportControl] ¬ [       0, body.transportControl];    type: RECORD[filler: Environment.Byte, packet: NSTypes.PacketType] ¬ [        0, body.packetType];    String.AppendString[line, "  NS[checksum: "L];    AppendHeaderPiece[format, @body.checksum, 1, line];    SELECT TRUE FROM      (body.pktLength ~IN[        NSTypes.bytesPerIDPHeader..b.fo.driver.length]) =>	String.AppendString[line, "**"L];      (~Checksums.TestChecksum[body]) => String.AppendString[line, "**"L];      ENDCASE;    String.AppendString[line, ", control: "L];    AppendHeaderPiece[format, @control, 1, line];    String.AppendString[line, ", length: "L];    AppendHeaderPiece[format, @body.pktLength, 1, line];    String.AppendString[line, ", type: "L];    SELECT body.packetType FROM      private => String.AppendString[line, "private, "L];      routingInformation => String.AppendString[line, "routing, "L];      echo => String.AppendString[line, "echo, "L];      error => String.AppendString[line, "error, "L];      packetExchange => String.AppendString[line, "pex, "L];      sequencedPacket => String.AppendString[line, "spp, "L];      pupAddrTransPacket => String.AppendString[line, "pupAddrTrans, "L];      ubBootPacket => String.AppendString[line, "ubBoot, "L];      ubIPCPacket => String.AppendString[line, "ubIPCPacket, "L];      bootServerPacket => String.AppendString[line, "boot, "L];      electronicMailCacheFlushPacket => String.AppendString[line,        "mailCacheFlush, "L];      ubDiagnosticPacket => String.AppendString[line, "ubDiag, "L];      pccPacket => String.AppendString[line, "pcc, "L];      oldTimeServer => String.AppendString[line, "oldTimeServer, "L];      ENDCASE => {String.AppendString[line, "??("L];                  AppendHeaderPiece[format, @type, 1, line];         	  String.AppendString[line, "), "L]};    AppendNSAddress[format, line, body.destination];    String.AppendString[line, " ¬ "L];    AppendNSAddress[format, line, body.source];    String.AppendString[line, "]"L];    outProc[line];    line.length ¬ 0;    END;  -- IDPFields              PacketData: PUBLIC PROC [    format: BufferDisplay.Format, b: Buffer.Buffer, start: LONG POINTER,    line: LONG STRING, outProc: BufferDisplay.OutputProc] =    BEGIN    ENABLE String.StringBoundsFault => {      line.length ¬ line.length - 4;  ERROR LineOverflow};    <<    Displays the packet's data.  Since the definition of data differs    depending upon the protocol level, clients must set <start> to the beginning    of the portion of packet they wish to treat as data.    >>    encapInfo: RECORD [body: LONG POINTER, type: IEEE8023.EthernetPacketType];    usedLinkLayer, usedHighLayer: CARDINAL;    dataLen: CARDINAL;    buffer: LONG POINTER ¬ start;    i: CARDINAL ¬ 0;    <<    amount of buffer (excluding encapsulation) that has already been    displayed or discarded.    >>    [encapInfo.body, encapInfo.type] ¬ FindBufferBodyAndType [b];    usedLinkLayer ¬ CARDINAL[start - b.linkLayer.blockPointer];    usedHighLayer ¬ CARDINAL[start - encapInfo.body];    -- calculate the length of the data.    IF LOOPHOLE [start, LONG ORDERED POINTER] <       LOOPHOLE [encapInfo.body, LONG ORDERED POINTER] THEN      dataLen ¬ b.fo.driver.length - (usedLinkLayer * 2)    ELSE BEGIN      SELECT encapInfo.type FROM        ns => {	  body: NSBuffer.Body ¬ encapInfo.body;          dataLen ¬ body.pktLength - (usedHighLayer * 2)};	pup, newpup => {	  body: PupDefs.Body ¬ encapInfo.body;          dataLen ¬ body.pupLength - (usedHighLayer * 2)};	arpa => {	  body: ArpaBuffer.Body ¬ encapInfo.body;          dataLen ¬ body.ipHeader.length - (usedHighLayer * 2)};	osi => {	  body: OSICLNetworkTypes.Body ¬ encapInfo.body;          dataLen ¬ body.ip.segmentLength + 1 - (usedHighLayer * 2)};	ENDCASE => dataLen ¬ b.fo.driver.length - (usedLinkLayer * 2);    END;    IF dataLen = 0 THEN RETURN;    String.AppendString[line, "    ("L];      AppendHeaderPiece[format, @dataLen, 1, line];    String.AppendChar[line, ')];    SELECT format FROM      octal2 =>        FOR i IN [0.. (dataLen + 1)/2) DO	  AppendOctal[(buffer+i), 1, line, FALSE];	  String.AppendChar[line, Ascii.SP];	  IF (line.length >= line.maxlength -12) THEN	    SIGNAL LineOverflow; 	  ENDLOOP;      octal1 =>	BEGIN	byteBuf: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬	  buffer;	FOR i IN [0..dataLen) DO	  AppendOctal1[byteBuf[i], line];	  IF (line.length >= line.maxlength -13) THEN	    SIGNAL LineOverflow; 	  ENDLOOP;        END;      hex =>	FOR i IN [0.. (dataLen + 1)/2) DO	  AppendNumber[(buffer+i), 1, 16, line, FALSE];	  String.AppendChar[line, Ascii.SP];	  IF (line.length >= line.maxlength -10) THEN	    SIGNAL LineOverflow;	  ENDLOOP;      decimal =>	FOR i IN [0.. (dataLen + 1)/2) DO	  AppendDecimal[(buffer+i), 1, line, FALSE];	  String.AppendChar[line, Ascii.SP];	  IF (line.length >= line.maxlength -10) THEN	    SIGNAL LineOverflow;	  ENDLOOP;      ascii =>	BEGIN	byteBuf: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬	  buffer;	FOR i IN [0.. dataLen) DO	  AppendAscii[byteBuf[i], line];	  IF (line.length >= line.maxlength -6) THEN	    SIGNAL LineOverflow;	  ENDLOOP;        END;      ebcdic =>        BEGIN	byteBuf: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬	  buffer;	FOR i IN [0.. dataLen) DO	  AppendEbcdic[byteBuf[i], line];	  IF (line.length >= line.maxlength -6) THEN	    SIGNAL LineOverflow;	  ENDLOOP;        END;      ENDCASE => ERROR;    outProc[line];    line.length ¬ 0;    END;  -- PacketData               PacketDataBlock: PUBLIC PROC [    format: BufferDisplay.Format, b: Buffer.Buffer, start: Environment.Block,    line: LONG STRING, outProc: BufferDisplay.OutputProc] =    BEGIN    ENABLE String.StringBoundsFault => {      line.length ¬ line.length - 4;  ERROR LineOverflow};    <<    Displays the packet's data.  Since the definition of data differs    depending upon the protocol level, clients must set <start> to the beginning    of the portion of packet they wish to treat as data.    >>    encapInfo: RECORD [body: LONG POINTER, type: IEEE8023.EthernetPacketType];    usedLinkLayer, usedHighLayer: CARDINAL;    dataLen: CARDINAL;    i: CARDINAL ¬ 0;    <<    amount of buffer (excluding encapsulation) that has already been    displayed or discarded.    >>    start.blockPointer ¬ start.blockPointer + start.startIndex / 2;    start.startIndex ¬ start.startIndex MOD 2;    [encapInfo.body, encapInfo.type] ¬ FindBufferBodyAndType [b];    usedLinkLayer ¬ CARDINAL[(start.blockPointer - b.linkLayer.blockPointer) * 2];    usedHighLayer ¬ CARDINAL[(start.blockPointer - encapInfo.body) * 2];    -- calculate the length of the data.    IF LOOPHOLE [start.blockPointer, LONG ORDERED POINTER] <       LOOPHOLE [encapInfo.body, LONG ORDERED POINTER] THEN      dataLen ¬ b.fo.driver.length - usedLinkLayer - start.startIndex    ELSE BEGIN      SELECT encapInfo.type FROM        ns => {	  body: NSBuffer.Body ¬ encapInfo.body;          dataLen ¬ body.pktLength - usedHighLayer - start.startIndex};	pup, newpup => {	  body: PupDefs.Body ¬ encapInfo.body;          dataLen ¬ body.pupLength - usedHighLayer - start.startIndex};	arpa => {	  body: ArpaBuffer.Body ¬ encapInfo.body;          dataLen ¬ body.ipHeader.length - usedHighLayer - start.startIndex};	osi => {	  body: OSICLNetworkTypes.Body ¬ encapInfo.body;          dataLen ¬	    body.ip.segmentLength + 1 - usedHighLayer - start.startIndex};	ENDCASE => 	  dataLen ¬ b.fo.driver.length - usedLinkLayer - start.startIndex;    END;    -- if caller didn't bother to provide stop, calculate it     IF start.stopIndexPlusOne = 0 THEN      start.stopIndexPlusOne ¬ start.startIndex + dataLen;    IF dataLen = 0 THEN RETURN;    String.AppendString[line, "    ("L];      AppendHeaderPiece[format, @dataLen, 1, line];    String.AppendChar[line, ')];    SELECT format FROM      octal1, octal2 =>        BEGIN        FOR i IN [start.startIndex..start.stopIndexPlusOne) DO	  IF (line.length >= line.maxlength -8) THEN	    SIGNAL LineOverflow; 	  AppendOctal1[start.blockPointer[i], line];	  ENDLOOP;        END;      hex =>        FOR i IN [start.startIndex..start.stopIndexPlusOne) DO	  AppendNumberBlock[[start.blockPointer, i, i+1], 16, line, FALSE];	  String.AppendChar[line, Ascii.SP];	  ENDLOOP;      decimal =>	FOR i IN [start.startIndex..start.stopIndexPlusOne) DO	  IF (line.length >= line.maxlength -8) THEN	    SIGNAL LineOverflow;	  AppendDecimalBlock[[start.blockPointer + i, 0, 1], line, FALSE];	  String.AppendChar[line, Ascii.SP];	  ENDLOOP;      ascii =>	BEGIN	FOR i IN [start.startIndex..start.stopIndexPlusOne) DO	  IF (line.length >= line.maxlength -6) THEN	    SIGNAL LineOverflow;	  AppendAscii[start.blockPointer[i], line];	  ENDLOOP;	END;      ebcdic =>	BEGIN        FOR i IN [start.startIndex..start.stopIndexPlusOne) DO	  IF (line.length >= line.maxlength -6) THEN	    SIGNAL LineOverflow;	  AppendEbcdic[start.blockPointer[i], line];	  ENDLOOP;	END;      ENDCASE => ERROR;    outProc[line];    line.length ¬ 0;    END;  -- PacketDataBlock            PupFields: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    body: PupDefs.Body = BodyAssumingEthernet[b];    control: RECORD[filler: Environment.Byte, c: PupTypes.Byte] ¬ [      0, body.pupTransportControl];    type: RECORD[filler: Environment.Byte, t: PupTypes.PupType] ¬ [      0, body.pupType];    String.AppendString[line, "  Pup[pupLength: "L];    AppendHeaderPiece[format, @body.pupLength, 1, line];    String.AppendString[line, ", control: "L];    AppendHeaderPiece[format, @control, 1, line];    String.AppendString[line, ", pupType: "L];    SELECT body.pupType FROM      echoMe => String.AppendString[line, "echoMe"L];      iAmEcho => String.AppendString[line, "iAmEcho"L];      badEcho => String.AppendString[line, "badEcho"L];      error => String.AppendString[line, "error"L];      rfc => String.AppendString[line, "rfc"L];      abort => String.AppendString[line, "abort"L];      end => String.AppendString[line, "end"L];      endRep => String.AppendString[line, "endRep"L];      data => String.AppendString[line, "data"L];      aData => String.AppendString[line, "aData"L];      ack => String.AppendString[line, "ack"L];      mark => String.AppendString[line, "mark"L];      int => String.AppendString[line, "int"L];      intRep => String.AppendString[line, "intRep"L];      aMark => String.AppendString[line, "aMark"L];      eData => String.AppendString[line, "eData"L];      eAck => String.AppendString[line, "eAck"L];      eEnd => String.AppendString[line, "eEnd"L];      eAbort => String.AppendString[line, "eAbort"L];      rpp => String.AppendString[line, "rpp"L];      gatewayRequest => String.AppendString[line, "gatewayRequest"L];      gatewayInfo => String.AppendString[line, "gatewayInfo"L];      ENDCASE => {        String.AppendString[line, "??("L];        AppendHeaderPiece[format, @type, 1, line];        String.AppendString[line, ")"L]};    String.AppendString[line, ", pupID[a: "L];    AppendHeaderPiece[format, @body.pupID.a, 1, line];    String.AppendString[line, ", b: "L];    AppendHeaderPiece[format, @body.pupID.b, 1, line];    String.AppendString[line, ", "L];    AppendPupAddress[format, line, body.dest];    String.AppendString[line, " ¬ "L];    AppendPupAddress[format, line, body.source];    String.AppendString[line, "]"L];    outProc[line];    line.length ¬ 0;    END;  -- PupFields        END.LOG 8-Jun-83 11:23:56  SMA  Created file.13-Jul-83 14:14:33  SMA  Folded AppendInAsciiImpl in.13-Jul-83 14:14:33  SMA  Fixed lengths (really, this time).23-Nov-83 12:33:52  SMA  Level2Packet supresses output of line for each header. 7-Mar-84 13:50:53  SMA  Look at b.encapsulation.ethernetType instead of b.type.15-Jun-84 10:08:12  SMA  Added UPIPCPacket.27-Sep-84 11:00:19  SMA  Moved all level 2 display routines to BufferDisplayImpl225-Oct-84 15:17:50  SMA  Added message exchange.10-Apr-85 16:50:13  SMA  Testing ns checksums. 9-Oct-85 15:01:47  SMA  set line.length to 0 after calling outProc.23-Jul-86 14:32:55  AOF  Replace '# with '. in level-0 printout24-Nov-86 16:58:18  AOF  New buffer package23-Jun-87 18:18:39  BKI  Convert to new OSI definitions.28-Jun-87 13:29:38  AOF  Change EtherMAC => IEEE8023.18-Aug-87 16:09:09  BKI  Fix IEEE8023 decapsulation procs.15-Apr-88 15:01:21  BKI  Minimized string length in AppendNumberBlock.28-Apr-88 13:03:41  BKI  Added leadingZero argument to AppendNumber.25-Jul-88 12:26:56  BKI  AppendArpaAddress[format: decimal].
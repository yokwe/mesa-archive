-- File: MataHariToolImpl.mesa - last edit:-- AOF                 19-May-88 16:45:51-- BKI                  2-Jul-87 19:04:54-- JAV                 20-Apr-87 14:38:49-- NS                  11-Feb-87 16:32:18-- SMA                 17-Apr-86 18:55:15-- Copyright (C) 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [Error, ErrorRecord, StringToNetworkAddress],  Buffer USING [AccessHandle, Buffer, BufferObject, DestroyPool, MakePool],  BufferDisplay USING [Format],  BufferOps USING [Defaults, GetDefaults, SetDefaults],  Cursor USING [Handle, Object, Set, Store, UniqueType],  Driver USING [Device, ChangeNumberOfInputBuffers, GetDeviceChain],  Environment USING [wordsPerPage],  EthernetDriver USING [inputState],  EthernetDriverFriends USING [EtherStatsInfo, GetEthernetStats],  Exec USING [ExecProc, AddCommand, RemoveCommand],  Flipper USING [    ClearCounts, Create, Disable, Enable, Enumerated, EnumeratedDescriptor],  Format USING [HostNumber, NetworkNumber, StringProc],  FormSW USING [ClientItemsProcType, DisplayItem, NotifyProcType, ProcType],  Heap USING [Create, Delete],  IEEE8023 USING [maxDataBytesPerEthernetPacket],  Menu USING [    Destroy, Handle, ItemObject, MCRType, Create, Instantiate, Uninstantiate],  MFile USING [    Acquire, CopyFileHandle, Delete, Error, Handle, Release, Rename, SetAccess,    SetLength, GetLength],  MSegment USING [Base, Create, Delete, Error, ForceOut, Handle, Kill],  MataHariInternal,  MataHariUtil USING [Convert],  Process USING [    Abort, Detach, InvalidProcess, Pause, priorityNormal, SecondsToTicks,    SetPriority, Yield],  Protocol1 USING [SetMaximumBufferSize],  Put USING [Line, Text],  RingBuffer,  Router USING [AssignAddress, NetworkNonExistent],  Runtime USING [GetBcdTime, GlobalFrame],  Selection USING [Convert],  Space,  SpecialCommunication USING [SetEthernetListener, SetSpyProc, SpyProc, SpyType],  SpecialSpy USING [StartProc],  String USING [AppendChar, AppendLongDecimal, AppendString],  System USING [    broadcastHostNumber, HostNumber, NetworkAddress, nullHostNumber,    nullSocketNumber, SocketNumber],  SpecialSystem USING [GetProcessorID],  TextSW USING [ForceOutput],  Time USING [Append, AppendCurrent, Unpack],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [Activate, SetTinyName, TransitionProcType],  UserInput USING [UserAbort],  Version USING [Append],  Volume USING [GetAttributes, PageCount, systemID],  Window USING [Handle];MataHariToolImpl: MONITOR  IMPORTS    AddressTranslation, Buffer, BufferOps, Cursor, Driver, EthernetDriverFriends,    Exec, Flipper, Format, FormSW, Heap, Menu, MFile, MSegment, MataHariInternal,    MataHariUtil, Process, Protocol1, Put, Router, Runtime, RingBuffer, Selection,    Space, SpecialCommunication, SpecialSystem, String, TextSW, Time, Tool,    ToolWindow, UserInput, Version, Volume  EXPORTS Buffer, MataHariInternal, SpecialSpy  SHARES EthernetDriver =  BEGIN  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  flipperCnt: CARDINAL = 4;  rawFlp, runtFlp, typeFlp, queued: PUBLIC LONG CARDINAL ¬ 0;  flipItems: Flipper.EnumeratedDescriptor ¬ DESCRIPTOR[flipItemsArray];  flipItemsArray: ARRAY [0..flipperCnt) OF Flipper.Enumerated ¬ [    ["raw"L, @rawFlp], ["runt"L, @runtFlp], ["type"L, @typeFlp],    ["queued"L, @queued]];  -- TYPES  -- VARIABLES and CONSTANTS  clientStart: SpecialSpy.StartProc ¬ NIL;  clientStop: PROC ¬ NIL;  clientWh: PUBLIC Window.Handle ¬ NIL;  -- window of the client tool (if any).  -- default number of buffers used by dispatcher.  displayWidth: CARDINAL = 250;  --number of characters per line on LF screen  ethernet: BOOLEAN ¬ TRUE;  buffers: Buffer.AccessHandle ¬ NIL;  inactive: BOOLEAN ¬ TRUE;  mh: Menu.Handle ¬ NIL;  -- The Convert menu handle.  newBias: CARDINAL = 30;  -- Buf bias so we don't miss as many pkts.  bufferQueue: CARDINAL = 50;  -- Number of buffers we are allowed to have.  -- cache for the current snapshot.  params: PUBLIC MataHariInternal.ParamHandle ¬ NIL;  pleaseStop: BOOLEAN ¬ FALSE;  tool: PUBLIC MataHariInternal.DataHandle;  toolParams: PUBLIC MataHariInternal.ParamHandle;  wh: Window.Handle ¬ NIL;  -- MataHariTool window handle.  unloading: BOOLEAN ¬ FALSE;  z: PUBLIC <<MataHariInternal>> UNCOUNTED ZONE ¬ Heap.Create[10];  oldBufInfo, newBufInfo: ARRAY BufferOps.Defaults OF CARDINAL;  unit: CARDINAL = 1;  defaultQueue: CARDINAL = 3;  --default length of input queue  expandedQueue: CARDINAL = 10;  --expanded length of input queue  -- Indexes for re-displaying items.  startItem, stopItem, bcItem, rawItem, nsItem, pupItem, arpaItem, osiItem: PUBLIC    CARDINAL;  -- Data for Convert utility.  maxBases: CARDINAL = 3;  octal: CARDINAL = 0;  decimal: CARDINAL = 1;  hex: CARDINAL = 2;  outBases: ARRAY [0..maxBases) OF Menu.ItemObject ¬ [    ["octal", Convert], ["decimal", Convert], ["hex", Convert]];  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    InputQ: PROC [queue, size: NATURAL] =      BEGIN      gf: LONG POINTER TO FRAME[EthernetDriver];      FOR d: Device ¬ Driver.GetDeviceChain[], d.next UNTIL d = NIL DO        IF d.device # ethernet THEN LOOP;        d.alive ¬ FALSE;  --mark him dead        d.deactivateDriver[];  --slow him up a little        gf ¬ LOOPHOLE[Runtime.GlobalFrame[LOOPHOLE[d.activateDriver]]];        gf.inputState.extraBuffers ¬ queue;  --load up the input queue	Protocol1.SetMaximumBufferSize[d, NIL, size];  --adjust buffer sizes        d.activateDriver[];  --start him back up again        d.alive ¬ TRUE;  --and let the world use him        ENDLOOP;      END;  -- InputQ    SELECT TRUE FROM      old = inactive =>        BEGIN        IF tool = NIL THEN tool ¬ z.NEW[MataHariInternal.Data ¬ []];        IF toolParams = NIL THEN toolParams ¬ z.NEW[MataHariInternal.Params ¬ []];        IF params = NIL THEN  -- this is the current snapshot of the parameters.          params ¬ z.NEW[MataHariInternal.Params ¬ []];        --twiddle buffering and input queue so we miss as few packets as possible.	buffers ¬ Buffer.MakePool[send: 0, receive: bufferQueue];        --expand the driver's input queue        InputQ[expandedQueue, IEEE8023.maxDataBytesPerEthernetPacket];        oldBufInfo ¬ BufferOps.GetDefaults[];        newBufInfo ¬ [oldBufInfo[send], oldBufInfo[receive], newBias];        BufferOps.SetDefaults[newBufInfo];  --set the bias up high        tool.settablePacketLength ¬ tool.defaultPacketLength ¬          IEEE8023.maxDataBytesPerEthernetPacket;        IF (mh = NIL) AND (wh # NIL) THEN          BEGIN          mh ¬ Menu.Create[DESCRIPTOR[outBases], "Convert"];          Menu.Instantiate[mh, wh];          END;        inactive ¬ FALSE;        END;      new = inactive =>        BEGIN        Stop[];        Process.Abort[tool.watcher ! Process.InvalidProcess => CONTINUE];        MataHariInternal.FlushPastState[];        CloseRBW[];        MataHariInternal.CloseOptions[];        IF clientWh # NIL THEN  -- Get rid of the client tool.  (if any)           BEGIN Tool.Destroy[clientWh]; clientWh ¬ NIL; END;        -- Get rid of the convert menu.        IF mh # NIL THEN          BEGIN Menu.Uninstantiate[mh, wh]; Menu.Destroy[mh]; mh ¬ NIL; END;        IF tool.ring # Space.nullInterval THEN          BEGIN  --get rid of any existing buffering spaces          MSegment.Kill[tool.segment];          [] ¬ MSegment.Delete[tool.segment];          MFile.SetAccess[tool.fileCopy, delete];          MFile.Delete[tool.fileCopy];          tool.ring ¬ Space.nullInterval;          END;	IF tool # NIL THEN z.FREE[@tool];	IF toolParams # NIL THEN z.FREE[@toolParams];	IF params # NIL THEN z.FREE[@params];        InputQ[defaultQueue, 0];        BufferOps.SetDefaults[oldBufInfo];  -- Reset buffer bias.        Buffer.DestroyPool[buffers];        inactive ¬ TRUE;        END;      ENDCASE;    END;  -- ClientTransition  CloseRBW: PUBLIC FormSW.ProcType =    BEGIN  --close the ring buffer options window.    OPEN MataHariInternal;    IF tool.rbOptionsSW # NIL THEN {      Tool.Destroy[tool.rbOptionsSW]; tool.rbOptionsSW ¬ NIL};    END;  --CloseRBW  Convert: Menu.MCRType =    BEGIN  -- Takes the number (or valid network address) in the current    -- selection and converts it to specified base.    s: LONG STRING ¬ NIL;    s ¬ Selection.Convert[string];    IF s = NIL THEN RETURN;    SELECT index FROM      octal => MataHariUtil.Convert[s, octal];      decimal => MataHariUtil.Convert[s, decimal];      hex => MataHariUtil.Convert[s, hex];      ENDCASE => ERROR;    z.FREE[@s];  -- Free the string that Selection created.    END;  -- Convert  Init: PROCEDURE =    BEGIN    lnA: System.NetworkAddress ¬ Router.AssignAddress[];    stringProc: Format.StringProc = {String.AppendString[name, s]};    name: STRING ¬ [120];    String.AppendString[name, "MataHari "L];    Version.Append[name];    String.AppendString[name, " of "L];    Time.Append[name, Time.Unpack[Runtime.GetBcdTime[]]];    String.AppendString[name, " running on "L];    String.AppendString[name, "(Dandelion) "L];    Format.NetworkNumber[stringProc, lnA.net, octal];    String.AppendChar[name, '.];    Format.HostNumber[stringProc, lnA.host, octal];    String.AppendChar[name, '.];    tool ¬ z.NEW[MataHariInternal.Data ¬ []];    toolParams ¬ z.NEW[MataHariInternal.Params ¬ []];    params ¬ z.NEW[MataHariInternal.Params ¬ []];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: active,      clientTransition: ClientTransition, name: name, cmSection: "MataHari"L,      initialBox: [[10, 40], [1000, 760]], tinyName1: "MataHari"L,      tinyName2: "Tool"L];    mh ¬ Menu.Create[DESCRIPTOR[outBases], "Convert"];    Menu.Instantiate[mh, wh];    Put.Line[tool.fileSW, name];    name.length ¬ 0;    Version.Append[name];    ToolWindow.SetTinyName[wh, "MataHari"L, name];    name.length ¬ 0;    String.AppendString[name, "Log created on "L];    Time.AppendCurrent[name];    Put.Line[tool.fileSW, name];    END;  -- Init  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "MataHari.log"L];    tool.msgSW ¬ Tool.MakeMsgSW[window: window, lines: 3];    tool.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MataHariInternal.MakeForm, zone: z];    tool.flipperSW ¬ Flipper.Create[      parent: window, flippers: flipItems, priority: Process.priorityNormal,      position: leftJustified];    tool.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;  Register: Exec.ExecProc =    BEGIN    IF wh = NIL THEN Init[]    ELSE  -- got a tool here somewhere.      IF inactive THEN ToolWindow.Activate[wh]    END;  -- Register  SaveRB: PUBLIC ENTRY FormSW.NotifyProcType =    BEGIN    « Tacks the specified name onto the ring buffer, and makes it unavailable       for spying.  This is cheaper than copying the entire file, which       is very large, though if the spy is started in buffered mode again,       it will create another space for another ring buffer.  »    SELECT TRUE FROM      tool.rbName = NIL, tool.rbName.length = 0 => {        Put.Line[tool.msgSW, "please specify file name"L]; RETURN};      tool.ring = Space.nullInterval => {        Put.Line[tool.msgSW, "no ring buffer"L]; RETURN};      ENDCASE;    MFile.SetLength[      tool.fileCopy, tool.ring.count * Environment.wordsPerPage * 2];    MSegment.ForceOut[tool.segment];    MSegment.Delete[tool.segment];    MFile.SetAccess[tool.fileCopy, rename];    MFile.Rename[tool.fileCopy, tool.rbName];    MFile.Release[tool.fileCopy];    tool.ring ¬ Space.nullInterval;    Put.Line[tool.msgSW, "ring buffer saved"L];    END;  --SaveRB  SetRB: PUBLIC ENTRY FormSW.NotifyProcType =    BEGIN    « Sets the ring buffer to be the specified file for replaying.       If there is  already a ring buffer being used by the tool,       it will be freed.  »    bytes, pages: LONG CARDINAL ¬ 0;    IF (tool.rbName = NIL) OR (tool.rbName.length = 0) THEN {      Put.Line[tool.msgSW, "please specify file name"L]; RETURN};    tool.backingFile ¬ MFile.Acquire[      name: tool.rbName, access: readOnly, release: [] !      MFile.Error =>        BEGIN        SELECT code FROM          conflictingAccess, insufficientAccess =>            Put.Line[tool.msgSW, "Already set"L];          ENDCASE => Put.Line[tool.msgSW, "Cannot aquire file"L];        GOTO notSet;        END];    IF tool.ring # Space.nullInterval THEN  --zap the old ring buffer.      BEGIN      MSegment.Delete[tool.segment];      MFile.SetAccess[tool.fileCopy, delete];      MFile.Delete[tool.fileCopy];      tool.ring ¬ Space.nullInterval;      END;    bytes ¬ MFile.GetLength[tool.backingFile];    MFile.SetAccess[tool.backingFile, readWrite];    tool.fileCopy ¬ MFile.CopyFileHandle[file: tool.backingFile, release: []];    pages ¬ Space.PagesFromWords[(bytes + 1) / 2];    tool.segment ¬ MSegment.Create[      file: tool.backingFile, release: [], pages: pages !      MSegment.Error =>        BEGIN        Put.Text[tool.msgSW, "MSegment.Error"L];        MFile.SetAccess[tool.backingFile, delete];        MFile.Delete[tool.backingFile];        GOTO notSet;        END];    tool.ring ¬ [Space.LongPointerFromPage[MSegment.Base[tool.segment]], pages];    RingBuffer.Create[tool.ring];  --first create the state, then access it    [toolParams.replayStart, toolParams.replayStop] ¬ RingBuffer.GetStatus[];    FormSW.DisplayItem[tool.formSW, startItem];    FormSW.DisplayItem[tool.formSW, stopItem];    Put.Line[tool.msgSW, "ring buffer set"L];    EXITS notSet => NULL    END;  --SetRB  SetStateChangeProcs: PUBLIC << SpecialSpy >> PROC [    start: SpecialSpy.StartProc, stop: PROC] =    BEGIN clientStart ¬ start; clientStop ¬ stop; END;  -- SetStateChangeProcs  SourceFromDisk: PROC =    BEGIN    --disk is providing the packets, not the ethernet.    b: Buffer.Buffer ¬ NIL;    start, end: CARDINAL ¬ 0;    Process.SetPriority[Process.priorityNormal];    « Get the indices of packet in the ring, adjust end to the end the user       wants, and position for filtering at the first one the user wants.       Indices start at 0, as in all nerd programs.  »    [start, end] ¬ RingBuffer.GetStatus[];    end ¬ MIN[params.replayStop, end];    b ¬ RingBuffer.ReadNext[start: TRUE];    WHILE start < params.replayStart DO      start ¬ start + 1; b ¬ RingBuffer.ReadNext[start: FALSE]; ENDLOOP;    IF (start > end) OR (b = NIL) THEN  --silly user is screwing up replay range!      {      tool.running ¬ FALSE;      Process.Abort[tool.watcher ! Process.InvalidProcess => CONTINUE];      RETURN};    [] ¬ MataHariInternal.DispatcherSpy[b, receive];    THROUGH [start + 1..end] UNTIL ~tool.running DO      IF (b ¬ RingBuffer.ReadNext[start: FALSE]) = NIL THEN EXIT;      Process.Yield[];      [] ¬ MataHariInternal.DispatcherSpy[b, receive];      ENDLOOP;    Stop[];    Process.Abort[tool.watcher ! Process.InvalidProcess => CONTINUE];    tool.running ¬ FALSE;    END;  -- SourceFromDisk  Stop: PUBLIC ENTRY PROC =    BEGIN  -- Called by the client by bugging command (calls StopCmd)    -- or by hitting stop key.    string: STRING ¬ [44];    p: PROCESS;    IF pleaseStop THEN RETURN;  -- already stopped.    pleaseStop ¬ TRUE;    p ¬ FORK Blink;    SELECT params.driver FROM      etherToDisplay, etherToDisk =>        BEGIN  --first reset promiscuous mode        Driver.ChangeNumberOfInputBuffers[FALSE];        [] ¬ SpecialCommunication.SetEthernetListener[          unit, LOOPHOLE[SpecialSystem.GetProcessorID[]]];        FOR t: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO          [] ¬ SpecialCommunication.SetSpyProc[NIL, t]; ENDLOOP;        IF params.driver = etherToDisk THEN          BEGIN  --set up start and stop index          [toolParams.replayStart, toolParams.replayStop] ¬ RingBuffer.GetStatus[            ];          params.replayStart ¬ toolParams.replayStart;          params.replayStop ¬ toolParams.replayStop;          FormSW.DisplayItem[tool.formSW, startItem];          FormSW.DisplayItem[tool.formSW, stopItem];          END;        END;      ENDCASE;    TextSW.ForceOutput[tool.fileSW];    Put.Line[tool.msgSW, "Spying stopped."L];    Process.Pause[Process.SecondsToTicks[1]];  -- let spy proc finish display.    z.FREE[@tool.globalLine];    IF clientStop # NIL THEN clientStop[];    tool.etherMissed ¬      EthernetDriverFriends.GetEthernetStats[        unit !        Router.NetworkNonExistent =>  --no ethernet, probably phone          {tool.etherMissed ¬ 0; CONTINUE}].info.packetsMissed - tool.etherMissed;    IF (params.driver # diskToDisplay) AND (tool.etherMissed # 0) THEN      BEGIN      String.AppendLongDecimal[string, tool.etherMissed];      String.AppendString[string, " packets missed by Ethernet device"L];      Put.Line[tool.fileSW, string];      END;    done ¬ TRUE;    JOIN p;    END;  -- Stop  done: BOOLEAN ¬ FALSE;  Blink: PROC =    BEGIN    open: BOOLEAN ¬ TRUE;    face: BOOLEAN ¬ FALSE;    cursors: ARRAY [0..4) OF Cursor.Object ¬ [      [      info: [Cursor.UniqueType[], 7, 7],      array: [      003740B, 017770B, 037774B, 077776B, 076076B, 161707B, 143743B, 103741B,      103741B, 143743B, 161707B, 076076B, 077776B, 037774B, 007760B, 000000B]], [      info: [Cursor.UniqueType[], 7, 7],      array: [      003740B, 017770B, 037774B, 077776B, 077776B, 177777B, 177777B, 177777B,      157773B, 143743B, 161707B, 076076B, 077776B, 037774B, 007760B, 000000B]], [      info: [Cursor.UniqueType[], 7, 7],      array: [      3740B, 14030B, 20004B, 40002B, 57072B, 121105B, 116071B, 125325B, 116471B,      100601B, 100001B, 46062B, 41702B, 20604B, 14030B, 3740B]], [      info: [Cursor.UniqueType[], 7, 7],      array: [      3740B, 14030B, 20004B, 40002B, 57072B, 121105B, 116071B, 125325B, 116471B,      100601B, 100001B, 40602B, 41702B, 22044B, 14030B, 3740B]]];    DO      IF done THEN GOTO outOfHere      ELSE {        open ¬ ~open;        Cursor.Store[@cursors[open.ORD + (2 * face.ORD)]];        Process.Pause[10];        LOOP;        }      ENDLOOP;    EXITS outOfHere => {Cursor.Set[groundedText]; done ¬ FALSE; };    END;  StartCmd: PUBLIC FormSW.ProcType =    BEGIN    -- for changing buffer bias.    p: PROCESS;    string: STRING ¬ [44];    address: System.NetworkAddress;    IF tool.running THEN RETURN;    p ¬ FORK Blink;    tool.running ¬ TRUE;    pleaseStop ¬ FALSE;    Flipper.ClearCounts[tool.flipperSW];    tool.processor ¬ System.nullHostNumber;    tool.socket ¬ System.nullSocketNumber;    MataHariInternal.FlushPastState[];    -- cache the main tool parameters.    params.format ¬ toolParams.format;    params.peekAddr ¬ toolParams.peekAddr;    params.lineLen ¬ toolParams.lineLen;    params.replayStart ¬ toolParams.replayStart;    params.replayStop ¬ toolParams.replayStop;    params.driver ¬ toolParams.driver;    params.incoming ¬ toolParams.incoming;    params.outgoing ¬ toolParams.outgoing;    params.all ¬ toolParams.all;    params.broadcasts ¬ toolParams.broadcasts;    params.raw ¬ toolParams.raw;    params.ns ¬ toolParams.ns;    params.pup ¬ toolParams.pup;    params.arpa ¬ toolParams.arpa;    params.osi ¬ toolParams.osi;    params.level1Type ¬ toolParams.level1Type;    params.nsType ¬ toolParams.nsType;    params.arpaType ¬ toolParams.arpaType;    params.osiType ¬ toolParams.osiType;    params.displayParams ¬ toolParams.displayParams;    Process.Detach[tool.watcher ¬ FORK Watcher[]];    IF clientStart # NIL THEN clientStart[params.format];    BEGIN  -- scoping for EXITS    IF (params.peekAddr # NIL) AND (params.peekAddr.length # 0)      AND (params.peekAddr # ".*."L) AND (params.peekAddr # ".*.*"L) THEN      BEGIN      stringProc: Format.StringProc = {String.AppendString[tool.globalLine, s]};      address ¬ AddressTranslation.StringToNetworkAddress[        params.peekAddr !        AddressTranslation.Error =>          WITH e: errorRecord SELECT FROM            scanError, badSyntax => {              Put.Line[                tool.msgSW, "Processor ID must be in form '.host.socket'"L];              GOTO notStarted};            chLookupProblem, otherCHProblem => {              Put.Line[tool.msgSW, "Clearinghouse lookup problems"L];              GOTO notStarted};            ENDCASE].addr;      tool.processor ¬ address.host;  --This may not be null      tool.globalLine ¬ z.NEW[        StringBody [MAX[displayWidth, params.lineLen]] ¬ [        length: 0, maxlength: MAX[displayWidth, params.lineLen], text:]];      String.AppendString[tool.globalLine, params.peekAddr];      String.AppendString[tool.globalLine, " = "];      Format.HostNumber[        stringProc, tool.processor,        SELECT params.format FROM          hex => hex,          decimal => productSoftware,          ENDCASE => octal];      String.AppendString[tool.globalLine, ", spying started "L];      Time.AppendCurrent[tool.globalLine];      Put.Line[tool.fileSW, tool.globalLine];      tool.globalLine.length ¬ 0;      IF tool.processor = System.broadcastHostNumber THEN        tool.processor ¬ System.nullHostNumber;  --just because that's what I check on      tool.socket ¬ address.socket;  --This may be == nullSocketNumber, i.e., ".*.0"      END;    Put.Line[tool.msgSW, "Spying ..."L];    SELECT params.driver FROM      etherToDisplay =>        BEGIN        tool.etherMissed ¬ EthernetDriverFriends.GetEthernetStats[          unit !          Router.NetworkNonExistent =>  --no ether, probably just phone.            {tool.etherMissed ¬ 0; CONTINUE}].info.packetsMissed;        Driver.ChangeNumberOfInputBuffers[TRUE];        IF tool.processor # LOOPHOLE[SpecialSystem.GetProcessorID[]] THEN          [] ¬ SpecialCommunication.SetEthernetListener[            unit, System.broadcastHostNumber];        done ¬ TRUE;        JOIN p;        FOR t: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO          [] ¬ SpecialCommunication.SetSpyProc[MataHariInternal.DispatcherSpy, t];          ENDLOOP;        END;  -- etherToDisplay      diskToDisplay =>        BEGIN        IF tool.ring = Space.nullInterval THEN          BEGIN  --can't do this without space already built          Put.Line[tool.msgSW, "no ring buffer"L];          RETURN;          END;        RingBuffer.Create[tool.ring];        done ¬ TRUE;        JOIN p;        Process.Detach[FORK SourceFromDisk[]];        END;  -- diskToDisplay      etherToDisk =>        BEGIN        tool.etherMissed ¬ EthernetDriverFriends.GetEthernetStats[          unit !          Router.NetworkNonExistent =>  --no ether, probably just phone.            {tool.etherMissed ¬ 0; CONTINUE}].info.packetsMissed;        Driver.ChangeNumberOfInputBuffers[TRUE];	<<        IF          ((tool.ring # Space.nullInterval)            AND (tool.ring.count * Environment.wordsPerPage * 2) # size) THEN          BEGIN  --if the old ring isn't the right size, gun it.          MSegment.Delete[tool.segment];          MFile.SetAccess[tool.fileCopy, delete];          MFile.Delete[tool.fileCopy];          tool.ring ¬ Space.nullInterval;          END;	>>        IF tool.ring = Space.nullInterval THEN          BEGIN	  size: Volume.PageCount ¬ MIN[	    Volume.GetAttributes[Volume.systemID].freePageCount / 2, 2500];          string.length ¬ 0;          String.AppendLongDecimal[string, size];          String.AppendString[string, " pages available for buffering"L];          Put.Line[tool.fileSW, string];          tool.backingFile ¬ MFile.Acquire[            name: "SpyRing.log"L, access: readWrite, release: [],            initialLength: size * (LONG[Environment.wordsPerPage] * 2)];          tool.fileCopy ¬ MFile.CopyFileHandle[            file: tool.backingFile, release: []];          tool.segment ¬ MSegment.Create[            file: tool.backingFile, release: [], pages: size !            MSegment.Error =>              BEGIN              Put.Text[tool.msgSW, "MSegment.Error: "L];              MFile.SetAccess[tool.backingFile, delete];              MFile.Delete[tool.backingFile];              GOTO notStarted;              END];          tool.ring ¬ [            Space.LongPointerFromPage[MSegment.Base[tool.segment]], size];          done ¬ TRUE;          END;  --create new space        RingBuffer.Create[tool.ring];        RingBuffer.Clear[];        [] ¬ SpecialCommunication.SetEthernetListener[          unit, System.broadcastHostNumber];        done ¬ TRUE;        JOIN p;        FOR t: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO          [] ¬ SpecialCommunication.SetSpyProc[MataHariInternal.DispatcherSpy, t];          ENDLOOP;        END;  -- etherToDisk      ENDCASE;    EXITS      notStarted =>        BEGIN        done ¬ TRUE;        JOIN p;        tool.running ¬ FALSE;        Put.Line[tool.msgSW, "Spying stopped."L];        RETURN;        END;    END;  -- EXIT scoping    END;  --StartCmd  StopCmd: PUBLIC FormSW.ProcType =    BEGIN    IF ~tool.running THEN RETURN;    tool.running ¬ FALSE;    IF params.driver # diskToDisplay THEN Stop[];  --replay mode calls Stop itself.    Process.Abort[tool.watcher ! Process.InvalidProcess => CONTINUE];    END;  -- StopCmd  ToggleFlippers: PUBLIC FormSW.NotifyProcType =    BEGIN    IF toolParams.flippers THEN Flipper.Enable[tool.flipperSW]    ELSE Flipper.Disable[tool.flipperSW];    END;  -- ToggleFlippers  Unload: Exec.ExecProc =    BEGIN    Tool.Destroy[wh];  --shoot him down    [] ¬ Exec.RemoveCommand[h, "MataHari.~"L];  --get rid of command    Heap.Delete[z];  --and the zone    END;  -- Unload  Watcher: PROC =    BEGIN    ENABLE ABORTED => GOTO exit;    Process.SetPriority[Process.priorityNormal];    WHILE ~UserInput.UserAbort[tool.fileSW] DO      Process.Pause[Process.SecondsToTicks[1]]; ENDLOOP;    IF params.driver # diskToDisplay THEN Stop[];  --replay mode calls Stop itself.    tool.running ¬ FALSE;    EXITS exit => NULL;    END;  -- Watcher  -- Mainline code  Exec.AddCommand["MataHari.~"L, Register, NIL, Unload];  Init[];  END.  LOG12-Dec-85  9:33:43  SMA  Post Yuba and take out large input queue crock.16-Mar-86 15:17:14  AOF  Put the large input queue crock back in16-Mar-86 15:17:14  AOF  ...and a larger buffer crock to go with it11-Feb-87 16:30:08  NS   Replaced old buffering scheme with kam & sma's spiffy new ring buffer stuff20-Apr-87 14:27:22  JAV	 Set max packet size to 1514 from 57615-May-87 17:00:34  AOF	 Fix unloading30-Jun-87 17:53:52  AOF	 Don't rebuild ring buffer as often 2-Jul-87 19:04:54  BKI	 Add support for OSI 3-Nov-87  9:52:58  AOF	 Private heap for tool19-May-88 16:45:33  AOF	 Create ring buffer state before getting stats
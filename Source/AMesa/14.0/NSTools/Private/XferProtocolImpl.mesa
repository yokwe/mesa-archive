-- File: XferProtocolImpl.mesa - last edit:-- AOF                  3-Feb-87 13:18:55-- Copyright (C) 1986, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  ByteBlt USING [ByteBlt],  Courier USING [Description, Handle],  CourierInternal USING [ConnectionHandle],  Environment USING [Block, bytesPerWord],  NetworkStreamImpl USING [packetStreamObject],  NetworkStream USING [closeSST, closeReplySST],  NetworkStreamInternal USING [CloseState],  NSBuffer USING [Buffer, Body],  NSTypes USING [bytesPerIDPHeader, bytesPerSppHeader],  PacketStream USING [ConnectionSuspended, Handle],  Process USING [Pause, SecondsToTicks],  Runtime USING [GlobalFrame],  Stream,  XferProtocol USING [    CommitArguments, CommitResults, StoreArguments, StoreResults];XferProtocolImpl: PROGRAM  IMPORTS ByteBlt, PacketStream, Process, Stream, Runtime  EXPORTS XferProtocol  SHARES NetworkStreamImpl = {  bpw: NATURAL = Environment.bytesPerWord;  DescribeStoreArguments: PUBLIC Courier.Description =    BEGIN    p: LONG POINTER TO XferProtocol.StoreArguments = notes.noteSize[      SIZE[XferProtocol.StoreArguments]];    notes.noteString[@p.name];    notes.noteLongCardinal[@p.length];    --notes.unnoted[@p.transport, SIZE[XferProtocol.Transport]];    END;  --DescribeStoreArguments  DescribeStoreResults: PUBLIC Courier.Description = {    [] ¬ notes.noteSize[SIZE[XferProtocol.StoreResults]]};  DescribeCommitArguments: PUBLIC Courier.Description =    BEGIN    p: LONG POINTER TO XferProtocol.CommitArguments = notes.noteSize[      SIZE[XferProtocol.CommitArguments]];    notes.noteLongCardinal[@p.length];    --notes.noteEnumerated[@p.type];    notes.noteLongCardinal[@p.create];    notes.noteLongCardinal[@p.write];    notes.noteLongCardinal[@p.read];    END;  DescribeCommitResults: PUBLIC Courier.Description =    {[] ¬ notes.noteSize[SIZE[XferProtocol.CommitResults]]};  PacketStreamFromCourier: PUBLIC PROC[cH: Courier.Handle]    RETURNS[PacketStream.Handle] =    BEGIN    OPEN ch: LOOPHOLE[cH, CourierInternal.ConnectionHandle];    sH: Stream.Handle ¬ @ch.transFilter.object;    gf: LONG POINTER TO FRAME[NetworkStreamImpl] ¬ LOOPHOLE[      Runtime.GlobalFrame[LOOPHOLE[sH.setTimeout]]];    RETURN[@gf.packetStreamObject];    END;  --PacketStreamFromCourier  SppSize: PROC[l: NATURAL] RETURNS[CARDINAL] = INLINE    {RETURN[NSTypes.bytesPerIDPHeader + NSTypes.bytesPerSppHeader + l]};  ClosePacketStream: PUBLIC PROC[    psH: PacketStream.Handle, state: NetworkStreamInternal.CloseState] =    BEGIN    Send: PROC[subtype: Stream.SubSequenceType] =      BEGIN      b ¬ psH.getSendBuffer[];      ns ¬ b.ns; ns.subtype ¬ subtype;      ns.pktLength ¬ SppSize[0]; psH.put[b];      END;    b: NSBuffer.Buffer;    ns: NSBuffer.Body;    psH.setWaitTime[2000];  --milliseconds    UNTIL state = closed DO      ENABLE PacketStream.ConnectionSuspended => EXIT;  --gone already?      SELECT state FROM        (sendClose) => {Send[NetworkStream.closeSST]; state ¬ waitCloseReply};	(waitCloseReply) =>	  BEGIN	  b ¬ psH.get[];	  IF b = NIL THEN EXIT ELSE ns ¬ b.ns;  --failed trying to close	  SELECT b.ns.subtype FROM	    NetworkStream.closeSST => state ¬ sendCloseReply;	    NetworkStream.closeReplySST =>	      {Send[NetworkStream.closeReplySST]; state ¬ closed};	    ENDCASE => NULL;  --simply consume the data	  psH.returnReceiveBuffer[b];  --give the buffer back	  END;	(sendCloseReply) =>	  {Send[NetworkStream.closeReplySST]; state ¬ waitCloseReplyReply};	(waitCloseReplyReply) =>	  BEGIN	  b ¬ psH.get[];	  IF b = NIL THEN EXIT ELSE ns ¬ b.ns;  --failed trying to close	  SELECT b.ns.subtype FROM	    NetworkStream.closeSST => state ¬ closed;	    NetworkStream.closeReplySST => state ¬ closed;	    ENDCASE => NULL;  --simply consume the data	  psH.returnReceiveBuffer[b];  --give the buffer back	  END;	ENDCASE;      ENDLOOP;    Process.Pause[Process.SecondsToTicks[1]];    END;  --ClosePacketStream  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE = RECORD[    stream: Stream.Object, zone: UNCOUNTED ZONE,    position, length: Stream.Position, block: Environment.Block ¬ TRASH,    buffer: SEQUENCE COMPUTED CARDINAL OF Stream.Word ¬ TRASH];  DevNull: PUBLIC <<XferProtocol>> PROC[    buffsize: CARDINAL, filesize: LONG CARDINAL, zone: UNCOUNTED ZONE]    RETURNS[Stream.Handle] =    BEGIN    handle: Handle ¬ zone.NEW[Object[buffsize / bpw] ¬ [      stream: Stream.defaultObject, position: 0, zone: zone, length: filesize]];    handle.block ¬ [LOOPHOLE[@handle.buffer[0]], 0, buffsize];    handle.stream.get ¬ GetBlock;    handle.stream.put ¬ PutBlock;    handle.stream.delete ¬ Destroy;    handle.stream.getPosition ¬ GetIndex;    handle.stream.setPosition ¬ SetIndex;    RETURN[@handle.stream];    END;  --DevNull  Destroy: PUBLIC PROCEDURE [sH: Stream.Handle] =    BEGIN    handle: Handle ¬ LOOPHOLE[sH, Handle];    zone: UNCOUNTED ZONE = handle.zone;    zone.FREE[@handle];    END; -- Destroy  GetBlock: Stream.GetProcedure =    BEGIN    OPEN handle: LOOPHOLE[sH, Handle];    why ¬ normal; sst ¬ 0;  --set nominal return values    bytesTransferred ¬ CARDINAL[MIN[  --make truncation happen in right place      LONG[ByteBlt.ByteBlt[block, handle.block]],  --so lengthen this one       (handle.length - handle.position)]];  --so this subtraction works right    handle.position ¬ handle.position + bytesTransferred;    SELECT TRUE FROM      ((block.stopIndexPlusOne - block.startIndex) = bytesTransferred) => NULL;      (options.signalEndOfStream) => SIGNAL Stream.EndOfStream[bytesTransferred];      ENDCASE => why ¬ endOfStream;    END; -- GetBlock  PutBlock: Stream.PutProcedure =    BEGIN    OPEN handle: LOOPHOLE[sH, Handle];    handle.position ¬ handle.position + ByteBlt.ByteBlt[block, handle.block];    END; -- PutBlock  SetIndex: Stream.SetPositionProcedure =    BEGIN    OPEN handle: LOOPHOLE[sH, Handle];    handle.position ¬ MIN[handle.length, position];    END; -- SetIndex  GetIndex: Stream.GetPositionProcedure =    BEGIN    OPEN handle: LOOPHOLE[sH, Handle];    RETURN[handle.position];    END; -- GetIndex  }...    
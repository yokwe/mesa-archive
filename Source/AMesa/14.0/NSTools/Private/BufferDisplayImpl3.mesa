-- File: BufferDisplayImpl3.mesa - last edit:-- BKI                 15-Jul-88 12:51:43-- Copyright (C) 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  Buffer USING [Buffer],  BufferDisplay USING [    AppendHeaderBlock, AppendHeaderPiece, FindBufferBodyAndType,    Format, LineOverflow, OutputProc],  ByteBlt USING [ByteBlt],  Environment USING [Byte, LongNumber],  Format USING [StringProc],  Inline USING [BITSHIFT],  ISO8073Types USING [AdditionalOption, ClassAndOption,    fixedPartLengthExtendedAK, fixedPartLengthNormalAK, fixedPartLengthCR,    fixedPartLengthDC, fixedPartLengthDR, fixedPartLengthExtendedEA,    fixedPartLengthNormalEA, fixedPartLengthExtendedED, fixedPartLengthNormalED,    fixedPartLengthER, HeaderFixed, pcAcknowledgeTime, pcPriority, pcTransitDelay,    pcThroughput, pcSubSequenceNumber, pcFlowControlConfirmation, pcResidualErrorRate,    pcTpduSize, pcCallingTSap, pcInvalidTpdu, pcCallingTSapAndpcInvalidTpdu,    pcCalledTSap, pcChecksum, pcVersion, pcProtection, pcAdditionalOptionSelection,    pcAlternativeProtocolClass, pcAdditionalInformation, SizeValue],  OSIAddressConversion USING [    DecodeNetworkAddressBinary, Error, FormatNetworkAddress, InvalidAddress],  OSICLNetworkTypes USING [    Body, destAddrOffset, DiscardReason, IPHeader, ipHeaderLength, IPParamCode,    IPProtocolId, riHeaderLength, SegmentationPart],  OSICommonDefs USING [NAddrObject],  String USING [AppendChar, AppendString, StringBoundsFault];  BufferDisplayImpl3: PROGRAM  IMPORTS BufferDisplay, ByteBlt, Inline, OSIAddressConversion, String  EXPORTS BufferDisplay =  BEGIN  BodyAssumingEthernet: PROC[b: Buffer.Buffer] RETURNS[ptr: LONG POINTER] =    BEGIN      [ptr, ] ¬ BufferDisplay.FindBufferBodyAndType [b];    END;     OsiCltpPacket: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    String.AppendString[line, "  OSI Transport[cltp not yet implemented]"L];    outProc[line];    line.length ¬ 0;    END;  OsiCotpPacket: PUBLIC PROC [b: Buffer.Buffer, line: LONG STRING,    format: BufferDisplay.Format, outProc: BufferDisplay.OutputProc] =    BEGIN    ENABLE String.StringBoundsFault => {      line.length ¬ line.length - 4;  ERROR BufferDisplay.LineOverflow};    body: OSICLNetworkTypes.Body = BodyAssumingEthernet[b];    tpduPtr: LONG POINTER TO ISO8073Types.HeaderFixed ¬      LOOPHOLE[body, LONG POINTER] + (body.ip.initialHeaderLength + 1) / 2;    optionPtr: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬      LOOPHOLE[tpduPtr];    parmCodeIndex: CARDINAL = 0;    parmLengthIndex: CARDINAL = 1;    parmValueIndex: CARDINAL = 2;    AppendBadHeaderPiece: PROC [field: CARDINAL] =      BEGIN      String.AppendString[line, "??("L];      BufferDisplay.AppendHeaderPiece[format, @field, 1, line];      String.AppendChar[line, ')];      END;    OsiAppendLongSequenceNumber:       PROC [opaqueSequenceNumberPtr: LONG POINTER] =      BEGIN      BufferDisplay.AppendHeaderPiece[format, opaqueSequenceNumberPtr, 2, line];      END;    OsiOptionsParse: PROC [optionIndex: CARDINAL]      RETURNS [BOOLEAN] =      BEGIN      WHILE optionIndex < CARDINAL[tpduPtr.li] + 1  DO        optionIndex ¬	  optionIndex + parmLengthIndex + 1 + optionPtr[optionIndex + parmLengthIndex];        ENDLOOP;      IF optionIndex = CARDINAL[tpduPtr.li] + 1 THEN        RETURN [TRUE]	ELSE RETURN [FALSE];      END;    OsiAppendCrOrCcHeader: PROC [codeString: STRING]      RETURNS [ optionIndex: CARDINAL ¬ ISO8073Types.fixedPartLengthCR + 1] =      BEGIN      OPEN crPtr: LOOPHOLE[tpduPtr, LONG POINTER TO ISO8073Types.HeaderFixed.cr];      byteData: RECORD [filler, data: Environment.Byte];      IF OsiOptionsParse[optionIndex] THEN {        byteData ¬ [0, tpduPtr.li];        BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line]}      ELSE AppendBadHeaderPiece[tpduPtr.li];      String.AppendString[line, ", code: "L];      String.AppendString[line, codeString];      String.AppendString[line, ", dst ref: "L];      BufferDisplay.AppendHeaderPiece[format, @crPtr.dstRef, 1, line];      String.AppendString[line, ", src ref: "L];      BufferDisplay.AppendHeaderPiece[format, @crPtr.srcRef, 1, line];      String.AppendString[line, ", credit: "L];      byteData ¬ [0, crPtr.icdt];      BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];      String.AppendString[line, ", class: "L];      IF crPtr.class = class4 THEN {        byteData ¬ [0, 4];        BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line]}      ELSE AppendBadHeaderPiece[ORD[crPtr.class]];      String.AppendString[line, ", format: "L];      IF crPtr.format = normal THEN        String.AppendString[line, "normal"L]	ELSE String.AppendString[line, "extended"L];      END;    OsiAppendDrHeader: PROC      RETURNS [optionIndex: CARDINAL ¬ ISO8073Types.fixedPartLengthDR + 1] =      INLINE BEGIN      OPEN drPtr: LOOPHOLE[tpduPtr, LONG POINTER TO ISO8073Types.HeaderFixed.dr];      IF OsiOptionsParse[optionIndex] THEN {        byteData: RECORD [filler, data: Environment.Byte] ¬ [0, tpduPtr.li];        BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line]}      ELSE AppendBadHeaderPiece[tpduPtr.li];      String.AppendString[line, ", code: dr, dst ref: "L];      BufferDisplay.AppendHeaderPiece[format, @drPtr.dstRef, 1, line];      String.AppendString[line, ", src ref: "L];      BufferDisplay.AppendHeaderPiece[format, @drPtr.srcRef, 1, line];      String.AppendString[line, ", disconnect reason: "L];      SELECT drPtr.reason FROM        reasonNotSpecified => 	  String.AppendString[line, "reason not specified"L];	congestionAtTSAP =>	  String.AppendString[line, "congestion at tsap"L];	noSessionEntityAttached =>	  String.AppendString[line, "session entity not attached"L];	unknownAddress =>	  String.AppendString[line, "unknown address"L];	normalDisconnect =>	  String.AppendString[line, "normal disconnect"L];	remoteCongestion =>	  String.AppendString[line, "remote congestion"L];	negotiationFailed =>	  String.AppendString[line, "negotiation failed"L];	duplicateSourceReference =>	  String.AppendString[line, "duplicate source reference"L];	mismatchedReferences =>	  String.AppendString[line, "mismatched references"L];	protocolError =>	  String.AppendString[line, "protocol error"L];	referenceOverflow =>	  String.AppendString[line, "reference overflow"L];	networkConnectionRefused =>	  String.AppendString[line, "network connection refused"L];	invalidHeaderOrParameterLength =>	  String.AppendString[line, "invalid header or param length"L];	ENDCASE => AppendBadHeaderPiece[ORD[drPtr.reason]];      END;    OsiAppendDcHeader: PROC      RETURNS [optionIndex: CARDINAL ¬ ISO8073Types.fixedPartLengthDC + 1] =      INLINE BEGIN      OPEN dcPtr: LOOPHOLE[tpduPtr, LONG POINTER TO ISO8073Types.HeaderFixed.dc];      IF OsiOptionsParse[optionIndex] THEN {        byteData: RECORD [filler, data: Environment.Byte] ¬ [0, tpduPtr.li];        BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line]}      ELSE AppendBadHeaderPiece[tpduPtr.li];      String.AppendString[line, ", code: dc, dst ref: "L];      BufferDisplay.AppendHeaderPiece[format, @dcPtr.dstRef, 1, line];      String.AppendString[line, ", src ref: "L];      BufferDisplay.AppendHeaderPiece[format, @dcPtr.srcRef, 1, line];      END;    OsiAppendDtOrEdHeader: PROC [codeString: STRING]      RETURNS [optionIndex: CARDINAL] =      BEGIN      longSequenceNumber: Environment.LongNumber;      eot: BOOLEAN ¬ FALSE;      IF OsiOptionsParse           [optionIndex ¬ ISO8073Types.fixedPartLengthExtendedED + 1] THEN        BEGIN	OPEN edExtendedPtr: LOOPHOLE[	  tpduPtr, LONG POINTER TO ISO8073Types.HeaderFixed.ed.extended];        longSequenceNumber ¬ [num[	  lowbits: edExtendedPtr.tpduNrAndEot.low,	  highbits: edExtendedPtr.tpduNrAndEot.high]];        IF edExtendedPtr.tpduNrAndEot.eot = true THEN eot ¬ TRUE;	END      ELSE BEGIN	OPEN edNormalPtr: LOOPHOLE[	  tpduPtr, LONG POINTER TO ISO8073Types.HeaderFixed.ed.normal];        IF OsiOptionsParse	     [optionIndex ¬ ISO8073Types.fixedPartLengthNormalED + 1] THEN	  BEGIN          longSequenceNumber ¬ [num[	    lowbits: edNormalPtr.edTpduNr, highbits: 0]];          IF edNormalPtr.eot  = true THEN eot ¬ TRUE;	  END	  ELSE optionIndex ¬ 0;	END;      IF optionIndex = 0 THEN        BEGIN        AppendBadHeaderPiece[tpduPtr.li];        String.AppendString[line, ", code: "L];        String.AppendString[line, codeString];        String.AppendString[line, ", sequence number: ??"L];      	END      ELSE BEGIN	OPEN edPtr: LOOPHOLE[	  tpduPtr, LONG POINTER TO ISO8073Types.HeaderFixed.ed];        byteData: RECORD [filler, data: Environment.Byte] ¬ [0, tpduPtr.li];        BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];        String.AppendString[line, ", code: "L];        String.AppendString[line, codeString];        String.AppendString[line, ", dst ref: "L];        BufferDisplay.AppendHeaderPiece[format, @edPtr.dstRef, 1, line];        String.AppendString[line, ", sequence number: "L];        OsiAppendLongSequenceNumber[@longSequenceNumber.lu];        IF eot THEN String.AppendString[line, ", eot"L];        END;      END;    OsiAppendAkOrRjHeader: PROC [codeString: STRING]      RETURNS [optionIndex: CARDINAL] =      BEGIN      longSequenceNumber: Environment.LongNumber;      credit: RECORD [filler, data: Environment.Byte];      IF OsiOptionsParse           [optionIndex ¬ ISO8073Types.fixedPartLengthExtendedAK + 1] THEN        BEGIN	OPEN akExtendedPtr: LOOPHOLE[	  tpduPtr, LONG POINTER TO ISO8073Types.HeaderFixed.ak.extended];        longSequenceNumber ¬ [num[	  lowbits: akExtendedPtr.yrTuNr.low,	  highbits: akExtendedPtr.yrTuNr.high]];        credit ¬ [0, akExtendedPtr.credit];	END      ELSE BEGIN	OPEN akNormalPtr: LOOPHOLE[	  tpduPtr, LONG POINTER TO ISO8073Types.HeaderFixed.ak.normal];        IF OsiOptionsParse	     [optionIndex ¬ ISO8073Types.fixedPartLengthNormalAK + 1] THEN	  BEGIN          longSequenceNumber ¬ [num[	    lowbits: akNormalPtr.yrTuNr, highbits: 0]];          credit ¬ [0, akNormalPtr.icdt];	  END	  ELSE optionIndex ¬ 0;	END;      IF optionIndex = 0 THEN        BEGIN        AppendBadHeaderPiece[tpduPtr.li];        String.AppendString[line, ", code: "L];        String.AppendString[line, codeString];        String.AppendString[line, ", sequence number: ??"L];      	END      ELSE BEGIN	OPEN akPtr: LOOPHOLE[	  tpduPtr, LONG POINTER TO ISO8073Types.HeaderFixed.ak];        byteData: RECORD [filler, data: Environment.Byte] ¬ [0, tpduPtr.li];        BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];        String.AppendString[line, ", code: "L];        String.AppendString[line, codeString];        String.AppendString[line, ", dst ref: "L];        BufferDisplay.AppendHeaderPiece[format, @akPtr.dstRef, 1, line];        String.AppendString[line, ", sequence number: "L];        OsiAppendLongSequenceNumber[@longSequenceNumber.lu];        String.AppendString[line, ", credit: "L];        BufferDisplay.AppendHeaderPiece[format, @credit, 1, line];        END;      END;    OsiAppendEaHeader: PROC RETURNS [optionIndex: CARDINAL] =      INLINE BEGIN      longSequenceNumber: Environment.LongNumber;      IF OsiOptionsParse           [optionIndex ¬ ISO8073Types.fixedPartLengthExtendedEA + 1] THEN        BEGIN	OPEN eaExtendedPtr: LOOPHOLE[	  tpduPtr, LONG POINTER TO ISO8073Types.HeaderFixed.ea.extended];	longSequenceNumber ¬ [num[	  lowbits: eaExtendedPtr.yrTuNr.low,	  highbits: eaExtendedPtr.yrTuNr.high]];        END      ELSE BEGIN	OPEN eaNormalPtr: LOOPHOLE[	  tpduPtr, LONG POINTER TO ISO8073Types.HeaderFixed.ea.normal];        IF OsiOptionsParse	   [optionIndex ¬ ISO8073Types.fixedPartLengthNormalEA + 1] THEN          longSequenceNumber ¬ [num[	    lowbits: eaNormalPtr.yrTuNr, highbits: 0]]	  ELSE optionIndex ¬ 0;	END;      IF optionIndex = 0 THEN        BEGIN        AppendBadHeaderPiece[tpduPtr.li];        String.AppendString[line, ", code: ea, sequence number: ??"L];      	END        ELSE BEGIN	OPEN eaPtr: LOOPHOLE[	  tpduPtr, LONG POINTER TO ISO8073Types.HeaderFixed.ea];        byteData: RECORD [filler, data: Environment.Byte] ¬ [0, tpduPtr.li];        BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];        String.AppendString[line, ", code: ea, dst ref: "L];        BufferDisplay.AppendHeaderPiece[format, @eaPtr.dstRef, 1, line];        String.AppendString[line, ", sequence number: "L];        OsiAppendLongSequenceNumber[@longSequenceNumber.lu];        END;      END;    OsiAppendErHeader: PROC       RETURNS [optionIndex: CARDINAL ¬ ISO8073Types.fixedPartLengthER] =      INLINE BEGIN      OPEN erPtr: LOOPHOLE[tpduPtr, LONG POINTER TO ISO8073Types.HeaderFixed.er];      IF OsiOptionsParse[optionIndex] THEN {        byteData: RECORD [filler, data: Environment.Byte] ¬ [0, tpduPtr.li];        BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line]}      ELSE AppendBadHeaderPiece[tpduPtr.li];      String.AppendString[line, ", code: er, dst ref: "L];      BufferDisplay.AppendHeaderPiece[format, @erPtr.dstRef, 1, line];      String.AppendString[line, ", reject cause: "L];      SELECT erPtr.rejectCause FROM        reasonNotSpecified =>	  String.AppendString[line, "reason not specified"L];  	invalidParameterCode =>	  String.AppendString[line, "invalid param code"L];	invalidTPDUType =>	  String.AppendString[line, "invalid tpdu type"L];	invalidParameterValue =>	  String.AppendString[line, "invalid param value"L];        ENDCASE =>	  AppendBadHeaderPiece[ORD[erPtr.rejectCause]];      END;    OsiCotpAppendOptions: PROC [optionIndex: CARDINAL] = INLINE      BEGIN      byteData: RECORD[high, low: Environment.Byte];      firstPass: BOOLEAN ¬ TRUE;      AppendWordValue: PROC =        BEGIN        byteData ¬ [	  optionPtr[optionIndex + parmValueIndex],	  optionPtr[optionIndex + parmValueIndex + 1]];        BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];	END;      AppendUntypedOctetValue: PROC =        BEGIN        BufferDisplay.AppendHeaderBlock	  [format,           [optionPtr, optionIndex + parmValueIndex, 	    optionIndex + parmValueIndex + optionPtr[optionIndex + parmLengthIndex]],      	   line];	END;      AppendAcknowledgeTimeValue: PROC = AppendWordValue;      AppendResidualErrorRateValue: PROC = AppendUntypedOctetValue;      AppendPriorityValue: PROC = AppendWordValue;      AppendTransitDelayValue: PROC = AppendUntypedOctetValue;      AppendThroughputValue: PROC = AppendUntypedOctetValue;      AppendSubsequenceNumberValue: PROC = AppendWordValue;      AppendFlowControlConfirmationValue: PROC = INLINE        BEGIN        longSequenceNumber: Environment.LongNumber ¬ [num[	  lowbits: optionPtr[optionIndex + parmValueIndex + 2] * 256 +	    optionPtr[optionIndex + parmValueIndex + 3],	  highbits: optionPtr[optionIndex + parmValueIndex] * 256 +	    optionPtr[optionIndex + parmValueIndex + 1]]];        String.AppendString[line, "lwe¬"L];        OsiAppendLongSequenceNumber[@longSequenceNumber.lu];        String.AppendString[line, " ssn¬"L];        byteData ¬	  [optionPtr[optionIndex + parmValueIndex + 4],	   optionPtr[optionIndex + parmValueIndex + 5]];        BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];        String.AppendString[line, " cdt¬"L];        byteData ¬	  [optionPtr[optionIndex + parmValueIndex + 6],	   optionPtr[optionIndex + parmValueIndex + 7]];        BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];	END;      AppendTpduSizeValue: PROC = INLINE        BEGIN        SELECT LOOPHOLE[optionPtr[optionIndex + parmValueIndex],	                ISO8073Types.SizeValue] FROM	  oct128  => String.AppendString[line, "128"L];	  oct256  => String.AppendString[line, "256"L];	  oct512  => String.AppendString[line, "512"L];	  oct1024 => String.AppendString[line, "1024"L];	  oct2048 => String.AppendString[line, "2048"L];	  oct4096 => String.AppendString[line, "4096"L];	  oct8192 => String.AppendString[line, "8128"L];	  ENDCASE => AppendBadHeaderPiece[optionPtr[optionIndex + parmValueIndex]];	END;      AppendCallingTSAPValue: PROC = AppendUntypedOctetValue;      AppendInvalidTpduValue: PROC = AppendUntypedOctetValue;      AppendCalledTSAPValue: PROC = AppendUntypedOctetValue;      AppendChecksumValue: PROC = AppendWordValue;      AppendVersionValue: PROC = INLINE        BEGIN        byteData ¬ [0, optionPtr[optionIndex + parmValueIndex]];        BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];	END;      AppendProtectionValue: PROC = AppendUntypedOctetValue;      AppendAdditionalOptionSelectionValue: PROC = INLINE        BEGIN        additionalOption: Environment.Byte ¬ 	  optionPtr[optionIndex + parmValueIndex];        additionalOptionPtr: LONG POINTER TO ISO8073Types.AdditionalOption ¬	  LOOPHOLE[LONG[@additionalOption]];        noneUsed: BOOLEAN ¬ TRUE;        IF additionalOptionPtr.nExpd = use THEN {	  String.AppendString[line, "nexpd "L]; noneUsed ¬ FALSE};        IF additionalOptionPtr.rConf = use THEN {	  String.AppendString[line, "rconf "L]; noneUsed ¬ FALSE};        IF additionalOptionPtr.cksum = use THEN {	  String.AppendString[line, "cksum "L]; noneUsed ¬ FALSE};        IF additionalOptionPtr.tExpd = use THEN {	  String.AppendString[line, "texpd "L]; noneUsed ¬ FALSE};        IF noneUsed THEN	  String.AppendString[line, "none"L]	  ELSE line.length ¬ line.length - 1;      	END;      AppendAlternativeProtocolClassValue: PROC = INLINE        BEGIN        classAndOption: RECORD [high, low: Environment.Byte];	classAndOptionPtr: LONG POINTER TO ISO8073Types.ClassAndOption.class4 ¬	  LOOPHOLE[LONG[@classAndOption]];        FOR i: CARDINAL IN [0.. optionPtr[optionIndex + parmLengthIndex]) DO          classAndOption ¬ [optionPtr[optionIndex + parmValueIndex + i], 0];          SELECT classAndOptionPtr.class FROM	    class0 => String.AppendString[line, "class0 "L];	    class1 => String.AppendString[line, "class1 "L];	    class2 => String.AppendString[line, "class2 "L];	    class3 => String.AppendString[line, "class3 "L];	    class4 => String.AppendString[line, "class4 "L];	    ENDCASE => String.AppendString[line, "class? "L];          IF classAndOptionPtr.format = extended THEN	    String.AppendString[line, "ext format "L] 	    ELSE String.AppendString[line, "norm format "L];          ENDLOOP;	END;      AppendAdditionalInformationValue: PROC = AppendUntypedOctetValue;      IF optionIndex = 0 THEN {        String.AppendString[line, ", options[??]"L]; RETURN};      String.AppendString[line, ", options["L];      WHILE optionIndex < CARDINAL[tpduPtr.li + 1] DO        expectedLen: CARDINAL ¬ 0;        IF firstPass THEN	  firstPass ¬ FALSE	  ELSE String.AppendString[line, ", "L];        SELECT optionPtr[optionIndex + parmCodeIndex] FROM          ISO8073Types.pcAcknowledgeTime => {	    String.AppendString[line, "ack time["L];            expectedLen ¬ 2};          ISO8073Types.pcResidualErrorRate => {	    String.AppendString[line, "error rate["L];            expectedLen ¬ 3};          ISO8073Types.pcPriority => {	    String.AppendString[line, "priority["L];	    expectedLen ¬ 2};          ISO8073Types.pcTransitDelay => {	    String.AppendString[line, "transit delay["L];	    expectedLen ¬ 8};          ISO8073Types.pcThroughput => 	    String.AppendString[line, "throughput["L];          ISO8073Types.pcSubSequenceNumber => {	    String.AppendString[line, "subsequence["L];            expectedLen ¬ 2};          ISO8073Types.pcFlowControlConfirmation => {	    String.AppendString[line, "fcc["L];	    expectedLen ¬ 8};          ISO8073Types.pcTpduSize => {	    String.AppendString[line, "tpdu size["L];	    expectedLen ¬ 1};          ISO8073Types.pcCallingTSap => 	    String.AppendString[line, "calling tsap["L];          ISO8073Types.pcInvalidTpdu => 	    String.AppendString[line, "bad tpdu["L];          ISO8073Types.pcCallingTSapAndpcInvalidTpdu => 	    String.AppendString[line, "bad tpdu["L];          ISO8073Types.pcCalledTSap => 	    String.AppendString[line, "called tsap["L];          ISO8073Types.pcChecksum => {	    String.AppendString[line, "checksum["L];            expectedLen ¬ 2};          ISO8073Types.pcVersion => {	    String.AppendString[line, "version["L];	    expectedLen ¬ 1};          ISO8073Types.pcProtection => 	    String.AppendString[line, "security["L];          ISO8073Types.pcAdditionalOptionSelection => {	    String.AppendString[line, "other options["L];	    expectedLen ¬ 1};          ISO8073Types.pcAlternativeProtocolClass => 	    String.AppendString[line, "alt classes["L];          ISO8073Types.pcAdditionalInformation => 	    String.AppendString[line, "other info["L];	  ENDCASE =>String.AppendString[line, "??["L];        String.AppendString[line, "len: "L];        IF (optionPtr[optionIndex + parmLengthIndex] = expectedLen) OR	   (expectedLen = 0) THEN {	   byteData ¬ [0, optionPtr[optionIndex + parmLengthIndex]];	   BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line]}	   ELSE AppendBadHeaderPiece[optionPtr[optionIndex + parmLengthIndex]];        String.AppendString[line, ", val: "L];        SELECT optionPtr[optionIndex + parmCodeIndex] FROM          ISO8073Types.pcAcknowledgeTime =>	    AppendAcknowledgeTimeValue;          ISO8073Types.pcResidualErrorRate => 	    AppendResidualErrorRateValue;          ISO8073Types.pcPriority =>	    AppendPriorityValue;          ISO8073Types.pcTransitDelay =>	    AppendTransitDelayValue;          ISO8073Types.pcThroughput =>	    AppendThroughputValue;          ISO8073Types.pcSubSequenceNumber =>	    AppendSubsequenceNumberValue;          ISO8073Types.pcFlowControlConfirmation =>	    AppendFlowControlConfirmationValue;          ISO8073Types.pcTpduSize => 	    AppendTpduSizeValue;          ISO8073Types.pcCallingTSap,	  ISO8073Types.pcInvalidTpdu,	  ISO8073Types.pcCallingTSapAndpcInvalidTpdu =>	    IF tpduPtr.code = er THEN	      AppendInvalidTpduValue	      ELSE AppendCallingTSAPValue;          ISO8073Types.pcCalledTSap =>	    AppendCalledTSAPValue;          ISO8073Types.pcChecksum => 	    AppendChecksumValue;          ISO8073Types.pcVersion =>	    AppendVersionValue;          ISO8073Types.pcProtection => 	    AppendProtectionValue;          ISO8073Types.pcAdditionalOptionSelection =>	    AppendAdditionalOptionSelectionValue;          ISO8073Types.pcAlternativeProtocolClass =>	    AppendAlternativeProtocolClassValue;          ISO8073Types.pcAdditionalInformation =>	    AppendAdditionalInformationValue;	  ENDCASE =>String.AppendString[line, "??"L];        String.AppendChar[line, ']];        optionIndex ¬ 	  optionIndex + parmLengthIndex + 1 + optionPtr[optionIndex + parmLengthIndex];        ENDLOOP;      String.AppendChar[line, ']];      END;    bytesMoved : CARDINAL ¬ 0;    optionIndex : CARDINAL;    saveByte : Environment.Byte;    IF (body.ip.initialHeaderLength MOD 2) = 0 THEN      BEGIN      saveByte ¬ optionPtr[0];      bytesMoved ¬ ByteBlt.ByteBlt[        to: [optionPtr, 0, optionPtr[1] + 1],	from: [optionPtr, 1, LAST[CARDINAL]], overLap: ripple];      END;    String.AppendString[line, "  OSI Transport[fixed[li: "L];    SELECT tpduPtr.code FROM      cr => optionIndex ¬ OsiAppendCrOrCcHeader["cr"L];      cc => optionIndex ¬ OsiAppendCrOrCcHeader["cc"L];      dr => optionIndex ¬ OsiAppendDrHeader[];      dc => optionIndex ¬ OsiAppendDcHeader[];      dt => optionIndex ¬ OsiAppendDtOrEdHeader["dt"L];      ed => optionIndex ¬ OsiAppendDtOrEdHeader["ed"L];      ak => optionIndex ¬ OsiAppendAkOrRjHeader["ak"L];      ea => optionIndex ¬ OsiAppendEaHeader[];      rj => optionIndex ¬ OsiAppendAkOrRjHeader["rj"L];      er => optionIndex ¬ OsiAppendErHeader[];      ENDCASE=> {        String.AppendString [line, "??"L];        optionIndex ¬ 0};    String.AppendChar[line, ']];    OsiCotpAppendOptions[optionIndex];    String.AppendChar[line, ']];    outProc[line];    line.length ¬ 0;    IF bytesMoved > 0 THEN      BEGIN      [] ¬ ByteBlt.ByteBlt[        to: [optionPtr, 1, LAST[CARDINAL]],	from: [optionPtr, 0, bytesMoved], overLap: ripple];      optionPtr[0] ¬ saveByte;      END;    END;   OsiIPFields: PUBLIC PROC [    b: Buffer.Buffer, line: LONG STRING, format: BufferDisplay.Format,    outProc: BufferDisplay.OutputProc] =    BEGIN    ENABLE String.StringBoundsFault => {      line.length ¬ line.length - 4;  ERROR BufferDisplay.LineOverflow};    body: OSICLNetworkTypes.Body = BodyAssumingEthernet[b];    opaqueBody: LONG POINTER ¬ body;    optionIndex: CARDINAL ¬ 0;    optionPtr: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬      opaqueBody;    segmentIndex: CARDINAL ¬ 0;    AppendBadHeaderPiece: PROC [field: CARDINAL] =      BEGIN      String.AppendString[line, "??("L];      BufferDisplay.AppendHeaderPiece[format, @field, 1, line];      String.AppendChar[line, ')];      END;    OsiIPAppendProtocolId: PROC  =      BEGIN      String.AppendString[line, "proto id: "L];      SELECT body.ip.protocolID FROM        standard => String.AppendString[line, "standard"L];        routing => String.AppendString[line, "routing"L];        ENDCASE => AppendBadHeaderPiece[ORD[body.ip.protocolID]];      END;    OsiIPAppendHeaderLength: PROC =      BEGIN      byteData: RECORD [filler, data: Environment.Byte] ¬        [0, body.ip.initialHeaderLength];      okay: BOOLEAN;      okay ¬ SELECT body.ip.protocolID FROM        standard =>	  body.ip.initialHeaderLength < body.ip.segmentLength,	routing =>	  TRUE --body.ri.initialHeaderLength = npduLength--,	ENDCASE => ERROR;      String.AppendString[line, ", hdr len: "L];      IF okay THEN BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line]      ELSE AppendBadHeaderPiece[body.ip.initialHeaderLength];      END;    OsiIPAppendVersion: PROC =      BEGIN      String.AppendString[line, ", version: "L];      IF body.ip.version = version1 THEN String.AppendChar[line, '1]      ELSE AppendBadHeaderPiece[ORD[body.ip.version]];      END;    OsiIPAppendLifetime: PROC [list: BOOL ¬ TRUE] =      BEGIN      byteData: RECORD [filler, data: Environment.Byte] ¬ [0, body.ip.lifetime];      IF list THEN        String.AppendString[line, ", lifetime: "L]      ELSE String.AppendString[line, "lifetime: "L];      BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];      END;    OsiIPAppendFlags: PROC [list: BOOL ¬ TRUE] =      BEGIN      flags: STRING ¬ [9];      flags.length ¬ 0;      IF body.ip.segmentPermitted THEN String.AppendString[flags, "sp "L];      IF body.ip.moreSegments THEN String.AppendString[flags, "ms "L];      IF body.ip.errorReport THEN String.AppendString[flags, "er "L];      IF flags.length # 0 THEN        BEGIN        flags.length ¬ flags.length - 1;        IF list THEN	  String.AppendString[line, ", flags["L]        ELSE String.AppendString[line, "flags["L];        String.AppendString[line, flags];        String.AppendChar[line, ']];	END;      END;    OsiIPAppendType: PROC =      BEGIN      expectedProtocolID: OSICLNetworkTypes.IPProtocolId;      String.AppendString[line, ", type: "L];      SELECT body.ip.type FROM        error => {	  String.AppendString[line, "er"L];	  expectedProtocolID ¬ standard}; 	esHello => {	  String.AppendString[line, "esh"L];	  expectedProtocolID ¬ routing};	isHello => {	  String.AppendString[line, "ish"L];	  expectedProtocolID ¬ routing};	redirect => {	  String.AppendString[line, "rd"L];	  expectedProtocolID ¬ routing};	data => {	  String.AppendString[line, "dt"L];	  expectedProtocolID ¬ standard};	ENDCASE => {	  AppendBadHeaderPiece[ORD[body.ip.type]];	  expectedProtocolID ¬ body.ip.protocolID};      IF body.ip.protocolID # expectedProtocolID THEN        String.AppendString[line, "??"L];      END;    OsiIPAppendSegmentLength: PROC = INLINE      BEGIN      String.AppendString[line, ", seg len: "L];      IF TRUE--body.ip.segmentLength = npduLength-- THEN        BufferDisplay.AppendHeaderPiece[format, @body.ip.segmentLength, 1, line]      ELSE AppendBadHeaderPiece[body.ip.segmentLength];      END;    OsiIPAppendChecksum: PROC =      BEGIN      IF body.ip.checksum # 0 THEN        BEGIN        String.AppendString[line, ", checksum: "L];        BufferDisplay.AppendHeaderPiece[format, @body.ip.checksum, 1, line];	END;      END;    OsiIPAppendZeroes: PROC = INLINE      BEGIN      IF body.ri.reserved # 0 THEN        BEGIN        String.AppendString[line, ", ??("L];        OsiIPAppendLifetime[list: FALSE];	String.AppendChar[line, ')];	END;      IF (body.ri.pad1 # 0) OR          (body.ri.pad2 # 0) OR 	 (body.ri.pad3 # 0) THEN        BEGIN        String.AppendString[line, ", ??("L];        OsiIPAppendFlags[list: FALSE];	String.AppendChar[line, ')];	END;      END;    OsiIPAppendHoldTime: PROC = INLINE      BEGIN      String.AppendString[line, ", hold time: "L];      BufferDisplay.AppendHeaderPiece[format, @body.ri.holdingTime, 1, line];      END;    OsiIPAppendAddresses: PROC [strings: DESCRIPTOR FOR ARRAY OF STRING] =      BEGIN      Append: Format.StringProc = {        String.AppendString[to: line, from: s]};      count: CARDINAL;      nsap: OSICommonDefs.NAddrObject;      offset, nextOffset: CARDINAL ¬ OSICLNetworkTypes.destAddrOffset;      String.AppendString[line, ", addrs: "L];      IF strings = NIL THEN        BEGIN	count ¬ body.bytes[offset];	offset ¬ offset + 1;	String.AppendChar[line, '(];	BufferDisplay.AppendHeaderPiece[format, @count, 1, line];	String.AppendChar[line, ')];	END      ELSE count ¬ LENGTH[strings];      String.AppendChar[line, '[];      FOR i: CARDINAL IN [0..count) DO        IF i # 0 THEN String.AppendString[line, ", "L];        IF strings # NIL THEN String.AppendString[line, strings[i]];	nextOffset ¬ offset + body.bytes[offset] + 1;	IF nextOffset - 1 > body.ip.initialHeaderLength THEN {	  String.AppendString[line, "??"L]; EXIT};	BEGIN	ENABLE OSIAddressConversion.Error,	  OSIAddressConversion.InvalidAddress => {	  String.AppendString[line, "??"L]; CONTINUE};	nsap ¬ OSIAddressConversion.DecodeNetworkAddressBinary[	  [@body.bytes, offset + 1, nextOffset]];	OSIAddressConversion.FormatNetworkAddress[addr: @nsap, proc: Append];	END; --ENABLE	offset ¬ nextOffset;        ENDLOOP;      String.AppendChar[line, ']];      END;    OsiIPAppendSegment: PROC = INLINE      BEGIN      String.AppendString[line, ", segment["L];      IF segmentIndex # 0 THEN        BEGIN	segmentPart: PACKED ARRAY [0..6) OF Environment.Byte;	segmentPtr: LONG POINTER TO OSICLNetworkTypes.SegmentationPart;	IF segmentIndex MOD 2 # 0 THEN	  BEGIN	  FOR i: CARDINAL IN [0..6) DO	    segmentPart[i] ¬ body.bytes[segmentIndex + i];	    ENDLOOP;	  segmentPtr ¬ LOOPHOLE[LONG[@segmentPart]];	  END	ELSE segmentPtr ¬ LOOPHOLE[@body.bytes + (segmentIndex / 2)];        String.AppendString[line, "duid: "L];        BufferDisplay.AppendHeaderPiece[format, @segmentPtr.unitId, 1, line];        String.AppendString[line, ", offset: "L];        BufferDisplay.AppendHeaderPiece[format, @segmentPtr.segmentOffset, 1, line];        String.AppendString[line, ", total len: "L];        BufferDisplay.AppendHeaderPiece[format, @segmentPtr.totalLength, 1, line];        END;      String.AppendChar[line, ']];      END;    OsiIPAppendOptions: PROC =      BEGIN      ScopeCode: TYPE = MACHINE DEPENDENT{        sourceAddr(1), destAddr(2), global(3)}; --belongs in OSICLNetworkTypes!      firstPass: BOOLEAN ¬ TRUE;      parmCodeIndex: CARDINAL = 0;      parmLenIndex: CARDINAL = 1;      parmValueIndex: CARDINAL = 2;      AppendUntypedOctetValue: PROC =        BEGIN        BufferDisplay.AppendHeaderBlock	  [format,	   [optionPtr, optionIndex + parmValueIndex, 	    optionIndex + parmValueIndex + optionPtr[optionIndex + parmLenIndex]],	   line];	END;      AppendErReasonValue: PROC = INLINE        BEGIN        SELECT	  LOOPHOLE[optionPtr[optionIndex + parmValueIndex], 	  OSICLNetworkTypes.DiscardReason] FROM          notSpecified => String.AppendString[line, "notSpecified"L];          protocolError => String.AppendString[line, "protocolError"L];          badChecksum => String.AppendString[line, "badChecksum"L];          congestion => String.AppendString[line, "congestion"L];          badSyntax => String.AppendString[line, "badSyntax"L];          noSegmenting => String.AppendString[line, "noSegmenting"L];          incompletePDU => String.AppendString[line, "incompletePDU"L];          duplicateOption => String.AppendString[line, "duplicateOption"L];          unreachable => String.AppendString[line, "destUnreachable"L];          unknown => String.AppendString[line, "destUnknown"L];          srNotSpecified => String.AppendString[line, "srNotSpecified"L];          srBadSyntax => String.AppendString[line, "srBadSyntax"L];          srUnknown => String.AppendString[line, "srUnknown"L];          srNoPath => String.AppendString[line, "srNoPath"L];          leTransit => String.AppendString[line, "leTransit"L];          leReassembly => String.AppendString[line, "leReassembly"L];          uoNotSpecified => String.AppendString[line, "uoNotSpecified"L];          uoProtocolVersion => String.AppendString[line, "uoProtocolVersion"L];          uoSecurity => String.AppendString[line, "uoSecurity"L];          uoSourceRouting => String.AppendString[line, "uoSourceRouting"L];          uoRouteRecording => String.AppendString[line, "uoRouteRecording"L];          reassmInterference => String.AppendString[line, "reassmInterference"L];	  ENDCASE => AppendBadHeaderPiece[optionPtr[optionIndex + parmValueIndex]];	END;      AppendScopedValue: PROC = INLINE        BEGIN        SELECT	  LOOPHOLE	    [Inline.BITSHIFT [optionPtr[optionIndex + parmValueIndex], -6],	     ScopeCode] FROM          sourceAddr => String.AppendString[line, "source addr spec "L];	  destAddr => String.AppendString[line, "dest addr spec "L];	  global => String.AppendString[line, "global "L];	  ENDCASE => String.AppendString[line, "?? "L];        AppendUntypedOctetValue; 	END;      AppendPriorityValue: PROC = INLINE        BEGIN        byteData: RECORD [filler, data: Environment.Byte] ¬          [0, optionPtr[optionIndex + parmValueIndex]];        BufferDisplay.AppendHeaderPiece[format, @byteData, 1, line];	END;      AppendRouteValue: PROC = AppendUntypedOctetValue;      AppendPadValue: PROC = AppendUntypedOctetValue;      String.AppendString[line, ", options["L];      IF optionIndex # 0 THEN	WHILE optionIndex + parmLenIndex <= body.ip.initialHeaderLength DO	  expectedLen: CARDINAL ¬ 0;	  parmLen: CARDINAL ¬ optionPtr[optionIndex + parmLenIndex];	  IF NOT firstPass THEN String.AppendString[line, ", "L];	  firstPass ¬ FALSE;	  SELECT LOOPHOLE[optionPtr[optionIndex + parmCodeIndex],	      OSICLNetworkTypes.IPParamCode] FROM	    reasonForDiscard => {	      String.AppendString[line, "er reason["L];	      expectedLen ¬ 2};	    qos => 	      String.AppendString[line, "qos["L];	    security => 	      String.AppendString[line, "security["L];	    priority => {	      String.AppendString[line, "priority["L];	      expectedLen ¬ 1};	    sourceRoute => 	      String.AppendString[line, "source route["L];	    routeRecord => 	      String.AppendString[line, "route record["L];	    pad => 	      String.AppendString[line, "pad["L];	    ENDCASE => 	      String.AppendString[line, "??["L];          String.AppendString[line, "len: "L];          IF (expectedLen # 0) AND (parmLen # expectedLen) THEN {	    AppendBadHeaderPiece[parmLen];	    String.AppendString[line, ", val: ??]"L]; EXIT};          BufferDisplay.AppendHeaderPiece[format, @parmLen, 1, line];          String.AppendString[line, ", val: "L];          SELECT LOOPHOLE[optionPtr[optionIndex + parmCodeIndex],	      OSICLNetworkTypes.IPParamCode] FROM	    reasonForDiscard => AppendErReasonValue;	    qos, security => AppendScopedValue;	    priority => AppendPriorityValue;	    sourceRoute, routeRecord => AppendRouteValue;	    pad => AppendPadValue;	    ENDCASE => String.AppendString[line, "??"L];          String.AppendChar [line, ']];          optionIndex ¬ optionIndex + parmLenIndex + 1 + parmLen;          ENDLOOP;      String.AppendChar[line, ']];      END;        OsiIPCalculateOffsets: PROC = INLINE      BEGIN      index: CARDINAL;      SELECT body.ip.protocolID FROM	standard =>	  BEGIN	  index ¬ OSICLNetworkTypes.ipHeaderLength + 1;	  index ¬ index + body.bytes[index] + 1; --add dest addr	  index ¬ index + body.bytes[index] + 1; --add source addr	  IF body.ip.segmentPermitted THEN	    BEGIN	    segmentIndex ¬ index;	    index ¬ index + SIZE[OSICLNetworkTypes.SegmentationPart] * 2;	    END;	  END;	routing =>	  BEGIN	  index ¬ OSICLNetworkTypes.riHeaderLength + 1;	  IF body.ri.type = esHello THEN	    BEGIN	    index ¬ index + 1;	    THROUGH [0..body.addrs[0]) DO	      index ¬ index + body.bytes[index] + 1; --add each source addr	      ENDLOOP;	    END	  ELSE	    BEGIN	    index ¬ index + body.bytes[index] + 1; --add first addr	    IF body.ri.type = redirect THEN	      BEGIN	      index ¬ index + body.bytes[index] + 1; --add subnet addr	      index ¬ index + body.bytes[index] + 1; --add net	      END;	    END;	  END;	ENDCASE;      IF index <= body.ip.initialHeaderLength THEN optionIndex ¬ index;      END;    OsiIPCalculateOffsets[];    String.AppendString[line, "  OSI Network[fixed["L];    SELECT body.ip.protocolID FROM      standard =>        BEGIN        addressLabels: ARRAY [0..2) OF STRING ¬ 	  ["dest: "L, "source: "L];        OsiIPAppendProtocolId;	OsiIPAppendHeaderLength;	OsiIPAppendVersion;	OsiIPAppendLifetime[TRUE];        OsiIPAppendFlags[TRUE];	OsiIPAppendType;	OsiIPAppendSegmentLength;	OsiIPAppendChecksum;        String.AppendChar[line, ']];        OsiIPAppendAddresses[DESCRIPTOR[addressLabels]];        OsiIPAppendSegment;	OsiIPAppendOptions;       	END;      routing =>        BEGIN        OsiIPAppendProtocolId;	OsiIPAppendHeaderLength;	OsiIPAppendVersion;	OsiIPAppendZeroes;	OsiIPAppendType;	OsiIPAppendHoldTime;	OsiIPAppendChecksum;	String.AppendChar[line, ']];	SELECT body.ri.type FROM	  esHello => {            OsiIPAppendAddresses[NIL]};	  isHello => {            addressLabels: ARRAY [0..1) OF STRING ¬ 	      ["net: "L];            OsiIPAppendAddresses[DESCRIPTOR[addressLabels]]};	  redirect => {            addressLabels: ARRAY [0..3) OF STRING ¬ 	      ["dest: "L, "subnet: "L, "net: "L];            OsiIPAppendAddresses[DESCRIPTOR[addressLabels]]};	  ENDCASE => String.AppendString[line, ", addrs: [??]"L];        OsiIPAppendOptions;	END;      ENDCASE => String.AppendString[line, "??]"L];    String.AppendChar[line, ']];    outProc[line];    line.length ¬ 0;    END;  END.LOG23-Jun-87 19:05:57  SMA  Convert to new OSI PDU definitions.17-Jul-87 19:11:07  BKI  OSITransportTypes ¬ ISO8073Types.11-Aug-87 17:37:48  BKI  Fix OsiCotpPacket.tpduPtr assignment.17-Aug-87 17:53:16  BKI  OSITransportTypesExtra ¬ ISO8073TypesExtra.			 Fix OSI sequence numbers.20-Aug-87 17:48:13  BKI  Use OSIAddressConversion to format addresses.			 Support odd-byte-aligned segmentation part.			 Fix bugs documented in MataHari.readMe. 1-Sep-87 18:56:01  BKI  Remove reference to ISO8073TypesExtra.15-Apr-88 20:56:31  BKI  Support odd-byte-aligned TPDU.26-Apr-88 14:54:05  BKI  Fixed ESH PDU format.28-Apr-88 13:14:19  BKI  Fixed OsiAppendLongSequenceNumber.15-Jul-88 12:51:43  BKI  Fixed AppendErReasonValue.
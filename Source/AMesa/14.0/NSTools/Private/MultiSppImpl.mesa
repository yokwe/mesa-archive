-- File: MultiSppImpl.mesa - last edit:-- AOF                 10-Jul-87 10:38:39-- Copyright (C) 1987 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [StringToNetworkAddress, Error, PrintError],  Exec USING [    AddCommand, ExecProc, CheckForAbort, Handle, OutputProc, GetToken,    FreeTokenString, EndOfCommandLine, RemoveCommand],  Environment USING [Byte, bytesPerWord],  ExtendedString USING [StringToNumber],  Format USING [Decimal, LongDecimal, StringProc, NetworkAddress, Number],  Heap USING [Create, Delete],  Inline USING [BITSHIFT, DBITSHIFT, LowByte],  NetworkStream USING [closeSST, closeReplySST],  NSBuffer USING [Body, Buffer],  NSConstants USING [echoerSocket],  NSTypes USING [bytesPerSppHeader, maxDataBytesPerSpp],  PacketStream USING [    Handle, Make, unknownConnID, ConnectionFailed, ConnectionSuspended],  Process USING [    Abort, GetCurrent, MsecToTicks, Pause, SetPriority, TooManyProcesses],  ProcessPriorities USING [priorityClient, priorityClientHigh],  Router USING [GetDelayToNet, NoTableEntryForNet],  Socket USING [SetPacketBytes, WaitTime],  Stream USING [SubSequenceType],  String USING [AppendChar, SubString, SubStringDescriptor],  System USING [    NetworkAddress, SocketNumber, GetClockPulses, MicrosecondsToPulses,    PulsesToMicroseconds, nullNetworkAddress, GetGreenwichMeanTime];MultiSppImpl: PROGRAM  IMPORTS    AddressTranslation, Format, Exec, Inline, Heap, Process, Router, Socket,    System, ExtendedString, String, PacketStream  EXPORTS =  BEGIN    EchoProcType: TYPE = PROC[p: LONG POINTER TO EchoProcess];  EchoHeader: TYPE = LONG POINTER TO EchoObject;  EchoObject: TYPE = RECORD[    SELECT OVERLAID * FROM      desc => [echoType: EchoType, time: LONG CARDINAL, bytes: CARDINAL],      data => [echoBytes: PACKED ARRAY[0..0) OF Environment.Byte],      ENDCASE];  EchoType: TYPE = MACHINE DEPENDENT{    (FIRST[CARDINAL]), echoRequest(1), echoResponse(2), (LAST[CARDINAL])};  HistPointer: TYPE = LONG DESCRIPTOR FOR Histogram;  Histogram: TYPE = ARRAY CARDINAL[0..128) OF CARDINAL;  ProcessPointer: TYPE = LONG POINTER TO ProcessArray;  ProcessArray: TYPE = ARRAY CARDINAL[0..50) OF EchoProcess;  EchoProcess: TYPE = RECORD[    process: PROCESS ¬ NIL,    him: System.NetworkAddress ¬ null,    hist: HistPointer ¬ NIL,    out: Format.StringProc ¬ NIL,    waitTime: Socket.WaitTime ¬ 0,    hops: CARDINAL ¬ 0,    rate: LONG CARDINAL ¬ 0,    good, late, missed, bad: CARDINAL ¬ 0];  delay: CARDINAL = 2;  compute: CARDINAL = 1;  bpw: NATURAL = Environment.bytesPerWord;  bpeh: NATURAL = bpw * SIZE[desc EchoObject];  null: System.NetworkAddress = System.nullNetworkAddress;  forkingRate: LONG CARDINAL = System.MicrosecondsToPulses[5D5];    z: UNCOUNTED ZONE = Heap.Create[5];  ConvertAddress: PROC[s: LONG STRING, out: Format.StringProc]    RETURNS[a: System.NetworkAddress ¬ null] =    BEGIN    [a, ] ¬ AddressTranslation.StringToNetworkAddress[s !      AddressTranslation.Error =>	{AddressTranslation.PrintError[errorRecord, out]; CONTINUE}];    END;  --ConvertAddress  ExecCall: Exec.ExecProc =    BEGIN    rate: LONG CARDINAL ¬ 0;    waitTime: Socket.WaitTime;    destination: System.NetworkAddress;    remote, switches: LONG STRING ¬ NIL;    begin, end, process, hops: CARDINAL ¬ 0;    missed, bad, late, good, vcs: CARDINAL ¬ 0;    list: ProcessPointer ¬ z.NEW[ProcessArray ¬ ALL[[]]];    timeOfLastFork: LONG CARDINAL ¬ System.GetClockPulses[];    histogram: LONG POINTER TO Histogram ¬ z.NEW[Histogram ¬ ALL[0]];    dots: STRING = " ... "L;    out: Format.StringProc ¬ Exec.OutputProc[h];    Process.SetPriority[ProcessPriorities.priorityClient];    WHILE ~Exec.EndOfCommandLine[h] AND (process < LENGTH[list­]) DO      IF Exec.CheckForAbort[h] THEN EXIT;  --changed his mind      out["Echo to"L]; out[dots];      [remote, switches] ¬ Exec.GetToken[h];      destination ¬ null;  --give this a well known value      hops ¬ 16;  --and this (probably redundant)      IF remote # NIL THEN        BEGIN	out[remote]; out[dots]; out["converting address"L]; out[dots];        destination ¬ ConvertAddress[remote, out];	destination.socket ¬ NSConstants.echoerSocket;	out["("L]; Format.NetworkAddress[out, destination, hex];	remote ¬ Exec.FreeTokenString[remote]; out[") is "L];	hops ¬ Router.GetDelayToNet[destination.net !	  Router.NoTableEntryForNet => {hops ¬ 16; CONTINUE}];	waitTime ¬ LONG[compute + delay * hops] * 1000;	Format.Decimal[out, hops]; out[" hops away"L]; out[dots];	out["timeout set to "L]; Format.LongDecimal[out, waitTime]; out[dots];  	END;      IF switches # NIL THEN	BEGIN	ss: String.SubStringDescriptor ¬ [switches, 0, switches.length];	SELECT TRUE FROM	  (ss.offset = ss.length) => vcs ¬ 10;  --default value	  ((vcs ¬ SubStringToDecimal[@ss]) = 0) =>	    out["number of packet is zero"L];	  ENDCASE;	switches ¬ Exec.FreeTokenString[switches];	END;      IF (destination.host # null.host) AND (hops < 16) THEN        THROUGH [0..vcs) WHILE process IN[0..LENGTH[list­]) DO	  ENABLE Process.TooManyProcesses => GOTO tooMany;	  list[process] ¬ [	    him: destination, hist: DESCRIPTOR[histogram],	    out: out, waitTime: waitTime, hops: hops];	  UNTIL (System.GetClockPulses[] - timeOfLastFork) > forkingRate DO	    Process.Pause[Process.MsecToTicks[500]]; ENDLOOP;	  timeOfLastFork ¬ System.GetClockPulses[];  --that's now	  list[process].process ¬ FORK MultiSpp[@list[process]];	  out["["L];	  Format.Number[out, list[process].process, [16]];	  out["H] "L];	  process ¬ SUCC[process];	  ENDLOOP;      out["\n"L];      REPEAT        tooMany => {	  out["  too many processes at"L];	  Format.Decimal[out, process];	  out["\n"L]};      ENDLOOP;    Process.SetPriority[ProcessPriorities.priorityClientHigh];    UNTIL Exec.CheckForAbort[h] DO Process.Pause[2]; ENDLOOP;    out["Stopping connections ..."L];    FOR process IN[0..LENGTH[list­]) DO      IF list[process].process = NIL THEN EXIT;  --first NIL is end of list      Process.Abort[list[process].process];  --get his attention      JOIN list[process].process;  --and hist data      out["["L]; Format.Number[out, list[process].process, [16]]; out["H] "L];      good ¬ good + list[process].good;      late ¬ late + list[process].late;      missed ¬ missed + list[process].missed;      bad ¬ bad + list[process].bad;      rate ¬ rate + list[process].rate;      ENDLOOP;    Process.SetPriority[ProcessPriorities.priorityClient];    out["\n  "L]; Format.Decimal[out, good]; out[" packets echoed\n"L];    out["  "L]; Format.Decimal[out, late]; out[" packets late\n"L];    out["  "L]; Format.Decimal[out, missed]; out[" packets missed\n"L];    out["  "L]; Format.Decimal[out, bad]; out[" packets bad\n"L];    out["  "L]; Format.LongDecimal[out, rate]; out[" bps echoed\n"L];    out["Echo round trip times(msecs)\n"L];    FOR begin IN[0..LENGTH[histogram­]) DO      IF histogram[begin] # 0 THEN EXIT; ENDLOOP;    FOR end DECREASING IN[0..LENGTH[histogram­]) DO      IF histogram[end] # 0 THEN EXIT; ENDLOOP;    FOR i: CARDINAL IN[begin..end] DO      IF histogram[i] = 0 THEN LOOP;      out["  ["L];      Format.Decimal[out, Inline.BITSHIFT[1, INTEGER[i - 1]]];      out[".."L];      Format.LongDecimal[out, LONG[Inline.BITSHIFT[1, i]]];      out["): "L]; Format.Decimal[out, histogram[i]]; out["\n"L];      ENDLOOP;    z.FREE[@histogram]; z.FREE[@list];    END; -- ExecCall  SubStringToDecimal: PROC[ss: String.SubString] RETURNS[n: INTEGER] =    BEGIN    s: LONG STRING ¬ ss.base;    c: CHARACTER;  --individual characters    sf: STRING ¬ [10];  --the substring field    si: CARDINAL ¬ ss.offset;  --the substring index    base: CARDINAL ¬ 0;  --like a 10 with the '1' missing    UNTIL si = ss.length DO      c ¬ s[si]; si ¬ si + 1;      SELECT c FROM        IN['0..'7] => String.AppendChar[sf, c];        '8, '9 => {base ¬ MAX[base, 10]; String.AppendChar[sf, c]};        'A, 'C, 'E, 'F => {base ¬ 16; String.AppendChar[sf, c]};        'B, 'b =>          IF (si = ss.length) THEN base ¬ MAX[base, 8]          ELSE {base ¬ 16; String.AppendChar[sf, c]};        'D, 'd =>          IF (si = ss.length) OR (s[si] = '#) THEN base ¬ MAX[base, 10]          ELSE {base ¬ 16; String.AppendChar[sf, c]};        'H, 'h => IF (si = ss.length) THEN base ¬ 16 ELSE RETURN[0];        ENDCASE => RETURN[0];  --this is a failure      ENDLOOP;    IF sf.length = 0 THEN String.AppendChar[sf, '0];  --after all that!    IF base = 0 THEN base ¬ 10;  --never found any other evidence    ExtendedString.StringToNumber[@n, SIZE[INTEGER], base, sf]    END;  --SubStringToDecimal  DPout: PROC[out: Format.StringProc, s: LONG STRING] = --INLINE    BEGIN    out[" ["L];    Format.Number[out, Process.GetCurrent[], [16]];    out["H] "L]; out[s]; out["\n"L];    END;  --DPout  MultiSpp: EchoProcType =    BEGIN OPEN p;    echo: EchoHeader;    bb: NSBuffer.Body;    b: NSBuffer.Buffer ¬ NIL;    psH: PacketStream.Handle;    bits, micro: LONG CARDINAL;    sst: Stream.SubSequenceType;    bytes, milli, bitOn: CARDINAL;    psH ¬ PacketStream.Make[      System.nullNetworkAddress, him,      PacketStream.unknownConnID, PacketStream.unknownConnID,      TRUE, waitTime, bulk !	ABORTED, PacketStream.ConnectionFailed => GOTO exit;	Process.TooManyProcesses => GOTO tooMany];    bits ¬ 0; rate ¬ System.GetGreenwichMeanTime[];    FOR sent: CARDINAL IN[0..LAST[NATURAL]) DO      ENABLE        BEGIN	ABORTED => EXIT;	PacketStream.ConnectionSuspended =>	  {IF sst # NetworkStream.closeReplySST THEN	    DPout[out, "connection suspended... "L]; EXIT};	END;      b ¬ psH.getSendBuffer[];      bb ¬ b.ns;  --create local copy of data area pointer      SELECT TRUE FROM        (sst = NetworkStream.closeSST) =>	  {DPout[out, "closed by remote ..."L];	  bb.subtype ¬ NetworkStream.closeReplySST};	(sst = NetworkStream.closeReplySST) =>	  bb.subtype ¬ NetworkStream.closeReplySST;        ((LAST[NATURAL] - sent) = 1) =>	  bb.subtype ¬ NetworkStream.closeSST;	ENDCASE => bb.subtype ¬ 0;      echo ¬ LOOPHOLE[@bb.sppWords[0]];      bytes ¬ MAX[(sent MOD NSTypes.maxDataBytesPerSpp), bpeh];      bb.sppWords[2] ¬ bytes;  --that's the sequence number MODULO      FOR i: CARDINAL IN[bpeh..bytes) DO        bb.sppBytes[i] ¬ Inline.LowByte[i + bytes]; ENDLOOP;      echo.echoType ¬ echoRequest;      echo.time ¬ System.GetClockPulses[];      echo.bytes ¬ bytes;      Socket.SetPacketBytes[b, bytes + NSTypes.bytesPerSppHeader];      psH.put[b]; b ¬ NIL;  --send the packet      IF (b ¬ psH.get[]) = NIL THEN {missed ¬ missed + 1; LOOP};      bb ¬ b.ns;  --create local copy of data area pointer      echo ¬ LOOPHOLE[@bb.sppWords[0]];  --get pointer to time field      micro ¬ System.PulsesToMicroseconds[[System.GetClockPulses[] - echo.time]];      milli ¬ CARDINAL[micro / 1000];  --truncation might occur      IF (milli > waitTime) THEN late ¬ SUCC[late];      FOR bitOn ¬ 0, bitOn + 1 UNTIL milli = 0 DO	milli ¬ Inline.BITSHIFT[milli, -1]; ENDLOOP;      hist[bitOn] ¬ hist[bitOn] + 1;      bytes ¬ echo.bytes;      bits ¬ bits + Inline.DBITSHIFT[bytes, 3];      sst ¬ bb.subtype;  --copy out his sst      FOR i: CARDINAL IN[bpeh..bytes) DO        IF bb.sppBytes[i] # Inline.LowByte[i + bytes] THEN	  {bad ¬ bad + 1; EXIT};	REPEAT FINISHED => good ¬ good + 1;	ENDLOOP;      psH.returnReceiveBuffer[b];  --leave b # NIL so we exit      ENDLOOP;    rate ¬ System.GetGreenwichMeanTime[] - rate;  --elapsed time (seconds)    rate ¬ (bits + (rate / 2)) / MAX[rate, 1];  --and the bit rate / second    psH.destroy[psH];    EXITS      exit => {DPout[out, "connection failed..."L]};      tooMany => {DPout[out, "too many processes..."L]};    END;  --MultiSpp  ExecUnload: Exec.ExecProc =    {Heap.Delete[z]; Exec.RemoveCommand[h, "MultiSpp.~"L]};  --ExecUnload  ExecHelp: Exec.ExecProc =    BEGIN    out: Format.StringProc ¬ Exec.OutputProc[h];    out["MultiSpp.~ <remote>/<n>\n"L];    out["  'n' is the number of connections to be created to <remote>.\n"L];    out["Example\n>MultiSpp.~ FileServer/5 PrintServer/5\n"L];    END; -- ExecHelp  Exec.AddCommand[    name: "MultiSpp.~"L, proc: ExecCall, help: ExecHelp, unload: ExecUnload]  END.Log 3-Feb-87 15:32:46 AOF  Created file
-- File: LedSWs.mesa - last edit:-- AOF                 10-May-88 11:37:19-- BRD                  9-Feb-83 13:48:41  -- Copyright (C) 1983, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  Context USING [Create, Data, Find, Type, UniqueType],  Display USING [Bitmap, Handle, replaceFlags, TextInline],  LedSW USING [State, EnumeratedDescriptor, Position],  Heap USING[systemZone],  String USING [AppendString],  Tool USING[AddThisSW],  ToolWindow USING [CreateSubwindow, DisplayProcType, WindowForSubwindow],  Window USING[Box, GetBox],  WindowFont USING[FontHeight, CharWidth];LedSWs: MONITOR  IMPORTS    Context, Display, Heap, String, Tool, ToolWindow, WindowFont, Window  EXPORTS LedSW =  BEGIN  LedData: TYPE = LONG POINTER TO LedObject ¬ NIL;  LedObject: TYPE = RECORD[    sw: Display.Handle, leds: SEQUENCE length: CARDINAL OF Leds];  Leds: TYPE = RECORD[    box: Window.Box,    tag: LONG STRING,    pattern: LedSW.State];      white: WORD = 0;  on: WORD = 3770B;  off: WORD = 2010B;  onPattern: ARRAY [0..16) OF WORD ¬ [    white, white, white, white, on, on, on, on,    on, on, on, on, white, white, white, white];  offPattern: ARRAY [0..16) OF WORD ¬ [    white, white, white, white, on, off, off, off,    off, off, off, on, white, white, white, white];  whiteSpace: CARDINAL = 5;  lineHeight: CARDINAL ¬ WindowFont.FontHeight[];  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  elementWidth: INTEGER = 14*charWidth;  dataType: Context.Type = Context.UniqueType[];  zone: UNCOUNTED ZONE = Heap.systemZone;  GetData: PROC [w: Display.Handle] RETURNS [LedData] = {    RETURN Context.Find [dataType, w]};  GetDataSW: PROC [sw: Display.Handle] RETURNS [LedData] = {    RETURN Context.Find [dataType, ToolWindow.WindowForSubwindow [sw]]};    Create: PUBLIC PROC[    parent: Display.Handle, leds: LedSW.EnumeratedDescriptor,    position: LedSW.Position ¬ centered, nextSW: Display.Handle ¬ NIL]    RETURNS[sw: Display.Handle] =    BEGIN    parentBox: Window.Box ¬ Window.GetBox[parent];    y: CARDINAL ¬ whiteSpace;    row: CARDINAL ¬ 0;    j: INTEGER ¬ 0; -- j is the led index relative to the current row    ledData: LedData ¬ zone.NEW[LedObject[LENGTH[leds]]];    leftMargin: INTEGER ¬ (parentBox.dims.w - (elementWidth*LENGTH[leds]))/2;    rightMargin: INTEGER ¬ parentBox.dims.w - elementWidth/4;    IF (leftMargin < 0) OR (position = leftJustified) THEN      leftMargin ¬ elementWidth/4;     FOR i: CARDINAL IN[0..LENGTH[leds]) DO      -- check if room for more leds      IF leftMargin + j*elementWidth > rightMargin THEN        BEGIN	j ¬ 0;	row ¬ row + 1;	y ¬ (3*whiteSpace + lineHeight+16)*row + whiteSpace;	END;      ledData[i] ¬ [        tag: NIL, pattern: leds[i].state,	box: [[leftMargin + j*elementWidth, y], [16, 16]]];      IF leds[i].tag # NIL THEN         BEGIN	ledData[i].tag ¬ zone.NEW[StringBody[leds[i].tag.length]];	String.AppendString[ledData[i].tag, leds[i].tag];	END;      j ¬ j + 1;      ENDLOOP;    sw ¬ ToolWindow.CreateSubwindow[parent: parent, display: DisplayLeds];    ledData.sw ¬ sw;    Context.Create[dataType, ledData, FreeLedData, sw];    Tool.AddThisSW[window: parent, sw: sw, swType: vanilla, nextSW: nextSW,      h: (16+whiteSpace*2+lineHeight)*(row+1)];    END;    SetLed: PUBLIC ENTRY PROC[    sw: Display.Handle, which: CARDINAL, state: LedSW.State] =    BEGIN    ledData: LedData ¬ GetData[sw];    pattern: LONG POINTER TO ARRAY [0..16) OF WORD;    IF ledData[which].pattern = state THEN RETURN;    ledData[which].pattern ¬ state;    SELECT state FROM       on => pattern ¬ @onPattern;      off => pattern ¬ @offPattern;      ENDCASE;    Display.Bitmap[      window: sw, box: ledData[which].box, bitmapBitWidth: 16,      address: [pattern, 0, 0], flags: Display.replaceFlags];    END;    FreeLedData: PROCEDURE [data: Context.Data, sw: Display.Handle] =    BEGIN    ledData: LedData = LOOPHOLE[data];    FOR i: CARDINAL IN[0..ledData.length) DO      IF ledData[i].tag # NIL THEN zone.FREE[@ledData[i].tag]; ENDLOOP;    END;     DisplayLeds: ToolWindow.DisplayProcType =    BEGIN    pattern: LONG POINTER TO ARRAY[0..16) OF WORD;    ledData: LedData ¬ GetData[window];    FOR which: CARDINAL IN[0..ledData.length) DO      tag: LONG STRING ¬ ledData[which].tag;      center: CARDINAL = ledData[which].box.place.x + 8;      tagY: CARDINAL = ledData[which].box.place.y + whiteSpace + 16;      SELECT ledData[which].pattern FROM        on => pattern ¬ @onPattern;        off => pattern ¬ @offPattern;        ENDCASE;      Display.Bitmap[        window: window, box: ledData[which].box, bitmapBitWidth: 16,	address:[pattern, 0, 0], flags : Display.replaceFlags];      IF tag # NIL THEN [] ¬ Display.TextInline[window: window, string: tag,         place: [center - tag.length*charWidth/2, tagY], 	flags: Display.replaceFlags];      ENDLOOP;    END;  END...  LOG 7-Feb-83 13:13:57 BRD Sierra conversion29-Mar-88 15:23:15 AOF Make LEDs a little more petite
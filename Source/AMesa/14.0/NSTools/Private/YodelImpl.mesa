-- File: YodelImpl.mesa - last edit:-- AOF                 10-May-88 10:04:24-- kam                 16-Oct-85 11:36:36-- Copyright (C) 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved.DIRECTORY  AddressTranslation USING [Error, NetworkAddress, StringToNetworkAddress],  Buffer USING [    AccessHandle, Buffer, Dequeue, Device, Enqueue, GetBuffer,    QueueCleanup, QueueInitialize, QueueObject, ReturnBuffer],  Driver USING [Device, GetDeviceChain, nilDevice],  Environment USING [bitsPerByte, Byte, bytesPerWord],  Exec USING [AddCommand, ExecProc, Handle, OutputProc, RemoveCommand],  Flipper USING [ClearCounts, Create, Enumerated],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, line0, line2, line3,    line5, LongNumberItem, nullIndex, NumberItem, NumberNotifyProcType,    ProcType, StringItem, ToggleFlag],  Heap USING [Create, Delete],  IEEE8023 USING [maxDataBytesPerEthernetPacket],  Inline USING [DBITAND, LongCOPY, LowByte],  NetworkStream USING [closeReplySST, closeSST],  NSBuffer USING [    AccessHandle, Body, Buffer, Dequeue, Enqueue, GetBuffer,    QueueCleanup, QueueInitialize, QueueObject],  NSConstants USING [echoerSocket],  NSTypes USING [    Byte, bytesPerEchoHeader, bytesPerIDPHeader, bytesPerSppHeader,    EchoType, ErrorCode, maxIDPBytesPerPacket],  PacketStream USING [    ConnectionFailed, ConnectionSuspended, Handle, Make, unknownConnID],  Process USING [    Abort, Detach, Pause, priorityBackground, priorityForeground,    priorityNormal, SetPriority],  Protocol1 USING [    EncapsulateAndTransmit, Family, GetContext, GetFamilyUnit,    SetMaximumBufferSize],  Put USING [Text],  Router USING [GetDelayToNet, NoTableEntryForNet],  Socket USING [    ChannelHandle, Create, Delete, GetAssignedAddress, GetBufferPool,    GetPacket, infiniteWaitTime, PutPacket, ReturnBuffer,    SetPacketBytes, SetWaitTime, TimeOut],  Stream USING [SubSequenceType],  System USING [    GetClockPulses, Microseconds, MicrosecondsToPulses, NetworkAddress,    nullNetworkAddress, nullSocketNumber, Pulses, PulsesToMicroseconds],  Tool USING [Create, Destroy, MakeFormSW, MakeMsgSW, MakeSWsProc],  ToolWindow USING [TransitionProcType],  Window USING [Box, Handle];YodelImpl: MONITOR  IMPORTS    AddressTranslation, NSBuffer, Driver, Exec, Flipper, FormSW, Heap,    Inline, PacketStream, Process, Put, Protocol1, Router, Socket, System,    Tool  EXPORTS Buffer =  BEGIN  Device: PUBLIC TYPE = Driver.Device;  PutProc: TYPE = PROC[cH: Socket.ChannelHandle, b: NSBuffer.Buffer];    Protocol: TYPE = MACHINE DEPENDENT {IDP(0), SPP(1)};  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0), formSW(2), flipperSW1(4): Window.Handle ¬ NIL,    packetsSecond(6): CARDINAL ¬ 100,    deltaPPS(7): CARDINAL ¬ 5,    bytesPacket(8): CARDINAL ¬ 512,    deltaBPP(9): CARDINAL ¬ 20,    bitsSecond(10): LONG CARDINAL ¬ 0,    address(12): LONG STRING ¬ NIL,    pulsesPerPacket(14): LONG CARDINAL ¬ 0,    nsAddress(16): System.NetworkAddress ¬ System.nullNetworkAddress,    aborted(22): BOOLEAN ¬ FALSE,    transmitRate(23), receiveRate(25), requeueRate(27): LONG CARDINAL ¬ 0,    hops(29): CARDINAL ¬ 0,    sent(30): LONG CARDINAL ¬ 0,    received(32): LONG CARDINAL ¬ 0,    bad(34): LONG CARDINAL ¬ 0,    error(36): LONG CARDINAL ¬ 0,    sentBytesPerInterval(38): LONG CARDINAL ¬ 0,    receivedBytesPerInterval(40): LONG CARDINAL ¬ 0,    requeueTotalPerInterval(42): LONG CARDINAL ¬ 0,    protocol(44): Protocol ¬ IDP,    sst(45): Stream.SubSequenceType ¬ 0,    setUp(46): BOOLEAN ¬ FALSE,    sentPacketsPerInterval(47): CARDINAL ¬ 0,    receivedPacketsPerInterval(48): CARDINAL ¬ 0,    transmitPacketRate(49), receivePacketRate(51): LONG CARDINAL ¬ 0,    flipperSW2(53): Window.Handle ¬ NIL,    family(55): Protocol1.Family ¬ Protocol1.GetFamilyUnit[ns],    bufferSize(57): CARDINAL ¬ TRASH --family.maxBufferSize--];  FormItems: TYPE = {    start, stop, protocol, address, minusPPSDelta, packetsSecond, plusPPSDelta,    deltaPPS, minusBPPDelta, bytesPacket, plusBPPDelta, deltaBPP, bitsSecond};    data: Data;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE = Heap.Create[10];  overhead: CARDINAL = NSTypes.bytesPerIDPHeader;  EchoHeader: TYPE = LONG POINTER TO EchoObject;  EchoObject: TYPE = RECORD[    SELECT OVERLAID * FROM      desc => [echoType: EchoType, time: LONG CARDINAL, bytes: CARDINAL],      data => [echoBytes: PACKED ARRAY[0..0) OF Environment.Byte],      ENDCASE];  EchoType: TYPE = MACHINE DEPENDENT{    (FIRST[CARDINAL]), echoRequest(1), echoResponse(2), (LAST[CARDINAL])};  bpeh: NATURAL = bpw * SIZE[desc EchoObject];  bpw: NATURAL = Environment.bytesPerWord;    producer: PROCESS ¬ NIL;  displayer: PROCESS ¬ NIL;    initialBox: Window.Box = [place: [x:0, y: 30], dims: [w: 612, h: 225]];  minPPS: CARDINAL = 1;  maxPPS: CARDINAL = LAST[NATURAL];  PlusPPSDelta: FormSW.ProcType =    BEGIN    data.packetsSecond ¬ MAX[      MIN[maxPPS, data.packetsSecond + data.deltaPPS], minPPS];    FormSW.DisplayItem[data.formSW, FormItems.packetsSecond.ORD];    CalculateBitRate[];    END;  MinusPPSDelta: FormSW.ProcType =    BEGIN    data.packetsSecond ¬      MIN[(        IF data.packetsSecond < data.deltaPPS + minPPS THEN minPPS        ELSE data.packetsSecond - data.deltaPPS), maxPPS];    FormSW.DisplayItem[data.formSW, FormItems.packetsSecond.ORD];    CalculateBitRate[];    END;  MaxBBP: PROC[] RETURNS [CARDINAL] = {    IF ~Running[] THEN data.bufferSize ¬ data.family.maxBufferSize;    RETURN[data.bufferSize - overhead - (IF data.protocol = IDP THEN      NSTypes.bytesPerEchoHeader ELSE NSTypes.bytesPerSppHeader)]};  minBBP: CARDINAL = 6;  PlusBPPDelta: FormSW.ProcType =    BEGIN    data.bytesPacket ¬ MAX[      MIN[MaxBBP[], data.bytesPacket + data.deltaBPP], minBBP];    FormSW.DisplayItem[data.formSW, FormItems.bytesPacket.ORD];    CalculateBitRate[];    END;  MinusBPPDelta: FormSW.ProcType =    BEGIN    data.bytesPacket ¬ MIN[(      IF data.bytesPacket < data.deltaBPP + minBBP THEN minBBP      ELSE data.bytesPacket - data.deltaBPP), MaxBBP[]];    FormSW.DisplayItem[data.formSW, FormItems.bytesPacket.ORD];    CalculateBitRate[];    END;    CalculateBitRate: PROCEDURE [display: BOOLEAN ¬ TRUE] =    BEGIN    data.bufferSize ¬ data.family.maxBufferSize;    IF data.packetsSecond # 0 THEN      data.pulsesPerPacket ¬ System.MicrosecondsToPulses[1D6/data.packetsSecond];    data.bitsSecond ¬ LONG[data.packetsSecond] * (LONG[data.bytesPacket]      + (IF data.protocol = IDP THEN NSTypes.bytesPerEchoHeader        ELSE NSTypes.bytesPerSppHeader)) * LONG[Environment.bitsPerByte];    IF display THEN FormSW.DisplayItem[data.formSW, FormItems.bitsSecond.ORD];    END;  Start: FormSW.ProcType =    BEGIN    ok: BOOLEAN ¬ TRUE;    data.nsAddress ¬ System.nullNetworkAddress;    IF Running[] THEN {      Put.Text[data.msgSW, "Tool already running\n"L]; RETURN};    IF data.address = NIL THEN {      Put.Text[data.msgSW, "No address specified\n"L]; RETURN};    data.nsAddress ¬ AddressTranslation.StringToNetworkAddress[      data.address ! AddressTranslation.Error => {      Put.Text[data.msgSW, "Address translation error\n"L];      ok ¬ FALSE;      CONTINUE}].addr;    Protocol1.SetMaximumBufferSize[      Driver.nilDevice, data.family, IEEE8023.maxDataBytesPerEthernetPacket];    data.bufferSize ¬ data.family.maxBufferSize;    IF data.bytesPacket NOT IN [minBBP .. MaxBBP[]] THEN {      Put.Text[data.msgSW, "Bytes/Packet is out of bounds\n"L]; RETURN};    IF data.packetsSecond NOT IN [minPPS .. maxPPS] THEN {      Put.Text[data.msgSW, "Packets/Second is out of bounds\n"L]; RETURN};    data.hops ¬ Router.GetDelayToNet[data.nsAddress.net !      Router.NoTableEntryForNet => {data.hops ¬ 16; CONTINUE}];    data.nsAddress.socket ¬ NSConstants.echoerSocket;    FormSW.ToggleFlag[data.formSW, FormItems.packetsSecond.ORD, readOnly];    FormSW.ToggleFlag[data.formSW, FormItems.bytesPacket.ORD, readOnly];    FormSW.ToggleFlag[data.formSW, FormItems.protocol.ORD, readOnly];    data.sent ¬ data.received ¬ data.bad ¬ data.receivedBytesPerInterval      ¬ data.sentBytesPerInterval ¬ data.requeueTotalPerInterval      ¬ data.sentPacketsPerInterval ¬ data.receivedPacketsPerInterval ¬ 0;    Put.Text[data.msgSW, "\n"L];    Flipper.ClearCounts[data.flipperSW1];    Flipper.ClearCounts[data.flipperSW2];    producer ¬ IF data.protocol = IDP THEN      FORK IDPProducer[] ELSE FORK SPPProducer[];    displayer ¬ FORK DisplayRealRate[];    END;  Stop: FormSW.ProcType =    BEGIN    Put.Text[data.msgSW, "\n"L];    IF NOT Running[] THEN {Put.Text[data.msgSW, "Tool not running\n"L]; RETURN};    BackOut[];    data.aborted ¬ TRUE;    IF data.protocol = IDP OR NOT data.setUp THEN Process.Abort[producer];    JOIN producer;    data.aborted ¬ FALSE;    producer ¬ NIL;    Protocol1.SetMaximumBufferSize[      Driver.nilDevice, data.family, NSTypes.maxIDPBytesPerPacket];    END;    BackOut: PROCEDURE =    BEGIN    Process.Abort[displayer];    JOIN displayer;    displayer ¬ NIL;    FormSW.ToggleFlag[data.formSW, FormItems.packetsSecond.ORD, readOnly];    FormSW.ToggleFlag[data.formSW, FormItems.bytesPacket.ORD, readOnly];    FormSW.ToggleFlag[data.formSW, FormItems.protocol.ORD, readOnly];    END;  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      (old = inactive) => {data ¬ []; CalculateBitRate[FALSE]};      (new = inactive) => IF Running[] THEN Stop[NIL, NIL, FormSW.nullIndex];      ENDCASE;    END;  Init: PROCEDURE =    BEGIN    Exec.AddCommand["Yodel.~"L, NoOp, NIL, Unload];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, -- initialBox: initialBox, --      clientTransition: ClientTransition, name: "Yodel"L,      cmSection: "Yodel"L];    END;  NoOp: Exec.ExecProc = { };    Unload: Exec.ExecProc = {    IF Running[] THEN {      Exec.OutputProc[h]["Tool is busy. Sorry.\n"L];      RETURN[error] };    Tool.Destroy[wh];    Exec.RemoveCommand[h, "Yodel.~"L];    Heap.Delete[zone]};  MakeSWs: Tool.MakeSWsProc =    BEGIN    flippers1: ARRAY [0.. 4) OF Flipper.Enumerated ¬ [      ["Sent"L, @data.sent], ["Rec'd"L, @data.received],      ["Bad"L, @data.bad], ["Err"L, @data.error]];    flippers2: ARRAY [0.. 5) OF Flipper.Enumerated ¬ [      ["Sent(pps)"L, @data.transmitPacketRate],      ["Rec'd(pps)"L, @data.receivePacketRate],      ["Sent(bps)"L, @data.transmitRate],      ["Rec'd(bps)"L, @data.receiveRate],      ["Requeue(usec)"L, @data.requeueRate]];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: zone];    data.flipperSW1 ¬ Flipper.Create[      parent: window, flippers: DESCRIPTOR[flippers1], state: [left, on],      position: centered, priority: Process.priorityNormal];    data.flipperSW2 ¬ Flipper.Create[      parent: window, flippers: DESCRIPTOR[flippers2], state: [off, on],      position: centered, priority: Process.priorityNormal];    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    protocol: ARRAY[0..2) OF Enumerated ¬ [      ["IDP"L, Protocol.IDP.ORD], ["SPP"L, Protocol.SPP.ORD]];    items ¬ AllocateItemDescriptor[nItems, zone];    items[FormItems.start.ORD] ¬ CommandItem[      tag: "Start"L, place: [6, line0], proc: Start, z: zone];    items[FormItems.stop.ORD] ¬ CommandItem[      tag: "Stop"L, place: [72, line0], proc: Stop];    items[FormItems.protocol.ORD] ¬ EnumeratedItem[      tag: "protocol"L, place: [138, line0], choices: DESCRIPTOR[protocol],      value: @data.protocol, z: zone];    items[FormItems.address.ORD] ¬ StringItem[      tag: "Address"L, place: [270, line0], inHeap: TRUE,      string: @data.address, z: zone];    items[FormItems.minusPPSDelta.ORD] ¬ CommandItem[      tag: "-"L, place: [6, line2], drawBox: TRUE,      proc: MinusPPSDelta, z: zone];    items[FormItems.packetsSecond.ORD] ¬ NumberItem[      tag: "Packets/Second"L, place: [72, line2], signed: FALSE,      value: @data.packetsSecond, z: zone];    items[FormItems.plusPPSDelta.ORD] ¬ CommandItem[      tag: "+"L, place: [270, line2], drawBox: TRUE,      proc: PlusPPSDelta, z: zone];    items[FormItems.deltaPPS.ORD] ¬ NumberItem[      tag: "delta"L, place: [324, line2], signed: FALSE,      value: @data.deltaPPS, z: zone];    items[FormItems.minusBPPDelta.ORD] ¬ CommandItem[      tag: "-"L, place: [6, line3], drawBox: TRUE,      proc: MinusBPPDelta, z: zone];    items[FormItems.bytesPacket.ORD] ¬ NumberItem[      tag: "Bytes/Packet"L, place: [72, line3], signed: FALSE,      value: @data.bytesPacket, z: zone];    items[FormItems.plusBPPDelta.ORD] ¬ CommandItem[      tag: "+"L, place: [270, line3], drawBox: TRUE,      proc: PlusBPPDelta, z: zone];    items[FormItems.deltaBPP.ORD] ¬ NumberItem[      tag: "delta"L, place: [324, line3], signed: FALSE,      value: @data.deltaBPP, z: zone];    items[FormItems.bitsSecond.ORD] ¬ LongNumberItem[      tag: "Calculated Bits/Second"L, place: [138, line5], readOnly: TRUE,      signed: FALSE, value: @data.bitsSecond, z: zone];    RETURN[items: items, freeDesc: TRUE];    END;    FormSWSetBitRate: FormSW.NumberNotifyProcType = {CalculateBitRate[]};      Running: PROCEDURE RETURNS [BOOLEAN] = {RETURN[producer # NIL]};  DisplayRealRate: PROCEDURE =    BEGIN    lastSent: LONG CARDINAL ¬ data.sent;    interval: System.Pulses = System.MicrosecondsToPulses[2D6];    start: System.Pulses ¬ System.GetClockPulses[];    Process.SetPriority[Process.priorityNormal];    DO ENABLE ABORTED => EXIT;      delta, tempR, tempT, tempQ, tempRP, tempTP: LONG CARDINAL;      Process.Pause[5];  --wait a little while      IF (delta ¬ System.GetClockPulses[] - start) > interval THEN	BEGIN	usec: System.Microseconds = System.PulsesToMicroseconds[[delta]];	start ¬ System.GetClockPulses[];  --this is where we are now	tempQ ¬ IF data.sent = lastSent THEN 0	  ELSE data.requeueTotalPerInterval / (data.sent - lastSent);	lastSent ¬ data.sent;	data.requeueTotalPerInterval ¬ 0;	tempR ¬ data.receivedBytesPerInterval;	data.receivedBytesPerInterval ¬ 0;	tempT ¬ data.sentBytesPerInterval;	data.sentBytesPerInterval ¬ 0;	tempRP ¬ data.receivedPacketsPerInterval;	data.receivedPacketsPerInterval ¬ 0;	tempTP ¬ data.sentPacketsPerInterval;	data.sentPacketsPerInterval ¬ 0;	tempR ¬ Environment.bitsPerByte * tempR;	tempR ¬ tempR * 1D3 / usec;	data.receiveRate ¬ tempR * 1D3;	tempT ¬ Environment.bitsPerByte * tempT;	tempT ¬ tempT * 1D3 / usec;	data.transmitRate ¬ tempT * 1D3;		data.transmitPacketRate ¬ (tempTP * 1D6 + usec - 1) / usec;	data.receivePacketRate ¬ (tempRP * 1D6 + usec - 1) / usec;	data.requeueRate ¬ System.PulsesToMicroseconds[[tempQ]];	END;      ENDLOOP;    END;    IDPProducer: PROCEDURE =     BEGIN        Requeue: ENTRY PROCEDURE [b: NSBuffer.Buffer] =      BEGIN      data.requeueTotalPerInterval ¬  --keep track of requeue times        data.requeueTotalPerInterval +  --might be due to collisions        (System.GetClockPulses[] - b.fo.time);      NSBuffer.Enqueue[@queueObject, b];      END;  --Requeue        Dequeue: ENTRY PROCEDURE RETURNS [b: NSBuffer.Buffer] = INLINE {      RETURN NSBuffer.Dequeue[@queueObject]};    QuickSend: PutProc =      BEGIN      bb: NSBuffer.Body ¬ b.ns;  --local copy      b.fo.network ¬ device;      b.fo.context ¬ context;      bb.transportControl ¬ [FALSE, 0, 0];      bb.checksum ¬ 177777B;  --let's not for now      Protocol1.EncapsulateAndTransmit[LOOPHOLE[b], @bb.destination.host];      END;  --QuickSend    bb: NSBuffer.Body;    put: PutProc ¬ NIL;    b: NSBuffer.Buffer ¬ NIL;    consumer: PROCESS ¬ NIL;    queueObject: NSBuffer.QueueObject;    socket: Socket.ChannelHandle ¬ Socket.Create[      System.nullSocketNumber, 10, 10];    pool: NSBuffer.AccessHandle = Socket.GetBufferPool[socket];    me: System.NetworkAddress = Socket.GetAssignedAddress[socket];    device: Device = Driver.GetDeviceChain[];  --first one on chain    context: LONG POINTER = Protocol1.GetContext[device, ns];    NSBuffer.QueueInitialize[@queueObject];    Process.SetPriority[Process.priorityBackground];    Socket.SetWaitTime[socket, Socket.infiniteWaitTime];    consumer ¬ FORK IDPConsumer[socket];    put ¬ SELECT TRUE FROM      (data.hops # 0) => Socket.PutPacket,      (me.host = data.nsAddress.host) => Socket.PutPacket,      ENDCASE => QuickSend;    DO ENABLE ABORTED => EXIT;      echo: EchoHeader;      bytes: CARDINAL = data.bytesPacket;      bytesPerPacket: CARDINAL = bytes +        NSTypes.bytesPerEchoHeader +        NSTypes.bytesPerIDPHeader;      pulses: System.Pulses = System.GetClockPulses[];      IF data.aborted THEN GOTO Aborted;      IF (b ¬ Dequeue[]) = NIL THEN        BEGIN        b ¬ NSBuffer.GetBuffer[pool, send, TRUE, bytesPerPacket];	bb ¬ b.ns;  --local copy of body	b.requeueProcedure ¬ Requeue;	bb.destination ¬ data.nsAddress;	bb.packetType ¬ echo;	bb.source ¬ me;	echo ¬ LOOPHOLE[@bb.echoType, EchoHeader];	FOR i: CARDINAL IN [bpeh..MaxBBP[]) DO	  echo.echoBytes[i] ¬ i; ENDLOOP;	END      ELSE        BEGIN	bb ¬ b.ns;  --in cases where we don't use the old value	echo ¬ LOOPHOLE[@bb.echoType, EchoHeader];  --and of this	END;      echo.echoType ¬ echoRequest;      echo.time ¬ pulses;      echo.bytes ¬ bytes;      bb.pktLength ¬ bytesPerPacket;      b.fo.time ¬ System.GetClockPulses[];  --that's when the packet goes out      put[socket, b];  --send using appropriate routine      data.sent ¬ SUCC[data.sent];      data.sentPacketsPerInterval ¬ SUCC[data.sentPacketsPerInterval];      data.sentBytesPerInterval ¬ data.sentBytesPerInterval + bytes;      DO        now: System.Pulses ¬ System.GetClockPulses[];	IF now - pulses > data.pulsesPerPacket THEN EXIT;        ENDLOOP;      REPEAT Aborted => NULL;      ENDLOOP;    Process.Abort[consumer];    JOIN consumer;    NSBuffer.QueueCleanup[@queueObject];    Socket.Delete[socket];    END;      IDPConsumer: PROCEDURE [socket: Socket.ChannelHandle] =    BEGIN    Process.SetPriority[Process.priorityForeground];    DO ENABLE ABORTED => EXIT;      bytes: CARDINAL;      bb: NSBuffer.Body;      b: NSBuffer.Buffer;      b ¬ Socket.GetPacket[socket ! Socket.TimeOut => RETRY];      bb ¬ b.ns;  --local copy      SELECT bb.packetType FROM        echo =>	  BEGIN	  echoData: EchoHeader ¬ LOOPHOLE[@bb.echoType];	  data.received ¬ SUCC[data.received];	  data.receivedPacketsPerInterval ¬ SUCC[data.receivedPacketsPerInterval];	  bytes ¬ echoData.bytes;	  data.receivedBytesPerInterval ¬ data.receivedBytesPerInterval + bytes;	  FOR i: CARDINAL IN [bpeh..bytes) DO	    IF echoData.echoBytes[i] # Inline.LowByte[i] THEN	      {data.bad ¬ SUCC[data.bad]; EXIT};	    ENDLOOP;	  END;	error =>	  BEGIN	  SELECT NSTypes.ErrorCode[bb.errorType].ORD FROM	    1005B, 1006B =>	      IF Inline.DBITAND[data.error, -8] = 0 THEN MinusPPSDelta[];	    ENDCASE;	  data.error ¬ SUCC[data.error];	  END;	ENDCASE => data.bad ¬ SUCC[data.bad];      Socket.ReturnBuffer[b];      ENDLOOP;    END;    SPPProducer: PROCEDURE =     BEGIN    bytes: CARDINAL;    echo: EchoHeader;    bb: NSBuffer.Body;    pulses: System.Pulses;    consumer: PROCESS ¬ NIL;    b: NSBuffer.Buffer ¬ NIL;    psH: PacketStream.Handle ¬ NIL;    sst: Stream.SubSequenceType;    DataArray: TYPE = RECORD[      PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte];    pktData: LONG POINTER TO DataArray ¬ NIL;    BEGIN    data.setUp ¬ FALSE;    Process.SetPriority[Process.priorityBackground];    data.sst¬ 0;    psH ¬ PacketStream.Make[      System.nullNetworkAddress, data.nsAddress,      PacketStream.unknownConnID, PacketStream.unknownConnID,      TRUE, Socket.infiniteWaitTime, bulk !      PacketStream.ConnectionFailed => GOTO CantEstablish;      ABORTED => GOTO Aborted];    psH.setSenderSizeLimit[MaxBBP[]];  --maybe larger, maybe not    consumer ¬ FORK SPPConsumer[psH];    data.setUp ¬ TRUE;    pktData ¬ zone.NEW[DataArray[MaxBBP[]]];    FOR i: CARDINAL IN [bpeh.. MaxBBP[]) DO pktData[i] ¬ i; ENDLOOP;    DO ENABLE PacketStream.ConnectionSuspended => GOTO ConnectionGone;      pulses ¬ System.GetClockPulses[];      bytes ¬ data.bytesPacket;      bb ¬ (b ¬ psH.getSendBuffer[]).ns;      sst ¬ bb.subtype ¬ SELECT TRUE FROM        data.sst # 0 => NetworkStream.closeReplySST,	data.aborted => NetworkStream.closeSST,	ENDCASE => 0;      echo ¬ LOOPHOLE[@bb.sppBody, EchoHeader];      Inline.LongCOPY[from: pktData, to: echo, nwords: bytes / bpw];      echo.echoType ¬ echoRequest;      echo.time ¬ pulses;      echo.bytes ¬ bytes;      Socket.SetPacketBytes[b, bytes + NSTypes.bytesPerSppHeader];      psH.put[b];      data.sent ¬ SUCC[data.sent];      data.sentPacketsPerInterval ¬ SUCC[data.sentPacketsPerInterval];      data.sentBytesPerInterval ¬ data.sentBytesPerInterval + bytes;      b ¬ NIL;      IF sst = NetworkStream.closeReplySST THEN EXIT;      DO        now: System.Pulses ¬ System.GetClockPulses[];	IF now - pulses > data.pulsesPerPacket THEN EXIT;        ENDLOOP;      ENDLOOP;    JOIN consumer;    psH.destroy[psH];    zone.FREE[@pktData];    EXITS      Aborted => NULL;      CantEstablish =>	BEGIN	Put.Text[data.msgSW, "Can't establish Spp connection\n"L];	BackOut[];	Process.Detach[producer];	producer ¬ NIL;	END;      ConnectionGone =>        BEGIN	JOIN consumer;	Put.Text[data.msgSW, "Connection was suspended\n"L];	BackOut[];	Process.Detach[producer];	producer ¬ NIL;        psH.destroy[psH];	zone.FREE[@pktData];	END;    END;    END;    SPPConsumer: PROCEDURE [psH: PacketStream.Handle] =    BEGIN    bytes: CARDINAL;    echo: EchoHeader;    bb: NSBuffer.Body;    b: NSBuffer.Buffer;    Process.SetPriority[Process.priorityForeground];    DO ENABLE ABORTED, PacketStream.ConnectionSuspended => EXIT;      b ¬ psH.get[]; data.received ¬ SUCC[data.received];      bb ¬ b.ns;  --local pointer to body      echo ¬ LOOPHOLE[@bb.sppBody, EchoHeader];      data.receivedPacketsPerInterval ¬ SUCC[data.receivedPacketsPerInterval];      bytes ¬ echo.bytes;      data.receivedBytesPerInterval ¬ data.receivedBytesPerInterval + bytes;      data.sst ¬ bb.subtype;      FOR i: CARDINAL IN [bpeh.. bytes) DO	IF echo.echoBytes[i] # Inline.LowByte[i] THEN	  {data.bad ¬ SUCC[data.bad]; EXIT};	ENDLOOP;      psH.returnReceiveBuffer[b];      IF data.sst = NetworkStream.closeReplySST THEN EXIT;      ENDLOOP;    END;  Init[];  END...    
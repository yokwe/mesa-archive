-- File: SptpTraceTool.mesa - last edit:-- AOF                 18-Mar-88 11:44:23-- Create by FormSWLayoutTool on 16-Jan-88 16:08-- Copyright (C) 1988 by Xerox Corporation. All rights reserved.DIRECTORY  Buffer USING [Device],  ByteBlt USING [ByteBlt],  CommUtil USING [AllocateBuffers, FreeBuffers],  Driver USING [Device],  Environment USING [Block, Byte, bytesPerPage, bytesPerWord],  Exec USING [AddCommand, ExecProc, Handle, OutputProc, RemoveCommand],  Format USING [Number, StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, Enumerated,    EnumeratedItem, line0, ProcType],  Heap USING [Create, Delete],  NewRS232CFace USING [DeviceStatus],  Process USING [Detach, priorityBackground, SetPriority],  Put USING [Text],  SptpOps USING [GetDevice, SetTrace, TraceProc],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Box, Handle],  WindowFont USING [CharWidth];SptpTraceTool: MONITOR  IMPORTS    ByteBlt, CommUtil, Exec, Format, FormSW, Heap, Process,    Put, SptpOps, Tool, WindowFont  EXPORTS Buffer = {  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    mode(6): OperationalMode ¬ capture,    save(7): OperationalMode ¬ capture,    running(8): BOOLEAN ¬ FALSE,    abort(9): BOOLEAN ¬ TRUE,    format(10): OutputFormat ¬ hex,    bytesleft(11): INTEGER ¬ fortyPagesOfBytes,    buffer(12): LONG POINTER ¬ NIL,    pointer(14): LONG POINTER TO TraceRecord ¬ NIL];  FormItems: TYPE = {start, stop, mode, format};  OperationalMode: TYPE = {capture, display};  OutputFormat: TYPE = {octal1, octal2, decimal, hex, ascii};  busyBit: BOOLEAN ¬ FALSE;  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.Create[initial: 4];  bpw: NATURAL = Environment.bytesPerWord;  bpp: NATURAL = Environment.bytesPerPage;  fortyPagesOfBytes: NATURAL = (40 * bpp);  initialBox: Window.Box = [place: [x:0, y: 30], dims: [w: 512, h: 740]];  Frame: TYPE = RECORD[    length: NATURAL,    variant: SELECT type: OutputFormat FROM      octal2, decimal =>        [data: LONG POINTER TO PACKED ARRAY[0..0) OF WORD],      octal1, hex, ascii =>        [data: LONG POINTER TO PACKED ARRAY[0..0) OF Environment.Byte],      ENDCASE];  TraceRecord: TYPE = RECORD[    length: INTEGER, --negative => tx, positive => rx, 0 => end of list    dte: NewRS232CFace.DeviceStatus];  --apparent status at end of operation  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    ENABLE UNWIND => NULL;    isBusy ¬ busyBit;    busyBit ¬ TRUE };  Done: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    busyBit ¬ FALSE};  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};  Start:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    device: Device = SptpOps.GetDevice[0];    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    SELECT TRUE FROM      (data.running) => Msg["\nAlready running"];      ((data.save ¬ data.mode) = display) =>        BEGIN	data.abort ¬ FALSE;        Process.Detach[FORK SptpDisplayProc[]];	Msg["\nDisplay mode tracing started"L];	Write["\nDisplay mode tracing started\n"L];	data.running ¬ TRUE;	END;      (device = NIL) => Msg["\nNo Sptp device"L];      (data.save = capture) =>        BEGIN	IF data.buffer = NIL THEN	  data.buffer ¬ CommUtil.AllocateBuffers[fortyPagesOfBytes];	data.pointer ¬ data.buffer;  --reset | empty buffer	data.bytesleft ¬ fortyPagesOfBytes;  --entire buffer available	data.pointer.length ¬ 0;  --like the end of the trace	[] ¬ SptpOps.SetTrace[device, SptpCaptureProc];	Msg["\nCapture mode tracing started"L];	Write["\nCapture mode tracing started\n"L];	data.running ¬ TRUE;	END;      ENDCASE;    Done[] };  Stop:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    device: Device = SptpOps.GetDevice[0];    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    SELECT TRUE FROM      (~data.running) => Msg["\nNothing running"];      (data.save = display) =>        {data.abort ¬ TRUE; Msg["\nDisplay tracing aborted"L]};      (device = NIL) =>        BEGIN	Msg["\nNo Sptp device"L];	Write["\nCapture tracing stopped\n"L];	END;      (data.save = capture) =>        BEGIN	[] ¬ SptpOps.SetTrace[device, NIL];	Msg["\nCapture tracing stopped"L];	Write["\nCapture tracing stopped\n"L];	END;      ENDCASE;    data.running ¬ FALSE;  --reset running boolean    Done[] };  SptpCaptureProc: SptpOps.TraceProc =    BEGIN    to: Environment.Block = [      LOOPHOLE[data.pointer], bpw * SIZE[TraceRecord],      (data.bytesleft - (bpw * SIZE[TraceRecord]))];    moved: NATURAL ¬ ByteBlt.ByteBlt[from: frame, to: to];    data.pointer­ ¬ [IF direction = tx THEN -moved ELSE moved, dte];    IF moved MOD 2 # 0 THEN moved ¬ moved.SUCC;  --round up byte length    data.pointer ¬ data.pointer + (moved / bpw) + SIZE[TraceRecord];    data.pointer­.length ¬ 0;  --zero end of list    data.bytesleft ¬ data.bytesleft - moved - (SIZE[TraceRecord] * bpw);    IF data.bytesleft <= (bpw * SIZE[TraceRecord]) THEN Stop[];    END;  --SptpTraceProc  SptpDisplayProc: PROC =    BEGIN    frame: Frame;    index, length, words: NATURAL ¬ 0;    trace: LONG POINTER TO TraceRecord;    Process.SetPriority[Process.priorityBackground];    FOR trace ¬ data.buffer, trace + words + SIZE[TraceRecord]      UNTIL data.abort DO      IF (length ¬ ABS[trace.length]) = 0 THEN EXIT;      words ¬ (length + bpw - 1) / bpw;      frame ¬ SELECT data.format FROM        octal1 => [length, octal1[LOOPHOLE[trace + SIZE[TraceRecord]]]],        octal2 => [words, octal2[LOOPHOLE[trace + SIZE[TraceRecord]]]],        decimal => [words, decimal[LOOPHOLE[trace + SIZE[TraceRecord]]]],        hex => [length, hex[LOOPHOLE[trace + SIZE[TraceRecord]]]],        ENDCASE => [length, ascii[LOOPHOLE[trace + SIZE[TraceRecord]]]];      Write[IF trace.length < 0 THEN "\nTx"L ELSE "\nRx"L];      Write[" Frame# "]; Format.Number[Write, index, []];      Write[" - DeviceStatus["L];      IF trace.dte.breakDetected THEN Write[" break "L];      IF trace.dte.dataLost THEN Write[" lost "L];      IF trace.dte.ringHeard THEN Write[" ring "L];      IF trace.dte.carrierDetect THEN Write[" cd "L];      IF trace.dte.clearToSend THEN Write[" cts "L];      IF trace.dte.dataSetReady THEN Write[" dsr "L];      IF trace.dte.ringIndicator THEN Write[" ri "L];      Write["]\n("L]; Format.Number[Write, length, []]; Write[") "L];      DumpBlock[frame];  --print the block      index ¬ index.SUCC;      ENDLOOP;    data.running ¬ FALSE;    Msg["\nDisplay trace ending"L];     Write["\nDisplay trace ending\n"L];     END;  --SptpDisplayProc  DumpBlock: PROC[frame: Frame] =    BEGIN    FOR i: NATURAL IN[0..frame.length) DO      WITH ff: frame SELECT FROM	octal1 => Format.Number[Write, ff.data[i], [8, TRUE, TRUE, 3]];        octal2 => Format.Number[Write, ff.data[i], [8, TRUE, TRUE, 7]];        decimal => Format.Number[Write, ff.data[i], [10, TRUE, TRUE, 5]];        hex => Format.Number[Write, ff.data[i], [16, TRUE, TRUE, 2]];        ascii => {};  --need a translate table	ENDCASE;      Write[" "L];      ENDLOOP;    Write["\n"L];  --and a CR for the next line    END;  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];      new = inactive =>        IF data # NIL THEN {	  CommUtil.FreeBuffers[data.buffer]; zone.FREE[@data]};      ENDCASE;    };  Init: PROCEDURE = {    Exec.AddCommand["SptpTraceTool.~"L, NoOp, NIL, Unload];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: initialBox,      clientTransition: ClientTransition, name: "SptpTraceTool"L,      cmSection: "SptpTraceTool"L];    };      NoOp: Exec.ExecProc = { };    Unload: Exec.ExecProc = {    IF Busy[] THEN {      Exec.OutputProc[h]["Tool is busy. Sorry.\n"L];      RETURN[error] };    Tool.Destroy[wh];    Exec.RemoveCommand[h, "SptpTraceTool.~"L];    Heap.Delete[zone];    Done[] };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [20];    Tool.UnusedLogName[unused: logName, root: "SptpTraceTool.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: zone];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};  MakeForm: FormSW.ClientItemsProcType = {    nItems: CARDINAL = FormItems.LAST.ORD + 1;    mode: ARRAY[0..2) OF FormSW.Enumerated ¬ [      ["capture"L, 0], ["display"L, 1]];    format: ARRAY[0..5) OF FormSW.Enumerated ¬ [      ["octal1"L, 0], ["octal2"L, 1],      ["decimal"L, 2], ["hex"L, 3],      ["ascii"L, 4]];    items ¬ FormSW.AllocateItemDescriptor[nItems, zone];    items[FormItems.start.ORD] ¬ FormSW.CommandItem[      tag: "Start"L, place: [CharPos[1], FormSW.line0], proc: Start, z: zone];    items[FormItems.stop.ORD] ¬ FormSW.CommandItem[      tag: "Stop"L, place: [CharPos[8], FormSW.line0], proc: Stop, z: zone];    items[FormItems.mode.ORD] ¬ FormSW.EnumeratedItem[      tag: "=>"L, place: [CharPos[15], FormSW.line0], feedback: all,      choices: DESCRIPTOR[mode], value: @data.mode, z: zone];    items[FormItems.format.ORD] ¬ FormSW.EnumeratedItem[      tag: "format"L, place: [CharPos[39], FormSW.line0],      choices: DESCRIPTOR[format], value: @data.format, z: zone];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
-- File: TeledebugFilter.mesa - last edit:-- AOF                  3-Nov-87 10:23:06-- SMA                  2-Dec-85 17:56:15-- Copyright (C) 1983, 1984, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Buffer USING [Buffer, BufferObject],  BufferDisplay USING [AppendHeaderPiece, Format],  Flipper USING [    ClearCounts, Create, Disable, Enable, Enumerated, EnumeratedDescriptor],  Format USING [HostNumber, NetworkNumber, StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, line0, line1,    NotifyProcType],  MataHariInternal USING [z],  NSTypes USING [BufferBody],  Process USING [Pause, priorityNormal, SecondsToTicks],  Router USING [AssignAddress],  Runtime USING [GetBcdTime],  SpecialSpy USING [    DisplayProc, Mode, SetNSSpyTrigger, SetStateChangeProcs, StartProc,    TriggerProc],  String USING [AppendChar, AppendString],  System USING [NetworkAddress],  TeledebugProtocol USING [    CoreStoreReqHandle, CoreStoreAckHandle, CoreFetchReqHandle,    CoreFetchAckHandle, DiskStoreReqHandle, DiskStoreAckHandle,    DiskFetchReqHandle, DiskFetchAckHandle, Handle, PageFlags, TeledebugBuffer],  Time USING [Append, Unpack],  Tool USING [Create, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  Version USING [Append],  VMMapLog USING [Entry],  Window USING [Handle];TeledebugFilter: PROGRAM  IMPORTS    BufferDisplay, Flipper, Format, FormSW, Process, Router, Runtime,    SpecialSpy, String, Time, Tool, Version, MataHariInternal =  BEGIN  flipperCnt: CARDINAL = 1;  pktFlp: LONG CARDINAL ¬ 0;  flipItems: Flipper.EnumeratedDescriptor ¬ DESCRIPTOR[flipItemsArray];  flipItemsArray: ARRAY [0..flipperCnt) OF Flipper.Enumerated ¬ [    ["packets"L, @pktFlp]];  -- TYPES  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    formSW(0): Window.Handle ¬ NIL,    flipperSW(2): Window.Handle ¬ NIL,    debugFields(4): BOOLEAN ¬ TRUE,    data(5): BOOLEAN ¬ TRUE,    flippers(6): BOOLEAN ¬ TRUE];  -- VARIABLES and CONSTANTS  globalLine: LONG STRING ¬ NIL;  tool: DataHandle ¬ NIL;  displayWidth: CARDINAL = 250;  -- minimum length of display line.  displayFormat: BufferDisplay.Format;  -- From the SetNSSpyTrigger call.  data: BOOLEAN ¬ FALSE;  -- snapshot of the tool parameter.  debugFields: BOOLEAN ¬ FALSE;  -- snapshot of the tool parameter.  wh: Window.Handle;  -- our window.  -- PROCEDURES  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        IF tool = NIL THEN tool ¬ MataHariInternal.z.NEW[Data ¬ []];        SpecialSpy.SetStateChangeProcs[Start, Stop];        END;      new = inactive =>        BEGIN        SpecialSpy.SetStateChangeProcs[NIL, NIL];        Stop[];        IF tool # NIL THEN MataHariInternal.z.FREE[@tool];        END;      ENDCASE;    END;  -- ClientTransition  DisplayDebugPkt: PROC [b: Buffer.Buffer, line: LONG STRING]    RETURNS [LONG POINTER] =    -- Displays a teledebug packet, returns a pointer to the data portion.    BEGIN    dp: LONG POINTER ¬ NIL;  -- The pointer to the data.    np: LONG POINTER TO NSTypes.BufferBody ¬ LOOPHOLE[b.linkLayer.blockPointer];    tb: LONG POINTER TO TeledebugProtocol.TeledebugBuffer ¬      LOOPHOLE[@np.exchangeWords];    h: TeledebugProtocol.Handle ¬ LOOPHOLE[@np.exchangeWords[0]];    spare: [0..1) ¬ tb.spare;    String.AppendString[line, "  teledebug[type: "L];    SELECT tb.type FROM      mayday => String.AppendString[line, "mayday"L];      ack => String.AppendString[line, "ack"L];      nak => String.AppendString[line, "nak"L];      coreStore => String.AppendString[line, "coreStore"L];      coreFetch => String.AppendString[line, "coreFetch"L];      diskStore => String.AppendString[line, "diskStore"L];      diskFetch => String.AppendString[line, "diskFetch"L];      go => String.AppendString[line, "go"L];      goReply => String.AppendString[line, "goReply"L];      remoteDestruct => String.AppendString[line, "remoteDestruct"L];      remoteDestructReply => String.AppendString[line, "remoteDestructReply"L];      ENDCASE => {        String.AppendString[line, "??? ("L];        BufferDisplay.AppendHeaderPiece[displayFormat, @tb.type, 1, line];        String.AppendString[line, ")"]};    String.AppendString[line, ", spare: "L];    BufferDisplay.AppendHeaderPiece[displayFormat, @spare, 1, line];    WITH h SELECT FROM      null => NULL;      coreStoreReq => {        p: TeledebugProtocol.CoreStoreReqHandle ¬ LOOPHOLE[h];        String.AppendString[line, ", (coreStoreReq), page: "L];        BufferDisplay.AppendHeaderPiece[displayFormat, @p.page, 2, line];        ShowFlags[p.flags, line];        dp ¬ @p.data};      coreStoreAck => {        p: TeledebugProtocol.CoreStoreAckHandle ¬ LOOPHOLE[h];        String.AppendString[line, ", (coreStoreAck), page: "L];        BufferDisplay.AppendHeaderPiece[displayFormat, @p.page, 2, line];        ShowFlags[p.flags, line];        dp ¬ NIL};      coreFetchReq => {        p: TeledebugProtocol.CoreFetchReqHandle ¬ LOOPHOLE[h];        String.AppendString[line, ", (coreFetchReq), page: "L];        BufferDisplay.AppendHeaderPiece[displayFormat, @p.page, 2, line];        dp ¬ NIL};      coreFetchAck => {        p: TeledebugProtocol.CoreFetchAckHandle ¬ LOOPHOLE[h];        String.AppendString[line, ", (coreFetchAck), page: "L];        BufferDisplay.AppendHeaderPiece[displayFormat, @p.page, 2, line];        dp ¬ NIL};      diskStoreReq => {        p: TeledebugProtocol.DiskStoreReqHandle ¬ LOOPHOLE[h];        String.AppendString[line, ", (diskStoreReq), page: "L];        BufferDisplay.AppendHeaderPiece[displayFormat, @p.page, 2, line];        ShowMapLogEntry[@p.entry, line];        dp ¬ @p.data};      diskStoreAck => {        p: TeledebugProtocol.DiskStoreAckHandle ¬ LOOPHOLE[h];        String.AppendString[line, ", (diskStoreAck), page: "L];        BufferDisplay.AppendHeaderPiece[displayFormat, @p.page, 2, line];        ShowMapLogEntry[@p.entry, line];        dp ¬ NIL};      diskFetchReq => {        p: TeledebugProtocol.DiskFetchReqHandle ¬ LOOPHOLE[h];        String.AppendString[line, ", (diskFetchReq), page: "L];        BufferDisplay.AppendHeaderPiece[displayFormat, @p.page, 2, line];        ShowMapLogEntry[@p.entry, line];        dp ¬ NIL};      diskFetchAck => {        p: TeledebugProtocol.DiskFetchAckHandle ¬ LOOPHOLE[h];        String.AppendString[line, ", (diskFetchAck), page: "L];        BufferDisplay.AppendHeaderPiece[displayFormat, @p.page, 2, line];        ShowMapLogEntry[@p.entry, line];        dp ¬ @p.data};      ENDCASE;    String.AppendString[line, "]"L];    IF debugFields THEN SpecialSpy.DisplayProc[line];    line.length ¬ 0;    RETURN[dp];    END;  -- DisplayDebugPkt  DSpy: SpecialSpy.TriggerProc =    BEGIN  -- The filtering procedure that gets called by the NSSpyTool just    -- before NSSpy returns the buffer to the dispatcher.    np: LONG POINTER TO NSTypes.BufferBody ¬ LOOPHOLE[b.linkLayer.blockPointer];    newDataPtr ¬ oldDataPtr;    save ¬ FALSE;    -- test for possible teledebug pkt.    IF (np.packetType = packetExchange) AND (np.exchangeType = teledebug) THEN      SELECT mode FROM        display => {          IF debugFields THEN	    newDataPtr.blockPointer ¬ DisplayDebugPkt[b, globalLine];          IF ~data THEN newDataPtr.blockPointer ¬ NIL};        collect => {pktFlp ¬ pktFlp + 1; save ¬ TRUE};        ENDCASE;    END;  -- DSpy  Init: PROCEDURE =    BEGIN    lnA: System.NetworkAddress ¬ Router.AssignAddress[];    stringProc: Format.StringProc = {String.AppendString[name, s]};    name: STRING ¬ [120];    String.AppendString[name, "TeledebugFilter "L];    Version.Append[name];    String.AppendString[name, " of "L];    Time.Append[name, Time.Unpack[Runtime.GetBcdTime[]]];    String.AppendString[name, " running on "L];    Format.NetworkNumber[stringProc, lnA.net, octal];    String.AppendChar[name, '.];    Format.HostNumber[stringProc, lnA.host, octal];    String.AppendChar[name, '.];    tool ¬ MataHariInternal.z.NEW[Data ¬ []];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: active,      initialBox: [place: [x: 800, y: 500], dims: [w: 300, h: 200]],      clientTransition: ClientTransition, name: name,      cmSection: "TeledebugFilter"L, tinyName1: "Teledebug"L,      tinyName2: "Filter"L];    END;  -- Init  MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    j: CARDINAL;    nItems: CARDINAL = 3;    items ¬ AllocateItemDescriptor[nItems];    items[j ¬ 0] ¬ BooleanItem[      tag: "Debug header fields"L, place: [0, line0], switch: @tool.debugFields];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Data"L, place: [120, line0], switch: @tool.data];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Flippers"L, place: [0, line1], switch: @tool.flippers,      proc: ToggleFlippers];    IF (j + 1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;  -- MakeForm  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "TeledebugSpy.log"L];    tool.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    tool.flipperSW ¬ Flipper.Create[      parent: window, flippers: flipItems, priority: Process.priorityNormal,      position: leftJustified];    END;  ShowFlags: PROC [flags: TeledebugProtocol.PageFlags, line: LONG STRING] =    BEGIN    String.AppendString[line, ", flags: "L];    SELECT flags FROM      clean => String.AppendString[line, "clean"L];      referenced => String.AppendString[line, "referenced"L];      dirty => String.AppendString[line, "dirty"L];      dirtyReferenced => String.AppendString[line, "dirtyReferenced"L];      writeProtected => String.AppendString[line, "writeProtected"L];      writeProtectedReferenced =>        String.AppendString[line, "writeProtectedReferenced"L];      vacant => String.AppendString[line, "vacant"L];      illegal => String.AppendString[line, "illegal"L];      ENDCASE => {        String.AppendString[line, "??? ("L];        BufferDisplay.AppendHeaderPiece[displayFormat, @flags, 1, line];        String.AppendString[line, ")"L]};    END;  -- ShowFlags  ShowMapLogEntry: PROC [e: LONG POINTER TO VMMapLog.Entry, line: LONG STRING] =    BEGIN    String.AppendString[line, ", entry: "L];    BufferDisplay.AppendHeaderPiece[displayFormat, e, 7, line];    END;  -- ShowMapLogEntry  Start: SpecialSpy.StartProc =    BEGIN    displayFormat ¬ format;    Flipper.ClearCounts[tool.flipperSW];    debugFields ¬ tool.debugFields;    data ¬ tool.data;    globalLine ¬ MataHariInternal.z.NEW[      StringBody [displayWidth] ¬ [length: 0, maxlength: displayWidth, text:]];    [] ¬ SpecialSpy.SetNSSpyTrigger[DSpy, wh];    END;  -- Start  Stop: PROC =    BEGIN    [] ¬ SpecialSpy.SetNSSpyTrigger[NIL, wh];  -- unhook it.    Process.Pause[Process.SecondsToTicks[1]];  -- Give display a chance to finish.    -- Clean house.    MataHariInternal.z.FREE[@globalLine];    END;  -- Stop  ToggleFlippers: FormSW.NotifyProcType =    BEGIN    IF tool.flippers THEN Flipper.Enable[tool.flipperSW]    ELSE Flipper.Disable[tool.flipperSW];    END;  -- ToggleFlippers  -- Mainline code  Init[];  END.
-- File: EtherGraphImpl.mesa - last edit:-- AOF                 22-May-88 13:45:04-- Copyright (C) 1984, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  Buffer USING [    Buffer, MakePool, DestroyPool, AccessHandle, ReturnBuffer, Type],  CommUtil,  DataLinkControl USING [AdjustInputQueueLength],  Driver USING [Device, GetDeviceChain],  Display USING [Black, White],  Environment USING [bitsPerByte, bytesPerWord],  IEEE8023 USING [Encapsulation, EthernetCRC],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, EnumeratedItem,    Enumerated, EnumeratedNotifyProcType, newLine, ProcType, StringItem,    DisplayItem],  Exec USING [AddCommand, ExecProc, RemoveCommand],  Heap USING [systemZone],  HostNumbers USING [IsMulticastID],  Inline USING [LongDiv, LongMult, LowHalf],  Process USING [    Abort, EnableAborts, SetTimeout, SecondsToTicks, priorityBackground,    SetPriority],  Protocol1 USING [SetMaximumBufferSize],  Router USING [FindMyHostID],  Runtime USING [GetBcdTime, ZeroDivisor],  SpecialCommunication USING [    SetSpyProc, SpyProc, SetEthernetCollectGarbageToo, SetEthernetListener,    SpyType],  SpecialSystem USING [HostNumber],  String USING [AppendString],  System USING [    broadcastHostNumber, GetClockPulses, MicrosecondsToPulses],  Time USING [Append, AppendCurrent, Unpack],  Tool USING [AddThisSW, Create, Destroy, MakeFormSW, MakeSWsProc],  ToolWindow USING [CreateSubwindow, DisplayProcType, TransitionProcType],  UserTerminal USING [],  -- Needed by Tool.Create  Window USING [Handle];EtherGraphImpl: MONITOR  IMPORTS    Buffer, CommUtil, Display, Driver, DataLinkControl, Exec,    FormSW, Heap, HostNumbers, Inline, Process, Protocol1, Router,    Runtime, SpecialCommunication, String, System, Time,    Tool, ToolWindow  EXPORTS Buffer, System =  BEGIN  HostNumber: PUBLIC TYPE = SpecialSystem.HostNumber;  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  bpb: NATURAL = Environment.bitsPerByte;  bpw: NATURAL = Environment.bytesPerWord;  wh: Window.Handle;  form, graph: Window.Handle ¬ NIL;  oldSpy: ARRAY Buffer.Type OF SpecialCommunication.SpyProc;    updater: PROCESS;  interval: CONDITION;  secondsPerInterval: CARDINAL ¬ 1;  pulsesPerSec: LONG CARDINAL = System.MicrosecondsToPulses[1000000];  pulsesPerInterval: LONG CARDINAL ¬ pulsesPerSec;  bytesPerSecond: LONG CARDINAL = 10D6/LONG[8];  preamble: CARDINAL = 64 / bpb;  --bytes in preamble  crc: CARDINAL = bpw * SIZE[IEEE8023.EthernetCRC];  ipg: CARDINAL = 96 / bpb;  --bytes in 9.6 uSecs  buffers: Buffer.AccessHandle ¬ NIL;  dispatcherBuffers: CARDINAL = 90;  space: LONG POINTER;    periodType: PeriodType ¬ seconds;  PeriodType: TYPE = {seconds, minutes, hours};  deflection: Scales ¬ tenth;  scale: LONG CARDINAL ¬ 10;  Scales: TYPE = MACHINE DEPENDENT {full(1), tenth(10), hundredth(100)};  leftEdgeTime: LONG STRING ¬ NIL;    me: HostNumber = Router.FindMyHostID[];  all: HostNumber = System.broadcastHostNumber;  BytesSeen: TYPE = LONG CARDINAL;  bytesSeen: BytesSeen;  unit: CARDINAL = 1;    Range: TYPE = [0..1000);  History: TYPE = PACKED ARRAY Range OF CARDINAL;  history: LONG DESCRIPTOR FOR History;  finger: Range ¬ 0;  margin: CARDINAL = 10;  graphHeight: CARDINAL = 300;  tickHeight: CARDINAL = 2;  tickWidth: CARDINAL = 2;  barHeight: CARDINAL = 2;  barWidth: CARDINAL = LAST[Range]+1;  gridWidth: CARDINAL = LAST[Range]+1;  gridHeight: CARDINAL = 1;  gridSpace: CARDINAL = graphHeight/10;  height: CARDINAL = barHeight+graphHeight+2*margin;  width: CARDINAL = barWidth+2*margin;  bottomOfBar: CARDINAL = height-margin;  topOfBar: CARDINAL = bottomOfBar-barHeight;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ExecCall: Exec.ExecProc = {};  --ExecCall  Unload: Exec.ExecProc =    BEGIN    Tool.Destroy[wh];  --get rid of tool (calls ClientTransition)    Exec.RemoveCommand[h, "EtherGraph.~"L];    END;  --Unload      Initialize: PROCEDURE =    BEGIN    herald: STRING ¬ [60];    Process.SetTimeout[@interval, Process.SecondsToTicks[secondsPerInterval]];    Process.EnableAborts[@interval];    Exec.AddCommand[name: "EtherGraph.~"L, proc: ExecCall, unload: Unload];    String.AppendString[to: herald, from: "Ether Graph of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 8;  -- omit hours, mins, zone.    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: herald,      initialBox: [[x: 0, y: 619 ],[w: 1024, h: graphHeight + 59]]];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    graph ¬ ToolWindow.CreateSubwindow[parent: window, display: DisplayGraph];    Tool.AddThisSW[window: window, sw: graph, swType: vanilla, h: height];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    END;  DisplayGraph: ToolWindow.DisplayProcType =    {DrawGraphPaper[];    FOR i: Range IN Range DO      info: CARDINAL = history[i];      IF info # 0 THEN Display.Black[        graph, [[margin + i, topOfBar - info], [1, info]]];      ENDLOOP};  DrawAnotherLine: PROCEDURE [percent: CARDINAL] =    BEGIN    scale: CARDINAL = Inline.LongDiv[Inline.LongMult[percent, graphHeight], 100];    thumb: Range = (finger + 10) MOD (LAST[Range] + 1);    pinky: Range = (finger - 10) MOD (LAST[Range] + 1);    history[finger] ¬ scale;    IF scale # 0 THEN Display.Black[      graph, [[margin + finger, topOfBar - scale], [1, scale]]];    IF finger = 0 THEN      BEGIN      finger ¬ 0;      leftEdgeTime.length ¬ 0;      Time.AppendCurrent[leftEdgeTime];      FormSW.DisplayItem[form, 3];      END;    finger ¬ IF finger = LAST[Range] THEN 0 ELSE SUCC[finger];    history[thumb] ¬ 0;  -- clear out a bit of space ahead    Display.White[      graph,[[margin + thumb, topOfBar - graphHeight], [1 ,graphHeight]]];    FOR i: CARDINAL IN(0..graphHeight] DO    --redraw grid behind current graph finger      IF (i MOD gridSpace) # 0 THEN LOOP;      Display.Black[        graph, [[margin + pinky, topOfBar - i], [tickWidth, gridHeight]]];      ENDLOOP;    END;      DrawGraphPaper: PROCEDURE =    BEGIN    i: CARDINAL;    delta: CARDINAL = SELECT periodType FROM      seconds, minutes => 60, ENDCASE => 24;    Display.White[graph, [[0, 0], [width, height]]];    Display.Black[graph, [[margin, topOfBar], [barWidth, barHeight]]];    FOR i IN[0..LAST[Range]) DO  -- minute markers      IF (i MOD delta) # 0 THEN LOOP;      Display.White[graph, [[margin + i, topOfBar], [tickWidth, barHeight]]];      Display.Black[        graph, [[margin + i, topOfBar+barHeight], [tickWidth, tickHeight]]];      ENDLOOP;    FOR i IN(0..graphHeight] DO      IF (i MOD gridSpace) # 0 THEN LOOP;      Display.Black[        graph, [[margin, topOfBar - i], [gridWidth, gridHeight]]];      ENDLOOP;    END;      MakeForm: FormSW.ClientItemsProcType --RETURNS [items, freeDesc]--  =    BEGIN    nItems: CARDINAL = 4;    scales: ARRAY [0..3) OF FormSW.Enumerated ¬ [      ["100%"L, Scales[full]],      ["10%"L, Scales[tenth]],      ["1%"L, Scales[hundredth]]];    periods: ARRAY [0..3) OF FormSW.Enumerated ¬ [      ["seconds"L, PeriodType[seconds]],      ["minutes"L, PeriodType[minutes]],      ["hours"L, PeriodType[hours]]];    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[0] ¬ FormSW.CommandItem[      tag: "Reset"L, proc: Reset, place: FormSW.newLine];    items[1] ¬ FormSW.EnumeratedItem[      tag: "Full deflection is "L, choices: DESCRIPTOR[scales],      value: @deflection, proc: Scale];    items[2] ¬ FormSW.EnumeratedItem[      tag: "Period"L, choices: DESCRIPTOR[periods], value: @periodType,      proc: Period];    items[3] ¬ FormSW.StringItem[      tag: "Time at left edge"L, readOnly: TRUE, string: @leftEdgeTime];    RETURN[items: items, freeDesc: TRUE];    END;    Scale: FormSW.EnumeratedNotifyProcType =    {scale ¬ SELECT deflection FROM full => 1, tenth => 10, ENDCASE => 100};  Period: FormSW.EnumeratedNotifyProcType =    BEGIN    secondsPerInterval ¬ SELECT periodType FROM      seconds => 1, minutes => 60, ENDCASE => 60*60;    pulsesPerInterval ¬ pulsesPerSec * secondsPerInterval;    Process.SetTimeout[@interval, Process.SecondsToTicks[secondsPerInterval]];    Reset[];    END;    Reset: FormSW.ProcType =    BEGIN    FOR i: Range IN Range DO history[i] ¬ 0; ENDLOOP;    finger ¬ 0; DrawGraphPaper[];    END;      ClientTransition: ToolWindow.TransitionProcType =    BEGIN    Area: TYPE = RECORD[history: History, bytesSeen: BytesSeen];    SELECT TRUE FROM      (old = inactive) =>        BEGIN	space ¬ CommUtil.AllocateBuffers[bpw * SIZE[Area]];	history ¬ DESCRIPTOR[NARROW[space, LONG POINTER TO Area].history];	FOR i: Range IN Range DO history[i] ¬ 0; ENDLOOP;	bytesSeen ¬ 0; finger ¬ 0;	leftEdgeTime ¬ Heap.systemZone.NEW[StringBody[20] ¬	  [length: 0, maxlength: 20, text: ]];	Time.AppendCurrent[leftEdgeTime];	updater ¬ FORK Updater[];	buffers ¬ Buffer.MakePool[dispatcherBuffers, 0];  --get large pool	[] ¬ DataLinkControl.AdjustInputQueueLength[  --ajust input queue	  ethernet, 0, dispatcherBuffers / 2];	FOR device: Device ¬ Driver.GetDeviceChain[], device.next	  UNTIL device = NIL DO	  IF device.device = ethernet THEN	    Protocol1.SetMaximumBufferSize[device, NIL, 1500];	  ENDLOOP;	[] ¬ SpecialCommunication.SetEthernetListener[unit, all];	[] ¬ SpecialCommunication.SetEthernetCollectGarbageToo[unit, TRUE];	FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	  oldSpy[type] ¬ SpecialCommunication.SetSpyProc[SpyProc, type];	  ENDLOOP;	END;      (new = inactive) =>        BEGIN        [] ¬ SpecialCommunication.SetEthernetListener[unit, me];	[] ¬ SpecialCommunication.SetEthernetCollectGarbageToo[unit, FALSE];	FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	  [] ¬ SpecialCommunication.SetSpyProc[NIL, type];  --wipe out spy	  ENDLOOP;	[] ¬ DataLinkControl.AdjustInputQueueLength[ethernet, 0, 5];	FOR device: Device ¬ Driver.GetDeviceChain[], device.next	  UNTIL device = NIL DO	  IF device.device = ethernet THEN	    BEGIN	    Protocol1.SetMaximumBufferSize[device, NIL, 0];	    END;	  ENDLOOP;        Buffer.DestroyPool[buffers];  --give pool back	Process.Abort[updater]; JOIN updater;	form ¬ graph ¬ NIL;	CommUtil.FreeBuffers[space];	Heap.systemZone.FREE[@leftEdgeTime];	END;      ENDCASE;    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Worker routines:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Updater: ENTRY PROC =    BEGIN        percent: LONG CARDINAL;  -- percentage of bandwidth used    fudge: LONG CARDINAL;  --fraction of interval actually elapsed X 100    total: LONG CARDINAL;  --number of bytes observed in interval    awps: LONG CARDINAL;  --adjusted bytes/seconds assuming 100% net utilization    awpi: LONG CARDINAL;  --adjusted bytes/interval if interval not seconds    start: LONG CARDINAL;  --time when interval started in pulses    stop: LONG CARDINAL;  --time when interval stopped in pulses    elapsed: LONG CARDINAL;  --length of interval in pulses    start ¬ System.GetClockPulses[];    Process.SetPriority[Process.priorityBackground];    DO      ENABLE {ABORTED => EXIT; Runtime.ZeroDivisor => CONTINUE};      WAIT interval;      stop ¬ System.GetClockPulses[];      elapsed ¬ stop - start;      start ¬ stop;      SELECT TRUE FROM        (graph = NIL) => NULL;	((total ¬ bytesSeen) = 0) => DrawAnotherLine[0];	ENDCASE =>	  BEGIN	  bytesSeen ¬ 0;  --clear counter          fudge ¬ elapsed*LONG[100] / pulsesPerInterval;  --amount to adjust * 100          awps ¬ (bytesPerSecond * fudge) / 100;  --adjusted bytes/second	  awpi ¬ awps * secondsPerInterval;  --adjusted bytes/interval	  percent ¬ ((total*scale*LONG[100]) / awpi);	  DrawAnotherLine[MIN[Inline.LowHalf[percent], 100]];	  END;      ENDLOOP;    END;    SpyProc: --ENTRY-- SpecialCommunication.SpyProc =    --PROC[b: Buffer.Buffer, function: Buffer.Function] RETURNS [Buffer.Buffer];    BEGIN    dest: HostNumber;    IF oldSpy[b.fo.type] # NIL THEN      {b ¬ oldSpy[b.fo.type][b, function]; IF b = NIL THEN RETURN[b]};    bytesSeen ¬ bytesSeen + b.fo.driver.length + preamble + crc + ipg;    dest ¬ LOOPHOLE[      b.linkLayer.blockPointer, IEEE8023.Encapsulation].ethernetDest;    SELECT TRUE FROM      (function = send) => RETURN[b];  --these always proceed      (b.fo.status # goodCompletion) => {Buffer.ReturnBuffer[b]; RETURN[NIL]};      (dest = me) => RETURN[b];  --it was sent to me      (HostNumbers.IsMulticastID[@dest]) => RETURN[b];  --multicast id      ENDCASE => {Buffer.ReturnBuffer[b]; RETURN[NIL]};  --not me, not *    END;      -- Mainline code:  Initialize[];  END.  LOG15-Aug-84 15:57:16  By: AOF: Post Klamath.28-Jun-87 13:41:34  By: AOF: EtherMAC => IEEE8023. 
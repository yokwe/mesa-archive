-- File: Flippers.mesa - last edit:-- AOF                  2-Feb-87 18:19:48-- Copyright (C) 1983, 1984 , 1987 by Xerox Corporation. All rights reserved. --Flippers.mesa - (last editted by AOF  2-Dec-83 11:14:40)--Implementation of flippers (known internally as paddles)  DIRECTORY  Context USING [Create, Data, Find, Type, UniqueType],  Display USING [Bitmap, Handle, replaceFlags, TextInline],  Flipper USING [    CountState, Disabled, Enabled, EnumeratedDescriptor, FlipperState, Position],  Heap USING[systemZone],  Process USING [    Abort, DisableTimeout, EnableAborts, GetPriority, InitializeCondition,    Priority, priorityBackground, SetPriority, SetTimeout],  String USING[AppendLongDecimal, AppendString],  Tool USING[AddThisSW],  ToolWindow USING [CreateSubwindow, DisplayProcType, WindowForSubwindow],  Window USING[Box, GetBox],  WindowFont USING[FontHeight, CharWidth];Flippers: MONITOR  IMPORTS    Context, Display, Heap, Tool, WindowFont, Window, Process, String, ToolWindow  EXPORTS Flipper =  BEGIN  PaddleData: TYPE = LONG POINTER TO PaddleObject ¬ NIL;  PaddleObject: TYPE = RECORD[    sw: Display.Handle, process: PROCESS ¬ NIL, condition: CONDITION,    pState: Flipper.FlipperState, cState: Flipper.CountState,    paddles: SEQUENCE length: CARDINAL OF Paddles];  Paddles: TYPE = RECORD[    box: Window.Box,    tag: LONG STRING,    observed: LONG CARDINAL,    pattern: Flipper.FlipperState,    actual: LONG POINTER TO LONG CARDINAL,    fillTo16: ARRAY CARDINAL[0..5) OF WORD ¬ NULL];  sizeTrap: CARDINAL[16..16] = SIZE[Paddles];  --keep it there       left: WORD = 177400B;  right: WORD = 000377B;  whiteSpace: CARDINAL = 5;  lineHeight: CARDINAL ¬ WindowFont.FontHeight[];  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  elementWidth: INTEGER = 14*charWidth;  blanks: LONG STRING = "              ";  dataType: Context.Type = Context.UniqueType[];  zone: UNCOUNTED ZONE = Heap.systemZone;  GetData: PROC [w: Display.Handle] RETURNS [PaddleData] = {    RETURN Context.Find [dataType, w]};  GetDataSW: PROC [sw: Display.Handle] RETURNS [PaddleData] = {    RETURN Context.Find [dataType, ToolWindow.WindowForSubwindow [sw]]};    Create: PUBLIC PROC[    parent: Display.Handle,    flippers: Flipper.EnumeratedDescriptor, state: Flipper.Enabled ¬ [],    priority: Process.Priority ¬ Process.priorityBackground,    position: Flipper.Position ¬ centered, nextSW: Display.Handle ¬ NIL]    RETURNS[sw: Display.Handle] =    BEGIN    y: CARDINAL ¬ whiteSpace;    row: CARDINAL ¬ 0;    j: INTEGER ¬ 0;  -- j is the flipper index relative to the current row.    parentBox: Window.Box ¬ Window.GetBox[parent];    cPrio: Process.Priority = Process.GetPriority[];    paddleData: PaddleData ¬ zone.NEW[PaddleObject[LENGTH[flippers]]];    leftMargin: INTEGER ¬ (parentBox.dims.w - (elementWidth*LENGTH[flippers]))/2;    rightMargin: INTEGER ¬ parentBox.dims.w - elementWidth/4;    IF (leftMargin < 0) OR (position = leftJustified) THEN      leftMargin ¬ elementWidth/4;     FOR i: CARDINAL IN[0..LENGTH[flippers]) DO      -- check if room for one more flipper on current row.      IF leftMargin + j*elementWidth > rightMargin THEN        BEGIN	j ¬ 0;        row ¬ row+1;	y ¬ (4*whiteSpace + lineHeight*3)*row + whiteSpace;	END;      paddleData[i] ¬ [        tag: NIL, actual: flippers[i].count, observed: 0, pattern: state.flippers,	box: [[leftMargin + j*elementWidth, y], [16, 16]]];      IF flippers[i].tag # NIL THEN        BEGIN	paddleData[i].tag ¬ zone.NEW[StringBody[flippers[i].tag.length]];	String.AppendString[paddleData[i].tag, flippers[i].tag];	END;      j ¬ j+1;      ENDLOOP;    paddleData.sw ¬ sw ¬ ToolWindow.CreateSubwindow[      parent: parent, display: DisplayBoxes];    Process.InitializeCondition[@paddleData.condition, 1];    Process.EnableAborts[@paddleData.condition];    paddleData.pState ¬ state.flippers;    paddleData.cState ¬ state.count;    Context.Create[dataType, paddleData, FreePaddleData, sw];    Tool.AddThisSW[      window: parent, sw: sw, swType: vanilla, nextSW: nextSW,      h: (lineHeight*3 + whiteSpace*4)*(row+1)+whiteSpace];    Process.SetPriority[priority];    paddleData.process ¬ FORK PaddleProcess[sw, paddleData];    Process.SetPriority[cPrio];    END;    Enable: PUBLIC PROC[sw: Display.Handle, newState: Flipper.Enabled ¬ []] =    {ChangeState[sw, newState.flippers, newState.count]};  Disable: PUBLIC PROC[sw: Display.Handle, newState: Flipper.Disabled ¬ []] =    {ChangeState[sw, newState.flippers, newState.count]};  ChangeState: ENTRY PROC[    sw: Display.Handle,    fState: Flipper.FlipperState,    cState: Flipper.CountState] =    BEGIN    paddleData: PaddleData ¬ GetData[sw];    SELECT TRUE FROM      (fState = off) AND (cState = off) =>        Process.DisableTimeout[@paddleData.condition];      (paddleData.pState = off) AND (paddleData.cState = off) =>	Process.SetTimeout[@paddleData.condition, 1];      ENDCASE;    paddleData.pState ¬ fState; paddleData.cState ¬ cState;    FOR which: CARDINAL IN[0..paddleData.length) DO      paddleData[which].pattern ¬ fState; ENDLOOP;    NOTIFY paddleData.condition;    END;    FreePaddleData: PROCEDURE [data: Context.Data, sw: Display.Handle] =    BEGIN    paddleData: PaddleData = LOOPHOLE[data];    Process.Abort[paddleData.process];    JOIN paddleData.process;    FOR i: CARDINAL IN[0..paddleData.length) DO      IF paddleData[i].tag # NIL THEN zone.FREE[@paddleData[i].tag]; ENDLOOP;    zone.FREE[@data];    END;     PaddleProcess: ENTRY PROC[sw: Display.Handle, paddleData: PaddleData] =    BEGIN    DO  --UNTIL ABORTED      ENABLE ABORTED => EXIT;      WAIT paddleData.condition;  --may be aborted|disabled      FOR i: CARDINAL IN[0..paddleData.length) DO        SELECT TRUE FROM	  (paddleData[i].actual = NIL) => NULL;	  (paddleData[i].actual­ = paddleData[i].observed) => NULL;	  (paddleData[i].actual­ < paddleData[i].observed) =>	    BEGIN	    ClearCountInternal[i, sw, paddleData];	    paddleData[i].observed ¬ paddleData[i].actual­;	    UpdateCount[paddleData[i].observed, i, sw, paddleData];	    END;          ENDCASE =>	    BEGIN	    paddleData[i].observed ¬ paddleData[i].actual­;	    UpdateCount[paddleData[i].observed, i, sw, paddleData];	    END;        ENDLOOP;      ENDLOOP;    END;  ClearCountInternal: PROC[     which: CARDINAL, sw: Display.Handle, paddleData: PaddleData] =    BEGIN    center, yaxis, width: CARDINAL;    width ¬ blanks.length*charWidth/2;      center ¬ paddleData[which].box.place.x + 8;      yaxis ¬ paddleData[which].box.place.y + 16 + lineHeight + 2*whiteSpace;      [] ¬ Display.TextInline[window: sw, string: blanks,        place: [center - width, yaxis], flags: Display.replaceFlags];    DisplayBoxes[sw];  --to get zero, not spaces, for the counts    END;  ClearCounts: PUBLIC PROC[sw: Display.Handle] =    BEGIN    paddleData: PaddleData ¬ GetData[sw];    FOR which: CARDINAL IN[0..paddleData.length) DO      IF paddleData[which].actual = NIL THEN LOOP;      paddleData[which].actual­ ¬ paddleData[which].observed ¬ 0;      ClearCountInternal[which, sw, paddleData];      ENDLOOP;    END;  DisplayBoxes: ToolWindow.DisplayProcType =    BEGIN    pattern: ARRAY[0..1] OF ARRAY[0..8) OF WORD;    numberString: STRING = [20];    paddleData: PaddleData ¬ GetData[window];    FOR which: CARDINAL IN[0..paddleData.length) DO      number: LONG CARDINAL;      tag: LONG STRING ¬ paddleData[which].tag;      center: CARDINAL = paddleData[which].box.place.x + 8;      tagY: CARDINAL = paddleData[which].box.place.y + whiteSpace + 16;      numberY: CARDINAL = tagY + lineHeight + whiteSpace;      IF paddleData[which].actual = NIL THEN LOOP      ELSE number ¬ paddleData[which].actual­;      SELECT paddleData[which].pattern FROM        left => pattern ¬ [ALL[left], ALL[right]];        right => pattern ¬ [ALL[right], ALL[left]];        off => pattern ¬ [ALL[0], ALL[0]];        ENDCASE;      Display.Bitmap[        window: window, box: paddleData[which].box, address: [@pattern, 0, 0],	bitmapBitWidth: 16, flags: Display.replaceFlags];      IF tag # NIL THEN [] ¬ Display.TextInline[window: window,       string: tag, place: [center - tag.length*charWidth/2, tagY],       flags: Display.replaceFlags];      numberString.length ¬ 0; String.AppendLongDecimal[numberString, number];      [] ¬ Display.TextInline[window: window, string: numberString,        place: [center - numberString.length*charWidth/2, numberY],	flags: Display.replaceFlags];      ENDLOOP;    END;  UpdateCount: PROC[    value: LONG CARDINAL, which: CARDINAL,    sw: Display.Handle, paddleData: PaddleData] =    BEGIN    string: STRING =[20];    center, numberY: CARDINAL;    pattern: ARRAY[0..1] OF ARRAY[0..8) OF WORD;    IF paddleData.pState # off THEN      BEGIN      IF paddleData[which].pattern = left THEN	{pattern ¬ [ALL[left], ALL[right]];	paddleData[which].pattern ¬ right}      ELSE	{pattern ¬ [ALL[right], ALL[left]];	paddleData[which].pattern ¬ left};      Display.Bitmap[        sw, paddleData[which].box, [@pattern, 0, 0], 16, Display.replaceFlags];      END;    IF paddleData.cState # off THEN      BEGIN      center ¬ paddleData[which].box.place.x + 8;      numberY ¬ paddleData[which].box.place.y + lineHeight + 2*whiteSpace + 16;      IF value = LAST[LONG CARDINAL] THEN RETURN;      String.AppendLongDecimal[string, value];      [] ¬ Display.TextInline[window: sw, string: string,        place: [center - string.length*charWidth/2, numberY],	flags: Display.replaceFlags];      END;    END;  END...  
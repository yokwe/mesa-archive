-- File: XferServer.mesa - last edit:-- AOF                 23-Oct-87  8:37:47-- Create by FormSWLayoutTool on  3-Oct-86 19:28-- Copyright (C) 1986, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Buffer USING [Device],  Courier USING [    Arguments, Dispatcher, Error, ExportRemoteProgram, Free, Handle,    InvalidArguments, NoSuchProcedureNumber, Results, SignalRemoteError,    UnexportRemoteProgram],  CourierInternal,  Driver USING [Device, nilDevice],  Environment USING [    Block, Byte, bytesPerPage, bytesPerWord, nullBlock, wordsPerPage],  Format USING [LongDecimal, StringProc, Decimal, NetworkAddress],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, line0, ProcType],  MFile USING [Acquire, Delete, Handle, SetAccess, SetProperties],  MStream USING [GetFile, Handle, Create],  NetworkStream USING [closeReplySST, closeSST, WaitTime],  NSBuffer USING [Body, Buffer],  NSTypes USING [    Byte, bytesPerExchangeHeader, bytesPerIDPHeader, bytesPerSppHeader,    maxIDPBytesPerPacket],  PacketExchange USING [    CreateReplier, ExchangeClientType, ExchangeHandle, RequestHandle,    SendReply, WaitForRequest, WaitTime],  PacketStream USING [    ConnectionFailed, ConnectionSuspended, Handle, Make, unknownConnID],  Process USING [Detach, DisableTimeout, priorityNormal, SetPriority],  Protocol1 USING [GetFamilyUnit, SetMaximumBufferSize],  Put USING [Text],  Router USING [AssignAddress],  SppOps USING [    DisableChecksums, SetWindow, sppWindowSize, PacketStreamFromByteStream],  Stream USING [Block, Handle, Position, SubSequenceType],  System USING [    GetClockPulses, GetGreenwichMeanTime, NetworkAddress, nullNetworkAddress,    PulsesToMicroseconds],  Tool USING [Create, MakeFileSW, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Box, Handle],  WindowFont USING [CharWidth],  XferProtocol USING [    ClosePacketStream, CommitArguments, CommitResults, CommitStatus,    DescribeCommitArguments, DescribeCommitResults, DescribeStoreArguments,    DescribeStoreResults, Error, Procedure, program, StoreArguments,    StoreResults, versionHigh, versionLow, DevNull, DeviceType],  XStream;XferServer: MONITOR  IMPORTS    Courier, Format, FormSW, MFile, MStream, PacketExchange,    PacketStream, Process, Protocol1, Put, Router, SppOps, System, Tool,    WindowFont, XferProtocol, XStream  EXPORTS Buffer, XferProtocol = {  Device: PUBLIC <<BUFFER>> TYPE = Driver.Device;  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    fileSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    serverStarted(4): BOOLEAN ¬ FALSE];  FormItems: TYPE = {start, stop};  data: DataHandle ¬ NIL;  zone: UNCOUNTED ZONE ¬ NIL;  box: Window.Box = [place:[x:700, y:0], dims:[w:324, h:128]];  busyBit: BOOLEAN ¬ FALSE;  bpp: NATURAL = Environment.bytesPerPage;  wpp: NATURAL = Environment.wordsPerPage;  bpw: NATURAL = Environment.bytesPerWord;  stateObject: StateObject ¬ [];  --pretty simple  StateHandle: TYPE = LONG POINTER TO StateObject;  StateObject: TYPE = RECORD[    sH: Stream.Handle ¬ NIL,    sink: XferProtocol.DeviceType ¬ NULL,    status: XferProtocol.CommitStatus ¬ idle,    address: System.NetworkAddress ¬ System.nullNetworkAddress];  rendezvous: RECORD[checkout: PROC[h: XStream.Handle], condition: CONDITION];  forceOut: CONDITION;  forceOutProcesses: NATURAL ¬ 0;  ServiceEntry: TYPE =PROC[cH: Courier.Handle,    arguments: Courier.Arguments, results: Courier.Results];  SppSize: PROC[l: NATURAL] RETURNS[CARDINAL] = INLINE    {RETURN[NSTypes.bytesPerIDPHeader + NSTypes.bytesPerSppHeader + l]};  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    ENABLE UNWIND => NULL;    isBusy ¬ busyBit;    busyBit ¬ TRUE };  Done: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    busyBit ¬ FALSE};  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  Start:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Write["\nTool is busy"L];      RETURN};    Process.Detach[FORK StartInternal[]]};  StartInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    Process.SetPriority[Process.priorityNormal];    IF data.serverStarted THEN {Write["\nAlready started"L]; RETURN};    data.serverStarted ¬ TRUE;    Write["\nStarting"L];    Courier.ExportRemoteProgram[      programNumber: XferProtocol.program, zone: zone, classOfService: bulk,      versionRange: [XferProtocol.versionLow, XferProtocol.versionHigh],      dispatcher: XferDispatcher, serviceName: "XferServer 2.0"L !        Courier.Error => {Write["...Already started"L]; CONTINUE}];    Done[] };  Stop:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Write["\nTool is busy"L];      RETURN};    Process.Detach[FORK StopInternal[]]};  StopInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF ~data.serverStarted THEN {Write["\nNot started"L]; RETURN};    data.serverStarted ¬ FALSE;    Write["\nStopping"L];    Courier.UnexportRemoteProgram[      programNumber: XferProtocol.program,      versionRange: [XferProtocol.versionLow, XferProtocol.versionHigh] !        Courier.Error => {Write["...not started"L]; CONTINUE}];    Done[] };  XferDispatcher: Courier.Dispatcher =    BEGIN    ENABLE      BEGIN      ABORTED => {Done[]; CONTINUE};      UNWIND => Done[];      END;    IF Busy[] THEN RETURN WITH ERROR Courier.SignalRemoteError[      XferProtocol.Error[busy].ORD];    SELECT procedureNumber FROM      XferProtocol.Procedure[store].ORD => Store[cH, arguments, results];      XferProtocol.Procedure[commit].ORD => Commit[cH, arguments, results];      XferProtocol.Procedure[xfer].ORD => XferBulk[cH, arguments, results];      ENDCASE => {Done[]; RETURN WITH ERROR Courier.NoSuchProcedureNumber};    Done[];  --and tell him we're done (again)     END;  --XferDispatcher  FindState: PROC[address: System.NetworkAddress] RETURNS[StateHandle]=    BEGIN    RETURN[@stateObject];  --could be a little more clever, but not now...    END;  --FindState  Commit: ServiceEntry =    BEGIN    args: XferProtocol.CommitArguments;    state: StateHandle ¬ FindState[args.address];    rslts: XferProtocol.CommitResults ¬ [state.status];    arguments[[@args, XferProtocol.DescribeCommitArguments]];    SELECT state.status FROM      okay => NULL;      error => args.status ¬ decommit;      busy => Courier.SignalRemoteError[XferProtocol.Error[busy].ORD];      idle => Courier.SignalRemoteError[XferProtocol.Error[nofile].ORD];      ENDCASE => ERROR Courier.InvalidArguments;    SELECT TRUE FROM      (state.sink = devnull) => NULL;  --we didn't scribble the bits out      (args.status = commit) =>        BEGIN	mfH: MFile.Handle = MStream.GetFile[state.sH];	MFile.SetProperties[	  file: mfH, type: args.type, length: args.length,	  write: System.GetGreenwichMeanTime[],	  read: [args.read], create: [args.create]];	END;      (args.status = decommit) =>        BEGIN	mfH: MFile.Handle = MStream.GetFile[state.sH];	MFile.SetAccess[mfH, delete];  --change the access	MFile.Delete[mfH];  --the destroy the file	IF state.status = error THEN	  Courier.SignalRemoteError[XferProtocol.Error[nofile].ORD];	END;      ENDCASE;    state.sH.delete[state.sH];  --and delete the stream?    <<DeleteState[state];>> state.status ¬ idle;    [] ¬ results[[@rslts, XferProtocol.DescribeCommitResults]];    END;  --Confirm  DisplayOptions: PROC[args: LONG POINTER TO XferProtocol.StoreArguments] =    BEGIN    Write["\n  Store arguments: [name: "L]; Write[args.name];    Write[", length: "L]; Format.LongDecimal[Write, args.length];    Write[", transport: [address: "L];    Format.NetworkAddress[Write, args.transport.address, octal];    Write[", source: {"L]; WriteDeviceType[args.transport.source];    Write["}, sink: {"L]; WriteDeviceType[args.transport.sink];    Write["}, type: {"L];    Write[SELECT args.transport.type FROM      packetstream => "packetstream"L, bulkdata => "bulkdata"L,      exchange => "exchange"L, netblt => "netblt"L, message => "message"L,      tt0 => "tt0"L, tt1 => "tt1"L, tt2 => "tt2"L, ENDCASE => "tt3"L];    Write["}, window: "L];  Format.Decimal[Write, args.transport.window];    Write[", frame: "L];    Format.Decimal[Write, args.transport.frame];    Write[", checksums: "L];    Write[IF args.transport.checksums THEN "TRUE"L ELSE "FALSE"L];    Write["]]\n"L];          END;  --DisplayOptions  Store: ServiceEntry =    BEGIN    sH: Stream.Handle;    rslts: XferProtocol.StoreResults;    args: XferProtocol.StoreArguments;    arguments[[@args, XferProtocol.DescribeStoreArguments]];    DisplayOptions[@args];  --log them forever    sH ¬ IF args.transport.sink = devnull THEN      XferProtocol.DevNull[args.transport.frame, args.length, zone]    ELSE MStream.Create[      MFile.Acquire[args.name, writeOnly, [,], TRUE, args.length], [,]];    rslts.address ¬ Router.AssignAddress[];    SELECT args.transport.type FROM      bulkdata => Process.Detach[FORK StoreBulk[args, rslts.address, sH]];      packetstream => Process.Detach[FORK StoreSpp[args, rslts.address, sH]];      exchange => Process.Detach[FORK StoreExchange[args, rslts.address, sH]];      ENDCASE =>        BEGIN	sH.delete[sH];  --gun the file access	RETURN WITH ERROR Courier.InvalidArguments;	END;        [] ¬ results[[@rslts, XferProtocol.DescribeStoreResults]];    END;  --Store  StoreBulk: PROC[    args: XferProtocol.StoreArguments, address: System.NetworkAddress,    sH: Stream.Handle] =    BEGIN    Notify: ENTRY PROC = INLINE      {FindState[address].status ¬ okay; NOTIFY rendezvous.condition};    Wait: ENTRY PROC = INLINE {      WHILE FindState[address].status = busy        DO WAIT rendezvous.condition; ENDLOOP};    PacketFromBulk: PROC[sH: Stream.Handle] RETURNS[PacketStream.Handle] =      BEGIN      sH ¬ @LOOPHOLE[        sH, CourierInternal.AugmentedStream].back.transFilter.object;      sH ¬ LOOPHOLE[@LOOPHOLE[sH, CourierInternal.AugmentedStream].context,	LONG POINTER TO Stream.Handle]­;  --retch!!!! (copied from CourierImplN)      RETURN[SppOps.PacketStreamFromByteStream[sH]];  --more loop-de-loops      END;  --PacketFromBulk    Checkout: PROC[h: XStream.Handle] =      BEGIN      time: LONG CARDINAL;      source: Stream.Handle = XStream.Create[h];      sink: Stream.Handle ¬ FindState[address].sH;      psH: PacketStream.Handle = PacketFromBulk[source];      Write["connection arrived ... "L];      psH.setSenderSizeLimit[  --make it a different size	args.transport.frame -  --that reflects the frame size selected	NSTypes.bytesPerIDPHeader -  --but allows that we're using SPP	NSTypes.bytesPerSppHeader];  --and doesn't dribble off the end      time ¬ System.GetClockPulses[];  --start the clock now      XStream.Copy[source: source, sink: sink];  --let him do it      time ¬ System.GetClockPulses[] - time;  --compute elapsed time      source.delete[source];  --delete stream      DisplayTime[time, args.length];  --display xfer time      Notify[];  --record result      END;  --Checkout    window: CARDINAL = SppOps.sppWindowSize;  --save old value;    stateObject ¬ [sH, args.transport.sink, busy, address];    --The RPC coming in with transfer will rendezvous with us.    rendezvous.checkout ¬ Checkout;  --that's what he needs    Write["\nWaiting for "L];    Write[args.name]; Write[" ... "L];    Protocol1.SetMaximumBufferSize[      Driver.nilDevice, Protocol1.GetFamilyUnit[ns], args.transport.frame];    SppOps.SetWindow[PRED[args.transport.window]];  --reset for test    Write["waiting for 'bulk data' connection ... "L];    Wait[];  --wait for it to happen    SppOps.SetWindow[window];  --reset to value when we came in    Protocol1.SetMaximumBufferSize[      Driver.nilDevice, Protocol1.GetFamilyUnit[ns],      NSTypes.maxIDPBytesPerPacket];  --back to normal    END;  --StoreBulk  XferBulk: ServiceEntry =    BEGIN    bulk: XStream.Handle;    arguments[[@bulk, XStream.DescribeSource]];    XStream.ServerCheckout[cH, [proc[rendezvous.checkout]]];    [] ¬ results[];  --nothing to report    END;  --XferBulk  DisplayTime: PROC[time: LONG CARDINAL, length: LONG CARDINAL] =    BEGIN    bps: LONG CARDINAL;    time ¬ System.PulsesToMicroseconds[[time]] / 100000;  --in decasecs    bps ¬ (length * 80) / (IF time # 0 THEN time ELSE 1);  --allow for quickness      Write["done\n"L];    Format.LongDecimal[Write, length];    Write[" bytes at "L];    Format.LongDecimal[Write, bps];    Write[" bits per second\n"L];    END;  --DisplayTime  StoreSpp: PROC[    args: XferProtocol.StoreArguments, address: System.NetworkAddress,    sH: Stream.Handle] =    BEGIN    window: CARDINAL;    time: LONG CARDINAL;    eom: BOOLEAN ¬ FALSE;    psH: PacketStream.Handle;    sst: Stream.SubSequenceType;    stateObject ¬ [sH, args.transport.sink, busy, address];    Write["\nWaiting for "L];    Write[args.name]; Write[" ... "L];    Protocol1.SetMaximumBufferSize[      Driver.nilDevice, Protocol1.GetFamilyUnit[ns], args.transport.frame];    window ¬ SppOps.sppWindowSize;  --save old value    SppOps.SetWindow[PRED[args.transport.window]];  --reset for test    Write["waiting for 'packet stream' connection ... "L];    psH ¬ PacketStream.Make[      local: address, remote: args.transport.address,      localConnID: PacketStream.unknownConnID,      remoteConnID: PacketStream.unknownConnID,      establishConnection: FALSE, classOfService: bulk !      PacketStream.ConnectionFailed => GOTO noConnection];    Write["connection arrived ... "L];    IF ~args.transport.checksums THEN SppOps.DisableChecksums[psH];    psH.setSenderSizeLimit[  --make it a different size      args.transport.frame -  --that reflects the frame size selected      NSTypes.bytesPerIDPHeader -  --but allows that we're using SPP      NSTypes.bytesPerSppHeader];  --and doesn't dribble off the end    time ¬ System.GetClockPulses[];  --we're brag'n, so let's measure    UNTIL eom DO      ENABLE PacketStream.ConnectionSuspended => GOTO failed;      ns: NSBuffer.Body;      from: Environment.Block;      b: NSBuffer.Buffer ¬ psH.get[];      IF b = NIL THEN GOTO failed ELSE ns ¬ b.ns;            SELECT (sst ¬ ns.subtype) FROM        1 =>	  BEGIN	  eom ¬ ns.endOfMessage;  --copy this one	  from ¬ [LOOPHOLE[ns], SppSize[0], ns.pktLength];	  sH.put[sH, from, FALSE];  --move the bits	  END;	NetworkStream.closeSST, NetworkStream.closeReplySST =>	  BEGIN	  eom ¬ TRUE;  --there's just no doubt	  from ¬ [LOOPHOLE[ns], SppSize[0], ns.pktLength];	  sH.put[sH, from, FALSE];  --move the bits	  END;	ENDCASE; --the endcase is ignoring the data      psH.returnReceiveBuffer[b];  --give the buffer back      IF eom THEN {stateObject.status ¬ okay; EXIT};  --get out now      REPEAT failed =>        {Write[" (transfer failed) "L]; stateObject.status ¬ error};      ENDLOOP;    time ¬ System.GetClockPulses[] - time;  --that's the elapsed time    XferProtocol.ClosePacketStream[psH,      SELECT sst FROM        NetworkStream.closeSST,	NetworkStream.closeReplySST => sendCloseReply,	ENDCASE => sendClose];    psH.destroy[psH];  --gun the stream    SppOps.SetWindow[window];  --reset to value when we came in    Protocol1.SetMaximumBufferSize[      Driver.nilDevice, Protocol1.GetFamilyUnit[ns],      NSTypes.maxIDPBytesPerPacket];  --back to normal    Courier.Free[[@args, XferProtocol.DescribeStoreArguments], zone];    DisplayTime[time, args.length];  --print results    EXITS noConnection =>      {stateObject.status ¬ error; Write["no connection..."L]};     END;  --StoreSpp  <<  NotifyForceOut: ENTRY PROC[interval: Space.Interval] =    BEGIN    WHILE forceOutProcesses > 10 DO WAIT forceOut;      REPEAT FINISHED =>        BEGIN	forceOutProcesses ¬ SUCC[forceOutProcesses];	Process.Detach[FORK ForceOutProcess[interval]];	END;      ENDLOOP;    END;  --NotifyForceOut  ForceOutProcess: ENTRY PROC[interval: Space.Interval] =    BEGIN    Space.ForceOut[interval];    forceOutProcesses ¬ PRED[forceOutProcesses];    NOTIFY forceOut;    END;  --ForceOutProcess  >>  StoreExchange: PROC[    args: XferProtocol.StoreArguments, address: System.NetworkAddress,    sH: Stream.Handle] =    BEGIN    from: Environment.Block;    time: LONG CARDINAL ¬ 0;    position: Stream.Position;    pH: PacketExchange.ExchangeHandle;    finis: XferProtocol.CommitStatus ¬ okay;    Position: TYPE = LONG POINTER TO Stream.Position;    eod: PacketExchange.ExchangeClientType ¬ unspecified;    Block: TYPE = RECORD[      PACKED SEQUENCE COMPUTED INTEGER OF Environment.Byte];    ovh: NATURAL = NSTypes.bytesPerExchangeHeader + NSTypes.bytesPerIDPHeader;    Protocol1.SetMaximumBufferSize[      Driver.nilDevice, Protocol1.GetFamilyUnit[ns], args.transport.frame];    pH ¬ PacketExchange.CreateReplier[  --after setting buffer size      local: address, waitTime: LAST[PacketExchange.WaitTime]];  --don't timeout    from.blockPointer ¬ LOOPHOLE[zone.NEW[Block[args.transport.frame - ovh]]];    stateObject ¬ [sH, args.transport.sink, busy, address];    Write["\nWaiting for "L];    Write[args.name]; Write[" ... "L];    Write["waiting for 'packet exchange' transfer ... "L];    UNTIL eod # unspecified DO      rH: PacketExchange.RequestHandle;      from.startIndex ¬ 0;  --so we read the position      from.stopIndexPlusOne ¬ args.transport.frame - ovh;      rH ¬ PacketExchange.WaitForRequest[pH, from];  --come and get it      IF time = 0 THEN time ¬ System.GetClockPulses[];  --start timing now      position ¬ sH.getPosition[sH];  --stream thinks he's there      SELECT INTEGER[LOOPHOLE[from.blockPointer, Position]­ - position] FROM        = 0 =>	  BEGIN	  from.startIndex ¬ SIZE[Stream.Position] * bpw;  --skip position field	  from.stopIndexPlusOne ¬ rH.nBytes;  --that many bytes	  eod ¬ rH.requestType;  --copy out for end of data	  sH.put[sH, from, FALSE];  --write the bits	  END;        < 0 => NULL;  --he missed my ack and retransmitted	> 0 => finis ¬ error;  --this is busted	ENDCASE;  --waddaya think's left here?      PacketExchange.SendReply[pH, rH, Environment.nullBlock, eod];      ENDLOOP;    time ¬ System.GetClockPulses[] - time;  --that's the elapsed time    DisplayTime[time, args.length];  --print results    stateObject.status ¬ finis;  --get out now    zone.FREE[@from.blockPointer];    END;  --StoreExchange  WriteDeviceType: PROC[dt: XferProtocol.DeviceType] =    BEGIN    Write[SELECT dt FROM      devnull => "devnull"L, rigidDisk => "rigidDisk"L, magtape => "magtape"L,      dt0 => "dt0"L, dt1 => "dt1"L, dt2 => "dt2"L, ENDCASE => "dt3"L];    END;  --WriteDeviceType  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];      new = inactive =>        IF data # NIL THEN	  {IF data.serverStarted THEN StopInternal[]; zone.FREE[@data]};      ENDCASE;    };  StartServer: PUBLIC <<XferProtocol>> PROC[z: UNCOUNTED ZONE]    RETURNS[wh: Window.Handle] = {    zone ¬ z;  --copy his zone for our use    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: box,      clientTransition: ClientTransition, name: "XferServer"L,      cmSection: "XferServer"L];    Process.DisableTimeout[@forceOut];    };      MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [18];    Tool.UnusedLogName[unused: logName, root: "XferServer.log"L];    data.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm, zone: zone];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems, zone];    items[FormItems.start.ORD] ¬ CommandItem[      tag: "Start"L, place: [CharPos[1], line0], proc: Start, z: zone];    items[FormItems.stop.ORD] ¬ CommandItem[      tag: "Stop"L, place: [CharPos[9], line0], proc: Stop, z: zone];    RETURN[items: items, freeDesc: TRUE];    };  }...    
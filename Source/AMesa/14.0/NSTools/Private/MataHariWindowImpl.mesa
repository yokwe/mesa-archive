-- File: MataHariWindowImpl.mesa - last edit:-- AOF                  3-Nov-87 11:00:57-- BKI                 23-Jun-87 18:08:14-- SMA                 17-Apr-86 19:51:55-- Copyright (C) 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  BufferDisplay USING [Format],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, LabelItem, line0, line1, line2,    line3, line4, line5, line6, line7, line8, line9, nextLine, NotifyProcType,    NumberItem, ProcType, sameLine, StringItem],  MataHariInternal,  Protocol1 USING [Family, GetFamilyUnit, SetMaximumBufferSize],  SpecialCommunication USING [SpyType],  String USING [CopyToNewString],  Tool USING [Create, Destroy, MakeFormSW, MakeSWsProc];MataHariWindowImpl: MONITOR  IMPORTS FormSW, MataHariInternal, Protocol1, String, Tool  EXPORTS MataHariInternal =  BEGIN  scratch: LONG STRING ¬ NIL;  packetLengthItem: NATURAL;  --set when formSW is created  zone: UNCOUNTED ZONE = MataHariInternal.z;  ApplyOptions: ENTRY FormSW.ProcType =    BEGIN  -- snapshot the state of the parameters.    ENABLE UNWIND => NULL;    MataHariInternal.params­ ¬ MataHariInternal.toolParams­;    BuildSpyArray[];    END;  -- ApplyOptions  BuildSpyArray: PROC =    BEGIN OPEN MataHariInternal;    done: BOOLEAN ¬ FALSE;    tool.spyTypes ¬ ALL[NIL];    IF params.ns THEN {tool.spyTypes[ns] ¬ MataHariInternal.NSSpy; done ¬ TRUE};    IF params.pup THEN {      tool.spyTypes[pup] ¬ MataHariInternal.PupSpy; done ¬ TRUE};    IF params.arpa THEN {      tool.spyTypes[arpa] ¬ MataHariInternal.ArpaSpy; done ¬ TRUE};    IF params.osi THEN {      tool.spyTypes[osi] ¬ MataHariInternal.OsiSpy; done ¬ TRUE};    IF ~done THEN      FOR t: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO        tool.spyTypes[t] ¬ RawSpy; ENDLOOP;    END;  --BuildSpyArray  CloseOptions: PUBLIC ENTRY FormSW.ProcType =    BEGIN  -- snapshot the state of the parameters and close the options window.    OPEN MataHariInternal;    params­ ¬ toolParams­;    BuildSpyArray[];    IF tool.optionsSW # NIL THEN {      Tool.Destroy[tool.optionsSW]; tool.optionsSW ¬ NIL};    END;  -- CloseOptions  MakeBroadcastOptions: Tool.MakeSWsProc =    BEGIN    MataHariInternal.tool.optionsSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeBroadcastForm, zone: zone];    END;  -- MakeBroadcastOptions  MakeRawOptions: Tool.MakeSWsProc =    BEGIN    MataHariInternal.tool.optionsSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeRawForm, zone: zone];    END;  -- MakeRawOptions  MakeNSOptions: Tool.MakeSWsProc =    BEGIN    MataHariInternal.tool.optionsSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeNSForm, zone: zone];    END;  -- MakeNSOptions  MakePupOptions: Tool.MakeSWsProc =    BEGIN    MataHariInternal.tool.optionsSW ¬ Tool.MakeFormSW[      window: window, formProc: MakePupForm, zone: zone];    END;  -- MakePupOptions  MakeArpaOptions: Tool.MakeSWsProc =    BEGIN    MataHariInternal.tool.optionsSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeArpaForm, zone: zone];    END;  -- MakeArpaOptions  MakeOsiOptions: Tool.MakeSWsProc =    BEGIN    MataHariInternal.tool.optionsSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeOsiForm, zone: zone];    END;  -- MakeOsiOptions  MakeRBOptions: Tool.MakeSWsProc =    BEGIN    MataHariInternal.tool.rbOptionsSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeRBForm, zone: zone];    END;  -- MakeRBOptions  MakeBroadcastForm: FormSW.ClientItemsProcType =    BEGIN  -- The form for the broadcast items.    OPEN FormSW, MataHariInternal;    j: CARDINAL;    nItems: CARDINAL = 6;    items ¬ AllocateItemDescriptor[nItems, zone];    items[j ¬ 0] ¬ CommandItem[      tag: "Apply"L, place: [5, line0], proc: ApplyOptions, z: zone];    items[j ¬ j + 1] ¬ CommandItem[      tag: "Close"L, place: [55, line0], proc: CloseOptions, z: zone];    items[j ¬ j + 1] ¬ LabelItem[      tag: "Display Options:"L, place: [5, line2], readOnly: TRUE, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Channel headers"L, place: [10, nextLine],      switch: @toolParams.displayParams[conHeader], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Encapsulation"L, place: [160, sameLine],      switch: @toolParams.displayParams[encap], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Data"L, place: [10, nextLine],      switch: @toolParams.displayParams[data], z: zone];    IF (j + 1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;  -- MakeBroadcastForm  MakeRawForm: FormSW.ClientItemsProcType =    BEGIN  -- The form for the raw items.    OPEN FormSW, MataHariInternal;    j: CARDINAL;    nItems: CARDINAL = 8;    items ¬ AllocateItemDescriptor[nItems, zone];    items[j ¬ 0] ¬ CommandItem[      tag: "Apply"L, place: [5, line0], proc: ApplyOptions, z: zone];    items[j ¬ j + 1] ¬ CommandItem[      tag: "Close"L, place: [55, line0], proc: CloseOptions, z: zone];    items[j ¬ j + 1] ¬ LabelItem[      tag: "Display Options:"L, place: [5, line2], readOnly: TRUE, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "all"L, place: [10, nextLine], switch: @toolParams.allRaw, z: zone];    items[j ¬ j + 1] ¬ NumberItem[      tag: "raw type"L, place: [160, sameLine], signed: FALSE, notNegative: TRUE,      value: @toolParams.rawType, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Channel headers"L, place: [10, nextLine],      switch: @toolParams.displayParams[conHeader], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Encapsulation"L, place: [160, sameLine],      switch: @toolParams.displayParams[encap], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Data"L, place: [10, nextLine],      switch: @toolParams.displayParams[data], z: zone];    IF (j + 1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;  -- MakeRawForm  MakeNSForm: FormSW.ClientItemsProcType =    BEGIN  --The form for the ns items.    OPEN FormSW, MataHariInternal;    j: CARDINAL;    nItems: CARDINAL = 24;    items ¬ AllocateItemDescriptor[nItems, zone];    items[j ¬ 0] ¬ CommandItem[      tag: "Apply"L, place: [5, line0], proc: ApplyOptions, z: zone];    items[j ¬ j + 1] ¬ CommandItem[      tag: "Close"L, place: [55, line0], proc: CloseOptions, z: zone];    items[j ¬ j + 1] ¬ LabelItem[      tag: "PacketType(s): "L, place: [5, line2], readOnly: TRUE, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "IDP"L, place: [10, line3], switch: @toolParams.level1Type[ns], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "private"L, place: [10, line5], switch: @toolParams.nsType[private], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "routing"L, place: [70, line5],      switch: @toolParams.nsType[routingInformation], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "echo"L, place: [130, line5], switch: @toolParams.nsType[echo], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "error"L, place: [190, line5], switch: @toolParams.nsType[error], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "pex"L, place: [250, line5],      switch: @toolParams.nsType[packetExchange], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "spp"L, place: [10, line6],      switch: @toolParams.nsType[sequencedPacket], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "pupAddr"L, place: [70, line6],      switch: @toolParams.nsType[pupAddrTransPacket], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "ubBoot"L, place: [130, line6],      switch: @toolParams.nsType[ubBootPacket], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "ubIPC"L, place: [190, line6],      switch: @toolParams.nsType[ubIPCPacket], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "etherBoot"L, place: [250, line6],      switch: @toolParams.nsType[bootServerPacket], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "mail"L, place: [10, line7],      switch: @toolParams.nsType[electronicMailCacheFlushPacket], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "ubDiag"L, place: [70, line7],      switch: @toolParams.nsType[ubDiagnosticPacket], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "pcc"L, place: [130, line7], switch: @toolParams.nsType[pccPacket], z: zone];    items[j ¬ j + 1] ¬ LabelItem[      tag: "Display Options:"L, place: [5, line9], readOnly: TRUE, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Connection/Channel headers"L, place: [10, nextLine],      switch: @toolParams.displayParams[conHeader], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Encapsulation"L, place: [170, sameLine],      switch: @toolParams.displayParams[encap], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "NS headers"L, place: [10, nextLine],      switch: @toolParams.displayParams[lvl1Headers], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Level 2 headers"L, place: [170, sameLine],      switch: @toolParams.displayParams[lvl2Headers], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Spp system packets"L, place: [10, nextLine],      switch: @toolParams.displayParams[system], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Data"L, place: [170, sameLine],      switch: @toolParams.displayParams[data], z: zone];    IF (j + 1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;  -- MakeNSForm  MakePupForm: FormSW.ClientItemsProcType =    BEGIN  -- The form for the pup items.    OPEN FormSW, MataHariInternal;    j: CARDINAL;    nItems: CARDINAL = 9;    items ¬ AllocateItemDescriptor[nItems, zone];    items[j ¬ 0] ¬ CommandItem[      tag: "Apply"L, place: [5, line0], proc: ApplyOptions, z: zone];    items[j ¬ j + 1] ¬ CommandItem[      tag: "Close"L, place: [55, line0], proc: CloseOptions, z: zone];    items[j ¬ j + 1] ¬ LabelItem[      tag: "PacketType(s): "L, place: [5, line2], readOnly: TRUE, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "level 1"L, place: [10, line3], switch: @toolParams.level1Type[pup], z: zone];    items[j ¬ j + 1] ¬ LabelItem[      tag: "Display Options:"L, place: [5, line5], readOnly: TRUE, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Connection/Channel headers"L, place: [10, nextLine],      switch: @toolParams.displayParams[conHeader], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Encapsulation"L, place: [170, sameLine],      switch: @toolParams.displayParams[encap], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "level 1 headers"L, place: [10, nextLine],      switch: @toolParams.displayParams[lvl1Headers], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Data"L, place: [170, sameLine],      switch: @toolParams.displayParams[data], z: zone];    IF (j + 1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;  -- MakePupForm  MakeArpaForm: FormSW.ClientItemsProcType =    BEGIN  --The form for the arpa items.    OPEN FormSW, MataHariInternal;    j: CARDINAL;    nItems: CARDINAL = 12;    items ¬ AllocateItemDescriptor[nItems, zone];    items[j ¬ 0] ¬ CommandItem[      tag: "Apply"L, place: [5, line0], proc: ApplyOptions, z: zone];    items[j ¬ j + 1] ¬ CommandItem[      tag: "Close"L, place: [55, line0], proc: CloseOptions, z: zone];    items[j ¬ j + 1] ¬ LabelItem[      tag: "PacketType(s): "L, place: [5, line2], readOnly: TRUE, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "IP"L, place: [10, line3], switch: @toolParams.level1Type[arpa], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "tcp"L, place: [10, line5], switch: @toolParams.arpaType[tcp], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "udp"L, place: [70, line5],      switch: @toolParams.arpaType[userDatagram], z: zone];    items[j ¬ j + 1] ¬ LabelItem[      tag: "Display Options:"L, place: [5, line7], readOnly: TRUE, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Connection/Channel headers"L, place: [10, nextLine],      switch: @toolParams.displayParams[conHeader], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Encapsulation"L, place: [170, sameLine],      switch: @toolParams.displayParams[encap], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "IP headers"L, place: [10, nextLine],      switch: @toolParams.displayParams[lvl1Headers], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Level 2 headers"L, place: [170, sameLine],      switch: @toolParams.displayParams[lvl2Headers], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Data"L, place: [10, nextLine],      switch: @toolParams.displayParams[data], z: zone];    IF (j + 1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;  -- MakeArpaForm  MakeOsiForm: FormSW.ClientItemsProcType =     BEGIN   -- The form for Osi items.    OPEN FormSW, MataHariInternal;    j: CARDINAL;    nItems: CARDINAL = 12;    items ¬ AllocateItemDescriptor[nItems, zone];    items[j ¬ 0] ¬ CommandItem[      tag: "Apply"L, place: [5, line0], proc: ApplyOptions, z: zone];    items[j ¬ j + 1] ¬ CommandItem[      tag: "Close"L, place: [55, line0], proc: CloseOptions, z: zone];    items[j ¬ j + 1] ¬ LabelItem[      tag: "PacketType(s): "L, place: [5, line2], readOnly: TRUE, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "CLNP"L, place: [10, line3], switch: @toolParams.level1Type[osi], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "COTP"L, place: [10, line5], switch: @toolParams.osiType[iso8073], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "CLTP"L, place: [70, line5], switch: @toolParams.osiType[iso8602], z: zone];    items[j ¬ j + 1] ¬ LabelItem[      tag: "Display Options:"L, place: [5, line7], readOnly: TRUE, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Connection/Channel headers"L, place: [10, nextLine],      switch: @toolParams.displayParams[conHeader], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Encapsulation"L, place: [170, sameLine],      switch: @toolParams.displayParams[encap]];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Network headers"L, place: [10, nextLine],      switch: @toolParams.displayParams[lvl1Headers], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Transport headers"L, place: [170, sameLine],      switch: @toolParams.displayParams[lvl2Headers], z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Data"L, place: [10, nextLine],      switch: @toolParams.displayParams[data], z: zone];    IF (j + 1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;  --MakeOsiForm  MakeForm: PUBLIC FormSW.ClientItemsProcType =    BEGIN  --The form for the main window.    OPEN FormSW, MataHariInternal;    j: CARDINAL;    nItems: CARDINAL = 24 «28» ;    coll: ARRAY [0..3) OF Enumerated ¬ [      ["realtime"L, MataHariInternal.Mode[etherToDisplay]], [      "buffered"L, MataHariInternal.Mode[etherToDisk]], [      "replay"L, MataHariInternal.Mode[diskToDisplay]]];    format: ARRAY [0..6) OF Enumerated ¬ [      ["octal2"L, BufferDisplay.Format[octal2]], [      "octal1"L, BufferDisplay.Format[octal1]], [      "hex"L, BufferDisplay.Format[hex]], [      "decimal"L, BufferDisplay.Format[decimal]], [      "ascii"L, BufferDisplay.Format[ascii]], [      "ebcdic"L, BufferDisplay.Format[ebcdic]]];    time: ARRAY [0..2) OF Enumerated ¬ [      ["relative"L, MataHariInternal.Timing[relative]], [      "absolute"L, MataHariInternal.Timing[absolute]]];    items ¬ AllocateItemDescriptor[nItems, zone];    toolParams.peekAddr ¬ zone.NEW[StringBody [5]];    toolParams.peekAddr ¬ String.CopyToNewString[      s: ".*."L, z: zone];    items[j ¬ 0] ¬ CommandItem[      tag: "StartSpy"L, place: [0, line0], proc: StartCmd, z: zone];    items[j ¬ j + 1] ¬ CommandItem[      tag: "StopSpy"L, place: [90, line0], proc: StopCmd, z: zone];    items[j ¬ j + 1] ¬ EnumeratedItem[      tag: "Collection Mode"L, place: [175, line0], choices: DESCRIPTOR[coll],      value: @toolParams.driver, z: zone];    items[j ¬ j + 1] ¬ NumberItem[      tag: "Replay range: {low"L, place: [175, line1], signed: FALSE,      notNegative: TRUE, value: @toolParams.replayStart, z: zone];    startItem ¬ j;    items[j ¬ j + 1] ¬ NumberItem[      tag: ", high"L, place: [375, line1], signed: FALSE, notNegative: TRUE,      value: @toolParams.replayStop, z: zone];    stopItem ¬ j;    items[j ¬ j + 1] ¬ LabelItem[tag: "}"L, place: [450, line1], readOnly: TRUE, z: zone];    items[j ¬ j + 1] ¬ StringItem[      tag: ""L, place: [600, line1], drawBox: TRUE, string: @scratch,      inHeap: TRUE, z: zone];    items[j ¬ j + 1] ¬ LabelItem[      tag: "DISPLAY OPTIONS"L, place: [0, line3], readOnly: TRUE, z: zone];    «   items[j¬j+1] ¬ LabelItem[      tag: "PACKET LENGTH OPTIONS"L, place: [606, line3], readOnly: TRUE, z: zone];    items[j¬j+1] ¬ CommandItem[      tag: "Defaults"L, place: [750, line3], proc: DefaultPacketLength, z: zone];    items[j¬j+1] ¬ CommandItem[      tag: "Set"L, place: [810, line3], proc: SetPacketLength, z: zone];      items[j¬j+1] ¬ NumberItem[tag: "(bytes)"L, place: [840, line3],      signed: FALSE, notNegative: TRUE, value: @tool.settablePacketLength, z: zone]; »    packetLengthItem ¬ j;  --remember what it was    items[j ¬ j + 1] ¬ BooleanItem[      tag: "Flippers"L, place: [40, line4], switch: @toolParams.flippers,      proc: ToggleFlippers, z: zone];    items[j ¬ j + 1] ¬ NumberItem[      tag: "Line length "L, place: [130, line4], signed: FALSE, notNegative: TRUE,      value: @toolParams.lineLen, z: zone];    items[j ¬ j + 1] ¬ EnumeratedItem[      tag: "Timing"L, place: [250, line4], choices: DESCRIPTOR[time],      value: @toolParams.timing, z: zone];    items[j ¬ j + 1] ¬ EnumeratedItem[      tag: "Format"L, place: [400, line4], choices: DESCRIPTOR[format],      value: @toolParams.format, z: zone];    items[j ¬ j + 1] ¬ LabelItem[      tag: "FILTERING"L, place: [0, line6], readOnly: TRUE, z: zone];    items[j ¬ j + 1] ¬ StringItem[      tag: "Source/destination address"L, place: [40, line7],      string: @toolParams.peekAddr, drawBox: TRUE, inHeap: TRUE, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "incoming"L, place: [520, line7], switch: @toolParams.incoming, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "outgoing"L, place: [600, line7], switch: @toolParams.outgoing, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "include broadcasts"L, place: [680, line7], switch: @toolParams.all, z: zone];    items[j ¬ j + 1] ¬ CommandItem[      tag: "Ring buffer options"L, place: [800, line7],      proc: CreateRBOptionsWindow, z: zone];    items[j ¬ j + 1] ¬ BooleanItem[      tag: "broadcasts "L, drawBox: TRUE, place: [40, line8],      switch: @toolParams.broadcasts, proc: NotifyFilterBC, z: zone];    bcItem ¬ j;    items[j ¬ j + 1] ¬ BooleanItem[      tag: "raw "L, drawBox: TRUE, place: [115, line8], switch: @toolParams.raw,      proc: NotifyFilterRaw, z: zone];    rawItem ¬ j;    items[j ¬ j + 1] ¬ BooleanItem[      tag: "NS "L, drawBox: TRUE, place: [190, line8], switch: @toolParams.ns,      proc: NotifyFilterNS, z: zone];    nsItem ¬ j;    items[j ¬ j + 1] ¬ BooleanItem[      tag: "PUP "L, drawBox: TRUE, place: [265, line8], switch: @toolParams.pup,      proc: NotifyFilterPup, z: zone];    pupItem ¬ j;    items[j ¬ j + 1] ¬ BooleanItem[      tag: "ARPA "L, drawBox: TRUE, place: [340, line8], switch: @toolParams.arpa,      proc: NotifyFilterArpa, z: zone];    arpaItem ¬ j;    items[j ¬ j + 1] ¬ BooleanItem[      tag: "OSI "L, drawBox: TRUE, place: [415, line8], switch: @toolParams.osi,      proc: NotifyFilterOsi, z: zone];    osiItem ¬ j;    IF (j + 1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;  -- MakeForm  MakeRBForm: FormSW.ClientItemsProcType =    BEGIN  -- The form for the ring buffer operations.    OPEN FormSW, MataHariInternal;    j: CARDINAL;    nItems: CARDINAL = 4;    items ¬ AllocateItemDescriptor[nItems, zone];    items[j ¬ 0] ¬ CommandItem[tag: "Close"L, place: [5, line0], proc: CloseRBW, z: zone];    items[j ¬ j + 1] ¬ CommandItem[tag: "Set"L, place: [10, line2], proc: SetRB, z: zone];    items[j ¬ j + 1] ¬ CommandItem[      tag: "Save"L, place: [40, line2], proc: SaveRB, z: zone];    items[j ¬ j + 1] ¬ StringItem[      tag: "Ring buffer file"L, place: [10, line3], string: @tool.rbName,      inHeap: TRUE, z: zone];    IF (j + 1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;  --MakeRBForm  CreateOptionsWindow: PUBLIC PROC [filterLvl: MataHariInternal.FilterLvl] =    BEGIN  -- Sets up the options window for the specified level of filtering.    OPEN MataHariInternal;    SELECT filterLvl FROM      broadcast =>        BEGIN        toolParams.raw ¬ toolParams.ns ¬ toolParams.pup ¬ toolParams.arpa ¬          toolParams.osi ¬ FALSE;        -- Close old option window.        IF tool.optionsSW # NIL THEN CloseOptions[];        tool.optionsSW ¬ Tool.Create[          makeSWsProc: MakeBroadcastOptions, initialState: default,          initialBox: [place: [x: 620, y: 530], dims: [w: 375, h: 222]],          name: "Level 0/Broadcast Display Options", tinyName1: "L0"L,          tinyName2: "Options"L];        END;      raw =>        BEGIN        toolParams.broadcasts ¬ toolParams.ns ¬ toolParams.pup ¬ toolParams.arpa ¬          toolParams.osi ¬ FALSE;        -- Close old option window.        IF tool.optionsSW # NIL THEN CloseOptions[];        tool.optionsSW ¬ Tool.Create[          makeSWsProc: MakeRawOptions, initialState: default,          initialBox: [place: [x: 620, y: 530], dims: [w: 375, h: 222]],          name: "Raw Display Options", tinyName1: "Raw"L, tinyName2: "Options"L];        END;      ns =>        BEGIN        toolParams.broadcasts ¬ toolParams.raw ¬ toolParams.pup ¬ toolParams.arpa          ¬ toolParams.osi ¬ FALSE;        -- Close old option window.        IF tool.optionsSW # NIL THEN CloseOptions[];        tool.optionsSW ¬ Tool.Create[          makeSWsProc: MakeNSOptions, initialState: default,          initialBox: [place: [x: 620, y: 530], dims: [w: 375, h: 222]],          name: "NS Display Options", tinyName1: "NS"L, tinyName2: "Options"L];        END;      pup =>        BEGIN        toolParams.broadcasts ¬ toolParams.raw ¬ toolParams.ns ¬ toolParams.arpa ¬          toolParams.osi ¬ FALSE;        -- Close old option window.        IF tool.optionsSW # NIL THEN CloseOptions[];        tool.optionsSW ¬ Tool.Create[          makeSWsProc: MakePupOptions, initialState: default,          initialBox: [place: [x: 620, y: 530], dims: [w: 375, h: 222]],          name: "Pup Display Options", tinyName1: "Pup"L, tinyName2: "Options"L];        END;      arpa =>        BEGIN        toolParams.broadcasts ¬ toolParams.raw ¬ toolParams.ns ¬ toolParams.pup ¬          toolParams.osi ¬ FALSE;        -- Close old option window.        IF tool.optionsSW # NIL THEN CloseOptions[];        tool.optionsSW ¬ Tool.Create[          makeSWsProc: MakeArpaOptions, initialState: default,          initialBox: [place: [x: 620, y: 530], dims: [w: 375, h: 222]],          name: "Arpa Display Options", tinyName1: "Arpa"L,          tinyName2: "Options"L];        END;      osi =>        BEGIN        toolParams.broadcasts ¬ toolParams.raw ¬ toolParams.ns ¬ toolParams.pup ¬          toolParams.arpa ¬ FALSE;        -- Close old option window.        IF tool.optionsSW # NIL THEN CloseOptions[];        tool.optionsSW ¬ Tool.Create[          makeSWsProc: MakeOsiOptions, initialState: default,          initialBox: [place: [x: 620, y: 530], dims: [w: 375, h: 222]],          name: "Osi Display Options", tinyName1: "Osi"L, tinyName2: "Options"L];        END;      ENDCASE;    FormSW.DisplayItem[tool.formSW, bcItem];    FormSW.DisplayItem[tool.formSW, rawItem];    FormSW.DisplayItem[tool.formSW, nsItem];    FormSW.DisplayItem[tool.formSW, pupItem];    FormSW.DisplayItem[tool.formSW, arpaItem];    FormSW.DisplayItem[tool.formSW, osiItem];    END;  -- CreateOptionsWindow  CreateRBOptionsWindow: FormSW.NotifyProcType =    BEGIN  -- Sets up the ring buffer options window.    OPEN MataHariInternal;    IF tool.rbOptionsSW # NIL THEN {CloseRBW[]; tool.rbOptionsSW ¬ NIL};    tool.rbOptionsSW ¬ Tool.Create[      makeSWsProc: MakeRBOptions, initialState: default,      initialBox: [place: [x: 620, y: 530], dims: [w: 375, h: 222]],      name: "Ring Buffer Operations", tinyName1: "RB"L, tinyName2: "Operations"L];    END;  --CreateRBOptionsWindow  SetPacketLength: FormSW.NotifyProcType =    BEGIN    « OPEN T: MataHariInternal;    size: ARRAY BufferOps.SizeHint OF CARDINAL;    size ¬ BufferOps.GetSizes[];  --that's what they are now    size[largeBuffer] ¬ (T.tool.settablePacketLength + 1) / 2;    BufferOps.SetSizes[size];  --and set them »    OPEN T: MataHariInternal;    magicNumber: CARDINAL = 1514;  -- exceed this at your own risk of glitch    size: CARDINAL ¬ MIN[(T.tool.settablePacketLength + 1) / 2, magicNumber];    family: Protocol1.Family ¬ Protocol1.GetFamilyUnit[ns];  -- well known    Protocol1.SetMaximumBufferSize[, family, size];    END;  --SetPacketLength  DefaultPacketLength: FormSW.NotifyProcType =    BEGIN    «   OPEN T: MataHariInternal;    size: ARRAY BufferOps.SizeHint OF CARDINAL;    size ¬ BufferOps.GetSizes[];  --that's what they are now    size[largeBuffer] ¬ (T.tool.defaultPacketLength + 1) / 2;        BufferOps.SetSizes[size];  --and restore them them  »    OPEN T: MataHariInternal;    family: Protocol1.Family ¬ Protocol1.GetFamilyUnit[ns];  -- well known    Protocol1.SetMaximumBufferSize[      , family, (T.tool.defaultPacketLength + 1) / 2];    T.tool.settablePacketLength ¬ T.tool.defaultPacketLength;    FormSW.DisplayItem[T.tool.formSW, packetLengthItem];  --redisplay    END;  --DefaultPacketLength  NotifyFilterBC: FormSW.NotifyProcType =    BEGIN OPEN MataHariInternal;    -- Called when the client changes the filter level to broadcast.    IF toolParams.broadcasts THEN      BEGIN      toolParams.displayParams[lvl1Headers] ¬ params.displayParams[lvl1Headers] ¬        FALSE;      toolParams.displayParams[lvl2Headers] ¬ params.displayParams[lvl2Headers] ¬        FALSE;      toolParams.displayParams[system] ¬ params.displayParams[system] ¬ FALSE;      CreateOptionsWindow[broadcast];      END;    END;  NotifyFilterRaw: FormSW.NotifyProcType =    BEGIN  -- Called when the client changes the filter level to level 0.    OPEN MataHariInternal;    IF toolParams.raw THEN      BEGIN      toolParams.displayParams[lvl1Headers] ¬ params.displayParams[lvl1Headers] ¬        toolParams.displayParams[lvl2Headers] ¬ params.displayParams[lvl2Headers]        ¬ toolParams.displayParams[system] ¬ params.displayParams[system] ¬ FALSE;      CreateOptionsWindow[raw];      END;    END;  NotifyFilterNS: FormSW.NotifyProcType =    BEGIN  -- Called when the client changes the filter ns.    IF MataHariInternal.toolParams.ns THEN BEGIN CreateOptionsWindow[ns]; END;    END;  NotifyFilterPup: FormSW.NotifyProcType =    BEGIN  -- Called when the client changes the filter to pup.    OPEN MataHariInternal;    IF toolParams.pup THEN      BEGIN      toolParams.displayParams[lvl2Headers] ¬ params.displayParams[lvl2Headers] ¬        toolParams.displayParams[system] ¬ params.displayParams[system] ¬ FALSE;      CreateOptionsWindow[pup];      END;    END;  NotifyFilterArpa: FormSW.NotifyProcType =    BEGIN  -- Called when the client changes the filter to arpa.    OPEN MataHariInternal;    IF toolParams.arpa THEN      BEGIN      toolParams.displayParams[system] ¬ params.displayParams[system] ¬ FALSE;      CreateOptionsWindow[arpa];      END;    END;  NotifyFilterOsi: FormSW.NotifyProcType =    BEGIN  -- Called when the client changes the filter to osi.    OPEN MataHariInternal;    IF toolParams.osi THEN      BEGIN      toolParams.displayParams[system] ¬ params.displayParams[system] ¬ FALSE;      CreateOptionsWindow[osi];      END;    END;  END...  LOG 7-Mar-85 15:23:44  SMA  Created file from FormSW pieces of NSSpyToolImpl.10-Apr-85 16:07:46  SMA  Added scratch pad item.   3-Oct-85 15:26:31  SMA  Added runtime loading of arpa and pup.19-Nov-85 13:24:12  SMA  Can specify type when collecting raw.16-Mar-86 15:03:42  AOF  Variable length (large, presumably) buffers16-Mar-86 15:03:42  NS   Took out packet length options stuff13-Apr-87  9:46:03  CLS  Added ISO support23-Jun-87 18:08:14  BKI  Convert to new OSI definitions. 3-Nov-87  9:56:06  AOF  Use of private zone
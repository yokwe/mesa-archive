-- File: HostGraphImpl.mesa - last edit:-- AOF                 18-May-88  8:47:04-- Copyright (C) 1984, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [Error, StringToNetworkAddress],  Buffer USING [    Buffer, MakePool, DestroyPool, AccessHandle, ReturnBuffer, Type],  DataLinkControl USING [AdjustInputQueueLength],  Display USING [Black, Gray, Text, White],  Driver USING [Device, GetDeviceChain],  IEEE8023 USING [Encapsulation],  Exec USING [AddCommand, ExecProc, RemoveCommand],  ExtendedString USING [AppendOctal],  File USING [nullFile],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    newLine, StringItem, ProcType],  Inline USING [LowHalf],  Process USING [    Abort, EnableAborts, SetTimeout, SecondsToTicks, priorityBackground,    SetPriority],  Protocol1 USING [SetMaximumBufferSize],  Router USING [FindMyHostID],  Runtime USING [GetBcdTime],  SpecialCommunication USING [    SetSpyProc, SpyProc, SetEthernetListener, SpyType],  Space USING [Interval, Kill, Map, Unmap],  SpecialSystem USING [    broadcastHostNumber, nullProcessorID, ProcessorID, HostNumber],  String USING [AppendString],  System USING [broadcastHostNumber, MicrosecondsToPulses],  Time USING [Append, Unpack],  Tool USING [AddThisSW, Create, Destroy, MakeFormSW, MakeSWsProc],  ToolWindow USING [CreateSubwindow, DisplayProcType, TransitionProcType],  UserTerminal USING [BlinkDisplay],  -- Needed by Tool.Create  Window USING [Handle],  WindowFont USING [CharWidth, FontHeight];    HostGraphImpl: MONITOR  IMPORTS    AddressTranslation, Buffer, Display, Driver, Exec, ExtendedString, Protocol1,    FormSW, Inline, Process, Router, Runtime, Space, SpecialCommunication,    String, System, Time, Tool, ToolWindow, UserTerminal, WindowFont,    DataLinkControl  EXPORTS Buffer, System =  BEGIN  HostNumber: PUBLIC TYPE = SpecialSystem.HostNumber;  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  wh: Window.Handle;  form, graph: Window.Handle ¬ NIL;  oldSpy: ARRAY Buffer.Type OF SpecialCommunication.SpyProc;    barHeight: INTEGER = 14;  tickHeight: INTEGER = 2;  tickWidth: INTEGER = 2;  graphHeight: INTEGER = 300;  margin: INTEGER = 10;  width: INTEGER = 1024 - 2*margin;  hostWidth: INTEGER = WindowFont.CharWidth['0] * 18;  barWidth: INTEGER = width - hostWidth;  height: INTEGER = tickHeight+graphHeight+2*margin;  borderBottom: INTEGER = height-margin;  borderTop: INTEGER = borderBottom-tickHeight;    updater: PROCESS;  interval: CONDITION;  scale: INTEGER = 32;  secondsPerInterval: CARDINAL = 1;  pulsesPerInterval: LONG CARDINAL = System.MicrosecondsToPulses[1000000];  running: BOOLEAN ¬ FALSE;  buffers: Buffer.AccessHandle ¬ NIL;  dispatcherBuffers: CARDINAL = 90;  space: Space.Interval;    unit: CARDINAL = 1;  me: HostNumber = Router.FindMyHostID[];  all: HostNumber = System.broadcastHostNumber;  processor: LONG STRING ¬ NIL;    Range: TYPE = CARDINAL[0..graphHeight/barHeight);  History: TYPE = PACKED ARRAY Range OF RECORD [old, new: INTEGER];  history: LONG DESCRIPTOR FOR History;    DataRecord: TYPE = RECORD [host: HostNumber, value: LONG INTEGER];  null: DataRecord ¬ [SpecialSystem.nullProcessorID, 0];  Data: TYPE = PACKED ARRAY Range OF DataRecord;  data: LONG DESCRIPTOR FOR Data;  finger: Range ¬ 0;    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ExecCall: Exec.ExecProc = {};  --ExecCall  Unload: Exec.ExecProc =    BEGIN    Tool.Destroy[wh];  --get rid of tool (calls ClientTransition)    Exec.RemoveCommand[h, "HostGraph.~"L];    END;  --Unload        Initialize: PROCEDURE =    BEGIN    herald: STRING ¬ [60];    Process.SetTimeout[@interval, Process.SecondsToTicks[secondsPerInterval]];    Process.EnableAborts[@interval];    Exec.AddCommand[name: "HostGraph.~"L, proc: ExecCall, unload: Unload];    String.AppendString[to: herald, from: "Host Graph of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 8;  -- omit hours, mins, zone.    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: herald,      initialBox: [[x: 0, y: 619 ],[w: 1024, h: graphHeight + 59]]];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    graph ¬ ToolWindow.CreateSubwindow[parent: window, display: DisplayGraph];    Tool.AddThisSW[window: window, sw: graph, swType: vanilla, h: height];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    END;    DisplayGraph: ToolWindow.DisplayProcType =    BEGIN    DrawGraphPaper[];    ShowDots[];    END;    DrawGraphPaper: PROCEDURE =    BEGIN    delta: CARDINAL = 100;    Display.White[graph,[[0,0],[width, height]]];    Display.Black[      graph,[[margin, borderBottom],[width, tickHeight]]];    FOR i: CARDINAL IN[0..1000) DO  -- hundreds markers      IF (i MOD delta) # 0 THEN LOOP;      Display.White[        graph,[[margin+hostWidth+i, borderBottom], [tickWidth, tickHeight]]];      Display.Black[        graph,[[margin+hostWidth+i, borderBottom - tickHeight],	[tickWidth, tickHeight]]];      ENDLOOP;    END;      ShowDots: PROCEDURE =    BEGIN    FOR i: Range IN Range DO DisplayHost[i]; DisplayBar[i]; ENDLOOP;    END;    DisplayHost: PROC [i: Range] =    BEGIN    host: STRING ¬ [20];    stringLeft: INTEGER ¬ 0;    barBottom: INTEGER = borderTop - (barHeight * i) - margin - tickHeight;    stringBottom: INTEGER = barBottom + (barHeight - WindowFont.FontHeight[])/2;    Display.White[graph,[[0, barBottom],[hostWidth, barHeight]]];    IF data[i].host # SpecialSystem.nullProcessorID THEN      BEGIN      ExtendedString.AppendOctal[        @data[i].host, SIZE[SpecialSystem.ProcessorID], host];      FOR j: CARDINAL IN[0..host.length) DO        stringLeft ¬ stringLeft + WindowFont.CharWidth[host[j]]; ENDLOOP;      stringLeft ¬ (hostWidth - stringLeft)/2 - 2;      [] ¬ Display.Text[graph, host, [stringLeft, stringBottom]];      END;     END;      DisplayBar: PROC [i: Range] =    BEGIN    barBottom: INTEGER = borderTop - (barHeight * i) - margin - tickHeight - 1;    grayRight: INTEGER = history[i].old;    blackRight: INTEGER ¬ history[i].new;    IF graph = NIL THEN RETURN;    Display.White[      graph, [[hostWidth, barBottom], [barWidth, barHeight]]];    Display.Gray[      graph, [[hostWidth, barBottom], [grayRight, barHeight - 2]]];    IF blackRight > barWidth THEN      BEGIN      Display.Black[graph,        [[hostWidth+grayRight, barBottom], [barWidth-grayRight, barHeight - 2]]];      history[i].new ¬ blackRight ¬ blackRight MOD barWidth;      END;    Display.Black[graph,      [[hostWidth+grayRight, barBottom], [blackRight-grayRight, barHeight - 2]]];	    END;      MakeForm: FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL = 5;    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[0] ¬ FormSW.CommandItem[      tag: "Stop|Go"L, proc: StopGo, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "Reset"L, proc: Reset];    items[2] ¬ FormSW.CommandItem[tag: "Remove"L, proc: Remove];    items[3] ¬ FormSW.CommandItem[tag: "Include"L, proc: Include];    items[4] ¬ FormSW.StringItem[tag: "Host"L, string: @processor, inHeap: TRUE];    RETURN[items: items, freeDesc: TRUE];    END;    Remove: ENTRY FormSW.ProcType =    BEGIN    ENABLE    AddressTranslation.Error => GOTO chError;    host: SpecialSystem.ProcessorID;    IF (processor = NIL) OR (processor.length = 0) THEN RETURN;    host ¬ LOOPHOLE[      AddressTranslation.StringToNetworkAddress[processor].addr.host];    FOR i: Range DECREASING IN Range DO      IF host = data[i].host THEN	BEGIN	data[i] ¬ null;	history[i] ¬ [0, 0];	DisplayHost[i];	DisplayBar[i];	RETURN;	END;      ENDLOOP;    UserTerminal.BlinkDisplay[];    EXITS chError => UserTerminal.BlinkDisplay[];    END;    Include: ENTRY FormSW.ProcType =    BEGIN    ENABLE    AddressTranslation.Error => GOTO chError;    host: SpecialSystem.ProcessorID;    IF (processor = NIL) OR (processor.length = 0) THEN RETURN;    host ¬ LOOPHOLE[      AddressTranslation.StringToNetworkAddress[processor].addr.host];    FOR i: Range IN Range DO      IF data[i].host = SpecialSystem.nullProcessorID THEN	BEGIN	data[i] ¬ [host, 0];	history[i] ¬ [0, 0];	DisplayHost[i];	DisplayBar[i];	RETURN;	END;      ENDLOOP;    UserTerminal.BlinkDisplay[];    EXITS chError => UserTerminal.BlinkDisplay[];    END;    ResetData: ENTRY PROC =    BEGIN    FOR i: Range IN Range DO history[i] ¬ [0, 0]; data[i] ¬ null; ENDLOOP;    data[LAST[Range]] ¬ [LOOPHOLE[SpecialSystem.broadcastHostNumber], 0];    END;    Reset: FormSW.ProcType =    BEGIN    ResetData[];    DrawGraphPaper[];    END;    StopGo: FormSW.ProcType =    BEGIN    IF ~running THEN      BEGIN      updater ¬ FORK Updater[];      buffers ¬ Buffer.MakePool[dispatcherBuffers, 0];  --get large pool      --Driver.ChangeNumberOfInputBuffers[TRUE];      [] ¬ DataLinkControl.AdjustInputQueueLength[        ethernet, 0, dispatcherBuffers / 2];      FOR device: Device ¬ Driver.GetDeviceChain[], device.next        UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 1500];	ENDLOOP;	[] ¬ SpecialCommunication.SetEthernetListener[unit, all];	FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	  oldSpy[type] ¬ SpecialCommunication.SetSpyProc[SpyProc, type];	  ENDLOOP;      END    ELSE      BEGIN        [] ¬ SpecialCommunication.SetEthernetListener[unit, me];	FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	  [] ¬ SpecialCommunication.SetSpyProc[NIL, type];  --wipe out spy	  ENDLOOP;      --Driver.ChangeNumberOfInputBuffers[FALSE];      [] ¬ DataLinkControl.AdjustInputQueueLength[ethernet, 0, 5];      FOR device: Device ¬ Driver.GetDeviceChain[], device.next        UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 0];	ENDLOOP;      Buffer.DestroyPool[buffers];  --give pool back      running ¬ FALSE; Process.Abort[updater]; JOIN updater;      END;    END;      ClientTransition: ToolWindow.TransitionProcType =    BEGIN    Area: TYPE = RECORD[history: History, data: Data];    SELECT TRUE FROM      (old = inactive) =>        BEGIN	area: LONG POINTER TO Area;	length: CARDINAL = (SIZE[Area]+255)/255;	space ¬ Space.Map[window: [File.nullFile, 0, length], class: data]; 	area ¬ space.pointer;	history ¬ DESCRIPTOR[area.history];	data ¬ DESCRIPTOR[area.data];	FOR i: Range IN Range DO history[i] ¬ [0, 0]; data[i] ¬ null; ENDLOOP;	ResetData[];	StopGo[];	END;      (new = inactive) =>        BEGIN	StopGo[];	form ¬ graph ¬ NIL;	Space.Kill[space];	[] ¬ Space.Unmap[space.pointer];	END;      ENDCASE;    END;	  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Worker routines:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	  Updater: ENTRY PROC =    BEGIN    running ¬ TRUE;    Process.SetPriority[Process.priorityBackground];    DO      ENABLE ABORTED => EXIT;      WAIT interval;  --one second      IF graph = NIL THEN LOOP;      FOR index: Range IN Range DO        value: LONG CARDINAL ¬ data[index].value;	data[index].value ¬ 0;        IF value # 0 THEN	  BEGIN	  IF history[index].new = 0 THEN DisplayHost[index];	  history[index].old ¬ history[index].new;	  value ¬ value + scale/2 + 1;	  value ¬ value/LONG[scale];	  history[index].new ¬ history[index].new + Inline.LowHalf[value];	  DisplayBar[index];	  END;	ENDLOOP;      ENDLOOP;    END;    SpyProc: SpecialCommunication.SpyProc =    --PROC[b: Buffer.Buffer] RETURNS[Buffer.Buffer]    BEGIN    index: Range;    dll: IEEE8023.Encapsulation = LOOPHOLE[b.linkLayer.blockPointer];    sa: HostNumber = dll.ethernetSource;    IF oldSpy[b.fo.type] # NIL THEN      {b ¬ oldSpy[b.fo.type][b, function]; IF b = NIL THEN RETURN[b]};    FOR index IN Range DO      SELECT TRUE FROM        sa = data[index].host =>	  {data[index].value ¬ data[index].value + b.fo.driver.length; EXIT};	data[index].host = SpecialSystem.nullProcessorID =>	  {data[index].host ¬ sa; data[index].value ¬ b.fo.driver.length; EXIT};	data[index].host = SpecialSystem.broadcastHostNumber =>	  {data[index].value ¬ data[index].value + b.fo.driver.length; EXIT};	ENDCASE;      ENDLOOP;     SELECT TRUE FROM      (function = send) => RETURN[b];      (dll.ethernetDest = me) => RETURN[b];      (dll.ethernetDest = all) => RETURN[b];      ENDCASE => {Buffer.ReturnBuffer[b]; RETURN[NIL]};    END;      -- Mainline code:    Initialize[];    END.   
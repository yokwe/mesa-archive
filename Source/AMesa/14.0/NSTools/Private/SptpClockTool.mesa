-- File: SptpClockTool.mesa - last edit:-- AOF                 21-Jan-88 15:17:09-- Create by FormSWLayoutTool on 13-Dec-87 14:33-- Copyright (C) 1987, 1988 by Xerox Corporation. All rights reserved.DIRECTORY  Buffer USING [Device],  Driver USING [Device],  Exec USING [AddCommand, ExecProc, Handle, OutputProc, RemoveCommand],  Format USING [LongDecimal, LongNumber, StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, Display,    DisplayItem, FindItem, line0, line1, line2, line3, line4, line5, line6,    line7, line8, line9, LineN, ProcType, StringItem, TagOnlyItem],  Heap USING [Create, Delete],  PhoneNet USING [Initialize],  Process USING [Detach, MsecToTicks, TicksToMsec],  Put USING [Text],  Runtime USING [GlobalFrame, IsBound],  SptpDriver USING [clock, myDevice],  SptpImpl USING [clock],  SptpOps USING [GetDevice, StatsRecord],  String USING [AppendChar, AppendString],  System USING [    GetGreenwichMeanTime, MicrosecondsToPulses, PulsesToMicroseconds],  Time USING [AppendCurrent],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Box, Handle],  WindowFont USING [CharWidth];SptpClockTool: MONITOR  IMPORTS    Exec, Format, FormSW, Heap, PhoneNet, Process, Put, Runtime, SptpOps,    String, System, Time, Tool, WindowFont  EXPORTS Buffer  SHARES SptpDriver, SptpImpl = {  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = <<MACHINE DEPENDENT>> RECORD [    msgSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    giveup: LONG STRING ¬ NIL,  --seconds    shortTmo: LONG STRING ¬ NIL, --ticks    onHook: LONG STRING ¬ NIL,  --ticks    clockCksm: LONG STRING ¬ NIL,  --ticks    idleInput: LONG STRING ¬ NIL,  --pulses    stuckOutput: LONG STRING ¬ NIL,  --pulses    mstrTmo: LONG STRING ¬ NIL,  --pulses    ltaHold: LONG STRING ¬ NIL,  --pulses    cmdTmo: LONG STRING ¬ NIL,  --pulses    cdDelay: LONG STRING ¬ NIL,  --pulses    ctsDelay: LONG STRING ¬ NIL,  --pulses    to1: LONG STRING ¬ NIL,  --pulses    to2: LONG STRING ¬ NIL,  --pulses    to3: LONG STRING ¬ NIL,  --pulses    to4: LONG STRING ¬ NIL,  --pulses    to5: LONG STRING ¬ NIL,  --pulses    to6: LONG STRING ¬ NIL,  --pulses    inputunits: InputUnits ¬ seconds,    inputvalue: LONG STRING ¬ NIL];  FormItems: TYPE = {physical, giveupC, giveup, shortTmoC, shortTmo,    onHookC, onHook, clockCksmC, clockCksm, idleInputC, idleInput,    stuckOutputC, stuckOutput, mstrTmoC, mstrTmo, ltaHoldC, ltaHold,    cmdTmoC, cmdTmo, cdDelayC, cdDelay, ctsDelayC, ctsDelay, datalink,    to1C, to1, to2C, to2, to3C, to3, to4C, to4, to5C, to5, to6C, to6,    scratch, inputvalue, setdefaults, logcurrent, recordstats, comparestats};  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.Create[initial: 4];  InputUnits: TYPE = {seconds, milliseconds, ticks, pulses, display};  driver: LONG POINTER TO FRAME[SptpDriver] ¬ NIL;  impl: LONG POINTER TO FRAME[SptpImpl] ¬ NIL;  original: RECORD[    driver: RECORD[      giveup: CARDINAL,  --seconds      shortTmo, onHook, clockCksm: CARDINAL,  --ticks      idleInput, stuckOutput, mstrTmo, ltaHold, cmdTmo, cdDelay, ctsDelay:        LONG CARDINAL],    impl: RECORD[to1, to2, to3, to4, to5, to6: LONG CARDINAL]];  recordedStats: SptpOps.StatsRecord;  recordTime: LONG CARDINAL;  initialBox: Window.Box = [place: [x:1, y: 29], dims: [w: 512, h: 497]];  busyBit: BOOLEAN ¬ FALSE;  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    ENABLE UNWIND => NULL;    isBusy ¬ busyBit;    busyBit ¬ TRUE };  Done: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    busyBit ¬ FALSE};  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};  ConvertIn: PROC[] RETURNS[msecs: LONG CARDINAL] =    BEGIN    fraction: NATURAL ¬ 3;    point: BOOLEAN ¬ FALSE;    msecs ¬ 0;  --nice starting value    IF data.inputvalue = NIL THEN RETURN;    FOR i: NATURAL IN[0..data.inputvalue.length) DO      c: CHARACTER = data.inputvalue[i];      IF (c = '.) THEN {point ¬ TRUE; LOOP};  --that's the decimal      msecs ¬ msecs * 10 + (c - '0);  --accumulate data      IF point AND (fraction ¬ fraction.PRED) = 0 THEN EXIT;      REPEAT FINISHED =>        THROUGH[0..fraction) DO msecs ¬ 10 * msecs; ENDLOOP;      ENDLOOP;    END;  --ConvertIn  ConvertOut: PROC[msecs: LONG CARDINAL, string: LONG POINTER TO LONG STRING] =    BEGIN    Number: Format.StringProc = {String.AppendString[string­, s]};    IF string­ = NIL THEN string­ ¬ zone.NEW[StringBody[8]];    string­.length ¬ 0;  --always reset the length    Format.LongNumber[Number, msecs / 1D3, []];  --the decimal part    String.AppendChar[string­, '.];  --the decimal point    Format.LongNumber[Number, msecs MOD 1D3, [10, TRUE, TRUE, 3]];    END;  --ConvertOut  ConvertTo: PROC[to: InputUnits] RETURNS[value: LONG CARDINAL] =    BEGIN    RETURN[SELECT to FROM      seconds => ConvertIn[] / 1D3,      milliseconds => ConvertIn[],      ticks => Process.MsecToTicks[CARDINAL[ConvertIn[]]],      pulses => System.MicrosecondsToPulses[ConvertIn[] * 1D3],      ENDCASE => 0];  --no endcase    END;  --ConvertTo  SetDisplay: PROC[] =    BEGIN    ConvertOut[(LONG[original.driver.giveup] * 1D3), @data.giveup];    ConvertOut[Process.TicksToMsec[original.driver.shortTmo], @data.shortTmo];    ConvertOut[Process.TicksToMsec[original.driver.onHook], @data.onHook];    ConvertOut[Process.TicksToMsec[original.driver.clockCksm], @data.clockCksm];    ConvertOut[System.PulsesToMicroseconds[      [(original.driver.idleInput + 500) / 1D3]], @data.idleInput];    ConvertOut[System.PulsesToMicroseconds[      [(original.driver.stuckOutput + 500) / 1D3]], @data.stuckOutput];    ConvertOut[System.PulsesToMicroseconds[      [(original.driver.mstrTmo + 500) / 1D3]], @data.mstrTmo];    ConvertOut[System.PulsesToMicroseconds[      [(original.driver.ltaHold + 500) / 1D3]], @data.ltaHold];    ConvertOut[System.PulsesToMicroseconds[      [(original.driver.cmdTmo + 500) / 1D3]], @data.cmdTmo];    ConvertOut[System.PulsesToMicroseconds[      [(original.driver.cdDelay + 500) / 1D3]], @data.cdDelay];    ConvertOut[System.PulsesToMicroseconds[      [(original.driver.ctsDelay + 500) / 1D3]], @data.ctsDelay];    ConvertOut[System.PulsesToMicroseconds[      [(original.impl.to1 + 500) / 1D3]], @data.to1];    ConvertOut[System.PulsesToMicroseconds[      [(original.impl.to2 + 500) / 1D3]], @data.to2];    ConvertOut[System.PulsesToMicroseconds[      [(original.impl.to3 + 500) / 1D3]], @data.to3];    ConvertOut[System.PulsesToMicroseconds[      [(original.impl.to4 + 500) / 1D3]], @data.to4];    ConvertOut[System.PulsesToMicroseconds[      [(original.impl.to5 + 500) / 1D3]], @data.to5];    ConvertOut[System.PulsesToMicroseconds[      [(original.impl.to6 + 500) / 1D3]], @data.to6];    END;  --SetDisplay  Giveup:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    driver.clock.giveup ¬ CARDINAL[ConvertTo[seconds]];    ConvertOut[(LONG[driver.clock.giveup] * 1D3), @data.giveup];    FormSW.DisplayItem[sw, index.SUCC];    END;  ShortTmo:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    driver.clock.shortTmo ¬ CARDINAL[ConvertTo[ticks]];    ConvertOut[Process.TicksToMsec[driver.clock.shortTmo], @data.shortTmo];    FormSW.DisplayItem[sw, index.SUCC];    END;  OnHook:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    driver.clock.onHook ¬ CARDINAL[ConvertTo[ticks]];    ConvertOut[Process.TicksToMsec[driver.clock.onHook], @data.onHook];    FormSW.DisplayItem[sw, index.SUCC];    END;  ClockCksm:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    driver.clock.clockCksm ¬ CARDINAL[ConvertTo[ticks]];    ConvertOut[Process.TicksToMsec[driver.clock.clockCksm], @data.clockCksm];    FormSW.DisplayItem[sw, index.SUCC];    END;  IdleInput:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    driver.clock.idleInput ¬ ConvertTo[pulses];    ConvertOut[System.PulsesToMicroseconds[      [(driver.clock.idleInput + 500) / 1D3]], @data.idleInput];    FormSW.DisplayItem[sw, index.SUCC];    END;  StuckOutput:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    driver.clock.stuckOutput ¬ ConvertTo[pulses];    ConvertOut[System.PulsesToMicroseconds[      [(driver.clock.stuckOutput + 500) / 1D3]], @data.stuckOutput];    FormSW.DisplayItem[sw, index.SUCC];    END;  MstrTmo:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    driver.clock.mstrTmo ¬ ConvertTo[pulses];    ConvertOut[System.PulsesToMicroseconds[      [(driver.clock.mstrTmo + 500) / 1D3]], @data.mstrTmo];    FormSW.DisplayItem[sw, index.SUCC];    END;  LtaHold:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    driver.clock.ltaHold ¬ ConvertTo[pulses];    ConvertOut[System.PulsesToMicroseconds[      [(driver.clock.ltaHold + 500) / 1D3]], @data.ltaHold];    FormSW.DisplayItem[sw, index.SUCC];    END;  CmdTmo:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    driver.clock.cmdTmo ¬ ConvertTo[pulses];    ConvertOut[System.PulsesToMicroseconds[      [(driver.clock.cmdTmo + 500) / 1D3]], @data.cmdTmo];    FormSW.DisplayItem[sw, index.SUCC];    END;  CdDelay:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    driver.clock.cdDelay ¬ ConvertTo[pulses];    ConvertOut[System.PulsesToMicroseconds[      [(driver.clock.cdDelay + 500) / 1D3]], @data.cdDelay];    FormSW.DisplayItem[sw, index.SUCC];    END;  CtsDelay:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    driver.clock.ctsDelay ¬ ConvertTo[pulses];    ConvertOut[System.PulsesToMicroseconds[      [(driver.clock.ctsDelay + 500) / 1D3]], @data.ctsDelay];    FormSW.DisplayItem[sw, index.SUCC];    END;  To1:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    impl.clock.to1 ¬ ConvertTo[pulses];    ConvertOut[System.PulsesToMicroseconds[      [(impl.clock.to1 + 500) / 1D3]], @data.to1];    FormSW.DisplayItem[sw, index.SUCC];    END;  To2:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    impl.clock.to2 ¬ ConvertTo[pulses];    ConvertOut[System.PulsesToMicroseconds[      [(impl.clock.to2 + 500) / 1D3]], @data.to2];    FormSW.DisplayItem[sw, index.SUCC];    END;  To3:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    impl.clock.to3 ¬ ConvertTo[pulses];    ConvertOut[System.PulsesToMicroseconds[      [(impl.clock.to3 + 500) / 1D3]], @data.to3];    FormSW.DisplayItem[sw, index.SUCC];    END;  To4:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    impl.clock.to4 ¬ ConvertTo[pulses];    ConvertOut[System.PulsesToMicroseconds[      [(impl.clock.to4 + 500) / 1D3]], @data.to4];    FormSW.DisplayItem[sw, index.SUCC];    END;  To5:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    impl.clock.to5 ¬ ConvertTo[pulses];    ConvertOut[System.PulsesToMicroseconds[      [(impl.clock.to5 + 500) / 1D3]], @data.to5];    FormSW.DisplayItem[sw, index.SUCC];    END;  To6:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    impl.clock.to6 ¬ ConvertTo[pulses];    ConvertOut[System.PulsesToMicroseconds[      [(impl.clock.to6 + 500) / 1D3]], @data.to6];    FormSW.DisplayItem[sw, index.SUCC];    END;  Setdefaults:  FormSW.ProcType =    BEGIN    IF Unbound[] THEN RETURN;    driver.clock ¬ [      original.driver.giveup,      original.driver.shortTmo,      original.driver.onHook,      original.driver.clockCksm,      original.driver.idleInput,      original.driver.stuckOutput,      original.driver.mstrTmo,      original.driver.ltaHold,      original.driver.cmdTmo,      original.driver.cdDelay,      original.driver.ctsDelay];    impl.clock ¬ [      original.impl.to1,      original.impl.to2,      original.impl.to3,      original.impl.to4,      original.impl.to5,      original.impl.to6];    SetDisplay[];  --make the display look right    Recordstats[];  --to fill in those slots    FormSW.Display[sw];  --make it pretty again    END;  Logcurrent:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK LogcurrentInternal[]]};  LogcurrentInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    time: LONG STRING ¬ [30];    Write["\nLogging current clock values at "L];    Time.AppendCurrent[time]; Write[time]; Write["\n"L];    FOR i: NATURAL IN[FormItems.giveupC.ORD..FormItems.to6.ORD] DO      WITH it: FormSW.FindItem[data.formSW, i] SELECT FROM        command => {Write[it.tag]; Write[": "L]};        string => {Write[it.string­]; Write["\n"L]};	ENDCASE;      ENDLOOP;    Done[] };  Recordstats:  FormSW.ProcType =    BEGIN    time: LONG STRING ¬ [30];    IF Unbound[] THEN RETURN;    Write["\nRecording statistics at "L];    Time.AppendCurrent[time]; Write[time]; Write["\n"L];    recordedStats ¬ NARROW[driver.myDevice.stats,      LONG POINTER TO SptpOps.StatsRecord]­;  --copy the stats    recordTime ¬ System.GetGreenwichMeanTime[];  --when we did it    END;  --Recordstats  Comparestats:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK ComparestatsInternal[]]};  ComparestatsInternal: PROCEDURE =    BEGIN    ENABLE ABORTED => {Done[]; CONTINUE};    timer: Interval;    time: LONG STRING ¬ [30];    Interval: TYPE = {seconds, minutes, hours};    old: LONG POINTER TO SptpStatsArray ¬ LOOPHOLE[@recordedStats];    elapsed: LONG CARDINAL = System.GetGreenwichMeanTime[] - recordTime;    nstats: NATURAL = SIZE[SptpOps.StatsRecord] / SIZE[LONG CARDINAL];    SptpStatsArray: TYPE = ARRAY NATURAL[0..nstats) OF LONG CARDINAL;    newStats: SptpOps.StatsRecord ¬ NARROW[driver.myDevice.stats,      LONG POINTER TO SptpOps.StatsRecord]­;  --copy current stats    new: POINTER TO SptpStatsArray ¬ LOOPHOLE[@newStats];    interval: ARRAY Interval OF STRING = ["second"L, "minute"L, "hour"L];    label: ARRAY NATURAL[0..nstats) OF STRING = [      "pktsReceived"L, "bytesReceived"L,      "packetsSent"L, "bytesSent"L,      "controlPktReceived"L, "controlPktSent"L,      "sendAborted"L, "receiveAborted"L,      "checksumError"L, "dataLost"L, "deviceError"L,      "disaster"L, "invalidFrame"L,      "protocolDown"L, "protocolUp"L, "masterTmo"L,      "commandInitiated"L, "commandLost"L];    Write["\nComparing statistics at "L];    Time.AppendCurrent[time]; Write[time]; Write["\n"L];    FOR i: NATURAL IN[0..nstats) DO      diff: LONG CARDINAL ¬ new[i] - old[i];      IF diff # 0 THEN        BEGIN	Write[label[i]];	Write[": "L];	Format.LongDecimal[Write, diff];	FOR timer IN Interval UNTIL (diff / elapsed) > 10 DO	  diff ¬ diff * 60; ENDLOOP;	Write[" ("L]; Format.LongDecimal[Write, diff / elapsed];	Write[" / "L]; Write[interval[timer]]; Write[")\n"L];	END;       ENDLOOP;    Done[]    END;  --ComparestatsInternal  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        BEGIN        IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];	original.driver ¬ [	  driver.clock.giveup,	  driver.clock.shortTmo,	  driver.clock.onHook,	  driver.clock.clockCksm,	  driver.clock.idleInput,	  driver.clock.stuckOutput,	  driver.clock.mstrTmo,	  driver.clock.ltaHold,	  driver.clock.cmdTmo,	  driver.clock.cdDelay,	   driver.clock.ctsDelay];        original.impl ¬ [	  impl.clock.to1,	  impl.clock.to2,	  impl.clock.to3,	  impl.clock.to4,	  impl.clock.to5,	  impl.clock.to6];	SetDisplay[];  --and make the display right	END;      new = inactive =>        IF data # NIL THEN {	  zone.FREE[@data]};      ENDCASE;    };  Init: PROCEDURE = {    Exec.AddCommand["SptpClockTool.~"L, NoOp, NIL, Unload];    IF NoOp[NIL, NIL] = abort THEN RETURN WITH ERROR ABORTED};  NoOp: Exec.ExecProc =    BEGIN    IF Unbound[] THEN RETURN[abort];    IF wh = NIL THEN      BEGIN       wh ¬ Tool.Create[	makeSWsProc: MakeSWs, initialState: default, initialBox: initialBox,	clientTransition: ClientTransition, name: "SptpClockTool"L,	cmSection: "SptpClockTool"L];      END;    END;  --NoOp  Unbound: PROC[] RETURNS[BOOLEAN ¬ FALSE] =    BEGIN    device: Device;    IF ~Runtime.IsBound[LOOPHOLE[SptpOps.GetDevice]] THEN GOTO abort;    device ¬ SptpOps.GetDevice[0]; IF device = NIL THEN GOTO abort;    driver ¬ LOOPHOLE[Runtime.GlobalFrame[LOOPHOLE[device.activateDriver]]];    impl ¬ LOOPHOLE[Runtime.GlobalFrame[LOOPHOLE[PhoneNet.Initialize]]];    EXITS abort =>      {IF wh # NIL THEN Msg["\nNo Sptp support found"L]; RETURN[TRUE]};    END;  --Unbound          Unload: Exec.ExecProc = {    IF Busy[] THEN {      Exec.OutputProc[h]["Tool is busy. Sorry.\n"L];      RETURN[error] };    IF wh # NIL THEN Tool.Destroy[wh];    Exec.RemoveCommand[h, "SptpClockTool.~"L];    Heap.Delete[zone];    Done[] };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [20];    Tool.UnusedLogName[unused: logName, root: "SptpClockTool.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: zone];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};  MakeForm: FormSW.ClientItemsProcType = {    nItems: CARDINAL = FormItems.LAST.ORD + 1;    items ¬ FormSW.AllocateItemDescriptor[nItems, zone];    items[FormItems.physical.ORD] ¬ FormSW.TagOnlyItem[      tag: "PHYSICAL"L, place: [CharPos[0], FormSW.line0], z: zone];    items[FormItems.giveupC.ORD] ¬ FormSW.CommandItem[      tag: "giveup"L, place: [CharPos[4], FormSW.line1], proc: Giveup, z: zone];    items[FormItems.giveup.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[12], FormSW.line1], readOnly: TRUE,      boxWidth: 64, string: @data.giveup, z: zone];    items[FormItems.shortTmoC.ORD] ¬ FormSW.CommandItem[      tag: "shortTmo"L, place: [CharPos[35], FormSW.line1],      proc: ShortTmo, z: zone];    items[FormItems.shortTmo.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[45], FormSW.line1], readOnly: TRUE,      boxWidth: 64, string: @data.shortTmo, z: zone];    items[FormItems.onHookC.ORD] ¬ FormSW.CommandItem[      tag: "onHook"L, place: [CharPos[4], FormSW.line2], proc: OnHook, z: zone];    items[FormItems.onHook.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[12], FormSW.line2], readOnly: TRUE,      boxWidth: 64, string: @data.onHook, z: zone];    items[FormItems.clockCksmC.ORD] ¬ FormSW.CommandItem[      tag: "clockCksm"L, place: [CharPos[34], FormSW.line2],      proc: ClockCksm, z: zone];    items[FormItems.clockCksm.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[45], FormSW.line2], readOnly: TRUE,      boxWidth: 64, string: @data.clockCksm, z: zone];    items[FormItems.idleInputC.ORD] ¬ FormSW.CommandItem[      tag: "idleInput"L, place: [CharPos[1], FormSW.line3],      proc: IdleInput, z: zone];    items[FormItems.idleInput.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[12], FormSW.line3], readOnly: TRUE,      boxWidth: 64, string: @data.idleInput, z: zone];    items[FormItems.stuckOutputC.ORD] ¬ FormSW.CommandItem[      tag: "stuckOutput"L, place: [CharPos[32], FormSW.line3],      proc: StuckOutput, z: zone];    items[FormItems.stuckOutput.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[45], FormSW.line3], readOnly: TRUE,      boxWidth: 64, string: @data.stuckOutput, z: zone];    items[FormItems.mstrTmoC.ORD] ¬ FormSW.CommandItem[      tag: "mstrTmo"L, place: [CharPos[3], FormSW.line4],      proc: MstrTmo, z: zone];    items[FormItems.mstrTmo.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[12], FormSW.line4], readOnly: TRUE,      boxWidth: 64, string: @data.mstrTmo, z: zone];    items[FormItems.ltaHoldC.ORD] ¬ FormSW.CommandItem[      tag: "ltaHold"L, place: [CharPos[36], FormSW.line4],      proc: LtaHold, z: zone];    items[FormItems.ltaHold.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[45], FormSW.line4], readOnly: TRUE,      boxWidth: 64, string: @data.ltaHold, z: zone];    items[FormItems.cmdTmoC.ORD] ¬ FormSW.CommandItem[      tag: "cmdTmo"L, place: [CharPos[4], FormSW.line5],      proc: CmdTmo, z: zone];    items[FormItems.cmdTmo.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[12], FormSW.line5], readOnly: TRUE,      boxWidth: 64, string: @data.cmdTmo, z: zone];    items[FormItems.cdDelayC.ORD] ¬ FormSW.CommandItem[      tag: "cdDelay"L, place: [CharPos[36], FormSW.line5],      proc: CdDelay, z: zone];    items[FormItems.cdDelay.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[45], FormSW.line5], readOnly: TRUE,      boxWidth: 64, string: @data.cdDelay, z: zone];    items[FormItems.ctsDelayC.ORD] ¬ FormSW.CommandItem[      tag: "ctsDelay"L, place: [CharPos[2], FormSW.line6],      proc: CtsDelay, z: zone];    items[FormItems.ctsDelay.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[12], FormSW.line6], readOnly: TRUE,      boxWidth: 64, string: @data.ctsDelay, z: zone];    items[FormItems.datalink.ORD] ¬ FormSW.TagOnlyItem[      tag: "DATA LINK"L, place: [CharPos[0], FormSW.line7], z: zone];    items[FormItems.to1C.ORD] ¬ FormSW.CommandItem[      tag: "to1"L, place: [CharPos[7], FormSW.line8], proc: To1, z: zone];    items[FormItems.to1.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[12], FormSW.line8], readOnly: TRUE,      boxWidth: 64, string: @data.to1, z: zone];    items[FormItems.to2C.ORD] ¬ FormSW.CommandItem[      tag: "to2"L, place: [CharPos[40], FormSW.line8], proc: To2, z: zone];    items[FormItems.to2.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[45], FormSW.line8], boxWidth: 64,      string: @data.to2, z: zone];    items[FormItems.to3C.ORD] ¬ FormSW.CommandItem[      tag: "to3"L, place: [CharPos[7], FormSW.line9], proc: To3, z: zone];    items[FormItems.to3.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[12], FormSW.line9], readOnly: TRUE,      boxWidth: 64, string: @data.to3, z: zone];    items[FormItems.to4C.ORD] ¬ FormSW.CommandItem[      tag: "to4"L, place: [CharPos[40], FormSW.line9], proc: To4, z: zone];    items[FormItems.to4.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[45], FormSW.line9], readOnly: TRUE,      boxWidth: 64, string: @data.to4, z: zone];    items[FormItems.to5C.ORD] ¬ FormSW.CommandItem[      tag: "to5"L, place: [CharPos[7], FormSW.LineN[10]], proc: To5, z: zone];    items[FormItems.to5.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[12], FormSW.LineN[10]], readOnly: TRUE,      boxWidth: 64, string: @data.to5, z: zone];    items[FormItems.to6C.ORD] ¬ FormSW.CommandItem[      tag: "to6"L, place: [CharPos[40], FormSW.LineN[10]], proc: To6, z: zone];    items[FormItems.to6.ORD] ¬ FormSW.StringItem[      tag: ":"L, place: [CharPos[45], FormSW.LineN[10]], readOnly: TRUE,      boxWidth: 64, string: @data.to6, z: zone];    items[FormItems.scratch.ORD] ¬ FormSW.TagOnlyItem[      tag: "SCRATCH"L, place: [CharPos[0], FormSW.LineN[11]], z: zone];    items[FormItems.inputvalue.ORD] ¬ FormSW.StringItem[      tag: "input value"L, place: [CharPos[2], FormSW.LineN[12]],      inHeap: TRUE, boxWidth: 64, string: @data.inputvalue, z: zone];    items[FormItems.setdefaults.ORD] ¬ FormSW.CommandItem[      tag: "Set defaults"L, place: [CharPos[2], FormSW.LineN[13]],      proc: Setdefaults, z: zone];    items[FormItems.logcurrent.ORD] ¬ FormSW.CommandItem[      tag: "Log current"L, place: [CharPos[19], FormSW.LineN[13]],      proc: Logcurrent, z: zone];    items[FormItems.recordstats.ORD] ¬ FormSW.CommandItem[      tag: "Record stats"L, place: [CharPos[35], FormSW.LineN[13]],      proc: Recordstats, z: zone];    items[FormItems.comparestats.ORD] ¬ FormSW.CommandItem[      tag: "Compare stats"L, place: [CharPos[53], FormSW.LineN[13]],      proc: Comparestats, z: zone];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
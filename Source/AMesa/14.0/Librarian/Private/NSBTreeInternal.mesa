--  File: NSBTreeInternal.mesa; last edited by: --  PXK    ,	 21-Mar-84 10:19:31--  BJD    ,	  4-Sep-84 16:33:46DIRECTORY  NSBTree USING [defaultValueSize, maxNameLength, Value, ValueSize],  Environment USING [PageCount, wordsPerPage],  File USING [File, nullFile],  NSFile USING [Handle, nullHandle, nullSession, Session],  Space USING [Interval, nullInterval, Usage];NSBTreeInternal: DEFINITIONS =  BEGIN  Tree: TYPE = LONG POINTER TO TreeObject;    TreeObject: PUBLIC TYPE = MONITORED RECORD [    base: PageHandle _ NIL,    top: PagePointer _ nilPagePointer,    size: Environment.PageCount _ treeIncrement,  -- in pages    lpSize: CARDINAL _ 0,  -- in pages    file: NSFile.Handle _ NSFile.nullHandle,  -- NSFile handle of tree    session: NSFile.Session ¬ NSFile.nullSession,  -- NSFile session of the file    cap: File.File _ File.nullFile,  -- cap. where BTree is stored    space: Space.Interval _ Space.nullInterval,  -- space BTree is mapped to    spaceReadOnly: BOOLEAN _ FALSE, -- the above space is read only    usage: Space.Usage,    pCache: PCache _ NIL,  -- pointer to cached info on enumeration    valueSize: NSBTree.ValueSize _ NSBTree.defaultValueSize,  -- size of value in tree    autoForceOut: BOOLEAN _ TRUE];  -- force out after modification  bTreePage: CARDINAL = 2;  -- number of disk pages in a b-tree page  -- if you change this, check the size of  -- the field Page.size  maxTreeSize: CARDINAL = 512;  -- (disk pages)  treeIncrement: CARDINAL = 8;  -- (b-tree pages)  -- Cached information on b-tree enumeration  PCache: TYPE = LONG POINTER TO Cache;  Cache: TYPE = RECORD [    lastName: StringBody _ [length: 0, maxlength: NSBTree.maxNameLength, text:],    array: PACKED ARRAY [0..NSBTree.maxNameLength) OF CHARACTER _ ALL[' ],    lastpP: PagePointer _ nilPagePointer,    lastpE: EntryHandle _ NIL];  PageHandle: TYPE = LONG BASE POINTER TO Page;  PagePointer: TYPE = PageHandle RELATIVE LONG POINTER TO Page;  nilPagePointer: PagePointer = LOOPHOLE[377777B];  firstPagePointer: PagePointer = LOOPHOLE[LONG[0]];  Page: TYPE = MACHINE DEPENDENT RECORD [    size(0:0..9): [0..512],  -- number of words used in this page    free(0:10..10): BOOLEAN,  -- TRUE if page is not in use    sizeValue(0:11..15): [0..32),  -- first page only - zero means default    top(1): PagePointer,  -- first page only - points to the root     parent(3): PagePointer,  -- the parent of this page    lastPointer(5): PagePointer,  -- the last pointer in this page    entries(emptySize:0..(bTreePage*Environment.wordsPerPage - emptySize)*16 - 1):      ARRAY [0..bTreePage*Environment.wordsPerPage - emptySize) OF UNSPECIFIED];  -- the entries  EntryHandle: TYPE = LONG POINTER TO Entry;  Entry: TYPE = UNSPECIFIED;    ValuePointer: TYPE = LONG POINTER TO ARRAY OF CARDINAL;  --Entry: TYPE = MACHINE DEPENDENT RECORD [  --  value: ARRAY [0.. tree.sizeValue) OF CARDINAL,  --  pointer: PagePointer,  --  name: StringBody _ [length: 0, maxlength: NSBTree.maxNameLength, text:]];  EntryName: PROCEDURE [tree: Tree, entry: EntryHandle]    RETURNS [LONG STRING] = INLINE {    RETURN[LOOPHOLE[entry + tree.valueSize + SIZE[PagePointer]]]};  EntryPointer: PROCEDURE [tree: Tree, entry: EntryHandle]    RETURNS [PagePointer] = INLINE {    RETURN[LOOPHOLE[entry + tree.valueSize, LONG POINTER TO PagePointer]^]};      EntryPointerPointer: PROCEDURE [tree: Tree, entry: EntryHandle]    RETURNS [LONG POINTER TO PagePointer] = INLINE {    RETURN[LOOPHOLE[entry + tree.valueSize]]};      EntrySize: PROCEDURE [tree: Tree, p: EntryHandle] RETURNS [CARDINAL] = INLINE {    -- returns the size of an entry    RETURN[Overhead[tree] + SIZE[StringBody[EntryName[tree, p].length]]]};          EntryValue: PROCEDURE [tree: Tree, entry: EntryHandle]    RETURNS [ValuePointer] = INLINE {RETURN[LOOPHOLE[entry]]};      FirstEntry: PROCEDURE [d: PageHandle] RETURNS [EntryHandle] =    -- return pointer to first entry of this page    INLINE {RETURN[LOOPHOLE[@d.entries]]};      FirstFreeEntry: PROCEDURE [d: PageHandle] RETURNS [EntryHandle] =    -- return pointer to first free entry of this page    INLINE {RETURN[LOOPHOLE[d + d.size]]};      NextEntry: PROCEDURE [tree: Tree, p: EntryHandle]    RETURNS [EntryHandle] = INLINE {    -- return pointer to next entry in this page    RETURN[p + Overhead[tree] + SIZE[StringBody[EntryName[tree, p].length]]]};       Overhead: PROCEDURE [tree: Tree] RETURNS [CARDINAL] =    -- returns the overhead size of an entry    INLINE {RETURN[tree.valueSize + SIZE[PagePointer]]};      emptySize: CARDINAL = 7;  -- the size of an empty page    -- internal procedures and variables used by BTree implementation    CheckVolumeAccess: PROCEDURE [tree: Tree];  CopyValue: PROCEDURE [    to: NSBTree.Value, from: ValuePointer, size: NSBTree.ValueSize]    RETURNS [targetTooSmall: BOOLEAN];  debug: READONLY BOOLEAN;  FlushGNCache: PROCEDURE [tree: Tree];  heap: READONLY UNCOUNTED ZONE;  InsertInNode: PROCEDURE [    tree: Tree, p: PagePointer, n: LONG STRING, c: ValuePointer,    after: PagePointer] RETURNS [ok, noRoom: BOOLEAN, ent: EntryHandle];  InternalFind: PROCEDURE [tree: Tree, name: LONG STRING]    RETURNS [      ok: BOOLEAN, value: ValuePointer, page: PagePointer, ent: EntryHandle];  InternalValidateBTree: PROCEDURE [tree: Tree];  LastEntry: PROCEDURE [tree: Tree, d: PageHandle] RETURNS [p: EntryHandle];  MapInternal: PROCEDURE [tree: Tree];  MoveLongString: PROCEDURE [to, from: LONG STRING];  SnapShot: PROCEDURE [tree: Tree];  Successor: PROCEDURE [    tree: Tree, p: PagePointer, pE: EntryHandle] RETURNS [pg, after: PagePointer];    END.
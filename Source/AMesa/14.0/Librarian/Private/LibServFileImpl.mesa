-- File: LibServFileImpl.mesa - last edit:-- bjd                 24-Feb-88 14:37:18-- PLK    	10-Apr-84 15:40:31-- DJW  	21-Nov-84 10:05:58-- Copyright (C) 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved.DIRECTORY  CH, Environment, File, Inline, LibBackup, LibMessages, LibOps, LibServOps, NSExec, NSFile, NSFileStream, NSName, NSSegment, NSSegmentInternal, NSString, Process, Space, SpecialNSFile, Stream, String, Time, XLibrarian, XStringHashTable, Volume;LibServFileImpl: PROGRAM  IMPORTS    Inline, LibBackup, LibMessages, LibServOps, NSExec, NSFile, NSFileStream, NSName, NSSegment, NSSegmentInternal, NSString, Process, Space, SpecialNSFile, Stream, String, XLibrarian, XStringHashTable, Volume   EXPORTS XLibrarian, LibServOps =  BEGIN      Service: TYPE = LONG POINTER TO ServiceObject;  ServiceObject: PUBLIC TYPE = LibServOps.ServiceObject;  DataBaseEntry: PUBLIC TYPE = LibServOps.DataBaseEntry;    PropertyList: TYPE = LONG POINTER TO PropertyListObject;  PropertyListObject: PUBLIC TYPE = LibOps.PropertyListObject;  gf: LONG POINTER TO LibServOps.GlobalFrame = @LibServOps.gf;  dirName: NSString.String = S["LibrarianFiles"L];    Header: TYPE = LONG POINTER TO LibServOps.HeaderObject;  AlreadyExists: ERROR = CODE;  Atom: PUBLIC TYPE = LibServOps.Atom;  nullAtom: Atom = XLibrarian.nullAtom;    initialLibjectPages: NATURAL = 20;  fileNameLength: NATURAL = CH.maxLocalNameLength + 30;    DataBase: TYPE = LibServOps.DataBase;  FreeSizes: TYPE = LibServOps.FreeSizes;  Run: TYPE = LibServOps.Run;    bpp: NATURAL = Environment.bytesPerPage;  wpp: NATURAL = Environment.wordsPerPage;  bpw: NATURAL = Environment.bytesPerWord;  initialHashTableSize: NATURAL = 10;  initialRecordFileSize: NATURAL = 20;    freeSizes: ARRAY FreeSizes OF NATURAL = [     one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7,     eight: 8, nine: 9, ten: 10, fifteen: 15, twenty: 20, thirty: 30,     forty: 40, fifty: 50, sixty: 60, seventy: 70, eighty: 80, ninety: 90,     oneHundred: 100, oneTwentyFive: 125, oneFifty: 150,     oneSeventyFive: 175, twoHundred: 200, twoFifty: 200];  growMinExtra: NATURAL = 50;    recordExt: NSString.String = S["Records"L];  hashTableExt: NSString.String = S["HashTable"L];  logExt: NSString.String = S["Log"L];  -- All procedures in this module which manipulate critical data are assumed to be executed under the global monitor controlled by MonitorOperation in LibServImpl.      GetTheBackup: ERROR = CODE;  AllocateRun: PUBLIC PROC [h: DataBase, length: CARDINAL]    RETURNS [run: Run] =    BEGIN    freeSize: FreeSizes;    index: LibServOps.Index;    IsDirty[h];    h.dirtyFreePages ¬ TRUE;    FOR f: FreeSizes IN FreeSizes DO      IF length <= freeSizes[f] THEN {freeSize ¬ f; EXIT};      REPEAT FINISHED => ERROR XLibrarian.Error[implementationBug];      ENDLOOP;    index ¬ h.freePages.freeLists[freeSize];    run.length ¬ freeSizes[freeSize]; -- get at right granularity    SELECT TRUE FROM      index # LibServOps.nullIndex => {        run.start ¬ h.freePages.cells[index].start;	h.freePages.freeLists[freeSize] ¬ h.freePages.cells[index].next;	h.freePages.cells[index].next ¬ h.freePages.freeCell;	h.freePages.freeCell ¬ index};      h.freePages.tail.length >= run.length => {        left: NATURAL = h.freePages.tail.length - run.length;	run.start ¬ h.freePages.tail.start;	h.freePages.tail ¬ [run.start + run.length, left]}      ENDCASE => {	growAmount: NATURAL = MAX[growMinExtra + run.length, 50];	left: NATURAL = growAmount + h.freePages.tail.length - run.length;	h.header.fileLength ¬ h.header.fileLength + growAmount;	SetLength[h.recordFile, h.header.fileLength];	h.header.freePages.start ¬ h.header.freePages.start + growAmount;	run.start ¬ h.freePages.tail.start;	h.freePages.tail ¬ [run.start + run.length, left]}    END;      SetFreePagesMaxLength: PROC [    freePages: LONG POINTER TO LibServOps.FreePagesObject,    pagesAvailable: NATURAL] = {    Kludge: TYPE = POINTER TO LibServOps.FreePagesObject;    offset: NATURAL = LOOPHOLE[@Kludge.NIL.allCells];    maxHandle: LONG POINTER TO ARRAY CARDINAL OF CARDINAL = LOOPHOLE[freePages];    newMaxLength: CARDINAL =      ((pagesAvailable*wpp) - SIZE[LibServOps.FreePagesObject[0]]) /      SIZE[LibServOps.FreeElement];    maxHandle[offset] ¬ newMaxLength};    FreeRun: PUBLIC PROC [h: DataBase, run: Run] =    BEGIN    index: LibServOps.Index;    freeSize: FreeSizes;    IsDirty[h];    h.dirtyFreePages ¬ TRUE;    FOR f: FreeSizes IN FreeSizes DO      IF run.length = freeSizes[f] THEN {freeSize ¬ f; EXIT};      REPEAT FINISHED => ERROR XLibrarian.Error[implementationBug];      ENDLOOP;    IF (index ¬ h.freePages.freeCell) # LibServOps.nullIndex THEN {      h.freePages.freeCell ¬ h.freePages.cells[index].next;      h.freePages.cells[index] ¬ [run.start, h.freePages.freeLists[freeSize]];      h.freePages.freeLists[freeSize] ¬ index;      RETURN};    IF h.freePages.activeCells >= h.freePages.allCells THEN { -- grow the file      newPages: NATURAL = h.header.freePages.length + 1;      newFreePages: LONG POINTER TO LibServOps.FreePagesObject =         GetSpace[newPages];      h.header.freePages.length ¬ newPages;      h.header.fileLength ¬ h.header.fileLength + 1;      SetLength[h.recordFile, h.header.fileLength];      Inline.LongCOPY[	from: h.freePages,	to: newFreePages,	nwords: SIZE[LibServOps.FreePagesObject[h.freePages.allCells]]];      FreeSpace[h.freePages];      SetFreePagesMaxLength[newFreePages, newPages];      h.freePages ¬ newFreePages};    index ¬ h.freePages.activeCells;    h.freePages.activeCells ¬ h.freePages.activeCells + 1;    h.freePages.cells[index] ¬ [run.start, h.freePages.freeLists[freeSize]];    h.freePages.freeLists[freeSize] ¬ index;    END;    -- starting and stopping  StartDataBase: PUBLIC PROCEDURE [i: NATURAL] =    BEGIN  -- client has to be prepared to check that Start succeeded    LoadDataBase[i ! GetTheBackup => {      -- for now, administrator must explicitly start the recovery;      -- Process.Detach[FORK LibBackup.Recover...[...];      -- the recover called here would have to be already under the monitor;       message: NSString.String ¬ LibMessages.ExpandMsg[        gf.z, LibMessages.M[keyDatabaseNeedsRecovery], gf.dataBases[i].nameRoot];      LibMessages.NoteEvent[message];      NSString.FreeString[gf.z, message];      CONTINUE}];    END;  LoadDataBase: PUBLIC PROCEDURE [i: NATURAL] =    BEGIN    -- think about monitoring this for automatic recovery    BadFile: PROC = {ERROR GetTheBackup};    Cleanup: PROC = {      h: DataBase = gf.dataBases[i].h;      IF h # NIL THEN {        IF h.header # NIL THEN FreeSpace[h.header];	IF h.libject # NIL THEN FreeSpace[h.libject];	IF h.scratchLibject # NIL THEN FreeSpace[h.scratchLibject];	IF h.recordFile # NSFile.nullHandle THEN CloseFile[h.recordFile];	IF h.hashTableFile # NSFile.nullHandle THEN CloseFile[h.hashTableFile];	IF h.hashTable # NIL THEN XStringHashTable.Delete[h.hashTable];	IF h.log # NIL THEN h.log.Delete[];	gf.z.FREE[@gf.dataBases[i].h]};      };    BEGIN ENABLE UNWIND => Cleanup[];    chName: NSString.String;    rootName: NSString.String = gf.dataBases[i].nameRoot;    logFile: NSFile.Handle;    block: Environment.Block;    names: CARDINAL ¬ 0;    h: DataBase;    IF LibServOps.TracingOn[] THEN {      message: NSString.String ¬ LibMessages.ExpandMsg[        gf.z, LibMessages.M[keyLoadingDatabase], gf.dataBases[i].nameRoot];      LibMessages.NoteEvent[message];      NSString.FreeString[gf.z, message]};    gf.dataBases[i].h ¬ h ¬ gf.z.NEW[LibServOps.DataBaseObject ¬ [      index: i,      header: GetSpace[1],      libjectPages: initialLibjectPages,      scratchLibjectPages: initialLibjectPages,      libject: NIL,  -- don't allocate before we know it is ok      scratchLibject: NIL,      recordFile: OpenFile[rootName, recordExt] ]];    [h.pilotFile, h.lpSize] ¬ NSSegmentInternal.GetID[      file: h.recordFile, session: gf.fileSession];  -- get the header page in and ready the rest of the data structures    Read[h, LibServOps.headerRun, h.header];  -- copy the backup path before reporting "need recovery", so recover knows where to look;    chName ¬ [      bytes: LOOPHOLE[@h.header.backupPath.bytes],      length: h.header.backupPath.length,      maxlength: h.header.backupPath.length];    gf.dataBases[i].backupPath ¬ NSString.CopyString[gf.z, chName];    gf.dataBases[i].backupVersionsToKeep ¬ h.header.backupVersionsToKeep;    IF h.header.dirty THEN BadFile[];    IF h.header.version # LibServOps.thisVersion THEN BadFile[];    h.libject ¬ GetSpace[initialLibjectPages, 4];    h.scratchLibject ¬ GetSpace[initialLibjectPages, 4];    chName ¬ [      bytes: LOOPHOLE[@h.header.readers.bytes],      length: h.header.readers.length,      maxlength: h.header.readers.length];    IF chName.length > 0 THEN h.readers ¬ NSName.NameFromString[gf.z, chName];    chName ¬ [      bytes: LOOPHOLE[@h.header.writers.bytes],      length: h.header.writers.length,      maxlength: h.header.writers.length];    IF chName.length > 0 THEN h.writers ¬ NSName.NameFromString[gf.z, chName];  -- now the hashTable    h.hashTableFile ¬ OpenFile[rootName, hashTableExt];    h.hashTable ¬ XStringHashTable.Make[      file: h.hashTableFile, session: gf.fileSession,      reset: FALSE, valueSize: SIZE[LibServOps.RecordPlace] !        XStringHashTable.NoRoom => ERROR NSFile.Error[[space[mediumFull]]]];  -- now the log file    logFile ¬ OpenOrCreateFile[rootName, logExt];    h.log ¬ NSFileStream.Create[file: logFile, session: gf.fileSession];    h.names ¬ GetSpace[h.header.names.length];    Read[h, h.header.names, h.names];    h.freePages ¬ GetSpace[h.header.freePages.length];    Read[h, h.header.freePages, h.freePages];  -- now initialize the names    block ¬ [      blockPointer: LOOPHOLE[@h.names.bytes],      startIndex: 0,      stopIndexPlusOne: TRASH];    WHILE block.startIndex < h.names.freeByte DO      name: Atom;      length: NATURAL;      name ¬ [	block.blockPointer[block.startIndex]*256 +	block.blockPointer[block.startIndex+1]];      length ¬ block.blockPointer[block.startIndex+2];      block.startIndex ¬ block.startIndex+3;      block.stopIndexPlusOne ¬ block.startIndex + length;      LibServOps.EnterAtom[h, name, block];      names ¬ names + 1;      block.startIndex ¬ block.stopIndexPlusOne;      ENDLOOP;<<    IF names # h.names.count OR block.startIndex # h.names.freeByte THEN	ERROR GetTheBackup;>>      END;      END;  StartFiles: PUBLIC PROCEDURE = {    strings: LibServOps.Strings ¬ NIL;    gf.fileSession ¬ NSFile.Logon[gf.serverId];    SpecialNSFile.EnablePrivileges[gf.fileSession]; -- else can't open sys dir.    InitLibDirectory[];    strings ¬ GetDataBases[];    gf.dataBases ¬ gf.z.NEW[LibServOps.DataBaseSequence[strings.length]];    FOR i: NATURAL IN [0..strings.length) DO      OPEN db: gf.dataBases[i];      Process.InitializeMonitor[@db.LOCK];  -- see comment below in CreateDataBase;        Process.InitializeCondition[@db.tilUnlocked, 0];      Process.DisableTimeout[@db.tilUnlocked];        Process.EnableAborts[@db.tilUnlocked];        db.h ¬ NIL;      db.recoveryInProgress ¬ db.backupInProgress ¬ FALSE;      db.status ¬ open;      db.nReaders ¬ 0;      db.backupPath ¬ NSString.nullString;  -- these will be cached here later;      db.backupVersionsToKeep ¬ LAST[CARDINAL];      db.nameRoot ¬ strings[i];      ENDLOOP;    gf.z.FREE[@strings];    LibBackup.StartBackupProcess[]};  StopFiles: PUBLIC PROCEDURE =    BEGIN    LibBackup.StopBackupProcess[];    FOR i: NATURAL IN [0..gf.dataBases.length) DO      OPEN db: gf.dataBases[i];      NSString.FreeString[gf.z,  db.nameRoot];      IF db.backupPath # NSString.nullString THEN         NSString.FreeString[gf.z, db.backupPath];      UnloadDataBase[i];      ENDLOOP;    gf.z.FREE[@gf.dataBases];    CloseFile[gf.libDir];    NSFile.Logoff[gf.fileSession]; -- closes all files within fileSession    gf.fileSession ¬ NSFile.nullSession;    END;    UnloadDataBase: PUBLIC PROCEDURE [i: NATURAL] =    BEGIN    h: DataBase = gf.dataBases[i].h;    IF h # NIL THEN {      MakeClean[h];      FreeSpace[h.header];      FreeSpace[h.names];      FreeSpace[h.freePages];      FreeSpace[h.libject];      FreeSpace[h.scratchLibject];      LibServOps.FreeAtoms[h];      IF h.readers#NIL THEN NSName.FreeName[gf.z, h.readers];      IF h.writers#NIL THEN NSName.FreeName[gf.z, h.writers];      XStringHashTable.Delete[h.hashTable];      CloseFile[h.recordFile];      CloseFile[h.hashTableFile];      h.log.Delete[];      InvalidateHandles[h];      gf.z.FREE[@gf.dataBases[i].h]};    END;  InvalidateHandles: PROCEDURE [h: DataBase] = {  -- invalidate any sessions open to this database;    proc: LibServOps.EnumHandlesProc = {    -- PROC [serv: Service] RETURNS [continue: BOOLEAN ¬ TRUE]      IF serv.allocated AND serv.h = h THEN serv.uid ¬ 0};    LibServOps.EnumerateHandles[enumProc: proc]};  RenameDataBase: PUBLIC PROCEDURE [    fromRoot, toRoot: NSString.String,    fromExt, toExt: NSString.String ¬ NSString.nullString]    RETURNS [ok: BOOLEAN ¬ TRUE] = {    ENABLE NSFile.Error => {      IF error = [access[problem:fileNotFound]] THEN ok ¬ TRUE ELSE ok ¬ FALSE;      GOTO return};    a: ARRAY [0..1) OF NSFile.Attribute;    fh: NSFile.Handle;    toString: LONG STRING = [NSFile.maxStringLength];    fTemp: LONG STRING = [fileNameLength];    tTemp: LONG STRING = [fileNameLength];    fExt: NSString.String ¬ S[fTemp];    tExt: NSString.String ¬ S[fTemp];    fExt ¬ NSString.AppendString[to: fExt, from: recordExt];     fExt ¬ NSString.AppendString[to: fExt, from: fromExt];     tExt ¬ NSString.AppendString[to: tExt, from: recordExt];     tExt ¬ NSString.AppendString[to: tExt, from: toExt];    -- fExt has the form .Records<fromExt> tExt the form .Records<toExt>         a ¬ [ [name[FileName[S[toString], toRoot, tExt]]] ];    fh ¬ OpenFile[root: fromRoot, ext: fExt];    NSFile.ChangeAttributes[      file: fh, attributes: DESCRIPTOR[a], session: gf.fileSession];    CloseFile[fh];        fExt.length ¬ tExt.length ¬ 0;    fExt ¬ NSString.AppendString[to: fExt, from: hashTableExt];     fExt ¬ NSString.AppendString[to: fExt, from: fromExt];     tExt ¬ NSString.AppendString[to: tExt, from: hashTableExt];     tExt ¬ NSString.AppendString[to: tExt, from: toExt];    -- fExt has the form .HashTable<fromExt> tExt the form .HashTable<toExt>     a ¬ [ [name[FileName[S[toString], toRoot, tExt]]] ];    fh ¬ OpenFile[root: fromRoot, ext: fExt];    NSFile.ChangeAttributes[      file: fh, attributes: DESCRIPTOR[a], session: gf.fileSession];    CloseFile[fh];    EXITS      return => NULL};  DestroyDataBase: PUBLIC PROCEDURE [database: NSString.String]    RETURNS [filesDeleted: NATURAL ¬ 0] = {    t: LONG STRING = [NSFile.maxStringLength];    scope: NSFile.Scope;    NSString.AppendToMesaString[t, database];    String.AppendString[t, ".*"L];    scope ¬ [filter: [matches[attribute: [name[S[t]]]]]];    DO      file: NSFile.Handle = NSFile.Find[        directory: gf.defaultLibDir, scope: scope !        NSFile.Error => GOTO noMore];      NSFile.Delete[file];      filesDeleted ¬ filesDeleted + 1;      REPEAT noMore => NULL;      ENDLOOP};  DeleteDataBaseFiles: PUBLIC PROCEDURE [    root: NSString.String, ext: NSString.String ¬ NSString.nullString]    RETURNS [ok: BOOLEAN ¬ TRUE] = {    -- this could certainly be merged with DestroyDataBase; but presently it only deals with .recordExt and .hashTableExt files (i.e., not log file);    file: NSFile.Handle;    temp: LONG STRING = [fileNameLength];    newExt: NSString.String ¬ S[temp];    newExt ¬ NSString.AppendString[to: newExt, from: recordExt];    newExt ¬ NSString.AppendString[to: newExt, from: ext];    -- pattern has form: <root>.*<ext>    file ¬ OpenFile[root: root, ext: newExt !        NSFile.Error => {file ¬ NSFile.nullHandle; CONTINUE}];    IF file # NSFile.nullHandle THEN DeleteFile[file !      NSFile.Error => {        ok ¬ FALSE; CloseFile[file]; file ¬ NSFile.nullHandle; CONTINUE}];    newExt.length ¬ 0;    newExt ¬ NSString.AppendString[to: newExt, from: hashTableExt];    newExt ¬ NSString.AppendString[to: newExt, from: ext];    file ¬ OpenFile[root: root, ext: newExt !      NSFile.Error => {file ¬ NSFile.nullHandle; CONTINUE}];    IF file # NSFile.nullHandle THEN DeleteFile[file !      NSFile.Error => {        ok ¬ FALSE; CloseFile[file]; file ¬ NSFile.nullHandle; CONTINUE}]};  CreateDataBase: PUBLIC PROCEDURE [database: NSString.String]    RETURNS [BOOLEAN] =    BEGIN    -- this proc must be monitored with the global monitor, because of the sequence copy at the end;    -- initial runs    --     header:	[0..1)    --     names:	[1..2)    --     free:	[2..19)  (initialLibjectPages = 20)    --     freePages:	[19..20)    headerRun: Run = LibServOps.headerRun;    nameRun: Run = [1, 1];    freePagesRun: Run = [initialLibjectPages - 1, 1];    changeTime: LONG STRING = "ChangeTime"L;    checkOutUser: LONG STRING = "CheckOutUser"L;    h: LibServOps.DataBaseObject; -- holds record file because of calls on Write    scratch: LONG POINTER;    header: LONG POINTER TO LibServOps.HeaderObject;    freePages: LONG POINTER TO LibServOps.FreePagesObject;    names: LONG POINTER TO LibServOps.AtomsObject;    h.recordFile ¬ CreateFile[database, recordExt !      AlreadyExists => GOTO alreadyExists];    h.hashTableFile ¬ CreateFile[database, hashTableExt !      AlreadyExists => GOTO alreadyExists];    [h.pilotFile, h.lpSize] ¬ NSSegmentInternal.GetID[      file: h.recordFile, session: gf.fileSession];  -- initialize the records file    SetLength[h.recordFile, initialRecordFileSize];    scratch ¬ GetSpace[1];  -- uses same scratch space 3 times    header ¬ scratch;    header­ ¬ [      freePages: [initialRecordFileSize - 1, 1],      names: [1, 1],      fileLength: initialRecordFileSize,      records: 0,      lastChange: LibServOps.Now[],      dirty: FALSE,      version: LibServOps.thisVersion,      minAuthentication: strong,  -- default to strong      backupVersionsToKeep: LibBackup.defaultVersionsToKeep];    Write[@h, headerRun, header];    names ¬ scratch;    names.count ¬ 2;    names.freeByte ¬ changeTime.length + 2 + 1 + checkOutUser.length + 2 + 1;    names.bytes[0] ¬ Inline.HighByte[LibServOps.changeTime];    names.bytes[1] ¬ Inline.LowByte[LibServOps.changeTime];    names.bytes[2] ¬ changeTime.length;    FOR i: NATURAL IN [0..changeTime.length) DO      names.bytes[i+3] ¬ changeTime[i].ORD;      ENDLOOP;    names.bytes[changeTime.length+3] ¬ Inline.HighByte[LibServOps.checkOutUser];    names.bytes[changeTime.length+4] ¬ Inline.LowByte[LibServOps.checkOutUser];    names.bytes[changeTime.length+5] ¬ checkOutUser.length;    FOR i: NATURAL IN [0..checkOutUser.length) DO      names.bytes[i+changeTime.length+6] ¬ checkOutUser[i].ORD;      ENDLOOP;    Write[@h, nameRun, names];    freePages ¬ scratch;    freePages.freeLists ¬ ALL[LibServOps.nullIndex];    freePages.freeCell ¬ LibServOps.nullIndex;    freePages.activeCells ¬ 0;    freePages.tail ¬ [      start: nameRun.start + nameRun.length,      length: initialRecordFileSize -	(CARDINAL[nameRun.start] + nameRun.length) - freePagesRun.length];    SetFreePagesMaxLength[freePages, 1];    Write[@h, freePagesRun, freePages];    CloseFile[h.recordFile];    FreeSpace[scratch];  -- initialize the HashTable    SetLength[h.hashTableFile, initialHashTableSize];    h.hashTable ¬ XStringHashTable.Make[      file: h.hashTableFile, session: gf.fileSession,      reset: TRUE, valueSize: SIZE[LibServOps.RecordPlace] !        XStringHashTable.NoRoom => ERROR NSFile.Error[[space[mediumFull]]]];    XStringHashTable.Delete[h.hashTable];    h.hashTable ¬ NIL;    CloseFile[h.hashTableFile];  -- make this one generally available;  this is the sleazy part;  use LongCOPY to copy the sequence of records;  for this reason, this proc must be called within the MonitorGF, so it can free the old sequence before advertising the new one;  (e.g., notifying a condition having some copy laying around could be tragic!)    IF LibServOps.StatusEqualTo[started] THEN {      seqSizeInWords: CARDINAL =        SIZE[LibServOps.DataBaseEntryObject]*gf.dataBases.length;      -- assume only one create at a time, so reading length here is okay;      oldDataBases: LONG POINTER TO LibServOps.DataBaseSequence ¬ gf.dataBases;      newDataBases: LONG POINTER TO LibServOps.DataBaseSequence =        gf.z.NEW[LibServOps.DataBaseSequence[oldDataBases.length + 1]];      db: LibServOps.DataBaseEntry ¬ @newDataBases[oldDataBases.length]; -- new      growDBSeq: PROC = {        gf.dataBases ¬ newDataBases;	gf.z.FREE[@oldDataBases]};      Inline.LongCOPY[        from: @oldDataBases[0], nwords: seqSizeInWords, to: @newDataBases[0]];      -- stuff in the new entry;  the Initialize calls are necessary because we have a sequence of monitored records;  this data structure is not very well supported by the language;  for this reason the sequence ultimately should be replace by a linked list;      Process.InitializeMonitor[@db.LOCK];        Process.InitializeCondition[@db.tilUnlocked, 0];        Process.DisableTimeout[@db.tilUnlocked];        Process.EnableAborts[@db.tilUnlocked];        db.h ¬ NIL;      db.recoveryInProgress ¬ db.backupInProgress ¬ FALSE;      db.status ¬ open;      db.nReaders ¬ 0;      db.backupPath ¬ NSString.nullString;  -- will be cached here later;      db.backupVersionsToKeep ¬ LAST[CARDINAL];      db.nameRoot ¬ NSString.CopyString[s: database, z: gf.z];      LibServOps.MonitorGF[proc: growDBSeq]};    RETURN[TRUE];    EXITS alreadyExists => RETURN[FALSE];    END;  ReadBackupParameters: PUBLIC PROCEDURE [i: NATURAL]    RETURNS [path: NSString.String, versionsToKeep: CARDINAL] =    BEGIN -- should work whether or not dirty;    IF gf.dataBases[i].backupPath = NSString.nullString THEN {      chName: NSString.String;      rootName: NSString.String = gf.dataBases[i].nameRoot;      h: DataBase ¬ gf.z.NEW[LibServOps.DataBaseObject ¬ [	header: GetSpace[1],	libjectPages: initialLibjectPages,	scratchLibjectPages: initialLibjectPages,	libject: NIL,	scratchLibject: NIL,	recordFile: OpenFile[rootName, recordExt] ]];      [h.pilotFile, h.lpSize] ¬ NSSegmentInternal.GetID[	file: h.recordFile, session: gf.fileSession];      Read[h, LibServOps.headerRun, h.header];      chName ¬ [	bytes: LOOPHOLE[@h.header.backupPath.bytes],	length: h.header.backupPath.length,	maxlength: h.header.backupPath.length];      gf.dataBases[i].backupPath ¬ NSString.CopyString[gf.z, chName];      gf.dataBases[i].backupVersionsToKeep ¬ h.header.backupVersionsToKeep;      FreeSpace[h.header];      CloseFile[h.recordFile];      gf.z.FREE[@h]};    RETURN[gf.dataBases[i].backupPath, gf.dataBases[i].backupVersionsToKeep];    END;-- utilities  GetSpace: PUBLIC PROCEDURE [pages: CARDINAL, swapSize: CARDINAL ¬ 0]    RETURNS [LONG POINTER] = {    ENABLE Space.InsufficientSpace, Volume.InsufficientSpace =>      ERROR XLibrarian.Error[serviceFull];    <<swap: Space.SwapUnitOption =      IF swapSize = 0 THEN [unitary[]] ELSE [uniform[swapSize]];>>    RETURN[Space.ScratchMap[pages]]};      FreeSpace: PUBLIC PROCEDURE [base: LONG POINTER] = {    [] ¬ Space.Unmap[base, return]};    ForceOut: PUBLIC PROCEDURE [h: DataBase] =    BEGIN    IF h.dirtyAtoms THEN {      Write[h, h.header.names, h.names];      h.dirtyAtoms ¬ FALSE};    IF h.dirtyFreePages THEN {      Write[h, h.header.freePages, h.freePages];      h.dirtyFreePages ¬ FALSE};    Write[h, LibServOps.headerRun, h.header];    END;  MakeClean: PUBLIC PROCEDURE [h: DataBase] = {    IF ~h.header.dirty THEN RETURN;    h.header.dirty ¬ FALSE;    ForceOut[h]};      IsDirty: PUBLIC PROCEDURE [h: DataBase] = {    IF h.header.dirty THEN RETURN;    h.header.dirty ¬ TRUE;    Write[h, LibServOps.headerRun, h.header]};    GetDataBases: PUBLIC PROCEDURE RETURNS [seq: LibServOps.Strings] =    BEGIN    CountThem: NSFile.AttributesProc = {count ¬ count + 1};    GetNames: NSFile.AttributesProc = {      extensionLength: NATURAL = hashTableExt.length + 1;      rootLength: NATURAL = attributes.name.length - extensionLength;      seq[i] ¬ NSString.CopyString[z: gf.z, s: attributes.name];      seq[i].length ¬ rootLength;      i ¬ i + 1};    i, count: NATURAL ¬ 0;    scope: NSFile.Scope = [filter: [matches[attribute: [name[S["*.HashTable"L]]]]]];    NSFile.List[      directory: gf.defaultLibDir, proc: CountThem, scope: scope, selections: []];    seq ¬ gf.z.NEW[LibServOps.StringSequence[count]];    NSFile.List[      directory: gf.defaultLibDir, proc: GetNames, scope: scope,      selections: [interpreted: [name: TRUE]]];    END;  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};-- dealing with NSFiling  -- The cost of doing the session validation on every Read or Write is  -- really too much. For that reason the pilot file is used for doing  -- this operation.    Read: PUBLIC PROCEDURE [h: DataBase, run: Run, where: LONG POINTER] = {    IF Space.CopyIn[where, [h.pilotFile, run.start + h.lpSize, run.length]] #       run.length THEN ERROR XLibrarian.Error[implementationBug]};  Write: PUBLIC PROCEDURE [h: DataBase, run: Run, where: LONG POINTER] = {    IF Space.CopyOut[where, [h.pilotFile, run.start + h.lpSize, run.length]] #       run.length THEN ERROR XLibrarian.Error[implementationBug]};       -- this should never happen, since AllocateRun sets the length of the file if it needs to grow;      SetLength: PROCEDURE [f: NSFile.Handle, pages: LONG CARDINAL] = INLINE {    NSSegment.SetSizeInPages[file: f, pages: pages, session: gf.fileSession]};    << NSFile.Error => -- let this through since Services exec catches NSFile.Error         IF error = [space[mediumFull]] THEN ERROR XLibrarian.Error[serviceFull]]};>>      OpenFile: PROCEDURE [root, ext: NSFile.String] RETURNS [handle: NSFile.Handle] = {    fileName: LONG STRING = [NSFile.maxStringLength];    NSString.AppendToMesaString[fileName, root];    String.AppendChar[fileName, '.];    NSString.AppendToMesaString[fileName, ext];    handle ¬ NSFile.OpenByName[      directory: gf.libDir, path: S[fileName], session: gf.fileSession]};  CloseFile: PROCEDURE [handle: NSFile.Handle]  = INLINE {    NSFile.Close[handle, gf.fileSession ! NSFile.Error => CONTINUE]};  DeleteFile: PROCEDURE [handle: NSFile.Handle]  = INLINE {    NSFile.Delete[handle, gf.fileSession]};  CreateFile: PROCEDURE [root, ext: NSFile.String] RETURNS [file: NSFile.Handle] =    BEGIN    fileName: LONG STRING = [NSFile.maxStringLength];    attrs: ARRAY [0..2) OF NSFile.Attribute;    NSString.AppendToMesaString[fileName, root];    String.AppendChar[fileName, '.];    NSString.AppendToMesaString[fileName, ext];    attrs ¬ [      [name[S[fileName]]], [backedUpOn[NSFile.neverBackup]]];    file ¬ NSFile.Create[      directory: gf.libDir, attributes: DESCRIPTOR[attrs],      session: gf.fileSession ! NSFile.Error =>	 IF error = [insertion[fileNotUnique]] THEN ERROR AlreadyExists];    END;  OpenOrCreateFile: PROCEDURE [root, ext: NSFile.String]    RETURNS [file: NSFile.Handle] =    BEGIN    justOpen: BOOLEAN ¬ FALSE;    file ¬ CreateFile[root, ext ! AlreadyExists => {justOpen ¬ TRUE; CONTINUE}];    IF justOpen THEN file ¬ OpenFile[root, ext];    END;    FileName: PROC [name, root, ext: NSFile.String]    RETURNS [NSString.String] = {    name.length ¬ 0;    name ¬ NSString.AppendString[name, root];    name ¬ NSString.AppendString[name, S["."L]];    name ¬ NSString.AppendString[name, ext];    RETURN[name]};-- creating directory for holding files  InitLibDirectory: PROC = {    sysDir: NSFile.Handle ¬ NSFile.OpenByReference[      reference: NSFile.GetReference[file: NSExec.SystemDirectory[]],      session: gf.fileSession];    gf.libDir ¬ NSFile.OpenByName[      directory: sysDir, path: dirName, session: gf.fileSession ! NSFile.Error =>      IF error = [access[fileNotFound]] THEN {        gf.libDir ¬ NSFile.nullHandle; CONTINUE}];    IF gf.libDir = NSFile.nullHandle THEN { -- must create it      attrs: ARRAY [0..3) OF NSFile.Attribute ¬ [        [name[dirName]],	[childrenUniquelyNamed[TRUE]],        [isDirectory[TRUE]]];      gf.libDir ¬ NSFile.Create[        directory: sysDir, attributes: DESCRIPTOR[attrs],        session: gf.fileSession]};    gf.defaultLibDir ¬ NSFile.OpenByReference[      reference: NSFile.GetReference[file: gf.libDir, session: gf.fileSession]];    CloseFile[sysDir]};      InitDefaultLibDirectory: PUBLIC PROC = { -- initializes the lib dir within default session    sysDir: NSFile.Handle ¬ NSExec.SystemDirectory[];    gf.defaultLibDir ¬ NSFile.OpenByName[      directory: sysDir, path: dirName ! NSFile.Error =>        IF error = [access[fileNotFound]] THEN {          gf.defaultLibDir ¬ NSFile.nullHandle; CONTINUE}]};-- main line code  END...  -- of LibServFileImpl
-- File: LibServImpl.mesa - last edit:-- bjd                 19-Jan-88 13:47:35-- PLK    	 3-Apr-84 14:26:08-- Copyright (C) 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved.    DIRECTORY  Auth, ByteBlt, CH, CHPIDs, Environment, Heap, Inline, LibOps, LibServOps, NSName,  Runtime, String, XLibrarian, XString, XStringHashTable;LibServImpl: MONITOR -- LOCKS db USING db: DataBaseEntry --  -- Monitor the per database lock operations (AcquireLock, ReleaseLock);  this can't be a per record monitor right now since we need to also monitor the gf.dataBases sequence;  i.e., the sequence that should be a linked list;  you may ask, why the heck isn't this a linked list then?  that decision was made before any reasonable monitoring scheme was put in;  IMPORTS    Auth, ByteBlt, CH, XLibrarian, LibOps, LibServOps, NSName, Runtime, XString, XStringHashTable  EXPORTS XLibrarian, LibServOps  SHARES XString =  BEGIN      Handle: TYPE = XLibrarian.Handle;  Service: TYPE = LONG POINTER TO ServiceObject;  ServiceObject: PUBLIC TYPE = LibServOps.ServiceObject;  DataBaseEntry: PUBLIC TYPE = LibServOps.DataBaseEntry;  Atom: PUBLIC TYPE = LibServOps.Atom;  PropertyListObject: PUBLIC TYPE = LibOps.PropertyListObject;  PropertyList: TYPE = LibOps.PropertyList;  nullAtom: Atom = XLibrarian.nullAtom;    DataBase: TYPE = LibServOps.DataBase;  Run: TYPE = LibServOps.Run;    Field: TYPE = RECORD [    base: LibServOps.BytesPointer,    span: LibServOps.ByteSpan];  bpp: NATURAL = Environment.bytesPerPage;  bpw: NATURAL = Environment.bytesPerWord;  wpp: NATURAL = Environment.wordsPerPage;    contextSize: CARDINAL = SIZE[XString.Context];  contextBytes: CARDINAL = contextSize*bpw;  gf: LONG POINTER TO LibServOps.GlobalFrame = @LibServOps.gf;  -- exported procedures  nullIndex: NATURAL = LAST[NATURAL];  Open: PUBLIC PROC [    dataBase: XString.Reader, zone: UNCOUNTED ZONE]    RETURNS [Handle] =    BEGIN    -- flavor is only relevant to client side implementation    serv: Service;    handle: Handle;    index: NATURAL ¬ nullIndex;    open: LibServOps.EntryProcType = {      IF db.h = NIL THEN LibServOps.StartDataBase[index];      IF db.h = NIL THEN { -- dirty, needs recovery;	serv.allocated ¬ FALSE;	XLibrarian.Error[dataBaseUnavailable]};      serv.h ¬ db.h;      handle ¬ [service[serv]]};    serv ¬ LibServOps.GetService[];    IF gf.dataBases = NIL THEN ERROR XLibrarian.Error[implementationBug];    FOR i: NATURAL IN [0..gf.dataBases.length) DO      -- what about reading name here?  should this be monitored?  no, since this is only reading, and nameRoot only changes at service startup, i.e. before this code can execute;      dbName: XString.ReaderBody ¬ XString.FromNSString[gf.dataBases[i].nameRoot];      IF XString.Equivalent[dataBase, @dbName] THEN {         index ¬ i;  EXIT};       REPEAT FINISHED => {	serv.allocated ¬ FALSE;	ERROR XLibrarian.Error[dataBaseNotFound]};      ENDLOOP;    MonitorOperation[proc: open, access: write, dbIndex: index];    RETURN[handle];    END;      Close: PUBLIC PROC [handle: XLibrarian.Handle] = {    serv: Service = ServiceForHandle[handle];    serv­ ¬ []};      Create: PUBLIC PROC [handle: Handle, libject: XString.Reader] = {    serv: Service = ServiceForHandle[handle];    create: LibServOps.EntryProcType = {CreateLibject[serv.h, serv, libject]};    MonitorOperation[proc: create, access: write, dbIndex: serv.h.index]};     Destroy: PUBLIC PROC [handle: Handle, libject: XString.Reader] = {    serv: Service = ServiceForHandle[handle];    destroy: LibServOps.EntryProcType = {DestroyLibject[serv.h, serv, libject]};    MonitorOperation[proc: destroy, access: write, dbIndex: serv.h.index]};     NextLibject: PUBLIC PROC [    handle: Handle, current, mask: XString.Reader,    onlyIfCheckedOut: BOOLEAN, user: XString.Reader]    RETURNS [next: XString.ReaderBody] = {    serv: Service = ServiceForHandle[handle];    nextLibject: LibServOps.EntryProcType = {next ¬ NextLibjectEntry[      serv.h, serv, current, mask, onlyIfCheckedOut, user]};    MonitorOperation[proc: nextLibject, access: read, dbIndex: serv.h.index]};     Query: PUBLIC PROC [    handle: Handle, libject: XString.Reader, what: XLibrarian.Atoms]    RETURNS [pl: PropertyList, isCheckedOut: BOOLEAN] = {    serv: Service = ServiceForHandle[handle];    query: LibServOps.EntryProcType = {      [pl, isCheckedOut] ¬ QueryLibject[serv.h, serv, libject, what]};    MonitorOperation[proc: query, access: read, dbIndex: serv.h.index]};     CheckOut: PUBLIC PROC [handle: Handle, libject: XString.Reader] = {    serv: Service = ServiceForHandle[handle];    checkOut: LibServOps.EntryProcType = {CheckOutLibject[serv.h, serv, libject]};    MonitorOperation[proc: checkOut, access: write, dbIndex: serv.h.index]};     CheckIn: PUBLIC PROC [handle: Handle, libject: XString.Reader] = {    serv: Service = ServiceForHandle[handle];    checkIn: LibServOps.EntryProcType = {CheckInLibject[serv.h, serv, libject]};    MonitorOperation[proc: checkIn, access: write, dbIndex: serv.h.index]};     SetProperties: PUBLIC PROC [    handle: Handle, libject: XString.Reader, pl: PropertyList] = {    serv: Service = ServiceForHandle[handle];    setProperties: LibServOps.EntryProcType = {      SetPropertiesForLibject[serv.h, serv, libject, pl]};    MonitorOperation[proc: setProperties, access: write, dbIndex: serv.h.index]};     QueryAndCheckOut: PUBLIC PROC [    handle: Handle, libject: XString.Reader, what: XLibrarian.Atoms]    RETURNS [pl: PropertyList] = {    serv: Service = ServiceForHandle[handle];    queryAndCheckOut: LibServOps.EntryProcType = {      pl ¬ QueryAndCheckOutLibject[serv.h, serv, libject, what]};    MonitorOperation[proc: queryAndCheckOut, access: write, dbIndex: serv.h.index]};   SetPropertiesAndCheckIn: PUBLIC PROC [    handle: Handle, libject: XString.Reader, pl: PropertyList] = {    serv: Service = ServiceForHandle[handle];    setPropertiesAndCheckIn: LibServOps.EntryProcType = {      SetPropertiesForAndCheckInLibject[serv.h, serv, libject, pl]};    MonitorOperation[      proc: setPropertiesAndCheckIn, access: write, dbIndex: serv.h.index]}; -- global monitor procedures;  MonitorOperation: PUBLIC PROC [    proc: LibServOps.EntryProcType, access: LibServOps.AccessType,    dbIndex: NATURAL] =    BEGIN    -- Monitors access to database i;    -- may raise XLibrarian.Error[dataBaseUnavailable];    -- for now treat all clients as writer or recoverer, since still can't handle simultaneous maps of the recordsFile;  should fix this;    access ¬ SELECT access FROM read, write => write      ENDCASE -- backup, recover -- => recover;    AcquireLock[@gf.dataBases[dbIndex], access];    proc[db: @gf.dataBases[dbIndex] !      UNWIND => ReleaseLock[@gf.dataBases[dbIndex], access]];    ReleaseLock[@gf.dataBases[dbIndex], access];    END;  AcquireLock: ENTRY PROCEDURE [    db: DataBaseEntry, accessDesired: LibServOps.AccessType] =    BEGIN ENABLE UNWIND => NULL;    UNTIL AcquireLockInternal[db, accessDesired].goAhead DO      WAIT db.tilUnlocked; ENDLOOP;    END;  AcquireLockInternal: INTERNAL PROCEDURE [    db: DataBaseEntry, accessDesired: LibServOps.AccessType]    RETURNS [goAhead: BOOLEAN] =    BEGIN    SELECT accessDesired FROM      read => {	IF db.backupInProgress OR db.recoveryInProgress THEN	  ERROR XLibrarian.Error[dataBaseUnavailable]; -- don't wait for backup/recover        SELECT db.status FROM          readerIn, open => {	    db.status ¬ readerIn; db.nReaders ¬ db.nReaders+1; goAhead ¬ TRUE};	  ENDCASE => goAhead ¬ FALSE};       write => {	IF db.backupInProgress OR db.recoveryInProgress THEN	  ERROR XLibrarian.Error[dataBaseUnavailable]; -- don't wait for backup/recover        SELECT db.status FROM          open => {	    db.status ¬ writerIn; goAhead ¬ TRUE};	  ENDCASE => goAhead ¬ FALSE};       backup => {        SELECT db.status FROM          readerIn, open => {	    db.status ¬ readerIn;	    db.nReaders ¬ db.nReaders+1;  goAhead ¬ TRUE};	  ENDCASE => goAhead ¬ FALSE};       recover => {        SELECT db.status FROM          open => {	    db.status ¬ writerIn;	    goAhead ¬ TRUE};	  ENDCASE => goAhead ¬ FALSE};       ENDCASE;     END;  ReleaseLock: ENTRY PROCEDURE [    db: DataBaseEntry, access: LibServOps.AccessType] =    BEGIN ENABLE UNWIND => NULL;    SELECT access FROM      read => {        db.nReaders ¬ db.nReaders - 1;        IF db.nReaders = 0 THEN db.status ¬ open};      backup => {        db.nReaders ¬ db.nReaders - 1;        IF db.nReaders = 0 THEN db.status ¬ open};      write => db.status ¬ open;      recover => db.status ¬ open;      ENDCASE;    BROADCAST db.tilUnlocked;    END;   MonitorGF: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE] =    -- we probably wouldn't need this either if db sequence was a linked list;    BEGIN ENABLE UNWIND => NULL;    proc[];    END;-- implementation procedures  CreateLibject: PUBLIC PROC [    h: DataBase, serv: Service, libject: XString.Reader] =    BEGIN ENABLE UNWIND => NULL;    ok, noRoom: BOOLEAN;    userBytes: LibServOps.ByteSpan = [      first: 0,  -- used to start after libject.name(wasNameNowTrash) bytes      length: XString.ByteLength[@serv.user]+contextBytes];    rp: LibServOps.RecordPlace ¬ [      run: TRASH, checkedOut: TRUE, properties: 2];    LibServOps.IsDirty[h];    rp.run ¬ LibServOps.AllocateRun[h, 1];    [ok, noRoom] ¬ XStringHashTable.Insert[h.hashTable, libject, Describe[@rp]];    IF noRoom THEN {      LibServOps.FreeRun[h, rp.run];      LibServOps.MakeClean[h];      ERROR XLibrarian.Error[serviceFull]};    IF ~ok THEN {      LibServOps.FreeRun[h, rp.run];      LibServOps.MakeClean[h];      ERROR XLibrarian.Error[libjectAlreadyExists]};    LibServOps.NoteTransaction[h: h, service: serv, why: create, libject: libject];    h.libject.bytes ¬ LOOPHOLE[SIZE[LibServOps.LibjectHeader[2]]];    h.libject.wasNameNowTrash ¬ [0, 0];    h.libject.count ¬ 2;    h.libject.checkedOut ¬ TRUE;    h.libject.props[0] ¬ [LibServOps.changeTime, [time[serv.lastUse]]];    h.libject.props[1] ¬ [LibServOps.checkOutUser, [xString[userBytes]]];    StoreXString[[@h.libject[h.libject.bytes], userBytes], @serv.user];    WriteLibject[h, rp.run, h.libject];    h.header.records ¬ h.header.records + 1;    LibServOps.MakeClean[h];    END;    DestroyLibject: PUBLIC PROC [    h: DataBase, serv: Service, libject: XString.Reader] =    BEGIN ENABLE UNWIND => NULL;    rp: LibServOps.RecordPlace;    LibServOps.IsDirty[h];    IF ~XStringHashTable.Remove[h.hashTable, libject, Describe[@rp]] THEN {      LibServOps.MakeClean[h];      ERROR XLibrarian.Error[libjectNotFound]};    LibServOps.NoteTransaction[h, serv, destroy, libject];    LibServOps.FreeRun[h, rp.run];    IF h.header.records > 0 THEN h.header.records ¬ h.header.records - 1;    LibServOps.MakeClean[h];    END;    CheckOutInternal: PROC [serv: Service, libject: XString.Reader] =    BEGIN    rp, dummy: LibServOps.RecordPlace;    filedLibject: LibServOps.LibjectBase;    h: DataBase = serv.h;    user: ARRAY [0..1) OF XLibrarian.Property ¬ [[      tag: LibServOps.checkOutUser,      value: [xString[@serv.user]]]];    IF ~XStringHashTable.Find[h.hashTable, libject, Describe[@rp]] THEN      ERROR XLibrarian.Error[libjectNotFound];    ReadLibject[h, rp];    IF h.libject.checkedOut THEN ERROR XLibrarian.Error[libjectCheckedOut];    -- need a way to force consistent    -- IF rp.checkedOut THEN ERROR XLibrarian.Error[implementationBug];    LibServOps.NoteTransaction[h, serv, checkOut, libject];    LibServOps.IsDirty[h];    rp.checkedOut ¬ TRUE;    h.libject.checkedOut ¬ TRUE;    filedLibject ¬ SetValues[h, serv, DESCRIPTOR[user], TRUE, @rp];    WriteLibject[h, rp.run, filedLibject];    IF ~XStringHashTable.SwapValue[      table: h.hashTable,      name: libject,      newValue: Describe[@rp],      oldValue: Describe[@dummy]] THEN ERROR XLibrarian.Error[implementationBug];    END;    CheckInInternal: PROC [serv: Service, libject: XString.Reader] =    BEGIN    rp, dummy: LibServOps.RecordPlace;    h: DataBase = serv.h;    changeTime: LONG POINTER TO LibServOps.PropertyValue.time;    prop: LONG POINTER TO LibServOps.PropertyValue;    IF ~XStringHashTable.Find[h.hashTable, libject, Describe[@rp]] THEN      ERROR XLibrarian.Error[libjectNotFound];    ReadLibject[h, rp];    IF ~h.libject.checkedOut THEN ERROR XLibrarian.Error[libjectNotCheckedOut];    -- need a way to force consistent    -- IF ~rp.checkedOut THEN ERROR XLibrarian.Error[implementationBug];    IF ~h.playingLog THEN {      CompareUser[h, serv];      LibServOps.NoteTransaction[h, serv, checkIn, libject]};    LibServOps.IsDirty[h];    rp.checkedOut ¬ FALSE;    h.libject.checkedOut ¬ FALSE;    prop ¬ FindProp[h.libject, LibServOps.changeTime];    IF prop = NIL THEN ERROR XLibrarian.Error[implementationBug];    changeTime ¬ NARROW[prop ! Runtime.NarrowFault =>      ERROR XLibrarian.Error[implementationBug]];    changeTime.time ¬ serv.lastUse;    WriteLibject[h, rp.run, h.libject];    IF ~XStringHashTable.SwapValue[      table: h.hashTable,      name: libject,      newValue: Describe[@rp],      oldValue: Describe[@dummy]] THEN ERROR XLibrarian.Error[implementationBug];    END;    NextLibjectEntry: PROC [    h: DataBase, serv: Service, current, mask: XString.Reader,    onlyIfCheckedOut: BOOLEAN, user: XString.Reader]    RETURNS [next: XString.ReaderBody] =    BEGIN    nextW: XString.WriterBody ¬      XString.NewWriterBody[XStringHashTable.maxNameLength, gf.z];    R: PROC [w: XString.Writer] RETURNS [XString.Reader] = INLINE {      RETURN[XString.ReaderFromWriter[w]]};     BEGIN ENABLE UNWIND => XString.FreeWriterBytes[@nextW];    rp: LibServOps.RecordPlace;    next ¬ current­;    DO      XStringHashTable.GetNext[        table: h.hashTable, name: @next, nextName: @nextW,	value: Describe[@rp], mask: mask];      IF XString.ByteLength[R[@nextW]] = 0 THEN EXIT;      IF ~onlyIfCheckedOut THEN EXIT;      IF rp.checkedOut THEN {	filed: LONG POINTER TO LibServOps.PropertyValue;        IF XString.Empty[user] THEN EXIT;  -- don't check for user	ReadLibject[h, rp];	filed ¬ FindProp[h.libject, LibServOps.checkOutUser];	IF filed = NIL THEN ERROR XLibrarian.Error[implementationBug];	WITH f: filed SELECT FROM	  string => { -- for old databases	    checkedOutUser: LONG STRING = [XStringHashTable.maxNameLength];	    rb: XString.ReaderBody;	    FetchString[	      from: [@h.libject[h.libject.bytes], f.bytes], to: checkedOutUser];   	    rb ¬ XString.FromSTRING[checkedOutUser, TRUE];	    IF XString.Equivalent[@serv.user, @rb] THEN EXIT};	  xString => {	    r: XString.ReaderBody ¬ FetchXString[	      [base: @h.libject[h.libject.bytes], span: f.bytes]];	    IF XString.Equivalent[user, @r] THEN EXIT};	  ENDCASE => ERROR XLibrarian.Error[implementationBug]};      next ¬ R[@nextW]­;      ENDLOOP;    next ¬ R[@nextW]­;    END;    END;    QueryInternal: PROC [    serv: Service, libject: XString.Reader, what: XLibrarian.Atoms,    notIfCheckedOut: BOOLEAN]    RETURNS [pl: PropertyList, isCheckedOut: BOOLEAN] =    BEGIN    rp: LibServOps.RecordPlace;    h: DataBase = serv.h;    getAll: BOOLEAN = (what.LENGTH = 0);    propCount: NATURAL;    IF ~XStringHashTable.Find[h.hashTable, libject, Describe[@rp]] THEN      ERROR XLibrarian.Error[libjectNotFound];    isCheckedOut ¬ rp.checkedOut;    IF isCheckedOut AND notIfCheckedOut THEN      ERROR XLibrarian.Error[libjectCheckedOut];    ReadLibject[h, rp];    propCount ¬ IF getAll THEN h.libject.count ELSE what.LENGTH;    pl ¬ LibOps.CreatePL[gf.z, propCount];    pl.list.props.LENGTH ¬ propCount;    FOR i: NATURAL IN [0..propCount) DO      heaped: XLibrarian.Value;      atom: Atom;      filed: LONG POINTER TO LibServOps.PropertyValue;      IF getAll THEN {        atom ¬ h.libject.props[i].pn;	filed ¬ @h.libject.props[i].value}      ELSE {        atom ¬ what[i];	filed ¬ FindProp[h.libject, atom]};      IF filed = NIL THEN heaped ¬ [null[]]      ELSE WITH f: filed SELECT FROM	null => heaped ¬ [null[]];	time => heaped ¬ [time[f.time]];	integer => heaped ¬ [integer[f.integer]];	xString => heaped ¬ [xString[MakeXString[h, f.bytes]]];	string => heaped ¬ [string[MakeString[h, f.bytes]]];	client => {	  r: XLibrarian.Record = LibOps.NEWRecord[gf.z, f.bytes.length/2];	  FetchBytes[[@h.libject[h.libject.bytes], f.bytes], @r[0]];	  heaped ¬ [client[r]]};	xStrings => {	  s: XLibrarian.XStrings = LibOps.NEWXStrings[gf.z, f.count];	  FOR i: NATURAL IN [0..f.count) DO	    s[i] ¬ MakeXString[h, h.libject[f.bytes][i]];	    ENDLOOP;	  heaped ¬ [xStrings[s]]};	strings => {	  s: XLibrarian.Strings = LibOps.NEWStrings[gf.z, f.count];	  FOR i: NATURAL IN [0..f.count) DO	    s[i] ¬ MakeString[h, h.libject[f.bytes][i]];	    ENDLOOP;	  heaped ¬ [strings[s]]};	ENDCASE => ERROR XLibrarian.Error[implementationBug];      pl.list.props[i] ¬ [atom, heaped];      ENDLOOP;    END;    SetValues: PROC [    h: DataBase, serv: Service,    pl: LONG DESCRIPTOR FOR ARRAY OF XLibrarian.Property,    settingUser: BOOLEAN, rp: POINTER TO LibServOps.RecordPlace]    RETURNS [dest: LibServOps.LibjectBase] =    BEGIN    allFits: BOOLEAN;    prop: LONG POINTER TO LibServOps.PropertyValue;    changeTime: LONG POINTER TO LibServOps.PropertyValue.time;    dest ¬ h.libject;    FOR i: NATURAL IN [0..pl.LENGTH) DO      IF SameAtom[pl[i].tag, LibServOps.checkOutUser] AND ~settingUser THEN	ERROR XLibrarian.Error[reservedProperty];      IF SameAtom[pl[i].tag, LibServOps.changeTime] THEN	ERROR XLibrarian.Error[reservedProperty];      prop ¬ FindProp[dest, pl[i].tag];      IF prop = NIL THEN	IF pl[i].value.type = null THEN LOOP -- removing non-existant property	ELSE GOTO haveToCopy;  -- adding new property      WITH p: pl[i].value SELECT FROM	null => GOTO haveToCopy;  -- removing existing property	time => {	  t: LONG POINTER TO LibServOps.PropertyValue.time = NARROW[prop !	    Runtime.NarrowFault => GOTO haveToCopy];	  t.time ¬ p.time};	integer => {	  i: LONG POINTER TO LibServOps.PropertyValue.integer = NARROW[prop !	    Runtime.NarrowFault => GOTO haveToCopy];	  i.integer ¬ p.integer};	client => {	  c: LONG POINTER TO LibServOps.PropertyValue.client = NARROW[prop !	    Runtime.NarrowFault => GOTO haveToCopy];	  IF CARDINAL[p.record.LENGTH]*bpw > c.bytes.length THEN GOTO haveToCopy;	  c.bytes.length ¬ p.record.LENGTH*bpw;	  StoreBytes[[@h.libject[h.libject.bytes], c.bytes], @p.record[0]]};	xString => {	  s: LONG POINTER TO LibServOps.PropertyValue.xString = NARROW[prop !	    Runtime.NarrowFault => GOTO haveToCopy];	  IF XString.ByteLength[p.string] > ByteLength[s.bytes] THEN	    GOTO haveToCopy;	  s.bytes.length ¬ XString.ByteLength[p.string]+contextBytes;	  StoreXString[to: [@h.libject[h.libject.bytes], s.bytes], from: p.string]};	string => {	  s: LONG POINTER TO LibServOps.PropertyValue.string = NARROW[prop !	    Runtime.NarrowFault => GOTO haveToCopy];	  IF p.string.length > s.bytes.length THEN GOTO haveToCopy;	  s.bytes.length ¬ p.string.length;	  StoreString[[@h.libject[h.libject.bytes], s.bytes], p.string]};	xStrings => GOTO haveToCopy;	strings => GOTO haveToCopy;	ENDCASE => ERROR XLibrarian.Error[illegalType];      REPEAT	haveToCopy => allFits ¬ FALSE;	FINISHED => allFits ¬ TRUE;      ENDLOOP;    IF ~allFits THEN {<<  At this point we know that we can't simply put all the new values directly into the space where they fit before. It was worth checking since that is a common case and prevents us from having to do the hard (following) part too often.  The first thing to do is to find out which properties need to be copied over into the new property list. This is all the old ones that are not also in the new list plus all the new ones (except the null properties which is the way the client says he wants to remove a property).  We then compute how much room the new list occupies.  We have to make sure that the scratchLibject is big enough to hold the merged lists. If not, it is expanded.  The new filed libject is created by doing the appropriate copying and the size needed (in file pages) is also computed. If necessary, a new run is allocated in the file. >>       count: NATURAL ¬ pl.LENGTH;      bytes, words, pages: NATURAL;      fromBase, toBase: LibServOps.BytesPointer;      keep: PACKED ARRAY [0..LibOps.maxProperties) OF BOOLEAN;      IF h.libject.count > LibOps.maxProperties THEN	ERROR XLibrarian.Error[implementationBug];-- count and note which elements to keep      FOR old: NATURAL IN [0..h.libject.count) DO	FOR new: NATURAL IN [0..pl.LENGTH) DO	  IF SameAtom[pl[new].tag, h.libject.props[old].pn] THEN GOTO notThisOne;	  REPEAT	    notThisOne => keep[old] ¬ FALSE;	    FINISHED => {keep[old] ¬ TRUE; count ¬ count + 1};	  ENDLOOP;	ENDLOOP;-- compute the bytes used (and remove count for [null[]] new entries)      bytes ¬ h.libject.wasNameNowTrash.length;      words ¬ SIZE[LibServOps.LibjectHeader[count]];      FOR new: NATURAL IN [0..pl.LENGTH) DO	WITH p: pl[new].value SELECT FROM	  null => {	    count ¬ count - 1; words ¬ words - SIZE[LibServOps.RelativeProperty]};	  client => bytes ¬ bytes + p.record.LENGTH*bpw;	  xString => bytes ¬ bytes + XString.ByteLength[p.string]+contextBytes;	  string => bytes ¬ bytes + p.string.length;	  xStrings => {	    words ¬ words + SIZE[LibServOps.RelStringSeq[p.strings.LENGTH]];	    FOR i: NATURAL IN [0..p.strings.LENGTH) DO	      bytes ¬ bytes + XString.ByteLength[p.strings[i]]+contextBytes;	      ENDLOOP};	  strings => {	    words ¬ words + SIZE[LibServOps.RelStringSeq[p.strings.LENGTH]];	    FOR i: NATURAL IN [0..p.strings.LENGTH) DO	      bytes ¬ bytes + p.strings[i].length;	      ENDLOOP};	  time, integer => NULL;	  ENDCASE => ERROR XLibrarian.Error[illegalType];	ENDLOOP;      FOR old: NATURAL IN [0..h.libject.count) DO	IF ~keep[old] THEN LOOP;	WITH p: h.libject.props[old].value SELECT FROM	  client => bytes ¬ bytes + p.bytes.length;	  xString => bytes ¬ bytes + p.bytes.length;	  string => bytes ¬ bytes + p.bytes.length;	  xStrings => {	    words ¬ words + SIZE[LibServOps.RelStringSeq[p.count]];	    FOR i: NATURAL IN [0..p.count) DO	      bytes ¬ bytes + h.libject[p.bytes][i].length;	      ENDLOOP};	  strings => {	    words ¬ words + SIZE[LibServOps.RelStringSeq[p.count]];	    FOR i: NATURAL IN [0..p.count) DO	      bytes ¬ bytes + h.libject[p.bytes][i].length;	      ENDLOOP};	  time, integer => NULL;	  ENDCASE => ERROR XLibrarian.Error[implementationBug];	ENDLOOP;-- make sure everything fits      pages ¬ PagesForBytes[words*bpw + bytes];      IF pages > h.scratchLibjectPages THEN {	LibServOps.FreeSpace[h.scratchLibject];	h.scratchLibjectPages ¬ pages;	h.scratchLibject ¬ LibServOps.GetSpace[pages]};      IF rp.run.length ~IN [pages..CARDINAL[pages+3]) THEN {	LibServOps.FreeRun[h, rp.run];	rp.run ¬ LibServOps.AllocateRun[h, pages]};-- copy the data into the new memory      h.scratchLibject.bytes ¬ LOOPHOLE[words];      h.scratchLibject.wasNameNowTrash ¬ h.libject.wasNameNowTrash;      h.scratchLibject.checkedOut ¬ h.libject.checkedOut;      h.scratchLibject.count ¬ count;      fromBase ¬ @h.libject[h.libject.bytes];      toBase ¬ @h.scratchLibject[h.scratchLibject.bytes];-- reset counters      words ¬ SIZE[LibServOps.LibjectHeader[count]];      bytes ¬ 0;      count ¬ 0;      CopyBytes[        from: [fromBase, h.libject.wasNameNowTrash],        to: [toBase, h.scratchLibject.wasNameNowTrash]];      bytes ¬ bytes + h.scratchLibject.wasNameNowTrash.length;      FOR new: NATURAL IN [0..pl.LENGTH) DO	WITH p: pl[new].value SELECT FROM	  null => LOOP;	  client => {	    span: LibServOps.ByteSpan = [bytes, p.record.LENGTH*bpw];	    h.scratchLibject.props[count] ¬ [pl[new].tag, [client[span]]];	    StoreBytes[from: @p.record[0], to: [toBase, span]];	    bytes ¬ bytes + span.length};	  xString => {	    span: LibServOps.ByteSpan = [               first: bytes, length: XString.ByteLength[p.string]+contextBytes]; 	    h.scratchLibject.props[count] ¬ [pl[new].tag, [xString[span]]];	    StoreXString[from: p.string, to: [toBase, span]];	    bytes ¬ bytes + span.length};	  string => {	    span: LibServOps.ByteSpan = [bytes, p.string.length];	    h.scratchLibject.props[count] ¬ [pl[new].tag, [string[span]]];	    StoreString[from: p.string, to: [toBase, span]];	    bytes ¬ bytes + span.length};	  xStrings => {	    seq: LibServOps.PropertyValue.xStrings =	      [xStrings[p.strings.LENGTH, LOOPHOLE[words]]];	    seqBase: LONG POINTER TO LibServOps.RelStringSeq =	      @h.scratchLibject[seq.bytes];	    h.scratchLibject.props[count] ¬ [pl[new].tag, seq];	    FOR i: NATURAL IN [0..p.strings.LENGTH) DO	      span: LibServOps.ByteSpan = [                first: bytes, length: XString.ByteLength[p.strings[i]]+contextBytes]; 	      StoreXString[from: p.strings[i], to: [toBase, span]];	      seqBase[i] ¬ span;	      bytes ¬ bytes + span.length;	      ENDLOOP;	    words ¬ words + SIZE[LibServOps.RelStringSeq[p.strings.LENGTH]]};	  strings => {	    seq: LibServOps.PropertyValue.strings =	      [strings[p.strings.LENGTH, LOOPHOLE[words]]];	    seqBase: LONG POINTER TO LibServOps.RelStringSeq =	      @h.scratchLibject[seq.bytes];	    h.scratchLibject.props[count] ¬ [pl[new].tag, seq];	    FOR i: NATURAL IN [0..p.strings.LENGTH) DO	      span: LibServOps.ByteSpan = [bytes, p.strings[i].length];	      StoreString[from: p.strings[i], to: [toBase, span]];	      seqBase[i] ¬ span;	      bytes ¬ bytes + span.length;	      ENDLOOP;	    words ¬ words + SIZE[LibServOps.RelStringSeq[p.strings.LENGTH]]};	  time =>	    h.scratchLibject.props[count] ¬ [pl[new].tag, [time[p.time]]];	  integer =>	    h.scratchLibject.props[count] ¬ [pl[new].tag, [integer[p.integer]]];	  ENDCASE => ERROR XLibrarian.Error[illegalType];	  count ¬ count + 1;	ENDLOOP;      FOR old: NATURAL IN [0..h.libject.count) DO	prop: LONG POINTER TO LibServOps.RelativeProperty = @h.libject.props[old];	IF ~keep[old] THEN LOOP;	WITH p: prop.value SELECT FROM	  client => {	    span: LibServOps.ByteSpan = [bytes, p.bytes.length];	    h.scratchLibject.props[count] ¬ [prop.pn, [client[span]]];	    CopyBytes[from: [fromBase, p.bytes], to: [toBase, span]];	    bytes ¬ bytes + span.length};	  xString => {	    span: LibServOps.ByteSpan = [               first: bytes, length: p.bytes.length]; 	    h.scratchLibject.props[count] ¬ [prop.pn, [xString[span]]];	    CopyBytes[from: [fromBase, p.bytes], to: [toBase, span]];	    bytes ¬ bytes + span.length};	  string => {	    span: LibServOps.ByteSpan = [bytes, p.bytes.length];	    h.scratchLibject.props[count] ¬ [prop.pn, [string[span]]];	    CopyBytes[from: [fromBase, p.bytes], to: [toBase, span]];	    bytes ¬ bytes + span.length};	  xStrings => {	    seq: LibServOps.PropertyValue.xStrings =	      [xStrings[p.count, LOOPHOLE[words]]];	    seqBase: LONG POINTER TO LibServOps.RelStringSeq =	      @h.scratchLibject[seq.bytes];	    h.scratchLibject.props[count] ¬ [prop.pn, seq];	    FOR i: NATURAL IN [0..p.count) DO	      span: LibServOps.ByteSpan = [	        first: bytes, length: h.libject[p.bytes][i].length]; 	      CopyBytes[	        from: [fromBase, h.libject[p.bytes][i]],	        to: [toBase, span]];	      seqBase[i] ¬ span;	      bytes ¬ bytes + span.length;	      ENDLOOP;	    words ¬ words + SIZE[LibServOps.RelStringSeq[p.count]]};	  strings => {	    seq: LibServOps.PropertyValue.strings =	      [strings[p.count, LOOPHOLE[words]]];	    seqBase: LONG POINTER TO LibServOps.RelStringSeq =	      @h.scratchLibject[seq.bytes];	    h.scratchLibject.props[count] ¬ [prop.pn, seq];	    FOR i: NATURAL IN [0..p.count) DO	      span: LibServOps.ByteSpan = [bytes, h.libject[p.bytes][i].length];	      CopyBytes[	        from: [fromBase, h.libject[p.bytes][i]],	        to: [toBase, span]];	      seqBase[i] ¬ span;	      bytes ¬ bytes + span.length;	      ENDLOOP;	    words ¬ words + SIZE[LibServOps.RelStringSeq[p.count]]};	  time =>	    h.scratchLibject.props[count] ¬ [prop.pn, [time[p.time]]];	  integer =>	    h.scratchLibject.props[count] ¬ [prop.pn, [integer[p.integer]]];	  ENDCASE => ERROR XLibrarian.Error[implementationBug];	count ¬ count + 1;	ENDLOOP;      IF count > LibOps.maxProperties THEN        ERROR XLibrarian.Error[implementationBug];      IF count # h.scratchLibject.count THEN        ERROR XLibrarian.Error[implementationBug];      rp.properties ¬ count;      dest ¬ h.scratchLibject};  -- fix up the time    prop ¬ FindProp[dest, LibServOps.changeTime];    IF prop = NIL THEN ERROR XLibrarian.Error[implementationBug];    changeTime ¬ NARROW[prop ! Runtime.NarrowFault =>      ERROR XLibrarian.Error[implementationBug]];    changeTime.time ¬ serv.lastUse;    END;    SetPropertiesInternal: PROC [    serv: Service, libject: XString.Reader, pl: PropertyList] = {    rp, dummy: LibServOps.RecordPlace;    filedLibject: LibServOps.LibjectBase;    h: DataBase = serv.h;    IF ~XStringHashTable.Find[h.hashTable, libject, Describe[@rp]] THEN      ERROR XLibrarian.Error[libjectNotFound];    ReadLibject[h, rp];    IF ~h.libject.checkedOut THEN ERROR XLibrarian.Error[libjectNotCheckedOut];    IF ~h.playingLog THEN {      CompareUser[h, serv];      LibServOps.NoteTransaction[h, serv, setProperty, libject, pl.list.props]};    LibServOps.IsDirty[h];    filedLibject ¬ SetValues[h, serv, pl.list.props, FALSE, @rp];    WriteLibject[h, rp.run, filedLibject];    IF ~XStringHashTable.SwapValue[      table: h.hashTable,      name: libject,      newValue: Describe[@rp],      oldValue: Describe[@dummy]] THEN ERROR XLibrarian.Error[implementationBug];    };    QueryLibject: PROC [    h: DataBase, serv: Service, libject: XString.Reader, what: XLibrarian.Atoms]    RETURNS [pl: PropertyList, isCheckedOut: BOOLEAN] = {    ENABLE UNWIND => NULL;    RETURN QueryInternal[serv, libject, what, FALSE]};    CheckOutLibject: PUBLIC PROC [    h: DataBase, serv: Service, libject: XString.Reader] = {    ENABLE UNWIND => LibServOps.MakeClean[h];    CheckOutInternal[serv, libject];    LibServOps.MakeClean[h]};    CheckInLibject: PUBLIC PROC [    h: DataBase, serv: Service, libject: XString.Reader] = {    ENABLE UNWIND => LibServOps.MakeClean[h];    CheckInInternal[serv, libject];    LibServOps.MakeClean[h]};    SetPropertiesForLibject: PUBLIC PROC [    h: DataBase, serv: Service, libject: XString.Reader, pl: PropertyList] = {    ENABLE UNWIND => LibServOps.MakeClean[h];    SetPropertiesInternal[serv, libject, pl];    LibServOps.MakeClean[h]};    QueryAndCheckOutLibject: PROC [    h: DataBase, serv: Service, libject: XString.Reader,    what: XLibrarian.Atoms]    RETURNS [pl: PropertyList] = {    ENABLE UNWIND => LibServOps.MakeClean[h];    pl ¬ QueryInternal[serv, libject, what, TRUE].pl;    CheckOutInternal[serv, libject];    LibServOps.MakeClean[h]};  SetPropertiesForAndCheckInLibject: PROC [    h: DataBase, serv: Service, libject: XString.Reader,    pl: PropertyList] = {    ENABLE UNWIND => LibServOps.MakeClean[h];    SetPropertiesInternal[serv, libject, pl];    CheckInInternal[serv, libject];    LibServOps.MakeClean[h]};  GetAccess: PUBLIC PROC [    h: LibServOps.DataBase, client: NSName.Name, creds: Auth.CredentialsHandle]    RETURNS [access: LibServOps.Access] =  -- h assumed to be loaded, i.e. non-nil;    BEGIN    getAccess: LibServOps.EntryProcType = {      -- serialize access to conversation handle      IF Auth.GetFlavor[creds] = simple AND	h.header.minAuthentication = strong THEN	  ERROR XLibrarian.Error[insufficientAuthentication];      IF h.writers = NIL THEN {	  access ¬ write; RETURN};      IF NSName.EquivalentNames[client, h.writers] THEN {	  access ¬ write; RETURN};      IF CH.IsMemberClosure[	conversation: gf.chConv, element: client, name: h.writers,	pn: CHPIDs.members, distingName: NIL].isMember THEN {	  access ¬ write; RETURN};      IF h.readers = NIL THEN {access ¬ read;  RETURN};      IF NSName.EquivalentNames[client, h.readers] THEN {access ¬ read;  RETURN};      IF CH.IsMemberClosure[	conversation: gf.chConv, element: client, name: h.writers,	pn: CHPIDs.members, distingName: NIL].isMember THEN {	  access ¬ read; RETURN};      ERROR XLibrarian.Error[insufficientAccess]};    MonitorOperation[proc: getAccess, access: read, dbIndex: h.index];    END;-- utility procedures  ReadLibject: PROCEDURE [h: DataBase, rp: LibServOps.RecordPlace] = {    IF h.currentRun = rp.run THEN RETURN;    IF h.libjectPages < rp.run.length THEN {      LibServOps.FreeSpace[h.libject];      h.libjectPages ¬ rp.run.length;      h.libject ¬ LibServOps.GetSpace[h.libjectPages, 4]};    LibServOps.Read[h, rp.run, h.libject];    h.currentRun ¬ rp.run};      WriteLibject: PROCEDURE [    h: DataBase, run: Run, where: LibServOps.LibjectBase] = {    LibServOps.Write[h, run, where];    IF where # h.libject THEN h.currentRun ¬ [0, 0]};      Describe: PROCEDURE [rp: LONG POINTER TO LibServOps.RecordPlace]    RETURNS [LONG DESCRIPTOR FOR ARRAY OF CARDINAL] = INLINE {    RETURN[DESCRIPTOR[rp, SIZE[LibServOps.RecordPlace]]]};      StoreXString: PROC [to: Field, from: XString.Reader] = {    c: PACKED ARRAY INTEGER[0..2) OF Environment.Byte ¬ LOOPHOLE[from.context];    to.base[to.span.first] ¬ c[0]; -- context in the 1st 2 bytes;    to.base[to.span.first+1] ¬ c[1];    [] ¬ ByteBlt.ByteBlt[      from: XString.Block[from].block,      to: [        to.base+contextSize,        to.span.first, to.span.first + to.span.length - contextBytes],      overLap: move]};      StoreString: PROC [to: Field, from: LONG STRING] = {    [] ¬ ByteBlt.ByteBlt[      from: StringBlock[from],      to: [to.base, to.span.first, to.span.first + to.span.length],      overLap: move]};      FetchXString: PROC [from: Field] RETURNS [to: XString.ReaderBody] = {    c: PACKED ARRAY INTEGER[0..2) OF Environment.Byte;    c[0] ¬ from.base[from.span.first];  -- context in the 1st 2 bytes;    c[1] ¬ from.base[from.span.first+1];    to ¬ XString.FromBlock[      context: LOOPHOLE[c],      block: [        blockPointer: from.base+contextSize,        startIndex: from.span.first,        stopIndexPlusOne: from.span.first + from.span.length - contextBytes]]};  FetchString: PROC [from: Field, to: LONG STRING] = {    to.length ¬ ByteBlt.ByteBlt[      to: [LOOPHOLE[@to.text], 0, to.maxlength],      from: [from.base, from.span.first, from.span.first + from.span.length],      overLap: move]};      Equivalent: PROC [c: CHARACTER, b: Environment.Byte] RETURNS [BOOLEAN] = {    IF c IN ['a..'z] THEN c ¬ c - ('a - 'A);    IF b IN [141B..172B] THEN b ¬ b - 40B;    RETURN[c.ORD = b]};    MakeXString: PROC [h: DataBase, span: LibServOps.ByteSpan]    RETURNS [s: XString.Reader] = {    r: XString.ReaderBody ¬ FetchXString[[@h.libject[h.libject.bytes], span]];    s ¬ XString.CopyReader[@r, gf.z]};  MakeString: PROC [h: DataBase, span: LibServOps.ByteSpan]    RETURNS [s: LONG STRING] = {    s ¬ gf.z.NEW[StringBody[span.length]];    FetchString[[@h.libject[h.libject.bytes], span], s]};  FetchBytes: PROC [from: Field, to: LONG POINTER] = {    [] ¬ ByteBlt.ByteBlt[      to: [to, 0, from.span.length],      from: [from.base, from.span.first, from.span.first + from.span.length],      overLap: move]};      StoreBytes: PROC [to: Field, from: LONG POINTER] = {    [] ¬ ByteBlt.ByteBlt[      from: [from, 0, to.span.length],      to: [to.base, to.span.first, to.span.first + to.span.length],      overLap: move]};      CopyBytes: PROC [from, to: Field] = {    [] ¬ ByteBlt.ByteBlt[      from: [from.base, from.span.first, from.span.first + from.span.length],      to: [to.base, to.span.first, to.span.first + to.span.length],      overLap: move]};      CompareUser: PROC [h: DataBase, serv: Service] =    BEGIN    prop: LONG POINTER TO LibServOps.PropertyValue =      FindProp[h.libject, LibServOps.checkOutUser];    IF prop = NIL THEN ERROR XLibrarian.Error[implementationBug];    IF serv.access = administrator THEN RETURN;  -- go ahead regardless    WITH p: prop SELECT FROM      string => { -- for old databases	checkedOutUser: LONG STRING = [XStringHashTable.maxNameLength];        rb: XString.ReaderBody;	FetchString[	  from: [@h.libject[h.libject.bytes], p.bytes], to: checkedOutUser];           rb ¬ XString.FromSTRING[checkedOutUser, TRUE];	IF ~XString.Equivalent[@serv.user, @rb] THEN	  ERROR XLibrarian.Error[libjectNotCheckedOutToYou]};      xString => {	checkedOutUser: XString.ReaderBody ¬ FetchXString[	  [@h.libject[h.libject.bytes], p.bytes]];   	IF ~XString.Equivalent[@serv.user, @checkedOutUser] THEN	  ERROR XLibrarian.Error[libjectNotCheckedOutToYou]};      ENDCASE => ERROR XLibrarian.Error[implementationBug];    END;      ByteLength: PROC [span: LibServOps.ByteSpan] RETURNS [CARDINAL] = INLINE {    RETURN[span.length-contextBytes]};   NthChar: PROC [h: DataBase, i: NATURAL] RETURNS [CHARACTER] = INLINE {    RETURN[0C + h.libject[h.libject.bytes][i]]};      NthByte: PROC [h: DataBase, i: NATURAL] RETURNS [Environment.Byte] = INLINE {    RETURN[h.libject[h.libject.bytes][i]]};      FindProp: PROC [libject: LibServOps.LibjectBase, atom: Atom]    RETURNS [LONG POINTER TO LibServOps.PropertyValue] =    BEGIN    FOR i: NATURAL IN [0..libject.count) DO      IF libject.props[i].pn = atom THEN RETURN[@libject.props[i].value];      ENDLOOP;    RETURN[NIL];    END;      XStringBlock: PROC [r: XString.Reader] RETURNS [Environment.Block] = INLINE {    RETURN[XString.Block[r].block]};      StringBlock: PROC [s: LONG STRING] RETURNS [Environment.Block] = INLINE {    RETURN[[LOOPHOLE[@s.text], 0, s.length]]};      PagesForBytes: PROC [bytes: NATURAL] RETURNS [NATURAL] = INLINE {    RETURN[(bytes + bpp - 1)/ bpp]};    -- this procedure is to prevent bogus warnings by compiler  SameAtom: PROC [a1, a2: Atom] RETURNS [BOOLEAN] = {    RETURN[a1 = a2]};      MatchChar: PROC [c1, c2: CHARACTER] RETURNS [BOOLEAN] = INLINE {    IF c1 IN ['a..'z] THEN c1 ¬ c1 - ('a-'A);    IF c2 IN ['a..'z] THEN c2 ¬ c2 - ('a-'A);    RETURN[c1 = c2]};      ServiceForHandle: PROC [handle: XLibrarian.Handle] RETURNS [Service] = {    WITH s: handle SELECT FROM      service => RETURN[s.service];      ENDCASE => ERROR XLibrarian.Error[invalidHandle]};      Init: PROC = {};    -- main line code  Init[];  END.  -- of LibServImplLOG (date - initials - action)18-Aug-87 16:42:03 - bjd - get rid of even crud in NextLibjectEntry; the call to AppendReader was mucking with the string, changing the byte length;  
-- File: LibHashStatsImpl.mesa - last edit:-- bjd                 23-Apr-87 15:06:15-- Copyright (C) 1985, 1986, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Format, LibServOps, NSFile, NSExec, NSString, NSTTY, Runtime, String, TextInput, TTY, XString, XStringHashTable, XStringHashTableExtra;LibHashStatsImpl: PROGRAM  IMPORTS LibServOps, NSExec, NSFile, NSString, NSTTY, Runtime, TextInput, TTY, XStringHashTableExtra =  BEGIN    recordsExt: NSString.String = S["Records"L];  hashTableExt: NSString.String = S["HashTable"L];  ChoiceSequence: TYPE = RECORD [    seq: SEQUENCE length: CARDINAL OF NSString.String];    gf: LONG POINTER TO LibServOps.GlobalFrame = @LibServOps.gf;  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  GetDataBases: PROCEDURE [lookInLibDirectory: BOOLEAN]    RETURNS [seq: LibServOps.Strings] =    BEGIN    dir: NSFile.Handle = IF lookInLibDirectory      THEN gf.defaultLibDir ELSE NSExec.WorkingDirectory[];    CountThem: NSFile.AttributesProc = {count ¬ count + 1};    GetNames: NSFile.AttributesProc = {      extensionLength: NATURAL = hashTableExt.length + 1;      rootLength: NATURAL = attributes.name.length - extensionLength;      seq[i] ¬ NSString.CopyString[z: gf.z, s: attributes.name];      seq[i].length ¬ rootLength;      i ¬ i + 1};    i, count: NATURAL ¬ 0;    scope: NSFile.Scope = [filter: [matches[attribute: [name[S["*.HashTable"L]]]]]];    NSFile.List[      directory: dir, proc: CountThem, scope: scope, selections: []];    seq ¬ gf.z.NEW[LibServOps.StringSequence[count]];    NSFile.List[      directory: dir, proc: GetNames, scope: scope,      selections: [interpreted: [name: TRUE]]];    END;  SetHashValidation: NSExec.ExecProc =     BEGIN    CleanUp: PROC = {      gf.z.FREE[@choices];      FOR i: NATURAL IN [0..dbStrings.length) DO NSString.FreeString[z: gf.z, s: dbStrings[i]] ENDLOOP;      gf.z.FREE[@dbStrings]};    on: BOOLEAN;    choices: LONG POINTER TO ChoiceSequence ¬ NIL;    tty: TTY.Handle = NSExec.GetTTY[exec];    which: TextInput.ChoiceIndex;    dbStrings: LibServOps.Strings;    {    IF gf.status # started THEN {      TTY.PutString[tty, "Librarian service must be started to set hash validation."L];      GOTO quit};    dbStrings ¬ GetDataBases[lookInLibDirectory: TRUE];    choices ¬ gf.z.NEW[ChoiceSequence[dbStrings.length]];    FOR i: NATURAL IN [0..dbStrings.length) DO choices[i] ¬ dbStrings[i] ENDLOOP;    which ¬ TextInput.GetChoice[      tty: tty, prompt: S["Which database?"L],      choices: DESCRIPTOR[choices], nilOK: FALSE ! UNWIND => CleanUp[]];    IF gf.dataBases[which].h = NIL THEN {      TTY.PutString[tty, "Database must be loaded to set hash validation."L];      CleanUp[];      GOTO quit};    on ¬ XStringHashTableExtra.ToggleValidate[gf.dataBases[which].h.hashTable];    TTY.PutString[tty, "Hash validation "L];    TTY.PutString[tty, " turned "L];    TTY.PutString[tty, IF on THEN " on\n"L ELSE " off\n"L];    };    CleanUp[];    EXITS      quit => NULL;    END;  ShowHashStatistics: NSExec.ExecProc =     BEGIN    Write: Format.StringProc = {TTY.PutString[tty, s]};    CleanUp: PROC = {      gf.z.FREE[@choices];      FOR i: NATURAL IN [0..dbStrings.length) DO NSString.FreeString[z: gf.z, s: dbStrings[i]] ENDLOOP;      gf.z.FREE[@dbStrings]};    choices: LONG POINTER TO ChoiceSequence ¬ NIL;    tty: TTY.Handle = NSExec.GetTTY[exec];    which: TextInput.ChoiceIndex;    dbStrings: LibServOps.Strings;    {    IF gf.status # started THEN {      TTY.PutString[tty, "Librarian service must be started to show hash statistics."L];      GOTO quit};    dbStrings ¬ GetDataBases[lookInLibDirectory: TRUE];    choices ¬ gf.z.NEW[ChoiceSequence[dbStrings.length]];    FOR i: NATURAL IN [0..dbStrings.length) DO choices[i] ¬ dbStrings[i] ENDLOOP;    which ¬ TextInput.GetChoice[      tty: tty, prompt: S["Which database?"L],      choices: DESCRIPTOR[choices], nilOK: FALSE ! UNWIND => CleanUp[]];    IF gf.dataBases[which].h = NIL THEN {      TTY.PutString[tty, "Database must be loaded to show hash statistics."L];      CleanUp[];      GOTO quit};    TTY.PutString[tty, "Hash distribution statistics for '"L];    NSTTY.PutString[tty, dbStrings[which]];    TTY.PutString[tty, "':\n"L];    XStringHashTableExtra.ShowStatistics[gf.dataBases[which].h.hashTable, Write];    };    CleanUp[];    EXITS      quit => NULL;    END;  Init: PROCEDURE = {    commands: ARRAY [0..2) OF NSExec.Command ¬ [      [S["Set Hash Validation"L], SetHashValidation, StartedPred],      [S["Show Hash Statistics"L], ShowHashStatistics, StartedPred]];    [] ¬ LibServOps.StatusEqualTo[started !      Runtime.UnboundProcedure, Runtime.ControlFault => GOTO error];    NSExec.AddClientCommands[gf.execId, DESCRIPTOR[commands]];    EXITS error => -- ERROR NSExec.Error[cannotInitialize] --      NULL};  StartedPred: NSExec.Predicate = {    RETURN[LibServOps.StatusEqualTo[started]]};  --main line code  Init[];  END.    
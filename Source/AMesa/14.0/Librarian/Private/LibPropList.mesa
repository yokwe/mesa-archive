-- File: LibPropList.mesa - last edit:-- bjd                 14-Jul-86 18:13:19-- PLK    	28-Mar-84 16:09:59-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.    DIRECTORY Heap, XLibrarian, LibOps, String, System, XString;LibPropList: PROGRAM  IMPORTS Heap, String, XString EXPORTS XLibrarian, LibOps =  BEGIN      PropertyListObject: PUBLIC TYPE = LibOps.PropertyListObject;  PropertyList: TYPE = LibOps.PropertyList;  Atom: TYPE = XLibrarian.Atom;  nullAtom: Atom = XLibrarian.nullAtom;  Property: TYPE = XLibrarian.Property;  Value: TYPE = XLibrarian.Value;  nullProp: Property = [nullAtom, [null[]]];  WrongPropertyType: PUBLIC ERROR = CODE;  Error: PUBLIC ERROR [code: XLibrarian.ErrorCode] = CODE;  -- procedures exported to XLibrarian  CreatePropertyList: PUBLIC PROC [z: UNCOUNTED ZONE] RETURNS [PropertyList] = {    RETURN[CreatePL[z, 5]]};  CopyPropertyList: PUBLIC PROC [from: PropertyList]    RETURNS [to: PropertyList] = {    to ¬ CreatePL[from.z, from.list.props.LENGTH];    FOR i: NATURAL IN [0..from.list.props.LENGTH) DO      AddProperty[to, from.list.props[i]];      ENDLOOP};    DestroyPropertyList: PUBLIC PROC [pl: PropertyList] = {    z: UNCOUNTED ZONE = pl.z;    RemoveAllProperties[pl];    FREEProperties[z, @pl.list];    z.FREE[@pl]};  RemoveAllProperties: PUBLIC PROC [pl: PropertyList] = {    FOR i: NATURAL IN [0..pl.list.props.LENGTH) DO      FreePropVal[pl.z, pl.list.props[i].value];      ENDLOOP;    pl.list.props.LENGTH ¬ 0};  EnumerateProperties: PUBLIC PROC [    pl: PropertyList, proc: XLibrarian.PropertyEnumerator] = {    FOR i: NATURAL IN [0..pl.list.props.LENGTH) DO      IF proc[pl.list.props[i]] THEN EXIT;      ENDLOOP};  GetProperty: PUBLIC PROC [plist: PropertyList, tag: Atom]    RETURNS [Property] = {    FOR i: NATURAL IN [0..plist.list.props.LENGTH) DO      bogusCompiler: Atom = plist.list.props[i].tag;      IF tag = bogusCompiler THEN RETURN[plist.list.props[i]];      REPEAT FINISHED => RETURN[nullProp];      ENDLOOP};  RemoveProperty: PUBLIC PROC [plist: PropertyList, tag: Atom] = {    remove: NATURAL;    FOR i: NATURAL IN [0..plist.list.props.LENGTH) DO      bogusCompiler: Atom = plist.list.props[i].tag;      IF tag = bogusCompiler THEN {remove ¬ i; EXIT};      REPEAT FINISHED => RETURN;      ENDLOOP;    FreePropVal[plist.z, plist.list.props[remove].value];    plist.list.props.LENGTH ¬ plist.list.props.LENGTH - 1;    FOR i: NATURAL IN [remove..plist.list.props.LENGTH) DO      plist.list.props[i] ¬ plist.list.props[i+1];      ENDLOOP};-- GetPropertyXXXX returns discriminated values  GetTimeProperty: PUBLIC PROC [plist: PropertyList, tag: Atom]    RETURNS [System.GreenwichMeanTime] = {    WITH v: GetProperty[plist, tag].value SELECT FROM      time => RETURN[v.time];      ENDCASE => ERROR WrongPropertyType};  GetRecordProperty: PUBLIC PROC [plist: PropertyList, tag: Atom]    RETURNS [LONG DESCRIPTOR FOR ARRAY OF WORD] = {    WITH v: GetProperty[plist, tag].value SELECT FROM      client => RETURN[v.record];      ENDCASE => ERROR WrongPropertyType};  GetXStringProperty: PUBLIC PROC [plist: PropertyList, tag: Atom]    RETURNS [XString.Reader] = {    WITH v: GetProperty[plist, tag].value SELECT FROM      xString => RETURN[v.string];      ENDCASE => ERROR WrongPropertyType};  GetXStringsProperty: PUBLIC PROC [plist: PropertyList, tag: Atom]    RETURNS [LONG DESCRIPTOR FOR ARRAY OF XString.Reader] = {    WITH v: GetProperty[plist, tag].value SELECT FROM      xStrings => RETURN[v.strings];      ENDCASE => ERROR WrongPropertyType};  GetStringProperty: PUBLIC PROC [plist: PropertyList, tag: Atom]    RETURNS [LONG STRING] = {    WITH v: GetProperty[plist, tag].value SELECT FROM      string => RETURN[v.string];      ENDCASE => ERROR WrongPropertyType};  GetStringsProperty: PUBLIC PROC [plist: PropertyList, tag: Atom]    RETURNS [LONG DESCRIPTOR FOR ARRAY OF LONG STRING] = {    WITH v: GetProperty[plist, tag].value SELECT FROM      strings => RETURN[v.strings];      ENDCASE => ERROR WrongPropertyType};  GetIntegerProperty: PUBLIC PROC [plist: PropertyList, tag: Atom]    RETURNS [LONG INTEGER] = {    WITH v: GetProperty[plist, tag].value SELECT FROM      integer => RETURN[v.integer];      ENDCASE => ERROR WrongPropertyType};<<	AddProperty assumes that the Property being passed in has had its	values already copied into the proper zone (plist.z). The client can	use one of the AddPropertyXXXX procedures to get a descriminated value	built and copied from the correct zone.>>  AddProperty: PUBLIC PROC [plist: PropertyList, prop: Property] =    BEGIN    slot: NATURAL;    IF plist.list.props.LENGTH > plist.list.maxLength THEN      ERROR Error[implementationBug];    SELECT prop.value.type FROM      null => NULL;      time, integer, client, string, xString, strings, xStrings => NULL;      ENDCASE => ERROR WrongPropertyType;    FOR i: NATURAL IN [0..plist.list.props.LENGTH) DO      IF prop.tag = plist.list.props[i].tag THEN {        slot ¬ i; FreePropVal[plist.z, plist.list.props[i].value]; EXIT};      REPEAT FINISHED => {	IF plist.list.maxLength = plist.list.props.LENGTH THEN {	  props: LibOps.Properties ¬	    NEWProperties[plist.z, plist.list.maxLength + 5];	  props.props.LENGTH ¬ plist.list.props.LENGTH; 	  FOR i: NATURAL IN [0..plist.list.props.LENGTH) DO	    props.props[i] ¬ plist.list.props[i];	    ENDLOOP;	  FREEProperties[plist.z, @plist.list];	  plist.list ¬ props};	slot ¬ plist.list.props.LENGTH;	plist.list.props.LENGTH ¬ plist.list.props.LENGTH + 1};      ENDLOOP;    plist.list.props[slot] ¬ prop;    END;  AddTimeProperty: PUBLIC PROC [    plist: PropertyList, tag: Atom, time: System.GreenwichMeanTime] = {    AddProperty[plist, [tag, [time[time]]]]};  AddIntegerProperty: PUBLIC PROC [    plist: PropertyList, tag: Atom, integer: LONG INTEGER] = {    AddProperty[plist, [tag, [integer[integer]]]]};  AddXStringProperty: PUBLIC PROC [    plist: PropertyList, tag: Atom, string: XString.Reader] = {    s: XString.Reader = XString.CopyReader[string, plist.z];    AddProperty[plist, [tag, [xString[s]]]]};  AddXStringsProperty: PUBLIC PROC [    plist: PropertyList, tag: Atom, strings: XLibrarian.XStrings] = {    s: XLibrarian.XStrings = NEWXStrings[plist.z, strings.LENGTH];    FOR i: NATURAL IN [0..strings.LENGTH) DO      s[i] ¬ XString.CopyReader[strings[i], plist.z];      ENDLOOP;    AddProperty[plist, [tag, [xStrings[s]]]]};  AddStringProperty: PUBLIC PROC [    plist: PropertyList, tag: Atom, string: LONG STRING] = {    s: LONG STRING = String.CopyToNewString[string, plist.z];    AddProperty[plist, [tag, [string[s]]]]};  AddStringsProperty: PUBLIC PROC [    plist: PropertyList, tag: Atom, strings: XLibrarian.Strings] = {    s: XLibrarian.Strings = NEWStrings[plist.z, strings.LENGTH];    FOR i: NATURAL IN [0..strings.LENGTH) DO      s[i] ¬ String.CopyToNewString[strings[i], plist.z];      ENDLOOP;    AddProperty[plist, [tag, [strings[s]]]]};  AddRecordProperty: PUBLIC PROC [    plist: PropertyList, tag: Atom, record: XLibrarian.Record] = {    r: XLibrarian.Record = NEWRecord[plist.z, record.LENGTH];    FOR i: NATURAL IN [0..record.LENGTH) DO r[i] ¬ record[i] ENDLOOP;    AddProperty[plist, [tag, [client[r]]]]};  StringForErrorCode: PUBLIC PROC [code: XLibrarian.ErrorCode, s: LONG STRING] = {    String.AppendString[to: s, from:      SELECT code FROM      insufficientAccess => "user doesn't have access or problem determining access"L,      invalidCredentials => "user identity cannot be authenticated"L,      insufficientAuthentication => "user identity needs to be stronger"L,      authenticationFailure => "authentication has failed somewhere"L,      dataBaseNotFound => "data base doesn't exist on the service"L,      dataBaseUnavailable => "data base is unavailable to perform that operation"L,      serviceFull => "not enough room on the service"L,      serviceInaccessible => "service location can't be determined, e.g. CH is down"L,      serviceNotFound => "service cannot be found"L,      serviceUnavailable => "service found, but it's not cooperating"L,      libjectInconsistent => "libject appears damaged or inconsistent"L,      libjectNotFound => "libject doesn't exist in the data base"L,      libjectCheckedOut => "libject is already checked out"L,      libjectAlreadyExists => "a libject of that name already exists"L,      libjectNotCheckedOut => "can't check in libject; it's not checked out "L,      libjectNotCheckedOutToYou => "can't check in libject; it's not checked out to you"L,      invalidHandle => "handle is trashed or has timed out"L,      nameTooLong, reservedProperty, illegalType, noSuchAtom,      implementationBug => "a librarian implementation bug has been uncovered"L,      ENDCASE => "unknown Error"L ! String.StringBoundsFault => RESUME[NIL]]};-- procedures exported to LibOps  CreatePL: PUBLIC PROC [z: UNCOUNTED ZONE, initialSize: NATURAL ¬ 5]    RETURNS [pl: PropertyList] = {    RETURN[z.NEW[PropertyListObject ¬ [      z, NEWProperties[z, initialSize] ]]]};      NEWRecord: PUBLIC PROC [z: UNCOUNTED ZONE, length: NATURAL]    RETURNS [r: XLibrarian.Record] = {    r.BASE ¬ Heap.MakeNode[z, length*SIZE[WORD]]; r.LENGTH ¬ length};  FREERecord: PUBLIC PROC [    z: UNCOUNTED ZONE, r: LONG POINTER TO XLibrarian.Record] = {    z.FREE[@r­.BASE]; r­.LENGTH ¬ 0};  NEWXStrings: PUBLIC PROC [z: UNCOUNTED ZONE, length: NATURAL]    RETURNS [s: XLibrarian.XStrings] = {    s.BASE ¬ Heap.MakeNode[z, length*SIZE[XString.Reader]]; s.LENGTH ¬ length};  FREEXStrings: PUBLIC PROC [    z: UNCOUNTED ZONE, s: LONG POINTER TO XLibrarian.XStrings] = {    z.FREE[@s­.BASE]; s­.LENGTH ¬ 0};  NEWStrings: PUBLIC PROC [z: UNCOUNTED ZONE, length: NATURAL]    RETURNS [s: XLibrarian.Strings] = {    s.BASE ¬ Heap.MakeNode[z, length*SIZE[LONG STRING]]; s.LENGTH ¬ length};  FREEStrings: PUBLIC PROC [    z: UNCOUNTED ZONE, s: LONG POINTER TO XLibrarian.Strings] = {    z.FREE[@s­.BASE]; s­.LENGTH ¬ 0};  NEWProperties: PUBLIC PROC [z: UNCOUNTED ZONE, length: NATURAL]    RETURNS [p: LibOps.Properties] = {    p.props.BASE ¬ Heap.MakeNode[z, length*SIZE[XLibrarian.Property]];    p.maxLength ¬ length;    p.props.LENGTH ¬ 0};  FREEProperties: PUBLIC PROC [    z: UNCOUNTED ZONE, p: LONG POINTER TO LibOps.Properties] = {    z.FREE[@p.props.BASE]; p.props.LENGTH ¬ 0; p.maxLength ¬ 0};-- utility procedures  FreePropVal: PROC [z: UNCOUNTED ZONE, val: Value] =    BEGIN    WITH v: val SELECT FROM      client => FREERecord[z, @v.record];      xString => XString.FreeReaderBytes[v.string, z];      xStrings => {        FOR i: NATURAL IN [0..v.strings.LENGTH) DO	  XString.FreeReaderBytes[v.strings[i], z];	  ENDLOOP;	FREEXStrings[z, @v.strings]};      string => z.FREE[@v.string];      strings => {        FOR i: NATURAL IN [0..v.strings.LENGTH) DO	  z.FREE[@v.strings[i]];	  ENDLOOP;	FREEStrings[z, @v.strings]};      ENDCASE;    END;      Init: PROC = {};    -- main line code  Init[];  END.  -- of LibPropList  
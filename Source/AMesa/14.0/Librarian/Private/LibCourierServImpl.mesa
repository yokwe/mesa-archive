-- File: LibCourierServImpl.mesa - last edit:-- bjd                 19-Jan-88 15:50:15-- PLK    	30-Mar-84 15:28:18-- Copyright (C) 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved.DIRECTORY  Auth, CH, CHPIDs, Courier, Inline, XLibrarian, LibCourierSvc, LibMessages,  LibOps, LibServOps, NSExec, NSFile, NSName, NSString, Process, Runtime, System, XString;LibCourierServImpl: MONITOR  -- monitor gf.handles sequence and gf.clientCnt;  -- anything changed in this module should also be changed in LibBCImpl, which closely resembles this one;   IMPORTS    Auth, Courier, Inline, XLibrarian, LibCourierSvc,    LibMessages, LibServOps, NSFile, NSName, NSString, Process, Runtime, System, XString  EXPORTS XLibrarian, LibServOps =  BEGIN  PropertyList: TYPE = LONG POINTER TO PropertyListObject;  PropertyListObject: PUBLIC TYPE = LibOps.PropertyListObject;    Service: TYPE = LONG POINTER TO ServiceObject;  ServiceObject: PUBLIC TYPE = LibServOps.ServiceObject;  SV: TYPE = LibServOps.SV;  Session: TYPE = LibCourierSvc.Session;  nullSession: Session = LibCourierSvc.nullSession;    gf: LONG POINTER TO LibServOps.GlobalFrame = @LibServOps.gf;  Sessions: TYPE = LibServOps.Sessions;  potentialTimeOut: NATURAL = 5*60;  -- 5 minutes  -- procedures  MakeUID: PUBLIC PROCEDURE RETURNS [c: CARDINAL] = {   t: LibServOps.Time = LibServOps.Now[];   c ¬ Inline.BITXOR[Inline.LowHalf[t], Inline.HighHalf[t]];   IF c = 0 THEN c ¬ 1};      TimeBetween: PROC [later, earlier: LibServOps.Time]    RETURNS [LONG CARDINAL] = INLINE {    RETURN[System.SecondsSinceEpoch[later] - System.SecondsSinceEpoch[earlier]]};  ServiceForHandle: PROC [handle: XLibrarian.Handle]    RETURNS [Service] = {    WITH s: handle SELECT FROM      service => RETURN[s.service];      ENDCASE => ERROR XLibrarian.Error[implementationBug]};  GetService: PUBLIC ENTRY PROC RETURNS [serv: Service] = {    ENABLE UNWIND => NULL;    slot: Sessions;    now: LibServOps.Time = LibServOps.Now[];    haveOne: BOOLEAN ¬ FALSE;    FOR i: Sessions IN Sessions DO      IF ~gf.handles[i].allocated THEN {haveOne ¬ TRUE; slot ¬ i; EXIT};      ENDLOOP;    IF ~haveOne THEN FOR i: Sessions IN Sessions DO      IF TimeBetween[now, gf.handles[i].lastUse] > potentialTimeOut THEN {	haveOne ¬ TRUE; slot ¬ i; EXIT};      ENDLOOP;    IF ~haveOne THEN ERROR XLibrarian.Error[dataBaseUnavailable];    serv ¬ @gf.handles[slot];    serv.uid ¬ MakeUID[];    serv.allocated ¬ TRUE;    serv.lastUse ¬ now};  EnumerateHandles: PUBLIC ENTRY PROC [    enumProc: LibServOps.EnumHandlesProc] = {    -- client must be careful not to call back into this monitor from enumProc;    ENABLE UNWIND => NULL;    FOR i: Sessions IN Sessions DO      IF ~enumProc[serv: @gf.handles[i]].continue THEN RETURN;      ENDLOOP};  SessionForService: PUBLIC ENTRY PROC [serv: Service]    RETURNS [session: Session] = {    ENABLE UNWIND => NULL;    FOR i: Sessions IN Sessions DO      IF serv = @gf.handles[i] THEN {        session ¬ [i, serv.uid, gf.startId]; EXIT};      REPEAT FINISHED => ERROR XLibrarian.Error[implementationBug];      ENDLOOP};  SVForSession: PUBLIC ENTRY PROC [    session: Session, client: Courier.SystemElement, access: LibServOps.Access,    him: Auth.Verifier]    RETURNS [sv: SV] = {    ENABLE UNWIND => NULL;    IF ~LibServOps.StatusEqualTo[started] THEN      ERROR XLibrarian.Error[serviceUnavailable];    IF session = nullSession THEN ERROR XLibrarian.Error[invalidHandle];    IF session.index >= LibServOps.maxSessions THEN      ERROR XLibrarian.Error[invalidHandle];    sv.serv ¬ @gf.handles[session.index];    IF session.startId # gf.startId THEN ERROR XLibrarian.Error[invalidHandle];    IF sv.serv.uid # session.uid THEN ERROR XLibrarian.Error[invalidHandle];    IF sv.serv.client # client THEN ERROR XLibrarian.Error[invalidHandle];    IF sv.serv.access < access THEN ERROR XLibrarian.Error[insufficientAccess];    IF Auth.GetFlavor[sv.serv.credentials]=strong THEN      sv.ver ¬ Auth.Authenticate[	recipient: gf.serverId, credentialsToCheck: sv.serv.credentials,	verifierToCheck: him, z: gf.z, initiator: NIL,        expiredCredsOK: TRUE, checkSimpleCreds: FALSE !	  Auth.AuthenticationError => ERROR XLibrarian.Error[authenticationFailure]]    ELSE sv.ver ¬ Auth.nullVerifier; -- simple: for now just return null;    sv.serv.lastUse ¬ LibServOps.Now[]};   XStringFromNSName: PROC [name: NSName.Name, z: UNCOUNTED ZONE]    RETURNS [XString.ReaderBody] = {    s: NSString.String ¬ NSString.MakeString[      z: z, bytes: name.org.length+name.domain.length+name.local.length + 2];    s ¬ NSName.AppendNameToString[s, name];    RETURN[XString.FromNSString[s]]};  --Dispatching to Local Procedures  SimpleCalls: TYPE = {create, destroy, out, in};  GetCalls: TYPE = {query, queryAndOut};  SetCalls: TYPE = {set, setAndIn};    lowVersionDispatcher: Courier.Dispatcher;  highVersionDispatcher: Courier.Dispatcher;  SetDispatcher: PUBLIC PROC [    versionSupported: CARDINAL, proc: Courier.Dispatcher] = {    SELECT versionSupported FROM      LibCourierSvc.lowVersion => lowVersionDispatcher ¬ proc;      LibCourierSvc.highVersion => highVersionDispatcher ¬ proc;      ENDCASE => RaiseError[implementationBug]};  Dispatcher: PUBLIC Courier.Dispatcher =    BEGIN    ENABLE UNWIND => DecrementClientUsers[];    -- dispatch to appropriate dispatcher proc;    IncrementClientUsers[];    SELECT cH.versionNumber FROM      LibCourierSvc.lowVersion  => 	lowVersionDispatcher[cH, procedureNumber, arguments, results];      LibCourierSvc.highVersion  => 	highVersionDispatcher[cH, procedureNumber, arguments, results];      ENDCASE => RaiseError[implementationBug];    DecrementClientUsers[];    END;  --Dispatcher      CurrentDispatcher: Courier.Dispatcher =    BEGIN    ENABLE {      Courier.Error => RaiseError[serviceUnavailable];      XLibrarian.Error => RaiseError[code];      NSFile.Error => IF error = [space[mediumFull]] THEN RaiseError[serviceFull]};    index: LibCourierSvc.RemoteProcedures;    IF procedureNumber ~IN [0..LibCourierSvc.RemoteProcedures.LAST.ORD] THEN      ERROR Courier.NoSuchProcedureNumber;    index ¬ VAL[procedureNumber];	-- can't do earlier because of potential bounds fault    SELECT index FROM      create => SimpleCall[create, cH, arguments, results];      destroy => SimpleCall[destroy, cH, arguments, results];      query => GetCall[query, cH, arguments, results];      checkOut => SimpleCall[out, cH, arguments, results];      checkIn => SimpleCall[in, cH, arguments, results];      setProperties => SetCall[set, cH, arguments, results];      queryAndCheckOut => GetCall[queryAndOut, cH, arguments, results];      setPropertiesAndCheckIn => SetCall[setAndIn, cH, arguments, results];      openDataBase => OpenDataBase[cH, arguments, results];      closeDataBase => CloseDataBase[cH, arguments, results];      makeAtom => MakeAtom[cH, arguments, results];      stringForAtom => StringForAtom[cH, arguments, results];      nextCheckedOut => NextLibject[cH, arguments, results];      ENDCASE;    END;  -- CurrentDispatcher      StartUpService: PUBLIC PROCEDURE = {    LibServOps.StartFiles[];    Courier.ExportRemoteProgram[      programNumber:  LibCourierSvc.program,      versionRange:   LibCourierSvc.versionRange,      dispatcher:     LibServOps.Dispatcher,      serviceName:    "Librarian Service of 1986"L,      zone:           gf.z,       classOfService: transactional       ! Courier.Error => CONTINUE]}; --ignore if already exported  TakeDownService: PUBLIC PROCEDURE [stopMode: NSExec.StopMode] = {    Courier.UnexportRemoteProgram[      programNumber: LibCourierSvc.program,      versionRange: LibCourierSvc.versionRange       ! Courier.Error => CONTINUE]; -- ignore if not exported    AllowCurrentClientCallsToComplete[];  -- do this for all stop modes for now;    LibServOps.StopFiles[]};  -- client count monitor  secsToWait: Process.Seconds = 1;  aBit: CONDITION;  IncrementClientUsers: ENTRY PROC = {    gf.clientCnt ¬ gf.clientCnt + 1};  DecrementClientUsers: ENTRY PROC = {    gf.clientCnt ¬ gf.clientCnt - 1};  AllowCurrentClientCallsToComplete: ENTRY PROC =    -- allow all others to finish;    BEGIN    ENABLE UNWIND => NULL;    WHILE gf.clientCnt > 0 DO      WAIT aBit; ENDLOOP;    END;    -- protocol operations  SimpleCall: PROC [    which: SimpleCalls, cH: Courier.Handle,    args: Courier.Arguments, res: Courier.Results] = {    sv: SV ¬ [NIL, NIL];    simple: LibCourierSvc.SimpleArguments;    Cleanup: PROC = {      Courier.Free[	parameters: [@simple, LibCourierSvc.DescribeSimpleArguments],	zone: gf.z];      Auth.FreeVerifier[@sv.ver, gf.z]};    args[[@simple, LibCourierSvc.DescribeSimpleArguments]];    {ENABLE UNWIND => Cleanup[];    sv ¬ SVForSession[simple.session, cH.remote, write, simple.verifier];    IF XString.Empty[simple.libject] THEN ERROR XLibrarian.Error[libjectNotFound];     SELECT which FROM      create => XLibrarian.Create[[service[sv.serv]], simple.libject];      destroy => XLibrarian.Destroy[[service[sv.serv]], simple.libject];      in => XLibrarian.CheckIn[[service[sv.serv]], simple.libject];      out => XLibrarian.CheckOut[[service[sv.serv]], simple.libject];      ENDCASE;    [] ¬ res[[@sv.ver, Auth.DescribeVerifier]];    Cleanup[]};    };      OpenDataBase: PROC [    cH: Courier.Handle, args: Courier.Arguments, res: Courier.Results] = {    ENABLE Auth.AuthenticationError, Auth.CallError =>      RaiseError[authenticationFailure];    oa: LibCourierSvc.OpenArguments;    or: LibCourierSvc.OpenResults ¬ [replyVerifier: NIL, session: TRASH];    initiator: NSName.Name ¬ NSName.MakeName[gf.z];    service: Service;    Cleanup: PROC = {      NSName.FreeName[gf.z, initiator];      Courier.Free[	parameters: [@oa, LibCourierSvc.DescribeOpenArguments],	zone: gf.z];      Auth.FreeVerifier[@or.replyVerifier, gf.z]};    args[[@oa, LibCourierSvc.DescribeOpenArguments]];    {ENABLE UNWIND => Cleanup[];    or.replyVerifier ¬ Auth.Authenticate[      recipient: gf.serverId, credentialsToCheck: oa.cred,      verifierToCheck: oa.verifier, initiator: initiator, z: gf.z];    service ¬ ServiceForHandle[XLibrarian.Open[oa.dataBase, gf.z]];    or.session ¬ SessionForService[service];    service.client ¬ cH.remote;    service.user ¬ XStringFromNSName[initiator, gf.z];    IF LibServOps.TracingOn[] THEN {      db: NSString.String ¬ XString.NSStringFromReader[oa.dataBase, gf.z];      user: NSString.String ¬ XString.NSStringFromReader[@service.user, gf.z];      message: NSString.String ¬ LibMessages.ExpandMsg[        z: gf.z, template: LibMessages.M[keyOpeningSession], s1: db, s2: user];      LibMessages.NoteEvent[message];      NSString.FreeString[gf.z, db];      NSString.FreeString[gf.z, user];      NSString.FreeString[gf.z, message]};    IF Auth.GetFlavor[oa.cred] = simple AND      service.h.header.minAuthentication = strong THEN	ERROR XLibrarian.Error[insufficientAuthentication];    service.access ¬ LibServOps.GetAccess[      h: service.h, client: initiator, creds: oa.cred];    service.credentials ¬ Auth.CopyCredentials[oa.cred, gf.z];    [] ¬ res[[@or, LibCourierSvc.DescribeOpenResults]];    Cleanup[]};    };      CloseDataBase: PROC [    cH: Courier.Handle,args: Courier.Arguments, res: Courier.Results] = {    sv: SV ¬ [NIL, NIL];    ca: LibCourierSvc.CloseArguments;    Cleanup: PROC = {      Courier.Free[	parameters: [@ca, LibCourierSvc.DescribeCloseArguments],	zone: gf.z]};    args[[@ca, LibCourierSvc.DescribeCloseArguments]];    {ENABLE UNWIND => Cleanup[];    sv ¬ SVForSession[ca.session, cH.remote, read, ca.verifier];    IF LibServOps.TracingOn[] THEN {      message: NSString.String;      user: NSString.String;      which: NATURAL = sv.serv.h.index;      user ¬ XString.NSStringFromReader[z: gf.z, r: @sv.serv.user];      message ¬ LibMessages.ExpandMsg[        gf.z, LibMessages.M[keyClosingSession], gf.dataBases[which].nameRoot, user];      LibMessages.NoteEvent[message];      NSString.FreeString[gf.z, user];      NSString.FreeString[gf.z, message]};    XString.FreeReaderBytes[r: @sv.serv.user, z: gf.z];    Auth.FreeCredentials[@sv.serv.credentials, gf.z];    Auth.FreeVerifier[@sv.ver, gf.z];    XLibrarian.Close[[service[sv.serv]]];    [] ¬ res[];    Cleanup[]};    };      MakeAtom: PROC [    cH: Courier.Handle, args: Courier.Arguments, res: Courier.Results] = {    sv: SV ¬ [NIL, NIL];    maa: LibCourierSvc.MakeAtomArguments;    mar: LibCourierSvc.MakeAtomResults;    Cleanup: PROC = {      Courier.Free[	parameters: [@maa, LibCourierSvc.DescribeMakeAtomArguments],	zone: gf.z];      Auth.FreeVerifier[@sv.ver, gf.z]};    args[[@maa, LibCourierSvc.DescribeMakeAtomArguments]];    {ENABLE UNWIND => Cleanup[];    sv ¬ SVForSession[maa.session, cH.remote, read, maa.verifier];    -- maybe this wants to be write, but the readers can't do much if    -- they can't make the atoms so that they can do the query.    mar ¬ [XLibrarian.MakeAtom[[service[sv.serv]], maa.tag], sv.ver];    [] ¬ res[[@mar, LibCourierSvc.DescribeMakeAtomResults]];    Cleanup[]};    };      StringForAtom: PROC [    cH: Courier.Handle,args: Courier.Arguments, res: Courier.Results] = {    sv: SV ¬ [NIL, NIL];    gpna: LibCourierSvc.GetPrintNameArguments;    gpnr: LibCourierSvc.GetPrintNameResults ¬ [NIL, NIL];    Cleanup: PROC = {      Courier.Free[	parameters: [@gpna, LibCourierSvc.DescribeGetPrintNameArguments],	zone: gf.z];      Auth.FreeVerifier[@sv.ver, gf.z];      IF gpnr.s # NIL THEN gf.z.FREE[@gpnr.s]};    args[[@gpna, LibCourierSvc.DescribeGetPrintNameArguments]];    {ENABLE UNWIND => Cleanup[];    sv ¬ SVForSession[gpna.session, cH.remote, read, gpna.verifier];    gpnr ¬ [XLibrarian.GetPrintName[[service[sv.serv]], gpna.tag], sv.ver];    [] ¬ res[[@gpnr, LibCourierSvc.DescribeGetPrintNameResults]];    Cleanup[]};    };      NextLibject: PROC [    cH: Courier.Handle,args: Courier.Arguments, res: Courier.Results] = {    sv: SV ¬ [NIL, NIL];    next: XString.ReaderBody;    ncoa: LibCourierSvc.NextLibjectArguments;    ncor: LibCourierSvc.NextLibjectResults;    Cleanup: PROC = {      Courier.Free[	parameters: [@ncoa, LibCourierSvc.DescribeNextLibjectArguments],	zone: gf.z];      Auth.FreeVerifier[@sv.ver, gf.z]};    args[[@ncoa, LibCourierSvc.DescribeNextLibjectArguments]];    {ENABLE UNWIND => Cleanup[];    sv ¬ SVForSession[ncoa.session, cH.remote, read, ncoa.verifier];    next ¬ XLibrarian.NextLibject[      [service[sv.serv]], ncoa.current, ncoa.mask,      ncoa.onlyIfCheckedOut, ncoa.user];    ncor ¬ IF XString.Empty[@next]     THEN [XString.nullReaderBody, sv.ver] ELSE [next, sv.ver];    [] ¬ res[[@ncor, LibCourierSvc.DescribeNextLibjectResults]];    XString.FreeReaderBytes[z: gf.z, r: @next];    Cleanup[]};    };      GetCall: PROC [    which: GetCalls, cH: Courier.Handle,    args: Courier.Arguments, res: Courier.Results] = {    sv: SV ¬ [NIL, NIL];    plist: PropertyList ¬ NIL;    isCheckedOut: BOOLEAN ¬ TRUE;    getArgs: LibCourierSvc.QueryArguments;    getRes: LibCourierSvc.QueryResults;    Cleanup: PROC = {      IF plist # NIL THEN XLibrarian.DestroyPropertyList[plist];      Courier.Free[	parameters: [@getArgs, LibCourierSvc.DescribeQueryArguments],	zone: gf.z];      Auth.FreeVerifier[@sv.ver, gf.z]};    args[[@getArgs, LibCourierSvc.DescribeQueryArguments]];    {ENABLE UNWIND => Cleanup[];    sv ¬ SVForSession[getArgs.session, cH.remote, read, getArgs.verifier];    SELECT which FROM      query =>        [plist, isCheckedOut] ¬ XLibrarian.Query[	  [service[sv.serv]], getArgs.libject, getArgs.atoms];      queryAndOut =>	plist ¬ XLibrarian.QueryAndCheckOut[	  [service[sv.serv]], getArgs.libject, getArgs.atoms];      ENDCASE;    getRes ¬ [plist.list, isCheckedOut, sv.ver];    [] ¬ res[[@getRes, LibCourierSvc.DescribeQueryResults]];    Cleanup[]};    };      SetCall: PROC [    which: SetCalls, cH: Courier.Handle,    args: Courier.Arguments, res: Courier.Results] = {    sv: SV ¬ [NIL, NIL];    plist: PropertyListObject;    setArgs: LibCourierSvc.SetPropertiesArguments;    Cleanup: PROC = {      Courier.Free[	parameters: [@setArgs, LibCourierSvc.DescribeSetPropertiesArguments],	zone: gf.z];      Auth.FreeVerifier[@sv.ver, gf.z]};    args[[@setArgs, LibCourierSvc.DescribeSetPropertiesArguments]];    {ENABLE UNWIND => Cleanup[];    sv ¬ SVForSession[setArgs.session, cH.remote, write, setArgs.verifier];    plist ¬ [gf.z, setArgs.plist];    SELECT which FROM      set => XLibrarian.SetProperties[[service[sv.serv]], setArgs.libject, @plist];      setAndIn =>	XLibrarian.SetPropertiesAndCheckIn[	  [service[sv.serv]], setArgs.libject, @plist];      ENDCASE;    [] ¬ res[[@sv.ver, Auth.DescribeVerifier]];    Cleanup[]};    };    -- The SACheckIn procedure is isolated in the sense that it is the only proc that calls through XLibrarian and is initiated by an SA at the server tty, and not by the stub. this raises XLibrarian.Error.  SACheckIn: PUBLIC PROCEDURE [   database, libject: NSString.String, user: NSName.Name] = {    xDatabase: XString.ReaderBody ¬ XString.FromNSString[database];    xLibject: XString.ReaderBody ¬ XString.FromNSString[libject];    handle: XLibrarian.Handle ¬ XLibrarian.Open[@xDatabase, gf.z];    service: Service ¬ ServiceForHandle[handle];    service.user ¬ XStringFromNSName[user, gf.z];    service.access ¬ administrator;    XLibrarian.CheckIn[handle, @xLibject];    XLibrarian.Close[handle]};      RaiseError: PROC [why: XLibrarian.ErrorCode] = {    IF why = implementationBug THEN      Runtime.CallDebugger["Service doesn't work."L];    ERROR Courier.SignalRemoteError[why.ORD, Courier.nullParameters]}; -- MAINLINE  Init: PROC ={    Process.SetTimeout[@aBit, Process.SecondsToTicks[secsToWait]];    SetDispatcher[LibCourierSvc.highVersion, CurrentDispatcher]};   Init[];    END.    
-- File: LibServUtils.mesa - last edit:-- bjd                 23-Jun-87 19:15:23-- PLK    	 3-Apr-84 14:27:01-- Copyright (C) 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved.    DIRECTORY  ByteBlt, Environment, XLibrarian, LibOps, LibServOps, Heap, Inline, PilotSwitches, String, System;LibServUtils: PROGRAM  IMPORTS ByteBlt, Heap, Inline, XLibrarian, LibServOps, String, System  EXPORTS XLibrarian, LibServOps =  BEGIN      Atom: PUBLIC TYPE = LibServOps.Atom;  nullAtom: Atom = XLibrarian.nullAtom;  ServiceObject: PUBLIC TYPE = LibServOps.ServiceObject;  Service: TYPE = LibServOps.Service;  AtomHandle: TYPE = LibServOps.AtomHandle;  DataBase: TYPE = LibServOps.DataBase;  heapChecking: BOOLEAN = System.switches[PilotSwitches.heapOwnerChecking]=down;  charZone: UNCOUNTED ZONE =    Heap.Create[initial: 8, swapUnitSize: 4, increment: 4];  nodeZone: UNCOUNTED ZONE = Heap.CreateUniform[    initial: 8, swapUnitSize: 4, increment: 4,    objectSize: LibServOps.AtomNode.SIZE];  names: CARDINAL ¬ 0; -- for instrumentation  changeTime: PUBLIC Atom;  -- constant accross all services  checkOutUser: PUBLIC Atom;  bpp: NATURAL = Environment.bytesPerPage;  wpp: NATURAL = Environment.wordsPerPage;  bpw: NATURAL = Environment.bytesPerWord;    gf: LONG POINTER TO LibServOps.GlobalFrame = @LibServOps.gf;    FindString: PROCEDURE [    h: DataBase, block: Environment.Block, forceAtom: Atom]    RETURNS [hh: LONG POINTER TO AtomHandle, pn: Atom] =    BEGIN    forced: BOOLEAN = (forceAtom # nullAtom);    length: NATURAL = block.stopIndexPlusOne - block.startIndex;    incr: CARDINAL;    IF length = 0 THEN RETURN[NIL, nullAtom];    IF length >= LibServOps.maxTagLength THEN ERROR XLibrarian.Error[nameTooLong];    IF forced THEN pn ¬ forceAtom    ELSE {incr ¬ 1; pn ¬ Hash[block]};    DO  -- try to see if this hash is free or there is a match      hh ¬ @h.rootAtom;      DO	IF hh­ = NIL THEN RETURN[hh, pn];	SELECT pn FROM	  < hh.pn => hh ¬ @hh.left;	  > hh.pn => hh ¬ @hh.right;	  ENDCASE => {	    IF forced THEN ERROR XLibrarian.Error[implementationBug];	    IF Equivalent[block, StringBlock[hh.string]] THEN RETURN[hh, pn];	    EXIT};	ENDLOOP;      pn ¬ [pn + incr];      IF pn = nullAtom THEN pn ¬ [1];      incr ¬ incr + 1;      ENDLOOP;    END;      AddAtom: PROCEDURE [    h: DataBase, block: Environment.Block, forceAtom: Atom]    RETURNS [atom: Atom, isNew: BOOLEAN] = {    handleAtomHandle: LONG POINTER TO AtomHandle;    s: LONG STRING;    [handleAtomHandle, atom] ¬ FindString[h, block, forceAtom];    isNew ¬ FALSE;    IF atom = nullAtom THEN RETURN;    IF handleAtomHandle­ # NIL THEN RETURN[handleAtomHandle.pn, FALSE];    isNew ¬ TRUE;    s ¬ charZone.NEW[StringBody[block.stopIndexPlusOne - block.startIndex]];    s.length ¬ ByteBlt.ByteBlt[      overLap: move, from: block, to: [LOOPHOLE[@s.text], 0, s.maxlength]];    handleAtomHandle­ ¬ nodeZone.NEW[LibServOps.AtomNode ¬ [      pn: atom, string: s, left: NIL, right: NIL]]};      FindAtom: PROCEDURE [h: DataBase, tag: Atom]    RETURNS [AtomHandle] = {    node: AtomHandle ¬ h.rootAtom;<<    IF tag = nullAtom THEN RETURN[NIL];	Since nullAtom is not in the tree anyway, there is no point in adding	code to make the special case faster.>>    WHILE node # NIL DO      SELECT tag FROM        < node.pn => node ¬ node.left;	> node.pn => node ¬ node.right;	ENDCASE => RETURN[node];      ENDLOOP;    ERROR XLibrarian.Error[noSuchAtom]};        FreeNode: PROCEDURE [node: LONG POINTER TO LibServOps.AtomHandle] =    BEGIN    IF node.left # NIL THEN FreeNode[@node.left];    IF node.right # NIL THEN FreeNode[@node.right];    charZone.FREE[@node.string];    nodeZone.FREE[node];    END;    -- exported to LibServOps;  these must be called from within MonitorOperation  EnterAtom: PUBLIC PROCEDURE [    h: DataBase, tag: Atom, string: Environment.Block] =    BEGIN    actualTag: Atom;    madeNew: BOOLEAN;    IF tag = nullAtom THEN ERROR XLibrarian.Error[implementationBug];    [actualTag, madeNew] ¬ AddAtom[h, string, tag];    IF actualTag # tag THEN ERROR XLibrarian.Error[implementationBug];    IF ~madeNew THEN ERROR XLibrarian.Error[implementationBug];    END;      FreeAtoms: PUBLIC PROCEDURE [h: DataBase] =    BEGIN    IF h.rootAtom # NIL THEN FreeNode[@h.rootAtom]    END;      AddAtomToFile: PUBLIC PROCEDURE [    h: DataBase, service: Service, tag: Atom, pName: LONG STRING] = {    ENABLE UNWIND => LibServOps.MakeClean[h];    prop: ARRAY [0..1) OF XLibrarian.Property ¬ [[tag, [null[]]]];    pages: CARDINAL = h.header.names.length;    Bytes: TYPE = LONG POINTER TO PACKED ARRAY CARDINAL OF Environment.Byte;    bytes: Bytes;    freeByte: CARDINAL;    LibServOps.IsDirty[h];    h.dirtyAtoms ¬ TRUE;    IF h.names.freeByte + pName.length + SIZE[LibServOps.AtomsObject[0]]*bpw >=       pages*bpp THEN {      newNames: LONG POINTER TO LibServOps.AtomsObject =         LibServOps.GetSpace[pages + 1];      LibServOps.FreeRun[h, h.header.names];      h.header.names ¬ LibServOps.AllocateRun[h, pages + 1];      Inline.LongCOPY[from: h.names, to: newNames, nwords: pages*wpp];      LibServOps.FreeSpace[h.names];      h.names ¬ newNames};    -- the following subterfuge is to prevent indexing by a LONG CARDINAL    freeByte ¬ IF (h.names.freeByte MOD 2) = 0 THEN 0 ELSE 1;    bytes ¬ LOOPHOLE[@h.names.bytes, Bytes] + h.names.freeByte/2;    bytes[freeByte] ¬ Inline.HighByte[tag];    bytes[freeByte + 1] ¬ Inline.LowByte[tag];    bytes[freeByte + 2] ¬ pName.length;    FOR i: CARDINAL IN [0..pName.length) DO      bytes[i + freeByte + 3] ¬ pName[i].ORD      ENDLOOP;    h.names.freeByte ¬ h.names.freeByte + pName.length + 3;    h.names.count ¬ h.names.count + 1;    LibServOps.NoteTransaction[h, service, newAtom, NIL, DESCRIPTOR[prop], pName];    LibServOps.MakeClean[h]};-- exported to XLibrarian  MakeAtom: PUBLIC PROCEDURE [handle: XLibrarian.Handle, s: LONG STRING]    RETURNS [tag: Atom] = {    madeIt: BOOLEAN;    serv: Service = ServiceForHandle[handle];    makeAtom: LibServOps.EntryProcType = {      [tag, madeIt] ¬ AddAtom[serv.h, StringBlock[s], nullAtom];      IF madeIt THEN AddAtomToFile[serv.h, serv, tag, s]};    LibServOps.MonitorOperation[proc: makeAtom, access: write, dbIndex: serv.h.index]};      GetPrintName: PUBLIC PROCEDURE [handle: XLibrarian.Handle, tag: Atom]    RETURNS [LONG STRING] = {    s: LONG STRING ¬ NIL;    serv: Service = ServiceForHandle[handle];    getPrintName: LibServOps.EntryProcType = {      IF tag = nullAtom THEN s ¬ NIL      ELSE s ¬ String.CopyToNewString[FindAtom[serv.h, tag].string, gf.z]};    LibServOps.MonitorOperation[      proc: getPrintName, access: read, dbIndex: serv.h.index];    RETURN[s]};      -- utility procedures  ServiceForHandle: PROC [handle: XLibrarian.Handle] RETURNS [Service] = {    WITH s: handle SELECT FROM      service => RETURN[s.service];      ENDCASE => ERROR XLibrarian.Error[invalidHandle]};      Hash: PROC [b: Environment.Block] RETURNS [atom: Atom] = {    t1: CARDINAL ¬ 0;    t2: CARDINAL ¬ 1;    FOR i: CARDINAL IN [b.startIndex..b.stopIndexPlusOne) DO      c: Environment.Byte = Upper[b.blockPointer[i]];      t2 ¬ t2 * 31 + c;      t1 ¬ t1 + c;      ENDLOOP;    atom ¬ [Inline.BITXOR[t1, t2]];    IF atom = nullAtom THEN atom ¬ [1]};    StringBlock: PROC [s: LONG STRING] RETURNS [Environment.Block] = INLINE {    RETURN[[LOOPHOLE[@s.text], 0, s.length]]};    Upper: PROC [byte: Environment.Byte] RETURNS [Environment.Byte] = INLINE {    RETURN[IF byte IN [141B..172B] THEN byte - 40B ELSE byte]};    Equivalent: PROC [b1, b2: Environment.Block] RETURNS [BOOLEAN] = {    count: NATURAL = b1.stopIndexPlusOne - b1.startIndex;    IF count # (b2.stopIndexPlusOne - b2.startIndex) THEN RETURN[FALSE];    FOR i: NATURAL IN [0..count) DO      IF Upper[b1.blockPointer[b1.startIndex + i]] #	 Upper[b2.blockPointer[b2.startIndex + i]] THEN RETURN[FALSE];      ENDLOOP;    RETURN[TRUE]};  -- main line code;  Init: PROC = {    changeTime ¬ Hash[StringBlock["ChangeTime"L]];    checkOutUser ¬ Hash[StringBlock["CheckOutUser"L]]};      Init[];    END.  -- of LibServUtils  
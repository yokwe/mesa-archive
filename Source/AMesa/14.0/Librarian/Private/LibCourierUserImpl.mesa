-- File: LibCourierUserImpl.mesa - last edit:-- bjd                 29-Sep-86 12:32:25-- djw                  7-May-85 12:01:13-- plk	 		4-Apr-84 16:28:51-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  AccessCH USING [EnumerateProc, Problem, ProblemType],  Auth,  Courier USING [Call, Create, Delete, Description, Error, Free, Handle, RemoteErrorSignalled, VersionMismatch],  LibProfile USING [    ErrorCode, GetDefaultCHName, GetIdentity, LookupAddress, LookupError],  LibCourier USING [ClientObject, CloseArguments, DescribeCloseArguments, DescribeGetPrintNameArguments, DescribeGetPrintNameResults, DescribeMakeAtomArguments, DescribeMakeAtomResults, DescribeNextLibjectArguments, DescribeNextLibjectResults, DescribeOpenArguments, DescribeOpenResults, DescribeQueryArguments, DescribeQueryResults, DescribeSetPropertiesArguments, DescribeSimpleArguments, GetPrintNameArguments, GetPrintNameResults, highVersion, MakeAtomArguments, MakeAtomResults, NextLibjectArguments, NextLibjectResults, OpenArguments, OpenResults, program, QueryArguments, QueryResults, RemoteProcedures, SetPropertiesArguments, SimpleArguments],  LibDBCache USING [EnumerateServices],  LibOps USING [PropertyListObject],  XLibrarian USING [Atom, Atoms, Client, ClientObject, Error, Handle],  LibrarianExtra USING [],  NSName USING [CopyName, Error, FreeName, Name, NameFromString, NameRecord, String],  NSString,  System USING [NetworkAddress],  XString;LibCourierUserImpl: MONITOR  IMPORTS AccessCH, Auth, Courier, LibDBCache, XLibrarian, LibProfile, LibCourier, NSName, NSString, XString  EXPORTS XLibrarian, LibrarianExtra =  BEGIN      Handle: TYPE = XLibrarian.Handle;  Client: TYPE = LONG POINTER TO ClientObject;  ClientObject: PUBLIC TYPE = LibCourier.ClientObject;  Atom: TYPE = XLibrarian.Atom;  Atoms: TYPE = XLibrarian.Atoms;  PropertyList: TYPE = LONG POINTER TO PropertyListObject;  PropertyListObject: PUBLIC TYPE = LibOps.PropertyListObject;    CoveredProc: TYPE = PROC [client: Client, ver: Auth.Verifier]    RETURNS [reply: Auth.Verifier];  -- procedures  magicCookie: XString.Character = ORD['#];  Open: PUBLIC PROC [    dataBase: XString.Reader, zone: UNCOUNTED ZONE] RETURNS [h: Handle] =    BEGIN    service: NSName.Name ¬ NIL;    breakChar: XString.Character;    svc: XString.ReaderBody;    [breakChar, svc] ¬ XString.ScanForCharacter[      r: dataBase, char: magicCookie, option: ignore];    IF  breakChar=magicCookie THEN { -- hack syntax for directed open;      ENABLE UNWIND =>         IF service#NIL THEN NSName.FreeName[zone, service];      service ¬ MakeFullNameWithDefaults[shortName: @svc, z: zone];      h ¬        GeneralOpen[dataBase: dataBase, zone: zone, service: service];      NSName.FreeName[zone, service]}    ELSE { -- since magicCookie wasn't found, svc now holds the db name      dataBase­ ¬ svc;      h ¬ GeneralOpen[dataBase: dataBase, zone: zone, service: NIL]};    RETURN[h];    END;  DirectedOpen: PUBLIC PROC [    dataBase: XString.Reader, service: NSName.Name ¬ NIL, zone: UNCOUNTED ZONE]    RETURNS [Handle] =    BEGIN    RETURN[GeneralOpen[dataBase: dataBase, zone: zone, service: service]];    END;  GetServiceName: PUBLIC PROCEDURE [handle: XLibrarian.Handle]    RETURNS [service: NSName.Name] = {RETURN[ClientForHandle[handle].service]};  Probe: PUBLIC PROCEDURE [XLibrarian.Handle] -- RETURNS [timeOut: CARDINAL] -- =  BEGIN  END;      GeneralOpen: PROC [    dataBase: XString.Reader, service: NSName.Name ¬ NIL, zone: UNCOUNTED ZONE]    RETURNS [Handle] =    BEGIN    OpenLibrarian: AccessCH.EnumerateProc = {     -- PROCEDURE [currentName: CH.Element] RETURNS [continue: BOOLEAN] = {      client.host ¬ LibProfile.LookupAddress[name: currentName, id: user];      client.courier ¬ Courier.Create[	remote: client.host,	programNumber: LibCourier.program,	versionNumber: LibCourier.highVersion,	zone: zone,	classOfService: transactional];      client.service ¬ NSName.CopyName[z: zone, name: currentName];      continue ¬ FALSE};    CopyId: PROCEDURE [id: Auth.IdentityHandle] = {      user ¬ Auth.CopyIdentity[id, zone]};	    args: LibCourier.OpenArguments;    results: LibCourier.OpenResults;    client: Client;    localName: XString.ReaderBody;    user: Auth.IdentityHandle ¬ NIL;    dbName: NSName.Name ¬ NIL;    {ENABLE {      LibProfile.LookupError => LibProfileError[code];      AccessCH.Problem => AccessCHError[type];      Auth.CallError => AuthCallError[reason, whichArg];      Auth.AuthenticationError => AuthenticationError[reason];      Courier.VersionMismatch, Courier.Error =>        ERROR XLibrarian.Error[serviceUnavailable];      Courier.RemoteErrorSignalled => ERROR XLibrarian.Error[VAL[errorNumber]];      UNWIND => {        IF dbName#NIL THEN NSName.FreeName[zone, dbName];        IF user#NIL THEN Auth.FreeIdentity[@user, zone]}};    LibProfile.GetIdentity[flavor: simple, proc: CopyId];    IF user = NIL THEN ERROR XLibrarian.Error[invalidCredentials];    client ¬ zone.NEW[ClientObject ¬ [zone: zone, user: user]];    dbName ¬ MakeFullNameWithDefaults[shortName: dataBase, z: zone];    IF service#NIL THEN [] ¬ OpenLibrarian[service]    ELSE      LibDBCache.EnumerateServices[	dbName: dbName, enumProc: OpenLibrarian, userId: user];    client.conv ¬ Auth.Initiate[      identity: user, recipientsName: client.service,      recipientsHostNumber: client.host.host, z: zone];    localName ¬ XString.FromNSString[dbName.local];    args.dataBase ¬ @localName;    [args.cred, args.verifier] ¬ Auth.CheckOutCredsAndNextVerifier[      client.conv, client.host.host];    [] ¬ Courier.Call[      cH: client.courier,      procedureNumber: LibCourier.RemoteProcedures.openDataBase.ORD,      arguments: [@args, LibCourier.DescribeOpenArguments],      results: [@results, LibCourier.DescribeOpenResults]];    client.session ¬ results.session;    IF ~Auth.ReplyVerifierChecks[client.conv, results.replyVerifier] THEN      ERROR XLibrarian.Error[implementationBug];    Courier.Free[[@results, LibCourier.DescribeOpenResults], zone];    Auth.FreeIdentity[@user, zone];    NSName.FreeName[zone, dbName];    RETURN[[client[client]]]    };    END;      Close: PUBLIC PROC [handle: Handle] =    BEGIN    thisClient: Client;    CloseIt: CoveredProc =      BEGIN      args: LibCourier.CloseArguments;      thisClient ¬ client;      args.session ¬ client.session;      args.verifier ¬ ver;      [] ¬ Courier.Call[	cH: client.courier,	procedureNumber: LibCourier.RemoteProcedures.closeDataBase.ORD,	arguments: [@args, LibCourier.DescribeCloseArguments]];      reply ¬ Auth.nullVerifier;      END;    z: UNCOUNTED ZONE;    Call[handle, CloseIt ! XLibrarian.Error =>      IF code = invalidHandle THEN CONTINUE];    z ¬ thisClient.zone;    Courier.Delete[thisClient.courier];    Auth.Terminate[@thisClient.conv, z];    NSName.FreeName[z: z, name: thisClient.service];    z.FREE[@thisClient];    END;  NextLibject: PUBLIC PROC [     handle: Handle, current, mask: XString.Reader,     onlyIfCheckedOut: BOOLEAN, user: XString.Reader]    RETURNS [next: XString.ReaderBody] =    BEGIN    NextIt: CoveredProc =      BEGIN      args: LibCourier.NextLibjectArguments ¬ [	client.session, ver, current, mask, onlyIfCheckedOut, user];      [] ¬ Courier.Call[	cH: client.courier,	procedureNumber: LibCourier.RemoteProcedures.nextCheckedOut.ORD,	arguments: [@args, LibCourier.DescribeNextLibjectArguments],	results: [@res, LibCourier.DescribeNextLibjectResults]];      reply ¬ res.replyVerifier;      END;    res: LibCourier.NextLibjectResults;    Call[handle, NextIt];    -- Courier.Free not needed.    IF XString.ByteLength[@res.next]=0 THEN {      Courier.Free[        [@res.next, XString.DescribeReaderBody], ClientForHandle[handle].zone];      RETURN[XString.nullReaderBody]}    ELSE RETURN[res.next]    END;  MakeAtom: PUBLIC PROC [handle: Handle, s: LONG STRING] RETURNS [Atom] =    BEGIN    MakeIt: CoveredProc =      BEGIN      args: LibCourier.MakeAtomArguments ¬ [client.session, ver, s];      [] ¬ Courier.Call[	cH: client.courier,	procedureNumber: LibCourier.RemoteProcedures.makeAtom.ORD,	arguments: [@args, LibCourier.DescribeMakeAtomArguments],	results: [@res, LibCourier.DescribeMakeAtomResults]];      reply ¬ res.replyVerifier;      END;    res: LibCourier.MakeAtomResults;    Call[handle, MakeIt];    -- Courier.Free not needed. Atom is only thing in record besides verifier.    RETURN[res.atom]    END;  GetPrintName: PUBLIC PROC [handle: Handle, tag: Atom]    RETURNS [LONG STRING] =    BEGIN    NameIt: CoveredProc =      BEGIN      args: LibCourier.GetPrintNameArguments ¬ [client.session, ver, tag];      [] ¬ Courier.Call[	cH: client.courier,	procedureNumber: LibCourier.RemoteProcedures.stringForAtom.ORD,	arguments: [@args, LibCourier.DescribeGetPrintNameArguments],	results: [@res, LibCourier.DescribeGetPrintNameResults]];      reply ¬ res.replyVerifier;      END;    res: LibCourier.GetPrintNameResults;    Call[handle, NameIt];    -- Courier.Free not needed. Client FREEs string returned    RETURN[res.s]    END;  Create: PUBLIC PROC [handle: Handle, libject: XString.Reader] = {    Simple[handle, libject, create]};  Destroy: PUBLIC PROC [handle: Handle, libject: XString.Reader] = {    Simple[handle, libject, destroy]};  CheckOut: PUBLIC PROC [handle: Handle, libject: XString.Reader] = {    Simple[handle, libject, checkOut]};  CheckIn: PUBLIC PROC [handle: Handle, libject: XString.Reader] = {    Simple[handle, libject, checkIn]};  Query: PUBLIC PROC [handle: Handle, libject: XString.Reader, what: Atoms]    RETURNS [pl: PropertyList, isCheckedOut: BOOLEAN] = {    RETURN Get[handle, libject, what, query]};  QueryAndCheckOut: PUBLIC PROC [    handle: Handle, libject: XString.Reader, what: Atoms]    RETURNS [pl: PropertyList] = {    RETURN[Get[handle, libject, what, queryAndCheckOut].pl]};  SetProperties: PUBLIC PROC [    handle: Handle, libject: XString.Reader, pl: PropertyList] = {    Set[handle, libject, pl, setProperties]};  SetPropertiesAndCheckIn: PUBLIC PROC [    handle: Handle, libject: XString.Reader, pl: PropertyList] = {    Set[handle, libject, pl, setPropertiesAndCheckIn]};-- calling procedures  Get: PROC [    handle: Handle, libject: XString.Reader, what: Atoms,    p: LibCourier.RemoteProcedures]    RETURNS [pl: PropertyList, isCheckedOut: BOOLEAN] =    BEGIN    zone: UNCOUNTED ZONE;    GetIt: CoveredProc =      BEGIN      args: LibCourier.QueryArguments ¬ [client.session, ver, libject, what];      zone ¬ client.zone;      [] ¬ Courier.Call[	cH: client.courier,	procedureNumber: p.ORD,	arguments: [@args, LibCourier.DescribeQueryArguments],	results: [@res, LibCourier.DescribeQueryResults]];      reply ¬ res.replyVerifier;      END;    res: LibCourier.QueryResults;    Call[handle, GetIt];    pl ¬ zone.NEW[LibOps.PropertyListObject ¬ [zone, res.plist]];    -- plist freed by client, verifier freed by covered call    isCheckedOut ¬ res.isCheckedOut;    END;  Set: PROC [    handle: Handle, libject: XString.Reader, pl: PropertyList,    p: LibCourier.RemoteProcedures] =    BEGIN    SetIt: CoveredProc =      BEGIN      args: LibCourier.SetPropertiesArguments ¬ [	client.session, ver, libject, pl.list];      [] ¬ Courier.Call[	cH: client.courier,	procedureNumber: p.ORD,	arguments: [@args, LibCourier.DescribeSetPropertiesArguments],	results: [@reply, Auth.DescribeVerifier]];      END;    Call[handle, SetIt];    END;  Simple: PROC [h: Handle, l: XString.Reader, p: LibCourier.RemoteProcedures] =    BEGIN    SimpleOne: CoveredProc =      BEGIN      args: LibCourier.SimpleArguments ¬ [client.session, ver, l];      [] ¬ Courier.Call[	cH: client.courier,	procedureNumber: p.ORD,	arguments: [@args, LibCourier.DescribeSimpleArguments],	results: [@reply, Auth.DescribeVerifier]];      END;    Call[h, SimpleOne];    END;  Call: PROC [handle: Handle, proc: CoveredProc] =    BEGIN    c: Client = ClientForHandle[handle];    ver: Auth.Verifier ¬ proc[c, Auth.CheckOutNextVerifier[c.conv, c.host.host] !      Courier.VersionMismatch, Courier.Error =>	ERROR XLibrarian.Error[serviceUnavailable];      Courier.RemoteErrorSignalled => ERROR XLibrarian.Error[VAL[errorNumber]]];    IF ver # Auth.nullVerifier THEN {      IF ~Auth.ReplyVerifierChecks[c.conv, ver] THEN	ERROR XLibrarian.Error[implementationBug];      Auth.FreeVerifier[@ver, c.zone]};    END;  --Call    -- utilities  ClientForHandle: PROC [handle: Handle] RETURNS [Client] = {    WITH c: handle SELECT FROM      client => RETURN[c.client];      ENDCASE => ERROR XLibrarian.Error[invalidHandle]};      MakeFullNameWithDefaults: PROC [shortName: XString.Reader, z: UNCOUNTED ZONE]    RETURNS [fullName: NSName.Name] = {    GetCHDefaults: PROCEDURE [defaultCH: NSName.Name] = {      fullName ¬ NSName.NameFromString[	z: z, s: nsString, clientDefaults: defaultCH !	  NSName.Error => ERROR XLibrarian.Error[dataBaseNotFound]]};    nsString: NSString.String ¬ XString.NSStringFromReader[r: shortName, z: z];    LibProfile.GetDefaultCHName[proc: GetCHDefaults !       UNWIND => NSString.FreeString[z, nsString]];    NSString.FreeString[z, nsString]};    S: PROC [mS: LONG STRING] RETURNS [NSString.String] = INLINE     { RETURN[NSString.StringFromMesaString[mS]] };    XS: PROC [mS: LONG STRING] RETURNS [XString.ReaderBody] = INLINE     { RETURN[XString.FromSTRING[mS]] };    LibProfileError: PROCEDURE [code: LibProfile.ErrorCode] = {    SELECT code FROM      noSuchDataBase => ERROR XLibrarian.Error[dataBaseNotFound];      authenticationFailure => ERROR XLibrarian.Error[authenticationFailure];      ENDCASE => ERROR XLibrarian.Error[dataBaseNotFound]};      AccessCHError: PROCEDURE [type: AccessCH.ProblemType] = {    SELECT type FROM      badDatabaseName => ERROR XLibrarian.Error[dataBaseNotFound];      authProblem => ERROR XLibrarian.Error[authenticationFailure];      accessProblem => ERROR XLibrarian.Error[insufficientAccess];      noClearinghouse => ERROR XLibrarian.Error[serviceInaccessible];      ENDCASE => ERROR XLibrarian.Error[serviceInaccessible]};      AuthCallError: PROCEDURE [reason: Auth.CallProblem, whichArg: Auth.WhichArg] = {    SELECT whichArg FROM      initiator => ERROR XLibrarian.Error[authenticationFailure];      ENDCASE => ERROR XLibrarian.Error[authenticationFailure]};      AuthenticationError: PROC [reason: Auth.AuthenticationProblem] = {    SELECT reason FROM      IN Auth.AuthenticationProblem => ERROR XLibrarian.Error[authenticationFailure];      ENDCASE => ERROR XLibrarian.Error[authenticationFailure]};      END.  -- of LibCourierUserImpl  
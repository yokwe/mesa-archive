-- File: LibCourierSvcImpl.mesa - last edit:-- bjd                 15-Sep-86 18:16:47-- PLK                 27-Mar-84 15:45:24-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  Auth USING [DescribeCredentials, DescribeVerifier],  Courier USING [Description],  Environment,  LibCourierSvc USING [CloseArguments, GetPrintNameArguments, GetPrintNameResults, MakeAtomArguments, MakeAtomResults, maxArrayLength, maxRecordSize, maxStrings, NextLibjectArguments, NextLibjectResults, OpenArguments, OpenResults, QueryArguments, QueryResults, SetPropertiesArguments, SimpleArguments],  LibOps USING [Properties],  XLibrarian USING [Atom, Property, PropertyType, Value],  XString;  LibCourierSvcImpl: PROGRAM  IMPORTS Auth EXPORTS LibCourierSvc  SHARES XString =  BEGIN  Property: TYPE = XLibrarian.Property;  Value: TYPE = XLibrarian.Value;  Atom: TYPE = XLibrarian.Atom;  -- describe the procedure records  DescribeSimpleArguments: PUBLIC Courier.Description = {    sa: LONG POINTER TO LibCourierSvc.SimpleArguments =      notes.noteSize[SIZE[LibCourierSvc.SimpleArguments]];    notes.noteParameters[@sa.verifier, Auth.DescribeVerifier];    notes.noteParameters[@sa.libject, DescribeReader]};    DescribeOpenArguments: PUBLIC Courier.Description = {    oa: LONG POINTER TO LibCourierSvc.OpenArguments =      notes.noteSize[SIZE[LibCourierSvc.OpenArguments]];    notes.noteParameters[@oa.dataBase, DescribeReader];    notes.noteParameters[@oa.cred, Auth.DescribeCredentials];    notes.noteParameters[@oa.verifier, Auth.DescribeVerifier]};    DescribeOpenResults: PUBLIC Courier.Description = {    or: LONG POINTER TO LibCourierSvc.OpenResults =      notes.noteSize[SIZE[LibCourierSvc.OpenResults]];    notes.noteParameters[@or.replyVerifier, Auth.DescribeVerifier]};    DescribeCloseArguments: PUBLIC Courier.Description = {    ca: LONG POINTER TO LibCourierSvc.CloseArguments =      notes.noteSize[SIZE[LibCourierSvc.CloseArguments]];    notes.noteParameters[@ca.verifier, Auth.DescribeVerifier]};    DescribeNextLibjectArguments: PUBLIC Courier.Description = {    ncoa: LONG POINTER TO LibCourierSvc.NextLibjectArguments =      notes.noteSize[SIZE[LibCourierSvc.NextLibjectArguments]];    notes.noteParameters[@ncoa.verifier, Auth.DescribeVerifier];    notes.noteParameters[@ncoa.current, DescribeReader];    notes.noteParameters[@ncoa.mask, DescribeReader];    notes.noteParameters[@ncoa.user, DescribeReader]};    DescribeNextLibjectResults: PUBLIC Courier.Description = {    ncor: LONG POINTER TO LibCourierSvc.NextLibjectResults =      notes.noteSize[SIZE[LibCourierSvc.NextLibjectResults]];    notes.noteParameters[@ncor.next, DescribeReaderBody];    notes.noteParameters[@ncor.replyVerifier, Auth.DescribeVerifier]};    DescribeMakeAtomArguments: PUBLIC Courier.Description = {    aa: LONG POINTER TO LibCourierSvc.MakeAtomArguments =      notes.noteSize[SIZE[LibCourierSvc.MakeAtomArguments]];    notes.noteParameters[@aa.verifier, Auth.DescribeVerifier];    notes.noteString[@aa.tag]};    DescribeMakeAtomResults: PUBLIC Courier.Description = {    ar: LONG POINTER TO LibCourierSvc.MakeAtomResults =      notes.noteSize[SIZE[LibCourierSvc.MakeAtomResults]];    notes.noteParameters[@ar.replyVerifier, Auth.DescribeVerifier]};    DescribeGetPrintNameArguments: PUBLIC Courier.Description = {    gpna: LONG POINTER TO LibCourierSvc.GetPrintNameArguments =      notes.noteSize[SIZE[LibCourierSvc.GetPrintNameArguments]];    notes.noteParameters[@gpna.verifier, Auth.DescribeVerifier]};    DescribeGetPrintNameResults: PUBLIC Courier.Description = {    gpnr: LONG POINTER TO LibCourierSvc.GetPrintNameResults =      notes.noteSize[SIZE[LibCourierSvc.GetPrintNameResults]];    notes.noteString[@gpnr.s];    notes.noteParameters[@gpnr.replyVerifier, Auth.DescribeVerifier]};    DescribeQueryArguments: PUBLIC Courier.Description = {    qa: LONG POINTER TO LibCourierSvc.QueryArguments =      notes.noteSize[SIZE[LibCourierSvc.QueryArguments]];    notes.noteParameters[@qa.verifier, Auth.DescribeVerifier];    notes.noteParameters[@qa.libject, DescribeReader];    notes.noteArrayDescriptor[@qa.atoms, SIZE[Atom], LibCourierSvc.maxArrayLength]};    DescribeQueryResults: PUBLIC Courier.Description = {    qr: LONG POINTER TO LibCourierSvc.QueryResults =      notes.noteSize[SIZE[LibCourierSvc.QueryResults]];    notes.noteParameters[@qr.plist, DescribeProperties];    notes.noteParameters[@qr.replyVerifier, Auth.DescribeVerifier]};    DescribeSetPropertiesArguments: PUBLIC Courier.Description = {    spa: LONG POINTER TO LibCourierSvc.SetPropertiesArguments =      notes.noteSize[SIZE[LibCourierSvc.SetPropertiesArguments]];    notes.noteParameters[@spa.verifier, Auth.DescribeVerifier];    notes.noteParameters[@spa.libject, DescribeReader];    notes.noteParameters[@spa.plist, DescribeProperties]};  -- describing my types  DescribeProperties: PUBLIC Courier.Description =    BEGIN    refProps: LONG POINTER TO LibOps.Properties =      notes.noteSize[SIZE[LibOps.Properties]];    notes.noteDeadSpace[@refProps.props, 0];    notes.noteArrayDescriptor[      @refProps.props, SIZE[Property], LibCourierSvc.maxArrayLength];    FOR i: NATURAL IN [0..refProps.props.LENGTH) DO      notes.noteParameters[@refProps.props[i], DescribeProperty];      ENDLOOP;    END;    DescribeProperty: PUBLIC Courier.Description =    BEGIN    prop: LONG POINTER TO Property ¬ notes.noteSize[SIZE[Property]];    lengths: ARRAY [0..XLibrarian.PropertyType.LAST.ORD] OF CARDINAL ¬ [      SIZE[Value.null], SIZE[Value.time], SIZE[Value.client],      SIZE[Value.string], SIZE[Value.strings], SIZE[Value.integer],      SIZE[Value.xString], SIZE[Value.xStrings],      SIZE[Value.spare8], SIZE[Value.spare9]];    notes.noteChoice[@prop.value.body, SIZE[Value], DESCRIPTOR[lengths]];    WITH val: prop.value SELECT FROM      null, spare8, spare9 => NULL;      time => notes.noteLongCardinal[LOOPHOLE[@val.time]];      client => notes.noteArrayDescriptor[        @val.record, SIZE[WORD], LibCourierSvc.maxRecordSize];      string => notes.noteString[@val.string];      strings => {        notes.noteArrayDescriptor[	  @val.strings, SIZE[LONG STRING], LibCourierSvc.maxStrings];	FOR i: NATURAL IN [0..val.strings.LENGTH) DO	  notes.noteString[@val.strings[i]];	  ENDLOOP};      integer => notes.noteLongInteger[@val.integer];      xString => notes.noteParameters[@val.string, DescribeReader];      xStrings => {        notes.noteArrayDescriptor[	  @val.strings, SIZE[XString.Reader], LibCourierSvc.maxStrings];	FOR i: NATURAL IN [0..val.strings.LENGTH) DO	  notes.noteParameters[@val.strings[i], DescribeReader];	  ENDLOOP};      ENDCASE;    END;  -- reader stuff is until services gets it right!  DescribeReaderBody: PUBLIC Courier.Description =    BEGIN          DescribeBytes: Courier.Description =        BEGIN	-- a PACKED ARRAY [0..1) won't work correctly.  See System Software AR #4434.	nullByte: PACKED ARRAY [0..2) OF Environment.Byte _ [0, 0];	lengthInWords: CARDINAL _ (lengthInBytes + 1)/2;        bs: LONG POINTER TO XString.ByteSequence _ notes.noteSize[lengthInWords];		IF lengthInWords = 0 THEN RETURN;	  	IF notes.operation = fetch THEN	  BEGIN	  notes.noteDeadSpace[bs, lengthInWords];	  -- note the context information, if any	  IF contextLength # 0 THEN notes.noteBlock[[@contextBytes, 0, contextLength]];	  -- note the sequence	  notes.noteBlock[[LOOPHOLE[bs], rb.offset, rb.limit]];	  -- If there was an odd number of bytes add a null byte for an exact word count.          IF ((lengthInBytes MOD 2) = 1) THEN notes.noteBlock[[@nullByte, 0, 1]];	  END;  	          END; -- of DescribeBytes	    lengthInBytes, contextLength: CARDINAL _ 0;    -- x will be used for filler characters at the end of contextBytes.    x: Environment.Byte = 377B;    esc: Environment.Byte = 377B;      set0: Environment.Byte = 0B;    contextBytes: PACKED ARRAY [0..3) OF Environment.Byte _ [x, x, x];    rb: XString.Reader = notes.noteSize[SIZE[XString.ReaderBody]];        -- Do not generate courier data out of the first three fields.  Context can not be sent    -- because it does not have a corresponding Courier type.  Limit and offset can be     -- reconstructed.    notes.noteDeadSpace[@rb.context, (SIZE[XString.Context] + 2*SIZE[CARDINAL])];         -- Compute the total number of bytes to be sent, including context characters, if    -- necessary.     IF notes.operation # store THEN       BEGIN      -- We can't send the context directly.  Instead we have to append the information      -- to the beginning of the byte sequence.      IF (rb.context # XString.vanillaContext) AND (rb.bytes[rb.offset] # 377B) THEN        BEGIN         IF rb.context.suffixSize = 1 THEN 	  {contextLength _ 2; contextBytes _ [esc, rb.context.prefix, x]}        ELSE {contextLength _ 3; contextBytes _ [esc, esc, set0]};	END;      lengthInBytes _ rb.limit - rb.offset + contextLength;      END;        -- Move the local variable "lengthInBytes" to/from the serialized stream.    notes.noteSpace[@lengthInBytes, SIZE[CARDINAL]];            -- In noting bytes, we must use LOOPHOLE to get around the READONLY.    notes.noteDisjointData[LOOPHOLE[@rb.bytes], DescribeBytes];        IF notes.operation = store THEN      BEGIN  -- rebuild the fields that were not sent as courier data      rb.context _ XString.vanillaContext;      rb.limit _ lengthInBytes;      rb.offset _ 0;      END;    END;  -- of DescribeReaderBody    DescribeReader: PUBLIC Courier.Description =    BEGIN    p: LONG POINTER TO XString.Reader ¬ notes.noteSize[SIZE[LONG POINTER]];    IF notes.operation = fetch AND p­ = NIL THEN {      zero: CARDINAL ¬ 0;      notes.noteSpace[@zero, SIZE[CARDINAL]];      notes.noteDeadSpace[p, SIZE[XString.Reader]]; -- this skips over reader      RETURN};    notes.noteDisjointData[p, DescribeReaderBody];    END;  -- of DescribeReader    -- main line code  END.LOG (date - person - action)27-Mar-84 15:45:24 - plk - created. 27-Mar-86 11:06:51 - bjd - added xstring stuff.   
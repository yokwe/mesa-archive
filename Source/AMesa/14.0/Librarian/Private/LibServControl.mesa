-- File: LibServControl.mesa - last edit:-- bjd                  7-Mar-88 12:19:11-- djw                  7-May-85 11:56:38-- PLK    	11-Apr-84 13:31:12-- Copyright (C) 1984, 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved.-- To Do:--   Future:  should somehow monitor the global variables; DIRECTORY  AccessCH USING [    AppendProblem, databaseGenericPIDs, databaseSecondaryPIDs, librarianDatabasePID, librarianGenericPIDs, librarianSecondaryPIDs, librarianServicePID, nullPIDList, Problem, RegisterDatabase, RegisterService, UnRegisterDatabase, UnRegisterService],  Auth USING [CallProblem, Flavor, FreeIdentity],  CH USING [MakeConversationHandle, maxLocalNameLength],  CHPIDs USING [librarianService],  Courier USING [LocalSystemElement],  Heap USING [Create, Delete],  LibBackup USING [    BackupFiles, FreeBackupPath, GetBackupParameters, RecoverDataBase],  LibMessages USING [GetMessages, MessageKey],  LibServOps USING [    AccessType, CHName, CreateDataBase, DataBase, DestroyDataBase, EntryProcType, GetDataBases, GlobalFrame, InitDefaultLibDirectory, MakeClean, MakeUID, maxCHNameLength, maxLibjectNameLength, maxSessions, MonitorOperation, SACheckIn, ServiceSequence, Sessions, StartDataBase, StartUpService, Strings, TakeDownService],  Message USING [Expand],  MsgOps USING [AuthCallErrToMsg],  NetMgtServiceSupport USING [RegisterService],  NSExec USING [    AddClientCommands, AssignClientID, BroadcastAsyncMessage, ClientProcs, ClientStatus, Command, CreateClient, DestroyClient, Error, ExecProc, GetTTY, Handle, Predicate, PutErrorMessage, PutIndentedMessage, PutMessage, ServerName, StopMode, UserAServerSA, UserEnabled, UserLoggedOn, UserName],  NSFile USING [AttributesRecord, Close, GetAttributes, Handle, NameRecord, nullHandle, Selections, String],  NSFileName,  NSFileStream USING [FileFromStream, Handle],  NSName USING [    AppendNameToString, FreeName, InitNameStore, maxDomainLength, maxFullNameLength, maxLocalLength, maxOrgLength, Name, NameFieldsFromString, NameFromString, NameRecord, NameStore, separator, separatorCharacter, String],  NSString USING [AppendCharacter, AppendString, AppendToMesaString, Character, CopyString, EqualCharacter, EquivalentString, FreeString, nullString, String, StringFromMesaString],  NSTTY USING [PutChar, PutLine, PutString],  PilotSwitches USING [heapOwnerChecking],  Process USING [Pause, SecondsToTicks],  ProductFactoring USING [Enabled],  Runtime USING [GetBcdTime],  ServicesError USING [SetCatching],  ServicesPFOptions USING [librarian],  String USING [LowerCase],  System USING [switches],  TextInput USING [ChoiceIndex, Confirm, GetChoice, GetDecimal, GetNSName, GetPathName, GetText, GetYesNo, YesOrNo],  TTY USING [Handle, PutBlanks, PutChar, PutCR, PutDate, PutLongNumber, PutString],  XLibrarian USING [Error],  XMessage USING [DestroyMessages, Get, Handle],  XString USING [ReaderBody];LibServControl: PROGRAM   -- monitor exec procs for remote SA;   IMPORTS    AccessCH, Auth, CH, Courier, Heap, LibBackup, LibMessages, LibServOps, Message, MsgOps, NetMgtServiceSupport, NSExec, NSFile, NSFileStream, NSName, NSString, NSTTY, Process, ProductFactoring, Runtime, ServicesError, String, System, TextInput, TTY, XLibrarian, XMessage  EXPORTS LibServOps, LibMessages  SHARES XString = {      --  TYPES    ChoiceSequence: TYPE = RECORD [    seq: SEQUENCE length: CARDINAL OF NSString.String];    Sessions: TYPE = LibServOps.Sessions;  --  VARS & CONSTANTS    gf: PUBLIC LibServOps.GlobalFrame;  nullString: NSString.String = NSString.nullString;  heapChecking: BOOLEAN = System.switches[PilotSwitches.heapOwnerChecking]=down;  libMsgs: XMessage.Handle;  procs: NSExec.ClientProcs = [    init:    InitLibService,    start:   StartLibService,    stop:    StopLibService,    unload:  UnloadLibService,    expunge: ExpungeLibService,    name:    NameLibService,    status:  StatusLibService];      regProb: SIGNAL = CODE;  -- future: need to monitor the global data; these procs may help;  StatusEqualTo: PUBLIC PROCEDURE [status: NSExec.ClientStatus]    RETURNS [BOOLEAN] = {RETURN[gf.status = status]};  SetStatusTo: PUBLIC PROCEDURE [status: NSExec.ClientStatus] = {    gf.status ¬ status};  TracingOn: PUBLIC PROCEDURE RETURNS [BOOLEAN] = {    RETURN[gf.tracing]};  FlipTracing: PUBLIC PROCEDURE = {    gf.tracing ¬ ~gf.tracing};  Stopped: PROC RETURNS [stopped: BOOLEAN] = {    stopped ¬ gf.status = stopped;    IF ~stopped THEN gf.status ¬ starting};  Started: PROC RETURNS [started: BOOLEAN] = {    started ¬ gf.status = started;    IF ~started THEN gf.status ¬ stopping};-- the ClientProcs  InitLibService: PROC [exec: NSExec.Handle, normal: BOOLEAN] =    BEGIN    commands: ARRAY [0..13) OF NSExec.Command ¬ [      [M[keyToggleTracing],	SetTracing,	NSExec.UserLoggedOn],      [M[keyBackupDatabases],	TryBackup,	AdministratorPred],      [M[keyRecoverDatabase],	RecoverDB,	AdministratorPred],      [M[keySetReaders],	SetReaders,	AdministratorPred],      [M[keySetWriters],		SetWriters,	AdministratorPred],      [M[keySetBackupPath],	SetBackupPath,	AdministratorPred],      [M[keyListDatabases],	ListDB,		ListPred],      [M[keyCreateDatabase],	CreateDB,	AdministratorPred],      [M[keyDestroyDatabase],	DestroyDB,	DestroyPred],      [M[keySetAuthenticationLevel],	SetAuthLevel,	AdministratorPred],      [M[keyRegisterDatabase],		RegisterDB,	AdministratorPred],      [M[keyUnregisterDatabase],	UnregisterDB,	AdministratorPred],      [M[keyCheckinLibject],		CheckinLibject,	AdministratorPred] ];    IF NOT ProductFactoring.Enabled [ServicesPFOptions.librarian] THEN {      NSExec.PutMessage[exec, M[keyNotProductFactored]];      ERROR NSExec.Error[type: cannotInitialize]};    NetMgtServiceSupport.RegisterService[      clientID: gf.execId,      serviceOption: ServicesPFOptions.librarian,      pid: CHPIDs.librarianService,      bcdTime: Runtime.GetBcdTime[]];    NSExec.AddClientCommands[gf.execId, DESCRIPTOR[commands]];    StartLibService[exec ! ServicesError.SetCatching => RESUME];    END;  StartLibService: NSExec.ExecProc = {    IF ~Stopped[] THEN RETURN;    NSExec.PutMessage[exec, M[keyStartingLibrarianService]];    IF gf.z = NIL THEN {  -- must be first time or last was a 'quitCold'      gf.z ¬ Heap.Create[        initial: 8, increment: 4, swapUnitSize: 4,        ownerChecking: heapChecking, checking: heapChecking];      gf.handles ¬ gf.z.NEW[LibServOps.ServiceSequence[LibServOps.maxSessions]];      FOR i: Sessions IN Sessions DO         gf.handles[i] ¬ []       ENDLOOP    };    IF gf.serverId = NIL THEN       GetServerId[exec ! regProb => GOTO registrationProblems];    gf.startId ¬ LibServOps.MakeUID[];    LibServOps.StartUpService[];    SetStatusTo[started]    EXITS      registrationProblems => {        NSExec.PutErrorMessage[exec, M[keyServiceNotStarted]];        SetStatusTo[stopped]}};  StopLibService: PROC [exec: NSExec.Handle, stopMode: NSExec.StopMode] = {    IF ~Started[] THEN RETURN;    LibServOps.TakeDownService[stopMode]; -- this waits until all clients have exited;    SetStatusTo[stopped]};  TryBackup: NSExec.ExecProc = {    LibBackup.BackupFiles[]};  RecoverDB: NSExec.ExecProc =     BEGIN    CleanUp: PROC = {      defaultPath ¬ LibBackup.FreeBackupPath[defaultPath]}; -- checks for null;    tty: TTY.Handle = NSExec.GetTTY[exec];    pathString: LONG STRING = [LibServOps.maxCHNameLength];    path: NSString.String;    defaultPath: NSString.String ¬ nullString;    which: TextInput.ChoiceIndex ¬ ChooseDB[exec: exec, start: FALSE];    defaultPath ¬ LibBackup.GetBackupParameters[which].path;    path ¬ TextInput.GetPathName[      tty: tty, prompt: M[keyRecoveryPath], path: S[pathString],       defaultPath: defaultPath ! UNWIND => CleanUp[]];  <<    IF ~NSString.EqualCharacter[      c: NSFileName.nameVersionPairSeparator, s: path, index: path.length]    THEN	path ¬ NSString.AppendCharacter[	  to: path, from: NSFileName.nameVersionPairSeparator];   >>     IF TextInput.Confirm[tty: tty, prompt: M[keyConfirmRecover] ! UNWIND => CleanUp[]]    THEN     -- do we want to fork this?  (it used to, probably because Backup did);     -- recoveryPath will get trashed after process is forked;     --   copiedPath: NSString.String ¬ NSString.CopyString[gf.z, path];     --   Process.Detach[FORK LibBackup.RecoverDataBase[which, copiedPath]];     -- path must then be freed by LibBackup.RecoverDataBase?      LibBackup.RecoverDataBase[index: which, recoveryPath: path !        UNWIND => CleanUp[]];    CleanUp[];    END;  UnregisterDB: NSExec.ExecProc =    BEGIN    tty: TTY.Handle = NSExec.GetTTY[exec];    string: LONG STRING = [NSName.maxFullNameLength];    local: LONG STRING = [NSName.maxLocalLength];    domain: LONG STRING = [NSName.maxDomainLength];    org: LONG STRING = [NSName.maxOrgLength];    dbName: NSName.NameRecord ¬ [      local: S[local], org: S[org], domain: S[domain]];    dbString: NSString.String ¬ TextInput.GetText[      tty: tty,      prompt: M[keyDatabaseName],      text: S[string],      maxLength: CH.maxLocalNameLength];    NSName.NameFieldsFromString[      z: gf.z, s: dbString, destination: @dbName, clientDefaults: gf.serviceName];    local.length ¬ dbName.local.length;    PutMsg[e: exec, template: M[keyUnregistering], s1: dbString];    IF AccessCH.UnRegisterDatabase[      database:	@dbName,      service:	gf.serviceName,      execHandle:	exec,      z:		gf.z].ok THEN NSTTY.PutString[tty, M[keyDone]];    END;  RegisterDB: NSExec.ExecProc =    BEGIN    tty: TTY.Handle = NSExec.GetTTY[exec];    string: LONG STRING = [NSName.maxFullNameLength];    local: LONG STRING = [NSName.maxLocalLength];    domain: LONG STRING = [NSName.maxDomainLength];    org: LONG STRING = [NSName.maxOrgLength];    dbName: NSName.NameRecord ¬ [      local: S[local], org: S[org], domain: S[domain]];    dbString: NSString.String ¬ TextInput.GetText[      tty: tty,      prompt: M[keyDatabaseName],      text: S[string],      maxLength: CH.maxLocalNameLength];    PutMsg[e: exec, template: M[keyRegistering], s1: dbString];    FOR i: NATURAL IN [0..gf.dataBases.length) DO      IF NSString.EquivalentString[dbString, gf.dataBases[i].nameRoot] THEN EXIT;      REPEAT FINISHED => { -- if database does not exist;	NSTTY.PutLine[tty, M[keyNoSuchDatabase]];        RETURN};      ENDLOOP;    NSName.NameFieldsFromString[      z: gf.z, s: dbString, destination: @dbName, clientDefaults: gf.serviceName];    IF AccessCH.RegisterDatabase[      database:	@dbName,      service:	gf.serviceName,      primaryPID:	AccessCH.librarianDatabasePID,      genericPIDs:	AccessCH.databaseGenericPIDs,      secondaryPIDs:	AccessCH.databaseSecondaryPIDs,      desc:		NSString.nullString,      execHandle:	exec,      z:		gf.z].ok THEN NSTTY.PutString[tty, M[keyDone]];    END;  UnloadLibService: NSExec.ExecProc = {ERROR};  -- Heap.Delete[xxx];  -- NSFile.Logoff[xxx]; ?  ExpungeLibService: NSExec.ExecProc =    BEGIN ENABLE UNWIND => NULL;    error: BOOLEAN ¬ FALSE;    IF gf.z = NIL THEN  -- must be first time or last was a 'quitCold'      gf.z ¬ Heap.Create[        initial: 8, increment: 4, swapUnitSize: 4,        ownerChecking: heapChecking, checking: heapChecking];    error ¬ NOT ExpungeDatabases[exec].completed;    IF ~error THEN -- if failed to delete all databases, leave service entry alone;      AccessCH.UnRegisterService[	primaryPID:	AccessCH.librarianServicePID,	-- workaround for SelfReg AR 7801: 	genericPIDs:	AccessCH.<<librarianGenericPIDs>>nullPIDList,	secondaryPIDs:	AccessCH.librarianSecondaryPIDs,	execHandle:	exec,	clientID:		gf.execId !	  AccessCH.Problem =>	    IF type = noCHData THEN CONTINUE	    ELSE {	     msg: STRING ¬ [50];	     regProbMsg: NSString.String ¬ AccessCH.AppendProblem[type, S[msg]];	     NSExec.PutErrorMessage[exec, regProbMsg];	     error ¬ TRUE;	     CONTINUE}];    XMessage.DestroyMessages[libMsgs];    NSExec.DestroyClient[gf.execId];    Heap.Delete[gf.z];    gf.z ¬ NIL;    IF error THEN ERROR NSExec.Error[cannotExpunge];    END;  ExpungeDatabases: PROCEDURE [exec: NSExec.Handle]    RETURNS [completed: BOOLEAN ¬ TRUE] =    BEGIN    CleanUp: PROC = {      IF gf.serverId#NIL THEN Auth.FreeIdentity[@gf.serverId];      IF dbStrings#NIL THEN {        FOR i: NATURAL IN [0..dbStrings.length) DO NSString.FreeString[z: gf.z, s: dbStrings[i]] ENDLOOP;        gf.z.FREE[@dbStrings]}};    tty: TTY.Handle = NSExec.GetTTY[exec];    string: LONG STRING = [NSName.maxFullNameLength];    local: LONG STRING = [NSName.maxLocalLength];    domain: LONG STRING = [NSName.maxDomainLength];    org: LONG STRING = [NSName.maxOrgLength];    dbName: NSName.NameRecord ¬ [      local: S[local], org: S[org], domain: S[domain]];    dbStrings: LibServOps.Strings ¬ NIL;    { ENABLE UNWIND => CleanUp[];    IF NOT TextInput.Confirm[      tty: NSExec.GetTTY[exec], default: no, prompt: M[keyConfirmExpunge]]    THEN GOTO bail    ELSE {      Process.Pause[Process.SecondsToTicks[5]];      IF NOT TextInput.Confirm[	tty: NSExec.GetTTY[exec], default: no, prompt: M[keyConfirm]]      THEN GOTO bail};    LibServOps.InitDefaultLibDirectory[];  -- GetDataBases needs this;    IF gf.defaultLibDir # NSFile.nullHandle THEN { -- otherwise no files;      dbStrings ¬ LibServOps.GetDataBases[];      IF gf.serverId = NIL THEN -- to get the service name; no other easy way 	GetServerId[exec ! regProb => GOTO bail];      FOR i: NATURAL IN [0..dbStrings.length) DO      -- unregister database entry from CH; do this first, since if this fails we still want to keep the database to attempt destroying after reboot.	NSName.NameFieldsFromString[	  z: gf.z, s: dbStrings[i], destination: @dbName,	  clientDefaults: gf.serviceName];	local.length ¬ dbName.local.length;	PutMsg[e: exec, template: M[keyUnregistering], s1: dbStrings[i]];	IF AccessCH.UnRegisterDatabase[	  database:	@dbName,	  service:		gf.serviceName,	  execHandle:	exec,	  z:		gf.z].ok THEN NSTTY.PutLine[tty, M[keyDone]]	  ELSE {	    NSTTY.PutLine[tty, M[keyContinuingToNextDatabase]];	    completed ¬ FALSE;	    LOOP};	-- delete associated files	PutMsg[e: exec, template: M[keyDestroying], s1: dbStrings[i]];	IF LibServOps.DestroyDataBase[dbStrings[i]].filesDeleted = 0 THEN {	  NSTTY.PutString[tty, M[keyFilesInUse]];	  NSTTY.PutLine[tty, M[keyContinuingToNextDatabase]];	  completed ¬ FALSE}	ELSE NSTTY.PutLine[tty, M[keyDone]];        ENDLOOP;      NSFile.Close[gf.defaultLibDir]};      CleanUp[];      EXITS bail => {        CleanUp[]; completed ¬ FALSE};    };    END;  NameLibService: PROC [    nameProc: PROCEDURE [clientName: NSString.String]] = {    IF gf.serviceName # NIL THEN {      string: LONG STRING = [NSName.maxFullNameLength];      svcString: NSString.String ¬ S[string];      svcString ¬ NSName.AppendNameToString[s: svcString, name: gf.serviceName];      nameProc[svcString]}    ELSE nameProc[M[keyLibrarianService]]};  StatusLibService: PROC [    statusProc: PROC [status: NSExec.ClientStatus, comment: NSString.String]] = {    comment: ARRAY NSExec.ClientStatus OF NSString.String = [      started:   M[keyStarted],      starting:  M[keyStarting],      stopped:   M[keyStopped],      stopping:  M[keyStopping]];    statusProc[gf.status, comment[gf.status]]};  -- predicate procs  AdministratorPred: NSExec.Predicate = {    RETURN[NSExec.UserAServerSA[exec] AND StatusEqualTo[started]]};  DestroyPred: NSExec.Predicate = {    RETURN[NSExec.UserEnabled[exec] AND StatusEqualTo[stopped]]};  ListPred: NSExec.Predicate = {RETURN[StatusEqualTo[started]]};  SetAuthPred: NSExec.Predicate = {    RETURN[NSExec.UserAServerSA[exec] AND StatusEqualTo[started]]};  SetUsersPred: NSExec.Predicate = {    RETURN[NSExec.UserEnabled[exec] AND StatusEqualTo[started]]};-- command procs       CreateDB: NSExec.ExecProc =    BEGIN OPEN NSFileName;    specialChars: ARRAY [0..8) OF NSString.Character = [      rightServiceSeparator, leftServiceSeparator, matchMultipleChars,      matchSingleChar, escapeChar, nameVersionPairSeparator, versionSeparator,      NSName.separatorCharacter];    tty: TTY.Handle = NSExec.GetTTY[exec];    database: LONG STRING = [CH.maxLocalNameLength];    BEGIN    dbString: NSString.String ¬ TextInput.GetText[      tty: tty,      prompt: M[keyDatabaseName],      text: S[database],      maxLength: CH.maxLocalNameLength];    FOR i: CARDINAL IN [0..dbString.length) DO      FOR j: CARDINAL IN [0..LENGTH[specialChars]) DO        IF NSString.EqualCharacter[s: dbString, c: specialChars[j], index: i] THEN	  GOTO illegalChar;        ENDLOOP;      ENDLOOP;    PutMsg[e: exec, template: M[keyCreating], s1: dbString];    IF NOT LibServOps.CreateDataBase[dbString].created THEN      NSTTY.PutLine[tty, M[keyAlreadyExists]]    ELSE NSTTY.PutLine[tty, M[keyDone]];    EXITS      illegalChar => {        NSTTY.PutString[tty, M[keyIllegalDatabaseName]];        NSTTY.PutLine[tty, M[keyCommandCancelled]]};    END;    END;    DestroyDB: NSExec.ExecProc =    BEGIN ENABLE UNWIND => NULL;    -- must use GetDataBases, since service is stopped and hence db sequence is freed;    CleanUp: PROC = {      gf.z.FREE[@choices];      FOR i: NATURAL IN [0..dbStrings.length) DO        NSString.FreeString[z: gf.z, s: dbStrings[i]] ENDLOOP;      gf.z.FREE[@dbStrings];      IF prompt#NSString.nullString THEN NSString.FreeString[gf.z, prompt]};    choices: LONG POINTER TO ChoiceSequence ¬ NIL;    tty: TTY.Handle = NSExec.GetTTY[exec];    which: TextInput.ChoiceIndex;    dbStrings: LibServOps.Strings ¬ LibServOps.GetDataBases[];    prompt: NSString.String ¬ NSString.nullString;    choices ¬ gf.z.NEW[ChoiceSequence[dbStrings.length]];    FOR i: NATURAL IN [0..dbStrings.length) DO choices[i] ¬ dbStrings[i] ENDLOOP;    which ¬ TextInput.GetChoice[      tty: tty, prompt: M[keyDatabaseName],      choices: DESCRIPTOR[choices], nilOK: FALSE ! UNWIND => CleanUp[]];    prompt ¬ ExpandMsg[      z: gf.z, template: M[keyConfirmDestroy], s1: dbStrings[which]];    IF TextInput.Confirm[tty: tty, prompt: prompt ! UNWIND => CleanUp[]]    THEN {      PutMsg[e: exec, template: M[keyDestroying], s1: dbStrings[which]];      IF LibServOps.DestroyDataBase[dbStrings[which]].filesDeleted = 0 THEN {	NSTTY.PutString[tty, M[keyFilesInUse]];        NSTTY.PutLine[tty, M[keyCommandCancelled]]}      ELSE NSTTY.PutLine[tty, M[keyDone]]};    CleanUp[];    END;  CheckinLibject: NSExec.ExecProc =    BEGIN    tty: TTY.Handle = NSExec.GetTTY[exec];    libjectString: LONG STRING = [LibServOps.maxLibjectNameLength];    libject: NSString.String;    {    which: TextInput.ChoiceIndex ¬ ChooseDB[exec];    IF gf.dataBases[which].h = NIL THEN {      --NSTTY.PutLine[tty, M[keyDatabaseBeingRecovered]];      RETURN};    libject ¬ TextInput.GetText[      tty: tty, prompt: M[keyLibjectName],      text: S[libjectString], maxLength: LibServOps.maxLibjectNameLength];    PutMsg[e: exec, template: M[keyCheckingInLibject], s1: libject];    LibServOps.SACheckIn[      database: gf.dataBases[which].nameRoot, libject: libject,      user: NSExec.UserName[exec] ! XLibrarian.Error => {        SELECT code FROM           libjectNotCheckedOut => NSTTY.PutString[tty, M[keyNotCheckedOut]];          libjectNotFound => NSTTY.PutString[tty, M[keyNotFound]];	  ENDCASE  => NSTTY.PutString[tty, M[keyUnknownLibrarianError]];	GOTO cancel}];    NSTTY.PutLine[tty, M[keyDone]];    EXITS cancel =>      NSTTY.PutLine[tty, M[keyCommandCancelled]];    }    END;  ChooseDB: PROC [exec: NSExec.Handle, start: BOOLEAN ¬ TRUE]    RETURNS [dbIndex: NATURAL] =    BEGIN    tty: TTY.Handle = NSExec.GetTTY[exec];    startDB: LibServOps.EntryProcType = {      IF db.h = NIL AND start THEN LibServOps.StartDataBase[which]};    which: TextInput.ChoiceIndex;    choices: LONG POINTER TO ChoiceSequence ¬      gf.z.NEW[ChoiceSequence[gf.dataBases.length]];    FOR i: NATURAL IN [0..choices.length) DO      choices[i] ¬ gf.dataBases[i].nameRoot;      ENDLOOP;    which ¬ TextInput.GetChoice[      tty: tty, prompt: M[keyDatabaseChoice],      choices: DESCRIPTOR[choices], nilOK: FALSE ! UNWIND => gf.z.FREE[@choices]];    gf.z.FREE[@choices];    [] ¬ CatchErrors[exec: exec, proc: startDB, access: write, dbIndex: which];    RETURN[which];    END;  SetAuthLevel: NSExec.ExecProc =    BEGIN    tty: TTY.Handle = NSExec.GetTTY[exec];    index: NATURAL = ChooseDB[exec];    level: TextInput.ChoiceIndex;    choices: ARRAY [0..2) OF NSString.String ¬ [M[keyStrong], M[keySimple]];    setAuthLevel: LibServOps.EntryProcType = {      IF db.h = NIL THEN {	--NSTTY.PutLine[tty, M[keyDatabaseBeingRecovered]];	RETURN};      db.h.header.minAuthentication ¬ IF level = 0 THEN strong ELSE simple;      db.h.header.dirty ¬ TRUE;      LibServOps.MakeClean[db.h]};    level ¬ TextInput.GetChoice[      tty: tty, prompt: M[keyAuthenticationLevel],      choices: DESCRIPTOR[choices], nilOK: FALSE];    [] ¬ CatchErrors[exec: exec, proc: setAuthLevel, access: write, dbIndex: index];     END;  SetReaders: NSExec.ExecProc =    BEGIN    tty: TTY.Handle = NSExec.GetTTY[exec];    index: NATURAL = ChooseDB[exec];    setReaders: LibServOps.EntryProcType = {      IF db.h = NIL THEN {	--NSTTY.PutLine[tty, M[keyDatabaseBeingRecovered]];	RETURN};      SetReaderWriter[db.h, tty, reader, M[keyReaders]]};    [] ¬ CatchErrors[exec: exec, proc: setReaders, access: write, dbIndex: index];    END;     SetWriters: NSExec.ExecProc =    BEGIN    tty: TTY.Handle = NSExec.GetTTY[exec];    index: NATURAL = ChooseDB[exec];    setWriters: LibServOps.EntryProcType = {      IF db.h = NIL THEN {	--NSTTY.PutLine[tty, M[keyDatabaseBeingRecovered]];	RETURN};      SetReaderWriter[db.h, tty, writer, M[keyWriters]]};    [] ¬ CatchErrors[exec: exec, proc: setWriters, access: write, dbIndex: index];    END;     SetBackupPath: NSExec.ExecProc =    BEGIN    tty: TTY.Handle = NSExec.GetTTY[exec];    string: LONG STRING = [LibServOps.maxCHNameLength];    path, defaultPath: NSString.String;    versions: INTEGER ¬ 0;    index: TextInput.ChoiceIndex ¬ ChooseDB[exec];    CleanUp: PROC = {      defaultPath ¬ LibBackup.FreeBackupPath[defaultPath]}; -- checks for null;    setBackupPath: LibServOps.EntryProcType = {      IF db.h = NIL THEN {	--NSTTY.PutLine[tty, M[keyDatabaseBeingRecovered]];	RETURN};      db.h.header.backupVersionsToKeep ¬ CARDINAL[versions];      db.h.header.backupPath.length ¬ path.length;      FOR i: NATURAL IN [0..path.length) DO	db.h.header.backupPath.bytes[i] ¬ path.bytes[i] ENDLOOP;      db.h.header.dirty ¬ TRUE;      NSString.FreeString[gf.z, db.backupPath]; -- checks for nil;      db.backupVersionsToKeep ¬ versions;      db.backupPath ¬ IF path.length = 0        THEN NSString.nullString ELSE NSString.CopyString[gf.z, path];      LibServOps.MakeClean[db.h]};      [defaultPath, versions] ¬ LibBackup.GetBackupParameters[index]; -- monitored read      path ¬ TextInput.GetPathName[	tty: tty, path: S[string], nilOK: TRUE,  -- nil path means don't backup.	defaultPath: defaultPath, defaultFields: NSExec.ServerName[],        prompt: M[keyBackupPath] ! UNWIND => CleanUp[]];      IF path.length = 0 OR NSString.EqualCharacter[        c: NSName.separatorCharacter, s: path, index: 1] THEN      -- GetPathName doesn't allow nil; () is the minimum even if nothing typed;      -- with defaultFields, if the user types empty, this returns: (:domain:org);	path.length ¬ 0      ELSE {	IF ~NSString.EqualCharacter[	  c: NSFileName.nameVersionPairSeparator, s: path, index: path.length]        THEN	    path ¬ NSString.AppendCharacter[	      to: path, from: NSFileName.nameVersionPairSeparator]; 	versions ¬ TextInput.GetDecimal[	  tty: tty, prompt: M[keyBackupVersionsToKeep],	  default: versions, min: 1, max: 100 ! UNWIND => CleanUp[]]};    [] ¬ CatchErrors[exec: exec, proc: setBackupPath, access: write, dbIndex: index];    CleanUp[];     END;    SetReaderWriter: PROCEDURE [ -- internal to MonitorOperation    h: LibServOps.DataBase, tty: TTY.Handle, type: {reader, writer},    prompt: NSString.String] =    BEGIN    chName: LONG POINTER TO LibServOps.CHName =      IF type = reader THEN @h.header.readers ELSE @h.header.writers;    string: LONG STRING = [LibServOps.maxCHNameLength];    wholeName: NSString.String ¬ S[string];    newName: NSName.NameStore;    defaultName: NSName.NameStore;    star: NSString.String ¬ S["*"L];    defaultFields: NSName.Name = NSExec.ServerName[];    NSName.InitNameStore[@newName];    NSName.InitNameStore[@defaultName];    IF chName.length = 0 THEN {      defaultName.record.local ¬ NSString.AppendString[	defaultName.record.local, star];      defaultName.record.domain ¬ NSString.AppendString[	defaultName.record.domain, defaultFields.domain];      defaultName.record.org ¬ NSString.AppendString[	defaultName.record.org, defaultFields.org]}    ELSE {      oldName: NSName.Name;      wholeName.length ¬ chName.length;      FOR i: NATURAL IN [0..wholeName.length) DO	wholeName.bytes[i] ¬ chName.bytes[i] ENDLOOP;      oldName ¬ NSName.NameFromString[gf.z, wholeName];      defaultName.record.local ¬ NSString.AppendString[	defaultName.record.local, oldName.local];      defaultName.record.domain ¬ NSString.AppendString[	defaultName.record.domain, oldName.domain];      defaultName.record.org ¬ NSString.AppendString[	defaultName.record.org, oldName.org];      NSName.FreeName[gf.z, oldName]};    TextInput.GetNSName[      tty: tty,      prompt: prompt,      name: @newName.record,      defaultName: @defaultName.record,      defaultFields: defaultFields];    SELECT type FROM  -- free the old one      reader => IF h.readers # NIL THEN NSName.FreeName[gf.z, h.readers];      writer => IF h.writers # NIL THEN NSName.FreeName[gf.z, h.writers];      ENDCASE;    IF NSString.EquivalentString[newName.record.local, star] AND       NSString.EquivalentString[newName.record.domain, defaultFields.domain] AND       NSString.EquivalentString[newName.record.org, defaultFields.org] THEN {      wholeName.length ¬ 0;      SELECT type FROM	reader => h.readers ¬ NIL;	writer => h.writers ¬ NIL;	ENDCASE}    ELSE {      wholeName ¬ NSName.AppendNameToString[wholeName, @newName.record, TRUE];      SELECT type FROM	reader => h.readers ¬ NSName.NameFromString[gf.z, wholeName];	writer => h.writers ¬ NSName.NameFromString[gf.z, wholeName];	ENDCASE};    chName.length ¬ wholeName.length;    FOR i: NATURAL IN [0..wholeName.length) DO      chName.bytes[i] ¬ wholeName.bytes[i] ENDLOOP;    h.header.dirty ¬ TRUE;    LibServOps.MakeClean[h];    END;  ListDB: NSExec.ExecProc =    BEGIN    i: NATURAL;    tty: TTY.Handle = NSExec.GetTTY[exec];    string: LONG STRING = [NSName.maxLocalLength];    dbString: NSString.String ¬ TextInput.GetText[      tty: tty, prompt: M[keyDatabaseName], text: S[string],      maxLength: NSName.maxLocalLength, default: S["*"L]];    verbose: TextInput.YesOrNo ¬ TextInput.GetYesNo[      tty: tty, prompt: M[keyVerboseFeedback], default: no];    listDB: LibServOps.EntryProcType = {      IF ~NameMatch[db.nameRoot, dbString] THEN RETURN;      NSExec.PutMessage[exec, db.nameRoot];      IF verbose = yes THEN {        logFile: NSFile.Handle ¬ NSFile.nullHandle;	IF db.h = NIL THEN LibServOps.StartDataBase[i];	IF db.h = NIL THEN RETURN;  -- needs recovery; StartDB posts;        logFile ¬ NSFileStream.FileFromStream[db.h.log];        PostDataFileInfo[	  tty: tty, file: db.h.recordFile, ext: "Records"L];        PostDataFileInfo[	  tty: tty, file: db.h.hashTableFile, ext: "HashTable"L];        PostDataFileInfo[	  tty: tty, file: logFile, ext: "Log"L];	PostAccess[tty, db.h];	PostAuthLevel[tty, db.h];	PostBackupPath[tty, db.h]}};    FOR i IN [0..gf.dataBases.length) DO      IF CatchErrors[exec: exec, proc: listDB, access: read, dbIndex: i].fatal THEN        EXIT;      ENDLOOP;    END;  PostDataFileInfo: PROCEDURE [    tty: TTY.Handle, file: NSFile.Handle, ext: LONG STRING] = {    selects: NSFile.Selections ¬ [];    attr: NSFile.AttributesRecord;    nSpaces: CARDINAL ¬ 25 - MIN[24, ext.length];  -- max of 25 blanks    selects.interpreted[dataSize] ¬ TRUE;    selects.interpreted[modifiedOn] ¬ TRUE;    NSFile.GetAttributes[      file: file, selections: selects,      attributes: @attr, session: gf.fileSession];    TTY.PutBlanks[tty, 2]; TTY.PutChar[tty, '.];  TTY.PutString[tty, ext];    TTY.PutBlanks[tty, nSpaces];    TTY.PutLongNumber[      tty, attr.dataSize, [      base: 10, zerofill: FALSE, unsigned: TRUE, columns: 8]];    TTY.PutBlanks[tty, 4];    TTY.PutDate[tty, attr.modifiedOn, full];    TTY.PutCR[tty];    };  PostAccess: PROCEDURE [tty: TTY.Handle, db: LibServOps.DataBase] = {    NSTTY.PutString[tty, M[keyReadersColon]];    IF db.readers = NIL THEN NSTTY.PutLine[tty, M[keyAsterisk]]    ELSE PostName[tty, db.readers];    NSTTY.PutString[tty, M[keyWritersColon]];    IF db.writers = NIL THEN NSTTY.PutLine[tty, M[keyAsterisk]]    ELSE PostName[tty, db.writers];    };  PostName: PROCEDURE [tty: TTY.Handle, name: NSName.Name] = {    NSTTY.PutString[tty, name.local];  TTY.PutChar[tty, NSName.separator];    NSTTY.PutString[tty, name.domain];  TTY.PutChar[tty, NSName.separator];    NSTTY.PutLine[tty, name.org];    };  PostAuthLevel: PROCEDURE [tty: TTY.Handle, db: LibServOps.DataBase] = {    flavor: Auth.Flavor ¬ db.header.minAuthentication;    NSTTY.PutString[tty, M[keyAuthenticationLevelColon]];    NSTTY.PutLine[tty, IF flavor = simple THEN M[keySimple] ELSE M[keyStrong]];    };  PostBackupPath: PROCEDURE [tty: TTY.Handle, db: LibServOps.DataBase] = {    NSTTY.PutString[tty, M[keyBackupPathColon]];    IF db.header.backupPath.length=0 THEN NSTTY.PutLine[tty, M[keyDontBackup]]    ELSE FOR i: NATURAL IN [0..db.header.backupPath.length) DO      NSTTY.PutChar[tty, [0, db.header.backupPath.bytes[i]]] ENDLOOP;    TTY.PutCR[tty]};  SetTracing: NSExec.ExecProc = {    m: NSString.String ¬ IF TracingOn[] THEN M[keyTracingOff] ELSE M[keyTracingOn];    FlipTracing[];    NSExec.PutIndentedMessage[exec, m]};  CatchErrors: PROC [    exec: NSExec.Handle, proc: LibServOps.EntryProcType,    access: LibServOps.AccessType, dbIndex: NATURAL]    RETURNS [fatal: BOOLEAN ¬ FALSE] =    BEGIN ENABLE XLibrarian.Error => {       tty: TTY.Handle = NSExec.GetTTY[exec];      SELECT code FROM -- this is the only expected error;        dataBaseUnavailable => NSTTY.PutLine[tty, M[keyDatabaseUnavailable]];        serviceFull => {	  NSTTY.PutLine[tty, M[keyOutOfVirtualMemory]];	  fatal ¬ TRUE};	ENDCASE => {	  NSTTY.PutLine[tty, M[keyUnknownLibrarianError]];	  fatal ¬ TRUE};      CONTINUE};     LibServOps.MonitorOperation[proc, access, dbIndex];    END;-- utilities  wildString: CHARACTER = '*;  wildChar: CHARACTER = '#;  NameMatch: PROCEDURE [s, pat: NSString.String] RETURNS [matched: BOOLEAN] = {    sS: LONG STRING= [NSName.maxLocalLength];    patS: LONG STRING= [NSName.maxLocalLength];    NSString.AppendToMesaString[to: sS, from: s];    NSString.AppendToMesaString[to: patS, from: pat];    RETURN[Match[sS, 0, patS, 0]]};  Match: PROCEDURE [    file: LONG STRING, fileIndex: CARDINAL, mask: LONG STRING,    maskIndex: CARDINAL] RETURNS [outcome: BOOLEAN] =    BEGIN    -- local variables    i, j: CARDINAL;    -- process each character in mask    FOR i IN [maskIndex..mask.length) DO      SELECT mask[i] FROM        wildString =>  -- matches any string of zero or more characters          BEGIN          IF file[fileIndex] = '> THEN            IF i < mask.length - 1 AND mask[i + 1] = wildString THEN              RETURN[Match[file, fileIndex + 1, mask, i]]            ELSE RETURN[FALSE];          FOR j IN [fileIndex..file.length] DO            IF Match[file, j, mask, i + 1] THEN RETURN[TRUE]; ENDLOOP;          RETURN[FALSE];          END;        wildChar =>  -- matches any single character          BEGIN          IF (file[fileIndex] = '> OR file[fileIndex] = '<) THEN RETURN[FALSE];          IF fileIndex = file.length THEN RETURN[FALSE];          fileIndex ¬ fileIndex + 1;          END;        ENDCASE =>          IF fileIndex = file.length            OR String.LowerCase[file[fileIndex]] # String.LowerCase[mask[i]] THEN            RETURN[FALSE]          ELSE fileIndex ¬ fileIndex + 1;      ENDLOOP;    -- filename passes mask if entire filename has been consumed    outcome ¬ fileIndex = file.length;    END;      S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};      NoOp: NSExec.ExecProc = {};    GetServerId: PROCEDURE [exec: NSExec.Handle] = {    ok: BOOLEAN;    authCallError: Auth.CallProblem;    desc: NSString.String ¬ NSString.nullString;    BEGIN    [name: gf.serviceName, desc: desc, identity: gf.serverId] ¬      AccessCH.RegisterService[	primaryPID:	AccessCH.librarianServicePID,	genericPIDs:	AccessCH.librarianGenericPIDs,	secondaryPIDs:	AccessCH.librarianSecondaryPIDs,	authLevel:	neither,	execHandle:	exec,	clientID:	gf.execId,	z:		gf.z !	  AccessCH.Problem =>	   IF type = entryExisted THEN CONTINUE	   ELSE SIGNAL regProb];    IF desc#NSString.nullString THEN NSString.FreeString[gf.z, desc];    [gf.chConv, ok, authCallError] ¬ CH.MakeConversationHandle[gf.serverId];    IF ~ok THEN {      msg: NSString.String ¬ MsgOps.AuthCallErrToMsg[        authCallError, notApplicable].msg;      NSExec.PutErrorMessage[exec, msg];      Auth.FreeIdentity[@gf.serverId];      SIGNAL regProb};    END};  -- Exported to LibMessages  -- returns the NSString corresponding to key  M: PUBLIC PROCEDURE [key: LibMessages.MessageKey]    RETURNS [string: NSString.String] = {    r: XString.ReaderBody ¬ XMessage.Get[libMsgs, key.ORD];    string ¬ [bytes: LOOPHOLE[r.bytes], length: r.limit, maxlength: r.limit]};  PutMsg: PUBLIC PROC [    e: NSExec.Handle, template: NSString.String,    s1, s2, s3, s4: NSString.String ¬ NSString.nullString] = {    msg: NSString.String ¬ ExpandMsg[gf.z, template, s1, s2, s3, s4];    NSTTY.PutString[NSExec.GetTTY[e], msg];    NSString.FreeString[gf.z, msg]};  ExpandMsg: PUBLIC PROC [    z: UNCOUNTED ZONE, template: NSString.String,    s1, s2, s3, s4: NSString.String ¬ NSString.nullString]    RETURNS [result: NSString.String] = {    args: ARRAY [0..4) OF NSString.String ¬ [s1, s2, s3, s4];    numArgs: CARDINAL ¬ SELECT TRUE FROM      (s1 = NSString.nullString) => 0,      (s2 = NSString.nullString) => 1,      (s3 = NSString.nullString) => 2,      (s4 = NSString.nullString) => 3,      ENDCASE => 4;    RETURN [      IF numArgs = 0 THEN NSString.CopyString[z, template]      ELSE Message.Expand[template, DESCRIPTOR[BASE[args], numArgs], z]]};  NoteEvent: PUBLIC PROC [s: NSString.String] = {    NSExec.BroadcastAsyncMessage[s, gf.execId]};-- main line code  InitModule: PROC = {    libMsgs ¬ LibMessages.GetMessages[];    gf ¬ [      tracing: TRUE, execId: NSExec.AssignClientID[],      me: Courier.LocalSystemElement[]];    NSExec.CreateClient[      id: gf.execId,       command: [name: M[keyLibrarianService], proc: NoOp],       procs: procs,       acronym: M[keyLS]]};  InitModule[];}...  -- of LibServControl  
--  File: NSBTreeImplB.mesa; last edited by: --  PXK    ,	21-Mar-84 11:04:10--  BJD    ,	 4-Sep-84 16:43:53DIRECTORY  NSBTree USING [    defaultValueSize, maxNameLength, ReadOnly, Tree, TreeObject, Value, ValueSize,    VolumeNotOpen, ValueTooSmall],  NSBTreeInternal USING [    bTreePage, CheckVolumeAccess, CopyValue, debug, emptySize, EntryHandle,    EntryName, EntryPointer, EntryPointerPointer, EntrySize, EntryValue,    FirstEntry, FirstFreeEntry, firstPagePointer, FlushGNCache, heap,    InsertInNode, InternalFind,    LastEntry, maxTreeSize, MoveLongString, NextEntry,    nilPagePointer, Overhead, PageHandle, PagePointer, SnapShot, Successor,    treeIncrement, TreeObject, ValuePointer],  ByteBlt USING [ByteBlt],  Environment USING [PageCount, wordsPerPage],  File USING [File, GetSize, nullFile, SetSize],  Inline USING [<<LongCOPY, LongDivMod,>> LowHalf],  NSFile USING [Handle, nullHandle, nullSession, Session],  NSSegment USING [GetSizeInPages, SetSizeInPages],  NSSegmentInternal USING [GetID],  Space USING [    Allocate, Deallocate, ForceOut, Interval, Map, MapAt,     nullInterval, Unmap, UnmapAt, Usage, Window],  SpecialNSBTree USING [Error, Unmapped],  Volume USING [GetStatus];NSBTreeImplB: MONITOR LOCKS tree USING tree: Tree  IMPORTS    NSBTree, NSBTreeInternal, ByteBlt, File, Inline, NSSegment,    NSSegmentInternal, SpecialNSBTree, Space, Volume  EXPORTS NSBTree, NSBTreeInternal, SpecialNSBTree =  BEGIN  TreeObject: PUBLIC TYPE = NSBTreeInternal.TreeObject;  Tree: TYPE = LONG POINTER TO TreeObject;  bTreePage: CARDINAL = NSBTreeInternal.bTreePage;  maxTreeSize: CARDINAL = NSBTreeInternal.maxTreeSize;  -- (disk pages)  emptySize: CARDINAL = NSBTreeInternal.emptySize;  -- the size of an empty page  PageHandle: TYPE = NSBTreeInternal.PageHandle;  PagePointer: TYPE = NSBTreeInternal.PagePointer;  nilPagePointer: PagePointer = NSBTreeInternal.nilPagePointer;  EntryHandle: TYPE = NSBTreeInternal.EntryHandle;  snapShot: PageHandle _ NIL;  snapShotSpace: Space.Interval _ Space.nullInterval;  initialReadOnlyMaps: BOOLEAN _ TRUE;  -- PUBLIC procedures and signals  -- SpecialNSBTree  AutoForceOut: PUBLIC ENTRY PROCEDURE [tree: Tree, auto: BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    tree.autoForceOut _ auto;    IF auto AND tree.base # NIL THEN Space.ForceOut[tree.space];    END;  -- NSBTree  Delete: PUBLIC PROCEDURE [tree: Tree] =    -- Get rid of a B-Tree.    BEGIN    LocalDelete: ENTRY PROCEDURE [tree: Tree] =      BEGIN      ENABLE UNWIND => NULL;      NSBTreeInternal.FlushGNCache[tree];      IF tree.base # NIL THEN         tree.space.pointer _ Space.Unmap[tree.space.pointer];      END;    LocalDelete[tree];    NSBTreeInternal.heap.FREE[@tree];    END;  -- NSBTree   Empty: PUBLIC ENTRY PROCEDURE [tree: Tree] RETURNS [BOOLEAN] =    -- B-Tree predicate    BEGIN    ENABLE UNWIND => NULL;    IF tree.base = NIL THEN {SIGNAL Unmapped[tree]; MapInternal[tree]};    RETURN[tree.base[tree.top].size = emptySize]    END;  -- SpecialNSBTree    ForceOut: PUBLIC ENTRY PROCEDURE [tree: Tree] =    BEGIN    ENABLE UNWIND => NULL;    IF tree.base = NIL THEN {SIGNAL Unmapped[tree]; MapInternal[tree]};    Space.ForceOut[tree.space];    END;  -- NSBTree    GetInfo: PUBLIC ENTRY PROCEDURE [tree: Tree]    RETURNS [valueSize: NSBTree.ValueSize,      file: NSFile.Handle, usage: Space.Usage] = {    RETURN[tree.valueSize, tree.file, tree.usage]};  -- SpecialNSBTree  Invalid: PUBLIC SIGNAL [error: SpecialNSBTree.Error] = CODE;  -- NSBTree   Make: PUBLIC PROCEDURE [    file: NSFile.Handle _ NSFile.nullHandle,    session: NSFile.Session ¬ NSFile.nullSession,    usage: Space.Usage,    valueSize: NSBTree.ValueSize _ NSBTree.defaultValueSize,     reset: BOOLEAN _ FALSE]    RETURNS [tree: Tree] =    BEGIN    capa: File.File _ File.nullFile;    lpSize: LONG CARDINAL _ 1;    IF file # NSFile.nullHandle THEN      [capa, lpSize] _ NSSegmentInternal.GetID[file: file, session: session];    tree _ MakeFromCapa[capa, usage, CARDINAL[lpSize], valueSize, reset];    tree.file _ file;    tree.session ¬ session;    IF file # NSFile.nullHandle THEN      NSSegment.SetSizeInPages[        file: file, pages: File.GetSize[capa] - lpSize, session: session];    END;  MakeFromCapa: PROCEDURE [      cap: File.File _ File.nullFile,      usage: Space.Usage,      lpSize: CARDINAL _ 1,      valueSize: NSBTree.ValueSize _ NSBTree.defaultValueSize,      reset: BOOLEAN _ FALSE]    RETURNS [tree: Tree] =    -- Make a new B-Tree.  If cap is File.nullFile, use a data space    BEGIN    pPage: PageHandle;    p: PagePointer;    window: Space.Window;    oddSize: BOOLEAN _ FALSE;    tree _ NSBTreeInternal.heap.NEW[      TreeObject _ [      lpSize: lpSize, cap: cap, usage: usage,      valueSize: valueSize, autoForceOut: TRUE]];    IF cap = File.nullFile THEN      BEGIN      tree.size _ maxTreeSize;      tree.lpSize _ 0;      window _ [file: File.nullFile, base: NULL, count: maxTreeSize];      tree.spaceReadOnly _ FALSE;      END     ELSE      BEGIN      tree.size _ File.GetSize[cap];       IF tree.size <= tree.lpSize THEN        SELECT Volume.GetStatus[tree.cap.volumeID] FROM          openRead  => ERROR NSBTree.ReadOnly[NIL];	  openReadWrite => {	    File.SetSize[              tree.cap, NSBTreeInternal.treeIncrement*bTreePage + tree.lpSize];            tree.size _ NSBTreeInternal.treeIncrement*bTreePage};	  ENDCASE => ERROR NSBTree.VolumeNotOpen[tree.cap.volumeID]      ELSE tree.size _ tree.size - tree.lpSize;      window _ [        file: cap, base: tree.lpSize, count: tree.size -- MIN[maxTreeSize, tree.size] --];      SELECT Volume.GetStatus[tree.cap.volumeID] FROM        openRead  => tree.spaceReadOnly _ TRUE;	openReadWrite => tree.spaceReadOnly _ initialReadOnlyMaps;	ENDCASE => ERROR NSBTree.VolumeNotOpen[tree.cap.volumeID];      END;    -- Create a space big enough for the tree and two expansions    tree.space _ Space.Map[      window: window,      usage: tree.usage,      swapUnits: [uniform[bTreePage]],       access: IF tree.spaceReadOnly THEN readOnly ELSE readWrite];     tree.base _ tree.space.pointer;    -- See if we have a real B-Tree or not.    -- IF YOU WISH TO BE MORE ROBUST, use Validate.    IF reset OR (tree.base[tree.base.top].size = 0) THEN {      --  We have a new file      NSBTreeInternal.CheckVolumeAccess[tree];      IF tree.size MOD 2 # 0 THEN {        tree.space.pointer _ Space.Unmap[tree.space.pointer];	tree.size _ tree.size + 1;	File.SetSize[tree.cap, tree.size];	window.count _ window.count + 1;	tree.space _ Space.Map[window: window, usage: tree.usage, 	        swapUnits: [uniform[bTreePage]], access: readWrite]};      tree.top _ NSBTreeInternal.firstPagePointer;      --  Set up the first page      tree.base^ _ [        size: emptySize, free: FALSE, sizeValue: tree.valueSize, top: tree.top,        parent: nilPagePointer, lastPointer: nilPagePointer, entries:];      --  initialize the rest of the tree to free pages      p _ NSBTreeInternal.firstPagePointer + Environment.wordsPerPage*bTreePage;      pPage _ @tree.base[p];      THROUGH [1..tree.size/bTreePage) DO        pPage.free _ TRUE;        pPage _ pPage + bTreePage*Environment.wordsPerPage;        ENDLOOP;      Space.ForceOut[tree.space]}    ELSE -- This is a bonifide B-Tree --      BEGIN      tree.top _ tree.base.top;      tree.valueSize _        IF tree.base.sizeValue = 0 THEN NSBTree.defaultValueSize	ELSE tree.base.sizeValue;      END;    END;  -- SpecialNSBTree   Map: PUBLIC ENTRY PROCEDURE [tree: Tree] =    BEGIN    ENABLE UNWIND => NULL;    IF tree.cap # File.nullFile AND tree.base = NIL THEN MapInternal[tree];    END;  -- NSBTree  Remove: PUBLIC ENTRY PROCEDURE [    tree: Tree, name: LONG STRING, value: NSBTree.Value] RETURNS [ok: BOOLEAN] =    -- remove an entry from the B-Tree and return the value    BEGIN    ENABLE UNWIND => NULL;    pEntry: EntryHandle;    page: PagePointer;    vp: NSBTreeInternal.ValuePointer;    IF tree.base = NIL THEN {      SIGNAL SpecialNSBTree.Unmapped[tree]; MapInternal[tree]};    NSBTreeInternal.CheckVolumeAccess[tree];    [ok: ok, value: vp, page: page, ent: pEntry] _ NSBTreeInternal.InternalFind[      tree, name];    IF ~ok THEN RETURN;    IF NSBTreeInternal.debug THEN NSBTreeInternal.SnapShot[tree];    IF value # NIL THEN ok _ ~NSBTreeInternal.CopyValue[value, vp, tree.valueSize];    DeleteInternal[tree, page, pEntry];    IF tree.autoForceOut THEN Space.ForceOut[tree.space];    NSBTreeInternal.FlushGNCache[tree];    IF NSBTreeInternal.debug THEN InternalValidateBTree[tree];    IF ~ok THEN ERROR NSBTree.ValueTooSmall[tree];    END;  -- SpecialNSBTree    Unmap: PUBLIC ENTRY PROCEDURE [tree: Tree] =    BEGIN    ENABLE UNWIND => NULL;    IF (tree.cap # File.nullFile) AND (tree.base # NIL) THEN      BEGIN tree.space _ Space.UnmapAt[tree.space.pointer]; tree.base _ NIL; END;    END;  -- SpecialNSBTree  Unmapped: PUBLIC SIGNAL [tree: Tree] = CODE;  -- SpecialNSBTree  Validate: PUBLIC ENTRY PROCEDURE [tree: Tree] = {};<<  BEGIN    ENABLE UNWIND => NULL;    IF tree.base = NIL THEN {SIGNAL Unmapped[tree]; MapInternal[tree]};    InternalValidateBTree[tree ! InvalidTree => {SIGNAL Invalid[error]; RESUME }];    END; >>  -- private procedures and signals  BalanceBrothers: INTERNAL PROCEDURE [    tree: Tree, low, high: PagePointer, parent: PageHandle,    parentEntry: EntryHandle, totalSize: CARDINAL] =    BEGIN    lowPage: PageHandle _ @tree.base[low];    highPage: PageHandle _ @tree.base[high];    midName: STRING _ [NSBTree.maxNameLength];    midValue: PACKED ARRAY [0..LAST[NSBTree.ValueSize]) OF CARDINAL;    pE1, pE2, pE3: EntryHandle;    copySize, loopSize, parentEntrySize: CARDINAL;    parentEntrySize _ NSBTreeInternal.EntrySize[tree, parentEntry];    IF lowPage.size > highPage.size THEN      BEGIN      -- move entries into the "higher" page      pE1 _ NSBTreeInternal.FirstEntry[lowPage];      pE2 _ NSBTreeInternal.LastEntry[tree, lowPage];      loopSize _ emptySize + NSBTreeInternal.EntrySize[tree, pE1];      WHILE loopSize < totalSize/2 DO        pE1 _ NSBTreeInternal.NextEntry[tree, pE1];        loopSize _ loopSize + NSBTreeInternal.EntrySize[tree, pE1];        IF pE1 = pE2 THEN RETURN;  -- leave well enough alone!        ENDLOOP;      loopSize _ loopSize - NSBTreeInternal.EntrySize[tree, pE1];      -- save the middle name, value      NSBTreeInternal.MoveLongString[midName, NSBTreeInternal.EntryName[tree, pE1]];      Copy[        from: NSBTreeInternal.EntryValue[tree, pE1], to: @midValue,        size: tree.valueSize];      -- make room in the more empty node      copySize _        lowPage.size - loopSize - NSBTreeInternal.EntrySize[tree, pE1] +          parentEntrySize;      pE2 _ pE3 _ NSBTreeInternal.FirstEntry[highPage];      Copy[from: pE2, to: pE2 + copySize, size: highPage.size - emptySize];      -- move in the entries from the brother      Copy[        from: NSBTreeInternal.NextEntry[tree, pE1], to: pE2,        size: copySize - parentEntrySize];      pE2 _ pE2 + copySize - parentEntrySize;      -- move parent entry      Copy[from: parentEntry, to: pE2, size: parentEntrySize];      NSBTreeInternal.EntryPointerPointer[tree, pE2]^ _ lowPage.lastPointer;      lowPage.lastPointer _ NSBTreeInternal.EntryPointer[tree, pE1];      lowPage.size _ loopSize;      highPage.size _ highPage.size + copySize;      IF highPage.lastPointer # nilPagePointer THEN        BEGIN        --  change parent pointers of moved children        pE2 _ NSBTreeInternal.NextEntry[tree, pE2];        WHILE pE3 # pE2 DO          tree.base[NSBTreeInternal.EntryPointer[tree, pE3]].parent _ high;          pE3 _ NSBTreeInternal.NextEntry[tree, pE3];          ENDLOOP        END      END    ELSE      BEGIN      -- move entries into the "lower" page      -- copy the parent entry into the page      pE2 _ pE3 _ NSBTreeInternal.FirstFreeEntry[lowPage];      Copy[from: parentEntry, to: pE2, size: parentEntrySize];      NSBTreeInternal.EntryPointerPointer[tree, pE2]^ _ lowPage.lastPointer;      -- copy from the brother until the node is about 1/2 full      pE1 _ NSBTreeInternal.FirstEntry[highPage];      pE2 _ pE2 + parentEntrySize;      copySize _ NSBTreeInternal.EntrySize[tree, pE1];      loopSize _ lowPage.size + parentEntrySize + copySize;      WHILE loopSize < totalSize/2 DO        pE1 _ NSBTreeInternal.NextEntry[tree, pE1];        copySize _ copySize + NSBTreeInternal.EntrySize[tree, pE1];        loopSize _ lowPage.size + parentEntrySize + copySize;        ENDLOOP;      copySize _ copySize - NSBTreeInternal.EntrySize[tree, pE1];      Copy[from: NSBTreeInternal.FirstEntry[highPage], to: pE2, size: copySize];      lowPage.lastPointer _ NSBTreeInternal.EntryPointer[tree, pE1];      --  save the new parent name, tree      NSBTreeInternal.MoveLongString[midName, NSBTreeInternal.EntryName[tree, pE1]];      Copy[        from: NSBTreeInternal.EntryValue[tree, pE1], to: @midValue,        size: tree.valueSize];      --move entries over in page we copied from      Copy[        from: NSBTreeInternal.NextEntry[tree, pE1],        to: NSBTreeInternal.FirstEntry[highPage],        size:        highPage.size - copySize - emptySize - NSBTreeInternal.EntrySize[          tree, pE1]];      lowPage.size _ lowPage.size + parentEntrySize + copySize;      highPage.size _        highPage.size - copySize - NSBTreeInternal.Overhead[tree] - SIZE[          StringBody [midName.length]];      IF lowPage.lastPointer # nilPagePointer THEN        BEGIN        --  change parent pointers of moved children        tree.base[lowPage.lastPointer].parent _ low;        WHILE pE3 # NSBTreeInternal.FirstFreeEntry[lowPage] DO          tree.base[NSBTreeInternal.EntryPointer[tree, pE3]].parent _ low;          pE3 _ NSBTreeInternal.NextEntry[tree, pE3];          ENDLOOP;        END;      END;    -- Remove the old parent entry and put in the new parent entry    IF parent.parent = nilPagePointer      AND parent.size = emptySize + NSBTreeInternal.EntrySize[tree, parentEntry]      THEN      BEGIN      --  this is the parent with one entry... do differently      NSBTreeInternal.EntryName[tree, parentEntry]^ _ [        length: 0, maxlength: midName.length, text:];      Copy[        from: midName, to: NSBTreeInternal.EntryName[tree, parentEntry],        size: SIZE[StringBody [midName.length]]];      Copy[        from: @midValue, to: NSBTreeInternal.EntryValue[tree, parentEntry],        size: tree.valueSize];      parent.size _ emptySize + NSBTreeInternal.EntrySize[tree, parentEntry];      END    ELSE      BEGIN      Squeeze[tree, lowPage.parent, parentEntry];      -- replace entry with successor entry      [] _ NSBTreeInternal.InsertInNode[        tree, lowPage.parent, midName, LOOPHOLE[LONG[@midValue]], high];      END;    END;  ChooseBrother: INTERNAL PROCEDURE [tree: Tree, p: PagePointer]    RETURNS [low, high: PagePointer, parentEntry: EntryHandle] =    BEGIN    pParent: PageHandle _ @tree.base[tree.base[p].parent];    pLast, pNext: EntryHandle;    IF pParent.lastPointer = p THEN      BEGIN      high _ p;      parentEntry _ NSBTreeInternal.LastEntry[tree, pParent];      low _ NSBTreeInternal.EntryPointer[tree, parentEntry];      RETURN      END;    parentEntry _ NSBTreeInternal.FirstEntry[pParent];    IF NSBTreeInternal.EntryPointer[tree, parentEntry] = p THEN      BEGIN      low _ p;      pNext _ NSBTreeInternal.NextEntry[tree, parentEntry];      high _        IF pNext = NSBTreeInternal.FirstFreeEntry[pParent] THEN pParent.lastPointer        ELSE NSBTreeInternal.EntryPointer[tree, pNext];      RETURN;      END;    pLast _ NSBTreeInternal.NextEntry[tree, parentEntry];    UNTIL NSBTreeInternal.EntryPointer[tree, parentEntry] = p DO      pLast _ parentEntry;      parentEntry _ NSBTreeInternal.NextEntry[tree, parentEntry];      ENDLOOP;    pNext _ NSBTreeInternal.NextEntry[tree, parentEntry];    high _      IF pNext = NSBTreeInternal.FirstFreeEntry[pParent] THEN pParent.lastPointer      ELSE NSBTreeInternal.EntryPointer[tree, pNext];    IF tree.base[NSBTreeInternal.EntryPointer[tree, pLast]].size < tree.base[      high].size THEN low _ p    ELSE      BEGIN      low _ NSBTreeInternal.EntryPointer[tree, pLast];      high _ p;      parentEntry _ pLast      END;    END;  Compress: INTERNAL PROCEDURE [tree: Tree, p: PagePointer, pE: EntryHandle] =    -- remove entry i from node p, with fill from a brother if necessary    BEGIN    dPage: PageHandle;    high: PagePointer;  -- the node of the two brothers with the higher keys    low: PagePointer;  -- the node of the two brothers with the lower keys    pParent: PageHandle;    parentEntry: EntryHandle;    totalSize: CARDINAL;    dPage _ @tree.base[p];    -- compress out the old entry    Squeeze[tree, p, pE];    IF (dPage.size >= bTreePage*Environment.wordsPerPage/2)      OR (dPage.parent = nilPagePointer) THEN RETURN;    -- the node is too small, so fill in from a brother    pParent _ @tree.base[dPage.parent];    [low, high, parentEntry] _ ChooseBrother[tree, p];    totalSize _      tree.base[high].size + tree.base[low].size + NSBTreeInternal.EntrySize[        tree, parentEntry] - emptySize;    (IF totalSize <= bTreePage*Environment.wordsPerPage THEN MergeBrothers     ELSE BalanceBrothers)[tree, low, high, pParent, parentEntry, totalSize];    END;  Copy: INTERNAL PROCEDURE [from, to: LONG POINTER, size: CARDINAL] = --INLINE-- {    [] _ ByteBlt.ByteBlt[      from: [from, 0, size*2], to: [to, 0, size*2], overLap: move]};  DeleteInternal: INTERNAL PROCEDURE [    tree: Tree, p: PagePointer, i: EntryHandle] =    -- delete node p entry i    BEGIN    page: PageHandle = @tree.base[p];    succPage, after: PagePointer;    pE: EntryHandle;    IF NSBTreeInternal.EntryPointer[tree, i] = nilPagePointer THEN      Compress[tree, p, i]    ELSE      BEGIN      [succPage, after] _ NSBTreeInternal.Successor[tree, p, i];      pE _ NSBTreeInternal.FirstEntry[@tree.base[succPage]];  -- pointer to successor entry      IF (page.parent = nilPagePointer)        AND (page.size = emptySize + NSBTreeInternal.EntrySize[tree, i]) THEN {        -- this is the parent with one entry... do differently        Copy[          from: NSBTreeInternal.EntryName[tree, pE],          to: NSBTreeInternal.EntryName[tree, i],          size: SIZE[StringBody [NSBTreeInternal.EntryName[tree, pE].length]]];        Copy[          from: NSBTreeInternal.EntryValue[tree, pE],          to: NSBTreeInternal.EntryValue[tree, i], size: tree.valueSize];        page.size _ emptySize + NSBTreeInternal.EntrySize[tree, pE]}      ELSE        BEGIN        Squeeze[tree, p, i];  -- replace entry with successor entry        [] _ NSBTreeInternal.InsertInNode[          tree, p, NSBTreeInternal.EntryName[tree, pE], NSBTreeInternal.EntryValue[          tree, pE], after];        END;      DeleteInternal[tree, succPage, pE]  -- Delete the successor entry      END;    END;  -- NSBTreeInternal   InternalValidateBTree: PUBLIC INTERNAL PROCEDURE [tree: Tree] = {};<<>  --  Perform some tests on this B-Tree    BEGIN    pPage: PagePointer;    iPage: CARDINAL;    pageTouched: ARRAY [0..maxTreeSize/bTreePage) OF BOOLEAN _ ALL[FALSE];    PointerToIndex: INTERNAL PROCEDURE [p: PagePointer]      RETURNS [index: CARDINAL] =      --change a page pointer to an index, doing some checking as we go      BEGIN      pNumber: LONG CARDINAL = LOOPHOLE[p, LONG CARDINAL];      mod: CARDINAL;      -- pointer must be multiple of page size      [index, mod] _ Inline.LongDivMod[        pNumber, bTreePage*Environment.wordsPerPage];      IF mod # 0 THEN ERROR InvalidTree[BadPointer, tree.base, p, NIL];      RETURN[index];      END;    ValidatePage: INTERNAL PROCEDURE [p, parent: PagePointer] =      --check this page for validity      BEGIN      pE: EntryHandle;      pP: PageHandle;      iP: CARDINAL;      size: CARDINAL;      leafPage: BOOLEAN;      iP _ PointerToIndex[p];      IF iP > tree.size - 1 THEN SIGNAL InvalidTree[SizeError, tree.base, p, NIL];      pP _ @tree.base[p];      IF pageTouched[iP] THEN {        SIGNAL InvalidTree[Cycle, tree.base, p, NIL]; RETURN};      pageTouched[iP] _ TRUE;      IF pP.free THEN {        SIGNAL InvalidTree[BadPointer, tree.base, parent, NIL]; RETURN};      IF pP.size < emptySize OR pP.size > bTreePage*Environment.wordsPerPage THEN        {SIGNAL InvalidTree[SizeError, tree.base, p, NIL]; RETURN};      IF pP.size = emptySize AND (pP.parent # nilPagePointer) THEN {        SIGNAL InvalidTree[SizeError, tree.base, p, NIL]; RETURN};      IF pP.parent # parent THEN {        SIGNAL InvalidTree[BadPointer, tree.base, p, NIL]; RETURN};      leafPage _ pP.lastPointer = nilPagePointer;      size _ emptySize;      pE _ NSBTreeInternal.FirstEntry[pP];      WHILE size < pP.size DO        IF          (NSBTreeInternal.EntryName[tree, pE].length > NSBTreeInternal.EntryName[            tree, pE].maxlength)          OR (NSBTreeInternal.EntryName[tree, pE].length > NSNSBTree.maxNameLength)          OR (NSBTreeInternal.EntryName[tree, pE].length = 0) THEN {          SIGNAL InvalidTree[SizeError, tree.base, p, pE]; RETURN};        IF NSBTreeInternal.EntryPointer[tree, pE] # nilPagePointer THEN          BEGIN          IF leafPage THEN SIGNAL InvalidTree[LeafError, tree.base, p, pE];          ValidatePage[p: NSBTreeInternal.EntryPointer[tree, pE], parent: p];          END        ELSE IF ~leafPage THEN SIGNAL InvalidTree[LeafError, tree.base, p, pE];        size _ size _ size + NSBTreeInternal.EntrySize[tree, pE];        pE _ NSBTreeInternal.NextEntry[tree, pE];        ENDLOOP;      IF ~leafPage THEN ValidatePage[p: pP.lastPointer, parent: p];      RETURN      END;  -- ValidatePage    ValidatePage[tree.top, nilPagePointer];    pPage _ NSBTreeInternal.firstPagePointer;    iPage _ 0;    THROUGH [0..tree.size/bTreePage) DO  --  test for orphan pages      IF ~tree.base[pPage].free AND ~pageTouched[iPage] THEN        SIGNAL InvalidTree[Orphan, tree.base, pPage, NIL];      pPage _ pPage + bTreePage*Environment.wordsPerPage;      iPage _ iPage + 1;      ENDLOOP;    RETURN    END; >>  -- NSBTreeInternal  MapInternal: PUBLIC INTERNAL PROCEDURE [tree: Tree] =    BEGIN    newSize: Environment.PageCount =      IF tree.file = NSFile.nullHandle THEN File.GetSize[tree.cap] - tree.lpSize      ELSE NSSegment.GetSizeInPages[file: tree.file, session: tree.session];    IF newSize > tree.size THEN      BEGIN      tree.size _ newSize;      Space.Deallocate[tree.space];      tree.space _ Space.Allocate[        count: tree.size + 2*NSBTreeInternal.treeIncrement*bTreePage];      -- MIN[maxTreeSize, tree.size + 2*NSBTreeInternal.treeIncrement*bTreePage]];      END;    SELECT Volume.GetStatus[tree.cap.volumeID] FROM        openRead  => tree.spaceReadOnly _ TRUE;	openReadWrite => tree.spaceReadOnly _ initialReadOnlyMaps;	ENDCASE => ERROR NSBTree.VolumeNotOpen[tree.cap.volumeID];    [] _ Space.MapAt[      at: tree.space,      window: [        tree.cap, tree.lpSize,	tree.size + 2*NSBTreeInternal.treeIncrement*bTreePage],      -- MIN[maxTreeSize, tree.size + 2*NSBTreeInternal.treeIncrement*bTreePage]],      usage: tree.usage,      swapUnits: [uniform[bTreePage]],      access: IF tree.spaceReadOnly THEN readOnly ELSE readWrite];    tree.base _ tree.space.pointer;    tree.top _ tree.base.top;    END;  MergeBrothers: INTERNAL PROCEDURE [    tree: Tree, low, high: PagePointer, parent: PageHandle,    parentEntry: EntryHandle, totalSize: CARDINAL] =    BEGIN    lowPage: PageHandle _ @tree.base[low];    highPage: PageHandle _ @tree.base[high];    parentEntrySize: CARDINAL = NSBTreeInternal.EntrySize[tree, parentEntry];    pChange, pFillEnd: EntryHandle;    pChange _ pFillEnd _ NSBTreeInternal.FirstFreeEntry[lowPage];    Copy[from: parentEntry, to: pFillEnd, size: parentEntrySize];    NSBTreeInternal.EntryPointerPointer[tree, pFillEnd]^ _ lowPage.lastPointer;    pFillEnd _ pFillEnd + parentEntrySize;    Copy[      from: NSBTreeInternal.FirstEntry[highPage], to: pFillEnd,      size: highPage.size - emptySize];    lowPage.lastPointer _ highPage.lastPointer;    lowPage.size _ totalSize;    OldPage[tree, high];    IF lowPage.lastPointer # nilPagePointer THEN      BEGIN      --  change parent pointers of new children      tree.base[lowPage.lastPointer].parent _ low;      WHILE pChange # NSBTreeInternal.FirstFreeEntry[lowPage] DO        tree.base[NSBTreeInternal.EntryPointer[tree, pChange]].parent _ low;        pChange _ NSBTreeInternal.NextEntry[tree, pChange];        ENDLOOP;      END;    IF tree.top = lowPage.parent AND parent.size = parentEntrySize + emptySize      THEN      BEGIN      -- this compress shrinks the tree      tree.top _ tree.base.top _ low;      OldPage[tree, lowPage.parent];      lowPage.parent _ nilPagePointer;      END    ELSE Compress[tree, lowPage.parent, parentEntry];    END;  InvalidTree: SIGNAL [    error: SpecialNSBTree.Error, base: PageHandle, page: PagePointer,    entry: EntryHandle] = CODE;  OldPage: INTERNAL PROCEDURE [tree: Tree, p: PagePointer] = INLINE {    tree.base[p].free _ TRUE};  -- NSBTreeInternal  SnapShot: PUBLIC INTERNAL PROCEDURE [tree: Tree] = {};  <<  --  Copy the b-tree into the debug space    BEGIN    from, to: LONG POINTER;    IF snapShot = NIL THEN      BEGIN      snapShotSpace _ Space.Map[        window: [file: File.nullFile, base: NULL, count: maxTreeSize],	usage: MUsage.bTreeDebug, 	swapUnits: [uniform[bTreePage]]];      snapShot _ snapShotSpace.pointer;      END;    from _ tree.base;    to _ snapShot;    FOR wordsLeft: LONG CARDINAL _ tree.size*Environment.wordsPerPage,         wordsLeft - LAST[CARDINAL] DO      Inline.LongCOPY[        from: from, to: to, nwords: CARDINAL[MIN[wordsLeft, LAST[CARDINAL]]]];      IF wordsLeft <= LAST[CARDINAL] THEN EXIT;      from _ from + LAST[CARDINAL];      to _ to + LAST[CARDINAL];      ENDLOOP;    END; >>  Squeeze: INTERNAL PROCEDURE [tree: Tree, p: PagePointer, pE: EntryHandle] =    -- squeeze out the entry pointed to by pE    BEGIN    compress, copy: CARDINAL;    pNext: EntryHandle _ NSBTreeInternal.NextEntry[tree, pE];    compress _ NSBTreeInternal.EntrySize[tree, pE];    copy _      tree.base[p].size - Inline.LowHalf[        LOOPHOLE[pNext, LONG CARDINAL] - LOOPHOLE[@tree.base[p], LONG CARDINAL]];    IF copy # 0 THEN      BEGIN      NSBTreeInternal.EntryPointerPointer[tree, pNext]^ _        NSBTreeInternal.EntryPointer[tree, pE];      Copy[from: pNext, to: pE, size: copy];      END    ELSE tree.base[p].lastPointer _ NSBTreeInternal.EntryPointer[tree, pE];    tree.base[p].size _ tree.base[p].size - compress;    RETURN    END;  END.           LOG      Time: 8-Jun-81 11:53:00 AM By: KAM  	Action: Created from DirectoryTreesImpl      Time: 22-Sep-81 17:20:41 By: KAM  	Action: NSBTreeGetNext now returns the entry that would follow name, even if name is not in    the b-tree.  Changed the get next cache from an array to a linked list, so it will never run out of room.      Time:  1-Oct-81 12:20:46 By: PXK    	Action: MONITORizing it and making Validation public, now has own heap.      Time:  5-Oct-81 16:11:09 By: KAM  	Action: Added PROCs SwapValue and SnapShot, attached cache entry to a b-tree descriptor,    added parameters reset and lpSize to Make.      Time:  January 27, 1982  5:45 PM By: KAM  	Action: Made less greedy in creating spaces for NSBTrees.      Time:  11-Mar-82  8:55:08 By: KAM  	Action: Added Map and Unmap plus support.   Time:  20-Sep-82 16:25:15 By: KAM  	Action: Split from NSBTreeImpl. Added NSFile Make and variable value size.   Time:   9-Nov-82 14:22:38 By: KAM  	Action: MapInternal didn't check to see if tree has changed whilst unmapped.   Time:  29-Nov-82 19:34:30 By: KAM  	Action: Remove deleted the entry before copying the value to the client storage.   Time:  12-May-83 18:31:54 By: KAM  	Action: Added read only stuff.   Time:  27-Jul-83 10:28:12 By: DWE      Action: added usage parameter.   Time:  21-Mar-84 10:53:09 By: PXK      Action: converted to NSFiling.      
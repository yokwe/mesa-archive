-- File: XStringHashTableImpl.mesa - last edit:-- bjd                  4-Nov-87 12:35:42-- kam                 13-Jun-86 13:46:01-- Copyright (C) 1986, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  ByteBlt USING [ByteBlt],  Environment USING [Block, Byte, PageFromLongPointer, wordsPerPage],  Format,  File USING [File],  Heap,  Inline USING [BITXOR, LongCOPY],  NSFile,  NSSegment USING [GetSizeInPages, ID, Session, SetSizeInPages],  NSSegmentInternal USING [GetID],  Space USING [ForceOut, Map, Unmap],  Volume USING [ID],  XChar USING [Character, Code, Decase],  XCharSet0 USING [Make],  XString,  XStringHashTable USING [maxNameLength, Value, ValueSize],  XStringHashTableExtra;XStringHashTableImpl: MONITOR LOCKS table USING table: Table  IMPORTS    ByteBlt, Environment, Format, Heap, Inline, NSFile, NSSegment, NSSegmentInternal, Space, XChar, XCharSet0, XString  EXPORTS XStringHashTable, XStringHashTableExtra  SHARES XString =  BEGIN  <<  The hash table consists of an array of buckets followed by an array of entries.  Each bucket contains a "pointer" that is the word position in the file of its  first entry. The buckets are each two words long and the buckets must take up  an integral number of pages (otherwise, a part of the file could be mapped into  two portions of VM). The local constant "pagesForTable" in the Create procedure  defines the number of buckets. The buckets are always mapped. The first bucket  is used to point to a special "entry zero" that holds information about the  hash table (described below).    The entries in a bucket are stored in sort order as a linked list. Each entry  contains the serialized name and the value. Each entry in a hash table have the  same size, depending on the value size the table was created with.    Entry zero is the first entry and is pointed to by the first bucket. It  contains the first pointer to the free entries (which are linked together),  the value size for the hash table, the number of buckets and the word position  in the file of the first "unused" (i.e., neither free nor filled) entry. It is  unused because there isn't enough room in the file for this entry to be full  sized. It will be used when the file is grown (i.e., when all the current  entries are filled).    In this implementation, only the buckets and a interval of size "mapWindow"  containing the entry being used (or last used) is mapped at any time. This  mapping strategy can have some odd effects, though. Only one entry can be  mapped at any time, so a procedure working on an entry cannot call another  procedure that itself maps an entry without subsequently remapping the original  entry. I've tried to have all such procedures explicitly return an EntryMap so  its clearer that a mapping has taken place. Grow is the only such procedure  that doesn't return a mapping.    Insert and Remove change the value of Entry Zero, so they force out its  contents when they are done. This has the nice effect of unmapping the last  entry they modified, so all other entries are automatically consistent with  disk. SwapValue, however, needs to force out the entry it modifies.    GetNext caches the entry from the last value it returned (unless the  enumeration terminated). This entry is used only for the name and next  pointer; if GetNext is called with the cached name, the cached next pointer  is used.    The cached entry will remain valid until (1) the entry to which it points is  deleted or (2) an entry is inserted that links to it. When either of these  cases occur, the implementation clears the cached entry.  >>  z: UNCOUNTED ZONE = Heap.Create[initial: 1];  Table: TYPE = LONG POINTER TO TableObject;  TableObject: PUBLIC TYPE = MONITORED RECORD [    hashFn: HashFnType,  -- must choose the correct one for backward compat.    validate: BOOLEAN,    file: NSFile.Handle,    pilotFile: File.File,    session: NSFile.Session,    table: LONG DESCRIPTOR FOR ARRAY OF EntryPointer,  -- buckets    mapped: EntryMap,  -- VM pointer to two pages starting at mappedPage    mappedPage: LONG CARDINAL,    leaderSize: CARDINAL,    -- cached values from entry zero    firstFree: EntryPointer,    valueSize: XStringHashTable.ValueSize,    firstUnusedEntry: EntryPointer,    countEntries: LONG CARDINAL,    seal: LONG CARDINAL,    version: CARDINAL,    -- cached information for GetNext enumeration    lastGetNextEntry: Entry];  HashFnType: TYPE = PROCEDURE [table: Table, s: XString.Reader]    RETURNS [CARDINAL];  EntryPointer: TYPE = LONG CARDINAL;  nullEntryPointer: EntryPointer = 0;  -- The only constraints on the layout of Entry is that byteCount, valueSize  -- and freeIfZero must overlap.  Entry: TYPE = RECORD [    SELECT OVERLAID * FROM    entry => [      next: EntryPointer,      byteCount: CARDINAL,      context: XString.Context,      body: ARRAY [0..XStringHashTable.maxNameLength / 2) OF UNSPECIFIED,      value: ARRAY [0..0) OF UNSPECIFIED],    freeEntry => [nextFree: EntryPointer, freeIfZero: CARDINAL],    entryZero => [  -- new entry zero must be smaller than entry size;      seal: LONG CARDINAL,  -- new field, replaces firstFree from original      valueSize: XStringHashTable.ValueSize,      tableSize: CARDINAL,      firstUnusedEntry: EntryPointer,      countEntries: LONG CARDINAL,      firstFree: EntryPointer,      version: CARDINAL],  -- new field    originalEntryZero => [      firstFree: EntryPointer,      valueSize: XStringHashTable.ValueSize,      tableSize: CARDINAL,      firstUnusedEntry: EntryPointer,      countEntries: LONG CARDINAL],    ENDCASE];  -- version and seal allow the format of the hash table to change; e.g., if the hash function changes, the version must be bumped, and the old and the new fcns should be supported;  originally, entry zero had no version field, so there is the kludged "seal" constant to determine if this is an original table or not;  the seal is read from the first 2 words of entry zero.  an original table's value should be something beyond 6400, the table size of the originals (and current) ones.  so our seal is some nonzero random value less than that;  seal: LONG CARDINAL = 1234;  version: CARDINAL = 1;  EntrySize: PROCEDURE [table: Table] RETURNS [CARDINAL] = {    RETURN[SIZE[Entry] + table.valueSize]};  EntryMap: TYPE = LONG POINTER TO Entry;  growth: CARDINAL = 20;  -- pages  mapWindow: CARDINAL = 2;  -- pages  sanity: BOOLEAN [TRUE..TRUE] = (mapWindow > 1 AND mapWindow <= growth);  -- these errors are not raised  ReadOnly: PUBLIC ERROR [table: Table] = CODE;  VolumeNotOpen: PUBLIC ERROR [volume: Volume.ID] = CODE;  ValueTooSmall: PUBLIC ERROR [table: Table] = CODE;  NoRoom: PUBLIC ERROR [table: Table] = CODE;  NameTooLong: PUBLIC ERROR [table: Table] = CODE;  -- raised when some logic/implementation error is discovered  Bug: ERROR [table: Table] = CODE;  Make: PUBLIC PROCEDURE [    file: NSFile.Handle, session: NSFile.Session,    valueSize: XStringHashTable.ValueSize, reset: BOOLEAN]    RETURNS [table: Table ¬ NIL] =    BEGIN    pagesForTable: CARDINAL = 50;  -- hash table of 6400 buckets    MakeEntry: ENTRY PROCEDURE [table: Table] =      -- Even though there can be no concurrent use of table (no one else has it      -- yet), this is an entry procedure to make the compiler happy about the      -- internal procedure calls      BEGIN      ENABLE UNWIND => NULL;      leaderSize: LONG CARDINAL;      table.validate ¬ FALSE;      table.seal ¬ seal;      table.version ¬ version;      table.hashFn ¬ NewHashFn;      table.file ¬ file;      table.session ¬ session;      table.mapped ¬ NIL;      table.mappedPage ¬ 0;      [table.pilotFile, leaderSize] ¬ NSSegmentInternal.GetID[        file: file, session: session];      table.leaderSize ¬ CARDINAL[leaderSize];      AssertFree[@table.lastGetNextEntry];      reset ¬ reset OR (        NSSegment.GetSizeInPages[file: table.file, session: table.session] = 0);      IF NOT reset THEN reset ¬ NOT OpenHashTable[table];      IF reset THEN {        table.valueSize ¬ valueSize; InitHashTable[table, pagesForTable]};      END;    MakeEntry[(table ¬ z.NEW[TableObject]) ! UNWIND => z.FREE[@table]];    END;  Delete: PUBLIC PROCEDURE [table: Table] =    BEGIN    IF table.mapped # NIL THEN [] ¬ Space.Unmap[table.mapped];    [] ¬ Space.Unmap[table.table.BASE];    z.FREE[@table];    END;  GetInfo: PUBLIC ENTRY PROCEDURE [table: Table]    RETURNS [valueSize: XStringHashTable.ValueSize, file: NSFile.Handle] = {    RETURN[table.valueSize, table.file]};  Insert: PUBLIC ENTRY PROCEDURE [    table: Table, name: XString.Reader, value: XStringHashTable.Value]    RETURNS [ok, noRoom: BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    bucket: CARDINAL;    entry: EntryMap;    free, last, next: EntryPointer;    block: Environment.Block;    [bucket: bucket, previous: last, following: next, map: entry] ¬      FindInternal[table, name];    IF entry # NIL THEN RETURN[ok: FALSE, noRoom: FALSE];  -- already exists    -- Fill in a free entry    [free, entry] ¬ GetFreeEntry[table ! NoRoom => GOTO Full];    Inline.LongCOPY[      from: value.BASE, to: @entry.value,      nwords: MIN[value.LENGTH, table.valueSize]];    [block, entry.context] ¬ XString.Block[name];    entry.byteCount ¬ MIN[      block.stopIndexPlusOne - block.startIndex + 1,        XStringHashTable.maxNameLength];    [] ¬ ByteBlt.ByteBlt[      to: [LOOPHOLE[@entry.body], 0, entry.byteCount - 1], from: block];    table.countEntries ¬ SUCC[table.countEntries];    -- Link up the entries    entry.next ¬ next;    IF last = nullEntryPointer THEN {      table.table[bucket] ¬ free; ForceoutTable[table]}    ELSE {entry ¬ Map[table, last]; entry.next ¬ free};    ForceoutEntryZero[table];    -- clear cached GetNext entry if necessary    IF NOT IsFree[@table.lastGetNextEntry]      AND table.lastGetNextEntry.next = next      THEN AssertFree[@table.lastGetNextEntry];    -- debugging check    IF table.validate THEN ValidateSize[table];    IF value.LENGTH > table.valueSize THEN      RETURN WITH ERROR ValueTooSmall[table];    IF block.stopIndexPlusOne - block.startIndex + 1 >      XStringHashTable.maxNameLength THEN RETURN WITH ERROR NameTooLong[table];    RETURN[ok: TRUE, noRoom: FALSE];    EXITS Full => RETURN[ok: FALSE, noRoom: TRUE];    END;  Remove: PUBLIC ENTRY PROCEDURE [    table: Table, name: XString.Reader, value: XStringHashTable.Value]    RETURNS [ok: BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    bucket: CARDINAL;    entry: EntryMap;    this, last, next: EntryPointer;    [bucket: bucket, pointer: this, previous: last, following: next, map: entry]      ¬ FindInternal[table, name];    IF entry = NIL THEN RETURN[FALSE];  -- doesn't exist    -- pull out old values    Inline.LongCOPY[      from: @entry.value, to: value.BASE,      nwords: MIN[value.LENGTH, table.valueSize]];    table.countEntries ¬ PRED[table.countEntries];    -- link to free list    entry.next ¬ table.firstFree;    table.firstFree ¬ this;    AssertFree[entry];    -- clear cached GetNext entry if it points to this entry    IF NOT IsFree[@table.lastGetNextEntry]      AND table.lastGetNextEntry.next = this      THEN AssertFree[@table.lastGetNextEntry];    -- link up remaining values    IF last = nullEntryPointer THEN {      table.table[bucket] ¬ next; ForceoutTable[table]}    ELSE {entry ¬ Map[table, last]; entry.next ¬ next};    ForceoutEntryZero[table];    -- debugging check    IF table.validate THEN ValidateSize[table];    IF value.LENGTH < table.valueSize THEN      RETURN WITH ERROR ValueTooSmall[table];    IF table.validate THEN [] ¬ CountChain[table, bucket];    END;  Empty: PUBLIC ENTRY PROCEDURE [table: Table] RETURNS [BOOLEAN] = {    RETURN[(table.countEntries = 0)]};  Find: PUBLIC ENTRY PROCEDURE [    table: Table, name: XString.Reader, value: XStringHashTable.Value]    RETURNS [ok: BOOLEAN ¬ TRUE] =    BEGIN    ENABLE UNWIND => NULL;    entry: EntryMap ¬ FindInternal[table, name].map;    IF entry = NIL THEN RETURN[FALSE];    Inline.LongCOPY[      from: @entry.value, to: value.BASE,      nwords: MIN[value.LENGTH, table.valueSize]];    IF value.LENGTH < table.valueSize THEN      RETURN WITH ERROR ValueTooSmall[table];    END;  SwapValue: PUBLIC ENTRY PROCEDURE [    table: Table, name: XString.Reader,    oldValue, newValue: XStringHashTable.Value] RETURNS [ok: BOOLEAN ¬ TRUE] =    BEGIN    ENABLE UNWIND => NULL;    tooSmall: BOOLEAN ¬ FALSE;    entry: EntryMap ¬ FindInternal[table, name].map;    IF entry = NIL THEN RETURN[FALSE];    -- Extract old value    Inline.LongCOPY[      from: @entry.value, to: oldValue.BASE,      nwords: MIN[oldValue.LENGTH, table.valueSize]];    -- Insert new value    Inline.LongCOPY[      from: newValue.BASE, to: @entry.value,      nwords: MIN[newValue.LENGTH, table.valueSize]];    ForceoutEntry[table, entry];    IF oldValue.LENGTH < table.valueSize OR newValue.LENGTH > table.valueSize      THEN RETURN WITH ERROR ValueTooSmall[table];    END;  asterisk: XChar.Character = XCharSet0.Make[asterisk];  numberSign: XChar.Character = XCharSet0.Make[numberSign];  GetNext: PUBLIC ENTRY PROCEDURE [    table: Table, name: XString.Reader, nextName: XString.Writer,    value: XStringHashTable.Value, mask: XString.Reader ¬ NIL] =    BEGIN    ENABLE UNWIND => NULL;    bucket: CARDINAL;    pointer: EntryPointer;    map: EntryMap;    maskLength: CARDINAL = XString.CharacterLength[mask];    all: BOOLEAN = (mask = NIL OR maskLength = 0 OR      (maskLength=1 AND XString.First[mask]=asterisk));    MaskName: PROCEDURE [      name: XString.Reader, nameIndex: CARDINAL, maskIndex: CARDINAL]      RETURNS [outcome: BOOLEAN] =      BEGIN      i, j: CARDINAL;      nameLength: CARDINAL = XString.CharacterLength[name];      IF maskLength = 0 THEN RETURN[TRUE];      -- Process each character in mask      FOR i IN [maskIndex..maskLength) DO        mc: XChar.Character = XString.NthCharacter[mask, i];        SELECT mc FROM          asterisk =>            BEGIN            FOR j IN [nameIndex..nameLength] DO              IF MaskName[name, j, i + 1] THEN RETURN[TRUE]; ENDLOOP;            RETURN[FALSE];            END;          numberSign =>            IF nameIndex = nameLength THEN RETURN[FALSE]            ELSE nameIndex ¬ nameIndex + 1;          ENDCASE =>            IF nameIndex = nameLength              OR XChar.Decase[XString.NthCharacter[name, nameIndex]] #                XChar.Decase[mc] THEN RETURN[FALSE]            ELSE nameIndex ¬ nameIndex + 1;        ENDLOOP;      -- name passes mask if entire name has been consumed      outcome ¬ nameIndex = nameLength;      END;    -- Determine where to start looking    SELECT TRUE FROM      XString.CharacterLength[name] = 0 => {        bucket ¬ 1; pointer ¬ table.table[1]};      NOT IsFree[@table.lastGetNextEntry] =>        BEGIN        rb: XString.ReaderBody ¬ ReaderFromEntry[@table.lastGetNextEntry];        IF XString.Equivalent[@rb, name] THEN {          bucket ¬ table.hashFn[table, name]; pointer ¬ table.lastGetNextEntry.next}        ELSE [bucket: bucket, following: pointer] ¬ FindInternal[table, name];        END;      ENDCASE =>        [bucket: bucket, following: pointer] ¬ FindInternal[table, name];    XString.ClearWriter[nextName];    -- (pointer, bucket) refer to the next entry and the bucket it is in. When    -- pointer is null, this bucket is exhausted, so go on to the next bucket.    DO      rb: XString.ReaderBody;      -- If exhausted this bucket, find a bucket with an entry      WHILE pointer = nullEntryPointer DO        bucket ¬ SUCC[bucket];        IF bucket = table.table.LENGTH THEN {          AssertFree[@table.lastGetNextEntry]; RETURN};  -- enumeration done        pointer ¬ table.table[bucket];        ENDLOOP;      -- If entry matches, return it      map ¬ Map[table, pointer];      rb ¬ ReaderFromEntry[map];      IF all OR MaskName[@rb, 0, 0] THEN        BEGIN        Inline.LongCOPY[          from: @map.value, to: value.BASE,          nwords: MIN[value.LENGTH, table.valueSize]];        MyAppendReader[nextName, @rb];        Inline.LongCOPY[  -- set up cached GetNext entry          from: map, to: @table.lastGetNextEntry, nwords: SIZE[Entry]];        IF value.LENGTH < table.valueSize THEN          RETURN WITH ERROR ValueTooSmall[table];        RETURN;        END;      -- Otherwise, try the next entry in the bucket      pointer ¬ map.next;      ENDLOOP;    END;  -- Internal procedures  MyAppendReader: PROC [to: XString.Writer, from: XString.Reader] = {    to.endContext ¬ to.context ¬ from.context;    to.offset ¬ 0;    to.limit ¬ ByteBlt.ByteBlt[      from: [blockPointer: LOOPHOLE[from.bytes], startIndex: from.offset,        stopIndexPlusOne: from.limit],       to: [blockPointer: LOOPHOLE[to.bytes], startIndex: to.offset,        stopIndexPlusOne: to.maxLimit]]};  AssertFree: INTERNAL PROCEDURE [map: EntryMap] = INLINE {map.freeIfZero ¬ 0};  IsFree: INTERNAL PROCEDURE [map: EntryMap] RETURNS [BOOLEAN] = INLINE {    RETURN[(map.freeIfZero = 0)]};  FindInternal: INTERNAL PROCEDURE [table: Table, name: XString.Reader]    RETURNS [      bucket: CARDINAL, pointer, previous, following: EntryPointer,      map: EntryMap] =    BEGIN    bucket ¬ table.hashFn[table, name];    pointer ¬ table.table[bucket];    previous ¬ nullEntryPointer;    UNTIL pointer = nullEntryPointer DO      readerBody: XString.ReaderBody;      map ¬ Map[table, pointer];      readerBody ¬ ReaderFromEntry[Map[table, pointer]];      SELECT XString.Compare[r1: @readerBody, r2: name, ignoreCase: TRUE] FROM        less => NULL;        equal => RETURN[bucket, pointer, previous, map.next, map];        greater => RETURN[bucket, nullEntryPointer, previous, pointer, NIL];        ENDCASE => ERROR Bug[table];      previous ¬ pointer;      pointer ¬ map.next;      ENDLOOP;    RETURN[bucket, nullEntryPointer, previous, nullEntryPointer, NIL];    END;  ForceoutEntry: INTERNAL PROCEDURE [table: Table, entry: EntryMap] =    BEGIN    pages: CARDINAL =      CARDINAL[        Environment.PageFromLongPointer[entry + EntrySize[table] - 1] -          Environment.PageFromLongPointer[entry]] + 1;    Space.ForceOut[[entry, pages]];    END;  ForceoutEntryZero: INTERNAL PROCEDURE [table: Table] =    BEGIN -- must use table version instead of seal to select on, since we may not have stored entry zero out yet.    entryZero: EntryMap ¬ Map[table, table.table[0]];    WITH zero: entryZero SELECT      IF table.version=0 THEN originalEntryZero ELSE entryZero FROM      entryZero => {	zero.seal ¬ table.seal;	zero.version ¬ table.version;	zero.firstFree ¬ table.firstFree;	zero.valueSize ¬ table.valueSize;	zero.tableSize ¬ table.table.LENGTH;	zero.firstUnusedEntry ¬ table.firstUnusedEntry;	zero.countEntries ¬ table.countEntries};      originalEntryZero => {	zero.firstFree ¬ table.firstFree;	zero.valueSize ¬ table.valueSize;	zero.tableSize ¬ table.table.LENGTH;	zero.firstUnusedEntry ¬ table.firstUnusedEntry;	zero.countEntries ¬ table.countEntries};      ENDCASE => Bug[table];    ForceoutEntry[table, entryZero];    END;  ForceoutTable: INTERNAL PROCEDURE [table: Table] = {    Space.ForceOut[      [      table.table.BASE,      table.table.LENGTH * SIZE[EntryPointer] / Environment.wordsPerPage]]};  GetFreeEntry: INTERNAL PROCEDURE [table: Table]    RETURNS [pointer: EntryPointer, map: EntryMap] =    BEGIN    IF (pointer ¬ table.firstFree) = nullEntryPointer THEN {      Grow[table]; pointer ¬ table.firstFree};    map ¬ Map[table, pointer];    table.firstFree ¬ map.next;    IF NOT IsFree[map] THEN ERROR Bug[table];    END;  Grow: INTERNAL PROCEDURE [table: Table] =    BEGIN    pointer: EntryPointer;    map: EntryMap;    fileSize: LONG CARDINAL = NSSegment.GetSizeInPages[      file: table.file, session: table.session];    tableSizeInWords: CARDINAL = table.table.LENGTH * SIZE[EntryPointer];    firstNewEntry: EntryPointer ¬ table.firstUnusedEntry;    firstUnusedEntry: EntryPointer;    entrySize: CARDINAL = EntrySize[table];    IF NOT table.firstFree = nullEntryPointer THEN ERROR Bug[table];    -- don't grow a table unless you really need to.    IF table.mapped # NIL  -- there is a cached mapping that may be no good      THEN table.mapped ¬ Space.Unmap[table.mapped];    NSSegment.SetSizeInPages[      file: table.file, pages: fileSize + growth, session: table.session !      NSFile.Error => IF error=[space[mediumFull]] THEN ERROR NoRoom[table]];    firstUnusedEntry ¬ table.firstUnusedEntry ¬      (((fileSize + growth) * Environment.wordsPerPage          -- the number of words in the file          - tableSizeInWords)         -- gives the number of words available for entries         / entrySize) * entrySize        -- truncate to number of words in the available entries        + tableSizeInWords;    -- add in the location of the first entry (which is entry zero)    pointer ¬ firstNewEntry;    UNTIL pointer >= firstUnusedEntry DO      map ¬ Map[table, pointer];      pointer ¬ map.next ¬ pointer + entrySize;      AssertFree[map];      ENDLOOP;    map.next ¬ nullEntryPointer;    table.firstFree ¬ firstNewEntry;    ForceoutEntryZero[table];    END;  NewHashFn: INTERNAL PROCEDURE [table: Table, s: XString.Reader]    RETURNS [CARDINAL] =    BEGIN    CharCode: PROCEDURE [c: XChar.Character] RETURNS [Environment.Byte] = INLINE      {RETURN XChar.Code[XChar.Decase[c]]};    IF XString.ByteLength[s] = 31 THEN {      v: WORD ¬	CharCode[XString.NthCharacter[s, 14]] * 177B + CharCode[	  XString.NthCharacter[s, 15]];      RETURN[MAX[1, v MOD table.table.LENGTH]]}    ELSE {      SumChars: XString.MapCharProc = {      -- [c: XString.Character] RETURNS [stop: BOOLEAN]      sum ¬ sum + CharCode[c];      RETURN[FALSE]};      sum: CARDINAL ¬ 0;      [] ¬ XString.Map[r: s, proc: SumChars];      RETURN[MAX[1, sum MOD table.table.LENGTH]]};    END;  OldHashFn: INTERNAL PROCEDURE [table: Table, s: XString.Reader]    RETURNS [CARDINAL] =    BEGIN    -- This is the XString equivalent of the famous Mesa hash function. I don't    -- know how well it works for this, but it probably ain't too bad.    CharCode: PROCEDURE [c: XChar.Character] RETURNS [Environment.Byte] = INLINE      {RETURN XChar.Code[XChar.Decase[c]]};    n: CARDINAL = XString.CharacterLength[s];    v: WORD ¬      CharCode[XString.First[s]] * 177B + CharCode[        XString.NthCharacter[s, n - 1]];    RETURN[MAX[1, Inline.BITXOR[v, n * 17B] MOD table.table.LENGTH]];    END;  InitHashTable: INTERNAL PROCEDURE [table: Table, pagesForTable: CARDINAL] =    BEGIN    -- table.leaderSize, table.pilotFile, table.valueSize must already be defined; will set the remaining values of table;    wordsForTable: CARDINAL = pagesForTable * Environment.wordsPerPage;    NSSegment.SetSizeInPages[      file: table.file, pages: pagesForTable, session: table.session];    table.table ¬ DESCRIPTOR[      Space.Map[[table.pilotFile, table.leaderSize, pagesForTable]].pointer,        wordsForTable / SIZE[EntryPointer]];    table.firstUnusedEntry ¬ wordsForTable + EntrySize[table];    table.firstFree ¬ nullEntryPointer;    table.countEntries ¬ 0;    table.table[0] ¬ wordsForTable;    FOR i: CARDINAL IN [1..table.table.LENGTH) DO      table.table[i] ¬ nullEntryPointer ENDLOOP;    ForceoutTable[table];    Grow[table];    END;  Map: INTERNAL PROCEDURE [table: Table, pointer: EntryPointer]    RETURNS [map: EntryMap] =    BEGIN    -- Page and offset of this entry in the file    page: LONG CARDINAL ¬ pointer / Environment.wordsPerPage;    offset: CARDINAL ¬ CARDINAL[pointer - page * Environment.wordsPerPage];    IF pointer < table.table[0] THEN ERROR Bug[table];  -- is before entry zero    page ¬ page + table.leaderSize;  -- Correct for leader page (for Space.Map)    IF table.mapped # NIL AND page >= table.mappedPage THEN      BEGIN      offsetInWindow: LONG CARDINAL ¬         (page - table.mappedPage) * Environment.wordsPerPage + offset;      IF offsetInWindow + EntrySize[table] <=        Environment.wordsPerPage * mapWindow THEN        RETURN[table.mapped + offsetInWindow];      END;    -- Map the pages that contain this entry    IF table.mapped # NIL THEN table.mapped ¬ Space.Unmap[table.mapped];    table.mapped ¬ Space.Map[[table.pilotFile, page, mapWindow]].pointer;    table.mappedPage ¬ page;    RETURN[table.mapped + offset];    END;  OpenHashTable: INTERNAL PROCEDURE [table: Table] RETURNS [opened: BOOLEAN] =    BEGIN    -- table.leaderSize, table.pilotFile, table.valueSize must already be defined; will set the remaining values of table;    initPtr: LONG POINTER TO EntryPointer ¬ Space.Map[      [table.pilotFile, table.leaderSize, 1]].pointer;    entryZero: EntryMap;    page: LONG POINTER;    tableSize: CARDINAL;    IF initPtr­ = nullEntryPointer THEN {      initPtr ¬ Space.Unmap[initPtr]; RETURN[FALSE]};    entryZero ¬ Space.Map[      [      table.pilotFile, table.leaderSize + initPtr­ / Environment.wordsPerPage,      1]].pointer;    WITH zero: entryZero SELECT      IF zero.seal # seal THEN originalEntryZero ELSE entryZero FROM      entryZero => {	table.valueSize ¬ zero.valueSize;	tableSize ¬ zero.tableSize;	table.firstUnusedEntry ¬ zero.firstUnusedEntry;	table.firstFree ¬ zero.firstFree;	table.countEntries ¬ zero.countEntries};      originalEntryZero => {	table.seal ¬ 0;	table.version ¬ 0;	table.hashFn ¬ OldHashFn;	table.firstFree ¬ zero.firstFree;	table.valueSize ¬ zero.valueSize;	tableSize ¬ zero.tableSize;	table.firstUnusedEntry ¬ zero.firstUnusedEntry;	table.countEntries ¬ zero.countEntries};      ENDCASE => Bug[table];    initPtr ¬ Space.Unmap[initPtr];    entryZero ¬ Space.Unmap[entryZero];    page ¬ Space.Map[      [      table.pilotFile, table.leaderSize,      tableSize * SIZE[EntryPointer] / Environment.wordsPerPage]].pointer;    table.table ¬ DESCRIPTOR[page, tableSize];    RETURN[TRUE];    END;  ReaderFromEntry: INTERNAL PROCEDURE [entry: EntryMap]    RETURNS [reader: XString.ReaderBody] = {    RETURN XString.FromBlock[      [LOOPHOLE[@entry.body], 0, entry.byteCount - 1], entry.context]};  ToggleValidate: PUBLIC ENTRY PROCEDURE [table: Table] RETURNS [BOOLEAN] =    BEGIN ENABLE UNWIND => NULL;    table.validate ¬ ~table.validate;    RETURN[table.validate];    END;  ShowStatistics: PUBLIC ENTRY PROCEDURE [table: Table, post: Format.StringProc] =    BEGIN ENABLE UNWIND => NULL;    total, cnt: LONG CARDINAL ¬ 0;    FOR i: CARDINAL IN [1..LENGTH[table.table]) DO      IF table.table[i] # nullEntryPointer THEN {	cnt ¬ CountChain[table, i];	total ¬ total + cnt;	Format.LongOctal[proc: post, n: i];	post[":\t"];	Format.LongOctal[post, cnt];	post["\n"]};      ENDLOOP;    post["\n"];    post["Total:\t"];     Format.LongOctal[proc: post, n: total];    post["\n"];    END;  ValidateSize: INTERNAL PROCEDURE [table: Table] = {    total: LONG CARDINAL ¬ 0;    FOR i: CARDINAL IN [1..LENGTH[table.table]) DO      IF table.table[i] # nullEntryPointer THEN	total ¬ total + CountChain[table, i];      ENDLOOP;    IF total # table.countEntries THEN ERROR Bug[table]};  CountChain: INTERNAL PROCEDURE [table: Table, bucket: CARDINAL]    RETURNS [cnt: CARDINAL] = {    map: EntryMap;    pointer: EntryPointer ¬ table.table[bucket];    cnt ¬ 0;    UNTIL pointer = nullEntryPointer DO      cnt ¬ cnt+1;      map ¬ Map[table, pointer];      IF map.byteCount < 1 OR map.byteCount > 100 THEN -- not valid entry        ERROR Bug[table];      pointer ¬ map.next;      ENDLOOP};      END...
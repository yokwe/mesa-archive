--  File: NSBTreeImplA.mesa; last edited by: --  PXK    ,	21-Mar-84 10:48:51--  BJD    ,	 4-Sep-84 16:39:20DIRECTORY  NSBTree USING [maxNameLength, Tree, TreeObject, Value, ValueSize],  NSBTreeInternal USING [    bTreePage, Cache, emptySize, EntryHandle, EntryName, EntryPointer,    EntryPointerPointer, EntrySize, EntryValue, FirstEntry, FirstFreeEntry,    firstPagePointer, InternalValidateBTree, MapInternal, maxTreeSize,    NextEntry, nilPagePointer,    Overhead, PageHandle, PagePointer, PCache, SnapShot, treeIncrement,    TreeObject, ValuePointer],  ByteBlt USING [ByteBlt],  Environment USING [PageCount, wordsPerPage],  File USING [File, nullFile, SetSize],  Heap USING [Create],  Inline USING [BITAND, LongCOPY],  NSFile USING [nullHandle],  NSSegment USING [SetSizeInPages],  Space USING [ForceOut, Map, SetAccess, Unmap],  SpecialNSBTree USING [Unmapped],  String USING [LowerCase],  Volume USING [GetStatus, InsufficientSpace, systemID, ID];NSBTreeImplA: MONITOR LOCKS tree USING tree: Tree  IMPORTS    NSBTreeInternal, ByteBlt, File, Heap, Inline, NSSegment,    SpecialNSBTree, String, Space, Volume  EXPORTS NSBTree, NSBTreeInternal =  BEGIN  TreeObject: PUBLIC TYPE = NSBTreeInternal.TreeObject;  Tree: TYPE = LONG POINTER TO TreeObject;  bTreePage: CARDINAL = NSBTreeInternal.bTreePage;  maxTreeSize: CARDINAL = NSBTreeInternal.maxTreeSize;  -- (disk pages)  treeIncrement: CARDINAL = NSBTreeInternal.treeIncrement;  -- (b-tree pages)  emptySize: CARDINAL = NSBTreeInternal.emptySize;  -- the size of an empty page  PCache: TYPE = NSBTreeInternal.PCache;  PageHandle: TYPE = NSBTreeInternal.PageHandle;  PagePointer: TYPE = NSBTreeInternal.PagePointer;  nilPagePointer: PagePointer = NSBTreeInternal.nilPagePointer;  EntryHandle: TYPE = NSBTreeInternal.EntryHandle;  heap: PUBLIC UNCOUNTED ZONE = Heap.Create[initial: 2];  debug: PUBLIC BOOLEAN _ FALSE;  --  check B-Trees for validity after touching  CompareResult: TYPE = {equal, less, greater};    -- public procedures and signals  -- NSBTreeInternal  CheckVolumeAccess: PUBLIC INTERNAL PROCEDURE [tree: Tree] =    BEGIN    IF tree.cap = File.nullFile THEN RETURN;    IF tree.cap.volumeID # Volume.systemID THEN      SELECT Volume.GetStatus[tree.cap.volumeID] FROM        openReadWrite => NULL;        openRead => ERROR ReadOnly[tree];        ENDCASE => ERROR VolumeNotOpen[tree.cap.volumeID];    IF tree.spaceReadOnly THEN {      Space.SetAccess[tree.space, readWrite]; tree.spaceReadOnly _ FALSE};    END;  -- NSBTree    Find: PUBLIC ENTRY PROCEDURE [tree: Tree, name: LONG STRING, value: NSBTree.Value]    RETURNS [ok: BOOLEAN] =    -- Given a file name, return the value    BEGIN    ENABLE UNWIND => NULL;    vp: NSBTreeInternal.ValuePointer;    IF tree.base = NIL THEN {      SIGNAL SpecialNSBTree.Unmapped[tree]; NSBTreeInternal.MapInternal[tree]};    [ok: ok, value: vp] _ InternalFind[tree, name];    IF ~ok OR value = NIL THEN RETURN;    IF CopyValue[value, vp, tree.valueSize] THEN ERROR ValueTooSmall[tree];    END;  -- NSBTree    GetNext: PUBLIC ENTRY PROCEDURE [    tree: Tree, name, nextName: LONG STRING, value: NSBTree.Value,    mask: LONG STRING] =    -- Stateless enumerator of B-Tree    BEGIN    ENABLE UNWIND => NULL;    pE: EntryHandle;    pP: PagePointer;    pC: PCache;    ok: BOOLEAN;    MaskFilename: PROCEDURE [      file: LONG STRING, fileIndex: CARDINAL, maskIndex: CARDINAL]      RETURNS [outcome: BOOLEAN] =      BEGIN      -- local variables      i, j: CARDINAL;      IF (mask = NIL) OR (mask.length = 0) THEN RETURN[TRUE];      -- process each character in mask      FOR i IN [maskIndex..mask.length) DO        SELECT mask[i] FROM          '* =>  -- matches any string of zero or more characters            BEGIN            FOR j IN [fileIndex..file.length] DO              IF MaskFilename[file, j, i + 1] THEN RETURN[TRUE]; ENDLOOP;            RETURN[FALSE];            END;          '# =>  -- matches any single character            IF fileIndex = file.length THEN RETURN[FALSE]            ELSE fileIndex _ fileIndex + 1;          ENDCASE =>            IF fileIndex = file.length              OR String.LowerCase[file[fileIndex]] # String.LowerCase[mask[i]]              THEN RETURN[FALSE]            ELSE fileIndex _ fileIndex + 1;        ENDLOOP;      -- filename passes mask if entire filename has been consumed      outcome _ fileIndex = file.length;      END;    IF tree.base = NIL THEN {      SIGNAL SpecialNSBTree.Unmapped[tree]; NSBTreeInternal.MapInternal[tree]};    IF tree.base[tree.top].size = emptySize THEN {nextName.length _ 0; RETURN};    pC _ GetGNCache[tree];    IF name.length = 0 THEN      --  we're asking for the first value      BEGIN      pE _ NSBTreeInternal.FirstEntry[@tree.base[tree.top]];      pP _ tree.top;      WHILE NSBTreeInternal.EntryPointer[tree, pE] # nilPagePointer DO        pP _ NSBTreeInternal.EntryPointer[tree, pE];        pE _ NSBTreeInternal.FirstEntry[@tree.base[pP]]        ENDLOOP      END    ELSE      --  see if we're asking for the value after the last one given      IF StringCompare[name, @pC.lastName] = equal THEN        [pE, pP] _ GetNextEntry[tree, pC.lastpE, pC.lastpP]      ELSE        --  if not, look up the old value        BEGIN        [ent: pE, page: pP, ok: ok] _ InternalFind[tree, name];        --  if we got a value, use the next...        --  otherwise, InternalFind has given us a pointer to the next entry        IF ok THEN [pE, pP] _ GetNextEntry[tree, pE, pP]        END;    --  there are no more values in this tree if pE is NIL    IF pE = NIL THEN {FlushGNCache[tree]; nextName.length _ 0; RETURN};    -- keep following the tree until we get a value that matches    WHILE ~MaskFilename[NSBTreeInternal.EntryName[tree, pE], 0, 0] DO      [pE, pP] _ GetNextEntry[tree, pE, pP];      --  there are no more values in this tree if pE is NIL      IF pE = NIL THEN {FlushGNCache[tree]; nextName.length _ 0; RETURN};      ENDLOOP;    --  we got a value - save the vitals in the cache    MoveLongString[nextName, NSBTreeInternal.EntryName[tree, pE]];    MoveLongString[@pC.lastName, NSBTreeInternal.EntryName[tree, pE]];    pC.lastpE _ pE;    pC.lastpP _ pP;    IF value = NIL THEN RETURN;    IF CopyValue[value, NSBTreeInternal.EntryValue[tree, pE], tree.valueSize] THEN      ERROR ValueTooSmall[tree];    END;  -- NSBTree    Insert: PUBLIC ENTRY PROCEDURE [    tree: Tree, name: LONG STRING, value: NSBTree.Value]    RETURNS [ok, noRoom: BOOLEAN] =    -- insert a name/value pair into the B-Tree    BEGIN    ENABLE UNWIND => NULL;    found: BOOLEAN;    page: PagePointer;    IF tree.base = NIL THEN {      SIGNAL SpecialNSBTree.Unmapped[tree]; NSBTreeInternal.MapInternal[tree]};    CheckVolumeAccess[tree];    [ok: found, page: page] _ InternalFind[tree, name];    IF found THEN RETURN[FALSE, FALSE];    IF debug THEN NSBTreeInternal.SnapShot[tree];    [ok, noRoom] _ InsertInNode[tree, page, name, BASE[value], nilPagePointer];    IF tree.autoForceOut THEN Space.ForceOut[tree.space];    FlushGNCache[tree];    IF debug THEN NSBTreeInternal.InternalValidateBTree[tree];    IF tree.valueSize < LENGTH[value] THEN ERROR ValueTooSmall[tree];    RETURN;    END;  -- SpecialNSBTree    ReadOnly: PUBLIC ERROR [tree: Tree] = CODE;  -- NSBTree    SwapValue: PUBLIC ENTRY PROCEDURE [    tree: Tree, name: LONG STRING, oldValue, newValue: NSBTree.Value]    RETURNS [ok: BOOLEAN] =    --  Swap the values associated with an entry    BEGIN    ENABLE UNWIND => NULL;    entry: EntryHandle;    vp: NSBTreeInternal.ValuePointer;    IF tree.base = NIL THEN {      SIGNAL SpecialNSBTree.Unmapped[tree]; NSBTreeInternal.MapInternal[tree]};    CheckVolumeAccess[tree];    [ok: ok, value: vp, ent: entry] _ InternalFind[tree, name];    IF ~ok THEN RETURN[FALSE];    IF oldValue # NIL THEN ok _ ~CopyValue[oldValue, vp, tree.valueSize];    Copy[from: BASE[newValue], to: vp, size: tree.valueSize];    IF tree.autoForceOut THEN Space.ForceOut[tree.space];    IF ~ok OR tree.valueSize > LENGTH[newValue] THEN ERROR ValueTooSmall[tree];    RETURN[TRUE];    END;  -- NSBTree    ValueTooSmall: PUBLIC ERROR [tree: Tree] = CODE;    -- SpecialNSBTree  VolumeNotOpen: PUBLIC ERROR [volume: Volume.ID] = CODE;  -- private procedures and signals  Copy: INTERNAL PROCEDURE [from, to: LONG POINTER, size: CARDINAL] = {    [] _ ByteBlt.ByteBlt[      from: [from, 0, size*2], to: [to, 0, size*2], overLap: move]};  -- NSBTreeInternal  CopyValue: PUBLIC INTERNAL PROCEDURE [    to: NSBTree.Value, from: NSBTreeInternal.ValuePointer, size: NSBTree.ValueSize]    RETURNS [targetTooSmall: BOOLEAN] =    BEGIN    Copy[from, BASE[to], MIN[size, LENGTH[to]]];    RETURN[size > LENGTH[to]];    END;  ExpandNSBTree: INTERNAL PROCEDURE [tree: Tree] RETURNS [p: PagePointer] =    --  Expand the NSBTree    BEGIN    newTreeSize: Environment.PageCount = tree.size + treeIncrement*bTreePage;    treeCap: File.File _ tree.cap;    pPage: PageHandle;--  IF newTreeSize > maxTreeSize THEN RETURN[nilPagePointer];    tree.space.pointer _ Space.Unmap[tree.space.pointer];    -- Expand the file    IF tree.file = NSFile.nullHandle THEN      File.SetSize[treeCap, newTreeSize + tree.lpSize !      Volume.InsufficientSpace => GOTO NoRoom]    ELSE NSSegment.SetSizeInPages[      file: tree.file, pages: newTreeSize, session: tree.session !        Volume.InsufficientSpace => GOTO NoRoom];    tree.space _ Space.Map[      window: [treeCap, tree.lpSize, newTreeSize],      usage: tree.usage,      swapUnits: [uniform[bTreePage]]];    tree.base _ tree.space.pointer;    -- Initialize the newly added pages to FREE    p _ NSBTreeInternal.firstPagePointer + Environment.wordsPerPage*tree.size;    pPage _ @tree.base[p];    THROUGH [0..treeIncrement) DO      pPage.free _ TRUE;      pPage _ pPage + bTreePage*Environment.wordsPerPage      ENDLOOP;    tree.size _ newTreeSize;    RETURN[p]    EXITS NoRoom => {      tree.space _ Space.Map[        window: [tree.cap, tree.lpSize, tree.size],	usage: tree.usage,	swapUnits: [uniform[bTreePage]]];        RETURN[nilPagePointer]};    END;  -- NSBTreeInternal  FlushGNCache: PUBLIC INTERNAL PROCEDURE [tree: Tree] =    -- clear this tree's cached state information    {IF tree.pCache # NIL THEN heap.FREE[@tree.pCache]};  GetGNCache: INTERNAL PROCEDURE [tree: Tree] RETURNS [PCache] =    --  Allocate a place to keep state information on this tree    BEGIN    IF tree.pCache = NIL THEN tree.pCache _ heap.NEW[NSBTreeInternal.Cache _ []];    RETURN[tree.pCache]    END;  GetNextEntry: INTERNAL PROCEDURE [tree: Tree, pE: EntryHandle, pP: PagePointer]    RETURNS [nextpE: EntryHandle, nextpP: PagePointer] =    -- given a pointer to a b-tree entry, get the successor b-tree entry    BEGIN    IF NSBTreeInternal.EntryPointer[tree, pE] = nilPagePointer THEN      BEGIN      nextpE _ NSBTreeInternal.NextEntry[tree, pE];      IF nextpE # NSBTreeInternal.FirstFreeEntry[@tree.base[pP]] THEN        RETURN[nextpE, pP]      ELSE        BEGIN        WHILE pP # tree.top DO          nextpP _ tree.base[pP].parent;          IF pP # tree.base[nextpP].lastPointer THEN EXIT;          pP _ nextpP;          REPEAT FINISHED => RETURN[NIL, nilPagePointer];          ENDLOOP;        FOR pE _ NSBTreeInternal.FirstEntry[@tree.base[nextpP]],          NSBTreeInternal.NextEntry[tree, pE] UNTIL NSBTreeInternal.EntryPointer[          tree, pE] = pP DO ENDLOOP;        END;      RETURN[pE, nextpP]      END    ELSE      BEGIN      nextpP _ Successor[tree, pP, pE].pg;      nextpE _ NSBTreeInternal.FirstEntry[@tree.base[nextpP]];      END;    END;  -- NSBTreeInternal  InsertInNode: PUBLIC INTERNAL PROCEDURE [    tree: Tree, p: PagePointer, n: LONG STRING, c: NSBTreeInternal.ValuePointer,    after: PagePointer] RETURNS [ok, noRoom: BOOLEAN, ent: EntryHandle] =    -- inserts the file name/value pair into this node.  The field "after"     -- points to the node that follows this entry in the B-Tree    BEGIN    dPage: PageHandle;    newEntrySize: CARDINAL;    pE, insertpE: EntryHandle;    loopSize: CARDINAL;    dPage _ @tree.base[p];    newEntrySize _ NSBTreeInternal.Overhead[tree] + SIZE[StringBody [n.length]];    IF dPage.size + newEntrySize > bTreePage*Environment.wordsPerPage THEN {      -- this node is full... split into two half-full nodes      [ok, noRoom, ent] _ SplitNode[tree, p, n, c, after]; RETURN};    IF dPage.size = emptySize THEN {      -- this is the first insert in this page      pE _ NSBTreeInternal.FirstEntry[dPage];      NSBTreeInternal.EntryName[tree, pE]^ _ [        length: 0, maxlength: n.length, text:];      MoveLongString[NSBTreeInternal.EntryName[tree, pE], n];      Copy[from: c, to: NSBTreeInternal.EntryValue[tree, pE], size: tree.valueSize];      NSBTreeInternal.EntryPointerPointer[tree, pE]^ _ nilPagePointer;      dPage.lastPointer _ after;      dPage.size _ dPage.size + newEntrySize;      RETURN[TRUE, FALSE, pE]};    --  change parent pointer in "after" node    IF after # nilPagePointer THEN tree.base[after].parent _ p;    -- move the other entries over and stick ours in    pE _ NSBTreeInternal.FirstEntry[dPage];    loopSize _ emptySize;    WHILE loopSize < dPage.size DO      IF StringCompare[n, NSBTreeInternal.EntryName[tree, pE]] = less THEN {        insertpE _ pE + newEntrySize;        Copy[from: pE, to: insertpE, size: dPage.size - loopSize];        NSBTreeInternal.EntryName[tree, pE]^ _ [          length: 0, maxlength: n.length, text:];        MoveLongString[NSBTreeInternal.EntryName[tree, pE], n];        Copy[          from: c, to: NSBTreeInternal.EntryValue[tree, pE], size: tree.valueSize];        NSBTreeInternal.EntryPointerPointer[tree, pE]^ _ NSBTreeInternal.EntryPointer[          tree, insertpE];        NSBTreeInternal.EntryPointerPointer[tree, insertpE]^ _ after;        dPage.size _ dPage.size + newEntrySize;        EXIT};      loopSize _ loopSize + NSBTreeInternal.EntrySize[tree, pE];      pE _ NSBTreeInternal.NextEntry[tree, pE];      REPEAT        FINISHED => {          NSBTreeInternal.EntryName[tree, pE]^ _ [            length: 0, maxlength: n.length, text:];          MoveLongString[NSBTreeInternal.EntryName[tree, pE], n];          Copy[            from: c, to: NSBTreeInternal.EntryValue[tree, pE],            size: tree.valueSize];          NSBTreeInternal.EntryPointerPointer[tree, pE]^ _ dPage.lastPointer;          dPage.lastPointer _ after;          dPage.size _ dPage.size + newEntrySize}      ENDLOOP;    RETURN[TRUE, FALSE, pE];    END;  -- NSBTreeInternal  InternalFind: PUBLIC INTERNAL PROCEDURE [tree: Tree, name: LONG STRING]    RETURNS [      ok: BOOLEAN, value: NSBTreeInternal.ValuePointer, page: PagePointer,      ent: EntryHandle] =    -- Given a file name, return the value and pointer to entry    -- If the file name is not found, return a pointer to the next entry     BEGIN    InternalFindLocal: INTERNAL PROCEDURE [      base: PageHandle, offset: PagePointer, name: LONG STRING]      RETURNS [        ok: BOOLEAN, value: NSBTreeInternal.ValuePointer, page: PagePointer,        ent: EntryHandle] =      BEGIN      dPage: PageHandle;      pE: EntryHandle;      loopSize: CARDINAL _ emptySize;      IF offset = nilPagePointer THEN RETURN[FALSE, NIL, nilPagePointer, NIL];      dPage _ @base[offset];      pE _ NSBTreeInternal.FirstEntry[dPage];      WHILE loopSize < dPage.size DO        SELECT StringCompare[name, NSBTreeInternal.EntryName[tree, pE]] FROM          less =>            IF NSBTreeInternal.EntryPointer[tree, pE] = nilPagePointer THEN              RETURN[FALSE, NIL, offset, pE]            ELSE {              [ok, value, page, ent] _ InternalFindLocal[                base, NSBTreeInternal.EntryPointer[tree, pE], name];              RETURN[ok, value, page, IF ent = NIL THEN pE ELSE ent]};          equal => RETURN[TRUE, NSBTreeInternal.EntryValue[tree, pE], offset, pE];          ENDCASE;        loopSize _ loopSize + NSBTreeInternal.EntrySize[tree, pE];        pE _ NSBTreeInternal.NextEntry[tree, pE];        ENDLOOP;      IF dPage.lastPointer = nilPagePointer THEN RETURN[FALSE, NIL, offset, NIL]      ELSE RETURN InternalFindLocal[base, dPage.lastPointer, name];      END;    RETURN InternalFindLocal[tree.base, tree.top, name];    END;  -- NSBTreeInternal  LastEntry: PUBLIC INTERNAL PROCEDURE [tree: Tree, d: PageHandle]    RETURNS [p: EntryHandle] =    -- return pointer to last filled entry of this page    BEGIN    l: CARDINAL _ emptySize;    p _ NSBTreeInternal.FirstEntry[d];    WHILE l < d.size DO      l _        l + NSBTreeInternal.Overhead[tree] + SIZE[          StringBody [NSBTreeInternal.EntryName[tree, p].length]];      IF l = d.size THEN EXIT;      p _ NSBTreeInternal.NextEntry[tree, p];      ENDLOOP;    RETURN    END;  -- NSBTreeInternal  MoveLongString: PUBLIC INTERNAL PROCEDURE [to, from: LONG STRING] =    BEGIN    to.length _ MIN[from.length, to.maxlength];    Inline.LongCOPY[to: to + 2, from: from + 2, nwords: (to.length + 1)/2];    RETURN    END;  NewPage: INTERNAL PROCEDURE [tree: Tree] RETURNS [p: PagePointer] =    BEGIN    p _ NSBTreeInternal.firstPagePointer;    THROUGH [0..tree.size/bTreePage) DO      IF tree.base[p].free THEN EXIT;      p _ p + bTreePage*Environment.wordsPerPage;      REPEAT        FINISHED => {p _ ExpandNSBTree[tree]; IF p = nilPagePointer THEN RETURN};      ENDLOOP;    tree.base[p].size _ emptySize;    tree.base[p].free _ FALSE;    tree.base[p].lastPointer _ tree.base[p].parent _ nilPagePointer;    tree.base[p].sizeValue _ tree.valueSize;    RETURN    END;  SplitNode: INTERNAL PROCEDURE [    tree: Tree, p: PagePointer, n: LONG STRING, c: NSBTreeInternal.ValuePointer,    after: PagePointer] RETURNS [ok, noRoom: BOOLEAN, ent: EntryHandle] =    -- split this node into two and insert the mid-entry into the parent node    BEGIN    dPage: PageHandle;    newPage: PagePointer;    pNewPage: PageHandle;    newPop: PagePointer;    pNewPop: PageHandle;    pE, pMid: EntryHandle;    midSize: CARDINAL;    middleName: STRING _ [NSBTree.maxNameLength];    middleValue: ARRAY [0..LAST[NSBTree.ValueSize]] OF CARDINAL;    loopSize: CARDINAL _ emptySize;    newPage _ NewPage[tree];    dPage _ @tree.base[p];    IF newPage = nilPagePointer THEN RETURN[FALSE, TRUE, NIL];    IF dPage.parent = nilPagePointer THEN {      -- the New[] might invalidate dPage, so recalculate       newPop _ NewPage[tree];      IF newPop = nilPagePointer THEN RETURN[FALSE, TRUE, NIL];      pNewPop _ @tree.base[newPop];      dPage _ @tree.base[p]};    -- fill the new page    pNewPage _ @tree.base[newPage];    pE _ NSBTreeInternal.FirstEntry[dPage];    WHILE loopSize + NSBTreeInternal.EntrySize[tree, pE] < dPage.size/2 DO      loopSize _ loopSize + NSBTreeInternal.EntrySize[tree, pE];      pE _ NSBTreeInternal.NextEntry[tree, pE];      ENDLOOP;    pMid _ pE;    midSize _ loopSize;    MoveLongString[middleName, NSBTreeInternal.EntryName[tree, pMid]];    Copy[      from: NSBTreeInternal.EntryValue[tree, pMid], to: @middleValue,      size: tree.valueSize];    loopSize _ loopSize + NSBTreeInternal.EntrySize[tree, pE];    pE _ NSBTreeInternal.NextEntry[tree, pE];    -- move the rest of the page into the new page    Copy[from: pE, to: @pNewPage.entries, size: dPage.size - loopSize];    -- clean up the two pages    pNewPage.size _ dPage.size - loopSize + emptySize;    dPage.size _ midSize;    pNewPage.lastPointer _ dPage.lastPointer;    dPage.lastPointer _ NSBTreeInternal.EntryPointer[tree, pMid];    pNewPage.parent _ dPage.parent;    IF pNewPage.lastPointer # nilPagePointer THEN {      --  change parent pointers in children of new node      tree.base[pNewPage.lastPointer].parent _ newPage;      pE _ NSBTreeInternal.FirstEntry[pNewPage];      WHILE pE # NSBTreeInternal.FirstFreeEntry[pNewPage] DO        tree.base[NSBTreeInternal.EntryPointer[tree, pE]].parent _ newPage;        pE _ NSBTreeInternal.NextEntry[tree, pE]        ENDLOOP};    -- now the insert will work    IF StringCompare[n, middleName] = less THEN      [ent: ent] _ InsertInNode[tree, p, n, c, after]    ELSE [ent: ent] _ InsertInNode[tree, newPage, n, c, after];    IF dPage.parent = nilPagePointer THEN {      -- the tree has grown out the top      tree.top _ tree.base.top _ newPop;      dPage.parent _ pNewPage.parent _ newPop;      pE _ NSBTreeInternal.FirstEntry[pNewPop];      NSBTreeInternal.EntryName[tree, pE]^ _ [        length: 0, maxlength: middleName.length, text:];      MoveLongString[NSBTreeInternal.EntryName[tree, pE], middleName];      Copy[        from: @middleValue, to: NSBTreeInternal.EntryValue[tree, pE],        size: tree.valueSize];      NSBTreeInternal.EntryPointerPointer[tree, pE]^ _ p;      pNewPop.lastPointer _ newPage;      pNewPop.size _        emptySize + NSBTreeInternal.Overhead[tree] + SIZE[          StringBody [middleName.length]];      RETURN[TRUE, FALSE, ent]};    [ok: ok, noRoom: noRoom] _ InsertInNode[      tree, dPage.parent, middleName, LOOPHOLE[LONG[@middleValue]], newPage];    RETURN[ok, noRoom, ent]    END;  StringCompare: INTERNAL PROCEDURE [a, b: LONG STRING]    RETURNS [relation: CompareResult] = {    l: CARDINAL;    ca, cb: CHARACTER;    CharAnd: PROCEDURE [CHARACTER, WORD] RETURNS [CHARACTER] = Inline.BITAND;    l _ MIN[a.length, b.length];    FOR i: CARDINAL IN [0..l) DO      ca _ a[i];      cb _ b[i];      IF ca IN ['a..'z] THEN ca _ CharAnd[ca, 137B];  -- ignore case shifts      IF cb IN ['a..'z] THEN cb _ CharAnd[cb, 137B];      IF ca < cb THEN RETURN[less];      IF ca > cb THEN RETURN[greater];      ENDLOOP;    RETURN[      SELECT a.length FROM        < b.length => less,        = b.length => equal,        ENDCASE => greater]};  -- NSBTreeInternal  Successor: PUBLIC INTERNAL PROCEDURE [    tree: Tree, p: PagePointer, pE: EntryHandle]    RETURNS [pg, after: PagePointer] =    -- Finds the successor to a given entry.  Also returns the after    -- pointer given entry    BEGIN    IntSucc: INTERNAL PROCEDURE [p1: PagePointer] RETURNS [p0: PagePointer] =      BEGIN      ipE: EntryHandle _ NSBTreeInternal.FirstEntry[@tree.base[p1]];      nextP: PagePointer _ NSBTreeInternal.EntryPointer[tree, ipE];      IF nextP = nilPagePointer THEN RETURN[p1]      ELSE {p0 _ IntSucc[nextP]; RETURN};      END;    testpE: EntryHandle _ NSBTreeInternal.FirstFreeEntry[@tree.base[p]];    pE _ NSBTreeInternal.NextEntry[tree, pE];    after _      IF testpE = pE THEN tree.base[p].lastPointer      ELSE NSBTreeInternal.EntryPointer[tree, pE];    pg _ IntSucc[after];    RETURN;    END;  END.           LOG      Time: 8-Jun-81 11:53:00 AM By: KAM  	Action: Created from DirectoryTreesImpl      Time: 22-Sep-81 17:20:41 By: KAM  	Action: NSBTreeGetNext now returns the entry that would follow name, even if name is not in    the b-tree.  Changed the get next cache from an array to a linked list, so it will never run out of room.      Time:  1-Oct-81 12:20:46 By: PXK    	Action: MONITORizing it and making Validation public, now has own heap.      Time:  5-Oct-81 16:11:09 By: KAM  	Action: Added PROCs SwapValue and SnapShot, attached cache entry to a b-tree descriptor,    added parameters reset and lpSize to Make.      Time:  January 27, 1982  5:45 PM By: KAM  	Action: Made less greedy in creating spaces for NSBTrees.      Time:  11-Mar-82  8:55:08 By: KAM  	Action: Added Map and Unmap plus support.   Time:  20-Sep-82 16:26:42 By: KAM  	Action: Split from NSBTreeImpl. Added variable value size.   Time:  13-May-83 11:50:08 By: KAM  	Action: Added ReadOnly plus support.   Time:  27-Jul-83 10:17:16 By: DWE     Action: added usage parmeter.      
-- File: LibScavengerImpl.mesa - last edit:-- bjd                 25-Aug-86 10:25:07-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  LibServOps, NSBTree, NSExec, NSFile, NSSegment, NSString, NSTTY, Runtime, String, TextInput, Time, TTY, XString, XStringHashTable;LibScavengerImpl: PROGRAM  IMPORTS LibServOps, NSBTree, NSExec, NSFile, NSSegment, NSString, NSTTY, Runtime, String, TextInput, Time, TTY, XString, XStringHashTable =  BEGIN    gf: LONG POINTER TO LibServOps.GlobalFrame = @LibServOps.gf;  recordsExt: NSString.String = S["Records"L];  bTreeExt: NSString.String = S["BTree"L];  hashTableExt: NSString.String = S["HashTable"L];  initialHashTableSize: NATURAL = 10;  ChoiceSequence: TYPE = RECORD [    seq: SEQUENCE length: CARDINAL OF NSString.String];    AlreadyExists: ERROR = CODE;  ScavengeDataBase: NSExec.ExecProc =     BEGIN    CleanUp: PROC = {      gf.z.FREE[@choices];      FOR i: NATURAL IN [0..dbStrings.length) DO NSString.FreeString[z: gf.z, s: dbStrings[i]] ENDLOOP;      gf.z.FREE[@dbStrings]};    failed: BOOLEAN ¬ FALSE;    nLibjects: CARDINAL ¬ 0;    startTime: Time.Packed = Time.Current[];    choices: LONG POINTER TO ChoiceSequence ¬ NIL;    tty: TTY.Handle = NSExec.GetTTY[exec];    which: TextInput.ChoiceIndex;    dbStrings: LibServOps.Strings;    inLibDir: TextInput.YesOrNo;    IF gf.status # started THEN {      TTY.PutString[tty, "Librarian service must be started to run scavenger."L];      GOTO quit};    inLibDir ¬ TextInput.GetYesNo[      tty: NSExec.GetTTY[exec], prompt: S["Look for database in librarian directory?"L], default: yes];    dbStrings ¬ GetDataBases[lookInLibDirectory: inLibDir=yes];    choices ¬ gf.z.NEW[ChoiceSequence[dbStrings.length]];    FOR i: NATURAL IN [0..dbStrings.length) DO choices[i] ¬ dbStrings[i] ENDLOOP;    which ¬ TextInput.GetChoice[      tty: tty, prompt: S["Database to scavenge"L],      choices: DESCRIPTOR[choices], nilOK: FALSE ! UNWIND => CleanUp[]];    IF TextInput.GetYesNo[      tty: NSExec.GetTTY[exec], prompt: S["Are you sure?"L]] # yes THEN      {CleanUp[]; GOTO quit};    TTY.PutString[tty, "Scavenging forward '"L];    NSTTY.PutString[tty, dbStrings[which]];    TTY.PutString[tty, "' ... "L];    [nLibjects, failed] ¬ ConvertBTreeToHashTable[      rootName: dbStrings[which], inLibDir: inLibDir=yes];    IF failed THEN TTY.PutLine[tty, " Failed. Try again."L]    ELSE {      string: STRING = [24];      IF inLibDir=no THEN MoveRecordsFile[rootName: dbStrings[which]];      TTY.PutLine[tty, " done."L];      AppendElapsedTime[Time.Current[] - startTime, string];      TTY.PutString[tty, "Elapsed time:  "L]; TTY.PutLine[tty, string];      string.length ¬ 0;      String.AppendNumber[string, nLibjects];      TTY.PutString[tty, string]; TTY.PutLine[tty, " libjects converted."L];      };    CleanUp[];    EXITS      quit => NULL;    END;  ConvertBTreeToHashTable: PROCEDURE [rootName: NSString.String, inLibDir: BOOLEAN]    RETURNS [nLibjects: CARDINAL ¬ 0, failed: BOOLEAN ¬ FALSE] =    BEGIN      CleanUp: PROC = {};    evenString: LONG STRING = [NSBTree.maxNameLength];    oddString: LONG STRING = [NSBTree.maxNameLength];    names: ARRAY BOOLEAN<<FALSE, TRUE>> OF LONG STRING = [oddString, evenString];    even: BOOLEAN ¬ TRUE;    rp: LibServOps.RecordPlace;        bTreeFileH: NSFile.Handle ¬       IF inLibDir THEN OpenFile[root: rootName, ext: bTreeExt]      ELSE OpenWDFile[root: rootName, ext: bTreeExt];    hashTableFileH: NSFile.Handle ¬ DeleteAndCreateFile[      root: rootName, ext: hashTableExt];    tree: NSBTree.Tree ¬ NSBTree.Make[bTreeFileH, gf.fileSession];    valueSize: NSBTree.ValueSize ¬ NSBTree.GetInfo[tree].valueSize;    table: XStringHashTable.Table ¬ NIL;    table ¬ XStringHashTable.Make[      file: hashTableFileH, session: gf.fileSession, valueSize: valueSize];    NSBTree.GetNext[      tree: tree, name: names[even], nextName: names[~even],      value: Describe[@rp], mask: "*"L];    DO      xName: XString.ReaderBody ¬ XS[names[~even]];      [] ¬ XStringHashTable.Insert[table, @xName, Describe[@rp]];      nLibjects ¬ SUCC[nLibjects];      even ¬ ~even;      NSBTree.GetNext[        tree: tree, name: names[even], nextName: names[~even],	value: Describe[@rp], mask: "*"L];      IF names[~even].length = 0 THEN EXIT;      ENDLOOP;    XStringHashTable.Delete[table];    NSBTree.Delete[tree];    DeleteFile[bTreeFileH];    CloseFile[bTreeFileH];    CloseFile[hashTableFileH];    END;    AppendElapsedTime: PROC [et: LONG CARDINAL, s: LONG STRING] = {    minutes, seconds: CARDINAL;    seconds ¬ CARDINAL[et MOD 60];    et ¬ et / 60;    minutes ¬ CARDINAL[et MOD 60];    et ¬ et / 60;    String.AppendLongNumber[s, et];    String.AppendChar[s, ':];    IF minutes < 10 THEN String.AppendChar[s, '0];    String.AppendNumber[s, minutes];    String.AppendChar[s, ':];    IF seconds < 10 THEN String.AppendChar[s, '0];    String.AppendNumber[s, seconds]};  MoveRecordsFile: PROCEDURE [rootName: NSString.String] =    BEGIN    recFile: NSFile.Handle ¬ OpenWDFile[rootName, recordsExt];    NSFile.Move[file: recFile, destination: gf.libDir, session: gf.fileSession];    END;  OpenWDFile: PROCEDURE [root, ext: NSFile.String] RETURNS [handle: NSFile.Handle] = {    libDir: NSFile.Handle ¬ NSFile.OpenByReference[      reference: NSFile.GetReference[file: NSExec.WorkingDirectory[]],      session: gf.fileSession];    fileName: LONG STRING = [NSFile.maxStringLength];    NSString.AppendToMesaString[fileName, root];    String.AppendChar[fileName, '.];    NSString.AppendToMesaString[fileName, ext];    handle ¬ NSFile.OpenByName[      directory: libDir, path: S[fileName], session: gf.fileSession];    CloseFile[libDir]};  OpenFile: PROCEDURE [root, ext: NSFile.String] RETURNS [handle: NSFile.Handle] = {    fileName: LONG STRING = [NSFile.maxStringLength];    NSString.AppendToMesaString[fileName, root];    String.AppendChar[fileName, '.];    NSString.AppendToMesaString[fileName, ext];    handle ¬ NSFile.OpenByName[      directory: gf.libDir, path: S[fileName], session: gf.fileSession]};  DeleteFile: PROCEDURE [handle: NSFile.Handle]  = INLINE {    NSFile.Delete[handle, gf.fileSession ! NSFile.Error => CONTINUE]};  CloseFile: PROCEDURE [handle: NSFile.Handle]  = INLINE {    NSFile.Close[handle, gf.fileSession ! NSFile.Error => CONTINUE]};  CreateFile: PROCEDURE [root, ext: NSFile.String] RETURNS [file: NSFile.Handle] =    BEGIN    fileName: LONG STRING = [NSFile.maxStringLength];    attrs: ARRAY [0..2) OF NSFile.Attribute;    NSString.AppendToMesaString[fileName, root];    String.AppendChar[fileName, '.];    NSString.AppendToMesaString[fileName, ext];    attrs ¬ [      [name[S[fileName]]], [backedUpOn[NSFile.neverBackup]]];    file ¬ NSFile.Create[      directory: gf.libDir, attributes: DESCRIPTOR[attrs],      session: gf.fileSession ! NSFile.Error =>	 IF error = [insertion[fileNotUnique]] THEN ERROR AlreadyExists];    END;  DeleteAndCreateFile: PROCEDURE [root, ext: NSFile.String]    RETURNS [file: NSFile.Handle] =    BEGIN    reset: BOOLEAN ¬ FALSE;    file ¬ CreateFile[root, ext ! AlreadyExists => {reset ¬ TRUE; CONTINUE}];    IF reset THEN {      file ¬ OpenFile[root, ext];      SetLength[file, 0]};    END;    SetLength: PROCEDURE [f: NSFile.Handle, pages: LONG CARDINAL] = INLINE {    NSSegment.SetSizeInPages[file: f, pages: pages, session: gf.fileSession]};      FileName: PROC [name, root, ext: NSFile.String]    RETURNS [NSString.String] = {    name.length ¬ 0;    name ¬ NSString.AppendString[name, root];    name ¬ NSString.AppendString[name, S["."L]];    name ¬ NSString.AppendString[name, ext];    RETURN[name]};  XS: PROC [s: LONG STRING] RETURNS [XString.ReaderBody] = INLINE {    RETURN[XString.FromSTRING[s]]};  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  Describe: PROCEDURE [rp: LONG POINTER TO LibServOps.RecordPlace]    RETURNS [LONG DESCRIPTOR FOR ARRAY OF CARDINAL] = INLINE {    RETURN[DESCRIPTOR[rp, SIZE[LibServOps.RecordPlace]]]};      GetDataBases: PROCEDURE [lookInLibDirectory: BOOLEAN]    RETURNS [seq: LibServOps.Strings] =    BEGIN    dir: NSFile.Handle = IF lookInLibDirectory      THEN gf.defaultLibDir ELSE NSExec.WorkingDirectory[];    CountThem: NSFile.AttributesProc = {count ¬ count + 1};    GetNames: NSFile.AttributesProc = {      extensionLength: NATURAL = bTreeExt.length + 1;      rootLength: NATURAL = attributes.name.length - extensionLength;      seq[i] ¬ NSString.CopyString[z: gf.z, s: attributes.name];      seq[i].length ¬ rootLength;      i ¬ i + 1};    i, count: NATURAL ¬ 0;    scope: NSFile.Scope = [filter: [matches[attribute: [name[S["*.BTree"L]]]]]];    NSFile.List[      directory: dir, proc: CountThem, scope: scope, selections: []];    seq ¬ gf.z.NEW[LibServOps.StringSequence[count]];    NSFile.List[      directory: dir, proc: GetNames, scope: scope,      selections: [interpreted: [name: TRUE]]];    END;  Init: PROCEDURE = {    commands: ARRAY [0..1) OF NSExec.Command ¬ [      [S["Scavenge Forward Database"L],	ScavengeDataBase, AdministratorPred]];    [] ¬ LibServOps.StatusEqualTo[started !      Runtime.UnboundProcedure, Runtime.ControlFault => GOTO error];    NSExec.AddClientCommands[gf.execId, DESCRIPTOR[commands]];    EXITS error => ERROR NSExec.Error[cannotInitialize]};      AdministratorPred: NSExec.Predicate = {    RETURN[NSExec.UserAServerSA[exec] AND LibServOps.StatusEqualTo[started]]};  --main line code  Init[];  END.    
-- File: LibBackupImpl.mesa - last edit:-- bjd                 18-Jan-88 22:16:15-- PLK    	10-Apr-84 15:40:31-- Copyright (C) 1986, 1987, 1988 by Xerox Corporation. All rights reserved.DIRECTORY  Backup,  CH,  Courier ,  Environment,  Inline,  LibOps,  LibBackup,  LibMessages,  LibServOps,  NSFile,  NSFileStream,  NSString,  Process,  Stream,  System,  Time,  XLibrarian,  XString;LibBackupImpl: MONITOR  -- monitor backup process;  IMPORTS    Backup, Courier, Inline, LibOps, LibMessages, LibServOps, NSFile, NSFileStream, NSString, Process, Stream, System, Time, XString, XLibrarian  EXPORTS LibBackup, XLibrarian, LibServOps =  BEGIN      Service: TYPE = LONG POINTER TO ServiceObject;  ServiceObject: PUBLIC TYPE = LibServOps.ServiceObject;    PropertyList: TYPE = LONG POINTER TO PropertyListObject;  PropertyListObject: PUBLIC TYPE = LibOps.PropertyListObject;  Atom: PUBLIC TYPE = LibServOps.Atom;  nullAtom: Atom = XLibrarian.nullAtom;    gf: LONG POINTER TO LibServOps.GlobalFrame = @LibServOps.gf;  fileNameLength: NATURAL = CH.maxLocalNameLength + 30;  Header: TYPE = LONG POINTER TO LibServOps.HeaderObject;  DataBase: TYPE = LibServOps.DataBase;  recordExt: NSString.String = S["Records"L];  hashTableExt: NSString.String = S["HashTable"L];  logExt: NSString.String = S["Log"L];    -- monitored data associated with the backup process;  backUpProcessRunning: BOOLEAN ¬ FALSE;  stopBackUpProcess: BOOLEAN ¬ FALSE;  backUpCond: CONDITION;  lastDayBackUpFinished: NATURAL ¬ Today[];  nullTime: LibServOps.Time = [0];  StartBackupProcess: PUBLIC ENTRY PROCEDURE = {    stopBackUpProcess ¬ FALSE;    Process.SetTimeout[@backUpCond, Process.SecondsToTicks[1800]];  -- half hour    Process.Detach[FORK BackUpProcess[]]};  StopBackupProcess: PUBLIC ENTRY PROCEDURE = {    stopBackUpProcess ¬ TRUE;    NOTIFY backUpCond;    WHILE backUpProcessRunning DO WAIT backUpCond; ENDLOOP};  BackupFiles: PUBLIC ENTRY PROC = {    lastDayBackUpFinished ¬ 33; NOTIFY backUpCond};      GetBackupParameters: PUBLIC PROCEDURE [index: NATURAL]    RETURNS [path: NSString.String, versionsToKeep: CARDINAL] =    BEGIN  -- path should be freed with FreeBackupPath    getBackupParams: LibServOps.EntryProcType = {      tempPath: NSString.String;      [tempPath, versionsToKeep] ¬ LibServOps.ReadBackupParameters[index];      path ¬ NSString.CopyString[gf.z, tempPath]};    -- monitor reading of the backup params. with global MonitorOperation proc;    LibServOps.MonitorOperation[proc: getBackupParams, access: read, dbIndex: index];    END;  FreeBackupPath: PUBLIC PROCEDURE [path: NSString.String]    RETURNS [null: NSString.String ¬ NSString.nullString] =    BEGIN    IF path#NSString.nullString THEN NSString.FreeString[z: gf.z, s: path];    END;  BackUpProcess: ENTRY PROC =    BEGIN ENABLE UNWIND => NULL;    allOK: BOOLEAN;    backUpProcessRunning ¬ TRUE;    DO      allOK ¬ TRUE;      WHILE lastDayBackUpFinished = Today[] DO	IF stopBackUpProcess THEN GOTO stopIt;	WAIT backUpCond;	ENDLOOP;      FOR i: NATURAL IN [0..gf.dataBases.length) DO        IF stopBackUpProcess THEN GOTO stopIt;	IF ~BackUp[i].ok THEN allOK ¬ FALSE;	ENDLOOP;      IF allOK THEN lastDayBackUpFinished ¬ Today[]      ELSE WAIT backUpCond;  -- don't try it too soon.      REPEAT stopIt => NULL;      ENDLOOP;    backUpProcessRunning ¬ FALSE;    NOTIFY backUpCond;    END;      BackUp: PROCEDURE [index: NATURAL] RETURNS [ok: BOOLEAN ¬ FALSE] =    BEGIN  -- monitor the backup op. with the other operations (e.g. protocol & SA); clear the backupInProgress bit even if it fails so others can access;    backUp: LibServOps.EntryProcType = {      db.backupInProgress ¬ TRUE;      ok ¬ BackItUp[db];      db.backupInProgress ¬ FALSE};    LibServOps.MonitorOperation[proc: backUp, access: backup, dbIndex: index];    END;  BackItUp: PROCEDURE [db: LibServOps.DataBaseEntry] RETURNS [ok: BOOLEAN] =    BEGIN    h: DataBase;    header: Header;    message: NSString.String;    errorMessage: NSString.String;    storedFile, storedLog, storedHashTable: BOOLEAN ¬ TRUE;    string: LONG STRING = [fileNameLength];    name: NSString.String ¬ S[string];    path: NSString.String;    IF db.h = NIL THEN RETURN[ok: TRUE];  -- should we load here?    h ¬ db.h; header ¬ h.header;    IF System.SecondsSinceEpoch[header.backupTime] > -- no change wait til tomorrow;       System.SecondsSinceEpoch[header.lastChange] THEN RETURN[ok: TRUE];    IF header.backupPath.length=0 THEN RETURN[ok: TRUE]; -- no path, don't bother;    path ¬ [      bytes: LOOPHOLE[@header.backupPath.bytes],      length: header.backupPath.length,      maxlength: header.backupPath.length];    message ¬ LibMessages.ExpandMsg[      gf.z, LibMessages.M[keyStartingBackup], db.nameRoot];    LibMessages.NoteEvent[message];    NSString.FreeString[gf.z, message];    SetChecksum[file: h.recordFile];    SetChecksum[file: h.hashTableFile];    [storedFile, errorMessage] ¬ Backup.File[      hostAndPath: path,      name: FileName[name, db.nameRoot, recordExt],      file: h.recordFile, session: gf.fileSession,      versionsToKeep: header.backupVersionsToKeep,      messageZone: gf.z,      for: gf.serverId];    IF storedFile THEN      [storedHashTable, errorMessage] ¬ Backup.File[	hostAndPath: path,	name: FileName[name, db.nameRoot, hashTableExt],	file: h.hashTableFile, session: gf.fileSession,	versionsToKeep: header.backupVersionsToKeep,	messageZone: gf.z,	for: gf.serverId];<<  At this point, there is no reason to save the log;  it won't help you when recovering;  future:  save the log every half hour, backup (hence reset log) every evening.    IF storedFile AND storedHashTable THEN      [storedLog, errorMessage] ¬ Backup.AppendToFile[	hostAndPath: path,	name: FileName[name, db.nameRoot, logExt],	startingAt: header.logLengthBackedUp,	source: h.log, session: gf.fileSession,	sourceBytes: header.logLength,	messageZone: gf.z,	for: gf.serverId];>>    ok ¬ storedFile AND storedHashTable -- AND storedLog --;    IF ok THEN NowBackedUp[h];    IF ~storedFile THEN PostBackupError[      store, db.nameRoot, recordExt, path, errorMessage];    IF ~storedHashTable THEN PostBackupError[      store, db.nameRoot, hashTableExt, path, errorMessage];    IF ~storedLog THEN PostBackupError[      store, db.nameRoot, logExt, path, errorMessage];    IF ok THEN {      message ¬ LibMessages.ExpandMsg[	gf.z, LibMessages.M[keyCompletedBackup], db.nameRoot];      LibMessages.NoteEvent[message];      NSString.FreeString[s: message, z: gf.z]};    END;-- Recovery  RecoverDataBase: PUBLIC PROCEDURE [    index: NATURAL, recoveryPath: NSString.String] =    BEGIN    -- this whole recover business could be done better by having the Backup.Recover take a destination;  Recover could then have the files retrieved to temporary and only after retrieval was successful, delete existing db files and rename temp to actual files.    recoverDB: LibServOps.EntryProcType = {      db.recoveryInProgress ¬ TRUE;      -- rename so recover can copy to dbName;      IF NOT RenameToTemp[dbName: db.nameRoot].ok THEN GOTO problems;      IF NOT Recover[index, recoveryPath].ok THEN        -- if Recover fails, restore from the temp files, which should still be dirty;        IF NOT RenameFromTemp[dbName: db.nameRoot].ok THEN	  GOTO inconsistent;	-- else recovery failed, but ok, the files are consistent, just dirty (maybe);       db.recoveryInProgress ¬ FALSE;       EXITS       inconsistent => -- here we couldn't recover from temp files, so we must leave the recoveryInProgress bit set; after rebooting the database will be gone, but still available from backup (hopefully). this should rarely happen;          LibMessages.NoteEvent[LibMessages.M[keyProblemsDeletingDatabase]];       problems => {         db.recoveryInProgress ¬ FALSE;         LibMessages.NoteEvent[LibMessages.M[keyProblemsDeletingDatabase]]}};    -- monitor the recovery with the other operations (e.g. protocol & SA)    LibServOps.MonitorOperation[proc: recoverDB, access: recover, dbIndex: index];    END;  Recover: PROCEDURE [i: NATURAL, recoveryPath: NSString.String]    RETURNS [ok: BOOLEAN ¬ TRUE] =    BEGIN    string: LONG STRING = [fileNameLength];    gotFile, gotHashTable: BOOLEAN ¬ TRUE;    errorMessage: NSString.String;    message: NSString.String;    name: NSString.String ¬ S[string];    name ¬ FileName[name, gf.dataBases[i].nameRoot, recordExt];    message ¬ LibMessages.ExpandMsg[      gf.z, LibMessages.M[keyStartingRecovery], gf.dataBases[i].nameRoot];    LibMessages.NoteEvent[message];    NSString.FreeString[gf.z, message];<<	Have to get HashTable first so that file won't look OK if that	retrieval succeeds but the HashTable file recovery fails.>>    [gotHashTable, errorMessage] ¬ Backup.RecoverFile[      hostAndPath: recoveryPath,      name: FileName[name, gf.dataBases[i].nameRoot, hashTableExt],      destination: gf.libDir, session: gf.fileSession,      messageZone: gf.z,      for: gf.serverId];    IF gotHashTable THEN [gotFile, errorMessage] ¬ Backup.RecoverFile[      hostAndPath: recoveryPath,      name: FileName[name, gf.dataBases[i].nameRoot, recordExt],      destination: gf.libDir, session: gf.fileSession,      messageZone: gf.z,      for: gf.serverId];    IF ~gotFile THEN PostBackupError[      retrieve, gf.dataBases[i].nameRoot, recordExt, recoveryPath, errorMessage];    IF ~gotHashTable THEN PostBackupError[      retrieve, gf.dataBases[i].nameRoot, hashTableExt, recoveryPath, errorMessage];    IF gotFile AND gotHashTable THEN {    -- load newly recovered data base and play log;      LibServOps.UnloadDataBase[i];      LibServOps.LoadDataBase[i];      LibServOps.IsDirty[gf.dataBases[i].h]; -- here is the problem;  if we crash after the files have been recovered, but before we dirty the db here, the log will never have been played, but after rebooting, the database will look okay.  this is the argument for reversing the order of these renames (see RecoverDatabase comment above) so as to make this window of vulnerability smaller;      PlayLog[i];      LibServOps.MakeClean[gf.dataBases[i].h];      message ¬ LibMessages.ExpandMsg[	gf.z, LibMessages.M[keyCompletedRecovery], gf.dataBases[i].nameRoot];      LibMessages.NoteEvent[message];      NSString.FreeString[s: message, z: gf.z];    };    -- ** if recovery were forked, need to free the copied path:    -- ** NSString.FreeString[gf.z, recoveryPath];    ok ¬ (gotHashTable AND gotFile); -- ok only if both of these ok;    END;  RenameToTemp: PROCEDURE [dbName: NSString.String]     RETURNS [ok: BOOLEAN ¬ TRUE] = {      -- 1st, delete any temp files (of form $$$.*$) that already exist;      IF NOT LibServOps.DeleteDataBaseFiles[root: S["$$$"L], ext: S["$"L]].ok THEN GOTO problems;      -- now rename to temporary files (of form $$$.*$);      IF NOT LibServOps.RenameDataBase[	fromRoot: dbName, toRoot: S["$$$"L], toExt: S["$"]].ok      THEN GOTO problems;      EXITS problems => ok ¬ FALSE};    RenameFromTemp: PROCEDURE [dbName: NSString.String]    RETURNS [ok: BOOLEAN ¬ TRUE] = {     -- 1st, delete actual database files, in case one of them was succesfully retrieved in Recover;     IF NOT LibServOps.DeleteDataBaseFiles[root: dbName].ok THEN GOTO problems;      -- now recreate database files from temporary files (of form $$$.*$);     IF NOT LibServOps.RenameDataBase[       fromRoot: S["$$$"L], fromExt: S["$"], toRoot: dbName].ok     THEN GOTO problems;     EXITS problems => ok ¬ FALSE};-- maintaining the log  NoteTransaction: PUBLIC PROC [    h: DataBase, service: LibServOps.Service, why: LibServOps.LogType,    libject: XString.Reader ¬ NIL, -- setProperty, checkIn, checkOut, destroy, create     props: LONG DESCRIPTOR FOR ARRAY CARDINAL OF XLibrarian.Property ¬ NIL,    -- for setProperty    pName: LONG STRING ¬ NIL -- for newAtom --] =    BEGIN    -- ENABLE NSFile.Error => IF error = [space[mediumFull]] THEN ERROR XLibrarian.Error[serviceFull];    -- let this error through since services exec catches it;    h.header.lastChange ¬ service.lastUse;    IF h.playingLog THEN RETURN;    NoteByte[h.log, why.ORD];    SELECT why FROM      setProperty => {	NoteXString[h.log, libject];        NoteLong[h.log, service.lastUse];	NoteWord[h.log, props.LENGTH];	FOR i: NATURAL IN [0..props.LENGTH) DO	  prop: LONG POINTER TO XLibrarian.Property = @props[i];	  -- prevent multiple dereferencing for the same item	  NoteWord[h.log, LOOPHOLE[prop.tag]];	  NoteWord[h.log, LOOPHOLE[prop.value.type]];	  WITH p: prop.value SELECT FROM	    null => NULL;	    time => NoteLong[h.log, p.time];	    client => {	      NoteWord[h.log, p.record.LENGTH];	      NoteWords[h.log, p.record.BASE, p.record.LENGTH]};	    xString => NoteXString[h.log, p.string];	    xStrings => {	      NoteWord[h.log, p.strings.LENGTH];	      FOR j: NATURAL IN [0..p.strings.LENGTH) DO	        NoteXString[h.log, p.strings[j]];		ENDLOOP};	    string => NoteString[h.log, p.string];	    strings => {	      NoteWord[h.log, p.strings.LENGTH];	      FOR j: NATURAL IN [0..p.strings.LENGTH) DO	        NoteString[h.log, p.strings[j]];		ENDLOOP};	    integer => NoteLong[h.log, p.integer];	    ENDCASE => ERROR XLibrarian.Error[implementationBug];	  ENDLOOP};      newAtom => {        NoteWord[h.log, LOOPHOLE[props[0].tag]];	NoteString[h.log, pName]};      checkIn => {	NoteXString[h.log, libject];        NoteLong[h.log, service.lastUse]};      destroy => NoteXString[h.log, libject];      create, checkOut => {	NoteXString[h.log, libject];	NoteLong[h.log, service.lastUse];	NoteXString[h.log, @service.user]};      ENDCASE => ERROR XLibrarian.Error[implementationBug];    Stream.SendNow[h.log];  -- does the SetLength    h.header.logLength ¬ Stream.GetPosition[h.log];    END;  NoteByte: PROC [s: Stream.Handle, b: Environment.Byte] = INLINE {    s.PutByte[b]};  NoteXString: PROC [s: Stream.Handle, t: XString.Reader] = INLINE {    Courier.SerializeParameters[parameters: [@t, XString.DescribeReader], sH: s]};  NoteString: PROC [s: Stream.Handle, t: LONG STRING] = INLINE {    NoteWord[s, t.length]; s.PutString[t]};  NoteWord: PROC [s: Stream.Handle, c: WORD] = INLINE {    s.PutWord[c]};  NoteLong: PROC [s: Stream.Handle, l: LONG UNSPECIFIED] = INLINE {    s.PutWord[Inline.HighHalf[l]]; s.PutWord[Inline.LowHalf[l]]};  NoteWords: PROC [s: Stream.Handle, p: LONG POINTER, w: CARDINAL] = --INLINE-- {    s.PutBlock[[p, 0, w*2]]};  PlayLog: PROC [i: NATURAL] =    BEGIN    h: DataBase = gf.dataBases[i].h;    serv: ServiceObject ¬ [h: h];      -- only fields referenced are 'h', 'lastUse', and 'user'      -- 'user' is only  referenced by 'CreateLibject' and 'CheckOutLibject'    libject: XString.Reader;    why: LibServOps.LogType;    s: Stream.Handle = h.log;    h.playingLog ¬ TRUE;    s.SetPosition[0];    DO      ENABLE Stream.EndOfStream => GOTO allDone;         -- especially if in middle of record      why ¬ VAL[s.GetByte[]];      SELECT why FROM        newAtom => {	  tag: Atom ¬ GetWord[h.log];	  pName: LONG STRING ¬ GetString[h.log];	  LibServOps.AddAtomToFile[h, @serv, tag, pName];	  gf.z.FREE[@pName]};        checkIn => {	  libject ¬ GetXStringReader[s];	  serv.lastUse ¬ [GetLong[h.log]];	  LibServOps.CheckInLibject[h, @serv, libject];	  FreeReader[r: libject, z: gf.z]};        checkOut => {	  libject ¬ GetXStringReader[s];	  serv.lastUse ¬ [GetLong[h.log]];	  serv.user ¬ GetXStringReaderBody[h.log]; 	  LibServOps.CheckOutLibject[h, @serv, libject];	  FreeReader[r: libject, z: gf.z];	  FreeReaderBytes[r: serv.user, z: gf.z]};        create => {	  libject ¬ GetXStringReader[s];	  serv.lastUse ¬ [GetLong[h.log]];	  serv.user ¬ GetXStringReaderBody[h.log]; 	  LibServOps.CreateLibject[h, @serv, libject];	  FreeReader[r: libject, z: gf.z];	  FreeReaderBytes[r: serv.user, z: gf.z]};        destroy => {	  libject ¬ GetXStringReader[s];	  LibServOps.DestroyLibject[h, @serv, libject];	  FreeReader[r: libject, z: gf.z];	  FreeReaderBytes[r: serv.user, z: gf.z]};	setProperty => {	  pl: PropertyList;	  length: CARDINAL;	  libject ¬ GetXStringReader[s];	  serv.lastUse ¬ [GetLong[h.log]];	  length ¬ GetWord[h.log];	  pl ¬ LibOps.CreatePL[gf.z, length];	  FOR i: NATURAL IN [0..length) DO	    prop: LONG POINTER TO XLibrarian.Property = @pl.list.props[i];	    type: XLibrarian.PropertyType;	    prop.tag ¬ GetWord[h.log];	    type ¬ GetWord[h.log];	    SELECT type FROM	      null => prop.value ¬ [null[]];	      time => prop.value ¬ [time[[GetLong[h.log]]]];	      xString => prop.value ¬ [xString[GetXStringReader[h.log]]];	      string => prop.value ¬ [string[GetString[h.log]]];	      integer => prop.value ¬ [integer[GetLong[h.log]]];	      client => {	        length: CARDINAL = GetWord[h.log];		record: XLibrarian.Record = LibOps.NEWRecord[gf.z, length];		GetWords[h.log, record.BASE, length];		prop.value ¬ [client[record]]};	      xStrings => {	        length: CARDINAL = GetWord[h.log];		strings: XLibrarian.XStrings = --LibOps.--NEWXStrings[gf.z, length];		FOR j: CARDINAL IN [0..length) DO		  strings[j] ¬ GetXStringReader[h.log];		  ENDLOOP;		prop.value ¬ [xStrings[strings]]};	      strings => {	        length: CARDINAL = GetWord[h.log];		strings: XLibrarian.Strings = LibOps.NEWStrings[gf.z, length];		FOR j: CARDINAL IN [0..length) DO		  strings[j] ¬ GetString[h.log];		  ENDLOOP;		prop.value ¬ [strings[strings]]};	      ENDCASE => ERROR XLibrarian.Error[implementationBug];	    ENDLOOP;	  pl.list.props.LENGTH ¬ length;	  LibServOps.SetPropertiesForLibject[h, @serv, libject, pl];	  FreeReader[r: libject, z: gf.z];	  XLibrarian.DestroyPropertyList[pl]};	ENDCASE => ERROR XLibrarian.Error[implementationBug];      REPEAT allDone => NULL;      ENDLOOP;    h.playingLog ¬ FALSE;    END;  --LibOps.--NEWXStrings: PROC [z: UNCOUNTED ZONE, length: NATURAL]     RETURNS [XLibrarian.XStrings] = {ERROR};  GetXStringReader: PROC [s: Stream.Handle] RETURNS [r: XString.Reader] = INLINE {    Courier.DeserializeParameters[      parameters: [@r, XString.DescribeReader], sH: s, zone: gf.z]};  GetXStringReaderBody: PROC [s: Stream.Handle]    RETURNS [r: XString.ReaderBody] = INLINE {    Courier.DeserializeParameters[      parameters: [@r, XString.DescribeReaderBody], sH: s, zone: gf.z]};  GetString: PROC [s: Stream.Handle] RETURNS [t: LONG STRING] = {    length: CARDINAL ¬ GetWord[s];    t ¬ gf.z.NEW[StringBody[length]];    [] ¬ s.GetBlock[[LOOPHOLE[@t.text], 0, length]];    t.length ¬ length};  GetWord: PROC [s: Stream.Handle] RETURNS [UNSPECIFIED] = --INLINE-- {    RETURN[s.GetWord[]]};  GetLong: PROC [s: Stream.Handle] RETURNS [LONG UNSPECIFIED] = {    l: Environment.Long;    l.high ¬ GetWord[s];    l.low ¬ GetWord[s];    RETURN[l.lu]};  GetWords: PROC [s: Stream.Handle, p: LONG POINTER, w: CARDINAL] = --INLINE-- {    [] ¬ s.GetBlock[[p, 0, w*2]]};  FreeReader: PROC [r: XString.Reader, z: UNCOUNTED ZONE] = INLINE {    Courier.Free[parameters: [@r, XString.DescribeReader], zone: z]};  FreeReaderBytes: PROC [r: XString.ReaderBody, z: UNCOUNTED ZONE] = INLINE {    Courier.Free[parameters: [@r, XString.DescribeReaderBody], zone: z]};-- Utilities  NowBackedUp: PROCEDURE [h: DataBase] =    BEGIN    ENABLE UNWIND => NULL;    h.header.dirty ¬ TRUE;    h.header.backupTime ¬ LibServOps.Now[];    h.header.logLengthBackedUp ¬ h.header.logLengthBackedUp + h.header.logLength;    h.header.logLength ¬ 0;    Stream.SetPosition[h.log, 0];    NSFileStream.SetLength[h.log, 0];    Stream.SendNow[h.log];    LibServOps.MakeClean[h];    END;  PostBackupError: PROC [    action: {store, retrieve}, root, ext, path, errorMessage: NSString.String] = {    template: NSString.String ¬ IF action = store      THEN LibMessages.M[keyBackupErrorStoreFailed]      ELSE LibMessages.M[keyBackupErrorRetrieveFailed];    message: NSString.String ¬ LibMessages.ExpandMsg[      gf.z, template, path, root, ext, errorMessage];    LibMessages.NoteEvent[message];    NSString.FreeString[s: errorMessage, z: gf.z];    NSString.FreeString[s: message, z: gf.z];    };  SetChecksum: PROCEDURE [file: NSFile.Handle] =    BEGIN  -- avoid checksum validation, since files are written via Pilot directly;    a: ARRAY [0..1) OF NSFile.Attribute ¬ [[checksum[NSFile.unknownChecksum]]];    NSFile.ChangeAttributes[      file: file, attributes: DESCRIPTOR[a], session: gf.fileSession];    END;      Today: PROC [] RETURNS [NATURAL] = {    RETURN[Time.Unpack[LibServOps.Now[]].day]};      S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  FileName: PROC [name, root, ext: NSFile.String]    RETURNS [NSString.String] = {    name.length ¬ 0;    name ¬ NSString.AppendString[name, root];    name ¬ NSString.AppendString[name, S["."L]];    name ¬ NSString.AppendString[name, ext];    RETURN[name]};  END.
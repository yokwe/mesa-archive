-- File: LibrarianTest.mesa - last edit:-- bjd                 21-Jul-86 11:17:15-- PLK    :	 4-Apr-84  9:52:10-- DSC  :	 26-Jul-84 15:53:08-- Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.DIRECTORY  Date, Exec, Format, FormSW, Heap, XLibrarian, Put, Process, Runtime, String,  System, Tool, ToolWindow, Window, XString, NSString;LibrarianTest: PROGRAM  IMPORTS    Date, Exec, Format, FormSW, Heap, XLibrarian, Put, Process, Runtime,    String, System, Tool, ToolWindow, XString, NSString  SHARES XString =  BEGIN  itemLines: NATURAL = 10;  LibTypes: TYPE = {null, time, integer, client, string, xString, seq};  Item: TYPE = MACHINE DEPENDENT RECORD [    tag(0): LONG STRING ¬ NIL,    atom(2): XLibrarian.Atom ¬ XLibrarian.nullAtom,    type(3): LibTypes ¬ null,    value(4): LONG STRING ¬ NIL];  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    server: XLibrarian.Handle ¬ XLibrarian.nullHandle,    msgSW: Window.Handle ¬ NIL,    commandSW: Window.Handle ¬ NIL,    itemSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    database: LONG STRING ¬ NIL,    debugging: BOOLEAN ¬ FALSE,    libject: LONG STRING ¬ NIL,    queryCount: CARDINAL ¬ 1,    items: ARRAY [0..itemLines) OF Item ¬ ALL[]];  CommandItems: TYPE = {    open, close, validateAtoms, makeAtoms, database, create, destroy, out,    in, set, query, libject, debugging, queryCount};  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  myZone: UNCOUNTED ZONE = Heap.Create[initial: 4];  libZone: UNCOUNTED ZONE = Heap.Create[initial: 8, swapUnitSize: 4];    ParseError: ERROR [i: NATURAL] = CODE;  CommandProc: FormSW.ProcType = {    c: CommandItems = VAL[index];    Put.CR[data.msgSW];    Process.Detach[FORK CommandRoutine[sw, item, index]]};   CommandRoutine: FormSW.ProcType =    BEGIN    ENABLE      BEGIN    ABORTED => {	Put.Text[data.fileSW, "\nAborted.\n"L];	CONTINUE};      XLibrarian.Error => {	errorString: LONG STRING = [80];	Put.Text[data.fileSW, "\nXLibrarian.Error["L];	XLibrarian.StringForErrorCode[code, errorString];	Put.Text[data.fileSW, errorString];	Put.Text[data.fileSW, "].\n"L];	IF data.debugging OR code = implementationBug THEN	  Runtime.CallDebugger["Now's your chance."L];	CONTINUE};      ParseError => {        Put.Text[data.fileSW, "\nFailure parsing value for item "L];	Put.Decimal[data.fileSW, i];	Put.Text[data.fileSW, ". ["L];	Put.Text[data.fileSW, data.items[i].tag];	Put.Text[data.fileSW, "].\n"L];	CONTINUE};      END;    command: CommandItems = VAL[index];    IF data.server = XLibrarian.nullHandle AND command # open THEN      Put.Text[data.fileSW, "Sorry, no connection open.\n"L]    ELSE SELECT command FROM      open => Open[sw, item, index];      close => Close[sw, item, index];      validateAtoms => ValidateAtoms[sw, item, index];      makeAtoms => MakeAtoms[sw, item, index];      create => CreateLib[];      destroy => DestroyLib[];      out => CheckOut[];      in => CheckIn[];      set => Set[sw, item, index];      query => Query[sw, item, index];      ENDCASE => Put.Text[data.fileSW, "Librarian Test Tool Bug.\n"L];    END;  Open:  FormSW.ProcType =     BEGIN    db: XString.ReaderBody ¬ XS[data.database];    IF data.server # XLibrarian.nullHandle THEN Close[];    Put.Text[data.fileSW, "Opening connection to '"L];    Put.Text[data.fileSW, data.database];    Put.Text[data.fileSW, "' ..."L];    data.server ¬ XLibrarian.Open[@db, libZone];    Put.Line[data.fileSW, " done."L];    END;  Close:  FormSW.ProcType =    BEGIN    IF data.server = XLibrarian.nullHandle THEN {      Put.Text[data.fileSW, "No connection open.\n"L]; RETURN};    Put.Text[data.fileSW, "Closing connection ..."L];    XLibrarian.Close[data.server !      XLibrarian.Error => IF code = invalidHandle THEN CONTINUE];    data.server ¬ XLibrarian.nullHandle;    Put.Text[data.fileSW, " done.\n"L];    FOR i: NATURAL IN [0..itemLines) DO      data.items[i].atom ¬ XLibrarian.nullAtom;      ENDLOOP;    END;  ValidateAtoms:  FormSW.ProcType =    BEGIN    MakeAtoms[];    Put.Text[data.fileSW, "Checking atoms ... "L];    FOR i: NATURAL IN [0..itemLines) DO      item: FormSW.ItemHandle = FormSW.FindItem[data.itemSW, i*3];      IF ~String.Empty[data.items[i].tag] THEN {	tag: LONG STRING;	Put.Char[data.fileSW, '[];	Put.Text[data.fileSW, data.items[i].tag];	tag ¬ XLibrarian.GetPrintName[data.server, data.items[i].atom];	IF String.Equivalent[tag, data.items[i].tag] THEN	  Put.Text[data.fileSW, " ok] ... "]	ELSE {	  Put.Text[data.fileSW, " # ("L];	  Put.Text[data.fileSW, tag];	  Put.Text[data.fileSW, ")] ..."L];	libZone.FREE[@tag]}};      ENDLOOP;    Put.Text[data.fileSW, " done.\n"L];    END;  MakeAtoms:  FormSW.ProcType =    BEGIN    needMessage: BOOLEAN ¬ TRUE;    FOR i: NATURAL IN [0..itemLines) DO      item: FormSW.ItemHandle = FormSW.FindItem[data.itemSW, i*3];      IF String.Empty[data.items[i].tag] THEN        data.items[i].atom ¬ XLibrarian.nullAtom      ELSE IF data.items[i].atom = XLibrarian.nullAtom OR	      item.flags.modified THEN {	IF needMessage THEN {	  Put.Text[data.fileSW, "Making atoms ... "L]; needMessage ¬ FALSE};	Put.Text[data.fileSW, data.items[i].tag];	Put.Text[data.fileSW, " ... "L];	data.items[i].atom ¬ XLibrarian.MakeAtom[data.server, data.items[i].tag]};      item.flags.modified ¬ FALSE;      ENDLOOP;    IF ~needMessage THEN Put.Text[data.fileSW, " done.\n"L];    END;  CreateLib:  FormSW.ProcType = {    libj: NSString.String ¬ NSString.StringFromMesaString[data.libject];    xLibj: XString.ReaderBody ¬ XString.FromNSString[libj, TRUE];    Put.Text[data.fileSW, "Creating '"L];    Put.Text[data.fileSW, data.libject];    Put.Text[data.fileSW, "' ..."L];    XLibrarian.Create[data.server, @xLibj];    Put.Text[data.fileSW, " done.\n"L]};  DestroyLib:  FormSW.ProcType = {    libj: XString.ReaderBody ¬ XS[data.libject];    Put.Text[data.fileSW, "Destroying '"L];    Put.Text[data.fileSW, data.libject];    Put.Text[data.fileSW, "' ..."L];    XLibrarian.Destroy[data.server, @libj];    Put.Text[data.fileSW, " done.\n"L]};  CheckOut:  FormSW.ProcType = {    libj: XString.ReaderBody ¬ XS[data.libject];    Put.Text[data.fileSW, "Checking out '"L];    Put.Text[data.fileSW, data.libject];    Put.Text[data.fileSW, "' ..."L];    XLibrarian.CheckOut[data.server, @libj];    Put.Text[data.fileSW, " done.\n"L]};  CheckIn:  FormSW.ProcType = {    libj: XString.ReaderBody ¬ XS[data.libject];    Put.Text[data.fileSW, "Checking in '"L];    Put.Text[data.fileSW, data.libject];    Put.Text[data.fileSW, "' ..."L];    XLibrarian.CheckIn[data.server, @libj];    Put.Text[data.fileSW, " done.\n"L]};  Set:  FormSW.ProcType =    BEGIN    libj: XString.ReaderBody ¬ XS[data.libject];    pl: XLibrarian.PropertyList = XLibrarian.CreatePropertyList[libZone];    BEGIN ENABLE UNWIND => XLibrarian.DestroyPropertyList[pl];    MakeAtoms[];    FOR i: NATURAL IN [0..itemLines) DO      IF data.items[i].atom # XLibrarian.nullAtom THEN {	SELECT data.items[i].type FROM	  null => XLibrarian.AddProperty[pl, [data.items[i].atom, [null[]]]];	  time => {ENABLE Date.Unintelligible => ERROR ParseError[i];	    XLibrarian.AddTimeProperty[	      plist: pl,	      tag: data.items[i].atom,	      time: Date.StringToPacked[data.items[i].value].dt]};	  integer => {ENABLE String.InvalidNumber => ERROR ParseError[i];	    XLibrarian.AddIntegerProperty[	      plist: pl,	      tag: data.items[i].atom,	      integer: String.StringToLongNumber[data.items[i].value]]};	  client => ERROR ParseError[i];	  xString => {	    rb: XString.ReaderBody;	    IF data.items[i].value = NIL THEN ERROR ParseError[i];	    rb ¬ XS[data.items[i].value];	    XLibrarian.AddXStringProperty[	      plist: pl,	      tag: data.items[i].atom,	      string: @rb]};	  string => {	    IF data.items[i].value = NIL THEN ERROR ParseError[i];	    XLibrarian.AddStringProperty[	      plist: pl,	      tag: data.items[i].atom,	      string: data.items[i].value]};	  seq => ERROR ParseError[i];	  ENDCASE => --EXHAUSTED-- ERROR};      ENDLOOP;    Put.Text[data.fileSW, "Setting values for '"L];    Put.Text[data.fileSW, data.libject];    Put.Text[data.fileSW, "' ..."L];    XLibrarian.SetProperties[data.server, @libj, pl];    END; -- of ENABLE    Put.Text[data.fileSW, " done.\n"L];    XLibrarian.DestroyPropertyList[pl];    END;  ShowPList:  PROC [pl: XLibrarian.PropertyList] =    BEGIN    next: NATURAL ¬ 0;    ShowProperty: XLibrarian.PropertyEnumerator = {      AppendVal: Format.StringProc = {        String.AppendString[newVal, s ! String.StringBoundsFault => RESUME[NIL]]};      name: LONG STRING ¬ XLibrarian.GetPrintName[data.server, prop.tag];      newVal: LONG STRING = [50];      item: FormSW.ItemHandle = FormSW.FindItem[data.itemSW, next*3];      IF next >= itemLines THEN RETURN[TRUE];      FormSW.ModifyEditable[data.itemSW, next*3, 0, 9999, name, FALSE];      item.flags.modified ¬ FALSE;      libZone.FREE[@name];      WITH v: prop.value SELECT FROM	null => data.items[next].type ¬ null;	time => {	  data.items[next].type ¬ time;	  Format.Date[AppendVal, v.time, dateTime]};	integer => {	  data.items[next].type ¬ integer;	  Format.LongDecimal[AppendVal, v.integer]};	client => {	  data.items[next].type ¬ client;	  Format.Decimal[AppendVal, v.record.LENGTH];	  Format.Char[AppendVal, '[];	  FOR i: NATURAL IN [0..v.record.LENGTH) DO	    IF i # 0 THEN Format.Text[AppendVal, ", "L];	    Format.Octal[AppendVal, v.record[i]];	    ENDLOOP;	  Format.Char[AppendVal, ']]};	string => {	  data.items[next].type ¬ string;	  Format.Text[AppendVal, v.string]};	xString => {	  val: LONG STRING ¬ S[v.string, libZone];	  data.items[next].type ¬ xString;	  Format.Text[AppendVal, val];	  libZone.FREE[@val]};	strings => {	  data.items[next].type ¬ seq;	  Format.Decimal[AppendVal, v.strings.LENGTH];	  Format.Char[AppendVal, '[];	  FOR i: NATURAL IN [0..v.strings.LENGTH) DO	    IF i # 0 THEN Format.Text[AppendVal, ", "L];	    Format.Text[AppendVal, v.strings[i]];	    ENDLOOP;	  Format.Char[AppendVal, ']]};	ENDCASE;      FormSW.DisplayItem[data.itemSW, next*3+1];      FormSW.ModifyEditable[data.itemSW, next*3+2, 0, 9999, newVal, FALSE];      next ¬ next + 1;      RETURN[FALSE]};    XLibrarian.EnumerateProperties[pl, ShowProperty];    FOR i: NATURAL IN [next..itemLines) DO      item: FormSW.ItemHandle = FormSW.FindItem[data.itemSW, i*3];      FormSW.ModifyEditable[data.itemSW, i*3, 0, 9999, NIL, FALSE];      item.flags.modified ¬ FALSE;      data.items[i].type ¬ null;      FormSW.DisplayItem[data.itemSW, i*3+1];      FormSW.ModifyEditable[data.itemSW, i*3+2, 0, 9999, NIL, FALSE];      ENDLOOP;    END;  Query:  FormSW.ProcType =    BEGIN    libj: XString.ReaderBody ¬ XS[data.libject];    atoms: ARRAY [0..itemLines) OF XLibrarian.Atom;    pl: XLibrarian.PropertyList;    nextAtom: NATURAL ¬ 0;    start, stop: System.Pulses;    elapsed: LONG CARDINAL;    repeat: CARDINAL = IF data.queryCount = 0 THEN 1 ELSE data.queryCount;    MakeAtoms[];    FOR i: NATURAL IN [0..itemLines) DO      IF data.items[i].atom # XLibrarian.nullAtom THEN {        atoms[nextAtom] ¬ data.items[i].atom;	nextAtom ¬ nextAtom + 1};      ENDLOOP;    Put.Text[data.fileSW, "Querying '"L];    Put.Text[data.fileSW, data.libject];    Put.Text[data.fileSW, "' ..."L];    start ¬ System.GetClockPulses[];    FOR i: NATURAL IN (0..repeat] DO      pl ¬ XLibrarian.Query[        data.server, @libj, DESCRIPTOR[@atoms, nextAtom]].pl;      IF i = repeat THEN {        stop ¬ System.GetClockPulses[];	Put.Text[data.fileSW, " done.\n"L];        ShowPList[pl]};      XLibrarian.DestroyPropertyList[pl];      ENDLOOP;    elapsed ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    PutNumber[data.fileSW, "Elapsed time = "L, elapsed];    PutNumber[data.fileSW, "    Mean time = "L, elapsed/repeat];    Put.CR[data.fileSW];    END;    PutNumber: PROC [w: Window.Handle, s: LONG STRING, t: LONG CARDINAL] = {    Put.Text[w, s];    Put.LongDecimal[data.fileSW, t/1000];    Put.Char[data.fileSW, '.];    Put.LongNumber[w, t MOD 1000, [zerofill: TRUE, columns: 3]]};  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ myZone.NEW[Data ¬ []];      new = inactive =>        IF data # NIL THEN {	  myZone.FREE[@data]};      ENDCASE};  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [15];    Tool.UnusedLogName[unused: logName, root: "LibTestA.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.commandSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeCommands, zone: myZone];    data.itemSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeItems, zone: myZone];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName]};  MakeCommands: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = CommandItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems, myZone];    items[CommandItems.open.ORD] ¬ CommandItem[      tag: "Open"L, place: [0, line0], proc: CommandProc, z: myZone];    items[CommandItems.close.ORD] ¬ CommandItem[      tag: "Close"L, place: [48, line0], proc: CommandProc, z: myZone];    items[CommandItems.validateAtoms.ORD] ¬ CommandItem[      tag: "Validate Atoms"L, place: [108, line0], proc: CommandProc,      z: myZone];    items[CommandItems.makeAtoms.ORD] ¬ CommandItem[      tag: "Make Atoms"L, place: [204, line0], proc: CommandProc, z: myZone];    items[CommandItems.database.ORD] ¬ StringItem[      tag: "Database"L, place: [282, line0], inHeap: TRUE,      string: @data.database, z: myZone];    items[CommandItems.create.ORD] ¬ CommandItem[      tag: "Create"L, place: [0, line1], proc: CommandProc, z: myZone];    items[CommandItems.destroy.ORD] ¬ CommandItem[      tag: "Destroy"L, place: [48, line1], proc: CommandProc, z: myZone];    items[CommandItems.out.ORD] ¬ CommandItem[      tag: "Out"L, place: [114, line1], proc: CommandProc, z: myZone];    items[CommandItems.in.ORD] ¬ CommandItem[      tag: "In"L, place: [144, line1], proc: CommandProc, z: myZone];    items[CommandItems.set.ORD] ¬ CommandItem[      tag: "Set"L, place: [186, line1], proc: CommandProc, z: myZone];    items[CommandItems.query.ORD] ¬ CommandItem[      tag: "Query"L, place: [216, line1], proc: CommandProc, z: myZone];    items[CommandItems.libject.ORD] ¬ StringItem[      tag: "Libject"L, place: [282, line1], inHeap: TRUE,      string: @data.libject, z: myZone];    items[CommandItems.debugging.ORD] ¬ BooleanItem[      tag: "Debugging"L, place: [0, line2], switch: @data.debugging, z: myZone];    items[CommandItems.queryCount.ORD] ¬ NumberItem[      tag: "Query Count"L, signed: FALSE, notNegative:TRUE,      default: 1, value: @data.queryCount, z: myZone];    RETURN[items: items, freeDesc: TRUE];    };  MakeItems: FormSW.ClientItemsProcType = {    OPEN FormSW;    type: ARRAY[0..7) OF Enumerated ¬ [      ["null"L, 0], ["time"L, 1],      ["integer"L, 2], ["client"L, 3],      ["string"L, 4], ["xString"L, 5], ["sequence"L, 6]];    nItems: CARDINAL = itemLines*3;    items ¬ AllocateItemDescriptor[nItems, myZone];    FOR i: NATURAL IN [0..itemLines) DO      items[i*3 + 0] ¬ StringItem[	tag: "Atom"L, place: [0, LineN[i]], inHeap: TRUE, z: myZone,        string: @data.items[i].tag];      items[i*3 + 1] ¬ EnumeratedItem[	tag: "Type"L, place: [126, LineN[i]], choices: DESCRIPTOR[type],        z: myZone, value: @data.items[i].type];      items[i*3 + 2] ¬ StringItem[	tag: "Value"L, place: [228, LineN[i]], inHeap: TRUE, z: myZone,        string: @data.items[i].value];      ENDLOOP;    RETURN[items: items, freeDesc: TRUE]};  SubStringFromXString: PROCEDURE [r: XString.Reader]    RETURNS [sd: String.SubStringDescriptor] = {    chSetShift: BOOLEAN ¬ r.bytes[0]=377B;    sd ¬ [      base: LOOPHOLE[LOOPHOLE[r.bytes, LONG CARDINAL] - (IF chSetShift THEN 1 ELSE 2), LONG POINTER TO StringBody],      offset: r.offset,      length: r.limit - r.offset];     IF chSetShift THEN sd.length ¬ sd.length-2;  };    S: PROCEDURE [r: XString.Reader, z: UNCOUNTED ZONE] RETURNS [s: LONG STRING] = {    sd: String.SubStringDescriptor;    IF r=NIL THEN RETURN[NIL];    sd ¬ SubStringFromXString[r];    s ¬ z.NEW[StringBody [sd.length]];    String.AppendSubString[to: s, from: @sd]};      XS: PROCEDURE [s: LONG STRING] RETURNS [XString.ReaderBody] = {    RETURN[XString.FromSTRING[s, TRUE]]};      -- Initialization and Exec commands  Init: PROCEDURE = {    Exec.AddCommand[      name: "LibrarianTest.~"L, proc: MakeNewInstance, unload: Unload];    };  MakeNewInstance: Exec.ExecProc = {MakeOne[]};    Unload: Exec.ExecProc =    BEGIN    IF wh # NIL THEN {Tool.Destroy[wh]; wh ¬ NIL};    Exec.RemoveCommand[h, "LibrarianTest.~"L];    END;  MakeOne: PROCEDURE = {    IF wh=NIL THEN wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "Librarian Test"L,      cmSection: "LibTest"L, initialBox: [[0, 100], [512, 600]]]    ELSE IF ToolWindow.GetState[wh]=inactive THEN ToolWindow.Activate[wh]};  Init[];    END...  -- of LibrarianTest.mesa   LOG 26-Jul-84 15:53:21	DSC  	ProfileExtra is gone. Used GetID in new Profile 27-May-86 10:57:58	bjd  	converted to xstring Librarian.
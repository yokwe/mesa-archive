-- File: LibBCImpl.mesa - last edit:-- bjd                 12-Oct-87 16:39:37-- PLK    	30-Mar-84 15:28:18-- Copyright (C) 1985, 1986, 1987 by Xerox Corporation. All rights reserved.-- This module supports backward compatiblity for the Mesa 12.0 version of the librarian stub.DIRECTORY  Auth, Courier, Heap, Librarian, LibCourierSvc, LibMessages,  LibOps, LibServOps, NSFile, NSName, NSString, Runtime, String, System, XLibrarian, XString;LibBCImpl: PROGRAM  IMPORTS    Auth, Courier, XLibrarian, LibCourierSvc, LibMessages,    LibServOps, NSFile, NSName, NSString, Runtime, String, XString  EXPORTS XLibrarian  SHARES XString =  BEGIN  Service: TYPE = LONG POINTER TO ServiceObject;  ServiceObject: PUBLIC TYPE = LibServOps.ServiceObject;  SV: TYPE = LibServOps.SV;  Session: TYPE = LibCourierSvc.Session;  nullSession: Session = LibCourierSvc.nullSession;    gf: LONG POINTER TO LibServOps.GlobalFrame = @LibServOps.gf;  Sessions: TYPE = LibServOps.Sessions;  PropertyList: TYPE = LONG POINTER TO PropertyListObject;  PropertyListObject: PUBLIC TYPE = LibOps.PropertyListObject;  -- types from old version of librarian  Value: TYPE = Librarian.Value;  Property: TYPE = Librarian.Property;  Properties: TYPE = RECORD [    maxLength: CARDINAL,    props: LONG DESCRIPTOR FOR ARRAY OF Property];    Atom: TYPE = XLibrarian.Atom;  checkOutUser: Atom = LOOPHOLE[LibServOps.checkOutUser];-- procedures  ServiceForHandle: PROC [handle: XLibrarian.Handle]    RETURNS [Service] = {    WITH s: handle SELECT FROM      service => RETURN[s.service];      ENDCASE => ERROR XLibrarian.Error[implementationBug]};  SimpleCalls: TYPE = {create, destroy, out, in};  GetCalls: TYPE = {query, queryAndOut};  SetCalls: TYPE = {set, setAndIn};    Dispatcher: Courier.Dispatcher =    BEGIN    ENABLE {      Courier.Error => RaiseError[serviceUnavailable];      XLibrarian.Error => RaiseError[code];      NSFile.Error => IF error = [space[mediumFull]] THEN RaiseError[serviceFull]};    index: LibCourierSvc.RemoteProcedures;    IF procedureNumber ~IN [0..LibCourierSvc.RemoteProcedures.LAST.ORD] THEN      ERROR Courier.NoSuchProcedureNumber;    index ¬ VAL[procedureNumber];	-- can't do earlier because of potential bounds fault    SELECT index FROM      create => SimpleCall[create, cH, arguments, results];      destroy => SimpleCall[destroy, cH, arguments, results];      query => GetCall[query, cH, arguments, results];      checkOut => SimpleCall[out, cH, arguments, results];      checkIn => SimpleCall[in, cH, arguments, results];      setProperties => SetCall[set, cH, arguments, results];      queryAndCheckOut => GetCall[queryAndOut, cH, arguments, results];      setPropertiesAndCheckIn => SetCall[setAndIn, cH, arguments, results];      openDataBase => OpenDataBase[cH, arguments, results];      closeDataBase => CloseDataBase[cH, arguments, results];      makeAtom => MakeAtom[cH, arguments, results];      stringForAtom => StringForAtom[cH, arguments, results];      nextCheckedOut => NextLibject[cH, arguments, results];      ENDCASE;    END;  --Dispatcher      SimpleCall: PROC [    which: SimpleCalls, cH: Courier.Handle,    args: Courier.Arguments, res: Courier.Results] = {    sv: SV;    simple: SimpleArguments;    libject: XString.ReaderBody;    args[[@simple, DescribeSimpleArguments]];    sv ¬ LibServOps.SVForSession[simple.session, cH.remote, write, simple.verifier];    libject ¬ XS[simple.libject];    SELECT which FROM      create => XLibrarian.Create[[service[sv.serv]], @libject];      destroy => XLibrarian.Destroy[[service[sv.serv]], @libject];      in => XLibrarian.CheckIn[[service[sv.serv]], @libject];      out => XLibrarian.CheckOut[[service[sv.serv]], @libject];      ENDCASE;    [] ¬ res[[@sv.ver, Auth.DescribeVerifier]];    Courier.Free[      parameters: [@simple, DescribeSimpleArguments],      zone: gf.z];    Auth.FreeVerifier[@sv.ver, gf.z]};   OpenDataBase: PROC [    cH: Courier.Handle, args: Courier.Arguments, res: Courier.Results] =    BEGIN ENABLE Auth.AuthenticationError, Auth.CallError =>      RaiseError[authenticationFailure];    oa: OpenArguments;    or: OpenResults;    dataBase: XString.ReaderBody;    initiator: NSName.Name ¬ NSName.MakeName[gf.z];    service: Service;    args[[@oa, DescribeOpenArguments]];    dataBase ¬ XS[oa.dataBase];    or.replyVerifier ¬ Auth.Authenticate[      recipient: gf.serverId, credentialsToCheck: oa.cred, verifierToCheck: oa.verifier,      initiator: initiator, z: gf.z ! UNWIND => NSName.FreeName[gf.z, initiator]];    BEGIN ENABLE UNWIND => {      NSName.FreeName[gf.z, initiator];  Auth.FreeVerifier[@or.replyVerifier, gf.z]};    service ¬ ServiceForHandle[XLibrarian.Open[@dataBase, gf.z]];    or.session ¬ LibServOps.SessionForService[service];    service.client ¬ cH.remote;    service.user ¬ XStringFromNSName[initiator, gf.z];    IF LibServOps.TracingOn[] THEN {      db: NSString.String ¬ S[oa.dataBase];      user: NSString.String ¬ XString.NSStringFromReader[@service.user, gf.z];      message: NSString.String ¬ LibMessages.ExpandMsg[        z: gf.z, template: LibMessages.M[keyOpeningSession], s1: db, s2: user];      LibMessages.NoteEvent[message];      NSString.FreeString[gf.z, user];      NSString.FreeString[gf.z, message]};    service.access ¬ LibServOps.GetAccess[service.h, initiator, oa.cred];    service.credentials ¬ Auth.CopyCredentials[oa.cred, gf.z];    [] ¬ res[[@or, DescribeOpenResults]];    Courier.Free[      parameters: [@oa, DescribeOpenArguments],      zone: gf.z];    NSName.FreeName[gf.z, initiator];    Auth.FreeVerifier[@or.replyVerifier, gf.z];    END;    END;      CloseDataBase: PROC [    cH: Courier.Handle,args: Courier.Arguments, res: Courier.Results] =    BEGIN    sv: SV;    ca: CloseArguments;    args[[@ca, DescribeCloseArguments]];    sv ¬ LibServOps.SVForSession[ca.session, cH.remote, read, ca.verifier];    IF LibServOps.TracingOn[] THEN {      message: NSString.String;      user: NSString.String;      which: NATURAL = sv.serv.h.index;      user ¬ XString.NSStringFromReader[z: gf.z, r: @sv.serv.user];      message ¬ LibMessages.ExpandMsg[        gf.z, LibMessages.M[keyClosingSession], gf.dataBases[which].nameRoot, user];      LibMessages.NoteEvent[message];      NSString.FreeString[gf.z, user];      NSString.FreeString[gf.z, message]};    XLibrarian.Close[[service[sv.serv]]];    [] ¬ res[];    Courier.Free[      parameters: [@ca, DescribeCloseArguments],      zone: gf.z];    Auth.FreeVerifier[@sv.ver, gf.z];    Auth.FreeCredentials[@sv.serv.credentials, gf.z];    END;      MakeAtom: PROC [    cH: Courier.Handle,args: Courier.Arguments, res: Courier.Results] = {    sv: SV;    maa: LibCourierSvc.MakeAtomArguments;    mar: LibCourierSvc.MakeAtomResults;    args[[@maa, LibCourierSvc.DescribeMakeAtomArguments]];    sv ¬ LibServOps.SVForSession[maa.session, cH.remote, read, maa.verifier];    -- maybe this wants to be write, but the readers can't do much if    -- they can't make the atoms so that they can do the query.    mar ¬ [XLibrarian.MakeAtom[[service[sv.serv]], maa.tag], sv.ver];    [] ¬ res[[@mar, LibCourierSvc.DescribeMakeAtomResults]];    Courier.Free[      parameters: [@maa, LibCourierSvc.DescribeMakeAtomArguments],      zone: gf.z];    Auth.FreeVerifier[@sv.ver, gf.z]};      StringForAtom: PROC [    cH: Courier.Handle,args: Courier.Arguments, res: Courier.Results] = {    sv: SV;    gpna: LibCourierSvc.GetPrintNameArguments;    gpnr: LibCourierSvc.GetPrintNameResults;    args[[@gpna, LibCourierSvc.DescribeGetPrintNameArguments]];    sv ¬ LibServOps.SVForSession[gpna.session, cH.remote, read, gpna.verifier];    gpnr ¬ [XLibrarian.GetPrintName[[service[sv.serv]], gpna.tag], sv.ver];    [] ¬ res[[@gpnr, LibCourierSvc.DescribeGetPrintNameResults]];    Courier.Free[      parameters: [@gpna, LibCourierSvc.DescribeGetPrintNameArguments],      zone: gf.z];    Auth.FreeVerifier[@sv.ver, gf.z];    gf.z.FREE[@gpnr.s]};      NextLibject: PROC [    cH: Courier.Handle,args: Courier.Arguments, res: Courier.Results] = {    sv: SV;    next, current, mask, user: XString.ReaderBody;    ncoa: NextLibjectArguments;    ncor: NextLibjectResults;    args[[@ncoa, DescribeNextLibjectArguments]];    current ¬ XS[ncoa.current];    mask ¬ XS[ncoa.mask];    user ¬ XS[ncoa.user];    sv ¬ LibServOps.SVForSession[ncoa.session, cH.remote, read, ncoa.verifier];    next ¬ XLibrarian.NextLibject[      [service[sv.serv]], @current, @mask,      ncoa.onlyIfCheckedOut, @user];    ncor ¬ [StringFromXString[@next, gf.z], sv.ver];    [] ¬ res[[@ncor, DescribeNextLibjectResults]];    Courier.Free[      parameters: [@ncoa, DescribeNextLibjectArguments],      zone: gf.z];    gf.z.FREE[@ncor.next];    Auth.FreeVerifier[@sv.ver, gf.z];    XString.FreeReaderBytes[z: gf.z, r: @next]};      GetCall: PROC [    which: GetCalls, cH: Courier.Handle,    args: Courier.Arguments, res: Courier.Results] = {    sv: SV;    plist: PropertyList;    isCheckedOut: BOOLEAN ¬ TRUE;    getArgs: QueryArguments;    getRes: QueryResults;    libject: XString.ReaderBody;    args[[@getArgs, DescribeQueryArguments]];    libject ¬ XS[getArgs.libject];    sv ¬ LibServOps.SVForSession[getArgs.session, cH.remote, read, getArgs.verifier];    SELECT which FROM      query =>        [plist, isCheckedOut] ¬ XLibrarian.Query[	  [service[sv.serv]], @libject, getArgs.atoms];      queryAndOut =>	plist ¬ XLibrarian.QueryAndCheckOut[	  [service[sv.serv]], @libject, getArgs.atoms];      ENDCASE;    getRes ¬ [NewPropsToOldProps[plist.list, gf.z], isCheckedOut, sv.ver];    [] ¬ res[[@getRes, DescribeQueryResults]];    Courier.Free[      parameters: [@getArgs, DescribeQueryArguments],      zone: gf.z];    Auth.FreeVerifier[@sv.ver, gf.z];    XLibrarian.DestroyPropertyList[plist]};      SetCall: PROC [    which: SetCalls, cH: Courier.Handle,    args: Courier.Arguments, res: Courier.Results] = {    sv: SV;    plist: PropertyListObject;    setArgs: SetPropertiesArguments;    libject: XString.ReaderBody;    args[[@setArgs, DescribeSetPropertiesArguments]];    libject ¬ XS[setArgs.libject];    sv ¬ LibServOps.SVForSession[setArgs.session, cH.remote, write, setArgs.verifier];    plist ¬ [gf.z, OldPropsToNewProps[setArgs.plist]];    SELECT which FROM      set => XLibrarian.SetProperties[[service[sv.serv]], @libject, @plist];      setAndIn =>	XLibrarian.SetPropertiesAndCheckIn[	  [service[sv.serv]], @libject, @plist];      ENDCASE;    [] ¬ res[[@sv.ver, Auth.DescribeVerifier]];    Courier.Free[      parameters: [@setArgs, DescribeSetPropertiesArguments],      zone: gf.z];    Auth.FreeVerifier[@sv.ver, gf.z]};      OldPropsToNewProps: PROC [old: Properties]    RETURNS [new: LibOps.Properties] = INLINE {RETURN[LOOPHOLE[old]]};  NewPropsToOldProps: PROC [new: LibOps.Properties, z: UNCOUNTED ZONE]     RETURNS [old: Properties] = { -- change checkOutUser to a string if necessary    FOR i: NATURAL IN [0..new.props.LENGTH) DO      WITH newV: new.props[i].value SELECT FROM	null, time, client, string, strings, integer => NULL; 	xString => 	-- replace xString checkOutUser with a string	  IF new.props[i].tag=checkOutUser THEN {	    str: LONG STRING ¬ StringFromXString[newV.string, z];	    v: string XLibrarian.Value ¬ [string [str]];	    XString.FreeReaderBytes[newV.string, z];	    new.props[i] ¬ [checkOutUser, v]}	  ELSE RaiseError[illegalType];	xStrings => RaiseError[illegalType]; 	ENDCASE => RaiseError[illegalType];      ENDLOOP;    RETURN[LOOPHOLE[new]]};  RaiseError: PROC [why: XLibrarian.ErrorCode] = {    whyBC: Librarian.ErrorCode ¬ TranslateError[why];     IF why = implementationBug THEN      Runtime.CallDebugger["Service doesn't work."L];    ERROR Courier.SignalRemoteError[whyBC.ORD, Courier.nullParameters]};   TranslateError: PROC [why: XLibrarian.ErrorCode]    RETURNS [Librarian.ErrorCode] = INLINE {    RETURN [      SELECT why FROM        insufficientAccess => insufficientAccess,        invalidCredentials => authenticationFailure,        insufficientAuthentication => insufficientAuthentication,        authenticationFailure => authenticationFailure,        dataBaseNotFound => noSuchDataBase,        dataBaseUnavailable => dataBaseBusy,        serviceInaccessible => communicationError,        serviceNotFound => noSuchDataBase,        serviceUnavailable => communicationError,        libjectNotFound => noSuchLibject,        libjectCheckedOut => alreadyCheckedOut,        libjectAlreadyExists => libjectAlreadyExists,        libjectNotCheckedOut => notCheckedOut,        libjectNotCheckedOutToYou => notCheckedOutToYou,        invalidHandle => invalidHandle,        nameTooLong => nameTooLong,        reservedProperty => reservedProperty,        illegalType => illegalType,        noSuchAtom => noSuchAtom,        implementationBug => implementationBug,        serviceFull, libjectInconsistent, unknown => unknownError,	ENDCASE => unknownError]};  SubStringFromXString: PROCEDURE [r: XString.Reader]    RETURNS [sd: String.SubStringDescriptor] = {    chSetShift: BOOLEAN ¬ r.bytes[0]=377B;    IF (chSetShift AND r.bytes[1]#000B) THEN RaiseError[illegalType];  -- alternatively, i could just ship some sort of mesa string anyway;  the client would figure out that it's bogus;    IF r.limit=0 THEN RETURN[[base: NIL, offset: 0, length: 0]];    sd ¬ [      base: LOOPHOLE[LOOPHOLE[r.bytes, LONG CARDINAL] - (IF chSetShift THEN 1 ELSE 2), LONG POINTER TO StringBody],      offset: r.offset,      length: r.limit - r.offset];     IF chSetShift THEN sd.length ¬ sd.length-2;  };    StringFromXString: PROCEDURE [r: XString.Reader, z: UNCOUNTED ZONE]    RETURNS [s: LONG STRING] = {    sd: String.SubStringDescriptor;    IF r=NIL THEN RETURN[NIL];    sd ¬ SubStringFromXString[r];    s ¬ z.NEW[StringBody [sd.length]];    String.AppendSubString[to: s, from: @sd]};      XS: PROCEDURE [s: LONG STRING] RETURNS [XString.ReaderBody] = {    RETURN[XString.FromSTRING[s, TRUE]]};  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};      XStringFromNSName: PROC [name: NSName.Name, z: UNCOUNTED ZONE]    RETURNS [XString.ReaderBody] = {    s: NSString.String ¬ NSString.MakeString[      z: z, bytes: name.org.length+name.domain.length+name.local.length + 2];    s ¬ NSName.AppendNameToString[s, name];    RETURN[XString.FromNSString[s]]};  -- Courier stuff-- arguments and results to remote procedures  SimpleArguments: TYPE = RECORD [    session: Session,    verifier: Auth.Verifier,    libject: LONG STRING];  OpenArguments: TYPE = RECORD [    dataBase: LONG STRING,    cred: Auth.CredentialsHandle,    verifier: Auth.Verifier];  OpenResults: TYPE = RECORD [    session: Session,    replyVerifier: Auth.Verifier];  CloseArguments: TYPE = RECORD [    session: Session,    verifier: Auth.Verifier];  NextLibjectArguments: TYPE = RECORD [    session: Session,    verifier: Auth.Verifier,    current: LONG STRING,    mask: LONG STRING,    onlyIfCheckedOut: BOOLEAN,    user: LONG STRING];  NextLibjectResults: TYPE = RECORD [    next: LONG STRING,    replyVerifier: Auth.Verifier];  QueryArguments: TYPE = RECORD [    session: Session,    verifier: Auth.Verifier,    libject: LONG STRING,    atoms: XLibrarian.Atoms];  QueryResults: TYPE = RECORD [    plist: Properties,    isCheckedOut: BOOLEAN,    replyVerifier: Auth.Verifier];  SetPropertiesArguments: TYPE = RECORD [    session: Session,    verifier: Auth.Verifier,    libject: LONG STRING,    plist: Properties];-- describe the procedure records  DescribeSimpleArguments: PUBLIC Courier.Description = {    sa: LONG POINTER TO SimpleArguments =      notes.noteSize[SIZE[SimpleArguments]];    notes.noteParameters[@sa.verifier, Auth.DescribeVerifier];    notes.noteString[@sa.libject]};    DescribeOpenArguments: PUBLIC Courier.Description = {    oa: LONG POINTER TO OpenArguments =      notes.noteSize[SIZE[OpenArguments]];    notes.noteString[@oa.dataBase];    notes.noteParameters[@oa.cred, Auth.DescribeCredentials];    notes.noteParameters[@oa.verifier, Auth.DescribeVerifier]};    DescribeOpenResults: PUBLIC Courier.Description = {    or: LONG POINTER TO OpenResults =      notes.noteSize[SIZE[OpenResults]];    notes.noteParameters[@or.replyVerifier, Auth.DescribeVerifier]};    DescribeCloseArguments: PUBLIC Courier.Description = {    ca: LONG POINTER TO CloseArguments =      notes.noteSize[SIZE[CloseArguments]];    notes.noteParameters[@ca.verifier, Auth.DescribeVerifier]};    DescribeNextLibjectArguments: PUBLIC Courier.Description = {    ncoa: LONG POINTER TO NextLibjectArguments =      notes.noteSize[SIZE[NextLibjectArguments]];    notes.noteParameters[@ncoa.verifier, Auth.DescribeVerifier];    notes.noteString[@ncoa.current];    notes.noteString[@ncoa.mask];    notes.noteString[@ncoa.user]};    DescribeNextLibjectResults: PUBLIC Courier.Description = {    ncor: LONG POINTER TO NextLibjectResults =      notes.noteSize[SIZE[NextLibjectResults]];    notes.noteString[@ncor.next];    notes.noteParameters[@ncor.replyVerifier, Auth.DescribeVerifier]};    DescribeQueryArguments: PUBLIC Courier.Description = {    qa: LONG POINTER TO QueryArguments =      notes.noteSize[SIZE[QueryArguments]];    notes.noteParameters[@qa.verifier, Auth.DescribeVerifier];    notes.noteString[@qa.libject];    notes.noteArrayDescriptor[@qa.atoms, SIZE[Atom], LibCourierSvc.maxArrayLength]};    DescribeQueryResults: PUBLIC Courier.Description = {    qr: LONG POINTER TO QueryResults =      notes.noteSize[SIZE[QueryResults]];    notes.noteParameters[@qr.plist, DescribeProperties];    notes.noteParameters[@qr.replyVerifier, Auth.DescribeVerifier]};    DescribeSetPropertiesArguments: PUBLIC Courier.Description = {    spa: LONG POINTER TO SetPropertiesArguments =      notes.noteSize[SIZE[SetPropertiesArguments]];    notes.noteParameters[@spa.verifier, Auth.DescribeVerifier];    notes.noteString[@spa.libject];    notes.noteParameters[@spa.plist, DescribeProperties]};  DescribeProperties: PUBLIC Courier.Description =    BEGIN    refProps: LONG POINTER TO Properties =      notes.noteSize[SIZE[Properties]];    notes.noteDeadSpace[@refProps.props, 0];    notes.noteArrayDescriptor[      @refProps.props, SIZE[Property], LibCourierSvc.maxArrayLength];    FOR i: NATURAL IN [0..refProps.props.LENGTH) DO      notes.noteParameters[@refProps.props[i], DescribeProperty];      ENDLOOP;    END;    DescribeProperty: PUBLIC Courier.Description =    BEGIN    prop: LONG POINTER TO Property ¬ notes.noteSize[SIZE[Property]];    lengths: ARRAY [0..Librarian.PropertyType.LAST.ORD] OF CARDINAL ¬ [      SIZE[Value.null], SIZE[Value.time], SIZE[Value.client],      SIZE[Value.string], SIZE[Value.strings], SIZE[Value.integer],      SIZE[Value.spare6], SIZE[Value.spare7]];    notes.noteChoice[@prop.value.body, SIZE[Value], DESCRIPTOR[lengths]];    WITH val: prop.value SELECT FROM      null, spare6, spare7 => NULL;      time => notes.noteLongCardinal[LOOPHOLE[@val.time]];      integer => notes.noteLongInteger[@val.integer];      string => notes.noteString[@val.string];      client =>notes.noteArrayDescriptor[        @val.record, SIZE[WORD], LibCourierSvc.maxRecordSize];      strings => {        notes.noteArrayDescriptor[	  @val.strings, SIZE[LONG STRING], LibCourierSvc.maxStrings];	FOR i: NATURAL IN [0..val.strings.LENGTH) DO	  notes.noteString[@val.strings[i]];	  ENDLOOP};      ENDCASE;    END;  -- MAINLINE  Init: PROCEDURE = {    LibServOps.SetDispatcher[LibCourierSvc.lowVersion, Dispatcher]};      Init[];    END.  
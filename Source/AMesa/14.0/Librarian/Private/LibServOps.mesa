-- File: LibServOps.mesa - last edit:-- bjd                 19-Jan-88 15:48:49-- PLK    	 8-Apr-84 14:35:20-- DJW  	20-Nov-84 15:23:01-- Copyright (C) 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved.DIRECTORY  Auth, CH, Courier, Environment, File, LibCourierSvc, XLibrarian, NSExec,  NSFile, NSFileStream, NSName, NSString, Stream, System, XString, XStringHashTable;LibServOps: DEFINITIONS IMPORTS System =  BEGIN       -- shared variables  maxLibjectNameLength: NATURAL = XStringHashTable.maxNameLength;  maxTagLength: NATURAL = 250; -- Length of PName of any Atom (less than one byte)    gf: GlobalFrame;  -- the shared global frame for all the modules  GlobalFrame: TYPE = RECORD [    z: UNCOUNTED ZONE ¬ NIL,    status: NSExec.ClientStatus ¬ stopped,    clientCnt: CARDINAL ¬ 0,    tracing: BOOLEAN ¬ FALSE,    execId: NSExec.ClientID ¬ NSExec.nullClientID,    chConv: CH.ConversationHandle ¬ [NIL],    serverId: Auth.IdentityHandle ¬ NIL,    serviceName: NSName.Name ¬ NIL,    startId: CARDINAL ¬ 0,    fileSession: NSFile.Session ¬ NSFile.nullSession,    libDir, defaultLibDir: NSFile.Handle ¬ NSFile.nullHandle,    -- libDir opened within our session, defaultLibDir within default session    me: System.NetworkAddress ¬ System.nullNetworkAddress,    handles: LONG POINTER TO ServiceSequence ¬ NIL,    dataBases: LONG POINTER TO DataBaseSequence ¬ NIL];  -- data types    maxSessions: NATURAL = 40;  Sessions: TYPE = [0..maxSessions);  Strings: TYPE = LONG POINTER TO StringSequence;  StringSequence: TYPE = RECORD [    seq: SEQUENCE length: CARDINAL OF NSString.String];  DataBaseEntry: TYPE = LONG POINTER TO DataBaseEntryObject;  DataBaseEntryObject: TYPE = MONITORED RECORD [    h: DataBase ¬ NIL,    nReaders: CARDINAL ¬ 0,    status: {open, readerIn, writerIn} ¬ open,    tilUnlocked: CONDITION,    recoveryInProgress: BOOLEAN ¬ FALSE,    backupInProgress: BOOLEAN ¬ FALSE,    backupPath: NSString.String ¬ NSString.nullString,    backupVersionsToKeep: CARDINAL ¬ LAST[CARDINAL],    nameRoot: NSString.String ¬ NSString.nullString];  DataBaseSequence: TYPE = RECORD [    db: SEQUENCE length: NATURAL OF DataBaseEntryObject];      Atom: TYPE = RECORD [CARDINAL];  Access: TYPE = {read, write, administrator};  Time: TYPE = System.GreenwichMeanTime;  AtomHandle: TYPE = LONG POINTER TO AtomNode;  AtomNode: TYPE = RECORD [    pn: Atom,    left, right: AtomHandle ¬ NIL,    string: LONG STRING];      changeTime: Atom;  -- constant accross all services  checkOutUser: Atom;    ServiceSequence: TYPE = RECORD [    seq: SEQUENCE length: CARDINAL OF ServiceObject];  Service: TYPE = LONG POINTER TO ServiceObject;  ServiceObject: TYPE = RECORD [    allocated:   BOOLEAN     ¬ FALSE,    access:      Access      ¬ write,    h:           DataBase    ¬ NIL,    credentials: Auth.CredentialsHandle ¬ NIL,    client:      System.NetworkAddress ¬ System.nullNetworkAddress,    uid:         CARDINAL    ¬ 0,    user:        XString.ReaderBody ¬ XString.nullReaderBody,    lastUse:     Time        ¬ System.gmtEpoch];  -- a libject is the filed form of a property list; the TYPE of 'Property' shadows the definition in XLibrarian.mesa    ByteSpan: TYPE = RECORD [first, length: CARDINAL];  DefinedType: TYPE = XLibrarian.PropertyType[null..xStrings];  Bytes: TYPE = PACKED ARRAY [0..0) OF Environment.Byte;  CharsPointer: TYPE = LONG POINTER TO Chars;  Chars: TYPE = PACKED ARRAY [0..0) OF CHARACTER;  BytesPointer: TYPE = LONG POINTER TO Bytes;  LibjectBase: TYPE = LONG BASE POINTER TO LibjectHeader;  RelStringSeq: TYPE = RECORD [    val: SEQUENCE COMPUTED CARDINAL OF ByteSpan];  RelativeProperty: TYPE = MACHINE DEPENDENT RECORD [    pn(0): Atom,    value(1): PropertyValue];  PropertyValue: TYPE = MACHINE DEPENDENT RECORD [    body(0): SELECT type(0): DefinedType FROM      null => NULL,      time => [time(1): Time],      integer => [integer(1): LONG INTEGER],      client, string => [bytes(1): ByteSpan],      strings => [	count(1): CARDINAL,	bytes(2): LibjectBase RELATIVE POINTER TO RelStringSeq],      xString => [bytes(1): ByteSpan],      xStrings => [	count(1): CARDINAL,	bytes(2): LibjectBase RELATIVE POINTER TO RelStringSeq],    ENDCASE];  LibjectHeader: TYPE = RECORD [    bytes: LibjectBase RELATIVE POINTER TO Bytes,        -- points after the array of offsets    wasNameNowTrash: ByteSpan, -- this isn't used but kept for backward compat.    checkedOut: BOOLEAN,    count: NATURAL,    props: SEQUENCE COMPUTED CARDINAL OF RelativeProperty];    Run: TYPE = MACHINE DEPENDENT RECORD [    start: LONG CARDINAL,    length: CARDINAL];    DataBase: TYPE = LONG POINTER TO DataBaseObject;  DataBaseObject: TYPE = RECORD [    index: CARDINAL ¬ LAST[CARDINAL],    dirtyAtoms, dirtyFreePages, playingLog: BOOLEAN ¬ FALSE,    libjectPages, scratchLibjectPages: NATURAL,    header: LONG POINTER TO HeaderObject,    names: LONG POINTER TO AtomsObject ¬ NIL,    rootAtom: AtomHandle ¬ NIL,    freePages: LONG POINTER TO FreePagesObject ¬ NIL,    libject, scratchLibject: LibjectBase,    currentRun: Run ¬ [0, 0],    recordFile: NSFile.Handle,    pilotFile: File.File ¬ File.nullFile,    lpSize: LONG CARDINAL ¬ 0,    writers: NSName.Name ¬ NIL,    readers: NSName.Name ¬ NIL,    log: NSFileStream.Handle ¬ [NIL],    hashTable: XStringHashTable.Table ¬ NIL,    hashTableFile: NSFile.Handle ¬ NSFile.nullHandle];    maxCHNameLength: NATURAL = 100;  CHName: TYPE = MACHINE DEPENDENT RECORD [    length(0): CARDINAL ¬ 0,    bytes(1): PACKED ARRAY [0..maxCHNameLength) OF Environment.Byte ¬ TRASH];  headerRun: Run = [start: 0, length: 1];  thisVersion: CARDINAL = 02064;  -- mmDDy  HeaderObject: TYPE = MACHINE DEPENDENT RECORD [    freePages(0): Run,    names(3): Run,    fileLength(6): LONG CARDINAL,  -- in pages    currentlyUnused(8): CARDINAL ¬ 0,    records(9): LONG CARDINAL ¬ 0,    lastChange(11): Time,    dirty(13:0..0): BOOLEAN,    version(13:1..15): NATURAL ¬ thisVersion,    logLength(14): LONG CARDINAL ¬ 0,  -- how much of log is in this data base    minAuthentication(16): Auth.Flavor ¬ simple,    readers(17): CHName ¬ [],    writers(68): CHName ¬ [],    logLengthBackedUp(119): LONG CARDINAL ¬ 0,    backupPath(121): CHName ¬ [],    backupTime(172): Time ¬ System.gmtEpoch,    backupVersionsToKeep(174): CARDINAL ¬ LAST[CARDINAL],    unused(175): ARRAY [175..256) OF WORD ¬ ALL[0]];  checkHeader: BOOLEAN [TRUE..(SIZE[HeaderObject] = 256)] = TRUE;    RecordPlace: TYPE = MACHINE DEPENDENT RECORD [  -- stuck into hash tables    run: Run,    checkedOut: BOOLEAN,    properties: NATURAL];  <<  atoms are stored by having two bytes of the atom followed by one byte indicating the length of the string for that atom followed by length bytes. The next name starts at the next byte.>>  firstCharacterWord: NATURAL = 3;  AtomsObject: TYPE = MACHINE DEPENDENT RECORD [    freeByte(0): LONG CARDINAL,    count(2): CARDINAL,  -- number of entries    bytes(firstCharacterWord): PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte];    -- free pages run is always the last n pages of the file  Index: TYPE = CARDINAL;  nullIndex: Index = Index.LAST;  FreeSizes: TYPE = {    one, two, three, four, five, six, seven, eight, nine, ten,    fifteen, twenty, thirty, forty, fifty, sixty, seventy, eighty, ninety,    oneHundred, oneTwentyFive, oneFifty, oneSeventyFive, twoHundred, twoFifty};  FreeElement: TYPE = MACHINE DEPENDENT RECORD [    start: LONG CARDINAL,    next: Index];  FreePagesObject: TYPE = MACHINE DEPENDENT RECORD [    freeLists: ARRAY FreeSizes OF Index,    freeCell: Index,    tail: Run,    pages: CARDINAL,    activeCells: Index,    cells: SEQUENCE allCells: Index OF FreeElement];  -- some interesting procedures  Now: PROC RETURNS [Time] = INLINE {RETURN[System.GetGreenwichMeanTime[]]};  MakeUID: PROC RETURNS [CARDINAL];  Dispatcher: Courier.Dispatcher;  SetDispatcher: PROC [versionSupported: CARDINAL, proc: Courier.Dispatcher];  -- procs and types for the gf.handles lock;  SV: TYPE = RECORD [serv: Service, ver: Auth.Verifier];  EnumHandlesProc: TYPE = PROC [serv: Service]    RETURNS [continue: BOOLEAN ¬ TRUE];  SVForSession: PROC [    session: LibCourierSvc.Session, client: Courier.SystemElement,    access: Access, him: Auth.Verifier] RETURNS [sv: SV];  SessionForService: PROC [serv: Service] RETURNS [session: LibCourierSvc.Session];  EnumerateHandles: PROC [enumProc: EnumHandlesProc];  GetService: PROC RETURNS [Service];  GetAccess: PROC [h: DataBase, client: NSName.Name, creds: Auth.CredentialsHandle]    RETURNS [access: Access];    -- procs and types for the per database lock and the gf lock;  AccessType: TYPE = {read, write, backup, recover};  EntryProcType: TYPE = PROCEDURE [db: DataBaseEntry];   MonitorOperation: PROC [    proc: EntryProcType, access: AccessType, dbIndex: NATURAL];  MonitorGF: PROCEDURE [proc: PROCEDURE];  -- the following procs should all be called from within the per database lock;  StartDataBase: PROC [i: NATURAL];  GetDataBases: PROC RETURNS [Strings];  LoadDataBase: PROC [i: NATURAL];  UnloadDataBase: PROC [i: NATURAL];  RenameDataBase: PROCEDURE [    fromRoot, toRoot: NSString.String,    fromExt, toExt: NSString.String ¬ NSString.nullString]    RETURNS [ok: BOOLEAN ¬ TRUE];  DeleteDataBaseFiles: PROCEDURE [    root: NSString.String, ext: NSString.String ¬ NSString.nullString]    RETURNS [ok: BOOLEAN ¬ TRUE];  DestroyDataBase: PROCEDURE [database: NSString.String]    RETURNS [filesDeleted: NATURAL];  CreateDataBase: PROCEDURE [database: NSString.String]    RETURNS [created: BOOLEAN];  SACheckIn: PROCEDURE [database, libject: NSString.String, user: NSName.Name];  -- Can raise XLibrarian.Error[..., libjectNotFound, libjectNotCheckedOut, ...]   ReadBackupParameters: PROCEDURE [i: NATURAL]    RETURNS [path: NSString.String, versionsToKeep: CARDINAL];    AllocateRun: PROCEDURE [h: DataBase, length: CARDINAL] RETURNS [run: Run];  FreeRun: PROCEDURE [h: DataBase, run: Run];  GetSpace: PROCEDURE [pages: CARDINAL, swapSize: CARDINAL ¬ 0]    RETURNS [LONG POINTER];  FreeSpace: PROCEDURE [base: LONG POINTER];  Read: PROCEDURE [h: DataBase, run: Run, where: LONG POINTER];  Write: PROCEDURE [h: DataBase, run: Run, where: LONG POINTER];  ForceOut: PROCEDURE [h: DataBase];  IsDirty: PROCEDURE [h: DataBase];  MakeClean: PROCEDURE [h: DataBase];      EnterAtom: PROCEDURE [h: DataBase, tag: Atom, string: Environment.Block];  FreeAtoms: PROCEDURE [h: DataBase];    AddAtomToFile: PROCEDURE [    h: DataBase, service: Service, tag: Atom, pName: LONG STRING];-- logging information  LogType: TYPE = {create, destroy, checkOut, checkIn, setProperty, newAtom};    NoteTransaction: PROC [    h: DataBase, service: Service, why: LogType, libject: XString.Reader,    props: LONG DESCRIPTOR FOR ARRAY CARDINAL OF XLibrarian.Property ¬      DESCRIPTOR[NIL, 0],    pName: LONG STRING ¬ NIL];        -- playing the log (includes AddAtomToFile)  CreateLibject: PROC [h: DataBase, serv: Service, libject: XString.Reader];  DestroyLibject: PROC [h: DataBase, serv: Service, libject: XString.Reader];  CheckOutLibject: PROC [h: DataBase, serv: Service, libject: XString.Reader];  CheckInLibject: PROC [h: DataBase, serv: Service, libject: XString.Reader];  SetPropertiesForLibject: PROC [    h: DataBase, serv: Service, libject: XString.Reader,    pl: XLibrarian.PropertyList];  -- starting and stopping  StartUpService: PROCEDURE;  TakeDownService: PROCEDURE [stopMode: NSExec.StopMode];  StartFiles: PROCEDURE;  StopFiles: PROCEDURE;  InitDefaultLibDirectory: PROCEDURE;    StatusEqualTo: PROCEDURE [status: NSExec.ClientStatus]    RETURNS [BOOLEAN];  SetStatusTo: PROCEDURE [status: NSExec.ClientStatus];    TracingOn: PROCEDURE RETURNS [BOOLEAN];  FlipTracing: PROCEDURE;      END.  -- of LibServOps 
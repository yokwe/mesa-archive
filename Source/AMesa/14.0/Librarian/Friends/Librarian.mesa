-- Librarian.mesa - Last edited by:-- PXK    	 3-Apr-84  8:21:58-- Copyright (C) Xerox Corporation 1984. All rights reserved.DIRECTORY  Auth USING [IdentityHandle],  System USING [GreenwichMeanTime];  Librarian: DEFINITIONS =  BEGIN  -- TYPEs    Client: TYPE = LONG POINTER TO ClientObject;  ClientObject: TYPE;  Service: TYPE = LONG POINTER TO ServiceObject;  ServiceObject: TYPE;  Handle: TYPE = RECORD [    SELECT type: * FROM      client => [client: Client],      service => [service: Service]      ENDCASE];  nullHandle: Handle = [client[NIL]];<<	The fact that these 'Handle's are variant records should be ignored by	the clients. It happened this way because of some subtle technical	things having to do with trying to EXPORT the exact same interface	on both the client and service side of the Courier worlds. Just treat	them as ordinary 3 word opaque objects.>>    Atom: TYPE[1];  nullAtomRep: CARDINAL = 0;  nullAtom: Atom = LOOPHOLE[nullAtomRep];<<	An 'Atom' is used as the unique name (tag) for a property. 'Atom's are	obtained by calling 'MakeAtom'. It is important to note that an 'Atom'	is only valid within a single data base. The same print name might	have a different 'Atom' value in a different data base. There are two	reserved 'Atom's.		"CheckOutUser"	is the tag of a 'PropertyType.string' containing				the 3 part name of the last person to change				some libject. This has a non-null value even				if the libject is currently checked in.		"ChangeTime"	is the tag of a 'PropertyType.time' containing				the date and time of the last change made				to some libject. It is set on any 'CheckIn',				'CheckOut' or 'SetProperty' call.	The reason that 'Atom's exist at all is just because it is considerably	more efficient to do one word compares instead of String.Equivalent	when manipulating property lists on either the client side or in the	service side. It also gets away from the need to pass the string back	and forth on the wire.>>  Atoms: TYPE = LONG DESCRIPTOR FOR ARRAY OF Atom;<<	'Atoms' are what is passed in a 'Query' call>>  PropertyType: TYPE = MACHINE DEPENDENT {      -- order is important for Courier!!    null(0), time, client, string, strings, integer, spare6(6), spare7(7)};  Property: TYPE = MACHINE DEPENDENT RECORD [    tag(0): Atom,    value(1): Value];  Value: TYPE = MACHINE DEPENDENT RECORD [    body(0): SELECT type(0): PropertyType FROM      null => NULL,      time => [time(1): System.GreenwichMeanTime],      client => [record(1): Record],      string => [string(1): LONG STRING],      strings => [strings(1): Strings],      integer => [integer(1): LONG INTEGER],      spare6, spare7 => NULL,    ENDCASE];  Record: TYPE = LONG DESCRIPTOR FOR ARRAY OF WORD;  -- current maximum length is 1500. See 'LibCourier' for the truth  Strings: TYPE = LONG DESCRIPTOR FOR ARRAY OF LONG STRING;  -- current maximum length is 250. See 'LibCourier' for the truth  PropertyList: TYPE = LONG POINTER TO PropertyListObject;  -- maximum number of properties on any one list is currently 160.  -- Check the private interface 'LibOps' for the truth.  PropertyListObject: TYPE;    nullProperty: Property = [nullAtom, [null[]]];    -- PROCEDUREs ===========    Open: PROC [    dataBase: LONG STRING, user: Auth.IdentityHandle, zone: UNCOUNTED ZONE]    RETURNS [handle: Handle];<<	In the Tajo world, the IdentityHandle can be obtained from the	ProfileExtra interface. The zone is used to do all the Courier	allocation and deallocation. In addition, any Query against the	handle will return PropertyLists that have been allocated from it.>>  Close: PROC [Handle];    NextLibject: PROCEDURE [    handle: Handle, current: LONG STRING, mask: LONG STRING ¬ NIL,    onlyIfCheckedOut: BOOLEAN ¬ FALSE, user: LONG STRING ¬ NIL]    RETURNS [next: LONG STRING];<<	This gives the client a way of enumerating all the libjects in a given	data base. To start, current should be a NIL string. If 'mask' is non-nil,	then only libjects that pass a wild card equivalency filter will be	returned to the client. This uses the standard syntax where a '#' will	match any one character and a '*' will match any string of characters,	including the empty string.		If the 'onlyIfCheckedOut' boolean is TRUE, then only those libjects	that are checked out will be returned. The 'user' parameter is only	useful if 'onlyIfCheckedOut' is TRUE. In this case only those	libjects that are checked out to some specific user will be	returned. 'user' must be the 3 part name including the colon	separators.	It is the clients responsibility to free 'next' back to the same zone	that was passed into the Open call.>>  MakeAtom: PROCEDURE [handle: Handle, s: LONG STRING] RETURNS [Atom];<<	'MakeAtom' does the obvious thing.>>  GetPrintName: PROCEDURE [handle: Handle, tag: Atom] RETURNS [LONG STRING];<<	It is the clients responsibility to free the string returned by	'GetPrintName'. It is allocated from the same zone that was passed	in to create the 'Handle'.>>  -- Remote PropertyList Procedures  <<	The term libject is sometimes confused. The best way to think about	it is that each libject is a name property list residing within	some data base. Each of the properties on that list is tagged with	the name.	Having a libject checked out merely means that the user has exclusive	rights to change that remote property list. (You can't change if you	don't have the libject checked out. At most one user can have any	libject checked out at at time.	This has nothing to do with what files are checked out. There has	been some confusion over this issue for some time. Basically it is	up to the application to decide what it means to have anything other	than a libject checked out. Access, for instance, decided to map	having the libject checked out as the same thing as having current	ownership of some file as specified in some of the properties of	that libject. This is not to say that this is a bad thing to do. It	is just important to realize that this is not the only way to design	how an application is going to use the librarian.>>  Create: PROC [handle: Handle, libject: LONG STRING];<<	'Create' creates a libject of name 'libject' in the data base. The	libject is automatically considered checked out after 'Create'	succeeds. It is expected that the client is going to immediately	put on some application specific properties (and then probably	check it in).>>  Destroy: PROC [handle: Handle, libject: LONG STRING]; <<	'Destroy' removes 'libject' from it data base.>>  Query: PROC [handle: Handle, libject: LONG STRING, what: Atoms]    RETURNS [pl: PropertyList, isCheckedOut: BOOLEAN];<<	The property list returned only has values filled in for the	'Atom's that are in 'what'. If 'what' is of length zero, then	all the properties associated with that libject are returned.	If some tag in 'what' is not in 'libject', then the associated	property in 'pl' will have a type of 'null'.		'pl' is now owned by the client and must be destroyed explicitly	to prevent storage from being lost.		If all you want to know is if 'libject' is checked out, then pass	in 'what' containing something like MakeAtom[handle, "ChangeTime"L]>>  CheckOut: PROC [handle: Handle, libject: LONG STRING];<<	'CheckOut' checks out 'libject'. What this means is that the	user represented by the 'user' of the 'Open' call can change any	of the properties in the data base. No properties may be changed	without first checking out the libject.>>  CheckIn: PROC [handle: Handle, libject: LONG STRING];<<	'CheckIn' unlocks 'libject'.>>  SetProperties: PROC [handle: Handle, libject: LONG STRING, pl: PropertyList];<<	'SetProperties' only changes those properties of 'libject' that	are also in 'pl'. If necessary new properties are added to 'libject'.	If some property of 'pl' is of type 'null', then that property is	removed from 'libject'.		'pl' is still owned by the client and must be destroyed by him.>>  QueryAndCheckOut: PROC [    handle: Handle, libject: LONG STRING, what: Atoms]    RETURNS [pl: PropertyList];<<	'QueryAndCheckOut' does the obvious thing.>>  SetPropertiesAndCheckIn: PROC [    handle: Handle, libject: LONG STRING, pl: PropertyList];<<	'SetPropertiesAndCheckIn' does the obvious thing.>>    -- Local PropertyList Procedures  <<	These are the procedures that are used to manipulate the property	lists. Either those that are going to be used in calls to	'SetProperties' or those lists returned by 'Query' calls.>>  CreatePropertyList: PROC [z: UNCOUNTED ZONE] RETURNS [pl: PropertyList];<<	'CreatePropertyList' does the obvious thing.>>  CopyPropertyList: PROC [from: PropertyList] RETURNS [to: PropertyList];<<	'CopyPropertyList' is only here for completeness. I have no idea	what client needs it.>>  DestroyPropertyList: PROC [pl: PropertyList];<<	'DestroyPropertyList' does the obvious thing.>>  RemoveAllProperties: PROC [pl: PropertyList];<<	'RemoveAllProperties' removes all the properties from a property list.>><<	There is even a way to find out all the properties in a list. This	is especially useful if you don't know what 'Atom's are there because	you have just done a 'Query' with an empty 'Atoms' ARRAY.>>  PropertyEnumerator: TYPE = PROC [prop: Property]    RETURNS [done: BOOLEAN ¬ FALSE];  EnumerateProperties: PROC [pl: PropertyList, proc: PropertyEnumerator];    AddProperty: PROC [plist: PropertyList, prop: Property];<<	Assumes property value is already copied from correct zone (if it is	a property type that needs additional storage). This procedure will	not be called by most clients. They typically will use one of the	AddXXXProperty procedures below. Any old value (i.e. property with	the same tag) is returned to the zone from which the property list	was created. >>  GetProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [prop: Property];  -- returns [nullAtom, null[]] if tag not found  RemoveProperty: PROC [plist: PropertyList, tag: Atom];<<	The following procedures return discriminated values to the client.	No copying of the data is done, so the client must not free any of	the values returned. The values are only valid until a change	(AddXXXProperty or RemoveProperty) is made to the property list. For	instance, if a 'string' property was obtained, the next AddProperty	that changes that value will cause the string to be returned to its	zone.>>  GetTimeProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [System.GreenwichMeanTime];  GetRecordProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [Record];  GetStringProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [LONG STRING];  GetStringsProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [Strings];  GetIntegerProperty: PROC [plist: PropertyList, tag: Atom]    RETURNS [LONG INTEGER];<<	The following procedures add properties of some specific type to	a property list. If the property already exists (i.e. there is a	property on the list with the same tag) the new property replaces	the old one even if the types are not the same. For 'PropertyType's	of 'client', 'string' and 'strings', the parameters are copied into	the zone associated with the property list (either the one from	CreatePropertyList or from a call on 'Query' which uses the zone	passed into the 'Handle' creation). For example, it is legal to pass	some constant string into 'AddStringProperty'.>>  AddTimeProperty: PROC [    plist: PropertyList, tag: Atom, time: System.GreenwichMeanTime];  AddRecordProperty: PROC [    plist: PropertyList, tag: Atom,    record: Record];  AddStringProperty: PROC [    plist: PropertyList, tag: Atom, string: LONG STRING];  AddStringsProperty: PROC [    plist: PropertyList, tag: Atom,    strings: Strings];  AddIntegerProperty: PROC [    plist: PropertyList, tag: Atom, integer: LONG INTEGER];  -- SIGNALS and ERRORS<<	Only two errors are ever raised by calls into Librarian. The	generic 'Error' handles most of the cases by encoding the specific	fault into the 'code' parameter.		The client should UNWIND the call into the Librarian if a signal is	raised before calling in again. i.e. Don't make another call while	in the catch phrase.	'WrongPropertyType' is only raised by the GetXXXXProperty procedures when	the property asked for from some property list does not have a type	that matches what was asked for (or isn't there). This indicates that	multiple applications are using the same data base and have not come	to some understanding about what information they want to share.>>  Error: ERROR [code: ErrorCode];  ErrorCode: TYPE = MACHINE DEPENDENT {    implementationBug(0),    noSuchAtom,    serverDead, serverNotStarted, noConnectionsAvailable, noSuchDataBase,    authenticationFailure, insufficientAccess, insufficientAuthentication,    invalidHandle, dataBaseBusy,    alreadyCheckedOut, notCheckedOut, noSuchLibject, libjectAlreadyExists,    nameTooLong, nilZone, reservedProperty, illegalType, notCheckedOutToYou,    communicationError, unknownError};   StringForErrorCode: PROC [code: ErrorCode, s: LONG STRING];<<	This appends the appropriate error message onto 's'. Only as much as	will fit into 's' is actually appended. The client is protected from	seeing the String.StringBoundsFault, but no indication that the error	message has been truncated is given. Most of the error messages are	merely an expansion of 'code' with all the words capitalized and	spaces in between each word.>>  WrongPropertyType: ERROR;  END.
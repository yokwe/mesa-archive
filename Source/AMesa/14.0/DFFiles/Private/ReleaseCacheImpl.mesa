-- File: ReleaseCacheImpl.mesa - last edit:-- kam                 25-Oct-85 11:07:53-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Environment, File, Heap, Inline, MFile, ReleaseCache, Space, SpecialMFile, String, Time, Volume;ReleaseCacheImpl: PROGRAM  IMPORTS File, Heap, Inline, MFile, Space, SpecialMFile, String, Volume  EXPORTS ReleaseCache =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    NoRoom: PUBLIC ERROR = CODE;    EntryPointer: TYPE = LONG CARDINAL;    Entry: TYPE = MACHINE DEPENDENT RECORD [    next(0): EntryPointer,    version(2), nIfsPages(3): CARDINAL,    create(4): Time.Packed,    string(6): StringBody];    EntryMap: TYPE = LONG POINTER TO Entry;      pagesForTable: CARDINAL = 50;  maxHash: CARDINAL    = pagesForTable * Environment.wordsPerPage / SIZE[EntryPointer];  HashValue: TYPE = CARDINAL [0.. maxHash);    Hash: PROCEDURE [time: Time.Packed] RETURNS [HashValue] = {    RETURN[CARDINAL[Inline.UDDivMod[LOOPHOLE[time], maxHash].remainder]]};    firstEntry: EntryPointer = pagesForTable * Environment.wordsPerPage;  nullEntry: EntryPointer = 0;    Cache: TYPE = LONG POINTER TO CacheObject;  CacheObject: PUBLIC TYPE = RECORD [    table: LONG POINTER TO ARRAY HashValue OF EntryPointer,    mFile: MFile.Handle,    file: File.File,    fileSize: LONG CARDINAL,    mapped: LONG CARDINAL,    mappedAt: LONG POINTER,    nextToFill: EntryPointer];    Make: PUBLIC PROCEDURE [name: LONG STRING] RETURNS [Cache] =    BEGIN    cache: Cache ¬ z.NEW[CacheObject];    exists: BOOLEAN ¬ TRUE;    cache.mFile ¬ MFile.Acquire[name, anchor, [] ! MFile.Error => {      exists ¬ FALSE; CONTINUE}];    IF exists THEN MFile.SetAccess[cache.mFile, readWrite]    ELSE cache.mFile ¬ MFile.ReadWrite[name, [], binary];    cache.file ¬ SpecialMFile.GetCapaWithAccess[cache.mFile];    cache.mapped ¬ 0;    cache.mappedAt ¬ NIL;    IF exists THEN      BEGIN      cache.fileSize ¬ File.GetSize[cache.file];      cache.table ¬ Space.Map[[cache.file, 1, pagesForTable]].pointer;      cache.nextToFill ¬ cache.fileSize * Environment.wordsPerPage;      END    ELSE      BEGIN      File.SetSize[cache.file, pagesForTable + 1];      cache.fileSize ¬ pagesForTable + 1;      cache.table ¬ Space.Map[[cache.file, 1, pagesForTable]].pointer;      cache.nextToFill ¬ firstEntry;      FOR i: HashValue IN HashValue  DO cache.table[i] ¬ nullEntry ENDLOOP;      END;    RETURN[cache];    END;      Close: PUBLIC PROCEDURE [cache: Cache] =    BEGIN    page: LONG CARDINAL ¬ cache.nextToFill / Environment.wordsPerPage;    location: CARDINAL ¬ CARDINAL[      cache.nextToFill - page * Environment.wordsPerPage];    page ¬ page + (IF location = 0 THEN 1 ELSE 2);    cache.table ¬ Space.Unmap[cache.table];    IF cache.mappedAt # NIL THEN cache.mappedAt ¬ Space.Unmap[cache.mappedAt];    IF cache.fileSize # page THEN {      File.SetSize[cache.file, page]; cache.fileSize ¬ page};    MFile.SetLength[cache.mFile, Environment.bytesPerPage * (cache.fileSize - 1)];    MFile.Release[cache.mFile];    z.FREE[@cache];    END;    Lookup: PUBLIC PROCEDURE [    cache: Cache, host, directory, shortname: LONG STRING, create: Time.Packed]    RETURNS [inCache: BOOLEAN ¬ FALSE, version, nIfsPages: CARDINAL ¬ 0] =    BEGIN    hash: HashValue = Hash[create];    pointer: EntryPointer ¬ cache.table[hash];    entry: EntryMap ¬ NIL;    DO      IF pointer = nullEntry THEN RETURN;      entry ¬ DoMap[cache, pointer];      pointer ¬ entry.next;      IF Match[entry, host, directory, shortname, create]        THEN RETURN[TRUE, entry.version, entry.nIfsPages];      ENDLOOP;    END;    Insert: PUBLIC PROCEDURE [    cache: Cache, host, directory, shortname: LONG STRING, create: Time.Packed,    version, nIfsPages: CARDINAL] =    BEGIN    hash: HashValue = Hash[create];    pointer: EntryPointer ¬ cache.table[hash];    entry: EntryMap ¬ NIL;    count: CARDINAL = host.length + directory.length + shortname.length;    IF pointer = nullEntry THEN cache.table[hash] ¬ cache.nextToFill    ELSE DO      entry ¬ DoMap[cache, pointer];      IF Match[entry, host, directory, shortname, create] THEN RETURN;      IF entry.next = nullEntry THEN {entry.next ¬ cache.nextToFill; EXIT};      pointer ¬ entry.next;      ENDLOOP;    entry ¬ DoMap[cache, cache.nextToFill];    entry­ ¬ [      next: nullEntry, version: version, nIfsPages: nIfsPages,      create: create, string: [length: 0, maxlength: count, text:]];    String.AppendString[to: @entry.string, from: host];    String.AppendString[to: @entry.string, from: directory];    String.AppendString[to: @entry.string, from: shortname];    cache.nextToFill ¬ cache.nextToFill + SIZE[Entry] + (count + 1)/2;    END;    Enumerate: PUBLIC PROCEDURE [cache: Cache, user: ReleaseCache.UserProc] =    BEGIN    continue: BOOLEAN ¬ TRUE;    CallUser: PROCEDURE [e: EntryMap] = {      continue ¬ user[@e.string, e.create, e.version, e.nIfsPages]};    FOR h: HashValue IN HashValue WHILE continue DO      IF cache.table[h] # nullEntry THEN        BEGIN	entry: EntryMap ¬ DoMap[cache, cache.table[h]];	CallUser[entry];	WHILE entry.next # nullEntry AND continue DO	  CallUser[(entry ¬ DoMap[cache, entry.next])] ENDLOOP;	END;      ENDLOOP;     END;    DoMap: PROCEDURE [cache: Cache, pointer: EntryPointer]    RETURNS [map: EntryMap] =    BEGIN    page: LONG CARDINAL ¬ pointer / Environment.wordsPerPage;    location: CARDINAL ¬ CARDINAL[pointer - page * Environment.wordsPerPage];    IF pointer < firstEntry THEN ERROR;    page ¬ page + 1; -- page 0 is the leader page    IF cache.mappedAt # NIL THEN {      IF cache.mapped = page THEN RETURN[LOOPHOLE[cache.mappedAt + location]]      ELSE cache.mappedAt ¬ Space.Unmap[cache.mappedAt]};    IF cache.fileSize < page + 2 THEN {      File.SetSize[cache.file, page + 11        ! Volume.InsufficientSpace => ERROR NoRoom];	cache.fileSize ¬ page + 11};    cache.mappedAt ¬ Space.Map[[cache.file, page, 2]].pointer;    cache.mapped ¬ page;    RETURN[LOOPHOLE[cache.mappedAt + location]];    END;    Match: PROCEDURE [    map: EntryMap, host, directory, shortname: LONG STRING, create: Time.Packed]    RETURNS [BOOLEAN] =    BEGIN    hostSS: String.SubStringDescriptor ¬ [host, 0, host.length];    directorySS: String.SubStringDescriptor ¬ [directory, 0, directory.length];    nameSS: String.SubStringDescriptor ¬ [shortname, 0, shortname.length];    entrySS: String.SubStringDescriptor ¬ [@map.string, 0, 0];    IF map.create # create THEN RETURN[FALSE];    IF map.string.length # host.length + directory.length + shortname.length      THEN RETURN[FALSE];    entrySS.offset ¬ 0;    entrySS.length ¬ host.length;    IF NOT String.EquivalentSubStrings[@hostSS, @entrySS] THEN RETURN[FALSE];    entrySS.offset ¬ entrySS.offset + host.length;    entrySS.length ¬ directory.length;    IF NOT String.EquivalentSubStrings[@directorySS, @entrySS] THEN RETURN[FALSE];    entrySS.offset ¬ entrySS.offset + directory.length;    entrySS.length ¬ shortname.length;    IF NOT String.EquivalentSubStrings[@nameSS, @entrySS] THEN RETURN[FALSE];    RETURN[TRUE];    END;    END...
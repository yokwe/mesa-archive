-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- RStatsSupportImpl.mesa - Last edited by--   Schmidt	September 28, 1982 12:59 pm--   BTL  	15-Nov-83 11:11:11--   DSC  	 5-Dec-84 15:59:43DIRECTORY  CWF USING [SWF1, SWF2, SWF3, SWF4, WF1],  Date USING [Packed, StringToPacked, Unintelligible],  DFUser USING [CleanupEnumerate, EnumerateEntries, EnumerateProcType],  Exec USING [CheckForAbort, Handle],  Format USING [StringProc],  FQ USING [FileQuery, Result],  GSort USING [CompareProcType, GetProcType, PutProcType, Sort],  LeafSubr USING [Close, FileHandle, GetStreamCreation, Open],  MStream USING [Error, Handle, WriteOnly],  RStatsSupport USING [BcdDep, DFDep, DFRec, XRef],  Stream USING [Delete, Handle],  String USING [AppendChar, Compare],  Subr USING [FileError, SubStrCopy],  Time USING [Packed],  UserInput USING [UserAbort],  Window USING [Handle];RStatsSupportImpl: PROGRAM    IMPORTS      CWF, Date, DFUser, Exec, FQ, GSort, LeafSubr, MStream, Stream,      String, Subr, UserInput    EXPORTS RStatsSupport =  BEGIN OPEN RStatsSupport;    -- changing this may require changing RStatsImpl.ZonePages also  MaxFiles: CARDINAL ¬ 10000;  LeafOpenWithCreate: PUBLIC PROC [        host, directory, shortname: LONG STRING, version: CARDINAL,        createtime: Time.Packed]      RETURNS [fh: LeafSubr.FileHandle] = {    sfn: STRING ¬ [150];    IF version > 0 AND createtime = Time.Packed[0] THEN      CWF.SWF3[sfn, "<%s>%s!%u"L, directory, shortname, @version]    ELSE CWF.SWF2[sfn, "<%s>%s"L, directory, shortname];  -- this gets !H    fh ¬ LeafSubr.Open[host, sfn];    IF createtime # Time.Packed[0]    AND LeafSubr.GetStreamCreation[fh] # createtime THEN {      fres: FQ.Result;      remoteVersion: CARDINAL;      targetFileName: STRING ¬ [150];      LeafSubr.Close[fh];  fh ¬ NIL;      [fres: fres, remoteVersion: remoteVersion] ¬ FQ.FileQuery[        host: host, directory: directory, shortname: shortname,	version: version, createtime: createtime, wantExplicitVersion: FALSE,        targetFileName: targetFileName];      SELECT fres FROM        foundCorrectVersion => {          CWF.SWF3[sfn, "<%s>%s!%u"L, directory, shortname, @remoteVersion];          fh ¬ LeafSubr.Open[host, sfn]};        foundWrongVersion => ERROR Subr.FileError[wrongVersion];        notFound => ERROR Subr.FileError[notFound];        ENDCASE}};  BreakUp: PUBLIC PROC [      line, filename: LONG STRING] RETURNS [create: Time.Packed] = {    i: CARDINAL;    inbracket: BOOLEAN;    filename.length ¬ 0;  create ¬ Time.Packed[0];    i ¬ 0;    WHILE i < line.length DO      IF line[i] = '[ THEN inbracket ¬ TRUE;      IF line[i] = '] AND inbracket THEN inbracket ¬ FALSE;      IF ~inbracket AND line[i] = '  THEN EXIT;      String.AppendChar[filename, line[i]];      i ¬ i + 1;      ENDLOOP;    IF i < line.length THEN {  -- get create date      WHILE i < line.length DO        IF line[i] # '  THEN EXIT;	i ¬ i + 1;	ENDLOOP;      IF i >= line.length THEN RETURN;      Subr.SubStrCopy[sto: line, sfrom: line, sfinx: i];      create ¬ Date.StringToPacked[line ! Date.Unintelligible => CONTINUE].dt}};      -- code to read in DF files and produce a list of files  ComputeFileList: PUBLIC PROC [      dfFileName: LONG STRING, fileListName: LONG STRING,      window: Window.Handle, exec: Exec.Handle] = {    sh: MStream.Handle ¬ NIL;    line: STRING ¬ [200];        Put: Format.StringProc = {      sh.put[sH: sh, block: [LOOPHOLE[@s.text], 0, s.length], endRecord: FALSE]};    OneFile: DFUser.EnumerateProcType = {      IF window # NIL THEN {        IF UserInput.UserAbort[window] THEN ERROR ABORTED}      ELSE IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;      IF version > 0 THEN {        IF createTime > 0 THEN { 	  CWF.SWF4[line, "[%s]<%s>%s!%u "L, host, directory, shortName, @version];	  Put[line];	  CWF.SWF1[line, "%lt\n"L, @createTime]}	ELSE 	  CWF.SWF4[	    line, "[%s]<%s>%s!%u\n"L, host, directory, shortName, @version]}      ELSE {        IF createTime > 0 THEN 	  CWF.SWF4[	    line, "[%s]<%s>%s %lt\n"L, host, directory, shortName, @createTime]	ELSE	  CWF.SWF3[	    line, "[%s]<%s>%s\n"L, host, directory, shortName]};      Put[line]};    BEGIN ENABLE UNWIND => IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL};    sh ¬ MStream.WriteOnly[name: fileListName, release: [], type: text      ! MStream.Error => {          CWF.WF1["\nUnable to write list of files to %s\n"L, fileListName];	  CONTINUE}];    IF sh # NIL THEN {      DFUser.EnumerateEntries[        dfFileName: dfFileName, procToCall: OneFile,	nEntriesInDFFiles: MaxFiles,        confirmBeforeOverwriting: FALSE, printProgressMessages: TRUE,        window: window, exec: exec,        sortOption: byLongName, tryDollars: FALSE,	retrieveDFsToTemp: FALSE, localDFDir: NIL         ! UNWIND => DFUser.CleanupEnumerate[]];      Stream.Delete[sh];  sh ¬ NIL;      CWF.WF1["List of files written on %s.\n"L, fileListName];      DFUser.CleanupEnumerate[]};    END};  -- must be delimited by non-alphabetic chars  SubString: PUBLIC PROC [line, match: LONG STRING] RETURNS [is: BOOLEAN] = {    is ¬ FALSE;    FOR i: CARDINAL IN [0..line.length) DO      IF line[i] = match[0] AND i + match.length <= line.length THEN        FOR j: CARDINAL IN [0..match.length) DO          IF line[i + j] # match[j] THEN EXIT;          REPEAT            FINISHED => {              f: CARDINAL = (i - 1);  -- char before              l: CARDINAL = (i + match.length);  -- char after              IF (i = 0 OR ~(line[f] IN ['A..'Z] OR line[f] IN ['a..'z]))              AND                (l >= line.length OR ~(line[l] IN ['A..'Z] OR line[l] IN ['a..'z]))		THEN RETURN[TRUE]};          ENDLOOP;      ENDLOOP};        	  UniqueSortDFRec: PUBLIC PROC [oldList: DFRec] RETURNS [newList: DFRec] = {    next, last: DFRec;    SortKey: TYPE = LONG POINTER TO SortKeyObject;    SortKeyObject: TYPE = RECORD[dfRec: DFRec];        OutputUnsorted: GSort.GetProcType = {      key: SortKey = p;      IF next = NIL THEN RETURN[0]  -- no entries remain      ELSE {        key­ ¬ SortKeyObject[dfRec: next];  next ¬ next.rest;        RETURN[SIZE[SortKeyObject]]}};        Compare: GSort.CompareProcType = {      k1: SortKey = p1;      k2: SortKey = p2;      RETURN[CompareDFRecs[k1.dfRec, k2.dfRec]]};          InsertSorted: GSort.PutProcType = {      key: SortKey = p;      d: DFRec = key.dfRec;      IF last = NIL THEN {newList ¬ last ¬ d;  last.rest ¬ NIL} -- first in list      ELSE IF CompareDFRecs[last, d] # 0 THEN {  -- insert new entry	last.rest ¬ d;  last ¬ d;  last.rest ¬ NIL}};        next ¬ oldList;  newList ¬ last ¬ NIL;    GSort.Sort[      get: OutputUnsorted, put: InsertSorted, compare: Compare,      expectedItemSize: SIZE[SortKeyObject],      maxItemSize: SIZE[SortKeyObject], pagesInHeap: 120]};      CompareDFRecs: PROC [d1, d2: DFRec] RETURNS [compare: INTEGER] = {    compare ¬ CompareStrings[d1.shortname, d2.shortname];    IF compare = 0 THEN   -- shortnames equal      compare ¬ CompareStrings[d1.directory, d2.directory]};        CompareStrings: PROC [s1, s2: LONG STRING] RETURNS [compare: INTEGER] = {    IF s1 = NIL AND s2 = NIL THEN compare ¬ 0    ELSE IF s1 = NIL THEN compare ¬ -1    ELSE IF s2 = NIL THEN compare ¬  1     ELSE compare ¬ String.Compare[s1, s2]};        UniqueSortDFDep: PUBLIC PROC [oldList: DFDep] RETURNS [newList: DFDep] = {    next, last: DFDep;    SortKey: TYPE = LONG POINTER TO SortKeyObject;    SortKeyObject: TYPE = RECORD[dfDep: DFDep];        OutputUnsorted: GSort.GetProcType = {      key: SortKey = p;      IF next = NIL THEN RETURN[0]  -- no entries remain      ELSE {        key­ ¬ SortKeyObject[dfDep: next];  next ¬ next.rest;        RETURN[SIZE[SortKeyObject]]}};        Compare: GSort.CompareProcType = {      k1: SortKey = p1;      k2: SortKey = p2;      RETURN[CompareDFDeps[k1.dfDep, k2.dfDep]]};        CompareDFDeps: PROC [d1, d2: DFDep] RETURNS [compare: INTEGER] = {      compare ¬ CompareStrings[d1.shortname, d2.shortname];      IF compare = 0 THEN {  -- shortnames equal         IF d1.createtime # Time.Packed[0] THEN          compare ¬ (            IF d1.createtime < d2.createtime THEN -1            ELSE IF d1.createtime = d2.createtime THEN 0 ELSE 1)        ELSE compare ¬ CompareStrings[d1.directory, d2.directory]}};          InsertSorted: GSort.PutProcType = {      key: SortKey = p;      d: DFDep = key.dfDep;      IF last = NIL THEN {newList ¬ last ¬ d;  last.rest ¬ NIL} -- first in list      ELSE IF CompareDFDeps[last, d] # 0 THEN {  -- insert new entry	last.rest ¬ d;  last ¬ d;  last.rest ¬ NIL}};        next ¬ oldList;  newList ¬ last ¬ NIL;    GSort.Sort[      get: OutputUnsorted, put: InsertSorted, compare: Compare,      expectedItemSize: SIZE[SortKeyObject],      maxItemSize: SIZE[SortKeyObject], pagesInHeap: 120]};        SortXRef: PUBLIC PROC [oldList: XRef] RETURNS [newList: XRef] = {    next, last: XRef;    SortKey: TYPE = LONG POINTER TO SortKeyObject;    SortKeyObject: TYPE = RECORD[xref: XRef];        OutputUnsorted: GSort.GetProcType = {      key: SortKey = p;      IF next = NIL THEN RETURN[0]  -- no entries remain      ELSE {        key­ ¬ SortKeyObject[xref: next];  next ¬ next.rest;        RETURN[SIZE[SortKeyObject]]}};        Compare: GSort.CompareProcType = {      k1: SortKey = p1;      k2: SortKey = p2;      RETURN[CompareXRefs[k1.xref, k2.xref]]};          InsertSorted: GSort.PutProcType = {      key: SortKey = p;      d: XRef = key.xref;      IF last = NIL THEN {newList ¬ last ¬ d;  last.rest ¬ NIL} -- first in list      ELSE {        last.rest ¬ d;  last ¬ d;  last.rest ¬ NIL}};        next ¬ oldList;  newList ¬ last ¬ NIL;    IF oldList # NIL THEN       GSort.Sort[        get: OutputUnsorted, put: InsertSorted, compare: Compare,        expectedItemSize: SIZE[SortKeyObject],        maxItemSize: SIZE[SortKeyObject], pagesInHeap: 120]};              CompareXRefs: PROC [d1, d2: XRef] RETURNS [compare: INTEGER] = {    compare ¬ CompareStrings[d1.shortname, d2.shortname];    IF compare = 0 THEN      compare ¬ CompareStrings[d1.dfshortname, d2.dfshortname]};        UniqueSortBcdDep: PUBLIC PROC [oldList: BcdDep] RETURNS [newList: BcdDep] = {    next, last: BcdDep;    SortKey: TYPE = LONG POINTER TO SortKeyObject;    SortKeyObject: TYPE = RECORD[bcddep: BcdDep];        OutputUnsorted: GSort.GetProcType = {      key: SortKey = p;      IF next = NIL THEN RETURN[0]  -- no entries remain      ELSE {        key­ ¬ SortKeyObject[bcddep: next];  next ¬ next.rest;        RETURN[SIZE[SortKeyObject]]}};        Compare: GSort.CompareProcType = {      k1: SortKey = p1;      k2: SortKey = p2;      RETURN[CompareBcdDeps[k1.bcddep, k2.bcddep]]};        CompareBcdDeps: PROC [d1, d2: BcdDep] RETURNS [compare: INTEGER] = {      compare ¬ CompareDFRecs[d1.dfrec, d2.dfrec];      IF compare = 0 THEN compare ¬ CompareStrings[d1.bcdName, d2.bcdName]};          InsertSorted: GSort.PutProcType = {      key: SortKey = p;      d: BcdDep = key.bcddep;      IF last = NIL THEN {newList ¬ last ¬ d;  last.rest ¬ NIL}  -- first in list      ELSE IF CompareBcdDeps[last, d] # 0 THEN {  -- insert new entry	last.rest ¬ d;  last ¬ d;  last.rest ¬ NIL}};        next ¬ oldList;  newList ¬ last ¬ NIL;    GSort.Sort[      get: OutputUnsorted, put: InsertSorted, compare: Compare,      expectedItemSize: SIZE[SortKeyObject],      maxItemSize: SIZE[SortKeyObject], pagesInHeap: 120]}; 	          END. 5-Dec-84 15:59:48	DSC  	Allowed spaces in names for BreakUp.
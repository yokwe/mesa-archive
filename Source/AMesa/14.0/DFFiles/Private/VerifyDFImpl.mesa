-- File: VerifyDFImpl.mesa - last edit:-- kam                 18-Dec-85 11:56:10-- Schmidt             11-Mar-82 11:35:56-- BTL                 15-Nov-83 14:57:49-- NSG                 19-Jul-84 16:40:25  -- DSC                 12-Feb-86 13:07:38  -- Copyright (C) 1982, 1983, 1984, 1985, 1986 by Xerox Corporation. All rights reserved. DIRECTORY  BcdDefs USING [    CTIndex, CTNull, FTIndex, NameRecord, NullName, VersionID, VersionStamp],  BcdOps USING [    BcdBase, CTHandle, FTHandle, MTHandle, NameString, ProcessConfigs,    ProcessFiles],  BootFile USING [    currentVersion, Header, maxEntriesPerHeader, maxEntriesPerTrailer,    MemorySizeToFileSize],  CWF USING [SWF2, SWF3, SWF4, WF0, WF1, WF2, WF3, WF4, WFCR],  DFSubr USING [    AllocateDFSeq, DF, DFSeq, FlattenDF, FreeDFSeq, InsertCRs, LookupDF,    LookupFiles, NextDF, SortByFileName, StripLongName, WriteOut],  Environment USING [bytesPerPage, PageCount, wordsPerPage],  Exec USING [Handle],  FileName USING [AllocVFN, Error, FreeVFN, GetRemoteName, VFN],  FileTransfer USING [DesiredProperties, Error, ErrorCode, FileInfo, GetStreamInfo, ListProc],  LeafSubr USING [Close, FileHandle, GetStreamCreation, Open, RemoteMap],  MFile USING [    Acquire, Delete, Error, GetCreateDate, Handle, maxNameLength,    ReadOnly, Release, SetAccess],  MSegment USING [Address, CopyIn, Create, Delete, Handle],  MStream USING [Error, GetFile, GetLength, Handle, ReadOnly, WriteOnly],  ProcBcds USING [    InnardsObject, InstallAddressesBcd, InvalidBcd, PrintDepends, ProcDep,    ProcMod, ReadInSegmentsBcd, UnstallBcd],  Stream USING [Delete, EndOfStream, GetBlock, Handle],  String USING [    AppendString, AppendSubString, Empty, Equivalent,     InvalidNumber, StringToDecimal, SubString, SubStringDescriptor],  Subr USING [    AllocateString, Any, CopyString, debugflg, EndsIn, errorflg,    FileError, FreeString, localDFDir, LongZone],  Time USING [Packed],  Transfer USING [EnumerateForProperties, EnumerateForRetrieve, RetrieveProcType, SetDefaultProcs, SetProps],  VerifyDFInterface USING [CheckAbortProc, Options],  Window USING [Handle];VerifyDFImpl: MONITOR    IMPORTS      BcdOps, BootFile, CWF, DFSubr, FileName, FileTransfer, LeafSubr,      MFile, MSegment, MStream, ProcBcds, Stream, String, Subr, Transfer    EXPORTS VerifyDFInterface =  BEGIN    IncompatibleBootFileVersion: ERROR = CODE;  MaxFiles: CARDINAL = 1000;  MaxMissingFiles: CARDINAL = 200;  accessDenied: FileTransfer.ErrorCode = FileTransfer.ErrorCode[accessDenied];    nowRunning: BOOLEAN ¬ FALSE;  checkAbort: VerifyDFInterface.CheckAbortProc;     -- VerifyDF serialization   AlreadyRunning: PUBLIC ENTRY PROC RETURNS [yes: BOOLEAN] = {    IF nowRunning THEN RETURN[TRUE];    nowRunning ¬ TRUE;    RETURN[FALSE]};    DoneRunning: PUBLIC ENTRY PROC = {nowRunning ¬ FALSE}; -- Main verification procedure    VerifyDFFile: PUBLIC PROC [      dfFileName: LONG STRING,      exec: Exec.Handle, window: Window.Handle,      opt: VerifyDFInterface.Options,       abortProc: VerifyDFInterface.CheckAbortProc] = {    dfSeq, dfSeqOther: DFSubr.DFSeq ¬ NIL;    goAround, readOnlyFile, oldNeed, oldEval: BOOLEAN;    df: DFSubr.DF;    analyzed: BOOLEAN ¬ FALSE;    dfZone: UNCOUNTED ZONE ¬ Subr.LongZone[];    Cleanup: PROC = {DFSubr.FreeDFSeq[@dfSeq];  DFSubr.FreeDFSeq[@dfSeqOther]; Transfer.SetDefaultProcs[];};    BEGIN ENABLE UNWIND => Cleanup[];    -- For verify DF, avoid looking up size information from    -- file transfer's FileInfo object since that is not    -- placed in the cache and that info is not used except    -- during boot file verifies.    -- This is restored in Transfer.SetDefaultProcs    -- during         SetSizeLessProps[];        checkAbort ¬ abortProc;    dfSeq ¬ DFSubr.AllocateDFSeq[      maxEntries: MaxFiles, zoneType: (IF opt.useHugeZone THEN huge ELSE shared)];    dfSeqOther ¬ DFSubr.AllocateDFSeq[      maxEntries: MaxMissingFiles, zoneType: shared];    IF dfFileName.length > 0 THEN {      IF ~Subr.Any[dfFileName, '.] THEN        String.AppendString[dfFileName, ".df"L];      IF opt.verbose THEN CWF.WF1[        "\nReading %s and the DF files it Imports and Includes.\n"L, dfFileName];      DFSubr.FlattenDF[        dfseq: dfSeq, dffilename: dfFileName,	exec: exec, window: window,        defaultUserName: NIL, defaultUserPassword: NIL,	setRecorder:		TRUE,        checkForOverwrite:	opt.checkForOverwrite,	printStatus:		Subr.debugflg,	retrieveDFsToTemp:	opt.retrieveDFsToTemp,	localDFDir:		Subr.localDFDir];      IF dfSeq.size = 0 THEN GOTO leave};    IF opt.printFlattened THEN PrintFlattenedDFFile[dfFileName, dfSeq];    -- now analyze the BCD: the algorithm used is as follows:    -- initally all .need flags are FALSE, all .eval flags are FALSE    -- for each file we discover, the corresponding .need flag is set to TRUE    -- on the next goaround, a file is analyzed if .need = TRUE and .eval = FALSE    -- after analysis, the .eval flag is set to TRUE (by MarkEntryEvaluated)    goAround ¬ TRUE;    FOR i: CARDINAL IN [0..dfSeq.size) DO      IF checkAbort[] THEN ERROR ABORTED;      df ¬ @dfSeq[i];      IF df.topmark THEN         IF Subr.EndsIn[df.shortname, ".bcd"L] THEN {	  oldNeed ¬ df.need;  df.need ¬ TRUE;  	  oldEval ¬ df.eval;  df.eval ¬ FALSE;          readOnlyFile ¬ AnalyzeBcd[df.shortname, dfSeq, dfSeqOther, opt.verbose];	  -- back out if file was readOnly	  IF readOnlyFile THEN {df.need ¬ oldNeed;  df.eval ¬ oldEval}	  ELSE {MarkEvaluated[df, dfSeq];  analyzed ¬ TRUE}}	ELSE IF Subr.EndsIn[df.shortname, ".boot"L] THEN {	  oldNeed ¬ df.need;  df.need ¬ TRUE;  	  oldEval ¬ df.eval;  df.eval ¬ FALSE;	  	  -- need to look at sizes	  Transfer.SetDefaultProcs[];	  	  -- back out if file was readOnly          readOnlyFile ¬ AnalyzeBootFile[	    df.shortname, dfSeq, dfSeqOther, opt.verbose];	    	  SetSizeLessProps[];	  IF readOnlyFile THEN {df.need ¬ oldNeed;  df.eval ¬ oldEval}	  ELSE {MarkEvaluated[df, dfSeq];  analyzed ¬ TRUE}}	ELSE {  -- allow, e.g., .cm files to be marked as "necessary"	  df.need ¬ df.eval ¬ TRUE};      ENDLOOP;    IF ~analyzed THEN {      CWF.WF1["Error - no '+' entries in %s.\n"L, dfFileName];      Subr.errorflg ¬ TRUE;  RETURN};    WHILE goAround DO      goAround ¬ FALSE;      FOR i: CARDINAL IN [0..dfSeq.size) DO        df ¬ @dfSeq[i];        IF ~df.eval AND df.need THEN {          IF Subr.EndsIn[df.shortname, ".bcd"L]	  OR ~Subr.Any[df.shortname, '.] THEN            [] ¬ AnalyzeBcd[df.shortname, dfSeq, dfSeqOther, opt.verbose];          MarkEvaluated[df, dfSeq];          goAround ¬ TRUE;          IF checkAbort[] THEN ERROR ABORTED};        ENDLOOP;      ENDLOOP;    CheckReadOnlyFiles[dfSeq, opt.verbose];    CheckForCommonBlunders[dfSeq];    IF dfSeqOther.size = 0 THEN CWF.WF0["\nNo files were omitted.\n"L]    ELSE PrintMissingFiles[dfFileName, dfSeqOther, opt.fileForMissingEntries];    IF opt.checkIfFilesNeeded THEN PrintUnnecessaryFiles[dfSeq];    EXITS leave => NULL;    END;    Cleanup[]};      PrintFlattenedDFFile: PROC [dfFileName: LONG STRING, dfSeq: DFSubr.DFSeq] = {    shortname: STRING ¬ [MFile.maxNameLength];    sfn: STRING ¬ [MFile.maxNameLength];    sh: MStream.Handle ¬ NIL;    [] ¬ DFSubr.StripLongName[      fullname: dfFileName, host: NIL, directory: NIL, short: shortname];    IF shortname.length > 0 THEN {      String.AppendString[sfn, shortname];      sfn.length ¬ sfn.length-2;  -- remove "df" extension      String.AppendString[sfn, "flattened"L]}    ELSE String.AppendString[sfn, "DF.flattened"L];    sh ¬ MStream.WriteOnly[sfn, [], text      ! MStream.Error => {	  CWF.WF1["Unable to write flattened DF file to %s.\n"L, sfn];	  CONTINUE}];    IF sh # NIL THEN {      DFSubr.WriteOut[        dfseq: dfSeq, topLevelFile: NIL, outputStream: sh, print: FALSE];      Stream.Delete[sh];      CWF.WF1["Flattened DF file written on %s.\n"L, sfn]}};        PrintMissingFiles: PROC [      dfFileName: LONG STRING, dfSeqOther: DFSubr.DFSeq,      fileForMissingEntries: BOOLEAN] = {    sfn: STRING ¬ [MFile.maxNameLength];    sh: MStream.Handle ¬ NIL;    CleanUp: PROC = {IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL}};    BEGIN ENABLE UNWIND => CleanUp[];    CWF.WF0["\nMissing Entries:\n"L];    [] ¬ DFSubr.StripLongName[      fullname: dfFileName, host: NIL, directory: NIL, short: sfn];    IF sfn.length > 0 THEN {      sfn.length ¬ sfn.length-2;  -- remove "df" extension      String.AppendString[sfn, "missing"L]}    ELSE String.AppendString[sfn, "DF.missing"L];    sh ¬ MStream.WriteOnly[sfn, [], text      ! MStream.Error => {          CWF.WF1["Unable to write missing DF entries to %s.\n"L, sfn];          CONTINUE}];    IF sh # NIL THEN {      CWF.WF0["(Filling in create dates from files on local disk..."L];      FillInCreateDates[dfSeqOther];      CWF.WF0["done.)\n"L];      DFSubr.SortByFileName[dfSeqOther, 0, dfSeqOther.size - 1, FALSE];      DFSubr.InsertCRs[dfSeqOther];      DFSubr.WriteOut[        dfseq: dfSeqOther, topLevelFile: NIL, outputStream: sh, print: TRUE];      IF fileForMissingEntries THEN CWF.WF1["List written on %s.\n"L, sfn]      ELSE {  -- gun the ".missing" file        temp: MFile.Handle ¬ NIL;        temp ¬ MFile.Acquire[name: sfn, access: delete, release: []          ! MFile.Error => CONTINUE];        IF temp # NIL THEN MFile.Delete[temp ! MFile.Error => CONTINUE]}};    END;    CleanUp[]};        MarkEvaluated: PROC [df: DFSubr.DF, dfSeq: DFSubr.DFSeq] = {    df.eval ¬ TRUE;    FOR i: CARDINAL IN [0..dfSeq.size) DO      other: DFSubr.DF ¬ @dfSeq[i];      IF other.shortname # NIL      AND String.Equivalent[other.shortname, df.shortname] THEN other.eval ¬ TRUE;      ENDLOOP};	  PrintUnnecessaryFiles: PROC [dfSeq: DFSubr.DFSeq] = {    legendPrinted: BOOLEAN ¬ FALSE;      FOR i: CARDINAL IN [0..dfSeq.size) DO        IF ~dfSeq[i].need AND ~dfSeq[i].eval	AND ~Subr.EndsIn[dfSeq[i].shortname, ".df"L]	AND ~Subr.EndsIn[dfSeq[i].shortname, ".cm"L] THEN {	  IF ~legendPrinted THEN {	    CWF.WF0["\nThe following files appear to be unnecessary.\n"L];	    legendPrinted ¬ TRUE};	  CWF.WF1["  %s\n"L, dfSeq[i].shortname]};        ENDLOOP;      IF legendPrinted THEN CWF.WFCR[]};  AnalyzeBcd: PROC [        sfn: LONG STRING, dfSeq, dfSeqOther: DFSubr.DFSeq, verbose: BOOLEAN]      RETURNS [readOnlyFile: BOOLEAN] = {    dftop: DFSubr.DF;    innards: ProcBcds.InnardsObject ¬ [];    skip: BOOLEAN ¬ FALSE;    -- versionstamp rule:    --	 versionstamp is set by procMod, or first call on procDep,    --   subsequent calls to procDep do not change it    -- dftop and sfn are passed in    procMod: ProcBcds.ProcMod = {      -- [sourcefile, smodulename: STRING,      --  bcdvers, sourcevers, creatorvers: BcdDefs.VersionStamp,      --  isdefns, isconfig, ispackaged, iscodebound, issymbolsbound,      --  istablecompiled, madebylinker, altoCode, boundsChecks, cedarSwitch,      --  crossJump, linksInCode, nilChecks, sortByUsage: BOOLEAN,      --  symbolSpace: FileParms.SymbolSpace] RETURNS [uns: UNSPECIFIED]      uns ¬ madebylinker;      IF dftop # NIL THEN {        MarkEvaluated[dftop, dfSeq];        IF dftop.versionstamp # Time.Packed[0]	AND dftop.versionstamp # bcdvers.time THEN {          skip ¬ TRUE;          CWF.WF4[            "Error - the version of %s listed in the DF file is stamped %lt, but %s wants it to be of %lt.\n"L,            dftop.shortname, @bcdvers.time, dftop.recorder, @dftop.versionstamp];          Subr.errorflg ¬ TRUE};        dftop.versionstamp ¬ [bcdvers.time];        Subr.FreeString[dftop.recorder, dfSeq.dfzone];        dftop.recorder ¬ Subr.CopyString[dftop.shortname, dfSeq.dfzone]};      -- if not readonly, ask about sourcefile      IF (dftop = NIL OR ~dftop.readonly) AND sourcefile.length > 0 THEN {        dfsrc: DFSubr.DF ¬ DFSubr.LookupDF[dfSeq, sourcefile];        IF dfsrc = NIL THEN	  dfsrc ¬ DFSubr.LookupDF[dfSeqOther, sourcefile];	  IF dfsrc = NIL THEN {          CWF.WF3[            "Error - %s is the source file for %s\n\tbut %s is not in the DF files.\n"L,            sourcefile, sfn, sourcefile];          dfsrc ¬ DFSubr.NextDF[dfSeqOther];  -- add to missing entry list	  IF dfsrc # NIL THEN { -- may return NIL when too many entries.	    dfsrc.shortname ¬ Subr.CopyString[sourcefile, dfSeqOther.dfzone];	    dfsrc.createtime ¬ [sourcevers.time];	    Subr.errorflg ¬ TRUE}};	IF dfsrc # NIL THEN {	  dfsrc.need ¬ TRUE;  MarkEvaluated[dfsrc, dfSeq];          IF dfsrc.createtime > Time.Packed[0]	  AND dfsrc.createtime # sourcevers.time THEN {            CWF.WF4[              "Error - %s of %lt is the source file for %s,\n\tbut the DF file lists version of %lt.\n"L,              dfsrc.shortname, @sourcevers.time, sfn, @dfsrc.createtime];            Subr.errorflg ¬ TRUE}}};      << Figure this out later....      -- if not symbolcopied, see if there is an entry for a ".symbols" file      IF ~issymbolsbound AND ~isdefns THEN {        syms: STRING ¬ [MFile.maxNameLength];	dfsyms: DFSubr.DF;	FOR i: CARDINAL IN [0..smodulename.length) DO	  IF smodulename[i] = '. THEN EXIT	  ELSE String.AppendChar[syms, smodulename[i]];	  ENDLOOP;	String.AppendString[syms, ".symbols"L];	dfsyms ¬ DFSubr.LookupDF[dfSeq, syms];	IF dfsyms # NIL THEN 	  CWF.WF2[	    "Warning - %s was bound without copied symbols, but %s appears in the DF files.\n"L, sfn, syms]}  >>	 };    -- filename will probably have ".bcd" at the end    -- look at otherdepends, canignore, defstype, and symbolsfile only    -- sfn, dfSeq, dfSeqOther, skip, and dftop passed in from outside    -- kam (18-Dec-85  9:20:02) also look at imports for c configurations    procDep: ProcBcds.ProcDep = {      -- [relcode: RelCode, smodulename, filename: STRING,      --  bcdvers: BcdDefs.VersionStamp, uns: UNSPECIFIED]      dfdep: DFSubr.DF;      madebylinker: BOOLEAN ¬ LOOPHOLE[uns];      IF skip OR filename.length = 0 OR filename[0] = '? THEN RETURN;      SELECT relcode FROM        otherdepends, canignore, defstype, symbolsfile => NULL;	imports => IF NOT madebylinker THEN RETURN;	ENDCASE => RETURN;      IF dfSeq.size = 0 OR (dfdep ¬ DFSubr.LookupDF[dfSeq, filename]) = NIL THEN {                 IF DFSubr.LookupDF[dfSeqOther, filename] = NIL THEN {          CWF.WF2[            "Error - %s is not in the DF files,\n\tbut %s depends on it.\n"L,            filename, sfn];          dfdep ¬ DFSubr.NextDF[dfSeqOther];  -- add to missing entry list          dfdep.shortname ¬ Subr.CopyString[filename, dfSeqOther.dfzone];          dfdep.versionstamp ¬ [bcdvers.time];	  Subr.errorflg ¬ TRUE}}      ELSE {        IF ~dfdep.need THEN {          -- forces analysis only if the including Bcd is not READONLY          dfdep.need ¬ (IF dftop = NIL THEN TRUE ELSE ~dftop.readonly)};        -- check its the right version        IF bcdvers.time = Time.Packed[0]	OR String.Equivalent[filename, sfn] THEN RETURN;        IF dfdep.versionstamp = Time.Packed[0] THEN {          dfdep.versionstamp ¬ [bcdvers.time];          -- enter who recorded this entry          Subr.FreeString[dfdep.recorder, dfSeq.dfzone];          dfdep.recorder ¬ Subr.CopyString[sfn, dfSeq.dfzone]};        IF bcdvers.time # dfdep.versionstamp AND dfdep.recorder # NIL THEN {          IF String.Equivalent[dfdep.shortname, dfdep.recorder] THEN            CWF.WF4[              "Error - %s is dated %lt\n\tbut %s wants it to be %lt.\n"L,              dfdep.shortname, @dfdep.versionstamp, sfn, @bcdvers.time]          ELSE {            CWF.WF4[              "Error - %s wants %s of %lt\n\tbut %s"L, sfn, dfdep.shortname,              @bcdvers.time, dfdep.recorder];            CWF.WF1[" wants it to be %lt.\n"L, @dfdep.versionstamp]};          Subr.errorflg ¬ TRUE}}};    BEGIN  -- main body of AnalyzeBcd      ENABLE        UNWIND => {          IF innards.rHandle # NIL THEN {	    LeafSubr.Close[innards.rHandle];  innards.rHandle ¬ NIL};	  IF innards.fHandle # NIL THEN {	    MFile.Release[innards.fHandle];  innards.fHandle ¬ NIL}};    success: BOOLEAN ¬ TRUE;    readOnlyFile ¬ FALSE;    -- look for Bcd sfn in flattened DF list (try for non-readonly entry)    dftop ¬ NIL;    FOR i: CARDINAL IN [0..dfSeq.size) DO      other: DFSubr.DF ¬ @dfSeq[i];      IF other.shortname # NIL AND String.Equivalent[other.shortname, sfn] THEN {        dftop ¬ other;        IF ~dftop.readonly THEN EXIT};  -- otherwise keep looking for non-readonly      ENDLOOP;    -- don't analyze readonly    IF dftop # NIL AND dftop.readonly THEN RETURN[readOnlyFile: TRUE];    IF dftop # NIL THEN      [innards.fHandle, innards.rHandle] ¬ CachedBcd[dftop, verbose         ! Subr.FileError => {            IF error = wrongVersion THEN              CWF.WF2["   %s of %lt cannot be found.\n"L, sfn, @dftop.createtime]            ELSE CWF.WF1["   %s cannot be found.\n"L, sfn];            GOTO err}]    ELSE {      innards.fHandle ¬ MFile.ReadOnly[name: sfn, release: []         ! MFile.Error => {CWF.WF1["   %s cannot be found.\n"L, sfn];  GOTO err}];      IF verbose THEN CWF.WF1["Analyzing %s.\n"L, sfn]};    ProcBcds.ReadInSegmentsBcd[@innards      ! ProcBcds.InvalidBcd => {          CWF.WF1["Error - %s is NOT a valid Bcd.\n"L, sfn];	  success ¬ FALSE;  CONTINUE}];    IF success THEN {      ProcBcds.InstallAddressesBcd[@innards];      [success] ¬ ProcBcds.PrintDepends[        innards: @innards,        procMod: procMod, procDep: procDep,        print: FALSE, calltwice: FALSE, less: TRUE, bcdfilename: sfn]};    IF ~success THEN {      CWF.WF1["Error - couldn't analyze %s correctly.\n"L, sfn];      Subr.errorflg ¬ TRUE};    IF innards.rHandle # NIL THEN {      LeafSubr.Close[innards.rHandle];  innards.rHandle ¬ NIL};    IF innards.fHandle # NIL THEN {      MFile.Release[innards.fHandle];  innards.fHandle ¬ NIL};    ProcBcds.UnstallBcd[@innards];    EXITS err => Subr.errorflg ¬ TRUE;    END};      -- file was found locally if returned rHandle is NIL, otherwise remote  CachedBcd: PROC [        df: DFSubr.DF, verbose: BOOLEAN]      RETURNS [fHandle: MFile.Handle, rHandle: LeafSubr.FileHandle] = {    localCreateTime: LONG CARDINAL;    fHandle ¬ NIL;  rHandle ¬ NIL;        BEGIN  -- look locally    fHandle ¬ MFile.Acquire[name: df.shortname, access: anchor, release: []      ! MFile.Error => GOTO notLocal];    localCreateTime ¬ MFile.GetCreateDate[fHandle];    IF localCreateTime = df.createtime    OR (df.createtime = Time.Packed[0] AND df.host = NIL) THEN {      IF verbose THEN CWF.WF1["Analyzing %s.\n"L, df.shortname];      MFile.SetAccess[file: fHandle, access: readOnly];      RETURN[fHandle, NIL]};    EXITS notLocal => NULL;    END;        BEGIN  -- look on remote server    name: STRING ¬ [150];    foundOneVersion, foundOnRemote: BOOLEAN ¬ FALSE;    correctRemoteVersion: CARDINAL;    CheckOneFile: FileTransfer.ListProc = {      remoteInfo: FileTransfer.FileInfo ¬ info[conn].source;      foundOneVersion ¬ TRUE;      IF df.createtime = remoteInfo.create THEN {        foundOnRemote ¬ TRUE;        IF ~String.Empty[remoteInfo.version] THEN          correctRemoteVersion ¬ String.StringToDecimal[remoteInfo.version	    ! String.InvalidNumber => {correctRemoteVersion ¬ 0;  CONTINUE}]};      RETURN[do]};    IF df.version > 0 AND df.criterion = none    AND df.createtime # Time.Packed[0] THEN {      CWF.SWF3[name, "<%s>%s!%u"L, df.directory, df.shortname, @df.version];      IF verbose THEN CWF.WF2["Analyzing [%s]%s.\n"L, df.host, name]}    ELSE {      CWF.SWF2[name, "<%s>%s!H"L, df.directory, df.shortname];      IF verbose THEN CWF.WF2["Analyzing [%s]%s.\n"L, df.host, name]};    rHandle ¬ LeafSubr.Open[df.host, name];    IF df.createtime # Time.Packed[0] THEN {      IF LeafSubr.GetStreamCreation[rHandle] # df.createtime THEN {        LeafSubr.Close[rHandle];        CWF.SWF3[name, "[%s]<%s>%s!*"L, df.host, df.directory, df.shortname];        Transfer.EnumerateForProperties[fileName: name, enumProc: CheckOneFile];        IF ~foundOneVersion THEN GOTO notfound;	IF ~foundOnRemote THEN GOTO wrongVersion;	CWF.SWF4[	  name, "[%s]<%s>%s!%u"L,	  df.host, df.directory, df.shortname, @correctRemoteVersion];        rHandle ¬ LeafSubr.Open[df.host, name]}};    EXITS      notfound => ERROR Subr.FileError[notFound];      wrongVersion => ERROR Subr.FileError[wrongVersion];    END};      AnalyzeBootFile: PROC [        sfn: LONG STRING, dfSeq, dfSeqOther: DFSubr.DFSeq, verbose: BOOLEAN]      RETURNS [readOnlyFile: BOOLEAN] = {    dftop: DFSubr.DF ¬ NIL;    sh: Stream.Handle ¬ NIL;    fileBytes: LONG CARDINAL ¬ 0;    readOnlyFile ¬ FALSE;    -- look for boot file sfn in flattened DF list (try for non-readonly entry)    FOR i: CARDINAL IN [0..dfSeq.size) DO      other: DFSubr.DF ¬ @dfSeq[i];      IF other.shortname # NIL AND String.Equivalent[other.shortname, sfn] THEN {        dftop ¬ other;        IF ~dftop.readonly THEN EXIT};  -- otherwise keep looking for non-readonly      ENDLOOP;    -- don't analyze readonly    IF dftop # NIL AND dftop.readonly THEN RETURN[readOnlyFile: TRUE];    MarkEvaluated[dftop, dfSeq];        BEGIN  -- look locally      ENABLE UNWIND => IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL};    localCreateTime: LONG CARDINAL;    sh ¬ MStream.ReadOnly[sfn, [] ! MStream.Error => GOTO notLocal];    localCreateTime ¬ MFile.GetCreateDate[MStream.GetFile[sh]];    IF localCreateTime = dftop.createtime    OR (dftop.createtime = Time.Packed[0] AND dftop.host = NIL) THEN {      IF verbose THEN CWF.WF1["Analyzing %s.\n"L, sfn];      fileBytes ¬ MStream.GetLength[sh];      sh.options.signalEndOfStream ¬ TRUE;      ScanBootFileStream[sh, dftop, dfSeq, dfSeqOther, fileBytes        ! IncompatibleBootFileVersion => {	    CWF.WF1["Error - %s has an incompatible boot file format.\n"L, sfn];	    CONTINUE}];      Stream.Delete[sh];  sh ¬ NIL;      RETURN[readOnlyFile: FALSE]};    EXITS notLocal => NULL;    END;    BEGIN  -- look on remote server    name: STRING ¬ [150];    foundOnRemote, foundOneVersion: BOOLEAN ¬ FALSE;    ConsiderFile: Transfer.RetrieveProcType = {      remoteInfo: FileTransfer.FileInfo;      foundOneVersion ¬ TRUE;      IF foundOnRemote THEN RETURN[skipRest: TRUE];      remoteInfo ¬ FileTransfer.GetStreamInfo[s];      IF dftop.createtime # remoteInfo.create THEN RETURN[skipRest: FALSE];      -- dates agree, go process it      foundOnRemote ¬ TRUE;      fileBytes ¬ remoteInfo.size;      ScanBootFileStream[s, dftop, dfSeq, dfSeqOther, fileBytes        ! IncompatibleBootFileVersion => {	    CWF.WF1["Error - %s has an incompatible boot file format.\n"L, name];	    CONTINUE}];      RETURN[skipRest: TRUE]};    IF String.Equivalent[dftop.host, "Unknown"L] THEN GOTO notfound;    IF dftop.version > 0 AND dftop.criterion = none    AND dftop.createtime # Time.Packed[0] THEN {      CWF.SWF4[        name, "[%s]<%s>%s!%u"L,	dftop.host, dftop.directory, dftop.shortname, @dftop.version];      IF verbose THEN CWF.WF1["Analyzing %s.\n"L, name]}    ELSE {      CWF.SWF3[        name, "[%s]<%s>%s!H"L, dftop.host, dftop.directory, dftop.shortname];      IF verbose THEN CWF.WF3[        "Analyzing [%s]<%s>%s.\n"L,	dftop.host, dftop.directory, dftop.shortname]};    Transfer.EnumerateForRetrieve[name, ConsiderFile      ! FileTransfer.Error =>	  SELECT code FROM	    retry => {	      CWF.WF1["Connection to %s timed out...retrying..."L, dftop.host];	      foundOnRemote ¬ foundOneVersion ¬ FALSE;	      RETRY};	    accessDenied => GOTO cantRead;	    ENDCASE => REJECT];    IF ~foundOneVersion THEN GOTO notfound;    IF ~foundOnRemote THEN GOTO wrongVersion; -- no correct version found    EXITS      notfound => {        CWF.WF1["   File %s cannot be found.\n"L, sfn];	Subr.errorflg ¬ TRUE};      wrongVersion => {        CWF.WF2["   File %s of %lt cannot be found.\n"L, sfn, @dftop.createtime];	Subr.errorflg ¬ TRUE};      cantRead => {        CWF.WF1["   Insufficient credentials to retrieve %s.\n"L, sfn];	Subr.errorflg ¬ TRUE};    END};      bpp: CARDINAL = Environment.bytesPerPage;  bufferPages: Environment.PageCount ¬ 178;  bitBucketPages: Environment.PageCount ¬ 20;    buffer, bitBucket: LONG POINTER ¬ NIL;  bufferSpace, bitBucketSpace: MSegment.Handle ¬ NIL;  bcd: BcdOps.BcdBase ¬ NIL;  -- If bootloaded portion is smaller, assume all resident (e.g. Othello).  -- These resident boot files include the Bcd in the bootloaded part.  allBootloadedBytes: LONG CARDINAL = (10 * bpp);  -- i.e. 10 pages  allBootloaded: BOOLEAN;  pagesLeftInGroup: CARDINAL; -- if allBootloaded, data pages are in groups  page: CARDINAL ¬ 0;  ScanBootFileStream: PROC [      sh: Stream.Handle, dftop: DFSubr.DF, dfSeq, dfSeqOther: DFSubr.DFSeq,      fileBytes: LONG CARDINAL] = {    bootloadedPages: CARDINAL ¬ 0;    bootloadedBytes: LONG CARDINAL ¬ 0;    eof: BOOLEAN ¬ FALSE;    bcdName: STRING ¬ [MFile.maxNameLength];    bcdvers: BcdDefs.VersionStamp;    dfdep: DFSubr.DF ¬ NIL;    BEGIN ENABLE UNWIND => FreeScanBuffers[];    sh.options.signalEndOfStream ¬ TRUE;    InitScanBuffers[];    bootloadedPages ¬ GetBootloadedPages[sh      ! Stream.EndOfStream => GOTO earlyEOF];    bootloadedBytes ¬ (LONG[bootloadedPages] * bpp);    IF fileBytes < bootloadedBytes THEN GOTO earlyEOF;    IF (fileBytes - bootloadedBytes) < allBootloadedBytes THEN {      allBootloaded ¬ TRUE;  pagesLeftInGroup ¬ BootFile.maxEntriesPerHeader}    ELSE {      allBootloaded ¬ FALSE;      SkipOverBootloadedPart[sh, bootloadedPages        ! Stream.EndOfStream => GOTO earlyEOF]};    DO -- look for start of a Bcd      IF checkAbort[] THEN ERROR ABORTED;      ReadOnePage[sh ! Stream.EndOfStream => {eof ¬ TRUE;  CONTINUE}];      IF eof THEN EXIT;      IF ~IsStartOfValidBcd[bcd] THEN LOOP;      IF bcd.nPages > 1 THEN ReadRemainingBcdPages[sh, bcd.nPages	! Stream.EndOfStream => GOTO earlyEOF];      GetBcdName[bcdName, bcd];      bcdvers ¬ bcd.version;      IF dfSeq.size = 0 THEN dfdep ¬ NIL      ELSE {        dfdep ¬ DFSubr.LookupDF[dfSeq, bcdName];	IF dfdep = NIL THEN {  -- try using file name derived from source	  GetNameFromSource[bcdName, bcd];	  dfdep ¬ DFSubr.LookupDF[dfSeq, bcdName];	  IF dfdep = NIL THEN  -- back out; it didn't work	    GetBcdName[bcdName, bcd]}};      IF dfdep = NIL THEN {         IF DFSubr.LookupDF[dfSeqOther, bcdName] = NIL THEN {          CWF.WF2[            "Error - %s is not in the DF files,\n\tbut %s depends on it.\n"L,            bcdName, dftop.shortname];          dfdep ¬ DFSubr.NextDF[dfSeqOther];  -- add to missing entry list          dfdep.shortname ¬ Subr.CopyString[bcdName, dfSeqOther.dfzone];          dfdep.versionstamp ¬ [bcdvers.time];	  Subr.errorflg ¬ TRUE}}      ELSE {        IF ~dfdep.need THEN {          -- forces analysis only if the including boot file is not READONLY          dfdep.need ¬ (IF dftop = NIL THEN TRUE ELSE ~dftop.readonly)};        -- check its the right version        IF bcdvers.time = Time.Packed[0]	 OR String.Equivalent[bcdName, dftop.shortname] THEN LOOP;        IF dfdep.versionstamp = Time.Packed[0] THEN {          dfdep.versionstamp ¬ [bcdvers.time];          -- enter who recorded this entry          Subr.FreeString[dfdep.recorder, dfSeq.dfzone];          dfdep.recorder ¬ Subr.CopyString[dftop.shortname, dfSeq.dfzone]};        IF bcdvers.time # dfdep.versionstamp AND dfdep.recorder # NIL THEN {          IF String.Equivalent[dfdep.shortname, dfdep.recorder] THEN            CWF.WF4[              "Error - %s is dated %lt\n\tbut %s wants it to be %lt.\n"L,              dfdep.shortname, @dfdep.versionstamp,	      dftop.shortname, @bcdvers.time]          ELSE {            CWF.WF3[              "Error - %s wants %s of %lt\n"L,	      dftop.shortname, dfdep.shortname, @bcdvers.time];            CWF.WF2[	      "\tbut %s wants it to be %lt.\n"L,	      dfdep.recorder, @dfdep.versionstamp]};          Subr.errorflg ¬ TRUE}};      ENDLOOP;     EXITS      earlyEOF => {        CWF.WF1["Error - unexpected EOF reading %s.\n"L, dftop.shortname];        Subr.errorflg ¬ TRUE};    END;    FreeScanBuffers[]};      InitScanBuffers: PROC = {    bufferSpace ¬ MSegment.Create[        file: NIL, release: [],      fileBase: 0, pages: bufferPages, swapInfo: [uniform[size: 4]]];    buffer ¬ MSegment.Address[bufferSpace];    bcd ¬ LOOPHOLE[buffer, BcdOps.BcdBase];    bitBucketSpace ¬ MSegment.Create[      file: NIL, release: [],      fileBase: 0, pages: bitBucketPages, swapInfo: [uniform[size: 4]]];    bitBucket ¬ MSegment.Address[bitBucketSpace];    page ¬ 0};      FreeScanBuffers: PROC = {    IF bufferSpace # NIL THEN {      MSegment.Delete[bufferSpace];  bufferSpace ¬ NIL;      buffer ¬ NIL};    IF bitBucketSpace # NIL THEN {      MSegment.Delete[bitBucketSpace];  bitBucketSpace ¬ NIL;      bitBucket ¬ NIL};    bcd ¬ NIL;    page ¬ 0};      GetBootloadedPages: PROC [      bootFileStream: Stream.Handle] RETURNS [bootloadedPages: CARDINAL] = {    header: LONG POINTER TO BootFile.Header ¬ LOOPHOLE[bitBucket];    [] ¬ Stream.GetBlock[bootFileStream, [bitBucket, 0, bpp]];    IF header.version # BootFile.currentVersion THEN      ERROR IncompatibleBootFileVersion;    bootloadedPages ¬ CARDINAL[BootFile.MemorySizeToFileSize[header.countData]];    page ¬ 1};      SkipOverBootloadedPart: PROC [      bootFileStream: Stream.Handle, bootloadedPages: CARDINAL] = {    pagesToSkip: CARDINAL = (bootloadedPages - 1);    THROUGH [1..(pagesToSkip/bitBucketPages)] DO      [] ¬ Stream.GetBlock[        bootFileStream, [bitBucket, 0, CARDINAL[bitBucketPages * bpp]]];      page ¬ page + CARDINAL[bitBucketPages];      ENDLOOP;    [] ¬ Stream.GetBlock[      bootFileStream,      [bitBucket, 0, CARDINAL[pagesToSkip MOD bitBucketPages] * bpp]];    page ¬ page + CARDINAL[pagesToSkip MOD bitBucketPages]};        ReadOnePage: PROC [bootFileStream: Stream.Handle] = {    [] ¬ Stream.GetBlock[bootFileStream, [buffer, 0, bpp]];    page ¬ page + 1;    IF allBootloaded AND (pagesLeftInGroup ¬ pagesLeftInGroup-1) = 0 THEN {      -- skip over trailer page      [] ¬ Stream.GetBlock[bootFileStream, [bitBucket, 0, bpp]];      pagesLeftInGroup ¬ BootFile.maxEntriesPerTrailer}};     IsStartOfValidBcd: PROC [bcd: BcdOps.BcdBase] RETURNS [yes: BOOLEAN] = {    IF bcd.versionIdent # BcdDefs.VersionID THEN RETURN[FALSE];    IF bcd.nPages = 0 THEN RETURN[FALSE];    IF bcd.nModules = 0 THEN RETURN[FALSE];    IF bcd.firstdummy < bcd.nModules THEN RETURN[FALSE];    IF bcd.nConfigs > 100 THEN RETURN[FALSE];    IF bcd.nImports > 300 OR bcd.nExports > 300 THEN RETURN[FALSE];    IF bcd.nPages > bufferPages THEN {      pages: CARDINAL ¬ bcd.nPages;      CWF.WF1[	"Warning - bootfile has a Bcd too large to process (%u pages).\n"L,	@pages];      RETURN[FALSE]};    RETURN[TRUE]};      ReadRemainingBcdPages: PROC [      bootFileStream: Stream.Handle, bcdPages: CARDINAL] = {    pagesToRead: CARDINAL = (bcdPages - 1);    p: LONG POINTER ¬ (buffer + Environment.wordsPerPage);  -- after first page    IF allBootloaded THEN {  -- have to skip trailer pages       THROUGH [1..pagesToRead] DO	[] ¬ Stream.GetBlock[bootFileStream, [p, 0, bpp]];	page ¬ page + 1;	IF allBootloaded AND (pagesLeftInGroup ¬ pagesLeftInGroup-1) = 0 THEN {	  -- skip trailer page	  [] ¬ Stream.GetBlock[bootFileStream, [bitBucket, 0, bpp]];	  pagesLeftInGroup ¬ BootFile.maxEntriesPerTrailer};	p ¬ (p + Environment.wordsPerPage);	ENDLOOP}    ELSE {      blockSize: CARDINAL = 10;      THROUGH [1..(pagesToRead/blockSize)] DO	[] ¬ Stream.GetBlock[bootFileStream, [p, 0, CARDINAL[blockSize * bpp]]];	page ¬ page + blockSize;	p ¬ (p + blockSize*Environment.wordsPerPage);	ENDLOOP;      [] ¬ Stream.GetBlock[	bootFileStream, [p, 0, CARDINAL[pagesToRead MOD blockSize] * bpp]];      page ¬ page + (pagesToRead MOD blockSize)}};      GetBcdName: PROC [bcdName: LONG STRING, bcd: BcdOps.BcdBase] = {    name: BcdDefs.NameRecord;    nameSS: String.SubStringDescriptor;    IF bcd.nConfigs > 0 THEN {  -- not Compiler created              FindTopLevelConfig: PROC [          cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex] RETURNS [stop: BOOLEAN] = {        IF cth.config = BcdDefs.CTNull THEN {name ¬ cth.name;  RETURN[TRUE]}        ELSE RETURN[FALSE]};	      [] ¬ BcdOps.ProcessConfigs[bcd, FindTopLevelConfig]}    ELSE {      firstMth: BcdOps.MTHandle = LOOPHOLE[bcd + bcd.mtOffset];       name ¬ firstMth.name};    SubStringForName[@nameSS, name, bcd];    bcdName.length ¬ 0;  String.AppendSubString[bcdName, @nameSS];    IF ~Subr.Any[bcdName, '.] THEN String.AppendString[bcdName, ".bcd"L]};      GetNameFromSource: PROC [bcdName: LONG STRING, bcd: BcdOps.BcdBase] = {    name: BcdDefs.NameRecord ¬ BcdDefs.NullName;    nameSS: String.SubStringDescriptor;            FindSourceFti: PROC [        fth: BcdOps.FTHandle, fti: BcdDefs.FTIndex] RETURNS [stop: BOOLEAN] = {      IF fti = bcd.sourceFile THEN {name ¬ fth.name;  RETURN[TRUE]}      ELSE RETURN[FALSE]};    [] ¬ BcdOps.ProcessFiles[bcd, FindSourceFti];    SubStringForName[@nameSS, name, bcd];    bcdName.length ¬ 0;    String.AppendSubString[bcdName, @nameSS];    FOR i: CARDINAL IN [0..bcdName.length) DO      IF bcdName[i] = '. THEN {	bcdName.length ¬ i;  String.AppendString[bcdName, ".bcd"L];  EXIT};      ENDLOOP};  SubStringForName: PROC [      ss: String.SubString, name: BcdDefs.NameRecord, bcd: BcdOps.BcdBase] = {    bcdNames: BcdOps.NameString ¬ LOOPHOLE[bcd + bcd.ssOffset];    ss.base ¬ @bcdNames.string;    IF name = BcdDefs.NullName THEN ss.offset ¬ ss.length ¬ 0     ELSE {ss.offset ¬ name;  ss.length ¬ bcdNames.size[name]}};  -- see if create dates of ReadOnly files agree with their functional stamps  CheckReadOnlyFiles: PROC [dfSeq: DFSubr.DFSeq, verbose: BOOLEAN] = {    bcdSeg: MSegment.Handle ¬ NIL;    bcd: BcdOps.BcdBase ¬ NIL;    df: DFSubr.DF;    fHandle: MFile.Handle ¬ NIL;    rHandle: LeafSubr.FileHandle ¬ NIL;        CleanUp: PROC = {      IF bcdSeg # NIL THEN {MSegment.Delete[bcdSeg];  bcdSeg ¬ NIL;  bcd ¬ NIL};      IF rHandle # NIL THEN {LeafSubr.Close[rHandle];  rHandle ¬ NIL};      IF fHandle # NIL THEN {MFile.Release[fHandle];  fHandle ¬ NIL}};	        BEGIN ENABLE UNWIND => CleanUp[];    IF verbose THEN CWF.WF0["\nChecking Imported files:\n"L];    bcdSeg ¬ MSegment.Create[file: NIL, release: [], pages: 1];    bcd ¬ MSegment.Address[bcdSeg];    FOR i: CARDINAL IN [0..dfSeq.size) DO      IF checkAbort[] THEN ERROR ABORTED;      df ¬ @dfSeq[i];      IF df.readonly AND df.versionstamp # Time.Packed[0] THEN {        [fHandle, rHandle] ¬ CachedBcd[df, verbose           ! Subr.FileError => {              IF error = wrongVersion THEN                CWF.WF2[                  "   File %s of %lt cannot be found.\n"L,		  df.shortname, @df.createtime]              ELSE CWF.WF1["   File %s cannot be found.\n"L, df.shortname];              Subr.errorflg ¬ TRUE;              LOOP}];	IF Subr.EndsIn[df.shortname, "bcd"L] THEN {	  IF rHandle = NIL THEN	    MSegment.CopyIn[segment: bcdSeg, file: fHandle, fileBase: 0, count: 1]	  ELSE LeafSubr.RemoteMap[seg: bcdSeg, fh: rHandle, base: 0];	  IF bcd.version.time # df.versionstamp THEN {	    CWF.WF3[	      "Error - %s of %lt has a version stamp of %lt,\n"L,	      df.shortname, @df.createtime, @bcd.version.time];	    CWF.WF2[	      "\tbut %s wants one with version stamp %lt.\n"L,	      df.recorder, @df.versionstamp];	    Subr.errorflg ¬ TRUE}};        IF rHandle # NIL THEN {LeafSubr.Close[rHandle];  rHandle ¬ NIL};        IF fHandle # NIL THEN {MFile.Release[fHandle];  fHandle ¬ NIL}};      ENDLOOP;    END;    CleanUp[]};      -- check various features of the DF file  CheckForCommonBlunders: PROC [dfseq: DFSubr.DFSeq] = {    df: DFSubr.DF;    legendPrinted: BOOLEAN;    -- Directory XXX (no ReleaseAs or CameFrom)    legendPrinted ¬ FALSE;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF ~df.readonly AND df.releaseDirectory = NIL THEN {        IF ~legendPrinted THEN {	  CWF.WF0["Warning - these files are in directories that are not ReadOnly and have no ReleaseAs or CameFrom clause.\n"L];	  CWF.WF2["\t%s in %s"L, df.shortname, df.recorder];	  legendPrinted ¬ TRUE}	ELSE CWF.WF2[", %s in %s"L, df.shortname, df.recorder]};      ENDLOOP;    IF legendPrinted THEN CWF.WFCR[];    -- Directory XXX ReleaseAs XXX    legendPrinted ¬ FALSE;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF ~df.readonly AND ~df.cameFrom      AND df.host # NIL AND df.releaseHost # NIL      AND df.directory # NIL AND df.releaseDirectory # NIL      AND String.Equivalent[df.host, df.releaseHost]      AND String.Equivalent[df.directory, df.releaseDirectory] THEN {        IF ~legendPrinted THEN {	  CWF.WF0["Warning - these files have release locations which are the same as their home location.\n"L];	  CWF.WF2["\t%s in %s"L, df.shortname, df.recorder];	  legendPrinted ¬ TRUE}	ELSE CWF.WF2[", %s in %s"L, df.shortname, df.recorder]};      ENDLOOP;    IF legendPrinted THEN CWF.WFCR[];    -- Includes XXX (no ReleaseAs or CameFrom)    legendPrinted ¬ FALSE;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF df.atsign AND ~df.readonly AND df.releaseDirectory = NIL THEN {        IF ~legendPrinted THEN {	  CWF.WF0["Warning - these DF files are Included but have no ReleaseAs or CameFrom clause.\n"L];	  CWF.WF2["\t%s in %s"L, df.shortname, df.recorder];	  legendPrinted ¬ TRUE}	ELSE CWF.WF2[", %s in %s"L, df.shortname, df.recorder]};      ENDLOOP;    IF legendPrinted THEN CWF.WFCR[];    -- Directory Foo>XXX ReleaseAs Bar>YYY,    --   where xxx = (FRIENDS/PRIVATE/PUBLIC) and XXX # YYY    legendPrinted ¬ FALSE;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF ~df.readonly      AND df.host # NIL AND df.releaseHost # NIL      AND df.directory # NIL AND df.releaseDirectory # NIL THEN {        loc, releaseLoc: {unknown, private, public, friends} ¬ unknown;        SELECT TRUE FROM	  Subr.EndsIn[df.directory, ">Private"L] => loc ¬ private;	  Subr.EndsIn[df.directory, ">Public"L]  => loc ¬ public;	  Subr.EndsIn[df.directory, ">Friends"L] => loc ¬ friends;	  ENDCASE => LOOP;	SELECT TRUE FROM	  Subr.EndsIn[df.directory, ">Private"L] => releaseLoc ¬ private;	  Subr.EndsIn[df.directory, ">Public"L]  => releaseLoc ¬ public;	  Subr.EndsIn[df.directory, ">Friends"L] => releaseLoc ¬ friends;	  ENDCASE => LOOP;	IF loc # releaseLoc THEN {          IF ~legendPrinted THEN {	    CWF.WF0["Warning - these files have working subdirectories that are not the same as the release/camefrom subdirectories.\n"L];	    CWF.WF2["\t%s in %s"L, df.shortname, df.recorder];	    legendPrinted ¬ TRUE}	  ELSE CWF.WF2[", %s in %s"L, df.shortname, df.recorder]}};      ENDLOOP;    IF legendPrinted THEN CWF.WFCR[]};	    -- fill in create dates for entries where we know the version stamp but  -- don't know their create dates; involves looking on the local disk  FillInCreateDates: PROC [dfSeq: DFSubr.DFSeq] = {    bcdSeg: MSegment.Handle ¬ NIL;    bcd: BcdOps.BcdBase ¬ NIL;    df: DFSubr.DF;    fullname: LONG STRING ¬ NIL;    vfn: FileName.VFN ¬ NIL;    CleanUp: PROC = {      IF bcdSeg # NIL THEN {MSegment.Delete[bcdSeg];  bcdSeg ¬ NIL};      IF fullname # NIL THEN {        Subr.FreeString[fullname, dfSeq.dfzone];  fullname ¬ NIL}};    UseDefaults: PROC = {      IF df.host = NIL THEN        df.host ¬ Subr.CopyString["Unknown"L, dfSeq.dfzone];      IF df.directory = NIL THEN        df.directory ¬ Subr.CopyString["Unknown"L, dfSeq.dfzone]};    BEGIN ENABLE UNWIND => CleanUp[];    bcdSeg ¬ MSegment.Create[file: NIL, release: [], pages: 1];    bcd ¬ MSegment.Address[bcdSeg];    fullname ¬ Subr.AllocateString[nchars: 150, zone: dfSeq.dfzone];    DFSubr.LookupFiles[dfSeq];    FOR i: CARDINAL IN [0..dfSeq.size) DO      BEGIN      df ¬ @dfSeq[i];      IF Subr.EndsIn[df.shortname, ".bcd"L] AND df.createtime = Time.Packed[0]      AND df.versionstamp # Time.Packed[0] AND df.presentonlocaldisk THEN {        MSegment.CopyIn[segment: bcdSeg, file: df.fHandle, fileBase: 0, count: 1];        IF df.versionstamp = bcd.version.time THEN {          df.createtime ¬ MFile.GetCreateDate[df.fHandle];	  fullname.length ¬ 0;          FileName.GetRemoteName[df.fHandle, fullname	    ! FileName.Error => CONTINUE];          IF fullname.length > 0 THEN {            vfn ¬ FileName.AllocVFN[fullname ! FileName.Error => CONTINUE];            IF vfn # NIL AND String.Equivalent[vfn.name, df.shortname]            AND vfn.host.length > 0 AND (IF (vfn.directory # NIL) THEN (vfn.directory.length > 0) ELSE FALSE) THEN {              IF df.host # NIL THEN Subr.FreeString[df.host, dfSeq.dfzone];              df.host ¬ Subr.CopyString[vfn.host, dfSeq.dfzone];              IF df.directory # NIL THEN                Subr.FreeString[df.directory, dfSeq.dfzone];              df.directory ¬ Subr.CopyString[vfn.directory, dfSeq.dfzone];	      FileName.FreeVFN[vfn];	      vfn ¬ NIL;              LOOP --avoid UseDefaults-- };	    IF vfn # NIL THEN FileName.FreeVFN[vfn]; vfn ¬ NIL}}}      ELSE {        IF df.createtime = Time.Packed[0] AND df.versionstamp # Time.Packed[0]	  THEN df.createtime ¬ df.versionstamp;        IF df.presentonlocaldisk AND df.createtime # Time.Packed[0]        AND df.createtime = MFile.GetCreateDate[df.fHandle] THEN {	  fullname.length ¬ 0;          FileName.GetRemoteName[df.fHandle, fullname	    ! FileName.Error => CONTINUE];          IF fullname.length > 0 THEN {            vfn ¬ FileName.AllocVFN[fullname ! FileName.Error => CONTINUE];            IF vfn # NIL AND String.Equivalent[vfn.name, df.shortname]            AND vfn.host.length > 0 AND vfn.directory.length > 0 THEN {              IF df.host # NIL THEN Subr.FreeString[df.host, dfSeq.dfzone];              df.host ¬ Subr.CopyString[vfn.host, dfSeq.dfzone];              IF df.directory # NIL THEN                Subr.FreeString[df.directory, dfSeq.dfzone];              df.directory ¬ Subr.CopyString[vfn.directory, dfSeq.dfzone];	      FileName.FreeVFN[vfn];	      vfn ¬ NIL;              LOOP --avoid UseDefaults-- };	    IF vfn # NIL THEN FileName.FreeVFN[vfn]; vfn ¬ NIL}}};      GOTO next;      EXITS next => UseDefaults[];      END;      ENDLOOP;    CleanUp[];    END};      SetSizeLessProps: PROCEDURE = {     NeededProps: FileTransfer.DesiredProperties = [      host:	   TRUE,      directory:   TRUE,      body:	   TRUE,      version:	   TRUE,      author:	   FALSE,      create:      TRUE,      read:        FALSE,      write:       FALSE,      size:	   FALSE, -- Note difference between this and TransferImpl.      type:	   TRUE,      oldFile:	   FALSE,   --writedate      readProtect: FALSE];  --readDate      Transfer.SetProps[NeededProps];    };  END.CHANGE LOG19-Jul-84 16:40:25	NSG	changed spare1 to accessDenied 7-May-85 15:37:31	DSC	Optimize for NS by using SetProps.25-Jun-85 14:59:44	kam	AnalyzeBcd.procMod couldn't handle a .bcd missing a source when analyzed more than once.?-Nov-85 ?		kam	AnalyzeBcd.procDep now skips a .bcd whose name begins with a question mark.12-Dec-85 10:48:54	kam	Checks imported dependency on non-bcd by verifying existence.18-Dec-85  9:23:29	kam	include imports in the analysis of bcds produced by linker.16-Jan-86 15:32:39	kam	When printing missing import's remote file name a missing directory created an address fault since it de-referenced vfn.directory. Check for NIL first.11-Feb-86 17:55:34	dsc	FIX AR #8715 procMod may gt NIL from DFSubr.NextDF and may write through that.12-Feb-86 13:07:45	dsc	Above fix more subtle than thought. change maxMissingFiles to 200.
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- TransferImpl.mesa - last edited by--   Brad&Richard	22-Feb-83 17:09:14--   BTL  		21-Nov-83 14:43:04--   NSG                19-Jul-84 16:24:06  --   DSC  		12-Feb-86 12:40:01DIRECTORY  Auth USING [IdentityHandle],  CWF USING [SWF2, SWF3, SWF4, W0, WF0, WF1, WF2],  Exec USING [CheckForAbort, Handle],  FileName USING [AllocVFN, Error, FreeVFN, SetRemoteName, VFN],  FileTransfer USING [    CheckAbortProc, ClientProc, Close, Connection, Copy, Create, Delete,    DesiredProperties, Destroy, Enumerate, Error, ErrorCode, FileInfo,    FileType, GetStreamName, GetStreamInfo, ListProc, MessageProc,    ReadStream, ReadNextStream, SetDesiredProperties, SetPrimaryCredentials,    SetProcs, SetSecondaryCredentials, StoreStream, VetoProc],  HeraldWindow USING [    CursorState, FreeCursorSlot, GetCursorSlot, SetCursor, SetCursorState, Slot],  MFile USING [    Acquire, AcquireTemp, AppendErrorMessage, ComputeFileType, CopyFileHandle,    Error, GetCreateDate, GetLength, GetType, Handle, maxNameLength,    Release, SetAccess, SetReadProtect, SetTimes, Type, WriteOnly],  MStream USING [Copy, Create, Error, Handle],  Profile USING [GetID, GetUser, String],  Stream USING [Delete, Handle, SetPosition],  String USING [    AppendChar, AppendString, Empty, Equivalent, InvalidNumber, StringToDecimal],  Subr USING [    AllocateWords, Confirm, CopyString, errorflg, FileError, FreeString,    FreeWords, GetNameandPassword],  Time USING [Packed],  Transfer USING [RetrieveProcType],  UserInput USING [UserAbort],  Window USING [Handle];TransferImpl: PROGRAM    IMPORTS      CWF, Exec, FileName, FileTransfer, HeraldWindow, MFile, MStream, Profile,      Stream, String, Subr, UserInput    EXPORTS Transfer =  BEGIN    accessDenied: FileTransfer.ErrorCode = FileTransfer.ErrorCode[accessDenied];    initialized: BOOLEAN ¬ FALSE;    execH: Exec.Handle ¬ NIL;  -- This could be an executive tool or a window tool.  wh: Window.Handle ¬ NIL;   -- for feedback; NIL => use exec  dfConn, copyConn: FileTransfer.Connection ¬ NIL;  remoteVFN: FileName.VFN ¬ NIL;  openRemoteStream: Stream.Handle ¬ NIL;  -- last (open) OpenRemoteStream stream  feedbackSlot: HeraldWindow.Slot ¬ NIL; -- Flipper responses.  feedbackState: {off, left, right} ¬ off; -- What are the flippers doing?  profileHits: CARDINAL ¬ 0; -- Determine how often we hit the Clearing House.  -- Secondary credential management. -- For an NS only world, this could be deleted.  lastDir, lastCopyDir: LONG STRING ¬ NIL;  connCredentials: ConnectCredentials ¬ NIL;  ConnectCredentials: TYPE = LONG POINTER TO ConnCredentialObject;  ConnCredentialObject: TYPE = RECORD [    link: ConnectCredentials ¬ NIL,    connDir, connPassword: LONG STRING ¬ NIL];  -- Initialize the globals.     Initialize: PUBLIC PROC [exec: Exec.Handle, window: Window.Handle] = {    IF ~initialized THEN {      IF exec = NIL AND window = NIL THEN {        CWF.WF0["Error - Internal error (Transfer.Initialize).\n"L];  RETURN};      execH ¬ exec;  wh ¬ window;  -- wh can be NIL => use execH      dfConn ¬ NIL;  copyConn ¬ NIL;  remoteVFN ¬ NIL;  openRemoteStream ¬ NIL;      lastDir ¬ NIL;  lastCopyDir ¬ NIL;  connCredentials ¬ NIL;      initialized ¬ TRUE}};      -- Get information from the Profile, and notify FileTransfer of it.  StartSession: PUBLIC PROC = BEGIN  -- reset primary credentials    IF dfConn # NIL THEN  SetPrimaryCredentials[conn: dfConn];  END; -- Of StartSession-- When done, free all data structures and connections.  Finalize: PUBLIC PROC = {    c, temp: ConnectCredentials;    IF initialized THEN {      IF openRemoteStream # NIL THEN CloseRemoteStream[openRemoteStream];        CloseConnection[];  CloseCopyConnection[];  ReleaseRemoteVFN[];      execH ¬ NIL;  wh ¬ NIL;      IF ~String.Empty[lastDir] THEN {        Subr.FreeString[lastDir];  lastDir ¬ NIL};      IF ~String.Empty[lastCopyDir] THEN {        Subr.FreeString[lastCopyDir];  lastCopyDir ¬ NIL};      c ¬ connCredentials;      WHILE c # NIL DO        temp ¬ c;  c ¬ c.link;	IF ~String.Empty[temp.connDir] THEN	  Subr.FreeString[temp.connDir];	IF ~String.Empty[temp.connPassword] THEN	  Subr.FreeString[temp.connPassword];	Subr.FreeWords[temp];  	ENDLOOP;      connCredentials ¬ NIL;        initialized ¬ FALSE}};    EnumerateForRetrieve: PUBLIC PROC [      fileName: LONG STRING, enumProc: Transfer.RetrieveProcType] = {    vfn: FileName.VFN ¬ NIL;    remoteStream: Stream.Handle;    temp: LONG STRING ¬ [150];    remoteName: LONG STRING ¬ NIL;    tryAgain, askedForConnect, skipRest: BOOLEAN;    Cleanup: PROC = {      IF remoteName # NIL THEN {        Subr.FreeString[remoteName];  remoteName ¬ NIL};      IF remoteStream # NIL AND remoteStream.delete # NIL THEN {        Stream.Delete[remoteStream];  remoteStream ¬ NIL};      IF vfn # NIL THEN {FileName.FreeVFN[vfn];  vfn ¬ NIL};      ClearBoxes[]};          BEGIN ENABLE UNWIND => Cleanup[];    OpenConnIfNeeded[];  ShowBoxes[];    vfn ¬ FileName.AllocVFN[fileName];    ResetConnCredentialsIfNewDir[vfn];    -- if unable to connect to remote directory    tryAgain ¬ TRUE;  askedForConnect ¬ FALSE;    WHILE tryAgain DO      tryAgain ¬ FALSE;  remoteStream ¬ NIL;      remoteStream ¬ FileTransfer.ReadStream[        conn: dfConn, files: vfn, veto: NIL, showDates: FALSE, type: remote        ! FileTransfer.Error =>            SELECT code FROM	      skipOperation =>	{CONTINUE};	      notFound =>	{CONTINUE};	      illegalLogin =>	{GetPrimaryCredentials[clientData: NIL];  RETRY};	      accessDenied =>   {	        IF ~askedForConnect THEN {		  GetConnectCredentials[conn, vfn.directory];		  tryAgain ¬ TRUE;  askedForConnect ¬ TRUE;  CONTINUE}		ELSE REJECT};  -- let client know about problem	      ENDCASE => REJECT];       ENDLOOP;    skipRest ¬ FALSE;    WHILE remoteStream # NIL DO      IF ~skipRest THEN {        CWF.SWF2[	  temp, "[%s]%s"L, vfn.host, FileTransfer.GetStreamName[remoteStream]];        remoteName ¬ Subr.CopyString[temp];	-- if unable to connect to remote directory (again)	tryAgain ¬ TRUE;  	WHILE tryAgain DO          tryAgain ¬ FALSE;          skipRest ¬ enumProc[remoteName, remoteStream	  ! FileTransfer.Error =>              SELECT code FROM	        accessDenied =>  -- might not be raised until actual read, etc. 	          IF ~askedForConnect THEN {		    GetConnectCredentials[conn, vfn.directory];		    tryAgain ¬ TRUE;  askedForConnect ¬ TRUE;  CONTINUE}		  ELSE REJECT;  -- let client know about problem	        ENDCASE => REJECT];	  ENDLOOP;        Subr.FreeString[remoteName];  remoteName ¬ NIL};      remoteStream ¬ FileTransfer.ReadNextStream[remoteStream];      ENDLOOP;    Cleanup[];    END};      EnumerateForProperties: PUBLIC PROC [      fileName: LONG STRING, enumProc: FileTransfer.ListProc] = {    vfn: FileName.VFN ¬ NIL;    tryAgain, askedForConnect: BOOLEAN;        Cleanup: PROC = {      IF vfn # NIL THEN {FileName.FreeVFN[vfn];  vfn ¬ NIL};      ClearBoxes[]};        BEGIN ENABLE UNWIND => Cleanup[];    OpenConnIfNeeded[];  ShowBoxes[];    vfn ¬ FileName.AllocVFN[fileName];    ResetConnCredentialsIfNewDir[vfn];    -- if unable to connect to remote directory    tryAgain ¬ TRUE;  askedForConnect ¬ FALSE;    WHILE tryAgain DO      tryAgain ¬ FALSE;      FileTransfer.Enumerate[conn: dfConn, files: vfn, proc: enumProc        ! FileTransfer.Error =>            SELECT code FROM	      skipOperation     => CONTINUE;	      notFound => CONTINUE;	      illegalLogin => {	          GetPrimaryCredentials[clientData: NIL];  		  RETRY};	      accessDenied => 	        IF ~askedForConnect THEN {		  GetConnectCredentials[conn, vfn.directory];		  tryAgain ¬ TRUE;  askedForConnect ¬ TRUE;  CONTINUE}		ELSE CONTINUE;	      ENDCASE  => REJECT];      ENDLOOP;    Cleanup[];    END};      OpenRemoteStream: PUBLIC PROC [      host, fileName: LONG STRING] RETURNS [s: Stream.Handle] = {    remoteName: STRING ¬ [150];    tryAgain, askedForConnect: BOOLEAN;    s ¬ NIL;  openRemoteStream ¬ NIL;    BEGIN ENABLE UNWIND => CloseRemoteStream[s];    OpenConnIfNeeded[];  ShowBoxes[];    CWF.SWF2[remoteName, "[%s]%s"L, host, fileName];    remoteVFN ¬ FileName.AllocVFN[remoteName];    ResetConnCredentialsIfNewDir[remoteVFN];    -- if unable to connect to remote directory    tryAgain ¬ TRUE;  askedForConnect ¬ FALSE;    WHILE tryAgain DO      tryAgain ¬ FALSE;      s ¬ FileTransfer.ReadStream[        conn: dfConn, files: remoteVFN, veto: NIL, showDates: FALSE, type: remote        ! FileTransfer.Error =>            SELECT code FROM	      skipOperation     => CONTINUE;	      notFound => CONTINUE;	      illegalParameters => ERROR Subr.FileError[notFound];	      illegalLogin => {GetPrimaryCredentials[clientData: NIL];  RETRY};	      accessDenied => 	        IF ~askedForConnect THEN {		  GetConnectCredentials[conn, remoteVFN.directory];		  tryAgain ¬ TRUE;  askedForConnect ¬ TRUE;  CONTINUE}		ELSE CONTINUE;	      ENDCASE  => REJECT];      ENDLOOP;    END;    IF s = NIL THEN {      ReleaseRemoteVFN[];  ClearBoxes[];  ERROR Subr.FileError[notFound]};    openRemoteStream ¬ s;    RETURN[s]};      CloseRemoteStream: PUBLIC PROC [s: Stream.Handle] = {    IF s # NIL THEN {      IF s.delete # NIL THEN Stream.Delete[s]};    openRemoteStream ¬ NIL;    ReleaseRemoteVFN[];    ClearBoxes[]};      ReleaseRemoteVFN: PROC = {    IF remoteVFN # NIL THEN {FileName.FreeVFN[remoteVFN];  remoteVFN ¬ NIL}};      GetStreamCreation: PUBLIC PROC [s: Stream.Handle] RETURNS [Time.Packed] = {    info: FileTransfer.FileInfo;    IF s = NIL THEN {      CWF.WF0["Error - Internal error (Transfer.GetStreamCreation).\n"L];      RETURN[Time.Packed[0]]};    info ¬ FileTransfer.GetStreamInfo[s];    RETURN[info.create]};      GetStreamLength: PUBLIC PROC [s: Stream.Handle] RETURNS [LONG CARDINAL] = {    info: FileTransfer.FileInfo ¬ NIL;    IF s = NIL THEN {      CWF.WF0["Error - Internal error (Transfer.GetStreamLength).\n"L];      RETURN[0]};    info ¬ FileTransfer.GetStreamInfo[s];    RETURN[info.size]};      -- Returns stream on local file (might retrieve from remote location)   -- Raises Subr.FileError if can't find file locally or remotely  -- If wantExplicitVersion is true, wantCreateTime = 0, and version > 0, then  --   gets that version; otherwise gets !H when wantCreateTime = 0  CachedOpen: PUBLIC PROC [        host, directory, name: LONG STRING,	wantCreateTime: Time.Packed,	wantExplicitVersion: BOOLEAN, version: CARDINAL,	checkForOverwrite: BOOLEAN ¬ TRUE, window: Window.Handle, -- overwrite?	retrieveToTemp: BOOLEAN ¬ FALSE, localDir: LONG STRING ¬ NIL]      RETURNS [s: MStream.Handle] = {    f: MFile.Handle;    localName: STRING ¬ [MFile.maxNameLength];    OpenConnIfNeeded[];    IF ~retrieveToTemp AND ~String.Empty[localDir] THEN {      IF localDir[0] # '< AND localDir[0] # '> THEN        String.AppendString[localName, "<>"L];      String.AppendString[localName, localDir];      IF localDir[localDir.length-1] # '> THEN String.AppendChar[localName, '>]};    String.AppendString[localName, name];    f ¬ CachedRetrieve[      host, directory, name, localName,      wantCreateTime,      wantExplicitVersion, version,        checkForOverwrite, window,      retrieveToTemp, localDir];    IF f # NIL THEN      s ¬ MStream.Create[f, [] ! MStream.Error => ERROR Subr.FileError[notFound]]    ELSE s ¬ NIL;    RETURN[s]};  CachedRetrieve: PROC [        host, directory, name, localName: LONG STRING,	wantCreateTime: Time.Packed,	wantExplicitVersion: BOOLEAN, version: CARDINAL,	checkForOverwrite: BOOLEAN ¬ TRUE, window: Window.Handle, -- overwrite?	retrieveToTemp: BOOLEAN ¬ FALSE, localDir: LONG STRING ¬ NIL]      RETURNS [f: MFile.Handle] = {    ENABLE UNWIND => {IF f # NIL THEN {MFile.Release[f];  f ¬ NIL}};    localOnly: BOOLEAN ¬ String.Empty[host];    localTime: Time.Packed ¬ [0];    -- look on local disk    f ¬ MFile.Acquire[name: localName, access: anchor, release: []      ! MFile.Error => {f ¬ NIL;  CONTINUE}];    IF f # NIL THEN {      localTime ¬ MFile.GetCreateDate[f];      IF wantCreateTime = localTime      OR (wantCreateTime = Time.Packed[0] AND localOnly) THEN {   -- f is OK        MFile.SetAccess[file: f, access: readOnly];        RETURN[f]}};    -- look on remote server    IF localOnly THEN {      IF f # NIL THEN {MFile.Release[f];  f ¬ NIL};  -- f isn't the right one      ERROR Subr.FileError[notFound]}    ELSE {        foundOnRemote, foundOneVersion, userDeclined: BOOLEAN ¬ FALSE;      fn: STRING ¬ [150];      ConsiderFile: Transfer.RetrieveProcType = {        info: FileTransfer.FileInfo;        remoteTime: Time.Packed;        IF foundOnRemote THEN RETURN[skipRest: TRUE];        foundOneVersion ¬ TRUE;        info ¬ FileTransfer.GetStreamInfo[s];        remoteTime ¬ info.create;        IF localTime = remoteTime AND wantCreateTime = Time.Packed[0] THEN {          foundOnRemote ¬ TRUE;	  RETURN[skipRest: TRUE]};        IF wantCreateTime = remoteTime OR wantCreateTime = Time.Packed[0] THEN {          foundOnRemote ¬ TRUE;          IF checkForOverwrite AND ~retrieveToTemp	  AND localTime # Time.Packed[0] THEN            SELECT CheckForOverwrite[                localName:  localName, localCreate:  localTime,	        remoteName: fileName,  remoteCreate: remoteTime,	        window:     window] FROM	      yes      => NULL;	      no       => {userDeclined ¬ TRUE;  RETURN[skipRest: TRUE]};	      useLocal => RETURN[skipRest: TRUE];	      ENDCASE;          IF retrieveToTemp THEN	    CWF.WF1["Fetching %s to temp file..."L, fileName]	  ELSE IF ~String.Empty[localDir] THEN	    CWF.WF2["Retrieving %s to %s..."L, fileName, localName]	  ELSE CWF.WF1["Retrieving %s..."L, fileName];	  IF f # NIL THEN {MFile.Release[f]; f ¬ NIL};	  f ¬ RetrieveBits[	    localName: localName, remoteName: fileName,	    retrieveToTemp: retrieveToTemp, info: info,	    remoteTime: remoteTime, remoteStream: s];	  RETURN[skipRest: TRUE]};        RETURN[skipRest: FALSE]};      IF CheckIfAborted[NIL] THEN ERROR ABORTED;      IF wantCreateTime = Time.Packed[0]      AND wantExplicitVersion AND version > 0 THEN         CWF.SWF4[fn, "[%s]<%s>%s!%u"L, host, directory, name, @version]      ELSE        IF wantCreateTime = Time.Packed[0] THEN  -- take the highest version          CWF.SWF3[fn, "[%s]<%s>%s"L, host, directory, name]        ELSE	  CWF.SWF3[fn, "[%s]<%s>%s!*"L, host, directory, name];      ShowBoxes[];      BEGIN ENABLE UNWIND => ClearBoxes[];      EnumerateForRetrieve[fn, ConsiderFile        ! FileTransfer.Error =>	    SELECT code FROM	      notFound       => CONTINUE;	      illegalLogin   => {GetPrimaryCredentials[clientData: NIL];  RETRY};	      skipOperation           => CONTINUE;	      cantModify     => CONTINUE;	      retry          => {		foundOnRemote ¬ foundOneVersion ¬ userDeclined ¬ FALSE;		RETRY};	      ENDCASE => REJECT];      END;      ClearBoxes[];      IF ~foundOnRemote THEN {  -- never found correct version        IF f # NIL THEN {MFile.Release[f];  f ¬ NIL};        ERROR Subr.FileError[IF foundOneVersion THEN wrongVersion ELSE notFound]}      ELSE IF userDeclined THEN {	IF f # NIL THEN {MFile.Release[f];  f ¬ NIL};	RETURN[NIL]};      MFile.SetAccess[file: f, access: readOnly];  -- use local file      RETURN[f]}};      RetrieveBits: PROC [        localName, remoteName: LONG STRING, retrieveToTemp: BOOLEAN,	info: FileTransfer.FileInfo,	remoteTime: Time.Packed, remoteStream: Stream.Handle]      RETURNS [f: MFile.Handle] = {    copy: MFile.Handle ¬ NIL;    local: MStream.Handle ¬ NIL;    actualBytes: LONG CARDINAL;    BEGIN ENABLE UNWIND => {      IF local # NIL THEN {Stream.Delete[local];  local ¬ NIL;  copy ¬ NIL};      IF copy # NIL THEN {MFile.Release[copy];  copy ¬ NIL};      IF f # NIL THEN {MFile.Release[f];  f ¬ NIL}};    f ¬ NIL;    FeedbackProgress[NIL];    IF retrieveToTemp THEN      f ¬ MFile.AcquireTemp[        type: MFileTypeFor[info.type], initialLength: info.size        ! MFile.Error => {            msg: STRING ¬ [100];            MFile.AppendErrorMessage[msg, code, file];            CWF.WF1["MFile error: %s.\n"L, msg];               ERROR Subr.FileError[accessConflict]}]    ELSE      f ¬ MFile.WriteOnly[        name: localName, release: [], type: MFileTypeFor[info.type],        initialLength: info.size        ! MFile.Error => {            msg: STRING ¬ [100];            MFile.AppendErrorMessage[msg, code, file];            CWF.WF1["MFile error: %s.\n"L, msg];               ERROR Subr.FileError[accessConflict]}];    copy ¬ MFile.CopyFileHandle[f, [], writeOnly];    local ¬ MStream.Create[copy, []      ! MStream.Error => ERROR Subr.FileError[accessConflict]];    IF ~retrieveToTemp THEN       MFile.SetReadProtect[file: copy, readProtected: TRUE];    FeedbackProgress[NIL];    actualBytes ¬ MStream.Copy[from: remoteStream, to: local, bytes: info.size];    FeedbackProgress[NIL];    IF ~retrieveToTemp THEN {       MFile.SetReadProtect[file: copy, readProtected: FALSE];      MFile.SetTimes[file: copy, create: remoteTime];      FileName.SetRemoteName[copy, remoteName ! FileName.Error => CONTINUE]};    Stream.Delete[local];  local ¬ NIL;  copy ¬ NIL;    MFile.SetAccess[f, readOnly      ! MFile.Error => ERROR Subr.FileError[accessConflict]];    IF actualBytes # info.size THEN {        CWF.WF2[        "\n\tWarning - %lu bytes retrieved, but remote length is %lu bytes.\n"L,        @actualBytes, @info.size];      Subr.errorflg ¬ TRUE}    ELSE CWF.WF1["%lu bytes.\n"L, @info.size];    FeedbackProgress[NIL];    END};  	    MFileTypeFor: PROC [type: FileTransfer.FileType] RETURNS [MFile.Type] = {    RETURN[      SELECT type FROM        unknown   => unknown,        text      => text,        binary    => binary,        directory => directory,	ENDCASE   => unknown]};	    FileTransferTypeFor: PROC [type: MFile.Type] RETURNS [FileTransfer.FileType] = {    RETURN[      SELECT type FROM        unknown   => unknown,        text      => text,        binary    => binary,        directory => directory,	ENDCASE   => unknown]};  CheckForOverwrite: PROC [        localName:  LONG STRING, localCreate:  Time.Packed,	remoteName: LONG STRING, remoteCreate: Time.Packed,	window: Window.Handle]      RETURNS [answer: {yes, no, useLocal}] = {    validResponse: BOOLEAN ¬ FALSE;    ch: CHARACTER;    CWF.WF2["Ok to retrieve %s of %lt,\n"L, remoteName, @remoteCreate];    UNTIL validResponse DO      IF remoteCreate < localCreate THEN        CWF.WF2[          "\tand overwrite NEWER local file %s of %lt "L, localName, @localCreate]      ELSE        CWF.WF2[          "\tand overwrite older local file %s of %lt "L,	  localName, @localCreate];      ch ¬ Subr.Confirm[defaultChar: 'y, window: window];      SELECT ch FROM        'y => {CWF.WF0[" Yes"L];  RETURN[yes]};	'n => {CWF.WF0[" No.\n"L];   validResponse ¬ TRUE};        'q => {CWF.WF0[" Quit.\n"L]; ERROR ABORTED};	ENDCASE => CWF.WF0[" ? (please reply one of y, n, a, q).\n"L];      ENDLOOP;    DO      CWF.WF0["\tShould the local version be used"L];      ch ¬ Subr.Confirm[defaultChar: 'n, window: window];      SELECT ch FROM        'y => {CWF.WF0[" Yes.\n"L];  RETURN[useLocal]};        'n => {CWF.WF0[" No.\n"L];   RETURN[no]};        'q => {CWF.WF0[" Quit.\n"L]; ERROR ABORTED};        ENDCASE => CWF.WF0[" ? (please reply one of y, n, a, q).\n"L];      ENDLOOP};          Store: PUBLIC PROC [        file: MFile.Handle, localDate: Time.Packed, remoteName: LONG STRING]      RETURNS [        stored, serverFull: BOOLEAN, nBytes: LONG CARDINAL, version: CARDINAL] = {    fileType: MFile.Type;    vfn: FileName.VFN ¬ NIL;    copy: MFile.Handle ¬ NIL;    localStream: MStream.Handle ¬ NIL;    tryAgain, askedForConnect: BOOLEAN;        CleanUp: PROC = {      IF localStream # NIL THEN {        Stream.Delete[localStream];  localStream ¬ NIL;  copy ¬ NIL};      IF copy # NIL THEN {MFile.Release[copy];  copy ¬ NIL};      IF vfn # NIL THEN FileName.FreeVFN[vfn];      ClearBoxes[]};        BEGIN ENABLE UNWIND => CleanUp[];    stored ¬ TRUE;  serverFull ¬ FALSE;  nBytes ¬ 0;  version ¬ 0;    OpenConnIfNeeded[];  ShowBoxes[];    vfn ¬ FileName.AllocVFN[remoteName];    ResetConnCredentialsIfNewDir[vfn];    copy ¬ MFile.CopyFileHandle[      file: file, release: [], access: readOnly      ! MFile.Error => ERROR Subr.FileError[accessConflict]];    localStream ¬ MStream.Create[file: copy, release: []      ! MStream.Error => ERROR Subr.FileError[accessConflict]];    nBytes ¬ MFile.GetLength[file];  fileType ¬ MFile.GetType[file];    IF fileType = unknown THEN fileType ¬ MFile.ComputeFileType[file];    -- if unable to connect to remote directory    tryAgain ¬ TRUE;  askedForConnect ¬ FALSE;    WHILE tryAgain DO      tryAgain ¬ FALSE;  stored ¬ TRUE;        FileTransfer.StoreStream[        conn: dfConn, remote: vfn, stream: localStream, creation: localDate,	bytes: nBytes, fileType: FileTransferTypeFor[fileType]        ! FileTransfer.Error =>            SELECT code FROM	      skipOperation  => {stored ¬ FALSE;  CONTINUE};	      retry => {	        localStream.SetPosition[0];		RETRY};  	      illegalLogin => {GetPrimaryCredentials[clientData: NIL];  RETRY};	      accessDenied => {	        stored ¬ FALSE;	        IF ~askedForConnect THEN {		  GetConnectCredentials[conn, vfn.directory];		  tryAgain ¬ TRUE;  askedForConnect ¬ TRUE;  CONTINUE}		ELSE CONTINUE};	      cantModify => {	        stored ¬ FALSE;  ERROR Subr.FileError[accessConflict]};	      directoryFull => {	        stored ¬ FALSE;  serverFull ¬ TRUE;  CONTINUE};	      ENDCASE => {stored ¬ FALSE;  REJECT}];      IF stored THEN {        IF String.Empty[vfn.version] THEN version ¬ 0	ELSE version ¬ String.StringToDecimal[vfn.version          ! String.InvalidNumber => {version ¬ 0;  CONTINUE}]}      ENDLOOP;    IF ~stored THEN version ¬ 0;    END;    CleanUp[]};        Delete: PUBLIC PROC [fileName: LONG STRING] = {    vfn: FileName.VFN ¬ NIL;    tryAgain, askedForConnect: BOOLEAN;        CleanUp: PROC = {      IF vfn # NIL THEN {FileName.FreeVFN[vfn];  vfn ¬ NIL};      ClearBoxes[]};        BEGIN ENABLE UNWIND => CleanUp[];    OpenConnIfNeeded[];  ShowBoxes[];    vfn ¬ FileName.AllocVFN[fileName];    ResetConnCredentialsIfNewDir[vfn];    -- if unable to connect to remote directory    tryAgain ¬ TRUE;  askedForConnect ¬ FALSE;    WHILE tryAgain DO      tryAgain ¬ FALSE;        FileTransfer.Delete[conn: dfConn, file: vfn, veto: NIL        ! FileTransfer.Error =>            SELECT code FROM	      illegalLogin => {GetPrimaryCredentials[clientData: NIL];  RETRY};	      accessDenied => 	        IF ~askedForConnect THEN {		  GetConnectCredentials[conn, vfn.directory];		  tryAgain ¬ TRUE;  askedForConnect ¬ TRUE;  CONTINUE}		ELSE CONTINUE;	      ENDCASE];      ENDLOOP;    CleanUp[];    END};        OpenCopyConnection: PUBLIC PROC = {    OpenConnIfNeeded[];    copyConn ¬ FileTransfer.Create[];    FileTransfer.SetProcs[      conn: copyConn, clientData: NIL,       messages: PutMessages, login: GetPrimaryCredentialsForCopy,      checkAbort: CheckIfAborted];    SetPrimaryCredentials[conn: copyConn]};    GetPrimaryCredentialsForCopy: FileTransfer.ClientProc = {    SetPrimaryCredentials[conn: copyConn];  };      CloseCopyConnection: PUBLIC PROC = {    IF copyConn # NIL THEN {      FileTransfer.Close[copyConn];  FileTransfer.Destroy[copyConn];      copyConn ¬ NIL}};       Copy: PUBLIC PROC [fromName, toName: LONG STRING]      RETURNS [        stored, serverFull: BOOLEAN, nBytes: LONG CARDINAL, version: CARDINAL] = {    sourceVFN, destVFN: FileName.VFN ¬ NIL;    tryAgain, askedForConnect: BOOLEAN;          CleanUp: PROC = {      IF sourceVFN # NIL THEN {FileName.FreeVFN[sourceVFN];  sourceVFN ¬ NIL};      IF destVFN # NIL THEN {FileName.FreeVFN[destVFN];  destVFN ¬ NIL};      ClearBoxes[]};        GetFileLength: FileTransfer.VetoProc = {      data: FileTransfer.FileInfo ¬ info[copyConn].source;      nBytes ¬ data.size;      RETURN[confirm: do, showDates: FALSE]};        BEGIN ENABLE UNWIND => CleanUp[];    stored ¬ TRUE;  serverFull ¬ FALSE;  nBytes ¬ 0;  version ¬ 0;    OpenConnIfNeeded[];    sourceVFN ¬ FileName.AllocVFN[fromName];    ResetConnCredentialsIfNewDir[sourceVFN];    destVFN ¬ FileName.AllocVFN[toName];    ResetCopyConnCredentialsIfNewDir[destVFN];    -- if unable to connect to remote directory    tryAgain ¬ TRUE;  askedForConnect ¬ FALSE;    WHILE tryAgain DO      tryAgain ¬ FALSE;  stored ¬ TRUE;        FileTransfer.Copy[        sourceFile: sourceVFN, destFile: destVFN,        sourceConn: dfConn, destConn: copyConn,	veto: GetFileLength, showDates: FALSE        ! FileTransfer.Error =>            SELECT code FROM	      skipOperation,skipFile  => {stored ¬ FALSE;  CONTINUE};	      illegalLogin => {GetPrimaryCredentials[clientData: NIL];  RETRY};	      accessDenied => {	        stored ¬ FALSE;	        IF ~askedForConnect THEN {		  GetConnectCredentials[conn, destVFN.directory];		  tryAgain ¬ TRUE;  askedForConnect ¬ TRUE;  CONTINUE}		ELSE CONTINUE};	      notFound, illegalParameters => {	        stored ¬ FALSE;  version ¬ 1234;  -- need a better indication		CONTINUE};	      directoryFull => {	        stored ¬ FALSE;  serverFull ¬ TRUE;  CONTINUE};	      ENDCASE => {stored ¬ FALSE;  CONTINUE}];      IF stored THEN {        IF String.Empty[destVFN.version] THEN version ¬ 0	ELSE version ¬ String.StringToDecimal[destVFN.version          ! String.InvalidNumber => {version ¬ 0;  CONTINUE}]}      ENDLOOP;    IF ~stored THEN version ¬ 0;    CleanUp[];    END};      -- Connection management-- Secondary credentials only matter for IFS's "Connects". NS Servers only work with primary credentials.  OpenConnIfNeeded: PROC = {IF dfConn = NIL THEN OpenConnection[]};    SetPrimaryCredentials: PROCEDURE[conn: FileTransfer.Connection] = {    SetUser: PROC [name, password: Profile.String] = {      FileTransfer.SetPrimaryCredentials[conn: conn, user: name, password: password];     };    SetID: PROCEDURE [id: Auth.IdentityHandle] = {      FileTransfer.SetPrimaryCredentials[conn: conn, id: id]};        -- Debugging to find out how often we hit Authentication    profileHits ¬ profileHits + 1;    --CWF.WF1["CH{#%u}\n", @profileHits];    Profile.GetUser[proc: SetUser];    Profile.GetID[proc: SetID];  };   OpenConnection: PROC = {    feedbackSlot ¬ HeraldWindow.GetCursorSlot[];    IF feedbackSlot # NIL THEN {      HeraldWindow.SetCursor[slot: feedbackSlot, cursor: blank];      feedbackState ¬ off};    dfConn ¬ FileTransfer.Create[];    FileTransfer.SetProcs[      conn: dfConn, clientData: NIL,       messages: PutMessages, login: GetPrimaryCredentials,       noteProgress: FeedbackProgress, checkAbort: CheckIfAborted];    SetPrimaryCredentials[conn: dfConn];    SetDefaultProcs[];  };      PutMessages: FileTransfer.MessageProc = {      PutMsg: PROC = {      IF s1 # NIL THEN CWF.W0[s1];      IF s2 # NIL THEN CWF.W0[s2];      IF s3 # NIL THEN CWF.W0[s3];      IF s4 # NIL THEN CWF.W0[s4]};          -- Caused error messages like: Error: Error Error: Error: remoteSystemNotResponsing.    -- CWF.WF0["Error: "L];    IF level = fatal THEN {      PutMsg[];    }};      GetPrimaryCredentials: FileTransfer.ClientProc = {   name: LONG STRING ¬ [100];   password: LONG STRING ¬ [100];   -- Set new Profile entries and THEN do the transfer stuff....   -- login sets the Profile as a SIDE EFFECT.    Subr.GetNameandPassword[login, name, password, wh];    SetPrimaryCredentials[conn: dfConn];   };     -- This applies only to IFS (Pup-based) servers which allow connects to specified directories.  ResetConnCredentialsIfNewDir: PROC [vfn: FileName.VFN] = {    IF ~String.Empty[lastDir] AND ~String.Empty[vfn.directory] THEN {      dir: STRING ¬ [100];      start: CARDINAL = (IF vfn.directory[0] = '< THEN 1 ELSE 0);      len: CARDINAL = vfn.directory.length;      FOR i: CARDINAL IN [start..len) DO        IF vfn.directory[i] = '> THEN EXIT;        String.AppendChar[dir, vfn.directory[i]];        ENDLOOP;      IF String.Equivalent[dir, lastDir] THEN RETURN;  -- no change in directory      FOR c: ConnectCredentials ¬ connCredentials, c.link WHILE c # NIL DO         IF String.Equivalent[dir, c.connDir] THEN {  -- we have credentials          FileTransfer.SetSecondaryCredentials[dfConn, c.connDir, c.connPassword];	  Subr.FreeString[lastDir];  lastDir ¬ Subr.CopyString[c.connDir];	  RETURN};        ENDLOOP;      FileTransfer.SetSecondaryCredentials[dfConn, NIL, NIL];      Subr.FreeString[lastDir];  lastDir ¬ Subr.CopyString[dir]}};      ResetCopyConnCredentialsIfNewDir: PROC [destVfn: FileName.VFN] = {    IF ~String.Empty[lastCopyDir] AND ~String.Empty[destVfn.directory] THEN {      dir: STRING ¬ [100];      start: CARDINAL = (IF destVfn.directory[0] = '< THEN 1 ELSE 0);      len: CARDINAL = destVfn.directory.length;      FOR i: CARDINAL IN [start..len) DO        IF destVfn.directory[i] = '> THEN EXIT;        String.AppendChar[dir, destVfn.directory[i]];        ENDLOOP;      IF String.Equivalent[dir, lastCopyDir] THEN RETURN;  -- no change      FOR c: ConnectCredentials ¬ connCredentials, c.link WHILE c # NIL DO         IF String.Equivalent[dir, c.connDir] THEN {  -- we have credentials          FileTransfer.SetSecondaryCredentials[	    copyConn, c.connDir, c.connPassword];	  Subr.FreeString[lastCopyDir];  lastCopyDir ¬ Subr.CopyString[c.connDir];	  RETURN};        ENDLOOP;      FileTransfer.SetSecondaryCredentials[copyConn, NIL, NIL];      Subr.FreeString[lastCopyDir];        lastCopyDir ¬ Subr.CopyString[dir]}};      GetConnectCredentials: PROC [      conn: FileTransfer.Connection, dir: LONG STRING] = {    start: CARDINAL;    connDir: STRING ¬ [100];    connPassword: STRING ¬ [60];    c: ConnectCredentials;    IF ~String.Empty[dir] THEN {      start ¬ (IF dir[0] = '< THEN 1 ELSE 0);      FOR i: CARDINAL IN [start..dir.length) DO        IF dir[i] = '> THEN EXIT;        String.AppendChar[connDir, dir[i]];        ENDLOOP;      FOR c ¬ connCredentials, c.link WHILE c # NIL DO         IF String.Equivalent[connDir, c.connDir] THEN {          FileTransfer.SetSecondaryCredentials[conn, c.connDir, c.connPassword];	  Subr.FreeString[lastDir];	  lastDir ¬ Subr.CopyString[c.connDir];	  RETURN};        ENDLOOP};    Subr.GetNameandPassword[connect, connDir, connPassword, wh];    FileTransfer.SetSecondaryCredentials[conn, connDir, connPassword];    c ¬ Subr.AllocateWords[SIZE[ConnCredentialObject]];    c­ ¬ ConnCredentialObject[      link:         connCredentials,      connDir:      Subr.CopyString[connDir],      connPassword: Subr.CopyString[connPassword]];    connCredentials ¬ c;    Subr.FreeString[lastDir];    lastDir ¬ Subr.CopyString[connDir]};      RegisterConnCredentials: PUBLIC PROC [dir, password: LONG STRING] = {    connDir: STRING ¬ [100];    start: CARDINAL;    c: ConnectCredentials;    IF String.Empty[dir] THEN RETURN;    start ¬ (IF dir[0] = '< THEN 1 ELSE 0);    FOR i: CARDINAL IN [start..dir.length) DO      IF dir[i] = '> THEN EXIT;      String.AppendChar[connDir, dir[i]];      ENDLOOP;    FOR c ¬ connCredentials, c.link WHILE c # NIL DO      IF String.Equivalent[connDir, c.connDir] THEN {        Subr.FreeString[c.connPassword];	c.connPassword ¬ Subr.CopyString[password];	RETURN};      ENDLOOP;    c ¬ Subr.AllocateWords[SIZE[ConnCredentialObject]];    c­ ¬ ConnCredentialObject[      link:         connCredentials,      connDir:      Subr.CopyString[connDir],      connPassword: Subr.CopyString[password]];    connCredentials ¬ c};          -- NS Server optimization    SetProps: PUBLIC PROC [props: FileTransfer.DesiredProperties] = {    IF dfConn # NIL THEN  FileTransfer.SetDesiredProperties[conn: dfConn, props: props];  };    SetDefaultProcs: PUBLIC PROC = {    NeededProps: FileTransfer.DesiredProperties = [      host:	   TRUE,      directory:   TRUE,      body:	   TRUE,      version:	   TRUE,      author:	   FALSE,      create:      TRUE,      read:        FALSE,      write:       FALSE,      size:	   TRUE,      type:	   TRUE,      oldFile:	   FALSE,   --writedate      readProtect: FALSE];  --readDate    IF dfConn # NIL THEN FileTransfer.SetDesiredProperties[conn: dfConn, props: NeededProps];  };-- Flipper support.  ShowBoxes: PROC = {    IF feedbackSlot # NIL THEN {      HeraldWindow.SetCursor[slot: feedbackSlot, cursor: ftpBoxes];      feedbackState ¬ left}};      ClearBoxes: PROC = {    IF feedbackSlot # NIL THEN {      HeraldWindow.SetCursor[slot: feedbackSlot, cursor: blank];      feedbackState ¬ off}};    -- Shuffle the flippers.  FeedbackProgress: FileTransfer.ClientProc = {    cursorState: HeraldWindow.CursorState;    IF feedbackSlot # NIL THEN {      SELECT feedbackState FROM        off     => {	  HeraldWindow.SetCursor[slot: feedbackSlot, cursor: ftpBoxes];	  cursorState ¬ negative;  feedbackState ¬ left};         left    => {cursorState ¬ positive;  feedbackState ¬ right}; 	ENDCASE => {cursorState ¬ negative;  feedbackState ¬ left};      HeraldWindow.SetCursorState[slot: feedbackSlot, state: cursorState]}}; --   Do the proper type of abort checking dependig on the interface used.   CheckIfAborted: FileTransfer.CheckAbortProc = {    IF wh # NIL THEN {IF UserInput.UserAbort[wh] THEN RETURN[abort: TRUE]}    ELSE IF Exec.CheckForAbort[execH] THEN RETURN[abort: TRUE];    RETURN[abort: FALSE]};         CloseConnection: PROC = {    IF feedbackSlot # NIL THEN {       feedbackSlot ¬ HeraldWindow.FreeCursorSlot[feedbackSlot];      feedbackState ¬ off};    IF dfConn # NIL THEN {      FileTransfer.Close[dfConn];  FileTransfer.Destroy[dfConn];  dfConn ¬ NIL}};      END.Change log19-Jul-84 16:24:06	NSG   	changed spare1 to accessDenied & skip to skipOperation7-Sep-84 15:31:49	DSC  	Added a call to Profile.GetID.25-Sep-84 11:46:42	DSC  	Delete employee names.24-Oct-84 16:10:37	DSC  	Added more Profile.GetID's. I missed some before...26-Oct-84 12:37:11	DSC  	Merged authentication code to a single PROCEDURE.29-Oct-84  9:59:55	DSC  	Found out that the new FileTransfer will authenticate the user each time credentials are set. The old one avoided that if the name and password remained the same. May need to change that. We found out the problem when the NS phase 3 took ~= 10 sec/authentication, which may have happened once per file.  1-Nov-84 15:51:59	DSC  	Prompt for name and password when you GetPrimaryCredentials...22-Jan-85 17:50:45	DSC  	Fixed MFile release bug thanks to BLewis. f not set to NIL after releasing 6-May-85 16:22:07	DSC  	Added SetProps. 7-May-85 16:51:22	DSC  	Make SetProps work on non-NIL dfConn.11-Feb-86 11:16:37	DSC  	Stop error messages like: Error: Error Error: Error: remoteSystemNotResponsing via fixing PutMessages: FileTransfer.MessageProc12-Feb-86 12:40:09	DSC  	Filter PutMessages on severity.						Things to fix:There's a LOT of duplicated FileTransfer ERROR catching going on. Perhaps I could create a common entry procedure and enable a catch phrase. Most of it has to do with authentication anyway.
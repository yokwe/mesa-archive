-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- LeafSubrImpl.mesa - Last edited by--   Schmidt	23-Jan-82 16:09:16--   BTL   	26-Sep-83 13:47:07DIRECTORY  Environment USING [bytesPerPage, wordsPerPage],  LeafSubr USING [FHObject, FileHandle],  MSegment USING [Address, Pages, Handle],  Stream USING [EndOfStream, GetBlock],  Subr USING [CopyString, FreeString],  Time USING [Packed],  Transfer USING [    CloseRemoteStream, GetStreamCreation, GetStreamLength, OpenRemoteStream];LeafSubrImpl: PROGRAM    IMPORTS MSegment, Stream, Subr, Transfer    EXPORTS LeafSubr =  BEGIN    UsageError: ERROR [msg: STRING] = CODE;    fhObject: LeafSubr.FHObject ¬ [    allocated: FALSE, host: NIL, sfn: NIL, stream: NIL, nextPageToRead: 0];      StartLeaf: PUBLIC PROC = {};    StopLeaf: PUBLIC PROC = {IF fhObject.allocated THEN Close[@fhObject]};   Open: PUBLIC PROC [host, sfn: LONG STRING] RETURNS [fh: LeafSubr.FileHandle] = {    ENABLE UNWIND => {fh.allocated ¬ FALSE};    fh ¬ @fhObject;    IF fh.allocated THEN ERROR UsageError["More than one 'Leaf' connection open"L];    fh.allocated ¬ TRUE;    fh.stream ¬ Transfer.OpenRemoteStream[host, sfn];    fh.host ¬ Subr.CopyString[host];  fh.sfn ¬ Subr.CopyString[sfn];    fh.nextPageToRead ¬ 0};      Close: PUBLIC PROC [fh: LeafSubr.FileHandle] = {    IF ~fh.allocated THEN ERROR UsageError["No 'Leaf' connection open"L];    IF fh.stream # NIL THEN {      Transfer.CloseRemoteStream[fh.stream];  fh.stream ¬ NIL};    Subr.FreeString[fh.host];  fh.host ¬ NIL;    Subr.FreeString[fh.sfn];  fh.sfn ¬ NIL;    fh.nextPageToRead ¬ 0;    fh.allocated ¬ FALSE};      GetStreamCreation: PUBLIC PROC [      fh: LeafSubr.FileHandle] RETURNS [Time.Packed] = {    IF ~fh.allocated THEN ERROR UsageError["No 'Leaf' connection open"L];    RETURN[Transfer.GetStreamCreation[fh.stream]]};      GetStreamLength: PUBLIC PROC [      fh: LeafSubr.FileHandle] RETURNS [LONG CARDINAL] = {    IF ~fh.allocated THEN ERROR UsageError["No 'Leaf' connection open"L];    RETURN[Transfer.GetStreamLength[fh.stream]]};      -- base is # of page to start "mapping" on; base = 0 is the first page  RemoteMap: PUBLIC PROC [      seg: MSegment.Handle, fh: LeafSubr.FileHandle, base: CARDINAL] = {    buffer: LONG POINTER = MSegment.Address[seg];    bufferPages: CARDINAL = CARDINAL[MSegment.Pages[seg]];    pagesToSkip, pagesToRead, chunk, chunkBytes: CARDINAL;    p: LONG POINTER;    IF ~fh.allocated THEN ERROR UsageError["No 'Leaf' connection open"L];    IF base < fh.nextPageToRead THEN {  -- must close and reopen remote stream      IF fh.stream # NIL THEN Transfer.CloseRemoteStream[fh.stream];      fh.stream ¬ Transfer.OpenRemoteStream[fh.host, fh.sfn];      fh.nextPageToRead ¬ 0};    pagesToSkip ¬ (base - fh.nextPageToRead);    WHILE pagesToSkip > 0 DO      chunk ¬ MIN[pagesToSkip, bufferPages, 127];      chunkBytes ¬ (chunk * Environment.bytesPerPage);      [] ¬ Stream.GetBlock[sH: fh.stream, block: [buffer, 0, chunkBytes]];      pagesToSkip ¬ (pagesToSkip - chunk);      ENDLOOP;    fh.nextPageToRead ¬ base;    pagesToRead ¬ bufferPages;  p ¬ buffer;    WHILE pagesToRead > 0 DO      chunk ¬ MIN[pagesToRead, 127];      chunkBytes ¬ (chunk * Environment.bytesPerPage);      [] ¬ Stream.GetBlock[sH: fh.stream, block: [p, 0, chunkBytes]        ! Stream.EndOfStream => CONTINUE];      p ¬ p + (chunk * Environment.wordsPerPage);      pagesToRead ¬ (pagesToRead - chunk);      ENDLOOP;    fh.nextPageToRead ¬ (fh.nextPageToRead + bufferPages)};    END.
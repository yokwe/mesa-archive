-- File: ReleaseImpl.mesa - last edit:--   kam                 19-Oct-85 18:50:54--   Schmidt	11-Mar-82 19:15:04--   DWE    	24-Jun-83 17:59:17--   BTL  	20-Dec-83 11:27:35--   DSC  	 3-Jan-86 10:18:56-- Copyright (C) 1982, 1983, 1984, 1985 by Xerox Corporation. All rights reserved. -- Phase      Meaning--   1		verify consistency of all DF files:--		make sure there are no version conflicts and--		all files exist on remote servers--   2		verify sufficiency: run VerifyDF on all DF files--   3		transfer files to new homes, produce new DF files-- note that only Phase 2 involves looking at the internals of the files-- Phase 2 and 3 are in Release23Impl.mesaDIRECTORY  CWF USING [    SetWriteProcedure, SWF1, SWF3, SWF4, WF0, WF1, WF2, WF3, WF4, WFCR, WFError],  DFSubr USING [    AllocateDFSeq, DF, DFSeq, EXSeq, EXSeqRecord, FlattenDF, FreeDFSeq,    SortByFileName, StripLongName, TooManyEntries],  Event USING [DoneWithProcess, Handle, StartingProcess],  Exec USING [CheckForAbort, Handle],  FileTransfer USING [CodeToString, Error, FileInfo, ListProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Enumerated, EnumeratedItem, NotifyProcType, NumberItem, line0, line1,    line2, line3, line4, ProcType, StringItem],  Heap USING [Error, systemZone],  Inline USING [LowHalf],  MFile USING [Acquire, AppendErrorMessage, Error, Handle, Release],  MSegment USING [Create, Delete, Error, Handle],  MStream USING [Error, Handle, ReadOnly],  Process USING [Detach],  Put USING [Char, Line],  Release23 USING [TransferFiles, VerifySufficiency],  ReleaseCache USING [Cache, Close, Insert, Lookup, Make],  ReleaseInterface USING [Data, DataObject, EPhase],  Runtime USING [GetBcdTime, IsBound],  Space USING [Error],  Stream USING [Delete, Handle, SendNow],  String USING [AppendString, Empty, Equivalent, StringToDecimal],  Subr USING [    Any, AppendMSegmentErrorMessage, AppendMStreamErrorMessage, CopyString,    debugflg, EndsIn, errorflg, FileError, ForceHugeZoneToDisk,    FreeString, GetLine, HugeZone, HugeZoneFromDisk, LongZone,    PagesUsedInHugeZone, Prefix, ResetHugeZoneToEmpty, StrCopy,    SubrInit, SubrStop],  TextSource USING [ActOn, Handle],  TextSW USING [GetSource],  Time USING [Append, Current, Packed, Unpack],  Tool USING [Create, MakeFormSW, MakeSWsProc, MakeTTYSW, UnusedLogName],  ToolWindow USING [TransitionProcType],  Transfer USING [EnumerateForProperties, Finalize, Initialize],  UserInput USING [UserAbort],  Volume USING [InsufficientSpace],  Window USING [Handle];ReleaseImpl: MONITOR    IMPORTS      CWF, DFSubr, Event, Exec, FileTransfer, FormSW, Heap, Inline,      MFile, MSegment, MStream, Process, Put, Release23, ReleaseCache,      Runtime, Space, Stream, String, Subr, TextSource, TextSW, Time,      Tool, Transfer, UserInput, Volume    EXPORTS ReleaseInterface =  BEGIN OPEN ReleaseInterface;  -- # bytes in an IFS page (all page counts are in IFS pages, not Pilot pages)  bytesPerIFSPage: CARDINAL = 2048;  -- max Release.ExceptionList entries  NEXCEPTIONS: CARDINAL = 20;  toolData: PUBLIC ReleaseInterface.Data ¬ NIL;  wh: PUBLIC Window.Handle ¬ NIL;  exec: PUBLIC Exec.Handle ¬ NIL;   -- ReleaseTool serialization  nowRunning: BOOLEAN ¬ FALSE;   AlreadyRunning: PUBLIC ENTRY PROC RETURNS [yes: BOOLEAN] = {    IF nowRunning THEN RETURN[TRUE];    nowRunning ¬ TRUE;    RETURN[FALSE]};    DoneRunning: PUBLIC ENTRY PROC = {nowRunning ¬ FALSE};           -- Do one phase   ProcessOnePhase: PUBLIC PROC [phase: EPhase] = {    starttime: Time.Packed ¬ Time.Current[];    BEGIN ENABLE {      UNWIND => DoneRunning[];      ABORTED => {CWF.WF0["\n...Release aborted.\n"L];  GOTO abort};      FileTransfer.Error => 	IF Subr.debugflg THEN REJECT	ELSE {	  msg: STRING ¬ [60];	  FileTransfer.CodeToString[code, msg];	  CWF.WF1["FileTransfer error: %s\n"L, msg];	  GOTO error};      Volume.InsufficientSpace => {CWF.WF0["Volume full\n"L];  GOTO error};      CWF.WFError => 	IF Subr.debugflg THEN REJECT	ELSE {          CWF.WF1["\nCWF error: %s.\n"L, err];	  GOTO error};      MFile.Error => 	IF Subr.debugflg THEN REJECT	ELSE {	  msg: STRING ¬ [100];	  MFile.AppendErrorMessage[msg, code, file];	  CWF.WF1["MFile error: %s\n"L, msg];   	  GOTO error};      MStream.Error =>  	IF Subr.debugflg THEN REJECT	ELSE {	  msg: STRING ¬ [100];	  Subr.AppendMStreamErrorMessage[msg, code, stream];	  CWF.WF1["MStream error: %s.\n"L, msg];   	  GOTO error};      MSegment.Error =>   	IF Subr.debugflg THEN REJECT	ELSE {	  msg: STRING ¬ [100];	  Subr.AppendMSegmentErrorMessage[msg, code, segment];	  CWF.WF1["MSegment error: %s.\n"L, msg];   	  GOTO error}};    GoAndDo[phase];    EXITS      abort => NULL;      error => Subr.errorflg ¬ TRUE;    END;    IF Subr.errorflg THEN CWF.WF0["\nErrors logged."L];    CWF.WFCR[];    starttime ¬ [Time.Current[] - starttime];    CWF.WF1["\nTotal elapsed time for ReleaseTool %lr.\n"L, @starttime];    PrintSeparator[]};  GoAndDo: PROC [phase: EPhase] = {    topdffilename: STRING ¬ [100];    myEventHandle: Event.Handle ¬ NIL;        CleanUpStorage: PROC = {ReleaseBTree[];  Subr.ForceHugeZoneToDisk[]};    ReallyCleanUp: PROC = {      IF toolData # NIL AND toolData.dfseqall # NIL THEN        DFSubr.FreeDFSeq[@toolData.dfseqall];      CleanUpStorage[];      Transfer.Finalize[];  Subr.SubrStop[];      IF myEventHandle # NIL THEN {        Event.DoneWithProcess[myEventHandle];  myEventHandle ¬ NIL};      DoneRunning[]};    DoPhase: PROC [phase: EPhase] = {      time: Time.Packed ¬ Time.Current[];      Subr.errorflg ¬ FALSE;  Subr.debugflg ¬ toolData.debugging;      SELECT phase FROM        One => CWF.WF0["\nPhase One: Verify consistency of all the DF files.\n"L];        Two => CWF.WF0["\nPhase Two: Verify sufficiency by invoking VerifyDF on all the DF files:\n"L];        Three => CWF.WF0["\nPhase Three: Transfer remote files and fix up DF files to match.\n"L];        ENDCASE;      CWF.WF1["Phase started at %lt.\n\nReleaseTool parameters:\n"L, @time];      CWF.WF1[        "   Maximum number of entries in all DF files (MaxAllFiles) = %u.\n"L,	@toolData.maxAllFiles];      CWF.WF1[        "   Number of pages in write-once huge zone (PagesInHugeZone) = %u.\n"L,	@toolData.pagesInHugeZone];      CWF.WF1[        "   Initial pages for each BTree (InitialBTreePages) = %u.\n"L,	@toolData.initialBTreePages];      IF toolData.verbose THEN CWF.WF0["   Verbose mode (/V)\n"L]      ELSE CWF.WF0["   Nonverbose mode (/-V)\n"L];      SELECT phase FROM        One => {	  IF toolData.checkOverwrite THEN	    CWF.WF0["   Checking before overwriting DF files (/O)\n"L]	  ELSE CWF.WF0["   Not checking before overwriting DF files (/-O)\n"L];	  IF toolData.checkSpanTree THEN	    CWF.WF0["   Checking DF spanning tree (/T)\n"L]	  ELSE CWF.WF0["   Not checking DF spanning tree (/-T)\n"L];	  IF toolData.checkFilesExist THEN	    CWF.WF0["   Checking existence of released files (/E)\n"L]	  ELSE CWF.WF0["   Not checking existence of released files (/-E)\n"L];	  IF toolData.useOldPhase1Cache THEN	    CWF.WF0["   Using old Phase 1 BTree (/1)\n"L]	  ELSE CWF.WF0["   Not using old Phase 1 BTree (/-1)\n"L];	  VerifyConsistency[topdffilename]};        Two =>           Release23.VerifySufficiency[            topdffilename: topdffilename,	    exec: exec, window: toolData.ttysw,	    checkForOverwrite: toolData.checkOverwrite];        Three => {	  IF toolData.useOldPhase3Cache THEN	    CWF.WF0["   Using old Phase 3 BTree (/3)\n"L]	  ELSE CWF.WF0["   Not using old Phase 3 BTree (/-3)\n"L];          Release23.TransferFiles[            topdffilename: topdffilename, dfseqall: toolData.dfseqall,	    exec: exec, window: toolData.ttysw,            checkForOverwrite: toolData.checkOverwrite,	    usePhase3BTree: toolData.useOldPhase3Cache,	    verbose: toolData.verbose]};        ENDCASE;      CleanUpStorage[];      time ¬ Time.Current[];      CWF.WF1["\nPhase ended at %lt.\n"L, @time]};    BEGIN ENABLE UNWIND => ReallyCleanUp[];    myEventHandle ¬ Event.StartingProcess["ReleaseTool"L];    IF phase = Reset THEN {      CWF.WF0["Resetting memory... "L];      IF toolData # NIL AND toolData.dfseqall # NIL THEN        DFSubr.FreeDFSeq[@toolData.dfseqall];      CleanUpStorage[];      Subr.SubrStop[];      Subr.SubrInit[exec];   -- if exec=NIL, i/o is through wh      CWF.WF0["ReleaseTool memory reset.\n"L];      GOTO leave};    IF phase = UseOldPhase1Data THEN {      ok: BOOLEAN ¬ TRUE;      lp: LONG POINTER;      IF toolData.dfseqall # NIL THEN {        CWF.WF0["Error - HugeZone already mapped.\n"L];  GOTO leave};      lp ¬ Subr.HugeZoneFromDisk["ReleaseTool"L         ! Space.Error => {            CWF.WF0["Error - Can't map to that starting address.\n"L];            ok ¬ FALSE;  CONTINUE};          Subr.FileError => {            CWF.WF0["Error - No old Phase 1 data available.\n"L];            ok ¬ FALSE;  CONTINUE}];      IF ok THEN {        CWF.WF0["Using old Phase 1 data -- you may proceed to Phase 3.\n"L];        toolData.dfseqall ¬ lp};      GOTO leave};    IF String.Empty[toolData.dffilename] THEN {      CWF.WF0["Error - must specify a DF file name.\n"L];  GOTO error};    IF ~Subr.Any[toolData.dffilename, '.] THEN      CWF.SWF1[topdffilename, "%s.df"L, toolData.dffilename]    ELSE Subr.StrCopy[topdffilename, toolData.dffilename];    IF ~Subr.EndsIn[topdffilename, ".df"L] THEN {      CWF.WF1["Error - %s must be a DF file name.\n"L, topdffilename];      GOTO error};    Transfer.Initialize[exec: exec, window: toolData.ttysw];    IF phase = OneThree THEN {      DoPhase[One]; CWF.WFCR[]; PrintSeparator[]; DoPhase[Three]; CWF.WFCR[]}    ELSE DoPhase[phase];    CleanUpStorage[];  Transfer.Finalize[];     EXITS      leave => NULL;      error => Subr.errorflg ¬ TRUE;    END;    IF myEventHandle # NIL THEN {      Event.DoneWithProcess[myEventHandle];  myEventHandle ¬ NIL};    DoneRunning[]};    PrintSeparator: PROC = {    CWF.WF0["================================="L];    CWF.WF0["=================================\n"L]};  -- Phase 1  VerifyConsistency: PROC [topdffilename: LONG STRING] = {    exseq: DFSubr.EXSeq ¬ NIL;    nconflicts, nmissing, nentries: CARDINAL;    time: Time.Packed;        PostSummary: PROC = {      npages: CARDINAL;      CWF.WF0["\nSummary for Phase 1: "L];      CWF.WF2["%u conflicting versions, %u files/versions not found.\n"L,	@nconflicts, @nmissing];      CWF.WF2["Total - %u file entries, %u unique entries\n\n"L,	@toolData.dfseqall.size, @nentries];      CWF.WF2["Estimated %u files to be copied for %lu (2048 byte) pages.\n"L,	@toolData.nProbableFiles, @toolData.nProbablePages];      CWF.WF0["\t(This excludes CameFrom files, but includes those already in release position).\n"L];      npages ¬ Subr.PagesUsedInHugeZone[];      CWF.WF1["%u pages used in HugeZone.\n"L, @npages];      FlushLog[]};        IF ~CreateHugeZone[] THEN RETURN;    toolData.nProbablePages ¬ 0;  toolData.nProbableFiles ¬ 0;    IF toolData.dfseqall # NIL THEN DFSubr.FreeDFSeq[@toolData.dfseqall];    Subr.ResetHugeZoneToEmpty[];  -- be sure there are NO outstanding pointers    CWF.WF0["\nReading exception list From 'Release.ExceptionList'.\n"L];    exseq ¬ ParseExceptionList["Release.ExceptionList"L];    toolData.dfseqall ¬ ReadDF[topdffilename, exseq];    RemoveCameFroms[toolData.dfseqall];    IF toolData.dfseqall.size = 0 THEN {      DFSubr.FreeDFSeq[@toolData.dfseqall];      IF exseq # NIL THEN FreeExceptionList[@exseq];      RETURN};    IF toolData.checkSpanTree THEN      VerifySpanningTree[topdffilename, toolData.dfseqall, exseq]    ELSE CWF.WF0["Not verifying spanning tree (/-t in effect).\n"L];    -- sorting must precede CheckExceptions and CheckForExistence    CWF.WF0["Sorting the flattened DF files.\n"L];    time ¬ Time.Current[];    DFSubr.SortByFileName[      dfseq: toolData.dfseqall, min: 0, max: (toolData.dfseqall.size - 1),      ignorehostanddir: FALSE];    time ¬ [Time.Current[] - time];    CWF.WF1["Time to sort the flattened DF files: %lr.\n"L, @time];    CheckExceptions[toolData.dfseqall, exseq];  FlushLog[];    CheckReleaseAs[toolData.dfseqall];  FlushLog[];    -- check that all files are there (and create/use B tree)    IF toolData.checkFilesExist THEN {      CreateBTree[];      [nmissing, nentries] ¬ CheckForExistence[toolData.dfseqall];      ReleaseBTree[]}  -- force out B tree now    ELSE CWF.WF0["Not checking file existence (/-e in effect).\n"L];    -- check for conflicts    time ¬ Time.Current[];    CWF.WF0["Sorting the flattened DF files by shortname.\n"L];    DFSubr.SortByFileName[toolData.dfseqall, 0, toolData.dfseqall.size - 1, TRUE];    time ¬ [Time.Current[] - time];    CWF.WF1["Time to sort the flattened DF files by shortname: %lr.\n\n"L, @time];    nconflicts ¬ CheckConflicts[toolData.dfseqall];    FlushLog[];    CheckForUnreleasedDFVersions[toolData.dfseqall];    IF exseq # NIL THEN FreeExceptionList[@exseq];    PostSummary[]};      CreateHugeZone: PROC RETURNS [ok: BOOLEAN] = {    breathingRoom: MSegment.Handle ¬ NIL; -- leave a little VM before HugeZone        CleanUp: PROC = {      IF breathingRoom # NIL THEN {        MSegment.Delete[breathingRoom];  breathingRoom ¬ NIL}};          BEGIN ENABLE UNWIND => CleanUp[];    ok ¬ TRUE;    breathingRoom ¬ MSegment.Create[file: NIL, release: [], pages: 50      ! MSegment.Error, Space.Error => {          CWF.WF0["Error - can't get breathing room for huge zone.\n"L];	  GOTO problem}];    [] ¬ Subr.HugeZone[toolData.pagesInHugeZone, "ReleaseTool"L      ! Space.Error => {          CWF.WF1["Error - Space.Error when attempting to acquire %u page huge zone.\n"L, @toolData.pagesInHugeZone];	  GOTO problem};        MFile.Error => {	  msg: STRING ¬ [100];	  MFile.AppendErrorMessage[msg, code, file];          CWF.WF2["Error - MFile error when attempting to acquire %u page huge zone: %s.\n"L, @toolData.pagesInHugeZone, msg];          GOTO problem}];    EXITS problem => ok ¬ FALSE;    END;    CleanUp[]};  ReadDF: PROC [        topdffilename: LONG STRING, exseq: DFSubr.EXSeq]      RETURNS [dfseq: DFSubr.DFSeq] = {    time: Time.Packed ¬ Time.Current[];    npages: CARDINAL;    CWF.WF0["\nFlatten the top-level DF file: read all the DF files.\n"L];    dfseq ¬ DFSubr.AllocateDFSeq[      maxEntries: toolData.maxAllFiles, zoneType: huge];    IF wh # NIL THEN {IF UserInput.UserAbort[wh] THEN ERROR ABORTED}    ELSE IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    -- the nested entries are definitely NOT to be forced to be readonly!    DFSubr.FlattenDF[      dfseq: dfseq, dffilename: topdffilename,      exec: exec, window: toolData.ttysw,      checkForOverwrite: toolData.checkOverwrite, setRecorder: TRUE,      printStatus: toolData.verbose,      allowForceReadOnly: FALSE, skipCameFrom: toolData.skipCameFrom,      retrieveDFsToTemp: FALSE, localDFDir: NIL,      exList: exseq  -- i.e. don't parse Imports from a EXSeq directory       ! DFSubr.TooManyEntries, Heap.Error => {        CWF.WF0[          "Error - too many entries for the master data structure that holds every DF entry.\n"L];        CWF.WF0["Increase its size and try again.\n"L];        CONTINUE}];    time ¬ [Time.Current[] - time];    npages ¬ Subr.PagesUsedInHugeZone[];    CWF.WF1["Time to read in all the DF files: %lr.\n"L, @time];    CWF.WF1[      "%u entries in the master list that holds all DF entries.\n"L, @dfseq.size];    CWF.WF1[      "%u pages used in the HugeZone (contains master list).\n\n"L, @npages];    FlushLog[]};      -- *** Delete any CameFrom clauses on "Imports Foo.df" lines.  -- *** Change release location on any "Includes Foo.df" lines   RemoveCameFroms: PROC [dfseq: DFSubr.DFSeq] = {    df: DFSubr.DF;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF df.atsign AND df.cameFrom AND Subr.EndsIn[df.shortname, ".df"L] THEN {        df.cameFrom ¬ FALSE;        -- Imported or Included DF file w/ CameFrom        IF df.readonly THEN {  -- Imported          IF df.releaseHost # NIL THEN	    Subr.FreeString[df.releaseHost, dfseq.dfzone];	  df.releaseHost ¬ NIL;	  IF df.releaseDirectory # NIL THEN	    Subr.FreeString[df.releaseDirectory, dfseq.dfzone];	  df.releaseDirectory ¬ NIL}	ELSE { 	  -- Controversial:	  --   change "Includes X CameFrom Y" to "Includes X ReleaseAs X"           IF df.releaseHost # NIL THEN	    Subr.FreeString[df.releaseHost, dfseq.dfzone];	  IF df.releaseDirectory # NIL THEN	    Subr.FreeString[df.releaseDirectory, dfseq.dfzone];	  df.releaseHost ¬ Subr.CopyString[df.host, dfseq.dfzone];	  df.releaseDirectory ¬ Subr.CopyString[df.directory, dfseq.dfzone];	  IF df.createtime > 0 THEN df.version ¬ 0}};      ENDLOOP};  VerifySpanningTree: PROC [      topdffilename: LONG STRING, dfseq: DFSubr.DFSeq, exseq: DFSubr.EXSeq] = {    time: Time.Packed ¬ Time.Current[];    df, dfj: DFSubr.DF;    natsign, nreleaseas: CARDINAL;    firstRef: BOOLEAN;    CWF.WF0["Verify spanning tree rule:\n"L];    CWF.WF0[      "  each DF file is Included once and only once (skipping CameFroms).\n"L];    FOR i: CARDINAL IN [0..dfseq.size) DO dfseq[i].eval ¬ FALSE ENDLOOP;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF df.eval OR df.parentCameFrom OR df.cameFrom      OR ~Subr.EndsIn[df.shortname, ".df"L] THEN LOOP;      -- this is a df we have not seen before (not nested in a cameFrom DF)      CWF.WF1["\n%s is referenced in:\n"L, df.shortname];      natsign ¬ nreleaseas ¬ 0;  firstRef ¬ TRUE;      FOR j: CARDINAL IN [0..dfseq.size) DO        dfj ¬ @dfseq[j];        IF dfj.shortname.length = df.shortname.length        AND String.Equivalent[dfj.shortname, df.shortname] THEN {          dfj.eval ¬ TRUE;          IF dfj.atsign AND ~dfj.readonly THEN	    natsign ¬ natsign + 1;          IF dfj.releaseDirectory # NIL AND ~dfj.cameFrom AND ~dfj.readonly          AND ~String.Equivalent[dfj.shortname, dfj.recorder] THEN            nreleaseas ¬ nreleaseas + 1;	  IF firstRef THEN {CWF.WF1["\t%s"L, dfj.recorder];  firstRef ¬ FALSE}	  ELSE CWF.WF1[", %s"L, dfj.recorder];          IF dfj.readonly THEN CWF.WF0[" (ro)"L]};        ENDLOOP;      IF ~firstRef THEN CWF.WF0[".\n"L];      IF natsign = 0 OR nreleaseas # 1 THEN {  -- likely problem        IF ~String.Equivalent[df.shortname, topdffilename]	AND ~InAnExceptionDirectory[df, exseq] THEN {  -- suppress message           IF natsign = 0 THEN            CWF.WF1[	      "\tError - %s is not Included in any other DF file.\n"L,	      df.shortname];          IF nreleaseas # 1 THEN            CWF.WF2[              "\tError - there were %u ReleaseAs statements for %s (not counting possible self references).  There should be exactly one.\n"L,              @nreleaseas, df.shortname]}};      FlushLog[];      ENDLOOP;    time ¬ [Time.Current[] - time];    CWF.WF1["Time to verify spanning tree: %lr.\n\n"L, @time]};      InAnExceptionDirectory: PROC [      df: DFSubr.DF, exseq: DFSubr.EXSeq] RETURNS [yes: BOOLEAN] = {    yes ¬ FALSE;    FOR i: CARDINAL IN [0..exseq.size) DO      IF Subr.Prefix[df.directory, exseq[i].directory]        AND String.Equivalent[df.host, exseq[i].host]        AND          (df.directory.length = exseq[i].directory.length            OR              (exseq[i].directory.length < df.directory.length                AND df.directory[exseq[i].directory.length] = '>))        AND          (exseq[i].shortname = NIL            OR String.Equivalent[df.shortname, exseq[i].shortname])	THEN RETURN[yes: TRUE];      ENDLOOP;    RETURN[yes: FALSE]};  -- invariant: after completion, df.version = 0 means  -- highest version or no such file, otherwise df.version is the correct one  --  -- dfseq must be sorted  CheckForExistence: PROC [      dfseq: DFSubr.DFSeq] RETURNS [nmissing, nentries: CARDINAL] = {    time: Time.Packed ¬ Time.Current[];    df: DFSubr.DF;    foundonremote, inCache, missing: BOOLEAN;    nIfsPages, highversion, i: CARDINAL ¬ 0;    highdate: Time.Packed ¬ Time.Packed[0];    nmissing ¬ nentries ¬ 0;    CWF.WF0["\nCheck that each file actually exists in the specified version.\n"L];    i ¬ 0;    WHILE i < dfseq.size DO      df ¬ @dfseq[i];      -- skip if same create or adjacent entries are for # or >      IF i > 0        AND          ((df.createtime > 0 AND dfseq[i - 1].createtime = df.createtime)            OR (df.criterion # none AND dfseq[i - 1].criterion # none))        AND String.Equivalent[dfseq[i - 1].shortname, df.shortname]        AND String.Equivalent[dfseq[i - 1].directory, df.directory]        AND String.Equivalent[dfseq[i - 1].host, df.host] THEN {        df.version ¬ dfseq[i - 1].version;        i ¬ i + 1;  -- skip this one, go to next;        LOOP};      nentries ¬ nentries + 1;      IF wh # NIL THEN {IF UserInput.UserAbort[wh] THEN ERROR ABORTED}      ELSE IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;      IF toolData.verbose THEN CWF.WF4[        "Check [%s]<%s>%s in %s..."L,	df.host, df.directory, df.shortname, df.recorder];      nIfsPages ¬ 0;  highdate ¬ Time.Packed[0];      inCache ¬ missing ¬ foundonremote ¬ FALSE;      IF toolData.oldPhase1CacheExists AND toolData.useOldPhase1Cache      AND df.createtime # 0 THEN {        [inCache, nIfsPages] ¬ LookupInBTree[df];        foundonremote ¬ TRUE};  -- highversion and highdate have no value      IF ~inCache THEN        [foundonremote, missing, nIfsPages, highversion, highdate] ¬	  CheckFile[df];      IF ~foundonremote THEN {        IF missing THEN nmissing ¬ nmissing + 1;        -- fixup for phase 3: might as well get the highest ones        -- note this may screw up consistency checking        df.createtime ¬ highdate;        df.version ¬ highversion}      ELSE {        IF toolData.verbose THEN {	  CWF.WF1["ok%s.\n"L, IF inCache THEN " (in cache)"L ELSE ""L];	  FlushLog[]}	ELSE CWF.WF0["."L];        IF df.releaseDirectory # NIL AND ~df.cameFrom THEN {          toolData.nProbableFiles ¬ toolData.nProbableFiles + 1;          toolData.nProbablePages ¬ toolData.nProbablePages + nIfsPages}};      IF ~inCache AND ~missing THEN InsertInBTree[df, nIfsPages];      i ¬ i + 1;      ENDLOOP;    time ¬ [Time.Current[] - time];    CWF.WF1["\nTime to check that all files exist: %lr.\n\n"L, @time]};        CheckFile: PROC [        df: DFSubr.DF]      RETURNS [        foundonremote, missing: BOOLEAN, nIfsPages, highversion: CARDINAL,        highdate: Time.Packed] = {    sfn: STRING ¬ [150];    oneVersionFound: BOOLEAN ¬ FALSE;    ConsiderOneFile: FileTransfer.ListProc = {      remoteInfo: FileTransfer.FileInfo;      vers: CARDINAL ¬ 0;      date: Time.Packed;      oneVersionFound ¬ TRUE;      remoteInfo ¬ info[conn].source;      IF ~String.Empty[remoteInfo.version] THEN        vers ¬ String.StringToDecimal[remoteInfo.version];      date ¬ remoteInfo.create;      -- insures equal dates => higher versions      IF date = highdate THEN highversion ¬ vers;      IF date > highdate THEN {highversion ¬ vers;  highdate ¬ date};      IF foundonremote THEN RETURN[do];      IF df.createtime # Time.Packed[0] AND df.createtime = date THEN {        IF df.version > 0 AND df.version # vers THEN {	  IF ~toolData.verbose THEN CWF.WF0["\n"L];           CWF.WF3[	    "(Warning: %s of create date %lt has version !%u, "L,	    df.shortname, @date, @vers];          CWF.WF2["but %s refers to !%u)"L, df.recorder, @df.version];	  IF ~toolData.verbose THEN CWF.WF0["\n"L]};        df.version ¬ vers;        foundonremote ¬ TRUE}      ELSE IF df.createtime = 0 THEN foundonremote ¬ TRUE;      IF foundonremote THEN        nIfsPages ¬ Inline.LowHalf[(remoteInfo.size/bytesPerIFSPage) + 2];      RETURN[do]};    BEGIN    missing ¬ foundonremote ¬ FALSE;    nIfsPages ¬ 0;  highdate ¬ Time.Packed[0];  highversion ¬ 0;    IF df.version > 0 AND df.createtime = 0 AND df.criterion = none THEN {      CWF.SWF4[        sfn, "[%s]<%s>%s!%u"L, df.host, df.directory, df.shortname, @df.version];      Transfer.EnumerateForProperties[fileName: sfn, enumProc: ConsiderOneFile]}    ELSE {      IF df.version > 0 AND df.createtime # 0 THEN {  -- try specific version        CWF.SWF4[	  sfn, "[%s]<%s>%s!%u"L, df.host, df.directory, df.shortname, @df.version];        [foundonremote, nIfsPages] ¬ TryExplicitVersion[sfn, df.createtime];	IF foundonremote THEN oneVersionFound ¬ TRUE};      IF ~foundonremote THEN        CWF.SWF3[sfn, "[%s]<%s>%s!*"L, df.host, df.directory, df.shortname];      Transfer.EnumerateForProperties[fileName: sfn, enumProc: ConsiderOneFile]};    IF ~oneVersionFound THEN {      IF toolData.verbose THEN CWF.WF0["NOT found.\n"L]      ELSE CWF.WF4[        "\nError - [%s]<%s>%s in %s NOT found.\n"L,	df.host, df.directory, df.shortname, df.recorder];      missing ¬ TRUE;  GOTO err};    IF ~foundonremote THEN {  -- this date not present      IF toolData.verbose THEN {        CWF.WF2[	  "NOT ok.\n\tError - %s of %lt NOT found,\n"L, sfn, @df.createtime];	CWF.WF1["\tmost recent available date is %lt.\n"L, @highdate]}      ELSE {        CWF.WF4[	  "\nError - [%s]<%s>%s in %s "L,	  df.host, df.directory, df.shortname, df.recorder];	CWF.WF1["of %lt NOT found,\n"L, @df.createtime];	CWF.WF1["\tmost recent available date is %lt.\n"L, @highdate]}};    -- controversial: simply eliminates the version #    -- important to remember: if enumeration above used !num, then    -- highdate and highversion will refer to that version    IF df.createtime = 0 AND --df.version = 0 AND-- highdate > 0 THEN {      -- handles cases where there is a naked entry      foundonremote ¬ TRUE;  df.createtime ¬ highdate;  df.version ¬ highversion};    EXITS err => Subr.errorflg ¬ TRUE;    END};      TryExplicitVersion: PROC [        remoteName: STRING, createDate: Time.Packed]      RETURNS [foundonremote: BOOLEAN, nIfsPages: CARDINAL] = {          ConsiderVersion: FileTransfer.ListProc = {      remoteInfo: FileTransfer.FileInfo ¬ info[conn].source;      IF remoteInfo.create = createDate THEN {        foundonremote ¬ TRUE;	nIfsPages ¬ Inline.LowHalf[(remoteInfo.size/bytesPerIFSPage) + 2]};      RETURN[do]};          foundonremote ¬ FALSE;  nIfsPages ¬ 0;    Transfer.EnumerateForProperties[      fileName: remoteName, enumProc: ConsiderVersion]};      CheckConflicts: PROC [dfseq: DFSubr.DFSeq] RETURNS [nconflicts: CARDINAL] = {    df, dflast: DFSubr.DF;    nconflicts ¬ 0;    CWF.WF0["Check for conflicting versions of files in different DF files.\n"L];    FOR i: CARDINAL IN [1..dfseq.size) DO      dflast ¬ @dfseq[i - 1];      df ¬ @dfseq[i];      IF dflast.createtime # df.createtime AND dflast.createtime > 0      AND df.createtime > 0      AND String.Equivalent[dflast.shortname, df.shortname] THEN {         nconflicts ¬ nconflicts + 1;        CWF.WF1["Warning - conflict for %s:\n"L, dflast.shortname];        CWF.WF4[          "\t%s has [%s]<%s>%s"L,	  dflast.recorder, dflast.host, dflast.directory, dflast.shortname];        CWF.WF4[          " of %lt,\n\tbut %s has [%s]<%s>"L,           @dflast.createtime, df.recorder, df.host, df.directory];        CWF.WF2["%s of %lt.\n"L, df.shortname, @df.createtime]};      ENDLOOP;    IF nconflicts > 0 THEN      CWF.WF1["\nWarning - there were %u conflicts.\n\n"L, @nconflicts]    ELSE CWF.WF0["\nSuccess - there were no conflicts among the files.\n\n"L]};  CheckForUnreleasedDFVersions: PROC [dfseq: DFSubr.DFSeq] = {    df: DFSubr.DF;    CWF.WF0["Check for references to (apparently) unreleased DF files.\n"L];    CWF.WF0["  Note: these can occur because newly released DF files have not had\n"L];    CWF.WF0["  their final release locations set by Phase 3 using Release.ChangeReleaseLoc.\n"L];    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF df.releaseDirectory # NIL AND ~df.cameFrom AND ~df.readonly      AND Subr.EndsIn[df.shortname, ".df"L]      AND ~String.Equivalent[df.shortname, df.recorder] THEN {        -- A DF file that is being released: see if there are any refs to a 	-- (different) version on a different directory.        FOR j: CARDINAL IN [0..dfseq.size) DO          IF i # j	  AND dfseq[j].shortname.length = df.shortname.length          AND String.Equivalent[dfseq[j].shortname, df.shortname] THEN {            IF ~String.Equivalent[dfseq[j].host, df.host]            OR ~String.Equivalent[dfseq[j].directory, df.directory] THEN               CWF.WF4[                "Warning: %s appears to refer to a version of %s (on [%s]<%s>) that is not being released.\n"L,                dfseq[j].recorder, dfseq[j].shortname, 		dfseq[j].host, dfseq[j].directory]};          ENDLOOP};      ENDLOOP};  ParseExceptionList: PROC [filename: STRING] RETURNS [exseq: DFSubr.EXSeq] = {    sh: Stream.Handle ¬ NIL;    line: STRING ¬ [100];    host: STRING ¬ [60];    directory: STRING ¬ [100];    shortname: STRING ¬ [100];    longzone: UNCOUNTED ZONE = Subr.LongZone[];    BEGIN ENABLE UNWIND => {IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL}};    exseq ¬ longzone.NEW[DFSubr.EXSeqRecord[NEXCEPTIONS]];    sh ¬ MStream.ReadOnly[name: filename, release: []       ! MStream.Error => {          CWF.WF1["\nWarning - cannot open %s.\n"L, filename];  GOTO out}];    WHILE Subr.GetLine[sh, line] DO      IF line.length = 0 OR Subr.Prefix[line, "//"L] OR Subr.Prefix[line, "--"L]        THEN LOOP;      [] ¬ DFSubr.StripLongName[line, host, directory, shortname, FALSE];      IF exseq.size > exseq.maxsize THEN {        CWF.WF1["Error - too many exception list entries in %s.\n"L, filename];        EXIT};      exseq[exseq.size] ¬ [        host: Subr.CopyString[host, longzone],        directory: Subr.CopyString[directory, longzone],        shortname:	  IF shortname.length > 0 THEN Subr.CopyString[shortname, longzone]          ELSE NIL];      exseq.size ¬ exseq.size + 1;      ENDLOOP;    Stream.Delete[sh];  sh ¬ NIL;    EXITS out => NULL;    END};  -- dfseq must be sorted  CheckExceptions: PROC [dfseq: DFSubr.DFSeq, exseq: DFSubr.EXSeq] = {    i, j: CARDINAL;    dfcur, dfinner: DFSubr.DF;    nrelease, ncamefrom: CARDINAL;    skip: BOOLEAN;    CWF.WF0["\nCheck that each file has a ReleaseAs or CameFrom clause.\n"L];    i ¬ 0;    WHILE i < dfseq.size DO      IF wh # NIL THEN {        IF UserInput.UserAbort[wh] THEN ERROR ABORTED}      ELSE IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;      dfcur ¬ @dfseq[i];      nrelease ¬ ncamefrom ¬ 0;      j ¬ i;      skip ¬ FALSE;      WHILE j < dfseq.size        AND String.Equivalent[dfcur.shortname, dfseq[j].shortname]        AND String.Equivalent[dfcur.directory, dfseq[j].directory]        AND String.Equivalent[dfcur.host, dfseq[j].host] DO        dfinner ¬ @dfseq[j];        IF dfinner.readonly THEN {          IF dfinner.releaseDirectory # NIL AND ~dfinner.cameFrom THEN            CWF.WF3[              "Warning - %s in %s is ReadOnly but also has a %s statement.\n"L,              dfinner.shortname, dfinner.recorder,              IF dfinner.cameFrom THEN "CameFrom"L ELSE "ReleaseAs"L]};        IF dfinner.releaseDirectory # NIL AND ~dfinner.cameFrom THEN           nrelease ¬ nrelease + 1;        IF ~dfinner.readonly AND dfinner.releaseDirectory = NIL THEN {          CWF.WF2[            "Error - %s in %s has no release directory and is not ReadOnly.\n"L,            dfinner.shortname, dfinner.recorder];          skip ¬ TRUE};        IF dfinner.cameFrom THEN ncamefrom ¬ ncamefrom + 1;        j ¬ j + 1;        ENDLOOP;      -- if there are no ReleaseAs statements and no CameFrom statements,      -- then this if ReadOnly everywhere      -- (Remember that the sort is not stable, so we can't simply look at dfcur)      IF nrelease = 0 AND ~skip AND ncamefrom = 0 AND ~dfcur.readonly THEN {        IF ~InAnExceptionDirectory[dfcur, exseq] THEN {          CWF.WF3[            "Error - there are no ReleaseAs or CameFrom statements for [%s]<%s>%s.\n\t(referenced in"L,            dfcur.host, dfcur.directory, dfcur.shortname];          FOR k: CARDINAL IN [i..j) DO            CWF.WF1[" %s"L, dfseq[k].recorder]; ENDLOOP;          CWF.WF0[").\n"L]}};      i ¬ j;      ENDLOOP};  -- also complains if there is a CameFrom without an explicit date  CheckReleaseAs: PROC [dfseq: DFSubr.DFSeq] = {    exseq: DFSubr.EXSeq ¬ ParseExceptionList["Release.Destinations"L];    df: DFSubr.DF;    CWF.WF0["\nCheck that ReleaseAs and CameFrom clauses reference allowed directories.\n"L];    IF exseq = NIL OR exseq.size = 0 THEN {      CWF.WF0["Error - no destination list found on 'Release.Destinations'.\n"L];      RETURN};    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF df.cameFrom THEN {        IF df.createtime = 0 THEN          CWF.WF3[            "Warning - %s contains an entry for %s in a CameFrom Directory,\n\tbut it has no create time for %s.\n"L,            df.recorder, df.shortname, df.shortname];        -- look for CameFrom's that are on directories	-- that are not release directories (this looks suspicious)        FOR j: CARDINAL IN [0..exseq.size) DO          IF Subr.Prefix[df.directory, exseq[j].directory]            AND String.Equivalent[df.host, exseq[j].host]            AND (df.directory.length = exseq[j].directory.length                 OR (exseq[j].directory.length < df.directory.length                     AND df.directory[exseq[j].directory.length] = '>)) THEN EXIT;          REPEAT            FINISHED =>              CWF.WF4[                "CameFrom Warning - %s in %s is a CameFrom from [%s]<%s>,\n\tbut  that is not an official release directory.\n"L,                df.shortname, df.recorder, df.host, df.directory];          ENDLOOP};      IF df.releaseDirectory # NIL AND ~df.cameFrom THEN {         FOR j: CARDINAL IN [0..exseq.size) DO          IF Subr.Prefix[df.releaseDirectory, exseq[j].directory]            AND String.Equivalent[df.releaseHost, exseq[j].host]            AND (df.releaseDirectory.length = exseq[j].directory.length                 OR (exseq[j].directory.length < df.releaseDirectory.length                    AND df.releaseDirectory[exseq[j].directory.length] = '>)) THEN            EXIT;          REPEAT            FINISHED =>              CWF.WF4[                "Warning - %s in %s is released onto [%s]<%s>,\n\twhich is not an official release directory.\n"L,                df.shortname, df.recorder, df.releaseHost, df.releaseDirectory];          ENDLOOP};      ENDLOOP;    FreeExceptionList[@exseq]};  FreeExceptionList: PROC [pexseq: POINTER TO DFSubr.EXSeq] = {    FOR i: CARDINAL IN [0..pexseq.size) DO      Subr.FreeString[pexseq[i].host];      Subr.FreeString[pexseq[i].directory];      Subr.FreeString[pexseq[i].shortname];      ENDLOOP;    Subr.LongZone[].FREE[pexseq]}; -- Flush output at major events   FlushLog: PUBLIC PROC = {    IF toolData = NIL THEN RETURN;    IF toolData.logStream # NIL THEN   -- in executive, flush MStream      Stream.SendNow[sH: toolData.logStream, endRecord: TRUE]    ELSE {  -- in tool, flush TTYSW      h: TextSource.Handle ¬ NIL;      IF toolData.ttysw = NIL THEN RETURN;      h ¬ TextSW.GetSource[toolData.ttysw];      IF h # NIL THEN h.ActOn[sleep]}};     -- File existence cache BTree code  LookupInBTree: PROC [df: DFSubr.DF]    RETURNS [inCache: BOOLEAN, nIfsPages: CARDINAL] = {    cache: ReleaseCache.Cache ¬ LOOPHOLE[toolData.phase1BTree];    version: CARDINAL;    inCache ¬ FALSE;    nIfsPages ¬ 0;    IF df.createtime = 0 OR ~toolData.oldPhase1CacheExists      OR ~toolData.useOldPhase1Cache THEN RETURN;    [inCache: inCache, version: version, nIfsPages: nIfsPages] ¬       ReleaseCache.Lookup[        cache, df.host, df.directory, df.shortname, df.createtime];    IF inCache THEN df.version ¬ version};  InsertInBTree: PROC [df: DFSubr.DF, nIfsPages: CARDINAL] = {    cache: ReleaseCache.Cache ¬ LOOPHOLE[toolData.phase1BTree];    ReleaseCache.Insert[      cache, df.host, df.directory, df.shortname, df.createtime,      df.version, nIfsPages]};      CreateBTree: PROC = {    file: MFile.Handle ¬ NIL;    BEGIN ENABLE UNWIND => IF file # NIL THEN MFile.Release[file];    toolData.oldPhase1CacheExists ¬ TRUE;    file ¬ MFile.Acquire[      name: "ReleaseTool.Phase1Cache"L, access: anchor, release: []      ! MFile.Error => {toolData.oldPhase1CacheExists ¬ FALSE;  CONTINUE}];    IF file # NIL THEN {MFile.Release[file]; file ¬ NIL};    toolData.phase1BTreeFile ¬ LOOPHOLE[LONG[1]];    toolData.phase1BTree ¬ LOOPHOLE[      ReleaseCache.Make["ReleaseTool.Phase1Cache"L]];    END};  ReleaseBTree: PROC = {    IF toolData.phase1BTreeFile # NIL THEN {      ReleaseCache.Close[LOOPHOLE[toolData.phase1BTree]];      toolData.phase1BTree ¬ NIL;      toolData.phase1BTreeFile ¬ NIL};    toolData.oldPhase1CacheExists ¬ FALSE};     -- Tool related code    FireUpWindow: PROC = {    s: STRING ¬ [60];    String.AppendString[s, "Release Tool of "L];    Time.Append[s, Time.Unpack[LOOPHOLE[Runtime.GetBcdTime[]]]];    s.length ¬ s.length-3;    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, name: s,       clientTransition: ClientTransition, cmSection: "ReleaseTool"L,      tinyName1: "Release"L, tinyName2: "Tool"L]};       MakeSWs: Tool.MakeSWsProc = {    logname: STRING ¬ [100];    Tool.UnusedLogName[unused: logname, root: "ReleaseTool.log"L];    toolData.formsw ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    toolData.ttysw  ¬ Tool.MakeTTYSW[window: window, name: logname]};  MakeForm: FormSW.ClientItemsProcType = {    nItems: CARDINAL = 13;    i: CARDINAL ¬ 0;    e1: ARRAY [0..6) OF FormSW.Enumerated ¬ [      ["One"L, EPhase[One]], ["Two"L, EPhase[Two]], ["Three"L, EPhase[Three]],       ["OneThree"L, EPhase[OneThree]], ["Reset"L, EPhase[Reset]],      ["UseOldPhase1Data"L, EPhase[UseOldPhase1Data]]];    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[i ¬ 0] ¬ FormSW.EnumeratedItem[      tag: "Phase"L, place: [x: 0, y: FormSW.line0],      feedback: all, value: @toolData.phase, choices: DESCRIPTOR[e1]];    --    items[i ¬ i+1] ¬ FormSW.BooleanItem[      tag: "CheckOverwrite"L, place: [x: 0, y: FormSW.line1],      switch: @toolData.checkOverwrite];    items[i ¬ i+1] ¬ FormSW.BooleanItem[      tag: "CheckSpanTree"L, place: [x: 110, y: FormSW.line1],      switch: @toolData.checkSpanTree];    items[i ¬ i+1] ¬ FormSW.BooleanItem[      tag: "CheckFilesExist"L, place: [x: 220, y: FormSW.line1],      switch: @toolData.checkSpanTree];    items[i ¬ i+1] ¬ FormSW.BooleanItem[      tag: "UseOldPhase1BTree"L, place: [x: 330, y: FormSW.line1],      switch: @toolData.useOldPhase1Cache];    items[i ¬ i+1] ¬ FormSW.BooleanItem[      tag: "UseOldPhase3BTree"L, place: [x: 440, y: FormSW.line1],      switch: @toolData.useOldPhase3Cache];    --    items[i ¬ i+1] ¬ FormSW.NumberItem[      tag: "MaxAllFiles"L, place: [x: 0, y: FormSW.line2],       value: @toolData.maxAllFiles];    items[i ¬ i+1] ¬ FormSW.NumberItem[      tag: "PagesInHugeZone"L, place: [x: 220, y: FormSW.line2],       value: @toolData.pagesInHugeZone];    items[i ¬ i+1] ¬ FormSW.NumberItem[      tag: "InitBTreePages"L, place: [x: 440, y: FormSW.line2],       value: @toolData.initialBTreePages];    --    items[i ¬ i+1] ¬ FormSW.BooleanItem[      tag: "Verbose"L, place: [x: 0, y: FormSW.line3],       switch: @toolData.verbose];    items[i ¬ i+1] ¬ FormSW.BooleanItem[      tag: "Debug"L, place: [x: 220, y: FormSW.line3],       switch: @toolData.debugging, proc: SetDebugProc];    --    items[i ¬ i+1] ¬ FormSW.StringItem[      tag: "DFFile"L, place: [x: 0, y: FormSW.line4],      string: @toolData.dffilename, inHeap: TRUE];    items[i ¬ i+1] ¬ FormSW.CommandItem[      tag: "Start"L, place: [x: 220, y: FormSW.line4],      proc: GoNotifyProc];    RETURN[items: items, freeDesc: TRUE]};    SetDebugProc: FormSW.NotifyProcType = {Subr.debugflg ¬ toolData.debugging};  ClientTransition: ToolWindow.TransitionProcType = {    IF old = inactive AND toolData = NIL THEN {      toolData ¬ Heap.systemZone.NEW[DataObject ¬ []];      [] ¬ CWF.SetWriteProcedure[ToolTTYProc];      Subr.SubrInit[exec: NIL]}  -- all i/o is through wh    ELSE      IF new = inactive AND toolData # NIL THEN {        IF toolData.dfseqall # NIL THEN DFSubr.FreeDFSeq[@toolData.dfseqall];        Subr.SubrStop[];        Heap.systemZone.FREE[@toolData]}};  GoNotifyProc: FormSW.ProcType = {    p: PROCESS;    IF AlreadyRunning[] THEN {       Put.Line[toolData.ttysw, "ReleaseTool still busy - try later."L];      RETURN};    p ¬ FORK ProcessOnePhase[toolData.phase];    Process.Detach[p]};	  ToolTTYProc: PROC [ch: CHARACTER] = {Put.Char[toolData.ttysw, ch]};  	    -- Initialization   Init: PROC = {IF Runtime.IsBound[LOOPHOLE[Tool.Create]] THEN FireUpWindow[]};    Init[];    END.Change Log:10-Sep-84 14:29:32	DSC  	Fixed AR #5381 of CWF 3-Jan-86 10:19:12	DSC  	Fixed AR #8731 of StringBounds fault. Changed STRING length constant. System: Mesa Tools  Subsystem: Other 
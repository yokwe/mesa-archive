-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- SModelExecImpl.mesa - last edited by:--    BTL   & DWE     	 4-Nov-83 13:08:04--    BTL   	 	20-Dec-83 11:25:23--    DSC   	 	24-Jan-85 17:15:38DIRECTORY  CWF USING [WF0, WF1, WFCR, WFError],  DFLibrarian,  Event USING [DoneWithProcess, Handle, StartingProcess],  Exec USING [    AddCommand, CheckAbortProc, CheckForAbort, ExecProc, FreeTokenString,    GetToken, Handle, Outcome, OutputProc, RemoveCommand],  FileName USING [Error],  FileTransfer USING [CodeToString, Error],  Format USING[StringProc],  Heap,  Librarian,  MFile USING [AppendErrorMessage, Error],  MSegment USING [Error],  MStream USING [Error],  Profile,  SModelInterface USING [    AlreadyRunning, CheckAbortProc, DefaultOptions, DoneRunning, Options,    StoreDF],  String USING [CopyToNewString, Empty, Equivalent, FreeString],  Subr USING [    AppendMSegmentErrorMessage, AppendMStreamErrorMessage,    checkLibrarian, debugflg, dfLibjectsOnly, errorflg, LongZone, PrintGreeting, SetUpCWFWriteProcedure,    SetIntegrationLoc, SetWorkingDFLoc, SubrInit, SubrStop],  Time USING [Current, Packed],  Transfer USING [Finalize, Initialize, RegisterConnCredentials],  Volume USING [InsufficientSpace];SModelExecImpl: PROGRAM    IMPORTS      CWF, DFLibrarian, Event, Exec, FileName, FileTransfer, Heap, Librarian,      MFile, MSegment, MStream, Profile, Transfer, SModelInterface, String,      Subr, Time, Volume =  BEGIN  DoStore: Exec.ExecProc = {    startTime, elapsedTime: Time.Packed;    exec: Exec.Handle ¬ h;    myEventHandle: Event.Handle ¬ NIL;    libobject: DFLibrarian.Object;        Cleanup: PROC = {      Transfer.Finalize[];        DFLibrarian.Finalize[@libobject];      Subr.SubrStop[];      Event.DoneWithProcess[myEventHandle];  myEventHandle ¬ NIL;      SModelInterface.DoneRunning[]};        BEGIN      ENABLE {      	UNWIND => Cleanup[];        ABORTED => {CWF.WF0["\n...SModel aborted.\n"L];  GOTO abort};        FileTransfer.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [60];	    FileTransfer.CodeToString[code, msg];	    CWF.WF1["\nFileTransfer error: %s\n"L, msg];	    GOTO error};        Volume.InsufficientSpace => {CWF.WF0["\nVolume full\n"L];  GOTO error};	FileName.Error =>	  IF Subr.debugflg THEN REJECT	  ELSE {CWF.WF0["FileName error.\n"L];  GOTO error};        Librarian.Error => {	  errorString: LONG STRING = [80];	  Librarian.StringForErrorCode[code, errorString];          CWF.WF1["\nLibrarian error: %s.\n"L, errorString];  	  GOTO error};	CWF.WFError => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    CWF.WF1["\nCWF error: %s.\n"L, err];	    GOTO error};	MFile.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];	    CWF.WF1["MFile error: %s\n"L, msg];   	    GOTO error};        MStream.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMStreamErrorMessage[msg, code, stream];	    CWF.WF1["MStream error: %s.\n"L, msg];   	    GOTO error};	MSegment.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMSegmentErrorMessage[msg, code, segment];	    CWF.WF1["MSegment error: %s.\n"L, msg];   	    GOTO error}};	    IF SModelInterface.AlreadyRunning[] THEN {       Exec.OutputProc[exec][" SModel already running!"L];      RETURN[abort]};    startTime ¬ Time.Current[];    Subr.SetUpCWFWriteProcedure[];    Subr.SubrInit[exec];      Subr.PrintGreeting["SModel"L];    Subr.errorflg ¬ Subr.debugflg ¬ FALSE;    myEventHandle ¬ Event.StartingProcess["SModel"L];    Transfer.Initialize[exec: exec, window: NIL];  -- use exec window for i/o    outcome ¬ StoreFiles[exec, libobject];    IF Subr.errorflg THEN outcome ¬ error;    EXITS      error => {Subr.errorflg ¬ TRUE;  outcome ¬ error};      abort => outcome ¬ abort;    END;    IF Subr.errorflg THEN CWF.WF0["\nErrors logged.\n"L] ELSE CWF.WFCR[];    elapsedTime ¬ [Time.Current[] - startTime];    CWF.WF1["Total elapsed time for SModel %lr.\n"L, @elapsedTime];    Cleanup[]};      StoreFiles: PROC [exec: Exec.Handle, libobject: DFLibrarian.Object] RETURNS [outcome: Exec.Outcome] = {    opt, globalOpt: SModelInterface.Options ¬ SModelInterface.DefaultOptions;    name, sw, dfName: LONG STRING ¬ NIL;    dfZone: UNCOUNTED ZONE ¬ Subr.LongZone[];        CheckAbortInExec: SModelInterface.CheckAbortProc = {      RETURN[Exec.CheckForAbort[exec]]};        Cleanup: PROC = {      IF name # NIL THEN {name ¬ Exec.FreeTokenString[name];  name ¬ NIL};      IF sw # NIL THEN {sw ¬ Exec.FreeTokenString[sw];  sw ¬ NIL};      IF dfName # NIL THEN {        String.FreeString[z: dfZone, s: dfName];  dfName ¬ NIL};      IF libobject.servername # NIL THEN String.FreeString[dfZone, libobject.servername]};      GetServer: PROCEDURE RETURNS [db: LONG STRING] = {    StuffString: PROCEDURE [str: Profile.String] = {      db ¬ String.CopyToNewString[s: str, z: Heap.systemZone]};    Profile.GetLibrarian[StuffString]};        BEGIN    -- Set the check librarian flag though the User.cm entry    globalOpt.checkLibrarian ¬ Subr.checkLibrarian;    globalOpt.dfLibjectsOnly ¬ Subr.dfLibjectsOnly;    globalOpt.libHandle ¬ @libobject;    globalOpt.libHandle.servername ¬ GetServer[];    outcome ¬ normal; -- be optimistic.    [name, sw] ¬ Exec.GetToken[exec];  -- Get first set    WHILE ~String.Empty[name] OR ~String.Empty[sw] DO      IF ~String.Empty[sw] AND String.Empty[name] THEN {  -- switches only, so it must be global switches        SetSwitches[@globalOpt, sw]; -- Save the globals to be used later.	name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];        [name, sw] ¬ Exec.GetToken[exec];	LOOP};      -- Logically  the ELSE part starts here..      opt ¬ globalOpt;      IF ~String.Empty[sw] THEN SetSwitches[@opt, sw];      IF opt.cmd THEN {        SELECT TRUE FROM          String.Equivalent[name, "WorkingDFLoc"L] => { -- next is working loc	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - WorkingDFLoc/c must be followed by [Host]<Dir>.\n"L];	      GOTO error};	    Subr.SetWorkingDFLoc[name]};          String.Equivalent[name, "IntegrationLoc"L] => { -- next is int loc	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - IntegrationLoc/c must be followed by [Host]<Dir>.\n"L];	      GOTO error};	    Subr.SetIntegrationLoc[name]};          String.Equivalent[name, "Connect"L],	  String.Equivalent[name, "Conn"L] => { -- next 2 are dir & password	    dir: LONG STRING;	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - Connect/c must be followed by 'Dir Password'.\n"L];	      GOTO error};	    dir ¬ name;	    [name, sw] ¬ Exec.GetToken[exec];  -- name is connect password	    IF ~String.Empty[sw] THEN {  -- assume empty connect password	      Transfer.RegisterConnCredentials[dir: dir, password: ""L];	      dir ¬ Exec.FreeTokenString[dir];	      LOOP};	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - Connect/c must be followed by 'Dir Password'.\n"L];	      GOTO error};	    Transfer.RegisterConnCredentials[dir: dir, password: name];	    dir ¬ Exec.FreeTokenString[dir]};	  ENDCASE => {	    CWF.WF1["Error - unrecognized command %s.\n"L, name];  GOTO error};	name ¬ Exec.FreeTokenString[name];	[name, sw] ¬ Exec.GetToken[exec];	LOOP};      IF ~String.Empty[name] THEN {        dfName ¬ String.CopyToNewString[s: name, z: dfZone, longer: 3];        SModelInterface.StoreDF[	  dfFileName: dfName, opt: opt,	  dfZone: dfZone, window: NIL, abortProc: CheckAbortInExec];	String.FreeString[z: dfZone, s: dfName];  dfName ¬ NIL};      name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];      [name, sw] ¬ Exec.GetToken[exec];      ENDLOOP;    EXITS error => Subr.errorflg ¬ TRUE;    END;    IF Subr.errorflg THEN outcome ¬ error};      SetSwitches: PROC [opt: POINTER TO SModelInterface.Options, sw: LONG STRING] = {    sense: BOOLEAN ¬ TRUE;    FOR i: CARDINAL IN [0..sw.length) DO      SELECT sw[i] FROM	'a, 'A => {opt.mustConfirm    ¬ ~sense;  sense ¬ TRUE}; 	'v, 'V => {opt.verify         ¬  sense;  sense ¬ TRUE};	'n, 'N => {opt.dontStoreFiles ¬  sense;  sense ¬ TRUE};	'l, 'L => {opt.checkLibrarian ¬  sense;  sense ¬ TRUE};	'z, 'Z => {opt.preRelease     ¬  sense;  sense ¬ TRUE};	'r, 'R => {opt.ignoreReadOnly ¬  sense;  sense ¬ TRUE};	't, 'T => {opt.topLevelOnly   ¬  sense;  sense ¬ TRUE};	'f, 'F => {opt.flipCameFrom   ¬  sense;  sense ¬ TRUE};	'd, 'D => {opt.debugging      ¬  sense;  sense ¬ TRUE};        'c, 'C => {opt.cmd	      ¬  sense;  sense ¬ TRUE};        'b, 'B => {opt.dfLibjectsOnly      ¬  sense;  sense ¬ TRUE};	'-, '~ => sense ¬ ~sense;	ENDCASE => {	  CWF.WF1["Unknown switch in '%s'\n"L, sw];  Subr.errorflg ¬ TRUE}      ENDLOOP};      Init: PROC = {      Exec.AddCommand[name:  "SModel.~"L, proc: DoStore, help:  Help,  unload:  Unload]};    Unload: Exec.ExecProc = {  []  ¬  h.RemoveCommand["SModel.~"L];  };    Help: Exec.ExecProc = {    OutputProc: Format.StringProc _ Exec.OutputProc[h];    h.OutputProc[]["Smodel[/<global switches>] DFfile1[/<local switches>]....DFfilen[/<local switches>] Global switches are optional and control the store of subsequent DFs. You can also set global switches by giving an empty DF file name. Smodel also recognizes commands, workingDFLoc/c and integrationLoc/c. Seconday connect credentials can be given on the command line:  Smodel conn/c Dir Password  DFfile. A switch specification is a letter identifying the switch, optionally preceeded by a '-' or a '~' to reverse the sense of the switch. Switches recognized by Smodel are:   a=store Always   f=Flip came from (default)   l=check Librarian (default)   n=do Not store file remotely   r=ignore ReadOnly   t=process Top DF only   not included DFs   v=Verify files are really on the remote server and store if necessary   z=pre release mode"L];  };  Init[];    END.Change Log:10-Sep-84 14:28:18	DSC  	Fixed AR #5781 of CWF. 4-Nov-84 14:16:15	DSC  	Made global default value for checklibrarian be the Subr.checkLibrarian. 4-Nov-84 14:16:57	DSC  	Added an unload proc. 6-Nov-84 10:53:51	DSC  	Added the 'b (Brad) switch.24-Jan-85 17:15:47	DSC  	DFLibrarian support. 
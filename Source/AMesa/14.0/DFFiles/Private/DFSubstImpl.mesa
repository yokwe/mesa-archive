-- File: DFSubstImpl.mesa - last edit:-- Riggle.PA            8-Jan-87 17:34:40-- Copyright (C) 1983 , 1987 by Xerox Corporation. All rights reserved. -- DFSubstImpl.mesa - Last edited by --    BTL  	19-Dec-83 17:32:45--    DSC  	22-Apr-85 13:57:30DIRECTORY  CWF USING [SWF1, WF0, WF1, WF2, WF3],  DFSubr USING [    AllocateDFSeq, AppendToUsingSeq, CopyUsing, DF, DFSeq, FreeDFSeq,    LookupDF, LookupOneFile, NextDF, ParseStream, ReadInDir, TooManyEntries,     TooManyParseErrors, UsingSeq, UsingSeqRecord, WriteOut],  Event USING [DoneWithProcess, Handle, StartingProcess],  Exec USING [    AddCommand, CheckForAbort, ExecProc, FreeTokenString, GetToken,    Handle, OutputProc, RemoveCommand],  Format USING[StringProc],  MFile USING [    Acquire, AppendErrorMessage, Error, GetTimes, Handle, maxNameLength, Release, SetAccess, SetTimes],  MSegment USING [Error],  MStream USING [Create, Error, Handle, ReadOnly, WriteOnly],  Stream USING [Delete, EndOfStream, GetChar],  String USING [    AppendChar, AppendString, Empty, Equivalent, EquivalentSubString,    StringBoundsFault, SubStringDescriptor],  Subr USING [    AllocateString, Any, AppendMSegmentErrorMessage,    AppendMStreamErrorMessage, CopyFile, CopyString, debugflg, EndsIn,    errorflg, FreeString, LongZone, PrintGreeting, SetUpCWFWriteProcedure,    SubrInit, SubrStop, workingDFDir, workingDFHost],  Time USING [defaultTime, Current, Packed],  Volume USING [InsufficientSpace];  DFSubstImpl: MONITOR    IMPORTS      CWF, DFSubr, Event, Exec, MFile, MSegment, MStream, Stream, String,      Subr, Time, Volume =  BEGIN  MaxFiles: CARDINAL = 450;    BadSubstFile: ERROR = CODE;    nowRunning: BOOLEAN ¬ FALSE;  exec: Exec.Handle ¬ NIL;      dfZone: UNCOUNTED ZONE ¬ NIL;      anyRenameCmds, anyDeleteCmds, anyInsertCmds, anyMoveCmds: BOOLEAN ¬ FALSE;   unnecessaryImports: BOOLEAN ¬ FALSE;  -- T if all of some file's imports Deleted  substStream: MStream.Handle ¬ NIL;      streamPos: LONG CARDINAL ¬ 0;      eof: BOOLEAN ¬ FALSE;      token: ParseToken ¬ tBad;      tokenStr: LONG STRING ¬ [150];      nextChar: CHARACTER ¬ 0C;    substCommands, lastCommand: Command ¬ NIL;   Command: TYPE = LONG POINTER TO CommandObject;  CommandObject: TYPE = RECORD [    next: Command,    doneForThisDFFile: BOOLEAN,    body: SELECT kind: * FROM      rename => [        doRHS: BOOLEAN,	fromHost, fromDir, fromName: LONG STRING,  -- NIL means don't change	toHost, toDir, toName: LONG STRING],      delete, insert => [        import, dfFile: LONG STRING],      move => [        doForThisDFFile: BOOLEAN,  -- i.e. import from fromDFFile found        import, fromDFFile, toDFFile: LONG STRING],      ENDCASE];  ParseToken: TYPE = {    -- keywords    tRename, tRHS, tTo,    tDelete, tInsert, tImport, tFrom,    tMove,    -- identifiers (i.e. filename, host, or directory names)    tIdent,    -- other    tBad, tEOF};      tokenString: ARRAY ParseToken OF LONG STRING = [    "Rename"L, "RHS"L, "To"L,    "Delete"L, "Insert"L, "Import"L, "From"L,    "Move"L,    "<identifier>"L, "<error>"L, "<eof>"L];          DoSubstitute: Exec.ExecProc = {    myEventHandle: Event.Handle ¬ NIL;    startTime, elapsedTime: Time.Packed;    name, sw: LONG STRING ¬ NIL;    substFile: STRING ¬ [MFile.maxNameLength];    dfFile: STRING ¬ [MFile.maxNameLength];    preserve: BOOLEAN ¬ FALSE;    Cleanup: PROC = {      IF substStream # NIL THEN {Stream.Delete[substStream];  substStream ¬ NIL};      ReleaseCommands[];      dfZone ¬ NIL;  exec ¬ NIL;      Subr.SubrStop[];      Event.DoneWithProcess[myEventHandle];  myEventHandle ¬ NIL;      DoneRunning[]};    BEGIN      ENABLE {	UNWIND => Cleanup[];        ABORTED => {CWF.WF0["\n...DFSubstitute aborted.\n"L];  GOTO abort};	MFile.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [MFile.maxNameLength];	    MFile.AppendErrorMessage[msg, code, file];	    CWF.WF1["MFile error: %s\n"L, msg];   	    GOTO error};        MStream.Error =>  	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMStreamErrorMessage[msg, code, stream];	    CWF.WF1["MStream error: %s.\n"L, msg];   	    GOTO error};	MSegment.Error =>   	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMSegmentErrorMessage[msg, code, segment];	    CWF.WF1["MSegment error: %s.\n"L, msg];   	    GOTO error};	String.StringBoundsFault =>    	  IF Subr.debugflg THEN REJECT	  ELSE {            CWF.WF0["DFSubstitute bug: String.StringBoundsFault.\n"L];	    GOTO error};	Volume.InsufficientSpace => {          CWF.WF0["Volume full\n"L];	  GOTO error}};	    IF AlreadyRunning[] THEN {       Exec.OutputProc[h][" DFSubstitute already running!"L];      RETURN[abort]};          startTime ¬ Time.Current[];    outcome ¬ normal;    exec ¬ h;    Subr.SetUpCWFWriteProcedure[];      Subr.SubrInit[exec: exec];    Subr.PrintGreeting["DFSubstitute"L];    myEventHandle ¬ Event.StartingProcess["DFSubstitute"L];    dfZone ¬ Subr.LongZone[];    Subr.debugflg ¬ Subr.errorflg ¬ FALSE;    IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    -- get name of substitute file    [name, sw] ¬ Exec.GetToken[exec];    IF ~String.Empty[sw] THEN {      sense: BOOLEAN ¬ TRUE;      FOR i: CARDINAL IN [0..sw.length) DO        SELECT sw[i] FROM          'd, 'D => {Subr.debugflg      ¬ sense;  sense ¬ TRUE};           'p, 'P => {preserve      ¬ sense;  sense ¬ TRUE}; 	  '-, '~ => sense ¬ ~sense;          ENDCASE => {	    CWF.WF1["Unknown switch in '%s'\n"L, sw]; outcome ¬ warning};	ENDLOOP};    sw ¬ Exec.FreeTokenString[sw];    IF String.Empty[name] THEN {      CWF.WF0["Error - no substitute file given.\n"L];      GOTO error};    String.AppendString[substFile, name];    IF ~Subr.Any[substFile, '.] THEN String.AppendString[substFile, ".subst"L];    ParseCommands[substFile ! BadSubstFile => GOTO error];    IF Subr.errorflg THEN GOTO error;    -- now get and process each DF file    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];    WHILE ~String.Empty[name] DO      dfFile.length ¬ 0;  String.AppendString[dfFile, name];      IF ~Subr.Any[dfFile, '.] THEN String.AppendString[dfFile, ".df"L];      SubstituteInDFFile[dfFile, preserve        ! DFSubr.TooManyEntries => {	    CWF.WF1["Error - too many file entries in %s.\n"L, dfFile];	    Subr.errorflg ¬ TRUE;  CONTINUE}];      name ¬ Exec.FreeTokenString[name];      [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];      ENDLOOP;    EXITS      error => outcome ¬ error;      abort => outcome ¬ abort;    END;    IF Subr.errorflg THEN {CWF.WF0["Errors found.\n"L];  outcome ¬ error};    elapsedTime ¬ [Time.Current[] - startTime];    CWF.WF1["Total elapsed time for DFSubstitute %lr.\n"L, @elapsedTime];    Cleanup[]};   -- Serialization   AlreadyRunning: ENTRY PROC RETURNS [yes: BOOLEAN] = {    IF nowRunning THEN RETURN[TRUE];    nowRunning ¬ TRUE;    RETURN[FALSE]};    DoneRunning: ENTRY PROC = {nowRunning ¬ FALSE};   -- Command parsing   ParseCommands: PROC [substFile: LONG STRING] = {        CleanUp: PROC = {      IF substStream # NIL THEN {Stream.Delete[substStream];  substStream ¬ NIL}};          BEGIN ENABLE UNWIND => CleanUp[];    substCommands ¬ lastCommand ¬ NIL;    anyRenameCmds ¬ anyDeleteCmds ¬ anyInsertCmds ¬ anyMoveCmds ¬ FALSE;    substStream ¬ NIL;  streamPos ¬ 0;  eof ¬ FALSE;  nextChar ¬ ' ;    substStream ¬ MStream.ReadOnly[substFile, []      ! MStream.Error => {          CWF.WF1["Unable to open %s for reading.\n"L, substFile];	  Subr.errorflg ¬ TRUE;	  GOTO badFile}];    substStream.options.signalEndOfStream ¬ TRUE;    GetToken[];  -- prime the pump    WHILE ~eof DO      GetCommand[];      ENDLOOP;    EXITS badFile => ERROR BadSubstFile;    END;    CleanUp[]};       ReleaseCommands: PROC = {    OPEN String;    c: Command ¬ substCommands;    temp: Command;    WHILE c # NIL DO      temp ¬ c.next;      WITH cmd: c SELECT FROM        rename => {	  IF ~Empty[cmd.fromHost] THEN Subr.FreeString[cmd.fromHost, dfZone];	  IF ~Empty[cmd.fromDir] THEN Subr.FreeString[cmd.fromDir, dfZone];	  IF ~Empty[cmd.fromName] THEN Subr.FreeString[cmd.fromName, dfZone];	  IF ~Empty[cmd.toHost] THEN Subr.FreeString[cmd.toHost, dfZone];	  IF ~Empty[cmd.toDir] THEN Subr.FreeString[cmd.toDir, dfZone];	  IF ~Empty[cmd.toName] THEN Subr.FreeString[cmd.toName, dfZone]};	delete, insert => {	  IF ~Empty[cmd.import] THEN Subr.FreeString[cmd.import, dfZone];	  IF ~Empty[cmd.dfFile] THEN Subr.FreeString[cmd.dfFile, dfZone]};	move => {	  IF ~Empty[cmd.import] THEN Subr.FreeString[cmd.import, dfZone];	  IF ~Empty[cmd.fromDFFile] THEN Subr.FreeString[cmd.fromDFFile, dfZone];	  IF ~Empty[cmd.toDFFile] THEN Subr.FreeString[cmd.toDFFile, dfZone]};	ENDCASE => ERROR;      dfZone.FREE[@c];      c ¬ temp;      ENDLOOP;    substCommands ¬ lastCommand ¬ NIL};      GetCommand: PROC = {    SELECT token FROM      tRename => GetRenameCommand[];      tDelete => GetDeleteCommand[];      tInsert => GetInsertCommand[];      tMove   => GetMoveCommand[];      ENDCASE => {        CWF.WF1["Error - unrecognized command at position %lu.\n"L, @streamPos];	Subr.errorflg ¬ TRUE;	SkipToStartOfCommand[]}};	  GetRenameCommand: PROC = {    c: Command ¬ NIL;    renameRHS: BOOLEAN ¬ FALSE;    fromHost, fromDir, fromName: LONG STRING ¬ NIL;    toHost, toDir, toName: LONG STRING ¬ NIL;    IF Subr.debugflg THEN CWF.WF0["Debugging - found Rename command.\n"L];    anyRenameCmds ¬ TRUE;    Skip[tRename];    IF token = tRHS THEN {renameRHS ¬ TRUE;  Skip[tRHS]};    [fromHost, fromDir, fromName] ¬ GetRenameId[tokenStr];    Skip[tIdent];    Skip[tTo];    [toHost, toDir, toName] ¬ GetRenameId[tokenStr];    Skip[tIdent];    IF Subr.debugflg THEN {       CWF.WF3[        "Debugging - fromHost=%s, fromDir=%s, fromName=%s.\n"L,        fromHost, fromDir, fromName];      CWF.WF3[        "\ttoHost=%s, toDir=%s, toName=%s.\n"L, toHost, toDir, toName]};    c ¬ dfZone.NEW[rename CommandObject ¬ [      next: NIL,      doneForThisDFFile: FALSE,      body: rename[        doRHS: renameRHS,	fromHost: fromHost, fromDir: fromDir, fromName: fromName,	toHost: toHost, toDir: toDir, toName: toName]] ];    IF lastCommand = NIL THEN substCommands ¬ lastCommand ¬ c    ELSE {lastCommand.next ¬ c;  lastCommand ¬ c}};      GetRenameId: PROC [id: LONG STRING] RETURNS [host, dir, name: LONG STRING] = {    i: CARDINAL ¬ 0;    idEnd, dirEnd: CARDINAL;    nameField: BOOLEAN;    host ¬ dir ¬ name ¬ NIL;    IF String.Empty[id] THEN {      posn: LONG CARDINAL ¬ IF streamPos = 0 THEN 0 ELSE streamPos - 1;      CWF.WF1["Error - Empty rename identifier at %u.\n"L, @posn];      Subr.errorflg ¬ TRUE;      RETURN};    idEnd ¬ (id.length - 1);  -- index of last char    -- get host field    IF id[0] = '[ THEN {      host ¬ Subr.AllocateString[nchars: id.length, zone: dfZone];      i ¬ 1;      WHILE i <= idEnd DO        IF id[i] = '] THEN {i ¬ i + 1;  EXIT};	String.AppendChar[host, id[i]];  i ¬ i + 1;	ENDLOOP};    IF i >= idEnd THEN RETURN;    -- get directory field    dir ¬ Subr.AllocateString[nchars: id.length, zone: dfZone];    IF id[i] = '< THEN i ¬ i + 1;    IF id[idEnd] = '> THEN {nameField ¬ FALSE;  dirEnd ¬ (idEnd - 1)}    ELSE {   -- look for end of directory field      FOR j: CARDINAL DECREASING IN [i..idEnd] DO         IF id[j] = '> THEN {nameField ¬ TRUE;  dirEnd ¬ (j - 1);  EXIT};	REPEAT	  FINISHED => {nameField ¬ FALSE;  dirEnd ¬ idEnd};	ENDLOOP};    WHILE i <= dirEnd DO      String.AppendChar[dir, id[i]];  i ¬ i + 1;      ENDLOOP;    IF ~nameField THEN RETURN;    -- get name field    name ¬ Subr.AllocateString[nchars: id.length, zone: dfZone];    IF id[i] = '> THEN i ¬ i + 1;    WHILE i <= idEnd DO      String.AppendChar[name, id[i]];  i ¬ i + 1;      ENDLOOP};	  GetDeleteCommand: PROC = {    c: Command ¬ NIL;    importFile, importDFfile: LONG STRING ¬ NIL;    IF Subr.debugflg THEN      CWF.WF0["Debugging - found Delete command.\n"L];    anyDeleteCmds ¬ TRUE;    Skip[tDelete];    Skip[tImport];    importFile ¬ Subr.CopyString[tokenStr, dfZone];    Skip[tIdent];    Skip[tFrom];    importDFfile ¬ Subr.CopyString[tokenStr, dfZone];    Skip[tIdent];    c ¬ dfZone.NEW[delete CommandObject ¬ [      next: NIL,      doneForThisDFFile: FALSE,      body: delete[import: importFile, dfFile: importDFfile]] ];    IF lastCommand = NIL THEN substCommands ¬ lastCommand ¬ c    ELSE {lastCommand.next ¬ c;  lastCommand ¬ c}};	  GetInsertCommand: PROC = {    c: Command ¬ NIL;    importFile, importDFfile: LONG STRING ¬ NIL;    IF Subr.debugflg THEN      CWF.WF0["Debugging - found Insert command.\n"L];    anyInsertCmds ¬ TRUE;    Skip[tInsert];    Skip[tImport];    importFile ¬ Subr.CopyString[tokenStr, dfZone];    Skip[tIdent];    Skip[tFrom];    importDFfile ¬ Subr.CopyString[tokenStr, dfZone];    Skip[tIdent];    c ¬ dfZone.NEW[insert CommandObject ¬ [      next: NIL,      doneForThisDFFile: FALSE,      body: insert[import: importFile, dfFile: importDFfile]] ];    IF lastCommand = NIL THEN substCommands ¬ lastCommand ¬ c    ELSE {lastCommand.next ¬ c;  lastCommand ¬ c}};	  GetMoveCommand: PROC = {    c: Command ¬ NIL;    importFile, fromDF, toDF: LONG STRING ¬ NIL;    IF Subr.debugflg THEN      CWF.WF0["Debugging - found Move command.\n"L];    anyMoveCmds ¬ TRUE;    Skip[tMove];    Skip[tImport];    importFile ¬ Subr.CopyString[tokenStr, dfZone];    Skip[tIdent];    Skip[tFrom];    fromDF ¬ Subr.CopyString[tokenStr, dfZone];    Skip[tIdent];    Skip[tTo];    toDF ¬ Subr.CopyString[tokenStr, dfZone];    Skip[tIdent];    c ¬ dfZone.NEW[move CommandObject ¬ [      next: NIL,      doneForThisDFFile: FALSE,      body: move[        doForThisDFFile: FALSE,	import: importFile, fromDFFile: fromDF, toDFFile: toDF]] ];    IF lastCommand = NIL THEN substCommands ¬ lastCommand ¬ c    ELSE {lastCommand.next ¬ c;  lastCommand ¬ c}};                Skip: PROC [expected: ParseToken] = {    IF token # expected THEN {      posn: LONG CARDINAL ¬ IF streamPos = 0 THEN 0 ELSE streamPos - 1;      CWF.WF3[        "Error - expected %s but found %s at position %lu.\n"L,        tokenString[expected], tokenString[token], @posn];      Subr.errorflg ¬ TRUE};    GetToken[]};            SkipToStartOfCommand: PROC = {    WHILE token # tRename AND token # tDelete AND token # tInsert    AND token # tEOF DO      GetToken[];      ENDLOOP};  GetToken: PROC = {    pos: CARDINAL;    token ¬ tBad;  tokenStr.length ¬ 0;    WHILE nextChar = '  OR nextChar = '\t OR nextChar = '\n DO      GetChar[];      ENDLOOP;    IF nextChar IN ['A..'Z] OR nextChar IN ['a..'z] OR nextChar = '[    OR nextChar = '< THEN {   -- start of keyword, host, dir, or name      token ¬ tIdent;      pos ¬ 0;  String.AppendChar[tokenStr, nextChar];      GetChar[];  -- advance over first char      WHILE ~(nextChar = '  OR nextChar = '\t OR nextChar = '\n OR nextChar = 0C) DO	IF (pos ¬ pos+1) > tokenStr.maxlength THEN {	  CWF.WF1["Token '%s' is too long.\n"L, tokenStr];  RETURN};	String.AppendChar[tokenStr, nextChar];	GetChar[];  -- advance over char	ENDLOOP;      -- see if keyword      IF ~(tokenStr[0] = '< OR tokenStr[0] = '[ OR tokenStr.length > 6) THEN        SELECT tokenStr.length FROM          2 => IF String.Equivalent[tokenStr, "To"L] THEN token ¬ tTo;          3 => IF String.Equivalent[tokenStr, "RHS"L] THEN token ¬ tRHS;          4 => {	    IF String.Equivalent[tokenStr, "From"L] THEN token ¬ tFrom	    ELSE IF String.Equivalent[tokenStr, "Move"L] THEN token ¬ tMove};	  6 => {	    IF String.Equivalent[tokenStr, "Rename"L] THEN token ¬ tRename	    ELSE IF String.Equivalent[tokenStr, "Delete"L] THEN token ¬ tDelete	    ELSE IF String.Equivalent[tokenStr, "Insert"L] THEN token ¬ tInsert	    ELSE IF String.Equivalent[tokenStr, "Import"L] THEN token ¬ tImport};	ENDCASE}    ELSE IF nextChar = '" THEN {  -- quoted host, dir, or name (not keyword)      token ¬ tIdent;      pos ¬ 0;      GetChar[];  -- advance over first '"      WHILE nextChar # '" DO	IF pos > tokenStr.maxlength THEN {	  CWF.WF1["Token '%s' is too long.\n"L, tokenStr];  RETURN};	String.AppendChar[tokenStr, nextChar];	GetChar[];  -- advance over char	pos ¬ pos + 1;	ENDLOOP;      GetChar[]}  -- advance over final '"    ELSE {  -- not alphanumeric, look for magic characters      IF nextChar = 0C THEN token ¬ tEOF;      GetChar[]};    IF Subr.debugflg THEN {      posn: LONG CARDINAL ¬ (IF streamPos = 0 THEN 0 ELSE streamPos - 1);      CWF.WF3[        "Debugging - found token %s ('%s') at position %lu.\n"L,        tokenString[token],        (IF token = tIdent THEN tokenStr ELSE ""L), @posn]}};        GetChar: PROC = {    IF eof THEN {nextChar ¬ 0C;  RETURN};    streamPos ¬ streamPos + 1;    nextChar ¬ Stream.GetChar[substStream      ! Stream.EndOfStream => {eof ¬ TRUE;  nextChar ¬ 0C;  CONTINUE}]};         -- Substitution code  SubstituteInDFFile: PROC [dfFile: LONG STRING, preserve: BOOLEAN] = {    dfSeq: DFSubr.DFSeq ¬ NIL;    df: DFSubr.DF ¬ NIL;    nChanges: CARDINAL ¬ 0;    createTime: Time.Packed ¬ Time.defaultTime;    mh: MFile.Handle ¬ NIL;        BEGIN ENABLE UNWIND => DFSubr.FreeDFSeq[@dfSeq];    IF dfFile.length = 0 THEN {      CWF.WF0["Error - empty DF file name.\n"L];      Subr.errorflg ¬ TRUE;  RETURN};    IF ~Subr.EndsIn[dfFile, ".df"L] THEN {      CWF.WF1["Error - %s must be a DF file name.\n"L, dfFile];      Subr.errorflg ¬ TRUE;  RETURN};    CWF.WF1["\nSubstituting in %s\n"L, dfFile];    IF preserve THEN {      mh ¬ MFile.Acquire[name: dfFile, access: anchor, release: [] ! MFile.Error => {	str: LONG STRING ¬ [100];	MFile.AppendErrorMessage[str, code, mh];	CWF.WF1["MFile error %s\n"L, str];	mh ¬ NIL;	CONTINUE;      }];      IF mh = NIL THEN RETURN;      -- Get the time      [createTime,,] ¬ MFile.GetTimes[mh];      MFile.Release[mh];    };    -- build fake entry     dfSeq ¬ DFSubr.AllocateDFSeq[maxEntries: 1, zoneType: shared];    df ¬ DFSubr.NextDF[dfSeq];    df.shortname ¬ Subr.CopyString[dfFile, dfSeq.dfzone];    df.atsign ¬ TRUE;    nChanges ¬ RecursiveSubstitute[dfSeqOuter: dfSeq, topDfOuter: NIL];    IF nChanges > 0 THEN      CWF.WF2["%u substitutions made in %s.\n"L, @nChanges, dfFile]    ELSE CWF.WF1["No substitutions made in %s.\n"L, dfFile];    IF preserve THEN {      mh ¬ MFile.Acquire[name: dfFile, access: anchor, release: [] ! MFile.Error => {	str: LONG STRING ¬ [100];	MFile.AppendErrorMessage[str, code, mh];	CWF.WF1["MFile error %s\n"L, str];	mh ¬ NIL;	CONTINUE;      }];      MFile.SetTimes[mh, createTime ! MFile.Error => {	str: LONG STRING ¬ [100];	MFile.AppendErrorMessage[str, code, mh];	CWF.WF1["MFile error %s\n"L, str];	mh ¬ NIL;	CONTINUE;      }];      MFile.Release[mh];    };    DFSubr.FreeDFSeq[@dfSeq];    END};  -- dfSeqOuter is allocated and filled with its contents  -- topDfOuter points to the entry in the outer df that indirects thru this DF  -- topDfOuter may be NIL  RecursiveSubstitute: PROC [        dfSeqOuter: DFSubr.DFSeq, topDfOuter: DFSubr.DF]      RETURNS [nChanges: CARDINAL] = {    c: Command;    dfOuter: DFSubr.DF;    i, n, j: CARDINAL ¬ 0;    nChanges ¬ 0;    FOR c ¬ substCommands, c.next UNTIL c = NIL DO      c.doneForThisDFFile ¬ FALSE;      ENDLOOP;    -- for this DF file, see if any Move commands should be executed    IF anyMoveCmds THEN      FOR c ¬ substCommands, c.next UNTIL c = NIL DO        WITH cmd: c SELECT FROM          move => {	    cmd.doForThisDFFile ¬ FALSE;	    IF String.Empty[cmd.import] THEN LOOP;	    FOR i IN [0..dfSeqOuter.size) DO	      dfOuter ¬ @dfSeqOuter[i];	      IF dfOuter.atsign AND dfOuter.readonly  -- Imports	      AND String.Equivalent[dfOuter.shortname, cmd.fromDFFile] THEN {	        usingSeq: DFSubr.UsingSeq ¬ dfOuter.using;	        IF usingSeq = NIL THEN LOOP;	        FOR j IN [0..usingSeq.size) DO                  IF String.Equivalent[usingSeq[j], cmd.import] THEN {                    cmd.doForThisDFFile ¬ TRUE;  GOTO doneWithCmd};		  ENDLOOP};	      REPEAT	        doneWithCmd => NULL;	      ENDLOOP};	  ENDCASE;        ENDLOOP;    -- now deal with each file in DF list    FOR i IN [0..dfSeqOuter.size) DO      dfOuter ¬ @dfSeqOuter[i];      n ¬ 0;      IF dfOuter.atsign AND ~dfOuter.readonly      AND Subr.EndsIn[dfOuter.shortname, ".df"L] THEN {  -- Included DF file        DFSubr.LookupOneFile[dfOuter];        IF dfOuter.presentonlocaldisk THEN	  n ¬ ProcessIndirectDFFile[dfOuter, dfSeqOuter, topDfOuter]}      ELSE IF topDfOuter = NIL THEN EXIT;  -- top level DF file      -- either a regular file, an Imported DF file, or an       -- Included DF file that we did not store above      n ¬ MakeAnySubstitutions[dfOuter];      nChanges ¬ nChanges + n;       ENDLOOP;    -- now insert new Imports lines if Inserts or Moves weren't done above    IF anyInsertCmds OR anyMoveCmds THEN       FOR c ¬ substCommands, c.next UNTIL c = NIL DO        WITH cmd: c SELECT FROM	  insert => 	    IF ~cmd.doneForThisDFFile THEN {	      InsertNewImportLine[	        import: cmd.import, fromDF: cmd.dfFile, dfseq: dfSeqOuter];	      cmd.doneForThisDFFile ¬ TRUE;	      nChanges ¬ nChanges + 1};          move => 	    IF ~cmd.doneForThisDFFile AND cmd.doForThisDFFile THEN {	      InsertNewImportLine[	        import: cmd.import, fromDF: cmd.toDFFile, dfseq: dfSeqOuter];	      cmd.doneForThisDFFile ¬ TRUE;	      nChanges ¬ nChanges + 1};	  ENDCASE;        ENDLOOP};        ProcessIndirectDFFile: PROC [        dfOuter: DFSubr.DF, dfSeqOuter: DFSubr.DFSeq, topDfOuter: DFSubr.DF]      RETURNS [nChanges: CARDINAL] = {    dfSeqInner: DFSubr.DFSeq ¬ NIL;    sh: MStream.Handle ¬ NIL;    j: CARDINAL;        CleanUp: PROC = {      IF sh # NIL THEN {        Stream.Delete[sh];  sh ¬ NIL;	dfOuter.fHandle ¬ NIL;  dfOuter.presentonlocaldisk ¬ FALSE};      IF dfSeqInner # NIL THEN DFSubr.FreeDFSeq[@dfSeqInner]};    BEGIN ENABLE UNWIND => CleanUp[];    nChanges ¬ 0;    IF topDfOuter # NIL THEN      CWF.WF1["\nNested Substitute in %s.\n"L, dfOuter.shortname];    dfSeqInner ¬ DFSubr.AllocateDFSeq[maxEntries: MaxFiles, zoneType: shared];    MFile.SetAccess[dfOuter.fHandle, readOnly];    sh ¬ MStream.Create[file: dfOuter.fHandle, release: []      ! MStream.Error => {          CWF.WF1["Error - can't open %s\n"L, dfOuter.shortname];	  Subr.errorflg ¬ TRUE;  GOTO leave}];    DFSubr.ParseStream[      sh: sh, dfseq: dfSeqInner, dffilename: dfOuter.shortname,      using: dfOuter.using,      noremoteerrors: FALSE, forceReadonly: FALSE, omitNonPublic: FALSE,      limitErrors: TRUE      ! DFSubr.TooManyParseErrors => {          CWF.WF1[	    " - parse abandoned, too many errors in %s.\n"L, dfOuter.shortname];	  GOTO leave}];    Stream.Delete[sh];  sh ¬ NIL;    dfOuter.fHandle ¬ NIL;  dfOuter.presentonlocaldisk ¬ FALSE;    IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    DFSubr.ReadInDir[dfSeqInner];  -- this fills in all file handles    unnecessaryImports ¬ FALSE;      IF anyDeleteCmds OR anyMoveCmds THEN      -- mark all files (Imports) needed for now      FOR j IN [0..dfSeqInner.size) DO        dfSeqInner[j].need ¬ TRUE;        ENDLOOP;    nChanges ¬ RecursiveSubstitute[dfSeqOuter: dfSeqInner, topDfOuter: dfOuter];    IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    IF nChanges > 0 THEN {  -- rewrite DF file      sold: STRING ¬ [100];      sh: MStream.Handle ¬ NIL;      dfInner: DFSubr.DF ¬ NIL;      -- first, remove any unnecessary Imports (no imported files)      IF (anyDeleteCmds OR anyMoveCmds) AND unnecessaryImports THEN {        tempSeq: DFSubr.DFSeq ¬ NIL;        BEGIN ENABLE UNWIND => DFSubr.FreeDFSeq[@tempSeq];        tempSeq ¬ DFSubr.AllocateDFSeq[	  maxEntries: dfSeqInner.size, zoneType: shared];        FOR j IN [0..dfSeqInner.size) DO          dfj: DFSubr.DF = @dfSeqInner[j];          dfCopy: DFSubr.DF;          IF dfj.atsign AND dfj.readonly AND ~dfj.need THEN LOOP; -- not needed          dfCopy ¬ DFSubr.NextDF[tempSeq];          dfCopy­ ¬ dfj­;          dfCopy.host        ¬ MakeCopy[dfj.host];          dfCopy.directory   ¬ MakeCopy[dfj.directory];          dfCopy.shortname   ¬ MakeCopy[dfj.shortname];          dfCopy.comment     ¬ MakeCopy[dfj.comment];          dfCopy.recorder    ¬ MakeCopy[dfj.recorder];          dfCopy.releaseHost ¬ MakeCopy[dfj.releaseHost];          dfCopy.releaseDirectory ¬ MakeCopy[dfj.releaseDirectory];          dfCopy.fHandle ¬ NIL;          IF dfj.using # NIL THEN dfCopy.using ¬ DFSubr.CopyUsing[dfj.using];          ENDLOOP;        DFSubr.FreeDFSeq[@dfSeqInner];        dfSeqInner ¬ tempSeq;        END};      -- save the old df file      CWF.SWF1[sold, "%s$"L, dfOuter.shortname];      Subr.CopyFile[from: dfOuter.shortname, to: sold];      -- get the entry for the DF file itself in the DF file      dfInner ¬ DFSubr.LookupDF[dfSeqInner, dfOuter.shortname];      IF dfInner # NIL THEN {        dfInner.version ¬ 0;	IF dfInner.fHandle # NIL THEN {	  MFile.Release[dfInner.fHandle];  dfInner.fHandle ¬ NIL}};      IF dfOuter.fHandle # NIL THEN MFile.Release[dfOuter.fHandle];      sh ¬ MStream.WriteOnly[name: dfOuter.shortname, release: [], type: text        ! MStream.Error => {            CWF.WF1["\nUnable to create new file on %s.\n"L, dfOuter.shortname];            Subr.errorflg ¬ TRUE;            DFSubr.FreeDFSeq[@dfSeqInner];            ERROR ABORTED}];      DFSubr.WriteOut[        dfseq: dfSeqInner, topLevelFile: NIL, outputStream: sh, print: FALSE];      Stream.Delete[sh];  sh ¬ NIL;      CWF.WF2[        "New DF file with %u substitutions written on %s"L,	@nChanges, dfOuter.shortname];      IF topDfOuter = NIL THEN        CWF.WF0[" - this MUST be SModeled to store it remotely.\n"L]      ELSE CWF.WF0[".\n"L];      -- reset outer DF entry if it was > or #      IF dfOuter.criterion # none THEN dfOuter.createtime ¬ Time.Packed[0]}     ELSE CWF.WF1["No substitutions made, %s not changed.\n"L, dfOuter.shortname];    IF topDfOuter # NIL THEN      CWF.WF1["End of nested Substitute of %s.\n\n"L, dfOuter.shortname];    EXITS leave => NULL;    END;    CleanUp[]};        MakeCopy: PROC [from: LONG STRING] RETURNS [LONG STRING] = {    IF String.Empty[from] THEN RETURN[NIL]    ELSE RETURN[Subr.CopyString[from, dfZone]]};        MakeAnySubstitutions: PROC [df: DFSubr.DF] RETURNS [nChanges: CARDINAL] = {    imports: BOOLEAN = (df.atsign AND df.readonly);    change: BOOLEAN;    nChanges ¬ 0;    IF Subr.debugflg THEN      CWF.WF3[        "Debugging - making substitutions in [%s]<%s>%s.\n"L,        df.host, df.directory, df.shortname];    IF ~imports AND ~anyRenameCmds THEN {      IF Subr.debugflg THEN         CWF.WF0["Debugging - don't bother: ~imports AND ~anyRenameCmds\n"L];      RETURN};    FOR c: Command ¬ substCommands, c.next UNTIL c = NIL DO      change ¬ FALSE;      WITH cmd: c SELECT FROM        rename => {          IF Subr.debugflg THEN CWF.WF0["Debugging - Rename command\n"L];	  change ¬ PossiblyRename[	    df, cmd.doRHS,	    cmd.fromHost, cmd.toHost, cmd.fromDir, cmd.toDir,	    cmd.fromName, cmd.toName];	  IF change THEN nChanges ¬ nChanges + 1};	delete => {	  IF Subr.debugflg THEN CWF.WF0["Debugging - Delete command\n"L];	  IF imports AND String.Equivalent[df.shortname, cmd.dfFile] THEN  	    change ¬ DeleteFromUsingList[df, cmd.import];	  IF change THEN nChanges ¬ nChanges + 1};	insert => {	  IF Subr.debugflg THEN CWF.WF0["Debugging - Insert command\n"L];	  IF imports AND String.Equivalent[df.shortname, cmd.dfFile] THEN  	    change ¬ InsertIntoUsingList[df, cmd.import];	  IF change THEN nChanges ¬ nChanges + 1};	move => {	  IF Subr.debugflg THEN CWF.WF0["Debugging - Move command\n"L];	  IF ~cmd.doForThisDFFile THEN LOOP;	  IF imports AND String.Equivalent[df.shortname, cmd.fromDFFile] THEN {  	    change ¬ DeleteFromUsingList[df, cmd.import];	    IF change THEN nChanges ¬ nChanges + 1};	  IF imports AND String.Equivalent[df.shortname, cmd.toDFFile] THEN {  	    change ¬ InsertIntoUsingList[df, cmd.import];	    IF change THEN {	      cmd.doneForThisDFFile ¬ TRUE;  -- marked done when (re)inserted	      nChanges ¬ nChanges + 1}}};	ENDCASE;      ENDLOOP};        PossiblyRename: PROC [        df: DFSubr.DF, doRHS: BOOLEAN,	fromHost, toHost, fromDir, toDir, fromName, toName: LONG STRING]      RETURNS [change: BOOLEAN] = {    hostMatch, dirMatch, nameMatch: BOOLEAN ¬ FALSE;    dirMatchStart: CARDINAL;    change ¬ FALSE;     nameMatch ¬ NamesMatch[df, fromName];    IF ~nameMatch THEN RETURN;    [dirMatch, dirMatchStart] ¬ DirectoriesMatch[      df: df, fromDir: fromDir, doRHS: doRHS, matchEntireDir: (fromName # NIL)];    IF ~dirMatch THEN RETURN;    hostMatch ¬ HostsMatch[df, doRHS, fromHost];    IF ~hostMatch THEN RETURN;    -- change host    IF ~String.Empty[fromHost] THEN {      IF doRHS AND ~String.Empty[df.releaseHost] THEN {        change ¬ TRUE;	Subr.FreeString[df.releaseHost, dfZone];	df.releaseHost ¬ Subr.CopyString[toHost, dfZone]}      ELSE IF ~String.Empty[df.host] THEN {        change ¬ TRUE;	Subr.FreeString[df.host, dfZone];	df.host ¬ Subr.CopyString[toHost, dfZone]}};    -- change directory    IF ~String.Empty[fromDir] THEN {      newDir: LONG STRING;      IF doRHS AND ~String.Empty[df.releaseDirectory] THEN {        change ¬ TRUE;	newDir ¬ MakeDirSubst[	  fullDir: df.releaseDirectory, toDir: toDir,	  matchStart: dirMatchStart, matchLength: fromDir.length];	Subr.FreeString[df.releaseDirectory, dfZone];	df.releaseDirectory ¬ newDir}      ELSE IF ~String.Empty[df.directory] THEN {        change ¬ TRUE;	newDir ¬ MakeDirSubst[	  fullDir: df.directory, toDir: toDir,	  matchStart: dirMatchStart, matchLength: fromDir.length];	Subr.FreeString[df.directory, dfZone];	df.directory ¬ newDir}};    -- change name    IF ~String.Empty[fromName] AND ~String.Empty[df.shortname] THEN {      change ¬ TRUE;      Subr.FreeString[df.shortname, dfZone];      df.shortname ¬ Subr.CopyString[toName, dfZone]};    -- reset version number hint: old ones are usually incorrect    IF change THEN df.version ¬ 0};        HostsMatch: PROC [        df: DFSubr.DF, doRHS: BOOLEAN, fromHost: LONG STRING]      RETURNS [match: BOOLEAN] = {    OPEN String;    IF Empty[fromHost] THEN match ¬ TRUE  -- trivially    ELSE match ¬ (      IF doRHS THEN Equivalent[df.releaseHost, fromHost]      ELSE Equivalent[df.host, fromHost])};        start, length: ARRAY [0..15) OF CARDINAL;  -- spans in fullDir between >'s  lastSpan: CARDINAL;  source, pattern: String.SubStringDescriptor;        DirectoriesMatch: PROC [        df: DFSubr.DF, fromDir: LONG STRING, doRHS, matchEntireDir: BOOLEAN]      RETURNS [match: BOOLEAN, dirMatchStart: CARDINAL] = {    fullDir: LONG STRING = (IF doRHS THEN df.releaseDirectory ELSE df.directory);    fullDirLength: CARDINAL;    fromDirLength: CARDINAL;    possiblePrefixLength: CARDINAL;    i: CARDINAL;    match ¬ FALSE;  dirMatchStart ¬ 0;    IF String.Empty[fullDir] OR String.Empty[fromDir] THEN {      IF String.Empty[fullDir] AND ~String.Empty[fromDir] THEN         RETURN[match: FALSE, dirMatchStart: 0];      RETURN[match: TRUE, dirMatchStart: 0]};    IF fullDir.length < fromDir.length THEN      RETURN[match: FALSE, dirMatchStart: 0];    IF String.Equivalent[fullDir, fromDir] THEN      RETURN[match: TRUE, dirMatchStart: 0];    IF matchEntireDir THEN  -- previous test should have succeeded      RETURN[match: FALSE, dirMatchStart: 0];    -- set up span arrays    fullDirLength ¬ fullDir.length;  fromDirLength ¬ fromDir.length;    lastSpan ¬ 0;  start[lastSpan] ¬ 0;      i ¬ 1;    WHILE i <= (fullDirLength - 1) DO      IF fullDir[i] = '> THEN {	length[lastSpan] ¬ (i - start[lastSpan]);	i ¬ i+1;  -- advance just beyond '>	IF i < fullDirLength THEN {	  lastSpan ¬ lastSpan + 1;  start[lastSpan] ¬ i}};      i ¬ i + 1;      ENDLOOP;    -- now look for matches    possiblePrefixLength ¬ (fullDirLength - fromDirLength);    pattern.base ¬ fromDir;  pattern.offset ¬ 0;  pattern.length ¬ fromDirLength;    source.base ¬ fullDir;    IF ~Subr.Any[fromDir, '>] THEN {  -- just look at spans between >'s      FOR i IN [0..lastSpan] DO	IF length[i] # fromDirLength THEN LOOP;	source.offset ¬ start[i];  source.length ¬ length[i];	IF String.EquivalentSubString[@pattern, @source] THEN 	  RETURN[match: TRUE, dirMatchStart: start[i]];	ENDLOOP}    ELSE {      source.length ¬ fromDirLength;      FOR i IN [0..lastSpan] DO	IF start[i] > possiblePrefixLength THEN EXIT;  -- no possible match	source.offset ¬ start[i];  	IF String.EquivalentSubString[@pattern, @source] THEN {	  -- see if really a match of a subdirectory	  lastPlusOne: CARDINAL = (start[i] + fromDirLength); 	  IF lastPlusOne = fullDirLength OR fullDir[lastPlusOne] = '> THEN  	    RETURN[match: TRUE, dirMatchStart: start[i]]};	ENDLOOP}};	  NamesMatch: PROC [      df: DFSubr.DF, fromName: LONG STRING] RETURNS [match: BOOLEAN] = {    IF String.Empty[fromName] THEN match ¬ TRUE  -- trivially    ELSE match ¬ String.Equivalent[df.shortname, fromName]};	  MakeDirSubst: PROC [        fullDir, toDir: LONG STRING, matchStart, matchLength: CARDINAL]      RETURNS [newDir: LONG STRING] = {    fullDirLength: CARDINAL = fullDir.length;    toDirLength: CARDINAL = toDir.length;    j: CARDINAL;    newDir ¬ Subr.AllocateString[(fullDirLength + toDirLength), dfZone];    FOR j IN [0..matchStart) DO      String.AppendChar[newDir, fullDir[j]];      ENDLOOP;    FOR j IN [0..toDirLength) DO      String.AppendChar[newDir, toDir[j]];      ENDLOOP;    FOR j IN [(matchStart + matchLength)..fullDirLength) DO      String.AppendChar[newDir, fullDir[j]];      ENDLOOP};	    DeleteFromUsingList: PROC [      df: DFSubr.DF, import: LONG STRING] RETURNS [change: BOOLEAN] = {    usingSeq: DFSubr.UsingSeq ¬ df.using;    i, pos, j: CARDINAL;    newSize: CARDINAL;    newUsing: DFSubr.UsingSeq ¬ NIL;    change ¬ FALSE;    IF usingSeq = NIL OR String.Empty[import] THEN RETURN;    FOR i IN [0..usingSeq.size) DO      IF String.Equivalent[usingSeq[i], import] THEN {        pos ¬ i;  change ¬ TRUE;  EXIT};      ENDLOOP;    IF ~change THEN RETURN;  -- no match    newSize ¬ (usingSeq.size - 1);    IF newSize = 0 THEN {      unnecessaryImports ¬ TRUE;  df.need ¬ FALSE;      newUsing ¬ NIL}    ELSE {      newUsing ¬ dfZone.NEW[DFSubr.UsingSeqRecord[newSize]];      newUsing.zone ¬ dfZone;      newUsing.size ¬ newSize;      j ¬ 0;      FOR i IN [0..usingSeq.size) DO        IF i # pos THEN {newUsing[j] ¬ usingSeq[i];  j ¬ j + 1};        ENDLOOP};    dfZone.FREE[@usingSeq];    df.using ¬ newUsing};	  InsertIntoUsingList: PROC [      df: DFSubr.DF, import: LONG STRING] RETURNS [change: BOOLEAN] = {    usingSeq: DFSubr.UsingSeq ¬ df.using;    change ¬ FALSE;    IF usingSeq = NIL OR String.Empty[import] THEN RETURN;    FOR i: CARDINAL IN [0..usingSeq.size) DO      IF String.Equivalent[usingSeq[i], import] THEN RETURN;  -- already there      ENDLOOP;    change ¬ TRUE;    df.using ¬ DFSubr.AppendToUsingSeq[usingSeq, import, dfZone]};	  InsertNewImportLine: PROC [import, fromDF: LONG STRING, dfseq: DFSubr.DFSeq] = {    df: DFSubr.DF;    usingSeq: DFSubr.UsingSeq ¬ NIL;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF df.atsign AND df.readonly      AND String.Equivalent[df.shortname, fromDF] THEN {  -- already there        [] ¬ InsertIntoUsingList[df, import];	RETURN};      ENDLOOP;    -- we really do need to allocate a new Import line    IF String.Empty[Subr.workingDFHost] OR String.Empty[Subr.workingDFDir] THEN {      CWF.WF2[        "Error - unable to insert Import line for %s from %s since no default DF location was given in User.cm.\n"L,	import, fromDF];      Subr.errorflg ¬ TRUE;      RETURN};    df ¬ DFSubr.NextDF[dfseq];    df.host      ¬ Subr.CopyString[Subr.workingDFHost, dfseq.dfzone];    df.directory ¬ Subr.CopyString[Subr.workingDFDir,  dfseq.dfzone];    df.shortname ¬ Subr.CopyString[fromDF, dfseq.dfzone];    df.version ¬ 0;  df.createtime ¬ [0];    df.criterion ¬ update;  -- i.e. >    df.atsign ¬ TRUE;  df.readonly ¬ TRUE;  -- i.e. Imports    df.presentonlocaldisk ¬ FALSE;  df.fHandle ¬ NIL;    usingSeq ¬ dfZone.NEW[DFSubr.UsingSeqRecord[1]];    usingSeq.zone ¬ dfZone;    usingSeq.size ¬ 0;    df.using ¬ usingSeq;    [] ¬ InsertIntoUsingList[df, import]};        	  	            Init: PROC = {Exec.AddCommand[name:  "DFSubstitute.~"L, proc: DoSubstitute, help:  Help,  unload:  Unload]};    Unload: Exec.ExecProc = {  []  ¬  h.RemoveCommand["DFSubstitute.~"L];  };    Help: Exec.ExecProc = {    OutputProc: Format.StringProc _ Exec.OutputProc[h];    h.OutputProc[]["DFSubstitute ScriptFile DFfile1...DFfilen   The first file is a substitution script (default extension \".script\" that specifies the changes to be made to the following DF files. DFSubstitute has no switches."L];  };  Init[];    END.Change Log: 5-Nov-84  9:30:28	DSC  	Added an unload and help proc. 22-Apr-85 14:36:20	DSC  	Preserve create date per DF.
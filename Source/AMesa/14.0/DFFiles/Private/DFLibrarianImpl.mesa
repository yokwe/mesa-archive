-- DFLibrarianImpl.mesa - Last edited by--   BTL  	17-Nov-83 13:25:56--   DSC  	11-Feb-86 11:08:59-- Copyright (C) 1983, 1984, 1986  by Xerox Corporation. All rights reserved. DIRECTORY  Atom USING [MakeAtom],  AtomicProfile USING [GetString],  Auth USING [CopyIdentity, FreeIdentity, IdentityHandle],  CWF USING [SWF4, WF0, WF1, WF2],  DFLibrarian USING [AtomArray, Handle],  FileName USING [AllocVFN, Error, FreeVFN, VFN],  HeraldWindow,  Librarian USING [AddStringProperty, CheckOut, Close, CreatePropertyList, DestroyPropertyList, Error, GetStringProperty, GetTimeProperty, Handle, MakeAtom, nullHandle, Open, PropertyList, Query, SetProperties, SetPropertiesAndCheckIn, StringForErrorCode, WrongPropertyType],  Profile USING [GetID ],  Runtime USING [IsBound],  Stream USING [Delete, Handle],  String USING [Copy, Empty, Equivalent, InvalidNumber, StringToDecimal],  Subr USING [errorflg, FileError],  Time USING [Packed],  Transfer USING [CachedOpen],  Window USING [Handle];  -- Here's the philosophiacal problem: Is the Usable routine required, if the -- Initiailize routine could return False. I think not, since the right-- protocDFLibrarianImpl: PROGRAM    IMPORTS Atom, AtomicProfile, Auth, CWF, FileName, HeraldWindow, Librarian, Profile, Runtime, Stream, String, Subr, Transfer    EXPORTS DFLibrarian = {      AtomArray: TYPE = DFLibrarian.AtomArray;  Handle: TYPE = DFLibrarian.Handle;    flipperState: TYPE = {off, left, right};    -- Initialize object pointed to by "h" to   -- a session with the librarian "servername"  -- and set all fields.   Initialize: PUBLIC PROC [h: Handle, servername: LONG STRING, zone: UNCOUNTED ZONE] RETURNS [ok: BOOLEAN ¬ TRUE] = {    feedbackSlot: HeraldWindow.Slot ¬ NIL;    feedbackState: flipperState ¬ off;    idCopy: Auth.IdentityHandle ¬ NIL;    LibOpen: PROCEDURE [id: Auth.IdentityHandle] = {      idCopy ¬ Auth.CopyIdentity[id, zone];    };    CleanUp: PROC = {      ClearBoxes[feedbackSlot, @feedbackState];      IF idCopy # NIL THEN Auth.FreeIdentity[@idCopy, zone];    };    BEGIN ENABLE UNWIND => CleanUp[];    IF String.Empty[servername] THEN RETURN[FALSE];    feedbackSlot ¬ HeraldWindow.GetCursorSlot[];    IF feedbackSlot # NIL THEN {      HeraldWindow.SetCursor[slot: feedbackSlot, cursor: blank];      feedbackState ¬ off};    ShowBoxes[feedbackSlot, @feedbackState];    -- Copy object related stuff    CWF.WF1["Opening connection to '%s' ..."L, servername];    Profile.GetID[proc: LibOpen];    h.server ¬ Librarian.Open[servername, idCopy, zone];    CWF.WF0[" done.\n"L];    h.zone ¬ zone;    -- Set up query atoms for this server only.    MakeQueryAtoms[h.server, @h.atoms];    CleanUp[];    END};	  -- Although not documented in the librarian interface, I assume that the  -- atoms are freed when the connection is closed. I assume that since  -- there are no "free atoms" proc. After all, they ARE atoms...	   Finalize: PUBLIC PROC [h: Handle] = {    feedbackSlot: HeraldWindow.Slot ¬ NIL;    feedbackState: flipperState ¬ off;    CleanUp: PROC = {      ClearBoxes[feedbackSlot, @feedbackState];    };    BEGIN ENABLE UNWIND => CleanUp[];    IF h.server # Librarian.nullHandle THEN {      feedbackSlot ¬ HeraldWindow.GetCursorSlot[];      IF feedbackSlot # NIL THEN {	HeraldWindow.SetCursor[slot: feedbackSlot, cursor: blank];	feedbackState ¬ off};      ShowBoxes[feedbackSlot, @feedbackState];      CWF.WF1["Closing connection  to '%s'..."L, h.servername];      Librarian.Close[h.server]; CWF.WF0[" done.\n"L];      h.server ¬ Librarian.nullHandle;      CleanUp[]};    END};     -- Should fix the whole thing, since it's silly to do multiple queries.     LookupLibject: PUBLIC PROC [h: Handle, shortName: LONG STRING]   RETURNS [libjectExists, librarianProblem: BOOLEAN ¬ FALSE] = {    pl: Librarian.PropertyList ¬ Librarian.CreatePropertyList[h.zone];    feedbackSlot: HeraldWindow.Slot ¬ NIL;    feedbackState: flipperState ¬ off;    libjectCheckedOut: BOOLEAN ¬ FALSE;    Cleanup: PROCEDURE = {      ClearBoxes[feedbackSlot, @feedbackState];      Librarian.DestroyPropertyList[pl];      };    BEGIN ENABLE UNWIND => Cleanup[];    feedbackSlot ¬ HeraldWindow.GetCursorSlot[];    IF feedbackSlot # NIL THEN {	HeraldWindow.SetCursor[slot: feedbackSlot, cursor: blank];	feedbackState ¬ off};    ShowBoxes[feedbackSlot, @feedbackState];    IF h.server = Librarian.nullHandle THEN {      CWF.WF0["No connection established.\n"L];       libjectExists ¬  FALSE;      librarianProblem ¬  TRUE;      GOTO problem};    [pl, libjectCheckedOut] ¬ Librarian.Query[ handle: h.server, libject: shortName, what: DESCRIPTOR[BASE[h.atoms], LENGTH[h.atoms]]      ! Librarian.Error =>	  IF code = noSuchLibject THEN GOTO noLibject	  ELSE {            message: LONG STRING ¬ [100];	    Librarian.StringForErrorCode[code, message]; 	    CWF.WF2["\nLibrarian problem when looking up %s: %s.\n"L, shortName, message];	    Subr.errorflg ¬ TRUE;  GOTO problem}];    libjectExists ¬  TRUE; librarianProblem ¬  FALSE;    EXITS       noLibject => {libjectExists ¬  FALSE; librarianProblem ¬  FALSE};      problem   => {libjectExists ¬  TRUE;  librarianProblem ¬  TRUE};    END;    Cleanup[];};     -- How about using libtoolops?   QueryLibject: PUBLIC PROC [h: Handle, libject: LONG STRING, localName, remoteName, checkOutUser, checkOutReason, checkInReason: LONG STRING] RETURNS  [checkedOut: BOOLEAN, checkOutTOD: Time.Packed, checkInTOD: Time.Packed] = {    pl: Librarian.PropertyList ¬ Librarian.CreatePropertyList[h.zone];    qualifiedName: LONG STRING ¬ [100];    host, directory, versionstr: LONG STRING ¬ NIL;    libjectCheckedOut: BOOLEAN ¬ FALSE;    feedbackSlot: HeraldWindow.Slot ¬ NIL;    feedbackState: flipperState ¬ off;    Cleanup: PROCEDURE = {      Librarian.DestroyPropertyList[pl];      ClearBoxes[feedbackSlot, @feedbackState]};    BEGIN ENABLE UNWIND => Cleanup[];    feedbackSlot ¬ HeraldWindow.GetCursorSlot[];    IF feedbackSlot # NIL THEN {	HeraldWindow.SetCursor[slot: feedbackSlot, cursor: blank];	feedbackState ¬ off};    ShowBoxes[feedbackSlot, @feedbackState];    [pl, libjectCheckedOut] ¬ Librarian.Query[handle: h.server, libject: libject, what: DESCRIPTOR[BASE[h.atoms], LENGTH[h.atoms]]];    String.Copy[localName, libject];    checkInReason ¬ NIL;    -- The properties may not be set, to prepare to catch them.    host ¬ Librarian.GetStringProperty[pl, h.atoms[host] ! Librarian.WrongPropertyType => { host ¬ NIL; CONTINUE}];    FeedbackProgress[feedbackSlot, @feedbackState];    directory ¬ Librarian.GetStringProperty[pl, h.atoms[directory] ! Librarian.WrongPropertyType => { directory ¬ NIL; CONTINUE}];    FeedbackProgress[feedbackSlot, @feedbackState];    versionstr ¬ Librarian.GetStringProperty[pl, h.atoms[version] ! Librarian.WrongPropertyType => {versionstr ¬ NIL; CONTINUE}];    FeedbackProgress[feedbackSlot, @feedbackState];    -- These two should be there.    String.Copy[checkOutUser, Librarian.GetStringProperty[pl, h.atoms[checkOutUser]]];    FeedbackProgress[feedbackSlot, @feedbackState];    checkedOut ¬ libjectCheckedOut;    checkInTOD ¬ Librarian.GetTimeProperty[pl, h.atoms[changeTime]];    FeedbackProgress[feedbackSlot, @feedbackState];    IF checkedOut THEN {      String.Copy[checkOutReason, Librarian.GetStringProperty[pl, h.atoms[reason] ! Librarian.WrongPropertyType => {checkOutReason ¬ NIL; CONTINUE}]];      checkOutTOD ¬ Librarian.GetTimeProperty[pl, h.atoms[changeTime]]}    ELSE {       checkOutReason ¬ NIL    };    qualifiedName.length ¬ 0;    CWF.SWF4[qualifiedName, "[%s]%s>%s!%s"L, host, directory, localName, versionstr];    String.Copy[remoteName, qualifiedName];    Cleanup[];    END};  	  IsLibjectCheckedOut: PUBLIC PROC [h: Handle, shortName: LONG STRING] RETURNS [yes: BOOLEAN] = {  feedbackSlot: HeraldWindow.Slot ¬ NIL;  feedbackState: flipperState ¬ off;  Cleanup: PROCEDURE = {    Librarian.DestroyPropertyList[pl];    ClearBoxes[feedbackSlot, @feedbackState]};  pl: Librarian.PropertyList ¬ Librarian.CreatePropertyList[h.zone];  BEGIN ENABLE UNWIND => Cleanup[];    feedbackSlot ¬ HeraldWindow.GetCursorSlot[];    IF feedbackSlot # NIL THEN {	HeraldWindow.SetCursor[slot: feedbackSlot, cursor: blank];	feedbackState ¬ off};    ShowBoxes[feedbackSlot, @feedbackState];    [pl, yes] ¬ Librarian.Query[handle: h.server, libject: shortName, what: DESCRIPTOR[BASE[h.atoms], LENGTH[h.atoms]]];    Cleanup[];  END};      CheckOutLibject: PUBLIC PROC [h: Handle, libject, reason: LONG STRING] RETURNS [success: BOOLEAN] = {    feedbackSlot: HeraldWindow.Slot ¬ NIL;    feedbackState: flipperState ¬ off;    pl: Librarian.PropertyList ¬ Librarian.CreatePropertyList[z: h.zone];    CleanUp: PROCEDURE = {      ClearBoxes[feedbackSlot, @feedbackState];    };    BEGIN ENABLE {      Librarian.Error => {	message: LONG STRING ¬ [100];	Librarian.StringForErrorCode[code, message];         CWF.WF1["\nLibrarian problem during checkout: %s.\n"L, message];	success ¬ FALSE;  Subr.errorflg ¬ TRUE;	ClearBoxes[feedbackSlot, @feedbackState];	GOTO return};       UNWIND => CleanUp[]};    success ¬ TRUE;    feedbackSlot ¬ HeraldWindow.GetCursorSlot[];    IF feedbackSlot # NIL THEN {	HeraldWindow.SetCursor[slot: feedbackSlot, cursor: blank];	feedbackState ¬ off};    ShowBoxes[feedbackSlot, @feedbackState];    Librarian.AddStringProperty[pl, h.atoms[reason], reason];    Librarian.CheckOut[h.server, libject];    Librarian.SetProperties[handle: h.server, libject: libject, pl: pl];    Librarian.DestroyPropertyList[pl]    EXITS      return => Librarian.DestroyPropertyList[pl]    END;    CleanUp[]};	    Retrieve: PUBLIC PROC [h: Handle, shortName: LONG STRING, window: Window.Handle] RETURNS [retrieved: BOOLEAN] = {    pl: Librarian.PropertyList ¬ Librarian.CreatePropertyList[h.zone];    host, dir, localName, vers: LONG STRING ¬ NIL;    feedbackSlot: HeraldWindow.Slot ¬ NIL;    feedbackState: flipperState ¬ off;    -- Here's a problem. Transfer expects directory names to be free of leading '<'s but     -- The librarian keeps that (It's nice for printing), so I'll strip it first..    -- So we'll take the hacked approach and fix it on the spot. I'm not willing  to    -- to change the semantics of Transfer and break the while DFfiles collection.    dirFixed: LONG STRING ¬ [100];    versint: INTEGER ¬ 0;    libjectCheckedOut: BOOLEAN;    sh: Stream.Handle ¬ NIL;    qualifiedName: LONG STRING ¬ [100];    CleanUp: PROC = {      ClearBoxes[feedbackSlot, @feedbackState];      Librarian.DestroyPropertyList[pl];      IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL}};    BEGIN ENABLE UNWIND => CleanUp[];    feedbackSlot ¬ HeraldWindow.GetCursorSlot[];    IF feedbackSlot # NIL THEN {	HeraldWindow.SetCursor[slot: feedbackSlot, cursor: blank];	feedbackState ¬ off};    ShowBoxes[feedbackSlot, @feedbackState];    [pl, libjectCheckedOut] ¬ Librarian.Query[handle: h.server, libject: shortName, what: DESCRIPTOR[BASE[h.atoms], LENGTH[h.atoms]]];    retrieved ¬ FALSE;    localName  ¬ shortName;    FeedbackProgress[feedbackSlot, @feedbackState];    host ¬ Librarian.GetStringProperty[pl, h.atoms[host]];    FeedbackProgress[feedbackSlot, @feedbackState];    dir  ¬ Librarian.GetStringProperty[pl, h.atoms[directory]];    -- Fix up DIR.    IF dir[0] = '< OR dir[0] = '/ THEN {      FOR i: CARDINAL IN [1..dir.length) DO        dirFixed[i-1] ¬ dir[i];      ENDLOOP;      dirFixed.length ¬ dir.length -1;    } ELSE {      String.Copy[dirFixed, dir];    };    FeedbackProgress[feedbackSlot, @feedbackState];    vers ¬ Librarian.GetStringProperty[pl, h.atoms[version] ! Librarian.WrongPropertyType => {vers ¬ "H"L; CONTINUE}];    CWF.SWF4[qualifiedName, "[%s]%s>%s!%s"L, host, dirFixed, localName, vers];    IF ~String.Equivalent[localName, shortName] THEN {       CWF.WF0["\n\tLibject NOT retrieved.\n"L];       CWF.WF2[         "\tLibject's 'local name' %s differs from remote short name %s.\n"L,	 localName, shortName];       GOTO leave};    -- Convert the vers to some reasonable CARDINAL for CachedOpen to chew on.    -- Possible:    -- vers = non integer string => Use bangH    -- vers = integer => use it.    versint ¬ String.StringToDecimal[s: vers ! String.InvalidNumber => {	  versint ¬ 0;	  CONTINUE}];    IF versint = 0 THEN {       CWF.WF1["Libject does not have specific version. Will try to get the most recent version of %s.\n"L, qualifiedName];    };    -- Remember this about CachedOpen    -- If wantExplicitVersion is true, wantCreateTime = 0, and version > 0, then    --   gets that version; otherwise gets !H when wantCreateTime = 0    sh ¬ Transfer.CachedOpen[  -- we actually just want the file locally      host: host, directory: dirFixed, name: localName,      wantCreateTime: [0],      wantExplicitVersion: TRUE, version: CARDINAL[versint],      checkForOverwrite: TRUE, window: window      ! Subr.FileError => {          SELECT error FROM	    notFound => CWF.WF1["Error - can't open %s.\n"L, qualifiedName];	    wrongVersion =>	      CWF.WF1[	        "Error - could not find correct version of %s.\n"L, qualifiedName];	    accessConflict =>	      CWF.WF1[	        "Error - access conflict in retrieving %s.\n"L, qualifiedName];	    ENDCASE;	  GOTO leave}];    retrieved ¬ TRUE;    EXITS leave => NULL;    END;    CleanUp[]};      CanLibjectBeCheckedIn: PUBLIC PROC [h: Handle, shortName: LONG STRING] RETURNS [yes: BOOLEAN] = {    pl: Librarian.PropertyList ¬ Librarian.CreatePropertyList[h.zone];    userOk, libjectCheckedOut: BOOLEAN;    localName, checkOutUser: LONG STRING ¬ NIL;    user: LONG STRING ¬ [100];    fullUser: LONG STRING ¬ [100];    feedbackSlot: HeraldWindow.Slot ¬ NIL;    feedbackState: flipperState ¬ off;    «    CheckUserName: PROC [name, password: Profile.String] = {      userOk ¬ String.Equivalent[checkOutUser, name];      String.Copy[user, name]};    »    CleanUp: PROC = {      ClearBoxes[feedbackSlot, @feedbackState]};    BEGIN ENABLE UNWIND => CleanUp[];    yes ¬ TRUE;    feedbackSlot ¬ HeraldWindow.GetCursorSlot[];    IF feedbackSlot # NIL THEN {	HeraldWindow.SetCursor[slot: feedbackSlot, cursor: blank];	feedbackState ¬ off};    ShowBoxes[feedbackSlot, @feedbackState];    [pl, libjectCheckedOut] ¬ Librarian.Query[handle: h.server, libject: shortName, what: DESCRIPTOR[BASE[h.atoms], LENGTH[h.atoms]]];    checkOutUser ¬ Librarian.GetStringProperty[pl, h.atoms[checkOutUser]];    IF String.Empty[checkOutUser] THEN {      CWF.WF0["\n\tLibject was not checked out..."L];      GOTO badLibject};    FeedbackProgress[feedbackSlot, @feedbackState];    -- the following will not work since Profile typically contains the alias of the user,    -- and not the distinguished name that is used in the libjects.    --Profile.GetUser[CheckUserName, clearinghouse];    -- So use this instead.    fullUser ¬ AtomicProfile.GetString[Atom.MakeAtom["fullUserName"L]];    userOk ¬ String.Equivalent[checkOutUser, fullUser];     IF ~userOk THEN {      outTOD: LONG CARDINAL ¬ Librarian.GetTimeProperty[plist: pl, tag: h.atoms[changeTime]];      reason: LONG STRING ¬ Librarian.GetStringProperty[plist: pl, tag: h.atoms[reason]];      CWF.WF1["\n\tLibject was not checked out by you (%s).\n"L, user];      CWF.WF2["\tIt was checked out by %s on %lt\n"L, checkOutUser, @outTOD];      CWF.WF1["\tReason: %s\n..."L, reason];      GOTO badLibject};    EXITS badLibject => {Subr.errorflg ¬ TRUE;  yes ¬ FALSE};    END;    CleanUp[]};      CheckinLibject: PUBLIC PROC [h: Handle, remoteName, libject: LONG STRING] RETURNS [success: BOOLEAN ¬ FALSE] = {    host, dir, name, vers: LONG STRING ¬ NIL;    vfn: FileName.VFN ¬ NIL;    feedbackSlot: HeraldWindow.Slot ¬ NIL;    feedbackState: flipperState ¬ off;    pl: Librarian.PropertyList ¬ Librarian.CreatePropertyList[z: h.zone];    CleanUp: PROC = {      ClearBoxes[feedbackSlot, @feedbackState];      IF pl # NIL THEN Librarian.DestroyPropertyList[pl];      IF vfn # NIL THEN {FileName.FreeVFN[vfn]; vfn ¬ NIL}    };    BEGIN ENABLE {     UNWIND => CleanUp[];     Librarian.Error => {	message: LONG STRING ¬ [100];	Librarian.StringForErrorCode[code, message]; 	CWF.WF2["\nLibrarian problem when checking in %s: %s.\n"L, remoteName, message];	success ¬ FALSE;  Subr.errorflg ¬ TRUE;	GOTO exit}};    feedbackSlot ¬ HeraldWindow.GetCursorSlot[];    IF feedbackSlot # NIL THEN {	HeraldWindow.SetCursor[slot: feedbackSlot, cursor: blank];	feedbackState ¬ off};    ShowBoxes[feedbackSlot, @feedbackState];    vfn ¬ FileName.AllocVFN[remoteName ! FileName.Error => {CleanUp[]; GOTO exit}];    FeedbackProgress[feedbackSlot, @feedbackState];    Librarian.AddStringProperty[pl, h.atoms[host], vfn.host];    FeedbackProgress[feedbackSlot, @feedbackState];    Librarian.AddStringProperty[pl, h.atoms[directory], vfn.directory];    FeedbackProgress[feedbackSlot, @feedbackState];    Librarian.AddStringProperty[pl, h.atoms[name], vfn.name];    FeedbackProgress[feedbackSlot, @feedbackState];    Librarian.AddStringProperty[pl, h.atoms[version], vfn.version];    FeedbackProgress[feedbackSlot, @feedbackState];    Librarian.SetPropertiesAndCheckIn[handle: h.server, libject: libject, pl: pl];    FeedbackProgress[feedbackSlot, @feedbackState];    CleanUp[];    RETURN[TRUE];    EXITS exit => {CleanUp[]};    END};	    -- Use indications of whether or not a Librarian is bound.  -- I've taken the first PROCEDURE declared in the Interface.	    Usable: PUBLIC PROCEDURE RETURNS [yes: BOOLEAN] = {yes ¬ Runtime.IsBound[LOOPHOLE[Librarian.Open]];  };    -- Private procedures.  MakeQueryAtoms:  PROCEDURE [    server: Librarian.Handle, qAtoms: LONG POINTER TO AtomArray] = {    feedbackSlot: HeraldWindow.Slot ¬ NIL;    feedbackState: flipperState ¬ off;    CleanUp: PROC = {      ClearBoxes[feedbackSlot, @feedbackState]};    BEGIN ENABLE UNWIND => CleanUp[];    feedbackSlot ¬ HeraldWindow.GetCursorSlot[];    IF feedbackSlot # NIL THEN {	HeraldWindow.SetCursor[slot: feedbackSlot, cursor: blank];	feedbackState ¬ off};    ShowBoxes[feedbackSlot, @feedbackState];    -- Reserved atoms.    FeedbackProgress[feedbackSlot, @feedbackState];    qAtoms[checkOutUser] ¬ Librarian.MakeAtom[handle: server, s: "CheckOutUser"L];    FeedbackProgress[feedbackSlot, @feedbackState];    qAtoms[changeTime] ¬ Librarian.MakeAtom[handle: server, s: "ChangeTime"L];    -- For our application.    FeedbackProgress[feedbackSlot, @feedbackState];    qAtoms[host] ¬ Librarian.MakeAtom[handle: server, s: "host"L];    FeedbackProgress[feedbackSlot, @feedbackState];    qAtoms[directory] ¬ Librarian.MakeAtom[handle: server, s: "directory"L];    FeedbackProgress[feedbackSlot, @feedbackState];    qAtoms[name] ¬ Librarian.MakeAtom[handle: server, s: "name"L];    FeedbackProgress[feedbackSlot, @feedbackState];    qAtoms[version] ¬ Librarian.MakeAtom[handle: server, s: "version"L];    FeedbackProgress[feedbackSlot, @feedbackState];    qAtoms[create] ¬ Librarian.MakeAtom[handle: server, s: "create"L];    FeedbackProgress[feedbackSlot, @feedbackState];    qAtoms[reason] ¬ Librarian.MakeAtom[handle: server, s: "reason"L];    END;    CleanUp[];};  -- of MakeQueryAtoms      -- Flipper support.  ShowBoxes: PROC [feedbackSlot: HeraldWindow.Slot, feedbackState: LONG POINTER TO flipperState] = {    IF feedbackSlot # NIL THEN {      HeraldWindow.SetCursor[slot: feedbackSlot, cursor: lib];      feedbackState­ ¬ left}};      ClearBoxes: PROC [feedbackSlot: HeraldWindow.Slot, feedbackState: LONG POINTER TO flipperState] = {    IF feedbackSlot # NIL THEN {      HeraldWindow.SetCursor[slot: feedbackSlot, cursor: blank];      feedbackSlot ¬ HeraldWindow.FreeCursorSlot[feedbackSlot];      feedbackState­ ¬ off}};  FeedbackProgress: PROC [feedbackSlot: HeraldWindow.Slot, feedbackState: LONG POINTER TO flipperState] = {    cursorState: HeraldWindow.CursorState;    IF feedbackSlot # NIL THEN {      SELECT feedbackState­ FROM        off     => {	  HeraldWindow.SetCursor[slot: feedbackSlot, cursor: lib];	  cursorState ¬ negative;  feedbackState­ ¬ left};         left    => {cursorState ¬ positive;  feedbackState­ ¬ right}; 	ENDCASE => {cursorState ¬ negative;  feedbackState­ ¬ left};      HeraldWindow.SetCursorState[slot: feedbackSlot, state: cursorState]}};      }.    Change log:12-Sep-84  9:41:58	DSC  	Added Usable PROCEDURE to detect presence of the librarian..21-Nov-84 13:47:16	DSC  	Made it call the corresponding NS and Pup routines.21-Jan-85  9:59:34	DSC  	Made it NS only.21-Jan-85 14:56:28	DSC  	Rewritten to make it object based. 6-Feb-85 12:57:16	DSC  	Profile.GetUser's qualification changed from registry to clearninghouse. 7-Feb-85 13:45:46	DSC  	Fixed version to be STRING instead of INTEGERs. 8-Feb-85 12:47:34	DSC  	Don't free Handle.servername here!. It's owned by the caller.14-Feb-85 14:09:41	DSC  	Allow for libjects with no version properties. Catch that as a !H.14-Feb-85 17:51:21	DSC  	Remove leading '< from  dir in librarian entry to make Transfer happy.26-Feb-85 11:03:30	DSC  	Added AtomicProfile usage. 6-Mar-85 15:38:55	DSC  	LIB FLippers. 6-May-85 12:30:47	DSC  	won't do I/O in Profile.GetID (monitorlocks).16-Sep-85 10:23:29	DSC  	Use Auth.CopyIdentity.11-Feb-86 11:09:17	DSC  	Check for NIL servername. 
-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- DFSubr.mesa - Last edited by --   Schmidt	 9-Mar-82 14:51:28--   BTL  	20-Sep-83 15:34:34DIRECTORY  Exec USING [Handle],  MFile USING [Handle],  MStream USING [Handle],  Time USING [Packed],  Window USING [Handle];DFSubr: DEFINITIONS =  BEGIN  DF: TYPE = LONG POINTER TO DFFileRecord;  DFFileRecord: TYPE = RECORD [    host: LONG STRING ¬ NIL,      	 -- ivy    directory: LONG STRING ¬ NIL, 	 -- schmidt>model    shortname: LONG STRING ¬ NIL, 	 -- junk.mesa    version: CARDINAL ¬ 0, 		 -- 23    createtime: Time.Packed ¬ [0], 	 -- > 0 is create time from leader pg.    comment: LONG STRING ¬ NIL,          -- comment before this line    recorder: LONG STRING ¬ NIL,         -- DescribeBcd, VerifyDf, ReleaseTool    releaseHost: LONG STRING ¬ NIL,      -- release on Ivy    releaseDirectory: LONG STRING ¬ NIL, -- release as Cedar>Top    criterion: Criterion ¬ none,	 -- transfer criterion    need: BOOLEAN ¬ FALSE, 		 -- need to retrieve this file    atsign: BOOLEAN ¬ FALSE, 		 -- indirect this df file    public: BOOLEAN ¬ FALSE,  		 -- if T then directory was Public    publicOnly: BOOLEAN ¬ FALSE, 	 -- if T then {PublicOnly} in filename    readonly: BOOLEAN ¬ FALSE, 		 -- readonly directory or imported    cameFrom: BOOLEAN ¬ FALSE, 		 -- T => CameFrom, F => ReleaseAs    topmark: BOOLEAN ¬ FALSE,  		 -- "+": a top level bcd in DF    released: BOOLEAN ¬ FALSE,  	 -- "*": a public/released top level file    newOnly: BOOLEAN ¬ FALSE,	         -- "~"; get only if not already on disk    parentCameFrom: BOOLEAN ¬ FALSE, 	 -- used by ReleaseTool    presentonlocaldisk: BOOLEAN ¬ FALSE, -- file is on local disk    systemfile: BOOLEAN ¬ FALSE, 	 -- is a Mesa system file    eval: BOOLEAN ¬ FALSE, 		 -- has been evaluated in EvalBcds    isdefns: BOOLEAN ¬ FALSE,  		 -- used by describebcd    exportsAnalyzed: BOOLEAN ¬ FALSE, 	 -- used by FlattenDF    includeAnalyzed: BOOLEAN ¬ FALSE,	 -- used by FlattenDF    versionstamp: Time.Packed ¬ [0],  	 -- used by DescribeBcd & VerifyDF    fHandle: MFile.Handle ¬ NIL,    using: UsingSeq ¬ NIL]; 		 -- using list for df file      -- notequal, none => transfer if # dates;  update => like retrieve/U  Criterion: TYPE = {none, update, notequal};  UsingSeq: TYPE = LONG POINTER TO UsingSeqRecord;  UsingSeqRecord: TYPE = RECORD [    zone: UNCOUNTED ZONE ¬ NIL,  -- the zone the strings are in    size: CARDINAL ¬ 0,    body: SEQUENCE maxsize: CARDINAL OF LONG STRING];  -- the strings, may be NIL  -- don't change these without looking at AllocSpecialSeq in DFSubrImpl  DFSeq: TYPE = LONG POINTER TO DFSeqRecord;  DFSeqRecord: TYPE = RECORD [    dfzone: UNCOUNTED ZONE ¬ NIL,    zoneType: ZoneType ¬ shared,    size: CARDINAL ¬ 0,    trailingcomment: LONG STRING ¬ NIL,    igorHost: LONG STRING ¬ NIL,	-- if huge, then "Igor"    idunHost: LONG STRING ¬ NIL,	-- if huge then "Idun"    body: SEQUENCE maxsize: CARDINAL OF DFFileRecord];      ZoneType: TYPE = {shared, single, huge};    -- Used by FlattenDF: don't parse a DF file imported from a EXSeq dir    EXSeq: TYPE = LONG POINTER TO EXSeqRecord;  EXSeqRecord: TYPE = RECORD [    size: CARDINAL ¬ 0,    body: SEQUENCE maxsize: CARDINAL OF      RECORD [        host: LONG STRING ¬ NIL,         -- "Idun"        directory: LONG STRING ¬ NIL,    -- "APilot>Pilot>Private"        shortname: LONG STRING ¬ NIL]];  -- "FileName.Mesa" -- Procedures defined in DFParserImpl   TooManyParseErrors: ERROR;  -- raised by ParseStream if limitErrors=TRUE    DFEntryProcType: TYPE = PROC [dfEntry: DF];  InterestingNestedDFProcType: TYPE = PROC [    host, directory, shortname, ancestor, immediateParent: LONG STRING,    version, nLevel: CARDINAL, createtime: Time.Packed,    driverUsingSeq, innerUsingSeq: UsingSeq, dfEntry: DF,    entryIsReadonly, publicOnly: BOOLEAN, criterion: Criterion];  -- if noremoteerrors, no complaint if a file doesn't seem to have remote place  -- if forceReadonly, make every entry in this DF file be ReadOnly  -- if omitNonPublic, don't parse them into dfseq  -- dffilename is for error messages  ParseStream: PROC [    sh: MStream.Handle, dfseq: DFSeq, dffilename: LONG STRING, using: UsingSeq,    noremoteerrors, forceReadonly, omitNonPublic: BOOLEAN,    interestingNestedDF: InterestingNestedDFProcType ¬ NIL,    dfEntryProc: DFEntryProcType ¬ NIL, ancestor: LONG STRING ¬ NIL,    nLevel: CARDINAL ¬ 0,    limitErrors: BOOLEAN ¬ FALSE]; -- Procedures defined in DFSubrImpl   AllocateDFSeq: PROC [    maxEntries: CARDINAL, zoneType: ZoneType] RETURNS [dfseq: DFSeq];  NextDF: PROC [dfseq: DFSeq] RETURNS [df: DF];  FreeDFSeq: PROC [pdfseq: LONG POINTER TO DFSeq];  -- input/output  TooManyEntries: ERROR;  -- raised by FlattenDF when dfseq fills up  FlattenDF: PROC [    dfseq: DFSubr.DFSeq, dffilename: LONG STRING,    exec: Exec.Handle, window: Window.Handle,    defaultUserName, defaultUserPassword: LONG STRING ¬ NIL,    checkForOverwrite, allowForceReadOnly: BOOLEAN ¬ TRUE,    setRecorder, printStatus, skipCameFrom, retrieveDFsToTemp: BOOLEAN ¬ FALSE,    localDFDir: LONG STRING ¬ NIL,    exList: EXSeq ¬ NIL];  -- don't parse a DF file imported from a EXSeq dir  WriteOut: PROC [    dfseq: DFSeq, topLevelFile: STRING, outputStream: MStream.Handle,    print: BOOLEAN ¬ FALSE];  -- UsingSeq procedures  AppendToUsingSeq: PROC [      oldusing: UsingSeq,  -- may be NIL      shortname: LONG STRING, zone: UNCOUNTED ZONE]    RETURNS [newusing: UsingSeq];  UsingEmpty: PROC [usingseq: UsingSeq] RETURNS [empty: BOOLEAN];  IntersectUsing: PROC [driver, limiter: UsingSeq] RETURNS [newusing: UsingSeq];  CopyUsing: PROC [limiter: UsingSeq] RETURNS [newusing: UsingSeq];  FreeUsingSeq: PROC [using: UsingSeq];  -- utilities  ReadInDir: PROC [dfseq: DFSeq];    -- obsolescent: gets ReadOnly handles  LookupFiles: PROC [dfseq: DFSeq];  -- gets handles with anchor access  LookupOneFile: PROC [df: DF];      -- get handle with anchor access  LookupDF: PROC [dfseq: DFSeq, shortname: LONG STRING] RETURNS [df: DF];  -- fullname is readonly.  host, directory, short may be NIL.  -- If mustbedir, then if long does not end in a '>  -- the tail is assumed to be part of the directory, not the short,  -- e.g. "schmidt>pilot" is all a directory if mustbedir is TRUE.  StripLongName: PROC [      fullname, host, directory, short: LONG STRING, mustbedir: BOOLEAN ¬ FALSE]    RETURNS [version: CARDINAL];  SortByFileName: PROC [    dfseq: DFSeq, min, max: CARDINAL, ignorehostanddir: BOOLEAN ¬ FALSE];  CompareDFs: PROC [      dfleft, dfright: DF, ignorehostanddir: BOOLEAN ¬ FALSE]    RETURNS [res: INTEGER];  InsertCRs: PROC [dfseq: DFSeq];  END.
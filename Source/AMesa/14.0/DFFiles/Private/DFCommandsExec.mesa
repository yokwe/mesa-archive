-- File: DFCommandsExec.mesa - last edit:-- kam                 19-Dec-85 13:09:49-- Copyright (C) 1985 by Xerox Corporation. All rights reserved. DIRECTORY  BringOverInterface USING [    AlreadyRunning, BringOverDF, CheckAbortProc, CheckThisFile,    DefaultOptions, DoneRunning, FreeUsingSeqWithError, Options, RecursiveLoop],  CWF USING [WF0, WF1, WFC, WFCR, WFError],  DFDeleteInterface USING [    AlreadyRunning, CheckAbortProc, DefaultOptions, DeleteDF, DoneRunning,    Finalize, Initialize, Options],  DFLibrarian USING [Finalize, Handle, Object],  DFSubr USING [AppendToUsingSeq, FreeUsingSeq, TooManyEntries, UsingSeq],  Event USING [DoneWithProcess, Handle, Object, StartingProcess],  Exec USING [    AddCommand, CheckAbortProc, CheckForAbort, ExecProc, FreeTokenString,    GetToken, Handle, Object, Outcome, OutputProc, RemoveCommand],  FileName USING [Error],  FileTransfer USING [CodeToString, Error],  Format USING [StringProc],  Heap USING [Error, systemZone],  LeafSubr USING [StartLeaf, StopLeaf],  Librarian USING [Error, Handle, StringForErrorCode],  MFile USING [    Acquire, AppendErrorMessage, Delete, Error, Handle, maxNameLength, Object],  MSegment USING [Error, Handle, Object],  MStream USING [Error, Handle, ReadOnly],  Profile USING [GetLibrarian, String],  SModelInterface USING [    AlreadyRunning, CheckAbortProc, DefaultOptions, DoneRunning, Options,    StoreDF],  Stream USING [Delete, EndOfStream, GetChar],  String USING [    AppendExtensionIfNeeded, AppendString, CopyToNewString, Empty, Equivalent,    FreeString],  Subr USING [    AppendMSegmentErrorMessage, AppendMStreamErrorMessage, checkLibrarian,    debugflg, DeleteHugeZone, dfLibjectsOnly, errorflg, FreeString,    GetLocalDir, HugeZone, LongZone, PrintGreeting, SetIntegrationLoc,    SetLocalDFDir, SetUpCWFWriteProcedure, SetWorkingDFLoc, SubrInit, SubrStop],  Time USING [Current, Packed],  Transfer USING [    Finalize, Initialize, RegisterConnCredentials],  VerifyDFInterface USING [    AlreadyRunning, CheckAbortProc, DefaultOptions, DoneRunning, Options,    VerifyDFFile],  Volume USING [InsufficientSpace];DFCommandsExec: MONITOR  IMPORTS    BringOverInterface, CWF, DFDeleteInterface, DFLibrarian, DFSubr, Event,    Exec, FileName, FileTransfer, Heap, LeafSubr, Librarian, MFile, MSegment,    MStream, Profile, SModelInterface, Stream, String, Subr, Time, Transfer,    VerifyDFInterface, Volume =    BEGIN    commandRunning: BOOLEAN ¬ FALSE;    TestNoCommandRunning: ENTRY PROCEDURE [h: Exec.Handle] RETURNS [ok: BOOLEAN] =    BEGIN    ok ¬ NOT commandRunning;    IF ok THEN commandRunning ¬ TRUE    ELSE Exec.OutputProc[h]["A command is already running... aborted"L];    END;      DoBringOver: Exec.ExecProc = {    startTime, elapsedTime: Time.Packed;    exec: Exec.Handle ¬ h;    myEventHandle: Event.Handle ¬ NIL;        Cleanup: ENTRY PROC = {      Transfer.Finalize[];  Subr.SubrStop[];      Event.DoneWithProcess[myEventHandle];  myEventHandle ¬ NIL;      BringOverInterface.DoneRunning[];      commandRunning ¬ FALSE};    BEGIN      ENABLE {        UNWIND => Cleanup[];        FileTransfer.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [60];	    FileTransfer.CodeToString[code, msg];	    CWF.WF1["FileTransfer error: %s\n"L, msg];	    GOTO error};        ABORTED => {CWF.WF0["\n...BringOver aborted.\n"L];  GOTO abort};        BringOverInterface.CheckThisFile =>	  RESUME;  -- if here then no infinite recursive loop        Volume.InsufficientSpace => {CWF.WF0["Volume full.\n"L];  GOTO error};	FileName.Error =>	  IF Subr.debugflg THEN REJECT	  ELSE {CWF.WF0["FileName error.\n"L];  GOTO error};        BringOverInterface.RecursiveLoop => {          CWF.WF0["Error - infinite recursive nesting of DF files using @.\n"L];          CWF.WF1["\tOne of the files involved is %s.\n"L, loopfilename];          ERROR ABORTED};	CWF.WFError => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    CWF.WF1["\nCWF error: %s.\n"L, err];	    GOTO error};	MFile.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];	    CWF.WF1["MFile error: %s.\n"L, msg];   	    GOTO error};        MStream.Error =>  	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMStreamErrorMessage[msg, code, stream];	    CWF.WF1["MStream error: %s.\n"L, msg];   	    GOTO error};	MSegment.Error =>   	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMSegmentErrorMessage[msg, code, segment];	    CWF.WF1["MSegment error: %s.\n"L, msg];   	    GOTO error}};	    IF NOT TestNoCommandRunning[h] THEN RETURN[abort];    IF BringOverInterface.AlreadyRunning[] THEN {       Exec.OutputProc[h][" BringOver already running!"L];      RETURN[abort]};    startTime ¬ Time.Current[];    Subr.SetUpCWFWriteProcedure[];  Subr.SubrInit[exec];    Subr.errorflg ¬ Subr.debugflg ¬ FALSE;    Subr.PrintGreeting["BringOver"L];    myEventHandle ¬ Event.StartingProcess["BringOver"L];    Transfer.Initialize[exec: exec, window: NIL];  -- use exec window for I/O    outcome ¬ GetFiles[exec];    EXITS      error => {Subr.errorflg ¬ TRUE;  outcome ¬ error};      abort => outcome ¬ abort;    END;    IF Subr.errorflg THEN CWF.WF0["\nErrors logged.\n"L] ELSE CWF.WFCR[];    elapsedTime ¬ [Time.Current[] - startTime];    CWF.WF1["Total elapsed time for BringOver %lr.\n\n"L, @elapsedTime];    Cleanup[]};      GetFiles: PROC [exec: Exec.Handle] RETURNS [outcome: Exec.Outcome] = {    opt, globalOpt: BringOverInterface.Options ¬      BringOverInterface.DefaultOptions;    dfFileNamed: BOOLEAN ¬ FALSE;    name, sw, dfName, onlyfile: LONG STRING ¬ NIL;    usingSeq: DFSubr.UsingSeq ¬ NIL;    localDir: LONG STRING ¬ NIL;    dfZone: UNCOUNTED ZONE ¬ Subr.LongZone[];        CheckAbortInExec: BringOverInterface.CheckAbortProc = {      RETURN[Exec.CheckForAbort[exec]]};        Cleanup: PROC = {      IF ~String.Empty[name] THEN name ¬ Exec.FreeTokenString[name];      IF ~String.Empty[sw] THEN sw ¬ Exec.FreeTokenString[sw];      IF ~String.Empty[onlyfile] THEN onlyfile ¬ Exec.FreeTokenString[onlyfile];      IF ~String.Empty[dfName] THEN {        String.FreeString[z: dfZone, s: dfName];  dfName ¬ NIL};      IF ~String.Empty[localDir] THEN {        Subr.FreeString[localDir, dfZone];  localDir ¬ NIL};      IF usingSeq # NIL THEN {DFSubr.FreeUsingSeq[usingSeq];  usingSeq ¬ NIL}};        BEGIN    outcome ¬ normal;    [name, sw] ¬ Exec.GetToken[exec];    WHILE ~String.Empty[name] OR ~String.Empty[sw] DO      IF ~String.Empty[sw] AND String.Empty[name] THEN {  -- global switches        SetBringOverSwitches[@globalOpt, sw];	IF globalOpt.onlyFileMode THEN {	  -- have to treat remaining tokens specially	  name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	  [onlyfile, sw] ¬ Exec.GetToken[exec]; sw ¬ Exec.FreeTokenString[sw];	  IF String.Empty[onlyfile] THEN {	    CWF.WF0["Error - /o must be followed by file name.\n"L];  GOTO error};	  usingSeq ¬ NIL;	  DO  -- onlyfile lags name; when name is empty, onlyfile has last name	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];              IF String.Empty[name] THEN {	      name ¬ onlyfile;  onlyfile ¬ NIL;  GOTO lookForDFfile};            usingSeq ¬ DFSubr.AppendToUsingSeq[usingSeq, onlyfile, dfZone];	    [] ¬ Exec.FreeTokenString[onlyfile];	    onlyfile ¬ name;            ENDLOOP;          EXITS lookForDFfile => NULL}	ELSE {  -- done with global switches, but not /o mode	  name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];          [name, sw] ¬ Exec.GetToken[exec];	  LOOP}};      opt ¬ globalOpt;      IF ~String.Empty[sw] THEN SetBringOverSwitches[@opt, sw];      IF opt.cmd THEN {        SELECT TRUE FROM          String.Equivalent[name, "localDir"L] => { -- next token is local dir	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - localDir/c must be followed by a directory name.\n"L];	      GOTO error};	    IF ~String.Empty[localDir] THEN Subr.FreeString[localDir, dfZone];            localDir ¬ Subr.GetLocalDir[name, dfZone]};          String.Equivalent[name, "localDFDir"L] => { -- next token is df dir	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - localDFDir/c must be followed by a directory name.\n"L];	      GOTO error};	    Subr.SetLocalDFDir[name]};          String.Equivalent[name, "workingDFLoc"L] => { -- next is working loc	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - workingDFLoc/c must be followed by [Host]<Dir>.\n"L];	      GOTO error};	    Subr.SetWorkingDFLoc[name]};          String.Equivalent[name, "integrationLoc"L] => { -- next is int loc	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - integrationLoc/c must be followed by [Host]<Dir>.\n"L];	      GOTO error};	    Subr.SetIntegrationLoc[name]};	  ENDCASE => {	    CWF.WF1["Error - unrecognized command %s.\n"L, name];  GOTO error};	name ¬ Exec.FreeTokenString[name];	[name, sw] ¬ Exec.GetToken[exec];	LOOP};      -- process DF file name      IF ~String.Empty[name] THEN {        dfFileNamed ¬ TRUE;	dfName ¬ String.CopyToNewString[s: name, z: dfZone, longer: 3];	Subr.debugflg ¬ opt.debugging;        BringOverInterface.BringOverDF[	  dfFileName: dfName, usingSeq: usingSeq,	  opt: opt, localDir: localDir, 	  dfZone: dfZone, window: NIL, abortProc: CheckAbortInExec];	String.FreeString[z: dfZone, s: dfName];  dfName ¬ NIL};      name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];      [name, sw] ¬ Exec.GetToken[exec];      ENDLOOP;    IF usingSeq # NIL THEN {      BringOverInterface.FreeUsingSeqWithError[usingSeq];  usingSeq ¬ NIL};    IF ~dfFileNamed THEN {      CWF.WF0["Error - No DF file specified.\n"L];  Subr.errorflg ¬ TRUE};    EXITS error => Subr.errorflg ¬ TRUE;    END;    IF Subr.errorflg THEN outcome ¬ error};      SetBringOverSwitches: PROC [      opt: POINTER TO BringOverInterface.Options, sw: LONG STRING] = {    sense: BOOLEAN ¬ TRUE;    FOR i: CARDINAL IN [0..sw.length) DO      SELECT sw[i] FROM        'a, 'A => {opt.mustConfirm      ¬ ~sense;  sense ¬ TRUE};        'p, 'P => {opt.publicOnly       ¬  sense;  sense ¬ TRUE};        'v, 'V => {opt.verify           ¬  sense;  sense ¬ TRUE};        '<     => {opt.getOlderOK       ¬  sense;  sense ¬ TRUE};        'u, 'U => {opt.updateExisting   ¬  sense;  sense ¬ TRUE};        'f, 'F => {opt.forceRetrieval   ¬  sense;  sense ¬ TRUE};        'd, 'D => {opt.debugging        ¬  sense;  sense ¬ TRUE};        'z, 'Z => {opt.preRelease       ¬  sense;  sense ¬ TRUE};        'x, 'X => {opt.archiveBcdRename ¬  sense;  sense ¬ TRUE};        'b, 'B => {opt.justObjects	¬  sense;  sense ¬ TRUE};        'r, 'R => {opt.justReadOnlys	¬  sense;  sense ¬ TRUE};        's, 'S => {opt.justSources	¬  sense;  sense ¬ TRUE};        'w, 'W => {opt.justNonReadOnlys ¬  sense;  sense ¬ TRUE};        'o, 'O => {opt.onlyFileMode     ¬  sense;  sense ¬ TRUE};        'c, 'C => {opt.cmd	        ¬  sense;  sense ¬ TRUE};	'-, '~ => sense ¬ ~sense;        ENDCASE => {	  CWF.WF1["Unknown switch in '%s'\n"L, sw];  Subr.errorflg ¬ TRUE}      ENDLOOP};        DoDelete: Exec.ExecProc = {    starttime: Time.Packed;    exec: Exec.Handle ¬ h;    temp: MFile.Handle ¬ NIL;    lineDotCm: MStream.Handle ¬ NIL;  -- for echoing Line.cm    myEventHandle: Event.Handle ¬ NIL;        Cleanup: ENTRY PROC = {      IF lineDotCm # NIL THEN {Stream.Delete[lineDotCm];  lineDotCm ¬ NIL};      Transfer.Finalize[];  Subr.SubrStop[];  DFDeleteInterface.Finalize[];      Event.DoneWithProcess[myEventHandle];  myEventHandle ¬ NIL;      DFDeleteInterface.DoneRunning[];      commandRunning ¬ FALSE};        BEGIN      ENABLE {        ABORTED => {CWF.WF0["\n...DFDelete Aborted.\n"L];  GOTO abort};        UNWIND => Cleanup[];        Volume.InsufficientSpace => {CWF.WF0["Volume full.\n"L];  GOTO error};	MFile.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];	    CWF.WF1["MFile error: %s.\n"L, msg];   	    GOTO error};	MStream.Error =>  	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMStreamErrorMessage[msg, code, stream];	    CWF.WF1["MStream error: %s.\n"L, msg];   	    GOTO error};	MSegment.Error =>   	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMSegmentErrorMessage[msg, code, segment];	    CWF.WF1["MSegment error: %s.\n"L, msg];   	    GOTO error}};    IF NOT TestNoCommandRunning[h] THEN RETURN[abort];    IF DFDeleteInterface.AlreadyRunning[] THEN {       Exec.OutputProc[h]["\nDFDelete already running!"L];      RETURN[abort]};    starttime ¬ Time.Current[];    outcome ¬ normal;    Subr.SetUpCWFWriteProcedure[];    Subr.SubrInit[exec];      Subr.PrintGreeting["DFDelete"L];    myEventHandle ¬ Event.StartingProcess["DFDelete"L];    Subr.errorflg ¬ Subr.debugflg ¬ FALSE;    Transfer.Initialize[exec: h, window: NIL];  DFDeleteInterface.Initialize[];    -- delete old Line.cm file    temp ¬ MFile.Acquire[name: "Line.cm"L, access: delete, release: []      ! MFile.Error => CONTINUE];    IF temp # NIL THEN {      MFile.Delete[temp ! MFile.Error => CONTINUE];  temp ¬ NIL};    outcome ¬ DeleteFiles[exec];    DFDeleteInterface.Finalize[];    -- echo Line.cm, if created    lineDotCm ¬ MStream.ReadOnly["Line.cm"L, [] ! MStream.Error => GOTO noLineCm];    CWF.WF0["-----------------------------------------------------------\n"L];    CWF.WF0["Contents of Line.cm:\n\n"L];    DO       CWF.WFC[Stream.GetChar[lineDotCm ! Stream.EndOfStream => EXIT]];      ENDLOOP;    Stream.Delete[lineDotCm];  lineDotCm ¬ NIL;    CWF.WF0["\n----------------------------------------------------------\n"L];    EXITS      noLineCm => NULL;      error => outcome ¬ error;      abort => outcome ¬ abort;    END;    IF Subr.errorflg THEN {CWF.WF0["\tErrors logged.\n"L];  outcome ¬ error};    starttime ¬ [Time.Current[] - starttime];    CWF.WF1["\nTotal elapsed time for DFDelete %lr.\n"L, @starttime];    Cleanup[]};      DeleteFiles: PROC [exec: Exec.Handle] RETURNS [outcome: Exec.Outcome] = {    opt, globalOpt: DFDeleteInterface.Options ¬ DFDeleteInterface.DefaultOptions;    dfZone: UNCOUNTED ZONE ¬ Subr.LongZone[];    name, sw: LONG STRING ¬ NIL;    dfName: LONG STRING ¬ NIL;        CheckAbortInExec: DFDeleteInterface.CheckAbortProc = {      RETURN[Exec.CheckForAbort[exec]]};        Cleanup: PROC = {      Transfer.Finalize[];  Subr.SubrStop[];  DFDeleteInterface.Finalize[];      DFDeleteInterface.DoneRunning[]};        outcome ¬ normal;    [name, sw] ¬ Exec.GetToken[exec];    WHILE ~String.Empty[name] OR ~String.Empty[sw] DO      IF ~String.Empty[sw] AND String.Empty[name] THEN {  -- global switches        SetDeleteSwitches[@globalOpt, sw];	name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];        [name, sw] ¬ Exec.GetToken[exec];	LOOP};      opt ¬ globalOpt;      IF ~String.Empty[sw] THEN SetDeleteSwitches[@opt, sw];      IF ~String.Empty[name] THEN {        dfName ¬ String.CopyToNewString[s: name, z: dfZone, longer: 3];        [] ¬ String.AppendExtensionIfNeeded[	  to: @dfName, extension: ".df"L, z: dfZone];	Subr.debugflg ¬ opt.debugging;	DFDeleteInterface.DeleteDF[	  dfFileName: dfName, opt: opt,	  exec: exec, window: NIL, abortProc: CheckAbortInExec	  ! DFSubr.TooManyEntries => {	      CWF.WF1["Error - too many file entries in %s.\n"L, dfName];	      Subr.errorflg ¬ TRUE;	      CONTINUE}];	String.FreeString[dfZone, dfName];  dfName ¬ NIL};      name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];      [name, sw] ¬ Exec.GetToken[exec];      ENDLOOP;    IF Subr.errorflg THEN outcome ¬ error};      SetDeleteSwitches: PROC [      opt: POINTER TO DFDeleteInterface.Options, sw: LONG STRING] = {    sense: BOOLEAN ¬ TRUE;    FOR i: CARDINAL IN [0..sw.length) DO      SELECT sw[i] FROM        'r, 'R => {opt.alsoDeleteReadOnly ¬ sense;  sense ¬ TRUE};         'd, 'D => {opt.debugging          ¬ sense;  sense ¬ TRUE}; 	'-, '~ => sense ¬ ~sense;        ENDCASE => {	  CWF.WF1["Unknown switch in '%s'\n"L, sw];  Subr.errorflg ¬ TRUE}      ENDLOOP};      DoStore: Exec.ExecProc = {    startTime, elapsedTime: Time.Packed;    exec: Exec.Handle ¬ h;    myEventHandle: Event.Handle ¬ NIL;    libobject: DFLibrarian.Object;        Cleanup: ENTRY PROC = {      Transfer.Finalize[];        DFLibrarian.Finalize[@libobject];      Subr.SubrStop[];      Event.DoneWithProcess[myEventHandle];  myEventHandle ¬ NIL;      SModelInterface.DoneRunning[];      commandRunning ¬ FALSE};        BEGIN      ENABLE {      	UNWIND => Cleanup[];        ABORTED => {CWF.WF0["\n...SModel aborted.\n"L];  GOTO abort};        FileTransfer.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [60];	    FileTransfer.CodeToString[code, msg];	    CWF.WF1["\nFileTransfer error: %s\n"L, msg];	    GOTO error};        Volume.InsufficientSpace => {CWF.WF0["\nVolume full\n"L];  GOTO error};	FileName.Error =>	  IF Subr.debugflg THEN REJECT	  ELSE {CWF.WF0["FileName error.\n"L];  GOTO error};        Librarian.Error => {	  errorString: LONG STRING = [80];	  Librarian.StringForErrorCode[code, errorString];          CWF.WF1["\nLibrarian error: %s.\n"L, errorString];  	  GOTO error};	CWF.WFError => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    CWF.WF1["\nCWF error: %s.\n"L, err];	    GOTO error};	MFile.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];	    CWF.WF1["MFile error: %s\n"L, msg];   	    GOTO error};        MStream.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMStreamErrorMessage[msg, code, stream];	    CWF.WF1["MStream error: %s.\n"L, msg];   	    GOTO error};	MSegment.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMSegmentErrorMessage[msg, code, segment];	    CWF.WF1["MSegment error: %s.\n"L, msg];   	    GOTO error}};	    IF NOT TestNoCommandRunning[h] THEN RETURN[abort];    IF SModelInterface.AlreadyRunning[] THEN {       Exec.OutputProc[exec][" SModel already running!"L];      RETURN[abort]};    startTime ¬ Time.Current[];    Subr.SetUpCWFWriteProcedure[];    Subr.SubrInit[exec];      Subr.PrintGreeting["SModel"L];    Subr.errorflg ¬ Subr.debugflg ¬ FALSE;    myEventHandle ¬ Event.StartingProcess["SModel"L];    Transfer.Initialize[exec: exec, window: NIL];  -- use exec window for i/o    outcome ¬ StoreFiles[exec, libobject];    IF Subr.errorflg THEN outcome ¬ error;    EXITS      error => {Subr.errorflg ¬ TRUE;  outcome ¬ error};      abort => outcome ¬ abort;    END;    IF Subr.errorflg THEN CWF.WF0["\nErrors logged.\n"L] ELSE CWF.WFCR[];    elapsedTime ¬ [Time.Current[] - startTime];    CWF.WF1["Total elapsed time for SModel %lr.\n"L, @elapsedTime];    Cleanup[]};      StoreFiles: PROC [exec: Exec.Handle, libobject: DFLibrarian.Object] RETURNS [outcome: Exec.Outcome] = {    opt, globalOpt: SModelInterface.Options ¬ SModelInterface.DefaultOptions;    name, sw, dfName: LONG STRING ¬ NIL;    dfZone: UNCOUNTED ZONE ¬ Subr.LongZone[];        CheckAbortInExec: SModelInterface.CheckAbortProc = {      RETURN[Exec.CheckForAbort[exec]]};        Cleanup: PROC = {      IF name # NIL THEN {name ¬ Exec.FreeTokenString[name];  name ¬ NIL};      IF sw # NIL THEN {sw ¬ Exec.FreeTokenString[sw];  sw ¬ NIL};      IF dfName # NIL THEN {        String.FreeString[z: dfZone, s: dfName];  dfName ¬ NIL};      IF libobject.servername # NIL THEN String.FreeString[dfZone, libobject.servername]};      GetServer: PROCEDURE RETURNS [db: LONG STRING] = {    StuffString: PROCEDURE [str: Profile.String] = {      db ¬ String.CopyToNewString[s: str, z: Heap.systemZone]};    Profile.GetLibrarian[StuffString]};        BEGIN    -- Set the check librarian flag though the User.cm entry    globalOpt.checkLibrarian ¬ Subr.checkLibrarian;    globalOpt.dfLibjectsOnly ¬ Subr.dfLibjectsOnly;    globalOpt.libHandle ¬ @libobject;    globalOpt.libHandle.servername ¬ GetServer[];    outcome ¬ normal; -- be optimistic.    [name, sw] ¬ Exec.GetToken[exec];  -- Get first set    WHILE ~String.Empty[name] OR ~String.Empty[sw] DO      IF ~String.Empty[sw] AND String.Empty[name] THEN {  -- switches only, so it must be global switches        SetStoreSwitches[@globalOpt, sw]; -- Save the globals to be used later.	name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];        [name, sw] ¬ Exec.GetToken[exec];	LOOP};      -- Logically  the ELSE part starts here..      opt ¬ globalOpt;      IF ~String.Empty[sw] THEN SetStoreSwitches[@opt, sw];      IF opt.cmd THEN {        SELECT TRUE FROM          String.Equivalent[name, "WorkingDFLoc"L] => { -- next is working loc	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - WorkingDFLoc/c must be followed by [Host]<Dir>.\n"L];	      GOTO error};	    Subr.SetWorkingDFLoc[name]};          String.Equivalent[name, "IntegrationLoc"L] => { -- next is int loc	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - IntegrationLoc/c must be followed by [Host]<Dir>.\n"L];	      GOTO error};	    Subr.SetIntegrationLoc[name]};          String.Equivalent[name, "Connect"L],	  String.Equivalent[name, "Conn"L] => { -- next 2 are dir & password	    dir: LONG STRING;	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - Connect/c must be followed by 'Dir Password'.\n"L];	      GOTO error};	    dir ¬ name;	    [name, sw] ¬ Exec.GetToken[exec];  -- name is connect password	    IF ~String.Empty[sw] THEN {  -- assume empty connect password	      Transfer.RegisterConnCredentials[dir: dir, password: ""L];	      dir ¬ Exec.FreeTokenString[dir];	      LOOP};	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - Connect/c must be followed by 'Dir Password'.\n"L];	      GOTO error};	    Transfer.RegisterConnCredentials[dir: dir, password: name];	    dir ¬ Exec.FreeTokenString[dir]};	  ENDCASE => {	    CWF.WF1["Error - unrecognized command %s.\n"L, name];  GOTO error};	name ¬ Exec.FreeTokenString[name];	[name, sw] ¬ Exec.GetToken[exec];	LOOP};      IF ~String.Empty[name] THEN {        dfName ¬ String.CopyToNewString[s: name, z: dfZone, longer: 3];        SModelInterface.StoreDF[	  dfFileName: dfName, opt: opt,	  dfZone: dfZone, window: NIL, abortProc: CheckAbortInExec];	String.FreeString[z: dfZone, s: dfName];  dfName ¬ NIL};      name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];      [name, sw] ¬ Exec.GetToken[exec];      ENDLOOP;    EXITS error => Subr.errorflg ¬ TRUE;    END;    IF Subr.errorflg THEN outcome ¬ error};      SetStoreSwitches: PROC [opt: POINTER TO SModelInterface.Options, sw: LONG STRING] = {    sense: BOOLEAN ¬ TRUE;    FOR i: CARDINAL IN [0..sw.length) DO      SELECT sw[i] FROM	'a, 'A => {opt.mustConfirm    ¬ ~sense;  sense ¬ TRUE}; 	'v, 'V => {opt.verify         ¬  sense;  sense ¬ TRUE};	'n, 'N => {opt.dontStoreFiles ¬  sense;  sense ¬ TRUE};	'l, 'L => {opt.checkLibrarian ¬  sense;  sense ¬ TRUE};	'z, 'Z => {opt.preRelease     ¬  sense;  sense ¬ TRUE};	'r, 'R => {opt.ignoreReadOnly ¬  sense;  sense ¬ TRUE};	't, 'T => {opt.topLevelOnly   ¬  sense;  sense ¬ TRUE};	'f, 'F => {opt.flipCameFrom   ¬  sense;  sense ¬ TRUE};	'd, 'D => {opt.debugging      ¬  sense;  sense ¬ TRUE};        'c, 'C => {opt.cmd	      ¬  sense;  sense ¬ TRUE};        'b, 'B => {opt.dfLibjectsOnly      ¬  sense;  sense ¬ TRUE};	'-, '~ => sense ¬ ~sense;	ENDCASE => {	  CWF.WF1["Unknown switch in '%s'\n"L, sw];  Subr.errorflg ¬ TRUE}      ENDLOOP};      ZonePages: CARDINAL = 350;    DoVerify: Exec.ExecProc = {    startTime, elapsedTime: Time.Packed;    exec: Exec.Handle ¬ h;    myEventHandle: Event.Handle ¬ NIL;          Cleanup: PROC = {      Transfer.Finalize[];  LeafSubr.StopLeaf[];      Subr.DeleteHugeZone[];  Subr.SubrStop[];      Event.DoneWithProcess[myEventHandle];  myEventHandle ¬ NIL;      VerifyDFInterface.DoneRunning[];      commandRunning ¬ FALSE};    BEGIN      ENABLE {	UNWIND => Cleanup[];        FileTransfer.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [60];	    FileTransfer.CodeToString[code, msg];	    CWF.WF1["\n...FileTransfer error: %s\n"L, msg];	    GOTO error};        ABORTED => {CWF.WF0["\n...VerifyDF aborted.\n"L];  GOTO abort};	Volume.InsufficientSpace => {	  CWF.WF0["\n...Volume full.\n"L];  GOTO error};	CWF.WFError => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    CWF.WF1["\nCWF error: %s.\n"L, err];	    GOTO error};	FileName.Error =>	  IF Subr.debugflg THEN REJECT	  ELSE {CWF.WF0["\n...FileName error.\n"L];  GOTO error};	MFile.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];	    CWF.WF1["MFile error: %s\n"L, msg];   	    GOTO error};        MStream.Error =>  	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMStreamErrorMessage[msg, code, stream];	    CWF.WF1["MStream error: %s.\n"L, msg];   	    GOTO error};	MSegment.Error =>   	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMSegmentErrorMessage[msg, code, segment];	    CWF.WF1["MSegment error: %s.\n"L, msg];   	    GOTO error}};	    IF NOT TestNoCommandRunning[h] THEN RETURN[abort];    IF VerifyDFInterface.AlreadyRunning[] THEN {       Exec.OutputProc[h][" VerifyDF already running!"L];      RETURN[abort]};    startTime ¬ Time.Current[];    Subr.SetUpCWFWriteProcedure[];  Subr.SubrInit[exec];    Subr.PrintGreeting["VerifyDF"L];    myEventHandle ¬ Event.StartingProcess["VerifyDF"L];    Transfer.Initialize[exec: exec, window: NIL];  -- use exec window for i/o    LeafSubr.StartLeaf[];    IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    outcome ¬ VerifyDFFiles[exec];    EXITS      error => {Subr.errorflg ¬ TRUE;  outcome ¬ error};      abort => outcome ¬ abort;    END;    elapsedTime ¬ [Time.Current[] - startTime];    CWF.WF1["\nTotal elapsed time for VerifyDF %lr.\n"L, @elapsedTime];    Cleanup[]};      VerifyDFFiles: PROC [exec: Exec.Handle] RETURNS [outcome: Exec.Outcome] = {    globalOpt, opt: VerifyDFInterface.Options ¬ VerifyDFInterface.DefaultOptions;    name, sw: LONG STRING ¬ NIL;    dfFileName: STRING ¬ [MFile.maxNameLength];        CheckAbortInExec: VerifyDFInterface.CheckAbortProc = {      RETURN[Exec.CheckForAbort[exec]]};    BEGIN    outcome ¬ normal;    [name, sw] ¬ Exec.GetToken[exec];    WHILE ~String.Empty[name] OR ~String.Empty[sw] DO      IF String.Empty[name] AND ~String.Empty[sw] THEN {  -- global switches        SetVerifySwitches[@globalOpt, sw];	name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];        [name, sw] ¬ Exec.GetToken[exec];	LOOP};      opt ¬ globalOpt;      IF ~String.Empty[sw] THEN SetVerifySwitches[@opt, sw];      IF ~String.Empty[name] THEN {        dfFileName.length ¬ 0;  String.AppendString[dfFileName, name];        Subr.debugflg ¬ opt.debugging;  Subr.errorflg ¬ FALSE;        [] ¬ Subr.HugeZone[nPages: ZonePages, zonePrefix: "VerifyDF"L	  ! MFile.Error =>	      IF code = noRoomOnVolume THEN {	        CWF.WF1[		  "Error - insufficient disk space to verify %s.\n"L, dfFileName];	        GOTO error}];        VerifyDFInterface.VerifyDFFile[          dfFileName: dfFileName, exec: exec, window: NIL,          opt: opt, abortProc: CheckAbortInExec           ! DFSubr.TooManyEntries => {              CWF.WF1["Error - too many entries in %s.\n"L, dfFileName];              Subr.errorflg ¬ TRUE;  CONTINUE};	    Heap.Error => {              CWF.WF1["Error - heap overflow while verifying %s.\n"L, dfFileName];              Subr.errorflg ¬ TRUE;  CONTINUE}];	Subr.DeleteHugeZone[];        IF Subr.errorflg THEN {	  CWF.WF1["There were errors in %s.\n"L, dfFileName];  outcome ¬ error}        ELSE CWF.WF1["No errors found in %s.\n"L, dfFileName]};      name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];      [name, sw] ¬ Exec.GetToken[exec];      ENDLOOP;    EXITS      error => Subr.errorflg ¬ TRUE;    END;    IF Subr.errorflg THEN outcome ¬ error};      SetVerifySwitches: PROC [      opt: POINTER TO VerifyDFInterface.Options, sw: LONG STRING] = {    sense: BOOLEAN ¬ TRUE;    FOR i: CARDINAL IN [0..sw.length) DO      SELECT sw[i] FROM        'f, 'F => {opt.printFlattened     ¬ sense;  sense ¬ TRUE};         'n, 'N => {opt.checkIfFilesNeeded ¬ sense;  sense ¬ TRUE};        't, 'T => {opt.retrieveDFsToTemp  ¬ sense;  sense ¬ TRUE};        'v, 'V => {opt.verbose		  ¬ sense;  sense ¬ TRUE};        'd, 'D => {opt.debugging          ¬ sense;  sense ¬ TRUE};	'-, '~ => sense ¬ ~sense;        ENDCASE => {	  CWF.WF1["Unknown switch in '%s'\n"L, sw];  Subr.errorflg ¬ TRUE}      ENDLOOP};        BringOverHelp: Exec.ExecProc = {    OutputProc: Format.StringProc _ Exec.OutputProc[h];    h.OutputProc[][ "BringOver[/<global switches>] DFfile1[/<local switches>]....DFfilen[/<local switches>] Global switches are optional and control the retrieval of subsequent DFs. You can also set global switches by giving an empty DF file name. BringOver's  \"only file\" mode (/o) has a slightly different format: files to be retrieved are listed after the global switch /o, and the DF file to be used is named last. BringOver also recognizes commands, localDir/c, localDFDir/c, workingDFLoc/c and integrationLoc/c:      Example: BringOver localDir/c <>Old> localDFDir/c <>Old>  [FS:]<Dir>DF.df. They override User.cm entries. A switch specification is a letter identifying the switch, optionally preceeded by a '-' or a '~' to reverse the sense of the switch. Switches recognized by BringOver are:   a=Always retrieve   b=get just Bcd (or other derived files)   f=Force retrieval, regardless of newer locals   o=Only specified files   p=Public (exported) only   r=Readonly (imported AND readonly)   s=Source only (inverse of /b)   u=Update existing local files (never get new files), v=Verify files exist in the right place and version and fill in DF dates (slow if DF is large)   w=Writable only (owned files that are in Exports or Directory clauses. Inverse of /r)   x=rename .bcd to .archivebcd if an archivebcd already exists   z=pre release mode   <=suppress confirmation request if an older remote vrsion is retrieved."L];  };  DeleteHelp: Exec.ExecProc = {    OutputProc: Format.StringProc _ Exec.OutputProc[h];    h.OutputProc[]["DFDelete[/<global switches>] DFfile1[/<local switches>]....DFfilen[/<local switches>] Global switches are optional and control the store of subsequent DFs. You can also set global switches by giving an empty DF file name. A switch specification is a letter identifying the switch, optionally preceeded by a '-' or a '~' to reverse the sense of the switch. Switches recognized by DFDelete are:   r=also delete imported and Readonly files."L];  };    StoreHelp: Exec.ExecProc = {    OutputProc: Format.StringProc _ Exec.OutputProc[h];    h.OutputProc[]["Smodel[/<global switches>] DFfile1[/<local switches>]....DFfilen[/<local switches>] Global switches are optional and control the store of subsequent DFs. You can also set global switches by giving an empty DF file name. Smodel also recognizes commands, workingDFLoc/c and integrationLoc/c. Seconday connect credentials can be given on the command line:  Smodel conn/c Dir Password  DFfile. A switch specification is a letter identifying the switch, optionally preceeded by a '-' or a '~' to reverse the sense of the switch. Switches recognized by Smodel are:   a=store Always   f=Flip came from (default)   l=check Librarian (default)   n=do Not store file remotely   r=ignore ReadOnly   t=process Top DF only   not included DFs   v=Verify files are really on the remote server and store if necessary   z=pre release mode"L];  };  VerifyHelp: Exec.ExecProc = {    OutputProc: Format.StringProc _ Exec.OutputProc[h];    h.OutputProc[][ "VerifyDF[/<global switches>] DFfile1[/<local switches>]....DFfilen[/<local switches>] Global switches are optional and control the retrieval of subsequent DFs. You can also set global switches by giving an empty DF file name. A switch specification is a letter identifying the switch, optionally preceeded by a '-' or a '~' to reverse the sense of the switch. Switches recognized by VerifyDF are:   f=print Flattened DF file (all Imports and Includes structure removed).   n=check that all files seem Necessary (default)   t=retrieve DF to Temporary files (default)."L];  };  Init: PROC =    BEGIN    Exec.AddCommand[      name: "BringOver.~"L, proc: DoBringOver, help: BringOverHelp,      unload: Unload];    Exec.AddCommand[      name: "DFDelete.~"L, proc: DoDelete, help: DeleteHelp, unload: Unload];    Exec.AddCommand[      name:  "SModel.~"L, proc: DoStore, help: StoreHelp, unload: Unload];    Exec.AddCommand[      name: "VerifyDF.~"L, proc: DoVerify, help: VerifyHelp, unload: Unload];    END;        Unload: Exec.ExecProc =      BEGIN      [] ¬ h.RemoveCommand["BringOver.~"L];      [] ¬ h.RemoveCommand["DFDelete.~"L];      [] ¬ h.RemoveCommand["SModel.~"L];      [] ¬ h.RemoveCommand["VerifyDF.~"L];      END;    Init[];  END...CHANGE LOG19-Dec-85 13:07:21	kam	Merged BringOverExecImpl, DFDeleteExecImpl, SModelExecImpl, VerifyDFExecImpl.
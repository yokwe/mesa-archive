-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- RStatsImpl.mesa - Last edited by--   Schmidt	September 15, 1982 9:27 am--   BTL  	15-Nov-83 10:56:22--   DSC  	10-Apr-84 10:39:52--   NSG        19-Jul-84 16:16:10 changed spare1 to accessDenied-- To compute statistics, run----    RStats /i Mesa10.0c.df---- then--    RStats /b			for the bcds--    RStats /d Mesa10.0c.df	for the DF files--    RStats /e			for the bcd dependency analysis--    RStats /r			for the source files (broken down by subdirectory)--    RStats /s			for the source files--    RStats /t			for totals on # and size of files---- alternatively--    RStats /a Mesa10.0c.df--	  which does a  "/i, /d, /b, /s, /t" in sequence (takes about 3 hours)DIRECTORY  BcdDefs USING [Base, MTIndex],  BcdOps USING [BcdBase, MTHandle],  CWF USING [SetWriteProcedure, SWF3, SWF4, WF0, WF1, WF2, WF3, WF4, WFCR],  DFSubr USING [StripLongName],  Event USING [DoneWithProcess, Handle, StartingProcess],  Exec USING [    AddCommand, CheckForAbort, ExecProc, FreeTokenString, GetToken,    Handle, OutputProc, PutChar],  FileTransfer USING [CodeToString, Error, ErrorCode, FileInfo, GetStreamInfo],  FQ USING [FileQuery, Result],  Inline USING [LowHalf],  LeafSubr USING [Close, FileHandle, GetStreamLength, RemoteMap, StopLeaf],  MFile USING [AppendErrorMessage, Error, GetProperties, Handle, maxNameLength],  MSegment USING [Address, Create, Delete, Error, GetFile, Handle],  MStream USING [Error, GetFile, Handle, ReadOnly, WriteOnly],  RStatsSupport USING [    BcdDep, BreakUp, ComputeFileList, DFDep, DFRec, DFRecRecord,    InitDFAnalysis, LeafOpenWithCreate, ProcessBcdAnalysis,    ProcessDFList, SubString],  Stream USING [Delete, EndOfStream, GetBlock, Handle, PutChar],  String USING [    AppendExtensionIfNeeded, AppendString, CopyToNewString, Empty,    Equivalent, FreeString],  Subr USING [    AllocateString, CopyString, debugflg, EndsIn, errorflg, FileError,    FreeString, GetLine, HugeZone, LongZone, PrintGreeting, StrCopy,    SubrInit, SubrStop],  Time USING [Current, Packed],  Transfer USING [EnumerateForRetrieve, Finalize, Initialize, RetrieveProcType],  Volume USING [InsufficientSpace];RStatsImpl: MONITOR    IMPORTS      CWF, DFSubr, Event, Exec, FileTransfer, FQ, Inline, LeafSubr,      MFile, MSegment, MStream, RStatsSupport, Stream, String, Subr,      Time, Transfer, Volume =  BEGIN  DFRec:  TYPE = RStatsSupport.DFRec;  DFDep:  TYPE = RStatsSupport.DFDep;  BcdDep: TYPE = RStatsSupport.BcdDep;    FileKind: TYPE = {mesa, config, bcd, df, other};  accessDenied: FileTransfer.ErrorCode = FileTransfer.ErrorCode[accessDenied];    exec: Exec.Handle ¬ NIL;  nowRunning: BOOLEAN ¬ FALSE;  dfZone: UNCOUNTED ZONE ¬ NIL;    bufferChars: CARDINAL = 3000;  buffer: LONG STRING ¬ NIL;  bufferPos, bufferEnd: CARDINAL ¬ 0;  lastCharInBuffer, eof: BOOLEAN ¬ FALSE;  Stats: TYPE = LONG POINTER TO StatArray;  StatArray: TYPE = ARRAY Stat OF LONG INTEGER;  Stat: TYPE = {    nBcd, nBcdDefn, nBcdConfig, nBcdImpl, nBcdCodeBytes, nBcdFileBytes, nSrc,    nSrcConfig, nSrcMesa, nSrcImpl, nSrcDefn, nSrcLines, nSrcBytes, nDF,    nOtherFiles, nOtherBytes, nTotalFiles, nTotalBytes};  -- check ResetCtrs[] before adding more global state  g: GlobalData ¬ NIL;  GlobalData: TYPE = LONG POINTER TO GlobalDataRecord;  GlobalDataRecord: TYPE = RECORD [    fileListName:     LONG STRING,	      -- e.g. ReleaseStats.files; readonly    xrefFileName:     LONG STRING,	      -- e.g. ReleaseStats.xref; readonly    stat:	      Stats ¬ NIL,    totalStat:	      Stats ¬ NIL,    dfrec:	      DFRec ¬ NIL,	      -- list of DF files    lastHost:	        LONG STRING ¬ NIL,    lastDirectory:      LONG STRING ¬ NIL,    lastShortname:      LONG STRING ¬ NIL,    lastTopDirectory:   LONG STRING ¬ NIL,    lastWholeDirectory: LONG STRING ¬ NIL,    sh:		      Stream.Handle ¬ NIL,    -- output log stream    bcdSeg:	      MSegment.Handle ¬ NIL,  -- one page remote map buffer    bcd:	      BcdOps.BcdBase ¬ NIL];  -- address of buffer  Choice: TYPE = {none, all, bcd, df, bcdAnalysis, init, src, detailSrc, total};    -- changing this may require changing RStatsSupportImpl.MaxFiles also  ZonePages: CARDINAL = 6500;  -- # pages in the overall write-once zone      RStats: Exec.ExecProc = {    choice: Choice ¬ none;    name, sw: LONG STRING ¬ NIL;    filename: LONG STRING ¬ NIL;    myEventHandle: Event.Handle ¬ NIL;    BEGIN      ENABLE {        UNWIND => Cleanup[filename, myEventHandle];        FileTransfer.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [60];	    FileTransfer.CodeToString[code, msg];	    CWF.WF1["FileTransfer error: %s\n"L, msg];	    Subr.errorflg ¬ TRUE;	    GOTO error};        ABORTED => {CWF.WF0["\n...RStats aborted.\n"L];  GOTO abort};        Volume.InsufficientSpace => {CWF.WF0["\nVolume full\n"L];  GOTO error};	MFile.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];	    CWF.WF1["MFile error: %s\n"L, msg];   	    GOTO error};        MStream.Error =>  	  IF Subr.debugflg THEN REJECT	  ELSE {	    name: LONG STRING ¬ [MFile.maxNameLength];            SELECT TRUE FROM	      (stream = NIL) => name ¬ "unknown"L;	      (code = invalidHandle) => name ¬ "unknown"L;	      ENDCASE => [] ¬ MFile.GetProperties[MStream.GetFile[stream], name];            CWF.WF1[	      "\n...Error accessing stream on file %s"L, 	      (IF name.length > 0 THEN name ELSE "unknown"L)];	    SELECT code FROM	      invalidHandle    => CWF.WF0[": invalidHandle\n"L];	      indexOutOfRange  => CWF.WF0[": indexOutOfRange\n"L];	      invalidOperation => CWF.WF0[": invalidOperation\n"L];	      fileTooLong      => CWF.WF0[": fileTooLong\n"L];	      fileNotAvailable => CWF.WF0[": fileNotAvailable\n"L];	      other            => CWF.WF0[": other\n"L];	      ENDCASE          => CWF.WF0[": (unknown MStream.Error)\n"L];	    GOTO error};	MSegment.Error =>   	  IF Subr.debugflg THEN REJECT	  ELSE {	    name: LONG STRING ¬ [MFile.maxNameLength];            SELECT TRUE FROM	      (segment = NIL) => name ¬ "unknown"L;	      (code = noSuchSegment) => name ¬ "unknown"L;	      ENDCASE => {	        file: MFile.Handle ¬ MSegment.GetFile[segment];		IF file = NIL THEN name ¬ "unknown"L		ELSE [] ¬ MFile.GetProperties[file, name]};	    CWF.WF1[	      "\n...Error accessing segment on file %s"L,	      (IF name.length > 0 THEN name ELSE "unknown"L)];	    SELECT code FROM	      zeroLength         => CWF.WF0[": zeroLength\n"L];	      insufficientVM     => CWF.WF0[": insufficientVM\n"L];	      noSuchSegment      => CWF.WF0[": noSuchSegment\n"L];	      sharedSegment      => CWF.WF0[": sharedSegment\n"L];	      baseOutOfRange     => CWF.WF0[": baseOutOfRange\n"L];	      conflictingAccess  => CWF.WF0[": conflictingAccess\n"L];	      illegalAccess      => CWF.WF0[": illegalAccess\n"L];	      other              => CWF.WF0[": other\n"L];              ENDCASE            => CWF.WF0[": (unknown MSegment.Error)\n"L];	   GOTO error}};	    IF AlreadyRunning[] THEN {       Exec.OutputProc[h][" RStats already running!"L];      RETURN[abort]};          outcome ¬ normal;    exec ¬ h;    Subr.SubrInit[exec: exec];    Subr.errorflg ¬ Subr.debugflg ¬ FALSE;    dfZone ¬ Subr.LongZone[];    g ¬ dfZone.NEW[GlobalDataRecord ¬ [      fileListName: "ReleaseStats.files", xrefFileName: "ReleaseStats.xref"]];    g.sh ¬ MStream.WriteOnly["RStats.Log"L, [], text      ! MStream.Error => {	  Exec.OutputProc[h]["\nUnable to open RStats.log.\n"L];	  dfZone.FREE[@g];  GOTO error}];    [] ¬ CWF.SetWriteProcedure[ExecLogProc];    g.stat ¬ dfZone.NEW[StatArray ¬ ALL[0]];    g.totalStat ¬ dfZone.NEW[StatArray ¬ ALL[0]];    g.lastHost ¬ Subr.AllocateString[nchars: 100, zone: dfZone];    g.lastDirectory ¬ Subr.AllocateString[nchars: 100, zone: dfZone];    g.lastShortname ¬ Subr.AllocateString[nchars: 150, zone: dfZone];    g.lastTopDirectory ¬ Subr.AllocateString[nchars: 150, zone: dfZone];    g.lastWholeDirectory ¬ Subr.AllocateString[nchars: 150, zone: dfZone];    g.bcdSeg ¬ MSegment.Create[file: NIL, release: [], pages: 1];    g.bcd ¬ MSegment.Address[g.bcdSeg];    [] ¬ Subr.HugeZone[nPages: ZonePages, zonePrefix: "RStats"L];    RStatsSupport.InitDFAnalysis[exec: exec, zone: dfZone];    Subr.PrintGreeting["RStats"L];    myEventHandle ¬ Event.StartingProcess["RStats"L];    Transfer.Initialize[exec: exec, window: NIL];  -- use exec window for I/O    [name, sw] ¬ Exec.GetToken[exec];    WHILE ~(String.Empty[name] AND String.Empty[sw]) DO      IF ~String.Empty[sw] THEN {         SELECT sw[0] FROM          'a, 'A => choice ¬ all;          'b, 'B => choice ¬ bcd;          'd, 'D => choice ¬ df;          'e, 'E => choice ¬ bcdAnalysis;          'i, 'I => choice ¬ init;          'r, 'R => choice ¬ detailSrc;          's, 'S => choice ¬ src;          't, 'T => choice ¬ total;          ENDCASE => NULL}      ELSE        IF ~String.Empty[name]	AND (choice = init OR choice = df OR choice = all) THEN {	  filename ¬ String.CopyToNewString[	    s: name, z: dfZone, longer: (".df"L).length];          [] ¬ String.AppendExtensionIfNeeded[	    to: @filename, extension: ".df"L, z: dfZone]};      name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];      [name, sw] ¬ Exec.GetToken[exec];      ENDLOOP;    IF choice = all THEN RunAll[filename]    ELSE RunOne[choice, filename];    Cleanup[filename, myEventHandle];    EXITS      error => outcome ¬ error;      abort => outcome ¬ abort;    END};    ExecLogProc: PROC [ch: CHARACTER] = {    Exec.PutChar[exec, ch];  Stream.PutChar[g.sh, ch]};      RunAll: PROC [filename: LONG STRING] = {    ChooseOne[init, filename];    ChooseOne[df, filename];    ChooseOne[src, filename];    ChooseOne[bcd, filename];    ChooseOne[total, filename]};  RunOne: PROC [choice: Choice, filename: LONG STRING] = {    ChooseOne[choice, filename]};  Cleanup: PROC [filename: LONG STRING, myEventHandle: Event.Handle] = {    s: Stats;    IF filename # NIL THEN {      String.FreeString[z: dfZone, s: filename];  filename ¬ NIL};    LeafSubr.StopLeaf[];  Transfer.Finalize[];     IF g.sh # NIL THEN {Stream.Delete[g.sh];  g.sh ¬ NIL};    IF g.bcdSeg # NIL THEN {      MSegment.Delete[g.bcdSeg];  g.bcdSeg ¬ NIL;  g.bcd ¬ NIL};    IF g.stat # NIL THEN {s ¬ g.stat;  dfZone.FREE[@s]};    IF g.totalStat # NIL THEN {s ¬ g.totalStat;  dfZone.FREE[@s]};    IF g.lastHost # NIL THEN {      Subr.FreeString[g.lastHost, dfZone];  g.lastHost ¬ NIL};    IF g.lastDirectory # NIL THEN {      Subr.FreeString[g.lastDirectory, dfZone];  g.lastDirectory ¬ NIL};    IF g.lastShortname # NIL THEN {      Subr.FreeString[g.lastShortname, dfZone];  g.lastShortname ¬ NIL};    IF g.lastTopDirectory # NIL THEN {      Subr.FreeString[g.lastTopDirectory, dfZone];  g.lastTopDirectory ¬ NIL};    IF g.lastWholeDirectory # NIL THEN {      Subr.FreeString[g.lastWholeDirectory, dfZone];  g.lastWholeDirectory ¬ NIL};    IF g # NIL THEN dfZone.FREE[@g];    ReleaseBuffer[];    Subr.SubrStop[];    IF myEventHandle # NIL THEN {      Event.DoneWithProcess[myEventHandle];  myEventHandle ¬ NIL};    DoneRunning[]};        AlreadyRunning: ENTRY PROC RETURNS [yes: BOOLEAN] = {    IF nowRunning THEN RETURN[TRUE];    nowRunning ¬ TRUE;    RETURN[FALSE]};    DoneRunning: ENTRY PROC = {nowRunning ¬ FALSE};        ChooseOne: PROC [choice: Choice, filename: LONG STRING] = {    timeStarted: Time.Packed ¬ Time.Current[];    CloseDown: PROC = {      elapsedTime: Time.Packed;      PrintStat[g.stat, choice];      PrintStat[g.totalStat, choice];      ResetCtrs[];      elapsedTime ¬ [Time.Current[] - timeStarted];      CWF.WF1["Total elapsed time for RStats: %lr.\n\n", @elapsedTime];      CWF.WF0["----------------------------------------------------------\n\n"L]};    BEGIN ENABLE UNWIND => CloseDown[];    ResetCtrs[];    IF choice = init THEN      RStatsSupport.ComputeFileList[        dfFileName: filename, fileListName: g.fileListName,	window: NIL, exec: exec]    ELSE AnalyzeAll[choice, filename];    CloseDown[];    END};  AnalyzeAll: PROC [choice: Choice, fileName: LONG STRING] = {    sh: Stream.Handle ¬ NIL;    line: STRING ¬ [200];    sfn: LONG STRING ¬ [150];    version: CARDINAL;    createtime: Time.Packed;    host: STRING ¬ [100];    directory: STRING ¬ [100];    shortname: STRING ¬ [150];    kind: FileKind;    BEGIN      ENABLE UNWIND => {        ReleaseBuffer[];        IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL}};    IF choice = src OR choice = detailSrc THEN AcquireBuffer[];    CWF.WF1["Reading list of files from %s\n"L, g.fileListName];    sh ¬ MStream.ReadOnly[name: g.fileListName, release: []      ! MStream.Error => {          CWF.WF1["Unable to open %s for reading.\n"L, g.fileListName];	  GOTO noInput}];    WHILE Subr.GetLine[sh, line] DO      IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;      createtime ¬ RStatsSupport.BreakUp[line, sfn];      version ¬ DFSubr.StripLongName[sfn, host, directory, shortname];      kind ¬ GetFileKind[shortname];      SELECT TRUE FROM        (choice = src) AND (kind = mesa OR kind = config) => {          IF SkipFile[host, directory, shortname] THEN LOOP;          CheckForTopDirSwitch[directory, choice];          AnalyzeSrc[host, directory, shortname, version, createtime]};        (choice = detailSrc) AND (kind = mesa OR kind = config) => {          IF SkipFile[host, directory, shortname] THEN LOOP;          CheckForWholeDirSwitch[directory, choice];          AnalyzeSrc[host, directory, shortname, version, createtime]};        (choice = bcd AND kind = bcd) => {          IF SkipFile[host, directory, shortname] THEN LOOP;          CheckForTopDirSwitch[directory, choice];          AnalyzeBcd[host, directory, shortname, version, createtime]};        (choice = df OR choice = bcdAnalysis) AND kind = df => {	  new: DFRec ¬ dfZone.NEW[RStatsSupport.DFRecRecord ¬ [	    rest:      g.dfrec,	    host:      Subr.CopyString[host, dfZone],            directory: Subr.CopyString[directory, dfZone],            shortname: Subr.CopyString[shortname, dfZone],	    version:   version,            dep:       NIL,	    refBy:     NIL,	    bcdDep:    NIL]];          g.dfrec ¬ new};        (choice = total) => {          IF SkipFile[host, directory, shortname] THEN LOOP;          CheckForTopDirSwitch[directory, choice];          AnalyzeTotals[sfn, host, directory, shortname, version, createtime]};	ENDCASE;      ENDLOOP;    Stream.Delete[sh];  sh ¬ NIL;    IF choice = df THEN      g.stat[nDF] ¬ RStatsSupport.ProcessDFList[        topDFName: fileName, dfrec: g.dfrec, xrefFileName: g.xrefFileName];    IF choice = bcdAnalysis THEN      RStatsSupport.ProcessBcdAnalysis[dfrec: g.dfrec];    EXITS      noInput => NULL;    END;    ReleaseBuffer[]};      GetFileKind: PROC [shortname: LONG STRING] RETURNS [kind: FileKind] = {    kind ¬ other;    IF Subr.EndsIn[shortname, ".bcd"L] THEN kind ¬ bcd    ELSE IF Subr.EndsIn[shortname, ".mesa"L] THEN kind ¬ mesa    ELSE IF Subr.EndsIn[shortname, ".config"L] THEN kind ¬ config    ELSE IF Subr.EndsIn[shortname, ".df"L] THEN kind ¬ df};  SkipFile: PROC [      host, directory, shortname: LONG STRING] RETURNS [skipIt: BOOLEAN] = {    IF g.lastHost = NIL THEN skipIt ¬ FALSE    ELSE skipIt ¬ (      String.Equivalent[g.lastShortname, shortname]      AND String.Equivalent[g.lastDirectory, directory]      AND String.Equivalent[g.lastHost, host]);    IF ~skipIt THEN {      g.lastShortname.length ¬ 0;      String.AppendString[g.lastShortname, shortname];      IF ~String.Equivalent[g.lastDirectory, directory] THEN {        g.lastDirectory.length ¬ 0;        String.AppendString[g.lastDirectory, directory]};      IF ~String.Equivalent[g.lastHost, host] THEN {        g.lastHost.length ¬ 0;        String.AppendString[g.lastHost, host]}} };  CheckForWholeDirSwitch: PROC [directory: LONG STRING, choice: Choice] = {    IF ~String.Equivalent[g.lastWholeDirectory, directory] THEN {      IF g.lastWholeDirectory # NIL THEN PrintStat[g.stat, choice];      g.lastWholeDirectory.length ¬ 0;      String.AppendString[g.lastWholeDirectory, directory]}};  CheckForTopDirSwitch: PROC [directory: LONG STRING, choice: Choice] = {    top: STRING ¬ [100];    len: CARDINAL ¬ directory.length;    FOR i: CARDINAL IN [0..len) DO      IF directory[i] = '> THEN {len ¬ i;  EXIT};      ENDLOOP;    Subr.StrCopy[top, directory];    top.length ¬ len;    IF ~String.Equivalent[g.lastTopDirectory, top] THEN {      IF ~String.Empty[g.lastTopDirectory] THEN PrintStat[g.stat, choice];      g.lastTopDirectory.length ¬ 0;      String.AppendString[g.lastTopDirectory, top]}};  AnalyzeTotals: PROC [      filename, host, directory, shortname: LONG STRING, version: CARDINAL,      createtime: Time.Packed] = {    fres: FQ.Result;    targetFileName: STRING ¬ [125];    vnum: CARDINAL;    byteLength: LONG CARDINAL;    CWF.WF3["[%s]<%s>%s."L, host, directory, shortname];    [fres: fres, remoteVersion: vnum, remoteByteLength: byteLength] ¬      FQ.FileQuery[        host: host, directory: directory, shortname: shortname,	version: version, createtime: createtime, wantExplicitVersion: FALSE,	targetFileName: targetFileName];    SELECT fres FROM      foundCorrectVersion => {        IF Subr.EndsIn[shortname, ".mesa"L]	OR Subr.EndsIn[shortname, ".config"L] THEN {          g.stat[nSrc] ¬ g.stat[nSrc] + 1;          g.stat[nSrcBytes] ¬ g.stat[nSrcBytes] + byteLength}        ELSE IF Subr.EndsIn[shortname, ".bcd"L] THEN {          g.stat[nBcd] ¬ g.stat[nBcd] + 1;          g.stat[nBcdFileBytes] ¬ g.stat[nBcdFileBytes] + byteLength}        ELSE {          g.stat[nOtherFiles] ¬ g.stat[nOtherFiles] + 1;          g.stat[nOtherBytes] ¬ g.stat[nOtherBytes] + byteLength};        g.stat[nTotalFiles] ¬ g.stat[nTotalFiles] + 1;        g.stat[nTotalBytes] ¬ g.stat[nTotalBytes] + byteLength};      foundWrongVersion, notFound =>        CWF.WF3["  Error - cannot open [%s]<%s>%s."L, host, directory, shortname];      ENDCASE;    CWF.WFCR[]}; -- Source procedures    AcquireBuffer: PROC = {    buffer ¬ Subr.AllocateString[bufferChars, dfZone];    bufferPos ¬ bufferEnd ¬ 0;    lastCharInBuffer ¬ eof ¬ FALSE};      ReleaseBuffer: PROC = {    IF buffer # NIL THEN Subr.FreeString[buffer, dfZone];    buffer ¬ NIL};        InitReading: PROC = {  -- init reading for a new stream    bufferPos ¬ bufferEnd ¬ 0;    lastCharInBuffer ¬ eof ¬ FALSE};      FillBuffer: PROC [sh: Stream.Handle] = {    IF eof THEN RETURN;    IF lastCharInBuffer THEN eof ¬ TRUE    ELSE {      lastCharInBuffer ¬ FALSE;      bufferEnd ¬ buffer.maxlength;  -- one beyond last char in buffer      bufferPos ¬ 0;      sh.options.signalEndOfStream ¬ TRUE;      [] ¬ Stream.GetBlock[sh, [LOOPHOLE[@buffer.text], 0, buffer.maxlength]	! Stream.EndOfStream => {	    lastCharInBuffer ¬ TRUE;	    bufferEnd ¬ Inline.LowHalf[nextIndex];	    IF nextIndex <= 1 THEN eof ¬ TRUE;	    CONTINUE}];      buffer.length ¬ bufferEnd}};      ReadLine: PROC [      sh: Stream.Handle, line: LONG STRING] RETURNS [notEof: BOOLEAN] = {    i: CARDINAL ¬ 0;    ch: CHARACTER;    line.length ¬ 0;    IF eof THEN RETURN[notEof: FALSE];    WHILE i < line.maxlength DO      IF bufferPos >= bufferEnd THEN FillBuffer[sh];      IF eof THEN {  -- insert CR before last \0        line[i] ¬ '\n;  i ¬ i + 1;  line[i] ¬ 0C;  EXIT}      ELSE {        ch ¬ buffer[bufferPos];  bufferPos ¬ bufferPos+1;	 line[i] ¬ ch;	 IF ch = '\n THEN EXIT;	 i ¬ i + 1};      ENDLOOP;    line.length ¬ i;  -- i.e. \0 or \n is after end of string    IF line.length >= line.maxlength THEN {      line.length ¬ line.maxlength;      CWF.WF1["ReadLine - line '%s' is too long.\n"L, line]};    RETURN[notEof: ~eof]};  AnalyzeSrc: PROC [      host, directory, shortname: LONG STRING,      version: CARDINAL, createtime: Time.Packed] = {    fres: FQ.Result;    targetFileName: STRING ¬ [150];    line: STRING ¬ [500];    OneFile: Transfer.RetrieveProcType = {  -- only called once      info: FileTransfer.FileInfo ¬ FileTransfer.GetStreamInfo[s];      nImpl, nDefs: LONG INTEGER ¬ 0;      nLines: LONG INTEGER ¬ 0;      checkForType: BOOLEAN ¬ TRUE;      IF Subr.EndsIn[shortname, ".config"L] THEN        g.stat[nSrcConfig] ¬ g.stat[nSrcConfig] + 1      ELSE g.stat[nSrcMesa] ¬ g.stat[nSrcMesa] + 1;      CWF.WF1["%s "L, targetFileName];      InitReading[];      WHILE ReadLine[s, line] DO        nLines ¬ nLines + 1;        IF checkForType THEN {          IF RStatsSupport.SubString[line, "PROGRAM"L] THEN {            nImpl ¬ nImpl + 1;  checkForType ¬ FALSE};          IF RStatsSupport.SubString[line, "DEFINITIONS"L] THEN {            nDefs ¬ nDefs + 1;  checkForType ¬ FALSE};          IF RStatsSupport.SubString[line, "MONITOR"L] THEN {            nImpl ¬ nImpl + 1;  checkForType ¬ FALSE}};        ENDLOOP;      g.stat[nSrc] ¬ g.stat[nSrc] + 1;      g.stat[nSrcBytes] ¬ g.stat[nSrcBytes] + info.size;      IF nImpl > 0 AND nDefs > 0 THEN        CWF.WF0["- Warning - counted twice as impl and defs.\n"L];      IF nImpl > 0 THEN g.stat[nSrcImpl] ¬ g.stat[nSrcImpl] + 1;      IF nDefs > 0 THEN g.stat[nSrcDefn] ¬ g.stat[nSrcDefn] + 1;      g.stat[nSrcLines] ¬ g.stat[nSrcLines] + nLines;      CWF.WFCR[]};    [fres: fres, remoteVersion: version] ¬ FQ.FileQuery[      host: host, directory: directory, shortname: shortname,      version: version, createtime: createtime, wantExplicitVersion: FALSE,      targetFileName: targetFileName];    SELECT fres FROM      foundCorrectVersion =>         Transfer.EnumerateForRetrieve[targetFileName, OneFile	  ! FileTransfer.Error =>	      SELECT code FROM	        retry => {	          CWF.WF1["\nConnection to %s timed out...retrying..."L, host];		  RETRY};		accessDenied => {		  CWF.WF3[		    "Error - Insufficient credentials to retrieve [%s]<%s>%s.\n"L,		    host, directory, shortname];		  GOTO cantRead};	        ENDCASE => REJECT];      foundWrongVersion, notFound =>        CWF.WF1["%s not found.\n"L, targetFileName];      ENDCASE;    EXITS cantRead => Subr.errorflg ¬ TRUE};       -- BCD procedures  AnalyzeBcd: PROC [      host, directory, shortname: LONG STRING,      version: CARDINAL, createtime: Time.Packed] = {    BEGIN    sfn: STRING ¬ [150];    fh: LeafSubr.FileHandle ¬ NIL;    bcd: BcdOps.BcdBase = g.bcd;    mth: BcdOps.MTHandle ¬ NIL;    g.stat[nBcd] ¬ g.stat[nBcd] + 1;    IF version > 0 THEN       CWF.SWF4[sfn, "[%s]<%s>%s!%d"L, host, directory, shortname, @version]    ELSE      CWF.SWF3[sfn, "[%s]<%s>%s"L, host, directory, shortname];    CWF.WF1["%s ", sfn];    fh ¬ RStatsSupport.LeafOpenWithCreate[      host, directory, shortname, version, createtime       ! Subr.FileError => {          CWF.WF1["Error - cannot open %s\n"L, sfn];  GOTO leave}];    IF fh = NIL THEN GOTO leave;    LeafSubr.RemoteMap[seg: g.bcdSeg, fh: fh, base: 0];  -- first page    IF bcd.definitions THEN g.stat[nBcdDefn] ¬ g.stat[nBcdDefn] + 1    ELSE IF bcd.nConfigs > 0 THEN g.stat[nBcdConfig] ¬ g.stat[nBcdConfig] + 1    ELSE {      mth ¬ @LOOPHOLE[bcd + bcd.mtOffset, BcdDefs.Base][FIRST[BcdDefs.MTIndex]];      g.stat[nBcdCodeBytes] ¬ g.stat[nBcdCodeBytes] + mth.code.length;      g.stat[nBcdImpl] ¬ g.stat[nBcdImpl] + 1};    g.stat[nBcdFileBytes] ¬ g.stat[nBcdFileBytes] + LeafSubr.GetStreamLength[fh];    LeafSubr.Close[fh];    EXITS leave => NULL;    END;    CWF.WFCR[]};  -- Support procedures  PrintStat: PROC [st: Stats, choice: Choice] = {    SELECT choice FROM      bcd => {        CWF.WF4[          "\nBcds: %ld files, %ld defs, %ld impls, %ld configs,\n\t"L,	  @st[nBcd], @st[nBcdDefn], @st[nBcdImpl], @st[nBcdConfig]];        CWF.WF2[          "%ld code bytes, %ld file bytes.\n\n"L,	  @st[nBcdCodeBytes], @st[nBcdFileBytes]]};      df => {        CWF.WF1["\nDF files: %ld.\n\n"L, @st[nDF]]};      src, detailSrc => {        CWF.WF1["\nSources: %ld files, "L, @st[nSrc]];        CWF.WF4[          "%ld mesas, %ld defs, %ld impls, %ld configs,\n\t"L,	  @st[nSrcMesa], @st[nSrcDefn], @st[nSrcImpl], @st[nSrcConfig]];        CWF.WF2[	  "%ld lines, %ld file bytes.\n\n"L, @st[nSrcLines], @st[nSrcBytes]]};      total => {        CWF.WF4[          "\nTotal: %ld files, %ld total bytes, %ld bcd files, %ld bcd file bytes,\n\t"L,          @st[nTotalFiles], @st[nTotalBytes], @st[nBcd], @st[nBcdFileBytes]];        CWF.WF4[          "%ld src files, %ld src file bytes, %ld other files, %ld other bytes.\n\n"L,          @st[nSrc], @st[nSrcBytes], @st[nOtherFiles], @st[nOtherBytes]]};      init, bcdAnalysis => NULL;      ENDCASE;    FOR s: Stat IN Stat DO      g.totalStat[s] ¬ g.totalStat[s] + g.stat[s];      g.stat[s] ¬ 0;      ENDLOOP};  ResetCtrs: PROC = {    rest: DFRec;    FOR s: Stat IN Stat DO g.totalStat[s] ¬ g.stat[s] ¬ 0 ENDLOOP;    FOR df: DFRec ¬ g.dfrec, rest UNTIL df = NIL DO      rest ¬ df.rest;      ReleaseDFRec[df];      ENDLOOP;    g.dfrec ¬ NIL;    g.lastHost.length ¬ g.lastDirectory.length ¬ g.lastShortname.length ¬ 0;    g.lastTopDirectory.length ¬ g.lastWholeDirectory.length ¬ 0};      ReleaseDFRec: PROC [df: DFRec] = {    dep, rest: DFDep ¬ NIL;    bcdDep, nextBcdDep: BcdDep ¬ NIL;    -- release df's strings    Subr.FreeString[df.host, dfZone];  df.host ¬ NIL;    Subr.FreeString[df.directory, dfZone];  df.directory ¬ NIL;    Subr.FreeString[df.shortname, dfZone];  df.shortname ¬ NIL;    -- release list of DF files that df depends on    FOR dep ¬ df.dep, rest UNTIL dep = NIL DO      rest ¬ dep.rest;      Subr.FreeString[dep.directory, dfZone];  dep.directory ¬ NIL;      Subr.FreeString[dep.shortname, dfZone];  dep.shortname ¬ NIL;      dfZone.FREE[@dep];      ENDLOOP;    df.dep ¬ NIL;    -- release list of DF files that depends on df    FOR dep ¬ df.refBy, rest UNTIL dep = NIL DO      rest ¬ dep.rest;      Subr.FreeString[dep.directory, dfZone];  dep.directory ¬ NIL;      Subr.FreeString[dep.shortname, dfZone];  dep.shortname ¬ NIL;      dfZone.FREE[@dep];      ENDLOOP;    df.refBy ¬ NIL;    -- release list of bcds that bcds in df depend on    FOR bcdDep ¬ df.bcdDep, nextBcdDep UNTIL bcdDep = NIL DO      nextBcdDep ¬ bcdDep.rest;      Subr.FreeString[bcdDep.bcdName, dfZone];  bcdDep.bcdName ¬ NIL;      dfZone.FREE[@bcdDep];      ENDLOOP;    df.bcdDep ¬ NIL;    dfZone.FREE[@df]};      Init: PROC = {Exec.AddCommand["RStats.~"L, RStats]};      Init[];  END.Change log10-Apr-84 10:39:52	dsc	to change ZonePages to 5000. This is the upper limit. Beyond that, the program will thrash badly. 3-Sep-85 15:41:13	dsc	to change ZonePages to 6500. Since services croaked when they were 99% done...Cross my fingers!.
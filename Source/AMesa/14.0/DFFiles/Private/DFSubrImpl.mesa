-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- DFSubrImpl.mesa - Last edited by--   Schmidt	 9-Mar-82 14:53:12--   BTL  	18-Nov-83 14:24:54DIRECTORY  Ascii USING [CR],  CWF USING [    FWF0, FWF1, FWF2, FWF3, FWFCR, SetWriteProcedure, SWF2, WF0, WF1, WF2,    WF3, WF4, WFC],  DFSubr USING [    Criterion, DF, DFFileRecord, DFSeq, DFSeqRecord, EXSeq,     InterestingNestedDFProcType, ParseStream, TooManyParseErrors,    UsingSeq, UsingSeqRecord, ZoneType],  DFUser USING [EnumerateProcType, SortOption],  Environment USING [wordsPerPage],  Exec USING [CheckForAbort, Handle, PutChar],  GSort USING [CompareProcType, GetProcType, PutProcType, Sort],  Heap USING [Create, Delete, Error],  Inline USING [LowHalf],  MFile USING [Acquire, Error, maxNameLength, Release, ReadOnly],  MSegment USING [Address, AddresstoSegment, Create, Delete, Handle],  MStream USING [Handle],  Put USING [Char],  QuickSort,  Stream USING [Delete, Handle, PutChar],  String USING [    AppendChar, Compare, CompareStrings,     Equivalent, EquivalentString, StringToDecimal],  Subr USING [    AllocateString, CopyString, debugflg, EndsIn, errorflg, FileError,    FreeString, HugeZone, LongZone, Prefix, StrCopy, SubStrCopy,    WordsFromHugeZone],  Transfer USING [CachedOpen],  UserInput USING [UserAbort],  Window USING [Handle];DFSubrImpl: PROGRAM    IMPORTS      CWF, DFSubr, Exec, GSort, Heap, Inline, MFile, MSegment, Put, Stream,      QuickSort, String, Subr, Transfer, UserInput    EXPORTS DFSubr, DFUser =  BEGIN  TooManyEntries: PUBLIC ERROR = CODE;    RecursiveLoop: ERROR [errorDFFile: LONG STRING] = CODE;  CheckThisFile: SIGNAL [candidateDF: LONG STRING] = CODE;  FlattenDF: PUBLIC PROC [      dfseq: DFSubr.DFSeq, dffilename: LONG STRING,      exec: Exec.Handle, window: Window.Handle,      defaultUserName, defaultUserPassword: LONG STRING,      checkForOverwrite, allowForceReadOnly: BOOLEAN ¬ TRUE,      setRecorder, printStatus, skipCameFrom: BOOLEAN ¬ FALSE,      retrieveDFsToTemp: BOOLEAN ¬ FALSE,      localDFDir: LONG STRING ¬ NIL,      exList: DFSubr.EXSeq ¬ NIL] = { -- don't parse Imports from a exList dir    ENABLE {      CheckThisFile => RESUME;      RecursiveLoop => {        CWF.WF1["Error - you have an infinite dependency chain in your DF files.  One of the DF files involved is %s.\n"L, errorDFFile];        ERROR ABORTED}};    host: LONG STRING ¬ NIL;    directory: LONG STRING ¬ NIL;    shortname: LONG STRING ¬ NIL;    vers: CARDINAL;    sh: Stream.Handle ¬ NIL;    newstart: CARDINAL ¬ dfseq.size;    CleanUpOuter: PROC = {      IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL};      IF host # NIL THEN {Subr.FreeString[host, dfseq.dfzone];  host ¬ NIL};      IF directory # NIL THEN {        Subr.FreeString[directory, dfseq.dfzone];  directory ¬ NIL};      IF shortname # NIL THEN {        Subr.FreeString[shortname, dfseq.dfzone];  shortname ¬ NIL}};    InterestingNestedDF: DFSubr.InterestingNestedDFProcType = {      dfIndex: CARDINAL ¬ GetDFIndex[dfseq, dfEntry];      newUsing: DFSubr.UsingSeq ¬ NIL;      sh: Stream.Handle ¬ NIL;      newstart: CARDINAL;      CleanUpNested: PROC = {IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL}};      BEGIN ENABLE UNWIND => CleanUpNested[];      IF window # NIL THEN {IF UserInput.UserAbort[window] THEN ERROR ABORTED}      ELSE IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;      -- using list processing      IF driverUsingSeq # NIL AND innerUsingSeq # NIL THEN {  -- must intersect        newUsing ¬ IntersectUsing[driverUsingSeq, innerUsingSeq];        IF newUsing = NIL THEN RETURN} -- no intersection      ELSE IF innerUsingSeq # NIL THEN {  -- driverUsingSeq = NIL        -- this is an imported DF file with a using list        newUsing ¬ CopyUsing[innerUsingSeq];        -- allows top DF file to be treated with a Using but w/o PublicOnly        publicOnly ¬ FALSE}      ELSE IF driverUsingSeq # NIL THEN {        IF UsingEmpty[driverUsingSeq] THEN RETURN;        newUsing ¬ driverUsingSeq};      SIGNAL CheckThisFile[shortname];      -- If DF file was already released (a CameFrom),      --  then ignore it if skipCameFrom (normally TRUE).       IF dfEntry # NIL AND skipCameFrom AND dfEntry.cameFrom THEN RETURN;      -- Imports only, without using lists      IF dfEntry # NIL AND dfEntry.readonly AND dfEntry.publicOnly        AND AlreadyAnalyzed[          dfseq: dfseq, dftop: dfEntry, dfIndex: dfIndex,	  printStatus:	   printStatus,          ancestor:	   (IF ancestor = NIL THEN ""L ELSE ancestor),	  immediateParent: immediateParent,	  importsWUsing:   (dfEntry.using # NIL),	  exList: exList] THEN RETURN;      IF dfseq.size >= dfseq.maxsize THEN ERROR TooManyEntries;      IF printStatus THEN PrintStatus[	dfIndex, nLevel, host, directory, shortname, immediateParent, ancestor];      sh ¬ Transfer.CachedOpen[        host: host, directory: directory, name: shortname,        wantCreateTime: createtime,        wantExplicitVersion: createtime = 0 AND version > 0 AND criterion = none,	version: version,	checkForOverwrite: checkForOverwrite, window: window,	retrieveToTemp: retrieveDFsToTemp, localDir: localDFDir        ! Subr.FileError => {            IF host # NIL THEN              CWF.WF3[	        "Error - can't open [%s]<%s>%s"L, host, directory, shortname]            ELSE CWF.WF1["Error - can't open %s"L, shortname];            IF error = wrongVersion THEN CWF.WF1[" of %lt"L, @createtime];            CWF.WF0[".\n"L];            GOTO leave}];      IF sh = NIL THEN {        CWF.WF1["Warning - cannot read contents of %s.\n"L, shortname];	RETURN};      -- allowForceReadOnly: if DF file is in ReadOnly directory, then      -- all its contents will be ReadOnly      -- also, only read in Public stuff if entry was {PublicOnly}      newstart ¬ dfseq.size;      DFSubr.ParseStream[        sh: sh, dfseq: dfseq, dffilename: shortname, using: newUsing,        noremoteerrors: FALSE,        forceReadonly: (entryIsReadonly AND allowForceReadOnly),        omitNonPublic: publicOnly,	interestingNestedDF: InterestingNestedDF,        nLevel: (nLevel + 1),        ancestor: (IF ancestor = NIL THEN shortname ELSE ancestor),	limitErrors: TRUE         ! CheckThisFile =>            IF String.EquivalentString[shortname, candidateDF] THEN              ERROR RecursiveLoop[candidateDF];	  DFSubr.TooManyParseErrors => {	    CWF.WF1[" - parse abandoned, too many errors in %s.\n"L, shortname];	    GOTO leave}];      Stream.Delete[sh];  sh ¬ NIL;      IF setRecorder THEN        AssignRecorder[          dfseq, newstart, shortname,          IF dfEntry = NIL THEN FALSE	  ELSE dfEntry.cameFrom OR dfEntry.parentCameFrom];      IF dfEntry # NIL AND newUsing = NIL THEN {        dfEntry.exportsAnalyzed ¬ TRUE;        -- if Include without public only and without using list        -- then entire contents are already analyzed        IF ~publicOnly AND ~entryIsReadonly THEN          dfEntry.includeAnalyzed ¬ TRUE};      IF newUsing # NIL AND innerUsingSeq # NIL THEN {        CheckForMissingImports[newUsing, shortname];        FreeUsingSeq[newUsing]};      EXITS leave => NULL;      END;      CleanUpNested[]};    BEGIN ENABLE UNWIND => CleanUpOuter[];    IF ~Subr.EndsIn[dffilename, ".df"L] THEN {      CWF.WF1["Error - %s must be a DF file name.\n"L, dffilename];      GOTO leaveOuter};    host ¬ Subr.AllocateString[nchars: 60, zone: dfseq.dfzone];    directory ¬ Subr.AllocateString[nchars: 100, zone: dfseq.dfzone];    shortname ¬ Subr.AllocateString[      nchars: MFile.maxNameLength, zone: dfseq.dfzone];    vers ¬ StripLongName[dffilename, host, directory, shortname, FALSE];    sh ¬ Transfer.CachedOpen[      host: host, directory: directory, name: shortname,      wantCreateTime: [0],      wantExplicitVersion: TRUE, version: vers,      checkForOverwrite: checkForOverwrite, window: window,      retrieveToTemp: retrieveDFsToTemp, localDir: localDFDir       ! Subr.FileError => {          SELECT error FROM	    notFound => CWF.WF1["Error - can't open %s.\n"L, dffilename];	    wrongVersion =>	      CWF.WF1[	        "Error - could not find correct version of %s.\n"L, dffilename];	    accessConflict =>	      CWF.WF1["Error - access conflict in retrieving %s.\n"L, dffilename];	    ENDCASE;	  GOTO leaveOuter}];    IF sh = NIL THEN {      CWF.WF1["Warning - cannot read contents of %s.\n"L, shortname];      GOTO leaveOuter};    DFSubr.ParseStream[      sh: sh, dfseq: dfseq, dffilename: dffilename, using: NIL,      noremoteerrors: TRUE, forceReadonly: FALSE, omitNonPublic: FALSE,      interestingNestedDF: InterestingNestedDF, ancestor: NIL, nLevel: 0         ! CheckThisFile =>            IF String.EquivalentString[shortname, candidateDF] THEN              ERROR RecursiveLoop[candidateDF];	  DFSubr.TooManyParseErrors => {	    CWF.WF1[" - parse abandoned, too many errors in %s.\n"L, dffilename];	    GOTO leaveOuter}];    IF setRecorder THEN AssignRecorder[dfseq, newstart, shortname, FALSE];    EXITS leaveOuter => NULL;    END;    CleanUpOuter[]};      CheckForMissingImports: PROC [using: DFSubr.UsingSeq, dfName: LONG STRING] = {    IF ~UsingEmpty[using] THEN {      CWF.WF0["Error - cannot find "L];      FOR i: CARDINAL IN [0..using.size) DO        IF using[i] # NIL THEN CWF.WF1["%s "L, using[i]];	ENDLOOP;      CWF.WF1["in any DF file nested in %s.\n"L, dfName];      Subr.errorflg ¬ TRUE}};        PrintStatus: PROC [      dfIndex, nLevel: CARDINAL,      host, directory, shortname, immediateParent, ancestor: LONG STRING] = {    CWF.WF2["(#%u,L%u) "L, @dfIndex, @nLevel];    CWF.WF3["Parsing [%s]<%s>%s, "L, host, directory, shortname];    CWF.WF2[      "ref by (%s,%s).\n"L,      immediateParent, (IF ancestor = NIL THEN ""L ELSE ancestor)]};       -- df.exportsAnalyzed means that the DF file was Imported without a Using list,   --	and all the Exports in the DF file have been analyzed already  -- df.includeAnalyzed means that the DF file was Included (w/o Using List),   --    and all the entries in the Df file have been analyzed already  -- importsWUsing must be FALSE in order to match with exportsAnalyzed  -- if importsWUsing is TRUE, then includeAnalyzed must be TRUE for success (stronger condition)  AlreadyAnalyzed: PROC [        dfseq: DFSubr.DFSeq, dftop: DFSubr.DF, dfIndex: CARDINAL,	printStatus: BOOLEAN, ancestor, immediateParent: LONG STRING,	importsWUsing: BOOLEAN,	exList: DFSubr.EXSeq]  -- skip if Import from a exList directory      RETURNS [already: BOOLEAN] = {    df: DFSubr.DF;    IF exList # NIL THEN {      ex: BOOLEAN ¬ FALSE;      FOR i: CARDINAL IN [0..exList.size) DO        IF Subr.Prefix[dftop.directory, exList[i].directory]          AND String.Equivalent[dftop.host, exList[i].host]          AND            (dftop.directory.length = exList[i].directory.length              OR                (exList[i].directory.length < dftop.directory.length                  AND dftop.directory[exList[i].directory.length] = '>))          AND            (exList[i].shortname = NIL              OR String.Equivalent[                dftop.shortname, exList[i].shortname]) THEN {ex ¬ TRUE;  EXIT};        ENDLOOP;      IF ex THEN {        IF printStatus THEN {	  CWF.WF4[            "Skip %s on Release.ExceptionList dir [%s]<%s>, ref by (%s"L,	    dftop.shortname, dftop.host, dftop.directory, immediateParent];          CWF.WF1[",%s).\n"L, ancestor]};        RETURN[TRUE]}};    FOR i: CARDINAL IN [0..dfIndex) DO      df ¬ @dfseq[i];      IF df.atsign AND dftop.createtime = df.createtime        AND ((df.exportsAnalyzed AND ~importsWUsing) OR df.includeAnalyzed)        AND String.EquivalentString[dftop.shortname, df.shortname]        AND String.EquivalentString[dftop.directory, df.directory]        AND String.EquivalentString[dftop.host, df.host] THEN {          IF printStatus THEN {            CWF.WF4[              "Skip [%s]<%s>%s, ref by (%s"L,	      dftop.host, dftop.directory, dftop.shortname, immediateParent];            CWF.WF1[",%s).\n"L, ancestor]};          RETURN[TRUE]};      ENDLOOP;    RETURN[FALSE]};  -- carefully designed to work with interestingNestedDF!  AssignRecorder: PROC [      dfseq: DFSubr.DFSeq, start: CARDINAL, recorder: LONG STRING,      parentCameFrom: BOOLEAN] = {    df: DFSubr.DF;    FOR i: CARDINAL IN [start..dfseq.size) DO      df ¬ @dfseq[i];      IF df.recorder = NIL THEN {        df.recorder ¬ Subr.CopyString[recorder, dfseq.dfzone];        df.parentCameFrom ¬ parentCameFrom};      ENDLOOP};  GetDFIndex: PROC [      dfseq: DFSubr.DFSeq, df: DFSubr.DF] RETURNS [dfIndex: CARDINAL] = {    dfIndex ¬  -- unsafe computation      IF df = NIL THEN 0      ELSE Inline.LowHalf[(df - @dfseq[0])/SIZE[DFSubr.DFFileRecord]]};  NextDF: PUBLIC PROC [dfseq: DFSubr.DFSeq] RETURNS [df: DFSubr.DF] = {    IF dfseq.size >= dfseq.maxsize THEN {      CWF.WF0["Error - too many files listed.\n"L];      Subr.errorflg ¬ TRUE;  df ¬ NIL}    ELSE {df ¬ @dfseq[dfseq.size];  df­ ¬ [];  dfseq.size ¬ dfseq.size + 1}};  -- obsolescent: gets ReadOnly handles  ReadInDir: PUBLIC PROC [dfseq: DFSubr.DFSeq] = {    df: DFSubr.DF;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF df.fHandle # NIL THEN {        IF Subr.debugflg THEN ERROR}      ELSE {        df.presentonlocaldisk ¬ TRUE;        df.fHandle ¬ MFile.ReadOnly[          name: df.shortname, release: []           ! MFile.Error => {df.presentonlocaldisk ¬ FALSE;  CONTINUE}]};      ENDLOOP};  -- gets handles with anchor access   LookupFiles: PUBLIC PROC [dfseq: DFSubr.DFSeq] = {    df: DFSubr.DF;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF df.fHandle # NIL THEN {        IF Subr.debugflg THEN ERROR}      ELSE {        df.presentonlocaldisk ¬ TRUE;        df.fHandle ¬ MFile.Acquire[	  name: df.shortname, access: anchor, release: []           ! MFile.Error => {df.presentonlocaldisk ¬ FALSE;  CONTINUE}]};      ENDLOOP};  -- gets one handle with anchor access   LookupOneFile: PUBLIC PROC [df: DFSubr.DF] = {    IF df.fHandle # NIL THEN {      IF Subr.debugflg THEN ERROR}    ELSE {      df.presentonlocaldisk ¬ TRUE;      df.fHandle ¬ MFile.Acquire[name: df.shortname, access: anchor, release: []         ! MFile.Error => {df.presentonlocaldisk ¬ FALSE;  CONTINUE}]}};        -- exported to DFUser  EnumerateEntries: PUBLIC PROC [      dfFileName: LONG STRING, procToCall: DFUser.EnumerateProcType,      nEntriesInDFFiles: CARDINAL,       confirmBeforeOverwriting, printProgressMessages: BOOLEAN,      window: Window.Handle, exec: Exec.Handle,      sortOption: DFUser.SortOption, tryDollars: BOOLEAN,      retrieveDFsToTemp: BOOLEAN ¬ FALSE, localDFDir: LONG STRING ¬ NIL] = {    dfseq: DFSubr.DFSeq ¬ NIL;    df: DFSubr.DF;    includedDFFile, importedDFFile: BOOLEAN;    ExecIOProc: PROC [ch: CHARACTER] = {Exec.PutChar[exec, ch]};    WindowIOProc: PROC [ch: CHARACTER] = {Put.Char[window, ch]};    OP: PROC [CHARACTER] ¬ NIL;    BEGIN      ENABLE UNWIND => {        FreeDFSeq[@dfseq];        IF OP # NIL THEN {[] ¬ CWF.SetWriteProcedure[OP];  OP ¬ NIL}};    IF window = NIL THEN OP ¬ CWF.SetWriteProcedure[ExecIOProc]    ELSE OP ¬ CWF.SetWriteProcedure[WindowIOProc];    dfseq ¬ AllocateDFSeq[maxEntries: nEntriesInDFFiles, zoneType: huge];    -- may raise TooManyEntries    FlattenDF[      dfseq: dfseq, dffilename: dfFileName,      exec: exec, window: window,       defaultUserName: NIL, defaultUserPassword: NIL,      checkForOverwrite: confirmBeforeOverwriting,      printStatus: printProgressMessages,       setRecorder: TRUE, allowForceReadOnly: FALSE, skipCameFrom: FALSE,      retrieveDFsToTemp: retrieveDFsToTemp, localDFDir: localDFDir];    IF sortOption = byShortName THEN       SortByFileName[dfseq, 0, dfseq.size-1, TRUE]    ELSE IF sortOption = byLongName THEN      SortByFileName[dfseq, 0, dfseq.size-1, FALSE];    FOR i: CARDINAL IN [0 .. dfseq.size) DO      df ¬ @dfseq[i];      includedDFFile ¬ (        df.atsign AND Subr.EndsIn[df.shortname, ".df"L]         AND ~df.readonly AND ~df.publicOnly);      importedDFFile ¬ (        df.atsign AND Subr.EndsIn[df.shortname, ".df"L]         AND df.readonly AND df.publicOnly);      procToCall[        df.host, df.directory, df.shortname, df.version, df.createtime,         includedDFFile, importedDFFile, df.readonly, df.recorder, dfseq];      ENDLOOP;    FreeDFSeq[@dfseq];    IF OP # NIL THEN {[] ¬ CWF.SetWriteProcedure[OP];  OP ¬ NIL};    END};	  -- exported to DFUser  CleanupEnumerate: PUBLIC PROC = {};  -- if shout is # NIL, then this is written out to shout  -- if toplevelfile is # NIL, then descendents is printed out   WriteOut: PUBLIC PROC [      dfseq: DFSubr.DFSeq, topLevelFile: STRING, outputStream: MStream.Handle,      print: BOOLEAN] = {    curhost: STRING ¬ [50];    curdir: STRING ¬ [100];    curreleaseDirectory: STRING ¬ [100];    curreleaseHost: STRING ¬ [40];    curreadonly, curpublic, p: BOOLEAN ¬ FALSE;    sfn: STRING ¬ [100];    df: DFSubr.DF;    prefixChars: CARDINAL;    wp: PROC [ch: CHARACTER] = {      IF print THEN CWF.WFC[ch];      IF outputStream # NIL THEN Stream.PutChar[outputStream, ch]};    IF topLevelFile # NIL THEN      CWF.FWF1[wp, "-- Mesa User Files (descendents of %s):\n"L, topLevelFile];    ConsolidateImports[dfseq];    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF ~p AND df.systemfile THEN {        CWF.FWF0[wp, "-- Mesa System Files:\n"L];  p ¬ TRUE};      IF df.comment # NIL THEN CWF.FWF1[wp, "%s"L, df.comment];      IF df.atsign THEN {        IF df.readonly AND df.publicOnly THEN {          PrintImports[df, wp]; curhost.length ¬ 0; LOOP}        ELSE          IF ~df.readonly AND ~df.publicOnly THEN {            PrintInclude[df, wp]; curhost.length ¬ 0; LOOP}};      IF df.host # NIL AND df.directory # NIL        AND          (~String.EquivalentString[curhost, df.host]            OR ~String.EquivalentString[curdir, df.directory]            OR curreadonly # df.readonly OR curpublic # df.public            OR              (df.releaseDirectory # NIL               AND ~String.EquivalentString[	         curreleaseDirectory, df.releaseDirectory])            OR              (df.releaseHost # NIL                AND ~String.EquivalentString[                  curreleaseHost, df.releaseHost])) THEN {        IF df.public THEN CWF.FWF0[wp, "Exports "L];        IF df.readonly THEN CWF.FWF0[wp, "ReadOnly "L];        IF ~df.public AND ~df.readonly THEN CWF.FWF0[wp, "Directory "L];        CWF.FWF2[wp, "[%s]<%s>"L, df.host, df.directory];        Subr.StrCopy[curhost, df.host];        Subr.StrCopy[curdir, df.directory];        IF df.releaseDirectory # NIL THEN {          CWF.FWF3[            wp, "     %s [%s]<%s>"L,            IF df.cameFrom THEN "CameFrom"L ELSE "ReleaseAs"L, df.releaseHost,            df.releaseDirectory];          Subr.StrCopy[curreleaseDirectory, df.releaseDirectory];          Subr.StrCopy[curreleaseHost, df.releaseHost]}        ELSE {curreleaseDirectory.length ¬ 0; curreleaseHost.length ¬ 0};        CWF.FWF0[wp, "\n\n"L];        curreadonly ¬ df.readonly;        curpublic ¬ df.public};      IF df.version > 0 THEN CWF.SWF2[sfn, "%s!%u"L, df.shortname, @df.version]      ELSE Subr.StrCopy[sfn, df.shortname];      CWF.FWF0[wp, "  "L];      prefixChars ¬ 0;      IF df.released THEN {CWF.FWF0[wp, "*"L];  prefixChars ¬ prefixChars+1};      IF df.topmark THEN  {CWF.FWF0[wp, "+"L];  prefixChars ¬ prefixChars+1};      IF df.newOnly THEN  {CWF.FWF0[wp, "~"L];  prefixChars ¬ prefixChars+1};      IF df.atsign THEN   {CWF.FWF0[wp, "@"L];  prefixChars ¬ prefixChars+1};      IF df.publicOnly THEN {        CWF.FWF0[wp, "{PublicOnly}"L];  prefixChars ¬ prefixChars+12};      IF (sfn.length + prefixChars) > 40 THEN CWF.FWF1[wp, "%s  "L, sfn]      ELSE {        temp: STRING ¬ "                                        "L;  -- 40 blanks        pad: CARDINAL ¬ (40 - (sfn.length + prefixChars));	temp.length ¬ pad;	CWF.FWF2[wp, "%s%s"L, sfn, temp]};      IF df.createtime > 0 THEN CWF.FWF1[wp, " %lt"L, @df.createtime]      ELSE IF df.criterion = update THEN CWF.FWF0[wp, " >"L]      ELSE IF df.criterion = notequal THEN CWF.FWF0[wp, " #"L];      CWF.FWFCR[wp];      ENDLOOP;    IF dfseq.trailingcomment # NIL THEN      CWF.FWF1[wp, "%s"L, dfseq.trailingcomment]};  PrintInclude: PROC [df: DFSubr.DF, wp: PROC [CHARACTER]] = {    CWF.FWF0[wp, "Include "L];    IF df.host # NIL AND df.host.length > 0 THEN CWF.FWF1[wp, "[%s]"L, df.host];    IF df.directory # NIL AND df.directory.length > 0 THEN      CWF.FWF1[wp, "<%s>"L, df.directory];    CWF.FWF1[wp, "%s"L, df.shortname];    IF df.version > 0 THEN CWF.FWF1[wp, "!%u"L, @df.version];    IF df.createtime > 0 THEN CWF.FWF1[wp, "  Of %lt "L, @df.createtime]    ELSE      IF df.criterion = notequal THEN CWF.FWF0[wp, " Of #"L]      ELSE IF df.criterion = update THEN CWF.FWF0[wp, " Of >"L];    IF df.releaseHost # NIL THEN      CWF.FWF3[        wp, "\n    %s [%s]<%s>"L,        IF df.cameFrom THEN "CameFrom"L ELSE "ReleaseAs"L, df.releaseHost,        df.releaseDirectory];    CWF.FWF0[wp, "\n"L]};  -- no extra trailing \n is supplied  PrintImports: PROC [df: DFSubr.DF, wp: PROC [CHARACTER]] = {    IF df.public THEN CWF.FWF0[wp, "Exports "L];    CWF.FWF0[wp, "Imports "L];    IF df.host # NIL AND df.host.length > 0 THEN CWF.FWF1[wp, "[%s]"L, df.host];    IF df.directory # NIL AND df.directory.length > 0 THEN      CWF.FWF1[wp, "<%s>"L, df.directory];    CWF.FWF1[wp, "%s"L, df.shortname];    IF df.version > 0 THEN CWF.FWF1[wp, "!%u"L, @df.version];    IF df.createtime > 0 THEN CWF.FWF1[wp, "  Of %lt "L, @df.createtime]    ELSE      IF df.criterion = notequal THEN CWF.FWF0[wp, " Of #"L]      ELSE IF df.criterion = update THEN CWF.FWF0[wp, " Of >"L];    IF df.releaseHost # NIL THEN      CWF.FWF3[        wp, "\n    %s [%s]<%s>"L,        IF df.cameFrom THEN "CameFrom"L ELSE "ReleaseAs"L, df.releaseHost,        df.releaseDirectory];    CWF.FWF0[wp, "\n"L];    IF df.using # NIL THEN      PrintUsing[df.using, wp]}; -- no extra trailing \n supplied  MAXLINE: CARDINAL = 65;  PrintUsing: PROC [usingseq: DFSubr.UsingSeq, wp: PROC [CHARACTER]] = {    lineposn: CARDINAL ¬ 0;    prefix: STRING ¬ "\n       "L;    p: BOOLEAN ¬ FALSE;    CWF.FWF0[wp, "    Using ["L];    lineposn ¬ 10;    FOR i: CARDINAL IN [0..usingseq.size) DO      IF p THEN {        lineposn ¬ lineposn + 2;        CWF.FWF0[wp, ", "L];        IF lineposn > MAXLINE THEN {          CWF.FWF0[wp, prefix]; lineposn ¬ prefix.length}};      p ¬ TRUE;      CWF.FWF1[wp, "%s"L, usingseq[i]];      lineposn ¬ lineposn + usingseq[i].length;      ENDLOOP;    CWF.FWF0[wp, "]\n"L]};  AppendToUsingSeq: PUBLIC PROC [        oldusing: DFSubr.UsingSeq, shortname: LONG STRING, zone: UNCOUNTED ZONE]      RETURNS [newusing: DFSubr.UsingSeq] = {    IF oldusing = NIL THEN {      newusing ¬ zone.NEW[DFSubr .UsingSeqRecord[20]]; newusing.zone ¬ zone}    ELSE      IF oldusing.size >= oldusing.maxsize THEN {        oldzone: UNCOUNTED ZONE;        newusing ¬ zone.NEW[DFSubr.UsingSeqRecord[oldusing.size + 20]];        newusing.zone ¬ zone;        newusing.size ¬ oldusing.size;        FOR i: CARDINAL IN [0..oldusing.size) DO          newusing[i] ¬ oldusing[i]; ENDLOOP;        oldzone ¬ oldusing.zone;        oldzone.FREE[@oldusing]}      ELSE newusing ¬ oldusing;    newusing[newusing.size] ¬ Subr.CopyString[shortname, newusing.zone];    newusing.size ¬ newusing.size + 1};  -- limiter is never changed  -- driver has entry removed for each that is added to newusing  IntersectUsing: PUBLIC PROC [      driver, limiter: DFSubr.UsingSeq] RETURNS [newusing: DFSubr.UsingSeq] = {    newusing ¬ NIL;    FOR i: CARDINAL IN [0..driver.size) DO      IF driver[i] = NIL THEN LOOP;      FOR j: CARDINAL IN [0..limiter.size) DO        IF String.EquivalentString[driver[i], limiter[j]] THEN {          newusing ¬ AppendToUsingSeq[newusing, driver[i], driver.zone];          Subr.FreeString[driver[i], driver.zone];          driver[i] ¬ NIL;          EXIT};        ENDLOOP;      ENDLOOP};  UsingEmpty: PUBLIC PROC [usingseq: DFSubr.UsingSeq] RETURNS [empty: BOOLEAN] = {    IF usingseq = NIL THEN RETURN[TRUE];    FOR i: CARDINAL IN [0..usingseq.size) DO      IF usingseq[i] # NIL THEN RETURN[FALSE];      ENDLOOP;    RETURN[TRUE]};  -- may return NIL if limiter is empty  CopyUsing: PUBLIC PROC [      limiter: DFSubr.UsingSeq] RETURNS [newusing: DFSubr.UsingSeq] = {    newusing ¬ NIL;    FOR i: CARDINAL IN [0..limiter.size) DO      newusing ¬ AppendToUsingSeq[newusing, limiter[i], limiter.zone];      ENDLOOP};  -- allocation/ deallocation  AllocateDFSeq: PUBLIC PROC [        maxEntries: CARDINAL, zoneType: DFSubr.ZoneType]      RETURNS [dfseq: DFSubr.DFSeq] = {    dfseq ¬ AllocSpecialSeq[maxEntries, zoneType];    dfseq.zoneType ¬ zoneType;    SELECT zoneType FROM      shared  => dfseq.dfzone ¬ Subr.LongZone[];      single  => dfseq.dfzone ¬ Heap.Create[initial: 30, increment: 10];      huge    => dfseq.dfzone ¬ Subr.HugeZone[];      ENDCASE;    IF zoneType = huge THEN {  -- allocate (common) hosts in huge zone      dfseq.igorHost ¬ Subr.CopyString["Igor"L, dfseq.dfzone];      dfseq.idunHost ¬ Subr.CopyString["Idun"L, dfseq.dfzone]}    ELSE dfseq.igorHost ¬ dfseq.idunHost ¬ NIL};  AllocSpecialSeq: PROC [        maxEntries: CARDINAL, zoneType: DFSubr.ZoneType]      RETURNS [dfseq: DFSubr.DFSeq] = {    nWords: LONG CARDINAL ¬      (LONG[SIZE[DFSubr.DFFileRecord]]*maxEntries + SIZE[DFSubr.DFSeqRecord[0]]);    SELECT zoneType FROM      huge =>         dfseq ¬ Subr.WordsFromHugeZone[nWords];      shared, single => {        nPages: CARDINAL ¬ Inline.LowHalf[nWords/Environment.wordsPerPage + 1];	seg: MSegment.Handle ¬ MSegment.Create[	  file: NIL, release: [], pages: nPages, swapInfo: [uniform [size: 4]]];	dfseq ¬ MSegment.Address[seg]};      ENDCASE;    -- assign to the MAX SIZE !!!!    (LOOPHOLE[dfseq, LONG POINTER] + SIZE[DFSubr.DFSeqRecord[0]] - 1)­ ¬      maxEntries;    dfseq.dfzone ¬ NIL;    dfseq.zoneType ¬ zoneType;    dfseq.size ¬ 0;    dfseq.trailingcomment ¬ NIL};  FreeDFSeq: PUBLIC PROC [pdfseq: LONG POINTER TO DFSubr.DFSeq] = {    df: DFSubr.DF;    zone: UNCOUNTED ZONE;    seg: MSegment.Handle ¬ NIL;    IF pdfseq­ = NIL THEN RETURN;    IF pdfseq.zoneType = huge THEN {  -- can't free anything      pdfseq­ ¬ NIL;  RETURN};    zone ¬ pdfseq.dfzone;    FOR i: CARDINAL IN [0..pdfseq.size) DO      df ¬ @pdfseq[i];      -- release any outstanding file handles      IF df.fHandle # NIL THEN {        MFile.Release[df.fHandle ! MFile.Error => CONTINUE];	df.fHandle ¬ NIL};      -- strings can be NIL, but that won't cause problems      Subr.FreeString[df.directory, zone];      Subr.FreeString[df.shortname, zone];      Subr.FreeString[df.host, zone];      Subr.FreeString[df.releaseHost, zone];      Subr.FreeString[df.releaseDirectory, zone];      Subr.FreeString[df.comment, zone];      Subr.FreeString[df.recorder, zone];      IF df.using # NIL THEN FreeUsingSeq[df.using];      ENDLOOP;    Subr.FreeString[pdfseq.trailingcomment, zone];    IF pdfseq.zoneType = single THEN {  -- must free the associated heap too!      deleteAgain: BOOLEAN ¬ FALSE;      Heap.Delete[z: pdfseq.dfzone, checkEmpty: TRUE         ! Heap.Error => {            IF type = invalidHeap THEN {              deleteAgain ¬ TRUE;              IF Subr.debugflg THEN	        CWF.WF0["Debugging: Single Heap not empty.\n"L]};            CONTINUE}];      IF deleteAgain THEN        Heap.Delete[z: pdfseq.dfzone, checkEmpty: FALSE	  ! Heap.Error => CONTINUE]};    -- now delete sequence itself    seg ¬ MSegment.AddresstoSegment[pdfseq­];    MSegment.Delete[seg];    pdfseq­ ¬ NIL};  FreeUsingSeq: PUBLIC PROC [using: DFSubr.UsingSeq] = {    zone: UNCOUNTED ZONE;    IF using = NIL THEN RETURN;    zone ¬ using.zone;    FOR i: CARDINAL IN [0..using.size) DO      Subr.FreeString[using[i], zone];      ENDLOOP;    zone.FREE[@using]};  -- fullname is readonly; any of host, directory, short may be NIL  -- if mustbedir is TRUE then if long does not end in a '>  --   the tail is assumed to be part of the directory, not short (name),  --   e.g. "schmidt>pilot" is all a directory if mustbedir is TRUE  -- may raise String.InvalidNumber  StripLongName: PUBLIC PROC [        fullname, host, directory, short: LONG STRING, mustbedir: BOOLEAN]      RETURNS [version: CARDINAL] = {    last, bot: CARDINAL;    rightSqBrktFound: BOOLEAN ¬ FALSE;    first: INTEGER;    stemp: STRING ¬ [150];    long: STRING ¬ [150];  -- long has host name stripped off    IF host # NIL THEN host.length ¬ 0;    IF directory # NIL THEN directory.length ¬ 0;    IF short # NIL THEN short.length ¬ 0;    IF fullname.length = 0 THEN RETURN[0];    Subr.StrCopy[long, fullname];    IF host # NIL AND long[0] = '[ THEN {      i: CARDINAL ¬ 1;      WHILE i < long.length AND i < host.maxlength DO        IF long[i] = '] THEN {rightSqBrktFound ¬ TRUE;  EXIT};        String.AppendChar[host, long[i]];  i ¬ i + 1;	ENDLOOP;      IF ~rightSqBrktFound OR i >= long.length THEN {        CWF.WF1["Error - missing ']': %s.\n"L, long];  RETURN};      Subr.SubStrCopy[long, long, i + 1]};    last ¬ long.length - 1;    WHILE last > 0 AND long[last] IN ['0..'9] DO last ¬ last - 1; ENDLOOP;    -- last points to '!, '; or the end of the file name (= long.length - 1)    IF last < long.length - 1 AND (long[last] = '! OR long[last] = ';) THEN {      Subr.SubStrCopy[stemp, long, last + 1];      version ¬ String.StringToDecimal[stemp];      last ¬ last - 1}    ELSE {      last ¬ long.length - 1;  -- in case the filename ended in a number      version ¬ 0};    -- last is now char before !, ;, or end of filename    first ¬ last;    WHILE first >= 0 AND (long[first] # '> AND long[first] # '<) DO      first ¬ first - 1;      ENDLOOP;    IF first > 0 THEN first ¬ first + 1;    IF first < 0 THEN first ¬ 0;    bot ¬ IF mustbedir THEN last + 1 ELSE first;    -- bot is the first char of the short name    IF short # NIL THEN {      FOR i: CARDINAL IN [bot..last] DO        String.AppendChar[short, long[i]];	ENDLOOP};    IF directory # NIL THEN {      Subr.StrCopy[directory, long];      directory.length ¬ bot;      IF bot > 0 THEN {        IF directory[bot - 1] = '> THEN directory.length ¬ directory.length - 1;        IF directory[0] = '< THEN Subr.SubStrCopy[directory, directory, 1]}}};  LookupDF: PUBLIC PROC [      dfseq: DFSubr.DFSeq, shortname: LONG STRING] RETURNS [df: DFSubr.DF] = {    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF df.shortname # NIL        AND String.EquivalentString[df.shortname, shortname] THEN RETURN[df];      ENDLOOP;    RETURN[NIL]};  InsertCRs: PUBLIC PROC [dfseq: DFSubr.DFSeq] = {    df: DFSubr.DF;    curhost: STRING ¬ [40];    curdir: STRING ¬ [60];    crline: STRING ¬ [2];    crline[0] ¬ Ascii.CR;  crline.length ¬ 1;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF df.host # NIL AND ~String.EquivalentString[curhost, df.host] THEN {        Subr.StrCopy[curhost, df.host];        IF df.comment = NIL THEN          df.comment ¬ Subr.CopyString[crline, dfseq.dfzone]};      IF df.directory # NIL      AND ~String.EquivalentString[curdir, df.directory] THEN {        Subr.StrCopy[curdir, df.directory];        IF df.comment = NIL THEN	  df.comment ¬ Subr.CopyString[crline, dfseq.dfzone]};      ENDLOOP;    IF dfseq.trailingcomment = NIL THEN      dfseq.trailingcomment ¬ Subr.CopyString[crline, dfseq.dfzone]};       -- ################### Sort DFs ####################    SortByFileName: PUBLIC PROC [      dfseq: DFSubr.DFSeq, min, max: CARDINAL, ignorehostanddir: BOOLEAN] = {    out, in: CARDINAL;    OutputUnsortedDF: GSort.GetProcType = {      df: DFSubr.DF = p;      IF out > max THEN RETURN[0]  -- no DF entries remain      ELSE {        df­ ¬ dfseq[out];  out ¬ out+1;        RETURN[SIZE[DFSubr.DFFileRecord]]}};          InsertSortedDF: GSort.PutProcType = {      df: DFSubr.DF = p;      dfseq[in] ¬ df­;  in ¬ in+1};        CompareDFNames: GSort.CompareProcType = {      df1: DFSubr.DF = p1;      df2: DFSubr.DF = p2;      RETURN[CompareDFs[df1, df2, ignorehostanddir]]};    out ¬ in ¬ min;    GSort.Sort[      get: OutputUnsortedDF, put: InsertSortedDF, compare: CompareDFNames,      expectedItemSize: SIZE[DFSubr.DFFileRecord],      maxItemSize: SIZE[DFSubr.DFFileRecord], pagesInHeap: 120]};      CompareDFs: PUBLIC PROC [        dfleft, dfright: DFSubr.DF, ignorehostanddir: BOOLEAN ¬ FALSE]      RETURNS [res: INTEGER] = {    res ¬ 0;    IF dfleft.shortname = NIL OR dfright.shortname = NIL THEN RETURN[0];    IF ~ignorehostanddir THEN {      IF dfleft.host # NIL AND dfright.host # NIL THEN        res ¬ String.CompareStrings[dfleft.host, dfright.host, TRUE];      IF res # 0 THEN RETURN[res];      IF dfleft.directory # NIL AND dfright.directory # NIL THEN        res ¬ String.CompareStrings[dfleft.directory, dfright.directory, TRUE];      IF res # 0 THEN RETURN[res]};    RETURN[String.CompareStrings[dfleft.shortname, dfright.shortname, TRUE]]};	  ConsolidateImports: PROC[dfseq: DFSubr.DFSeq] = {    count: CARDINAL ¬ 0;    df: DFSubr.DF;    i, index, nonimports: CARDINAL;    importlist: DFSubr.DFSeq ¬ NIL;    FOR i: CARDINAL IN [0..dfseq.size) DO	-- count the imports      df ¬ @dfseq[i];      IF df.atsign AND df.readonly AND df.publicOnly THEN count ¬ count + 1;      ENDLOOP;    IF count = 0 THEN RETURN;    importlist ¬ dfseq.dfzone.NEW[DFSubr.DFSeqRecord[count]];    index ¬ 0;    FOR i IN [0..dfseq.size) DO	-- take out the imports      df ¬ @dfseq[i];      IF df.atsign AND df.readonly AND df.publicOnly THEN {        importlist[index] ¬ dfseq[i];	index ¬ index + 1;	};      ENDLOOP;    importlist.size ¬ count;    nonimports ¬ dfseq.size - count;    index ¬ 0;    FOR i IN [0..dfseq.size) DO	-- pack non imports      df ¬ @dfseq[i];      IF df.atsign AND df.readonly AND df.publicOnly THEN LOOP;      IF index # i THEN dfseq[index] ¬ dfseq[i];      index ¬ index +1;      ENDLOOP;    importlist.dfzone ¬ dfseq.dfzone;    SortImportList[importlist];    MergeImportList[importlist];    FOR i IN [0..importlist.size) DO	-- return the imports      dfseq[index] ¬ importlist[i];      index ¬ index + 1;      ENDLOOP;    dfseq.size ¬ nonimports + importlist.size;    dfseq.dfzone.FREE[@importlist];    };    SortImportList: PROCEDURE [importlist: DFSubr.DFSeq] = {    df1, df2: DFSubr.DF;    compare: QuickSort.CompareProc = {      df1 ¬ @importlist[one];      df2 ¬ @importlist[two];      SELECT String.Compare[df1.host, df2.host] FROM        -1 => RETURN [smaller];	1 => RETURN [bigger];	ENDCASE => SELECT String.Compare[df1.shortname, df2.shortname] FROM	  -1 => RETURN [smaller];	  1 => RETURN [bigger];	  ENDCASE => SELECT String.Compare[df1.directory, df2.directory] FROM	    -1 => RETURN [smaller];	    1 => RETURN [bigger];	    ENDCASE => RETURN[same];      };    swap: QuickSort.SwapProc = {      temp: DFSubr.DFFileRecord;      temp ¬ importlist[one];      importlist[one] ¬ importlist[two];      importlist[two] ¬ temp;      };    QuickSort.Sort[0, importlist.size-1, compare, swap, NIL];    };    SortUsingList: PROCEDURE [using: DFSubr.UsingSeq] = {    compare: QuickSort.CompareProc = {      SELECT String.Compare[using[one], using[two]] FROM        -1 => RETURN [smaller];	1 => RETURN [bigger];	ENDCASE => RETURN[same];      };    swap: QuickSort.SwapProc = {      temp: LONG STRING;      temp ¬ using[one];      using[one] ¬ using[two];      using[two] ¬ temp;      };    QuickSort.Sort[0, using.size-1, compare, swap, NIL];    };    MergeImportList: PROCEDURE [importlist: DFSubr.DFSeq] = {    i, j, k: CARDINAL ¬ 0;    df, lastdf: DFSubr.DF;    totalCollapse: CARDINAL ¬ 0;    CollaspeDuplicates: PROC[original, lastDuplicate: CARDINAL] = {      collapse: CARDINAL ¬ lastDuplicate-original-1;      IF collapse > 0 THEN {	-- there were some merges, so collapse	totalCollapse ¬ totalCollapse + collapse;	FOR i: CARDINAL IN [lastDuplicate..importlist.size) DO	  importlist[i-collapse] ¬ importlist[i];	  ENDLOOP;	importlist.size ¬ importlist.size - collapse;	SortUsingList[lastdf.using];	};      };           WHILE i < importlist.size DO      lastdf ¬ @importlist[i];      FOR j IN [i+1..importlist.size) DO        df ¬ @importlist[j];	IF String.EquivalentString[lastdf.shortname, df.shortname] AND 	  String.EquivalentString[lastdf.host, df.host] AND	  String.EquivalentString[lastdf.directory, df.directory] AND	  lastdf.using # NIL AND df.using # NIL THEN {	-- merge imports	  newsize: CARDINAL ¬ lastdf.using.size + df.using.size;	  newusing: DFSubr.UsingSeq ¬ lastdf.using.zone.NEW[	    DFSubr.UsingSeqRecord[newsize] ¬ [	    zone: lastdf.using.zone, size: newsize, body:]];	  index: CARDINAL ¬ 0;	  zone: UNCOUNTED ZONE ¬ importlist.dfzone;	  FOR n: CARDINAL IN [0..lastdf.using.size) DO	    newusing[index] ¬ lastdf.using[n];	    index ¬ index + 1;	    ENDLOOP;	  FOR n: CARDINAL IN [0..df.using.size) DO	    newusing[index] ¬ df.using[n];	    index ¬ index + 1;	    ENDLOOP;	  lastdf.using.zone.FREE[@lastdf.using];	  df.using.zone.FREE[@df.using];	  zone.FREE[@df.host];	  zone.FREE[@df.directory];	  zone.FREE[@df.shortname];	  zone.FREE[@df.releaseHost];	  zone.FREE[@df.releaseDirectory];	  zone.FREE[@df.comment];	  zone.FREE[@df.recorder];	  lastdf.using ¬ newusing;	  }	ELSE {CollaspeDuplicates[i, j]; EXIT};	REPEAT FINISHED => 	  IF importlist.size-i > 1 THEN CollaspeDuplicates[i, importlist.size];	ENDLOOP;      i ¬ i+1;       ENDLOOP;    };    END.
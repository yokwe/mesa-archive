-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- File DFToolCommands.mesa - last edited by--   BTL  	20-Dec-83 11:19:25--   DSC  	 6-Mar-85 15:47:53DIRECTORY  BringOverInterface USING [    AlreadyRunning, BringOverDF, CheckThisFile, DoneRunning, Options,    RecursiveLoop],  CWF USING [SWF1, WF0, WF1, WF2, WFC],  DFDeleteInterface USING [    AlreadyRunning, DeleteDF, DoneRunning, Finalize, Initialize, Options],  DFLibrarian USING [    CheckOutLibject, Finalize, Initialize, LookupLibject, QueryLibject, Retrieve, Usable],  DFSubr USING [    AppendToUsingSeq, FreeUsingSeq, TooManyEntries, UsingEmpty, UsingSeq],  DFToolOps USING [CmdProc, Data, IsAborted, PostMsg, toolData],  FileName,  Heap USING [Error],  LeafSubr USING [StartLeaf, StopLeaf],  MFile USING [Acquire, Delete, Error, Handle, maxNameLength, Object],  MStream USING [Error, Handle, ReadOnly],  Profile USING [debugging, GetUser, String],  SModelInterface USING [AlreadyRunning, DoneRunning, Options, StoreDF],  Stream USING [Delete, EndOfStream, GetChar],  String USING [    AppendChar, AppendExtensionIfNeeded, CopyToNewString, Empty, Equivalent,    FreeString, MakeString],  Subr USING [    DeleteHugeZone, errorflg, GetLocalDir, GetNameandPassword, HugeZone],  Time USING [Packed],  Token USING [    FilterProcType, FreeTokenString, Handle, MaybeQuoted, nonQuote, Object,    QuoteProcType, WhiteSpace],  VerifyDFInterface USING [AlreadyRunning, DoneRunning, Options, VerifyDFFile];DFToolCommands: PROGRAM  IMPORTS    BringOverInterface, CWF, DFDeleteInterface, DFLibrarian, DFSubr, DFToolOps,    FileName, Heap, LeafSubr, MFile, MStream, Profile, SModelInterface, Stream,    String, Subr, Token, VerifyDFInterface  EXPORTS DFToolOps =  BEGIN  td: DFToolOps.Data ¬ DFToolOps.toolData;  -- also set by each CmdProc    -- Should consider using Token for this!!!!!  cmdLine: LONG STRING ¬ NIL; -- Used to hold 1) DF files list and 2) Specified files list.  cmdPtr: CARDINAL ¬ 0; -- Current parsing position of cmdLine.     SorryNoLibrarian: PROCEDURE = {     CWF.WF0["Sorry, you don't have a librarian service available in your boot file!\n"];   };  CheckOut: PUBLIC DFToolOps.CmdProc = {    name, dfName: LONG STRING ¬ NIL;    librarianProblem: BOOLEAN ¬ FALSE;    Cleanup: PROC = {      IF name # NIL THEN {name ¬ FreeName[name]; name ¬ NIL};      DoneParsingNames[];      IF ~String.Empty[dfName] THEN {        String.FreeString[td.dfZone, dfName]; dfName ¬ NIL};      DFLibrarian.Finalize[td.libHandle]};    DoCheckOut: PROC [name: LONG STRING] = {      libjectExists, success, retrieved: BOOLEAN;      [libjectExists, librarianProblem] ¬ DFLibrarian.LookupLibject[td.libHandle, name];      IF librarianProblem THEN RETURN;      IF ~libjectExists THEN {        msg: STRING ¬ [150];        CWF.SWF1[msg, "No libject exists for %s."L, name];        CWF.WF1["%s\n"L, msg];        DFToolOps.PostMsg[msg];        Subr.errorflg ¬ TRUE;        RETURN};      success ¬ DFLibrarian.CheckOutLibject[td.libHandle, name, td.reasonCopy];      IF success THEN {        msg: STRING ¬ [100];        CWF.WF1["%s has been checked out.\n"L, name];        DFToolOps.PostMsg["Libject checked out."L];        CWF.WF0["Retrieving Libject file\n"L];        retrieved ¬ DFLibrarian.Retrieve[h: td.libHandle, shortName: name, window: td.ttySW];        IF ~retrieved THEN {          CWF.SWF1[msg, "%s NOT retrieved."L, name];          CWF.WF1["%s\n"L, msg];          DFToolOps.PostMsg[msg];          Subr.errorflg ¬ TRUE}}      ELSE {        CWF.WF1["%s has NOT been checked out.\n"L, name];        DFToolOps.PostMsg["Libject NOT checked out."L];        Subr.errorflg ¬ TRUE}};    BEGIN    ENABLE UNWIND => Cleanup[];    -- This is an extra check, since this code cannot be reached    -- because the DFTool is not supposed to have the Librarian    -- commmands made visible. But other clients may not.    -- N.B. The above applies to the old dftool only. New one's too stupid to    -- turn them off. Actually, it's tough to turn off a single part of an enum.    IF NOT DFLibrarian.Usable[] THEN {      SorryNoLibrarian[];      Subr.errorflg ¬ TRUE;      RETURN;    };    td ¬ DFToolOps.toolData;        IF String.Empty[td.reasonCopy] THEN {      CWF.WF0["\nPlease supply a Librarian checkout reason.\n"L];      DFToolOps.PostMsg["No Librarian checkout reason given!"L];      Subr.errorflg ¬ TRUE;      RETURN};    IF ~DFLibrarian.Initialize[h: td.libHandle, servername: td.libHandle.servername, zone: td.dfZone] THEN {      CWF.WF0["\nInvalid Librarian profile entries.\n"L];      DFToolOps.PostMsg["Invalid Librarian profile entries!"L];      Subr.errorflg ¬ TRUE;      RETURN};    InsureLoggedIn[];    CWF.WF1["CheckOut reason: %s.\n"L, td.reasonCopy];    StartParsingNames[td.inputDfFilesCopy];    name ¬ GetName[];    WHILE ~String.Empty[name] AND ~librarianProblem DO      dfName ¬ String.CopyToNewString[s: name, z: td.dfZone, longer: 3];      [] ¬ String.AppendExtensionIfNeeded[        to: @dfName, extension: ".df"L, z: td.dfZone];      DoCheckOut[dfName];      String.FreeString[z: td.dfZone, s: dfName];      dfName ¬ NIL;      name ¬ FreeName[name];      name ¬ GetName[];      ENDLOOP;    DoneParsingNames[];    StartParsingNames[td.inputFilesCopy];    name ¬ GetName[];    WHILE ~String.Empty[name] AND ~librarianProblem DO      DoCheckOut[name]; name ¬ FreeName[name]; name ¬ GetName[]; ENDLOOP;    Cleanup[];    END};  Query: PUBLIC DFToolOps.CmdProc = {    -- Name:  STRING from form.    -- dfName: On DF form, has DF  appened if needed.    -- shortname: if "Name" is a full path name, is its trailing short name    -- queryname: Is used for the query. May be name or the shortname (if name is full)    name, dfName, shortname, queryname: LONG STRING ¬ NIL;    librarianProblem, shortened: BOOLEAN ¬ FALSE;    tmpVfn: FileName.VFN ¬ NIL;    Cleanup: PROC = {      IF name # NIL THEN {name ¬ FreeName[name]; name ¬ NIL};      IF tmpVfn # NIL THEN {         FileName.FreeVFN[tmpVfn]; 	 tmpVfn ¬ NIL};      DoneParsingNames[];      IF ~String.Empty[dfName] THEN {         String.FreeString[td.dfZone, dfName]; dfName ¬ NIL};      DFLibrarian.Finalize[td.libHandle]};           -- In the NS librarian, we only have a checkoutuser, so use checkoutuser.    DoQuery: PROC [name: LONG STRING, truncated: BOOLEAN, originalname: LONG STRING] = {      libjectExists, checkedOut, badRemoteFileName: BOOLEAN ¬ FALSE;      localName: LONG STRING ¬ [100];       remoteName: LONG STRING ¬ [100];      versionLessRemoteName: LONG STRING ¬ [100];      checkOutUser: LONG STRING ¬ [100];      checkOutReason: LONG STRING ¬ [100];       checkInReason: LONG STRING ¬ [100];      checkOutTOD, checkInTOD: Time.Packed;      remVfn: FileName.VFN ¬ NIL; --  remote file name property VFN.      CleanupDoQuery: PROCEDURE = {        IF remVfn # NIL THEN  { 	   FileName.FreeVFN[remVfn];  	   remVfn ¬ NIL};      };      BEGIN      ENABLE UNWIND => CleanupDoQuery[];      [libjectExists, librarianProblem] ¬ DFLibrarian.LookupLibject[td.libHandle, name];      IF librarianProblem THEN RETURN;      IF ~libjectExists THEN {        msg: STRING ¬ [150];        CWF.SWF1[msg, "%s has no libject."L, name];        CWF.WF1["\n%s\n"L, msg];        DFToolOps.PostMsg[msg];        Subr.errorflg ¬ TRUE;        RETURN};      [checkedOut,checkOutTOD, checkInTOD] ¬        DFLibrarian.QueryLibject[td.libHandle, name, localName, remoteName, checkOutUser, checkOutReason, checkInReason];	      -- Truncated means that the user probably supplied a fill remote name for the DF File...      IF truncated THEN {	-- If we got the query name from a long name, make sure that the	-- remote name is the same as the long name. If not, give a warning only..	-- first get rid of the version information from the remote name.	badRemoteFileName ¬ FALSE;	remVfn ¬ FileName.AllocVFN[remoteName ! FileName.Error => {	      CWF.WF1["Warning: Bad remote file name found: '%s'\n"L, remoteName]; badRemoteFileName ¬ TRUE}];	      	-- Avoid FileName errors.   	IF NOT badRemoteFileName THEN {	  versionLessRemoteName ¬ FileName.PackFilename[vfn: remVfn, h: TRUE, d: TRUE, n: TRUE];	  	};	IF NOT String.Equivalent[originalname, versionLessRemoteName] THEN {	     CWF.WF2["Warning: The remote file name: '%s' is not equal to the file name given: '%s'\n"L, remoteName, originalname];	};	-- Free FileName stuff.	IF NOT badRemoteFileName THEN { 	   FileName.FreeFilename[versionLessRemoteName]; 	   FileName.FreeVFN[remVfn];	   remVfn ¬ NIL};      };            -- Display data.      IF checkedOut THEN CWF.WF1["\n%s - currently checked out:\n"L, name]      ELSE CWF.WF1["\n%s - not checked out:\n"L, name];      IF checkedOut THEN {        CWF.WF2["  Checked out by %s on %lt\n"L, checkOutUser, @checkOutTOD];        CWF.WF1["  Checkout reason: %s\n"L, checkOutReason];        CWF.WF1["  Current remote file name: %s\n"L, remoteName]}      ELSE {        CWF.WF2["  Last checked in by %s on %lt\n"L, checkOutUser, @checkInTOD];        IF ~String.Empty[checkInReason] THEN          CWF.WF1["  Checkin reason: %s\n"L, checkInReason];        CWF.WF1["  Remote file name: %s\n"L, remoteName]};      CWF.WF1["  Local file name: %s\n"L, localName];            END;      CleanupDoQuery[];      };    BEGIN     ENABLE UNWIND => Cleanup[];    IF NOT DFLibrarian.Usable[] THEN {      SorryNoLibrarian[];      Subr.errorflg ¬ TRUE;      RETURN;    };     td ¬ DFToolOps.toolData;    IF ~DFLibrarian.Initialize[h: td.libHandle, servername: td.libHandle.servername, zone: td.dfZone] THEN {      CWF.WF0["\nInvalid Librarian profile entries.\n"L];      DFToolOps.PostMsg["Invalid Librarian profile entries!"L];      Subr.errorflg ¬ TRUE;      RETURN};    InsureLoggedIn[];    -- First check the DFfiles: parameters.    StartParsingNames[td.inputDfFilesCopy];    name ¬ GetName[];    shortened ¬ FALSE;    WHILE ~String.Empty[name] AND ~librarianProblem DO      dfName ¬ String.CopyToNewString[s: name, z: td.dfZone, longer: 3];      [] ¬ String.AppendExtensionIfNeeded[        to: @dfName, extension: ".df"L, z: td.dfZone];      -- Use only the short name.      tmpVfn ¬ FileName.AllocVFN[        dfName !        FileName.Error => {          CWF.WF1["Bad file name given: '%s'\n"L, dfName]; GOTO error}];      -- If the "name" of the file equals the fullname, then we were given a short name only.       -- get short name      shortname ¬ FileName.PackFilename[vfn: tmpVfn, n: TRUE];      IF NOT String.Equivalent[s1: shortname, s2: dfName] THEN {        queryname ¬ FileName.PackFilename[vfn: tmpVfn, n: TRUE];	shortened ¬ TRUE}      ELSE        queryname ¬ dfName;      -- Debug      CWF.WF1["Query for file: '%s'\n"L, queryname];      DoQuery[name: queryname, truncated: shortened, originalname: dfName];      --      -- clean up....      FileName.FreeFilename[shortname];      FileName.FreeVFN[tmpVfn];       tmpVfn ¬ NIL;      shortened ¬ FALSE;      String.FreeString[z: td.dfZone, s: dfName];      dfName ¬ NIL;      name ¬ FreeName[name];      name ¬ GetName[];      ENDLOOP;    DoneParsingNames[];    -- Check the individual lines.    StartParsingNames[td.inputFilesCopy];    name ¬ GetName[];    WHILE ~String.Empty[name] AND ~librarianProblem DO      DoQuery[name: name, truncated: FALSE, originalname: NIL]; name ¬ FreeName[name]; name ¬ GetName[]; ENDLOOP;    EXITS error => Subr.errorflg ¬ TRUE;    END;    Cleanup[];    };  InsureLoggedIn: PROC = {    loggedIn: BOOLEAN ¬ TRUE;    GetUserCredentials: PROC [name, password: Profile.String] = {      IF String.Empty[name] OR String.Empty[password]        OR String.Equivalent[name, "Guest"L] THEN loggedIn ¬ FALSE};    Profile.GetUser[GetUserCredentials];    IF ~loggedIn THEN      Subr.GetNameandPassword[        nt: login, name2: NIL, password2: NIL, window: DFToolOps.toolData.ttySW]};  BringOver: PUBLIC DFToolOps.CmdProc = {    name, dfName, fileName, retrieveDir: LONG STRING ¬ NIL;    usingSeq: DFSubr.UsingSeq ¬ NIL;    opt: BringOverInterface.Options;    firstName: BOOLEAN ¬ TRUE;    i: CARDINAL ¬ 0;    Cleanup: PROC = {      IF name # NIL THEN {name ¬ FreeName[name]; name ¬ NIL};      DoneParsingNames[];      IF ~String.Empty[dfName] THEN {        String.FreeString[td.dfZone, dfName]; dfName ¬ NIL};      IF ~String.Empty[fileName] THEN {        String.FreeString[td.dfZone, fileName]; fileName ¬ NIL};      IF ~String.Empty[retrieveDir] THEN {        String.FreeString[td.dfZone, retrieveDir]; retrieveDir ¬ NIL};      IF usingSeq # NIL THEN {DFSubr.FreeUsingSeq[usingSeq]; usingSeq ¬ NIL};      BringOverInterface.DoneRunning[]};    BEGIN    ENABLE {      UNWIND => Cleanup[];      BringOverInterface.CheckThisFile => RESUME      ;  -- if it gets here then there is no infinite recursive loop      BringOverInterface.RecursiveLoop => {        CWF.WF0["Error - infinite recursive nesting of DF files using @.\n"L];        CWF.WF1["\tOne of the files involved is %s.\n"L, loopfilename];        ERROR ABORTED}};    td ¬ DFToolOps.toolData;    IF BringOverInterface.AlreadyRunning[] THEN {      CWF.WF0["BringOver already running!"L];      DFToolOps.PostMsg["BringOver already running!"L];      Subr.errorflg ¬ TRUE;      RETURN};    IF String.Empty[td.inputDfFilesCopy] THEN {      CWF.WF0["Error - no DF file name specified.\n"L];      DFToolOps.PostMsg["Error - no DF file name specified!"L];      Subr.errorflg ¬ TRUE;      BringOverInterface.DoneRunning[];      RETURN};    opt ¬ [      mustConfirm: td.switch[confirm], publicOnly: td.switch[getOnlyExports],      verify: td.switch[verifyFilesExist], getOlderOK: td.switch[getOlderOK],      updateExisting: td.switch[updateExisting], forceRetrieval: FALSE,      debugging: Profile.debugging, preRelease: (td.switch[bringOverPreRelease] OR td.switch[preRelease]),      archiveBcdRename: td.switch[archiveBcdRename],      justObjects: td.switch[justObjects],      justReadOnlys: td.switch[justReadOnlys],      justSources: td.switch[justSources],      justNonReadOnlys: td.switch[justNonReadOnlys], onlyFileMode: FALSE,      cmd: FALSE];    retrieveDir ¬ Subr.GetLocalDir[td.localDirCopy, td.dfZone];    StartParsingNames[td.inputDfFilesCopy];    name ¬ GetName[];    WHILE ~String.Empty[name] DO      dfName ¬ String.CopyToNewString[s: name, z: td.dfZone, longer: 3];      [] ¬ String.AppendExtensionIfNeeded[        to: @dfName, extension: ".df"L, z: td.dfZone];      IF firstName THEN {  -- process any list of specific files to bring over        firstName ¬ FALSE;        IF ~String.Empty[td.inputFilesCopy] THEN {          len: CARDINAL = td.inputFilesCopy.length;          fileName ¬ String.MakeString[td.dfZone, MFile.maxNameLength];          WHILE i < len DO            IF DFToolOps.IsAborted[] THEN ERROR ABORTED;            fileName.length ¬ 0;            WHILE i < len              AND (td.inputFilesCopy[i] = '  OR td.inputFilesCopy[i] = ',) DO              i ¬ i + 1; ENDLOOP;            WHILE i < len              AND (td.inputFilesCopy[i] # '  AND td.inputFilesCopy[i] # ',) DO              String.AppendChar[fileName, td.inputFilesCopy[i]];              i ¬ i + 1;              ENDLOOP;            IF fileName.length = 0 THEN LOOP;            usingSeq ¬ DFSubr.AppendToUsingSeq[usingSeq, fileName, td.dfZone];            ENDLOOP}};      BringOverInterface.BringOverDF[        dfFileName: dfName, usingSeq: usingSeq, opt: opt, localDir: retrieveDir,        dfZone: td.dfZone, window: td.ttySW,        abortProc: LOOPHOLE[DFToolOps.IsAborted]];      IF usingSeq # NIL AND ~DFSubr.UsingEmpty[usingSeq] THEN {        CWF.WF0["Error - cannot find "L];        FOR i: CARDINAL IN [0..usingSeq.size) DO          IF usingSeq[i] # NIL THEN CWF.WF1["%s "L, usingSeq[i]]; ENDLOOP;        CWF.WF1["in any DF file nested in %s.\n"L, name];        Subr.errorflg ¬ TRUE};      name ¬ FreeName[name];      name ¬ GetName[];      ENDLOOP;    Cleanup[];    END};    SModel: PUBLIC DFToolOps.CmdProc = {    name, dfName: LONG STRING ¬ NIL;    opt: SModelInterface.Options;    Cleanup: PROC = {      IF name # NIL THEN {name ¬ FreeName[name]; name ¬ NIL};      DoneParsingNames[];      IF dfName # NIL THEN {String.FreeString[td.dfZone, dfName]; dfName ¬ NIL};      SModelInterface.DoneRunning[]};    BEGIN    ENABLE UNWIND => Cleanup[];    -- Copy the td lib stuff to opt.    opt.libHandle ¬ td.libHandle;    td ¬ DFToolOps.toolData;    IF SModelInterface.AlreadyRunning[] THEN {      CWF.WF0["SModel already running!"L];      DFToolOps.PostMsg["SModel already running!"L];      Subr.errorflg ¬ TRUE;      RETURN};    IF String.Empty[td.inputDfFilesCopy] THEN {      CWF.WF0["Error - no DF file name specified.\n"L];      DFToolOps.PostMsg["Error - no DF file name specified!"L];      Subr.errorflg ¬ TRUE;      SModelInterface.DoneRunning[];      RETURN};    opt ¬ [      mustConfirm: td.switch[confirm], verify: td.switch[verifyRemoteOnStore],      dontStoreFiles: td.switch[dontStoreRemotely],      checkLibrarian: td.switch[checkLibrarian],      preRelease: (td.switch[smodelPreRelease] OR td.switch[preRelease]), ignoreReadOnly: FALSE,      topLevelOnly: td.switch[topLevelOnly],      flipCameFrom: td.switch[flipCameFrom], debugging: Profile.debugging,      cmd: FALSE,       dfLibjectsOnly: td.switch[dfLibjectsOnly],      libHandle: td.libHandle];    StartParsingNames[td.inputDfFilesCopy];    name ¬ GetName[];    WHILE ~String.Empty[name] DO      dfName ¬ String.CopyToNewString[s: name, z: td.dfZone, longer: 3];      [] ¬ String.AppendExtensionIfNeeded[        to: @dfName, extension: ".df"L, z: td.dfZone];      SModelInterface.StoreDF[        dfFileName: dfName, opt: opt, dfZone: td.dfZone, window: td.ttySW,        abortProc: LOOPHOLE[DFToolOps.IsAborted]];      String.FreeString[z: td.dfZone, s: dfName];      dfName ¬ NIL;      name ¬ FreeName[name];      name ¬ GetName[];      ENDLOOP;    Cleanup[];    END};  VerifyDF: PUBLIC DFToolOps.CmdProc = {    name, dfName: LONG STRING ¬ NIL;    opt: VerifyDFInterface.Options;    ZonePages: CARDINAL = 350;    Cleanup: PROC = {      IF name # NIL THEN {name ¬ FreeName[name]; name ¬ NIL};      DoneParsingNames[];      IF dfName # NIL THEN {String.FreeString[td.dfZone, dfName]; dfName ¬ NIL};      LeafSubr.StopLeaf[];      Subr.DeleteHugeZone[];      VerifyDFInterface.DoneRunning[]};    BEGIN    ENABLE UNWIND => Cleanup[];    td ¬ DFToolOps.toolData;    IF VerifyDFInterface.AlreadyRunning[] THEN {      CWF.WF0["VerifyDF already running!"L];      DFToolOps.PostMsg["VerifyDF already running!"L];      Subr.errorflg ¬ TRUE;      RETURN};    LeafSubr.StartLeaf[];    opt ¬ [      checkForOverwrite: TRUE, printFlattened: FALSE, checkIfFilesNeeded: TRUE,      useHugeZone: TRUE, fileForMissingEntries: FALSE,      retrieveDFsToTemp: td.switch[retrieveDFsToTemp], verbose: TRUE,      debugging: Profile.debugging];    StartParsingNames[td.inputDfFilesCopy];    name ¬ GetName[];    WHILE ~String.Empty[name] DO      Subr.errorflg ¬ FALSE;      dfName ¬ String.CopyToNewString[s: name, z: td.dfZone, longer: 3];      [] ¬ String.AppendExtensionIfNeeded[        to: @dfName, extension: ".df"L, z: td.dfZone];      -- HugeZone now used for dfSeq in VerifyBcds      [] ¬ Subr.HugeZone[        nPages: ZonePages, zonePrefix: "VerifyDF"L !        MFile.Error =>          IF code = noRoomOnVolume THEN {            CWF.WF1["Error - insufficient disk space to verify %s.\n"L, dfName];            GOTO error}];      VerifyDFInterface.VerifyDFFile[        dfFileName: dfName, exec: NIL, window: td.ttySW, opt: opt,        abortProc: LOOPHOLE[DFToolOps.IsAborted] !        DFSubr.TooManyEntries => {          CWF.WF1["Error - too many entries in %s.\n"L, dfName];          Subr.errorflg ¬ TRUE;          CONTINUE};        Heap.Error => {          CWF.WF1["Error - heap overflow while verifing %s.\n"L, dfName];          Subr.errorflg ¬ TRUE;          CONTINUE}];      Subr.DeleteHugeZone[];      IF Subr.errorflg THEN CWF.WF1["There were errors in %s.\n"L, dfName]      ELSE CWF.WF1["No errors found in %s.\n"L, dfName];      String.FreeString[td.dfZone, dfName];      dfName ¬ NIL;      name ¬ FreeName[name];      name ¬ GetName[];      ENDLOOP;    EXITS error => Subr.errorflg ¬ TRUE;    END;    Cleanup[]};  -- These are here for the "old" DFtool. I do not plan to make the new DFtool support it. It makes the BCD large, and will be used infrequently.  -- Throw these away when the old DFtool is decommissioned.    DFSubstitute: PUBLIC DFToolOps.CmdProc = {    td ¬ DFToolOps.toolData;    CWF.WF0["DFTool DFSubstitute is not yet implemented!\nAn Exec version is available.\n"L];    DFToolOps.PostMsg["DFTool DFSubstitute is not yet implemented!\nAn Exec version is available.\n"L]};  DFDisk: PUBLIC DFToolOps.CmdProc = {    td ¬ DFToolOps.toolData;    CWF.WF0["DFTool DFDisk is not yet implemented!\nAn Exec version is available.\n"L];    DFToolOps.PostMsg["DFTool DFDisk is not yet implemented!\nAn Exec version is available.\n"L]};  DFDelete: PUBLIC DFToolOps.CmdProc = {    name, dfName: LONG STRING ¬ NIL;    opt: DFDeleteInterface.Options;    temp: MFile.Handle ¬ NIL;    lineDotCm: MStream.Handle ¬ NIL;  -- for echoing Line.cm    Cleanup: PROC = {      IF name # NIL THEN {name ¬ FreeName[name]; name ¬ NIL};      DoneParsingNames[];      IF dfName # NIL THEN {String.FreeString[td.dfZone, dfName]; dfName ¬ NIL};      IF lineDotCm # NIL THEN {Stream.Delete[lineDotCm]; lineDotCm ¬ NIL};      DFDeleteInterface.Finalize[];      DFDeleteInterface.DoneRunning[]};    BEGIN    ENABLE UNWIND => Cleanup[];    td ¬ DFToolOps.toolData;    IF DFDeleteInterface.AlreadyRunning[] THEN {      CWF.WF0["DFDelete already running!"L];      DFToolOps.PostMsg["DFDelete already running!"L];      Subr.errorflg ¬ TRUE;      RETURN};    opt ¬ [      alsoDeleteReadOnly: td.switch[alsoDeleteReadOnly],      debugging: Profile.debugging];    DFDeleteInterface.Initialize[];    -- delete old Line.cm file    temp ¬ MFile.Acquire[      name: "Line.cm"L, access: delete, release: [] ! MFile.Error => CONTINUE];    IF temp # NIL THEN {MFile.Delete[temp ! MFile.Error => CONTINUE]; temp ¬ NIL};    StartParsingNames[td.inputDfFilesCopy];    name ¬ GetName[];    WHILE ~String.Empty[name] DO      dfName ¬ String.CopyToNewString[s: name, z: td.dfZone, longer: 3];      [] ¬ String.AppendExtensionIfNeeded[        to: @dfName, extension: ".df"L, z: td.dfZone];      DFDeleteInterface.DeleteDF[        dfFileName: dfName, opt: opt, exec: NIL, window: td.ttySW,        abortProc: LOOPHOLE[DFToolOps.IsAborted] !        DFSubr.TooManyEntries => {          CWF.WF1["Error - too many file entries in %s.\n"L, dfName];          Subr.errorflg ¬ TRUE;          CONTINUE}];      String.FreeString[td.dfZone, dfName];      dfName ¬ NIL;      name ¬ FreeName[name];      name ¬ GetName[];      ENDLOOP;    DFDeleteInterface.Finalize[];    -- echo Line.cm, if created    lineDotCm ¬ MStream.ReadOnly["Line.cm"L, [] ! MStream.Error => GOTO noLineCm];    CWF.WF0["----------------------------------------------------------\n"L];    CWF.WF0["Contents of Line.cm:\n\n"L];    DO CWF.WFC[Stream.GetChar[lineDotCm ! Stream.EndOfStream => EXIT]]; ENDLOOP;    Stream.Delete[lineDotCm];    lineDotCm ¬ NIL;    CWF.WF0["\n-----------------------------------------------------------\n"L];    EXITS noLineCm => NULL;    END;    Cleanup[]};  -- utilities  StartParsingNames: PROC [str: LONG STRING] = {cmdLine ¬ str; cmdPtr ¬ 0};  DoneParsingNames: PROC = {cmdLine ¬ NIL; cmdPtr ¬ 0};  GetName: PROC RETURNS [name: LONG STRING] = {    GetChar: PROC [Token.Handle] RETURNS [c: CHARACTER] = {      IF cmdPtr >= cmdLine.length THEN c ¬ '\000      ELSE {c ¬ cmdLine[cmdPtr]; cmdPtr ¬ cmdPtr + 1}};    IsQuote: Token.QuoteProcType = {RETURN[IF c = '" THEN c ELSE Token.nonQuote]};    NameFilter: Token.FilterProcType = {      RETURN[inClass: c # '\000 AND ~Token.WhiteSpace[c, NIL]]};    getToken: Token.Object ¬ [getChar: GetChar, break: '\000];    IF String.Empty[cmdLine] THEN RETURN[NIL];    name ¬ Token.MaybeQuoted[@getToken, NIL, NameFilter, IsQuote]};  FreeName: PROC [name: LONG STRING] RETURNS [nil: LONG STRING] = {    RETURN[Token.FreeTokenString[name]]};  END.Change log:10-Sep-84 18:21:05	DSC  	Better messages for Checkout retrieval.13-Sep-84 11:52:47	DSC  	Fix AR #4622. Full path name is used for query, etc.  One should strip the directory information from the filename, but a problem occurs if the "remotepathname" property of the libject differs from the user specified file name. Current, I don't check the difference.13-Sep-84 17:05:10	DSC  	Went ahead and made sure that the remote name = user file name.14-Sep-84 10:28:21	DSC  	Added sanity checks in CheckOut and Query to RETURN if Librarian is not usable. This is to protect against potential clients who may call these procedures even if the librarian is not available. Also made the warning about the remotename not equal to the user's full path name IGNORE version numbers. I hope that's correct, since we don't want the user to query about an old libject. 7-Nov-84 16:11:41	DSC  	Fixed bug where VFN was not set to NIL when freed. Also, I called CleanUp[] in DoQuery instead of CleanUpDoQuery[], which somehow set the DFLibrarian.libPrefix to garbage.27-Nov-84 14:19:35	DSC  	Made the opts set for bringOver and Smodel be backwards compatible with the two interfaces. You see, the old interface has only flag for the prerelese mode, wherewas the new one has two, one from bringover and one more smodel. I OR'ed the generalFlags with the specific one to allow both to be used. they are initialized to FALSE, and also since they are not both in use (i.e. you either use the td[preRelese] or you don't. it should be ok.27-Nov-84 15:45:08	DSC  	Added librarian protocols.30-Nov-84 11:39:38	DSC  	Made Usable take protocol param since people may switch often.21-Jan-85 12:16:43	DSC  	Took out pup protocol stuff. 6-Mar-85 15:48:02	DSC  	New QueryLibject. 
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- VerifyDFExecImpl.mesa - Last edited by--   BTL  	20-Dec-83 11:26:37--   DSC  	 4-Nov-84 16:15:13DIRECTORY  CWF USING [WF0, WF1, WFError],  DFSubr USING [TooManyEntries],  Event USING [DoneWithProcess, Handle, StartingProcess],  Exec USING [    AddCommand, CheckAbortProc, CheckForAbort, ExecProc, FreeTokenString,    GetToken, Handle, Outcome, OutputProc, RemoveCommand],  FileName USING [Error],  FileTransfer USING [CodeToString, Error],  Format USING[StringProc],  Heap USING [Error],  LeafSubr USING [StartLeaf, StopLeaf],  MFile USING [AppendErrorMessage, Error, maxNameLength],  MSegment USING [Error],  MStream USING [Error],  String USING [AppendString, Empty],  Subr USING [    AppendMSegmentErrorMessage, AppendMStreamErrorMessage, debugflg,    DeleteHugeZone, errorflg, HugeZone, PrintGreeting,    SetUpCWFWriteProcedure, SubrInit, SubrStop],  Time USING [Current, Packed],  Transfer USING [Finalize, Initialize],  VerifyDFInterface USING [    AlreadyRunning, CheckAbortProc, DefaultOptions, DoneRunning, Options,    VerifyDFFile],  Volume USING [InsufficientSpace];VerifyDFExecImpl: MONITOR    IMPORTS      CWF, DFSubr, Event, Exec, FileName, FileTransfer, Heap, LeafSubr,      MFile, MSegment, MStream, String, Subr, Time, Transfer,      VerifyDFInterface, Volume =  BEGIN  ZonePages: CARDINAL = 350;    DoVerify: Exec.ExecProc = {    startTime, elapsedTime: Time.Packed;    exec: Exec.Handle ¬ h;    myEventHandle: Event.Handle ¬ NIL;          Cleanup: PROC = {      Transfer.Finalize[];  LeafSubr.StopLeaf[];      Subr.DeleteHugeZone[];  Subr.SubrStop[];      Event.DoneWithProcess[myEventHandle];  myEventHandle ¬ NIL;      VerifyDFInterface.DoneRunning[]};    BEGIN      ENABLE {	UNWIND => Cleanup[];        FileTransfer.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [60];	    FileTransfer.CodeToString[code, msg];	    CWF.WF1["\n...FileTransfer error: %s\n"L, msg];	    GOTO error};        ABORTED => {CWF.WF0["\n...VerifyDF aborted.\n"L];  GOTO abort};	Volume.InsufficientSpace => {	  CWF.WF0["\n...Volume full.\n"L];  GOTO error};	CWF.WFError => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    CWF.WF1["\nCWF error: %s.\n"L, err];	    GOTO error};	FileName.Error =>	  IF Subr.debugflg THEN REJECT	  ELSE {CWF.WF0["\n...FileName error.\n"L];  GOTO error};	MFile.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];	    CWF.WF1["MFile error: %s\n"L, msg];   	    GOTO error};        MStream.Error =>  	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMStreamErrorMessage[msg, code, stream];	    CWF.WF1["MStream error: %s.\n"L, msg];   	    GOTO error};	MSegment.Error =>   	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMSegmentErrorMessage[msg, code, segment];	    CWF.WF1["MSegment error: %s.\n"L, msg];   	    GOTO error}};	    IF VerifyDFInterface.AlreadyRunning[] THEN {       Exec.OutputProc[h][" VerifyDF already running!"L];      RETURN[abort]};    startTime ¬ Time.Current[];    Subr.SetUpCWFWriteProcedure[];  Subr.SubrInit[exec];    Subr.PrintGreeting["VerifyDF"L];    myEventHandle ¬ Event.StartingProcess["VerifyDF"L];    Transfer.Initialize[exec: exec, window: NIL];  -- use exec window for i/o    LeafSubr.StartLeaf[];    IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    outcome ¬ VerifyDFFiles[exec];    EXITS      error => {Subr.errorflg ¬ TRUE;  outcome ¬ error};      abort => outcome ¬ abort;    END;    elapsedTime ¬ [Time.Current[] - startTime];    CWF.WF1["\nTotal elapsed time for VerifyDF %lr.\n"L, @elapsedTime];    Cleanup[]};      VerifyDFFiles: PROC [exec: Exec.Handle] RETURNS [outcome: Exec.Outcome] = {    globalOpt, opt: VerifyDFInterface.Options ¬ VerifyDFInterface.DefaultOptions;    name, sw: LONG STRING ¬ NIL;    dfFileName: STRING ¬ [MFile.maxNameLength];        CheckAbortInExec: VerifyDFInterface.CheckAbortProc = {      RETURN[Exec.CheckForAbort[exec]]};    BEGIN    outcome ¬ normal;    [name, sw] ¬ Exec.GetToken[exec];    WHILE ~String.Empty[name] OR ~String.Empty[sw] DO      IF String.Empty[name] AND ~String.Empty[sw] THEN {  -- global switches        SetSwitches[@globalOpt, sw];	name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];        [name, sw] ¬ Exec.GetToken[exec];	LOOP};      opt ¬ globalOpt;      IF ~String.Empty[sw] THEN SetSwitches[@opt, sw];      IF ~String.Empty[name] THEN {        dfFileName.length ¬ 0;  String.AppendString[dfFileName, name];        Subr.debugflg ¬ opt.debugging;  Subr.errorflg ¬ FALSE;        [] ¬ Subr.HugeZone[nPages: ZonePages, zonePrefix: "VerifyDF"L	  ! MFile.Error =>	      IF code = noRoomOnVolume THEN {	        CWF.WF1[		  "Error - insufficient disk space to verify %s.\n"L, dfFileName];	        GOTO error}];        VerifyDFInterface.VerifyDFFile[          dfFileName: dfFileName, exec: exec, window: NIL,          opt: opt, abortProc: CheckAbortInExec           ! DFSubr.TooManyEntries => {              CWF.WF1["Error - too many entries in %s.\n"L, dfFileName];              Subr.errorflg ¬ TRUE;  CONTINUE};	    Heap.Error => {              CWF.WF1["Error - heap overflow while verifying %s.\n"L, dfFileName];              Subr.errorflg ¬ TRUE;  CONTINUE}];	Subr.DeleteHugeZone[];        IF Subr.errorflg THEN {	  CWF.WF1["There were errors in %s.\n"L, dfFileName];  outcome ¬ error}        ELSE CWF.WF1["No errors found in %s.\n"L, dfFileName]};      name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];      [name, sw] ¬ Exec.GetToken[exec];      ENDLOOP;    EXITS      error => Subr.errorflg ¬ TRUE;    END;    IF Subr.errorflg THEN outcome ¬ error};      SetSwitches: PROC [      opt: POINTER TO VerifyDFInterface.Options, sw: LONG STRING] = {    sense: BOOLEAN ¬ TRUE;    FOR i: CARDINAL IN [0..sw.length) DO      SELECT sw[i] FROM        'f, 'F => {opt.printFlattened     ¬ sense;  sense ¬ TRUE};         'n, 'N => {opt.checkIfFilesNeeded ¬ sense;  sense ¬ TRUE};        't, 'T => {opt.retrieveDFsToTemp  ¬ sense;  sense ¬ TRUE};        'v, 'V => {opt.verbose		  ¬ sense;  sense ¬ TRUE};        'd, 'D => {opt.debugging          ¬ sense;  sense ¬ TRUE};	'-, '~ => sense ¬ ~sense;        ENDCASE => {	  CWF.WF1["Unknown switch in '%s'\n"L, sw];  Subr.errorflg ¬ TRUE}      ENDLOOP};        Init: PROC = {Exec.AddCommand[name:  "VerifyDF.~"L, proc: DoVerify, help:  Help,  unload:  Unload]};  Unload: Exec.ExecProc = {  []  ¬  h.RemoveCommand["VerifyDF.~"L];  };    Help: Exec.ExecProc = {    OutputProc: Format.StringProc _ Exec.OutputProc[h];    h.OutputProc[][ "VerifyDF[/<global switches>] DFfile1[/<local switches>]....DFfilen[/<local switches>] Global switches are optional and control the retrieval of subsequent DFs. You can also set global switches by giving an empty DF file name. A switch specification is a letter identifying the switch, optionally preceeded by a '-' or a '~' to reverse the sense of the switch. Switches recognized by VerifyDF are:   f=print Flattened DF file (all Imports and Includes structure removed).   n=check that all files seem Necessary (default)   t=retrieve DF to Temporary files (default)."L];  };  Init[];    END.Change log:  4-Nov-84 16:15:25	DSC  	Added Unload and Help procs. 
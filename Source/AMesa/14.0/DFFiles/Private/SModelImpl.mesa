-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- SModelImpl.mesa - last edited by:--   Schmidt	 9-Mar-82 16:55:40--   BTL  	16-Nov-83 14:46:30--   NSG        19-Jul-84 16:22:13  --   DSC         6-May-85 16:42:21 DIRECTORY  CWF USING [SWF1, SWF3, SWF4, WF0, WF1, WF2, WF3],  DFLibrarian,  DFSubr USING [    AllocateDFSeq, DF, DFSeq, FreeDFSeq, LookupDF, LookupFiles,    NextDF, ParseStream, TooManyParseErrors, WriteOut],  FileName USING [Error, SetRemoteName],  FileTransfer USING [CodeToString, DesiredProperties, Error, FileInfo, ListProc],  MFile USING [    Acquire, AppendErrorMessage, Error, GetCreateDate, maxNameLength,    Release, SetAccess, SetTimes],  MStream USING [Create, Error, Handle, WriteOnly],  Profile,  SModelInterface USING [CheckAbortProc, Options],  Stream USING [Delete],  String,  Subr USING [    Confirm, CopyFile, CopyString, debugflg, EndsIn,    errorflg, FileError, FreeString, integrationDir, integrationHost, Prefix,    workingDFDir, workingDFHost],  Time USING [Current, Packed],  Transfer USING [EnumerateForProperties, SetProps, SetDefaultProcs, Store],  Window USING [Handle];SModelImpl: MONITOR    IMPORTS      CWF, DFSubr, DFLibrarian, FileName, FileTransfer, MFile, MStream,      Profile, Transfer, Stream, String, Subr, Time    EXPORTS SModelInterface =  BEGIN  MaxFiles: CARDINAL = 450;    nowRunning: BOOLEAN ¬ FALSE;  checkAbort: SModelInterface.CheckAbortProc;  preReleaseProblems: BOOLEAN ¬ FALSE;   -- SModel serialization   AlreadyRunning: PUBLIC ENTRY PROC RETURNS [yes: BOOLEAN] = {    IF nowRunning THEN RETURN[TRUE];    nowRunning ¬ TRUE;    RETURN[FALSE]};    DoneRunning: PUBLIC ENTRY PROC = {nowRunning ¬ FALSE}; -- Main SModel procedure  StoreDF: PUBLIC PROC [dfFileName: LONG STRING, opt: SModelInterface.Options,      dfZone: UNCOUNTED ZONE, window: Window.Handle,      abortProc: SModelInterface.CheckAbortProc] = {    dfSeq: DFSubr.DFSeq ¬ NIL;    nStored: CARDINAL;    Cleanup: PROC = {      Transfer.SetDefaultProcs[];      DFSubr.FreeDFSeq[@dfSeq];      IF opt.checkLibrarian AND DFLibrarian.Usable[] THEN DFLibrarian.Finalize[opt.libHandle]};    BEGIN ENABLE UNWIND => Cleanup[];    IF BadOptions[opt] THEN RETURN;    [] ¬ String.AppendExtensionIfNeeded[      to: @dfFileName, extension: ".df"L, z: dfZone];    IF BadDFFileName[dfFileName] THEN RETURN;    checkAbort ¬ abortProc;    Subr.debugflg ¬ opt.debugging;    preReleaseProblems ¬ FALSE;    -- since we don't use the fileInfo's size in Smodel, set it to something plain.    SetPlainProps[];    IF opt.preRelease THEN {CheckPreReleaseParameters[];  opt.verify ¬ TRUE};    --Previosuly, we checked what Subr.checklibrarian used, but that doesn't    -- make sense if the user wants to over ride that. Let the    -- caller of the proc decide what to put in the options.     opt.checkLibrarian ¬ opt.checkLibrarian AND DFLibrarian.Usable[];    IF opt.checkLibrarian  THEN {       InitLibrarian[dfZone: dfZone, h: opt.libHandle]};    -- build fake entry     dfSeq ¬ BuildFakeDFSeq[dfFileName];    DFSubr.LookupFiles[dfSeq];  -- get file handle for top level df file    IF ~dfSeq[0].presentonlocaldisk THEN {      CWF.WF1["Error - can't open %s.\n"L, dfFileName];      Subr.errorflg ¬ TRUE;      nStored ¬ 0}    ELSE       [nStored: nStored] ¬ RecursiveStore[        dfSeqOuter: dfSeq, topDfOuter: NIL, opt: opt, window: window];    IF ~opt.dontStoreFiles THEN      IF nStored > 0 THEN CWF.WF1["%u files stored.\n"L, @nStored]      ELSE CWF.WF0["No files stored.\n"L];    IF opt.preRelease AND preReleaseProblems THEN      CWF.WF0["Warning - SModel PreRelease mode and problems were found.\n"L];    Cleanup[];    END};      BadOptions: PROC [opt: SModelInterface.Options] RETURNS [bad: BOOLEAN] = {    IF opt.preRelease AND opt.dontStoreFiles THEN {      CWF.WF0["The /z and /n options cannot be used together.\n"L];      CWF.WF0["  Run SModel again with one or the other but not both.\n"L];      RETURN[TRUE]};    RETURN[FALSE]};      LocalFileName: PROCEDURE [filename: LONG STRING] RETURNS[yes: BOOLEAN] = {    IF filename = NIL THEN ERROR;    yes ¬ filename[0] = '[;  };    BadDFFileName: PROC [dfFileName: LONG STRING] RETURNS [bad: BOOLEAN] = {    IF dfFileName = NIL THEN ERROR;    IF ~Subr.EndsIn[dfFileName, ".df"L] THEN {      CWF.WF1["Error - %s must be a DF file name.\n"L, dfFileName];      Subr.errorflg ¬ TRUE;      RETURN[TRUE]};    IF LocalFileName[dfFileName] THEN {      CWF.WF1["Error - %s must be a local file.\n"L, dfFileName];      Subr.errorflg ¬ TRUE;      RETURN[TRUE]};    RETURN[FALSE]};       CheckPreReleaseParameters: PROC = {    CWF.WF0["SModel PreRelease mode.\n\n"L];    IF String.Empty[Subr.workingDFHost]    OR String.Empty[Subr.workingDFDir] THEN {      CWF.WF0["Error - SModel PreRelease mode but no WorkingDFLoc given in User.cm [DFTool] section\n"L];      ERROR ABORTED};    IF String.Empty[Subr.integrationHost]    OR String.Empty[Subr.integrationDir] THEN {      CWF.WF0["Error - SModel PreRelease mode but no IntegrationLoc given in User.cm [DFTool] section.\n"L];      ERROR ABORTED}};        GetServer:  PROCEDURE[zone: UNCOUNTED ZONE] RETURNS [db: LONG STRING] = {    StuffString: PROCEDURE [str: Profile.String] = {      db ¬ String.CopyToNewString[s: str, z: zone]};    Profile.GetLibrarian[StuffString]};    InitLibrarian: PROC [dfZone: UNCOUNTED ZONE, h: DFLibrarian.Handle] = {    IF ~DFLibrarian.Initialize[h: h, servername: h.servername, zone: dfZone] THEN {      CWF.WF0["\nInvalid Librarian profile entries.\n"L];      ERROR ABORTED}};      BuildFakeDFSeq: PROC [shortname: LONG STRING] RETURNS [dfSeq: DFSubr.DFSeq] = {    df: DFSubr.DF;    dfSeq ¬ DFSubr.AllocateDFSeq[maxEntries: 1, zoneType: shared];    df ¬ DFSubr.NextDF[dfSeq];    df.shortname ¬ Subr.CopyString[shortname, dfSeq.dfzone];    df.atsign ¬ TRUE};     -- dfSeqOuter is allocated and filled with its contents  -- topDfOuter points to the entry in the outer df that indirects thru this DF  -- topDfOuter may be NIL  RecursiveStore: PROC [      dfSeqOuter: DFSubr.DFSeq, topDfOuter: DFSubr.DF,      opt: SModelInterface.Options, window: Window.Handle]    RETURNS [      outOfSpace: BOOLEAN, nStored: CARDINAL,      dfFileMustBeStored, alreadyIntegrationLoc: BOOLEAN] = {    dfOuter: DFSubr.DF;    n: CARDINAL;    o, d, p, xferred: BOOLEAN;    flipped: BOOLEAN ¬ FALSE;    nStored ¬ 0;    outOfSpace ¬ dfFileMustBeStored ¬ FALSE;    alreadyIntegrationLoc ¬ TRUE;    CheckThatAllFilesLocal[dfSeqOuter, opt.preRelease];    CheckForStrangeNestedDFFiles[dfSeqOuter, topDfOuter];    p ¬ FALSE;    FOR i: CARDINAL IN [0..dfSeqOuter.size) DO      dfOuter ¬ @dfSeqOuter[i];      IF dfOuter.cameFrom AND opt.flipCameFrom THEN        flipped ¬ ChangeCameFromToReleaseAs[dfOuter, dfSeqOuter] OR flipped;      IF opt.preRelease THEN        p ¬ ChangeToIntegrationLoc[dfOuter, dfSeqOuter];      alreadyIntegrationLoc ¬ alreadyIntegrationLoc AND p;      IF dfOuter.presentonlocaldisk AND dfOuter.atsign AND ~dfOuter.readonly      AND Subr.EndsIn[dfOuter.shortname, ".df"L]      AND (~opt.topLevelOnly OR topDfOuter = NIL) THEN {        IF topDfOuter = NIL THEN CWF.WF1["SModel of %s.\n"L, dfOuter.shortname]	ELSE CWF.WF1["\nNested SModel of %s.\n"L, dfOuter.shortname];            [outOfSpace: o, nStored: n, dfFileMustBeStored: d] ¬ StoreIncludedDFFile[	  dfOuter, topDfOuter, opt, window];        IF topDfOuter = NIL THEN	  CWF.WF1["End of SModel of %s.\n\n"L, dfOuter.shortname]	ELSE CWF.WF1["End of nested SModel of %s.\n"L, dfOuter.shortname];	outOfSpace ¬ outOfSpace OR o;	nStored ¬ nStored + n;	dfFileMustBeStored ¬ dfFileMustBeStored OR d;	LOOP};       IF topDfOuter = NIL THEN EXIT;  -- skip next test if is top level DF      -- this is either a regular file, an Imported DF file, or a       -- Included DF file that we did not store in the above nested section      [dfFileShouldBeStored: d, xferred: xferred] ¬ PossibleTransfer[        df: dfOuter, dfseq: dfSeqOuter, opt: opt, sdffile: topDfOuter.shortname,	window: window];      dfFileMustBeStored ¬ dfFileMustBeStored OR d;      IF xferred THEN nStored ¬ nStored + 1;      IF outOfSpace THEN EXIT;      ENDLOOP;    IF flipped THEN {      CWF.WF0["\nSome CameFroms were changed to ReleaseAs or deleted.\n"L];      dfFileMustBeStored ¬ TRUE}};        CheckThatAllFilesLocal: PROC [      dfSeqOuter: DFSubr.DFSeq, preRelease: BOOLEAN] = {    legendPrinted: BOOLEAN ¬ FALSE;    dfOuter: DFSubr.DF;    FOR i: CARDINAL IN [0..dfSeqOuter.size) DO      dfOuter ¬ @dfSeqOuter[i];      IF ~dfOuter.presentonlocaldisk THEN {        IF ~legendPrinted THEN {	  CWF.WF1[	      "Warning - the following files are not local or cannot be opened for reading:\n\t%s"L,	    dfOuter.shortname];	  legendPrinted ¬ TRUE;	  IF preRelease THEN preReleaseProblems ¬ TRUE}	ELSE CWF.WF1["  %s"L, dfOuter.shortname]};      ENDLOOP;    IF legendPrinted THEN CWF.WF0[".\n\n"L]};      CheckForStrangeNestedDFFiles: PROC [dfSeqOuter: DFSubr.DFSeq, topDfOuter: DFSubr.DF] = {    legendPrinted: BOOLEAN ¬ FALSE;    dfOuter: DFSubr.DF;    -- check for DF files not Imported or Included in containing DF file    FOR i: CARDINAL IN [0..dfSeqOuter.size) DO      dfOuter ¬ @dfSeqOuter[i];      IF ~dfOuter.readonly AND ~dfOuter.atsign      AND Subr.EndsIn[dfOuter.shortname, ".DF"L]      AND ~String.Equivalent[dfOuter.shortname, topDfOuter.shortname] THEN {        IF ~legendPrinted THEN {	  CWF.WF2[	    "Warning - these DF files are not Imported or Included in %s:\n\t%s"L,	    topDfOuter.shortname, dfOuter.shortname];	  legendPrinted ¬ TRUE}	ELSE CWF.WF1["  %s"L, dfOuter.shortname]};      ENDLOOP;    IF legendPrinted THEN CWF.WF0[".\n\n"L]};      StoreIncludedDFFile: PROC [      dfOuter, topDfOuter: DFSubr.DF,      opt: SModelInterface.Options, window: Window.Handle]    RETURNS [      outOfSpace: BOOLEAN, nStored: CARDINAL, dfFileMustBeStored: BOOLEAN] = {     dfSeqInner: DFSubr.DFSeq ¬ NIL;    o, d, innerAlreadyIntegrationLoc, actuallyStored: BOOLEAN;    n: CARDINAL;    BEGIN ENABLE UNWIND => IF dfSeqInner # NIL THEN DFSubr.FreeDFSeq[@dfSeqInner];    outOfSpace ¬ FALSE;  nStored ¬ 0;  dfFileMustBeStored ¬ FALSE;    IF checkAbort[] THEN ERROR ABORTED;    dfSeqInner ¬ ParseDFFileToDFSeq[dfOuter      ! MFile.Error => {          msg: STRING ¬ [100];	  MFile.AppendErrorMessage[msg, code, file];	  CWF.WF1["\nMFile error: %s.\n"L, msg];	  GOTO err};        MStream.Error => {	  CWF.WF1["Error - can't open %s.\n"L, dfOuter.shortname];          GOTO err}];    [outOfSpace: o, nStored: n, dfFileMustBeStored: d,     alreadyIntegrationLoc: innerAlreadyIntegrationLoc] ¬ RecursiveStore[       dfSeqOuter: dfSeqInner, topDfOuter: dfOuter, opt: opt, window: window];    outOfSpace ¬ outOfSpace OR o;    -- if inner DF file changed, outer DF must be stored (but only if not # or >)    dfFileMustBeStored ¬ (dfFileMustBeStored OR (d AND dfOuter.criterion = none));    nStored ¬ nStored + n;    IF checkAbort[] THEN ERROR ABORTED;    IF d OR n > 0 THEN       BEGIN  -- store the DF file (dfOuter) itself      newDFFileName: STRING ¬ [MFile.maxNameLength];      dfInner: DFSubr.DF;      dfOuter.version ¬ 0;  dfOuter.createtime ¬ Time.Current[];      IF opt.preRelease AND ~innerAlreadyIntegrationLoc THEN         String.AppendString[newDFFileName, "SModel.PreReleaseTemp$$"L]      ELSE {        MakeBackupFile[dfOuter.shortname];        String.AppendString[newDFFileName, dfOuter.shortname]};      -- get the entry for the DF file itself in the DF file      dfInner ¬ DFSubr.LookupDF[dfSeqInner, dfOuter.shortname];      IF dfInner # NIL THEN {        dfInner.createtime ¬ dfOuter.createtime;  dfInner.version ¬ 0;        IF dfInner.fHandle # NIL THEN MFile.Release[dfInner.fHandle];	dfInner.fHandle ¬ NIL};      -- write out new DF file with correct self reference      IF dfOuter.fHandle # NIL THEN MFile.Release[dfOuter.fHandle];      dfOuter.fHandle ¬ NIL;      WriteOutNewDFFile[dfSeqInner, newDFFileName];      IF ~opt.preRelease OR innerAlreadyIntegrationLoc THEN         CWF.WF1["New DF file written on %s.\n"L, newDFFileName];      dfOuter.fHandle ¬ MFile.Acquire[        name: newDFFileName, access: anchor, release: []];      IF dfInner # NIL THEN        dfInner.fHandle ¬ MFile.Acquire[	  name: newDFFileName, access: anchor, release: []];      IF ~opt.dontStoreFiles AND ~(dfOuter.readonly AND ~opt.ignoreReadOnly)      AND ~outOfSpace THEN         BEGIN  -- store DF file remotely (SModel.PreReleaseTemp$$ if PreRelease)        -- set time off by -1 since file might not be stored        MFile.SetTimes[file: dfOuter.fHandle, create: [dfOuter.createtime-1]];        actuallyStored ¬ TRUE;        IF dfOuter.directory # NIL THEN {  -- use dfOuter info          IF dfInner # NIL THEN {            Subr.FreeString[dfInner.host, dfSeqInner.dfzone];            dfInner.host ¬ Subr.CopyString[dfOuter.host, dfSeqInner.dfzone];            Subr.FreeString[dfInner.directory, dfSeqInner.dfzone];            dfInner.directory ¬ Subr.CopyString[	      dfOuter.directory, dfSeqInner.dfzone]};	  actuallyStored ¬ StoreNewDFFile[dfOuter, opt, window];          IF actuallyStored THEN nStored ¬ nStored + 1}        ELSE IF dfInner # NIL THEN {  -- have to use dfInner info	  actuallyStored ¬ StoreNewDFFile[dfInner, opt, window];          IF actuallyStored THEN nStored ¬ nStored + 1};        IF actuallyStored THEN           MFile.SetTimes[file: dfOuter.fHandle, create: dfOuter.createtime];        END;  -- actually store DF file      PrintAnyStoreWarnings[dfOuter, opt];      -- reset outer DF entry if it was > or #      IF dfOuter.criterion # none THEN dfOuter.createtime ¬ Time.Packed[0];      -- if preRelease, release handle on SModel.IntegrationTemp$$      IF opt.preRelease AND ~innerAlreadyIntegrationLoc THEN {        IF dfOuter.fHandle # NIL THEN MFile.Release[dfOuter.fHandle];        dfOuter.fHandle ¬ MFile.Acquire[	  name: dfOuter.shortname, access: anchor, release: []]};      END  -- store the DF file (dfOuter) itself    ELSE -- not storing DF file      IF ~opt.dontStoreFiles THEN        CWF.WF1["No files stored, %s not changed.\n"L, dfOuter.shortname];    DFSubr.FreeDFSeq[@dfSeqInner];    EXITS      err => Subr.errorflg ¬ TRUE;    END};      ParseDFFileToDFSeq: PROC [df: DFSubr.DF] RETURNS [dfSeq: DFSubr.DFSeq] = {    sh: MStream.Handle ¬ NIL;        CleanUp: PROC = {      IF sh # NIL THEN {        Stream.Delete[sh];  sh ¬ NIL;	df.fHandle ¬ NIL;  df.presentonlocaldisk ¬ FALSE}};    BEGIN ENABLE UNWIND => CleanUp[];    dfSeq ¬ DFSubr.AllocateDFSeq[maxEntries: MaxFiles, zoneType: shared];    MFile.SetAccess[df.fHandle, readOnly];    sh ¬ MStream.Create[file: df.fHandle, release: []];    DFSubr.ParseStream[      sh: sh, dfseq: dfSeq, dffilename: df.shortname, using: df.using,      noremoteerrors: FALSE, forceReadonly: FALSE, omitNonPublic: FALSE,      limitErrors: TRUE      ! DFSubr.TooManyParseErrors => {          CWF.WF1[" - parse abandoned, too many errors in %s.\n"L, df.shortname];	  GOTO leave}];    Stream.Delete[sh];  sh ¬ NIL;    df.fHandle ¬ NIL;  df.presentonlocaldisk ¬ FALSE;    IF checkAbort[] THEN ERROR ABORTED;    DFSubr.LookupFiles[dfSeq];    EXITS leave => NULL;    END;    CleanUp[]};      MakeBackupFile: PROC [dfName: LONG STRING] = {    backup: STRING ¬ [MFile.maxNameLength];    CWF.SWF1[backup, "%s$"L, dfName];    Subr.CopyFile[from: dfName, to: backup      ! MFile.Error => {          msg: STRING ¬ [100];	  MFile.AppendErrorMessage[msg, code, file];	  CWF.WF1["\nMFile error on creating backup file: %s.\n"L, msg];    	  Subr.errorflg ¬ TRUE;  CONTINUE}]};	    WriteOutNewDFFile: PROC [dfseq: DFSubr.DFSeq, fileName: LONG STRING] = {    sh: MStream.Handle ¬ NIL;    BEGIN ENABLE UNWIND => IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL};    sh ¬ MStream.WriteOnly[name: fileName, release: [], type: text      ! MStream.Error => {          CWF.WF1["\nUnable to create new file on %s.\n"L, fileName];          ERROR ABORTED}];    DFSubr.WriteOut[      dfseq: dfseq, topLevelFile: NIL, outputStream: sh, print: FALSE];    Stream.Delete[sh];  sh ¬ NIL;    END};      StoreNewDFFile: PROC [        df: DFSubr.DF, opt: SModelInterface.Options, window: Window.Handle]      RETURNS [stored: BOOLEAN] = {    [stored: stored] ¬ StoreBack[      df: df, localDate: df.createtime, opt: opt, window: window       ! FileTransfer.Error =>          SELECT code FROM    	    skipOperation, cantModify => {    	      s: STRING ¬ [100];    	      FileTransfer.CodeToString[code, s];              CWF.WF1["\nFileTransfer Error: %s\n"L, s];    	      Subr.errorflg ¬ TRUE;  GOTO xferProblem};    	    ENDCASE => REJECT];     EXITS xferProblem => NULL};      PrintAnyStoreWarnings: PROC [      dfOuter: DFSubr.DF, opt: SModelInterface.Options] = {    IF dfOuter.directory # NIL    AND (dfOuter.readonly AND ~opt.ignoreReadOnly) THEN {      CWF.WF1["Warning - you MUST store %s yourself\n"L, dfOuter.shortname];      CWF.WF0["\tsince it was ReadOnly and was not stored.\n"L]};    IF opt.dontStoreFiles THEN {      CWF.WF1["Warning - you MUST store %s yourself\n"L, dfOuter.shortname];      CWF.WF0["\tsince SModel /n did not store it for you.\n"L]}};   ChangeCameFromToReleaseAs: PROC [      df: DFSubr.DF, dfseq: DFSubr.DFSeq] RETURNS [changed: BOOLEAN] = {    changed ¬ FALSE;    IF df.cameFrom AND ~String.Empty[df.releaseHost]    AND ~String.Empty[df.releaseDirectory] THEN {      IF df.atsign AND df.readonly THEN {  -- eliminate CameFrom on an Imports      	Subr.FreeString[df.releaseHost, dfseq.dfzone];      	Subr.FreeString[df.releaseDirectory, dfseq.dfzone];      	df.releaseHost ¬ df.releaseDirectory ¬ NIL;	df.cameFrom ¬ FALSE;	RETURN[TRUE]};      IF ~String.Equivalent[df.host, df.releaseHost]      OR ~String.Equivalent[df.directory, df.releaseDirectory] THEN {        -- flip Directory and CameFrom      	t: LONG STRING;	t ¬ df.releaseHost;  df.releaseHost ¬ df.host;  df.host ¬ t;      	t ¬ df.releaseDirectory;  df.releaseDirectory ¬ df.directory;      	df.directory ¬ t;      	-- any version is likely to be for releaseDirectory      	IF df.createtime > 0 THEN df.version ¬ 0;	df.cameFrom ¬ FALSE;	RETURN[TRUE]}}};        ChangeToIntegrationLoc: PROC [        df: DFSubr.DF, dfseq: DFSubr.DFSeq]      RETURNS [alreadyIntegrationLoc: BOOLEAN] = {    temp: STRING ¬ [150];    i, last: CARDINAL;    alreadyIntegrationLoc ¬ FALSE;    IF df.cameFrom THEN RETURN;    IF df.atsign AND df.readonly AND Subr.EndsIn[df.shortname, ".DF"L]     AND ~String.Empty[df.host] AND ~String.Empty[df.directory] THEN {      -- Imported DF file       -- Map DF loc only if it came from the remote default DF loc      IF ~String.Empty[Subr.workingDFHost]      AND ~String.Empty[Subr.workingDFDir] THEN {        len: CARDINAL = MIN[Subr.workingDFHost.length, df.host.length];        sameHost: BOOLEAN ¬ TRUE;	LowerCase: PROC [c: CHARACTER] RETURNS [CHARACTER] = INLINE {          IF c IN ['A..'Z] THEN c ¬ c + ('a - 'A);  RETURN[c]};        IF ~String.Equivalent[df.directory, Subr.workingDFDir] THEN	  RETURN;  -- don't map: not from remote working DF loc	FOR i IN [0..len) DO	  IF df.host[i] = ': OR Subr.workingDFHost[i] = ': THEN EXIT;  -- map	  IF LowerCase[df.host[i]] # LowerCase[Subr.workingDFHost[i]] THEN	    RETURN;  -- don't map: not from remote working DF loc	  ENDLOOP};      alreadyIntegrationLoc ¬ (        String.Equivalent[df.host, Subr.integrationHost] AND	Subr.Prefix[df.directory, Subr.integrationDir]);      -- convert LHS host      Subr.FreeString[df.host, dfseq.dfzone];      df.host ¬ Subr.CopyString[Subr.integrationHost, dfseq.dfzone];      -- convert LHS directory      String.AppendString[temp, Subr.integrationDir];      String.AppendString[temp, ">DF"L];      Subr.FreeString[df.directory, dfseq.dfzone];      df.directory ¬ Subr.CopyString[temp, dfseq.dfzone];      -- change "Of >" to "Of #"      IF df.criterion = update THEN df.criterion ¬ notequal;      RETURN};    IF ~String.Empty[df.releaseHost] AND ~String.Empty[df.releaseDirectory] THEN {      -- Directory, Exports, or Included DF file      alreadyIntegrationLoc ¬ (        String.Equivalent[df.host, df.releaseHost] AND	Subr.Prefix[df.directory, Subr.integrationDir]);      -- convert LHS host      Subr.FreeString[df.host, dfseq.dfzone];      df.host ¬ Subr.CopyString[Subr.integrationHost, dfseq.dfzone];      -- convert LHS directory      String.AppendString[temp, Subr.integrationDir];      i ¬ 0;  last ¬ df.releaseDirectory.length;      WHILE i < last DO        IF df.releaseDirectory[i] = '> THEN EXIT ELSE i ¬ i+1;        ENDLOOP;      WHILE i < last DO        String.AppendChar[temp, df.releaseDirectory[i]];  i ¬ i+1;	ENDLOOP;      Subr.FreeString[df.directory, dfseq.dfzone];      df.directory ¬ Subr.CopyString[temp, dfseq.dfzone]}};			  PossibleTransfer: PROC [        df: DFSubr.DF, dfseq: DFSubr.DFSeq,	opt: SModelInterface.Options, sdffile: LONG STRING, window: Window.Handle]      RETURNS [dfFileShouldBeStored, xferred: BOOLEAN] = {    localDate: Time.Packed;    d: BOOLEAN;    BEGIN    xferred ¬ dfFileShouldBeStored ¬ FALSE;    IF opt.preRelease AND opt.checkLibrarian AND DFLibrarian.Usable[] THEN      WarnIfLibjectCheckedOut[shortname: df.shortname, opt: opt];      IF df.presentonlocaldisk AND df.criterion = none THEN {  -- might be xferred      localDate ¬ MFile.GetCreateDate[df.fHandle];      IF localDate # df.createtime THEN {        IF df.createtime = Time.Packed[0] THEN {          IF df.readonly AND ~opt.ignoreReadOnly THEN {            ReadOnlyWOCreateDate[df, localDate];            dfFileShouldBeStored ¬ TRUE} -- don't transfer it, readonly file          ELSE GOTO transferIt}        ELSE          IF df.readonly AND ~opt.ignoreReadOnly THEN	    ReadOnlyButDiffCreateDates[df]          ELSE GOTO transferIt}};    IF opt.verify THEN {  -- go and look to see if it still should be transferred      found, dfFileUpdated: BOOLEAN;      [found, dfFileUpdated] ¬ ProcessVerify[df, opt];      IF dfFileUpdated THEN dfFileShouldBeStored ¬ TRUE;      IF ~found THEN {        IF df.readonly THEN Subr.errorflg ¬ TRUE;  -- won't be able to transfer        IF df.presentonlocaldisk AND df.criterion = none THEN GOTO transferIt	ELSE VerifiedFileNotFoundError[df]}};    EXITS      transferIt =>         IF (df.readonly AND ~opt.ignoreReadOnly)  -- never xfer if readonly        OR String.Equivalent[df.shortname, sdffile] THEN {          dfFileShouldBeStored ¬ TRUE;	  df.version ¬ 0;  df.createtime ¬ localDate}        ELSE {          xferred ¬ TRUE;  -- not really true if dontStoreFiles          IF checkAbort[] THEN ERROR ABORTED;          IF ~opt.dontStoreFiles THEN {	    [dfFileShouldBeStored: d, stored: xferred] ¬ StoreBack[	      df, localDate, opt, window];	    dfFileShouldBeStored ¬ dfFileShouldBeStored OR d;	    IF xferred THEN df.createtime ¬ localDate}	  ELSE {df.version ¬ 0;  df.createtime ¬ localDate}};    END};      WarnIfLibjectCheckedOut: PROC [shortname: LONG STRING, opt: SModelInterface.Options] = {    libjectExists, librarianProblem: BOOLEAN;    -- We want to skip this if we are in a dfLibjectsOnly mode for a non .df file.    -- commented out since it's really obnoxious. if you're crazy, decomment it.    «    IF opt.dfLibjectsOnly AND NOT Subr.EndsIn[shortname, ".df"L] THEN {       CWF.WF1["Skipping librarian checking for non DF: \"%s\".\n", shortname];       RETURN;    };    »    [libjectExists, librarianProblem] ¬ DFLibrarian.LookupLibject[h: opt.libHandle, shortName: shortname];    IF libjectExists AND ~librarianProblem    AND DFLibrarian.IsLibjectCheckedOut[h: opt.libHandle, shortName: shortname] THEN {       CWF.WF1[        "Warning - PreRelease mode but libject for %s is checked out.\n"L,        shortname];      preReleaseProblems ¬ TRUE}};        ReadOnlyWOCreateDate: PROC [df: DFSubr.DF, localDate: Time.Packed] = {    CWF.WF1[      "Warning - %s is ReadOnly and has no create date in the DF file,\n"L,      df.shortname];    CWF.WF1[      "\t%lt has been filled in, but the file has not been stored.\n"L,      @localDate];    df.createtime ¬ localDate};        ReadOnlyButDiffCreateDates: PROC [df: DFSubr.DF] = {    CWF.WF1[      "Warning - %s is ReadOnly and the create dates of the file\n"L,      df.shortname];    CWF.WF0["\ton the local disk and in DF file do not agree.\n"L]};      VerifiedFileNotFoundError: PROC [df: DFSubr.DF] = {    CWF.WF1[      "Error - %s could not be found either locally or remotely.\n"L,      df.shortname];    Subr.errorflg ¬ TRUE};  StoreBack: PROC [df: DFSubr.DF, localDate: Time.Packed, opt: SModelInterface.Options,window: Window.Handle] RETURNS [dfFileShouldBeStored, stored: BOOLEAN] = {    remoteName: STRING ¬ [150];    found, olderLocal: BOOLEAN ¬ FALSE;    version: CARDINAL;    remoteDate: Time.Packed;    IF checkAbort[] THEN ERROR ABORTED;    dfFileShouldBeStored ¬ stored ¬ FALSE;    IF String.Empty[df.host] THEN {      CWF.WF1["Warning - no host given, cannot store %s on remote server.\n"L,df.shortname];      RETURN};    CWF.SWF3[remoteName, "[%s]<%s>%s!H"L, df.host, df.directory, df.shortname];    [found, version, remoteDate] ¬ CheckHighestRemoteVersion[remoteName];    remoteName.length ¬ remoteName.length - 2;  -- remove !H    IF found AND (localDate = remoteDate) THEN {       -- already there: we have better version info so rewrite DF file      df.version ¬ version;  df.createtime ¬ remoteDate;      IF opt.verify THEN CWF.WF1["Check %s...ok.\n"L, remoteName];        RETURN[dfFileShouldBeStored: TRUE, stored: FALSE]};    IF opt.preRelease AND preReleaseProblems     AND Subr.EndsIn[df.shortname, ".df"L] THEN {      CWF.WF0["\nWarning - PreRelease mode and problems were found.\n\n"L];      opt.mustConfirm ¬ TRUE};    CWF.WF1["Store %s"L, remoteName];    IF found AND (remoteDate > localDate) THEN {      CWF.WF2["\n\tThe highest remote version, !%u, has date %lt;"L, @version, @remoteDate];      CWF.WF1[" should the OLDER local file of %lt be stored"L, @localDate];      olderLocal ¬ TRUE};    IF opt.mustConfirm OR olderLocal THEN {      validResponse: BOOLEAN ¬ FALSE;      ch: CHARACTER;      UNTIL validResponse DO        ch ¬ Subr.Confirm[	  defaultChar: 'y, window: window, allowAlways: ~olderLocal];	SELECT ch FROM          'y => {CWF.WF0[" Yes..."L];  validResponse ¬ TRUE};	  'n => {CWF.WF0[" No.\n"L];   RETURN};          'q => {CWF.WF0[" Quit.\n"L]; ERROR ABORTED};	  ENDCASE => CWF.WF0[" ? (not one of y, n, a, q) - confirm"L];	ENDLOOP}    ELSE CWF.WF0["..."L];    stored ¬ StoreBits[df, remoteName, localDate, opt, window];    RETURN[dfFileShouldBeStored: FALSE, stored: stored]};	  StoreBits: PROC [        df: DFSubr.DF, remoteName: LONG STRING, 	localDate: Time.Packed, opt: SModelInterface.Options, 	window: Window.Handle]      RETURNS [stored: BOOLEAN] = {    serverFull, checkIn, goOn: BOOLEAN ¬ FALSE;    nBytes: LONG CARDINAL;    version: CARDINAL;    IF  opt.checkLibrarian AND ~opt.preRelease AND DFLibrarian.Usable[] THEN {      -- Since the only files checked out are DFs, use the special option to skip libject checking for non DFs.      IF opt.dfLibjectsOnly AND NOT Subr.EndsIn[df.shortname, ".df"L] THEN {         -- Boy..how obnoxious.         --CWF.WF1["Skipping librarian checking for non DF: \"%s\".\n", df.shortname];         goOn ¬ TRUE; checkIn ¬ FALSE}       ELSE {        [checkIn, goOn] ¬ CheckIfLibjectCanBeCheckedIn[opt.libHandle, df.shortname]      };      IF ~goOn THEN RETURN};    [stored, serverFull, nBytes, version] ¬ Transfer.Store[      file: df.fHandle, localDate: localDate, remoteName: remoteName      ! Subr.FileError => {	  SELECT error FROM	    accessConflict => CWF.WF0[" NOT stored - can't acquire file.\n"L];	    ENDCASE => CWF.WF0[" NOT stored - internal problem.\n"L];          GOTO cant}];    IF ~stored THEN {      CWF.WF0[IF serverFull THEN " NOT stored - SERVER FULL.\n"L ELSE " NOT stored.\n"L];      GOTO cant};    IF version = 0 THEN {df.version ¬ 0;  CWF.WF1["%lu bytes"L, @nBytes]}    ELSE {df.version ¬ version;  CWF.WF2["!%u, %lu bytes"L, @version, @nBytes]};    -- check in libject (if appropriate) and set remoteName property      IF version = 0 THEN       CWF.SWF3[remoteName, "[%s]<%s>%s"L, df.host, df.directory, df.shortname]    ELSE       CWF.SWF4[remoteName, "[%s]<%s>%s!%u"L, df.host, df.directory, df.shortname, @version];    IF checkIn THEN CheckLibjectBackIn[opt.libHandle, remoteName, df.shortname] ELSE CWF.WF0[".\n"L];    FileName.SetRemoteName[df.fHandle, remoteName ! FileName.Error => CONTINUE];    EXITS cant => {      df.version ¬ 0;  df.createtime ¬ Time.Packed[0];        Subr.errorflg ¬ TRUE;  RETURN}};      CheckHighestRemoteVersion: PROC [remoteName: STRING]      RETURNS [found: BOOLEAN, version: CARDINAL, remoteDate: Time.Packed] = {          ConsiderBangH: FileTransfer.ListProc = {      remoteInfo: FileTransfer.FileInfo ¬ info[conn].source;      found ¬ TRUE;      IF ~String.Empty[remoteInfo.version] THEN        version ¬ String.StringToDecimal[remoteInfo.version	  ! String.InvalidNumber => {version ¬ 0;  CONTINUE}];      remoteDate ¬ remoteInfo.create;      RETURN[do]};          found ¬ FALSE;  version ¬ 0;  remoteDate ¬ [0];    Transfer.EnumerateForProperties[remoteName, ConsiderBangH]};      CheckIfLibjectCanBeCheckedIn: PROC [h: DFLibrarian.Handle, shortname: LONG STRING] RETURNS [checkIn, goOn: BOOLEAN] = {    libjectExists, librarianProblem: BOOLEAN ¬ FALSE;    checkIn ¬ goOn ¬ TRUE;    [libjectExists, librarianProblem] ¬ DFLibrarian.LookupLibject[h: h, shortName: shortname];    -- I presume that if a libject does not exist, we just go on happily.    IF ~libjectExists THEN checkIn ¬ FALSE    ELSE {      IF librarianProblem OR ~DFLibrarian.CanLibjectBeCheckedIn[h: h, shortName: shortname] THEN {        CWF.WF0[" NOT stored.\n"L];  checkIn ¬ goOn ¬ FALSE}}};	  CheckLibjectBackIn: PROC [h: DFLibrarian.Handle, remoteName, shortname: LONG STRING] = {    IF DFLibrarian.CheckinLibject[h: h, remoteName: remoteName, libject: shortname]     THEN CWF.WF0["...libject checked in.\n"L]    ELSE CWF.WF0["...libject NOT checked in.\n"L]};        ProcessVerify: PROC [      df: DFSubr.DF, opt: SModelInterface.Options] RETURNS [found, dfFileUpdated: BOOLEAN] = {    localDate: Time.Packed;    fn: STRING ¬ [150];    oneVersionFound: BOOLEAN ¬ FALSE;    wantExplicitVersion: BOOLEAN ¬ (      df.criterion = none AND df.createtime = Time.Packed[0]);    -- only called once unless df.createtime # [0]    ConsiderOneFile: FileTransfer.ListProc = {      remoteInfo: FileTransfer.FileInfo;      version: CARDINAL ¬ 0;      date: Time.Packed;      oneVersionFound ¬ TRUE;      IF found THEN RETURN[do];      remoteInfo ¬ info[conn].source;      IF ~String.Empty[remoteInfo.version] THEN        version ¬ String.StringToDecimal[remoteInfo.version	  ! String.InvalidNumber => {version ¬ 0;  CONTINUE}];      date ¬ remoteInfo.create;      IF df.createtime # Time.Packed[0] AND df.createtime = date THEN {        -- the date in the df file agrees with date on remote server        IF df.version > 0 AND df.version # version THEN          CWF.WF3["(Warning: version !%u has date %lt, but DF file has version !%u) "L, @version, @date, @df.version];        IF df.version # version THEN {df.version ¬ version;  dfFileUpdated ¬ TRUE};        found ¬ TRUE}        ELSE        IF df.createtime = Time.Packed[0] THEN {	  -- no date in the df file - update version no. if this is > or #          IF df.version # version AND df.criterion # none THEN {	    df.version ¬ version;  dfFileUpdated ¬ TRUE};          found ¬ TRUE};      -- if there is a date in the df file, but this is not it, we keep looking      -- as a side effect add remote name property      IF df.presentonlocaldisk AND localDate = date AND ~opt.preRelease THEN {        remoteName: STRING ¬ [150];        CWF.SWF3[remoteName, "[%s]<%s>%s"L, df.host, df.directory, df.shortname];        FileName.SetRemoteName[df.fHandle, remoteName	  ! FileName.Error => CONTINUE]};      RETURN[do]};    found ¬ dfFileUpdated ¬ FALSE;    IF df.presentonlocaldisk THEN localDate ¬ MFile.GetCreateDate[df.fHandle];    CWF.SWF3[fn, "[%s]<%s>%s"L, df.host, df.directory, df.shortname];    CWF.WF1["Check %s..."L, fn];    IF checkAbort[] THEN ERROR ABORTED;    IF opt.preRelease AND ~wantExplicitVersion THEN  -- wrong version hint      df.version ¬ 0;    IF wantExplicitVersion AND df.version > 0 THEN      CWF.SWF4[        fn, "[%s]<%s>%s!%u"L, df.host, df.directory, df.shortname, @df.version]    ELSE CWF.SWF3[fn, "[%s]<%s>%s!*"L, df.host, df.directory, df.shortname];    Transfer.EnumerateForProperties[fileName: fn, enumProc: ConsiderOneFile];    IF found THEN CWF.WF0["ok"L]    ELSE IF oneVersionFound THEN CWF.WF0["version not found"L]    ELSE CWF.WF0["not found or problems"L];    IF df.createtime = Time.Packed[0] AND df.criterion # none THEN {      df.version ¬ 0;  -- these are confusing to users      dfFileUpdated ¬ TRUE};    CWF.WF0[".\n"L]};        SetPlainProps: PROCEDURE = {      NeededProps: FileTransfer.DesiredProperties = [      host:	   TRUE,      directory:   TRUE,      body:	   TRUE,      version:	   TRUE,      author:	   FALSE,      create:      TRUE,      read:        FALSE,      write:       FALSE,      size:	   FALSE, -- Note difference between this and TransferImpl.      type:	   TRUE,      oldFile:	   FALSE,   --writedate      readProtect: FALSE];  --readDate      Transfer.SetProps[NeededProps];    };      END.Change log:19-Jul-84 16:22:13	NSG   	changed skip to skipOperation14-Sep-84 11:59:08	DSC  	Added clause "AND DFLibrarian.Usable[]" after any IF stmt that 				checks if the checklibrarian flag is on. 				Even if the checklibrarian flag is somehow turned on in a non librarian site, 				we don't want to run the librarian operations. 2-Nov-84 16:58:13	DSC  	Fixed a problem where a libject is only checked back in if Subr.Checklibrarian is TRUE.  				Now, Subr.Checklibrarian only sets the detaults that appear in the DF TOOL. 6-Nov-84 10:45:00	DSC  	Election day! Added a new option opt.dfLibjectsOnly in 				StoreBits to avoid non DF libject checks. 9-Nov-84 18:40:23	DSC  	Mondale lost! Fixed preRelease mode to avoid libject checking for non DFs.14-Nov-84 15:00:47	DSC  	Fixed bug in pre release libject bypass for non DFs. Forgot .16-Nov-84 14:05:15	DSC  	Made more procedures not trust its parameters. Basically NIL checking. 27-Nov-84 15:43:49	DSC  	Added librarian protocol paramaters. 21-Jan-85 11:28:11	DSC  	Removed librarian protocol paramaters. 22-Jan-85 11:10:23	DSC  	Added libHandle to options.  8-Feb-85 14:59:55	DSC  	Made caller owner of libhandle.servername.   6-May-85 16:42:30	DSC  	Call Transfer SetProps to avoid Size props. 
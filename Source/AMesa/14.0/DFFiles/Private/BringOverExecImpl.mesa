-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- BringOverExecImpl.mesa - last edited by:--    BTL  	20-Dec-83 11:24:19--    DSC  	 4-Nov-84 15:07:05DIRECTORY  BringOverInterface USING [    AlreadyRunning, BringOverDF, CheckAbortProc, CheckThisFile,    DefaultOptions, DoneRunning, FreeUsingSeqWithError, Options, RecursiveLoop],  CWF USING [WF0, WF1, WFCR, WFError],  DFSubr USING [AppendToUsingSeq, FreeUsingSeq, UsingSeq],  Event USING [DoneWithProcess, Handle, StartingProcess],  Exec USING [    AddCommand, CheckAbortProc, CheckForAbort, ExecProc, FreeTokenString,    GetToken, Handle, Outcome, OutputProc, RemoveCommand],  FileName USING [Error],  FileTransfer USING [CodeToString, Error],  Format USING[StringProc],  MFile USING [AppendErrorMessage, Error],  MSegment USING [Error],  MStream USING [Error],  String USING [CopyToNewString, Empty, Equivalent, FreeString],  Subr USING [    AppendMSegmentErrorMessage, AppendMStreamErrorMessage,    debugflg, errorflg, FreeString, GetLocalDir, LongZone, PrintGreeting,    SetIntegrationLoc, SetLocalDFDir, SetUpCWFWriteProcedure,    SetWorkingDFLoc, SubrInit, SubrStop],  Time USING [Current, Packed],  Transfer USING [Finalize, Initialize],  Volume USING [InsufficientSpace];BringOverExecImpl: PROGRAM    IMPORTS      BringOverInterface, CWF, DFSubr, Event, Exec, FileName, FileTransfer,      MFile, MSegment, MStream, String, Subr, Time, Transfer, Volume =  BEGIN  DoBringOver: Exec.ExecProc = {    startTime, elapsedTime: Time.Packed;    exec: Exec.Handle ¬ h;    myEventHandle: Event.Handle ¬ NIL;        Cleanup: PROC = {      Transfer.Finalize[];  Subr.SubrStop[];      Event.DoneWithProcess[myEventHandle];  myEventHandle ¬ NIL;      BringOverInterface.DoneRunning[]};    BEGIN      ENABLE {        UNWIND => Cleanup[];        FileTransfer.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [60];	    FileTransfer.CodeToString[code, msg];	    CWF.WF1["FileTransfer error: %s\n"L, msg];	    GOTO error};        ABORTED => {CWF.WF0["\n...BringOver aborted.\n"L];  GOTO abort};        BringOverInterface.CheckThisFile =>	  RESUME;  -- if here then no infinite recursive loop        Volume.InsufficientSpace => {CWF.WF0["Volume full.\n"L];  GOTO error};	FileName.Error =>	  IF Subr.debugflg THEN REJECT	  ELSE {CWF.WF0["FileName error.\n"L];  GOTO error};        BringOverInterface.RecursiveLoop => {          CWF.WF0["Error - infinite recursive nesting of DF files using @.\n"L];          CWF.WF1["\tOne of the files involved is %s.\n"L, loopfilename];          ERROR ABORTED};	CWF.WFError => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    CWF.WF1["\nCWF error: %s.\n"L, err];	    GOTO error};	MFile.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];	    CWF.WF1["MFile error: %s.\n"L, msg];   	    GOTO error};        MStream.Error =>  	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMStreamErrorMessage[msg, code, stream];	    CWF.WF1["MStream error: %s.\n"L, msg];   	    GOTO error};	MSegment.Error =>   	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMSegmentErrorMessage[msg, code, segment];	    CWF.WF1["MSegment error: %s.\n"L, msg];   	    GOTO error}};	    IF BringOverInterface.AlreadyRunning[] THEN {       Exec.OutputProc[h][" BringOver already running!"L];      RETURN[abort]};    startTime ¬ Time.Current[];    Subr.SetUpCWFWriteProcedure[];  Subr.SubrInit[exec];    Subr.errorflg ¬ Subr.debugflg ¬ FALSE;    Subr.PrintGreeting["BringOver"L];    myEventHandle ¬ Event.StartingProcess["BringOver"L];    Transfer.Initialize[exec: exec, window: NIL];  -- use exec window for I/O    outcome ¬ GetFiles[exec];    EXITS      error => {Subr.errorflg ¬ TRUE;  outcome ¬ error};      abort => outcome ¬ abort;    END;    IF Subr.errorflg THEN CWF.WF0["\nErrors logged.\n"L] ELSE CWF.WFCR[];    elapsedTime ¬ [Time.Current[] - startTime];    CWF.WF1["Total elapsed time for BringOver %lr.\n\n"L, @elapsedTime];    Cleanup[]};      GetFiles: PROC [exec: Exec.Handle] RETURNS [outcome: Exec.Outcome] = {    opt, globalOpt: BringOverInterface.Options ¬      BringOverInterface.DefaultOptions;    dfFileNamed: BOOLEAN ¬ FALSE;    name, sw, dfName, onlyfile: LONG STRING ¬ NIL;    usingSeq: DFSubr.UsingSeq ¬ NIL;    localDir: LONG STRING ¬ NIL;    dfZone: UNCOUNTED ZONE ¬ Subr.LongZone[];        CheckAbortInExec: BringOverInterface.CheckAbortProc = {      RETURN[Exec.CheckForAbort[exec]]};        Cleanup: PROC = {      IF ~String.Empty[name] THEN name ¬ Exec.FreeTokenString[name];      IF ~String.Empty[sw] THEN sw ¬ Exec.FreeTokenString[sw];      IF ~String.Empty[onlyfile] THEN onlyfile ¬ Exec.FreeTokenString[onlyfile];      IF ~String.Empty[dfName] THEN {        String.FreeString[z: dfZone, s: dfName];  dfName ¬ NIL};      IF ~String.Empty[localDir] THEN {        Subr.FreeString[localDir, dfZone];  localDir ¬ NIL};      IF usingSeq # NIL THEN {DFSubr.FreeUsingSeq[usingSeq];  usingSeq ¬ NIL}};        BEGIN    outcome ¬ normal;    [name, sw] ¬ Exec.GetToken[exec];    WHILE ~String.Empty[name] OR ~String.Empty[sw] DO      IF ~String.Empty[sw] AND String.Empty[name] THEN {  -- global switches        SetSwitches[@globalOpt, sw];	IF globalOpt.onlyFileMode THEN {	  -- have to treat remaining tokens specially	  name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	  [onlyfile, sw] ¬ Exec.GetToken[exec]; sw ¬ Exec.FreeTokenString[sw];	  IF String.Empty[onlyfile] THEN {	    CWF.WF0["Error - /o must be followed by file name.\n"L];  GOTO error};	  usingSeq ¬ NIL;	  DO  -- onlyfile lags name; when name is empty, onlyfile has last name	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];              IF String.Empty[name] THEN {	      name ¬ onlyfile;  onlyfile ¬ NIL;  GOTO lookForDFfile};            usingSeq ¬ DFSubr.AppendToUsingSeq[usingSeq, onlyfile, dfZone];	    [] ¬ Exec.FreeTokenString[onlyfile];	    onlyfile ¬ name;            ENDLOOP;          EXITS lookForDFfile => NULL}	ELSE {  -- done with global switches, but not /o mode	  name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];          [name, sw] ¬ Exec.GetToken[exec];	  LOOP}};      opt ¬ globalOpt;      IF ~String.Empty[sw] THEN SetSwitches[@opt, sw];      IF opt.cmd THEN {        SELECT TRUE FROM          String.Equivalent[name, "localDir"L] => { -- next token is local dir	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - localDir/c must be followed by a directory name.\n"L];	      GOTO error};	    IF ~String.Empty[localDir] THEN Subr.FreeString[localDir, dfZone];            localDir ¬ Subr.GetLocalDir[name, dfZone]};          String.Equivalent[name, "localDFDir"L] => { -- next token is df dir	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - localDFDir/c must be followed by a directory name.\n"L];	      GOTO error};	    Subr.SetLocalDFDir[name]};          String.Equivalent[name, "workingDFLoc"L] => { -- next is working loc	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - workingDFLoc/c must be followed by [Host]<Dir>.\n"L];	      GOTO error};	    Subr.SetWorkingDFLoc[name]};          String.Equivalent[name, "integrationLoc"L] => { -- next is int loc	    name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];	    [name, sw] ¬ Exec.GetToken[exec];  sw ¬ Exec.FreeTokenString[sw];	    IF String.Empty[name] THEN {	      CWF.WF0[	        "Error - integrationLoc/c must be followed by [Host]<Dir>.\n"L];	      GOTO error};	    Subr.SetIntegrationLoc[name]};	  ENDCASE => {	    CWF.WF1["Error - unrecognized command %s.\n"L, name];  GOTO error};	name ¬ Exec.FreeTokenString[name];	[name, sw] ¬ Exec.GetToken[exec];	LOOP};      -- process DF file name      IF ~String.Empty[name] THEN {        dfFileNamed ¬ TRUE;	dfName ¬ String.CopyToNewString[s: name, z: dfZone, longer: 3];	Subr.debugflg ¬ opt.debugging;        BringOverInterface.BringOverDF[	  dfFileName: dfName, usingSeq: usingSeq,	  opt: opt, localDir: localDir, 	  dfZone: dfZone, window: NIL, abortProc: CheckAbortInExec];	String.FreeString[z: dfZone, s: dfName];  dfName ¬ NIL};      name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];      [name, sw] ¬ Exec.GetToken[exec];      ENDLOOP;    IF usingSeq # NIL THEN {      BringOverInterface.FreeUsingSeqWithError[usingSeq];  usingSeq ¬ NIL};    IF ~dfFileNamed THEN {      CWF.WF0["Error - No DF file specified.\n"L];  Subr.errorflg ¬ TRUE};    EXITS error => Subr.errorflg ¬ TRUE;    END;    IF Subr.errorflg THEN outcome ¬ error};      SetSwitches: PROC [      opt: POINTER TO BringOverInterface.Options, sw: LONG STRING] = {    sense: BOOLEAN ¬ TRUE;    FOR i: CARDINAL IN [0..sw.length) DO      SELECT sw[i] FROM        'a, 'A => {opt.mustConfirm      ¬ ~sense;  sense ¬ TRUE};        'p, 'P => {opt.publicOnly       ¬  sense;  sense ¬ TRUE};        'v, 'V => {opt.verify           ¬  sense;  sense ¬ TRUE};        '<     => {opt.getOlderOK       ¬  sense;  sense ¬ TRUE};        'u, 'U => {opt.updateExisting   ¬  sense;  sense ¬ TRUE};        'f, 'F => {opt.forceRetrieval   ¬  sense;  sense ¬ TRUE};        'd, 'D => {opt.debugging        ¬  sense;  sense ¬ TRUE};        'z, 'Z => {opt.preRelease       ¬  sense;  sense ¬ TRUE};        'x, 'X => {opt.archiveBcdRename ¬  sense;  sense ¬ TRUE};        'b, 'B => {opt.justObjects	¬  sense;  sense ¬ TRUE};        'r, 'R => {opt.justReadOnlys	¬  sense;  sense ¬ TRUE};        's, 'S => {opt.justSources	¬  sense;  sense ¬ TRUE};        'w, 'W => {opt.justNonReadOnlys ¬  sense;  sense ¬ TRUE};        'o, 'O => {opt.onlyFileMode     ¬  sense;  sense ¬ TRUE};        'c, 'C => {opt.cmd	        ¬  sense;  sense ¬ TRUE};	'-, '~ => sense ¬ ~sense;        ENDCASE => {	  CWF.WF1["Unknown switch in '%s'\n"L, sw];  Subr.errorflg ¬ TRUE}      ENDLOOP};        Init: PROC = {Exec.AddCommand[name:  "BringOver.~"L, proc: DoBringOver, help:  Help,  unload:  Unload]};    Unload: Exec.ExecProc = {  []  ¬  h.RemoveCommand["BringOver.~"L];  };    Help: Exec.ExecProc = {    OutputProc: Format.StringProc _ Exec.OutputProc[h];    h.OutputProc[][ "BringOver[/<global switches>] DFfile1[/<local switches>]....DFfilen[/<local switches>] Global switches are optional and control the retrieval of subsequent DFs. You can also set global switches by giving an empty DF file name. BringOver's  \"only file\" mode (/o) has a slightly different format: files to be retrieved are listed after the global switch /o, and the DF file to be used is named last. BringOver also recognizes commands, localDir/c, localDFDir/c, workingDFLoc/c and integrationLoc/c:      Example: BringOver localDir/c <>Old> localDFDir/c <>Old>  [FS:]<Dir>DF.df. They override User.cm entries. A switch specification is a letter identifying the switch, optionally preceeded by a '-' or a '~' to reverse the sense of the switch. Switches recognized by BringOver are:   a=Always retrieve   b=get just Bcd (or other derived files)   f=Force retrieval, regardless of newer locals   o=Only specified files   p=Public (exported) only   r=Readonly (imported AND readonly)   s=Source only (inverse of /b)   u=Update existing local files (never get new files), v=Verify files exist in the right place and version and fill in DF dates (slow if DF is large)   w=Writable only (owned files that are in Exports or Directory clauses. Inverse of /r)   x=rename .bcd to .archivebcd if an archivebcd already exists   z=pre release mode   <=suppress confirmation request if an older remote vrsion is retrieved."L];  };  Init[];  END.Change log: 4-Nov-84 15:07:17	DSC  	Added Unload and Help procs. 
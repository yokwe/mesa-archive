-- File: DFParserImpl.mesa - last edit:-- Riggle.PA            8-Jan-87 17:33:30-- DFParserImpl.mesa - Last edited by --   Schmidt	 9-Mar-82 16:52:31--   RXJ     	11-Jan-83 11:23:48--   BTL  	1-Aug-83 20:38:19--   DSC  	11-Feb-86 17:18:39-- Copyright (C) 1982, 1983, 1984 , 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [CR, NUL, TAB],  CWF USING [WF0, WF1, WF2, WF3, WF4],  Date USING [StringToPacked, Unintelligible],  DFSubr USING [    AppendToUsingSeq, Criterion, DF, DFEntryProcType, DFFileRecord, DFSeq,    FreeUsingSeq, InterestingNestedDFProcType, NextDF, StripLongName, UsingEmpty,    UsingSeq, ZoneType],  DFWorldTime,  Inline USING [LowHalf],  MStream USING [Handle],  NSName USING [maxFullNameLength],  Stream USING [EndOfStream, GetBlock],  String USING [    AppendChar, AppendString, Empty, EquivalentString, InvalidNumber,    StringBoundsFault],  Subr USING [    Any, AllocateString, CopyString, EndsIn, errorflg, FreeString, LongZone,    StrCopy, SubStrCopy],  System,  Time;DFParserImpl: PROGRAM  IMPORTS CWF, Date, DFSubr, DFWorldTime, Inline, Stream, String, Subr, System, Time  EXPORTS DFSubr =  BEGIN  -- may be raised by ParseStream if limitErrors is TRUE  TooManyParseErrors: PUBLIC ERROR = CODE;  longzone: UNCOUNTED ZONE ¬ NIL;  Token: TYPE = {    tBad,    -- keywords    tCameFrom, tDirectory, tExports, tHost, tImports, tInclude, tOf, tPublic,    tPublicOnly, tReadOnly, tReleaseAs, tUsing,    -- special characters    tAtSign, tOpenCurly, tCloseCurly, tOpenBracket, tCloseBracket, tComment,    tTilde, tPlus, tNotEqual, tStar, tGreaterThan, tOther, tEOF, tCR};  -- tOther is a catch all: e.g. filenames such as <dir>schmidt.df; dates, etc.  tokenString: ARRAY Token OF LONG STRING = [    "bad"L, "CameFrom"L, "Directory"L, "Exports"L, "Host"L, "Imports"L,    "Include"L, "Of"L, "Public"L, "PublicOnly"L, "ReadOnly"L, "ReleaseAs"L,    "Using"L,    -- special characters    "@"L, "{"L, "}"L, "["L, "]"L, "Comment"L, "~"L, "+"L, "~="L, "*"L, ">"L,    "filename or date"L, "EOF"L, "CR"L];  giveUpLimit: CARDINAL = 10;  maxBufferLength: CARDINAL = 1000;  maxCommentLineLength: CARDINAL = 600;  -- Following stolen from FileNameImpl   maxRemoteNameLength: CARDINAL = 150;  maxTokenLength: CARDINAL = maxRemoteNameLength;  -- Better get this from an extrnal interface.  maxDirectoryLength: CARDINAL = maxTokenLength;  maxReleaseDirLength: CARDINAL = maxDirectoryLength;  maxFullNameLength: CARDINAL = maxTokenLength;  maxShortNameLength: CARDINAL = maxTokenLength;  -- Change this when you add more keywords.  maxReservedWordLength: CARDINAL = 10;  -- this outer procedure is here to hold state for the inner parsing procedures,  -- making the code reentrant  -- if noremoteerrors is true, don't complain if a file doesn't  --   	appear to have a remote place  -- if forceReadonly then make every entry in this DF file be ReadOnly  -- if omitNonPublic, then don't parse them into dfseq  -- dffilename is for error messages  -- if using # NIL then restrict parsing to those on using list  -- dfseq does not need to be local!  -- justexception is here to kludge over bugs in with  -- the spacing on Host and Directory: it is not used with Imports and Includes  ParseStream: PUBLIC PROC [    sh: MStream.Handle, dfseq: DFSubr.DFSeq, dffilename: LONG STRING,    using: DFSubr.UsingSeq, noremoteerrors, forceReadonly, omitNonPublic: BOOLEAN,    interestingNestedDF: DFSubr.InterestingNestedDFProcType,    dfEntryProc: DFSubr.DFEntryProcType, ancestor: LONG STRING, nLevel: CARDINAL,    limitErrors: BOOLEAN ¬ FALSE] = {    errorCount: CARDINAL ¬ 0;  -- if >10 and limitErrors raise TooManyParseErrors     lastCharInBuffer, eof: BOOLEAN ¬ FALSE;    buffer: LONG STRING ¬ NIL;  -- char buffer for scanner    bufferPos, bufferEnd: CARDINAL ¬ 0;    streamposn: LONG CARDINAL ¬ 0;  -- file index of peekch (1 for 1st char, etc)    peekch: CHARACTER ¬ ' ;  -- peek character    tok: Token ¬ tBad;  -- next token    wholecomment: LONG STRING ¬ NIL;  -- memory in longzone    justexception: BOOLEAN ¬ FALSE;    -- these strings are allocated dynamically; beware: they are in a longzone    host: LONG STRING ¬ NIL;    releaseHost: LONG STRING ¬ NIL;    tokenstr: LONG STRING ¬ NIL;  -- receives text of next token (tok)    commentline: LONG STRING ¬ NIL;  -- used by GetC to accumulate comments, commentline includes trailing CR    directory: LONG STRING ¬ NIL;  -- the current directory    releasedir: LONG STRING ¬ NIL;  -- the current release directory    fullname: LONG STRING ¬ NIL;  -- the whole name    shortname: LONG STRING ¬ NIL;  -- the short name    tempdir: LONG STRING ¬ NIL;  -- explicit directory on a filename    -- does not get the following token    -- parses [host]<directory> or <directory>    -- called only if tok = tOther or tOpenBracket    HostAndOrDir: PROC [host, directory: LONG STRING] = {      IF tok = tOpenBracket THEN GetHost[host: host, expectJustDir: TRUE];  -- [ host ]      -- the next string is the directory, possibly with <>      CkTok[tok, tOther];      Subr.StrCopy[directory, tokenstr];      IF directory.length = 0 THEN {        IF ~noremoteerrors THEN {          CWF.WF0["Error - Null directory entry.\n"L];          Subr.errorflg ¬ TRUE;          IF (errorCount ¬ errorCount + 1) > giveUpLimit AND limitErrors THEN            ERROR TooManyParseErrors};        RETURN};      IF directory[directory.length - 1] = '> THEN        directory.length ¬ directory.length - 1;      IF directory[0] = '< THEN Subr.SubStrCopy[directory, directory, 1]};    GetHost: PROC [host: LONG STRING, expectJustDir: BOOLEAN] = {      -- [ host ]   (collect all characters up to ] as host)      ch: CHARACTER;      tokenstr.length ¬ 0;      DO        ch ¬ GetC[];        IF tokenstr.length >= tokenstr.maxlength THEN {          CWF.WF1["Host '%s' is too long.\n"L, tokenstr]; RETURN};        tokenstr[tokenstr.length] ¬ ch;        tokenstr.length ¬ tokenstr.length + 1;        IF peekch = '] OR peekch = Ascii.NUL THEN EXIT;        ENDLOOP;      Subr.StrCopy[host, tokenstr];      GetToken[TRUE];  -- skip over host id      CkTok[tok, tCloseBracket];      -- skip over ] (get directory)      -- Start the paranoid check:      IF Subr.Any[str: host, ch: ':] THEN { -- must be NS name..         -- May put more checks to make sure that there are TWO	 -- colon in the host name.         IF Subr.EndsIn[str: host, suf: ":"L] THEN { -- FOOL!	    CWF.WF3["\nWarning - host is a NS name, but is not fully qualified. (i.e. name:domain:organization) The OFFENDING string is: \"%s\" in DF \"%s\" whose ancestor is \"%s\". Please be nice and fix it NOW!.\n"L, host, dffilename, ancestor];	 };      };      GetToken[ignoreLeadingCR: TRUE, expectJustDir: expectJustDir]};    -- does not get the following token    ParseFullName: PROC [host, directory, filename: LONG STRING]      RETURNS [vers: CARDINAL] = {      host.length ¬ 0;      IF tok = tOpenBracket THEN  -- get [host]<path>file!vers        GetHost[host: host, expectJustDir: FALSE];      -- tok should now be <directory>file!vers      CkTok[tok, tOther];      vers ¬ DFSubr.StripLongName[        tokenstr, NIL, directory, filename, FALSE !        String.InvalidNumber => {          posn: LONG CARDINAL ¬ IF streamposn = 0 THEN 0 ELSE streamposn - 1;          CWF.WF2[            "Error - invalid number at position %lu in file %s.\n"L, @posn,            dffilename];          ERROR ABORTED}]};    CkTok: PROC [token, shouldbe: Token] = {      IF token # shouldbe THEN {        posn: LONG CARDINAL ¬ IF streamposn = 0 THEN 0 ELSE streamposn - 1;        CWF.WF4[          "Error - expecting a %s, found a %s at position %lu in file %s.\n"L,          tokenString[token], tokenString[shouldbe], @posn, dffilename];        Subr.errorflg ¬ TRUE;        IF (errorCount ¬ errorCount + 1) > giveUpLimit AND limitErrors THEN          ERROR TooManyParseErrors}};    Misplaced: PROC [token: Token] = {      posn: LONG CARDINAL ¬ IF streamposn = 0 THEN 0 ELSE streamposn - 1;      CWF.WF3[        "Error - was not expecting the token '%s' at position %lu in file %s.\n"L,        tokenString[token], @posn, dffilename];      Subr.errorflg ¬ TRUE;      IF (errorCount ¬ errorCount + 1) > giveUpLimit AND limitErrors THEN        ERROR TooManyParseErrors};    -- gets the following token, first on the next line    GetCR: PROC = {      -- forces next GetToken to the beginning of the line (and not return a CR)      DO IF tok = tCR OR tok = tEOF THEN EXIT; GetToken[FALSE] ENDLOOP;      GetToken[TRUE]};    SkipCR: PROC = {IF tok = tCR THEN GetToken[TRUE]};    ParseDateField: PROC      RETURNS [criterion: DFSubr.Criterion, wantdate: Time.Packed] = {      sdate: STRING ¬ [100];  -- String to contain the Date that is to be parsed.      savetok: Token;  -- temporary for the token read before current one.      ch: CHARACTER ¬ Ascii.NUL;  -- to read the DateField one character at a time.      -- VARS FOR THE DATE PROBLEM FIX IN PILOT 11.0 (and perhaps BEYOND!)      -- The following decls are fixes to get around  a current bug in DateImpl that does not parse dates correctly when Daylight Savings Time does is not the same as those in the United States.      --      -- Get a LTP set on the machine.      badLTP: useThese Time.LTP ¬ [useThese[System.GetLocalTimeParameters[]]];      mustFixTime: BOOLEAN ¬ FALSE;  -- true if not in US DST.      -- This better be right. Change this if Congress does something funny.      USAfirstDST: CARDINAL = 121;      USAlastDST: CARDINAL = 305;      -- mustFixTime is TRUE if  the LTP is not set to US standards.      -- pretend we are in the US (since that's where the software works)      -- by setting our fake LTP to the US parameters.      IF badLTP.ltp.beginDST # USAfirstDST OR badLTP.ltp.endDST # USAlastDST THEN        {	-- I.e. If we do not follow the US standards then we better fix it.        mustFixTime ¬ TRUE;        badLTP.ltp.beginDST ¬ USAfirstDST;        badLTP.ltp.endDST ¬ USAlastDST};      -- General comments on routine:      --      -- This routine has been hacked very badly, but the current      -- Token routine has difficulty reading '- since it is a      -- comment delimitor, and also since comments are preserved for      -- rewriting. The solution is to change the DF syntax.      -- Initialize params.      wantdate ¬ Time.Packed[0];      criterion ¬ none;      -- At this point in the parse, we have already read the file name.      -- The date field could be empty and that should be handled.      -- some keywords could follow the file name, such as OF.      -- Possibilites:      -- filename date time CR      -- filename # CR	      -- filename > CR        -- filename CR          -- !!! for imports clauses!!!      -- filename of date time CR      -- filename of > CR      -- criteria  if one of: notequal or update      --	i.e. # or ~= OR >      --      -- if we have a date (not the time, since that's a separate token)      -- 	we should have that in the token string.      --	that should be parsed.      -- else if we have a > or a #       -- 	we have those symbols in the token string.      --	so set the criterion and parse past the CR      -- else if we have a CR      -- 	then return      -- else if we have a OF then      --	read date OR >      -- 	skip to CR.      GetToken[FALSE];  -- don't skip any leading CR.      savetok ¬ tok;      SELECT tok FROM        tOf => GetToken[FALSE];  -- go ahead and get the date (or # or >) that follows.        tCR => {  -- ok to have, we'll fill it in later.          --CWF.WF0["No date field found!\n"];             RETURN; };        tNotEqual => {  -- If we have a '# or a "~=", we MAY have a date that follows          criterion ¬ notequal; GetToken[FALSE]; RETURN; };        tGreaterThan => {criterion ¬ update; GetToken[FALSE]; RETURN; };        tOther => {          -- Great! token may already be   (part of) a date!          String.AppendString[sdate, tokenstr];          -- Assuming that this is a date, add an extra space since the date format          -- requires a space between the time and the date tokens          String.AppendChar[sdate, ' ];          };        ENDCASE => {          CWF.WF3[            "Error - expecting a date at position %lu in %s, \nfound '%s' instead.\n"L,            @streamposn, dffilename, tokenstr];          Subr.errorflg ¬ TRUE;          IF (errorCount ¬ errorCount + 1) > 10 AND limitErrors THEN {            ERROR TooManyParseErrors}          ELSE {RETURN}};      -- the remaining possibilities.      -- filename date time CR      -- filename of date time CR      -- filename of > CR      -- if we had an OF, then we have the next token.      -- if we have a > afterwards already, finsish off that case.      --	read until the end of the line.      IF savetok = tOf THEN {        SELECT tok FROM          tGreaterThan => {            criterion ¬ update;            GetToken[FALSE];  -- supposed to get the CR if syntax is correct.            RETURN;            };          tNotEqual => {            criterion ¬ notequal;            GetToken[FALSE];  -- supposed to get the CR if syntax is correct.            RETURN;            };          tOther => {            -- save the token we read after identifying the OF (first part of the date)            -- then we must get the next token which should be the second part of date.            String.AppendString[sdate, tokenstr]; String.AppendChar[sdate, ' ]; };          ENDCASE => {  -- put this in an EXIT clause sometime.            CWF.WF3[              "Error - expecting a date at position %lu in %s, \nfound '%s' instead.\n"L,              @streamposn, dffilename, tokenstr];            Subr.errorflg ¬ TRUE;            IF (errorCount ¬ errorCount + 1) > 10 AND limitErrors THEN {              ERROR TooManyParseErrors}            ELSE {RETURN}};        };      -- the remaining possibilities.      -- filename date time CR      -- filename of date time CR      -- IF we read an OF, the token points to the       -- potentially, the first part of the date      -- if we have tOther, we already have appended the first      -- part of the date to the str.      --CWF.WF1["sdate is '%s'\n"L, tokenstr];      -- Skip the extra space(s) between the date and time fields.      -- which are not expected but date may be hand written, so advance pointer.      WHILE peekch = '  DO [] ¬ GetC[]; ENDLOOP;      IF ch # Ascii.CR OR ch # Ascii.NUL THEN ch ¬ GetC[];  -- add the non space character later.      WHILE ch # Ascii.CR AND ch # Ascii.NUL DO        IF sdate.length >= sdate.maxlength THEN {          --CWF.WF1["String '%s' is toolong.\n"L, sdate];           RETURN; };        String.AppendChar[s: sdate, c: ch];        --CWF.WF3["Ch is: %c and peekch is %c sdate is %s\n"L, @ch, @peekch, sdate];        ch ¬ GetC[];        ENDLOOP;      IF (ch = Ascii.CR OR ch = Ascii.NUL) AND String.Empty[sdate] THEN {        --CWF.WF0["Found no date!\n"];        tokenstr.length ¬ 0;        RETURN;  -- no date given        };      -- assert[ch = Ascii.CR];      wantdate ¬ Date.StringToPacked[        sdate !        Time.Invalid, Date.Unintelligible => {          CWF.WF3[            "Error - '%s' is an invalid time at position %lu in %s.\n"L, sdate,            @streamposn, dffilename];          wantdate ¬ [0];          Subr.errorflg ¬ TRUE;          IF (errorCount ¬ errorCount + 1) > giveUpLimit AND limitErrors THEN            ERROR TooManyParseErrors;          CONTINUE}].dt;      -- FIX the date problem:      -- If we have a "valid" date, but is also messed up, and are not in DST...      -- If we are not in the US (ay Japan), and the DF date is in DST      -- and we are in DST by US stanards      IF mustFixTime AND DFWorldTime.needsFix AND NOT Time.Unpack[wantdate].dst        AND Time.Unpack[wantdate].dst AND Time.Unpack[wantdate, badLTP].dst THEN {        wantdate ¬ System.AdjustGreenwichMeanTime[gmt: wantdate, delta: DFWorldTime.delta];        -- add one hour in Japan, at least.        };      --CWF.WF1["Date parsed is %lt.\n"L, @wantdate];      tokenstr.length ¬ 0;      -- prime the token with the CR      --CWF.WF0["Getting the CR...\n"];      GetToken[FALSE];      };    -- this procedure is called ONCE by the outer procedure    ParseStreamInternal: PROC = {      nExports: CARDINAL;      readonly, public, camefrom: BOOLEAN ¬ FALSE;      df: DFSubr.DF;      lastdir, lastreleasedir: LONG STRING ¬ NIL;      isatsign, istopmark, isstar, ispublicOnly: BOOLEAN;      isnoremoteversion, exportsImports: BOOLEAN;      nExports ¬ 0;      [] ¬ GetC[];  -- to set up peekch      GetToken[TRUE];  -- first token      exportsImports ¬ FALSE;      DO        -- tok is from last GetToken[]; should be first on next line        -- IF Exec.CheckForAbort[] THEN ERROR ABORTED;        justexception ¬ FALSE;        SELECT tok FROM          tEOF => EXIT;          tHost => {            justexception ¬ TRUE;            GetToken[TRUE];            CkTok[tok, tOther];            Subr.StrCopy[host, tokenstr];            GetCR[]};  -- forces new line           tDirectory, tPublic, tExports, tReadOnly => {            justexception ¬ TRUE;            exportsImports ¬ public ¬ readonly ¬ camefrom ¬ FALSE;            DO              SELECT tok FROM                tImports => GOTO isImports;                tReadOnly => readonly ¬ TRUE;                tExports, tPublic => public ¬ TRUE;                tOpenBracket => EXIT;                tDirectory => NULL;                ENDCASE => Misplaced[tok];              GetToken[TRUE];              IF tok = tOther OR tok = tEOF OR tok = tOpenBracket THEN EXIT;              ENDLOOP;            HostAndOrDir[host, directory];            -- parse CameFrom or ReleaseAs            GetToken[TRUE];            releaseHost.length ¬ releasedir.length ¬ 0;            IF tok = tCameFrom OR tok = tReleaseAs THEN {              camefrom ¬ (tok = tCameFrom);              GetToken[TRUE];              HostAndOrDir[releaseHost, releasedir];              GetCR[]};  -- gets new line & next token            EXITS isImports => exportsImports ¬ TRUE};  -- "Exports Imports", goto tImports processing          tImports, tInclude => {            -- if exportsImports is true, then this is an Exports Imports            innerUsing: DFSubr.UsingSeq ¬ NIL;            vers: CARDINAL;            savecomment: LONG STRING ¬ NIL;            createtime: Time.Packed;            criterion: DFSubr.Criterion;            savetok: Token ¬ tok;            localhost: STRING ¬ [NSName.maxFullNameLength];            localdirectory: STRING ¬ [100];            localrhost: STRING ¬ [50];            localrdirectory: STRING ¬ [100];            skipIt, callIt, publicOk: BOOLEAN ¬ FALSE;            -- (Exports) Imports [host]<path>file!vers Of <date> CameFrom [host]<path>             -- Imports (Exports) [host]<path>file!vers Of <date> CameFrom [host]<path>             -- Include [host]<path>file!vers Of <date> (CameFrom|ReleaseAs [host]<path>)             --	Using [ file list ]            df ¬ NIL;            GetToken[TRUE];            savecomment ¬ wholecomment;            wholecomment ¬ NIL;            IF savetok = tExports THEN {exportsImports ¬ TRUE; GetToken[TRUE]};  -- Imports Exports            vers ¬ ParseFullName[localhost, localdirectory, shortname];            skipIt ¬ FALSE;            -- skip it if there is a using list and it does not consume an element            -- or if the Imports is not Public            -- don't skip it if it is Include            IF using # NIL THEN skipIt ¬ ~Consume[using, shortname]            ELSE              skipIt ¬ (omitNonPublic AND ~exportsImports AND savetok = tImports);            IF exportsImports THEN nExports ¬ nExports + 1;            IF ~skipIt THEN {              df ¬ DFSubr.NextDF[dfseq];              IF df = NIL THEN EXIT;              df.host ¬ CopyHost[localhost, dfseq];              df.directory ¬ Subr.CopyString[localdirectory, dfseq.dfzone];              df.shortname ¬ Subr.CopyString[shortname, dfseq.dfzone];              IF savecomment # NIL THEN df.comment ¬ savecomment;              savecomment ¬ NIL};            [criterion, createtime] ¬ ParseDateField[              !              String.StringBoundsFault => {                CWF.WF0["Error - bad date field.\n"L];                Subr.errorflg ¬ TRUE;                IF (errorCount ¬ errorCount + 1) > 10 AND limitErrors THEN                  ERROR TooManyParseErrors}];            SkipCR[];            camefrom ¬ FALSE;            IF tok = tCameFrom OR tok = tReleaseAs THEN {              camefrom ¬ (tok = tCameFrom);              GetToken[TRUE];              HostAndOrDir[localrhost, localrdirectory];              GetToken[TRUE]};            IF ~skipIt THEN {              IF savetok = tImports THEN                df.readonly ¬ df.publicOnly ¬ df.atsign ¬ TRUE              ELSE  -- tInclude --                df.atsign ¬ TRUE;              df.version ¬ vers;              df.public ¬ exportsImports;  -- from Exports Imports              df.criterion ¬ criterion;              df.createtime ¬ createtime;              df.releaseDirectory ¬                IF localrdirectory.length > 0 THEN Subr.CopyString[                localrdirectory, dfseq.dfzone] ELSE NIL;              df.releaseHost ¬                IF localrhost.length > 0 THEN CopyHost[localrhost, dfseq]                ELSE NIL;              df.cameFrom ¬ camefrom};            IF tok = tUsing AND savetok = tImports THEN {              GetToken[TRUE];              CkTok[tok, tOpenBracket];              DO                GetToken[TRUE];                IF tok = tCloseBracket OR tok = tEOF THEN EXIT;                CkTok[tok, tOther];                IF ~Subr.Any[tokenstr, '.] THEN  -- assume ".bcd" at end                  String.AppendString[tokenstr, ".bcd"L];                innerUsing ¬ DFSubr.AppendToUsingSeq[                  innerUsing, tokenstr, dfseq.dfzone];                ENDLOOP;              IF ~skipIt THEN df.using ¬ innerUsing;              GetCR[]};            IF savecomment # NIL THEN Subr.FreeString[savecomment, dfseq.dfzone];            savecomment ¬ NIL;            -- first call about this entry            IF ~skipIt AND dfEntryProc # NIL THEN dfEntryProc[dfEntry: df];            -- call the user about this DF file            -- call if             -- 1) the using list we are driven by is not exhausted and             --      a) there is an inner using list so            --         we must check the intersection            --      b) if we are looking at an Imports w/o Using list then            --         this entry is Public,             --      c) if this is an Included DF file            -- 2) or if the using list is exhausted,             --    the DF file was on the using list;             -- 3) or if there is no using list and            --      a) the DF file is Public             --      b) if PublicOnly is false            --      c) if the df file is an Includes            publicOk ¬ exportsImports OR ~omitNonPublic;            callIt ¬ interestingNestedDF # NIL;            IF using # NIL THEN              callIt ¬ callIt                AND                  ((~DFSubr.UsingEmpty[using]                     AND (savetok = tInclude OR publicOk OR innerUsing # NIL))                    OR ~skipIt)            ELSE callIt ¬ callIt AND (publicOk OR savetok = tInclude);            IF callIt THEN              interestingNestedDF[                host: localhost, directory: localdirectory, shortname: shortname,                ancestor: ancestor, immediateParent: dffilename, nLevel: nLevel,                version: vers, createtime: createtime, driverUsingSeq: using,                innerUsingSeq: innerUsing, dfEntry: df,                entryIsReadonly: (savetok = tImports) OR forceReadonly,                publicOnly: (savetok = tImports) OR omitNonPublic,                criterion: criterion];            IF skipIt THEN DFSubr.FreeUsingSeq[innerUsing];            exportsImports ¬ public ¬ FALSE};  -- reset for next line          tOther, tAtSign, tPlus, tTilde, tStar => {            criterion: DFSubr.Criterion;            createtime: Time.Packed;            skipIt, callIt, publicOk, isNewOnly: BOOLEAN;            vers: CARDINAL;            -- +, @, ~, * { PublicOnly } <Directory>Filename!vers  createdate            df ¬ NIL;            skipIt ¬ FALSE;            -- if no using list and this is exports only, then skip it            IF omitNonPublic AND ~public AND using = NIL THEN skipIt ¬ TRUE;            IF public THEN nExports ¬ nExports + 1;            isatsign ¬ istopmark ¬ isstar ¬ ispublicOnly ¬ isNewOnly ¬ FALSE;            DO              SELECT tok FROM                tAtSign => isatsign ¬ TRUE;                tOpenCurly => NULL;                tPublicOnly => ispublicOnly ¬ TRUE;                tCloseCurly => NULL;                tPlus => istopmark ¬ TRUE;                tTilde => isNewOnly ¬ TRUE;                tStar => isstar ¬ TRUE;                tOther, tEOF => EXIT;                ENDCASE => Misplaced[tok];              GetToken[TRUE];              ENDLOOP;            IF tok = tEOF THEN LOOP;            CkTok[tok, tOther];            isnoremoteversion ¬ FALSE;            Subr.StrCopy[fullname, tokenstr];            IF tokenstr[0] # '< AND directory.length = 0 THEN {              IF ~noremoteerrors THEN {                Subr.errorflg ¬ TRUE;                CWF.WF1["Error - directory not specified for '%s'.\n"L, tokenstr];                IF (errorCount ¬ errorCount + 1) > 10 AND limitErrors THEN                  ERROR TooManyParseErrors};              isnoremoteversion ¬ TRUE};            -- fullname looks like <schmidt>model>junk.mesa!3 or junk.mesa!3            vers ¬ DFSubr.StripLongName[              fullname, NIL, tempdir, shortname, FALSE !              String.InvalidNumber => {                posn: LONG CARDINAL ¬                  IF streamposn = 0 THEN 0 ELSE streamposn - 1;                CWF.WF2[                  "Error - invalid number at position %lu in file %s.\n"L, @posn,                  dffilename];                ERROR ABORTED}];            -- skip it if not on using list            -- we will not skip DF files that are referenced in included DF files (omitNonPublic = FALSE),            -- we will skip DF files that are  referenced in imported DF files (omitNonPublic = TRUE)            IF using # NIL THEN skipIt ¬ ~Consume[using, shortname];            -- skip it if there is a using list and it does not consume an element            IF ~skipIt THEN {              df ¬ DFSubr.NextDF[dfseq];              IF df = NIL THEN EXIT;              -- get previous comment saved              IF wholecomment # NIL THEN                df.comment ¬ Subr.CopyString[wholecomment, dfseq.dfzone]};            -- free previous comment at this point            -- any later and the parsedatefield/skipCR will loose a line            IF wholecomment # NIL THEN Subr.FreeString[wholecomment, longzone];            wholecomment ¬ NIL;            [criterion, createtime] ¬ ParseDateField[              !              String.StringBoundsFault => {                CWF.WF0["Error - bad date field.\n"L];                Subr.errorflg ¬ TRUE;                IF (errorCount ¬ errorCount + 1) > 10 AND limitErrors THEN                  ERROR TooManyParseErrors}];            SkipCR[];            IF ~skipIt THEN {              lastdir ¬ df.directory ¬                IF isnoremoteversion THEN NIL                ELSE                  IF tempdir.length = 0 THEN LittleCopyString[                  directory, lastdir, dfseq]                  ELSE LittleCopyString[tempdir, lastdir, dfseq];              lastreleasedir ¬ df.releaseDirectory ¬                IF releasedir.length > 0 THEN LittleCopyString[                releasedir, lastreleasedir, dfseq] ELSE NIL;              df.releaseHost ¬                IF releaseHost.length > 0 THEN CopyHost[releaseHost, dfseq]                ELSE NIL;              df.host ¬ CopyHost[host, dfseq];              df.shortname ¬ Subr.CopyString[shortname, dfseq.dfzone];              df.version ¬ vers;              df.atsign ¬ isatsign;              df.topmark ¬ istopmark;              df.released ¬ isstar;              df.newOnly ¬ isNewOnly;              df.readonly ¬ forceReadonly OR readonly;              df.public ¬ public;              df.publicOnly ¬ ispublicOnly;              df.cameFrom ¬ camefrom;              df.createtime ¬ createtime;              df.criterion ¬ criterion};            -- first call about this entry            IF ~skipIt AND dfEntryProc # NIL THEN dfEntryProc[dfEntry: df];            -- call the user about this DF file            publicOk ¬ public OR ~omitNonPublic;            callIt ¬ isatsign AND interestingNestedDF # NIL              AND Subr.EndsIn[shortname, ".df"L];            IF using # NIL THEN              callIt ¬ callIt                AND                  ((~DFSubr.UsingEmpty[using] AND publicOk OR ~readonly)                    OR ~skipIt)            ELSE callIt ¬ callIt AND (publicOk OR ~readonly);            IF callIt THEN              interestingNestedDF[                host: host, directory: directory, shortname: shortname,                ancestor: ancestor, immediateParent: dffilename, nLevel: nLevel,                version: vers, createtime: createtime, driverUsingSeq: using,                innerUsingSeq: NIL, dfEntry: df,                entryIsReadonly: readonly OR forceReadonly,                publicOnly: ispublicOnly OR omitNonPublic, criterion: criterion]};          ENDCASE => {Misplaced[tok]; GetToken[TRUE]};        ENDLOOP;      IF wholecomment # NIL THEN {        IF dfseq.trailingcomment = NIL THEN          dfseq.trailingcomment ¬ Subr.CopyString[wholecomment, dfseq.dfzone];        Subr.FreeString[wholecomment, longzone]}};  -- end of ParseStreamInternal    -- returns results in tok and tokenstr    GetToken: PROC [ignoreLeadingCR: BOOLEAN, expectJustDir: BOOLEAN ¬ FALSE] = {      ch: CHARACTER;      tok ¬ tBad;      tokenstr.length ¬ 0;      WHILE peekch = '  OR peekch = Ascii.TAB OR peekch = ', OR peekch = '/        OR peekch = '-  -- questionable?        OR (ignoreLeadingCR AND peekch = Ascii.CR) DO [] ¬ GetC[]; ENDLOOP;      IF peekch IN ['A..'Z] OR peekch IN ['a..'z] OR peekch IN ['0..'9]        OR peekch = '< THEN {        tok ¬ tOther;        DO          ch ¬ GetC[];          IF tokenstr.length >= tokenstr.maxlength THEN {            CWF.WF1["String '%s' is too long.\n"L, tokenstr]; RETURN};          tokenstr[tokenstr.length] ¬ ch;          tokenstr.length ¬ tokenstr.length + 1;          -- see if end of token (not ">", "-" as they are part of file names)          -- if expectJustDir, ignore blanks unless after '>          IF (peekch = '  AND (~expectJustDir OR ch = '>)) OR peekch = Ascii.NUL            OR peekch = '[ OR peekch = '] OR peekch = Ascii.TAB            OR peekch = Ascii.CR OR peekch = ', OR peekch = '+ OR peekch = '@            OR peekch = '{ OR peekch = '} OR peekch = '/ OR peekch = '~ THEN EXIT;          ENDLOOP;        -- now see if reserved or identifier or other        IF tokenstr[0] = '< OR tokenstr.length > maxReservedWordLength THEN          RETURN;        -- claim: this is as good as hashing!!        SELECT tokenstr.length FROM          2 => IF String.EquivalentString[tokenstr, "of"L] THEN tok ¬ tOf;          4 => IF String.EquivalentString[tokenstr, "host"L] THEN tok ¬ tHost;          5 => IF String.EquivalentString[tokenstr, "using"L] THEN tok ¬ tUsing;          6 => IF String.EquivalentString[tokenstr, "public"L] THEN tok ¬ tPublic;          7 => {            IF String.EquivalentString[tokenstr, "imports"L] THEN tok ¬ tImports            ELSE              IF String.EquivalentString[tokenstr, "exports"L] THEN tok ¬ tExports              ELSE                IF String.EquivalentString[tokenstr, "include"L] THEN                  tok ¬ tInclude};          8 => {            IF String.EquivalentString[tokenstr, "camefrom"L] THEN tok ¬ tCameFrom            ELSE              IF String.EquivalentString[tokenstr, "includes"L] THEN                tok ¬ tInclude              ELSE                IF String.EquivalentString[tokenstr, "readonly"L] THEN                  tok ¬ tReadOnly};          9 => {            IF String.EquivalentString[tokenstr, "directory"L] THEN              tok ¬ tDirectory            ELSE              IF String.EquivalentString[tokenstr, "releaseas"L] THEN                tok ¬ tReleaseAs};          10 =>            IF String.EquivalentString[tokenstr, "publiconly"L] THEN              tok ¬ tPublicOnly;          -- don't change # 10 without looking at IF test above          ENDCASE;        --CWF.WF1["Token returned = '%s'\n", tokenString[tok]];        --CWF.WF1["tokenstr = '%s'\n", tokenstr];        RETURN};      ch ¬ GetC[];      String.AppendChar[tokenstr, ch];      -- not alphanumeric, look for magic characters      SELECT ch FROM        -- one char delimiters        '[ => tok ¬ tOpenBracket;        '] => tok ¬ tCloseBracket;        Ascii.CR => tok ¬ tCR;        '> => tok ¬ tGreaterThan;        '+ => tok ¬ tPlus;        '# => tok ¬ tNotEqual;        '* => tok ¬ tStar;        Ascii.NUL => tok ¬ tEOF;        '@ => tok ¬ tAtSign;        '{ => tok ¬ tOpenCurly;        '} => tok ¬ tCloseCurly;        -- two chars        '~ => {          IF peekch = '= THEN {[] ¬ GetC[]; tok ¬ tNotEqual} ELSE tok ¬ tTilde};        ENDCASE => tok ¬ tOther;      --CWF.WF1["Token returned = '%s'\n", tokenString[tok]];      --CWF.WF1["tokenstr = '%s'\n", tokenstr];      };    FillBuffer: PROC = {      IF lastCharInBuffer THEN eof ¬ TRUE      ELSE {        lastCharInBuffer ¬ FALSE;        bufferEnd ¬ buffer.maxlength;  -- one beyond last char in buffer        bufferPos ¬ 0;        sh.options.signalEndOfStream ¬ TRUE;        [] ¬ Stream.GetBlock[          sH: sh, block: [LOOPHOLE[@buffer.text], 0, buffer.maxlength] !          Stream.EndOfStream => {            lastCharInBuffer ¬ TRUE;            bufferEnd ¬ Inline.LowHalf[nextIndex];            IF nextIndex <= 1 THEN eof ¬ TRUE;            CONTINUE}];        buffer.length ¬ bufferEnd}};    ReadC: PROC = {      IF bufferPos >= bufferEnd THEN FillBuffer[];      IF eof THEN peekch ¬ Ascii.NUL      ELSE {        peekch ¬ buffer[bufferPos];        bufferPos ¬ bufferPos + 1;        streamposn ¬ streamposn + 1}};    GetC: PROC RETURNS [ch: CHARACTER] = {      ch ¬ peekch;      IF ch = Ascii.NUL THEN RETURN;  -- STP only signals EndOfStream once, then hangs      ReadC[];      DO        -- strips leading blanks from lines        IF ch = Ascii.CR AND peekch = '  THEN {          WHILE peekch = '  DO ReadC[] ENDLOOP};  -- note that ch remains = \n        IF (ch = '/ AND peekch = '/) OR (ch = '- AND peekch = '-)          OR (ch = Ascii.CR AND peekch = Ascii.CR AND ~justexception) THEN {          -- handle comment          len: CARDINAL;          savecomment: LONG STRING;          commentline.length ¬ 0;          String.AppendChar[commentline, ch];          IF peekch # Ascii.CR THEN {            -- get rest of comment line            DO              String.AppendChar[commentline, peekch];              ReadC[];              IF peekch = Ascii.CR OR peekch = Ascii.NUL THEN EXIT;              ENDLOOP;            String.AppendChar[commentline, peekch]};          ch ¬ peekch;          IF ch # Ascii.NUL THEN ReadC[];          len ¬ commentline.length;          IF wholecomment # NIL THEN len ¬ len + wholecomment.length;          savecomment ¬ wholecomment;          wholecomment ¬ Subr.AllocateString[len, longzone];          IF savecomment # NIL THEN {            Subr.StrCopy[wholecomment, savecomment];            Subr.FreeString[savecomment, longzone]};          String.AppendString[wholecomment, commentline]}        ELSE EXIT;        ENDLOOP};    Cleanup: PROC = {      Subr.FreeString[host, longzone];      host ¬ NIL;      Subr.FreeString[releaseHost, longzone];      releaseHost ¬ NIL;      Subr.FreeString[buffer, longzone];      buffer ¬ NIL;      Subr.FreeString[tempdir, longzone];      tempdir ¬ NIL;      Subr.FreeString[shortname, longzone];      shortname ¬ NIL;      Subr.FreeString[fullname, longzone];      fullname ¬ NIL;      Subr.FreeString[releasedir, longzone];      releasedir ¬ NIL;      Subr.FreeString[directory, longzone];      directory ¬ NIL;      Subr.FreeString[tokenstr, longzone];      tokenstr ¬ NIL;      Subr.FreeString[commentline, longzone];      commentline ¬ NIL};    longzone ¬ Subr.LongZone[];    -- these strings are allocated here to avoid running out of resident VM    host ¬ Subr.AllocateString[NSName.maxFullNameLength, longzone];    releaseHost ¬ Subr.AllocateString[NSName.maxFullNameLength, longzone];    buffer ¬ Subr.AllocateString[maxBufferLength, longzone];    commentline ¬ Subr.AllocateString[maxCommentLineLength, longzone];    tokenstr ¬ Subr.AllocateString[maxTokenLength, longzone];    directory ¬ Subr.AllocateString[maxDirectoryLength, longzone];    releasedir ¬ Subr.AllocateString[maxReleaseDirLength, longzone];    fullname ¬ Subr.AllocateString[maxFullNameLength, longzone];    shortname ¬ Subr.AllocateString[maxShortNameLength, longzone];    tempdir ¬ Subr.AllocateString[maxDirectoryLength, longzone];    ParseStreamInternal[ ! UNWIND => Cleanup[]];    Cleanup[]};  Consume: PROC [usingseq: DFSubr.UsingSeq, shortname: LONG STRING]    RETURNS [consumed: BOOLEAN] = {    FOR i: CARDINAL IN [0..usingseq.size) DO      IF usingseq[i] = NIL THEN LOOP;      IF String.EquivalentString[usingseq[i], shortname] THEN {        Subr.FreeString[usingseq[i], usingseq.zone];        usingseq[i] ¬ NIL;        RETURN[TRUE]};      ENDLOOP;    RETURN[FALSE]};  LittleCopyString: PROC [newstr, oldstr: LONG STRING, dfseq: DFSubr.DFSeq]    RETURNS [LONG STRING] = {    RETURN[      IF dfseq.zoneType # huge OR oldstr = NIL      OR ~String.EquivalentString[newstr, oldstr] THEN Subr.CopyString[      newstr, dfseq.dfzone] ELSE oldstr]};  CopyHost: PROC [host: LONG STRING, dfseq: DFSubr.DFSeq] RETURNS [LONG STRING] =    {    IF dfseq.zoneType = huge THEN {      IF String.EquivalentString[host, dfseq.igorHost] THEN        RETURN[dfseq.igorHost];      IF String.EquivalentString[host, dfseq.idunHost] THEN        RETURN[dfseq.idunHost]};    RETURN[Subr.CopyString[host, dfseq.dfzone]]};  END.LOG24-Jul-84  9:37:56	DSC   Made version that supports Offsets from GMT for DF Files. restrictions: Do not concatenate files together on the same line with the hope to have the program figure out where the file name ends and starts. The ParseDate routine was hacked up since the GetToken routine cannot be fixed easily to recognize the '- as a token (it's a comment delimitor) 8-Nov-84 17:53:14	DSC   Got rid of some constants paramters and declared constants at top of program. 9-Nov-84 10:16:15	DSC   Added the crock to allow DF to be used around the world. Take away the cruft when Pilot gets the time parser FIXED... Actually, all you need to do is fix the user.cm when Pilot gets it fixed, and the program will still be usable. Just remove the flags.. 9-Nov-84 14:00:14	DSC   Added a sanity check to warn users if their NS host name does not have the domain and organization I.e I will NOT tolerate crap like [RatTail:]<IMesa>DF.. 14-Nov-84 17:47:22	DSC   Made sanity check message more meaningful..19-Jun-85 13:14:22	DSC   Made max string length of Imports and Include to be 50..11-Feb-86 17:18:51	DSC   AR #8210. Made localHost = NSName.maxFullNameLength
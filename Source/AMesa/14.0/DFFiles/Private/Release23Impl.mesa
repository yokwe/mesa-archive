-- File: Release23Impl.mesa - last edit:-- kam                 19-Oct-85 18:58:44--   Schmidt	 9-Mar-82 17:03:10--   BTL  	18-Nov-83 13:22:49--   DSC  	 4-Mar-85 12:35:26-- Copyright (C) 1982, 1983, 1985 by Xerox Corporation. All rights reserved. DIRECTORY  Ascii USING [TAB],  CWF USING [SWF3, SWF4, WF0, WF1, WF2, WF3, WF4, WFC, WFCR],  DFSubr USING [    AllocateDFSeq, DF, DFSeq, FreeDFSeq, LookupDF, NextDF, ParseStream,    StripLongName, TooManyParseErrors, WriteOut],  Exec USING [CheckForAbort, Handle],  FileTransfer USING [FileInfo, ListProc],  Heap USING [Error],  Inline USING [LowHalf],  MFile USING [Acquire, Error, Handle, ReadOnly, Release],  MStream USING [Error, Handle, ReadOnly, WriteOnly],  Release23 USING [],  ReleaseCache USING [Cache, Close, Insert, Lookup, Make],  ReleaseInterface USING [Data, FlushLog, toolData],  Stream USING [Delete, Handle],  String USING [    AppendChar, AppendString, Empty, Equivalent, EquivalentSubString,    InvalidNumber, StringToDecimal, SubStringDescriptor],  Subr USING [    CopyString, EndsIn, errorflg, FileError, FreeString, GetLine,    LongZone, Prefix, StrCopy, StripLeadingBlanks, SubStrCopy],  Time USING [Current, Packed],  Transfer USING [    CachedOpen, CloseCopyConnection, Copy, EnumerateForProperties,    OpenCopyConnection, Store],  UserInput USING [UserAbort],  VerifyDFInterface USING [CheckAbortProc, Options, VerifyDFFile],  Window USING [Handle];Release23Impl: PROGRAM    IMPORTS      CWF, DFSubr, Exec, Heap, Inline, MFile, MStream,      ReleaseCache, ReleaseInterface, Stream, String, Subr, Time, Transfer,      UserInput, VerifyDFInterface    EXPORTS Release23 =  BEGIN -- # bytes in an IFS page (all page counts are in IFS pages, not Pilot pages)  bytesPerIFSPage: CARDINAL = 2048;  MAXFILES: CARDINAL = 500;     -- max # entries in a single df file  NMAPENTRIES: CARDINAL = 30;   -- max dfmap entries   td: ReleaseInterface.Data ¬ NIL;  prevLineWasDots: BOOLEAN ¬ FALSE;  nDFFilesStored: CARDINAL ¬ 0;		-- # actually written  nFilesSkipped: CARDINAL ¬ 0;		-- # not being released (CameFrom)  nFilesToRelease: CARDINAL ¬ 0;	-- # that are being ReleaseAs'd  nPagesToRelease: LONG CARDINAL ¬ 0; 	-- pages for above  nFilesStored: CARDINAL ¬ 0;		-- # actually copied this time  nPagesStored: LONG CARDINAL ¬ 0;	-- pages for above  nFilesNotStored: CARDINAL ¬ 0;	-- # that would have been copied  nPagesNotStored: LONG CARDINAL ¬ 0;	-- pages for above   -- Used to change lhs loc from an old release loc to new working loc -- Set from file Release.DFLocations  dfmap: DFMap ¬ NIL; -- Used to change release loc (e.g. <APilot>) to another (e.g. <APilot>11.0>) -- Set from file Release.ChangeReleaseLoc  relLocMap: DFMap ¬ NIL;  DFMap: TYPE = LONG POINTER TO DFMapSeq;  DFMapSeq: TYPE = RECORD [    size: CARDINAL ¬ 0,    zone: UNCOUNTED ZONE ¬ NULL,  -- zone for strings below    body: SEQUENCE maxsize: CARDINAL OF      RECORD [        shortname: LONG STRING ¬ NIL, -- NIL for relLocMap        lhsHost: LONG STRING ¬ NIL,   -- from loc        lhsDirectory: LONG STRING ¬ NIL,        rhsHost: LONG STRING ¬ NIL,   -- to loc        rhsDirectory: LONG STRING ¬ NIL]];   -- Phase 2  VerifySufficiency: PUBLIC PROC [      topdffilename: LONG STRING,      exec: Exec.Handle, window: Window.Handle, checkForOverwrite: BOOLEAN] = {    dfseq: DFSubr.DFSeq ¬ NIL;    sh: Stream.Handle ¬ NIL;    df: DFSubr.DF;        CleanUp: PROC = {      IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL};      IF dfseq # NIL THEN DFSubr.FreeDFSeq[@dfseq]};          BEGIN ENABLE UNWIND => CleanUp[];    td ¬ ReleaseInterface.toolData;    CWF.WF1["Opening %s.\n"L, topdffilename];    sh ¬ Transfer.CachedOpen[      host: NIL, directory: NIL, name: topdffilename,      wantCreateTime: Time.Packed[0],      wantExplicitVersion: FALSE, version: 0,      checkForOverwrite: checkForOverwrite, window: window,      retrieveToTemp: FALSE, localDir: NIL       ! Subr.FileError => GOTO notfound];    IF sh = NIL THEN GOTO notfound;    dfseq ¬ DFSubr.AllocateDFSeq[maxEntries: MAXFILES, zoneType: shared];    DFSubr.ParseStream[      sh: sh, dfseq: dfseq, dffilename: topdffilename, using: NIL,      noremoteerrors: FALSE, forceReadonly: FALSE, omitNonPublic: FALSE,      limitErrors: TRUE      ! DFSubr.TooManyParseErrors => {          CWF.WF1[" - parse abandoned, too many errors in %s.\n"L, topdffilename];	  GOTO leave}];    Stream.Delete[sh];  sh ¬ NIL;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF df.atsign AND ~df.readonly AND ~df.cameFrom THEN        VerifyThisPackage[          df.host, df.directory, df.shortname,	  df.version, df.createtime,	  exec, window, checkForOverwrite, df.criterion = none];      ReleaseInterface.FlushLog[];      ENDLOOP;    EXITS      notfound => {        CWF.WF1["Error - can't open %s.\n"L, topdffilename];	Subr.errorflg ¬ TRUE};      leave => NULL;    END;    CleanUp[]};  -- this is called once for each of the first level of the tree below the root  -- that is, for each of the Includes of the root DF for the release  -- host and directory may be NIL  VerifyThisPackage: PROC [      host, directory, shortname: LONG STRING, version: CARDINAL,      createtime: Time.Packed, exec: Exec.Handle, window: Window.Handle,      checkForOverwrite, wantExplicitVersion: BOOLEAN] = {    dfseq: DFSubr.DFSeq ¬ NIL;    sh: Stream.Handle ¬ NIL;    plus, nonLeaf: BOOLEAN ¬ FALSE;    df: DFSubr.DF;    opt: VerifyDFInterface.Options ¬ [      checkForOverwrite:     checkForOverwrite,      printFlattened:	     FALSE,      checkIfFilesNeeded:    FALSE,      useHugeZone:	     FALSE,  -- so as to recycle dfSeq storage      fileForMissingEntries: TRUE,      retrieveDFsToTemp:     FALSE,      verbose:		     td.verbose,      debugging:	     FALSE];        CheckAbort: VerifyDFInterface.CheckAbortProc = {      RETURN[        IF window # NIL THEN UserInput.UserAbort[window]	ELSE Exec.CheckForAbort[exec]]};        CleanUp: PROC = {      IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL};      IF dfseq # NIL THEN DFSubr.FreeDFSeq[@dfseq]};        BEGIN ENABLE UNWIND => CleanUp[];    CWF.WF1["\nOpening %s.\n"L, shortname];    sh ¬ Transfer.CachedOpen[      host: host, directory: directory, name: shortname,      wantCreateTime: createtime,      wantExplicitVersion: wantExplicitVersion, version: version,      checkForOverwrite: checkForOverwrite, window: window,      retrieveToTemp: FALSE, localDir: NIL      ! Subr.FileError => GOTO notfound];    IF sh = NIL THEN GOTO notfound;    dfseq ¬ DFSubr.AllocateDFSeq[maxEntries: MAXFILES, zoneType: shared];    DFSubr.ParseStream[      sh: sh, dfseq: dfseq, dffilename: shortname, using: NIL,      noremoteerrors: FALSE, forceReadonly: FALSE, omitNonPublic: FALSE,      limitErrors: TRUE      ! DFSubr.TooManyParseErrors => {          CWF.WF1[" - parse abandoned, too many errors in %s.\n"L, shortname];	  GOTO leave}];    Stream.Delete[sh];  sh ¬ NIL;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF df.atsign AND ~df.readonly AND ~df.cameFrom THEN nonLeaf ¬ TRUE;      ENDLOOP;    -- at this point all nested DF files have been verified    plus ¬ FALSE;    FOR i: CARDINAL IN [0..dfseq.size) DO      IF dfseq[i].topmark THEN plus ¬ TRUE;      ENDLOOP;    DFSubr.FreeDFSeq[@dfseq];    IF ~nonLeaf AND ~plus THEN {      CWF.WF1[        "No + files in %s, a file that Includes no other DF files.\n"L,        shortname];      RETURN};    CWF.WF1["VerifyDF of %s started.\n"L, shortname];    VerifyDFInterface.VerifyDFFile[      dfFileName: shortname, exec: exec, window: window,      opt: opt, abortProc: CheckAbort      ! Heap.Error => {          CWF.WF1[	    "\nHeap.Error while verifing %s - continuing on...\n"L, shortname];	  CONTINUE}];    CWF.WF1["VerifyDF of %s complete.\n"L, shortname];    EXITS      notfound => {        IF host # NIL THEN          CWF.WF3["Error - can't open [%s]<%s>%s"L, host, directory, shortname]        ELSE CWF.WF1["Error - can't open %s.\n"L, shortname];	Subr.errorflg ¬ TRUE};      leave => NULL;    END};  -- Phase 3  -- at this point we know all the files exist and are consistent  -- thus we go ahead and store the files in their  -- new release directories, producing new DF files as we go  -- this is done bottom up-recursive, roughly as SModel does it.  -- dfseqall comes from the Phase 1 cache that was saved.  TransferFiles: PUBLIC PROC [      topdffilename: LONG STRING, dfseqall: DFSubr.DFSeq,      exec: Exec.Handle, window: Window.Handle,      checkForOverwrite, usePhase3BTree, verbose: BOOLEAN] = {    dfseq: DFSubr.DFSeq ¬ NIL;    outofspace: BOOLEAN ¬ FALSE;    df: DFSubr.DF;    Cleanup: PROC = {      CWF.WF0["\n\nSummary for phase 3: (page counts assume 2048 byte pages)\n"L];      CWF.WF2["\t%u non-DF files being released, %lu pages in those files,\n",	@nFilesToRelease, @nPagesToRelease];      CWF.WF2["\t%u non-DF files actually copied, %lu pages in those files,\n",	@nFilesStored, @nPagesStored];      CWF.WF2["\t%u non-DF files already in release position, %lu pages in those files,\n",	@nFilesNotStored, @nPagesNotStored];      CWF.WF2["\t%u DF files written, %u files skipped entirely (CameFrom).\n",	@nDFFilesStored, @nFilesSkipped];      Transfer.CloseCopyConnection[];      ReleaseBTree[];      DFSubr.FreeDFSeq[@dfseq]};    BEGIN ENABLE UNWIND => Cleanup[];    td ¬ ReleaseInterface.toolData;    prevLineWasDots ¬ FALSE;    IF usePhase3BTree THEN {CreateBTree[];  td.useOldPhase3Cache ¬ TRUE}    ELSE td.useOldPhase3Cache ¬ FALSE;    nDFFilesStored ¬ nFilesSkipped ¬ 0;    nFilesToRelease ¬ nFilesStored ¬ nFilesNotStored ¬ 0;    nPagesToRelease ¬ nPagesStored ¬ nPagesNotStored ¬ 0;    IF dfseqall = NIL THEN {      CWF.WF0[        "Error - ReleaseTool data reset: Phase 3 must be run immediately after Phase 1 or a UseOldPhase1Data call.\n"L];      ReleaseBTree[];      RETURN};    IF dfseqall.size < 10 OR dfseqall.size > 15000 THEN       CWF.WF0[        "Warning - ReleaseTool data seems suspicious: suggest you rerun Phase 1 or use a UseOldPhase1Data call.\n"L];    -- set final DF create times    SetDFFileCreateTimes[dfseqall];    IF window # NIL THEN {      IF UserInput.UserAbort[window] THEN ERROR ABORTED}    ELSE IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    Transfer.OpenCopyConnection[];    -- Create outer top level DF for the recursive store of the DF.    dfseq ¬ DFSubr.AllocateDFSeq[maxEntries: 1, zoneType: shared];    -- indirect this df file    df ¬ DFSubr.NextDF[dfseq];    -- Umbrella DF. name set.    df.shortname ¬ Subr.CopyString[topdffilename, dfseq.dfzone];    df.atsign ¬ TRUE;    outofspace ¬ RecursiveStoreDF[      dfseqouter: dfseq, topdfouter: NIL, dfseqall: dfseqall,      exec: exec, window: window, checkForOverwrite: checkForOverwrite,      verbose: verbose];    Cleanup[];    END};  -- make up create times for the DF files we will write out  SetDFFileCreateTimes: PROC [dfseq: DFSubr.DFSeq] = {    time: Time.Packed ¬ Time.Current[];    df, dfj: DFSubr.DF; -- DF to be checked and for the different versions    CWF.WF0["\nSetting final create times for the DF files to be written.\n"L];    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      -- Keep release runner believe the program is still running.      CWF.WFC['.];       -- Must be a DF, Non released file, not imported or readonly, and is a "releasable" file, and not the "owner of df"?.      IF ~df.cameFrom AND ~df.readonly AND df.releaseDirectory # NIL AND Subr.EndsIn[df.shortname, ".df"L]      AND ~String.Equivalent[df.shortname, df.recorder] THEN {        -- Set up bogus time and version number.        df.createtime ¬ time;  df.version ¬ 0;	-- Increment bogus time by a second. Note use of record constructor.        time ¬ [time + 1];	-- now see if there are any refs to different versions of this df file.         FOR j: CARDINAL IN [0..dfseq.size) DO	  dfj ¬ @dfseq[j];	  -- Avoid checking itself and as an optimization, use this short circuited smt to make sure that the name is the same.  Name length equivalent is sufficient to screen out most of them.          IF i # j	  AND dfj.shortname.length = df.shortname.length          AND String.Equivalent[dfj.shortname, df.shortname] THEN {            IF String.Equivalent[dfj.host, df.host]            AND String.Equivalent[dfj.directory, df.directory] THEN {	      -- Same name!	      dfj.createtime ¬ df.createtime;  dfj.version ¬ 0}            ELSE {	      -- dfj refers to a version of df on a different directory.	      -- This is OK if we will later map df's RHS release location to be	      -- the same as dfj's LHS Imports/Includes directory.	      IF SameEventualReleaseLoc[newDef: df, oldRef: dfj] THEN {	        dfj.createtime ¬ df.createtime;  dfj.version ¬ 0}	      ELSE                CWF.WF4[                  "Warning: %s refers to a version of %s (on [%s]<%s>) that is not being released.\n"L,                  dfj.recorder, dfj.shortname, dfj.host, dfj.directory]}};          ENDLOOP};      ENDLOOP;      CWF.WFCR[]};        SameEventualReleaseLoc: PROC [      newDef, oldRef: DFSubr.DF] RETURNS [yes: BOOLEAN] = {    -- Will newDef later have its RHS release location mapped    --   (by ChangeReleaseLoc, which also reads Release.ChangeReleaseLoc)    --   to be the same as oldRef's LHS Imports/Includes directory?    source, pattern: String.SubStringDescriptor;    patternLen: CARDINAL;    newDir: STRING ¬ [100];    IF relLocMap = NIL THEN      relLocMap ¬ ReadInAndParseDFMap[        fileName: "Release.ChangeReleaseLoc"L, setShortName: FALSE];    IF String.Empty[newDef.releaseHost]      OR String.Empty[newDef.releaseDirectory] THEN RETURN[yes: FALSE];    source.base ¬ newDef.releaseDirectory;  source.offset ¬ 0;    pattern.offset ¬ 0;    -- if relLocMap.size = 0, then couldn't open Release.ChangeReleaseLoc    FOR i: CARDINAL IN [0..relLocMap.size) DO      IF String.Equivalent[relLocMap[i].lhsHost, newDef.releaseHost] THEN {        -- is relLocMap[i].lhsDirectory = prefix of newDef.releaseDirectory?	patternLen ¬ relLocMap[i].lhsDirectory.length;	IF newDef.releaseDirectory.length < patternLen THEN LOOP;	pattern.base ¬ relLocMap[i].lhsDirectory;	source.length ¬ pattern.length ¬ patternLen;        IF String.EquivalentSubString[@source, @pattern] 	AND (	  newDef.releaseDirectory.length = patternLen	  OR newDef.releaseDirectory[patternLen] = '>)	THEN {  -- match	  String.AppendString[newDir, relLocMap[i].rhsDirectory];	  -- now append rest of old release directory	  FOR j: CARDINAL IN [patternLen..newDef.releaseDirectory.length) DO	    String.AppendChar[newDir, newDef.releaseDirectory[j]];	    ENDLOOP;	  IF String.Equivalent[newDir, oldRef.directory]	  AND String.Equivalent[relLocMap[i].rhsHost, oldRef.host] THEN	    RETURN[yes: TRUE]}};      ENDLOOP;    RETURN[yes: FALSE]};  -- topdfouter may be NIL  RecursiveStoreDF: PROC [        dfseqouter: DFSubr.DFSeq, topdfouter: DFSubr.DF, dfseqall: DFSubr.DFSeq,        exec: Exec.Handle, window: Window.Handle,	checkForOverwrite, verbose: BOOLEAN]      RETURNS [outofspace: BOOLEAN] = {    sh: Stream.Handle ¬ NIL;    dfouter, df: DFSubr.DF;    o: BOOLEAN;    dfseqinner: DFSubr.DFSeq ¬ NIL;        CleanUp: PROC = {      IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL};      IF dfseqinner # NIL THEN DFSubr.FreeDFSeq[@dfseqinner]};          outofspace ¬ FALSE;    -- for each file in the containing DF...    FOR i: CARDINAL IN [0..dfseqouter.size) DO      dfouter ¬ @dfseqouter[i];      IF dfouter.atsign AND ~dfouter.readonly      AND ~(dfouter.cameFrom AND dfouter.releaseDirectory # NIL) THEN {        -- is a non-readonly DF file (i.e. OWNED DF)        BEGIN ENABLE UNWIND => CleanUp[];        -- recur on lower DF file        -- once it returns, we know the files are all stored and         -- the release directories have been swapped        -- now this level (parent) can STORE the DF file        IF window # NIL THEN {          IF UserInput.UserAbort[window] THEN ERROR ABORTED}        ELSE IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;        dfseqinner ¬ DFSubr.AllocateDFSeq[maxEntries: MAXFILES, zoneType: shared];        sh ¬ Transfer.CachedOpen[          host: dfouter.host, directory: dfouter.directory,          name: dfouter.shortname,	  wantCreateTime: dfouter.createtime, 	  wantExplicitVersion: dfouter.criterion = none, version: dfouter.version,          checkForOverwrite: checkForOverwrite, window: window,	  retrieveToTemp: FALSE, localDir: NIL          ! Subr.FileError => GOTO err];        IF sh = NIL THEN GOTO err;	IF ~verbose THEN CWF.WFCR[];        CWF.WF1["Opening %s.\n"L, dfouter.shortname];        IF window # NIL THEN {          IF UserInput.UserAbort[window] THEN ERROR ABORTED}        ELSE IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;        DFSubr.ParseStream[          sh: sh, dfseq: dfseqinner, dffilename: dfouter.shortname, using: NIL,	  noremoteerrors: FALSE, forceReadonly: FALSE, omitNonPublic: FALSE,	  limitErrors: TRUE	  ! DFSubr.TooManyParseErrors => {	      CWF.WF1[	        " - parse abandoned, too many errors in %s.\n"L,		dfouter.shortname];	      GOTO leave}];        Stream.Delete[sh];  sh ¬ NIL;	-- *** In just parsed inner df sequence - 	-- ***   Delete any CameFrom clauses on "Imports Foo.df" lines.	-- ***   Change release location on any "Includes Foo.df" lines 	FOR i: CARDINAL IN [0..dfseqinner.size) DO	  df ¬ @dfseqinner[i];	  IF df.atsign AND df.cameFrom	  AND Subr.EndsIn[df.shortname, ".df"L] THEN {	    df.cameFrom ¬ FALSE;	    -- Imported or Included DF file w/ CameFrom	    IF df.readonly THEN {  -- Imported	      IF df.releaseHost # NIL THEN		Subr.FreeString[df.releaseHost, dfseqinner.dfzone];	      df.releaseHost ¬ NIL;	      IF df.releaseDirectory # NIL THEN		Subr.FreeString[df.releaseDirectory, dfseqinner.dfzone];	      df.releaseDirectory ¬ NIL}	    ELSE {	      -- Controversial:	      --   change "Includes X CameFrom Y" to "Includes X ReleaseAs X" 	      IF df.releaseHost # NIL THEN		Subr.FreeString[df.releaseHost, dfseqinner.dfzone];	      IF df.releaseDirectory # NIL THEN		Subr.FreeString[df.releaseDirectory, dfseqinner.dfzone];	      df.releaseHost ¬ Subr.CopyString[df.host, dfseqinner.dfzone];	      df.releaseDirectory ¬ Subr.CopyString[	        df.directory, dfseqinner.dfzone];	      IF df.createtime > 0 THEN df.version ¬ 0}};	  ENDLOOP;        o ¬ RecursiveStoreDF[          dfseqouter: dfseqinner, topdfouter: dfouter, dfseqall: dfseqall,	  exec: exec, window: window, checkForOverwrite: checkForOverwrite,	  verbose: verbose];        SetCreateDateAndVersion[dfouter, dfseqall];        outofspace ¬ outofspace OR o;        IF dfouter.releaseDirectory = NIL AND topdfouter # NIL THEN {          CWF.WF2[            "No release directory for %s in %s.\n"L,	    dfouter.shortname, topdfouter.shortname];          DFSubr.FreeDFSeq[@dfseqinner];          LOOP};        IF ~outofspace THEN {	  o ¬ StoreDFFile[dfouter, dfseqinner, dfseqouter, verbose];	  outofspace ¬ outofspace OR o};        EXITS          err => {            IF dfouter.host # NIL THEN              CWF.WF3[                "Error - can't open [%s]<%s>%s"L, dfouter.host, dfouter.directory,                dfouter.shortname]            ELSE CWF.WF1["Error - can't open %s.\n"L, dfouter.shortname];	    Subr.errorflg ¬ TRUE};	  leave => NULL;	END;	CleanUp[];	ReleaseInterface.FlushLog[];        LOOP};      -- "regular" file or Imported DF file      IF dfouter.atsign AND dfouter.readonly      AND Subr.EndsIn[dfouter.shortname, ".df"L] THEN  -- Imported DF file	-- handle case where special map to prerelease directory is needed	CoerceDFLocToAnother[	  df: dfouter, dfseq: dfseqouter, containingDFName: topdfouter.shortname,	  verbose: verbose];      IF dfouter.cameFrom AND dfouter.releaseDirectory # NIL THEN {        IF verbose THEN {	  CWF.WF4[            "Leaving [%s]<%s>%s in %s alone.\n"L,	    dfouter.host, dfouter.directory, dfouter.shortname,	    topdfouter.shortname];	  ReleaseInterface.FlushLog[]}	ELSE CWF.WFC['.];	nFilesSkipped ¬ nFilesSkipped + 1}      ELSE {         SetCreateDateAndVersion[dfouter, dfseqall];        IF dfouter.releaseDirectory = NIL THEN {          IF dfouter.readonly THEN	    FixupEntriesWithoutReleaseAs[dfouter, dfseqouter, dfseqall]	  ELSE {	    IF ~verbose THEN CWF.WFCR[];            CWF.WF2[              "Error - no release directory specified for %s in %s.\n"L,              dfouter.shortname, topdfouter.shortname]}}        ELSE  -- there is a release directory to copy it to          IF ~String.Equivalent[dfouter.shortname, topdfouter.shortname] THEN {             o ¬ CopyRemoteFile[dfouter, dfseqouter, exec, window, verbose];	    outofspace ¬ outofspace OR o}          ELSE {            -- if it is a self reference, then            -- swap directory entries even though it is not correct            SwapSides[dfouter]}};      ENDLOOP};  -- This maps lines with a directory like   --	Imports [Idun]<APilot100>DF>Compiler.df (an old release location)  -- to be   --	Imports [Igor]<Ramona>DF>Compiler.df (a prerelease directory)  -- for selected DF files.  -- This prerelease directory is then swapped back to the new version  -- on [Idun]<APilot100>DF> by RecursiveStoreDF.  CoerceDFLocToAnother: PROC [      df: DFSubr.DF, dfseq: DFSubr.DFSeq, containingDFName: LONG STRING,      verbose: BOOLEAN] = {    IF dfmap = NIL THEN      dfmap ¬ ReadInAndParseDFMap[        fileName: "Release.DFLocations"L, setShortName: TRUE];    -- if dfmap.size = 0, then couldn't open Release.DFLocations    FOR i: CARDINAL IN [0..dfmap.size) DO      IF String.Equivalent[dfmap[i].shortname, df.shortname]      AND String.Equivalent[dfmap[i].lhsHost, df.host]      AND String.Equivalent[dfmap[i].lhsDirectory, df.directory] THEN {        IF ~verbose THEN CWF.WFCR[];        CWF.WF4[          "Release.DFLocations change: mapping 'Imports [%s]<%s>%s' in %s\n"L,	  df.host, df.directory, df.shortname, containingDFName];        CWF.WF3[          "\tto 'Imports [%s]<%s>%s' (will be remapped later).\n"L,	  dfmap[i].rhsHost, dfmap[i].rhsDirectory, df.shortname];	ReleaseInterface.FlushLog[];        Subr.FreeString[df.host, dfseq.dfzone];        Subr.FreeString[df.directory, dfseq.dfzone];        df.host ¬ Subr.CopyString[dfmap[i].rhsHost, dfseq.dfzone];        df.directory ¬ Subr.CopyString[dfmap[i].rhsDirectory, dfseq.dfzone];        RETURN};      ENDLOOP};  StoreDFFile: PROC [        dfouter: DFSubr.DF, dfseqinner, dfseqouter: DFSubr.DFSeq,        verbose: BOOLEAN]      RETURNS [outofspace: BOOLEAN] = {    sh: Stream.Handle ¬ NIL;    tmpFile: MFile.Handle ¬ NIL;    rem: STRING ¬ [150];    dfinner: DFSubr.DF;    innerZone: UNCOUNTED ZONE = dfseqinner.dfzone;    nBytes: LONG CARDINAL;    version: CARDINAL;    stored: BOOLEAN;    BEGIN      ENABLE UNWIND => {        IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL};	IF tmpFile # NIL THEN {MFile.Release[tmpFile];  tmpFile ¬ NIL}};    outofspace ¬ FALSE;    dfouter.version ¬ 0;    -- change release loc if requested (via Release.ChangeReleaseLoc)    ChangeReleaseLoc[df: dfouter, dfseq: dfseqouter];     SwapSides[dfouter];    -- get the entry for the inner DF file; this is usually a self entry    dfinner ¬ DFSubr.LookupDF[dfseqinner, dfouter.shortname];    IF dfinner # NIL THEN {      IF dfouter.createtime = 0 THEN dfouter.createtime ¬ dfinner.createtime      ELSE dfinner.createtime ¬ dfouter.createtime;      dfinner.version ¬ 0;      IF dfouter.host # NIL THEN {        Subr.FreeString[dfinner.host, innerZone];        dfinner.host ¬ Subr.CopyString[dfouter.host, innerZone];        Subr.FreeString[dfinner.directory, innerZone];        dfinner.directory ¬ Subr.CopyString[dfouter.directory, innerZone];        Subr.FreeString[dfinner.releaseHost, innerZone];        dfinner.releaseHost ¬ Subr.CopyString[dfouter.releaseHost, innerZone];        Subr.FreeString[dfinner.releaseDirectory, innerZone];        dfinner.releaseDirectory ¬ Subr.CopyString[	  dfouter.releaseDirectory, innerZone];        dfinner.cameFrom ¬ dfouter.cameFrom}      ELSE {        -- no ReleaseAs for dfouter; this may be top-level DF.        -- N.B. dfinner has already had its sides swapped (SwapSides[])        --  by nested RecursiveStore[].        -- Change dfinner's dir (was releasedir) if necessary.	oldCameFrom: BOOLEAN = dfinner.cameFrom;	dfinner.cameFrom ¬ FALSE;  SwapSides[dfinner];	ChangeReleaseLoc[df: dfinner, dfseq: dfseqinner];  -- if necessary	dfinner.cameFrom ¬ FALSE;  SwapSides[dfinner];	dfinner.cameFrom ¬ oldCameFrom}};    -- kludge around FileTransfer's nonsupport of writable remote streams    sh ¬ MStream.WriteOnly[name: "ReleaseTool.tmp$$"L, release: [], type: text];    DFSubr.WriteOut[      dfseq: dfseqinner, topLevelFile: NIL, outputStream: sh, print: FALSE];    Stream.Delete[sh];  sh ¬ NIL;    tmpFile ¬ MFile.ReadOnly[name: "ReleaseTool.tmp$$"L, release: []];    IF dfouter.host # NIL THEN      CWF.SWF3[        rem, "[%s]<%s>%s"L, dfouter.host, dfouter.directory, dfouter.shortname]    ELSE IF dfinner # NIL THEN      CWF.SWF3[        rem, "[%s]<%s>%s"L, dfinner.host, dfinner.directory, dfinner.shortname]    ELSE {      IF ~verbose THEN CWF.WFCR[];      CWF.WF1["Error - don't know where to store %s.\n"L, dfouter.shortname];      RETURN};    IF ~verbose THEN CWF.WFCR[];    CWF.WF1["Storing %s..."L, rem];    [stored: stored, serverFull: outofspace, nBytes: nBytes, version: version] ¬      Transfer.Store[        file: tmpFile, localDate: dfouter.createtime, remoteName: rem];    IF ~stored THEN {      CWF.WF0["NOT STORED"L];      IF outofspace THEN CWF.WF0[" - SERVER FULL.\n"L] ELSE CWF.WF0[".\n"L];      dfouter.version ¬ 0}    ELSE {      CWF.WF2["!%u, %lu bytes.\n"L, @version, @nBytes];      nDFFilesStored ¬ nDFFilesStored + 1;      dfouter.version ¬ version};    ReleaseInterface.FlushLog[];      IF dfinner # NIL THEN dfinner.version ¬ version;    MFile.Release[tmpFile];  tmpFile ¬ NIL;    END};      CopyRemoteFile: PROC [        dfouter: DFSubr.DF, dfseqouter: DFSubr.DFSeq,         exec: Exec.Handle, window: Window.Handle, verbose: BOOLEAN]      RETURNS [outofspace: BOOLEAN] = {    sfnold: STRING ¬ [150];    sfnnew: STRING ¬ [150];    nbytes: LONG CARDINAL ¬ 0;    nIfsPages, vers: CARDINAL;    ok, inCache, stored, serverFull: BOOLEAN;    outofspace ¬ FALSE;    -- change release loc if requested (via Release.ChangeReleaseLoc)    ChangeReleaseLoc[df: dfouter, dfseq: dfseqouter];     [ok, inCache, vers, nIfsPages] ¬ AlreadyExistsInCorrectVersion[      dfouter.releaseHost, dfouter.releaseDirectory, dfouter.shortname,      dfouter.createtime, exec, window];    IF ok THEN {      IF verbose THEN {        CWF.WF4[          "Correct version of [%s]<%s>%s already stored, %u pages"L,          dfouter.releaseHost, dfouter.releaseDirectory, dfouter.shortname,	  @nIfsPages];        CWF.WF1["%s\n"L, IF inCache THEN "  (In cache)"L ELSE ""L];	ReleaseInterface.FlushLog[]}      ELSE {CWF.WFC['.];  prevLineWasDots ¬ TRUE};      SwapSides[dfouter];      dfouter.version ¬ vers;      nFilesNotStored ¬ nFilesNotStored + 1;      nPagesNotStored ¬ nPagesNotStored + nIfsPages;      nFilesToRelease ¬ nFilesToRelease + 1;      nPagesToRelease ¬ nPagesToRelease + nIfsPages;      RETURN};    IF dfouter.version # 0 THEN      CWF.SWF4[        sfnold, "[%s]<%s>%s!%u"L,	dfouter.host, dfouter.directory, dfouter.shortname, @dfouter.version]    ELSE      CWF.SWF3[        sfnold, "[%s]<%s>%s!H"L,	dfouter.host, dfouter.directory, dfouter.shortname];    CWF.SWF3[      sfnnew, "[%s]<%s>%s"L,      dfouter.releaseHost, dfouter.releaseDirectory, dfouter.shortname];    IF ~verbose AND prevLineWasDots THEN CWF.WFCR[];    IF verbose THEN CWF.WF2["Copying %s to %s..."L, sfnold, sfnnew]    ELSE {      IF dfouter.version = 0 THEN CWF.WF1["Copying !H to %s..."L, sfnnew]      ELSE CWF.WF2["Copying !%u to %s..."L, @dfouter.version, sfnnew]};    prevLineWasDots ¬ FALSE;    [stored: stored, serverFull: serverFull, nBytes: nbytes, version: vers] ¬      Transfer.Copy[fromName: sfnold, toName: sfnnew];    IF ~stored THEN {      CWF.WF0["NOT STORED"L];      IF serverFull THEN {CWF.WF0[" - SERVER FULL.\n"L];  outofspace ¬ TRUE}      ELSE IF vers = 1234 THEN CWF.WF0[" - FILE NOT FOUND.\n"L]      ELSE CWF.WF0[".\n"L];      dfouter.version ¬ 0;      SwapSides[dfouter]}    ELSE {        CWF.WF2["!%u, %lu bytes.\n"L, @vers, @nbytes];      dfouter.version ¬ vers;      SwapSides[dfouter];      nIfsPages ¬ Inline.LowHalf[(nbytes/bytesPerIFSPage) + 2];      nFilesStored ¬ nFilesStored + 1;      nPagesStored ¬ nPagesStored + nIfsPages;      nFilesToRelease ¬ nFilesToRelease + 1;      nPagesToRelease ¬ nPagesToRelease + nIfsPages;      InsertInBTree[        dfouter.host, dfouter.directory, dfouter.shortname, 	dfouter.version, dfouter.createtime, nIfsPages]};    ReleaseInterface.FlushLog[]};      AlreadyExistsInCorrectVersion: PROC [        host, directory, shortname: LONG STRING, createtime: Time.Packed,        exec: Exec.Handle, window: Window.Handle]      RETURNS [foundonremote, inCache: BOOLEAN, vers, nIfsPages: CARDINAL] = {    sfn: STRING ¬ [150];    foundonremote ¬ inCache ¬ FALSE;  vers ¬ 0;  nIfsPages ¬ 0;    IF window # NIL THEN {      IF UserInput.UserAbort[window] THEN ERROR ABORTED}    ELSE IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    [inCache, vers, nIfsPages] ¬ LookupInBTree[      host, directory, shortname, createtime];    IF inCache THEN      RETURN[        foundonremote: TRUE, inCache: TRUE, vers: vers, nIfsPages: nIfsPages];    -- not in cache, we have to look on server; consider !H     CWF.SWF3[sfn, "[%s]<%s>%s!H"L, host, directory, shortname];    [foundonremote, vers, nIfsPages] ¬ CheckHighestRemoteVersion[sfn, createtime];    IF foundonremote THEN       InsertInBTree[host, directory, shortname, vers, createtime, nIfsPages]};      CheckHighestRemoteVersion: PROC [        remoteName: STRING, createtime: Time.Packed]      RETURNS [foundonremote: BOOLEAN, vers, nIfsPages: CARDINAL] = {          ConsiderBangH: FileTransfer.ListProc = {      remoteInfo: FileTransfer.FileInfo ¬ info[conn].source;      IF createtime = remoteInfo.create THEN {        foundonremote ¬ TRUE;	IF ~String.Empty[remoteInfo.version] THEN          vers ¬ String.StringToDecimal[remoteInfo.version	    ! String.InvalidNumber => {vers ¬ 0;  CONTINUE}];	nIfsPages ¬ Inline.LowHalf[(remoteInfo.size/bytesPerIFSPage) + 2]};      RETURN[do]};          foundonremote ¬ FALSE;  vers ¬ 0;  nIfsPages ¬ 0;    Transfer.EnumerateForProperties[      fileName: remoteName, enumProc: ConsiderBangH]};        SetCreateDateAndVersion: PROC [      df: DFSubr.DF, dfseqall: DFSubr.DFSeq] = {    dfall: DFSubr.DF;    FOR i: CARDINAL IN [0..dfseqall.size) DO      dfall ¬ @dfseqall[i];      IF dfall.createtime # 0      AND String.Equivalent[dfall.shortname, df.shortname]      AND String.Equivalent[dfall.directory, df.directory]      AND String.Equivalent[dfall.host, df.host] THEN {        df.createtime ¬ dfall.createtime;	df.version ¬ dfall.version;	RETURN};      ENDLOOP;    df.version ¬ 0};      ChangeReleaseLoc: PROC [df: DFSubr.DF, dfseq: DFSubr.DFSeq] = {    source, pattern: String.SubStringDescriptor;    patternLen, dfReleaseDirLen: CARDINAL;    newDir: STRING ¬ [100];    IF relLocMap = NIL THEN      relLocMap ¬ ReadInAndParseDFMap[        fileName: "Release.ChangeReleaseLoc"L, setShortName: FALSE];    IF String.Empty[df.releaseHost] OR String.Empty[df.releaseDirectory] THEN      RETURN;    -- pattern (relLocMap[i].lhsDirectory) has form "<APilot>"    source.base ¬ df.releaseDirectory;  source.offset ¬ 0;    pattern.offset ¬ 0;    -- if relLocMap.size = 0, then couldn't open Release.ChangeReleaseLoc    FOR i: CARDINAL IN [0..relLocMap.size) DO      IF String.Equivalent[relLocMap[i].lhsHost, df.releaseHost] THEN {        -- is relLocMap[i].lhsDirectory = prefix of df.releaseDirectory?	patternLen ¬ relLocMap[i].lhsDirectory.length;	IF df.releaseDirectory.length < patternLen THEN LOOP;	pattern.base ¬ relLocMap[i].lhsDirectory;	source.length ¬ pattern.length ¬ patternLen;        IF String.EquivalentSubString[@source, @pattern] 	AND (	  df.releaseDirectory.length = patternLen	  OR df.releaseDirectory[patternLen] = '>)	THEN {  -- match	  String.AppendString[newDir, relLocMap[i].rhsDirectory];	  -- now append rest of old release directory	  dfReleaseDirLen ¬ df.releaseDirectory.length;	  FOR j: CARDINAL IN [patternLen..dfReleaseDirLen) DO	    String.AppendChar[newDir, df.releaseDirectory[j]];	    ENDLOOP;	  Subr.FreeString[df.releaseHost, dfseq.dfzone];	  df.releaseHost ¬ Subr.CopyString[	    relLocMap[i].rhsHost, dfseq.dfzone];	  df.releaseDirectory ¬ Subr.CopyString[newDir, dfseq.dfzone];	  RETURN}};      ENDLOOP};   ReadInAndParseDFMap: PROC [      fileName: LONG STRING, setShortName: BOOLEAN] RETURNS [map: DFMap] = {    i: CARDINAL;    inbracket: BOOLEAN ¬ FALSE;    sh: MStream.Handle ¬ NIL;    stemp: STRING ¬ [100];    line: STRING ¬ [100];    host: STRING ¬ [100];    directory: STRING ¬ [100];    shortname: STRING ¬ [100];    longzone: UNCOUNTED ZONE ¬ Subr.LongZone[];    BEGIN ENABLE UNWIND => {IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL}};    map ¬ longzone.NEW[DFMapSeq[NMAPENTRIES]];    map.zone ¬ longzone;    sh ¬ MStream.ReadOnly[fileName, []       ! MStream.Error => {          CWF.WF1["\nWarning - Cannot open %s.\n"L, fileName];  GOTO out}];    CWF.WF1["Reading DF mapping from file %s.\n"L, fileName];    WHILE Subr.GetLine[sh, line] DO      inbracket ¬ FALSE;      -- A comment?      IF line.length = 0 OR Subr.Prefix[line, "//"L] OR Subr.Prefix[line, "--"L]        THEN LOOP;      IF map.size > map.maxsize THEN {        CWF.WF0["Error - too many DFLocations.\n"L];  EXIT};      i ¬ 0;      -- Get length of first string...(lhs)      WHILE i < line.length DO        IF line[i] = '[ THEN inbracket ¬ TRUE;	IF line[i] = '] AND inbracket THEN inbracket ¬ FALSE;	IF ~inbracket AND (line[i] = '  OR line[i] = Ascii.TAB) THEN EXIT;        i ¬ i + 1;	ENDLOOP;      IF i >= line.length THEN {        CWF.WF1["Error - this line needs two file names on it: %s.\n"L, line];        EXIT};      Subr.StrCopy[stemp, line];      stemp.length ¬ i;      Subr.SubStrCopy[line, line, i];      Subr.StripLeadingBlanks[line];      [] ¬ DFSubr.StripLongName[stemp, host, directory, shortname, FALSE];      IF setShortName THEN        map[map.size].shortname ¬ Subr.CopyString[shortname, longzone]      ELSE map[map.size].shortname ¬ NIL;      map[map.size].lhsHost ¬ Subr.CopyString[host, longzone];      map[map.size].lhsDirectory ¬ Subr.CopyString[directory, longzone];      [] ¬ DFSubr.StripLongName[line, host, directory, shortname, FALSE];      IF setShortName      AND ~String.Equivalent[shortname, map[map.size].shortname] THEN {        CWF.WF1[          "Error - line including %s does not have shortnames that match.\n"L,          line];        LOOP};      map[map.size].rhsHost ¬ Subr.CopyString[host, longzone];      map[map.size].rhsDirectory ¬ Subr.CopyString[directory, longzone];      map.size ¬ map.size + 1;      ENDLOOP;    Stream.Delete[sh];  sh ¬ NIL;    EXITS out => NULL;    END};  -- note that it doesn't check create times  -- called only when releaseDirectory = NIL  -- *** We now do not write "Imports Foo.df" lines with CameFrom clauses.   FixupEntriesWithoutReleaseAs: PROC [      df: DFSubr.DF, dfseq, dfseqall: DFSubr.DFSeq] = {    dfall: DFSubr.DF;    isImportedDF: BOOLEAN ¬ FALSE;    FOR i: CARDINAL IN [0..dfseqall.size) DO      dfall ¬ @dfseqall[i];      IF dfall.releaseDirectory # NIL AND ~dfall.cameFrom      AND String.Equivalent[dfall.shortname, df.shortname]      AND String.Equivalent[dfall.directory, df.directory]      AND String.Equivalent[dfall.host, df.host]      AND ~String.Equivalent[dfall.shortname, dfall.recorder] THEN {        df.releaseHost ¬ Subr.CopyString[dfall.releaseHost, dfseq.dfzone];        df.releaseDirectory ¬ Subr.CopyString[	  dfall.releaseDirectory, dfseq.dfzone];        df.createtime ¬ dfall.createtime;        df.version ¬ dfall.version;	IF df.atsign AND df.readonly AND ~df.cameFrom	AND Subr.EndsIn[df.shortname, ".df"L] THEN {  -- Imported DF file	  ChangeReleaseLoc[df, dfseq];	  isImportedDF ¬ TRUE};        SwapSides[df];	IF isImportedDF THEN {  -- *** discard CameFrom clause	  Subr.FreeString[df.releaseHost, dfseq.dfzone];	  df.releaseHost ¬ NIL;            Subr.FreeString[df.releaseDirectory, dfseq.dfzone];	  df.releaseDirectory ¬ NIL;	  df.cameFrom ¬ FALSE};        RETURN};      ENDLOOP};  SwapSides: PROC [df: DFSubr.DF] = {    s: LONG STRING;    IF df.cameFrom THEN RETURN;  -- should never be called if already CameFrom    df.cameFrom ¬ ~df.cameFrom;    s ¬ df.releaseHost;  df.releaseHost ¬ df.host;  df.host ¬ s;    s ¬ df.directory;  df.directory ¬ df.releaseDirectory;    df.releaseDirectory ¬ s};     -- Copied file cache BTree code  LookupInBTree: PROC [        host, directory, shortname: LONG STRING, createtime: Time.Packed]      RETURNS [inCache: BOOLEAN, version, nIfsPages: CARDINAL] = {    cache: ReleaseCache.Cache ¬ LOOPHOLE[td.phase3BTree];    inCache ¬ FALSE;  version ¬ 0;  nIfsPages ¬ 0;    IF createtime = 0 OR ~td.oldPhase3CacheExists      OR ~td.useOldPhase3Cache THEN RETURN;    [inCache: inCache, version: version, nIfsPages: nIfsPages] ¬       ReleaseCache.Lookup[cache, host, directory, shortname, createtime]};  InsertInBTree: PROC [      host, directory, shortname: LONG STRING, version: CARDINAL,      createtime: Time.Packed, nIfsPages: CARDINAL] = {    cache: ReleaseCache.Cache ¬ LOOPHOLE[td.phase3BTree];    ReleaseCache.Insert[      cache, host, directory, shortname, createtime, version, nIfsPages]};      CreateBTree: PROC = {    file: MFile.Handle ¬ NIL;    BEGIN ENABLE UNWIND => IF file # NIL THEN MFile.Release[file];    td.oldPhase3CacheExists ¬ TRUE;    file ¬ MFile.Acquire[      name: "ReleaseTool.Phase3Cache"L, access: anchor, release: []      ! MFile.Error => {td.oldPhase3CacheExists ¬ FALSE;  CONTINUE}];    IF file # NIL THEN {MFile.Release[file];  file ¬ NIL};    td.phase3BTreeFile ¬ LOOPHOLE[LONG[1]];    td.phase3BTree ¬ LOOPHOLE[ReleaseCache.Make["ReleaseTool.Phase3Cache"L]];    END};  ReleaseBTree: PROC = {    IF td.phase3BTreeFile # NIL THEN {      ReleaseCache.Close[LOOPHOLE[td.phase3BTree]];      td.phase3BTree ¬ NIL;      td.phase3BTreeFile ¬ NIL};    td.oldPhase3CacheExists ¬ FALSE};  END.Change log:10-Dec-84 14:19:54	DSC  	Added more dot processing, fixued up weird comments. Minor stuff.. 4-Mar-85 12:35:36	DSC  	Fixed ReadInAndParseDFMap to allows LHS to include spaces.
-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- DFDeleteImpl.mesa - Last edited by--   Schmidt	 9-Mar-82 17:05:33--   BTL  	19-Aug-83 11:19:52DIRECTORY  CWF USING [WF0, WF1, WF2],  DFDeleteInterface USING [CheckAbortProc, Options],  DFSubr USING [    AllocateDFSeq, DF, DFSeq, FlattenDF, FreeDFSeq, LookupFiles, LookupOneFile,    NextDF, ParseStream, SortByFileName, TooManyEntries, TooManyParseErrors],  Exec USING [Handle],  Format USING [StringProc],  MFile USING [GetCreateDate, SetAccess],  MStream USING [Create, Error, Handle, WriteOnly],  Stream USING [Delete],  Subr USING [CopyString, EndsIn, errorflg],  Time USING [Packed],  Window USING [Handle];DFDeleteImpl: MONITOR    IMPORTS CWF, DFSubr, MFile, MStream, Stream, Subr    EXPORTS DFDeleteInterface =  BEGIN  MaxFlattenedFiles: CARDINAL = 600;  MaxSingleDFFiles: CARDINAL = 400;  nowRunning: BOOLEAN ¬ FALSE;  checkAbort: DFDeleteInterface.CheckAbortProc;  lineDotCm: MStream.Handle ¬ NIL;       -- serialization  AlreadyRunning: PUBLIC ENTRY PROC RETURNS [yes: BOOLEAN] = {    IF nowRunning THEN RETURN[TRUE];    nowRunning ¬ TRUE;    RETURN[FALSE]};    DoneRunning: PUBLIC ENTRY PROC = {nowRunning ¬ FALSE};      Initialize: PUBLIC PROC = {lineDotCm ¬ NIL};      Finalize: PUBLIC PROC = {    IF lineDotCm # NIL THEN Stream.Delete[lineDotCm];    lineDotCm ¬ NIL};   -- Main DF deletion procedure  DeleteDF: PUBLIC PROC [      dfFileName: LONG STRING, opt: DFDeleteInterface.Options,      exec: Exec.Handle, window: Window.Handle,      abortProc: DFDeleteInterface.CheckAbortProc] = {    checkAbort ¬ abortProc;    BEGIN      ENABLE DFSubr.TooManyEntries => {        CWF.WF1["Error - too many file entries in %s.\n"L, dfFileName];        Subr.errorflg ¬ TRUE;        GOTO cant};    IF opt.alsoDeleteReadOnly THEN DeleteImportsAlso[dfFileName, exec, window]    ELSE OnlyDeleteNonImports[dfFileName];    EXITS cant => NULL;    END};      -- When Imports ARE to be deleted (flattens DF file)  DeleteImportsAlso: PROC [      dfName: LONG STRING, exec: Exec.Handle, window: Window.Handle] = {    dfseq: DFSubr.DFSeq ¬ DFSubr.AllocateDFSeq[      maxEntries: MaxFlattenedFiles, zoneType: shared];    nDeletes: CARDINAL ¬ 0;    BEGIN ENABLE UNWIND => IF dfseq # NIL THEN DFSubr.FreeDFSeq[@dfseq];    CWF.WF1["\nDeleting %s, including its Imported files.\n"L, dfName];    CWF.WF1[      "  (Reading %s and the DF files it Imports and Includes.)\n"L, dfName];    DFSubr.FlattenDF[      dfseq: dfseq, dffilename: dfName, exec: exec, window: window,      retrieveDFsToTemp: TRUE, localDFDir: NIL];    IF dfseq.size = 0 THEN {DFSubr.FreeDFSeq[@dfseq];  RETURN};    -- need ¬ TRUE if file WILL be deleted    FOR i: CARDINAL IN [0..dfseq.size) DO      dfseq[i].need ¬ TRUE;      ENDLOOP;    CWF.WF0["Reading create dates on local disk...\n"L];    CheckCreateDates[dfseq];    DFSubr.SortByFileName[      dfseq: dfseq, min: 0, max: (dfseq.size - 1), ignorehostanddir: TRUE];    nDeletes ¬ GenerateDeleteCmd[dfName, dfseq];    IF nDeletes > 0 THEN      CWF.WF2["\n%u files in %s will be deleted.\n\n"L, @nDeletes, dfName]    ELSE CWF.WF1["\nNo files in %s will be deleted.\n\n"L, dfName];    DFSubr.FreeDFSeq[@dfseq];    END};    CheckCreateDates: PROC [dfseq: DFSubr.DFSeq] = {    df: DFSubr.DF;    localTime: Time.Packed;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF ~df.need OR df.createtime = 0 THEN LOOP;      DFSubr.LookupOneFile[df];      IF df.presentonlocaldisk THEN {        localTime ¬ MFile.GetCreateDate[df.fHandle];        IF localTime # df.createtime THEN {  -- won't be deleted	  df.need ¬ FALSE;	  CWF.WF1["Warning - the local version of %s has"L, df.shortname];	  IF localTime < df.createtime THEN	    CWF.WF2[	      " an OLDER date (%lt) than that in the DF file (%lt).\n"L,	      @localTime, @df.createtime]	  ELSE	    CWF.WF2[	      " a NEWER date (%lt) than that in the DF file (%lt).\n"L,	      @localTime, @df.createtime]}};      ENDLOOP};  GenerateDeleteCmd: PROC [      dfName: LONG STRING, dfseq: DFSubr.DFSeq] RETURNS [nDeletes: CARDINAL] = {    df: DFSubr.DF;    Put: Format.StringProc = {      lineDotCm.put[        sH: lineDotCm,	block: [LOOPHOLE[@s.text], 0, s.length], endRecord: FALSE]};    nDeletes ¬ 0;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF df.need AND df.presentonlocaldisk AND df.createtime # 0 THEN {        nDeletes ¬ nDeletes+1;        IF lineDotCm = NIL THEN {          lineDotCm ¬ MStream.WriteOnly[name: "Line.cm"L, release: [], type: text            ! MStream.Error => {                CWF.WF0["Unable to write delete command on Line.cm.\n"L];	        ERROR ABORTED}];	  Put["Delete.~ "L];          CWF.WF0["\nThe following files will be deleted (see Line.cm).\n"L]};	IF df.shortname.length > 40 THEN	  CWF.WF2["    %s of %lt\n"L, df.shortname, @df.createtime]	ELSE 	  CWF.WF2["    %-40s of %lt\n"L, df.shortname, @df.createtime];        Put[df.shortname];  Put[" "L]};      ENDLOOP};       -- When Imports are NOT to be deleted (doesn't flatten DF file)  OnlyDeleteNonImports: PROC [dfName: LONG STRING] = {    dfSeq: DFSubr.DFSeq ¬ NIL;    df: DFSubr.DF ¬ NIL;    nDeletes: CARDINAL ¬ 0;    BEGIN ENABLE UNWIND => DFSubr.FreeDFSeq[@dfSeq];    IF dfName.length = 0 THEN {      CWF.WF0["Error - empty DF file name.\n"L];      Subr.errorflg ¬ TRUE;  RETURN};    IF ~Subr.EndsIn[dfName, ".df"L] THEN {      CWF.WF1["Error - %s must be a DF file name.\n"L, dfName];      Subr.errorflg ¬ TRUE;  RETURN};    CWF.WF1["Deleting files in %s\n"L, dfName];    IF checkAbort[] THEN ERROR ABORTED;    -- build fake entry     dfSeq ¬ DFSubr.AllocateDFSeq[maxEntries: 1, zoneType: shared];    df ¬ DFSubr.NextDF[dfSeq];    df.shortname ¬ Subr.CopyString[dfName, dfSeq.dfzone];    df.atsign ¬ TRUE;    DFSubr.LookupFiles[dfSeq];  -- get file handle for top level df file    nDeletes ¬ RecursiveDelete[dfSeqOuter: dfSeq, topDfOuter: NIL];    IF nDeletes > 0 THEN      CWF.WF2["\n%u files in %s will be deleted.\n\n"L, @nDeletes, dfName]    ELSE CWF.WF1["\nNo files in %s will be deleted.\n\n"L, dfName];    DFSubr.FreeDFSeq[@dfSeq];    END};  -- dfSeqOuter is allocated and filled with its contents  -- topDfOuter points to the entry in the outer df that indirects thru this DF  -- topDfOuter may be NIL  RecursiveDelete: PROC [        dfSeqOuter: DFSubr.DFSeq, topDfOuter: DFSubr.DF]      RETURNS [nDeletes: CARDINAL] = {    dfOuter: DFSubr.DF;    n: CARDINAL ¬ 0;    nDeletes ¬ 0;    -- now deal with each file in DF list    FOR i: CARDINAL IN [0..dfSeqOuter.size) DO      dfOuter ¬ @dfSeqOuter[i];      n ¬ 0;      IF dfOuter.atsign AND ~dfOuter.readonly      AND Subr.EndsIn[dfOuter.shortname, ".df"L] THEN {  -- Included DF file         IF dfOuter.presentonlocaldisk THEN	  n ¬ ProcessIncludedDFFile[dfOuter, dfSeqOuter, topDfOuter]	ELSE CWF.WF1["Warning - can't open %s.\n"L, dfOuter.shortname]}      ELSE IF topDfOuter = NIL THEN EXIT  -- top level DF file      ELSE {        -- a regular file, an Imported DF file, or a         -- Included DF file that we did not process above	shouldDelete: BOOLEAN ¬ FALSE;	localTime: Time.Packed;	IF ~dfOuter.readonly AND dfOuter.presentonlocaldisk	AND dfOuter.createtime # 0 THEN {	  IF checkAbort[] THEN ERROR ABORTED;          localTime ¬ MFile.GetCreateDate[dfOuter.fHandle];          IF localTime = dfOuter.createtime THEN {	    AddToDeleteCommand[dfOuter.shortname, dfOuter.createtime];	    shouldDelete ¬ TRUE}          ELSE {	    CWF.WF1[	      "Warning - the local version of %s has"L, dfOuter.shortname]; 	    IF localTime < dfOuter.createtime THEN	      CWF.WF2[	        " an OLDER date (%lt) than that in the DF file (%lt).\n"L,	        @localTime, @dfOuter.createtime]	    ELSE	      CWF.WF2[	        " a NEWER date (%lt) than that in the DF file (%lt).\n"L,	        @localTime, @dfOuter.createtime]}};	IF shouldDelete THEN n ¬ 1};       nDeletes ¬ nDeletes + n;       ENDLOOP};        ProcessIncludedDFFile: PROC [        dfOuter: DFSubr.DF, dfSeqOuter: DFSubr.DFSeq, topDfOuter: DFSubr.DF]      RETURNS [nDeletes: CARDINAL] = {    dfSeqInner: DFSubr.DFSeq ¬ NIL;    sh: MStream.Handle ¬ NIL;        CleanUp: PROC = {      IF sh # NIL THEN {        Stream.Delete[sh];  sh ¬ NIL;	dfOuter.fHandle ¬ NIL;  dfOuter.presentonlocaldisk ¬ FALSE};      IF dfSeqInner # NIL THEN DFSubr.FreeDFSeq[@dfSeqInner]};          BEGIN ENABLE UNWIND => CleanUp[];    nDeletes ¬ 0;    IF topDfOuter # NIL THEN      CWF.WF1["\nNested Delete of files in %s.\n"L, dfOuter.shortname];    dfSeqInner ¬ DFSubr.AllocateDFSeq[      maxEntries: MaxSingleDFFiles, zoneType: shared];    MFile.SetAccess[dfOuter.fHandle, readOnly];    sh ¬ MStream.Create[file: dfOuter.fHandle, release: []      ! MStream.Error => {          CWF.WF1["Error - can't open %s.\n"L, dfOuter.shortname];	  Subr.errorflg ¬ TRUE;  GOTO leave}];    DFSubr.ParseStream[      sh: sh, dfseq: dfSeqInner, dffilename: dfOuter.shortname,      using: dfOuter.using,      noremoteerrors: FALSE, forceReadonly: FALSE, omitNonPublic: FALSE,      limitErrors: TRUE      ! DFSubr.TooManyParseErrors => {          CWF.WF1[	    " - parse abandoned, too many errors in %s.\n"L, dfOuter.shortname];	  Subr.errorflg ¬ TRUE;  GOTO leave}];    Stream.Delete[sh];  sh ¬ NIL;    dfOuter.fHandle ¬ NIL;  dfOuter.presentonlocaldisk ¬ FALSE;    IF checkAbort[] THEN ERROR ABORTED;    DFSubr.LookupFiles[dfSeqInner];  -- this fills in all file handles    nDeletes ¬ RecursiveDelete[dfSeqOuter: dfSeqInner, topDfOuter: dfOuter];    IF checkAbort[] THEN ERROR ABORTED;    DFSubr.FreeDFSeq[@dfSeqInner];    IF topDfOuter # NIL THEN      CWF.WF1["End of nested Delete of files in %s.\n\n"L, dfOuter.shortname];    EXITS leave => NULL;    END;    CleanUp[]};      AddToDeleteCommand: PROC [name: LONG STRING, createDate: Time.Packed] = {      Put: Format.StringProc = {      lineDotCm.put[        sH: lineDotCm,	block: [LOOPHOLE[@s.text], 0, s.length], endRecord: FALSE]};          IF lineDotCm = NIL THEN {       lineDotCm ¬ MStream.WriteOnly[name: "Line.cm"L, release: [], type: text        ! MStream.Error => {            CWF.WF0["Unable to write delete command on Line.cm.\n"L];	    ERROR ABORTED}];      CWF.WF0["\nThe following files will be deleted (see Line.cm).\n\n"L];      Put["Delete.~ "L]};    IF name.length > 40 THEN CWF.WF2["    %s of %lt\n"L, name, @createDate]    ELSE CWF.WF2["    %-40s of %lt\n"L, name, @createDate];    Put[name];  Put[" "L]};      END.
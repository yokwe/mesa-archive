-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- DFDeleteExecImpl.mesa - last edited by:--    BTL  	20-May-83 18:27:26--    DSC  	  5-Nov-84  9:48:48DIRECTORY  CWF USING [WFC, WF0, WF1],  DFDeleteInterface USING [    AlreadyRunning, CheckAbortProc, DefaultOptions, DeleteDF,    DoneRunning, Finalize, Initialize, Options],  DFSubr USING [TooManyEntries],  Event USING [DoneWithProcess, Handle, StartingProcess],  Exec USING [    AddCommand, CheckAbortProc, CheckForAbort, ExecProc, FreeTokenString,    GetToken, Handle, Outcome, OutputProc, RemoveCommand],  Format USING[StringProc],  MFile USING [Acquire, AppendErrorMessage, Delete, Error, Handle],  MSegment USING [Error],  MStream USING [Error, Handle, ReadOnly],  Stream USING [Delete, GetChar, EndOfStream],  String USING [AppendExtensionIfNeeded, CopyToNewString, Empty, FreeString],  Subr USING [    AppendMSegmentErrorMessage, AppendMStreamErrorMessage, debugflg, errorflg,    LongZone, PrintGreeting, SetUpCWFWriteProcedure, SubrInit, SubrStop],  Time USING [Current, Packed],  Transfer USING [Finalize, Initialize],  Volume USING [InsufficientSpace];DFDeleteExecImpl: PROGRAM    IMPORTS      CWF, DFDeleteInterface, DFSubr, Event, Exec, MFile, MSegment, MStream,      Stream, String, Subr, Time, Transfer, Volume =  BEGIN  DoDelete: Exec.ExecProc = {    starttime: Time.Packed;    exec: Exec.Handle ¬ h;    temp: MFile.Handle ¬ NIL;    lineDotCm: MStream.Handle ¬ NIL;  -- for echoing Line.cm    myEventHandle: Event.Handle ¬ NIL;        Cleanup: PROC = {      IF lineDotCm # NIL THEN {Stream.Delete[lineDotCm];  lineDotCm ¬ NIL};      Transfer.Finalize[];  Subr.SubrStop[];  DFDeleteInterface.Finalize[];      Event.DoneWithProcess[myEventHandle];  myEventHandle ¬ NIL;      DFDeleteInterface.DoneRunning[]};        BEGIN      ENABLE {        ABORTED => {CWF.WF0["\n...DFDelete Aborted.\n"L];  GOTO abort};        UNWIND => Cleanup[];        Volume.InsufficientSpace => {CWF.WF0["Volume full.\n"L];  GOTO error};	MFile.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];	    CWF.WF1["MFile error: %s.\n"L, msg];   	    GOTO error};	MStream.Error =>  	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMStreamErrorMessage[msg, code, stream];	    CWF.WF1["MStream error: %s.\n"L, msg];   	    GOTO error};	MSegment.Error =>   	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMSegmentErrorMessage[msg, code, segment];	    CWF.WF1["MSegment error: %s.\n"L, msg];   	    GOTO error}};    IF DFDeleteInterface.AlreadyRunning[] THEN {       Exec.OutputProc[h]["\nDFDelete already running!"L];      RETURN[abort]};    starttime ¬ Time.Current[];    outcome ¬ normal;    Subr.SetUpCWFWriteProcedure[];    Subr.SubrInit[exec];      Subr.PrintGreeting["DFDelete"L];    myEventHandle ¬ Event.StartingProcess["DFDelete"L];    Subr.errorflg ¬ Subr.debugflg ¬ FALSE;    Transfer.Initialize[exec: h, window: NIL];  DFDeleteInterface.Initialize[];    -- delete old Line.cm file    temp ¬ MFile.Acquire[name: "Line.cm"L, access: delete, release: []      ! MFile.Error => CONTINUE];    IF temp # NIL THEN {      MFile.Delete[temp ! MFile.Error => CONTINUE];  temp ¬ NIL};    outcome ¬ DeleteFiles[exec];    DFDeleteInterface.Finalize[];    -- echo Line.cm, if created    lineDotCm ¬ MStream.ReadOnly["Line.cm"L, [] ! MStream.Error => GOTO noLineCm];    CWF.WF0["-----------------------------------------------------------\n"L];    CWF.WF0["Contents of Line.cm:\n\n"L];    DO       CWF.WFC[Stream.GetChar[lineDotCm ! Stream.EndOfStream => EXIT]];      ENDLOOP;    Stream.Delete[lineDotCm];  lineDotCm ¬ NIL;    CWF.WF0["\n----------------------------------------------------------\n"L];    EXITS      noLineCm => NULL;      error => outcome ¬ error;      abort => outcome ¬ abort;    END;    IF Subr.errorflg THEN {CWF.WF0["\tErrors logged.\n"L];  outcome ¬ error};    starttime ¬ [Time.Current[] - starttime];    CWF.WF1["\nTotal elapsed time for DFDelete %lr.\n"L, @starttime];    Cleanup[]};      DeleteFiles: PROC [exec: Exec.Handle] RETURNS [outcome: Exec.Outcome] = {    opt, globalOpt: DFDeleteInterface.Options ¬ DFDeleteInterface.DefaultOptions;    dfZone: UNCOUNTED ZONE ¬ Subr.LongZone[];    name, sw: LONG STRING ¬ NIL;    dfName: LONG STRING ¬ NIL;        CheckAbortInExec: DFDeleteInterface.CheckAbortProc = {      RETURN[Exec.CheckForAbort[exec]]};        Cleanup: PROC = {      Transfer.Finalize[];  Subr.SubrStop[];  DFDeleteInterface.Finalize[];      DFDeleteInterface.DoneRunning[]};        outcome ¬ normal;    [name, sw] ¬ Exec.GetToken[exec];    WHILE ~String.Empty[name] OR ~String.Empty[sw] DO      IF ~String.Empty[sw] AND String.Empty[name] THEN {  -- global switches        SetSwitches[@globalOpt, sw];	name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];        [name, sw] ¬ Exec.GetToken[exec];	LOOP};      opt ¬ globalOpt;      IF ~String.Empty[sw] THEN SetSwitches[@opt, sw];      IF ~String.Empty[name] THEN {        dfName ¬ String.CopyToNewString[s: name, z: dfZone, longer: 3];        [] ¬ String.AppendExtensionIfNeeded[	  to: @dfName, extension: ".df"L, z: dfZone];	Subr.debugflg ¬ opt.debugging;	DFDeleteInterface.DeleteDF[	  dfFileName: dfName, opt: opt,	  exec: exec, window: NIL, abortProc: CheckAbortInExec	  ! DFSubr.TooManyEntries => {	      CWF.WF1["Error - too many file entries in %s.\n"L, dfName];	      Subr.errorflg ¬ TRUE;	      CONTINUE}];	String.FreeString[dfZone, dfName];  dfName ¬ NIL};      name ¬ Exec.FreeTokenString[name];  sw ¬ Exec.FreeTokenString[sw];      [name, sw] ¬ Exec.GetToken[exec];      ENDLOOP;    IF Subr.errorflg THEN outcome ¬ error};      SetSwitches: PROC [      opt: POINTER TO DFDeleteInterface.Options, sw: LONG STRING] = {    sense: BOOLEAN ¬ TRUE;    FOR i: CARDINAL IN [0..sw.length) DO      SELECT sw[i] FROM        'r, 'R => {opt.alsoDeleteReadOnly ¬ sense;  sense ¬ TRUE};         'd, 'D => {opt.debugging          ¬ sense;  sense ¬ TRUE}; 	'-, '~ => sense ¬ ~sense;        ENDCASE => {	  CWF.WF1["Unknown switch in '%s'\n"L, sw];  Subr.errorflg ¬ TRUE}      ENDLOOP};      Init: PROC = {Exec.AddCommand[name: "DFDelete.~"L, proc: DoDelete, help: Help,  unload:  Unload]};    Unload: Exec.ExecProc = {  []  ¬  h.RemoveCommand["DFDelete.~"L];  };    Help: Exec.ExecProc = {    OutputProc: Format.StringProc _ Exec.OutputProc[h];    h.OutputProc[]["DFDelete[/<global switches>] DFfile1[/<local switches>]....DFfilen[/<local switches>] Global switches are optional and control the store of subsequent DFs. You can also set global switches by giving an empty DF file name. A switch specification is a letter identifying the switch, optionally preceeded by a '-' or a '~' to reverse the sense of the switch. Switches recognized by DFDelete are:   r=also delete imported and Readonly files."L];  };  Init[];  END.Change Log: 5-Nov-84  9:20:55	DSC  	Added an unload and help proc.  5-Nov-84  9:48:55	DSC  	Set up CWF BEFORE Subr.Init.
-- SubrImpl.mesa - Last edited by--   Schmidt	11-Feb-82 10:22:36--   BTL  	17-Nov-83 15:08:00--   DSC  	11-Feb-86 17:06:40-- Copyright (C) 1982, 1983, 1986  by Xerox Corporation. All rights reserved. DIRECTORY  CmFile USING [Close, Error, FindSection, Handle, NextValue, TableError, UserDotCmOpen],  CWF USING [SetWriteProcedure, SWF1, SWF2, WF0, WF1, WF2, WFCR],  DFWorldTime,  Environment USING [bytesPerPage, PageFromLongPointer, wordsPerPage],  Exec USING [GetTTY, Handle, PutChar, ReleaseTTY],  File USING [File],  Heap USING [Create, Delete, Error],  Inline USING [LongCOPY, LowHalf],  MFile USING [Acquire, AddProperty, AppendErrorMessage, Copy, Delete, Error, FreeSearchPath, GetFullName, GetProperties, GetProperty, GetSearchPath, Handle, maxNameLength, Property, PropertyError, ReadOnly, ReadWrite, Release, RemoveProperty, SameFile, SearchPath, SetLength, SetProperty],  MFileProperty USING [RemoteName],  MSegment USING [Address, Create, Delete, Error, ErrorCode, ForceOut, GetFile, Handle],  MStream USING [ErrorCode, GetFile, Handle],  MUsage USING [dfHugeZone],  Profile USING [GetUser, SetUser, String],  Runtime USING [GetBcdTime],  Space USING [Allocate, Deallocate, Error, ForceOut, Interval, MapAt, nullInterval, PageFromLongPointer, UnmapAt, virtualMemory, Window],  SpecialMFile USING [GetCapaWithAccess, LeaderPages],  Stream USING [EndOfStream, GetChar],  String USING [AppendChar, AppendString, Empty],  StringLookUp USING [noMatch, TableDesc],  Subr USING [FileErrorType, IncrementPages, InitPages, NameType],  Time USING [Append, AppendCurrent, Unpack],  Token USING [Boolean, FileName, FreeTokenString, Handle, Item, LongDecimal, MaybeQuoted, NilData, Quote, StandardFilterState, SyntaxError],  TTY USING [GetChar, GetID, GetPassword, Handle, Rubout, UserAbort],  TTYSW USING [GetTTYHandle],  Window USING [Handle];SubrImpl: PROGRAM  IMPORTS    CmFile, CWF, DFWorldTime, Exec, Heap, Inline, MFile, MSegment, MStream, Profile,      Runtime, Space, SpecialMFile, Stream, String, Time, Token, TTY, TTYSW      EXPORTS Subr =  BEGIN  FileError: PUBLIC ERROR [error: Subr.FileErrorType] = CODE;  ContainingDFNameError: PUBLIC ERROR = CODE;  errorflg: PUBLIC BOOLEAN ¬ FALSE;  debugflg: PUBLIC BOOLEAN ¬ FALSE;  alwaysConfirm: PUBLIC BOOLEAN ¬ FALSE;  -- set TRUE if 'a' typed by user  -- set from User.cm [DFTool] section  workingDFHost, workingDFDir: PUBLIC LONG STRING ¬ NIL;  -- from WorkingDFLoc:  integrationHost, integrationDir: PUBLIC LONG STRING ¬ NIL;  -- f. IntegrationLoc:  localDFDir: PUBLIC LONG STRING ¬ NIL;  checkLibrarian: PUBLIC BOOLEAN ¬ TRUE;  dfLibjectsOnly: PUBLIC BOOLEAN ¬ FALSE;  dfZone: UNCOUNTED ZONE ¬ NIL;  dfExec: Exec.Handle ¬ NIL;  -- Huge zone-related declarations  hzFile: MFile.Handle ¬ NIL;  hzMapping: {none, mSegment, spaceInterval} ¬ none;  hzSeg: MSegment.Handle ¬ NIL;  -- if hzMapping = mSegment  hzInterval: Space.Interval ¬ Space.nullInterval;  -- if hzMapping = spaceInterval  hzHeader: LONG POINTER TO HZHeaderRecord ¬ NIL;  HZHeaderRecord: TYPE = RECORD [    beginning: LONG POINTER ¬ NIL,  -- @first word of data    current: LONG POINTER ¬ NIL,  -- @current word of data    ending: LONG POINTER ¬ NIL,  -- @last word of data    self: LONG POINTER ¬ NIL,  -- = hzHeader (< beginning)    npages: CARDINAL ¬ 0,  -- total pages in HugeZone    forced: BOOLEAN ¬ FALSE];  hzHandle: UZHandle ¬ @hzObject;  hzObject: UZObject ¬ [procs: @hzProcs, data: NIL];  hzProcs: UZProcs ¬ [alloc: HZAlloc, dealloc: HZDeAlloc];  UZHandle: TYPE = LONG POINTER TO UZObject;  UZObject: TYPE = MACHINE DEPENDENT RECORD [    procs: LONG POINTER TO UZProcs, data: LONG POINTER TO UZData];  UZProcs: TYPE = MACHINE DEPENDENT RECORD [    alloc: PROC [zone: UZHandle, size: CARDINAL] RETURNS [LONG POINTER],    dealloc: PROC [zone: UZHandle, object: LONG POINTER]];  UZData: TYPE = RECORD [];  -- Initialization and finalization  SubrInit: PUBLIC PROC [    exec: Exec.Handle, zone: UNCOUNTED ZONE ¬ NIL,    initPages: CARDINAL ¬ Subr.InitPages,    increment: CARDINAL ¬ Subr.IncrementPages] = {    IF dfZone # NIL THEN {      IF debugflg THEN CWF.WF0["Debugging: SubrInit called twice.\n"L]; RETURN};    errorflg ¬ FALSE;    dfExec ¬ exec;    alwaysConfirm ¬ FALSE;    ResetUserCmVariables[];    CreateLongZone[zone, initPages, increment];    SetUserCmVariables[]};  SubrStop: PUBLIC PROC [deleteZone: BOOLEAN ¬ TRUE] = {    ResetUserCmVariables[];    IF deleteZone THEN {      IF hzFile # NIL THEN {ForceHugeZoneToDisk[]; ReleaseHugeZone[]};      DeleteLongZone[]};    dfZone ¬ NIL;    dfExec ¬ NIL;    alwaysConfirm ¬ FALSE};  LongZone: PUBLIC PROC RETURNS [UNCOUNTED ZONE] = {RETURN[dfZone]};  CreateLongZone: PROC [zone: UNCOUNTED ZONE, initPages, increment: CARDINAL] = {    dfZone ¬      (IF zone # NIL THEN zone       ELSE Heap.Create[initial: initPages, increment: increment])};  DeleteLongZone: PROC = {    IF dfZone # NIL THEN {      deleteAgain: BOOLEAN ¬ FALSE;      Heap.Delete[        z: dfZone, checkEmpty: debugflg !        Heap.Error => {          IF type = invalidHeap THEN {            deleteAgain ¬ TRUE;            IF debugflg THEN CWF.WF0["Debugging: Heap not empty.\n"L]};          CONTINUE}];      IF deleteAgain THEN        Heap.Delete[z: dfZone, checkEmpty: FALSE ! Heap.Error => CONTINUE];      dfZone ¬ NIL}};  SetUserCmVariables: PROC = {    userCm: CmFile.Handle;    myState: Token.StandardFilterState;    Item: TYPE = MACHINE DEPENDENT{      workingDFLoc(0), integrationLoc(1), localDFDir(2), checkLibrarian(3), dfLibjectsOnly(4), timeNeedsFix(5), timeDelta(6),         noMatch(StringLookUp.noMatch)};    DefinedItem: TYPE = Item [workingDFLoc..timeDelta];    itemTable: ARRAY DefinedItem OF LONG STRING ¬ [      workingDFLoc: "WorkingDFLoc"L, integrationLoc: "IntegrationLoc"L,      localDFDir: "LocalDFDir"L, checkLibrarian: "CheckLibrarian"L, dfLibjectsOnly: "DfLibjectsOnly"L,  timeNeedsFix: "timeNeedsFix"L, timeDelta: "timeDelta"L];    CheckType: PROC [h: CmFile.Handle, table: StringLookUp.TableDesc]      RETURNS [index: CARDINAL] = CmFile.NextValue;    MyNextValue: PROC [      h: CmFile.Handle,      table: LONG DESCRIPTOR FOR ARRAY DefinedItem OF LONG STRING]      RETURNS [index: Item] = LOOPHOLE[CheckType];    userCm ¬ CmFile.UserDotCmOpen[ ! CmFile.Error => GOTO NoUserDotCm];    IF CmFile.FindSection[userCm, "DFTool"L] THEN      DO        SELECT MyNextValue[        userCm, DESCRIPTOR[itemTable] ! CmFile.TableError => RESUME ] FROM          noMatch => EXIT;          workingDFLoc => {            temp: LONG STRING ¬ NIL;            temp ¬ Token.MaybeQuoted[              h: userCm, data: @myState, filter: Token.FileName,              isQuote: Token.Quote !              Token.NilData, Token.SyntaxError => CONTINUE];            IF temp # NIL THEN {              [workingDFHost, workingDFDir] ¬ GetRemoteLoc[temp, dfZone];              temp ¬ Token.FreeTokenString[temp]}};          integrationLoc => {            temp: LONG STRING ¬ NIL;            temp ¬ Token.MaybeQuoted[              h: userCm, data: @myState, filter: Token.FileName,              isQuote: Token.Quote !              Token.NilData, Token.SyntaxError => CONTINUE];            IF temp # NIL THEN {              [integrationHost, integrationDir] ¬ GetRemoteLoc[temp, dfZone];              temp ¬ Token.FreeTokenString[temp]}};          localDFDir => {            temp: LONG STRING ¬ NIL;            temp ¬ Token.Item[              userCm ! Token.NilData, Token.SyntaxError => CONTINUE];            IF temp # NIL THEN {              localDFDir ¬ GetLocalDir[temp, dfZone];              temp ¬ Token.FreeTokenString[temp]}};          checkLibrarian => {            checkLibrarian ¬ TRUE;            checkLibrarian ¬ Token.Boolean[              userCm ! Token.SyntaxError => CONTINUE]};	  dfLibjectsOnly => {	    dfLibjectsOnly ¬ TRUE;	    dfLibjectsOnly ¬ Token.Boolean[              userCm ! Token.SyntaxError => CONTINUE]};	   timeNeedsFix => {	      DFWorldTime.needsFix ¬  FALSE;	      DFWorldTime.needsFix ¬ 	Token.Boolean[              userCm ! Token.SyntaxError => CONTINUE]};	    timeDelta => {	      DFWorldTime.delta ¬ 0;	      DFWorldTime.delta ¬ Token.LongDecimal[	        userCm ! Token.SyntaxError => CONTINUE]};          ENDCASE;        ENDLOOP;    [] ¬ CmFile.Close[userCm];    EXITS NoUserDotCm => NULL};  ResetUserCmVariables: PROC = {    IF workingDFHost # NIL THEN dfZone.FREE[@workingDFHost];    IF workingDFDir # NIL THEN dfZone.FREE[@workingDFDir];    IF integrationHost # NIL THEN dfZone.FREE[@integrationHost];    IF integrationDir # NIL THEN dfZone.FREE[@integrationDir];    IF localDFDir # NIL THEN dfZone.FREE[@localDFDir];    checkLibrarian ¬ TRUE};  -- HugeZone stuff  HugeZone: PUBLIC PROC [nPages: CARDINAL, zonePrefix: STRING]    RETURNS [UNCOUNTED ZONE] = {    temp: STRING ¬ [MFile.maxNameLength];    IF hzFile # NIL THEN RETURN[LOOPHOLE[hzHandle]];    CWF.SWF1[      temp, "%sHugeZone.VirtualMemory$"L,      (IF zonePrefix = NIL THEN ""L ELSE zonePrefix)];    hzFile ¬ MFile.ReadWrite[      name: temp, release: [], type: binary,      initialLength: (LONG[nPages] * Environment.bytesPerPage)];    MFile.SetLength[hzFile, (LONG[nPages] * Environment.bytesPerPage)];    hzSeg ¬ MSegment.Create[      file: hzFile, release: [], pages: nPages, swapInfo: [uniform[4]]];    hzMapping ¬ mSegment;    hzHeader ¬ MSegment.Address[hzSeg];    hzHeader­ ¬ [      self: hzHeader, npages: nPages, beginning: hzHeader + SIZE[HZHeaderRecord],      current: hzHeader + SIZE[HZHeaderRecord],      ending: hzHeader + (nPages * LONG[Environment.wordsPerPage])];    RETURN[LOOPHOLE[hzHandle]]};  HZAlloc: PROC [zone: UZHandle, size: CARDINAL] RETURNS [lp: LONG POINTER] = {    IF LOOPHOLE[hzHeader.current, LONG CARDINAL] + size >=      LOOPHOLE[hzHeader.ending, LONG CARDINAL] THEN      ERROR Heap.Error[insufficientSpace];    lp ¬ hzHeader.current;    hzHeader.current ¬ (hzHeader.current + size);    RETURN[lp]};  HZDeAlloc: PROC [zone: UZHandle, object: LONG POINTER] = {};  -- for now  WordsFromHugeZone: PUBLIC PROC [nwords: LONG CARDINAL]    RETURNS [lp: LONG POINTER] = {    IF LOOPHOLE[hzHeader.current, LONG CARDINAL] + nwords >=      LOOPHOLE[hzHeader.ending, LONG CARDINAL] THEN      ERROR Heap.Error[insufficientSpace];    lp ¬ hzHeader.current;    hzHeader.current ¬ (hzHeader.current + nwords);    RETURN[lp]};  PagesUsedInHugeZone: PUBLIC PROC RETURNS [npages: CARDINAL] = {    IF hzHeader = NIL THEN RETURN[0];    RETURN[      Inline.LowHalf[        (hzHeader.current - hzHeader.beginning) / Environment.wordsPerPage + 1]]};  ResetHugeZoneToEmpty: PUBLIC PROC = {    -- NB: there must be no outstanding pointers to old contents of the huge zone    IF hzHeader # NIL THEN hzHeader.current ¬ hzHeader.beginning};  -- raises:  --   Space.Error      if position is already inhabited  --   Subr.FileError   if no virtual memory backing file on disk  HugeZoneFromDisk: PUBLIC PROC [zonePrefix: STRING]    RETURNS [originalBeginning: LONG POINTER] = {    temp: STRING ¬ [MFile.maxNameLength];    seg: MSegment.Handle ¬ NIL;    self: LONG POINTER ¬ NIL;    npages: CARDINAL;    f: File.File;    hzWindow: Space.Window;    hzHeader ¬ NIL;    IF hzFile # NIL THEN ERROR Space.Error[alreadyAllocated];    CWF.SWF1[      temp, "%sHugeZone.VirtualMemory$"L,      (IF zonePrefix = NIL THEN ""L ELSE zonePrefix)];    -- get original starting location (self), etc    hzFile ¬ MFile.ReadOnly[name: temp, release: []];    seg ¬ MSegment.Create[file: hzFile, release: [], pages: 1];    hzHeader ¬ MSegment.Address[seg];    self ¬ hzHeader.self;    npages ¬ hzHeader.npages;    IF self = NIL OR npages = 0 OR ~hzHeader.forced THEN      ERROR FileError[notFound];  -- data inconsistency    MSegment.Delete[seg];    seg ¬ NIL;    hzHeader ¬ NIL;    hzFile ¬ NIL;    -- now read "pickled" huge zone into its old VM location (!)    hzFile ¬ MFile.ReadWrite[      name: temp, release: [], type: binary,      initialLength: (LONG[npages] * Environment.bytesPerPage)];    MFile.SetLength[hzFile, (LONG[npages] * Environment.bytesPerPage)];    f ¬ SpecialMFile.GetCapaWithAccess[hzFile];    hzInterval ¬ Space.Allocate[      count: npages, within: Space.virtualMemory,      base: Space.PageFromLongPointer[self]];    IF hzInterval.pointer # self THEN ERROR FileError[notFound];  -- data inconsistency;    hzWindow ¬ Space.Window[      file: f, base: SpecialMFile.LeaderPages[], count: npages];    [] ¬ Space.MapAt[      at: hzInterval, window: hzWindow, usage: MUsage.dfHugeZone, class: file,      access: readWrite, life: alive, swapUnits: [uniform[size: 4]]];    hzMapping ¬ spaceInterval;    hzHeader ¬ self;    RETURN[originalBeginning: hzHeader.beginning]};  ReleaseHugeZone: PROC = {    IF hzHeader = NIL THEN RETURN;    SELECT hzMapping FROM      mSegment => {        IF hzSeg # NIL THEN MSegment.Delete[hzSeg ! MSegment.Error => CONTINUE];        hzSeg ¬ NIL;        hzFile ¬ NIL};      spaceInterval => {        [] ¬ Space.UnmapAt[pointer: hzInterval.pointer, returnWait: wait];        Space.Deallocate[hzInterval];        hzInterval ¬ Space.nullInterval};      ENDCASE;    IF hzFile # NIL THEN MFile.Release[hzFile ! MFile.Error => CONTINUE];    hzFile ¬ NIL;    hzMapping ¬ none;    hzHeader ¬ NIL};  ForceHugeZoneToDisk: PUBLIC PROC = {    IF hzHeader = NIL THEN RETURN;    hzHeader.forced ¬ TRUE;    SELECT hzMapping FROM      mSegment => MSegment.ForceOut[hzSeg];      spaceInterval => Space.ForceOut[hzInterval];      ENDCASE};  DeleteHugeZone: PUBLIC PROC = {    fullName: LONG STRING ¬ [MFile.maxNameLength];    canDelete: BOOLEAN ¬ TRUE;    IF hzHeader = NIL OR hzFile = NIL THEN RETURN;    MFile.GetFullName[hzFile, fullName];    SELECT hzMapping FROM      mSegment => {        MSegment.Delete[hzSeg ! Space.Error => CONTINUE];        hzSeg ¬ NIL;        hzFile ¬ NIL};      spaceInterval => {        [] ¬ Space.UnmapAt[pointer: hzInterval.pointer, returnWait: wait];        Space.Deallocate[hzInterval];        hzInterval ¬ Space.nullInterval};      ENDCASE;    IF hzFile # NIL THEN MFile.Release[hzFile ! MFile.Error => CONTINUE];    hzFile ¬ MFile.Acquire[      name: fullName, access: delete, release: [] !      MFile.Error => {canDelete ¬ FALSE; CONTINUE}];    IF canDelete THEN MFile.Delete[hzFile ! MFile.Error => CONTINUE];    MFile.Release[hzFile ! MFile.Error => CONTINUE];    hzFile ¬ NIL;    hzMapping ¬ none;    hzHeader ¬ NIL};  -- String manipulation  AllocateString: PUBLIC PROC [nchars: CARDINAL, zone: UNCOUNTED ZONE]    RETURNS [s: LONG STRING] = {    IF zone = NIL THEN zone ¬ dfZone;    s ¬ zone.NEW[StringBody [nchars] ¬ [length: 0, maxlength: nchars, text:]]};  FreeString: PUBLIC PROC [str: LONG STRING, zone: UNCOUNTED ZONE] = {    IF str = NIL THEN RETURN; IF zone = NIL THEN zone ¬ dfZone; zone.FREE[@str]};  AllocateWords: PUBLIC PROC [nwords: CARDINAL] RETURNS [ptr: LONG POINTER] = {    seq: TYPE = RECORD [body: SEQUENCE maxsize: CARDINAL OF WORD];    ptr ¬ dfZone.NEW[seq [nwords]]};  FreeWords: PUBLIC PROC [ptr: LONG POINTER] = {    IF dfZone = NIL OR ptr = NIL THEN RETURN; dfZone.FREE[@ptr]};  CopyString: PUBLIC PROC [old: LONG STRING, zone: UNCOUNTED ZONE]    RETURNS [new: LONG STRING] = {    nchars: CARDINAL;    IF old = NIL THEN RETURN[NIL];    nchars ¬ old.length;    IF zone = NIL THEN zone ¬ dfZone;    new ¬ zone.NEW[      StringBody [nchars] ¬ [length: nchars, maxlength: nchars, text:]];    Inline.LongCOPY[from: old + 2, nwords: (nchars + 1) / 2, to: new + 2]};  -- can also be used if sto and sfrom point to the same StringBody  SubStrCopy: PUBLIC PROC [sto, sfrom: LONG STRING, sfinx: CARDINAL] = {    i: CARDINAL ¬ 0;    WHILE sfinx < sfrom.length AND i < sto.maxlength DO      sto[i] ¬ sfrom[sfinx]; i ¬ i + 1; sfinx ¬ sfinx + 1; ENDLOOP;    sto.length ¬ i};  StrCopy: PUBLIC PROC [to, from: LONG STRING] = {    l: CARDINAL = MIN[from.length, to.maxlength];    Inline.LongCOPY[from: (from + 2), to: (to + 2), nwords: (l + 1) / 2];    to.length ¬ l};  Confirm: PUBLIC PROC [    defaultChar: CHARACTER, window: Window.Handle, allowAlways: BOOLEAN ¬ TRUE]  -- allow previous "a" (always) to confirm    RETURNS [CHARACTER] = {    -- Note: Since the return value is unnamed, I have to declare a result variable.    -- When the def is edited, fix this..    result: CHARACTER;    ch: CHARACTER;    ttyh: TTY.Handle;    Cleanup: PROC = {IF window # NIL THEN Exec.ReleaseTTY[ttyh]};    BEGIN    ENABLE UNWIND => Cleanup[];    -- Ok to return directly here since we didn't get the EXEC handle.    IF alwaysConfirm AND allowAlways THEN RETURN['y];    -- Get the right tty handle.    IF window = NIL THEN ttyh ¬ Exec.GetTTY[dfExec]    ELSE ttyh ¬ TTYSW.GetTTYHandle[sw: window];    -- Since we are not getting a TTY edited string, the RUBOUT signal is never raised.    -- Prompt    CWF.WF0["? "L];    -- Tired? It seems hard to get this abort caught. It won't hurt anyhow..    IF TTY.UserAbort[ttyh] THEN ERROR ABORTED;    -- Get input.    ch ¬ TTY.GetChar[ttyh];    -- Use default if not input.    IF ch = '\n THEN ch ¬ defaultChar;    -- Normalize    ch ¬ LowerCase[ch];    -- Act    SELECT ch FROM      'a => {alwaysConfirm ¬ TRUE; CWF.WF0["Always - "L]; result ¬ 'y; };      ENDCASE => {result ¬ ch; };    Cleanup[];    RETURN[result];    END;  -- ENABLE...    };  GetRemoteLoc: PUBLIC PROC [loc: LONG STRING, dfZone: UNCOUNTED ZONE]    RETURNS [host, dir: LONG STRING] = {    locLen, last, i: CARDINAL;    IF String.Empty[loc] THEN RETURN[NIL, NIL];    locLen ¬ loc.length;    host ¬ AllocateString[locLen, dfZone];    dir ¬ AllocateString[locLen, dfZone];    last ¬ (IF loc[locLen - 1] = '> THEN locLen - 2 ELSE locLen - 1);    i ¬ (IF loc[0] = '[ THEN 1 ELSE 0);    WHILE i <= last DO      IF loc[i] = '] THEN {i ¬ i + 1; EXIT};      String.AppendChar[host, loc[i]];      i ¬ i + 1;      ENDLOOP;    IF loc[i] = '< THEN i ¬ i + 1;    WHILE i <= last DO String.AppendChar[dir, loc[i]]; i ¬ i + 1; ENDLOOP};  GetLocalDir: PUBLIC PROC [name: LONG STRING, dfZone: UNCOUNTED ZONE]    RETURNS [dir: LONG STRING] = {    nameLen, last: CARDINAL;    found, problem: BOOLEAN ¬ FALSE;    dirHandle, spDirHandle: MFile.Handle ¬ NIL;    spDirectories: MFile.SearchPath ¬ NIL;    msg: STRING ¬ [100];    CleanUp: PROC = {      IF dirHandle # NIL THEN {MFile.Release[dirHandle]; dirHandle ¬ NIL};      IF spDirHandle # NIL THEN {MFile.Release[spDirHandle]; spDirHandle ¬ NIL};      IF spDirectories # NIL THEN {        MFile.FreeSearchPath[spDirectories]; spDirectories ¬ NIL}};    BEGIN    ENABLE UNWIND => CleanUp[];    IF String.Empty[name] THEN RETURN[NIL];    nameLen ¬ name.length;    last ¬ (IF name[nameLen - 1] = '> THEN nameLen - 2 ELSE nameLen - 1);    dir ¬ AllocateString[(nameLen + 3), dfZone];    IF name[0] # '< AND name[0] # '> THEN String.AppendString[dir, "<>"L];    FOR i: CARDINAL IN [0..last] DO String.AppendChar[dir, name[i]]; ENDLOOP;    String.AppendChar[dir, '>];    -- now check that dir is on the search path    dirHandle ¬ MFile.Acquire[      name: dir, access: anchor, release: [] !      MFile.Error => {        MFile.AppendErrorMessage[msg, code, file];        CWF.WF2[          "Error - unable to check that %s is on search path: %s.\n"L, dir, msg];        dirHandle ¬ NIL;        problem ¬ TRUE;        CONTINUE}];    IF dirHandle # NIL THEN {      spDirectories ¬ MFile.GetSearchPath[];      FOR i: CARDINAL IN [0..spDirectories.length) WHILE ~found DO        spDirHandle ¬ MFile.Acquire[          name: spDirectories.directories[i], access: anchor, release: [] !          MFile.Error => {            MFile.AppendErrorMessage[msg, code, file];            CWF.WF2[              "Error - unable to check that %s is on search path: %s.\n"L, dir,              msg];            spDirHandle ¬ NIL;            problem ¬ TRUE;            CONTINUE}];        IF MFile.SameFile[dirHandle, spDirHandle] THEN found ¬ TRUE;        MFile.Release[spDirHandle];        spDirHandle ¬ NIL;        ENDLOOP;      MFile.Release[dirHandle];      dirHandle ¬ NIL;      MFile.FreeSearchPath[spDirectories];      spDirectories ¬ NIL};    IF ~found AND ~problem THEN      CWF.WF1["Warning - local directory %s is not on search path.\n"L, dir];    END;    CleanUp[]};  StripLeadingBlanks: PUBLIC PROC [str: LONG STRING] = {    i: CARDINAL ¬ 0;    WHILE i < str.length AND (str[i] = '  OR str[i] = '\t) DO i ¬ i + 1; ENDLOOP;    SubStrCopy[str, str, i]};  Any: PUBLIC PROC [str: LONG STRING, ch: CHARACTER] RETURNS [BOOLEAN] = {    FOR i: CARDINAL IN [0..str.length) DO      IF str[i] = ch THEN RETURN[TRUE]; ENDLOOP;    RETURN[FALSE]};  EndsIn: PUBLIC PROC [str: LONG STRING, suf: LONG STRING] RETURNS [BOOLEAN] = {    FOR i: CARDINAL IN [0..str.length) DO      BEGIN      IF LowerCase[str[i]] = LowerCase[suf[0]] THEN {        FOR j: CARDINAL IN [0..suf.length) DO          IF i + j >= str.length OR LowerCase[str[i + j]] # LowerCase[suf[j]] THEN            GOTO outer;          ENDLOOP;        IF i + suf.length < str.length THEN GOTO outer;        RETURN[TRUE]};      EXITS outer => NULL;      END;      ENDLOOP;    RETURN[FALSE]};  ControlChars: PUBLIC PROC [str: LONG STRING] RETURNS [BOOLEAN] = {    j: CARDINAL;    FOR i: CARDINAL IN [0..str.length) DO      j ¬ LOOPHOLE[str[i], CARDINAL];      IF j IN [0..32) OR j >= 177B THEN RETURN[TRUE];      ENDLOOP;    RETURN[FALSE]};  Prefix: PUBLIC PROC [str, pref: LONG STRING] RETURNS [BOOLEAN] = {    i: CARDINAL ¬ 0;    WHILE i < str.length AND i < pref.length      AND LowerCase[str[i]] = LowerCase[pref[i]] DO i ¬ i + 1; ENDLOOP;    RETURN[i = pref.length]};  LowerCase: PROC [c: CHARACTER] RETURNS [CHARACTER] = INLINE {    IF c IN ['A..'Z] THEN c ¬ c + ('a - 'A); RETURN[c]};  -- File parsing  GetLine: PUBLIC PROC [sh: MStream.Handle, line: LONG STRING]    RETURNS [notEof: BOOLEAN] = {    i: CARDINAL ¬ 0;    ch: CHARACTER;    line.length ¬ 0;    DO      ch ¬ Stream.GetChar[sh ! Stream.EndOfStream => {ch ¬ 0C; CONTINUE}];      line[i] ¬ ch;      IF ch = '\n OR ch = 0C THEN EXIT;      i ¬ i + 1;      IF i >= line.maxlength THEN EXIT;      ENDLOOP;    line.length ¬ i;    IF line.length >= line.maxlength THEN {      line.length ¬ line.maxlength;      CWF.WF1["GetLine - line '%s' is too long.\n"L, line]};    RETURN[notEof: ~(ch = 0C AND line.length = 0)]};  GetChar: PUBLIC PROC [sh: MStream.Handle] RETURNS [ch: CHARACTER] = {    ch ¬ 0C;  -- return 0C if EOF    ch ¬ Stream.GetChar[sh ! Stream.EndOfStream => CONTINUE];    RETURN[ch]};  -- parses line, beginning at line[inx], into sub  -- considers a string to be a sequence of characters  -- begun by anything except blank, :, =, tab, and [  -- and terminated by blank, :, =, tab, and [  -- leading and trailing blanks are ignored  -- TAB is not considered a blank  GetString: PUBLIC PROC [line: LONG STRING, sub: LONG STRING, inx: CARDINAL]    RETURNS [CARDINAL] = {    i: CARDINAL;    sub.length ¬ 0;    WHILE inx < line.length AND line[inx] = '  DO inx ¬ inx + 1 ENDLOOP;    IF inx >= line.length THEN RETURN[inx];    i ¬ 0;    DO      sub[i] ¬ line[inx];      inx ¬ inx + 1;      i ¬ i + 1;      IF sub[i - 1] = '= OR sub[i - 1] = ': THEN EXIT;  -- termination chars      IF inx < line.length AND i < sub.maxlength AND line[inx] # 0C        AND line[inx] # '  AND line[inx] # '\t AND line[inx] # ':        AND line[inx] # '= AND line[inx] # '[ THEN LOOP;  -- tests for begin chars      EXIT;      ENDLOOP;    sub.length ¬ i;    IF sub.length >= sub.maxlength THEN      CWF.WF1["Substring %s not long enough\n"L, sub];    RETURN[inx]};  -- File operations  AppendMStreamErrorMessage: PUBLIC PROC [    msg: LONG STRING, code: MStream.ErrorCode, stream: MStream.Handle] = {    name: LONG STRING ¬ [MFile.maxNameLength];    problem: LONG STRING;    SELECT TRUE FROM      (stream = NIL) => name ¬ "unknown"L;      (code = invalidHandle) => name ¬ "unknown"L;      ENDCASE => {        file: MFile.Handle ¬ MStream.GetFile[stream];        IF file = NIL THEN name ¬ "unknown"L        ELSE [] ¬ MFile.GetProperties[file, name];        IF String.Empty[name] THEN name ¬ "unknown"L};    problem ¬      (SELECT code FROM         invalidHandle => "invalidHandle"L,         indexOutOfRange => "indexOutOfRange"L,         invalidOperation => "invalidOperation"L,         fileTooLong => "fileTooLong"L,         fileNotAvailable => "fileNotAvailable"L,         invalidFile => "invalidFile"L,         other => "other"L,         ENDCASE => "(unknown MStream.Error)"L);    CWF.SWF2[msg, "Error accessing stream on file %s: %s"L, name, problem]};  AppendMSegmentErrorMessage: PUBLIC PROC [    msg: LONG STRING, code: MSegment.ErrorCode, segment: MSegment.Handle] = {    name: LONG STRING ¬ [MFile.maxNameLength];    problem: LONG STRING;    SELECT TRUE FROM      (segment = NIL) => name ¬ "unknown"L;      (code = noSuchSegment) => name ¬ "unknown"L;      ENDCASE => {        file: MFile.Handle ¬ MSegment.GetFile[segment];        IF file = NIL THEN name ¬ "unknown"L        ELSE [] ¬ MFile.GetProperties[file, name];        IF String.Empty[name] THEN name ¬ "unknown"L};    problem ¬      (SELECT code FROM         zeroLength => "zeroLength"L,         insufficientVM => "insufficientVM"L,         noSuchSegment => "noSuchSegment"L,         sharedSegment => "sharedSegment"L,         baseOutOfRange => "baseOutOfRange"L,         conflictingAccess => "conflictingAccess"L,         illegalAccess => "illegalAccess"L,         invalidFile => "invalidFile"L,         dataSegmentNeedsPages => "dataSegmentNeedsPages"L,         noRoomOnVolume => "noRoomOnVolume"L,         other => "other"L,         ENDCASE => "(unknown MSegment.Error)"L);    CWF.SWF2[msg, "Error accessing segment on file %s: %s"L, name, problem]};  CopyFile: PUBLIC PROC [from, to: LONG STRING] = {    f: MFile.Handle ¬ NIL;    Cleanup: PROC = {IF f # NIL THEN {MFile.Release[f]; f ¬ NIL}};    BEGIN    ENABLE UNWIND => Cleanup[];    f ¬ MFile.ReadOnly[name: from, release: []];    MFile.Copy[file: f, newName: to];    MFile.Release[f];    END};  -- Global parameter management   SetWorkingDFLoc: PUBLIC PROC [workingDFLoc: LONG STRING] = {    IF workingDFHost # NIL THEN dfZone.FREE[@workingDFHost];    IF workingDFDir # NIL THEN dfZone.FREE[@workingDFDir];    [workingDFHost, workingDFDir] ¬ GetRemoteLoc[workingDFLoc, dfZone]};  SetIntegrationLoc: PUBLIC PROC [integrationLoc: LONG STRING] = {    IF integrationHost # NIL THEN dfZone.FREE[@integrationHost];    IF integrationDir # NIL THEN dfZone.FREE[@integrationDir];    [integrationHost, integrationDir] ¬ GetRemoteLoc[integrationLoc, dfZone]};  SetLocalDFDir: PUBLIC PROC [localDFDirectory: LONG STRING] = {    IF localDFDir # NIL THEN dfZone.FREE[@localDFDir];    localDFDir ¬ GetLocalDir[localDFDirectory, dfZone]};  SetCheckLibrarian: PUBLIC PROC [checkWithLibrarian: BOOLEAN] = {    checkLibrarian ¬ checkWithLibrarian};  -- Management of containing-DF-file property in MFile leader pages  maxContainingDFNameLength: CARDINAL = 70;  -- big enough for most...  ContainingDFName: MFile.Property = [MFileProperty.RemoteName + 1];  SetContainingDFName: PUBLIC PROC [file: MFile.Handle, dfName: LONG STRING] = {    -- dfName should be of the form "DfName.df"    IF String.Empty[dfName] OR dfName.length > maxContainingDFNameLength THEN      ERROR ContainingDFNameError;    DO      BEGIN      MFile.AddProperty[        file: file, property: ContainingDFName,        maxLength: maxContainingDFNameLength !        MFile.PropertyError =>          SELECT code FROM            noRoomInPropertyList, insufficientSpaceForProperty => GOTO ForgetIt;            wrongSize => GOTO Remove;  -- must UNWIND before Remove            ENDCASE => REJECT];      EXITS        Remove => {MFile.RemoveProperty[file, MFileProperty.RemoteName]; LOOP};      END;      EXIT      ENDLOOP;    MFile.SetProperty[      file: file, property: ContainingDFName,      block: [      blockPointer: LOOPHOLE[@dfName.text], startIndex: 0,      stopIndexPlusOne: dfName.length]];    EXITS ForgetIt => NULL};  GetContainingDFName: PUBLIC PROC [file: MFile.Handle, dfName: LONG STRING] = {    temp: LONG STRING ¬ [maxContainingDFNameLength];    rnLength: CARDINAL;    IF dfName = NIL THEN ERROR ContainingDFNameError;    rnLength ¬ MFile.GetProperty[      file: file, property: ContainingDFName,      block: [      blockPointer: LOOPHOLE[@temp.text], startIndex: 0,      stopIndexPlusOne: maxContainingDFNameLength] !      MFile.PropertyError =>        SELECT code FROM noSuchProperty => GOTO NoSuchProp; ENDCASE => REJECT];    IF rnLength > dfName.maxlength THEN ERROR ContainingDFNameError;  -- won't fit    dfName.length ¬ 0;    temp.length ¬ rnLength;    String.AppendString[dfName, temp];    EXITS NoSuchProp => dfName.length ¬ 0};  -- Misc. operations  PrintGreeting: PUBLIC PROC [str: LONG STRING] = {    s: STRING ¬ [60];    String.AppendString[s, str];    String.AppendString[s, " of "L];    Time.Append[s, Time.Unpack[LOOPHOLE[Runtime.GetBcdTime[]]]];    s.length ¬ s.length - 3;    CWF.WF1["%s\n"L, s];    s.length ¬ 0;    Time.AppendCurrent[s];    s.length ¬ s.length - 3;    CWF.WF1["  %s\n\n"L, s]};  SetUpCWFWriteProcedure: PUBLIC PROC = {[] ¬ CWF.SetWriteProcedure[TTYProc]};  TTYProc: PROC [ch: CHARACTER] = {Exec.PutChar[dfExec, ch]};  MaxNameLength: CARDINAL = 60;  MaxPassWordLength: CARDINAL = 60;  GetNameandPassword: PUBLIC PROC [    nt: Subr.NameType, name2, password2: LONG STRING, window: Window.Handle] = {    n: STRING ¬ [MaxNameLength];    p: STRING ¬ [MaxPassWordLength];    ttyh: TTY.Handle;    Cleanup: PROC = {IF window # NIL THEN Exec.ReleaseTTY[ttyh]};    GetUserName: PROC [name, password: Profile.String] = {      IF ~String.Empty[name] THEN String.AppendString[n, name]};    BEGIN    ENABLE UNWIND => Cleanup[];    -- The TTY.UserAbort code does not seem to work well, but it doesn't seem to hurt...    --    -- If we don't have a tool window, we MUST have an exec handle...    IF window = NIL THEN ttyh ¬ Exec.GetTTY[dfExec]    ELSE ttyh ¬ TTYSW.GetTTYHandle[sw: window];    -- Get the name...    CWF.WFCR[];    IF TTY.UserAbort[ttyh] THEN {ERROR ABORTED};    SELECT nt FROM      login => {        n.length ¬ 0;  -- Clear out in case we loop here.        Profile.GetUser[GetUserName];        CWF.WF0["Please login - name: "L]};      connect => {String.AppendString[n, name2]; CWF.WF0["Connect name (hit DELETE to ABORT): "L]};      ENDCASE => ERROR;    IF TTY.UserAbort[ttyh] THEN ERROR ABORTED;    TTY.GetID[h: ttyh, s: n ! TTY.Rubout => ERROR ABORTED];    -- Get the password...    CWF.WF0[" password: "L];    IF TTY.UserAbort[ttyh] THEN ERROR ABORTED;    TTY.GetPassword[h: ttyh, s: p ! TTY.Rubout => ERROR ABORTED];    CWF.WFCR[];    -- Work with the results...    SELECT nt FROM      login => {Profile.SetUser[name: n, password: p]};      connect => {        name2.length ¬ 0;        String.AppendString[name2, n];        password2.length ¬ 0;        String.AppendString[password2, p]};      ENDCASE => ERROR;    -- Clean up    Cleanup[];    END};  END.Change log 1-Nov-84 15:18:19	DSC  	Changed GetNameandPassword so that a RUBOUT will raise an ABORT! This is for the benefit of people who forget their passwords and when the authentication is messed up. BringOver works better now, but I don't know how other programs are affected.	We'll see....Also, I called TTY.GetPassword rather than setting the echo mode myself. Also, I got rid of outmoded references to TTYSW operations and mappen them all to the TTY interface.  2-Nov-84 13:00:46	DSC  	Since TTy.Rubout is never raised during  a GETCHAR used in CONFIRM, I got rid of that stuff. There was a RUBOUT related loop there, but now, it's straight code.  1-Nov-84 15:18:19	DSC  	Added dfLibjectsOnly flag to allow quicker Smodels.    9-Nov-84 10:08:20	DSC  	Added DFWorldTime usage to make it usable in Japan and other places . (Note: This is due to a Pilot bug!!!!) I don't want to make change the Subr interface to smash thiss hacks in since this would mean ** MASSSIVE ** recompilations that I'm too lazy to wait for. Abnd don't forget to take this crock away when Pilot is fixed!11-Feb-86 17:06:03	DSC  	Add (hit DELETE to abort) to message in GetNameandPassword since I raise ABORTED.
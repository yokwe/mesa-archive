-- File: RemoteDeleteAllImpl.mesa - last edit:-- Riggle.PA            8-Jan-87 17:38:55-- Copyright (C) 1982, 1983, 1984 , 1987 by Xerox Corporation. All rights reserved. -- RemoteDeleteAllImpl.mesa - Last edited by--   Schmidt	 9-Mar-82 17:04:50--   BTL  	18-Nov-83 10:41:25--   DWE    	16-Mar-84  9:31:31--   DSC  	25-Sep-84 11:43:35	--   NSG        19-Jul-84 16:17:40      changed spare1 to accessDenied-- Usage: RemoteDeleteAll directory <list of dfs>DIRECTORY  BTree USING [Delete, GetNext, Insert, Make, Tree, Value],  CWF USING [SetWriteProcedure, SWF2, SWF3, WF0, WF1, WF2, WF3, WFCR],  DFSubr USING [AllocateDFSeq, DF, DFSeq, EXSeq, EXSeqRecord, FlattenDF, FreeDFSeq, StripLongName],  Environment USING [bytesPerPage],  Exec USING [    AddCommand, CheckForAbort, ExecProc, FreeTokenString, GetToken,    Handle, OutputProc],  FileTransfer USING [CodeToString, Error, ErrorCode, FileInfo, ListProc],  Inline USING [BITXOR, BytePair, LowHalf],  MFile USING [    AcquireTemp, AppendErrorMessage, Error, Handle, maxNameLength,    Release, SetLength],  MSegment USING [Error, ErrorCode],  MStream USING [Error, ErrorCode, Handle, ReadOnly, WriteOnly],  Stream USING [Delete, Handle, PutChar],  String USING [    AppendChar, AppendExtensionIfNeeded, AppendString, CopyToNewString,    Empty, Equivalent, FreeString, InvalidNumber, LowerCase, StringToDecimal],  Subr USING [    AllocateString, Any, AppendMSegmentErrorMessage,    AppendMStreamErrorMessage, Confirm, CopyString, debugflg, EndsIn,    errorflg, FreeString, GetLine, HugeZone, localDFDir, LongZone, PagesUsedInHugeZone, Prefix,    PrintGreeting, SetUpCWFWriteProcedure, StrCopy, SubrInit, SubrStop],  Time USING [Current, Packed],  Transfer USING [Delete, EnumerateForProperties, Finalize, Initialize];RemoteDeleteAllImpl: MONITOR    IMPORTS      BTree, CWF, DFSubr, Exec, FileTransfer, Inline, MFile, MSegment,      MStream, Stream, String, Subr, Transfer, Time =  BEGIN  exseq: DFSubr.EXSeq ¬ NIL;	-- exception list to speed up flattening.   accessDenied: FileTransfer.ErrorCode = FileTransfer.ErrorCode[accessDenied];  IFSBytesPerPage: CARDINAL = 2048;    -- max number of files in all DF files we want to ignore  MaxDeleteFile: CARDINAL ¬ 600;  -- size of zone in which the strings of the internal data structure are stored  PagesInHugeZone: CARDINAL ¬ 400;  -- initial size of deletion BTree backing file  initialBackingPages: CARDINAL ¬ 40;     nowRunning: BOOLEAN ¬ FALSE;   exec: Exec.Handle ¬ NIL;  hugezone: UNCOUNTED ZONE ¬ NIL;  remotePattern: LONG STRING ¬ NIL;  remotePatternHost: LONG STRING ¬ NIL;  fullspeed: BOOLEAN ¬ FALSE;  lastDirectory: LONG STRING ¬ [100];  lastD: LONG STRING ¬ NIL;  nLook, nScan, nInsert: CARDINAL ¬ 0;  nDelete, nSkipDF, nSkipNo: CARDINAL ¬ 0;  nSkipPages, nDeletePages: LONG CARDINAL ¬ 0;    -- we need to split this into two sequences since  -- we cannot allocate sequences longer than 64K words.  shortName1: LONG POINTER TO ShortNameSeq1 ¬ NIL;  shortName2: LONG POINTER TO ShortNameSeq2 ¬ NIL;  ShortNameSeq1: TYPE = RECORD [    body: SEQUENCE maxsize: CARDINAL OF RECORD [      name: LONG STRING]];  ShortNameSeq2: TYPE = RECORD [    body: SEQUENCE maxsize: CARDINAL OF RECORD [       list: NameList]];    NameList: TYPE = LONG POINTER TO NameListRecord;  NameListRecord: TYPE = RECORD [    list: NameList,    host, directory: LONG STRING,    version: CARDINAL,    createtime: Time.Packed];    haveBTree: BOOLEAN ¬ FALSE;  deleteBTree: BTree.Tree ¬ NIL;  deleteBTreeFile: MFile.Handle ¬ NIL;  NEXCEPTIONS: CARDINAL = 20;  DoDelete: Exec.ExecProc = {    startTime: Time.Packed;    dfZone: UNCOUNTED ZONE ¬ NIL;    token, sw, dfName: LONG STRING ¬ NIL;    remoteName: STRING ¬ [150];    retrieveDFsToTemp: BOOLEAN ¬ TRUE;    manyFiles: BOOLEAN ¬ FALSE;    verbose: BOOLEAN ¬ TRUE;    dfseq: DFSubr.DFSeq ¬ NIL;    time: Time.Packed;    host: STRING ¬ [MFile.maxNameLength];    dir: STRING  ¬ [MFile.maxNameLength];    name: STRING ¬ [MFile.maxNameLength];    npages: CARDINAL;         -- Since this is a copy of the code in ReleaseImpl.mesa, please   -- consider making this a shared interface procedure.     ParseExceptionList: PROC [filename: STRING] RETURNS [exseq: DFSubr.EXSeq] = {    sh: Stream.Handle ¬ NIL;    line: STRING ¬ [100];    host: STRING ¬ [60];    directory: STRING ¬ [100];    shortname: STRING ¬ [100];    longzone: UNCOUNTED ZONE = Subr.LongZone[];    BEGIN ENABLE UNWIND => {IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL}};    exseq ¬ longzone.NEW[DFSubr.EXSeqRecord[NEXCEPTIONS]];    CWF.WF0["Reading exceptions list\n"];    sh ¬ MStream.ReadOnly[name: filename, release: []       ! MStream.Error => {          CWF.WF1["\nWarning - cannot open %s.\n"L, filename];  GOTO out}];    WHILE Subr.GetLine[sh, line] DO      IF line.length = 0 OR Subr.Prefix[line, "//"L] OR Subr.Prefix[line, "--"L]        THEN LOOP;      [] ¬ DFSubr.StripLongName[line, host, directory, shortname, FALSE];      IF exseq.size > exseq.maxsize THEN {        CWF.WF1["Error - too many exception list entries in %s.\n"L, filename];        EXIT};      exseq[exseq.size] ¬ [        host: Subr.CopyString[host, longzone],        directory: Subr.CopyString[directory, longzone],        shortname:	  IF shortname.length > 0 THEN Subr.CopyString[shortname, longzone]          ELSE NIL];      exseq.size ¬ exseq.size + 1;      ENDLOOP;    Stream.Delete[sh];  sh ¬ NIL;    EXITS out => NULL;    END};  FreeExceptionList: PROC [pexseq: LONG POINTER TO DFSubr.EXSeq] = {    FOR i: CARDINAL IN [0..pexseq.size) DO      Subr.FreeString[pexseq[i].host];      Subr.FreeString[pexseq[i].directory];      Subr.FreeString[pexseq[i].shortname];      ENDLOOP;    Subr.LongZone[].FREE[pexseq]};    Cleanup: PROC = {      ReleaseBTree[];      IF ~String.Empty[token] THEN token ¬ Exec.FreeTokenString[token];      IF ~String.Empty[sw] THEN sw ¬ Exec.FreeTokenString[sw];      IF ~String.Empty[dfName] THEN {        String.FreeString[z: dfZone, s: dfName];  dfName ¬ NIL};      IF ~String.Empty[remotePattern] THEN {        Subr.FreeString[remotePattern, dfZone];  remotePattern ¬ NIL};      IF ~String.Empty[remotePatternHost] THEN {        Subr.FreeString[remotePatternHost, dfZone];  remotePatternHost ¬ NIL};      IF ~String.Empty[lastD] THEN {        Subr.FreeString[lastD, hugezone];  lastD ¬ NIL};      lastDirectory.length ¬ 0;      shortName1 ¬ NIL;      shortName2 ¬ NIL;      DFSubr.FreeDFSeq[@dfseq];      Transfer.Finalize[];  Subr.SubrStop[];      DoneRunning[]};    BEGIN      ENABLE {        UNWIND => Cleanup[];	ABORTED => {CWF.WF0["\n...RemoteDeleteAll aborted.\n"L];  GOTO abort};        FileTransfer.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [60];	    FileTransfer.CodeToString[code, msg];	    CWF.WF1["FileTransfer error: %s\n"L, msg];	    GOTO error};	MFile.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];	    CWF.WF1["MFile error: %s.\n"L, msg];   	    GOTO error};        MStream.Error =>  	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMStreamErrorMessage[msg, code, stream];	    CWF.WF1["MStream error: %s.\n"L, msg];   	    GOTO error};	MSegment.Error =>   	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: STRING ¬ [100];	    Subr.AppendMSegmentErrorMessage[msg, code, segment];	    CWF.WF1["MSegment error: %s.\n"L, msg];   	    GOTO error}};	       IF AlreadyRunning[] THEN {       Exec.OutputProc[h][" RemoteDeleteAll already running!"L];      RETURN[abort]};          startTime ¬ Time.Current[];    outcome ¬ normal;    exec ¬ h;    Subr.SetUpCWFWriteProcedure[];  Subr.SubrInit[exec];    Subr.errorflg ¬ Subr.debugflg ¬ FALSE;    dfZone ¬ Subr.LongZone[];    Subr.PrintGreeting["RemoteDeleteAll"L];    IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    exseq ¬ ParseExceptionList["Release.ExceptionList"L];    Transfer.Initialize[exec: exec, window: NIL];  -- use exec window for I/O    MaxDeleteFile ¬ 600;  PagesInHugeZone ¬ 400;  -- defaults    initialBackingPages ¬ 40;    fullspeed ¬ FALSE;  lastDirectory.length ¬ 0;  lastD ¬ NIL;    nLook ¬ nScan ¬ nInsert ¬ 0;    nDelete ¬ nSkipDF ¬ nSkipNo ¬ 0;    nSkipPages ¬ nDeletePages ¬ 0;    shortName1 ¬ NIL;    shortName2 ¬ NIL;    haveBTree ¬ FALSE;  deleteBTree ¬ NIL;  deleteBTreeFile ¬ NIL;    -- get name of remote directory to clean up    [token, sw] ¬ Exec.GetToken[exec];    IF String.Empty[token] THEN {sw ¬ Exec.FreeTokenString[sw];  GOTO badUsage};    IF ~String.Empty[sw] THEN {      sense: BOOLEAN ¬ TRUE;      FOR i: CARDINAL IN [0..sw.length) DO        SELECT sw[i] FROM          'd, 'D => {Subr.debugflg     ¬ sense;  sense ¬ TRUE};           't, 't => {retrieveDFsToTemp ¬ sense;  sense ¬ TRUE};	  'm, 'M => {manyFiles         ¬ sense;  sense ¬ TRUE}; 	  'v, 'V => {verbose           ¬ sense;  sense ¬ TRUE}; 	  '-, '~ => sense ¬ ~sense;          ENDCASE => {	    CWF.WF1["Unknown switch in '%s'\n"L, sw]; outcome ¬ warning};	  ENDLOOP};    IF manyFiles THEN {     -- Due to a problem in Mesa11.0 and before, we cannot make sequences     -- of more than 16K since the argument to NEW is a CARDINAL     -- so a sequence longer than 16000 is not possible.     -- so we split the sequence into two.           MaxDeleteFile ¬ 32000;  PagesInHugeZone ¬ 10000;  initialBackingPages ¬ 1000};    Subr.StrCopy[remoteName, token];    token ¬ Exec.FreeTokenString[token];  sw ¬ Exec.FreeTokenString[sw];    -- allocate huge zone    [] ¬ Subr.HugeZone[PagesInHugeZone];    hugezone ¬ Subr.HugeZone[];    dfseq ¬ DFSubr.AllocateDFSeq[maxEntries: MaxDeleteFile, zoneType: huge];    -- now read the DF files    time ¬ Time.Current[];    [token, sw] ¬ Exec.GetToken[exec];    sw ¬ Exec.FreeTokenString[sw];    WHILE ~String.Empty[token] DO      dfName ¬ String.CopyToNewString[s: token, z: dfZone, longer: 3];      [] ¬ String.AppendExtensionIfNeeded[@dfName, ".df"L, dfZone];      CWF.WF1["Reading %s:\n"L, dfName];      DFSubr.FlattenDF[        dfseq: dfseq, dffilename: dfName,	exec: exec, window: NIL,        defaultUserName: NIL, defaultUserPassword: NIL,	checkForOverwrite: FALSE, allowForceReadOnly: TRUE,	setRecorder: FALSE, printStatus: TRUE, skipCameFrom: FALSE,	retrieveDFsToTemp: retrieveDFsToTemp, localDFDir: Subr.localDFDir,	exList: exseq];      String.FreeString[z: dfZone, s: dfName];  dfName ¬ NIL;      [token, sw] ¬ Exec.GetToken[exec];      sw ¬ Exec.FreeTokenString[sw];      ENDLOOP;    FreeExceptionList[@exseq];    time ¬ [Time.Current[] - time];    CWF.WF1["\nTime to read in all DF files: %lr.\n"L, @time];    npages ¬ Subr.PagesUsedInHugeZone[];    CWF.WF2[      "%u pages used in Huge Zone, %u entries in flattened DF files.\n"L,      @npages, @dfseq.size];    [] ¬ DFSubr.StripLongName[remoteName, host, dir, name];    remotePattern ¬ Subr.AllocateString[(remoteName.length + 4), dfZone];     CWF.SWF3[remotePattern, "[%s]<%s>%s"L, host, dir, name];    IF ~Subr.EndsIn[remotePattern, "*"L] THEN      String.AppendChar[remotePattern, '*];    IF ~Subr.Any[remotePattern, '!] THEN      String.AppendString[remotePattern, "!*"L];    remotePatternHost ¬ Subr.AllocateString[host.length, dfZone];    String.AppendString[remotePatternHost, host];    RunDeleteAll[dfseq, verbose];    EXITS      badUsage => {        CWF.WF0["\nUsage: RemoteDeleteAll directory dffile(s).\n"L];	outcome ¬ error};      error => {Subr.errorflg ¬ TRUE;  outcome ¬ error};      abort => outcome ¬ abort;    END;    time ¬ [Time.Current[] - startTime];    CWF.WF1["\nTotal elapsed time for RemoteDeleteAll %lr."L, @time];    IF Subr.errorflg THEN CWF.WF0["\tErrors logged.\n"L];    CWF.WFCR[];    Cleanup[]};      AlreadyRunning: ENTRY PROC RETURNS [yes: BOOLEAN] = {    IF nowRunning THEN RETURN[TRUE];    nowRunning ¬ TRUE;    RETURN[FALSE]};    DoneRunning: ENTRY PROC = {nowRunning ¬ FALSE};      RunDeleteAll: PROC [dfseq: DFSubr.DFSeq, verbose: BOOLEAN] = {    sh: MStream.Handle ¬ NIL;    saveCWFProc: PROC [CHARACTER] ¬ NIL;        WriteTwice: PROC [ch: CHARACTER] = {saveCWFProc[ch];  Stream.PutChar[sh, ch]};          BEGIN ENABLE UNWIND => {      IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL};      IF saveCWFProc # NIL THEN [] ¬ CWF.SetWriteProcedure[saveCWFProc]};    shortName1 ¬ hugezone.NEW[ShortNameSeq1[MaxDeleteFile]];    shortName2 ¬ hugezone.NEW[ShortNameSeq2[MaxDeleteFile]];    FOR i: CARDINAL IN [0..shortName1.maxsize) DO      shortName1[i] ¬ [name: NIL];      shortName2[i] ¬ [list: NIL];      ENDLOOP;         CWF.WF0["\nFilling in hash table..."L];    FOR i: CARDINAL IN [0..dfseq.size) DO      df: DFSubr.DF = @dfseq[i];      AddName[df.host, df.directory, df.shortname, df.version, df.createtime];      ENDLOOP;    CWF.WF0["done.\n"L];    CWF.WF3[      "(%u insertions, %u scans in %u looks.)\n"L, @nInsert, @nScan, @nLook];    CreateBTree[];    CWF.WF0["\n\n---------------------------------------------------------\n\n"L];    IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    IF verbose THEN {      sh ¬ MStream.WriteOnly["NotDeleted.list"L, [], text        ! MStream.Error => {            CWF.WF0["Unable to open NotDeleted.list.\n"L];            GOTO leave}];      saveCWFProc ¬ CWF.SetWriteProcedure[WriteTwice];      CWF.WF0["These files will NOT be deleted.\n"L];      CWF.WF0["\t(This list is also written to file NotDeleted.list)\n\n"L]};    CWF.WF1["Enumerating %s...\n\n"L, remotePattern];    IF verbose THEN       CWF.WF0[        "FileName                                         CreateTime          IFSPages\n"L];    BuildBTree[verbose];    IF verbose THEN {      [] ¬ CWF.SetWriteProcedure[saveCWFProc];  saveCWFProc ¬ NIL;      Stream.Delete[sh];  sh ¬ NIL};    CWF.WF0["\n\n---------------------------------------------------------\n\n"L];    IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    sh ¬ MStream.WriteOnly["ToBeDeleted.list"L, [], text      ! MStream.Error => {          CWF.WF0["Unable to open ToBeDeleted.list.\n"L];          GOTO leave}];    saveCWFProc ¬ CWF.SetWriteProcedure[WriteTwice];    nDelete ¬ 0;    CWF.WF0["These files WILL be deleted.\n"L];    CWF.WF0["\t(This list is also written to file ToBeDeleted.list)\n\n"L];    CWF.WF0[      "FileName                                         CreateTime          IFSPages\n"L];    EnumerateBTree[PrintListOfDeletes];    [] ¬ CWF.SetWriteProcedure[saveCWFProc];    Stream.Delete[sh];  sh ¬ NIL;    CWF.WF0["\n\n---------------------------------------------------------\n\n"L];    IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    CWF.WF0["File Deletion - for each file type:\n"L];    CWF.WF0["\ty to delete\n\tq to quit\n"L];    CWF.WF0["\tg ('Go on') to delete subsequent files w/o confirmation\n"L];    CWF.WF0["\tany other char to NOT delete.\n"L];    CWF.WF1["\nEnumerating %s...\n\n"L, remotePattern];    EnumerateBTree[ReallyDeleteFiles ! ABORTED => CONTINUE];    CWF.WF3[      "\n(%u files matched, %u files deleted, %u files skipped.)\n"L,      @nSkipDF, @nDelete, @nSkipNo];    EXITS leave => NULL;    END};  AddName: PROC [      host, directory, name: LONG STRING, version: CARDINAL,      createtime: Time.Packed] = {    n: NameList ¬ NIL;    element: CARDINAL ¬ HashedLookup[name];        ComputeHost: PROC [o: LONG STRING] RETURNS [n: LONG STRING] = {      RETURN[Subr.CopyString[o, hugezone]]};    ComputeDirectory: PROC [o: LONG STRING] RETURNS [n: LONG STRING] = {      IF lastD # NIL AND String.Equivalent[o, lastD] THEN n ¬ lastD      ELSE n ¬ lastD ¬ Subr.CopyString[o, hugezone]};          IF shortName1[element].name = NIL THEN {  -- not in table      shortName1[element] ¬ [name: Subr.CopyString[name, hugezone]];      shortName2[element] ¬ [list: NIL];      nInsert ¬ nInsert + 1};    n ¬ hugezone.NEW[NameListRecord ¬ [      host: ComputeHost[host], directory: ComputeDirectory[directory],      version: version, createtime: createtime,      list: shortName2[element].list]];    shortName2[element].list ¬ n};  -- if name found, returns element # NIL   -- if not, returns element with name = NIL (this is the first NIL encountered)   HashedLookup: PROC [name: LONG STRING] RETURNS [element: CARDINAL] = {    hv: CARDINAL ¬ Hash[name, shortName1.maxsize];  -- IN [0..maxsize)    nLook ¬ nLook + 1;    FOR i: CARDINAL IN [hv..shortName1.maxsize) DO      nScan ¬ nScan + 1;      IF shortName1[i].name = NIL THEN RETURN[i];      IF String.Equivalent[shortName1[i].name, name] THEN RETURN[i];      ENDLOOP;    FOR i: CARDINAL IN [0..hv) DO      nScan ¬ nScan + 1;      IF shortName1[i].name = NIL THEN RETURN[i];      IF String.Equivalent[shortName1[i].name, name] THEN RETURN[i];      ENDLOOP};      Hash: PROC [name: LONG STRING, modulo: CARDINAL] RETURNS [hv: CARDINAL] = {    h, i: CARDINAL ¬ 0;    v: Inline.BytePair;    DO      v.low ¬ LOOPHOLE[String.LowerCase[name[i]], CARDINAL];      i ¬ i + 1;      v.high ¬        IF i >= name.length THEN 0        ELSE LOOPHOLE[String.LowerCase[name[i]], CARDINAL];      i ¬ i + 1;      h ¬ Inline.BITXOR[h, v];      IF i >= name.length THEN EXIT;      ENDLOOP;    hv ¬ h MOD modulo};      BuildBTree: PROC [verbose: BOOLEAN] = {    filesFound: BOOLEAN ¬ FALSE;    nFiles: CARDINAL ¬ 0;    time: Time.Packed ¬ Time.Current[];    bval: BTreeValueRec;    ConsiderOneFile: FileTransfer.ListProc = {      remoteInfo: FileTransfer.FileInfo;      pages: CARDINAL;      ok, noRoom: BOOLEAN;      filesFound ¬ TRUE;      IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;      remoteInfo ¬ info[conn].source;      IF file.length > 2 AND Subr.EndsIn[file, ">!1"L] THEN        RETURN[do];  -- skip these questionable cases      nFiles ¬ nFiles + 1;      pages ¬ Inline.LowHalf[remoteInfo.size/IFSBytesPerPage + 2];      IF Match[remoteInfo] THEN {        IF verbose THEN {          IF ~String.Equivalent[lastDirectory, remoteInfo.directory] THEN {            CWF.WFCR[];  -- extra space            Subr.StrCopy[lastDirectory, remoteInfo.directory]};          IF file.length > 45 THEN            CWF.WF3["%s    %lt  %4u\n"L, file, @remoteInfo.create, @pages]          ELSE	    CWF.WF3["%-45s    %lt  %4u\n"L, file, @remoteInfo.create, @pages]};        nSkipPages ¬ nSkipPages + pages;        nSkipDF ¬ nSkipDF + 1}      ELSE {  -- insert in delete BTree	bval ¬ BTreeValueRec[create: remoteInfo.create, nIfsPages: pages];          nDeletePages ¬ nDeletePages + pages;        nDelete ¬ nDelete + 1;        [ok, noRoom] ¬ BTree.Insert[	  tree: deleteBTree, name: file, value: MakeValue[@bval]];	IF ~ok THEN 	  CWF.WF1["\n\nError: error when inserting %s into BTree.\n"L, file];	IF noRoom THEN 	  CWF.WF1["\n\nError: no room to insert %s into BTree.\n"L, file]};      RETURN[do]};    Transfer.EnumerateForProperties[remotePattern, ConsiderOneFile];    IF ~filesFound THEN CWF.WF1["%s not found.\n"L, remotePattern];    time ¬ [Time.Current[] - time];    CWF.WF2[      "\nEnumeration complete: %u files, elapsed time %lr.\n"L, @nFiles, @time];    CWF.WF3[      "Will offer to delete %u files - to free %lu pages, and leave %lu pages alone.\n"L,      @nDelete, @nDeletePages, @nSkipPages]};        Match: PROC [info: FileTransfer.FileInfo] RETURNS [dontDelete: BOOLEAN] = {    remdate: Time.Packed ¬ [0];    l: NameList;    element: CARDINAL ¬ HashedLookup[info.body];    IF shortName1[element].name = NIL THEN RETURN[FALSE]; -- not found    l ¬ shortName2[element].list;    WHILE l # NIL DO      IF String.Equivalent[l.directory, info.directory]      AND String.Equivalent[l.host, remotePatternHost]  -- FT bug: info.host=NIL      THEN {        IF l.createtime > 0 THEN {          IF remdate = 0 THEN remdate ¬ info.create;          IF remdate = l.createtime THEN RETURN[TRUE]};        IF l.version > 0 THEN {          IF ~String.Empty[info.version] THEN {            vers: CARDINAL ¬ 0;            vers ¬ String.StringToDecimal[info.version	      ! String.InvalidNumber => CONTINUE];            IF vers = l.version THEN RETURN[TRUE]}};        IF l.createtime = 0 AND l.version = 0 THEN RETURN[TRUE]};  --  >, #      l ¬ l.list;      ENDLOOP;    RETURN[FALSE]};        PrintListOfDeletes: BTreeEnumerateProc = {    createDate: Time.Packed ¬ value.create;    nPages: CARDINAL ¬ value.nIfsPages;    directory: STRING ¬ [100];    IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    Subr.StrCopy[directory, name];    FOR i: CARDINAL DECREASING IN [0..name.length) DO      IF name[i] = '> THEN {directory.length ¬ i;  EXIT};      ENDLOOP;    IF ~String.Equivalent[lastDirectory, directory] THEN {      CWF.WFCR[];  -- extra line of spaces      Subr.StrCopy[lastDirectory, directory]};    IF name.length > 45 THEN      CWF.WF3["%s    %lt  %4u\n"L, name, @createDate, @nPages]    ELSE      CWF.WF3["%-45s    %lt  %4u\n"L, name, @createDate, @nPages]};      ReallyDeleteFiles: BTreeEnumerateProc = {    createDate: Time.Packed ¬ value.create;    nPages: CARDINAL ¬ value.nIfsPages;    fullName: STRING ¬ [150];    ch: CHARACTER;    deleted: BOOLEAN;    IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    CWF.SWF2[fullName, "[%s]%s"L, remotePatternHost, name];    CWF.WF2["Delete %s of %lt"L, fullName, @value.create];    ch ¬ (      IF fullspeed THEN 'y      ELSE Subr.Confirm[defaultChar: 'n, window: NIL, allowAlways: FALSE]);    IF ch = 'q THEN {      CWF.WF0["Quit.\n"L];  nSkipNo ¬ nSkipNo + 1;  ERROR ABORTED};    IF ch = 'g THEN {      CWF.WF0["All\nDo you really want to delete without confirmation"L];      ch ¬ Subr.Confirm[defaultChar: 'n, window: NIL, allowAlways: FALSE];      SELECT ch FROM       'q => {CWF.WF0["Quit.\n"L];  nSkipNo ¬ nSkipNo + 1;  ERROR ABORTED};       'y => {fullspeed ¬ TRUE};  -- continues on to delete this file       ENDCASE};    IF ch = 'y THEN {      CWF.WF0["Yes..."L];      nDelete ¬ nDelete + 1;  deleted ¬ TRUE;      Transfer.Delete[fullName         ! FileTransfer.Error =>            SELECT code FROM	      notFound => {	        CWF.WF0[" - NOT found.\n"L];  deleted ¬ FALSE;  CONTINUE};	      accessDenied => {	        CWF.WF0[" - NOT deleted.\n"L];  deleted ¬ FALSE;  CONTINUE};	      ENDCASE];      IF deleted THEN CWF.WF0["deleted.\n"L]}    ELSE {CWF.WF0["No.\n"L];  nSkipNo ¬ nSkipNo + 1}};  -- Files-to-keep BTree support code   BTreeValue: TYPE = LONG POINTER TO BTreeValueRec;  BTreeValueRec: TYPE = RECORD [    create: Time.Packed ¬ [0], nIfsPages: CARDINAL ¬ 0];      BTreeEnumerateProc: TYPE = PROC [name: LONG STRING, value: BTreeValue];  CreateBTree: PROC = {    ENABLE UNWIND =>       IF deleteBTreeFile # NIL THEN {        MFile.Release[deleteBTreeFile];  deleteBTreeFile ¬ NIL};    deleteBTreeFile ¬ MFile.AcquireTemp[      type: binary,      initialLength: (LONG[initialBackingPages] * Environment.bytesPerPage)];    MFile.SetLength[      deleteBTreeFile, (LONG[initialBackingPages] * Environment.bytesPerPage)];    deleteBTree ¬ BTree.Make[      file: deleteBTreeFile, valueSize: SIZE[BTreeValueRec]];    haveBTree ¬ TRUE};      ReleaseBTree: PROC = {    IF deleteBTreeFile # NIL THEN {      BTree.Delete[deleteBTree];  deleteBTree ¬ NIL;      MFile.Release[deleteBTreeFile];  deleteBTreeFile ¬ NIL;      haveBTree ¬ FALSE}};  MakeValue: PROC [val: BTreeValue] RETURNS [BTree.Value] = {    RETURN[DESCRIPTOR[LOOPHOLE[val, LONG POINTER], SIZE[BTreeValueRec]]]};      EnumerateBTree: PROC [proc: BTreeEnumerateProc] = {    prevName: STRING;    nextName: STRING ¬ [100];    bValRec: BTreeValueRec;    bVal: BTree.Value ¬ DESCRIPTOR[@bValRec, SIZE[BTreeValueRec]];    BTree.GetNext[tree: deleteBTree, name: ""L, nextName: nextName, value: bVal];    WHILE ~String.Empty[nextName] DO      proc[name: nextName, value: LOOPHOLE[BASE[bVal]]];      prevName ¬ nextName;      BTree.GetNext[        tree: deleteBTree, name: prevName, nextName: nextName, value: bVal];      ENDLOOP};  Init: PROC = {Exec.AddCommand["RemoteDeleteAll.~"L, DoDelete]};  Init[];  END.Change log30-Mar-84  9:09:20	DSC  	added exception list handling.25-Sep-84 11:43:23	DSC  	removed employee names.
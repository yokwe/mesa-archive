-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- BringOverImpl.mesa - last edited by:--    Schmidt	 9-Mar-82 14:41:54--    BTL  	18-Nov-83 11:59:57--    NSG       19-Jul-84 16:43:23  changed spare1 to accessDenied--    DSC       29-May-86 13:34:25  DIRECTORY  BringOverInterface USING [CheckAbortProc, Options],  CWF USING [SWF1, SWF2, SWF3, SWF4, WF0, WF1, WF2, WF3, WF4, WFCR],  DFSubr USING [    AllocateDFSeq, CopyUsing, Criterion, DF, DFEntryProcType, DFSeq,    FreeDFSeq, FreeUsingSeq, InterestingNestedDFProcType, IntersectUsing,    LookupDF, LookupOneFile, NextDF, ParseStream, StripLongName,    TooManyParseErrors, UsingEmpty, UsingSeq, WriteOut],  FileName USING [Error, SetRemoteName],  FileTransfer USING [    Error, ErrorCode, FileInfo, FileType, GetStreamInfo, ListProc],  MFile USING [    Acquire, AppendErrorMessage, DeleteWhenReleased, Error,    GetCreateDate, GetFullName, Handle, maxNameLength,    Release, SetReadProtect, SetTimes, Type, WriteOnly],  MStream USING [Copy, Create, Error, Handle, ReadOnly, WriteOnly],  NSName USING [maxFullNameLength],  Stream USING [Delete, Handle],  String USING [    AppendChar, AppendExtensionIfNeeded, AppendString, Empty,    Equivalent, InvalidNumber, StringToDecimal],  Subr USING [    AllocateString, Confirm, ContainingDFNameError, CopyFile,    CopyString, debugflg, EndsIn, errorflg, FileError, FreeString,    integrationDir, integrationHost, localDFDir, Prefix,    SetContainingDFName, StrCopy, workingDFDir, workingDFHost],  Time USING [Packed],  Transfer USING [    EnumerateForProperties, EnumerateForRetrieve, RetrieveProcType],  Window USING [Handle];BringOverImpl: MONITOR    IMPORTS      CWF, DFSubr, FileName, FileTransfer, MFile, MStream, Stream, String,      Subr, Transfer    EXPORTS BringOverInterface =  BEGIN  MaxFiles: CARDINAL = 450;  accessDenied: FileTransfer.ErrorCode = FileTransfer.ErrorCode[accessDenied];  CheckThisFile: PUBLIC SIGNAL [checkfilename: LONG STRING] = CODE;  RecursiveLoop: PUBLIC SIGNAL [loopfilename: LONG STRING] = CODE;  nowRunning: BOOLEAN ¬ FALSE;  checkAbort: BringOverInterface.CheckAbortProc;     -- serialization   AlreadyRunning: PUBLIC ENTRY PROC RETURNS [yes: BOOLEAN] = {    IF nowRunning THEN RETURN[TRUE];    nowRunning ¬ TRUE;    RETURN[FALSE]};    DoneRunning: PUBLIC ENTRY PROC = {nowRunning ¬ FALSE};     -- main BringOver procedure   BringOverDF: PUBLIC PROC [      dfFileName: LONG STRING, usingSeq: DFSubr.UsingSeq,      opt: BringOverInterface.Options, localDir: LONG STRING,       dfZone: UNCOUNTED ZONE, window: Window.Handle,      abortProc: BringOverInterface.CheckAbortProc] = {    fakeDFSeq: DFSubr.DFSeq ¬ NIL;  -- one element DFSeq containing dfFileName    dfName, host, directory, shortname, containingDFFile: LONG STRING ¬ NIL;    nRetrieved: CARDINAL ¬ 0;    quit: BOOLEAN ¬ FALSE;        CleanUpInner: PROC = {      IF fakeDFSeq # NIL THEN DFSubr.FreeDFSeq[@fakeDFSeq];      IF dfName # NIL THEN {Subr.FreeString[dfName, dfZone];  dfName ¬ NIL};      IF host # NIL THEN {Subr.FreeString[host, dfZone];  host ¬ NIL};      IF directory # NIL THEN {        Subr.FreeString[directory, dfZone];  directory ¬ NIL};      IF shortname # NIL THEN {        Subr.FreeString[shortname, dfZone];  shortname ¬ NIL}};    DFEntryProc: DFSubr.DFEntryProcType = {      broughtover: BOOLEAN;      IF quit THEN RETURN;      -- called for every entry in the sequence, including @ df files      -- these @ df files cause NestedDFFileProc to be called ALSO      IF Subr.EndsIn[dfEntry.shortname, ".df"L] THEN {        IF opt.justReadOnlys AND ~dfEntry.readonly THEN RETURN;	IF opt.justNonReadOnlys AND dfEntry.readonly THEN RETURN}      ELSE {        IF opt.justReadOnlys AND ~dfEntry.readonly THEN RETURN;        IF opt.justNonReadOnlys AND dfEntry.readonly THEN RETURN;        IF opt.justSources AND IsDerivedFile[dfEntry] THEN RETURN;        IF opt.justObjects AND ~dfEntry.atsign	 AND ~IsDerivedFile[dfEntry] THEN RETURN};      [quit, broughtover] ¬ RetrieveEntry[        df: dfEntry, window: window, opt: opt, localDir: localDir,	containingDFFile: containingDFFile];      IF broughtover THEN nRetrieved ¬ nRetrieved + 1};    NestedDFFileProc: DFSubr.InterestingNestedDFProcType = {      sh: MStream.Handle ¬ NIL;      dfseq, dfseqInner: DFSubr.DFSeq ¬ NIL;      newUsing: DFSubr.UsingSeq ¬ NIL;            CleanUpNested: PROC = {        IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL};        IF newUsing # NIL AND innerUsingSeq # NIL THEN {	  DFSubr.FreeUsingSeq[newUsing];  newUsing ¬ NIL};        DFSubr.FreeDFSeq[@dfseqInner];  DFSubr.FreeDFSeq[@dfseq]};	        BEGIN ENABLE UNWIND => CleanUpNested[];      -- don't continue if q typed, df not on disk, or       -- (wrong version on disk and there is a remote host)      IF quit THEN RETURN;      IF CannotAnalyzeContents[dfEntry, opt] THEN RETURN;      -- using list processing      IF driverUsingSeq # NIL AND innerUsingSeq # NIL THEN {  -- do intersection        newUsing ¬ DFSubr.IntersectUsing[driverUsingSeq, innerUsingSeq];        IF newUsing = NIL THEN RETURN} -- no intersection      ELSE        IF innerUsingSeq # NIL THEN {  -- driverUsingSeq = NIL          -- this is an imported DF file with a using list          newUsing ¬ DFSubr.CopyUsing[innerUsingSeq];          -- allows first level to be non-public as well          publicOnly ¬ FALSE}  -- newUsing should be freed        ELSE          IF driverUsingSeq # NIL THEN {  -- innerUsingSeq = NIL            IF DFSubr.UsingEmpty[driverUsingSeq] THEN RETURN;  -- already empty            newUsing ¬ driverUsingSeq};  -- newUsing should NOT be freed      SIGNAL CheckThisFile[shortname];      PutLegendForDFFile[        name: shortname, nested: (nLevel > 0), hasUsing: (newUsing # NIL), 	exportsOnly: publicOnly, verify: opt.verify, preRelease: opt.preRelease];      containingDFFile ¬ shortname;  -- this is used by DFEntryProc      IF dfEntry = NIL THEN {        -- this calls RetrieveEntry for those DF files that appear in no DFseq        dfseqInner ¬ BuildFakeDFSeq[          host, directory, shortname, version, createtime, criterion];        dfEntry ¬ @dfseqInner[0];        DFEntryProc[dfEntry];	-- don't continue if q typed, df not on disk, wrong version on disk        IF quit THEN RETURN;        IF CannotAnalyzeContents[dfEntry, opt] THEN RETURN};      sh ¬ MStream.ReadOnly[dfEntry.shortname, []];      dfseq ¬ DFSubr.AllocateDFSeq[maxEntries: MaxFiles, zoneType: shared];      DFSubr.ParseStream[        sh: sh, dfseq: dfseq, dffilename: shortname, using: newUsing,        noremoteerrors:      FALSE,	forceReadonly:       entryIsReadonly,	omitNonPublic:       publicOnly,        interestingNestedDF: (IF opt.verify THEN NIL ELSE NestedDFFileProc),        dfEntryProc:         (IF opt.verify THEN NIL ELSE DFEntryProc),	nLevel:              (nLevel + 1),        ancestor:            (IF ancestor = NIL THEN shortname ELSE ancestor),	limitErrors:	     TRUE           ! CheckThisFile =>              IF String.Equivalent[shortname, checkfilename] THEN                ERROR RecursiveLoop[checkfilename];	    DFSubr.TooManyParseErrors => {	      CWF.WF1[" - parse abandoned, too many errors in %s.\n"L, shortname];	      GOTO leave}];        Stream.Delete[sh];  sh ¬ NIL;      IF nLevel = 1 THEN CheckForMissingImports[newUsing];      IF opt.verify THEN {ProcessVerify[dfEntry, dfseq];  GOTO leave};      EXITS leave => NULL;      END;      CleanUpNested[];      PutClosingLegendForDFFile[name: shortname, nested: (nLevel > 0)]};    BEGIN ENABLE UNWIND => CleanUpInner[];  -- start of BringOverDF    version: CARDINAL;    goOn, fetchDFConfirmed, saveMustConfirm: BOOLEAN;    [] ¬ String.AppendExtensionIfNeeded[@dfFileName, ".df"L, dfZone];    checkAbort ¬ abortProc;    Subr.debugflg ¬ opt.debugging;    dfName    ¬ Subr.AllocateString[nchars: MFile.maxNameLength, zone: dfZone];    host      ¬ Subr.AllocateString[nchars: NSName.maxFullNameLength, zone: dfZone];    directory ¬ Subr.AllocateString[nchars: 100, zone: dfZone];    shortname ¬ Subr.AllocateString[nchars: MFile.maxNameLength, zone: dfZone];    String.AppendString[dfName, dfFileName];    IF opt.preRelease THEN       IF ~SetUpForPreReleaseMode[window] THEN GOTO leave;    -- check that local DF file is not older than !H on the default DF directory    -- (gotten from User.cm); note that DFVersionOK may update dfName    [goOn, fetchDFConfirmed] ¬ DFVersionOK[dfName, opt.preRelease, window];    IF goOn THEN {      version ¬ DFSubr.StripLongName[dfName, host, directory, shortname];      IF BadDFFileName[shortname] THEN GOTO leave;      fakeDFSeq ¬ FakeDFSeqForOutermostDF[host, directory, shortname, version];      IF fetchDFConfirmed THEN {        saveMustConfirm ¬ opt.mustConfirm;  opt.mustConfirm  ¬ FALSE};      DFEntryProc[@fakeDFSeq[0]];      IF fetchDFConfirmed THEN opt.mustConfirm ¬ saveMustConfirm;      DFSubr.LookupOneFile[@fakeDFSeq[0]];      IF fakeDFSeq[0].presentonlocaldisk THEN {        FreeFileHandle[@fakeDFSeq[0]];         NestedDFFileProc[          host: host, directory: directory, shortname: shortname, ancestor: NIL,          immediateParent: NIL, version: version, nLevel: 0,	  createtime: Time.Packed[0],	  driverUsingSeq: usingSeq, innerUsingSeq: NIL, dfEntry: @fakeDFSeq[0],          entryIsReadonly: FALSE, publicOnly: opt.publicOnly, criterion: none]}};    EXITS leave => NULL;    END;    CleanUpInner[];    PostFilesRetrieved[nRetrieved]};      FreeFileHandle: PROC [df: DFSubr.DF] = {    IF df.fHandle # NIL THEN MFile.Release[df.fHandle];    df.fHandle ¬ NIL;  df.presentonlocaldisk ¬ FALSE};        CannotAnalyzeContents: PROC [        df: DFSubr.DF, opt: BringOverInterface.Options]      RETURNS [cannot: BOOLEAN ¬ FALSE] = {    IF df = NIL THEN RETURN;    DFSubr.LookupOneFile[df];    IF ~df.presentonlocaldisk OR (df.need AND ~String.Empty[df.host]) THEN {      cannot ¬ TRUE;      IF Subr.EndsIn[df.shortname, ".df"L] THEN {        IF ~(opt.justReadOnlys AND ~df.readonly)	AND ~(opt.justNonReadOnlys AND df.readonly) THEN 	  CWF.WF1["Warning - cannot analyze contents of %s\n"L, df.shortname]}};    FreeFileHandle[df]};      BadDFFileName: PROC [dfName: LONG STRING] RETURNS [bad: BOOLEAN] = {    IF ~Subr.EndsIn[dfName, ".df"L] THEN {      CWF.WF1["Error - %s must be a DF file name.\n"L, dfName];      Subr.errorflg ¬ TRUE;      RETURN[TRUE]};    RETURN[FALSE]};       SetUpForPreReleaseMode: PROC [      window: Window.Handle] RETURNS [continue: BOOLEAN] = {    ch: CHARACTER;    IF String.Empty[Subr.integrationHost] THEN {      CWF.WF0["Error - BringOver PreRelease mode but no IntegrationLoc given in User.cm [DFTool] section\n"L];      ERROR ABORTED};    CWF.WF0["Warning - BringOver PreRelease mode: newer local versions may be OVERWRITTEN.\n"L];    DO      CWF.WF0["\tContinue"L];      ch ¬ Subr.Confirm[defaultChar: 'y, window: window, allowAlways: TRUE];      SELECT ch FROM	'y => {CWF.WF0[" Yes.\n"L];  RETURN[continue: TRUE]};	'n => {CWF.WF0[" No.\n"L];   RETURN[continue: FALSE]};	'q => {CWF.WF0[" Quit.\n"L]; ERROR ABORTED};	ENDCASE => CWF.WF0[" ? (please reply one of y, n, q).\n"L];      ENDLOOP};        PostFilesRetrieved: PROC [nRetrieved: CARDINAL] = {    IF nRetrieved > 0 THEN CWF.WF1["%u files retrieved.\n"L, @nRetrieved]    ELSE CWF.WF0["No files retrieved.\n"L]};          IsDerivedFile: PROC [df: DFSubr.DF] RETURNS [BOOLEAN] = {    RETURN[Subr.EndsIn[df.shortname, ".Bcd"L]       OR Subr.EndsIn[df.shortname, ".Symbols"L]      OR Subr.EndsIn[df.shortname, ".Obj"L]      OR Subr.EndsIn[df.shortname, ".Lnk"L]      OR Subr.EndsIn[df.shortname, ".Loc"L]      OR Subr.EndsIn[df.shortname, ".Hex"L]      OR Subr.EndsIn[df.shortname, ".Com"L]      OR Subr.EndsIn[df.shortname, ".Boot"L]        OR Subr.EndsIn[df.shortname, ".Signals"L]        OR Subr.EndsIn[df.shortname, ".Press"L]]};  FakeDFSeqForOutermostDF: PROC [        host, directory, shortname: LONG STRING, version: CARDINAL]      RETURNS [dfseq: DFSubr.DFSeq] = {    df: DFSubr.DF;    dfseq ¬ DFSubr.AllocateDFSeq[maxEntries: 1, zoneType: shared];    df ¬ DFSubr.NextDF[dfseq];    df.host ¬ (      IF host.length = 0 THEN NIL ELSE Subr.CopyString[host, dfseq.dfzone]);    df.directory ¬ (      IF directory.length = 0 THEN NIL      ELSE Subr.CopyString[directory, dfseq.dfzone]);    df.shortname ¬ Subr.CopyString[shortname, dfseq.dfzone];    df.version ¬ version;    df.createtime ¬ Time.Packed[0];    df.criterion ¬ none};      PutLegendForDFFile: PROC [      name: LONG STRING,      nested, hasUsing, exportsOnly, verify, preRelease: BOOLEAN] = {    IF nested THEN CWF.WF1["\nNested BringOver of %s"L, name]    ELSE CWF.WF1["BringOver of %s"L, name];    IF hasUsing THEN CWF.WF0[" (with Using list)"L]    ELSE IF exportsOnly THEN CWF.WF0[" (Exports only)"L]    ELSE IF verify THEN CWF.WF0[" (Verify mode)"L]    ELSE IF preRelease THEN CWF.WF0[" (PreRelease mode)"L];    CWF.WFCR[]};      PutClosingLegendForDFFile: PROC [name: LONG STRING, nested: BOOLEAN] = {    IF nested THEN CWF.WF1["End of nested BringOver of %s\n"L, name]    ELSE CWF.WF1["End of BringOver of %s\n"L, name]};      DFVersionOK: PROC [        dfName: LONG STRING,  -- *** may be modified if to use remote version	preRelease: BOOLEAN, window: Window.Handle]      RETURNS [goOn, fetchDFConfirmed: BOOLEAN] = {    shortname: STRING ¬ [MFile.maxNameLength];    remoteName: STRING ¬ [150];    f: MFile.Handle ¬ NIL;    localTime, remoteTime: Time.Packed;    found: BOOLEAN;    BEGIN ENABLE UNWIND => IF f # NIL THEN {MFile.Release[f];  f ¬ NIL};    goOn ¬ TRUE;  fetchDFConfirmed ¬ FALSE;    IF dfName[0] = '[ OR String.Empty[Subr.workingDFHost] THEN RETURN;    [] ¬ DFSubr.StripLongName[dfName, NIL, NIL, shortname];    IF preRelease THEN {      IF ~Subr.EndsIn[Subr.integrationDir, ">DF"L] THEN  -- add ">DF"         CWF.SWF3[          remoteName, "[%s]<%s>DF>%s!H"L,	  Subr.integrationHost, Subr.integrationDir, shortname]      ELSE        CWF.SWF3[          remoteName, "[%s]<%s>%s!H"L,	 Subr.integrationHost, Subr.integrationDir, shortname]}    ELSE      CWF.SWF3[        remoteName, "[%s]<%s>%s!H"L,	Subr.workingDFHost, Subr.workingDFDir, shortname];    f ¬ MFile.Acquire[      name: shortname, access: anchor, release: [] ! MFile.Error => CONTINUE];    IF f = NIL THEN {      Subr.StrCopy[dfName, remoteName];  -- use remote version      dfName.length ¬ dfName.length - 2;  -- remove !H      RETURN[goOn: TRUE, fetchDFConfirmed: TRUE]};      localTime ¬ MFile.GetCreateDate[f];    MFile.Release[f];  f ¬ NIL;    -- now get remote create date    [found, remoteTime] ¬ CheckHighestRemoteVersion[remoteName];    IF ~found THEN RETURN[goOn: TRUE, fetchDFConfirmed: FALSE];    IF preRelease THEN {      IF localTime = remoteTime THEN        RETURN[goOn: TRUE, fetchDFConfirmed: FALSE]  -- use local version      ELSE {        Subr.StrCopy[dfName, remoteName];  -- use remote version	dfName.length ¬ dfName.length-2;   -- remove !H        RETURN[goOn: TRUE, fetchDFConfirmed: TRUE]}};    -- normal (not preRelease) mode    IF localTime >= remoteTime THEN  -- use newer local version      RETURN[goOn: TRUE, fetchDFConfirmed: FALSE]    ELSE {      validResponse: BOOLEAN ¬ FALSE;      ch: CHARACTER;      CWF.WF3[        "\n\tThe highest working version of %s has a NEWER date (%lt) than the local file (%lt).\n"L,        shortname, @remoteTime, @localTime];      UNTIL validResponse DO        CWF.WF0["\tShould the newer remote version be used"L];	ch ¬ Subr.Confirm[defaultChar: 'y, window: window, allowAlways: FALSE];	SELECT ch FROM	  'y => {	    CWF.WF0[" Yes.\n"L];	    Subr.StrCopy[dfName, remoteName];  -- *** N.B. dfName is modified!	    dfName.length ¬ dfName.length - 2;  -- remove !H	    RETURN[goOn: TRUE, fetchDFConfirmed: TRUE]};	  'n => {CWF.WF0[" No.\n"L];  validResponse ¬ TRUE};	  'q => {CWF.WF0[" Quit.\n"L];  ERROR ABORTED};	  ENDCASE => CWF.WF0[" ? (please reply one of y, n, a, q).\n"L];        ENDLOOP;      DO        CWF.WF0["\tShould the older local version be used"L];        ch ¬ Subr.Confirm[defaultChar: 'n, window: window, allowAlways: FALSE];        SELECT ch FROM          'y => {CWF.WF0[" Yes.\n"L];  RETURN};	  'n => {	    CWF.WF0[" No.\n"L];  RETURN[goOn: FALSE, fetchDFConfirmed: FALSE]};          'q => {CWF.WF0[" Quit.\n"L];  ERROR ABORTED};	  ENDCASE => CWF.WF0[" ? (please reply one of y, n, a, q).\n"L];        ENDLOOP};    END};    CheckHighestRemoteVersion: PROC [      remoteName: STRING] RETURNS [found: BOOLEAN, remoteTime: Time.Packed] = {          ConsiderBangH: FileTransfer.ListProc = {      remoteInfo: FileTransfer.FileInfo ¬ info[conn].source;      found ¬ TRUE;  remoteTime ¬ remoteInfo.create;      RETURN[do]};          found ¬ FALSE;  remoteTime ¬ [0];    Transfer.EnumerateForProperties[remoteName, ConsiderBangH]};     FreeUsingSeqWithError: PUBLIC PROC [newUsing: DFSubr.UsingSeq] = {    CheckForMissingImports[newUsing];    DFSubr.FreeUsingSeq[newUsing]};     CheckForMissingImports: PROC [newUsing: DFSubr.UsingSeq] = {    IF ~DFSubr.UsingEmpty[newUsing] THEN {      CWF.WF0["Error - cannot find "L];      FOR i: CARDINAL IN [0..newUsing.size) DO        IF newUsing[i] # NIL THEN CWF.WF1["%s "L, newUsing[i]];	ENDLOOP;      CWF.WF0["in any nested DF file.\n"L];      Subr.errorflg ¬ TRUE}};  BuildFakeDFSeq: PROC [        host, directory, shortname: LONG STRING, version: CARDINAL,        createtime: Time.Packed, criterion: DFSubr.Criterion]      RETURNS [dfseq: DFSubr.DFSeq] = {    df: DFSubr.DF;    dfseq ¬ DFSubr.AllocateDFSeq[maxEntries: 1, zoneType: shared];    df ¬ DFSubr.NextDF[dfseq];    df.host ¬      (IF host.length = 0 THEN NIL ELSE Subr.CopyString[host, dfseq.dfzone]);    df.directory ¬      (IF directory.length = 0 THEN NIL       ELSE Subr.CopyString[directory, dfseq.dfzone]);    df.shortname ¬ Subr.CopyString[shortname, dfseq.dfzone];    df.version ¬ version;    df.createtime ¬ createtime;    df.criterion ¬ criterion};      -- df.need is TRUE if the file is not found on the remote server or  --  the user declines to bring it over.  -- Now frees df.fHandle and sets df.presentonlocaldisk FALSE when done.  RetrieveEntry: PROC [        df: DFSubr.DF, window: Window.Handle,	opt: BringOverInterface.Options,	localDir, containingDFFile: LONG STRING]      RETURNS [quit, broughtover: BOOLEAN] = {    b, q, foundOnRemote, foundOneVersion, refused: BOOLEAN ¬ FALSE;    localDate: Time.Packed;    BEGIN ENABLE UNWIND => FreeFileHandle[df];    quit ¬ broughtover ¬ FALSE;    DFSubr.LookupOneFile[df];    IF ~df.presentonlocaldisk AND String.Empty[df.host] THEN {      CWF.WF1["Error - can't open %s and remote host is empty.\n"L, df.shortname];      Subr.errorflg ¬ TRUE;  GOTO leave};    IF ~df.presentonlocaldisk OR df.createtime = Time.Packed[0]      OR df.criterion = update THEN {      localDate ¬ Time.Packed[0];  df.need ¬ TRUE}    ELSE {      localDate ¬ MFile.GetCreateDate[df.fHandle];      df.need ¬ (df.createtime # localDate)};    IF ~df.need OR String.Empty[df.host] THEN GOTO leave;    -- use df.version as a hint; if df.createtime = 0 takes highest version #    IF df.version > 0 OR df.createtime = 0 THEN {      [foundOnRemote: foundOnRemote, broughtover: b, quit: q, refused: refused] ¬        TryExplicitVersion[          df: df, localDate: localDate, window: window, opt: opt,	  localDir: localDir, containingDFFile: containingDFFile];      broughtover ¬ broughtover OR b;      quit        ¬ quit OR q;      df.need     ¬ refused OR ~foundOnRemote;      IF b OR q OR foundOnRemote OR refused THEN GOTO leave};    [foundOneVersion: foundOneVersion, foundOnRemote: foundOnRemote,     broughtover: b, quit: q, refused: refused] ¬ TryAnyVersion[       df: df, localDate: localDate, window: window, opt: opt,       localDir: localDir, containingDFFile: containingDFFile];    broughtover ¬ broughtover OR b;    quit        ¬ quit OR q;    df.need     ¬ refused OR ~foundOnRemote;    IF b OR q OR refused THEN GOTO leave;    IF foundOneVersion AND ~foundOnRemote THEN {      CWF.WF2[        "\nError - %s of %lt is not available; will offer the most recent version."L,        df.shortname, @df.createtime];      Subr.errorflg ¬ TRUE;      df.createtime ¬ Time.Packed[0];  df.version ¬ 0;      [foundOnRemote: foundOnRemote, broughtover: b, quit: q, refused: refused] ¬        TryExplicitVersion[          df: df, localDate: localDate, window: window, opt: opt,	  localDir: localDir, containingDFFile: containingDFFile];      df.need     ¬ refused OR ~foundOnRemote;      broughtover ¬ broughtover OR b;      quit        ¬ quit OR q};    EXITS leave => NULL;    END;    FreeFileHandle[df]};        -- TryAnyVersion and TryExplicitVersion retrieve as follows:  -- 	if there is a create time, checks !H for that create time  --	else if there is a version and > or #, checks !H  --	else if there is a version and no createtime and no > or #,  --      checks the explicit version  -- 	(checking in the last two cases always does a retrieval,  --     so no create time results in the check succeeding)    TryAnyVersion: PROC [        df: DFSubr.DF, localDate: Time.Packed, window: Window.Handle, 	opt: BringOverInterface.Options, localDir, containingDFFile: LONG STRING]      RETURNS [        foundOneVersion, foundOnRemote, broughtover, quit, refused: BOOLEAN] = {    fn: STRING ¬ [150];    ConsiderFile: Transfer.RetrieveProcType = {      info: FileTransfer.FileInfo ¬ FileTransfer.GetStreamInfo[s];      remdate: Time.Packed ¬ info.create;      foundOneVersion ¬ TRUE;      IF df.createtime # remdate THEN RETURN[skipRest: FALSE];      -- dates agree, go get it      [broughtover, quit, refused] ¬ ProceedWithBringOver[        df: df, remoteName: fileName, info: info,	opt: opt, localDir: localDir, window: window,	remDate: remdate, localDate: localDate, remoteStream: s,	containingDFFile: containingDFFile];      foundOnRemote ¬ TRUE;      RETURN[skipRest: TRUE]};    foundOneVersion ¬ foundOnRemote ¬ broughtover ¬ quit ¬ refused ¬ FALSE;    IF df.version > 0 AND df.createtime = Time.Packed[0]    AND df.criterion = none THEN {      CWF.WF4[        "Error - [%s]<%s>%s!%u: version not found.\n"L,	df.host, df.directory, df.shortname, @df.version];      Subr.errorflg ¬ TRUE;      RETURN};    CWF.SWF3[fn, "[%s]<%s>%s!*"L, df.host, df.directory, df.shortname];    Transfer.EnumerateForRetrieve[fn, ConsiderFile      ! FileTransfer.Error =>	  SELECT code FROM	    retry => {	      foundOneVersion ¬ foundOnRemote ¬ broughtover ¬ FALSE;	      RETRY};	    accessDenied => {	      CWF.WF3[	        "Error - Insufficient credentials to retrieve [%s]<%s>%s.\n"L,	        df.host, df.directory, df.shortname];	      GOTO cantRead};	    ENDCASE => REJECT];    IF ~foundOneVersion THEN {      fn.length ¬ fn.length - 2;      CWF.WF1["Error - %s was not found\n"L, fn];      Subr.errorflg ¬ TRUE};    EXITS cantRead => {      foundOneVersion ¬ foundOnRemote ¬ broughtover ¬ quit ¬ FALSE;      refused ¬ TRUE;      Subr.errorflg ¬ TRUE}};  TryExplicitVersion: PROC [        df: DFSubr.DF, localDate: Time.Packed, window: Window.Handle,  	opt: BringOverInterface.Options, localDir, containingDFFile: LONG STRING]      RETURNS [foundOnRemote, broughtover, quit, refused: BOOLEAN] = {    fn: STRING ¬ [150];    OnlyOneFile: Transfer.RetrieveProcType = {      info: FileTransfer.FileInfo ¬ FileTransfer.GetStreamInfo[s];      remdate: Time.Packed ¬ info.create;      IF df.createtime # Time.Packed[0] AND df.createtime # remdate THEN        RETURN[skipRest: FALSE];  -- actually, we should only see one file      -- date is ok, go get it      [broughtover, quit, refused] ¬ ProceedWithBringOver[        df: df, remoteName: fileName, info: info,	opt: opt, localDir: localDir, window: window,	remDate: remdate, localDate: localDate, remoteStream: s,	containingDFFile: containingDFFile];      foundOnRemote ¬ TRUE;      RETURN[skipRest: TRUE]};    foundOnRemote ¬ broughtover ¬ quit ¬ refused ¬ FALSE;    IF df.createtime = Time.Packed[0]    AND (df.criterion # none OR df.version = 0) THEN      CWF.SWF3[fn, "[%s]<%s>%s!H"L, df.host, df.directory, df.shortname]    ELSE      CWF.SWF4[fn, "[%s]<%s>%s!%u"L, df.host, df.directory, df.shortname, @df.version];    Transfer.EnumerateForRetrieve[fn, OnlyOneFile      ! FileTransfer.Error =>	  SELECT code FROM	    retry => {	      foundOnRemote ¬ broughtover ¬ FALSE;	      RETRY};	    accessDenied => {	      CWF.WF3[	        "Error - Insufficient credentials to retrieve [%s]<%s>%s.\n"L,	        df.host, df.directory, df.shortname];	      GOTO cantRead};	    ENDCASE => REJECT];    EXITS cantRead => {      foundOnRemote ¬ broughtover ¬ quit ¬ FALSE;      refused ¬ TRUE;      Subr.errorflg ¬ TRUE}};  ProceedWithBringOver: PROC [        df: DFSubr.DF, remoteName: LONG STRING, info: FileTransfer.FileInfo,	opt: BringOverInterface.Options, localDir: LONG STRING,	window: Window.Handle,	remDate, localDate: Time.Packed, remoteStream: Stream.Handle,	containingDFFile: LONG STRING]      RETURNS [broughtover, quit, refused: BOOLEAN] = {    nameIfRetrieved: STRING ¬ [MFile.maxNameLength];    local, newerLocal, diffVersions: BOOLEAN ¬ FALSE;    broughtover ¬ quit ¬ refused ¬ FALSE;    IF checkAbort[] THEN ERROR ABORTED;    IF opt.archiveBcdRename AND Subr.EndsIn[df.shortname, ".bcd"L] THEN {      IF ~String.Empty[localDir] THEN	String.AppendString[nameIfRetrieved, localDir];      FOR i: CARDINAL IN [0..df.shortname.length) DO        IF df.shortname[i] = '. THEN EXIT;        String.AppendChar[nameIfRetrieved, df.shortname[i]];        ENDLOOP;      String.AppendString[nameIfRetrieved, ".archiveBcd"L];      [local, localDate] ¬ LookupArchiveBcd[df.shortname]}    ELSE {      local ¬ df.presentonlocaldisk;      IF local AND localDate = Time.Packed[0] THEN        localDate ¬ MFile.GetCreateDate[df.fHandle];      IF ~local THEN {  -- add actual dir to which we will retrieve file        IF ~String.Empty[Subr.localDFDir]        AND Subr.EndsIn[df.shortname, ".df"L] THEN           String.AppendString[nameIfRetrieved, Subr.localDFDir]        ELSE IF ~String.Empty[localDir] THEN	  String.AppendString[nameIfRetrieved, localDir]};      String.AppendString[nameIfRetrieved, df.shortname]};    IF opt.preRelease AND localDate = remDate THEN RETURN;    IF ~opt.forceRetrieval AND ~opt.preRelease THEN {      IF (df.criterion = update AND localDate >= remDate)      OR localDate = remDate      OR (opt.updateExisting AND (~local OR localDate >= remDate)) THEN RETURN};    CWF.WF2["\n%s (%lt)\n"L, remoteName, @remDate];    IF local AND (localDate > remDate AND df.criterion # update)    AND ~opt.getOlderOK AND ~opt.updateExisting AND ~opt.preRelease AND ~opt.forceRetrieval THEN {      CWF.WF1[	"\tShould it be retrieved over the NEWER local version of %lt"L,	@localDate];      newerLocal ¬ TRUE}    ELSE PutFeedback[nameIfRetrieved, local, remDate, localDate];    IF df.createtime # Time.Packed[0] AND df.createtime # remDate    AND ~opt.preRelease THEN {      CWF.WF1["\n\tError - you wanted (%lt)  Retrieve it?"L, @df.createtime];      diffVersions ¬ TRUE};    IF opt.mustConfirm OR newerLocal OR diffVersions THEN {      validResponse: BOOLEAN ¬ FALSE;      ch: CHARACTER;      UNTIL validResponse DO	ch ¬ Subr.Confirm[	  defaultChar: (IF newerLocal THEN 'n ELSE 'y),	  window: window, allowAlways: ~newerLocal];        SELECT ch FROM          'y => {CWF.WF0[" Yes"L];  validResponse ¬ TRUE};	  'n => {CWF.WF0[" No.\n"L];   refused ¬ TRUE;  RETURN};	  'q => {CWF.WF0[" Quit.\n"L]; quit ¬ TRUE;  RETURN};	  ENDCASE => CWF.WF0[" ? (not one of y, n, a, q) - confirm"L];	ENDLOOP};    IF Subr.Prefix[df.shortname, "BringOver."L] THEN      HandleBringOverSpecialCase[nameIfRetrieved, opt.archiveBcdRename];    CWF.WF0["..."L];    broughtover ¬ RetrieveBits[      df: df, remoteName: remoteName, localName: nameIfRetrieved,      info: info, remDate: remDate, remoteStream: remoteStream,      containingDFFile: containingDFFile];    IF broughtover THEN CWF.WF1["%lu bytes.\n"L, @info.size]};      PutFeedback: PROC [      localName: LONG STRING, local: BOOLEAN, remDate, localDate: Time.Packed] = {    SELECT TRUE FROM      ~local => CWF.WF1["\tto new file %s"L, localName];      remDate < localDate =>        CWF.WF2["\tto newer file %s (%lt)"L, localName, @localDate];      remDate > localDate =>	CWF.WF2["\tto older file %s (%lt)"L, localName, @localDate];      ENDCASE => CWF.WF1["\tto local file %s (same)"L, localName]};      RetrieveBits: PROC [        df: DFSubr.DF, remoteName, localName: LONG STRING,	info: FileTransfer.FileInfo,	remDate: Time.Packed, remoteStream: Stream.Handle,	containingDFFile: LONG STRING]      RETURNS [broughtover: BOOLEAN] = {    f: MFile.Handle ¬ NIL;    s: MStream.Handle ¬ NIL;    actualBytes: LONG CARDINAL;    BEGIN ENABLE UNWIND => {      IF s # NIL THEN {Stream.Delete[s];  s ¬ NIL;  f ¬ NIL};      IF f # NIL THEN {MFile.Release[f];  f ¬ NIL}};    broughtover ¬ TRUE;    FreeFileHandle[df];    f ¬ MFile.WriteOnly[      name: localName, release: [], type: MFileTypeFor[info.type],      initialLength: info.size      ! MFile.Error => {	  msg: STRING ¬ [100];	  MFile.AppendErrorMessage[msg, code, file];	  CWF.WF1["NOT retrieved - MFile error: %s.\n"L, msg];	  broughtover ¬ FALSE;  CONTINUE}];    IF ~broughtover THEN RETURN;    s ¬ MStream.Create[f, []      ! MStream.Error => ERROR Subr.FileError[accessConflict]];    MFile.SetReadProtect[file: f, readProtected: TRUE];    actualBytes ¬ MStream.Copy[from: remoteStream, to: s, bytes: info.size];    MFile.SetReadProtect[file: f, readProtected: FALSE];    MFile.SetTimes[file: f, create: remDate];    FileName.SetRemoteName[f, remoteName ! FileName.Error => CONTINUE];    Subr.SetContainingDFName[f, containingDFFile      ! Subr.ContainingDFNameError => CONTINUE];     Stream.Delete[s];  s ¬ NIL;  f ¬ NIL;    IF actualBytes # info.size THEN        CWF.WF1["(Warning - remote length is %lu bytes)..."L, @actualBytes];    END};        LookupArchiveBcd: PROC [      shortname: LONG STRING] RETURNS [local: BOOLEAN, localDate: Time.Packed] = {    localName: STRING ¬ [MFile.maxNameLength];    f: MFile.Handle ¬ NIL;    local ¬ TRUE;  localDate ¬ Time.Packed[0];    FOR i: CARDINAL IN [0..shortname.length) DO      IF shortname[i] = '. THEN EXIT;      String.AppendChar[localName, shortname[i]];      ENDLOOP;    String.AppendString[localName, ".archiveBcd"L];     f ¬ MFile.Acquire[name: localName, access: anchor, release: []      ! MFile.Error => {local ¬ FALSE;  CONTINUE}];    IF local THEN {localDate ¬ MFile.GetCreateDate[f];  MFile.Release[f]}};      MFileTypeFor: PROC [type: FileTransfer.FileType] RETURNS [MFile.Type] = {    RETURN[      SELECT type FROM        unknown   => unknown,        text      => text,        binary    => binary,        directory => directory,	ENDCASE   => unknown]};          HandleBringOverSpecialCase: PROC [      localName: LONG STRING, archiveBcdRename: BOOLEAN] = {    zap: BOOLEAN ¬ FALSE;    f: MFile.Handle ¬ NIL;    f ¬ MFile.WriteOnly[localName, [], unknown      ! MFile.Error => {IF code = conflictingAccess THEN zap ¬ TRUE;  CONTINUE}];    IF f # NIL THEN {MFile.Release[f];  f ¬ NIL;  RETURN};    IF zap THEN {      f ¬ MFile.Acquire[name: localName, access: anchor, release: []        ! MFile.Error => CONTINUE];      IF f # NIL THEN {        CWF.WF0[	  "\n\tWarning - you have just retrieved a new version of BringOver.\n"L];        CWF.WF0["\tIf you want to use the new version, you must either\n"L];        CWF.WF0[          "\ttype 'run BringOver' to the Executive, or boot this volume.\n"L];        MFile.GetFullName[file: f, name: localName ! MFile.Error => CONTINUE];        MFile.DeleteWhenReleased[f ! MFile.Error => CONTINUE]}}};  ProcessVerify: PROC [topDf: DFSubr.DF, dfseq: DFSubr.DFSeq] = {    df, dfInner: DFSubr.DF;    fn: STRING ¬ [150];    highestVersion: CARDINAL;    highestDate, localDate: Time.Packed;    oneVersionFound, found, newerVersions, fillInVersionNums: BOOLEAN ¬ FALSE;    ConsiderOneFile: FileTransfer.ListProc = {      remoteInfo: FileTransfer.FileInfo;      version: CARDINAL ¬ 0;      remoteDate: Time.Packed;      oneVersionFound ¬ TRUE;      remoteInfo ¬ info[conn].source;      IF ~String.Empty[remoteInfo.version] THEN        version ¬ String.StringToDecimal[remoteInfo.version	  ! String.InvalidNumber => {version ¬ 0;  CONTINUE}];      remoteDate ¬ remoteInfo.create;      IF version > highestVersion THEN {        highestVersion ¬ version;  highestDate ¬ remoteDate};      IF found THEN RETURN[do];      IF df.createtime # Time.Packed[0] AND df.createtime = remoteDate THEN {        found ¬ TRUE;        IF df.version = 0 OR df.version < version THEN {          df.version ¬ version;  fillInVersionNums ¬ TRUE}}      ELSE        IF df.createtime = Time.Packed[0] THEN {          IF df.version > 0 AND df.criterion = none THEN {            IF df.version = version THEN found ¬ TRUE}          ELSE found ¬ TRUE}	ELSE IF df.createtime < remoteDate THEN 	  CWF.WF4[            "\n  (Warning: DF file has version !%u and date %lt, but remote version %u has newer date %lt)\n"L,	    @df.version, @df.createtime, @version, @remoteDate];      -- as a side effect add remote name property      IF df.presentonlocaldisk AND localDate = remoteDate THEN {        temp: LONG STRING ¬ [150]; 	CWF.SWF2[temp, "[%s]%s"L, df.host, file];        FileName.SetRemoteName[df.fHandle, temp ! FileName.Error => CONTINUE]};      RETURN[do]};    FOR i: CARDINAL IN [0..dfseq.size) DO      BEGIN      df ¬ @dfseq[i];      IF String.Empty[df.host] THEN {        CWF.WF1[	  "Warning - unable to verify %s on remote server.\n"L, df.shortname];        LOOP};      df.fHandle ¬ NIL;  df.presentonlocaldisk ¬ TRUE;      df.fHandle ¬ MFile.Acquire[name: df.shortname, access: anchor, release: []        ! MFile.Error => {df.presentonlocaldisk ¬ FALSE;  CONTINUE}];      IF df.presentonlocaldisk THEN localDate ¬ MFile.GetCreateDate[df.fHandle]      ELSE localDate ¬ Time.Packed[0];      CWF.SWF3[fn, "[%s]<%s>%s"L, df.host, df.directory, df.shortname];      IF checkAbort[] THEN ERROR ABORTED;      found ¬ FALSE;  highestDate ¬ Time.Packed[0];  highestVersion ¬ 0;      CWF.WF1["Check %s..."L, fn];      String.AppendString[fn, "!*"L];      oneVersionFound ¬ FALSE;      Transfer.EnumerateForProperties[fileName: fn, enumProc: ConsiderOneFile];      IF ~oneVersionFound THEN {        fn.length ¬ fn.length - 2;  CWF.WF0["NOT found.\n"L];  GOTO out};      IF found THEN CWF.WF0["ok"L] ELSE CWF.WF0["NOT found"L];      IF (highestDate > df.createtime AND df.createtime # Time.Packed[0]) THEN {        CWF.WF2[          ", but the highest version (!%u) has date %lt"L,	  @highestVersion, @highestDate];        df.createtime ¬ highestDate;  df.version ¬ highestVersion;        newerVersions ¬ TRUE};      -- fill !H version and date for those files with no create time      IF found AND df.createtime = Time.Packed[0] AND df.criterion = none      AND df.version = 0 THEN {        df.createtime ¬ highestDate;  df.version ¬ highestVersion;	fillInVersionNums ¬ TRUE};      -- see if local file is newer      IF found AND localDate # Time.Packed[0] AND df.createtime # Time.Packed[0]      AND localDate > df.createtime THEN {        CWF.WF1[	  ".\n\tWarning: the local file has a newer date (%lt).\n"L, @localDate];	CWF.WF0["\tYou should run SModel to store this newer local version.\n"L]}      ELSE CWF.WF0[".\n"L];      EXITS        out => Subr.errorflg ¬ TRUE;      END;      ENDLOOP;    -- get the entry for the DF file itself in the DF file    dfInner ¬ DFSubr.LookupDF[dfseq, topDf.shortname];    IF dfInner # NIL THEN {      MFile.Release[dfInner.fHandle];  dfInner.fHandle ¬ NIL};    IF newerVersions OR fillInVersionNums THEN {      sold: STRING ¬ [MFile.maxNameLength];      sh: MStream.Handle ¬ NIL;      BEGIN ENABLE UNWIND => {IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL}};      -- save the old df file      CWF.SWF1[sold, "%s$"L, topDf.shortname];      Subr.CopyFile[from: topDf.shortname, to: sold];      -- write out a new DF File      IF topDf.fHandle # NIL THEN {        MFile.Release[topDf.fHandle];  topDf.fHandle ¬ NIL;	topDf.presentonlocaldisk ¬ FALSE};      sh ¬ MStream.WriteOnly[name: topDf.shortname, release: [], type: text	! MStream.Error => {	    CWF.WF1["\nUnable to create new file on %s.\n"L, topDf.shortname];	    GOTO leave}];      DFSubr.WriteOut[dfseq: dfseq, topLevelFile: NIL, outputStream: sh];      Stream.Delete[sh];  sh ¬ NIL;      CWF.WF1[        "New DF file (with newer version numbers or dates) written on %s.\n"L,	topDf.shortname];      CWF.WF0["You must run SModel to store this DF file remotely\n"L];      END};    EXITS leave => RETURN};  END.Change log23-Apr-85 18:19:59	DSC	Fix forceretrieval bug23-Apr-85 18:19:59	DSC	Use NSName.maxFullNameLength29-May-86 13:34:30	DSC	Added new extensions for 80186 stuff.
-- File: ProcBcdsImpl.mesa - last edit:-- kam                 18-Dec-85 12:02:12-- Copyright (C) 1982, 1983 , 1985 by Xerox Corporation. All rights reserved. -- ProcBcdsImpl.mesa - Last edited by--   Schmidt	 4-Mar-82 13:59:26--   BTL  	15-Nov-83 10:52:57--   DSC  	15-Nov-84 17:17:32--   kam  	15-Nov-84 17:17:32DIRECTORY  BcdDefs USING [    Base, CTIndex, CTNull, CTRecord, EXPIndex, EXPRecord, FTIndex, FTNull,    FTRecord, FTSelf, IMPIndex, IMPRecord, Link, MTIndex, MTRecord,    Namee, NameRecord, NullVersion, SGIndex, VersionID, VersionStamp],  CWF USING [SWF0, SWF1, WF0, WF1],  Environment USING [wordsPerPage],  LeafSubr USING [RemoteMap],  MSegment USING [Address, CopyIn, Create, Delete, Handle, Reset],  ProcBcds USING [Innards, nullSymbolSpace, ProcDep, ProcMod, SymbolSpace],  String USING [    AppendString, AppendSubString, EquivalentString, SubStringDescriptor],  Subr USING [Any, ControlChars],  TimeStamp USING [Stamp];ProcBcdsImpl: PROGRAM    IMPORTS CWF, LeafSubr, MSegment, String, Subr    EXPORTS ProcBcds =  BEGIN  InvalidBcd: PUBLIC SIGNAL = CODE;  ReadInSegmentsBcd: PUBLIC PROC [innards: ProcBcds.Innards] = {    local: BOOLEAN = (innards.rHandle = NIL);    segPages: CARDINAL ¬ 16;    npages: CARDINAL;    IF innards.fHandle = NIL AND innards.rHandle = NIL THEN RETURN;    innards.bcdHeaderSeg ¬ MSegment.Create[      file: NIL, release: [], pages: segPages];    IF local THEN      MSegment.CopyIn[        segment: innards.bcdHeaderSeg, file: innards.fHandle,	fileBase: 0, count: segPages]    ELSE      LeafSubr.RemoteMap[seg: innards.bcdHeaderSeg, fh: innards.rHandle, base: 0];    innards.bcd ¬ MSegment.Address[innards.bcdHeaderSeg];    IF innards.bcd.versionIdent # BcdDefs.VersionID THEN {      MSegment.Delete[innards.bcdHeaderSeg];  innards.bcdHeaderSeg ¬ NIL;      innards.bcd ¬ NIL;      SIGNAL InvalidBcd;  RETURN};    npages ¬ innards.bcd.nPages;    IF npages > segPages THEN {      MSegment.Reset[        segment: innards.bcdHeaderSeg, pages: npages,	swapInfo: [uniform [size: 4]]];      innards.bcd ¬ MSegment.Address[innards.bcdHeaderSeg];      IF local THEN        MSegment.CopyIn[          segment: innards.bcdHeaderSeg, file: innards.fHandle,	fileBase: 0, count: npages]      ELSE        LeafSubr.RemoteMap[          seg: innards.bcdHeaderSeg, fh: innards.rHandle, base: 0]};    innards.upperLimit ¬ (npages * Environment.wordsPerPage)};  InstallAddressesBcd: PUBLIC PROC [innards: ProcBcds.Innards] = {    innards.tb  ¬ LOOPHOLE[innards.bcd];    innards.ssb ¬ LOOPHOLE[innards.bcd + innards.bcd.ssOffset];    innards.ctb ¬ innards.tb + innards.bcd.ctOffset;    innards.mtb ¬ innards.tb + innards.bcd.mtOffset;    innards.itb ¬ innards.tb + innards.bcd.impOffset;    innards.etb ¬ innards.tb + innards.bcd.expOffset;    innards.sgb ¬ innards.tb + innards.bcd.sgOffset;    innards.ftb ¬ innards.tb + innards.bcd.ftOffset;    innards.ntb ¬ innards.tb + innards.bcd.ntOffset;    innards.spb ¬ innards.tb + innards.bcd.spOffset;    innards.fpb ¬ innards.tb + innards.bcd.fpOffset};  UnstallBcd: PUBLIC PROC [innards: ProcBcds.Innards] = {    IF innards.bcdHeaderSeg # NIL THEN MSegment.Delete[innards.bcdHeaderSeg];    innards.bcdHeaderSeg ¬ NIL};  PrintDepends: PUBLIC PROC [        innards: ProcBcds.Innards,	procMod: ProcBcds.ProcMod, procDep: ProcBcds.ProcDep,	print, calltwice, less: BOOLEAN, bcdfilename: LONG STRING]      RETURNS [        success, isconfig, isdefns: BOOLEAN, nimp, nexp, ntype: CARDINAL] = {    uns: UNSPECIFIED;    sourcefile: STRING ¬ [100];    interfacename: STRING ¬ [100];    sourceVersion: BcdDefs.VersionStamp ¬ BcdDefs.NullVersion;    cti: BcdDefs.CTIndex ¬ FIRST[BcdDefs.CTIndex];    nullstring: STRING ¬ ""L;    altoCode, boundsChecks, cedarSwitch, crossJump, linksInCode, nilChecks,      sortByUsage, madebylinker: BOOLEAN ¬ FALSE;    notcodebound, notsymbolsbound: BOOLEAN;    symbolSpace: ProcBcds.SymbolSpace ¬ ProcBcds.nullSymbolSpace;    success ¬ isconfig ¬ isdefns ¬ FALSE;    nexp ¬ nimp ¬ ntype ¬ 0;    IF nullstring.length # 0 THEN RETURN;    IF innards.bcd.versionIdent # BcdDefs.VersionID THEN {      CWF.WF0[" Error - wrong bcd version.\n"L];  RETURN};    -- if it is a defs file, we simply record the interface name    IF innards.bcd.sourceFile # BcdDefs.FTNull THEN {      PutName[innards, innards.ftb[innards.bcd.sourceFile].name, sourcefile];      sourceVersion ¬ innards.ftb[innards.bcd.sourceFile].version};    IF sourcefile.length > 0 AND sourcefile[sourcefile.length - 1] = '. THEN      sourcefile.length ¬ sourcefile.length - 1;    -- CWF.WF1["sourcefiles %s\n"L, sourcefile];    IF Subr.ControlChars[sourcefile] THEN {      CWF.WF0[" Error - bad sourcefile.\n"L];  RETURN};    success ¬ GetModuleName[innards, interfacename];    IF ~success THEN RETURN;    -- success must now always be TRUE since we call the procDep and procMod procs    isconfig ¬ (innards.bcd.nConfigs > 0);    IF ~isconfig THEN {      sSeg: BcdDefs.SGIndex ¬ innards.mtb[FIRST[BcdDefs.MTIndex]].sseg;      altoCode     ¬ FALSE;      boundsChecks ¬ innards.mtb[FIRST[BcdDefs.MTIndex]].boundsChecks;      crossJump    ¬ innards.mtb[FIRST[BcdDefs.MTIndex]].crossJumped;      cedarSwitch  ¬ FALSE;      nilChecks    ¬ innards.mtb[FIRST[BcdDefs.MTIndex]].nilChecks;      linksInCode  ¬ (innards.mtb[FIRST[BcdDefs.MTIndex]].linkLoc = code);      sortByUsage  ¬ TRUE;  -- actually, controlled by /s switch      symbolSpace  ¬ [        file: innards.fHandle,        span: [base: innards.sgb[sSeg].base, pages: innards.sgb[sSeg].pages]]};    notcodebound   ¬ (        IF isconfig THEN NotCodeBound[innards: innards, parent: BcdDefs.CTNull]       ELSE TRUE);    notsymbolsbound   ¬ (        IF isconfig THEN NotSymbolsBound[innards: innards, parent: BcdDefs.CTNull]       ELSE TRUE);    madebylinker ¬ innards.bcd.spare[0] AND innards.bcd.spare[1]      AND innards.bcd.spare[2] AND innards.bcd.spare[3];    isdefns ¬ innards.bcd.definitions;    IF isdefns THEN      uns ¬ procMod[        sourcefile: sourcefile, smodulename: interfacename,	bcdvers: innards.bcd.version,	sourcevers: sourceVersion,        creatorvers: innards.bcd.creator,	isdefns: TRUE, isconfig: FALSE, ispackaged: innards.bcd.repackaged,	iscodebound: FALSE, issymbolsbound: FALSE, istablecompiled: FALSE,	madebylinker: FALSE, altoCode: FALSE, boundsChecks: FALSE,	cedarSwitch: FALSE, crossJump: FALSE, linksInCode: FALSE,	nilChecks: FALSE, sortByUsage: FALSE, symbolSpace: symbolSpace]    ELSE      uns ¬ procMod[        sourcefile: sourcefile, smodulename: interfacename,	bcdvers: innards.bcd.version,	sourcevers: sourceVersion,        creatorvers: innards.bcd.creator,	isdefns: FALSE, isconfig: isconfig, ispackaged: innards.bcd.repackaged,	iscodebound: ~notcodebound,  issymbolsbound: ~notsymbolsbound,	istablecompiled: innards.bcd.tableCompiled, altoCode: altoCode,	madebylinker: madebylinker, boundsChecks: boundsChecks,	cedarSwitch: cedarSwitch, crossJump: crossJump, linksInCode: linksInCode,        nilChecks: nilChecks, sortByUsage: sortByUsage, symbolSpace: symbolSpace];    IF ~isconfig THEN       ntype ¬ PrintDirectory[innards, procDep, uns, print, bcdfilename];    IF ~isdefns THEN nexp ¬ PrintExports[innards, procDep, uns, print];    IF calltwice AND ~isdefns AND (ntype > 50 OR nexp > 30) THEN {      -- call again to avoid overflow in the database      uns ¬ procMod[        sourcefile, interfacename, innards.bcd.version,	innards.ftb[innards.bcd.sourceFile].version,        innards.bcd.creator, FALSE, isconfig, innards.bcd.repackaged,	~notcodebound, ~notsymbolsbound, innards.bcd.tableCompiled,	madebylinker, altoCode, boundsChecks, cedarSwitch, crossJump,        linksInCode, nilChecks, sortByUsage, symbolSpace]};    nimp ¬ PrintImports[innards, procDep, uns, print];    IF isconfig THEN {      PrintConfigDepends[        innards: innards, procDep: procDep, uns: uns,        notcodebound: notcodebound, stopnesting: FALSE];      IF ~notcodebound AND print THEN CWF.WF0["(code bound)\n"L]};    success ¬ TRUE};  PrintDirectory: PROC [        innards: ProcBcds.Innards, procDep: ProcBcds.ProcDep, uns: UNSPECIFIED,        print: BOOLEAN, bcdfilename: LONG STRING]      RETURNS [ntype: CARDINAL] = {    modulename: STRING ¬ [100];    filename: STRING ¬ [100];    fti: BcdDefs.FTIndex ¬ FIRST[BcdDefs.FTIndex];    ntype ¬ 0;    UNTIL fti = innards.bcd.ftLimit DO      PutName[innards, innards.ftb[fti].name, filename];      IF ~Subr.Any[filename, '.] THEN String.AppendString[filename, ".bcd"L];      procDep[        defstype, GuessModulename[innards, fti, modulename], filename,        innards.ftb[fti].version, uns];      ntype ¬ ntype + 1;      fti ¬ fti + SIZE[BcdDefs.FTRecord];      IF LOOPHOLE[fti, CARDINAL] > LOOPHOLE[innards.bcd.ftLimit, CARDINAL] THEN        GO TO Bogus;      REPEAT        Bogus => {	  CWF.WF1["Error - Garbage FileTable in %s.\n"L, bcdfilename]; RETURN};      ENDLOOP;    IF print THEN CWF.WF1[" %d types.\n"L, @ntype]};  GuessModulename: PROC [  -- returns NIL if can't find modulename        innards: ProcBcds.Innards, fti: BcdDefs.FTIndex, modulename: STRING]      RETURNS [STRING] = {    iti: BcdDefs.IMPIndex ¬ FIRST[BcdDefs.IMPIndex];    eti: BcdDefs.EXPIndex ¬ FIRST[BcdDefs.EXPIndex];    WHILE LOOPHOLE[iti, CARDINAL] < LOOPHOLE[innards.bcd.impLimit, CARDINAL] DO      IF innards.itb[iti].file = fti THEN {        PutName[innards, innards.itb[iti].name, modulename];        RETURN[modulename]};      iti ¬ iti + SIZE[BcdDefs.IMPRecord];      ENDLOOP;    WHILE LOOPHOLE[eti, CARDINAL] < LOOPHOLE[innards.bcd.expLimit, CARDINAL] DO      IF innards.etb[eti].file = fti THEN {        PutName[innards, innards.etb[eti].name, modulename];        RETURN[modulename]};      eti ¬ eti +        SIZE[BcdDefs.EXPRecord] + (innards.etb[eti].size * SIZE[BcdDefs.Link]);      ENDLOOP;    RETURN[NIL]};  GetModuleName: PROC [        innards: ProcBcds.Innards, interfacename: STRING]      RETURNS [success: BOOLEAN] = {    -- unofficially, a defs file or impl modules name is the first index in    -- the module table.  Not so for configs; they are in the config table    cti: BcdDefs.CTIndex ¬ FIRST[BcdDefs.CTIndex];    IF innards.bcd.nConfigs = 0 THEN      PutName[innards, innards.mtb[FIRST[BcdDefs.MTIndex]].name, interfacename]    ELSE      UNTIL cti = innards.bcd.ctLimit DO        IF innards.ctb[cti].config = BcdDefs.CTNull THEN {          PutName[innards, innards.ctb[cti].name, interfacename];          -- CWF.WF1["Name: %s\n"L, interfacename];          EXIT};        cti ¬ cti + SIZE[BcdDefs.CTRecord] +	  (innards.ctb[cti].nControls * SIZE[BcdDefs.Namee]);        IF LOOPHOLE[cti,CARDINAL] > LOOPHOLE[innards.bcd.ctLimit,CARDINAL] THEN {          CWF.WF0["Garbage: can't get module name.\n"L]; RETURN[FALSE]};        ENDLOOP;    RETURN[TRUE]};  PrintExports: PROC [        innards: ProcBcds.Innards, procDep: ProcBcds.ProcDep, uns: UNSPECIFIED,        print: BOOLEAN]      RETURNS [nexp: CARDINAL] = {    eti: BcdDefs.EXPIndex ¬ FIRST[BcdDefs.EXPIndex];    nexp ¬ 0;    UNTIL eti = innards.bcd.expLimit DO      PrintExport[innards, eti, procDep, uns];      nexp ¬ nexp + 1;      eti ¬ eti +        SIZE[BcdDefs.EXPRecord] + (innards.etb[eti].size * SIZE[BcdDefs.Link]);      IF LOOPHOLE[eti, CARDINAL] > LOOPHOLE[innards.bcd.expLimit, CARDINAL] THEN        GO TO Bogus;      REPEAT Bogus => {CWF.WF0["Garbage Garbage Garbage.\n"L]; RETURN};      ENDLOOP;    IF print THEN CWF.WF1[" %d exp, "L, @nexp]};  PrintExport: PROC [      innards: ProcBcds.Innards, eti: BcdDefs.EXPIndex, procDep: ProcBcds.ProcDep,      uns: UNSPECIFIED] = {    OPEN innards.etb[eti];    stemp: STRING ¬ [100];    stemp1: STRING ¬ [100];    vers: BcdDefs.VersionStamp;    PutName[innards, name, stemp];    PrintFileName[innards, file, stemp1];    IF stemp.length = 0 OR Subr.ControlChars[stemp] OR stemp1.length = 0    OR Subr.ControlChars[stemp1] THEN {CWF.WF0["name garbaged up\n"L]; RETURN};    vers ¬ innards.ftb[file].version;    procDep[exports, stemp, stemp1, vers, uns]};  PrintImports: PROC [        innards: ProcBcds.Innards, procDep: ProcBcds.ProcDep, uns: UNSPECIFIED,        print: BOOLEAN]      RETURNS [nimp: CARDINAL] = {    iti: BcdDefs.IMPIndex ¬ FIRST[BcdDefs.IMPIndex];    nullstring: STRING ¬ ""L;    nimp ¬ 0;    UNTIL iti = innards.bcd.impLimit DO      PrintImport[innards, iti, procDep, uns];      nimp ¬ nimp + 1;      iti ¬ iti + SIZE[BcdDefs.IMPRecord];      IF LOOPHOLE[iti, CARDINAL] > LOOPHOLE[innards.bcd.impLimit, CARDINAL] THEN        GO TO Bogus;      REPEAT Bogus => {CWF.WF0["Garbage: can't print imports.\n"L]; RETURN};      ENDLOOP;    IF print THEN CWF.WF1[" %d imp.\n"L, @nimp]};  PrintImport: PROC [      innards: ProcBcds.Innards, iti: BcdDefs.IMPIndex, procDep: ProcBcds.ProcDep,      uns: UNSPECIFIED] = {    OPEN innards.itb[iti];    stemp: STRING ¬ [100];    stemp1: STRING ¬ [100];    PutName[innards, name, stemp];    PrintFileName[innards, file, stemp1];    IF stemp.length = 0 OR Subr.ControlChars[stemp] OR stemp1.length = 0    OR Subr.ControlChars[stemp1] THEN {      CWF.WF0["import name is garbage\n"L]; RETURN};    IF ~(file = BcdDefs.FTSelf) THEN     procDep[imports, stemp, stemp1, innards.ftb[file].version, uns]    ELSE CWF.WF0["myself...skipped.\n"]};  -- if any one of the bcds ins not codebound, then the config  -- is not codebound  NotCodeBound: PROC [        innards: ProcBcds.Innards, parent: BcdDefs.CTIndex]      RETURNS [notcodebound: BOOLEAN] = {    cti: BcdDefs.CTIndex ¬ FIRST[BcdDefs.CTIndex];    notcodebound ¬ FALSE;    UNTIL cti = innards.bcd.ctLimit DO      IF innards.ctb[cti].config = parent THEN {        notcodebound ¬ (	  notcodebound OR NotCodeBound[innards: innards, parent: cti]);        notcodebound ¬ (	  notcodebound OR NotCodeBoundModules[innards, cti])};      cti ¬ cti + SIZE[BcdDefs.CTRecord] +        (innards.ctb[cti].nControls * SIZE[BcdDefs.Namee]);      IF LOOPHOLE[cti, CARDINAL] > LOOPHOLE[innards.bcd.ctLimit, CARDINAL] THEN {        CWF.WF0["Garbage Config.\n"L];  RETURN};      ENDLOOP};  NotCodeBoundModules: PROC [        innards: ProcBcds.Innards, cti: BcdDefs.CTIndex]      RETURNS [notcodebound: BOOLEAN] = {    codeseg: BcdDefs.SGIndex;    mti: BcdDefs.MTIndex ¬ FIRST[BcdDefs.MTIndex];    notcodebound ¬ FALSE;    UNTIL mti = innards.bcd.mtLimit DO      IF innards.mtb[mti].config = cti THEN {        IF innards.mtb[mti].file # BcdDefs.FTSelf THEN {          codeseg ¬ innards.mtb[mti].code.sgi;          IF innards.sgb[codeseg].class # code THEN {            CWF.WF0["Error - not code seg\n"L]; RETURN};          notcodebound ¬ notcodebound            OR innards.sgb[codeseg].file # BcdDefs.FTSelf}};      mti ¬ mti + SIZE[BcdDefs.MTRecord];      IF LOOPHOLE[mti, CARDINAL] > LOOPHOLE[innards.bcd.mtLimit, CARDINAL] THEN {        CWF.WF0["Garbage Module.\n"L];  RETURN};      ENDLOOP};  -- if one of the bcds is not symbolsbound, then the config is not symbolsbound  NotSymbolsBound: PROC [        innards: ProcBcds.Innards, parent: BcdDefs.CTIndex]      RETURNS [notsymbolsbound: BOOLEAN] = {    cti: BcdDefs.CTIndex ¬ FIRST[BcdDefs.CTIndex];    notsymbolsbound ¬ FALSE;    UNTIL cti = innards.bcd.ctLimit DO      IF innards.ctb[cti].config = parent THEN {        notsymbolsbound ¬ notsymbolsbound	  OR NotSymbolsBound[innards: innards, parent: cti];        notsymbolsbound ¬ notsymbolsbound	  OR NotSymbolsBoundModules[innards, cti]};      cti ¬ cti + SIZE[BcdDefs.CTRecord] +        (innards.ctb[cti].nControls * SIZE[BcdDefs.Namee]);      IF LOOPHOLE[cti, CARDINAL] > LOOPHOLE[innards.bcd.ctLimit, CARDINAL] THEN {        CWF.WF0["Garbage Config.\n"L];  RETURN};      ENDLOOP};	  NotSymbolsBoundModules: PROC [        innards: ProcBcds.Innards, cti: BcdDefs.CTIndex]      RETURNS [notsymbolsbound: BOOLEAN] = {    symseg: BcdDefs.SGIndex;    mti: BcdDefs.MTIndex ¬ FIRST[BcdDefs.MTIndex];    notsymbolsbound ¬ FALSE;    UNTIL mti = innards.bcd.mtLimit DO      IF innards.mtb[mti].config = cti THEN {        IF innards.mtb[mti].file # BcdDefs.FTSelf THEN {          symseg ¬ innards.mtb[mti].sseg;          IF innards.sgb[symseg].class # symbols THEN {            CWF.WF0["Error - not symbol seg\n"L]; RETURN};          notsymbolsbound ¬ notsymbolsbound            OR innards.sgb[symseg].file # BcdDefs.FTSelf}};      mti ¬ mti + SIZE[BcdDefs.MTRecord];      IF LOOPHOLE[mti, CARDINAL] > LOOPHOLE[innards.bcd.mtLimit, CARDINAL] THEN {        CWF.WF0["Garbage Module.\n"L];  RETURN};      ENDLOOP};        -- a config .bcd depends on  -- 	itself  --	all module entries for itself  -- 	all config entries (not FTSelf) one level away  -- 	module entries for config's that are FTSelf's away from the top  -- for each config entry:  --	if parent = CTNull, print config and modules  -- 	if parent[parent] = CTNull print config  --	if (file = FTSelf)* and parent = CTNull, print modules  PrintConfigDepends: PROC [      innards: ProcBcds.Innards, procDep: ProcBcds.ProcDep, uns: UNSPECIFIED,      notcodebound, stopnesting: BOOLEAN] = {    cti: BcdDefs.CTIndex ¬ FIRST[BcdDefs.CTIndex];    modname: STRING ¬ [100];    filename: STRING ¬ [100];    topcti: BcdDefs.CTIndex;    ok: BOOLEAN;    UNTIL cti = innards.bcd.ctLimit DO      ok ¬ FALSE;      topcti ¬ innards.ctb[cti].config;  -- first level parent      WHILE topcti # BcdDefs.CTNull AND innards.ctb[topcti].file = BcdDefs.FTSelf        DO topcti ¬ innards.ctb[topcti].config ENDLOOP;      IF topcti = BcdDefs.CTNull OR innards.ctb[topcti].config = BcdDefs.CTNull        THEN ok ¬ TRUE;      IF ok AND innards.ctb[cti].file # BcdDefs.FTSelf THEN {        PutName[innards, innards.ctb[cti].name, modname];        PrintFileName[innards, innards.ctb[cti].file, filename];        procDep[          relcode: (IF notcodebound THEN otherdepends ELSE canignore),	  smodulename: modname, filename: filename,          bcdvers: innards.ftb[innards.ctb[cti].file].version, uns: uns]};      cti ¬ cti + SIZE[BcdDefs.CTRecord] +        (innards.ctb[cti].nControls * SIZE[BcdDefs.Namee]);      IF LOOPHOLE[cti, CARDINAL] > LOOPHOLE[innards.bcd.ctLimit, CARDINAL] THEN {        CWF.WF0["Garbage Config: can't print config depends.\n"L]; RETURN};      ENDLOOP;    ProcessModuleTable[innards, procDep, uns, notcodebound]};  ProcessModuleTable: PROC [      innards: ProcBcds.Innards, procDep: ProcBcds.ProcDep, uns: UNSPECIFIED,      notcodebound: BOOLEAN] = {    symseg, codeseg: BcdDefs.SGIndex;    mti: BcdDefs.MTIndex ¬ FIRST[BcdDefs.MTIndex];    modname: STRING ¬ [100];    filename: STRING ¬ [100];    cti: BcdDefs.CTIndex;    UNTIL mti = innards.bcd.mtLimit DO      cti ¬ innards.mtb[mti].config;      WHILE innards.ctb[cti].file = BcdDefs.FTSelf DO        IF innards.ctb[cti].config = BcdDefs.CTNull THEN EXIT;        cti ¬ innards.ctb[cti].config;        ENDLOOP;      IF innards.ctb[cti].config = BcdDefs.CTNull THEN {        symseg ¬ innards.mtb[mti].sseg;        IF innards.sgb[symseg].class # symbols THEN {          CWF.WF0["Error - not symseg\n"L]; RETURN};        IF innards.sgb[symseg].file # BcdDefs.FTSelf        AND innards.sgb[symseg].file # BcdDefs.FTNull THEN {          PrintFileName[innards, innards.sgb[symseg].file, filename];          PutName[innards, innards.mtb[mti].name, modname];          IF ~String.EquivalentString[filename, modname] THEN {            symfilevers: TimeStamp.Stamp;            symfilevers ¬ innards.ftb[innards.sgb[symseg].file].version;            procDep[symbolsfile, modname, filename, symfilevers, uns]}};        IF innards.mtb[mti].file # BcdDefs.FTSelf          AND innards.mtb[mti].file # BcdDefs.FTNull THEN {          codeseg ¬ innards.mtb[mti].code.sgi;          IF innards.sgb[codeseg].class # code THEN {            CWF.WF0["Error - not code seg\n"L]; RETURN};          PutName[innards, innards.mtb[mti].name, modname];          PrintFileName[innards, innards.mtb[mti].file, filename];          procDep[            IF notcodebound THEN otherdepends ELSE canignore, modname, filename,            innards.ftb[innards.mtb[mti].file].version, uns]}};      mti ¬ mti + SIZE[BcdDefs.MTRecord];      IF LOOPHOLE[mti, CARDINAL] > LOOPHOLE[innards.bcd.mtLimit, CARDINAL] THEN {        CWF.WF0["Garbage Module.\n"L]; RETURN};      ENDLOOP};  PutName: PROC [      innards: ProcBcds.Innards, n: BcdDefs.NameRecord, stemp: STRING] = {    str: STRING ¬ [100];    ssd: String.SubStringDescriptor ¬ [      base: @innards.ssb.string,      offset: n, length: MIN[innards.ssb.size[n], 100]];    String.AppendSubString[str, @ssd];    CWF.SWF1[stemp, "%s"L, str]};  -- if no '.' is present, explicitely append ".bcd" at the end of stemp  PrintFileName: PROC [      innards: ProcBcds.Innards, fti: BcdDefs.FTIndex, stemp: STRING] = {    SELECT fti FROM      BcdDefs.FTNull => {CWF.SWF0[stemp, "(null)"L];  RETURN};      BcdDefs.FTSelf => {CWF.SWF0[stemp, "(self)"L];  RETURN};      ENDCASE => {        PutName[innards, innards.ftb[fti].name, stemp];        IF ~Subr.Any[stemp, '.] THEN String.AppendString[stemp, ".bcd"L]}};  END.15-Nov-84 17:17:47	DSC  	Changed PrintImport to avoid self.18-Dec-85 12:01:48	kam  	Added ProcMod parameter "madebylinker".
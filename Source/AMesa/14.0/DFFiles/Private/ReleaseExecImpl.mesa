-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- ReleaseExecImpl.mesa - Last edited by--   BTL  	18-Nov-83 13:37:35--   DSC  	29-Mar-84 18:11:29 increased td.maxAllFiles to 10,000DIRECTORY  CWF USING [SetWriteProcedure, WF0, WF1],  Exec USING [    AddCommand, ExecProc, FreeTokenString, GetToken, Handle, OutputProc, PutChar],  Heap USING [systemZone],  MFile USING [Error],  MStream USING [Error, Handle, WriteOnly],  ReleaseInterface USING [    AlreadyRunning, Data, DataObject, DoneRunning, EPhase, exec,    ProcessOnePhase, toolData, wh],  Runtime USING [CallDebugger],  Stream USING [Delete, Handle, PutChar],  String USING [Empty, Equivalent, InvalidNumber, StringToDecimal],  Subr USING [debugflg, errorflg, PrintGreeting, SubrInit],  Transfer USING [RegisterConnCredentials];ReleaseExecImpl: MONITOR    IMPORTS      CWF, Exec, Heap, MFile, MStream, ReleaseInterface, Runtime, Stream,      String, Subr, Transfer =  BEGIN OPEN ReleaseInterface; -- ReleaseTool executive command line related code   Phase1Release: Exec.ExecProc = {    IF ReleaseInterface.AlreadyRunning[] THEN {       Exec.OutputProc[h]["ReleaseTool still busy."L];      RETURN[abort]};    CmdLineCall[phase: One, exec: h];    ReleaseInterface.DoneRunning[];    RETURN[IF Subr.errorflg THEN error ELSE normal]};   Phase2Release: Exec.ExecProc = {    IF ReleaseInterface.AlreadyRunning[] THEN {       Exec.OutputProc[h]["ReleaseTool still busy."L];      RETURN[abort]};    CmdLineCall[phase: Two, exec: h];    ReleaseInterface.DoneRunning[];    RETURN[IF Subr.errorflg THEN error ELSE normal]};   Phase3Release: Exec.ExecProc = {    IF ReleaseInterface.AlreadyRunning[] THEN {       Exec.OutputProc[h]["ReleaseTool still busy."L];      RETURN[abort]};    CmdLineCall[phase: Three, exec: h];    ReleaseInterface.DoneRunning[];    RETURN[IF Subr.errorflg THEN error ELSE normal]};   Phase13Release: Exec.ExecProc = {    IF ReleaseInterface.AlreadyRunning[] THEN {       Exec.OutputProc[h]["ReleaseTool still busy."L];      RETURN[abort]};    CmdLineCall[phase: OneThree, exec: h];    ReleaseInterface.DoneRunning[];    RETURN[IF Subr.errorflg THEN error ELSE normal]};   ResetData: Exec.ExecProc = {    IF ReleaseInterface.AlreadyRunning[] THEN {       Exec.OutputProc[h]["ReleaseTool still busy."L];      RETURN[abort]};    CmdLineCall[phase: Reset, exec: h];    ReleaseInterface.DoneRunning[];    RETURN[IF Subr.errorflg THEN error ELSE normal]};   UseOldPhase1Data: Exec.ExecProc = {    IF ReleaseInterface.AlreadyRunning[] THEN {       Exec.OutputProc[h]["ReleaseTool still busy."L];      RETURN[abort]};    CmdLineCall[phase: UseOldPhase1Data, exec: h];    ReleaseInterface.DoneRunning[];    RETURN[IF Subr.errorflg THEN error ELSE normal]};      CmdLineCall: PROC [phase: ReleaseInterface.EPhase, exec: Exec.Handle] = {    name, sw: LONG STRING ¬ NIL;    td: ReleaseInterface.Data ¬ ReleaseInterface.toolData;        CleanUp: PROC = {      sw ¬ Exec.FreeTokenString[sw];      name ¬ Exec.FreeTokenString[name];      IF td # NIL THEN {        IF td.logStream # NIL THEN {	  Stream.Delete[td.logStream];  td.logStream ¬ NIL};        td.dffilename ¬ NIL};      ReleaseInterface.DoneRunning[]};	    BEGIN ENABLE UNWIND => CleanUp[];     BEGIN    IF td = NIL THEN {      ReleaseInterface.toolData ¬ td ¬ Heap.systemZone.NEW[        ReleaseInterface.DataObject ¬ []]};    IF td.formsw # NIL THEN {  -- user must deactivate tool window      Exec.OutputProc[exec][        "Error - you must first deactivate the ReleaseTool window."L];      CleanUp[];      RETURN};    ReleaseInterface.wh ¬ NIL;  ReleaseInterface.exec ¬ exec;    SetDefaultOptions[];    td.phase ¬ phase;    Subr.SubrInit[exec: exec];    [] ¬ CWF.SetWriteProcedure[ExecLogProc];    Subr.errorflg ¬ Subr.debugflg ¬ FALSE;    td.logStream ¬ MStream.WriteOnly[      name: "ReleaseTool.log"L, release: [], type: text      ! MStream.Error, MFile.Error => GOTO noLog];    Subr.PrintGreeting["ReleaseTool"L];    IF phase = Reset OR phase = UseOldPhase1Data THEN       ReleaseInterface.ProcessOnePhase[phase: phase]    ELSE {       [name, sw] ¬ Exec.GetToken[exec];      WHILE ~String.Empty[name] OR ~String.Empty[sw] DO	IF String.Empty[name] THEN GOTO noDFFile;	td.command ¬ FALSE;	IF ~String.Empty[sw] THEN ProcessSwitches[sw];	IF td.command THEN {	  which: {connect, maxFiles, hugeZonePages, initBTreePages};	  SELECT TRUE FROM	    String.Equivalent[name, "Connect"L],	    String.Equivalent[name, "Conn"L] =>	      which ¬ connect; 	    String.Equivalent[name, "MaxAllFiles"L] =>	      which ¬ maxFiles; 	    String.Equivalent[name, "PagesInHugeZone"L] =>	      which ¬ hugeZonePages; 	    String.Equivalent[name, "InitialBTreePages"L] =>	      which ¬ initBTreePages;	    ENDCASE => GOTO badCmd;	  sw ¬ Exec.FreeTokenString[sw];  name ¬ Exec.FreeTokenString[name];	  [name, sw] ¬ Exec.GetToken[exec];	  IF String.Empty[name] THEN GOTO badParameter;	  sw ¬ Exec.FreeTokenString[sw];	  IF which = connect THEN {	    dir: LONG STRING ¬ name;	    [name, sw] ¬ Exec.GetToken[exec];  -- name is connect password	    IF ~String.Empty[sw] THEN {  -- assume empty connect password	      Transfer.RegisterConnCredentials[dir: dir, password: ""L];	      dir ¬ Exec.FreeTokenString[dir];	      LOOP};	    IF String.Empty[name] THEN GOTO noPassword;	    Transfer.RegisterConnCredentials[dir: dir, password: name];	    dir ¬ Exec.FreeTokenString[dir]}	  ELSE {  -- name is number (parameter) 	    n: CARDINAL;	    n ¬ String.StringToDecimal[name	      ! String.InvalidNumber => GOTO badNumber];	    SELECT which FROM	      maxFiles	     => td.maxAllFiles ¬ n;	      hugeZonePages  => td.pagesInHugeZone ¬ n;	      initBTreePages => td.initialBTreePages ¬ n;	      ENDCASE};	  sw ¬ Exec.FreeTokenString[sw];  name ¬ Exec.FreeTokenString[name];	  [name, sw] ¬ Exec.GetToken[exec];	  LOOP};   	td.dffilename ¬ name;	ReleaseInterface.ProcessOnePhase[phase: phase];	sw ¬ Exec.FreeTokenString[sw];  name ¬ Exec.FreeTokenString[name];	[name, sw] ¬ Exec.GetToken[exec];	ENDLOOP};    EXITS      noDFFile =>        CWF.WF0["Bad ReleaseTool command line: no DF file given\n"L];      badCmd =>        CWF.WF1["Bad ReleaseTool command line: unknown command %s\n"L, name];      badParameter =>        CWF.WF0["Bad ReleaseTool command line: missing subcommand parameter\n"L];      noPassword =>        CWF.WF0["Bad ReleaseTool command line: missing connect password\n"L];      badNumber =>        CWF.WF1["Bad ReleaseTool command line: bad parameter number %s\n"L, name];      noLog => CWF.WF0["Can't open log file\n"L];    END;    END;  -- ENABLE UNWIND => CleanUp[];    CleanUp[]};      SetDefaultOptions: PROC = {    td: ReleaseInterface.Data ¬ ReleaseInterface.toolData;    td.formsw		 ¬ NIL;    td.ttysw		 ¬ NIL;    td.dffilename	 ¬ NIL;    td.checkOverwrite	 ¬ FALSE;    td.checkSpanTree	 ¬ TRUE;    td.checkFilesExist	 ¬ TRUE;    td.debugging	 ¬ FALSE;    td.verbose		 ¬ TRUE;    td.skipCameFrom	 ¬ TRUE;    td.useOldPhase1Cache ¬ TRUE;    td.useOldPhase3Cache ¬ TRUE;    td.maxAllFiles	 ¬ 10000;      td.pagesInHugeZone	 ¬ 3500;    td.initialBTreePages ¬ 1000;    td.command	 	 ¬ FALSE};      ProcessSwitches: PROC [sw: LONG STRING] = {    td: ReleaseInterface.Data ¬ ReleaseInterface.toolData;    sense: BOOLEAN ¬ TRUE;    FOR i: CARDINAL IN [0..sw.length) DO      SELECT sw[i] FROM	'-, '~ => sense ¬ ~sense;	'o, 'O => {td.checkOverwrite ¬ sense;	 sense ¬ TRUE};	't, 'T => {td.checkSpanTree ¬ sense;	 sense ¬ TRUE};	'e, 'E => {td.checkFilesExist ¬ sense;	 sense ¬ TRUE};	's, 'S => {td.skipCameFrom ¬ sense;	 sense ¬ TRUE};	'1     => {td.useOldPhase1Cache ¬ sense; sense ¬ TRUE};	'3     => {td.useOldPhase1Cache ¬ sense; sense ¬ TRUE};	'd, 'D => {td.debugging ¬ sense;	 sense ¬ TRUE};	'v, 'V => {td.verbose ¬ sense;		 sense ¬ TRUE};	'c, 'C => {td.command ¬ sense;		 sense ¬ TRUE};   	'!     => Runtime.CallDebugger["Called from ReleaseTool"L];	ENDCASE;      ENDLOOP};      ExecLogProc: PROC [ch: CHARACTER] = {    IF ReleaseInterface.exec # NIL THEN      Exec.PutChar[ReleaseInterface.exec, ch];    IF ReleaseInterface.toolData # NIL     AND ReleaseInterface.toolData.logStream # NIL THEN      Stream.PutChar[ReleaseInterface.toolData.logStream, ch]};    	    -- Initialization   Init: PROC = {    Exec.AddCommand["Phase1Release.~"L, Phase1Release];    Exec.AddCommand["Phase2Release.~"L, Phase2Release];    Exec.AddCommand["Phase3Release.~"L, Phase3Release];    Exec.AddCommand["Phase13Release.~"L, Phase13Release];    Exec.AddCommand["ResetData.~"L, ResetData];    Exec.AddCommand["UseOldPhase1Data.~"L, UseOldPhase1Data]};    Init[];    END.
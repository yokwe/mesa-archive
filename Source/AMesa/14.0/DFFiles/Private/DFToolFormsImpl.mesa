-- DFToolFormsImpl.mesa - last edited by-- DSC	 April 16, 1985  2:05 pm-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. DIRECTORYDFToolForms,DFToolOps,FormSW,WindowFont;DFToolFormsImpl: PROGRAMIMPORTS FormSW, DFToolOps, WindowFontEXPORTS DFToolForms = { OPEN DFToolOps; -- To make toolData references cleaner. Sorry..    -- All the fields in the main form.  CmdFormItems: TYPE = DFToolForms.CmdFormItems;    charWidth: CARDINAL ¬ WindowFont.CharWidth['M];    CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};      ChW: PROCEDURE [s: LONG STRING] RETURNS [tot: NATURAL ¬ 0] = {    FOR i: CARDINAL IN [0..s.length) DO      tot ¬ tot + WindowFont.CharWidth[s[i]];    ENDLOOP;  };  ISp: NATURAL = 2;    BringOverOptionsFormItems: TYPE = {  confirm, 		getOnlyExports, 	justReadOnlys, 	justNonReadOnlys,  justObjects, 		justSources,		updateExisting,	getOlderOK,  verifyFilesExist, 	preRelease,  		archiveBcdRename};    DFDeleteOptionsFormItems: TYPE = {deleteImports};    NoOptionsFormItems: TYPE = {nooptions};    SmodelOptionsFormItems: TYPE = {confirm, 	flipCameFrom, 		checkLibrarian, dontStoreRemotely, topLevelOnly,	verifyRemoteOnStore, 	preRelease, 	dFLibjectsOnly};    VerifyDFOptionsFormItems: TYPE = {retrieveDFToTemp};  -- Kludges.  Doit:  FormSW.ProcType = {   DFToolOps.Doit[sw, item, index];  };    BringUpOptionSheet:  FormSW.ProcType = {   DFToolOps.BringUpOptionSheet[sw, item, index];  };    Stop:  FormSW.ProcType = {   DFToolOps.Stop[sw, item, index];  };     Help:  FormSW.ProcType = {   DFToolOps.Help[sw, item, index];  };    NewOperation:  FormSW.EnumeratedNotifyProcType = {   DFToolOps.NewOperation[sw, item, index];  };  -- when you change this by copying a routine from the FormSWlayoutTool,  -- change all @toolData.switchLBRACKETtopLevelOnlyRBRACKET  -- to @toolData.switch[topLevelOnly] with the editor. This is due to  -- the formswlayouttool bug that does not allow brackets in the switch: field.  -- Also, to make the anyfont option work better, calculate the item tag length  -- and add that to each successive item. See example below for what's happening.      -- The current versions are hand crafted to allow variable fonts the "right" way.      MakeCmdForm: PUBLIC FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = CmdFormItems.LAST.ORD + 1;    operation: ARRAY[0..6) OF Enumerated ¬ [      ["BringOver"L, 0], ["SModel"L, 1],      ["VerifyDF"L, 2], ["CheckOut"L, 3],      ["Query"L, 4], ["DFDelete"L, 5]];    items ¬ AllocateItemDescriptor[nItems];    items[CmdFormItems.dFFiles.ORD] ¬ StringItem[      tag: "DFFiles"L, place: newLine, inHeap: TRUE, string: @toolData.inputDfFiles];    items[CmdFormItems.files.ORD] ¬ StringItem[      tag: "Files"L, place: newLine, inHeap: TRUE, string: @toolData.inputFiles];    items[CmdFormItems.localDir.ORD] ¬ StringItem[      tag: "LocalDir"L, place: [CharPos[36], sameLine], inHeap: TRUE, string: @toolData.localDir];    items[CmdFormItems.checkoutReason.ORD] ¬ StringItem[      tag: "Check Out Reason"L, place: newLine, inHeap: TRUE, string: @toolData.reason];    items[CmdFormItems.doit.ORD] ¬ CommandItem[      tag: "Doit"L, place: newLine, proc: Doit];    items[CmdFormItems.options.ORD] ¬ CommandItem[      tag: "Options"L, place: nextPlace, proc: BringUpOptionSheet];    items[CmdFormItems.stop.ORD] ¬ CommandItem[      tag: "Stop"L, place: nextPlace, proc: Stop];    items[CmdFormItems.help.ORD] ¬ CommandItem[      tag: "Help"L, place: nextPlace, proc: Help];    items[CmdFormItems.operation.ORD] ¬ EnumeratedItem[      tag: "Operation"L, place: newLine, feedback: all, proc: NewOperation, choices: DESCRIPTOR[operation], value: @toolData.operation];    RETURN[items: items, freeDesc: TRUE];    };  MakeBringOverOptionsFormSW: PUBLIC FormSW.ClientItemsProcType = {    OPEN FormSW;    tabs: ARRAY [0..5] OF CARDINAL ¬ [0,12,24,36,48,60];    nItems: CARDINAL = BringOverOptionsFormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems];    items[BringOverOptionsFormItems.confirm.ORD] ¬ BooleanItem[      tag: "Confirm"L, place: newLine, switch: @toolData.switch[confirm]];    items[BringOverOptionsFormItems.getOnlyExports.ORD] ¬ BooleanItem[      tag: "Exports"L, place: nextPlace, switch: @toolData.switch[getOnlyExports]];    items[BringOverOptionsFormItems.justReadOnlys.ORD] ¬ BooleanItem[      tag: "Imports"L, place: nextPlace, switch: @toolData.switch[justReadOnlys]];    items[BringOverOptionsFormItems.justNonReadOnlys.ORD] ¬ BooleanItem[      tag: "Writable"L, place: nextPlace, switch: @toolData.switch[justNonReadOnlys]];          items[BringOverOptionsFormItems.justObjects.ORD] ¬ BooleanItem[      tag: "Objects"L, place: newLine, switch: @toolData.switch[justObjects]];    items[BringOverOptionsFormItems.justSources.ORD] ¬ BooleanItem[      tag: "Sources"L, place: nextPlace, switch: @toolData.switch[justSources]];    items[BringOverOptionsFormItems.updateExisting.ORD] ¬ BooleanItem[      tag: "Update"L, place: nextPlace, switch: @toolData.switch[updateExisting]];    items[BringOverOptionsFormItems.getOlderOK.ORD] ¬ BooleanItem[      tag: "GetOlderOK"L, place: nextPlace, switch: @toolData.switch[getOlderOK]];    items[BringOverOptionsFormItems.verifyFilesExist.ORD] ¬ BooleanItem[      tag: "Verify"L, place: newLine, switch: @toolData.switch[verifyFilesExist]];    items[BringOverOptionsFormItems.preRelease.ORD] ¬ BooleanItem[      tag: "PreRelease"L, place: nextPlace, switch: @toolData.switch[bringOverPreRelease]];    items[BringOverOptionsFormItems.archiveBcdRename.ORD] ¬ BooleanItem[      tag: "ArchiveBcd"L, place: nextPlace, switch: @toolData.switch[archiveBcdRename]];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];    RETURN[items: items, freeDesc: TRUE];    };  MakeSmodelOptionsFormSW: PUBLIC FormSW.ClientItemsProcType = {    OPEN FormSW;    tabs: ARRAY [0..5] OF CARDINAL ¬ [0,10,24,36,48,60];        nItems: CARDINAL = SmodelOptionsFormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems];    items[SmodelOptionsFormItems.confirm.ORD] ¬ BooleanItem[      tag: "Confirm"L, place: newLine, switch: @toolData.switch[confirm]];     items[SmodelOptionsFormItems.flipCameFrom.ORD] ¬ BooleanItem[      tag: "FlipCameFrom"L, place: nextPlace, switch: @toolData.switch[flipCameFrom]];     items[SmodelOptionsFormItems.checkLibrarian.ORD] ¬ BooleanItem[      tag: "Librarian"L, place: nextPlace, switch: @toolData.switch[checkLibrarian]];     items[SmodelOptionsFormItems.dontStoreRemotely.ORD] ¬ BooleanItem[      tag: "DontStore"L, place: nextPlace, switch: @toolData.switch[dontStoreRemotely]];           items[SmodelOptionsFormItems.topLevelOnly.ORD] ¬ BooleanItem[      tag: "TopLevel"L, place: newLine, switch: @toolData.switch[topLevelOnly]];     items[SmodelOptionsFormItems.verifyRemoteOnStore.ORD] ¬ BooleanItem[      tag: "VerifyRemote"L, place: nextPlace, switch: @toolData.switch[verifyRemoteOnStore]];     items[SmodelOptionsFormItems.preRelease.ORD] ¬ BooleanItem[      tag: "PreRelease"L, place: nextPlace, switch: @toolData.switch[smodelPreRelease]];     items[SmodelOptionsFormItems.dFLibjectsOnly.ORD] ¬ BooleanItem[      tag: "DFLibjects"L, place: nextPlace, switch: @toolData.switch[dfLibjectsOnly]];          SetTagPlaces[items, DESCRIPTOR[tabs], FALSE];    RETURN[items: items, freeDesc: TRUE];    };  MakeVerifyDFOptionsFormSW: PUBLIC FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = VerifyDFOptionsFormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems];    items[VerifyDFOptionsFormItems.retrieveDFToTemp.ORD] ¬ BooleanItem[      tag: "RetrieveDFToTemp"L, place: newLine, switch: @toolData.switch[retrieveDFsToTemp]];    RETURN[items: items, freeDesc: TRUE];    };  MakeDFDeleteOptionsFormSW: PUBLIC FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = DFDeleteOptionsFormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems];    items[DFDeleteOptionsFormItems.deleteImports.ORD] ¬ BooleanItem[      tag: "DeleteImports"L, place: newLine, switch: @toolData.switch[alsoDeleteReadOnly]];    RETURN[items: items, freeDesc: TRUE];    };  -- Catch call for all those with no options.  MakeNoOptionsFormSW: PUBLIC FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = NoOptionsFormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems];    items[NoOptionsFormItems.nooptions.ORD] ¬ TagOnlyItem[      tag: "No options"L, place: newLine];    RETURN[items: items, freeDesc: TRUE];    };}...20-Nov-84 17:43:34	DSC  	Create27-Nov-84 14:14:46	DSC  	Split smodel and bringover pre release flags21-Jan-85  9:55:44	DSC  	Removed Pup librarian protocol choice. 7-Feb-85 12:47:07	DSC  	Added justReadOnlys.14-Feb-85 18:17:24	DSC  	Renamed Storeback to Smodel.11-Apr-85 13:07:26	DSC  	Any font.11-Apr-85 13:16:39	DSC  	Any font charwidth = 'M11-Apr-85 14:39:09	DSC  	Relative anyfont calcs.15-Apr-85 15:55:45	DSC  	Use newLine and nextPlace. New Opt tags16-Apr-85 13:55:52	DSC  	ExportsOnly -> Exports.16-Apr-85 14:08:19	DSC  	Don't use FormSWLayout anymore.16-Apr-85 14:27:48	DSC  	MakeNoOptionsFormSW => NewLine.
-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- DFDiskImpl.mesa - Last edited by--   Schmidt	 9-Mar-82 16:58:08--   BTL  	11-Jan-83 11:23:25--   DSC  	 7-Feb-85 15:28:28DIRECTORY  CWF USING [FWF1, SWF1, WF0, WF1, WFCR],  DFSubr USING [    AllocateDFSeq, DF, DFSeq, FreeDFSeq, InsertCRs, NextDF, SortByFileName, WriteOut],  Exec USING [AddCommand, CheckForAbort, ExecProc, Handle, OutputProc, PutChar, RemoveCommand],  FileName,  FileTransfer USING [CodeToString, Error],  Format USING [StringProc],  MFile USING [    AppendErrorMessage, EnumerateDirectory, EnumerateProc, Error,    GetCreateDate, GetProperties, Handle, maxNameLength],  MSegment USING [Error, GetFile],  MStream USING [Error, GetFile, Handle, WriteOnly],  Stream USING [Delete, Handle, PutChar],  String USING [AppendChar, Copy, Empty, EquivalentString],  Subr USING [    CopyString, debugflg, EndsIn, errorflg, FreeString, PrintGreeting,    SetUpCWFWriteProcedure, SubrInit, SubrStop],  Time USING [Current, Packed],  Volume USING [InsufficientSpace];DFDiskImpl: MONITOR    IMPORTS      CWF, DFSubr, Exec, FileName, FileTransfer, MFile, MSegment, MStream,      Stream, String, Subr, Time, Volume =  BEGIN  MaxFiles: CARDINAL = 1000;  Main: Exec.ExecProc = {    startTime, elapsedTime: Time.Packed;    exec: Exec.Handle ¬ NIL;    dfseq: DFSubr.DFSeq ¬ NIL;    sh: Stream.Handle ¬ NIL;    Cleanup: PROC = {      IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL};      DFSubr.FreeDFSeq[@dfseq]; Subr.SubrStop[]};    WFSH: PROC [ch: CHARACTER] = {      Stream.PutChar[sh, ch];  Exec.PutChar[exec, ch]};    BEGIN      ENABLE {        UNWIND => {Cleanup[];  DoneRunning[]};        ABORTED => {	  IF sh # NIL THEN 	  CWF.WF0["\n...DFDisk aborted.\n"L];  GOTO abort};        FileTransfer.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: LONG STRING ¬ [100];	    FileTransfer.CodeToString[code, msg];	    CWF.WF1["FileTransfer error: %s\n"L, msg];	    Subr.errorflg ¬ TRUE;	    GOTO error};        Volume.InsufficientSpace => {          CWF.WF0["Volume full\n"L];	  Subr.errorflg ¬ TRUE;  GOTO error};	MFile.Error => 	  IF Subr.debugflg THEN REJECT	  ELSE {	    msg: LONG STRING ¬ [100];	    MFile.AppendErrorMessage[msg, code, file];	    CWF.WF1["MFile error: %s\n"L, msg];   	    GOTO error};        MStream.Error =>  	  IF Subr.debugflg THEN REJECT	  ELSE {	    name: LONG STRING ¬ [MFile.maxNameLength];            SELECT TRUE FROM	      (stream = NIL) => name ¬ "unknown"L;	      (code = invalidHandle) => name ¬ "unknown"L;	      ENDCASE => [] ¬ MFile.GetProperties[MStream.GetFile[stream], name];            CWF.WF1[	      "\n...Error accessing stream on file %s"L, 	      (IF name.length > 0 THEN name ELSE "unknown"L)];	    SELECT code FROM	      invalidHandle    => CWF.WF0[": invalidHandle\n"L];	      indexOutOfRange  => CWF.WF0[": indexOutOfRange\n"L];	      invalidOperation => CWF.WF0[": invalidOperation\n"L];	      fileTooLong      => CWF.WF0[": fileTooLong\n"L];	      fileNotAvailable => CWF.WF0[": fileNotAvailable\n"L];	      other            => CWF.WF0[": other\n"L];	      ENDCASE          => CWF.WF0[": (unknown MStream.Error)\n"L];	    GOTO error};	MSegment.Error =>   	  IF Subr.debugflg THEN REJECT	  ELSE {	    name: LONG STRING ¬ [MFile.maxNameLength];            SELECT TRUE FROM	      (segment = NIL) => name ¬ "unknown"L;	      (code = noSuchSegment) => name ¬ "unknown"L;	      ENDCASE => {	        file: MFile.Handle ¬ MSegment.GetFile[segment];		IF file = NIL THEN name ¬ "unknown"L		ELSE [] ¬ MFile.GetProperties[file, name]};	    CWF.WF1[	      "\n...Error accessing segment on file %s"L,	      (IF name.length > 0 THEN name ELSE "unknown"L)];	    SELECT code FROM	      zeroLength         => CWF.WF0[": zeroLength\n"L];	      insufficientVM     => CWF.WF0[": insufficientVM\n"L];	      noSuchSegment      => CWF.WF0[": noSuchSegment\n"L];	      sharedSegment      => CWF.WF0[": sharedSegment\n"L];	      baseOutOfRange     => CWF.WF0[": baseOutOfRange\n"L];	      conflictingAccess  => CWF.WF0[": conflictingAccess\n"L];	      illegalAccess      => CWF.WF0[": illegalAccess\n"L];	      other              => CWF.WF0[": other\n"L];              ENDCASE            => CWF.WF0[": (unknown MSegment.Error)\n"L];	   GOTO error}};    IF AlreadyRunning[] THEN {       Exec.OutputProc[h][" DFDisk already running!"L];      RETURN[abort]};          startTime ¬ Time.Current[];    outcome ¬ normal;    exec ¬ h;    Subr.SetUpCWFWriteProcedure[];  Subr.SubrInit[exec: exec];    Subr.PrintGreeting["DFDisk"L];    dfseq ¬ DFSubr.AllocateDFSeq[maxEntries: MaxFiles, zoneType: shared];    ConstructDF[dfseq];    sh ¬ MStream.WriteOnly[name: "Disk.DF"L, release: [], type: text      ! MStream.Error => {          CWF.WF0["Unable to create listing on 'Disk.DF'\n"L];	  ERROR ABORTED}];    CWF.FWF1[WFSH, "-- Whole disk (search path) on %lt\n"L, @startTime];    IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    DFSubr.SortByFileName[dfseq: dfseq, min: 0, max: (dfseq.size - 1)];    DFSubr.InsertCRs[dfseq];    DFSubr.WriteOut[      dfseq: dfseq, topLevelFile: NIL, outputStream: sh, print: TRUE];    Stream.Delete[sh];  sh ¬ NIL;    IF Exec.CheckForAbort[exec] THEN ERROR ABORTED;    CWF.WF0["Listing created on 'Disk.DF'\n"L];    elapsedTime ¬ [Time.Current[] - startTime];    CWF.WF1["\nTotal elapsed time for DFDisk %lr."L, @elapsedTime];    IF Subr.errorflg THEN CWF.WF0["\tErrors logged.\n"L]    ELSE CWF.WFCR[];    IF Subr.errorflg THEN outcome ¬ error;    EXITS      error => outcome ¬ error;      abort => outcome ¬ abort;    END;    Cleanup[];    DoneRunning[]};       -- DFDisk serialization   nowRunning: BOOLEAN ¬ FALSE;   AlreadyRunning: PUBLIC ENTRY PROC RETURNS [yes: BOOLEAN] = {    IF nowRunning THEN RETURN[TRUE];    nowRunning ¬ TRUE;    RETURN[FALSE]};    DoneRunning: PUBLIC ENTRY PROC = {nowRunning ¬ FALSE};  ConstructDF: PROC [dfseq: DFSubr.DFSeq] = {    AddDir: MFile.EnumerateProc = {      df: DFSubr.DF ¬ NIL;      fullname: LONG STRING ¬ [125];      host: LONG STRING ¬ [30];      directory: LONG STRING ¬ [100];      fixeddirectory : LONG STRING ¬ [100];      short: LONG STRING ¬ [100];      vfn: FileName.VFN ¬ NIL;            CleanUp: PROC = {        IF vfn # NIL THEN {FileName.FreeVFN[vfn]; vfn ¬ NIL}};	      FillDefaults: PROC = {        IF df.host = NIL THEN          df.host ¬ Subr.CopyString["Unknown"L, dfseq.dfzone];        IF df.directory = NIL THEN          df.directory ¬ Subr.CopyString["Unknown"L, dfseq.dfzone]};	        BEGIN       ENABLE UNWIND => CleanUp[];            IF ThrowAwayThisFile[name] THEN RETURN[done: FALSE];      df ¬ DFSubr.NextDF[dfseq];      IF df = NIL THEN RETURN[done: TRUE];  -- too many files      df.shortname ¬ Subr.CopyString[name, dfseq.dfzone];      df.presentonlocaldisk ¬ TRUE;      df.fHandle ¬ fileProc[access: readOnly, release: []        ! MFile.Error => {	    df.presentonlocaldisk ¬ FALSE;	    df.fHandle ¬ NIL;	    SELECT code FROM	      conflictingAccess => GOTO InUse;	      protectionFault => GOTO ReadProtected;	      noSuchFile => GOTO NotFound;	      ENDCASE => REJECT}];      IF df.presentonlocaldisk THEN {        df.createtime ¬ MFile.GetCreateDate[df.fHandle          ! MFile.Error => {FillDefaults[];  GOTO PressOn}];	FileName.GetRemoteName[df.fHandle, fullname	  ! FileName.Error => {FillDefaults[];  GOTO PressOn}];	IF fullname.length = 0 THEN {FillDefaults[];  GOTO PressOn};	vfn ¬ FileName.AllocVFN[fullname ! FileName.Error => {CleanUp[]; GOTO BadName}];	host ¬ vfn.host;	directory ¬ vfn.directory;	-- Now, I've got ALL this cruft to deal with	-- first of all, directory contains a leading '<, which DFSubr.StringLongName	-- took out for me. But I've got to use FileName, since the filenames keep changing,	-- and I'm not willing to keep up with that. Plus the directory has all this '/	-- in it, so I'm going to smash in a '> for that. Take that!	IF ~String.Empty[directory] THEN { -- We have something	  IF directory[0] = '< THEN { -- Take that out!	    fixeddirectory.length ¬ 0;	    FOR i: CARDINAL IN [1..directory.length) DO	      String.AppendChar[fixeddirectory, directory[i]];	    ENDLOOP; 	  };	  --Also, smash all occurences of '/ with a '>, which is what the DF software understands best.	  FOR i: CARDINAL IN [0..fixeddirectory.length) DO	   IF fixeddirectory[i] = '/ THEN fixeddirectory[i]  ¬ '>;	  ENDLOOP;	  String.Copy[to: directory, from: fixeddirectory];	};	short ¬ vfn.name;	IF ~String.EquivalentString[short, df.shortname] THEN {	  temp: LONG STRING ¬ [150];	  CWF.SWF1[	    temp, "\n-- The next file was renamed locally to %s.\n"L, name];          df.comment ¬ Subr.CopyString[temp, dfseq.dfzone];	  Subr.FreeString[df.shortname, dfseq.dfzone];	  df.shortname ¬ Subr.CopyString[short, dfseq.dfzone]};	df.host ¬ Subr.CopyString[IF ~String.Empty[directory] THEN host ELSE "Unknown"L, dfseq.dfzone];	df.directory ¬ Subr.CopyString[IF ~String.Empty[directory] THEN directory ELSE "Unknown"L, dfseq.dfzone];        };      CleanUp[];      RETURN[done: FALSE]      EXITS        InUse => CWF.WF1["  %s can't be accessed\n"L, fullName];        ReadProtected => CWF.WF1["  %s is read protected\n"L, fullName];        NotFound => CWF.WF1["  %s can't be read\n"L, fullName];        PressOn => NULL;	BadName => CleanUp[];      END};    MFile.EnumerateDirectory[name: "*"L, proc: AddDir, which: filesOnly]};  ThrowAwayThisFile: PROC [p: LONG STRING] RETURNS [discard: BOOLEAN] = {    transferFileList: ARRAY [0..4) OF LONG STRING ¬ [      "disk.df"L, "Executive.DontDeleteMe"L, "FileTool.logD"L, "line.cm"L];    discard ¬       Subr.EndsIn[p, "$"L] OR Subr.EndsIn[p, ".log"L] OR      Subr.EndsIn[p, ".errlog"L] OR Subr.EndsIn[p, ".tmp"L] OR      Subr.EndsIn[p, ".outload"L] OR Subr.EndsIn[p, ".dif"L] OR      Subr.EndsIn[p, ".bl"L] OR Subr.EndsIn[p, ".sl"L] OR      Subr.EndsIn[p, ".pgslog"L] OR Subr.EndsIn[p, ".echo"L];    IF ~discard THEN {      FOR i: CARDINAL IN [0..LENGTH[transferFileList]) DO        IF String.EquivalentString[p, transferFileList[i]] THEN RETURN[TRUE];        ENDLOOP;      RETURN[FALSE]}};  Init: PROC = {Exec.AddCommand[name:  "DFDisk.~"L, proc: Main, help:  Help,  unload:  Unload]};    Unload: Exec.ExecProc = {  []  ¬  h.RemoveCommand["DFDisk.~"L];  };    Help: Exec.ExecProc = {    OutputProc: Format.StringProc _ Exec.OutputProc[h];    h.OutputProc[]["DFDisk produces a file \"Disk.df\" that describes the current search path. With the exception of \"$\" files and a few kinds of log files, it lists all files on the search path with the create date and remote location found on the local disk. The remote location is taken from the RemoteName property in each file's leader page. DFDisk is most useful when you are trying to find the remote location for files, or when you are trying to save all your files before reformatting the volume. It can also tell you about new files that should be recorded in a DF file, since the RemoteName property for these files will nt have been set and they wil be listed under the remote \"location\" [Unknown]<Unknown>."L];  };  Init[];    END.Change log: 5-Feb-85 10:33:52	DSC  	Got rid of the use of StripLongName from DFSubr and use Filename instead. 			Why not use FileName in DFSubr? Since I parse my format [host]<dir>dir>...name			in MOST cases from DFFiles, and I do not want to break too many things. Boy..			I hate it when things like this change: i.e. [host]<dir>dir> to (host)dir/dir/dir..			And ALSO...Argh!! I found tons of MDS Strings. (STRING). I changed them to LONG STRING's
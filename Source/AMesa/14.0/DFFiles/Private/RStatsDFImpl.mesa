-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- RStatsDFImpl.mesa - Last edited by:--   Schmidt    October 12, 1982 11:07 am--   BTL  	31-Aug-83 16:24:07  DIRECTORY  BcdDefs USING [FTIndex, NameRecord],  BcdOps USING [BcdBase, FTHandle, NameString, ProcessFiles],  CWF USING [SWF2, SWF3, SWF4, WF0, WF1, WF2, WF3, WF4, WFCR],  DFSubr USING [    AllocateDFSeq, DF, DFSeq, FreeDFSeq, ParseStream, TooManyParseErrors],  Exec USING [CheckForAbort, Handle],  Format USING [StringProc],  LeafSubr USING [Close, FileHandle],  MStream USING [Error, Handle, WriteOnly],  ProcBcds USING [    InnardsObject, InstallAddressesBcd, InvalidBcd, ReadInSegmentsBcd,    UnstallBcd],  RStatsSupport USING [    BcdDep, BcdDepRecord, DFDep, DFDepRecord, DFRec, LeafOpenWithCreate,    NeededBcd, NeededBcdRecord, SortXRef, UniqueSortBcdDep, UniqueSortDFDep,    UniqueSortDFRec, XRef, XRefRecord],  Stream USING [Delete, Handle],  String USING [AppendChar, AppendString, Equivalent, StringBoundsFault],  Subr USING [AllocateString, Any, CopyString, EndsIn, FileError, FreeString],  Time USING [Packed],  Transfer USING [CachedOpen];RStatsDFImpl: PROGRAM    IMPORTS      BcdOps, CWF, DFSubr, Exec, LeafSubr, MStream, ProcBcds,      RStatsSupport, Stream, String, Subr, Transfer    EXPORTS RStatsSupport =  BEGIN  DFRec: TYPE = RStatsSupport.DFRec;  DFDep: TYPE = RStatsSupport.DFDep;  XRef:  TYPE = RStatsSupport.XRef;  BcdDep: TYPE = RStatsSupport.BcdDep;  NeededBcd: TYPE = RStatsSupport.NeededBcd;      dfExec: Exec.Handle ¬ NIL;  dfZone: UNCOUNTED ZONE ¬ NIL;      InitDFAnalysis: PUBLIC PROC [exec: Exec.Handle, zone: UNCOUNTED ZONE] = {    dfExec ¬ exec;  dfZone ¬ zone};      ProcessDFList: PUBLIC PROC [        topDFName: LONG STRING, dfrec: DFRec, xrefFileName: LONG STRING]      RETURNS [nDFFiles: CARDINAL] = {    dfxref: XRef ¬ NIL;    sh: MStream.Handle ¬ NIL;    line: STRING ¬ [200];    line2: STRING ¬ [200];        Put: Format.StringProc = {      sh.put[sH: sh, block: [LOOPHOLE[@s.text], 0, s.length], endRecord: FALSE]};    nDFFiles ¬ 0;    dfrec ¬ RStatsSupport.UniqueSortDFRec[dfrec];    FOR l: DFRec ¬ dfrec, l.rest UNTIL l = NIL DO      IF Exec.CheckForAbort[dfExec] THEN ERROR ABORTED;      dfxref ¬ AnalyzeDF[dfptr: l, olddfxref: dfxref, dfrec: dfrec];      nDFFiles ¬ nDFFiles + 1;      ENDLOOP;    CWF.WF0["\n\n---The Depends On Relation---\n\n"L];    CWF.WF0["DFFile on <Directory> depends on\n\tDFFile list\n\n"L];    FOR l: DFRec ¬ dfrec, l.rest UNTIL l = NIL DO      PrintDF[dfrec: l, depends: TRUE];      ENDLOOP;    CWF.WF0["\n\n---The Referenced By Relation---\n\n"L];    CWF.WF0["DFFile on <Directory> is referenced by\n\tDFFile list\n\n"L];    FOR l: DFRec ¬ dfrec, l.rest UNTIL l = NIL DO      l.refBy ¬ RStatsSupport.UniqueSortDFDep[l.refBy];      PrintDF[dfrec: l, depends: FALSE];      ENDLOOP;    -- now handle the XRef    dfxref ¬ RStatsSupport.SortXRef[dfxref];    BEGIN ENABLE UNWIND => {      IF dfxref # NIL THEN {ReleaseDFXref[dfxref];  dfxref ¬ NIL};      IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL}};    sh ¬ MStream.WriteOnly[name: xrefFileName, release: [], type: text      ! MStream.Error => {          CWF.WF1["\nUnable to write cross reference to %s.\n"L, xrefFileName];	  CONTINUE}];    IF sh # NIL THEN {      xrefLen: CARDINAL ¬ 0;      FOR x: XRef ¬ dfxref, x.rest UNTIL x = NIL DO        xrefLen ¬ xrefLen + 1;	ENDLOOP;      CWF.SWF2[        line, "DF Cross Reference for %s.\nTotal of %u files.\n\n"L,	topDFName, @xrefLen];      Put[line];      FOR x: XRef ¬ dfxref, x.rest UNTIL x = NIL DO        CWF.SWF4[	  line2, "[%s]<%s>\t%u\t%lt"L,	  x.host, x.directory, @x.version, @x.createtime];        CWF.SWF4[	  line, "%s\t%s%s\t%s\n"L,	  x.shortname, x.dfpath, x.dfshortname, line2];	Put[line];        ENDLOOP;      Stream.Delete[sh];  sh ¬ NIL;      CWF.WF1["\n\nCross reference stored on %s.\n"L, xrefFileName];      ReleaseDFXref[dfxref]};    END};      ReleaseDFXref: PROC [dfxref: XRef] = {    rest: XRef;    FOR x: XRef ¬ dfxref, rest UNTIL x = NIL DO      rest ¬ x.rest;      ReleaseDFXrefRecord[x];      ENDLOOP};        ReleaseDFXrefRecord: PROC [x: XRef] = {    b, rest: NeededBcd ¬ NIL;    -- release x's strings    Subr.FreeString[x.shortname, dfZone];   x.shortname ¬ NIL;    Subr.FreeString[x.host, dfZone];	    x.host ¬ NIL;    Subr.FreeString[x.directory, dfZone];   x.directory ¬ NIL;    Subr.FreeString[x.dfshortname, dfZone]; x.dfshortname ¬ NIL;    Subr.FreeString[x.dfpath, dfZone];	    x.dfpath ¬ NIL;    -- release list of bcds that x depends on    FOR b ¬ x.bcdChild, rest UNTIL b = NIL DO      rest ¬ b.rest;      dfZone.FREE[@b];      ENDLOOP;    x.bcdChild ¬ NIL};        ProcessBcdAnalysis: PUBLIC PROC [dfrec: DFRec] = {    dfxref: XRef ¬ NIL;    dfrec ¬ RStatsSupport.UniqueSortDFRec[dfrec];    FOR l: DFRec ¬ dfrec, l.rest UNTIL l = NIL DO      IF Exec.CheckForAbort[dfExec] THEN ERROR ABORTED;      dfxref ¬ AnalyzeDF[dfptr: l, olddfxref: dfxref, dfrec: dfrec];      ENDLOOP;    -- now handle the XRef    dfxref ¬ RStatsSupport.SortXRef[dfxref];    CWF.WF0["\nAnalyzing Bcd dependencies...\n\n"L];    AnalyzeBcdDep[dfxref, dfrec];    CWF.WF0["\n---Bcd Dependencies of DF Files---\n\n"L];    PrintBcdDependency[dfrec];    EmitCompileStatement[dfxref];    ReleaseDFXref[dfxref]};  AnalyzeDF: PROC [      dfptr: DFRec, olddfxref: XRef, dfrec: DFRec] RETURNS [dfxref: XRef] = {    sh: Stream.Handle ¬ NIL;    dfseq: DFSubr.DFSeq ¬ NIL;    df: DFSubr.DF;        CleanUp: PROC = {      IF sh # NIL THEN {Stream.Delete[sh];  sh ¬ NIL};      IF dfseq # NIL THEN DFSubr.FreeDFSeq[@dfseq]};          BEGIN ENABLE UNWIND => CleanUp[];    dfseq ¬ DFSubr.AllocateDFSeq[500, shared];    dfxref ¬ olddfxref;    CWF.WF3[      "Reading [%s]<%s>%s...\n"L, dfptr.host, dfptr.directory, dfptr.shortname];    sh ¬ Transfer.CachedOpen[      host: dfptr.host, directory: dfptr.directory, name: dfptr.shortname,      wantCreateTime: Time.Packed[0],      wantExplicitVersion: TRUE, version: dfptr.version,      checkForOverwrite: FALSE, window: NIL,      retrieveToTemp: FALSE, localDir: NIL      ! Subr.FileError => {sh ¬ NIL;  CONTINUE}];    IF sh = NIL THEN {      CWF.WF1["Warning - cannot read contents of %s.\n"L, dfptr.shortname];      RETURN};    DFSubr.ParseStream[      sh: sh, dfseq: dfseq, dffilename: dfptr.shortname, using: NIL,      noremoteerrors: TRUE, forceReadonly: FALSE, omitNonPublic: FALSE,      interestingNestedDF: NIL, ancestor: NIL, nLevel: 0, limitErrors: TRUE      ! DFSubr.TooManyParseErrors => {          CWF.WF1[	    " - parse abandoned, too many errors in %s.\n"L, dfptr.shortname];	  GOTO leave};	String.StringBoundsFault => {	  CWF.WF1[	    " - parse abandoned, StringBoundsFault in %s.\n"L, dfptr.shortname];	  GOTO leave}];    Stream.Delete[sh];  sh ¬ NIL;    FOR i: CARDINAL IN [0..dfseq.size) DO      df ¬ @dfseq[i];      IF Subr.EndsIn[df.shortname, ".df"L] AND df.atsign THEN {        new: DFDep ¬ dfZone.NEW[RStatsSupport.DFDepRecord ¬ [	  rest:       dfptr.dep,	  directory:  NIL,	  shortname:  Subr.CopyString[df.shortname, dfZone],          createtime: df.createtime]];        dfptr.dep ¬ new;        AddToRefBy[df.host, df.directory, df.shortname, dfptr, dfrec]}      ELSE {  -- add to cross reference list        new: XRef;	path: LONG STRING ¬ Subr.AllocateString[	  nchars: (dfptr.host.length + dfptr.directory.length + 4), zone: dfZone];	CWF.SWF2[path, "[%s]<%s>"L, dfptr.host, dfptr.directory];	new ¬ dfZone.NEW[RStatsSupport.XRefRecord ¬ [	  rest:        dfxref,          shortname:   Subr.CopyString[df.shortname, dfZone],	  host:        Subr.CopyString[df.host, dfZone],	  directory:   Subr.CopyString[df.directory, dfZone],	  version:     df.version,	  createtime:  df.createtime,	  dfshortname: Subr.CopyString[dfptr.shortname, dfZone],	  dfpath:      path,	  readOnly:    df.readonly,	  compiled:    FALSE,	  eval:        FALSE,	  bcdChild:    NIL]];        dfxref ¬ new};      ENDLOOP;    dfptr.dep ¬ RStatsSupport.UniqueSortDFDep[dfptr.dep];    EXITS leave => NULL;    END;    CleanUp[]};  AddToRefBy: PROC [      host, directory, shortname: LONG STRING, dfptr: DFRec, dfrec: DFRec] = {    -- look for shortname, add dfptr to the refBy list    FOR l: DFRec ¬ dfrec, l.rest UNTIL l = NIL DO      IF String.Equivalent[l.shortname, shortname]      AND String.Equivalent[l.directory, directory]      AND String.Equivalent[l.host, host] THEN {  -- found it        new: DFDep ¬ dfZone.NEW[RStatsSupport.DFDepRecord ¬ [	  rest:       l.refBy,	  directory:  Subr.CopyString[dfptr.directory, dfZone],	  shortname:  Subr.CopyString[dfptr.shortname, dfZone],          createtime: Time.Packed[0]]];        l.refBy ¬ new;        RETURN};      ENDLOOP;    CWF.WF4[      "  Cannot add RefBy info: [%s]<%s>%s by %s.\n"L,      host, directory, shortname, dfptr.shortname]};        TabSize: CARDINAL = 8;  LineLength: CARDINAL = 80;  PrintDF: PROC [dfrec: DFRec, depends: BOOLEAN] = {    l: DFDep;    current: INTEGER ¬ TabSize;    IF depends THEN      CWF.WF2["\n%s on <%s> depends on:\n\t"L, dfrec.shortname, dfrec.directory]    ELSE      CWF.WF2[        "\n%s on <%s> is referenced by:\n\t", dfrec.shortname, dfrec.directory];    l ¬ (IF depends THEN dfrec.dep ELSE dfrec.refBy);    UNTIL l = NIL DO      len: INTEGER ¬ (l.shortname.length + 1);      IF current + len > LineLength THEN {CWF.WF0["\n\t"L];  current ¬ TabSize};      CWF.WF1["%s "L, l.shortname];  current ¬ current + len;      l ¬ l.rest;      ENDLOOP;    CWF.WFCR[]};  AnalyzeBcdDep: PROC [dfxref: XRef, dfrec: DFRec] = {    FOR l: XRef ¬ dfxref, l.rest UNTIL l = NIL DO      IF ~l.readOnly AND Subr.EndsIn[l.shortname, ".bcd"L]      AND ~Subr.EndsIn[l.shortname, "Impl.bcd"L] THEN        ForEachBcd[l, dfxref, dfrec];      ENDLOOP};  ForEachBcd: PROC [thisBcd, dfxref: XRef, dfrec: DFRec] = {    sfn: STRING ¬ [150];    innards: ProcBcds.InnardsObject ¬ [];    success: BOOLEAN ¬ TRUE;    bcdName: LONG STRING ¬ [150];    ForEachFile: PROC [        fth: BcdOps.FTHandle, fti: BcdDefs.FTIndex] RETURNS [stop: BOOLEAN] = {      stop ¬ FALSE;      bcdName.length ¬ 0;      StringForName[bcdName, fth.name, innards.ssb];      IF ~Subr.Any[bcdName, '.] THEN String.AppendString[bcdName, ".bcd"L];      IF ~Subr.EndsIn[bcdName, ".bcd"L] THEN RETURN;      FOR l: XRef ¬ dfxref, l.rest UNTIL l = NIL DO        IF String.Equivalent[l.shortname, bcdName] THEN {	  new: NeededBcd ¬ NIL;          DFDependsOnDF[thisBcd.dfshortname, l, dfrec];	  new ¬ dfZone.NEW[RStatsSupport.NeededBcdRecord ¬ [	    rest: thisBcd.bcdChild,	    bcd:  l]];	  thisBcd.bcdChild ¬ new;          EXIT};        REPEAT          FINISHED =>	    CWF.WF1["  Cannot find %s in list of all files.\n"L, bcdName];        ENDLOOP};    BEGIN      ENABLE UNWIND => {        IF innards.rHandle # NIL THEN {	  LeafSubr.Close[innards.rHandle];  innards.rHandle ¬ NIL}};    IF thisBcd.version > 0 THEN      CWF.SWF4[        sfn, "[%s]<%s>%s!%u"L,	thisBcd.host, thisBcd.directory, thisBcd.shortname, @thisBcd.version]    ELSE      CWF.SWF3[        sfn, "[%s]<%s>%s"L, thisBcd.host, thisBcd.directory, thisBcd.shortname];    CWF.WF1["%s.\n"L, sfn];    innards.rHandle ¬ RStatsSupport.LeafOpenWithCreate[      thisBcd.host, thisBcd.directory, thisBcd.shortname,      thisBcd.version, thisBcd.createtime       ! Subr.FileError => {          CWF.WF1["  Error - cannot open %s.\n"L, sfn];  GOTO leave}];    IF innards.rHandle = NIL THEN GOTO leave;    ProcBcds.ReadInSegmentsBcd[@innards      ! ProcBcds.InvalidBcd => {          CWF.WF1["  Error - %s is NOT a valid Bcd.\n"L, sfn];	  success ¬ FALSE;  CONTINUE}];    IF success THEN {      ProcBcds.InstallAddressesBcd[@innards];      [] ¬ BcdOps.ProcessFiles[innards.bcd, ForEachFile];      thisBcd.eval ¬ TRUE};    LeafSubr.Close[innards.rHandle];  innards.rHandle ¬ NIL;    ProcBcds.UnstallBcd[@innards];    EXITS leave => NULL;    END};  DFDependsOnDF: PROC [parentdf: LONG STRING, child: XRef, dfrec: DFRec] = {    parentdfrec, childdfrec: DFRec ¬ NIL;    new: BcdDep ¬ NIL;    FOR l: DFRec ¬ dfrec, l.rest UNTIL l = NIL DO      IF String.Equivalent[parentdf, l.shortname] THEN {        parentdfrec ¬ l;  EXIT};      REPEAT        FINISHED => {          CWF.WF1["  Cannot find %s in list of DF files.\n"L, parentdf];          RETURN};      ENDLOOP;    FOR l: DFRec ¬ dfrec, l.rest UNTIL l = NIL DO      IF String.Equivalent[child.dfshortname, l.shortname] THEN {        childdfrec ¬ l;  EXIT};      REPEAT        FINISHED => {          CWF.WF1["  Cannot find %s in list of DF files.\n"L, child.dfshortname];          RETURN};      ENDLOOP;    new ¬ dfZone.NEW[RStatsSupport.BcdDepRecord ¬ [      rest:    parentdfrec.bcdDep,      dfrec:   childdfrec,      bcdName: Subr.CopyString[child.shortname, dfZone]]];    parentdfrec.bcdDep ¬ new};  StringForName: PROC [      bcdName: LONG STRING, name: BcdDefs.NameRecord,      namestring: BcdOps.NameString] = {    len: CARDINAL ¬ namestring.size[name];    bcdName.length ¬ 0;    FOR i: CARDINAL IN [0..len) DO      String.AppendChar[bcdName, namestring.string.text[name + i]];      ENDLOOP};  PrintBcdDependency: PROC [dfrec: DFRec] = {    FOR l: DFRec ¬ dfrec, l.rest UNTIL l = NIL DO      l.bcdDep ¬ RStatsSupport.UniqueSortBcdDep[l.bcdDep];      PrintBcdDependencyForADF[l];      ENDLOOP};  PrintBcdDependencyForADF: PROC [dfrec: DFRec] = {    temp: STRING ¬ [200];    current: CARDINAL ¬ TabSize;    len: CARDINAL;    CWF.WF2[      "\n%s on <%s> depends on (bcd):\n\t"L, dfrec.shortname, dfrec.directory];    FOR l: BcdDep ¬ dfrec.bcdDep, l.rest UNTIL l = NIL DO      IF String.Equivalent[l.dfrec.shortname, dfrec.shortname] THEN LOOP;      CWF.SWF2[temp, "%s (%s) "L, l.dfrec.shortname, l.bcdName];      len ¬ temp.length;      IF (current + len) > LineLength THEN {CWF.WF0["\n\t"L];  current ¬ TabSize};      CWF.WF1["%s"L, temp];  current ¬ current + len;      ENDLOOP;    CWF.WFCR[]};  EmitCompileStatement: PROC [dfxref: XRef] = {    CWF.WF0["\n---Compile all files---\n\nCompile.~"L];    FOR l: XRef ¬ dfxref, l.rest UNTIL l = NIL DO      IF ~l.compiled AND l.eval THEN GenCompile[l];      ENDLOOP;    CWF.WF0[";\n\n"L]};  GenCompile: PROC [x: RStatsSupport.XRef] = {    IF x.compiled OR ~x.eval THEN RETURN;    FOR l: NeededBcd ¬ x.bcdChild, l.rest UNTIL l = NIL DO      IF ~l.bcd.compiled AND l.bcd # x THEN GenCompile[l.bcd];      ENDLOOP;    CWF.WF1[" %s"L, x.shortname];    x.compiled ¬ TRUE};  END.
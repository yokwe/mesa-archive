-- File DFToolWindow.mesa - last edited by--   BTL  	20-Dec-83 11:22:07--   DSC  	19-Jun-85 16:30:32--  Purpose: --  Window implementation for the DFTool.-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. --  	DIRECTORY	CWF, DFLibrarian, DFToolForms, DFToolOps, DFVersion, Event, Exec, FileName, FileTransfer, Format, FormSW, Heap, Librarian, Menu, MFile, MSegment, MsgSW, MStream, Process, Profile, Put, Runtime, String, Subr, TextSW, Time, Tool, ToolWindow, Transfer, TTYSW, UserInput, UserTerminal, Version, Volume, Window;DFToolWindow: MONITORIMPORTS CWF, DFToolForms, DFToolOps, DFVersion, Event, Exec, FileName, FileTransfer, FormSW, Heap, Librarian, Menu, MFile, MSegment, MStream, MsgSW, Process, Profile, Put, Runtime, String, Subr, TextSW, Time, Tool, ToolWindow, Transfer, TTYSW, UserInput, UserTerminal, Volume, Window EXPORTS DFToolOps = BEGIN  toolData: PUBLIC DFToolOps.Data ¬ NIL; -- this has some defaults set by the type declaration. Some user.cm defaults are set later through Subr globals.  saveSwitch: DFToolOps.Switches ¬ DFToolOps.SwitchDefaults;  optWorkingLoc: LONG STRING ¬ NIL;  optIntegrationLoc: LONG STRING ¬ NIL;  optLocalDFDir: LONG STRING ¬ NIL;  inactive: BOOLEAN ¬ FALSE;  -- All the fields in the options sheet.  OptFormItems: TYPE = {apply, abort, workingDFLoc, integrationLoc, localDFDir};  -- DFTool window  FireUpWindow: PROC = {    -- Don't use Version.Append since that's misleading.    herald: LONG STRING ¬ [100];        String.AppendString[herald, "DFTool "L];    DFVersion.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 3;    -- toolData.toolWindow is set in MakeSWs below    [] ¬ Tool.Create[makeSWsProc: MakeSWs, initialState: default, name: herald,      clientTransition: ClientTransition, cmSection: "DFTool"L, tinyName1: "DF"L,      tinyName2: "Tool"L]};     -- Make an array of option windows to be swapped in depending on the operation chosen.   MakeOptionsWindow: PROCEDURE [op: DFToolOps.ToolOperations] = {    wh: Window.Handle ¬ ToolWindow.CreateSubwindow[parent: NIL];    SELECT op FROM      BringOver =>{FormSW.Create[sw: wh, clientItemsProc: DFToolForms.MakeBringOverOptionsFormSW, options: [scrollVertical: FALSE]]; toolData.optSWs[BringOver] ¬ wh};      StoreBack =>{FormSW.Create[sw: wh, clientItemsProc: DFToolForms.MakeSmodelOptionsFormSW, options: [scrollVertical: FALSE]]; toolData.optSWs[StoreBack] ¬ wh};      VerifyDF => {FormSW.Create[sw: wh, clientItemsProc: DFToolForms.MakeVerifyDFOptionsFormSW, options: [scrollVertical: FALSE]]; toolData.optSWs[VerifyDF] ¬ wh};      CheckOut => {FormSW.Create[sw: wh, clientItemsProc: DFToolForms.MakeNoOptionsFormSW, options: [scrollVertical: FALSE]]; toolData.optSWs[CheckOut] ¬ wh};      Query =>    {FormSW.Create[sw: wh, clientItemsProc: DFToolForms.MakeNoOptionsFormSW, options: [scrollVertical: FALSE]]; toolData.optSWs[Query] ¬ wh};      DFDelete => {FormSW.Create[sw: wh, clientItemsProc: DFToolForms.MakeDFDeleteOptionsFormSW, options: [scrollVertical: FALSE]]; toolData.optSWs[DFDelete] ¬ wh};      ENDCASE => ERROR;    };      MakeAllOptionWindows: PROCEDURE = {    FOR op: DFToolOps.ToolOperations IN DFToolOps.ToolOperations DO      MakeOptionsWindow[op: op];     ENDLOOP};    SetUpDefaultFields: PROCEDURE = {     -- Rationalize this someday. first of all dfLibjectsOnly should be a tool switch too.    toolData.switch[checkLibrarian] ¬ Subr.checkLibrarian;    toolData.switch[dfLibjectsOnly] ¬ Subr.dfLibjectsOnly;    IF String.Empty[Subr.workingDFHost] OR String.Empty[Subr.workingDFDir] THEN      toolData.workingDFLoc ¬ NIL    ELSE {      toolData.workingDFLoc ¬ String.MakeString[        z: Heap.systemZone,        maxlength: (Subr.workingDFHost.length + Subr.workingDFDir.length + 4)];      CWF.SWF2[        toolData.workingDFLoc, "[%s]<%s>"L, Subr.workingDFHost,        Subr.workingDFDir]};    IF String.Empty[Subr.integrationHost] OR String.Empty[Subr.integrationDir]      THEN toolData.integrationLoc ¬ NIL    ELSE {      toolData.integrationLoc ¬ String.MakeString[        z: Heap.systemZone,        maxlength:        (Subr.integrationHost.length + Subr.integrationDir.length + 4)];      CWF.SWF2[        toolData.integrationLoc, "[%s]<%s>"L, Subr.integrationHost,        Subr.integrationDir]};    toolData.localDFDir ¬      (IF String.Empty[Subr.localDFDir] THEN NIL       ELSE String.CopyToNewString[Subr.localDFDir, Heap.systemZone]);  };    ToolPutProc: PROC [c: CHARACTER] = {Put.Char[toolData.ttySW, c]};    InitializeToolStuff: PROCEDURE = {    [] ¬ CWF.SetWriteProcedure[ToolPutProc];  -- i/o is via toolData.ttySW    -- This Creates the long zone and sets the User.cm variables.    Subr.SubrInit[exec: NIL];    SetUpDefaultFields[];    Transfer.Initialize[exec: NIL, window: toolData.ttySW];    PrintSeparator[]  };    OptionsWindowForOperation: PROCEDURE  RETURNS[wh: Window.Handle] = {    wh ¬ toolData.optSWs[LOOPHOLE[toolData.operation, DFToolOps.ToolOperations]];  };    OperationInTool: PROCEDURE RETURNS [operation: DFToolOps.ToolOperations] = {    operation ¬ LOOPHOLE[toolData.operation, DFToolOps.ToolOperations];  };    MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [100];    Tool.UnusedLogName[unused: logName, root: "DFTool.log"L];    toolData.toolWindow ¬ window;    MakeAllOptionWindows[];    toolData.msgSW ¬ Tool.MakeMsgSW[window: window, lines: 1];    toolData.cmdSW ¬ Tool.MakeFormSW[window: window, formProc: DFToolForms.MakeCmdForm];    toolData.ttySW ¬  Tool.MakeTTYSW[window: window, name: logName];    -- Set up the option sheet to be for the default option set in the enumeration.    Tool.AddThisSW[window: window, sw: OptionsWindowForOperation[], nextSW: toolData.ttySW];    toolData.paramSW ¬ OptionsWindowForOperation[];    InitializeToolStuff[];    CWF.WF1["This window is logged on %s.\n"L, logName];  };  NewOperation: PUBLIC FormSW.EnumeratedNotifyProcType = {    wh: Window.Handle ¬ OptionsWindowForOperation[];    [] ¬ Tool.SwapSWs[window: toolData.toolWindow, oldSW: toolData.paramSW, newSW:  wh];    toolData.paramSW ¬ wh;  };    Stop: PUBLIC FormSW.ProcType = {CWF.WF0["Please hit the STOP key on the keyboard.\n"L]};      Help: PUBLIC FormSW.ProcType = {  SELECT OperationInTool[] FROM    BringOver => BringOverHelp[];    StoreBack => SModelHelp[];    VerifyDF => NoHelp[];    CheckOut => NoHelp[];    Query => NoHelp[];    DFDelete => NoHelp[];    ENDCASE => ERROR;  CWF.WF0["Please read the documentation for more details.\n"L];  };    NoHelp: PROCEDURE = {    CWF.WF0["No help.\n"L];  };  BringOverHelp: PROCEDURE = {    CWF.WF0["BringOver options.\n"L];    CWF.WF0["_________________\n"L];    CWF.WF0["Confirm: Ask for confirmation per retrieval.\n"L];    CWF.WF0["Exports: get just Public files.\n"L];    CWF.WF0["Imports: get just ReadOnly files. (Imported and Readonly)\n"L];    CWF.WF0["Writable: get just Writable files. (Exports or Directory) Inverse of Imports.\n"L];    CWF.WF0["Objects: get just derived files: .bcd, .symbols, .signals, .press.\n"L];    CWF.WF0["Sources: get just source files. Inverse of Objects.\n"L];    CWF.WF0["Update: Only update existing local files (never get new files).\n"L];    CWF.WF0["GetOlderOk: Supress confirmation request if an older remote file is rerieved.\n"L];    CWF.WF0["Verify: Verify files exist in the right place and version , and fill in DF dates.\n"L];    CWF.WF0["PreRelease: Get files from integration directory.\n"L];    CWF.WF0["ArchiveBCD: Rename .bcd to .archivebcd if an archivebcd already exists.\n"L];  };  SModelHelp: PROCEDURE = {      CWF.WF0["SModel options.\n"L];    CWF.WF0["_________________\n"L];    CWF.WF0["Confirm: Ask for confirmation per retrieval.\n"L];    CWF.WF0["FlipCameFrom: Flip CameFrom clause to be ReleaseAs.\n"L];    CWF.WF0["Librarian: Check with the program librarian. Overrides User.cm\n"L];    CWF.WF0["DontStore: Do not store files remotely.\n"L];    CWF.WF0["TopLevel: Process only the top (outermost) DF files, not Includes .DFs\n"L];    CWF.WF0["VerifyRemote: Verify that files are really on the remote server and store if necessary.\n"L];    CWF.WF0["PreRelease: Store files to integration directory.\n"L];    CWF.WF0["DFLibjects: Check librarian for .DFs only.\n"L];  };  -- This is crufty code here, someday, make an enumeration for it. also, notice that we use short STRINGs here. Don't change that!  Doit: PUBLIC FormSW.ProcType = {    enumItem: FormSW.ItemHandle ¬ FormSW.FindItem[toolData.cmdSW, DFToolForms.CmdFormItems.operation.ORD];    IF ~StartCommand[] THEN RETURN;    -- Make the Enumerated READONLY    enumItem.flags.readOnly ¬ TRUE;    SELECT OperationInTool[] FROM      BringOver => Process.Detach[FORK Umbrella[DFToolOps.BringOver, BringOver]];      StoreBack => Process.Detach[FORK Umbrella[DFToolOps.SModel, StoreBack]];      VerifyDF => Process.Detach[FORK Umbrella[DFToolOps.VerifyDF, VerifyDF]];      CheckOut => Process.Detach[FORK Umbrella[DFToolOps.CheckOut, CheckOut]];      Query => Process.Detach[FORK Umbrella[DFToolOps.Query, Query]];      DFDelete => Process.Detach[FORK Umbrella[DFToolOps.DFDelete, DFDelete]];      ENDCASE => ERROR;    };  PrintSeparator: PROC = {    CWF.WF0["=====================================\n"L]};  -- Transition and sync related stuff.    ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      (old = inactive) => WakeUp[];      (new = inactive) => Sleep[];      ENDCASE};  WakeUp: PROC = {    inactive ¬ FALSE;    IF toolData = NIL THEN -- We do not save the old options!      toolData ¬ Heap.systemZone.NEW[DFToolOps.DataObject ¬ []];      toolData.libHandle ¬ Heap.systemZone.NEW[DFLibrarian.Object ¬ []];    };  Sleep: ENTRY PROC = {    inactive ¬ TRUE;    IF toolData # NIL THEN {      WHILE toolData.toolBusy DO WAIT toolData.untilDone ENDLOOP;      Transfer.Finalize[];      Subr.SubrStop[];      IF toolData.optWindow # NIL THEN {        Tool.Destroy[toolData.optWindow]; toolData.optWindow ¬ NIL};      IF toolData # NIL THEN Heap.systemZone.FREE[@toolData]}};  -- Options window  BringUpOptionSheet: PUBLIC FormSW.ProcType = {    location: Window.Place ¬ Window.BitmapPlace[toolData.toolWindow];    location.y ¬ location.y + 122;    IF toolData.optionBusy THEN {      MsgSW.Post[toolData.msgSW, "Options window already up!"L];      UserTerminal.BlinkDisplay[];      RETURN}    ELSE toolData.optionBusy ¬ TRUE;    toolData.optWindow ¬ Tool.Create[      makeSWsProc: MakeOptionSWs, initialState: default,      initialBox: [location, [488, 120]], clientTransition: OptionTransition,      name: "DFTool Options"L,  --cmSection: "DFToolOptions"L,--      tinyName1: "DFTool"L, tinyName2: "Options"L]};  MakeOptionSWs: Tool.MakeSWsProc = {    menuStrings: ARRAY [0..1] OF LONG STRING ¬ ["Apply"L, "Abort"L];    optWorkingLoc ¬      (IF String.Empty[toolData.workingDFLoc] THEN NIL       ELSE String.CopyToNewString[toolData.workingDFLoc, Heap.systemZone]);    optIntegrationLoc ¬      (IF String.Empty[toolData.integrationLoc] THEN NIL       ELSE String.CopyToNewString[toolData.integrationLoc, Heap.systemZone]);    optLocalDFDir ¬      (IF String.Empty[toolData.localDFDir] THEN NIL       ELSE String.CopyToNewString[toolData.localDFDir, Heap.systemZone]);    toolData.optMenu ¬ Menu.Make[      name: "Options", strings: DESCRIPTOR[menuStrings], mcrProc: OptionMenu];    toolData.optFormSW ¬ Tool.MakeFormSW[window: window, formProc: MakeOptForm, options: [type: relative]];    Menu.Instantiate[toolData.optMenu, window]};  ApplyOptions:  FormSW.ProcType = {    IF toolData.workingDFLoc # NIL THEN      String.FreeString[Heap.systemZone, toolData.workingDFLoc];    toolData.workingDFLoc ¬      (IF optWorkingLoc = NIL THEN NIL       ELSE String.CopyToNewString[optWorkingLoc, Heap.systemZone]);    Subr.SetWorkingDFLoc[toolData.workingDFLoc];    --    IF toolData.integrationLoc # NIL THEN      String.FreeString[Heap.systemZone, toolData.integrationLoc];    toolData.integrationLoc ¬      (IF optIntegrationLoc = NIL THEN NIL       ELSE String.CopyToNewString[optIntegrationLoc, Heap.systemZone]);    Subr.SetIntegrationLoc[toolData.integrationLoc];    --    IF toolData.localDFDir # NIL THEN      String.FreeString[Heap.systemZone, toolData.localDFDir];    toolData.localDFDir ¬      (IF optLocalDFDir = NIL THEN NIL       ELSE String.CopyToNewString[optLocalDFDir, Heap.systemZone]);    Subr.SetLocalDFDir[toolData.localDFDir];    --    Subr.debugflg ¬ Profile.debugging;    Tool.Destroy[toolData.optWindow];    toolData.optWindow ¬ NIL};  AbortOptions: FormSW.ProcType = {    Subr.debugflg ¬ Profile.debugging;    Tool.Destroy[toolData.optWindow];    toolData.optWindow ¬ NIL};  OptionMenu: Menu.MCRType = {  -- Options menu    SELECT index FROM 0 => ApplyOptions[]; 1 => AbortOptions[]; ENDCASE};  OptionTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM (new = inactive) => toolData.optionBusy ¬ FALSE; ENDCASE};  -- command procedures  StartCommand: PROC RETURNS [ok: BOOLEAN] = {    IF ~Enter[] THEN {PostMsg["DFTool already running!"L]; RETURN[FALSE]};    MsgSW.Clear[toolData.msgSW];    IF toolData.ttySW # NIL THEN  -- flush pending input in TTY sw      WHILE TTYSW.CharsAvailable[toolData.ttySW] > 0 DO        [] ¬ TTYSW.GetChar[toolData.ttySW]; ENDLOOP;    toolData.myEventHandle ¬ Event.StartingProcess["DFTool"L];    Transfer.StartSession[];    CopyStringParams[];    RETURN[TRUE]};  FinishCommand: PROC = {    enumItem: FormSW.ItemHandle ¬ FormSW.FindItem[toolData.cmdSW, DFToolForms.CmdFormItems.operation.ORD];    PrintSeparator[];    TextSW.ForceOutput[toolData.ttySW];    FreeStringParams[];    Event.DoneWithProcess[toolData.myEventHandle];    toolData.myEventHandle ¬ NIL;    Leave[];    enumItem.flags.readOnly ¬ FALSE};      -- Options sheet.  -- Change toolData.optWorkingLoc -> optWorkingLoc  MakeOptForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = OptFormItems.LAST.ORD + 1;    items ¬ AllocateItemDescriptor[nItems];    items[OptFormItems.apply.ORD] ¬ CommandItem[      tag: "Apply"L, place: newLine, proc: ApplyOptions];    items[OptFormItems.abort.ORD] ¬ CommandItem[      tag: "Abort"L, place: newLine, proc: AbortOptions];    items[OptFormItems.workingDFLoc.ORD] ¬ StringItem[      tag: "Working DF Loc"L, place: newLine, inHeap: TRUE, string: @optWorkingLoc];    items[OptFormItems.integrationLoc.ORD] ¬ StringItem[      tag: "Integration Loc"L, place: newLine, inHeap: TRUE, string: @optIntegrationLoc];    items[OptFormItems.localDFDir.ORD] ¬ StringItem[      tag: "Local DF Dir"L, place: newLine, inHeap: TRUE, string: @optLocalDFDir];    RETURN[items: items, freeDesc: TRUE];    };  Enter: ENTRY PROC RETURNS [ok: BOOLEAN] = {    ENABLE UNWIND => NULL;    IF toolData.toolBusy THEN RETURN[FALSE];    toolData.toolBusy ¬ TRUE;    RETURN[TRUE]};  Leave: ENTRY PROC = {    ENABLE UNWIND => NULL; toolData.toolBusy ¬ FALSE; NOTIFY toolData.untilDone};      GetServer: PROCEDURE RETURNS [db: LONG STRING] = {    StuffString: PROCEDURE [str: Profile.String] = {      db ¬ String.CopyToNewString[s: str, z: Heap.systemZone]};    Profile.GetLibrarian[StuffString]};  -- Take a snap shot of the tool parameters.  CopyStringParams: PROC = {    td: DFToolOps.Data = toolData;    IF td = NIL THEN RETURN;    td.inputDfFilesCopy ¬      (IF String.Empty[td.inputDfFiles] THEN NIL       ELSE String.CopyToNewString[td.inputDfFiles, Heap.systemZone]);    td.inputFilesCopy ¬      (IF String.Empty[td.inputFiles] THEN NIL       ELSE String.CopyToNewString[td.inputFiles, Heap.systemZone]);    td.reasonCopy ¬      (IF String.Empty[td.reason] THEN NIL       ELSE String.CopyToNewString[td.reason, Heap.systemZone]);    td.localDirCopy ¬      (IF String.Empty[td.localDir] THEN NIL       ELSE String.CopyToNewString[td.localDir, Heap.systemZone]);    td.libHandle.servername ¬ String.CopyToNewString[GetServer[], Heap.systemZone];    };  FreeStringParams: PROC = {    td: DFToolOps.Data = toolData;    IF td = NIL THEN RETURN;    IF ~String.Empty[td.inputDfFilesCopy] THEN {      String.FreeString[Heap.systemZone, td.inputDfFilesCopy];      td.inputDfFilesCopy ¬ NIL};    IF ~String.Empty[td.inputFilesCopy] THEN {      String.FreeString[Heap.systemZone, td.inputFilesCopy];      td.inputFilesCopy ¬ NIL};    IF ~String.Empty[td.reasonCopy] THEN {      String.FreeString[Heap.systemZone, td.reasonCopy]; td.reasonCopy ¬ NIL};    IF ~String.Empty[td.localDirCopy] THEN {      String.FreeString[Heap.systemZone, td.localDirCopy];      td.localDirCopy ¬ NIL};    IF ~String.Empty[td.libHandle.servername] THEN {      String.FreeString[Heap.systemZone, td.libHandle.servername];      td.libHandle.servername ¬ NIL}    };  PostMsg: PUBLIC PROC [msg: LONG STRING] = {MsgSW.Post[toolData.msgSW, msg, info, TRUE, FALSE]};  IsAborted: PUBLIC PROC RETURNS [BOOLEAN] = {    RETURN[UserInput.UserAbort[toolData.toolWindow]]};  Umbrella: PROC [cmdProc: PROC, op: DFToolOps.ToolOperations] = {  -- FORKed to do command    startTime, elapsedTime: Time.Packed;    cmdName: LONG STRING ¬ [100];    BEGIN    ENABLE { -- the biggest catch phrase I've seen.      UNWIND => FinishCommand[];      ABORTED => {        CWF.WF1["...DFTool %s aborted.\n"L, cmdName];        PostMsg["...aborted"L];        GOTO leave};      FileTransfer.Error =>        IF Subr.debugflg THEN REJECT        ELSE {          msg: STRING ¬ [60];          FileTransfer.CodeToString[code, msg];          CWF.WF1["FileTransfer error: %s\n"L, msg];          PostMsg["...FileTransfer error"L];          GOTO error};      Volume.InsufficientSpace =>        IF Subr.debugflg THEN REJECT        ELSE {CWF.WF0["Volume full.\n"L]; PostMsg["...Volume full"L]; GOTO error};  «    Librarian.WrongPropertyType => {        CWF.WF0["\nLibject property error. Wrong property type.\n"L];	GOTO error};       »      Librarian.Error => {        errorString: LONG STRING = [80];        IF Subr.debugflg THEN REJECT        ELSE {	  Librarian.StringForErrorCode[code, errorString];          CWF.WF1["\nLibrarian error: %s.\n"L, errorString];          PostMsg["...Librarian error"L];          GOTO error}};      CWF.WFError =>        IF Subr.debugflg THEN REJECT        ELSE {          CWF.WF1["\nCWF error: %s.\n"L, err];          PostMsg["...Internal (CWF) error"L];          GOTO error};      Subr.FileError =>        IF Subr.debugflg THEN REJECT        ELSE {          CWF.WF0["\nInternal error (Subr.FileError).\n"L];          PostMsg["...Internal error"L];          GOTO error};      FileName.Error =>        IF Subr.debugflg THEN REJECT        ELSE {          CWF.WF0["FileName error.\n"L];          PostMsg["...FileName error"L];          GOTO error};      MFile.Error =>        IF Subr.debugflg THEN REJECT        ELSE {          msg: STRING ¬ [100];          MFile.AppendErrorMessage[msg, code, file];          CWF.WF1["MFile error: %s\n"L, msg];          PostMsg["...MFile error"L];          GOTO error};      MStream.Error =>        IF Subr.debugflg THEN REJECT        ELSE {          msg: STRING ¬ [100];          Subr.AppendMStreamErrorMessage[msg, code, stream];          CWF.WF1["MStream error: %s.\n"L, msg];          PostMsg["...MStream error"L];          GOTO error};      MSegment.Error =>        IF Subr.debugflg THEN REJECT        ELSE {          msg: STRING ¬ [100];          Subr.AppendMSegmentErrorMessage[msg, code, segment];          CWF.WF1["MSegment error: %s.\n"L, msg];          PostMsg["...MSegment error"L];          GOTO error}};    String.Copy[to: cmdName, from: SELECT op FROM    BringOver => "BringOver"L, StoreBack => "SModel"L, VerifyDF => "VerifyDF"L, CheckOut  => "CheckOut"L, Query => "Query"L, DFDelete => "DFDelete"L, ENDCASE => ERROR];    startTime ¬ Time.Current[];    CWF.WF2["\n%s started at %lt\n\n"L, cmdName, @startTime];    Subr.errorflg ¬ FALSE;    Subr.alwaysConfirm ¬ FALSE;    toolData.dfZone ¬ Subr.LongZone[];    MsgSW.Clear[toolData.msgSW];    cmdProc[];    EXITS leave => Subr.errorflg ¬ TRUE; error => NULL;    END;    IF Subr.errorflg THEN {CWF.WF0["\nErrors logged.\n"L];     PostMsg[" Errors..."L]};    elapsedTime ¬ [Time.Current[] - startTime];    CWF.WF2["\nTotal elapsed time for %s %lr.\n"L, cmdName, @elapsedTime];    FinishCommand[]};  -- command line interface  DFToolExecCall: Exec.ExecProc = {    -- Must be around, but tiny.    IF toolData # NIL AND toolData.toolWindow # NIL THEN {      ToolWindow.Activate[toolData.toolWindow]}    ELSE {IF inactive THEN Exec.OutputProc[h]["DFTool is inactive.\n"L]; }};  -- initialization  Init: PROC = {    Exec.AddCommand[      name: "DFTool.~"L, proc: DFToolExecCall, help: EHelp, unload: DestroyWindow];    -- This allocates the herald and creates the tool.    FireUpWindow[]};  EHelp: Exec.ExecProc = {    OutputProc: Format.StringProc ¬ Exec.OutputProc[h];    h.OutputProc[][      "Please see the DF Software Reference Manual, or corresponding help descriptions from the individual tools."L];    };  DestroyWindow: Exec.ExecProc = {    IF toolData # NIL AND toolData.toolWindow # NIL THEN      Tool.Destroy[toolData.toolWindow];    h.RemoveCommand["DFTool.~"L]};  Init[];  END.Change Log:11-Sep-84 17:25:58	DSC  	Added code to make librarian related stuff invisible when the librarian code is not bound in.12-Sep-84  9:38:39	DSC  	Shoved librarian stuff over to DFLibrarian.12-Sep-84 12:01:15	DSC  	Fixed AR # 5518 and 4614 for not checking User.cm.12-Sep-84 13:16:33	DSC  	Fixed AR # 5495. Tells user if tool is already running. Doesn't really solve the problem of reactivating the window, which the user is expected to do.25-Sep-84 11:38:47	DSC  	Removed all internal employee names.14-Nov-84 18:01:11	DSC  	Made namestripe include version.16-Nov-84 17:53:28	DSC  	New user interface. Removed version since that's misleading. 20-Nov-84 10:52:50	DSC  	Upon KAM  's advice, added multiple option sheets rather than having an all the options displayed in a formSW with the relevant ones turned on. 20-Nov-84 16:42:50	DSC  	Note: FormSW.Create now has the scrollVertical set to false. For some reason, using the defaults makes the Swap routine try to delete the scrollbar which does not exist, and causes a crash. In investigation. 27-Nov-84 11:33:49	DSC  	Renamed DFToolWindow, since this becomes the main program. 2.127-Nov-84 15:00:02	DSC  	Allowed dfLibjectsonly to be read in from User.cm. 21-Jan-85  9:47:52	DSC  	Removed Pup Librarian protocols from it. 2.2 8-Feb-85 12:39:33	DSC  	Catch Librarian.WrongProperty. Now 2.314-Feb-85 18:15:44	DSC  	Renamed back to Smodel. People are used to it. 7-Mar-85 12:08:59	DSC  	Use MsgSW.Post.11-Apr-85 13:02:16	DSC  	AnyFont code.16-Apr-85 11:59:42	DSC  	Make operations enumeration in the CmdSw READONLY.17-Apr-85  9:52:37	DSC  	Help Procs.19-Jun-85 16:30:40	DSC  	Help Procs spelling mistakes.
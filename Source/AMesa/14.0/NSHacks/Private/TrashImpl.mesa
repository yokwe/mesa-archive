-- File: TrashImpl.mesa - last edit:-- AOF                 22-May-88 16:43:58-- Copyright (C) 1984, 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [Error, StringToNetworkAddress],  Buffer USING [    AccessHandle, Buffer, Dequeue, DestroyPool, Enqueue, MakePool,    QueueCleanup, QueueInitialize, QueueObject, ReturnBuffer, Type],  BufferDisplay USING [Format, Level1Packet],  DataLinkControl USING [AdjustInputQueueLength],  Driver USING [Device, GetDeviceChain],  Exec USING [AddCommand, ExecProc, Handle, RemoveCommand],  Format USING [LongDecimal, StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, Enumerated,    EnumeratedItem, newLine, NumberItem, ProcType, StringItem],  Heap USING [Create, Delete],  HostNumbers USING [IsMulticastID],  IEEE8023 USING [    Encapsulation, maxBytesPerEthernetPacket, minBytesPerEthernetPacket],  Process USING [    Abort, DisableTimeout, EnableAborts, Pause, priorityBackground, SetPriority],  Protocol1 USING [SetMaximumBufferSize],  Put USING [Line, Text],  Router USING [FindMyHostID],  Runtime USING [GetBcdTime],  SpecialCommunication USING [    SetEthernetCollectGarbageToo, SetEthernetListener, SetSpyProc,    SpyProc, SpyType],  SpecialSystem USING [HostNumber],  String USING [AppendString],  System USING [broadcastHostNumber, HostNumber, nullHostNumber],  Time USING [Append, Unpack],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle];    TrashImpl: MONITOR  IMPORTS    Buffer, Driver, Exec, SpecialCommunication, Put, FormSW, Process, Router,    Runtime, String, Time, Tool, Heap, BufferDisplay, UserInput, HostNumbers,    AddressTranslation, Format, DataLinkControl, Protocol1  EXPORTS Buffer, System =  BEGIN  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  HostNumber: PUBLIC <<System>> TYPE = SpecialSystem.HostNumber;      newTrash: CONDITION;  wh: Window.Handle ¬ NIL;  tool: ToolData ¬ [];  ToolData: TYPE = RECORD[    count: CARDINAL ¬ 0,    bunch: CARDINAL ¬ 5,    seen, forHim, forMe, trash: LONG CARDINAL ¬ 0,    me: HostNumber ¬ NULL,    queue: Buffer.QueueObject ¬ NULL,    him: HostNumber ¬ NULL,    running: BOOLEAN ¬ FALSE,    s: LONG STRING ¬ NIL,    what: Collection ¬ trash,    source: LONG STRING ¬ NIL,    verbose: BufferDisplay.Format ¬ hex,    buffers: Buffer.AccessHandle ¬ NIL,    formatter, stopper: PROCESS ¬ NIL,    form, log: Window.Handle ¬ NIL,    oldSpy: ARRAY Buffer.Type OF SpecialCommunication.SpyProc ¬ ALL[NIL]];  unit: CARDINAL = 1;  dispatcherBuffers: CARDINAL = 40;  zone: UNCOUNTED ZONE = Heap.Create[5];  all: HostNumber = System.broadcastHostNumber;  Write: Format.StringProc = {Put.Text[tool.log, s]};  Collection: TYPE = {all, bunch, trash};    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      Initialize: PROCEDURE =    BEGIN    herald: STRING ¬ [60];    Process.EnableAborts[@newTrash];    Process.DisableTimeout[@newTrash];    Exec.AddCommand["TrashTool.~"L, NoOp, NIL, Unload];    String.AppendString[to: herald, from: "Trash Tool of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 8;  -- omit hours, mins, zone.    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: herald];    END;  NoOp: Exec.ExecProc = { };    Unload: Exec.ExecProc = {    Tool.Destroy[wh]; Heap.Delete[zone]; Exec.RemoveCommand[h, "TrashTool.~"L]};    MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "TrashTool.log"L];    tool.form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm, zone: zone];    tool.log ¬ Tool.MakeFileSW[window: window, name: logName];    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL = 6;    what: ARRAY[0..3) OF FormSW.Enumerated ¬ [      ["all packets", Collection[all]],      ["next bunch", Collection[bunch]],      ["trash only", Collection[trash]]];    verbosity: ARRAY[0..4) OF FormSW.Enumerated ¬ [      ["off", BufferDisplay.Format[ebcdic]],      ["octal", BufferDisplay.Format[octal2]],      ["ascii", BufferDisplay.Format[ascii]],      ["hex", BufferDisplay.Format[hex]]];    items ¬ FormSW.AllocateItemDescriptor[nItems, zone];    items[0] ¬ FormSW.CommandItem[      tag: "Stop"L, proc: Stop, place: FormSW.newLine, z: zone];    items[1] ¬ FormSW.CommandItem[tag: "Start"L, proc: Go, z: zone];    items[2] ¬ FormSW.EnumeratedItem[      tag: "Collect"L, choices: DESCRIPTOR[what], value: @tool.what, z: zone];    items[3] ¬ FormSW.NumberItem[      tag: "bunch"L, boxWidth: 16, default: 0, value: @tool.bunch, z: zone];    items[4] ¬ FormSW.EnumeratedItem[      tag: "verbosity"L, choices: DESCRIPTOR[verbosity], place: FormSW.newLine,      value: @tool.verbose, z: zone];    items[5] ¬ FormSW.StringItem[      tag: "Source address"L, string: @tool.source, inHeap: TRUE, z: zone];    RETURN[items: items, freeDesc: TRUE];    END;  Stop: FormSW.ProcType =    BEGIN    OPEN tool;    IF running THEN      BEGIN      s: STRING ¬ [40];      running ¬ FALSE;      [] ¬ SpecialCommunication.SetEthernetListener[unit, me];      [] ¬ SpecialCommunication.SetEthernetCollectGarbageToo[unit, FALSE];      FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	[] ¬ SpecialCommunication.SetSpyProc[NIL, type];	ENDLOOP;      --Driver.ChangeNumberOfInputBuffers[FALSE];      [] ¬ DataLinkControl.AdjustInputQueueLength[ethernet, 0, 5];      FOR device: Driver.Device ¬ Driver.GetDeviceChain[], device.next	UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 576];	ENDLOOP;      Process.Abort[formatter]; JOIN formatter;      Buffer.QueueCleanup[@queue];      Buffer.DestroyPool[buffers];  --give pool back      String.AppendString[s, "Collected stopped at "L];      Time.Append[s, Time.Unpack[]]; Put.Line[log, s];      Format.LongDecimal[Write, seen];      Write[" packets observed\n"L];      Format.LongDecimal[Write, forMe];      Write[" where for ME\n"L];      Format.LongDecimal[Write, forHim];      Write[" where for him\n"L];      Format.LongDecimal[Write, trash];      Write[" had a trashy status\n"L];      zone.FREE[@tool.s];      END;    END;  --Stop  Stopper: PROC =    BEGIN    --running at Process.priorityForeground    ENABLE ABORTED => CONTINUE;    WHILE tool.running DO      IF UserInput.UserAbort[wh] THEN {Stop[]; EXIT};      Process.Pause[10]; ENDLOOP;    END;  --Stopper        Go: FormSW.ProcType =    BEGIN    OPEN tool;    IF ~running THEN      BEGIN      tool.s ¬ zone.NEW[StringBody[6000]];  --great big sucker      me ¬ Router.FindMyHostID[];  --that' me!      tool.him ¬ System.nullHostNumber;  --and that's not him      seen ¬ forHim ¬ forMe ¬ trash ¬ 0; count ¬ 0;      IF tool.source # NIL THEN	BEGIN	OPEN at: AddressTranslation;	ENABLE at.Error => CONTINUE;	tool.him ¬ at.StringToNetworkAddress[tool.source].addr.host;	END;      SELECT tool.him FROM        (System.nullHostNumber) =>	  {Write["No host specified...aborted\n"L]; RETURN};	(tool.me) => IF tool.what # trash THEN	  {Write["Cannot spy on ME and print non-trash packets\n"L]; RETURN};	(all) => IF tool.what # trash THEN	  {Write["Cannot spy on '*' and print non-trash packets\n"L]; RETURN};	ENDCASE;      running ¬ TRUE;      String.AppendString[tool.s, "Collected started at "L];      Time.Append[s, Time.Unpack[]];      Put.Line[log, tool.s];      Buffer.QueueInitialize[@queue];      formatter ¬ FORK Formatter[]; stopper ¬ FORK Stopper[];      buffers ¬ Buffer.MakePool[dispatcherBuffers, 0];  --get large pool      FOR device: Driver.Device ¬ Driver.GetDeviceChain[], device.next	UNTIL device = NIL DO	IF device.device = ethernet THEN	  Protocol1.SetMaximumBufferSize[device, NIL, 1500];	ENDLOOP;      --Driver.ChangeNumberOfInputBuffers[TRUE];      [] ¬ DataLinkControl.AdjustInputQueueLength[        ethernet, 0, dispatcherBuffers / 2];      FOR type: SpecialCommunication.SpyType IN SpecialCommunication.SpyType DO	tool.oldSpy[type] ¬ SpecialCommunication.SetSpyProc[SpyProc, type];	ENDLOOP;      [] ¬ SpecialCommunication.SetEthernetListener[unit, all];      [] ¬ SpecialCommunication.SetEthernetCollectGarbageToo[unit, TRUE];      END;    END;      ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      (new = inactive) => Stop[];      (old = inactive) => tool ¬ [];      ENDCASE;    END;	  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Worker routines:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Formatter: PROC =    BEGIN    OPEN tool;    OffQueue: ENTRY PROC RETURNS[b: Buffer.Buffer ¬ NIL] =      BEGIN      UNTIL b # NIL DO        ENABLE ABORTED => EXIT;        IF queue.length = 0 THEN {WAIT newTrash; LOOP};	b ¬ Buffer.Dequeue[@queue];        ENDLOOP;      END;    b: Buffer.Buffer;    Process.SetPriority[Process.priorityBackground];    WHILE running DO      IF (b ¬ OffQueue[]) = NIL THEN LOOP;      s.length ¬ 0; Time.Append[s, Time.Unpack[]];      Write[tool.s];      Write["  Buffer("L];      Write[SELECT b.fo.function FROM        send => "send"L, receive => "receive", driver => "driver"L,	ENDCASE => "???"L];      WITH status: b.fo.driver SELECT FROM        ethernet =>	  BEGIN	  SELECT b.fo.driver.length FROM	    < IEEE8023.minBytesPerEthernetPacket =>	      {Write[")  RUNT\n"L]; GOTO skip};	    > IEEE8023.maxBytesPerEthernetPacket =>	      {Write[")  LENGTH SUSPICIOUS\n"L]; GOTO skip};	    ENDCASE;	  Write[")  Status = ethernet["L];	  Write[SELECT status.ethernet FROM	    pending =>  "pending"L, ok => "ok"L, overrun => "overrun"L,	    underrun => "underrun"L, packetTooLong => "packetTooLong"L,	    tooManyCollisions => "tooManyCollisions"L,	    crc => "crc"L, crcAndBadAlignment => "crcAndBadAlignment"L,	    badAlignmentButOkCrc => "badAlignmentButOkCrc"L,	    ENDCASE => "otherError"L];	  Write["]\n"L];	  s.length ¬ 0;	  IF tool.verbose # ebcdic THEN	    BEGIN	    BufferDisplay.Level1Packet[b, tool.s, tool.verbose, Write];	    Write["\n"L];	    END;	  EXITS skip => NULL;	  END;	ENDCASE;      Buffer.ReturnBuffer[b];      ENDLOOP;    END;  --Formatter	      SpyProc: ENTRY SpecialCommunication.SpyProc =    BEGIN    OPEN encap: LOOPHOLE[b.linkLayer.blockPointer, IEEE8023.Encapsulation];    dest: HostNumber = encap.ethernetDest;    tool.seen ¬ tool.seen.SUCC;  --just a count    BEGIN      BEGIN      SELECT TRUE FROM	(function = send) => NULL;	(tool.count # 0) => GOTO enqueue;	(tool.what = all) => GOTO enqueue;	(dest = tool.me) => GOTO itsMe;	(HostNumbers.IsMulticastID[@encap.ethernetDest]) => GOTO itsMe;	(tool.him = all) =>GOTO itsHim;	(dest = tool.him) =>GOTO itsHim;	(encap.ethernetSource = tool.him) =>GOTO itsHim;	ENDCASE => GOTO freebuffer;      EXITS	itsMe =>	  BEGIN	  tool.forMe ¬ tool.forMe.SUCC;	  WITH status: b.fo.driver SELECT FROM	    ethernet =>	      SELECT status.ethernet FROM		(ok), (badAlignmentButOkCrc) => GOTO keepbuffer;		ENDCASE =>		  BEGIN		  tool.trash ¬ tool.trash.SUCC;		  IF tool.what = bunch THEN tool.count ¬ tool.bunch;		  GOTO enqueue;		  END;	    ENDCASE => GOTO keepbuffer;	  END;	itsHim =>	  BEGIN	  tool.forHim ¬ tool.forHim.SUCC;	  WITH status: b.fo.driver SELECT FROM	    ethernet =>	      SELECT status.ethernet FROM		(ok), (badAlignmentButOkCrc) => GOTO freebuffer;		ENDCASE =>		  BEGIN		  tool.trash ¬ tool.trash.SUCC;		  IF tool.what = bunch THEN tool.count ¬ tool.bunch;		  GOTO enqueue;		  END;	    ENDCASE => GOTO freebuffer;  --not ethernet data link	  END;      END;    EXITS      keepbuffer => NULL;  --returns with b # NIL      freebuffer => {Buffer.ReturnBuffer[b]; b ¬ NIL};      enqueue =>        BEGIN	NOTIFY newTrash;	IF tool.count # 0 THEN tool.count ¬ tool.count.PRED;	Buffer.Enqueue[@tool.queue, b];	b ¬ NIL;	END;    END;    RETURN[b];    END;    -- Mainline code:    Initialize[];    END.   
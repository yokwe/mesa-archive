-- File: SmashCHStubImpl.mesa - last edit:-- AOF                 11-Feb-87 10:52:57-- Copyright (C) 1984, 1985, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  CH USING [EnumerateNearbyDomains, Name],  CHAddressCacheFriends USING [InvalidateAddr],  CHNameToAddrMapper USING [    AddrList, closeCH, closeDomains, LOCK, myHeap, orgTreeHead,    unavailableDomains, heapChecking, processingHintCount],  CHSwitches USING [doStubDebug],  Exec USING [AddCommand, ExecProc, GetToken, OutputProc, RemoveCommand],  Format USING [NetworkAddress, StringProc],  Heap USING [Create, Delete, systemZone],  IncrementalSort USING [FindElement, Handle, MakeSorter, nullHandle],  NSName USING [    Name, MakeName, maxFullNameLength, NameFieldsFromString, FreeName],  NSString USING [StringFromMesaString],  Process USING [InitializeCondition, SecondsToTicks],  Profile USING [GetDefaultOrganization, Qualify],  Runtime USING [GlobalFrame, IsBound],  String USING [AppendChar, AppendString, EqualString],  System USING [NetworkAddress, nullNetworkAddress];SmashCHStubImpl: MONITOR LOCKS gf.LOCK  IMPORTS    CH, CHAddressCacheFriends, Exec, Format, Heap, IncrementalSort,    NSName, NSString, Process, Profile, Runtime, String  SHARES CHNameToAddrMapper =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;  gf: LONG POINTER TO FRAME[CHNameToAddrMapper];  <<COPIED FROM CHNameToAddrMapper>>  DestroyCurrentCache: ENTRY PROC =    BEGIN    aWhile: CONDITION;    Process.InitializeCondition[@aWhile, Process.SecondsToTicks[5]];    WHILE gf.processingHintCount > 0 DO WAIT aWhile; ENDLOOP;    gf.closeDomains ¬ IncrementalSort.nullHandle;    gf.orgTreeHead ¬ IncrementalSort.nullHandle;    gf.unavailableDomains ¬ IncrementalSort.nullHandle;    IF gf.myHeap # NIL THEN Heap.Delete[gf.myHeap];    -- next remake the heap    gf.closeCH ¬ System.nullNetworkAddress;    gf.myHeap ¬ Heap.Create[      initial: 2, increment: 6, ownerChecking: CHSwitches.doStubDebug,      checking: CHSwitches.doStubDebug AND gf.heapChecking];  -- no swap units    -- now get handles for new trees    gf.orgTreeHead ¬ IncrementalSort.MakeSorter[      FALSE, FALSE, TRUE, TRUE, gf.myHeap];    gf.closeDomains ¬ IncrementalSort.MakeSorter[      FALSE, FALSE, TRUE, TRUE, gf.myHeap];    gf.unavailableDomains ¬ IncrementalSort.MakeSorter[      FALSE, FALSE, FALSE, TRUE, gf.myHeap];    END;  --DestroyCurrentCache  FindDomainAddr: ENTRY PROC[name: CH.Name]    RETURNS[addr: System.NetworkAddress ¬ System.nullNetworkAddress] =    BEGIN    addressesForDomain: CHNameToAddrMapper.AddrList ¬ LONG[NIL];    domainTreeWanted: IncrementalSort.Handle;    IF gf.orgTreeHead # IncrementalSort.nullHandle      AND        (domainTreeWanted ¬ LOOPHOLE[IncrementalSort.FindElement[          gf.orgTreeHead, name, FALSE, TRUE, TRUE].userData]) #        IncrementalSort.nullHandle      AND        (addressesForDomain ¬ IncrementalSort.FindElement[          domainTreeWanted, name, TRUE, FALSE, TRUE].userData) # LONG[NIL] THEN      WHILE addressesForDomain # NIL DO	IF addressesForDomain.usable THEN RETURN[addressesForDomain.addr];	addressesForDomain ¬ addressesForDomain.next;	ENDLOOP;    END;  --FindDomainAddr  FlushCHName: PROC[    local: LONG STRING, out: Format.StringProc, listOnly: BOOLEAN] =    BEGIN    GetDefaultOrganization: PROCEDURE [s: LONG STRING] =      BEGIN      String.AppendChar[qualified, ':];      String.AppendString[qualified, s];      END;    separators: CARDINAL ¬ 0;    target: NSName.Name ¬ NIL;    addr: System.NetworkAddress;    qualified: LONG STRING = [NSName.maxFullNameLength];    Profile.Qualify[local, qualified, clearinghouse];    FOR i: CARDINAL IN [0..qualified.length) DO      IF (qualified[i] = ':) AND ((separators ¬ separators + 1) = 2) THEN EXIT;      REPEAT FINISHED => Profile.GetDefaultOrganization[GetDefaultOrganization];      ENDLOOP;    out[qualified];    target ¬ NSName.MakeName[z];    NSName.NameFieldsFromString[      z: z, destination: target, s: NSString.StringFromMesaString[qualified]];    addr ¬ FindDomainAddr[target];    out[".  Server was ("L]; Format.NetworkAddress[out, addr, octal]; out[")"L];    IF ~listOnly THEN      BEGIN      CHAddressCacheFriends.InvalidateAddr[addr];  --smash it      addr ¬ FindDomainAddr[target];  --find who supports now      out[", now ("L]; Format.NetworkAddress[out, addr, octal]; out[")"L];      END;    IF target # NIL THEN NSName.FreeName[z, target];    END;  --FlushCHName    Enter: Exec.ExecProc =    BEGIN    count: CARDINAL;    listOnly: BOOLEAN;    token, switch: LONG STRING ¬ NIL;    out: Format.StringProc = Exec.OutputProc[h];    FOR count ¬ 0, count ¬ count + 1 DO      [token, switch] ¬ Exec.GetToken[h];      listOnly ¬ SELECT TRUE FROM        (switch = NIL) => TRUE,	(switch[0] = 'L), (switch[0] = 'l) => TRUE,	(switch[0] = 'S), (switch[0] = 's) => FALSE,	ENDCASE => TRUE;      z.FREE[@switch];      SELECT TRUE FROM        (token = NIL) =>	  BEGIN	  IF count = 0 THEN out["Argument required... operation surpressed"L]; 	  EXIT;	  END;	(~listOnly AND (gf.processingHintCount > 0)) =>	  out["..ABORTED..stub still processing hints"L];        (String.EqualString[token, "ALL"L]) =>	  BEGIN	  IF listOnly THEN	    BEGIN	    out["Value of 'nearby clearinghouse' server is "L];	    Format.NetworkAddress[out, gf.closeCH, octal];	    END	  ELSE	    BEGIN	    out["Smashing 'nearby clearinghouse' server ...value was "L];	    Format.NetworkAddress[out, gf.closeCH, octal];	    DestroyCurrentCache[];	    out[", now is "L]; Format.NetworkAddress[out, gf.closeCH, octal];	    out[" ...WARNING - expect next CH lookup to fail"L];	    END;	  END;	ENDCASE =>	  BEGIN	  SELECT TRUE FROM	    (count # 0) => out[", "L];	    (listOnly) => out["Listing 'nearby domain' server for "L];	    ENDCASE => out["Smashing 'nearby domain' server for "L];	  FlushCHName[token, out, listOnly];	  END;      z.FREE[@token];      ENDLOOP;    out[" ...done"L];    END;  --Enter  Unload: Exec.ExecProc = {Exec.RemoveCommand[h, "CHSmash.~"L]};  Start: PROC =    BEGIN    IF Runtime.IsBound[LOOPHOLE[CH.EnumerateNearbyDomains]] THEN      BEGIN      gf ¬ LOOPHOLE[Runtime.GlobalFrame[LOOPHOLE[CH.EnumerateNearbyDomains]]];      Exec.AddCommand["SmashCHStub.~"L, Enter, Help, Unload];      END;    END;  Help: Exec.ExecProc =    BEGIN    out: Format.StringProc = Exec.OutputProc[h];    out["SmashCHStub.~ <arguments><switches> - may be used to attempt to convince the clearinghouse stub to bind to a different server.\n"L];    out["<arguments>\n"L];    out["	ALL - addresses the CHStub's concept of 'local clearinghouse'.\n"L];    out["	<chname> - addresses the binding supporting the domain indicated in the chname(s).\n"L];    out["<switches> - either '/list' or '/smash'.\n"l];    out["	/list causes the current argument to be listed without modification.\n"L];    out["	/smash lists the value specified argument, then smashes it and displays the new value."L];    END;  --Help       Start[];  --get it going  END...
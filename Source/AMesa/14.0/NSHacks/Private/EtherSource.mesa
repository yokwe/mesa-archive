-- File: EtherSource.mesa - last edit:-- AOF                 28-Jun-87 13:55:54-- Copyright (C) 1984, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [PrintError, Error, StringToNetworkAddress],  Buffer USING [AccessHandle, Buffer, DestroyPool, GetBuffer, MakePool,    ReturnBuffer],  ByteBlt USING [ByteBlt],  Driver USING [GetDeviceChain, Device],  IEEE8023 USING [Encapsulation, EncapObject],  Environment USING [Block, Byte, bytesPerWord],  EthernetDriverFriends USING [EtherStatsInfo, GetEthernetStats],  Format USING [HostNumber, StringProc],  FormSW USING [AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, line1, line2, line3, line4, line5, line6, line7, NumberItem,    ProcType, StringItem, TagOnlyItem],  Heap USING [systemZone],  Inline USING [LowHalf],  Process USING [Abort, Detach, Pause, priorityBackground, priorityNormal,    SetPriority, TicksToMsec, Yield],  Put USING [CR, Decimal, Line, LongDecimal, Text],  SpecialCommunication USING [SpyProc, SetSpyProc],  SpecialSystem USING [GetProcessorID, ProcessorID],  String USING [AppendString, CopyToNewString],  System USING [GetClockPulses, HostNumber, MicrosecondsToPulses,    PulsesToMicroseconds],  Tool USING [Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],   ToolWindow USING [TransitionProcType],  Window USING [Handle];EtherSource: PROGRAM  IMPORTS    AddressTranslation, Buffer, ByteBlt, SpecialCommunication,    Driver, EthernetDriverFriends, Format, FormSW, Heap, Inline, Process, Put,    SpecialSystem, String, System, Tool =  BEGIN  bpw: NATURAL = Environment.bytesPerWord;    Bytes: TYPE = LONG POINTER TO BytesRecord;  BytesRecord: TYPE = RECORD[    PACKED SEQUENCE COMPUTED INTEGER OF Environment.Byte];  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    dest(6): LONG STRING ¬ NIL,       --destination address    source(8): LONG STRING ¬ NIL,     --source address    type(10): CARDINAL ¬ 0,           --level 0 type    varyLen(11): BOOLEAN ¬ TRUE,      --vary data length    conLen(12): BOOLEAN ¬ FALSE,      --constant data length    lcon(13): CARDINAL ¬ 0,           --constant to use for length         varyCont(14): BOOLEAN ¬ TRUE,     --vary data content    conCont(15): BOOLEAN ¬ FALSE,     --constant data content    ccon(16): CARDINAL ¬ 0,           --constant to use for content    varyDel(17): BOOLEAN ¬ TRUE,      --vary interpacket delay    conDel(18): BOOLEAN ¬ FALSE,      --constant interpacket delay    dcon(19): CARDINAL ¬ 0,           --constant to use for interpacket delay    stats(20): BOOLEAN ¬ FALSE,       --display ethernet statistics    total(21): LONG CARDINAL ¬ 0];    --total to send or receive    data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  sourceRunning: BOOLEAN ¬ FALSE;  sinkRunning: BOOLEAN ¬ FALSE;  sourcer: PROCESS ¬ NIL;  sourceStart, sourceEnd: LONG CARDINAL ¬ 0;  --in pulses  sinkStart, sinkEnd: LONG CARDINAL ¬ 0;  --in pulses  z: UNCOUNTED ZONE ¬ Heap.systemZone;  me: SpecialSystem.ProcessorID ¬ SpecialSystem.GetProcessorID[];  myEar: SpecialSystem.ProcessorID ¬ SpecialSystem.GetProcessorID[];  him: System.HostNumber;  twoTicks: LONG CARDINAL ¬ System.MicrosecondsToPulses[    LONG[Process.TicksToMsec[2]]*LONG[1000]];  sourced, sunk, received: LONG CARDINAL ¬ 0;  oldStats: EthernetDriverFriends.EtherStatsInfo;      nmin: INTEGER ¬ 1;  --range of packets to be send [nmin..nmax)  nmax: INTEGER ¬ 1000;  ntmin: INTEGER ¬ 1;  --range of interpacket delay variance  ntmax: INTEGER ¬ 1000;  t0m: INTEGER ¬ 500;  --ranges of times (msec)  tminm: INTEGER ¬ 3;  tmaxm: INTEGER ¬ 1000;  --ranges of times (pulses)  t0: LONG INTEGER ¬ System.MicrosecondsToPulses[LONG[t0m]*LONG[1000]];  tmin: LONG INTEGER ¬ System.MicrosecondsToPulses[LONG[tminm]*LONG[1000]];  tmax: LONG INTEGER ¬ System.MicrosecondsToPulses[LONG[tmaxm]*LONG[1000]];    nlmin: INTEGER ¬ 1;  --range of packet length variance  nlmax: INTEGER ¬ 1000;  l0: INTEGER ¬ 128;  --ranges of lengths  lmin: INTEGER ¬ 30;  lmax: INTEGER ¬ 576;  ncmin: INTEGER ¬ 1;  --range of packet content variance  ncmax: INTEGER ¬ 1000;  c0: INTEGER ¬ 125;  --ranges of contents  cmin: INTEGER ¬ 0;  cmax: INTEGER ¬ 255;  LineProc: Format.StringProc = {Put.Line[data.fileSW, s]};  Source:  FormSW.ProcType =    BEGIN    ENABLE  AddressTranslation.Error =>      {AddressTranslation.PrintError[errorRecord, LineProc]; GOTO exit};    IF (data.dest = NIL) OR (data.source = NIL) THEN      BEGIN      Put.Line[data.fileSW, "Processor ID must be in form '.host.'"L];      GOTO exit;      END;    him ¬ AddressTranslation.StringToNetworkAddress[data.dest].addr.host;    myEar ¬      LOOPHOLE[AddressTranslation.StringToNetworkAddress[data.source].addr.host];    sourceRunning ¬ TRUE;    Put.Line[data.fileSW, "Sourcing..."L];    oldStats ¬ EthernetDriverFriends.GetEthernetStats[1];  --assume one driver.    Process.Detach[sourcer ¬ FORK Sourcer[]];    EXITS exit => NULL;    END;  --Source          SourceResults: PROC =    BEGIN    elapsed: LONG CARDINAL ¬ 0;    Put.Line[data.fileSW, "... source stopped"L];    Put.Text[data.fileSW, "Elapsed time = "L];    elapsed ¬ sourceEnd - sourceStart;    Put.LongDecimal[data.fileSW,      System.PulsesToMicroseconds[[elapsed]] / LONG[1000]];    Put.Text[data.fileSW, " ms, "L];    Put.LongDecimal[data.fileSW, sourced];    Put.Line[data.fileSW, " ether packets sent"L];    IF data.stats THEN Stats[];    END;  --SourceResults                 StopSource: FormSW.ProcType =    BEGIN    IF sourceRunning THEN      BEGIN      IF sourcer # NIL THEN        BEGIN        Process.Abort[sourcer];	sourcer ¬ NIL;	END;      SourceResults[];      END;  --sourceRunning    END;  --StopSource          StopSink: FormSW.ProcType =    BEGIN    elapsed: LONG CARDINAL ¬ 0;    IF sinkRunning THEN      BEGIN      [] ¬ SpecialCommunication.SetSpyProc[NIL, orphan];      Put.Line[data.fileSW, "... sink stopped"L];      sinkRunning ¬ FALSE;      sinkEnd ¬ System.GetClockPulses[];      Put.Text[data.fileSW, "Elapsed time = "L];      elapsed ¬ sinkEnd - sinkStart;      Put.LongDecimal[data.fileSW,        System.PulsesToMicroseconds[[elapsed]] / LONG[1000]];      Put.Text[data.fileSW, " ms, "L];      Put.LongDecimal[data.fileSW, sunk];      Put.Line[data.fileSW, " ether packets received"L];      END;  --sinkRunning    END;  --StopSink          Sink: FormSW.ProcType =    BEGIN    sinkRunning ¬ TRUE; sunk ¬ 0;    Put.Line[data.fileSW, "Sinking ..."L];    [] ¬ SpecialCommunication.SetSpyProc[PktIn, orphan];    sinkStart ¬ System.GetClockPulses[];    END;  --Sink          Stats: PROC =    BEGIN    newStats: EthernetDriverFriends.EtherStatsInfo ¬       EthernetDriverFriends.GetEthernetStats[1];    Put.Line[data.fileSW, "  Stats:"L];    Put.Text[data.fileSW, "    packetsRecv: "L];    Put.LongDecimal[data.fileSW, newStats.packetsRecv - oldStats.packetsRecv];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    wordsRecv: "L];    Put.LongDecimal[data.fileSW, newStats.wordsRecv - oldStats.wordsRecv];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    packetsMissed: "L];    Put.LongDecimal[data.fileSW, newStats.packetsMissed - oldStats.packetsMissed];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    badRecvStatus: "L];    Put.LongDecimal[data.fileSW, newStats.badRecvStatus - oldStats.badRecvStatus];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    okButDribble: "L];    Put.LongDecimal[data.fileSW, newStats.okButDribble - oldStats.okButDribble];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    badCrc: "L];    Put.LongDecimal[data.fileSW, newStats.badCrc - oldStats.badCrc];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    badAlignmentButOkCrc: "L];    Put.LongDecimal[data.fileSW, newStats.badAlignmentButOkCrc -      oldStats.badAlignmentButOkCrc];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    packetTooLong: "L];    Put.LongDecimal[data.fileSW, newStats.packetTooLong - oldStats.packetTooLong];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    overrun: "L];    Put.LongDecimal[data.fileSW, newStats.overrun - oldStats.overrun];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    idleInput: "L];    Put.LongDecimal[data.fileSW, newStats.idleInput - oldStats.idleInput];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    packetsSent: "L];    Put.LongDecimal[data.fileSW, newStats.packetsSent - oldStats.packetsSent];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    wordsSent: "L];    Put.LongDecimal[data.fileSW, newStats.wordsSent - oldStats.wordsSent];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    badSendStatus: "L];    Put.LongDecimal[data.fileSW, newStats.badSendStatus - oldStats.badSendStatus];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    tooManyCollisions: "L];    Put.LongDecimal[data.fileSW, newStats.tooManyCollisions -      oldStats.tooManyCollisions];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    underrun: "L];    Put.LongDecimal[data.fileSW, newStats.underrun - oldStats.underrun];    Put.CR[data.fileSW];    Put.Text[data.fileSW, "    stuckOutput: "L];    Put.LongDecimal[data.fileSW, newStats.stuckOutput - oldStats.stuckOutput];    Put.CR[data.fileSW];    FOR i: CARDINAL IN [0..16) DO      Put.Text[data.fileSW, "      "L];      Put.Decimal[data.fileSW, i];      Put.Text[data.fileSW, " collisions: "L];      Put.LongDecimal[data.fileSW, newStats.loadTable[i] - oldStats.loadTable[i]];      Put.CR[data.fileSW];      ENDLOOP;    END;  --Stats      PktIn: SpecialCommunication.SpyProc =    --called when packet isn't fielded by other families    {sunk ¬ sunk + 1; Buffer.ReturnBuffer[b]; RETURN[NIL]};  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ z.NEW[Data ¬ []];      new = inactive =>        IF data # NIL THEN z.FREE[@data];      ENDCASE;    END;  --ClientTransition  Init: PROCEDURE =    BEGIN    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialBox: [place: [x:350, y:250],      dims: [w:450, h:450]], initialState: default,      clientTransition: ClientTransition, name: "EtherSource"L,      cmSection: "EtherSource"];    END;  --Init  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: LONG STRING ¬ [25];    Tool.UnusedLogName[unused: logName, root: "EtherSource.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, h: 150];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;  --MakeSWs  MakeForm: FormSW.ClientItemsProcType =    BEGIN    OPEN FormSW;    host: LONG STRING ¬ [40];    stringProc: Format.StringProc = {String.AppendString[host, s]};    j: CARDINAL ¬ 0;    nItems: CARDINAL = 21;    items ¬ AllocateItemDescriptor[nItems];    Format.HostNumber[stringProc, LOOPHOLE[me], octal];    data.source ¬ String.CopyToNewString[s: host, z: z];    items[j ¬ 0] ¬ CommandItem[      tag: "Source"L, place: [18, line1], proc: Source];    items[j¬j+1] ¬ CommandItem[      tag: "Stop source"L, place: [70, line1], proc: StopSource];    items[j¬j+1] ¬ CommandItem[      tag: "Sink"L, place: [160, line1], proc: Sink];    items[j¬j+1] ¬ CommandItem[      tag: "Stop sink"L, place: [210, line1], proc: StopSink];    items[j¬j+1] ¬ NumberItem[      tag: "total"L, place: [300, line1], signed: FALSE, value: @data.total];    items[j¬j+1] ¬ BooleanItem[      tag: "Stats"L, place: [400, line1], switch: @data.stats];    items[j¬j+1] ¬ StringItem[      tag: "dest"L, place: [36, line2], inHeap: TRUE, string: @data.dest];    items[j¬j+1] ¬ StringItem[      tag: "source"L, place: [36, line3], inHeap: TRUE, string: @data.source];    items[j¬j+1] ¬ NumberItem[      tag: "type"L, place: [36, line4], signed: FALSE, value: @data.type];    items[j¬j+1] ¬ TagOnlyItem[      tag: "length:"L, place: [36, line5]];    items[j¬j+1] ¬ BooleanItem[      tag: "vary"L, place: [96, line5], switch: @data.varyLen];    items[j¬j+1] ¬ BooleanItem[      tag: "constant"L, place: [132, line5], switch: @data.conLen];    items[j¬j+1] ¬ NumberItem[      tag: " "L, place: [180, line5], signed: FALSE, value: @data.lcon];    items[j¬j+1] ¬ TagOnlyItem[      tag: "content:"L, place: [36, line6]];    items[j¬j+1] ¬ BooleanItem[      tag: "vary"L, place: [96, line6], switch: @data.varyCont];    items[j¬j+1] ¬ BooleanItem[      tag: "constant"L, place: [132, line6], switch: @data.conCont];    items[j¬j+1] ¬ NumberItem[      tag: " "L, place: [180, line6], signed: FALSE, value: @data.ccon];    items[j¬j+1] ¬ TagOnlyItem[      tag: "delay:"L, place: [36, line7]];    items[j¬j+1] ¬ BooleanItem[      tag: "vary"L, place: [96, line7], switch: @data.varyDel];    items[j¬j+1] ¬ BooleanItem[      tag: "constant"L, place: [132, line7], switch: @data.conDel];    items[j¬j+1] ¬ NumberItem[      tag: " "L, place: [180, line7], signed: FALSE, value: @data.dcon];    IF (j+1) # nItems THEN ERROR;  --for debugging    RETURN[items: items, freeDesc: TRUE];    END;  --MakeForm          Sourcer: PROC =    BEGIN    l: CARDINAL ¬ 0;    c: Environment.Byte;    b: Buffer.Buffer ¬ NIL;    delta, now, t, lastT: LONG CARDINAL ¬ 0;  --times    net: Driver.Device ¬ Driver.GetDeviceChain[];  --assume just one network.    pool: Buffer.AccessHandle ¬ Buffer.MakePool[send: 1, receive: 4];    BEGIN ENABLE ABORTED => GOTO exit;        Process.SetPriority[Process.priorityNormal];    sourceStart ¬ System.GetClockPulses[];    sourced ¬ 0;    DO      bytes: Bytes;      e: IEEE8023.Encapsulation;      b ¬ Buffer.GetBuffer[aH: pool, function: send, size: 1514];      e ¬ LOOPHOLE[b.linkLayer.blockPointer];      bytes ¬ LOOPHOLE[e + SIZE[IEEE8023.EncapObject]];      e.ethernetSource ¬ myEar;      e.ethernetDest ¬ LOOPHOLE[him];      e.ethernetType ¬ LOOPHOLE[data.type];      SELECT TRUE FROM  --data length        data.varyLen => l ¬ Length[Inline.LowHalf[sourced]];        data.conLen => l ¬ data.lcon;	ENDCASE => l ¬ lmax;      SELECT TRUE FROM  --data content        data.varyCont => c ¬ Content[Inline.LowHalf[sourced]];	data.conCont => c ¬ data.ccon;	ENDCASE => c ¬ cmax;      SELECT TRUE FROM  --interpacket delay        data.varyDel => t ¬ Delay[Inline.LowHalf[sourced]];	data.conDel => t ¬ System.MicrosecondsToPulses[data.dcon*LONG[1000]];	ENDCASE => t ¬ 0;      bytes[0] ¬ c;      [] ¬ ByteBlt.ByteBlt[[LOOPHOLE[bytes], 1, lmax], [LOOPHOLE[bytes], 0, l]];      b.fo.driver.length ¬ (SIZE[IEEE8023.EncapObject] * bpw) + l;      Process.SetPriority[Process.priorityBackground];      DO	now ¬ System.GetClockPulses[];	delta ¬ now - lastT;	SELECT TRUE FROM	  (lastT = 0) => EXIT;  --starting condition (or fluke)	  (delta > t) => EXIT;  --already waited too long	  (t - delta > twoTicks) => Process.Pause[1];  --longer time to wait	  ENDCASE => Process.Yield[];  --short time to wait (<100 msecs)	ENDLOOP;      net.sendRawBuffer[b];      b ¬ NIL;      lastT ¬ now;      Process.SetPriority[Process.priorityNormal];      sourced ¬ sourced + 1;      IF sourced = data.total THEN EXIT;  --if data.total = 0, do forever.      ENDLOOP;    EXITS exit => IF b # NIL THEN Buffer.ReturnBuffer[b];    END;  --enabled clause    sourceEnd ¬ System.GetClockPulses[];    Buffer.DestroyPool[pool];    sourceRunning ¬ FALSE;    SourceResults[];    END;  --Sourcer          Length: PROC [n: INTEGER] RETURNS [l: INTEGER] =    BEGIN    IF n ~IN[nlmin..nlmax] THEN RETURN[l0];    RETURN[lmax + INTEGER[LONG[(n - nmin)]*LONG[(lmin - lmax)]/(nmax - nmin)]];    END;  --Length          Content: PROC [n: INTEGER] RETURNS [c: Environment.Byte] =    BEGIN    IF n ~IN[ncmin..ncmax] THEN RETURN[c0];      RETURN[cmax + INTEGER[LONG[(n - nmin)]*LONG[(cmin - cmax)]/(nmax - nmin)]];    END;  --Content          Delay: PROC [n: INTEGER] RETURNS [t: LONG CARDINAL] =    BEGIN    t ¬ IF n ~IN[ntmin..ntmax] THEN t0      ELSE t ¬ tmax + (n - nmin)*(tmin - tmax)/(nmax - nmin);    END;  --Delay  -- Mainline code  Init[];  END...    
-- File: EXS.mesa - last edit:-- AOF                 22-May-88 15:39:31-- Copyright (C) 1983 , 1988 by Xerox Corporation. All rights reserved. -- File: EXS.mesa - last edit by: SMA 31-Aug-83 11:20:08DIRECTORY  ExtendedString USING [AppendNumber, StringToNumber],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, LineN,     ProcType, StringItem, NumberItem, DisplayItem],  Heap USING [systemZone],  Tool USING [Create, MakeFormSW, MakeSWsProc],  ToolWindow USING [TransitionProcType],  Window USING [Handle];  EXS: PROGRAM  IMPORTS ExtendedString, FormSW, Heap, Tool =  BEGIN    DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    formSW: Window.Handle,    bases: SEQUENCE index: CARDINAL OF BaseRecord];      BaseType: TYPE = CARDINAL[0..6);  BaseRecord: TYPE = RECORD [    base: CARDINAL ¬ 0, value: LONG STRING ¬ NIL];      tool: DataHandle ¬ NIL;  wh: Window.Handle; -- Tool's window    Convert: FormSW.ProcType =    BEGIN    base: CARDINAL;    value: LONG STRING;    field: ARRAY[0..6) OF WORD;    range: STRING = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"L;    index ¬ index/3;  --just to get into range    value ¬ tool.bases[index].value;    base ¬ tool.bases[index].base;    IF (base ~IN[2..36]) OR (value = NIL) THEN RETURN;    FOR vi: CARDINAL IN[0..value.length) DO      FOR bi: CARDINAL IN [0..base) DO        IF value[vi] = range[bi] THEN EXIT;	REPEAT FINISHED => RETURN;  --failed to find match	ENDLOOP;      ENDLOOP;    ExtendedString.StringToNumber[      @field, 6, tool.bases[index].base, tool.bases[index].value];    FOR other: CARDINAL IN BaseType DO      IF other = index OR tool.bases[other].base ~IN[2..36] THEN LOOP;      IF (tool.bases[other].value = NIL) OR        (tool.bases[other].value.maxlength < 80) THEN	BEGIN	Heap.systemZone.FREE[@tool.bases[other].value];        tool.bases[other].value ¬ Heap.systemZone.NEW[StringBody[80]];	END;      tool.bases[other].value.length ¬ 0;      ExtendedString.AppendNumber[        @field, 6, tool.bases[other].base, tool.bases[other].value];      FormSW.DisplayItem[sw, (other*3)+2];      ENDLOOP;    END;      ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>	IF tool = NIL THEN	  BEGIN	  tool ¬ Heap.systemZone.NEW[Data[LAST[BaseType] + 1]];	  tool.formSW ¬ NIL;	  FOR index: CARDINAL IN BaseType DO	    tool.bases[index] ¬ [];	    ENDLOOP;	  END;      new = inactive =>	IF tool # NIL THEN	  BEGIN	  FOR index: CARDINAL IN BaseType DO	    IF tool.bases[index].value # NIL THEN	      Heap.systemZone.FREE[@tool.bases[index].value];	    ENDLOOP;	  Heap.systemZone.FREE[@tool];	  END;      ENDCASE;    END;      Init: PROCEDURE =    BEGIN    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "EXS 10.0"L,      initialBox: [place: [x: 200, y: 200], dims: [w: 400, h: 140]]];    END;      MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    -- This procedure creates a sample FormSW.    nItems: CARDINAL = (LAST[BaseType]+1) * 3;    items ¬ AllocateItemDescriptor[nItems];    FOR index: CARDINAL IN BaseType DO      items[index*3] ¬ CommandItem[        tag: "Convert"L, place: [0, LineN[index]], proc: Convert];      items[index*3+1] ¬ NumberItem[tag: "Base: ", place: [54, LineN[index]],        drawBox: TRUE, signed: FALSE, notNegative: TRUE,        default: 0, value: @tool.bases[index].base];       items[index*3+2] ¬ StringItem[tag: "Value"L, place: [184, LineN[index]],        string: @tool.bases[index].value, inHeap: TRUE, drawBox: TRUE];      ENDLOOP;    RETURN[items: items, freeDesc: TRUE];    END;      MakeSWs: Tool.MakeSWsProc =    BEGIN    tool.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    END;      -- Mainline code    Init[]; -- this gets string out of global frame    END...  
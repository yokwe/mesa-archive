-- File: Convert.mesa - last edit:-- AOF                 29-Apr-88 15:35:59-- Copyright (C) 1983, 1985, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  AddressTranslation USING [Error, StringToNetworkAddress],  ExtendedString USING [AppendNumber, StringToNumber],  Exec,  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, LabelItem, line0, line1, line2, ProcType, StringItem],  Format USING [NetworkAddress, StringProc],  Heap USING [Create, Delete],  Put USING [CR, Line],  String USING [AppendChar, AppendDecimal, AppendString, StringBoundsFault],  System USING [HostNumber, NetworkAddress, NetworkNumber, SocketNumber],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Box, Handle];  Convert: PROGRAM  IMPORTS  AddressTranslation, Exec, ExtendedString, FormSW, Format,    Heap, Put, String, Tool =  BEGIN  maxBases: NATURAL = 4;    zone: UNCOUNTED ZONE = Heap.Create[5];  prod: CARDINAL ¬ 0;  -- the "base" for product format.    DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    inNum: NumRecord,    formSW, fileSW: Window.Handle,    displayFields: ARRAY [0..maxBases) OF DisplayRec ¬ [      [8, TRUE], [10, TRUE], [16, TRUE], [prod, TRUE]]];        DisplayRec: TYPE = RECORD [base: CARDINAL, show: BOOLEAN];     Number: TYPE = ARRAY[0..6) OF WORD;   NumRecord: TYPE = RECORD[    num: LONG POINTER TO Number, value: LONG STRING ¬ NIL];      wh: Window.Handle;  tool: DataHandle ¬ NIL;  line: LONG STRING ¬ [100];  stringProc: Format.StringProc = {String.AppendString[line, s]};  box: Window.Box = [place:[x:1332B, y:36B], dims:[w:446B, h:216B]];        Convert: FormSW.ProcType =    BEGIN     ENABLE      BEGIN      AddressTranslation.Error =>        BEGIN	Put.CR[tool.fileSW];        Put.Line[tool.fileSW, "Bad address!"L];	Put.CR[tool.fileSW];        GOTO exit;        END;      String.StringBoundsFault =>        BEGIN        Put.CR[tool.fileSW];        Put.Line[tool.fileSW, "Number too long!"L];	Put.CR[tool.fileSW];        GOTO exit;        END;      END;  -- enable clause.	    i, b: CARDINAL;    fieldPart: CARDINAL ¬ 0;    si: CARDINAL ¬ 0;  -- index into the string.    addr: BOOLEAN ¬ FALSE;  -- the number to be converted is a network address.        EndOfField: PROC[c: CHARACTER] RETURNS[BOOLEAN] =      {RETURN[(c = '#) OR (c = '.)]};          SubField: PROC[f: LONG POINTER] RETURNS[BOOLEAN ¬ FALSE] =      BEGIN      <<      Finds out the base of the number in input string, converts that      number and puts it in the field pointed to by <f>.  IF the number is      determined to be a network address (i.e. running into a '-, '#, or '.),      the <addr> boolean is set and returns to let AddressTranslation do all the      conversion work!      >>       c: CHARACTER;      sf: STRING ¬ [40];      base: CARDINAL ¬ 8;  --up to you to prove me wrong      UNTIL si = tool.inNum.value.length DO	c ¬ tool.inNum.value[si]; si ¬ si.SUCC;	SELECT c FROM	  IN['0..'7] =>	    {sf[sf.length] ¬ c; sf.length ¬ sf.length.SUCC};	  '8, '9 =>	    BEGIN	    base ¬ MAX[base, 10];	    sf[sf.length] ¬ c; sf.length ¬ sf.length.SUCC;	    END;	  'A, 'C, 'E, 'F =>	    BEGIN	    base ¬ 16;	    sf[sf.length] ¬ c; sf.length ¬ sf.length.SUCC;	    END;	  'B =>	    BEGIN	    IF (si = tool.inNum.value.length) OR EndOfField[c] THEN	      base ¬ MAX[base, 8]	    ELSE {sf[sf.length] ¬ c; sf.length ¬ sf.length.SUCC; base ¬ 16};	    END;	  'D =>	    BEGIN	    IF (si = tool.inNum.value.length) OR EndOfField[c] THEN 	      base ¬ MAX[base, 10]	    ELSE {sf[sf.length] ¬ c; sf.length ¬ sf.length.SUCC; base ¬ 16};	    END;	  'H => base ¬ 16;	  ENDCASE => RETURN[TRUE];  --must be CHS name        ENDLOOP;      IF sf.length # 0 THEN        ExtendedString.StringToNumber[f, 6, base, sf];      END;  --SubField            -- start of Convert.      IF (tool.inNum.value = NIL) OR (tool.inNum.value.length = 0) THEN	{Put.Line[tool.fileSW, "Please enter a number"L]; RETURN};      tool.inNum.num ¬ zone.NEW[Number];      IF SubField[tool.inNum.num] THEN  --AddressTranslation will do dirty work.        DisplayAddresses[	  AddressTranslation.StringToNetworkAddress[tool.inNum.value].addr]      ELSE  -- Vanilla long number.        BEGIN	-- Display in other bases.	Put.CR[tool.fileSW];	FOR i IN [0..maxBases) DO	  IF tool.displayFields[i].show THEN	    BEGIN  -- Convert and display.	    line.length ¬ 0;	    b ¬ tool.displayFields[i].base;	    DisplayBase[b];	    IF b = prod THEN              Format.NetworkAddress[	        stringProc, AddressTranslation.StringToNetworkAddress[		  tool.inNum.value].addr, productSoftware]	    ELSE ExtendedString.AppendNumber[tool.inNum.num, 6, b, line];	    SELECT b FROM	      16 => String.AppendChar[line, 'H];	      8 => String.AppendChar[line, 'B];	      ENDCASE;	    Put.Line[tool.fileSW, line]; 	    END;	  ENDLOOP;	END;      zone.FREE[@tool.inNum.num];    EXITS exit => zone.FREE[@tool.inNum.num];    END;  -- Convert       DisplayAddresses: PROC [a: System.NetworkAddress] =    BEGIN    -- Displays the address, returns TRUE if successful, else FALSE.    b: CARDINAL;    Put.CR[tool.fileSW];    FOR i: CARDINAL IN [0..maxBases) DO      line.length ¬ 0;      b ¬ tool.displayFields[i].base;      DisplayBase[b];      SELECT b FROM        8 => Format.NetworkAddress[stringProc, a, octal];	10 => 	  BEGIN	  ExtendedString.AppendNumber[	    @a.net, SIZE[System.NetworkNumber], 10, line];	  String.AppendChar[line, '.];	  ExtendedString.AppendNumber[@a.host, SIZE[System.HostNumber], 10, line];	  String.AppendChar[line, '.];	  ExtendedString.AppendNumber[	    @a.socket, SIZE[System.SocketNumber], 10, line];	  END;	16 => Format.NetworkAddress[stringProc, a, hex];	prod => Format.NetworkAddress[stringProc, a, productSoftware];	ENDCASE => ERROR;      Put.Line[tool.fileSW, line];      ENDLOOP;    END;  -- DisplayAddresses          DisplayBase: PROC [b: CARDINAL] =    BEGIN  -- Displays the base information for the line.    String.AppendString[line, "Base: "L];    IF b = prod THEN String.AppendString[line, "product"L]    ELSE String.AppendDecimal[line, b];    String.AppendString[line, ", "L];    END;   -- DisplayBase           ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive => IF tool = NIL THEN tool ¬ zone.NEW[Data];      new = inactive => IF tool # NIL THEN zone.FREE[@tool];      ENDCASE;    END;          Init: PROCEDURE =    BEGIN    Exec.AddCommand["Convert.~"L, NoOp, NIL, Unload];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: box,      clientTransition: ClientTransition, name: "Convert 11.0"L];    END;  NoOp: Exec.ExecProc = { };    Unload: Exec.ExecProc = {    Tool.Destroy[wh];    Exec.RemoveCommand[h, "Convert.~"L];    Heap.Delete[zone]};          MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    j: CARDINAL;    nItems: CARDINAL = 8;    items ¬ AllocateItemDescriptor[nItems, zone];    items[j¬0] ¬ CommandItem[tag: "Convert"L, place: [5, line0],      proc: Convert, z: zone];    items[j¬j+1] ¬ LabelItem[tag: "Output bases {"L, place: [5, line1],      readOnly: TRUE, z: zone];    items[j¬j+1] ¬ BooleanItem[tag: "8"L, place: [100, line1],      switch: @tool.displayFields[0].show, z: zone];    items[j¬j+1] ¬ BooleanItem[tag: "10"L, place: [120, line1],      switch: @tool.displayFields[1].show, z: zone];    items[j¬j+1] ¬ BooleanItem[tag: "16"L, place: [140, line1],      switch: @tool.displayFields[2].show, z: zone];    items[j¬j+1] ¬ BooleanItem[tag: "product"L, place: [160, line1],      switch: @tool.displayFields[3].show, z: zone];    items[j¬j+1] ¬ LabelItem[      tag: "}"L, place: [200, line1], readOnly: TRUE, z: zone];    items[j¬j+1] ¬ StringItem[tag: "Input number"L, place: [5, line2],      string: @tool.inNum.value, inHeap: TRUE, drawBox: TRUE, z: zone];    IF (j+1) # nItems THEN ERROR;     RETURN[items: items, freeDesc: TRUE];    END;      MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "Convert.log"L];    tool.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm, zone: zone];    tool.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;      -- Mainline code    Init[];    END...  
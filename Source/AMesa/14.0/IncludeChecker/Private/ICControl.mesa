-- ICControl.mesa - Last modified by--    BGY	17-Jan-83 16:45:49--    BWL	15-Nov-83 16:26:46--    KAM	11-Apr-85 14:07:52--    RLC        5-Feb-87 10:35:31 DIRECTORY  Ascii USING [NUL],  BcdDefs USING [VersionStamp],  CmFile USING [    Close, Error, FindSection, Handle, NextValue, TableError, UserDotCmOpen],  Environment USING [wordsPerPage],  Exec USING [    AddCommand, ExecProc, Handle, OutputProc, GetChar, Outcome,     CheckForAbort, RemoveCommand],  FileTransfer USING [CodeToString, Error],  Format USING [Blanks, Char, CR, Date, Decimal, Number, NumberFormat,     StringProc],  Heap USING [Create, Delete, Error],  ICDefs USING [    AbortType, badFiles, circular, Done, FinalizeFileReading, Go,    InitFileReading, KillToolWindow, nLocalBcds, nRemoteBcds, nFiles, nIncludes,    nLocalSources, nRemoteSources, olderIncludesFound, onlyLocalFiles,    ownTable, PrintData, ProcessData, ReadAllFiles, ReadClosureOfFiles,    ReadDFFile, ReadRequestedFile],  ICLists USING [    AnyMultVersionFiles, containType, depthType, dirType, fileType,    Finalize, hostType, incDescType, includeType, Initialize, markedType,    MatchIncludedFiles, Name, nameType, NTables, StringForName],  Inline USING [LowHalf],  LongAlloc USING [Bounds, Create, Destroy, Handle, TableInfo],  MFile USING [    Acquire, AppendErrorMessage, Delete, Error, GetProperties, Handle,    maxNameLength, Release, WriteOnly],  MSegment USING [Error, GetFile],  MStream USING [Error, GetFile],  Profile USING [debugging],  Runtime USING [CallDebugger, GetBcdTime],  String USING [    AppendChar, AppendString, CopyToNewString, Empty, EquivalentString,    FreeString, MakeString, StringBoundsFault],  StringLookUp USING [noMatch, TableDesc],  Time USING [Append, Current, defaultTime, Packed, Unpack],  Token USING [    Boolean, FilterProcType, FreeTokenString, Handle, Item, MaybeQuoted, NilData,    nonQuote, Object, QuoteProcType, SyntaxError, WhiteSpace],  UserInput USING [UserAbort],  Version USING [Append],  Volume USING [InsufficientSpace],  Window USING [Handle];  ICControl: PROGRAM    IMPORTS       CmFile, Exec, FileTransfer, Format, Heap, ICDefs, ICLists, Inline,      LongAlloc, MFile, MSegment, MStream, Profile, Runtime,      String, Time, Token, Version, UserInput, Volume    EXPORTS ICDefs =  BEGIN OPEN ICLists;    BadCommandLine: ERROR = CODE;  Bug: PUBLIC ERROR [problem: LONG STRING] = CODE;  ExitExec: SIGNAL = CODE;  -- Get out of Exec; just bring up tool window    exec: PUBLIC Exec.Handle _ NIL;  ownTable: PUBLIC LongAlloc.Handle _ NIL;    zone: PUBLIC UNCOUNTED ZONE _ NIL;  startTime: LONG CARDINAL;  icReadFileInitialized: BOOLEAN _ FALSE;    inExec: PUBLIC BOOLEAN _ FALSE;   ttySW: PUBLIC Window.Handle _ NIL;  doingDFFile: PUBLIC BOOLEAN _ FALSE;   globalHost, globalDir: PUBLIC LONG STRING _ NIL;  dfFile: PUBLIC LONG STRING _ NIL;  buffer: PUBLIC LONG STRING _ NIL;  ptr: PUBLIC CARDINAL _ 0;      -- processing switches   switches, switchDefaults: PUBLIC PACKED ARRAY CHARACTER ['a..'z] OF BOOLEAN _ [    TRUE,   -- a  All directly and indirectly included files on local disk             --      (not just one level)  (DEFAULT)      TRUE,   -- b  Include imports and Exports on binder bcd files (DEFAULT)     FALSE,  -- c  Command: Write rebuild command to Line.cm      FALSE,  -- d  Debugging mode      FALSE,  -- e      TRUE,   -- f  Fast: don't compute Contained-By relation if /i-o-c (DEFAULT)      FALSE,  -- g      FALSE,  -- h      TRUE,   -- i  Includes and Contained-By relations to <root>.list (DEFAULT)    FALSE,  -- j      TRUE,   -- k  Output Packager command in Line.cm (DEFAULT)     FALSE,  -- l  Limit size of .includes file      FALSE,  -- m  Multiple output files: <root>.includes and <root>.includedBy      FALSE,  -- n  Not bad if source but no Bcd found      TRUE,   -- o  Order: Print rebuild order to <root>.list (DEFAULT)      FALSE,  -- p  Pause: /P after includes level changes in <root>.cm     FALSE,  -- q      TRUE,   -- r  examine readonly (imported) files in DF file (DEFAULT)    FALSE,  -- s  "Star hack": same as /c-i-o       FALSE,  -- t  Tables to <root>.data     FALSE,  -- u      TRUE,   -- v  Verbose listing: ok files as well as error files (DEFAULT)      FALSE,  -- w      FALSE,  -- x  Don't run in Executive     FALSE,  -- y      FALSE]; -- z         -- Initialization and finalization   Abort: ICDefs.AbortType;  CheckAbort: PUBLIC ICDefs.AbortType = {RETURN[Abort[]]};    InitZone: PROC = {    zone _ Heap.Create[initial: 8, increment: 4, swapUnitSize: 4]};  Initialize: PROC = {    -- move tableInfo into local frame RLC  5-Feb-87 10:35:31    tableInfo: ARRAY [0..ICLists.NTables) OF LongAlloc.TableInfo _ [      [initialPages:  6, initialVMemPages: 12],  -- file entries        [initialPages:  6, initialVMemPages: 12],  -- included files      [initialPages:  3, initialVMemPages:  6],  -- descriptions of included files      [initialPages:  6, initialVMemPages: 12],  -- contained files      [initialPages:  2, initialVMemPages:  2],  -- hosts      [initialPages:  2, initialVMemPages:  2],  -- directories      [initialPages:  2, initialVMemPages:  2],  -- depth list chain heads      [initialPages:  2, initialVMemPages:  2],  -- marked files      [initialPages:  4, initialVMemPages: 8]]; -- names       startTime _ Time.Current[];    PutHeading[];    ownTable _ LongAlloc.Create[weights: DESCRIPTOR[tableInfo]];    globalHost _ String.CopyToNewString["ME"L, zone];  globalDir _ NIL;    dfFile _ NIL;  doingDFFile _ FALSE;    GetOutputNameAndSwitches[];    AttemptToOpenFiles[];    ICLists.Initialize[];    icReadFileInitialized _ FALSE;    ICDefs.nFiles _ 0;    ICDefs.nLocalSources _ ICDefs.nRemoteSources _ 0;    ICDefs.nLocalBcds _ ICDefs.nRemoteBcds _ 0;    ICDefs.onlyLocalFiles _ TRUE};    PutHeading: PROC = {    OPEN String;    herald: STRING _ [60];    PutCR[];    AppendString[herald, "Mesa IncludeChecker "L];  Version.Append[herald];    AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    PutLine[herald];    herald.length _ 0;    AppendString[herald, "  "L];    Time.Append[herald, Time.Unpack[Time.defaultTime]];    herald.length _ herald.length-3;    PutLine[herald];    PutCR[]};      Finalize: PROC = {    IF icReadFileInitialized THEN ICDefs.FinalizeFileReading[];    ICLists.Finalize[];    FreeFileNames[];    IF ownTable # NIL THEN {LongAlloc.Destroy[ownTable];  ownTable _ NIL};    IF zone # NIL THEN {Heap.Delete[zone];  zone _ NIL}};       -- command line (and tool parameter) parsing   initialLength: CARDINAL = 120;   -- initial length for buffer  lengthIncrement: CARDINAL = 120; -- additional characters to allocate  GetBuffer: PROC [h: Exec.Handle] = {    ch: CHARACTER;    ptr _ 0;    buffer _ String.MakeString[zone, initialLength];    ch _ Exec.GetChar[h];    DO      IF ch = Ascii.NUL THEN EXIT;        String.AppendChar[buffer, ch        ! String.StringBoundsFault => {	    ns _ String.MakeString[zone, (s.maxlength + lengthIncrement)];	    String.AppendString[to: ns, from: s];	    String.FreeString[zone, s];	    RESUME[buffer _ ns]}];      ch _ Exec.GetChar[h];      ENDLOOP};      name, sw: LONG STRING _ NIL;      GetNextToken: PROC RETURNS [name, sw: LONG STRING] = {    GetChar: PROC [Token.Handle] RETURNS [c: CHARACTER] = {      IF ptr >= buffer.length THEN c _ Ascii.NUL      ELSE {c _ buffer[ptr];  ptr _ ptr+1}};    IsQuote: Token.QuoteProcType = {RETURN[IF c = '" THEN c ELSE Token.nonQuote]};    NameOrSwitch: Token.FilterProcType = {       RETURN[inClass:         SELECT TRUE FROM          Token.WhiteSpace[c, NIL], (c = Ascii.NUL) => FALSE,          (c = '/) => FALSE,          ENDCASE  => TRUE]};    getToken: Token.Object _ [getChar: GetChar, break: Ascii.NUL];    name _ Token.MaybeQuoted[@getToken, NIL, NameOrSwitch, IsQuote];    sw _ (      IF getToken.break # '/ THEN NIL      ELSE Token.MaybeQuoted[@getToken, NIL, NameOrSwitch, IsQuote])};   FreeToken: PROC = {    IF name # NIL THEN name _ Token.FreeTokenString[name];    IF sw   # NIL THEN sw _ Token.FreeTokenString[sw]};         -- Exec window output   putProc: Format.StringProc;  Put: PUBLIC PROC [s: LONG STRING] = {putProc[s]};  PutCR: PUBLIC PROC = {Format.CR[putProc]};  PutLine: PUBLIC PROC [s: LONG STRING] = {putProc[s];  Format.CR[putProc]};  PutChar: PUBLIC PROC [c: CHARACTER] = {Format.Char[putProc, c]};  PutDecimal: PUBLIC PROC [n: INTEGER] = {Format.Decimal[putProc, n]};     -- IncludeChecker log  Log: PUBLIC Format.StringProc = {IF s # NIL THEN {putProc[s]}};  LogCR: PUBLIC PROC = {Format.CR[Log]};  LogLine: PUBLIC PROC [s: LONG STRING] = {Log[s];  LogCR[]};  LogChar: PUBLIC PROC [c: CHARACTER] = {Format.Char[Log, c]};  LogSP: PUBLIC PROC = {Format.Char[Log, ' ]};  LogBlanks: PUBLIC PROC [n: INTEGER] = {Format.Blanks[Log, n]};  LogDecimal: PUBLIC PROC [n: INTEGER] = {Format.Decimal[Log, n]};  LogNumber: PUBLIC PROC [n: UNSPECIFIED, f: Format.NumberFormat] = {    Format.Number[Log, n, f]};  LogDate: PUBLIC PROC [t: Time.Packed] = {Format.Date[Log, t, full]};  LogName: PUBLIC PROC [name: ICLists.Name] = {Log[ICLists.StringForName[name]]};    LogPaddedName: PUBLIC PROC [name: ICLists.Name, width: CARDINAL] = {    s: LONG STRING = ICLists.StringForName[name];    IF width > s.length THEN {Log[s];  LogBlanks[width - s.length]}    ELSE {Log[s];  LogSP[]}};    LogVersion: PUBLIC PROC [v: BcdDefs.VersionStamp] = {    s: STRING _ [20];    octal: Format.NumberFormat  = [8, FALSE, FALSE, 1];    Time.Append[s, Time.Unpack[LOOPHOLE[v.time, Time.Packed]]];    IF s[0] = '  THEN FOR i: CARDINAL IN [1..s.length) DO LogChar[s[i]] ENDLOOP    ELSE Log[s];    LogChar[' ];    LogNumber[v.net, octal];  LogChar['#];    LogNumber[v.host, octal]; LogChar['#]};       -- Command processing   rootName: PUBLIC LONG STRING _ NIL;  listName: PUBLIC LONG STRING _ NIL;     -- Includes/Contained-By relations file  commandName: PUBLIC LONG STRING _ NIL;  -- rebuild command line file  tableName: PUBLIC LONG STRING _ NIL;    -- Table file   useRootForCommandName: BOOLEAN _ FALSE;    ProcessUserCmSection: PROC = {    Option: TYPE = MACHINE DEPENDENT{      defaultSwitches(0), commandNameFromRoot(1), noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = Option [defaultSwitches..commandNameFromRoot];    optionTable: ARRAY DefinedOption OF LONG STRING _ [      defaultSwitches: "DefaultSwitches"L,      commandNameFromRoot: "CommandNameFromRoot"L];    userCm: CmFile.Handle;    CheckType: PROC [        h: CmFile.Handle, table: StringLookUp.TableDesc]      RETURNS [index: CARDINAL] = CmFile.NextValue;    MyNextValue: PROC [        h: CmFile.Handle,        table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]      RETURNS [index: Option] = LOOPHOLE[CheckType];    userCm _ CmFile.UserDotCmOpen[ ! CmFile.Error => GOTO NoUserDotCm];    BEGIN ENABLE ExitExec => [] _ CmFile.Close[userCm];    IF CmFile.FindSection[userCm, "IncludeChecker"L] THEN {      DO        SELECT MyNextValue[userCm, DESCRIPTOR[optionTable]	    ! CmFile.TableError => RESUME] FROM          noMatch => EXIT;          defaultSwitches => {	    temp: LONG STRING _ Token.Item[userCm	      ! Token.NilData, Token.SyntaxError => GOTO TokenError];            SetProcessingSwitches[temp ! ExitExec => temp _ Token.FreeTokenString[temp]];            temp _ Token.FreeTokenString[temp]};          commandNameFromRoot => 	    useRootForCommandName _ Token.Boolean[userCm	      ! Token.NilData, Token.SyntaxError => GOTO TokenError];          ENDCASE;        ENDLOOP};    END; -- ENABLE ExitExec    [] _ CmFile.Close[userCm];    EXITS      NoUserDotCm => NULL;      TokenError => NULL};        GetOutputNameAndSwitches: PROC = {    [name, sw] _ GetNextToken[];    SetRootName[name];  SetProcessingSwitches[sw ! ExitExec => FreeToken[]];  SetFileNames[];    DeleteOldFiles[];    FreeToken[]};      AttemptToOpenFiles: PROC = {    file: MFile.Handle _ NIL;    IF ~String.Empty[listName] THEN {      file _ MFile.WriteOnly[name: listName, release: [], type: text];      IF file # NIL THEN {MFile.Release[file];  file _ NIL}};    IF ~String.Empty[tableName] THEN {      file _ MFile.WriteOnly[name: tableName, release: [], type: text];      IF file # NIL THEN {MFile.Release[file];  file _ NIL}}};      SetRootName: PROC [name: LONG STRING] = {    OPEN String;    rootName _ String.MakeString[zone, MFile.maxNameLength];    IF String.Empty[name] THEN AppendString[rootName, "IncludeChecker"L]    ELSE {      FOR i: CARDINAL IN [0..name.length) DO       IF name[i] = '. THEN RETURN;        AppendChar[rootName, name[i]];       ENDLOOP}};      SetProcessingSwitches: PROC [sw: LONG STRING] = {    sense: BOOLEAN _ TRUE;    IF String.Empty[sw] THEN RETURN;    FOR i: CARDINAL IN [0..sw.length) DO      c: CHARACTER _ sw[i];      IF c IN ['A..'Z] THEN c _ c + ('a - 'A);      SELECT c FROM	'-, '~ => sense _ FALSE;	IN ['a..'z] => {	  IF c = 's THEN {  -- crufty Star hack: same as /c-i-o	    switches['c] _ sense;	    switches['i] _ switches['o] _ ~sense}	  ELSE switches[c] _ sense;	  sense _ TRUE};	'! => {Runtime.CallDebugger["Called from IncludeChecker"L]; sense _ TRUE};	ENDCASE;      ENDLOOP;    IF switches['x] THEN SIGNAL ExitExec[]}; -- Don't Run in Exec	      SetFileNames: PROC = {    OPEN String;    IF switches['i] OR switches['o] THEN {      IF switches['m] THEN listName _ NIL      ELSE {        listName _ String.MakeString[zone, rootName.length + 5];        AppendString[listName, rootName];  AppendString[listName, ".list"L]}};    IF switches['c] THEN {      IF useRootForCommandName THEN {        commandName _ String.MakeString[zone, rootName.length + 3];	AppendString[commandName, rootName];  AppendString[commandName, ".cm"L]}      ELSE {        commandName _ String.MakeString[zone, 7];        AppendString[commandName, "Line.cm"L]}};    IF switches['t] THEN {      tableName _ String.MakeString[zone, rootName.length + 5];      AppendString[tableName, rootName];  AppendString[tableName, ".data"L]}};	      DeleteOldFiles: PROC = {      DeleteOldFile: PROC [name: LONG STRING] = {      old: MFile.Handle _ NIL;      old _ MFile.Acquire[name: name, access: delete, release: []        ! MFile.Error => CONTINUE];      IF old # NIL THEN MFile.Delete[old ! MFile.Error => CONTINUE]};          IF (switches['i] OR switches['o]) AND ~switches['m] THEN      DeleteOldFile[listName];    IF switches['c] THEN DeleteOldFile[commandName];    IF switches['t] THEN DeleteOldFile[tableName]};            EchoFileNames: PROC = {    SELECT TRUE FROM      switches['i] OR switches['o] => {        IF switches['m] THEN {	  Put["Listings to "L];	  Put[rootName];  Put[".includes and "L];	  Put[rootName];  Put[".includedBy"L]}	ELSE {Put["Listing to "L];  Put[listName]};	IF switches['c] THEN {Put[", command to "L];  Put[commandName]};	IF switches['t] THEN {Put[", tables to "L];  Put[tableName]}};      switches['c] => {        Put["Command to "L];  Put[commandName];	IF switches['t] THEN {Put[", tables to "L];  Put[tableName]}};      switches['t] => {Put["Tables to "L];  Put[tableName]};      ENDCASE;    PutCR[]};      FreeFileNames: PROC = {    IF rootName # NIL THEN zone.FREE[@rootName];    IF listName # NIL THEN zone.FREE[@listName];    IF commandName # NIL THEN zone.FREE[@commandName];    IF tableName # NIL THEN zone.FREE[@tableName]};           -- File Processing    CheckFiles: Exec.ExecProc = {    ENABLE {      BadCommandLine => GOTO badCommandLine;       ABORTED => GOTO aborted;      ExitExec => GOTO leaveExec;      MFile.Error =>         IF switches['d] THEN REJECT  -- goto CoPilot	ELSE {          msg: STRING _ [100];	  MFile.AppendErrorMessage[msg, code, file];	  Put["MFile error: "L];  PutLine[msg];	  GOTO filesystemProblem};      MStream.Error =>         IF switches['d] THEN REJECT  -- goto CoPilot	ELSE {	  name: LONG STRING _ [MFile.maxNameLength];          SELECT TRUE FROM	    (stream = NIL) => name _ "unknown"L;	    (code = invalidHandle) => name _ "unknown"L;	    ENDCASE => [] _ MFile.GetProperties[MStream.GetFile[stream], name];	  Put["Error accessing stream on file "L];  Put[name];	  SELECT code FROM	    invalidHandle    => Put[": invalidHandle"L];	    indexOutOfRange  => Put[": indexOutOfRange"L];	    invalidOperation => Put[": invalidOperation"L];	    fileTooLong      => Put[": fileTooLong"L];	    fileNotAvailable => Put[": fileNotAvailable"L];	    other            => Put[": other"L];	    ENDCASE          => Put[": (unknown MStream.Error)"L];	  PutCR[];   	  GOTO filesystemProblem};      MSegment.Error =>         IF switches['d] THEN REJECT  -- goto CoPilot	ELSE {	  name: LONG STRING _ [MFile.maxNameLength];          SELECT TRUE FROM	    (segment = NIL) => name _ "unknown"L;	    (code = noSuchSegment) => name _ "unknown"L;	    ENDCASE => [] _ MFile.GetProperties[MSegment.GetFile[segment], name];	  Put["Error accessing segment on file "L];  Put[name];	  SELECT code FROM	    zeroLength         => Put[": zeroLength"L];	    insufficientVM     => Put[": insufficientVM"L];	    noSuchSegment      => Put[": noSuchSegment"L];	    sharedSegment      => Put[": sharedSegment"L];	    baseOutOfRange     => Put[": baseOutOfRange"L];	    conflictingAccess  => Put[": conflictingAccess"L];	    illegalAccess      => Put[": illegalAccess"L];	    other              => Put[": other"L];	    ENDCASE            => Put[": (unknown MSegment.Error)"L];	  PutCR[];   	  GOTO filesystemProblem};      FileTransfer.Error =>         IF code = retry THEN RETRY	ELSE IF switches['d] THEN REJECT	ELSE {	  msg: STRING _ [60];	  FileTransfer.CodeToString[code, msg];	  Put["...FileTransfer error: "L];  PutLine[msg];	  GOTO fileTransferProblem};      Volume.InsufficientSpace =>         IF switches['d] THEN REJECT  -- goto CoPilot	ELSE {	  PutCR[];  PutLine["...Volume full"L];	  GOTO fullVolume};      Heap.Error =>         IF switches['d] THEN REJECT  -- goto CoPilot	ELSE {          PutCR[];  Put["...Heap error: "L];	  SELECT type FROM	    insufficientSpace => Put["insufficientSpace"L];	    invalidHeap       => Put["invalidHeap"L];	    invalidNode       => Put["invalidNode"L];	    invalidZone       => Put["invalidZone"L];	    invalidOwner      => Put["invalidOwner"L];	    invalidSize       => Put["invalidSize"L];	    otherError        => Put["otherError"L];	    ENDCASE           => Put["(other Heap.Error)"L];          PutCR[];	  GOTO heapError};      Bug =>         IF switches['d] THEN REJECT  -- goto CoPilot	ELSE {          PutCR[];  Put["...IncludeChecker problem:"L];  PutLine[problem];	  GOTO bug}};    exec _ h;    EchoFileNames[];    PutLine["Reading files..."L];  Put["  "L];  ProcessCommandLine[];    IF icReadFileInitialized THEN ICDefs.FinalizeFileReading[];    PutCR[];    Put["Processing data..."L];  ICDefs.ProcessData[];    IF switches['i] OR switches['o] OR switches['c] THEN {       Put["Writing output..."L];  ICDefs.PrintData[]};    PutCR[];  PutCR[];    PutSummary[];    IF ICDefs.circular THEN outcome _ warning ELSE outcome _ normal;    EXITS      aborted => {        outcome _ abort;         PutCR[];  PutLine["...IncludeChecker aborted"L];	IF ~inExec THEN ERROR ABORTED};        badCommandLine => {        outcome _ error;         PutCR[];  PutLine["...aborted"L]};      leaveExec => {        outcome _ normal;	PutCR[]; PutLine["...IncludeChecker tool loaded"L]};      filesystemProblem, fileTransferProblem, fullVolume, bug, heapError => {        outcome _ error}};	  ProcessCommandLine: PROC = {    fileRequested: BOOLEAN _ FALSE;    [name, sw] _ GetNextToken[];    WHILE ~String.Empty[name] DO      IF ~String.Empty[sw] THEN ProcessCommand[]       ELSE {        fileRequested _ TRUE;	IF ~icReadFileInitialized THEN {	  ICDefs.InitFileReading[];  icReadFileInitialized _ TRUE}; 	ICDefs.ReadRequestedFile[name]};      FreeToken[];      [name, sw] _ GetNextToken[]      ENDLOOP;    FreeToken[];    SELECT TRUE FROM      doingDFFile =>             -- no files (should have been) read above        IF fileRequested THEN {          PutCR[];  PutLine["Can't check DF files along with other files"L]}        ELSE {	  ICDefs.ReadDFFile[];	  ICLists.MatchIncludedFiles[]};      ~fileRequested => {        -- no files were requested; process all files        IF ~icReadFileInitialized THEN {	  ICDefs.InitFileReading[];  icReadFileInitialized _ TRUE};        ICDefs.ReadAllFiles[];	ICLists.MatchIncludedFiles[]};      ICDefs.onlyLocalFiles => { -- just local files have been read; do closure        ICLists.MatchIncludedFiles[];	ICDefs.ReadClosureOfFiles[]};      ENDCASE =>	         -- all or some remote files have been read        ICLists.MatchIncludedFiles[]};      MakeRoot: PROC = {    i: CARDINAL _ 0;    WHILE i < name.length AND name[i] # '. DO i _ i+1 ENDLOOP;    IF i < name.length THEN name.length _ i};      ProcessCommand: PROC = {    c: CHARACTER = sw[0];    IF c # 'c AND c # 'C THEN {      PutCR[];  Put["Unrecognized switch "L];  PutChar[c];  PutCR[];      FreeToken[];      ERROR BadCommandLine};    SELECT TRUE FROM      String.EquivalentString[name, "cf"L],      String.EquivalentString[name, "commandfile"L] => {        file: MFile.Handle _ NIL;        FreeToken[];        [name, sw] _ GetNextToken[];        IF String.Empty[name] THEN {          PutCR[];  PutLine["No command file name given"L];          FreeToken[];          ERROR BadCommandLine};        IF commandName # NIL THEN zone.FREE[@commandName];	MakeRoot[];	commandName _ String.MakeString[zone, name.length + 3];	String.AppendString[commandName, name];  	String.AppendString[commandName, ".cm"L];	file _ MFile.WriteOnly[  -- try opening command file	  name: commandName, release: [], type: text];        IF file # NIL THEN MFile.Release[file]};	      String.EquivalentString[name, "op"L],       String.EquivalentString[name, "open"L] => {        FreeToken[];        [name, sw] _ GetNextToken[];        IF String.Empty[name] THEN {          PutCR[];  PutLine["No host name given"L];          FreeToken[];          ERROR BadCommandLine};        String.FreeString[zone, globalHost];        globalHost _ String.CopyToNewString[name, zone];        String.FreeString[zone, globalDir];  globalDir _ NIL};	      String.EquivalentString[name, "dir"L],      String.EquivalentString[name, "directory"L] => {        FreeToken[];        [name, sw] _ GetNextToken[];        IF String.Empty[name] THEN {          PutCR[];  PutLine["No directory name given"L];          FreeToken[];          ERROR BadCommandLine};        IF name[name.length-1] = '> THEN name.length _ name.length-1;        String.FreeString[zone, globalDir];        globalDir _ String.CopyToNewString[name, zone]};	      String.EquivalentString[name, "df"L],      String.EquivalentString[name, "dffile"L] => {        FreeToken[];        [name, sw] _ GetNextToken[];        IF String.Empty[name] THEN {          PutCR[];  PutLine["No DF file name given"L];          FreeToken[];          ERROR BadCommandLine};        IF name[name.length-1] = '> THEN name.length _ name.length-1;        String.FreeString[zone, dfFile];        dfFile _ String.CopyToNewString[name, zone];	doingDFFile _ TRUE};		      ENDCASE => {        PutCR[];  Put["Unrecognized command "L];  PutLine[name];	FreeToken[];        ERROR BadCommandLine}};      PutSummary: PROC = {    elapsedTime: CARDINAL = Inline.LowHalf[Time.Current[] - startTime];    IF switches['c] THEN {      IF ICLists.AnyMultVersionFiles[] OR ICDefs.circular      OR ICDefs.olderIncludesFound THEN {        Log["Check "L];  Log[commandName];  LogLine[" carefully:"L];        IF ICLists.AnyMultVersionFiles[] THEN          LogLine["\tFiles were found in multiple versions"L];        IF ICDefs.circular THEN          LogLine["\tCircular file dependencies were found"L];        IF ICDefs.olderIncludesFound THEN          LogLine["\tOlder versions of included files were found"L]}};    IF ICDefs.badFiles THEN PutLine["Inconsistencies found."L]    ELSE PutLine["The files seem consistent."L];     PutDecimal[ICDefs.nLocalBcds];     Put[" local, "L];    PutDecimal[ICDefs.nRemoteBcds];    Put[" remote Bcds.   "L];     PutDecimal[ICDefs.nLocalSources];  Put[" local, "L];    PutDecimal[ICDefs.nRemoteSources]; Put[" remote sources.   "L];      PutDecimal[ICDefs.nIncludes];      PutLine[" included files."L];     PutDecimal[GetTablePages[]];       Put[" table pages, "L];    PutDecimal[elapsedTime];           PutLine[" seconds."L]};      GetTablePages: PROC RETURNS [nPages: CARDINAL] = {    icTable: LongAlloc.Handle = ICDefs.ownTable;    d: LONG CARDINAL _ 0;    d _ (d + icTable.Bounds[ICLists.fileType].size);    d _ (d + icTable.Bounds[ICLists.includeType].size);    d _ (d + icTable.Bounds[ICLists.incDescType].size);    d _ (d + icTable.Bounds[ICLists.containType].size);    d _ (d + icTable.Bounds[ICLists.hostType].size);    d _ (d + icTable.Bounds[ICLists.dirType].size);    d _ (d + icTable.Bounds[ICLists.depthType].size);    d _ (d + icTable.Bounds[ICLists.markedType].size);    d _ (d + icTable.Bounds[ICLists.nameType].size);    nPages _ Inline.LowHalf[      (d + Environment.wordsPerPage-1)/Environment.wordsPerPage]};	 ToolInterface: PUBLIC PROC [       OutProc: Format.StringProc, buf: LONG STRING,       w, icTTYSW: Window.Handle]      RETURNS [outcome: Exec.Outcome]= {   BEGIN ENABLE UNWIND => Finalize[];   abort: ICDefs.AbortType = {RETURN[UserInput.UserAbort[w]]};   inExec _ FALSE;  exec _ NIL;  ttySW _ icTTYSW;   putProc _ OutProc;  Abort _ abort;   InitZone[];   buffer _ buf;  ptr _ 0;   switches _ switchDefaults;   useRootForCommandName _ FALSE;   Initialize[];   outcome _ CheckFiles[NIL];   Finalize[];   END};    CheckFilesFromExec: Exec.ExecProc = {   out: Exec.Outcome;   ExecAbortProc: ICDefs.AbortType = {RETURN[Exec.CheckForAbort[exec]]};   BEGIN ENABLE {     ExitExec => GOTO quit;     UNWIND => GOTO quit};   IF ~ICDefs.Go[] THEN {     Exec.OutputProc[h]["IncludeChecker already busy."L];      RETURN};   inExec _ TRUE;  exec _ h;  ttySW _ NIL;       putProc _ Exec.OutputProc[exec];  Abort _ ExecAbortProc;   InitZone[];   GetBuffer[exec];  -- and copy exec command line into it   switches _ switchDefaults;   IF Profile.debugging THEN switches['d] _ TRUE;   useRootForCommandName _ FALSE;   ProcessUserCmSection[];   Initialize[];   out _ CheckFiles[exec];   IF buffer # NIL THEN String.FreeString[zone, buffer];   buffer _ NIL;   Finalize[];   ICDefs.Done[];   EXITS quit => {     IF buffer # NIL THEN String.FreeString[zone, buffer];     buffer _ NIL;     Finalize[];     ICDefs.Done[]};   END};         -- MAIN BODY CODE    RegisterSelf: PROC = {    Exec.AddCommand[      name: "IncludeChecker.~"L, proc: CheckFilesFromExec,      unload: DestroyWindow]};        DestroyWindow: Exec.ExecProc = {    ICDefs.KillToolWindow[];    h.RemoveCommand["IncludeChecker.~"L]};    RegisterSelf[];    END.
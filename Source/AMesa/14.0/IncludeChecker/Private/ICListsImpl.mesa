-- ICListsImpl.mesa  -- Last edited by BTL   on 24-Mar-83 16:49:33DIRECTORY  BcdDefs USING [NullVersion, VersionStamp],  GSort USING [CompareProcType, GetProcType, PutProcType, Sort],  ICDefs USING [Bug, ownTable, zone],  ICLists USING [    Base, CFNil, ContainingFile, ContainingFileObject, containType, DepthIndex,    DepthObject, depthType, DirName, DirNameObject, dirType, DNNil, File,    FileObject, fileType, FNil, Hash, HNNil, HostName, HostNameObject,    hostType, HVSize, IFDNil, IFNil, incDescType, IncFileDesc, IncFileDescObject,    IncludedFile, IncludedFileObject, includeType, Loc, markedType,    MFObject, MLBNil, MLSNil, MultLocBcd, MultLocSource, MultVersionBcd,    MultVersionSource, MVBNil, MVSNil, Name, NameNil, NameObject, nameType,    NullLoc, NullTime, VersionStamp],  Inline USING [BITAND, BITXOR],  LongAlloc USING [    AddNotify, Base, DropNotify, Handle, Notifier, Overflow, Top, Words],  MFile USING [maxNameLength],  String USING [    AppendString, AppendSubString, CompareStrings, Empty, EquivalentSubString,    SubString, SubStringDescriptor, WordsForString],  Time USING [Packed];  ICListsImpl: PROGRAM    IMPORTS GSort, ICDefs, Inline, LongAlloc, String    EXPORTS ICLists, ICDefs =  BEGIN OPEN String, ICLists;    icZone: UNCOUNTED ZONE _ NIL;   -- local copies of ICDefs variables   icTable: LongAlloc.Handle _ NIL;   feb: LongAlloc.Base;  -- file records  ifb: LongAlloc.Base;  -- included files  idb: LongAlloc.Base;  -- descriptions of included files   cfb: LongAlloc.Base;  -- contained files  hb:  LongAlloc.Base;  -- hosts  db:  LongAlloc.Base;  -- directories  dib: LongAlloc.Base;  -- depth list chain heads  mb:  LongAlloc.Base;  -- marked files  nb:  LongAlloc.Base;  -- names  UpdateBases: LongAlloc.Notifier = {    feb _ base[ICLists.fileType];      ifb _ base[ICLists.includeType];    idb _ base[ICLists.incDescType];    cfb _ base[ICLists.containType];    hb  _ base[ICLists.hostType];    db  _ base[ICLists.dirType];    dib _ base[ICLists.depthType];    mb  _ base[ICLists.markedType];    nb  _ base[ICLists.nameType]};          -- Initialization and finalization    Initialize: PUBLIC PROC = {    icZone _ ICDefs.zone;    icTable _ ICDefs.ownTable;    icTable.AddNotify[UpdateBases];    InitHashing[];    nIncludes _ 0;      firstFile _ FNil;  firstHost _ HNNil;    localHost _ EnterHost["ME"L];    firstMultLocSource _ MLSNil;  firstMultLocBcd _ MLBNil;    firstMultVersionSource _ MVSNil;  firstMultVersionBcd _ MVBNil};          Finalize: PUBLIC PROC = {    FinalizeHashing[];     IF icTable # NIL THEN icTable.DropNotify[UpdateBases];     nIncludes _ 0;    firstFile _ FNil;  firstHost _ HNNil;    localHost _ HNNil;    firstMultLocSource _ MLSNil;  firstMultLocBcd _ MLBNil;    firstMultVersionSource _ MVSNil;  firstMultVersionBcd _ MVBNil;        icZone _ NIL;  icTable _ NIL};     -- ###################### List of source and Bcd files ########################   firstFile: PUBLIC File _ FNil;  EnterSource: PUBLIC PROC [        host, dir, file: LONG STRING,         config, packaged: BOOLEAN, sourceDate: Time.Packed]       RETURNS [f: File] = {    name: Name = NameForString[file];    hash: Hash = HashFn[file];    sourceLoc: Loc = [host: EnterHost[host], dir: EnterDir[dir]];        RecordSourceMatch: PROC = {      EnterSourceInfo[f];      -- see if any remaining entries (after f) are Bcds derived from this source        FOR o: File _ feb[f].next, feb[o].next WHILE o # FNil DO        IF EqualNames[name, feb[o].name] AND feb[o].bcd AND ~feb[o].source THEN 	  EnterSourceInfo[o]; 	ENDLOOP};	    EnterSourceInfo: PROC [s: File] = INLINE {      feb[s].source _ TRUE;    feb[s].sourceLoc _ sourceLoc;      feb[s].config _ config;  feb[s].packaged _ packaged;      feb[s].sourceDate _ sourceDate};	    -- see if source matches a previously entered file    FOR f _ fHashVec[hash], feb[f].next WHILE f # FNil DO      IF EqualNames[name, feb[f].name] THEN         SELECT TRUE FROM	          feb[f].source =>             IF feb[f].sourceDate = sourceDate THEN  -- same source already entered              IF sourceLoc = feb[f].sourceLoc THEN RETURN[f]               ELSE {	        SourceInMultLocs[	          name: name, create: sourceDate,		  loc1: sourceLoc, loc2: feb[f].sourceLoc];	        LOOP}	    ELSE { -- another version of source already entered	      SourceInMultVersions[	        name: name, create1: sourceDate, create2: feb[f].sourceDate,		loc1: sourceLoc, loc2: feb[f].sourceLoc];	      LOOP};    	          feb[f].bcd => {  -- Bcd with same name already entered at f            RecordSourceMatch[];  RETURN[f]};    	            ENDCASE => 	    ERROR ICDefs.Bug["ICListsImpl: file entered, but not source or Bcd"L];          ENDLOOP;    -- no match; create new entry for this source    f _ CreateFile[name];    feb[f].next _ fHashVec[hash];  fHashVec[hash] _ f;    EnterSourceInfo[f]};        EnterBcd: PUBLIC PROC [        host, dir, file: LONG STRING, 	config, packaged: BOOLEAN, version: VersionStamp, sourceDate: Time.Packed]       RETURNS [f: File] = {    name: Name = NameForString[file];    hash: Hash = HashFn[file];    bcdLoc: Loc = [host: EnterHost[host], dir: EnterDir[dir]];        RecordBcdMatch: PROC = {      EnterBcdInfo[];      -- now see if this Bcd was derived from any previously entered source      -- i.e. two Bcds derived from the same source      IF ~feb[f].source THEN        FOR o: File _ fHashVec[hash], feb[o].next WHILE o # FNil DO          IF o # f AND EqualNames[name, feb[o].name] AND feb[o].source THEN {	    feb[f].source _ TRUE;  -- copy source info from o to f	    feb[f].packaged   _ feb[o].packaged;	    feb[f].sourceLoc  _ feb[o].sourceLoc;	    feb[f].sourceDate _ feb[o].sourceDate;	    RETURN};	  ENDLOOP};        EnterBcdInfo: PROC = INLINE {      feb[f].bcd _ TRUE;               feb[f].config _ config;    feb[f].packaged _ packaged;      feb[f].version _ version;  feb[f].bcdSourceDate _ sourceDate;      feb[f].bcdLoc _ bcdLoc};	    -- see if Bcd matches a previously entered file    FOR f _ fHashVec[hash], feb[f].next WHILE f # FNil DO      IF EqualNames[name, feb[f].name] THEN        SELECT TRUE FROM	          feb[f].bcd =>             IF feb[f].version = version THEN  -- same Bcd already entered	      IF bcdLoc = feb[f].bcdLoc THEN RETURN[f]              ELSE {	        BcdInMultLocs[		  name: name, version: version,		  loc1: bcdLoc, loc2: feb[f].bcdLoc];		LOOP}	    ELSE {  -- another version of Bcd already entered	      BcdInMultVersions[	        name: name, version1: version, version2: feb[f].version,	        loc1: bcdLoc, loc2: feb[f].bcdLoc];	      LOOP};	                feb[f].source => {EnterBcdInfo[];  RETURN[f]}	              ENDCASE =>	    ERROR ICDefs.Bug["ICListsImpl: file entered, but not source or Bcd"L];      ENDLOOP;    -- no match; create new entry for this Bcd    f _ CreateFile[name];    feb[f].next _ fHashVec[hash];  fHashVec[hash] _ f;    RecordBcdMatch[]};      CreateFile: PROC [name: Name] RETURNS [f: File] = {    f _ icTable.Words[ICLists.fileType, SIZE[FileObject]      ! LongAlloc.Overflow => RESUME[10]];  -- allocate an addition 10 pages    feb[f] _ FileObject[      name:           name,      link:           firstFile,      next:           FNil,       bcdLoc:         NullLoc,      sourceLoc:      NullLoc,      version:        BcdDefs.NullVersion,      bcdSourceDate:  NullTime,      sourceDate:     NullTime,       includes:       IFNil,      containedBy:    CFNil,      nextInDepth:    FNil,      includeCount:   0,      bcd:            FALSE,      source:         FALSE,      imported:           FALSE,      sameBcdInDFfile:    TRUE,      sameSourceInDFfile: TRUE,      config:         FALSE,      defModule:      FALSE,      packaged:       FALSE,      tableCompiled:  FALSE,      boundsCheck:    FALSE,      nilCheck:       FALSE,      crossJumped:    TRUE,       codeBound:      TRUE,       symbolsBound:   FALSE,       tag:            FALSE,      busy:           FALSE,      bad:            FALSE,      obsolete:       FALSE,      readProtected:  FALSE,      wrongSource:    FALSE,      sourceButNoBcd: FALSE,      wrongIncludes:  FALSE,      dependsOnBad:   FALSE,      badDependee:    NameNil];    firstFile _ f};  SourceFound: PUBLIC PROC [f: File] RETURNS [BOOLEAN] = {RETURN[feb[f].source]};      BcdFound: PUBLIC PROC [f: File] RETURNS [BOOLEAN] = {RETURN[feb[f].bcd]};      TableCompiled: PUBLIC PROC [f: File] RETURNS [BOOLEAN] = {    RETURN[feb[f].tableCompiled]};  EnumerateFiles: PUBLIC PROC [      proc: PROC [File] RETURNS [stop: BOOLEAN]] = {    FOR f: File _ firstFile, feb[f].link UNTIL f = FNil DO      IF proc[f] THEN RETURN;      ENDLOOP};      EnumerateFilesWithName: PUBLIC PROC [      name: Name, proc: PROC [File] RETURNS [stop: BOOLEAN]] = {    hash: Hash = HashFn[StringForName[name]];    FOR f: File _ fHashVec[hash], feb[f].next WHILE f # FNil DO      IF EqualNames[name, feb[f].name] THEN         IF proc[f] THEN RETURN;      ENDLOOP};      ClearTags: PUBLIC PROC = {      ClearTag: PROC [f: File] RETURNS [stop: BOOLEAN] = {      feb[f].tag _ FALSE;  RETURN[FALSE]};          EnumerateFiles[ClearTag]};        ClearBusyMarks: PUBLIC PROC = {      ClearBusyMark: PROC [f: File] RETURNS [stop: BOOLEAN] = {      feb[f].busy _ FALSE;  RETURN[FALSE]};          EnumerateFiles[ClearBusyMark]};         -- ########## File location (host and directory) information ############   firstHost: HostName _ HNNil;  localHost: HostName _ HNNil;      EmptyLoc: PROC [loc: Loc] RETURNS [BOOLEAN] = {    RETURN[loc.host = HNNil AND loc.dir = DNNil]};      EnterHost: PROC [host: LONG STRING] RETURNS [h: HostName] = {    hostName: Name;    IF String.Empty[host] THEN RETURN[HNNil];    hostName _ NameForString[host];    FOR h _ firstHost, hb[h].link UNTIL h = HNNil DO      IF EqualNames[hostName, hb[h].name] THEN RETURN[h];      ENDLOOP;    -- create a new host entry    h _ icTable.Words[ICLists.hostType, SIZE[HostNameObject]      ! LongAlloc.Overflow => RESUME[5]];    hb[h] _ HostNameObject[      link: firstHost,       name: hostName];    firstHost _ h};      EnterDir: PROC [dir: LONG STRING] RETURNS [d: DirName] = {    dirName: Name;    h: Hash;    IF String.Empty[dir] THEN RETURN[DNNil];    dirName _ NameForString[dir];    h _ HashFn[dir];    FOR d _ dnHashVec[h], db[d].next UNTIL d = DNNil DO      IF EqualNames[dirName, db[d].name] THEN RETURN[d];      ENDLOOP;    -- create a new directory entry    d _ icTable.Words[ICLists.dirType, SIZE[DirNameObject]      ! LongAlloc.Overflow => RESUME[5]];    db[d] _ DirNameObject[      next: dnHashVec[h],       name: dirName];    dnHashVec[h] _ d};      LocalHost: PUBLIC PROC [host: HostName] RETURNS [BOOLEAN] = {    RETURN[host = localHost]};       -- ####### Marked files: those found in multiple locations or versions #######   firstMultLocSource:     MultLocSource _ MLSNil;  firstMultLocBcd:        MultLocBcd _ MLBNil;  firstMultVersionSource: MultVersionSource _ MVSNil;  firstMultVersionBcd:    MultVersionBcd _ MVBNil;      SourceInMultLocs: PROC [name: Name, create: Time.Packed, loc1, loc2: Loc] = {    s: MultLocSource;    last: MultLocSource _ MLSNil;  -- trails s (list is kept sorted)    FOR s _ firstMultLocSource, LOOPHOLE[mb[s].link] UNTIL s = MLSNil DO      SELECT NameCompare[mb[s].name, name] FROM	-1    => last _ s;	0     => RETURN;	ENDCASE => EXIT;      ENDLOOP;    s _ icTable.Words[ICLists.markedType, SIZE[source multLoc MFObject]      ! LongAlloc.Overflow => RESUME[5]];    IF last = MLSNil THEN {  -- first in list      mb[s] _ [        link: firstMultLocSource, name: name, loc1: loc1, loc2: loc2,	body: multLoc[source[create: create]]];      firstMultLocSource _ s}    ELSE {      mb[s] _ [        link: mb[last].link, name: name, loc1: loc1, loc2: loc2,	body: multLoc[source[create: create]]];      mb[last].link _ s}};      SourceInMultVersions: PROC [      name: Name, create1, create2: Time.Packed, loc1, loc2: Loc] = {    s: MultVersionSource;    last: MultVersionSource _ MVSNil;  -- trails s (list is kept sorted)    FOR s _ firstMultVersionSource, LOOPHOLE[mb[s].link] UNTIL s = MVSNil DO      SELECT NameCompare[mb[s].name, name] FROM	-1    => last _ s;	0     => RETURN;	ENDCASE => EXIT;      ENDLOOP;    s _ icTable.Words[ICLists.markedType, SIZE[source multVersion MFObject]      ! LongAlloc.Overflow => RESUME[5]];    IF last = MVSNil THEN {  -- first in list      mb[s] _ [        link: firstMultVersionSource, name: name, loc1: loc1, loc2: loc2,	body: multVersion[source[create1: create1, create2: create2]]];      firstMultVersionSource _ s}    ELSE {      mb[s] _ [        link: mb[last].link, name: name, loc1: loc1, loc2: loc2,	body: multVersion[source[create1: create1, create2: create2]]];      mb[last].link _ s}};            BcdInMultLocs: PROC [name: Name, version: VersionStamp, loc1, loc2: Loc] = {    b: MultLocBcd;    last: MultLocBcd _ MLBNil;  -- trails b (list is kept sorted)    FOR b _ firstMultLocBcd, LOOPHOLE[mb[b].link] UNTIL b = MLBNil DO      SELECT NameCompare[mb[b].name, name] FROM	-1    => last _ b;	0     => RETURN;	ENDCASE => EXIT;      ENDLOOP;    b _ icTable.Words[ICLists.markedType, SIZE[bcd multLoc MFObject]      ! LongAlloc.Overflow => RESUME[5]];    IF last = MLBNil THEN {  -- first in list      mb[b] _ [        link: firstMultLocBcd, name: name, loc1: loc1, loc2: loc2,	body: multLoc[bcd[version: version]]];      firstMultLocBcd _ b}    ELSE {      mb[b] _ [        link: mb[last].link, name: name, loc1: loc1, loc2: loc2,	body: multLoc[bcd[version: version]]];      mb[last].link _ b}};	      BcdInMultVersions: PROC [      name: Name, version1, version2: VersionStamp, loc1, loc2: Loc] = {    b: MultVersionBcd;    last: MultVersionBcd _ MVBNil;  -- trails b (list is kept sorted)    FOR b _ firstMultVersionBcd, LOOPHOLE[mb[b].link] UNTIL b = MVBNil DO      SELECT NameCompare[mb[b].name, name] FROM	-1    => last _ b;	0     => RETURN;	ENDCASE => EXIT;      ENDLOOP;    b _ icTable.Words[ICLists.markedType, SIZE[bcd multVersion MFObject]      ! LongAlloc.Overflow => RESUME[5]];    IF last = MVBNil THEN {  -- first in list      mb[b] _ [        link: firstMultVersionBcd, name: name, loc1: loc1, loc2: loc2,	body: multVersion[bcd[version1: version1, version2: version2]]];      firstMultVersionBcd _ b}    ELSE {      mb[b] _ [        link: mb[last].link, name: name, loc1: loc1, loc2: loc2,	body: multVersion[bcd[version1: version1, version2: version2]]];      mb[last].link _ b}};	    EnumerateMultLocSources: PUBLIC PROC [      proc: PROC [MultLocSource] RETURNS [stop: BOOLEAN]] = {    FOR s: MultLocSource _ firstMultLocSource, LOOPHOLE[mb[s].link]    UNTIL s = MLSNil DO      IF proc[s] THEN RETURN;      ENDLOOP};        EnumerateMultLocBcds: PUBLIC PROC [      proc: PROC [MultLocBcd] RETURNS [stop: BOOLEAN]] = {    FOR b: MultLocBcd _ firstMultLocBcd, LOOPHOLE[mb[b].link]    UNTIL b = MLBNil DO      IF proc[b] THEN RETURN;      ENDLOOP};        EnumerateMultVersionSources: PUBLIC PROC [      proc: PROC [MultVersionSource] RETURNS [stop: BOOLEAN]] = {    FOR s: MultVersionSource _ firstMultVersionSource, LOOPHOLE[mb[s].link]    UNTIL s = MVSNil DO      IF proc[s] THEN RETURN;      ENDLOOP};    EnumerateMultVersionBcds: PUBLIC PROC [      proc: PROC [MultVersionBcd] RETURNS [stop: BOOLEAN]] = {    FOR b: MultVersionBcd _ firstMultVersionBcd, LOOPHOLE[mb[b].link]    UNTIL b = MVBNil DO      IF proc[b] THEN RETURN;      ENDLOOP};        AnyMultVersionFiles: PUBLIC PROC RETURNS [BOOLEAN] = {    RETURN[firstMultVersionSource # MVSNil OR firstMultVersionBcd # MVBNil]}; -- ################# Descriptions of included files ##################   nIncludes: PUBLIC CARDINAL _ 0;   AddToIncludedList: PUBLIC PROC [      container: File,      included: String.SubString, version: VersionStamp] = {    name: Name = NameForSubString[included];    i: IncludedFile;    last: IncludedFile _ IFNil;  -- trails i (includes list is kept sorted)    FOR i _ feb[container].includes, ifb[i].link UNTIL i = IFNil DO      incFile: IncFileDesc = ifb[i].desc;      SELECT NameCompare[idb[incFile].name, name] FROM	-1    => last _ i;	0     => RETURN;	ENDCASE => EXIT;      ENDLOOP;    -- no existing entry, insert a new entry after "last"    i _ icTable.Words[ICLists.includeType, SIZE[IncludedFileObject]      ! LongAlloc.Overflow => RESUME[10]];    IF last = IFNil THEN {  -- first in list      ifb[i] _ IncludedFileObject[	link: feb[container].includes,	desc: CreateIncFileDesc[included, name, version]];      feb[container].includes _ i}    ELSE {      ifb[i] _ IncludedFileObject[	link: ifb[last].link,	desc: CreateIncFileDesc[included, name, version]];      ifb[last].link _ i}};        CreateIncFileDesc: PROC [        included: String.SubString, name: Name, version: VersionStamp]      RETURNS [d: IncFileDesc] = {    hash: Hash = SSHashFn[included];    -- see if file has already been included    FOR d _ ifdHashVec[hash], idb[d].next WHILE d # IFDNil DO      IF EqualNames[name, idb[d].name] AND version = idb[d].version THEN RETURN[d];      ENDLOOP;    -- no match; create new entry    nIncludes _ nIncludes+1;    d _ icTable.Words[ICLists.incDescType, SIZE[IncFileDescObject]       ! LongAlloc.Overflow => RESUME[10]];    idb[d] _ IncFileDescObject[      next:     ifdHashVec[hash],      name:     name,      version:  version,      file:     FNil,  -- an attempt to match the file will be made later      lookedUp: FALSE,      found:    FALSE,      wrongVersion:   FALSE,      unknownVersion: FALSE];      ifdHashVec[hash] _ d};      -- Match included file descriptions against the files actually found  MatchIncludedFiles: PUBLIC PROC = {      MatchFile: PROC [i: IncFileDesc] RETURNS [stop: BOOLEAN] = {      MatchOneIncludedFile[i];  RETURN[FALSE]};          EnumerateIncludedFiles[MatchFile]};      MatchOneIncludedFile: PUBLIC PROC [i: IncFileDesc] = {    -- there are three possible outcomes:    --  1) idb[i].found =>                           (match found; ok)    --        idb[i].file = <matching file found>    --  2) ~idb[i].found AND idb[i].wrongVersion =>  (no match but another version    --        idb[i].file = <other version found>      was found or was readonly)    --  3) ~idb[i].found AND ~idb[i].wrongVersion => (never found but seems ok)    --        idb[i].file = IFNil    incName: Name = idb[i].name;    incVersion: VersionStamp = idb[i].version;    anotherVersion: BOOLEAN _ FALSE;        CheckIfMatchingFile: PROC [f: File] RETURNS [stop: BOOLEAN] = {      IF feb[f].version = incVersion THEN {        idb[i].found _ TRUE;	idb[i].file _ f;  -- note that a match was found at f	RETURN[TRUE]}      ELSE {anotherVersion _ TRUE;  RETURN[FALSE]}};        CheckIfOtherVersionFound: PROC [f: File] RETURNS [stop: BOOLEAN] = {      IF feb[f].version # incVersion AND (feb[f].bcd OR feb[f].imported) THEN {        idb[i].wrongVersion _ TRUE;	idb[i].file _ f;  -- note the other (found or imported) version of file	RETURN[TRUE]}      ELSE RETURN[FALSE]};          EnumerateFilesWithName[incName, CheckIfMatchingFile];    IF ~idb[i].found AND anotherVersion THEN      -- wrongVersion if another version WAS found      EnumerateFilesWithName[incName, CheckIfOtherVersionFound]};         EnumerateIncludedFiles: PUBLIC PROC [     proc: PROC [IncFileDesc] RETURNS [stop: BOOLEAN]] = {   ifdLimit: IncFileDesc = icTable.Top[ICLists.incDescType];   FOR i: IncFileDesc _ LOOPHOLE[LONG[0]], i + SIZE[IncFileDescObject]   UNTIL i = ifdLimit DO     IF proc[i] THEN RETURN;     ENDLOOP};     EnumerateIncludedFilesWithName: PUBLIC PROC [     name: Name, proc: PROC [IncFileDesc] RETURNS [stop: BOOLEAN]] = {   hash: Hash = HashFn[StringForName[name]];   FOR i: IncFileDesc _ ifdHashVec[hash], idb[i].next WHILE i # IFDNil DO     IF idb[i].name = name THEN       IF proc[i] THEN RETURN;     ENDLOOP};        EnumerateFilesIncludedBy: PUBLIC PROC [      container: File, proc: PROC [IncludedFile] RETURNS [stop: BOOLEAN]] = {    FOR i: IncludedFile _ feb[container].includes, ifb[i].link UNTIL i = IFNil DO      IF proc[i] THEN RETURN;      ENDLOOP};             -- ################# Descriptions of containing files ##################   AddToContainedByList: PUBLIC PROC [included, containedBy: File] = {    contName: Name = feb[containedBy].name;    c: ContainingFile;    last: ContainingFile _ CFNil;  -- trails c (containedBy list is kept sorted)    FOR c _ feb[included].containedBy, cfb[c].link UNTIL c = CFNil DO      -- containing file is cfb[c].file;      SELECT NameCompare[feb[cfb[c].file].name, contName] FROM	-1    => last _ c;	0     => RETURN;	ENDCASE => EXIT;      ENDLOOP;    -- no existing entry, insert a new entry after "last"    c _ icTable.Words[ICLists.containType, SIZE[ContainingFileObject]          ! LongAlloc.Overflow => RESUME[5]];    IF last = CFNil THEN {  -- first in list      cfb[c] _ ContainingFileObject[        link: feb[included].containedBy, file: containedBy];      feb[included].containedBy _ c}    ELSE {      cfb[c] _ ContainingFileObject[	link: cfb[last].link, file: containedBy];      cfb[last].link _ c}};        NewContainer: PUBLIC PROC RETURNS [new: ContainingFile] = {    new _ icTable.Words[ICLists.containType, SIZE[ContainingFileObject]      ! LongAlloc.Overflow => RESUME[5]];    cfb[new] _ ContainingFileObject[link: CFNil, file: FNil]};        EnumerateFilesThatContain: PUBLIC PROC [      included: File,      proc: PROC [ContainingFile] RETURNS [stop: BOOLEAN]] = {    FOR c: ContainingFile _ feb[included].containedBy, cfb[c].link    UNTIL c = CFNil DO      IF proc[c] THEN RETURN;      ENDLOOP};        EnumerateContainingFiles: PUBLIC PROC [      proc: PROC [ContainingFile] RETURNS [stop: BOOLEAN]] = {    cLimit: ContainingFile = icTable.Top[ICLists.containType];    FOR c: ContainingFile _ LOOPHOLE[LONG[0]], c + SIZE[ContainingFileObject]    UNTIL c = cLimit DO      IF proc[c] THEN RETURN;      ENDLOOP};     -- ###################### Depth lists ########################   EnumerateDepths: PUBLIC PROC [      proc: PROC [DepthIndex] RETURNS [stop: BOOLEAN]] = {    dLimit: DepthIndex = icTable.Top[ICLists.depthType];    FOR d: DepthIndex _ LOOPHOLE[LONG[0]], d + SIZE[DepthObject]    UNTIL d = dLimit DO      IF proc[d] THEN RETURN;      ENDLOOP};        EnumerateFilesOfDepth: PUBLIC PROC [      depth: DepthIndex,      proc: PROC [File] RETURNS [stop: BOOLEAN]] = {    FOR f: File _ dib[depth].first, feb[f].nextInDepth UNTIL f = FNil DO      IF proc[f] THEN RETURN;      ENDLOOP};        -- ###################### File names ########################   -- Assert: (s1 equiv s2) <=> (NameForString[s1] = NameForString[s2])    NameForString: PUBLIC PROC [s: LONG STRING] RETURNS [name: Name] = {    ss: String.SubStringDescriptor _ [base: s, offset: 0, length: s.length];    RETURN[NameForSubString[@ss]]};        NameForSubString: PROC [ss: String.SubString] RETURNS [name: Name] = {    OPEN String;    b: LONG STRING = ss.base;    hash: Hash = SSHashFn[ss];    lowercase: BOOLEAN _ TRUE;    -- determine if ss is lowercase    FOR i: CARDINAL IN [ss.offset..(ss.offset+ss.length)) DO      IF b[i] IN ['A..'Z] THEN {lowercase _ FALSE;  EXIT};      ENDLOOP;    -- see if name has already been entered    FOR name _ nameHashVec[hash], nb[name].next WHILE name # NameNil DO      nameString: LONG STRING = @nb[name].string;      nameSsd: SubStringDescriptor _ [        base: nameString, offset: 0, length: nameString.length];      IF EquivalentSubString[ss, @nameSsd] THEN {        -- replace old string with ss if ss has better capitalization        IF ~lowercase AND nb[name].lowercase THEN {	  nameString.length _ 0;	  AppendSubString[to: nameString, from: ss];	  nb[name].lowercase _ FALSE};	RETURN[name]};      ENDLOOP;    -- no match; create new name entry    name _ icTable.Words[ICLists.nameType, (SIZE[NameObject] + (ss.length+1)/2)      ! LongAlloc.Overflow => RESUME[10]];    nb[name] _ NameObject[      next: nameHashVec[hash],      hash: hash,      lowercase: lowercase,      string: StringBody[length: 0, maxlength: ss.length, text: ]];    AppendSubString[to: @nb[name].string, from: ss];    nameHashVec[hash] _ name};      StringForName: PUBLIC PROC [name: Name] RETURNS [LONG STRING] = {    RETURN[IF name = NameNil THEN "" ELSE @nb[name].string]};      EqualNames: PROC [n1, n2: Name] RETURNS [BOOLEAN] = INLINE {RETURN[n1 = n2]};      NameCompare: PUBLIC PROC [n1, n2: Name] RETURNS [r: INTEGER] = {    a, b: LONG STRING;    l: CARDINAL;    ca, cb: CHARACTER;    CharAnd: PROC [CHARACTER, WORD] RETURNS [CHARACTER] = Inline.BITAND;    SELECT TRUE FROM      (n1 = n2)      => RETURN[0];      (n1 = NameNil) => RETURN[-1];      (n2 = NameNil) => RETURN[1];      ENDCASE;    a _ @nb[n1].string;  b _ @nb[n2].string;    l _ MIN[a.length, b.length];    FOR i: CARDINAL IN [0..l) DO      ca _ a[i];  cb _ b[i];      IF ca IN ['a..'z] THEN ca _ CharAnd[ca, 137B]; -- ignore case shifts      IF cb IN ['a..'z] THEN cb _ CharAnd[cb, 137B];      IF ca < cb THEN RETURN[-1];      IF ca > cb THEN RETURN[1];      ENDLOOP;    RETURN[      SELECT a.length FROM	< b.length => -1,	= b.length => 0,	ENDCASE    => 1]};           -- ################### Sort filelist ####################    next, last: File;    SortKey: TYPE = LONG POINTER TO SortKeyObject;  SortKeyObject: TYPE = RECORD [    f: File,     name: StringBody];        SortFiles: PUBLIC PROC = {    next _ firstFile;  last _ FNil;     GSort.Sort[      get: OutputUnsortedFile, put: InsertSortedFile, compare: CompareFileNames,      expectedItemSize: 20, maxItemSize: 100, pagesInHeap: 30]};        OutputUnsortedFile: GSort.GetProcType = {    key: SortKey = p;    IF next = FNil THEN RETURN[0]  -- no files remain    ELSE {      key^ _ [        f: next, name: [length: 0, maxlength: MFile.maxNameLength, text: ]];      AppendString[@key.name, StringForName[feb[next].name]];      next _ feb[next].link;      RETURN[ SIZE[File] + WordsForString[key.name.length] ]}};      CompareFileNames: GSort.CompareProcType = {    k1: SortKey = p1;    k2: SortKey = p2;    RETURN[String.CompareStrings[@k1.name, @k2.name]]};      InsertSortedFile: GSort.PutProcType = {    key: SortKey = p;    f: File = key.f;    IF last = FNil THEN firstFile _ last _ f  -- first in sorted list    ELSE {feb[last].link _ f;  last _ f};    feb[last].link _ FNil};     -- ############# Hashing and string operations ##############    fHashVec: LONG POINTER TO FVec _ NIL;        -- Hash -> File  FVec: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF File];  dnHashVec: LONG POINTER TO DNVec _ NIL;      -- Hash -> DirName  DNVec: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF DirName];  ifdHashVec: LONG POINTER TO IFDVec _ NIL;    -- Hash -> IncFileDesc  IFDVec: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF IncFileDesc];  nameHashVec: LONG POINTER TO NameVec _ NIL;  -- Hash -> Name  NameVec: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF Name];     InitHashing: PROC = {    fHashVec    _ icZone.NEW[FVec[HVSize]];    dnHashVec   _ icZone.NEW[DNVec[HVSize]];    ifdHashVec  _ icZone.NEW[IFDVec[HVSize]];    nameHashVec _ icZone.NEW[NameVec[HVSize]];    FOR i: Hash IN Hash DO      fHashVec[i] _ FNil;  dnHashVec[i] _ DNNil;      ifdHashVec[i] _ IFDNil;  nameHashVec[i] _ NameNil;      ENDLOOP};   FinalizeHashing: PROC = {    IF fHashVec # NIL THEN icZone.FREE[@fHashVec];    IF dnHashVec # NIL THEN icZone.FREE[@dnHashVec];    IF ifdHashVec # NIL THEN icZone.FREE[@ifdHashVec];    IF nameHashVec # NIL THEN icZone.FREE[@nameHashVec]};      CharBits: PROC [CHARACTER, WORD] RETURNS [WORD] = LOOPHOLE[Inline.BITAND];  CharMask: WORD = 337B;  -- mask out case shifts      HashFn: PROC [s: LONG STRING] RETURNS [Hash] = {    n: CARDINAL = s.length;    v: WORD _ CharBits[s[0], CharMask]*177B;    IF n > 0 THEN v _ v + CharBits[s[n-1], CharMask];    RETURN[Inline.BITXOR[v, n*17B] MOD HVSize]};      SSHashFn: PROC [ss: String.SubString] RETURNS [Hash] = {    t: LONG STRING = ss.base;    n: CARDINAL = ss.length;    v: WORD _ CharBits[t[ss.offset], CharMask]*177B;    IF n > 0 THEN v _ v + CharBits[t[ss.offset+ss.length-1], CharMask];    RETURN[Inline.BITXOR[v, n*17B] MOD HVSize]};      END. 
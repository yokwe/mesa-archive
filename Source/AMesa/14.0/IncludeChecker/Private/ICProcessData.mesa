-- ICProcessData.mesa - Last modified by--   BTL  	 5-May-83 13:13:18--   RLC         5-Feb-87 10:26:33 DIRECTORY  BcdDefs USING [NullVersion, VersionStamp],  Environment USING [bytesPerWord, wordsPerPage],  Exec USING [Handle],  GSort USING [    CompareProcType, Port, PutProcType, Sort, SortItemPort,    SortStarter, SortStopper],  ICDefs USING [    CheckAbort, exec, Log, LogBlanks, LogCR, LogDate, LogLine, LogName,     LogVersion, nLocalBcds, nRemoteBcds, nIncludes, nLocalSources,    nRemoteSources, ownTable, switches, tableName, zone],  ICLists USING [    Base, CFNil, ClearBusyMarks, ClearTags, ContainingFile, containType,    DepthIndex, DepthObject, depthType, DINil, dirType,    EnumerateContainingFiles, EnumerateFiles, EnumerateFilesIncludedBy,    EnumerateFilesThatContain, EnumerateFilesWithName, EnumerateIncludedFiles,    File, FileObject, fileType, firstFile, FNil, Header, HeaderObject,    hostType, IFDNil, IFNil, incDescType, IncFileDesc, IncludedFile,    includeType, markedType, Name, NameCompare, NameNil, nameType, NewContainer,    NullLoc, NullTime, SortFiles, VersionID, VersionStamp],  Inline USING [LowHalf],  LongAlloc USING [    AddNotify, Base, Bounds, DropNotify, Handle, Notifier, Overflow,    Selector, Words],  MFile USING [    dontRelease, Error, Handle, ReadOnly, Release, SetReadProtect, WriteOnly],  MStream USING [Create, Handle],  Runtime USING [GetBcdTime],  Stream USING [Delete, Handle, PutBlock, SetPosition],  Time USING [Packed];  ICProcessData: PROGRAM    IMPORTS       GSort, ICDefs, ICLists, Inline, LongAlloc, MFile, MStream, Runtime, Stream    EXPORTS ICDefs =  BEGIN OPEN ICDefs, ICLists;    icExec: Exec.Handle _ NIL;  -- local copies of ICDefs variables  icTable: LongAlloc.Handle _ NIL;    badFiles: PUBLIC BOOLEAN _ FALSE;  circular: PUBLIC BOOLEAN _ FALSE;  olderIncludesFound: PUBLIC BOOLEAN _ FALSE;    feb: LongAlloc.Base;  -- file records  ifb: LongAlloc.Base;  -- included files  idb: LongAlloc.Base;  -- descriptions of included files   cfb: LongAlloc.Base;  -- containing files  hb:  LongAlloc.Base;  -- hosts  db:  LongAlloc.Base;  -- directories  dib: LongAlloc.Base;  -- file depth chain heads  mb:  LongAlloc.Base;  -- marked files  nb:  LongAlloc.Base;  -- names  UpdateBases: LongAlloc.Notifier = {    feb _ base[ICLists.fileType];      ifb _ base[ICLists.includeType];    idb _ base[ICLists.incDescType];    cfb _ base[ICLists.containType];    hb  _ base[ICLists.hostType];    db  _ base[ICLists.dirType];    dib _ base[ICLists.depthType];    mb  _ base[ICLists.markedType];    nb  _ base[ICLists.nameType]};         -- Analyze file data  ProcessData: PUBLIC PROC = {    ENABLE UNWIND => Finalize[];    depthsNeeded: BOOLEAN = (ICDefs.switches['c] OR ICDefs.switches['o]);    Initialize[];    LogCR[];    IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    ICLists.SortFiles[];    -- analyze file dependencies    IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    IF depthsNeeded    OR (ICDefs.switches['i] AND ICDefs.switches['v] AND ~ICDefs.switches['f]) THEN      ComputeContainedByRelation[];  -- only if needed and not "fast" mode    IF depthsNeeded THEN ComputeInclusionDepths[];    -- determine which files must be rebuilt    IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    badFiles _ FALSE;    MarkDirectlyBadFiles[];    IF badFiles THEN MarkIndirectlyBadFiles[];    -- if debugging, check tables for consistency    IF ICDefs.switches['d] THEN {      IF ICDefs.CheckAbort[] THEN ERROR ABORTED;      CheckTableConsistency[]};    -- write data for other programs    IF ICDefs.switches['t] THEN {      IF ICDefs.CheckAbort[] THEN ERROR ABORTED;      PutTablesToFile[]};    Finalize[]};      Initialize: PROC = {    icExec _ ICDefs.exec;  icTable _ ICDefs.ownTable;    icTable.AddNotify[UpdateBases];    badFiles _ FALSE;  circular _ FALSE;  olderIncludesFound _ FALSE};    Finalize: PROC = {    CloseOutputStream[];    IF header # NIL THEN zone.FREE[@header];    IF icTable # NIL THEN icTable.DropNotify[UpdateBases];    icTable _ NIL;  icExec _ NIL};         -- Find for each file, which files contain it --  (Actually, containers are recorded only for found files)   lastG: File;  lastContainer: ContainingFile;    buffer: SortKey _ NIL;  SortKey: TYPE = LONG POINTER TO SortKeyObject;  SortKeyObject: TYPE = RECORD [f, g: File];   -- where f includes g  ComputeContainedByRelation: PROC = {    OutToSort: GSort.SortItemPort;  -- RLC 5-Feb-87 10:26:33 move into local frame    keySize: CARDINAL = (2*SIZE[File]);    pagesInHeap: CARDINAL _ 120;    funnyIncFile: CARDINAL _ 0;    lastG _ FNil;  lastContainer _ CFNil;    LOOPHOLE[OutToSort, GSort.Port].out _ GSort.Sort;    buffer _ LOOPHOLE[OutToSort, GSort.SortStarter] [      nextItem: @OutToSort,      put: InsertSortedKeys, compare: CompareKeys,      expectedItemSize: keySize, maxItemSize: keySize,       pagesInHeap: pagesInHeap];    FOR f: File _ ICLists.firstFile, feb[f].link UNTIL f = FNil DO      FOR i: IncludedFile _ feb[f].includes, ifb[i].link UNTIL i = IFNil DO        incDesc: IncFileDesc = ifb[i].desc;	IF idb[incDesc].file # FNil THEN {  -- f includes (the found) "g"          buffer^ _ [f: f, g: idb[incDesc].file];          buffer _ OutToSort[keySize]}	ELSE funnyIncFile _ funnyIncFile + 1;  -- place to hang breakpoint	ENDLOOP;      ENDLOOP;    LOOPHOLE[OutToSort, GSort.SortStopper][]};      CompareKeys: GSort.CompareProcType = {    k1: SortKey = p1;  -- order st. increasing g, then      k2: SortKey = p2;  --   within g, increasing name of f    SELECT k1.g FROM      < k2.g  => RETURN[-1];      > k2.g  => RETURN[+1];      ENDCASE => RETURN[ICLists.NameCompare[feb[k1.f].name, feb[k2.f].name]]};        InsertSortedKeys: GSort.PutProcType = {    key: SortKey = p;    c: ContainingFile _ ICLists.NewContainer[];    funny: CARDINAL _ 0;    cfb[c] _ [link: CFNil, file: key.f];    IF key.g # lastG THEN {  -- new "g", and new containedBy list      lastG _ key.g;      IF feb[lastG].containedBy # CFNil THEN funny _ funny+1; -- place for bkpt      feb[lastG].containedBy _ lastContainer _ c}    ELSE {cfb[lastContainer].link _ c;  lastContainer _ c}};           -- Determine inclusion depths of files    anotherDepth: BOOLEAN;            -- if a next higher file depth remains  filesWithUnreadableBcds: BOOLEAN; -- readProtected, sourceButNoBcd, obsolete  lastOfDepth: File _ FNil;  thisDepth: DepthIndex _ DINil;   ComputeInclusionDepths: PROC = {    anotherDepth _ FALSE;  filesWithUnreadableBcds _ FALSE;    InitDepthComputation[];    WHILE anotherDepth DO RecordFilesOfNextDepth[] ENDLOOP;    IF filesWithUnreadableBcds THEN {      anotherDepth _ TRUE;       NoteFilesWithUnreadableBcds[];       WHILE anotherDepth DO RecordFilesOfNextDepth[] ENDLOOP}};        InitDepthComputation: PROC = {    ClearBusyMarks[];  -- file busy <=> already output (cycle detection)    EnumerateFiles[NoteIncludesCount]};    NoteIncludesCount: PROC [f: File] RETURNS [stop: BOOLEAN] = {    OPEN file: feb[f];    count: CARDINAL _ 0;          InspectIncludedFile: PROC [if: IncludedFile] RETURNS [stop: BOOLEAN] = {      incDesc: IncFileDesc = ifb[if].desc;      -- we count any found file with same name, even if the wrong version        IF idb[incDesc].file # FNil THEN count _ count+1;       RETURN[FALSE]};           file.sourceButNoBcd _ (file.source AND ~file.bcd);    IF file.sourceButNoBcd OR file.readProtected OR file.obsolete THEN {      -- we put these files towards the end (very high depth)      file.includeCount _ LAST[NAT];  filesWithUnreadableBcds _ TRUE}    ELSE {      EnumerateFilesIncludedBy[f, InspectIncludedFile];      file.includeCount _ count;      IF count = 0 THEN anotherDepth _ TRUE};    RETURN[FALSE]};        RecordFilesOfNextDepth: PROC = {    thisDepth _ icTable.Words[ICLists.depthType, SIZE[DepthObject]      ! LongAlloc.Overflow => RESUME[10]];    dib[thisDepth] _ DepthObject[first: FNil];    lastOfDepth _ FNil;  anotherDepth _ FALSE;    EnumerateFiles[TagIfZeroCount];    EnumerateFiles[RecordTaggedFiles]};      TagIfZeroCount: PROC [f: File] RETURNS [stop: BOOLEAN] = {    OPEN file: feb[f];    file.tag _ (file.includeCount = 0 AND ~file.busy);    RETURN[FALSE]};          RecordTaggedFiles: PROC [f: File] RETURNS [stop: BOOLEAN] = {    OPEN file: feb[f];        UpdateContainersDepth: PROC [c: ContainingFile] RETURNS [stop: BOOLEAN] = {      container: File = cfb[c].file;      IF feb[container].busy THEN {NoteCircularDependency[f];  RETURN[FALSE]};      feb[container].includeCount _ (feb[container].includeCount - 1);      IF feb[container].includeCount = 0 THEN anotherDepth _ TRUE;      RETURN[FALSE]};	    IF file.tag THEN {  -- a file of this next depth - record it      IF dib[thisDepth].first = FNil THEN dib[thisDepth].first _ lastOfDepth _ f      ELSE {        feb[lastOfDepth].nextInDepth _ f;  file.nextInDepth _ FNil;        lastOfDepth _ f};      file.busy _ TRUE;  file.tag _ FALSE;        -- now consider direct containers as possible files of next higher depth      EnumerateFilesThatContain[f, UpdateContainersDepth]};    RETURN[FALSE]};      NoteFilesWithUnreadableBcds: PROC = {  -- readProtected, sourceButNoBcd, obsolete        ZeroCountIfUnreadableBcd: PROC [f: File] RETURNS [stop: BOOLEAN] = {      OPEN file: feb[f];      IF file.sourceButNoBcd OR file.readProtected OR file.obsolete THEN        file.includeCount _ 0;      RETURN[FALSE]};          EnumerateFiles[ZeroCountIfUnreadableBcd]};      NoteCircularDependency: PROC [f: File] = {    LogCR[];  Log["Circular file dependencies: "L];    LogName[feb[f].name];    LogLine[" depends on a file that, in turn, depends on it"L];    circular _ TRUE};         -- Mark directly bad files: those st.  --  o Bcd has incompatible version  --  o Bcd was marked read-protected   --  o source not found, but another version of source was  --  o included file not found, but another version was  --  o (if /-N switch) source but no Bcd was found      MarkDirectlyBadFiles: PROC = {EnumerateFiles[CheckIfDirectlyBad]};    CheckIfDirectlyBad: PROC [f: File] RETURNS [stop: BOOLEAN] = {    IF feb[f].imported THEN RETURN[FALSE];  -- never mark imported files bad    CheckIfIncompatableVersion[f];    CheckIfReadProtected[f];    IF ~feb[f].obsolete AND ~feb[f].readProtected THEN {      CheckIfBadSource[f];      IF ~ICDefs.switches['n] THEN CheckIfSourceButNoBcd[f];      CheckIfBadIncludedFile[f]};    RETURN[FALSE]};      CheckIfIncompatableVersion: PROC [f: File] = {    IF feb[f].obsolete THEN {      MarkDirectlyBad[f];      Log["  "L];  LogName[feb[f].name];      LogLine[" - incompatible Bcd format.\n"L]}};       CheckIfReadProtected: PROC [f: File] = {    IF feb[f].readProtected THEN {      MarkDirectlyBad[f];      Log["  "L];  LogName[feb[f].name];  LogLine[" - readProtected.\n"L]}};       CheckIfBadSource: PROC [f: File] = {    OPEN file: feb[f];          CheckIfOtherSourceFound: PROC [g: File] RETURNS [stop: BOOLEAN] = {      OPEN other: feb[g];      IF (g # f) AND other.source AND other.sourceDate # NullTime      AND other.sourceDate # file.bcdSourceDate THEN         IF file.bcdSourceDate > other.sourceDate THEN {	  Log["  (Warning - "L];  LogName[file.name];	  Log[" had source of "L];  LogDate[file.bcdSourceDate];  LogLine[","L];	  LogBlanks[8];  Log[" but OLDER source of "L];	  LogDate[other.sourceDate];  LogLine[" found - NOT marked bad.)\n"L];	  RETURN[TRUE]}	ELSE {          MarkDirectlyBad[f];  file.wrongSource _ TRUE;	  Log["  "L];  LogName[file.name];            Log[" had source of "L];  LogDate[file.bcdSourceDate];  LogLine[","L];	  LogBlanks[8];  Log["but NEWER source of "L];	  LogDate[other.sourceDate];  LogLine[" was found.\n"L];	  RETURN[TRUE]};      RETURN[FALSE]};         IF file.bcd AND file.bcdSourceDate # NullTime THEN       IF file.source AND file.sourceDate # NullTime       AND file.sourceDate # file.bcdSourceDate THEN         IF file.bcdSourceDate > file.sourceDate THEN {	  Log["  (Warning - "L];  LogName[file.name];	  Log[" - had source of "L];  LogDate[file.bcdSourceDate];  LogLine[","L];	  LogBlanks[8];  Log["but OLDER source of "L];	  LogDate[file.sourceDate];  LogLine[" found - NOT marked bad.)\n"L];	  RETURN}	ELSE {	  MarkDirectlyBad[f];  file.wrongSource _ TRUE;	  Log["  "L];  LogName[file.name];	  Log[" - had source of "L];  LogDate[file.bcdSourceDate];  LogLine[","L];	  LogBlanks[8];  Log["but NEWER source of "L];	  LogDate[file.sourceDate];  LogLine[" was found.\n"L];	  RETURN}      ELSE  -- no source already matched, is there another source version?         EnumerateFilesWithName[file.name, CheckIfOtherSourceFound]};	  CheckIfSourceButNoBcd: PROC [f: File] = {    IF feb[f].sourceButNoBcd THEN {      MarkDirectlyBad[f];      Log["  "L];  LogName[feb[f].name];      LogLine[" - source but no Bcd.\n"L]}};        CheckIfBadIncludedFile: PROC [f: File] = {       CheckIncludedFile: PROC [i: IncludedFile] RETURNS [stop: BOOLEAN] = {      desc: IncFileDesc = ifb[i].desc;      IF idb[desc].wrongVersion THEN {        incFile: File = idb[desc].file;	IF feb[incFile].readProtected THEN {	  Log["  "L];  LogName[feb[f].name];	  Log[" - depends on "L];  LogName[idb[desc].name];	  Log[" of "L];  LogVersion[idb[desc].version];  Log[","L];  LogCR[];	  LogBlanks[8];  LogLine["but readProtected version found.\n"L];	  MarkDirectlyBad[f];  feb[f].wrongIncludes _ TRUE}	ELSE {	  neededTime: Time.Packed = LOOPHOLE[idb[desc].version.time];	  foundTime:  Time.Packed = LOOPHOLE[feb[incFile].version.time];	  MarkDirectlyBad[f];  feb[f].wrongIncludes _ TRUE;	  IF neededTime > foundTime THEN {  -- older includes found	    Log["  "L];  LogName[feb[f].name];	    Log[" - depends on a NEWER version of "L];  LogName[idb[desc].name];	    Log[" "L];  LogVersion[idb[desc].version];  LogCR[];	    LogBlanks[8];  Log["than was found.  OLDER version found was "L];	    LogVersion[feb[incFile].version];  LogLine["."L];	    LogBlanks[8];	    LogLine[	      "Warning: you may want to edit rebuild command to NOT rebuild it.\n"L];	    olderIncludesFound _ TRUE}	  ELSE {	    Log["  "L];  LogName[feb[f].name];  Log[" - depends on "L];	    LogName[idb[desc].name];  Log[" of "L];	    LogVersion[idb[desc].version];  Log[","L];  LogCR[];	    LogBlanks[8];  Log["but NEWER version of "L];	    LogVersion[feb[incFile].version];  LogLine[" was found.\n"L]}};	RETURN[TRUE]};      RETURN[FALSE]};          EnumerateFilesIncludedBy[f, CheckIncludedFile]};      MarkDirectlyBad: PROC [f: File] = {    IF ~badFiles THEN {      LogCR[];      LogLine["The following files must be rebuilt:"L];  LogCR[];      badFiles _ TRUE};    feb[f].bad _ TRUE};           -- Mark indirectly bad files: those that depend on already bad files   directlyBadFile: File _ FNil;  iBFHeaderPrinted, headerForBadFilePrinted: BOOLEAN _ FALSE;    MarkIndirectlyBadFiles: PROC = {      CheckIfBad: PROC [f: File] RETURNS [stop: BOOLEAN] = {      IF feb[f].bad THEN {        directlyBadFile _ f;  headerForBadFilePrinted _ FALSE;	EnumerateFilesThatContain[f, MarkDependentBad];	IF headerForBadFilePrinted THEN Log["\n\n"L]};      RETURN[FALSE]};          ClearTags[];  ClearBusyMarks[];    iBFHeaderPrinted _ FALSE;    EnumerateFiles[CheckIfBad];    IF iBFHeaderPrinted THEN LogCR[];    ClearTags[];  ClearBusyMarks[]};      MarkDependentBad: PROC [c: ContainingFile] RETURNS [stop: BOOLEAN] = {    d: File = cfb[c].file;    IF feb[d].tag THEN RETURN[FALSE];  -- d and its dependents already marked bad    IF feb[d].busy THEN {NoteCircularDependency[d]; RETURN[FALSE]};    IF feb[d].imported THEN RETURN[FALSE];  -- never mark imported files bad    feb[d].busy _ TRUE;    IF ~iBFHeaderPrinted THEN {      LogCR[];      LogLine["Files that depend on files to be rebuilt:\n"L];      iBFHeaderPrinted _ TRUE};    IF ~headerForBadFilePrinted THEN {      Log["  "L];  LogName[feb[directlyBadFile].name]; Log[" has dependents:"L];      headerForBadFilePrinted _ TRUE};    Log[" "L];  LogName[feb[d].name];    feb[d].bad _ TRUE;    feb[d].dependsOnBad _ TRUE;  feb[d].badDependee _ feb[directlyBadFile].name;     EnumerateFilesThatContain[d, MarkDependentBad];    feb[d].busy _ FALSE;    feb[d].tag _ TRUE;    RETURN[FALSE]};             -- If debugging, check table consistency   TableInconsistency: SIGNAL = CODE;    BadTable: PROC = {SIGNAL TableInconsistency};    CheckTableConsistency: PROC = {    CheckFileEntries[];    CheckIncFileDescriptions[];    CheckContainingFiles[]};      CheckFileEntries: PROC = {        CheckOneFileEntry: PROC [f: File] RETURNS [stop: BOOLEAN] = {      file: FileObject = feb[f];      IF file.name = NameNil THEN BadTable[];      IF file.defModule THEN {        IF file.config OR file.tableCompiled THEN BadTable[]};	      IF file.bcd THEN {        IF file.bcdLoc = NullLoc THEN BadTable[];	IF ~file.readProtected THEN {	  IF file.version = BcdDefs.NullVersion THEN BadTable[];	  IF file.bcdSourceDate = NullTime THEN BadTable[]}}      ELSE {        IF file.bcdLoc # NullLoc THEN BadTable[];	IF file.version # BcdDefs.NullVersion THEN BadTable[];	IF file.bcdSourceDate # NullTime AND ~file.tableCompiled THEN BadTable[];	IF file.includes # IFNil THEN BadTable[];	IF file.containedBy # CFNil THEN BadTable[];	IF file.tableCompiled THEN BadTable[];	IF file.obsolete OR file.wrongIncludes THEN BadTable[]};	        IF file.source THEN {        IF file.sourceLoc = NullLoc THEN BadTable[];	IF file.sourceDate = NullTime THEN BadTable[]}      ELSE {        IF file.sourceLoc # NullLoc THEN BadTable[];	IF file.sourceDate # NullTime THEN BadTable[]};	      IF file.bad THEN {        IF ~file.obsolete AND ~file.wrongSource AND ~file.sourceButNoBcd 	AND ~file.wrongIncludes AND ~file.dependsOnBad	AND ~file.readProtected THEN	  BadTable[]};      EnumerateFilesIncludedBy[f, CheckOneIncFile];      RETURN[FALSE]};          CheckOneIncFile: PROC [i: IncludedFile] RETURNS [stop: BOOLEAN] = {      IF ifb[i].desc = IFDNil THEN BadTable[];      RETURN[FALSE]};            EnumerateFiles[CheckOneFileEntry]};      CheckIncFileDescriptions: PROC = {      CheckOneIncFileDesc: PROC [d: IncFileDesc] RETURNS [stop: BOOLEAN] = {      IF idb[d].name = NameNil THEN BadTable[];      IF idb[d].version = BcdDefs.NullVersion THEN BadTable[];      IF idb[d].file = FNil THEN {        IF idb[d].found OR idb[d].wrongVersion THEN BadTable[]}      ELSE IF idb[d].unknownVersion THEN BadTable[];      RETURN[FALSE]};          EnumerateIncludedFiles[CheckOneIncFileDesc]};      CheckContainingFiles: PROC = {      CheckOneContainingFile: PROC [c: ContainingFile] RETURNS [stop: BOOLEAN] = {      IF cfb[c].file = FNil THEN BadTable[];      RETURN[FALSE]};          EnumerateContainingFiles[CheckOneContainingFile]};      -- Write file information   tableFile: MFile.Handle _ NIL;  tableStream: MStream.Handle _ NIL;  header: ICLists.Header _ NIL;    PutTablesToFile: PROC = {    ENABLE      UNWIND => {        CloseOutputStream[];	MarkOutputFileBad[];	Finalize[]};    header _ zone.NEW[ICLists.HeaderObject];    InitHeader[];    OpenOutputStream[];    WriteStream[];    CloseOutputStream[];    IF header # NIL THEN zone.FREE[@header]};      InitHeader: PROC = {    OPEN header;    d, s: LONG CARDINAL;    versionIdent _ ICLists.VersionID;    creator _ Runtime.GetBcdTime[];    consistent _ ~badFiles;    circularity _ circular;    depths _ (ICDefs.switches['c] OR ICDefs.switches['o]);    containedBy _      depths OR      (ICDefs.switches['i] AND ICDefs.switches['v] AND ~ICDefs.switches['f]);    readSources _ ICDefs.switches['s];    allFiles _ ICDefs.switches['a];    nLocalBcds    _ ICDefs.nLocalBcds;     nRemoteBcds    _ ICDefs.nRemoteBcds;    nLocalSources _ ICDefs.nLocalSources;  nRemoteSources _ ICDefs.nRemoteSources;    nIncludes _ ICDefs.nIncludes;    d _ SIZE[ICLists.HeaderObject];    feOffset _ d;  d _ d + (s _ icTable.Bounds[fileType].size);    feLimit _ LOOPHOLE[s];    ifOffset _ d;  d _ d + (s _ icTable.Bounds[includeType].size);    ifLimit _ LOOPHOLE[s];    idOffset _ d;  d _ d + (s _ icTable.Bounds[incDescType].size);      idLimit _ LOOPHOLE[s];      cfOffset _ d;  d _ d + (s _ icTable.Bounds[containType].size);    cfLimit _ LOOPHOLE[s];    hOffset _ d;  d _ d + (s _ icTable.Bounds[hostType].size);    hLimit _ LOOPHOLE[s];    dOffset _ d;  d _ d + (s _ icTable.Bounds[dirType].size);    dLimit _ LOOPHOLE[s];    diOffset _ d;  d _ d + (s _ icTable.Bounds[depthType].size);    diLimit _ LOOPHOLE[s];    mOffset _ d;  d _ d + (s _ icTable.Bounds[markedType].size);    mLimit _ LOOPHOLE[s];    nOffset _ d;  d _ d + (s _ icTable.Bounds[nameType].size);    nLimit _ LOOPHOLE[s];    nPages _ Inline.LowHalf[      (d + Environment.wordsPerPage-1)/Environment.wordsPerPage]};      WriteStream: PROC = {    headerBytes: CARDINAL =      (SIZE[ICLists.HeaderObject] * Environment.bytesPerWord);    Stream.SetPosition[tableStream, 0];    [] _ Stream.PutBlock[      tableStream,       [blockPointer: LOOPHOLE[header],       startIndex: 0, stopIndexPlusOne: headerBytes]];    WriteTables[]};        WriteTables: PROC = {    WriteSubTable[ICLists.fileType];    WriteSubTable[ICLists.includeType];    WriteSubTable[ICLists.incDescType];    WriteSubTable[ICLists.containType];    WriteSubTable[ICLists.hostType];    WriteSubTable[ICLists.dirType];    WriteSubTable[ICLists.depthType];    WriteSubTable[ICLists.markedType];    WriteSubTable[ICLists.nameType]};    WriteSubTable: PROC [t: LongAlloc.Selector] = {    base: LongAlloc.Base;    words: LONG CARDINAL;    wordsToTransfer, bytesToTransfer: CARDINAL;    [base, words] _ icTable.Bounds[t];    WHILE words > 0 DO      wordsToTransfer _ (IF words > 32000 THEN 32000 ELSE Inline.LowHalf[words]);       bytesToTransfer _ wordsToTransfer*Environment.bytesPerWord;      [] _ Stream.PutBlock[        tableStream,         [blockPointer: base, startIndex: 0, stopIndexPlusOne: bytesToTransfer]];      words _ (words - wordsToTransfer);      base  _ (base  + wordsToTransfer)      ENDLOOP};         -- Management of output stream   OpenOutputStream: PROC = {    tableFile _ MFile.WriteOnly[      name: ICDefs.tableName, release: MFile.dontRelease, type: binary];    tableStream _ MStream.Create[file: tableFile, release: []]};        CloseOutputStream: PROC = {    IF tableFile # NIL THEN      MFile.SetReadProtect[file: tableFile, readProtected: FALSE];    IF tableStream # NIL THEN Stream.Delete[tableStream];    tableStream _ NIL;  tableFile _ NIL};        MarkOutputFileBad: PROC = {    IF tableFile # NIL THEN       MFile.SetReadProtect[file: tableFile, readProtected: TRUE]    ELSE {      outFile: MFile.Handle _ NIL;      outFile _ MFile.ReadOnly[        name: ICDefs.tableName, release: MFile.dontRelease	! MFile.Error => CONTINUE];      IF outFile # NIL THEN {        MFile.SetReadProtect[file: outFile, readProtected: TRUE];        MFile.Release[outFile]}}};             END.
-- ICReadFiles.mesa - Last modified by --   BGY     	11-Aug-84 13:22:08--   BTL  	15-Nov-83 16:45:44 --   RXJ     	12-Jul-83 13:57:46 DIRECTORY  BcdDefs USING [    CTIndex, CTNull, EXPIndex, FTIndex, FTSelf, IMPIndex, MTIndex,     NameRecord, NullName, SGIndex, VersionID, VersionStamp],  BcdOps USING [     BcdBase, CTHandle, EXPHandle, FTHandle, IMPHandle, MTHandle,     ProcessConfigs, ProcessExports, ProcessFiles, ProcessImports,    ProcessModules],  BcdUtilDefs USING [BcdBasePtr, BcdBases],  Environment USING [bytesPerPage, PageCount, PageNumber, wordsPerPage],  Exec USING [GetNameandPassword, Handle],  FileName USING [ResetVFN, UnpackFilename, VFN, VirtualFilenameObject],  FileTransfer USING [    ClientProc, Close, Confirmation, Connection, Create, Destroy, Error,    ErrorCode, FileInfo, LocalVFN, MessageProc, ReadNextStream, ReadStream,    SetPrimaryCredentials, SetProcs, VetoProc],  Heap USING [systemZone],  ICDefs USING [    Bug, CheckAbort, exec, globalDir, globalHost, inExec, Log, LogChar,    LogCR, LogLine, ownTable, Put, PutChar, PutCR, PutDecimal, switches, zone],  ICLists USING [    AddToIncludedList, containType, depthType, dirType, EnterBcd,    EnterSource, File, fileType, hostType, incDescType, IncFileDesc,    IncFileDescObject, includeType, markedType, MatchOneIncludedFile,    Name, nameType, NullTime, NullVersion, StringForName, VersionStamp],  Inline USING [LongCOPY],  LongAlloc USING [AddNotify, Base, DropNotify, Handle, Notifier, Top],  MFile USING [    EnumerateDirectory, EnumerateProc, Error, GetLength, GetTimes, Handle,    maxNameLength, ReadOnly, Release],  MSegment USING [Address, CopyIn, Create, Delete, Handle],  Profile USING [GetUser, String],  Stream USING [EndOfStream, GetBlock, Handle],  String USING [    AppendChar, AppendString, CopyToNewString, Empty, EquivalentString,    FreeString, MakeString, SubString, SubStringDescriptor],  Table USING [Base],  Time USING [Packed];  ICReadFiles: PROGRAM    IMPORTS       BcdOps, Exec, FileName, FileTransfer, Heap, ICDefs, ICLists, Inline,      LongAlloc, MFile, MSegment, Profile, Stream, String    EXPORTS ICDefs =  BEGIN OPEN ICDefs, ICLists;    TruncatedBcd: ERROR = CODE;  ErroneousBcd: ERROR = CODE;    bytesPerPage: CARDINAL = Environment.bytesPerPage;      onlyLocalFiles: PUBLIC BOOLEAN;    icExec: Exec.Handle _ NIL;  -- local copies of ICDefs variables  icTable: LongAlloc.Handle _ NIL;  icZone: UNCOUNTED ZONE _ NIL;    icConn: FileTransfer.Connection _ NIL;  bHeader: BcdOps.BcdBase _ NIL;      -- Bcd  bcd: BcdUtilDefs.BcdBasePtr _ NIL;  -- Bcd table bases  bcdVersion: VersionStamp;  bcdSourceDate: Time.Packed;  defModule, tableCompiled, config, packaged: BOOLEAN;  localBcdPages: Environment.PageCount;  z: UNCOUNTED ZONE _ Heap.systemZone;      feb: LongAlloc.Base;  -- file records  ifb: LongAlloc.Base;  -- included files  idb: LongAlloc.Base;  -- descriptions of included files   cfb: LongAlloc.Base;  -- containing files  hb:  LongAlloc.Base;  -- hosts  db:  LongAlloc.Base;  -- directories  dib: LongAlloc.Base;  -- file depth chain heads  mb:  LongAlloc.Base;  -- marked files  nb:  LongAlloc.Base;  -- names  UpdateBases: LongAlloc.Notifier = {    feb _ base[ICLists.fileType];      ifb _ base[ICLists.includeType];    idb _ base[ICLists.incDescType];    cfb _ base[ICLists.containType];    hb  _ base[ICLists.hostType];    db  _ base[ICLists.dirType];    dib _ base[ICLists.depthType];    mb  _ base[ICLists.markedType];    nb  _ base[ICLists.nameType]};         -- Initialization and finalization   InitFileReading: PUBLIC PROC = {    icExec _ ICDefs.exec;  icTable _ ICDefs.ownTable;  icZone _ ICDefs.zone;    icTable.AddNotify[UpdateBases];    nFiles _ nLocalBcds _ nRemoteBcds _ nLocalSources _ nRemoteSources _ 0;    onlyLocalFiles _ TRUE;    headingLogged _ FALSE;    OpenConnection[];    CreateBuffer[];    vfn _ icZone.NEW[FileName.VirtualFilenameObject _ [      host: NIL, directory: NIL, name: NIL, version: NIL]];    bcd _ icZone.NEW[BcdUtilDefs.BcdBases];    -- file name variables    dir _ icZone.NEW[StringBody[MFile.maxNameLength]];    properName _ icZone.NEW[StringBody[MFile.maxNameLength]];    ext _ icZone.NEW[StringBody[MFile.maxNameLength]];    nameWithExt _ icZone.NEW[StringBody[MFile.maxNameLength]]};    FinalizeFileReading: PUBLIC PROC = {    CloseConnection[];    IF headingLogged THEN {LogCR[];  headingLogged _ FALSE};     IF dir # NIL THEN icZone.FREE[@dir];    IF properName # NIL THEN icZone.FREE[@properName];    IF ext # NIL THEN icZone.FREE[@ext];    IF nameWithExt # NIL THEN icZone.FREE[@nameWithExt];    DestroyBuffer[];    IF vfn # NIL THEN icZone.FREE[@vfn];    IF bcd # NIL THEN icZone.FREE[@bcd];    IF icTable # NIL THEN icTable.DropNotify[UpdateBases];    icTable _ NIL;  icZone _ NIL;  icExec _ NIL};           -- Connection management   OpenConnection: PROC = {    userName, userPassword: Profile.String;        GetUserCredentials: PROC [name, password: Profile.String] = {      userName _ name;  userPassword _ password};          icConn _ FileTransfer.Create[];    FileTransfer.SetProcs[      conn: icConn, clientData: NIL,       messages: PutMessages, login: LoginUser];    Profile.GetUser[GetUserCredentials];    FileTransfer.SetPrimaryCredentials[      conn: icConn, user: userName, password: userPassword]};      PutMessages: FileTransfer.MessageProc = {    IF level = fatal THEN {       ICDefs.Put["Error: "L];      IF s1 # NIL THEN ICDefs.Put[s1];      IF s2 # NIL THEN ICDefs.Put[s2];      IF s3 # NIL THEN ICDefs.Put[s3];      IF s4 # NIL THEN ICDefs.Put[s4]}};      LoginUser: FileTransfer.ClientProc = {    user: STRING = [60];    password: STRING = [60];    IF inExec THEN {      Exec.GetNameandPassword[exec, user, password];      FileTransfer.SetPrimaryCredentials[icConn, user, password]}    ELSE ERROR ABORTED;    ICDefs.PutCR[]};      CloseConnection: PROC = {    IF icConn # NIL THEN {      FileTransfer.Close[icConn];  FileTransfer.Destroy[icConn];  icConn _ NIL}};              -- VFN management   vfn: FileName.VFN _ NIL;    ResetEntireVfn: PROC = INLINE {    FileName.ResetVFN[vfn: vfn, h: TRUE, d: TRUE, n: TRUE, v: TRUE]};      ResetVfnName: PROC = INLINE {    FileName.ResetVFN[vfn: vfn, h: FALSE, d: FALSE, n: TRUE, v: FALSE]};      ResetVfnDir: PROC = INLINE {    FileName.ResetVFN[vfn: vfn, h: FALSE, d: TRUE, n: FALSE, v: FALSE]};         -- File name manipulation    dir: LONG STRING _ NIL;  properName: LONG STRING _ NIL;  ext: LONG STRING _ NIL;  nameWithExt: LONG STRING _ NIL;    DirFromName: PROC [fullName, dir: LONG STRING] = {    OPEN String;    dir.length _ 0;    FOR i: CARDINAL DECREASING IN [0..fullName.length) DO      IF fullName[i] = '> THEN {        start: CARDINAL _ 0;	IF fullName[0] = '< THEN start _ 1;        FOR j: CARDINAL IN [start..i) DO AppendChar[dir, fullName[j]] ENDLOOP;	RETURN};      ENDLOOP};    SplitFileName: PROC [name, noExt, ext: LONG STRING] = {    OPEN String;    s: LONG STRING _ noExt;    noExt.length _ ext.length _ 0;    FOR i: CARDINAL IN [0..name.length) DO      IF name[i] = '. THEN s _ ext ELSE AppendChar[s, name[i]];      ENDLOOP};    StripExtension: PROC [name, noExt: LONG STRING] = {    OPEN String;    noExt.length _ 0;    FOR i: CARDINAL IN [0..name.length) DO      IF name[i] = '. THEN RETURN ELSE AppendChar[noExt, name[i]];      ENDLOOP};        AddExtension: PROC [name, ext, copy: LONG STRING] = {    OPEN String;    copy.length _ 0;  AppendString[copy, name];  AppendString[copy, ext]};         -- Exec window feedback   nFiles: PUBLIC CARDINAL _ 0;  nLocalBcds, nRemoteBcds, nLocalSources, nRemoteSources: PUBLIC CARDINAL _ 0;   NoteLocalSourceProcessed: PUBLIC PROC = {    nLocalSources _ nLocalSources+1;    IF ((nFiles _ nFiles+1) MOD 10) = 0 THEN {      ICDefs.PutDecimal[nFiles];  ICDefs.PutChar[' ]}};   NoteRemoteSourceProcessed: PUBLIC PROC = {    nRemoteSources _ nRemoteSources+1;    IF ((nFiles _ nFiles+1) MOD 10) = 0 THEN {      ICDefs.PutDecimal[nFiles];  ICDefs.PutChar[' ]}};   NoteLocalBcdProcessed: PUBLIC PROC = {    nLocalBcds _ nLocalBcds+1;    IF ((nFiles _ nFiles+1) MOD 10) = 0 THEN {      ICDefs.PutDecimal[nFiles];  ICDefs.PutChar[' ]}};   NoteRemoteBcdProcessed: PUBLIC PROC = {    nRemoteBcds _ nRemoteBcds+1;    IF ((nFiles _ nFiles+1) MOD 10) = 0 THEN {      ICDefs.PutDecimal[nFiles];  ICDefs.PutChar[' ]}};             -- Output to IncludeChecker.log   headingLogged: BOOLEAN _ FALSE;   LogHeadingIfNeeded: PROC = {    IF ~headingLogged THEN {      LogCR[];      LogLine["Problems encountered while reading files"L];  LogCR[];      headingLogged _ TRUE}};      LogRemoteName: PROC = {    SELECT TRUE FROM      String.EquivalentString[vfn.host, "ME"L] => NULL;      String.Empty[vfn.host] => NULL;      ENDCASE => {LogChar['[];  Log[vfn.host];  LogChar[']]};    SELECT TRUE FROM      String.Empty[dir] => NULL;      ENDCASE => {LogChar['<];  Log[dir];  LogChar['>]};    Log[nameWithExt]};         -- Buffer space management   buffer: MSegment.Handle _ NIL;  -- a data space  bufferSize: Environment.PageCount _ 0;  bufAddr: LONG POINTER _ NIL;   CreateBuffer: PROC = {    IF buffer # NIL THEN ICDefs.Bug["ICReadFiles: nonempty buffer"L];    bufferSize _ 20;    buffer _ MSegment.Create[        file: NIL, release: [],      fileBase: 0, pages: bufferSize, swapInfo: [uniform[size: 4]]];    bufAddr _ MSegment.Address[buffer]};      GrowBuffer: PROC [minPages: Environment.PageCount] = {    newSize: Environment.PageCount = ((minPages+3)/4 * 4);    newBuffer: MSegment.Handle = MSegment.Create[        file: NIL, release: [],      fileBase: 0, pages: newSize, swapInfo: [uniform[size: 4]]];    newBufAddr: LONG POINTER = MSegment.Address[newBuffer];    Inline.LongCOPY[      from: bufAddr, to: newBufAddr,      nwords: CARDINAL[bufferSize*Environment.wordsPerPage]];    MSegment.Delete[buffer];    buffer _ newBuffer;  bufferSize _ newSize;  bufAddr _ newBufAddr};        DestroyBuffer: PROC = {    IF buffer # NIL THEN {      MSegment.Delete[buffer];  buffer _ NIL;  bufferSize _ 0;  bufAddr _ NIL}};      	     -- ******************* File processing *******************   ReadAllFiles: PUBLIC PROC = {    vfn.host _ String.CopyToNewString[ICDefs.globalHost, z];    vfn.directory _ String.CopyToNewString[ICDefs.globalDir, z];    vfn.name _ String.CopyToNewString["*"L, z];    IF FileTransfer.LocalVFN[icConn, vfn] THEN {      AllLocalFiles[];  onlyLocalFiles _ TRUE}    ELSE {AllRemoteFiles[];  onlyLocalFiles _ FALSE};    ResetEntireVfn[]};      ReadRequestedFile: PUBLIC PROC [name: LONG STRING] = {    SetVfnFromRequestedFile[name];  -- fix extension later    IF FileTransfer.LocalVFN[icConn, vfn] THEN OneLocalFile[]    ELSE {OneRemoteFile[];  onlyLocalFiles _ FALSE};    ResetEntireVfn[]};      ReadClosureOfFiles: PUBLIC PROC = {    IF ~switches['a] THEN [] _ ReadOneLevelOfIncludedFiles[]    ELSE {  -- read all directly and indirectly included files on local disk      fileRead: BOOLEAN _ TRUE;      WHILE fileRead DO        fileRead _ ReadOneLevelOfIncludedFiles[];        ENDLOOP}};      ReadOneLevelOfIncludedFiles: PROC RETURNS [fileRead: BOOLEAN] = {    incName: ICLists.Name;    incNameString: LONG STRING;    currentIFDLimit: IncFileDesc = icTable.Top[ICLists.incDescType];    fileRead _ FALSE;    FOR i: IncFileDesc _ LOOPHOLE[LONG[0]], i + SIZE[ICLists.IncFileDescObject]    UNTIL i = currentIFDLimit DO      IF idb[i].lookedUp THEN LOOP;      IF idb[i].found OR idb[i].wrongVersion THEN  -- already read        idb[i].lookedUp _ TRUE      ELSE {         incName _ idb[i].name;        incNameString _ ICLists.StringForName[incName];        ReadRequestedFile[incNameString];        ICLists.MatchOneIncludedFile[i];        idb[i].lookedUp _ TRUE;	fileRead _ TRUE};      ENDLOOP};             SetVfnFromRequestedFile: PROC [name: LONG STRING] = {    fullDirGiven: BOOLEAN = (name[0] = '<);    FileName.UnpackFilename[name, vfn];    IF String.Empty[vfn.host] THEN      vfn.host _ String.CopyToNewString[globalHost, z];    IF String.Empty[vfn.directory] THEN      vfn.directory _ String.CopyToNewString[globalDir, z]    ELSE   -- prepend a user-given global directory name      IF ~fullDirGiven AND ~String.Empty[ICDefs.globalDir] THEN {        full: LONG STRING _ String.MakeString[	  z, vfn.directory.length + ICDefs.globalDir.length + 1];	String.AppendString[full, ICDefs.globalDir];  String.AppendChar[full, '>];	String.AppendString[full, vfn.directory];	ResetVfnDir[];  vfn.directory _ full}};		 -- ***** Local files *****	  allFiles: LONG STRING _ NIL;	  AllLocalFiles: PROC = {    OPEN String;    ENABLE UNWIND => CleanupAllLocalFiles[];    dir: LONG STRING = vfn.directory;    IF ~String.Empty[dir] THEN {  -- a local directory was specified       allFiles _ MakeString[icZone, dir.length + 2];      IF dir[0] = '> THEN        FOR i: CARDINAL IN [1..dir.length) DO AppendChar[allFiles, dir[i]] ENDLOOP      ELSE AppendString[allFiles, dir];      IF dir[dir.length - 1] # '> THEN AppendChar[allFiles, '>]}  -- trailing >    ELSE allFiles _ MakeString[icZone, 1];    AppendChar[allFiles, '*];    MFile.EnumerateDirectory[      name: allFiles, proc: ReadEnumeratedFile, which: filesOnly];    CleanupAllLocalFiles[]};        CleanupAllLocalFiles: PROC = {    IF allFiles # NIL THEN String.FreeString[icZone, allFiles];    allFiles _ NIL};      ReadEnumeratedFile: MFile.EnumerateProc = {    BEGIN    f: MFile.Handle _ NIL;    IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    SplitFileName[name, properName, ext];    SELECT TRUE FROM          String.EquivalentString[ext, "bcd"L] => {        NoteLocalBcdProcessed[];	DirFromName[fullName, dir];	f _ fileProc[access: readOnly, release: []	  ! MFile.Error =>	      SELECT code FROM	        conflictingAccess => GOTO InUse;	        protectionFault => GOTO ReadProtectedBcd;		noSuchFile => GOTO NotFound;	        ENDCASE => REJECT];	ReadLocalBcd[bcdFile: f, host: "ME"L, dir: dir];	MFile.Release[f]};            String.EquivalentString[ext, "mesa"L] => {	NoteLocalSourceProcessed[];	DirFromName[fullName, dir];	f _ fileProc[access: readOnly, release: []	  ! MFile.Error =>	      SELECT code FROM	        conflictingAccess => GOTO InUse;	        protectionFault => GOTO ReadProtectedSource;		noSuchFile => GOTO NotFound;	        ENDCASE => REJECT];	[] _ ICLists.EnterSource[	  host: "ME"L, dir: dir, file: properName,	  config: FALSE, packaged: FALSE, sourceDate: MFile.GetTimes[f].create];	MFile.Release[f]};	      String.EquivalentString[ext, "config"L] => {        NoteLocalSourceProcessed[];	DirFromName[fullName, dir];	f _ fileProc[access: readOnly, release: []	  ! MFile.Error =>	      SELECT code FROM	        conflictingAccess => GOTO InUse;	        protectionFault => GOTO ReadProtectedSource;		noSuchFile => GOTO NotFound;	        ENDCASE => REJECT];	[] _ ICLists.EnterSource[	  host: "ME"L, dir: dir, file: properName,	  config: TRUE, packaged: FALSE, sourceDate: MFile.GetTimes[f].create];	MFile.Release[f]};	        switches['k] AND String.EquivalentString[ext, "pack"L] => {        NoteLocalSourceProcessed[];	DirFromName[fullName, dir];	f _ fileProc[access: readOnly, release: []	  ! MFile.Error =>	      SELECT code FROM	        conflictingAccess => GOTO InUse;	        protectionFault => GOTO ReadProtectedSource;		noSuchFile => GOTO NotFound;	        ENDCASE => REJECT];	[] _ ICLists.EnterSource[	  host: "ME"L, dir: dir, file: properName,	  config: TRUE, packaged: TRUE, sourceDate: MFile.GetTimes[f].create];	MFile.Release[f]};	              ENDCASE;    EXITS      NotFound => NULL;      InUse => {        OPEN ICDefs;	LogHeadingIfNeeded[];	Log["  "L];  Log[fullName];  LogLine[" can't be accessed"L]};      ReadProtectedBcd => ProcessReadProtectedBcd[host: "ME"L, dir: dir];      ReadProtectedSource => {        OPEN ICDefs;	LogHeadingIfNeeded[];	Log["  "L];  Log[fullName];  LogLine[" is read protected"L]};    END;    RETURN[done: FALSE]};      ProcessReadProtectedBcd: PROC [host, dir: LONG STRING] = {    f: File _ ICLists.EnterBcd[      host: host, dir: dir, file: properName,      config: FALSE, packaged: FALSE, version: NullVersion, sourceDate: NullTime];    feb[f].readProtected _ TRUE};        	  OneLocalFile: PROC = {    file: MFile.Handle _ NIL;    IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    StripExtension[vfn.name, properName];    -- process a Bcd file, if any    AddExtension[properName, ".bcd"L, nameWithExt];    file _ MFile.ReadOnly[name: nameWithExt, release: []      ! MFile.Error =>          SELECT code FROM	    noSuchFile => CONTINUE;	    illegalName => NoteBadName[];	    protectionFault => {	      NoteLocalBcdProcessed[];	      ProcessReadProtectedBcd[host: vfn.host, dir: vfn.directory];	      CONTINUE};	    conflictingAccess => {NoteInUse[];  CONTINUE};	    ENDCASE => REJECT];      IF file # NIL THEN {      NoteLocalBcdProcessed[];      ReadLocalBcd[bcdFile: file, host: vfn.host, dir: vfn.directory];      MFile.Release[file]};    -- process a mesa source file, if any    AddExtension[properName, ".mesa"L, nameWithExt];    file _ NIL;    file _ MFile.ReadOnly[name: nameWithExt, release: []      ! MFile.Error =>          SELECT code FROM	    noSuchFile => CONTINUE;	    illegalName => NoteBadName[];	    conflictingAccess => {NoteInUse[];  CONTINUE};	    protectionFault => {NoteReadProtectedSource[];  CONTINUE};	    ENDCASE => REJECT];    IF file # NIL THEN {      NoteLocalSourceProcessed[];      [] _ ICLists.EnterSource[        host: vfn.host, dir: vfn.directory, file: properName,        config: FALSE, packaged: FALSE, sourceDate: MFile.GetTimes[file].create];      MFile.Release[file];      RETURN};    -- no mesa source file, look for config source    AddExtension[properName, ".config"L, nameWithExt];    file _ NIL;    file _ MFile.ReadOnly[name: nameWithExt, release: []      ! MFile.Error =>          SELECT code FROM	    noSuchFile => CONTINUE;	    illegalName => NoteBadName[];	    conflictingAccess => {NoteInUse[];  CONTINUE};	    protectionFault => {NoteReadProtectedSource[];  CONTINUE};	    ENDCASE => REJECT];    IF file # NIL THEN {      NoteLocalSourceProcessed[];      [] _ ICLists.EnterSource[        host: vfn.host, dir: vfn.directory, file: properName,        config: TRUE, packaged: FALSE, sourceDate: MFile.GetTimes[file].create];      MFile.Release[file];      RETURN};    -- no mesa or config source file, look for packager source    IF ~switches['k] THEN RETURN;    AddExtension[properName, ".pack"L, nameWithExt];    file _ NIL;    file _ MFile.ReadOnly[name: nameWithExt, release: []      ! MFile.Error =>          SELECT code FROM	    noSuchFile => CONTINUE;	    illegalName => NoteBadName[];	    conflictingAccess => {NoteInUse[];  CONTINUE};	    protectionFault => {NoteReadProtectedSource[];  CONTINUE};	    ENDCASE => REJECT];    IF file # NIL THEN {      NoteLocalSourceProcessed[];      [] _ ICLists.EnterSource[        host: vfn.host, dir: vfn.directory, file: properName,        config: TRUE, packaged: TRUE, sourceDate: MFile.GetTimes[file].create];      MFile.Release[file];      RETURN}};      NoteInUse: PROC = {    LogHeadingIfNeeded[];    Log["  "L];  Log[nameWithExt];  LogLine[" can't be accessed"L]};        NoteBadName: PROC = {    LogHeadingIfNeeded[];    Log["  "L];  Log[nameWithExt];  LogLine[" has an illegal name"L]};        NoteReadProtectedSource: PROC = {    LogHeadingIfNeeded[];    Log["  "L];  Log[nameWithExt];  LogLine[" is read protected"L]};            ReadLocalBcd: PROC [bcdFile: MFile.Handle, host, dir: LONG STRING] = {    MSegment.CopyIn[segment: buffer, file: bcdFile, fileBase: 0, count: 10];    bHeader _ LOOPHOLE[bufAddr, BcdOps.BcdBase];    IF bHeader.versionIdent # BcdDefs.VersionID THEN GOTO ObsoleteBcd;    localBcdPages _ CARDINAL[      (MFile.GetLength[bcdFile] + bytesPerPage)/bytesPerPage];    IF localBcdPages < bHeader.nPages THEN GOTO TruncatedFile;    IF bHeader.nPages > bufferSize THEN {      GrowBuffer[minPages: bHeader.nPages];      bHeader _ LOOPHOLE[bufAddr, BcdOps.BcdBase]};    IF bHeader.nPages > 10 THEN       MSegment.CopyIn[        segment: buffer, file: bcdFile, fileBase: 0, count: bHeader.nPages];    RecordBcdInfo[];    IF packaged AND ~switches['k] THEN RETURN;    IF config THEN      ProcessBinderBcd[host, dir ! ErroneousBcd => GOTO GarbageBcd]    ELSE      ProcessLocalCompilerBcd[bcdFile, host, dir         ! TruncatedBcd        => GOTO TruncatedFile;	  ErroneousBcd        => GOTO GarbageBcd];    EXITS      ObsoleteBcd => ProcessObsoleteBcd[host, dir];      TruncatedFile => {        LogHeadingIfNeeded[];	Log["  "L];  Log[nameWithExt];  Log[" is missing some pages"L]};      GarbageBcd => {        LogHeadingIfNeeded[];	Log["  "L];  Log[nameWithExt];	LogLine[" is bad: no symbols or has a bad included name!"L]}};      ProcessObsoleteBcd: PROC [host, dir: LONG STRING] = {    f: File _ ICLists.EnterBcd[      host: host, dir: dir, file: properName,      config: FALSE, packaged: FALSE, version: NullVersion, sourceDate: NullTime];    feb[f].obsolete _ TRUE};	  RecordBcdInfo: PROC = {    bcdVersion    _ bHeader.version;    defModule     _ bHeader.definitions;    tableCompiled _ bHeader.tableCompiled;    config        _ (bHeader.nConfigs # 0);    bcd^ _ [      ctb: LOOPHOLE[bHeader + bHeader.ctOffset],      mtb: LOOPHOLE[bHeader + bHeader.mtOffset],      lfb: LOOPHOLE[bHeader + bHeader.lfOffset],      etb: LOOPHOLE[bHeader + bHeader.expOffset],      itb: LOOPHOLE[bHeader + bHeader.impOffset],      sgb: LOOPHOLE[bHeader + bHeader.sgOffset],      ftb: LOOPHOLE[bHeader + bHeader.ftOffset],      ssb: LOOPHOLE[bHeader + bHeader.ssOffset],      enb: LOOPHOLE[bHeader + bHeader.enOffset],      tyb: LOOPHOLE[bHeader + bHeader.typOffset],      tmb: LOOPHOLE[bHeader + bHeader.tmOffset],      ntb: LOOPHOLE[bHeader + bHeader.ntOffset],      spb: LOOPHOLE[bHeader + bHeader.spOffset],      fpb: LOOPHOLE[bHeader + bHeader.fpOffset],      atb: LOOPHOLE[bHeader + bHeader.atOffset],      apb: LOOPHOLE[bHeader + bHeader.apOffset] ];    bcdSourceDate _ [bcd.ftb[bHeader.sourceFile].version.time];    packaged _ FALSE;    IF bHeader.repackaged THEN {      -- Bcd contains packaged subconfigs (may be packaged itself)      badBcd: BOOLEAN _ FALSE;      sourceSS: String.SubStringDescriptor;      packaged _ FALSE;  -- assume not packaged itself      SubStringForName[@sourceSS, bcd.ftb[bHeader.sourceFile].name        ! ErroneousBcd => {badBcd _ TRUE;  CONTINUE}];      IF ~badBcd AND SubStringEndsIn[@sourceSS, ".pack"L] THEN packaged _ TRUE}};  SubStringEndsIn: PROC [      ss: String.SubString, suf: LONG STRING] RETURNS [yes: BOOLEAN] = {    FOR i: CARDINAL IN [0..ss.length) DO      BEGIN      IF LowerCase[ss.base[ss.offset + i]] = LowerCase[suf[0]] THEN {        FOR j: CARDINAL IN [0..suf.length) DO          IF i + j >= ss.length	  OR LowerCase[ss.base[(ss.offset + i) + j]] # LowerCase[suf[j]]          THEN GOTO outer;          ENDLOOP;        IF i + suf.length < ss.length THEN GOTO outer;        RETURN[TRUE]};      EXITS outer => NULL;      END;      ENDLOOP;    RETURN[FALSE]};  LowerCase: PROC [c: CHARACTER] RETURNS [CHARACTER] = INLINE {    IF c IN ['A..'Z] THEN c _ c + ('a - 'A);    RETURN[c]};      	  ProcessBinderBcd: PROC [host, dir: LONG STRING] = {    f: File _ ICLists.EnterBcd[      host: host, dir: dir, file: properName,      config: TRUE, packaged:packaged, version: bcdVersion,       sourceDate: bcdSourceDate];    feb[f].tableCompiled _ tableCompiled;    feb[f].defModule _ FALSE;    feb[f].codeBound _ ~NotCodeBound[parent: BcdDefs.CTNull];    feb[f].symbolsBound _ ~NotSymbolsBound[parent: BcdDefs.CTNull];    EnterIncludesOfBinderBcd[f]};      NotCodeBound: PROC [      parent: BcdDefs.CTIndex] RETURNS [notCodeBound: BOOLEAN] = {      CheckOneConfig: PROC [        cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex] RETURNS [stop: BOOLEAN] = {      IF cth.config = parent THEN {        notCodeBound _ notCodeBound OR NotCodeBound[parent: cti];        notCodeBound _ notCodeBound OR NotCodeBoundModules[parent: cti]};      RETURN[FALSE]};        notCodeBound _ FALSE;    [] _ BcdOps.ProcessConfigs[bHeader, CheckOneConfig]};      NotCodeBoundModules: PROC [      parent: BcdDefs.CTIndex] RETURNS [notCodeBound: BOOLEAN] = {          CheckOneModule: PROC [        mth: BcdOps.MTHandle, mti: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] = {      codeseg: BcdDefs.SGIndex;      IF mth.config = parent THEN {        IF mth.file # BcdDefs.FTSelf THEN {          codeseg _ mth.code.sgi;	  notCodeBound _ notCodeBound OR bcd.sgb[codeseg].file # BcdDefs.FTSelf}};      RETURN[FALSE]};          notCodeBound _ FALSE;    [] _ BcdOps.ProcessModules[bHeader, CheckOneModule]};      NotSymbolsBound: PROC [      parent: BcdDefs.CTIndex] RETURNS [notSymbolsBound: BOOLEAN] = {      CheckOneConfig: PROC [        cth: BcdOps.CTHandle, cti: BcdDefs.CTIndex] RETURNS [stop: BOOLEAN] = {      IF cth.config = parent THEN {        notSymbolsBound _ notSymbolsBound OR NotSymbolsBound[parent: cti];        notSymbolsBound _ notSymbolsBound OR NotSymbolsBoundModules[parent: cti]};      RETURN[FALSE]};        notSymbolsBound _ FALSE;    [] _ BcdOps.ProcessConfigs[bHeader, CheckOneConfig]};      NotSymbolsBoundModules: PROC [      parent: BcdDefs.CTIndex] RETURNS [notSymbolsBound: BOOLEAN] = {          CheckOneModule: PROC [        mth: BcdOps.MTHandle, mti: BcdDefs.MTIndex] RETURNS [stop: BOOLEAN] = {      symseg: BcdDefs.SGIndex;      IF mth.config = parent THEN {        IF mth.file # BcdDefs.FTSelf THEN {          symseg _ mth.sseg;	  notSymbolsBound _ 	    notSymbolsBound OR bcd.sgb[symseg].file # BcdDefs.FTSelf}};      RETURN[FALSE]};          notSymbolsBound _ FALSE;    [] _ BcdOps.ProcessModules[bHeader, CheckOneModule]};          EnterIncludesOfBinderBcd: PROC [f: File] = {    OPEN BcdDefs;    version: VersionStamp;    name: NameRecord;    nameSS: String.SubStringDescriptor;      EnterIncludedConfig: PROC [        cth: BcdOps.CTHandle, cti: CTIndex] RETURNS [stop: BOOLEAN] = {      IF cth.config # CTNull THEN {  -- not outermost config        version _	  (IF cth.file = FTSelf THEN bcdVersion ELSE bcd.ftb[cth.file].version);	IF version = ICLists.NullVersion THEN RETURN[FALSE];        name _ cth.name;        SubStringForName[@nameSS, name];        ICLists.AddToIncludedList[          container: f, 	  included: @nameSS, version: version]};      RETURN[FALSE]};          EnterIncludedModule: PROC [        mth: BcdOps.MTHandle, mti: MTIndex] RETURNS [stop: BOOLEAN] = {      name _ mth.name;      SubStringForName[@nameSS, name];      version _ (        IF mth.file = FTSelf THEN bcdVersion ELSE bcd.ftb[mth.file].version);      IF version = ICLists.NullVersion THEN RETURN[FALSE];      ICLists.AddToIncludedList[        container: f, 	included: @nameSS, version: version];      RETURN[FALSE]};          EnterIncludedImports: PROC [        ith: BcdOps.IMPHandle, iti: IMPIndex] RETURNS [stop: BOOLEAN] = {      name _ ith.name;      SubStringForName[@nameSS, name];      version _ (        IF ith.file = FTSelf THEN bcdVersion ELSE bcd.ftb[ith.file].version);      IF version = ICLists.NullVersion THEN RETURN[FALSE];      ICLists.AddToIncludedList[        container: f, 	included: @nameSS, version: version];      RETURN[FALSE]};          EnterIncludedExports: PROC [        eth: BcdOps.EXPHandle, eti: EXPIndex] RETURNS [stop: BOOLEAN] = {      name _ eth.name;      SubStringForName[@nameSS, name];      version _ (        IF eth.file = FTSelf THEN bcdVersion ELSE bcd.ftb[eth.file].version);      IF version = ICLists.NullVersion THEN RETURN[FALSE];      ICLists.AddToIncludedList[        container: f, 	included: @nameSS, version: version];      RETURN[FALSE]};          [] _ BcdOps.ProcessConfigs[bHeader, EnterIncludedConfig];    [] _ BcdOps.ProcessModules[bHeader, EnterIncludedModule];    IF switches['b] THEN {      [] _ BcdOps.ProcessImports[bHeader, EnterIncludedImports];      [] _ BcdOps.ProcessExports[bHeader, EnterIncludedExports]}};      SubStringForName: PROC [ss: String.SubString, name: BcdDefs.NameRecord] = {    ss.base _ @bcd.ssb.string;    IF name = BcdDefs.NullName THEN ss.offset _ ss.length _ 0     ELSE {      ss.offset _ name;  ss.length _ bcd.ssb.size[name];      IF (ss.length > MFile.maxNameLength) OR (ss.length = 0) THEN        ERROR ErroneousBcd}};	      ProcessLocalCompilerBcd: PROC [file: MFile.Handle, host, dir: LONG STRING] = {    OPEN BcdDefs;    f: File;    mth: BcdOps.MTHandle = @bcd.mtb[FIRST[MTIndex]]; -- first module entry    version: VersionStamp;    nameSS: String.SubStringDescriptor;          EnterNeededBcd: PROC [        fth: BcdOps.FTHandle, fti: BcdDefs.FTIndex] RETURNS [stop: BOOLEAN] = {      IF fti = bHeader.sourceFile THEN RETURN[FALSE];      SubStringForName[@nameSS, fth.name];      RemoveExt[@nameSS];      version _ fth.version;      IF version = ICLists.NullVersion THEN RETURN[FALSE];      ICLists.AddToIncludedList[        container: f, 	included: @nameSS, version: version];      RETURN[FALSE]};	    f _ ICLists.EnterBcd[      host: host, dir: dir, file: properName,      config: FALSE, packaged:packaged, version: bcdVersion,       sourceDate: bcdSourceDate];    feb[f].defModule     _ defModule;    feb[f].tableCompiled _ tableCompiled;    feb[f].boundsCheck   _ mth.boundsChecks;    feb[f].nilCheck      _ mth.nilChecks;    feb[f].crossJumped   _ mth.crossJumped;    [] _ BcdOps.ProcessFiles[bHeader, EnterNeededBcd]};	  RemoveExt: PROC [ss: String.SubString] = {    FOR i: CARDINAL IN [0..ss.length) DO      IF ss.base[i + ss.offset] = '. THEN {ss.length _ i;  RETURN};      ENDLOOP};          -- ***** Remote files *****     stream: Stream.Handle _ NIL;  streamPage: Environment.PageNumber _ 0;  -- number of page next to be read   AllRemoteFiles: PROC = {    stream _ NIL;    stream _ FileTransfer.ReadStream[conn: icConn, files: vfn, veto: Confirm      ! FileTransfer.Error =>          SELECT code FROM	    skipFile => CONTINUE;	    illegalLogin => IF ~ICDefs.inExec THEN ERROR ABORTED;	    ENDCASE => REJECT];    WHILE stream # NIL DO      stream.options.signalEndOfStream _ TRUE;      ReadRemoteBcd[stream  -- only Bcds are confirmed currently        ! FileTransfer.Error =>            SELECT code FROM	      accessDenied => CONTINUE;	      retry => RETRY; 	      ENDCASE => REJECT];      stream _ FileTransfer.ReadNextStream[stream];      ENDLOOP};       OneRemoteFile: PROC = {    copyWithExt: LONG STRING;    StripExtension[vfn.name, properName];    copyWithExt _ String.MakeString[z, properName.length + 2];    AddExtension[properName, ".*"L, copyWithExt];    ResetVfnName[];  vfn.name _ copyWithExt;    stream _ NIL;    stream _ FileTransfer.ReadStream[conn: icConn, files: vfn, veto: Confirm      ! FileTransfer.Error =>          SELECT code FROM	    skipFile => CONTINUE;	    notFound => CONTINUE;	    illegalLogin => IF ~ICDefs.inExec THEN ERROR ABORTED;	    ENDCASE => REJECT];    WHILE stream # NIL DO      stream.options.signalEndOfStream _ TRUE;      ReadRemoteBcd[stream  -- only Bcds are confirmed currently        ! FileTransfer.Error =>            SELECT code FROM	      accessDenied => CONTINUE;	      retry => RETRY; 	      ENDCASE => REJECT];      stream _ FileTransfer.ReadNextStream[stream];      ENDLOOP};  Confirm: FileTransfer.VetoProc = {    OPEN String;    answer: FileTransfer.Confirmation _ skip;    source, target: FileTransfer.FileInfo;    IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    [source, target] _ info[icConn];    IF String.Empty[source.body] THEN      RETURN[confirm: skip, showDates: FALSE];    SplitFileName[source.body, properName, ext];    SELECT TRUE FROM          EquivalentString[ext, "bcd"L] => {        NoteRemoteBcdProcessed[];	AddExtension[properName, ".bcd"L, nameWithExt];	dir.length _ 0;  AppendString[dir, source.directory];	answer _ do};            EquivalentString[ext, "mesa"L] => {	NoteRemoteSourceProcessed[];        [] _ ICLists.EnterSource[	  host: vfn.host, dir: source.directory, file: properName,	  config: FALSE, packaged: FALSE, sourceDate: source.create]};	      EquivalentString[ext, "config"L] => {        NoteRemoteSourceProcessed[];        [] _ ICLists.EnterSource[	  host: vfn.host, dir: source.directory, file: properName,	  config: TRUE, packaged: FALSE, sourceDate: source.create]};	        switches['k] AND EquivalentString[ext, "pack"L] => {        NoteRemoteSourceProcessed[];        [] _ ICLists.EnterSource[	  host: vfn.host, dir: source.directory, file: properName,	  config: TRUE, packaged: TRUE, sourceDate: source.create]};	        ENDCASE;    RETURN[confirm: answer, showDates: FALSE]};      ReadRemoteBcd: PROC [stream: Stream.Handle] = {    onePage: BOOLEAN _ FALSE;    headerPages: CARDINAL;    streamPage _ 0;    -- get the first page, which has the header    [] _ Stream.GetBlock[sH: stream, block: [bufAddr, 0, bytesPerPage]      ! Stream.EndOfStream => {onePage _ TRUE;  CONTINUE}];    streamPage _ 1;    bHeader _ LOOPHOLE[bufAddr, BcdOps.BcdBase];    IF bHeader.versionIdent # BcdDefs.VersionID THEN GOTO ObsoleteBcd;    -- now get the remainder of the Bcd itself    headerPages _ bHeader.nPages;    IF headerPages > 1 AND onePage THEN GOTO UnexpectedEOS;    IF headerPages > bufferSize THEN {      GrowBuffer[minPages: headerPages];      bHeader _ LOOPHOLE[bufAddr, BcdOps.BcdBase]};    IF headerPages > 1 THEN {      bytesNeeded: CARDINAL = (headerPages-1)*bytesPerPage;      start: CARDINAL = bytesPerPage;  -- after one page      endPlusOne: CARDINAL = (start + bytesNeeded);      [] _ Stream.GetBlock[sH: stream, block: [bufAddr, start, endPlusOne]        ! Stream.EndOfStream => CONTINUE];      streamPage _ bHeader.nPages};    RecordBcdInfo[];    IF packaged AND ~switches['k] THEN RETURN;    IF config THEN      ProcessBinderBcd[vfn.host, dir ! ErroneousBcd => GOTO GarbageBcd]    ELSE      ProcessRemoteCompilerBcd[stream, vfn.host, dir];    EXITS      ObsoleteBcd => ProcessObsoleteBcd[vfn.host, dir];      GarbageBcd => {        LogHeadingIfNeeded[];	Log["  "L];  LogRemoteName[];	LogLine[" is bad (no symbols or bad included name)!"L]};      UnexpectedEOS => {        LogHeadingIfNeeded[];	Log["  Unexpected end of stream reading "L];  LogRemoteName[];	LogLine[" (bad Bcd?)"L]}};      ProcessRemoteCompilerBcd: PROC [      stream: Stream.Handle, host, dir: LONG STRING] = {    OPEN BcdDefs;    f: File;    mth: BcdOps.MTHandle = @bcd.mtb[FIRST[MTIndex]];  -- first module entry    version: VersionStamp;    nameSS: String.SubStringDescriptor;          EnterNeededBcd: PROC [        fth: BcdOps.FTHandle, fti: BcdDefs.FTIndex] RETURNS [stop: BOOLEAN] = {      IF fti = bHeader.sourceFile THEN RETURN[FALSE];      SubStringForName[@nameSS, fth.name];      RemoveExt[@nameSS];      version _ fth.version;      IF version = ICLists.NullVersion THEN RETURN[FALSE];      ICLists.AddToIncludedList[        container: f, 	included: @nameSS, version: version];      RETURN[FALSE]};	    f _ ICLists.EnterBcd[      host: host, dir: dir, file: properName,      config: FALSE, packaged:packaged, version: bcdVersion,       sourceDate: bcdSourceDate];    feb[f].defModule     _ defModule;    feb[f].tableCompiled _ tableCompiled;    feb[f].boundsCheck   _ mth.boundsChecks;    feb[f].nilCheck      _ mth.nilChecks;    feb[f].crossJumped   _ mth.crossJumped;    [] _ BcdOps.ProcessFiles[bHeader, EnterNeededBcd]};      END.            
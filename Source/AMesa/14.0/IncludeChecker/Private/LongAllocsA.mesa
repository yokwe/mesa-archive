-- File LongAllocsA.mesa - Last modified by--   RES  	14-Oct-81 13:15:01--   BXM  	20-Aug-81 11:52:50--   EXS          	July 25, 1980  4:02 PM--   BTL  	 9-May-83 17:17:20DIRECTORY  LongAlloc USING [Base, Index, OrderedIndex, Selector],  LongAllocOps USING [    BaseSeq, BasesHandle, Chunk, ChunkHandle, CIndex, GrowTable, Handle,     InstanceData, NullChunkIndex];LongAllocsA: MONITOR LOCKS h USING h: Handle    IMPORTS LongAllocOps    EXPORTS LongAlloc =  BEGIN OPEN LongAlloc, LongAllocOps;    InstanceData: PUBLIC TYPE = LongAllocOps.InstanceData;  Failure: PUBLIC ERROR [h: Handle, table: Selector] = CODE;  Overflow: PUBLIC SIGNAL [    h: Handle, table: Selector] RETURNS [extra: CARDINAL] = CODE;    -- stack allocation from subzones  Words: PUBLIC ENTRY PROC [      h: Handle, table: Selector, size: CARDINAL] RETURNS [index: OrderedIndex] = {    index _ WordsInternal[h, table, size ! UNWIND => NULL]};  WordsInternal: INTERNAL PROC [      h: Handle, table: Selector, size: CARDINAL] RETURNS [OrderedIndex] = {    index: LONG CARDINAL = h.top[table];    newTop: LONG CARDINAL = (index + size);    IF newTop > h.limit[table] THEN LongAllocOps.GrowTable[h, table, newTop];     h.top[table] _ newTop;    RETURN[LOOPHOLE[index]]};          -- linked list allocation    GetChunk: PUBLIC ENTRY PROC [      h: Handle, size: CARDINAL, table: Selector] RETURNS [Index] = {    ENABLE UNWIND => NULL;    ch: ChunkHandle = h.chunks[table];    cb: Base = h.base[table];    q: CIndex;    IF ch = NIL THEN ERROR Failure[h, table];    size _ MAX[size, SIZE[Chunk]];    BEGIN    IF size IN [ch.firstSmall..ch.firstSmall+ch.nSmall) THEN {       offset: CARDINAL = (size - ch.firstSmall);      q _ ch.smallLists[offset];      IF q # NullChunkIndex THEN {        ch.smallLists[offset] _ cb[q].fLink;         GO TO found}};    q _ GetRoverChunk[h, size, table];    IF q # NullChunkIndex THEN GO TO found;    q _ WordsInternal[h, table, size ! Failure => GO TO noneAtEnd];    EXITS      noneAtEnd => {        -- none the right size, no space at the end, and no big ones to split	FOR s: CARDINAL IN [ch.firstSmall.. ch.firstSmall+ch.nSmall) DO          offset: CARDINAL = (s - ch.firstSmall);          r: CIndex _ ch.smallLists[offset];          WHILE r # NullChunkIndex DO            next: CIndex = cb[r].fLink;	    FreeRoverChunk[h: h, index: r, size: s, table: table];	    r _ next;	    ENDLOOP;          ch.smallLists[offset] _ NullChunkIndex;          ENDLOOP;        -- now all possible merges of free nodes can happen        q _ GetRoverChunk[h, size, table];        IF q = NullChunkIndex THEN ERROR Failure[h, table]};      found => NULL    END;    h.base[table][q].free _ FALSE;    RETURN[q]};  GetRoverChunk: INTERNAL PROC [      h: Handle, size: CARDINAL, table: Selector] RETURNS [Index] = {    ch: ChunkHandle = h.chunks[table];    cb: Base = h.base[table];    p, q, next: CIndex;    nodeSize: CARDINAL;    n: INTEGER;    BEGIN    IF (p _ ch.chunkRover) = NullChunkIndex THEN GO TO notFound;    -- search for a chunk to allocate    DO      nodeSize _ cb[p].size;      WHILE (next _ p + nodeSize) # LOOPHOLE[h.top[table], CIndex] AND cb[next].free DO	cb[cb[next].bLink].fLink _ cb[next].fLink;	cb[cb[next].fLink].bLink _ cb[next].bLink;	cb[p].size _ nodeSize _ (nodeSize + cb[next].size);	ch.chunkRover _ p; -- in case next = chunkRover	ENDLOOP;      SELECT n _ (nodeSize - size) FROM	= 0 => {	  IF cb[p].fLink = p THEN ch.chunkRover _ NullChunkIndex	  ELSE {	    ch.chunkRover _ cb[cb[p].bLink].fLink _ cb[p].fLink;	    cb[cb[p].fLink].bLink _ cb[p].bLink};	  q _ p;	  GO TO found};	>= SIZE[Chunk] => {	  cb[p].size _ n;  ch.chunkRover _ p; q _ p + n;  	  GO TO found};	ENDCASE;      IF (p _ cb[p].fLink) = ch.chunkRover THEN GO TO notFound;      ENDLOOP;    EXITS       found => NULL;       notFound => q _ NullChunkIndex;    END;    RETURN[q]};  FreeChunk: PUBLIC ENTRY PROC [      h: Handle, index: Index, size: CARDINAL, table: Selector] = {    ENABLE UNWIND => NULL;    ch: ChunkHandle = h.chunks[table];    cb: Base = h.base[table];    p: CIndex = LOOPHOLE[index];    IF ch = NIL THEN ERROR Failure[h, table];    cb[p].size _ size _ MAX[size, SIZE[Chunk]];    IF size IN [ch.firstSmall..ch.firstSmall+ch.nSmall) THEN {      offset: CARDINAL = size - ch.firstSmall;      cb[p].fLink _ ch.smallLists[offset];      ch.smallLists[offset] _ p;      -- don't set cb[p].free _ TRUE; to avoid coalescing nodes      cb[p].bLink _ NullChunkIndex} -- note, only singly linked    ELSE FreeRoverChunk[h: h, index: index, size: size, table: table]};  FreeRoverChunk: INTERNAL PROC [      h: Handle, index: Index, size: CARDINAL, table: Selector] = {    ch: ChunkHandle = h.chunks[table];    cb: Base = h.base[table];    p: CIndex = LOOPHOLE[index];    IF ch = NIL THEN ERROR Failure[h, table];    cb[p].size _ size _ MAX[size, SIZE[Chunk]];    IF ch.chunkRover = NullChunkIndex THEN      ch.chunkRover _ cb[p].fLink _ cb[p].bLink _ p    ELSE {      rover: CIndex = ch.chunkRover;      cb[p].fLink _ cb[rover].fLink;      cb[cb[p].fLink].bLink _ p;      cb[p].bLink _ rover;      cb[rover].fLink _ p};    cb[p].free _ TRUE};      -- queries    Bounds: PUBLIC ENTRY PROC [      h: Handle, table: Selector] RETURNS [base: Base, size: LONG CARDINAL] = {    RETURN[h.base[table], h.top[table]]};  Top: PUBLIC ENTRY PROC [h: Handle, table: Selector] RETURNS [OrderedIndex] = {    RETURN[ LOOPHOLE[h.top[table]] ]};  END.
-- File LongAllocsB.mesa - Last modified by--   BXM  	20-Aug-81 11:37:38--   RES  	28-Jan-82 10:22:18--   CXH   	13-May-83 17:49:11--   RXJ     	20-May-83 10:41:22--   BTL  	 8-Dec-83  0:25:31DIRECTORY  LongAlloc USING [    Base, defaultChunkType, defaultTileSize, Failure, Notifier, Overflow,    Selector, TableInfo],  LongAllocOps USING [    BaseSeq, BasesHandle, ChunkHandle, ChunkObject, ChunkSeq, Handle,     InstanceData, NotifyChainHandle, NotifyNode, NullChunkIndex,    SizeSeq, SpaceSeq],  Environment USING [maxPagesInVM, PageCount, PageOffset, wordsPerPage],  File USING [nullFile],  Heap USING [Create, Delete],  Inline USING [LongCOPY, LongDiv],  Space USING [Allocate, Deallocate, Interval, MapAt, unknownUsage, UnmapAt];LongAllocsB: MONITOR LOCKS h USING h: Handle    IMPORTS LongAlloc, Heap, Inline, Space    EXPORTS LongAlloc, LongAllocOps =  BEGIN OPEN LongAlloc, LongAllocOps;  InstanceData: PUBLIC TYPE = LongAllocOps.InstanceData;  fileTileSize: CARDINAL = 32;  -- must be >= tileSize;    PagesForWords: PROC [words: LONG CARDINAL] RETURNS [CARDINAL] = {    RETURN[      Inline.LongDiv[        (words + Environment.wordsPerPage-1), Environment.wordsPerPage]]};	  -- stack allocation from subzones  GrowTable: PUBLIC INTERNAL PROC [      h: Handle, table: Selector, newTop: LONG CARDINAL] =     BEGIN    newPages: CARDINAL = PagesForWords[newTop+1];      -- N.B. the last word of the VM for the table is never allocated    newTiles: CARDINAL = ((newPages+h.tileSize-1)/h.tileSize) * h.tileSize;    IF newPages > h.vmPages[table] THEN {      extra: CARDINAL = SIGNAL Overflow[h, table];      newVM: CARDINAL = (newPages + extra);      newSpace: Space.Interval = Space.Allocate[count: newVM];      oldSpace: Space.Interval = h.spaces[table];      tilePages: CARDINAL = MIN[newTiles, newVM];      o: LONG POINTER _ oldSpace.pointer;      n: LONG POINTER _ newSpace.pointer;      nwords: LONG CARDINAL _ h.top[table];      chunkSize: LONG CARDINAL;      [] _ Space.MapAt[        at: [pointer: newSpace.pointer, count: tilePages], 	window: [file: File.nullFile, base: NULL, count: tilePages],	usage: -- alloc -- Space.unknownUsage, swapUnits: [uniform[h.tileSize]]];      WHILE nwords > 0 DO        chunkSize _ MIN[nwords, LAST[CARDINAL]];	Inline.LongCOPY[from: o, to: n, nwords: CARDINAL[chunkSize]];	o _ (o + chunkSize);  n _ (n + chunkSize);	nwords _ (nwords - chunkSize);	ENDLOOP;      DeleteZone[oldSpace, h.limit[table]];      h.spaces[table] _ newSpace;      h.base[table] _ LOOPHOLE[newSpace.pointer];      h.vmPages[table] _ newVM;      h.limit[table] _ LONG[tilePages]*Environment.wordsPerPage - 1;      RunNotifierChain[h]}    ELSE {      deltaPages: LONG CARDINAL =        (MIN[LONG[newTiles], h.vmPages[table]]) - PagesForWords[h.limit[table]];      [] _ Space.MapAt[        at: [pointer: h.base[table] + h.limit[table]+1, count: deltaPages], 	window: [file: File.nullFile, base: NULL, count: deltaPages],	usage: -- alloc -- Space.unknownUsage, swapUnits: [uniform[h.tileSize]]];      h.limit[table] _ h.limit[table] + deltaPages*Environment.wordsPerPage};    END;      -- initialization, expansion and termination  DeleteZone: PROC [s: Space.Interval, tableMax: LONG CARDINAL] = {    ENABLE UNWIND => NULL;    p: LONG ORDERED POINTER _ LOOPHOLE[s.pointer];    limit: LONG ORDERED POINTER _ p + tableMax;    WHILE p <= limit DO      si: Space.Interval = Space.UnmapAt[p, wait];      p _ LOOPHOLE[si.pointer + si.count*Environment.wordsPerPage];      ENDLOOP;    Space.Deallocate[s]};  Create: PUBLIC PROC [        weights: DESCRIPTOR FOR ARRAY OF TableInfo,        tileSize: CARDINAL _ defaultTileSize]       RETURNS [h: Handle] = {    az: UNCOUNTED ZONE = Heap.Create[initial: 1];     cnt: CARDINAL = LENGTH[weights];    h _ az.NEW[InstanceData _ [      nTables: cnt, z: az,      tileSize: tileSize, notifiers: NIL,      base: az.NEW[BaseSeq[cnt]],      spaces: az.NEW[SpaceSeq[cnt]],      chunks: az.NEW[ChunkSeq[cnt]],      top: az.NEW[SizeSeq[cnt]],      limit: az.NEW[SizeSeq[cnt]],      vmPages: az.NEW[SizeSeq[cnt]],      clientData: NIL]];    IF tileSize >= fileTileSize THEN ERROR;    FOR i: CARDINAL IN [0..cnt) DO InitTable[h, i, weights[i]] ENDLOOP};  InitTable: PROC [h: Handle, table: Selector, tableInfo: TableInfo] = {    max: CARDINAL _ tableInfo.initialVMemPages;    ipages: CARDINAL _ tableInfo.initialPages;    IF max = 0 OR ipages = 0 THEN ERROR Failure[h, table];    IF ipages > max OR max > Environment.maxPagesInVM THEN      ERROR Failure[h, table];    h.vmPages[table] _ max;    h.spaces[table] _ Space.Allocate[count: max];    h.base[table] _ LOOPHOLE[h.spaces[table].pointer];    h.top[table] _ h.limit[table] _ 0;    h.chunks[table] _ NIL;    [] _ Space.MapAt[      at: [pointer: h.spaces[table].pointer, count: ipages],       window: [file: File.nullFile, base: NULL, count: ipages],      usage: -- alloc -- Space.unknownUsage, swapUnits: [uniform[h.tileSize]]];    h.limit[table] _ LONG[ipages]*Environment.wordsPerPage - 1};  ResetTable: PUBLIC ENTRY PROC [      h: Handle, table: Selector, tableInfo: TableInfo] = {    ENABLE UNWIND => NULL;    DeleteZone[h.spaces[table], h.limit[table]];    InitTable[h, table, tableInfo];    RunNotifierChain[h]};  Destroy: PUBLIC PROC [h: Handle] = {DestroyEntry[h]; Heap.Delete[h.z]};  DestroyEntry: ENTRY PROC [h: Handle] = {    ENABLE UNWIND => NULL;    i: CARDINAL;    FOR i IN [0..h.nTables) DO      h.base[i] _ NIL;      ENDLOOP;    RunNotifierChain[h];    FOR i IN [0..h.nTables) DO DeleteZone[h.spaces[i], h.limit[i]] ENDLOOP};  Reset: PUBLIC ENTRY PROC [h: Handle] = {    ENABLE UNWIND => NULL;    FOR i: CARDINAL IN [0..h.nTables) DO       h.top[i] _ 0;      ResetChunkInternal[h, i];      ENDLOOP};  Chunkify: PUBLIC ENTRY PROC [      h: Handle, table: Selector _ defaultChunkType,       firstSmall: CARDINAL _ 3, nSmall: CARDINAL _ 4] = {    ENABLE UNWIND => NULL;    ch: ChunkHandle _ h.chunks[table];    IF ch # NIL THEN ERROR Failure[h, table];    ch _ h.z.NEW[ChunkObject[nSmall]];    ch.firstSmall _ firstSmall;    h.chunks[table] _ ch;    ResetChunkInternal[h, table]};  UnChunkify: PUBLIC ENTRY PROC [h: Handle, table: Selector] = {    ENABLE UNWIND => NULL;    IF h.chunks[table] = NIL THEN RETURN;    h.z.FREE[@h.chunks[table]]};  Trim: PUBLIC ENTRY PROC [h: Handle, table: Selector, size: LONG CARDINAL] = {    ENABLE UNWIND => NULL;    IF size <= h.top[table] THEN {      h.top[table] _ size;  ResetChunkInternal[h, table]}    ELSE ERROR Failure[h, table]};  ResetChunk: PUBLIC ENTRY PROC [h: Handle, table: Selector] = {    ResetChunkInternal[h, table ! UNWIND => NULL]};      ResetChunkInternal: INTERNAL PROC [h: Handle, table: Selector] = {    ch: ChunkHandle _ h.chunks[table];    IF ch = NIL THEN RETURN;    ch.chunkRover _ NullChunkIndex;    FOR i: CARDINAL IN [0..ch.nSmall) DO      ch.smallLists[i] _ NullChunkIndex;      ENDLOOP};        -- Notifier stuff    AddNotify: PUBLIC ENTRY PROC [h: Handle, proc: LongAlloc.Notifier] = {    ENABLE UNWIND => NULL;    p: NotifyChainHandle = h.z.NEW[NotifyNode _ [      notifier: proc,       link: h.notifiers]];    h.notifiers _ p;    proc[DESCRIPTOR[h.base, h.nTables]]};  DropNotify: PUBLIC ENTRY PROC [h: Handle, proc: LongAlloc.Notifier] = {    ENABLE UNWIND => NULL;    p, q: NotifyChainHandle;    IF h.notifiers = NIL THEN RETURN;    p _ h.notifiers;    IF p.notifier = proc THEN h.notifiers _ p.link    ELSE {      WHILE TRUE DO	q _ p;	p _ p.link;	IF p = NIL THEN RETURN;	IF p.notifier = proc THEN EXIT	ENDLOOP;      q.link _ p.link};    h.z.FREE[@p]};      RunNotifierChain: INTERNAL PROC [h: Handle] = {    FOR p: NotifyChainHandle _ h.notifiers, p.link UNTIL p = NIL DO      p.notifier[DESCRIPTOR[h.base, h.nTables]];      ENDLOOP};               -- client data stuff     GetZone: PUBLIC ENTRY PROC [h: Handle] RETURNS [UNCOUNTED ZONE]= {    RETURN[h.z]};  SetClientData: PUBLIC ENTRY PROC [h: Handle, data: LONG POINTER]= {    h.clientData _ data};  GetClientData: PUBLIC ENTRY PROC [h: Handle] RETURNS [LONG POINTER]= {    RETURN[h.clientData]};  END.
-- ICTool.mesa - Last edited by--   BGY     	17-Jan-83 16:42:11--   BTL  	16-Nov-83 12:18:40DIRECTORY  CmFile USING [    Close, Error, FindSection, Handle, NextValue, TableError, UserDotCmOpen],  Exec USING [Outcome],  Expand USING [ExpandString, defaultMask, AbortProcType, UnknownCommandFile],  Format USING [StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, line0, line1, line2, line3, line4, ProcType, StringItem],  Heap USING [systemZone],  ICDefs USING [ToolInterface],  Menu USING [Handle, Instantiate, Make, MCRType],  MFile USING [Access, Acquire, dontRelease, Error, ErrorCode, Handle, Release],  MStream USING [Error, Handle, ReadOnly, ReleaseData],  Profile USING [debugging],  Process USING [Detach],  Put USING [Line, Text, Char, CR],  Runtime USING [GetBcdTime, IsBound],  Stream USING [EndOfStream, GetChar, Delete],  String USING [    AppendChar, AppendCharAndGrow, AppendExtensionIfNeeded, AppendString,    AppendStringAndGrow, CopyToNewString, Empty, FreeString],  StringLookUp USING [noMatch, TableDesc],  Time USING [Append, Unpack],  Token USING [FreeTokenString, Item, NilData, SyntaxError],  Tool USING [    Create, Destroy, MakeFormSW, MakeMsgSW, MakeSWsProc, MakeTTYSW,    UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  UserTerminal USING [BlinkDisplay],  Window USING [BitmapPlace, Handle, Place];ICTool: MONITOR    IMPORTS      CmFile, Expand, FormSW, Heap, ICDefs, Menu, MFile, MStream, Process,      Profile, Put, Runtime, Stream, String, Time, Token, Tool, UserInput,      UserTerminal, Window    EXPORTS ICDefs =  BEGIN  -- TYPEs  SwitchNames: TYPE = {    all, binder, command, debug, fast, includes, packagerCmd, limit,    multiple, notbad, order, pause, imports, tables, verbose, none};  StringNames: TYPE = {listfile, commandfile, host, directory, source, dffile};    DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [  -- Message subwindow stuff    msgSW(0):    Window.Handle _ NIL,    ttySW(2):    Window.Handle _ NIL,    formSW(4):   Window.Handle _ NIL,    switch(6):   ARRAY SwitchNames OF BOOLEAN _ ALL[FALSE],    menu(22):    Menu.Handle _ NIL,    formOSW(24): Window.Handle _ NIL,    menuO(26):   Menu.Handle _ NIL,    strings(28): ARRAY StringNames OF LONG STRING _ ALL[NIL]];  tempHandle: TYPE = LONG POINTER TO tempData;  tempData: TYPE = MACHINE DEPENDENT RECORD [    opt(0): ARRAY SwitchNames OF BOOLEAN _ ALL[FALSE]];    Permissions: TYPE = {overWrite, cantOverWrite};  ErrorType: TYPE = {    fileDoesNotExist, improperFile, improperAccess, noFile, noOverWrite};  AcquistionError: SIGNAL [type: ErrorType, file: LONG STRING] = CODE; -- Variable declarations  toolData: DataHandle _ NIL;  dfUser: BOOLEAN _ FALSE;  -- [DFTool] section in User.cm (i.e. DF user)  busy, optionBusy: BOOLEAN _ FALSE;  condition: CONDITION;  tmp: tempHandle _ NIL;  wh: Window.Handle;  -- Tool's window  oh: Window.Handle;  -- Options window  systemZone: UNCOUNTED ZONE _ NIL;  buf: LONG STRING _ NIL;    Initialize: PROC = {  -- see GetSwitches before changing defaults    toolData.switch[all] _ TRUE;    toolData.switch[verbose] _ TRUE;    toolData.switch[order] _ TRUE;    toolData.switch[includes] _ TRUE;    toolData.switch[binder] _ TRUE;    toolData.switch[fast] _ TRUE;    toolData.switch[imports] _ TRUE;    toolData.switch[packagerCmd] _ TRUE;    toolData.switch[debug] _ Profile.debugging;    toolData.strings[host] _ toolData.strings[directory] _ NIL;    toolData.strings[source] _ toolData.strings[dffile] _ NIL;    optionBusy _ FALSE;    SetUpOptionsFromUserCm[]};      SetUpOptionsFromUserCm: PROC = {    Option: TYPE = MACHINE DEPENDENT {      defaultSwitches(0), noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = Option[defaultSwitches..defaultSwitches];    optionTable: ARRAY DefinedOption OF LONG STRING _ [      defaultSwitches: "DefaultSwitches"L];    userCm: CmFile.Handle;    CheckType: PROC [        h: CmFile.Handle, table: StringLookUp.TableDesc]      RETURNS [index: CARDINAL] = CmFile.NextValue;    MyNextValue: PROC [        h: CmFile.Handle,        table: LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]      RETURNS [index: Option] = LOOPHOLE[CheckType];    userCm _ CmFile.UserDotCmOpen[ ! CmFile.Error => GOTO NoUserDotCm];    IF CmFile.FindSection[userCm, "IncludeChecker"L] THEN       DO        SELECT MyNextValue[userCm, DESCRIPTOR[optionTable]	    ! CmFile.TableError => RESUME] FROM          noMatch => EXIT;          defaultSwitches => {	    temp: LONG STRING _ Token.Item[userCm	      ! Token.NilData, Token.SyntaxError => GOTO TokenError];            SetDefaultSwitches[temp];            temp _ Token.FreeTokenString[temp]};          ENDCASE;        ENDLOOP;    [] _ CmFile.Close[userCm];    EXITS NoUserDotCm, TokenError => NULL};      SetDefaultSwitches: PROC [sw: LONG STRING] = {    sense: BOOLEAN _ TRUE;    IF String.Empty[sw] THEN RETURN;    FOR i: CARDINAL IN [0..sw.length) DO      c: CHARACTER _ sw[i];      IF c IN ['A..'Z] THEN c _ c + ('a - 'A);      SELECT c FROM	'-, '~ => sense _ FALSE;	'a => {toolData.switch[all] _ sense;  sense _ TRUE};	'b => {toolData.switch[binder] _ sense;  sense _ TRUE};	'c => {toolData.switch[command] _ sense;  sense _ TRUE};	'd => {toolData.switch[debug] _ sense;  sense _ TRUE};	'f => {toolData.switch[fast] _ sense;  sense _ TRUE};	'i => {toolData.switch[includes] _ sense;  sense _ TRUE};	'k => {toolData.switch[packagerCmd] _ sense;  sense _ TRUE};	'l => {toolData.switch[limit] _ sense;  sense _ TRUE};	'm => {toolData.switch[multiple] _ sense;  sense _ TRUE};	'n => {toolData.switch[notbad] _ sense;  sense _ TRUE};	'o => {toolData.switch[order] _ sense;  sense _ TRUE};	'p => {toolData.switch[pause] _ sense;  sense _ TRUE};	'r => {toolData.switch[imports] _ sense;  sense _ TRUE};	's => {  -- crufty Star hack: same as /c-i-o	   toolData.switch[command] _ sense;	   toolData.switch[includes] _ toolData.switch[order] _ ~sense;	   sense _ TRUE};	't => {toolData.switch[tables] _ sense;  sense _ TRUE};	'v => {toolData.switch[verbose] _ sense;  sense _ TRUE};	ENDCASE;      ENDLOOP};      -- File access routines  FileExists: PROC [file: LONG STRING] RETURNS [itExists: BOOLEAN] = {    fileHandle: MFile.Handle _ NIL;    itExists _ TRUE;    fileHandle _ MFile.Acquire[file, anchor, MFile.dontRelease      ! MFile.Error =>          IF code = noSuchFile THEN {fileHandle _ NIL; itExists _ FALSE; CONTINUE}          ELSE REJECT];    IF fileHandle # NIL THEN {MFile.Release[fileHandle];  RETURN[TRUE]}};  GetReadStream: PROC [      fileName: LONG STRING] RETURNS [streamHandle: MStream.Handle] = {    streamReleaseData: MStream.ReleaseData _ [NIL, NIL];    IF fileName = NIL THEN SIGNAL AcquistionError[noFile, NIL]  -- no file to open    ELSE RETURN[      MStream.ReadOnly[        fileName, streamReleaseData           ! MStream.Error =>  -- catches the case where the file doesn't exists              IF code = fileNotAvailable THEN                SIGNAL AcquistionError[fileDoesNotExist, fileName]]]};  CloseUpStream: PROC [stream: MStream.Handle] RETURNS [MStream.Handle] = {    Stream.Delete[stream]; RETURN[NIL]}; -- FormSW support routines  -- see Initialize also  GetSwitches: PROC[Switches: LONG POINTER TO LONG STRING]={    index: SwitchNames;    letters: ARRAY SwitchNames OF CHARACTER = [      'a, 'b, 'c, 'd, 'f, 'i, 'k, 'l, 'm, 'n, 'o, 'p, 'r, 't, 'v, '@];    Switches.length _ 0;    String.AppendChar[Switches^, '/];    FOR index IN [all..verbose] DO      SELECT index FROM        all, verbose, order, includes, binder, fast, imports, packagerCmd =>          IF ~toolData.switch[index] THEN {            String.AppendChar[Switches^, '-];            String.AppendChar[Switches^, letters[index]]};        ENDCASE =>          IF toolData.switch[index] THEN            String.AppendChar[Switches^, letters[index]];      ENDLOOP;    IF Switches^.length = 1 THEN Switches^[0] _ '     ELSE String.AppendChar[Switches^, ' ]};  FeedBack: Format.StringProc = {Put.Text[toolData.ttySW, s]};  PrintCommandFile: PROC = {    out: Window.Handle _ toolData.ttySW;    in: MStream.Handle _ NIL;    CommandFile: LONG STRING _ NIL;        CleanUp: PROC = {      IF CommandFile # NIL THEN String.FreeString[systemZone, CommandFile];      CommandFile _ NIL;      IF in # NIL THEN in _ CloseUpStream[in]};          {    ENABLE UNWIND => CleanUp[];    IF String.Empty[toolData.strings[commandfile]] THEN      CommandFile _ String.CopyToNewString["Line.cm"L, systemZone]    ELSE      CommandFile _ String.CopyToNewString[        toolData.strings[commandfile], systemZone];    [] _ String.AppendExtensionIfNeeded[@CommandFile, ".cm"L, systemZone];    Put.CR[out];    Put.Text[out, "Contents of "L];  Put.Text[out, CommandFile];    Put.Line[out, ": \n"L];    in _ GetReadStream[CommandFile];    DO Put.Char[out, Stream.GetChar[in ! Stream.EndOfStream => EXIT]] ENDLOOP;    Put.CR[out];    CleanUp[]}};  AppendCommand: PROC = INLINE {    String.AppendStringAndGrow[@buf, " cf/c "L, systemZone];    String.AppendStringAndGrow[@buf, toolData.strings[commandfile], systemZone];    String.AppendCharAndGrow[@buf, ' , systemZone]};  AppendHost: PROC = INLINE {    String.AppendStringAndGrow[@buf, " open/c "L, systemZone];    String.AppendStringAndGrow[@buf, toolData.strings[host], systemZone]};  AppendDir: PROC = INLINE {    String.AppendStringAndGrow[@buf, " dir/c "L, systemZone];    String.AppendStringAndGrow[@buf, toolData.strings[directory], systemZone];    String.AppendCharAndGrow[@buf, ' , systemZone]};  AppendDFFile: PROC = INLINE {    String.AppendStringAndGrow[@buf, " df/c "L, systemZone];    String.AppendStringAndGrow[@buf, toolData.strings[dffile], systemZone];    String.AppendCharAndGrow[@buf, ' , systemZone]};  isAborted: Expand.AbortProcType = {RETURN[UserInput.UserAbort[wh]]};    AppendSource: PROC = {    Source: LONG STRING _ toolData.strings[source];    expanded: LONG STRING _ NIL;    {    ENABLE UNWIND => String.FreeString[systemZone, expanded];    expanded _ Expand.ExpandString[Source, isAborted, Expand.defaultMask];    String.AppendStringAndGrow[@buf, expanded, systemZone];    String.FreeString[systemZone, expanded]}};  ClearBuf: PROC = {    IF buf # NIL THEN String.FreeString[systemZone, buf];  buf _ NIL};  CheckNamedFiles: FormSW.ProcType = {    ENABLE      Expand.UnknownCommandFile => {        Put.Text[toolData.msgSW, name];  Put.Line[toolData.msgSW, " not found!"L];        UserTerminal.BlinkDisplay[];        GOTO quit};    Put.CR[toolData.msgSW];    IF ~Go[] THEN {      Put.Line[toolData.msgSW, "IncludeChecker already busy!"L];      UserTerminal.BlinkDisplay[];      ClearBuf[];      RETURN};    buf _ NIL;    IF String.Empty[toolData.strings[listfile]] THEN {      UserTerminal.BlinkDisplay[];      Put.Line[toolData.msgSW, "Need listing output file!"L];      Done[]}    ELSE Process.Detach[FORK DoCheck[namedFiles]];    EXITS quit => {ClearBuf[];  Done[]}};  CheckDFFile: FormSW.ProcType = {    Put.CR[toolData.msgSW];    IF ~Go[] THEN {      Put.Line[toolData.msgSW, "IncludeChecker already busy!"L];      UserTerminal.BlinkDisplay[];      ClearBuf[];      RETURN};    buf _ NIL;    IF String.Empty[toolData.strings[dffile]] THEN {      UserTerminal.BlinkDisplay[];      Put.Line[toolData.msgSW, "No DF file given to check!"L];      Done[]}    ELSE Process.Detach[FORK DoCheck[dfFile]]};        DoCheck: PROC [checkMode: {namedFiles, dfFile}] = {    out: Window.Handle _ toolData.ttySW;    generateCommand: BOOLEAN = toolData.switch[command];    outcome: Exec.Outcome;    switches: LONG STRING _ [20];    BEGIN      ENABLE {        AcquistionError => {          Put.Line[out, "Problems encountered ...."L];          SELECT type FROM            fileDoesNotExist =>              Put.Line[out, " does not exist. Transfer cannnot be completed"L];            improperFile =>              Put.Line[out, " is improper.  Transfer cannnot be completed"L];            noFile => Put.Line[out, "Need two files to complete transfer"L];            noOverWrite =>              Put.Line[out, " exists but don't have overwrite permissions"L];            improperAccess =>              Put.Line[out, " can't be acquired with approriate access"L];            ENDCASE;          GOTO quit};        Expand.UnknownCommandFile => {	  Put.Text[out, name];	  Put.Line[out, ": Unknown Command file for expansion."L]};	ABORTED => GOTO quit;        UNWIND  => GOTO quit};    toolData.switch[debug] _ Profile.debugging;    buf _ String.CopyToNewString[      s: toolData.strings[listfile], z: systemZone, longer: 400];    GetSwitches[@switches];    String.AppendStringAndGrow[@buf, switches, systemZone];    IF generateCommand THEN AppendCommand[];    IF checkMode = namedFiles THEN {      IF ~String.Empty[toolData.strings[host]] THEN AppendHost[];      IF ~String.Empty[toolData.strings[directory]] THEN AppendDir[];      IF ~String.Empty[toolData.strings[source]] THEN        AppendSource[	  ! MFile.Error => {	      Put.Text[toolData.msgSW, toolData.strings[source]];	      Put.Line[toolData.msgSW, " is an invalid file list!"L];	      UserTerminal.BlinkDisplay[];	      GOTO quit}]}    ELSE {  -- checkMode = dfFile      IF ~String.Empty[toolData.strings[dffile]] THEN AppendDFFile[]};    outcome _ ICDefs.ToolInterface[FeedBack, buf, wh, toolData.ttySW];    SELECT outcome FROM      normal =>        IF generateCommand THEN PrintCommandFile[];      warning => {        IF generateCommand THEN PrintCommandFile[];        Put.Line[out, "Warnings logged."L]};      error => Put.Line[out, "Errors logged."L];      ENDCASE;    EXITS      quit => NULL;    END;    Put.CR[out];    Put.Text[out, "========================================="L];    Put.Line[out, "========================================="L];    Put.CR[out];    ClearBuf[];  Done[]};      -- Tool routines  ClientTransition: ENTRY ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive => {        IF toolData = NIL THEN toolData _ systemZone.NEW[Data _ []];        toolData.strings[listfile] _ String.CopyToNewString[	  "IncludeChecker.list"L, systemZone];        toolData.strings[commandfile] _ String.CopyToNewString[	  "Line.cm"L, systemZone]};      new = inactive =>        IF toolData # NIL THEN {          IF tmp # NIL THEN Tool.Destroy[oh];          WHILE busy DO WAIT condition ENDLOOP;          systemZone.FREE[@toolData]};      ENDCASE};  Init: PROCEDURE = {    herald: STRING _ [60];    -- don't create tool window if running in Simple Tajo (no display)    IF ~Runtime.IsBound[LOOPHOLE[FormSW.DisplayItem]] THEN RETURN;    CheckIfDFToolUser[];    String.AppendString[to: herald, from: "IncludeChecker of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    systemZone _ Heap.systemZone;    wh _ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: herald,      cmSection: "IncludeChecker"L,      tinyName1: "Include"L, tinyName2: "Checker"L]};        CheckIfDFToolUser: PROC = {    -- see if user is a DF user (has [DFTool] section in User.cm)    userCm: CmFile.Handle _ NIL;    userCm _ CmFile.UserDotCmOpen[ ! CmFile.Error => CONTINUE];    IF userCm # NIL THEN {      dfUser _ CmFile.FindSection[userCm, "DFTool"L];      [] _ CmFile.Close[userCm]}    ELSE dfUser _ FALSE};  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = (IF dfUser THEN 13 ELSE 11);    i: CARDINAL;    items _ AllocateItemDescriptor[nItems];    Initialize[];    --    items[i _ 0] _ StringItem[      tag: "Listing"L, place: [0, line0],      string: @toolData.strings[listfile], inHeap: TRUE];    items[i _ i+1] _ StringItem[      tag: "Commands"L, place: [190, line0],      string: @toolData.strings[commandfile], inHeap: TRUE];    items[i _ i+1] _ CommandItem[      tag: "Options"L, place: [330, line0], proc: OptionCommand];    --    items[i _ i+1] _ CommandItem[      tag: "Check"L, place: [0, line1], proc: CheckNamedFiles];    items[i _ i+1] _ StringItem[      tag: "Host"L, place: [70, line1],      string: @toolData.strings[host], inHeap: TRUE];    items[i _ i+1] _ StringItem[      tag: "Dir"L, place: [150, line1],      string: @toolData.strings[directory], inHeap: TRUE];    items[i _ i+1] _ BooleanItem[      tag: "Command"L, place: [390, line1], switch: @toolData.switch[command]];    items[i _ i+1] _ BooleanItem[      tag: "Pause"L, place: [455, line1], switch: @toolData.switch[pause]];    --    items[i _ i+1] _ StringItem[      tag: "Files"L, place: [70, line2],      string: @toolData.strings[source], inHeap: TRUE];    items[i _ i+1] _ BooleanItem[      tag: "List"L, place: [390, line2], switch: @toolData.switch[includes]];    items[i _ i+1] _ BooleanItem[      tag: "Order"L, place: [455, line2], switch: @toolData.switch[order]];    --    IF dfUser THEN {      items[i _ i+1] _ CommandItem[        tag: "Check DF"L, place: [0, line3], proc: CheckDFFile];      items[i _ i+1] _ StringItem[        tag: "DF File"L, place: [70, line3],        string: @toolData.strings[dffile], inHeap: TRUE]};    RETURN[items: items, freeDesc: TRUE]};  MakeSWs: Tool.MakeSWsProc = {    feedback: STRING _ [40];    log: STRING _ [40];    Tool.UnusedLogName[unused: feedback, root: "IncludeChecker.log"L];    toolData.msgSW  _ Tool.MakeMsgSW[window: window];    toolData.formSW _ Tool.MakeFormSW[window: window, formProc: MakeForm];    toolData.ttySW  _ Tool.MakeTTYSW[window: window, name: feedback]};      KillToolWindow: PUBLIC PROC = {IF wh # NIL THEN Tool.Destroy[wh]};          -- Options window  OptionCommand: FormSW.ProcType = {    location: Window.Place _ Window.BitmapPlace[wh];    location.y _ location.y + 122;    IF optionBusy THEN {      Put.Line[toolData.msgSW, "Options already up."L];      UserTerminal.BlinkDisplay[];      RETURN}    ELSE optionBusy _ TRUE;    oh _ Tool.Create[      makeSWsProc: MakeOSWs, initialState: default,      initialBox: [location, [450, 100]], clientTransition: OptionTransition,      name: "IncludeChecker Options"L, cmSection: "ICOptions"L,      tinyName1: "IC"L, tinyName2: "Options"L]};  OptionTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>        IF tmp = NIL THEN tmp _ systemZone.NEW[tempData _ []];      new = inactive =>        IF tmp # NIL THEN {          systemZone.FREE[@tmp]; tmp _ NIL; optionBusy _ FALSE};      ENDCASE};  MakeOForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = (IF dfUser THEN 10 ELSE 9);    i: CARDINAL;    items _ AllocateItemDescriptor[nItems];    --    items[i _ 0] _ BooleanItem[      tag: "Indirect Local Includes"L, place: [0, line0],      switch: @toolData.switch[all]];    items[i _ i+1] _ BooleanItem[      tag: "Source w/o Bcd OK"L, place: [160, line0],      switch: @toolData.switch[notbad]];    items[i _ i+1] _ BooleanItem[      tag: "Tables To Disk"L, place: [320, line0],      switch: @toolData.switch[tables]];    --    items[i _ i+1] _ BooleanItem[      tag: "Verbose Output"L, place: [0, line1],      switch: @toolData.switch[verbose]];    items[i _ i+1] _ BooleanItem[      tag: "Multiple Output Files"L, place: [160, line1],      switch: @toolData.switch[multiple]];    items[i _ i+1] _ BooleanItem[      tag: "Limit File Length"L, place: [320, line1],      switch: @toolData.switch[limit]];    --    items[i _ i+1] _ BooleanItem[      tag: "Output Packager Cmd"L, place: [0, line2],      switch: @toolData.switch[packagerCmd]];    IF dfUser THEN       items[i _ i+1] _ BooleanItem[        tag: "Examine DF Imports"L, place: [160, line2],        switch: @toolData.switch[imports]];    --    items[i _ i+1] _ CommandItem[      tag: "Apply"L, place: [0, line4], proc: Apply];    items[i _ i+1] _ CommandItem[      tag: "Abort"L, place: [160, line4], proc: Abort];    RETURN[items: items, freeDesc: TRUE]};  Abort: FormSW.ProcType = {    FOR i: SwitchNames IN [all..none] DO toolData.switch[i] _ tmp.opt[i] ENDLOOP;    Tool.Destroy[oh]};  Apply: FormSW.ProcType = {Tool.Destroy[oh]};  OptionMenu: Menu.MCRType = {  -- Options menu    SELECT index FROM 0 => Tool.Destroy[oh] ENDCASE};  MakeOSWs: Tool.MakeSWsProc = {  -- Options sub window.    menuStrings: ARRAY [0..1) OF LONG STRING _ ["Apply"L];    i: SwitchNames;    FOR i IN [all..none] DO tmp.opt[i] _ toolData.switch[i] ENDLOOP;    toolData.menuO _ Menu.Make[      name: "Options", strings: DESCRIPTOR[menuStrings], mcrProc: OptionMenu];    toolData.formOSW _ Tool.MakeFormSW[window: window, formProc: MakeOForm];    Menu.Instantiate[toolData.menuO, window]};  Go: PUBLIC PROC RETURNS [BOOLEAN] = {RETURN[enter[]]};  Done: PUBLIC PROC = {leave[]};    enter: ENTRY PROC RETURNS [okay: BOOLEAN] = {    ENABLE UNWIND => NULL;    IF busy THEN RETURN[FALSE];    busy _ TRUE;  RETURN[TRUE]};  leave: ENTRY PROC = {    ENABLE UNWIND => NULL;    busy _ FALSE;  NOTIFY condition};  Init[];  END.  
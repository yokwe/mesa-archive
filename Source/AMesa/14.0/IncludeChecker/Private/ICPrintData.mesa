-- ICPrintData.mesa - Last modified by --   BGY     	30-Aug-82 10:01:11--   BTL  	15-Nov-83 16:34:50DIRECTORY  BcdDefs USING [VersionStamp],  Exec USING [Handle],  Format USING [    Blank, Blanks, Char, CR, Date, Decimal, Number, NumberFormat, StringProc],  ICDefs USING [    badFiles, CheckAbort, circular, commandName, exec,      listName, olderIncludesFound, ownTable, rootName, switches],  ICLists USING [    AnyMultVersionFiles, Base, CFNil, ClearTags, ContainingFile, containType,    DepthIndex, depthType, dirType, DNNil, EnumerateDepths, EnumerateFiles,    EnumerateFilesIncludedBy, EnumerateFilesOfDepth, EnumerateFilesThatContain,    EnumerateFilesWithName, EnumerateIncludedFiles, EnumerateMultLocBcds,    EnumerateMultLocSources, EnumerateMultVersionBcds,    EnumerateMultVersionSources, File, fileType,    HNNil, hostType, IFNil, incDescType, IncFileDesc, IncludedFile,    includeType, Loc, LocalHost, markedType, MultLocBcd, MultLocSource,    MultVersionBcd, MultVersionSource, Name, NameNil, nameType, NullTime,    StringForName, VersionStamp],  LongAlloc USING [AddNotify, Base, DropNotify, Handle, Notifier],  MFile USING [maxNameLength],  MStream USING [GetLength, Handle, WriteOnly],  Runtime USING [GetBcdTime],  Stream USING [Delete, Handle],  String USING [AppendDecimal, AppendString],  System USING [GreenwichMeanTime],  Time USING [Append, Current, defaultTime, Packed, Unpack],  Version USING [Append];  ICPrintData: PROGRAM    IMPORTS      Format, ICDefs, ICLists, LongAlloc, MStream, Runtime, Stream, String,      Time, Version    EXPORTS ICDefs =  BEGIN OPEN ICDefs, ICLists;    icExec: Exec.Handle _ NIL;  -- local copies of ICDefs variables  table: LongAlloc.Handle _ NIL;    feb: LongAlloc.Base;  -- file records  ifb: LongAlloc.Base;  -- included files  idb: LongAlloc.Base;  -- descriptions of included files   cfb: LongAlloc.Base;  -- containing files  hb:  LongAlloc.Base;  -- hosts  db:  LongAlloc.Base;  -- directories  dib: LongAlloc.Base;  -- file depth chain heads  mb:  LongAlloc.Base;  -- marked files  nb:  LongAlloc.Base;  -- names  UpdateBases: LongAlloc.Notifier = {    feb _ base[ICLists.fileType];      ifb _ base[ICLists.includeType];    idb _ base[ICLists.incDescType];    cfb _ base[ICLists.containType];    hb  _ base[ICLists.hostType];    db  _ base[ICLists.dirType];    dib _ base[ICLists.depthType];    mb  _ base[ICLists.markedType];    nb  _ base[ICLists.nameType]};      -- File data output stream management  listStream: MStream.Handle _ NIL;    Print: Format.StringProc = {    IF s # NIL THEN       listStream.put[        sH: listStream, block: [LOOPHOLE[@s.text], 0, s.length],	endRecord: FALSE]};	  PrintSP: PROC = {Format.Blank[Print]};  PrintChar: PROC [c: CHARACTER] = {Format.Char[Print, c]};  PrintCR: PROC = {Format.CR[Print]};  PrintLine: PROC [s: LONG STRING] = {Print[s];  PrintCR[]};  PrintBlanks: PROC [n: INTEGER] = {Format.Blanks[Print, n]};  PrintDecimal: PROC [n: INTEGER] = {Format.Decimal[Print, n]};  PrintName: PROC [name: ICLists.Name] = {Print[ICLists.StringForName[name]]};    PrintPaddedName: PROC [name: ICLists.Name, width: CARDINAL] = {    s: LONG STRING = ICLists.StringForName[name];    IF width > s.length THEN {Print[s];  PrintBlanks[width - s.length]}    ELSE {Print[s];  PrintSP[]}};    PrintNumber: PROC [n: UNSPECIFIED, f: Format.NumberFormat] = {    Format.Number[Print, n, f]};   PrintCreation: PROC [      t: Time.Packed,      leading: {leadingSpace, noLeadingSpace} _ noLeadingSpace] = {    IF t = Time.defaultTime THEN {      Print[IF leading = leadingSpace THEN " (unknown)"L ELSE "(unknown)"L];      RETURN};    IF leading = leadingSpace THEN Format.Date[Print, t, dateTime]    ELSE {      s: STRING _ [20];      Time.Append[s, Time.Unpack[t]];      IF s[0] = '  THEN        FOR i: CARDINAL IN [1..s.length) DO PrintChar[s[i]] ENDLOOP      ELSE Print[s]}};       PrintVersion: PROC [      v: BcdDefs.VersionStamp,      leading: {leadingSpace, noLeadingSpace} _ noLeadingSpace] = {    octal: Format.NumberFormat = [8, FALSE, FALSE, 1];    IF LOOPHOLE[v.time, Time.Packed] = Time.defaultTime THEN {      Print[IF leading = leadingSpace THEN " (unknown)"L ELSE "(unknown)"L];      RETURN};    IF leading = leadingSpace THEN      Format.Date[Print, LOOPHOLE[v.time, Time.Packed], dateTime]    ELSE {      s: STRING _ [20];      Time.Append[s, Time.Unpack[LOOPHOLE[v.time, Time.Packed]]];      IF s[0] = '  THEN         FOR i: CARDINAL IN [1..s.length) DO PrintChar[s[i]] ENDLOOP      ELSE Print[s]};    PrintSP[];    PrintNumber[v.net, octal];  PrintChar['#];    PrintNumber[v.host, octal]; PrintChar['#]};    PrintLoc: PROC [loc: Loc] = {    SELECT TRUE FROM      (loc.host = HNNil) => Print["(locally)"L];      ICLists.LocalHost[loc.host] =>         Print[IF loc.dir = DNNil THEN "(locally)"L ELSE "[ME]"L];      ENDCASE => {PrintChar['[];  PrintName[hb[loc.host].name];  PrintChar[']]};    IF loc.dir # DNNil THEN {      locDir: LONG STRING _ ICLists.StringForName[db[loc.dir].name];      IF locDir[0] # '< THEN PrintChar['<];      Print[locDir];      IF locDir[locDir.length-1] # '> THEN PrintChar['>]}};              listTime: System.GreenwichMeanTime;  listFile: CARDINAL;  OpenListFile: PROC = {    s: STRING _ [120];    listStream _ MStream.WriteOnly[      name: ICDefs.listName, release: [], type: text];    HeaderToListFile[];    listTime _ Time.Current[];    String.AppendString[s, "  File "L];  String.AppendString[s, ICDefs.listName];    String.AppendString[s, " created "L];    Time.Append[s, Time.Unpack[listTime]];  s.length _ s.length-3;    PrintLine[s];    listFile _ 1};      CloseListFile: PROC = {    IF listStream # NIL THEN Stream.Delete[listStream];    listStream _ NIL};      OpenAnotherListFile: PROC = {  -- if switches['l]: limit size of .includes file    listName: STRING _ [MFile.maxNameLength];    s: STRING _ [120];    CloseListFile[];    listFile _ listFile+1;    String.AppendString[listName, ICDefs.listName];    String.AppendDecimal[listName, listFile];    listStream _ MStream.WriteOnly[name: listName, release: [], type: text];    HeaderToListFile[];    String.AppendString[s, "  File "L];  String.AppendString[s, listName];    String.AppendString[s, " created "L];    Time.Append[s, Time.Unpack[listTime]];  s.length _ s.length-3;    PrintLine[s];  PrintCR[]};  OpenIncludesListFile: PROC = {  -- if switches['m]: multiple output files    listName: STRING _ [MFile.maxNameLength];    s: STRING _ [120];    String.AppendString[listName, ICDefs.rootName];     String.AppendString[listName, ".includes"L];    listStream _ MStream.WriteOnly[name: listName, release: [], type: text];    HeaderToListFile[];    String.AppendString[s, "  File "L];  String.AppendString[s, listName];    String.AppendString[s, " created "L];    listTime _ Time.Current[];    Time.Append[s, Time.Unpack[listTime]];  s.length _ s.length-3;    PrintLine[s];    listFile _ 1};      OpenIncludedByListFile: PROC = {    listName: STRING _ [MFile.maxNameLength];    s: STRING _ [120];    CloseListFile[];    String.AppendString[listName, ICDefs.rootName];     String.AppendString[listName, ".includedBy"L];    listStream _ MStream.WriteOnly[name: listName, release: [], type: text];    HeaderToListFile[];    String.AppendString[s, "  File "L];  String.AppendString[s, listName];    String.AppendString[s, " created "L];    Time.Append[s, Time.Unpack[listTime]];  s.length _ s.length-3;    PrintLine[s]};      HeaderToListFile: PROC = {     s: STRING _ [60];    String.AppendString[s, "Mesa IncludeChecker "L];  Version.Append[s];    String.AppendString[s, " of "L];    Time.Append[s, Time.Unpack[LOOPHOLE[Runtime.GetBcdTime[]]]];    s.length _ s.length-3;    PrintLine[s]};      Legend: TYPE = {    obsolete, multLocBcd, multLocSource, multVersionBcd, multVersionSource,    wrongIncBcd, sourceButNoBcd, recompileOrder, rebindOrder, repackageOrder,    includesRelation, containedByRelation};        PrintLegend: PROC [kind: Legend] = {    PrintCR[];    SELECT kind FROM      obsolete =>        PrintLine["Bcds found with incompatible versions:"L];      multLocBcd =>        PrintLine["Bcds found in multiple locations:"L];      multLocSource =>        PrintLine["Source files found in multiple locations:"L];      multVersionBcd =>        PrintLine["Bcds found in multiple versions:"L];      multVersionSource =>        PrintLine["Source files found in multiple versions:"L];      wrongIncBcd =>        PrintLine[	  "Included Bcds that were not found, but were found in other versions:"L];      sourceButNoBcd =>        PrintLine["Source files for which no Bcd was found:"L];      recompileOrder =>        PrintLine["Recompilation order:"L];      rebindOrder =>        PrintLine["Rebind order:"L];      repackageOrder =>        PrintLine["Repackage order :"L];      includesRelation =>        PrintLine["List of files that were found, and the files they include:"L];      containedByRelation =>        PrintLine["Containing file lists:"L];      ENDCASE;    PrintCR[]};         -- Rebuild command stream management   cmdStream: MStream.Handle _ NIL;    PrintCmd: Format.StringProc = {    IF s # NIL THEN       cmdStream.put[        sH: cmdStream, block: [LOOPHOLE[@s.text], 0, s.length],	endRecord: FALSE]};	  PrintCmdSP: PROC = {Format.Blank[PrintCmd]};  PrintCmdChar: PROC [c: CHARACTER] = {Format.Char[PrintCmd, c]};  PrintCmdName: PROC [name: ICLists.Name] = {    PrintCmd[ICLists.StringForName[name]]};  PrintCmdCR: PROC = {Format.CR[PrintCmd]};  PrintCmdLine: PROC [s: LONG STRING] = {PrintCmd[s];  PrintCmdCR[]};    OpenCommandFile: PROC = {    cmdStream _ MStream.WriteOnly[      name: ICDefs.commandName, release: [], type: text];    HeaderToCommandFile[]};    HeaderToCommandFile: PROC = {    PrintCmd["// File "L];  PrintCmd[ICDefs.commandName];    PrintCmd[" created by the IncludeChecker on "L];    Format.Date[PrintCmd, Time.Current[], dateTime];    PrintCmdCR[]};      CloseCommandFile: PROC = {    IF cmdStream # NIL THEN Stream.Delete[cmdStream];    cmdStream _ NIL};                   -- *********** Print file data and rebuild command ************     PrintData: PUBLIC PROC = {    ENABLE UNWIND => Finalize[];    Initialize[];    IF switches['i] OR switches['o] THEN PrintFileData[];    IF switches['c] THEN PrintRebuildLine[];    Finalize[]};      Initialize: PROC = {    icExec _ ICDefs.exec;  table _ ICDefs.ownTable;    table.AddNotify[UpdateBases]};    Finalize: PROC = {    CloseListFile[];  CloseCommandFile[];    IF table # NIL THEN table.DropNotify[UpdateBases];    table _ NIL;  icExec _ NIL};         -- **** File data: marked files, rebuild order, includes/containedBy relations      PrintFileData: PROC = {    IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    IF switches['m] THEN OpenIncludesListFile[] ELSE OpenListFile[];    IF switches['i] THEN {      PrintObsoleteFiles[];      PrintFilesInMultLocAndVersions[];      PrintBcdsIncludedInWrongVersion[];      PrintSourcesWithNoBcds[]};    IF switches['o] THEN PrintRebuildOrder[];    IF switches['i] THEN {      PrintIncludesRelation[];      IF switches['v] THEN {        IF switches['m] THEN OpenIncludedByListFile[];	PrintContainedByRelation[]}};    CloseListFile[]};     -- Print "unusual" files, e.g. those with no Bcds or in >1 version   PrintObsoleteFiles: PROC = {    legendPrinted: BOOLEAN _ FALSE;        CheckOneFile: PROC [f: File] RETURNS [stop: BOOLEAN] = {      OPEN file: feb[f];      IF file.obsolete THEN {        IF ~legendPrinted THEN {PrintLegend[obsolete];  legendPrinted _ TRUE};	PrintBlanks[2];  PrintName[file.name];  PrintCR[]};        RETURN[FALSE]};      IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    EnumerateFiles[CheckOneFile]};    PrintFilesInMultLocAndVersions: PROC = {    IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    PrintMultLocBcds[];      PrintMultLocSources[];      PrintMultVersionBcds[];  PrintMultVersionSources[]};      PrintMultLocBcds: PROC = {    legendPrinted: BOOLEAN _ FALSE;      PrintMultLocBcd: PROC [m: MultLocBcd] RETURNS [stop: BOOLEAN] = {      OPEN b: mb[m];      IF ~legendPrinted THEN {PrintLegend[multLocBcd];  legendPrinted _ TRUE};      PrintBlanks[2];  PrintPaddedName[b.name, 25];      PrintVersion[b.version, leadingSpace];  PrintLine[":"L];      PrintBlanks[4];  PrintLoc[b.loc1];  Print[" and "L];  PrintLoc[b.loc2];      PrintCR[];      RETURN[FALSE]};          EnumerateMultLocBcds[PrintMultLocBcd]};      PrintMultLocSources: PROC = {    legendPrinted: BOOLEAN _ FALSE;      PrintMultLocSource: PROC [m: MultLocSource] RETURNS [stop: BOOLEAN] = {      OPEN s: mb[m];      IF ~legendPrinted THEN {PrintLegend[multLocSource];  legendPrinted _ TRUE};      PrintBlanks[2];  PrintPaddedName[s.name, 25];      PrintCreation[s.create, leadingSpace];  PrintLine[":"L];      PrintBlanks[4];  PrintLoc[s.loc1];  Print[" and "L];  PrintLoc[s.loc2];      PrintCR[];      RETURN[FALSE]};          EnumerateMultLocSources[PrintMultLocSource]};      PrintMultVersionBcds: PROC = {    legendPrinted: BOOLEAN _ FALSE;      PrintMultVersionBcd: PROC [m: MultVersionBcd] RETURNS [stop: BOOLEAN] = {      OPEN b: mb[m];      IF ~legendPrinted THEN {PrintLegend[multVersionBcd];  legendPrinted _ TRUE};      PrintBlanks[2];  PrintName[b.name];  PrintCR[];      PrintBlanks[4];  PrintVersion[b.version1, leadingSpace];      IF InterestingLoc[b.loc1] THEN {Print[" on "L];  PrintLoc[b.loc1]}      ELSE Print[" (locally) "L];      Print[" and"L];  PrintCR[];      PrintBlanks[4];  PrintVersion[b.version2, leadingSpace];      IF InterestingLoc[b.loc2] THEN {Print[" on "L];  PrintLoc[b.loc2]}      ELSE Print[" (locally) "L];      PrintCR[];      RETURN[FALSE]};          EnumerateMultVersionBcds[PrintMultVersionBcd]};      InterestingLoc: PROC [loc: Loc] RETURNS [BOOLEAN] = {    -- "uninteresting" if local machine and empty directory    IF loc.host = HNNil THEN RETURN[FALSE];    IF ICLists.LocalHost[loc.host] AND loc.dir = DNNil THEN RETURN[FALSE];    RETURN[TRUE]};      PrintMultVersionSources: PROC = {    legendPrinted: BOOLEAN _ FALSE;      PrintMultVersionSource: PROC [        m: MultVersionSource] RETURNS [stop: BOOLEAN] = {      OPEN s: mb[m];      IF ~legendPrinted THEN {        PrintLegend[multVersionSource]; legendPrinted _ TRUE};      PrintBlanks[2];  PrintName[s.name];  PrintCR[];      PrintBlanks[4];  PrintCreation[s.create1, leadingSpace];      IF InterestingLoc[s.loc1] THEN {Print[" on "L];  PrintLoc[s.loc1]}      ELSE Print[" (locally) "L];      Print[" and "L];  PrintCR[];      PrintBlanks[4];  PrintCreation[s.create2, leadingSpace];      IF InterestingLoc[s.loc2] THEN {Print[" on "L];  PrintLoc[s.loc2]}      ELSE Print[" (locally) "L];      PrintCR[];      RETURN[FALSE]};          EnumerateMultVersionSources[PrintMultVersionSource]};      PrintBcdsIncludedInWrongVersion: PROC = {    legendPrinted: BOOLEAN _ FALSE;        CheckOneIncFile: PROC [d: IncFileDesc] RETURNS [stop: BOOLEAN] = {      OPEN inc: idb[d];      IF inc.wrongVersion THEN {        IF ~legendPrinted THEN {PrintLegend[wrongIncBcd];  legendPrinted _ TRUE};	PrintBlanks[2];  PrintPaddedName[inc.name, 25];	PrintVersion[inc.version, leadingSpace];	PrintCR[]};        RETURN[FALSE]};      EnumerateIncludedFiles[CheckOneIncFile]};      PrintSourcesWithNoBcds: PROC = {    legendPrinted: BOOLEAN _ FALSE;        CheckOneFile: PROC [f: File] RETURNS [stop: BOOLEAN] = {      OPEN file: feb[f];      IF file.source AND ~file.bcd THEN {        IF ~legendPrinted THEN {	  PrintLegend[sourceButNoBcd];  legendPrinted _ TRUE};	PrintBlanks[2];  PrintPaddedName[file.name, 25];	PrintCreation[file.sourceDate, leadingSpace];	PrintCR[]};        RETURN[FALSE]};      EnumerateFiles[CheckOneFile]};     -- Print recompile and rebind orders and repackage orders      PrintRebuildOrder: PROC = {    PrintRecompileOrder[];    PrintRebindOrder[];    PrintRepackageOrder[]};      PrintRecompileOrder: PROC = {    legendPrinted, depthPrinted: BOOLEAN _ FALSE;    depth: CARDINAL _ 0;    printFile: BOOLEAN;        DoOneRecompileDepth: PROC [d: DepthIndex] RETURNS [stop: BOOLEAN] = {      depthPrinted _ FALSE;      EnumerateFilesOfDepth[d, CheckOneFile];      IF depthPrinted THEN PrintCR[];      depth _ depth+1;      RETURN[FALSE]};          CheckOneFile: PROC [f: File] RETURNS [stop: BOOLEAN] = {      OPEN file: feb[f];            CheckOtherVersionsOfFile: PROC [o: File] RETURNS [stop: BOOLEAN] = {        IF o # f AND	~(feb[o].sourceButNoBcd OR feb[o].readProtected OR feb[o].obsolete) THEN {	  printFile _ FALSE;  -- assume o has higher depth	  RETURN[TRUE]};	RETURN[FALSE]};	      IF ~file.config AND ~file.tableCompiled AND ~file.packaged THEN {        IF depth = 0 THEN {  -- look for higher depth Bcd	  printFile _ TRUE;	  EnumerateFilesWithName[file.name, CheckOtherVersionsOfFile];	  IF ~printFile THEN RETURN[FALSE]};        IF ~depthPrinted THEN {	  IF ~legendPrinted THEN {	    PrintLegend[recompileOrder];  legendPrinted _ TRUE};	  Print["  (depth "L];  PrintDecimal[depth];  Print["):"L];	  depthPrinted _ TRUE};        PrintSP[];  PrintName[file.name]};       RETURN[FALSE]};        IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    EnumerateDepths[DoOneRecompileDepth];    PrintCR[]};      PrintRebindOrder: PROC = {    legendPrinted, depthPrinted: BOOLEAN _ FALSE;    depth: CARDINAL _ 0;    printFile: BOOLEAN;        DoOneRebindDepth: PROC [d: DepthIndex] RETURNS [stop: BOOLEAN] = {      depthPrinted _ FALSE;      EnumerateFilesOfDepth[d, CheckOneFile];      IF depthPrinted THEN PrintCR[];      depth _ depth+1;      RETURN[FALSE]};          CheckOneFile: PROC [f: File] RETURNS [stop: BOOLEAN] = {      OPEN file: feb[f];            CheckOtherVersionsOfFile: PROC [o: File] RETURNS [stop: BOOLEAN] = {        IF o # f AND	~(feb[o].sourceButNoBcd OR feb[o].readProtected OR feb[o].obsolete) THEN {	  printFile _ FALSE;  -- assume o has higher depth	  RETURN[TRUE]};        RETURN[FALSE]};          IF file.config AND ~file.packaged THEN {        IF depth = 0 THEN {  -- look for higher depth Bcd	  printFile _ TRUE;	  EnumerateFilesWithName[file.name, CheckOtherVersionsOfFile];	  IF ~printFile THEN RETURN[FALSE]};        IF ~depthPrinted THEN {	  IF ~legendPrinted THEN {	    PrintLegend[rebindOrder];  legendPrinted _ TRUE};	  Print["  (depth "L];  PrintDecimal[depth];  Print["):"L];	  depthPrinted _ TRUE};	PrintSP[];  PrintName[file.name]};       RETURN[FALSE]};        IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    EnumerateDepths[DoOneRebindDepth];    PrintCR[]};     PrintRepackageOrder: PROC = {    legendPrinted, depthPrinted: BOOLEAN _ FALSE;    depth: CARDINAL _ 0;    printFile: BOOLEAN;        DoOneRepackagDepth: PROC [d: DepthIndex] RETURNS [stop: BOOLEAN] = {      depthPrinted _ FALSE;      EnumerateFilesOfDepth[d, CheckOneFile];      IF depthPrinted THEN PrintCR[];      depth _ depth+1;      RETURN[FALSE]};          CheckOneFile: PROC [f: File] RETURNS [stop: BOOLEAN] = {      OPEN file: feb[f];            CheckOtherVersionsOfFile: PROC [o: File] RETURNS [stop: BOOLEAN] = {        IF o # f AND	~(feb[o].sourceButNoBcd OR feb[o].readProtected OR feb[o].obsolete) THEN {	  printFile _ FALSE;  -- assume o has higher depth	  RETURN[TRUE]};        RETURN[FALSE]};          IF file.packaged THEN {        IF depth = 0 THEN {  -- look for higher depth Bcd	  printFile _ TRUE;	  EnumerateFilesWithName[file.name, CheckOtherVersionsOfFile];	  IF ~printFile THEN RETURN[FALSE]};        IF ~depthPrinted THEN {	  IF ~legendPrinted THEN {	    PrintLegend[repackageOrder];  legendPrinted _ TRUE};	  Print["  (depth "L];  PrintDecimal[depth];  Print["):"L];	  depthPrinted _ TRUE};	PrintSP[];  PrintName[file.name]};       RETURN[FALSE]};        IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    EnumerateDepths[DoOneRepackagDepth];    PrintCR[]};         -- Print file data, and includes and containedBy relations      fileNumber: CARDINAL;	      PrintIncludesRelation: PROC = {        PrintOneFilesData: PROC [f: File] RETURNS [stop: BOOLEAN] = {      OPEN file: feb[f];      IF ICDefs.CheckAbort[] THEN ERROR ABORTED;      fileNumber _ fileNumber+1;      IF switches['v] OR file.bad THEN {        IF file.bad AND ~switches['v] THEN {  -- don't print if only problem	  IF file.dependsOnBad                -- is indirect dep. on bad file	  AND ~file.obsolete AND ~file.readProtected AND ~file.wrongSource	  AND ~file.sourceButNoBcd AND ~file.wrongIncludes THEN RETURN[FALSE]};         IF switches['l] THEN	  IF (MStream.GetLength[listStream] > 100000) THEN OpenAnotherListFile[];        PrintBlanks[2];  PrintDecimal[fileNumber];   Print[". "L];        IF file.bad THEN PrintChar['*];        PrintName[file.name];  PrintCR[];        PrintSourceInfoOf[f];        PrintBcdInfoOf[f];        IF file.bad THEN PrintProblemsOf[f];        PrintIncludesOf[f];        PrintCR[]};      RETURN[FALSE]};          IF switches['v] OR ICDefs.badFiles THEN PrintLegend[includesRelation];    fileNumber _ 0;    EnumerateFiles[PrintOneFilesData];    PrintCR[]};      PrintSourceInfoOf: PROC [f: File] = {    OPEN file: feb[f];    PrintBlanks[6];    IF file.wrongSource OR file.sourceButNoBcd THEN PrintChar['*] ELSE PrintSP[];    Print["Source: "L];    IF file.source THEN {      IF InterestingLoc[file.sourceLoc] THEN {        Print["on "L];  PrintLoc[file.sourceLoc];  Print[", "L]};       PrintCreation[file.sourceDate, leadingSpace];      IF file.wrongSource THEN {        Print[", but Bcd's source was "L];  PrintCreation[file.bcdSourceDate]}}    ELSE {      Print["(not found)"L];      IF file.bcdSourceDate # NullTime THEN {        Print[", creation date was "L];  PrintCreation[file.bcdSourceDate]}};    IF ~file.sameSourceInDFfile THEN Print[", different version in DF file"L];      PrintCR[]};      PrintBcdInfoOf: PROC [f: File] = {    OPEN file: feb[f];    PrintBlanks[6];    IF file.obsolete OR file.readProtected THEN PrintChar['*] ELSE PrintSP[];    Print["Bcd:    "L];    IF file.bcd THEN {      IF InterestingLoc[file.bcdLoc] THEN {        Print["on "L];  PrintLoc[file.bcdLoc];  Print[", "L]};      IF file.readProtected THEN {        PrintLine["(read protected)"L];  RETURN}      ELSE PrintVersion[file.version, leadingSpace];      PrintCR[];      PrintBlanks[7];      SELECT TRUE FROM	file.packaged AND file.config => {	  Print["Packager created"L];	  IF file.codeBound THEN Print[", code copied"L];	  IF file.symbolsBound THEN Print[", symbols copied"L]};	file.packaged AND ~file.config =>	  Print["Packager created (single module)"L];	file.config => {	  Print["Binder created"L];	  IF file.codeBound THEN Print[", code copied"L];	  IF file.symbolsBound THEN Print[", symbols copied"L]};	file.tableCompiled =>	  Print["Table compiled"L];	file.defModule =>	  Print["Definitions module"L];	ENDCASE => {	  Print["Implementation module"L];	  IF ~file.crossJumped OR file.boundsCheck OR file.nilCheck THEN {	    Print[" compiled /"L];	    IF ~file.crossJumped THEN Print["-j"L];	    IF file.boundsCheck THEN PrintChar['b];	    IF file.nilCheck THEN PrintChar['n]}};        IF file.imported THEN Print[", imported"L];	IF ~file.sameBcdInDFfile THEN Print[", different version in DF file"L];      PrintCR[]}    ELSE PrintLine["(not found)"L]};       PrintProblemsOf: PROC [f: File] = {    OPEN file: feb[f];    first: BOOLEAN _ TRUE;        PrintProblem: PROC [s: STRING] = {      IF ~first THEN Print[", "L];      Print[s];  first _ FALSE};           PrintBlanks[7];    Print["Problem: "L];    IF file.obsolete THEN PrintProblem["incompatible Bcd format"L];    IF file.readProtected THEN PrintProblem["read protected Bcd"L];    IF file.sourceButNoBcd THEN PrintProblem["source but no Bcd"L];    IF file.wrongSource THEN      PrintProblem["different version of source found"L];    IF file.wrongIncludes THEN      PrintProblem["different version of included Bcd found"L];    IF file.dependsOnBad THEN {      PrintProblem["depends on bad file"L];      IF file.badDependee # ICLists.NameNil THEN {        Print[" ("L];  PrintName[file.badDependee];  Print[")"L]}};      PrintCR[]};      PrintIncludesOf: PROC [f: File] = {    OPEN file: feb[f];    IF file.includes = IFNil THEN RETURN;    IF ~switches['v] THEN       IF file.bad AND ~file.wrongIncludes THEN RETURN;    PrintBlanks[7];  PrintLine["Includes:"L];    EnumerateFilesIncludedBy[f, PrintOneIncludedFile]};      PrintOneIncludedFile: PROC [i: IncludedFile] RETURNS [stop: BOOLEAN] = {    OPEN inc: idb[ifb[i].desc];    IF switches['v] OR inc.wrongVersion THEN {      PrintBlanks[9];      PrintChar[IF inc.wrongVersion THEN '* ELSE ' ];      PrintPaddedName[inc.name, 20];      IF inc.unknownVersion THEN Print[" (version unknown)"L]      ELSE {PrintSP[];  PrintVersion[inc.version, leadingSpace]};      IF inc.found THEN PrintLine[", found"L] ELSE PrintCR[]};    RETURN[FALSE]};      col: CARDINAL _ 0;  PrintContainedByRelation: PROC = {    PrintLegend[containedByRelation];    fileNumber _ 0;      EnumerateFiles[PrintFilesContaining];    PrintCR[]};      PrintFilesContaining: PROC [f: File] RETURNS [stop: BOOLEAN] = {    OPEN file: feb[f];        PrintContainingFile: PROC [c: ContainingFile] RETURNS [stop: BOOLEAN] = {      OPEN cont: feb[cfb[c].file];      IF (col _ col+1) > 3 THEN {PrintCR[];  PrintBlanks[7];  col _ 1};      PrintPaddedName[cont.name, 22];      RETURN[FALSE]};          IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    fileNumber _ fileNumber+1;  col _ 0;    PrintBlanks[2];  PrintDecimal[fileNumber];  Print[". "L];    PrintName[file.name];  Print[" is included by"L];    IF file.containedBy = CFNil THEN PrintLine[" nothing"L]    ELSE {      PrintChar[':];  PrintCR[];  PrintBlanks[7];      EnumerateFilesThatContain[f, PrintContainingFile];      PrintCR[]};    PrintCR[];    RETURN[FALSE]};	            -- ******* Output command to rebuild files if necessary ********   PrintRebuildLine: PROC = {    IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    OpenCommandFile[];    IF ~ICDefs.badFiles THEN PrintCmdLine["// The files seem consistent"L]    ELSE {      IF ICLists.AnyMultVersionFiles[] OR ICDefs.circular      OR ICDefs.olderIncludesFound THEN {         PrintCmd["// Check these commands carefully: "L];  PrintCmdCR[];        IF ICLists.AnyMultVersionFiles[] THEN { 	  PrintCmd["//   Files were found in multiple versions."L];	  PrintCmdCR[]};	IF ICDefs.circular THEN {	  PrintCmd["//   Circular file dependencies were found."L];	  PrintCmdCR[]};	IF ICDefs.olderIncludesFound THEN {	  PrintCmd["//   Older versions of included files were found."L];	  PrintCmdCR[]};	PrintCmdCR[]};      PrintRecompileCommand[];      PrintRebindCommand[];      IF ICDefs.switches['k] THEN PrintRepackageCommand[]};    CloseCommandFile[]};      PrintRecompileCommand: PROC = {    first: BOOLEAN _ TRUE;    lastHadSwitch: BOOLEAN _ FALSE;    depth: CARDINAL _ 0;    printFile, fileAtDepthPrinted: BOOLEAN;      PrintOneRecompileDepth: PROC [d: DepthIndex] RETURNS [stop: BOOLEAN] = {      fileAtDepthPrinted _ FALSE;      EnumerateFilesOfDepth[d, CheckIfBad];      IF ICDefs.switches['p] THEN         IF fileAtDepthPrinted THEN	  PrintCmd[IF lastHadSwitch THEN "p"L ELSE "/p"L];      depth _ depth+1;      RETURN[FALSE]};          CheckIfBad: PROC [f: File] RETURNS [stop: BOOLEAN] = {      OPEN file: feb[f];          CheckOtherVersionsOfFile: PROC [o: File] RETURNS [stop: BOOLEAN] = {        IF o # f AND	~(feb[o].sourceButNoBcd OR feb[o].readProtected OR feb[o].obsolete) THEN {	  printFile _ FALSE;  -- assume o has higher depth	  RETURN[TRUE]};        RETURN[FALSE]};            TagOtherVersionsOfFile: PROC [o: File] RETURNS [stop: BOOLEAN] = {        IF o # f THEN feb[o].tag _ TRUE;  -- don't compile this version        RETURN[FALSE]};            IF ~file.tag AND file.bad      AND ~file.config AND ~file.tableCompiled AND ~file.packaged THEN {        IF depth = 0 THEN {  -- look for higher depth Bcd	  printFile _ TRUE;	  EnumerateFilesWithName[file.name, CheckOtherVersionsOfFile];	  IF ~printFile THEN RETURN[FALSE]};        IF first THEN {PrintCmd["Compile /j-b-n';"L];  first _ FALSE};	PrintCmdSP[];  PrintCmdName[file.name];	IF ~file.defModule	AND (~file.crossJumped OR file.boundsCheck OR file.nilCheck) THEN {	  PrintCmdChar['/];	  IF ~file.crossJumped THEN PrintCmd["-j"L];	  IF file.boundsCheck THEN PrintCmd["b"L];	  IF file.nilCheck THEN PrintCmd["n"L];	  lastHadSwitch _ TRUE}	ELSE lastHadSwitch _ FALSE;	fileAtDepthPrinted _ TRUE;	EnumerateFilesWithName[file.name, TagOtherVersionsOfFile];	file.tag _ TRUE};       RETURN[FALSE]};          IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    ClearTags[];  -- files are tagged when output (or if name already output)    EnumerateDepths[PrintOneRecompileDepth];    IF ~first THEN PrintCmdCR[]};      PrintRebindCommand: PROC = {    first: BOOLEAN _ TRUE;    lastHadSwitch: BOOLEAN _ FALSE;    depth: CARDINAL _ 0;    printFile, fileAtDepthPrinted: BOOLEAN;        PrintOneRebindDepth: PROC [d: DepthIndex] RETURNS [stop: BOOLEAN] = {      fileAtDepthPrinted _ FALSE;      EnumerateFilesOfDepth[d, CheckIfBad];      IF ICDefs.switches['p] THEN        IF fileAtDepthPrinted THEN	  PrintCmd[IF lastHadSwitch THEN "p"L ELSE "/p"L];      depth _ depth+1;      RETURN[FALSE]};          CheckIfBad: PROC [f: File] RETURNS [stop: BOOLEAN] = {      OPEN file: feb[f];          CheckOtherVersionsOfFile: PROC [o: File] RETURNS [stop: BOOLEAN] = {        IF o # f AND	~(feb[o].sourceButNoBcd OR feb[o].readProtected OR feb[o].obsolete) THEN {	  printFile _ FALSE;  -- assume o has higher depth	  RETURN[TRUE]};        RETURN[FALSE]};            TagOtherVersionsOfFile: PROC [o: File] RETURNS [stop: BOOLEAN] = {        IF o # f THEN feb[o].tag _ TRUE;  -- don't bind this version        RETURN[FALSE]};             IF ~file.tag AND file.bad      AND file.config AND ~file.packaged THEN {        IF depth = 0 THEN {  -- look for higher depth Bcd	  printFile _ TRUE;	  EnumerateFilesWithName[file.name, CheckOtherVersionsOfFile];	  IF ~printFile THEN RETURN[FALSE]};	IF first THEN {PrintCmdCR[];  PrintCmd["Bind /c-s';"L];  first _ FALSE};	PrintCmdSP[];  PrintCmdName[file.name];	IF ~file.codeBound OR file.symbolsBound THEN {	  PrintCmdChar['/];	  IF ~file.codeBound THEN PrintCmd["-c"L];	  IF file.symbolsBound THEN PrintCmd["s"L];	  lastHadSwitch _ TRUE}	ELSE lastHadSwitch _ FALSE;	fileAtDepthPrinted _ TRUE;	EnumerateFilesWithName[file.name, TagOtherVersionsOfFile];	file.tag _ TRUE};       RETURN[FALSE]};           IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    ClearTags[];  -- files are tagged when output (or if name already output)    EnumerateDepths[PrintOneRebindDepth];    IF ~first THEN PrintCmdCR[]};  PrintRepackageCommand: PROC = {    first: BOOLEAN _ TRUE;    depth: CARDINAL _ 0;    printFile, fileAtDepthPrinted: BOOLEAN;        PrintOneRepackageDepth: PROC [d: DepthIndex] RETURNS [stop: BOOLEAN] = {      fileAtDepthPrinted _ FALSE;      EnumerateFilesOfDepth[d, CheckIfBad];      IF ICDefs.switches['p] THEN        IF fileAtDepthPrinted THEN PrintCmd["/p"L];      depth _ depth+1;      RETURN[FALSE]};          CheckIfBad: PROC [f: File] RETURNS [stop: BOOLEAN] = {      OPEN file: feb[f];          CheckOtherVersionsOfFile: PROC [o: File] RETURNS [stop: BOOLEAN] = {        IF o # f AND	~(feb[o].sourceButNoBcd OR feb[o].readProtected OR feb[o].obsolete) THEN {	  printFile _ FALSE;  -- assume o has higher depth	  RETURN[TRUE]};        RETURN[FALSE]};            TagOtherVersionsOfFile: PROC [o: File] RETURNS [stop: BOOLEAN] = {        IF o # f THEN feb[o].tag _ TRUE;  -- don't bind this version        RETURN[FALSE]};             IF ~file.tag AND file.bad      AND file.packaged THEN {        IF depth = 0 THEN {  -- look for higher depth Bcd	  printFile _ TRUE;	  EnumerateFilesWithName[file.name, CheckOtherVersionsOfFile];	  IF ~printFile THEN RETURN[FALSE]};	IF first THEN {PrintCmdCR[];  PrintCmd["Packager"L];  first _ FALSE};	PrintCmdSP[];  PrintCmdName[file.name]; PrintCmd["[?] "L];	fileAtDepthPrinted _ TRUE;	EnumerateFilesWithName[file.name, TagOtherVersionsOfFile];	file.tag _ TRUE};       RETURN[FALSE]};           IF ICDefs.CheckAbort[] THEN ERROR ABORTED;    ClearTags[];  -- files are tagged when output (or if name already output)    EnumerateDepths[PrintOneRepackageDepth];    IF ~first THEN PrintCmdCR[]};      END.
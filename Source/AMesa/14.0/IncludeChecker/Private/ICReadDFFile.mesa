-- ICReadDFFile.mesa  -- Last modified by BTL   on  1-Dec-82 16:34:44 DIRECTORY  BcdDefs USING [Base],  CWF USING [SetWriteProcedure, SWF2, SWF3, WF0, WF1, WF2],  DFSubr USING [    AllocateDFSeq, DF, DFSeq, FlattenDF, FreeDFSeq, ReadInDir, TooManyEntries],  Exec USING [Handle, PutChar],  FileTransfer USING [FileInfo, ListProc],  ICDefs USING [    dfFile, exec, NoteLocalBcdProcessed, NoteRemoteBcdProcessed,    NoteLocalSourceProcessed, NoteRemoteSourceProcessed, ownTable, switches,    ttySW, zone],  ICLists USING [    AddToIncludedList, containType, depthType, dirType, EnterBcd,    EnterSource, File, fileType, FNil, hostType, incDescType,    includeType, markedType, nameType, NullTime, NullVersion],  LeafSubr USING [Close, FileHandle, GetStreamCreation, Open, StartLeaf, StopLeaf],  LongAlloc USING [AddNotify, Base, Handle, Notifier],  MFile USING [CopyFileHandle, Error, GetCreateDate, Handle, ReadOnly, Release],  ProcBcds USING [    InnardsObject, InstallAddressesBcd, InvalidBcd, PrintDepends, ProcDep,    ProcMod, ReadInSegmentsBcd, UnstallBcd],  Put USING [Char],  String USING [    AppendChar, AppendString, Empty, EquivalentString, SubString,    SubStringDescriptor],  Subr USING [    Any, debugflg, EndsIn, errorflg, FileError, SubrInit, SubrStop],  Time USING [Packed],  Transfer USING [EnumerateForProperties, Finalize, Initialize],  Window USING [Handle];    ICReadDFFile: PROGRAM    IMPORTS       CWF, DFSubr, Exec, ICDefs, ICLists, LeafSubr, LongAlloc, MFile,      ProcBcds, Put, String, Subr, Transfer    EXPORTS ICDefs =  BEGIN OPEN ICDefs, ICLists;    MaxFiles: CARDINAL = 500;    icExec: Exec.Handle _ NIL;  -- local copies of ICDefs variables  icTable: LongAlloc.Handle _ NIL;  icZone: UNCOUNTED ZONE _ NIL;  icTTYSW: Window.Handle _ NIL;    headingLogged: BOOLEAN _ FALSE;    feb: LongAlloc.Base;  -- file records  ifb: LongAlloc.Base;  -- included files  idb: LongAlloc.Base;  -- descriptions of included files   cfb: LongAlloc.Base;  -- containing files  hb:  LongAlloc.Base;  -- hosts  db:  LongAlloc.Base;  -- directories  dib: LongAlloc.Base;  -- file depth chain heads  mb:  LongAlloc.Base;  -- marked files  nb:  LongAlloc.Base;  -- names  UpdateBases: LongAlloc.Notifier = {    feb _ base[ICLists.fileType];      ifb _ base[ICLists.includeType];    idb _ base[ICLists.incDescType];    cfb _ base[ICLists.containType];    hb  _ base[ICLists.hostType];    db  _ base[ICLists.dirType];    dib _ base[ICLists.depthType];    mb  _ base[ICLists.markedType];    nb  _ base[ICLists.nameType]};        ReadDFFile: PUBLIC PROC = {    dfFileName: STRING _ [100];      Cleanup: PROC = {      Transfer.Finalize[];  LeafSubr.StopLeaf[];      Subr.SubrStop[deleteZone: FALSE]};          BEGIN ENABLE UNWIND => Cleanup[];    icExec _ ICDefs.exec;  icTable _ ICDefs.ownTable;  icZone _ ICDefs.zone;    icTTYSW _ ICDefs.ttySW;    headingLogged _ FALSE;    icTable.AddNotify[UpdateBases];    Subr.SubrInit[exec: icExec, zone: icZone];    [] _ CWF.SetWriteProcedure[      IF icTTYSW # NIL THEN ToolTTYProc ELSE ExecTTYProc];    Subr.debugflg _ ICDefs.switches['d];  Subr.errorflg _ FALSE;    Transfer.Initialize[exec: icExec, window: icTTYSW];  LeafSubr.StartLeaf[];    String.AppendString[dfFileName, ICDefs.dfFile];    ProcessDFFile[dfFileName      ! DFSubr.TooManyEntries => {          CWF.WF0["Error - too many entries in the DF file.\n"L];          CONTINUE}];    Cleanup[];    END};	  ToolTTYProc: PROC [ch: CHARACTER] = {Put.Char[icTTYSW, ch]};  ExecTTYProc: PROC [ch: CHARACTER] = {Exec.PutChar[icExec, ch]};      ProcessDFFile: PROC [dfFileName: LONG STRING] = {    dfSeq: DFSubr.DFSeq _ NIL;        Cleanup: PROC = {DFSubr.FreeDFSeq[@dfSeq]};        BEGIN ENABLE UNWIND => Cleanup[];    dfSeq _ DFSubr.AllocateDFSeq[maxEntries: MaxFiles, zoneType: shared];    IF dfFileName.length > 0 THEN {      IF ~Subr.Any[dfFileName, '.] THEN        String.AppendString[dfFileName, ".df"L];      IF ~Subr.EndsIn[dfFileName, ".df"L] THEN {        CWF.WF1["Error - %s must be a DF file name.\n"L, dfFileName];        GOTO leave};      CWF.WF1["(Flattening %s)  "L, dfFileName];      DFSubr.FlattenDF[        dfseq: dfSeq, dffilename: dfFileName, exec: icExec, window: icTTYSW,        defaultUserName: NIL, defaultUserPassword: NIL, setRecorder: TRUE,        checkForOverwrite: TRUE, printStatus: ICDefs.switches['d]];      IF dfSeq.size = 0 THEN GOTO leave;      DFSubr.ReadInDir[dfSeq]};  -- get create dates    FOR i: CARDINAL IN [0..dfSeq.size) DO      df: DFSubr.DF _ @dfSeq[i];      SELECT TRUE FROM        Subr.EndsIn[df.shortname, ".bcd"L] =>  -- only examine imports if /r	  IF ~df.readonly OR ICDefs.switches['r] THEN ReadBcd[df];        Subr.EndsIn[df.shortname, ".mesa"L]   => ReadSource[df, mesa];	Subr.EndsIn[df.shortname, ".config"L] => ReadSource[df, config];	Subr.EndsIn[df.shortname, ".pack"L]   => ReadSource[df, pack];	ENDCASE;      ENDLOOP;    EXITS leave => NULL;    END;    Cleanup[]};  ReadBcd: PROC [df: DFSubr.DF] = {    properName: STRING _ [100];    innardsObject: ProcBcds.InnardsObject _ [];    success, readProtected, local: BOOLEAN;    f: ICLists.File _ ICLists.FNil;        procMod: ProcBcds.ProcMod =           -- [sourcefile, smodulename: STRING,      --  bcdvers, sourcevers, creatorvers: BcdDefs.VersionStamp,      --  isdefns, isconfig, ispackaged, iscodebound, issymbolsbound,      --  istablecompiled, altoCode, boundsChecks, cedarSwitch,      --  crossJump, linksInCode, nilChecks, sortByUsage: BOOLEAN,      --  symbolSpace: FileParms.SymbolSpace] RETURNS [uns: UNSPECIFIED]      BEGIN      f _ ICLists.EnterBcd[        host: (IF local THEN "ME"L ELSE df.host),	dir:  (IF local THEN NIL ELSE df.directory),	file: properName,        config: isconfig, packaged: ispackaged, version: bcdvers,         sourceDate: LOOPHOLE[sourcevers.time, Time.Packed]];      feb[f].imported      _ df.readonly;      feb[f].sameBcdInDFfile _        (~local OR df.createtime = MFile.GetCreateDate[df.fHandle]);      feb[f].defModule     _ isdefns;      feb[f].tableCompiled _ istablecompiled;      feb[f].boundsCheck   _ boundsChecks;      feb[f].nilCheck      _ nilChecks;      feb[f].crossJumped   _ crossJump;      feb[f].codeBound     _ iscodebound;      feb[f].symbolsBound  _ issymbolsbound;      END;          procDep: ProcBcds.ProcDep =       -- [relcode: RelCode, smodulename, filename: STRING,      --  bcdvers: BcdDefs.VersionStamp, uns: UNSPECIFIED]      BEGIN      nameSS: String.SubStringDescriptor;      IF relcode # otherdepends AND relcode # canignore AND relcode # defstype        THEN RETURN;      IF filename.length = 0 THEN RETURN;      IF bcdvers = ICLists.NullVersion THEN RETURN;      IF Subr.Any[filename, '.] THEN        IF ~Subr.EndsIn[filename, ".bcd"L] THEN RETURN;      nameSS.base _ filename;  nameSS.offset _ 0;  nameSS.length _ filename.length;      RemoveExt[@nameSS];      ICLists.AddToIncludedList[        container: f, 	included: @nameSS, version: bcdvers];      END;          BEGIN  -- main body of ReadBcd      ENABLE        UNWIND => {          IF innardsObject.rHandle # NIL THEN {	    LeafSubr.Close[innardsObject.rHandle];  innardsObject.rHandle _ NIL};	  IF innardsObject.fHandle # NIL THEN {	    MFile.Release[innardsObject.fHandle];  innardsObject.fHandle _ NIL}};    StripExtension[df.shortname, properName];    [innardsObject.fHandle, innardsObject.rHandle, readProtected] _ CachedFile[df       ! Subr.FileError => {  -- notFound or wrongVersion          IF error = wrongVersion THEN             CWF.WF2[              "   File %s of %lt cannot be found.\n"L,	      df.shortname, @df.createtime]	  ELSE CWF.WF1["   File %s cannot be found.\n"L, df.shortname];	  Subr.errorflg _ TRUE;          GOTO leave}];    IF readProtected THEN {ProcessReadProtectedBcd[df, properName];  GOTO leave};    local _ (innardsObject.rHandle = NIL);    IF local THEN ICDefs.NoteLocalBcdProcessed[]    ELSE ICDefs.NoteRemoteBcdProcessed[];    success _ TRUE;    ProcBcds.ReadInSegmentsBcd[@innardsObject      ! ProcBcds.InvalidBcd => {          ProcessObsoleteBcd[df, properName];  success _ FALSE;  CONTINUE}];    IF success THEN {      ProcBcds.InstallAddressesBcd[@innardsObject];      [success] _ ProcBcds.PrintDepends[        innards: @innardsObject,        procMod: procMod, procDep: procDep,        print: Subr.debugflg, calltwice: FALSE, less: TRUE,	bcdfilename: df.shortname]};    IF ~success THEN {      CWF.WF1["\nError - couldn't analyze %s correctly.\n"L, df.shortname];      Subr.errorflg _ TRUE};    IF innardsObject.rHandle # NIL THEN {      LeafSubr.Close[innardsObject.rHandle];  innardsObject.rHandle _ NIL};    IF innardsObject.fHandle # NIL THEN {      MFile.Release[innardsObject.fHandle];  innardsObject.fHandle _ NIL};    ProcBcds.UnstallBcd[@innardsObject];    EXITS leave => Subr.errorflg _ TRUE;    END};    StripExtension: PROC [name, noExt: LONG STRING] = {    noExt.length _ 0;    FOR i: CARDINAL IN [0..name.length) DO      IF name[i] = '. THEN RETURN ELSE String.AppendChar[noExt, name[i]];      ENDLOOP};	      ProcessReadProtectedBcd: PROC [df: DFSubr.DF, properName: STRING] = {    f: File _ ICLists.EnterBcd[      host: df.host, dir: df.directory, file: properName,      config: FALSE, packaged: FALSE, version: NullVersion, sourceDate: NullTime];    feb[f].readProtected _ TRUE};  ProcessObsoleteBcd: PROC [df: DFSubr.DF, properName: STRING] = {    f: File _ ICLists.EnterBcd[      host: df.host, dir: df.directory, file: properName,      config: FALSE, packaged: FALSE, version: NullVersion, sourceDate: NullTime];    feb[f].obsolete _ TRUE};	  RemoveExt: PROC [ss: String.SubString] = {    FOR i: CARDINAL IN [0..ss.length) DO      IF ss.base[i + ss.offset] = '. THEN {ss.length _ i;  RETURN};      ENDLOOP};         ReadSource: PROC [df: DFSubr.DF, kind: {mesa, config, pack}] = {    properName: STRING _ [100];    innardsObject: ProcBcds.InnardsObject _ [];    readProtected, local: BOOLEAN;    localCreateDate: Time.Packed;    f: ICLists.File _ ICLists.FNil;    BEGIN      ENABLE        UNWIND => {          IF innardsObject.rHandle # NIL THEN {	    LeafSubr.Close[innardsObject.rHandle];  innardsObject.rHandle _ NIL};	  IF innardsObject.fHandle # NIL THEN {	    MFile.Release[innardsObject.fHandle];  innardsObject.fHandle _ NIL}};    StripExtension[df.shortname, properName];    [innardsObject.fHandle, innardsObject.rHandle, readProtected] _ CachedFile[df       ! Subr.FileError => {          IF error = wrongVersion THEN             CWF.WF2[              "   File %s of %lt cannot be found.\n"L,	      df.shortname, @df.createtime]	  ELSE CWF.WF1["   File %s cannot be found.\n"L, df.shortname];	  Subr.errorflg _ TRUE;          GOTO leave}];    IF readProtected THEN {ProcessReadProtectedSource[df];  GOTO leave};    local _ (innardsObject.rHandle = NIL);    IF local THEN {      localCreateDate _ MFile.GetCreateDate[df.fHandle];      ICDefs.NoteLocalSourceProcessed[]}    ELSE ICDefs.NoteRemoteSourceProcessed[];    f _ ICLists.EnterSource[      host: (IF local THEN "ME"L ELSE df.host),      dir:  (IF local THEN NIL ELSE df.directory),      file: properName,      config: (kind = config), packaged: (kind = pack),      sourceDate: (IF local THEN localCreateDate ELSE df.createtime)];    feb[f].imported _ df.readonly;    feb[f].sameSourceInDFfile _ (~local OR df.createtime = localCreateDate);    IF innardsObject.rHandle # NIL THEN {      LeafSubr.Close[innardsObject.rHandle];  innardsObject.rHandle _ NIL};    IF innardsObject.fHandle # NIL THEN {      MFile.Release[innardsObject.fHandle];  innardsObject.fHandle _ NIL};    ProcBcds.UnstallBcd[@innardsObject];    EXITS leave => NULL;    END};	      ProcessReadProtectedSource: PROC [df: DFSubr.DF] = {    LogHeadingIfNeeded[];    CWF.WF1["  %s is read protected\n"L, df.shortname]};   LogHeadingIfNeeded: PROC = {    IF ~headingLogged THEN {      CWF.WF0["\nProblems encountered while reading files:\n"L];      headingLogged _ TRUE}};      -- file was found locally if returned rHandle is NIL, otherwise remote  CachedFile: PROC [        df: DFSubr.DF]      RETURNS [        fHandle: MFile.Handle, rHandle: LeafSubr.FileHandle,	readProtected: BOOLEAN] = {    localCreateTime: Time.Packed _ [0];    fHandle _ NIL;  rHandle _ NIL;  readProtected _ FALSE;    -- try for any local version (unless Imported file)    IF df.presentonlocaldisk THEN       fHandle _ MFile.CopyFileHandle[        file: df.fHandle, release: [], access: readOnly]    ELSE   -- see if file is readProtected      fHandle _ MFile.ReadOnly[name: df.shortname, release: []         ! MFile.Error =>             SELECT code FROM              protectionFault => {readProtected _ TRUE;  CONTINUE};              ENDCASE => CONTINUE];    IF readProtected THEN RETURN;    IF fHandle # NIL THEN {      IF ~df.readonly THEN RETURN;  -- use the local file      localCreateTime _ MFile.GetCreateDate[fHandle];      IF df.createtime = localCreateTime      OR (df.createtime = Time.Packed[0] AND String.Empty[df.host]) THEN RETURN};    -- look on remote server    BEGIN    name: STRING _ [100];    foundOneVersion: BOOLEAN _ FALSE;    realName: STRING _ [100];        CheckOneFile: FileTransfer.ListProc = {      remoteInfo: FileTransfer.FileInfo _ info[conn].source;      foundOneVersion _ TRUE;      IF df.createtime = remoteInfo.create THEN         CWF.SWF3[	  realName, "<%s>%s!%s"L,	  remoteInfo.directory, remoteInfo.body, remoteInfo.version];      RETURN[do]};          IF String.EquivalentString[df.host, "Unknown"L] THEN      ERROR Subr.FileError[notFound];    IF df.version > 0 AND df.criterion = none    AND df.createtime # Time.Packed[0] THEN       CWF.SWF3[name, "<%s>%s!%u"L, df.directory, df.shortname, @df.version]    ELSE       CWF.SWF2[name, "<%s>%s!H"L, df.directory, df.shortname];    rHandle _ LeafSubr.Open[df.host, name];    IF df.createtime # Time.Packed[0] THEN {      IF LeafSubr.GetStreamCreation[rHandle] # df.createtime THEN {        LeafSubr.Close[rHandle];        CWF.SWF3[name, "[%s]<%s>%s!*"L, df.host, df.directory, df.shortname];        Transfer.EnumerateForProperties[fileName: name, enumProc: CheckOneFile];        IF ~foundOneVersion THEN GOTO notfound;	IF realName.length = 0 THEN GOTO wrongVersion;  -- no correct version found        rHandle _ LeafSubr.Open[df.host, realName]}};    EXITS      notfound => ERROR Subr.FileError[notFound];      wrongVersion => ERROR Subr.FileError[wrongVersion];    END};      END.      
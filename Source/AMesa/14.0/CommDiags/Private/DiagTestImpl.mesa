-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- DiagTestImpl.mesa - last edited by  SMA   5-Feb-85 12:38:04DIRECTORY  AddressTranslation USING [Error, StringToNetworkAddress],  CommOnlineDiagnostics USING [CommError, CommErrorCode, CountType, DialupOutcome,    DialupTest, EchoDiagHandle, EchoParams, EchoResults, EtherDiagError,     EtherStatsInfo, EventReporter, FreeHistogram, GetEchoCounters, GetEchoResults,    GetEthernetStats, GetRS232CResults, RS232CDiagHandle, Histogram, ModemChange,    PatternType, RS232CDiagError, StartRS232CTest, RS232CParams, SetDiagnosticLine,    StartEchoUser, StatsIndices, WordsInPacket, WriteMsg],  Dialup USING [Number],  DiagTestInternal,  FormSW USING [AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, Enumerated, EnumeratedItem, line0, line1, line2,    line3, line4, line5, line6, line7, line8, line9, LineN, LongNumberItem,    NumberItem, ProcType, StringItem, TagOnlyItem],  Heap USING [systemZone],  Process USING [Abort, InvalidProcess, Pause, priorityNormal, SecondsToTicks,    SetPriority],  Put USING [Decimal, Line, LongDecimal, Text],  RS232C USING [CharLength, Correspondent, LineSpeed, LineType, Parity],   Tool USING [Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],  RS232CCorrespondents USING [xerox800, xerox850, system6, cmcII, ttyHost,    nsSystemElement, ibm3270Host, ibm2770Host, ibm6670Host, ibm6670, xerox860,    nsSystemElementBSC, siemens9750],  System USING [GetClockPulses, GreenwichMeanTime, NetworkAddress,    Pulses, PulsesToMicroseconds],  Time USING [Append, Unpack],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle, Box];DiagTestImpl: MONITOR  IMPORTS    AddressTranslation, CommOnlineDiagnostics, DiagTestInternal, FormSW, Heap,    Process, Put, System, Time, Tool, UserInput  EXPORTS DiagTestInternal =  BEGIN    -- Tests the retrieval of intermediate results by calling GetEchoResults or  -- GetRS232CResults every 10 seconds.  eRetriever: PROCESS ¬ NIL;   eH: CommOnlineDiagnostics.EchoDiagHandle ¬ NIL;  call: PROCESS ¬ NIL;     --The forked call that we can abort.  watcher: PROCESS ¬ NIL;  --The abort key watcher.      --The linked lists of handles identifying a test.  RS232CEntryPtr: TYPE = LONG POINTER TO RS232CEntry;  RS232CEntry: TYPE = RECORD[    handle: CommOnlineDiagnostics.RS232CDiagHandle,    line: CARDINAL,  --port number.    retriever: PROCESS,  --retreiving intermediate results.    time: System.Pulses,  --time last displayed.    frames: LONG CARDINAL,  --number of frames last displayed.    next: RS232CEntryPtr];  rs232cHs: RS232CEntryPtr ¬ NIL;  data: PUBLIC DiagTestInternal.DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  z: UNCOUNTED ZONE = Heap.systemZone;    initialBox: Window.Box = [place: [x:420, y: 28], dims: [w: 514, h: 724]];  host: System.NetworkAddress;    -- the names of the indices in the GetEtherStats proc.  statStrings: ARRAY CommOnlineDiagnostics.StatsIndices OF LONG STRING ¬ [    "echoServerPkts", "echoServerBytes", "packetsRecv", "wordsRecv",    "packetsMissed", "badRecvStatus", "okButDribble", "badCrc",     "badAlignmentButOkCrc", "crcAndBadAlignment", "packetTooLong", "overrun",    "idleInput", "packetsSent", "wordsSent", "badSendStatus", "tooManyCollisions",    "lateCollisions", "underrun", "stuckOutput", "coll1", "coll2", "coll3",    "coll4", "coll5", "coll6", "coll7", "coll8", "coll9", "coll10", "coll11",    "coll12", "coll13", "coll14", "coll15", "coll16", "spare"];      --The strings for the communications errors.  xlate: ARRAY CommOnlineDiagnostics.CommErrorCode OF LONG STRING ¬ [    transmissionMediumProblem: "transmissionMediumProblem",    noAnswerOrBusy: "noAnswerOrBusy",    noRouteToSystemElement: "noRouteToSystemElement",    transportTimeout: "transportTimeout",    remoteSystemElementNotResponding: "remoteSystemElementNotResponding",    noCourierAtRemoteSite: "noCourierAtRemoteSite",    tooManyConnections: "tooManyConnections",    invalidMessage: "invalidMessage",    noSuchDiagnostic: "noSuchDiagnostic",    returnTimedOut: "returnTimedOut",    callerAborted: "callerAborted",    unknownErrorInRemoteProcedure: "unknownErrorInRemoteProcedure",    streamNotYours: "streamNotYours",    truncatedTransfer: "truncatedTransfer",    parameterInconsistency: "parameterInconsistency",    invalidArguments: "invalidArguments",    protocolMismatch: "protocolMismatch",    duplicateProgramExport: "duplicateProgramExport",    noSuchProgramExport: "noSuchProgramExport",    invalidHandle: "invalidHandle",    noError: "noError"];        AddRS232CHandle: PROC [h: CommOnlineDiagnostics.RS232CDiagHandle,    line: CARDINAL] =    BEGIN    new: RS232CEntryPtr ¬ z.NEW[RS232CEntry ¬ [      h, line, NIL, System.GetClockPulses[], 0, rs232cHs]];    rs232cHs ¬ new;    END;  --AddRS232CHandle         GetRS232CHandle: PROC [line: CARDINAL, remove: BOOLEAN]    RETURNS [e: RS232CEntryPtr] =    BEGIN    prev: RS232CEntryPtr ¬ NIL;    FOR e ¬ rs232cHs, e.next UNTIL e = NIL DO      IF e.line = line THEN	BEGIN	IF remove THEN	  BEGIN	  IF prev = NIL THEN rs232cHs ¬ e.next	  ELSE prev.next ¬ e.next;	  END;	EXIT;	END;      prev ¬ e;      ENDLOOP;    END;  --GetRS232CHandle          StartRS232C: FormSW.ProcType =    BEGIN    DoTest[CallRS232CStart];    END;  --StartRS232C      StopRS232C: FormSW.ProcType =    BEGIN    DoTest[CallRS232CStop];    END;  --StopRS232C      StartEcho: FormSW.ProcType =    BEGIN    DoTest[CallEchoStart];    END;  --StartEcho      StopEcho: FormSW.ProcType =    BEGIN    DoTest[CallEchoStop];    END;  --StopEcho          DoTest: ENTRY PROC [test: PROC] =    BEGIN  --So watcher can abort the call.    watcher ¬ FORK Watcher[];    call ¬ FORK test[];    JOIN call;    Process.Abort[watcher];    JOIN watcher;    END;  --DoTest          Watcher: PROC =    BEGIN    ENABLE ABORTED => GOTO exit;    Process.SetPriority[Process.priorityNormal];    WHILE ~UserInput.UserAbort[data.fileSW] DO      Process.Pause[Process.SecondsToTicks[1]];      ENDLOOP;    Process.Abort[call ! Process.InvalidProcess => CONTINUE];    EXITS exit => NULL;    END;  -- Watcher        CallRS232CStart: PROC =    BEGIN    ENABLE      BEGIN      ABORTED => GOTO exit;      CommOnlineDiagnostics.CommError =>        BEGIN        Put.Text[data.fileSW, "CommError; reason = "L];        Put.Line[data.fileSW, xlate[reason]];	GOTO exit;        END;      CommOnlineDiagnostics.RS232CDiagError =>        BEGIN	Put.Text[data.fileSW, "RS232CDiagError; reason = "L];	Put.Line[data.fileSW, SELECT reason FROM          aborted => "aborted"L,	  noHardware => "noHardware"L,	  noSuchLine => "noSuchLine"L,	  channelInUse => "channelInUse"L,	  unimplementedFeature => "unimplementedFeature"L,	  invalidParameter => "invalidParameter"L,	  invalidHandle => "invalidHandle"L,	  ENDCASE => "???"L];	GOTO exit;	END;      END;  -- catch series.    wm: CommOnlineDiagnostics.WriteMsg ¬ NIL;    mc: CommOnlineDiagnostics.ModemChange ¬ NIL;    sdl: CommOnlineDiagnostics.SetDiagnosticLine ¬ NIL;    params: CommOnlineDiagnostics.RS232CParams;    h: CommOnlineDiagnostics.RS232CDiagHandle;    success: BOOLEAN;    IF data.hostString = NIL THEN      BEGIN      Put.Line[data.msgSW, "Invalid address"L];      RETURN;      END;    [host, success] ¬ TranslateHost[data.hostString];    IF ~success THEN GOTO exit;    IF data.writeMsg = call THEN wm ¬ DiagTestInternal.MyWriteMsg;    IF data.modemChange = call THEN mc ¬ DiagTestInternal.MyModemChange;    IF data.setDiagnosticLine = call THEN sdl ¬ DiagTestInternal.MySetDiagLine;    params.testCount ¬ data.testCount;    params.safetyTOInMsecs ¬ data.rSafetyTOInMsecs;    params.lineSpeed ¬ data.lineSpeed;    params.correspondent ¬ data.correspondent;    params.lineType ¬ data.lineType;    params.lineNumber ¬ data.lineNumber;    params.parity ¬ data.parity;    params.charLength ¬ SELECT data.charLength FROM      5 => 5,      6 => 6,      7 => 7,      ENDCASE => 8;    params.pattern ¬ data.pattern;    params.constant ¬ data.rConstant;    params.dataLengths ¬ [data.dataLenLow, data.dataLenHi];    Put.Line[data.fileSW, "StartRS232CTest[]"L];    h ¬ CommOnlineDiagnostics.StartRS232CTest[params, sdl, wm, mc, host];    AddRS232CHandle[h, params.lineNumber];    -- If the user specifies a safety timeout of more than 60 secs, lets go into    -- a lengthy test mode and keep calling StartRS232CTest w/stopIt = FALSE to    -- reset the timeout.  Remember, the test may still enter idle state by    -- reaching totalCount.    IF params.safetyTOInMsecs >= 60000 THEN  --we know our handle is at the front      rs232cHs.retriever ¬ FORK RRetriever[params.lineNumber];    EXITS exit => NULL;    END;  -- StartRSC232C  CallRS232CStop: PROC =    BEGIN    ENABLE      BEGIN      ABORTED => GOTO exit;      CommOnlineDiagnostics.CommError =>        BEGIN        Put.Text[data.fileSW, "CommError; reason = "L];        Put.Line[data.fileSW, xlate[reason]];	GOTO exit;        END;      CommOnlineDiagnostics.RS232CDiagError =>        BEGIN	Put.Text[data.fileSW, "RS232CDiagError; reason = "L];	Put.Line[data.fileSW, SELECT reason FROM          aborted => "aborted"L,	  noHardware => "noHardware"L,	  noSuchLine => "noSuchLine"L,	  channelInUse => "channelInUse"L,	  unimplementedFeature => "unimplementedFeature"L,	  invalidParameter => "invalidParameter"L,	  invalidHandle => "invalidHandle"L,	  ENDCASE => "???"L];	GOTO exit;	END;      END;  -- catch series.    c: CommOnlineDiagnostics.CountType;    e: RS232CEntryPtr ¬ NIL;    success: BOOLEAN;    IF data.hostString = NIL THEN      BEGIN      Put.Line[data.msgSW, "Invalid address"L];      RETURN;      END;    [host, success] ¬ TranslateHost[data.hostString];    IF ~success THEN GOTO exit;    IF (e ¬ GetRS232CHandle[line: data.lineNumber, remove: TRUE]) = NIL THEN      {Put.Line[data.fileSW, "no test running on the port!"]; RETURN};    IF e.retriever # NIL THEN      BEGIN  -- stop the other guy who is calling GetRS232CResults.      Process.Abort[e.retriever];      JOIN e.retriever;      e.retriever ¬ NIL;      END;    Put.Line[data.fileSW, ""];    Put.Text[data.fileSW, "*** line = "L];    Put.Decimal[data.fileSW, e.line];    [c] ¬ CommOnlineDiagnostics.GetRS232CResults[      dH: e.handle, stopIt: TRUE, host: host];    z.FREE[@e];    DiagTestInternal.PrintRS232CTotals[c];    Put.Line[data.fileSW, ""];    EXITS exit => NULL;    END;  -- CallRS232CStop      CallEchoStart: PROC =    BEGIN    ENABLE       BEGIN      ABORTED => GOTO exit;      CommOnlineDiagnostics.CommError =>        BEGIN        Put.Text[data.fileSW, "CommError; reason = "L];        Put.Line[data.fileSW, xlate[reason]];	GOTO exit;        END;      CommOnlineDiagnostics.EtherDiagError =>        BEGIN	Put.Text[data.fileSW, "EtherDiagError; reason = "L];        Put.Line[data.fileSW, SELECT reason FROM          echoUserNotThere => "echoUserNotThere"L,	  noMoreNets => "noMoreNets"L,	  invalidHandle => "invalidHandle"L,	  ENDCASE => "???"L];	GOTO exit;	END;      END;  -- catch series.    ev: CommOnlineDiagnostics.EventReporter ¬ NIL;    params: CommOnlineDiagnostics.EchoParams ¬ [];    target: System.NetworkAddress;    success: BOOLEAN;        IF data.hostString = NIL THEN      BEGIN      Put.Line[data.msgSW, "Invalid address"L];      RETURN;      END;    [host, success] ¬ TranslateHost[data.hostString];    IF ~success THEN GOTO exit;    Put.Line[data.fileSW, "StartEchoUser[]"L];    IF data.eventReporter = call THEN ev ¬ DiagTestInternal.MyEventRep;    IF ~data.useDefaults THEN      BEGIN      IF data.targetSystemElement = NIL THEN        BEGIN        Put.Line[data.msgSW, "Invalid address"L];        RETURN;        END;      [target,success] ¬ TranslateHost[data.targetSystemElement];      IF ~success THEN GOTO exit;      params.totalCount ¬ data.totalCount;      params.safetyTOInMsecs ¬ data.eSafetyTOInMsecs;      params.minPacketSizeInBytes ¬ data.minPacketSizeInBytes;      params.maxPacketSizeInBytes ¬ data.maxPacketSizeInBytes;      params.wordContents ¬ data.wordContents;      params.constant ¬ data.eConstant;      params.minMsecsBetweenPackets ¬ data.minMsecsBetweenPackets;      params.checkContents ¬ data.checkContents;      params.waitForResponse ¬ data.waitForResponse;      END    ELSE target ¬ host;    eH ¬ CommOnlineDiagnostics.StartEchoUser[target, params, ev, host];    -- If the user specifies a safety timeout of more than 60 secs, lets go into    -- a lengthy test mode and keep calling GetEchoResults w/stopIt = FALSE to    -- reset the timeout.  Remember, the test may still enter idle state by    -- reaching totalCount.    IF params.safetyTOInMsecs >= 60000 THEN      eRetriever ¬ FORK ERetriever[];    EXITS exit => NULL;    END;  -- CallEchoStart  CallEchoStop: PROC =    BEGIN    ENABLE      BEGIN      ABORTED => GOTO exit;      CommOnlineDiagnostics.CommError =>        BEGIN        Put.Text[data.fileSW, "CommError; reason = "L];        Put.Line[data.fileSW, xlate[reason]];	GOTO exit;        END;      CommOnlineDiagnostics.EtherDiagError =>        BEGIN	Put.Text[data.fileSW, "EtherDiagError; reason = "L];        Put.Line[data.fileSW, SELECT reason FROM          echoUserNotThere => "echoUserNotThere"L,	  noMoreNets => "noMoreNets"L,	  invalidHandle => "invalidHandle"L,	  ENDCASE => "???"L];	GOTO exit;	END;      END;  -- catch series.    t: CommOnlineDiagnostics.EchoResults;    h: CommOnlineDiagnostics.Histogram;    success: BOOLEAN;    IF data.hostString = NIL THEN      BEGIN      Put.Line[data.msgSW, "Invalid address"L];      RETURN;      END;    [host, success] ¬ TranslateHost[data.hostString];    IF ~success THEN GOTO exit;    IF eRetriever # NIL THEN      BEGIN  -- stop the other guy who is calling GetEchoResults.      Process.Abort[eRetriever];      JOIN eRetriever;      eRetriever ¬ NIL;      END;    Put.Line[data.fileSW, "GetEchoResults[]"L];    [t, h] ¬ CommOnlineDiagnostics.GetEchoResults[eH, TRUE, host];    DiagTestInternal.PrintEchoTotals[t, h];    CommOnlineDiagnostics.FreeHistogram[h];    Put.Line[data.fileSW, ""];    EXITS exit => NULL;    END;  -- CallEchoStop  GetStats:  FormSW.ProcType =    BEGIN    ENABLE      BEGIN      ABORTED => GOTO exit;      CommOnlineDiagnostics.CommError =>        BEGIN        Put.Text[data.fileSW, "CommError; reason = "L];        Put.Line[data.fileSW, xlate[reason]];	GOTO exit;        END;      CommOnlineDiagnostics.EtherDiagError =>        BEGIN	Put.Text[data.fileSW, "EtherDiagError; reason = "L];        Put.Line[data.fileSW, SELECT reason FROM          echoUserNotThere => "echoUserNotThere"L,	  noMoreNets => "noMoreNets"L,	  invalidHandle => "invalidHandle"L,	  ENDCASE => "???"L];	GOTO exit;	END;      END;  -- catch series.    s: LONG STRING ¬ [50];    time: System.GreenwichMeanTime;    stats: CommOnlineDiagnostics.EtherStatsInfo;    success: BOOLEAN;    IF data.hostString = NIL THEN      BEGIN      Put.Line[data.msgSW, "Invalid address"L];      RETURN;      END;    [host, success] ¬ TranslateHost[data.hostString];    IF ~success THEN GOTO exit;    Put.Line[data.fileSW, "GetEthernetStats[]"L];    [stats, time] ¬ CommOnlineDiagnostics.GetEthernetStats[      data.physicalOrder, host];    Put.Line[data.fileSW, "Results: "L];    FOR i: CommOnlineDiagnostics.StatsIndices IN       CommOnlineDiagnostics.StatsIndices DO      Put.Text[data.fileSW, statStrings[i]];      Put.Text[data.fileSW, " = "L];      Put.LongDecimal[data.fileSW, stats[i]];      Put.Text[data.fileSW, " ,"L];      ENDLOOP;    Time.Append[s, Time.Unpack[time]];    Put.Line[data.fileSW, s];    Put.Line[data.fileSW, ""];    EXITS exit => NULL;    END;  -- GetStats  GetECounters:  FormSW.ProcType =    BEGIN    ENABLE      BEGIN      ABORTED => GOTO exit;      CommOnlineDiagnostics.CommError =>        BEGIN        Put.Text[data.fileSW, "CommError; reason = "L];        Put.Line[data.fileSW, xlate[reason]];	GOTO exit;        END;      CommOnlineDiagnostics.EtherDiagError =>        BEGIN	Put.Text[data.fileSW, "EtherDiagError; reason = "L];        Put.Line[data.fileSW, SELECT reason FROM          echoUserNotThere => "echoUserNotThere"L,	  noMoreNets => "noMoreNets"L,	  invalidHandle => "invalidHandle"L,	  ENDCASE => "???"L];	GOTO exit;	END;      END;  -- catch series.    s: LONG STRING ¬ [50];    p, b: LONG CARDINAL;    time: System.GreenwichMeanTime;    success: BOOLEAN;    IF data.hostString = NIL THEN      BEGIN      Put.Line[data.msgSW, "Invalid address"L];      RETURN;      END;    [host, success] ¬ TranslateHost[data.hostString];    IF ~success THEN GOTO exit;    Put.Line[data.fileSW, "GetEchoCounters[]"L];    [p, b, time] ¬ CommOnlineDiagnostics.GetEchoCounters[host];    Put.Text[data.fileSW, "Results: packets = "L];    Put.LongDecimal[data.fileSW, p];    Put.Text[data.fileSW, ", bytes = "L];    Put.LongDecimal[data.fileSW, b];    Put.Text[data.fileSW, ", time = "L];    Time.Append[s, Time.Unpack[time]];    Put.Line[data.fileSW, s];    Put.Line[data.fileSW, ""];    EXITS exit => NULL;    END;  --GetECounters  DialerTest:  FormSW.ProcType =    BEGIN    ENABLE      BEGIN      ABORTED => GOTO exit;      CommOnlineDiagnostics.CommError =>        BEGIN        Put.Text[data.fileSW, "CommError; reason = "L];        Put.Line[data.fileSW, xlate[reason]];	GOTO exit;        END;      CommOnlineDiagnostics.EtherDiagError =>        BEGIN	Put.Text[data.fileSW, "EtherDiagError; reason = "L];        Put.Line[data.fileSW, SELECT reason FROM          echoUserNotThere => "echoUserNotThere"L,	  noMoreNets => "noMoreNets"L,	  invalidHandle => "invalidHandle"L,	  ENDCASE => "???"L];	GOTO exit;	END;      END;  -- catch series.    phoneNum: LONG POINTER TO Dialup.Number;      outcome: CommOnlineDiagnostics.DialupOutcome;     success: BOOLEAN;       IF data.phoneNumber # NIL THEN      phoneNum ¬ z.NEW[Dialup.Number[data.phoneNumber.length]];    IF data.hostString = NIL THEN      BEGIN      Put.Line[data.msgSW, "Invalid address"L];      RETURN;      END;    [host, success] ¬ TranslateHost[data.hostString];    IF ~success THEN GOTO exit;    Put.Line[data.fileSW, "Dialer[]"L];      FOR i: CARDINAL IN [0..data.phoneNumber.length) DO        phoneNum[i] ¬ LOOPHOLE[data.phoneNumber[i] - '0];        ENDLOOP;    outcome ¬ CommOnlineDiagnostics.DialupTest[0, phoneNum, RS366, host];    Put.Text[data.fileSW, "outcome = "L];    Put.Line[data.fileSW, SELECT outcome FROM        success => "success."L,	failure => "failure."L,	aborted => "aborted."L,	formatError => "formatError."L,	transmissionError => "transmissionError."L,	dataLineOccupied => "dataLineOccupied."L,	dialerNotPresent => "dialerNotPresent."L,	dialingTimeout => "dialingTimeout."L,	transferTimeout => "transferTimeout."L,	otherError => "otherError."L,	noHardware => "noHardware."L,	noSuchLine => "noSuchLine."L,	channelInUse => "channelInUse."L,	unimplementedFeature => "unimplementedFeature."L,	invalidParamater => "invalidParamater."L,	ENDCASE => "???"L];    Put.Line[data.fileSW, ""];    z.FREE[@phoneNum];    EXITS exit => NULL;    END;  -- DialerTest  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ z.NEW[DiagTestInternal.Data ¬ []];      new = inactive =>        BEGIN        IF data # NIL THEN z.FREE[@data];	data ¬ NIL;	END;      ENDCASE;    END;  Init: PROCEDURE =    BEGIN    IF data = NIL THEN data ¬ z.NEW[DiagTestInternal.Data ¬ []];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: initialBox,      clientTransition: ClientTransition, name: "CommDiagTest"L,      cmSection: "CommDiagTest"L];    END;  MakeSWs: Tool.MakeSWsProc = BEGIN    logName: LONG STRING ¬ [19];    Tool.UnusedLogName[unused: logName, root: "CommDiagTest.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    nItems: CARDINAL = 43;    j: CARDINAL;    pattern: ARRAY[0..5) OF Enumerated ¬ [      ["zero"L, CommOnlineDiagnostics.PatternType[zero]],      ["ones"L, CommOnlineDiagnostics.PatternType[ones]],      ["oneZeroes"L, CommOnlineDiagnostics.PatternType[oneZeroes]],      ["constant"L, CommOnlineDiagnostics.PatternType[constant]],      ["byteIncr"L, CommOnlineDiagnostics.PatternType[byteIncr]]];    lineSpeed: ARRAY[0..19) OF Enumerated ¬ [      ["bps50"L, RS232C.LineSpeed[bps50]],      ["bps75"L, RS232C.LineSpeed[bps75]],      ["bps110"L, RS232C.LineSpeed[bps110]],      ["bps134p5"L, RS232C.LineSpeed[bps134p5]],      ["bps150"L, RS232C.LineSpeed[bps150]],      ["bps300"L, RS232C.LineSpeed[bps300]],      ["bps600"L, RS232C.LineSpeed[bps600]],      ["bps1200"L, RS232C.LineSpeed[bps1200]],      ["bps2400"L, RS232C.LineSpeed[bps2400]],      ["bps3600"L, RS232C.LineSpeed[bps3600]],      ["bps4800"L, RS232C.LineSpeed[bps4800]],      ["bps7200"L, RS232C.LineSpeed[bps7200]],      ["bps9600"L, RS232C.LineSpeed[bps9600]],      ["bps19200"L, RS232C.LineSpeed[bps19200]],      ["bps28800"L, RS232C.LineSpeed[bps28800]],      ["bps38400"L, RS232C.LineSpeed[bps38400]],      ["bps48000"L, RS232C.LineSpeed[bps48000]],      ["bps56000"L, RS232C.LineSpeed[bps56000]],      ["bps57600"L, RS232C.LineSpeed[bps57600]]];    correspondent: ARRAY[0..13) OF Enumerated ¬ [      ["xerox800"L, RS232CCorrespondents.xerox800],      ["xerox850"L, RS232CCorrespondents.xerox850],      ["system6"L, RS232CCorrespondents.system6],      ["cmcII"L, RS232CCorrespondents.cmcII],      ["ttyHost"L, RS232CCorrespondents.ttyHost],      ["nsSystemElement"L, RS232CCorrespondents.nsSystemElement],      ["ibm3270Host"L, RS232CCorrespondents.ibm3270Host],      ["ibm2770Host"L, RS232CCorrespondents.ibm2770Host],      ["ibm6670Host"L, RS232CCorrespondents.ibm6670Host],      ["ibm6670"L, RS232CCorrespondents.ibm6670],      ["xerox860"L, RS232CCorrespondents.xerox860],      ["nsSystemElementBSC"L, RS232CCorrespondents.nsSystemElementBSC],      ["siemens9750"L, RS232CCorrespondents.siemens9750]];    setDiagnosticLine: ARRAY[0..2) OF Enumerated ¬ [      ["call"L, DiagTestInternal.CallbackState[call]], ["dontCall"L,        DiagTestInternal.CallbackState[dontCall]]];    parity: ARRAY[0..3) OF Enumerated ¬ [      ["even"L, RS232C.Parity[even]],      ["odd"L, RS232C.Parity[odd]],      ["none"L, RS232C.Parity[none]]];    writeMsg: ARRAY[0..2) OF Enumerated ¬ [      ["call"L, DiagTestInternal.CallbackState[call]],        ["dontCall"L, DiagTestInternal.CallbackState[dontCall]]];    modemChange: ARRAY[0..2) OF Enumerated ¬ [      ["call"L, DiagTestInternal.CallbackState[call]],        ["dontCall"L, DiagTestInternal.CallbackState[dontCall]]];    eventReporter: ARRAY[0..2) OF Enumerated ¬ [      ["call"L, DiagTestInternal.CallbackState[call]],        ["dontCall"L, DiagTestInternal.CallbackState[dontCall]]];    wordContents: ARRAY[0..5) OF Enumerated ¬ [      ["all0s"L, CommOnlineDiagnostics.WordsInPacket[all0s]],      ["all1s"L, CommOnlineDiagnostics.WordsInPacket[all1s]],      ["incrWords"L, CommOnlineDiagnostics.WordsInPacket[incrWords]],      ["allConstant"L, CommOnlineDiagnostics.WordsInPacket[allConstant]],      ["dontCare"L, CommOnlineDiagnostics.WordsInPacket[dontCare]]];    lineType: ARRAY[0..3) OF Enumerated ¬ [      ["bitSynchronous"L, RS232C.LineType[bitSynchronous]],      ["byteSynchronous"L, RS232C.LineType[byteSynchronous]],      ["asynchronous"L, RS232C.LineType[asynchronous]]];    items ¬ AllocateItemDescriptor[nItems];    items[j¬0] ¬ StringItem[      tag: "host"L, place: [42, line0], inHeap: TRUE, string: @data.hostString];    items[j¬j+1] ¬ TagOnlyItem[      tag: "RS232CTest"L, place: [12, line1], readOnly: TRUE, drawBox: TRUE];    items[j¬j+1] ¬ TagOnlyItem[      tag: "EchoTest"L, drawBox: TRUE, place: [360, line1]];    items[j¬j+1] ¬ TagOnlyItem[      tag: "EtherStats"L, place: [624, line1], drawBox: TRUE];    items[j¬j+1] ¬ TagOnlyItem[      tag: "DialupTest"L, place: [834, line1], drawBox: TRUE];    items[j¬j+1] ¬ CommandItem[      tag: "StartRS232C"L, place: [12, line2], proc: StartRS232C];    items[j¬j+1] ¬ CommandItem[      tag: "StopRS232C"L, place: [96, line2], proc: StopRS232C];    items[j¬j+1] ¬ CommandItem[      tag: "StartEcho"L, place: [360, line2], proc: StartEcho];    items[j¬j+1] ¬ CommandItem[      tag: "StopEcho"L, place: [444, line2], proc: StopEcho];    items[j¬j+1] ¬ CommandItem[      tag: "Retrieve"L, place: [624, line2], proc: GetStats];    items[j¬j+1] ¬ CommandItem[      tag: "DialerTest"L, place: [834, line2], proc: DialerTest];    items[j¬j+1] ¬ NumberItem[      tag: "testCount"L, place: [12, line3], signed: FALSE,      value: @data.testCount];    items[j¬j+1] ¬ BooleanItem[      tag: "use defaults"L, place: [360, line3], switch: @data.useDefaults];    items[j¬j+1] ¬ NumberItem[      tag: "physicalOrder"L, place: [624, line3], signed: FALSE,      value: @data.physicalOrder];    items[j¬j+1] ¬ NumberItem[      tag: "rs232cLineNumber"L, place: [834, line3], signed: FALSE,      value: @data.rs232cLineNumber];    items[j¬j+1] ¬ LongNumberItem[      tag: "safetyTOInMsecs"L, place: [12, line4], signed: FALSE,      value: @data.rSafetyTOInMsecs];    items[j¬j+1] ¬ StringItem[      tag: "targetSystemElement"L, place: [360, line4],      inHeap: TRUE, string: @data.targetSystemElement];    items[j¬j+1] ¬ StringItem[      tag: "phoneNumber"L, place: [834, line4], inHeap: TRUE,      string: @data.phoneNumber];    items[j¬j+1] ¬ EnumeratedItem[      tag: "lineSpeed"L, place: [12, line5],      choices: DESCRIPTOR[lineSpeed], value: @data.lineSpeed];    items[j¬j+1] ¬ EnumeratedItem[      tag: "parity"L, place: [144, line5], choices: DESCRIPTOR[parity],      value: @data.parity];    items[j¬j+1] ¬ NumberItem[      tag: "totalCount"L, place: [360, line5], signed: FALSE,      value: @data.totalCount];    items[j¬j+1] ¬ EnumeratedItem[      tag: "pattern"L, place: [12, line6],      choices: DESCRIPTOR[pattern], value: @data.pattern];    items[j¬j+1] ¬ NumberItem[      tag: "constant"L, place: [144, line6], signed: FALSE,      value: @data.rConstant];    items[j¬j+1] ¬ LongNumberItem[      tag: "safetyTOInMsecs"L, place: [360, line6], signed: FALSE,      value: @data.eSafetyTOInMsecs];    items[j¬j+1] ¬ TagOnlyItem[      tag: "EchoCounters"L, place: [624, line6], drawBox: TRUE];    items[j¬j+1] ¬ NumberItem[      tag: "lineNumber"L, place: [12, line7], signed: FALSE,      value: @data.lineNumber];    items[j¬j+1] ¬ NumberItem[      tag: "minPacketSizeInBytes"L, place: [360, line7], signed: FALSE,      value: @data.minPacketSizeInBytes];    items[j¬j+1] ¬ CommandItem[      tag: "Retrieve"L, place: [624, line7], proc: GetECounters];    items[j¬j+1] ¬ NumberItem[      tag: "charLength"L, place: [12, line8], signed: FALSE,      value: @data.charLength];    items[j¬j+1] ¬ NumberItem[      tag: "maxPacketSizeInBytes"L, place: [360, line8], signed: FALSE,      value: @data.maxPacketSizeInBytes];    items[j¬j+1] ¬ EnumeratedItem[      tag: "lineType"L, place: [12, line9], choices: DESCRIPTOR[lineType],      value: @data.lineType];    items[j¬j+1] ¬ EnumeratedItem[      tag: "wordContents"L, place: [360, line9],      choices: DESCRIPTOR[wordContents], value: @data.wordContents];     items[j¬j+1] ¬ EnumeratedItem[      tag: "correspondent"L, place: [12, LineN[10]],      choices: DESCRIPTOR[correspondent], value: @data.correspondent];    items[j¬j+1] ¬ NumberItem[      tag: "constant"L, place: [360, LineN[10]], signed: FALSE,      value: @data.eConstant];    items[j¬j+1] ¬ NumberItem[      tag: "dataLength (high)"L, place: [12, LineN[11]], signed: FALSE,      value: @data.dataLenHi];    items[j¬j+1] ¬ NumberItem[      tag: "minMsecsBetweenPackets"L, place: [360, LineN[11]],      signed: FALSE, value: @data.minMsecsBetweenPackets];    items[j¬j+1] ¬ NumberItem[      tag: "dataLength (low)"L, place: [12, LineN[12]], signed: FALSE,      value: @data.dataLenLow];    items[j¬j+1] ¬ BooleanItem[      tag: "checkContents"L, place: [360, LineN[12]],      switch: @data.checkContents];    items[j¬j+1] ¬ EnumeratedItem[      tag: "setDiagnosticLine"L, place: [12, LineN[13]],      choices: DESCRIPTOR[setDiagnosticLine], value: @data.setDiagnosticLine];    items[j¬j+1] ¬ EnumeratedItem[      tag: "writeMsg"L, place: [192, LineN[13]], choices: DESCRIPTOR[writeMsg],      value: @data.writeMsg];    items[j¬j+1] ¬ EnumeratedItem[      tag: "eventReporter"L, place: [360, LineN[13]],      choices: DESCRIPTOR[eventReporter], value: @data.eventReporter];    items[j¬j+1] ¬ EnumeratedItem[      tag: "modemChange"L, place: [12, LineN[14]],      choices: DESCRIPTOR[modemChange], value: @data.modemChange];    items[j¬j+1] ¬ BooleanItem[      tag: "waitForResponse"L, place: [360, LineN[14]],      switch: @data.waitForResponse];    IF (j+1) # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;        RRetriever: PROC [line: CARDINAL] =    BEGIN  -- Retrieves intermediate RS232C results every 10 seconds.    ENABLE      BEGIN      ABORTED => GOTO exit;      CommOnlineDiagnostics.CommError =>        BEGIN        Put.Text[data.fileSW, "CommError; reason = "L];        Put.Line[data.fileSW, xlate[reason]];	GOTO exit;        END;      CommOnlineDiagnostics.RS232CDiagError =>        BEGIN	Put.Text[data.fileSW, "RS232CDiagError; reason = "L];	Put.Line[data.fileSW, SELECT reason FROM          aborted => "aborted"L,	  noHardware => "noHardware"L,	  noSuchLine => "noSuchLine"L,	  channelInUse => "channelInUse"L,	  unimplementedFeature => "unimplementedFeature"L,	  invalidParameter => "invalidParameter"L,	  invalidHandle => "invalidHandle"L,	  ENDCASE => "???"L];	GOTO exit;	END;      END;  -- catch series.    c: CommOnlineDiagnostics.CountType;    elapsed: LONG CARDINAL;    e: RS232CEntryPtr ¬ GetRS232CHandle[line: line, remove: FALSE];    Process.SetPriority[Process.priorityNormal];    DO      Process.Pause[Process.SecondsToTicks[10]];      c ¬ CommOnlineDiagnostics.GetRS232CResults[dH: e.handle, stopIt: FALSE,         host: host];      Put.Line[data.fileSW, ""];      Put.Text[data.fileSW, "*** line = "L];      Put.Decimal[data.fileSW, line];      Put.Text[data.fileSW, ", frames per second = "L];      elapsed ¬        System.PulsesToMicroseconds[System.GetClockPulses[]] -	System.PulsesToMicroseconds[e.time];      elapsed ¬ elapsed/10000;      Put.LongDecimal[data.fileSW, elapsed];      e.time ¬ System.GetClockPulses[];      e.frames ¬ c.sendOk;      DiagTestInternal.PrintRS232CTotals[c];      Put.Line[data.fileSW, ""];    ENDLOOP;    EXITS exit => NULL;    END;  -- RRetriever      ERetriever: PROC =    BEGIN  -- Retrieves intermediate echo results every 10 seconds.    h: CommOnlineDiagnostics.Histogram ¬ NIL;    BEGIN ENABLE       BEGIN      ABORTED => GOTO exit;      CommOnlineDiagnostics.CommError =>        BEGIN        Put.Text[data.fileSW, "CommError; reason = "L];        Put.Line[data.fileSW, xlate[reason]];	GOTO exit;        END;      CommOnlineDiagnostics.EtherDiagError =>        BEGIN	Put.Text[data.fileSW, "EtherDiagError; reason = "L];        Put.Line[data.fileSW, SELECT reason FROM          echoUserNotThere => "echoUserNotThere"L,	  noMoreNets => "noMoreNets"L,	  invalidHandle => "invalidHandle"L,	  ENDCASE => "???"L];	GOTO exit;	END;      END;  -- catch series.        t: CommOnlineDiagnostics.EchoResults;    Process.SetPriority[Process.priorityNormal];    DO      Process.Pause[Process.SecondsToTicks[10]];      [t, h] ¬ CommOnlineDiagnostics.GetEchoResults[eH, FALSE, host];      DiagTestInternal.PrintEchoTotals[t, h];      Put.Line[data.fileSW, ""];    ENDLOOP;    EXITS exit =>      BEGIN      IF h # NIL THEN        CommOnlineDiagnostics.FreeHistogram[h];	h ¬ NIL;      END;    END;  -- enabled clause    END;  -- ERetriever         TranslateHost: PROC [s: LONG STRING]    RETURNS [h: System.NetworkAddress, success: BOOLEAN ¬ TRUE] =    BEGIN    h ¬ AddressTranslation.StringToNetworkAddress[s !      AddressTranslation.Error =>        BEGIN	Put.Line[data.fileSW, "AddressTranslation problem"L];	GOTO exit;	END].addr;    EXITS exit => success ¬ FALSE;    END;  -- TranslateHost  -- Mainline code  Init[];  END...    
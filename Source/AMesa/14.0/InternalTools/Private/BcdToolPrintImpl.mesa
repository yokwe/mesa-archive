-- Copyright (C) 1980, 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- BcdToolPrintImpl.mesa, Last edited by -- Lewis,	 3-Dec-80 17:53:26-- Bruce,	21-Sep-81 10:37:16-- Haynes,	29-Nov-82 20:28:20DIRECTORY  Ascii USING [CR, DEL, ESC, FF, LF, NUL, SP, TAB],  BcdDefs USING [    Link, Namee, NameRecord, NTIndex, NTRecord, TYPNull, VersionStamp],  BcdToolCommands USING [cancelAction],  BcdToolPrint USING [],  BcdToolSourceBcd USING [bcdBases, bcdLimits, SubStringForName],  BcdToolWindows USING [fileSW, main, msgSW],  Format USING [NumberFormat],  Inline USING [LongNumber],  MsgSW USING [Clear, Post],  Put USING [Char],  String USING [AppendLongNumber, AppendNumber, SubString, SubStringDescriptor],  Time USING [Append, Unpack],  UserInput USING [UserAbort],  Window USING [GetBox],  WindowFont USING [CharWidth];BcdToolPrintImpl: PROGRAM     IMPORTS       BcdToolCommands, BcdToolSourceBcd, BcdToolWindows, MsgSW, Put,      String, Time, UserInput, Window, WindowFont     EXPORTS BcdToolPrint =  BEGIN OPEN BcdToolPrint;  charsOnLine: CARDINAL ¬ 0;  SPWidth: CARDINAL = WindowFont.CharWidth[Ascii.SP];  MaxCharsOnLine: CARDINAL = (BcdToolWindows.fileSW.GetBox[].dims.w / SPWidth) - 4;  Complaint: PUBLIC PROC [msg: LONG STRING, clear: BOOLEAN ¬ TRUE] =    BEGIN    IF BcdToolWindows.msgSW = NIL THEN RETURN;    IF clear THEN MsgSW.Clear[BcdToolWindows.msgSW];    MsgSW.Post[      sw: BcdToolWindows.msgSW,       string: msg, prefix: FALSE, endOfMsg: FALSE];    END;  Char: PUBLIC PROCEDURE [c: CHARACTER] =    BEGIN    IF UserInput.UserAbort[BcdToolWindows.main] THEN       ERROR BcdToolCommands.cancelAction[endLine: TRUE];    Put.Char[BcdToolWindows.fileSW, c];    charsOnLine ¬ SELECT c FROM      Ascii.TAB  => ((charsOnLine+8)/8)*8,      Ascii.CR   => 0,      ENDCASE    => charsOnLine + 1;    END;  AsciiChar: PUBLIC PROC [c: [0..128)] =    BEGIN    SELECT LOOPHOLE[c, CHARACTER] FROM      Ascii.CR  => Text["CR"L];      Ascii.DEL => Text["DEL"L];      Ascii.ESC => Text["ESC"L];      Ascii.FF  => Text["FF"L];      Ascii.LF  => Text["LF"L];      Ascii.SP  => Text["SP"L];      Ascii.TAB => Text["TAB"L];      Ascii.NUL => Text["NULL"L];      < 40C     => {Text["'­"L];  Char['@+c]};      ENDCASE   => {Char[''];  Char[LOOPHOLE[c]]};    END;  Text: PUBLIC PROC [s: LONG STRING] =    {FOR i: CARDINAL IN [0..s.length) DO Char[s[i]] ENDLOOP};  SubString: PUBLIC PROC [ss: String.SubString] =    BEGIN    FOR i: CARDINAL IN [ss.offset .. ss.offset+ss.length) DO      Char[ss.base[i]];      ENDLOOP;    END;  Cr: PUBLIC PROC = {Char[Ascii.CR]};  Sp: PUBLIC PROC = {Char[Ascii.SP]};  Decimal: PUBLIC PROC [i: INTEGER] =    BEGIN    Number[      num: i,       format: [base: 10, unsigned: FALSE, zerofill: FALSE, columns: 1]];    END;  Cardinal: PUBLIC PROC [i: CARDINAL] =    BEGIN    Number[      num: i,        format: [base: 10, unsigned: FALSE, zerofill: TRUE, columns: 1]];    END;      LongCardinal: PUBLIC PROC [i: LONG CARDINAL] =    BEGIN    LongNumber[      num: i,        format: [base: 10, unsigned: FALSE, zerofill: TRUE, columns: 1]];    END;  Octal: PUBLIC PROC [i: CARDINAL] =    BEGIN    Number[      num: i,         format: [base: 8, unsigned: FALSE, zerofill: TRUE, columns: 1]];    IF i > 7 THEN Char['B];    END;  Number: PUBLIC PROC [num: UNSPECIFIED, format: Format.NumberFormat] =    BEGIN    i: CARDINAL;    neg: BOOLEAN ¬ FALSE;    fill: CHARACTER ¬ (IF format.zerofill THEN '0 ELSE ' );    numString: STRING ¬ [10];    IF INTEGER[num] < 0 AND ~format.unsigned THEN      {num ¬ -INTEGER[num];  neg ¬ TRUE};    String.AppendNumber[numString, num, format.base];    i ¬ numString.length;    IF neg THEN      BEGIN      i ¬ i + 1;      IF fill = '0 THEN {Char['-];  neg ¬ FALSE};      END;    THROUGH (i..format.columns] DO Char[fill] ENDLOOP;    IF neg THEN Char['-];    Text[numString];    END;  LongNumber: PUBLIC PROC [      num: LONG UNSPECIFIED, format: Format.NumberFormat] =    BEGIN    n: Inline.LongNumber ¬ LOOPHOLE[num];    i: CARDINAL;    neg: BOOLEAN ¬ FALSE;    fill: CHARACTER ¬ (IF format.zerofill THEN '0 ELSE ' );    numString: STRING ¬ [20];    IF n.li < 0 AND ~format.unsigned THEN {n.li ¬ -n.li;  neg ¬ TRUE};    String.AppendLongNumber[numString, n.lc, format.base];    i ¬ numString.length;    IF neg THEN      BEGIN      i ¬ i + 1;      IF fill = '0 THEN {Char['-];  neg ¬ FALSE};      END;    THROUGH (i..format.columns] DO Char[fill] ENDLOOP;    IF neg THEN Char['-];    Text[numString];    END;  Index: PUBLIC PROC [index, nullIndex: UNSPECIFIED] =    BEGIN    Char['[];    IF index = nullIndex THEN Text["Null"L] ELSE Cardinal[index];    Char[']];    END;  Date: PUBLIC PROC [t: LONG CARDINAL] =    BEGIN    s: STRING ¬ [20];    Time.Append[s, Time.Unpack[LOOPHOLE[t]]];  Text[s];    END;  Machine: PUBLIC PROC [stamp: BcdDefs.VersionStamp] =    BEGIN    octal: Format.NumberFormat = [      base: 8, unsigned: FALSE, zerofill: FALSE, columns: 1];    Number[stamp.net, octal];  Char['#];    Number[stamp.host, octal];  Char['#];    END;  Name: PUBLIC PROC [name: BcdDefs.NameRecord] =    BEGIN    ssd: String.SubStringDescriptor;    BcdToolSourceBcd.SubStringForName[ss: @ssd, name: name];    IF ssd.length > 40 THEN ssd.length ¬ 40;    FOR i: CARDINAL IN [ssd.offset .. ssd.offset+ssd.length) DO      Char[ssd.base[i]];      ENDLOOP;    END;  InstanceNameForNamee: PUBLIC PROC [namee: BcdDefs.Namee] =    BEGIN    nti: BcdDefs.NTIndex ¬ FIRST[BcdDefs.NTIndex];    UNTIL nti = BcdToolSourceBcd.bcdLimits.nt DO      IF BcdToolSourceBcd.bcdBases.ntb[nti].item = namee THEN         {Name[BcdToolSourceBcd.bcdBases.ntb[nti].name];  EXIT};      nti ¬ nti + SIZE[BcdDefs.NTRecord];      ENDLOOP;    END;  Version: PUBLIC PROC [version: BcdDefs.VersionStamp] =    BEGIN    Char['(];    IF version.time = 0 THEN Text["Null Version"L]    ELSE {Date[version.time];  Char[' ];  Machine[version]};    Char[')];    END;  ControlLink: PUBLIC PROC [link: BcdDefs.Link] =    BEGIN    WITH l: link SELECT FROM       procedure =>  	BEGIN	Text["procedure["L];          Decimal[l.gfi];  Char[',];  Decimal[l.ep]; Char[']];	END;      signal =>  	BEGIN	Text["signal["L];          Decimal[l.gfi];  Char[',];  Decimal[l.index]; Char[']];	END;      type =>  	BEGIN	Text["type"L];  	Index[index: l.typeID, nullIndex: BcdDefs.TYPNull];	END;      variable =>  	BEGIN	Text["variable["L];          Decimal[l.gfi]; Char[',];  Decimal[l.offset]; Char[']];	END;      ENDCASE;    END;  VariousRepresentations: PUBLIC PROC [value: UNSPECIFIED] =    BEGIN    r: RECORD [       SELECT OVERLAID * FROM        int     => [i: INTEGER],        card    => [c: CARDINAL],        bytes   => [b1, b2: [0..256)],        nibbles => [n1, n2, n3, n4: [0..16)],        ENDCASE]  = value;    AnotherVal: PROCEDURE [length: CARDINAL] =      BEGIN      Text[" ="L];      IF MakeRoom[chars: length+1, indent: 2] THEN Sp[];      END;    BEGIN  OPEN r;    Number[c, [base: 8, zerofill: FALSE, unsigned: TRUE, columns: 0]];    Text["B = "L];    Number[c, [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];    IF i < 0 THEN      BEGIN      AnotherVal[1 + Log10[-i]];      Number[c, [base: 10, zerofill: FALSE, unsigned: FALSE, columns: 0]];      END;    IF b1 # 0 THEN  -- print as two bytes      BEGIN      AnotherVal[Log10[b1] + Log10[b2] + 2];      Number[b1, [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];      Text[",,"L];      Number[b2, [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];      IF b1 > 15 OR b2 > 15 THEN	BEGIN        nChars: CARDINAL ¬ Log8[b1] + Log8[b2] + 2;        IF b1 > 7 THEN nChars ¬ nChars+1;        IF b2 > 7 THEN nChars ¬ nChars+1;	AnotherVal[nChars];	Number[b1, [base: 8, zerofill: FALSE, unsigned: TRUE, columns: 0]];	IF b1 > 7 THEN Char['B];	Text[",,"L];	Number[b2, [base: 8, zerofill: FALSE, unsigned: TRUE, columns: 0]];	IF b2 > 7 THEN Char['B];	END;      IF b1 < 128 AND b2 < 128 THEN        BEGIN	AnotherVal[LengthAsChar[b1] + LengthAsChar[b2] + 2];	AsciiChar[b1];  Text[",,"L];  AsciiChar[b2];	END;      END    ELSE IF b2 IN [1..127] THEN  -- print as one byte       {AnotherVal[LengthAsChar[b2]];  AsciiChar[b2]};    IF n1 # 0 OR n3 # 0 THEN  -- print as nibbles      BEGIN      nChars: CARDINAL ¬ Log10[n4];      IF b1 # 0 THEN        BEGIN        IF n1 # 0 THEN nChars ¬ nChars + Log10[n1] + 1;        nChars ¬ nChars + Log10[n2] + 2;        END;      IF n3 # 0 THEN nChars ¬ nChars + Log10[n3] + 1;      AnotherVal[nChars];      IF b1 # 0 THEN        BEGIN        IF n1 # 0 THEN	  BEGIN	  Number[n1, [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];	  Char[':];	  END;        Number[n2, [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];        Text[",,"L];        END;      IF n3 # 0 THEN	BEGIN	Number[n3, [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];	Char[':];	END;      Number[n4, [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];      END;    END;    END;  LengthAsChar: PROC [c: [0..128)] RETURNS [length: CARDINAL] =    BEGIN    SELECT LOOPHOLE [c, CHARACTER] FROM      Ascii.CR  => RETURN[2];      Ascii.DEL => RETURN[3];      Ascii.ESC => RETURN[3];      Ascii.FF  => RETURN[2];      Ascii.LF  => RETURN[2];      Ascii.SP  => RETURN[2];      Ascii.TAB => RETURN[3];      < 40C     => RETURN[3];      ENDCASE   => RETURN[2];    END;  NextIndex: PUBLIC PROC [      s: LONG STRING, index, nullIndex: UNSPECIFIED, indent: CARDINAL ¬ 2] =    BEGIN    extra: CARDINAL ¬ IF index = nullIndex THEN 4 ELSE Log10[index];    Next[s, extra+2, indent];    Text[": "L];    Index[index, nullIndex];    END;  NextCardinal: PUBLIC PROC [s: LONG STRING, num: CARDINAL, indent: CARDINAL ¬ 2] =    BEGIN    extra: CARDINAL ¬ Log10[num];    Next[s, extra+2, indent];    Text[": "L];    Cardinal[num];    END;  NextOctal: PUBLIC PROC [s: LONG STRING, num: CARDINAL, indent: CARDINAL ¬ 2] =    BEGIN    extra: CARDINAL ¬ Log8[num];    IF num > 7 THEN extra ¬ extra+1;    Next[s, extra+2, indent];    Text[": "L];    Octal[num];    END;  NextLong: PUBLIC PROC [s: LONG STRING, num: LONG INTEGER, indent: CARDINAL ¬ 2] =    BEGIN    neg: BOOLEAN ¬ num < 0;    extra: CARDINAL;    extra ¬ IF neg THEN LongLog10[-num]+1 ELSE LongLog10[num];    Next[s, extra+2, indent];    Text[": "L];    LongNumber[      num: num,      format: [base: 10, unsigned: FALSE, zerofill: FALSE, columns: 0]];    END;  Next: PUBLIC PROC [s: LONG STRING, extra: CARDINAL ¬ 0, indent: CARDINAL ¬ 2] =    BEGIN    Char[',];    IF MakeRoom[s.length+1+extra, indent] THEN Sp[];    Text[s];    END;  MakeRoom: PROC [chars, indent: CARDINAL] RETURNS [wasRoom: BOOLEAN] =    BEGIN    IF (chars + charsOnLine) <= MaxCharsOnLine THEN RETURN[TRUE]    ELSE      BEGIN      Cr[];      THROUGH [0..indent/8) DO Char[Ascii.TAB] ENDLOOP;      THROUGH [0..indent MOD 8) DO Sp[] ENDLOOP;      RETURN[FALSE];      END;    END;  Log10: PUBLIC PROC [num: CARDINAL] RETURNS [CARDINAL] =    BEGIN    IF num < 1000 THEN      IF num < 10 THEN RETURN[1]      ELSE         IF num >= 100 THEN RETURN[3]        ELSE RETURN[2]    ELSE      IF num >= 10000 THEN RETURN[5]      ELSE RETURN[4];    END;    LongLog10: PUBLIC PROC [num: LONG CARDINAL] RETURNS [CARDINAL] =    BEGIN    power: ARRAY [1..10] OF LONG CARDINAL =       [0, 1D1, 1D2, 1D3, 1D4, 1D5, 1D6, 1D7, 1D8, 1D9];    u, l, i: CARDINAL;    l ¬ 1; u ¬ 11;    UNTIL u < l DO      i ¬ (l+u)/2;      SELECT power[i] FROM        = num => RETURN [i];        > num => u ¬ i-1;        ENDCASE => l ¬ i+1;      ENDLOOP;    RETURN[u];  -- see Knuth, 6.2.1 Exercise 1.    END;    Log8: PUBLIC PROC [num: CARDINAL] RETURNS [CARDINAL] =    BEGIN    IF num < 1000B THEN      IF num < 10B THEN RETURN[1]      ELSE         IF num >= 100B THEN RETURN[3]        ELSE RETURN[2]    ELSE      IF num >= 100000B THEN RETURN[6]      ELSE         IF num >= 10000B THEN RETURN[5]        ELSE RETURN[4];    END;    LongLog8: PUBLIC PROC [num: LONG CARDINAL] RETURNS [CARDINAL] =    BEGIN    power: ARRAY [1..11] OF LONG CARDINAL =       [0, 1B1, 1B2, 1B3, 1B4, 1B5, 1B6, 1B7,        1B8, 1B9, 1B10];    u, l, i: CARDINAL;    l ¬ 1; u ¬ 11;    UNTIL u < l DO      i ¬ (l+u)/2;      SELECT power[i] FROM        = num => RETURN [i];        > num => u ¬ i-1;        ENDCASE => l ¬ i+1;      ENDLOOP;    RETURN[u];    END;  END.  
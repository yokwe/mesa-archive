-- Copyright (C) 1981, 1982, 1984  by Xerox Corporation. All rights reserved. -- CGenDebugCommands.mesa --   Edited by Bruce, 14-Oct-81 11:06:09--   Edited by Sweet, 21-May-84  9:39:48--   Edited by Haynes, 29-Nov-82 20:27:52DIRECTORY  Ascii USING [CR, SP, TAB],  CGenDebugCommandDefs USING [ParamIndex],  CGenDebugDefs USING [    CCCur, CCFirst, GFrameSheet, GoFwd, PutAsCC,     PutAsComponent, PutAsFopcode, PutAsLabelInfoIndex,     PutAsStack, PutAsVar, PutCurrentBody, PutCurrentExpr,     PutCurrentSource, PutCurrentStmt, PutLabelState, PutNextCC, PutPrevCC,     PutRecentCC, PutStackDown, PutStackState, PutStackUp, PutTempState,     StackTop],  DebugTab,  FormSW USING [ProcType],  Inline USING [LongNumber],  MopOps USING [PutMopcode],  MsgSW USING [Clear, Post],  Put USING [Char, Text],  RESOut USING [PCr, PDecimal, POctal, PString, WindowsHandle],  Runtime USING [GetTableBase],  Selection USING [LongNumber],  STDebugDefs USING [    NextSe, PutAsBti, PutAsCti, PutAsHti, PutAsMdi, PutAsSei, PutAsTree,    PutAsVariousRep],  String USING [InvalidNumber],  UserInput USING [UserAbort],  Window USING [GetBox],  WindowFont USING [CharWidth];CGenDebugCommands: PROGRAM   IMPORTS     CGenDebugDefs, DebugTab, MopOps, MsgSW, Put,    RESOut, Runtime, Selection, STDebugDefs, String, UserInput, Window, WindowFont  EXPORTS CGenDebugDefs, RESOut =  BEGIN OPEN CGenDebugDefs, STDebugDefs;  handle: PUBLIC RESOut.WindowsHandle ¬ NIL;  cancelAction: PUBLIC ERROR [endLine: BOOLEAN ¬ FALSE] = CODE;    table: LONG POINTER = Runtime.GetTableBase[LOOPHOLE[DebugTab]];  ParamNotify: PUBLIC FormSW.ProcType =    BEGIN OPEN CGenDebugCommandDefs;    ENABLE cancelAction =>        BEGIN      IF endLine THEN Put.Text[handle.fileSW, " XXX"L];      GO TO done;      END;    Complain[""L];    SELECT LOOPHOLE[index, ParamIndex] FROM      tree => PutAsTree[table, GetSelectionValue[]];      asCC => PutAsCC[GetSelectionValue[]];      var => 	BEGIN	RESOut.PCr[];	PutAsVar[GetSelectionValue[]];	END;      vcomp => 	BEGIN OPEN RESOut;	val: UNSPECIFIED ¬ GetSelectionValue[];	PCr[];	POctal[val]; PString["­ = "L];	PutAsComponent[val];	END;      first => PutAsCC[CCFirst[]];      cur => PutAsCC[CCCur[]];      next => PutNextCC[];      prev => PutPrevCC[];      fwd => GoFwd[GetSelectionValue[]];      rcnt => PutRecentCC[GetSelectionValue[]];      temp => PutTempState[];      allStack => PutStackState[];      stack => PutAsStack[GetSelectionValue[]];      tos => PutAsStack[StackTop[]];      down => PutStackDown[];      up => PutStackUp[];      lbl => PutLabelState[];      lii => PutAsLabelInfoIndex[GetSelectionValue[]];      sei => PutAsSei[table, GetSelectionValue[]];      nextse => NextSe[table];      hti => PutAsHti[GetSelectionValue[]];      cti => PutAsCti[GetSelectionValue[]];      bti => PutAsBti[GetSelectionValue[]];      mdi => PutAsMdi[GetSelectionValue[]];      mop => PutAsMopcode[GetSelectionValue[]];      fop => PutAsFopcode[GetSelectionValue[]];      rep => PutAsVariousRep[GetSelectionValue[]];      body => PutCurrentBody[];      stmt => PutCurrentStmt[];      expr => PutCurrentExpr[];      gFrames => GFrameSheet[];      source => PutCurrentSource[];      ENDCASE;    EXITS      done => NULL;    END;      PutAsMopcode: PUBLIC PROCEDURE [n: CARDINAL] =    BEGIN OPEN RESOut;    PCr[];    PDecimal[n];    PString[" = z"L];    MopOps.PutMopcode[PString, n];    RETURN    END;  GetSelectionValue: PUBLIC PROCEDURE RETURNS [val: UNSPECIFIED] =    BEGIN    num: Inline.LongNumber;    num.lc ¬ GetLongSelectionValue[];    SELECT num.highbits FROM      0, 177777B => NULL;      ENDCASE => {Complain["number too big"L]; ERROR cancelAction};    RETURN[num.lowbits];    END;  GetLongSelectionValue: PUBLIC PROCEDURE RETURNS [val: LONG UNSPECIFIED] =    BEGIN    val ¬ Selection.LongNumber[radix: 10 !	String.InvalidNumber => GO TO noNumber];    RETURN;    EXITS      noNumber =>	BEGIN	Complain["Select a number first"L];	ERROR cancelAction;	END;    END;  Complain: PUBLIC PROCEDURE [msg: LONG STRING, clear: BOOLEAN ¬ TRUE] =    BEGIN    IF handle = NIL OR handle.msgSW = NIL THEN RETURN;    IF clear THEN MsgSW.Clear[handle.msgSW];    MsgSW.Post[sw: handle.msgSW, string: msg, prefix: FALSE, endOfMsg: FALSE];    END;-- log writing procedures  charsOnLine: CARDINAL ¬ 0;  PChar: PUBLIC PROCEDURE [c: CHARACTER] =    BEGIN    IF UserInput.UserAbort[handle.fileSW] THEN ERROR cancelAction[TRUE];    Put.Char[handle.fileSW, c];    charsOnLine ¬ SELECT c FROM      Ascii.TAB  => ((charsOnLine+8)/8)*8,      Ascii.CR => 0,      ENDCASE => charsOnLine + 1;    END;  MakeRoom: PUBLIC PROCEDURE [chars, indent: CARDINAL]       RETURNS [was: BOOLEAN]=    BEGIN    cw: CARDINAL = WindowFont.CharWidth['w];    charsPerLine: CARDINAL = handle.fileSW.GetBox[].dims.w/cw-4;    IF charsOnLine + chars <= charsPerLine THEN RETURN [TRUE];    PChar[Ascii.CR];    THROUGH [0..indent/8) DO PChar[Ascii.TAB]; ENDLOOP;    THROUGH [0..indent MOD 8) DO PChar[Ascii.SP]; ENDLOOP;    RETURN[FALSE];    END;  END.
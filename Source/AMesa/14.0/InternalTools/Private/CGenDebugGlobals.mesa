-- Copyright (C) 1982, 1983, 1987  by Xerox Corporation. All rights reserved. -- CGenDebugGlobals.mesa  -- Edited by Bruce, September 22, 1980  10:55 AM-- Edited by Sweet,  1-Mar-83 16:10:05-- Edited by Haynes,  8-Dec-82 19:18:33-- Edited by JBD, 14-Jan-87 15:50:41DIRECTORY  AllocOps USING [BasesHandle, Handle, SizesHandle],  CGenDebugDefs USING [ccInfo, cd, handle, UpdateConstDest],  Code USING [    codeptr, codeStart, curctxlvl, framesz, stking, tempcontext, tempstart],  CodeDefs USING [    CCIndex, CCInfoType, codeType, ConsDestination, LabelInfoIndex, StackIndex,     StackItem, StackNull],  ComData USING [bodyIndex, sourceFile, table, textIndex],  Constructor USING [cd],  DebugUsefulDefs,  DebugUsefulDefsExtras USING[GFlong, Frame],  Expression USING [recentExp],  Event,  EventTypes,  Final USING [ccInfo],  FormSW,  Flow USING [labelStack],  Heap USING [systemZone],  OpCodeParams USING [GlobalBase, GlobalLoadSlots, LocalBase, LocalLoadSlots],  RESOut USING [    cancelAction, Complain, PChar, PCr, PNext, PNextUnsigned, POctal, PString,     PUnsigned],  Selection,  StackImpl USING [stkHead, stkPtr],  Statement USING [recentStmt],  STDebugDefs USING [],  String,  SymbolOps USING [ToBitAddr, ToCard],  Symbols USING [    BitAddress, ContextLevel, CTXRecord, ctxType, ISEIndex, ISENull, lG, lZ,     SERecord, seType],  Supervisor,  Table USING [Base, chunkType, Selector],  Temp USING [heapList, pendTempList],  Tool,  Window,  WindowFont;CGenDebugGlobals: PROGRAM   IMPORTS CGenDebugDefs, DebugUsefulDefs, DebugUsefulDefsExtras, FormSW,     Heap, RESOut, Selection, String, SymbolOps, Tool, Window, WindowFont  EXPORTS CGenDebugDefs, STDebugDefs   SHARES Final, Flow, StackImpl, Temp =  BEGIN OPEN CodeDefs, DebugUsefulDefs, RESOut, CGenDebugDefs;  wordlength: CARDINAL = 16;  basesValid: BOOLEAN ¬ FALSE;  constructor: LONG POINTER TO FRAME [Constructor] ¬ NIL;  CPtr: LONG POINTER TO FRAME [Code] ¬ NIL;  expression: LONG POINTER TO FRAME [Expression] ¬ NIL;  final: LONG POINTER TO FRAME [Final]  ¬ NIL;  flow: LONG POINTER TO FRAME [Flow] ¬ NIL;  MPtr: LONG POINTER TO FRAME [ComData] ¬ NIL;  stack: LONG POINTER TO FRAME [StackImpl] ¬ NIL;  statement: LONG POINTER TO FRAME [Statement] ¬ NIL;  temp: LONG POINTER TO FRAME [Temp] ¬ NIL;    CheckFrame: PROC[    atP: LONG POINTER TO LONG POINTER, mod, config: STRING] =    BEGIN OPEN DebugUsefulDefs;    cfig: STRING ¬ [50];    IF atP­ # NIL THEN RETURN;    atP­ ¬ DebugUsefulDefsExtras.GFlong[DebugUsefulDefsExtras.Frame[mod !      NotFound => GO TO notFound;      MultipleFrames -- [list: FrameList]--  => {        FOR i: CARDINAL IN [0..list.LENGTH) DO          cfig.length ¬ 0;          ConfigForFrame[list[i], cfig];	  IF String.EqualStrings[cfig, config] THEN {atP­ ¬ list[i]; GO TO done};	  ENDLOOP;        GO TO notFound}]];    EXITS      notFound => {        RESOut.Complain["Base of "L];	RESOut.Complain[mod, FALSE];	RESOut.Complain[" unknown"L, FALSE];	ERROR cancelAction};      done => NULL;    END;  StackBottom: PUBLIC PROCEDURE RETURNS [StackIndex] =    BEGIN OPEN CodeDefs;    sHead: StackIndex;    sir: StackItem;    cb: Table.Base = TableBase[CodeDefs.codeType];    CheckFrame[@stack, "StackImpl"L, "P5"L];    sHead ¬ LongREAD[@stack.stkHead];    IF sHead = StackNull THEN RETURN [StackNull];    LongCopyREAD[to: @sir, from: @cb[sHead], nwords: SIZE[StackItem]];    RETURN [sir.uplink];    END;  StackState: PUBLIC PROCEDURE RETURNS [BOOLEAN] =    BEGIN    CheckFrame[@CPtr, "Code"L, "P5"L];    RETURN [LongREAD[@CPtr.stking]];    END;  StackTop: PUBLIC PROCEDURE RETURNS [StackIndex] =    BEGIN OPEN CodeDefs;    CheckFrame[@stack, "StackImpl"L, "P5"L];    RETURN [LongREAD[@stack.stkPtr]];    END;  PutTempState: PUBLIC PROCEDURE =    BEGIN OPEN Symbols;    seb: Table.Base = TableBase[seType];    ser: id SERecord;    name: STRING ¬ [20];    ShowList: PROCEDURE [sei: ISEIndex, heading: STRING] =      BEGIN      first: BOOLEAN ¬ TRUE;      IF sei = ISENull THEN RETURN;      PCr[]; PString["    "L];      PString[heading]; PString[": {"L];      WHILE sei # ISENull DO        LongCopyREAD[to: @ser, from: @seb[sei], nwords: SIZE[id SERecord]];	GetVarName[name, sei];	IF first THEN PString[name] ELSE PNext[name,,6];	first ¬ FALSE;	WITH ser SELECT FROM	  linked => sei ¬ link;	  ENDCASE => sei ¬ ISENull;	ENDLOOP;      PChar['}];      END;    CheckFrame[@temp, "Temp"L, "P5"L];    CheckFrame[@CPtr, "Code"L, "P5"L];    PCr[];    PString["Temp ctx: "L]; PUnsigned[LongREAD[@CPtr.tempcontext]];    PNextUnsigned["start"L, LongREAD[@CPtr.tempstart]];    PNextUnsigned["framesz"L, LongREAD[@CPtr.framesz]];    ShowList[LongREAD[@temp.pendTempList], "Pending"L];    ShowList[LongREAD[@temp.heapList], "Heap"L];    END;  GetVarName: PROCEDURE [s: STRING, sei: Symbols.ISEIndex] =    BEGIN OPEN Symbols;    ctxb: Table.Base = TableBase[ctxType];    seb: Table.Base = TableBase[seType];    ser: id SERecord;    ctr: CTXRecord;    addr: BitAddress;    LongCopyREAD[to: @ser, from: @seb[sei], nwords: SIZE [id SERecord]];    LongCopyREAD[to: @ctr, from: @ctxb[ser.idCtx], nwords: SIZE[CTXRecord]];    addr ¬ SymbolOps.ToBitAddr[ser.idValue];    s.length ¬ 0;    GetFrameName[s, addr.wd, ctr.level,	(SymbolOps.ToCard[ser.idInfo]+wordlength-1)/wordlength];    END;  GetFrameName: PUBLIC PROCEDURE [s: LONG STRING,      wd: CARDINAL, level: Symbols.ContextLevel, wSize: CARDINAL] =    BEGIN OPEN String, Symbols;    curlvl: ContextLevel = CurContext[];    levadj: STRING ¬ [10];    SELECT level FROM      lZ => AppendString[s, "Field "L];      lG => AppendChar[s, 'G];      curlvl => AppendChar[s, 'L];      ENDCASE =>	BEGIN	AppendChar[s, 'L];	AppendString[levadj," (up "L];	AppendDecimal[levadj, curlvl-level];	AppendChar[levadj,')];	END;    SELECT level FROM      lZ => NULL;      lG => IF wd IN OpCodeParams.GlobalLoadSlots THEN 	  wd ¬ wd - OpCodeParams.GlobalBase	ELSE AppendString[s, "B "L];       ENDCASE => IF wd IN OpCodeParams.LocalLoadSlots THEN 	  wd ¬ wd - OpCodeParams.LocalBase	ELSE AppendString[s, "B "L];     AppendDecimal[s, wd];    IF wSize > 1 THEN       BEGIN      AppendString[s, ".."L];      AppendDecimal[s, wd + wSize - 1];      END;    AppendString[s, levadj];    END;  TableBase: PUBLIC PROCEDURE [table: Table.Selector ¬ Table.chunkType]      RETURNS [b: Table.Base] =    BEGIN    h: AllocOps.Handle;    bs: AllocOps.BasesHandle;    CheckFrame[@MPtr, "ComData"L, "Compiler"L];    LongCopyREAD[to: @h, from: @MPtr.table, nwords: SIZE[AllocOps.Handle]];    LongCopyREAD[to: @bs, from: @h.base, nwords: SIZE[AllocOps.BasesHandle]];    LongCopyREAD[to: @b, from: @bs[table], nwords: SIZE[Table.Base]];    RETURN    END;  TableSize: PUBLIC PROCEDURE [table: Table.Selector ¬ Table.chunkType]      RETURNS [CARDINAL] =    BEGIN    h: AllocOps.Handle;    ts: AllocOps.SizesHandle;    CheckFrame[@MPtr, "ComData"L, "Compiler"L];    LongCopyREAD[to: @h, from: @MPtr.table, nwords: SIZE[AllocOps.Handle]];    LongCopyREAD[to: @ts, from: @h.top, nwords: SIZE[AllocOps.SizesHandle]];    RETURN [LongREAD[@ts[table]]];    END;      LockSymbols: PUBLIC PROC = {};  UnlockSymbols: PUBLIC PROC = {};  STRead: PUBLIC PROCEDURE [addr: LONG POINTER] RETURNS [UNSPECIFIED] =    BEGIN    RETURN [DebugUsefulDefs.LongREAD[addr]];    END;  STCopyRead: PUBLIC PROCEDURE [from: LONG POINTER, nwords: CARDINAL, to: LONG POINTER] =    BEGIN    DebugUsefulDefs.LongCopyREAD[from: from, nwords: nwords, to: to];    END;  CurContext: PUBLIC PROCEDURE RETURNS [Symbols.ContextLevel] =    BEGIN    CheckFrame[@CPtr, "Code"L, "P5"L];    RETURN [LongREAD[@CPtr.curctxlvl]];    END;  CCCur: PUBLIC PROCEDURE RETURNS [CodeDefs.CCIndex] =    BEGIN    CheckFrame[@CPtr, "Code"L, "P5"L];    RETURN [LongREAD[@CPtr.codeptr]];    END;  CCFirst: PUBLIC PROCEDURE RETURNS [CodeDefs.CCIndex] =    BEGIN    CheckFrame[@CPtr, "Code"L, "P5"L];    RETURN [LongREAD[@CPtr.codeStart]];    END;  LabelStack: PUBLIC PROCEDURE RETURNS [CodeDefs.LabelInfoIndex] =    BEGIN    CheckFrame[@flow, "Flow"L, "P5"L];    RETURN [LongREAD[@flow.labelStack]];    END;  PutCurrentBody: PUBLIC PROCEDURE =    BEGIN    CheckFrame[@MPtr, "ComData"L, "Compiler"L];    PCr[];    PString["Current body bti = "L];    PUnsigned[LongREAD[@MPtr.bodyIndex]];     END;  PutCurrentSource: PUBLIC PROCEDURE =    BEGIN    index: CARDINAL;    us: LONG STRING;    sn: LONG STRING ¬ NIL;    BEGIN    ENABLE UNWIND => IF sn # NIL THEN Heap.systemZone.FREE[@sn];    CheckFrame[@MPtr, "ComData"L, "Compiler"L];    LongCopyREAD[      to: @us, from: @MPtr.sourceFile, nwords: SIZE[LONG STRING]];    sn ¬ CopyUserString[us];    index ¬ LongREAD[@MPtr.textIndex];    PCr[];    PString["Current source: "L]; PString[sn];    PString[" ["L]; POctal[index]; PChar[']];    END;    Heap.systemZone.FREE[@sn];    END;  CopyUserString: PRIVATE PROCEDURE [us: LONG STRING] RETURNS [s: LONG STRING] =    BEGIN    sb: StringBody;    IF us = NIL THEN GO TO bad;    LongCopyREAD[to: @sb, from: us, nwords: SIZE[StringBody]];    IF sb.length > 60 THEN GO TO bad;    s ¬ String.MakeString[Heap.systemZone, sb.length];    LongCopyREAD[to: @s.text, from: @us.text, nwords: (sb.length+1)/2];    s.length ¬ sb.length;    EXITS      bad =>	BEGIN	RESOut.Complain["String too long"L];	ERROR cancelAction;	END;    END;  PutCurrentStmt: PUBLIC PROCEDURE =    BEGIN     CheckFrame[@statement, "Statement"L, "P5"L];    PCr[];    PString["Current stmt tree = "L];    PUnsigned[LongREAD[@statement.recentStmt]];     END;  PutCurrentExpr: PUBLIC PROCEDURE =    BEGIN     CheckFrame[@expression, "Expression"L, "P5"L];    PCr[];    PString["Current expr tree = "L];    PUnsigned[LongREAD[@expression.recentExp]];     END;  CopyGlobalData: PROCEDURE =    BEGIN    BEGIN    ENABLE cancelAction => GO TO forgetIt;    info: CodeDefs.CCInfoType ¬ generating;    CheckFrame[@final, "Final"L, "P5"L];    CheckFrame[@constructor, "Constructor"L, "P5"L];    info ¬ LongREAD[@final.ccInfo];    CGenDebugDefs.ccInfo ¬ IF info IN CodeDefs.CCInfoType THEN info      ELSE generating;    LongCopyREAD[      to: @CGenDebugDefs.cd,      from: @constructor.cd,      nwords: SIZE[CodeDefs.ConsDestination]];    UpdateConstDest[];    EXITS      forgetIt => NULL;    END;    END;  NotifyEvent: PUBLIC Supervisor.AgentProcedure =    BEGIN    IF event = EventTypes.newSession THEN {      constructor ¬ NIL; CPtr ¬ NIL; expression ¬ NIL;      final ¬ NIL; flow ¬ NIL; MPtr ¬ NIL; stack ¬ NIL;      statement ¬ NIL; temp¬ NIL};    SELECT event FROM      EventTypes.newSession, EventTypes.resumeSession => 	BEGIN	CopyGlobalData[ ! cancelAction => CONTINUE];	END;      ENDCASE;    END;          gFrameWindow, gfFormSW: Window.Handle ¬ NIL;  cw: CARDINAL;  ch: CARDINAL;  GFrameSheet: PUBLIC PROC =    BEGIN    place: Window.Place = Window.BitmapPlace[CGenDebugDefs.handle.fileSW];    cw ¬ WindowFont.CharWidth['w];    ch ¬ WindowFont.FontHeight[];    IF gFrameWindow = NIL THEN       gFrameWindow ¬ Tool.Create[        name: "Global frames"L, makeSWsProc: GFrameSW, initialState: active,        initialBox: [[place.x + cw, place.y + ch], [83*cw, 5*(ch + 3) + 4]]]    ELSE Complain["Frame window already exists."L];    END;  CloseGFrameSheet: FormSW.ProcType =    BEGIN    IF Selection.Convert[subwindow] = sw THEN Selection.Clear[];    gfFormSW ¬ NIL;    Tool.Destroy[gFrameWindow];    gFrameWindow ¬ NIL;    END;  GFrameSW: Tool.MakeSWsProc = {    gfFormSW ¬ Tool.MakeFormSW[window: window, formProc: MakeGFrames]};  ItemName: TYPE = {    close, CPtr, constructor, expression, final, flow, MPtr, stack,     statement, temp};      Col1: CARDINAL = 0;  Col2: CARDINAL = 24;  Col3: CARDINAL = 44;  Col4: CARDINAL = 65;  MakeGFrames: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    ngFrames: CARDINAL = LOOPHOLE[LAST[ItemName], CARDINAL]+1;    ia: LONG POINTER TO ARRAY ItemName OF ItemHandle;  ItemPlace: ARRAY ItemName OF Window.Place = [    close: [x: Col1*cw, y: line0],    CPtr: [x: Col2*cw, y: line0],    constructor: [x: Col3*cw, y: line0],    expression: [x: Col1*cw, y: line1],    final: [x: Col2*cw, y: line1],    flow: [x: Col3*cw, y: line1],    MPtr: [x: Col4*cw, y: line1],    stack: [x: Col2*cw, y: line2],    statement: [x: Col3*cw, y: line2],    temp: [x: Col4*cw, y: line2]];         items ¬ AllocateItemDescriptor[ngFrames];    ia ¬ LOOPHOLE[BASE[items]];        ia­ ¬ [      close: CommandItem[        tag: "close"L, proc: CloseGFrameSheet, place: ItemPlace[close]],        CPtr:  NumberItem[        tag: "Code"L, place: ItemPlace[CPtr], value: @CPtr,        radix: octal, signed: FALSE, boxWidth: 8*cw],      constructor: NumberItem[        tag: "Constructor"L, place: ItemPlace[constructor], value: @constructor,        radix: octal, signed: FALSE, boxWidth: 8*cw],      expression: NumberItem[        tag: "Expression"L, place: ItemPlace[expression], value: @expression,        radix: octal, signed: FALSE, boxWidth: 8*cw],      final: NumberItem[        tag: "Final"L, place: ItemPlace[final], value: @final,        radix: octal, signed: FALSE, boxWidth: 8*cw],      flow: NumberItem[        tag: "Flow"L, place: ItemPlace[flow], value: @flow,        radix: octal, signed: FALSE, boxWidth: 8*cw],      MPtr: NumberItem[        tag: "ComData"L, place: ItemPlace[MPtr], value: @MPtr,        radix: octal, signed: FALSE, boxWidth: 8*cw],      stack: NumberItem[        tag: "StackImpl"L, place: ItemPlace[stack], value: @stack,        radix: octal, signed: FALSE, boxWidth: 8*cw],      statement: NumberItem[        tag: "Statement"L, place: ItemPlace[statement], value: @statement,        radix: octal, signed: FALSE, boxWidth: 8*cw],      temp: NumberItem[        tag: "Temp"L, place: ItemPlace[temp], value: @temp,        radix: octal, signed: FALSE, boxWidth: 8*cw]];    RETURN[items, TRUE]    END;  CopyGlobalData[]; -- so it gets done when the tool is started up  END.
-- Copyright (C) 1981  by Xerox Corporation. All rights reserved. -- CGenDebugLabels.mesa  Edited by Sweet, 11-Sep-81 16:47:49DIRECTORY  CGenDebugDefs USING [LabelStack],  CodeDefs USING [codeType, LabelInfoIndex, LabelInfoNull, LabelInfoRecord],  DebugUsefulDefs USING [LongCopyREAD],  RESOut USING [    Log10, PChar, PCr, PDecimal, PNext, PNextNull, PNextUnsigned, PString,     PUnsigned],  STDebugDefs USING [PSTSubString, showLinks, SubStringForHash, TableBase],  String USING [AppendChar, AppendDecimal, AppendString, SubStringDescriptor],  Table USING [Base];CGenDebugLabels: PROGRAM   IMPORTS     STDebugDefs, CGenDebugDefs, DebugUsefulDefs, RESOut,    String  EXPORTS CGenDebugDefs =  BEGIN OPEN STDebugDefs, CodeDefs, CGenDebugDefs, RESOut;  PutAsLabelInfoIndex: PUBLIC PROCEDURE [lii: CodeDefs.LabelInfoIndex] =    BEGIN    lir: LabelInfoRecord;    cb: Table.Base ¬ TableBase[codeType];    DebugUsefulDefs.LongCopyREAD[      to: @lir,      from: @cb[lii],      nwords: SIZE[LabelInfoRecord]];    PCr[]; PString["cb["L];    PDecimal[LOOPHOLE[lii]];    PString["] = "L];    IF lir.free THEN      BEGIN      PString["FREE!"L];      RETURN      END;    PString["level: "L]; PUnsigned[lir.catchLevel];    WITH li: lir SELECT FROM      named =>        BEGIN        desc: String.SubStringDescriptor;	SubStringForHash[@desc, li.hti];        PNext["hti: "L, Log10[li.hti]+3+desc.length];	PUnsigned[li.hti]; PString[" ("L];	PSTSubString[@desc]; PChar[')];	PNextUnsigned["cci"L, li.cci];        END;      stmt =>        BEGIN	PNextUnsigned["RETRY"L, li.retry];	PNextUnsigned["CONT"L, li.continue];        END;      loop =>        BEGIN	PNextUnsigned["LOOP"L, li.loop];	PNextUnsigned["EXIT"L, li.exit];        END;      ENDCASE;    IF STDebugDefs.showLinks THEN PNextNull["thread"L, lir.thread, LabelInfoNull];    END;  PutLabelState: PUBLIC PROCEDURE =    BEGIN OPEN CodeDefs;    lii: LabelInfoIndex;    lir: LabelInfoRecord;    cb: Table.Base = STDebugDefs.TableBase[codeType];    desc: String.SubStringDescriptor;    extra: CARDINAL;    first: BOOLEAN ¬ TRUE;    name: STRING ¬ [30];    PCr[];    PString["labelStack: "L];    lii ¬ LabelStack[];    IF lii = LabelInfoNull THEN      BEGIN PString["empty"L]; RETURN END;    WHILE lii # LabelInfoNull DO      name.length ¬ 0; extra ¬ 0;      DebugUsefulDefs.LongCopyREAD[to: @lir, from: @cb[lii],	nwords: SIZE[LabelInfoRecord]];      BEGIN OPEN String;      AppendChar[name, '(]; AppendDecimal[name, LOOPHOLE[lii]];      AppendString[name, ") "L];      END;      WITH li: lir SELECT FROM	named => 	  BEGIN	  SubStringForHash[@desc, li.hti]; 	  extra ¬ desc.length + 2 + Log10[LOOPHOLE[li.hti]];	  END;	loop => extra ¬ 6 + Log10[LOOPHOLE[li.loop]];	stmt => extra ¬ 7 + Log10[LOOPHOLE[li.retry]];	ENDCASE;      IF first THEN	BEGIN PString[name]; first ¬ FALSE; END      ELSE PNext[name, extra];      WITH li: lir SELECT FROM	named => 	  BEGIN	  PSTSubString[@desc]; 	  PString[": "L];	  PUnsigned[LOOPHOLE[li.cci]];	  END;	loop => 	  BEGIN	  PString["LOOP: "L];	  PUnsigned[LOOPHOLE[li.loop]];	  PNextUnsigned["EXIT"L, li.exit];	  END;	stmt => 	  BEGIN	  PString["RETRY: "L];	  PUnsigned[LOOPHOLE[li.retry]];	  PNextUnsigned["CONT"L, li.continue];	  END;	ENDCASE;      lii ¬ lir.thread;      ENDLOOP;    END;  END.
-- Copyright (C) 1981, 1982, 1983, 1984, 1985, 1986 by Xerox Corporation. All rights reserved. -- BcdToolCommandsImpl.mesa -- Last edited by   -- Lewis on 22-Nov-81 15:46:05  -- Bruce on 21-Sep-81 10:34:24  -- Sweet on 22-Nov-81 15:02:24  -- Haynes on  8-Dec-82 19:12:38  -- Wagner on 11-Apr-85  9:55:46  -- JKF on  6-Mar-86 13:01:55    DIRECTORY  AtomVariants USING [IMPRecord],  BcdDefs USING [    ATIndex, ATNull, ATRecord, BCD, Link, CTIndex, CTNull, CTRecord, ENIndex,     EXPIndex, EXPNull,    EXPRecord, ENNull, ENRecord, FPIndex, FPNull, FPRecord, FTIndex,    FTNull, FTRecord, FTSelf, IMPIndex, IMPNull, IMPRecord, LFIndex, LFNull,    LinkFrag, MTIndex, MTNull, MTRecord, Namee, NameRecord, NTIndex, NTNull,    NTRecord, NullName, PackedString, SegClass, SGIndex, SGNull, SGRecord,    SpaceID, SPIndex, SPNull, SPRecord, TMIndex, TMNull,    TMRecord, TYPIndex, TYPNull, TYPRecord, VersionID],  BcdOps USING [ATHandle],  BcdToolCommands,  BcdToolPrint USING [  -- renamed in OPEN as "Print"    AsciiChar, Cardinal, Char, Complaint, ControlLink, Cr, Date, Decimal,    Index, InstanceNameForNamee, LongCardinal, Machine, Name, NextCardinal,    NextIndex, NextOctal, Octal, Sp, Text, VariousRepresentations, Version],  BcdToolSourceBcd USING [    bcdBases, bcdHeader, bcdLimits, IncompatibleVersion, IsLoaded, Load,    UnknownBcdFile, Unload],  BcdToolWindows USING [fileSW, formSW],  FormSW USING [DisplayItem, NotifyProcType],  MSegment USING [PagesForWords],  Put USING [Text],  Selection USING [Number],  String USING [AppendString, InvalidNumber],  Table USING [Base],  UserTerminal USING [BlinkDisplay];      BcdToolCommandsImpl: PROGRAM     IMPORTS       BcdToolPrint, BcdToolSourceBcd, BcdToolWindows, FormSW, MSegment, Put,       Selection, String, UserTerminal    EXPORTS BcdToolCommands =  BEGIN  OPEN Print: BcdToolPrint;  cancelAction: PUBLIC ERROR [endLine: BOOLEAN ¬ FALSE] = CODE; -- Parameter items (initialized by BcdToolWindowsImpl)  bcdFileName: PUBLIC LONG STRING;  configIndex, moduleIndex, importIndex, exportIndex, fileIndex,    segmentIndex, nameIndex, spaceIndex, framePkIndex, nmEntryIndex,    expVarIndex, typeIndex, typeMpIndex, linkFgIndex, atomIndex: PUBLIC CARDINAL;   printLinks: PUBLIC BOOLEAN;   -- TRUE if to print external links  readLoc, readWords: PUBLIC CARDINAL;  -- parameters for read command  readMode: PUBLIC BcdToolCommands.ReadMode;     -- local copies of BcdToolSourceBcd information  bcdHeader: LONG POINTER TO BcdDefs.BCD;      ctb, mtb, etb, itb, sgb, ftb, enb, spb, ntb, tyb, tmb, fpb, lfb, atb:  								Table.Base;  ssb: LONG POINTER TO BcdDefs.PackedString;      ctLimit: BcdDefs.CTIndex;  mtLimit: BcdDefs.MTIndex;  etLimit: BcdDefs.EXPIndex;  itLimit: BcdDefs.IMPIndex;  sgLimit: BcdDefs.SGIndex;  ftLimit: BcdDefs.FTIndex;  enLimit: BcdDefs.ENIndex;  spLimit: BcdDefs.SPIndex;  ntLimit: BcdDefs.NTIndex;  tyLimit: BcdDefs.TYPIndex;  tmLimit: BcdDefs.TMIndex;  fpLimit: BcdDefs.FPIndex;  lfLimit: BcdDefs.LFIndex;  atLimit: BcdDefs.ATIndex;  ssLimit: CARDINAL;  configIndexParamIndex, moduleIndexParamIndex, importIndexParamIndex,    exportIndexParamIndex, fileIndexParamIndex, segmentIndexParamIndex,    nameIndexParamIndex, spaceIndexParamIndex, framePkIndexParamIndex,    nmEntryIndexParamIndex, expVarIndexParamIndex, typeIndexParamIndex,    typeMpIndexParamIndex, linkFgIndexParamIndex, atomIndexParamIndex:     								CARDINAL ¬ 0;  Initialize: PUBLIC PROC =    BEGIN    configIndexParamIndex  ¬ LOOPHOLE[BcdToolCommands.ParamIndex[Config]];    moduleIndexParamIndex  ¬ LOOPHOLE[BcdToolCommands.ParamIndex[Module]];    importIndexParamIndex  ¬ LOOPHOLE[BcdToolCommands.ParamIndex[Import]];    exportIndexParamIndex  ¬ LOOPHOLE[BcdToolCommands.ParamIndex[Export]];    fileIndexParamIndex    ¬ LOOPHOLE[BcdToolCommands.ParamIndex[File]];    segmentIndexParamIndex ¬ LOOPHOLE[BcdToolCommands.ParamIndex[Segment]];    nameIndexParamIndex    ¬ LOOPHOLE[BcdToolCommands.ParamIndex[Name]];    spaceIndexParamIndex   ¬ LOOPHOLE[BcdToolCommands.ParamIndex[Space]];    framePkIndexParamIndex ¬ LOOPHOLE[BcdToolCommands.ParamIndex[FramePk]];    nmEntryIndexParamIndex ¬ LOOPHOLE[BcdToolCommands.ParamIndex[NmEntry]];    expVarIndexParamIndex  ¬ LOOPHOLE[BcdToolCommands.ParamIndex[ExpVar]];    typeIndexParamIndex    ¬ LOOPHOLE[BcdToolCommands.ParamIndex[Type]];    typeMpIndexParamIndex  ¬ LOOPHOLE[BcdToolCommands.ParamIndex[TypeMp]];    linkFgIndexParamIndex  ¬ LOOPHOLE[BcdToolCommands.ParamIndex[LinkFg]];    atomIndexParamIndex    ¬ LOOPHOLE[BcdToolCommands.ParamIndex[Atom]];    END;  ParamNotify: PUBLIC FormSW.NotifyProcType =    BEGIN      ENABLE cancelAction =>          BEGIN        IF endLine THEN Put.Text[BcdToolWindows.fileSW, " XXX"L];        GO TO done;        END;    ClearMsgSW[];      SELECT LOOPHOLE[index, BcdToolCommands.ParamIndex] FROM      LoadBcd       => LoadBcd[];      PutTableBds   => PrintTableBds[];      PutRep        => PrintInVariousRep[GetSelectionValue[]];       Read          => PrintWords[		         from: readLoc, nWords: readWords, 		         mode: readMode];       ReadSel       => PrintWords[		         from: GetSelectionValue[], nWords: readWords, 		         mode: readMode];       FindGfi       => PrintFoundGfi[GetSelectionValue[]];       PutConfig     => PrintConfig[cti: LOOPHOLE[configIndex]];      PutSelConfig  => PrintConfig[cti: LOOPHOLE[GetSelectionValue[]]];      Put1stConfig  => PrintConfig[cti: LOOPHOLE[FIRST[BcdDefs.CTIndex]]];      PutNextConfig => PrintNextConfig[];      PutModule     => PrintModule[mti: LOOPHOLE[moduleIndex]];      PutSelModule  => PrintModule[mti: LOOPHOLE[GetSelectionValue[]]];      Put1stModule  => PrintModule[mti: LOOPHOLE[FIRST[BcdDefs.MTIndex]]];      PutNextModule => PrintNextModule[];      PutLinkFg     => PrintLinkFg[lfi: LOOPHOLE[linkFgIndex]];      PutSelLinkFg  => PrintLinkFg[lfi: LOOPHOLE[GetSelectionValue[]]];      Put1stLinkFg  => PrintLinkFg[lfi: LOOPHOLE[FIRST[BcdDefs.LFIndex]]];      PutNextLinkFg => PrintNextLinkFg[];      PutImport     => PrintImport[iti: LOOPHOLE[importIndex]];      PutSelImport  => PrintImport[iti: LOOPHOLE[GetSelectionValue[]]];      Put1stImport  => PrintImport[iti: LOOPHOLE[FIRST[BcdDefs.IMPIndex]]];      PutNextImport => PrintNextImport[];      PutExport     => PrintExport[eti: LOOPHOLE[exportIndex]];      PutSelExport  => PrintExport[eti: LOOPHOLE[GetSelectionValue[]]];      Put1stExport  => PrintExport[eti: LOOPHOLE[FIRST[BcdDefs.EXPIndex]]];      PutNextExport => PrintNextExport[];      PutFile       => PrintFile[fti: LOOPHOLE[fileIndex]];      PutSelFile    => PrintFile[fti: LOOPHOLE[GetSelectionValue[]]];      Put1stFile    => PrintFile[fti: LOOPHOLE[FIRST[BcdDefs.FTIndex]]];      PutNextFile   => PrintNextFile[];      PutSegment    => PrintSegment[sgi: LOOPHOLE[segmentIndex]];      PutSelSegment => PrintSegment[sgi: LOOPHOLE[GetSelectionValue[]]];      Put1stSegment => PrintSegment[sgi: LOOPHOLE[FIRST[BcdDefs.SGIndex]]];      PutNextSegment=> PrintNextSegment[];      PutName       => PrintName[name: LOOPHOLE[nameIndex]];      PutSelName    => PrintName[name: LOOPHOLE[GetSelectionValue[]]];      Put1stName    => PrintName[name: BcdDefs.NullName];      PutNextName   => PrintNextName[];      PutSpace      => PrintSpace[spi: LOOPHOLE[nameIndex]];      PutSelSpace   => PrintSpace[spi: LOOPHOLE[GetSelectionValue[]]];      Put1stSpace   => PrintSpace[spi: LOOPHOLE[FIRST[BcdDefs.SPIndex]]];      PutNextSpace  => PrintNextSpace[];      PutFramePk    => PrintFramePk[fpi: LOOPHOLE[framePkIndex]];      PutSelFramePk => PrintFramePk[fpi: LOOPHOLE[GetSelectionValue[]]];      Put1stFramePk => PrintFramePk[fpi: LOOPHOLE[FIRST[BcdDefs.FPIndex]]];      PutNextFramePk=> PrintNextFramePk[];      PutNmEntry    => PrintNmEntry[nti: LOOPHOLE[nmEntryIndex]];      PutSelNmEntry => PrintNmEntry[nti: LOOPHOLE[GetSelectionValue[]]];      Put1stNmEntry => PrintNmEntry[nti: LOOPHOLE[FIRST[BcdDefs.NTIndex]]];      PutNextNmEntry=> PrintNextNmEntry[];      PutExpVar     => PrintExpVar[eni: LOOPHOLE[expVarIndex]];      PutSelExpVar  => PrintExpVar[eni: LOOPHOLE[GetSelectionValue[]]];      Put1stExpVar  => PrintExpVar[eni: LOOPHOLE[FIRST[BcdDefs.ENIndex]]];      PutNextExpVar => PrintNextExpVar[];      PutType       => PrintType[typi: LOOPHOLE[typeIndex]];      PutSelType    => PrintType[typi: LOOPHOLE[GetSelectionValue[]]];      Put1stType    => PrintType[typi: LOOPHOLE[FIRST[BcdDefs.TYPIndex]]];      PutNextType   => PrintNextType[];      PutTypeMp     => PrintTypeMp[tmi: LOOPHOLE[typeMpIndex]];      PutSelTypeMp  => PrintTypeMp[tmi: LOOPHOLE[GetSelectionValue[]]];      Put1stTypeMp  => PrintTypeMp[tmi: LOOPHOLE[FIRST[BcdDefs.TYPIndex]]];      PutNextTypeMp => PrintNextTypeMp[];      PutAtom       => PrintAtom[ati: LOOPHOLE[atomIndex]];      PutSelAtom    => PrintAtom[ati: LOOPHOLE[GetSelectionValue[]]];      Put1stAtom    => PrintAtom[ati: LOOPHOLE[FIRST[BcdDefs.ATIndex]]];      PutNextAtom   => PrintNextAtom[];      ENDCASE;    EXITS      done => NULL;    END;  ClearMsgSW: PROC = {Print.Complaint[msg: " "L, clear: TRUE]};  GetSelectionValue: PROC RETURNS [value: UNSPECIFIED] =     BEGIN    value ¬ Selection.Number[radix: 10 !      String.InvalidNumber => GO TO notNumber];    EXITS      notNumber =>	BEGIN	Print.Complaint["Invalid number selected"L];	UserTerminal.BlinkDisplay[];	ERROR cancelAction;	END    END;  LoadBcd: PROC =    BEGIN    completeFileName: STRING ¬ [40];    IF BcdToolSourceBcd.IsLoaded[] THEN BcdToolSourceBcd.Unload[];    String.AppendString[to: completeFileName, from: bcdFileName];    FOR i: CARDINAL IN [0..completeFileName.length) DO      IF completeFileName[i] = '. THEN EXIT;      REPEAT         FINISHED => String.AppendString[to: completeFileName, from: ".bcd"];      ENDLOOP;    BcdToolSourceBcd.Load[completeFileName !      BcdToolSourceBcd.UnknownBcdFile =>         BEGIN        UserTerminal.BlinkDisplay[];        Print.Complaint["Unknown Bcd file"L];	GO TO exit;        END;      BcdToolSourceBcd.IncompatibleVersion =>        BEGIN        UserTerminal.BlinkDisplay[];        Print.Complaint["Bcd has an incompatible version"L];	GO TO exit;        END ];    SetupBcdBaseAndLimits[];    bcdHeader ¬ BcdToolSourceBcd.bcdHeader;    WriteBcdHeader[];    EXITS      exit => NULL;    END;  SetupBcdBaseAndLimits: PROC =    BEGIN  OPEN BcdToolSourceBcd;    ctb ¬ bcdBases.ctb;  ctLimit ¬ bcdLimits.ct;    mtb ¬ bcdBases.mtb;  mtLimit ¬ bcdLimits.mt;    etb ¬ bcdBases.etb;  etLimit ¬ bcdLimits.et;    itb ¬ bcdBases.itb;  itLimit ¬ bcdLimits.it;    sgb ¬ bcdBases.sgb;  sgLimit ¬ bcdLimits.sg;    ftb ¬ bcdBases.ftb;  ftLimit ¬ bcdLimits.ft;    enb ¬ bcdBases.enb;  enLimit ¬ bcdLimits.en;    spb ¬ bcdBases.spb;  spLimit ¬ bcdLimits.sp;    ntb ¬ bcdBases.ntb;  ntLimit ¬ bcdLimits.nt;    tyb ¬ bcdBases.tyb;  tyLimit ¬ bcdLimits.ty;    tmb ¬ bcdBases.tmb;  tmLimit ¬ bcdLimits.tm;    fpb ¬ bcdBases.fpb;  fpLimit ¬ bcdLimits.fp;    lfb ¬ bcdBases.lfb;  lfLimit ¬ bcdLimits.lf;    ssb ¬ bcdBases.ssb;  ssLimit ¬ bcdLimits.ss;    atb ¬ bcdBases.atb;  atLimit ¬ bcdLimits.at;    END;  WriteBcdHeader: PROC =    BEGIN    Print.Text[bcdFileName];    Print.Text[" configured "L];  Print.Date[bcdHeader.version.time];    IF bcdHeader.sourceFile = BcdDefs.FTNull THEN       Print.Text[" from (Source File = NULL) "L]      ELSE IF ftb[bcdHeader.sourceFile].name # BcdDefs.NullName THEN      BEGIN      Print.Text[" from "L];        Print.Name[ftb[bcdHeader.sourceFile].name];      Print.Text[" (created "L];        Print.Date[ftb[bcdHeader.sourceFile].version.time];      Print.Char[')];      END;    Print.Cr[];    IF bcdHeader.versionIdent # BcdDefs.VersionID THEN      BEGIN      Print.Text["  Obsolete VersionID = "L];      Print.Cardinal[bcdHeader.versionIdent];      Print.Cr[];      END;    Print.Text["  Configured by translator "L];    Print.Date[bcdHeader.creator.time];    Print.Sp[];  Print.Machine[bcdHeader.creator];    Print.Text[" on machine "L];  Print.Machine[bcdHeader.version];    Print.Cr[];    Print.Text["  nPages: "L];  Print.Decimal[bcdHeader.nPages];    Print.Text[", "];    IF ~bcdHeader.definitions THEN Print.Char['~];      Print.Text["defs, "L];    IF ~bcdHeader.repackaged THEN Print.Char['~];      Print.Text["repackaged, "L];    IF ~bcdHeader.typeExported THEN Print.Char['~];      Print.Text["typeExported, "L];    IF ~bcdHeader.tableCompiled THEN Print.Char['~];      Print.Text["tableCompiled, "L];--    IF ~bcdHeader.versions THEN Print.Char['~];  --    Print.Text["versions, "L];--    IF ~bcdHeader.extended THEN Print.Char['~];  --    Print.Text["extended, "L];    Print.Cr[];    Print.Text["  Configs: "];  Print.Decimal[bcdHeader.nConfigs];    Print.NextCardinal["modules"L, bcdHeader.nModules];    Print.NextCardinal["imports"L, bcdHeader.nImports];    Print.NextCardinal["exports"L, bcdHeader.nExports];    Print.NextCardinal["first dummy"L, bcdHeader.firstdummy];    Print.NextCardinal["#dummies"L, bcdHeader.nDummies];    Print.Cr[];  Print.Cr[];      END;  PrintTableBds: PROC =    BEGIN    VerifyBcdLoaded[];    Print.Cr[];    Print.Text["~~~~~~~~~~~~~~~~~~  Table Bounds ~~~~~~~~~~~~~~~~~~~"L];    Print.Cr[];    WriteTable[      title: "  config"L,       offset: bcdHeader.ctOffset, limit: LOOPHOLE[bcdHeader.ctLimit]];    WriteTable[      title: ", module"L,       offset: bcdHeader.mtOffset, limit: LOOPHOLE[bcdHeader.mtLimit]];    WriteTable[      title: ", import"L,       offset: bcdHeader.impOffset, limit: LOOPHOLE[bcdHeader.impLimit]];    Print.Cr[];    WriteTable[      title: "  export"L,       offset: bcdHeader.expOffset, limit: LOOPHOLE[bcdHeader.expLimit]];    WriteTable[      title: ", exp var"L,       offset: bcdHeader.enOffset, limit: LOOPHOLE[bcdHeader.enLimit]];    WriteTable[      title: ", file"L,       offset: bcdHeader.ftOffset, limit: LOOPHOLE[bcdHeader.ftLimit]];    WriteTable[      title: ", segment"L,       offset: bcdHeader.sgOffset, limit: LOOPHOLE[bcdHeader.sgLimit]];    Print.Cr[];    WriteTable[      title: "  string"L,       offset: bcdHeader.ssOffset, limit: LOOPHOLE[bcdHeader.ssLimit]];    WriteTable[      title: ", name"L,       offset: bcdHeader.ntOffset, limit: LOOPHOLE[bcdHeader.ntLimit]];    WriteTable[      title: ", space"L,       offset: bcdHeader.spOffset, limit: LOOPHOLE[bcdHeader.spLimit]];    WriteTable[      title: ", frame pack"L,       offset: bcdHeader.fpOffset, limit: LOOPHOLE[bcdHeader.fpLimit]];    Print.Cr[];    WriteTable[      title: "  type"L,       offset: bcdHeader.typOffset, limit: LOOPHOLE[bcdHeader.typLimit]];    WriteTable[      title: ", type map"L,       offset: bcdHeader.tmOffset, limit: LOOPHOLE[bcdHeader.tmLimit]];    WriteTable[      title: ", link fragment"L,       offset: bcdHeader.lfOffset, limit: LOOPHOLE[bcdHeader.lfLimit]];    Print.Cr[];  Print.Cr[];      END;  VerifyBcdLoaded: PROC =    BEGIN    IF ~BcdToolSourceBcd.IsLoaded[] THEN      BEGIN      Print.Complaint["No Bcd is loaded"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    END;  WriteTable: PROC [title: STRING, offset, limit: CARDINAL] =    BEGIN    Print.Text[title];  Print.Char[':];    IF limit = 0 THEN Print.Char['*]    ELSE      BEGIN      Print.Char['[];      Print.Decimal[offset];  Print.Text[".."L];        Print.Decimal[offset + limit];      Print.Char[')];      END;    END;  PrintInVariousRep: PROC [value: UNSPECIFIED] =    BEGIN    Print.VariousRepresentations[value];    Print.Cr[];    END;  PrintWords: PROC [from, nWords: CARDINAL, mode: BcdToolCommands.ReadMode] =    BEGIN    word: LONG POINTER TO ARRAY[0..0) OF UNSPECIFIED = LOOPHOLE[bcdHeader];    w: UNSPECIFIED;    count: CARDINAL ¬ 0;    VerifyBcdLoaded[];    IF MSegment.PagesForWords[from + nWords] > bcdHeader.nPages THEN      BEGIN      Print.Complaint["Word count is greater than Bcd length"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    count ¬ 0;    FOR i: CARDINAL IN [from..(from + nWords)) DO      w ¬ word[i];      IF (count ¬ count + 1) > 7 THEN {Print.Cr[];  count ¬ 1};      Print.Char['(];  Print.Decimal[i];  Print.Text[") "L];         SELECT mode FROM        decimal => Print.Decimal[w];         octal   => Print.Octal[w];         ascii   => 	  BEGIN	  byte: PACKED ARRAY [0..1] OF [0..128) = LOOPHOLE[w];	  Print.AsciiChar[byte[0]];  Print.Sp[]; 	  Print.AsciiChar[byte[1]];	  END;        ENDCASE;      Print.Text["  "L];      ENDLOOP;     Print.Cr[];    END;  PrintGarbage: PROC =    BEGIN    Print.Text["? Looks like garbage ..."L];    Print.Cr[];    END;      OutOfRange: PROCEDURE [index, limit: UNSPECIFIED] RETURNS [BOOLEAN] =    INLINE {RETURN[LOOPHOLE[index, CARDINAL] > LOOPHOLE[limit, CARDINAL]]};    PrintFoundGfi: PROC [gfi: CARDINAL] =    BEGIN    VerifyBcdLoaded[];    Print.Text["Gfi "L];  Print.Decimal[gfi];  Print.Text[": "L];    -- search among modules    FOR mti: BcdDefs.MTIndex ¬ FIRST[BcdDefs.MTIndex], mti + SIZE[BcdDefs.MTRecord]    UNTIL mti = mtLimit DO      WriteModule[mti];      IF OutOfRange[mti, mtLimit] THEN GO TO Bogus;      REPEAT         Bogus => PrintGarbage[];      ENDLOOP;    -- search among imports    FOR iti: BcdDefs.IMPIndex ¬ FIRST[BcdDefs.IMPIndex],      iti + SIZE[BcdDefs.IMPRecord]     UNTIL iti = itLimit DO      WriteImport[iti];      IF OutOfRange[iti, itLimit] THEN GO TO Bogus;      REPEAT         Bogus => PrintGarbage[];      ENDLOOP;    Print.Cr[];     END;   PrintConfig: PROC [cti: BcdDefs.CTIndex] =    {WriteConfig[cti]};  PrintNextConfig: PROC =    BEGIN    cti: BcdDefs.CTIndex = LOOPHOLE[configIndex];    increment: CARDINAL;    VerifyBcdLoaded[];    increment ¬       SIZE[BcdDefs.CTRecord] + ctb[cti].nControls*SIZE[BcdDefs.Namee];    IF (configIndex + increment) >= LOOPHOLE[ctLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No configuration table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    WriteConfig[cti: LOOPHOLE[(configIndex + increment), BcdDefs.CTIndex]];    END;  WriteConfig: PROC [cti: BcdDefs.CTIndex] =    BEGIN  OPEN config: ctb[cti];    VerifyBcdLoaded[];    configIndex ¬ LOOPHOLE[cti, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: configIndexParamIndex];    IF LOOPHOLE[ctLimit, CARDINAL] = 0 OR         LOOPHOLE[cti, CARDINAL] >= LOOPHOLE[ctLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of configuration table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;      Print.Text["Config"L];     Print.Index[index: cti, nullIndex: BcdDefs.CTNull];    IF cti # BcdDefs.CTNull THEN      BEGIN       Print.Sp[];        WriteName[config.name];        IF config.namedInstance THEN         BEGIN        Print.Text[", instance name: "L];         Print.InstanceNameForNamee[namee: [config[cti]]];        END;      Print.Text[", file"L];      Print.Index[index: config.file, nullIndex: BcdDefs.FTNull];      Print.Text[": "L];  WriteFileName[config.file];        IF config.config # BcdDefs.CTNull THEN         BEGIN        Print.Text[", parent"L];         Print.Index[index: config.config, nullIndex: BcdDefs.CTNull];        Print.Text[": "L];  WriteName[ctb[config.config].name];          END;      IF config.nControls # 0 THEN        BEGIN        Print.Text[", controls: ("L];  Print.Cardinal[config.nControls];        Print.Text[")["L];        FOR i: CARDINAL IN [0..config.nControls) DO	  WITH c: config.controls[i] SELECT FROM	    module => {	      Print.Text["module"L];	      Print.Index[index: c.mti, nullIndex: BcdDefs.MTNull];	      Print.Text[": "L];  Print.Name[mtb[c.mti].name]};	    config => {	      Print.Text["config"L];	      Print.Index[index: c.cti, nullIndex: BcdDefs.CTNull];	      Print.Text[": "L];  Print.Name[ctb[c.cti].name]};	    ENDCASE => Print.Text["Bad control variant!"L];  	  Print.Text[IF i # CARDINAL[config.nControls - 1] THEN ", "L ELSE "]"L];  	  ENDLOOP;        END;      END;    Print.Cr[];    END;  WriteName: PROC [name: BcdDefs.NameRecord] =    BEGIN    IF name = BcdDefs.NullName THEN Print.Text["[null name]"L]    ELSE       BEGIN      IF name > (2*ssLimit - 4) THEN Print.Text["(name out of range)"L]      ELSE Print.Name[name];        Print.Char['[];  Print.Cardinal[name];  Print.Char[']];      END;    END;  WriteFileName: PROC [fti: BcdDefs.FTIndex] =    BEGIN    SELECT fti FROM      BcdDefs.FTNull => Print.Text["(null file)"L];      BcdDefs.FTSelf => Print.Text["(self)"L];      ENDCASE => WriteName[ftb[fti].name];    END;  PrintModule: PROC [mti: BcdDefs.MTIndex] =    {WriteModule[mti]};  PrintNextModule: PROC =    BEGIN    mti: BcdDefs.MTIndex = LOOPHOLE[moduleIndex];    increment: CARDINAL;    VerifyBcdLoaded[];    increment ¬ SIZE[BcdDefs.MTRecord];    IF (moduleIndex + increment) >= LOOPHOLE[mtLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No module table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    WriteModule[mti: LOOPHOLE[(moduleIndex + increment), BcdDefs.MTIndex]];    END;  WriteModule: PROC [mti: BcdDefs.MTIndex] =    BEGIN  OPEN module: mtb[mti];    VerifyBcdLoaded[];    moduleIndex ¬ LOOPHOLE[mti, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: moduleIndexParamIndex];    IF LOOPHOLE[mtLimit, CARDINAL] = 0 OR         LOOPHOLE[mti, CARDINAL] >= LOOPHOLE[mtLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of module table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;      Print.Text["Module"L];     Print.Index[index: mti, nullIndex: BcdDefs.MTNull];    IF mti # BcdDefs.MTNull THEN      BEGIN       Print.Sp[];        WriteName[module.name];        IF module.namedInstance THEN          BEGIN        Print.Text[", instance name: "L];        Print.InstanceNameForNamee[namee: [module[mti]]];        END;      Print.Text[", file"L];      Print.Index[index: module.file, nullIndex: BcdDefs.FTNull];      Print.Text[": "L];  WriteFileName[module.file];      Print.Text["  "L];      IF module.file # BcdDefs.FTSelf AND module.file # BcdDefs.FTNull THEN        Print.Version[ftb[module.file].version];      Print.Cr[];      IF module.config # BcdDefs.CTNull THEN         BEGIN        Print.Text["  config"L];        Print.Index[index: module.config, nullIndex: BcdDefs.CTNull];        Print.Text[": "L];  WriteName[ctb[module.config].name];        Print.Cr[];        END;      Print.Text["  "L];        IF ~module.tableCompiled THEN Print.Char['~];        Print.Text["tableComp, "L];      IF ~module.packageable THEN Print.Char['~];        Print.Text["packageable, "L];      IF ~module.residentFrame THEN Print.Char['~];        Print.Text["resFrame, "L];      IF ~module.initial THEN Print.Char['~];        Print.Text["init, "L];      IF ~module.boundsChecks THEN Print.Char['~];        Print.Text["boundsCks, "L];      IF ~module.nilChecks THEN Print.Char['~];        Print.Text["nilCks, "L];      IF ~module.crossJumped THEN Print.Char['~];        Print.Text["cross jumped, "L];      IF module.spare # ALL[FALSE] THEN {	FOR i: CARDINAL IN [0..LENGTH[module.spare]) DO	  IF module.spare[i] THEN {	  Print.Text["spare["L]; Print.Decimal[i]; Print.Text["], "L]};	  ENDLOOP};      Print.Cr[];      Print.Text["  framesize: "L];      Print.Decimal[module.framesize];      Print.Text["code: "L];  PrintSegment[module.code.sgi];      Print.Text[", offset: "L];  Print.Octal[module.code.offset];      Print.Text[", length: "L];  Print.Octal[module.code.length];      Print.Text[", links: "L];      Print.Index[index: module.links, nullIndex: BcdDefs.LFNull];      Print.Text[", linkLoc: "L];      Print.Text[        (SELECT module.linkLoc FROM	  frame => "frame"L,	  code => "code"L,	  ENDCASE => "dontcare"L)];      IF module.linkspace THEN Print.Text[", linkspace avail"L];      IF module.packed THEN Print.Text[", packed"L];      PrintLinkFg[module.links];      Print.Cr[];      Print.Text["  code: "L];  WriteSegment[module.code.sgi];      Print.NextOctal["offset"L, module.code.offset];      Print.NextOctal["length"L, module.code.length];      Print.Cr[];      Print.Text["  symbols: "L];  WriteSegment[module.sseg];      END;    Print.Cr[];  Print.Cr[];    END;      PrintLinkFg: PROC [lfi: BcdDefs.LFIndex] = {    IF lfi # BcdDefs.LFNull THEN WriteLinkFg[lfi]};    PrintNextLinkFg: PROC =     BEGIN    lfi: BcdDefs.LFIndex = LOOPHOLE[linkFgIndex];    increment: CARDINAL;    VerifyBcdLoaded[];    increment ¬ SIZE[BcdDefs.LinkFrag[lfb[lfi].length]];    IF (linkFgIndex + increment) >= LOOPHOLE[lfLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No link fragment entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    WriteLinkFg[lfi: LOOPHOLE[(linkFgIndex + increment), BcdDefs.LFIndex]];    END;  WriteLinkFg: PROC [lfi: BcdDefs.LFIndex] = {    length: CARDINAL;    VerifyBcdLoaded[];    length ¬ lfb[lfi].length;    linkFgIndex ¬ LOOPHOLE[lfi, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: linkFgIndexParamIndex];    IF LOOPHOLE[lfLimit, CARDINAL] = 0 OR        LOOPHOLE[lfi, CARDINAL] >= LOOPHOLE[lfLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of link fragment table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    Print.Text["Link Fragment"L];     Print.Index[index: lfi, nullIndex: BcdDefs.LFNull];    Print.Text["  #links: "L];    Print.Decimal[length];    IF length # 0 THEN Print.Text[", control links:"L];    FOR i: CARDINAL IN [0..length) DO      IF (i MOD 8) = 0 THEN {Print.Cr[];  Print.Text["    "L]}      ELSE Print.Sp[];      Print.ControlLink[lfb[lfi].frag[i]];      IF (i + 1) # length THEN Print.Char[',];      ENDLOOP;    Print.Cr[];  Print.Cr[]};  PrintImport: PROC [iti: BcdDefs.IMPIndex] =    {WriteImport[iti]};  PrintNextImport: PROC =    BEGIN    increment: CARDINAL = SIZE[BcdDefs.IMPRecord];    VerifyBcdLoaded[];    IF (importIndex + increment) >= LOOPHOLE[itLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No import table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    WriteImport[iti: LOOPHOLE[(importIndex + increment), BcdDefs.IMPIndex]];    END;  WriteImport: PROC [iti: BcdDefs.IMPIndex] =    BEGIN  OPEN import: itb[iti];    VerifyBcdLoaded[];    importIndex ¬ LOOPHOLE[iti, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: importIndexParamIndex];    IF LOOPHOLE[itLimit, CARDINAL] = 0 OR        LOOPHOLE[iti, CARDINAL] >= LOOPHOLE[itLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of import table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;      Print.Text["Import"L];     Print.Index[index: iti, nullIndex: BcdDefs.IMPNull];    IF iti # BcdDefs.IMPNull THEN      BEGIN       com: LONG POINTER TO AtomVariants.IMPRecord ¬ LOOPHOLE[@import];            Print.Sp[];      WriteName[import.name];       IF com.common THEN  { -- This import is really a common declaration	 Print.Text[", a Fortran"L];	 IF com.initialized THEN Print.Text[" , initialized,"L];	 Print.Text[" COMMON declaration, size: "L];	 Print.LongCardinal[com.commonSize];         Print.NextCardinal["gfi"L, com.gfi]}        ELSE { -- It's a normal import record	IF import.port = module THEN Print.Text[", module"L];	IF import.namedInstance THEN	  BEGIN	  Print.Text[", instance name: "L];	  Print.InstanceNameForNamee[namee: [import[iti]]];	  END;        IF import.file = BcdDefs.FTNull THEN           Print.Text[", import file is FTNull"L]        ELSE {          Print.Text[", version"L];          Print.Index[index: import.file, nullIndex: BcdDefs.IMPNull];          Print.Text[": "L];  Print.Version[ftb[import.file].version]};         Print.NextCardinal["gfi"L, import.gfi]}        END;    Print.Cr[];    END;  PrintExport: PROC [eti: BcdDefs.EXPIndex] =    {WriteExport[eti]};  PrintNextExport: PROC =    BEGIN    eti: BcdDefs.EXPIndex = LOOPHOLE[exportIndex];    increment: CARDINAL;    VerifyBcdLoaded[];    increment ¬ SIZE[BcdDefs.EXPRecord] + etb[eti].size*SIZE[BcdDefs.Link];    IF (exportIndex + increment) >= LOOPHOLE[etLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No export table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    WriteExport[eti: LOOPHOLE[(exportIndex + increment), BcdDefs.EXPIndex]];    END;  WriteExport: PROC [eti: BcdDefs.EXPIndex] =    BEGIN  OPEN export: etb[eti];    VerifyBcdLoaded[];    exportIndex ¬ LOOPHOLE[eti, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: exportIndexParamIndex];    IF LOOPHOLE[etLimit, CARDINAL] = 0 OR        LOOPHOLE[eti, CARDINAL] >= LOOPHOLE[etLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of export table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;      Print.Text["Export"L];     Print.Index[index: eti, nullIndex: BcdDefs.EXPNull];    IF eti # BcdDefs.EXPNull THEN      BEGIN      Print.Sp[];       WriteName[export.name];          IF export.port = module THEN Print.Text[", module"L];      IF export.namedInstance THEN         BEGIN        Print.Text[", instance name: "L];         Print.InstanceNameForNamee[namee: [export[eti]]];        END;      Print.Text[", version"L];      Print.Index[index: export.file, nullIndex: BcdDefs.FTNull];      Print.Text[": "L];  Print.Version[ftb[export.file].version];       Print.Text[", "L];       IF ~export.typeExported THEN Print.Char['~];        Print.Text["typeExported"L];      Print.NextCardinal["#links"L, export.size];        Print.Text[", control links:"L];      FOR i: CARDINAL IN [0..export.size) DO        IF (i MOD 8) = 0 THEN {Print.Cr[];  Print.Text["  "L]}        ELSE Print.Sp[];        Print.ControlLink[export.links[i]];        IF (i + 1) # export.size THEN Print.Char[',];        ENDLOOP;      END;    Print.Cr[];    END;  PrintFile: PROC [fti: BcdDefs.FTIndex] =    {WriteFile[fti]};  PrintNextFile: PROC =    BEGIN    increment: CARDINAL = SIZE[BcdDefs.FTRecord];    VerifyBcdLoaded[];    IF (fileIndex + increment) >= LOOPHOLE[ftLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No module table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    WriteFile[fti: LOOPHOLE[(fileIndex + increment), BcdDefs.FTIndex]];    END;  WriteFile: PROC [fti: BcdDefs.FTIndex] =    BEGIN  OPEN file: ftb[fti];    VerifyBcdLoaded[];    fileIndex ¬ LOOPHOLE[fti, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: fileIndexParamIndex];    IF LOOPHOLE[ftLimit, CARDINAL] = 0 OR        LOOPHOLE[fti, CARDINAL] >= LOOPHOLE[ftLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of file table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    Print.Text["File"L];    Print.Index[index: fti, nullIndex: BcdDefs.FTNull];    IF fti # BcdDefs.FTNull THEN      BEGIN       Print.Sp[];        WriteFileName[fti];            Print.Text[", version: "L];  Print.Version[file.version];      END;      Print.Cr[];    END;  PrintSegment: PROC [sgi: BcdDefs.SGIndex] =    {PutSegment[sgi]};  PrintNextSegment: PROC =    BEGIN    increment: CARDINAL = SIZE[BcdDefs.SGRecord];    VerifyBcdLoaded[];    IF (segmentIndex + increment) >= LOOPHOLE[sgLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No module table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    PutSegment[sgi: LOOPHOLE[(segmentIndex + increment), BcdDefs.SGIndex]];    END;  PutSegment: PROC [sgi: BcdDefs.SGIndex] =    BEGIN    classLabel: ARRAY BcdDefs.SegClass OF STRING = [      "code"L, "symbols"L, "acMap"L, "other"L];    VerifyBcdLoaded[];      segmentIndex ¬ LOOPHOLE[sgi, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: segmentIndexParamIndex];    IF LOOPHOLE[sgLimit, CARDINAL] = 0 OR        LOOPHOLE[sgi, CARDINAL] >= LOOPHOLE[sgLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of segment table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    Print.Text["Segment"L];      WriteSegment[sgi];    IF sgi # BcdDefs.SGNull THEN      {Print.Text[", "L];  Print.Text[classLabel[sgb[sgi].class]]};      Print.Cr[];    END;  WriteSegment: PROC [sgi: BcdDefs.SGIndex] =    BEGIN  OPEN segment: sgb[sgi];    Print.Index[index: sgi, nullIndex: BcdDefs.SGNull];    IF sgi # BcdDefs.SGNull THEN      BEGIN      Print.Sp[];      WriteFileName[segment.file];         Print.Text[", [base: "L];  Print.Decimal[segment.base];       Print.NextCardinal["pages"L, segment.pages];      IF segment.extraPages # 0 THEN         {Print.Char['+];  Print.Decimal[segment.extraPages]};      Print.Char[']];      END;    END;  PrintName: PROC [name: BcdDefs.NameRecord] =    {PutName[name]};  PrintNextName: PROC =    BEGIN    increment: CARDINAL;    VerifyBcdLoaded[];    IF ssLimit = 0 OR (nameIndex > (2*ssLimit - 4)) THEN      BEGIN      Print.Complaint["Name index is beyond end of string table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;      increment ¬ ssb.size[nameIndex];     IF (nameIndex + increment) >= (2*ssLimit - 4) THEN      BEGIN      Print.Complaint["No name table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    PutName[name: LOOPHOLE[(nameIndex + increment), BcdDefs.NameRecord]];    END;  PutName: PROC [name: BcdDefs.NameRecord] =    BEGIN    VerifyBcdLoaded[];    nameIndex ¬ name;    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: nameIndexParamIndex];    IF ssLimit = 0 OR (name > (2*ssLimit - 4)) THEN      BEGIN      Print.Complaint["Name index is beyond end of string table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;      Print.Text["Name "L];  WriteName[name];      Print.Cr[];    END;  PrintSpace: PROC [spi: BcdDefs.SPIndex] =    {WriteSpace[spi]};  PrintNextSpace: PROC =    BEGIN    spi: BcdDefs.SPIndex = LOOPHOLE[spaceIndex];    increment: CARDINAL;    VerifyBcdLoaded[];    increment ¬       SIZE[BcdDefs.SPRecord] + spb[spi].length*SIZE[BcdDefs.SpaceID];    IF (spaceIndex + increment) >= LOOPHOLE[spLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No space table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    WriteSpace[spi: LOOPHOLE[(spaceIndex + increment), BcdDefs.SPIndex]];    END;  WriteSpace: PROC [spi: BcdDefs.SPIndex] =    BEGIN  OPEN spaceRec: spb[spi];    VerifyBcdLoaded[];    spaceIndex ¬ LOOPHOLE[spi, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: spaceIndexParamIndex];    IF LOOPHOLE[spLimit, CARDINAL] = 0 OR        LOOPHOLE[spi, CARDINAL] >= LOOPHOLE[spLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of space table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;      Print.Text["Space"L];  Print.Index[index: spi, nullIndex: BcdDefs.SPNull];    IF spi # BcdDefs.SPNull THEN      BEGIN      Print.Text[" segment: "L];       Print.Index[index: spaceRec.seg, nullIndex: BcdDefs.SGNull];      Print.Text[", length: "L];  Print.Cardinal[spaceRec.length];      IF spaceRec.length # 0 THEN Print.Text[", code packs: "L];      FOR i: CARDINAL IN [0..spaceRec.length) DO        Print.Cr[];        Print.Text["  code pack "L];  WriteName[spaceRec.spaces[i].name];        Print.Text[", "L];        IF ~spaceRec.spaces[i].resident THEN Print.Char['~];        Print.Text["resident, offset: "L];        Print.Cardinal[spaceRec.spaces[i].offset];        Print.Text[", pages: "L];  Print.Cardinal[spaceRec.spaces[i].pages];        ENDLOOP;      END;    Print.Cr[];    END;  PrintFramePk: PROC [fpi: BcdDefs.FPIndex] =    {WriteFramePk[fpi]};  PrintNextFramePk: PROC =    BEGIN    fpi: BcdDefs.FPIndex = LOOPHOLE[framePkIndex];    increment: CARDINAL;    VerifyBcdLoaded[];    increment ¬       SIZE[BcdDefs.FPRecord] + fpb[fpi].length*SIZE[BcdDefs.MTIndex];    IF (framePkIndex + increment) >= LOOPHOLE[fpLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No frame pack table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    WriteFramePk[fpi: LOOPHOLE[(framePkIndex + increment), BcdDefs.FPIndex]];    END;  WriteFramePk: PROC [fpi: BcdDefs.FPIndex] =    BEGIN  OPEN framePack: fpb[fpi];    VerifyBcdLoaded[];    framePkIndex ¬ LOOPHOLE[fpi, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: framePkIndexParamIndex];    IF LOOPHOLE[fpLimit, CARDINAL] = 0 OR        LOOPHOLE[fpi, CARDINAL] >= LOOPHOLE[fpLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of frame pack table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;      Print.Text["Frame pack"L];     Print.Index[index: fpi, nullIndex: BcdDefs.FPNull];    IF fpi # BcdDefs.FPNull THEN      BEGIN      Print.Sp[];       WriteName[framePack.name];      Print.Text[", length: "L];  Print.Cardinal[framePack.length];      IF framePack.length # 0 THEN Print.Text[", modules: "L];      FOR i: CARDINAL IN [0..framePack.length) DO        IF (i MOD 10) = 0 THEN {Print.Cr[];  Print.Text["  "L]}        ELSE Print.Sp[];        Print.Index[index: framePack.modules[i], nullIndex: BcdDefs.MTNull];        IF (i + 1) # framePack.length THEN Print.Char[',];        ENDLOOP;      END;    Print.Cr[];    END;  PrintNmEntry: PROC [nti: BcdDefs.NTIndex] =    {WriteNmEntry[nti]};  PrintNextNmEntry: PROC =    BEGIN    nti: BcdDefs.NTIndex = LOOPHOLE[nmEntryIndex];    increment: CARDINAL = SIZE[BcdDefs.NTRecord];    VerifyBcdLoaded[];    IF (nmEntryIndex + increment) >= LOOPHOLE[ntLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No name table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    WriteNmEntry[nti: LOOPHOLE[(nmEntryIndex + increment), BcdDefs.NTIndex]];    END;  WriteNmEntry: PROC [nti: BcdDefs.NTIndex] =    BEGIN  OPEN nameRec: ntb[nti];    VerifyBcdLoaded[];    nmEntryIndex ¬ LOOPHOLE[nti, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: nmEntryIndexParamIndex];    IF LOOPHOLE[ntLimit, CARDINAL] = 0 OR        LOOPHOLE[nti, CARDINAL] >= LOOPHOLE[ntLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of name table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;      Print.Text["Name table entry"L];     Print.Index[index: nti, nullIndex: BcdDefs.NTNull];    IF nti # BcdDefs.NTNull THEN      BEGIN      Print.Text[" [name: "L];  WriteName[nameRec.name];      Print.Text[", namee: "L];      WITH nameRec.item SELECT FROM        config =>  	  BEGIN  	  Print.Text["config"L];  	  Print.Index[index: cti, nullIndex: BcdDefs.CTNull];  	  END;        module =>  	  BEGIN  	  Print.Text["module"L];  	  Print.Index[index: mti, nullIndex: BcdDefs.MTNull];  	  END;        import =>  	  BEGIN  	  Print.Text["import"L];  	  Print.Index[index: impi, nullIndex: BcdDefs.IMPNull];  	  END;        export =>  	  BEGIN  	  Print.Text["export"L];  	  Print.Index[index: expi, nullIndex: BcdDefs.EXPNull];  	  END;        ENDCASE;      Print.Char[']];      END;    Print.Cr[];    END;  PrintExpVar: PROC [eni: BcdDefs.ENIndex] =    {WriteExpVar[eni]};  PrintNextExpVar: PROC =    BEGIN    eni: BcdDefs.ENIndex = LOOPHOLE[expVarIndex];    increment: CARDINAL;    VerifyBcdLoaded[];    increment ¬       SIZE[BcdDefs.ENRecord] + enb[eni].nEntries*SIZE[CARDINAL];    IF (expVarIndex + increment) >= LOOPHOLE[enLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No exported variable table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    WriteExpVar[eni: LOOPHOLE[(expVarIndex + increment), BcdDefs.ENIndex]];    END;  WriteExpVar: PROC [eni: BcdDefs.ENIndex] =    BEGIN  OPEN expVar: enb[eni];    VerifyBcdLoaded[];    expVarIndex ¬ LOOPHOLE[eni, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: expVarIndexParamIndex];    IF LOOPHOLE[enLimit, CARDINAL] = 0 OR        LOOPHOLE[eni, CARDINAL] >= LOOPHOLE[enLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of exported variable table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;      Print.Text["Exported variables"L];     Print.Index[index: eni, nullIndex: BcdDefs.ENNull];    IF eni # BcdDefs.ENNull THEN      BEGIN       Print.Text[" length: "L];  Print.Cardinal[expVar.nEntries];      Print.Text[", offsets: "L];      FOR i: CARDINAL IN [1..expVar.nEntries] DO        IF (i MOD 10) = 1 THEN {Print.Cr[];  Print.Text["  "L]}        ELSE Print.Sp[];        Print.Cardinal[expVar.initialPC[i]];        IF (i # expVar.nEntries) THEN Print.Char[',];        ENDLOOP;      END;    Print.Cr[];    END;  PrintType: PROC [typi: BcdDefs.TYPIndex] =    {WriteType[typi]};  PrintNextType: PROC =    BEGIN    increment: CARDINAL ¬ SIZE[BcdDefs.TYPRecord];    VerifyBcdLoaded[];    IF (typeIndex + increment) >= LOOPHOLE[tyLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No type table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    WriteType[typi: LOOPHOLE[(typeIndex + increment), BcdDefs.TYPIndex]];    END;  WriteType: PROC [typi: BcdDefs.TYPIndex] =    BEGIN  OPEN type: tyb[typi];    VerifyBcdLoaded[];    typeIndex ¬ LOOPHOLE[typi, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: typeIndexParamIndex];    IF LOOPHOLE[tyLimit, CARDINAL] = 0 OR        LOOPHOLE[typi, CARDINAL] >= LOOPHOLE[tyLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of type table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;      Print.Text["Type"L];     Print.Index[index: typi, nullIndex: BcdDefs.TYPNull];    IF typi # BcdDefs.TYPNull THEN      BEGIN      Print.Text[" id: "L];  Print.Cardinal[type.id];      Print.Text[", from: "L];  Print.Version[type.version];      END;    Print.Cr[];    END;  PrintTypeMp: PROC [tmi: BcdDefs.TMIndex] =    {WriteTypeMp[tmi]};  PrintNextTypeMp: PROC =    BEGIN    increment: CARDINAL = SIZE[BcdDefs.TMRecord];    VerifyBcdLoaded[];    IF (typeMpIndex + increment) >= LOOPHOLE[tmLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No type map table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    WriteTypeMp[tmi: LOOPHOLE[(typeMpIndex + increment), BcdDefs.TMIndex]];    END;  WriteTypeMp: PROC [tmi: BcdDefs.TMIndex] =    BEGIN  OPEN typeMap: tmb[tmi];    VerifyBcdLoaded[];    typeMpIndex ¬ LOOPHOLE[tmi, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: typeMpIndexParamIndex];    IF LOOPHOLE[tmLimit, CARDINAL] = 0 OR        LOOPHOLE[tmi, CARDINAL] >= LOOPHOLE[tmLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of type map table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;      Print.Text["Type map"L];     Print.Index[index: tmi, nullIndex: BcdDefs.TMNull];    IF tmi # BcdDefs.TMNull THEN      BEGIN      Print.Text[" entry: "L];  Print.Cardinal[typeMap.offset];      Print.Text[", in: "L];  Print.Version[typeMap.version];      Print.NextIndex[        s: "mapped to"L, index: typeMap.map, nullIndex: BcdDefs.TMNull];      END;      Print.Cr[];    END;          PrintAtom: PROC [ati: BcdDefs.ATIndex] =    {WriteAtom[ati]};  PrintNextAtom: PROC =    BEGIN    atom: BcdOps.ATHandle = @atb[LOOPHOLE[atomIndex, BcdDefs.ATIndex]];    increment: CARDINAL = SIZE[BcdDefs.ATRecord] +       (atom.nAtoms * SIZE[BcdDefs.NameRecord]);    VerifyBcdLoaded[];    IF (atomIndex + increment) >= LOOPHOLE[atLimit, CARDINAL] THEN      BEGIN      Print.Complaint["No atom table entries remain"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;    WriteAtom[ati: LOOPHOLE[(atomIndex + increment), BcdDefs.ATIndex]];    END;  WriteAtom: PROC [ati: BcdDefs.ATIndex] =    BEGIN  OPEN atom: atb[ati];    VerifyBcdLoaded[];    atomIndex ¬ LOOPHOLE[ati, CARDINAL];    FormSW.DisplayItem[      sw: BcdToolWindows.formSW, index: atomIndexParamIndex];    IF LOOPHOLE[atLimit, CARDINAL] = 0 OR        LOOPHOLE[ati, CARDINAL] >= LOOPHOLE[atLimit, CARDINAL] THEN      BEGIN      Print.Complaint["Index is beyond end of atom table"L];      UserTerminal.BlinkDisplay[];      ERROR cancelAction;      END;      Print.Text["Atom Record: "L];     Print.Index[index: ati, nullIndex: BcdDefs.ATNull];    IF ati # BcdDefs.ATNull THEN      BEGIN       Print.Text[" offset = "L];      Print.Cardinal[atom.offset];      Print.Text[" nAtoms = "L];      Print.Cardinal[atom.nAtoms];      Print.Text[" atom seq: "L];      FOR i: CARDINAL IN [0..atom.nAtoms) DO	Print.Cardinal[atom[i]];	Print.Text[", "L];	ENDLOOP;      END;    Print.Cr[];    END;  END.
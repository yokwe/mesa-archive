-- File: BcdToolSourceBcdImpl.mesa - created by Lewis. Last edit:-- JKF                  6-Mar-86 14:55:37-- Lewis,	 3-Dec-80 17:54:57-- Bruce,	21-Sep-81 10:38:29-- Sweet,	18-Jan-82 12:02:06-- Haynes,	29-Nov-82 20:29:09-- Copyright (C) 1980, 1981, 1982, 1983, 1986 by Xerox Corporation. All rights reserved. DIRECTORY  BcdDefs USING [BCD, NameRecord, VersionID],  BcdToolSourceBcd,  Heap USING [systemZone],  MFile USING [Acquire, Error],  MSegment USING [Address, Create, Delete, Handle, Reset],  String USING [SubString];BcdToolSourceBcdImpl: PROGRAM    IMPORTS Heap, MFile, MSegment    EXPORTS BcdToolSourceBcd =  BEGIN  UnknownBcdFile: PUBLIC ERROR = CODE;  IncompatibleVersion: PUBLIC ERROR = CODE;  -- Bcd has incompatible version  bcdBases:  PUBLIC LONG POINTER TO BcdToolSourceBcd.BcdBaseRec ¬ NIL;  bcdLimits: PUBLIC LONG POINTER TO BcdToolSourceBcd.BcdLimitRec ¬ NIL;  bcdHeader: PUBLIC LONG POINTER TO BcdDefs.BCD ¬ NIL;  bcdLoaded: BOOLEAN ¬ FALSE;  bcdSegment: MSegment.Handle ¬ NIL;  Load: PUBLIC PROC [bcdFileName: LONG STRING] =    BEGIN    pages: CARDINAL;    bcdSegment ¬ MSegment.Create[      file: MFile.Acquire[bcdFileName, readOnly, []        ! MFile.Error => ERROR UnknownBcdFile],       release: [], fileBase: 0, pages: 1];    bcdHeader ¬ bcdSegment.Address[];    IF bcdHeader.versionIdent # BcdDefs.VersionID THEN      BEGIN      bcdSegment.Delete[];      bcdSegment ¬ NIL; bcdHeader ¬ NIL;      ERROR IncompatibleVersion;      END;    IF (pages ¬ bcdHeader.nPages) # 1 THEN { -- load entire Bcd      bcdSegment.Reset[pages: pages]; bcdHeader ¬ bcdSegment.Address[]};    bcdBases ¬ Heap.systemZone.NEW[BcdToolSourceBcd.BcdBaseRec ¬         [ctb: LOOPHOLE[bcdHeader + bcdHeader.ctOffset],         mtb: LOOPHOLE[bcdHeader + bcdHeader.mtOffset],         etb: LOOPHOLE[bcdHeader + bcdHeader.expOffset],         itb: LOOPHOLE[bcdHeader + bcdHeader.impOffset],         sgb: LOOPHOLE[bcdHeader + bcdHeader.sgOffset],         ftb: LOOPHOLE[bcdHeader + bcdHeader.ftOffset],         ssb: LOOPHOLE[bcdHeader + bcdHeader.ssOffset],         enb: LOOPHOLE[bcdHeader + bcdHeader.enOffset],         spb: LOOPHOLE[bcdHeader + bcdHeader.spOffset],         ntb: LOOPHOLE[bcdHeader + bcdHeader.ntOffset],         tyb: LOOPHOLE[bcdHeader + bcdHeader.typOffset],         tmb: LOOPHOLE[bcdHeader + bcdHeader.tmOffset],         fpb: LOOPHOLE[bcdHeader + bcdHeader.fpOffset],	 lfb: LOOPHOLE[bcdHeader + bcdHeader.lfOffset],	 atb: LOOPHOLE[bcdHeader + bcdHeader.atOffset]] ];    bcdLimits ¬ Heap.systemZone.NEW[BcdToolSourceBcd.BcdLimitRec ¬        [ct: bcdHeader.ctLimit,         sg: bcdHeader.sgLimit,         ft: bcdHeader.ftLimit,         en: bcdHeader.enLimit,         mt: bcdHeader.mtLimit,         et: bcdHeader.expLimit,         it: bcdHeader.impLimit,         nt: bcdHeader.ntLimit,         sp: bcdHeader.spLimit,         ty: bcdHeader.typLimit,         tm: bcdHeader.tmLimit,         fp: bcdHeader.fpLimit,         ss: bcdHeader.ssLimit,	 lf: bcdHeader.lfLimit,	 at: bcdHeader.atLimit] ];    bcdLoaded ¬ TRUE;    END;  Unload: PUBLIC PROC =    BEGIN    IF bcdSegment = NIL THEN RETURN;    bcdSegment.Delete[];    bcdSegment ¬ NIL;  bcdHeader ¬ NIL;    Heap.systemZone.FREE[@bcdBases];  Heap.systemZone.FREE[@bcdLimits];    bcdLoaded ¬ FALSE;    END;  IsLoaded: PUBLIC PROC RETURNS[reply: BOOLEAN] =    {RETURN[bcdLoaded]};  SubStringForName: PUBLIC PROC [      ss: String.SubString, name: BcdDefs.NameRecord] =    BEGIN    ss.base ¬ @bcdBases.ssb.string;    IF name > ss.base.length OR (name + bcdBases.ssb.size[name]) > ss.base.length THEN      BEGIN      ss.base ¬ "(out of range)";      ss.offset ¬ 0;  ss.length ¬ ss.base.length;      END    ELSE      {ss.offset ¬ name;  ss.length ¬ bcdBases.ssb.size[name]};    END;  END.
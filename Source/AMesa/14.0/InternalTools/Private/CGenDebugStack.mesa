-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CGenDebugStack.mesa-- Edited by Sweet,  9-Jul-83  0:06:50DIRECTORY  CGenDebugDefs USING [GetFrameName, StackBottom, StackState],  CodeDefs USING [CCNull, codeType, StackBackup, StackIndex, StackItem, StackNull],  DebugUsefulDefs USING [LongCopyREAD],  RESOut USING [    Complain, PCr, PDecimal, PNext, PNextNull,     PNull, PString],  STDebugDefs USING [showLinks, TableBase],  String USING [AppendChar, AppendDecimal, AppendString],  Symbols USING [ContextLevel],  Table USING [Base];CGenDebugStack: PROGRAM   IMPORTS CGenDebugDefs, DebugUsefulDefs, RESOut, STDebugDefs, String  EXPORTS CGenDebugDefs =  BEGIN OPEN CodeDefs, CGenDebugDefs, RESOut;  PutStackState: PUBLIC PROCEDURE =    BEGIN OPEN CodeDefs;    sip: StackIndex;    sir: StackItem;    cb: Table.Base = STDebugDefs.TableBase[codeType];    first: BOOLEAN ¬ TRUE;    name: STRING ¬ [30];    PCr[];    PString["Stack["]; PString[IF StackState[] THEN "ON"L ELSE "OFF"L];    PString["]: "L];    sip ¬ StackBottom[];    IF sip = StackNull THEN      BEGIN PString["empty"L]; RETURN END;    WHILE sip # StackNull DO      name.length ¬ 0;      DebugUsefulDefs.LongCopyREAD[to: @sir, from: @cb[sip],	nwords: SIZE[StackItem]];      BEGIN OPEN String;      AppendChar[name, '(]; AppendDecimal[name, LOOPHOLE[sip]];      AppendString[name, ") "L];      END;      WITH sir SELECT FROM	mark => String.AppendString[name, "Mark"L];	data =>	  IF loaded THEN String.AppendString[name, "OnStk"L]	  ELSE WITH bb: backup SELECT FROM	    frame => GetFrameName[s: name, level: bb.tLevel, wd: bb.tOffset, wSize: 1];	<<    link => 	      BEGIN OPEN String;	      AppendString[name, "LK "L];	      AppendDecimal[name,  bb.link];	      END;	>>	    const => 	      BEGIN OPEN String;	      AppendChar[name, '=];	      AppendDecimal[name, bb.value];	      AppendChar[name, '=];	      END;	    ENDCASE;	ENDCASE;      IF first THEN	BEGIN PString[name]; first ¬ FALSE; END      ELSE PNext[name];      sip ¬ sir.uplink;      ENDLOOP;    END;  lastSti: StackIndex ¬ StackNull;  PutAsStack: PUBLIC PROCEDURE [sti: StackIndex] =    BEGIN    sir: StackItem;    cb: Table.Base = STDebugDefs.TableBase[codeType];    backupName: STRING ¬ [30];        IF sti = StackNull THEN RETURN;    lastSti ¬ sti;    DebugUsefulDefs.LongCopyREAD[to: @sir, from: @cb[sti],      nwords: SIZE[StackItem]];    PCr[];    PString["cb["L]; PDecimal[LOOPHOLE[sti]]; PString["] - "L];    IF sir.free THEN PString["FREE!"L]    ELSE      WITH sir SELECT FROM	mark =>	  BEGIN	  PString["mark - label: "L];	  PNull[label, CCNull];	  END;	data =>	  BEGIN	  IF loaded THEN PString["onStack"L]	  ELSE PString["offStack"L];	  IF backup.where # none THEN 	    BEGIN	    GetBackup[backupName, backup];	    PNext[backupName];	    END;	  END;        ENDCASE;    IF STDebugDefs.showLinks THEN      BEGIN      PNextNull["downlink"L, sir.downlink, StackNull];      PNextNull["uplink"L, sir.uplink, StackNull];      END;    END;  GetBackup: PUBLIC PROC [s: LONG STRING, backup: StackBackup] =    BEGIN OPEN String;    Alias: PROCEDURE [wd: CARDINAL, lvl: Symbols.ContextLevel] =      BEGIN OPEN String;      AppendString[s, " ("L];      GetFrameName[s: s, wd: wd, level: lvl, wSize: 1];      AppendChar[s, ')];      END;    s.length ¬ 0;    WITH bb: backup SELECT FROM      frame =>	BEGIN	AppendString[s, "frame[tOff:"L]; AppendDecimal[s, bb.tOffset];	AppendString[s, ", tLvl:"L]; AppendDecimal[s, bb.tLevel];	AppendChar[s, ']];	Alias[bb.tOffset, bb.tLevel];	END;     << link =>	BEGIN	AppendString[s, "link["L]; AppendDecimal[s, bb.link];	AppendChar[s, ']];	END;      >>      const =>	BEGIN	AppendString[s, "const["L]; AppendDecimal[s, bb.value];	AppendChar[s, ']];	END;      none => AppendString[s, "none[]"L];      ENDCASE;          END;  PutStackDown: PUBLIC PROCEDURE =    BEGIN    sir: StackItem;    cb: Table.Base = STDebugDefs.TableBase[codeType];    IF lastSti = StackNull THEN GO TO invalid;    DebugUsefulDefs.LongCopyREAD[to: @sir, from: @cb[lastSti],      nwords: SIZE[StackItem]];    IF sir.free THEN GO TO invalid    ELSE PutAsStack[sir.downlink];    EXITS      invalid =>        RESOut.Complain["no valid last stack index"L];    END;  PutStackUp: PUBLIC PROCEDURE =    BEGIN    sir: StackItem;    cb: Table.Base = STDebugDefs.TableBase[codeType];    IF lastSti = StackNull THEN GO TO invalid;    DebugUsefulDefs.LongCopyREAD[to: @sir, from: @cb[lastSti],      nwords: SIZE[StackItem]];    IF sir.free THEN GO TO invalid    ELSE PutAsStack[sir.uplink];    EXITS      invalid =>        RESOut.Complain["no valid last stack index"L];    END;  END.
-- Copyright (C) 1982, 1984, 1987  by Xerox Corporation. All rights reserved. -- CGenDebugCC.mesa, Last Edited by:-- Haynes,	29-Nov-82 20:19:55-- Sweet,	27-Apr-84 17:20:39-- JBD		14-Jan-87 14:13:00DIRECTORY  AllocOps,    Ascii USING [SP],  CGenDebugDefs USING [],  CodeDefs USING [    CCIndex, CCInfoType, CCItem, CCNull, codeType, EINull, JumpType],  DebugUsefulDefs USING [LongCopyREAD],  MopOps,  OpTableDefs USING [InstLength],  P5 USING [NumberOfParams],  RESOut USING [    PChar, PCr, PDecimal, PNext, PNextNull, PNextUnsigned, PNull, POctal,     PString, PUnsigned],  STDebugDefs USING [showLinks, TableBase],  Table USING [Base];CGenDebugCC: PROGRAM   IMPORTS STDebugDefs, DebugUsefulDefs, MopOps, OpTableDefs, P5, RESOut  EXPORTS CGenDebugDefs =  BEGIN OPEN CodeDefs, CGenDebugDefs, RESOut;    FCPtr: TYPE = POINTER TO AllocOps.Chunk;  PutAsFopcode: PUBLIC PROCEDURE [n: CARDINAL] =    BEGIN    PCr[];    PDecimal[n];    PString[" = q"L];    MopOps.PutFopcode[PString, n];    RETURN    END;  WriteFOpName: PUBLIC PROCEDURE [n: CARDINAL] =    BEGIN    PChar['q];    MopOps.PutFopcode[PString, n];    END;  WriteMOpName: PROCEDURE [n: CARDINAL] =    BEGIN    PChar['z];    MopOps.PutMopcode[PString, n];    RETURN    END;  FullCCSize: CARDINAL = MAX[    SIZE[CCItem], SIZE[code CCItem]+3];  FullCC: TYPE = ARRAY [0..FullCCSize) OF UNSPECIFIED;  ccInfo: PUBLIC CodeDefs.CCInfoType ¬ generating;  current: CodeDefs.CCIndex ¬ CodeDefs.CCNull;  PutNextCC: PUBLIC PROCEDURE =    BEGIN    fc: FullCC;    cbc: POINTER TO CodeDefs.CCItem = LOOPHOLE[@fc];    cb: Table.Base = STDebugDefs.TableBase[CodeDefs.codeType];    next: CodeDefs.CCIndex;    IF current = CodeDefs.CCNull THEN RETURN;    DebugUsefulDefs.LongCopyREAD[      to: @fc,      from: @cb[current],      nwords: FullCCSize];    IF cbc.free THEN next ¬ LOOPHOLE[LOOPHOLE[cbc, FCPtr].fLink]    ELSE next ¬ cbc.flink;    IF next # CodeDefs.CCNull THEN      PutAsCC[next];    END;  PutPrevCC: PUBLIC PROCEDURE =    BEGIN    fc: FullCC;    cbc: POINTER TO CodeDefs.CCItem = LOOPHOLE[@fc];    cb: Table.Base = STDebugDefs.TableBase[CodeDefs.codeType];    prev: CodeDefs.CCIndex;    IF current = CodeDefs.CCNull THEN RETURN;    DebugUsefulDefs.LongCopyREAD[      to: @fc,      from: @cb[current],      nwords: FullCCSize];    IF cbc.free THEN prev ¬ LOOPHOLE[LOOPHOLE[cbc, FCPtr].bLink]    ELSE prev ¬ cbc.blink;    IF prev # CodeDefs.CCNull THEN      PutAsCC[prev];    END;  GoFwd: PUBLIC PROCEDURE [n: INTEGER] =    BEGIN    fc: FullCC;    cbc: POINTER TO CodeDefs.CCItem = LOOPHOLE[@fc];    cb: Table.Base = STDebugDefs.TableBase[CodeDefs.codeType];    next: CodeDefs.CCIndex;    IF current = CodeDefs.CCNull THEN RETURN;    THROUGH [0..n) DO      DebugUsefulDefs.LongCopyREAD[        to: @fc,        from: @cb[current],        nwords: FullCCSize];      IF cbc.free THEN next ¬ LOOPHOLE[LOOPHOLE[cbc, FCPtr].fLink]      ELSE next ¬ cbc.flink;      IF next = CodeDefs.CCNull THEN EXIT;      PutAsCC[next];      ENDLOOP;    END;  PutRecentCC: PUBLIC PROCEDURE [n: INTEGER] =    BEGIN    fc: FullCC;    cbc: POINTER TO CodeDefs.CCItem = LOOPHOLE[@fc];    cb: Table.Base = STDebugDefs.TableBase[CodeDefs.codeType];    c: CCIndex ¬ current;    k: CARDINAL ¬ 0;    prev: CodeDefs.CCIndex;    IF n = 0 OR c = CodeDefs.CCNull THEN RETURN;    THROUGH (0..n) DO      DebugUsefulDefs.LongCopyREAD[        to: @fc,        from: @cb[c],        nwords: FullCCSize];      IF cbc.free THEN prev ¬ LOOPHOLE[LOOPHOLE[cbc, FCPtr].bLink]      ELSE prev ¬ cbc.blink;      IF prev = CodeDefs.CCNull THEN EXIT;      k ¬ k+1;      c ¬ prev;      ENDLOOP;    PutAsCC[c];    IF k # 0 THEN GoFwd[k];    END;  PutAsCC: PUBLIC PROCEDURE [index: CodeDefs.CCIndex] =    BEGIN    fc: FullCC;    cbc: POINTER TO CodeDefs.CCItem = LOOPHOLE[@fc];    cb: Table.Base ¬ STDebugDefs.TableBase[CodeDefs.codeType];    DebugUsefulDefs.LongCopyREAD[      to: @fc,      from: @cb[index],      nwords: FullCCSize];    current ¬ index;    PCr[];    PDecimal[LOOPHOLE[index]];    PString[":	"L];    IF cbc.free THEN      BEGIN      PString["FREE - size: "L];      PUnsigned[LOOPHOLE[cbc, FCPtr].size];      END    ELSE WITH cc:cbc SELECT FROM      label =>        BEGIN        PString["Lbl - "L];        WITH cc SELECT ccInfo FROM           generating =>             BEGIN	    PString["jlist: "L];	    PNull[jumplist, CCNull];	    IF cc.labelseen THEN PNext["seen"L,,10];	    IF cc.catch THEN PNext["catch"L,,10];	    IF cc.procEntry THEN PNext["procEntry"L,,10];	    IF cc.ei # EINull THEN PNextUnsigned["enable"L, cc.ei, 10];	    END;          binding =>            BEGIN            PString["minPC: "L]; PUnsigned[minPC];            PNextUnsigned["maxPC"L, maxPC, 10];            END;          coding =>            BEGIN            PString["pc: "L]; PUnsigned[pc];            END;          ENDCASE;	IF cc.offsetLoaded THEN PNext["offsetLoaded"L,,10];        END;      jump =>        BEGIN        WriteJumpName[cc.jtype];	PChar[Ascii.SP];         PNull[cc.destlabel, CCNull];	IF cc.forward THEN PNext["fwd"L,,10];	IF cc.fixedup THEN PNext["fixed"L,,10];	IF cc.completed THEN PNext["complete"L,,10];	PNextUnsigned["jsize"L, cc.jsize, 10]; 	IF cc.jparam # 0 THEN PNextUnsigned["param"L, cc.jparam, 10];         WITH cc SELECT ccInfo FROM           generating => {	    PNextNull["thread"L, thread, CCNull, 10];	    IF cc.ei # EINull THEN PNextUnsigned["enable"L, cc.ei, 10]};          binding =>            BEGIN            PNextUnsigned["minPC"L, minPC, 10];            PNextUnsigned["maxPC"L, maxPC, 10];            END;          coding => PNextUnsigned["pc"L, pc, 10];          ENDCASE;        END;      code =>        BEGIN        np: CARDINAL = IF ~cc.realinst THEN P5.NumberOfParams[cc.inst] 	               ELSE MAX[(IF cc.isize # 0 THEN cc.isize			 ELSE OpTableDefs.InstLength[cc.inst]), 1]-1;        i: CARDINAL;        IF cc.realinst THEN WriteMOpName[cc.inst]         ELSE WriteFOpName[cc.inst];        IF np # 0 THEN	  BEGIN	  PChar[Ascii.SP];          FOR i IN [1..np] DO            IF i # 1 THEN PString[", "L];            POctal[cc.parameters[i]];            ENDLOOP;	  END;        IF cc.isize # 0 THEN PNextUnsigned["size"L, cc.isize, 10];	IF cc.lco THEN PNext["lco"L,,10];        END;      other => WITH cc SELECT FROM        table => 	  BEGIN	  PString["Table - offset: "L];	  POctal[taboffset];	  IF btab THEN PNext["btab"L,,10];	  PNextUnsigned["tableSize"L, tableSize, 10];	  END;        markbody =>          BEGIN          PString[IF start THEN "Start"L ELSE "End"L];          PString["Body, bti: "L];          PUnsigned[LOOPHOLE[index]];          END;        markEnable =>          BEGIN          PString[IF start THEN "Start"L ELSE "End"L];          PString["Enable, index: "L];          PUnsigned[LOOPHOLE[index]];          END;        source => 	  BEGIN	  PString["Source: "L];	  POctal[index];	  END;        localCall => 	  BEGIN	  PString["localCall: "L];	  POctal[target];	  END;        ENDCASE;      ENDCASE;    IF STDebugDefs.showLinks THEN      BEGIN      PNextNull[	"blink"L, 	IF cbc.free THEN LOOPHOLE[cbc, FCPtr].bLink ELSE LOOPHOLE[cbc.blink], 	CCNull, 	10];      PNextNull[	"flink"L, 	IF cbc.free THEN LOOPHOLE[cbc, FCPtr].fLink ELSE LOOPHOLE[cbc.flink], 	CCNull, 	10];      END;    END;  WriteJumpName: PROCEDURE[n: CodeDefs.JumpType] =    BEGIN OPEN CodeDefs;    JumpName: ARRAY JumpType OF STRING = [	"JumpE"L, "JumpN"L, "JumpL"L, "JumpGE"L, "JumpG"L, "JumpLE"L,	"UJumpL"L, "UJumpGE"L, "UJumpG"L, "UJumpLE"L, "ZJumpE"L, "ZJumpN"L,	"Jump"L, "JumpA"L, "JumpEnable"L, "JumpC"L, "JumpCA"L, "JumpRet"L,	"BYTEJumpE"L, "BYTEJumpN"L, "JumpLIO"L, "JumpDESC"L];    IF n > LAST[JumpType] THEN      BEGIN PChar['j]; PDecimal[LOOPHOLE[n]] END    ELSE PString[JumpName[n]];  RETURN    END;  END.
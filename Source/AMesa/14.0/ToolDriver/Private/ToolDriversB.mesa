-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- ToolDriversB.mesa - last edit: -- Mark		Nov 7, 1980 11:49 PM-- Mike		14-Jan-82 10:53:39-- RXJ     	12-Nov-82  8:32:56-- RXR   	 5-Jan-83 15:05:14DIRECTORY  Ascii USING [CR],  CmFile USING [ReadLineOrToken, TitleMatch],  Heap USING [MakeNode, systemZone],  Inline USING [LongCOPY],  MFile USING [Acquire, Error, Handle, ReleaseData],  MStream USING [Create, EndOf, ReleaseData],  Scan USING [CharFilterProcType],  Stream USING [GetChar, SetPosition],  String USING [CopyToNewString, EquivalentString, SubStringDescriptor],  StringExtra USING [NextFilteredStringInSS],  Token USING [Object, Handle],  ToolDriver USING [AddressDescriptor, ToolID],  ToolDriverOps USING [    ErrorCode, registryStream, SequenceFromID, SubwindowSequence,     SubwindowSequenceObject],  ToolWindow USING [WindowForSubwindow],  Window USING [Handle];  ToolDriversB: PROGRAM  IMPORTS    CmFile, Heap, Inline, MFile, MStream, Stream, String, StringExtra,    ToolDriverOps, ToolWindow  EXPORTS ToolDriverOps =  BEGIN  -- Global data and TYPEs  ToolEntry: TYPE = RECORD [    tool, sw: LONG STRING,    id: ToolDriver.ToolID,    handle: Window.Handle,    swNames: LONG DESCRIPTOR FOR ARRAY OF LONG STRING,    sws: ToolDriverOps.SubwindowSequence];  lastTool: ToolEntry ¬ [NIL, NIL, ----, NIL, DESCRIPTOR[NIL, 0], ----];  -- SIGNALs  Error: PUBLIC SIGNAL [code: ToolDriverOps.ErrorCode, msg: LONG STRING] = CODE;  -- Interface PROCEDUREs  GetCharForReadLineOrToken: PROCEDURE[Token.Handle] RETURNS[c: CHARACTER] = {RETURN[Stream.GetChar[ToolDriverOps.registryStream]]};      FindToolID: PUBLIC PROCEDURE [tool: LONG STRING]    RETURNS [ToolDriver.ToolID] =    BEGIN OPEN Stream, ToolDriverOps;    sectionCount: CARDINAL ¬ 0;    buffer: STRING ¬ [100];    mfH: MFile.Handle ¬ NIL;    readLineOrTokenObject: Token.Object;        GetStream: PROCEDURE =      BEGIN      msrD: MStream.ReleaseData ¬ [];      mfrD: MFile.ReleaseData ¬ [];      mfH ¬ MFile.Acquire["Tool.sws"L, readOnly, mfrD !MFile.Error =>        ERROR Error[noToolSWsFile, "File Tool.sws missing!"L]];      registryStream ¬ MStream.Create[mfH, msrD];      END; -- of GetStream        IF registryStream = NIL THEN GetStream[];     SetPosition[registryStream, 0];    readLineOrTokenObject.getChar ¬ GetCharForReadLineOrToken;    WHILE ~MStream.EndOf[registryStream] DO      CmFile.ReadLineOrToken[@readLineOrTokenObject, buffer, Ascii.CR];      IF buffer.length # 0 AND buffer[0] = '[ THEN	BEGIN	IF CmFile.TitleMatch[buffer, tool] THEN	RETURN[sectionCount];	sectionCount ¬ sectionCount + 1;	END;      ENDLOOP;    ERROR Error[noSuchTool, NIL];    END;            FindSubwindow: PUBLIC PROCEDURE [tool, sw: LONG STRING]    RETURNS [Window.Handle] =    BEGIN    i: CARDINAL;    CheckCache[tool ! Error => IF code # noToolSWsFile THEN GOTO NoTool];    -- Now check for a hit on the sw    IF lastTool.sw # NIL THEN      IF String.EquivalentString[lastTool.sw, sw] THEN	RETURN[lastTool.handle]  -- a hit!      ELSE Heap.systemZone.FREE[@lastTool.sw];    IF BASE[lastTool.swNames] = NIL OR lastTool.sws = NIL THEN RETURN[NIL];    FOR i IN [0..LENGTH[lastTool.swNames]) DO      IF String.EquivalentString[lastTool.swNames[i], sw] THEN	BEGIN	lastTool.sw ¬ String.CopyToNewString[sw, Heap.systemZone];	RETURN[(lastTool.handle ¬ lastTool.sws.subwindows[i])];	END;      ENDLOOP;    RETURN[NIL];    EXITS      NoTool => RETURN[NIL];    END;      FindWindow: PUBLIC PROCEDURE [tool: LONG STRING]    RETURNS [w: Window.Handle, toolRegistered: BOOLEAN ¬ TRUE] =    BEGIN    CheckCache[tool ! Error => IF code # noToolSWsFile THEN GOTO NoTool];    RETURN[      IF BASE[lastTool.swNames] = NIL OR lastTool.sws = NIL THEN NIL      ELSE ToolWindow.WindowForSubwindow[lastTool.sws.subwindows[0]] ];    EXITS      NoTool => RETURN[NIL, FALSE];    END;      FlushLastToolCache: PUBLIC PROCEDURE =    BEGIN    FreeSubwindowNames[lastTool.swNames];    lastTool.swNames ¬ DESCRIPTOR[NIL, 0];    Heap.systemZone.FREE[@lastTool.tool];    Heap.systemZone.FREE[@lastTool.sw];    lastTool.sws ¬ NIL;    END;      MakeSubwindowSequence: PUBLIC PROCEDURE [    subwindows: ToolDriver.AddressDescriptor]    RETURNS [sws: ToolDriverOps.SubwindowSequence] =    BEGIN    i, j, count: CARDINAL;    names: LONG DESCRIPTOR FOR ARRAY OF LONG STRING ¬ LoadSubwindowNames[];    IF BASE[names] = NIL THEN RETURN[NIL];    -- Verify the registry does not contain unknown names.    FOR i IN [0..LENGTH[names]) DO      FOR j IN [0..LENGTH[subwindows]) DO	IF String.EquivalentString[names[i], subwindows[j].name] THEN EXIT;	REPEAT FINISHED => ERROR Error[unknownName, NIL];	ENDLOOP;      ENDLOOP;    -- Ordering of FOR's is important.  If tool provides "abcdef" and user    --   provided "cfd", entries must be in order "cfd", not "cdf".    count ¬ 0;    FOR i IN [0..LENGTH[names]) DO      FOR j IN [0..LENGTH[subwindows]) DO	IF String.EquivalentString[names[i], subwindows[j].name] THEN	  {count ¬ count + 1; EXIT};	ENDLOOP;      ENDLOOP;    IF count = 0 THEN RETURN[NIL];    sws ¬ Heap.MakeNode[Heap.systemZone,      SIZE[ToolDriverOps.SubwindowSequenceObject]+(count*SIZE[Window.Handle])];    sws.length ¬ count;    count ¬ 0;    -- Must match order of FOR's above.    FOR i IN [0..LENGTH[names]) DO      FOR j IN [0..LENGTH[subwindows]) DO	IF String.EquivalentString[names[i], subwindows[j].name] THEN	  BEGIN	  sws.subwindows[count] ¬ subwindows[j].sw;	  count ¬ count + 1;	  EXIT;	  END;	ENDLOOP;      ENDLOOP;    END;    -- Utilities  CheckCache: PROCEDURE [tool: LONG STRING] =    -- Make sure the right tool is loaded in the cache    BEGIN    IF lastTool.tool # NIL    AND ~String.EquivalentString[lastTool.tool, tool] THEN      BEGIN      Heap.systemZone.FREE[@lastTool.tool];      Heap.systemZone.FREE[@lastTool.sw];      END;    IF lastTool.tool = NIL THEN      BEGIN  -- replace cached entry      FreeSubwindowNames[lastTool.swNames];      lastTool.id ¬ FindToolID[tool !	UNWIND => lastTool.swNames ¬ DESCRIPTOR[NIL, 0]];      lastTool.swNames ¬ LoadSubwindowNames[];      lastTool.sws ¬ ToolDriverOps.SequenceFromID[lastTool.id];      lastTool.tool ¬ String.CopyToNewString[tool, Heap.systemZone];      END;    END;      LoadSubwindowNames: PUBLIC PROCEDURE    RETURNS [names: LONG DESCRIPTOR FOR ARRAY OF LONG STRING] =    -- Assumes that registryStream has been positioned by FindToolID    BEGIN OPEN ToolDriverOps;    temp: ARRAY [0..50) OF LONG STRING ¬ ALL[NIL];    length: CARDINAL ¬ 0;    buffer: STRING ¬ [100];    ss: String.SubStringDescriptor;    readLineOrTokenObject: Token.Object;        ValidSubwindowNameChar: Scan.CharFilterProcType =      BEGIN      RETURN[SELECT char FROM	IN ['0..'9], IN ['A..'Z], IN ['a..'z] => TRUE,	ENDCASE => FALSE];      END;          readLineOrTokenObject.getChar ¬ GetCharForReadLineOrToken;    WHILE ~MStream.EndOf[registryStream] DO      CmFile.ReadLineOrToken[@readLineOrTokenObject, buffer, Ascii.CR];      IF buffer.length = 0 THEN EXIT;      ss ¬ [base: buffer, offset: 0, length: buffer.length];      DO	IF (temp[length] ¬ StringExtra.NextFilteredStringInSS[	  @ss, ValidSubwindowNameChar]) = NIL THEN EXIT;	length ¬ length + 1;	ENDLOOP;      ENDLOOP;    IF length > 0 THEN      BEGIN      names ¬ DESCRIPTOR[Heap.MakeNode[Heap.systemZone, SIZE[LONG STRING]*length], length];      Inline.LongCOPY[	from: BASE[temp], to: BASE[names], nwords: SIZE[LONG STRING]*length];      END    ELSE names ¬ DESCRIPTOR[NIL, 0];    END;      FreeSubwindowNames: PUBLIC PROCEDURE [names: LONG DESCRIPTOR FOR ARRAY OF LONG STRING] =    BEGIN    i: CARDINAL;    p: LONG POINTER ¬ BASE[names];    IF p # NIL THEN      BEGIN      FOR i IN [0..LENGTH[names]) DO Heap.systemZone.FREE[@names[i]]; ENDLOOP;      Heap.systemZone.FREE[@p];      END;    END;    -- Mainline codeEND. -- of ToolDriversB
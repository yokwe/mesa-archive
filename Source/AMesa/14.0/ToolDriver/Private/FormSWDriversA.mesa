-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: FormSWDriversA.mesa - last edit:-- Mark		Jan 8, 1981 3:28 PM-- Mike		24-Feb-82 11:06:50-- RXJ     	11-Nov-82 18:05:48-- RXR   	18-Apr-83 14:35:51DIRECTORY  Ascii USING [NUL],  Cursor USING [Object, Fetch, GetInfo, Set, Store],  FormSW USING [    IndexFromEnumeratedValue, DisplayItem, EnumeratedHandle, FindItem,     ItemHandle, ItemObject, ModifyEditable, nullIndex],  FormSWDriver USING [    BuiltIn, BuiltInType, BuiltInValue, ErrorCode, ItemSpec, ItemSpecObject, KnownType,     SBuiltIn],  Heap USING [systemZone],  Inline USING [LongNumber],  String USING [    AppendDecimal, AppendOctal, AppendLongDecimal, AppendLongNumber,     CopyToNewString, Empty, EquivalentStrings, InvalidNumber,    StringToLongNumber, StringToNumber],  Token USING [Handle],  Window USING [Handle];  FormSWDriversA: PROGRAM  IMPORTS Cursor, FormSW, Heap, String  EXPORTS FormSWDriver =  BEGIN    -- SIGNALs  Error: PUBLIC SIGNAL [code: FormSWDriver.ErrorCode] = CODE;  TypeMismatch: PUBLIC SIGNAL [src, dest: FormSWDriver.KnownType] = CODE;  -- Conversion routines  BuiltInToString: PUBLIC PROCEDURE [    bi: FormSWDriver.BuiltIn, sbi: FormSWDriver.SBuiltIn] =    BEGIN    IF sbi.s # NIL AND sbi.inHeap THEN Heap.systemZone.FREE[@sbi.s];    sbi.s ¬ NIL; sbi.inHeap ¬ TRUE;    WITH variant: bi SELECT bi.type FROM      boolean =>	sbi.s ¬ String.CopyToNewString[IF variant.b THEN "TRUE"L ELSE "FALSE"L, Heap.systemZone];      cardinal =>	BEGIN	sbi.s ¬ Heap.systemZone.NEW[StringBody[10]];	String.AppendOctal[sbi.s, variant.c];	END;      character =>	IF variant.c # Ascii.NUL THEN	  {sbi.s ¬ Heap.systemZone.NEW[StringBody[1]]; sbi.s[0] ¬ variant.c; sbi.s.length ¬ 1};      empty => NULL;      integer =>	BEGIN	sbi.s ¬ Heap.systemZone.NEW[StringBody[10]];	String.AppendDecimal[sbi.s, variant.i];	END;      pointer =>	BEGIN	sbi.s ¬ Heap.systemZone.NEW[StringBody[10]];	String.AppendLongNumber[s: sbi.s, n: variant.p, radix: 8];	END;      string => sbi.s ¬ String.CopyToNewString[variant.s, Heap.systemZone];      unspecified =>	BEGIN	sbi.s ¬ Heap.systemZone.NEW[StringBody[10]];	String.AppendOctal[sbi.s, variant.u];	END;      longNumber =>	BEGIN	sbi.s ¬ Heap.systemZone.NEW[StringBody[20]];	String.AppendLongDecimal[sbi.s, variant.ln.li];	END;      longPointer =>	BEGIN	sbi.s ¬ Heap.systemZone.NEW[StringBody[20]];	String.AppendLongNumber[sbi.s, variant.lp, 8];	END;      ENDCASE => ERROR;    END;      StringToBuiltIn: PUBLIC PROCEDURE [    s: LONG STRING, inHeap: BOOLEAN, bi: FormSWDriver.BuiltIn] =    BEGIN    IF s = NIL THEN WITH variant: bi SELECT bi.type FROM      character, empty, string => NULL;      ENDCASE => ERROR TypeMismatch[src: string, dest: bi.type];    WITH variant: bi SELECT bi.type FROM      boolean => variant.b ¬ SELECT TRUE FROM	String.EquivalentStrings[s, "TRUE"L] => TRUE,	String.EquivalentStrings[s, "FALSE"L] => FALSE,	ENDCASE => ERROR TypeMismatch[src: string, dest: bi.type];      character =>	variant.c ¬ IF String.Empty[s] THEN Ascii.NUL ELSE s[0];      empty => NULL;      cardinal, integer, pointer, unspecified =>	BEGIN	u: UNSPECIFIED = String.StringToNumber[s, 10 !	  String.InvalidNumber => ERROR TypeMismatch[src: string, dest: bi.type]];	WITH variant: bi SELECT bi.type FROM	  cardinal => variant.c ¬ u;	  integer => variant.i ¬ u;	  pointer => variant.p ¬ u;	  unspecified => variant.u ¬ u;	  ENDCASE;	END;      string =>	BEGIN	IF inHeap THEN {variant.s ¬ s; inHeap ¬ FALSE}	ELSE variant.s ¬ String.CopyToNewString[s, Heap.systemZone];	variant.inHeap ¬ TRUE;	END;      longNumber => variant.ln.lu ¬ String.StringToLongNumber[s, 10 !	String.InvalidNumber => ERROR TypeMismatch[src: string, dest: bi.type]];      longPointer => variant.lp ¬ String.StringToLongNumber[s, 10 !	String.InvalidNumber => ERROR TypeMismatch[src: string, dest: bi.type]];      ENDCASE => ERROR TypeMismatch[src: string, dest: bi.type];    IF inHeap THEN Heap.systemZone.FREE[@s];    END;    -- FormSW utilities  BuiltInFromItem: PUBLIC PROCEDURE [    dest: FormSWDriver.BuiltIn, source: FormSW.ItemHandle] =    BEGIN    WITH sourceItem: source SELECT FROM      boolean => dest­ ¬ [type: boolean, body: boolean[b: sourceItem.switch­]];      command => dest.type ¬ empty;      enumerated =>	BEGIN	choiceString: LONG STRING ¬ NIL;	i: CARDINAL ¬ FormSW.IndexFromEnumeratedValue[@sourceItem];	IF i # FormSW.nullIndex THEN	  choiceString ¬ sourceItem.choices[i].string;	dest­ ¬ [type: string, body: string[s: choiceString, inHeap: FALSE]];	END;      longNumber =>	dest­ ¬ [type: longNumber, 	  body: longNumber[ln: Inline.LongNumber[lu[sourceItem.value­]]]];      number =>	dest­ ¬ [type: unspecified, body: unspecified[u: sourceItem.value­]];      string =>	dest­ ¬ [type: string, body: string[	  s: String.CopyToNewString[sourceItem.string­, Heap.systemZone], inHeap: TRUE]];      tagOnly =>	BEGIN	IF sourceItem.otherItem # FormSW.nullIndex THEN	  BEGIN	  otherSourceH: FormSW.ItemHandle ¬ FormSW.FindItem[	    sourceItem.sw, sourceItem.otherItem];	  BuiltInFromItem[dest, otherSourceH];	  END;	dest­ ¬ [type: string, body: string[s: NIL, inHeap: TRUE]];	END;      ENDCASE => GOTO Error;    EXITS      Error => ERROR TypeMismatch[src: BuiltInTypeForItemType[source], dest: dest.type];    END;      BuiltInTypeForItemType: PUBLIC PROCEDURE [source: FormSW.ItemHandle]    RETURNS [dest: FormSWDriver.BuiltInType] =    BEGIN    dest ¬ WITH sourceItem: source SELECT FROM      boolean => boolean,      command => empty,      enumerated => string,      longNumber => longNumber,      number => unspecified,      string => string,      tagOnly => BuiltInTypeForItemType[source],      ENDCASE => ERROR TypeMismatch[src: formSWItem, dest: unknown];    END;      ConvertBuiltIns: PUBLIC PROCEDURE [dest, source: FormSWDriver.BuiltIn] =    -- Do not call this if you already have the same dest and source types    BEGIN    WITH sourceVariant: source SELECT source.type FROM      string => StringToBuiltIn[sourceVariant.s, FALSE, dest];      ENDCASE =>	BEGIN	temp: FormSWDriver.BuiltInValue;	temp ¬ [type: string, body: string[s: NIL, inHeap: FALSE]];	WITH tempVariant: temp SELECT temp.type FROM	  string =>	    BEGIN	    BuiltInToString[source, @tempVariant];	    StringToBuiltIn[tempVariant.s, tempVariant.inHeap, dest];	    END;	  ENDCASE;	END;    END;      FindEnumVal: PUBLIC PROCEDURE [    eItem: FormSW.EnumeratedHandle, value: LONG STRING]    RETURNS [UNSPECIFIED] =    BEGIN    i: CARDINAL;    FOR i IN [0..LENGTH[eItem.choices]) DO      IF String.EquivalentStrings[eItem.choices[i].string, value] THEN	BEGIN RETURN[eItem.choices[i].value]; END;      ENDLOOP;    ERROR Error[noSuchEnumVal];    END;      FindFormSWItem: PUBLIC PROCEDURE [sw: Window.Handle, tag: LONG STRING]    RETURNS [item: FormSW.ItemHandle, index: CARDINAL] =    BEGIN    i: CARDINAL;    -- Do following if you decide not to raise the Error    -- item ¬ NIL; index ¬ FormSW.nullIndex;    FOR i ¬ 0, i+1 DO      IF (item ¬ FormSW.FindItem[sw, i]) = NIL THEN EXIT;      IF String.EquivalentStrings[item.tag, tag] THEN	BEGIN index ¬ i; RETURN; END;      ENDLOOP;    ERROR Error[noSuchItem];    END;      ModifyFormSWItem: PUBLIC PROCEDURE    [dest: FormSWDriver.ItemSpec, source: FormSWDriver.BuiltIn] =    BEGIN OPEN Cursor;    cursor: Object;    Fetch[@cursor];    Set[hourGlass];    WITH item: dest.item SELECT FROM      boolean =>	BEGIN	val: BOOLEAN ¬ WITH variant: source SELECT source.type FROM	  boolean => variant.b,	  ENDCASE => ERROR TypeMismatch[src: source.type, dest: boolean];	IF val # item.switch­ THEN	  BEGIN	  item.switch­ ¬ val;	  FormSW.DisplayItem[dest.sw, dest.index];	  item.proc[dest.sw, dest.item, dest.index];	  END;	END;      command =>	BEGIN	item.proc[dest.sw, dest.item, dest.index];	END;      enumerated =>	BEGIN	val: UNSPECIFIED ¬ WITH variant: source SELECT source.type FROM	  string => FindEnumVal[@item, variant.s],	  ENDCASE => ERROR TypeMismatch[src: source.type, dest: string];	oldValue: UNSPECIFIED ¬ item.value­;	IF val # oldValue THEN	  BEGIN	  item.value­ ¬ val;	  FormSW.DisplayItem[dest.sw, dest.index];	  item.proc[dest.sw, dest.item, dest.index, oldValue];	  END;	END;      longNumber =>	BEGIN	old: LONG UNSPECIFIED = item.value­;	item.value­ ¬ WITH variant: source SELECT source.type FROM	  longNumber => variant.ln.lu,	  cardinal => LONG[variant.c],	  integer => LONG[variant.i],	  unspecified => LONG[variant.u],	  ENDCASE => ERROR TypeMismatch[src: source.type, dest: formSWItem];	item.proc[dest.sw, @item, dest.index, old];	FormSW.DisplayItem[dest.sw, dest.index];	END;      number =>	BEGIN	old: UNSPECIFIED = item.value­;	item.value­ ¬ WITH variant: source SELECT source.type FROM	  longNumber => variant.ln.lowbits,	  cardinal => variant.c,	  integer => variant.i,	  unspecified => variant.u,	  ENDCASE => ERROR TypeMismatch[src: source.type, dest: formSWItem];	item.proc[dest.sw, @item, dest.index, old];	FormSW.DisplayItem[dest.sw, dest.index];	END;      string =>	BEGIN	WITH variant: source SELECT source.type FROM	  string => FormSW.ModifyEditable[	    dest.sw, dest.index, 0, LAST[CARDINAL], variant.s, FALSE];	  ENDCASE => ERROR TypeMismatch[src: source.type, dest: string];	END;      tagOnly =>	BEGIN	IF item.otherItem # FormSW.nullIndex THEN	  BEGIN	  otherItemSpecObject: FormSWDriver.ItemSpecObject;	  otherItemSpecObject.sw ¬ dest.sw;	  otherItemSpecObject.index ¬ item.otherItem;	  otherItemSpecObject.item ¬ FormSW.FindItem[	    dest.sw, item.otherItem];	  ModifyFormSWItem[@otherItemSpecObject, source];	  END;	END;      ENDCASE;    IF GetInfo[].type = hourGlass THEN      Store[@cursor];    END;      SetFormSWItem: PUBLIC PROCEDURE [formSW: Window.Handle, tag, value: LONG STRING] =    BEGIN    itemSpecObject: FormSWDriver.ItemSpecObject;    itemSpecObject.sw ¬ formSW;    [itemSpecObject.item, itemSpecObject.index] ¬ FindFormSWItem[formSW, tag];    SetItemFromString[@itemSpecObject, value];    END;      SetItemFromString: PUBLIC PROCEDURE [    dest: FormSWDriver.ItemSpec, value: LONG STRING] =    BEGIN    source: FormSWDriver.BuiltInValue;    source.type ¬ BuiltInTypeForItemType[dest.item];    StringToBuiltIn[s: value, inHeap: FALSE, bi: @source];    ModifyFormSWItem[dest, @source];    WITH variant: source SELECT source.type FROM      string => IF variant.inHeap THEN Heap.systemZone.FREE[@variant.s];      ENDCASE;    END;      SetItemFromItem: PUBLIC PROCEDURE [    dest: FormSWDriver.ItemSpec, source: FormSW.ItemHandle] =    BEGIN    bi: FormSWDriver.BuiltInValue;    BuiltInFromItem[dest: @bi, source: source];    SetItemFromValue[dest: dest, source: @bi];    WITH variant: bi SELECT bi.type FROM      string => IF variant.inHeap THEN Heap.systemZone.FREE[@variant.s];      ENDCASE;    END;      SetItemFromValue: PUBLIC PROCEDURE [    dest: FormSWDriver.ItemSpec, source: FormSWDriver.BuiltIn] =    BEGIN    target: FormSWDriver.BuiltInValue;    target.type ¬ BuiltInTypeForItemType[dest.item];    IF source.type = target.type THEN      ModifyFormSWItem[dest: dest, source: source]    ELSE      BEGIN      ConvertBuiltIns[dest: @target, source: source !	TypeMismatch => ERROR TypeMismatch[src: source.type, dest: target.type]];      ModifyFormSWItem[dest: dest, source: @target];      WITH variant: target SELECT target.type FROM	string => IF variant.inHeap THEN Heap.systemZone.FREE[@variant.s];	ENDCASE;      END;    END;      RunFormSW: PUBLIC PROCEDURE [    formSW: Window.Handle,    proc: PROCEDURE[Token.Handle] RETURNS [LONG STRING, LONG STRING],    handle: Token.Handle] =    BEGIN    tag, value: LONG STRING;    CleanupProc: PROCEDURE =      BEGIN      Heap.systemZone.FREE[@tag];      Heap.systemZone.FREE[@value];      END;    DO      [tag, value] ¬ proc[handle];      IF tag = NIL THEN RETURN;      SetFormSWItem[formSW, tag, value !UNWIND => CleanupProc[]];      CleanupProc[];      ENDLOOP;    END;    -- Main Line codeEND. -- of FormSWDriversA.mesa
-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- TDScanner.mesa - last edit:-- Mark		Mar 18, 1981 4:23 PM-- Mike		12-Jan-82 15:16:19-- RXJ     	12-Nov-82  8:31:52-- RES  	 4-Oct-83 13:16:06-- AXD    	27-Apr-84 17:49:15-- DWR    	26-Oct-84 11:25:32 fixed arrows but good-- Modified version of Compiler's Scanner.Mesa (on [Ivy]<CedarKernel>PDE>Compiler>)DIRECTORY  Ascii USING [ControlZ, CR, NUL, SP, TAB],  Environment USING [bytesPerPage, charsPerWord, wordsPerPage],  Format USING [Char, OctalFormat, Number, StringProc],  Heap USING [Prune, systemZone],  Inline USING [LowHalf],  MSegment USING[FreePages, GetPages],  MStream USING [EndOf],  ParseTable USING [    HashIndex, TSymbol, VocabHashEntry, --EndMarker,-- TableRef, tokenDELSTR,     tokenID, tokenNUM, tokenSCS],  Stream: TYPE USING [Block, Byte, CompletionCode, Handle, GetBlock, GetChar, GetPosition, SetPosition],  String USING [CopyToNewString, SubStringDescriptor],  StringExtra USING [StringFromSubString],  TDParseOps USING [Token];  TDScanner: PROGRAM    IMPORTS Format, Heap, Inline, MSegment, MStream, Stream, String, StringExtra     EXPORTS TDParseOps =  BEGIN  OPEN ParseTable;    hashTab: LONG POINTER TO ARRAY HashIndex OF VocabHashEntry;  scanTab: LONG POINTER TO ARRAY CHARACTER [40C..377C] OF TSymbol;  vocab: LONG STRING;  vocabIndex: LONG POINTER TO ARRAY TSymbol OF CARDINAL;    stream: Stream.Handle ¬ NIL;	-- the input stream  streamOrigin: LONG CARDINAL;    errorMsg: Format.StringProc;	-- for error logging    TextPages: CARDINAL = 6;  TextWords: CARDINAL = TextPages*Environment.wordsPerPage;   TextBytes: CARDINAL = TextPages*Environment.bytesPerPage;  TextChars: CARDINAL = TextWords*Environment.charsPerWord;    tC: LONG POINTER TO PACKED ARRAY [0..TextChars) OF CHARACTER;  tI, tMax: [0..TextChars];  tOrigin, tLimit: CARDINAL;  tEnded: BOOLEAN;    FillBuffer: PROC =    BEGIN    words: [0..TextWords];    bytes: [0..Environment.charsPerWord);    block: Stream.Block ¬ [LOOPHOLE[tC], 0, TextBytes];    tOrigin ¬ tLimit;    IF tEnded      THEN tMax ¬ 0      ELSE	BEGIN	words ¬ Stream.GetBlock[sH: stream, block: block].bytesTransferred / 2;	bytes ¬ Inline.LowHalf[Stream.GetPosition[stream]] MOD Environment.charsPerWord;	IF bytes # 0 THEN words ¬ words-1;	tMax ¬ words*Environment.charsPerWord + bytes;	IF tMax < TextChars THEN tEnded ¬ TRUE;	tLimit ¬ tOrigin + tMax;	END;    IF tMax = 0 THEN {tC[0] ¬ tC[1] ¬ '\\;  -- Compiler uses Ascii.NUL --  tMax ¬ 1};    tI ¬ 0;    END;      buffer: LONG STRING ¬ NIL;			-- token assembly area  iMax: CARDINAL;			-- iMax = buffer.maxlength  desc: String.SubStringDescriptor;	-- initial buffer segment    nTokens: CARDINAL;			-- token count  nErrors: CARDINAL;			-- lexical errors    BufferOverflow: ERROR = CODE;    ExpandBuffer: PROC =    BEGIN    IF buffer.length > 2000 THEN ERROR BufferOverflow;    desc.base ¬ buffer ¬ String.CopyToNewString[buffer, Heap.systemZone, buffer.length];    iMax ¬ buffer.length ¬ buffer.maxlength;    END;          char: CHARACTER;	-- current (most recently scanned) character  lastWasSemiColon: BOOLEAN ¬ FALSE;    NextChar: PROCEDURE = BEGIN InlineNextChar[]; END;    InlineNextChar: PROCEDURE = INLINE    BEGIN    IF (tI¬tI+1) = tMax THEN FillBuffer[];    char ¬ tC[tI];    END;      Atom: PUBLIC PROCEDURE RETURNS [token: TDParseOps.Token] =    BEGIN OPEN token;    -- Special hack to allow parser reset    IF lastWasSemiColon THEN      BEGIN      class ¬ tokenSCS;      lastWasSemiColon ¬ FALSE;      index ¬ tOrigin + tI;      RETURN;      END;    DO      -- Skip white space and Bravo looks      WHILE char IN [Ascii.NUL..Ascii.SP] 	DO	  SELECT char FROM	    Ascii.ControlZ =>	      UNTIL char = Ascii.CR DO		IF (tI¬tI+1) = tMax THEN		  {IF tEnded THEN GOTO EndFile; FillBuffer[]};		char ¬ tC[tI];		ENDLOOP;	    ENDCASE;	  IF (tI¬tI+1) = tMax THEN	    {IF tEnded THEN GOTO EndFile; FillBuffer[]};	  char ¬ tC[tI];	  ENDLOOP;      -- Now build token      index ¬ tOrigin + tI;  value ¬ 0;            BEGIN      SELECT char FROM      	'a, 'b, 'c, 'd, 'e, 'f, 'g, 'h, 'i, 'j, 'k, 'l, 'm,	'n, 'o, 'p, 'q, 'r, 's, 't, 'u, 'v, 'w, 'x, 'y, 'z  =>	  BEGIN	  i: CARDINAL;	  i ¬ 0;	    DO	    buffer[i] ¬ char;	    InlineNextChar[];	    SELECT char FROM	      IN ['a..'z], IN ['A..'Z], IN ['0..'9] => NULL;	      '' => InlineNextChar[];	      ENDCASE =>  EXIT;	    IF (i ¬ i+1) >= iMax THEN ExpandBuffer[];	    ENDLOOP;	  desc.length ¬ i+1;	  class ¬ tokenID;  value ¬ StringExtra.StringFromSubString[@desc];	  GO TO GotNext	  END;	  	'A, 'B, 'C, 'D, 'E, 'F, 'G, 'H, 'I, 'J, 'K, 'L, 'M,	'N, 'O, 'P, 'Q, 'R, 'S, 'T, 'U, 'V, 'W, 'X, 'Y, 'Z  =>	  BEGIN	  first, last: CARDINAL ¬ char-0C;	  i: CARDINAL ¬ 0;	  h: HashIndex;	  s1, s2, j: CARDINAL;	  -- Gather the token	  DO	    buffer[i] ¬ char;	    InlineNextChar[];	    SELECT char FROM	      IN ['A..'Z], IN ['a..'z], IN ['0..'9] => last ¬ char-0C;	      '' => InlineNextChar[];	      ENDCASE => EXIT;	    IF (i ¬ i+1) >= iMax THEN ExpandBuffer[];	    ENDLOOP;	  i ¬ i+1;	  -- Check for multi-character Terminal in vocab.	  -- This code is forced by PGS.	  h ¬ ((first*128-first) + last) MOD LAST[HashIndex] + 1;	  WHILE (j ¬ hashTab[h].symbol) # 0 DO 	    IF vocabIndex[j]-(s2¬vocabIndex[j-1]) = i THEN	      FOR s1 IN [0..i) DO 		IF buffer[s1] # vocab[s2] THEN EXIT;		s2 ¬ s2+1;		REPEAT		  FINISHED => {value ¬ class ¬ j; GO TO GotNext};		ENDLOOP;	    IF (h ¬ hashTab[h].link) = 0 THEN EXIT;	    ENDLOOP;	  -- Enter token	  desc.length ¬ i;	  class ¬ tokenID;  value ¬ StringExtra.StringFromSubString[@desc];	  GO TO GotNext	  END;	  	'0, '1, '2, '3, '4, '5, '6, '7, '8, '9  =>	  BEGIN	  v, v10, v8: LONG INTEGER;	  scale: CARDINAL;	  valid, valid10, valid8, octal: BOOLEAN;	  MaxLiteral: CARDINAL = LAST[CARDINAL];	  vRep: ARRAY [0..SIZE[LONG INTEGER]) OF WORD;  -- machine dependent	  v10 ¬ v8 ¬ 0;  valid10 ¬ valid8 ¬ TRUE;	  WHILE char IN ['0..'9] 	    DO	    IF valid10 THEN [v10, valid10] ¬ AppendDigit10[v10, char];	    IF valid8 THEN [v8, valid8] ¬ AppendDigit8[v8, char];	    NextChar[];	    ENDLOOP;	  SELECT char FROM	    'B --,'C-- =>	      BEGIN	      -- class ¬ IF char = 'C THEN tokenCHAR ELSE tokenNUM;	      class ¬ tokenNUM;	      v ¬ v8;  valid ¬ valid8;  octal ¬ TRUE;	      END;	    ENDCASE =>	      {class ¬ tokenNUM;  v ¬ v10;  valid ¬ valid10;  octal ¬ FALSE};	  SELECT char FROM	    'B, 'C, 'D =>	      BEGIN 	      NextChar[];	      IF class = tokenNUM		THEN		  BEGIN  scale ¬ 0;		  WHILE char IN ['0..'9] 		    DO		    scale ¬ 10*scale + CARDINAL[char-'0];  NextChar[];		    ENDLOOP;		  THROUGH [1 .. scale]  WHILE valid		    DO		    IF octal		      THEN [v, valid] ¬ AppendDigit8[v, '0]		      ELSE [v, valid] ¬ AppendDigit10[v, '0];		    ENDLOOP;		  END;	      END;	    ENDCASE;	  vRep ¬ LOOPHOLE[v];	  IF vRep[1] = 0  --v <= MaxLiteral--	    THEN value ¬ vRep[0]	    ELSE	      BEGIN	      -- IF class = tokenCHAR THEN-- valid ¬ FALSE;	      -- class ¬ tokenLNUM;	      -- value ¬ LiteralOps.FindDescriptor[DESCRIPTOR[vRep]];	      END;	  IF ~valid THEN {nErrors ¬ nErrors + 1; ScanError[number, index]};	  GO TO GotNext	  END;	  	';  =>	  {class ¬ scanTab[char]; lastWasSemiColon ¬ TRUE; GO TO GetNext};	  	',, ':, '¬, '#, '~, '+, '*, '/, '­, '@, '!,	'(, '), '[, '], '{, '}  =>	  {class ¬ scanTab[char]; GO TO GetNext};	  	'" =>	  BEGIN	  i: CARDINAL;	  i ¬ 0;	  DO 	    IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GO TO EOFEnd;  FillBuffer[]};	    char ¬ tC[tI];	    SELECT char FROM	      '" =>		BEGIN		InlineNextChar[];		IF char # '" THEN GO TO QuoteEnd;		END;	      ENDCASE;	    IF i >= iMax	      THEN ExpandBuffer[		! BufferOverflow => {ScanError[string, index]; i ¬ 0; CONTINUE}];	    buffer[i] ¬ char;  i ¬ i+1;	    REPEAT	      QuoteEnd => NULL;	      EOFEnd => {ScanError[string, index]; FillBuffer[];  char ¬ tC[tI]};	    ENDLOOP;	  desc.length ¬ i;	  value ¬ StringExtra.StringFromSubString[@desc];	  class ¬ tokenDELSTR;	  GO TO GotNext;	  END;	  	'- =>	  BEGIN	  pChar: CHARACTER;	  NextChar[];	  -- Signed numbers are not implemented	  -- IF char # '- THEN {class ¬ tokenMINUS; GO TO GotNext};	  IF char # '- THEN	    {NextChar[]; nErrors ¬ nErrors + 1; ScanError[char, index]};	  char ¬ Ascii.NUL;	    DO	    pChar ¬ char;	    IF (tI¬tI+1) = tMax THEN {IF tEnded THEN GOTO EndFile; FillBuffer[]};	    char ¬ tC[tI];	    SELECT char FROM	      '- =>  IF pChar = '- THEN EXIT;	      Ascii.CR =>  EXIT;	      ENDCASE;	    ENDLOOP;	  NextChar[];	  END;		'< => {	  NextChar[];	  IF char = '< THEN GO TO ScanComment ELSE ScanError[char, index]};		253c => GO TO ScanComment;	-- Character mappings	137c => { -- old left arrow converted to new left arrow	  class ¬ scanTab[254c]; GO TO GetNext};	136c => { -- old up arrow to new	  class ¬ scanTab[255c]; GO TO GetNext};	264c => { -- new times to old	  class ¬ scanTab['*]; GO TO GetNext};	270c => { -- new divide to old	  class ¬ scanTab['/]; GO TO GetNext};		ENDCASE =>	  BEGIN	  class ¬ scanTab[char];	  IF class # 0 THEN GO TO GetNext;	  NextChar[];	  ScanError[char, index];	  END;	        EXITS ScanComment => {	state: {plain, leftBrocket, rightBrocket} ¬ plain;	nest: CARDINAL ¬ 1;	DO	  IF (tI¬tI+1) = tMax THEN {	    IF tEnded THEN GO TO EndFile; FillBuffer[]};	  char ¬ tC[tI];	  SELECT char FROM	    '> => SELECT state FROM	      plain, leftBrocket => state ¬ rightBrocket;	      rightBrocket => {		state ¬ plain; nest ¬ nest - 1; IF nest = 0 THEN EXIT};	      ENDCASE;	    '< => SELECT state FROM	      plain, rightBrocket => state ¬ leftBrocket;	      leftBrocket => {state ¬ plain; nest ¬ nest + 1};	      ENDCASE;	    253c => {state ¬ plain; nest ¬ nest + 1};	    273c => {state ¬ plain; nest ¬ nest - 1; IF nest = 0 THEN EXIT};	    ENDCASE => state ¬ plain;	  ENDLOOP;	NextChar[]};      END;      REPEAT	GetNext => InlineNextChar[];	GotNext => NULL;	EndFile =>	  BEGIN	  FillBuffer[]; char ¬ tC[tI];	  class ¬ scanTab[char];  -- Compiler uses EndMarker --	  index ¬ tOrigin; value ¬ 0;	  END;      ENDLOOP;    nTokens ¬ nTokens + 1;    RETURN    END;    -- numerical conversion  Digit: ARRAY CHARACTER ['0..'9] OF CARDINAL = [0,1,2,3,4,5,6,7,8,9];    AppendDigit10: PROC [v: LONG INTEGER, digit: CHARACTER ['0..'9]]      RETURNS [newV: LONG INTEGER, valid: BOOLEAN] =    BEGIN    MaxV: LONG INTEGER = 429496729;		-- (2**32-1)/10    MaxD: CARDINAL = 5;			-- (2**32-1) MOD 10    d: [0..9] = Digit[digit];    valid ¬ v < MaxV OR (v = MaxV AND d <= MaxD);    newV ¬ 10*v + d;    RETURN    END;      AppendDigit8: PROC [v: LONG INTEGER, digit: CHARACTER ['0..'9]]      RETURNS [newV: LONG INTEGER, valid: BOOLEAN] =    BEGIN    MaxV: LONG INTEGER = 3777777777B;		-- (2**32-1)/8    MaxD: CARDINAL = 7B;			-- (2**32-1) MOD 8    d: [0..9] = Digit[digit];    valid ¬ (d < 8) AND (v < MaxV OR (v = MaxV AND d <= MaxD));    newV ¬ 8*v + d;    RETURN    END;    -- initialization/finalization  ScanInit: PUBLIC PROC [      sourceStream: Stream.Handle,      msg: Format.StringProc,      table: ParseTable.TableRef] =    BEGIN    hashTab ¬ @table[table.scanTable.hashTab];    scanTab ¬ @table[table.scanTable.scanTab];    vocab ¬ LOOPHOLE[@table[table.scanTable.vocabBody]];    vocabIndex ¬ @table[table.scanTable.vocabIndex];    IF buffer = NIL THEN buffer ¬ Heap.systemZone.NEW[StringBody[256]];    iMax ¬ buffer.length ¬ buffer.maxlength;    desc.base ¬ buffer;  desc.offset ¬ 0;    stream ¬ sourceStream;  errorMsg ¬ msg;    streamOrigin ¬ Stream.GetPosition[stream];    tC ¬ MSegment.GetPages[TextPages];    tOrigin ¬ tLimit ¬ 0;  tMax ¬ 0;  tEnded ¬ FALSE;    FillBuffer[];  char ¬ tC[tI];    nTokens ¬ nErrors ¬ 0;    END;      ScanReset: PUBLIC PROC RETURNS [CARDINAL, CARDINAL] =    BEGIN    MSegment.FreePages[tC];    IF buffer # NIL THEN {Heap.systemZone.FREE[@buffer]; buffer ¬ NIL};    [] ¬ Heap.Prune[Heap.systemZone];    RETURN [nTokens, nErrors]    END;        -- error handling  StreamIndex: TYPE = LONG CARDINAL;    PutChar: PROC [c: CHARACTER] = INLINE    BEGIN Format.Char[errorMsg, c]; END;      PutString: PROC [s: LONG STRING] = INLINE    BEGIN errorMsg[s]; END;      PutNumber: PROC [u: UNSPECIFIED] = INLINE    BEGIN    Format.Number[n: u, format: Format.OctalFormat, proc: errorMsg];    END;      NewLine: PROC = INLINE {PutChar[Ascii.CR]};    ResetScanIndex: PUBLIC PROC [index: CARDINAL] =    BEGIN    IF index IN [tOrigin .. tLimit) THEN      {tI ¬ index - tOrigin; IF tI >= tMax THEN FillBuffer[]}    ELSE      BEGIN      oddByteAligned: BOOLEAN = ((streamOrigin+index) MOD 2) # 0;      tLimit ¬ IF oddByteAligned THEN index-1 ELSE index;      tEnded ¬ FALSE;      Stream.SetPosition[stream, streamOrigin + tLimit];      FillBuffer[];      IF oddByteAligned THEN tI ¬ tI + 1;      END;    char ¬ tC[tI];    END;          ScanError: PROC [code: {number, string, char}, tokenIndex: CARDINAL] =    BEGIN    nErrors ¬ nErrors + 1;    ErrorContext[      SELECT code FROM	number => "invalid number"L,	string => "string unterminated or too long"L,	char => "invalid character"L,	ENDCASE => NIL,      tokenIndex];    NewLine[];    END;          ErrorContext: PUBLIC PROC [message: LONG STRING, tokenIndex: CARDINAL] =    BEGIN    saveIndex: StreamIndex = Stream.GetPosition[stream];    origin: StreamIndex = streamOrigin + tokenIndex;    start, lineIndex: StreamIndex ¬ origin;    char: CHARACTER;    n: [1..100];    FOR n IN [1..100] UNTIL lineIndex = 0      DO      lineIndex ¬ lineIndex - 1;      Stream.SetPosition[stream, lineIndex];      IF Stream.GetChar[stream] = Ascii.CR THEN EXIT;      start ¬ lineIndex;      ENDLOOP;    Stream.SetPosition[stream, start];    FOR n IN [1..100] UNTIL MStream.EndOf[stream]      DO      char ¬ Stream.GetChar[stream];      SELECT char FROM	Ascii.CR, Ascii.ControlZ => EXIT;	ENDCASE => PutChar[char];      ENDLOOP;    NewLine[];    Stream.SetPosition[stream, start];    UNTIL Stream.GetPosition[stream] = origin OR MStream.EndOf[stream]      DO      char ¬ Stream.GetChar[stream];      PutChar[IF char = Ascii.TAB THEN Ascii.TAB ELSE Ascii.SP];      ENDLOOP;    PutString["­ "L];  PutString[message];    PutString[" ["L];    PutNumber[tokenIndex];    PutChar[']];   NewLine[];    Stream.SetPosition[stream, saveIndex];    END;      END.  -- From Atom's SELECT char FROM  '' =>    BEGIN    NextChar[];    class ¬ tokenCHAR;  value ¬ LiteralOps.Find[char-0C];    GO TO GetNext    END;      '. =>    BEGIN    NextChar[];    IF char = '.       THEN  {class ¬ tokenDOTS;  GO TO GetNext}      ELSE  {class ¬ tokenDOT;   GO TO GotNext}    END;      '= =>    BEGIN    NextChar[];    IF char = '>       THEN  {class ¬ tokenARROW;  GO TO GetNext}      ELSE  {class ¬ tokenEQUAL;  GO TO GotNext}    END;      '< =>    BEGIN    NextChar[];    IF char = '=       THEN  {class ¬ tokenLE;    GO TO GetNext}      ELSE  {class ¬ tokenLESS;  GO TO GotNext}    END;      '> =>    BEGIN    NextChar[];    IF char = '=       THEN  {class ¬ tokenGE;       GO TO GetNext}      ELSE  {class ¬ tokenGREATER;  GO TO GotNext}    END;    
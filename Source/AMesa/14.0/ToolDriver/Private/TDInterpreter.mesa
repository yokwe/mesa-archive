-- file TDInterpreter.mesa rewritten by PGS, 26-Oct-84 11:28-- file TDInterpreter.mesa rewritten by PGS,  8-Oct-84 11:02-- file TDInterpreter.mesa rewritten by PGS,  8-Oct-84 10:40-- file TDInterpreter.mesa rewritten by PGS,  8-Oct-84 10:07-- file TDInterpreter.mesa rewritten by PGS,  8-Oct-84 10:06-- file TDInterpreter.mesa rewritten by PGS,  5-Oct-84 14:03-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- file TDInterpreter.mesa rewritten by PGS,  5-Oct-83 10:07-- file TDInterpreter.mesa rewritten by PGS,  4-Oct-83 14:43-- file TDInterpreter.mesa rewritten by PGS,  4-Oct-83 12:02-- file TDInterpreter.mesa rewritten by PGS, 22-Feb-82 14:49-- TDInterpreter.mesa - last edit:-- Mark		Mar 18, 1981 5:27 PM-- BTL  	7-Jan-82 14:10:27-- Mike		15-Jan-82 10:36:09-- RXJ     	12-Nov-82  8:23:36-- RSF           4-Oct-83 14:59:17DIRECTORY  FormSWDriver USING [    BuiltInValue, Error, ItemSpecObject, SBuiltIn, SetItemFromItem,    SetItemFromValue],  Heap USING [FreeNode, systemZone],  Inline USING [LowHalf],  ParseTable USING [ActionEntry, ProductionInfo, ProdDataRef, tokenTRUE],  StringExtra USING [StringsAreSame],  TDParseOps USING [ParseError, QueueProcessor, ResetScanIndex],  TDSupportOps USING [    BuiltInFunction, CleanupStorage, EscapeCall, FormSWItem, FreeFormSWItem,     Handle, InitStmtState, interpreterStack, LocateFormSWItem, Pop, PopBool,     PopFormSWItem, PopString, PushBool, PushFormSWItem, PushNumber, PushString, Relation,     ReservedNames, ScanState, Stack, StringFromHandle],  ToolDriverOps USING [AnotherStepDone, OnlyDoOneStep];  TDInterpreter: PROGRAM  IMPORTS    FormSWDriver, Heap, Inline, StringExtra, TDParseOps, TDSupportOps, ToolDriverOps  EXPORTS TDParseOps, TDSupportOps =  BEGIN OPEN TDSupportOps;    q: LONG DESCRIPTOR FOR ARRAY OF ParseTable.ActionEntry;  v: LONG DESCRIPTOR FOR ARRAY OF LONG UNSPECIFIED;  l: LONG DESCRIPTOR FOR ARRAY OF CARDINAL;  proddata: ParseTable.ProdDataRef;    defaultTool, defaultSubwindow: PUBLIC LONG STRING;  formSWItem: PUBLIC FormSWItem;  relation: PUBLIC Relation;    scanState: PUBLIC ScanState;  labelToFind: PUBLIC LONG STRING;  loopDepth: PUBLIC CARDINAL;  idCount: PUBLIC CARDINAL;    globalTop, lGlobalTop: PUBLIC CARDINAL;    AssignDescriptors: PUBLIC PROCEDURE [      lq: LONG DESCRIPTOR FOR ARRAY OF ParseTable.ActionEntry,      lv: LONG DESCRIPTOR FOR ARRAY OF LONG UNSPECIFIED,      ll: LONG DESCRIPTOR FOR ARRAY OF CARDINAL,      lproddata: ParseTable.ProdDataRef] =    BEGIN q ¬ lq; v ¬ lv; l ¬ ll; proddata ¬ lproddata END;      InterpreterInit: PUBLIC PROCEDURE =    BEGIN    IF interpreterStack # NIL THEN CleanupStorage[];    interpreterStack ¬ Heap.systemZone.NEW[Stack];    defaultTool ¬ defaultSubwindow ¬ NIL;    formSWItem ¬ [];    scanState ¬ [];    labelToFind ¬ NIL;    loopDepth ¬ 0;    END;      ProcessQueue: PUBLIC TDParseOps.QueueProcessor =    BEGIN    RealProcessQueue[qI, top ! UNWIND => CleanupStorage[]];    END;      RealProcessQueue: TDParseOps.QueueProcessor =    BEGIN    Oops: PROCEDURE = BEGIN ERROR TDParseOps.ParseError[l[top]]; END;    oneStepAtATime: BOOLEAN ¬ ToolDriverOps.OnlyDoOneStep[];    rule: [0..256);    i: CARDINAL;    FOR i IN [0..qI) DO      globalTop ¬ top ¬ top-q[i].tag.pLength+1;      lGlobalTop ¬ l[globalTop];      rule ¬ proddata[q[i].transition].rule;      SELECT rule FROM            0  =>   --        --TYPE: ParseTable	--TABLE: TDGrammar  EXPORTS: SELF	--GOAL:  goal		--TERMINALS:	--    \  ¬  .  ,  [  ]  id	--    delimStr  num  NIL  TRUE  FALSE	--    ActivateTool  AppendCommand  AppendString  CallDebugger  FileCreated	--    InvokeMCR  IsVisible  LastMessage  ModifyItem  Pause  SetDispState	--    SetSelection  SetWindowBox  SubString  Wait WindowOnTop	--    DO  ENDLOOP  EXITLOOP  ;  semiSuffix	--    IF  THEN  BEGIN  END  ELSE	--    =  #		--ALIASES:	--  id			tokenID	--  delimStr		tokenDELSTR	--  num			tokenNUM	--  ActivateTool	tokenCallAT	--  AppendCommand	tokenCallAC	--  AppendString	tokenCallAS	--  CallDebugger	tokenCallCD	--  FileCreated		tokenCallFC	--  InvokeMCR		tokenCallIM	--  IsVisible		tokenCallIV	--  LastMessage		tokenCallLM	--  ModifyItem		tokenCallMI	--  Pause		tokenCallPause	--  SetDispState	tokenCallSDS	--  SetSelection	tokenCallSSel	--  SetWindowBox	tokenCallSWB	--  SubString		tokenCallSStr	--  Wait		tokenCallWait	--  WindowOnTop		tokenCallWOT	--  TRUE		tokenTRUE	--  semiSuffix		tokenSCS		--  PRODUCTIONS:		      --  goal		::= statements \	CleanupStorage[];	      1  =>   -- statements		::= statements statement	      -- statements		::= statement	BEGIN	InitStmtState[];	IF scanState.mode = exit AND loopDepth = 0 THEN Oops[];	END;	      2  =>   -- statement		::= assignment	      -- statement		::= formCmd	      -- statement		::= loop semiSuffix	      -- statement		::= ifStatement	IF scanState.mode = normal AND oneStepAtATime THEN	  SIGNAL ToolDriverOps.AnotherStepDone[l[top]];	        3  =>   -- statement		::= EXITLOOP loopLabel ; semiSuffix	BEGIN	loopLabel: FormSWDriver.SBuiltIn ¬ PopString[];	IF ~loopLabel.inHeap THEN Oops[];	IF scanState.mode # normal THEN Heap.systemZone.FREE[@loopLabel.s]	ELSE	  BEGIN	  scanState ¬ [mode: exit, info: loopDepth-1];	  Heap.systemZone.FREE[@labelToFind];	  labelToFind ¬ loopLabel.s;	  END;	loopLabel.s ¬ NIL;	IF loopDepth = 0 THEN Oops[];	END;	      4  =>   -- statement		::= functionCall	IF scanState.mode = normal THEN	  BEGIN	  sbi: FormSWDriver.SBuiltIn ¬ PopString[];	  IF sbi.inHeap THEN Heap.systemZone.FREE[@sbi.s];	  IF oneStepAtATime THEN	    SIGNAL ToolDriverOps.AnotherStepDone[l[top]];	  END;	        5  =>   -- assignment		::= formSWItem ¬ expression	IF scanState.mode = normal THEN	  BEGIN	  dest: FormSWDriver.ItemSpecObject;	  destTemp: LONG POINTER TO FormSWItem;	  sourceTemp: Handle;	  -- Order of next two assignments is crucial!	  sourceTemp ¬ Pop[]; destTemp ¬ PopFormSWItem[];	  IF ReservedNames[sourceTemp, destTemp] THEN GOTO Special;	  -- Locate item and do assignment	  dest ¬ LocateFormSWItem[destTemp];	  FreeFormSWItem[destTemp];  -- in case of ERRORs below	  WITH sourceBI: sourceTemp SELECT FROM	    formSWItem =>	      BEGIN	      source: FormSWDriver.ItemSpecObject;	      source ¬ LocateFormSWItem[@sourceBI.pi !		UNWIND => FreeFormSWItem[@sourceBI.pi]];	      FreeFormSWItem[@sourceBI.pi];	      FormSWDriver.SetItemFromItem[@dest, source.item !		FormSWDriver.Error => Oops[]];	      END;	    builtIn =>	      BEGIN	      lost: BOOLEAN ¬ FALSE;	      FormSWDriver.SetItemFromValue[@dest, @sourceBI.b !		FormSWDriver.Error => {lost ¬ TRUE; CONTINUE}];	      WITH bi: sourceBI.b SELECT sourceBI.b.type FROM		string =>		  IF bi.inHeap THEN Heap.systemZone.FREE[@bi.s];		ENDCASE;	      IF lost THEN Oops[];	      END;	    ENDCASE => Oops[];	  EXITS	    Special => NULL;	  END;	        6  =>   -- formCmd		::= formSWItem	IF scanState.mode = normal THEN	  BEGIN	  dest: FormSWDriver.ItemSpecObject;	  biv: FormSWDriver.BuiltInValue;	  temp: LONG POINTER TO FormSWItem ¬ PopFormSWItem[];	  -- Locate item and do assignment	  dest ¬ LocateFormSWItem[temp];	  FreeFormSWItem[temp];  -- in case of ERRORs below	  IF dest.item.type # command THEN Oops[];	  biv.type ¬ empty;	  FormSWDriver.SetItemFromValue[@dest, @biv !	    FormSWDriver.Error => Oops[]];	  END;	        7  =>   -- formSWItem		::= idList	IF scanState.mode = normal THEN	  BEGIN	  sbi: FormSWDriver.SBuiltIn;	  IF ~(idCount IN [1..3]) THEN ERROR TDParseOps.ParseError[l[top]];	  sbi ¬ PopString[];	  formSWItem ¬ [tool: NIL, sw: NIL, tag: sbi.s, idCount: idCount];	  IF idCount > 1 THEN	    BEGIN	    sbi ¬ PopString[];	    formSWItem.sw ¬ sbi.s;	    END;	  IF idCount > 2 THEN	    BEGIN	    sbi ¬ PopString[];	    formSWItem.tool ¬ sbi.s;	    END;	  PushFormSWItem[@formSWItem];	  END;	        8  =>  -- idList		::= idList . id	IF scanState.mode # normal THEN Heap.FreeNode[Heap.systemZone, v[top+2]] ELSE	{PushString[v[top+2], TRUE]; v[top+2] ¬ LONG[NIL]; idCount ¬ idCount + 1};	      9  =>  -- idList		::= id	IF scanState.mode # normal THEN Heap.FreeNode[Heap.systemZone, v[top]] ELSE	{PushString[v[top], TRUE]; v[top] ¬ LONG[NIL]; idCount ¬ 1};	      10  =>  -- expressionList	::= expressionList , expression	      -- expressionList	::= expression	NULL;	      11  =>  -- expression		::= variable	      -- expression		::= constant	NULL;	      12  =>  -- expressionTail		::= variable	      -- expressionTail		::= constant	NULL;		      	            13  =>  -- variable		::= formSWItem	      -- variable		::= functionCall	NULL;	      14  =>  -- constant		::= delimStr	IF scanState.mode = normal THEN PushString[v[top], TRUE]	ELSE Heap.FreeNode[Heap.systemZone, v[top]];	      15  =>  -- constant		::= num	IF scanState.mode = normal THEN PushNumber[Inline.LowHalf[v[top]]];	      16  =>  -- constant		::= NIL	IF scanState.mode = normal THEN PushString[NIL, TRUE];	      17  =>  -- constant		::= TRUE	      -- constant		::= FALSE	IF scanState.mode = normal THEN PushBool[v[top]=ParseTable.tokenTRUE];	      18  =>  -- functionCall		::= id [ expressionList ]	IF scanState.mode = normal THEN	  EscapeCall[v[top]];  -- The escape hatch!  Client provides value.	        19  =>  -- functionCall		::= functionName [ expressionList ]	IF scanState.mode = normal THEN	  BuiltInFunction[Inline.LowHalf[v[top]]];	        20  =>  -- functionName		::= ActivateTool	      -- functionName		::= AppendCommand	      -- functionName		::= AppendString	      -- functionName		::= CallDebugger	      -- functionName		::= FileCreated	      -- functionName		::= InvokeMCR	      -- functionName		::= IsVisible	      -- functionName		::= LastMessage	      -- functionName		::= ModifyItem	      -- functionName		::= Pause	      -- functionName		::= SetDispState	      -- functionName		::= SetSelection	      -- functionName		::= SetWindowBox	      -- functionName		::= SubString	      -- functionName		::= Wait	      -- functionName		::= WindowOnTop	NULL;	      21  =>  -- loop			::= do statements ENDLOOP loopLabel ;	BEGIN	thisLabel: FormSWDriver.SBuiltIn ¬ PopString[];	loopDepth ¬ loopDepth - 1;	SELECT scanState.mode FROM	  exit =>	    BEGIN	    IF scanState.info = loopDepth THEN	      IF StringExtra.StringsAreSame[thisLabel.s, labelToFind, FALSE] THEN		scanState ¬ []	      ELSE scanState.info ¬ scanState.info - 1;	    END;	  if => NULL;	  normal => TDParseOps.ResetScanIndex[l[top]];	  ENDCASE => Oops[];	IF thisLabel.inHeap THEN Heap.systemZone.FREE[@thisLabel.s];	END;	      22  =>  -- do			::= DO	loopDepth ¬ loopDepth + 1;	      23  =>  -- ifStatement		::= ifExp block	      -- ifStatement		::= ifExp blockElse block	IF scanState.mode = if AND scanState.info = l[top] THEN scanState ¬ [];	      24  =>  -- ifExp			::= IF boolExp THEN	IF scanState.mode = normal AND ~PopBool[] THEN scanState ¬ [mode: if, info: l[top]];	      25  =>  -- block			::= statement	      -- block			::= BEGIN statements END	NULL;	      26  =>  -- blockElse		::= BEGIN statements END ELSE	BEGIN	IF top = 0 THEN Oops[];	SELECT scanState.mode FROM	  exit => NULL;	  if => IF scanState.info = l[top-1] THEN scanState ¬ [];	  normal => scanState ¬ [mode: if, info: l[top-1]];	  ENDCASE => Oops[];	END;	      27  =>  -- boolExp		::= expression relational expressionTail	BEGIN	IF scanState.mode = normal THEN	  BEGIN	  lhsExp, rhsExp: LONG STRING;	  freelhsExp, freeRhsExp: BOOLEAN;	  [freeRhsExp, rhsExp] ¬ StringFromHandle[Pop[]];	  [freelhsExp, lhsExp] ¬ StringFromHandle[Pop[]];	  PushBool[(relation = equal) = StringExtra.StringsAreSame[	    rhsExp, lhsExp, TRUE]];	  IF freeRhsExp THEN Heap.systemZone.FREE[@rhsExp];	  IF freelhsExp THEN Heap.systemZone.FREE[@lhsExp];	  END;	END;	      28  =>  -- boolExp		::= expression	BEGIN	IF scanState.mode = normal THEN	  BEGIN	  exp: LONG STRING;	  freeExp: BOOLEAN;	  [freeExp, exp] ¬ StringFromHandle[Pop[]];	  PushBool[StringExtra.StringsAreSame[exp, "TRUE"L, TRUE]];	  IF freeExp THEN Heap.systemZone.FREE[@exp];	  END;	END;	      29  =>  -- loopLabel		::= id	{PushString[v[top], TRUE]; v[top] ¬ LONG[NIL]};	      30  =>  -- loopLabel		::=	PushString[NIL, TRUE];	      31  =>  -- relational		::= =	relation ¬ equal;	      32  =>  -- relational		::= #	relation ¬ notEqual;	      ENDCASE => Oops[];      ENDLOOP;    RETURN    END;      InitStmtState[];    END.
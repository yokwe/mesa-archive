-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- TDParser.Mesa - last edit:-- Mark		      Dec 23, 1980 11:13 AM-- Mike		      25-Jan-82 11:58:41-- RXJ     	      11-Nov-82 18:13:32-- RXR   	       2-Mar-83 10:29:41-- RES  /RSF           4-Oct-83 15:23:02-- Modified version of XDebug's DIParser-- There is no error recovery-- Too bad its not Pilot based.  (BAM)DIRECTORY  Format USING [StringProc],   Inline USING [LongCOPY],  MSegment USING [GetWords, FreeWords],  ParseTable USING [    ActionEntry, ActionTag, DefaultMarker, FinalState, InitialState,     NTIndex, NTState, NTSymbol, ProdDataRef, State, TableRef, TIndex, TSymbol],  Runtime USING [GetTableBase, GlobalFrame],  Stream USING [Handle],  TDGrammar USING [],  TDParseOps USING [    AssignDescriptors, Atom, InterpreterInit, lastntstate, ProcessQueue,     ScanInit, ScanReset, Token],  ToolDriverOps USING [debugging];     TDParser: PROGRAM    IMPORTS Inline, MSegment, Runtime, TDGrammar, TDParseOps, ToolDriverOps    EXPORTS TDParseOps =  BEGIN  OPEN TDParseOps, ParseTable;    ParseError: PUBLIC SIGNAL [errorLoc: CARDINAL] = CODE;  SyntaxError: PUBLIC SIGNAL [errorLoc: CARDINAL] = CODE;  ToolNotRegistered: PUBLIC SIGNAL [errorLoc: CARDINAL] = CODE;    currentState: State;  inputSymbol, lhs: TSymbol;    input: PROCEDURE RETURNS [symbol: Token];  inputLoc: CARDINAL;  inputValue: LONG UNSPECIFIED;  qI, top: CARDINAL;  stackSize: CARDINAL;  queueSize: CARDINAL;    q: LONG DESCRIPTOR FOR ARRAY OF ActionEntry;  --reduction rules  v: LONG DESCRIPTOR FOR ARRAY OF LONG UNSPECIFIED; --parse stack  l: LONG DESCRIPTOR FOR ARRAY OF CARDINAL; --sourceline index  s: LONG DESCRIPTOR FOR ARRAY OF State;    -- transition tables for terminal input symbols    tStart: LONG POINTER TO ARRAY State OF TIndex;  tLength: LONG POINTER TO ARRAY State OF CARDINAL;  tSymbol: LONG POINTER TO ARRAY TIndex OF TSymbol;  tAction: LONG POINTER TO ARRAY TIndex OF ActionEntry;    -- transition tables for nonterminal input symbols    nStart: LONG POINTER TO ARRAY NTState OF NTIndex;  nLength: LONG POINTER TO ARRAY NTState OF CARDINAL;  nSymbol: LONG POINTER TO ARRAY NTIndex OF NTSymbol;  nAction: LONG POINTER TO ARRAY NTIndex OF ActionEntry;  ntDefaults: LONG POINTER TO ARRAY NTSymbol OF ActionEntry;    -- production information    prodData: ProdDataRef;    -- initialization/termination  refCount: CARDINAL ¬ 0;  table: ParseTable.TableRef ¬     Runtime.GetTableBase[Runtime.GlobalFrame[TDGrammar]];    Initialize: PROCEDURE [sourceStream: Stream.Handle, msg: Format.StringProc] =    BEGIN    IF (refCount ¬ refCount + 1) > 1 THEN ParseInit[sourceStream, msg, FALSE]    ELSE ParseInit[sourceStream, msg, TRUE];    END;      Finalize: PROCEDURE =    BEGIN    EraseQueue[];    EraseStack[];    refCount ¬ refCount - 1;    END;      ParseInit: PROCEDURE [sourceStream: Stream.Handle, msg: Format.StringProc, initTable: BOOLEAN] =    BEGIN    ScanInit[sourceStream, msg, table];    stackSize ¬ queueSize ¬ 0;     ExpandStack[64];      ExpandQueue[256];    IF initTable THEN      BEGIN OPEN table;      tStart ¬ @table[table.parseTable.tStart];      tLength ¬ @table[table.parseTable.tLength];      tSymbol ¬ @table[table.parseTable.tSymbol];      tAction ¬ @table[table.parseTable.tAction];      nStart ¬ @table[table.parseTable.nStart];      nLength ¬ @table[table.parseTable.nLength];      nSymbol ¬ @table[table.parseTable.nSymbol];      nAction ¬ @table[table.parseTable.nAction];      ntDefaults ¬ @table[table.parseTable.ntDefaults];      prodData ¬ @table[table.parseTable.prodData];      END;    InterpreterInit[];    END;      InputLoc: PUBLIC PROCEDURE RETURNS [CARDINAL] = BEGIN RETURN[inputLoc] END;  --  the main parsing procedures  Parse: PUBLIC PROCEDURE [sourceStream: Stream.Handle, msg: Format.StringProc]    RETURNS [complete: BOOLEAN, nTokens, nErrors: CARDINAL] =    BEGIN    input ¬ Atom;    Initialize[sourceStream, msg];    [complete, nTokens, nErrors] ¬ RealParse[! UNWIND => Finalize[]];    Finalize[];    END;      RealParse: PROCEDURE RETURNS [complete: BOOLEAN, nTokens, nErrors: CARDINAL] =    BEGIN    i, valid, k, m: CARDINAL;		-- stack pointers    j, j0: CARDINAL;    tj: ActionEntry;        i ¬ top ¬ valid ¬ 0;  qI ¬ 0;    s[0] ¬ currentState ¬ InitialState;    [inputSymbol, inputValue, inputLoc] ¬ input[].symbol;        WHILE currentState # FinalState DO      BEGIN      j0 ¬ tStart[currentState];      FOR j IN [j0 .. j0 + tLength[currentState]) 	DO	SELECT tSymbol[j] FROM	  inputSymbol, DefaultMarker => EXIT;	  ENDCASE;	REPEAT	  FINISHED => GO TO SyntaxError;	ENDLOOP;	      tj ¬ tAction[j];       IF ~tj.tag.reduce	-- scan or scan reduce entry	THEN	  BEGIN	  IF qI > 0 	    THEN	      BEGIN	      FOR k IN (valid..i] DO s[k] ¬ s[top+(k-valid)] ENDLOOP;	      AssignDescriptors[q,v,l,prodData];	      ProcessQueue[qI, top !		ParseError => IF ~ToolDriverOps.debugging THEN GOTO SyntaxError;		ToolNotRegistered => GOTO NoToolError];	      qI ¬ 0;	      EXITS		SyntaxError => SIGNAL SyntaxError[inputLoc];		NoToolError => SIGNAL ToolNotRegistered[inputLoc];	      END;	  top ¬ valid ¬ i ¬ i+1;	  IF top = stackSize THEN ExpandStack[64];	  v[i] ¬ inputValue;  l[i] ¬ inputLoc;	  [inputSymbol,inputValue,inputLoc]  ¬ input[].symbol;	  END;	        WHILE tj.tag # ActionTag[FALSE, 0] DO	IF qI >= queueSize THEN ExpandQueue[256];	q[qI] ¬ tj;  qI ¬ qI + 1;	i ¬ i-tj.tag.pLength;	-- pop 1 state per rhs symbol	currentState ¬ s[IF i > valid THEN top+(i-valid) ELSE (valid ¬ i)];	lhs ¬ prodData[tj.transition].lhs;	  BEGIN	  IF currentState <= lastntstate 	    THEN	      BEGIN  j ¬ nStart[currentState];	      FOR j IN [j..j+nLength[currentState])		DO		IF lhs = nSymbol[j] THEN		  BEGIN  tj ¬ nAction[j]; GO TO nfound  END;		ENDLOOP;	      END;	  tj ¬ ntDefaults[lhs];	  EXITS	    nfound => NULL;	  END;	i ¬ i+1;	ENDLOOP;      IF (m ¬ top+(i-valid)) >= stackSize THEN ExpandStack[64];      s[m] ¬ currentState ¬ tj.transition;      EXITS	SyntaxError => SIGNAL SyntaxError[inputLoc];      END;      ENDLOOP;          BEGIN    AssignDescriptors[q,v,l,prodData];    ProcessQueue[qI, top !      ParseError => IF ~ToolDriverOps.debugging THEN GO TO SyntaxError];    EXITS      SyntaxError => SIGNAL SyntaxError[inputLoc];    END;        [nTokens, nErrors] ¬ ScanReset[];    RETURN [nErrors = 0, nTokens, nErrors]    END;      ExpandStack: PROCEDURE [delta: CARDINAL] =    BEGIN    sS, sL, sV: CARDINAL;    p: LONG POINTER;    newS: LONG DESCRIPTOR FOR ARRAY OF State;    newL: LONG DESCRIPTOR FOR ARRAY OF CARDINAL;    newV: LONG DESCRIPTOR FOR ARRAY OF LONG UNSPECIFIED;    newSize: CARDINAL = stackSize + delta;    sS ¬ newSize*SIZE[State];    sL ¬ newSize*SIZE[CARDINAL];    sV ¬ newSize*SIZE[LONG UNSPECIFIED];    p ¬ MSegment.GetWords[sS+sL+sV];    newS ¬ DESCRIPTOR[p, newSize];    newL ¬ DESCRIPTOR[p+sS, newSize];    newV ¬ DESCRIPTOR[p+sS+sL, newSize];    IF stackSize # 0 THEN      BEGIN      Inline.LongCOPY[from: BASE[s], nwords: stackSize, to: BASE[newS]];      Inline.LongCOPY[from: BASE[l], nwords: stackSize, to: BASE[newL]];      Inline.LongCOPY[from: BASE[v], nwords: stackSize*2, to: BASE[newV]];      EraseStack[];      END;    s ¬ newS;  l ¬ newL;  v ¬ newV;  stackSize ¬ newSize;    END;      EraseStack: PROCEDURE =    {IF stackSize # 0 THEN {stackSize ¬ 0; MSegment.FreeWords[BASE[s]]}};      ExpandQueue: PROCEDURE [delta: CARDINAL] =    BEGIN    newQ: LONG DESCRIPTOR FOR ARRAY OF ActionEntry;    newSize: CARDINAL = queueSize + delta;    newQ ¬ DESCRIPTOR[MSegment.GetWords[      newSize*SIZE[ActionEntry]], newSize];    IF queueSize # 0 THEN      BEGIN      Inline.LongCOPY[from: BASE[q], nwords: newSize, to: BASE[newQ]];      EraseQueue[];      END;    q ¬ newQ;  queueSize ¬ newSize;    END;      EraseQueue: PROCEDURE =    {IF queueSize # 0 THEN {queueSize ¬ 0; MSegment.FreeWords[BASE[q]]}};    END.
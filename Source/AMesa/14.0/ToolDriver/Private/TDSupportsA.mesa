-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- TDSupportsA.mesa - last edit:-- Mark		Mar 18, 1981 5:57 PM-- Mike		25-Jan-82 11:06:54-- RXJ     	12-Nov-82  9:18:27-- RXR   	 7-Jan-83 14:38:10-- Support routines for the interpreter.DIRECTORY  FormSW USING [ModifyEditable, nullIndex, SetTypeIn],  FormSWDriver USING [    BuiltInFromItem, BuiltInToString, BuiltInValue, Error, FindFormSWItem,     ItemSpecObject, SBuiltIn, StringToBuiltIn],  Heap USING [systemZone],  Inline USING [HighHalf, LowHalf],  List USING [    AddAtHead, Delete, Enumerate, EnumerateProcType, Simple,     SimpleCreate, SimpleNode],  Menu USING [Error, Handle, MCRForKeyword, MCRType],  MFile USING [Acquire, Error, Handle, GetTimes, Release, ReleaseData],   MsgSW USING [LastLine],  Put USING [Text],  ParseTable USING [    tokenCallAC, tokenCallAS, tokenCallAT, tokenCallCD, tokenCallFC, tokenCallIM,     tokenCallIV, tokenCallLM, tokenCallMI, tokenCallPause, tokenCallSDS, tokenCallSSel,     tokenCallSStr, tokenCallSWB, tokenCallWait, tokenCallWOT],  Selection USING [ActOnProcType, ConvertProcType, Set],  String USING [    AppendOctal, AppendString, CopyToNewString, EqualStrings, EquivalentStrings,    SubStringDescriptor],  StringExtra USING [StringFromSubString],  Runtime USING [CallDebugger],  TajoMisc USING [SetState, WaitMilliSecs],  TDParseOps USING [ParseError, ToolNotRegistered],  TDSupportOps USING [    defaultSubwindow, defaultTool, FormSWItem, Handle, IOMode, lGlobalTop, Stack,    StackPtr],  Time USING [Current, Packed],  TIP USING [GetPlace],  ToolDriverOps USING [Error, FindSubwindow, FindWindow, Pause, wh],  ToolWindow USING [Box, GetState, Handle, MakeSize, SetBox],  UserInput USING [StuffString, UserAbort],  UserInputOps USING [DoNextPeriodicCall],  Window USING [    Box, GetChild, GetParent, Handle, rootWindow, Root, Stack, ValidateTree];  TDSupportsA: PROGRAM  IMPORTS    FormSW, FormSWDriver, List, Heap, Inline, Menu, MFile, MsgSW, Put, Runtime,    Selection, String, StringExtra, TajoMisc, TDParseOps, TDSupportOps, Time, TIP,    ToolDriverOps, ToolWindow, UserInput, UserInputOps, Window  EXPORTS TDSupportOps =  BEGIN OPEN TDSupportOps;  -- TYPEs  ClientFunction: TYPE = LONG POINTER TO ClientFunctionObject;  ClientFunctionObject: TYPE = MACHINE DEPENDENT RECORD [    next: ClientFunction,    name: LONG STRING,    function: PROCEDURE];    -- Global data  interpreterStack: PUBLIC LONG POINTER TO Stack ¬ NIL;  stackPtr: PUBLIC StackPtr ¬ FIRST[StackPtr];  -- Points to current    clientFunctions: List.Simple ¬ List.SimpleCreate[];  -- Coercion  CFToSN: PROCEDURE [cf: ClientFunction] RETURNS [List.SimpleNode] = INLINE    BEGIN RETURN[LOOPHOLE[cf, List.SimpleNode]]; END;      SNToCF: PROCEDURE [sn: List.SimpleNode] RETURNS [ClientFunction] = INLINE    BEGIN RETURN[LOOPHOLE[sn, ClientFunction]]; END;    -- Non PGS procedures to handle interpreter stack  DecrStackPtr: PUBLIC PROCEDURE =    BEGIN    IF stackPtr > FIRST[StackPtr] THEN stackPtr ¬ stackPtr - 1    ELSE TDParseOps.ParseError[lGlobalTop];    END;      IncrStackPtr: PUBLIC PROCEDURE =    BEGIN    IF stackPtr = LAST[StackPtr] THEN TDParseOps.ParseError[lGlobalTop]    ELSE stackPtr ¬ stackPtr + 1;    END;      Pop: PUBLIC PROCEDURE RETURNS [h: Handle] =    BEGIN    h ¬ @interpreterStack[stackPtr];    DecrStackPtr[];    END;      PopBool: PUBLIC PROCEDURE RETURNS [b: BOOLEAN] =    BEGIN    WITH node: interpreterStack[stackPtr] SELECT FROM      builtIn =>	WITH bi: node.b SELECT node.b.type FROM	  boolean => b ¬ bi.b;	  ENDCASE => ERROR TDParseOps.ParseError[lGlobalTop];      ENDCASE => ERROR TDParseOps.ParseError[lGlobalTop];    DecrStackPtr[];    END;      PopFormSWItem: PUBLIC PROCEDURE RETURNS [pf: LONG POINTER TO FormSWItem] =    BEGIN    WITH node: interpreterStack[stackPtr] SELECT FROM      formSWItem => pf ¬ @node.pi;      ENDCASE => ERROR TDParseOps.ParseError[lGlobalTop];    DecrStackPtr[];    END;      PopNumber: PUBLIC PROCEDURE [exactRepOnly: BOOLEAN] RETURNS [c: CARDINAL] =    BEGIN    sbi: string FormSWDriver.BuiltInValue ¬      [type: string, body: string[s: NIL, inHeap: FALSE]];    cbi: cardinal FormSWDriver.BuiltInValue ¬ [type: cardinal, body: cardinal[c: 0]];    BEGIN    WITH node: interpreterStack[stackPtr] SELECT FROM      builtIn =>	WITH bi: node.b SELECT node.b.type FROM	  cardinal => {c ¬ bi.c; GOTO DontTransform};	  string =>	    IF exactRepOnly THEN GOTO Error	    ELSE {sbi.s ¬ bi.s; bi.s ¬ NIL; sbi.inHeap ¬ bi.inHeap};	      -- must set bi.s or confuse CleanupStorage if UNWIND	  ENDCASE => IF exactRepOnly THEN GOTO Error	    ELSE FormSWDriver.BuiltInToString[@node.b, @sbi];      formSWItem => IF exactRepOnly THEN GOTO Error ELSE	BEGIN	formSWItem: FormSWDriver.ItemSpecObject;	formSWItem ¬ LocateFormSWItem[@node.pi];	FreeFormSWItem[@node.pi];	WITH item: formSWItem.item SELECT FROM	  longNumber =>	    BEGIN	    IF Inline.HighHalf[item.value­] # 0 THEN GOTO Error;	    c ¬ Inline.LowHalf[item.value­];	    GOTO DontTransform;	    END;	  number => {c ¬ item.value­; GOTO DontTransform};	  string => sbi.s ¬ item.string­;	  ENDCASE =>	    BEGIN	    temp: FormSWDriver.BuiltInValue;	    FormSWDriver.BuiltInFromItem[@temp, formSWItem.item];	    FormSWDriver.BuiltInToString[@temp, @sbi];	    END;	END;      ENDCASE => GOTO Error;    FormSWDriver.StringToBuiltIn[sbi.s, sbi.inHeap, @cbi !      UNWIND => IF sbi.inHeap THEN Heap.systemZone.FREE[@sbi.s]];    c ¬ cbi.c;    EXITS DontTransform => NULL;    END;    DecrStackPtr[];    EXITS Error => ERROR TDParseOps.ParseError[lGlobalTop];    END;      PopString: PUBLIC PROCEDURE RETURNS [sbi: FormSWDriver.SBuiltIn] =    BEGIN    WITH node: interpreterStack[stackPtr] SELECT FROM      builtIn =>	WITH bi: node.b SELECT node.b.type FROM	  string => sbi ¬ @bi;	  ENDCASE => ERROR TDParseOps.ParseError[lGlobalTop];      ENDCASE => ERROR TDParseOps.ParseError[lGlobalTop];    DecrStackPtr[];    END;      PopSW: PUBLIC PROCEDURE RETURNS [sw: Window.Handle] =    BEGIN    toolSW: LONG POINTER TO FormSWItem ¬ PopFormSWItem[];    BEGIN ENABLE UNWIND => FreeFormSWItem[toolSW];    SELECT toolSW.idCount FROM      1 => sw ¬ LocateSW[NIL, toolSW.tag];      2 => sw ¬ LocateSW[toolSW.sw, toolSW.tag];      ENDCASE => ERROR TDParseOps.ParseError[lGlobalTop];    END;    FreeFormSWItem[toolSW];    END;      PushBool: PUBLIC PROCEDURE [b: BOOLEAN] =    BEGIN    biv: FormSWDriver.BuiltInValue ¬ [type: boolean, body: boolean[b: b]];    IncrStackPtr[];    interpreterStack[stackPtr] ¬ [builtIn [b: biv]];    END;      PushFormSWItem: PUBLIC PROCEDURE [pp: LONG POINTER TO FormSWItem] =    BEGIN    IncrStackPtr[];    interpreterStack[stackPtr] ¬ [formSWItem [pi: pp­]];    END;      PushNumber: PUBLIC PROCEDURE [c: CARDINAL] =    BEGIN    cbiv: FormSWDriver.BuiltInValue ¬ [type: cardinal, body: cardinal[c: c]];    IncrStackPtr[];    interpreterStack[stackPtr] ¬ [builtIn [b: cbiv]];    END;      PushString: PUBLIC PROCEDURE [str: LONG STRING, inHeap: BOOLEAN] =    BEGIN    sbiv: FormSWDriver.BuiltInValue ¬ [      type: string, body: string[s: str, inHeap: inHeap]];    IncrStackPtr[];    interpreterStack[stackPtr] ¬ [builtIn [b: sbiv]];    END;    -- Non PGS procedures; built-in functions  ActivateTool: PUBLIC PROCEDURE =    BEGIN    s: FormSWDriver.SBuiltIn;    menu: Menu.Handle;    index: CARDINAL;    mcr: Menu.MCRType;    s ¬ PopString[];    IF s.s = NIL THEN ERROR TDParseOps.ParseError[lGlobalTop];    [mcr, menu, index] ¬ Menu.MCRForKeyword[      Window.rootWindow, "Inactive"L, s.s !	Menu.Error => IF code = notInstantiated THEN	  {index ¬ LAST[CARDINAL]; CONTINUE}];    IF index # LAST[CARDINAL] THEN mcr[Window.rootWindow, menu, index];    IF s.inHeap THEN Heap.systemZone.FREE[@s.s];    END;      AppendIO: PUBLIC PROCEDURE [mode: IOMode] =    BEGIN    new: LONG STRING ¬ NIL;    manufactured: BOOLEAN ¬ FALSE;    sw: Window.Handle;    h: Handle;    -- Order of next two assignments is crucial!    h ¬ Pop[]; sw ¬ PopSW[];    [manufactured, new] ¬ StringFromHandle[h];    BEGIN ENABLE UNWIND => IF manufactured THEN Heap.systemZone.FREE[@new];    IF mode = in THEN [] ¬ UserInput.StuffString[sw, new] ELSE Put.Text[sw, new];    END;    IF manufactured THEN Heap.systemZone.FREE[@new];    END;      BuiltInFunction: PUBLIC PROCEDURE [index: UNSPECIFIED] =    BEGIN OPEN PT: ParseTable;    SELECT index FROM      PT.tokenCallAC => AppendIO[in];      PT.tokenCallAS => AppendIO[out];      PT.tokenCallAT => ActivateTool[];      PT.tokenCallCD => CallDebugger[];      PT.tokenCallFC => BEGIN PushBool[FileCreated[]]; GOTO AlreadyPushedValue; END;      PT.tokenCallIM => InvokeMCR[];      PT.tokenCallIV => BEGIN IsVisible[]; GOTO AlreadyPushedValue; END;      PT.tokenCallLM =>	BEGIN PushString[LastMessage[], TRUE]; GOTO AlreadyPushedValue; END;      PT.tokenCallMI => ModifyItem[];      PT.tokenCallPause => BEGIN Pause[]; GOTO AlreadyPushedValue; END;      PT.tokenCallSDS => SetDisplayState[];      PT.tokenCallSSel => SetSelection[];      PT.tokenCallSStr => BEGIN PushString[SubString[], TRUE]; GOTO AlreadyPushedValue; END;      PT.tokenCallSWB => SetWindowBox[];      PT.tokenCallWait => Wait[];      PT.tokenCallWOT => WindowOnTop[];      ENDCASE => ERROR ToolDriverOps.Error[noClientFunction, "A built-in"L];    PushString[NIL, TRUE];  -- The default function value    EXITS      AlreadyPushedValue => NULL;    END;      CallDebugger: PUBLIC PROCEDURE =    BEGIN    s: FormSWDriver.SBuiltIn ¬ PopString[];    Runtime.CallDebugger[IF s.s = NIL THEN "ToolDriver script call."L ELSE s.s];    IF s.inHeap THEN Heap.systemZone.FREE[@s.s];    END;      EscapeCall: PUBLIC PROCEDURE [functionName: LONG STRING] =    BEGIN    cf: ClientFunction ¬ FindCF[functionName];    IF cf = NIL THEN ERROR ToolDriverOps.Error[noClientFunction, functionName]    ELSE cf.function[];    END;      FileCreated: PUBLIC PROCEDURE RETURNS [exists: BOOLEAN] =    BEGIN    h: Handle;    fileName: LONG STRING ¬ NIL;    manufactured: BOOLEAN ¬ FALSE;    delta: CARDINAL;    exists ¬ FALSE;    -- Order of following Pop's is crucial!    delta ¬ PopNumber[FALSE];     h ¬ Pop[];    [manufactured, fileName] ¬ StringFromHandle[h];    IF fileName # NIL THEN      BEGIN      diff: LONG CARDINAL;      releaseData: MFile.ReleaseData ¬ [];      mfh: MFile.Handle ¬ NIL;            BEGIN ENABLE UNWIND => IF manufactured THEN Heap.systemZone.FREE[@fileName];      create: Time.Packed;      mfh ¬ MFile.Acquire[name: fileName, access: anchor,       release: releaseData !MFile.Error => GOTO Lose;];      create ¬ MFile.GetTimes[mfh].create;            diff ¬ Time.Current[] - create;      exists ¬ (Inline.HighHalf[diff] = 0 AND Inline.LowHalf[diff] <= delta);      MFile.Release[mfh];      EXITS Lose => NULL;      END;      IF manufactured THEN Heap.systemZone.FREE[@fileName];      END;    END;      InvokeMCR: PUBLIC PROCEDURE =    BEGIN    menuName, keyword: FormSWDriver.SBuiltIn;    BEGIN    sw: Window.Handle;    menu: Menu.Handle;    index: CARDINAL;    mcr: Menu.MCRType;    -- Order of next three assignments is crucial!    keyword ¬ PopString[]; menuName ¬ PopString[]; sw ¬ PopSW[];    IF keyword.s = NIL OR menuName.s = NIL THEN GOTO Error;    [mcr, menu, index] ¬ Menu.MCRForKeyword[sw, menuName.s, keyword.s !      Menu.Error => GOTO Error];    mcr[sw, menu, index];    IF keyword.inHeap THEN Heap.systemZone.FREE[@keyword.s];    IF menuName.inHeap THEN Heap.systemZone.FREE[@menuName.s];    EXITS      Error =>	BEGIN	msg: STRING ¬ [100];	AppendNameAndValue[msg, "Menu"L, menuName.s, FALSE];	AppendNameAndValue[msg, "item"L, keyword.s, TRUE];	AppendErrorLoc[msg];	ERROR ToolDriverOps.Error[noSuchItem, msg];	END;    END;    END;      IsVisible: PUBLIC PROCEDURE =    BEGIN    source: FormSWDriver.ItemSpecObject;    sourceTemp: LONG POINTER TO FormSWItem ¬ PopFormSWItem[];    source ¬ LocateFormSWItem[sourceTemp ! UNWIND => FreeFormSWItem[sourceTemp]];    FreeFormSWItem[sourceTemp];  -- PushBool will trash sourceTemp­    PushBool[~source.item.flags.invisible];    END;      LastMessage: PUBLIC PROCEDURE RETURNS [s: LONG STRING] =    BEGIN    sw: Window.Handle ¬ PopSW[];    ss: String.SubStringDescriptor;    MsgSW.LastLine[sw, @ss];     RETURN[StringExtra.StringFromSubString[@ss]];    END;      ModifyItem: PUBLIC PROCEDURE =    BEGIN    h: Handle;    source: FormSWDriver.ItemSpecObject;    sourceTemp: LONG POINTER TO FormSWItem ¬ NIL;    position, length: CARDINAL;    new: LONG STRING ¬ NIL;    manufactured: BOOLEAN ¬ FALSE;    -- Order of following Pop's is crucial!    h ¬ Pop[];    [manufactured, new] ¬ StringFromHandle[h];    BEGIN ENABLE UNWIND => IF manufactured THEN Heap.systemZone.FREE[@new];    length ¬ PopNumber[FALSE]; position ¬ PopNumber[FALSE];     sourceTemp ¬ PopFormSWItem[];    source ¬ LocateFormSWItem[sourceTemp ! UNWIND => FreeFormSWItem[sourceTemp]];    FreeFormSWItem[sourceTemp];    FormSW.SetTypeIn[source.sw, FormSW.nullIndex, 0];    FormSW.ModifyEditable[source.sw, source.index, position, length, new];    IF manufactured THEN Heap.systemZone.FREE[@new];    END;    END;      Pause: PUBLIC PROCEDURE =    BEGIN    msgNode: FormSWDriver.SBuiltIn;    msg: LONG STRING;    answer, mustFreeMsg, question: BOOLEAN;    -- Order of next two assignments is crucial!    question ¬ PopBool[]; msgNode ¬ PopString[];    -- Save msgNode data in case of PushBool, which will trash msgNode­    IF (msg ¬ msgNode.s) = NIL THEN GOTO Error;    mustFreeMsg ¬ msgNode.inHeap;    answer ¬ SIGNAL ToolDriverOps.Pause[msg, question];    IF question THEN PushBool[answer] ELSE PushString[NIL, TRUE];    IF mustFreeMsg THEN Heap.systemZone.FREE[@msg];    EXITS      Error => ERROR TDParseOps.ParseError[lGlobalTop];    END;      SetDisplayState: PUBLIC PROCEDURE =    BEGIN    s: FormSWDriver.SBuiltIn ¬ PopString[];    error: BOOLEAN ¬ FALSE;    SELECT TRUE FROM      String.EquivalentStrings[s.s, "On"L] => [] ¬ TajoMisc.SetState[on];      String.EquivalentStrings[s.s, "Off"L] => [] ¬ TajoMisc.SetState[off];      String.EquivalentStrings[s.s, "Disconnected"L] =>	[] ¬ TajoMisc.SetState[disconnected];      ENDCASE => error ¬ TRUE;    IF s.inHeap THEN Heap.systemZone.FREE[@s.s];    IF error THEN ERROR TDParseOps.ParseError[lGlobalTop];    END;      SetSelection: PUBLIC PROCEDURE =    BEGIN    s: FormSWDriver.SBuiltIn ¬ PopString[];    Selection.Set[      IF s.inHeap THEN s.s ELSE String.CopyToNewString[s.s, Heap.systemZone],      ConvertSelection, ActOnSelection];    END;      SetWindowBox: PUBLIC PROCEDURE =    BEGIN    toolSW: LONG POINTER TO FormSWItem ¬ NIL;    toolRegistered: BOOLEAN;    Cleanup: PUBLIC PROCEDURE =      BEGIN IF toolSW # NIL THEN FreeFormSWItem[toolSW]; END;    BEGIN        window: Window.Handle;	windowBox: Window.Box;    BoxIndex: TYPE = {x, y, w, h};    i: BoxIndex;    box: ARRAY BoxIndex OF INTEGER;    FOR i DECREASING IN BoxIndex DO      box[i] ¬ PopNumber[FALSE];      ENDLOOP;    windowBox ¬ [place: [x: box[x], y: box[y]], dims: [w: box[w], h: box[h]]];    toolSW ¬ PopFormSWItem[];    IF toolSW.idCount # 1 THEN GOTO ParseError;    [window, toolRegistered] ¬ ToolDriverOps.FindWindow[toolSW.tag];    IF ~toolRegistered THEN GOTO NoTool;    IF window = NIL THEN GOTO ParseError;    IF ToolWindow.GetState[window] = tiny THEN      ToolWindow.MakeSize[window, normal];    ToolWindow.SetBox[window, windowBox];    Cleanup[];    EXITS      ParseError => {Cleanup[]; ERROR TDParseOps.ParseError[lGlobalTop]};      NoTool => {Cleanup[]; ERROR TDParseOps.ToolNotRegistered[lGlobalTop]};    END;    END;      SubString: PUBLIC PROCEDURE RETURNS [s: LONG STRING] =    BEGIN    h: Handle;    ss: String.SubStringDescriptor;    manufactured: BOOLEAN;    -- Order of next three assignments is crucial!    ss.length ¬ PopNumber[FALSE]; ss.offset ¬ PopNumber[FALSE]; h ¬ Pop[];    [manufactured, ss.base] ¬ StringFromHandle[h];    IF ss.base = NIL THEN RETURN[NIL];    IF ss.base.length = 0 THEN s ¬ NIL    ELSE      BEGIN      IF ss.offset >= ss.base.length THEN ss.offset ¬ ss.base.length-1;      IF ss.length+ss.offset > ss.base.length THEN ss.length ¬ ss.base.length - ss.offset;      s ¬ StringExtra.StringFromSubString[@ss];      END;    IF manufactured THEN Heap.systemZone.FREE[@ss.base];    END;      Wait: PUBLIC PROCEDURE =    BEGIN    n: CARDINAL = PopNumber[FALSE];    IF n = 0 THEN ERROR TDParseOps.ParseError[lGlobalTop]    ELSE      THROUGH [0..n*10) DO        --Only check for UserAbort in ToolDriver window	IF UserInput.UserAbort[ToolDriverOps.wh] THEN EXIT;	TajoMisc.WaitMilliSecs[100];	UserInputOps.DoNextPeriodicCall[TIP.GetPlace[Window.Root[]]];  -- kludge	ENDLOOP;    END;      WindowOnTop: PUBLIC PROCEDURE =    BEGIN    window: Window.Handle ¬ NIL;    child: Window.Handle;    toolSW: LONG POINTER TO FormSWItem ¬ PopFormSWItem[];    toolRegistered: BOOLEAN ¬ TRUE;    IF toolSW.idCount = 1 THEN      [window, toolRegistered] ¬ ToolDriverOps.FindWindow[toolSW.tag];    FreeFormSWItem[toolSW];    IF ~toolRegistered THEN ERROR TDParseOps.ToolNotRegistered[lGlobalTop];    IF window = NIL THEN ERROR TDParseOps.ParseError[lGlobalTop];    IF (child ¬ Window.GetChild[Window.GetParent[window]]) # window THEN      BEGIN      Window.Stack[window, child];      Window.ValidateTree[];      END;    END;    -- Non PGS procedures; random utilities  ActOnSelection: Selection.ActOnProcType =    BEGIN    s: LONG STRING ¬ data;    SELECT action FROM      clear => Heap.systemZone.FREE[@s];      ENDCASE;    END;      AddClientProcedure: PUBLIC PROCEDURE [name: LONG STRING, proc: PROCEDURE] =    BEGIN    cf: ClientFunction ¬ Heap.systemZone.NEW[ClientFunctionObject];    cf­ ¬ [next: NULL, name: name, function: proc];    List.AddAtHead[clientFunctions, CFToSN[cf]];    END;      CleanupStorage: PUBLIC PROCEDURE =    BEGIN    Heap.systemZone.FREE[@defaultTool];    Heap.systemZone.FREE[@defaultSubwindow];    IF interpreterStack # NIL AND stackPtr > FIRST[StackPtr] THEN      BEGIN      i: StackPtr;      FOR i IN (FIRST[StackPtr]..stackPtr] DO	WITH h: interpreterStack[i] SELECT FROM	  formSWItem => FreeFormSWItem[@h.pi];	  builtIn =>	    WITH bi: h.b SELECT h.b.type FROM	      string => IF bi.inHeap THEN Heap.systemZone.FREE[@bi.s];	      ENDCASE;	  ENDCASE;	ENDLOOP;      END;    Heap.systemZone.FREE[@interpreterStack];    stackPtr ¬ FIRST[StackPtr];    END;      ConvertSelection: Selection.ConvertProcType =    BEGIN    s: LONG STRING ¬ data;    SELECT target FROM      length =>	BEGIN	p: LONG POINTER TO LONG CARDINAL ¬  Heap.systemZone.NEW[LONG CARDINAL];	p­ ¬ s.length;	RETURN[p]	END;      string => RETURN[String.CopyToNewString[s, Heap.systemZone]];      ENDCASE;    RETURN[NIL]    END;      DeleteClientProcedure: PUBLIC PROCEDURE [name: LONG STRING] =    BEGIN    cf: ClientFunction ¬ FindCF[name];    IF cf = NIL THEN ERROR ToolDriverOps.Error[noClientFunction, name]    ELSE      BEGIN      Heap.systemZone.FREE[@cf.name];      List.Delete[clientFunctions, CFToSN[cf]];      END;    END;      FindCF: PROCEDURE [name: LONG STRING] RETURNS [ClientFunction] =    BEGIN    CheckName: List.EnumerateProcType =      {done ¬ String.EquivalentStrings[SNToCF[prev].next.name, name]};    RETURN[SNToCF[List.Enumerate[clientFunctions, CheckName, forward]]];    END;      FreeFormSWItem: PUBLIC PROCEDURE [pp: LONG POINTER TO FormSWItem] =    BEGIN    Heap.systemZone.FREE[@pp.tool];    Heap.systemZone.FREE[@pp.sw];    Heap.systemZone.FREE[@pp.tag];    END;      InitStmtState: PUBLIC PROCEDURE =    BEGIN    IF stackPtr # FIRST[StackPtr] THEN ERROR TDParseOps.ParseError[lGlobalTop];    IF UserInput.UserAbort[ToolDriverOps.wh] THEN ERROR ABORTED;    END;      LocateFormSWItem: PUBLIC PROCEDURE [pp: LONG POINTER TO FormSWItem]    RETURNS [dest: FormSWDriver.ItemSpecObject] =    BEGIN    dest.sw ¬ LocateSW[pp.tool, pp.sw];    IF pp.tag = NIL THEN GOTO Error;    [dest.item, dest.index] ¬ FormSWDriver.FindFormSWItem[dest.sw, pp.tag !      FormSWDriver.Error => GOTO Error];    EXITS      Error => RaiseNoSuchItem[	IF pp.tool = NIL THEN defaultTool ELSE pp.tool,	IF pp.sw = NIL THEN defaultSubwindow ELSE pp.sw,	pp.tag];    END;      LocateSW: PUBLIC PROCEDURE [tool, subwindow: LONG STRING]    RETURNS [sw: Window.Handle] =    BEGIN    IF tool = NIL THEN tool ¬ defaultTool;    IF subwindow = NIL THEN subwindow ¬ defaultSubwindow;    IF tool = NIL OR subwindow = NIL THEN GOTO Error;    sw ¬ ToolDriverOps.FindSubwindow[tool, subwindow];    IF sw = NIL THEN GOTO Error;    EXITS      Error => RaiseNoSuchTool[tool, subwindow];    END;      ReservedNames: PUBLIC PROCEDURE [    sourceTemp: Handle, destTemp: LONG POINTER TO FormSWItem]    RETURNS [set: BOOLEAN] =    -- Consumes sourceTemp and destTemp's LONG STRINGs iff set    BEGIN    ps: LONG POINTER TO LONG STRING;    SELECT TRUE FROM      destTemp.idCount # 1 => RETURN[FALSE];      String.EqualStrings[destTemp.tag, "TOOL"L] =>	ps ¬ @defaultTool;      String.EqualStrings[destTemp.tag, "SUBWINDOW"L] =>	ps ¬ @defaultSubwindow;      ENDCASE => RETURN[FALSE];    Heap.systemZone.FREE[@destTemp.tag];    WITH source: sourceTemp SELECT FROM      builtIn =>	WITH bi: source.b SELECT source.b.type FROM	  string => {ps­ ¬ bi.s; bi.s ¬ NIL; RETURN[TRUE]};	  ENDCASE;      ENDCASE;    TDParseOps.ParseError[lGlobalTop];    END;      StringFromHandle: PUBLIC PROCEDURE [sourceHandle: Handle]    RETURNS [manufactured: BOOLEAN, str: LONG STRING] =    BEGIN    WITH source: sourceHandle SELECT FROM      formSWItem =>	BEGIN	formSWItem: FormSWDriver.ItemSpecObject;	formSWItem ¬ LocateFormSWItem[@source.pi];	FreeFormSWItem[@source.pi];	WITH item: formSWItem.item SELECT FROM	  string => RETURN[FALSE, item.string­];	  ENDCASE =>	    BEGIN	    temp: FormSWDriver.BuiltInValue;	    sbi: string FormSWDriver.BuiltInValue;	    FormSWDriver.BuiltInFromItem[@temp, formSWItem.item];	    sbi.s ¬ NIL;	    sbi.inHeap ¬ FALSE;	    FormSWDriver.BuiltInToString[@temp, @sbi];	    RETURN[sbi.inHeap, sbi.s];	    END;	END;      builtIn =>	WITH bi: source.b SELECT source.b.type FROM	  string =>	    BEGIN	    str ¬ bi.s; bi.s ¬ NIL;	    RETURN[bi.inHeap, str];	    END;	  ENDCASE =>	    BEGIN	    sbi: string FormSWDriver.BuiltInValue;	    sbi.s ¬ NIL;	    sbi.inHeap ¬ FALSE;	    FormSWDriver.BuiltInToString[@source.b, @sbi];	    RETURN[sbi.inHeap, sbi.s];	    END;      ENDCASE => GOTO Error;    EXITS      Error => ERROR TDParseOps.ParseError[lGlobalTop];    END;    -- Error reporting  AppendErrorLoc: PUBLIC PROCEDURE [msg: LONG STRING] =    BEGIN OPEN String;    AppendString[msg, " unknown at ["L];    AppendOctal[msg, lGlobalTop];    AppendString[msg, "]"L];    END;      AppendNameAndValue: PUBLIC PROCEDURE [msg, name, value: LONG STRING, needComma: BOOLEAN] =    BEGIN OPEN String;    IF needComma THEN AppendString[msg, ", "L];    AppendString[msg, name];    AppendString[msg, ": "L];    AppendString[msg, IF value = NIL THEN "NIL"L ELSE value];    END;      AppendToolAndSubwindow: PUBLIC PROCEDURE [msg, tool, subwindow: LONG STRING] =    BEGIN OPEN String;    AppendNameAndValue[msg, "Tool"L, tool, FALSE];    AppendNameAndValue[msg, "subwindow"L, subwindow, TRUE];    END;      RaiseNoSuchItem: PUBLIC PROCEDURE [tool, subwindow, tag: LONG STRING] =    BEGIN    msg: STRING ¬ [100];    AppendToolAndSubwindow[msg, tool, subwindow];    AppendNameAndValue[msg, "item"L, tag, TRUE];    AppendErrorLoc[msg];    ERROR ToolDriverOps.Error[noSuchItem, msg];    END;      RaiseNoSuchTool: PUBLIC PROCEDURE [tool, subwindow: LONG STRING] =    BEGIN    msg: STRING ¬ [100];    AppendToolAndSubwindow[msg, tool, subwindow];    AppendErrorLoc[msg];    ERROR ToolDriverOps.Error[noSuchTool, msg];    END;        END.
-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- ToolDriverExec.mesa - last edit:-- Mark		Mar 18, 1981 4:46 PM-- Mike		11-Mar-82 16:43:35-- RXJ     	11-Nov-82 17:22:02-- LXR    	 1-Mar-84 14:03:57-- RXR   	 7-Jan-83 15:34:41-- AXD    	18-Jan-84 15:34:38-- DWR    	30-Nov-84 14:21:50-- User interface to Tool Driver facilitiesDIRECTORY  Context USING [DestroyProcType],  Cursor USING [Fetch, GetInfo, Object, Set, Store],  Exec USING [AddCommand, ExecProc, FreeTokenString, GetToken],  Heap USING [systemZone],  Menu USING [Handle, Instantiate, Make, MCRType],  MFile USING [Acquire, Error, Handle, ReleaseData, SetAccess],  MStream USING[Create, ReleaseData],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,     line0, ModifyEditable, ProcType, StringItem, ToggleVisibility],  FormSWDriver USING [Error, KnownType, TypeMismatch],  Format USING [StringProc],  Profile USING [debugging],  Put USING [Line, Octal, Text],  Stream USING [Delete, Handle],  String USING [AppendString, CopyToNewString, Length, SubStringDescriptor],  StringExtra USING [IsItAFileNameChar, NextFilteredStringInSS],  TajoMisc USING [SetToolDriverRunning],  TajoOps USING [Notifier],  TDParseOps USING [Parse, ParseError, SyntaxError, ToolNotRegistered],  TDSupportOps USING [lGlobalTop],  Tool USING [    Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolDriverOps USING [    AnotherStepDone, Error, ErrorCode, Pause, registryStream],  ToolWindow USING [Activate, GetState, TransitionProcType],  UserInput USING [    CreatePeriodicNotify, Error, PeriodicNotifyHandle, PeriodicProcType,    ReturnToNotifier, WaitForConfirmation],  Version USING [Append],  Window USING [Handle];  ToolDriverExec: PROGRAM   IMPORTS    Cursor, Exec, FormSW, FormSWDriver, Heap, Menu, MFile, MStream,    Profile, Put, String, Stream, StringExtra, TajoMisc, TajoOps, TDParseOps,    TDSupportOps, Tool, ToolDriver, ToolDriverOps, ToolWindow, UserInput, Version  EXPORTS ToolDriverOps =  BEGIN  -- TYPEs  StringNames: TYPE = {script};    DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    -- Message subwindow stuff    msgSW (0): Window.Handle ¬ NIL,    -- File subwindow stuff    fileSW(2): Window.Handle ¬ NIL,    -- Form subwindow stuff    formSW(4): Window.Handle ¬ NIL,    strings(6): ARRAY StringNames OF LONG STRING ¬ NULL,    singleStep(8): BOOLEAN ¬ NULL,    noIndex (9): CARDINAL ¬ LAST[CARDINAL],    proceedIndex (10): CARDINAL ¬ LAST[CARDINAL],    yesIndex (11): CARDINAL ¬ LAST[CARDINAL],    scriptIndex (12): CARDINAL ¬ LAST[CARDINAL],   -- Misc    answer(13): BOOLEAN ¬ NULL];    -- Variable declarations  debugging: PUBLIC BOOLEAN ¬ FALSE;  initialScriptFile: LONG STRING ¬ NIL; -- this never gets set, but who's counting? [DWR]  toolData: DataHandle ¬ NIL;  wh: PUBLIC Window.Handle ¬ NIL;  -- Tool's window  -- Communication with the interpreter  AnotherStepDone: PUBLIC SIGNAL [stmtStart: CARDINAL] = CODE;    KeepOnTrucking: SIGNAL = CODE;    OnlyDoOneStep: PUBLIC PROCEDURE RETURNS [yes: BOOLEAN] =    BEGIN yes ¬ toolData.singleStep; END;      Pause: PUBLIC SIGNAL [msg: LONG STRING, question: BOOLEAN]    RETURNS [yes: BOOLEAN] = CODE;      AcquireOldFileOnly: PROCEDURE[name: LONG STRING] RETURNS[fH: MFile.Handle] =    BEGIN    mfrD: MFile.ReleaseData ¬ [];    RETURN[MFile.Acquire[name, anchor, mfrD]]    END;    -- Communication with the clients  ErrorDestroy: Context.DestroyProcType =    BEGIN    ERROR UserInput.Error[code: other];    --Was UserInput.CantGetHere;  not supposed to get here    END;    -- Menu support Routines  MenuCommandRoutine: Menu.MCRType =    BEGIN    SELECT index FROM      0 => FormSWCommandRoutine[toolData.formSW, NIL, 0];      ENDCASE => Put.Line[toolData.fileSW, "Bad command index."L];    END;    -- Error logging support routines  LogErrorAndLoc: PROCEDURE [sw: Window.Handle, prefix: LONG STRING, errorLoc: CARDINAL] =    BEGIN OPEN Put;    Text[sw, prefix]; Text[sw, " error at ["L]; Octal[sw, errorLoc]; Line[sw, "]"L];    END;      LogLGlobalTop: PROCEDURE [sw: Window.Handle] =    BEGIN OPEN Put;    Text[sw, " at ["L]; Octal[sw, TDSupportOps.lGlobalTop]; Line[sw, "]."L];    END;      LogKnownType: PROCEDURE [sw: Window.Handle, type: FormSWDriver.KnownType] =    BEGIN    Put.Text[sw, SELECT type FROM      boolean => "BOOLEAN"L,      cardinal => "CARDINAL"L,      character => "CHARACTER"L,      empty => "empty"L,      integer => "INTEGER"L,      pointer => "POINTER"L,      string => "STRING"L,      unspecified => "UNSPECIFIED"L,      longNumber => "LONG NUMBER"L,      longPointer => "LONG POINTER"L,      formSWItem => "formSW item"L,      unknown => "unknown"L,      ENDCASE => "*** ENDCASE ERROR ***"L];    END;      LogTDOError: PROCEDURE [sw: Window.Handle, code: ToolDriverOps.ErrorCode, msg: LONG STRING] =    BEGIN OPEN Put;    IF msg = NIL THEN      BEGIN      Text[sw, SELECT code FROM	malformedRegistry => "Tool.sws has bad format"L,	noSuchTool => "Unknown tool"L,	unknownName => "Tool.sws has an unknown subwindow"L,	ENDCASE => "ToolDriverOps.Error"L];      LogLGlobalTop[sw];      END    ELSE SELECT code FROM      noClientFunction =>	{Text[sw, "Unknown client function: "L]; Text[sw, msg]; LogLGlobalTop[sw]};      ENDCASE => Line[sw, msg];    END;    -- FormSW support Routines  FormSWCommandRoutine: PUBLIC FormSW.ProcType =    BEGIN    SELECT index FROM      toolData.noIndex, toolData.proceedIndex, toolData.yesIndex =>	{toolData.answer ¬ (index = toolData.yesIndex); ERROR KeepOnTrucking};      0 => ExecuteScripts[toolData.strings[script], toolData.fileSW, toolData.msgSW];      ENDCASE => Put.Line[toolData.fileSW, "Bad command index."L];    END;      ExecuteScripts: PROCEDURE [names: LONG STRING, fileSW, msgSW: Window.Handle] =    BEGIN    ssd: String.SubStringDescriptor ¬ [      base: names, offset: 0, length: String.Length[names]];    next: LONG STRING;    DO      IF (next ¬ StringExtra.NextFilteredStringInSS[	@ssd, StringExtra.IsItAFileNameChar]) = NIL THEN EXIT;      ExecuteScript[next, fileSW, msgSW];      Heap.systemZone.FREE[@next];      ENDLOOP;    END;      ExecuteScript: PROCEDURE [name: LONG STRING, fileSW, msgSW: Window.Handle] =    BEGIN    old: Cursor.Object;    source: Stream.Handle ¬ NIL;    mfh: MFile.Handle ¬ NIL;    msrD: MStream.ReleaseData ¬ [];          DeleteStream: PROCEDURE =      BEGIN      IF source # NIL THEN BEGIN        Stream.Delete[source];        source ¬ NIL;	mfh ¬ NIL;      END;      IF ToolDriverOps.registryStream # NIL THEN BEGIN        Stream.Delete[ToolDriverOps.registryStream];        ToolDriverOps.registryStream ¬ NIL;      END;      END;        BEGIN    Put.Line[msgSW, ""L];    Put.Line[fileSW, ""L];    IF source = NIL THEN      BEGIN      mfh ¬ AcquireOldFileOnly[name !MFile.Error =>        IF code = noSuchFile THEN	  BEGIN	  Put.Text[fileSW, IF name = NIL THEN "NIL"L ELSE name];	  Put.Line[fileSW, " - no such script file."L];	  GOTO Return;	END];      MFile.SetAccess[mfh, readOnly];	      source ¬ MStream.Create[mfh, msrD];      END;    Put.Text[fileSW, "Interpreting script file "L];    Put.Line[fileSW, name];    TajoMisc.SetToolDriverRunning[TRUE];    [] ¬ TDParseOps.Parse[source, ErrorMsg !      ABORTED => GOTO Aborted;      UserInput.ReturnToNotifier =>	{IF string # NIL THEN Put.Line[fileSW, string]; GOTO Aborted};      FormSWDriver.Error =>	BEGIN	SELECT code FROM	  noSuchEnumVal => Put.Text[fileSW, "Unknown enumerated value"L];	  noSuchItem => Put.Text[fileSW, "No such item"L];	  ENDCASE;	LogLGlobalTop[fileSW];	IF ~debugging THEN CONTINUE;	END;      FormSWDriver.TypeMismatch =>	BEGIN	Put.Text[fileSW, "Incompatible types.  Need "L];	LogKnownType[fileSW, dest];	Put.Text[fileSW, " but script has "L];	LogKnownType[fileSW, src];	LogLGlobalTop[fileSW];	IF ~debugging THEN CONTINUE;	END;      ToolDriverOps.AnotherStepDone =>	BEGIN	ok: BOOLEAN;	Cursor.Fetch[@old];	Cursor.Set[mouseRed];	Put.Text[msgSW, "Break at "L];	Put.Octal[msgSW, stmtStart];	Put.Line[msgSW, ", continue?"L];	ok ¬ UserInput.WaitForConfirmation[].okay;	IF Cursor.GetInfo[].type = mouseRed THEN Cursor.Store[@old];	IF ok THEN {Put.Line[msgSW, ""L]; RESUME}	ELSE	  BEGIN	  Put.Line[msgSW, "Aborted."L];	  IF debugging THEN	    SIGNAL ToolDriverOps.AnotherStepDone[LAST[CARDINAL]];	  CONTINUE;	  END;	END;      ToolDriverOps.Pause =>	BEGIN	toolData.answer ¬ FALSE;	Put.Line[msgSW, msg];	ToggleItems[toolData, question];	Cursor.Fetch[@old];	Cursor.Set[textPointer];	TajoMisc.SetToolDriverRunning[FALSE];	TajoOps.Notifier[FALSE !	  KeepOnTrucking => CONTINUE];  -- let user interact with us	TajoMisc.SetToolDriverRunning[TRUE];	Cursor.Store[@old];	ToggleItems[toolData, question];	Put.Line[msgSW, ""L];	RESUME[toolData.answer];	END;      ToolDriverOps.Error =>	BEGIN	LogTDOError[fileSW, code, msg];	IF ~debugging THEN CONTINUE;	END;      TDParseOps.ParseError =>	BEGIN	LogErrorAndLoc[fileSW, "Parser"L, errorLoc];	IF debugging THEN	  SIGNAL TDParseOps.ParseError[LAST[CARDINAL]];	CONTINUE;	END;      TDParseOps.SyntaxError =>	BEGIN	LogErrorAndLoc[fileSW, "Syntax"L, errorLoc];	IF debugging THEN	  SIGNAL TDParseOps.SyntaxError[LAST[CARDINAL]];	CONTINUE;	END;      TDParseOps.ToolNotRegistered =>	BEGIN	LogErrorAndLoc[fileSW, "Unregistered tool"L, errorLoc];	IF debugging THEN	  SIGNAL TDParseOps.ToolNotRegistered[LAST[CARDINAL]];	CONTINUE;	END];    Put.Line[fileSW, "Done."L];    TajoMisc.SetToolDriverRunning[FALSE];    DeleteStream[];    EXITS      Aborted =>	BEGIN	DeleteStream[];	TajoMisc.SetToolDriverRunning[FALSE];	Put.Line[msgSW, "Aborted."L];	Put.Line[fileSW, "Aborted."L];	ERROR UserInput.ReturnToNotifier[NIL];	END;      Return => DeleteStream[];    END;    END;      ErrorMsg: Format.StringProc = BEGIN Put.Text[toolData.fileSW, s]; END;    ToggleItems: PROCEDURE [toolData: DataHandle, question: BOOLEAN] =    BEGIN    FormSW.ToggleVisibility[toolData.formSW, 0];    IF question THEN      BEGIN      FormSW.ToggleVisibility[toolData.formSW, toolData.noIndex];      FormSW.ToggleVisibility[toolData.formSW, toolData.yesIndex];      END    ELSE FormSW.ToggleVisibility[toolData.formSW, toolData.proceedIndex];    END;    -- Tool needed routines  CallFormSWCommandRoutine: UserInput.PeriodicProcType =    -- a kamikaze periodic notifier    BEGIN      FormSWCommandRoutine[toolData.formSW, NIL, 0];    END;      ClientTransition: ToolWindow.TransitionProcType =    BEGIN     SELECT TRUE FROM      old = inactive =>	BEGIN	toolData ¬ Heap.systemZone.NEW[Data];	toolData­ ¬ [];	END;      new = inactive =>	IF toolData # NIL THEN	  BEGIN	  ToolDriver.RemoveSWs["ToolDriverExec"L];	  IF ToolDriverOps.registryStream # NIL THEN	   BEGIN            Stream.Delete[ToolDriverOps.registryStream];            ToolDriverOps.registryStream ¬ NIL;           END;	  Heap.systemZone.FREE[@toolData];	  END;      ENDCASE;    END;      Init: PROCEDURE =    BEGIN    toolsName: LONG STRING ¬ [50];    address: ARRAY [0..1) OF ToolDriver.Address ¬ [      ["execSW"L, NIL] ];    String.AppendString[to: toolsName, from: "Tool Driver Exec "L];    Version.Append[toolsName];    wh ¬ Tool.Create[makeSWsProc: MakeSWs,      initialState: IF initialScriptFile = NIL THEN default ELSE active,      clientTransition: ClientTransition,      name: toolsName, cmSection: "ToolDriver"L];    Exec.AddCommand["ToolDriver.~"L, ExecProc];    ToolDriver.NoteSWs["TajoExec"L, DESCRIPTOR[address]];    -- Note that Init is not called from the Notifier (hence it cannot call    --   FormSWCommandRoutine directly in case of a Pause[] in the script)    IF initialScriptFile # NIL THEN      [] ¬ UserInput.CreatePeriodicNotify[CallFormSWCommandRoutine, wh, 0];    END;      MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    nItems: CARDINAL = 7;    items ¬ AllocateItemDescriptor[nItems];    items[0] ¬ CommandItem[      tag: "Go"L, place: [0, line0], proc: FormSWCommandRoutine];    items[1] ¬ BooleanItem[      tag: "SingleStep"L, place: [30, line0], switch: @toolData.singleStep];    toolData.singleStep ¬ FALSE;    items[2] ¬ BooleanItem[      tag: "Debug"L, switch: @debugging];    debugging ¬ Profile.debugging;    items[toolData.proceedIndex ¬ 3] ¬ CommandItem[      tag: "Proceed"L, invisible: TRUE, proc: FormSWCommandRoutine];    items[toolData.yesIndex ¬ 4] ¬ CommandItem[      tag: "Yes"L, invisible: TRUE, proc: FormSWCommandRoutine];    items[toolData.noIndex ¬ 5] ¬ CommandItem[      tag: "No"L, invisible: TRUE, proc: FormSWCommandRoutine];    items[toolData.scriptIndex ¬ 6] ¬ StringItem[      tag: "Script"L, place: [250, line0], string: @toolData.strings[script],       inHeap: TRUE];    toolData.strings[script] ¬      IF initialScriptFile = NIL THEN String.CopyToNewString["Test.tds"L, Heap.systemZone]      ELSE initialScriptFile;    RETURN[items: items, freeDesc: TRUE];    END;      MakeSWs: Tool.MakeSWsProc =    BEGIN    addresses: ARRAY [0..3) OF ToolDriver.Address;    logName: LONG STRING ¬ [40];    menuStrings: ARRAY [0..1) OF LONG STRING ¬ [      "Go"L];    menu: Menu.Handle ¬ Menu.Make[name: "T.D. Exec"L,      strings: DESCRIPTOR[menuStrings], mcrProc: MenuCommandRoutine];    Tool.UnusedLogName[unused: logName, root: "TDE.log"L];    toolData.msgSW ¬ Tool.MakeMsgSW[window: window];    toolData.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    toolData.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    Menu.Instantiate[menu, window];    addresses ¬ [      ["msgSW"L, toolData.msgSW],      ["formSW"L, toolData.formSW],      ["fileSW"L, toolData.fileSW] ];    ToolDriver.NoteSWs["ToolDriverExec"L, DESCRIPTOR[addresses]];    END;      ExecProc: Exec.ExecProc =    BEGIN    script, switches: LONG STRING ¬ NIL;    [script, switches] ¬ Exec.GetToken[h];    switches ¬ Exec.FreeTokenString[switches];    IF ToolWindow.GetState[wh] = inactive THEN ToolWindow.Activate[wh];    IF script # NIL THEN {      FormSW.ModifyEditable[sw: toolData.formSW, index: toolData.scriptIndex,	position: 0, length: toolData.strings[script].length, new: script];      script ¬ Exec.FreeTokenString[script];      [] ¬ UserInput.CreatePeriodicNotify[proc: CallFormSWCommandRoutine, window: wh, rate: 0];    };    END;-- Mainline code  Init[];  -- this gets string out of global frame  END...LOGDWR    	30-Nov-84 14:00:03  The new Exec Command didn't work.  I fixed it.
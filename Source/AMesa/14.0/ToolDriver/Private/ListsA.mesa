-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- File: ListsA.mesa - last edit: -- Mark		Mar 1, 1981 2:10 PM-- Mike		29-Dec-81 15:50:37-- RXJ     	12-Nov-82  8:22:16-- The simple list support-- WARNING: The order of most of the code below is VERY sensitive!DIRECTORY  Heap USING [systemZone],  List USING [    ActOnNodeProcType, ActOnSuccProcType, AddAfterProcType, AddAtHead,     CreateProcType, DelinkSucc, DoubleNode, FindProcType,     Procs, ProcsObject, Simple, SimpleNode, SimpleNodeObject, SNToDN];  ListsA: PROGRAM  IMPORTS Heap, List  EXPORTS List =  BEGIN OPEN List;  -- Data TYPEs  ProcsImpl: TYPE = LONG POINTER TO ProcsObject;    SimpleImpl: TYPE = LONG POINTER TO SimpleImplObject;  -- Need this sooner or later  SimpleImplObject: TYPE = MACHINE DEPENDENT RECORD [    procs: Procs,    head, tail: SimpleNodeObject,    forward: BOOLEAN,    gap: [0..77777B]];    -- Might want password or MONITOR LOCK in an escalation.    -- Coercion  AbsToRep: PROCEDURE [abs: Simple] RETURNS [SimpleImpl] = INLINE    BEGIN RETURN[LOOPHOLE[abs]]; END;  RepToAbs: PROCEDURE [rep: SimpleImpl] RETURNS [Simple] = INLINE    BEGIN RETURN[LOOPHOLE[rep]]; END;      MakeReadOnly: PROCEDURE [procs: ProcsImpl] RETURNS [Procs] = INLINE    BEGIN RETURN[LOOPHOLE[procs]]; END;  MakeWritable: PROCEDURE [procs: Procs] RETURNS [ProcsImpl] = INLINE    BEGIN RETURN[LOOPHOLE[procs]]; END;    -- SIGNALs  NotFound: PUBLIC SIGNAL = CODE;  -- Initial/Finalization  CreateProcsObject: PROCEDURE [    addAfter: AddAfterProcType,     delinkSucc: ActOnSuccProcType,     find: FindProcType,    zone: UNCOUNTED ZONE ¬ NIL]    RETURNS [Procs] =    BEGIN    procs: ProcsImpl;    IF zone = NIL THEN zone ¬ Heap.systemZone;    procs ¬ zone.NEW[ProcsObject ¬ [addAfter: addAfter, delinkSucc: delinkSucc, find: find, zone: zone]];    RETURN[MakeReadOnly[procs]];    END;      DestroyProcsObject: PROCEDURE [procs: Procs] =    BEGIN    z: UNCOUNTED ZONE = procs.zone;    procsImpl: ProcsImpl ¬ MakeWritable[procs];    z.FREE[@procsImpl];    END;      DoubleCreate: PUBLIC CreateProcType =    BEGIN simple ¬ CreateListHead[AddAfterDImpl, DelinkSuccDImpl, FindDImpl, zone]; END;      EnableAutoForwarding: PUBLIC PROCEDURE [simple: Simple] =    BEGIN AbsToRep[simple].forward ¬ TRUE; END;      SimpleCreate: PUBLIC CreateProcType =    BEGIN    simple ¬ CreateListHead[AddAfterSImpl, DelinkSuccSImpl, FindSImpl, zone];    END;      SimpleDestroy: PUBLIC PROCEDURE [simple: Simple] =    BEGIN    z: UNCOUNTED ZONE = simple.procs.zone;    procsImpl: ProcsImpl ¬ MakeWritable[simple.procs];    node, temp: SimpleNode;    node ¬ simple.head.next;    WHILE node # NIL DO      temp ¬ node; node ¬ node.next; z.FREE[@temp];      ENDLOOP;    z.FREE[@procsImpl];    z.FREE[@simple];    END;      CreateListHead: PROCEDURE [    addAfter: AddAfterProcType,     delinkSucc: ActOnSuccProcType,     find: FindProcType,    zone: UNCOUNTED ZONE ¬ NIL]    RETURNS [Simple] =    BEGIN    simple: SimpleImpl;    IF zone = NIL THEN zone ¬ Heap.systemZone;    simple ¬ zone.NEW[SimpleImplObject ¬ [      procs: CreateProcsObject[addAfter, delinkSucc, find, zone],      head: [NIL], tail: [NIL], forward: FALSE, gap: 0]];    RETURN[RepToAbs[simple]];    END;    -- Addition  AddAfterDImpl: AddAfterProcType =    BEGIN    AddAfterSImpl[simple, node, new];    IF simple.tail.next = new THEN SNToDN[new].back ¬ node    ELSE      BEGIN      SNToDN[new].back ¬ SNToDN[new.next].back;      SNToDN[new.next].back ¬ new;      END;    END;      AddAfterSImpl: AddAfterProcType =    BEGIN    temp: SimpleNode = (IF node = NIL THEN @simple.head ELSE node);    new.next ¬ temp.next;    temp.next ¬ new;    IF simple.tail.next = node THEN simple.tail.next ¬ new;    END;    -- Reordering  MoveToHead: PUBLIC ActOnNodeProcType =    BEGIN MoveSuccToHead[simple, Find[simple, node]]; END;      MoveSuccToHead: PUBLIC ActOnSuccProcType =    BEGIN    IF prev # NIL THEN      BEGIN      node: SimpleNode ¬ prev.next;      simple.procs.delinkSucc[simple, prev];      AddAtHead[simple, node];      END;    END;    -- Searching  Find: PUBLIC FindProcType =    BEGIN    prev ¬ simple.procs.find[simple, node];    IF AbsToRep[simple].forward THEN MoveSuccToHead[simple, prev];    END;      FindDImpl: FindProcType = BEGIN RETURN[SNToDN[node].back]; END;    FindSImpl: FindProcType =    BEGIN    FOR prev ¬ @simple.head, prev.next UNTIL prev = NIL DO      IF prev.next = node THEN	{IF prev = @simple.head THEN prev ¬ NIL; RETURN};      ENDLOOP;    ERROR NotFound;    END;    -- Deletion/Delinking  Delete: PUBLIC ActOnNodeProcType =    BEGIN Delink[simple, node]; simple.procs.zone.FREE[@node]; END;      DeleteSucc: PUBLIC ActOnSuccProcType =    BEGIN    node: SimpleNode ¬ IF prev = NIL THEN simple.head.next ELSE prev.next;    DelinkSucc[simple, prev];    simple.procs.zone.FREE[@node];    END;      Delink: PUBLIC ActOnNodeProcType =    BEGIN DelinkSucc[simple, Find[simple, node]]; END;      DelinkSuccCommon: PROCEDURE [simple: Simple, prev: SimpleNode]    RETURNS [prevNext: SimpleNode] =    BEGIN    IF prev = NIL THEN prev ¬ @simple.head;    IF simple.tail.next = prev.next THEN simple.tail.next ¬ prev;    IF (prevNext ¬ prev.next) # NIL THEN prev.next ¬ prev.next.next;    END;      DelinkSuccDImpl: ActOnSuccProcType =    BEGIN    prevNext: DoubleNode ¬ SNToDN[DelinkSuccCommon[simple, prev]];    IF prevNext # NIL AND prevNext.next # NIL THEN      SNToDN[prevNext.next].back ¬ prevNext.back;    END;      DelinkSuccSImpl: ActOnSuccProcType =    BEGIN [] ¬ DelinkSuccCommon[simple, prev]; END;    END. -- of ListsA.mesa
-- Copyright (C) 1982  by Xerox Corporation. All rights reserved. -- StringExtraImpl.mesa - last edit:-- Mark		Nov 7, 1980 10:51 PM-- Mike		 6-Jan-82 13:37:28-- RXJ     	11-Nov-82 18:15:32  DIRECTORY  Ascii USING [CR, NUL, SP],  Heap USING [systemZone],  MStream USING [EndOf],  Scan USING [CharFilterProcType, Find],  Stream USING [GetChar, Handle],  StringExtra USING [BackupSS],  String USING [    AppendChar, AppendSubString, Empty, EqualStrings, EquivalentStrings,     StringToDecimal, StringToNumber, SubString, SubStringDescriptor];  StringExtraImpl: PROGRAM  IMPORTS Heap, MStream, Scan, Stream, StringExtra, String  EXPORTS StringExtra =  BEGIN  -- STRING and CHARACTER utilities  StringsAreSame: PUBLIC PROCEDURE [s1, s2: LONG STRING, caseFold: BOOLEAN]    RETURNS [BOOLEAN] =    BEGIN    RETURN[      IF String.Empty[s1] THEN String.Empty[s2]      ELSE IF String.Empty[s2] THEN FALSE      ELSE IF caseFold THEN String.EquivalentStrings[s1, s2]      ELSE String.EqualStrings[s1, s2]      ]    END;    -- Procedures managing Buffers  CharFromSS: PUBLIC PROCEDURE [    ss: String.SubString, caseFold: BOOLEAN ¬ TRUE]    RETURNS [c: CHARACTER] =    BEGIN OPEN ss;    IF offset < length THEN      BEGIN      c ¬ base[offset]; offset ¬ offset+1; length ¬ length-1;      IF c IN ['A..'Z] AND caseFold THEN c ¬ c + ('a-'A);      END    ELSE c ¬ Ascii.NUL;    END;      DecimalFromSS: PUBLIC PROCEDURE [ss: String.SubString, default: INTEGER]    RETURNS [v: INTEGER] =    BEGIN    temp: String.SubStringDescriptor;    FilteredStringFromSS[ss, @temp, IsItADigit];    v ¬ default;    IF temp.length # 0 THEN      BEGIN      s: LONG STRING ¬ StringFromSubString[@temp];      v ¬ String.StringToDecimal[s];      Heap.systemZone.FREE[@s];      END;    END;      FilteredStringFromSS: PUBLIC PROCEDURE    [ss, result: String.SubString, filter: Scan.CharFilterProcType] =    BEGIN    NotFilter: Scan.CharFilterProcType =      BEGIN RETURN[~filter[char]]; END;    result­ ¬ ss­;    IF Scan.Find[result, ss, NotFilter].found THEN StringExtra.BackupSS[ss];    END;      NextFilteredStringInSS: PUBLIC PROCEDURE [    ss: String.SubString, filter: Scan.CharFilterProcType]    RETURNS [s: LONG STRING] =    BEGIN    temp: String.SubStringDescriptor;    IF ~filter[ss.base[ss.offset]] THEN      SkipToFilteredStringInSS[ss, filter];    FilteredStringFromSS[ss, @temp, filter];    s ¬ StringFromSubString[@temp];    END;      NumberFromSS: PUBLIC PROCEDURE [ss: String.SubString, default: UNSPECIFIED]    RETURNS [u: UNSPECIFIED] =    BEGIN    temp: String.SubStringDescriptor;    FilteredStringFromSS[ss, @temp, IsItANumeric];    u ¬ default;    IF temp.length # 0 THEN      BEGIN      s: LONG STRING ¬ StringFromSubString[@temp];      u ¬ String.StringToNumber[s, 10];      Heap.systemZone.FREE[@s];      END;    END;      TokenFromSS: PUBLIC PROCEDURE [ss: String.SubString, token, switches: LONG STRING] =    BEGIN    s: LONG STRING ¬ token;    c: CHARACTER;    token.length ¬ switches.length ¬ 0;    DO      SELECT (c ¬ CharFromSS[ss: ss]) FROM	Ascii.NUL => EXIT;	Ascii.SP, Ascii.CR =>	  IF token.length # 0 OR switches.length # 0 THEN RETURN;	'' =>	  BEGIN	  c ¬ CharFromSS[ss: ss];	  IF c # Ascii.NUL THEN String.AppendChar[s, c];	  END;	'/ => s ¬ switches;	ENDCASE => String.AppendChar[s, c];      ENDLOOP;    RETURN    END;      SkipToFilteredStringInSS: PUBLIC PROCEDURE [    ss: String.SubString, filter: Scan.CharFilterProcType] =    BEGIN    temp: String.SubStringDescriptor ¬ ss­;    IF Scan.Find[@temp, ss, filter].found THEN StringExtra.BackupSS[ss];    END;      StringFromSubString: PUBLIC PROCEDURE [ss: String.SubString]    RETURNS [s: LONG STRING] =    BEGIN    IF ss.length = 0 THEN s ¬ NIL    ELSE      BEGIN      s ¬ Heap.systemZone.NEW[StringBody[ss.length]];      String.AppendSubString[s, ss];      END;    END;        -- Procedures managing Stream  GetTokenFromStream: PUBLIC PROCEDURE [    com: Stream.Handle, token, switches: LONG STRING] =    BEGIN    s: LONG STRING;    c: CHARACTER;    token.length ¬ switches.length ¬ 0;    s ¬ token;    WHILE ~MStream.EndOf[com] DO      SELECT (c ¬ Stream.GetChar[com]) FROM	Ascii.SP, Ascii.CR =>	  IF token.length # 0 OR switches.length # 0 THEN RETURN;	'' =>	  BEGIN	  String.AppendChar[s, c];	  IF MStream.EndOf[com] THEN EXIT;	  c ¬ Stream.GetChar[com];	  String.AppendChar[s, c];	  END;	'/ => s ¬ switches;	ENDCASE => String.AppendChar[s, c];      ENDLOOP;    RETURN    END;    -- CHARACTER filters  IsItADigit: PUBLIC Scan.CharFilterProcType =    BEGIN RETURN[char IN ['0..'9]]; END;      IsItAFileNameChar: PUBLIC Scan.CharFilterProcType =    BEGIN    RETURN[(SELECT char FROM      IN ['0..'9], IN ['A..'Z], IN ['a..'z], '-, '., '$, '<, '> => TRUE,      ENDCASE => FALSE)];    END;      IsItANumeric: PUBLIC Scan.CharFilterProcType =    BEGIN    RETURN[(SELECT char FROM      IN ['0..'9], 'b, 'B, 'd, 'D, '- => TRUE,      ENDCASE => FALSE)];    END;    END... of StringExtraImpl.mesa
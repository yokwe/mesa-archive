-- Copyright (C) 1981, 1982  by Xerox Corporation. All rights reserved. -- File: List.mesa - last edited: -- Mark		Sep 25, 1980 10:29 PM-- Mike		30-Dec-81 11:04:24-- RXJ     	11-Nov-82 14:21:08-- A moderately efficient generic list package.-- Several layers of sophistication of list management are provided.List: DEFINITIONS =  BEGIN  -- Very simple (singly linked, unclustered unstructured nodes, no reordering)--   Client should have the following Mesa source typically:--     MyHandle: TYPE = LONG POINTER TO MyObject;--     MyObject: TYPE = MACHINE DEPENDENT RECORD [--       next: MyHandle,--       myData: ...];--     simple: List.Simple ¬ List.SimpleCreate[...];--     myHandle: MyHandle ¬ MyAllocator[SIZE[MyObject]];--     List.AddAfter[simple, List.PToSN[myHandle]];--   Added type safety would require:--     MyPToSN: PROCEDURE [p: MyHandle] RETURNS [SimpleNode] = INLINE--       BEGIN RETURN[LOOPHOLE[p, SimpleNode]]; END;--     List.AddAfter[simple, MyPToSN[myHandle]];--   The MACHINE DEPENDENT MyObject can be avoided via:--     MyObject: TYPE = RECORD [--       next: MyHandle,--       myData: ...];--     nextOffset: CARDINAL = LOOPHOLE[@LOOPHOLE[0, MyHandle].next];--     MyPToSN: PROCEDURE [p: MyHandle] RETURNS [SimpleNode] = INLINE--       BEGIN RETURN[LOOPHOLE[@p.next, SimpleNode]]; END;--     MySNToP: PROCEDURE [sn: SimpleNode] RETURNS [MyHandle] = INLINE--       BEGIN RETURN[LOOPHOLE[sn, SimpleNode]-nextOffset]; END;  -- PROCEDURE TYPEs      -- Internal    ActOnNodeProcType: TYPE = PROCEDURE [simple: Simple, node: SimpleNode];    ActOnSuccProcType: TYPE = PROCEDURE [simple: Simple, prev: SimpleNode];    AddAfterProcType: TYPE = PROCEDURE [simple: Simple, node, new: SimpleNode];    CreateProcType: TYPE = PROCEDURE [zone: UNCOUNTED ZONE ¬ NIL]      RETURNS [simple: Simple];    EnumerateProcType: TYPE = PROCEDURE [simple: Simple, prev: SimpleNode]      RETURNS[done: BOOLEAN];    FindProcType: TYPE = PROCEDURE [simple: Simple, node: SimpleNode]      RETURNS [prev: SimpleNode];        -- Data TYPEs      Simple: TYPE = LONG POINTER TO SimpleObject;    SimpleObject: TYPE = MACHINE DEPENDENT RECORD [      procs: Procs,       head, tail: SimpleNodeObject];  -- There may be other (private) fields          Procs: TYPE = LONG POINTER TO READONLY ProcsObject;    ProcsObject: TYPE = MACHINE DEPENDENT RECORD [      addAfter: AddAfterProcType,       zone: UNCOUNTED ZONE,       delinkSucc: ActOnSuccProcType,       find: FindProcType];          SimpleNode: TYPE = LONG POINTER TO SimpleNodeObject;    SimpleNodeObject: TYPE = RECORD [next: SimpleNode];        EnumerateDoneAction: TYPE = {none, forward};      -- Basic PROCEDUREs (prev = NIL => at head of list)      SimpleCreate: CreateProcType;    SimpleDestroy: PROCEDURE [simple: Simple];        AddAfter: AddAfterProcType = INLINE      BEGIN simple.procs.addAfter[simple, node, new]; END;    AddAtHead: PROCEDURE [simple: Simple, new: SimpleNode] = INLINE      BEGIN AddAfter[simple, NIL, new]; END;    AddAtTail: PROCEDURE [simple: Simple, new: SimpleNode] = INLINE      BEGIN AddAfter[simple, simple.tail.next, new]; END;    Delete: ActOnNodeProcType;    DeleteSucc: ActOnSuccProcType;    Delink: ActOnNodeProcType;    DelinkSucc: ActOnSuccProcType = INLINE      BEGIN simple.procs.delinkSucc[simple, prev]; END;    Enumerate: PROCEDURE [      simple: Simple, proc: EnumerateProcType, doneAction: EnumerateDoneAction]      RETURNS [doneNode: SimpleNode] = INLINE      BEGIN      prev: SimpleNode;      FOR prev ¬ @simple.head, prev.next UNTIL prev.next = NIL DO	IF proc[simple, prev] THEN	  BEGIN	  IF prev # @simple.head AND doneAction = forward THEN	    BEGIN	    MoveSuccToHead[simple, prev];	    prev ¬ @simple.head;	    END;	  EXIT;	  END;	ENDLOOP;      RETURN[prev.next];      END;    Find: FindProcType;        PToSN: PROCEDURE [p: LONG POINTER] RETURNS [SimpleNode] = INLINE      BEGIN RETURN[LOOPHOLE[p, SimpleNode]]; END;    SNToP: PROCEDURE [sn: SimpleNode] RETURNS [LONG POINTER] = INLINE      BEGIN RETURN[LOOPHOLE[sn, LONG POINTER]]; END;        -- SIGNALs      NotFound: SIGNAL;    -- Doubly linked--   Client should have the following Mesa source typically:--     MyObject: TYPE = MACHINE DEPENDENT RECORD [--       next, back: MyHandle,--       myData: ...];--     simple: List.Simple ¬ List.DoubleCreate[...];--   The MACHINE DEPENDENT MyObject can be avoided via:--     MyObject: TYPE = RECORD [--       links: DoubleNode,--       myData: ...];--     linksOffset: CARDINAL = LOOPHOLE[@LOOPHOLE[0, MyHandle].links];--     MyPToSN: PROCEDURE [p: MyHandle] RETURNS [SimpleNode] = INLINE--       BEGIN RETURN[LOOPHOLE[@p.links, SimpleNode]]; END;--     MyDNToP: PROCEDURE [dn: DoubleNode] RETURNS [MyHandle] = INLINE--       BEGIN RETURN[LOOPHOLE[dn, MyHandle]-linksOffset]; END;  -- Data TYPEs      DoubleNode: TYPE = LONG POINTER TO DoubleObject;    DoubleObject: TYPE = MACHINE DEPENDENT RECORD [next, back: SimpleNode];      -- Basic PROCEDUREs      DoubleCreate: CreateProcType;        SNToDN: PROCEDURE [sn: SimpleNode] RETURNS [DoubleNode] = INLINE      BEGIN RETURN[LOOPHOLE[sn, DoubleNode]]; END;      -- Forwarding after search to speed up non-random probes  -- Basic PROCEDUREs      EnableAutoForwarding: PROCEDURE [simple: Simple];    MoveToHead: ActOnNodeProcType;    MoveSuccToHead: ActOnSuccProcType;    -- Very (overly?) complicated lists--   Client's nodes are copied into a compacted node cluster (BlockObject).--   The list package only knows how big the client node is.  It does not--   understand the internal structure.  For this reason the client must provide--   a SearcherProcType that looks inside a node and tells the list package if--   the node is a match for a given key (whose structure is also not understood--   by the list package.  -- PROCEDURE TYPEs      SearcherProcType: TYPE = PROCEDURE [listCell, key: LONG POINTER]      RETURNS [match: BOOLEAN];        -- Data TYPEs      ReorderingStrategy: TYPE = {none, forward};        List: TYPE = LONG POINTER TO ListObject;    ListObject: TYPE = RECORD [      simple: SimpleObject,      zone: UNCOUNTED ZONE,       reordering: ReorderingStrategy,      searcher: SearcherProcType,       nodeSize: NodeSize,       blockSize: BlockSize];          -- Types to make compiler find more obvious blunders    NodeSize: TYPE = RECORD [CARDINAL];    BlockSize: TYPE = RECORD [CARDINAL];        Block: TYPE = LONG POINTER TO BlockObject;    BlockObject: TYPE = MACHINE DEPENDENT RECORD [      next: Block,  -- must be first (see 'previous' hack in FindBlockAndIndex)      length: CARDINAL,      data: ARRAY [0..0) OF UNSPECIFIED];        -- Basic PROCEDUREs      ListCreate: PROCEDURE [      zone: UNCOUNTED ZONE,       reordering: ReorderingStrategy ¬ none,      searcher: SearcherProcType,      nodeSize: NodeSize,       blockSize: BlockSize]      RETURNS [list: List];    ListDestroy: PROCEDURE [list: List];        AddToList: PROCEDURE [list: List, node: LONG POINTER];    DeleteFromList: PROCEDURE [list: List, node: LONG POINTER];    FindInList: PROCEDURE [      list: List, node: LONG POINTER, reordering: ReorderingStrategy]      RETURNS [LONG POINTER];        -- Utility PROCEDUREs      AddNewBlock: PROCEDURE [list: List] RETURNS [newBlock: Block];        AddToBlock: PROCEDURE [block: Block, node: LONG POINTER, nodeSize: NodeSize];        DeleteFromBlock: PROCEDURE [      current, previous: Block, nodeIndex: CARDINAL, nodeSize: NodeSize,       simple: Simple, reordering: ReorderingStrategy];          FindBlockAndIndex: PROCEDURE [      list: List, node: LONG POINTER, reordering: ReorderingStrategy]      RETURNS [current, previous: Block, i: CARDINAL];          BlockIndex: PROCEDURE [index: CARDINAL, nodeSize: NodeSize]      RETURNS [CARDINAL] = INLINE      BEGIN RETURN[index*nodeSize]; END;          CellFromBlock: PROCEDURE [block: Block, index: CARDINAL, nodeSize: NodeSize]      RETURNS [LONG POINTER] = INLINE      BEGIN RETURN[@block.data[BlockIndex[index, nodeSize]]]; END;          SpaceForBlock: PROCEDURE [nodeSize: NodeSize, blockSize: BlockSize]      RETURNS [CARDINAL] = INLINE      BEGIN RETURN[SIZE[BlockObject] + nodeSize*blockSize]; END;      END. -- of List.mesa
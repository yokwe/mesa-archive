-- Copyright (C) 1982  by Xerox Corporation. All rights reserved. -- ToolDriversA.mesa - last edit: -- Mark		Dec 25, 1980 5:52 PM-- Mike		 11-Mar-82 16:43:14-- RXJ     	 11-Nov-82 18:16:12DIRECTORY  FileSW USING [IsIt],  Heap USING [systemZone],  List USING [    AddAtHead, Delete, Enumerate, EnumerateProcType, Simple, SimpleCreate,     SimpleNode],  MsgSW USING [IsIt],  Put USING [Line],  String USING [AppendString],  Stream USING [Handle],  ToolDriver USING [NoteSWsProcType, RemoveSWsProcType, SetSWsProcs, ToolID],  ToolDriverOps USING [    Error, FindToolID, FlushLastToolCache, MakeSubwindowSequence,     SubwindowSequence, wh],  ToolWindow USING [EnumerateSWProcType, EnumerateSWs],  UserTerminal USING [BlinkDisplay],  Window USING [Handle];    ToolDriversA: PROGRAM  IMPORTS FileSW, Heap, List, MsgSW, Put, String, ToolDriver, ToolDriverOps, ToolWindow, UserTerminal  EXPORTS ToolDriver, ToolDriverOps =  BEGIN  -- Global data and TYPEs  registryStream: PUBLIC Stream.Handle ¬ NIL;    ROType: TYPE = {toolSWs, commData}; --blank field needed for bit alignment  ToolSWsRH: TYPE = LONG POINTER TO toolSWs RegisteredObject;  CommDataRH: TYPE = LONG POINTER TO commData RegisteredObject;  RegisteredHandle: TYPE = LONG POINTER TO RegisteredObject;  RegisteredObject: TYPE = MACHINE DEPENDENT RECORD [    next(offset:0..31): RegisteredHandle,    id(2:0..15): ToolDriver.ToolID,    blankField(3:0..13): [0..16384),    body(3:14..47): SELECT type(3:14..15): ROType FROM    toolSWs =>      [handles(3:16..47): ToolDriverOps.SubwindowSequence],    commData =>      [data(3:16..47): LONG POINTER]    ENDCASE];      registry: List.Simple;  -- Coercion  offset: CARDINAL = 0;    RHToSN: PROCEDURE [rh: RegisteredHandle] RETURNS [List.SimpleNode] = INLINE    BEGIN RETURN[LOOPHOLE[@rh.next, List.SimpleNode]]; END;      SNToRH: PROCEDURE [sn: List.SimpleNode] RETURNS [RegisteredHandle] = INLINE    BEGIN RETURN[LOOPHOLE[sn, RegisteredHandle]-offset]; END;      FindSWsID: PROCEDURE [toolID: ToolDriver.ToolID] RETURNS [ToolSWsRH] = INLINE    BEGIN RETURN[LOOPHOLE[FindID[toolID, toolSWs], ToolSWsRH]]; END;    -- Interface PROCEDUREs  FindData: PUBLIC PROCEDURE [toolID: ToolDriver.ToolID]    RETURNS [LONG POINTER] =    BEGIN    node: RegisteredHandle = FindID[toolID, commData];    RETURN[IF node = NIL THEN NIL      ELSE WITH p: node SELECT FROM commData => p.data, ENDCASE => ERROR];    END;      FindID: PUBLIC PROCEDURE [toolID: ToolDriver.ToolID, type: ROType]    RETURNS [RegisteredHandle] =    BEGIN    CheckNode: List.EnumerateProcType =      {done ¬ SNToRH[prev].next.id = toolID AND SNToRH[prev].next.type = type};    RETURN[SNToRH[List.Enumerate[registry, CheckNode, forward]]];    END;      SequenceFromID: PUBLIC PROCEDURE [toolID: ToolDriver.ToolID]    RETURNS [ToolDriverOps.SubwindowSequence] =    BEGIN    node: ToolSWsRH = FindSWsID[toolID];    IF node # NIL THEN RETURN[node.handles];    ERROR ToolDriverOps.Error[noSuchTool, NIL];    END;    -- Utilities  PutInTDsFileAndMsgSW: PROCEDURE[wh: Window.Handle, msg: LONG STRING] =    BEGIN      PutMsg: ToolWindow.EnumerateSWProcType =        BEGIN	IF MsgSW.IsIt[sw] OR FileSW.IsIt[sw] THEN	  Put.Line[sw, msg];	RETURN[FALSE];	END; --PutMsg    ToolWindow.EnumerateSWs[wh, PutMsg];    END; --PutInTDsFileAndMsgSW  InitModule: PROCEDURE =    BEGIN    registry ¬ List.SimpleCreate[];    ToolDriver.SetSWsProcs[RealNoteSWs, RealRemoveSWs];  -- replace nops    END;      MakeDataNode: PROCEDURE [toolID: ToolDriver.ToolID, data: LONG POINTER]    RETURNS [node: CommDataRH] =    BEGIN    node ¬ Heap.systemZone.NEW[commData RegisteredObject];    node­ ¬ [next: NULL, id: toolID, blankField: 0, body: commData[data]];    RETURN[node];    END;      MakeSWsNode: PROCEDURE [    toolID: ToolDriver.ToolID, handles: ToolDriverOps.SubwindowSequence]    RETURNS [node: ToolSWsRH] =    BEGIN    node ¬ Heap.systemZone.NEW[toolSWs RegisteredObject];    node­ ¬ [next: NULL, id: toolID, blankField: 0, body: toolSWs[handles]];    RETURN[node];    END;      RealNoteSWs: ToolDriver.NoteSWsProcType =    BEGIN    id: ToolDriver.ToolID;    handles: ToolDriverOps.SubwindowSequence;    id ¬ ToolDriverOps.FindToolID[tool ! ToolDriverOps.Error => GOTO NotThere];    handles ¬ ToolDriverOps.MakeSubwindowSequence[subwindows !ToolDriverOps.Error => IF code = unknownName THEN GOTO UnknownName];    IF handles # NIL THEN      List.AddAtHead[registry, RHToSN[MakeSWsNode[id, handles]]];    EXITS      NotThere => NULL;      UnknownName => BEGIN         msgName: LONG STRING ¬ [200];	String.AppendString[msgName, tool];	String.AppendString[msgName, " subwindow name doesn't match in Tool.sws; Tool NOT registered!"L];	PutInTDsFileAndMsgSW[ToolDriverOps.wh, msgName];	UserTerminal.BlinkDisplay[];      END;    END;      RealRemoveSWs: ToolDriver.RemoveSWsProcType =    BEGIN    id: ToolDriver.ToolID;    node: ToolSWsRH;    id ¬ ToolDriverOps.FindToolID[tool ! ToolDriverOps.Error => GOTO NotThere];    node ¬ FindSWsID[id];    IF node = NIL THEN GOTO NotThere  -- Tool registered before Driver started?    ELSE Heap.systemZone.FREE[@node.handles];    List.Delete[registry, RHToSN[node]];    ToolDriverOps.FlushLastToolCache[];  -- it probably has this guy    EXITS      NotThere => NULL;    END;    -- Mainline code  InitModule[];  END. -- of ToolDriversA.mesa
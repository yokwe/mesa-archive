-- Copyright (C) 1981  by Xerox Corporation. All rights reserved. -- File: Scans.mesa  -- String scanning routines  -- Last Edited by:    -- Mark on: Apr 8, 1980 3:06 PM     -- Mike on: 30-Dec-81 10:46:36    DIRECTORY    Ascii: FROM "Ascii" USING [NUL, SP, TAB],    Scan: FROM "Scan" USING [CharFilterProcType],    String: FROM "String" USING [SubString];  Scans: PROGRAM  EXPORTS Scan =  BEGIN OPEN Scan;  -- Global Data and STUFF  -- Utilities  NilTest: PUBLIC CharFilterProcType =    BEGIN RETURN[FALSE]; END;      WhiteSpace: PUBLIC CharFilterProcType =    BEGIN    RETURN[SELECT char FROM      Ascii.SP, Ascii.TAB => TRUE,      ENDCASE => FALSE];    END;      NotWhiteSpace: PUBLIC CharFilterProcType =    BEGIN    RETURN[SELECT char FROM      Ascii.TAB, Ascii.SP => FALSE,      ENDCASE => TRUE];    END;      BaseScan: PUBLIC PROCEDURE [    prefix, suffix: String.SubString,     isABreak, trimIt: CharFilterProcType]    RETURNS [breakChar: CHARACTER, found: BOOLEAN] =    BEGIN    prefixLength: CARDINAL ¬ prefix.length;    [breakChar, found] ¬ Scan[prefix, suffix, isABreak, trimIt];    prefix.base.length ¬ prefix.base.length - (prefixLength - prefix.length);    END;      BaseTrim: PUBLIC PROCEDURE [    ss: String.SubString, trimIt: CharFilterProcType] =    BEGIN    ssLength: CARDINAL ¬ ss.length;    Trim[ss, trimIt];    ss.base.length ¬ ss.base.length - (ssLength - ss.length);    END;      Find: PUBLIC PROCEDURE [    prefix, suffix: String.SubString,    isABreak: CharFilterProcType]    RETURNS [breakChar: CHARACTER, found: BOOLEAN] =    -- 'breakChar' is valid iff 'found' and is not included in 'prefix' or    --    'suffix' upon RETURN.    BEGIN    i: CARDINAL;    suffix.base ¬ prefix.base;    IF prefix.base = NIL THEN prefix.length ¬ 0;  -- robustness measure    FOR i IN [prefix.offset..prefix.offset+prefix.length) DO      IF isABreak[prefix.base[i]] THEN	BEGIN	suffix.offset ¬ i + 1;	suffix.length ¬ prefix.length+prefix.offset-suffix.offset;	prefix.length ¬ suffix.offset-prefix.offset-1;	RETURN[prefix.base[i], TRUE];	END;      ENDLOOP;    suffix.offset ¬ prefix.length;    suffix.length ¬ 0;    RETURN[Ascii.NUL, FALSE];    END;      Scan: PUBLIC PROCEDURE [    prefix, suffix: String.SubString,     isABreak, trimIt: CharFilterProcType]    RETURNS [breakChar: CHARACTER, found: BOOLEAN] =    BEGIN    lastIPlusOne: CARDINAL = prefix.offset+prefix.length;    nextFree: CARDINAL ¬ LAST[CARDINAL];    breakPos: CARDINAL;    BEGIN    i: CARDINAL;    -- Check to see if faster routines can be used.    IF isABreak = NilTest THEN      BEGIN      IF trimIt # NilTest THEN Trim[prefix, trimIt];      GOTO NoBreakFound;      END    ELSE IF trimIt = NilTest THEN      BEGIN      [breakChar, found] ¬ Find[prefix, suffix, isABreak];      RETURN;      END;    suffix.base ¬ prefix.base;    IF prefix.base = NIL THEN prefix.length ¬ 0;  -- robustness measure    IF prefix.length = 0 THEN GOTO NoBreakFound;    -- No.  First increase prefix.offset if appropriate.    IF isABreak[prefix.base[prefix.offset]] THEN      BEGIN breakPos ¬ prefix.offset; GOTO GotBreak; END;    IF trimIt[prefix.base[prefix.offset]] THEN      FOR i IN [prefix.offset+1..lastIPlusOne) DO	IF isABreak[prefix.base[i]] THEN	  BEGIN breakPos ¬ i; GOTO GotBreak; END;	IF ~trimIt[prefix.base[i]] THEN	  BEGIN prefix.offset ¬ i; EXIT; END;	REPEAT	  FINISHED =>	    BEGIN	    prefix.offset ¬ lastIPlusOne;	    prefix.length ¬ 0;	    GOTO NoBreakFound;	    END;	ENDLOOP;    -- Next look for the first embedded char to trim    FOR i IN [prefix.offset+1..lastIPlusOne) DO      IF isABreak[prefix.base[i]] THEN	BEGIN breakPos ¬ i; GOTO GotBreak; END;      IF trimIt[prefix.base[i]] THEN	BEGIN nextFree ¬ i; EXIT; END;      REPEAT	FINISHED => GOTO NoBreakFound;      ENDLOOP;    -- Now slide down remainder    FOR i IN [nextFree+1..lastIPlusOne) DO      IF isABreak[prefix.base[i]] THEN	BEGIN breakPos ¬ i; GOTO GotBreak; END;      IF ~trimIt[prefix.base[i]] THEN	BEGIN	prefix.base[nextFree] ¬ prefix.base[i];	nextFree ¬ nextFree + 1;	END;      ENDLOOP;    prefix.length ¬ nextFree - prefix.offset;    GOTO NoBreakFound;    EXITS      GotBreak =>	BEGIN	suffix.offset ¬ breakPos + 1;	suffix.length ¬ lastIPlusOne-suffix.offset;	prefix.length ¬ (IF nextFree = LAST[CARDINAL]	  THEN suffix.offset-prefix.offset-1	  ELSE nextFree-prefix.offset);	RETURN[prefix.base[breakPos], TRUE];	END;      NoBreakFound =>	BEGIN	suffix.offset ¬ prefix.offset+prefix.length;	suffix.length ¬ 0;	RETURN[Ascii.NUL, FALSE];	END;    END;    END;      Trim: PUBLIC PROCEDURE [    ss: String.SubString, trimIt: CharFilterProcType] =    BEGIN    i, lastIPlusOne, nextFree: CARDINAL;    IF ss.base = NIL THEN ss.length ¬ 0;  -- robustness measure    IF ss.length = 0 THEN RETURN;    lastIPlusOne ¬ ss.offset+ss.length;    -- First increase ss.offset if appropriate    IF trimIt[ss.base[ss.offset]] THEN      FOR i IN [ss.offset+1..lastIPlusOne) DO	IF ~trimIt[ss.base[i]] THEN	  BEGIN ss.offset ¬ i; EXIT; END;	REPEAT	  FINISHED =>	    BEGIN	    ss.offset ¬ lastIPlusOne;	    ss.length ¬ 0;	    RETURN;	    END;	ENDLOOP;    -- Next look for the first embedded char to trim    FOR i IN [ss.offset+1..lastIPlusOne) DO      IF trimIt[ss.base[i]] THEN	BEGIN nextFree ¬ i; EXIT; END;      REPEAT	FINISHED => RETURN;      ENDLOOP;    -- Now slide down remainder    FOR i IN [nextFree+1..lastIPlusOne) DO      IF ~trimIt[ss.base[i]] THEN	BEGIN	ss.base[nextFree] ¬ ss.base[i];	nextFree ¬ nextFree + 1;	END;      ENDLOOP;    ss.length ¬ nextFree - ss.offset;    END;    -- Main Line codeEND. -- of Scans.mesa        
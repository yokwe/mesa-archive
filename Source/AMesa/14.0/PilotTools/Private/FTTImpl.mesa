-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. -- FTTImpl.mesa, last edited by:   RSV on   3-Apr-87 18:31:08DIRECTORY  Floppy,  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType,     CommandItem, line0, line1, line2, line3, line4, line5, line6, line7,    line8, ProcType],  FTTDefs,  Heap USING [systemZone],  MFile USING [Release, Handle],  Space USING [nullInterval, Unmap],  String USING [AppendString, CopyToNewString],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeStringSW,    MakeSWsProc, UnusedLogName],    ToolWindow USING [TransitionProcType],  UserTerminal USING [],  Window USING [Box, GetBox, Handle];  FTTImpl: PROGRAM   IMPORTS FormSW, FTTDefs, Heap, MFile, Space, String, Tool, Window  EXPORTS FTTDefs =    BEGIN OPEN FTTDefs;    --CONSTANTS  done so I can number my items in MakeFormSW    Format: CARDINAL = 0;    CreateFile: CARDINAL = 1;    CopyToPilotFile: CARDINAL = 2;    Open: CARDINAL = 3;    DeleteFile: CARDINAL = 4;    CopyFromPilotFile: CARDINAL = 5;    Close: CARDINAL = 6;    Read: CARDINAL = 7;    GetFileAttributes: CARDINAL = 8;    GetAttributes: CARDINAL = 9;    Write: CARDINAL = 10;    GetNextFile: CARDINAL = 11;    SetRootFile: CARDINAL = 12;    SetBootFiles: CARDINAL = 13;    Compact: CARDINAL = 14;    Scavenge: CARDINAL = 15;    GetNextBadSector: CARDINAL = 16;    ReplaceBadSector: CARDINAL = 17;    CreateInitial: CARDINAL = 18;    GetBootFiles: CARDINAL = 19;    MakeImage: CARDINAL = 20;    CreateFloppyFromImage: CARDINAL = 21;    GetImageAttributes: CARDINAL = 22;    PagesForImage: CARDINAL = 23;    -- TYPEs  optionitems : CARDINAL = 24;  --number of commanditems in formSW (= nitems)  --Array of Procedures to be called upon selection of apprpriate CommandItem  MakeOptionsProcedures : ARRAY[0..optionitems) OF FormSW.ClientItemsProcType =    [FormatMakeOptions, CreateFileMakeOptions, CopyToPilotFileMakeOptions,    OpenMakeOptions, DeleteFileMakeOptions, CopyFromPilotFileMakeOptions,    CloseMakeOptions, ReadMakeOptions, GetFileAttributesMakeOptions,    GetAttributesMakeOptions, WriteMakeOptions, GetNextFileMakeOptions,    SetRootFileMakeOptions, SetBootFilesMakeOptions, CompactMakeOptions,    ScavengeMakeOptions, GetNextBadSectorMakeOptions,    ReplaceBadSectorMakeOptions, CreateInitialMakeOptions,    GetBootFilesMakeOptions, MakeImageMakeOptions,    CreateFloppyFromImageMakeOptions, GetImageAttributesMakeOptions,    PagesForImageMakeOptions];      MakeOptionsStringNames: ARRAY[0..optionitems) OF LONG STRING =    ["Format's"L, "CreateFile's"L, "CopyToPilotFile's"L, "Open's"L,    "Delete's"L, "CopyFromPilotFile's"L, "Close's"L, "Read's"L,    "GetFileAttribute's"L, "GetAttributes'"L, "Write's"L,    "GetNextFile's"L, "SetRootFile's"L, "SetBootFiles'"L, "Compact's"L,    "Scavenge's"L, "GetNextBadSector's"L, "ReplaceBadSector's"L,    "CreateInitialMicrocodeFile's"L, "GetBootFiles'"L, "MakeImage's"L,    "CreateFloppyFromImage's"L, "GetImageAttributes'"L, "PagesForImage's"L];        --width and height for optionsSW box  Dimension:TYPE = RECORD[                      width: CARDINAL ¬ 0,		      height: CARDINAL ¬ 0];  BoxDimensionArrayType:TYPE = ARRAY[0..optionitems) OF Dimension;           -- Variable declarations      --Strings used for temporarily holding toolData.longString and tooData.pilotFile while they are deallocated  lSI: PUBLIC LONG STRING ¬ NIL;  pFI: PUBLIC LONG STRING ¬ NIL;  toolData: PUBLIC DataHandle ¬ NIL;  wh: PUBLIC Window.Handle ¬ NIL;  BoxDimensionArray: BoxDimensionArrayType ¬ [[350,100], [350,90], [350,150],               [350,50],[350,90], [350,145], [350,50],[350,90], [350,90],	       [350,90],[350,150], [350,90],[350,90],[480, 150],[350,80],	       [350,70],[350,70],[350,90],[350,90],[350,70],[350,110],	       [480,160],[350,110],[350,50]];	         z: UNCOUNTED ZONE = Heap.systemZone;  -- where we're allocating storage from.             OptionsWindow: FormSW.ProcType =  BEGIN             OptionSW: Tool.MakeSWsProc =          BEGIN	    	    toolData.optionFormSW ¬ Tool.MakeFormSW[window: window, formProc: MakeOptionsProcedures[index]];            --If command is to Write, create a StringSW so can input a string to write	    IF index = Write THEN		 toolData.writeStringSW ¬ Tool.MakeStringSW[window: window, s: @toolData.backingString];	 END;       box: Window.Box = Window.GetBox[wh];    toolName:  STRING ¬ [256];            IF toolData.optionSW # NIL THEN --Option window already exists--      --remove the option window currently displayed--      BEGIN      RemoveOptions[sw];      IF toolData.getAFileOptionSW # NIL THEN	RemoveGetAFileOption;      END;      IF toolData.DVMOptionSW # NIL THEN      RemoveDisplayOption;    String.AppendString[toolName, MakeOptionsStringNames[index]];    String.AppendString[toolName, " Parameters"L];    toolData.optionSW ¬ Tool.Create[      name: toolName, makeSWsProc: OptionSW, initialState: active,      initialBox: [[box.place.x, box.place.y - BoxDimensionArray[index].height],      [w: BoxDimensionArray[index].width, h: BoxDimensionArray[index].height]]];     --Clear the msgSW by putting a CR    ClearmsgSW[];    END;    RemoveOptions: PUBLIC FormSW.ProcType =    BEGIN    IF toolData.backingString # NIL THEN      --deallocate string so the next time the Write optionSW is created      --your maxlength won't be fixed to the length of this string      z.FREE[@toolData.backingString];    IF toolData.labelString # NIL THEN       --copy string so can transfer it back after toolData.labelString is deallocated      lSI ¬ String.CopyToNewString[s: toolData.labelString, z: z];    IF toolData.pilotFileID # NIL THEN      --copy string so can transfer it back after toolData.pilotFileID is deallocated      pFI ¬ String.CopyToNewString[s: toolData.pilotFileID, z: z];    IF toolData.fileHandle # 0 THEN {      --release handle to file      MFile.Release[LOOPHOLE[toolData.fileHandle,MFile.Handle]];      toolData.fileHandle ¬ 0 };    Tool.Destroy[toolData.optionSW];    toolData.optionSW ¬ NIL;    IF lSI # NIL THEN       BEGIN      toolData.labelString ¬ lSI;      lSI ¬ NIL;      END;    IF pFI # NIL THEN      BEGIN      toolData.pilotFileID ¬ pFI;      pFI ¬ NIL;      END;    END;        -- Tool needed routines    ClientTransition: ToolWindow.TransitionProcType =    -- This procedure is called whenever the system determines that this    -- Tool's state is undergoing a user invoked transition.    BEGIN    SELECT TRUE FROM      old = inactive =>	IF toolData = NIL THEN	  BEGIN	  toolData ¬ z.NEW[Data];	  toolData^ ¬ [vmInterval: Space.nullInterval];	  END;      new = inactive =>	 BEGIN	 IF toolData.vmInterval # Space.nullInterval THEN	    BEGIN	    toolData.vmInterval.pointer ¬	      Space.Unmap[toolData.vmInterval.pointer];	    toolData.vmInterval ¬ Space.nullInterval;	    END;	 IF toolData.labelString # NIL THEN	   z.FREE[@toolData.labelString];	 IF toolData.pilotFile # NIL THEN	   z.FREE[@toolData.pilotFile];         IF toolData.optionSW # NIL THEN          BEGIN	   Tool.Destroy[toolData.optionSW];           toolData.optionSW ¬ NIL;          END;	 IF toolData # NIL THEN	   z.FREE[@toolData];	  END;      ENDCASE;    END;      Init: PROCEDURE =    BEGIN    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default, initialBox: [place: [x: 401, y: 424], dims: [w: 480, h: 350]],      clientTransition: ClientTransition, name: "Floppy Test Tool"L];    END;      MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    -- This procedure creates a sample FormSW.    items ¬ AllocateItemDescriptor[optionitems];    -- Create an example of command item usage    items[Format] ¬ CommandItem[      tag: "Format"L, place: [25, line0], proc: OptionsWindow];    items[CreateFile] ¬ CommandItem[      tag: "CreateFile"L, place: [180, line0], proc: OptionsWindow];    items[CopyToPilotFile] ¬ CommandItem[      tag: "CopyToPilotFile"L, place: [350, line0], proc: OptionsWindow];    items[Open] ¬ CommandItem[      tag: "Open"L, place: [25, line1], proc: OptionsWindow];    items[DeleteFile] ¬ CommandItem[      tag: "DeleteFile"L, place: [180, line1], proc: OptionsWindow];    items[CopyFromPilotFile] ¬ CommandItem[      tag: "CopyFromPilotFile"L, place: [350, line1], proc: OptionsWindow];    items[Close] ¬ CommandItem[      tag: "Close"L, place: [25, line2], proc: OptionsWindow];    items[Read] ¬ CommandItem[      tag: "Read"L, place: [180, line2], proc: OptionsWindow];    items[GetFileAttributes] ¬ CommandItem[      tag: "GetFileAttributes"L, place: [350, line2], proc: OptionsWindow];    items[GetAttributes] ¬ CommandItem[      tag: "GetAttributes"L, place: [25, line3], proc: OptionsWindow];    items[Write] ¬ CommandItem[      tag: "Write"L, place: [180, line3], proc: OptionsWindow];    items[GetNextFile] ¬ CommandItem[      tag: "GetNextFile"L, place: [350, line3], proc: OptionsWindow];    items[SetRootFile] ¬ CommandItem[      tag: "SetRootFile"L, place: [25, line4], proc: OptionsWindow];    items[SetBootFiles] ¬ CommandItem[      tag: "SetBootFiles"L, place: [180, line4], proc: OptionsWindow];     items[Compact] ¬ CommandItem[      tag: "Compact"L, place: [25, line5], proc: OptionsWindow];    items[Scavenge] ¬ CommandItem[      tag: "Scavenge"L, place: [180, line5], proc: OptionsWindow];    items[GetNextBadSector] ¬ CommandItem[      tag: "GetNextBadSector"L, place: [350, line5], proc: OptionsWindow];    items[ReplaceBadSector] ¬ CommandItem[      tag: "ReplaceBadSector"L, place: [25, line6], proc: OptionsWindow];    items[CreateInitial] ¬ CommandItem[      tag: "CreateInitialMicrocodeFile"L, place: [180, line6], proc: OptionsWindow];    items[GetBootFiles] ¬ CommandItem[      tag: "GetBootFiles"L, place: [350, line6], proc: OptionsWindow];    items[MakeImage] ¬ CommandItem[      tag: "MakeImage"L, place: [25, line7], proc: OptionsWindow];    items[CreateFloppyFromImage] ¬ CommandItem[      tag: "CreateFloppyFromImage"L, place: [180, line7], proc: OptionsWindow];    items[GetImageAttributes] ¬ CommandItem[      tag: "GetImageAttributes"L, place: [350, line7], proc: OptionsWindow];    items[PagesForImage] ¬ CommandItem[      tag: "PagesForImage"L, place: [25, line8], proc: OptionsWindow];    RETURN[items: items, freeDesc: TRUE];    END;      MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "FloppyTest.log"L];    toolData.msgSW ¬ Tool.MakeMsgSW[window:window];    toolData.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    toolData.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;      -- Mainline code    Init[]; -- this gets string out of global frame    END...  LOG19-Nov-81 15:14:29  LXD  created file.25-Oct-82 18:28:14  ET   various changes. 3-Apr-87 18:31:08  RSV  Old arrows to new arrows.  Add copyright notice.  Fold in ET's changes.  Not based on Storage anymore.  Convert to Klamath version of Space.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- GraphTomDGraphSW.mesa (last edited by Jonathan JXG     29-Jun-83 10:55:36)DIRECTORY  Context USING [Create, Destroy, NopDestroyProc],  GraphTomDOps,  String USING [Equal],  ToolWindow USING [AdjustProcType],  Window USING [Box, Dims, GetBox, Handle, InvalidateBox, Place, Validate],  WindowFont USING[CharWidth, defaultFont, FontHeight];    GraphTomDGraphSW:  MONITOR   LOCKS globalInfo USING globalInfo:GraphTomDOps.GlobalInfoP  IMPORTS Context, GraphTomDOps, String, Window, WindowFont  EXPORTS GraphTomDOps =  BEGIN OPEN GraphTomDOps;    cH: PUBLIC CARDINAL ¬ WindowFont.FontHeight[];  cW: PUBLIC CARDINAL ¬ WindowFont.CharWidth['M];  minimumRowH: PUBLIC CARDINAL ¬ 4*cH;  rowOffset: PUBLIC CARDINAL ¬ cH/2;      -- graph routines ....    CreateGraphs:    PUBLIC PROCEDURE[globalInfo:GlobalInfoP, newItems:Items¬NIL,    	                   initialDims:Window.Dims¬[0,0]] =    BEGIN -- start new picture    oldItems:Items ¬ globalInfo.items;        IF initialDims=[0,0]     THEN initialDims ¬ Window.GetBox[globalInfo.mainSW].dims;        -- create the itemInfo records to maintain histories, etc ....     IF newItems#NIL    THEN      BEGIN      FOR i:CARDINAL IN [0..LENGTH[newItems])        DO        item:ItemP ¬ newItems[i];        itemInfo:ItemInfoP ¬ FindAndExtractItemInfo[item, oldItems];        IF itemInfo=NIL        THEN           BEGIN          itemInfo ¬ z.NEW[ItemInfo[globalInfo.historySize]];          itemInfo.prev ¬ undefined;          itemInfo.hwm ¬ 10;  -- a non-zero initial value (caveat: rescale)          itemInfo.maxVal ¬ 10; -- well, its an initial value!          itemInfo.isSelected ¬ FALSE;	   FOR i:CARDINAL IN [0..globalInfo.historySize) 	   DO itemInfo.history[i] ¬ undefined ENDLOOP;	   END;        newItems[i].client ¬ itemInfo;        itemInfo.item ¬ newItems[i];        ENDLOOP;            FOR i:CARDINAL IN [0..LENGTH[oldItems])        DO         itemInfo:ItemInfoP ¬ oldItems[i].client;        IF itemInfo#NIL THEN z.FREE[@itemInfo]         ENDLOOP;	      globalInfo.items ¬ newItems;      END;          -- and off we jolly well ...    globalInfo.currentDims ¬ SetBoxes[globalInfo, initialDims];    Context.Create[graphContextType, globalInfo, Context.NopDestroyProc,      		   globalInfo.mainSW];    Context.Create[graphContextType, globalInfo, Context.NopDestroyProc,      		   globalInfo.formSW];    Window.InvalidateBox[globalInfo.mainSW, [[0, 0], globalInfo.currentDims]];    Window.Validate[globalInfo.mainSW];	       END;              DestroyGraphs: PUBLIC PROCEDURE[globalInfo:GlobalInfoP] =    BEGIN     Window.InvalidateBox[globalInfo.mainSW, [[0, 0], globalInfo.currentDims]];    Context.Destroy[graphContextType, globalInfo.mainSW];    Context.Destroy[graphContextType, globalInfo.formSW];	    END;      UpdateGraphs: PUBLIC PROCEDURE[globalInfo:GlobalInfoP] =    BEGIN OPEN globalInfo;    FOR i:CARDINAL IN [0..LENGTH[items])      DO      itemInfo:ItemInfoP ¬ items[i].client;      BEGIN OPEN itemInfo;      -- mark the bar invalid and requiring repainting; in addition, a small gap       -- is left at the side and room is left for the new cursor underneath the      -- window      bar:Window.Box ¬         [[firstBarX+last*barDims.w, graphBox.place.y+1], 	 [(IF last=historySize-1 THEN barDims.w ELSE 2*barDims.w), barDims.h+1]];      Window.InvalidateBox[mainSW, bar];      IF history[last]>hwm AND history[last]#undefined       THEN {hwm ¬ history[last];	    IF hwm>maxVal THEN Window.InvalidateBox[mainSW, hwmBox]};      Window.Validate[mainSW];      END;      ENDLOOP;          END;       AdjustGraph: PUBLIC ToolWindow.AdjustProcType =     BEGIN    globalInfo:GlobalInfoP ¬ GetGlobalInfo[window];    actualDims:Window.Dims;    IF globalInfo=NIL THEN RETURN; <<   IF box=Window.GetBox[globalInfo.mainSW] THEN RETURN;  -- no change >>     -- for some reason not clearly understood (!) that line causes a RETURN too often!     -- so ...    IF when=after THEN RETURN;    actualDims ¬ SetBoxes[GetGlobalInfo[window], box.dims];    IF actualDims#globalInfo.currentDims    THEN   -- shape of window has changed significantly (so graph boxes have changed)       BEGIN       globalInfo.currentDims ¬ actualDims;      Window.InvalidateBox[window, [[0,0],box.dims]];      Window.Validate[window]      END    END;      DisplaySelection: PUBLIC PROCEDURE[globalInfo:GlobalInfoP] =    BEGIN    newSlct:Slct ¬ globalInfo.slct;    h:INTEGER ¬ globalInfo.slctH;         FOR i:CARDINAL IN [0..LENGTH[globalInfo.items])      DO      item:ItemP ¬ globalInfo.items[i];      itemInfo:ItemInfoP ¬ item.client;      y:INTEGER ¬ itemInfo.graphBox.place.y+itemInfo.graphBox.dims.h;      Invalidate:PROCEDURE[j1, j2:CARDINAL] =        BEGIN        x:INTEGER ¬ globalInfo.firstBarX+j1*globalInfo.barDims.w;        w:INTEGER ¬ globalInfo.barDims.w*(j2-j1+1);	Window.InvalidateBox[globalInfo.mainSW, [[x, y], [w, h]]]	END;      oldSlct:Slct ¬ itemInfo.slct;            IF globalInfo.selectionMarked  AND  itemInfo.isSelected        THEN         BEGIN	IF oldSlct.j1=LAST[CARDINAL] 	THEN Invalidate[newSlct.j1, newSlct.j2]	ELSE	  BEGIN	  SELECT TRUE FROM            newSlct.j1 < oldSlct.j1   => Invalidate[newSlct.j1,   oldSlct.j1-1];            newSlct.j1 > oldSlct.j1   => Invalidate[oldSlct.j1,   newSlct.j1-1];	    ENDCASE;	  SELECT TRUE FROM            newSlct.j2 < oldSlct.j2   => Invalidate[newSlct.j2+1, oldSlct.j2];            newSlct.j2 > oldSlct.j2   => Invalidate[oldSlct.j2+1, newSlct.j2];	    ENDCASE;	  END;	itemInfo.slct ¬ newSlct	END      ELSE	IF oldSlct.j1#LAST[CARDINAL] 	THEN {Invalidate[oldSlct.j1, oldSlct.j2]; itemInfo.slct ¬ [LAST[CARDINAL], 0]};	      ENDLOOP;           Window.Validate[globalInfo.mainSW]    END;          SetBoxes: PROCEDURE[globalInfo:GlobalInfoP, requestedDims:Window.Dims]       RETURNS [actualDims:Window.Dims] =    BEGIN    maxInterfaceStringSize, maxVariableStringSize, index: CARDINAL ¬ 0;    barW, firstBarX, barH, labelW, labelX, labelH, graphW, graphX, graphH,      rowW, rowH, slctH: INTEGER;          IF globalInfo=NIL THEN RETURN [[0, 0]];        -- compute size of longest label ....    FOR i:CARDINAL IN [0..LENGTH[globalInfo.items])      DO       item:ItemP ¬ globalInfo.items[i];      maxInterfaceStringSize ¬ MAX[maxInterfaceStringSize, item.interfaceName.length];      maxVariableStringSize  ¬ MAX[maxVariableStringSize,  item.varName.length];      ENDLOOP;     -- compute dimensions of useful boxes ....    slctH ¬ 5;    labelX ¬ 4;    labelW ¬ (MAX[maxInterfaceStringSize, maxVariableStringSize+2])*cW;    firstBarX ¬ labelX + labelW + 20;    barW ¬ MAX[1, (requestedDims.w-firstBarX)/INTEGER[globalInfo.historySize]];    graphX ¬ firstBarX - 1;    graphW ¬ barW*globalInfo.historySize + 2;    rowW ¬ graphX+graphW;        rowH ¬ MAX[minimumRowH, globalInfo.graphHeight+slctH+3];    barH ¬ rowH-slctH-3;    graphH ¬ barH+2;    labelH ¬ 2*cH;          globalInfo.barDims ¬ [barW, barH];    globalInfo.rowH ¬ rowH;    globalInfo.firstBarX ¬ firstBarX;    globalInfo.graphW ¬ graphW;    globalInfo.slctH ¬ slctH;        FOR i:CARDINAL IN [0..LENGTH[globalInfo.items])      DO       itemInfo:ItemInfoP ¬ globalInfo.items[i].client;      rowY: INTEGER ¬ index*rowH+rowOffset-globalInfo.yOffset;      hwmY: INTEGER ¬ rowY+labelH;      itemInfo.rowBox ¬   [[     0, rowY], [  rowW,    rowH]];      itemInfo.labelBox ¬ [[labelX, rowY], [labelW, labelH]];      itemInfo.hwmBox ¬   [[     0, hwmY], [labelW,     cH]];      itemInfo.graphBox ¬ [[graphX, rowY], [graphW, graphH]];      index ¬ index+1      ENDLOOP;          RETURN [[rowW, rowOffset+index*rowH+slctH]]    END;      FindAndExtractItemInfo: PROCEDURE[item:ItemP, items:Items]     RETURNS [itemInfo:ItemInfoP] =    BEGIN        IF items=NIL THEN RETURN [NIL];        FOR i:CARDINAL IN [0..LENGTH[items])      DO      IF String.Equal[item.interfaceName, items[i].interfaceName] AND         String.Equal[item.varName, items[i].varName]      THEN {itemInfo ¬ items[i].client; items[i].client ¬ NIL; RETURN}      ENDLOOP;    RETURN [NIL]    END;      END...
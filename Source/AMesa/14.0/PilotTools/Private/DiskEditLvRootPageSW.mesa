-- Copyright (C) 1984, 1988  by Xerox Corporation. All rights reserved. -- DiskEditLVRootPageSW.mesa     1-Mar-88  9:00:38 by CAJ 				 DIRECTORY  Boot USING [BootFileType, DiskFileID, VolumeType],  DiskEditInternal USING [dataPtr, dataWindowKey, ReplaceUIDString, ValidateUID],  File USING [ID, nullID, Type],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    FilterProcType, ItemHandle, LabelItem, LongNumberItem, MenuProcType, newLine,    nextPlace, NumberItem, NumberNotifyProcType, ProcType, StringEditProc,    StringItem],  Heap USING [systemZone],  LogicalVolumeFormat USING [    currentVersion, Descriptor, maxLogicalVolumeLabelLength, lvRootSeal],  PilotDisk USING [FileID],  PilotFileTypes USING [    PilotRootFileType, tBeingMoved, tBeingReplicated, tFreePage, tScavengerLog,    tTempFileList, tTransactionStateFile, tVMBackingFile, tVolumeAllocationMap,    tVolumeFileMap],  String USING [FreeString, Replace],  System USING [nullID, UniversalID],  UserTerminal USING [BlinkDisplay],  Volume USING [Type],  WindowSwap USING [RegisterView];DiskEditLVRootPageSW: PROGRAM  IMPORTS DiskEditInternal, FormSW, Heap, String, UserTerminal, WindowSwap  SHARES Boot, File =  BEGIN  enumeratedLVBootFiles: ARRAY [0..6) OF FormSW.Enumerated = [    [string: "hardMicrocode"L, value: Boot.BootFileType[hardMicrocode]], [    string: "softMicrocode"L, value: Boot.BootFileType[softMicrocode]], [    string: "germ"L, value: Boot.BootFileType[germ]], [    string: "pilot"L, value: Boot.BootFileType[pilot]], [    string: "debugger"L, value: Boot.BootFileType[debugger]], [    string: "debuggee"L, value: Boot.BootFileType[debuggee]]];  enumeratedLVTypeArray: ARRAY [0..4) OF FormSW.Enumerated = [    [string: "normal"L, value: Volume.Type[normal]], [    string: "debugger"L, value: Volume.Type[debugger]], [    string: "debuggerDebugger"L, value: Volume.Type[debuggerDebugger]], [    string: "nonPilot"L, value: Volume.Type[nonPilot]]];  lvFillIndexIndex: CARDINAL ¬ 0;  lvFillValueIndex: CARDINAL ¬ 0;  lvBootFileIDIndex: CARDINAL ¬ 0;  lvBootFileFirstPageIndex: CARDINAL ¬ 0;  lvBootFileDiskAddressA: CARDINAL ¬ 0;  lvBootFileDiskAddressB: CARDINAL ¬ 0;  intervalKeyFileIDIndex: CARDINAL ¬ 0;  intervalKeyFilePageNumberIndex: CARDINAL ¬ 0;  intervalVolumePageNumberIndex: CARDINAL ¬ 0;  intervalNextKeyFileIDIndex: CARDINAL ¬ 0;  intervalNextKeyFilePageNumberIndex: CARDINAL ¬ 0;  currentRootFileIDStringIndex: CARDINAL ¬ 0;  Pair: TYPE = RECORD [UNSPECIFIED, UNSPECIFIED];    cardinalGmtEpoch: LONG CARDINAL ¬ 2114294400;   lvRootPage: RECORD [    -- fields herein which are passed to FormSW must be word-aligned.    IDString: LONG STRING ¬ NIL,    labelString: LONG STRING ¬ NIL,    type: Boot.VolumeType ¬ normal,    alignA: CARDINAL ¬ 0,    volumeRootDirectoryIDString: LONG STRING ¬ NIL,    currentFillIndex: CARDINAL ¬ 0,    currentFillValue: WORD ¬ 0,    currentRootFileType: File.Type ¬ PilotFileTypes.tFreePage,    currentRootFileIDString: LONG STRING ¬ NIL,    currentRootFileID: File.ID ¬ File.nullID,    changing: BOOLEAN ¬ FALSE,    scavengerIDString: LONG STRING ¬ NIL,    alignB: CARDINAL ¬ 0,    currentBootFileType: Boot.BootFileType ¬ pilot,    currentBootFileFileIDString: LONG STRING ¬ NIL,    currentBootFileDiskFile: Boot.DiskFileID ¬ [LOOPHOLE[System.nullID, unique PilotDisk.FileID], 0, LOOPHOLE[Pair[0, 0]]],      -- Preceeding LOOPHOLE should be fixed for proper exported type    labelLength: CARDINAL ¬ 0 ];      lv: LONG POINTER TO LogicalVolumeFormat.Descriptor = LOOPHOLE[DiskEditInternal.dataPtr];  CleanupLvRootPageSW: PROCEDURE =    BEGIN    -- The only things that are copied here are things that occupy less than a full  word in the actual root page.  Other things are set directly by the form sw.    lv.type ¬ lvRootPage.type;    lv.changing ¬ lvRootPage.changing;    lv.bootingInfo[lvRootPage.currentBootFileType] ¬      lvRootPage.currentBootFileDiskFile;    lv.rootFileID[lvRootPage.currentRootFileType] ¬ lvRootPage.currentRootFileID;    END;  CopyLabel: FormSW.FilterProcType =    BEGIN    FormSW.StringEditProc[sw, item, insert, string];    FOR i: CARDINAL IN      [0..MIN[         LogicalVolumeFormat.maxLogicalVolumeLabelLength,         lvRootPage.labelString.length]) DO      lv.label[i] ¬ lvRootPage.labelString[i]; ENDLOOP;    END;  DestroyLvRootPageSW: PROCEDURE =    BEGIN    -- Clean up resources for view going away for good.    String.FreeString[z: Heap.systemZone, s: lvRootPage.IDString];    lvRootPage.IDString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: lvRootPage.labelString];    lvRootPage.labelString ¬ NIL;    String.FreeString[      z: Heap.systemZone, s: lvRootPage.volumeRootDirectoryIDString];    lvRootPage.volumeRootDirectoryIDString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: lvRootPage.currentRootFileIDString];    lvRootPage.currentRootFileIDString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: lvRootPage.scavengerIDString];    lvRootPage.scavengerIDString ¬ NIL;    String.FreeString[      z: Heap.systemZone, s: lvRootPage.currentBootFileFileIDString];    lvRootPage.currentBootFileFileIDString ¬ NIL;    END;  FillBackCommand: FormSW.ProcType =    BEGIN    IF lvRootPage.currentFillIndex IN [0..LENGTH[lv.fill]) THEN      lv.fill[lvRootPage.currentFillIndex] ¬ lvRootPage.currentFillValue;    lvRootPage.currentFillIndex ¬      IF lvRootPage.currentFillIndex = 0 THEN LENGTH[lv.fill] - 1      ELSE lvRootPage.currentFillIndex - 1;    lvRootPage.currentFillValue ¬ lv.fill[lvRootPage.currentFillIndex];    FormSW.DisplayItem[sw, lvFillIndexIndex];    FormSW.DisplayItem[sw, lvFillValueIndex];    END;  FillLvRootPageSW: PROCEDURE =    BEGIN    longFileID: volumeRelative PilotDisk.FileID;     volumeLabel: STRING ¬ [LogicalVolumeFormat.maxLogicalVolumeLabelLength];    DiskEditInternal.ReplaceUIDString[@lvRootPage.IDString, lv.vID];    volumeLabel.length ¬ 0;    FOR i: CARDINAL IN      [0..MIN[LogicalVolumeFormat.maxLogicalVolumeLabelLength, lv.labelLength]) DO      volumeLabel[i] ¬ lv.label[i];      volumeLabel.length ¬ volumeLabel.length + 1      ENDLOOP;    String.Replace[@lvRootPage.labelString, volumeLabel, Heap.systemZone];    lvRootPage.labelLength ¬ lv.labelLength;    lvRootPage.type ¬ lv.type;    lvRootPage.changing ¬ lv.changing;    longFileID.fileID ¬ lv.volumeRootDirectory;    DiskEditInternal.ReplaceUIDString[      @lvRootPage.volumeRootDirectoryIDString, LOOPHOLE[longFileID, System.UniversalID]];        lvRootPage.currentFillValue ¬ lv.fill[lvRootPage.currentFillIndex];    lvRootPage.currentBootFileDiskFile ¬ lv.bootingInfo[      lvRootPage.currentBootFileType];    DiskEditInternal.ReplaceUIDString[      @lvRootPage.currentBootFileFileIDString,      LOOPHOLE[lvRootPage.currentBootFileDiskFile.fID]];    lvRootPage.currentRootFileID ¬ lv.rootFileID[lvRootPage.currentRootFileType];    longFileID.fileID ¬ lvRootPage.currentRootFileID;    DiskEditInternal.ReplaceUIDString[      @lvRootPage.currentRootFileIDString, LOOPHOLE[longFileID, System.UniversalID]];          DiskEditInternal.ReplaceUIDString[      @lvRootPage.scavengerIDString, lv.scavengerLogVolume];    END;  FillNextCommand: FormSW.ProcType =    BEGIN    IF lvRootPage.currentFillIndex IN [0..LENGTH[lv.fill]) THEN      lv.fill[lvRootPage.currentFillIndex] ¬ lvRootPage.currentFillValue;    lvRootPage.currentFillIndex ¬      (lvRootPage.currentFillIndex + 1) MOD LENGTH[lv.fill];    lvRootPage.currentFillValue ¬ lv.fill[lvRootPage.currentFillIndex];    FormSW.DisplayItem[sw, lvFillIndexIndex];    FormSW.DisplayItem[sw, lvFillValueIndex];    END;  MakeLvRootPageSW: FormSW.ClientItemsProcType =    BEGIN    i: CARDINAL ¬ 0;    nItems: CARDINAL = 32;    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[0] ¬ FormSW.LabelItem[tag: NIL, invisible: TRUE, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LabelItem[      tag: "Logical volume root page"L, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Seal"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: LogicalVolumeFormat.lvRootSeal, value: @lv.seal, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Version"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: LogicalVolumeFormat.currentVersion, value: @lv.version,      place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: TRUE, string: @lvRootPage.IDString,      filterProc: ValidateLVID, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Label length"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @lv.labelLength, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.StringItem[      tag: "Label"L, inHeap: TRUE, string: @lvRootPage.labelString,      filterProc: CopyLabel, place: FormSW.nextPlace];    BEGIN    localLVTypeArray: ARRAY [0..LENGTH[enumeratedLVTypeArray]) OF      FormSW.Enumerated ¬ enumeratedLVTypeArray;    items[i ¬ i + 1] ¬ FormSW.EnumeratedItem[      tag: "Type"L, feedback: one, copyChoices: TRUE, value: @lvRootPage.type,      choices: DESCRIPTOR[localLVTypeArray], place: FormSW.newLine];    END;    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "Size"L, signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @lv.volumeSize, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "Free page count"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @lv.freePageCount, place: FormSW.nextPlace];        items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "Lower bound"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @lv.lowerBound, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.BooleanItem[      tag: "changing"L, switch: @lvRootPage.changing, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "VAM start"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @lv.vamStart, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "VFM start"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @lv.vfmStart, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Checksum"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @lv.checksum, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.StringItem[      tag: "ScavengerLogID"L, inHeap: TRUE, string: @lvRootPage.scavengerIDString,      filterProc: ValidateScavengerID, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "LastIDAllocated"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: 0, value: @lv.lastIDAllocated, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "LastTimeOpendForWrite"L, signed: FALSE, notNegative: TRUE,       radix: octal, default: cardinalGmtEpoch, value:       @LOOPHOLE[lv.lastTimeOpendForWrite, LONG CARDINAL], place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.LabelItem[      tag: "Client root file capability"L, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: TRUE, string: @lvRootPage.volumeRootDirectoryIDString,      filterProc: ValidateRootDirectoryID, place: FormSW.nextPlace];    items[lvFillIndexIndex ¬ i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Fill word index"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: 0, value: @lvRootPage.currentFillIndex, proc: NoticeNewFillIndex,      place: FormSW.newLine];    items[lvFillValueIndex ¬ i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Value", signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @lvRootPage.currentFillValue, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.CommandItem[      tag: "Next", proc: FillNextCommand, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.CommandItem[      tag: "Back", proc: FillBackCommand, place: FormSW.nextPlace];    BEGIN    localLVBootFiles: ARRAY [0..LENGTH[enumeratedLVBootFiles]) OF      FormSW.Enumerated ¬ enumeratedLVBootFiles;    items[i ¬ i + 1] ¬ FormSW.EnumeratedItem[      tag: "Boot file for type"L, feedback: one, copyChoices: TRUE,      value: @lvRootPage.currentBootFileType, proc: NoticeNewBootFileType,      choices: DESCRIPTOR[localLVBootFiles], place: FormSW.newLine];    items[lvBootFileIDIndex ¬ i ¬ i + 1] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: TRUE, string: @lvRootPage.currentBootFileFileIDString,      filterProc: ValidateBootFileID, place: FormSW.nextPlace];    items[lvBootFileFirstPageIndex ¬ i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "   First page"L, notNegative: TRUE, signed: FALSE, default: 0,      radix: decimal, value: @lvRootPage.currentBootFileDiskFile.firstPage,      place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LabelItem[      tag: "Disk address"L, place: FormSW.nextPlace];    items[lvBootFileDiskAddressA ¬ i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "a"L, notNegative: TRUE, signed: FALSE, default: 0, radix: octal,      value: @lvRootPage.currentBootFileDiskFile.da, place: FormSW.nextPlace];    items[lvBootFileDiskAddressB ¬ i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "b"L, notNegative: TRUE, signed: FALSE, default: 0, radix: octal,      value: 1 + @lvRootPage.currentBootFileDiskFile.da, place: FormSW.nextPlace];    END;    BEGIN    enumeratedLVRootFiles: ARRAY [0..9) OF FormSW.Enumerated ¬ [      [string: "tBeingMoved"L, value: PilotFileTypes.tBeingMoved], [      string: "tBeingReplicated"L, value: PilotFileTypes.tBeingReplicated], [      string: "tFreePage"L, value: PilotFileTypes.tFreePage], [      string: "tScavengerLog"L, value: PilotFileTypes.tScavengerLog], [      string: "tTempFileList"L, value: PilotFileTypes.tTempFileList], [      string: "tTransactionStateFile"L,      value: PilotFileTypes.tTransactionStateFile], [      string: "tVMBackingFile"L, value: PilotFileTypes.tVMBackingFile], [      string: "tVolumeAllocationMap"L,      value: PilotFileTypes.tVolumeAllocationMap], [      string: "tVolumeFileMap"L, value: PilotFileTypes.tVolumeFileMap]];    items[i ¬ i + 1] ¬ FormSW.EnumeratedItem[      tag: "Root file for type"L, feedback: one, copyChoices: TRUE,      value: @lvRootPage.currentRootFileType, proc: NoticeNewRootFileType,      choices: DESCRIPTOR[enumeratedLVRootFiles], place: FormSW.newLine];    items[currentRootFileIDStringIndex ¬ i ¬ i + 1] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: TRUE, string: @lvRootPage.currentRootFileIDString,      filterProc: ValidateRootFileID, place: FormSW.nextPlace];    END;    IF i ~= nItems - 1 THEN ERROR;    RETURN[items, TRUE]    END;  NoticeNewBootFileType: FormSW.EnumeratedNotifyProcType =    BEGIN    lv.bootingInfo[oldValue] ¬ lvRootPage.currentBootFileDiskFile;    DiskEditInternal.ReplaceUIDString[      @lvRootPage.currentBootFileFileIDString, LOOPHOLE[lv.bootingInfo[      lvRootPage.currentBootFileType].fID]];    lvRootPage.currentBootFileDiskFile ¬ lv.bootingInfo[      lvRootPage.currentBootFileType];    FormSW.DisplayItem[sw, lvBootFileIDIndex];    FormSW.DisplayItem[sw, lvBootFileFirstPageIndex];    FormSW.DisplayItem[sw, lvBootFileDiskAddressA];    FormSW.DisplayItem[sw, lvBootFileDiskAddressB];    END;  NoticeNewFillIndex: FormSW.NumberNotifyProcType =    BEGIN    IF oldValue IN [0..LENGTH[lv.fill]) THEN      lv.fill[oldValue] ¬ lvRootPage.currentFillValue;    IF lvRootPage.currentFillIndex ~IN [0..LENGTH[lv.fill]) THEN      BEGIN UserTerminal.BlinkDisplay[]; RETURN; END;    lvRootPage.currentFillValue ¬ lv.fill[lvRootPage.currentFillIndex];    FormSW.DisplayItem[sw, lvFillValueIndex];    END;    NoticeNewRootFileType: FormSW.EnumeratedNotifyProcType =    BEGIN    longFileID: volumeRelative PilotDisk.FileID;    longFileID.fileID ¬ lv.rootFileID[lvRootPage.currentRootFileType];    DiskEditInternal.ReplaceUIDString[      @lvRootPage.currentRootFileIDString, LOOPHOLE[longFileID, System.UniversalID]];    FormSW.DisplayItem[sw, currentRootFileIDStringIndex];    END;  ValidateRootDirectoryID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[lvRootPage.volumeRootDirectoryIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE {      arrayID: ARRAY [0..5) OF WORD ¬ LOOPHOLE[id];      fileID: ARRAY[0..2) OF WORD ¬ [arrayID[0], arrayID[1]];      lv.volumeRootDirectory ¬ LOOPHOLE[fileID, File.ID] };    END;    ValidateBootFileID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      lvRootPage.currentBootFileFileIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE lvRootPage.currentBootFileDiskFile.fID ¬ LOOPHOLE[id];    END;  ValidateLVID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[lvRootPage.IDString];    IF ~valid THEN UserTerminal.BlinkDisplay[] ELSE lv.vID ¬ LOOPHOLE[id];    END;  ValidateRootFileID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      lvRootPage.currentRootFileIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE {      arrayID: ARRAY [0..5) OF WORD ¬ LOOPHOLE[id];      fileID: ARRAY [0..2) OF WORD ¬ [arrayID[0], arrayID[1]];      lvRootPage.currentRootFileID ¬ LOOPHOLE[fileID] };    END;      ValidateScavengerID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[lvRootPage.scavengerIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[] ELSE lv.scavengerLogVolume ¬ LOOPHOLE[id];    END;  -- Module initialization:  -- Register this subwindow as a view for the data subwindow  WindowSwap.RegisterView[    key: DiskEditInternal.dataWindowKey,    viewName: "LV root page"L,    makeFormSW: MakeLvRootPageSW,    viewFromDataProc: FillLvRootPageSW,    dataFromViewProc: CleanupLvRootPageSW,    destroyViewProc: DestroyLvRootPageSW];  END.LOG23-Sep-81 15:08:05   WDK       LONGified, converted to Tajo 8.  Wouldn't change lv label length.23-Sep-81 15:08:05   CAJ    LOOPHOLE'd initialization of Boot.DiskAddress in currentBootFileDiskFile.27-Apr-83 11:20:26   EKN      Update to Klamath (LogicalVolume => LogicalVolumeFormat) 1-Jul-83 11:06:26   Yien     Changed item[16].place from nextPlace to newLine since item[15] was a StringItem.30-Nov-83 11:08:43	EKN    Changed items: lv.labelLength, lv.volumeSize, lv.freePageCount, lv.lowerBound, lv.vamStart, lv.vfmStart, lv.checksum, lvRootPage.currentFillValue, lvRootPage.currentBootFileDiskFile.firstPage to display decimals instead of octals.  Also changed "softMicorcode" to "softMicrocode". 5-Sep-84 14:01:25   CAJ    Add registering window view via WindowSwap. 1-Mar-88  9:00:14   CAJ    Add DestroyLvRootPageSW.
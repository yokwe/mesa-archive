-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- VMTestDatabaseImpl.mesa     25-Apr-83 16:22:01 by CAJ -- Virtual memory test program.-- VMTestDatabaseImpl is a database which models Pilot VM.  All access to the-- model database goes through the procedures in this interface.DIRECTORY  BackingStore USING [Run],  Environment USING [PageCount, PageNumber],  PilotSwitches USING [zeroScratchMem],  --ResMemPerf USING [SetDefaultSwapUnitSize],  Space USING [Access, Allocate, Class, Deallocate, defaultSwapUnitSize, Error,    InsufficientSpace, Interval, Life, LongPointerFromPage, PageFromLongPointer,    SwapUnitOption, SwapUnitSize, SwapUnitType, Usage],  System USING [switches],  TryDefs USING [Ck],  VM USING [BackingStoreRuns, Interval, nullInterval,    Swappability],  VMTestBackingStore USING [InitializeBackingData],  VMTestDatabase,  VMTestSpace USING [GetSpace, ReturnSpace];VMTestDatabaseImpl: MONITOR  IMPORTS --ResMemPerf, --Space, System, TryDefs, VMTestBackingStore,    VMTestSpace  EXPORTS VMTestDatabase =  BEGIN  ------------  -- PUBLIC variables: none  ------------  -- PUBLIC SIGNALs and ERRORs:  TestVMTooBig: PUBLIC SIGNAL = CODE;  ------------  -- GLOBAL types, constants and variables:  Error: ERROR [type: ErrorType] = CODE;  ErrorType: TYPE = {bogusPage, impossibleCase, intervalNotMapUnit,    runTooLong, pastEndOfInterval, unterminatedSwapUnit};  -- *** Some of these need to be made RETURN WITH ERRORs ****  Index: TYPE = CARDINAL;  -- Model of each page in the test VM  PageData: TYPE = RECORD [    attributes: VMTestDatabase.Attributes,    seed: CARDINAL,  -- seed for regenerating page contents data    mapData: VMTestDatabase.MapUnit,    alternateRun: LONG POINTER TO BackingStore.Run,    runIndex: CARDINAL,      -- this is page runOffset of run MapUnitData.backingStoreRuns[runIndex]    runOffset: CARDINAL];  freedPage: CONDITION;  pageDatabase: LONG POINTER TO ARRAY [0..0) OF PageData ¬ NIL;  settableSeedSeed: CARDINAL ¬ 5031B;  testVM: VM.Interval ¬ VM.nullInterval;  undefinedPageSeed: CARDINAL = LAST[CARDINAL];  undefinedRun: CARDINAL = LAST[CARDINAL];  unlocked: CONDITION;  zeroPageSeed: CARDINAL = 0;  zeroScratchMem: BOOLEAN ¬ FALSE;  ------------  -- Interval ownership procedures  -- Gives an operation ownership of pages for the duration of the operation.  -- This high level locking mechanism does not provide low level flag protection.  -- No-op for null interval.  AcquireInterval: ENTRY PROCEDURE [interval: VM.Interval] =    BEGIN    IF interval.count ~= 0 THEN      BEGIN      gotEmAll: BOOLEAN ¬ FALSE;      page: Index ¬ PageIndex[interval.page];      DO        FOR i: CARDINAL IN [page..EndIndex[interval]) DO          IF pageDatabase[i].attributes.inUse THEN	    {Free[[interval.page, i - page]]; EXIT};	  pageDatabase[i].attributes.inUse ¬ TRUE;	  REPEAT	  FINISHED => gotEmAll ¬ TRUE;	  ENDLOOP;        IF gotEmAll THEN EXIT ELSE WAIT freedPage;        ENDLOOP;      END;    END;  -- Ensure interval is in test program's VM, and acquire it.  This must be  -- the first action in any modelled VM operation on the database.  CheckAndAcquireInterval: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    CheckInterval[interval];    AcquireInterval[interval];    END;  -- Change page ownership to match new interval boundaries as adjusted by a  -- particular operation.  The call is a noop if new = current.  CorrectAcquiredInterval: PUBLIC PROCEDURE [current, new: VM.Interval] =    BEGIN    IF new = current THEN RETURN;    -- Caller must not be holding any critical resources; wait may be necessary.    ReleaseInterval[current];    AcquireInterval[new];    END;  Free: INTERNAL PROCEDURE [interval: VM.Interval] =    BEGIN    IF interval.count = 0 THEN RETURN;    FOR i: CARDINAL IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.inUse ¬ FALSE      ENDLOOP;    END;  -- Frees pages for initiation of another operation  ReleaseInterval: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    -- The interval parameter is the actual VM interval    {Free[interval]; BROADCAST freedPage};  -- Protect an interval of pages while a backing store transfer is in progress.  Lock: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    BEGIN    -- A null interval should never get here    gotEmAll: BOOLEAN ¬ FALSE;    page: Index ¬ PageIndex[interval.page];    DO      FOR i: CARDINAL IN [page..EndIndex[interval]) DO        IF pageDatabase[i].attributes.transferring THEN	  {UnlockInternal[[interval.page, i - page]]; EXIT};	pageDatabase[i].attributes.transferring ¬ TRUE;	REPEAT	FINISHED => gotEmAll ¬ TRUE;	ENDLOOP;      IF gotEmAll THEN EXIT ELSE WAIT unlocked;      ENDLOOP;    END;  Unlock: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {UnlockInternal[interval]; BROADCAST unlocked};  UnlockInternal: INTERNAL PROCEDURE [interval: VM.Interval] =    BEGIN    page: Index ¬ PageIndex[interval.page];    FOR i: CARDINAL IN [page..EndIndex[interval]) DO      pageDatabase[i].attributes.transferring ¬ FALSE      ENDLOOP;    END;  ------------  -- Other PUBLIC Monitor procedures  -- All Mark* and Clear* procedures assume caller does all determining of  -- actual interval implied by an operation (e.g., expand to enclosing  -- swap unit boundaries).  ClearActivating: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.activating ¬ FALSE ENDLOOP};  ClearCopyingIn: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.copyingIn ¬ FALSE ENDLOOP};  ClearCopyingOut: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.copyingOut ¬ FALSE ENDLOOP};  ClearDeactivating: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.deactivating ¬ FALSE ENDLOOP};  ClearForcingOut: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.forcingOut ¬ FALSE ENDLOOP};  MarkActivating: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.activating ¬ TRUE ENDLOOP};  MarkAlive: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    BEGIN    impliedInterval: VM.Interval ¬ FindEnclosingSwapUnits[interval];      -- implied interval is already converted to zero-relative value    FOR i: Index IN [      PageIndex[impliedInterval.page]..EndIndex[impliedInterval]) DO        pageDatabase[i].attributes.alive ¬ TRUE ENDLOOP;    END;  MarkClean: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.clean ¬ TRUE ENDLOOP};  MarkCopyingIn: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.copyingIn ¬ TRUE ENDLOOP};  MarkCopyingOut: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.copyingOut ¬ TRUE ENDLOOP};  MarkDeactivating: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.deactivating ¬ TRUE ENDLOOP};  MarkDead: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    BEGIN    FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.alive ¬ FALSE;      pageDatabase[i].seed ¬ undefinedPageSeed;      ENDLOOP;    END;  MarkDirty: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.clean ¬ FALSE ENDLOOP};  MarkForcingOut: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.forcingOut ¬ TRUE ENDLOOP};  MarkReadonly: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    BEGIN    FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      IF pageDatabase[i].attributes.mapped THEN        pageDatabase[i].attributes.readonly ¬ TRUE;      ENDLOOP;    END;  MarkResident: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    BEGIN    FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      IF pageDatabase[i].attributes.mapped THEN        pageDatabase[i].attributes.swappable ¬ FALSE;      ENDLOOP;    END;  MarkSwappable: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    BEGIN    FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      IF pageDatabase[i].attributes.mapped THEN        pageDatabase[i].attributes.swappable ¬ TRUE;      ENDLOOP;    END;  MarkWritable: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    BEGIN    FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      IF pageDatabase[i].attributes.mapped THEN        pageDatabase[i].attributes.readonly ¬ FALSE;      ENDLOOP;    END;  -- Setup the map unit's pages in the database with all mapping information.  MapDatabasePages: PUBLIC ENTRY PROCEDURE [mapUnit: VMTestDatabase.MapUnit] =    BEGIN OPEN mapUnit;    -- mapUnit is always a real pointer, i.e., no null intervals here.    FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].attributes.mapped ¬ TRUE;      pageDatabase[i].attributes.alive ¬         IF access = readOnly THEN TRUE ELSE life = alive;      pageDatabase[i].attributes.clean ¬ TRUE;      pageDatabase[i].attributes.readonly ¬ access = readOnly;      pageDatabase[i].attributes.swappable ¬  swappability = swappable;      IF backed AND life = alive THEN        pageDatabase[i].seed ¬ GenerateRandomSeed[];      IF ~backed AND swappability = resident AND zeroScratchMem THEN        pageDatabase[i].seed ¬ zeroPageSeed;      -- otherwise value remains undefinedPageSeed      pageDatabase[i].mapData ¬  mapUnit;      ENDLOOP;    MarkIndexPairs[interval, backingStoreRuns];    MarkSwapUnits[interval, swapUnits, backingStoreRuns];    END;  SetAlternateRun: PUBLIC ENTRY PROCEDURE [    interval: VM.Interval, run: LONG POINTER TO BackingStore.Run] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].alternateRun ¬ run; ENDLOOP};  -- Replace the expected contents of a test VM page  SetSeed: PUBLIC ENTRY PROCEDURE [interval: VM.Interval] =    {FOR i: Index IN [PageIndex[interval.page]..EndIndex[interval]) DO      pageDatabase[i].seed ¬ GenerateRandomSeed[]; ENDLOOP};  UnmapDatabasePages: PUBLIC ENTRY PROCEDURE [mapUnit: VMTestDatabase.MapUnit] =    BEGIN    IF mapUnit = NIL THEN RETURN;    FOR i: Index IN        [PageIndex[mapUnit.interval.page]..EndIndex[mapUnit.interval]) DO      pageDatabase[i].attributes ¬ VMTestDatabase.unmappedPage;      pageDatabase[i].seed ¬ undefinedPageSeed;      pageDatabase[i].mapData ¬ NIL;      pageDatabase[i].alternateRun ¬ NIL;      pageDatabase[i].runOffset ¬ pageDatabase[i].runIndex ¬ undefinedRun;      ENDLOOP;    END;  -- Determines whether all pages in interval are expected state.  The  -- nullInterval always verifies.  VerifyMapState: PUBLIC PROCEDURE [    interval: VM.Interval, expect: VMTestDatabase.MappedUnmapped]      RETURNS [BOOLEAN] =    BEGIN    match: BOOLEAN ¬ expect = mapped;    page: Index ¬ PageIndex[interval.page];    FOR i: CARDINAL IN [page..EndIndex[interval]) DO      IF pageDatabase[page].attributes.mapped ~= match THEN RETURN[FALSE]      ENDLOOP;    RETURN[TRUE]    END;  ------------  -- PUBLIC unmonitored procedures:  -- Allocate and initiate map unit data structure.  CreateMapUnit: PUBLIC PROCEDURE [    id: LONG STRING, interval: VM.Interval, backed: BOOLEAN,    runs: VM.BackingStoreRuns, usage: Space.Usage, class: Space.Class,    access: Space.Access, swapUnits: Space.SwapUnitOption, life: Space.Life,    swappability: VM.Swappability]    RETURNS [mapUnit: VMTestDatabase.MapUnit] =    BEGIN    mapUnit ¬ VMTestSpace.GetSpace[SIZE[VMTestDatabase.MapUnitData], resident];    mapUnit­ ¬ [      id: id, interval: interval, backed: backed, backingStoreRuns: runs,      usage: usage, class: class, access: access, swapUnits: swapUnits,      life: life, swappability: swappability];    VMTestBackingStore.InitializeBackingData[runs, interval.page, map];    END;  -- Release map unit storage and reset map unit's pages.  DestroyMapUnit: PUBLIC PROCEDURE [    mapUnit: VMTestDatabase.MapUnit, updatePages: BOOLEAN] =    -- This guy happens to know about the backing and swap data allocations    -- generated by the script client via MakeBacking/IrregularSwapData procs.    -- Since exactly what backing and swap data are is hidden from the client,    -- the allocations must be returned here.    -- The leaveMapped parameter allows distinction between the case where the    -- pages are being unmapped and the case where just the map unit is going    -- away, as after a Map error.    BEGIN    IF mapUnit = NIL THEN RETURN;    IF mapUnit.backed THEN      VMTestSpace.ReturnSpace[BASE[mapUnit.backingStoreRuns]];    WITH mapUnit.swapUnits SELECT FROM      unitary => NULL;      uniform => NULL;      irregular => VMTestSpace.ReturnSpace[BASE[sizes]];      ENDCASE => NULL;    IF updatePages THEN UnmapDatabasePages[mapUnit];    VMTestSpace.ReturnSpace[mapUnit];    END;  -- Determine the interval covering all swap units which are entirely included  -- within the parameter interval.  There may be unmapped intervals embedded  -- in the enclosing interval.  There may also be mapped pages which are  -- beginning or end fragments of swap units which are not entirely contained  -- in interval.  If there is no complete swap unit, then VM.nullInterval  -- is returned.  FindEnclosedSwapUnits: PUBLIC PROCEDURE [interval: VM.Interval]    RETURNS [VM.Interval] =    BEGIN    endPage: Index;    startPage: Index;    IF interval.count = 0 THEN GOTO noSwapUnit;    -- Find start of the first swap unit in interval, if any.    FOR startPage IN [PageIndex[interval.page]..EndIndex[interval]) DO      IF pageDatabase[startPage].attributes.mapped AND        pageDatabase[startPage].attributes.startOfSwapUnit THEN EXIT;      REPEAT      FINISHED => GOTO noSwapUnit;      ENDLOOP;    -- Now look backwards from end for end of swap unit, if any.    FOR endPage DECREASING IN      [startPage..PageIndex[interval.page + interval.count - 1]] DO      IF pageDatabase[endPage].attributes.mapped AND        pageDatabase[endPage].attributes.endOfSwapUnit THEN EXIT;      REPEAT      FINISHED => GOTO noSwapUnit;      ENDLOOP;    RETURN[[UserToVMPage[startPage], endPage - startPage + 1]];    EXITS noSwapUnit => RETURN [VM.nullInterval];    END;  -- Determine the interval covering all swap units which include any portion of  -- the parameter interval.  There may be unmapped intervals embedded in the  -- enclosing interval.  If none of interval is mapped, then VM.nullInterval  -- is returned.  FindEnclosingSwapUnits: PUBLIC PROCEDURE [interval: VM.Interval]    RETURNS [VM.Interval] =    BEGIN    endPage: Index;    startPage: Index;    IF interval.count = 0 THEN GOTO noMapped;    -- Find first mapped page in interval and ensure at least one page is mapped.    FOR startPage IN [PageIndex[interval.page]..EndIndex[interval]) DO      IF pageDatabase[startPage].attributes.mapped THEN EXIT;      REPEAT      FINISHED => GOTO noMapped;      ENDLOOP;    WHILE ~pageDatabase[startPage].attributes.startOfSwapUnit DO      startPage ¬ startPage - 1 ENDLOOP;    -- Extend or back up at end of interval: if the last page is unmapped, then    -- back up to a mapped page if it is mapped, extend to end of the swap unit.    endPage ¬ PageIndex[interval.page + interval.count - 1];    WHILE ~pageDatabase[endPage].attributes.mapped DO      endPage ¬ endPage - 1 ENDLOOP;    WHILE ~pageDatabase[endPage].attributes.endOfSwapUnit DO      endPage ¬ endPage + 1 ENDLOOP;    IF ~pageDatabase[endPage].attributes.mapped      THEN Error[unterminatedSwapUnit];  -- impossible    RETURN [[UserToVMPage[startPage], endPage - startPage + 1]];    EXITS noMapped => RETURN [VM.nullInterval];    END;  GetAlternateRun: PUBLIC PROCEDURE [page: Environment.PageNumber]    RETURNS [run: LONG POINTER TO BackingStore.Run] =    {RETURN[pageDatabase[PageIndex[page]].alternateRun]};  GetMapUnit: PUBLIC PROCEDURE [page: Environment.PageNumber]    RETURNS [mapUnit: VMTestDatabase.MapUnit] =    {RETURN[pageDatabase[PageIndex[page]].mapData]};  GetPageAttributes: PUBLIC PROCEDURE [page: Environment.PageNumber]    RETURNS [attributes: VMTestDatabase.Attributes] =    {RETURN[pageDatabase[PageIndex[page]].attributes]};  GetPageSeed: PUBLIC PROCEDURE [page: Environment.PageNumber]    RETURNS [seed: CARDINAL] =    {RETURN[pageDatabase[PageIndex[page]].seed]};  GetRunIndex: PUBLIC PROCEDURE [page: Environment.PageNumber]    RETURNS [index: CARDINAL] =    {RETURN[pageDatabase[PageIndex[page]].runIndex]};  GetRunOffset: PUBLIC PROCEDURE [page: Environment.PageNumber]    RETURNS [offset: CARDINAL] =    {RETURN[pageDatabase[PageIndex[page]].runOffset]};  -- Get the number of pages in test VM.  GetTestVMSize: PUBLIC PROCEDURE RETURNS [Environment.PageCount] =    {RETURN[testVM.count]};  -- Create and initialize the database.  Initialize: PUBLIC PROCEDURE [pagesInTestVM: Environment.PageCount] =    BEGIN    -- allocate our own (subset of) virtual memory:    rawSpace: Space.Interval ¬ Space.Allocate[pagesInTestVM      ! Space.InsufficientSpace => SIGNAL TestVMTooBig];    testVM ¬ [Space.PageFromLongPointer[rawSpace.pointer], rawSpace.count];    zeroScratchMem ¬ System.switches[PilotSwitches.zeroScratchMem] = down;    -- allocate and initialize per/page database for test vm:    pageDatabase ¬      VMTestSpace.GetSpace[SIZE[PageData]*pagesInTestVM,      resident ! Space.InsufficientSpace => SIGNAL TestVMTooBig];    FOR i: Index IN [0..IndexFromPage[pagesInTestVM]) DO      pageDatabase[i] ¬        [attributes: VMTestDatabase.unmappedPage,         seed: undefinedPageSeed, mapData: NIL, alternateRun: NIL,         runIndex: undefinedRun, runOffset: undefinedRun];      ENDLOOP;    END;      MakeIrregularSwapData: PUBLIC PROCEDURE [sizes: VMTestDatabase.ArrayDescriptor]    RETURNS [option: Space.SwapUnitOption] =    BEGIN    length: CARDINAL = LENGTH[sizes];    sizeArray: irregular Space.SwapUnitOption ¬      [irregular[DESCRIPTOR [VMTestSpace.GetSpace[        length * SIZE[Space.SwapUnitOption[irregular]], resident],      length]]];    FOR i: CARDINAL IN [0..length) DO      sizeArray.sizes[i] ¬ sizes[i] ENDLOOP;    option ¬ sizeArray;    END;  MakeUniformSwapData: PUBLIC PROCEDURE [size: Space.SwapUnitSize]    RETURNS [option: Space.SwapUnitOption] =    BEGIN    IF size = 0 OR size = Space.defaultSwapUnitSize THEN      {size ¬ 1};      -- Replace preceding line with following two when ResMemPerf exported.      --{size ¬ ResMemPerf.SetDefaultSwapUnitSize[1];      --  [] ¬ ResMemPerf.SetDefaultSwapUnitSize[size]};    option ¬ [uniform[size]];    END;  MakeUnitarySwapData: PUBLIC PROCEDURE    RETURNS [option: Space.SwapUnitOption] =    {option ¬ [unitary[]]};  -- Terminate database and release its resources.  Shutdown: PUBLIC PROCEDURE =    BEGIN    Space.Deallocate[[Space.LongPointerFromPage[testVM.page], testVM.count]      ! Space.Error => CONTINUE];    testVM ¬ VM.nullInterval;    VMTestSpace.ReturnSpace[pageDatabase];    pageDatabase ¬ NIL;    END;  -- Find the total number of pages of backing store for map unit  TotalBS: PUBLIC PROCEDURE [runs: VM.BackingStoreRuns]    RETURNS [pages: Environment.PageCount] =    BEGIN    pages ¬ 0;    IF runs ~= NIL THEN      FOR i: CARDINAL IN [0..LENGTH[runs])        DO pages ¬ pages + runs[i].count ENDLOOP;    END;  -- Determine whether page has a state where page contents are considered  -- undefined by Pilot (dead page or unbacked + resident data unit page).  UndefinedPageContents: PUBLIC PROCEDURE [    page: Environment.PageNumber] RETURNS [BOOLEAN] =    {RETURN[pageDatabase[PageIndex[page]].seed = undefinedPageSeed]};  -- Find real VM page number for script client (test VM relative) page number  --   No check is made for valid page number.  UserToVMPage: PUBLIC PROCEDURE [page: Environment.PageNumber]    RETURNS [Environment.PageNumber] =    {RETURN[page + testVM.page]};  -- Find user (script) page number for actual VM page number  --   No check is made for valid page number.  VMToUserPage: PUBLIC PROCEDURE [page: Environment.PageNumber]    RETURNS [Environment.PageNumber] =    {RETURN[page - testVM.page]};  -- Convert script user's zero-relative interval to actual VM interval.  VMInterval: PUBLIC PROCEDURE [interval: VM.Interval] RETURNS [VM.Interval] =    {RETURN[      IF interval = VM.nullInterval THEN VM.nullInterval      ELSE [UserToVMPage[interval.page], interval.count]]};  -- Determine whether page is defined to be all zeros.  --  (This is currently only available via a bootswitch option to cause  --   initialization of data map units to zeros.)  ZeroPageContents: PUBLIC PROCEDURE [    page: Environment.PageNumber] RETURNS [BOOLEAN] =    {RETURN[pageDatabase[PageIndex[page]].seed = zeroPageSeed]};  ------------  -- PRIVATE INTERNAL Procedures:  -- Set the values for each page's index into the backing store run array  -- and its page offset within the run.  MarkIndexPairs: INTERNAL PROCEDURE    [interval: VM.Interval, runs: VM.BackingStoreRuns] =    BEGIN    page: Index ¬ PageIndex[interval.page];    runOffset, runIndex: CARDINAL ¬ 0;    IF runs = NIL THEN RETURN;    FOR i: CARDINAL IN [page..EndIndex[interval]) DO      pageDatabase[i].runOffset ¬ runOffset;      pageDatabase[i].runIndex ¬ runIndex;      runOffset ¬ runOffset + 1;      IF runOffset >= runs[runIndex].count THEN        {runIndex ¬ runIndex + 1; runOffset ¬ 0};      ENDLOOP;     END;  -- Set flags for beginning and end of swap units, which are the subgroups of  -- pages in the interval as broken up by swap unit breaks, run breaks, and  -- the interval boundaries.  MarkSwapUnits: INTERNAL PROCEDURE    [interval: VM.Interval, swapUnitOption: Space.SwapUnitOption,     runs: VM.BackingStoreRuns] =    BEGIN    CheckSize: INTERNAL PROC [run: Environment.PageCount] RETURNS [CARDINAL] =      BEGIN      IF run >= LAST[CARDINAL] THEN Error[runTooLong];      RETURN[CARDINAL[run]];      END;    -- The following constant is not exported from Pilot; we just know it.    -- It is not expected to change, ever.  If it does, some test will break    -- and we will fix the constant.     maxIrregularSwapUnit: CARDINAL = 16;    actualSwapSize: Space.SwapUnitSize;    beginSwapUnit: Index ¬ PageIndex[interval.page];    endSwapUnit: Index;    irregularSwapUnits: BOOLEAN ¬ FALSE;    lastPage: Index = PageIndex[interval.page + interval.count - 1];    runOffset: CARDINAL ¬ 0;    runLeft: CARDINAL;    swapOffset: CARDINAL ¬ 0;    swapLeft: Space.SwapUnitSize;    -- Assume backingStoreRuns >= interval    -- Runs may bear no correspondence to swap unit boundaries, and a run may    -- continue beyond the specified interval, as may the BackingStoreRuns array.    -- Setup initial values    runLeft ¬      IF runs ~= NIL THEN CheckSize[runs[0].count] ELSE LAST[CARDINAL];    WITH swapUnitOption SELECT FROM      unitary => swapLeft ¬ CheckSize[interval.count];      uniform => swapLeft ¬ size;      irregular =>        {swapLeft ¬ sizes[0];	 irregularSwapUnits ¬ TRUE;};      ENDCASE => Error[impossibleCase];    -- now mark off the interval into actual swap units    UNTIL beginSwapUnit > lastPage DO      IF runLeft = 0 THEN        runLeft ¬ CheckSize[runs[runOffset ¬ runOffset + 1].count];      IF swapLeft = 0 THEN        swapLeft ¬ WITH swapUnitOption SELECT FROM          uniform => size,          irregular => sizes[swapOffset ¬ swapOffset + 1],	  ENDCASE => Error[pastEndOfInterval];      pageDatabase[beginSwapUnit].attributes.startOfSwapUnit ¬ TRUE;      actualSwapSize ¬ MIN[runLeft, swapLeft];      swapLeft ¬ swapLeft - actualSwapSize;      IF irregularSwapUnits THEN        {IF actualSwapSize > maxIrregularSwapUnit THEN	  {swapLeft ¬ swapLeft + actualSwapSize - maxIrregularSwapUnit;	   actualSwapSize ¬ maxIrregularSwapUnit}};      runLeft ¬ runLeft - actualSwapSize;      endSwapUnit ¬ MIN[beginSwapUnit + actualSwapSize - 1, lastPage];      pageDatabase[endSwapUnit].attributes.endOfSwapUnit ¬ TRUE;      beginSwapUnit ¬ beginSwapUnit + actualSwapSize;      ENDLOOP;    END;  ------------  -- PRIVATE Procedures:  -- Ensure interval is in subset of VM owned by test program  CheckInterval: PROCEDURE [interval: VM.Interval] =    -- ok => noop    -- not ok => log message, signal debugger    {TryDefs.Ck[      "interval in test VM"L, NIL, InTestVM[interval]]};  -- Cretinous random number generator, adapted form PilotTests.StorageExerciser.  -- This generates a number which is random over all calls.  GenerateRandomSeed: PROCEDURE RETURNS [CARDINAL] =    BEGIN    DO      IF (settableSeedSeed ¬ 26207B*settableSeedSeed + 35011B) = zeroPageSeed        THEN LOOP;      IF settableSeedSeed ~= undefinedPageSeed THEN EXIT;      ENDLOOP;    RETURN[settableSeedSeed];    END;  -- Convert a zero-relative VMTest page value from a long page number  -- to a single word value, usually for use as an index.  The zero-relative  -- page values are known to be representable in a single word because  -- the size of testVM is thus constrained.  IndexFromPage: PROCEDURE [page: Environment.PageNumber] RETURNS [Index] =    INLINE {IF page > LAST[Index] THEN Error[bogusPage] ELSE RETURN[Index[page]]};  InTestVM: PROCEDURE [interval: VM.Interval] RETURNS [BOOLEAN] =    {RETURN[((interval.page >= testVM.page)      AND (interval.page + interval.count <= testVM.page + testVM.count))      OR (interval = VM.nullInterval)]};  -- Find index value for open end value of the given interval.  If the interval  -- is null, then the initial page is returned (=> noop open interval).  EndIndex: PROCEDURE [interval: VM.Interval] RETURNS [Index] =    -- The index is known to be in the range [0..testVM.count), i.e., CARDINAL.    INLINE {RETURN[      IF interval = VM.nullInterval THEN Index[interval.page]      ELSE IndexFromPage[VMToUserPage[interval.page] + interval.count]]};  -- Converts VM page number to its index into the page database  PageIndex: PROCEDURE [page: Environment.PageNumber] RETURNS [Index] =    INLINE {RETURN[IndexFromPage[VMToUserPage[page]]]};  -- Identical to function of PageIndex except no INLINEs, for debugging.  PrivatePageIndex: PROCEDURE [page: Environment.PageNumber] RETURNS [Index] =    {RETURN[Index[VMToUserPage[page]]]};  ------------  -- PUBLIC SIGNALs and ERRORs: none  END.LOG30-Aug-82 13:08:12   CAJ    Created file.  
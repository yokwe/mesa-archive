-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- GumoutProcess.mesa	24-Jan-85 16:02:31 by CAJ -- Floppy Disk Tool Command HandlerDIRECTORY  Environment   USING [wordsPerPage],  FloppyChannel USING [    Context, DiskAddress, Error, FormatTracks, GetHandle, GetNextDrive, Handle,    Nop, nullDrive, ReadSectors, SetContext, Status, WriteDeletedSectors,    WriteSectors],  Format        USING [NumberFormat],  GumoutDefs    USING [    CurrentContext, FillType, nCylinders, nHeads, nSectors, state, toolData],  Inline        USING [    BITAND, BITOR, BITSHIFT, DIVMOD, HighByte, HighHalf, LongCOPY, LongMult,    LowByte, LowHalf],  MsgSW         USING [Post, Clear],  Put           USING [Blanks, Char, CR, Decimal, Line, LongString, Number, Text],  Space         USING [ScratchMap, Unmap],  System        USING [GetClockPulses],  Window        USING [Handle];GumoutProcess: MONITOR  IMPORTS    FloppyChannel, GumoutDefs, Inline, MsgSW, Put, Space, System  EXPORTS GumoutDefs =  BEGIN OPEN toolData: GumoutDefs.toolData;    -- constants:  -- words in dataSpace: (must be >= Context.sectorLength*operation count)  dataSize: CARDINAL = maxSectorPages*Environment.wordsPerPage;    -- words in dataSpace  maxSectorPages: CARDINAL = 2;  -- pages to hold largest (512 word) sector  -- global variables  dataSpace:  LONG POINTER ¬ NIL;  newCommand: CONDITION;  -- local  GumoutError: PRIVATE ERROR [ErrorType] = CODE;  ErrorType:   TYPE = {bufferOverflow, noSuchFunction};  -- Procedures  CommandProcessor: PUBLIC PROCEDURE =    BEGIN    -- This process is forked when the tool becomes active.    dataSpace ¬ Space.ScratchMap[maxSectorPages];    AdoptNewDisk[];    -- main command processing loop    DO      GumoutDefs.state ¬ null;      AwaitCommand[];      SELECT GumoutDefs.state FROM        quit => EXIT;  -- quit gets here only from make-inactive        start, diskChange =>          BEGIN          MsgSW.Clear[toolData.msgSW];          IF NOT toolData.drivePresent THEN {            MsgSW.Post[toolData.msgSW, "No floppy drive present."L]; LOOP};          IF GumoutDefs.state = diskChange THEN AdoptNewDisk[]          ELSE  -- start --            SELECT toolData.function FROM              read, write, writeDeleted => Xfer[];              format => FormatDisk[];              nop => Nop[];              ENDCASE => Put.Line[toolData.fileSW, "Not implemented."L];          END;        ENDCASE => NULL;  -- null or reset      -- state may have gone to reset during processing of previous state      IF GumoutDefs.state = reset THEN Put.Line[toolData.fileSW, "RESET"L];      ENDLOOP;    -- Here on quit    dataSpace ¬ Space.Unmap[dataSpace];    END;  -- Monitor procedures  AdoptNewDisk: ENTRY PROCEDURE =    -- Implements NewDisk command; also called to initialize floppy at startup.    -- Waits for new disk to come ready, gets handle, and updates toolData.    BEGIN    DO      toolData.floppyDrive ¬ GetHandle[];      IF FloppyChannel.Nop[toolData.floppyDrive        ! FloppyChannel.Error =>	  {IF type = invalidHandle THEN LOOP ELSE FloppyChannel.Error[type]}	].status ~= notReady THEN EXIT;      ENDLOOP;    END;  AwaitCommand: ENTRY PROCEDURE =    -- waits for notification that a command has been selected.    BEGIN WAIT newCommand; END;  FormatDisk: ENTRY PROCEDURE =    -- Formats entire disk according to current context setting.    BEGIN OPEN t: toolData;    badPages:  CARDINAL ¬ 0;    c:         FloppyChannel.Context;    count:     CARDINAL;    countDone: CARDINAL;    status:    FloppyChannel.Status;    Put.Text[t.fileSW, "formatting..."L];    BEGIN    -- track 0    c ¬ [      protect: FALSE, format: IBM, density: single,      sectorLength: 64--128 bytes--];    IF ~FloppyChannel.SetContext[t.floppyDrive, c] THEN GOTO contextFailure;    [status, countDone] ¬ FloppyChannel.FormatTracks[      t.floppyDrive, [cylinder: 0, head: 0, sector: 1], GumoutDefs.nHeads];    IF countDone < GumoutDefs.nHeads THEN GOTO badTrack;    -- remainder of the disk    IF ~FloppyChannel.SetContext[t.floppyDrive, GumoutDefs.CurrentContext[]] THEN      GOTO contextFailure;    count ¬ GumoutDefs.nHeads * GumoutDefs.nCylinders - countDone;    [status, countDone] ¬ FloppyChannel.FormatTracks[      t.floppyDrive, [cylinder: 1, head: 0, sector: 1], count];    IF countDone < count THEN GOTO badTrack;  -- one error and you're out    EXITS      badTrack =>	BEGIN	Put.Text[t.fileSW, "Bad track "L];	Put.Decimal[t.fileSW, countDone];	Put.Text[t.fileSW, "; can't format. "L];	END;      contextFailure => Put.Text[t.fileSW, "Can't format with this context. "L];    END;    PostStatus[status];    END;  GetHandle: PUBLIC PROCEDURE RETURNS [FloppyChannel.Handle] =    {RETURN[FloppyChannel.GetHandle[      FloppyChannel.GetNextDrive[FloppyChannel.nullDrive]]]};  NotifyCommandProcessor: PUBLIC ENTRY PROCEDURE = BEGIN NOTIFY newCommand; END;  Nop: ENTRY PROCEDURE =    -- Recalibrates and reports status.    BEGIN PostStatus[FloppyChannel.Nop[toolData.floppyDrive]]; END;  ResetContext: PUBLIC ENTRY PROCEDURE [new: FloppyChannel.Context]    RETURNS [ok: BOOLEAN] =    -- Changes context (protect, format, density, sectorLength) to specified.    BEGIN RETURN[FloppyChannel.SetContext[toolData.floppyDrive, new]]; END;  Xfer: ENTRY PROCEDURE =    -- Implements Read, Write, WriteDeleted.    -- Does transfer, reports status, and displays data buffer if called for.    BEGIN OPEN t: toolData;    addr: FloppyChannel.DiskAddress ¬ GetAddr[];    count: CARDINAL ¬ GetCount[];    countDone, countPass: CARDINAL;    maxPerPass: CARDINAL = dataSize/t.context.sectorLength;    status: FloppyChannel.Status;    xferFunc: PROC [      handle: FloppyChannel.Handle, address: FloppyChannel.DiskAddress,      buffer: LONG POINTER, count: CARDINAL, incrementDataPtr: BOOLEAN]      RETURNS [status: FloppyChannel.Status, countDone: CARDINAL];    Put.Text[t.fileSW, "started..."L];    SELECT t.function FROM      read => xferFunc ¬ FloppyChannel.ReadSectors;      write => {FillBuffer[t.fill]; xferFunc ¬ FloppyChannel.WriteSectors};      writeDeleted => {        FillBuffer[t.fill]; xferFunc ¬ FloppyChannel.WriteDeletedSectors};      ENDCASE => ERROR GumoutError[noSuchFunction];    IF count = 0 THEN Put.Line[t.fileSW, " no transfer"L]    ELSE BEGIN      WHILE count > 0 DO        countPass ¬ MIN[count, maxPerPass];        IF countPass*t.context.sectorLength > dataSize	  THEN ERROR GumoutError[bufferOverflow];        [status, countDone] ¬	  xferFunc[t.floppyDrive, addr, dataSpace, countPass, TRUE	    ! FloppyChannel.Error => IF type = invalidHandle THEN GOTO badHandle];        IF t.print THEN PrintBuffer[addr, countDone];        count ¬ count - countDone;        addr ¬ IncAddr[addr, countDone];        IF (status ~= goodCompletion) OR (GumoutDefs.state = reset)	  THEN {PrintDiskAddress[addr]; EXIT};        ENDLOOP;      PostStatus[status]      END;    EXITS      badHandle => Put.Line[t.fileSW, " invalid handle"L];    END;  -- Internal procedures  FillBuffer: INTERNAL PROCEDURE [what: GumoutDefs.FillType] =    BEGIN    SELECT what FROM      leaveAlone => RETURN;      random =>        BEGIN        seed: CARDINAL ¬ Inline.LowHalf[System.GetClockPulses[]];        p: LONG POINTER ¬ dataSpace;        THROUGH [0..dataSize) DO [p­, seed] ¬ Random[seed]; p ¬ p + 1; ENDLOOP;        END;      ENDCASE =>  -- ones, zeroes        BEGIN        dataSpace­ ¬ IF what = zeroes THEN 0 ELSE -1;        Inline.LongCOPY[from: dataSpace, nwords: dataSize - 1, to: dataSpace + 1];        END;    END;  GetAddr: INTERNAL PROCEDURE RETURNS [address: FloppyChannel.DiskAddress] =    BEGIN OPEN toolData;    RETURN[      FloppyChannel.DiskAddress[        cylinder: startAddr.cylinder, head: Inline.LowHalf[startAddr.head],        sector: Inline.LowHalf[startAddr.sector]]];    END;  GetCount: INTERNAL PROCEDURE RETURNS [count: CARDINAL] =    BEGIN OPEN toolData;    first: CARDINAL ¬ startAddr.sector +      GumoutDefs.nSectors*(startAddr.head + GumoutDefs.nHeads*startAddr.cylinder);    last: CARDINAL ¬ endAddr.sector +      GumoutDefs.nSectors*(endAddr.head + GumoutDefs.nHeads*endAddr.cylinder);    count ¬ IF first <= last THEN last - first + 1 ELSE 0;    END;  IncAddr: INTERNAL PROCEDURE [da: FloppyChannel.DiskAddress, inc: CARDINAL]    RETURNS [FloppyChannel.DiskAddress] =    BEGIN OPEN da;    q: CARDINAL;    [q, sector] ¬ Inline.DIVMOD[sector - 1 + inc, GumoutDefs.nSectors];    sector ¬ sector + 1;  -- sectors start with 1    IF q > 0 THEN      BEGIN      [q, head] ¬ Inline.DIVMOD[head + q, GumoutDefs.nHeads];      cylinder ¬ cylinder + q;      END;    RETURN[da];    END;  PostStatus: INTERNAL PROCEDURE [s: FloppyChannel.Status] =    -- Writes status information to the file window.    BEGIN    IF s ~= goodCompletion THEN Put.LongString[toolData.fileSW, "Error: "L];    Put.Line[toolData.fileSW, SELECT s FROM      goodCompletion => "goodCompletion"L,      diskChange => "diskChange"L,      notReady => "notReady"L,      cylinderError => "cylinderError"L,      deletedData => "deletedData"L,      recordNotFound => "recordNotFound"L,      headerError => "headerError"L,      dataError => "dataError"L,      dataLost => "dataLost"L,      writeFault => "writeFault"L,      otherError => "unexpected error"L,      ENDCASE => "Gumout bug"L];    END;  PrintBuffer: INTERNAL PROCEDURE [    addr: FloppyChannel.DiskAddress, count: CARDINAL] =    -- Writes contents of zero or more sectors in the data    --  buffer to the file window.    BEGIN    cols: CARDINAL = 8;    fHex: Format.NumberFormat = [      base: 16, zerofill: TRUE, unsigned: TRUE, columns: 1];    fOctal: Format.NumberFormat = [      base: 8, zerofill: TRUE, unsigned: TRUE, columns: 6];    fOctalByte: Format.NumberFormat = [      base: 8, zerofill: TRUE, unsigned: TRUE, columns: 3];    h: Window.Handle ¬ toolData.fileSW;    i: CARDINAL      ¬ 0;    n: CARDINAL      ¬ toolData.context.sectorLength;    p: LONG POINTER  ¬ dataSpace;    Swap: PROC [u: UNSPECIFIED] RETURNS [UNSPECIFIED] = INLINE {      RETURN[Inline.HighByte[u] + u*256]};    PutChar: PROC [c: CHARACTER] = {      Put.Char[h, IF c IN ['  .. '~] THEN '  ELSE '­];      Put.Char[h, IF c IN ['  .. '~] THEN c ELSE (c-1C)+'A]};    THROUGH [0..count) DO      PrintDiskAddress[addr];      FOR i IN [0..n) DO        Put.Blanks[h, 2];        SELECT toolData.printHow FROM          octal =>            Put.Number[h, (p + i)­, fOctal];          octalByte =>            BEGIN            Put.Number[h, Inline.HighByte[(p + i)­], fOctalByte];            Put.Blanks[h, 1];            Put.Number[h, Inline.LowByte[ (p + i)­], fOctalByte];            END;          hex =>            BEGIN            Put.Number[h, Inline.BITSHIFT[Inline.HighByte[(p + i)­],  -4], fHex];            Put.Number[h, Inline.BITAND[  Inline.HighByte[(p + i)­], 17B], fHex];            Put.Blanks[h, 2];            Put.Number[h, Inline.BITSHIFT[Inline.LowByte[(p + i)­],   -4],  fHex];            Put.Number[h, Inline.BITAND[  Inline.LowByte[(p + i)­],  17B],  fHex];            END;          octalSwapped =>             Put.Number[h, Swap[(p + i)­], fOctal];          ascii =>            BEGIN            PutChar[Inline.HighByte[(p + i)­]+0C];            PutChar[Inline.LowByte [(p + i)­]+0C];            END;           asciiSwapped =>            BEGIN            PutChar[Inline.LowByte [(p + i)­]+0C];            PutChar[Inline.HighByte[(p + i)­]+0C];            END;           ENDCASE => ERROR;        IF i MOD cols = (cols - 1) THEN Put.CR[h];        ENDLOOP;      Put.CR[h];      addr ¬ IncAddr[addr, 1];      p ¬ p + n;      ENDLOOP;    END;  PrintDiskAddress: INTERNAL PROCEDURE [da: FloppyChannel.DiskAddress] =    -- Writes formatted disk address to the file window.    BEGIN    h: Window.Handle ¬ toolData.fileSW;    Put.Text[h, "cylinder: "L];    Put.Decimal[h, da.cylinder];    Put.Text[h, ",  head: "L];    Put.Decimal[h, da.head];    Put.Text[h, ",  sector: "L];    Put.Decimal[h, da.sector];    Put.CR[h];    END;  Random: INTERNAL PROCEDURE [oldSeed: CARDINAL]    RETURNS [random, newSeed: CARDINAL] =    -- This routine adapted from Flex.    -- This is a pseudo-random number routine taking a given seed    --   times itself+311 (chosen as a prime number of more than    --   8 bits) to form longC[length 32 bits] and using the    --   middle 16 bits for the new seed.  The newSeed is of    --   the form longC[12:4]|longC[16:4].    BEGIN    longC: LONG CARDINAL ¬ Inline.LongMult[oldSeed, oldSeed + 311];    newSeed ¬ Inline.BITOR[      Inline.BITSHIFT[Inline.HighHalf[longC], 8], Inline.HighByte[      Inline.LowHalf[longC]]];    [, random] ¬ Inline.DIVMOD[newSeed, 177777B];    END;  END....LOGFebruary 6, 1981  6:29 PM	CAJ 	Add log.  New FormatDisk for rewritten FormatSA800 interface; assert 	notPilotVolume only for transfer functions; miscellaneous fixes and	improvements.March 7, 1981  11:46 AM		CAJ 	Add ResetContext, Nop; print stop address for reset or error; implement 	print options octal byte and hex; add clear msgSW.3-Sep-81 12:20:43	WDK    	LONGify, convert to new FloppyChannel, Tajo 8.30-Nov-81 17:13:53	CAJ 	Convert to Trinity FloppyChannel; remove	Pilot/nonPilot disk distinction; fix incorrect sector length formatting        track 0, bogus status when transfer count=0.22-Jan-82 15:38:33	CAJ 	Correct double density formatting and erroneous        "no transfer"; make AdoptNewDisk and Xfer catch invalidHandle; add private        errors.21-Apr-83 13:37:29	CAJ 	Convert to Klamath.28-Jul-83 13:46:14	JXG     Fix catch phrase in AdoptNewDisk24-Jan-85 15:20:52	CAJ 	Convert to 12.0 FloppyChannel.
-- Copyright (C) 1987, 1988  by Xerox Corporation. All rights reserved. -- FloppyTapeEditContextSW.mesa  last edited: 29-Feb-88 10:50:23  by: CAJ-- This module implements the subwindow dealing with FloppyTape context and related hardware or tape environment parameters and commands.-- Note: Due to FloppyTapeEdit's derivation from FloppyEdit, sometimes the tape is called a disk.  It's just name inheritance.  This tool does not do anything to any kind of disk.  DIRECTORY  Device USING [Type],  DeviceTypesExtras4 USING [anyFloppyTape, FloppyTape],  FloppyChannel USING [    Attributes, Context, Density, DiskAddress, Drive, Error, Format, GetContext,    GetDeviceAttributes, GetHandle, Handle, HeadCount, Nop, nullHandle,    SectorCount, SetContext, Status],  FloppyEditInternal USING [data, GetDrive, heap, Msg],  FloppyFormat USING [nullSector, Sector],  FloppyTapeFormat USING [floppyTapeContext],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType, line0,    line1, line2, line3, ProcType],  Inline USING [DIVMOD],  MsgSW USING [Clear],  ProcessOperations USING [],  RuntimeInternal USING [Bug],  System USING [GetGreenwichMeanTime, GreenwichMeanTime],  Window USING [Handle];FloppyTapeEditContextSW: PROGRAM  IMPORTS    FloppyChannel, FloppyEditInternal, FormSW, Inline, MsgSW, RuntimeInternal,    System  EXPORTS FloppyEditInternal =  BEGIN  --//////////////////  -- Local TYPEs and variables  ContextData: TYPE = LONG POINTER TO ContextDataObject;  ContextDataObject: TYPE = MACHINE DEPENDENT RECORD [    -- The following are subwindow items (all on word boundaries)    writeProtect(0): BOOLEAN ¬ FALSE,    format(1): FloppyChannel.Format ¬ IBM,  -- ringer    density(2): FloppyChannel.Density ¬ double,    sectorSize(3): FloppyChannel.SectorCount ¬ 0,    diskChange(4): BOOLEAN ¬ TRUE,    -- The following are not subwindow items    deviceType(5): Device.Type ¬ DeviceTypesExtras4.anyFloppyTape,    numberOfTracks(6): CARDINAL ¬ 0,    numberOfHeads(7): FloppyChannel.HeadCount ¬ 0,    sectorsPerTrack(8): FloppyChannel.SectorCount ¬ 0,    contextInEffect(9): FloppyChannel.Context ¬ [FALSE, IBM, double, 0]];  FormItems: TYPE = {    writeProtect, format, diskChange, density, sectorSize, newTape,    setDefaultContext, setSpecifiedContext, getContext};  contextSettings: ARRAY FloppyChannel.Density OF FloppyChannel.Context = [    --single--[protect: FALSE, format: IBM, density: single, sectorLength: 256],    --double--FloppyTapeFormat.floppyTapeContext];  contextData: ContextData ¬ NIL;  tracksPerCylinder: CARDINAL = 1;  --//////////////////  -- Errors  BugType: TYPE = {contextMismatch, noHeap};  Bug: PROCEDURE [bug: BugType] = {RuntimeInternal.Bug[bug]};  --//////////////////  -- Procedures  ContextMatchesContextInEffect: PUBLIC PROCEDURE RETURNS [BOOLEAN] = {    RETURN[MakeFloppyChannelContext[] = contextData.contextInEffect]};  -- Convert track/stream/sector type address to tape-sequential sector number  DiskAddressToSectorNumber: PUBLIC PROCEDURE [    diskAddress: FloppyChannel.DiskAddress]    RETURNS [sector: FloppyFormat.Sector] =    BEGIN    sector ¬      IF FloppyEditInternal.data.handle = FloppyChannel.nullHandle        THEN FloppyFormat.nullSector        ELSE diskAddress.sector + contextData.sectorsPerTrack *         (diskAddress.head * tracksPerCylinder + diskAddress.cylinder);    END;  -- DiskAddressToSectorNumber  EstablishNewDisk: PROCEDURE RETURNS [ok: BOOLEAN] =    -- This procedure is called at tool activation time and on NewTape to    -- establish the context and attributes for the current tape.    -- There may be no tape present, or the drive may have changed since    -- the last valid tape.  The return value indicates whether it was able    -- to get drive attributes and set context.    BEGIN    attrib: FloppyChannel.Attributes;    c: FloppyChannel.Context;    h: FloppyChannel.Handle;    oneMinute: System.GreenwichMeanTime = [60];    status: FloppyChannel.Status;    timeout: System.GreenwichMeanTime ¬      [System.GetGreenwichMeanTime[] + oneMinute];       -- retry period for diskChange/invalidHandle to resolve    WHILE System.GetGreenwichMeanTime[] < timeout DO      h ¬ GetHandle[        ! FloppyChannel.Error => IF type = invalidDrive THEN GOTO notOK];      status ¬ FloppyChannel.Nop[h        ! FloppyChannel.Error => IF type = invalidHandle THEN LOOP];      SELECT status FROM        notReady => GOTO notOK;	diskChange => LOOP;	ENDCASE => EXIT;      REPEAT      FINISHED => GOTO notOK;      ENDLOOP;    -- Got a handle    ok ¬ TRUE;    FloppyEditInternal.data.handle ¬ h;    -- Attributes are constant per drive, but the drive may have changed.    attrib ¬ FloppyChannel.GetDeviceAttributes[h];    contextData.diskChange ¬ attrib.diskChange;    -- Tape doesn't care about attrib.twoSided, right?    contextData.deviceType ¬ attrib.deviceType;    contextData.numberOfTracks ¬ attrib.numberOfCylinders;    contextData.numberOfHeads ¬ attrib.numberOfHeads;    contextData.sectorsPerTrack ¬ attrib.maxSectorsPerTrack;    -- Set initial context to data context. We have to do some guessing to get    -- writeProtect and density right, e.g., corresponding to tape. Context    -- cannot be set successfully with the wrong values. After initialization    -- we just believe the values in contextData, assuming they are the ones we    -- set or that the user reset them on purpose.    FOR i: FloppyChannel.Density DECREASING IN FloppyChannel.Density DO      c ¬  contextSettings[i];      IF FloppyChannel.SetContext[FloppyEditInternal.data.handle, c]        THEN EXIT;      c.protect ¬ ~c.protect;      IF FloppyChannel.SetContext[FloppyEditInternal.data.handle, c]        THEN EXIT;      REPEAT      FINISHED => GOTO notOK ;      ENDLOOP;    contextData.writeProtect ¬ c.protect;    contextData.format ¬ c.format;    contextData.density ¬ c.density;    contextData.sectorSize ¬ c.sectorLength;    contextData.contextInEffect ¬ c;    EXITS notOK => ok ¬ FALSE;    END;  -- EstablishNewDisk  GetContext: FormSW.ProcType =    BEGIN    c: FloppyChannel.Context;    MsgSW.Clear[FloppyEditInternal.data.msgSW];    IF contextData.format = Troy THEN GOTO noContext;    c ¬ FloppyChannel.GetContext[      FloppyEditInternal.data.handle !      FloppyChannel.Error =>        IF type = invalidHandle THEN GOTO invalidHandle ELSE REJECT];    ShowContext[c, sw];    IF ~ContextMatchesContextInEffect[] THEN Bug[contextMismatch];    EXITS      invalidHandle =>        BEGIN        FloppyEditInternal.Msg["Invalid handle"L, TRUE];        InvalidateHandle[];        END;      noContext => FloppyEditInternal.Msg["No context has been set."L, TRUE];    END;  -- GetContext  GetHandle: PROCEDURE RETURNS [FloppyChannel.Handle] = {    RETURN[FloppyChannel.GetHandle[FloppyEditInternal.GetDrive[]]]};  InitContext: PUBLIC PROCEDURE =    -- This procedure is called at tool activation time.    -- If it is unable to get drive attributes and set context, it sets    -- the tool state to indicate no valid tape is present.    -- If no context is set at initialization time (e.g., because there is no    -- tape ready), the user must explicitly set the context later.    BEGIN    IF FloppyEditInternal.data = NIL THEN Bug[noHeap];    FloppyEditInternal.data.contextData ¬ contextData ¬      FloppyEditInternal.heap.NEW[ContextDataObject ¬ []];    -- Stash contextData pointer in tool data so it can be freed on deactivate.    IF ~EstablishNewDisk[          ! FloppyChannel.Error =>	    IF type = invalidHandle THEN GOTO noAccess ELSE REJECT]      THEN GOTO noAccess;    -- If the device type is outside the floppyTape range but the initialization    -- completed normally, it is probably a floppy disk.  It's not going to let    -- you have it as a default at startup time, but if you bug NewTape it will    -- post a warning and allow access.  It can't post a warning message here    -- because the tool isn't up yet.    IF LOOPHOLE[contextData.deviceType, CARDINAL]      ~IN DeviceTypesExtras4.FloppyTape THEN GOTO noAccess;    EXITS noAccess => InvalidateHandleNoDisplay[]    END;  -- InitContext  InvalidateHandle: PUBLIC PROCEDURE =    BEGIN    InvalidateHandleNoDisplay[];    FormSW.DisplayItem[      FloppyEditInternal.data.contextSW, FormItems.diskChange.ORD];    END;  -- InvalidateHandle  InvalidateHandleNoDisplay: PROCEDURE = INLINE    BEGIN    -- For use when subwindow isn't there    FloppyEditInternal.data.handle ¬ FloppyChannel.nullHandle;    contextData.diskChange ¬ TRUE;    END;  MakeContextSW: PUBLIC FormSW.ClientItemsProcType =    BEGIN OPEN FSW: FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    format: ARRAY [0..1) OF FSW.Enumerated ¬ [      ["IBM"L, FloppyChannel.Format[IBM]]];    density: ARRAY [0..2) OF FSW.Enumerated ¬ [      ["single"L, FloppyChannel.Density[single]], [       "double"L, FloppyChannel.Density[double]]];    sectorSize: ARRAY [0..1) OF FSW.Enumerated ¬ [      ["256"L, 256]];    items ¬ FSW.AllocateItemDescriptor[nItems];    items[FormItems.writeProtect.ORD] _ FSW.BooleanItem[      tag: "WriteProtect"L, place: [3, FSW.line0], readOnly: FALSE,      switch: @contextData.writeProtect];    items[FormItems.format.ORD] _ FSW.EnumeratedItem[      tag: "Format"L, place: [116, FSW.line0], readOnly: FALSE, feedback: one,      proc: SetFormat, choices: DESCRIPTOR[format], value: @contextData.format];    items[FormItems.diskChange.ORD] _ FSW.BooleanItem[      tag: "DiskChange"L, place: [303, FSW.line0], readOnly: TRUE,      switch: @contextData.diskChange];    items[FormItems.density.ORD] _ FSW.EnumeratedItem[      tag: "Density"L, place: [3, FSW.line1], readOnly: FALSE, feedback: all,      choices: DESCRIPTOR[density], value: @contextData.density];    items[FormItems.sectorSize.ORD] _ FSW.EnumeratedItem[      tag: "Sector size (words)"L, place: [240, FSW.line1], readOnly: FALSE,      feedback: all, choices: DESCRIPTOR[sectorSize],      value: @contextData.sectorSize];    items[FormItems.newTape.ORD] _ FSW.CommandItem[      tag: "NewTape"L, place: [3, FSW.line2], proc: NewTapeCommand];    items[FormItems.setDefaultContext.ORD] _ FSW.CommandItem[      tag: "SetDefaultContext"L, place: [3, FSW.line3], proc: SetDefaultContext];    items[FormItems.setSpecifiedContext.ORD] _ FSW.CommandItem[      tag: "SetSpecifiedContext"L, place: [145, FSW.line3],      proc: SetSpecifiedContext];    items[FormItems.getContext.ORD] _ FSW.CommandItem[      tag: "GetContext"L, place: [300, FSW.line3], proc: GetContext];    RETURN[items: items, freeDesc: TRUE];    END;  MakeFloppyChannelContext: PROCEDURE RETURNS [c: FloppyChannel.Context] = {    RETURN[      [protect: contextData.writeProtect, format: contextData.format,        density: contextData.density, sectorLength: contextData.sectorSize]]};  NewTapeCommand: FormSW.ProcType =    BEGIN    MsgSW.Clear[FloppyEditInternal.data.msgSW];    IF (contextData.diskChange ¬ ~EstablishNewDisk[].ok) THEN      BEGIN      FloppyEditInternal.Msg["Can't access device."L, TRUE];      InvalidateHandle[];      END;    IF LOOPHOLE[contextData.deviceType, CARDINAL]      ~IN DeviceTypesExtras4.FloppyTape THEN FloppyEditInternal.Msg[        "Warning: device type not in floppy tape range."L, FALSE];    FormSW.DisplayItem[      FloppyEditInternal.data.contextSW, FormItems.diskChange.ORD];    END;  -- Convert tape-sequential sector number to track/stream/sector type address  SectorNumberToDiskAddress: PUBLIC PROCEDURE [sector: FloppyFormat.Sector]    RETURNS [diskAddress: FloppyChannel.DiskAddress] =    BEGIN    IF FloppyEditInternal.data.handle = FloppyChannel.nullHandle      THEN diskAddress ¬ [cylinder: 0, head: 0, sector: 0] -- not a real address      ELSE BEGIN      q: CARDINAL;      [quotient: q, remainder: diskAddress.sector] ¬        Inline.DIVMOD[sector - 1, contextData.sectorsPerTrack];      diskAddress.sector ¬ diskAddress.sector + 1; -- sectors begin at 1      [quotient: diskAddress.cylinder, remainder: diskAddress.head] ¬        Inline.DIVMOD[q, tracksPerCylinder];      END;    END;  -- SectorNumberToDiskAddress  SectorWords: PUBLIC PROCEDURE RETURNS [FloppyChannel.SectorCount] = {    RETURN[contextData.sectorSize]};  SetContext: PROCEDURE [c: FloppyChannel.Context] RETURNS [ok: BOOLEAN] =    BEGIN    -- Do common guts of context change.    MsgSW.Clear[FloppyEditInternal.data.msgSW];    ok ¬ FloppyChannel.SetContext[      handle: FloppyEditInternal.data.handle, context: c      ! FloppyChannel.Error =>        IF type = invalidHandle THEN GOTO invalidHandle ELSE REJECT];    IF ok THEN      BEGIN      contextData.sectorsPerTrack ¬ FloppyChannel.GetDeviceAttributes[	FloppyEditInternal.data.handle].maxSectorsPerTrack;      contextData.contextInEffect ¬ c;      END    ELSE      BEGIN      status: FloppyChannel.Status ¬ FloppyChannel.Nop[        FloppyEditInternal.data.handle];      FloppyEditInternal.Msg[        string: SELECT status FROM          notReady => "Not ready."L,          writeFault => "Tape is write protected."L          ENDCASE => "Can't set that context."L, blink: TRUE];      END;    EXITS      invalidHandle => {        FloppyEditInternal.Msg["Invalid handle"L, TRUE]; InvalidateHandle[]};    END;  SetDefaultContext: FormSW.ProcType =    BEGIN    -- Set the default context.    IF SetContext[contextSettings[contextData.density]] THEN      ShowContext[contextSettings[contextData.density], sw];    END;  -- SetDefaultContext  SetSpecifiedContext: FormSW.ProcType =    BEGIN    -- Set the context shown by the individual context items in the subwindow.    c: FloppyChannel.Context ¬ MakeFloppyChannelContext[];    IF SetContext[c] THEN ShowContext[c, sw];    END;  -- SetSpecifiedContext  SetFormat: FormSW.EnumeratedNotifyProcType =    BEGIN    IF contextData.format = Troy THEN      BEGIN      FloppyEditInternal.Msg["Troy format is not supported."L, FALSE];      contextData.format ¬ IBM;      FormSW.DisplayItem[sw, FormItems.format.ORD];      END;    END;  -- SetFormat  ShowContext: PROCEDURE [c: FloppyChannel.Context, sw: Window.Handle] =    BEGIN    -- Transfer given context to indiv. display items and redisplay.    contextData.writeProtect ¬ c.protect;    contextData.format ¬ c.format;    contextData.density ¬ c.density;    contextData.sectorSize ¬ c.sectorLength;    FormSW.DisplayItem[sw, FormItems.format.ORD];    FormSW.DisplayItem[sw, FormItems.writeProtect.ORD];    FormSW.DisplayItem[sw, FormItems.density.ORD];    FormSW.DisplayItem[sw, FormItems.sectorSize.ORD];    END;  -- Ensure address is valid for tape which is currently active  ValidateDiskAddress: PUBLIC PROCEDURE [addr: FloppyChannel.DiskAddress]    RETURNS [BOOLEAN] = {    RETURN[      addr.cylinder IN [0..contextData.numberOfTracks)        AND addr.head IN [0..contextData.numberOfHeads)        AND addr.sector IN [1..contextData.sectorsPerTrack]]};  -- Ensure sector specified is valid for currently active tape  ValidateSectorNumber: PUBLIC PROCEDURE [sector: FloppyFormat.Sector]    RETURNS [BOOLEAN] = {    RETURN[      (sector ~= FloppyFormat.nullSector)        AND          (sector IN            [0..contextData.numberOfTracks * contextData.numberOfHeads *                  contextData.sectorsPerTrack])]};  END...LOG12-Jan-87 19:20:34   CAJ	Created file from FloppyEditContextSW of 24-Apr-86  9:16:25.22-Apr-87 13:25:23   CAJ	Cleanup for "real" vs. prototype floppy tape; remove Troy format, designated #streams.29-Feb-88 10:50:18   CAJ	Reinitialize context for each NewTape in case drive changed.  Return null values to address conversions if handle is invalid since context is also invalid then.  Special case non-floppy device type.
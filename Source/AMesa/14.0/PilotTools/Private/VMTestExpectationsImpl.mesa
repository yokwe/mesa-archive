-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- VMTestExpectationsImpl.mesa      25-Mar-83 14:32:28 by CAJ -- Virtual memory test program.-- Each operation in VMTestExpectations sets up the expected results for a-- particular VM operation.  FunSpec information about errors and outcomes-- for various parameters, and database state information are used to make-- the predictions.  Expectations for a given operation involve one or more-- of the following:--   + Each operation returns a SigsetDefs.Sigset, which is an array of--     possible signals, faults, or other outcomes (e.g., unrecoverable error,--     normal return).  The Sigset may contain more than one entry where--     circumstances which we cannot predict may affect the outcome (such as--     an I/O error, or the order of evaluation in the Pilot implementation).--   + Most return the actual interval of pages, implied by the page or interval--     parameter, over which the operation will actually occur.--   + Predicted results are returned where the VM operation returns results.--   + The database is updated for those operations where performance of the--     corresponding Pilot operation may cause the database to be referenced,--     (e.g., for Map, pages must be marked mapped for use by the backing store--     routine in setting up initial contents).-- In general, an error state from an operation is not reported here.  It is-- reflected in the predicted outcome, then reported and handled further down-- the line in the modelling.  Any error which stops here is something which is-- legal to Pilot in general but illegal in the constraints of the test program.-- All operations in this interface assume that the initial interval has been-- validated and locked.DIRECTORY  BackingStore USING [Run],  Environment USING [PageNumber],  SigsetDefs USING [AddDefiniteError, AddNonRecoverable, AddPotentialError,    InitToNone, IsIn, Sigset],  VM USING [BackingStoreRuns, Interval, nullInterval],  VMTestDatabase USING [Attributes, CorrectAcquiredInterval,    FindEnclosingSwapUnits, GetMapUnit, GetPageAttributes, MapDatabasePages,    MapUnit, TotalBS, VerifyMapState],  VMTestExpectations;VMTestExpectationsImpl: PROGRAM  IMPORTS SigsetDefs, VMTestDatabase  EXPORTS VMTestExpectations =  BEGIN  ------------  -- PUBLIC procedures - VM Operations:  Activate: PUBLIC PROCEDURE [interval: VM.Interval, expect: SigsetDefs.Sigset] =    BEGIN    page: Environment.PageNumber;    SigsetDefs.InitToNone[expect];    FOR page IN [interval.page..interval.page + interval.count) DO      attr: VMTestDatabase.Attributes ¬ VMTestDatabase.GetPageAttributes[page];      IF attr.mapped AND attr.swappable AND attr.alive THEN        {SigsetDefs.AddPotentialError[expect, spaceIOError]; EXIT};      ENDLOOP;    END;  CopyIn: PUBLIC PROCEDURE [    interval: VM.Interval, run: BackingStore.Run, expect: SigsetDefs.Sigset] =    BEGIN    page: Environment.PageNumber;    -- implied interval = given interval, so CorrectAcquiredInterval unnecessary    SigsetDefs.InitToNone[expect];    SigsetDefs.AddPotentialError[expect, spaceIOError];    IF run.count < interval.count THEN      SigsetDefs.AddDefiniteError[expect, spaceInvalidParameters];    IF ~AllMapped[interval] THEN      SigsetDefs.AddDefiniteError[expect, spaceNotMapped];    FOR page IN [interval.page..interval.page + interval.count) DO      IF VMTestDatabase.GetPageAttributes[page].readonly THEN        {SigsetDefs.AddDefiniteError[expect, spaceReadOnly]; EXIT};      ENDLOOP;    END;  CopyOut: PUBLIC PROCEDURE [    interval: VM.Interval, run: BackingStore.Run, expect: SigsetDefs.Sigset] =    BEGIN    -- implied interval = given interval, so CorrectAcquiredInterval unnecessary    SigsetDefs.InitToNone[expect];    SigsetDefs.AddPotentialError[expect, spaceIOError];    IF run.count < interval.count THEN      SigsetDefs.AddDefiniteError[expect, spaceInvalidParameters];    IF ~AllMapped[interval] THEN      SigsetDefs.AddDefiniteError[expect, spaceNotMapped];    END;  Deactivate: PUBLIC PROCEDURE [    interval: VM.Interval, expect: SigsetDefs.Sigset] =    BEGIN    page: Environment.PageNumber;    SigsetDefs.InitToNone[expect];    FOR page IN [interval.page..interval.page + interval.count) DO      attr: VMTestDatabase.Attributes ¬ VMTestDatabase.GetPageAttributes[page];      IF attr.mapped AND attr.swappable AND ~attr.readonly AND attr.alive          AND ~attr.clean        THEN {SigsetDefs.AddPotentialError[expect, spaceIOError]; EXIT};      ENDLOOP;    END;  ForceOut: PUBLIC PROCEDURE [interval: VM.Interval, expect: SigsetDefs.Sigset] =    BEGIN    page: Environment.PageNumber;    SigsetDefs.InitToNone[expect];    FOR page IN [interval.page..interval.page + interval.count) DO      attr: VMTestDatabase.Attributes ¬ VMTestDatabase.GetPageAttributes[page];      IF attr.mapped AND ~attr.readonly AND attr.alive AND ~attr.clean          AND VMTestDatabase.GetMapUnit[page].backed        THEN {SigsetDefs.AddPotentialError[expect, spaceIOError]; EXIT};      ENDLOOP;    END;  GetMapUnitAttributes: PUBLIC PROCEDURE [    page: Environment.PageNumber, backingStoreRunsResult: VM.BackingStoreRuns,    expect: SigsetDefs.Sigset] =    BEGIN    SigsetDefs.InitToNone[expect];    END;  GetSwapUnitAttributes: PUBLIC PROCEDURE [    page: Environment.PageNumber, expect: SigsetDefs.Sigset] =    BEGIN    SigsetDefs.InitToNone[expect];    END;  Kill: PUBLIC PROCEDURE [interval: VM.Interval, expect: SigsetDefs.Sigset] =    BEGIN    SigsetDefs.InitToNone[expect];    END;  MakeReadOnly: PUBLIC PROCEDURE [    interval: VM.Interval, expect: SigsetDefs.Sigset]    RETURNS [realInterval: VM.Interval] =    BEGIN    -- Note that VM.MakeReadOnly, unlike Space.MakeReadOnly, does not do an    -- implied ForceOut of a resident swap unit.    realInterval ¬ VMTestDatabase.FindEnclosingSwapUnits[interval];    VMTestDatabase.CorrectAcquiredInterval[interval, realInterval];    SigsetDefs.InitToNone[expect];    END;  MakeResident: PUBLIC PROCEDURE [    interval: VM.Interval, expect: SigsetDefs.Sigset]    RETURNS [realInterval: VM.Interval] =    BEGIN    page: Environment.PageNumber;    realInterval ¬ VMTestDatabase.FindEnclosingSwapUnits[interval];    VMTestDatabase.CorrectAcquiredInterval[interval, realInterval];    SigsetDefs.InitToNone[expect];    FOR page IN [interval.page..interval.page + interval.count) DO      attr: VMTestDatabase.Attributes ¬ VMTestDatabase.GetPageAttributes[page];      IF attr.mapped AND attr.alive AND ~attr.clean AND attr.readonly THEN        {SigsetDefs.AddPotentialError[expect, spaceIOError]; EXIT};      ENDLOOP;    END;  MakeSwappable: PUBLIC PROCEDURE [    interval: VM.Interval, expect: SigsetDefs.Sigset]    RETURNS [realInterval: VM.Interval] =    BEGIN    lastPage: Environment.PageNumber;    SkipToNextMapUnit: PROCEDURE [page: Environment.PageNumber]      RETURNS [next: Environment.PageNumber] =      BEGIN      next ¬ page + VMTestDatabase.GetMapUnit[page].interval.count;      WHILE VMTestDatabase.GetMapUnit[page] = NIL DO	IF (next ¬ next + 1) > lastPage THEN EXIT ENDLOOP;      END;    realInterval ¬ VMTestDatabase.FindEnclosingSwapUnits[interval];    VMTestDatabase.CorrectAcquiredInterval[interval, realInterval];    SigsetDefs.InitToNone[expect];    IF realInterval ~= VM.nullInterval THEN      BEGIN      page: Environment.PageNumber;      lastPage ¬ realInterval.page + realInterval.count - 1;      FOR page ¬ realInterval.page, SkipToNextMapUnit[page]          UNTIL page > lastPage DO        -- all map units included in interval must have non-NIL procs        IF ~VMTestDatabase.GetMapUnit[page].backed THEN          {SigsetDefs.AddDefiniteError[expect, spaceNoWindow]; EXIT}        ENDLOOP;      END;    END;  MakeWritable: PUBLIC PROCEDURE [    interval: VM.Interval, expect: SigsetDefs.Sigset]    RETURNS [realInterval: VM.Interval] =    BEGIN    realInterval ¬ VMTestDatabase.FindEnclosingSwapUnits[interval];    VMTestDatabase.CorrectAcquiredInterval[interval, realInterval];    SigsetDefs.InitToNone[expect];    END;  Map: PUBLIC PROCEDURE [    mapUnit: VMTestDatabase.MapUnit, expect: SigsetDefs.Sigset]    RETURNS [mappedInDatabase: BOOLEAN] =    BEGIN OPEN mapUnit;    SigsetDefs.InitToNone[expect];    IF interval.count = 0 THEN  -- null interval      SigsetDefs.AddDefiniteError[expect, spaceInvalidParameters]    ELSE      BEGIN  -- valid interval      IF AnyMapped[interval] THEN        SigsetDefs.AddNonRecoverable[expect];  -- debugger      IF access = readOnly AND swappability = resident AND NOT backed THEN        SigsetDefs.AddDefiniteError[expect, spaceInvalidParameters];      IF backed THEN        BEGIN	IF swappability = resident AND life = alive THEN          SigsetDefs.AddPotentialError[expect, spaceIOError];	IF backingStoreRuns = NIL THEN          SigsetDefs.AddNonRecoverable[expect];  -- debugger        IF VMTestDatabase.TotalBS[backingStoreRuns] < interval.count THEN          SigsetDefs.AddNonRecoverable[expect];  -- debugger	END      ELSE -- not backed        BEGIN	IF swappability = swappable THEN          SigsetDefs.AddDefiniteError[expect, spaceNoWindow];	END;      -- not enough information about why from nonrecoverable - need another msg?      -- predict for initial contents besides resident?      --   swappability + life + backed + boot switch + clean/dirty      END;  -- valid interval    IF SigsetDefs.IsIn[expect, none]      THEN {VMTestDatabase.MapDatabasePages[mapUnit]; mappedInDatabase ¬ TRUE}      ELSE mappedInDatabase ¬ FALSE;    END;  Relocate: PUBLIC PROCEDURE [    from: Environment.PageNumber, to: Environment.PageNumber,    expect: SigsetDefs.Sigset] RETURNS [realInterval: VM.Interval] =    BEGIN    realInterval ¬ VMTestDatabase.GetMapUnit[from].interval;    VMTestDatabase.CorrectAcquiredInterval[[from, 1], realInterval];    -- Acquire to interval?    SigsetDefs.InitToNone[expect];    -- from ~= start of map unit => debugger    -- to + map unit size already mapped => debugger    -- watch overlapping    -- from must be 1st page of map unit    END;  SupplyBackingStore: PUBLIC PROCEDURE [    page: Environment.PageNumber, useProc: BOOLEAN,    backingStoreRuns: VM.BackingStoreRuns, expect: SigsetDefs.Sigset]    RETURNS [realInterval: VM.Interval] =    BEGIN    -- page can be any page in a map unit    -- look more at the spec on this    realInterval ¬ VMTestDatabase.GetMapUnit[page].interval;    VMTestDatabase.CorrectAcquiredInterval[[page, 1], realInterval];    -- CheckInterval[(swap unit containing page), "SupplyBackingStore"L];    SigsetDefs.InitToNone[expect];    -- page not mapped => debugger    -- any swap units nonresident => debugger    -- sum of backingStore elements < interval.count => debugger    -- else expect (¬) none    END;  Unmap: PUBLIC PROCEDURE [    interval: VM.Interval, expect: SigsetDefs.Sigset]    RETURNS [realInterval: VM.Interval] =    BEGIN    mapUnit: VMTestDatabase.MapUnit ¬ VMTestDatabase.GetMapUnit[interval.page];    realInterval ¬ IF mapUnit = NIL THEN VM.nullInterval ELSE mapUnit.interval;    VMTestDatabase.CorrectAcquiredInterval[interval, realInterval];    IF mapUnit = NIL THEN      SigsetDefs.AddDefiniteError[expect, spaceNotMapped]    ELSE      BEGIN      SigsetDefs.InitToNone[expect];      IF mapUnit.backed THEN SigsetDefs.AddPotentialError[expect, spaceIOError];      IF ~AllMapped[realInterval] THEN        SigsetDefs.AddDefiniteError[expect, spaceNotMapped];      END;    END;  ------------  -- PRIVATE procedures:  -- TRUE if all pages in interval are mapped  AllMapped: PROCEDURE [interval: VM.Interval] RETURNS [BOOLEAN] =    INLINE {RETURN[VMTestDatabase.VerifyMapState[interval, mapped]]};  -- TRUE if any page in interval is mapped  AnyMapped: PROCEDURE [interval: VM.Interval] RETURNS [BOOLEAN] =    INLINE {RETURN[~VMTestDatabase.VerifyMapState[interval, unmapped]]};  ------------  -- Main line code  -- None.  END.LOG17-Aug-82 16:37:26   CAJ    Created file.
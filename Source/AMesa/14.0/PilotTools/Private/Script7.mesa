-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Script7.mesa       26-Apr-83 17:12:02 by CAJ -- Virtual memory test program, Klamath Pilot.-- Script7 tests CopyOut.DIRECTORY  Environment USING [PageCount],  ScriptOps USING [RegisterScript],  VM USING [Interval],  VMTestOperations --USING [all the operations]--,  VMTestScript USING [GetHeap, GiveBackHeap, MakeBackingData,    MakeIrregularSwapData, MakeUniformSwapData, MakeUnitarySwapData, Ticker];Script7: PROGRAM  IMPORTS ScriptOps, VMTestOperations, VMTestScript =  BEGIN  ------------  -- PUBLIC procedures:  -- RunTests is a script of tests using procedures from VMTestOperations (for  -- VM operations) and VMTestScript (for test utilities).  RunTests: PROCEDURE =    BEGIN OPEN VMTestScript;        heap: UNCOUNTED ZONE ¬ GetHeap[];    CopyOutUnitary[heap];    CopyOutUniformA[heap];    CopyOutUniformB[heap];    CopyOutUniformC[heap];    CopyOutIrregularA[heap];    CopyOutIrregularB[heap];    CopyOutIrregularC[heap];    -- copy same thing twice    -- copy overlap 2nd    -- in + out    -- out + in    -- resident    -- resident + swap mixed    -- into dirty    -- run > interval    heap ¬ GiveBackHeap[heap];    END;  -- CopyOut tests for irregular swap units in single map units, part 1  CopyOutIrregularA: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      pArray: LONG POINTER;    -- whole map unit: irregular swap    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut whole irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- whole unit (irregular), initially dirty    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut whole irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Touch[[0, 10], write];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- whole unit (irregular), initially dead    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut whole irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial map unit: 1st whole irregular swap unit    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyOut[interval: [0, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit (irregular), initially dirty    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Touch[[0, 5], write];    CopyOut[interval: [0, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit (irregular), initially dead    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    CopyOut[interval: [0, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial map unit: last whole irregular swap unit    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyOut[interval: [6, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    -- partial unit (irregular), end, initially dirty    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Touch[[6, 4], write];    CopyOut[interval: [6, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    -- partial unit (irregular), end, initially dead    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut partial, last irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    CopyOut[interval: [6, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    END;  -- CopyOut tests for irregular swap units in single map units, part 2  CopyOutIrregularB: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      pArray: LONG POINTER;    -- partial map unit: embedded page, irregular swap unit    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut embedded page of irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyOut[interval: [8, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit (irregular), embedded page, initially dirty    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut embedded page of irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Touch[[8, 1], write];    CopyOut[interval: [8, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit (irregular), embedded page, initially dead    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut embedded page of irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    CopyOut[interval: [8, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial map unit: overlap irregular swap units    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [4, 2, 4]];    Map[id: "CopyOut partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyOut[interval: [2, 3],      runLength: 3,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit, overlap irregular swap units, initially dirty    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [4, 2, 4]];    Map[id: "CopyOut partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Touch[[2, 3], write];    CopyOut[interval: [2, 3],      runLength: 3,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit, overlap irregular swap units, initially dead    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [4, 2, 4]];    Map[id: "CopyOut partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    CopyOut[interval: [2, 3],      runLength: 3,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial map unit: overlap + include irregular swap units    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyOut[interval: [4, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit, overlap + include irregular swap units, initially dirty    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Touch[[4, 5], write];    CopyOut[interval: [4, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit, overlap + include irregular swap units, initially dead    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    CopyOut[interval: [4, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    END;  -- CopyOut tests for irregular swap units in single map units, part 3  CopyOutIrregularC: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- This contains the tests of parts 1 and 2, but with a single Map/Unmap.      pArray: LONG POINTER;    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut, irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    Touch[[0, 10], write];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    CopyOut[interval: [0, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Touch[[0, 5], write];    CopyOut[interval: [0, 5],      runLength: 5,      returnWait: wait];    Ticker[];    CopyOut[interval: [6, 4],      runLength: 4,      returnWait: wait];    Ticker[];    Touch[[6, 4], write];    CopyOut[interval: [6, 4],      runLength: 4,      returnWait: wait];    Ticker[];    CopyOut[interval: [8, 1],      runLength: 1,      returnWait: wait];    Ticker[];    Touch[[8, 1], write];    CopyOut[interval: [8, 1],      runLength: 1,      returnWait: wait];    Ticker[];    CopyOut[interval: [2, 3],      runLength: 3,      returnWait: wait];    Ticker[];    Touch[[2, 3], write];    CopyOut[interval: [2, 3],      runLength: 3,      returnWait: wait];    Ticker[];    CopyOut[interval: [4, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Touch[[4, 5], write];    CopyOut[interval: [4, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Now on dead pages    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyOut whole irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    CopyOut[interval: [0, 5],      runLength: 5,      returnWait: wait];    Ticker[];    CopyOut[interval: [6, 4],      runLength: 4,      returnWait: wait];    Ticker[];    CopyOut[interval: [8, 1],      runLength: 1,      returnWait: wait];    Ticker[];    CopyOut[interval: [2, 3],      runLength: 3,      returnWait: wait];    Ticker[];    CopyOut[interval: [4, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    END;  -- CopyOut tests over multiple map units  CopyOutMultiple: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      -- Make as many arrayPointers as needed    --pArray: LONG POINTER;    --pRuns: LONG POINTER;    --pSwapUnits: LONG POINTER;    -- multiple map units: all of 2    -- multiple map units: all of 1 + some of 2    -- multiple map units: end of 1 + all of 2    -- multiple map units: some of each: whole uniform swap units    -- multiple map units: some of each: whole irregular swap units    -- multiple map units: some of each: overlap uniform    -- multiple map units: some of each: overlap irregular    -- multiple map units: some of each: overlap + include uniform    -- multiple map units: some of each: overlap + include irregular    -- multiple map units: all of 2: different kinds    -- multiple map units: some of each: different kinds    -- multiple map units: some of each + overlap: different kinds    END;  -- CopyOut tests for uniform swap units in single map units, part 1  CopyOutUniformA: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      pRuns: LONG POINTER;    -- whole map unit: uniform swap    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut whole uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyOut[interval: [4, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- whole unit (uniform), initially dirty    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut whole uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Touch[[4, 10], write];    CopyOut[interval: [4, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- whole unit (uniform), initially dead    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut whole uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    CopyOut[interval: [4, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: beginning, whole uniform swap units    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut beginning of uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyOut[interval: [4, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (uniform), initially dirty    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut beginning of uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Touch[[4, 10], write];    CopyOut[interval: [4, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (uniform), initially dead    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut beginning of uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    CopyOut[interval: [4, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: end, whole uniform swap units    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut end of uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyOut[interval: [4, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (uniform), end, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut end of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Touch[[0, 4], write];    CopyOut[interval: [6, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    END;  -- CopyOut tests for uniform swap units in single map units, part 2  CopyOutUniformB: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      pRuns: LONG POINTER;    -- partial unit (uniform), end, initially dead    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut end of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    CopyOut[interval: [6, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: one embedded page, whole uniform swap units    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut embedded page of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyOut[interval: [4, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (uniform), one embedded page, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut embedded page of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Touch[[4, 1], write];    CopyOut[interval: [4, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (uniform), one embedded page, initially dead    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut embedded page of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    CopyOut[interval: [4, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: overlap uniform swap units    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut beginning of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyOut[interval: [3, 2],      runLength: 2,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit, overlap uniform swap units, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut beginning of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Touch[[3, 2], write];    CopyOut[interval: [3, 2],      runLength: 2,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit, overlap uniform swap units, initially dead    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut beginning of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    CopyOut[interval: [3, 2],      runLength: 2,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: overlap + include uniform swap units    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut beginning of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyOut[interval: [3, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit, overlap + include uniform swap units, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut beginning of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Touch[[3, 4], write];    CopyOut[interval: [3, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit, overlap + include uniform swap units, initially dead    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut beginning of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    CopyOut[interval: [3, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    END;  -- CopyOut tests for uniform swap units in single map units, part 3  CopyOutUniformC: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- This contains all the tests of parts 1 and 2 but with a single Map/Unmap.    pRuns: LONG POINTER;    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut whole uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    Touch[[0, 10], write];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    CopyOut[interval: [0, 4],      runLength: 4,      returnWait: wait];    Ticker[];    Touch[[0, 10], write];    CopyOut[interval: [4, 4],      runLength: 4,      returnWait: wait];    Ticker[];    Touch[[0, 4], write];    CopyOut[interval: [6, 4],      runLength: 4,      returnWait: wait];    Ticker[];    CopyOut[interval: [4, 1],      runLength: 1,      returnWait: wait];    Ticker[];    Touch[[4, 1], write];    CopyOut[interval: [4, 1],      runLength: 1,      returnWait: wait];    Ticker[];    CopyOut[interval: [3, 2],      runLength: 2,      returnWait: wait];    Ticker[];    Touch[[3, 2], write];    CopyOut[interval: [3, 2],      runLength: 2,      returnWait: wait];    Ticker[];    CopyOut[interval: [3, 4],      runLength: 4,      returnWait: wait];    Ticker[];    Touch[[3, 4], write];    CopyOut[interval: [3, 4],      runLength: 4,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pRuns];    -- Now on dead pages    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyOut whole uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    CopyOut[interval: [4, 10],      runLength: 10,      returnWait: wait];    Ticker[];    CopyOut[interval: [4, 4],      runLength: 4,      returnWait: wait];    Ticker[];    CopyOut[interval: [6, 4],      runLength: 4,      returnWait: wait];    Ticker[];    CopyOut[interval: [4, 1],      runLength: 1,      returnWait: wait];    Ticker[];    CopyOut[interval: [3, 2],      runLength: 2,      returnWait: wait];    Ticker[];    CopyOut[interval: [3, 4],      runLength: 4,      returnWait: wait];    Ticker[];    Unmap[page: 4];    heap.FREE[@pRuns];    END;  -- CopyOut tests for unitary swap units in single map units  CopyOutUnitary: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      pRuns: LONG POINTER;    -- whole map unit: unitary swap    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut whole unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- whole unit (unitary), initially dirty    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut whole unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Touch[[0, 10], write];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- whole unit (unitary), initially dead    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut whole unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: swappable];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: unitary, beginning    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut beginning of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyOut[interval: [0, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (unitary), beginning, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut beginning of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Touch[[0, 5], write];    CopyOut[interval: [0, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (unitary), beginning, initially dead    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut beginning of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: swappable];    CopyOut[interval: [0, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: unitary, end    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut end of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyOut[interval: [5, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (unitary), end, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut end of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Touch[[5, 5], write];    CopyOut[interval: [5, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (unitary), end, initially dead    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut end of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: swappable];    CopyOut[interval: [5, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: one embedded page    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut embedded page of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyOut[interval: [3, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (unitary), one embedded page, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut embedded page of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Touch[[3, 1], write];    CopyOut[interval: [3, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (unitary), one embedded page, initially dead    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut embedded page of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: swappable];    CopyOut[interval: [3, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- now all the tests together, one Map/Unmap    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut whole unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    Touch[[0, 10], write];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    CopyOut[interval: [0, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Touch[[0, 5], write];    CopyOut[interval: [0, 5],      runLength: 5,      returnWait: wait];    Ticker[];    CopyOut[interval: [5, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Touch[[5, 5], write];    CopyOut[interval: [5, 5],      runLength: 5,      returnWait: wait];    Ticker[];    CopyOut[interval: [3, 1],      runLength: 1,      returnWait: wait];    Ticker[];    Touch[[3, 1], write];    CopyOut[interval: [3, 1],      runLength: 1,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pRuns];    -- same thing, dead pages    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyOut whole unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: swappable];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    CopyOut[interval: [0, 5],      runLength: 5,      returnWait: wait];    Ticker[];    CopyOut[interval: [5, 5],      runLength: 5,      returnWait: wait];    Ticker[];    CopyOut[interval: [3, 1],      runLength: 1,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pRuns];    END;  ------------  -- PUBLIC SIGNALs and ERRORs: none  ------------  -- Initialization:  ScriptOps.RegisterScript[RunTests, "CopyOut tests"L];  END.LOG29-Nov-82 16:12:05   CAJ    Created file.
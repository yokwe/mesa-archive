-- Copyright (C) 1983, 1985, 1986  by Xerox Corporation. All rights reserved. -- GraphTomDFormSW.mesa (last edited by JBD      7-Jul-86 15:43:11)DIRECTORY  Format USING [Blanks, Char, CR, LongNumber, LongString, StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, CommandItem, DisplayItem, ItemDescriptor,    newLine, NumberItem, NotifyProcType, ProcType, StringItem],  GraphTomDOps,  MsgSW USING [Clear],  MStream USING [Error, WriteOnly],  Put USING [Line],  Selection USING [ClearOnMatch],  Stream USING [Delete, Handle, PutString],  Window USING [InvalidateBox, Validate];GraphTomDFormSW: MONITOR LOCKS globalInfo USING globalInfo:  GraphTomDOps.GlobalInfoP  IMPORTS    Format, FormSW, GraphTomDOps, MsgSW, MStream, Put, Selection, Stream, Window  EXPORTS GraphTomDOps =  BEGIN OPEN GraphTomDOps;  iHold, iNormalise, iRescale, iResetOrigin, iClear, iPrint, iFilename,    iHistorySize, iHeight, iSet, iReset: CARDINAL;  -- routines to manage the options formSW ....  FormSWItems: PUBLIC PROCEDURE [globalInfo: GlobalInfoP]    RETURNS [items: FormSW.ItemDescriptor, freeDesc: BOOLEAN] =    BEGIN OPEN FormSW;    nItems: CARDINAL ¬ 11;    items ¬ AllocateItemDescriptor[nItems];    items[iHold ¬ 0] ¬ BooleanItem[      tag: "Hold"L, place: newLine, switch: @globalInfo.hold.b];    items[iNormalise ¬ 1] ¬ BooleanItem[      tag: "Normalize"L, switch: @globalInfo.normalize.b, proc: Normalize];    items[iRescale ¬ 2] ¬ CommandItem[tag: "Rescale", proc: CommandProc];    items[iResetOrigin ¬ 3] ¬ CommandItem[      tag: "Reset origin"L, proc: CommandProc];    items[iClear ¬ 4] ¬ CommandItem[tag: "Clear"L, proc: CommandProc];    items[iPrint ¬ 5] ¬ CommandItem[tag: "Print"L, proc: CommandProc];    items[iFilename ¬ 6] ¬ StringItem[      tag: "Filename"L, string: @globalInfo.filename, inHeap: TRUE];    items[iHistorySize ¬ 7] ¬ NumberItem[      tag: "History Size"L, place: newLine, value: @globalInfo.usersHistorySize,      signed: FALSE, notNegative: TRUE];    items[iHeight ¬ 8] ¬ NumberItem[      tag: "Graph height"L, value: @globalInfo.usersGraphHeight, signed: FALSE,      notNegative: TRUE];    items[iSet ¬ 9] ¬ CommandItem[tag: "set"L, proc: CommandProc];    items[iReset ¬ 10] ¬ CommandItem[tag: "reset"L, proc: CommandProc];    RETURN[items: items, freeDesc: TRUE];    END;  CommandProc: FormSW.ProcType =    BEGIN    globalInfo: GlobalInfoP ¬ GetGlobalInfo[sw];    IF globalInfo = NIL THEN RETURN;    BEGIN OPEN globalInfo;    MsgSW.Clear[globalInfo.msgSW];    SELECT index FROM      iRescale => Rescale[globalInfo];      iResetOrigin => ResetOrigin[globalInfo];      iClear => Clear[globalInfo];      iPrint => Print[globalInfo];      iSet =>        BEGIN        IF historySize # usersHistorySize THEN ChangeHistorySize[globalInfo];        IF graphHeight # usersGraphHeight THEN ChangeGraphHeight[globalInfo];        END;      iReset =>        BEGIN        IF historySize # usersHistorySize THEN {          usersHistorySize ¬ historySize;          FormSW.DisplayItem[formSW, iHistorySize]};        IF graphHeight # usersGraphHeight THEN {          usersGraphHeight ¬ graphHeight; FormSW.DisplayItem[formSW, iHeight]};        END;      ENDCASE => ERROR;    END    END;  ChangeHistorySize: ENTRY PROCEDURE [globalInfo: GlobalInfoP] =    BEGIN    oldSize: CARDINAL ¬ globalInfo.historySize;    newSize: CARDINAL ¬ globalInfo.usersHistorySize;    item0Info: ItemInfoP ¬ globalInfo.items[0].client;    sourceCount: CARDINAL ¬  -- number of non-undefined readings      (IF item0Info.history[globalInfo.historySize - 1] = undefined THEN       globalInfo.last + 1 ELSE globalInfo.historySize);    Selection.ClearOnMatch[globalInfo];    DestroyGraphs[globalInfo];    FOR i: CARDINAL IN [0..LENGTH[globalInfo.items]) DO      oldItemInfo: ItemInfoP ¬ globalInfo.items[i].client;      newItemInfo: ItemInfoP ¬ z.NEW[ItemInfo [newSize]];      -- boring - can't copy constant data part because size gets zapped      -- so initialize newItemInfo by steam      -- don't bother to init box fields - will be done later      newItemInfo.prev ¬ oldItemInfo.prev;      newItemInfo.hwm ¬ oldItemInfo.hwm;      newItemInfo.maxVal ¬ oldItemInfo.maxVal;      newItemInfo.isSelected ¬ oldItemInfo.isSelected;      newItemInfo.item ¬ oldItemInfo.item;      IF sourceCount > newSize THEN        FOR j: CARDINAL IN [0..newSize) DO          newItemInfo.history[j] ¬ oldItemInfo.history[            (globalInfo.last + j - newSize + 1) MOD oldSize];          ENDLOOP      ELSE        BEGIN        FOR j: CARDINAL IN [0..sourceCount) DO          newItemInfo.history[j] ¬ oldItemInfo.history[            (globalInfo.last + j - sourceCount + 1) MOD oldSize];          ENDLOOP;        FOR j: CARDINAL IN [sourceCount..newSize) DO          newItemInfo.history[j] ¬ undefined ENDLOOP;        END;      globalInfo.items[i].client ¬ newItemInfo;      ENDLOOP;    globalInfo.last ¬      (IF newSize < sourceCount THEN newSize - 1 ELSE sourceCount - 1);    globalInfo.historySize ¬ newSize;    CreateGraphs[globalInfo];    END;  ChangeGraphHeight: ENTRY PROCEDURE [globalInfo: GlobalInfoP] =    BEGIN    globalInfo.graphHeight ¬ globalInfo.usersGraphHeight;    DestroyGraphs[globalInfo];    [] ¬ CreateGraphs[globalInfo];    END;  Clear: PROCEDURE [globalInfo: GlobalInfoP] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH[globalInfo.items]) DO      itemInfo: ItemInfoP ¬ globalInfo.items[i].client;      FOR j: CARDINAL IN [0..globalInfo.historySize) DO        itemInfo.history[j] ¬ undefined ENDLOOP;      Window.InvalidateBox[globalInfo.mainSW, itemInfo.rowBox];      ENDLOOP;    globalInfo.last ¬ globalInfo.historySize - 1;    Window.Validate[globalInfo.mainSW];    END;  Normalize: FormSW.NotifyProcType =    BEGIN    globalInfo: GlobalInfoP ¬ GetGlobalInfo[sw];    FOR i: CARDINAL IN [0..LENGTH[globalInfo.items]) DO      itemInfo: ItemInfoP ¬ globalInfo.items[i].client;      IF itemInfo.item.counter.b THEN        Window.InvalidateBox[globalInfo.mainSW, itemInfo.rowBox]      ENDLOOP;    Window.Validate[globalInfo.mainSW];    END;  Print: ENTRY PROCEDURE [globalInfo: GlobalInfoP] =    BEGIN    Write: PROCEDURE [s: LONG STRING] = {Put.Line[globalInfo.msgSW, s]};    p: Format.StringProc = {Stream.PutString[sH: stream, string: s]};    index: CARDINAL ¬ 0;    stream: Stream.Handle;    anyNormalized: BOOLEAN ¬ FALSE;    IF globalInfo.slctScale = none THEN {      Write["error: nothing selected"]; RETURN};    stream ¬ MStream.WriteOnly[      name: globalInfo.filename, release: [NIL, NIL], type: text !      MStream.Error => GOTO openError];    FOR i: CARDINAL IN [0..LENGTH[globalInfo.items]) DO      item: ItemP ¬ globalInfo.items[i];      itemInfo: ItemInfoP ¬ item.client;      IF ~itemInfo.isSelected THEN LOOP;      index ¬ index + 1;      Format.LongNumber[p, index, [columns: 4]];      IF globalInfo.normalize.b AND item.counter.b THEN {        anyNormalized ¬ TRUE; Format.LongString[p, "*  "L]}      ELSE Format.Blanks[p, 3];      Format.LongString[p, item.interfaceName];      Format.Char[p, '.];      Format.LongString[p, item.varName];      Format.CR[p];      -- Incorporate summary statistics of the selection      BEGIN      min: LONG CARDINAL ¬ LAST[LONG CARDINAL] - 1;      max: LONG CARDINAL ¬ 0;      nBins: CARDINAL ¬ 0;      sum: LONG CARDINAL ¬ 0;      FOR j: CARDINAL IN [globalInfo.slct.j1..globalInfo.slct.j2] DO        IF j = globalInfo.last + 1 THEN NULL        ELSE          BEGIN          normVal: LONG CARDINAL ¬ NormalizedValue[globalInfo, itemInfo, j];          IF normVal # undefined THEN {            IF normVal < min THEN min ¬ normVal;            max ¬ MAX[max, normVal];            nBins ¬ nBins + 1;            sum ¬ sum + normVal};          END;        ENDLOOP;      Format.LongString[p, "    Max="L];      Format.LongNumber[p, max, []];      Format.LongString[p, ", Min="L];      Format.LongNumber[p, min, []];      Format.LongString[p, ", nBins="L];      Format.LongNumber[p, nBins, []];      Format.LongString[p, ", SumBins="L];      Format.LongNumber[p, sum, []];      Format.LongString[p, ", Average="L];      IF nBins > 0 THEN Format.LongNumber[p, sum / nBins, []]      ELSE Format.LongString[p, "***"L];      Format.CR[p];      END;      ENDLOOP;    IF anyNormalized THEN Format.LongString[p, "(*: normalized)\n"L];    THROUGH [1..3] DO Format.CR[p] ENDLOOP;    FOR i: CARDINAL IN [1..index] DO      Format.LongNumber[p, i, [columns: 5]]; Format.Blanks[p, 1] ENDLOOP;    THROUGH [1..2] DO Format.CR[p] ENDLOOP;    FOR j: CARDINAL IN [globalInfo.slct.j1..globalInfo.slct.j2] DO      FOR i: CARDINAL IN [0..LENGTH[globalInfo.items]) DO        item: ItemP ¬ globalInfo.items[i];        itemInfo: ItemInfoP ¬ item.client;        IF ~itemInfo.isSelected THEN LOOP;        IF j = globalInfo.last + 1 THEN Format.LongString[p, "    -"L]        ELSE          BEGIN          normVal: LONG CARDINAL ¬ NormalizedValue[globalInfo, itemInfo, j];          IF normVal = undefined THEN Format.LongString[p, "    *"L]          ELSE Format.LongNumber[p, normVal, [columns: 5]];          END;        Format.Blanks[p, 1];        ENDLOOP;      Format.CR[p];      ENDLOOP;    Stream.Delete[stream];    EXITS openError => Put.Line[globalInfo.msgSW, "error opening file for output"]    END;  Rescale: ENTRY PROCEDURE [globalInfo: GlobalInfoP] =    BEGIN    FOR i: CARDINAL IN [0..LENGTH[globalInfo.items]) DO      item: ItemP ¬ globalInfo.items[i];      itemInfo: ItemInfoP ¬ item.client;      max: LONG CARDINAL ¬ 1;      IF ~itemInfo.isSelected THEN LOOP;      FOR j: CARDINAL IN [globalInfo.slct.j1..globalInfo.slct.j2] DO        normVal: LONG CARDINAL ¬ NormalizedValue[globalInfo, itemInfo, j];        IF normVal # undefined THEN max ¬ MAX[max, normVal]        ENDLOOP;      itemInfo.maxVal ¬ max;      itemInfo.hwm ¬ 0;      Window.InvalidateBox[globalInfo.mainSW, itemInfo.rowBox];      ENDLOOP;    Window.Validate[globalInfo.mainSW];    END;  ResetOrigin: ENTRY PROCEDURE [globalInfo: GlobalInfoP] =    BEGIN    hS: CARDINAL ¬ globalInfo.historySize;    IF globalInfo.last = hS - 1 THEN RETURN;    FOR i: CARDINAL IN [0..LENGTH[globalInfo.items]) DO      itemInfo: ItemInfoP ¬ globalInfo.items[i].client;      newItemInfo: ItemInfoP ¬ z.NEW[ItemInfo [hS] ¬ itemInfo­];      FOR j: CARDINAL IN [0..hS) DO  -- rotate info so that last moves to end column        newItemInfo.history[(j + hS - 1 - globalInfo.last) MOD hS] ¬          itemInfo.history[j];        ENDLOOP;      Window.InvalidateBox[globalInfo.mainSW, itemInfo.rowBox];      globalInfo.items[i].client ¬ newItemInfo;      z.FREE[@itemInfo];      ENDLOOP;    globalInfo.last ¬ hS - 1;    Window.Validate[globalInfo.mainSW]    END;  END....  LOG28-Jun-83  9:36:37  JXG  Created file19-Nov-85 14:39:25  RSV  Added call to MsgSW.Clear (AR 5521) and created log file 7-Jul-86 15:23:44  JBD  Added statistics to Print        
-- Copyright (C) 1983, 1985, 1987  by Xerox Corporation. All rights reserved. -- FBStompTool.mesa - (last edited by RSV     11-Mar-87 18:02:25)-- Tool for making bootable floppy disks.DIRECTORY  Boot USING [BootFileType, DiskFileID, inLoad, PVBootFiles, Request],  DeviceTypes USING [sa800],  DLionInputOutput USING [firstMapPage, ioPageNumber, mapPagesCount],  Environment USING [    bytesPerPage, bytesPerWord, PageCount, PageNumber, wordsPerPage],  Event USING [DoneWithProcess, Handle, StartingProcess, toolWindow],  EventTypes USING [deactivate],  File USING [File, GetSize, ID, nullID, PageCount, Unknown],  FileTypes USING [tUntypedFile],  Floppy USING [    BootFilePointer, Close, CopyFromPilotFile, CreateFile,    CreateInitialMicrocodeFile, DeleteFile, Error, ErrorType, FileHandle, Format,    GetAttributes, GetBootFiles, GetFileAttributes, nullBootFilePointer,    nullFileID, Open, PageNumber, Read, SetBootFiles, VolumeHandle, Write],  FloppyChannel USING [DiskAddress],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem, Display,    FindItem, ItemHandle, line0, line1, line2, line3, newLine, NumberItem,    ProcType, StringItem, WordBoolean],  Heap USING [systemZone],  Inline USING [HighHalf, LongCOPY, LowHalf],  MFile USING [Acquire, Error, Handle, Release],  MStream USING [Error, ReadOnly, WriteOnly],  Process USING [Detach],  Put USING [Text],  Runtime USING [GetBcdTime],  Space USING [Interval, Map, ScratchMap, Unmap],  SpecialFloppy USING [    CreateFileAtAddress, Error, GetDiskAddress, GetFileAtDiskAddress],  SpecialMFile USING [GetCapaWithAccess, LeaderPages],  String USING [AppendString, CopyToNewString, Empty],  Stream USING [Handle],  Supervisor USING [AddDependency, AgentProcedure, CreateSubsystem,    EnumerationAborted, RemoveDependency, SubsystemHandle],  Time USING [Append, Unpack],  Tool USING [    Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [CreatePeriodicNotify, PeriodicProcType],  UserTerminal USING [BlinkDisplay],  Version USING [Append],  Window USING [Handle];FBStompTool: MONITOR  IMPORTS    Event, Floppy, File, FormSW, Heap, Inline, MFile, MStream, Process, Put,    Runtime, String, Space, SpecialFloppy, SpecialMFile, Supervisor, Time, Tool,    UserInput, UserTerminal, Version =  BEGIN  -- Types  StringName: TYPE = {floppyName, initUCode, boot, germ, diagUCode, pilotUCode};  FileName: TYPE = StringName [initUCode..pilotUCode];  wdsPerPage: CARDINAL = Environment.wordsPerPage;  bytesPerPage: CARDINAL = Environment.bytesPerPage;  bootingInfoOffset: CARDINAL = 10B;  DiagnosticDataRec: TYPE = MACHINE DEPENDENT RECORD [    data(0): CARDINAL ¬ 850,    sector(1): CARDINAL,    cylinder(2): CARDINAL,    head(3): CARDINAL,    a(4): ARRAY [4..32) OF CARDINAL ¬ ALL[000000B],    b(32): ARRAY [32..64) OF CARDINAL ¬ ALL[177777B],    c(64): ARRAY [64..96) OF CARDINAL ¬ ALL[052525B],    d(96): ARRAY [96..128) OF CARDINAL ¬ ALL[125252B],    e(128): ARRAY [128..160) OF CARDINAL ¬ ALL[031463B],    f(160): ARRAY [160..192) OF CARDINAL ¬ ALL[146314B],    g(192): ARRAY [192..224) OF CARDINAL ¬ ALL[000401B],    h(224): ARRAY [224..256) OF CARDINAL ¬ ALL[177376B]];  rootPageAddress: FloppyChannel.DiskAddress = [cylinder: 4, head: 0, sector: 1];  -- Global variables, allocated dynamically so we don't use up resources  -- when deactivated.  GlobalHandle: TYPE = LONG POINTER TO Global;  Global: TYPE = RECORD [    msgSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    commandSW: Window.Handle ¬ NIL,    driveIndex: CARDINAL ¬ 0,    strings: ARRAY StringName OF LONG STRING ¬ ALL[NIL],    formatFloppy: FormSW.WordBoolean ¬ [f1[FALSE]],    reserveLastCylinder: FormSW.WordBoolean ¬ [f1[FALSE]],    makeBoot: FormSW.WordBoolean ¬ [f1[FALSE]],    busy: BOOLEAN ¬ FALSE];  -- The following two lines MUST correspond  nItems: CARDINAL = bootIndex + 1;  drivesIndex: CARDINAL = 0;  formattingIndex: CARDINAL = drivesIndex + 1;  initUCodeIndex: CARDINAL = formattingIndex + 1;  diagUCodeIndex: CARDINAL = initUCodeIndex + 1;  pilotUCodeIndex: CARDINAL = diagUCodeIndex + 1;  germIndex: CARDINAL = pilotUCodeIndex + 1;  bootIndex: CARDINAL = germIndex + 1;  nCommands: CARDINAL = startIndex + 1;  formatIndex: CARDINAL = 0;  reserveLastCylinderIndex: CARDINAL = formatIndex + 1;  makeBootIndex: CARDINAL = reserveLastCylinderIndex + 1;  startIndex: CARDINAL = makeBootIndex + 1;    agent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[CheckDeactivate];  -- Variable declarations  g: GlobalHandle ¬ NIL;  wh: Window.Handle;  -- Tool's window  z: UNCOUNTED ZONE ¬ Heap.systemZone;  NoFile: ERROR [s: LONG STRING] = CODE;  Error: ERROR [s1: LONG STRING, s2: LONG STRING ¬ NIL] = CODE;  --*********************************************************************  --  -- formatting a floppy  --  --*********************************************************************  Format: PROCEDURE =    BEGIN    Write[both, "\nFormatting... "L];    IF g.strings[floppyName] = NIL OR g.strings[floppyName].length = 0 THEN      Error["Please pick a name for this floppy"L];    Floppy.Format[      drive: g.driveIndex, maxNumberOfFileListEntries: 30,      labelString: g.strings[floppyName], density: double];    Write[both, "done"L];    END;  --*********************************************************************  --  -- reserve last cylinder for diagnostics  --  --*********************************************************************  -- on side 0, use 1 (seal), 2-12 (write test), 13 deleted sector test,   --                14 (end marker), 15 (system or begin marker page)  -- on side 1, use 1 (seal), 2 (write), 3 (end marker)  ReserveLastCylinderForDiagnostics: PROCEDURE =    BEGIN    twoSided: BOOLEAN;    Write[both, "\nReserving last cylinder for diagnostics... "L];    twoSided ¬ ReserveLastCylinderOnOneSide[0, 14];    IF twoSided THEN [] ¬ ReserveLastCylinderOnOneSide[1, 2];    Write[both, "done"L];    END;  ReserveLastCylinderOnOneSide: PROCEDURE [head: CARDINAL, size: CARDINAL]    RETURNS [twoSided: BOOLEAN] =    BEGIN    cylinder: CARDINAL = 76;    sector: CARDINAL = 1;    buffer: DiagnosticDataRec ¬ DiagnosticDataRec[      sector: sector, cylinder: cylinder, head: head];    vol: Floppy.VolumeHandle = Floppy.Open[g.driveIndex];    file: Floppy.FileHandle;    pageNumber: Floppy.PageNumber;    BEGIN    ENABLE UNWIND => Floppy.Close[vol ! Floppy.Error => CONTINUE];    IF Floppy.GetAttributes[vol, NIL].density # double THEN      Error["Diagnostic floppies must be double density"L];    twoSided ¬ (Floppy.GetAttributes[vol, NIL].sides = two);    [file, pageNumber] ¬ SpecialFloppy.GetFileAtDiskAddress[      vol, [cylinder: cylinder, head: head, sector: sector]];    IF file.file # Floppy.nullFileID THEN      BEGIN      IF pageNumber # 0 OR Floppy.GetFileAttributes[file].size # size        OR Floppy.GetFileAttributes[file].type # FileTypes.tUntypedFile THEN        Error["Another file occupies required space"L];      Floppy.Read[file, 0, 1, @buffer];      IF buffer # DiagnosticDataRec[sector: sector, cylinder: cylinder, head: head]        THEN Error["Another file occupies required space"L];      END    ELSE      BEGIN      -- create the file      file ¬ SpecialFloppy.CreateFileAtAddress[        vol, size, FileTypes.tUntypedFile, [        cylinder: cylinder, head: head, sector: sector]];      Floppy.Write[file, 0, 1, @buffer];      END;    END;    Floppy.Close[vol];    END;  --*********************************************************************  --  -- install the various files for a bootable floppy  --  --*********************************************************************  MakeBootableFloppy: PROCEDURE =    BEGIN    rootPageFile: Floppy.FileHandle;    vol: Floppy.VolumeHandle;    gotIt: BOOLEAN ¬ TRUE;    Write[both, "\nMaking bootable floppy... "L];    vol ¬ Floppy.Open[g.driveIndex];    rootPageFile ¬ SpecialFloppy.CreateFileAtAddress[      vol, 1, FileTypes.tUntypedFile, rootPageAddress !      SpecialFloppy.Error => {gotIt ¬ FALSE; CONTINUE}];    IF ~gotIt THEN      BEGIN      rootPageFile ¬ SpecialFloppy.GetFileAtDiskAddress[vol, rootPageAddress].file;      IF rootPageFile.file = Floppy.nullFileID THEN GO TO noSpace      ELSE        BEGIN        size: LONG CARDINAL ¬ Floppy.GetFileAttributes[rootPageFile].size;        IF size ~= 1 THEN          BEGIN          Floppy.DeleteFile[rootPageFile];          rootPageFile ¬ SpecialFloppy.CreateFileAtAddress[            vol, 1, FileTypes.tUntypedFile, rootPageAddress !            SpecialFloppy.Error => GO TO noSpace];          END;        END;      END;    -- The following line enforces a workaround for a bug in FloppyInitial.db.    -- Because the floppy initial does not create the inload request for the    -- germ but rather relies on ProcessGerm to do it (here)  we end up    -- with the Germ on the floppy containing a cross-pointer to the bootfile.    -- Therefore if ever we write a new bootfile, we must write a new germ as     -- well.    IF ~String.Empty[g.strings[boot]] AND String.Empty[g.strings[germ]] THEN      GOTO mustQuoteGerm;    FOR s: FileName IN FileName DO      InstallFile[s, vol ! UNWIND => Floppy.Close[vol ! Floppy.Error => CONTINUE]];      ENDLOOP;    WriteBootingInfo[vol, rootPageFile];    Floppy.Close[vol];    Write[both, "done"L];    EXITS      noSpace => {Write[both, "\nfloppy requires reformatting"L]; RETURN};      mustQuoteGerm => {        Write[both, "\nyou must provide a germ if you want to write a bootfile"L];        RETURN};    END;  InstallFile: PROCEDURE [which: FileName, vol: Floppy.VolumeHandle] =    BEGIN    PageOfZeros: TYPE = ARRAY [0..Environment.wordsPerPage] OF WORD ¬ ALL[0];    pageOfZeros: LONG POINTER TO PageOfZeros ¬ z.NEW[PageOfZeros];    filename: LONG STRING = g.strings[which];    file: File.File;    flopFile: Floppy.FileHandle;    leaderSize: File.PageCount;    fileSize: File.PageCount;    flopBFP: Floppy.BootFilePointer;    IF filename = NIL OR filename.length = 0 THEN RETURN;    Write[fileOnly, "\n  installing "L, filename, "... "L];    IF which = germ THEN      BEGIN      IF CreateGermFile[vol, boot] THEN        [file, leaderSize, fileSize] ¬ GetPilotFSDope["FloppyBoot.scratch$"]      ELSE RETURN;      END    ELSE [file, leaderSize, fileSize] ¬ GetPilotFSDope[filename];    flopBFP ¬ GetFloppyFSDope[which, vol];    flopFile ¬ [volume: vol, file: flopBFP.file];    IF flopFile.file # Floppy.nullFileID      AND (Floppy.GetFileAttributes[flopFile].size # fileSize OR which = initUCode)      THEN {      Write[fileOnly, "(deleting existing file)... "L];      Floppy.DeleteFile[flopFile];      SetFloppyFSDope[which, vol, Floppy.nullBootFilePointer];      flopFile ¬ [volume: vol, file: Floppy.nullFileID]};    IF flopFile.file = Floppy.nullFileID THEN {      Write[fileOnly, "(creating file)... "L];      flopFile ¬        IF which = initUCode THEN Floppy.CreateInitialMicrocodeFile[          vol, fileSize, FileTypes.tUntypedFile, 0]        ELSE Floppy.CreateFile[vol, fileSize, FileTypes.tUntypedFile];      IF which # initUCode THEN         SetFloppyFSDope[which, vol, [flopFile.file, 0]]};    Floppy.Write[file: flopFile, first: 0, count: 1, vm: pageOfZeros];    Floppy.CopyFromPilotFile[      floppyFile: flopFile, pilotFile: file, firstFloppyPage: 1,      firstPilotPage: leaderSize+1];    Floppy.CopyFromPilotFile[      floppyFile: flopFile, pilotFile: file, firstFloppyPage: 0,      firstPilotPage: leaderSize, count: 1];    z.FREE[@pageOfZeros];    END;  CreateGermFile: PROCEDURE [volume: Floppy.VolumeHandle, bf: FileName]    RETURNS [success: BOOLEAN ¬ FALSE] =    BEGIN    file: LONG STRING = g.strings[germ];    flopFile: Floppy.FileHandle;    flopBFP: Floppy.BootFilePointer;    location: Boot.DiskFileID;    diskAddress: FloppyChannel.DiskAddress;    flopBFP ¬ GetFloppyFSDope[bf, volume];    flopFile ¬ [volume: volume, file: flopBFP.file];    location.firstPage ¬ 0;    location.fID ¬ [volumeRelative[File.nullID]];    diskAddress ¬ SpecialFloppy.GetDiskAddress[flopFile, flopBFP.page];    location.da ¬ LOOPHOLE[diskAddress];    IF MakeRMFile[file, location] THEN success ¬ TRUE;    END;  WriteBootingInfo: PROCEDURE [vol: Floppy.VolumeHandle, fH: Floppy.FileHandle] =    BEGIN    sIPtr: LONG POINTER = Space.ScratchMap[count: 1];    bf: Boot.PVBootFiles;    flopFile: Floppy.FileHandle;    floppyBootFiles: ARRAY Boot.BootFileType OF Floppy.BootFilePointer;    flopFile.volume ¬ vol;    [, floppyBootFiles[softMicrocode], floppyBootFiles[hardMicrocode],      floppyBootFiles[germ], floppyBootFiles[pilot]] ¬ Floppy.GetBootFiles[vol];    FOR index: Boot.BootFileType IN [hardMicrocode..pilot] DO      flopFile.file ¬ floppyBootFiles[index].file;      bf[index].fID ¬ [volumeRelative[File.nullID]];      bf[index].firstPage ¬ 0;      bf[index].da ¬ LOOPHOLE[SpecialFloppy.GetDiskAddress[        flopFile, floppyBootFiles[index].page]];      ENDLOOP;    LOOPHOLE[sIPtr + bootingInfoOffset, LONG POINTER TO Boot.PVBootFiles]­ ¬ bf;    Floppy.Write[fH, 0, 1, sIPtr];    [] ¬ Space.Unmap[sIPtr];    END;  GetPilotFSDope: PROCEDURE [s: LONG STRING]    RETURNS [file: File.File, leaderSize, fileSize: File.PageCount] = {    fH: MFile.Handle;    fH ¬ MFile.Acquire[s, readOnly, [] ! MFile.Error => NoFile[s]];    file ¬ SpecialMFile.GetCapaWithAccess[fH];    leaderSize ¬ SpecialMFile.LeaderPages[];    fileSize ¬      File.GetSize[file ! File.Unknown => {MFile.Release[fH]; NoFile[s]}] -        leaderSize;    MFile.Release[fH]};  GetFloppyFSDope: PROCEDURE [which: FileName, vol: Floppy.VolumeHandle]    RETURNS [Floppy.BootFilePointer] =    BEGIN    info: ARRAY FileName OF Floppy.BootFilePointer;    [initialMicrocode: info[initUCode], pilotMicrocode: info[pilotUCode],      diagnosticMicrocode: info[diagUCode], germ: info[germ],      pilotBootFile: info[boot]] ¬ Floppy.GetBootFiles[vol];    RETURN[info[which]];    END;  SetFloppyFSDope: PROCEDURE [    which: FileName, vol: Floppy.VolumeHandle, bfPointer: Floppy.BootFilePointer] =    BEGIN    info: ARRAY FileName OF Floppy.BootFilePointer;    [initialMicrocode: info[initUCode], pilotMicrocode: info[pilotUCode],      diagnosticMicrocode: info[diagUCode], germ: info[germ],      pilotBootFile: info[boot]] ¬ Floppy.GetBootFiles[vol];    info[which] ¬ bfPointer;    Floppy.SetBootFiles[      volume: vol, pilotMicrocode: info[pilotUCode],      diagnosticMicrocode: info[diagUCode], germ: info[germ],      pilotBootFile: info[boot]];    END;  --*********************************************************************  --  -- Dandelion real memory image maker  --  --*********************************************************************  RealPageNumber: TYPE = CARDINAL;  MapPage: TYPE = RealPageNumber    [DLionInputOutput.firstMapPage..DLionInputOutput.firstMapPage + CARDINAL[                                      DLionInputOutput.mapPagesCount]);  OtherMem: TYPE = RealPageNumber [320..768);  IOPhysPage: RealPageNumber = DLionInputOutput.ioPageNumber;  IOVirtPage: CARDINAL = 377B;  GermMDSPage: TYPE = CARDINAL [0..377B);  -- page  germMDSMapPage: MapPage = MapPage.FIRST;  firstForPilotPage: RealPageNumber = OtherMem.FIRST;  -- there are two memory boards in the DLion:  -- memControl (standard 64K, option 256K)  -- storage    (standard 128K, option: 512K or fraction)  last192kMachineForPilotPage: RealPageNumber = 3 * 256 - 1;  last256kMachineForPilotPage: RealPageNumber = 4 * 256 - 1;  last384kMachineForPilotPage: RealPageNumber = 6 * 256 - 1;  lastForPilotPage: RealPageNumber ¬ last192kMachineForPilotPage;  -- Dandelion memory map  mapPages: Environment.PageCount = MapPage.LAST.SUCC - MapPage.FIRST;  -- NOTE: MapIndex-es ARE ALWAYS REDUCED TO A CARDINAL  -- ALTHOUGH A PAGE NUMBER IS POTENTIALLY 24 BITS LONG.  HOWEVER,   -- DANDELIONS ONLY HAVE 16 BIT PAGE NUMBERS AND THIS IS MAKEDLIONBOOTFLOPPYTOOL!  MapIndex: TYPE = CARDINAL [0..CARDINAL[mapPages * wdsPerPage]);  RealMapEntry: TYPE = MACHINE DEPENDENT RECORD [    lo: [0..256), logSingle: BOOLEAN ¬ FALSE, flg: [0..8), addrHi: [0..16)];  vacant: RealMapEntry = [0, FALSE, 6, 0];  InitMap: PROCEDURE [map: LONG POINTER TO ARRAY MapIndex OF RealMapEntry] = {    -- set the local map to be the same as that set up by the initial ucode    SetMap: PROCEDURE [      virtual: Environment.PageNumber, realPage: RealPageNumber,      map: LONG POINTER TO ARRAY MapIndex OF RealMapEntry] = {      IF virtual NOT IN MapIndex THEN ERROR;      map[CARDINAL[virtual]] ¬ [        flg: 0, addrHi: realPage / 400B, lo: realPage MOD 400B]};	    rp: RealPageNumber ¬ firstForPilotPage;    vp: Environment.PageNumber ¬ 0;        «map­ ¬ ALL[vacant]; »« workaround below for compiler bug»    map[0] ¬ vacant;    Inline.LongCOPY[      from: @map[0],       to: @map[1],      nwords: SIZE[ARRAY MapIndex OF RealMapEntry] - 1];          DO      SELECT TRUE FROM        vp = IOVirtPage => {SetMap[vp, IOPhysPage, map]; vp ¬ vp + 1};        rp = IOPhysPage => {rp ¬ rp + 1};        ENDCASE => {SetMap[vp, rp, map]; rp ¬ rp + 1; vp ¬ vp + 1};      IF rp = lastForPilotPage + 1 THEN EXIT;      ENDLOOP};  OutData: PROCEDURE [    realAddr: LONG POINTER, myAddr: LONG POINTER, out: Stream.Handle,    count: CARDINAL [0..wdsPerPage] ¬ wdsPerPage] = {    RMHeader: TYPE = MACHINE DEPENDENT RECORD [      count(0), realHi(1), realLo(2): CARDINAL];    rmHeader: RMHeader ¬ [      count: count, realHi: Inline.HighHalf[realAddr],      realLo: Inline.LowHalf[realAddr]];    out.put[      out, [      LOOPHOLE[LONG[@rmHeader]], 0, Environment.bytesPerWord * SIZE[RMHeader]],      FALSE];    out.put[out, [myAddr, 0, count * Environment.bytesPerWord], FALSE]};  UnmappedMemory: ERROR = CODE;  GetRealAddr: PROCEDURE [    virtPageNumber: Environment.PageNumber,    map: LONG POINTER TO ARRAY MapIndex OF RealMapEntry]    RETURNS [realAddr: LONG POINTER] =    BEGIN    me: RealMapEntry = map[CARDINAL[virtPageNumber]];    IF me.flg = vacant.flg THEN ERROR UnmappedMemory;    RETURN[LOOPHOLE[LONG[me.lo + (me.addrHi * 400B)] * wdsPerPage]]    END;  ReadPage: PROCEDURE [in: Stream.Handle, p: LONG POINTER, filename: LONG STRING]    RETURNS [eof: BOOLEAN] =    BEGIN    SELECT in.get[in, [p, 0, bytesPerPage], in.options].bytesTransferred FROM      bytesPerPage => RETURN[eof: FALSE];      0 => RETURN[eof: TRUE];      ENDCASE => Error["Unexpected end of "L, filename]    END;  ProcessGerm: PROCEDURE [    germName: LONG STRING, bootFileLocation: Boot.DiskFileID, map: LONG POINTER,    out: Stream.Handle] =    BEGIN    in: Stream.Handle = MStream.ReadOnly[      germName, [] ! MStream.Error => NoFile[germName]];    FOR vp: GermMDSPage ¬ FIRST[GermMDSPage] + 1, vp + 1 DO      data: ARRAY [0..wdsPerPage) OF WORD;      IF ReadPage[in, @data, germName ! UNWIND => in.delete[in]].eof THEN EXIT;      -- THE FOLLOWING OUGHT TO BE DONE BY THE INITIAL FLOPPY MICROCODE.      -- INSTEAD, IT LEAVES A POINTER TO THE BOOTFILE WRITTEN INTO THE GERM!!!      IF vp = GermMDSPage.FIRST + 4 THEN {        -- pRequest is now on page 4 of the germ file. AHL        myPRequest: POINTER TO Boot.Request = LOOPHOLE[@data[240B]];        myPRequest­ ¬ [	  --requestBasicVersion: Boot.currentRequestBasicVersion,          action: Boot.inLoad,          location: [deviceType: DeviceTypes.sa800, deviceOrdinal: 0, vp: NULL],          pStartListHeader: NIL, inLoadMode: load, session: NULL];        myPRequest.location.diskFileID ¬ bootFileLocation};      OutData[realAddr: GetRealAddr[vp, map], myAddr: @data, out: out];      ENDLOOP;    in.delete[in]    END;  MakeRMFile: PROCEDURE [germName: LONG STRING, bootFileLocation: Boot.DiskFileID]    RETURNS [success: BOOLEAN ¬ TRUE] =    BEGIN    IF String.Empty[germName] THEN RETURN[FALSE];    Write[fileOnly, "converting boot file to real memory image... "L];    BEGIN    out: Stream.Handle = MStream.WriteOnly["FloppyBoot.scratch$"L, [], binary];    mapSpace: LONG POINTER = Space.ScratchMap[mapPages];    InitMap[map: mapSpace];    ProcessGerm[      germName: germName, bootFileLocation: bootFileLocation, map: mapSpace,      out: out ! UnmappedMemory => {success ¬ FALSE; CONTINUE};      UNWIND => {out.delete[out]; [] ¬ Space.Unmap[mapSpace]}];    [] ¬ Space.Unmap[mapSpace];    -- end stream    THROUGH [0..3) DO out.putWord[out, 0] ENDLOOP;    out.delete[out];    END;    IF ~success THEN Write[fileOnly, "aborted: boot file too big"L]    END;  --*********************************************************************  --  -- tool support  --  --*********************************************************************  -- Initialization  Init: PROCEDURE =    BEGIN    name: LONG STRING ¬ String.CopyToNewString[      s: "MakeDLionBootFloppyTool "L, z: z, longer: 100];    Version.Append[name];    String.AppendString[to: name, from: " of "L];    Time.Append[name, Time.Unpack[Runtime.GetBcdTime[]]];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: name, tinyName1: "MakeDLion"L,      tinyName2: "BootFloppy"L, cmSection: "MakeDLionBootFloppyTool"L];    z.FREE[@name];    END;      CheckDeactivate: Supervisor.AgentProcedure     --[event: Supervisor.Event, eventData: LONG POINTER TO UNSPECIFIED, instanceData: LONG POINTER TO UNSPECIFIED]-- =    BEGIN    IF event = EventTypes.deactivate AND      wh # NIL AND wh = eventData      AND g.busy THEN {      UserTerminal.BlinkDisplay[];      Write[msgOnly, "\nMakeDLionBootFloppyTool busy: aborting deactivation... "L];      ERROR Supervisor.EnumerationAborted};    END;  MakeSWs: Tool.MakeSWsProc --[window: Tool.WindowHandle]--  =    BEGIN    logName: STRING = [50];    Tool.UnusedLogName[unused: logName, root: "MakeDLionBootFloppyTool.log"L];    g.msgSW ¬ Tool.MakeMsgSW[window: window];    g.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    g.commandSW ¬ Tool.MakeFormSW[window: window, formProc: MakeCommandSW];    g.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    Supervisor.AddDependency[client: agent, implementor: Event.toolWindow];    END;  MakeForm: FormSW.ClientItemsProcType    --RETURNS [items: FormSW.ItemDescriptor, freeDesc: BOOLEAN]--  =    BEGIN OPEN FormSW;    items ¬ AllocateItemDescriptor[nItems];    items[drivesIndex] ¬ NumberItem[      tag: "Drive"L, place: [0, line0], signed: FALSE, notNegative: TRUE,      radix: decimal, value: @g.driveIndex];    items[formattingIndex] ¬ StringItem[      tag: "Floppy Name"L, place: [200, line0], string: @g.strings[floppyName],      inHeap: TRUE];    items[initUCodeIndex] ¬ StringItem[      tag: "Initial uCode"L, place: [0, line1], string: @g.strings[initUCode],      inHeap: TRUE];    items[diagUCodeIndex] ¬ StringItem[      tag: "Diagnostic uCode"L, place: [200, line1], string: @g.strings[diagUCode],      inHeap: TRUE];    items[pilotUCodeIndex] ¬ StringItem[      tag: "Pilot uCode"L, place: [0, line2], string: @g.strings[pilotUCode],      inHeap: TRUE];    items[germIndex] ¬ StringItem[      tag: "Germ File"L, place: [200, line2], string: @g.strings[germ],      inHeap: TRUE];    items[bootIndex] ¬ StringItem[      tag: "Boot File"L, place: [0, line3], string: @g.strings[boot],      inHeap: TRUE];    RETURN[items: items, freeDesc: TRUE];    END;  MakeCommandSW: FormSW.ClientItemsProcType    --RETURNS [items: FormSW.ItemDescriptor, freeDesc: BOOLEAN]--  =    BEGIN OPEN FormSW;    -- Create SW for commands.    items ¬ AllocateItemDescriptor[nCommands];    items[formatIndex] ¬ BooleanItem[      tag: "Format Floppy"L, place: newLine, switch: @g.formatFloppy.b,      drawBox: TRUE];    items[reserveLastCylinderIndex] ¬ BooleanItem[      tag: "Reserve Last Cylinder For Diagnostics"L,      switch: @g.reserveLastCylinder.b, drawBox: TRUE];    items[makeBootIndex] ¬ BooleanItem[      tag: "Install Boot Files"L, switch: @g.makeBoot.b, drawBox: TRUE];    items[startIndex] ¬ CommandItem[tag: "Start"L, proc: DoCommand];    RETURN[items: items, freeDesc: TRUE];    END;      DoCommand: FormSW.ProcType    --[sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL]--  =    {Process.Detach[FORK DoCommandInternal[sw, item, index]]};      DoCommandInternal: ENTRY PROCEDURE [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL] =    BEGIN    floppyErrors: ARRAY Floppy.ErrorType OF STRING = [      "badDisk"L, "badSectors"L, "endOfFile"L, "fileListFull"L, "fileNotFound"L,      "hardwareError"L, "incompatibleSizes"L, "invalidFormat"L,      "invalidPageNumber"L, "invalidVolumeHandle"L, "insufficientSpace"L,      "needsScavenging"L, "noSuchDrive"L, "notReady"L, "onlyOneSide"L,      "onlySingleDensity"L, "initialMicrocodeSpaceNotAvailable"L,      "stringTooShort"L, "volumeNotOpen"L, "writeInhibited"L, "zeroSizeFile"L,      "file list length too short"L, "floppy image invalid"L,      "floppy space too small"L];    handle: Event.Handle ¬ Event.StartingProcess["MakeDLionBootFloppyTool"L];    BEGIN -- Extra BEGIN/END so handle can be referred to in EXITS clause    g.busy ¬ TRUE;    SetCommandSW[executing];    IF g.formatFloppy.b THEN      Format[        !        Floppy.Error => {          Write[both, "\nFloppy.Error="L, floppyErrors[error]]; GOTO Skip};        Error => {Write[both, s1, s2]; GOTO Skip}];    IF g.reserveLastCylinder.b THEN      ReserveLastCylinderForDiagnostics[        !        Floppy.Error => {          Write[both, "\nFloppy.Error="L, floppyErrors[error]]; GOTO Skip};        Error => {Write[both, s1, s2]; GOTO Skip}];    IF g.makeBoot.b THEN      MakeBootableFloppy[        !        Floppy.Error => {          Write[both, "\nFloppy.Error="L, floppyErrors[error]]; GOTO Skip};        Error => {Write[both, s1, s2]; GOTO Skip};        NoFile => {Write[both, s, " not found"L]; GOTO Skip}];    SetCommandSW[waiting];    g.busy ¬ FALSE;    Event.DoneWithProcess[handle];    EXITS Skip => {      UserTerminal.BlinkDisplay[];       SetCommandSW[waiting];       g.busy ¬ FALSE;       Event.DoneWithProcess[handle]};    END;    END;  SetCommandSW: PROCEDURE [newState: {executing, waiting}] =    BEGIN    item: FormSW.ItemHandle;    SELECT newState FROM      executing => {        FOR i: CARDINAL ¬ 0, i + 1 UNTIL (item ¬ FormSW.FindItem[g.commandSW, i]) =          NIL DO item.flags.invisible ¬ TRUE ENDLOOP;        FormSW.Display[g.commandSW]};      waiting => {        FOR i: CARDINAL ¬ 0, i + 1 UNTIL (item ¬ FormSW.FindItem[g.commandSW, i]) =          NIL DO item.flags.invisible ¬ FALSE ENDLOOP;        [] ¬ UserInput.CreatePeriodicNotify[          proc: FormSWDisplay, window: g.commandSW, rate: 0]};      ENDCASE;    END;  FormSWDisplay: UserInput.PeriodicProcType = {FormSW.Display[window]};  ClientTransition: ToolWindow.TransitionProcType    --[window: ToolWindow.Handle, old, new: ToolWindow.State]--  =    BEGIN    SELECT TRUE FROM      old = inactive => {         IF g = NIL THEN {          g ¬ z.NEW[Global ¬ []];          g.strings[initUCode] ¬ String.CopyToNewString["FloppyInitial.db"L, z];          g.strings[germ] ¬ String.CopyToNewString["DLion.germ"L, z];          g.strings[pilotUCode] ¬ String.CopyToNewString["Mesa.db"L, z];          g.strings[boot] ¬ String.CopyToNewString["OthelloDLion.boot"L, z];          g.strings[diagUCode] ¬ String.CopyToNewString["MoonBoot.db"L, z]}};      new = inactive => {        Supervisor.RemoveDependency[client: agent, implementor: Event.toolWindow];        IF g # NIL THEN {          FOR i: StringName IN StringName DO z.FREE[@g.strings[i]]; ENDLOOP;          z.FREE[@g]}};      ENDCASE    END;  Write: PROCEDURE [which: {fileOnly, msgOnly, both}, s1, s2, s3: LONG STRING ¬ NIL] =    BEGIN    Do: PROCEDURE [sw: Window.Handle, s: LONG STRING] = INLINE {      IF s # NIL THEN Put.Text[sw, s]};    IF which # msgOnly THEN {      Do[g.fileSW, s1]; Do[g.fileSW, s2]; Do[g.fileSW, s3]};    IF (which = both) OR (which = msgOnly) THEN {      Do[g.msgSW, s1]; Do[g.msgSW, s2]; Do[g.msgSW, s3]};    END;  Init[];  END.  LOG-- JXG    	20-Apr-83 14:29:48-- AXD    	29-Aug-83 15:38:27-- AEF     	28-Sep-83 10:42:54JXG    	28-Nov-83 11:35:01   Added support for reserving last cylinder for diagnostics  Forced user to quote germ if a new boot file is being installed  Tidied up program. Trimmed log to Klamath.RSV     23-Dec-85  8:58:21  Changed "Floppy.GetFileAttributes[flopFile].size < fileSize ..." to "Floppy.GetFileAttributes[flopFile].size # fileSize ..." in procedure InstallFile (AR 8556).  Changed parameter of Floppy.Open in ReserveLastCylinderOnOneSide from 0 to g.driveIndex.  Moved writing "Making bootable floppy" message before trying to open the drive.  Changed zeroing entry for files in sector nine page to just zeroing first page of the file being installed.  Finally, made tool run in background.RSV     11-Mar-87 18:02:05  Work around in InitMap for compiler bug.  AHL earlier also made changes for MDS relief.
-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. -- FTTApplyOptionsAImpl.mesa, last edited by:   RSV on  3-Apr-87 18:36:39DIRECTORY  Environment USING [bytesPerPage],  File USING [File, PageNumber, Type],  Floppy,  Format USING [],  FormSW USING [ProcType],  FTTDefs,  Inline USING [LongCOPY],  MFile USING [Handle, Release, SetLength],  Space USING [nullInterval, PageCount, Unmap],  StringSW USING [GetString];FTTApplyOptionsAImpl: PROGRAM   IMPORTS Floppy, FTTDefs, Inline, MFile, Space, StringSW  EXPORTS FTTDefs  SHARES Floppy =			  BEGIN OPEN FTTDefs;      FormatApplyOptions: PUBLIC FormSW.ProcType =    BEGIN      ENABLE         redoparams => BEGIN	    	       PrintErrorProc[toolData.msgSW, msg];		       GOTO exit;                       END;    --Clear the messageSW    ClearmsgSW[];    --Test Floppy.Format; checking for apprpriate errors    Floppy.Format[      toolData.drive, toolData.maxNumberOfFileListEntries,      toolData.labelString, toolData.density, toolData.sides !        Floppy.Error => ErrorHandlingProc[error];	Floppy.AlreadyFormatted =>	  IF toolData.reFormat THEN  -- if really want to reformat then do it	    RESUME	  ELSE 	    BEGIN	    PrintErrorProc[	      toolData.msgSW, "Floppy is Already Formatted.  Reformat?"L];	    GOTO exit;	    END;];    RemoveOptions[sw];    EXITS      exit => RETURN;    END;  CreateFileApplyOptions: PUBLIC FormSW.ProcType =    BEGIN      ENABLE        redoparams => BEGIN	    	      PrintErrorProc[toolData.msgSW, msg];		      GOTO exit;                      END;    fileType: File.Type;    volume: VolumeRecType ¬ [toolData.volumeHandle.lowbits,			      toolData.volumeHandle.highbits];    fHandle : Floppy.FileHandle;         --Clear the messageSW    ClearmsgSW[];    --Convert data into appropriate types so can test Floppy.CreateFile    fileType ¬ LOOPHOLE[toolData.type, File.Type];    --Test Floppy.CreateFile; storing the returned data for later inspection    fHandle ¬ Floppy.CreateFile[      LOOPHOLE[volume, Floppy.VolumeHandle],toolData.size,fileType !	 Floppy.Error => ErrorHandlingProc[error];];    --Print whatever was returned from Floppy.CreateFile    PrintCreateFileReturns[fHandle];    RemoveOptions[sw];    EXITS      exit => RETURN;    END;       CopyToPilotFileApplyOptions: PUBLIC FormSW.ProcType =    BEGIN     ENABLE       redoparams => BEGIN	    	     PrintErrorProc[toolData.msgSW, msg];		     GOTO exit;                     END;           file: FileRecType ¬ [toolData.volumeHandle.lowbits,			toolData.volumeHandle.highbits,                        toolData.fileID.a,			toolData.fileID.b];    pilotFile: File.File;    size: LONG CARDINAL;    count: Floppy.PageCount ¬     IF toolData.entireFile THEN Floppy.defaultPageCount ELSE toolData.count;    firstFloppyPage: Floppy.PageNumber ¬ toolData.first;    firstPilotPage: File.PageNumber ¬ toolData.pilotPage;        --Clear messageSW    ClearmsgSW[];    --Convert data into appropriate types so can test Floppy.CopyToPilotFile    pilotFile ¬ LoopHoleFile[toolData.pilotFileID];    --Test Floppy.CopyToPilotFile    Floppy.CopyToPilotFile[      LOOPHOLE[file, Floppy.FileHandle], pilotFile, firstFloppyPage,      firstPilotPage, count !         Floppy.Error => ErrorHandlingProc[error];];    size ¬ Environment.bytesPerPage * Floppy.GetFileAttributes[      LOOPHOLE[file,Floppy.FileHandle] !        Floppy.Error => ErrorHandlingProc[error];].size;    IF toolData.fileHandle # 0 THEN {      MFile.SetLength[LOOPHOLE[toolData.fileHandle,MFile.Handle],size];      MFile.Release[LOOPHOLE[toolData.fileHandle,MFile.Handle]];      toolData.fileHandle ¬ 0};    RemoveOptions[sw];    EXITS      exit => RETURN;    END;  ApplyOpenOptions: PUBLIC FormSW.ProcType =    BEGIN     ENABLE        redoparams =>  BEGIN	    		 PrintErrorProc[toolData.msgSW, msg];			 GOTO exit;                       END;       vh: Floppy.VolumeHandle;            --Clear the messageSW     ClearmsgSW[];     --Test Floppy.Open; storing the returned value so it can be printed     vh ¬ Floppy.Open[toolData.drive !Floppy.Error =>    						ErrorHandlingProc[error];];     --Print the variables that were returned by Floppy.Open     PrintOpensReturns[vh];     RemoveOptions[sw];     EXITS       exit => RETURN;    END;      DeleteFileApplyOptions: PUBLIC FormSW.ProcType =    BEGIN     ENABLE        redoparams =>  BEGIN	    		 PrintErrorProc[toolData.msgSW, msg];			 GOTO exit;                       END;      file: FileRecType ¬ [toolData.volumeHandle.lowbits,			toolData.volumeHandle.highbits,                        toolData.fileID.a,			toolData.fileID.b];     --Clear messageSW     ClearmsgSW[];     --Test Floppy.DeleteFile     Floppy.DeleteFile[LOOPHOLE[file, Floppy.FileHandle] !        Floppy.Error => ErrorHandlingProc[error];];     RemoveOptions[sw];     EXITS       exit => RETURN;    END;      CopyFromPilotFileApplyOptions: PUBLIC FormSW.ProcType =    BEGIN     ENABLE       redoparams =>  BEGIN	    	      PrintErrorProc[toolData.msgSW, msg];		      GOTO exit;                      END;          file: FileRecType ¬ [toolData.volumeHandle.lowbits,			toolData.volumeHandle.highbits,                        toolData.fileID.a,			toolData.fileID.b];    pilotFile: File.File;    count: Floppy.PageCount ¬      IF toolData.entireFile THEN Floppy.defaultPageCount ELSE toolData.count;    firstFloppyPage: Floppy.PageNumber ¬ toolData.first;    firstPilotPage: File.PageNumber ¬ toolData.pilotPage;        --Clear messageSW    ClearmsgSW[];    --Convert data to appropriate types so can test    pilotFile ¬ LoopHoleFile[toolData.pilotFileID];    -- Test Floppy.CopyToPilotFile    Floppy.CopyFromPilotFile[      pilotFile, LOOPHOLE[file, Floppy.FileHandle], firstPilotPage,      firstFloppyPage, count !        Floppy.Error => ErrorHandlingProc[error]];    IF toolData.fileHandle # 0 THEN {      MFile.Release[LOOPHOLE[toolData.fileHandle,MFile.Handle]];      toolData.fileHandle ¬ 0};    RemoveOptions[sw];    EXITS      exit => RETURN;    END;  CloseApplyOptions: PUBLIC FormSW.ProcType =    BEGIN     ENABLE        redoparams =>  BEGIN	    		 PrintErrorProc[toolData.msgSW, msg];			 GOTO exit;                       END;     volume: VolumeRecType ¬ [toolData.volumeHandle.lowbits,			      toolData.volumeHandle.highbits];     --clear messageSW     ClearmsgSW[];     --Test Floppy.Close     Floppy.Close[LOOPHOLE[volume, Floppy.VolumeHandle] !        Floppy.Error => ErrorHandlingProc[error];];     RemoveOptions[sw];     EXITS       exit => RETURN;    END;  ReadApplyOptions: PUBLIC FormSW.ProcType =    BEGIN     ENABLE      BEGIN        redoparams =>  BEGIN	    		 PrintErrorProc[toolData.msgSW, msg];			 GOTO exit;                       END;        Floppy.DataError => BEGIN			    PrintErrorProc[toolData.msgSW,			      "Read Error -- look in fileSW for Info"L];			    PrintErrorProc[toolData.fileSW,			      "Data Error while reading in"L];			    PrintDataErrorProc[toolData.fileSW, file, page, vm];                            GOTO exit;			    END;	reduceCount => BEGIN		       PrintErrorProc[toolData.msgSW,			 "Lowering count -- Size of the file is less than the space you want to create"L];		       RESUME;		       END;       END;       fileTo: FileRecType ¬ [toolData.volumeHandle.lowbits,			toolData.volumeHandle.highbits,                        toolData.fileID.a,			toolData.fileID.b];     --Clear messageSW     ClearmsgSW[];     toolData.count ¬ MinFileSize[fileTo, toolData.count];     IF toolData.vmInterval = Space.nullInterval THEN --no space has been created so create one--             CreateSpace[toolData.count]     ELSE             IF toolData.lastSpaceCount < toolData.count THEN --the space created isn't big enough so..--         BEGIN	 [] ¬ 	   Space.Unmap[toolData.vmInterval.pointer]; --get rid of current space--         CreateSpace[toolData.count]; --create a new one of the proper size--         END;          --Test Floppy.Read     Floppy.Read[       LOOPHOLE[fileTo, Floppy.FileHandle], toolData.first,       toolData.count, LOOPHOLE[toolData.vm, LONG POINTER] !         Floppy.Error => ErrorHandlingProc[error];];     --Give the user a chance to display characters/numbers read into vm     DisplayVMOptionsWindow;     RemoveOptions[sw];     EXITS       exit => RETURN;    END;        GetFileAttributesApplyOptions: PUBLIC FormSW.ProcType =    BEGIN     ENABLE        redoparams =>  BEGIN	    		 PrintErrorProc[toolData.msgSW, msg];			 GOTO exit;                       END;       fileType: File.Type;       file: FileRecType ¬ [toolData.volumeHandle.lowbits,			toolData.volumeHandle.highbits,                        toolData.fileID.a,			toolData.fileID.b];            --Clear messageSW     ClearmsgSW[];     --Test Floppy.GetFileAttributes; storing results so they can be printed     [toolData.size, fileType] ¬        Floppy.GetFileAttributes[LOOPHOLE[file, Floppy.FileHandle] !         Floppy.Error => ErrorHandlingProc[error];];     --Print returns of Floppy.GetFileAttributes     PrintGetFileAttributesReturns[toolData.size, fileType];     RemoveOptions[sw];     EXITS       exit => RETURN;    END;  GetAttributesApplyOptions: PUBLIC FormSW.ProcType =    BEGIN      ENABLE        redoparams => BEGIN	    	      PrintErrorProc[toolData.msgSW, msg];		      GOTO exit;		      END;    ReturnRecType: TYPE = RECORD [      freeSpace: Floppy.PageCount ¬ 0,      largestBlock: Floppy.PageCount ¬ 0,      fileList: Floppy.FileHandle ¬ [Floppy.nullVolumeHandle, Floppy.nullFileID],      rootFile: Floppy.FileHandle ¬        [Floppy.nullVolumeHandle, Floppy.nullFileID],      maxFileListEntries: CARDINAL ¬ 0];    returnRec: ReturnRecType;    volume: VolumeRecType ¬ [toolData.volumeHandle.lowbits,			      toolData.volumeHandle.highbits];          --clear messageSW    ClearmsgSW[];    --test Floppy.GetAttributes; stroing results so they can be printed    [returnRec.freeSpace, returnRec.largestBlock, returnRec.fileList,      returnRec.rootFile, toolData.density, toolData.sides,      returnRec.maxFileListEntries] ¬         Floppy.GetAttributes[	  LOOPHOLE[volume, Floppy.VolumeHandle], toolData.labelString !	    Floppy.Error =>ErrorHandlingProc[error];];    --Print returns from Floppy.GetAttributes    PrintGetAttributesReturns[      toolData.labelString, returnRec.freeSpace, returnRec.largestBlock,      returnRec.fileList, returnRec.rootFile, toolData.density,      toolData.sides, returnRec.maxFileListEntries];    RemoveOptions[sw];    EXITS      exit => RETURN;    END;     WriteApplyOptions: PUBLIC FormSW.ProcType =    BEGIN     ENABLE      BEGIN        redoparams =>  BEGIN	    	       PrintErrorProc[toolData.msgSW, msg];		       GOTO exit;		       END;	Floppy.DataError => BEGIN			    PrintErrorProc[toolData.msgSW,			      "Read Error -- look in fileSW for Info"L];			    PrintErrorProc[toolData.fileSW,			      "Data Error while reading in"L];			    PrintDataErrorProc[toolData.fileSW, file, page, vm];			    GOTO exit;			    END;        reduceCount => BEGIN		       PrintErrorProc[toolData.msgSW,			 "Lowering count -- Size of the file is less than the space you want to create"L];       	               RESUME;		       END;      END;      fileTo: FileRecType ¬ [toolData.volumeHandle.lowbits,			toolData.volumeHandle.highbits,                        toolData.fileID.a,			toolData.fileID.b];      one: CARDINAL = 1;      two: CARDINAL = 2;      vmStringPointer: LONG POINTER TO LONG STRING ¬ NIL;      --clear messageSW      ClearmsgSW[];        toolData.count ¬ MinFileSize[fileTo, toolData.count];	SELECT toolData.writeFrom FROM          WriteFrom[String] => BEGIN --if user want to write a string into vm--	    -- see if any space is created to write into--      	    IF toolData.vmInterval = Space.nullInterval THEN               CreateSpace[toolData.count] --if not create the space--            ELSE                    IF toolData.lastSpaceCount < toolData.count THEN		-- if current space isn't large enough                BEGIN	        [] ¬ Space.Unmap[toolData.vmInterval.pointer];                CreateSpace[toolData.count];                END;	    -- get a pointer to the string in StringSW	    vmStringPointer ¬ StringSW.GetString[toolData.writeStringSW];	    -- set the length for # of words to be printed from vm to be the length in words	    -- of the text field for the string in the StringSW	    -- Check for NIL string	    IF vmStringPointer = NIL OR vmStringPointer^ = NIL THEN	      SIGNAL redoparams["No String given"L];	    toolData.length ¬ (vmStringPointer.length + one)/two;	    -- Copy the text field into vm	    Inline.LongCOPY[from: @vmStringPointer.text, nwords: toolData.length,	      to: LOOPHOLE[toolData.vm, LONG POINTER]];	   END;         WriteFrom[ExistingVM] =>	   IF toolData.vmInterval = Space.nullInterval THEN 	     -- if want to write from vm (no string input) check to see if space	     -- is created	     SIGNAL redoparams["no VM mapped"L]         ENDCASE;       --Test Floppy.Write       Floppy.Write[	 LOOPHOLE[fileTo, Floppy.FileHandle],toolData.first,	 toolData.count,LOOPHOLE[toolData.vm, LONG POINTER] ! 	   Floppy.Error => ErrorHandlingProc[error];];       RemoveOptions[sw];    EXITS      exit => RETURN;    END;  GetNextFileApplyOptions: PUBLIC FormSW.ProcType =    BEGIN     ENABLE        redoparams =>  BEGIN	    		 PrintErrorProc[toolData.msgSW, msg];			 GOTO exit;		       END;       file: FileRecType ¬ [toolData.volumeHandle.lowbits,			toolData.volumeHandle.highbits,                        toolData.fileID.a,			toolData.fileID.b];       fHandle: Floppy.FileHandle ¬ [Floppy.nullVolumeHandle, Floppy.nullFileID];     --Clear messageSW     ClearmsgSW[];     --Test Floppy.GetNextFile; storing results so the can be printed     fHandle ¬ Floppy.GetNextFile[LOOPHOLE[file, Floppy.FileHandle] !       Floppy.Error => ErrorHandlingProc[error];];     --print returns from Floppy.GetNextFile     PrintGetNextFileReturns[fHandle];     RemoveOptions[sw];     EXITS       exit => RETURN;    END;  SetRootFileApplyOptions:PUBLIC FormSW.ProcType =    BEGIN     ENABLE        redoparams =>  BEGIN	    		 PrintErrorProc[toolData.msgSW, msg];			 GOTO exit;		       END;    file: FileRecType ¬ [toolData.volumeHandle.lowbits,			toolData.volumeHandle.highbits,                        toolData.fileID.a,			toolData.fileID.b];    --clear messageSW    ClearmsgSW[];    --Test Floppy.SetRootFile    Floppy.SetRootFile[LOOPHOLE[file, Floppy.FileHandle] !       Floppy.Error => ErrorHandlingProc[error];];    RemoveOptions[sw];    EXITS       exit => RETURN;    END;  SetBootFilesApplyOptions: PUBLIC FormSW.ProcType =    BEGIN     ENABLE        redoparams =>  BEGIN	    		 PrintErrorProc[toolData.msgSW, msg];			 GOTO exit;		       END;     volume: VolumeRecType ¬ [toolData.volumeHandle.lowbits,			      toolData.volumeHandle.highbits];               --Clear messageSW     ClearmsgSW[];     --Test Floppy.SetBootFiles     Floppy.SetBootFiles[       volume: LOOPHOLE[volume, Floppy.VolumeHandle],       pilotMicrocode: toolData.pilotMicrocode,       diagnosticMicrocode: toolData.diagnosticMicrocode,       germ: toolData.germ,       pilotBootFile: toolData.pilotBootFile !         Floppy.Error=> ErrorHandlingProc[error];];     RemoveOptions[sw];     EXITS       exit => RETURN;    END;    END... --Main Program   LOG10-Feb-82 18:23:10  LXD  Created file.19-Oct-82 15:32:05  ET   Added a couple of MFile.Release things. 3-Apr-87 18:36:39  RSV  Added Copyright notice.  Old arrows to new arrows.  Convert to Klamath Floppy and Space interfaces.
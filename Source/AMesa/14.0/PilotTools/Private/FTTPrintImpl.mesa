-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. -- FTTPrintImpl.mesa, last edited by:   RSV on  1-May-87 15:45:25 DIRECTORY   Environment USING [wordsPerPage],   File USING [PageCount, Type],   Floppy,      FormSW USING [     AllocateItemDescriptor, ClientItemsProcType, Enumerated, EnumeratedItem,     ProcType, CommandItem, line0, line1, line2, line3, NumberItem],   FTTDefs,   Inline USING [LongNumber, LowByte, HighByte],   Put USING [Blanks, Char, CR, Line, LongNumber, Number, Text],   Tool USING [Create, Destroy, MakeFormSW, MakeSWsProc],   UserTerminal USING [BlinkDisplay],   Window USING [Box, GetBox, Handle];  FTTPrintImpl: PROGRAM  IMPORTS  FormSW, FTTDefs, Inline,  Put, Tool, UserTerminal, Window  EXPORTS FTTDefs  SHARES Floppy =  BEGIN OPEN FTTDefs;  DisplayVMOptionsWindow: PUBLIC FormSW.ProcType =    BEGIN          DVMOptionSW: Tool.MakeSWsProc =         {[] ¬ Tool.MakeFormSW[window: window, formProc: DisplayVMMakeForm]};	       box: Window.Box = Window.GetBox[wh];    toolData.DVMOptionSW ¬ Tool.Create[      name: "Display VM"L, makeSWsProc: DVMOptionSW, initialState: active,      initialBox: [[box.place.x, box.place.y - 90], [350, 90]]]    END;            DisplayVMMakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    nOptions: CARDINAL = 5;    print: ARRAY [0..2) OF Enumerated ¬      [["Characters"L, PrintCharOrNumb[PrintChars]],       ["Numbers"L, PrintCharOrNumb[PrintNumber]]];         items ¬ AllocateItemDescriptor[nOptions];    items[0] ¬ NumberItem[tag: "Relative Start"L, place: [0, line0], signed: FALSE, notNegative: TRUE,	      value: @toolData.start];    items[1] ¬ NumberItem[      tag: "Length(words)"L, place: [200, line0], signed: FALSE, notNegative: TRUE,	      value: @toolData.length];    items[2] ¬ EnumeratedItem[tag: "Print"L, place:[0, line1], feedback: all,      value: @toolData.printFromVM, choices: DESCRIPTOR[print]];    items[3] ¬ CommandItem[tag: "Abort"L, place: [280, line2], proc: RemoveDisplayOption];    items[4] ¬ CommandItem[tag: "Do it"L, place: [280, line3], proc: ApplyDisplayVM];    RETURN[items, TRUE]    END;     ApplyDisplayVM: FormSW.ProcType =    BEGIN      ENABLE        redoparams =>  BEGIN	    		 PrintErrorProc[toolData.msgSW, msg];			 GOTO exit;                       END;		           loop: CARDINAL ¬ 0;    vm: LONG POINTER ¬ LOOPHOLE[toolData.vm, LONG POINTER];          IF (toolData.length+toolData.start) > (toolData.count*Environment.wordsPerPage)      THEN SIGNAL redoparams["Asked to print beyond end of mapped VM, lower length please"L];    SELECT toolData.printFromVM FROM      PrintCharOrNumb[PrintChars] => BEGIN	vm ¬ vm + toolData.start;	FOR loop IN [0..toolData.length) DO	  Put.Char[toolData.fileSW, LOOPHOLE[Inline.HighByte[vm^], CHARACTER]];	  Put.Text[toolData.fileSW, ", "L];	  Put.Char[toolData.fileSW, LOOPHOLE[Inline.LowByte[vm^], CHARACTER]];	  IF loop # toolData.length - 1 THEN 	    Put.Text[toolData.fileSW, ", "L];	  vm ¬ vm + 1;	  ENDLOOP;	Put.CR[toolData.fileSW];        END;      PrintCharOrNumb[PrintNumber] => BEGIN	vm ¬ vm + toolData.start;	FOR loop IN [0..toolData.length) DO	  Put.Number[h: toolData.fileSW, n: LOOPHOLE[vm^, INTEGER], format: [10, FALSE, TRUE, 0]];	  IF loop # toolData.length - 1 THEN 	    Put.Text[toolData.fileSW, ", "L];	  vm ¬ vm + 1;	  ENDLOOP;	Put.CR[toolData.fileSW];	END;      ENDCASE;    EXITS      exit => RETURN;    END;	         RemoveDisplayOption: PUBLIC FormSW.ProcType =    BEGIN    Tool.Destroy[toolData.DVMOptionSW];    toolData.DVMOptionSW ¬ NIL;    END;                   PrintCreateFileReturns: PUBLIC PROCEDURE[fileHandle:Floppy.FileHandle]=    BEGIN    UpdateFHandle[fileHandle];    Put.Line[toolData.fileSW, "File Handle returned from CreateFile:"L];    PrintFileHandle[toolData.volumeHandle, toolData.fileID];    END;  PrintOpensReturns: PUBLIC PROCEDURE[vHandle:Floppy.VolumeHandle]=    BEGIN    vhRec: VolumeRecType;         vhRec ¬ LOOPHOLE[vHandle, VolumeRecType];    toolData.volumeHandle.lowbits ¬ vhRec.volA;    toolData.volumeHandle.highbits ¬ vhRec.volB;    Put.Text[toolData.fileSW, "    VolumeHandle[  "L];    Put.Number[toolData.fileSW, toolData.volumeHandle.lowbits, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.Text[toolData.fileSW, " , "L];    Put.Number[toolData.fileSW, toolData.volumeHandle.highbits, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.Line[toolData.fileSW, " ]"L];    END;  PrintGetFileAttributesReturns: PUBLIC PROCEDURE[size: Floppy.PageCount, filetype: File.Type]=    BEGIN    toolData.type ¬ LOOPHOLE[filetype, CARDINAL];    Put.Line[toolData.fileSW, "Size and File.Type Returned From GetFileAttributes"L];    Put.Text[toolData.fileSW, "    size= "L];    Put.LongNumber[toolData.fileSW, size, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.CR[toolData.fileSW];    Put.Text[toolData.fileSW, "    filetype= "L];    Put.Number[toolData.fileSW, toolData.type, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.CR[toolData.fileSW];    END;  PrintGetAttributesReturns: PUBLIC PROCEDURE [    labelString: LONG STRING, freeSpace: Floppy.PageCount,    largestBlock: Floppy.PageCount, fileList: Floppy.FileHandle,    rootFile: Floppy.FileHandle, density: Floppy.Density[single..double],    sides: Floppy.Sides[one..two], maxFileListEntries: CARDINAL]=    BEGIN    Put.Line[toolData.fileSW, "labelString Returned From GetAttributes"L];    Put.Text[toolData.fileSW, "    labelString= "L];    Put.Line[toolData.fileSW, labelString];    Put.Line[toolData.fileSW, "freeSpace Returned From GetAttributes"L];    Put.Text[toolData.fileSW, "    freeSpace= "L];    Put.LongNumber[toolData.fileSW, freeSpace, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.CR[toolData.fileSW];    Put.Line[toolData.fileSW, "largestBlock Returned From GetAttributes"L];    Put.Text[toolData.fileSW, "    largestBlock= "L];    Put.LongNumber[toolData.fileSW, largestBlock, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.CR[toolData.fileSW];    Put.Line[toolData.fileSW, "fileList Returned From GetAttributes"L];    PrintFileHandle[LOOPHOLE[fileList.volume, Inline.LongNumber], fileList.file];    UpdateFHandle[rootFile];    Put.Line[toolData.fileSW, "rootFile Returned From GetAttributes"L];    PrintFileHandle[toolData.volumeHandle, toolData.fileID];    Put.Text[toolData.fileSW, "    Density= "L];    Put.Line[toolData.fileSW, densitydesc[density].string];    Put.Text[toolData.fileSW, "    Sides= "L];    Put.Line[toolData.fileSW, sidesdesc[sides].string];    Put.Text[toolData.fileSW, "    maxFileListEntries= "L];    Put.Number[toolData.fileSW, maxFileListEntries, [base: 10, zerofill: FALSE,      unsigned: TRUE, columns: 0]];    END;  PrintGetNextFileReturns: PUBLIC PROCEDURE[fileH: Floppy.FileHandle]=    BEGIN    UpdateFHandle[fileH];    Put.Line[toolData.fileSW, "FileHandle Returned From GetNextFile"L];    PrintFileHandle[toolData.volumeHandle, toolData.fileID];    END;      PrintScavengeReturns: PUBLIC PROCEDURE [ok: BOOLEAN] =    BEGIN    Put.Line[toolData.fileSW, "okay Status Returned From Scavenge"L];    Put.Text[toolData.fileSW, "    okay= "L];    IF ok THEN Put.Line[toolData.fileSW, " TRUE"L]    ELSE Put.Line[toolData.fileSW, " FALSE"L];    END;      PrintGetNextBadSectorReturns: PUBLIC PROCEDURE [    newIndex: CARDINAL, file: Floppy.FileHandle, page: Floppy.PageNumber] =    BEGIN    Put.Line[toolData.fileSW, "newIndex Returned From GetNextBadSector"L];    Put.Text[toolData.fileSW, "    newIndex= "L];    Put.Number[toolData.fileSW, newIndex, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.CR[toolData.fileSW];    Put.Line[toolData.fileSW, "file Returned From GetNextBadSector"L];    UpdateFHandle[file];    PrintFileHandle[toolData.volumeHandle, toolData.fileID];    Put.Line[toolData.fileSW, "page Returned From GetNextBadSector"L];    Put.Text[toolData.fileSW, "    page= "L];    Put.LongNumber[toolData.fileSW, page, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.CR[toolData.fileSW];    END;      PrintReplaceBadSectorReturns: PUBLIC PROCEDURE[readError: BOOLEAN] =    BEGIN    Put.Line[toolData.fileSW, "readError Returned From ReplaceBadSector"L];    Put.Text[toolData.fileSW, "    readError= "L];    IF readError THEN      Put.Line[toolData.fileSW, " TRUE"L]    ELSE      Put.Line[toolData.fileSW, " FALSE"L];    END;      PrintCreateInitialReturns: PUBLIC PROCEDURE[fileHandle: Floppy.FileHandle] =    BEGIN    UpdateFHandle[fileHandle];    Put.Line[toolData.fileSW, "File Handle returned from CreateInitialMicrocode:"L];    PrintFileHandle[toolData.volumeHandle, toolData.fileID];   END;  PrintGetBootFilesReturns: PUBLIC PROCEDURE [    initialMicrocode:Floppy.BootFilePointer,    pilotMicrocode:Floppy.BootFilePointer,    diagnosticMicrocode:Floppy.BootFilePointer,    germ:Floppy.BootFilePointer, pilotBootFile:Floppy.BootFilePointer] =    BEGIN    Put.Line[toolData.fileSW, "BootFiles Returned From GetBootFiles"L];    PrintBootFile[initialMicrocode, "initialMicrocode"L];    PrintBootFile[pilotMicrocode, "pilotMicrocode"L];    PrintBootFile[diagnosticMicrocode, "diagnosticMicrocode"L];    PrintBootFile[germ, "germ"L];    PrintBootFile[pilotBootFile, "pilotBootFile"L];    END;       PrintBootFile: PROCEDURE[bootFile: Floppy.BootFilePointer, bootFileName: LONG STRING] =    BEGIN    Put.Blanks[toolData.fileSW, 6];    Put.Text[toolData.fileSW, bootFileName];    Put.Text[toolData.fileSW, ":    FileHandle[  "L];    Put.Number[toolData.fileSW, bootFile.file.a, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.Text[toolData.fileSW, "  , "L];    Put.Number[toolData.fileSW, bootFile.file.b, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.Text[toolData.fileSW, " ]"L];    Put.Text[toolData.fileSW, "     page: "L];    Put.LongNumber[toolData.fileSW, bootFile.page, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.CR[toolData.fileSW];    END;      PrintFileSizeProc: PUBLIC PROCEDURE[place: Window.Handle, fileSize: File.PageCount] =    BEGIN    Put.Line[place, "Size of pilotFile returned from a Directory.Lookup in GetAFile"L];    Put.Text[place, "pilotFile size: "L];    Put.LongNumber[place, fileSize, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.CR[place];    END;     PrintErrorProc: PUBLIC PROCEDURE[place: Window.Handle, msg: LONG STRING] =    {UserTerminal.BlinkDisplay[]; Put.Line[place, msg]};      PrintDataErrorProc: PUBLIC PROCEDURE [    place: Window.Handle, fHandle: Floppy.FileHandle,     page: Floppy.PageNumber, vm: LONG POINTER] =    BEGIN    UserTerminal.BlinkDisplay[];    UpdateFHandle[fHandle];    PrintFileHandle[toolData.volumeHandle, toolData.fileID];    Put.Text[place, "    page= "L];    Put.LongNumber[place, page, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.CR[place];    Put.Text[place, "    vm= "L];    Put.LongNumber[place, LOOPHOLE[vm, LONG CARDINAL], [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.CR[place];    END;      UpdateFHandle: PROCEDURE [fileHandle: Floppy.FileHandle] =    BEGIN    fileH : FileRecType;         fileH ¬ LOOPHOLE[fileHandle, FileRecType];    toolData.volumeHandle.lowbits ¬ fileH.volWA;    toolData.volumeHandle.highbits ¬ fileH.volWB;    toolData.fileID.a ¬ fileH.fIDa;    toolData.fileID.b ¬ fileH.fIDb;    END;     PrintFileHandle: PROCEDURE [   volumeHandle: Inline.LongNumber, fileID:Floppy.FileID] =   BEGIN   Put.Text[toolData.fileSW, "    VolumeHandle[  "L];   Put.Number[toolData.fileSW, volumeHandle.lowbits, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];   Put.Text[toolData.fileSW, " , "L];   Put.Number[toolData.fileSW, volumeHandle.highbits, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];   Put.Line[toolData.fileSW, " ]"L];   Put.Text[toolData.fileSW, "    FileHandle[  "L];   Put.Number[toolData.fileSW, fileID.a, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];   Put.Text[toolData.fileSW, "  , "L];   Put.Number[toolData.fileSW, fileID.b, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];   Put.Line[toolData.fileSW, " ]"L];   END;    PrintGetImageAttributesReturns: PUBLIC PROCEDURE [   maxNumberOfFiles: CARDINAL, currentNumberOfFiles: CARDINAL,    density: Floppy.Density, sides: Floppy.Sides] =   BEGIN   Put.Line[toolData.fileSW, "GetImageAttributes returns "L];   Put.Text[toolData.fileSW, "  maxNumberOfFiles = "L];   Put.Number[toolData.fileSW, maxNumberOfFiles, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];   Put.CR[toolData.fileSW];   Put.Text[toolData.fileSW, "  currentNumberOfFiles = "L];   Put.Number[toolData.fileSW, currentNumberOfFiles, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];   Put.CR[toolData.fileSW];   Put.Text[toolData.fileSW, "  density = "L];   SELECT density FROM     single => Put.Text[toolData.fileSW, "Single"L];     double => Put.Text[toolData.fileSW, "Double"L];     ENDCASE;   Put.CR[toolData.fileSW];   Put.Text[toolData.fileSW, "  sides = "L];   SELECT sides FROM     one => Put.Text[toolData.fileSW, "One"L];     two => Put.Text[toolData.fileSW, "Two"L];     ENDCASE;   Put.CR[toolData.fileSW];   END;     PrintPagesForImageReturns: PUBLIC PROCEDURE[pages: Floppy.PageNumber] =    BEGIN    Put.Line[toolData.fileSW, "PagesForImage returns "L];    Put.Text[toolData.fileSW, "  pages = "L];    Put.LongNumber[toolData.fileSW, pages, [base:10, zerofill:FALSE, unsigned:TRUE, columns:0]];    Put.CR[toolData.fileSW];    END;       ClearmsgSW: PUBLIC PROCEDURE = {Put.CR[toolData.msgSW]};      END... -- main codeLOG19-Nov-81 17:13:20  LXD  created file.25-Oct-82 10:47:24  ET   various changes.27-Mar-87 12:19:57  RSV  Added copyright notice.  Old arrows to new arrows.  Folded in ET's changes.  Move onto current Window interface. 1-May-87 15:45:34  RSV  Changed PrintScavengeReturns for status returned from FloppyExtras.NewScavenge.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- TomDImpl.mesa  (last edited by Jonathan JXG     15-Mar-83 11:19:22)-- This module maintains the list of registered displays,-- exporting its routines to the TomD and TomInternal interfaces.  -- The TomD.Register routine will be used by those wishing to register -- display routines;  all other routines (in TomOps) will be used by -- the Tom tool to interrogate the listDIRECTORY  String USING [Compare, CopyToNewString, Empty, Equivalent],  TomD,  TomOps,  Window USING [Handle];  TomDImpl:   MONITOR   IMPORTS String, TomOps  EXPORTS TomD, TomOps =  BEGIN OPEN TomOps;    		    DisplayErr: PUBLIC SIGNAL[reason:TomOps.DisplayErrReason, name:LONG STRING] = CODE;  DisplayHandle: TYPE = LONG POINTER TO DisplayObject;  DisplayObject:    PUBLIC TYPE = RECORD -- it is hidden in the interface as simply TYPE      [name:LONG STRING, next:DisplayHandle,       setDisplayProc:TomD.SetDisplayProcType,         updateDisplayProc:TomD.UpdateDisplayProcType];  	       displayChain: DisplayHandle ¬ NIL;     -- the Register routine ...               Register:     PUBLIC ENTRY PROCEDURE       [name:LONG STRING, setDisplayProc:TomD.SetDisplayProcType,        updateDisplayProc:TomD.UpdateDisplayProcType]     RETURNS [ok:BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    p:LONG POINTER TO DisplayHandle ¬ @displayChain;    UNTIL p­=NIL OR String.Compare[p­.name, name, TRUE]>0 DO p ¬ @p­.next ENDLOOP;    IF p­#NIL AND String.Equivalent[p­.name, name] THEN RETURN [FALSE];    p­ ¬       z.NEW[DisplayObject ¬               [name:name, next:p­,	       setDisplayProc:setDisplayProc, 	       updateDisplayProc:updateDisplayProc]];    RETURN [TRUE];    END;           -- interrogation routines ...      GetDisplayNames: PUBLIC ENTRY PROCEDURE []     RETURNS [names:TomOps.Names, freeNamesProc:TomOps.FreeNamesProcType] =    BEGIN    ENABLE UNWIND => NULL;    n:CARDINAL; seq:SeqOfStringsP;    n ¬ 0;    FOR display:DisplayHandle ¬ displayChain, display.next UNTIL display=NIL       DO n ¬ n+1 ENDLOOP;    seq ¬ z.NEW[SeqOfStrings[MAX[1,n]]];    IF n=0    THEN {seq[0] ¬ Copy["none!"];  n ¬ 1 }    ELSE      {m:CARDINAL ¬ 0;       FOR display:DisplayHandle ¬ displayChain, display.next UNTIL display=NIL         DO seq[m] ¬ String.CopyToNewString[display.name, z];  m ¬ m+1  ENDLOOP};    RETURN [ArrayFromSequence[seq, n], FreeNames];    END;      GetDisplay: PUBLIC ENTRY PROCEDURE [name:LONG STRING]     RETURNS [display:DisplayHandle] =     BEGIN    ENABLE UNWIND => NULL;    IF String.Empty[name] THEN RETURN WITH ERROR DisplayErr[noDisplayGiven, NIL];        FOR display ¬ displayChain, display.next UNTIL display=NIL    DO IF String.Equivalent[display.name, name] THEN RETURN ENDLOOP;      		     RETURN WITH ERROR DisplayErr[displayNotFound, name]	       END;       Display:     PUBLIC PROCEDURE       [display:DisplayHandle, items:TomD.Items, clientHandle:LONG POINTER,        msgSW, parent, insertBeforeThis:Window.Handle]    RETURNS [newClientHandle:LONG POINTER] =    {newClientHandle ¬       display.setDisplayProc[clientHandle, msgSW, parent, insertBeforeThis, items]};      UpdateDisplay: PUBLIC PROCEDURE [display:DisplayHandle, clientHandle:LONG POINTER] =    {display.updateDisplayProc[clientHandle]};  Copy: PROCEDURE[s:LONG STRING] RETURNS [LONG STRING] = INLINE     {RETURN[String.CopyToNewString[s, z]]};	      END...
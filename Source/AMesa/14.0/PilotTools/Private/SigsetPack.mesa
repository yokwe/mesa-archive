-- Copyright (C) 1983, 1987  by Xerox Corporation. All rights reserved. -- SigsetPack.mesa    last edited by: ET         21-Apr-87 18:40:12-- Test software for Pilot.-- Sigset defines a large enumerated type "Sig", that names all of the signal situations that may arise when calling a public Pilot procedure.  This includes names for all of Pilot's public signals, plus "none" and "other".  In addition, SigsetDefs defines the object "Sigset".  Objects of type Sigset represent subsets of the set of all Sig's.DIRECTORY  File USING [ErrorType],  Heap USING [ErrorType, systemZone],  PhysicalVolume USING [ErrorType],  Runtime USING [ConfigErrorType],  Scavenger USING [ErrorType],  SigsetAuxDefs,  SigsetDefs,  Space USING [ErrorType],  String USING [AppendString, StringBoundsFault],  Volume USING [ErrorType, RootDirectoryErrorType];SigsetPack: PROGRAM  IMPORTS Heap, String  EXPORTS SigsetAuxDefs, SigsetDefs  SHARES SigsetDefs =BEGIN OPEN SigsetDefs;------------------------------------------ Global types, constants, and variables  -- stringFromSig maps the enumeration Sig into printable strings.  -- After the mainline initialization, this array is effectively constant.  --> NOTE:  Perhaps this array shouldn't be kept in the global frame.stringFromSig: ARRAY Sig OF LONG STRING ¬ ALL[NIL]; -- re-init in main line codezone: UNCOUNTED ZONE = Heap.systemZone;------------------------------------------ Public procedures:  Manipulate Sig values-- The following procedures do the obvious translation of enumerated-type-- values.  They check for argument out of range.SigFromFileErrorType: PUBLIC PROCEDURE [errorType: File.ErrorType]    RETURNS [Sig] =  BEGIN  RETURN[SELECT errorType FROM           invalidParameters => fileInvalidParameters,           reservedType => fileReservedType,           ENDCASE => fileUndefined]  END;SigFromHeapErrorType: PUBLIC PROCEDURE [errorType: Heap.ErrorType]    RETURNS [Sig] =  BEGIN  RETURN[SELECT errorType FROM           insufficientSpace => heapInsufficientSpace,           invalidHeap => heapInvalidHeap,           invalidNode => heapInvalidNode,           invalidZone => heapInvalidZone,           invalidOwner => heapInvalidOwner,           otherError => heapOtherError,           invalidSize => heapInvalidSize,           invalidParameters => heapInvalidParameters,           maxSizeExceeded => heapMaxSizeExceeded,           ENDCASE => heapUndefined]  END;SigFromPhysicalVolumeErrorType: PUBLIC PROCEDURE    [errorType: PhysicalVolume.ErrorType] RETURNS [Sig] =  BEGIN  RETURN[SELECT errorType FROM    badDisk => physicalVolumeBadDisk,    badSpotTableFull => physicalVolumeBadSpotTableFull,    containsOpenVolumes => physicalVolumeContainsOpenVolumes,    diskReadError => physicalVolumeDiskReadError,    hardwareError => physicalVolumeHardwareError,    hasPilotVolume => physicalVolumeHasPilotVolume,    alreadyAsserted => physicalVolumeAlreadyAsserted,    insufficientSpace => physicalVolumeInsufficientSpace,    invalidHandle => physicalVolumeInvalidHandle,    nameRequired => physicalVolumeNameRequired,    notReady => physicalVolumeNotReady,    noSuchDrive => physicalVolumeNoSuchDrive,    noSuchLogicalVolume => physicalVolumeNoSuchLogicalVolume,    physicalVolumeUnknown => physicalVolumePhysicalVolumeUnknown,    writeProtected => physicalVolumeWriteProtected,    wrongFormat => physicalVolumeWrongFormat,    ENDCASE => physicalVolumeUndefined]  END;SigFromRuntimeConfigErrorType: PUBLIC PROCEDURE    [configErrorType: Runtime.ConfigErrorType] RETURNS [Sig] =  BEGIN  RETURN[SELECT configErrorType FROM           badCode => runtimeConfigErrorBadCode,           exportedTypeClash => runtimeConfigErrorExportedTypeClash,           invalidConfig => runtimeConfigErrorInvalidConfig,           missingCode => runtimeConfigErrorMissingCode,           unknown => runtimeConfigErrorUnknown,           ENDCASE => runtimeConfigErrorUndefined]  END;SigFromScavengerErrorType: PUBLIC PROCEDURE [errorType: Scavenger.ErrorType]    RETURNS [Sig] =  BEGIN  RETURN[SELECT errorType FROM           cannotWriteLog => scavengerCannotWriteLog,           noSuchPage => scavengerNoSuchPage,           orphanNotFound => scavengerOrphanNotFound,           volumeOpen => scavengerVolumeOpen,           diskHardwareError => scavengerDiskHardwareError,           diskNotReady => scavengerDiskNotReady,           needsRiskyRepair => scavengerNeedsRiskyRepair,           ENDCASE => scavengerUndefined]  END;SigFromSpaceErrorType: PUBLIC PROCEDURE [errorType: Space.ErrorType]    RETURNS [Sig] =  BEGIN  RETURN[SELECT errorType FROM           alreadyAllocated => spaceAlreadyAllocated,	   alreadyDeallocated => spaceAlreadyDeallocated,	   incompleteSwapUnits => spaceIncompleteSwapUnits,	   invalidParameters => spaceInvalidParameters,	   invalidProcedure => spaceInvalidProcedure,	   invalidSwapUnitSize => spaceInvalidSwapUnitSize,	   invalidWindow => spaceInvalidWindow,	   stillMapped => spaceStillMapped,	   notAllocated => spaceNotAllocated,	   notMapped => spaceNotMapped,	   noWindow => spaceNoWindow,	   pointerPastEndOfMemory => spacePointerPastEndOfMemory,           readOnly => spaceReadOnly,           ENDCASE => spaceUndefined]  END;SigFromVolumeErrorType: PUBLIC PROCEDURE [errorType: Volume.ErrorType]    RETURNS [Sig] =  BEGIN  RETURN[SELECT errorType FROM           nameRequired => volumeNameRequired,           pageCountTooSmallForVolume => volumePageCountTooSmallForVolume,           subvolumeHasTooManyBadPages => volumeSubvolumeHasTooManyBadPages,           tooManySubvolumes => volumeTooManySubvolumes,           ENDCASE => volumeUndefined]  END;SigFromVolumeRootDirectoryErrorType: PUBLIC PROCEDURE [  errorType: Volume.RootDirectoryErrorType]    RETURNS [Sig] =  BEGIN  RETURN[SELECT errorType FROM           directoryFull => volumeRootDirectoryDirectoryFull,           duplicateRootFile => volumeRootDirectoryDuplicateRootFile,           invalidRootFileType => volumeRootDirectoryInvalidRootFileType,           rootFileUnknown => volumeRootDirectoryRootFileUnknown,           ENDCASE => volumeRootDirectoryUndefined]  END;  -- StringFromSig returns a (globally allocated) string with a printable  -- representation of Sig 'm'.StringFromSig: PUBLIC PROCEDURE [s: Sig] RETURNS [LONG STRING] =  BEGIN  IF s NOT IN Sig THEN    ERROR Error[invalidArgument, "Sig argument out of range in SigsetPack"L];  RETURN[stringFromSig[s]];  END;------------------------------------------ Public procedures:  Manage Sigset objects-- Sigset objects represent sets of Sig values, i.e., subsets of the set of all Sig's.  Every Sig value is either in the set or not;  this includes the value "none".  Note that {none} is different from the empty set {}.  The purpose of a Sigset object is to inform Try of the possible signal situations (each represented by a Sig value) that are acceptable, i.e., the set of alternative expected situations.-- A Sigset object is mutable, that is, it's contents may be changed.  -- AddDefiniteError adds a "definite error" to a set of error Sig's.  A  -- "definite error" is one that should definitely arise, unless a different  -- error arises (first).  Therefore, AddDefiniteError makes sure that "none"  -- is not a possibility (that is, it removes "none" from the Sigset), and it  -- inserts the new error Sig.  AddDefiniteError signals  -- Error[noneConstruedAsAnError] if the error argument is "none".AddDefiniteError: PUBLIC PROCEDURE [errorSet: Sigset, error: Sig] =  BEGIN  IF error = none THEN ERROR Error[noneConstruedAsAnError,    "the Sig ""none"" was used as if it represented an error"L];  Insert[errorSet, error];  Remove[errorSet, none];  RETURN;  END;  -- AddNonRecoverable adds "nonRecoverable" to an error set if "none" is in  -- the set.  This is for the cases where the operation in question would be  -- non-recoverable IFF it doesn't raise a signal.AddNonRecoverable: PUBLIC PROCEDURE [errorSet: Sigset] =  BEGIN  IF errorSet[none]    THEN {Insert[errorSet, nonRecoverable]; Remove[errorSet, none]};  RETURN;  END;  -- AddPotentialError adds a "potential error" to a set of error Sig's.  A  -- "potential error" is one that we don't have enough information to predict  -- for sure;  it could happen, but it's ok if no errors happen.  Therefore,  -- AddPotentialError merely inserts the new error Sig.  AddPotentialError  -- signals Error[noneConstruedAsAnError] if the error argument is "none".  --"Potential errors" (as opposed to "definite errors" and singleton sigsets)  -- arise from limitations in the model.AddPotentialError: PUBLIC PROCEDURE [errorSet: Sigset, error: Sig] =  BEGIN  IF error = none THEN ERROR Error[noneConstruedAsAnError,    "the Sig ""none"" was used as if it represented an error"L];  Insert[errorSet, error];  RETURN;  END;  -- Create allocates and returns a new, empty Sigset object.Create: PUBLIC PROCEDURE RETURNS [new: Sigset] =  {new ¬ zone.NEW[Aqsigset ¬ ALL[FALSE]]; RETURN};  -- Destroy destroys a Sigset object and releases its storage.Destroy: PUBLIC PROCEDURE [set: Sigset] =  {Empty[set]; zone.FREE[@set]; RETURN};  -- Empty performs:  set ¬ {}.Empty: PUBLIC PROCEDURE [set: Sigset] =  {set­ ¬ ALL[FALSE]; RETURN};  -- InitToNone performs:  set ¬ {none}, which is quite different from Empty!InitToNone: PUBLIC PROCEDURE [set: Sigset] =  {Empty[set]; Insert[set, none]; RETURN};  -- Insert performs:  set ¬ UNION[set, {insert}].Insert: PUBLIC PROCEDURE [set: Sigset, insert: Sig] =  {set[insert] ¬ TRUE; RETURN};  -- IsIn finds out if a Sig is an element of a given Sigset.IsIn: PUBLIC PROCEDURE [set: Sigset, item: Sig] RETURNS [BOOLEAN] =  {RETURN[set[item]]};  -- Monad makes a monadic Sigset.Monad: PUBLIC PROCEDURE [set: Sigset, item: Sig] =  {Empty[set]; Insert[set, item]; RETURN};  -- Remove performs:  set ¬ INTERSECTION[set, COMPLEMENT[{remove}]],  -- where COMPLEMENT is the complement of a set with respect to the set of  -- all Sig's.Remove: PUBLIC PROCEDURE [set: Sigset, remove: Sig] =  {set[remove] ¬ FALSE; RETURN};  -- StringFromSigset generates a string representation of a Sigset.StringFromSigset: PUBLIC PROCEDURE [set: Sigset, buffer: LONG STRING] =  BEGIN  myWriteProc: PROCEDURE [newPiece: LONG STRING] =    {String.AppendString[buffer, newPiece]};  buffer.length ¬ 0;  WriteSigset[set, myWriteProc    ! String.StringBoundsFault => ERROR Error[stringOverflow,          "string overflow in SigsetPack.StringFromSigset"L]];  RETURN;  END;  -- WriteSigset will write out a Sigset by calling "writeProc" successively  -- with each of the string parts needed to build a representation of "set".WriteSigset: PUBLIC PROCEDURE [set: Sigset, writeProc: PROCEDURE [LONG STRING]] =  BEGIN  signal: Sig;  atLeastOneAlready: BOOLEAN ¬ FALSE; -- to control separators  writeProc["{"L];  FOR signal IN Sig    DO    IF set[signal] THEN      BEGIN      IF atLeastOneAlready THEN writeProc[", "L];      atLeastOneAlready ¬ TRUE;      writeProc[stringFromSig[signal]];      END;    ENDLOOP;  writeProc["}"L];  RETURN;  END;------------------------------------------ Public errors and signals  -- General purpose error.Error: PUBLIC ERROR [errortype: Errortype, msg: STRING] = CODE;------------------------------------------ Main line code  -- This code initializes the mapping array stringFromSig.stringFromSig ¬ [  none:	"no signals",  byteBltStartIndexGreaterThanStopIndexPlusOne:	"ByteBlt.StartIndexGreaterThanStopIndexPlusOne",  fileInvalidParameters:	"File.Error[invalidParameters]",  fileReservedType:	"File.Error[reservedType]",  fileUndefined:	"File.Error[?? type NOT IN File.ErrorType ??]",  fileMissingPages:	"File.MissingPages",  fileUnknown:		"File.Unknown",  heapInsufficientSpace:	"Heap.Error[insufficientSpace]",  heapInvalidHeap:	"Heap.Error[invalidHeap]",  heapInvalidNode:	"Heap.Error[invalidNode]",  heapInvalidZone:	"Heap.Error[invalidZone]",  heapInvalidOwner:	"Heap.Error[invalidOwner]",  heapOtherError:	"Heap.Error[otherError]",  heapInvalidSize:	"Heap.Error[invalidSize]",  heapInvalidParameters:	"Heap.Error[invalidParameters]",  heapMaxSizeExceeded:	"Heap.Error[maxSizeExceeded]",  heapUndefined:	"Heap.Error[?? type NOT IN Heap.ErrorType ??]",  physicalVolumeBadDisk:	"PhysicalVolume.Error[badDisk]",  physicalVolumeBadSpotTableFull:	"PhysicalVolume.Error[badSpotTableFull]",  physicalVolumeContainsOpenVolumes:	"PhysicalVolume.Error[containsOpenVolumes]",  physicalVolumeDiskReadError:	"PhysicalVolume.Error[diskReadError]",  physicalVolumeHardwareError:	"PhysicalVolume.Error[hardwareError]",  physicalVolumeHasPilotVolume:	"PhysicalVolume.Error[hasPilotVolume]",  physicalVolumeAlreadyAsserted:	"PhysicalVolume.Error[alreadyAsserted]",  physicalVolumeInsufficientSpace:	"PhysicalVolume.Error[insufficientSpace]",  physicalVolumeInvalidHandle:	"PhysicalVolume.Error[invalidHandle]",  physicalVolumeNameRequired:	"PhysicalVolume.Error[nameRequired]",  physicalVolumeNotReady:	"PhysicalVolume.Error[notReady]",  physicalVolumeNoSuchDrive:	"PhysicalVolume.Error[noSuchDrive]",  physicalVolumeNoSuchLogicalVolume:	"PhysicalVolume.Error[noSuchLogicalVolume]",  physicalVolumePhysicalVolumeUnknown:	"PhysicalVolume.Error[physicalVolumeUnknown]",  physicalVolumeWriteProtected:	"PhysicalVolume.Error[writeProtected]",  physicalVolumeWrongFormat:	"PhysicalVolume.Error[wrongFormat]",  physicalVolumeUndefined:	"PhysicalVolume.Error[?? error NOT IN PhysicalVolume.ErrorType ??]",  physicalVolumeNeedsScavenging:	"PhysicalVolume.NeedsScavenging",  processInvalidProcess:	"Process.InvalidProcess",  processTooManyProcesses:	"Process.TooManyProcesses",  runtimeVersionMismatch:	"Runtime.VersionMismatch",  runtimeInvalidGlobalFrame:	"Runtime.InvalidGlobalFrame",  runtimeInvalidFrame:	"Runtime.InvalidFrame",  runtimeBoundsFault:	"Runtime.BoundsFault",  runtimeConfigErrorBadCode:	"Runtime.ConfigError[badCode]",  runtimeConfigErrorExportedTypeClash:	"Runtime.ConfigError[exportedTypeClash]",  runtimeConfigErrorInvalidConfig:	"Runtime.ConfigError[invalidConfig]",  runtimeConfigErrorMissingCode:	"Runtime.ConfigError[missingCode]",  runtimeConfigErrorUnknown:	"Runtime.ConfigError[unknown]",  runtimeConfigErrorUndefined:	"Runtime.ConfigError[?? type NOT IN Runtime.ConfigErrorType ??]",  runtimeControlFault:	"Runtime.ControlFault",  runtimeDivideCheck:	"Runtime.DivideCheck",  runtimeLinkageFault:	"Runtime.LinkageFault",  runtimeNarrowFault:	"Runtime.NarrowFault",  runtimePointerFault:	"Runtime.PointerFault",  runtimePortFault:	"Runtime.PortFault",  runtimeStartFault:	"Runtime.StartFault",  runtimeUnboundProcedure:	"Runtime.UnboundProcedure",  runtimeZeroDivisor:	"Runtime.ZeroDivisor",  scavengerCannotWriteLog:	"Scavenger.Error[cannotWriteLog]",  scavengerNoSuchPage:	"Scavenger.Error[noSuchPage]",  scavengerOrphanNotFound:	"Scavenger.Error[orphanNotFound]",  scavengerVolumeOpen:	"Scavenger.Error[volumeOpen]",  scavengerDiskHardwareError:	"Scavenger.Error[diskHardwareError]",  scavengerDiskNotReady:	"Scavenger.Error[diskNotReady]",  scavengerNeedsRiskyRepair:	"Scavenger.Error[needsRiskyRepair]",  scavengerUndefined:	"Scavenger.Error[?? error NOT IN Scavenger.ErrorType ??]",  spaceAlreadyAllocated:	"Space.Error[alreadyAllocated]",  spaceAlreadyDeallocated:	"Space.Error[alreadyDeallocated]",  spaceIncompleteSwapUnits:	"Space.Error[incompleteSwapUnits]",  spaceInvalidParameters:	"Space.Error[invalidParameters]",  spaceInvalidProcedure:	"Space.Error[invalidProcedure]",  spaceInvalidSwapUnitSize:	"Space.Error[invalidSwapUnitSize]",  spaceInvalidWindow:	"Space.Error[invalidWindow]",  spaceStillMapped:	"Space.Error[stillMapped]",  spaceNotAllocated:	"Space.Error[notAllocated]",  spaceNotMapped:	"Space.Error[notMapped]",  spaceNoWindow:	"Space.Error[noWindow]",  spacePointerPastEndOfMemory:	"Space.Error[pointerPastEndOfMemory]",  spaceReadOnly:	"Space.Error[readOnly]",  spaceUndefined:	"Space.Error[?? type NOT IN Space.ErrorType ??]",  spaceInsufficientSpace:	"Space.InsufficientSpace",  spaceIOError:		"Space.IOError",  streamAttention:	"Stream.Attention",  streamEndOfStream:	"Stream.EndOfStream",  streamLongBlock:	"Stream.LongBlock",  streamShortBlock:	"Stream.ShortBlock",  streamSSTChange:	"Stream.SSTChange",  streamTimeOut:	"Stream.TimeOut",  streamInvalidOperation:	"Stream.InvalidOperation",  temporaryBootingInvalidParameters:	"TemporaryBooting.InvalidParameters",  temporaryBootingInvalidVersion:	"TemporaryBooting.InvalidVersion",  userTerminalBitmapIsDisconnected:	"UserTerminal.BitmapIsDisconnected",  volumeNameRequired:		"Volume.Error[nameRequired]",  volumePageCountTooSmallForVolume:  		"Volume.Error[pageCountTooSmallForVolume]",  volumeSubvolumeHasTooManyBadPages:  		"Volume.Error[subvolumeHasTooManyBadPages]",  volumeTooManySubvolumes:	"Volume.Error[tooManySubvolumes]",  volumeUndefined:	"Volume.Error[?? type NOT IN Space.ErrorType ??]",  volumeRootDirectoryDirectoryFull:  		"Volume.RootDirectoryError[directoryFull]",  volumeRootDirectoryDuplicateRootFile:  		"Volume.RootDirectoryError[duplicateRootFile]",  volumeRootDirectoryInvalidRootFileType:  		"Volume.RootDirectoryError[invalidRootFileType]",  volumeRootDirectoryRootFileUnknown:  		"Volume.RootDirectoryError[rootFileUnknown]",  volumeRootDirectoryUndefined:	"Volume.RootDirectoryError[?? type NOT IN Volume.RootDirectoryErrorType ??]",  volumeInsufficientSpace:	"Volume.InsufficientSpace",  volumeNeedsScavenging:	"Volume.NeedsScavenging",  volumeNotOnline:	"Volume.NotOnline",  volumeNotOpen:	"Volume.NotOpen",  volumeReadOnly:	"Volume.ReadOnly",  volumeUnknown:	"Volume.Unknown",  other:		"a non Pilot-specific signal (ANY)",  nonRecoverable:	"a non-recoverable problem"];END.LOG OF SIGNIFICANT CHANGESDate: August 3, 1979, By: JHM, Action: Created file by removing this stuff  from TryPack.Date: December 6, 1979, By: JHM, Action: Added "nonRecoverable" to Sig, for  error situations that we can't recover from, e.g., AddressFault.Date: February 12, 1980, By: JHM, Action: Update for Amargosa.Date: August 12, 1980, By: SEH, Action: Update for Mokolumne RS232C*, and  Socket only.Date: August 20, 1980, By: JHM, Action: Update for Mokolumne, Mesa 6, and  new version of Storage.Date: September 29, 1980, By: JHM, Action: Made Sigset LONG.  Made  StringFromSigset's "buffer" arg LONG.Date: February 19, 1981, By: JHM, Action: Minimal update for Rubicon.  Switched from Storage to system heap, so PilotAuxDefs.Shorten is not needed.Date: March 9, 1981, By: JHM, Action: Full update for Rubicon--Removed Socket  (now a private interface) & NetworkStream & RS232C* (communications interfaces,  not Pilot;  and they change too much!);  added 2 new Scavenger error codes.Date: 13-Jan-83 15:22:29, By: CAJ , Action: Update for Klamath.Date: 19-Aug-83 17:17:11, By: AWL      , Action: runtimeNoGlobalFrameSlots dead; runtimeNarrowFault is new.Date: 21-Apr-87 18:40:23, By: ET      , Action: Pilot 14.0 changes.
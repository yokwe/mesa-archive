-- Copyright (C) 1982, 1987  by Xerox Corporation. All rights reserved. -- MakePilotMP.mesa - last edit by: RSV, 27-Mar-87 14:49:20-- This Tajo-based tool generates PilotMP.mesa, the MP codes definition file,-- using a report generated from the Adobe database for Dandelion MP codes.DIRECTORY  Ascii USING [NUL],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Enumerated, EnumeratedItem, line0, line1, line2, line3,    NopEnumeratedNotifyProc, NopNotifyProc, ProcType, StringItem],  Heap USING [systemZone],  MFile USING [Acquire, Delete, Error, Handle, maxNameLength,    Release, SetAccess, SetLength, WriteOnly],  MStream USING [Create, Error, Handle],  Put USING [CR, Decimal, Line, Text],  Runtime USING [GetBcdTime],  Stream USING [Delete, EndOfStream, PutChar],  String USING [AppendString],  StringLookUp USING [InTable],  Time USING [Append, AppendCurrent, Packed, Unpack],  Token USING [AlphaNumeric, Filtered, FilterProcType, FreeTokenString,    GetCharProcType, Item, Line, Numeric, Object, StandardFilterState],  Tool USING [Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [TransitionProcType],  Window USING [Handle];  MakePilotMP: PROGRAM   IMPORTS    FormSW, Heap, MFile, MStream, Put, Runtime, Stream, String, StringLookUp,    Time, Token, Tool =      BEGIN    -- TYPEs    ErrorChoice: TYPE = {skip, abort};    DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    msgSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    overwrite: BOOLEAN,    fill1: UNSPECIFIED ¬ 0,    onError: ErrorChoice,    fill2: UNSPECIFIED ¬ 0,    inputFilename: LONG STRING,    outputFilename: LONG STRING];      ProblemType: TYPE = {inputAccessFailure, inputStreamFailure, noSuchFile,    outputAccessFailure, outputStreamFailure, overwriteAttempt};  State: TYPE = {aborted, done, null, inProgress};    StringData: TYPE = RECORD [    labelBody: StringBody,    labelBodyText: PACKED ARRAY [0..6) OF CHARACTER,    codeBody: StringBody,    codeBodyText: PACKED ARRAY [0..7) OF CHARACTER,    commentBody: StringBody,    commentBodyText: PACKED ARRAY [0..8) OF CHARACTER,    doneBody: StringBody,    doneBodyText: PACKED ARRAY [0..5) OF CHARACTER,    inputFileBody: StringBody,    inputFileBodyText: PACKED ARRAY [0..MFile.maxNameLength) OF CHARACTER,    outputFileBody: StringBody,    outputFileBodyText: PACKED ARRAY [0..MFile.maxNameLength) OF CHARACTER];          -- Constants  -- The following are logically an enumerated TYPE  label: CARDINAL = 0;  code: CARDINAL = 1;  comment: CARDINAL = 2;  done: CARDINAL = 3;  -- Variable declarations    data: DataHandle ¬ NIL;  errors: CARDINAL;  fieldIDTable: ARRAY [label..done] OF LONG STRING ¬ [NIL,NIL,NIL,NIL];  fieldArg: ARRAY [label..comment] OF LONG STRING ¬ [NIL,NIL,NIL];  state: State;  stringData: LONG POINTER TO StringData ¬ NIL;    z: UNCOUNTED ZONE = Heap.systemZone;  -- Procedures    DoIt: FormSW.ProcType =    BEGIN    inF: MFile.Handle;    inH: MStream.Handle;    outF: MFile.Handle;    outH: MStream.Handle;    there: BOOLEAN ¬ TRUE;        Problem: PROC [type: ProblemType, file: LONG STRING] =      BEGIN      Put.Text[data.msgSW,        SELECT type FROM	  noSuchFile => "No such file: "L,	  inputAccessFailure, outputAccessFailure => "Cannot access file: "L,	              inputStreamFailure, outputStreamFailure =>"Problem opening stream on: "L,	  overwriteAttempt => "Attempt to overwrite file: "L,	  ENDCASE => "Unknown problem"L];      Put.Line[data.msgSW, file];      END;        state ¬ inProgress;    BEGIN    inF ¬ MFile.Acquire[data.inputFilename, readOnly, []      ! MFile.Error => {Problem[IF code = noSuchFile THEN noSuchFile        ELSE inputAccessFailure, data.inputFilename]; GOTO stopNow}];    outF ¬ MFile.Acquire[data.outputFilename, anchor, []      ! MFile.Error =>        IF code = noSuchFile THEN {there ¬ FALSE; CONTINUE}        ELSE {Problem[outputAccessFailure, data.outputFilename];	  MFile.Release[inF]; GOTO stopNow}];    IF there THEN      BEGIN      IF data.overwrite        THEN {MFile.SetAccess[outF, writeOnly]; MFile.SetLength[outF, 0]}        ELSE {Problem[overwriteAttempt, data.outputFilename];	  MFile.Release[inF]; MFile.Release[outF]; GOTO stopNow};      END    ELSE outF ¬ MFile.WriteOnly[data.outputFilename, [], unknown, 0];        inH ¬ MStream.Create[file: inF, release: [],      options: [FALSE,FALSE,FALSE,FALSE,TRUE--signalEndOfStream--,FALSE]        ! MStream.Error => {Problem[inputStreamFailure, data.inputFilename];          MFile.Release[inF]; MFile.Release[outF]; GOTO stopNow}];    outH ¬ MStream.Create[file: outF, release: []        ! MStream.Error => {Problem[outputStreamFailure, data.outputFilename];	  Stream.Delete[inH]; MFile.Release[outF]; GOTO stopNow}];    Put.Text[data.fileSW, "Writing MPCodes to: "L];    Put.Text[data.fileSW, data.outputFilename];    Put.Text[data.fileSW, "  using: "L];    Put.Text[data.fileSW, data.inputFilename];    Put.Text[data.fileSW, " ... "L];    Filter[inH, outH];    IF errors > 0 THEN      {Put.CR[data.fileSW];      Put.Text[data.fileSW, "   Missing field(s) ... "L];      IF data.onError = skip THEN        {Put.Decimal[data.fileSW, errors];	Put.Text[data.fileSW, " record(s) skipped ... "L]}};    Stream.Delete[inH];    Stream.Delete[outH];    IF state = aborted THEN      {ok: BOOLEAN ¬ TRUE;      outF ¬ MFile.Acquire[data.outputFilename, delete,[]        ! MFile.Error => ok ¬ FALSE];      IF ok THEN MFile.Delete[outF]};    EXITS      stopNow => state ¬ aborted;    END;        Put.Line[data.fileSW,      IF state = aborted THEN "Aborted, no MPCodes file generated."L      ELSE "done."L];    state ¬ null;    END;      Filter: PROC [inH, outH: MStream.Handle] =    BEGIN    WriteHeader[outH];    GetRecord[inH];    WHILE state = inProgress DO      MakeSourceLine[outH];      GetRecord[inH];      ENDLOOP;    IF state ~= aborted THEN WriteTrailer[outH];    END;      GetRecord: PROCEDURE [s: MStream.Handle] =    -- The following assumptions are made about the Adobe report.    --   Any fields may be present in the report but only MPCode:, Notes:,    -- and Subject: are used.  All three must be present for a valid record.    --   The Notes: field must contain the MP code's variable name label as the    -- first token.  Anything else in the field is ignored.    --   The Subject: field must be the last of the three in the record.    --   The records in the report are already sorted in MP code order.    --   The end of the report is indicated by a record beginning with "Done.".    BEGIN    endOfRecord: BOOLEAN ¬ FALSE;    BEGIN ENABLE Stream.EndOfStream => {state ¬ done; CONTINUE};    argFilter: Token.FilterProcType;    fieldID: LONG STRING;    fieldObj: Token.Object ¬ [getChar: GetChar, break: term];    filterData: Token.StandardFilterState ¬ [':, Ascii.NUL];    i: CARDINAL;    term: CHARACTER;    GetChar: Token.GetCharProcType =      {RETURN [LOOPHOLE[s.getByte[s]]]};       UNTIL endOfRecord DO      -- get the identifying label      argFilter ¬ NIL;      fieldID ¬ Token.Item[h: @fieldObj, temporary: TRUE];      -- identify and get argument accordingly      i ¬ StringLookUp.InTable[key: fieldID, table: DESCRIPTOR[fieldIDTable],          caseFold: FALSE, noAbbreviation: TRUE];      SELECT i  FROM        label => argFilter ¬ Token.AlphaNumeric;	code => argFilter ¬ Token.Numeric;	comment => argFilter ¬ Token.Line;	done => state ¬ done;	ENDCASE => NULL; -- keep looking at words      fieldID ¬ Token.FreeTokenString[fieldID];      -- get arg to proper string      IF argFilter ~= NIL THEN fieldArg[i] ¬ Token.Filtered[        h: @fieldObj, data: @filterData, filter: argFilter];      endOfRecord ¬ (state = done) OR (i = comment);      ENDLOOP;    END;    END;  Help: FormSW.ProcType =    BEGIN    Put.Text[data.fileSW,"*** Directions for generating PilotMP.mesa ***This tool generates PilotMP.mesa, the interface defining the MP codes assigned to Pilot.  Pilot MP codes are in the range [900..1000).  The codes are taken from the Adobe database, which is considered to be the ultimate source of The Truth.  The appropriate data from the Adobe database is extracted by the ToolDriver running several Adobe tools.  Then this tool processes that report into the standard mesa definitions file."L];    Put.Text[data.fileSW,"Following are the steps in the process.  1.  The following must be present on the disk:        Adobe.bcd (or AdobeQuery, AdobeReport, and AdobeSort)	DandelionMPCodes.bcd   -- for Adobe field definition, available	                          same place as Adobe	DandelionMPCodes.user  --   (same as .bcd)	MakePilotMP.template   -- template file for AdobeReport, available	                          same place as this tool	ToolDrivers.bcd	Tool.sws               -- used by ToolDriver, available same place	                          as ToolDrivers	MakePilotMP.tds        -- script for ToolDriver, available same place	                          as this tool  2.  Set up the user.cm [Adobe] section to include the entry      'Field List File: DandelionMPCodes'.  3.  Login with an acceptable Grapevine/Librarian name and password.  4.  Run ToolDrivers.  This will bring up the ToolDriver Exec window.      Don't do anything to it yet.  5.  Run Adobe.  Deactivate all of its windows.  6.  In the ToolDrivers window, set the Script: field to      MakePilotMP.tds, then execute the Go! command.  This will cause      AdobeQuery, AdobeReport, and AdobeSort to be run in turn.  The result      is the file PilotMP.report, which is the expected input to this tool.  7.  Fill in the fields in this tool.  The Report file: field is      defaulted to PilotMP.report and the Mesa file: field to      PilotMP.mesa.  Set the On error: field to 'abort' to stop at      the first error, to 'skip' to ignore erroneous input records      and continue.  Turn on Overwrite to overwrite an existing copy      of PilotMP.mesa.  Execute DoIt! to generate the mesa file.  8.  When all is verified, delete PilotMP.unsorted, .sortkeys, and      .report."L];    END;  MakeSourceLine: PROCEDURE [h: MStream.Handle] =    BEGIN    i: CARDINAL;    BEGIN    FOR i IN [label..comment] DO      IF fieldArg[i] = NIL THEN GOTO badRecord ENDLOOP;    WriteString[h, "  "L];    WriteString[h, fieldArg[label]];    WriteString[h, ":  Code = "L];    WriteString[h, fieldArg[code]];    WriteString[h, ";  -- "L];    WriteString[h, fieldArg[comment]];    WriteString[h, ""L];    EXITS      badRecord =>         BEGIN	-- crude error handling	errors ¬ errors + 1;	IF data.onError = abort THEN state ¬ aborted;	-- print arg data?	END;    END;    FOR i IN [label..comment] DO      fieldArg[i] ¬ Token.FreeTokenString[fieldArg[i]] ENDLOOP;    END;    WriteHeader: PROCEDURE [h: MStream.Handle] =    BEGIN    time: STRING ¬ [30];    Time.AppendCurrent[s: time, zone: FALSE];    WriteString[h, "-- PilotMP.mesa,   generated: "L];    WriteString[h, time];    WriteString[h, "PilotMP: DEFINITIONS =  BEGIN  -- Maintenance Panel codes displayed by Pilot (e.g. when going to debugger  -- is not appropriate).  Note that it polite to save the old MP code and  -- restore when you are done.  -- This is the source for Pilot codes found in MPCodes.bravo.  -- This module has no interface items or records.  Do not include it  -- in any other interfaces, and then it can be recompiled at any time  -- without getting the Binder upset. (The IncludeChecker will still  -- complain though.)  Code: TYPE = [0..10000);"L];    END;    WriteString: PROCEDURE [h: MStream.Handle, s: LONG STRING] =    {FOR i: CARDINAL IN [0..s.length) DO Stream.PutChar[h, s[i]] ENDLOOP};  WriteTrailer: PROCEDURE [h: MStream.Handle] =    BEGIN    WriteString[h, "  END."L];    END;  -- Tool setup and handling  ClientTransition: ToolWindow.TransitionProcType =    -- This procedure is called whenever the system determines that this    -- Tool's state is undergoing a user invoked transition.    BEGIN    SELECT TRUE FROM      old = inactive =>	IF data = NIL THEN	  BEGIN	  data ¬ z.NEW[Data];	  stringData ¬ z.NEW[StringData];	  InitData[];	  END;      new = inactive =>	IF data # NIL THEN	  BEGIN	  z.FREE[@data];	  z.FREE[@stringData];	  fieldIDTable ¬ [NIL,NIL,NIL,NIL];	  END;      ENDCASE;    END;      Init: PROCEDURE =    BEGIN    toolName: STRING ¬ [70];    bcdTime: Time.Packed ¬ Runtime.GetBcdTime[];    String.AppendString[toolName, "Pilot MPCodes Generator of "L];    Time.Append[toolName, Time.Unpack[bcdTime]];    [] ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: toolName];    InitData[];    END;      InitData: PROCEDURE =    BEGIN        fileTemplate: STRING = [MFile.maxNameLength];    labelString: LONG STRING ¬ "Notes:"L;    codeString: LONG STRING ¬ "MPCode:"L;    commentString: LONG STRING ¬ "Subject:"L;    doneString: LONG STRING ¬ "Done."L;    inputFileString: LONG STRING ¬ "PilotMP.report"L;    outputFileString: LONG STRING ¬ "PilotMP.mesa"L;        CopyText: PROC [from: LONG STRING,        to: LONG DESCRIPTOR FOR PACKED ARRAY OF CHARACTER] =      BEGIN      FOR i: CARDINAL IN [0..from.length) DO        to[i] ¬ from[i]; ENDLOOP;      END;        state ¬ null;    errors ¬ 0;    data.overwrite ¬ TRUE;    data.onError ¬ skip;    stringData.labelBody ¬ labelString­;  -- (copies body only)    stringData.codeBody ¬ codeString­;    stringData.commentBody ¬ commentString­;    stringData.doneBody ¬ doneString­;    stringData.inputFileBody ¬ fileTemplate­;    stringData.outputFileBody ¬ fileTemplate­;    CopyText[labelString, DESCRIPTOR[stringData.labelBodyText]];    CopyText[codeString, DESCRIPTOR[stringData.codeBodyText]];    CopyText[commentString, DESCRIPTOR[stringData.commentBodyText]];    CopyText[doneString, DESCRIPTOR[stringData.doneBodyText]];    fieldIDTable[label] ¬ @stringData.labelBody;    fieldIDTable[code] ¬ @stringData.codeBody;    fieldIDTable[comment] ¬ @stringData.commentBody;    fieldIDTable[done] ¬ @stringData.doneBody;    data.inputFilename ¬ @stringData.inputFileBody;    data.outputFilename ¬ @stringData.outputFileBody;    String.AppendString[data.inputFilename, inputFileString];    String.AppendString[data.outputFilename, outputFileString];    END;    MakeForm: FormSW.ClientItemsProcType =    BEGIN    errorChoices: ARRAY [0..1] OF FormSW.Enumerated ¬      [["skip record"L, ErrorChoice[skip]], ["abort"L, ErrorChoice[abort]]];    nItems: CARDINAL = 6;    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[0] ¬ FormSW.StringItem[      tag: "Report file"L, place: [0, FormSW.line0],      string: @data.inputFilename, inHeap: TRUE];    items[1] ¬ FormSW.StringItem[      tag: "Mesa file"L, place: [0, FormSW.line1],      string: @data.outputFilename, inHeap: TRUE];    items[2] ¬ FormSW.BooleanItem[      tag: "Overwrite"L, place: [0, FormSW.line2],       switch: @data.overwrite, proc: FormSW.NopNotifyProc];    items[3] ¬ FormSW.EnumeratedItem[      tag: "On error"L, place: [100, FormSW.line2], feedback: all,       value: @data.onError, proc: FormSW.NopEnumeratedNotifyProc,      copyChoices: TRUE, choices: DESCRIPTOR[errorChoices]];    items[4] ¬ FormSW.CommandItem[      tag: "DoIt"L, place: [0, FormSW.line3], proc: DoIt];    items[5] ¬ FormSW.CommandItem[      tag: "Help"L, place: [125, FormSW.line3], proc: Help];    RETURN[items: items, freeDesc: TRUE];    END;      MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "MakePilotMP.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;        -- Mainline code    Init[];    END...  LOG16-Mar-82 17:50:30  CAJ   Action: Created file.29-Mar-82 16:20:05  CAJ   Action: Changed Help directions to use ToolDriver.27-Mar-87 14:49:20  RSV   Action: Use Heap instead of Storage.
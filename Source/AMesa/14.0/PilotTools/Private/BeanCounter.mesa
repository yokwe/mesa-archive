-- Copyright (C) 1986, 1987  by Xerox Corporation. All rights reserved.-- BeanCounter.mesa             by RSV     9-Nov-87 12:19:01<<This is a hack that enumerates the page groups (runs) on the current logical volume, and outputs statistics about it.  It does this by reading the first label of each run on the logical volume and then doing a label verify on the remainder of the run -- thus giving run size information.  It registers itself as the exec command "CountBeans.~".  It creates a data file to keep it's file statistics in, and thus requires that the logical volume it runs on have at least 60 free pages on it.  This number is derived from (maxTableEntries*SIZE[TableEntry]/wordsPerPage = 5000*3/256 pages.  Note this data file adds one to the count of temporary files on the volume.  As the labels are being read, a dot is printed out for every 100 of them.This implementation allows for 5000 total files on the logical volume it is being run on.  If there are more files than this number, then the statistics will be printed out for the allowed number of files and the program will be aborted short of the actual number of files.  (The data outputs even if incomplete to make it not a total waste of time...).  To increase this limit, increase the global maxTableEntries.  Note that you must necessarily insure the subject logical volume has additional free pages available for the increased data space...>>	DIRECTORY  DiskChannel USING [    defaultTries, DoIO, IORequest, IOStatus, Handle, Create,    GetNextDrive, nullDrive, GetDriveAttributes, Drive, goodCompletion],  Environment USING [PageCount, wordsPerPage],  Exec USING [AddCommand, EndOfCommandLine, ExecProc, FreeTokenString,    GetToken, Handle, OutputProc, RemoveCommand],  File USING [ID, Type, nullID],  Format USING [Decimal, LongDecimal, Octal, StringProc],  PhysicalVolume USING [GetContainingPhysicalVolume, ID, PageNumber],  PilotDisk USING [GetLabelFilePage, FileID, Label],  PilotFileTypes USING [tAnonymousFile, tFreePage, tVolumeFileMap, tVMBackingFile],  Space USING [Allocate, Interval, LongPointerFromPage,    PageFromLongPointer, PagesFromWords, ScratchMap, Unmap],  SpecialVolume USING [GetNextSubVolume, nullSubVolume, SubVolume],  String USING [Equivalent],  VM USING [Interval, ScratchMap],  Volume USING [GetLabelString, GetNext, ID, maxNameLength, nullID,    PageCount, Unknown];BeanCounter: PROGRAM  IMPORTS    Exec, Format, DiskChannel, PhysicalVolume,    PilotDisk, Space, SpecialVolume, String, VM, Volume =  BEGIN--*************************************---- Global variables.--*************************************--  exceededTable: BOOLEAN ¬ FALSE;    -- This is a table, indexed by fileID's.  Each fileID entry has a count  --  of the number of page groups in that file.  -- Entries that are indexed by File.nullID are unused entries.  -- SIZE[TableEntry] = 3 words.  maxTableEntries: CARDINAL = 5000;  TableEntry: TYPE = RECORD[    fileID: File.ID,    runs: CARDINAL];  table: LONG POINTER TO ARRAY [1..maxTableEntries] OF TableEntry;  lastEntry: CARDINAL ¬ 0; -- index of last entry filled in table.  TypesOfInterest: TYPE = {free, vfm, vmBacking, other};    -- Statistic variables that will be printed out.  totalNumberPages: LONG CARDINAL ¬ 0; -- on this LV.  totalNumberAllocatedPages: LONG CARDINAL ¬ 0; -- on this LV.  totalNumberFreePages: LONG CARDINAL ¬ 0; -- on this LV.  totalNumberFiles: LONG CARDINAL ¬ 0; -- on this LV.  totalNumberTemporaryFiles: LONG CARDINAL ¬ 0; -- on this LV.  totalNumberAnonymousFiles: LONG CARDINAL ¬ 0; -- on this LV.  totalNumberRuns, totalVFMNumberRuns, totalVMBNumberRuns: LONG CARDINAL ¬ 0; -- on this LV.  maxAllocatedRunSize: LONG CARDINAL ¬ 0; -- on this LV.  maxFreeRunSize: LONG CARDINAL ¬ 0; -- on this LV.  averageNumberRuns: LONG CARDINAL ¬ 0; -- per file on this LV.  maxNumberRuns: RECORD [ fileID: File.ID ¬ File.nullID,                          pages: LONG CARDINAL ¬ 0]; -- per file on this LV.  curveSize: CARDINAL = 14; -- inclusive.  CurveType: TYPE = ARRAY [1..curveSize] OF CARDINAL;  fileRunCurve: CurveType ¬ ALL[0]; -- histogram of pagegroups in files  freePGCurve: CurveType ¬ ALL[0]; -- free across entire LV.  pgCurve: CurveType ¬ ALL[0]; -- non-free across entire LV.  	-- pgCurve[ 1] = # of runs that are 1 page.	-- pgCurve[ 2] = # of runs that are 2 pages.  	-- pgCurve[ 3] = # of runs that are 3 pages.	-- pgCurve[ 4] = # of runs that are 4 pages.  	-- pgCurve[ 5] = # of runs that are 5 pages.	-- pgCurve[ 6] = # of runs that are 6 pages.  	-- pgCurve[ 7] = # of runs that are 7 pages.	-- pgCurve[ 8] = # of runs that are 8 pages.	-- pgCurve[ 9] = # of runs that are 9 pages.	-- pgCurve[10] = # of runs at least   9 but less than  20 pages.	-- pgCurve[11] = # of runs at least  20 but less than  50 pages.	-- pgCurve[12] = # of runs at least  50 but less than 200 pages.	-- pgCurve[13] = # of runs at least 200 but less than  1K pages.	-- pgCurve[14] = # of runs at least 1K pages.impossibleEndcase: PUBLIC ERROR = CODE;--*************************************---- Zero out all global data (in case the program is run twice).--*************************************--  InitializeGlobals: PROCEDURE =    BEGIN    table ¬ Space.ScratchMap[      Space.PagesFromWords[LONG[maxTableEntries]*SIZE[TableEntry]]];    lastEntry ¬ 0;    totalNumberPages ¬ 0;    totalNumberAllocatedPages ¬ 0;    totalNumberFreePages ¬ 0;    totalNumberFiles ¬ 0;    totalNumberTemporaryFiles ¬ 0;    totalNumberAnonymousFiles ¬ 0;    totalNumberRuns ¬ totalVMBNumberRuns ¬ totalVFMNumberRuns ¬ 0;    maxAllocatedRunSize ¬ 0;    maxFreeRunSize ¬ 0;    averageNumberRuns ¬ 0;    maxNumberRuns ¬ [File.nullID, 0];    fileRunCurve ¬ ALL[0];    pgCurve ¬ ALL[0];    freePGCurve ¬ ALL[0];    END; --InitializeGlobals----************************************************----  Maintains UNsorted list of File.IDs, returns index of thing last added.--  Note that the next unused entry AFTER newLastEntry is initialized, too.--************************************************--  InsertFileInTable: PROCEDURE [lastEntry: CARDINAL, fileID: File.ID]     RETURNS [newLastEntry: CARDINAL] =    BEGIN      FOR file: CARDINAL IN [1..lastEntry] DO -- search for any old entry.	IF table­[file].fileID = fileID THEN 	  {table­[file].runs ¬ table­[file].runs + 1;	   newLastEntry ¬ lastEntry;	   RETURN;	   };        ENDLOOP;      IF lastEntry + 1 > maxTableEntries THEN {exceededTable ¬ TRUE; RETURN};      newLastEntry ¬ lastEntry + 1;		-- add new entry.      table­[newLastEntry] ¬ [fileID, 1];      IF newLastEntry # maxTableEntries THEN    -- clear entry ahead of it.        table­[newLastEntry+1] ¬ [File.nullID, 0];    END; --InsertFileInTable----************************************************---- Bump the appropriate curve point according to the curve rules--  mentioned in the global declaration above.--************************************************--  InsertInCurve: PROCEDURE [    curve: LONG POINTER TO CurveType, data: CARDINAL] =     BEGIN    IF data = 0 THEN RETURN;    IF data < 10 THEN      curve­[data] ¬ curve­[data] + 1;    IF data >=10 AND data < 20 THEN      curve­[10] ¬ curve­[10] + 1;    IF data >=20 AND data < 50 THEN      curve­[11] ¬ curve­[11] + 1;    IF data >=50 AND data < 200 THEN      curve­[12] ¬ curve­[12] + 1;    IF data >=200 AND data < 1000 THEN      curve­[13] ¬ curve­[13] + 1;    IF data >=1000 THEN      curve­[14] ¬ curve­[14] + 1;    END;  --InsertInCurve-- --************************************************---- Fill the FileTable with page run info for each file on the LV.--************************************************--  InitializeTable: PROCEDURE [h: Exec.Handle] =     BEGIN        -- internal proc. prints to the exec window.    Out: Format.StringProc = Exec.OutputProc[h];        -- internal proc. get lvStart/lvEndPage. assumes at least one LV.    -- has to first get LV ID from name, then get LV size from PV.    GetDiskInfo: PROCEDURE RETURNS [      found: BOOLEAN ¬ FALSE, drive: DiskChannel.Drive,      lvStartPage, lvEndPage: PhysicalVolume.PageNumber] =      BEGIN      index: CARDINAL ¬ 0;      reqLVname, switches: LONG STRING;      myLVname: LONG STRING _ [Volume.maxNameLength];      myLVID: Volume.ID _ Volume.GetNext[Volume.nullID, [TRUE, TRUE, TRUE, TRUE]];      myPVID: PhysicalVolume.ID;      myLV: SpecialVolume.SubVolume;      -- get drive.      FOR drive ¬ DiskChannel.GetNextDrive[DiskChannel.nullDrive],        DiskChannel.GetNextDrive[drive] UNTIL drive = DiskChannel.nullDrive  DO        IF index = DiskChannel.GetDriveAttributes[drive].deviceOrdinal THEN          {found ¬ TRUE; EXIT;};        ENDLOOP;      -- get LV ID from supplied LV name.      IF Exec.EndOfCommandLine[h] THEN GOTO Quit;      [reqLVname, switches] _ Exec.GetToken[h];      Volume.GetLabelString[myLVID, myLVname        ! Volume.Unknown => GOTO Quit];      WHILE myLVID # Volume.nullID AND NOT String.Equivalent[reqLVname, myLVname] DO        myLVID _ Volume.GetNext[myLVID, [TRUE, TRUE, TRUE, TRUE]];        Volume.GetLabelString[myLVID, myLVname ! Volume.Unknown => GOTO Quit];        ENDLOOP;      switches _ Exec.FreeTokenString[switches];      reqLVname _ Exec.FreeTokenString[reqLVname];      IF myLVID = Volume.nullID THEN GOTO Quit;      -- get LV size from PV and LV ID.      myPVID ¬ PhysicalVolume.GetContainingPhysicalVolume[myLVID];      myLV ¬ SpecialVolume.GetNextSubVolume[myPVID, SpecialVolume.nullSubVolume];      UNTIL myLV.lvID = myLVID DO        myLV ¬ SpecialVolume.GetNextSubVolume[myPVID, myLV];	ENDLOOP;      lvStartPage ¬ myLV.firstPVPageNumber;      lvEndPage ¬ lvStartPage + myLV.subVolumeSize;      EXITS      Quit => {RETURN[found, drive, 0, 0]};      END;          --internal proc.  read disk label.    ReadRun: PROCEDURE RETURNS [currentFileID: File.ID, fType: TypesOfInterest,        runCount: LONG CARDINAL] =        BEGIN	runFirstPage: LONG CARDINAL;        req: DiskChannel.IORequest;        labelVerifyError: DiskChannel.IOStatus = [disk[labelVerifyError]];        status: DiskChannel.IOStatus ¬ labelVerifyError;        -- read a label at the beginning of a run into diskLabelPtr.        WHILE status # DiskChannel.goodCompletion DO          req ¬ [              command: [verify, read, read],              diskPage: currentPage, memoryPage: dataBuffer.page,              useSamePage: TRUE, count: 1,              label: LOOPHOLE[diskLabelPtr],              tries: DiskChannel.defaultTries];          [status, runCount] ¬ DiskChannel.DoIO[channel, @req];          IF status ~= DiskChannel.goodCompletion THEN	     {Out["burp"L]; currentPage ¬ currentPage + 1; LOOP};	  ENDLOOP; -- read label	-- extract interesting page zero information.	currentFileID ¬ LOOPHOLE[diskLabelPtr.fileID.fileID, File.ID];        runFirstPage ¬ PilotDisk.GetLabelFilePage[diskLabelPtr];	fType ¬ SELECT diskLabelPtr.type FROM	  PilotFileTypes.tFreePage => free,	  PilotFileTypes.tVolumeFileMap => vfm,	  PilotFileTypes.tVMBackingFile => vmBacking,	  ENDCASE => other;        IF runFirstPage = 0 THEN            BEGIN            IF diskLabelPtr.temporary = TRUE THEN	      totalNumberTemporaryFiles ¬ totalNumberTemporaryFiles + 1;	    IF diskLabelPtr.type = PilotFileTypes.tAnonymousFile THEN	      totalNumberAnonymousFiles ¬ totalNumberAnonymousFiles + 1;	    -- if page ~zero~ begins a run, verify with page ~one~ instead.            IF (currentPage-100) MOD 1000 = 0 THEN Out["!"L]              ELSE IF currentPage MOD 100 = 0 THEN Out["."L];	    currentPage ¬ currentPage + 1;	    totalNumberPages ¬ totalNumberPages + 1;	    req ¬ [                command: [verify, read, read],                diskPage: currentPage, memoryPage: dataBuffer.page,                useSamePage: TRUE, count: 1,                label: LOOPHOLE[diskLabelPtr],                tries: DiskChannel.defaultTries];            [status, runCount] ¬ DiskChannel.DoIO[channel, @req];            IF status ~= DiskChannel.goodCompletion THEN Out["burp"L];	    IF status ~= DiskChannel.goodCompletion OR	      currentFileID # LOOPHOLE[diskLabelPtr.fileID.fileID, File.ID] THEN	      RETURN[currentFileID: currentFileID, fType: fType, runCount: 1];	    END;        -- verify labels with this label until the label no longer verifies.        req ¬ [            command: [verify, verify, read],            diskPage: currentPage, memoryPage: dataBuffer.page,            useSamePage: TRUE, count: lvEndPage-currentPage,            label: LOOPHOLE[diskLabelPtr],            tries: DiskChannel.defaultTries];        [status, runCount] ¬ DiskChannel.DoIO[channel, @req];        IF status ~= labelVerifyError AND	  runCount # lvEndPage-currentPage --last run on LV-- THEN Out["snort"L];        -- extract interesting run infomation and update current page.        FOR dots:LONG CARDINAL IN [currentPage..currentPage+runCount) DO          IF (dots-100) MOD 1000 = 0 THEN Out["!"L]            ELSE IF dots MOD 100 = 0 THEN Out["."L];	  ENDLOOP;	totalNumberPages ¬ totalNumberPages + runCount;        currentPage ¬ currentPage + runCount;	IF runFirstPage = 0 THEN runCount ¬ runCount + 1;        END; --internal ReadRun--          -- local variables    channel: DiskChannel.Handle;    drive: DiskChannel.Drive;    diskOk: BOOLEAN;    lvStartPage, lvEndPage: PhysicalVolume.PageNumber;    currentFileID: File.ID;    currentPage: PhysicalVolume.PageNumber; -- loop variable.    runCount: LONG CARDINAL;    fType: TypesOfInterest;    dataBuffer: VM.Interval ¬ [Space.PageFromLongPointer[Space.Allocate[1].pointer], 1];    diskLabelPtr: LONG POINTER TO PilotDisk.Label  ¬ Space.Allocate[1].pointer;    VM.ScratchMap[dataBuffer]; -- must be resident    VM.ScratchMap[[Space.PageFromLongPointer[diskLabelPtr], 1]];    [diskOk, drive, lvStartPage, lvEndPage] ¬ GetDiskInfo[];    IF ~diskOk THEN ERROR;  -- cannot get to drive.    channel ¬ DiskChannel.Create[drive];    IF lvStartPage = 0 AND lvEndPage = 0 THEN      {Out["\nBad volume specified."L]};    currentPage ¬ lvStartPage;    UNTIL currentPage >= lvEndPage DO      [currentFileID, fType, runCount] ¬ ReadRun[];      IF fType = free THEN		-- it's a free run        BEGIN        totalNumberFreePages ¬ totalNumberFreePages + runCount;	IF runCount > maxFreeRunSize THEN maxFreeRunSize ¬ runCount;	InsertInCurve[@freePGCurve, CARDINAL[runCount]];	END      ELSE			-- it's a non-free run        BEGIN	SELECT fType FROM	  vfm => totalVFMNumberRuns ¬ totalVFMNumberRuns + 1;	  vmBacking => totalVMBNumberRuns ¬ totalVMBNumberRuns + 1;	  other, free => NULL;	  ENDCASE => ERROR impossibleEndcase;	totalNumberAllocatedPages ¬ totalNumberAllocatedPages + runCount;	IF runCount > maxAllocatedRunSize THEN maxAllocatedRunSize ¬ runCount;	InsertInCurve[@pgCurve, CARDINAL[runCount]];	totalNumberRuns ¬ totalNumberRuns + 1;	lastEntry ¬ InsertFileInTable[lastEntry, currentFileID];	IF exceededTable THEN	    {Out["\nLimit of table is reached; discontinuing count."L];EXIT};        END;      ENDLOOP;          [] ¬ Space.Unmap[Space.LongPointerFromPage[dataBuffer.page]];    diskLabelPtr ¬ Space.Unmap[diskLabelPtr];    END; --InitializeTable--      --************************************************---- Computes statistics for every file entered in the table.--************************************************--  EnumerateTable: PROCEDURE =     BEGIN    file: CARDINAL ¬ 1;    FOR file IN [1..lastEntry] DO -- for every file (every non-free page)      totalNumberFiles ¬ totalNumberFiles + 1;      InsertInCurve[@fileRunCurve, table­[file].runs];      IF table­[file].runs > maxNumberRuns.pages THEN        maxNumberRuns ¬ [table­[file].fileID, table­[file].runs];      ENDLOOP; -- for every file (every non-free page)    averageNumberRuns ¬ totalNumberRuns/totalNumberFiles;    END; --EnumerateTable--        --************************************************---- Prints statistics for every file entered in the table.--************************************************--  PrintTable: PROCEDURE [h: Exec.Handle] =     BEGIN    usableFileID: TYPE = RECORD[a, b: CARDINAL];    Out: Format.StringProc = Exec.OutputProc[h];        Out["\nTotal PAGES, ALLOCATED, FREE on this LV: "L];    	Format.LongDecimal[Out, totalNumberPages]; Out[" , "L];    	Format.LongDecimal[Out, totalNumberAllocatedPages]; Out[" , "L];    	Format.LongDecimal[Out, totalNumberFreePages];    Out["\nTotal FILES, TEMPORARY, ANONYMOUS on this LV: "L];    	Format.LongDecimal[Out, totalNumberFiles]; Out[" , "L];    	Format.LongDecimal[Out, totalNumberTemporaryFiles]; Out[" , "L];    	Format.LongDecimal[Out, totalNumberAnonymousFiles];    Out["\nTotal number of runs on this LV: "L];    	Format.LongDecimal[Out, totalNumberRuns];    Out["\nBiggest ALLOCATED, FREE run size on this LV: "L];    	Format.LongDecimal[Out, maxAllocatedRunSize]; Out[" , "L];    	Format.LongDecimal[Out, maxFreeRunSize];    Out["\nAve and Max number of runs in a file on this LV: "L];    	Format.LongDecimal[Out, averageNumberRuns]; Out[" and "L];    	Format.LongDecimal[Out, maxNumberRuns.pages];    Out["\n		(file ID of most fragmented file is "L];        	Format.Octal[Out, 	   LOOPHOLE[maxNumberRuns.fileID, usableFileID].a];    	Format.Octal[Out, 	   LOOPHOLE[maxNumberRuns.fileID, usableFileID].b]; Out[")"L];    Out["\nVFM and VMBACKINGFILE run count: "L];    	Format.LongDecimal[Out, totalVFMNumberRuns]; Out[" , "L];	Format.LongDecimal[Out, totalVMBNumberRuns];     Out["\nRun distribution across entire LV"L];    Out["\n		alloc	free  runs-in-file"L];    Out["\n	size	count	count	count"L];    Out["\n	1	"L]; Format.Decimal[Out, pgCurve[ 1]]; Out["	"L]; Format.Decimal[Out, freePGCurve[ 1]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[ 1]];    Out["\n	2	"L]; Format.Decimal[Out, pgCurve[ 2]]; Out["	"L]; Format.Decimal[Out, freePGCurve[ 2]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[ 2]];    Out["\n	3	"L]; Format.Decimal[Out, pgCurve[ 3]]; Out["	"L]; Format.Decimal[Out, freePGCurve[ 3]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[ 3]];    Out["\n	4	"L]; Format.Decimal[Out, pgCurve[ 4]]; Out["	"L]; Format.Decimal[Out, freePGCurve[ 4]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[ 4]];    Out["\n	5	"L]; Format.Decimal[Out, pgCurve[ 5]]; Out["	"L]; Format.Decimal[Out, freePGCurve[ 5]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[ 5]];    Out["\n	6	"L]; Format.Decimal[Out, pgCurve[ 6]]; Out["	"L]; Format.Decimal[Out, freePGCurve[ 6]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[ 6]];    Out["\n	7	"L]; Format.Decimal[Out, pgCurve[ 7]]; Out["	"L]; Format.Decimal[Out, freePGCurve[ 7]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[ 7]];    Out["\n	8	"L]; Format.Decimal[Out, pgCurve[ 8]]; Out["	"L]; Format.Decimal[Out, freePGCurve[ 8]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[ 8]];    Out["\n	9	"L]; Format.Decimal[Out, pgCurve[ 9]]; Out["	"L]; Format.Decimal[Out, freePGCurve[ 9]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[ 9]];    Out["\n = 10 & < 20	"L]; Format.Decimal[Out, pgCurve[10]]; Out["	"L]; Format.Decimal[Out, freePGCurve[10]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[10]];    Out["\n = 20 & < 50	"L]; Format.Decimal[Out, pgCurve[11]]; Out["	"L]; Format.Decimal[Out, freePGCurve[11]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[11]];    Out["\n = 50 & <200	"L]; Format.Decimal[Out, pgCurve[12]]; Out["	"L]; Format.Decimal[Out, freePGCurve[12]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[12]];    Out["\n =200 & < 1K	"L]; Format.Decimal[Out, pgCurve[13]]; Out["	"L]; Format.Decimal[Out, freePGCurve[13]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[13]];    Out["\n	>=1K	"L]; Format.Decimal[Out, pgCurve[14]]; Out["	"L]; Format.Decimal[Out, freePGCurve[14]]; Out["	"L]; Format.Decimal[Out, fileRunCurve[14]];    END; --PrintTable----************************************************---- Main routine.--  InitializeGlobals does a failsafe clear of all the globals.--  CreateTable gets the space needed for table: one thousand pages, it turns out!--  InitializeTable sets up the table of page run counts for each file.--  EnumerateTable counts the number of page runs in the current LV.--  PrintTable prints the numbers EnumerateTable came up with.--  DestroyTable returns the space used by the table.--  the Exec.Handle [h] must be passed to any routine that wants to output to the Exec.--************************************************--        Main: Exec.ExecProc =      BEGIN      ENABLE UNWIND => NULL;      InitializeGlobals[];      InitializeTable[h];      IF lastEntry # 0 THEN       {EnumerateTable[];        PrintTable[h]};      [] ¬ Space.Unmap[table];      END;          Unload: Exec.ExecProc = {h.RemoveCommand["CountBeans.~"L]};        Help: Exec.ExecProc = {      h.OutputProc[]["This is a hack that enumerates the page groups        on the current logical volume, and outputs statistics about it.	It does this by reading the first label of each run on the	logical volume and then doing a label verify on the remainder	of the run -- thus giving run size information.  It registers	itself as the exec command 'CountBeans.~'.  To run, it requires	the logical volume have about 60 free pages on it.  As the	pages are being read, a dot is printed out for every 100 of	them."L]};        --************************************************---- Mainline code--************************************************--    Exec.AddCommand[name: "CountBeans.~"L, proc: Main, help: Help, unload: Unload];          END...  -- LOG--  6-Feb-86 23:15:00 KEK created file-- 11-Feb-86 11:19:00 KEK added runs-in-file histogram (fileRunCurve) stuff.  also add file ID of most fragmented file.-- 13-Feb-86 13:29:34 KEK add LV argument, so can run across LV's other than the current one.--  9-Nov-87 12:19:01 RSV Remove unused IMPORT Inline.
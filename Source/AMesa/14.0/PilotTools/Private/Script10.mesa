-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Script10.mesa       26-Apr-83 17:13:50 by CAJ -- Virtual memory test program, Klamath Pilot.-- Script10 tests CopyIn over multiple map units.DIRECTORY  Environment USING [PageCount, PageNumber],  ScriptOps USING [RegisterScript],  VM USING [Interval],  VMTestOperations --USING [all the operations]--,  VMTestScript USING [GetHeap, GetTestVMSize, GiveBackHeap, MakeBackingData,    MakeIrregularSwapData, MakeUniformSwapData, MakeUnitarySwapData, Ticker];Script10: PROGRAM  IMPORTS ScriptOps, VMTestOperations, VMTestScript =  BEGIN  ------------  -- PUBLIC procedures:  -- RunTests is a script of tests using procedures from VMTestOperations (for  -- VM operations) and VMTestScript (for test utilities).  RunTests: PROCEDURE =    BEGIN OPEN VMTestOperations, VMTestScript;        heap: UNCOUNTED ZONE ¬ GetHeap[];    CopyOutUnlikeB[heap];    CopyInUnbacked[heap];    CopyInOther[heap];    CopyOutUnbacked[heap];    CopyOutOther[heap];    -- make runs not corresponding to swap units    heap ¬ GiveBackHeap[heap];    END;  -- Copy tests over multiple map units  CopyInOther: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      pArray: LONG POINTER;    vmSize: CARDINAL = CARDINAL[GetTestVMSize[]];  -- known single-word value    -- copy up to end of VM with run extending past    pArray ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 5, 1, vmSize]];    Map[id: "Irregular A"L,      interval: [0, vmSize],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 4]],      life: alive,      swappability: swappable];    CopyIn[interval: [3, vmSize - 3],      runLength: vmSize - 3,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArray];    -- loop tests    BEGIN    i: Environment.PageCount;    -- map each page separately    pArray ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [1]];    FOR i IN [0..vmSize) DO      Map[id: "Irregular i"L,        interval: [i, 1],        backed: TRUE,        runs:  MakeBackingData[DESCRIPTOR[pArray, 1]],        access: readWrite,        swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 1]],        life: alive,        swappability: swappable];      ENDLOOP;    -- copy each page separately    FOR i DECREASING IN [0..vmSize) DO      CopyIn[interval: [i, 1], runLength: 1, returnWait: wait];      ENDLOOP;    Ticker[];    -- copy each page separately, this time without waiting    FOR i IN [0..vmSize) DO      CopyIn[interval: [i, 1], runLength: 1, returnWait: return];      ENDLOOP;    Ticker[];    -- copy each pair of pages, overlapping, too-long runs    FOR i IN [0..vmSize - 1) DO      CopyIn[interval: [i, 2], runLength: 3, returnWait: wait];      ENDLOOP;    Ticker[];    -- copy the same page repeatedly    FOR i IN [0..100) DO      CopyIn[interval: [2, 1], runLength: 1, returnWait: wait];      ENDLOOP;    Ticker[];    -- copy the last page repeatedly, this time without waiting    FOR i IN [0..100) DO      CopyIn[interval: [vmSize - 1, 1], runLength: 1, returnWait: return];      ENDLOOP;    Ticker[];    -- unmap everything    FOR i IN [0..vmSize) DO Unmap[page: i] ENDLOOP;    heap.FREE[@pArray];    END;  -- loop tests    -- copy resident map unit    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform B"L,      interval: [0, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: resident];    CopyIn[interval: [3, 3],      runLength: 3,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArray];    Ticker[];    -- mixed swappable and resident, copy on swap unit boundaries    pArray ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [3,3,3,3]];    Map[id: "Uniform swappable + resident"L,      interval: [0, 12],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 4]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: resident];    MakeSwappable[interval: [3, 3]];    MakeSwappable[interval: [6, 3]];    CopyIn[interval: [3, 9],      runLength: 9,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- mixed swappable and resident, copy overlaps swap unit boundaries    pArray ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [3,3,3,3]];    Map[id: "Irregular swappable + resident"L,      interval: [0, 12],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 4]],      life: alive,      swappability: resident];    MakeSwappable[interval: [3, 3]];    MakeSwappable[interval: [9, 3]];    CopyIn[interval: [1, 6],      runLength: 6,      returnWait: wait];    Ticker[];    CopyIn[interval: [6, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- CopyIn then CopyOut    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 12]];    Map[id: "Irregular C"L,      interval: [0, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    FOR i: Environment.PageNumber IN [1..14) DO      CopyIn[interval: [i, 1], runLength: 1, returnWait: wait];      CopyOut[interval: [i, 1], runLength: 1, returnWait: wait];      ENDLOOP;    CopyIn[interval: [0, 15],      runLength: 15,      returnWait: wait];    CopyOut[interval: [0, 15],      runLength: 15,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArray];    Ticker[];    -- CopyOut then CopyIn    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 12]];    Map[id: "Irregular C"L,      interval: [0, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    FOR i: Environment.PageNumber IN [1..14) DO      CopyOut[interval: [i, 1], runLength: 1, returnWait: wait];      CopyIn[interval: [i, 1], runLength: 1, returnWait: wait];      ENDLOOP;    CopyOut[interval: [0, 15],      runLength: 15,      returnWait: wait];    CopyIn[interval: [0, 15],      runLength: 15,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArray];    Ticker[];    END;  -- Copy tests over multiple map units  CopyOutOther: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      pArray: LONG POINTER;    vmSize: CARDINAL = CARDINAL[GetTestVMSize[]];  -- known single-word value    -- copy up to end of VM with run extending past    pArray ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 5, 1, vmSize]];    Map[id: "Irregular A"L,      interval: [0, vmSize],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 4]],      life: alive,      swappability: swappable];    CopyOut[interval: [3, vmSize - 3],      runLength: vmSize - 3,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArray];    -- loop tests    BEGIN    i: Environment.PageCount;    -- map each page separately    pArray ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [1]];    FOR i IN [0..vmSize) DO      Map[id: "Irregular i"L,        interval: [i, 1],        backed: TRUE,        runs:  MakeBackingData[DESCRIPTOR[pArray, 1]],        access: readWrite,        swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 1]],        life: alive,        swappability: swappable];      ENDLOOP;    -- copy each page separately    FOR i DECREASING IN [0..vmSize) DO      CopyOut[interval: [i, 1], runLength: 1, returnWait: wait];      ENDLOOP;    Ticker[];    -- copy each page separately, this time without waiting    FOR i IN [0..vmSize) DO      CopyOut[interval: [i, 1], runLength: 1, returnWait: return];      ENDLOOP;    Ticker[];    -- copy each pair of pages, overlapping, too-long runs    FOR i IN [0..vmSize - 1) DO      CopyOut[interval: [i, 2], runLength: 3, returnWait: wait];      ENDLOOP;    Ticker[];    -- copy the same page repeatedly    FOR i IN [0..100) DO      CopyOut[interval: [2, 1], runLength: 1, returnWait: wait];      ENDLOOP;    Ticker[];    -- copy the last page repeatedly, this time without waiting    FOR i IN [0..100) DO      CopyOut[interval: [vmSize - 1, 1], runLength: 1, returnWait: return];      ENDLOOP;    Ticker[];    -- unmap everything    FOR i IN [0..vmSize) DO Unmap[page: i] ENDLOOP;    heap.FREE[@pArray];    END;  -- loop tests    -- copy resident map unit    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform B"L,      interval: [0, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: resident];    CopyOut[interval: [3, 3],      runLength: 3,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArray];    Ticker[];    -- mixed swappable and resident, copy on swap unit boundaries    pArray ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [3,3,3,3]];    Map[id: "Uniform swappable + resident"L,      interval: [0, 12],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 4]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: resident];    MakeSwappable[interval: [3, 3]];    MakeSwappable[interval: [6, 3]];    CopyOut[interval: [3, 9],      runLength: 9,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- mixed swappable and resident, copy overlaps swap unit boundaries    pArray ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [3,3,3,3]];    Map[id: "Irregular swappable + resident"L,      interval: [0, 12],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 4]],      life: alive,      swappability: resident];    MakeSwappable[interval: [3, 3]];    MakeSwappable[interval: [9, 3]];    CopyOut[interval: [1, 6],      runLength: 6,      returnWait: wait];    Ticker[];    CopyOut[interval: [6, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- CopyOut from readOnly map unit    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 12]];    Map[id: "Irregular C"L,      interval: [0, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readOnly,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    FOR i: Environment.PageNumber IN [1..14) DO      CopyOut[interval: [i, 1], runLength: 1, returnWait: wait];      ENDLOOP;    CopyOut[interval: [0, 15],      runLength: 15,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArray];    Ticker[];    END;  -- CopyIn tests involving unbacked map units  CopyInUnbacked: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      pArrayA: LONG POINTER;    pArrayC: LONG POINTER;    -- single unbacked data unit    Map[id: "Unbacked data unit"L,      interval: [0, 10],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 0];    Ticker[];    -- copy in two unbacked data units: all of A + part of B    Map[id: "Unbacked A"L,      interval: [0, 10],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    Map[id: "Unbacked B"L,      interval: [10, 15],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    CopyIn[interval: [0, 11],      runLength: 11,      returnWait: wait];    Unmap[page: 0];    Unmap[page: 10];    Ticker[];    -- copy in two unbacked data units: part of each    Map[id: "Unbacked A"L,      interval: [0, 10],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    Map[id: "Unbacked B"L,      interval: [10, 15],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    CopyIn[interval: [3, 11],      runLength: 11,      returnWait: wait];    Unmap[page: 0];    Unmap[page: 10];    Ticker[];    -- unbacked + backed resident    Map[id: "Unbacked A"L,      interval: [0, 10],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Backed resident B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: resident];    CopyIn[interval: [3, 11],      runLength: 11,      returnWait: wait];    Unmap[page: 0];    Unmap[page: 10];    heap.FREE[@pArrayA];    Ticker[];    -- unbacked + backed swappable    Map[id: "Unbacked A"L,      interval: [0, 10],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Backed swappable B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [3, 11],      runLength: 11,      returnWait: wait];    Unmap[page: 0];    Unmap[page: 10];    heap.FREE[@pArrayA];    Ticker[];    -- unbacked sandwiched between 2 backed        pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Backed swappable B"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Map[id: "Unbacked B"L,      interval: [10, 5],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 6]];    Map[id: "Irregular B"L,      interval: [15, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayC, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [7, 12],      runLength: 12,      returnWait: wait];    CopyIn[interval: [0, 24],      runLength: 24,      returnWait: wait];    Unmap[page: 0];    Unmap[page: 10];    heap.FREE[@pArrayA];    Unmap[page: 15];    heap.FREE[@pArrayC];    Ticker[];    END;  -- CopyOut tests involving unbacked map units  CopyOutUnbacked: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      pArrayA: LONG POINTER;    pArrayC: LONG POINTER;    -- single unbacked data unit    Map[id: "Unbacked data unit"L,      interval: [0, 10],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 0];    Ticker[];    -- copy in two unbacked data units: all of A + part of B    Map[id: "Unbacked A"L,      interval: [0, 10],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    Map[id: "Unbacked B"L,      interval: [10, 15],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    CopyOut[interval: [0, 11],      runLength: 11,      returnWait: wait];    Unmap[page: 0];    Unmap[page: 10];    Ticker[];    -- copy in two unbacked data units: part of each    Map[id: "Unbacked A"L,      interval: [0, 10],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    Map[id: "Unbacked B"L,      interval: [10, 15],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    CopyOut[interval: [3, 11],      runLength: 11,      returnWait: wait];    Unmap[page: 0];    Unmap[page: 10];    Ticker[];    -- unbacked + backed resident    Map[id: "Unbacked A"L,      interval: [0, 10],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Backed resident B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: resident];    CopyOut[interval: [3, 11],      runLength: 11,      returnWait: wait];    Unmap[page: 0];    Unmap[page: 10];    heap.FREE[@pArrayA];    Ticker[];    -- unbacked + backed swappable    Map[id: "Unbacked A"L,      interval: [0, 10],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Backed swappable B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyOut[interval: [3, 11],      runLength: 11,      returnWait: wait];    Unmap[page: 0];    Unmap[page: 10];    heap.FREE[@pArrayA];    Ticker[];    -- unbacked sandwiched between 2 backed        pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Backed swappable B"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Map[id: "Unbacked B"L,      interval: [10, 5],      backed: FALSE,      runs:  NIL,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 6]];    Map[id: "Irregular B"L,      interval: [15, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayC, 3]],      life: alive,      swappability: swappable];    CopyOut[interval: [7, 12],      runLength: 12,      returnWait: wait];    CopyOut[interval: [0, 24],      runLength: 24,      returnWait: wait];    Unmap[page: 0];    Unmap[page: 10];    heap.FREE[@pArrayA];    Unmap[page: 15];    heap.FREE[@pArrayC];    Ticker[];    END;  -- CopyOut tests over multiple map units, part 2  -- (CopyOutUnlikeA is in Script9.  Both make too much for compiler pass 1.)  CopyOutUnlikeB: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      -- Make as many arrayPointers as needed    pArrayA: LONG POINTER;    pArrayB: LONG POINTER;    pArrayC: LONG POINTER;    --pSwapUnits: LONG POINTER;    -- unitary - uniform - irregular: whole swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [4]];    Map[id: "Unitary A"L,      interval: [0, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2,2,2]];    Map[id: "Uniform B"L,      interval: [4, 6],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 12]];    Map[id: "Irregular C"L,      interval: [10, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayC, 3]],      life: alive,      swappability: swappable];    CopyOut[interval: [0, 13],      runLength: 13,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 4];    heap.FREE[@pArrayB];    Unmap[page: 10];    heap.FREE[@pArrayC];    Ticker[];    -- unitary - uniform - irregular: partial swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [4]];    Map[id: "Unitary A"L,      interval: [0, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2,2,2]];    Map[id: "Uniform B"L,      interval: [4, 6],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 12]];    Map[id: "Irregular C"L,      interval: [10, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayC, 3]],      life: alive,      swappability: swappable];    CopyOut[interval: [1, 22],      runLength: 22,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 4];    heap.FREE[@pArrayB];    Unmap[page: 10];    heap.FREE[@pArrayC];    Ticker[];    -- irregular - unitary - uniform: whole swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 4, 1, 8]];    Map[id: "Irregular A"L,      interval: [0, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [4]];    Map[id: "Unitary B"L,      interval: [15, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2,2,2]];    Map[id: "Uniform C"L,      interval: [19, 6],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyOut[interval: [6, 17],      runLength: 17,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 15];    heap.FREE[@pArrayB];    Unmap[page: 19];    heap.FREE[@pArrayC];    Ticker[];    -- irregular - unitary - uniform: partial swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 4, 1, 8]];    Map[id: "Irregular A"L,      interval: [0, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [4]];    Map[id: "Unitary B"L,      interval: [15, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2,2,2]];    Map[id: "Uniform C"L,      interval: [19, 6],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyOut[interval: [3, 21],      runLength: 21,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 15];    heap.FREE[@pArrayB];    Unmap[page: 19];    heap.FREE[@pArrayC];    Ticker[];    -- uniform - irregular - unitary: partial swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 6]];    Map[id: "Irregular B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [6]];    Map[id: "Unitary C"L,      interval: [19, 6],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyOut[interval: [3, 21],      runLength: 21,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Unmap[page: 19];    heap.FREE[@pArrayC];    Ticker[];    -- irregular - irregular - uniform: whole swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [1, 3, 1, 7]];    Map[id: "Irregular A"L,      interval: [0, 12],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 1]];    Map[id: "Irregular B"L,      interval: [12, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform C"L,      interval: [16, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyOut[interval: [4, 18],      runLength: 18,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 12];    heap.FREE[@pArrayB];    Unmap[page: 16];    heap.FREE[@pArrayC];    Ticker[];    -- irregular - irregular - uniform: partial swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [1, 3, 1, 7]];    Map[id: "Irregular A"L,      interval: [0, 12],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 1]];    Map[id: "Irregular B"L,      interval: [12, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform C"L,      interval: [16, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyOut[interval: [2, 18],      runLength: 18,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 12];    heap.FREE[@pArrayB];    Unmap[page: 16];    heap.FREE[@pArrayC];    Ticker[];    END;  ------------  -- PUBLIC SIGNALs and ERRORs: none  ------------  -- Initialization:  ScriptOps.RegisterScript[RunTests, "Other copy tests"L];  END.LOG29-Nov-82 16:12:05   CAJ    Created file.
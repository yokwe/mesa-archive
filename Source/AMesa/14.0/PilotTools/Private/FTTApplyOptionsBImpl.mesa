-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. -- FTTApplyOptionsBImpl.mesa,  last edited by RSV on  1-May-87 15:43:18DIRECTORY  Environment USING [bytesPerPage],  File USING [File, PageCount, Type],  Floppy,  FloppyExtras,  FormSW USING [ProcType],  FTTDefs,  MFile USING [Handle, Release, SetLength],  SpecialSystem USING [Unimplemented];FTTApplyOptionsBImpl: PROGRAM   IMPORTS Floppy, FloppyExtras, FTTDefs, MFile, SpecialSystem  EXPORTS FTTDefs  SHARES Floppy =			  BEGIN OPEN FTTDefs;        CompactApplyOptions: PUBLIC FormSW.ProcType =     BEGIN      ENABLE        redoparams =>  BEGIN	    	       PrintErrorProc[toolData.msgSW, msg];		       GOTO exit;                       END;      volume: VolumeRecType ¬ [toolData.volumeHandle.lowbits,			      toolData.volumeHandle.highbits];           --Clear messageSW      ClearmsgSW[];      --Test Floppy.Compact      Floppy.Compact[LOOPHOLE[volume, Floppy.VolumeHandle] !Floppy.Error=>      							      ErrorHandlingProc[error];];      RemoveOptions[sw];      EXITS        exit => RETURN;     END;         ScavengeApplyOptions: PUBLIC FormSW.ProcType =     BEGIN       ENABLE	 redoparams => BEGIN	    	       PrintErrorProc[toolData.msgSW, msg];		       GOTO exit;                       END;     ok: BOOLEAN ¬ FALSE;     --Clear messageSW     ClearmsgSW[];     --Test FloppyExtras.NewScavenge; storing results for printing     ok ¬ FloppyExtras.NewScavenge[toolData.drive !        Floppy.Error => ErrorHandlingProc[error];       FloppyExtras.ExtrasError => ExtraErrorHandlingProc[error]];     --Print returns of FloppyExtras.NewScavenge     PrintScavengeReturns[ok];     RemoveOptions[sw];     EXITS       exit => RETURN;     END;          GetNextBadSectorApplyOptions: PUBLIC FormSW.ProcType =      BEGIN       ENABLE        redoparams =>  BEGIN	    		 PrintErrorProc[toolData.msgSW, msg];			 GOTO exit;                       END;        volume: VolumeRecType ¬ [toolData.volumeHandle.lowbits,			      toolData.volumeHandle.highbits];       file: Floppy.FileHandle;            --Clear messageSW       ClearmsgSW[];       --Test Floppy.GetNextBadSector; storing results so they can be printed       [toolData.oldIndex, file,       toolData.page] ¬ Floppy.GetNextBadSector[LOOPHOLE[volume, Floppy.VolumeHandle],                                    toolData.oldIndex !Floppy.Error=>       							ErrorHandlingProc[error];];       --Print returns of Floppy.GetNextBadSector       PrintGetNextBadSectorReturns[toolData.oldIndex, file, toolData.page];       RemoveOptions[sw];       EXITS         exit => RETURN;     END;           ReplaceBadSectorApplyOptions: PUBLIC FormSW.ProcType =      BEGIN               ENABLE          BEGIN	    redoparams =>  BEGIN	    		     PrintErrorProc[toolData.msgSW, msg];			     GOTO exit;                           END;	    --Raised because this code is currently not implemented--	    SpecialSystem.Unimplemented => BEGIN	                                      PrintErrorProc[toolData.msgSW, "Unimplemented Code"L];			                      GOTO exit;			                    END;	END;       file: FileRecType ¬ [toolData.volumeHandle.lowbits,			toolData.volumeHandle.highbits,                        toolData.fileID.a,			toolData.fileID.b];       readError: BOOLEAN ¬ FALSE;              --Clear messageSW       ClearmsgSW[];       --Test Floppy.ReplaceBadSector; storing results for printing       readError ¬ Floppy.ReplaceBadSector[LOOPHOLE[file, Floppy.FileHandle],                                   toolData.page !Floppy.Error=>     				  			ErrorHandlingProc[error];];       --Print returns from Floppy.ReplaceBadSector       PrintReplaceBadSectorReturns[readError];       RemoveOptions[sw];       EXITS         exit => RETURN;       END;          CreateInitialApplyOptions: PUBLIC FormSW.ProcType =      BEGIN       ENABLE        BEGIN	  redoparams =>  BEGIN	    		    PrintErrorProc[toolData.msgSW, msg];			    GOTO exit;                         END;	  --Raised because code is currently not implemented--	  SpecialSystem.Unimplemented => BEGIN	                       PrintErrorProc[toolData.msgSW, "Unimplemented Code"L];			       GOTO exit;			    END;	END;       volume: VolumeRecType ¬ [toolData.volumeHandle.lowbits,			      toolData.volumeHandle.highbits];       file: Floppy.FileHandle;              --clear messageSW       ClearmsgSW[];       --Test Floppy.CreateInitialMicrocodeFile; storing results for printing       file ¬ Floppy.CreateInitialMicrocodeFile[         LOOPHOLE[volume, Floppy.VolumeHandle], toolData.size,	 LOOPHOLE[toolData.type, File.Type], toolData.startingPageNumber !	   Floppy.Error=> ErrorHandlingProc[error];];       --Print returns from Floppy.CreateInitialMicrocodeFile       PrintCreateInitialReturns[file];       RemoveOptions[sw];       EXITS         exit => RETURN;      END;    GetBootFilesApplyOptions: PUBLIC FormSW.ProcType =      BEGIN       ENABLE        redoparams =>  BEGIN	    		 PrintErrorProc[toolData.msgSW, msg];			 GOTO exit;                       END;       initialMicrocode: Floppy.BootFilePointer ¬ Floppy.nullBootFilePointer;       volume: VolumeRecType ¬ [toolData.volumeHandle.lowbits,			      toolData.volumeHandle.highbits];              --Clear messageSW       ClearmsgSW[];       --Test Floppy.GetBootFiles; string results for printing       [initialMicrocode, toolData.pilotMicrocode,        toolData.diagnosticMicrocode, toolData.germ,        toolData.pilotBootFile] ¬ Floppy.GetBootFiles[	  LOOPHOLE[volume, Floppy.VolumeHandle] ! 	    Floppy.Error=> ErrorHandlingProc[error];];       --Print returns from Floppy.GetBootFiles       PrintGetBootFilesReturns[         initialMicrocode, toolData.pilotMicrocode, toolData.diagnosticMicrocode,	 toolData.germ, toolData.pilotBootFile];       RemoveOptions[sw];       EXITS         exit => RETURN;      END;            MakeImageApplyOptions: PUBLIC FormSW.ProcType =      BEGIN       ENABLE         BEGIN         redoparams =>  BEGIN	    		PrintErrorProc[toolData.msgSW, msg];			GOTO exit;                        END;         Floppy.DataError => BEGIN	                     PrintDataErrorProc[toolData.msgSW, file, page, vm];			     GOTO exit;			     END;	 END;	      pilotFile: File.File;      size: LONG CARDINAL;      			         --Clear messageSW      ClearmsgSW[];      --Convert data into appropriate types so can test Floppy.CopyToPilotFile      pilotFile ¬ LoopHoleFile[toolData.pilotFileID];      --Test Floppy.MakeImage      Floppy.MakeImage[        floppyDrive: toolData.drive, imageFile: pilotFile,        firstImagePage: toolData.pilotPage ! 	  Floppy.Error => ErrorHandlingProc[error]];      size ¬ Environment.bytesPerPage * Floppy.PagesForImage[toolData.drive];      IF toolData.fileHandle # 0 THEN {        MFile.SetLength[LOOPHOLE[toolData.fileHandle,MFile.Handle],size];        MFile.Release[LOOPHOLE[toolData.fileHandle,MFile.Handle]];        toolData.fileHandle ¬ 0};      RemoveOptions[sw]              EXITS        exit => RETURN;      END;            CreateFloppyFromImageApplyOptions: PUBLIC FormSW.ProcType =      BEGIN       ENABLE        BEGIN         redoparams =>  BEGIN	    		PrintErrorProc[toolData.msgSW, msg];			GOTO exit;                        END;		       	 Floppy.DataError => BEGIN	                     PrintErrorProc[toolData.msgSW, "Floppy Data Error"L];			     PrintDataErrorProc[toolData.fileSW, file, page, vm];			     GOTO exit;			     END;		              END;            pilotFile: File.File;	                   --Clear messageSW      ClearmsgSW[];      --Convert data to appropriate types so can test      pilotFile ¬ LoopHoleFile[toolData.pilotFileID];      --Test Floppy.CreateFloppyFromImage      Floppy.CreateFloppyFromImage[        floppyDrive: toolData.drive, imageFile: pilotFile,        firstImagePage: toolData.pilotPage, reformatFloppy: toolData.reFormat,        floppyDensity: toolData.density, floppySides: toolData.sides,	numberOfFiles: toolData.numberOfFiles,        newLabelString: toolData.labelString ! 	  Floppy.Error => ErrorHandlingProc[error]];      IF toolData.fileHandle # 0 THEN {        MFile.Release[LOOPHOLE[toolData.fileHandle,MFile.Handle]];        toolData.fileHandle ¬ 0 };      RemoveOptions[sw];      EXITS        exit => RETURN;      END;          GetImageAttributesApplyOptions: PUBLIC FormSW.ProcType =      BEGIN      currentNumberOfFiles: CARDINAL;      maxNumberOfFiles: CARDINAL;      density: Floppy.Density;      sides: Floppy.Sides;      labelString: LONG STRING ¬ [128];      pilotFile: File.File;  	           --Clear messageSW      ClearmsgSW[];      --Convert data to appropriate types so can test      pilotFile ¬ LoopHoleFile[toolData.pilotFileID];      --Test Floppy.GetImageAttributes      [maxNumberOfFiles: maxNumberOfFiles,        currentNumberOfFiles: currentNumberOfFiles, density: density,        sides: sides] ¬ Floppy.GetImageAttributes[imageFile: pilotFile,	  firstImagePage: toolData.pilotPage, name: labelString];      --Print out the return values          PrintGetImageAttributesReturns[        maxNumberOfFiles: maxNumberOfFiles, 	currentNumberOfFiles: currentNumberOfFiles, density: density,        sides: sides];               IF toolData.fileHandle # 0 THEN {        MFile.Release[LOOPHOLE[toolData.fileHandle,MFile.Handle]];        toolData.fileHandle ¬ 0 };      RemoveOptions[sw];      END;          PagesForImageApplyOptions: PUBLIC FormSW.ProcType =      BEGIN      pages: File.PageCount;             --Clear messageSW      ClearmsgSW[];      --Test Floppy.PagesForImage      pages ¬ Floppy.PagesForImage[floppyDrive: toolData.drive];      --print out returns from Floppy.PagesForImage      PrintPagesForImageReturns[pages: pages];      RemoveOptions[sw];      END;END... --Main Program   LOG20-Nov-81 11:26:40  LXD  Created file26-Oct-82 14:11:03  ET   Added GetImageAttributesApplyOptions, CreateFlopppyFromImageApplyOptions, and MakeImageApplyOptions. 3-Apr-87 18:38:08  RSV  Added Copyright notice.  Old arrows to new arrows.  Convert to Klamath Floppy and File interfaces. 1-May-87 15:43:18  RSV  Changed ScavengeApplyOptions to reflect FloppyExtras.NewScavenge.
-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- DiskEditETableBucketSW.mesa  26-Sep-86 26-Sep-86  9:21:43 by CAJDIRECTORY  DiskEditInternal USING [    dataPtr, dataWindowKey, msgSW, ReplaceFIDString, ValidateFID],  ETable USING [BucketHandle, BucketHeader, ETable, ETableHandle,    ETableHeader, PageGroup],  Environment USING [wordsPerPage],  File USING [ID, nullID, Type],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Display, DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    FilterProcType, FindItem, GetSelection, GetTypeIn, line0, line1, line2,    line3, line4, line5, line6, line7, line8, LongNumberItem,    LongNumberNotifyProcType, nextLine, nextPlace, NotifyProcType, nullIndex,    NumberItem, NumberNotifyProcType, ProcType, SetSelection, SetTypeIn,    StringEditProc, StringItem, TagOnlyItem],  Heap USING [systemZone],  MsgSW USING [Clear],  PilotFileTypes USING [tUnassigned],  Put USING [Line],  String USING [FreeString],  UserTerminal USING [BlinkDisplay],  Window USING [Handle],  WindowSwap USING [CurrentViewHandle, RegisterView];DiskEditETableBucketSW: PROGRAM  IMPORTS DiskEditInternal, FormSW, Heap, MsgSW, Put, String, UserTerminal,    WindowSwap =  BEGIN  -- TYPEs and constants:  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    -- Values of less than a word are sandwiched to force word boundaries.    bucketType: BucketType ¬ normal,    firstETableOffset: ETableOffset ¬ LOOPHOLE[SIZE[ETable.BucketHeader]],    freeSpace: LONG POINTER ¬ NIL,    -- The preceeding definition replaces the following correct one because the    -- definition of tools items won't take such sophisticated objects.    --freeSpace: ETable.FreeSpaceInOverflow ¬ firstOffsetValue,    offset: ETableOffset ¬ LOOPHOLE[SIZE[ETable.BucketHeader]],    fileIDString: LONG STRING ¬ NIL,    eTableType: ETableType ¬ inuse,    howManyGroups: CARDINAL ¬ 0,    allShown: BOOLEAN ¬ TRUE,    unused: CARDINAL ¬ 0,    temporary: BOOLEAN ¬ FALSE,    fileType: File.Type ¬ PilotFileTypes.tUnassigned,    bootable: BOOLEAN ¬ FALSE,    length: CARDINAL ¬ 0,    fill: CARDINAL ¬ 0,    pageGroups: ARRAY [0..maxedOutPageGroups) OF ETable.PageGroup ¬ ALL[[0, 0]]];  BucketType: TYPE = {normal, overflow, overflowExtention};  ETableOffset: TYPE =    ETable.BucketHandle RELATIVE ORDERED POINTER TO ETable.ETable;  ETableType: TYPE = {inuse, free};  FormItems: TYPE = {eTableBucket, bucketHeader, firstETableOffset, bucketType,    freeSpace, eTablesInOverflowCount, noHeader, firstFree, currentETable,    offset, next, back, first, last, fileID, eTableType, length, howManyGroups,    allShown, fill, temporary, bootable, unused, fileType, pageGroups};  firstPageGroupItem: CARDINAL = FormItems.pageGroups.ORD;  itemsPerPageGroup: CARDINAL = 2;  maxNormal: CARDINAL = (Environment.wordsPerPage - SIZE[ETable.BucketHeader] -    SIZE[ETable.ETableHeader])/SIZE[ETable.PageGroup];  maxedOutPageGroups: CARDINAL = (Environment.wordsPerPage -    SIZE[ETable.ETableHeader])/SIZE[ETable.PageGroup];  firstOffsetValue: ETableOffset = LOOPHOLE[0];  -- What is the real boundary for this?  lastETableOffset: ETableOffset = LOOPHOLE[Environment.wordsPerPage-1];  -- Global variables:  bucketPage: ETable.BucketHandle = LOOPHOLE[DiskEditInternal.dataPtr];  currentETable: ETable.ETableHandle ¬ NIL;  data: DataHandle ¬ NIL;  heap: UNCOUNTED ZONE ¬ Heap.systemZone;  -- used by all but should be public  maxPageGroups: CARDINAL;  sw: Window.Handle ¬ NIL;  -- Procedures:  Back:  FormSW.ProcType =    BEGIN    -- same as Next except (1) calc backwards (how?) and (2) check beginning    NotImplemented[];    END;  -- Back  ChangeBootable: FormSW.NotifyProcType =    BEGIN    Put.Line[DiskEditInternal.msgSW,      "Warning: this doesn't make do Make{Bootable, Unbootable}"L];    currentETable.header.bootable ¬ data.bootable;    END;  -- ChangeBootable  ChangeBucketVariant: FormSW.EnumeratedNotifyProcType =    --[sw: Window.Handle, item: FormsSW.ItemHandle, index: CARDINAL,    -- oldValue: UNSPECIFIED]    BEGIN    -- Changes the bucket variant part from one (assumed valid) to another type.    MsgSW.Clear[DiskEditInternal.msgSW];    SELECT data.bucketType FROM      oldValue => RETURN;      normal, overflow, overflowExtention => NULL;      ENDCASE => UserTerminal.BlinkDisplay[];    SetBucketVariant[data.bucketType];    Redisplay[];    END;  -- ChangeBucketVariant  ChangeCount: FormSW.NumberNotifyProcType =    --[sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    -- oldValue: UNSPECIFIED]    BEGIN    whichGroup: CARDINAL ¬ (index - firstPageGroupItem)/itemsPerPageGroup;    MsgSW.Clear[DiskEditInternal.msgSW];    currentETable.pageGroups[whichGroup].count ¬      data.pageGroups[whichGroup].count;    END;  -- ChangeCount  ChangeETableVariant: FormSW.EnumeratedNotifyProcType =    --[sw: Window.Handle, item: FormsSW.ItemHandle, index: CARDINAL,    -- oldValue: UNSPECIFIED]    BEGIN    -- Changes the ETable variant part from one (assumed valid) to the other type.    MsgSW.Clear[DiskEditInternal.msgSW];    SetETableVariant[variant: data.eTableType, oldGroupCount: data.howManyGroups];    Redisplay[];    END;  -- ChangeETableVariant  ChangeFileType: FormSW.NumberNotifyProcType =    BEGIN    MsgSW.Clear[DiskEditInternal.msgSW];    currentETable.header.type ¬ data.fileType;    END;  -- ChangeFileType  ChangeFill: FormSW.NumberNotifyProcType =    BEGIN    MsgSW.Clear[DiskEditInternal.msgSW];    currentETable.header.fill ¬ data.fill;    END;  -- ChangeFill  ChangeFirstETableOffset: FormSW.NumberNotifyProcType =    -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    --  oldValue: UNSPECIFIED]    BEGIN    MsgSW.Clear[DiskEditInternal.msgSW];    IF data.firstETableOffset ~IN [firstOffsetValue..lastETableOffset]      THEN {UserTerminal.BlinkDisplay[]; RETURN};    NewETable[offset: data.firstETableOffset, oldGroupCount: data.howManyGroups];    Redisplay[];    END;  -- ChangeFirstETableOffset  ChangeFreeSpace: FormSW.LongNumberNotifyProcType =    BEGIN    MsgSW.Clear[DiskEditInternal.msgSW];    bucketPage.header.freeSpace ¬ LOOPHOLE[data.freeSpace];    END;  -- ChangeFreeSpace  ChangeGroups: FormSW.NumberNotifyProcType =    --[sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    -- oldValue: UNSPECIFIED]    BEGIN    IF data.bucketType = normal THEN      {IF data.howManyGroups ~IN [0..maxPageGroups] THEN        {UserTerminal.BlinkDisplay[]; RETURN}};    currentETable.header.howManyGroups ¬ data.howManyGroups;    SetETableVariant[variant: data.eTableType, oldGroupCount: oldValue];    Redisplay[];    END;  -- ChangeGroups  ChangeLength: FormSW.NumberNotifyProcType =    BEGIN    MsgSW.Clear[DiskEditInternal.msgSW];    currentETable.header.length ¬ data.length;    END;  -- ChangeLength  ChangeTemporary: FormSW.NotifyProcType =    BEGIN    MsgSW.Clear[DiskEditInternal.msgSW];    currentETable.header.temporary ¬ data.temporary;    END;  -- ChangeTemporary  ChangeUnused: FormSW.NumberNotifyProcType =    --[sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    -- oldValue: UNSPECIFIED]    BEGIN    fourBitsMax: CARDINAL = 15;    MsgSW.Clear[DiskEditInternal.msgSW];    IF data.unused > fourBitsMax THEN      BEGIN      UserTerminal.BlinkDisplay[];      data.unused ¬ oldValue;      FormSW.DisplayItem[sw, index];      END    ELSE currentETable.header.unused ¬ data.unused;    END;  ChangeVolumePage: FormSW.LongNumberNotifyProcType =    --[sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    -- oldValue: LONG UNSPECIFIED]    BEGIN    whichGroup: CARDINAL ¬ (index - firstPageGroupItem)/itemsPerPageGroup;    MsgSW.Clear[DiskEditInternal.msgSW];    currentETable.pageGroups[whichGroup].volumePage ¬      data.pageGroups[whichGroup].volumePage;    END;  CleanupETableBucketSW: PROCEDURE = {};  DestroyETableBucketSW: PROCEDURE =    BEGIN    String.FreeString[z: heap, s: data.fileIDString];    heap.FREE[@data];    data ¬ NIL;    sw ¬ NIL;    END;  -- DestroyETableBucketSW  FillETableBucketSW: PROCEDURE =    BEGIN    i: CARDINAL;    IF sw = NIL THEN      sw ¬ WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey];    data.firstETableOffset ¬ LOOPHOLE[SIZE[ETable.BucketHeader]];    maxPageGroups ¬ maxNormal;    SetBucketVariant[normal];  -- assume and make user change it if wrong    -- Find how many page groups are currently visible    FOR i ¬ 0, i + 1 UNTIL i = maxPageGroups DO      IF FormSW.FindItem[        sw, firstPageGroupItem + i*itemsPerPageGroup].flags.invisible THEN EXIT      ENDLOOP;    NewETable[offset: data.firstETableOffset, oldGroupCount: i];    END;  -- FillETableBucketSW  First:  FormSW.ProcType =    BEGIN    MsgSW.Clear[DiskEditInternal.msgSW];    NewETable[offset: data.firstETableOffset, oldGroupCount: data.howManyGroups];    Redisplay[];    END;  -- First  Last:  FormSW.ProcType =  -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL]    BEGIN    -- calc last ETable (how?)    -- rest same as Next    NotImplemented[];    END;  -- Last  MakeETableBucketSW: FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL =      firstPageGroupItem + (maxedOutPageGroups*itemsPerPageGroup);    bucketTypes: ARRAY[0..3) OF FormSW.Enumerated ¬ [      ["normal"L, BucketType[normal]],      ["overflow"L, BucketType[overflow]],      ["overflowExtention"L, BucketType[overflowExtention]]];    eTableTypes: ARRAY[0..2) OF FormSW.Enumerated ¬ [      ["inuse"L, ETableType[inuse]], ["free"L, ETableType[free]]];    data ¬ heap.NEW[Data];    sw ¬ WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey];    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[FormItems.eTableBucket.ORD] ¬ FormSW.TagOnlyItem[      tag: "ETable Bucket"L, place: [4, FormSW.line0]];    items[FormItems.bucketHeader.ORD] ¬ FormSW.TagOnlyItem[      tag: "Bucket header"L, place: [12, FormSW.line1]];    items[FormItems.firstETableOffset.ORD] ¬ FormSW.NumberItem[      tag: "1st ETable offset  "L, place: [140, FormSW.line1], invisible: TRUE,      signed: FALSE, notNegative: TRUE, proc: ChangeFirstETableOffset,      default: 0, value: @data.firstETableOffset];    items[FormItems.bucketType.ORD] ¬ FormSW.EnumeratedItem[      tag: "type"L, place: [21, FormSW.line2], feedback: all,      choices: DESCRIPTOR[bucketTypes], proc: ChangeBucketVariant,      value: @data.bucketType];    items[FormItems.freeSpace.ORD] ¬ FormSW.LongNumberItem[      tag: "freeSpace "L, place: [21, FormSW.line3], invisible: TRUE,      signed: FALSE, notNegative: TRUE, value: @data.freeSpace];    items[FormItems.eTablesInOverflowCount.ORD] ¬ FormSW.NumberItem[      tag: "eTablesInOverflowCount "L, place: [21, FormSW.line3], signed: FALSE,      notNegative: TRUE, value: @bucketPage.header.eTablesInOverflowCount];    items[FormItems.noHeader.ORD] ¬ FormSW.TagOnlyItem[      tag: "(no header) "L, place: [21, FormSW.line3]];    items[FormItems.firstFree.ORD] ¬ FormSW.NumberItem[      tag: "firstFree "L, place: [276, FormSW.line3], signed: FALSE,      notNegative: TRUE, value: @bucketPage.header.firstFree];    items[FormItems.currentETable.ORD] ¬ FormSW.TagOnlyItem[      tag: "Current ETable"L, place: [12, FormSW.line4]];    items[FormItems.offset.ORD] ¬ FormSW.NumberItem[      tag: "offset "L, place: [150, FormSW.line4], signed: FALSE,       readOnly: TRUE, value: @data.offset];    items[FormItems.next.ORD] ¬ FormSW.CommandItem[      tag: "Next"L, place: [270, FormSW.line4], proc: Next];    items[FormItems.back.ORD] ¬ FormSW.CommandItem[      tag: "Back"L, place: [318, FormSW.line4], proc: Back];    items[FormItems.first.ORD] ¬ FormSW.CommandItem[      tag: "First"L, place: [365, FormSW.line4], proc: First];    items[FormItems.last.ORD] ¬ FormSW.CommandItem[      tag: "Last"L, place: [420, FormSW.line4], proc: Last];    items[FormItems.fileID.ORD] ¬ FormSW.StringItem[      tag: "fileID"L, place: [21, FormSW.line5], inHeap: TRUE,      filterProc: ValidateFileID, string: @data.fileIDString];    items[FormItems.eTableType.ORD] ¬ FormSW.EnumeratedItem[      tag: "ETable type"L, place: [21, FormSW.line6], feedback: all,      choices: DESCRIPTOR[eTableTypes], proc: ChangeETableVariant,      value: @data.eTableType];    items[FormItems.length.ORD] ¬  FormSW.NumberItem[      tag: "length "L, place: [21, FormSW.line7], invisible: TRUE, signed: FALSE,      notNegative: TRUE, proc: ChangeLength, default: 0, value: @data.length];    items[FormItems.howManyGroups.ORD] ¬ FormSW.NumberItem[      tag: "howManyGroups "L, place: [21, FormSW.line7], signed: FALSE,      notNegative: TRUE, proc: ChangeGroups, default: 0,      value: @data.howManyGroups];    items[FormItems.allShown.ORD] ¬ FormSW.BooleanItem[      tag: "allGroupsInThisPage"L, place: [200, FormSW.line7], readOnly: TRUE,      switch: @data.allShown];    items[FormItems.fill.ORD] ¬  FormSW.NumberItem[      tag: "fill "L, place: [21, FormSW.line8], invisible: TRUE, signed: FALSE,      notNegative: TRUE, proc: ChangeFill, default: 0, value: @data.fill];    items[FormItems.temporary.ORD] ¬ FormSW.BooleanItem[      tag: "temporary"L, place: [21, FormSW.line8], proc: ChangeTemporary,      switch: @data.temporary];    items[FormItems.bootable.ORD] ¬ FormSW.BooleanItem[      tag: "bootable"L, place: [101, FormSW.line8], proc: ChangeBootable,      switch: @data.bootable];    items[FormItems.unused.ORD] ¬ FormSW.NumberItem[      tag: "unused "L, place: [174, FormSW.line8], signed: FALSE,      notNegative: TRUE, proc: ChangeUnused, default: 0, value: @data.unused];    items[FormItems.fileType.ORD] ¬ FormSW.NumberItem[      tag: "type "L, place: [306, FormSW.line8], signed: FALSE,      notNegative: TRUE, proc: ChangeFileType, value: @data.fileType];    FOR i: CARDINAL IN [0..maxedOutPageGroups) DO      -- Setup for max possible number of page groups.      -- Start out all invisible      items[firstPageGroupItem + i*itemsPerPageGroup] ¬ FormSW.LongNumberItem[        tag: "volumePage "L, place: [40, FormSW.nextLine], invisible: TRUE,	signed: FALSE, notNegative: TRUE, proc: ChangeVolumePage,        default: 0, value: @data.pageGroups[i].volumePage];      items[firstPageGroupItem + i*itemsPerPageGroup + 1] ¬ FormSW.NumberItem[        tag: "count "L, place: FormSW.nextPlace, invisible: TRUE,        signed: FALSE, notNegative: TRUE, proc: ChangeCount, default: 0,	value: @data.pageGroups[i].count];      ENDLOOP;    RETURN[items: items, freeDesc: TRUE];    END;  -- MakeETableBucketSW  NewETable: PROCEDURE [offset: ETableOffset, oldGroupCount: CARDINAL] =    BEGIN    data.offset ¬ offset;    currentETable ¬ @bucketPage[offset];    DiskEditInternal.ReplaceFIDString[heapString: @data.fileIDString,      id: currentETable.header.fileID];    SetETableVariant[      variant: IF currentETable.header.fileID = File.nullID THEN free ELSE inuse,      oldGroupCount: oldGroupCount];    END;  -- NewETable  Next:  FormSW.ProcType =    -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL]    BEGIN    nextOffset: ETableOffset ¬ data.offset +      (IF data.eTableType = free THEN data.length        ELSE SIZE[ETable.ETableHeader] + data.howManyGroups *	  SIZE[ETable.PageGroup]);    MsgSW.Clear[DiskEditInternal.msgSW];    -- Eventually instead of the following, it would be nice to try to display    -- the stuff past the last perceived page group.    IF nextOffset > lastETableOffset THEN GOTO noSuchGroup;    NewETable[offset: nextOffset, oldGroupCount: data.howManyGroups];    Redisplay[];    EXITS      noSuchGroup =>        {UserTerminal.BlinkDisplay[];	 Put.Line[DiskEditInternal.msgSW, "Past end of page"L]};    END;  -- Next  NotImplemented: PROCEDURE =    {UserTerminal.BlinkDisplay[]; Put.Line[DiskEditInternal.msgSW,      "Not implemented"L]};  Redisplay: PROCEDURE =    BEGIN    -- Besides the usual redisplay of the whole form after item visibility was    -- changed, this takes care of the possibiliby of the selection and/or the    -- insertion point being left on a newly invisible item.    index: CARDINAL ¬ FormSW.GetSelection[sw].index;    IF index ~= FormSW.nullIndex THEN      {IF FormSW.FindItem[sw, index].flags.invisible        THEN FormSW.SetSelection[sw, FormSW.nullIndex, 0, 0]};    index ¬ FormSW.GetTypeIn[sw].index;    IF index ~= FormSW.nullIndex THEN      {IF FormSW.FindItem[sw, index].flags.invisible        THEN FormSW.SetTypeIn[sw, FormSW.nullIndex, 0]};    FormSW.Display[sw];    END;  SetBucketVariant: PROCEDURE [variant: BucketType] =    BEGIN    -- Sets local values, form item visibility for the items for each type.    normalValue, overflowValue, overflowExtValue: BOOLEAN;    oldOffset: ETableOffset ¬ data.firstETableOffset;    data.bucketType ¬ variant;    SELECT variant FROM      normal =>        BEGIN	data.firstETableOffset ¬ LOOPHOLE[SIZE[ETable.BucketHeader]];	normalValue ¬ FALSE; overflowValue ¬ overflowExtValue ¬ TRUE;	END;      overflow =>        BEGIN	data.firstETableOffset ¬ LOOPHOLE[SIZE[ETable.BucketHeader]];	data.freeSpace ¬ LOOPHOLE[bucketPage.header.freeSpace];	normalValue ¬ overflowExtValue ¬ TRUE; overflowValue ¬ FALSE;	END;      overflowExtention =>        BEGIN	data.firstETableOffset ¬ firstOffsetValue;	data.freeSpace ¬ LOOPHOLE[bucketPage.header.freeSpace];	normalValue ¬ overflowValue ¬ TRUE; overflowExtValue ¬ FALSE;	END;      ENDCASE => RETURN;    IF data.firstETableOffset ~= oldOffset THEN NewETable[      offset: data.firstETableOffset, oldGroupCount: data.howManyGroups];    -- This way of making the form items invisible by hand is not Tools-world    -- kosher but works since we always repaint the form, and it avoids    -- FormSW.ToggleVisibility's repainting the whole form for each item toggled.    FormSW.FindItem[sw, FormItems.eTablesInOverflowCount.ORD].flags.invisible ¬      normalValue;    FormSW.FindItem[sw, FormItems.firstFree.ORD].flags.invisible ¬ normalValue;    FormSW.FindItem[sw, FormItems.freeSpace.ORD].flags.invisible ¬ overflowValue;    FormSW.FindItem[sw, FormItems.firstETableOffset.ORD].flags.invisible ¬      overflowExtValue;    FormSW.FindItem[sw, FormItems.noHeader.ORD].flags.invisible ¬      overflowExtValue;    END;  -- SetBucketVariant  SetETableVariant: PROCEDURE [variant: ETableType, oldGroupCount: CARDINAL] =    BEGIN    -- Sets local values for variant values; makes form items visible/invisible    -- as appropriate to the variant.    freeValue, inuseValue: BOOLEAN;    newGroupCount: CARDINAL;    oldMaxPageGroups: CARDINAL ¬ maxPageGroups;    maxPageGroups ¬      (Environment.wordsPerPage-LOOPHOLE[data.offset]-SIZE[ETable.ETableHeader])        /SIZE[ETable.PageGroup];    data.eTableType ¬ variant;    SELECT variant FROM      inuse =>        BEGIN        data.howManyGroups ¬ currentETable.header.howManyGroups;	data.allShown ¬ data.howManyGroups <= maxPageGroups;        data.temporary ¬ currentETable.header.temporary;        data.bootable ¬ currentETable.header.bootable;        data.unused ¬ currentETable.header.unused;        data.fileType ¬ currentETable.header.type;        FOR i: CARDINAL IN [0..MIN[data.howManyGroups, maxPageGroups]) DO          data.pageGroups[i] ¬ currentETable.pageGroups[i];          ENDLOOP;	freeValue ¬ TRUE; inuseValue ¬ FALSE;        END;      free =>        BEGIN        data.howManyGroups ¬ 0;        data.length ¬ currentETable.header.length;        data.fill ¬ currentETable.header.fill;	freeValue ¬ FALSE; inuseValue ¬ TRUE;	END;      ENDCASE => RETURN;    -- This way of making the form items invisible by hand instead of via    -- FormSW.ToggleVisibility is a hack to avoid the redisplay of the whole    -- form for each item toggled.  It runs the risk that the underlying Tools    -- code could change and invalidate it.    FormSW.FindItem[sw, FormItems.howManyGroups.ORD].flags.invisible ¬ inuseValue;    FormSW.FindItem[sw, FormItems.allShown.ORD].flags.invisible ¬ inuseValue;    FormSW.FindItem[sw, FormItems.temporary.ORD].flags.invisible ¬ inuseValue;    FormSW.FindItem[sw, FormItems.bootable.ORD].flags.invisible ¬ inuseValue;    FormSW.FindItem[sw, FormItems.unused.ORD].flags.invisible ¬ inuseValue;    FormSW.FindItem[sw, FormItems.fileType.ORD].flags.invisible ¬ inuseValue;    FormSW.FindItem[sw, FormItems.length.ORD].flags.invisible ¬ freeValue;    FormSW.FindItem[sw, FormItems.fill.ORD].flags.invisible ¬ freeValue;    newGroupCount ¬ data.howManyGroups;    IF newGroupCount > oldGroupCount THEN  -- more to become visible      FOR i: CARDINAL IN        [firstPageGroupItem + oldGroupCount*itemsPerPageGroup..	 firstPageGroupItem + MIN[newGroupCount, maxPageGroups]*itemsPerPageGroup)        DO FormSW.FindItem[sw, i].flags.invisible ¬ FALSE ENDLOOP    ELSE  -- old > new, make difference invisible (= is noop)      FOR i: CARDINAL IN        [firstPageGroupItem + newGroupCount*itemsPerPageGroup..	 firstPageGroupItem +	   MIN[oldGroupCount, oldMaxPageGroups]*itemsPerPageGroup)        DO FormSW.FindItem[sw, i].flags.invisible ¬ TRUE ENDLOOP;    END;  -- SetETableVariant  ValidateFileID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: File.ID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateFID[data.fileIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE currentETable.header.fileID ¬ LOOPHOLE[id];    END;  -- ValidateFileID  -- Module initialization:  -- Register this subwindow as an alternate view for the data subwindow  WindowSwap.RegisterView[    key: DiskEditInternal.dataWindowKey,    viewName: "ETableBucket"L,    makeFormSW: MakeETableBucketSW,    viewFromDataProc: FillETableBucketSW,    dataFromViewProc: CleanupETableBucketSW];  END...LOG 9-Jun-86  7:59:44   CAJ    Created file.23-Jun-86 13:35:52   CAJ    Correct ETable size calc. for Next.24-Sep-86  9:42:40   CAJ    Add bucket type "overflowExtention", facility to set initial ETable offset, indication of whether all page groups are on this page.  Implement ChangeGroups.    
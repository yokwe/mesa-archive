-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- VMTestCheckImpl.mesa      29-Mar-83 17:57:16 by CAJ -- Virtual memory test program.-- VMTestCheck routines check the results of the corresponding Pilot operation-- against the VMTest database.DIRECTORY  BackingStore USING [Run, TransferProc],  Environment USING [PageCount, PageNumber],  PageMap USING [IsMapped, IsVacant],  Space USING [Access, Class, Life, SwapUnitOption, unknownUsage, Usage],  String USING [AppendLongDecimal],  TryDefs USING [Ck],  VM USING [BackingStoreRuns, GetMapUnitAttributes, GetSwapUnitAttributes,    Interval, nullInterval, Swappability],  VMTestCheck,  VMTestDatabase USING [Attributes, ClearActivating, ClearDeactivating,    ClearForcingOut, FindEnclosedSwapUnits, GetMapUnit, GetPageAttributes,    MapUnit, VerifyMapState],  VMTestSpace USING [GetSpace, ReturnSpace];VMTestCheckImpl: PROGRAM  IMPORTS PageMap, String, TryDefs, VM, VMTestDatabase, VMTestSpace  EXPORTS VMTestCheck =  BEGIN  ------------  -- Global types, constants, variables:  Error: ERROR [type: ErrorType] = CODE;  ErrorType: TYPE = {impossibleCase};  ------------  -- Public procedures - individual operations:  Activate: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    CheckPage: PROCEDURE RETURNS [BOOLEAN] =      BEGIN      RETURN[        IF attr.activating THEN	  -- flag still set => no transfer occurred	  NOT (attr.mapped AND attr.swappable)	  OR NOT attr.alive	  OR PageMap.IsMapped[page]	ELSE  -- activating flag has been cleared by I/O	  (attr.mapped AND attr.swappable AND attr.clean AND attr.alive)];      END;    attr: VMTestDatabase.Attributes;    page: Environment.PageNumber;    pageString: STRING = [20];    FOR page IN [interval.page..interval.page + interval.count) DO      attr ¬ VMTestDatabase.GetPageAttributes[page];      pageString.length ¬ 0;      String.AppendLongDecimal[pageString, page];      TryDefs.Ck["[Activate] page attributes"L, pageString, CheckPage[]];      ENDLOOP;    VMTestDatabase.ClearActivating[interval];    END;  CopyIn: PUBLIC PROCEDURE [interval: VM.Interval, run: BackingStore.Run] =    BEGIN        CheckCopyInAttributes: PROCEDURE RETURNS [BOOLEAN] =      BEGIN      attr: VMTestDatabase.Attributes ¬ VMTestDatabase.GetPageAttributes[page];      IF attr.copyingIn THEN RETURN[FALSE];      IF attr.mapped THEN        BEGIN	IF attr.clean THEN RETURN[FALSE];	IF attr.alive ~= (VM.GetSwapUnitAttributes[page].life = alive)	  THEN RETURN[FALSE];	END;      RETURN[TRUE];      END;    -- It would be nice to do some kind of check with the run contents,    -- e.g., put new seed in run, transfer to page database at transfer time,    -- check here.    page: Environment.PageNumber;    FOR page IN [interval.page..interval.page + interval.count) DO      TryDefs.Ck["CopyIn page attributes"L, NIL,        CheckCopyInAttributes[]];      ENDLOOP;    END;  CopyOut: PUBLIC PROCEDURE [interval: VM.Interval, run: BackingStore.Run] =    BEGIN        CheckCopyOutAttributes: PROCEDURE RETURNS [BOOLEAN] =      BEGIN      attr: VMTestDatabase.Attributes ¬ VMTestDatabase.GetPageAttributes[page];      RETURN [        ~attr.copyingOut AND        (~attr.mapped	 OR ((VM.GetSwapUnitAttributes[page].life = alive) = attr.alive))];      END;    page: Environment.PageNumber;    FOR page IN [interval.page..interval.page + interval.count) DO      TryDefs.Ck["CopyOut page attributes"L, NIL,        CheckCopyOutAttributes[]];      ENDLOOP;    END;  Deactivate: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    CheckPage: PROCEDURE RETURNS [BOOLEAN] =      BEGIN      RETURN[        IF attr.deactivating THEN	  -- flag still set => no transfer occurred	  NOT (attr.mapped AND ~attr.readonly AND attr.swappable)          OR attr.clean	  OR PageMap.IsVacant[page]	ELSE  -- forcingOut flag has been cleared by I/O	  (attr.mapped AND ~attr.readonly AND attr.swappable AND attr.clean)];      END;    attr: VMTestDatabase.Attributes;    page: Environment.PageNumber;    pageString: STRING = [20];    FOR page IN [interval.page..interval.page + interval.count) DO      attr ¬ VMTestDatabase.GetPageAttributes[page];      pageString.length ¬ 0;      String.AppendLongDecimal[pageString, page];      TryDefs.Ck["[Deactivate] page attributes"L, pageString, CheckPage[]];      ENDLOOP;    VMTestDatabase.ClearDeactivating[interval];    -- What happens if you deactivate a dead page? dirty page?    END;  ForceOut: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    CheckPage: PROCEDURE RETURNS [BOOLEAN] =      BEGIN      RETURN[        IF attr.forcingOut THEN	  -- flag still set => no transfer occurred	  NOT (attr.mapped AND ~attr.readonly AND	    VMTestDatabase.GetMapUnit[page].backed)	  OR attr.clean          OR PageMap.IsVacant[page]	ELSE  -- forcingOut flag has been cleared by I/O	  (attr.mapped AND ~attr.readonly AND attr.clean AND attr.alive	     AND VMTestDatabase.GetMapUnit[page].backed)];      END;    attr: VMTestDatabase.Attributes;    page: Environment.PageNumber;    pageString: STRING = [20];    FOR page IN [interval.page..interval.page + interval.count) DO      attr ¬ VMTestDatabase.GetPageAttributes[page];      pageString.length ¬ 0;      String.AppendLongDecimal[pageString, page];      TryDefs.Ck["[ForceOut] page attributes"L, pageString, CheckPage[]];      ENDLOOP;    VMTestDatabase.ClearForcingOut[interval];    END;  GetMapUnitAttributes: PUBLIC PROCEDURE [    page: Environment.PageNumber, mapUnit: VM.Interval, backed: BOOLEAN,    backingStoreRuns: VM.BackingStoreRuns, usage: Space.Usage,    class: Space.Class, swapUnits: Space.SwapUnitOption] =    BEGIN    -- Take the attributes returned by Pilot and compare against database.    --   check model vs. Pilot: if null interval returned, check unmapped    --   check model vs. Pilot: check vs. model attributes    END;  GetSwapUnitAttributes: PUBLIC PROCEDURE [    page: Environment.PageNumber, swapUnit: VM.Interval, access: Space.Access,    life: Space.Life, swappability: VM.Swappability] =    BEGIN    -- Take the attributes returned by Pilot and compare against database.    --   check model vs. Pilot: if null interval returned, check unmapped    --   check model vs. Pilot: check vs. model attributes - swap units    -- A lot more work is required here.    -- There is much in common with Map and Relocate and probably     -- SupplyBackingStore.  Refactoring of Map necessary.    currentPage: Environment.PageNumber;    pageString: STRING = [20];    IF swapUnit = VM.nullInterval THEN      TryDefs.Ck["[GetSwapUnitAttributes] unmapped page"L,        --?--, ~VMTestDatabase.GetPageAttributes[page].mapped]    ELSE      BEGIN      TryDefs.Ck["[GetSwapUnitAttributes] page in interval"L, --?--,        page IN [swapUnit.page..swapUnit.page + swapUnit.count)];      TryDefs.Ck["[GetSwapUnitAttributes] all mapped"L, --?--,        AllMapped[swapUnit]];      END;    FOR currentPage IN [swapUnit.page..swapUnit.page + swapUnit.count) DO      ENDLOOP;    END;  Kill: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    actualKillInterval: VM.Interval ¬      VMTestDatabase.FindEnclosedSwapUnits[interval];    attr: VMTestDatabase.Attributes;    page: Environment.PageNumber;    pageString: STRING = [20];    FOR page IN [interval.page..interval.page + interval.count) DO      attr ¬ VMTestDatabase.GetPageAttributes[page];      IF attr.mapped THEN        BEGIN        pageString.length ¬ 0;        String.AppendLongDecimal[pageString, page];        TryDefs.Ck["[Kill] Pilot vs. database"L, pageString,          (VM.GetSwapUnitAttributes[page].life = alive) = attr.alive];        TryDefs.Ck["[Kill] page attributes"L, pageString, attr.clean];        IF PageInInterval[page, actualKillInterval] THEN          TryDefs.Ck["[Kill] swap unit attributes"L, pageString, ~attr.alive];	END;      ENDLOOP;    END;  MakeReadonly: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    page: Environment.PageNumber;    pageString: STRING = [20];    -- Would be nice to try provoking a write fault.    FOR page IN [interval.page..interval.page + interval.count) DO      pageString.length ¬ 0;      String.AppendLongDecimal[pageString, page];      TryDefs.Ck["readOnly attribute"L, pageString, CheckAccess[page, readOnly]];      ENDLOOP;    END;  MakeResident: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    page: Environment.PageNumber;    pageString: STRING = [20];    FOR page IN [interval.page..interval.page + interval.count) DO      pageString.length ¬ 0;      String.AppendLongDecimal[pageString, page];      TryDefs.Ck[        "resident attribute"L, pageString, CheckSwappability[page, resident]];      ENDLOOP;    END;  MakeSwappable: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    page: Environment.PageNumber;    pageString: STRING = [20];    FOR page IN [interval.page..interval.page + interval.count) DO      pageString.length ¬ 0;      String.AppendLongDecimal[pageString, page];      TryDefs.Ck["swappable attribute"L, pageString,        CheckSwappability[page, swappable]];      ENDLOOP;    END;  MakeWritable: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    page: Environment.PageNumber;    pageString: STRING = [20];    -- Would be nice to try provoking a write fault.    FOR page IN [interval.page..interval.page + interval.count) DO      pageString.length ¬ 0;      String.AppendLongDecimal[pageString, page];      TryDefs.Ck["writable attribute"L, pageString, CheckAccess[page, readWrite]];      ENDLOOP;    END;  Map: PUBLIC PROCEDURE [interval: VM.Interval] =    BEGIN    -- Note: This code makes the chicken/egg assumption that VM procs    -- GetMapUnitAttributes and GetSwapUnitAttributes can be trusted.    CheckBackingStore: PROCEDURE RETURNS [BOOLEAN] =      BEGIN      -- The Pilot version of the backing store runs may be truncated,      -- in number of elements or value of the final element (or both), if      -- the user-supplied backing store is longer than the mapped interval.      IF pilot.backed ~= database.backed THEN RETURN[FALSE];      -- The Backing store is ignored if the map unit is not backed.      IF pilot.backed THEN        BEGIN        numberOfRuns: CARDINAL ¬ LENGTH[pilot.runs];        lastRun: CARDINAL ¬ numberOfRuns - 1;        pageCount: Environment.PageCount ¬ pilot.runs[lastRun].count;        IF numberOfRuns = 0 THEN RETURN[FALSE];        IF numberOfRuns > LENGTH[database.runs] THEN RETURN[FALSE];        FOR i: CARDINAL IN [0..lastRun) DO          IF pilot.runs[i] ~= database.runs[i] THEN RETURN[FALSE];	  pageCount ¬ pageCount + pilot.runs[i].count;	  ENDLOOP;        IF pilot.runs[lastRun].count < database.runs[lastRun].count THEN          {IF pageCount ~= mapUnit.interval.count THEN RETURN[FALSE]};	END;      RETURN[TRUE];      END;    CheckPageAttributes: PROCEDURE RETURNS [BOOLEAN] =      --INLINE--{RETURN[         mapUnit.interval = mapInterval AND         pilot.usage = database.usage AND         pilot.class = database.class]};    CheckSwapOption: PROCEDURE RETURNS [match: BOOLEAN] =      BEGIN      WITH p: pilot.swapOption SELECT FROM        unitary => match ¬	  WITH d: database.swapOption SELECT FROM	    unitary => TRUE,	    uniform => FALSE,	    irregular => FALSE,	    ENDCASE => Error[impossibleCase];	uniform => match ¬	  WITH d: database.swapOption SELECT FROM	    unitary => FALSE,	    uniform => p.size = d.size,	    irregular => FALSE,	    ENDCASE => Error[impossibleCase];	irregular =>	  WITH d: database.swapOption SELECT FROM	    unitary => match ¬ FALSE;	    uniform => match ¬ FALSE;	    irregular =>	      BEGIN	      match ¬ TRUE;	      FOR i: CARDINAL IN [0..LENGTH[p.sizes]) DO	        IF p.sizes ~= d.sizes THEN {match ¬ FALSE; EXIT}		ENDLOOP;	      END;	    ENDCASE => Error[impossibleCase];        ENDCASE => Error[impossibleCase];      END;    CheckSwapUnitAttributes: PROCEDURE RETURNS [BOOLEAN] =      {RETURN        [pilot.access = database.access AND          pilot.swappability = database.swappability AND          (~pilot.backed OR (pilot.life = database.life))]};    CheckSwapUnitBoundaries: PROCEDURE RETURNS [BOOLEAN] =      --INLINE-- BEGIN      swapEndPage: Environment.PageNumber;      IF swapInterval = VM.nullInterval THEN RETURN[TRUE];      swapEndPage ¬ swapInterval.page + swapInterval.count - 1;      RETURN[         (VMTestDatabase.GetPageAttributes[page].attributes.startOfSwapUnit =	   (page = swapInterval.page)) AND  	 (VMTestDatabase.GetPageAttributes[page].attributes.endOfSwapUnit =	   (page = swapEndPage))]      END;    DatabaseAttributes: PROCEDURE [page: Environment.PageNumber]      RETURNS [MapAttributes] =      --INLINE--BEGIN      attr: VMTestDatabase.Attributes ¬ VMTestDatabase.GetPageAttributes[page];      RETURN[        [access: IF attr.readonly THEN readOnly ELSE readWrite,        life:  IF attr.alive THEN alive ELSE dead,        swappability: IF attr.swappable THEN swappable ELSE resident,        backed: mapUnit.backed,        runs: mapUnit.backingStoreRuns,        usage: puntUsage,        class: puntClass,        swapOption: mapUnit.swapUnits]];      END;    MapAttributes: TYPE = RECORD[      access: Space.Access,      life: Space.Life,      swappability: VM.Swappability,      backed: BOOLEAN,      runs: VM.BackingStoreRuns,      usage: Space.Usage,      class: Space.Class,      swapOption: Space.SwapUnitOption];    puntClass: Space.Class = unknown;    puntUsage: Space.Usage = Space.unknownUsage;    database: MapAttributes;    pilot: MapAttributes;    mapInterval: VM.Interval;    mapUnit: VMTestDatabase.MapUnit;    page: Environment.PageNumber;    proc: BackingStore.TransferProc;    runsLength: CARDINAL;    runStorage: VM.BackingStoreRuns ¬ NIL;    swapInterval: VM.Interval ¬ VM.nullInterval;    IF interval.count = 0 THEN GOTO notMapped;    IF (mapUnit ¬ VMTestDatabase.GetMapUnit[interval.page]) = NIL THEN      GOTO notMapped;    -- Genuine mapped interval exists.    runsLength ¬ LENGTH[mapUnit.backingStoreRuns];    runStorage ¬ DESCRIPTOR[      VMTestSpace.GetSpace[runsLength * SIZE[BackingStore.Run], resident],      runsLength];    FOR page IN [interval.page..interval.page + interval.count) DO      [mapInterval, proc, pilot.runs, pilot.usage, pilot.class,	pilot.swapOption] ¬ VM.GetMapUnitAttributes[page, runStorage];      TryDefs.Ck["[Map] interval"L, mapUnit.id,        interval = mapInterval];      IF mapUnit = NIL THEN EXIT;      database ¬ DatabaseAttributes[page];      pilot.backed ¬ proc ~= NIL;      pilot.class ¬ puntClass;  -- for now      pilot.usage ¬ puntUsage;  --  "      [swapInterval, pilot.access, pilot.life, pilot.swappability] ¬	VM.GetSwapUnitAttributes[page];      TryDefs.Ck["[Map] null swap unit"L, mapUnit.id,	swapInterval ~= VM.nullInterval];      TryDefs.Ck["[Map] backing store"L, mapUnit.id,        CheckBackingStore[]];      TryDefs.Ck["[Map] swap unit boundaries"L, mapUnit.id,	CheckSwapUnitBoundaries[]];      TryDefs.Ck["[Map] page swap unit attributes"L, mapUnit.id,	CheckSwapUnitAttributes[]];      TryDefs.Ck["[Map] page attributes"L, mapUnit.id,        CheckPageAttributes[]];      ENDLOOP;    IF runStorage ~= NIL THEN VMTestSpace.ReturnSpace[BASE[runStorage]];    EXITS notMapped => NULL;    END;  Relocate: PUBLIC PROCEDURE [    from: Environment.PageNumber, to: Environment.PageNumber] =    BEGIN    -- IF something moved THEN    --   check all pages in old interval unmapped, new mapped    END;  SupplyBackingStore: PUBLIC PROCEDURE [    page: Environment.PageNumber, backed: BOOLEAN,    backingStoreRuns: VM.BackingStoreRuns] =    BEGIN    -- check model vs. Pilot: check page attributes (?)    -- check model vs. Pilot: check each page backed/not backed (????)    --    (this might involve special process working with AwaitAddressFault    --      and able to terminate itself)    END;  Unmap: PUBLIC PROCEDURE [mapUnit: VMTestDatabase.MapUnit] =    BEGIN    CheckUnmapAttributes: PROCEDURE [page: Environment.PageNumber]      RETURNS [BOOLEAN] =      {RETURN[        (VM.GetMapUnitAttributes[page, runStorage].mapUnit = VM.nullInterval) AND	 ~VMTestDatabase.GetPageAttributes[page].attributes.mapped]};    runsLength: CARDINAL;    runStorage: VM.BackingStoreRuns;    IF mapUnit = NIL THEN RETURN;  -- page was never mapped    runsLength ¬ LENGTH[mapUnit.backingStoreRuns];    runStorage ¬ DESCRIPTOR[      VMTestSpace.GetSpace[runsLength * SIZE[BackingStore.Run], resident],      runsLength];    FOR page: Environment.PageNumber IN      [mapUnit.interval.page..mapUnit.interval.page + mapUnit.interval.count) DO      TryDefs.Ck["[Unmap] page attributes"L, mapUnit.id,        CheckUnmapAttributes[page]];      ENDLOOP;    VMTestSpace.ReturnSpace[BASE[runStorage]];    END;    ------------  -- Private procedures:  AllMapped: PROCEDURE [interval: VM.Interval] RETURNS [BOOLEAN] =    INLINE {RETURN[VMTestDatabase.VerifyMapState[interval, mapped]]};  CheckAccess: PROCEDURE [page: Environment.PageNumber, access: Space.Access]    RETURNS [BOOLEAN] =    BEGIN    attr: VMTestDatabase.Attributes = VMTestDatabase.GetPageAttributes[page];    RETURN[~attr.mapped OR       ((attr.readonly = (access = readOnly)) AND      (VM.GetSwapUnitAttributes[page].access = access))];    END;  CheckSwappability: PROCEDURE [    page: Environment.PageNumber, swappability: VM.Swappability]    RETURNS [BOOLEAN] =    BEGIN    attr: VMTestDatabase.Attributes = VMTestDatabase.GetPageAttributes[page];    RETURN[~attr.mapped OR       ((attr.swappable = (swappability = swappable)) AND      (VM.GetSwapUnitAttributes[page].swappability = swappability))];    END;  PageInInterval: PROCEDURE [page: Environment.PageNumber, interval: VM.Interval]    RETURNS [BOOLEAN] =    {RETURN[(page >= interval.page) AND (page < interval.page + interval.count)]};  ------------  -- Public SIGNALs and ERRORs: none    END.LOG 6-Oct-82 21:37:16   CAJ    Created file.    
-- WindowSwapImpl.mesa  29-Apr-85 14:37:57 by Jose--	Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.DIRECTORY  FormSW USING [ClientItemsProcType, Create, Display, FreeAllItems],  Heap USING [Create, Delete],  Menu USING [Error, Free, Handle, Instantiate, Make, MCRType, Uninstantiate],  Process USING [Yield],  RuntimeInternal USING [Bug],  String USING [CopyToNewString, EquivalentStrings],  TajoOps USING [AllocateWindow, DeallocateWindow],  Tool USING [SwapSWs],  ToolWindow USING [DisplayProcType, GetState, nullBox, WindowForSubwindow],  UserInput USING [CreatePeriodicNotify, PeriodicProcType, WaitNoButtons],  Window USING [Box, Handle, InitializeWindow],  WindowSwap;WindowSwapImpl: MONITOR  IMPORTS    FormSW, Heap, Menu, Process, RuntimeInternal, String, TajoOps, Tool,    ToolWindow, UserInput, Window, WindowSwap  EXPORTS WindowSwap =  BEGIN  -- This implementation has two levels of monitorization.  The module monitor  -- protects the viewsWindowList during creation, deletion, and searching.  -- Serialization for changes to individual view subwindows is provided by  -- the Tools world Notifier.  This is necessary because the Notifier is the  -- only sequencing mechanism used by the Tools window- and menu-handling,  -- and much of WindowSwap is logically inside that.  -- Each WindowSwap function packages up its "monitored" activity  -- into a procedure to run inside the monitor via NotifierAccess, which  -- registers a one-time Notifier proc and handles waiting for completion.  --////////////  -- PUBLIC types, constants, variables, errors:  nullDataFromViewProc: PUBLIC WindowSwap.DataFromViewProc = {};  nullDestroyViewProc: PUBLIC WindowSwap.DestroyViewProc = {};  nullKey: PUBLIC WindowSwap.Key ¬ 0;  nullViewFromDataProc: PUBLIC WindowSwap.ViewFromDataProc = {};  Error: PUBLIC SIGNAL [type: WindowSwap.ErrorType] = CODE;  --////////////  -- private types, constants, variables, errors:  -- A SWObject exists for each subwindow which has registered views. It is  -- created at EstablishViewsWindow time and deleted when the last view is  -- Deregistered.  SW: TYPE = LONG POINTER TO SWObject;  SWObject: TYPE = RECORD [    key: WindowSwap.Key,    menu: Menu.Handle,    menuName: LONG STRING,    currentView: View,    firstView: View,    otherWindows: WindowSwap.OtherWindows,    next: SW];  -- A ViewObject exists for each alternate view registered in a subwindow.  View: TYPE = LONG POINTER TO ViewObject;  ViewObject: TYPE = RECORD [    wh: Window.Handle,    name: LONG STRING,    makeFormSW: FormSW.ClientItemsProcType,    viewFromDataProc: WindowSwap.ViewFromDataProc,    dataFromViewProc: WindowSwap.DataFromViewProc,    destroyViewProc: WindowSwap.DestroyViewProc,    nextView: View];  heap: UNCOUNTED ZONE ¬ NIL;  nextKey: WindowSwap.Key ¬ nullKey + 1;  viewsWindowDeactivated: BOOLEAN ¬ FALSE;  viewsWindowList: SW ¬ NIL;  BugType: TYPE = {bogusMenu, listSmashed};  Bug: PROCEDURE [bug: BugType] = {RuntimeInternal.Bug[bug]};  --///////////////////  -- PUBLIC procedures:  CurrentViewHandle: PUBLIC PROCEDURE [key: WindowSwap.Key]    RETURNS [viewH: Window.Handle] =    -- This procedure returns the window handle for the view currently    -- occupying the swapping subwindow designated by key.    BEGIN    {viewH ¬ GetSWForKey[key].currentView.wh};    -- Note that there is no guarantee that the value of "current view" will    -- stay the same until the caller gets to use the one returned.    END;  DeactivateViewsWindow: PUBLIC PROCEDURE [key: WindowSwap.Key] =    -- This procedure is to be called in the tool's TransitionProc on the    -- active -> inactive transition.    -- This is the complement of ReactivateViewsWindow.    BEGIN    -- TransitionProc is already called inside notifier.    sw: SW ¬ GetSWForKey[      key ! WindowSwap.Error => IF type = noSuchKey THEN GOTO noop];    MenuDown[sw];    sw.currentView.dataFromViewProc[];    sw.menu ¬ FreeMenu[sw.menu];    FOR v: View ¬ sw.firstView, v.nextView UNTIL v = NIL DO      IF v = sw.currentView THEN v.dataFromViewProc[];      v.destroyViewProc[];      IF v ~= sw.currentView THEN DeallocateSW[v.wh];      -- Leave current occupant for Tajo to deallocate      v.wh ¬ NIL;      ENDLOOP;    viewsWindowDeactivated ¬ TRUE;    EXITS noop => NULL;    END;  -- DeactivateViewsWindow  DeregisterAll: PUBLIC PROCEDURE [key: WindowSwap.Key] =    -- This procedure is equivalent to calling DeregisterView for all views    -- registered for a given subwindow.  Unlike DeregisterView, it does not    -- require the current view to be the default view, deregistered last.    BEGIN    sw: SW;    v: View;    DeregisterAllNotifyProc: PROCEDURE =      BEGIN      sw ¬ GetSWForKey[key];      MenuDown[sw];      FOR v ¬ sw.firstView, v.nextView UNTIL v = NIL DO        DeregisterNotifyInternal[sw: sw, v: v];	ENDLOOP;      DeleteViewsWindow[sw];      END;    NotifierAccess[DeregisterAllNotifyProc, key];    END;  -- DeregisterAll  DeregisterView: PUBLIC PROCEDURE [key: WindowSwap.Key, viewName: LONG STRING] =    -- This procedure is the complement of RegisterView.  It removes the    -- subwindow which was registered with the name viewName from the tool's    -- list of alternative views and destroys the subwindow.  When the last    -- view is Deregistered, the views window is retired as well, leaving the    -- most recent occupant in sole possession. The default subwindow (the    -- one used in EstablishViewsWindow) is not destroyed.    BEGIN    errorCode: {noSuchView, viewInUse, null} ¬ null;    sw: SW;    v: View;    DeregisterNotifyProc: PROCEDURE =      BEGIN      sw ¬ GetSWForKey[key];      FOR v ¬ sw.firstView, v.nextView UNTIL v = NIL DO        IF String.EquivalentStrings[viewName, v.name] THEN EXIT;        REPEAT FINISHED => {errorCode ¬ noSuchView; RETURN}        ENDLOOP;      MenuDown[sw];      IF v ~= sw.currentView THEN        BEGIN        DeregisterNotifyInternal[sw: sw, v: v];        IF sw.menu ~= NIL THEN {RebuildMenu[sw]; MenuUp[sw]};	END      ELSE        BEGIN        IF ~(v = sw.firstView AND v.nextView = NIL) THEN	  {errorCode ¬ viewInUse; RETURN};        DeregisterNotifyInternal[sw: sw, v: v];        DeleteViewsWindow[sw];	END;      END;  -- DeregisterNotifyProc    NotifierAccess[DeregisterNotifyProc, key];    IF errorCode ~= null THEN SIGNAL WindowSwap.Error[      IF errorCode = noSuchView THEN noSuchView ELSE viewInUse];    END;  -- DeregisterView  EstablishViewsWindow: PUBLIC PROCEDURE [    menuName: LONG STRING, viewH: Window.Handle, viewName: LONG STRING,    viewFromDataProc: WindowSwap.ViewFromDataProc,    dataFromViewProc: WindowSwap.DataFromViewProc,    destroyViewProc: WindowSwap.DestroyViewProc,    otherWindows: WindowSwap.OtherWindows]    RETURNS [key: WindowSwap.Key] =    -- This procedure designates a tool subwindow as one in which alternate view    -- subwindows will swap and registers the default formSW occupant    -- of the subwindow.  (Use RegisterView for subsequent views.)  This    -- subwindow, identified by its window handle viewH, belongs to the host    -- tool rather than WindowSwap: it is initially created (via Tool.MakeFormSW    -- in the MakeSWsProc passed to Tool.Create) and maintained through    -- deactivate/activate by the tool as a non-view-swapping subwindow would be.    -- EstablishViewsWindow is called after the Tool.Create.  The string    -- menuName is the title for the menu of alternate views registered in the    -- subwindow. The view implementor provides the name that goes into the menu,    -- the procedure to create the form, and procedures which the view handler    -- calls to have the implementor deal with the mapping back and forth    -- between the raw data and the view formatting of the data.  The    -- destroyViewProc procedure is called when the view is about to be destroyed.    -- Optionally, otherWindows can specify a list of additional windows in which    -- the views menu is to appear.  The key returned is used to identify the    -- particular views window.  Parameters are copied.    BEGIN    sw: SW;    Windows: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF Window.Handle];    w: LONG POINTER TO Windows;    EstablishNotifierProc: PROCEDURE =      {RebuildMenu[sw]; AddToSWList[sw]; MenuUp[sw]};    IF viewName = NIL OR viewH = NIL THEN      SIGNAL WindowSwap.Error[invalidParameters];    IF heap = NIL THEN      heap ¬ Heap.Create[initial: 4, increment: 1, swapUnitSize: 1];    sw ¬ heap.NEW[SWObject];    key ¬ sw.key ¬ NewKey[];    sw.menuName ¬ String.CopyToNewString[menuName, heap];    sw.currentView ¬ sw.firstView ¬ MakeViewObject[      viewH, viewName, NIL, viewFromDataProc, dataFromViewProc, destroyViewProc];    w ¬ heap.NEW[Windows [LENGTH[otherWindows]]];    FOR i: CARDINAL IN [0..LENGTH[otherWindows]) DO      w[i] ¬ otherWindows[i]; ENDLOOP;    sw.otherWindows ¬ DESCRIPTOR[w, LENGTH[otherWindows]];    sw.menu ¬ NIL;    NotifierAccessGuts[EstablishNotifierProc, viewH];    END;  -- EstablishViewsWindow  ReactivateViewsWindow: PUBLIC PROCEDURE [    key: WindowSwap.Key, defaultSW: Window.Handle,    otherWindows: WindowSwap.OtherWindows] =    -- This procedure recreates all the view subwindows and rebuilds the menu    -- after they have been deactivated.  It belongs in the MakeSWsProc (passed    -- to Tool.Create) as the procedure to be called on invocations subsequent    -- to tool creation (i.e., tool being activated after being deactivated).    -- A useful way to do this is the following:    --    IF key ~= WindowSwap.nullKey THEN ReactivateViewsWindow[...];    -- If the subwindows were not deleted, (DeactivateViewsWindow was not    -- called), it does not recreate them. If key is null then    -- ReactivateViewsWindow is a noop.    -- This should be called from inside the notifier (e.g., in the MakeSWsProc).    BEGIN    sw: SW;    IF key = WindowSwap.nullKey THEN RETURN;    sw ¬ GetSWForKey[key];    FOR v: View ¬ sw.firstView.nextView, v.nextView UNTIL v = NIL DO      IF v.wh = NIL THEN v.wh ¬ MakeViewFormSW[v.makeFormSW]; ENDLOOP;    sw.currentView ¬ sw.firstView;    sw.firstView.wh ¬ defaultSW;  -- window handles have been recreated    FOR i: CARDINAL IN [0..LENGTH[otherWindows]) DO      sw.otherWindows[i] ¬ otherWindows[i]; ENDLOOP;    sw.currentView.viewFromDataProc[];    viewsWindowDeactivated ¬ FALSE;    RebuildMenu[sw];    MenuUp[sw];    END;  -- ReactivateViewsWindow  RegisterView: PUBLIC PROCEDURE [    key: WindowSwap.Key, viewName: LONG STRING,    makeFormSW: FormSW.ClientItemsProcType,    viewFromDataProc: WindowSwap.ViewFromDataProc,    dataFromViewProc: WindowSwap.DataFromViewProc,    destroyViewProc: WindowSwap.DestroyViewProc] =    -- This procedure creates and registers a subwindow which provides a view,    -- or particular formatting, of the data in the tool's global data buffer.    -- Registering adds viewName to the menu of alternatives available for the    -- subwindow identified by key. The makeFormSW procedure is used to set up    -- the window layout. The viewFromData and dataFromView procedures are    -- provided for the view handler to call to have the implementor deal with    -- the mapping back and forth between the raw data and the view formatting    -- of the data. The destroyViewProc procedure is called when the view is    -- about to be destroyed.  The string is copied.    -- A view may be registered in an inactive window.    BEGIN    sw: SW;    view: View;    RegisterNotifyProc: PROCEDURE =      BEGIN      sw ¬ GetSWForKey[key];      MenuDown[sw];      AddToViewList[view, sw];      IF sw.menu ~= NIL THEN {RebuildMenu[sw]; MenuUp[sw]};      END;  -- RegisterNotifyProc    IF viewName = NIL THEN SIGNAL WindowSwap.Error[invalidParameters];    view ¬ MakeViewObject[      MakeViewFormSW[makeFormSW], viewName, makeFormSW, viewFromDataProc,      dataFromViewProc, destroyViewProc];    NotifierAccess[RegisterNotifyProc, key];    END;  -- RegisterView  UpdateDataFromView: PUBLIC PROCEDURE [key: WindowSwap.Key] =    -- This procedure calls the DataFromViewProc procedure registered for    -- the current view in the subwindow identified by key. It is normally    -- called when the underlying raw data, owned by the tool, must be made to    -- correspond to any changes in local view contents, such as when the data    -- is about to be written out.    BEGIN    dataFromViewProc: WindowSwap.DataFromViewProc ¬      GetSWForKey[key].currentView.dataFromViewProc;    dataFromViewProc[];    END;  UpdateViewFromData: PUBLIC PROCEDURE [key: WindowSwap.Key] =    -- This procedure calls the ViewFromDataProc procedure registered for    -- the current view in the subwindow identified by key. This causes any    -- local view data to be updated to match the raw data. It is normally    -- called after a change in the data, which is owned by the tool, such    -- as when new data is read in.    BEGIN    viewFromDataProc: WindowSwap.ViewFromDataProc ¬      GetSWForKey[key].currentView.viewFromDataProc;    viewFromDataProc[];    END;  --///////////////////  -- private procedures:  AddToSWList: ENTRY PROCEDURE [sw: SW] =    -- Add to list of subwindows containing view choices.    {sw.next ¬ viewsWindowList; viewsWindowList ¬ sw};  AddToViewList: PROCEDURE [view: View, sw: SW] =    -- Add to list of alternate views for this subwindow.    BEGIN    v: View;    -- View added to end of list, keeping the first registered the default.    FOR v ¬ sw.firstView, v.nextView UNTIL v.nextView = NIL DO ENDLOOP;    v.nextView ¬ view;    END;  -- AddToViewList  DeallocateSW: PROCEDURE [wh: Window.Handle] =    -- Get rid of Tajo's notion of the view subwindow.    -- Doesn't deal with WindowSwap's notion of the subwindow.    -- This shouldn't be done to the default view subwindow.    BEGIN    IF wh ~= NIL THEN      {FormSW.FreeAllItems[wh]; TajoOps.DeallocateWindow[wh]};    END;  -- DeallocateSW  DeleteViewObject: PROCEDURE [view: View, sw: SW] =    -- Remove view from list of alternates for subwindow and give back the View    -- and any resources it used.    BEGIN    v: View;    IF sw.firstView = view THEN sw.firstView ¬ view.nextView    ELSE      BEGIN      FOR v ¬ sw.firstView, v.nextView UNTIL v = NIL DO        IF v.nextView = view THEN EXIT;        REPEAT FINISHED => Bug[listSmashed];        ENDLOOP;      v.nextView ¬ v.nextView.nextView;      END;    heap.FREE[@view.name];    heap.FREE[@view];    END;  -- DeleteViewObject  DeleteViewsWindow: ENTRY PROCEDURE [sw: SW] =    -- Delete from list of subwindows containing view choices, destroy the menu,    -- and free up data structure's storage.    BEGIN    IF viewsWindowList = sw THEN viewsWindowList ¬ sw.next    ELSE      BEGIN      s: SW;      FOR s ¬ viewsWindowList, s.next UNTIL s = NIL DO        IF s.next = sw THEN EXIT; REPEAT FINISHED => Bug[listSmashed]; ENDLOOP;      FOR s ¬ viewsWindowList, s.next UNTIL s.next = sw DO ENDLOOP;      s.next ¬ sw.next;      END;    [] ¬ FreeMenu[sw.menu];    heap.FREE[@sw.menuName];    heap.FREE[@(BASE[sw.otherWindows])];    heap.FREE[@sw];    -- If that was the last swappable subwindow, then WindowSwap is going    -- inactive so we dump resources.    IF viewsWindowList = NIL THEN {      Heap.Delete[z: heap, checkEmpty: TRUE]; heap ¬ NIL};    END;  -- DeleteViewsWindow  DeregisterNotifyInternal: PROCEDURE [sw: SW, v: View] =    -- This is common guts for NotifyProcs in DeregisterView and DeregisterAll.    -- It is assumed to be called from within a Notify proc.    BEGIN    IF v = sw.currentView THEN v.dataFromViewProc[];    v.destroyViewProc[];    IF v ~= sw.currentView THEN DeallocateSW[v.wh]; -- Tajo needs current view SW    DeleteViewObject[v, sw];    END;  -- DeregisterNotifyInternal  FreeMenu: PROCEDURE [menu: Menu.Handle] RETURNS [Menu.Handle] = {    IF menu ~= NIL THEN Menu.Free[menu: menu, freeStrings: TRUE]; RETURN[NIL]};  GetSWForKey: ENTRY PROCEDURE [key: WindowSwap.Key] RETURNS [sw: SW] =    -- Find the views subwindow object which corresponds to key.    BEGIN    FOR sw ¬ viewsWindowList, sw.next UNTIL sw = NIL DO      IF sw.key = key THEN EXIT;      REPEAT FINISHED => RETURN WITH ERROR WindowSwap.Error[noSuchKey];      ENDLOOP;    END;  -- GetSWForKey  MakeViewFormSW: PROCEDURE [makeFormProc: FormSW.ClientItemsProcType]    RETURNS [wh: Window.Handle] =    -- This procedure creates the Form subwindow for a swappable view subwindow.    -- It is a normal form subwindow except that it is not part of a tool window.    BEGIN    CreateUnattachedSubwindow: PROCEDURE [      display: ToolWindow.DisplayProcType ¬ NIL,      box: Window.Box ¬ ToolWindow.nullBox] RETURNS [Window.Handle] =      BEGIN      -- This procedure is almost like ToolWindow.CreateSubwindow, but it creates      -- a subwindow which is not attached to a particular tool window parent      -- and thus can be swapped with like subwindows in a single subwindow.      window: Window.Handle ¬ TajoOps.AllocateWindow[];      Window.InitializeWindow[window, display, box, NIL];      RETURN[window]      END;  -- CreateUnattachedSubwindow    FormSW.Create[      sw: wh ¬ CreateUnattachedSubwindow[box: ToolWindow.nullBox],      initialState: active, clientItemsProc: makeFormProc,      options: [type: fixed]];    END;  -- MakeViewFormSW  MakeViewObject: PROCEDURE [    wh: Window.Handle, name: LONG STRING, makeFormSW: FormSW.ClientItemsProcType,    viewFromDataProc: WindowSwap.ViewFromDataProc,    dataFromViewProc: WindowSwap.DataFromViewProc,    destroyViewProc: WindowSwap.DestroyViewProc] RETURNS [view: View] =    -- Allocate and build data structure with information about a particular view.    BEGIN    view ¬ heap.NEW[ViewObject];    view^ ¬ [      wh: wh, name: String.CopyToNewString[name, heap], makeFormSW: makeFormSW,      viewFromDataProc: viewFromDataProc, dataFromViewProc: dataFromViewProc,      destroyViewProc: destroyViewProc, nextView: NIL];    END;  -- MakeView  MenuDown: PROCEDURE [sw: SW] =    -- This procedure takes away the view menu from the view swap subwindow    -- and any other subwindows in which it appears. It is a noop if menu is    -- NIL or if the menu has already been uninstantiated.    BEGIN    IF viewsWindowDeactivated OR (sw.menu = NIL) THEN RETURN;    UserInput.WaitNoButtons[];  -- this is probably redundant in notifier    Menu.Uninstantiate[      menu: sw.menu, window: sw.currentView.wh !      Menu.Error =>        SELECT code FROM          alreadyInstantiated => CONTINUE;          contextNotAvailable =>  -- see comment on equivalent in MenuUp            {viewsWindowDeactivated ¬ TRUE; sw.menu ¬ NIL; GOTO bailOut};          ENDCASE => REJECT];    FOR i: CARDINAL IN [0..LENGTH[sw.otherWindows]) DO      Menu.Uninstantiate[        menu: sw.menu, window: sw.otherWindows[i] !        Menu.Error => IF code = notInstantiated THEN CONTINUE ELSE REJECT];      ENDLOOP;    EXITS bailOut => NULL;    END;  -- MenuDown  MenuSelectProc: Menu.MCRType =    -- [window: Window.Handle, menu: Menu.Handle, index: CARDINAL]--    -- This procedure is called whenever an item on a registered views menu    -- is selected.    BEGIN    newView, oldView: View;    sw: SW;    toolWindow: Window.Handle;    -- find sw which owns the menu just selected    FOR sw ¬ viewsWindowList, sw.next UNTIL sw = NIL DO      IF menu = sw.menu THEN EXIT;      REPEAT FINISHED => Bug[bogusMenu];      -- If this proc got called, that menu belongs to somebody      ENDLOOP;    newView ¬ sw.firstView;    THROUGH [0..index) DO newView ¬ newView.nextView ENDLOOP;    IF newView.wh = sw.currentView.wh THEN RETURN;  -- same one    toolWindow ¬ ToolWindow.WindowForSubwindow[sw.currentView.wh];    oldView ¬ sw.currentView;    Menu.Uninstantiate[menu, oldView.wh];    oldView.dataFromViewProc[];    sw.currentView ¬ newView;    newView.viewFromDataProc[];    FormSW.Display[newView.wh];  -- gets around Tools bug: caches not invalidated    [] ¬ Tool.SwapSWs[toolWindow, oldView.wh, newView.wh];    Menu.Instantiate[menu, newView.wh];    END;  -- MenuSelectProc  MenuUp: PROCEDURE [sw: SW] =    -- This procedure puts up the view menu from the view swap subwindow    -- and any other subwindows in which it appears.  If the tool is currently    -- inactive then MenuUp is a noop.    -- Because of the delay before execution of procs inside the Notifier,    -- MenuUp needs to be resilient to menus having already been brought up.    BEGIN    IF      (ToolWindow.GetState[ToolWindow.WindowForSubwindow[sw.currentView.wh]] =        inactive)  -- GetState lies if deactivate is in progress.      OR viewsWindowDeactivated THEN RETURN;    Menu.Instantiate[      menu: sw.menu, window: sw.currentView.wh !      Menu.Error =>        SELECT code FROM          alreadyInstantiated => CONTINUE;          contextNotAvailable => {            viewsWindowDeactivated ¬ TRUE; sw.menu ¬ NIL; GOTO bailOut};          -- This egregious kludge is to deal with the case (which we cannot          -- identify before the error) where view registering began after          -- initiation of a deactivate, which is still in progress.  GetState          -- is claiming the tool is active, but for our purposes it is inactive          -- since the menu has already been freed.  We just want to bail out.          ENDCASE => REJECT];    FOR i: CARDINAL IN [0..LENGTH[sw.otherWindows]) DO      Menu.Instantiate[        menu: sw.menu, window: sw.otherWindows[i] !        Menu.Error => IF code = alreadyInstantiated THEN CONTINUE ELSE REJECT];      ENDLOOP;    EXITS bailOut => NULL;    END;  -- MenuUp  NewKey: PROCEDURE RETURNS [key: WindowSwap.Key] = INLINE {    key ¬ nextKey; nextKey ¬ nextKey + 1};  NotifierAccess: PROCEDURE [proc: PROCEDURE, key: WindowSwap.Key] =    BEGIN    -- CALLERS OF NotifierAccess BEWARE:  All kinds of inconvenient things    -- can happen while we are waiting for the notifier to get to the    -- CreatePeriodicNotify proc.  For instance, the current view can be    -- Deregistered or replaced, or the tool can be deactivated.    NotifierAccessGuts[proc, GetSWForKey[key].currentView.wh];    -- Note that this GetSWFor Key accesses the viewsWindowList unprotected,    -- and there is the small but unavoidable chance that we will crash here...    END;  -- NotifierAccess  NotifierAccessGuts: PROCEDURE [proc: PROCEDURE, w: Window.Handle] =    BEGIN    -- This version exists separately for EstablishViewsWindow, whose key is    -- not usable until its proc completes, but which already has its hands    -- on a real window handle.    waitingForProcCompletion: BOOLEAN;    WindowSwapInsideNotifier: UserInput.PeriodicProcType =      BEGIN proc[]; waitingForProcCompletion ¬ FALSE; END;    waitingForProcCompletion ¬ TRUE;    [] ¬ UserInput.CreatePeriodicNotify[      proc: WindowSwapInsideNotifier, window: w, rate: 0];    -- window value is to make tools world happy - we don't use it    WHILE waitingForProcCompletion DO Process.Yield ENDLOOP;    END;  -- NotifierAccess  RebuildMenu: PROCEDURE [sw: SW] =    BEGIN    -- Destroy the current menu, if any, and build a new menu of all the    -- currently registered views.    Strings: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF LONG STRING];    count: CARDINAL ¬ 0;    s: LONG POINTER TO Strings;    v: View;    -- count the views so we know how big an array to make    FOR v ¬ sw.firstView, v.nextView UNTIL v = NIL DO count ¬ count + 1 ENDLOOP;    -- now build the array of name strings    s ¬ heap.NEW[Strings [count] ¬ TRASH];    v ¬ sw.firstView;    FOR i: CARDINAL IN [0..count) DO s[i] ¬ v.name; v ¬ v.nextView; ENDLOOP;    [] ¬ FreeMenu[sw.menu];    sw.menu ¬ Menu.Make[      name: sw.menuName, strings: DESCRIPTOR[s, count], mcrProc: MenuSelectProc,      copyStrings: TRUE];    heap.FREE[@s];    END;  -- RebuildMenu  --///////////////////  -- Mainline code:  END.LOG 6-Aug-84 14:36:55	Jose	Created file.29-Apr-85 14:33:38	Jose	Separated monitorization into MONITOR for view list protection and Tools Notifier for sequencing view activity.  Added DeactivateAll, DestroyViewProc stuff; changed Error from ERROR to SIGNAL.  Deactivate frees sw items.
-- Copyright (C) 1984, 1985, 1987, 1988  by Xerox Corporation. All rights reserved. --MugParam.mesa	last edited by: CAJ       5-May-88 16:15:10-- Parameter Subwindow handling for the Disk Torment-and-Scavenge ToolDIRECTORY  BackingStore USING [Run],  DiskBackingStore USING [DiskDataFromBSData],  DiskChannel USING [DiskPageNumber],  File USING [File, ID, GetSize, lastPageNumber, nullID, PageNumber, Unknown],  FileTypes USING [tUnassigned],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedDescriptor, EnumeratedItem,    EnumeratedNotifyProcType, FilterProcType, line0, line1, line2, line3,    LongNumberItem, LongNumberNotifyProcType, nextPlace, NotifyProcType,    ProcType, StringEditProc, StringItem, TagOnlyItem],  MugInternal USING [BadCommand, heap, Mode, NewCommand, String, toolData,    Unimplemented, ValidDiskPage],  SpecialFile USING [GetBackingStoreRun],  String USING [AppendSubString, Copy, InvalidNumber, StringToOctal,    SubString, SubStringDescriptor],  UserTerminal USING [BlinkDisplay],  Volume USING [GetLabelString, GetNext, ID, NotOpen, nullID, TypeSet];MugParam: PROGRAM  IMPORTS DiskBackingStore, File, FormSW, MugInternal, SpecialFile, String,    UserTerminal, Volume  EXPORTS MugInternal SHARES File =  BEGIN  -- Public variables  nVolumes: PUBLIC CARDINAL ¬ 0;    -- volumeDescriptor is used also by Scavenge SW for Scavenge log volume  volumeDescriptor: PUBLIC FormSW.EnumeratedDescriptor ¬ NIL;  -- Private variables  filePageIndex: CARDINAL;  pvPageIndex: CARDINAL;    MakeParamSW: PUBLIC FormSW.ClientItemsProcType =    BEGIN OPEN F: FormSW, M: MugInternal;    i: CARDINAL ¬ 0;    nItems: CARDINAL = 9;    modeArray: ARRAY [0..3) OF F.Enumerated ¬ [      ["interactive"L, M.Mode[interactive]], ["script"L, M.Mode[script]],      ["exercise"L, M.Mode[exercise]]];    set: Volume.TypeSet =      [normal: TRUE, debugger: TRUE, debuggerDebugger: TRUE, nonPilot: FALSE];    volID: Volume.ID;    volName: STRING ¬ [80];    Allocate: PROC [words: CARDINAL] RETURNS [LONG POINTER] = INLINE      {hunk: TYPE = RECORD[ s: SEQUENCE COMPUTED CARDINAL OF WORD];      RETURN[MugInternal.heap.NEW[hunk[words]]]};    nVolumes ¬ 0;    FOR volID ¬ Volume.GetNext[Volume.nullID, set], Volume.GetNext[volID, set]      UNTIL volID = Volume.nullID DO nVolumes ¬ nVolumes + 1 ENDLOOP;    M.toolData.volIDs ¬ DESCRIPTOR[      Allocate[SIZE[Volume.ID]*nVolumes], nVolumes];    volumeDescriptor ¬ DESCRIPTOR[      Allocate[SIZE[F.Enumerated]*nVolumes], nVolumes];    -- Descriptor is freed after Scavenge SW has been created    volID ¬ Volume.nullID;    FOR i: CARDINAL IN [0..nVolumes) DO      volID ¬ Volume.GetNext[volID, set];      Volume.GetLabelString[volID, volName];      volumeDescriptor[i].string ¬        MugInternal.heap.NEW[StringBody[volName.length]];      String.Copy[to: volumeDescriptor[i].string, from: volName];      volumeDescriptor[i].value ¬ i;      M.toolData.volIDs[i] ¬ volID;      ENDLOOP;    items ¬ F.AllocateItemDescriptor[nItems];    items[i] ¬ F.EnumeratedItem[      tag: "Target Volume"L, feedback: one, place: [0, F.line0],      value: @M.toolData.volume, choices: volumeDescriptor];    items[i¬i+1] ¬ F.EnumeratedItem[      tag: "Mode"L, place: [225, F.line0], feedback: one, value: @M.toolData.mode,      choices: DESCRIPTOR[modeArray], proc: ChangeMode];    items[i¬i+1] ¬ F.BooleanItem[      tag: "Verbose Log"L, place: [370, F.line0], switch: @M.toolData.verbose,      proc: ChangeVerbose];    items[i¬i+1] ¬ F.StringItem[      tag: "File Page:  [FileID"L, inHeap: TRUE, place: [0, F.line1],      string: @M.toolData.fileIDString, filterProc: ValidateFileID];    items[filePageIndex ¬ i¬i+1] ¬ F.LongNumberItem[      tag: "File page# (decimal)"L, place: [75, F.line2], signed: FALSE,      notNegative: TRUE, radix: decimal, default: 0, value: @M.toolData.filePage,      proc: ValidateFilePage];    items[i¬i+1] ¬ F.TagOnlyItem[      tag: "]"L, place: [265, F.line2]];    items[i¬i+1] ¬ F.CommandItem[      tag: "PV page -> File page"L, place: [295, F.line2], proc: ConvertPVPage];    items[pvPageIndex ¬ i¬i+1] ¬ F.LongNumberItem[      tag: "PV page# (decimal)"L, place: [0, F.line3], signed: FALSE,      notNegative: TRUE, radix: decimal, default: 0, value: @M.toolData.pvPage,      proc: ValidateDiskPage];    items[i¬i+1] ¬ F.CommandItem[      tag: "File page -> PV page"L, place: [295, F.line3], proc: ConvertFilePage];    RETURN[items: items, freeDesc: TRUE];    END;    ChangeMode: FormSW.EnumeratedNotifyProcType =    BEGIN    IF MugInternal.toolData.mode ~= interactive THEN      BEGIN      MugInternal.Unimplemented[];      MugInternal.toolData.mode ¬ interactive;      FormSW.DisplayItem[sw, index];      END;    END;    ChangeVerbose: FormSW.NotifyProcType =    BEGIN    MugInternal.Unimplemented[];    MugInternal.toolData.verbose ¬ FALSE;    FormSW.DisplayItem[sw, index];    END;    ConvertFilePage: FormSW.ProcType =    -- Command: "File page -> PV page"    BEGIN    ok: BOOLEAN;    page: DiskChannel.DiskPageNumber;    MugInternal.NewCommand[];    [ok, page] ¬ FilePageToPVPage[      MugInternal.toolData.fileID, MugInternal.toolData.filePage];    IF ok THEN      BEGIN      MugInternal.toolData.pvPage ¬ page;      FormSW.DisplayItem[sw, pvPageIndex];      END    END;  ConvertPVPage: FormSW.ProcType =    -- Command: "PV page -> File page"    {MugInternal.Unimplemented[]};  FilePageToPVPage: PUBLIC PROC [fID: File.ID, fPage: File.PageNumber]      RETURNS [ok: BOOLEAN, page: DiskChannel.DiskPageNumber] =    BEGIN    file: File.File ¬      [fID, MugInternal.toolData.volIDs[MugInternal.toolData.volume]];    run: BackingStore.Run;    ok ¬ fPage < File.GetSize[file ! File.Unknown => GOTO noSuchFile;                                     Volume.NotOpen => GOTO notOpen;];    IF ~ok THEN GOTO illegalPage;    run ¬ SpecialFile.GetBackingStoreRun[file, fPage, FileTypes.tUnassigned].run;    page ¬ DiskBackingStore.DiskDataFromBSData[run.data].volumePage;        EXITS      illegalPage =>        BEGIN        MugInternal.BadCommand["Illegal file page"L];        RETURN[FALSE,0];	END;      noSuchFile =>        BEGIN	MugInternal.BadCommand["No such file"L];	RETURN[FALSE,0];	END;      notOpen =>        BEGIN	MugInternal.BadCommand["Volume not open"L];	RETURN[FALSE,0];	END;    END;  --PVPageToFilePage: PUBLIC PROC [pvPage: DiskChannel.DiskPageNumber]  --    RETURNS [fID: File.ID, fPage: File.PageNumber] =  --  {};      ValidateDiskPage: FormSW.LongNumberNotifyProcType =    BEGIN    IF ~MugInternal.ValidDiskPage[MugInternal.toolData.pvPage] THEN      BEGIN      MugInternal.BadCommand["Invalid page, leaving unchanged"L];      MugInternal.toolData.pvPage ¬ oldValue;      FormSW.DisplayItem[sw, pvPageIndex];      END;    END;    ValidateFileID: FormSW.FilterProcType =    BEGIN    id: File.ID;    valid: BOOLEAN;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ ValidateUID[MugInternal.toolData.fileIDString];    IF ~ valid THEN UserTerminal.BlinkDisplay[]    ELSE MugInternal.toolData.fileID ¬ LOOPHOLE[id];    END;  ValidateFilePage: FormSW.LongNumberNotifyProcType =    BEGIN    IF MugInternal.toolData.filePage ~IN [0.. File.lastPageNumber)     THEN       {UserTerminal.BlinkDisplay[];        MugInternal.toolData.filePage ¬ oldValue;	FormSW.DisplayItem[sw, filePageIndex]};    END;    ValidateUID: PUBLIC PROCEDURE [s: MugInternal.String]     RETURNS [valid: BOOLEAN, id: File.ID] =    BEGIN    currentNumber: STRING ¬ [64];    startPos: CARDINAL;    curPos: CARDINAL;    len: CARDINAL;    subStringDesc: String.SubStringDescriptor;    subString: String.SubString ¬ @subStringDesc;    p: POINTER TO ARRAY[0..SIZE[File.ID]) OF UNSPECIFIED = LOOPHOLE[@id];    id ¬ File.nullID;    valid ¬ TRUE;    -- Skip over any leading characters that are not octal digits    FOR startPos IN [0..s.length) DO       IF s[startPos] IN ['0..'7] THEN EXIT;       REPEAT       FINISHED => GO TO nullReturn; -- a bogus UID was given       ENDLOOP;    -- Now process each word of the UID    FOR word: [0..SIZE[File.ID]) IN [0..SIZE[File.ID]) DO       -- parse each word       curPos ¬ startPos;       WHILE s[curPos] IN ['0..'7] DO         curPos ¬ curPos+1;         IF curPos >= s.length THEN RETURN; -- Truncate the UID         ENDLOOP;       IF s[curPos] = 'B OR s[curPos] = 'b THEN len ¬ curPos-startPos+1          ELSE len ¬ curPos-startPos;       currentNumber.length ¬ 0;       subString­ ¬ [s, startPos, len];       String.AppendSubString[          to: currentNumber, from: subString];       p[word] ¬ String.StringToOctal[currentNumber !          String.InvalidNumber => GO TO nullReturn];       startPos ¬ startPos+len;       UNTIL s[startPos] IN ['0..'7] DO         startPos ¬ startPos+1;         IF startPos >= s.length THEN RETURN; -- Truncate the UID         ENDLOOP;       ENDLOOP;    EXITS    nullReturn => RETURN[FALSE, File.nullID];    END;    END.LOG  Time:   10-Sep-81 15:23:26  By: CAJ 	 Action: Created file.    Time:    5-Dec-81 12:06:51  By: CAJ 	 Action: Convert to 8.0e; don't set toolData.pvPage if conversion fails.    Time:   12-Apr-83 17:32:37  By: EKN    Action: Converted to Klamath (Deleted references to KernelFile.GetFilePoint by using SpecialFile.GetBackingStoreRun and DiskBackingStore Procedures.  Changed File.Capabilty to File.File  Time:   14-Jun-84 16:56:55  By: CAJ 	 Action: Allocate descriptors from Heap instead of Storage interface.    Time:    7-Nov-85 16:23:41  By: RSV    Action: Added line nVolumes ¬ 0 in MakeParamSW.Allocate to fix crashing during reactivate (AR 2375).  Also put in catch phrase for Volume.NotOpen in FilePageToPVPage.  Time:   12-Nov-85 15:24:28  By: RSV    Action: Fixed enumerating volumes string problem in MakeParamSW by using MugInternal.heap.NEW[StringBody[x]] instead of Allocate[x].  Time:    6-Oct-87 14:32:33  By: RSV    Action: Take out references to VMMapLog and VMMapLogInternal.  Time:   15-Dec-87 12:10:18  By: CAJ    Action: Make page numbers decimal.  Time:    5-May-88 16:13:47  By: CAJ    Action: Refused page values redisplay old value.  Make file page item space big enough.
-- Copyright (C) 1984, 1986  by Xerox Corporation. All rights reserved. -- TomPImpl.mesa  (last edited by RSV      7-Nov-86 14:26:41)-- This module maintains the list of registered interfaces,-- exporting its routines to the TomP and TomOps interfaces. -- The TomP.Register routine will be used by those wishing to -- register interfaces routines;  all other routines (in TomOps)-- will be used by the Tom tool to interrogate the list of registered codeDIRECTORY  Courier USING [Arguments, Call, Create, Delete, Description, Dispatcher,     Error, ExportRemoteProgram, Free, Handle, NoSuchProcedureNumber, nullParameters,    Parameters, RemoteErrorSignalled, Results, SignalRemoteError, SystemElement],  Heap USING [systemZone],  Process USING [SecondsToTicks, SetTimeout, Ticks],  String USING [Compare, CopyToNewString, Empty, Equivalent, FreeString],  System USING [GetClockPulses, NetworkAddress, Pulses],  TomOps,  TomP;  TomPImpl:   MONITOR -- separate MONITOR controlling access to list of registered code  IMPORTS Courier, Heap, Process, String, System, TomOps  EXPORTS TomOps, TomP =  BEGIN OPEN TomOps;    z:PUBLIC UNCOUNTED ZONE ¬ Heap.systemZone;    PerfErr:     PUBLIC SIGNAL[reason:PerfErrReason,                   interfaceName, variableName: LONG STRING ¬ NIL] = CODE;  -- InterfaceHandle's hold the list of registered code...    interfaceChain: InterfaceHandle ¬ NIL;  InterfaceHandle: TYPE = LONG POINTER TO InterfaceObject;  InterfaceObject: TYPE = RECORD      [name:LONG STRING, next:InterfaceHandle,      nVariables:CARDINAL,      getVariableProc:TomP.GetVariableProcType,      updateVariablesProc:TomP.UpdateVariablesProcType,      userHandle:LONG POINTER];    -- UpdateHandle's contain the necessary info for the continuous update  -- of interfaces  	       UpdateHandle: TYPE = PUBLIC LONG POINTER TO UpdateObject;  UpdateObject: PUBLIC TYPE = RECORD -- note record is private    [SELECT type:* FROM      local  => [n:CARDINAL,                  updateProcsAndHandles:SEQUENCE max:CARDINAL OF RECORD[proc:TomP.UpdateVariablesProcType, handle:LONG POINTER]],      remote => [n:CARDINAL, remoteSeal:System.Pulses, cH:Courier.Handle,       		 remoteValues:LONG POINTER TO Values],      ENDCASE];  LocalUpdateHandle: TYPE = LONG POINTER TO local UpdateObject;  RemoteUpdateHandle: TYPE = LONG POINTER TO remote UpdateObject;      -- infoForRemote is a single record maintaining update info for  -- a remote client    infoForRemote:LONG POINTER TO InfoForRemote ¬ NIL;  InfoForRemote:    TYPE = RECORD [uH:LocalUpdateHandle, n:CARDINAL, remote:Courier.SystemElement,    		   addrsForRemote: LONG POINTER TO Addrs,		   valuesForRemote:LONG POINTER TO Values,		   seal:LONG CARDINAL,		   deadMansHandleProcess: PROCESS ¬ NIL, 		   timer:CONDITION, seqNo:CARDINAL ¬ 0, ending:BOOLEAN ¬ FALSE];		     -- misc  Values: TYPE = RECORD[SEQUENCE COMPUTED CARDINAL OF LONG CARDINAL];  Addrs:  TYPE = RECORD[SEQUENCE COMPUTED CARDINAL OF LONG POINTER TO LONG CARDINAL];		      -- bits and pieces for Courier    tomProgramNumber:LONG CARDINAL = 35;       -- (assigned by bureaucracy)  tomVersionNumber:CARDINAL = 2;    -- v1:  initial version    -- v2:  counter:WordBoolean introduced into Items  timeoutForRemote: Process.Ticks = Process.SecondsToTicks[60];  	-- for incoming calls  ProcedureForRemote:     TYPE = PROCEDURE[remote:Courier.SystemElement,     		     arguments:Courier.Arguments, results:Courier.Results];  ProceduresForRemote:TYPE = CARDINAL[0..5); -- valid procedure numbers  proceduresForRemote: ARRAY ProceduresForRemote OF ProcedureForRemote ¬    [GetInterfaceNamesForRemote,     GetVariableNamesForRemote,     InitializeUpdateForRemote,     UpdateForRemote,     TerminateUpdateForRemote];          	-- for outgoing calls  rpGetInterfaceNames: CARDINAL = 0;   rpGetVariableNames:  CARDINAL = 1;   rpInitializeUpdate:  CARDINAL = 2;   rpUpdate:	       CARDINAL = 3;   rpTerminateUpdate:   CARDINAL = 4;       	-- for Courier.Descriptions  ItemsRecord: TYPE = RECORD [items:Items];  NamesRecord: TYPE = RECORD [names:Names];   StringRecord: TYPE = RECORD [s:LONG STRING];  SealRecord: TYPE = RECORD [seal:LONG CARDINAL];  SealAndCountersRecord: TYPE =     RECORD[seal:LONG CARDINAL, counters:LONG DESCRIPTOR FOR ARRAY OF WordBoolean];  PerfErrRecord:     TYPE = RECORD [reason:PerfErrReason, interfaceName, variableName:LONG STRING];              	-- misc  null:Courier.Parameters = Courier.nullParameters;  -- the Register routine ...    -- make a new interface available to the system.    -- the client must provide a procedure to enumerate the variable names and     -- addresses, and a (possibly NIL) procedure to update them               Register:     PUBLIC ENTRY PROCEDURE       [name:LONG STRING, nVariables:CARDINAL,       getVariableProc:TomP.GetVariableProcType,        updateVariablesProc:TomP.UpdateVariablesProcType ¬ NIL,       userHandle:LONG POINTER ¬ NIL]     RETURNS [ok:BOOLEAN] =    BEGIN    p:LONG POINTER TO InterfaceHandle ¬ @interfaceChain;    UNTIL p­=NIL OR String.Compare[p­.name, name, TRUE]>0 DO p ¬ @p­.next ENDLOOP;    IF p­#NIL AND String.Equivalent[p­.name, name] THEN RETURN [FALSE];    p­ ¬       z.NEW[InterfaceObject ¬  	      [name:name, next:p­,       	       nVariables:nVariables, 	       getVariableProc:getVariableProc,	       updateVariablesProc:updateVariablesProc,	       userHandle:userHandle]];    RETURN [TRUE];    END;      -- the Deregister routine ...    -- a simple implementation for now - assume that the user is being    -- intelligent (!) and has ensured that this is a safe thing to do     -- (ie there should be no outstanding references to the update proc,    --  for example)        -- a more sophisticated implementation would be to keep a list of all    -- outstanding localUpdateObjects (link/delink them in InitialiseLocalUpdate/    -- TerminateLocalUpdate).  Deregister would then scan this list looking    -- for references to the updateProc for the interface being deregistered.    -- If it finds any references, they should be zapped with a procedure that    -- will raise an error InterfaceNoLongerExists       Deregister: PUBLIC ENTRY PROCEDURE [name:LONG STRING] RETURNS [ok:BOOLEAN] =    BEGIN    FOR p:LONG POINTER TO InterfaceHandle ¬ @interfaceChain, @p­.next UNTIL p­=NIL       DO       IF String.Equivalent[p­.name, name]       THEN {interface:InterfaceHandle ¬ p­;            p­ ¬ p­.next;  	    z.FREE[@interface];	    RETURN [TRUE]}      ENDLOOP;    RETURN [FALSE]    END;                    -- provide info about and provide access to the registered routines	-- interrogation routines ...    GetInterfaceNames:     -- get a list of all registered interfaces; mostly used to generate menus    PUBLIC PROCEDURE [placeHandle:PlaceHandle]     RETURNS [names:Names, freeNamesProc:FreeNamesProcType] =    BEGIN    SELECT placeHandle.type       FROM      bad    => ERROR PerfErr[badRemoteName];      remote => RETURN GetRemoteInterfaceNames[placeHandle.cH];      local  => RETURN GetLocalInterfaceNames[];      ENDCASE    END;      GetVariableNames:    -- get a list of all registered variables for a given interface;     -- mostly used to generate menus - hence the <ALL> tacked on the front     PUBLIC PROCEDURE [placeHandle:PlaceHandle, name:LONG STRING]     RETURNS [names:Names, freeNamesProc:FreeNamesProcType] =    BEGIN    SELECT placeHandle.type      FROM      bad    => ERROR PerfErr[badRemoteName];      remote => RETURN GetRemoteVariableNames[placeHandle.cH, name];      local  => RETURN GetLocalVariableNames[name];      ENDCASE    END;       	-- general (either local or remote) access routines ...        InitializeUpdateInterfaces:     -- for each item, fill in the address of the specified variable    -- (given by the interface and variable names) and also create a record    -- of all the update procedures that have to be called    PUBLIC PROCEDURE[placeHandle:PlaceHandle, items:Items]       RETURNS [updateHandle:UpdateHandle] =    BEGIN    SELECT placeHandle.type      FROM      bad    => ERROR PerfErr[badRemoteName, NIL];      remote => RETURN InitializeRemoteUpdate[placeHandle.cH, items];      local  => RETURN InitializeLocalUpdate[items];      ENDCASE    END;      UpdateInterfaces:  -- cause all variables to have up-to-date contents    PUBLIC PROCEDURE[u:UpdateHandle] =    BEGIN    WITH u SELECT      FROM      remoteU:RemoteUpdateHandle => RemoteUpdate[remoteU];      localU:LocalUpdateHandle   => LocalUpdate[localU];       ENDCASE    END;      TerminateUpdateInterfaces:  -- release resources used by InitializeUpdateInterfaces    PUBLIC PROCEDURE [updateHandle:UpdateHandle, mode:TerminateMode] =    BEGIN    WITH updateHandle SELECT      FROM      remoteU:RemoteUpdateHandle => TerminateRemoteUpdate[remoteU, mode];      localU:LocalUpdateHandle   => TerminateLocalUpdate[localU, mode];        ENDCASE    END;    				         -- routines for the local chains  	-- firstly, the local versions of the PUBLIC routines ...      GetLocalInterfaceNames:      ENTRY PROCEDURE []     RETURNS [names:Names, freeNamesProc:FreeNamesProcType] =    BEGIN    ENABLE UNWIND => NULL;    m, n:CARDINAL; seq:SeqOfStringsP;    n ¬ 0;    FOR interface:InterfaceHandle ¬ interfaceChain, interface.next       UNTIL interface=NIL       DO n ¬ n+1 ENDLOOP;    IF n=0 THEN PerfErr[noInterfaces];    seq ¬ z.NEW[SeqOfStrings[n]];    m ¬ 0;    FOR interface:InterfaceHandle ¬ interfaceChain, interface.next       UNTIL interface=NIL      DO seq[m] ¬ Copy[interface.name];  m ¬ m+1  ENDLOOP;    RETURN [ArrayFromSequence[seq, n], FreeLocalNames];    END;        GetLocalVariableNames:     PROCEDURE [name:LONG STRING]     RETURNS [names:Names, freeNamesProc:FreeNamesProcType] =    BEGIN     n:CARDINAL; seq:SeqOfStringsP;    interface:InterfaceHandle;    interface ¬ GetLocalInterface[name];    n ¬ interface.nVariables+1;       seq ¬ z.NEW[SeqOfStrings[n]];      seq[0] ¬ Copy["<ALL>"L];    FOR i:CARDINAL IN [1..n)    DO seq[i] ¬ Copy[interface.getVariableProc[i-1, interface.userHandle].name] ENDLOOP;    RETURN [ArrayFromSequence[seq, n], FreeLocalNames];      END;        InitializeLocalUpdate:    PROCEDURE [items:Items] RETURNS [uH:LocalUpdateHandle] =    BEGIN    ENABLE UNWIND => IF uH#NIL THEN z.FREE[@uH];    uH ¬ z.NEW[local UpdateObject[LENGTH[items]]];      uH.n ¬ 0;    FOR i:CARDINAL IN [0..LENGTH[items])      DO      item:ItemP ¬ items[i];      interface:InterfaceHandle ¬ GetLocalInterface[item.interfaceName];      updateProc:TomP.UpdateVariablesProcType ¬ interface.updateVariablesProc;      userHandle:LONG POINTER ¬ interface.userHandle;      [item.varAddr, item.counter.b] ¬ GetLocalVariable[interface, item.varName];      IF updateProc#NIL       THEN         FOR i:CARDINAL IN [0..uH.n)           DO IF uH.updateProcsAndHandles[i].proc=updateProc 	     AND uH.updateProcsAndHandles[i].handle=userHandle THEN EXIT	  REPEAT 	    FINISHED => 	      {uH.updateProcsAndHandles[uH.n].proc ¬ updateProc;	       uH.updateProcsAndHandles[uH.n].handle ¬ userHandle; 	       uH.n ¬ uH.n+1}	  ENDLOOP;      ENDLOOP;    END;      LocalUpdate: PROCEDURE[uH:LocalUpdateHandle] =    BEGIN    FOR i:CARDINAL IN [0..uH.n)       DO       (uH.updateProcsAndHandles[i].proc)[uH.updateProcsAndHandles[i].handle]       ENDLOOP;    END;      TerminateLocalUpdate:     PROCEDURE[uH:LocalUpdateHandle, mode:TerminateMode] = {z.FREE[@uH]};            	-- utility routines ...    GetLocalInterface:      ENTRY PROCEDURE [name:LONG STRING] RETURNS [interface:InterfaceHandle] =    BEGIN    ENABLE UNWIND => NULL;    IF String.Empty[name]     THEN RETURN WITH ERROR PerfErr[noInterfaceGiven, name]    ELSE FOR interface ¬ interfaceChain, interface.next UNTIL interface=NIL           DO IF String.Equivalent[interface.name, name] THEN RETURN 	   REPEAT FINISHED => RETURN WITH ERROR PerfErr[interfaceNotFound, name];           ENDLOOP;    END;         GetLocalVariable:     ENTRY PROCEDURE [interface:InterfaceHandle, name:LONG STRING]     RETURNS [addr:LONG POINTER TO LONG CARDINAL, counter:BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    IF interface=NIL THEN RETURN WITH ERROR PerfErr[badInterface, NIL];    FOR i:CARDINAL IN [0..interface.nVariables)      DO      v:TomP.Variable ¬ interface.getVariableProc[i, interface.userHandle];      IF String.Equivalent[v.name, name] THEN RETURN [v.addr, v.counter];      ENDLOOP;    RETURN WITH ERROR PerfErr[variableNotFound, interface.name, name]    END;      FreeLocalNames: FreeNamesProcType =    BEGIN    n:CARDINAL;  seq:SeqOfStringsP;    [seq, n] ¬ SequenceFromArray[names];    FOR i:CARDINAL IN [0..n) DO String.FreeString[z, seq[i]] ENDLOOP;    z.FREE[@seq]    END;                   -- the routines to access the remote lists (ie outgoing remote calls) ...    GetRemoteInterfaceNames:     PROCEDURE[cH:Courier.Handle] RETURNS [names:Names, freeNamesProc:FreeNamesProcType] =    BEGIN     r:NamesRecord;    RemoteCall[cH, rpGetInterfaceNames, null, [@r, DescribeNames]];    RETURN [r.names, FreeRemoteNames]	     END;      GetRemoteVariableNames:     PROCEDURE[cH:Courier.Handle, name:LONG STRING]     RETURNS [names:Names, freeNamesProc:FreeNamesProcType] =    BEGIN    a:StringRecord ¬ [name];  r:NamesRecord;     RemoteCall[cH, rpGetVariableNames, [@a, DescribeString], [@r, DescribeNames]];    RETURN [r.names, FreeRemoteNames]    END;      InitializeRemoteUpdate:     PROCEDURE[cH:Courier.Handle, items:Items] RETURNS [uH:RemoteUpdateHandle] =    BEGIN    a:ItemsRecord ¬ [items];  r:SealAndCountersRecord;      n:CARDINAL ¬ LENGTH[items];    RemoteCall[cH, rpInitializeUpdate,                [@a, DescribeItems], [@r, DescribeSealAndCounters]];    uH ¬ z.NEW[remote UpdateObject ¬ [remote[n, [r.seal], cH, z.NEW[Values[n]]]]];    FOR i:CARDINAL IN [0..n)       DO       items[i].varAddr ¬ @uH.remoteValues[i];       items[i].counter ¬ r.counters[i]       ENDLOOP;    END;    RemoteUpdate: PROCEDURE[uH:RemoteUpdateHandle] =    BEGIN    a:SealRecord ¬ [uH.remoteSeal];    DescribeRemoteValues: Courier.Description =       {[] ¬ notes.noteSize[uH.n*SIZE[LONG CARDINAL]]};        -- note this is seriously cheating as it doesn't call noteLongCardinal	-- for each value - but will be OK between homogeneous machines	-- (and is faster!!).    RemoteCall[uH.cH, rpUpdate,     	       [@a, DescribeSeal], [uH.remoteValues, DescribeRemoteValues]];    END;    TerminateRemoteUpdate:PROCEDURE[uH:RemoteUpdateHandle, mode:TerminateMode] =    BEGIN    a:SealRecord ¬ [uH.remoteSeal];    IF mode=normal THEN RemoteCall[uH.cH, rpTerminateUpdate, [@a, DescribeSeal], null];    z.FREE[@uH.remoteValues];    z.FREE[@uH];    END;      FreeRemoteNames: PROCEDURE [names:Names] =     BEGIN    a:NamesRecord ¬ [names];    Free[@a, DescribeNames];    END;      RemoteCall:     PROCEDURE [cH:Courier.Handle, n:CARDINAL, arguments, results:Courier.Parameters] =    {[] ¬ Courier.Call[cH, n, arguments, results, 10 !      Courier.RemoteErrorSignalled =>       {r:PerfErrRecord;        {ENABLE UNWIND => Free[@r, DescribePerfErr];         arguments[[@r, DescribePerfErr]];	 ERROR PerfErr[r.reason, r.interfaceName, r.variableName]}}]};             -- routines to make the local lists available to the remote client   	-- (ie incoming remote calls) ...    RemoteDispatcher: Courier.Dispatcher =    BEGIN    ENABLE      BEGIN      PerfErr => -- propogate error back to caller        {r:PerfErrRecord ¬ [reason, interfaceName, variableName];	 ERROR Courier.SignalRemoteError[0, [@r, DescribePerfErr]]};      Courier.Error => NULL  -- simply allow infoForRemote (if any) to time out      END;    IF procedureNumber IN ProceduresForRemote    THEN (proceduresForRemote[procedureNumber])[cH.remote, arguments, results]    ELSE ERROR Courier.NoSuchProcedureNumber    END;  GetInterfaceNamesForRemote: ProcedureForRemote =     BEGIN    r:NamesRecord;  freeNamesProc:FreeNamesProcType;    arguments[];    [r.names, freeNamesProc] ¬ GetLocalInterfaceNames[];    [] ¬ results[[@r, DescribeNames]];    END;      GetVariableNamesForRemote: ProcedureForRemote =     BEGIN    a:StringRecord;  r:NamesRecord;  freeNamesProc:FreeNamesProcType;    arguments[[@a, DescribeString]];    [r.names, freeNamesProc] ¬ GetLocalVariableNames[a.s];    [] ¬ results[[@r, DescribeNames]];    Free[@a, DescribeString];    END;      InitializeUpdateForRemote: ProcedureForRemote =     BEGIN    a:ItemsRecord;  r:SealAndCountersRecord ¬ [0, NIL];    Counters: TYPE = RECORD[seq:SEQUENCE COMPUTED CARDINAL OF WordBoolean];    counters:LONG POINTER TO Counters;    uH:LocalUpdateHandle ¬ NIL;     BEGIN    ENABLE UNWIND =>       {Free[@a, DescribeItems];        IF uH#NIL THEN TerminateLocalUpdate[uH, normal];       IF r.counters#NIL THEN z.FREE[@counters]};    arguments[[@a, DescribeItems]];    uH ¬ InitializeLocalUpdate[a.items];    AllocateInfoForRemote[remote, a.items, uH];    counters ¬ z.NEW[Counters[LENGTH[a.items]]];    FOR i:CARDINAL IN [0..LENGTH[a.items])       DO counters[i].b ¬ a.items[i].counter.b ENDLOOP;    r.seal ¬ infoForRemote.seal;    r.counters ¬       DESCRIPTOR[LOOPHOLE[@counters.seq, LONG POINTER], LENGTH[a.items], WordBoolean];    [] ¬ results[[@r, DescribeSealAndCounters]];    infoForRemote.deadMansHandleProcess ¬ FORK DeadMansHandleForRemote[];    Free[@a, DescribeItems];    z.FREE[@counters];    END;    END;      UpdateForRemote: ENTRY ProcedureForRemote =     BEGIN    ENABLE UNWIND => NULL;    a:SealRecord;    DescribeRemoteValues: Courier.Description =       {[] ¬ notes.noteSize[infoForRemote.n*SIZE[LONG CARDINAL]]};        -- note this is seriously cheating as it doesn't call noteLongCardinal	-- for each value - but will be OK between homogeneous machines	-- (and is faster!!).    arguments[[@a, DescribeSeal]];    IF infoForRemote=NIL OR remote#infoForRemote.remote OR a.seal#infoForRemote.seal    THEN RETURN WITH ERROR PerfErr[invalidCall];    LocalUpdate[infoForRemote.uH];    FOR i:CARDINAL IN [0..infoForRemote.n)      DO infoForRemote.valuesForRemote[i] ¬ infoForRemote.addrsForRemote[i]­ ENDLOOP;    [] ¬ results[[infoForRemote.valuesForRemote, DescribeRemoteValues]];    infoForRemote.seqNo ¬ infoForRemote.seqNo+1;    END;      TerminateUpdateForRemote: ProcedureForRemote =     BEGIN    StopTimer: ENTRY PROCEDURE [] = INLINE       {infoForRemote.ending ¬ TRUE;  NOTIFY infoForRemote.timer};    a:SealRecord;    arguments[[@a, DescribeSeal]];    IF infoForRemote=NIL OR remote#infoForRemote.remote OR a.seal#infoForRemote.seal    THEN ERROR PerfErr[invalidCall];    StopTimer[];    JOIN infoForRemote.deadMansHandleProcess;    [] ¬ results[]    END;      AllocateInfoForRemote:     ENTRY PROCEDURE [remote:Courier.SystemElement, items:Items, uH:LocalUpdateHandle] =    BEGIN    n:CARDINAL ¬ LENGTH[items];    IF infoForRemote#NIL THEN RETURN WITH ERROR PerfErr[alreadyBeingMonitored];    infoForRemote ¬       z.NEW[InfoForRemote ¬         [uH, n, remote, z.NEW[Addrs[n]], z.NEW[Values[n]], System.GetClockPulses[]]];    FOR i:CARDINAL IN [0..n)      DO infoForRemote.addrsForRemote[i] ¬ items[i].varAddr ENDLOOP;    END;      DeadMansHandleForRemote: ENTRY PROCEDURE [] =    BEGIN    prevSeqNo:CARDINAL ¬ LAST[CARDINAL];    Process.SetTimeout[@infoForRemote.timer, timeoutForRemote];    UNTIL infoForRemote.ending OR infoForRemote.seqNo=prevSeqNo       DO prevSeqNo ¬ infoForRemote.seqNo;  WAIT infoForRemote.timer ENDLOOP;    TerminateLocalUpdate[infoForRemote.uH, normal];    z.FREE[@infoForRemote.valuesForRemote];    z.FREE[@infoForRemote.addrsForRemote];    z.FREE[@infoForRemote];    END;    	-- the description procedures are used by both incoming and outgoing calls	-- thus ensuring protocol compatability!  DescribeSeal: Courier.Description =    BEGIN    r:LONG POINTER TO SealRecord = notes.noteSize[SIZE[SealRecord]];    END;      DescribeSealAndCounters: Courier.Description =    BEGIN    r:LONG POINTER TO SealAndCountersRecord =     	notes.noteSize[SIZE[SealAndCountersRecord]];    notes.noteArrayDescriptor[@r.counters, SIZE[WordBoolean], LAST[CARDINAL]]    END;    	  DescribeItems: Courier.Description =    BEGIN    DescribeItem: Courier.Description =    -- treat the addr and client fields as UNSPECIFIED - they are not required    -- treat counter field as UNSPECIFIED - it is not valid yet      {r:LONG POINTER TO Item = notes.noteSize[SIZE[Item]];       notes.noteString[@r.interfaceName];       notes.noteString[@r.varName]};    r:LONG POINTER TO ItemsRecord = notes.noteSize[SIZE[ItemsRecord]];    notes.noteArrayDescriptor[@r.items, SIZE[ItemP], LAST[CARDINAL]];    FOR i:CARDINAL IN [0..LENGTH[r.items])      DO notes.noteDisjointData[@r.items[i], DescribeItem] ENDLOOP;    END;      DescribeNames: Courier.Description =     BEGIN    r:LONG POINTER TO NamesRecord = notes.noteSize[SIZE[NamesRecord]];    notes.noteArrayDescriptor[@r.names, SIZE[LONG STRING], LAST[CARDINAL]];    FOR i:CARDINAL IN [0..LENGTH[r.names])       DO notes.noteString[@r.names[i]] ENDLOOP    END;      DescribeString: Courier.Description =    BEGIN    r:LONG POINTER TO StringRecord = notes.noteSize[SIZE[StringRecord]];    notes.noteString[@r.s]    END;      DescribePerfErr: Courier.Description =    BEGIN    r:LONG POINTER TO PerfErrRecord = notes.noteSize[SIZE[PerfErrRecord]];    notes.noteString[@r.interfaceName];    notes.noteString[@r.variableName]    END;          				-- miscellaneous utility procedures	  CreateCourierHandle:     PUBLIC PROCEDURE [addr:System.NetworkAddress] RETURNS [cH:Courier.Handle] =    {cH ¬        Courier.Create[remote:addr, classOfService:transactional,	  programNumber:tomProgramNumber, versionNumber:tomVersionNumber,	  zone:Heap.systemZone]};	    DeleteCourierHandle: PUBLIC PROCEDURE[cH:Courier.Handle] =    {Courier.Delete[cH]};      IsSamePlace:     PUBLIC PROCEDURE[placeHandle:PlaceHandle, updateHandle:UpdateHandle]     RETURNS [BOOLEAN] =    BEGIN    WITH updateHandle SELECT        FROM      luh:LocalUpdateHandle => RETURN [placeHandle.type=local];      ruh:RemoteUpdateHandle =>         RETURN [placeHandle.type=remote  AND      	        placeHandle.cH.remote=ruh.cH.remote];      ENDCASE --ie NIL-- => RETURN [FALSE]    END;     Copy: PROCEDURE[s:LONG STRING] RETURNS [LONG STRING] = INLINE     {RETURN[String.CopyToNewString[s, z]]};             Free: PROCEDURE [location:LONG POINTER, description:Courier.Description] = INLINE    {Courier.Free[[location, description], Heap.systemZone]};                  -- main line code ...      Courier.ExportRemoteProgram[    programNumber:tomProgramNumber,    versionRange:[tomVersionNumber,tomVersionNumber],    dispatcher:RemoteDispatcher,    serviceName:"Tom",    zone:Heap.systemZone,    classOfService:transactional];	      END...  LOGxx-Mar-83   ......	JXG    	created file27-Mar-84 14:05:12 	JXG    	add userHandles to TomP routines 7-Nov-86 14:26:41      RSV     Changed FOR loop from [..] to [..) in GetLocalVariable
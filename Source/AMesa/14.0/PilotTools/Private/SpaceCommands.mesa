-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- SpaceCommands.mesa    26-Dec-84 15:00:03 by AWL      <<This program has a "current space" and a "current page". The commandsgenerally define or operate on the current space or page.TO DO: Space.CopyIn and  Space.CopyOut tests are not yet implemented.NOTE: Consider adding a differentiation between  unmapped & allocated and unmapped & deallocated in DisplayCmd>>DIRECTORY  Ascii USING [CR, SP],  Command USING [    Aborted, Action, Break, Confirm, Entry, InstallTopLevel, Loop, QuitLevel,    Scan],  Environment USING [    LongPointerFromPage, PageCount, PageFromLongPointer, wordsPerPage],  File USING [File, nullFile, nullID],  MFile USING [Error, GetFullName, Handle, maxNameLength, Release],  PilotCommand USING [    defaultWindow, GetFBCur, GetFileCur, ReadFBCur, StorageCatch, WriteFileIDs],  Runtime USING [IsBound],  Space,  SpaceUsage USING [PilotKernelUsage],  SpecialMFile USING [AcquireID],  TTY USING [    GetLongNumber, Handle, PutChar, PutLine, PutLongNumber, PutNumber, PutOctal,    PutString, UserAbort],  VM USING [FindMapUnit, Interval];SpaceCommands: PROGRAM  IMPORTS    Command, Environment, MFile, PilotCommand, Runtime, Space, SpecialMFile,    TTY, VM  EXPORTS PilotCommand =  BEGIN  tty: TTY.Handle = PilotCommand.defaultWindow;  defaultWindow: Space.Window = [    file: File.nullFile, base: 0, count: LAST[Environment.PageCount]];  wordsPerPage: CARDINAL = Environment.wordsPerPage;  entries: ARRAY [0..25) OF Command.Entry ¬ [    ["commands", LoopCmd],  -- must be first    ["activate", ActivateCmd], ["anywhere allocate", AnywhereAllocateCmd], [    "create", AllocateCmd], ["current", CurrentCmd], ["data map", DataMapCmd], [    "deactivate", DeactivateCmd], ["deallocate", DeallocateCmd], [    "display", DisplayCmd], ["force out", ForceOutCmd], [    "from page", FromPageCmd], ["map unit attributes", GetMapUnitAttributesCmd], [    "swap unit attributes", GetSwapUnitAttributesCmd], ["invalid", InvalidCmd], [    "kill", KillCmd], ["map space", MapCmd], ["mds", MdsCmd], [    "read only", ReadOnlyCmd], ["read word", ReadWordCmd], [    "unmap at", UnmapAtCmd], ["unmap space", UnmapCmd], ["vm", VmCmd], [    "write only", WritableCmd], ["write word", WriteWordCmd], [    "quit", Command.QuitLevel]];  pageCur: Space.PageNumber ¬ 0;  -- what commands should set it?  siCur: Space.Interval ¬ Space.virtualMemory;  --==============================  -- Public procedures:  --==============================  GetSICur: PUBLIC PROCEDURE RETURNS [Space.Interval] = {RETURN[siCur]};  SetSICur: PUBLIC PROCEDURE [si: Space.Interval] = {siCur ¬ si};  WriteSHCur: PUBLIC PROCEDURE [h: TTY.Handle] = {CurrentCmd[h]};  --==============================  -- Command routines:  --==============================  ActivateCmd: Command.Action = {Space.Activate[siCur]};  AnywhereAllocateCmd: Command.Action =    BEGIN    count: Space.PageCount;    TTY.PutString[h, " count:"L];    count ¬ TTY.GetLongNumber[h: h, default: 1, radix: 8];    siCur ¬ Space.Allocate[count: count, within: siCur, base: Space.defaultBase];    CurrentCmd[h]    END;  AllocateCmd: Command.Action =    BEGIN    count: Space.PageCount;    offset: Space.PageOffset;    TTY.PutString[h, " count:"L];    count ¬ TTY.GetLongNumber[h: h, default: 1, radix: 8];    TTY.PutString[h, " offset:"L];    offset ¬ TTY.GetLongNumber[h: h, default: 0, radix: 8];    siCur ¬ Space.Allocate[count: count, within: siCur, base: offset];    CurrentCmd[h]    END;  CurrentCmd: Command.Action = {TTY.PutString[h, " is"L]; DisplayLocation[siCur]};  DataMapCmd: Command.Action = {    Command.Confirm[h]; [] ¬ Space.MapAt[at: siCur, window: defaultWindow]};  DeactivateCmd: Command.Action = {Space.Deactivate[siCur]};  DeallocateCmd: Command.Action =    BEGIN    Command.Confirm[h];    Space.Deallocate[siCur];    siCur ¬ Space.virtualMemory;    END;  DisplayCmd: Command.Action =    -- Display mapped or unmapped intervals of the siCur interval    BEGIN    pRemaining, pAfter: LONG ORDERED POINTER;    TTY.PutChar[h, Ascii.CR];    TTY.PutLine[h, " Page ! Count  File: Name [ID] Base"L];    pRemaining ¬ Order[siCur.pointer];    pAfter ¬ Order[siCur.pointer + siCur.count*wordsPerPage];    WHILE pRemaining < pAfter DO      vmMapUnit: VM.Interval = VM.FindMapUnit[        Environment.PageFromLongPointer[pRemaining]];      pMapUnit: LONG ORDERED POINTER =  -- @next map unit or end of interval.        IF vmMapUnit.count = 0 THEN pAfter        ELSE Order[Environment.LongPointerFromPage[vmMapUnit.page]];      IF pRemaining < pMapUnit THEN        BEGIN  -- unmapped starting at pRemaining        DisplayInterval[          [pointer: pRemaining, count: (pMapUnit - pRemaining)/wordsPerPage]];        TTY.PutLine[tty, " unmapped"L];        pRemaining ¬ pMapUnit;  -- step past unmapped interval.        END      ELSE        BEGIN  -- mapped starting at pRemaining        DisplayInterval[[pMapUnit, vmMapUnit.count]];        BEGIN  --scope of UnknownBS--        spaceMapUnit: Space.Interval;        window: Space.Window;        usage: Space.Usage;        class: Space.Class;        swapUnits: Space.SwapUnitOption;        [spaceMapUnit, window, usage, class, swapUnits] ¬          Space.GetMapUnitAttributes[          pMapUnit !          Space.Error --[type]-- => {            IF type # invalidParameters THEN              Command.Break[tty, "Funny error from GetMapUnitAttributes"L];            GOTO UnknownBS}; UNWIND => GOTO UnknownBS  -- TEMP until GetMapUnitAttributes raises Space.Error          ];        IF spaceMapUnit.pointer # pMapUnit OR spaceMapUnit.count # vmMapUnit.count          THEN Command.Break[tty, "VM and Space disagree about map status!"L];        DisplayWindow[window];        EXITS UnknownBS => TTY.PutString[tty, " mapped to unknown backing store"]        END;  --scope of UnknownBS--        TTY.PutChar[tty, Ascii.CR];        DisplaySwapUnits[[pMapUnit, vmMapUnit.count]];        pRemaining ¬ pRemaining + vmMapUnit.count*wordsPerPage;        END;      ENDLOOP;    END;  ForceOutCmd: Command.Action = {Space.ForceOut[siCur]};  FromPageCmd: Command.Action =    BEGIN    defaultCnt: Environment.PageCount;    interval: Space.Interval;    window: Space.Window;    usage: Space.Usage;    class: Space.Class;    su: Space.SwapUnitOption;    TTY.PutChar[h, Ascii.SP];    siCur.pointer ¬ Space.LongPointerFromPage[      pageCur ¬ TTY.GetLongNumber[h: h, default: pageCur, radix: 8]];    TTY.PutString[h, "count: "L];    [interval, window, usage, class, su] ¬ Space.GetMapUnitAttributes[      siCur.pointer];    IF interval.count = 0 THEN defaultCnt ¬ 1 ELSE defaultCnt ¬ interval.count;    siCur.count ¬ TTY.GetLongNumber[h: h, default: defaultCnt, radix: 8];    DisplayLocation[siCur];    END;  GetMapUnitAttributesCmd: Command.Action =    BEGIN    interval: Space.Interval;    window: Space.Window;    usage: Space.Usage;    class: Space.Class;    swapUnits: Space.SwapUnitOption;    [interval, window, usage, class, swapUnits] ¬ Space.GetMapUnitAttributes[      siCur.pointer];    TTY.PutLine[h, "Map Unit Attibutes..."L];    TTY.PutLine[h, "  interval = "L];    DisplayLocation[interval];    TTY.PutLine[h, "  window = "L];    PilotCommand.WriteFileIDs[h, window.file];    TTY.PutLine[h, " "L];    TTY.PutString[h, "    base: "L];    TTY.PutLongNumber[h, window.base, [8, FALSE, TRUE, 5]];    TTY.PutString[h, "    count: "L];    TTY.PutLongNumber[h, window.count, [8, FALSE, TRUE, 5]];    TTY.PutString[h, "  usage = "L];    SELECT TRUE FROM      usage = Space.unknownUsage => TTY.PutLine[h, "unknownUsage"L];      usage ~IN SpaceUsage.PilotKernelUsage => TTY.PutLine[h, "ClientUsage"L];      usage IN SpaceUsage.PilotKernelUsage => TTY.PutLine[h, "PilotUsage"L];      ENDCASE => TTY.PutLine[h, "Problem: no known type of usage"L];    TTY.PutString[h, "  class = "L];    SELECT class FROM      unknown => TTY.PutLine[h, "unknown"L];      code => TTY.PutLine[h, "code"L];      globalFrame => TTY.PutLine[h, "globalFrame"L];      localFrame => TTY.PutLine[h, "localFrame"L];      zone => TTY.PutLine[h, "zone"L];      file => TTY.PutLine[h, "file"L];      data => TTY.PutLine[h, "data"L];      spareA => TTY.PutLine[h, "spareA"L];      spareB => TTY.PutLine[h, "spareB"L];      pilotResident => TTY.PutLine[h, "pilotResident"L]      ENDCASE => TTY.PutLine[h, "Problem: no known type of class"L];    TTY.PutString[h, "  swapUnits = "L];    WITH s: swapUnits SELECT FROM      unitary => TTY.PutLine[h, "unitary"L];      uniform => {        TTY.PutString[h, "uniform with swap size "L];        TTY.PutNumber[h, s.size, [8, FALSE, TRUE, 5]];        TTY.PutLine[h, " "]};      irregular => {        TTY.PutString[h, "irregular with sizes: "L];        FOR i: CARDINAL IN [0..LENGTH[s.sizes]) DO          TTY.PutNumber[h, s.sizes[i], [8, FALSE, TRUE, 5]]; ENDLOOP;        TTY.PutString[h, "  swapUnits = "L]};      ENDCASE;    END;  GetSwapUnitAttributesCmd: Command.Action =    BEGIN    interval: Space.Interval;    access: Space.Access;    life: Space.Life;    [interval, access, life] ¬ Space.GetSwapUnitAttributes[siCur.pointer];    TTY.PutLine[h, "Map Unit Attibutes..."L];    TTY.PutLine[h, "  interval = "L];    DisplayLocation[interval];    TTY.PutString[h, "  access = "L];    SELECT access FROM      readWrite => TTY.PutLine[h, "readWrite"L];      readOnly => TTY.PutLine[h, "readOnly"L];      ENDCASE => TTY.PutLine[h, "Problem: access unknown"L];    SELECT life FROM      alive => TTY.PutLine[h, "alive"L];      dead => TTY.PutLine[h, "dead"L];      ENDCASE => TTY.PutLine[h, "Problem: life unknown"L];    END;  InvalidCmd: Command.Action =    BEGIN    siCur ¬ Space.Allocate[count: 1, within: Space.virtualMemory];    CurrentCmd[h];    Space.Deallocate[siCur];    TTY.PutString[h, " ... is now invalid"L]    END;  KillCmd: Command.Action = {Command.Confirm[h]; Space.Kill[siCur]};  LoopCmd: Command.Action =    BEGIN    Command.Loop[      h, DESCRIPTOR[@entries[1], LENGTH[entries] - 1], PilotCommand.StorageCatch,      "space "L]    END;  MapCmd: Command.Action = {    PilotCommand.ReadFBCur[h];    siCur ¬ Space.Map[      window: [PilotCommand.GetFileCur[], PilotCommand.GetFBCur[],      LAST[Environment.PageCount]]]};  MdsCmd: Command.Action = {siCur ¬ Space.MDS[]; DisplayLocation[siCur]};  ReadOnlyCmd: Command.Action = {Command.Confirm[h]; Space.MakeReadOnly[siCur]};  ReadWordCmd: Command.Action =    BEGIN    w: WORD;    Command.Confirm[h];    w ¬ siCur.pointer­;    TTY.PutString[h, "first word = "L];    TTY.PutOctal[h, w]    END;  SpaceCmd: Command.Action =    BEGIN    TTY.PutChar[h, Ascii.SP];    Command.Scan[      h, DESCRIPTOR[BASE[entries], LENGTH[entries] - 1],      PilotCommand.StorageCatch]    END;  UnmapAtCmd: Command.Action = {    Command.Confirm[h]; [] ¬ Space.UnmapAt[siCur.pointer, wait]};  UnmapCmd: Command.Action = {    Command.Confirm[h]; siCur.pointer ¬ Space.Unmap[siCur.pointer]};  VmCmd: Command.Action = {DisplayLocation[siCur ¬ Space.virtualMemory]};  WritableCmd: Command.Action = {Command.Confirm[h]; Space.MakeWritable[siCur]};  WriteWordCmd: Command.Action =    BEGIN    Command.Confirm[h];    siCur.pointer­ ¬ 1;    TTY.PutString[h, "first word ¬ 1"L]    END;  --==============================  -- Support routines:  --==============================  DisplayLocation: PROCEDURE [si: Space.Interval] =    BEGIN    TTY.PutChar[tty, Ascii.SP];    TTY.PutLongNumber[      tty, Space.PageFromLongPointer[si.pointer], [8, FALSE, TRUE, 5]];    TTY.PutChar[tty, '!];    TTY.PutLongNumber[tty, siCur.count, [8, FALSE, TRUE, 5]];    END;  DisplayWindow: PROCEDURE [window: Space.Window] =    BEGIN    IF window = defaultWindow THEN TTY.PutString[tty, "data"L]    ELSE      BEGIN      name: STRING = [MFile.maxNameLength];      lName: LONG STRING ¬ name;      fID: File.File = window.file;      IF fID.fileID = File.nullID THEN TTY.PutString[tty, "private"L]      ELSE        BEGIN        found: BOOLEAN;        h: MFile.Handle;        IF (found ¬ Runtime.IsBound[LOOPHOLE[MFile.GetFullName]]) THEN          BEGIN          ENABLE MFile.Error => GOTO notFound;          h ¬ SpecialMFile.AcquireID[            id: fID, access: anchor, release: [NIL, NIL]];          MFile.GetFullName[file: h, name: lName];          EXITS notFound => found ¬ FALSE;          END;        IF found THEN {TTY.PutString[tty, name]; MFile.Release[h]}        ELSE TTY.PutString[tty, "anonymous"];        TTY.PutChar[tty, Ascii.SP];        PilotCommand.WriteFileIDs[tty, window.file];        TTY.PutLongNumber[tty, window.base, [8, FALSE, TRUE, 5]]        END;      END;    END;  DisplayInterval: PROCEDURE [interval: Space.Interval] =    BEGIN    IF TTY.UserAbort[tty] THEN ERROR Command.Aborted;    TTY.PutLongNumber[      tty, Environment.PageFromLongPointer[interval.pointer], [      base: 10, zerofill: FALSE, unsigned: TRUE, columns: 5]];    TTY.PutString[tty, " !"L];    TTY.PutLongNumber[      tty, interval.count, [      base: 10, zerofill: FALSE, unsigned: TRUE, columns: 5]];    END;  DisplaySwapUnits: PROCEDURE [mapUnit: Space.Interval] =    BEGIN    ptr: LONG ORDERED POINTER ¬ Order[mapUnit.pointer];    WHILE ptr < Order[mapUnit.pointer + mapUnit.count*wordsPerPage] DO      swapUnit: Space.Interval;      access: Space.Access;      life: Space.Life;      [swapUnit, access, life] ¬ Space.GetSwapUnitAttributes[ptr];      TTY.PutString[tty, "     "L];      TTY.PutLongNumber[        tty, Environment.PageFromLongPointer[ptr], [8, FALSE, TRUE, 5]];      TTY.PutLongNumber[tty, swapUnit.count, [8, FALSE, TRUE, 5]];      SELECT access FROM        readWrite => TTY.PutString[tty, " readWrite "L];        readOnly => TTY.PutString[tty, " readOnly "L];        ENDCASE => TTY.PutString[tty, " Problem: access unknown"L];      SELECT life FROM        alive => TTY.PutLine[tty, " alive"L];        dead => TTY.PutLine[tty, " dead"L];        ENDCASE => TTY.PutString[tty, " Problem: life unknown"L];      ptr ¬ ptr + (swapUnit.count*wordsPerPage);      ENDLOOP;    END;  Order: PROCEDURE [p: LONG POINTER] RETURNS [LONG ORDERED POINTER] = INLINE {    RETURN[LOOPHOLE[p]]};  -- Initialization  Command.InstallTopLevel[tty, ["space", SpaceCmd]]  END.LOG   (For previous log entries, please see Mesa 10.0 arcive version.)20-Nov-81 14:24:03   CAJ    Replaced Directory with MFile and SpecialMFile.26-Jan-82 12:26:19   CAJ    Correct display handling of file known to Pilot but not MFile.11-Jan-83 10:27:31   EKN      Updated to Klamath14-Jan-83 11:39:59   EKN      Added quit to command entries 23-Feb-83 17:21:09   EKN      Changed "unmap" of entries array to "unmap space" and "map" to "map space".  Command processor was having problems distinguishing between commands when one was a prefix of another.12-Apr-83 16:20:11   JXP      No space usage ranges remain in Space, use SpaceUsage. 4-May-83 14:47:32   WDK        Use VM.FindMapUnit. Work around GetMapUnitAttributes not raising Error.17-Aug-83 14:43:01   JXP      Convert to 11.0b.26-Dec-84 15:00:00   AWL         WriteSHCur is NOT a Command.Action.
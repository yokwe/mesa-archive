-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- TextTomD.mesa (last edited by Jonathan Gibbons: 14-Mar-83 15:18:09)-- a simple test routineDIRECTORY   Ascii USING [SP],   Format USING [Blanks, CR, LongNumber, LongString, NumberFormat, StringProc],   FormSW USING [AllocateItemDescriptor, BooleanItem, ClientItemsProcType,      CommandItem, ContextFromItem, Create, Destroy, ItemDescriptor,     ItemHandle, ItemObject, newLine, NotifyProcType,      ProcType, sameLine, ToggleVisibility, WordBoolean],   Heap USING [systemZone],	    String USING [AppendString],   StringSW USING [Create, Destroy],   TextSW USING [Update],   TomD,   Tool USING [AddThisSW, DeleteThisSW],   ToolWindow USING [CreateSubwindow, Destroy],   Window USING [Handle],   WindowFont USING [FontHeight];   TextTomD:  PROGRAM  IMPORTS Format, FormSW, Heap, String, StringSW, TextSW, TomD, Tool,  	  ToolWindow, WindowFont =  BEGIN OPEN TomD;    ItemInfoP: TYPE = LONG POINTER TO ItemInfo;  ItemInfo: TYPE = RECORD     [current, prev, accumBase, diff, prevDiff: LONG INTEGER ¬ 0,     currentPlace, diffPlace: CARDINAL];    GlobalInfoP: TYPE = LONG POINTER TO GlobalInfo;    GlobalInfo: TYPE = RECORD    [formSW, mainSW: Window.Handle,      accumulate, hold: FormSW.WordBoolean,      items:Items,     s:LONG STRING];       numberStringSize:CARDINAL = 12;           -- the main routine to start and stop displays           Set:SetDisplayProcType =    BEGIN    globalInfo: GlobalInfoP ¬ clientHandle;    maxInterfaceStringSize, maxVariableStringSize, index: CARDINAL ¬ 0;          IF globalInfo=NIL    THEN       BEGIN  -- first time being called - initialise world      FormClientItemsProc: FormSW.ClientItemsProcType =         { RETURN FormSWItems[globalInfo] };      globalInfo ¬ Heap.systemZone.NEW[GlobalInfo];      globalInfo.accumulate.b ¬ globalInfo.hold.b ¬ FALSE;      globalInfo.formSW ¬ ToolWindow.CreateSubwindow[parent:parent];      FormSW.Create[globalInfo.formSW, FormClientItemsProc];      Tool.AddThisSW[window:parent, sw:globalInfo.formSW, nextSW:insertBeforeThis,      		     swType:predefined];      globalInfo.mainSW ¬ ToolWindow.CreateSubwindow[parent:parent];      END    ELSE      BEGIN  -- clean up after previous picture	           FOR i:CARDINAL IN [0..LENGTH[globalInfo.items])         DO Heap.systemZone.FREE[@globalInfo.items[i].client] ENDLOOP;      StringSW.Destroy[globalInfo.mainSW];      Tool.DeleteThisSW[globalInfo.mainSW];      Heap.systemZone.FREE[@globalInfo.s];      END;                 IF items=NIL     THEN       BEGIN -- last time being called - clean up world      ToolWindow.Destroy[globalInfo.mainSW];      Tool.DeleteThisSW[globalInfo.formSW];      FormSW.Destroy[globalInfo.formSW];      ToolWindow.Destroy[globalInfo.formSW];      Heap.systemZone.FREE[@globalInfo];      END    ELSE       BEGIN -- start new picture      nItems:CARDINAL ¬ LENGTH[items];      globalInfo.items ¬ items;      FOR i:CARDINAL IN [0..LENGTH[globalInfo.items])        DO 	item:ItemP ¬ globalInfo.items[i];        maxInterfaceStringSize ¬ 	  MAX[maxInterfaceStringSize, item.interfaceName.length];        maxVariableStringSize ¬ 	  MAX[maxVariableStringSize, item.varName.length];        ENDLOOP;      	        globalInfo.s ¬         Heap.systemZone.NEW[StringBody[nItems*(maxInterfaceStringSize + 2 +           maxVariableStringSize + 2 + numberStringSize +2 + numberStringSize + 1)]];          FOR i:CARDINAL IN [0..LENGTH[globalInfo.items])        DO 	item:ItemP ¬ globalInfo.items[i];        interfaceName:LONG STRING ¬ item.interfaceName;        variableName:LONG STRING ¬ item.varName;        p:Format.StringProc = {String.AppendString[globalInfo.s, s]};        nf:Format.NumberFormat = 	    [base:10, zerofill:FALSE, unsigned:TRUE, columns:numberStringSize];        itemInfo:LONG POINTER TO ItemInfo ¬ Heap.systemZone.NEW[ItemInfo];        itemInfo.prev ¬ item.varAddr­;        item.client ¬ itemInfo;        Format.LongString[proc:p, s:interfaceName];        Format.Blanks[proc:p, n:maxInterfaceStringSize+2-interfaceName.length];        Format.LongString[proc:p, s:variableName];        Format.Blanks[proc:p, n:maxVariableStringSize+2-variableName.length];        itemInfo.currentPlace ¬ globalInfo.s.length;        Format.LongNumber[proc:p, n:item.varAddr­, format:nf];        itemInfo.diffPlace ¬ globalInfo.s.length;        Format.Blanks[proc:p, n:numberStringSize+2];        Format.CR[proc:p];        ENDLOOP;          StringSW.Create[sw:globalInfo.mainSW, s:@globalInfo.s, expandable:FALSE,      		      options:[access:read, menu:FALSE, split:FALSE,		        wrap:FALSE,scrollbar:TRUE, flushTop:FALSE, flushBottom:FALSE]];      Tool.AddThisSW[window:parent, sw:globalInfo.mainSW, nextSW:insertBeforeThis,                     swType:predefined, h:(nItems+1)*WindowFont.FontHeight[]];	            END;                 RETURN [globalInfo]    END;              -- routines to update the display ...      Update:UpdateDisplayProcType =     BEGIN    globalInfo: GlobalInfoP ¬ clientHandle;    IF ~globalInfo.hold.b THEN ReallyUpdate[globalInfo]    END;      ReallyUpdate: PROCEDURE[globalInfo:GlobalInfoP] =    BEGIN        FOR i:CARDINAL IN [0..LENGTH[globalInfo.items])      DO       item:ItemP ¬ globalInfo.items[i];      itemInfo:ItemInfoP ¬ item.client;      BEGIN OPEN itemInfo;      current ¬ item.varAddr­;        diff ¬ current - (IF globalInfo.accumulate.b THEN accumBase ELSE prev);            IF current#prev       THEN DisplayNumber[globalInfo, current, currentPlace];            IF diff#prevDiff       THEN IF diff=0           THEN DisplayBlank[globalInfo, diffPlace, numberStringSize] 	   ELSE DisplayNumber[globalInfo, diff, diffPlace];	         prev ¬ current;        prevDiff ¬ diff;      END;      ENDLOOP;    END;      DisplayBlank:PROCEDURE[globalInfo:GlobalInfoP, from, n: CARDINAL] =    BEGIN    FOR i:CARDINAL IN [from..from+n) DO globalInfo.s[i] ¬ Ascii.SP ENDLOOP;    TextSW.Update[sw:globalInfo.mainSW, from:from, to:from+n-1, charsDeleted:FALSE]    END;      DisplayNumber:PROCEDURE[globalInfo:GlobalInfoP, n:LONG CARDINAL, at:CARDINAL] =    BEGIN    at2: CARDINAL ¬ at;   -- for p to munge    p:Format.StringProc =       {FOR i:CARDINAL IN [0..s.length) DO globalInfo.s[at2+i] ¬ s[i] ENDLOOP;       at2 ¬ at2+s.length};    nf:Format.NumberFormat = 	    [base:10, zerofill:FALSE, unsigned:FALSE, columns:numberStringSize];    Format.LongNumber[proc:p, n:n, format:nf];    TextSW.Update[sw:globalInfo.mainSW,                    from:at, to:at+numberStringSize-1, charsDeleted:FALSE]    END;          -- routines to manage the options formSW ....      FormSWItems: PROCEDURE [globalInfo:GlobalInfoP]     RETURNS [items:FormSW.ItemDescriptor, freeDesc:BOOLEAN] =    BEGIN    nItems:CARDINAL ¬ 3;    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[0] ¬ FormSW.BooleanItem[tag:"Hold", place:FormSW.newLine,      				  switch:@globalInfo.hold.b];    items[1] ¬ FormSW.BooleanItem[tag:"Accumulate", place:[60,FormSW.sameLine],      				  hasContext:TRUE, proc:NotifyAccumulateAltered,       				  switch:@globalInfo.accumulate.b];    (InfoFromItem[items[1]])­ ¬ globalInfo;			      items[2] ¬ FormSW.CommandItem[tag:"Reset", invisible:TRUE,       				  place:[150,FormSW.sameLine],      				  hasContext:TRUE, proc:ResetDifferences];    (InfoFromItem[items[2]])­ ¬ globalInfo;			      RETURN [items:items, freeDesc:TRUE];	    END;			   ResetDifferences: FormSW.ProcType =    BEGIN    globalInfo:GlobalInfoP ¬ (InfoFromItem[item])­;    FOR i:CARDINAL IN [0..LENGTH[globalInfo.items])      DO      item:ItemP ¬ globalInfo.items[i];      itemInfo:ItemInfoP ¬ item.client;      itemInfo.accumBase ¬ item.varAddr­;       ENDLOOP;    IF globalInfo.hold.b THEN ReallyUpdate[globalInfo];    END;        NotifyAccumulateAltered: FormSW.NotifyProcType =    BEGIN    IF (NARROW[item­, boolean FormSW.ItemObject]).switch­    THEN ResetDifferences[sw, item, index];    FormSW.ToggleVisibility[sw, 2 --Reset-- ];    FormSW.ToggleVisibility[sw, 3 --Intervals-- ]    END;      InfoFromItem: PROCEDURE[item:FormSW.ItemHandle]     RETURNS [LONG POINTER TO GlobalInfoP] =    INLINE {RETURN [LOOPHOLE[FormSW.ContextFromItem[item]]]};         -- main line code ...      [] ¬ Register["Text", Set , Update]    END.
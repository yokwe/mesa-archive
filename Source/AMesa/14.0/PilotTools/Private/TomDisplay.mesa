-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- TomDisplay.mesa (last edited by Jonathan JXG     16-Feb-83 11:03:17)DIRECTORY  Put USING [LongString],  Process USING [Abort, EnableAborts, MsecToTicks, SetPriority, SetTimeout],  TomOps,   String USING [Equal],  Window USING [Handle];   TomDisplay:  MONITOR -- protecting instance specific data  LOCKS ctx USING ctx: TomOps.CtxHandle  IMPORTS Process, Put, String, TomOps  EXPORTS TomOps   SHARES TomOps =  BEGIN OPEN TomOps;    ok:BOOLEAN = TRUE;    ItemSeq: TYPE = RECORD [seq:SEQUENCE COMPUTED CARDINAL OF ItemP];  -- Tom end of the display management routines ...    GetDisplayAndCatchErrors:    PUBLIC PROCEDURE [ctx:CtxHandle]       RETURNS [display:DisplayHandle] =    BEGIN    firstTime:BOOLEAN ¬ TRUE;    display ¬ GetDisplay[ctx.displayName !      DisplayErr =>        {Write:PROCEDURE[s:LONG STRING] = {Put.LongString[ctx.msgSW, s]};	IF firstTime AND reason=displayNotFound	THEN {firstTime ¬ FALSE; 	      IF TryToLoad[name, display, ctx.msgSW] THEN RETRY};        SELECT reason 	  FROM	  displayNotFound => {Write["can't find display: "]; Write[name]; Write["\n"]};	  noDisplayGiven  => Write["no display given\n"];	  ENDCASE;	display ¬ NIL;	CONTINUE}];    END;            SetDisplay:     PUBLIC INTERNAL PROCEDURE[ctx:CtxHandle, display:DisplayHandle, items:Items] =    BEGIN        IF display=ctx.display AND ItemsEqual[items, ctx.items]        AND IsSamePlace[ctx.placeHandle, ctx.updateHandle]    THEN       BEGIN      -- not worth going through whole routine - hardly anything has changed!      -- but the intervae and priority of the update process might have, so...      IF ctx.updateProcess#NIL      THEN {TerminateDisplayUpdate[ctx]; InitializeDisplayUpdate[ctx]};      RETURN      END;         -- if there is a current display, stop it and the interfaces being updated    -- and allow the display code to clear up if we are changing display routines.    IF ctx.display#NIL      THEN      BEGIN      TerminateDisplayUpdate[ctx];      TerminateUpdateInterfacesAndCatchErrors[ctx];      IF display # ctx.display  -- only kill if changing to a new one      THEN [] ¬ Display[ctx.display, NIL, ctx.clientHandle,                         ctx.msgSW, ctx.toolWindow, ctx.lastSW]      END;           -- have a go at starting the update of the new set of interfaces, if any     -- (and clear up if anything goes wrong)    IF items#NIL     THEN IF LENGTH[items]=0 OR display=NIL OR     	    InitializeUpdateInterfacesAndCatchErrors[ctx, items]#ok         THEN {FreeItems[items]; items ¬ NIL};        -- finally, sort out the new display, if there is one;   if there are valid    -- items then wonderful, set things going  - otherwise take care to clean    -- up display in case it was left going above (in hope of new items!)    IF display#NIL    THEN       IF items#NIL      THEN {IF display#ctx.display THEN ctx.clientHandle ¬ NIL;             ctx.clientHandle ¬ Display[display, items, ctx.clientHandle,       	                               ctx.msgSW, ctx.toolWindow, ctx.lastSW];            InitializeDisplayUpdate[ctx]}      ELSE {IF display=ctx.display 	    THEN [] ¬ Display[display, NIL, ctx.clientHandle,       	                     ctx.msgSW, ctx.toolWindow, ctx.lastSW];	    display ¬ NIL};	        FreeItems[ctx.items];     ctx.items ¬ items;            ctx.display ¬ display;    END;  AllocateItems: PUBLIC PROCEDURE [n:CARDINAL] RETURNS [items:Items] =     BEGIN    iS:LONG POINTER TO ItemSeq ¬ z.NEW[ItemSeq[n]];    RETURN [DESCRIPTOR[LOOPHOLE[@(iS­.seq), LONG POINTER], n, ItemP]]    END;          FreeItems: PUBLIC PROCEDURE [items:Items] =     BEGIN    IF items#NIL    THEN       {iS:LONG POINTER TO ItemSeq ¬ LOOPHOLE[BASE[items]];       FOR i:CARDINAL IN [0..LENGTH[items]) DO z.FREE[@items[i]] ENDLOOP;       z.FREE[@iS]}    END;          ItemsEqual: INTERNAL PROCEDURE[d1, d2: Items]    RETURNS [BOOLEAN] =    BEGIN    IF LENGTH[d1] # LENGTH[d2]    THEN RETURN [FALSE]    ELSE      FOR i:CARDINAL IN [0..LENGTH[d1])      DO IF NOT (String.Equal[d1[i].interfaceName, d2[i].interfaceName]                AND String.Equal[d1[i].varName, d2[i].varName])         THEN RETURN [FALSE]      ENDLOOP;    RETURN [TRUE]    END;	   	    InitializeDisplayUpdate: INTERNAL PROCEDURE[ctx:CtxHandle] =    {ctx.updateProcess ¬ FORK UpdateProcessProc[ctx, ctx.updateProcessSerialNo]};	     UpdateProcessProc: ENTRY PROCEDURE[ctx:CtxHandle, mySerialNo:CARDINAL] =     BEGIN    ENABLE ABORTED => GOTO quit;     updateTimer:CONDITION;    Process.SetPriority[ctx.priority];    Process.SetTimeout[@updateTimer, Process.MsecToTicks[ctx.interval]];    Process.EnableAborts[@updateTimer];    UNTIL mySerialNo#ctx.updateProcessSerialNo      DO       IF UpdateInterfacesAndCatchErrors[ctx]#ok      THEN {TerminateDisplayUpdate[ctx];            TerminateUpdateInterfacesAndCatchErrors[ctx, abandon];	    EXIT};      UpdateDisplay[ctx.display, ctx.clientHandle];      WAIT updateTimer;      ENDLOOP;    EXITS       quit => NULL    END;  TerminateDisplayUpdate: INTERNAL PROCEDURE[ctx:CtxHandle] =    {IF ctx.updateProcess#NIL      THEN {ctx.updateProcessSerialNo ¬ ctx.updateProcessSerialNo+1;            Process.Abort[ctx.updateProcess];           ctx.updateProcess ¬ NIL}};     END...
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- File: PageScavengerInt.mesa - last edit by:-- PXK    ,	 9-Mar-83 11:59:05DIRECTORY  File USING [ID, PageNumber, Type],  Format USING [CR, Decimal, Line, LongDecimal, Octal, StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType,    CommandItem, newLine, NumberItem, ProcType, StringItem],  Heap USING [systemZone],  MesaDEFileTypes USING [    MesaDEFileType, tDirectory, tNormal, tRootDirectory, tUnassigned],  PageScavenger USING [    Action, DeviceIndex, DiskStatus, Error, PageNumber, Scavenge],  Put USING [CR, Line, Text],  String USING [InvalidNumber, StringToLongNumber],  Token USING [FreeStringHandle, FreeTokenString, Handle, Item, StringToHandle],  Tool USING [    Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserTerminal USING [BlinkDisplay],  Window USING [Handle];PageScavengerInt: PROGRAM  IMPORTS    Format, FormSW, Heap, PageScavenger, Put, String, Token, Tool, UserTerminal =  BEGIN  -- TYPEs  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    msgSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    firstTime: BOOLEAN ¬ TRUE,    formSW: Window.Handle ¬ NIL,    writable: BOOLEAN ¬ TRUE,    pages: LONG STRING ¬ NIL,    drive: PageScavenger.DeviceIndex ¬ 0];  notAPage: PageScavenger.PageNumber = LAST[PageScavenger.PageNumber];  toolData: DataHandle ¬ NIL;  toolWindow: Window.Handle;  LogProc: Format.StringProc = {Put.Text[toolData.fileSW, s]};      ScavengeSomePages: FormSW.ProcType = {    diskPage: PageScavenger.PageNumber;    tokenHandle: Token.Handle;    gotAPage: BOOLEAN ¬ FALSE;    Put.CR[toolData.msgSW];    IF toolData.firstTime THEN toolData.firstTime ¬ FALSE    ELSE Put.CR[toolData.fileSW];    IF toolData.pages # NIL THEN {      tokenHandle ¬ Token.StringToHandle[toolData.pages];      DO        s: LONG STRING = Token.Item[tokenHandle];	IF s = NIL THEN EXIT;	diskPage ¬ String.StringToLongNumber[s, 10 ! String.InvalidNumber => {	  Put.Text[toolData.msgSW, s];	  Put.Line[toolData.msgSW, ": invalid Number"L];	  diskPage ¬ notAPage;	  CONTINUE}];	IF diskPage # notAPage THEN {	  gotAPage ¬ TRUE;	  ScavengeOnePage[LogProc, diskPage, toolData.drive, toolData.writable]};	[] ¬ Token.FreeTokenString[s];	ENDLOOP;      [] ¬ Token.FreeStringHandle[tokenHandle]};    IF ~gotAPage THEN Put.Line[toolData.msgSW, "Please specify a page number."L]};          ScavengeOnePage: PROC [    log: Format.StringProc, diskPage: PageScavenger.PageNumber,    device: PageScavenger.DeviceIndex, overWrite: BOOLEAN] =    BEGIN    action: PageScavenger.Action;    contentsReliable: BOOLEAN;    diskStatus: PageScavenger.DiskStatus;    file: File.ID;    filePage: File.PageNumber;    type: File.Type;    fileID: LONG POINTER TO ARRAY [0..5) OF CARDINAL = LOOPHOLE[LONG[@file]];    [action, contentsReliable, diskStatus, file, filePage, type] ¬       PageScavenger.Scavenge[device, diskPage, overWrite !          PageScavenger.Error => {	    Format.Line[	      proc: log,	      s: SELECT errorType FROM		driveNotAvailable => "Error[Drive not available]"L,		driveNotReady => "Error[Drive not ready]"L,		invalidPageNumber => "Error[Invalid page number]"L,		unknownDrive => "Error[Unknown drive]"L,		ENDCASE => "Unknown error variant"L];	     GO TO failed}];    log["Action: "L];       log[SELECT action FROM              fixDataCRCError => "fixDataCRCError"L,	      fixHardware => "fixHardware"L,	      boot => "boot"L,	      lvScavenge => "lvScavenge"L,	      pvScavenge => "pvScavenge"L,	      ENDCASE => "Unknown action"L];    log[".  Initial disk status is "L];       log[SELECT diskStatus FROM              goodCompletion => "goodCompletion"L,	      noSuchPage => "noSuchPage"L,	      labelDoesNotMatch => "labelDoesNotMatch"L,	      seekFailed => "seekFailed"L,	      checkError => "checkError"L,	      dataError => "dataError"L,	      hardwareError => "hardwareError"L,	      notReady => "notReady"L,	      labelError => "labelError"L	      ENDCASE => "Unknown disk status"L];       Format.CR[log];    log["    File: ["L];       Format.Octal[log, fileID[0]];       log[", "L];       Format.Octal[log, fileID[1]];       log[", "L];       Format.Octal[log, fileID[2]];       log[", "L];       Format.Octal[log, fileID[3]];       log[", "L];       Format.Octal[log, fileID[4]];       log["].  "L];    log["  File page: "L];       Format.LongDecimal[log, filePage];    log["  file type: "L];       Format.Decimal[log, type];    IF type IN MesaDEFileTypes.MesaDEFileType THEN {      log[" (MesaDEFileType["L];      log[SELECT type FROM        MesaDEFileTypes.tUnassigned => "tUnassgined"L,	MesaDEFileTypes.tRootDirectory => "tRootDirectory",	MesaDEFileTypes.tDirectory => "tDirectory"L,	MesaDEFileTypes.tNormal => "tNormal"L,	ENDCASE => "unknown"L];      log["])"L]};    Format.CR[log];    log["     "L];       Format.LongDecimal[log, diskPage];       log[" now has "L];       log[IF contentsReliable THEN "reliable"L ELSE "unreliable"L];       log[" contents."L];    Format.CR[log];    EXITS failed => UserTerminal.BlinkDisplay[];    END;  -- Tool needed routines  Transit: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        IF toolData = NIL THEN toolData ¬ Heap.systemZone.NEW[Data ¬ []];      new = inactive =>        IF toolData # NIL THEN  Heap.systemZone.FREE[@toolData];      ENDCASE;    END;  Init: PROCEDURE =    BEGIN    toolWindow ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: Transit, name: "Page Scavenger Tool"L,      cmSection: "PageScavengerTool"L,      tinyName1: "Page"L, tinyName2: "Scavenger"L];    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    nItems: CARDINAL = 4;    items ¬ AllocateItemDescriptor[nItems];    items[0] ¬ CommandItem[      tag: "Scavenge"L, place: newLine, proc: ScavengeSomePages];    items[1] ¬ NumberItem[      tag: "RD"L, signed: FALSE, notNegative: TRUE,      boxWidth: 30, value: @toolData.drive];    items[2] ¬ BooleanItem[tag: "ReWrite"L, switch: @toolData.writable];    items[3] ¬ StringItem[tag: "Pages"L, string: @toolData.pages,inHeap: TRUE];    RETURN[items: items, freeDesc: TRUE];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    nameRoot: STRING = "PageScavenger.log"L;    logName: STRING ¬ [17 + 4]; -- stupid compiler    Tool.UnusedLogName[unused: logName, root: nameRoot];    toolData.msgSW ¬ Tool.MakeMsgSW[window: window];    toolData.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    toolData.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;  -- Mainline code  Init[];  -- this gets string out of global frame  END...  
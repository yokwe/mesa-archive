-- Copyright (C) 1983, 1987  by Xerox Corporation. All rights reserved. -- MiniMugImpl.mesa edited by: CAJ     29-Dec-87 14:37:26DIRECTORY  Ascii		   USING [CR, SP],  Command	   USING [Aborted, Action, Confirm, Entry, InstallTopLevel,     QuitLevel, Scan],  DDC              USING [corruptDataHandle, corruptLabelAndDataHandle],  Device USING [Type],  DeviceTypes      USING [    q2000, q2010, q2020, q2030, q2040, q2080, sa1000, sa1004, sa4000,    sa4008, t300, t80],  DeviceTypesExtraExtras USING [m2235, m2242, m2243],  DeviceTypesExtras3 USING [mc1325, mc1303, q540],    DeviceTypesExtras4 USING [    mr322, mr535, m2243asx, mk56fbx, d3126, d5146hx, m2243x4, m2243as, mk56fb,    d5146h, tm703x, tm702x, st4026x, q530x, st225x, st4051x, st251x, m2227d,    m2227dx, st4096, m2243tx, m2243t, m2225ad],  Environment      USING [Base, first64K, PageCount],  File		   USING [nullFile],  Inline           USING [LowHalf],  PilotCommand     USING [defaultWindow, StorageCatch],  PilotDisk        USING [Label, SetLabelFilePage],  PilotDiskFace    USING [Command, ControllerHandle, DetermineDiskShape,    DeviceHandle, DiskAddress, GetDeviceAttributes, GetDeviceType,    GetNextController, GetNextDevice, Initiate, Label, nullControllerHandle,    nullDeviceHandle, OperationPtr, operationAlignment, operationSize, Poll,    Status],  ProcessorFaceExtras USING [Version],  ResidentHeap     USING [FreeNode, MakeNode],  Space		   USING [ScratchMap, Unmap],  SystemInternal   USING [UniversalID],  TTY		   USING [GetLongNumber, Handle, PutChar, PutCR, PutLine,    PutLongNumber, PutString],  Zone             USING [Status];MiniMugImpl: PROGRAM  IMPORTS    Command, Inline, PilotCommand, PilotDisk, PilotDiskFace,    ProcessorFaceExtras, ResidentHeap, Space, TTY =  BEGIN    entries: ARRAY [0..4)  OF Command.Entry ¬ [    ["make Missing (labelVerifyError)", MakeMissingCmd],    ["make Orphan (labelCRCError)", MakeOrphanCmd],    ["make Unreadable (dataCRCError)", MakeUnreadableCmd],    ["quit", Command.QuitLevel]];  controller: PilotDiskFace.ControllerHandle;  cyls, headsPerCyl, sectorsPerTrack: CARDINAL;  device: PilotDiskFace.DeviceHandle;  h: TTY.Handle ¬ PilotCommand.defaultWindow;  labelRecord: MACHINE DEPENDENT RECORD [    label: PilotDisk.Label, fill: ARRAY [0..10) OF WORD ¬ ALL[0]];  op: PilotDiskFace.OperationPtr;  pSpace: LONG POINTER;          MakeMissingCmd: Command.Action =    { Run[makeMissing,    "Make Page Missing"L,   " missing."L] };      MakeOrphanCmd: Command.Action =    { Run[makeOrphan,     "Make Page Orphan"L,    " an orphan."L] };      MakeUnreadableCmd: Command.Action =    { Run[makeUnreadable, "Make Page Unreadable", " unreadable."L] };      MiniMugCmd: Command.Action =    BEGIN    TTY.PutChar[h, Ascii.SP];    Command.Scan[      h, DESCRIPTOR[entries], PilotCommand.StorageCatch];    END;        Run: PROC [function: Function, string, otherString: LONG STRING]= {    page: LONG CARDINAL;    IF ~setup THEN Setup[];    TTY.PutString[h, "Disk page "L];    page ¬ TTY.GetLongNumber[h, LAST[LONG CARDINAL], 10, TRUE];    TTY.PutCR[h];    TTY.PutString[h, "About to permanently make RD0 disk page "L];    TTY.PutLongNumber[h, page, [10, FALSE, TRUE,5]];    TTY.PutLine[h, otherString];    Command.Confirm[h];    Perform[DiskAddressFromPage[page], function]};  Function: TYPE = {makeMissing, makeOrphan, makeUnreadable};      DiskAddressFromPage: PROC [p: LONG CARDINAL]    RETURNS [sa: PilotDiskFace.DiskAddress] = {    track: CARDINAL = Inline.LowHalf[p/sectorsPerTrack];    sa.cylinder ¬ track  /  headsPerCyl;    sa.head     ¬ track MOD headsPerCyl;    sa.sector   ¬ Inline.LowHalf[p MOD sectorsPerTrack]};      Perform: PROC [address: PilotDiskFace.DiskAddress, task: Function] =    BEGIN    status: PilotDiskFace.Status;    storage: Environment.Base RELATIVE POINTER;    BEGIN    [op, storage] ¬ MakeOp[];    pSpace ¬ Space.ScratchMap[1];    IF (status ¬ DoDiskIO[[verify, read, read], address, device])       # goodCompletion THEN {PrintStatus["read error: "L, status]; GOTO skipIt};    SELECT task FROM      makeMissing => {	idPtr: LONG POINTER TO SystemInternal.UniversalID	           = LOOPHOLE[@labelRecord.label.fileID];	-- Long ago, Glypnod was a gateway or something like that.	glypnod: ARRAY [0..3) OF CARDINAL = [0, 0, 24043B];	-- Rewrite bogus label, taking care to make it filePage 0	idPtr.processor ¬ LOOPHOLE[glypnod];	PilotDisk.SetLabelFilePage[@labelRecord.label, LOOPHOLE[LONG[0]]];	status ¬ DoDiskIO[[verify, write, noOp], address, device]};      makeOrphan =>	status ¬ DoDiskIO[	  [verify, write, write],  address, DDC.corruptLabelAndDataHandle];      makeUnreadable =>	status ¬ DoDiskIO[	  [verify, verify, write], address, DDC.corruptDataHandle];      ENDCASE => ERROR;  -- impossible command    PrintStatus["Corruption of page returns: "L, status];    [] ¬ Space.Unmap[pSpace];    FreeOp[storage];    EXITS skipIt => {[] ¬ Space.Unmap[pSpace]; FreeOp[storage]};    END;    END;    DoDiskIO: PROC [    cmd: PilotDiskFace.Command, address: PilotDiskFace.DiskAddress,    dH: PilotDiskFace.DeviceHandle]    RETURNS [status: PilotDiskFace.Status] =    BEGIN    op­ ¬ [      clientHeader:                address,      labelPtr:         @LOOPHOLE[labelRecord.label, PilotDiskFace.Label],      dataPtr:                      pSpace,      incrementDataPtr:              FALSE,      command:                         cmd,      tries:                            10,  -- arbitrary,      pageCount:                         1,      deviceStatus:                   NULL,  -- set by Poll      diskHeader:                     NULL,  -- not used by us      device:                          dH];    -- We can do this direct Initiate/Poll without special saving of head state    -- and without worrying about other disk users because we know that the    -- PilotTests this is part of is a UtilityPilot client and does not run    -- multiple simultaneous commands.  If either of these assumptions changes,    -- this would be an extremely ill advised way to access the disk.    -- Find the volume the page is in, Assert it, and use DiskChannel instead.    PilotDiskFace.Initiate[op];    WHILE (status ¬ PilotDiskFace.Poll[controller].status) = inProgress      DO ENDLOOP;    RETURN[status];    END;        PrintDriveInfo: PROC [    dT: Device.Type, cyls, headsPerCyl, sectorsPerTrack: CARDINAL,    diskPages: LONG CARDINAL] = {    TTY.PutCR[h];    TTY.PutString[h, "Drive 0, type="L];    TTY.PutString[h, SELECT dT FROM          DeviceTypes.sa1004, DeviceTypes.sa1000 => "Shugart 1000"L,          DeviceTypes.sa4000, DeviceTypes.sa4008 => "Shugart 4000"L,          DeviceTypes.q2000, DeviceTypes.q2010,	    DeviceTypes.q2020, DeviceTypes.q2030,	    DeviceTypes.q2040, DeviceTypes.q2080 => "Quantum 2000"L,          DeviceTypes.t80			 => "T80"L,          DeviceTypes.t300			 => "T300"L,	  DeviceTypesExtraExtras.m2235		 => "Fujitsu m2235"L,	  DeviceTypesExtraExtras.m2242		 =>"Fujitsu m2242"L,	  DeviceTypesExtraExtras.m2243		 => "Fujitsu m2243"L,	  DeviceTypesExtras3.mc1325		 => "Micropolis m1325"L,	  DeviceTypesExtras3.q540		 => "Quantum q540"L,	  DeviceTypesExtras3.mc1303		 => "Micropolis m1303"L,	  DeviceTypesExtras4.mr322		 => "Mitsubishi mr322"L,	  DeviceTypesExtras4.mr535		 => "Mitsubishi mr535"L,	  DeviceTypesExtras4.m2243as		 => "Fujitsu m2243as"L,	  DeviceTypesExtras4.mk56fb		 => "Toshiba mk56fb"L,	  DeviceTypesExtras4.d3126		 => "NEC d3126"L,	  DeviceTypesExtras4.d5146h		 => "NEC d5146h"L,	  DeviceTypesExtras4.m2243x4		 => "Fujitsu m2243x4"L,	  DeviceTypesExtras4.m2243asx		 => "Fujitsu m2243asx"L,	  DeviceTypesExtras4.mk56fbx		 => "Toshiba mk56fbx"L,	  DeviceTypesExtras4.d5146hx		 => "NEC d5146hx"L,	  DeviceTypesExtras4.tm703x		 => "NEC tm703x"L,	  DeviceTypesExtras4.tm702x		 => "NEC tm702x"L,	  DeviceTypesExtras4.st4026x		 => "NEC st4026x"L,	  DeviceTypesExtras4.q530x		 => "NEC q530x"L,	  DeviceTypesExtras4.st225x		 => "Seagate st225x"L,	  DeviceTypesExtras4.st4051x		 => "Seagate st4051x"L,	  DeviceTypesExtras4.st251x		 => "Seagate st251x"L,	  DeviceTypesExtras4.m2227d		 => "Fujitsu m2227d"L,	  DeviceTypesExtras4.m2227dx		 => "Fujitsu m2227dx"L,	  DeviceTypesExtras4.st4096		 => "Seagate st4096"L,	  DeviceTypesExtras4.m2243tx		 => "Fujitsu m2243tx"L,	  DeviceTypesExtras4.m2243t		 => "Fujitsu m2243t"L,	  DeviceTypesExtras4.m2225ad		 => "Fujitsu m2225ad"L,          ENDCASE				 => "unknown"L];    TTY.PutString[h, ", cyls="L];    TTY.PutLongNumber[h, cyls, [10, FALSE, TRUE, 5]];    TTY.PutString[h, ", heads="L];    TTY.PutLongNumber[h, headsPerCyl, [10, FALSE, TRUE, 5]];    TTY.PutString[h, ", sectors="L];    TTY.PutLongNumber[h, sectorsPerTrack, [10, FALSE, TRUE, 5]];    TTY.PutString[h, ", diskPages="L];    TTY.PutLongNumber[h, diskPages, [10, FALSE, TRUE, 5]];    TTY.PutCR[h]};        PrintStatus: PROC [s: STRING, status: PilotDiskFace.Status] = {    strings: ARRAY PilotDiskFace.Status OF STRING = [      inProgress:        "in Progress"L,      goodCompletion:    "successful"L,      notReady:          "not Ready"L,      recalibrateError:  "recalibrate Error"L,      seekTimeout:       "seek Timeout"L,      headerCRCError:    "header CRC Error"L,      labelCRCError:     "label CRC Error"L,      dataCRCError:      "data CRC Error"L,      headerNotFound:    "header Not Found"L,      labelVerifyError:  "label Verify Error"L,      dataVerifyError:   "data Verify Error"L,      overrunError:      "overrun Error"L,      writeFault:        "write Fault"L,      memoryError:       "memory Error"L,      memoryFault:       "memory Fault"L,      clientError:       "client Error"L,      operationReset:    "operation Reset"L,      otherError:        "other Error"L];    TTY.PutString[h, s]; TTY.PutLine[h, strings[status]]};            setup: BOOLEAN ¬ FALSE;  NoNode: ERROR = CODE;  FreeOp: PROC [rp: Environment.Base RELATIVE POINTER] =    BEGIN    status: Zone.Status ¬ ResidentHeap.FreeNode[rp];    IF status ~= okay THEN ERROR NoNode;    END;  MakeOp: PROC RETURNS [pOp: PilotDiskFace.OperationPtr,    rp: Environment.Base RELATIVE POINTER] =    BEGIN    status: Zone.Status;    [rp, status] ¬ ResidentHeap.MakeNode[      n: PilotDiskFace.operationSize,      alignment: SELECT PilotDiskFace.operationAlignment FROM        16 => a16, 8 => a8, 4 => a4, 2 => a2, ENDCASE => a1];    IF status ~= okay THEN ERROR NoNode;    pOp ¬ @Environment.first64K[rp];    END;  Setup: PROC = {    ok: BOOLEAN;    storage: Environment.Base RELATIVE POINTER;    SELECT ProcessorFaceExtras.Version[].machineType FROM      dandelion, kiku, daylight => NULL;      ENDCASE => 	{TTY.PutCR[h]; TTY.PutString[h,"Mugging not supported on this machine"L];	 Command.Aborted[]};    device ¬ PilotDiskFace.GetNextDevice[PilotDiskFace.nullDeviceHandle];    controller ¬      PilotDiskFace.GetNextController[PilotDiskFace.nullControllerHandle];    pSpace ¬ Space.ScratchMap[1];    [op, storage] ¬ MakeOp[];    ok ¬ PilotDiskFace.DetermineDiskShape[device, op, quickReadOnly, pSpace];    [] ¬ Space.Unmap[pSpace];    FreeOp[storage];    IF ~ok THEN      BEGIN      TTY.PutCR[h]; TTY.PutString[h, "Can't determine disk shape"];      Command.Aborted[];      END;    [cylinders: cyls, movingHeads: headsPerCyl, sectorsPerTrack: sectorsPerTrack]      ¬ PilotDiskFace.GetDeviceAttributes[device];    PrintDriveInfo[dT: PilotDiskFace.GetDeviceType[device], cyls: cyls,      headsPerCyl: headsPerCyl, sectorsPerTrack: sectorsPerTrack,      diskPages: LONG[cyls]*LONG[headsPerCyl]*LONG[sectorsPerTrack]];    setup ¬ TRUE};      Command.InstallTopLevel[h, ["miniMug", MiniMugCmd]];  END....  LOG30-Apr-82  9:59:23  FXH    	Created file from MugTorment.15-Feb-83 11:19:26  EKN   	Changed so it can install itself with PilotTests 8-Mar-83 17:48:07  EKN   	Changed length field of DESCRIPTOR passed to Command.Scan so quit command is seen 7-Oct-83 14:11:57  JXP   	Fix MapAt call in Setup.22-Apr-87 10:01:49  ET		Pilot 14.0 mds relief: STRING TO LONG STRING in Run proc. 2-Nov-87 12:47:28  CAJ		Make all output numbers decimal to match input, added lotsa disk types.29-Dec-87 14:23:42  CAJ		Handle heads which don't support mugging.  Change tries from 200 to 10 (we don't have to be violent).  Add diskPageCount to printed description.  Add expected error to command.  Fix space leaks, etc..
-- Copyright (C) 1981  by Xerox Corporation. All rights reserved. -- TryDefs.mesa, J. Morrison, (March 9, 1981  1:30 PM)-- Test software for Pilot 6.0b.-- Try provides procedures to help its clients attempt Pilot operations and check the results.  Try uses the large enumerated type "SigsetDefs.Sig", that names all of Pilot's public signals, and "SigsetDefs.Sigset" objects, which are "sets" of values of type Sig.DIRECTORY  PostAuxDefs USING [Tick],  SigsetDefs USING [Sig, Sigset];TryDefs: DEFINITIONS =BEGIN------------------------------------------ Public types and constantsSig: TYPE = SigsetDefs.Sig;Sigset: TYPE = SigsetDefs.Sigset;------------------------------------------ Public procedures:  Get/Set TryPack's state.-- These procedures control flag in TryPack.  If "logging NonRecoverable" is true, the Try procedures will log a warning message every time they skip an operation because "nonRecoverable" is in the mask.  If "break on warning" is true, the Ck procedures will break to the debugger when they log warning messages.  These flags may also be examined and set via the debugger.GetBreakOnWarning: PROCEDURE RETURNS [BOOLEAN];GetLoggingNonRecoverable: PROCEDURE RETURNS [BOOLEAN];SetBreakOnWarning: PROCEDURE [newState: BOOLEAN];SetLoggingNonRecoverable: PROCEDURE [newState: BOOLEAN];------------------------------------------ Special Public procedure CatchThisSignal.  -- Call CatchIt (from the client or from the debugger) if Try* has let an  -- unknown (ANY) resumable signal go by, and you want it to "catch" the  -- signal and continue.  (If the signal is non-resumable, merely Proceed  -- from the debugger, and Try* will catch the ResumeError.)CatchIt: PROCEDURE;------------------------------------------ Public procedures:  Trying Pilot operations-- Ck: checks that 'ok' is TRUE.  If not, Ck logs a message in the typescript-- and raises a signal to the debugger.  The logged message is of the form:--     "Check of <aspect> of <testee> failed."-- Or: "Check of <aspect> failed." (used if <testee> is empty)-- The signal to the debugger is:--     CheckFailed[aspect: <aspect>, testee: <testee>, tick: <current tick>],-- where "tick" indicates the current test step, if Post's ticker is in use.-- If "warning" is TRUE and the ck fails, then Ck will log the error as a-- warning, and return without breaking to the debugger (unless the-- "breakOnWarning" flag is TRUE).Ck: PROCEDURE [aspect: LONG STRING, testee: LONG STRING ¬ NIL, ok: BOOLEAN,  warning: BOOLEAN ¬ FALSE];  -- Ck1 is just like Ck, except it returns the argument "ok".Ck1: PROCEDURE [aspect: LONG STRING, testee: LONG STRING ¬ NIL, ok: BOOLEAN,  warning: BOOLEAN ¬ FALSE] RETURNS [ckOk: BOOLEAN];-- The "Try" procedures handle the signals that might be raised from trial operations, such as calls to Pilot.  The client provides the trial operation, a mask of the signal(s) expected to arise, and some comments that describe the trial operation.  The Try procedure executes the trial code in an environment that is prepared to catch any Pilot signals that may arise.-- In executing the trial operation, the Try procedure checks to see if what actually happened was expected or not.  If not, the trial is considered to have failed, so the Try procedure logs a message in the typescript and raises a signal to the debugger, keeping as much information as possible available on the stack for debugging.  The "comment" arguments are included in both the logged message and in the signal;  they should identify the test being performed.-- The logged message is of the following form (note that spaces are inserted-- between the comments):--   "Failed <comment1> <comment2> <comment3>"--   "    Raised the signal <actual signal> instead of one of {<signals>}."-- The signal to the debugger is:--   TryFailed[<comment1>, <comment2>, <comment3>,--     <expected signals>, <actual signal>, <current tick>],-- where "tick" indicates the current test step, if Post's ticker is in use.-- It is possible to "Proceed" from the TryFailed signal, in which case the Try procedure will return to its caller.  Whether the trial failed or not, when the Try procedure returns, it returns a value of type Sig indicating what actually happened.-- The Try procedures will accept non-Pilot specific errors ("ANY") only if "other" is mentioned the "mask" argument.  It will log a message in the typescript file when it catches such a signal, whether it accepts or rejects the signal.  Note that "other" will NEVER catch Pilot signals named in the enumeration Sig, NOR will it catch any signals raised by TryPack.-- There is one other case to catching ANY:  if a Try procedure catches and rejects an unknown error, that error might propagate to the debugger.  If the user resumes the error (by proceeding from the debugger), the signaller will raise ResumeError.  The Try procedure will then catch this second error (using catch ANY), and return "other" to its caller.-- If "nonRecoverable" is an element of the "mask" argument, this informs the Try procedure that the trial operation might cause a non-recoverable error.  To avoid this, the Try procedure posts a message and SKIPS the trial operation.  It returns "nonRecoverale", to indicate that the trial operation was skipped.  The message is:--   "Test <comment1> <comment2> <comment3> skipped, since it might cause a non-recoverable error."-- There are four forms of Try procedures, with slightly different calling mechanisms for the "mask" and the "trial operation".  -- TryP is the first form of "Try procedure".  It takes a trial operation in  -- the form of a procedure "trial", and invokes "trial" when it is prepared  -- to catch the signals that might be raised.  It takes its "mask" argument  -- as a Sigset, which is a set of Sig values.  Each element in the Sigset  -- indicates an "expected result".  The other "Try procedures" are  -- implemented in terms of TryP.  -- For example:  --   BEGIN  --   sh: Space.Handle ¬ Space.Create[1, Space.mds];  --   sigset: Sigset ¬ SigsetDefs.Create[];  --   TrialProc: PROCEDURE = BEGIN Space.Delete[sh]; END;  --  --   SigsetDefs.Monad[sigset, none];  --   [] ¬ TryP[TrialProc, sigset, "Delete a space in MDS"L];  --  --   SigsetDefs.Insert[sigset, spaceInvalidHandle];  --   [] ¬ TryP[TrialProc, sigset, "Delete an already deleted space"L,  --     "(but its space handle might've been recycled)"L];  --   END;TryP: PROCEDURE [trial: PROCEDURE, mask: Sigset,  comment1, comment2, comment3: LONG STRING ¬ NIL] RETURNS [actual: Sig];  -- TryP1 is a special case of TryP.  It is useful where the mask is known  -- to be a monad, hence it's mask argument is a simple Sig, rather than a  -- Sigset.  Like TryP, it takes a procedure for the trial operation.  -- For example:  --   BEGIN  --   TrialProc: PROCEDURE = BEGIN Space.Delete[sh]; END;  --   parent: Space.Handle ¬ Space.Create[10, Space.mds];  --   sh: Space.Handle ¬ Space.Create[1, parent];  --   ...  --   [] ¬ TryP1[TrialProc, none, "Delete a child space of 'parent'"L];  --   [] ¬ TryP1[TrialProc, spaceInvalidHandle,  --     "Delete an already deleted child space of 'parent'"L];  --   ...  --   END;TryP1: PROCEDURE [trial: PROCEDURE, mask: Sig,  comment1, comment2, comment3: LONG STRING ¬ NIL] RETURNS [actual: Sig];  -- Try, the third form of a "Try procedure", is like TryP, except the trial  -- operation is specified in the form of a catch phrase for the signal  -- TryDefs.Test;  Try raises this signal when it is ready to invoke the  -- trial code.  This form is much easier to use when writing a test program  -- that (lexically) has many calls to Try.  However, it is slower, and the  -- debugger might not display catch frames.  -- Three examples are given here.  The first trial operation expects no  -- signals at all. The second expects either Space.Error[invalidHandle] or  -- Space.Error[invalidParameters].  The third expects either  -- Space.Error[insufficientSpace] or no signals at all:  --   BEGIN ENABLE Test => RESUME;  --   expct: Sigset ¬ SigsetDefs.Create[];  --   s: Space.Handle; f: File.Capability;  --  --   SigsetDefs.Monad[expct, none];  --   [] ¬ Try[expct, "create a small file"L ! Test => f ¬ File.Create[...]];  --  --   SigsetDefs.Monad[expct, spaceInvalidHandle];  --   SigsetDefs.InsertIn[expct, spaceInvalidParameters];  --   [] ¬ Try[expct, "create a space with invalid parent and size"L  --     ! Test => s ¬ Space.Create[size: 0, parent: Space.nullHandle]];  --  --   SigsetDefs.Monad[expct, spaceInsufficientSpace];  --   SigsetDefs.InsertIn[expct, none];  --   [] ¬ Try[expct, "create a big space in the MDS"L  --     ! Test => s ¬ Space.Create[size: 300, parent: Space.MDS[]]];  --  --   SigsetDefs.Destroy[];  --   END;Try: PROCEDURE [mask: Sigset, comment1, comment2, comment3: LONG STRING ¬ NIL]  RETURNS [actual: Sig];  -- Try1 is a special case of Try.  It is useful where the mask is known  -- to be a monad, hence it's mask argument is a simple Sig, rather than a  -- Sigset.  Like Try, it raises the signal "Test" to invoke the trial  -- operation.  -- Example:  an alternative for the first example of Try:  --   BEGIN ENABLE Test => RESUME;  --   s: Space.Handle; f: File.Capability;  --   [] ¬ Try1[none, "create a small file"L ! Test => f ¬ File.Create[...]];  --   END;Try1: PROCEDURE [mask: Sig, comment1, comment2, comment3: LONG STRING ¬ NIL]  RETURNS [actual: Sig];------------------------------------------ Public errors and signals  -- When calling Try or Try1, the catch phrase for Test is used as the trial  -- operation.  This catch phrase should either end with RESUME, or (simpler  -- alternative) a larger scope catch phrase "ENABLE Test => RESUME" may be  -- used.Test: SIGNAL;  -- CheckFailed is raised by Ck, when some check is not "ok".  It is meant to  -- be caught by the debugger.CheckFailed: SIGNAL [aspect, testee: LONG STRING, tick: PostAuxDefs.Tick];  -- TryFailed is raised by the Try procedures when some trial operation  -- causes a signal or none other than as expected.  It is meant to be caught  -- by the debugger.TryFailed: SIGNAL [comment1, comment2, comment3, expected: LONG STRING,    actual: Sig, tick: PostAuxDefs.Tick];-- TryPack defines no errors other than the 3 above.  The only signals that it raises or allows to propagate are:  (1) Test, used to invoke trial operations, (2) signals not defined in Pilot's public interface (which are only caught if the Try procedure being used is asked to catch "other"), (3) CheckFailed and TryFailed, and (4) [potentially] SigsetDefs.Error (this should never happen).------------------------------------------ Public program TryPack.  On startup, TryPack starts SigsetPack.TryPack: PROGRAM;END.LOG OF SIGNIFICANT CHANGESDate: July 13, 1979, By: JHM, Action: Created file.Date: August 3, 1979, By: JHM, Action: Moved the large enumeration Sig, plus  the object definition and operations Sigset off to a new file SigsetDefs.Date: October 3, 1979, By: JHM, Action: Added Try1.Date: October 10, 1979, By: JHM, Action: Added TryP and TryP1.  Removed Error.Date: December 5, 1979, By: JHM, Action: Added "nonRecoverable".Date: August 20, 1980, By: JHM, Action: Added LoggingNonRecoverable,  SetLoggingNonRecoverable, and Ck1, and the optional argument "warning" to Ck  and Ck1.Date: August 21, 1980, By: JHM, Action: Added the current tick to the signals  CheckFailed & TryFailed.Date: September 29, 1980, By: JHM, Action: Widened strings to LONG.Date: March 9, 1981, By: JHM, Action: Full update for Rubicon--Changed the  definition of TryFailed.(1376)\f8
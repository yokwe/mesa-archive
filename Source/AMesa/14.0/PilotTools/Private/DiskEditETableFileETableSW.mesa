-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. -- DiskEditETableFileETableSW.mesa   12-Jun-86 10:49:20 by CAJDIRECTORY  DiskEditInternal USING [    dataPtr, dataWindowKey, msgSW, ReplaceFIDString, ValidateFID],  ETable USING [ETable, ETableHandle, ETableHeader, PageGroup],  Environment USING [wordsPerPage],  File USING [ID, Type],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, FilterProcType, FindItem, line0, line1, line2, line3, line4,    LongNumberItem, LongNumberNotifyProcType, nextLine, nextPlace,    NotifyProcType, NumberItem, NumberNotifyProcType, ProcType,    StringEditProc, StringItem, TagOnlyItem],  Heap USING [systemZone],  PilotFileTypes USING [tUnassigned],  Put USING [Line],  String USING [FreeString],  UserTerminal USING [BlinkDisplay],  Window USING [Handle],  WindowSwap USING [CurrentViewHandle, RegisterView];DiskEditETableFileETableSW: PROGRAM  IMPORTS DiskEditInternal, FormSW, Heap, Put, String, UserTerminal, WindowSwap =  BEGIN  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    -- Values of less than a word are sandwiched to force word boundaries.    fileIDString: LONG STRING ¬ NIL,    howManyGroups: CARDINAL ¬ 0,    temporary: BOOLEAN ¬ FALSE,    unused: CARDINAL ¬ 0,    bootable: BOOLEAN ¬ FALSE,    fileType: File.Type ¬ PilotFileTypes.tUnassigned,    fillStart: CARDINAL ¬ 0,    offset: CARDINAL ¬ 0,    value: CARDINAL ¬ 0,    pageGroups: ARRAY [0..maxPageGroups) OF ETable.PageGroup ¬ ALL[[0, 0]]];  FormItems: TYPE = {eTableFileETable, fileID, howManyGroups,    temporary, bootable, unused, fileType, postETableFill, offset,    value, next, back, pageGroups};  firstPageGroupItem: CARDINAL = FormItems.pageGroups.ORD;  itemsPerPageGroup: CARDINAL = 2;  maxPageGroups: CARDINAL =    (Environment.wordsPerPage - SIZE[ETable.ETableHeader])/SIZE[ETable.PageGroup];  lastFill: CARDINAL = Environment.wordsPerPage - 1;  data: DataHandle ¬ NIL;  eTable: ETable.ETableHandle = LOOPHOLE[DiskEditInternal.dataPtr];  eTablePlain: LONG POINTER = LOOPHOLE[DiskEditInternal.dataPtr];  heap: UNCOUNTED ZONE ¬ Heap.systemZone;  -- used by all but should be public  sw: Window.Handle ¬ NIL;  Back:  FormSW.ProcType =    BEGIN    IF (data.offset < data.fillStart) OR (data.offset > lastFill)      THEN {UserTerminal.BlinkDisplay[]; RETURN};    (eTablePlain + data.offset)^ ¬ data.value;    data.offset ¬      IF data.offset = data.fillStart THEN lastFill ELSE data.offset - 1;    ResetFill[sw];    END;  ChangeBootable: FormSW.NotifyProcType =    {eTable.header.bootable ¬ data.bootable};  ChangeCount: FormSW.NumberNotifyProcType =  --[sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,  -- oldValue: UNSPECIFIED]    BEGIN    whichGroup: CARDINAL ¬ (index - firstPageGroupItem)/itemsPerPageGroup;    eTable.pageGroups[whichGroup].count ¬ data.pageGroups[whichGroup].count;    END;  ChangeFileType: FormSW.NumberNotifyProcType =    {eTable.header.type ¬ data.fileType};  ChangeFillValue: FormSW.NumberNotifyProcType =    {(eTablePlain + data.offset)^ ¬ data.value};  ChangeGroups: FormSW.NumberNotifyProcType =  --[sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,  -- oldValue: UNSPECIFIED]    BEGIN    -- check range and put in right place in actual header field    -- out of range => {blink, restore oldValue}    -- update eTable pageGroups for difference if new > old    -- adjust page groups    -- adjust fillStart; move current values if necessary    -- redisplay    UserTerminal.BlinkDisplay[];    Put.Line[DiskEditInternal.msgSW,      "Sorry, changing that not implemented yet."L];    WITH i: item SELECT FROM      number => i.value­ ¬ oldValue;      ENDCASE => NULL;    FormSW.DisplayItem[sw, index];    END;  ChangeOffset: FormSW.NumberNotifyProcType =  --[sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,  -- oldValue: UNSPECIFIED]    BEGIN    IF (data.offset < data.fillStart)        OR (data.offset >= Environment.wordsPerPage) THEN      BEGIN      UserTerminal.BlinkDisplay[];      data.offset ¬ oldValue;      END;    ResetFill[sw];    END;  ChangeTemporary: FormSW.NotifyProcType =    {eTable.header.temporary ¬ data.temporary};  ChangeUnused: FormSW.NumberNotifyProcType =  --[sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,  -- oldValue: UNSPECIFIED]    BEGIN    fourBitsMax: CARDINAL = 15;    IF data.unused > fourBitsMax THEN      BEGIN      UserTerminal.BlinkDisplay[];      data.unused ¬ oldValue;      FormSW.DisplayItem[sw, index];      END    ELSE eTable.header.unused ¬ data.unused;    END;  ChangeVolumePage: FormSW.LongNumberNotifyProcType =  --[sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,  -- oldValue: LONG UNSPECIFIED]    BEGIN    whichGroup: CARDINAL ¬ (index - firstPageGroupItem)/itemsPerPageGroup;    eTable.pageGroups[whichGroup].volumePage ¬      data.pageGroups[whichGroup].volumePage;    END;  CleanupETableFileETableSW: PROCEDURE = {};  DestroyETableFileETableSW: PROCEDURE =    BEGIN    String.FreeString[z: heap, s: data.fileIDString];    heap.FREE[@data];    data ¬ NIL;    sw ¬ NIL;    END;  -- DestroyETableFileETableSW  FillETableFileETableSW: PROCEDURE =    BEGIN    end: CARDINAL;    newCount: CARDINAL;    oldCount: CARDINAL;    start: CARDINAL;    value: BOOLEAN;    IF sw = NIL THEN      sw ¬ WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey];    -- Find how many page groups are currently visible    FOR oldCount IN [0..maxPageGroups) DO      IF FormSW.FindItem[sw,        firstPageGroupItem + oldCount*itemsPerPageGroup].flags.invisible THEN EXIT      ENDLOOP;    DiskEditInternal.ReplaceFIDString[heapString: @data.fileIDString,      id: eTable.header.fileID];    data.howManyGroups ¬ eTable.header.howManyGroups;    data.temporary ¬ eTable.header.temporary;    data.bootable ¬ eTable.header.bootable;    data.unused ¬ eTable.header.unused;    data.fileType ¬ eTable.header.type;    data.fillStart ¬      SIZE[ETable.ETableHeader] + data.howManyGroups*SIZE[ETable.PageGroup];    data.offset ¬ data.fillStart;    data.value ¬ (eTablePlain + data.offset)^;    newCount ¬ MIN[data.howManyGroups, maxPageGroups];    FOR i: CARDINAL IN [0..newCount) DO      data.pageGroups[i] ¬ eTable.pageGroups[i];      ENDLOOP;    IF newCount > oldCount      THEN {start ¬ oldCount; end ¬ newCount; value ¬ FALSE}      ELSE {start ¬ newCount; end ¬ oldCount; value ¬ TRUE};    FOR i: CARDINAL IN        [firstPageGroupItem + start*itemsPerPageGroup..	 firstPageGroupItem + end*itemsPerPageGroup)      DO FormSW.FindItem[sw, i].flags.invisible ¬ value ENDLOOP;    END;  -- FillETableFileETableSW  MakeETableFileETableSW: FormSW.ClientItemsProcType =    BEGIN    nItems: CARDINAL =      firstPageGroupItem + (maxPageGroups*itemsPerPageGroup);    data ¬ heap.NEW[Data];    sw ¬ WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey];    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[FormItems.eTableFileETable.ORD] ¬ FormSW.TagOnlyItem[      tag: "ETableFile ETable"L, place: [4, FormSW.line0]];    items[FormItems.fileID.ORD] ¬ FormSW.StringItem[      tag: "fileID"L, place: [21, FormSW.line1], inHeap: TRUE,      filterProc: ValidateFileID, string: @data.fileIDString];    items[FormItems.howManyGroups.ORD] ¬ FormSW.NumberItem[      tag: "howManyGroups "L, place: [21, FormSW.line2], signed: FALSE,      notNegative: TRUE, proc: ChangeGroups, value: @data.howManyGroups];    items[FormItems.temporary.ORD] ¬ FormSW.BooleanItem[      tag: "temporary"L, place: [21, FormSW.line3], proc: ChangeTemporary,      switch: @data.temporary];    items[FormItems.bootable.ORD] ¬ FormSW.BooleanItem[      tag: "bootable"L, place: [101, FormSW.line3], proc: ChangeBootable,      switch: @data.bootable];    items[FormItems.unused.ORD] ¬ FormSW.NumberItem[      tag: "unused "L, place: [174, FormSW.line3], signed: FALSE,      notNegative: TRUE, proc: ChangeUnused, value: @data.unused];    items[FormItems.fileType.ORD] ¬ FormSW.NumberItem[      tag: "type "L, place: [306, FormSW.line3], signed: FALSE,      notNegative: TRUE, proc: ChangeFileType, value: @data.fileType];    items[FormItems.postETableFill.ORD] ¬ FormSW.TagOnlyItem[      tag: "Post-ETable fill:"L, place: [21, FormSW.line4]];    items[FormItems.offset.ORD] ¬ FormSW.NumberItem[      tag: "offset "L, place: [160, FormSW.line4], signed: FALSE,      notNegative: TRUE, proc: ChangeOffset, value: @data.offset];    items[FormItems.value.ORD] ¬ FormSW.NumberItem[      tag: "value "L, place: [280, FormSW.line4], signed: FALSE,      notNegative: TRUE, proc: ChangeFillValue, value: @data.value];    items[FormItems.next.ORD] ¬ FormSW.CommandItem[      tag: "Next"L, place: [402, FormSW.line4], proc: Next];    items[FormItems.back.ORD] ¬ FormSW.CommandItem[      tag: "Back"L, place: [445, FormSW.line4], proc: Back];    FOR i: CARDINAL IN [0..maxPageGroups) DO      -- Setup for max number of page groups.      -- Start out all invisible      items[firstPageGroupItem + i*itemsPerPageGroup] ¬ FormSW.LongNumberItem[        tag: "volumePage "L, place: [40, FormSW.nextLine], invisible: TRUE,	signed: FALSE, notNegative: TRUE,        value: @data.pageGroups[i].volumePage];      items[firstPageGroupItem + i*itemsPerPageGroup + 1] ¬ FormSW.NumberItem[        tag: "count "L, place: FormSW.nextPlace, invisible: TRUE, signed: FALSE,        notNegative: TRUE, value: @data.pageGroups[i].count];      ENDLOOP;    RETURN[items: items, freeDesc: TRUE];    END;  -- MakeETableFileETableSW  Next:  FormSW.ProcType =  -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL]    BEGIN    IF (data.offset < data.fillStart) OR (data.offset > lastFill)      THEN {UserTerminal.BlinkDisplay[]; RETURN};    (eTablePlain + data.offset)^ ¬ data.value;    data.offset ¬      IF data.offset = lastFill THEN data.fillStart ELSE data.offset + 1;    ResetFill[sw];    END;  -- Next  ResetFill: PROCEDURE [sw: Window.Handle] =    BEGIN    data.value ¬ (eTablePlain + data.offset)^;    FormSW.DisplayItem[sw, FormItems.offset.ORD];    FormSW.DisplayItem[sw, FormItems.value.ORD];    END;  ValidateFileID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: File.ID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateFID[data.fileIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE eTable.header.fileID ¬ LOOPHOLE[id];    END;  -- ValidateFileID  -- Module initialization:  -- Register this subwindow as an alternate view for the data subwindow  WindowSwap.RegisterView[    key: DiskEditInternal.dataWindowKey,    viewName: "ETableFile ETable"L,    makeFormSW: MakeETableFileETableSW,    viewFromDataProc: FillETableFileETableSW,    dataFromViewProc: CleanupETableFileETableSW];  END...LOG12-Jun-86 8:18:51   CAJ    Created file.    
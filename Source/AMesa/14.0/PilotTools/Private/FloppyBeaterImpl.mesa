-- FloppyBeaterImpl.mesa-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. <<  Last edited by:  FormSWLayoutTool on 8-Aug-84  9:56  AWL	 9-Aug-84 13:22:18  AWL	21-Aug-84 18:22:03  CAJ	 6-May-86 14:42:39>>DIRECTORY  FileTypes USING [tUntypedFile],  Floppy USING [    Close, CreateFile, DeleteFile, Error, FileHandle, GetAttributes,    maxCharactersInLabel, nullVolumeHandle, Open, PageCount, Read,    VolumeHandle, Write],  FloppyChannel USING [Drive, GetNextDrive, nullDrive],  Format USING [NumberFormat],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, line0, line1, line2, LongNumberItem,    NotifyProcType, NumberItem, NumberNotifyProcType, ProcType, TagOnlyItem],  Heap USING [systemZone],  MsgSW USING [Clear, Post],  Process USING [    Detach, DisableAborts, DisableTimeout, InitializeCondition, Pause, Priority,    priorityBackground, priorityForeground, priorityNormal, Seconds,    SecondsToTicks, SetPriority, SetTimeout, Yield],  Put USING [CR, LongNumber, LongString, Number],  RandomDefs USING [GeneratorState, InitializeRandom, Random],  Runtime USING [IsBound],  Space USING [InsufficientSpace, Interval, ScratchMap, Unmap],  String USING [AppendChar, AppendDecimal, AppendLongDecimal, AppendString],  Time USING [AppendCurrent],  Tool USING [    Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [State, TransitionProcType],  UserTerminal USING [BlinkDisplay],  Volume USING [InsufficientSpace],  Window USING [Handle];FloppyBeaterImpl: MONITOR  IMPORTS    Floppy, FloppyChannel, FormSW, Heap, MsgSW, Process, Put, RandomDefs,    Runtime, Space, String, Time, Tool, UserTerminal, Volume =  BEGIN  DataHandle: TYPE = LONG POINTER TO Data;  -- Elements less than a word long are carefully sandwiched between full-word  -- values so that tool addressing will come out right.  Data: TYPE = RECORD [    msgSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    randomSeed: LONG UNSPECIFIED ¬ 2097151,    processesPerDrive: CARDINAL ¬ 10,    priority: Priorities ¬ background,    statsInterval: CARDINAL ¬ 30,    verbose: BOOLEAN ¬ FALSE,    forkedProcesses: CARDINAL ¬ 0,    state: State ¬ stopped,    volumes: LONG POINTER TO Volumes ¬ NIL,    stats: LONG POINTER TO Statistics ¬ NIL,    random: RandomDefs.GeneratorState ¬ TRASH,    savedState: MACHINE DEPENDENT RECORD [      processes(0): CARDINAL ¬ 0,      priority(1): Priorities ¬ background,      randomSeed(2): LONG UNSPECIFIED ¬ 2097151]    ];  FormItems: TYPE = {useDrives, use0, use1, use2, use3, randomSeed,    processesPerDrive, priority, start, stats, stop, statsInterval, verbose};    Priorities: TYPE = MACHINE DEPENDENT {    background(0), normal(1), forground(2), random(3)};    State: TYPE = {running, stopped, stopping};  StatData: TYPE = RECORD [    createdFiles: LONG CARDINAL ¬ 0,    deletedFiles: LONG CARDINAL ¬ 0,    fileReads: LONG CARDINAL ¬ 0,    fileWrites: LONG CARDINAL ¬ 0];  Statistics: TYPE =  ARRAY [0..maxDrives) OF StatData;  VolumeData: TYPE = RECORD [    selected: BOOLEAN ¬ FALSE,    volume: Floppy.VolumeHandle ¬ Floppy.nullVolumeHandle];  Volumes: TYPE = ARRAY [0..maxDrives) OF VolumeData;  maxDrives: CARDINAL = 4;  drivesAvailable: CARDINAL;  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  processStopped: CONDITION;  statsInterval: CONDITION;    numberFormat: Format.NumberFormat = [    base: 10, zerofill: FALSE, unsigned: TRUE, columns: 10];  Start: ENTRY FormSW.ProcType =    BEGIN    ENABLE UNWIND => NULL;    MsgSW.Clear[data.msgSW];    SELECT data.state FROM      running =>        BEGIN	MsgSW.Post[data.msgSW, "AlreadyRunning!"L];	UserTerminal.BlinkDisplay[];	RETURN;	END;      stopping => WHILE data.forkedProcesses > 0 DO WAIT processStopped ENDLOOP;      stopped =>        BEGIN	drive: FloppyChannel.Drive;	time: LONG STRING ¬ [64];	IF ~Runtime.IsBound[LOOPHOLE[RandomDefs.InitializeRandom]] THEN	  BEGIN	  MsgSW.Post[data.msgSW, "Please load an implementation of RandomDefs!"L];	  UserTerminal.BlinkDisplay[];	  RETURN;	  END;	data.savedState ¬	  [data.processesPerDrive, data.priority, data.randomSeed];	data.random.seed ¬ data.randomSeed;	RandomDefs.InitializeRandom[@data.random];	data.state ¬ running;	Put.LongString[data.fileSW, "Starting with "L];        Put.Number[	  data.fileSW, data.processesPerDrive,	  [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];        Put.LongString[data.fileSW, " processes/drive, random seed of "L];	Put.LongNumber[	  data.fileSW, data.randomSeed,	  [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];	Put.LongString[data.fileSW, ", at "L];	Time.AppendCurrent[time];	Put.LongString[data.fileSW, time];        Put.CR[data.fileSW];	drive ¬ FloppyChannel.nullDrive;	FOR i: CARDINAL IN [0..maxDrives) DO	  data.stats[i] ¬	    [createdFiles: 0, deletedFiles: 0, fileReads: 0, fileWrites: 0];	  drive ¬ FloppyChannel.GetNextDrive[drive];	  IF data.volumes[i].selected THEN	    BEGIN	    data.volumes[i].volume ¬ Floppy.Open[drive];            THROUGH [0..data.processesPerDrive) DO              Process.Detach[FORK BeaterProcess[driveIndex: i]];              data.forkedProcesses ¬ data.forkedProcesses+1;              ENDLOOP;	    END	  ELSE data.volumes[i].volume ¬ Floppy.nullVolumeHandle;	  ENDLOOP;	IF ~data.verbose AND (data.statsInterval > 0)	  THEN BEGIN          Put.CR[data.fileSW];	  Put.LongString[data.fileSW,	    "Key: [Drive 0: file creates/deletes/reads/writes, Drive 1: ...]"L];          Put.CR[data.fileSW];	  END;	data.forkedProcesses ¬ data.forkedProcesses+1;	Process.Detach[FORK StatsReporter[]];	END;      ENDCASE =>        BEGIN	MsgSW.Post[data.msgSW, "Unexpected Endcase!"L];	UserTerminal.BlinkDisplay[];	RETURN;	END;    END;  Stats:  FormSW.ProcType =    BEGIN    time: LONG STRING ¬ [64];    Put.CR[data.fileSW];    Put.LongString[data.fileSW, "Statistics at "L];    Time.AppendCurrent[time];    Put.LongString[data.fileSW, time];    Put.CR[data.fileSW];    -- It would be nice to have drives next to each other rather than sequential    --  (build string, then print it)    FOR i: CARDINAL IN [0..maxDrives) DO      IF data.volumes[i].selected THEN        BEGIN        Put.LongString[data.fileSW, "  Drive "L];          Put.Number[data.fileSW, i,	    [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];          Put.LongString[data.fileSW, ":"L];          Put.CR[data.fileSW];        Put.LongString[data.fileSW, "  Files created:   "L];          Put.LongNumber[data.fileSW, data.stats[i].createdFiles, numberFormat];          Put.CR[data.fileSW];        Put.LongString[data.fileSW, "  Files destroyed: "L];          Put.LongNumber[data.fileSW, data.stats[i].deletedFiles, numberFormat];         Put.CR[data.fileSW];       Put.LongString[data.fileSW, "  File reads:      "L];         Put.LongNumber[data.fileSW, data.stats[i].fileReads, numberFormat];         Put.CR[data.fileSW];       Put.LongString[data.fileSW, "  File Writes:     "L];         Put.LongNumber[data.fileSW, data.stats[i].fileWrites, numberFormat];         Put.CR[data.fileSW];       Put.CR[data.fileSW];       END;     ENDLOOP;    END;  Stop: ENTRY FormSW.ProcType =    BEGIN    MsgSW.Clear[data.msgSW];    IF data.state ~= running THEN      BEGIN      MsgSW.Post[data.msgSW, "Not running!"L];      UserTerminal.BlinkDisplay[];      RETURN;      END;    Put.LongString[data.fileSW, "Stopping all processes..."L];    data.state ¬ stopped;    BROADCAST statsInterval;  -- knock everybody out of WAIT in case it's long    WHILE data.forkedProcesses > 0 DO WAIT processStopped ENDLOOP;    Put.LongString[data.fileSW, "stopped."L];    Put.CR[data.fileSW];    FOR i: CARDINAL IN [0..maxDrives) DO      IF data.volumes[i].selected THEN        BEGIN        Floppy.Close[data.volumes[i].volume];        data.volumes[i].volume ¬ Floppy.nullVolumeHandle;	END;      ENDLOOP;    END;  ClientTransition: ENTRY ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN	  {data ¬ zone.NEW[Data ¬ []];	  data.volumes ¬ zone.NEW[Volumes];	  data.volumes[0].selected ¬ TRUE;  -- default drive 0 on	  data.stats ¬ zone.NEW[Statistics]};      new = inactive =>        IF data # NIL THEN	  {zone.FREE[@data.volumes]; zone.FREE[@data.stats]; zone.FREE[@data]};      ENDCASE;    END;  Init: PROCEDURE =    BEGIN    drive: FloppyChannel.Drive ¬ FloppyChannel.nullDrive;    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "FloppyBeater"L,      cmSection: "FloppyBeater"L];    Process.InitializeCondition[      @statsInterval, Process.SecondsToTicks[data.statsInterval]];    Process.DisableAborts[@statsInterval];    drivesAvailable ¬ 0;    THROUGH [0..maxDrives) DO      -- This assumes drives must be sequential, beginning with 0.      IF (drive ¬ FloppyChannel.GetNextDrive[drive]) = FloppyChannel.nullDrive        THEN EXIT;      drivesAvailable ¬ drivesAvailable + 1;      ENDLOOP;    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: LONG STRING ¬ [23];    Tool.UnusedLogName[unused: logName, root: "FloppyBeaterImpl.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    OPEN FormSW;    checkDrivesCount: BOOLEAN[TRUE..TRUE] = (maxDrives = 4);    -- checkDrivesCount is to make sure the number of drive items below gets    -- changed if maxDrives is changed.  There doesn't seem to be any good way    -- to put this stuff in an array related to maxDrives.    nItems: CARDINAL = FormItems.LAST.ORD + 1;    priority: ARRAY[0..4) OF Enumerated ¬ [      ["background"L, 0], ["normal"L, 1],      ["foreground"L, 2], ["random"L, 3]];    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.useDrives.ORD] _ TagOnlyItem[      tag: "Use drive(s):"L, place: [3, line0]];    items[FormItems.use0.ORD] _ BooleanItem[      tag: "0"L, place: [111, line0], proc: DriveSelect,      switch: @data.volumes[0].selected];    items[FormItems.use1.ORD] _ BooleanItem[      tag: "1"L, place: [136, line0], proc: DriveSelect,      switch: @data.volumes[1].selected];    items[FormItems.use2.ORD] _ BooleanItem[      tag: "2"L, place: [162, line0], proc: DriveSelect,      switch: @data.volumes[2].selected];    items[FormItems.use3.ORD] _ BooleanItem[      tag: "3"L, place: [187, line0], proc: DriveSelect,      switch: @data.volumes[3].selected];    items[FormItems.randomSeed.ORD] _ LongNumberItem[      tag: "Random Seed"L, place: [230, line0], signed: FALSE, notNegative: TRUE,      value: @data.randomSeed];    items[FormItems.processesPerDrive.ORD] _ NumberItem[      tag: "# Processes per drive"L, place: [3, line1], signed: FALSE,      notNegative: TRUE, value: @data.processesPerDrive];    items[FormItems.priority.ORD] _ EnumeratedItem[      tag: "Priority"L, place: [230, line1], choices: DESCRIPTOR[priority],      value: @data.priority];    items[FormItems.start.ORD] _ CommandItem[      tag: "Start"L, place: [26, line2], proc: Start];    items[FormItems.stats.ORD] _ CommandItem[      tag: "Stats"L, place: [83, line2], proc: Stats];    items[FormItems.stop.ORD] _ CommandItem[      tag: "Stop"L, place: [139, line2], proc: Stop];    items[FormItems.statsInterval.ORD] _ NumberItem[      tag: "Stats interval (seconds) "L, place: [209, line2], signed: FALSE,      notNegative: TRUE, value: @data.statsInterval, proc: StatsIntervalChange];    items[FormItems.verbose.ORD] _ BooleanItem[      tag: "verbose"L, place: [432, line2], switch: @data.verbose];    RETURN[items: items, freeDesc: TRUE];    END;  BeaterProcess: PROCEDURE [driveIndex: CARDINAL] =    BEGIN    BEGIN ENABLE ABORTED => GO TO Return;    pause: CARDINAL ¬ 5;    deleteFile: CARDINAL ¬ 15;    readBits: CARDINAL ¬ 55;    writeBits: CARDINAL ¬ 95;    switchPriority: CARDINAL = 100;    IncrementLongCardinal: ENTRY PROCEDURE [lc: LONG POINTER TO LONG CARDINAL] =      {lc^ ¬ lc^+1};    Stop: ENTRY PROCEDURE RETURNS [BOOLEAN] =      {RETURN [data.state ~= running]};    WaitABit: PROCEDURE = {Process.Pause[1+RandomNumber[100]]};    Process.SetPriority[      SELECT data.savedState.priority FROM        background => Process.priorityBackground,	normal => Process.priorityNormal,	forground => Process.priorityForeground,	random => RandomPriority[],	ENDCASE => Process.priorityBackground];    UNTIL Stop[] DO      createdFile: BOOLEAN;      file: Floppy.FileHandle;      fileSize: Floppy.PageCount;      maxTries: CARDINAL = 2;      tries: CARDINAL ¬ 0;      volume: Floppy.VolumeHandle ¬ data.volumes[driveIndex].volume;      DO        createdFile ¬ TRUE; -- Assume!	fileSize ¬ RandomFileSize[volume];        file ¬          Floppy.CreateFile[volume, fileSize, FileTypes.tUntypedFile !	    Floppy.Error =>	      BEGIN	      createdFile ¬ FALSE;	      IF error ~= insufficientSpace THEN  -- don't count insuff as error	        {IF (tries ¬ tries + 1) = maxTries THEN REJECT};	      CONTINUE;	      END];	IF createdFile THEN EXIT	ELSE IF Stop[] THEN GO TO Return ELSE WaitABit[];	ENDLOOP;      IncrementLongCardinal[@data.stats[driveIndex].createdFiles];      DO -- until told to stop or to delete the file        IF Stop[] THEN EXIT; -- and kill ourselves	Process.Yield[]; -- for politeness!        SELECT RandomNumber[100] FROM	  IN [0..pause) => WaitABit[];	  IN [pause..deleteFile) => EXIT;	  IN [deleteFile..readBits) =>	    BEGIN	    pagesToRead: Space.Interval = RandomPages[fileSize];	    tries ¬ 0;	    Floppy.Read[file, 0, pagesToRead.count, pagesToRead.pointer	      ! Floppy.Error =>	         IF (tries ¬ tries + 1) < maxTries THEN RETRY ELSE REJECT];	    IncrementLongCardinal[@data.stats[driveIndex].fileReads];	    [] ¬ Space.Unmap[pagesToRead.pointer];	    END;	  IN [readBits..writeBits) =>	    BEGIN	    pagesToWrite: Space.Interval = RandomPages[fileSize];	    Floppy.Write[file, 0, pagesToWrite.count, pagesToWrite.pointer	      ! Floppy.Error =>	         IF (tries ¬ tries + 1) < maxTries THEN RETRY ELSE REJECT];	    IncrementLongCardinal[@data.stats[driveIndex].fileWrites];	    [] ¬ Space.Unmap[pagesToWrite.pointer];	    END;	  IN [writeBits..switchPriority) =>	    IF data.savedState.priority = random THEN	      Process.SetPriority[RandomPriority[]]	    ELSE NULL; -- and try again for a new command	  ENDCASE;        ENDLOOP;      tries ¬ 0;      Floppy.DeleteFile[file ! Floppy.Error =>	IF (tries ¬ tries + 1) < maxTries THEN RETRY ELSE REJECT];      IncrementLongCardinal[@data.stats[driveIndex].deletedFiles];      ENDLOOP;    GO TO Return;    END    EXITS    Return =>      BEGIN      Dying: ENTRY PROCEDURE =        BEGIN	data.forkedProcesses ¬ data.forkedProcesses-1;	NOTIFY processStopped;	END;      Dying[];      END;    END;  -- BeaterProcess  BriefStats: PROCEDURE =    BEGIN    s: STRING = [45];    String.AppendChar[s, '[];    FOR i: CARDINAL IN [0..maxDrives) DO      IF data.volumes[i].selected THEN        BEGIN        IF i > 0 THEN String.AppendString[s, ", "L ];        String.AppendDecimal[s, i];        String.AppendString[s, ": "L];        String.AppendLongDecimal[s, data.stats[i].createdFiles];        String.AppendChar[s, '/];        String.AppendLongDecimal[s, data.stats[i].deletedFiles];        String.AppendChar[s, '/];        String.AppendLongDecimal[s, data.stats[i].fileReads];        String.AppendChar[s, '/];        String.AppendLongDecimal[s, data.stats[i].fileWrites];       END;     ENDLOOP;    String.AppendChar[s, ']];    Put.LongString[data.fileSW, s];    END;  DriveSelect: FormSW.NotifyProcType =    -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL]    BEGIN    -- Assumes drives must be sequential, beginning with 0.    MsgSW.Clear[data.msgSW];    IF index > (FormItems.use0.ORD + drivesAvailable-1) THEN      BEGIN      MsgSW.Post[data.msgSW, "No such drive!"L];      data.volumes[index - FormItems.use0.ORD].selected ¬ FALSE;      FormSW.DisplayItem[sw: sw, index: index];      UserTerminal.BlinkDisplay[];      END;    END;  RandomFileSize: ENTRY PROCEDURE [volume: Floppy.VolumeHandle]    RETURNS [size: Floppy.PageCount] =    BEGIN    name: LONG STRING ¬ [Floppy.maxCharactersInLabel];    maxFileSize: CARDINAL =      CARDINAL [        MIN [	  LONG[LAST[CARDINAL]],	  Floppy.GetAttributes[volume, name].largestBlock]];    SELECT maxFileSize FROM      --0, 1 => RETURN [maxFileSize];      0, 1 => RETURN [1];  -- Let Create call handle the insufficientSpace error      ENDCASE =>        RETURN [	  1+LONG[RandomDefs.Random[@data.random, maxFileSize-1]]];    END;    RandomNumber: ENTRY PROCEDURE [max: CARDINAL] RETURNS [CARDINAL] =    {RETURN [RandomDefs.Random[@data.random, max]]};    RandomPages: ENTRY PROCEDURE [fileSize: Floppy.PageCount]    RETURNS [interval: Space.Interval] =    BEGIN    size: CARDINAL ¬ 1 +      RandomDefs.Random[        @data.random,	IF fileSize < LONG[LAST[CARDINAL]]+1 THEN CARDINAL[fileSize-1]	ELSE LAST[CARDINAL]-1];    RETURN[      [Space.ScratchMap[size !          Space.InsufficientSpace, Volume.InsufficientSpace =>	    {size ¬ size/2; RETRY};],       size]];    END;  RandomPriority: ENTRY PROCEDURE [] RETURNS [prority: Process.Priority] =    BEGIN    RETURN [      SELECT RandomDefs.Random[@data.random, 100] FROM        < 50 => Process.priorityBackground,        < 75 => Process.priorityNormal,        < 100 => Process.priorityForeground,        ENDCASE => Process.priorityBackground -- should never get here      ];    END;  StatsIntervalChange: FormSW.NumberNotifyProcType =    -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    --  oldValue: UNSPECIFIED]    BEGIN    ExchangeTimeout: ENTRY PROCEDURE =      {BROADCAST statsInterval};    IF data.statsInterval > 0 THEN      BEGIN      Process.SetTimeout[condition: @statsInterval,        ticks: Process.SecondsToTicks[data.statsInterval]];      IF oldValue = 0 THEN        {Put.LongString[data.fileSW, "Stats feedback enabled"L];	 Put.CR[data.fileSW]};      END    ELSE      BEGIN      Process.DisableTimeout[condition: @statsInterval];      Put.LongString[data.fileSW, "Stats feedback disabled"L];      Put.CR[data.fileSW];      END;    ExchangeTimeout[];    END;  StatsReporter: PROCEDURE =    BEGIN    Stop: ENTRY PROCEDURE RETURNS [BOOLEAN] =      BEGIN      WAIT statsInterval;      RETURN [data.state ~= running];      END;    KillingOurselves: ENTRY PROCEDURE =      BEGIN      data.forkedProcesses ¬ data.forkedProcesses-1;      NOTIFY processStopped;      END;    Process.SetPriority[Process.priorityForeground];    WHILE ~Stop[] DO      IF data.verbose THEN Stats[] ELSE BriefStats;      ENDLOOP;    KillingOurselves[];    END;  -- Mainline code  Init[];  -- this gets string out of global frame  END...    
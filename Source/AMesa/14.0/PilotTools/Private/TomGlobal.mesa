-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- TomGlobal.mesa (last edited by Jonathan JXG     11-Feb-83 11:36:57)-- This tool provides dynamically updateable facilities for monitoring low level -- "performance" interfaces, typically made available as a set of variables from the-- depths of Pilot. To make such variables available to this tool, stubs of code must-- be loaded which transform the low level interface into a higher level, generalised-- interface. To this end, the tool provides public routines in the interface TomOps-- DIRECTORY  Ascii USING [NUL, CR],  CmFile USING [Close, Error, FindSection, Handle, NextValue,     TableError, UserDotCmOpen],  Context USING [Create, Destroy, DestroyProcType, Find, NopDestroyProc,     SimpleDestroyProc, Type,UniqueType],  Exec USING [AddCommand, ExecProc],  FormSW USING [AllocateItemDescriptor, ClientItemsProcType, CommandItem,     Enumerated, EnumeratedItem, newLine, NumberItem,     ProcType, sameLine, StringItem],  MFile USING [Error, ReadOnly],  MLoader USING [Error, Handle, Run, VersionMismatch],  Process USING [GetCurrent, priorityBackground, priorityForeground, priorityNormal],  Put USING [LongString],  Runtime USING [GetBcdTime],  String USING [AppendString, AppendStringAndGrow, Copy, CopyToNewString],  StringLookUp USING [noMatch, TableDesc],  Time USING [Append, Unpack],  Token USING [FreeTokenString, Item],  TomOps,  Tool USING [AddThisSW, Create, MakeSWsProc, MakeFormSW, MakeMsgSW,    MakeStringSW, State],  ToolWindow USING [CreateSubwindow, Place, TransitionProcType],  Version USING [Append],  Window USING [Box, GetBox, Handle, nullBox];    TomGlobal:  MONITOR  -- protecting the list of contexts  IMPORTS CmFile, Context, Exec, FormSW, MFile, MLoader,  Process, Put, Runtime,    String, Time, Token, TomOps, Tool, ToolWindow, Version, Window  EXPORTS TomOps   SHARES TomOps =  BEGIN OPEN TomOps;     -- ***** global variables    -- z (=Heap.systemZone) is exported from TomPImpl so that it can be used standalone    tomContextType: PUBLIC Context.Type ¬ Context.UniqueType[];  ctxChain: CtxHandle ¬ NIL;      currentProcess:PROCESS ¬ NIL;  -- used by pseudo-ENTRY mechanism  nesting:CARDINAL ¬ 0;  lockReleased:CONDITION;   locked:BOOLEAN ¬ FALSE;      cmSection:LONG STRING ¬ "Tom"; -- used by both Tool.create and ProcessUserCM      -- ***** Global monitor --    -- To get around certain messy situations that can occur when starting  -- up new TomTool instances, we use a serialization mechanism that doesn't  -- deadlock if we call one "entry" procedure from another as long as both  -- are in the same process.    -- Real entry procedures --    ReleaseLock: ENTRY PROCEDURE =    BEGIN    IF (nesting ¬ nesting - 1) = 0     THEN {locked ¬ FALSE; BROADCAST lockReleased}    END;    AcquireLock: ENTRY PROCEDURE =    BEGIN    us: PROCESS = Process.GetCurrent[];    IF locked     THEN      IF currentProcess=us       THEN {nesting ¬ nesting + 1; RETURN}      ELSE WHILE locked DO WAIT lockReleased ENDLOOP;    locked ¬ TRUE;    currentProcess ¬ us;    nesting ¬ 1;    END;    Enter: PROCEDURE [proc: PROCEDURE] = {AcquireLock[]; proc[]; ReleaseLock[]};    StartUp: --ENTRY-- PROCEDURE [ctx:CtxHandle ¬ NIL] =    BEGIN    Startup1: PROCEDURE[] =      BEGIN      -- initially, this is called from the main line code, to set up the      -- first window, and so we let Tool.Create scan User.cm for       -- InitialState, WindowBox and TinyPlace.  On subsequent calls (when      -- the user bugs Another!) the state is always active and the place is      -- generated from the previous one.            localCmSection:LONG STRING;      initialState:Tool.State;      initialBox:Window.Box;      toolName:LONG STRING ¬ [100];      String.Copy[from:"Tom ", to:toolName];      Version.Append[toolName];      String.AppendString[to:toolName, from:" of "L];      Time.Append[toolName, Time.Unpack[Runtime.GetBcdTime[]]];            IF ctx=NIL  -- first time      THEN {localCmSection ¬ cmSection;            initialBox ¬ Window.nullBox;	    initialState ¬ default}      ELSE {localCmSection ¬ ""L;            initialBox ¬ Window.GetBox[ctx.toolWindow];	    initialBox.place.x ¬ initialBox.place.x+20;            initialBox.place.y ¬ initialBox.place.y+20;	    initialState ¬ active};	          [] ¬ Tool.Create[makeSWsProc: AnotherMakeSWs, initialState: initialState,                       clientTransition: ClientTransition, name:toolName,                       cmSection: localCmSection, tinyName1: "Tom"L, tinyName2: ""L,		       initialBox:initialBox];		             END;        	           Enter[Startup1]    END;              AnotherMakeSWs: Tool.MakeSWsProc =    BEGIN    MakeContext: PROCEDURE [sw:Window.Handle] =      {Context.Create[type:tomContextType, data:ctx, proc:Context.NopDestroyProc,                       window:sw]};    MakeForm: FormSW.ClientItemsProcType =      BEGIN OPEN FormSW;      -- ctx: CtxHandle;  NOTE we can't get ctx from the 'sw' parameter (we haven't had      -- a chance to set it up yet, and we do not get given a 'window' parameter  -      -- hence the nested use of 'ctx'  from AnotherMakeSWs.      priorityChoices:ARRAY [0..3) OF Enumerated ¬        [["0(b)"L, Process.priorityBackground],         ["1(n)"L,     Process.priorityNormal],         ["2(f)"L, Process.priorityForeground]];            afterGap: ToolWindow.Place = [-20, sameLine];      items ¬ AllocateItemDescriptor[iLastPlus1];      items[iAnother] ¬         CommandItem[tag:"Another", proc:Another, place:newLine];      items[iDestroy] ¬         CommandItem[tag:"Destroy", proc:MainFormCommandProc];      items[iReset] ¬         CommandItem[tag:"Reset", proc:MainFormCommandProc];      items[iLoad] ¬         CommandItem[tag:"Load", proc:MainFormCommandProc, place:afterGap];      items[iSave] ¬         CommandItem[tag:"Save", proc:MainFormCommandProc];      items[iParmFile] ¬         StringItem[tag:"Parameter File", menuProc:MainFormMenuProc,		   string:@ctx.parmFileName, inHeap:TRUE, boxWidth:100];      items[iRemoteMachine] ¬        StringItem[tag:"Remote machine", string:@ctx.remoteName, inHeap:TRUE,		   place:newLine];	         items[iAdd] ¬         CommandItem[tag:"Add", proc:MainFormCommandProc, place:newLine];      items[iInterface] ¬         StringItem[tag:"Interface", menuProc:MainFormMenuProc,            	   string:@ctx.interfaceName, inHeap:TRUE, boxWidth:80];      items[iVariable] ¬         StringItem[tag:"Variable",  menuProc:MainFormMenuProc,                   string:@ctx.variableName, inHeap:TRUE, boxWidth:200];      items[iApply] ¬         CommandItem[tag:"Apply", proc:MainFormCommandProc, place:newLine];       items[iDisplay] ¬         StringItem[tag:"Display", menuProc:MainFormMenuProc,         	   string:@ctx.displayName, inHeap:TRUE, boxWidth:80];      items[iPriority] ¬         EnumeratedItem[tag:"Priority", feedback:all,		       choices:DESCRIPTOR[priorityChoices], value:@ctx.priority];            items[iInterval] ¬         NumberItem[tag:"Interval (mS)", signed:FALSE, notNegative:TRUE,       	           default:1000, value:@ctx.interval];      RETURN[items: items, freeDesc: TRUE];      END;  -- MakeForm          ctx:CtxHandle ¬ GetContext[window];      ctx.msgSW ¬ Tool.MakeMsgSW[window:window, lines:2];    ctx.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    ctx.parmSW ¬ Tool.MakeStringSW[window:window, h:100,      			           s:@ctx.parmString, access:edit, expandable:TRUE];	-- this next sw is a fudge; client sws have to be inserted before it	-- to get box dimensions correct			       ctx.lastSW ¬ ToolWindow.CreateSubwindow[parent:window];     Tool.AddThisSW[window:window, sw:ctx.lastSW, swType:vanilla];     MakeContext[sw:ctx.msgSW];    MakeContext[sw:ctx.formSW];    MakeContext[sw:ctx.parmSW];    END;    Another: FormSW.ProcType = {StartUp[GetContext[sw]]};               -- ***** the next procedure is called whenever the state of the window changes          ClientTransition: -- ENTRY -- ToolWindow.TransitionProcType =    BEGIN    ClientTransition1: PROCEDURE =      BEGIN      IF old=inactive -- AND new=inactive OR new=tiny --      THEN        BEGIN	wCtx: CtxHandle ¬ z.NEW[TomContext];	wCtx.priority ¬ Process.priorityBackground; -- not compile-time constant - moan!	Context.Create[type:tomContextType, data:wCtx, proc:Context.SimpleDestroyProc,	               window:window];        wCtx.toolWindow ¬ window;        AddToList[wCtx];	wCtx.placeHandle ¬ z.NEW[PlaceObject];	END      ELSE      IF -- old=active OR old=tiny AND -- new=inactive      THEN         BEGIN	ctx:CtxHandle ¬ GetContext[window];	IF ctx=NIL THEN RETURN;	SetDisplay[ctx, NIL, NIL];	IF ctx.placeHandle.type=remote	THEN DeleteCourierHandle[ctx.placeHandle.cH];	z.FREE[@ctx.placeHandle];		RemoveFromList[ctx];         Context.Destroy[tomContextType, window]	END      END;	    Enter[ClientTransition1]    END;   -- ***** process User.cm    ProcessUserCM: PROCEDURE [] =    BEGIN    -- Note that WindowBox, InitialState and TinyPlace are all picked    -- up by the first call of Tool.Create     Entry: TYPE = MACHINE DEPENDENT       {interface(0), interfaces, display, displays, noMatch(StringLookUp.noMatch)};    DefinedEntries: TYPE = Entry[interface..displays];    entryTable: ARRAY DefinedEntries OF LONG STRING ¬      [interface:"interface"L, interfaces:"interfaces"L,       display:"display", displays:"displays"L];    entry:Entry;    userCm:CmFile.Handle ¬ NIL;    CheckType: PROCEDURE [h:CmFile.Handle, table:StringLookUp.TableDesc]               RETURNS [index:CARDINAL] = CmFile.NextValue;    NextEntry: PROCEDURE [h:CmFile.Handle,               		  table:LONG DESCRIPTOR FOR ARRAY DefinedEntries 			  		OF LONG STRING]	       RETURNS [index:Entry] = LOOPHOLE[CheckType];    userCm ¬ CmFile.UserDotCmOpen[!CmFile.Error => CONTINUE];        IF userCm#NIL AND CmFile.FindSection[userCm, cmSection]    THEN      DO        SELECT (entry ¬ NextEntry[h:userCm, table:DESCRIPTOR[entryTable]				  ! CmFile.TableError => RESUME])	FROM	  interface, interfaces => 	    UNTIL userCm­.break=Ascii.CR OR userCm­.break=Ascii.NUL	      DO value:LONG STRING = Token.Item[userCm];	         [] ¬ TryToLoad[value, interface];		 [] ¬ Token.FreeTokenString[value]	      ENDLOOP;	  display, displays =>	    			  	    UNTIL userCm­.break=Ascii.CR OR userCm­.break=Ascii.NUL	      DO value:LONG STRING = Token.Item[userCm];	         [] ¬ TryToLoad[value, display];		 [] ¬ Token.FreeTokenString[value]	      ENDLOOP;       -- windowBox    => done in Tool.Create --       -- initialState => done in Tool.Create --       -- tinyPlace    => done in Tool.Create --    	  noMatch => EXIT;	ENDCASE;      ENDLOOP;          IF userCm#NIL THEN []¬CmFile.Close[userCm];    END;    	 	 	 		    	      -- ***** miscellaneous utility routines        AddToList: PROCEDURE [c:CtxHandle] =    INLINE {c.next ¬ ctxChain; ctxChain ¬ c };      RemoveFromList: PROCEDURE [c:CtxHandle] =    BEGIN    IF c=ctxChain    THEN  ctxChain ¬ ctxChain.next    ELSE FOR ctx:CtxHandle ¬ ctxChain, ctx.next UNTIL ctx=NIL         DO IF ctx.next=c	    THEN {ctx.next ¬ c.next; RETURN}	 ENDLOOP    END;       Main: Exec.ExecProc = {StartUp[]};           -- dynamic code loading ...    TryToLoad:     PUBLIC PROCEDURE[name:LONG STRING, type:InterfaceOrDisplay,     		     msgSW:Window.Handle ¬ NIL]       RETURNS [ok:BOOLEAN] =    BEGIN    Write: PROCEDURE[s:LONG STRING] = {Put.LongString[msgSW, s]};    BEGIN    ENABLE      BEGIN      MFile.Error   => {Write["... error accessing file\n"]; GOTO quit};      MLoader.Error => {Write["... error loading file\n"]; GOTO quit};      MLoader.VersionMismatch                    => {Write["... version mismatch\n"]; GOTO quit};      END;          appendix: LONG STRING ¬ (IF type=display THEN "TomD.bcd" ELSE "TomP.bcd");    filename:LONG STRING;    handle:MLoader.Handle;        -- internal convention - error message menu items end in '!    IF name[name.length-1]='! THEN RETURN [FALSE];        filename ¬ String.CopyToNewString[s:name, longer:appendix.length, z:z];    String.AppendStringAndGrow[to:@filename, from:appendix, z:z];    Write["trying to load "];  Write[filename];  Write[" ... "];    handle ¬ MLoader.Run[MFile.ReadOnly[name:filename, release:[]]];    Write["ok\n"];        RETURN [TRUE];        EXITS      quit => RETURN [FALSE]    END    END;             -- ***** Main line code    ProcessUserCM[];    Exec.AddCommand["Tom.~", Main];    	         END....      
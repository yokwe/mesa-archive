-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- GraphTomDSlct.mesa (last edited by JBD      7-Jul-86 16:31:33)DIRECTORY  GraphTomDOps,  Selection USING [ActOn, ActOnProcType, Clear, ConvertProcType, Set],  UserTerminal USING [BlinkDisplay],  Window USING [Place];  GraphTomDSlct:  MONITOR   LOCKS globalInfo USING globalInfo:GraphTomDOps.GlobalInfoP   IMPORTS GraphTomDOps, Selection, UserTerminal  EXPORTS GraphTomDOps =  BEGIN OPEN GraphTomDOps;    prevPlace: RECORD [i, j:CARDINAL] ¬ [LAST[CARDINAL], 0];  iAtStartOfAdjust: CARDINAL;  adjustAddingItemsToSelection:BOOLEAN ¬ FALSE;      anchorJLeft: BOOLEAN;      -- representation of the current selection:  -- *  the current selection can be any (contiguous) subrange of the history  --    of any (possibly non-contiguous) subset of graphs  -- *  globalInfo.slctScale indicates current scale ('none' if not)  -- *  globalInfo.slct indicates the current subrange, slaved in  --    globalInfo.slctAtStartOfAdjust whilst adjusting the selection  -- *  itemInfo.selected indicates if this graph is included in  --    the current selected (slaved in ...AtStartOfAdjust while ...)  -- *  itemInfo.slct is maintained in GraphSW and indicates what is  --    currently on display - call DisplaySelection to make these fields  --    up to date          SetSlct:     PUBLIC ENTRY PROCEDURE[globalInfo:GlobalInfoP, place:Window.Place,     			   soonAfter:BOOLEAN, inMotion:BOOLEAN] =    BEGIN    Set: PROCEDURE[i1, i2, j1, j2:CARDINAL, scale:SlctScale] =      BEGIN      globalInfo.slct ¬ [j1, j2];      globalInfo.slctScale ¬ scale;      FOR i:CARDINAL IN [i1..i2]        DO	itemInfo:ItemInfoP ¬ globalInfo.items[i].client;	itemInfo.isSelected ¬ TRUE	ENDLOOP      END;          intNewI:INTEGER ¬ (place.y+globalInfo.yOffset-rowOffset)/globalInfo.rowH;    intNewJ:INTEGER ¬ (place.x-globalInfo.firstBarX)/globalInfo.barDims.w;    newI, newJ:CARDINAL;    scale:SlctScale ¬        (IF globalInfo.slctScale=none THEN bar ELSE globalInfo.slctScale);        IF intNewI NOT IN [0..LENGTH[globalInfo.items])	      -- silly place      OR intNewJ NOT IN [0..INTEGER[globalInfo.historySize])  -- ditto    THEN RETURN;        newJ ¬ intNewJ;  newI ¬ intNewI;  -- now we know they are valid!    IF inMotion AND InSamePlace[scale, newI, newJ] THEN RETURN;    Selection.Clear[];    IF ~inMotion    THEN scale ¬ (IF soonAfter AND scale#all THEN SUCC[scale] ELSE bar);        SELECT scale     FROM      bar =>   Set[newI, newI, newJ, newJ, scale];      graph => Set[newI, newI, 0, globalInfo.historySize-1, scale];      all =>   Set[0, LENGTH[globalInfo.items]-1, 0, globalInfo.historySize-1, scale];      ENDCASE => ERROR;        adjustAddingItemsToSelection ¬ TRUE;    Selection.Set[globalInfo, ConvertSlct, ActOnSlct];    Selection.ActOn[mark];  -- will cause display update          END;      AdjustSlct:     PUBLIC ENTRY PROCEDURE[globalInfo:GlobalInfoP, place:Window.Place,     			   soonAfter:BOOLEAN, inMotion:BOOLEAN] =    BEGIN    NearerLeft: PROCEDURE [left, i, right: INTEGER] RETURNS [BOOLEAN] =       -- warning - must NOT be INLINE - compiler loses INTEGER attr of parms if so      {RETURN [(IF left=right THEN i<left ELSE ABS[left-i] < ABS[right-i])]};    intNewI:INTEGER ¬ (place.y+globalInfo.yOffset-rowOffset)/globalInfo.rowH;    intNewJ:INTEGER ¬ (place.x-globalInfo.firstBarX)/globalInfo.barDims.w;    newI, newJ:CARDINAL;    itemInfo:ItemInfoP;    scale:SlctScale ¬ globalInfo.slctScale;    adjusted:BOOLEAN ¬ FALSE;        IF   intNewI NOT IN [0..LENGTH[globalInfo.items])	  -- silly place      OR intNewJ NOT IN [0..INTEGER[globalInfo.historySize]) -- ditto      OR globalInfo.slctScale=none 			  -- not selected at all      OR globalInfo.slctScale=all    THEN RETURN;         newJ ¬ intNewJ;  newI ¬ intNewI;  -- now we know they are valid!    itemInfo ¬ globalInfo.items[newI].client;        IF ~inMotion    -- ie start of adjust    THEN      BEGIN      globalInfo.slctAtStartOfAdjust ¬ globalInfo.slct;  -- save copy of selection      FOR i:CARDINAL IN [0..LENGTH[globalInfo.items])        DO    	tempItemInfo:ItemInfoP ¬ globalInfo.items[i].client;	tempItemInfo.wasSelectedAtStartOfAdjust ¬ tempItemInfo.isSelected	ENDLOOP;             IF scale=bar      THEN IF NearerLeft[globalInfo.slct.j1, newJ, globalInfo.slct.j2]        THEN {anchorJLeft ¬ FALSE; globalInfo.slct.j1 ¬ newJ}        ELSE {anchorJLeft ¬ TRUE;  globalInfo.slct.j2 ¬ newJ};	      iAtStartOfAdjust ¬ newI;      adjustAddingItemsToSelection ¬         (IF soonAfter THEN ~adjustAddingItemsToSelection ELSE TRUE);      itemInfo.isSelected ¬ adjustAddingItemsToSelection;      adjusted ¬ TRUE      END    ELSE      BEGIN      IF newI#prevPlace.i      THEN        BEGIN	FOR i:CARDINAL IN [MIN[prevPlace.i, newI]..MAX[prevPlace.i, newI]]	  DO	  tempItemInfo:ItemInfoP ¬ globalInfo.items[i].client;	  tempItemInfo.isSelected ¬	     (IF i IN [iAtStartOfAdjust..newI]  OR  i IN [newI..iAtStartOfAdjust] 	      THEN adjustAddingItemsToSelection	      ELSE tempItemInfo.wasSelectedAtStartOfAdjust)	  ENDLOOP;	adjusted ¬ TRUE        END;      IF newJ#prevPlace.j AND scale=bar      THEN        BEGIN        IF  ~anchorJLeft AND newJ>globalInfo.slct.j2         OR  anchorJLeft AND newJ<globalInfo.slct.j1        THEN {anchorJLeft ¬ ~anchorJLeft;  	      globalInfo.slct ¬ globalInfo.slctAtStartOfAdjust};        IF anchorJLeft         THEN globalInfo.slct.j2 ¬ newJ        ELSE globalInfo.slct.j1 ¬ newJ;	adjusted ¬ TRUE        END      END;        prevPlace ¬ [newI, newJ];          IF adjusted THEN DisplaySelection[globalInfo]     END;    		              ConvertSlct: Selection.ConvertProcType ={RETURN [NIL]};    ActOnSlct: Selection.ActOnProcType =    BEGIN    globalInfo:GlobalInfoP ¬ data;    SELECT action    FROM      mark   => globalInfo.selectionMarked ¬ TRUE;      unmark => globalInfo.selectionMarked ¬ FALSE;      delete => {UserTerminal.BlinkDisplay[]; RETURN};      clear  =>         BEGIN	globalInfo.slctScale ¬ none;	globalInfo.selectionMarked ¬ FALSE;	FOR i:CARDINAL IN [0..LENGTH[globalInfo.items])          DO    	  itemInfo:ItemInfoP ¬ globalInfo.items[i].client;	  itemInfo.isSelected ¬ FALSE	  ENDLOOP	END;      ENDCASE;    DisplaySelection[globalInfo];    END;      InSamePlace: PROCEDURE[scale:SlctScale, i, j:CARDINAL]     RETURNS [t:BOOLEAN] =    BEGIN    t ¬ SELECT scale FROM          bar   => prevPlace=[i, j],          graph => prevPlace.i=i,          all   => TRUE,          ENDCASE => FALSE;    prevPlace ¬ [i, j]    END;	  END...  LOG 7-Jul-86 16:28:18  JBD  Repaired call to InSamePlace (previously used uninitialized i,j)
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Script1.mesa        4-Mar-83 13:58:24 by CAJ -- Virtual memory test program, Klamath Pilot.-- Script1 tests ForceOut.DIRECTORY  Environment USING [PageCount],  ScriptOps USING [RegisterScript],  VM USING [Interval, nullBackingStoreRuns],  VMTestOperations --USING [all the operations]--,  VMTestScript USING [GetHeap, GetTestVMSize, GiveBackHeap, MakeBackingData,    MakeIrregularSwapData, MakeUniformSwapData, Ticker];Script1: PROGRAM  IMPORTS ScriptOps, VMTestOperations, VMTestScript =  BEGIN  ------------  -- PUBLIC procedures:  -- RunTests is a script of tests using VMTestOperations procedures  RunTests: PUBLIC PROCEDURE =    BEGIN OPEN VMTestOperations, VMTestScript;        heap: UNCOUNTED ZONE ¬ GetHeap[];    TestForceOut[heap];    heap ¬ GiveBackHeap[heap];    END;  ------------  -- PRIVATE procedures:  -- Map unit attribute combinations  TestForceOut: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    vmSize: Environment.PageCount ¬ GetTestVMSize[];    pArrayA: LONG POINTER;    pArrayB: LONG POINTER;    -- ForceOuts with normal case Map (swappable, readWrite, alive)    pArrayA ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 2, 3]];    Map[id: "irregular A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 3]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "uniform B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    -- forceOut single swap unit, clean, out    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut single swap unit, clean, in    Touch[[5, 2], read];    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut single swap unit, dirty    Touch[[5, 2], write];    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut overlapping swap units    Touch[[12, 5], write];    ForceOut[[12, 5], wait];    Ticker[];    -- forceOut overlapping map units    Touch[[8, 6], write];    ForceOut[[8, 6], wait];    Ticker[];    -- forceOut unmapped    ForceOut[[20, 5], wait];    Ticker[];    -- forceOut all of testVM    ForceOut[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    -- ForceOuts on space Mapped swappable + readWrite + dead    pArrayA ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 2, 3]];    Map[id: "irregular A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 3]],      life: dead,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "uniform B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    -- forceOut single swap unit    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut overlapping swap units    Touch[[12, 5], write];    ForceOut[[12, 5], wait];    Ticker[];    -- forceOut overlapping map units    Touch[[8, 6], write];    ForceOut[[8, 6], wait];    Ticker[];    -- forceOut all of testVM    ForceOut[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    -- ForceOuts on space Mapped resident + readWrite + alive    pArrayA ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 2, 3]];    Map[id: "irregular A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 3]],      life: alive,      swappability: resident];    pArrayB ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "uniform B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: resident];    -- forceOut single swap unit, clean, in    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut single swap unit, clean, out    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut single swap unit, dirty    Touch[[5, 2], write];    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut overlapping swap units    Touch[[12, 5], write];    ForceOut[[12, 5], wait];    Ticker[];    -- forceOut overlapping map units    Touch[[8, 6], write];    ForceOut[[8, 6], wait];    Ticker[];    -- forceOut all of testVM    ForceOut[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    -- ForceOuts on space Mapped resident + readWrite + dead    pArrayA ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 2, 3]];    Map[id: "irregular A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 3]],      life: dead,      swappability: resident];    pArrayB ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "uniform B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: resident];    -- forceOut single swap unit    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut overlapping swap units    Touch[[12, 5], write];    ForceOut[[12, 5], wait];    Ticker[];    -- forceOut overlapping map units    Touch[[8, 6], write];    ForceOut[[8, 6], wait];    Ticker[];    -- forceOut all of testVM    ForceOut[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    -- ForceOuts on space Mapped resident + not backed (standard data space)    pArrayA ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 2, 3]];    Map[id: "irregular A"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 3]],      life: alive,      swappability: resident];    pArrayB ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "uniform B"L,      interval: [10, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: resident];    -- forceOut single swap unit, clean, out    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut single swap unit, clean, in    Touch[[5, 2], read];    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut single swap unit, dirty    Touch[[5, 2], write];    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut overlapping swap units    Touch[[12, 5], write];    ForceOut[[12, 5], wait];    Ticker[];    -- forceOut overlapping map units    Touch[[8, 6], write];    ForceOut[[8, 6], wait];    Ticker[];    -- forceOut all of testVM    ForceOut[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    -- ForceOuts on space Mapped resident + not backed + dead    pArrayA ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 2, 3]];    Map[id: "irregular A"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 3]],      life: dead,      swappability: resident];    pArrayB ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "uniform B"L,      interval: [10, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: resident];    -- forceOut single swap unit    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut overlapping swap units    Touch[[12, 5], write];    ForceOut[[12, 5], wait];    Ticker[];    -- forceOut overlapping map units    Touch[[8, 6], write];    ForceOut[[8, 6], wait];    Ticker[];    -- forceOut all of testVM    ForceOut[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    -- ForceOuts on space Mapped resident + readOnly + alive    pArrayA ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 2, 3]];    Map[id: "irregular A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 3]],      access: readOnly,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 3]],      life: alive,      swappability: resident];    pArrayB ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "uniform B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 5]],      access: readOnly,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: resident];    -- forceOut single swap unit, clean, in    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut single swap unit, clean, out    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut overlapping swap units    ForceOut[[12, 5], wait];    Ticker[];    -- forceOut overlapping map units    ForceOut[[8, 6], wait];    Ticker[];    -- forceOut all of testVM    ForceOut[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    -- ForceOuts on space Mapped swappable + readOnly + alive    pArrayA ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 2, 3]];    Map[id: "irregular A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 3]],      access: readOnly,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 3]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "uniform B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 5]],      access: readOnly,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    -- forceOut single swap unit, clean, out    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut single swap unit, clean, in    Touch[[5, 2], read];    ForceOut[[5, 2], wait];    Ticker[];    -- forceOut overlapping swap units    ForceOut[[12, 5], wait];    Ticker[];    -- forceOut overlapping map units    ForceOut[[8, 6], wait];    Ticker[];    -- forceOut all of testVM    ForceOut[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    -- Case swappable + readOnly + dead is illegal Map option   END;  ------------  -- PUBLIC SIGNALs and ERRORs: none  ------------  -- Initialization:  ScriptOps.RegisterScript[RunTests, "ForceOut"L];  END.LOG 3-Mar-83 14:14:41   CAJ    Created file.
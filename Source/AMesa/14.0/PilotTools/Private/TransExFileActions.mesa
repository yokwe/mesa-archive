-- Copyright (C) 1983, 1985, 1987  by Xerox Corporation. All rights reserved. -- TransEx>TransExFileActions.mesa          9-Feb-87 18:42:48 by RSV    -- Implementation Note:  Consider the following scenario: delete a file in a transaction; then create a file in some other transaction which essentially fills the volume; then crash.  During crash recovery of the first transaction, Pilot will be unable to locate enough volume space to recreate the deleted file, and thus will be permanently hogtied.  To avoid this problem, this program keeps track of the total number of free pages on each volume necessary to ensure that there is sufficient space for Crash Recovery to recreate and/or grow all files that were deleted or shrunk in all ongoing transactions, and attempts to never go below that minimum free space.DIRECTORY  Environment USING [PageCount,-- PageNumber, PageOffset, -- wordsPerPage],  File USING [    Create, Delete, File, GetAttributes, GetSize,    MakePermanent, nullFile, PageCount, PageNumber, SetSize, Type, Unknown],  -- Inline USING [BITAND,  LowHalf],  TransExDefs USING [RealTransaction],  Process USING [Yield],  --Runtime USING [CallDebugger],  Space USING [    CopyIn, CopyOut, GetSwapUnitAttributes, Interval,    MakeReadOnly, MakeWritable, Map, nullInterval, PageCount,    SwapUnitSize, Unmap],  SpecialFile USING [MakeTemporary],  TestFrameworkDefs USING [    AndDo, Base, Circumstance, ColdStartProc, FinalFinishProc, Free, nil, Node,    OneOf, PrivateGenerator, Random, RandomCase, RandomRange, Register, RelPtr,    RestartProc, StartStop, testFileType, Tick, WantsRandoms, Verbosity, VWFCR,    VWFN, VWF0, VWF1, VWF2],  Volume USING [GetAttributes, GetNext, GetStatus, ID, InsufficientSpace, nullID, PageCount, systemID, Unknown];TransExFileActions: MONITOR  IMPORTS File, --Inline,-- Process, --Runtime, -- Space, SpecialFile,  TestFrameworkDefs, Volume  EXPORTS TestFrameworkDefs =  BEGIN OPEN TestFrameworkDefs;  -- Parameters:  maxPagesPerFile: FilePageCount = 100;  maxFilesPerTrans: CARDINAL = 4;  maxFilesInPool: CARDINAL = 20;  -- (files which are not currently in any transaction.)  minFreeOnVolume: VolPageCount = 200;  -- (a safety margin for unrelated processes.)  -- Types:  nullTransactionHandle: DummyTransactionHandle = [0];  DummyTransactionHandle: TYPE = RECORD[CARDINAL];  TransInfo: TYPE = RECORD [    trans: DummyTransactionHandle, file: ARRAY TransFiles OF TransFileInfo];  TransFiles: TYPE = [0..maxFilesPerTrans);  TransFileInfo: TYPE = RECORD [    busy: BOOLEAN,  -- is file being operated on currently?    shrunk: BOOLEAN,  -- has file been shrunk or deleted in transaction?    space: Space.Interval,  -- space for reading and writing file. (nullHandle means no space.)    current: FileInfo,    atBeginTrans: FileInfo];  FileInfo: TYPE = RECORD [    capability: File.File,  -- File.nullFile means file does not exist yet.    volIndex: VolumeIndex,    permanent: BOOLEAN,    deleted: BOOLEAN,    count: FilePageCount,    pageContents: ARRAY [0..maxPagesPerFile) OF PageContents];  PageContents: TYPE = RECORD [    allZero: BOOLEAN,  -- (is all zero when page first created)    seed: CARDINAL];  StableData: TYPE = RECORD [    filePool: RPoolFileInfo,  -- list head for the pool of files not currently in any transaction.    onlineVols: CARDINAL,  -- number of volumes online.    volume: ARRAY VolumeIndex OF Volume.ID];  -- volumes on which we will create files.  PoolFileInfo: TYPE = RECORD [  -- descriptor for a file in the File Pool.    nextPFI: RPoolFileInfo, fileInfo: FileInfo];  --TestFrameworkDefs.--  RealTransaction: PUBLIC TYPE = TransExDefs.RealTransaction;  --TestFrameworkDefs.--  ModelTransHandle: PUBLIC TYPE = RECORD [rTransInfo: RTransInfo, fill: CARDINAL];  -- must be valid over system restarts.  RPoolFileInfo: TYPE = TestFrameworkDefs.Base RELATIVE POINTER TO PoolFileInfo;  RTransInfo: TYPE = TestFrameworkDefs.Base RELATIVE POINTER TO TransInfo;  PTransInfo: TYPE = LONG POINTER TO TransInfo;  PTransFileInfo: TYPE = LONG POINTER TO TransFileInfo;  PFileInfo: TYPE = LONG POINTER TO FileInfo;  FilePageCount: TYPE = CARDINAL; -- Space.PageCount;   = LowHalf[File.PageCount].  FilePageNumber: TYPE = CARDINAL; -- Space.PageNumber; = LowHalf[File.PageNumber]  VolPageCount: TYPE = Volume.PageCount; --  = LowHalf[Volume.PageCount].  VolumeIndex: TYPE = CARDINAL [0..5);  Action: TYPE = {    copyIn, copyOut, createFile, deleteFile, makeTemporary, makePermanent,    noAction, read, setFileSize, useFileFromFilePool, write};  ActionProc: TYPE = PROCEDURE [pti: PTransInfo]    RETURNS [actionTaken: ActionTaken];  ActionTaken: TYPE = {actionDone, noValidActionFound};  -- Constants, Transient Data:  actionLikelihood: ARRAY Action OF CARDINAL;  relNIL: TestFrameworkDefs.RelPtr = TestFrameworkDefs.nil;  nullModelTransHandle: PUBLIC ModelTransHandle ¬ [    LOOPHOLE[LAST[CARDINAL]], LAST[CARDINAL]];  swapUnitSize: Space.PageCount ¬ maxPagesPerFile/7;  systemVolume: Volume.ID ¬ Volume.systemID;  sysVolIndex: VolumeIndex;  chatty: TestFrameworkDefs.Verbosity = 5;  blathery: TestFrameworkDefs.Verbosity = 7;  blahBlahBlah: TestFrameworkDefs.Verbosity = 9;  -- Stable Data:  stable: TestFrameworkDefs.Base ¬ NIL;  data: TestFrameworkDefs.Base RELATIVE POINTER TO StableData ¬ relNIL;  -- Monitor Data:  volumeSpacePromised: ARRAY VolumeIndex OF VolPageCount ¬ ALL[0];  -- (entries correspond to stableData.volume.)  -- (Other monitor data is in stable storage (e.g. file pool).)  -- Signals:  IncorrectData: SIGNAL [type: IncorrectDataType] = CODE;  IncorrectDataType: TYPE = {shouldBeAllZero, wrongValue};  IncorrectFileProperties: SIGNAL [type: IncorrectFilePropertiesType] = CODE;  IncorrectFilePropertiesType: TYPE = {    fileShouldExist, fileShouldNotExist, wrongFileType, wrongImmutability,    wrongPermanentness, wrongSize, wrongVolume};  ProgramBug: ERROR [type: ProgramBugType] = CODE;  -- my programming error.  ProgramBugType: TYPE = {    badVolSpaceTally, didntFindCandidate, fileInUseAtEndTrans, noVolumes,    nPagesCopiedOff, unknownAction, unknownTermination, verifyOnDeletedFile};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization code:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  startStop: TestFrameworkDefs.StartStop ¬ [  -- ("¬" due to compiler glitch)    moduleName: "TransExFileActions", coldStart: ColdStart, restart: Restart,    saveState: NIL, finalFinish: Finish];  ColdStart: ENTRY TestFrameworkDefs.ColdStartProc  --[zoneBase]--    --RETURNS [registerThisNode]--  =    BEGIN    v: Volume.ID ¬ Volume.nullID;    vol: VolumeIndex ¬ FIRST[VolumeIndex];    stable ¬ zoneBase;  -- remember in global for whole module.    data ¬ TestFrameworkDefs.Node[SIZE[StableData]];  -- remember in global for whole module.    stable[data].filePool ¬ relNIL;    stable[data].onlineVols ¬ 0;    DO      v ¬ Volume.GetNext[v];      IF v = Volume.nullID THEN EXIT;      IF Volume.GetStatus[v] # openReadWrite THEN LOOP;      stable[data].volume[vol] ¬ v;      IF v = systemVolume THEN sysVolIndex ¬ vol;      stable[data].onlineVols ¬ SUCC[stable[data].onlineVols];      IF vol = LAST[VolumeIndex] THEN EXIT      ELSE vol ¬ SUCC[vol];      ENDLOOP;    IF stable[data].onlineVols = 0 THEN ProgramBug[noVolumes];    IF systemVolume = Volume.nullID      THEN {systemVolume ¬ stable[data].volume[FIRST[VolumeIndex]]; sysVolIndex ¬ FIRST[VolumeIndex]};    RETURN[registerThisNode: data];    END;  Restart: ENTRY TestFrameworkDefs.RestartProc --[zoneBase, registeredNode]--  =    BEGIN    progress: BOOLEAN;    prevPool: RPoolFileInfo;    stable ¬ zoneBase;  -- remember in global for whole module.    data ¬ registeredNode;  -- remember in global for whole module.    -- Delete the temp files in the file pool: (which have disappeared in restarting the system)    prevPool ¬ relNIL;    --UNTIL no more temp files in pool--    DO      progress ¬ FALSE;      FOR poolFile: RPoolFileInfo ¬ stable[data].filePool, stable[        poolFile].nextPFI WHILE poolFile ~= relNIL DO        -- look for temp files..        IF ~stable[poolFile].fileInfo.permanent THEN  -- delete this temp file from pool.          BEGIN          IF prevPool = relNIL THEN            stable[data].filePool ¬ stable[poolFile].nextPFI          ELSE stable[prevPool].nextPFI ¬ stable[poolFile].nextPFI;          TestFrameworkDefs.Free[poolFile];          progress ¬ TRUE;          EXIT;  -- and make another pass around the outer loop.          END;        prevPool ¬ poolFile;        ENDLOOP;      IF ~progress THEN EXIT;      ENDLOOP;    END;  Finish: ENTRY TestFrameworkDefs.FinalFinishProc --[]--  =    BEGIN    nextPool: RPoolFileInfo;    VWF0[chatty, "*n ..deleting file pool.. "L];    FOR poolFile: RPoolFileInfo ¬ stable[data].filePool, nextPool WHILE poolFile      ~= relNIL DO  -- delete files in pool..      DeleteFile[@stable[poolFile].fileInfo, nullTransactionHandle];      nextPool ¬ stable[poolFile].nextPFI;      TestFrameworkDefs.Free[poolFile];      ENDLOOP;    stable[data].filePool ¬ relNIL;    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Transaction Beginning and Ending:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AbortModelTrans: PUBLIC PROCEDURE [    mTrans: ModelTransHandle, circumstance: Circumstance] =    -- (At entry, the Pilot transaction has already been aborted,    --  either during normal operation or as a result of CrashRecovery.)    {AbortOrCommit[mTrans, circumstance, abort]};  EndModelTrans: PUBLIC PROCEDURE [    mTrans: ModelTransHandle, circumstance: Circumstance] =    -- (At entry, the Pilot transaction has already been committed,    --  either during normal operation or as a result of CrashRecovery.)    {AbortOrCommit[mTrans, circumstance, commit]};  AbortOrCommit: ENTRY PROCEDURE [    mTrans: ModelTransHandle, circumstance: Circumstance,    termination: {abort, commit}] =    -- (At entry, the Pilot transaction has already been committed or aborted,    --  either during normal operation or as a result of CrashRecovery.)    BEGIN    pti: PTransInfo = @stable[mTrans.rTransInfo];    FOR jFile: CARDINAL IN TransFiles DO      -- scope of tfi --      BEGIN OPEN tfi: pti.file[jFile];      pfi: PFileInfo =        (SELECT termination FROM           commit => @tfi.current,           abort => @tfi.atBeginTrans           ENDCASE => ProgramBug[unknownTermination]);      errorsInFile: BOOLEAN ¬ FALSE;      -- scope of fi, FileUnknown --      BEGIN OPEN pfi;      ENABLE {        File.Unknown, Volume.Unknown => GO TO FileUnknown;        IncorrectFileProperties => {errorsInFile ¬ TRUE; REJECT}};      poolFiles: CARDINAL;      type: File.Type;      temporary: BOOLEAN;      volume: Volume.ID;      IF circumstance = followingCrash THEN {        tfi.space ¬ Space.nullInterval;  -- space has disappeared across system restart.        tfi.busy ¬ FALSE};  -- fi could have been busy when state saved.      IF tfi.busy THEN ProgramBug[fileInUseAtEndTrans];      -- Verify that the file is the way it should be:      volume ¬ pfi.capability.volumeID;      [type, temporary] ¬ File.GetAttributes[        pfi.capability ! File.Unknown, Volume.Unknown => GO TO FileUnknown];      IF type ~= TestFrameworkDefs.testFileType THEN        IncorrectFileProperties[wrongFileType];      IF temporary = pfi.permanent THEN        IncorrectFileProperties[wrongPermanentness];  -- (we made the file permanent, then marked it permanent.)      IF volume ~= stable[data].volume[pfi.volIndex] THEN        IncorrectFileProperties[wrongVolume];      IF File.GetSize[pfi.capability] ~= pfi.count THEN        IncorrectFileProperties[wrongSize];      IF pfi.deleted THEN IncorrectFileProperties[fileShouldNotExist];  -- else above would have signaled File.Unknown.      VerifyPageContents[        @tfi, pfi, --startPage:-- 0, pfi.count, nullTransactionHandle];      IF circumstance = normal AND tfi.shrunk THEN        ReleaseVolumeSpaceInternal[pfi, maxPagesPerFile, 0];      VWFCR[chatty];      PrintTransAndFile[chatty, pti, @pfi.capability];      VWF1[        chatty, "%s "L, IF termination = abort THEN "Aborted"L ELSE "Committed"L];      AssureFileNotMapped[@tfi];      poolFiles ¬ 0;      FOR poolFile: RPoolFileInfo ¬ stable[data].filePool, stable[        poolFile].nextPFI WHILE poolFile ~= relNIL DO  -- count em..        poolFiles ¬ SUCC[poolFiles]; ENDLOOP;      IF poolFiles >= maxFilesInPool OR errorsInFile THEN        DeleteFile[pfi, nullTransactionHandle]      ELSE  -- save the file in the File Pool..        BEGIN        poolFile: RPoolFileInfo ¬ TestFrameworkDefs.Node[SIZE[PoolFileInfo]];        stable[poolFile].nextPFI ¬ stable[data].filePool;        stable[poolFile].fileInfo ¬ pfi­;        stable[data].filePool ¬ poolFile;        VWFCR[blathery];        PrintTransAndFile[blathery, pti, @pfi.capability];        VWF0[blathery, "transferred to file pool "L];        END;      EXITS        FileUnknown =>          IF --we created a file-- pfi.capability ~= File.nullFile            AND              --didn't delete it-- ~pfi.deleted            AND              ((circumstance = normal AND termination = commit)                OR (circumstance = normal AND termination = abort)                OR (circumstance = followingCrash AND termination = commit)                OR                  (circumstance = followingCrash AND termination = abort                    AND pfi.permanent)) THEN            IncorrectFileProperties[fileShouldExist];      END;      END;      ENDLOOP;    TestFrameworkDefs.Free[mTrans.rTransInfo];    -- nActiveTransactions ¬ nActiveTransactions - 1;    END;  BeginModelTrans: PUBLIC PROCEDURE [rTrans: TransExDefs.RealTransaction]    RETURNS [mTrans: ModelTransHandle] =    BEGIN    rti: RTransInfo = LOOPHOLE[TestFrameworkDefs.Node[SIZE[TransInfo]]];    -- scope of ti --    BEGIN OPEN ti: stable[rti];    ti.trans ¬ LOOPHOLE[rTrans.trans, DummyTransactionHandle];    FOR jFile: TransFiles IN TransFiles DO      -- scope of tfi --      BEGIN OPEN tfi: ti.file[jFile];      tfi.busy ¬ FALSE;      tfi.shrunk ¬ FALSE;      tfi.space ¬ Space.nullInterval;      tfi.current.capability ¬ File.nullFile;      tfi.atBeginTrans.capability ¬ File.nullFile;      END;      ENDLOOP;    END;    -- nActiveTransactions ¬ nActiveTransactions + 1;    VWF1[chatty, "*n ******Begin trans %b "L, @rTrans.trans];    RETURN[ModelTransHandle[rti, --fill:-- 0]];    END;  CreateFileWithinTransaction: PUBLIC PROCEDURE [    rTrans: RealTransaction, andDo: AndDo] =    -- May raise Volume.InsufficientSpace.    {    file: File.File = File.Create[      systemVolume, 1, TestFrameworkDefs.testFileType];    andDo[file];    File.MakePermanent[file]};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Transaction Model Actions:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  RandomModelAct: PUBLIC PROCEDURE [mTrans: ModelTransHandle] =    BEGIN    actionTaken: ActionTaken;    pti: PTransInfo = @stable[mTrans.rTransInfo];    TestFrameworkDefs.Tick[];    actionTaken ¬ noValidActionFound;    WHILE actionTaken = noValidActionFound DO      actionTaken ¬        SELECT LOOPHOLE[	  TestFrameworkDefs.RandomCase[LOOPHOLE[DESCRIPTOR[actionLikelihood]]],	  Action] FROM          copyIn => CopyInForTrans[pti],          copyOut => CopyOutForTrans[pti],          createFile => CreateFileForTrans[pti],          deleteFile => DeleteFileForTrans[pti],          makeTemporary => MakeFileTemporaryForTrans[pti],          makePermanent => MakeFilePermanentForTrans[pti],          noAction => NoAction[pti],          read => ReadFileForTrans[pti],          setFileSize => SetFileSizeForTrans[pti],          useFileFromFilePool => UseFileFromFilePoolForTrans[pti],          write => WriteFileForTrans[pti],          ENDCASE => ProgramBug[unknownAction];      ENDLOOP;    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- (Individual Actions follow alphabetically)  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  CreateFileForTrans: ActionProc =    BEGIN    CreatableTransFileTest: CandidateTest = {      RETURN[ptfi.current.capability = File.nullFile]};    ptfi: PTransFileInfo = ChooseTransFile[pti, CreatableTransFileTest];    IF ptfi = NIL THEN RETURN[noValidActionFound]    ELSE      BEGIN OPEN fi: ptfi.current;      fi.volIndex ¬ RandomRange[stable[data].onlineVols];      ptfi.space ¬ Space.nullInterval;      fi.permanent ¬  fi.deleted ¬ FALSE;      fi.count ¬ TestFrameworkDefs.RandomRange[maxPagesPerFile + 1];  -- [0..maxPagesPerFile].      IF fi.count = 0 THEN fi.count ¬ 1;  --ban zero-size files!      IF ~ReserveVolumeSpace[@fi, fi.count, 0, pti.trans] THEN {        ptfi.busy ¬ FALSE; RETURN[noValidActionFound]};      FOR k: FilePageCount IN [0..fi.count) DO        fi.pageContents[k].allZero ¬ TRUE ENDLOOP;      fi.capability ¬ File.Create[        stable[data].volume[fi.volIndex], fi.count,        TestFrameworkDefs.testFileType !        Volume.InsufficientSpace => CONTINUE];  -- (capability not set if trouble)      ReleaseVolumeSpace[@fi, fi.count, 0];      VWFCR[blathery];      PrintTransAndFile[blathery, pti, @fi.capability];      VWF1[blathery, "created, size %d "L, @fi.count];      ptfi.busy ¬ FALSE;      RETURN[actionDone];      END;    END;  CopyInForTrans: ActionProc =    BEGIN    ptfi: PTransFileInfo ¬ ChooseTransFile[pti, WritableTransFileTest];    IF ptfi = NIL THEN RETURN[noValidActionFound]    ELSE      BEGIN      pfi: PFileInfo = @ptfi.current;      firstPage: FilePageNumber ¬ 0;      -- scope of AbortOuter --      BEGIN      ptfiInner: PTransFileInfo ¬ ChooseTransFile[pti, ReadableTransFileTest];      IF ptfiInner = NIL THEN GO TO AbortOuter      ELSE        BEGIN	pagesCopied: Environment.PageCount;        pfiInner: PFileInfo = @ptfiInner.current;        firstPageInner: FilePageNumber ¬ TestFrameworkDefs.RandomRange[          pfiInner.count];        nPages: FilePageCount ¬ MIN[pfi.count, pfiInner.count - firstPageInner];        IF pfi.count - firstPage < nPages THEN  -- TEMP UNTIL AR6457 FIXED.          {ptfiInner.busy ¬ FALSE; GO TO AbortOuter};  -- TEMP UNTIL AR6457 FIXED.        IF ~ReserveVolumeSpace[pfi, 0, nPages + (swapUnitSize - 1), pti.trans]          THEN {ptfiInner.busy ¬ FALSE; GO TO AbortOuter};        AssureFileMapped[ptfi, pfi, pti.trans, forWriting];        AssureFileNotMapped[ptfiInner];	FOR k: CARDINAL IN [0..nPages) DO	IF NOT pfiInner.pageContents[firstPageInner + k].allZero THEN	  BEGIN	  -- Runtime.CallDebugger["about to copy in"L];	  EXIT;	  END;	  ENDLOOP;        pagesCopied ¬ Space.CopyIn[          ptfi.space.pointer, [pfiInner.capability, firstPageInner, nPages]];	IF pagesCopied # nPages THEN ProgramBug[nPagesCopiedOff];        FOR k: CARDINAL IN [0..nPages) DO          pfi.pageContents[firstPage + k] ¬ pfiInner.pageContents[            firstPageInner + k];          ENDLOOP;	AssureFileNotMapped[ptfi];	VerifyPageContents[ptfi, pfi, firstPage, nPages, pti.trans];        ReleaseVolumeSpace[pfi, 0, nPages + (swapUnitSize - 1)];        VWFCR[blathery];        PrintTransAndFile[blathery, pti, @pfi.capability];        VWF2[blathery, "pages %D!%D copied in from "L, @firstPage, @nPages];        PrintFile[blathery, @pfiInner.capability];        VWF1[blathery, "page %D "L, @firstPageInner];        ptfiInner.busy ¬ FALSE;        ptfi.busy ¬ FALSE;        RETURN[actionDone];        END;      END;      EXITS AbortOuter => {ptfi.busy ¬ FALSE; RETURN[noValidActionFound]};      END;    END;  CopyOutForTrans: ActionProc =    BEGIN    ptfi: PTransFileInfo ¬ ChooseTransFile[pti, ReadableTransFileTest];    IF ptfi = NIL THEN RETURN[noValidActionFound]    ELSE      BEGIN      pfi: PFileInfo = @ptfi.current;      firstPage: FilePageNumber ¬ 0;      -- scope of AbortOuter --      BEGIN      ptfiInner: PTransFileInfo ¬ ChooseTransFile[pti, WritableTransFileTest];      IF ptfiInner = NIL THEN GO TO AbortOuter      ELSE        BEGIN	pagesCopied: Environment.PageCount;        pfiInner: PFileInfo = @ptfiInner.current;        firstPageInner: FilePageNumber ¬ TestFrameworkDefs.RandomRange[          pfiInner.count];        nPages: FilePageCount ¬ MIN[pfi.count, pfiInner.count - firstPageInner];        IF ~ReserveVolumeSpace[          pfiInner, 0, nPages + (swapUnitSize - 1), pti.trans] THEN {          ptfiInner.busy ¬ FALSE; GO TO AbortOuter};        AssureFileMapped[ptfi, pfi, pti.trans, forReading];        AssureFileNotMapped[ptfiInner];        pagesCopied ¬ Space.CopyOut[          ptfi.space.pointer, [pfiInner.capability, firstPageInner, nPages]];	IF pagesCopied # nPages THEN ProgramBug[nPagesCopiedOff];        FOR k: CARDINAL IN [0..nPages) DO          pfiInner.pageContents[firstPageInner + k] ¬ pfi.pageContents[firstPage + k];          ENDLOOP;	AssureFileNotMapped[ptfi];	VerifyPageContents[ptfi, pfiInner, firstPageInner, nPages, pti.trans];        ReleaseVolumeSpace[pfiInner, 0, nPages + (swapUnitSize - 1)];        VWFCR[blathery];        PrintTransAndFile[blathery, pti, @pfi.capability];        VWF2[blathery, "pages %D!%D copied out to "L, @firstPage, @nPages];        PrintFile[blathery, @pfiInner.capability];        VWF1[blathery, "page %D "L, @firstPageInner];        ptfiInner.busy ¬ FALSE;        ptfi.busy ¬ FALSE;        RETURN[actionDone];        END;      END;      EXITS AbortOuter => {ptfi.busy ¬ FALSE; RETURN[noValidActionFound]};      END;    END;  DeleteFileForTrans: ActionProc =    BEGIN    DeletableTransFileTest: CandidateTest = {      RETURN[ptfi.current.capability ~= File.nullFile]};    ptfi: PTransFileInfo ¬ ChooseTransFile[pti, DeletableTransFileTest];    IF ptfi = NIL THEN RETURN[noValidActionFound]    ELSE      BEGIN OPEN fi: ptfi.current;      longTermReserved: VolPageCount =        (IF ~ptfi.shrunk THEN maxPagesPerFile ELSE 0);      AssureFileNotMapped[ptfi];      IF ~ReserveVolumeSpace[@fi, longTermReserved, fi.count, pti.trans] THEN {        ptfi.busy ¬ FALSE; RETURN[noValidActionFound]};      DeleteFile[@fi, pti.trans];      fi.deleted ¬ TRUE;      ptfi.shrunk ¬ TRUE;      ReleaseVolumeSpace[@fi, 0, fi.count];      -- (rest will be released at end trans.)      VWFCR[blathery];      PrintTransAndFile[blathery, pti, @fi.capability];      VWF0[blathery, "deleted "L];      ptfi.busy ¬ FALSE;      RETURN[actionDone];      END;    END;  DummyAction: ActionProc = {RETURN[noValidActionFound]};  MakeFileTemporaryForTrans: ActionProc =    BEGIN    TemporaryTransFileTest: CandidateTest = {      RETURN[        ptfi.current.capability ~= File.nullFile          AND ptfi.current.permanent]};    ptfi: PTransFileInfo ¬ ChooseTransFile[pti, TemporaryTransFileTest];    IF ptfi = NIL THEN RETURN[noValidActionFound]    ELSE      BEGIN OPEN fi: ptfi.current;      AssureFileNotMapped[ptfi];      SpecialFile.MakeTemporary[fi.capability];      fi.permanent ¬ FALSE;      VWFCR[blathery];      PrintTransAndFile[blathery, pti, @fi.capability];      VWF0[blathery, "made temporary "L];      ptfi.busy ¬ FALSE;      RETURN[actionDone];      END;    END;  MakeFilePermanentForTrans: ActionProc =    BEGIN    PermanentableTransFileTest: CandidateTest = {      RETURN[        ptfi.current.capability ~= File.nullFile AND ~ptfi.current.permanent]};    ptfi: PTransFileInfo ¬ ChooseTransFile[pti, PermanentableTransFileTest];    IF ptfi = NIL THEN RETURN[noValidActionFound]    ELSE      BEGIN OPEN fi: ptfi.current;      AssureFileNotMapped[ptfi];      File.MakePermanent[fi.capability];      fi.permanent ¬ TRUE;      VWFCR[blathery];      PrintTransAndFile[blathery, pti, @fi.capability];      VWF0[blathery, "made permanent "L];      ptfi.busy ¬ FALSE;      RETURN[actionDone];      END;    END;  NoAction: ActionProc = {RETURN[actionDone]};  ReadFileForTrans: ActionProc =    BEGIN    ptfi: PTransFileInfo ¬ ChooseTransFile[pti, ReadableTransFileTest];    IF ptfi = NIL THEN RETURN[noValidActionFound]    ELSE      BEGIN OPEN fi: ptfi.current;      firstPage: FilePageNumber ¬ TestFrameworkDefs.RandomRange[fi.count];      nPages: FilePageCount ¬        IF fi.count = 0 THEN 0        ELSE TestFrameworkDefs.RandomRange[fi.count - firstPage] + 1;  -- [1 .. fi.count-firstPage].      VerifyPageContents[ptfi, @fi, firstPage, nPages, pti.trans];      VWFCR[blathery];      PrintTransAndFile[blathery, pti, @fi.capability];      VWF2[blathery, "read pages %D!%D "L, @firstPage, @nPages];      ptfi.busy ¬ FALSE;      RETURN[actionDone];      END    END;    SetFileSizeForTrans: ActionProc =    BEGIN    ptfi: PTransFileInfo ¬ ChooseTransFile[pti, WritableTransFileTest];    IF ptfi = NIL THEN RETURN[noValidActionFound]    ELSE      BEGIN OPEN fi: ptfi.current;      oldCount, newCount: FilePageCount;      growth, shrinkage: FilePageCount;      longTermReserved: VolPageCount;      oldCount ¬ fi.count;      newCount ¬ TestFrameworkDefs.RandomRange[        maxPagesPerFile + 1];  -- [0..maxPagesPerFile].       IF newCount = 0 THEN newCount ¬ 1;      growth ¬ (IF newCount > oldCount THEN newCount - oldCount ELSE 0);      shrinkage ¬ (IF newCount < oldCount THEN oldCount - newCount ELSE 0);      longTermReserved ¬  (IF growth > 0 AND ~ptfi.shrunk THEN maxPagesPerFile ELSE 0);      IF File.GetSize[fi.capability].size ~= oldCount THEN        IncorrectFileProperties[wrongSize];      IF ~ReserveVolumeSpace[@fi, longTermReserved, shrinkage, pti.trans] THEN {        ptfi.busy ¬ FALSE; RETURN[noValidActionFound]};      AssureFileNotMapped[ptfi];      File.SetSize[        fi.capability, newCount !        Volume.InsufficientSpace => GO TO Abort];      fi.count ¬ newCount;      FOR k: CARDINAL IN [oldCount..fi.count) DO        fi.pageContents[k].allZero ¬ TRUE; ENDLOOP;      IF longTermReserved > 0 THEN ptfi.shrunk ¬ TRUE;      ReleaseVolumeSpace[@fi, 0, shrinkage];  -- (rest will be released at end trans.)      VWFCR[blathery];      PrintTransAndFile[blathery, pti, @fi.capability];      VWF2[blathery, "changed size from %D to %D "L, @oldCount, @newCount];      EXITS Abort => NULL;      END;    ptfi.busy ¬ FALSE;    RETURN[actionDone];    END;  UseFileFromFilePoolForTrans: ActionProc =    BEGIN    UnusedTransFileTest: CandidateTest = {      RETURN[ptfi.current.capability = File.nullFile]};    ptfi: PTransFileInfo ¬ ChooseTransFile[pti, UnusedTransFileTest];    IF ptfi = NIL THEN RETURN[noValidActionFound]    ELSE      BEGIN      IF ~ChoosePoolFile[resultFileInfo: @ptfi.atBeginTrans].gotOne THEN {        ptfi.busy ¬ FALSE; RETURN[noValidActionFound]};      ptfi.current ¬ ptfi.atBeginTrans;      VWFCR[blathery];      PrintTransAndFile[blathery, pti, @ptfi.current.capability];      VWF1[blathery, "obtained from file pool, size %d "L, @ptfi.current.count];      ptfi.busy ¬ FALSE;      RETURN[actionDone];      END;    END;  WriteFileForTrans: ActionProc =    BEGIN    ptfi: PTransFileInfo ¬ ChooseTransFile[pti, WritableTransFileTest];    IF ptfi = NIL THEN RETURN[noValidActionFound]    ELSE      BEGIN OPEN fi: ptfi.current;      currPage: CARDINAL;      PageFiller: TestFrameworkDefs.WantsRandoms --[nextRandom: NextRandom]--  =        BEGIN        pPage: LONG ORDERED POINTER TO UNSPECIFIED =          LOOPHOLE[ptfi.space.pointer +                     currPage*Environment.wordsPerPage];        FOR pData: LONG ORDERED POINTER TO UNSPECIFIED IN          [pPage..pPage + Environment.wordsPerPage) DO          pData­ ¬ nextRandom[]; ENDLOOP;        END;      firstPage: FilePageNumber ¬ TestFrameworkDefs.RandomRange[fi.count];      nPages: FilePageCount ¬        IF fi.count = 0 THEN 0        ELSE TestFrameworkDefs.RandomRange[fi.count - firstPage] + 1;  -- [1 .. fi.count-firstPage].      IF ~ReserveVolumeSpace[@fi, 0, nPages + (swapUnitSize - 1), pti.trans] THEN        {ptfi.busy ¬ FALSE; RETURN[noValidActionFound]};      AssureFileMapped[ptfi, @ptfi.current, pti.trans, forWriting];      FOR k: CARDINAL IN [0..nPages) DO        currPage ¬ firstPage + k;        fi.pageContents[currPage] ¬ [          allZero: FALSE, seed: TestFrameworkDefs.Random[]];        TestFrameworkDefs.PrivateGenerator[          fi.pageContents[currPage].seed, PageFiller];        ENDLOOP;      AssureFileNotMapped[ptfi];      VerifyPageContents[ptfi, @fi, firstPage, nPages,  pti.trans];      ReleaseVolumeSpace[@fi, 0, nPages + (swapUnitSize - 1)];      VWFCR[blathery];      PrintTransAndFile[blathery, pti, @ptfi.current.capability];      VWF2[blathery, "wrote pages %D!%D "L, @firstPage, @nPages];      ptfi.busy ¬ FALSE;      RETURN[actionDone];      END;    END;  --~~~~~~~~~~~~~~~~~~~~~~  -- Utilities for Model Actions  --~~~~~~~~~~~~~~~~~~~~~~  AssureFileMapped: PROCEDURE [    ptfi: PTransFileInfo, pfi: PFileInfo, trans: DummyTransactionHandle,    mode: {forReading, forWriting}] =    -- (mapped within the transaction, that is.)    BEGIN        IF ptfi.space = Space.nullInterval THEN      BEGIN --assure mapping space exists      mapCapability: File.File ¬  pfi.capability;      SELECT RandomRange[3] FROM        0 =>  ptfi.space ¬ 	       Space.Map[window: [mapCapability, 0, LAST[Environment.PageCount]],		  swapUnits: [unitary[]]];	1 =>  ptfi.space ¬ 	       Space.Map[window: [mapCapability, 0, LAST[Environment.PageCount]]];	           --uniform, defaultSwapUnitSize	2 => 	    BEGIN	    maxSUArrayEntries: CARDINAL = 20;  --choose reasonable number	    suArray: ARRAY[0..maxSUArrayEntries) OF Space.SwapUnitSize;	    sumSUSizes: CARDINAL ¬ 0;	    FOR i: CARDINAL IN [0..maxSUArrayEntries) DO	    suArray[i] ¬ RandomRange[maxPagesPerFile];	    IF suArray[i] = 0 THEN suArray[i] ¬ 1;  	    sumSUSizes ¬ sumSUSizes + suArray[i];	    ENDLOOP;	    IF sumSUSizes < maxPagesPerFile THEN --bump last entry to be safe--	      suArray[maxSUArrayEntries - 1] ¬ suArray[maxSUArrayEntries - 1] + maxPagesPerFile - sumSUSizes;	    ptfi.space ¬ 	     Space.Map[window: [mapCapability, 0, LAST[Environment.PageCount]],	      swapUnits: [irregular[DESCRIPTOR[suArray]]]];	    END;	ENDCASE => NULL;            VWFCR[blahBlahBlah];      PrintTransFileSpace[blahBlahBlah, trans, @mapCapability, ptfi.space];      VWF0[blahBlahBlah, "mapped "L];      END    ELSE      BEGIN      isReadOnly: BOOLEAN =(Space.GetSwapUnitAttributes[ptfi.space.pointer].access = readOnly);      IF mode = forWriting AND isReadOnly THEN {          Space.MakeWritable[ptfi.space];          VWFCR[blahBlahBlah];          PrintTransFileSpace[blahBlahBlah, trans, @pfi.capability, ptfi.space];          VWF0[blahBlahBlah, "made writable "L]};      IF mode = forReading AND ~isReadOnly AND OneOf[4] THEN {          Space.MakeReadOnly[ptfi.space];  -- (optional code.)          VWFCR[blahBlahBlah];          PrintTransFileSpace[blahBlahBlah, trans, @pfi.capability, ptfi.space];          VWF0[blahBlahBlah, "made read-only "L]};      END;    END;  AssureFileNotMapped: PROCEDURE [ptfi: PTransFileInfo] = {    IF ptfi.space ~= Space.nullInterval      THEN {        [] ¬ Space.Unmap[ptfi.space.pointer];	VWFCR[blahBlahBlah];        PrintTransFileSpace[blahBlahBlah, nullTransactionHandle, @ptfi.current.capability, ptfi.space];        VWF0[blahBlahBlah, "unmapped "L];        ptfi.space ¬ Space.nullInterval};   };  DeleteFile: PROCEDURE [pfi: PFileInfo, trans: DummyTransactionHandle] = {    File.Delete[pfi.capability]};  -- DisplayFileData: PROCEDURE [file: FileDescHandle, firstPage: CARDINAL, nPages: CARDINAL] =  -- BEGIN  -- nWords: CARDINAL ¬ nPages*Environment.words;  -- nWordsLeft: CARDINAL ¬ nWords;  -- thisLineBase: CARDINAL ¬ 0;  -- SimulatedRead[file, firstByte, nBytes, @data];  -- WF2["file data, first byte: %l, nWords: %d", @firstPage, nWords];  -- WHILE nWordsLeft > 0 DO  -- BEGIN  -- nWordsThisLine: CARDINAL ¬ MIN[10, nWordsLeft];  -- WF0["*N*T"];  -- FOR k: CARDINAL IN [0..nWordsThisLine) DO  -- WF1[" %b", data[thisLineBase+k]];  -- ENDLOOP;  -- thisLineBase ¬ thisLineBase + 10;  -- nWordsLeft ¬ nWordsLeft - nWordsThisLine;  -- END;  -- ENDLOOP;  -- WF0["*N"];  -- END;  PrintFile: PROCEDURE [    verbosity: Verbosity, capability: LONG POINTER TO File.File] = {    fileValPtrs: ARRAY [0..SIZE[File.File]) OF LONG POINTER;    FOR k: CARDINAL IN [0..SIZE[File.File]) DO fileValPtrs[k] ¬ capability+k ENDLOOP;    VWFN[verbosity, "file %b %b volume %b %b %b %b %b "L, DESCRIPTOR[fileValPtrs]]};  PrintSpace: PROCEDURE [verbosity: Verbosity, space: Space.Interval] = {    spaceValPtrs: ARRAY [0..SIZE[Space.Interval]) OF LONG POINTER;    FOR k: CARDINAL IN [0..SIZE[Space.Interval]) DO spaceValPtrs[k] ¬ @space+k ENDLOOP;    VWFN[verbosity, "space %b %b %b %b "L, DESCRIPTOR[spaceValPtrs]]};  PrintTrans: PROCEDURE [verbosity: Verbosity, trans: DummyTransactionHandle] = {    VWF1[verbosity, "trans %b "L, @trans]};  PrintTransAndFile: PROCEDURE [    verbosity: Verbosity, pTransInfo: PTransInfo,    capability: LONG POINTER TO File.File] = {    PrintTrans[verbosity, pTransInfo.trans]; PrintFile[verbosity, capability]};  PrintTransFileSpace: PROCEDURE [    verbosity: Verbosity, trans: DummyTransactionHandle,    capability: LONG POINTER TO File.File, space: Space.Interval] = {    PrintTrans[verbosity, trans];    PrintFile[verbosity, capability];    PrintSpace[verbosity, space]};  ReadableTransFileTest: CandidateTest = {    RETURN[ptfi.current.capability ~= File.nullFile]};  VerifyPageContents: PROCEDURE [    ptfi: PTransFileInfo, pfi: PFileInfo, startPage: FilePageNumber,    count: FilePageCount, trans: DummyTransactionHandle] =    BEGIN    currPage: CARDINAL;    PageChecker: TestFrameworkDefs.WantsRandoms --[nextRandom: NextRandom]--  =      BEGIN      pPage: LONG ORDERED POINTER TO UNSPECIFIED =        LOOPHOLE[ptfi.space.pointer +                   currPage*Environment.wordsPerPage];      FOR pData: LONG ORDERED POINTER TO UNSPECIFIED IN        [pPage..pPage + Environment.wordsPerPage) DO        SELECT TRUE FROM          pfi.pageContents[currPage].allZero =>            IF pData­ ~= 0 THEN {IncorrectData[shouldBeAllZero]; EXIT};          ENDCASE =>            IF pData­ ~= nextRandom[] THEN {IncorrectData[wrongValue]; EXIT};        ENDLOOP;      END;    IF pfi.deleted THEN ProgramBug[verifyOnDeletedFile];    AssureFileMapped[ptfi, pfi, trans, forReading];    FOR currPage IN [startPage..startPage + count) DO      TestFrameworkDefs.PrivateGenerator[        pfi.pageContents[currPage].seed, PageChecker --[currPage]-- ];      ENDLOOP;    AssureFileNotMapped[ptfi];    END;  WritableTransFileTest: CandidateTest = {    RETURN[      ptfi.current.capability ~= File.nullFile]};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Entry Procedures - for checking-out files to be acted upon:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ChoosePoolFile: PROCEDURE [resultFileInfo: PFileInfo]    RETURNS [gotOne: BOOLEAN] = {    gotOne ¬ ChoosePoolFileEntry[resultFileInfo];    WHILE TestFrameworkDefs.OneOf[4] DO Process.Yield[] ENDLOOP};  -- break up possible lock step.  ChoosePoolFileEntry: ENTRY PROCEDURE [pResultFileInfo: PFileInfo]    RETURNS [gotOne: BOOLEAN] =    BEGIN    -- If gotOne is returned TRUE, pResultFileInfo­ will contain the only extant copy of the file info.    prevPool: RPoolFileInfo;    candidate: CARDINAL;    selectedCandidate: CARDINAL;    nCandidates: CARDINAL ¬ 0;    FOR poolFile: RPoolFileInfo ¬ stable[data].filePool, stable[poolFile].nextPFI      WHILE poolFile ~= relNIL DO  -- count valid candidates..      nCandidates ¬ SUCC[nCandidates]; ENDLOOP;    IF nCandidates = 0 THEN RETURN[gotOne: FALSE];    selectedCandidate ¬ TestFrameworkDefs.RandomRange[nCandidates];    candidate ¬ 0;    prevPool ¬ relNIL;    FOR poolFile: RPoolFileInfo ¬ stable[data].filePool, stable[poolFile].nextPFI      DO  -- locate selected candidate..      IF poolFile = relNIL THEN ProgramBug[didntFindCandidate];      IF candidate = selectedCandidate THEN        BEGIN        pResultFileInfo­ ¬ stable[poolFile].fileInfo;        IF prevPool = relNIL THEN stable[data].filePool ¬ stable[poolFile].nextPFI        ELSE stable[prevPool].nextPFI ¬ stable[poolFile].nextPFI;        TestFrameworkDefs.Free[poolFile];        RETURN[gotOne: TRUE];        END;      candidate ¬ candidate + 1;      prevPool ¬ poolFile;      ENDLOOP;    END;  CandidateTest: TYPE = PROCEDURE [ptfi: PTransFileInfo]    RETURNS [suitable: BOOLEAN];  ChooseTransFile: PROCEDURE [pti: PTransInfo, candidateTest: CandidateTest]    RETURNS [ptfi: PTransFileInfo] = {    ptfi ¬ ChooseTransFileEntry[pti, candidateTest];    WHILE TestFrameworkDefs.OneOf[4] DO Process.Yield[] ENDLOOP};  -- break up possible lock step.  ChooseTransFileEntry: ENTRY PROCEDURE [    pti: PTransInfo, candidateTest: CandidateTest]    RETURNS [ptfi: PTransFileInfo] =    -- (returns NIL if no suitable candidate.)    BEGIN    nCandidates: CARDINAL ¬ 0;    candidate: CARDINAL;    selectedCandidate: CARDINAL;    FOR jFile: CARDINAL IN TransFiles DO  -- count valid candidates..      IF ~pti.file[jFile].busy AND ~pti.file[jFile].current.deleted        AND candidateTest[@pti.file[jFile]] THEN nCandidates ¬ nCandidates + 1;      ENDLOOP;    IF nCandidates = 0 THEN RETURN[NIL];    selectedCandidate ¬ TestFrameworkDefs.RandomRange[nCandidates];    candidate ¬ 0;    FOR jFile: CARDINAL IN TransFiles DO  -- locate selected candidate..      IF ~pti.file[jFile].busy AND ~pti.file[jFile].current.deleted        AND candidateTest[@pti.file[jFile]] THEN        BEGIN        IF candidate = selectedCandidate THEN {          pti.file[jFile].busy ¬ TRUE;  -- so no other process may work on this file.          RETURN[@pti.file[jFile]]};        candidate ¬ candidate + 1;        END;      ENDLOOP;    ProgramBug[didntFindCandidate];  -- did not find candidate    END;  ReserveVolumeSpace: ENTRY PROCEDURE [    pfi: PFileInfo, fileVolSpaceNeeded, sysVolSpaceNeeded: VolPageCount,    trans: DummyTransactionHandle] RETURNS [sufficientSpace: BOOLEAN] =    -- If sufficientSpace, then that much space has been reserved for the caller,    -- who must ReleaseVolumeSpace it after his operation has completed    -- (successfully or not).    BEGIN    fileVolFree: VolPageCount ¬       Volume.GetAttributes[stable[data].volume[pfi.volIndex]].freePageCount;    IF pfi.volIndex = sysVolIndex THEN      BEGIN      IF fileVolFree <        fileVolSpaceNeeded + sysVolSpaceNeeded + volumeSpacePromised[pfi.volIndex]          + minFreeOnVolume THEN RETURN[sufficientSpace: FALSE];      volumeSpacePromised[pfi.volIndex] ¬        volumeSpacePromised[pfi.volIndex] + fileVolSpaceNeeded +          sysVolSpaceNeeded;      RETURN[sufficientSpace: TRUE];      END    ELSE      BEGIN      sysVolFree: VolPageCount ¬         Volume.GetAttributes[systemVolume].freePageCount;      IF fileVolFree <        fileVolSpaceNeeded + volumeSpacePromised[pfi.volIndex] + minFreeOnVolume        OR sysVolFree <          sysVolSpaceNeeded + volumeSpacePromised[sysVolIndex] + minFreeOnVolume        THEN RETURN[sufficientSpace: FALSE];      volumeSpacePromised[pfi.volIndex] ¬        volumeSpacePromised[pfi.volIndex] + fileVolSpaceNeeded;      volumeSpacePromised[sysVolIndex] ¬        volumeSpacePromised[sysVolIndex] + sysVolSpaceNeeded;      RETURN[sufficientSpace: TRUE];      END;    END;  ReleaseVolumeSpace: ENTRY PROCEDURE [    pfi: PFileInfo, fileVolSpaceReserved, sysVolSpaceReserved: VolPageCount] = {    ReleaseVolumeSpaceInternal[pfi, fileVolSpaceReserved, sysVolSpaceReserved]};  ReleaseVolumeSpaceInternal: INTERNAL PROCEDURE [    pfi: PFileInfo, fileVolSpaceReserved, sysVolSpaceReserved: VolPageCount] =    BEGIN    IF pfi.volIndex = sysVolIndex THEN      volumeSpacePromised[pfi.volIndex] ¬        volumeSpacePromised[pfi.volIndex] - fileVolSpaceReserved -          sysVolSpaceReserved    ELSE {      volumeSpacePromised[pfi.volIndex] ¬        volumeSpacePromised[pfi.volIndex] - fileVolSpaceReserved;      volumeSpacePromised[sysVolIndex] ¬        volumeSpacePromised[sysVolIndex] - sysVolSpaceReserved};    IF volumeSpacePromised[pfi.volIndex] > LAST[VolPageCount] - 1000      OR volumeSpacePromised[sysVolIndex] > LAST[VolPageCount] - 1000 THEN      ProgramBug[badVolSpaceTally];    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Mainline code:  (see also Initialization code at beginning of module)  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Note that many of the following likelihoods are conditional, in the sense that most actions have some preconditions necessary for them to be done.  actionLikelihood[copyIn] ¬ 20;  actionLikelihood[copyOut] ¬ 20;  actionLikelihood[createFile] ¬ 20;  actionLikelihood[deleteFile] ¬ 10;  -- less than actionLikelihood[createFile] so that the file pool tends to fill up.  actionLikelihood[makePermanent] ¬ 50;  actionLikelihood[makeTemporary] ¬ 2;  actionLikelihood[noAction] ¬ 1;  actionLikelihood[read] ¬ 200;  actionLikelihood[setFileSize] ¬ 30;  actionLikelihood[useFileFromFilePool] ¬ actionLikelihood[createFile];  actionLikelihood[write] ¬ actionLikelihood[read]/2;  Register[@startStop];  END.LOGOctober 30, 1980  3:28 PM   WDK       Created file from [Ivy]<Juniper>5.11> Tests>ATestFileModel.mesa of 4 Feb 80 and ATestFileActions.mesa of 4 Feb 80.   8-Sep-81 15:28:50   WDK       Deleted Remap action.2-Mar-83 11:13:54   	LXD       Quick and dirty conversion to Klamath 3-Mar-83 14:07:09	LXD       FilePageCount, FilePageNumber made CARDINALs 7-Mar-83 14:48:35	LXD        ColdStart now uses only volumes that are openReadWrite.  If no system volume, uses the first such volume that it finds.8-Mar-83 18:22:36	LXD        Eliminated possibility of zero-size files.14-Mar-83 11:51:45 	LXD        Unmap now announces itself.  Converted MakeImmutable action to MakeTemporary.26-Jul-83 16:10:08 	JXG      count parameter to Space.Window no longer defaulted 5-Nov-85 11:01:33      RSV      fixed enumerating physical volumes. 9-Feb-87 18:42:48      RSV      for MDS relief.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Script15.mesa        4-Apr-83 13:43:03 by CAJ -- Virtual memory test program, Klamath Pilot.-- Script15 tests CopyIn and CopyOut.DIRECTORY  Environment USING [PageCount, PageNumber],  ScriptOps USING [RegisterScript],  VM USING [Interval],  VMTestOperations --USING [all the operations]--,  VMTestScript USING [GetHeap, GetTestVMSize, GiveBackHeap, MakeBackingData,    MakeIrregularSwapData, MakeUniformSwapData, MakeUnitarySwapData, Ticker];Script15: PROGRAM  IMPORTS ScriptOps, VMTestOperations, VMTestScript =  BEGIN  ------------  -- PUBLIC procedures:  -- RunTests is a registered script procedure which may be called by the  -- VMTest driver.  The tests in the script may use procedures from  -- VMTestOperations (for VM operations) and VMTestScript (for test utilities).  RunTests: PROCEDURE =    BEGIN    heap: UNCOUNTED ZONE ¬ VMTestScript.GetHeap[];    Test1[heap];    Test2[heap];        heap ¬ VMTestScript.GiveBackHeap[heap];    END;  ------------  -- Private procedures:  Test1: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    page: Environment.PageNumber;    pRuns: LONG POINTER;    pSwap: LONG POINTER;    vmSize: CARDINAL ¬ CARDINAL[GetTestVMSize[]];  -- known to be short    pRuns ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, vmSize/3, 1]];    pSwap ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [1, vmSize/6, vmSize/6, 10]];    FOR count: Environment.PageCount IN [1..vmSize] DO      -- Map all testVM into 3 map units: irregular, unitary, uniform      Map[id: "irregular"L,          interval: [0, vmSize/3],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pRuns, 3]],          access: readWrite,          swapUnits: MakeIrregularSwapData[DESCRIPTOR[pRuns, 4]],          life: alive,          swappability: swappable];      Map[id: "unitary"L,          interval: [vmSize/3, vmSize/3],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pRuns, 3]],          access: readWrite,          swapUnits: MakeUnitarySwapData[],          life: alive,          swappability: swappable];      Map[id: "uniform"L,          interval: [vmSize/3 * 2, vmSize - vmSize/3 * 2],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pRuns, 3]],          access: readWrite,          swapUnits: MakeUniformSwapData[3],          life: alive,          swappability: swappable];      -- CopyIn each interval      FOR page ¬ 0, page + count UNTIL page > vmSize - count DO        CopyIn[interval: [page, count], runLength: count, returnWait: return]        ENDLOOP;      Ticker[];      -- Restore      Touch[[0, vmSize], write];      Deactivate[[0, vmSize], wait];      -- CopyOut each interval      FOR page ¬ 0, page + count UNTIL page > vmSize - count DO        CopyOut[interval: [page, count], runLength: count, returnWait: return]        ENDLOOP;      Ticker[];      -- Restore      Touch[[0, vmSize], write];      Deactivate[[0, vmSize], wait];      -- CopyIn + CopyOut same      FOR page ¬ 0, page + count UNTIL page > vmSize - count DO        CopyIn[interval: [page, count], runLength: count, returnWait: return];        CopyOut[interval: [page, count], runLength: count, returnWait: return];        ENDLOOP;      Ticker[];      -- Restore      Touch[[0, vmSize], write];      Deactivate[[0, vmSize], wait];      -- CopyOut + CopyIn same      FOR page ¬ 0, page + count UNTIL page > vmSize - count DO        CopyOut[interval: [page, count], runLength: count, returnWait: return];        CopyIn[interval: [page, count], runLength: count, returnWait: return];        ENDLOOP;      Ticker[];      Unmap[page: 0];      Unmap[page: vmSize/3];      Unmap[page: vmSize/3 * 2];      ENDLOOP;  -- end count loop    heap.FREE[@pRuns];    heap.FREE[@pSwap];    END;  -- Overlapped Copy operations  Test2: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    overlap: Environment.PageCount = 2;    page: Environment.PageNumber;    pRuns: LONG POINTER;    pSwap: LONG POINTER;    vmSize: CARDINAL ¬ CARDINAL[GetTestVMSize[]];  -- known to be short    pRuns ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, vmSize/3, 1]];    pSwap ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [1, vmSize/6, vmSize/6, 10]];    FOR count: Environment.PageCount IN [1..vmSize - overlap] DO      -- Map all testVM into 3 map units: irregular, unitary, uniform      Map[id: "irregular"L,          interval: [0, vmSize/3],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pRuns, 3]],          access: readWrite,          swapUnits: MakeIrregularSwapData[DESCRIPTOR[pRuns, 4]],          life: alive,          swappability: swappable];      Map[id: "unitary"L,          interval: [vmSize/3, vmSize/3],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pRuns, 3]],          access: readWrite,          swapUnits: MakeUnitarySwapData[],          life: alive,          swappability: swappable];      Map[id: "uniform"L,          interval: [vmSize/3 * 2, vmSize - vmSize/3 * 2],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pRuns, 3]],          access: readWrite,          swapUnits: MakeUniformSwapData[3],          life: alive,          swappability: swappable];      -- CopyIn + CopyOut overlapped      FOR page ¬ 0, page + count UNTIL page > vmSize - count - overlap DO        CopyIn[interval: [page + overlap, count], runLength: count,	  returnWait: return];        CopyOut[interval: [page, count], runLength: count, returnWait: return];        ENDLOOP;      Ticker[];      -- Restore      Touch[[0, vmSize], write];      Deactivate[[0, vmSize], wait];      -- CopyOut + CopyIn overlapped      FOR page ¬ 0, page + count UNTIL page > vmSize - count - overlap DO        CopyOut[interval: [page + overlap, count], runLength: count,	  returnWait: return];        CopyIn[interval: [page, count], runLength: count, returnWait: return];        ENDLOOP;      Ticker[];      -- Restore      Touch[[0, vmSize], write];      Deactivate[[0, vmSize], wait];      --CopyIns closing in from both ends      FOR page ¬ 0, page + count UNTIL page > vmSize - count DO        CopyIn[interval: [page, count], runLength: count, returnWait: return];        CopyIn[interval: [vmSize - page - count, count], runLength: count,	  returnWait: return];        ENDLOOP;      Ticker[];      -- Restore      Touch[[0, vmSize], write];      Deactivate[[0, vmSize], wait];      --CopyOuts closing in from both ends      FOR page ¬ 0, page + count UNTIL page > vmSize - count DO        CopyOut[interval: [page, count], runLength: count, returnWait: return];        CopyOut[interval: [vmSize - page - count, count], runLength: count,	  returnWait: return];        ENDLOOP;      Ticker[];      -- Restore      Touch[[0, vmSize], write];      Deactivate[[0, vmSize], wait];      -- CopyOut + CopyIn closing in from both ends      FOR page ¬ 0, page + count UNTIL page > vmSize - count DO        CopyOut[interval: [page, count], runLength: count, returnWait: return];        CopyIn[interval: [vmSize - page - count, count], runLength: count,	  returnWait: return];        ENDLOOP;      Ticker[];      Unmap[page: 0];      Unmap[page: vmSize/3];      Unmap[page: vmSize/3 * 2];      ENDLOOP;  -- end count loop    heap.FREE[@pRuns];    heap.FREE[@pSwap];    END;  ------------  -- PUBLIC SIGNALs and ERRORs: none  ------------  -- Initialization:  -- Register the given script proc and identifying name with the script  -- handling facility at start time.  Module must be explicitly started.  ScriptOps.RegisterScript[script: RunTests, name: "Copy loops"L];  END.LOG17-Mar-83 14:04:34   CAJ    Created file.
-- Copyright (C) 1981  by Xerox Corporation. All rights reserved. -- SystemCommands.mesa (last edited by: CJS    on: 11-Feb-87 12:23:25)DIRECTORY  Ascii USING [CR, SP],  Command,  PilotCommand,  String,  System,  TTY USING [Handle, GetID, GetNumber, PutChar, PutLine, PutOctal, PutString, GetChar];SystemCommands: PROGRAM  IMPORTS Command, PilotCommand, String, System, TTY EXPORTS PilotCommand =  BEGIN OPEN Command, System, TTY;  entries: ARRAY [0..10) OF Entry ¬ [    ["commands", LoopCmd],  -- must be first    ["greenwich mean time", GMTCmd], [    "measure interval timer overhead", MeasureIntervalTimerOverheadCmd], [    "measure interval timer rate", MeasureIntervalTimerRateCmd], [    "microseconds to pulses", MuSecsToPulsesCmd], [    "pulses to microseconds", PulsesToMuSecsCmd], [    "try interval timer", TryIntervalTimerCmd], [    "universal identifier", UniversalIDCmd], ["power off", PowerOffCmd], [    "quit", Command.QuitLevel]  -- must be last    ];  GMTCmd: Action = {    PutString[h, " = "]; WriteGreenwichMeanTime[h, GetGreenwichMeanTime[]]; };  LoopCmd: Action = {    Loop[h, DESCRIPTOR[@entries[1], LENGTH[entries] - 1], NullCatch, "system "];    };  tty: TTY.Handle = PilotCommand.defaultWindow;  usecsPerPulse: LONG CARDINAL ¬ 0;  MeasureIntervalTimerOverheadCmd: Action =    BEGIN    d: LONG CARDINAL;  -- needed because of compiler bug    n: LONG CARDINAL = 1D5;    pl0, plLoop, plLoopGet, plT, plLoopGetGet: LONG CARDINAL;    PutChar[h, Ascii.CR];    IF usecsPerPulse = 0 THEN      BEGIN WriteError[h, "first measure rate"L]; RETURN END;    WriteMeasure["iterations"L, n];    PutLine[h, "Following measures are usecs/iteration:"L];    pl0 ¬ GetClockPulses[];    -- 6.0n compiler bug prevents long fors    d ¬ 0;    DO IF (d ¬ d + 1) = n THEN EXIT; ENDLOOP;    -- FOR [0..n) DO ENDLOOP;    plLoop ¬ GetClockPulses[] - pl0;    WriteMeasure["loop"L, plLoop*usecsPerPulse/n];    pl0 ¬ GetClockPulses[];    -- FOR dummy IN [0..n) DO [] ¬ GetClockPulses[] ENDLOOP;    d ¬ 0;    DO [] ¬ GetClockPulses[]; IF (d ¬ d + 1) = n THEN EXIT; ENDLOOP;    plLoopGet ¬ GetClockPulses[] - pl0;    WriteMeasure["[]¬Get[]"L, (plLoopGet - plLoop)*usecsPerPulse/n];    pl0 ¬ GetClockPulses[];    -- FOR dummy IN [0..n) DO plT ¬ GetClockPulses[]; plT ¬ GetClockPulses[]-plT ENDLOOP;    d ¬ 0;    DO      plT ¬ GetClockPulses[];      plT ¬ GetClockPulses[] - plT;      IF (d ¬ d + 1) = n THEN EXIT;      ENDLOOP;    plLoopGetGet ¬ GetClockPulses[] - pl0;    WriteMeasure["v¬Get[];v¬Get[]-v"L, (plLoopGetGet - plLoop)*usecsPerPulse/n];    END;  MeasureIntervalTimerRateCmd: Action =    BEGIN    pl0, plElapsed, usecs: LONG CARDINAL;    min, sec: CARDINAL;    PutChar[h, Ascii.CR];    PutString[h, "Type any character to start interval..."L];    [] ¬ ReadChar[h];    pl0 ¬ GetClockPulses[];    PutString[h, "...now any character to end interval"L];    [] ¬ ReadChar[h];    plElapsed ¬ GetClockPulses[] - pl0;    PutChar[h, Ascii.CR];    min ¬ ReadParameter["interval minutes"L, 1];    sec ¬ ReadParameter[" seconds"L, 0];    WriteMeasure["elapsed pulses"L, plElapsed];    usecsPerPulse ¬ (usecs ¬ (LONG[min]*60 + sec)*1D6)/plElapsed;    WriteMeasure["usecs/pulse"L, usecsPerPulse];    WriteMeasure["remainder", usecs - usecsPerPulse*plElapsed];    END;  MuSecsToPulsesCmd: Action =    BEGIN    microseconds: Microseconds;    PutString[h, " of "];    microseconds ¬ ReadLongNumber[radix: 10];    PutString[h, " = "];    WriteLongDecimal[h, MicrosecondsToPulses[microseconds]]    END;  PulsesToMuSecsCmd: Action =    BEGIN    pulses: Pulses;    PutString[h, " of "];    pulses ¬ [ReadLongNumber[radix: 10]];    PutString[h, " = "];    WriteLongDecimal[h, PulsesToMicroseconds[pulses]]    END;  PowerOffCmd: Action = {Confirm[h]; PowerOff[]; };  -- what about flushing typescript?  SystemCmd: Action =    BEGIN    PutChar[h, Ascii.SP];    Scan[h, DESCRIPTOR[BASE[entries], LENGTH[entries] - 1], NullCatch]    END;  TryIntervalTimerCmd: Action =    BEGIN    t: TimerHandle;    m: Microseconds;    PutChar[h, Ascii.CR];    PutString[h, "Type any character to start interval..."L];    [] ¬ ReadChar[h];    t ¬ CreateIntervalTimer[];    PutString[h, "...now any character to end interval"L];    [] ¬ ReadChar[h];    m ¬ GetIntervalTime[t];    PutChar[h, Ascii.CR];    WriteMeasure["elapsed microseconds"L, m]    END;  UniversalIDCmd: Action =    BEGIN PutString[h, " = "]; WriteUniversalID[h, GetUniversalID[]] END;  -- Following should be exported to PilotCommand:  ReadLongNumber: PROCEDURE [radix: CARDINAL] RETURNS [LONG UNSPECIFIED] =    BEGIN    s: STRING = [20];    GetID[tty, s];    RETURN[String.StringToLongNumber[s: s, radix: radix]]    END;  ReadParameter: PROCEDURE [p: STRING, default: CARDINAL] RETURNS [v: CARDINAL] =    BEGIN    PutString[tty, p];    PutString[tty, " =	"L];    v ¬ GetNumber[h: tty, default: default, radix: 10];    PutChar[tty, Ascii.CR]    END;  sizeUID: CARDINAL = SIZE[System.UniversalID];  RepUID: TYPE = RECORD [ARRAY [0..sizeUID) OF CARDINAL];  ReadUniversalID: PUBLIC PROCEDURE [h: TTY.Handle, default: System.UniversalID]    RETURNS [System.UniversalID] =    BEGIN OPEN rep: LOOPHOLE[default, RepUID];        GetValidIDNum: PROC [      default: UNSPECIFIED, terminators: STRING, ignoreLeadingBrac: BOOLEAN]      RETURNS[UNSPECIFIED] =      BEGIN      c: CHARACTER ¬ GetChar[h];      s: STRING = [20];      WHILE c=Ascii.SP DO PutChar[h, Ascii.SP]; c ¬ GetChar[h] ENDLOOP;      IF ignoreLeadingBrac AND c = '[ THEN {        c ¬ GetChar[h]; WHILE c=Ascii.SP DO PutChar[h, Ascii.SP]; c ¬ GetChar[h] ENDLOOP};      WHILE c IN ['0..'8) DO        PutChar[h, c];        String.AppendChar[s, c  ! String.StringBoundsFault => GOTO invalidNumber];        c ¬ GetChar[h];              ENDLOOP;                  IF s.length = 0 THEN {        IF ~(c=Ascii.CR OR c=terminators[0] OR c=terminators[1]) THEN GOTO invalidNumber;	TTY.PutOctal[h, default]; RETURN[default]}      ELSE {        IF c = 'B OR c = 'b THEN {PutChar[h, c]; c ¬ GetChar[h]};        IF ~(c=Ascii.CR OR c=terminators[0] OR c=terminators[1]) THEN GOTO invalidNumber;        RETURN[String.StringToNumber[s, 8]]};      EXITS      invalidNumber => ERROR String.InvalidNumber      END;               PutChar[h, '[];    rep[0] ¬ GetValidIDNum[default: rep[0], terminators: ", "L, ignoreLeadingBrac: TRUE];  PutChar[h, ',];    FOR i: CARDINAL IN (0..sizeUID-1) DO     rep[i] ¬ GetValidIDNum[default: rep[i], terminators: ", "L, ignoreLeadingBrac: FALSE];      PutChar[h, ',];         ENDLOOP;    rep[sizeUID-1] ¬ GetValidIDNum[      default: rep[sizeUID-1], terminators: " ]"L, ignoreLeadingBrac: FALSE];    PutChar[h, ']];    RETURN[LOOPHOLE[rep]]    END;  WriteMeasure: PROCEDURE [m: LONG STRING, v: LONG CARDINAL] =    BEGIN    PutString[tty, m];    PutString[tty, " =	"L];    WriteLongDecimal[tty, v];    PutChar[tty, Ascii.CR]    END;  WriteGreenwichMeanTime: PUBLIC PROCEDURE [    h: TTY.Handle, gmt: GreenwichMeanTime] =    BEGIN    s: STRING = [20];    String.AppendLongNumber[s: s, n: gmt, radix: 8];    PutString[h, s]    -- add (optional?) alphanumeric version a la TimeDefs    END;  WriteUniversalID: PUBLIC PROCEDURE [h: TTY.Handle, uid: UniversalID] =    BEGIN OPEN rep: LOOPHOLE[uid, RepUID];    PutChar[h, '[];    FOR i: [0..sizeUID) IN [0..sizeUID) DO      PutOctal[h, rep[i]]; IF i ~= sizeUID - 1 THEN PutChar[h, ',] ENDLOOP;    PutChar[h, ']]    END;  InstallTopLevel[tty, ["system", SystemCmd]]  END. LOGTime: July 10, 1979  11:26 AM			By: FXH    		Action: StringDefs=>StringTime: November 8, 1979  1:45 PM			By: RXG   		Action: Fix bug in measuring interval timer rateTime: July 17, 1980  1:32 PM			By: PXM    		Action: Remove dependency on uid sizeTime: August 15, 1980  8:02 PM	                By: SXY   		Action: IODefs and Command are replaced by TTY and TTYCommand respectivelyTime: September 9, 1980  2:07 PM		By: SXY   		Action: TTYCommand is replaced by new CommandTime: October 15, 1981  3:02 PM                 By: Rhodes              Action: GetNumber replaced by GetValidIDNum in ReadUniversalID (friendlier input routine)11-Feb-87 12:23:39	CJS	STRING ¬ LONG STRING in WriteMeasure.
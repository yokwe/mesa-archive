-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. -- FTTApplySetUpImpl.mesa,  last edited by RSV   3-Apr-87 17:14:06DIRECTORY  Environment USING [bytesPerPage],  File USING [Error, File, ID, nullFile, nullID, SetSize, Unknown],  Floppy,  Format USING [],  FormSW USING [    AllocateItemDescriptor,  ClientItemsProcType, CommandItem, Display,    Enumerated, EnumeratedItem, line0, line1, line2, ProcType,StringItem],  FTTDefs,  Heap USING [systemZone],  MFile USING [Acquire, Error, Handle, ReadWrite, SetAccess],  Space USING [Error, Interval, Map, PageCount],  SpecialMFile USING [GetCapaWithAccess],  String USING [    AppendChar, AppendOctal, AppendString, AppendSubString, InvalidNumber,    Replace, StringToOctal, SubString, SubStringDescriptor],  Tool USING [Create, Destroy, MakeFormSW, MakeSWsProc],  Volume USING [InsufficientSpace, systemID, Unknown],  Window USING [Box, GetBox];FTTApplySetUpImpl: PROGRAM  IMPORTS     File, Floppy, FormSW, FTTDefs, Heap, MFile, Space, SpecialMFile,    String, Tool, Volume, Window  EXPORTS FTTDefs  SHARES Floppy =			  BEGIN OPEN FTTDefs;    z: UNCOUNTED ZONE = Heap.systemZone;        ValidateFileID: PUBLIC PROCEDURE [s: LONG STRING]    RETURNS [valid: BOOLEAN, id: File.ID] =    BEGIN    currentNumber: STRING ¬ [64];    startPos: CARDINAL;    curPos: CARDINAL;    len: CARDINAL;    subStringDesc: String.SubStringDescriptor;    subString: String.SubString ¬ @subStringDesc;    p:  POINTER TO ARRAY [0..SIZE[File.ID]) OF UNSPECIFIED = LOOPHOLE[@id];    id ¬ File.nullID;    valid ¬ TRUE;    -- Skip over any leading characters that are not octal digits        IF s = NIL THEN SIGNAL redoparams["Need a File.ID"L];    FOR startPos IN [0..s.length) DO      IF s[startPos] IN ['0..'7] THEN EXIT;      REPEAT FINISHED => GO TO nullReturn;  -- a bogus File.ID was given      ENDLOOP;    -- Now process each word of the UID    FOR word: [0..SIZE[File.ID]) IN [0..SIZE[File.ID]) DO      -- parse each word      curPos ¬ startPos;      WHILE s[curPos] IN ['0..'7] DO        curPos ¬ curPos + 1;        IF curPos >= s.length THEN RETURN;  -- Truncate the File.ID        ENDLOOP;      IF s[curPos] = 'B OR s[curPos] = 'b THEN len ¬ curPos - startPos + 1      ELSE len ¬ curPos - startPos;      currentNumber.length ¬ 0;      subString^ ¬ [s, startPos, len];      String.AppendSubString[to: currentNumber, from: subString];      p[word] ¬ String.StringToOctal[        currentNumber ! String.InvalidNumber => GO TO nullReturn];      startPos ¬ startPos + len;      UNTIL s[startPos] IN ['0..'7] DO        startPos ¬ startPos + 1;        IF startPos >= s.length THEN RETURN;  -- Truncate the UID        ENDLOOP;      ENDLOOP;    EXITS nullReturn => RETURN[FALSE, File.nullID];    END;  ReplaceFileIDString: PUBLIC PROCEDURE [    heapString: LONG POINTER TO LONG STRING, id: File.ID] =    BEGIN    i: CARDINAL ¬ 0;    s: STRING ¬ [64];    p: POINTER TO ARRAY [0..SIZE[File.ID]) OF UNSPECIFIED =      LOOPHOLE[@id];    String.AppendChar[s, '[];    FOR i: [0..SIZE[File.ID]) IN [0..SIZE[File.ID] - 1) DO      String.AppendOctal[s, p[i]];      String.AppendString[to: s, from: ", "L];      ENDLOOP;    String.AppendOctal[s, p[SIZE[File.ID] - 1]];    String.AppendChar[s, ']];    String.Replace[heapString, s, z];    END;  LoopHoleFile: PUBLIC PROCEDURE [fileID: LONG STRING] RETURNS [file: File.File] =    BEGIN     --convert a string into a File.ID    valid: BOOLEAN;    [valid, file.fileID] ¬ ValidateFileID[fileID];        IF NOT valid THEN      SIGNAL redoparams["Invalid File ID"L];    file.volumeID ¬ Volume.systemID;    END;     ConvertFile: PUBLIC PROCEDURE [file: File.File] =    BEGIN    --turn the file ID into a string and put it into toolData.pilotFile    ReplaceFileIDString[@toolData.pilotFileID, file.fileID];  END;  MinFileSize: PUBLIC PROCEDURE [file: FileRecType, count: Floppy.PageCount]    RETURNS[recount: Floppy.PageCount] =      BEGIN    recount ¬ MIN[      count,       Floppy.GetFileAttributes[LOOPHOLE[file, Floppy.FileHandle] !	Floppy.Error => ErrorHandlingProc[error];].size];    IF recount # toolData.count THEN      SIGNAL reduceCount;    RETURN[recount]    END;  CreateSpace: PUBLIC PROCEDURE [size: Space.PageCount] =    BEGIN          --Create the new space    toolData.vmInterval ¬       Space.Map[window: [file: File.nullFile, base: NULL, count: size] ! 	Space.Error =>	  IF type = invalidParameters THEN	    SIGNAL redoparams["Invalid parameter -- count must be > 0"L];];    --get a LONG POINTER for the space and store it as a CARDINAL    toolData.vm ¬ LOOPHOLE[toolData.vmInterval.pointer, LONG CARDINAL];    --save the value of count for later comparison    toolData.lastSpaceCount ¬ toolData.count;    END;      GetAFileOptionsWindow: PUBLIC FormSW.ProcType =    BEGIN        GetAFileOptionSW: Tool.MakeSWsProc =       {[] ¬ Tool.MakeFormSW[window: window, formProc: GetAFileMakeForm]};	       box: Window.Box = Window.GetBox[wh];    toolData.getAFileOptionSW ¬ Tool.Create[      name: "Get A File"L, makeSWsProc: GetAFileOptionSW, initialState: active,      initialBox: [[box.place.x, box.place.y - 125], [350, 125]]]    END;            GetAFileMakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    nOptions: CARDINAL = 4;    stateOfFile: ARRAY [0..2) OF Enumerated ¬ [      ["Existing"L, ExistingORNewFile[Old]], ["New"L, ExistingORNewFile[New]]];    items ¬ AllocateItemDescriptor[nOptions];    items[0] ¬ StringItem[      tag: "pilotFile"L, place: [0, line0], string: @toolData.pilotFile,      inHeap: TRUE];    items[1] ¬       EnumeratedItem[tag: "pilotFile is"L, place:[0, line1], feedback: all,      	value: @toolData.fileCapFrom, choices: DESCRIPTOR[stateOfFile]];    items[2] ¬      CommandItem[tag: "Abort"L, place: [250, line1], proc: RemoveGetAFileOption];    items[3] ¬       CommandItem[tag: "Do it"L, place: [250, line2],        proc: GetAFileApplyOptions];    RETURN[items, TRUE]   END;      GetAFileApplyOptions: FormSW.ProcType =     BEGIN       ENABLE       	 BEGIN	 MFile.Error =>	   BEGIN	   SELECT code FROM	     noSuchFile =>  PrintErrorProc[toolData.msgSW,	       "PilotFile Not Found"L];	     illegalName => PrintErrorProc[toolData.msgSW,	       "Invalid PilotFile Name"L];	     ENDCASE;	   GOTO exit;	   END;	 Volume.InsufficientSpace =>	   BEGIN	   PrintErrorProc[toolData.msgSW,	     "Not enough Space to create the new file"L];           GOTO exit;	   END;	 redoparams =>	   BEGIN	   PrintErrorProc[toolData.msgSW, msg];	   GOTO exit;           END;         END;	 		           file: FileRecType ¬ [toolData.volumeHandle.lowbits,       toolData.volumeHandle.highbits,       toolData.fileID.a, toolData.fileID.b];     handle: MFile.Handle;     size: LONG CARDINAL;	     ClearmsgSW[];     -- This code bypasses the file system interlocking mechanism,     -- acquiring access only long enough to determine the file ID     SELECT toolData.fileCapFrom FROM       ExistingORNewFile[Old] =>	 BEGIN	 -- first get only anchor access to force error if file doesn't exist	 handle ¬ MFile.Acquire[name: toolData.pilotFile,	   access: anchor, release: [NIL,NIL]];	 -- then kick it up to full access	 MFile.SetAccess[handle, readWrite];	 END;       ExistingORNewFile[New] =>	 BEGIN	 size ¬ Environment.bytesPerPage * Floppy.GetFileAttributes[	   LOOPHOLE[file, Floppy.FileHandle]	     ! Floppy.Error => ErrorHandlingProc[error];].size;	 handle ¬ MFile.ReadWrite[name: toolData.pilotFile, release: [NIL,NIL],	   type: unknown, initialLength: size];	 END;       ENDCASE;     --Convert this File.Capability into a String so it can be displayed     ConvertFile[SpecialMFile.GetCapaWithAccess[handle]];     FormSW.Display[sw: toolData.optionFormSW];     toolData.fileHandle ¬ LOOPHOLE[handle, LONG CARDINAL];     RemoveGetAFileOption;     EXITS       exit => RETURN;     END;               RemoveGetAFileOption: PUBLIC FormSW.ProcType =    BEGIN      Tool.Destroy[toolData.getAFileOptionSW];      toolData.getAFileOptionSW ¬ NIL;    END;  SetSizeOfImageFile: PUBLIC FormSW.ProcType =    BEGIN       ENABLE        redoparams => BEGIN	    	     PrintErrorProc[toolData.msgSW, msg];		     GOTO exit;                     END;    file: File.File ¬ LoopHoleFile[toolData.pilotFileID];    File.SetSize[file: file, size: toolData.count !        File.Unknown => PrintErrorProc[toolData.msgSW,"FileisUnknown"L];	Volume.Unknown => PrintErrorProc[toolData.msgSW, "File is Unknown"L];	Volume.InsufficientSpace =>	  PrintErrorProc[toolData.msgSW, "Not enough free pages on volume"L];	File.Error => IF type = invalidParameters THEN 	                PrintErrorProc[toolData.msgSW, "Invalid parameters"L]];    EXITS      exit => RETURN;    END;END....   LOG 1-Dec-81 15:36:11  LXD  created file  9-Dec-81 14:47:18  CAJ  converted from Directory to new file system.10-Feb-82 15:42:43  LXD  corrected bug in MFile.ReadWrite call in GetAFileCapApplyOptions.26-Oct-82 13:41:15  ET   Added SetSizeOfImageFile. 3-Apr-87 17:13:59  RSV  Added copyright notice.  Folded in changes from ET.  Old arrows to new arrows.  Move off of Storage.  Convert to Klamath version of File.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Script0.mesa       26-Apr-83 17:16:57 by CAJ -- Virtual memory test program, Klamath Pilot.-- Script0 tests Deactivate.DIRECTORY  Environment USING [PageCount, PageNumber],  ScriptOps USING [RegisterScript],  Space USING [SwapUnitSize],  VM USING [Interval, nullBackingStoreRuns],  VMTestOperations --USING [all the operations]--,  VMTestScript USING [GetHeap, GetTestVMSize, GiveBackHeap, MakeBackingData,    MakeIrregularSwapData, MakeUniformSwapData, MakeUnitarySwapData,    Ticker];Script0: PROGRAM  IMPORTS ScriptOps, VMTestOperations, VMTestScript =  BEGIN  ------------  -- PUBLIC procedures:  -- RunTests is the registered script procedure  RunTests: PROCEDURE =    BEGIN OPEN VMTestOperations, VMTestScript;    heap: UNCOUNTED ZONE ¬ GetHeap[];    TestDeactivate[heap];    TestDeactivateCombo1[heap];    TestDeactivateCombo2[heap];    heap ¬ GiveBackHeap[heap];    END;  ------------  -- PRIVATE procedures:  -- Allocate variable number of words out of the heap  Allocate: PROCEDURE [heap: UNCOUNTED ZONE, words: CARDINAL]    RETURNS [LONG POINTER] =    INLINE BEGIN    hunk: TYPE = RECORD [s: SEQUENCE COMPUTED CARDINAL OF WORD];    RETURN[heap.NEW[hunk[words]]];    END;  -- Test Deactivate with different combinations of Map unit attributes  TestDeactivate: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- Map a space with each combination of Map attributes.  The same set    -- of tests is used with each Map.    pArray: LONG POINTER;    vmSize: CARDINAL = CARDINAL[GetTestVMSize[]];    -- Deactivates with normal case Map    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "normal case map"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 6]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: alive,      swappability: swappable];    -- Each test uses a new interval unless reuse is relevant to the test or    -- otherwise noted.    -- deactivate single swap unit    Touch[[3, 1], read];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate dirty (same interval)    Touch[[3, 1], write];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate overlap to next    Touch[[4, 5], read];    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate already deactivated    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate not in    Deactivate[[0, 3], wait];    Ticker[];    -- deactivate less than swap unit    Touch[[14, 1], read];    Deactivate[[14, 1], wait];    Ticker[];    -- deactivate running off end of map unit    Touch[[17, 1], read];    Deactivate[[17, 4], wait];    Ticker[];    -- deactivate unmapped    Deactivate[[20, 5], wait];    Ticker[];    -- deactivate all of testVM    Deactivate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Deactivates on space Mapped dead    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "swappable + readWrite + dead"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 6]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: dead,      swappability: swappable];    -- deactivate single swap unit    Touch[[3, 1], read];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate dirty (same interval)    Touch[[3, 1], write];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate overlap to next    Touch[[4, 5], read];    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate already deactivated    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate not in    Deactivate[[0, 3], wait];    Ticker[];    -- deactivate less than swap unit    Touch[[14, 1], read];    Deactivate[[14, 1], wait];    Ticker[];    -- deactivate running off end of map unit    Touch[[17, 1], read];    Deactivate[[17, 4], wait];    Ticker[];    -- deactivate all of testVM    Deactivate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Deactivates on space Mapped resident + readWrite + alive    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "resident + readWrite + alive"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 6]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: alive,      swappability: resident];    -- deactivate single swap unit    Touch[[3, 1], read];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate dirty (same interval)    Touch[[3, 1], write];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate overlap to next    Touch[[4, 5], read];    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate already deactivated    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate not in    Deactivate[[0, 3], wait];    Ticker[];    -- deactivate less than swap unit    Touch[[14, 1], read];    Deactivate[[14, 1], wait];    Ticker[];    -- deactivate running off end of map unit    Touch[[17, 1], read];    Deactivate[[17, 4], wait];    Ticker[];    -- deactivate all of testVM    Deactivate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Deactivates on space Mapped resident + readWrite + dead    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "resident + readWrite + dead"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 6]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: dead,      swappability: resident];    -- deactivate single swap unit    Touch[[3, 1], read];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate dirty (same interval)    Touch[[3, 1], write];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate overlap to next    Touch[[4, 5], read];    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate already deactivated    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate not in    Deactivate[[0, 3], wait];    Ticker[];    -- deactivate less than swap unit    Touch[[14, 1], read];    Deactivate[[14, 1], wait];    Ticker[];    -- deactivate running off end of map unit    Touch[[17, 1], read];    Deactivate[[17, 4], wait];    Ticker[];    -- deactivate all of testVM    Deactivate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Deactivates on space Mapped resident + not backed (standard data space)    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "resident + readWrite + not backed"L,      interval: [0, 19],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: alive,      swappability: resident];    -- deactivate single swap unit    Touch[[3, 1], read];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate dirty (same interval)    Touch[[3, 1], write];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate overlap to next    Touch[[4, 5], read];    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate already deactivated    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate not in    Deactivate[[0, 3], wait];    Ticker[];    -- deactivate less than swap unit    Touch[[14, 1], read];    Deactivate[[14, 1], wait];    Ticker[];    -- deactivate running off end of map unit    Touch[[17, 1], read];    Deactivate[[17, 4], wait];    Ticker[];    -- deactivate all of testVM    Deactivate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Deactivates on space Mapped resident + not backed + dead    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "resident + not backed + dead"L,      interval: [0, 19],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: dead,      swappability: resident];    -- deactivate single swap unit    Touch[[3, 1], read];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate dirty (same interval)    Touch[[3, 1], write];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate overlap to next    Touch[[4, 5], read];    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate already deactivated    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate not in    Deactivate[[0, 3], wait];    Ticker[];    -- deactivate less than swap unit    Touch[[14, 1], read];    Deactivate[[14, 1], wait];    Ticker[];    -- deactivate running off end of map unit    Touch[[17, 1], read];    Deactivate[[17, 4], wait];    Ticker[];    -- deactivate all of testVM    Deactivate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Deactivates on space Mapped resident + readOnly + alive    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "resident + readOnly + alive"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 6]],      access: readOnly,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: alive,      swappability: resident];    -- deactivate single swap unit    Touch[[3, 1], read];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate overlap to next    Touch[[4, 5], read];    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate already deactivated    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate not in    Deactivate[[0, 3], wait];    Ticker[];    -- deactivate less than swap unit    Touch[[14, 1], read];    Deactivate[[14, 1], wait];    Ticker[];    -- deactivate running off end of map unit    Touch[[17, 1], read];    Deactivate[[17, 4], wait];    Ticker[];    -- deactivate all of testVM    Deactivate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Deactivates on space Mapped swappable + readOnly + alive    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "swappable + readOnly + alive"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 6]],      access: readOnly,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: alive,      swappability: swappable];    -- deactivate single swap unit    Touch[[3, 1], read];    Deactivate[[3, 1], wait];    Ticker[];    -- deactivate overlap to next    Touch[[4, 5], read];    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate already deactivated    Deactivate[[4, 5], wait];    Ticker[];    -- deactivate not in    Deactivate[[0, 3], wait];    Ticker[];    -- deactivate less than swap unit    Touch[[14, 1], read];    Deactivate[[14, 1], wait];    Ticker[];    -- deactivate running off end of map unit    Touch[[17, 1], read];    Deactivate[[17, 4], wait];    Ticker[];    -- deactivate all of testVM    Deactivate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    END;  -- Combinations of Deactivates and ForceOuts  TestDeactivateCombo1: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- Map all of test VM using different sizes of map interval and alternating    -- all three types of swap unit.  Try various combinations of Deactivate,    -- ForceOut, and Touch.  Tests overlaps and underlaps(?) of map unit, swap    -- unit, and run boundaries, dirty/clean combinations, in-/out-ness.    count: Environment.PageCount;    mapCount: CARDINAL;    page: Environment.PageNumber;    pArray: LONG POINTER;    vmSize: CARDINAL = CARDINAL[GetTestVMSize[]];  -- known to be short    FOR mapCount IN [1..8) DO  -- arbitrary small number of different sizes      --  Map intervals of pages irregular, unitary, uniform, ...      pArray ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [mapCount]];      FOR page ¬ 0, page + mapCount * 3 UNTIL page > vmSize - mapCount * 3 DO        Map[id: "irregular"L,          interval: [page, mapCount],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArray, 1]],          access: readWrite,          swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 1]],          life: alive,          swappability: swappable];        Map[id: "unitary"L,          interval: [page + mapCount, mapCount],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArray, 1]],          access: readWrite,          swapUnits: MakeUnitarySwapData[],          life: alive,          swappability: swappable];        Map[id: "uniform"L,          interval: [page + mapCount * 2, mapCount],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArray, 1]],          access: readWrite,          swapUnits: MakeUniformSwapData[mapCount],          life: alive,          swappability: swappable];        ENDLOOP;  -- end mapping loop      BEGIN ENABLE VMTestOperations.CannotTouch => CONTINUE;      -- Just skip Touch if the page isn't mapped.      -- ForceOut-return/Deactivate      FOR count IN [1..vmSize] DO        -- first dirty alternate pages	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 1 DO          Touch[[page, 1], write]; ENDLOOP;        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  ForceOut[[page, count], return];	  Deactivate[[page, count], return];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Dirty - Deactivate - ForceOut      FOR count DECREASING IN [1..vmSize] DO        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Touch[[page, 1], write];	  Deactivate[[page, count], wait];	  ForceOut[[page, count], wait];          ENDLOOP;        Ticker[];        ENDLOOP;      -- Dirty - ForceOut - Deactivate      FOR count IN [1..vmSize] DO        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Touch[[page, 1], write];	  ForceOut[[page, count], wait];	  Deactivate[[page, count], wait];          ENDLOOP;        Ticker[];        ENDLOOP;      -- Dirty - ForceOut - Touch - Deactivate      FOR count IN [1..vmSize] DO        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Touch[[page, count], write];	  ForceOut[[page, count], wait];          ENDLOOP;        FOR page DECREASING IN [0..vmSize) DO	  Touch[[page, 1], read];	  Deactivate[[page, 1], wait];          ENDLOOP;        Ticker[];        ENDLOOP;      END;  -- end scope of enable      -- Unmap the whole works      FOR page  ¬ 0, page + mapCount UNTIL page > vmSize - mapCount DO        Unmap[page] ENDLOOP;      heap.FREE[@pArray];      ENDLOOP;  -- end mapCount loop    END;  -- Combinations of Activates, Deactivates and Kills  TestDeactivateCombo2: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- Map all of test VM using different sizes of map interval and alternating    -- all three types of swap unit.  Try various combinations of Activate,    -- Deactivate, Kill, and Touch.  Tests overlaps and underlaps(?) of map unit,    -- swap unit, and run boundaries, dirty/clean combinations, in-/out-ness,    -- alive/dead combinations.    count: Environment.PageCount;    mapUnitSize: CARDINAL;    maxMapUnitSize: CARDINAL;    page: Environment.PageNumber;    pBacking: LONG POINTER;    pSwap: LONG POINTER;    vmSize: CARDINAL = CARDINAL[GetTestVMSize[]];  -- known to be short    maxMapUnitSize ¬ vmSize/3;    -- BackingStore for all map units through all map unit sizes consists of    -- 2 (approx.) equal runs totalling maxMapUnitSize.  The existence of a run    -- boundary in the map unit and its location relative to swap units will    -- vary as the map unit size increases.  For all but the last round,    -- the backing store extends past the end of the map unit.    pBacking ¬ heap.NEW[ARRAY[0..2) OF WORD ¬      [maxMapUnitSize/2, maxMapUnitSize - maxMapUnitSize/2]];    FOR mapUnitSize IN [1..maxMapUnitSize] DO      -- Map uniform, irregular, unitary, uniform, irregular, ...      -- Doing Maps non-sequentially      FOR page ¬ 0, page + mapUnitSize * 3 UNTIL page > vmSize - mapUnitSize DO        Map[id: "uniform"L,          interval: [page, mapUnitSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pBacking, 2]],          access: readWrite,          swapUnits: MakeUniformSwapData[mapUnitSize],          life: alive,          swappability: swappable];        ENDLOOP;  -- end map loop      -- Allocate and initiate for single page swap units, no overlap.      pSwap ¬ Allocate[heap, mapUnitSize];      FOR i: CARDINAL IN [0..mapUnitSize) DO (pSwap + i)­ ¬ 1 ENDLOOP;      FOR page ¬ mapUnitSize, page + mapUnitSize * 3          UNTIL page > vmSize - mapUnitSize DO        Map[id: "irregular"L,          interval: [page, mapUnitSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pBacking, 2]],          access: readWrite,          swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwap, mapUnitSize]],          life: alive,          swappability: swappable];        ENDLOOP;  -- end map loop      FOR page ¬ mapUnitSize * 2, page + mapUnitSize * 3          UNTIL page > vmSize - mapUnitSize DO        Map[id: "unitary"L,          interval: [page, mapUnitSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pBacking, 2]],          access: readWrite,          swapUnits: MakeUnitarySwapData[],          life: alive,          swappability: swappable];        ENDLOOP;  -- end map loop      BEGIN ENABLE VMTestOperations.CannotTouch => CONTINUE;      -- Just skip Touch if the page isn't mapped.      -- dirty some, Kill, Deactivate      FOR count IN [1..vmSize] DO        -- first dirty alternate pages        FOR page ¬ 0, page + 2 UNTIL page > vmSize - 1 DO          Touch[[page, 1], write]; ENDLOOP;        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Kill[[page, count]];	  Deactivate[[page, count], return];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Kill, Activate, dirty some, Deactivate      FOR count IN [1..vmSize] DO        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Kill[[page, count]];	  Activate[[page, 1], return];	  ENDLOOP;        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO          Touch[[page + count - 1, 1], write];	  Deactivate[[page, count], return];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- touch some, Deactivate, Kill, Activate      FOR count IN [1..vmSize] DO        -- first touch every other page	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 1 DO          Touch[[page, 1], read]; ENDLOOP;        -- Deactivate every other page	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 1 DO	  Deactivate[[page, 1], return]; ENDLOOP;        -- Kill everything	FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Kill[[page, count]]; ENDLOOP;        -- Activate everything and touch some        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Activate[[page, count], return];          Touch[[page, 1], write];	  ENDLOOP;        Ticker[];	ENDLOOP;      END;  -- end scope of enable      -- Unmap the whole works      FOR page  ¬ 0, page + mapUnitSize UNTIL page > vmSize - mapUnitSize DO        Unmap[page] ENDLOOP;      heap.FREE[@pSwap];      ENDLOOP;  -- end mapCount loop    heap.FREE[@pBacking];    END;  ------------  -- PUBLIC SIGNALs and ERRORs: none  ------------  -- Initialization:  ScriptOps.RegisterScript[RunTests, "Deactivate"L];  END.LOG22-Nov-82 15:30:39   CAJ    Created file.
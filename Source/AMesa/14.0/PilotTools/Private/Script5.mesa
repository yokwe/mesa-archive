-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Script5.mesa      26-Apr-83 17:07:18 by CAJ -- Virtual memory test program, Klamath Pilot.-- Script5 tests CopyIn.DIRECTORY  Environment USING [PageCount],  ScriptOps USING [RegisterScript],  VM USING [Interval],  VMTestOperations --USING [all the operations]--,  VMTestScript USING [GetHeap, GiveBackHeap, MakeBackingData,    MakeIrregularSwapData, MakeUniformSwapData, MakeUnitarySwapData, Ticker];Script5: PROGRAM  IMPORTS ScriptOps, VMTestOperations, VMTestScript =  BEGIN  ------------  -- PUBLIC procedures:  -- RunTests is a script of tests using procedures from VMTestOperations (for  -- VM operations) and VMTestScript (for test utilities).  RunTests: PROCEDURE =    BEGIN OPEN VMTestScript;    heap: UNCOUNTED ZONE ¬ GetHeap[];    CopyInUnitary[heap];    CopyInUniformA[heap];    CopyInUniformB[heap];    CopyInUniformC[heap];    CopyInIrregularA[heap];    CopyInIrregularB[heap];    CopyInIrregularC[heap];    CopyInOther[heap];    -- in + out    -- out + in    -- resident    -- resident + swap mixed    TestErrors[heap];    heap ¬ GiveBackHeap[heap];    END;  TestErrors: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      -- Make as many arrayPointers as needed    --pArray: LONG POINTER;    --pRuns: LONG POINTER;    --pSwapUnits: LONG POINTER;    -- all unmapped    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    CopyOut[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    -- error: unmapped: 1st part    -- error: unmapped: later part    -- error: unmapped: enclosed part    -- error: readonly: all    -- error: readonly: 1st part    -- error: readonly: later part    -- error: readonly: enclosed part    -- error: run < interval    -- error: null interval    END;  -- CopyIn tests for irregular swap units in single map units, part 1  CopyInIrregularA: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- Make as many arrayPointers as needed    pArray: LONG POINTER;    --pRuns: LONG POINTER;    --pSwapUnits: LONG POINTER;    -- whole map unit: irregular swap    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn whole irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- whole unit (irregular), initially dirty    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn whole irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Touch[[0, 10], write];    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- whole unit (irregular), initially dead    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn whole irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial map unit: 1st whole irregular swap unit    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit (irregular), initially dirty    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Touch[[0, 5], write];    CopyIn[interval: [0, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit (irregular), initially dead    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    CopyIn[interval: [0, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial map unit: last whole irregular swap unit    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [6, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    -- partial unit (irregular), end, initially dirty    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Touch[[6, 4], write];    CopyIn[interval: [6, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    -- partial unit (irregular), end, initially dead    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn partial, last irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    CopyIn[interval: [6, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    END;  -- CopyIn tests for irregular swap units in single map units, part 2  CopyInIrregularB: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- Make as many arrayPointers as needed    pArray: LONG POINTER;    --pRuns: LONG POINTER;    --pSwapUnits: LONG POINTER;    -- partial map unit: embedded page, irregular swap unit    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn embedded page of irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [8, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit (irregular), embedded page, initially dirty    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn embedded page of irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Touch[[8, 1], write];    CopyIn[interval: [8, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit (irregular), embedded page, initially dead    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn embedded page of irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    CopyIn[interval: [8, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial map unit: overlap irregular swap units    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [4, 2, 4]];    Map[id: "CopyIn partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [2, 3],      runLength: 3,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit, overlap irregular swap units, initially dirty    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [4, 2, 4]];    Map[id: "CopyIn partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Touch[[2, 3], write];    CopyIn[interval: [2, 3],      runLength: 3,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit, overlap irregular swap units, initially dead    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [4, 2, 4]];    Map[id: "CopyIn partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    CopyIn[interval: [2, 3],      runLength: 3,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial map unit: overlap + include irregular swap units    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [4, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit, overlap + include irregular swap units, initially dirty    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Touch[[4, 5], write];    CopyIn[interval: [4, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    -- partial unit, overlap + include irregular swap units, initially dead    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn partial irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    CopyIn[interval: [4, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    END;  -- CopyIn tests for irregular swap units in single map units, part 3  CopyInIrregularC: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- This contains the tests of parts 1 and 2, but with a single Map/Unmap.      pArray: LONG POINTER;    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn, irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    Touch[[0, 10], write];    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    CopyIn[interval: [0, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Touch[[0, 5], write];    CopyIn[interval: [0, 5],      runLength: 5,      returnWait: wait];    Ticker[];    CopyIn[interval: [6, 4],      runLength: 4,      returnWait: wait];    Ticker[];    Touch[[6, 4], write];    CopyIn[interval: [6, 4],      runLength: 4,      returnWait: wait];    Ticker[];    CopyIn[interval: [8, 1],      runLength: 1,      returnWait: wait];    Ticker[];    Touch[[8, 1], write];    CopyIn[interval: [8, 1],      runLength: 1,      returnWait: wait];    Ticker[];    CopyIn[interval: [2, 3],      runLength: 3,      returnWait: wait];    Ticker[];    Touch[[2, 3], write];    CopyIn[interval: [2, 3],      runLength: 3,      returnWait: wait];    Ticker[];    CopyIn[interval: [4, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Touch[[4, 5], write];    CopyIn[interval: [4, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Tests on dead pages meaningless since CopyIn causes dead -> alive.    END;  -- CopyIn tests over multiple map units  CopyInMultiple: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      -- Make as many arrayPointers as needed    --pArray: LONG POINTER;    --pRuns: LONG POINTER;    --pSwapUnits: LONG POINTER;    -- multiple map units: all of 2    -- multiple map units: all of 1 + some of 2    -- multiple map units: end of 1 + all of 2    -- multiple map units: some of each: whole uniform swap units    -- multiple map units: some of each: whole irregular swap units    -- multiple map units: some of each: overlap uniform    -- multiple map units: some of each: overlap irregular    -- multiple map units: some of each: overlap + include uniform    -- multiple map units: some of each: overlap + include irregular    -- multiple map units: all of 2: different kinds    -- multiple map units: some of each: different kinds    -- multiple map units: some of each + overlap: different kinds    END;  -- CopyIn tests for assorted other conditions not covered by other procs  CopyInOther: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      pArray: LONG POINTER;    pRuns: LONG POINTER;    --pSwapUnits: LONG POINTER;    -- copy overlaps previous copy    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn beginning of uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [4, 4],      runLength: 4,      returnWait: wait];    CopyIn[interval: [7, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- run > interval    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "CopyIn embedded page of irregular swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 1],      runLength: 5,      returnWait: wait];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    END;  -- CopyIn tests for uniform swap units in single map units, part 1  CopyInUniformA: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- Make as many arrayPointers as needed    pRuns: LONG POINTER;    --pSwapUnits: LONG POINTER;    -- whole map unit: uniform swap    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn whole uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [4, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- whole unit (uniform), initially dirty    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn whole uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Touch[[4, 10], write];    CopyIn[interval: [4, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- whole unit (uniform), initially dead    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn whole uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    CopyIn[interval: [4, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: beginning, whole uniform swap units    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn beginning of uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [4, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (uniform), initially dirty    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn beginning of uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Touch[[4, 10], write];    CopyIn[interval: [4, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (uniform), initially dead    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn beginning of uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    CopyIn[interval: [4, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: end, whole uniform swap units    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn end of uniform swap"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [4, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (uniform), end, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn end of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Touch[[0, 4], write];    CopyIn[interval: [6, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (uniform), end, initially dead    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn end of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    CopyIn[interval: [6, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    END;  -- CopyIn tests for uniform swap units in single map units, part 2  CopyInUniformB: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      -- Make as many arrayPointers as needed    pRuns: LONG POINTER;    --pSwapUnits: LONG POINTER;    -- partial map unit: one embedded page, whole uniform swap units    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn embedded page of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [4, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (uniform), one embedded page, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn embedded page of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Touch[[4, 1], write];    CopyIn[interval: [4, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (uniform), one embedded page, initially dead    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn embedded page of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    CopyIn[interval: [4, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: overlap uniform swap units    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn beginning of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [3, 2],      runLength: 2,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit, overlap uniform swap units, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn beginning of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Touch[[3, 2], write];    CopyIn[interval: [3, 2],      runLength: 2,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit, overlap uniform swap units, initially dead    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn beginning of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    CopyIn[interval: [3, 2],      runLength: 2,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: overlap + include uniform swap units    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn beginning of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [3, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit, overlap + include uniform swap units, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn beginning of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Touch[[3, 4], write];    CopyIn[interval: [3, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit, overlap + include uniform swap units, initially dead    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn beginning of uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    CopyIn[interval: [3, 4],      runLength: 4,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    END;  -- CopyIn tests for uniform swap units in single map units, part 3  CopyInUniformC: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- This contains all the tests of parts 1 and 2 but with a single Map/Unmap.    pRuns: LONG POINTER;    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "CopyIn whole uniform swap"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    Touch[[0, 10], write];    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    CopyIn[interval: [0, 4],      runLength: 4,      returnWait: wait];    Ticker[];    Touch[[0, 10], write];    CopyIn[interval: [4, 4],      runLength: 4,      returnWait: wait];    Ticker[];    Touch[[0, 4], write];    CopyIn[interval: [6, 4],      runLength: 4,      returnWait: wait];    Ticker[];    CopyIn[interval: [4, 1],      runLength: 1,      returnWait: wait];    Ticker[];    Touch[[4, 1], write];    CopyIn[interval: [4, 1],      runLength: 1,      returnWait: wait];    Ticker[];    CopyIn[interval: [3, 2],      runLength: 2,      returnWait: wait];    Ticker[];    Touch[[3, 2], write];    CopyIn[interval: [3, 2],      runLength: 2,      returnWait: wait];    Ticker[];    CopyIn[interval: [3, 4],      runLength: 4,      returnWait: wait];    Ticker[];    Touch[[3, 4], write];    CopyIn[interval: [3, 4],      runLength: 4,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pRuns];    -- Tests on dead pages meaningless since CopyIn causes dead -> alive.    END;  -- CopyIn tests for unitary swap units in single map units  CopyInUnitary: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- Make as many arrayPointers as needed    pRuns: LONG POINTER;    --pSwapUnits: LONG POINTER;    -- whole map unit: unitary swap    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyIn whole unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- whole unit (unitary), initially dirty    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyIn whole unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Touch[[0, 10], write];    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- whole unit (unitary), initially dead    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyIn whole unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: swappable];    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: unitary, beginning    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyIn beginning of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (unitary), beginning, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyIn beginning of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Touch[[0, 5], write];    CopyIn[interval: [0, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (unitary), beginning, initially dead    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyIn beginning of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: swappable];    CopyIn[interval: [0, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: unitary, end    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyIn end of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [5, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (unitary), end, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyIn end of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Touch[[5, 5], write];    CopyIn[interval: [5, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (unitary), end, initially dead    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyIn end of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: swappable];    CopyIn[interval: [5, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial map unit: one embedded page    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyIn embedded page of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [3, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (unitary), one embedded page, initially dirty    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyIn embedded page of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Touch[[3, 1], write];    CopyIn[interval: [3, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- partial unit (unitary), one embedded page, initially dead    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyIn embedded page of unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: swappable];    CopyIn[interval: [3, 1],      runLength: 1,      returnWait: wait];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- now all the tests together, one Map/Unmap    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "CopyIn, unitary swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    Touch[[0, 10], write];    CopyIn[interval: [0, 10],      runLength: 10,      returnWait: wait];    Ticker[];    CopyIn[interval: [0, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Touch[[0, 5], write];    CopyIn[interval: [0, 5],      runLength: 5,      returnWait: wait];    Ticker[];    CopyIn[interval: [5, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Touch[[5, 5], write];    CopyIn[interval: [5, 5],      runLength: 5,      returnWait: wait];    Ticker[];    CopyIn[interval: [3, 1],      runLength: 1,      returnWait: wait];    Ticker[];    Touch[[3, 1], write];    CopyIn[interval: [3, 1],      runLength: 1,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pRuns];    END;  ------------  -- PUBLIC SIGNALs and ERRORs: none  ------------  -- Initialization:  ScriptOps.RegisterScript[RunTests, "CopyIn tests"L];  END.LOG29-Nov-82 15:20:50   CAJ    Created file.
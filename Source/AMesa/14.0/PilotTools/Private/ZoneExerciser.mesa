-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- PilotTests>ZoneExerciser.mesa    6-Nov-85 10:43:54 by RSV   DIRECTORY  Command USING [Action, Confirm, InstallTopLevel, RunTopLevel],  Environment USING [wordsPerPage],  File USING [nullFile],  Heap USING [systemZone],  PilotCommand USING [defaultWindow],  Process USING [Detach, MsecToTicks, SetTimeout, TooManyProcesses],  RandomDefs USING [GeneratorState, Random, Randomize],  Runtime USING [GetBcdTime, IsBound],  Space USING [    defaultBase, Interval, Map, PageCount, Unmap],  Tool USING [UnusedLogName],  TTY USING [    Create, GetChar, Handle, OutOfInstances, PutCR, PutDate, PutDecimal,    PutLongDecimal, PutLine, PutString, SetBackingSize],  Zone USING [    AddSegment, Alignment, BlockSize, Base, Create, FreeNode, GetAttributes,    GetSegmentAttributes, Handle, MakeNode, minimumNodeSize, NodeSize,    nullSegment, RemoveSegment, SegmentHandle, SetChecking, SplitNode, Status];ZoneExerciser: MONITOR  IMPORTS    Command, Heap, PilotCommand, Process, RandomDefs, Runtime, Space, Tool, TTY, Zone =  BEGIN  -- This program is designed to test the Pilot Free Storage Package as  -- defined by the interface "Zone."  The testing strategy is to have a  -- set of asynchronous processes randomly create, delete, and split nodes  -- managed by the Free Storage Package, along with other operations.  -- For the purposes of testing, the Common Software Free Storage Package  -- represented by Storage is used (note that this interface is actually  -- implemented using the Pilot Zone interface).  In particular, for each  -- node created via the interface Zone, a record of type "Object" is  -- created to keep track of it.  All Objects are chained together in a  -- circular list pointed to by the variable "objList."  Each node so  -- allocated is filled with a random value (repeated as often as necessary  -- to fill it up) which can be checked regularly to ensure that no  -- clobber has occurred.  -- Several (mostly unrelated) things are protected by the this module's  -- monitor.  The invariants are as follows:  -- 1) currentObjCount= the actual number of nodes on the circular list  --  pointed to by objList.  References to information contained in the nodes  --  of the list, as well as manipulations of the list's structure, is always  --  done from within the monitor.  -- 2) output to the display is always done from within the monitor.  -- 3) numberProcesses=  --  numberCreators+numberDeletors+numberSplittors+numberMiscProcesses.  --  The procedure CheckPause must ONLY be called by procedures for which  --  willPause=TRUE.  -- 4) currentSegmentCount= the number of segmentState entries for which  --  allocated=TRUE.  Accesses to segmentState are done only from within  --  the monitor.  --  Types  Object: TYPE = RECORD [    node: LONG POINTER,    link: OPtr,    size: OSize,    value: CARDINAL,    alignment: Zone.Alignment];      OPtr: TYPE = LONG POINTER TO Object;  OSize: TYPE = CARDINAL [0..maxSize);  NodeError: TYPE = ERROR [obj: OPtr];  Msec: TYPE = CARDINAL;  SegCount: TYPE = CARDINAL [0..maxSegments];  SegIndex: TYPE = CARDINAL [0..maxSegments);  OptionalSegIndex: TYPE = SegIndex [1..maxSegments);  SegmentState: TYPE = RECORD [seg: Zone.SegmentHandle, state: {free, allocated}];  Operation: TYPE = {createNode, deleteNode, splitNode, other};  Percentage: TYPE = CARDINAL [0..100];  ProcessRecord: TYPE = RECORD [    proc: PROCEDURE,    count: LONG POINTER TO CARDINAL,    keepTrying,  -- TRUE means keep retrying FORK until we succeed      willPause: BOOLEAN ¬ FALSE];  -- should Pause wait for this one?  ProcessState: TYPE = {run, pause, stop};  --  Constants  maxSize: Zone.BlockSize = 30;  maxSegments: CARDINAL = 4;  pagesPerSegment: CARDINAL = 1;  segmentSize: Zone.BlockSize = Environment.wordsPerPage*pagesPerSegment;  totalSpace: CARDINAL = maxSegments*segmentSize;  maxWait: Msec = 10000;  waitFactor: Msec = maxWait/totalSpace*2;  maxNumberCreators: CARDINAL = 7;  createWait: Msec = 1000;  maxNumberDeletors: CARDINAL = 7;  deleteWait: Msec = 1000;  maxNumberSplittors: CARDINAL = 5;  splitWait: Msec = 1000;  checkInterval: Msec = 400;  segmentControlInterval: Msec = 1000;  zoneCheckingProbability: Percentage = 50;  --expressed as percentage  alignmentProbability: Percentage = 20;  --expressed as percentage  alignmentTable: ARRAY Zone.Alignment OF [0..16] = [1, 2, 4, 8, 16];  displayInterval: CARDINAL = 40;  --display every n'th report  smpThreshold: CARDINAL = 1000;  -- start the Segment Management Process after this many creates,  -- deletes, and splits  --  Global variables  segmentState: ARRAY SegIndex OF SegmentState ¬ ALL[[Zone.nullSegment, free]];  segmentBase: LONG POINTER;  ttyz: TTY.Handle;  gen: LONG POINTER TO RandomDefs.GeneratorState = RandomDefs.Randomize[1526374859];  objList: OPtr ¬ NIL;  currentSegmentCount: SegCount ¬ 0;  availableSpace: CARDINAL;  displayCount: CARDINAL ¬ 0;  currentNodeCount, currentSpace, objCount: CARDINAL ¬ 0;  allocates, frees, splits, checks: LONG INTEGER ¬ 0;  base: Zone.Base;  -- - 1 to test if non-aligned base values work  zH: Zone.Handle;  threshold: CARDINAL;  numberCreators,  -- number of node creator processes    numberDeletors,  -- number of node deletor processes    numberSplittors,  -- number of node splittor processes    numberMiscProcesses,    -- number of processes not fitting into the above categories    numberProcesses,  -- total of all processes    numberPaused,  -- number of node processes waiting on stateChanged    numberWillPause: CARDINAL ¬ 0;  -- numberCreators + numberDeletors + numberSplittors + (nodeChecker)  control: CONDITION;  zoneChecking: BOOLEAN;  processState: ProcessState ¬ stop;  stateChanged, stateNoticed: CONDITION;  nodeSplittor: ProcessRecord ¬ [    proc: NodeSplittingProcess, count: @numberSplittors, willPause: TRUE];  nodeCreator: ProcessRecord ¬ [    proc: NodeCreatingProcess, count: @numberCreators, willPause: TRUE];  nodeDeletor: ProcessRecord ¬ [    proc: NodeDeletingProcess, count: @numberDeletors, willPause: TRUE];  nodeChecker: ProcessRecord ¬ [    proc: NodeCheckingProcess, count: @numberMiscProcesses, willPause: TRUE];  segmentManager: ProcessRecord ¬ [    proc: SegmentManagementProcess, count: @numberMiscProcesses,    keepTrying: TRUE];  --	Signals  TestDone: SIGNAL = CODE;  ZoneError: ERROR [s: Zone.Status] = CODE;  BadNodeSize: NodeError = CODE;  BadNodeValue: NodeError = CODE;  DeleteError: NodeError = CODE;  SplitError: NodeError = CODE;  MisalignedNode: NodeError = CODE;  SegmentCreateError: ERROR = CODE;  SegmentError: ERROR [seg: Zone.SegmentHandle] = CODE;  --  Procedures  --	Main process of the exerciser  ExerciseZone: Command.Action =    BEGIN    s: Zone.Status;    r: CARDINAL;    smpStarted, forceSMP: BOOLEAN ¬ FALSE;    -- forceSMP is for debugging purposes to forcibly start the    -- segment manager.  smpStarted ensures it is only started once.    WriteStatus: ENTRY PROCEDURE [s: LONG STRING] = INLINE {      DisplayInfo[other]; TTY.PutLine[h, s]};    OkayToStop: ENTRY PROCEDURE RETURNS [BOOLEAN] = INLINE {      RETURN[numberProcesses = 0]};    StartSMP: PROCEDURE = INLINE      BEGIN      OkayToStart: ENTRY PROCEDURE RETURNS [BOOLEAN] = {        RETURN[          (numberCreators = maxNumberCreators            AND numberDeletors = maxNumberDeletors            AND numberSplittors = maxNumberSplittors) OR forceSMP            OR allocates + frees + splits > smpThreshold]};      IF OkayToStart[] THEN {smpStarted ¬ TRUE; New[@segmentManager]};      END;    Command.Confirm[h];    TTY.PutLine[h, "Type any character to halt test."];    allocates ¬ frees ¬ splits ¬ checks ¬ 0;    FOR i: SegIndex IN SegIndex DO      segmentState[i] ¬ [Zone.nullSegment, free] ENDLOOP;    base ¬ segmentBase ¬ GetPages[maxSegments*pagesPerSegment];    zoneChecking ¬ IF Random[100] < zoneCheckingProbability THEN TRUE ELSE FALSE;    [zH, s] ¬ Zone.Create[      storage: segmentBase, length: segmentSize, zoneBase: base,      checking: zoneChecking];    IF s = okay THEN {      segmentState[0].state ¬ allocated;      currentSegmentCount ¬ currentSegmentCount + 1}    ELSE ERROR;    [threshold: threshold, length: availableSpace] ¬ Zone.GetAttributes[zH];    -- get the minimum size of node and total space available    Run[];  -- make sure we set processState to run before we test it in Cycle     Process.Detach[FORK AbortProcess];    -- set up to abort the exerciser when user wants to    -- now fork the working processes    New[@nodeChecker];    WHILE Cycle[] DO      -- First wait a random amount of time which is small if the zone is      -- nearly empty or nearly full and large if the zone is half-full      IF currentSpace < availableSpace/2 THEN        ControlWait[Random[maxWait/availableSpace*currentSpace]]      ELSE        ControlWait[          Random[maxWait/availableSpace*(availableSpace - currentSpace)]];      -- Note that there is no real need to protect references to currentSpace      -- and availableSpace by the monitor since we are only using it as a      -- random number seed here (and not updating it)      r ¬ Random[availableSpace];      IF r > currentSpace THEN {        IF numberCreators < maxNumberCreators THEN New[@nodeCreator]}      ELSE        IF r < 2*currentSpace/3 THEN {          IF numberDeletors < maxNumberDeletors THEN New[@nodeDeletor]}        ELSE IF numberSplittors < maxNumberSplittors THEN New[@nodeSplittor];      IF ~smpStarted THEN StartSMP[ ! Process.TooManyProcesses => CONTINUE];      ENDLOOP;    WriteStatus["Winding up zone exerciser"];    WHILE ~OkayToStop[] DO ControlWait[1000] ENDLOOP;    --delay to give processes a chance to wind down    WaitForSegsClear[];  -- allow creators, deleters, splitters, checker to stop    WriteStatus["All Processes terminated"];    FOR i: SegIndex IN SegIndex DO      IF segmentState[i].state = allocated THEN        BEGIN        DeleteNodesInSegment[segmentBase + i*segmentSize];        -- delete the nodes of this segment        IF i # 0 THEN  -- seg 0 is special          {          [s: s] ¬ Zone.RemoveSegment[zH, segmentState[i].seg];          IF s # okay THEN ERROR SegmentError[segmentState[i].seg]};        DecrementSegmentCounts[i];        END;      ENDLOOP;    FreePages[segmentBase];  --free the zone storage    TTY.PutLine[h, "ZoneExercise Terminated; storage freed."];    END;  --ExerciseZone  -- Object list management  AddObject: INTERNAL PROCEDURE [obj: OPtr] = INLINE    BEGIN    IF objList = NIL THEN objList ¬ obj.link ¬ obj  --create new circular list    ELSE  --add object to circular list      BEGIN      obj.link ¬ objList.link;      obj.link ¬ objList.link;      objList.link ¬ obj      END;    objCount ¬ objCount + 1;    END;  --AddObject  DeleteNodesInSegment: PROCEDURE [segment: LONG POINTER] =    -- Deletes all nodes in a given segment.    BEGIN    o: OPtr;    s: Zone.Status;    UpdateCounts: ENTRY PROCEDURE = INLINE      BEGIN      frees ¬ frees + 1;      currentNodeCount ¬ currentNodeCount - 1;      currentSpace ¬ currentSpace - o.size;      DisplayInfo[deleteNode];      END;    -- main body    WHILE (o ¬ DeleteObject[segment]) # NIL DO      IF (s ¬ Zone.FreeNode[zH, o.node]) # okay THEN ERROR DeleteError[o];      UpdateCounts[];      Heap.systemZone.FREE[@o];      ENDLOOP;    END;  --DeleteNodesInSegment  DeleteObject: ENTRY PROCEDURE [segment: LONG POINTER] RETURNS [obj: OPtr] =    -- This procedure manages the data structures to delete a node    BEGIN    IF objList = NIL THEN RETURN[NIL]    ELSE      IF segment # NIL THEN        THROUGH [0..objCount) DO          --delete only nodes from this segment          n: LONG ORDERED POINTER = LOOPHOLE[objList.link.node];          s: LONG ORDERED POINTER = LOOPHOLE[segment];          IF n >= s AND n < s + segmentSize THEN EXIT            --this node is in the segment and so can be deleted          ELSE objList ¬ objList.link;  --try the next node          REPEAT FINISHED => RETURN[NIL];          ENDLOOP      ELSE        THROUGH [0..RandomDefs.Random[gen, objCount]) DO          objList ¬ objList.link;  --move objList forward around circular list          ENDLOOP;    obj ¬ RemoveObjHead[];    CheckNode[obj];  --	Check the node to see that it is still well-formed    END;  --DeleteObject  RemoveObjHead: INTERNAL PROCEDURE RETURNS [obj: OPtr] = INLINE    BEGIN    IF objCount = 0 OR objList = NIL THEN ERROR;    obj ¬ objList.link;    objList.link ¬ obj.link;    IF objList = obj THEN objList ¬ NIL;  -- set to NIL if list is now empty    objCount ¬ objCount - 1;    END;  -- Process management  CheckPause: INTERNAL PROCEDURE =    -- see if we should pause; if so, wait for processState to change again    BEGIN    numberPaused ¬ numberPaused + 1;    BROADCAST stateNoticed;    WHILE processState = pause DO WAIT stateChanged ENDLOOP;    numberPaused ¬ numberPaused - 1;    END;  Cycle: ENTRY PROCEDURE RETURNS [run: BOOLEAN] = {RETURN[processState # stop]};  CycleOrPause: ENTRY PROCEDURE RETURNS [run: BOOLEAN] = {    CheckPause[]; RETURN[processState # stop]};  New: PROCEDURE [process: LONG POINTER TO ProcessRecord] = {    Process.Detach[      FORK RunProcess[      process !      Process.TooManyProcesses =>        IF process.keepTrying THEN {Wait[1000]; RETRY} ELSE CONTINUE]]};  Pause: ENTRY PROCEDURE RETURNS [run: BOOLEAN] =    -- tell willPause processes to stop temporarily, then wait for them to do so    BEGIN    IF processState = stop THEN RETURN[FALSE];    processState ¬ pause;    BROADCAST stateChanged;    WHILE numberPaused < numberWillPause DO WAIT stateNoticed ENDLOOP;    RETURN[TRUE];    END;  Run: ENTRY PROCEDURE =    -- let willPause processes to continue    {processState ¬ run; BROADCAST stateChanged};  RunProcess: PROCEDURE [p: LONG POINTER TO ProcessRecord] =    BEGIN    IncrementCounts: ENTRY PROCEDURE = {      p.count­ ¬ p.count­ + 1;      numberProcesses ¬ numberProcesses + 1;      IF p.willPause THEN numberWillPause ¬ numberWillPause + 1};    DecrementCounts: ENTRY PROCEDURE = {      p.count­ ¬ p.count­ - 1;      numberProcesses ¬ numberProcesses - 1;      IF p.willPause THEN numberWillPause ¬ numberWillPause - 1;      BROADCAST stateNoticed;      NOTIFY control};  -- poke main process    IncrementCounts[];    p.proc[];    DecrementCounts[];    END;  Stop: ENTRY PROCEDURE =    BEGIN  -- stop ALL processes (not just willPause processes)    processState ¬ stop;    BROADCAST stateChanged;    WHILE numberCreators + numberDeletors + numberSplittors + numberMiscProcesses      > 0 DO WAIT stateNoticed ENDLOOP;    END;  Resume: ENTRY PROCEDURE = {    IF processState = pause THEN processState ¬ run; BROADCAST stateChanged};  WaitForSegsClear: ENTRY PROCEDURE = {    WHILE numberWillPause > 0 DO WAIT stateChanged ENDLOOP};  -- Utility procedures  CheckNode: INTERNAL PROCEDURE [obj: OPtr] =    -- This procedure checks the size, value, and alignment of a node and    -- raises an error if necessary.    BEGIN    s: CARDINAL = Zone.NodeSize[obj.node];    t: CARDINAL = MAX[obj.size, Zone.minimumNodeSize - 1];    -- round up the size to the minimum allocated by the Zone    nodeBody: LONG DESCRIPTOR FOR ARRAY OF CARDINAL;    IF s < t OR s > t + threshold THEN ERROR BadNodeSize[obj];    -- Check that the Zone and the model agree on node size    nodeBody ¬ DESCRIPTOR[obj.node, obj.size];    FOR i: CARDINAL IN [0..obj.size) DO  -- check that data for this node is ok      IF nodeBody[i] # obj.value THEN ERROR BadNodeValue[obj]; ENDLOOP;    IF LOOPHOLE[obj.node, LONG CARDINAL] MOD alignmentTable[obj.alignment] # 0 THEN      ERROR MisalignedNode[obj];    END;  --CheckNode  ControlWait: ENTRY PROCEDURE [time: Msec] =    -- Return to the caller after waiting for the specified amount of time.    {Process.SetTimeout[@control, Process.MsecToTicks[time]]; WAIT control};  DecrementSegmentCounts: ENTRY PROCEDURE [i: SegIndex] = INLINE    BEGIN    segmentState[i] ¬ [seg: Zone.nullSegment, state: free];    availableSpace ¬ availableSpace - segmentSize;    currentSegmentCount ¬ currentSegmentCount - 1;    DisplayInfo[other];    END;  --	DecrementSegmentCounts  DisplayInfo: INTERNAL PROCEDURE [op: Operation] =    -- This procedure prints out the state of the world every time it changes.    BEGIN    IF displayCount > displayInterval OR op = other THEN      BEGIN      displayCount ¬ 0;      TTY.PutString[ttyz, "C: "];      TTY.PutDecimal[ttyz, numberCreators];      TTY.PutString[ttyz, ";  S: "];      TTY.PutDecimal[ttyz, numberSplittors];      TTY.PutString[ttyz, ";  D: "];      TTY.PutDecimal[ttyz, numberDeletors];      TTY.PutString[ttyz, ";  Alloc: "];      TTY.PutLongDecimal[ttyz, allocates];      TTY.PutString[ttyz, ";  Free: "];      TTY.PutLongDecimal[ttyz, frees];      TTY.PutString[ttyz, ";  Split: "];      TTY.PutLongDecimal[ttyz, splits];      TTY.PutString[ttyz, ";  Nodes: "];      TTY.PutDecimal[ttyz, currentNodeCount];      TTY.PutString[ttyz, ";  Space: "];      TTY.PutDecimal[ttyz, currentSpace];      TTY.PutString[ttyz, "/"];      TTY.PutDecimal[ttyz, availableSpace];      TTY.PutString[ttyz, "("];      TTY.PutDecimal[ttyz, currentSegmentCount];      TTY.PutLine[ttyz, ")"];      END    ELSE displayCount ¬ displayCount + 1;    END;  --DisplayInfo  Random: ENTRY PROCEDURE [key: CARDINAL] RETURNS [CARDINAL] =    -- This procedure protects the random number generator from clobber    -- as a result of more than one process accessing it at the same time.    INLINE {RETURN[RandomDefs.Random[gen, key]]};  Wait: ENTRY PROCEDURE [time: Msec] =    -- Wait for the specified amount of time.    BEGIN    c: CONDITION;    Process.SetTimeout[@c, Process.MsecToTicks[time]];    WAIT c;  -- Wait for time    END;  --Wait  WaitExponential: PROCEDURE [mean: Msec] =    -- This procedure causes the calling process to wait a random amount of    -- time which has an approximate exponential distribution.  In particular,    -- a random number is generated, and its log2 is calculated (by counting    -- the number of leading zero bits).  The "mean" of this distribution is    -- taken from the argument and determines the amount of waiting.    BEGIN    i: CARDINAL ¬ Random[LAST[CARDINAL]];    j: CARDINAL;    time: Msec;    FOR j DECREASING IN [16..1] WHILE i > 0 DO      i ¬ i/2; REPEAT FINISHED => time ¬ mean*j/2; ENDLOOP;    Wait[time];  --Wait for time = log2 mean (approximately)    END;  --WaitExponential  --  Processes  AbortProcess: PROCEDURE = {[] ¬ TTY.GetChar[ttyz]; Stop[]};  NodeCheckingProcess: PROCEDURE =    BEGIN    CheckObject: ENTRY PROCEDURE =      -- Check object pointed to by objList, step objList forward by one object      INLINE      BEGIN      IF objList = NIL THEN RETURN;      CheckNode[objList];  --	Check that node is still well-formed      objList ¬ objList.link;      checks ¬ checks + 1;      END;  --CheckObject    WHILE CycleOrPause[] DO      CheckObject[];  --Check one object      WaitExponential[checkInterval];      ENDLOOP;    END;  --NodeCheckingProcess  NodeDeletingProcess: PROCEDURE =    -- Deletes nodes at random intervals after first checking the size and    -- consistency of the value stored in the node.  Note that the calls upon    -- the Zone are outside the monitor, in order to test the robustness of the    -- Zone machinery in the face of multiple processes.  The node selected for    -- deletion is found by stepping forward through the circular list pointed    -- to by objList a random number of nodes, then deleting that one.    BEGIN    o: OPtr;    s: Zone.Status;    UpdateCounts: ENTRY PROCEDURE = INLINE      BEGIN      frees ¬ frees + 1;      currentNodeCount ¬ currentNodeCount - 1;      currentSpace ¬ currentSpace - o.size;      DisplayInfo[deleteNode];      END;    WHILE CycleOrPause[] DO      Wait[Random[deleteWait]];      IF (o ¬ DeleteObject[NIL]) # NIL THEN        BEGIN        IF (s ¬ Zone.FreeNode[zH, o.node]) # okay THEN ERROR DeleteError[o];        UpdateCounts[];        Heap.systemZone.FREE[@o];        END      ELSE EXIT  -- Terminate the process if there are no more nodes to delete      ENDLOOP;    END;  --NodeDeletingProcess  NodeCreatingProcess: PROCEDURE =    -- Creates nodes at random intervals of a random size and stores random    -- values in their bodies (the same random value in each word of a node).    -- Can create a node of size zero.  Note that the calls upon the Zone are    -- outside the monitor, in order to test the robustness of the Zone    -- machinery in the face of multiple processes.  Nodes are linked onto the    -- circular list pointed to by objList.    BEGIN    s: Zone.Status;    r: Zone.Base RELATIVE POINTER;    size: OSize;    a: Percentage = Random[LAST[Percentage]];    align: Zone.Alignment;    CreateObj: ENTRY PROCEDURE [      node: LONG POINTER, size: OSize, value: CARDINAL, alignment: Zone.Alignment] =      -- This procedure keeps track of the newly created node      BEGIN      obj: OPtr;      nodeBody: LONG DESCRIPTOR FOR ARRAY OF CARDINAL;      obj ¬ Heap.systemZone.NEW[Object ¬[        node: node, size: size, value: value, link: NIL, alignment: alignment]];      nodeBody ¬ DESCRIPTOR[node, size];      FOR i: CARDINAL IN [0..size) DO nodeBody[i] ¬ value ENDLOOP;      --store the argument "value" in each word of the node      AddObject[obj];      allocates ¬ allocates + 1;      currentNodeCount ¬ currentNodeCount + 1;      currentSpace ¬ currentSpace + size;      DisplayInfo[createNode];      END;  --CreateObj    --	main body of NodeCreatingProcess    WHILE CycleOrPause[] DO      align ¬        IF a > alignmentProbability THEN a1        ELSE LOOPHOLE[a MOD 5, Zone.Alignment];      size ¬ Random[maxSize];      Wait[Random[createWait]];      IF a > alignmentProbability THEN [r, s] ¬ Zone.MakeNode[zH, size]      ELSE [r, s] ¬ Zone.MakeNode[zH, size, align];      IF s = okay THEN        CreateObj[          node: @base[r], size: size, value: Random[LAST[CARDINAL]],          alignment: align]      ELSE IF s # noRoomInZone THEN ERROR ZoneError[s] ELSE EXIT      -- Terminate the process if unable to create more nodes      ENDLOOP;    END;  --NodeCreatingProcess  NodeSplittingProcess: PROCEDURE =    -- This process splits nodes into two, randomly-sized smaller pieces.    -- It operates in much the same way as the NodeDeletingProcess.    BEGIN    o: OPtr;    s: Zone.Status;    newSize, difference: OSize;    RemoveObject: ENTRY PROCEDURE RETURNS [obj: OPtr] =      -- This procedure manages the data structures to delete a node      BEGIN      IF objList = NIL THEN RETURN[NIL]      ELSE        THROUGH [0..RandomDefs.Random[gen, objCount]) DO          objList ¬ objList.link;  --move objList forward around circular list          ENDLOOP;      obj ¬ RemoveObjHead[];      CheckNode[obj];  --	Check the node to see that it is still well-formed      END;  --RemoveObject    InsertObject: ENTRY PROCEDURE [obj: OPtr, sizeDifference: OSize] =      -- Reinserts the object into the circular list and updates the counts      BEGIN      AddObject[obj];      splits ¬ splits + 1;      currentSpace ¬ currentSpace - sizeDifference;      DisplayInfo[splitNode];      END;  --InsertObject    -- Begin the main body of the NodeSplittingProcess    WHILE CycleOrPause[] DO      Wait[Random[splitWait]];      IF (o ¬ RemoveObject[]) # NIL THEN        BEGIN        newSize ¬ Random[o.size];        IF (s ¬ Zone.SplitNode[zH, o.node, newSize]) # okay THEN          ERROR SplitError[o];        difference ¬ o.size - newSize;        o.size ¬ newSize;        InsertObject[o, difference];        END      ELSE EXIT  -- Terminate the process if there are no more nodes to split      ENDLOOP;    END;  --NodeSplittingProcess  SegmentManagementProcess: PROCEDURE =    BEGIN    sH: Zone.SegmentHandle;    s: Zone.Status;    r: SegCount;    -- holds a random number for determining whether to create or delete a segment    IncrementSegmentCounts: ENTRY PROCEDURE [      i: OptionalSegIndex, sH: Zone.SegmentHandle] = INLINE      BEGIN      segmentState[i] ¬ [seg: sH, state: allocated];      currentSegmentCount ¬ currentSegmentCount + 1;      availableSpace ¬ availableSpace + segmentSize;      DisplayInfo[other];      END;  --	IncrementSegmentCounts    WHILE Cycle[] DO      WaitExponential[maxWait];      r ¬ (Random[LAST[SegCount] - 1] + 1);  -- r IN [1..LAST[SegCount]]      IF r >= currentSegmentCount THEN        BEGIN  --create a new segment        FOR i: OptionalSegIndex IN OptionalSegIndex DO          IF segmentState[i].state = free THEN GOTO allocate;          REPEAT            allocate =>              BEGIN              sH: Zone.SegmentHandle;              s: Zone.Status;              [sH: sH, s: s] ¬ Zone.AddSegment[                zH: zH, storage: segmentBase + i*segmentSize,                length: segmentSize];              IF s # okay THEN ERROR SegmentCreateError;              IncrementSegmentCounts[i, sH];              END;            FINISHED => ERROR;          ENDLOOP;        END      ELSE        BEGIN  --delete a segment        j: OptionalSegIndex;        IF ~Pause[] THEN EXIT;  -- quiesce working processes        sH ¬ Zone.GetAttributes[zH].next;        THROUGH [1..r) DO          --find the r'th segment          IF sH = Zone.nullSegment THEN ERROR SegmentError[sH]          ELSE sH ¬ Zone.GetSegmentAttributes[zH, sH].next;          ENDLOOP;        FOR j IN OptionalSegIndex DO          IF segmentState[j].seg = sH THEN EXIT;          -- j now points to the correct entry of segmentState          REPEAT FINISHED => ERROR;          ENDLOOP;        DO  --now attempt to delete segment sH          [s: s] ¬ Zone.RemoveSegment[zH, sH];          IF s = okay THEN EXIT          ELSE IF s # nonEmptySegment THEN ERROR SegmentError[sH];          DeleteNodesInSegment[segmentBase + j*segmentSize];          -- delete the nodes of this segment          ENDLOOP;        DecrementSegmentCounts[j];        Resume[];  -- let working processes continue        END;      zoneChecking ¬        IF Random[100] > zoneCheckingProbability THEN FALSE ELSE TRUE;      [] ¬ Zone.SetChecking[zH, zoneChecking];      ENDLOOP;    END;  --SegmentManagementProcess  GetPages: PROCEDURE [n: Space.PageCount] RETURNS [LONG POINTER] = {    RETURN[Space.Map[      [File.nullFile, Space.defaultBase, n]].mapUnit.pointer] };  FreePages: PROCEDURE [p: LONG POINTER] = {    [] ¬ Space.Unmap[p]};  RunOurTopLevel: PROCEDURE = {Command.RunTopLevel[ttyz]};  -- Initialize the exerciser and register it as a command in the test package  Init: PROC =    BEGIN    logName: STRING ¬ [40];    IF Runtime.IsBound[LOOPHOLE[Tool.UnusedLogName]] THEN      Tool.UnusedLogName[unused: logName, root: "ZoneExerciser.log"L]    ELSE logName ¬ "ZoneExerciser.log"L;    ttyz ¬ TTY.Create[logName      ! TTY.OutOfInstances => {ttyz ¬ PilotCommand.defaultWindow; CONTINUE}];    TTY.SetBackingSize[h: ttyz, size: 20000];    IF ttyz = PilotCommand.defaultWindow THEN      Command.InstallTopLevel[ttyz, ["exercise zones", ExerciseZone]]    ELSE      BEGIN      Command.InstallTopLevel[ttyz, ["run", ExerciseZone]];      TTY.PutString[ttyz, "Zone Exerciser of "L];      TTY.PutDate[ttyz, Runtime.GetBcdTime[]];      TTY.PutCR[ttyz];      Process.Detach[FORK RunOurTopLevel[]];      END;    END;  Init[];  END.LOGApril 5, 1979  9:59 PM   HXL     Created fileJune 2, 1979  10:23 PM   HXL     renamed file from "FSPTest" to "ZoneExerciser"; converted it to be  part of TestPackage; added test for allocating aligned nodesJuly 19, 1979  4:15 PM   HXL     Removed reference to ZoneExtensionNovember 8, 1979  3:36 PM   RXG      No longer disables typescript, fixed bug in process countsJanuary 15, 1980  8:25 PM   RXG      Removed references to SystemDefsAugust 18, 1980  3:21 PM   SXY      IODefs and Command are replaced by TTY and TTYCommand respectivelySeptember 3, 1980  2:08 PM   SXY      Added its own windowSeptember 9, 1980  5:52 PM   SXY      TTYCommand is replaced by new Command. Now the window is created at  initializationSeptember 12, 1980  9:36 PM   SXY      Added a catch phrase to TTY.Create. Output message is changed from  Zone Exercises to Zone ExerciserDecember 16, 1980  7:02 PM   RXG      Fix bug that causes ZE to hang in an infinite loop (and take the  rest of the system with it!).29-Jul-81 20:15:40   CRF   Moved "Run[]" from AbortProcess to ExerciseZone to fix race  condition that allowed ZE to test processState before it was set to "run",  thereby terminating ZE right away.  Also set typescript size to 20000.8-Sep-81 14:33:05   SXY      Use TTY.SetBackingSize instead of TajoUtility.SetTypescriptSize, segmentBase  & OPtr & gen are LONGified.23-Sep-81  9:21:45   WDK       Stop shortening long pointers!30-Nov-81 14:08:31   CAJ    Replaced ANY in TTY.Create, generate log name using Tool.UnusedLogName, created Init proc.26-Jan-82 11:50:07   CAJ    Single window command name changed to 'exercise zones' to avoid conflict with 'exercise zone recreate'.17-Mar-82 10:15:26   FXH       added IsBound test to Tool.UnusedLogName25-Jan-83 15:59:52   RXJ        Removed Storage.31-Jan-83 10:21:01   EKN   	Update To Klamath (GetPages, FreePages effected)12-Apr-83 16:32:12   JXP   	Name of Space.Map result changed to mapUnit. 2-May-83 10:13:44   EKN        Fix bug in DeletNodesInSegment where 'o' is dereferenced after the node was freed up.17-Aug-83 14:57:15   JXP        Convert to 11.0b. 6-Nov-85 10:44:03   RSV        Changed hardwire of date to Runtime.GetBcdTime (AR 4714)
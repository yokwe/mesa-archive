-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Script8.mesa       31-Jan-83 17:12:02 by CAJ -- Virtual memory test program, Klamath Pilot.-- Script8 tests CopyIn over multiple map units.DIRECTORY  Environment USING [PageCount],  ScriptOps USING [RegisterScript],  VM USING [Interval],  VMTestOperations --USING [all the operations]--,  VMTestScript USING [GetHeap, GiveBackHeap, MakeBackingData,    MakeIrregularSwapData, MakeUniformSwapData, MakeUnitarySwapData, Ticker];Script8: PROGRAM  IMPORTS ScriptOps, VMTestOperations, VMTestScript =  BEGIN  ------------  -- PUBLIC procedures:  -- RunTests is a script of tests using procedures from VMTestOperations (for  -- VM operations) and VMTestScript (for test utilities).  RunTests: PROCEDURE =    BEGIN OPEN VMTestOperations, VMTestScript;        heap: UNCOUNTED ZONE ¬ GetHeap[];    CopyInLikeA[heap];    CopyInLikeB[heap];    CopyInUnlikeA[heap];    CopyInUnlikeB[heap];    heap ¬ GiveBackHeap[heap];    END;  -- CopyIn tests over multiple like map units, unitary and uniform  CopyInLikeA: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      pRunsA: LONG POINTER;    pRunsB: LONG POINTER;    -- Unitary    -- 2 unitary, all of both    pRunsA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pRunsB ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsB, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 20],      runLength: 20,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pRunsA];    Unmap[page: 10];    heap.FREE[@pRunsB];    Ticker[];    -- 2 unitary, end of A + all of B    pRunsA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pRunsB ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsB, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [7, 13],      runLength: 13,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pRunsA];    Unmap[page: 10];    heap.FREE[@pRunsB];    Ticker[];    -- 2 unitary, all of A + beginning of B    pRunsA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pRunsB ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsB, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 14],      runLength: 14,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pRunsA];    Unmap[page: 10];    heap.FREE[@pRunsB];    Ticker[];    -- 2 unitary, end of A + beginning of B    pRunsA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pRunsB ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsB, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [9, 2],      runLength: 2,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pRunsA];    Unmap[page: 10];    heap.FREE[@pRunsB];    Ticker[];    -- now all 4 previous copies in single Map/Unmap    pRunsA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pRunsB ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsB, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 20],      runLength: 20,      returnWait: wait];    Ticker[];    CopyIn[interval: [7, 13],      runLength: 13,      returnWait: wait];    Ticker[];    CopyIn[interval: [0, 14],      runLength: 14,      returnWait: wait];    Ticker[];    CopyIn[interval: [9, 2],      runLength: 2,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pRunsA];    Unmap[page: 10];    heap.FREE[@pRunsB];    -- Uniform    -- 2 uniform, all of both    pRunsA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pRunsB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 19],      runLength: 19,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pRunsA];    Unmap[page: 10];    heap.FREE[@pRunsB];    Ticker[];    -- 2 uniform, end of A + all of B, whole swap units    pRunsA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pRunsB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [4, 15],      runLength: 15,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pRunsA];    Unmap[page: 10];    heap.FREE[@pRunsB];    Ticker[];    -- 2 uniform, all of A + beginning of B, whole swap units    pRunsA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pRunsB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 13],      runLength: 13,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pRunsA];    Unmap[page: 10];    heap.FREE[@pRunsB];    Ticker[];    -- 2 uniform, end of A + beginning of B, whole swap units    pRunsA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pRunsB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [6, 7],      runLength: 7,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pRunsA];    Unmap[page: 10];    heap.FREE[@pRunsB];    Ticker[];    -- 2 uniform, end of A + all of B, partial swap units    pRunsA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pRunsB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [7, 12],      runLength: 12,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pRunsA];    Unmap[page: 10];    heap.FREE[@pRunsB];    Ticker[];    -- 2 uniform, all of A + end of B, partial swap units    pRunsA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pRunsB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 11],      runLength: 11,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pRunsA];    Unmap[page: 10];    heap.FREE[@pRunsB];    Ticker[];    -- 2 uniform, end of A + beginning of B, partial swap units    pRunsA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pRunsB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [7, 5],      runLength: 5,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pRunsA];    Unmap[page: 10];    heap.FREE[@pRunsB];    Ticker[];    -- now all of previous 6 copies within single Map/Unmap    pRunsA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pRunsB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRunsB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 19],      runLength: 19,      returnWait: wait];    Ticker[];    CopyIn[interval: [4, 15],      runLength: 15,      returnWait: wait];    Ticker[];    CopyIn[interval: [0, 13],      runLength: 13,      returnWait: wait];    Ticker[];    CopyIn[interval: [6, 7],      runLength: 7,      returnWait: wait];    Ticker[];    CopyIn[interval: [7, 12],      runLength: 12,      returnWait: wait];    Ticker[];    CopyIn[interval: [0, 11],      runLength: 11,      returnWait: wait];    Ticker[];    CopyIn[interval: [7, 5],      runLength: 5,      returnWait: wait];    Ticker[];    -- and same 6 again with (all) dirty pages    Touch[[0, 19], write];    CopyIn[interval: [0, 19],      runLength: 19,      returnWait: wait];    Ticker[];    Touch[[4, 15], write];    CopyIn[interval: [4, 15],      runLength: 15,      returnWait: wait];    Ticker[];    Touch[[0, 13], write];    CopyIn[interval: [0, 13],      runLength: 13,      returnWait: wait];    Ticker[];    Touch[[6, 7], write];    CopyIn[interval: [6, 7],      runLength: 7,      returnWait: wait];    Ticker[];    Touch[[7, 12], write];    CopyIn[interval: [7, 12],      runLength: 12,      returnWait: wait];    Ticker[];    Touch[[0, 11], write];    CopyIn[interval: [0, 11],      runLength: 11,      returnWait: wait];    Ticker[];    Touch[[7, 5], write];    CopyIn[interval: [7, 5],      runLength: 5,      returnWait: wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pRunsA];    Unmap[page: 10];    heap.FREE[@pRunsB];    END;  -- CopyIn tests over multiple map units, irregular  CopyInLikeB: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      pArrayA: LONG POINTER;    pArrayB: LONG POINTER;    -- Irregular    -- 2 irregular, all of both    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 5, 1, 13]];    Map[id: "Irregular A"L,      interval: [0, 21],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 1]];    Map[id: "Irregular B"L,      interval: [21, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 25],      runLength: 25,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 21];    heap.FREE[@pArrayB];    Ticker[];    -- 2 irregular, end of A + all of B, whole swap units    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 5, 1, 13]];    Map[id: "Irregular A"L,      interval: [0, 21],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 1]];    Map[id: "Irregular B"L,      interval: [21, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [7, 18],      runLength: 18,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 21];    heap.FREE[@pArrayB];    Ticker[];    -- 2 irregular, all of A + beginning of B, whole swap units    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 5, 1, 13]];    Map[id: "Irregular A"L,      interval: [0, 21],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 1]];    Map[id: "Irregular B"L,      interval: [21, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 24],      runLength: 24,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 21];    heap.FREE[@pArrayB];    Ticker[];    -- 2 irregular, end of A + beginning of B, whole swap units    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 5, 1, 13]];    Map[id: "Irregular A"L,      interval: [0, 21],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 1]];    Map[id: "Irregular B"L,      interval: [21, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [7, 17],      runLength: 17,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 21];    heap.FREE[@pArrayB];    Ticker[];    -- 2 irregular, end of A + all of B, partial swap units    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 5, 1, 13]];    Map[id: "Irregular A"L,      interval: [0, 21],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 1]];    Map[id: "Irregular B"L,      interval: [21, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [10, 15],      runLength: 15,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 21];    heap.FREE[@pArrayB];    Ticker[];    -- 2 irregular, all of A + beginning of B, partial swap units    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 5, 1, 13]];    Map[id: "Irregular A"L,      interval: [0, 21],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 1]];    Map[id: "Irregular B"L,      interval: [21, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 22],      runLength: 22,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 21];    heap.FREE[@pArrayB];    Ticker[];    -- 2 irregular, end of A + beginning of B, partial swap units    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 5, 1, 13]];    Map[id: "Irregular A"L,      interval: [0, 21],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 1]];    Map[id: "Irregular B"L,      interval: [21, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [10, 12],      runLength: 12,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 21];    heap.FREE[@pArrayB];    Ticker[];    -- now all of previous 6 copies within single Map/Unmap    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 5, 1, 13]];    Map[id: "Irregular A"L,      interval: [0, 21],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 1]];    Map[id: "Irregular B"L,      interval: [21, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 25],      runLength: 25,      returnWait: wait];    Ticker[];    CopyIn[interval: [7, 18],      runLength: 18,      returnWait: wait];    Ticker[];    CopyIn[interval: [0, 24],      runLength: 24,      returnWait: wait];    Ticker[];    CopyIn[interval: [7, 17],      runLength: 17,      returnWait: wait];    Ticker[];    CopyIn[interval: [10, 15],      runLength: 15,      returnWait: wait];    Ticker[];    CopyIn[interval: [0, 22],      runLength: 22,      returnWait: wait];    Ticker[];    CopyIn[interval: [10, 12],      runLength: 12,      returnWait: wait];    -- and same 6 again with (all) dirty pages    Touch[[0, 25], write];    CopyIn[interval: [0, 25],      runLength: 25,      returnWait: wait];    Ticker[];    Touch[[7, 18], write];    CopyIn[interval: [7, 18],      runLength: 18,      returnWait: wait];    Ticker[];    Touch[[0, 24], write];    CopyIn[interval: [0, 24],      runLength: 24,      returnWait: wait];    Ticker[];    Touch[[7, 17], write];    CopyIn[interval: [7, 17],      runLength: 17,      returnWait: wait];    Ticker[];    Touch[[10, 15], write];    CopyIn[interval: [10, 15],      runLength: 15,      returnWait: wait];    Ticker[];    Touch[[0, 22], write];    CopyIn[interval: [0, 22],      runLength: 22,      returnWait: wait];    Ticker[];    Touch[[10, 12], write];    CopyIn[interval: [10, 12],      runLength: 12,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 21];    heap.FREE[@pArrayB];    END;   -- CopyIn tests over multiple unlike map units, part 1  CopyInUnlikeA: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      pArrayA: LONG POINTER;    pArrayB: LONG POINTER;    -- This set of tests does not do all possible combinations.    -- unitary + uniform: all of both    pArrayA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 19],      runLength: 19,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- same as previous, with runs not corresponding to swap units    pArrayA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2,6,1]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 19],      runLength: 19,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- unitary + uniform: end of unitary + whole swap units of uniform    pArrayA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [4, 9],      runLength: 9,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- same as previous, with runs not corresponding to swap units    pArrayA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2,6,1]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [4, 9],      runLength: 9,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- unitary + uniform: end of unitary + partial swap unit of uniform    pArrayA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [4, 8],      runLength: 8,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- same as previous, with runs not corresponding to swap units    pArrayA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2,6,1]];    Map[id: "Uniform B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [4, 8],      runLength: 8,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- uniform + unitary: all of both    pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 20],      runLength: 20,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- uniform + unitary: end of unitary + whole swap units of uniform    pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [5, 9],      runLength: 9,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- uniform + unitary: end of unitary + partial swap unit of uniform    pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary B"L,      interval: [10, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [5, 10],      runLength: 10,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- unitary + irregular: all of both    pArrayA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3, 1, 11]];    Map[id: "Irregular B"L,      interval: [10, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 25],      runLength: 25,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- unitary + irregular: end of unitary + whole swap units of irregular    pArrayA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3, 1, 11]];    Map[id: "Irregular B"L,      interval: [10, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [5, 9],      runLength: 9,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- unitary + irregular: end of unitary + partial swap unit of irregular    pArrayA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "Unitary A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3, 1, 11]];    Map[id: "Irregular B"L,      interval: [10, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [5, 12],      runLength: 12,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- irregular + uniform: all of both    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 5, 1, 11]];    Map[id: "Irregular A"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 2, 2]];    Map[id: "Uniform B"L,      interval: [19, 6],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 25],      runLength: 25,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 19];    heap.FREE[@pArrayB];    Ticker[];    -- irregular + uniform: whole swap units from each    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 5, 1, 11]];    Map[id: "Irregular A"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 2, 2]];    Map[id: "Uniform B"L,      interval: [19, 6],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [7, 16],      runLength: 16,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 19];    heap.FREE[@pArrayB];    Ticker[];    -- irregular + uniform: partial swap units from each    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 5, 1, 11]];    Map[id: "Irregular A"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 2, 2]];    Map[id: "Uniform B"L,      interval: [19, 6],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [4, 18],      runLength: 18,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 19];    heap.FREE[@pArrayB];    Ticker[];    -- uniform + irregular: all of both    pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [9, 1, 5]];    Map[id: "Irregular B"L,      interval: [10, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 25],      runLength: 25,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- uniform + irregular: whole swap units from each    pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [9, 1, 5]];    Map[id: "Irregular B"L,      interval: [10, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [8, 11],      runLength: 11,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    -- uniform + irregular: partial swap units from each    pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [9, 1, 5]];    Map[id: "Irregular B"L,      interval: [10, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [1, 23],      runLength: 23,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Ticker[];    END;   -- CopyIn tests over multiple map units, part 2  CopyInUnlikeB: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;      -- Make as many arrayPointers as needed    pArrayA: LONG POINTER;    pArrayB: LONG POINTER;    pArrayC: LONG POINTER;    --pSwapUnits: LONG POINTER;    -- unitary - uniform - irregular: whole swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [4]];    Map[id: "Unitary A"L,      interval: [0, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2,2,2]];    Map[id: "Uniform B"L,      interval: [4, 6],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 12]];    Map[id: "Irregular C"L,      interval: [10, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayC, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [0, 13],      runLength: 13,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 4];    heap.FREE[@pArrayB];    Unmap[page: 10];    heap.FREE[@pArrayC];    Ticker[];    -- unitary - uniform - irregular: partial swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [4]];    Map[id: "Unitary A"L,      interval: [0, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2,2,2]];    Map[id: "Uniform B"L,      interval: [4, 6],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 12]];    Map[id: "Irregular C"L,      interval: [10, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayC, 3]],      life: alive,      swappability: swappable];    CopyIn[interval: [1, 22],      runLength: 22,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 4];    heap.FREE[@pArrayB];    Unmap[page: 10];    heap.FREE[@pArrayC];    Ticker[];    -- irregular - unitary - uniform: whole swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 4, 1, 8]];    Map[id: "Irregular A"L,      interval: [0, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [4]];    Map[id: "Unitary B"L,      interval: [15, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2,2,2]];    Map[id: "Uniform C"L,      interval: [19, 6],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [6, 17],      runLength: 17,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 15];    heap.FREE[@pArrayB];    Unmap[page: 19];    heap.FREE[@pArrayC];    Ticker[];    -- irregular - unitary - uniform: partial swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [2, 4, 1, 8]];    Map[id: "Irregular A"L,      interval: [0, 15],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [4]];    Map[id: "Unitary B"L,      interval: [15, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2,2,2]];    Map[id: "Uniform C"L,      interval: [19, 6],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    CopyIn[interval: [3, 21],      runLength: 21,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 15];    heap.FREE[@pArrayB];    Unmap[page: 19];    heap.FREE[@pArrayC];    Ticker[];    -- uniform - irregular - unitary: partial swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "Uniform A"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 6]];    Map[id: "Irregular B"L,      interval: [10, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [6]];    Map[id: "Unitary C"L,      interval: [19, 6],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    CopyIn[interval: [3, 21],      runLength: 21,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 10];    heap.FREE[@pArrayB];    Unmap[page: 19];    heap.FREE[@pArrayC];    Ticker[];    -- irregular - irregular - uniform: whole swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [1, 3, 1, 7]];    Map[id: "Irregular A"L,      interval: [0, 12],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 1]];    Map[id: "Irregular B"L,      interval: [12, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform C"L,      interval: [16, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [4, 18],      runLength: 18,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 12];    heap.FREE[@pArrayB];    Unmap[page: 16];    heap.FREE[@pArrayC];    Ticker[];    -- irregular - irregular - uniform: partial swap units on each end    pArrayA ¬ heap.NEW[ARRAY[0..4) OF WORD ¬ [1, 3, 1, 7]];    Map[id: "Irregular A"L,      interval: [0, 12],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayA, 4]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayA, 4]],      life: alive,      swappability: swappable];    pArrayB ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [2, 1, 1]];    Map[id: "Irregular B"L,      interval: [12, 4],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayB, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArrayB, 3]],      life: alive,      swappability: swappable];    pArrayC ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [3,3,3]];    Map[id: "Uniform C"L,      interval: [16, 9],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArrayC, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[3],      life: alive,      swappability: swappable];    CopyIn[interval: [2, 18],      runLength: 18,      returnWait: wait];    Unmap[page: 0];    heap.FREE[@pArrayA];    Unmap[page: 12];    heap.FREE[@pArrayB];    Unmap[page: 16];    heap.FREE[@pArrayC];    Ticker[];    END;  ------------  -- PUBLIC SIGNALs and ERRORs: none  ------------  -- Initialization:  ScriptOps.RegisterScript[RunTests, "CopyIn multiple"L];  END.LOG29-Nov-82 16:12:05   CAJ    Created file.
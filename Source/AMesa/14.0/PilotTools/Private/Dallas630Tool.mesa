-- Copyright (C) 1983, 1987  by Xerox Corporation. All rights reserved. -- File: Dallas630Tool.mesa - last edit by RSV     27-Mar-87 14:28:10-- The tool will exercise the modified 630 printer that will be the -- 	Star printerDIRECTORY  Ascii USING [CR, SP, TAB],  FormSW USING [AllocateItemDescriptor, BooleanItem, ClientItemsProcType,     CommandItem, Enumerated, EnumeratedItem, line0, line1, line2, ProcType,    sameLine],  Heap USING [systemZone],  Inline USING [LowByte, HighByte],  MsgSW USING[PostAndLog],  Process USING [    Detach, MsecToTicks, Pause, priorityForeground, SetPriority],  Put USING [Char, Decimal, Line, Text, LongDecimal],  Runtime USING [IsBound],  Selection USING [Source, Convert, Target],  String USING [AppendString],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],  Tool USING [    Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  TTYPort USING [    ChannelHandle, Create, Delete, Get, GetStatus,    NoTTYPortHardware, Put, SetParameter, TransferStatus],  Window USING [Handle];Dallas630Tool: MONITOR  IMPORTS    FormSW, Heap, Inline, Process, MsgSW, Put, Runtime, Selection, String,    System, Tool, TTYPort =  BEGIN OPEN PutDefs: Put;  FontRec: TYPE = RECORD [hammer: Hammer, width: Width, spoke: Spoke];  Spoke:   TYPE = [0..95];  Width:   TYPE = [0..8];  Hammer:  TYPE = [0..4];  X:       TYPE=INTEGER;  -- units are in 1/120"  Y:       TYPE=INTEGER;  -- units are in 1/48"  DeviceStatusIndex: TYPE = MACHINE DEPENDENT {    printerReady, carriageCheck, printWheelCheck, endOfRibbon,    outOfPaper,   lidOpen,       operatorStop,    apfOption};  DeviceStatus:      TYPE = PACKED ARRAY DeviceStatusIndex OF BOOLEAN;  interCharacterSpacing: X = 6;  lineHeight:            Y = 8;  rightMargin:           X = 960; -- 8 inches  leftMargin:            X = 60;  -- .5 inches  tabAmount:             X = 90;  -- 8 12pt character widths  Font: TYPE = MACHINE DEPENDENT {    MetalTen(0), MetalTwelve, MetalPS, PlasticTen, PlasticTwelve,    PlasticPS, (177777B)};      z: UNCOUNTED ZONE = Heap.systemZone;  Problem:  SIGNAL [s: STRING] = CODE;  DoTiming: SIGNAL RETURNS [doTiming: BOOLEAN] = CODE;  fontRec:  SIGNAL [c: CHARACTER] RETURNS [FontRec] = CODE;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Tool interface section  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    msgSW:    Window.Handle ¬ NIL,    fileSW:   Window.Handle ¬ NIL,    formSW:   Window.Handle ¬ NIL,    font:     Font          ¬ PlasticPS,    doTiming: BOOLEAN       ¬ FALSE];      toolData: DataHandle ¬ NIL;  wh:       Window.Handle;    -- Tool needed routines  -- This procedure is called whenever the system determines that this  -- Tool's state is undergoing a user invoked transition.  -- In this Example we demonstrate a technique that minimizes the memory  -- requirements for a Tool that is inactive.  ClientTransition: ToolWindow.TransitionProcType =    BEGIN          IF new=tiny OR new=inactive THEN {AbortCommand[]; Close[]};    SELECT TRUE FROM      old = inactive =>	IF toolData = NIL THEN {toolData ¬ z.NEW[Data];	toolData­ ¬ Data[]};      new = inactive =>	IF toolData # NIL THEN z.FREE[@toolData];      ENDCASE;    END;      ToolInit: PROC = {    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "Dallas 630 Tool 8.0"L]};      MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    overprint:      CARDINAL = 0;    typeSelection:  CARDINAL = overprint+1;    daisyAlignment: CARDINAL = typeSelection+1;    speed:          CARDINAL = daisyAlignment+1;    diagnose:       CARDINAL = speed+1;    font :          CARDINAL = diagnose+1;    doTiming:       CARDINAL = font+1;    abort:          CARDINAL = doTiming+1;    nItems:         CARDINAL = abort+1;        e1: ARRAY [0..6) OF Enumerated ¬ [      ["Metal 10"L,   Font[MetalTen]],      ["Metal 12"L,   Font[MetalTwelve]],      ["Metal PS"L,   Font[MetalPS]],      ["Plastic 10"L, Font[PlasticTen]],      ["Plastic 12"L, Font[PlasticTwelve]],      ["Plastic PS"L, Font[PlasticPS]]];    items ¬ AllocateItemDescriptor[nItems];    items[overprint] ¬ CommandItem[      tag: "Overprint Test"L, place: [0, line0], proc: OverprintCommand];    items[typeSelection] ¬ CommandItem[      tag: "Type Selection"L, place: [130, sameLine],      proc: TypeSelectionCommand];    items[daisyAlignment] ¬ CommandItem[      tag: "Daisy Alignment Test"L, place: [230, sameLine],      proc: DaisyAlignmentCommand];    items[speed] ¬ CommandItem[      tag: "Speed Test"L, place: [0, line1], proc: SpeedCommand];    items[diagnose] ¬ CommandItem[      tag: "Diagnose"L, place: [130, sameLine], proc: DiagnoseCommand];    items[font] ¬ EnumeratedItem[       tag: "Font"L,  place: [0, line2], feedback: one,      value: @toolData.font,  choices: DESCRIPTOR[e1]];    items[doTiming] ¬ BooleanItem[      tag: "Do Timing"L, place: [130, sameLine], switch: @toolData.doTiming];    items[abort] ¬ CommandItem[      tag: "Abort Printing"L, place: [230, sameLine], proc: AbortToolCommand];    RETURN[items: items, freeDesc: TRUE];    END;      MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "Dallas630Tool.log"L];    toolData.msgSW  ¬ Tool.MakeMsgSW[window: window, lines: 5];    toolData.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    toolData.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Command processing  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  OverprintCommand: FormSW.ProcType = {    LineMsg["The OverprintCommand Procedure has been called."L];    ProcessACommand[OverprintTest]};  TypeSelectionCommand: FormSW.ProcType = {    LineMsg["The TypeSelectionCommand Procedure has been called."L];    ProcessACommand[TypeSelection]};  DaisyAlignmentCommand: FormSW.ProcType = {    LineMsg["The DaisyAlignmentCommand Procedure has been called."L];    ProcessACommand[DaisyAlignmentTest]};  SpeedCommand: FormSW.ProcType = {    LineMsg["The SpeedCommand Procedure has been called."L];    ProcessACommand[SpeedTest]};  DiagnoseCommand: FormSW.ProcType = {    LineMsg["The DiagnoseCommand Procedure has been called."L];    ProcessACommand[DiagnoseTest]};  ProcessACommand: PROC [commandProc: PROC] =    BEGIN    IF PrintingInProgress[] THEN  {      LineErrMsg["action currently underway"L]; RETURN};    PortInit[! Problem => {LineErrMsg[s]; GOTO return}];    Interpet[GetPrinterStatus[] ! Problem => {LineErrMsg[s]; GOTO return}];    SetPrintingInProgress[];    putCount ¬ 0;    Process.Detach[FORK ProcessCommand[commandProc]];    EXITS return => NULL END;	  ProcessCommand: PROC [commandProc: PROC] =    BEGIN    msg:            BOOLEAN ¬ TRUE;    timingThisTest: BOOLEAN = toolData.doTiming;    font:           PROC [c: CHARACTER] RETURNS [FontRec] =      (SELECT toolData.font FROM         MetalTen =>      MetalTen,      MetalTwelve  => MetalTwelve,	MetalPS =>       MetalPS,       PlasticTen => PlasticTen,	PlasticTwelve => PlasticTwelve, PlasticPS => PlasticPS,	ENDCASE =>       ERROR);    commandProc[    ! Problem =>  {LineErrMsg[s]; msg ¬ FALSE; CONTINUE};      DoTiming => RESUME[timingThisTest];      fontRec =>  RESUME[font[c]]];    ClearPrintingInProgress[];    IF msg THEN LineMsg["Ready for next command"L];    END;    DiagnoseTest: PROC = {    diagnosticAnswer: CARDINAL = Diagnose[];    SELECT diagnosticAnswer FROM       0 => Problem["Carriage/Printwheel ROM (8041) check sum error"L];      1 => Problem["8085 ROM check sum error"L];      2 => Problem["8085 RAM check sum error"L];      3 => Problem["Error in enabling/disabling carriage servo"L];      4 => Problem["Error in restoring printer"L];      5 => Problem["Error in stepping printer from spoke zero to spoke 96"L];      6 => Problem["Error in stepping printer from spoke 96 to spoke zero"L];      7 => Problem["Error in firing hammer with energy level 1 to 4"L];      8 => Problem["Error in firing hammer with energy level 4 to 1"L];      9 => Problem["Error in lifting and dropping ribbon"L];     10 => Problem["Error in moving ribbon"L];     11 => Problem["Error in moving carriage"L];     11 => Problem["Error in moving platten"L];     12 => Problem["Error in printing"L];    192 => NULL;    ENDCASE => Problem["Unknown error"L]};  OverprintTest: PROC =    BEGIN    IF DoTiming[] THEN      Problem["Timing calaculations can't be done during overprint"L];    BeginPage[];    PrintString["The quick brown fox jumps over the lazy dog (once)"L];    BeginPage[];    THROUGH [0..2) DO      PrintString["The quick brown fox jumps over the lazy dog (up and back)"L];      NewLine[]; MoveY[-lineHeight] ENDLOOP;    THROUGH [0..2) DO      MoveY[48]; CarriageReturn[];      PrintString["The quick brown fox jumps over the lazy dog (up twice)"L];      MoveY[-48] ENDLOOP;    BeginPage[]; BeginPage[];    THROUGH [0..2) DO      CarriageReturn[]; PrintString["The quick brown fox jumps over the lazy dog"L];      NewLine[]; PrintString["Pack my box with five dozen liquor jugs"L];      NewLine[]; PrintString["Waltz nymph for quick jigs vex Bud (short x)"L];      MoveY[-lineHeight]; MoveY[-lineHeight]      ENDLOOP;    MoveY[lineHeight]; MoveY[lineHeight]; BeginPage[];    THROUGH [0..2)  DO      MoveY[48]; CarriageReturn[]; PrintString["The quick brown fox jumps over the lazy dog"L];      NewLine[]; PrintString["Pack my box with five dozen liquor jugs"L];      NewLine[]; PrintString["Waltz nymph for quick jigs vex Bud (short x)"L];      MoveY[-lineHeight]; MoveY[-lineHeight]; MoveY[-48] ENDLOOP;    MoveY[48]; MoveY[48];    END;      TypeSelection: PROC =    BEGIN    string: STRING = [130];    source: Selection.Source;        BeginPage[];    source ¬ Selection.Convert[source]; --get selection ready    DO      source.proc[source.data, string]; --get a string      IF string.length=0 THEN EXIT;      PrintString[string ! UNWIND => source.destroy[source]];      ENDLOOP;    source.destroy[source];    EndPage[];    END;  DaisyAlignmentTest: PROC =    BEGIN    string: STRING=    "!H""H#H$H%H&H'H(H)H*H+H,H-H.H/H0H1H2H3H4H5H6H7H8H9H:H;H<H=H>H?H@HAHBHCHEHFHGHHHIHJHKHLHMHNHOHPHQHRHSHTHUHVHWHXHYHZH[H\\H]H­H¬HaHbHcHdHeHfHgHhHiHjHkHlHmHnHoHpHqHrHsHtHuHvHwHxHyHzH{H|H}H~H"L;    BeginPage[]; PrintString[string];    NewLine[]; NewLine[]; PrintString[string];    NewLine[]; NewLine[]; PrintString[string];    NewLine[]; NewLine[]; EndPage[];    END;  SpeedTest: PROC =    BEGIN    string: STRING =      "The head and in frontal attack on an english writer that the character of this point is therefore another method for.  The letters that the time of who ever told the problem for an unexpected the head and in frontal attack on.  An english writer that the character of this point is therefore another method for the letters that the time of who.  Ever told the problem for an unexpected the head and in frontal attack on an english writer that the character of.  This point is therefore another method for the letters that the time of who ever told the problem for an unexpected."L;    BeginPage[]; PrintString[string]; EndPage[];    END;      AbortToolCommand: FormSW.ProcType = {    LineMsg["The AbortCommand Procedure has been called."L];    AbortCommand[]; LineMsg["Command aborted, ready for next command"L]};      Interpet: PROC [deviceStatus: DeviceStatus] =    BEGIN    msg: STRING = [(16+5)*8];    goodStatusNoApf:   DeviceStatus = [      printerReady: TRUE,  carriageCheck: FALSE, printWheelCheck: FALSE,      endOfRibbon:  FALSE, outOfPaper:    FALSE, lidOpen: FALSE,       operatorStop: FALSE, apfOption:     FALSE];    goodStatusApf:     DeviceStatus = [      printerReady: TRUE,  carriageCheck: FALSE, printWheelCheck: FALSE,      endOfRibbon:  FALSE, outOfPaper:    FALSE, lidOpen: FALSE,      operatorStop: FALSE, apfOption:     TRUE];          subMsg: ARRAY DeviceStatusIndex OF STRING = [	" ready="L,          ", carriage check="L, ", daisy check="L,	", ribbon end="L,    ", paper out="L,      ", lid open="L,	", operator stop="L, ", apf option="L];    IF deviceStatus = goodStatusNoApf OR deviceStatus = goodStatusApf THEN RETURN;    msg.length ¬ 0;    FOR i: DeviceStatusIndex IN [printerReady..apfOption] DO       String.AppendString[msg, subMsg[i]];      String.AppendString[msg, IF deviceStatus[i] THEN "TRUE"L ELSE "FALSE"L];      ENDLOOP;    Problem[msg];    END;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- DaisyWheel code  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~MetalTen: PROC [c: CHARACTER] RETURNS [f: FontRec] = {  f ¬ MetalPS[c]; f.width ¬ 6};  MetalTwelve: PROC [c: CHARACTER] RETURNS [f: FontRec] = {  f ¬ MetalPS[c]; f.width ¬ 5};   MetalPS: PROC [c: CHARACTER] RETURNS [FontRec] =   BEGIN  metalPS: ARRAY CHARACTER [40C..200C) OF FontRec = [  --040C--[0, 7,  1], [2, 3, 59], [2, 4, 63], [4, 6,  4],  --044C--[4, 5, 89], [4, 8, 17], [4, 7, 19], [1, 2, 73],  --050C--[2, 3, 20], [2, 3, 22], [3, 5, 81], [2, 5, 85],  --054C--[1, 3, 55], [1, 4, 61], [1, 3, 57], [2, 4, 65],  --060C--[4, 5, 10], [2, 5, 14], [3, 5, 13], [3, 5, 12],  --064C--[3, 5, 11], [3, 5,  9], [3, 5,  8], [3, 5,  7],  --070C--[4, 5,  6], [3, 5,  5], [2, 3, 67], [2, 3, 69],  --074C--[2, 3, 20], [2, 5, 87], [2, 3, 22], [2, 5, 79],  --100C--[4, 8, 21], [4, 7, 78], [4, 6, 88], [3, 7, 60],  --104C--[4, 7, 64], [4, 6, 80], [4, 6, 74], [4, 7, 56],  --110C--[4, 7, 70], [3, 3, 71], [3, 5, 75], [4, 7, 50],  --114C--[3, 6, 76], [4, 8, 58], [4, 7, 72], [4, 7, 66],  --120C--[4, 6, 86], [4, 7, 44], [4, 7, 68], [4, 5, 82],  --124C--[3, 6, 77], [4, 7, 62], [4, 6, 84], [4, 8, 54],  --130C--[4, 7, 46], [4, 7, 52], [3, 6, 90], [1, 1,  0],  --134C--[1, 1,  0], [1, 1,  0], [1, 1,  0], [1, 1,  0],  --140C--[1, 2, 73], [3, 5, 37], [3, 5, 28], [3, 5, 34],  --144C--[3, 5, 36], [3, 5, 38], [3, 4, 51], [4, 5, 31],  --150C--[3, 5, 35], [2, 3, 49], [3, 3, 47], [3, 5, 27],  --154C--[2, 3, 53], [4, 8, 48], [3, 5, 39], [3, 5, 40],  --160C--[4, 5, 29], [4, 5, 24], [2, 4, 41], [3, 4, 45],  --164C--[3, 4, 43], [3, 5, 33], [3, 5, 32], [3, 7, 42],  --170C--[3, 5, 26], [3, 5, 30], [3, 5, 25], [2, 3, 20],  --174C--[1, 1,  0], [2, 3, 22], [1, 1,  0], [1, 1,  0]];  RETURN[metalPS[c]];  END;  PlasticTen: PROC [c: CHARACTER] RETURNS [f: FontRec] = {  f ¬ PlasticPS[c]; f.width ¬ 6};  PlasticTwelve: PROC [c: CHARACTER] RETURNS [f: FontRec] = {  f ¬ PlasticPS[c]; f.width ¬ 5};   PlasticPS: PROC [c: CHARACTER] RETURNS [FontRec] =   BEGIN  plastic96: ARRAY CHARACTER [40C..200C) OF FontRec = [  --040C--[3, 5, 94], [2, 3, 28], [2, 4, 26], [3, 5, 50],  --044C--[4, 5, 52], [3, 5, 49], [3, 6, 27], [1, 2, 42],  --050C--[2, 3, 36], [2, 3, 38], [3, 4, 35], [2, 5, 51],  --054C--[1, 3, 93], [1, 5, 53], [1, 3, 91], [2, 4, 30],  --060C--[3, 5, 59], [2, 5, 63], [3, 5, 62], [2, 5, 61],  --064C--[3, 5, 60], [3, 5, 58], [3, 5, 57], [2, 5, 56],  --070C--[3, 5, 55], [3, 5, 54], [1, 3, 84], [2, 3, 65],  --074C--[2, 5, 39], [3, 5, 48], [2, 5, 46], [2, 5, 31],  --100C--[4, 7, 34], [3, 6, 85], [4, 5, 88], [3, 6, 86],  --104C--[4, 6, 74], [4, 5, 81], [4, 5, 87], [4, 6, 72],  --110C--[4, 6, 79], [2, 3, 76], [3, 4, 67], [4, 6, 68],  --114C--[4, 5, 75], [4, 7, 90], [4, 6, 77], [3, 6, 78],  --120C--[4, 5, 70], [4, 6, 69], [4, 6, 83], [3, 5, 82],  --124C--[3, 5, 80], [4, 6, 73], [4, 6, 66], [4, 7, 92],  --130C--[4, 6, 64], [4, 6, 71], [3, 5, 89], [2, 4, 43],  --134C--[2, 4, 33], [2, 4, 45], [1, 5, 32], [2, 6, 41],  --140C--[1, 5, 40], [2, 5, 12], [4, 5, 18], [2, 5, 17],  --144C--[3, 5, 20], [2, 5, 13], [3, 4,  7], [4, 5, 22],  --150C--[3, 5,  9], [2, 3, 11], [3, 2, 24], [3, 5,  3],  --154C--[2, 3, 19], [4, 7, 25], [3, 5, 14], [3, 5, 16],  --160C--[4, 5,  6], [4, 5,  4], [2, 4, 15], [3, 4,  8],  --164C--[2, 4, 10], [3, 5,  5], [2, 5, 23], [3, 7,  0],  --170C--[3, 5, 21], [4, 5,  2], [3, 5,  1], [2, 3, 47],  --174C--[2, 2, 37], [2, 3, 29], [1, 5, 44], [1, 4, 95]];  RETURN[plastic96[c]];  END;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Printing code  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- definitions to drive printer  CommandByte: TYPE = MACHINE DEPENDENT RECORD [    diagnostic7:           BOOLEAN ¬ FALSE,    printerIdentification: BOOLEAN ¬ FALSE,    paperFeedOrApf:        BOOLEAN ¬ FALSE,    carriageMotion:        BOOLEAN ¬ FALSE,    print:                 BOOLEAN ¬ FALSE,    restoreCarriage:       BOOLEAN ¬ FALSE,    restorePrintWheel:     BOOLEAN ¬ FALSE,    requestStatus:         BOOLEAN ¬ FALSE];  PaperFeedData: TYPE = MACHINE DEPENDENT RECORD [    direction (0:0..0):  {down, up},    zero (0:1..4):       [0..15) ¬ 0,    magnitude (0:5..15): CARDINAL [0..2048)];  CarriageMotionData: TYPE = MACHINE DEPENDENT RECORD [    direction (0:0..0):  {right, left},    unused (0:1..4):     [0..15) ¬ 0,    magnitude (0:5..15): CARDINAL [0..2048)];  PrintData: TYPE = MACHINE DEPENDENT RECORD [    liftRibbon (0:0..0):    BOOLEAN ¬ TRUE,    hammerEnergy (0:1..3):  CARDINAL [0..4],    ribbonAdvance (0:4..7): CARDINAL [0..8],    unused (0:8..8):        [0..2) ¬ 0,    spokeNumber (0:9..15):  CARDINAL [0..96)];  ApfData: TYPE = MACHINE DEPENDENT {    (0), closeBail(10000B), paperFeed(20000B), restore(60000B),    statusRequest(70000B)};  currentPosition: X ¬ 0;  beginPulses:     System.Pulses;  characterCount:  CARDINAL;  numberOfLines:   CARDINAL;  totalRate:       LONG CARDINAL;    --used to calculate cps average / <numberOfLines> lines  nullData:        MACHINE DEPENDENT RECORD [UNSPECIFIED] = [0B];  MoveX: PROC [x: X] =    BEGIN    IF x=0 THEN RETURN;  --no movement    IF currentPosition + x < 0 THEN {Problem["X position Error"L]; RETURN};     IF currentPosition + x > rightMargin THEN {NewLine[]; RETURN};    currentPosition ¬ currentPosition + x;    Put[      [carriageMotion: TRUE],      CarriageMotionData[        direction: IF x < 0 THEN left ELSE right, magnitude: ABS[x]]];    END;  MoveY: PROC [y: Y] = {    IF y#0 THEN Put[      [paperFeedOrApf: TRUE],      PaperFeedData[direction: IF y < 0 THEN up ELSE down, magnitude: ABS[y]]]};  Strike: PROC [f: FontRec] = {    Put[      [print: TRUE],      PrintData[        liftRibbon: TRUE, hammerEnergy: f.hammer, ribbonAdvance: f.width,	spokeNumber: f.spoke]]};  FeedApf: PROC = {Put[[paperFeedOrApf: TRUE], ApfData[paperFeed]]};  CloseBail: PROC = {Put[[paperFeedOrApf: TRUE], ApfData[closeBail]]};  Reset: PROC = {Put[[restorePrintWheel: TRUE, restoreCarriage: TRUE]]};  BeginPage: PROC =    BEGIN    Put[[restoreCarriage: TRUE]];    currentPosition ¬ 0; MoveY[48]; CarriageReturn[];    --we are now at column 0 down 1", left margin    characterCount ¬ 0; numberOfLines ¬ 0; totalRate ¬ 0;    beginPulses ¬ System.GetClockPulses[];    END;      CarriageReturn: PROC = INLINE {MoveX[leftMargin - currentPosition]};  PrintString: PROC [string: STRING] =    BEGIN    spaceWidth: X = fontRec['o].width + interCharacterSpacing;      --the width of a blank is the same as of a letter 'oh'    FOR stringIndex: CARDINAL IN [0..string.length) DO      c: CHARACTER = string[stringIndex];      SELECT c FROM        IN ['! .. '~] => {          characterCount ¬ characterCount + 1;          Strike[fontRec[c]]; MoveX[fontRec[c].width + interCharacterSpacing]};        = Ascii.SP =>          IF currentPosition#leftMargin THEN {            characterCount ¬ characterCount+1; MoveX[spaceWidth]};        = Ascii.CR => NewLine[];        = Ascii.TAB =>          IF currentPosition MOD tabAmount # 0 THEN            MoveX[(((currentPosition/tabAmount)+1)*tabAmount)-currentPosition];        ENDCASE => NULL;      ENDLOOP;    END;       EndPage: PROC =    BEGIN    NewLine[]; MoveY[48];  -- move to the left margin then down 1"    IF numberOfLines # 0 THEN      PutEndPageTimings[numberOfLines, totalRate/numberOfLines];    END;      -- print speed is calculated using the measurement method specified  -- in section 12.2 of Xerox drawing number 82P80523, rev A  -- Drawing title:  "Design Specification - 860 IPS/630 Printer"  NewLine: PROC = {    IF characterCount#0 THEN {      time: LONG CARDINAL        = System.PulsesToMicroseconds[[System.GetClockPulses[] - beginPulses]];      rate: LONG CARDINAL = (LONG[characterCount]*10000000)/time;      totalRate ¬ totalRate + rate; numberOfLines ¬ numberOfLines + 1;      PutLastLineRateInfo[time, rate, characterCount]};    CarriageReturn[]; MoveY[lineHeight];    Interpet[GetPrinterStatus[]]; putCount ¬ 0;    characterCount ¬ 0; beginPulses ¬ System.GetClockPulses[]};  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- TTY Port interface code  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  channel:  TTYPort.ChannelHandle ¬ NIL;  putCount: CARDINAL;  --PortInit will set up the port, if needed.  It will reset the printer  -- (by sending a break) and request printer status.    PortInit: PROC =    BEGIN    IF ~Runtime.IsBound[LOOPHOLE[TTYPort.Create]]       THEN Problem["TTYPort is not bound"L];    IF channel = NIL THEN {      channel ¬ TTYPort.Create[0      ! TTYPort.NoTTYPortHardware => Problem["No TTY Hardware present"L]];      Process.Pause[Process.MsecToTicks[500]]; SetChannel[]; StartGet[]};    IF ~TTYPort.GetStatus[channel].stat.dataTerminalReady THEN       Problem["printer must be turned on"L];    SendABreak[]; Reset[]    END;  Put: PROC [    commandByte: CommandByte, data: UNSPECIFIED ¬ nullData] = {    PutByte[commandByte, data];    IF ShouldStopPrinting[] THEN SIGNAL Problem["Abort Requested"L];    IF putCount=10 THEN {Interpet[GetPrinterStatus[]]; putCount ¬ 0}    ELSE putCount ¬ putCount + 1};      PutByte: PROC [    commandByte: CommandByte, data: UNSPECIFIED ¬ nullData] = {    [] ¬ TTYPort.Put[channel, LOOPHOLE[commandByte]];    [] ¬ TTYPort.Put[channel, LOOPHOLE[Inline.LowByte[data]]];    [] ¬ TTYPort.Put[channel, LOOPHOLE[Inline.HighByte[data]]]};  SetChannel: PROC = {      TTYPort.SetParameter[channel, [characterLength [lengthIs8bits]]];    TTYPort.SetParameter[channel, [parity [odd]]];    TTYPort.SetParameter[channel, [lineSpeed[bps2400]]];    TTYPort.SetParameter[channel, [stopBits [one]]];    TTYPort.SetParameter[channel, [clearToSend[TRUE]]];    TTYPort.SetParameter[channel, [dataSetReady [TRUE]]]};      SendABreak: PROC=    BEGIN    TTYPort.SetParameter[channel, [parity [even]]];    TTYPort.SetParameter[channel, [lineSpeed[bps50]]];    [] ¬ TTYPort.Put[channel, 0C];    Process.Pause[Process.MsecToTicks[180]];  --wait till char done    SetChannel[];  --back to normal    END;  Close: PROC= {    IF channel # NIL THEN {AbortGet[]; TTYPort.Delete[channel]; channel¬ NIL}};      -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- starting/stopping/aborting  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  printState:       {idle, busy, stopRequested} ¬ idle;  abortCommandWait: CONDITION;  AbortCommand: ENTRY PROC = {    IF printState=busy THEN {      PutDefs.Text[toolData.msgSW, "Aborting ... "L];      printState ¬ stopRequested;      WHILE printState=stopRequested DO WAIT abortCommandWait ENDLOOP}};      PrintingInProgress: ENTRY PROC RETURNS [BOOLEAN] = INLINE {    RETURN[printState#idle]};    SetPrintingInProgress: ENTRY PROC = INLINE {printState ¬ busy};      ClearPrintingInProgress: ENTRY PROC = {    abortAbort: BOOLEAN = (printState = stopRequested);    printState ¬ idle; IF abortAbort THEN NOTIFY abortCommandWait};      ShouldStopPrinting: ENTRY PROC RETURNS [BOOLEAN] = INLINE {    RETURN[printState=stopRequested]};      -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- recieve character process  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  getIsActive:   BOOLEAN ¬ FALSE; --if the Get process is active or not  continueGet:   BOOLEAN ¬ TRUE;  --if it is okay for the Get process to run  getDying:      CONDITION;  gottenByte:    UNSPECIFIED;  gottenDSState: {waiting, full} ¬ full;  gottenDSWait:  CONDITION;  AbortGet: ENTRY PROC = {    continueGet ¬ FALSE;    WHILE getIsActive DO WAIT getDying ENDLOOP;    continueGet ¬ TRUE};  StartGet: ENTRY PROC = {    IF ~getIsActive THEN {      Process.Detach[FORK Get[]];      WHILE ~getIsActive DO Process.Pause[Process.MsecToTicks[250]] ENDLOOP}};  Diagnose:ENTRY PROC RETURNS [answer: CARDINAL] = {    PutByte[[diagnostic7: TRUE]]; gottenDSState ¬ waiting;    WHILE gottenDSState=waiting DO WAIT gottenDSWait ENDLOOP;    answer ¬ gottenByte};  GetPrinterStatus: ENTRY PROC RETURNS [status: DeviceStatus] = {    PutByte[[requestStatus: TRUE]]; gottenDSState ¬ waiting;    WHILE gottenDSState=waiting DO WAIT gottenDSWait ENDLOOP;    status ¬ gottenByte};  XferByte: ENTRY PROC [c: UNSPECIFIED] = INLINE {    IF gottenDSState=waiting THEN {      gottenByte ¬ c; gottenDSState ¬ full; NOTIFY gottenDSWait}};  Get: PROC =    BEGIN    ByeBye: ENTRY PROC = INLINE {getIsActive ¬ FALSE; NOTIFY getDying};    getIsActive ¬ TRUE;     Process.SetPriority[Process.priorityForeground];    WHILE continueGet DO      statusChar: CHARACTER; status: TTYPort.TransferStatus;      [data: statusChar, status: status] ¬ TTYPort.Get[channel];      IF status#success THEN EXIT;      XferByte[statusChar];      ENDLOOP;    ByeBye[];    END;    	    	  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  --The following procedures are in the locked section of the Monitor  --This prevents the problem of two processes trying to send  --messages at the same time  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    LineErrMsg: ENTRY PROC [string: STRING] = {    IF toolData# NIL THEN MsgSW.PostAndLog[      sw: toolData.msgSW, string: string, severity: fatal,      logSW: toolData.fileSW]};  LineMsg: ENTRY PROC [string: STRING] = {    IF toolData# NIL THEN PutDefs.Line[toolData.msgSW, string]};  StringMsg: ENTRY PROC [string: STRING] = {    IF toolData# NIL THEN PutDefs.Text[toolData.msgSW, string]};       PutLineFileSW: ENTRY PROC [string: STRING] = {    IF toolData# NIL THEN PutDefs.Line[toolData.fileSW, string]};       PutStringFileSW: ENTRY PROC [string: STRING] = {    IF toolData# NIL THEN PutDefs.Text[toolData.fileSW, string]};       PutLongDecimalFileSW: ENTRY PROC [number: LONG INTEGER] = {    IF toolData# NIL THEN PutDefs.LongDecimal[toolData.fileSW, number]};  PutEndPageTimings: ENTRY PROC [    numberOfLines: CARDINAL, ratePerLine: LONG CARDINAL] = {    IF ~DoTiming[] THEN RETURN;    PutDefs.Text[toolData.fileSW, "Average rate over last "L];    PutDefs.Decimal[toolData.fileSW, numberOfLines];    PutDefs.Text[toolData.fileSW, " lines = "L];    PutDefs.LongDecimal[toolData.fileSW, ratePerLine/10];    PutDefs.Char[toolData.fileSW, '.];    PutDefs.LongDecimal[toolData.fileSW, ratePerLine MOD 10];    PutDefs.Line[toolData.fileSW, " cps"]};      PutLastLineRateInfo: ENTRY PROC [    time, rate: LONG CARDINAL, characterCount: CARDINAL] = {    IF ~DoTiming[] THEN RETURN;    PutDefs.Text[toolData.fileSW, "Time = "L];    PutDefs.LongDecimal[toolData.fileSW, time];    PutDefs.Text[toolData.fileSW, " usec, Chars= "L];    PutDefs.Decimal[toolData.fileSW, characterCount];    PutDefs.Text[toolData.fileSW, " rate:  "L];    PutDefs.LongDecimal[toolData.fileSW, rate/10];    PutDefs.Char[toolData.fileSW, '.];    PutDefs.LongDecimal[toolData.fileSW, rate MOD 10];    PutDefs.Line[toolData.fileSW, " cps"L]};      -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Mainline code  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ToolInit[]; -- this gets string out of global frame    END.....  LOG...JXG    	28-Jul-83 10:39:06 started log, need LOOPHOLE in Runtime.IsBound  RSV     27-Mar-87 14:27:49 Deleted Storage references (use NEW and FREE).
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- TomOps.mesa (last edited by Jonathan JXG     22-Feb-83  9:46:58)DIRECTORY  Context USING [Find, Type],  Courier USING [Handle],  FormSW USING [MenuProcType, ProcType],  Process USING [Priority],  System USING [NetworkAddress],  TomD,  Window USING [Handle];TomOps:  DEFINITIONS  IMPORTS Context, Process, TomD, Window = PRIVATE  BEGIN 	       -- contexts - used to associate private data with a window   CtxHandle:     TYPE = LONG POINTER TO TomContext;      TomContext:     TYPE = MONITORED RECORD      	    [toolWindow, 			-- various windows	     msgSW, 	     formSW, 	     parmSW, 	     lastSW: Window.Handle ¬ NIL,	     next: CtxHandle ¬ NIL,		-- pointer to next instance	     parmFileName,       		-- formSW strings    	     remoteName, 	     displayName,	     interfaceName, 	     variableName, 	     parmString: LONG STRING ¬ NIL,	-- parmSW backing store	     priority: Process.Priority,	-- formSW items	     interval: CARDINAL ¬ 1000,	     remoteNameChanged:BOOLEAN ¬ TRUE,  -- indicates if placeHandle up to date	     placeHandle:PlaceHandle ¬ NIL,     -- info about who to monitor	     display: DisplayHandle ¬ NIL,	-- current display	     items: Items ¬ NIL,		-- current list of items	     clientHandle: LONG POINTER ¬ NIL,  -- passed to client display routines	     updateHandle: UpdateHandle ¬ NIL,	-- passed to client interface routines	     updateCH: Courier.Handle ¬ NIL,   	     updateProcess: PROCESS ¬ NIL,	-- updates display and interfaces	     updateProcessSerialNo: CARDINAL ¬ 0	    ];	     	  tomContextType: Context.Type;    GetContext: PROCEDURE[w:Window.Handle] RETURNS [ctx:CtxHandle] =    INLINE {RETURN[Context.Find[tomContextType, w]]};       -- given a window, return its instance context      Items: TYPE = TomD.Items;   ItemP: TYPE = TomD.ItemP;  Item: TYPE = TomD.Item;      WordBoolean: TYPE = TomD.WordBoolean;      iAnother:CARDINAL = 0;    	 -- FormSW item indices  iDestroy:CARDINAL = 1;   iReset:CARDINAL = 2;  iLoad:CARDINAL = 3;  iSave:CARDINAL = 4;  iParmFile:CARDINAL = 5;        iRemoteMachine:CARDINAL = 6;    iAdd:CARDINAL = 7;  iInterface:CARDINAL = 8;  iVariable:CARDINAL = 9;       iApply:CARDINAL = 10;  iDisplay:CARDINAL = 11;  iPriority:CARDINAL = 12;  iInterval: CARDINAL = 13;  iLastPlus1: CARDINAL = 14;    z:UNCOUNTED ZONE;    SeqOfStrings:  TYPE = RECORD[seq:SEQUENCE COMPUTED CARDINAL OF LONG STRING];   SeqOfStringsP: TYPE = LONG POINTER TO SeqOfStrings;  Names:TYPE = LONG DESCRIPTOR FOR ARRAY OF LONG STRING;  FreeNamesProcType: TYPE = PROCEDURE[names:Names];  TerminateMode: TYPE = {abandon, normal};      -- TomGlobal ...  -- tool creation and deletion ...  TryToLoad:     PROCEDURE [name:LONG STRING, type:InterfaceOrDisplay, msgSW:Window.Handle¬NIL]    RETURNS [ok:BOOLEAN];  InterfaceOrDisplay: TYPE = {interface, display};           -- TomPImpl ...    PlaceHandle: TYPE = LONG POINTER TO PlaceObject;  PlaceObject:TYPE =     RECORD [name:LONG STRING ¬ NIL,            type:{bad, local, remote} ¬ local, 	    cH:Courier.Handle ¬ NIL];    GetInterfaceNames:     PROCEDURE [placeHandle:PlaceHandle]     RETURNS [names:Names, freeNamesProc:FreeNamesProcType];    GetVariableNames:     PROCEDURE [placeHandle:PlaceHandle, name:LONG STRING]     RETURNS [names:Names, freeNamesProc:FreeNamesProcType];  CreateCourierHandle:     PROCEDURE[addr:System.NetworkAddress] RETURNS [cH:Courier.Handle];  DeleteCourierHandle: PROCEDURE[cH:Courier.Handle];  IsSamePlace:     PROCEDURE[placeHandle:PlaceHandle, updateHandle:UpdateHandle] RETURNS [BOOLEAN];        InitializeUpdateInterfaces:     PROCEDURE [placeHandle:PlaceHandle, items:Items]     RETURNS [updateHandle:UpdateHandle];  UpdateInterfaces: PROCEDURE [updateHandle:UpdateHandle];  TerminateUpdateInterfaces: PROCEDURE [updateHandle:UpdateHandle, mode:TerminateMode];  UpdateHandle:TYPE = LONG POINTER TO UpdateObject; UpdateObject:TYPE;     PerfErr:    SIGNAL [reason:PerfErrReason, interfaceName, variableName: LONG STRING ¬ NIL];      PerfErrReason:     TYPE = {badRemoteName,    	    noInterfaces, noInterfaceGiven, interfaceNotFound, badInterface,    	    interfaceNoLongerAvailable, variableNotFound,	    alreadyBeingMonitored, invalidCall};      -- TomDImpl ...      GetDisplayNames: PROCEDURE [] RETURNS [names:Names, freeNamesProc:FreeNamesProcType];    GetDisplay: PROCEDURE [name:LONG STRING] RETURNS [display:DisplayHandle];  Display:     PROCEDURE [display:DisplayHandle, items:Items, clientHandle:LONG POINTER, 	       msgSW, parent, insertBeforeThis:Window.Handle]    RETURNS [newClientHandle:LONG POINTER];  UpdateDisplay: PROCEDURE [display:DisplayHandle, clientHandle:LONG POINTER];  DisplayHandle:TYPE = LONG POINTER TO DisplayObject; DisplayObject:TYPE;    DisplayErr:SIGNAL [reason:DisplayErrReason, name:LONG STRING];  DisplayErrReason:  TYPE = {noDisplayGiven, displayNotFound};        -- TomCommands ...  MainFormCommandProc: FormSW.ProcType;    -- TomDisplay ...  GetDisplayAndCatchErrors:     PROCEDURE [ctx:CtxHandle] RETURNS [display:DisplayHandle];  SetDisplay: PROCEDURE [ctx:CtxHandle, display:DisplayHandle, items:Items];  FreeItems: PROCEDURE [items:Items];  AllocateItems: PROCEDURE [n:CARDINAL] RETURNS [items:Items];    -- TomMenu ...  MainFormMenuProc: FormSW.MenuProcType;  FreeNames: PROCEDURE [names:Names];    -- TomPerf ...  GetNamesAndCatchErrorsProcType: TYPE =     PROCEDURE [ctx:CtxHandle] RETURNS [names:Names, freeNamesProc:FreeNamesProcType];  GetInterfaceNamesAndCatchErrors: GetNamesAndCatchErrorsProcType;  GetVariableNamesAndCatchErrors: GetNamesAndCatchErrorsProcType;  InitializeUpdateInterfacesAndCatchErrors:     PROCEDURE [ctx:CtxHandle, items:Items] RETURNS [ok:BOOLEAN];  UpdateInterfacesAndCatchErrors:    PROCEDURE[ctx:CtxHandle] RETURNS [ok:BOOLEAN];  TerminateUpdateInterfacesAndCatchErrors:     PROCEDURE [ctx:CtxHandle, mode:TerminateMode ¬ normal];  UpdatePlaceHandle: PROCEDURE [ctx:CtxHandle];        -- misc ...    ArrayFromSequence:     PROCEDURE [seq:SeqOfStringsP, n:CARDINAL] RETURNS [Names] = INLINE    {RETURN [DESCRIPTOR[LOOPHOLE[@(seq­.seq), LONG POINTER], n, LONG STRING]]};     -- note that DESCRIPTOR cannot be applied directly to a COMPUTED SEQUENCE      -- even if a length is supplied      SequenceFromArray:     PROCEDURE [names:Names] RETURNS [seq:SeqOfStringsP, n:CARDINAL] = INLINE    {RETURN [LOOPHOLE[BASE[names]], LENGTH[names]]};          END...
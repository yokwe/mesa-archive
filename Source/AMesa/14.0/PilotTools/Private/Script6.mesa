-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Script6.mesa       26-Apr-83 17:18:59 by CAJ -- Virtual memory test program, Klamath Pilot.-- Script6 tests Map and Unmap.DIRECTORY  Environment USING [PageCount],  ScriptOps USING [RegisterScript],  Space USING [defaultSwapUnitSize],  VM USING [Interval, nullBackingStoreRuns, nullInterval],  VMTestOperations --USING [all the operations]--,  VMTestScript USING [GetHeap, GetTestVMSize, GiveBackHeap, LogNonRecoverable,    MakeBackingData, MakeIrregularSwapData, MakeUniformSwapData,    MakeUnitarySwapData, Ticker];Script6: PROGRAM  IMPORTS ScriptOps, VMTestOperations, VMTestScript =  BEGIN  ------------  -- Procedures:  -- RunTests is a script of tests using procedures from VMTestOperations (for  -- VM operations) and VMTestScript (for test utilities).  RunTests: PROCEDURE =    BEGIN OPEN VMTestOperations, VMTestScript;    heap: UNCOUNTED ZONE ¬ GetHeap[];    testEverything: BOOLEAN ¬ TRUE;    LogNonRecoverable[TRUE];    -- Test combinations of arguments to Map    TestUnitarySwapUnits[heap];    TestUniformSwapUnits[heap];    TestIrregularSwapUnits[heap];    IF testEverything THEN TestUnrecoverable[heap];    -- Test Map some map units, then Unmap all, in different orders    -- Test ???    heap ¬ GiveBackHeap[heap];    END;  TestIrregularSwapUnits: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    vmSize: CARDINAL = CARDINAL[GetTestVMSize[]];  -- known single-word value    pArray: LONG POINTER;    pRuns: LONG POINTER;    pSwapUnits: LONG POINTER;    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular swap units, matching backing runs"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    pSwapUnits ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "irregular swap units, single backing run"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapUnits, 3]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 2];    Ticker[];    heap.FREE[@pSwapUnits];    heap.FREE[@pRuns];    pSwapUnits ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    pRuns ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [2, 1, 2, 1, 2, 2]];    Map[id: "irregular swap units, contained backing runs"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 6]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapUnits, 3]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 2];    Ticker[];    heap.FREE[@pSwapUnits];    heap.FREE[@pRuns];    pSwapUnits ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 1, 4, 1, 2]];    Map[id: "irregular swap units, overlapping backing runs"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapUnits, 3]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 2];    Ticker[];    heap.FREE[@pSwapUnits];    heap.FREE[@pRuns];    pSwapUnits ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    pRuns ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [2, 1, 4, 1, 3, 1]];    Map[id: "irregular swap units, backing runs past map"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 6]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapUnits, 3]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 2];    Ticker[];    heap.FREE[@pSwapUnits];    heap.FREE[@pRuns];    pSwapUnits ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "irregular swap units, single swap unit"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapUnits, 1]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 2];    Ticker[];    heap.FREE[@pSwapUnits];    heap.FREE[@pRuns];    pSwapUnits ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [vmSize]];    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [10, 10, 10, 10, 10]];    Map[id: "irregular swap units, fill test VM"L,      interval: [0, vmSize],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapUnits, 1]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pSwapUnits];    heap.FREE[@pRuns];    pSwapUnits ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [1, 15, 2]];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [18]];    Map[id: "irregular swap units, tickle max size boundary (a)"L,      interval: [0, 18],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapUnits, 3]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pSwapUnits];    heap.FREE[@pRuns];    pSwapUnits ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [1, 16, 2]];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [19]];    Map[id: "irregular swap units, tickle max size boundary (b)"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapUnits, 3]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pSwapUnits];    heap.FREE[@pRuns];    pSwapUnits ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [1, 17, 2]];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [20]];    Map[id: "irregular swap units, tickle max size boundary (c)"L,      interval: [0, 20],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapUnits, 3]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pSwapUnits];    heap.FREE[@pRuns];    pSwapUnits ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [1, 16, 2]];    pRuns ¬ heap.NEW[ARRAY[0..2) OF WORD ¬ [16, 3]];    Map[id: "irregular swap units, tickle max size boundary (d)"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 2]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapUnits, 3]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pSwapUnits];    heap.FREE[@pRuns];    pSwapUnits ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [1]];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [2]];    Map[id: "irregular swap unit, last page"L,      interval: [vmSize - 1, 1],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapUnits, 1]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: vmSize - 1];    Ticker[];    heap.FREE[@pRuns];    pSwapUnits ¬ heap.NEW[ARRAY[0..2) OF WORD ¬ [16, 2]];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [5]];    Map[id: "irregular, swap units > interval"L,      interval: [0, 5],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapUnits, 2]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- end of plain runs + swap units combinations    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular swap units, no backing, readWrite, swappable"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular, no backing, readonly"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readOnly,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular, no backing, readWrite, swappable, dead"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular, no backing, readonly, swappable, dead"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readOnly,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular swap unit, no proc but backing runs"L,      interval: [0, 10],      backed: FALSE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 1];    Ticker[];    heap.FREE[@pArray];    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular swap units, backed, readWrite, swappable, dead"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    Ticker[];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular swap units, backed, readWrite, resident, dead"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: resident];    Ticker[];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular swap units, backed, readOnly, swappable, dead"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readOnly,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: swappable];    Ticker[];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular swap units, backed, readOnly, resident, dead"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 3]],      access: readOnly,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: resident];    Ticker[];    Unmap[page: 2];    Ticker[];    heap.FREE[@pArray];    END;  TestUniformSwapUnits: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    vmSize: CARDINAL = CARDINAL[GetTestVMSize[]];  -- known single-word value    pRuns: LONG POINTER;    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "uniform swap units, matching backing runs"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "uniform swap units, single backing run"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..7) OF WORD ¬ [1, 1, 2, 1, 1, 2, 2]];    Map[id: "uniform swap units, contained backing runs"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 7]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [1, 2, 3, 1, 2, 1]];    Map[id: "uniform swap units, overlapping backing runs"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 6]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..7) OF WORD ¬ [2, 1, 4, 1, 3, 4, 2]];    Map[id: "uniform swap units, backing runs past map"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 7]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..7) OF WORD ¬ [2, 1, 4, 1, 3, 4, 2]];    Map[id: "uniform swap units, size = 0"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 7]],      access: readWrite,      swapUnits: MakeUniformSwapData[0],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..7) OF WORD ¬ [2, 1, 4, 1, 3, 4, 2]];    Map[id: "uniform swap units, size = default"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 7]],      access: readWrite,      swapUnits: MakeUniformSwapData[Space.defaultSwapUnitSize],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [10, 10, 10, 10, 10]];    Map[id: "uniform swap units, fill test VM"L,      interval: [0, vmSize],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[vmSize],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [2]];    Map[id: "uniform swap unit, last page"L,      interval: [vmSize - 1, 1],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUniformSwapData[1],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: vmSize - 1];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [2]];    Map[id: "uniform, swap unit > map interval"L,      interval: [0, 2],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUniformSwapData[4],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    -- end uniform + runs tests    Map[id: "uniform swap unit, no backing, readWrite, swappable"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUniformSwapData[0],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    Map[id: "uniform swap unit, no backing, readonly"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readOnly,      swapUnits: MakeUniformSwapData[0],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    Map[id: "uniform, no backing, readWrite, swappable, dead"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUniformSwapData[0],      life: dead,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    Map[id: "uniform, no backing, readonly, swappable, dead"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readOnly,      swapUnits: MakeUniformSwapData[0],      life: dead,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    pRuns ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "uniform swap unit, no proc but backing runs"L,      interval: [0, 10],      backed: FALSE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 3]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 1];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "uniform, backed, readWrite, swappable, dead"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    Ticker[];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "uniform, backed, readWrite, resident, dead"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readWrite,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: resident];    Ticker[];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "uniform, backed, readOnly, swappable, dead"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readOnly,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: swappable];    Ticker[];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..5) OF WORD ¬ [2, 2, 2, 2, 2]];    Map[id: "uniform, backed, readOnly, resident, dead"L,      interval: [4, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 5]],      access: readOnly,      swapUnits: MakeUniformSwapData[2],      life: dead,      swappability: resident];    Ticker[];    Unmap[page: 4];    Ticker[];    heap.FREE[@pRuns];    END;  TestUnitarySwapUnits: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    vmSize: CARDINAL = CARDINAL[GetTestVMSize[]];  -- known single-word value    pRuns: LONG POINTER;    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "unitary swap unit, single backing run"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "unitary swap unit, contained backing runs"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 3]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Ticker[];        Unmap[page: 1];    Ticker[];    heap.FREE[@pRuns];        pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [12]];    Map[id: "unitary swap unit, backing run too long (1)"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Ticker[];        Unmap[page: 9];    Ticker[];    heap.FREE[@pRuns];        pRuns ¬ heap.NEW[ARRAY[0..2) OF WORD ¬ [7, 7]];    Map[id: "unitary swap unit, backing runs too long (>1)"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 2]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Ticker[];          Unmap[page: 9];    Ticker[];    heap.FREE[@pRuns];          pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [50]];    Map[id: "unitary swap unit, fill test VM"L,      interval: [0, vmSize],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Ticker[];          Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];          pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [2]];    Map[id: "unitary swap unit, last page"L,      interval: [vmSize - 1, 1],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Ticker[];        Unmap[page: vmSize - 1];    Ticker[];    heap.FREE[@pRuns];        -- end of purely runs + swap type tests        Map[id: "unitary swap unit, no backing, readWrite, swappable"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Ticker[];          Unmap[page: 1];    Ticker[];          Map[id: "unitary, no backing, readonly, swappable"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readOnly,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Ticker[];        Unmap[page: 1];    Ticker[];    Map[id: "unitary swap unit, no backing, readWrite, swappable, dead"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: swappable];    Ticker[];    Unmap[page: 1];    Ticker[];    Map[id: "unitary, no backing, readonly, swappable, dead"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readOnly,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: swappable];    Ticker[];    Unmap[page: 1];    Ticker[];    pRuns ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "unitary swap unit, no proc but backing runs"L,      interval: [0, 10],      backed: FALSE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 3]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 1];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "unitary, backed, readWrite, swappable, dead"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "unitary, backed, readWrite, resident, dead"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: resident];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "unitary, backed, readOnly, swappable, dead"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readOnly,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: swappable];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    pRuns ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [10]];    Map[id: "unitary, backed, readOnly, resident, dead"L,      interval: [0, 10],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pRuns, 1]],      access: readOnly,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: resident];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pRuns];    Map[id: "null interval"L,      interval: VM.nullInterval,      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    Ticker[];    -- Unmap already unmapped page    Unmap[page: 10];    Ticker[];    Map[id: "zero count"L,      interval: [7, 0],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    Ticker[];    END;  TestUnrecoverable: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- These tests should all abort for predicted unrecoverable outcomes.    -- A facility for checking this would be nice.    pArray: LONG POINTER;    pRuns: LONG POINTER;    Map[id: "overlapping map - real map 1st"L,      interval: [8, 2],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    Ticker[];    Map[id: "overlapping map - overlap"L,      interval: [9, 5],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    Ticker[];    Unmap[page: 9];    Ticker[];    Map[id: "unitary, no backing, readWrite, resident"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    Ticker[];    Unmap[page: 1];    Ticker[];    Map[id: "unitary, no backing, readonly, resident"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readOnly,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: resident];    Ticker[];    Unmap[page: 1];    Ticker[];    Map[id: "unitary, no backing, readWrite, resident, dead"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: resident];    Ticker[];    Unmap[page: 1];    Ticker[];    Map[id: "unitary, no backing, readonly, resident, dead"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readOnly,      swapUnits: MakeUnitarySwapData[],      life: dead,      swappability: resident];    Ticker[];    Unmap[page: 1];    Ticker[];    pRuns ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "unitary swap unit, proc but no backing runs"L,      interval: [0, 10],      backed: TRUE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUnitarySwapData[],      life: alive,      swappability: swappable];    Ticker[];    Unmap[page: 1];    Ticker[];    heap.FREE[@pRuns];    Map[id: "uniform swap unit, no backing, readWrite, resident"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUniformSwapData[0],      life: alive,      swappability: resident];    Ticker[];    Unmap[page: 0];    Ticker[];    Map[id: "uniform swap unit, no backing, readonly, resident"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readOnly,      swapUnits: MakeUniformSwapData[0],      life: alive,      swappability: resident];    Ticker[];    Unmap[page: 0];    Ticker[];    Map[id: "uniform, no backing, readWrite, resident, dead"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeUniformSwapData[0],      life: dead,      swappability: resident];    Ticker[];    Unmap[page: 0];    Ticker[];    Map[id: "uniform, no backing, readonly, resident, dead"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readOnly,      swapUnits: MakeUniformSwapData[0],      life: dead,      swappability: resident];    Ticker[];    Unmap[page: 0];    Ticker[];    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular, no backing, readWrite, resident"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: resident];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular, no backing, readonly, resident"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readOnly,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: alive,      swappability: resident];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular, no backing, readWrite, resident, dead"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: resident];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    pArray ¬ heap.NEW[ARRAY[0..3) OF WORD ¬ [5, 1, 4]];    Map[id: "irregular, no backing, readonly, resident, dead"L,      interval: [0, 10],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readOnly,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 3]],      life: dead,      swappability: resident];    Ticker[];    Unmap[page: 0];    Ticker[];    heap.FREE[@pArray];    END;  ------------  -- Initialization:  ScriptOps.RegisterScript[RunTests, "Map tests +"L];  END.LOG29-Nov-82 15:20:50   CAJ    Created file.
-- Copyright (C) 1984, 1985, 1988  by Xerox Corporation. All rights reserved. -- DiskEditMarkerPageSW.mesa    1-Mar-88  9:16:30 by CAJ  DIRECTORY  Boot USING [BootFileType, DiskFileID],  DiskEditInternal USING [dataPtr, dataWindowKey, ReplaceUIDString, ValidateUID],  Heap USING [systemZone],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    FilterProcType, ItemHandle, LabelItem, LongNumberItem, newLine, nextPlace,    NumberItem, NumberNotifyProcType, ProcType, StringEditProc, StringItem],  LogicalVolumeFormat USING [LSMCurrentVersion, LSMSeal, maxLogicalVolumeLabelLength],  PhysicalVolumeFormat USING [    PageNumber, physicalVolumeLabelLength, PSMCurrentVersion, PSMSeal,    SubVolumeDesc, SubVolumeFill1, SubVolumeFill2, SubVolumeMarkerPage],  PilotDisk USING [FileID],  String USING [FreeString, Replace],  System USING [nullID, UniversalID],  UserTerminal USING [BlinkDisplay],  Volume USING [Type],  WindowSwap USING [RegisterView];DiskEditMarkerPageSW: PROGRAM  IMPORTS DiskEditInternal, FormSW, Heap, String, UserTerminal, WindowSwap  SHARES Boot =  BEGIN  fill1IndexIndex: CARDINAL ¬ 0;  fill1ValueIndex: CARDINAL ¬ 0;  fill2IndexIndex: CARDINAL ¬ 0;  fill2ValueIndex: CARDINAL ¬ 0;  lvBootFileIDIndex: CARDINAL ¬ 0;  lvBootFileFirstPageIndex: CARDINAL ¬ 0;  lvBootFileDiskAddressA: CARDINAL ¬ 0;  lvBootFileDiskAddressB: CARDINAL ¬ 0;  pvBootFileIDIndex: CARDINAL ¬ 0;  pvBootFileFirstPageIndex: CARDINAL ¬ 0;  pvBootFileDiskAddressA: CARDINAL ¬ 0;  pvBootFileDiskAddressB: CARDINAL ¬ 0;  Pair: TYPE = RECORD [UNSPECIFIED, UNSPECIFIED];  MarkerPageLogical: TYPE = MACHINE DEPENDENT RECORD [      labelString(0): LONG STRING ¬ NIL,      labelLength(2): CARDINAL ¬ 0,      type(3:0..15): Volume.Type ¬ normal,      rootDirectoryIDString(4): LONG STRING ¬ NIL,      pad(6:0..15): [0..256) ¬ 0,      currentBootingInfoFileType(7:0..15): Boot.BootFileType ¬ pilot,      currentBootingInfoFileIDString(8): LONG STRING ¬ NIL,      currentBootingInfoDiskFileID(10): Boot.DiskFileID ¬ [LOOPHOLE[System.nullID], 0,         LOOPHOLE[Pair[0, 0]]]  -- fix this LOOPHOLE to export type properly --      ];  MarkerPagePhysical: TYPE = MACHINE DEPENDENT RECORD [      IDString(0): LONG STRING ¬ NIL,      labelString(2): LONG STRING ¬ NIL,      labelLength(4): CARDINAL ¬ 0,      fill(5:0..15): [0..128) ¬ 0,      svNumber(6): CARDINAL ¬ 0,      svIDString(7): LONG STRING ¬ NIL,      currentBootingInfoFileType(9:0..15): Boot.BootFileType ¬ pilot,      currentBootingInfoFileIDString(10): LONG STRING ¬ NIL,      currentBootingInfoDiskFileID(12): Boot.DiskFileID ¬ [LOOPHOLE[System.nullID], 0,        LOOPHOLE[Pair[0, 0]]],   -- fix this LOOPHOLE to export type properly --      lvShouldBeScavenged(21): BOOLEAN ¬ FALSE      ];   markerPage: RECORD [    logical: MarkerPageLogical,    physical: MarkerPagePhysical,    fill1Index: CARDINAL ¬ FIRST[PhysicalVolumeFormat.SubVolumeFill1],    fill1CurrentValue: WORD ¬ 0,    fill2Index: CARDINAL ¬ FIRST[PhysicalVolumeFormat.SubVolumeFill2],    fill2CurrentValue: WORD ¬ 0    ];  mp: LONG POINTER TO PhysicalVolumeFormat.SubVolumeMarkerPage =    LOOPHOLE[DiskEditInternal.dataPtr];  CleanupMarkerPageSW: PROCEDURE =    BEGIN    mp.logical.type ¬ markerPage.logical.type;    mp.logical.labelLength ¬ markerPage.logical.labelLength;    mp.logical.bootingInfo[markerPage.logical.currentBootingInfoFileType] ¬      markerPage.logical.currentBootingInfoDiskFileID;    mp.logical.pad ¬ markerPage.logical.pad;    mp.physical.fill ¬ markerPage.physical.fill;    mp.physical.labelLength ¬ markerPage.physical.labelLength;    mp.physical.svNumber ¬ markerPage.physical.svNumber;    mp.physical.bootingInfo[markerPage.physical.currentBootingInfoFileType] ¬      markerPage.physical.currentBootingInfoDiskFileID;    mp.physical.lvShouldBeScavenged ¬ markerPage.physical.lvShouldBeScavenged;    END;  CopyLVLabel: FormSW.FilterProcType =    BEGIN    FormSW.StringEditProc[sw, item, insert, string];    FOR i: CARDINAL IN      [0..MIN[         LogicalVolumeFormat.maxLogicalVolumeLabelLength,         markerPage.logical.labelString.length]) DO      mp.logical.label[i] ¬ markerPage.logical.labelString[i]; ENDLOOP;    END;  CopyPVLabel: FormSW.FilterProcType =    BEGIN    FormSW.StringEditProc[sw, item, insert, string];    FOR i: CARDINAL IN      [0..MIN[         PhysicalVolumeFormat.physicalVolumeLabelLength,         markerPage.physical.labelString.length]) DO      mp.physical.label[i] ¬ markerPage.physical.labelString[i]; ENDLOOP;    END;  DestroyMarkerPageSW: PROCEDURE =    BEGIN    -- Clean up resources for view going away for good.    String.FreeString[z: Heap.systemZone, s: markerPage.logical.labelString];    markerPage.logical.labelString ¬ NIL;    String.FreeString[      z: Heap.systemZone, s: markerPage.logical.rootDirectoryIDString];    markerPage.logical.rootDirectoryIDString ¬ NIL;    String.FreeString[      z: Heap.systemZone, s: markerPage.logical.currentBootingInfoFileIDString];    markerPage.logical.currentBootingInfoFileIDString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: markerPage.physical.IDString];    markerPage.physical.IDString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: markerPage.physical.labelString];    markerPage.physical.labelString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: markerPage.physical.svIDString];    markerPage.physical.svIDString ¬ NIL;    String.FreeString[      z: Heap.systemZone, s: markerPage.physical.currentBootingInfoFileIDString];    markerPage.physical.currentBootingInfoFileIDString ¬ NIL;    END;  Fill1BackCommand: FormSW.ProcType =    BEGIN    mp.fill1[markerPage.fill1Index] ¬ markerPage.fill1CurrentValue;    markerPage.fill1Index ¬      IF markerPage.fill1Index = FIRST[PhysicalVolumeFormat.SubVolumeFill1] THEN LAST[      PhysicalVolumeFormat.SubVolumeFill1] ELSE markerPage.fill1Index - 1;    markerPage.fill1CurrentValue ¬ mp.fill1[markerPage.fill1Index];    FormSW.DisplayItem[sw, fill1IndexIndex];    FormSW.DisplayItem[sw, fill1ValueIndex];    END;  Fill1NextCommand: FormSW.ProcType =    BEGIN    mp.fill1[markerPage.fill1Index] ¬ markerPage.fill1CurrentValue;    markerPage.fill1Index ¬      IF markerPage.fill1Index = LAST[PhysicalVolumeFormat.SubVolumeFill1] THEN FIRST[      PhysicalVolumeFormat.SubVolumeFill1] ELSE markerPage.fill1Index + 1;    markerPage.fill1CurrentValue ¬ mp.fill1[markerPage.fill1Index];    FormSW.DisplayItem[sw, fill1IndexIndex];    FormSW.DisplayItem[sw, fill1ValueIndex];    END;  Fill2BackCommand: FormSW.ProcType =    BEGIN    mp.fill2[markerPage.fill2Index] ¬ markerPage.fill2CurrentValue;    markerPage.fill2Index ¬      IF markerPage.fill2Index = FIRST[PhysicalVolumeFormat.SubVolumeFill2] THEN LAST[      PhysicalVolumeFormat.SubVolumeFill2] ELSE markerPage.fill2Index - 1;    markerPage.fill2CurrentValue ¬ mp.fill2[markerPage.fill2Index];    FormSW.DisplayItem[sw, fill2IndexIndex];    FormSW.DisplayItem[sw, fill2ValueIndex];    END;  Fill2NextCommand: FormSW.ProcType =    BEGIN    mp.fill2[markerPage.fill2Index] ¬ markerPage.fill2CurrentValue;    markerPage.fill2Index ¬      IF markerPage.fill2Index = LAST[PhysicalVolumeFormat.SubVolumeFill2] THEN FIRST[      PhysicalVolumeFormat.SubVolumeFill2] ELSE markerPage.fill2Index + 1;    markerPage.fill2CurrentValue ¬ mp.fill2[markerPage.fill2Index];    FormSW.DisplayItem[sw, fill2IndexIndex];    FormSW.DisplayItem[sw, fill2ValueIndex];    END;  FillMarkerPageSW: PROCEDURE =    BEGIN    longFileID: volumeRelative PilotDisk.FileID;    ReplaceLabelString[      @markerPage.logical.labelString, DESCRIPTOR[      @mp.logical.label, MIN[        LogicalVolumeFormat.maxLogicalVolumeLabelLength, mp.logical.labelLength]]];    markerPage.logical.labelLength ¬ mp.logical.labelLength;    markerPage.logical.type ¬ mp.logical.type;    longFileID.fileID ¬ mp.logical.volumeRootDirectory;    DiskEditInternal.ReplaceUIDString[      @markerPage.logical.rootDirectoryIDString, LOOPHOLE[longFileID, System.UniversalID]];    markerPage.logical.pad ¬ mp.logical.pad;    DiskEditInternal.ReplaceUIDString[      @markerPage.logical.currentBootingInfoFileIDString, LOOPHOLE[mp.logical.bootingInfo[      markerPage.logical.currentBootingInfoFileType].fID, System.UniversalID]];    markerPage.logical.currentBootingInfoDiskFileID ¬ mp.logical.bootingInfo[      markerPage.logical.currentBootingInfoFileType];    DiskEditInternal.ReplaceUIDString[      @markerPage.physical.IDString, mp.physical.pvID];    ReplaceLabelString[      @markerPage.physical.labelString, DESCRIPTOR[      @mp.physical.label, MIN[        PhysicalVolumeFormat.physicalVolumeLabelLength,        mp.physical.labelLength]]];    markerPage.physical.labelLength ¬ mp.physical.labelLength;    markerPage.physical.fill ¬ mp.physical.fill;    markerPage.physical.svNumber ¬ mp.physical.svNumber;    markerPage.physical.lvShouldBeScavenged ¬ mp.physical.lvShouldBeScavenged;    DiskEditInternal.ReplaceUIDString[      @markerPage.physical.svIDString, mp.physical.descriptor.lvID];    DiskEditInternal.ReplaceUIDString[      @markerPage.physical.currentBootingInfoFileIDString,      LOOPHOLE[mp.physical.bootingInfo[      markerPage.physical.currentBootingInfoFileType].fID, System.UniversalID]];    markerPage.physical.currentBootingInfoDiskFileID ¬ mp.physical.bootingInfo[      markerPage.physical.currentBootingInfoFileType];    markerPage.fill1CurrentValue ¬ mp.fill1[markerPage.fill1Index];    markerPage.fill2CurrentValue ¬ mp.fill2[markerPage.fill2Index];    END;  MakeMarkerPageSW: FormSW.ClientItemsProcType =    BEGIN    fill1: BOOLEAN =      (LAST[PhysicalVolumeFormat.SubVolumeFill1] - FIRST[PhysicalVolumeFormat.SubVolumeFill1]) ~= 0;    fill2: BOOLEAN =      (LAST[PhysicalVolumeFormat.SubVolumeFill2] - FIRST[PhysicalVolumeFormat.SubVolumeFill2]) ~= 0;    i: CARDINAL ¬ 0;    nItems: CARDINAL ¬ 38 + (IF fill1 THEN 5 ELSE 0) + (IF fill2 THEN 5 ELSE 0);    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[0] ¬ FormSW.LabelItem[tag: NIL, invisible: TRUE, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LabelItem[      tag: "Marker Page"L, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LabelItem[      tag: "Logical Subvolume Marker"L, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "   Version"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: LogicalVolumeFormat.LSMCurrentVersion, value: @mp.logical.version,      place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Seal"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: LogicalVolumeFormat.LSMSeal, value: @mp.logical.seal,      place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "   Label length"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @markerPage.logical.labelLength,      proc: ValidateLVLabelLength, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.StringItem[      tag: "Label"L, inHeap: TRUE, string: @markerPage.logical.labelString,      filterProc: CopyLVLabel, place: FormSW.nextPlace];    BEGIN    enumeratedLVTypeArray: ARRAY [0..4) OF FormSW.Enumerated ¬ [      [string: "normal"L, value: Volume.Type[normal]], [      string: "debugger"L, value: Volume.Type[debugger]], [      string: "debuggerDebugger"L, value: Volume.Type[debuggerDebugger]], [      string: "nonPilot"L, value: Volume.Type[nonPilot]]];    items[i ¬ i + 1] ¬ FormSW.EnumeratedItem[      tag: "   Type"L, feedback: one, copyChoices: TRUE,      value: @markerPage.logical.type, choices: DESCRIPTOR[enumeratedLVTypeArray],      place: FormSW.newLine];    END;    items[i ¬ i + 1] ¬ FormSW.LabelItem[      tag: "Client root file capability"L, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: TRUE,      string: @markerPage.logical.rootDirectoryIDString,      filterProc: ValidateVolumeRootDirectoryID, place: FormSW.nextPlace];    BEGIN    enumeratedLVBootFiles: ARRAY [0..6) OF FormSW.Enumerated ¬ [      [string: "hardMicrocode"L, value: Boot.BootFileType[hardMicrocode]], [      string: "softMicrocode"L, value: Boot.BootFileType[softMicrocode]], [      string: "germ"L, value: Boot.BootFileType[germ]], [      string: "pilot"L, value: Boot.BootFileType[pilot]], [      string: "debugger"L, value: Boot.BootFileType[debugger]], [      string: "debuggee"L, value: Boot.BootFileType[debuggee]]];    items[i ¬ i + 1] ¬ FormSW.EnumeratedItem[      tag: "   Boot file for type"L, feedback: one, copyChoices: TRUE,      value: @markerPage.logical.currentBootingInfoFileType,      proc: NoticeNewLVBootFileType, choices: DESCRIPTOR[enumeratedLVBootFiles],      place: FormSW.newLine];    items[lvBootFileIDIndex ¬ i ¬ i + 1] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: TRUE,      string: @markerPage.logical.currentBootingInfoFileIDString,      filterProc: ValidateLVBootFileID, place: FormSW.nextPlace];    items[lvBootFileFirstPageIndex ¬ i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "   First page"L, notNegative: TRUE, signed: FALSE, default: 0,      radix: decimal,      value: @markerPage.logical.currentBootingInfoDiskFileID.firstPage,     place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LabelItem[      tag: "   Disk address"L, place: FormSW.newLine];    items[lvBootFileDiskAddressA ¬ i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "a"L, notNegative: TRUE, signed: FALSE, default: 0, radix: octal,      value: @markerPage.logical.currentBootingInfoDiskFileID.da,      place: FormSW.nextPlace];    items[lvBootFileDiskAddressB ¬ i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "b"L, notNegative: TRUE, signed: FALSE, default: 0, radix: octal,      value: 1 + @markerPage.logical.currentBootingInfoDiskFileID.da,      place: FormSW.nextPlace];    END;    items[i ¬ i + 1] ¬ FormSW.LabelItem[      tag: "Physical volume marker page"L, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "   Seal"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: PhysicalVolumeFormat.PSMSeal, value: @mp.physical.seal,      place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Version"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: PhysicalVolumeFormat.PSMCurrentVersion,      value: @mp.physical.version, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.StringItem[      tag: "   ID"L, inHeap: TRUE, string: @markerPage.physical.IDString,      filterProc: ValidatePVID, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "   Label length"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @markerPage.physical.labelLength,      proc: ValidateLVLabelLength, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.StringItem[      tag: "Label"L, inHeap: TRUE, string: @markerPage.physical.labelString,      filterProc: CopyPVLabel, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "   Max bad pages"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @mp.physical.maxBadPages, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Fill"L, signed: FALSE, notNegative: TRUE, radix: decimal,      proc: ValidatePVFill, default: 0, value: @markerPage.physical.fill,      place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.BooleanItem[      tag: "lvShouldBeScavenged"L, switch: @markerPage.physical.lvShouldBeScavenged,       place: FormSW.nextPlace];     items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "   Is for subvolume"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @markerPage.physical.svNumber, proc: ValidatePVSVNumber,      place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: TRUE, string: @markerPage.physical.svIDString,      filterProc: ValidatePVSVID, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "      Logical volume size"L, signed: FALSE, notNegative: TRUE,      radix: decimal, default: 0, value: @mp.physical.descriptor.lvSize,      place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "Subvolume size"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @mp.physical.descriptor.nPages, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "      LV page #"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @mp.physical.descriptor.lvPage, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "PV page #"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @mp.physical.descriptor.pvPage, place: FormSW.nextPlace];    BEGIN    enumeratedPVBootFiles: ARRAY [0..4) OF FormSW.Enumerated ¬ [      [string: "hardMicrocode"L, value: Boot.BootFileType[hardMicrocode]], [      string: "softMicrocode"L, value: Boot.BootFileType[softMicrocode]], [      string: "germ"L, value: Boot.BootFileType[germ]], [      string: "pilot"L, value: Boot.BootFileType[pilot]]];    items[i ¬ i + 1] ¬ FormSW.EnumeratedItem[      tag: "Boot file for type"L, feedback: one, copyChoices: TRUE,      value: @markerPage.physical.currentBootingInfoFileType,      proc: NoticeNewPVBootFileType, choices: DESCRIPTOR[enumeratedPVBootFiles],      place: FormSW.newLine];    items[pvBootFileIDIndex ¬ i ¬ i + 1] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: TRUE, filterProc: ValidatePVBootFileID,      string: @markerPage.physical.currentBootingInfoFileIDString,      place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "  First page"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0,      value: @markerPage.physical.currentBootingInfoDiskFileID.firstPage,      place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LabelItem[      tag: "BootDiskAddress", place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "a"L, signed: FALSE, notNegative: TRUE, radix: octal, default: 0,      value: @markerPage.physical.currentBootingInfoDiskFileID.da,      place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "b"L, signed: FALSE, notNegative: TRUE, radix: octal, default: 0,      value: 1 + @markerPage.physical.currentBootingInfoDiskFileID.da,      place: FormSW.newLine];    END;    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Marker page checksum"L, signed: FALSE, notNegative: TRUE,      radix: decimal, default: 0, value: @mp.checksum, place: FormSW.newLine];    IF fill1 THEN      BEGIN      items[i ¬ i + 1] ¬ FormSW.LabelItem[        tag: "MarkerPage Fill1"L, place: FormSW.newLine];      items[fill1IndexIndex ¬ i ¬ i + 1] ¬ FormSW.NumberItem[        tag: "Index"L, signed: FALSE, notNegative: TRUE, radix: decimal,        default: FIRST[PhysicalVolumeFormat.SubVolumeFill1], proc: NoticeFill1Index,        value: @markerPage.fill1Index, place: FormSW.nextPlace];      items[fill1ValueIndex ¬ i ¬ i + 1] ¬ FormSW.NumberItem[        tag: "Value"L, signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,        value: @markerPage.fill1CurrentValue, place: FormSW.nextPlace];      items[i ¬ i + 1] ¬ FormSW.CommandItem[        tag: "Next"L, proc: Fill1NextCommand, place: FormSW.nextPlace];      items[i ¬ i + 1] ¬ FormSW.CommandItem[        tag: "Back"L, proc: Fill1BackCommand, place: FormSW.nextPlace];      END;    IF fill2 THEN      BEGIN      items[i ¬ i + 1] ¬ FormSW.LabelItem[        tag: "MarkerPage Fill2"L, place: FormSW.newLine];      items[fill2IndexIndex ¬ i ¬ i + 1] ¬ FormSW.NumberItem[        tag: "Index"L, signed: FALSE, notNegative: TRUE, radix: decimal,        default: FIRST[PhysicalVolumeFormat.SubVolumeFill2], proc: NoticeFill2Index,        value: @markerPage.fill2Index, place: FormSW.nextPlace];      items[fill2ValueIndex ¬ i ¬ i + 1] ¬ FormSW.NumberItem[        tag: "Value"L, signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,        value: @markerPage.fill2CurrentValue, place: FormSW.nextPlace];      items[i ¬ i + 1] ¬ FormSW.CommandItem[        tag: "Next"L, proc: Fill2NextCommand, place: FormSW.nextPlace];      items[i ¬ i + 1] ¬ FormSW.CommandItem[        tag: "Back"L, proc: Fill2BackCommand, place: FormSW.nextPlace];      END;    IF i ~= nItems - 1 THEN ERROR;  -- indicates that items is incompletely initialized    RETURN[items, TRUE]    END;  NoticeFill1Index: FormSW.NumberNotifyProcType =    BEGIN    IF markerPage.fill1Index ~IN      [FIRST[PhysicalVolumeFormat.SubVolumeFill1]..LAST[PhysicalVolumeFormat.SubVolumeFill1]] THEN      BEGIN UserTerminal.BlinkDisplay[]; RETURN; END;    mp.fill1[oldValue] ¬ markerPage.fill1CurrentValue;    markerPage.fill1CurrentValue ¬ mp.fill1[markerPage.fill1Index];    FormSW.DisplayItem[sw, fill1ValueIndex];    END;  NoticeFill2Index: FormSW.NumberNotifyProcType =    BEGIN    IF markerPage.fill2Index ~IN      [FIRST[PhysicalVolumeFormat.SubVolumeFill2]..LAST[PhysicalVolumeFormat.SubVolumeFill2]] THEN      BEGIN UserTerminal.BlinkDisplay[]; RETURN; END;    mp.fill2[oldValue] ¬ markerPage.fill2CurrentValue;    markerPage.fill2CurrentValue ¬ mp.fill2[markerPage.fill2Index];    FormSW.DisplayItem[sw, fill2ValueIndex];    END;  NoticeNewLVBootFileType: FormSW.EnumeratedNotifyProcType =    BEGIN    mp.logical.bootingInfo[oldValue] ¬      markerPage.logical.currentBootingInfoDiskFileID;    DiskEditInternal.ReplaceUIDString[      @markerPage.logical.currentBootingInfoFileIDString, LOOPHOLE[mp.logical.bootingInfo[      markerPage.logical.currentBootingInfoFileType].fID, System.UniversalID]];    markerPage.logical.currentBootingInfoDiskFileID ¬ mp.logical.bootingInfo[      markerPage.logical.currentBootingInfoFileType];    FormSW.DisplayItem[sw, lvBootFileIDIndex];    FormSW.DisplayItem[sw, lvBootFileFirstPageIndex];    FormSW.DisplayItem[sw, lvBootFileDiskAddressA];    FormSW.DisplayItem[sw, lvBootFileDiskAddressB];    END;  NoticeNewPVBootFileType: FormSW.EnumeratedNotifyProcType =    BEGIN    mp.physical.bootingInfo[oldValue] ¬      markerPage.physical.currentBootingInfoDiskFileID;    mp.physical.bootingInfo[oldValue].da ¬      markerPage.physical.currentBootingInfoDiskFileID.da;    DiskEditInternal.ReplaceUIDString[      @markerPage.physical.currentBootingInfoFileIDString,      LOOPHOLE[mp.physical.bootingInfo[      markerPage.physical.currentBootingInfoFileType].fID, System.UniversalID]];    markerPage.physical.currentBootingInfoDiskFileID ¬ mp.physical.bootingInfo[      markerPage.physical.currentBootingInfoFileType];    FormSW.DisplayItem[sw, pvBootFileIDIndex];    FormSW.DisplayItem[sw, pvBootFileFirstPageIndex];    FormSW.DisplayItem[sw, pvBootFileDiskAddressA];    FormSW.DisplayItem[sw, pvBootFileDiskAddressB];    END;  ReplaceLabelString: PROCEDURE [    label: LONG POINTER TO LONG STRING, s: LONG DESCRIPTOR FOR PACKED ARRAY OF CHARACTER] =    BEGIN    volumeLabel: STRING ¬ [LogicalVolumeFormat.maxLogicalVolumeLabelLength];    volumeLabel.length ¬ 0;    FOR i: CARDINAL IN [0..MIN[LogicalVolumeFormat.maxLogicalVolumeLabelLength,  LENGTH[s]]) DO      volumeLabel[i] ¬ s[i];      volumeLabel.length ¬ volumeLabel.length + 1;      ENDLOOP;    String.Replace[label, volumeLabel, Heap.systemZone];    END;  ValidateVolumeRootDirectoryID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      markerPage.logical.rootDirectoryIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE {      arrayID: ARRAY [0..5) OF WORD ¬ LOOPHOLE[id];      fileID: ARRAY [0..2) OF WORD ¬ [arrayID[0], arrayID[1]];      mp.logical.volumeRootDirectory ¬ LOOPHOLE[fileID] };    END;  ValidateLVBootFileID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      markerPage.logical.currentBootingInfoFileIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE markerPage.logical.currentBootingInfoDiskFileID.fID ¬ LOOPHOLE[id];    END;  ValidateLVLabelLength: FormSW.NumberNotifyProcType =    BEGIN    IF markerPage.logical.labelLength ~IN [0..64) THEN      UserTerminal.BlinkDisplay[];    END;  ValidatePVBootFileID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      markerPage.physical.currentBootingInfoFileIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE markerPage.physical.currentBootingInfoDiskFileID.fID ¬ LOOPHOLE[id];    END;  ValidatePVFill: FormSW.NumberNotifyProcType =    BEGIN    IF markerPage.physical.fill ~IN [0..128) THEN UserTerminal.BlinkDisplay[];    END;  ValidatePVID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[markerPage.physical.IDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE mp.physical.pvID ¬ LOOPHOLE[id];    END;  ValidatePVSVID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[markerPage.physical.svIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE mp.physical.descriptor.lvID ¬ LOOPHOLE[id];    END;  ValidatePVSVNumber: FormSW.NumberNotifyProcType =    BEGIN    IF markerPage.physical.svNumber ~IN [0..8) THEN UserTerminal.BlinkDisplay[];    END;  -- Module initialization:  -- Register this subwindow as an alternate view for the data subwindow  WindowSwap.RegisterView[    key: DiskEditInternal.dataWindowKey,    viewName: "Marker page"L,    makeFormSW: MakeMarkerPageSW,    viewFromDataProc: FillMarkerPageSW,    dataFromViewProc: CleanupMarkerPageSW,    destroyViewProc: DestroyMarkerPageSW];  END.LOG17-Sep-81 11:01:01   WDK       Converted to new MarkerPage format and CommonSoftware 8.0.18-Nov-81 14:15:58   CAJ    LOOPHOLE'd Boot.DiskAddress pending upgrade to proper exported type.27-Apr-83 14:15:06   EKN        Update to Klamath29-Nov-83 17:02:09	EKN   	Changed items: markerPage.logical.labelLength, markerPage.logical.currentBootingInfoDiskFileID.firstPage, markerPage.physical.labelLength, mp.physical.maxBadPages, markerPage.physical.fill, markerPage.physical.svNumber, mp.physical.descriptor.lvSize, mp.physical.descriptor.nPages, mp.physical.descriptor.lvPage, mp.physical.descriptor.pvPage, markerPage.physical.currentBootingInfoDiskFileID.firstPage, mp.checksum, markerPage.fill1Index, markerPage.fill1CurrentValue, markerPage.fill2Index, markerPage.fill2CurrentValue  to display as decimals instead of octals. 5-Sep-84 14:02:31   CAJ    Add registering window view via WindowSwap.20-Nov-85 15:41:14   RSV    Fixed printing label string in ReplaceLabelString (AR 5599) 1-Mar-88  9:16:18   CAJ    Add DestroyMarkerPageSW.
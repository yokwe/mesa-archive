-- Copyright (C) 1984, 1987  by Xerox Corporation. All rights reserved. --MugCentral.mesa	last edited by: CAJ 	17-Dec-87 15:49:20-- Driver for the Disk Torment-and-Scavenge ToolDIRECTORY  Device USING [Type],  DiskChannel USING [Drive, GetDriveAttributes, GetNextDrive, nullDrive],  Environment USING [Base, first64K, wordsPerPage],  Exec USING [AddCommand, ExecProc, OutputProc, RemoveCommand],  File USING [nullID],  Format USING [StringProc],  FormSW USING [ClientItemsProcType],  HeadStartChain USING [Start],  Heap USING [Create, Delete],  Inline USING [LowHalf],  MsgSW USING [Clear],  MugInternal USING [Data, DataHandle, DiskDrive, DiskDriveHandle, MakeFileSW,    MakeTSW, MakeParamSW, MakeSSW, String],  PilotDisk USING [Handle, Label],  PilotDiskFace USING [Operation, operationAlignment, operationSize],  ProcessorFaceExtras USING [Version],  Put USING [Line, Text],  ResidentHeap USING [FreeNode, MakeNode],  Space USING [ScratchMap, Unmap],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc,    UnusedLogName],  ToolWindow USING [Activate, TransitionProcType],  UserTerminal USING [BlinkDisplay],  Window USING [Handle],  Zone USING [Status];MugCentral: PROGRAM  IMPORTS DiskChannel, Exec, HeadStartChain, Heap, Inline, MsgSW, MugInternal,    PilotDiskFace, ProcessorFaceExtras, Put, ResidentHeap, Space, Tool,    ToolWindow, UserTerminal  EXPORTS MugInternal SHARES DiskChannel =  BEGIN  -- Variable declarations  diskData: PUBLIC MugInternal.DiskDriveHandle ¬ NIL;  toolData: PUBLIC MugInternal.DataHandle ¬ NIL;  heap: PUBLIC UNCOUNTED ZONE ¬ NIL;  wh: Window.Handle ¬ NIL;  -- Tool's window    MuggerError: ERROR [ErrorType] = CODE;  ErrorType: TYPE = {heapAllocationProblem, noPilotDisk};    -- Tool and exec routines  ClientTransition: ToolWindow.TransitionProcType =    -- This procedure is called whenever the system determines that this    -- Tool's state is undergoing a user invoked transition.    BEGIN    IF old = new THEN RETURN;    SELECT TRUE FROM      old = inactive =>        BEGIN        IF heap = NIL THEN heap ¬ Heap.Create[initial: 2];        IF toolData = NIL THEN          BEGIN          toolData ¬ heap.NEW[MugInternal.Data];	  diskData ¬ heap.NEW[MugInternal.DiskDrive];	  InitData[];	  END;	END;      new = inactive =>        BEGIN        IF toolData # NIL THEN          BEGIN	  CleanupData[];          heap.FREE[@toolData];          heap.FREE[@diskData];	  toolData ¬ NIL;	  diskData ¬ NIL;	  END;	IF heap ~= NIL THEN {Heap.Delete[heap]; heap ¬ NIL};	END;      ENDCASE;    END;  Help: Exec.ExecProc =    BEGIN    OutputProc: Format.StringProc ¬ Exec.OutputProc[h];    h.OutputProc[][     "Mugger is a tool which provides a test environment for the scavengers."L];    END;  Init: PROCEDURE =    BEGIN    Exec.AddCommand["Mugger.~"L, MuggerCommand, Help, Unload];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "Mugger.log"L];    toolData.msgSW ¬ Tool.MakeMsgSW[window: window];    toolData.paramSW ¬      Tool.MakeFormSW[window: window, formProc: MugInternal.MakeParamSW];    toolData.tSW ¬ Tool.MakeFormSW[window: window, formProc: MugInternal.MakeTSW];    toolData.sSW ¬ Tool.MakeFormSW[window: window, formProc: MugInternal.MakeSSW];    toolData.fSW ¬      Tool.MakeFormSW[window: window, formProc: MugInternal.MakeFileSW];    toolData.logSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;  MakeTool: PROCEDURE RETURNS[wh: Window.Handle] =  BEGIN    HeadStartChain.Start[];  -- This must precede tool creation    RETURN[Tool.Create[      makeSWsProc: MakeSWs, initialState: default, tinyName1: "Mugger"L,      clientTransition: ClientTransition, name: "Disk Mugger"L]]    END;  MuggerCommand: Exec.ExecProc =     BEGIN    SELECT ProcessorFaceExtras.Version[].machineType FROM      dandelion, kiku, daylight =>         {IF wh # NIL THEN ToolWindow.Activate[wh]         ELSE wh ¬ MakeTool[]};      ENDCASE => h.OutputProc[][	"Mugging not supported on this machine; aborted."L];    END;   Unload: Exec.ExecProc =    BEGIN    IF wh # NIL THEN Tool.Destroy [wh];    wh ¬ NIL;    [] ¬ Exec.RemoveCommand[h, "Mugger.~"L];    END;  -- Supporting routines    BadCommand: PUBLIC PROC [s: MugInternal.String] =    BEGIN    UserTerminal.BlinkDisplay[];    Put.Text[toolData.msgSW, s];    Put.Line[toolData.msgSW, "; command aborted"L];    END;  CleanupData: PROCEDURE =    BEGIN    rp: Environment.Base RELATIVE POINTER =      Inline.LowHalf[diskData.operation - Environment.first64K];    [] ¬ ResidentHeap.FreeNode[rp];    diskData.dataPtr ¬ Space.Unmap[diskData.dataPtr];    diskData.labelPtr ¬ Space.Unmap[diskData.labelPtr];    END;    InitData: PROCEDURE =    BEGIN    d: DiskChannel.Drive;    dH: PilotDisk.Handle;    rp: Environment.Base RELATIVE POINTER TO PilotDiskFace.Operation;    status: Zone.Status;     -- init toolData    toolData.mode ¬ interactive;    toolData.volume ¬ toolData.logVol ¬ 0;    toolData.verbose ¬ toolData.perm ¬ FALSE;    toolData.repair ¬ checkOnly;    toolData.fileIDString ¬ NIL;    toolData.fileID ¬ File.nullID;    toolData.filePage ¬ 0;    toolData.pvPage ¬ 0;    toolData.pageTranslation ¬ pvPage;    toolData.fileSize ¬ 1;    toolData.fileType ¬ LOOPHOLE[177777B];  -- make compiler happy    toolData.fileCount ¬ 1;        -- init diskData    d ¬ DiskChannel.GetNextDrive[DiskChannel.nullDrive];    diskData.drive ¬ d;    IF d = DiskChannel.nullDrive THEN ERROR MuggerError[noPilotDisk];    dH ¬ DiskChannel.GetDriveAttributes[d].deviceHandle;    diskData.deviceHandle ¬ dH;    [rp, status] ¬ ResidentHeap.MakeNode[      n: PilotDiskFace.operationSize,      alignment: SELECT PilotDiskFace.operationAlignment FROM        16 => a16, 8 => a8, 4 => a4, 2 => a2, ENDCASE => a1];    IF status ~= okay THEN ERROR MuggerError[heapAllocationProblem];    diskData.operation ¬ @Environment.first64K[rp];    diskData.dataPtr ¬ Space.ScratchMap[2];    diskData.labelPtr ¬ Space.ScratchMap[1];    diskData.saveData ¬ diskData.dataPtr + Environment.wordsPerPage;    diskData.saveLabel ¬ diskData.labelPtr+ 3*SIZE[PilotDisk.Label];      -- well out of way    diskData.savePage ¬ LONG[-1];  -- illegal page    diskData.undoValid ¬ FALSE;    END;  NewCommand: PUBLIC PROC =    {MsgSW.Clear[toolData.msgSW]};  Unimplemented: PUBLIC PROC =    BEGIN    Put.Line[toolData.msgSW, "Not implemented"L];    END;      -- Mainline code  Init[];  -- this gets string out of global frame  END...  LOG  Time:    10-Sep-81 14:48:39  By: CAJ 	 Action: Created file.  Time:     4-Dec-81 16:13:55  By: CAJ 	 Action: Converted to PilotDiskFace.  Time:	   14-Apr-83  9:56:12  By: EKN    Action: Converted to Klamath (Space stuff)  Time:    14-Jun-84 14:52:32  By: CAJ 	 Action: Register Exec command, converted from Storage to Heap.  Time:    17-Dec-87 15:48:21  By: CAJ 	 Action: Abort startup if running on head which doesn't support mugging.  Correct initial fileType, op alignment.
-- Copyright (C) 1984, 1988  by Xerox Corporation. All rights reserved. -- File: DiskEditPvRootPageSW.mesa   1-Mar-88  9:22:28 by CAJ  DIRECTORY  Boot USING [BootFileType, DiskAddress],  DiskEditInternal USING [dataPtr, dataWindowKey, ReplaceUIDString, ValidateUID],  File USING [PageNumber],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    FilterProcType, ItemHandle, LabelItem, LongNumberItem, MenuProcType, newLine,    nextPlace, NumberItem, NumberNotifyProcType, ProcType, StringEditProc,    StringItem],  Heap USING [systemZone],  PhysicalVolumeFormat USING [    currentVersion, Descriptor, maxSubVols, PageNumber, physicalVolumeLabelLength,    seal, Seal, SubVolumeDesc],  String USING [AppendChar, FreeString, MakeString, Replace],  System USING [LocalTimeParameters, UniversalID, WestEast],  UserTerminal USING [BlinkDisplay],  Volume USING [nullID],  WindowSwap USING [RegisterView];DiskEditPVRootPageSW: PROGRAM  IMPORTS DiskEditInternal, FormSW, Heap, String, UserTerminal, WindowSwap  SHARES Boot =  BEGIN  currentFillIndexIndex: CARDINAL ¬ 0;  currentFillValueIndex: CARDINAL ¬ 0;  currentSubvolumeLVIDIndex: CARDINAL ¬ 0;  currentSubvolumeLVSizeIndex: CARDINAL ¬ 0;  currentSubvolumeLVPageIndex: CARDINAL ¬ 0;  currentSubvolumePVPageIndex: CARDINAL ¬ 0;  currentSubvolumeNPagesIndex: CARDINAL ¬ 0;  currentBootingInfoFileIDIndex: CARDINAL ¬ 0;  currentBootingInfoFirstPageIndex: CARDINAL ¬ 0;  currentBootingInfoDaAIndex: CARDINAL ¬ 0;  currentBootingInfoDaBIndex: CARDINAL ¬ 0;  validatePhysicalVolumeRootPage: BOOLEAN [TRUE..TRUE] =    PhysicalVolumeFormat.currentVersion = 6;  LtpZone: TYPE = [0..12];  LtpZoneMinutes: TYPE = [0..59];  LtpBeginDST: TYPE = [0..366];  LtpEndDST: TYPE = [0..366];  Pair: TYPE = RECORD [UNSPECIFIED, UNSPECIFIED];    pvRootPage: RECORD [    -- The fields in here which are passed to a FormSW must be word-aligned.    IDString: LONG STRING ¬ NIL,    labelString: LONG STRING ¬ NIL,    subVolumeMarkerIDString: LONG STRING ¬ NIL,    currentBootingInfoType: Boot.BootFileType[hardMicrocode..pilot] ¬ hardMicrocode,    currentSubvolumeIndex: CARDINAL ¬ 0,    currentSubvolumeIDString: LONG STRING ¬ NIL,    currentBootingInfoFileIDString: LONG STRING ¬ NIL,    currentSubvolume: PhysicalVolumeFormat.SubVolumeDesc ¬      [Volume.nullID, 0, 0, 0, 0],    currentBootingInfoFirstPage: File.PageNumber ¬ 0,    currentBootingInfoDiskAddress: Boot.DiskAddress ¬ LOOPHOLE[Pair[0, 0]],      -- make LOOPHOLE proper exported type    ltpsValid: BOOLEAN ¬ FALSE,    alignFillerA: WORD,    ltpDirection: System.WestEast ¬ west,    ltpZone: CARDINAL ¬ 0,    ltpZoneMinutes: CARDINAL ¬ 0,    ltpBeginDST: CARDINAL ¬ 0,    ltpEndDST: CARDINAL ¬ 0,    currentFillIndex: CARDINAL ¬ 0,    currentFillValue: CARDINAL ¬ 0 ];      pv: LONG POINTER TO PhysicalVolumeFormat.Descriptor =    LOOPHOLE[DiskEditInternal.dataPtr];      CleanupPvRootPageSW: PROCEDURE =    BEGIN    pv.subVolumes[pvRootPage.currentSubvolumeIndex] ¬ pvRootPage.currentSubvolume;    pv.bootingInfo[pvRootPage.currentBootingInfoType].firstPage ¬      pvRootPage.currentBootingInfoFirstPage;    pv.bootingInfo[pvRootPage.currentBootingInfoType].da ¬      pvRootPage.currentBootingInfoDiskAddress;    pv.localTimeParametersValid ¬ pvRootPage.ltpsValid;    pv.localTimeParameters.direction ¬ pvRootPage.ltpDirection;    pv.localTimeParameters.zone ¬ pvRootPage.ltpZone;    pv.localTimeParameters.zoneMinutes ¬ pvRootPage.ltpZoneMinutes;    pv.localTimeParameters.beginDST ¬ pvRootPage.ltpBeginDST;    pv.localTimeParameters.endDST ¬ pvRootPage.ltpEndDST;    IF pvRootPage.currentFillIndex IN [0..LENGTH[pv.fill1]) THEN      pv.fill1[pvRootPage.currentFillIndex] ¬ pvRootPage.currentFillValue;    END;  CopyLabel: FormSW.FilterProcType =    BEGIN    FormSW.StringEditProc[sw, item, insert, string];    FOR i: CARDINAL IN      [0..MIN[         PhysicalVolumeFormat.physicalVolumeLabelLength,         pvRootPage.IDString.length]) DO      pv.label[i] ¬ pvRootPage.labelString[i]; ENDLOOP;    END;  DestroyPvRootPageSW: PROCEDURE =    BEGIN    -- Clean up resources for view going away for good.    String.FreeString[z: Heap.systemZone, s: pvRootPage.IDString];    pvRootPage.IDString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: pvRootPage.labelString];    pvRootPage.labelString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: pvRootPage.subVolumeMarkerIDString];    pvRootPage.subVolumeMarkerIDString ¬ NIL;    String.FreeString[z: Heap.systemZone, s: pvRootPage.currentSubvolumeIDString];    pvRootPage.currentSubvolumeIDString ¬ NIL;    String.FreeString[      z: Heap.systemZone, s: pvRootPage.currentBootingInfoFileIDString];    pvRootPage.currentBootingInfoFileIDString ¬ NIL;    END;  FillPvRootPageSW: PROCEDURE =    BEGIN    labelLength: CARDINAL =      MIN[PhysicalVolumeFormat.physicalVolumeLabelLength, pv.labelLength];    DiskEditInternal.ReplaceUIDString[@pvRootPage.IDString, pv.pvID];    String.Replace[@pvRootPage.labelString, NIL, Heap.systemZone];    pvRootPage.labelString ¬ String.MakeString[Heap.systemZone, labelLength];    FOR i: CARDINAL IN [0..labelLength) DO      String.AppendChar[pvRootPage.labelString, pv.label[i]]; ENDLOOP;    DiskEditInternal.ReplaceUIDString[      @pvRootPage.subVolumeMarkerIDString, pv.subVolumeMarkerID];    pvRootPage.currentSubvolume ¬ pv.subVolumes[pvRootPage.currentSubvolumeIndex];    DiskEditInternal.ReplaceUIDString[      @pvRootPage.currentSubvolumeIDString, pv.subVolumes[      pvRootPage.currentSubvolumeIndex].lvID];    DiskEditInternal.ReplaceUIDString[      @pvRootPage.currentBootingInfoFileIDString, LOOPHOLE[pv.bootingInfo[      pvRootPage.currentBootingInfoType].fID]];    pvRootPage.currentBootingInfoFirstPage ¬ pv.bootingInfo[      pvRootPage.currentBootingInfoType].firstPage;    pvRootPage.currentBootingInfoDiskAddress ¬ pv.bootingInfo[      pvRootPage.currentBootingInfoType].da;    pvRootPage.ltpsValid ¬ pv.localTimeParametersValid;    pvRootPage.ltpDirection ¬ pv.localTimeParameters.direction;    pvRootPage.ltpZone ¬ pv.localTimeParameters.zone;    pvRootPage.ltpZoneMinutes ¬ pv.localTimeParameters.zoneMinutes;    pvRootPage.ltpBeginDST ¬ pv.localTimeParameters.beginDST;    pvRootPage.ltpEndDST ¬ pv.localTimeParameters.endDST;    pvRootPage.currentFillValue ¬ pv.fill1[pvRootPage.currentFillIndex];    END;  MakePvRootPageSW: FormSW.ClientItemsProcType =    BEGIN    i: CARDINAL ¬ 0;    nItems: CARDINAL = 36;    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[0] ¬ FormSW.LabelItem[tag: NIL, invisible: TRUE, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LabelItem[      tag: "Physical volume root page"L, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: TRUE, string: @pvRootPage.IDString,      filterProc: ValidatePVID, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Seal"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: PhysicalVolumeFormat.seal, value: @pv.seal, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Version"L, signed: FALSE, notNegative: TRUE, radix: octal,      default: PhysicalVolumeFormat.currentVersion, value: @pv.version,      place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "Max bad pages"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pv.maxBadPages, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Online count"L, notNegative: TRUE, signed: FALSE, radix: decimal,      default: 0, value: @pv.onLineCount, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "Bad page count"L, notNegative: TRUE, signed: FALSE, radix: decimal,      default: 0, value: @pv.badPageCount, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Subvolume Count"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pv.subVolumeCount, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Label length"L, notNegative: TRUE, signed: FALSE, radix: decimal,      default: 0, value: @pv.labelLength, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.StringItem[      tag: "Label"L, inHeap: TRUE, string: @pvRootPage.labelString,      filterProc: CopyLabel, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.StringItem[      tag: "Subvolume Marker ID"L, inHeap: TRUE, filterProc: ValidateSVMarkerID,      string: @pvRootPage.subVolumeMarkerIDString, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Current Subvolume"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, proc: NoticeNewSubvolumeIndex,      value: @pvRootPage.currentSubvolumeIndex, place: FormSW.newLine];    items[currentSubvolumeLVIDIndex ¬ i ¬ i + 1] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: TRUE, string: @pvRootPage.currentSubvolumeIDString,      filterProc: ValidateSVID, place: FormSW.nextPlace];    items[currentSubvolumeLVSizeIndex ¬ i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "   Logical volume size"L, signed: FALSE, notNegative: TRUE,      radix: decimal, default: 0, value: @pvRootPage.currentSubvolume.lvSize,      place: FormSW.newLine];    items[currentSubvolumeNPagesIndex ¬ i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "Subvolume size"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pvRootPage.currentSubvolume.nPages,      place: FormSW.nextPlace];    items[currentSubvolumeLVPageIndex ¬ i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "   LV page #"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pvRootPage.currentSubvolume.lvPage,      place: FormSW.newLine];    items[currentSubvolumePVPageIndex ¬ i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "PV page #"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pvRootPage.currentSubvolume.pvPage,      place: FormSW.nextPlace];    BEGIN    enumeratedPVBootFiles: ARRAY [0..4) OF FormSW.Enumerated ¬ [      [string: "hardMicrocode"L, value: Boot.BootFileType[hardMicrocode]], [      string: "softMicrocode"L, value: Boot.BootFileType[softMicrocode]], [      string: "germ"L, value: Boot.BootFileType[germ]], [      string: "pilot"L, value: Boot.BootFileType[pilot]]];    items[i ¬ i + 1] ¬ FormSW.EnumeratedItem[      tag: "Boot file for type"L, feedback: one, copyChoices: TRUE,      value: @pvRootPage.currentBootingInfoType, proc: NoticeNewBootFileType,      choices: DESCRIPTOR[enumeratedPVBootFiles], place: FormSW.newLine];    items[currentBootingInfoFileIDIndex ¬ i ¬ i + 1] ¬ FormSW.StringItem[      tag: "ID"L, inHeap: TRUE,      string: @pvRootPage.currentBootingInfoFileIDString,      filterProc: ValidateBootFileID, place: FormSW.nextPlace];    items[currentBootingInfoFirstPageIndex ¬ i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "  First page"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pvRootPage.currentBootingInfoFirstPage,      place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LabelItem[      tag: "BootDiskAddress", place: FormSW.nextPlace];    items[currentBootingInfoDaAIndex ¬ i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "a"L, signed: FALSE, notNegative: TRUE, radix: octal, default: 0,      value: @pvRootPage.currentBootingInfoDiskAddress, place: FormSW.nextPlace];    items[currentBootingInfoDaBIndex ¬ i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "b"L, signed: FALSE, notNegative: TRUE, radix: octal, default: 0,      value: 1 + @pvRootPage.currentBootingInfoDiskAddress,      place: FormSW.nextPlace];    END;    BEGIN    enumeratedDirections: ARRAY [0..2) OF FormSW.Enumerated ¬ [      [string: "east"L, value: System.WestEast[east]], [      string: "west"L, value: System.WestEast[west]]];    items[i ¬ i + 1] ¬ FormSW.LabelItem[      tag: "Local time parameters"L, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.BooleanItem[      tag: "valid"L, switch: @pvRootPage.ltpsValid, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.EnumeratedItem[      tag: "  Direction"L, feedback: all, copyChoices: TRUE,      value: @pvRootPage.ltpDirection, choices: DESCRIPTOR[enumeratedDirections],      place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Zone"L, signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @pvRootPage.ltpZone, proc: ValidateLtpZone, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Zone minutes"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pvRootPage.ltpZoneMinutes, proc: ValidateLtpZoneMinutes,      place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "  Begin DST"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @pvRootPage.ltpBeginDST, proc: ValidateLtpBeginDST,      place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "End DST"L, signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @pvRootPage.ltpEndDST, proc: ValidateLtpEndDST,      place: FormSW.nextPlace];    END;    items[i ¬ i + 1] ¬ FormSW.LabelItem[tag: "Fill1"L, place: FormSW.newLine];    items[currentFillIndexIndex ¬ i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Index"L, signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @pvRootPage.currentFillIndex, proc: NoticeNewFillIndex,      place: FormSW.newLine];    items[currentFillValueIndex ¬ i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Value", signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @pvRootPage.currentFillValue, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.CommandItem[      tag: "Next", proc: FillNextCommand, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.CommandItem[      tag: "Back", proc: FillBackCommand, place: FormSW.nextPlace];    IF i ~= nItems - 1 THEN ERROR;  -- indicates that items is incompletely initialized    RETURN[items, TRUE]    END;  FillBackCommand: FormSW.ProcType =    BEGIN    IF pvRootPage.currentFillValue IN [0..LENGTH[pv.fill1]) THEN      pv.fill1[pvRootPage.currentFillValue] ¬ pvRootPage.currentFillValue;    pvRootPage.currentFillIndex ¬      IF pvRootPage.currentFillIndex = 0 THEN LENGTH[pv.fill1] - 1      ELSE pvRootPage.currentFillIndex - 1;    pvRootPage.currentFillValue ¬ pv.fill1[pvRootPage.currentFillIndex];    FormSW.DisplayItem[sw, currentFillIndexIndex];    FormSW.DisplayItem[sw, currentFillValueIndex];    END;  FillNextCommand: FormSW.ProcType =    BEGIN    IF pvRootPage.currentFillValue IN [0..LENGTH[pv.fill1]) THEN      pv.fill1[pvRootPage.currentFillValue] ¬ pvRootPage.currentFillValue;    pvRootPage.currentFillIndex ¬      (pvRootPage.currentFillIndex + 1) MOD LENGTH[pv.fill1];    pvRootPage.currentFillValue ¬ pv.fill1[pvRootPage.currentFillIndex];    FormSW.DisplayItem[sw, currentFillIndexIndex];    FormSW.DisplayItem[sw, currentFillValueIndex];    END;  NoticeNewBootFileType: FormSW.EnumeratedNotifyProcType =    BEGIN    pv.bootingInfo[oldValue].firstPage ¬ pvRootPage.currentBootingInfoFirstPage;    pv.bootingInfo[oldValue].da ¬ pvRootPage.currentBootingInfoDiskAddress;    DiskEditInternal.ReplaceUIDString[      @pvRootPage.currentBootingInfoFileIDString, LOOPHOLE[pv.bootingInfo[      pvRootPage.currentBootingInfoType].fID]];    pvRootPage.currentBootingInfoDiskAddress ¬ pv.bootingInfo[      pvRootPage.currentBootingInfoType].da;    pvRootPage.currentBootingInfoFirstPage ¬ pv.bootingInfo[      pvRootPage.currentBootingInfoType].firstPage;    FormSW.DisplayItem[sw, currentBootingInfoFileIDIndex];    FormSW.DisplayItem[sw, currentBootingInfoFirstPageIndex];    FormSW.DisplayItem[sw, currentBootingInfoDaAIndex];    FormSW.DisplayItem[sw, currentBootingInfoDaBIndex];    END;  NoticeNewFillIndex: FormSW.NumberNotifyProcType =    BEGIN    IF oldValue IN [0..LENGTH[pv.fill1]) THEN      pv.fill1[oldValue] ¬ pvRootPage.currentFillValue;    IF pvRootPage.currentFillIndex ~IN [0..LENGTH[pv.fill1]) THEN {      UserTerminal.BlinkDisplay[]; RETURN};    pvRootPage.currentFillValue ¬ pv.fill1[pvRootPage.currentFillIndex];    FormSW.DisplayItem[sw, currentFillValueIndex];    END;  NoticeNewSubvolumeIndex: FormSW.NumberNotifyProcType =    BEGIN    IF oldValue IN [0..PhysicalVolumeFormat.maxSubVols) THEN      pv.subVolumes[oldValue] ¬ pvRootPage.currentSubvolume;    IF pvRootPage.currentSubvolumeIndex ~IN [0..PhysicalVolumeFormat.maxSubVols)      THEN {UserTerminal.BlinkDisplay[]; RETURN};    pvRootPage.currentSubvolume ¬ pv.subVolumes[pvRootPage.currentSubvolumeIndex];    DiskEditInternal.ReplaceUIDString[      @pvRootPage.currentSubvolumeIDString, pvRootPage.currentSubvolume.lvID];    FormSW.DisplayItem[sw, currentSubvolumeLVIDIndex];    FormSW.DisplayItem[sw, currentSubvolumeLVSizeIndex];    FormSW.DisplayItem[sw, currentSubvolumeLVPageIndex];    FormSW.DisplayItem[sw, currentSubvolumePVPageIndex];    FormSW.DisplayItem[sw, currentSubvolumeNPagesIndex];    END;  ValidateBootFileID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      pvRootPage.currentBootingInfoFileIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE pv.bootingInfo[pvRootPage.currentBootingInfoType].fID ¬ LOOPHOLE[id];    END;  ValidateLtpBeginDST: FormSW.NumberNotifyProcType =    BEGIN    IF pvRootPage.ltpBeginDST ~IN [FIRST[LtpBeginDST]..LAST[LtpBeginDST]] THEN      UserTerminal.BlinkDisplay[]    ELSE pv.localTimeParameters.beginDST ¬ pvRootPage.ltpBeginDST;    END;  ValidateLtpEndDST: FormSW.NumberNotifyProcType =    BEGIN    IF pvRootPage.ltpEndDST ~IN [FIRST[LtpBeginDST]..LAST[LtpEndDST]] THEN      UserTerminal.BlinkDisplay[]    ELSE pv.localTimeParameters.endDST ¬ pvRootPage.ltpEndDST;    END;  ValidateLtpZone: FormSW.NumberNotifyProcType =    BEGIN    IF pvRootPage.ltpZone ~IN [FIRST[LtpZone]..LAST[LtpZone]] THEN      UserTerminal.BlinkDisplay[]    ELSE pv.localTimeParameters.zone ¬ pvRootPage.ltpZone;    END;  ValidateLtpZoneMinutes: FormSW.NumberNotifyProcType =    BEGIN    IF pvRootPage.ltpZoneMinutes ~IN [FIRST[LtpZoneMinutes]..LAST[LtpZoneMinutes]]      THEN UserTerminal.BlinkDisplay[]    ELSE pv.localTimeParameters.zoneMinutes ¬ pvRootPage.ltpZoneMinutes;    END;  ValidatePVID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[pvRootPage.IDString];    IF ~valid THEN UserTerminal.BlinkDisplay[] ELSE pv.pvID ¬ LOOPHOLE[id];    END;  ValidateSVID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      pvRootPage.currentSubvolumeIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE pvRootPage.currentSubvolume.lvID ¬ LOOPHOLE[id];    END;  ValidateSVMarkerID: FormSW.FilterProcType =    BEGIN    valid: BOOLEAN;    id: System.UniversalID;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[      pvRootPage.currentSubvolumeIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE pv.subVolumeMarkerID ¬ LOOPHOLE[id];    END;  -- Module initialization:  -- Register this subwindow as an alternate view for the data subwindow  WindowSwap.RegisterView[    key: DiskEditInternal.dataWindowKey,    viewName: "PV root page"L,    makeFormSW: MakePvRootPageSW,    viewFromDataProc: FillPvRootPageSW,    dataFromViewProc: CleanupPvRootPageSW,     destroyViewProc: DestroyPvRootPageSW];  END.LOG10-Sep-81 11:58:51   WDK       Converted to Pilot 8, Tajo 8.18-Nov-81 14:54:08   CAJ    LOOPHOLE'd init of currentBootingInfoDiskAddress pending upgrade to exported type.13-May-82  9:34:34   AWL         Copy all appropriate stuff in Cleanup and Fill routines..25-Apr-83 18:00:27   EKN      Update To Klamath (LOOPHOLE PilotDisk.FileID to System.UniversalID for DiskEditInternal.ReplaceUIDString). Replace Storage interface with String.29-Nov-83 17:34:30	EKN      Changed items:  pv.maxBadPages, pv.onLineCount, pv.badPageCount, pv.subVolumeCount, pv.labelLength, pvRootPage.currentSubvolumeIndex, pvRootPage.currentSubvolume.lvSize, pvRootPage.currentSubvolume.nPages,pvRootPage.currentSubvolume.lvPage, pvRootPage.currentSubvolume.pvPage, pvRootPage.currentBootingInfoFirstPage, pvRootPage.ltpZone, pvRootPage.ltpZoneMinutes, pvRootPage.ltpBeginDST, pvRootPage.ltpEndDST, pvRootPage.currentFillIndex, pvRootPage.currentFillValue to display decimal instead of octal.   16-Jan-84 11:43:57   KEK       Fill failed to copy ltpsValid. 5-Sep-84 14:03:41   CAJ    Added registering window view via WindowSwap, fix Fill proc's get label string. 1-Mar-88  9:22:12   CAJ    Added DestroyPvRootPageSW.
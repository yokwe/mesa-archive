-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- MugScavenge.mesa	last edited by: CAJ 	15-Jun-84 14:08:47-- Scavenge Subwindow handling for the Disk Torment-and-Scavenge ToolDIRECTORY  File USING [File],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, Enumerated,    EnumeratedDescriptor, EnumeratedItem, line0, line1, line2, ProcType],  MugInternal USING [BadCommand, heap, NewCommand, nVolumes, toolData,    Unimplemented, volumeDescriptor, WriteFileID],  Put USING [Line, Text],  Scavenger USING [Error, ErrorType, RepairType, Scavenge],  Volume USING [GetStatus, GetType, SystemID];MugScavenge: PROGRAM  IMPORTS FormSW, MugInternal, Put, Scavenger, Volume  EXPORTS MugInternal =  BEGIN    checkOnly: Scavenger.RepairType ¬ checkOnly;  safeRepair: Scavenger.RepairType ¬ safeRepair;  riskyRepair: Scavenger.RepairType ¬ riskyRepair;  choicesDescriptor: FormSW.EnumeratedDescriptor ¬ DESCRIPTOR[choicesArray];      choicesArray: ARRAY [0..3) OF FormSW.Enumerated ¬ [    ["checkOnly", checkOnly],    ["safeRepair", safeRepair],    ["riskyRepair", riskyRepair]];      MakeSSW: PUBLIC FormSW.ClientItemsProcType =    BEGIN OPEN F: FormSW, M: MugInternal;    i: CARDINAL ¬ 0;    nItems: CARDINAL = 6;    items ¬ F.AllocateItemDescriptor[nItems];    items[i] ¬ F.CommandItem[      tag: "Scavenge LV"L, place: [0, F.line0], proc: ScavengeLV];    items[i¬i+1] ¬ F.CommandItem[      tag: "Scavenge PV"L, place: [125, F.line0], proc: ScavengePV];    items[i¬i+1] ¬ F.CommandItem[      tag: "Client Scavenger"L, place: [250, F.line0], proc: ClientScavenge];    items[i¬i+1] ¬ F.EnumeratedItem[      tag: "Log destination"L, feedback: one, place: [35, F.line1],      value: @M.toolData.logVol, choices: M.volumeDescriptor];      -- Check log volume ~= scavenge volume    items[i¬i+1] ¬ F.EnumeratedItem[      tag: "Repair"L, feedback: one, place: [350, F.line1], value: @M.toolData.repair, choices: choicesDescriptor];    items[i¬i+1] ¬ F.CommandItem[      tag: "(Other scavenger ops)"L, place: [0, F.line2], proc: Other];        --  release space we have gathered    FOR i: CARDINAL IN [0..M.nVolumes) DO      MugInternal.heap.FREE[@M.volumeDescriptor[i].string] ENDLOOP;    MugInternal.heap.FREE[@(BASE[M.volumeDescriptor])];    RETURN[items: items, freeDesc: TRUE];    END;      ScavengeLV: FormSW.ProcType =    BEGIN -- so er will be in outer block for EXITS    er: Scavenger.ErrorType;    BEGIN OPEN t: MugInternal.toolData;    file: File.File;    MugInternal.NewCommand[];    SELECT Volume.GetStatus[t.volIDs[t.volume]] FROM      openRead, openReadWrite => GOTO volOpen;      ENDCASE => NULL;    IF Volume.GetStatus[t.volIDs[t.logVol]] ~= openReadWrite THEN GOTO noLogVol;    IF Volume.GetType[t.volIDs[t.volume]] > Volume.GetType[Volume.SystemID[]]      THEN GOTO higherType;    Put.Text[t.logSW, "Scavenging LV... "L];    file ¬ Scavenger.Scavenge[      volume: t.volIDs[t.volume], logDestination: t.volIDs[t.logVol],      repair: t.repair, okayToConvert:FALSE      ! Scavenger.Error => {er ¬ error; GOTO scavengeError}];    Put.Text[t.logSW, "log= "L];    MugInternal.WriteFileID[t.logSW, file];    Put.Line[t.logSW, "...done"L];    EXITS      higherType => MugInternal.BadCommand["Can't scavenge higher type volume"L];      noLogVol => MugInternal.BadCommand["Log volume not open"L];      scavengeError =>        BEGIN	 Put.Line[t.logSW, SELECT er FROM	   cannotWriteLog => "cannot write log"L,	   diskHardwareError => "disk error"L,	   diskNotReady => "disk not ready"L,	   needsConversion => "needs conversion"L,	   ENDCASE => "unexpected status"L];	 END;      volOpen => MugInternal.BadCommand["Scavenge volume open"L];    END;    END;  ClientScavenge,  ScavengePV,  Other: FormSW.ProcType =    {MugInternal.Unimplemented[]};  END.LOG  Time:    10-Sep-81 15:15:34  By: CAJ 	 Action: Created file.  Time:     2-Oct-81 16:20:26  By: CAJ 	 Action: Added implementation for ScavengeLV.  Time:     5-Dec-81 12:56:07  By: CAJ 	 Action: Converted to 8.0e.  Time:    14-Apr-83 10:00:45  By: EKN    Action: Converted to Klamath    Time:    29-Jul-83 15:08:31  By: JXG     Action: okayToConvert no longer defaulted  Time:    15-Jun-84 14:05:36  By: CAJ 	 Action: Use heap instead of Storage.
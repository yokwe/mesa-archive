-- SwapBeaterImpl.mesa	Last edited by: CAJ  on:  7-Apr-86  8:24:52-- Copyright (C) 1986  by Xerox Corporation. All rights reserved. DIRECTORY  Environment USING [Long, PageCount, PageNumber],  Format USING [NumberFormat],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, Enumerated,    EnumeratedItem, line0, line1, line2, line3, LongNumberItem,    NumberItem, NumberNotifyProcType, ProcType, TagOnlyItem],  Heap USING [systemZone],  Inline USING [HighHalf, LowHalf],  MsgSW USING [Clear, Post],  Process USING [    Detach, DisableAborts, DisableTimeout, InitializeCondition, Pause, Priority,    priorityBackground, priorityForeground, priorityNormal, Seconds,    SecondsToTicks, SetPriority, SetTimeout, Yield],  ProcessorFace USING [GetNextAvailableVM],  Put USING [CR, LongNumber, LongString, Number],  RandomDefs USING [GeneratorState, InitializeRandom, Random],  Runtime USING [IsBound],  Space USING [    Activate, Deactivate, ForceOut, Interval, LongPointerFromPage, MDS,    virtualMemory],  String USING [AppendChar, AppendLongDecimal],  Time USING [AppendCurrent],  Tool USING [    Create, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [State, TransitionProcType],  UserTerminal USING [BlinkDisplay],  Window USING [Handle];SwapBeaterImpl: MONITOR  IMPORTS    FormSW, Heap, Inline, MsgSW, Process, ProcessorFace, Put, RandomDefs,    Runtime, Space, String, Time, Tool, UserTerminal =  BEGIN  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    -- Elements less than a word long are carefully sandwiched between full-word    -- values so that tool addressing will come out right.    msgSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    processes: CARDINAL ¬ 1,    priority: Priorities ¬ background,    randomSeed: LONG UNSPECIFIED ¬ 2097151,    state: State ¬ stopped,    forkedProcesses: CARDINAL ¬ 0,    activateWeight: CARDINAL ¬ 50,    deactivateWeight: CARDINAL ¬ 40,    forceOutWeight: CARDINAL ¬ 10,    vmWeight: CARDINAL ¬ 75,    mdsWeight: CARDINAL ¬ 20,    randomWeight: CARDINAL ¬ 5,    statsInterval: CARDINAL ¬ 30,    activates: LONG CARDINAL ¬ 0,    deactivates: LONG CARDINAL ¬ 0,    forceOuts: LONG CARDINAL ¬ 0,    random: RandomDefs.GeneratorState ¬ TRASH,    savedState: MACHINE DEPENDENT RECORD [      processes(0): CARDINAL ¬ 0,      priority(1): Priorities ¬ background,      randomSeed(2): LONG UNSPECIFIED ¬ 2097151]    ];  FormItems: TYPE = {processes, priority, randomSeed, opWeight, activate,    deactivate, forceOut, intWeight, vm, mds, random, start, stats, stop,    statsInterval};    Priorities: TYPE = MACHINE DEPENDENT {    background(0), normal(1), foreground(2), random(3)};    State: TYPE = {running, stopped, stopping};  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  processStopped: CONDITION;  statsInterval: CONDITION;  -- current operation range boundaries  pause: CARDINAL ¬ 5;  switchPriority: CARDINAL ¬ 10;  activate: CARDINAL;  deactivate: CARDINAL;  forceOut: CARDINAL;  opMax: CARDINAL ¬ 100 + switchPriority;  -- interval range boundaries  vm: CARDINAL;  mds: CARDINAL;  random: CARDINAL;  intervalMaxRange: CARDINAL ¬ 100;  lastVMPage: Environment.PageNumber;  numberFormat: Format.NumberFormat = [    base: 10, zerofill: FALSE, unsigned: TRUE, columns: 10];  numberFormatLeftJust: Format.NumberFormat = [    base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0];  BeaterProcess: PROCEDURE [] =    BEGIN    BEGIN ENABLE ABORTED => GO TO Return;    Stopped: ENTRY PROCEDURE RETURNS [BOOLEAN] = {RETURN [data.state ~= running]};    WaitABit: PROCEDURE = {Process.Pause[1+RandomNumber[100]]};    IncrementLongCardinal: ENTRY PROCEDURE [lc: LONG POINTER TO LONG CARDINAL] =      {lc­ ¬ lc­+1};    Process.SetPriority[      SELECT data.savedState.priority FROM        background => Process.priorityBackground,	normal => Process.priorityNormal,	foreground => Process.priorityForeground,	random => RandomPriority[],	ENDCASE => Process.priorityBackground];    UNTIL Stopped[] DO      interval: Space.Interval ¬ ChooseInterval[];      Process.Yield[]; -- for politeness!      SELECT RandomNumber[opMax] FROM	IN [0..pause) => WaitABit[];	IN [pause..switchPriority) =>	  IF data.savedState.priority = random THEN	    Process.SetPriority[RandomPriority[]]	  ELSE NULL; -- and try again for a new command	IN [switchPriority..activate) =>	  BEGIN	  Space.Activate[interval];	  IncrementLongCardinal[@data.activates];	  END;	IN [activate..deactivate) =>	  BEGIN	  Space.Deactivate[interval];	  IncrementLongCardinal[@data.deactivates];	  END;	IN [deactivate..forceOut) =>	  BEGIN	  Space.ForceOut[interval];	  IncrementLongCardinal[@data.forceOuts];	  END;	ENDCASE;  -- should never get here      ENDLOOP;    GO TO Return;    END    EXITS    Return =>      BEGIN      Dying: ENTRY PROCEDURE =        BEGIN	data.forkedProcesses ¬ data.forkedProcesses-1;	NOTIFY processStopped;	END;      Dying[];      END;    END;  -- BeaterProcess  BriefStats: PROCEDURE =    BEGIN    s: STRING = [30];    String.AppendLongDecimal[s, data.activates];    String.AppendChar[s, '/];    String.AppendLongDecimal[s, data.deactivates];    String.AppendChar[s, '/];    String.AppendLongDecimal[s, data.forceOuts];    String.AppendChar[s, ' ];    Put.LongString[data.fileSW, s];    END;  -- BriefStats  ChooseInterval: PROCEDURE RETURNS [i: Space.Interval] =    BEGIN    i ¬ SELECT RandomNumber[intervalMaxRange] FROM      IN [0..vm) => Space.virtualMemory,      IN [vm..mds) => Space.MDS[],      IN [mds..random) => RandomInterval[],      ENDCASE => RandomInterval[];  -- should not get here    END;  ClientTransition: ENTRY ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];      new = inactive =>        IF data # NIL THEN zone.FREE[@data];      ENDCASE;    END;  -- ClientTransition  Init: PROCEDURE =    BEGIN    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "SwapBeater"L,      cmSection: "SwapBeater"L];    Process.InitializeCondition[@statsInterval, Process.SecondsToTicks[30]];    Process.DisableAborts[@statsInterval];    -- Find size of VM on this processor    BEGIN    page: Environment.PageNumber;    count: Environment.PageCount;    countVM: Environment.PageCount;    FOR countVM ¬ FIRST[Environment.PageNumber], page + count DO      [page, count] ¬ ProcessorFace.GetNextAvailableVM[countVM];      IF count = 0 THEN EXIT;      ENDLOOP;    lastVMPage ¬ countVM - 1;    END;  -- find VM size    END;  -- Init  MakeForm: FormSW.ClientItemsProcType =    BEGIN    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    priority: ARRAY[0..4) OF Enumerated ¬ [      ["background"L, 0], ["normal"L, 1],      ["foreground"L, 2], ["random"L, 3]];    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.processes.ORD] ¬ NumberItem[      tag: "# Processes"L, place: [6, line0], signed: FALSE,      value: @data.processes];    items[FormItems.priority.ORD] ¬ EnumeratedItem[      tag: "Priority"L, place: [150, line0], choices: DESCRIPTOR[priority],      value: @data.priority];    items[FormItems.randomSeed.ORD] ¬ LongNumberItem[      tag: "Random Seed"L, place: [320, line0], signed: FALSE, notNegative: TRUE,      value: @data.randomSeed];    items[FormItems.opWeight.ORD] ¬ TagOnlyItem[      tag: "Op weight (%):"L, place: [1, line1]];    items[FormItems.activate.ORD] ¬ NumberItem[      tag: "Activate"L, place: [90, line1], signed: FALSE, notNegative: TRUE,      default: 50, value: @data.activateWeight];    items[FormItems.deactivate.ORD] ¬ NumberItem[      tag: "Deactivate"L, place: [212, line1], signed: FALSE, notNegative: TRUE,      default: 40, value: @data.deactivateWeight];    items[FormItems.forceOut.ORD] ¬ NumberItem[      tag: "ForceOut"L, place: [344, line1], signed: FALSE, notNegative: TRUE,      default: 10, value: @data.forceOutWeight];    items[FormItems.intWeight.ORD] ¬ TagOnlyItem[      tag: "Interval weight (%):"L, place: [1, line2]];    items[FormItems.vm.ORD] ¬ NumberItem[      tag: "VM"L, place: [140, line2], signed: FALSE, notNegative: TRUE,      default: 75, value: @data.vmWeight];    items[FormItems.mds.ORD] ¬ NumberItem[      tag: "MDS"L, place: [230, line2], signed: FALSE, notNegative: TRUE,      default: 20, value: @data.mdsWeight];    items[FormItems.random.ORD] ¬ NumberItem[      tag: "random intervals"L, place: [325, line2], signed: FALSE,      notNegative: TRUE, default: 5, value: @data.randomWeight];    items[FormItems.start.ORD] ¬ CommandItem[      tag: "Start"L, place: [26, line3], proc: Start];    items[FormItems.stats.ORD] ¬ CommandItem[      tag: "Stats"L, place: [83, line3], proc: Stats];    items[FormItems.stop.ORD] ¬ CommandItem[      tag: "Stop"L, place: [139, line3], proc: Stop];    items[FormItems.statsInterval.ORD] _ NumberItem[      tag: "Stats interval (seconds) "L, place: [209, line3], signed: FALSE,      notNegative: TRUE, value: @data.statsInterval, proc: StatsIntervalChange];    RETURN[items: items, freeDesc: TRUE];    END;  -- MakeForm  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: LONG STRING ¬ [23];    Tool.UnusedLogName[unused: logName, root: "SwapBeaterImpl.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;  -- MakeSWs  RandomInterval: ENTRY PROCEDURE RETURNS [i: Space.Interval] =    BEGIN    page: Environment.PageNumber ¬ RandomNumberLong[lastVMPage];    i ¬ [pointer: Space.LongPointerFromPage[page],      count: 1 + RandomNumberLong[lastVMPage - page]];    IF (page > lastVMPage) OR (i.count > (lastVMPage + 1)) THEN ERROR;    END;  -- RandomInterval  RandomNumber: ENTRY PROCEDURE [max: CARDINAL] RETURNS [CARDINAL] =    {RETURN [RandomDefs.Random[@data.random, max]]};  RandomNumberLong: INTERNAL PROCEDURE [max: LONG CARDINAL]    RETURNS [LONG CARDINAL] =    {RETURN[LOOPHOLE[Environment.Long[num[      lowbits: RandomDefs.Random[@data.random, Inline.LowHalf[max]],      highbits: RandomDefs.Random[@data.random, Inline.HighHalf[max]]]]]]};  RandomPriority: ENTRY PROCEDURE [] RETURNS [prority: Process.Priority] =    BEGIN    RETURN [      SELECT RandomDefs.Random[@data.random, 100] FROM        < 50 => Process.priorityBackground,        < 75 => Process.priorityNormal,        < 100 => Process.priorityForeground,        ENDCASE => Process.priorityBackground -- should never get here      ];    END;  -- RandomPriority  Start: ENTRY FormSW.ProcType =    BEGIN    ENABLE UNWIND => NULL;    MsgSW.Clear[data.msgSW];    SELECT data.state FROM      running =>        BEGIN	MsgSW.Post[data.msgSW, "AlreadyRunning!"L];	UserTerminal.BlinkDisplay[];	RETURN;	END;      stopping => WHILE data.forkedProcesses > 0 DO WAIT processStopped ENDLOOP;      stopped =>        BEGIN	time: LONG STRING ¬ [64];	IF ~Runtime.IsBound[LOOPHOLE[RandomDefs.InitializeRandom]] THEN	  BEGIN	  MsgSW.Post[data.msgSW, "Please load an implementation of RandomDefs!"L];	  UserTerminal.BlinkDisplay[];	  RETURN;	  END;	IF ~ValidateWeights[] THEN	  BEGIN	  MsgSW.Post[data.msgSW, "Weights must add up to 100%!"L];	  UserTerminal.BlinkDisplay[];	  RETURN;	  END;	data.savedState ¬ [data.processes, data.priority, data.randomSeed];	data.activates ¬ data.deactivates ¬ data.forceOuts ¬ 0;	data.random.seed ¬ data.randomSeed;	RandomDefs.InitializeRandom[@data.random];	data.state ¬ running;        THROUGH [0..data.processes) DO          Process.Detach[FORK BeaterProcess[]];          data.forkedProcesses ¬ data.forkedProcesses+1;          ENDLOOP;	Put.LongString[data.fileSW, "Starting with "L];        Put.Number[data.fileSW, data.processes, numberFormatLeftJust];        Put.LongString[data.fileSW, " processes, random seed of "L];	Put.LongNumber[data.fileSW, data.randomSeed, numberFormatLeftJust];	Put.LongString[data.fileSW, ", at "L];	Time.AppendCurrent[time];	Put.LongString[data.fileSW, time];        Put.CR[data.fileSW];	data.forkedProcesses ¬ data.forkedProcesses+1;	Process.Detach[FORK StatsReporter[]];	END;      ENDCASE =>        BEGIN	MsgSW.Post[data.msgSW, "Unexpected Endcase!"L];	UserTerminal.BlinkDisplay[];	RETURN;	END;    END;  -- Start  Stats:  FormSW.ProcType =    BEGIN    time: LONG STRING ¬ [64];    MsgSW.Clear[data.msgSW];    Put.CR[data.fileSW];    Put.LongString[data.fileSW, "Statistics at "L];    Time.AppendCurrent[time];    Put.LongString[data.fileSW, time];    Put.CR[data.fileSW];    Put.LongString[data.fileSW, "  Activates:   "L];      Put.LongNumber[data.fileSW, data.activates, numberFormat];      Put.CR[data.fileSW];    Put.LongString[data.fileSW, "  Deactivates: "L];      Put.LongNumber[data.fileSW, data.deactivates, numberFormat];      Put.CR[data.fileSW];    Put.LongString[data.fileSW, "  ForceOuts:      "L];      Put.LongNumber[data.fileSW, data.forceOuts, numberFormat];      Put.CR[data.fileSW];    END;  -- Stats  StatsIntervalChange: FormSW.NumberNotifyProcType =    -- [sw: Window.Handle, item: FormSW.ItemHandle, index: CARDINAL,    --  oldValue: UNSPECIFIED]    BEGIN    ExchangeTimeout: ENTRY PROCEDURE =      {BROADCAST statsInterval};    IF data.statsInterval > 0 THEN      BEGIN      Process.SetTimeout[condition: @statsInterval,        ticks: Process.SecondsToTicks[data.statsInterval]];      IF oldValue = 0 THEN        {Put.LongString[data.fileSW, "Stats feedback enabled"L];	 Put.CR[data.fileSW]};      END    ELSE      BEGIN      Process.DisableTimeout[condition: @statsInterval];      Put.LongString[data.fileSW, "Stats feedback disabled"L];      Put.CR[data.fileSW];      END;    ExchangeTimeout[];    END;  StatsReporter: PROCEDURE =    BEGIN    Stopped: ENTRY PROCEDURE RETURNS [BOOLEAN] =      BEGIN      WAIT statsInterval;      RETURN [data.state ~= running];      END;    KillingOurselves: ENTRY PROCEDURE =      BEGIN      data.forkedProcesses ¬ data.forkedProcesses-1;      NOTIFY processStopped;      END;    Process.SetPriority[Process.priorityForeground];    WHILE ~Stopped[] DO      BriefStats[];      ENDLOOP;    KillingOurselves[];    END;  -- StatsReporter  Stop: ENTRY FormSW.ProcType =    BEGIN    ENABLE UNWIND => NULL;    MsgSW.Clear[data.msgSW];    IF data.state ~= running THEN      BEGIN      MsgSW.Post[data.msgSW, "Not running!"L];      UserTerminal.BlinkDisplay[];      RETURN;      END;    Put.LongString[data.fileSW, "Stopping all processes..."L];    data.state ¬ stopped;    BROADCAST statsInterval;  -- knock everybody out of WAIT in case it's long    WHILE data.forkedProcesses > 0 DO WAIT processStopped ENDLOOP;    Put.LongString[data.fileSW, "stopped."L];    Put.CR[data.fileSW];    END;  -- Stop  ValidateWeights: PROCEDURE RETURNS [BOOLEAN] =    BEGIN    IF      ((data.activateWeight + data.deactivateWeight + data.forceOutWeight) ~= 100)      OR ((data.mdsWeight + data.vmWeight + data.randomWeight) ~= 100)      THEN RETURN[FALSE]    ELSE      BEGIN      -- These are position dependent.      activate ¬ data.activateWeight + switchPriority;      deactivate ¬ data.deactivateWeight + activate;      forceOut ¬ data.forceOutWeight + deactivate;      vm ¬ data.vmWeight;      mds ¬ data.mdsWeight + vm;      random ¬ data.randomWeight + mds;      RETURN[TRUE];      END;    END;  -- Mainline code  Init[];  -- this gets string out of global frame  END...LOG24-Jun-85 16:30:52	CAJ	Created file, variant of FloppyBeaterImpl.12-Jul-85 15:17:55	CAJ	Default processes 3 ¬ 1; form adjustments. 4-Apr-86 13:37:52	CAJ	Bug fixes; form adjustments; add stats interval.
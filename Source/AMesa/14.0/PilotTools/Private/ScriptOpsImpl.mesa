-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- ScriptOpsImpl.mesa      12-Jan-83 17:31:22 by CAJ -- ScriptOps provides a facility for multiple, dynamically selectable, test-- scripts to drive a test program.  A script registers itself with a central-- facility, providing a script procedure and a name string by which it may be-- identified.  A test program can access any registered script via the name-- string.  The script may also be deregistered when the test program is done-- with it.DIRECTORY  Heap USING [Create, Delete],  ScriptOps,  String USING [EquivalentStrings];ScriptOpsImpl: MONITOR  IMPORTS Heap, String  EXPORTS ScriptOps =  BEGIN  ------------  -- Global types, constants, variables:  EntryData: TYPE = RECORD [    next: LONG POINTER,    proc: PROCEDURE,    nameBody: StringBody,    nameBodyText: PACKED ARRAY [0..ScriptOps.maxNameLength) OF CHARACTER];  Entry: TYPE = LONG POINTER TO EntryData;  scriptListHead: Entry ¬ NIL;  z: UNCOUNTED ZONE;  ------------  -- PUBLIC procedures:  RegisterScript: PUBLIC PROCEDURE [script: ScriptOps.Script, name: LONG STRING] =    BEGIN    newEntry: Entry ¬ z.NEW[EntryData];    newEntry.proc ¬ script;    IF name.length > ScriptOps.maxNameLength THEN      name.length ¬ ScriptOps.maxNameLength;    newEntry.nameBody ¬ name­;  -- copies string body only, no chars    FOR i: CARDINAL IN [0..name.length) DO      newEntry.nameBodyText[i] ¬ name.text[i];      ENDLOOP;     AddEntry[newEntry];    END;  DeregisterScript: PUBLIC PROCEDURE [name: LONG STRING] =    BEGIN    entry: Entry;    IF (entry ¬ FindEntry[name]) = NIL THEN ERROR NoSuchScript;    DeleteEntry[entry];    z.FREE[@entry];    END;  -- Enumerate script list entries  -- Given a name string, return the name of the next entry in the list.  -- NIL name starts at the top of the list; the end of the list returns NIL.  GetNext: PUBLIC PROCEDURE [name: LONG STRING]    RETURNS [LONG STRING] =    BEGIN    entry: Entry;    IF name = NIL THEN entry ¬ scriptListHead      ELSE {entry ¬ FindEntry[name]; IF entry ~= NIL THEN entry ¬ entry.next};    RETURN [IF entry = NIL THEN NIL ELSE @entry.nameBody];    END;  GetScript: PUBLIC PROCEDURE [name: LONG STRING]    RETURNS [ScriptOps.Script] =    BEGIN    entry: Entry ¬ FindEntry[name];    IF entry = NIL THEN ERROR NoSuchScript;    RETURN [entry.proc];     END;  -- This really wants to be registered at initialization rather than public  Shutdown: PUBLIC PROCEDURE =    {Heap.Delete[z: z, checkEmpty: TRUE]};  ------------  -- PUBLIC SIGNALs and ERRORs  NoSuchScript: PUBLIC ERROR = CODE;  ------------  -- Private procedures:  AddEntry: ENTRY PROCEDURE [entry: Entry] =    {entry.next ¬ scriptListHead; scriptListHead ¬ entry};  DeleteEntry: ENTRY PROCEDURE [entry: Entry] =    BEGIN    IF entry = NIL THEN RETURN WITH ERROR NoSuchScript;    IF entry = scriptListHead THEN scriptListHead ¬ entry.next    ELSE      BEGIN      prev: Entry ¬ scriptListHead;      WHILE prev.next ~= entry DO         IF prev.next = NIL THEN RETURN WITH ERROR NoSuchScript;	 prev ¬ prev.next;	 ENDLOOP;      prev.next ¬ entry.next;      END;    END;  -- Returns entry with matching name, or NIL for no match.  FindEntry: ENTRY PROCEDURE [name: LONG STRING] RETURNS [entry: Entry] =    BEGIN    entry ¬ scriptListHead;    IF name.length > ScriptOps.maxNameLength THEN      name.length ¬ ScriptOps.maxNameLength;    WHILE entry ~= NIL DO      entryName: LONG STRING ¬ @entry.nameBody;      IF String.EquivalentStrings[name, entryName] THEN EXIT;      entry ¬ entry.next;      ENDLOOP;    END;  ------------  -- Initialization:  z ¬ Heap.Create[initial: 1, increment: 1];  END.LOG12-Nov-82 14:59:11   CAJ    Created file.
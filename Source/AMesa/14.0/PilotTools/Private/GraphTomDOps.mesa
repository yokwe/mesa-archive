-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- GraphTomDOps.mesa (last edited by JBD      7-Jul-86 13:09:21)DIRECTORY  Context USING [Find, Type],  FormSW USING [ItemDescriptor, WordBoolean],  Inline USING [LongDiv, LongMult],  TomD,  ToolWindow USING [AdjustProcType, DisplayProcType],  Window USING [Box, Dims, Handle, Place];GraphTomDOps: DEFINITIONS IMPORTS Context, Inline, TomD =  BEGIN  Items: TYPE = TomD.Items;  ItemP: TYPE = TomD.ItemP;  GlobalInfoP: TYPE = LONG POINTER TO GlobalInfo;  GlobalInfo: TYPE = MONITORED RECORD [    formSW, mainSW, msgSW: Window.Handle,    hold, normalize: FormSW.WordBoolean,    filename: LONG STRING,    last: CARDINAL,    slct, slctAtStartOfAdjust: Slct,    slctScale: SlctScale,    selectionMarked: BOOLEAN,    barDims, currentDims: Window.Dims,    yOffset, firstBarX, rowH, graphW, slctH: INTEGER,    usersHistorySize, historySize: CARDINAL,    usersGraphHeight, graphHeight: CARDINAL,    items: Items];  ItemInfoP: TYPE = LONG POINTER TO ItemInfo;  ItemInfo: TYPE = RECORD [    rowBox, labelBox, graphBox, hwmBox: Window.Box,    isSelected, wasSelectedAtStartOfAdjust: BOOLEAN,    slct: Slct,    prev, maxVal, hwm: LONG CARDINAL,    item: ItemP,  -- back pointer to parent item    history: SEQUENCE historySize: CARDINAL OF LONG CARDINAL];  Slct: TYPE = RECORD [j1, j2: CARDINAL];  SlctScale: TYPE = {none, bar, graph, all};  undefined: LONG CARDINAL = LAST[LONG CARDINAL];  z: UNCOUNTED ZONE;  graphContextType: Context.Type;  -- GraphTomDFormSW ...  FormSWItems: PROCEDURE [globalInfo: GlobalInfoP]    RETURNS [items: FormSW.ItemDescriptor, freeDesc: BOOLEAN];  -- GraphTomDGraphSW ...    CreateGraphs: PROCEDURE [    globalInfo: GlobalInfoP, newItems: Items ¬ NIL,    initialDims: Window.Dims ¬ [0, 0]];  DestroyGraphs: PROCEDURE [globalInfo: GlobalInfoP];  UpdateGraphs: PROCEDURE [globalInfo: GlobalInfoP];  AdjustGraph: ToolWindow.AdjustProcType;  DisplaySelection: PROCEDURE [globalInfo: GlobalInfoP];  cH, cW, minimumRowH, rowOffset: CARDINAL;  -- GraphTomDRepaint ...  DisplayGraph: ToolWindow.DisplayProcType;  -- GraphTomDScroll ...  CreateScrollbar: PROCEDURE [w: Window.Handle];  DestroyScrollbar: PROCEDURE [w: Window.Handle];  -- GraphTomDTIP ...  CreateTIPClient: PROCEDURE [w: Window.Handle];  DestroyTIPClient: PROCEDURE [w: Window.Handle];  -- GraphTomDSlct ...  SetSlct: PROCEDURE [    globalInfo: GlobalInfoP, place: Window.Place, soonAfter: BOOLEAN,    inMotion: BOOLEAN];  AdjustSlct: PROCEDURE [    globalInfo: GlobalInfoP, place: Window.Place, soonAfter: BOOLEAN,    inMotion: BOOLEAN];  -- miscellaneous little INLINEs ...  GetGlobalInfo: PROCEDURE [w: Window.Handle] RETURNS [globalInfo: GlobalInfoP] =    INLINE {RETURN[Context.Find[graphContextType, w]]};  MulDiv: PROCEDURE [a, b, c: CARDINAL] RETURNS [d: CARDINAL] = INLINE {    RETURN[Inline.LongDiv[Inline.LongMult[a, b], c]]};  NormalizedValue: PROCEDURE [    globalInfo: GlobalInfoP, itemInfo: ItemInfoP, j: CARDINAL]    RETURNS [val: LONG CARDINAL] = INLINE {    IF globalInfo.normalize.b AND itemInfo.item.counter.b THEN {      item0Info: ItemInfoP ¬ globalInfo.items[0].client;      -- Use the order of evaluation to avoid overflow.      -- item0Info.history[j] is near 1000 hence we don't lose resolution when itemInfo.history[j] is large.         IF itemInfo.history[j] < (LAST[LONG CARDINAL] / 1000) THEN          RETURN[itemInfo.history[j] * 1000 / item0Info.history[j]]        ELSE RETURN[itemInfo.history[j] / item0Info.history[j] * 1000];}    ELSE RETURN[itemInfo.history[j]]};  END...  LOG27-Jun-83 11:09:47 JXG    	remove globalInfo.state, no return from CreateGraphs 7-Jul-86 13:00:36 JBD		fix overflow in NormalizedValue
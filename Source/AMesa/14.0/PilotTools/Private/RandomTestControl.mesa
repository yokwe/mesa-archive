-- Copyright (C) 1983, 1987  by Xerox Corporation. All rights reserved. -- RandomTestControl.mesa                    9-Feb-87 18:41:08 by JXG    DIRECTORY  Ascii USING [CR, SP],  Command USING [Action, Confirm, Entry, InstallTopLevel, Loop, NullCatch, QuitLevel, Scan],  Heap USING [systemMDSZone],  --Inline USING [LowHalf],  --MFile USING [Acquire, Error, Handle, ReadOnly, Release],  --MStream USING [Create],  PilotCommand USING [defaultWindow],  Process USING [    Detach, InitializeCondition, InitializeMonitor, SecondsToTicks, SetTimeout,    Ticks, Yield],  ProcessOperations USING [Enter, Exit],  Runtime USING [CallDebugger, IsBound],  --SpecialTransaction USING [OptionalCrash, SetCrashProcedure],  Stream USING [--Delete,-- Handle, SendNow],  System USING [--GetClockPulses,-- GetGreenwichMeanTime, GreenwichMeanTime],  --TemporaryBooting USING [BootButton],  TestFrameworkDefs USING [    AbortModelTrans, AbortRealTransaction, Base, BeginModelTrans,    BeginRealTransaction, CloseParameterItemRegistration, ColdStartProc,    --currentVerbosity,-- DeallocateParameterState, DidTransactionCommit,    DisplayParameterValues, EndModelTrans, EndRealTransaction, EnumerateTrans,    FinalFinish, InitializeStableStorage, ModelTransHandle, nil, Node,    ObtainTransactionIdentifier, OneOf, --ProcessParameterFile, -- RandomModelAct,    RandomRange, RealTransaction, Register, RegisterParameter,    ReleaseTransactionIdentifier, RelPtr, RestartProc, SaveState, StartStop,    ThenDo, Tick, Transactionid, Verbosity, VWF0],  Tool USING [UnusedLogName],  TTY USING [    Create, Destroy, GetChar, Handle, OutOfInstances, PutChar,  PutLine],  Volume USING [InsufficientSpace],  CWF USING [SetWriteProcedure];RandomTestControl: MONITOR LOCKS pLock USING pLock: LONG POINTER TO MONITORLOCK  IMPORTS    Command, Heap, --Inline, MFile, MStream,-- PilotCommand, Process, ProcessOperations, Runtime,    --SpecialTransaction, -- Stream, System, --TemporaryBooting,--    TestFrameworkDefs, Tool, TTY, Volume, CWF  EXPORTS TestFrameworkDefs =  BEGIN  -- - - - - - - - - - - - Constants, Parameters - - - - - - - - - - -  backingFileName: LONG STRING ¬ "RandomTest.state";  coldStartParameterFileName: LONG STRING ¬ "RandomTestParameters.txt";  forceColdStart: BOOLEAN ¬ FALSE;  -- (settable from debugger.)  startStop: TestFrameworkDefs.StartStop ¬ [    "RandomTestControl", ColdStart, Restart, NIL, NIL];  tty: TTY.Handle;  ttyStream: Stream.Handle ¬ NIL;  ZonePages: TYPE = CARDINAL [0..127];  zonePages: ZonePages ¬ 127;  required: TestFrameworkDefs.Verbosity = 0;  notice: TestFrameworkDefs.Verbosity = 2;  -- - - - - - - - - - - - Errors - - - - - - - - - - -  NoSuchFile: ERROR = CODE;  -- - - - - - - - - - - - Stable Data - - - - - - - - - - -  stable: TestFrameworkDefs.Base ¬ NIL;  -- base pointer for stable storage.  data: TestFrameworkDefs.Base RELATIVE POINTER TO ControlState ¬    TestFrameworkDefs.nil;  ControlState: TYPE = RECORD [  -- an instance of this is allocated in stable storage.    -- Parameters:    abortsDuringActions: BOOLEAN,    abortLikelihood: CARDINAL,  -- (out of commitLikelihood+abortLikelihood.)    commitLikelihood: CARDINAL,  -- (out of commitLikelihood+abortLikelihood.)    crashPercentage: CARDINAL [0..100],  -- out of 100 Pilot-suggested highest-importance opportunities.    maxActionsPerTrans: CARDINAL,    maxProcessesPerTrans: CARDINAL,    maxNumberOfTrans: CARDINAL,    timeToQuit: BOOLEAN];  -- (settable from debugger)  -- - - - - - - - - - - - Transient Data - - - - - - - - - - -  -- Process Monitor Data:  processLock: MONITORLOCK;  transactions: CARDINAL ¬ 0;  processes: CARDINAL ¬ 0;  -- (processes involved in transactions, that is.)  transactionEnded: CONDITION;  processesIdling: CARDINAL ¬ 0;  waitingForAllProcessesIdle: BOOLEAN ¬ FALSE;  okToProceed: CONDITION;  processIdled: CONDITION;  -- Other data:  wantToCrash: BOOLEAN ¬ FALSE;  z: MDSZone = Heap.systemMDSZone;  -- Temporary storage for parameters on coldStart:  -- The following parameter values are only used at coldStart parameter initialization time.  After that, they are copied into stable storage, which is their normal home.  initialData: ControlState ¬ [    abortsDuringActions: FALSE, abortLikelihood: 0, commitLikelihood: 100,    crashPercentage: 0, maxActionsPerTrans: 50, maxProcessesPerTrans: 4,    maxNumberOfTrans: 4, timeToQuit: FALSE];  --should be different if really doint transactions      -- Commands --    entries: ARRAY [0..3) OF Command.Entry ¬ [    ["commands", LoopCmd],  -- must be first    --["pause", PauseCmd],    ["run", RunCmd],    ["quit", Command.QuitLevel]];  -- must be last    ExerciseFileCmd: Command.Action =    BEGIN    TTY.PutChar[h, Ascii.SP];    Command.Scan[      h, DESCRIPTOR[BASE[entries], LENGTH[entries] - 1], Command.NullCatch]    END;        LoopCmd: Command.Action =    BEGIN    Command.Loop[      h, DESCRIPTOR[@entries[1], LENGTH[entries] - 1], Command.NullCatch,      "exercise file "];    END;  RunCmd: Command.Action =    BEGIN        DecrementProcessesAndNotify: ENTRY PROCEDURE [      pLock: LONG POINTER TO --process monitor-- MONITORLOCK] = {      processes ¬ processes - 1; NOTIFY transactionEnded; BROADCAST processIdled};         SetTimeToQuit: ENTRY PROCEDURE[     pLock: LONG POINTER TO --process monitor-- MONITORLOCK] = {      stable[data].timeToQuit ¬ TRUE};                     Command.Confirm[h];      -- Process parameters:      -- (We unconditionally process the parameters into temporary global variables.  If this is a restart, these temporary globals will be ignored.)     RegisterMyParameters[];  -- (and STARTs TestUtilities.  Also starts all subsidiary modules to allow them to register their parameters.)     TestFrameworkDefs.Register[@startStop];  -- must register after all other modules.  (See note in Restart[].)     TestFrameworkDefs.CloseParameterItemRegistration;     BEGIN     --no parameter file right now       -- ENABLE MFile.Error => CONTINUE;     --fH: MFile.Handle;     --sH: Stream.Handle ¬ NIL;     --[fH, sH] ¬ OpenFile[coldStartParameterFileName, ++ifNoneThenCreate:++ FALSE];     --TestFrameworkDefs.ProcessParameterFile[sH];     --CloseFile[fH, sH];     END;    zonePages ¬ MIN[LAST[ZonePages], zonePages];  -- in case user gave too-large value.    initialData.crashPercentage ¬ MIN[100, initialData.crashPercentage];  -- in case user gave too-large value.    -- DisplayParameterValues is done by ColdStart.    --SpecialTransaction.SetCrashProcedure[PossibleCrash];  ++ set us up to crash the system at random times.    BEGIN  -- Besides initializing Stable Storage, the following routine calls the coldstart or restart proc of all modules (including ours).    [] ¬ TestFrameworkDefs.InitializeStableStorage[    backingFileName, zonePages, forceColdStart !    Volume.InsufficientSpace => {      Runtime.CallDebugger[        "Insufficient space on volume to start test. (P)roceed will bail out."L];      GO TO GiveUp}];  --Process.Detach[FORK Run[@processLock]];    EXITS GiveUp => NULL;    END;        TTY.PutLine[h, "Type any character to quit."L];    Process.Detach[FORK Run[@processLock]];    [] ¬ TTY.GetChar[h];    SetTimeToQuit[@processLock];    TestFrameworkDefs.SaveState[];  -- (must be called from outside of process monitor)    DecrementProcessesAndNotify[@processLock];    END;      -- - - - - - - - - - - - Running the Test - - - - - - - - - - -  Run: ENTRY PROCEDURE [pLock: LONG POINTER TO --process monitor-- MONITORLOCK] =    BEGIN    transactions ¬ 0;    processes ¬ 0;    -- stable[data].timeToQuit is set FALSE at cold start.    IF ~stable[data].timeToQuit THEN      BEGIN     -- commandProcess: PROCESS RETURNS[] ¬ FORK UserCommandProcess[];      -- give user a chance to give a Quit command right off:      beginTime: System.GreenwichMeanTime ¬ System.GetGreenwichMeanTime[];      Process.SetTimeout[@transactionEnded, Process.SecondsToTicks[1]];      WHILE System.GetGreenwichMeanTime[] < beginTime + 10 --seconds-- DO        WAIT transactionEnded;  -- (timeout terminates)        ENDLOOP;      Process.SetTimeout[@transactionEnded, Process.SecondsToTicks[60]];      UNTIL stable[data].timeToQuit AND transactions = 0 DO        currentTransactions: CARDINAL;        IF ~stable[data].timeToQuit          AND transactions < stable[data].maxNumberOfTrans THEN          BEGIN  -- spawn some transactions..          numberToSpawn: CARDINAL ¬ TestFrameworkDefs.RandomRange[            stable[data].maxNumberOfTrans - transactions + 1];  -- [0..maxNumberOfTrans-transactions].          IF transactions + numberToSpawn = 0 THEN numberToSpawn ¬ 1;          THROUGH [0..numberToSpawn) DO            TestFrameworkDefs.Tick[];            transactions ¬ transactions + 1;            processes ¬ processes + 1;            Process.Detach[FORK OneTransaction[]];            ENDLOOP;          END;        currentTransactions ¬ transactions;        WHILE currentTransactions = transactions DO WAIT transactionEnded ENDLOOP;        ENDLOOP;     -- [] ¬ JOIN commandProcess;      END;    TestFrameworkDefs.VWF0[required, "*n*n TEST FINISHED *n*n"L];    TestFrameworkDefs.FinalFinish[];  -- allow everyone to go away gracefully.    TTY.Destroy[tty];    END;  -- process disappears.  IncrementProcesses: ENTRY PROCEDURE [    pLock: LONG POINTER TO --process monitor-- MONITORLOCK] = {    processes ¬ SUCC[processes]};  DecrementProcesses: ENTRY PROCEDURE [    pLock: LONG POINTER TO --process monitor-- MONITORLOCK] = {    processes ¬ (IF processes = 0 THEN ERROR ELSE PRED[processes]); BROADCAST processIdled}; -- PossibleCrash: SpecialTransaction.OptionalCrash [unimportance]  =    -- This procedure uses System.GetClockPulses as a random source since our normal generator's monitor lock may be held by the caller of the Pilot transaction operation.   -- BEGIN   -- importance: CARDINAL [1..100] = 100/MIN[100, unimportance];   -- IF (Inline.LowHalf[System.GetClockPulses[]] MOD 100) <   --   CARDINAL[importance*stable[data].crashPercentage]/100 OR wantToCrash THEN  crash the system!   --   TemporaryBooting.BootButton[];  ++ crash / restart the system!  (does not depend on any Pilot facilities.)   -- END;  TransactionData: TYPE = MONITORED RECORD [  -- monitor data for an individual transaction.    realTrans: TestFrameworkDefs.RealTransaction,    modTrans: TestFrameworkDefs.ModelTransHandle,    id: TestFrameworkDefs.Transactionid,    actionsToBeDone: CARDINAL,    numberActors: CARDINAL,    actorsStillRunning: CARDINAL,    actorFinished: CONDITION];  OneTransaction: PROCEDURE[] =    BEGIN    transactionData: TransactionData;    --scope of transactionData--      BEGIN OPEN transactionData;      Process.InitializeMonitor[@transactionData.LOCK];      Process.InitializeCondition[@actorFinished, LAST[Process.Ticks]];        -- begin the transaction:      TestFrameworkDefs.Tick[];      TestFrameworkDefs.SaveState[];  -- just before beginning the transaction.  (Must be called from outside of process monitor)      realTrans ¬ TestFrameworkDefs.BeginRealTransaction[];      modTrans ¬ TestFrameworkDefs.BeginModelTrans[realTrans];      id ¬ TestFrameworkDefs.ObtainTransactionIdentifier[realTrans, modTrans];        CauseActions[@transactionData, @transactionData.LOCK];        -- end the transaction:      TestFrameworkDefs.Tick[];      IF TestFrameworkDefs.RandomRange[        stable[data].commitLikelihood + stable[data].abortLikelihood] < stable[        data].commitLikelihood THEN  -- commit the transaction        BEGIN        TestFrameworkDefs.VWF0[notice, "  End transaction  "L];        TestFrameworkDefs.SaveState[];  -- just before committing the transaction.  (Must be called from outside of process monitor)        TestFrameworkDefs.EndRealTransaction[realTrans];        TestFrameworkDefs.EndModelTrans[mTrans: modTrans, circumstance: normal];        END      ELSE  -- abort the transaction        BEGIN        TestFrameworkDefs.VWF0[notice, "  Abort transaction  "L];        TestFrameworkDefs.AbortRealTransaction[realTrans];        TestFrameworkDefs.AbortModelTrans[mTrans: modTrans, circumstance: normal];        END;      TestFrameworkDefs.ReleaseTransactionIdentifier[id];      NotifyTransactionEnded[@processLock];      END; --scope of transactionData--    END;  CauseActions: ENTRY PROCEDURE [    pData: POINTER TO TransactionData,    pLock: LONG POINTER TO --transaction monitor-- MONITORLOCK] =    BEGIN OPEN pData;        SomeActorsRunning: --ENTRY-- PROCEDURE RETURNS [running: BOOLEAN] = {      WHILE ~ProcessOperations.Enter[pLock] DO NULL ENDLOOP;  -- acquire transaction lock.      running ¬ (actorsStillRunning > 0);      ProcessOperations.Exit[pLock] };  -- release transaction lock.    -- fork a number of processes to perform some model actions:    actionsToBeDone ¬ TestFrameworkDefs.RandomRange[      stable[data].maxActionsPerTrans + 1];  -- [0..maxActionsPerTrans].    numberActors ¬ TestFrameworkDefs.RandomRange[      stable[data].maxProcessesPerTrans + 1];  -- [0..maxProcessesPerTrans].    actorsStillRunning ¬ 0;    FOR k: CARDINAL IN [0..numberActors) DO      acts: CARDINAL =        (IF k = numberActors THEN actionsToBeDone         ELSE TestFrameworkDefs.RandomRange[actionsToBeDone]);      TestFrameworkDefs.Tick[];      IncrementProcesses[@processLock];  -- 1 of 2.      Process.Detach[FORK OneActor[acts, pData]];  -- 2 of 2.      actorsStillRunning ¬ SUCC[actorsStillRunning];      actionsToBeDone ¬ actionsToBeDone - acts;      ENDLOOP;    -- wait for model actions to finish:    ProcessOperations.Exit[pLock];  -- release transaction lock while we wait.    IdleUntilCondition[      waitWhile: SomeActorsRunning, pCondition: @actorFinished, pLock: @processLock];    WHILE ~ProcessOperations.Enter[pLock] DO NULL ENDLOOP;  -- reacquire transaction lock.    END;  OneActor: PROCEDURE [actsToDo: CARDINAL, pData: POINTER TO TransactionData] =    BEGIN    THROUGH [0..actsToDo] DO      TestFrameworkDefs.Tick[];      IF TestFrameworkDefs.OneOf[4] THEN Process.Yield[];      TestFrameworkDefs.RandomModelAct[pData.modTrans];      IF stable[data].timeToQuit THEN EXIT;  -- bypass rest of planned actions.     -- IF wantToCrash THEN PossibleCrash[100];  ++ will definitely crash.      AllowSaveState[];      ENDLOOP;    NotifyActorFinished[pData, @pData.LOCK];    END;  -- (process vanishes)  NotifyActorFinished: ENTRY PROCEDURE [    pData: POINTER TO TransactionData,    pLock: LONG POINTER TO --transaction monitor-- MONITORLOCK] = {    DecrementProcesses[@processLock];    pData.actorsStillRunning ¬      (IF pData.actorsStillRunning = 0 THEN ERROR       ELSE PRED[pData.actorsStillRunning]);    NOTIFY pData.actorFinished };  NotifyTransactionEnded: ENTRY PROCEDURE [    pLock: LONG POINTER TO --process monitor-- MONITORLOCK] =    BEGIN    transactions ¬ (IF transactions = 0 THEN ERROR ELSE PRED[transactions]);    processes ¬ (IF processes = 0 THEN ERROR ELSE PRED[processes]);    NOTIFY transactionEnded;    BROADCAST processIdled;    END;  -- - - - - - - - - - Synchronization: - - - - - - - - -  WaitForAllProcessesIdle: PUBLIC PROCEDURE [thenDo: TestFrameworkDefs.ThenDo] =    BEGIN WaitForAllProcessesIdleEntry[thenDo, @processLock]; END;  WaitForAllProcessesIdleEntry: ENTRY PROCEDURE [    thenDo: TestFrameworkDefs.ThenDo,    pLock: LONG POINTER TO --process monitor-- MONITORLOCK] =    BEGIN    processesIdling ¬ SUCC[processesIdling];  -- (namely me!)    BROADCAST processIdled;    WHILE waitingForAllProcessesIdle DO WAIT okToProceed ENDLOOP;  -- wait till any previous idleWaiter is finished..    waitingForAllProcessesIdle ¬ TRUE;    WHILE processesIdling < processes DO WAIT processIdled ENDLOOP;    thenDo[];    waitingForAllProcessesIdle ¬ FALSE;    BROADCAST okToProceed;  -- wake all of them guys up.    processesIdling ¬      (IF processesIdling = 0 THEN ERROR ELSE PRED[processesIdling]);    END;  AllowSaveState: PUBLIC --NON-ENTRY-- PROCEDURE[] =    -- (We enter the monitor only if necessary.  (This works since testing a BOOLEAN is an atomic action.)  If we just miss somebody setting waitingForAllProcessesIdle, we will catch it the next time we come around.)    {IF waitingForAllProcessesIdle THEN AllowSaveStateEntry[@processLock]};  AllowSaveStateEntry: ENTRY PROCEDURE [    pLock: LONG POINTER TO --process monitor-- MONITORLOCK] =    BEGIN    processesIdling ¬ SUCC[processesIdling];    BROADCAST processIdled;    WHILE waitingForAllProcessesIdle DO WAIT okToProceed ENDLOOP;    processesIdling ¬      (IF processesIdling = 0 THEN ERROR ELSE PRED[processesIdling]);    END;  IdleUntilCondition: ENTRY PROCEDURE [    waitWhile: PROC RETURNS [BOOLEAN], pCondition: LONG POINTER TO CONDITION,    pLock: LONG POINTER TO --process monitor-- MONITORLOCK] =    BEGIN    processesIdling ¬ SUCC[processesIdling];    BROADCAST processIdled;    WHILE waitWhile[] DO WAIT pCondition­ ENDLOOP;    processesIdling ¬      (IF processesIdling = 0 THEN ERROR ELSE PRED[processesIdling]);    END;  -- - - - - - - - - - Start / Restart: - - - - - - - - -  ColdStart: TestFrameworkDefs.ColdStartProc    --[zoneBase: Base] RETURNS [registerThisNode: RelPtr]--  =    BEGIN    TTY.PutLine[tty, "-- Cold Start --"L];    TestFrameworkDefs.DisplayParameterValues[];    TestFrameworkDefs.DeallocateParameterState[];    stable ¬ zoneBase;  -- remember for whole module.    data ¬ TestFrameworkDefs.Node[SIZE[ControlState]];  -- remember for whole module.    stable[data] ¬ initialData;  -- copy parameters to stable storage, where they will remain.    RETURN[registerThisNode: data];    END;  Restart: TestFrameworkDefs.RestartProc    --[zoneBase: Base, registeredNode: RelPtr]--  =    BEGIN    FinishTrans: PROCEDURE [      mt: TestFrameworkDefs.ModelTransHandle,      id: TestFrameworkDefs.Transactionid] =      BEGIN      IF TestFrameworkDefs.DidTransactionCommit[id].committed THEN        TestFrameworkDefs.EndModelTrans[mTrans: mt, circumstance: followingCrash]      ELSE        TestFrameworkDefs.AbortModelTrans[          mTrans: mt, circumstance: followingCrash];      TestFrameworkDefs.ReleaseTransactionIdentifier[id];      END;    stable ¬ zoneBase;  -- remember for whole module.    data ¬ registeredNode;  -- remember for whole module.    TTY.PutLine[tty, "-- Continuing from last checkpoint --"L];    IF stable[data].timeToQuit THEN      TTY.PutLine[tty, "..continuing to wind down current transactions.."L];    TestFrameworkDefs.DeallocateParameterState[];  -- flushes initial parameter stuff (which is always done).    -- Doing EnumerateTrans[FinishTrans] here means that this restart proc must run LAST.  All other modules must have recovered their state before we finish processing the transactions outstanding when we last crashed.    TestFrameworkDefs.EnumerateTrans[FinishTrans];    END;  -- - - - - Initialization, Parameter processing (if coldStart), and Main Body: - - - -  TTYPutChar: PROCEDURE [c: CHARACTER] =  -- for WriteFormatted package.    {TTY.PutChar[tty, c]; IF ttyStream # NIL AND c = Ascii.CR THEN Stream.SendNow[ttyStream]};  RegisterMyParameters: PROCEDURE[] =    BEGIN OPEN TestFrameworkDefs;    RegisterParameter[      "abortsDuringActions"L, [bv[@initialData.abortsDuringActions]]];    RegisterParameter["abortLikelihood"L, [cv[@initialData.abortLikelihood]]];    RegisterParameter["backingFileName"L, [str[backingFileName]]];    RegisterParameter["commitLikelihood"L, [cv[@initialData.commitLikelihood]]];    RegisterParameter[      "crashPercentage"L, [cv[@LOOPHOLE[initialData.crashPercentage, CARDINAL]]]];    RegisterParameter["forceColdStart"L, [bv[@forceColdStart]]];    RegisterParameter[      "maxActionsPerTrans"L, [cv[@initialData.maxActionsPerTrans]]];    RegisterParameter[      "maxProcessesPerTrans"L, [cv[@initialData.maxProcessesPerTrans]]];    RegisterParameter["maxNumberOfTrans"L, [cv[@initialData.maxNumberOfTrans]]];    RegisterParameter["zonePages"L, [cv[@LOOPHOLE[zonePages, CARDINAL]]]];    END; -- OpenFile: PROCEDURE [name: STRING, ifNoneThenCreate: BOOLEAN] --   RETURNS [fH: MFile.Handle, sH: Stream.Handle] = --  BEGIN --  fH ¬ MFile.ReadOnly[name: name, release: [NIL,NIL] --   ! MFile.Error => IF code = noSuchFile AND ifNoneThenCreate --    THEN fH ¬ MFile.Acquire[name, readWrite, [NIL,NIL], 1] --   ELSE REJECT]; --   sH ¬ MStream.Create[fH, [NIL,NIL]]; --  END; -- CloseFile: PROCEDURE [fH: MFile.Handle, sH: Stream.Handle] = --   BEGIN --   MFile.Release[fH]; --   Stream.Delete[sH]; --   END;  Init: PROC =    BEGIN    logName: STRING ¬ [40];    IF Runtime.IsBound[LOOPHOLE[Tool.UnusedLogName]] THEN      Tool.UnusedLogName[logName, "RandomTest.log"L]    ELSE logName ¬ "RandomTest.log"L;    tty ¬ TTY.Create[logName ! TTY.OutOfInstances => { tty ¬ PilotCommand.defaultWindow; CONTINUE}];    --ttyStream ¬ TTY.BackingStream[tty];    [] ¬ CWF.SetWriteProcedure[TTYPutChar];    IF tty = PilotCommand.defaultWindow THEN      Command.InstallTopLevel[tty, ["exercise file", ExerciseFileCmd]];  --ELSE worry about this in later implementation    END;             Init[];  END.LOGSeptember 26, 1980  8:16 AM   JXI      Created file.October 28, 1980  2:34 PM   WDK       Add monitors for process and transaction control, command processing, clean   up parameter processing. Fix bugs.April 25, 1981  3:28 PM   JXI      Force out typescript once per line.  Make file names generic.8-Sep-81 13:33:58   WDK       Don't delay before crashing.1-Dec-81 16:28:21   CAJ    Convert from Directory to new file system, generate log file via   Tool.UnusedLogName. 2-Dec-81  9:05:40   WDK       Didn't broadcast processIdled often enough  1-Mar-83 14:14:45   LXD        Eliminated references to MFile, MStream.  Reset initial data.   wantToCrash will NEVER become TRUE  4-Mar-83 14:44:12	LXD        Converted to use Command  4-Mar-83 15:15:34	LXD        ttyStream ¬ NIL  7-Mar-83 11:20:04	LXD        former initialization code is now part of the RunCmd  8-Mar-83 16:58:15	LXD        failure to BROADCAST processIdled when number of processes decreased led to deadlock.26-Jul-83 15:56:34 	need LOOPHOLE for Runtime.IsBound 9-Feb-87 18:41:08      RSV        STRING to LONG STRING, POINTER to LONG POINTER.
-- Copyright (C) 1983, 1986  by Xerox Corporation. All rights reserved. -- GraphTomDRepaint.mesa (last edited by JBD      7-Jul-86 17:23:01)DIRECTORY  Display USING [Black, Gray, Text],  GraphTomDOps,  Inline USING [DIVMOD],  String USING [AppendLongNumber, Copy],  ToolWindow USING [DisplayProcType, DrawRectangle],  Window USING [    Box, BoxesAreDisjoint, Dims, EnumerateInvalidBoxes, Handle, Place],  WindowFont USING [defaultFont];GraphTomDRepaint: MONITOR LOCKS globalInfo USING globalInfo:  GraphTomDOps.GlobalInfoP  IMPORTS Display, GraphTomDOps, Inline, String, ToolWindow, Window, WindowFont  EXPORTS GraphTomDOps =  BEGIN OPEN GraphTomDOps;  slightlyGray: ARRAY [0..16) OF CARDINAL ¬ [    010421B, 042104B, 021042B, 104210B, 010421B, 042104B, 021042B, 104210B,    010421B, 042104B, 021042B, 104210B, 010421B, 042104B, 021042B, 104210B];  -- routines to paint the picture ...  DisplayGraph: PUBLIC ToolWindow.DisplayProcType = {    Window.EnumerateInvalidBoxes[window, RepaintBox]};  RepaintBox: PROCEDURE [w: Window.Handle, box: Window.Box] =    BEGIN    globalInfo: GlobalInfoP ¬ GetGlobalInfo[w];    itemInfo: ItemInfoP;    IF globalInfo = NIL THEN RETURN;    -- two common cases are considered - that the box is all or part of a a bar in the    -- current column of some item or other, and that the box is part of the    -- current selection    IF (itemInfo ¬ ItemFromBar[globalInfo, box]) # NIL THEN      RepaintBar[globalInfo, itemInfo, globalInfo.last]    ELSE      IF (itemInfo ¬ ItemFromPartOfSelection[globalInfo, box]) # NIL THEN        RepaintSelection[globalInfo, itemInfo]  -- allow system to clip this to box!           ELSE        FOR i: CARDINAL IN [0..LENGTH[globalInfo.items]) DO          itemInfo ¬ globalInfo.items[i].client;          -- quick and easy optimisation ...          IF Window.BoxesAreDisjoint[box, itemInfo.rowBox] THEN LOOP;          IF ~Window.BoxesAreDisjoint[box, itemInfo.hwmBox] THEN            RepaintHwm[globalInfo, itemInfo];          RepaintScale[globalInfo, itemInfo];          IF ~Window.BoxesAreDisjoint[box, itemInfo.labelBox] THEN            RepaintLabel[globalInfo, itemInfo];          IF ~Window.BoxesAreDisjoint[box, itemInfo.graphBox] THEN            RepaintGraph[globalInfo, itemInfo];          IF itemInfo.isSelected THEN RepaintSelection[globalInfo, itemInfo];          ENDLOOP;    END;  ItemFromBar: PROCEDURE [globalInfo: GlobalInfoP, box: Window.Box]    RETURNS [itemInfo: ItemInfoP] =    BEGIN OPEN globalInfo;    -- determine if the box is a bar and if so return the itemInfo;    -- the box is a bar if its place and dims are ok;     -- note its dims may not be exact if they have been clipped;    -- also note we do not know to which item this bar corresponds - hence    -- complications in check of y-coord;    -- note further the box is allowed to be twice the width of a bar so that a    -- white space may lead the latest bar    -- Oh! to be able to put a hint with a box in the call to Window.InvalidateBox!    IF box.dims.h <= barDims.h + 1 AND box.dims.w <= 2 * barDims.w      AND box.place.x = firstBarX + INTEGER[last] * barDims.w THEN {      quot, rem: CARDINAL;      possiblyIndexTimesRowH: INTEGER ¬ box.place.y - rowOffset - 1 + yOffset;      IF possiblyIndexTimesRowH >= 0 THEN {        [quot, rem] ¬ Inline.DIVMOD[possiblyIndexTimesRowH, rowH];        IF rem = 0 AND quot IN [0..LENGTH[globalInfo.items]) THEN          RETURN[globalInfo.items[quot].client]}};    RETURN[NIL]  -- it isn't a valid bar    END;  ItemFromPartOfSelection: PROCEDURE [globalInfo: GlobalInfoP, box: Window.Box]    RETURNS [itemInfo: ItemInfoP] =    BEGIN OPEN globalInfo;    -- determine if the box is part of the indication of the current selection;    -- see also notes on ItemFromBar    IF box.dims.h <= slctH AND (box.place.x - firstBarX MOD barDims.w) = 0      AND (box.place.x + box.dims.w) <= firstBarX + graphW THEN {      quot, rem: CARDINAL;      possiblyIndexTimesRowH: INTEGER ¬ box.place.y - rowOffset + slctH + yOffset;      IF possiblyIndexTimesRowH >= 0 THEN {        [quot, rem] ¬ Inline.DIVMOD[possiblyIndexTimesRowH, rowH];        IF rem = 0 AND quot IN [0..LENGTH[globalInfo.items]) THEN          RETURN[globalInfo.items[quot].client]}};    RETURN[NIL]  -- it isn't a valid part of selection indicant     END;  RepaintGraph: PROCEDURE [globalInfo: GlobalInfoP, itemInfo: ItemInfoP] =    BEGIN OPEN itemInfo, globalInfo;    ToolWindow.DrawRectangle[window: mainSW, box: graphBox, width: 1];    FOR i: CARDINAL IN [0..historySize) DO      RepaintBar[globalInfo, itemInfo, i] ENDLOOP;    END;  RepaintBar: PROCEDURE [    globalInfo: GlobalInfoP, itemInfo: ItemInfoP, i: CARDINAL] =    BEGIN    normVal: LONG CARDINAL ¬ NormalizedValue[globalInfo, itemInfo, i];    val: LONG CARDINAL ¬ MIN[itemInfo.maxVal, normVal];    -- Avoid overflow by checking size of val before multiplying    height: CARDINAL ¬ CARDINAL[      IF val < LAST[CARDINAL] THEN        (val * globalInfo.barDims.h) / itemInfo.maxVal       ELSE val / (itemInfo.maxVal / globalInfo.barDims.h)];    bar: Window.Box ¬ [      [      itemInfo.graphBox.place.x + 1 + globalInfo.barDims.w * i,      itemInfo.graphBox.place.y + 1 + globalInfo.barDims.h - height], [      globalInfo.barDims.w, height + 1]];  -- always repaint bottom of box    IF normVal # undefined THEN Display.Black[globalInfo.mainSW, bar]    ELSE Display.Gray[globalInfo.mainSW, bar, DESCRIPTOR[slightlyGray]]    END;  RepaintHwm: PROCEDURE [globalInfo: GlobalInfoP, itemInfo: ItemInfoP] =    BEGIN    IF itemInfo.hwm > itemInfo.maxVal THEN      BEGIN      hwmS: LONG STRING ¬ [30];      String.Copy[from: "      hwm="L, to: hwmS];      String.AppendLongNumber[hwmS, itemInfo.hwm];      RepaintText[globalInfo, hwmS, itemInfo.hwmBox.place];      END    END;  RepaintScale: PROCEDURE [globalInfo: GlobalInfoP, itemInfo: ItemInfoP] =    BEGIN    maxValS: LONG STRING ¬ [20];    endX: INTEGER ¬ itemInfo.graphBox.place.x - 3;    topY: INTEGER ¬ itemInfo.graphBox.place.y;    bottomY: INTEGER ¬ topY + globalInfo.barDims.h - cH;    String.AppendLongNumber[maxValS, itemInfo.maxVal];    RepaintText[globalInfo, maxValS, [endX - cW * maxValS.length, topY]];    RepaintText[globalInfo, "0"L, [endX - cW, bottomY]]    END;  RepaintLabel: PROCEDURE [globalInfo: GlobalInfoP, itemInfo: ItemInfoP] =    BEGIN    place: Window.Place ¬ itemInfo.labelBox.place;    RepaintText[globalInfo, itemInfo.item.interfaceName, place];    RepaintText[      globalInfo, itemInfo.item.varName, [place.x + 2 * cW, place.y + cH]];    END;  RepaintSelection: PROCEDURE [globalInfo: GlobalInfoP, itemInfo: ItemInfoP] =    BEGIN    x, y, w, h: INTEGER;    x ¬ globalInfo.firstBarX + globalInfo.slct.j1 * globalInfo.barDims.w;    w ¬ globalInfo.barDims.w * (globalInfo.slct.j2 - globalInfo.slct.j1 + 1);    y ¬ itemInfo.graphBox.place.y + itemInfo.graphBox.dims.h;    h ¬ globalInfo.slctH;    IF itemInfo.isSelected AND globalInfo.selectionMarked THEN      Display.Gray[globalInfo.mainSW, [[x, y], [w, h]]]    END;  RepaintText: PROCEDURE [    globalInfo: GlobalInfoP, s: LONG STRING, place: Window.Place] = {    [] ¬ Display.Text[      window: globalInfo.mainSW, font: WindowFont.defaultFont, string: s,      place: place]};  END...  LOG 7-Jul-86 14:20:48 JBD		fix overflow in RepaintBar
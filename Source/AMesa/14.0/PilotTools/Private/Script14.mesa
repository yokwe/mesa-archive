-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Script14.mesa        4-May-83 17:40:43 by CAJ -- Virtual memory test program, Klamath Pilot.-- Script14 tests combinations of CopyIn and CopyOut under varying map unit-- attribute states.DIRECTORY  Environment USING [PageNumber],  ScriptGeneric USING [CopyCombos, CopyProc, DoubleCopyCombos, RestoreProc],  ScriptOps USING [RegisterScript],  Space USING [SwapUnitSize],  VM USING [Interval, ReturnWait],  VMTestOperations-- USING [all the operations]--,  VMTestScript USING [GetHeap, GetTestVMSize, GiveBackHeap, MakeBackingData,    MakeIrregularSwapData, MakeUniformSwapData, MakeUnitarySwapData];Script14: PROGRAM  IMPORTS ScriptGeneric, ScriptOps, VMTestOperations, VMTestScript =  BEGIN  ------------  -- Public procedures:  -- RunTests is a registered script procedure which may be called by the  -- VMTest driver.  The tests in the script may use procedures from  -- VMTestOperations (for VM operations) and VMTestScript (for test utilities).  RunTests: PROCEDURE =    BEGIN    heap: UNCOUNTED ZONE ¬ VMTestScript.GetHeap[];    TestA[heap];    heap ¬ VMTestScript.GiveBackHeap[heap];    END;  ------------  -- Local procedures:  -- Initial (and restored) state:  --  readWrite, swappable, backed, alive, clean, out  TestA: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- Restore testVM to initial state:    --  readWrite, swappable, (backed,) alive, clean, out    Restore: ScriptGeneric.RestoreProc =      BEGIN      MakeSwappable[[0, vmSize]];      MakeWritable[[0, vmSize]];      Touch[[0, vmSize], write];      Deactivate[[0, vmSize], wait];      END;    halfMapUnit: CARDINAL;    mapUnitSize: CARDINAL;    maxMapUnitSize: CARDINAL;    page: Environment.PageNumber;    pBacking: LONG POINTER;    pSwap: LONG POINTER;    vmSize: CARDINAL;    vmSize ¬ CARDINAL[GetTestVMSize[]];  -- known to be short    maxMapUnitSize ¬ MAX[vmSize/4, 1];    -- BackingStore for all map units through all map unit sizes consists of    -- 3 runs, 2 each about half the map unit with a single page in between.    -- The existence of a run boundary in the map unit and its location relative    -- to swap units will vary as the map unit size increases.  For all but the    -- last round, the backing store extends past the end of the map unit.    halfMapUnit ¬ MAX[maxMapUnitSize/2, 1];    pBacking ¬ heap.NEW[ARRAY[0..3) OF WORD ¬      [halfMapUnit, 1, maxMapUnitSize - halfMapUnit]];    pSwap  ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [1]];    FOR mapUnitSize IN [1..maxMapUnitSize] DO      -- Map uniform, irregular, unitary, uniform, irregular, ...      -- Doing Maps non-sequentially      FOR page ¬ 0, page + mapUnitSize * 3 UNTIL page > vmSize - mapUnitSize DO        Map[id: "uniform"L,          interval: [page, mapUnitSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pBacking, 3]],          access: readWrite,          swapUnits: MakeUniformSwapData[3],          life: alive,          swappability: swappable];        ENDLOOP;  -- end map loop      FOR page ¬ mapUnitSize, page + mapUnitSize * 3          UNTIL page > vmSize - mapUnitSize DO        Map[id: "irregular"L,          interval: [page, mapUnitSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pBacking, 3]],          access: readWrite,          swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwap, 1]],          life: alive,          swappability: swappable];        ENDLOOP;  -- end map loop      FOR page ¬ mapUnitSize * 2, page + mapUnitSize * 3          UNTIL page > vmSize - mapUnitSize DO        Map[id: "unitary"L,          interval: [page, mapUnitSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pBacking, 3]],          access: readWrite,          swapUnits: MakeUnitarySwapData[],          life: alive,          swappability: swappable];        ENDLOOP;  -- end map loop      ScriptGeneric.CopyCombos[CopyIn, Restore, vmSize];      ScriptGeneric.CopyCombos[CopyOut, Restore, vmSize];      ScriptGeneric.DoubleCopyCombos[CopyIn, CopyOut, Restore, vmSize];      ScriptGeneric.DoubleCopyCombos[CopyIn, CopyIn, Restore, vmSize];      ScriptGeneric.DoubleCopyCombos[CopyOut, CopyIn, Restore, vmSize];      ScriptGeneric.DoubleCopyCombos[CopyOut, CopyOut, Restore, vmSize];      -- unmap      FOR page ¬ 0, page + mapUnitSize UNTIL page > vmSize - mapUnitSize DO        Unmap [page] ENDLOOP;  -- end unmap loop      ENDLOOP;  -- end mapUnitSize loop    heap.FREE[@pBacking];    heap.FREE[@pSwap];    END;  ------------  -- PUBLIC SIGNALs and ERRORs: none  ------------  -- Initialization:  -- Register the given script proc and identifying name with the script  -- handling facility at start time.  Module must be explicitly started.  ScriptOps.RegisterScript[script: RunTests, name: "Copy combos"L];  END.LOG17-Mar-83 14:03:43   CAJ    Created file.
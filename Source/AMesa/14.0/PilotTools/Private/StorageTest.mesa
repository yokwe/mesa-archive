-- Copyright (C) 1983, 1985, 1986  by Xerox Corporation. All rights reserved. -- StorageTest.mesa  last edited by CJS on 11-Feb-87 12:19:28-- Volume.InsufficientSpace and Space.InsufficientSpace are both raised-- by Space.Map[[File.nullFile, 0, countVm]].   This test is commented out-- until the code is written to handle multiple errors raised on a single call.-- Volume.ReadOnly can only be tested after a GetNextFileOnVolume kind of -- procedure is implemented or found somewhere.  DIRECTORY  Ascii USING [CR],  Command USING [Action, Break, Confirm, InstallTopLevel],  Environment USING [PageCount, wordsPerPage],  File,  FileTypes USING [tUntypedFile],  PilotCommand USING [defaultWindow],  PilotFileTypes USING [tVolumeFileMap],  Space,  String USING [AppendString],  TTY USING [Handle, PutChar, PutDecimal, PutLine],  Volume USING [Error, GetNext, GetStatus, ID, InsufficientSpace,     NeedsScavenging, NotOpen, NotOnline, nullID, Open, ReadOnly,     Status, SystemID, TypeSet, Unknown];StorageTest: PROGRAM  IMPORTS Command, File, PilotCommand, Space, String, TTY, Volume =  BEGIN  tty: TTY.Handle = PilotCommand.defaultWindow;    countVm: Space.PageCount ¬ Space.virtualMemory.count;  siNull: Space.Interval = Space.nullInterval;  siVm: Space.Interval = Space.virtualMemory;  siMds: Space.Interval ¬ Space.MDS[];  siSink: Space.Interval;  siInt, siIntSpec: Space.Interval;  -- one-page space in the MDS, sibling of same.  siIntOther: Space.Interval;  -- another one-page space in the MDS.  siExt: Space.Interval;  -- one-page space in hyperspace, sibling of same.  int: Space.Interval;  pnSink, pn: Space.PageNumber;  vidNull: Volume.ID = Volume.nullID;  vid, vidSys: Volume.ID;  fileSink, file: File.File;  ftUntyped: File.Type = FileTypes.tUntypedFile;  countReported: CARDINAL;  break: BOOLEAN ¬ TRUE;      Report: PROCEDURE [symptom: STRING] =    BEGIN    countReported ¬ countReported + 1;    IF break THEN Command.Break[tty, symptom]    END;  Mask: TYPE = {    nil, spAlAlloc, spDealloc, spInPa, spInProc, spIncSU, spInSp,     spInSUSize, spInWi, spIOError, spNotAlloc, spNotMap, spNoWi,     spPtrPastEndOfMem, spRdOnly, spStillMap, fiInPa, fiMsPg, fiReTy,     fiUnknown, voBadPages, voInSp, voPgCntSmall, voNameRq, voNeedsSca,     voNotOpen, voNotOnline, voRdOnly, voTooManySv, voUnknown};  Do: SIGNAL = CODE;  Try: PROCEDURE [mask: Mask, commentary: STRING] =    BEGIN    s: STRING = [100];    err: Mask ¬ nil;    SIGNAL Do[      !      Space.Error =>        SELECT type FROM	  alreadyAllocated => BEGIN err ¬ spAlAlloc; CONTINUE END;	  alreadyDeallocated => BEGIN err ¬ spDealloc; CONTINUE END;	  incompleteSwapUnits => BEGIN err ¬ spIncSU; CONTINUE END;          invalidParameters => BEGIN err ¬ spInPa; CONTINUE END;	  invalidProcedure => BEGIN err ¬ spInProc; CONTINUE END;	  invalidSwapUnitSize => BEGIN err ¬ spInSUSize; CONTINUE END;          invalidWindow => BEGIN err ¬ spInWi; CONTINUE END;	  pointerPastEndOfMemory => BEGIN err ¬ spPtrPastEndOfMem; CONTINUE END;	  readOnly => BEGIN err ¬ spRdOnly; CONTINUE END;	  stillMapped => BEGIN err ¬ spStillMap; CONTINUE END;	  notAllocated => BEGIN err ¬ spNotAlloc; CONTINUE END;	  notMapped => BEGIN err ¬ spNotMap; CONTINUE END;          noWindow => BEGIN err ¬ spNoWi; CONTINUE END;          ENDCASE => ERROR;      Space.InsufficientSpace => BEGIN err ¬ spInSp; CONTINUE END;      Space.IOError => BEGIN err ¬ spIOError; CONTINUE END;      File.Error =>        SELECT type FROM	  invalidParameters => BEGIN err ¬ fiInPa; CONTINUE END;          reservedType => BEGIN err ¬ fiReTy; CONTINUE END;          ENDCASE => ERROR;       File.MissingPages => BEGIN err ¬ fiMsPg; CONTINUE END;      File.Unknown => BEGIN err ¬ fiUnknown; CONTINUE END;      Volume.Error =>        SELECT error FROM 	  nameRequired => BEGIN err ¬ voNameRq; CONTINUE END;	  pageCountTooSmallForVolume => BEGIN err ¬ voPgCntSmall; CONTINUE END;	  subvolumeHasTooManyBadPages => BEGIN err ¬ voBadPages; CONTINUE END;	  tooManySubvolumes => BEGIN err ¬ voTooManySv; CONTINUE END;	  ENDCASE => ERROR;      Volume.InsufficientSpace => BEGIN err ¬ voInSp; CONTINUE END;      Volume.NeedsScavenging => BEGIN err ¬ voNeedsSca; CONTINUE END;      Volume.NotOnline => BEGIN err ¬ voNotOnline; CONTINUE END;      Volume.NotOpen => BEGIN err ¬ voNotOpen; CONTINUE END;      Volume.ReadOnly => BEGIN err ¬ voRdOnly; CONTINUE END;      Volume.Unknown => BEGIN err ¬ voUnknown; CONTINUE END];    IF err ~= mask THEN      BEGIN      String.AppendString[s, "Unexpected exception condition from "L];      String.AppendString[s, commentary];      Report[s]      END    END;  Check: PROCEDURE [aspect: LONG STRING, ok: BOOLEAN] =    BEGIN    s: STRING = [100];    IF ~ok THEN      BEGIN      String.AppendString[s, "check of "L];      String.AppendString[s, aspect];      String.AppendString[s, " failed"L];      Report[s]      END    END;  CheckSpace: PROCEDURE [    space: Space.Interval, checkSize: BOOLEAN, size: Space.PageCount,    checkMapped: BOOLEAN,     mapped: BOOLEAN] =    BEGIN    mapUnit: Space.Interval;    window: Space.Window;    Try[      nil, "Space.GetAttributes[checkee]"L !      Do => [mapUnit,window, , , ] ¬ Space.GetMapUnitAttributes[space.pointer]];    IF checkSize THEN Check["space size"L, space.count = size];    IF checkMapped THEN       BEGIN      mappedInt: BOOLEAN;      mappedInt ¬ ~(mapUnit = Space.nullInterval AND  window.count = 0);       Check["space mapping"L, mappedInt = mapped]        END;    END;  CheckFile: PROCEDURE [    file: File.File, type: File.Type, temporary: BOOLEAN, size: File.PageCount] =    BEGIN    ty: File.Type;    te: BOOLEAN;    s: File.PageCount;    Try[      nil, "File.GetAttributes[checkee]"L !      Do => [ty, te] ¬ File.GetAttributes[file]];    Try[nil, "File.GetSize[checkee]"L ! Do => s ¬ File.GetSize[file]];    Check["file type"L, ty = type];    Check["file permanence"L, te = temporary];    Check["file size"L, s = size];    END;  TestSpace: PROCEDURE =    BEGIN    ptr: LONG POINTER;    page: Space.PageNumber;    intervalPtrBiggerThanVm: Space.Interval ¬ [      LOOPHOLE[Environment.wordsPerPage * countVm, LONG POINTER], 1];    TTY.PutLine[tty, "Testing space operations."L];        Try[nil, "MDS[]"L ! Do => siExt ¬ Space.MDS[]];    Check["MDS[]=siMds", siExt = siMds];    CheckSpace[siExt, FALSE, 0, TRUE, FALSE];    Try[      spInSp, "within: siNull to Allocate"L !      Do => siSink ¬ Space.Allocate[1, siNull, Space.defaultBase]];    Try[      spInPa, "illegal base to Allocate"L !      Do => siSink ¬ Space.Allocate[1, siVm, countVm]];       -- use base of interval of process calling it    Try[      spAlAlloc, "in-use base to Allocate"L !      Do => siSink ¬ Space.Allocate[1, siVm, Space.PageFromLongPointer[siMds.pointer]]];    Try[      spInPa, "size: 0 to Allocate"L !      Do => siSink ¬ Space.Allocate[0, siVm, Space.defaultBase]];    Try[      spInSp, "size: countVm to Allocate"L !      Do => siSink ¬ Space.Allocate[countVm, siVm, Space.defaultBase]];    Try[      spInSp, "size: LAST[PageCount] to Allocate"L !      Do =>        siSink ¬ Space.Allocate[LAST[Space.PageCount], siVm, Space.defaultBase]];    Try[      nil, "siInt ¬ Allocate[1, siMds, defaultBase]"L !      Do => siInt ¬ Space.Allocate[1, siMds, Space.defaultBase]];    CheckSpace[siInt, TRUE, 1, TRUE, FALSE];        Try[      nil,  "int ¬ Allocate[2, siVm, defaultBase]"L !      Do => int ¬ Space.Allocate[2, siVm, Space.defaultBase]];    CheckSpace[int, TRUE, 2, TRUE, FALSE];        Try[      spInPa, "ptr ¬ Pointer[int.pointer]"L !       Do => ptr ¬ Space.Pointer[int.pointer]];          Try[      nil, "ptr ¬ Pointer[siInt.pointer]"L !       Do => ptr ¬ Space.Pointer[siInt.pointer]];          page ¬ Space.PageFromLongPointer[int.pointer];    Try[      spInPa, "ptr ¬ PointerFromPage[page]"L !      Do => ptr ¬ Space.PointerFromPage[page]];          page ¬ Space.PageFromLongPointer[siInt.pointer];    Try[      nil, "ptr ¬ PointerFromPage[page]"L !      Do => ptr ¬ Space.PointerFromPage[page]];      Try[      spInSp, "too large size to Allocate"L      ! Do => siSink ¬ Space.Allocate[3, siInt, Space.defaultBase]];    Try[      spAlAlloc, "siIntSpec ¬ Allocate[1, siInt, 0]"L !      Do => siIntSpec ¬ Space.Allocate[1, siInt, 0]];          Try[      nil, "siNull to PageFromLongPointer"L !      Do => pnSink ¬ Space.PageFromLongPointer[siNull.pointer]];    -- Test if siNull is mapped    CheckSpace[siNull, FALSE, 0, TRUE, FALSE];        -- Test if siVm is mapped    CheckSpace[siVm, FALSE, 0, TRUE, FALSE];      -- Test if siMds is mapped    CheckSpace[siMds, FALSE, 0, TRUE, FALSE];              Try[nil, "PageFromLongPointer[int]"L ! Do => pn ¬ Space.PageFromLongPointer[int.pointer]];      Check[        "LongPointer[int]=256*PageFromLongPointer[int.pointer]"L, int.pointer = LOOPHOLE[256 * pn,        LONG POINTER]];          Try[spInProc, "ActivateProc[NIL]"L ! Do => Space.ActivateProc[NIL]];        Try[spPtrPastEndOfMem, "Activate with pointer past end of memory"L !      Do => Space.Activate[intervalPtrBiggerThanVm]];        END;  TestVolume: PROCEDURE =    BEGIN    readWrite: Space.Access ¬ readWrite;    status: Volume.Status ¬ unknown;    typeSet: Volume.TypeSet ¬ ALL[TRUE];        TTY.PutLine[tty, "Testing volume operations."L];    Try[nil, "vidSys ¬ SystemID[]"L ! Do => vidSys ¬ Volume.SystemID[]];    Try[nil, "vid ¬ GetNext[vidNull]"L ! Do => vid ¬ Volume.GetNext[vidNull]];            FOR vol:Volume.ID ¬ Volume.GetNext[vidNull, typeSet], Volume.GetNext[vol, typeSet] UNTIL vol = vidNull DO      SELECT Volume.GetStatus[vol] FROM        <<	openRead => Try[voRdOnly, "Map on readOnly volume with readWrite Access"L	  ! Do => [] ¬ Space.Map[window: [someFileOnVol, 0, 1], access: readWrite]];	>>	closedAndInconsistent => Try[voNeedsSca, " open a closed and inconsistant volume "L !	  Do => Volume.Open[vol]];	closedAndConsistent => BEGIN	  fileOnClosedVol: File.File ¬ [File.nullID, vol];	  Try[voNotOpen, "CopyIn from closed volume"L !	    Do => [] ¬ Space.CopyIn[int.pointer, [fileOnClosedVol, 0, 1]]];	  END;	ENDCASE;	         ENDLOOP;    --Test GetNext (more), GetAttributes    END;  TestFile: PROCEDURE =    BEGIN    TTY.PutLine[tty, "Testing file operations."L];    Try[      voUnknown, "vidNull to Create"L !      Do => fileSink ¬ File.Create[vidNull, 1, ftUntyped]];          Try[      fiInPa, "file ¬ Create[vidSys, 0, ftUntyped]"L !      Do => file ¬ File.Create[vidSys, 0, ftUntyped]];        Try[      fiReTy, "pilot file to create"L !      Do => file ¬ File.Create[vidSys, 1, PilotFileTypes.tVolumeFileMap]];    Try[      nil, "file ¬ Create[vidSys, 1, ftUntyped]"L !      Do => file ¬ File.Create[vidSys, 1, ftUntyped]];    CheckFile[file, ftUntyped, TRUE, 1];    Try[      voUnknown, "nullFile to SetSize"L !      Do => File.SetSize[File.nullFile, 2]];    Try[nil, "MakePermanent[file]"L ! Do => File.MakePermanent[file]];    CheckFile[file, ftUntyped, FALSE, 1];    END;  TestMapping: PROCEDURE =    BEGIN    defaultWindow: Space.Window ¬ [File.nullFile, 0, LAST[ Environment.PageCount]];    irregSu: ARRAY [0..3) OF Space.SwapUnitSize ¬ [1, 3, 1];    mu: Space.Interval;    access: Space.Access ¬ readOnly;    su: Space.SwapUnitOption;    TTY.PutLine[tty, "Testing mapping/unmapping operations."L];    Try[spNoWi, "siNull to MapAt"L ! Do => [] ¬ Space.MapAt[siNull, defaultWindow]];    Try[nil, "siNull to MakeReadOnly"L ! Do => Space.MakeReadOnly[siNull]];        Try[spNotMap, "siNull to UnmapAt"L !      Do => [] ¬ Space.UnmapAt[siNull.pointer]];        Try[spNotMap, "vm to UnmapAt"L ! Do => [] ¬ Space.UnmapAt[siVm.pointer]];    Try[nil, "MapAt[at:siInt, window: [file, 0, 1], access: access]"L ! Do => [] ¬ Space.MapAt[at:siInt, window: [file, 0, 1], access: access]];    CheckSpace[siInt, TRUE, 1, TRUE, TRUE];    Try[spRdOnly, "CopyIn to readOnly interval"L !      Do => [] ¬ Space.CopyIn[siInt. pointer, [file, 0, 1]]];    Try[      spStillMap, "already mapped space to MapAt"L !      Do => [] ¬ Space.MapAt[siInt, [file, 0, 1]]];    Try[      nil, "siIntOther ¬ Allocate[1, siMds, Space.defaultBase]"L !      Do => siIntOther ¬ Space.Allocate[1, siMds, Space.defaultBase]];          access ¬ readWrite;    Try[nil, "MapAt[at: siIntOther, window: [file, 0, 1], access: access]"L !      Do => [] ¬ Space.MapAt[at:siIntOther, window: [file, 0, 1], access: access]];    CheckSpace[siIntOther, TRUE, 1, TRUE, TRUE];    siIntOther.pointer­ ¬ 12345;    Try[nil, "ForceOut[siIntOther]"L ! Do => Space.ForceOut[siIntOther]];    Check[      "siInt.pointer­=siIntOther.pointer­=12345"L, siInt.pointer­ = 12345      AND siIntOther.pointer­ = 12345];    Try[nil, "UnmapAt[siIntOther.pointer]"L ! Do => [] ¬ Space.UnmapAt[siIntOther.pointer]];    CheckSpace[siIntOther, TRUE, 1, TRUE, FALSE];        Try[nil, "MakeWritable"L ! Do => Space.MakeWritable[siInt]];    CheckSpace[siInt, TRUE, 1, TRUE, TRUE];        Try[nil, "UnmapAt[siInt.pointer]"L ! Do => [] ¬      Space.UnmapAt[siInt.pointer]];    CheckSpace[siInt, TRUE, 1, TRUE, FALSE];        -- Replace following test with commented out version when AR 7554 is fixed.    Try[spInPa, "mu ¬ Map[[file, 0, 0]]"L ! Do => mu ¬ Space.Map[[file, 0, 0]]];    --Try[spNoWi, "mu ¬ Map[[file, 0, 0]]"L ! Do => mu ¬ Space.Map[[file, 0, 0]]];        Try[spInWi, "map of window outside of file"L !      Do => mu ¬ Space.Map[[file, File.maxPagesPerFile, 1]]];             su ¬ [irregular[DESCRIPTOR[BASE[irregSu], 3]]];    -- following test was commented out previously for AR 7291 (has been fixed)    Try[spIncSU, "sum of swapUnits.sizes < map unit size"L !      Do => mu ¬ Space.Map[window: [File.nullFile, 0, 6], swapUnits: su]];          irregSu ¬ [4, 0, 1];    -- following test was commented out previously for AR 7291 (has been fixed)    Try[spInSUSize, "0 as swap unit size"L !      Do => mu ¬ Space.Map[window: [File.nullFile, 0, 5], swapUnits: su]];            Try[nil, "mu ¬ Map[[file,0,1]]"L !       Do => mu ¬ Space.Map[[file, 0, 1]]];    CheckSpace[mu, TRUE, 1, TRUE, TRUE];        Try[nil, "Unmap[mu.pointer]"L !      Do => mu.pointer ¬ Space.Unmap[mu.pointer]];    CheckSpace[mu, FALSE, 0, TRUE, FALSE];     Try[spNotMap, "unmapped space to unmap"L !      Do => mu.pointer ¬ Space.Unmap[mu.pointer]];            Try[      nil, "unmapped space to MakeReadOnly"L !      Do => Space.MakeReadOnly[mu]];    Try[spNotMap, "siMds to Unmap"L ! Do =>        [siMds.pointer] ¬ Space.Unmap[siMds.pointer]];     << Both Space.InsufficientSpace and Volume.InsufficientSpace can be raised.       This code does not yet allow for mutliple errors    Try[voInSp, "dataWindow too large"L !       Do =>  [] ¬ Space.Map[[File.nullFile, 0, countVm]]];    >>	     END;  TestSpaceDeletion: PROCEDURE =    BEGIN    TTY.PutLine[tty, "Testing space deletion."L];        Try[nil, "second MapAt[siInt, [file, 0, 1]]"L !       Do => [] ¬ Space.MapAt[siInt, [file, 0, 1]]];    CheckSpace[siInt, TRUE, 1, TRUE, TRUE];        Try[spStillMap, "deallocate mapped interval"L !      Do => Space.Deallocate[siInt]];          Try[nil, "UnmapAt[siInt.pointer]"L !      Do => [] ¬ Space.UnmapAt[siInt.pointer]];    CheckSpace[siInt, TRUE, 1, TRUE, FALSE];           Try[nil, "Deallocate[siInt]"L !       Do => Space.Deallocate[siInt]];    Try[spDealloc, "deallocated interval to deallocate"L !       Do => Space.Deallocate[siInt]];          Try[nil, "Deallocate[int]"L ! Do => Space.Deallocate[int]];    Try[nil, "Deallocate[siIntOther]"L ! Do => Space.Deallocate[siIntOther]];        END;  TestFileDeletion: PROCEDURE =    BEGIN    TTY.PutLine[tty, "Testing file deletion operations."L];    Try[nil, "Delete[file]"L ! Do => File.Delete[file]];    Try[fiUnknown, "already-deleted file to Delete"L ! Do => File.Delete[file]];    END;  StorageTestCommand: Command.Action =    BEGIN    Command.Confirm[h];    TTY.PutLine[h, "StorageTest of May 8, 1979"L];    countReported ¬ 0;    BEGIN    ENABLE Do => RESUME ;    TestSpace[];    TestVolume[];    TestFile[];    TestMapping[];    TestSpaceDeletion[];    TestFileDeletion[]    END;    TTY.PutChar[h, Ascii.CR];    IF countReported = 0 THEN TTY.PutLine[h, "Tests successfully completed."L]    ELSE      BEGIN      TTY.PutDecimal[h, countReported];      TTY.PutLine[h, " problems reported."L]      END    END;  Command.InstallTopLevel[tty, ["test storage", StorageTestCommand]]  END.LOGAugust 11, 1980  9:13 AM	WDK	Space.GetWindow now only returns read, write permissions.August 14, 1980  9:34 AM	SXY	IODefs and Command are replaced by TTY and TTYCommand respectively.September 8, 1980  8:08 PM	SXY	TTYCommand is replaced by new Command.January 16, 1981  5:54 PM	CAJ	TestSpace fix for nonzero mds.8-Sep-81 14:14:59	        SXY	Space.Remap related codes are commented out.28-Jan-83 15:41:03		EKT	Updated to Klamath, deleted Space.Remap comments28-Jun-83 14:38:51		EKT	Fix CheckSpace to use space.pointer instead of mapunit.pointer.  Fix minor checks in TestSpace, TestMapping, and TestFile.14-Jun-85 16:43:07		CJS, CAJ ftZero ¬  ftUntyped: tUntypedFile.  spNoWi in TestMapping.  Remove UnmapAt test for duplicated pointer.  Temporary fixes/removal for assorted broken tests. 6-Nov-85 11:19:26              RSV      Removed line "Check["GetNext[vidNull]=SystemID[]"L, vid = vidSys];" from TestVolume since this was a bogus test (AR 4499).11-Nov-86 11:03:45              RSV      Re-added lines in TestMapping commented out for AR 7291.
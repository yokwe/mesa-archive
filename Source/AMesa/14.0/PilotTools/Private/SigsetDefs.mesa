-- Copyright (C) 1983, 1987  by Xerox Corporation. All rights reserved. -- SigsetDefs.mesa    last edited by: ET          21-Apr-87 18:36:18-- Test software for Pilot.-- Sigset defines a lare enumerated type "Sig", that names all of the signal situations that may arise when calling a public Pilot procedure.  This includes names for all of Pilot's public signals, plus "none" and "other".  In addition, SigsetDefs defines the object "Sigset".  Objects of type Sigset represent subsets of the set of all Sig's.-- See also SigsetAuxDefs.SigsetDefs: DEFINITIONS =BEGIN------------------------------------------ Public types and constants  -- Sig names ALL OF Pilot's public SIGNALsSig: TYPE = {    none,				-- no signals    byteBltStartIndexGreaterThanStopIndexPlusOne,					-- ByteBlt.StartIndexGreaterThanStopIndexPlusOne    fileInvalidParameters,		-- File.Error[invalidParameters]    fileReservedType,			-- File.Error[reservedType]    fileUndefined,			-- File.Error[?? type NOT IN File.ErrorType ??]    fileMissingPages,			-- File.MissingPages    fileUnknown,			-- File.Unknown    heapInsufficientSpace,		-- Heap.Error[insufficientSpace]    heapInvalidHeap,			-- Heap.Error[invalidHeap]    heapInvalidNode,			-- Heap.Error[invalidNode]    heapInvalidZone,			-- Heap.Error[invalidZone]    heapInvalidOwner,			-- Heap.Error[invalidOwner]    heapOtherError,			-- Heap.Error[otherError]    heapInvalidSize,			-- Heap.Error[invalidSize]    heapInvalidParameters,		-- Heap.Error[invalidParameters]    heapMaxSizeExceeded,		-- Heap.Error[maxSizeExceeded]    heapUndefined,			-- Heap.Error[?? type NOT IN Heap.ErrorType ??]    physicalVolumeBadDisk,		-- PhysicalVolume.Error[badDisk]    physicalVolumeBadSpotTableFull,	-- PhysicalVolume.Error[badSpotTableFull]    physicalVolumeContainsOpenVolumes,	-- PhysicalVolume.Error[containsOpenVolumes]    physicalVolumeDiskReadError,	-- PhysicalVolume.Error[diskReadError]    physicalVolumeHardwareError,	-- PhysicalVolume.Error[hardwareError]    physicalVolumeHasPilotVolume,	-- PhysicalVolume.Error[hasPilotVolume]    physicalVolumeAlreadyAsserted,	-- PhysicalVolume.Error[alreadyAsserted]    physicalVolumeInsufficientSpace,	-- PhysicalVolume.Error[insufficientSpace]    physicalVolumeInvalidHandle,	-- PhysicalVolume.Error[invalidHandle]    physicalVolumeNameRequired,		-- PhysicalVolume.Error[nameRequired]    physicalVolumeNotReady,		-- PhysicalVolume.Error[notReady]    physicalVolumeNoSuchDrive,		-- PhysicalVolume.Error[noSuchDrive]    physicalVolumeNoSuchLogicalVolume,    		-- PhysicalVolume.Error[noSuchLogicalVolume]    physicalVolumePhysicalVolumeUnknown,	-- PhysicalVolume.Error[physicalVolumeUnknown]    physicalVolumeWriteProtected,	-- PhysicalVolume.Error[writeProtected]    physicalVolumeWrongFormat,		-- PhysicalVolume.Error[wrongFormat]    physicalVolumeUndefined,		-- PhysicalVolume.Error[?? error NOT IN PhysicalVolume.ErrorType ??]    physicalVolumeNeedsScavenging,	-- PhysicalVolume.NeedsScavenging    processInvalidProcess,		-- Process.InvalidProcess    processTooManyProcesses,		-- Process.TooManyProcesses    runtimeVersionMismatch,		-- Runtime.VersionMismatch    runtimeInvalidGlobalFrame,		-- Runtime.InvalidGlobalFrame    runtimeInvalidFrame,		-- Runtime.InvalidFrame    runtimeBoundsFault,			-- Runtime.BoundsFault    runtimeConfigErrorBadCode,		-- Runtime.ConfigError[badCode]    runtimeConfigErrorExportedTypeClash,    		-- Runtime.ConfigError[exportedTypeClash]    runtimeConfigErrorInvalidConfig,	-- Runtime.ConfigError[invalidConfig]    runtimeConfigErrorMissingCode,	-- Runtime.ConfigError[missingCode]    runtimeConfigErrorUnknown,		-- Runtime.ConfigError[unknown]    runtimeConfigErrorUndefined,		-- Runtime.ConfigError[?? type NOT IN Runtime.ConfigErrorType ??]    runtimeControlFault,		-- Runtime.ControlFault    runtimeDivideCheck,			-- Runtime.DivideCheck    runtimeLinkageFault,		-- Runtime.LinkageFault    runtimeNarrowFault,			-- Runtime.NarrowFault    runtimePointerFault,		-- Runtime.PointerFault    runtimePortFault,			-- Runtime.PortFault    runtimeStartFault,			-- Runtime.StartFault    runtimeUnboundProcedure,		-- Runtime.UnboundProcedure    runtimeZeroDivisor,			-- Runtime.ZeroDivisor    scavengerCannotWriteLog,		-- Scavenger.Error[cannotWriteLog]    scavengerNoSuchPage,		-- Scavenger.Error[noSuchPage]    scavengerOrphanNotFound,		-- Scavenger.Error[orphanNotFound]    scavengerVolumeOpen,		-- Scavenger.Error[volumeOpen]    scavengerDiskHardwareError,		-- Scavenger.Error[diskHardwareError]    scavengerDiskNotReady,		-- Scavenger.Error[diskNotReady]    scavengerNeedsRiskyRepair,		-- Scavenger.Error[needsRiskyRepair]    scavengerUndefined,    		-- Scavenger.Error[?? error NOT IN Scavenger.ErrorType ??]    spaceAlreadyAllocated,		-- Space.Error[alreadyAllocated]    spaceAlreadyDeallocated,		-- Space.Error[alreadyDeallocated]    spaceIncompleteSwapUnits,		-- Space.Error[incompleteSwapUnits]    spaceInvalidParameters,		-- Space.Error[invalidParameters]    spaceInvalidProcedure,		-- Space.Error[invalidProcedure]    spaceInvalidSwapUnitSize,		-- Space.Error[invalidSwapUnitSize]    spaceInvalidWindow,			-- Space.Error[invalidWindow]    spaceStillMapped,			-- Space.Error[stillMapped]    spaceNotAllocated,			-- Space.Error[notAllocated]    spaceNotMapped,			-- Space.Error[notMapped]    spaceNoWindow,			-- Space.Error[noWindow]    spacePointerPastEndOfMemory,	-- Space.Error[pointerPastEndOfMemory]    spaceReadOnly,			-- Space.Error[readOnly]    spaceUndefined,    		-- Space.Error[?? type NOT IN Space.ErrorType ??]    spaceInsufficientSpace,		-- Space.InsufficientSpace    spaceIOError,			-- Space.IOError    streamAttention,			-- Stream.Attention    streamEndOfStream,			-- Stream.EndOfStream    streamLongBlock,			-- Stream.LongBlock    streamShortBlock,			-- Stream.ShortBlock    streamSSTChange,			-- Stream.SSTChange    streamTimeOut,			-- Stream.TimeOut    streamInvalidOperation,		-- Stream.InvalidOperation    temporaryBootingInvalidParameters,	-- TemporaryBooting.InvalidParameters    temporaryBootingInvalidVersion,	-- TemporaryBooting.InvalidVersion    userTerminalBitmapIsDisconnected,	-- UserTerminal.BitmapIsDisconnected    volumeNameRequired,			-- Volume.Error[nameRequired]    volumePageCountTooSmallForVolume,    		-- Volume.Error[pageCountTooSmallForVolume]    volumeSubvolumeHasTooManyBadPages,    		-- Volume.Error[subvolumeHasTooManyBadPages]    volumeTooManySubvolumes,		-- Volume.Error[tooManySubvolumes]    volumeUndefined,    		-- Volume.Error[?? type NOT IN Volume.ErrorType ??]    volumeRootDirectoryDirectoryFull,    		-- Volume.RootDirectoryError[directoryFull]    volumeRootDirectoryDuplicateRootFile,    		-- Volume.RootDirectoryError[duplicateRootFile]    volumeRootDirectoryInvalidRootFileType,    		-- Volume.RootDirectoryError[invalidRootFileType]    volumeRootDirectoryRootFileUnknown,    		-- Volume.RootDirectoryError[rootFileUnknown]    volumeRootDirectoryUndefined,	-- Volume.RootDirectoryError[?? type NOT IN Volume.RootDirectoryErrorType ??]    volumeInsufficientSpace,		-- Volume.InsufficientSpace    volumeNeedsScavenging,		-- Volume.NeedsScavenging    volumeNotOnline,			-- Volume.NotOnline    volumeNotOpen,			-- Volume.NotOpen    volumeReadOnly,			-- Volume.ReadOnly    volumeUnknown,			-- Volume.Unknown    other,				-- a non Pilot-specific signal (ANY)    nonRecoverable		-- a non-recoverable problem (e.g., AddressFault)    };  -- Sigset object:  A mutable set of Sig values.  -- For more documentation, see public Sigset operations, below.Sigset: TYPE = LONG POINTER TO Aqsigset;------------------------------------------ Public procedures:  Manipulate Sig values.-- See also the procedures in SigsetAuxDefs.  -- StringFromSig returns a (globally allocated) string with a printable  -- representation of Sig 'm'.StringFromSig: PROCEDURE [Sig] RETURNS [LONG STRING];------------------------------------------ Public procedures:  Manage Sigset objects-- Sigset objects represent sets of Sig values, i.e., subsets of the set of all Sig's.  Every Sig value is either in the set or not;  this includes the value "none".  Note that {none} is different from the empty set {}.  The purpose of a Sigset object is to inform Try of the possible signal situations (each represented by a Sig value) that are acceptable, i.e., the set of alternative expected situations.-- A Sigset object is mutable, that is, it's contents may be changed.  -- AddDefiniteError adds a "definite error" to a set of error Sig's.  A  -- "definite error" is one that should definitely arise, unless a different  -- error arises (first).  Therefore, AddDefiniteError makes sure that "none"  -- is not a possibility (that is, it removes "none" from the Sigset), and it  -- inserts the new error Sig.  AddDefiniteError signals  -- Error[noneConstruedAsAnError] if the error argument is "none".AddDefiniteError: PROCEDURE [errorSet: Sigset, error: Sig];  -- AddNonRecoverable adds "nonRecoverable" to an error set if "none" is in  -- the set.  This is for the cases where the operation in question would be  -- non-recoverable IFF it doesn't raise a signal.AddNonRecoverable: PROCEDURE [errorSet: Sigset];  -- = IF IsIn[errorSet, none] THEN AddDefiniteError[errorSet, nonRecoverable]  -- AddPotentialError adds a "potential error" to a set of error Sig's.  A  -- "potential error" is one that we don't have enough information to predict  -- for sure;  it could happen, but it's ok if no errors happen.  Therefore,  -- AddPotentialError merely inserts the new error Sig.  AddPotentialError  -- signals Error[noneConstruedAsAnError] if the error argument is "none".  --"Potential errors" (as opposed to "definite errors" and singleton sigsets)  -- arise from limitations in the model.AddPotentialError: PROCEDURE [errorSet: Sigset, error: Sig];  -- Create allocates and returns a new, empty Sigset object.Create: PROCEDURE RETURNS [Sigset];  -- Destroy destroys a Sigset object and releases its storage.Destroy: PROCEDURE [set: Sigset];  -- Empty performs:  set ¬ {}.Empty: PROCEDURE [set: Sigset];  -- InitToNone performs:  set ¬ {none}, which is quite different from Empty!InitToNone: PROCEDURE [set: Sigset];  -- Insert performs:  set ¬ UNION[set, {insert}].Insert: PROCEDURE [set: Sigset, insert: Sig];  -- IsIn finds out if a Sig is an element of a given Sigset.IsIn: PROCEDURE [set: Sigset, item: Sig] RETURNS [BOOLEAN];  -- Monad makes a monadic Sigset, that is, it performs: set ¬ {item}.Monad: PROCEDURE [set: Sigset, item: Sig];  -- Remove performs:  set ¬ INTERSECTION[set, COMPLEMENT[{remove}]],  -- where COMPLEMENT is the complement of a set with respect to the set of  -- all signals.Remove: PROCEDURE [set: Sigset, remove: Sig];  -- StringFromSigset generates a string representation of a Sigset.  It  -- builds this representation into its "buffer" string argument.  The result  -- is of the form "{signal1, signal2, signal3}", or just "{}".StringFromSigset: PROCEDURE [set: Sigset, buffer: LONG STRING];  -- WriteSigset constructs a string representation of a Sigset piecemeal,  -- calling a procedure "writeProc" to take each piece, e.g., for printing.  -- If writeProc appends its arguments to some buffer string, then  -- WriteSigset acts just like StringFromSigset.  Its advantage is avoiding  -- the need to have a buffer to build a string into, and avoiding the  -- buffer size limitations, when you merely want to write the Sigset out.WriteSigset: PROCEDURE [set: Sigset, writeProc: PROCEDURE [LONG STRING]];------------------------------------------ Public errors and signals  -- General purpose error.Error: ERROR [errortype: Errortype, msg: STRING];Errortype: TYPE = {  -- client errors    invalidArgument,    stringOverflow,    noneConstruedAsAnError,  -- errors in Sigset    bugInSigsetPack    };------------------------------------------ Public program SigsetPackSigsetPack: PROGRAM;------------------------------------------ Private stuff  -- Clients are now allowed to allocate Aqsigset's in their own frames, if  -- they want to do that instead of Create & Destroy.Aqsigset: TYPE = PRIVATE PACKED ARRAY Sig OF BOOLEAN ¬ ALL[FALSE];END.LOG OF SIGNIFICANT CHANGESDate: August 3, 1979, By: JHM, Action: Created file by removing this stuff  from TryDefs.Date: December 6, 1979, By: JHM, Action: Added "nonRecoverable" to Sig, for  error situations that we can't recover from, e.g., AddressFault.Date: February 12, 1980, By: JHM, Action: Update for Amargosa.Date: August 11, 1980, By: SEH, Action: Partial Update for Mokolumne: RS232C,  RS232CManager.Date: August 20, 1980, By: JHM, Action: Update for Mokolumne and Mesa 6.Date: September 17, 1980, By: JHM, Action: Moved the enumerated type  translation procs off to a new interface SigseAuxDefs.Date: September 29, 1980, By: JHM, Action: Made Sigset LONG.  Made  StringFromSigset's "buffer" arg LONG.Date: March 9, 1981, By: JHM, Action: Full update for Rubicon--Removed Socket  (now a private interface) & NetworkStream & RS232C* (communications interfaces,  not Pilot;  and they change too much!);  added 2 new Scavenger error codes.Date: 13-Jan-83 15:23:03, By: CAJ , Action: Update for Klamath.Date: 19-Aug-83 17:08:06, By: AWL      , Action: Deleted runtimeNoGlobalFrameSlots and added runtiemNarrowFault to Sig.Date: 21-Apr-87 18:36:30, By: ET      , Action: Pilot 14.0 changes.
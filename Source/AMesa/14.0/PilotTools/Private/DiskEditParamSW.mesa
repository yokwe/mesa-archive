-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- DiskEditParamSW.mesa  22-Apr-85 17:16:33 by CAJ DIRECTORY  DiskChannel USING [    Create, defaultTries, DiskPageNumber, Drive, DoIO, GetDriveAttributes,     GetNextDrive, GetPageAddress, GetPageNumber, goodCompletion, Handle,     IORequest,  IOStatus, nullDrive, nullHandle],  DiskEditInternal USING [    CleanupLabelSW, dataPtr, dataWindowKey, diskLabel, FillLabelSW, labelSW,    msgSW],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Display, DisplayItem, Enumerated, EnumeratedItem, EnumeratedNotifyProcType,    ItemHandle, LabelItem, LongNumberItem, newLine, nextPlace, NumberItem,    ProcType],  MsgSW USING [Clear, Post],  PilotDisk USING [Address, Label],  PilotDiskFace USING [Command],  Space USING [GetMapUnitAttributes, PageCount, PageFromLongPointer],  VM USING [MakeResident, MakeSwappable, ReturnWait],  UserTerminal USING [BlinkDisplay],  WindowSwap USING [    CurrentViewHandle, Error, UpdateDataFromView, UpdateViewFromData];DiskEditParamSW: PROGRAM  IMPORTS    DiskChannel, DiskEditInternal, FormSW, MsgSW, Space,    VM, UserTerminal, WindowSwap  EXPORTS DiskEditInternal  SHARES DiskChannel =  BEGIN  HeadAndSectorType: TYPE = [0..256);  paramPageNumberBaseIndex: CARDINAL ¬ 0;  paramPageNumberOffsetIndex: CARDINAL ¬ 0;  paramPageNumberIOIndex: CARDINAL ¬ 0;  paramCylinderIndex: CARDINAL ¬ 0;  paramSectorIndex: CARDINAL ¬ 0;  paramHeadIndex: CARDINAL ¬ 0;  paramUsePageNumberIndex: CARDINAL ¬ 0;  paramUseDiskAddressIndex: CARDINAL ¬ 0;    TerminationCondition: TYPE = {goodCompletion, failure};  diskDrive: MACHINE DEPENDENT RECORD [    drive(0): DiskChannel.Drive,    pageNumberValid(2:0..15): BOOLEAN,    diskAddressValid(3:0..15): BOOLEAN,    pageNumberOffset(4): DiskChannel.DiskPageNumber,    cylinder(6): CARDINAL,    head(7:0..15): HeadAndSectorType,    sector(8:0..15): HeadAndSectorType,    useDiskAddress(9:0..15): BOOLEAN,    usePageNumber(10:0..15): BOOLEAN,    currentCommand(11:0..15): PilotDiskFace.Command,    channel(12): DiskChannel.Handle,    address(15): PilotDisk.Address,    driveIndex(17): CARDINAL,    repeatCount(18): CARDINAL,    terminationCondition(19): TerminationCondition,    pageNumberBase(20): DiskChannel.DiskPageNumber,    pageNumberIO(22): DiskChannel.DiskPageNumber] ¬      [DiskChannel.nullDrive, FALSE, FALSE, 0, 0, 0, 0, FALSE, TRUE,       PilotDiskFace.Command[verify, read, read], DiskChannel.nullHandle,       [0, 0, 0], 0, 1, goodCompletion, 0, 0];  DiskAddressCommand: FormSW.ProcType =    BEGIN    IF ~ValidateDiskPageNumber[] THEN      BEGIN      MsgSW.Post[sw: DiskEditInternal.msgSW, string: "Page number invalid"L];      UserTerminal.BlinkDisplay[];      RETURN;      END;    diskDrive.address ¬ DiskChannel.GetPageAddress[      diskDrive.drive, GetDiskAddress[]];    diskDrive.cylinder ¬ diskDrive.address.cylinder;    diskDrive.sector ¬ diskDrive.address.sector;    diskDrive.head ¬ diskDrive.address.head;    FormSW.DisplayItem[sw, paramCylinderIndex];    FormSW.DisplayItem[sw, paramHeadIndex];    FormSW.DisplayItem[sw, paramSectorIndex];    END;  DoDiskIOCommand: FormSW.ProcType =    BEGIN    ENABLE WindowSwap.Error => IF type = noSuchKey THEN CONTINUE;    req: DiskChannel.IORequest;    returnWait: VM.ReturnWait ¬ wait;    status: DiskChannel.IOStatus;    dataPtrCount: Space.PageCount ¬       Space.GetMapUnitAttributes[DiskEditInternal.dataPtr].interval.count;    diskLabelCount: Space.PageCount ¬       Space.GetMapUnitAttributes[DiskEditInternal.diskLabel].interval.count;    -- First validate everything to be sure that a "reasonable" disk and sector are addressed    IF ~ValidateDrive[] THEN RETURN;    IF diskDrive.usePageNumber THEN      IF ~ValidateDiskPageNumber[] THEN        BEGIN        MsgSW.Post[sw: DiskEditInternal.msgSW, string: "Page number invalid"L];        UserTerminal.BlinkDisplay[];        RETURN;        END      ELSE {}  -- Use the page number and it is valid    ELSE  -- using the disk address      IF ~ValidateDiskHead[] THEN        BEGIN        MsgSW.Post[          sw: DiskEditInternal.msgSW, string: "Disk head number invalid"L];        UserTerminal.BlinkDisplay[];        RETURN;        END      ELSE        IF ~ValidateDiskSector[] THEN          BEGIN          MsgSW.Post[            sw: DiskEditInternal.msgSW, string: "Disk sector number invalid"L];          UserTerminal.BlinkDisplay[];          RETURN;          END;    FillDiskAddress[];    WindowSwap.UpdateDataFromView[DiskEditInternal.dataWindowKey];    DiskEditInternal.CleanupLabelSW[];    MsgSW.Clear[sw: DiskEditInternal.msgSW];    VM.MakeResident[      [Space.PageFromLongPointer[DiskEditInternal.dataPtr], dataPtrCount], returnWait];    VM.MakeResident[      [Space.PageFromLongPointer[DiskEditInternal.diskLabel], diskLabelCount], returnWait];    diskDrive.pageNumberIO ¬      IF diskDrive.usePageNumber THEN GetDiskAddress[]      ELSE DiskChannel.GetPageNumber[diskDrive.drive, diskDrive.address];    FormSW.DisplayItem[sw, paramPageNumberIOIndex];    req ¬ [      command: diskDrive.currentCommand,       diskPage:diskDrive.pageNumberIO,      memoryPage: Space.PageFromLongPointer[DiskEditInternal.dataPtr],      useSamePage: TRUE, count: 1,      label: LOOPHOLE[DiskEditInternal.diskLabel],      tries: DiskChannel.defaultTries      ];   THROUGH [0..diskDrive.repeatCount) DO      oldLabel: PilotDisk.Label;      oldLabel ¬ DiskEditInternal.diskLabel­;      status ¬ DiskChannel.DoIO[diskDrive.channel, @req].status;      IF diskDrive.currentCommand ~= [verify, read, read] THEN        DiskEditInternal.diskLabel­ ¬ oldLabel;      IF        (diskDrive.terminationCondition = goodCompletion          AND status = DiskChannel.goodCompletion)        OR          (diskDrive.terminationCondition = failure            AND status ~= DiskChannel.goodCompletion) THEN EXIT;      ENDLOOP;    VM.MakeSwappable[      [Space.PageFromLongPointer[DiskEditInternal.dataPtr], dataPtrCount]];    VM.MakeSwappable[      [Space.PageFromLongPointer[DiskEditInternal.diskLabel], diskLabelCount]];    IF status ~= DiskChannel.goodCompletion THEN      BEGIN      MsgSW.Post[        sw: DiskEditInternal.msgSW,        string:	WITH ioStatus: status SELECT FROM	  invalidChannel => "invalidChannel"L,	  invalidDriveState => "invalidDriveState"L,	  disk =>  SELECT ioStatus.status FROM	    inProgress => "inProgress"L,	    notReady => "notReady"L,	    recalibrateError => "recalibrateError"L,	    seekTimeout => "seekTimeout"L,	    headerCRCError => "headerCRCError"L,	    labelCRCError => "labelCRCError"L,	    dataCRCError => "dataCRCError"L,	    headerNotFound => "headerNotFound"L,	    labelVerifyError => "labelVerifyError"L,	    dataVerifyError => "dataVerifyError"L,	    overrunError => "overrunError"L,	    writeFault => "writeFault"L,	    memoryError => "memoryError"L,	    memoryFault => "memoryFault"L,	    clientError => "clientError"L,	    operationReset => "operationReset"L,	    otherError => "otherError"L,	    ENDCASE =>	      "An unknown PilotDiskFace error status has been returned"L,	            ENDCASE => "An unknown DiskChannel error status has been returned"L];      -- redisplay everything so the user sees the flakey data      DiskEditInternal.FillLabelSW[];      FormSW.Display[DiskEditInternal.labelSW];      WindowSwap.UpdateViewFromData[DiskEditInternal.dataWindowKey];      FormSW.Display[	WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey]];      UserTerminal.BlinkDisplay[];      END    ELSE -- status = DiskChannel.goodCompletion      SELECT diskDrive.currentCommand FROM        [verify, verify, read] =>          BEGIN          WindowSwap.UpdateViewFromData[DiskEditInternal.dataWindowKey];          FormSW.Display[	    WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey]];          END;        [verify, verify, write] => NULL;        [verify, read, read] =>          BEGIN          DiskEditInternal.FillLabelSW[];          WindowSwap.UpdateViewFromData[DiskEditInternal.dataWindowKey];          FormSW.Display[DiskEditInternal.labelSW];          FormSW.Display[	    WindowSwap.CurrentViewHandle[DiskEditInternal.dataWindowKey]];          END;        [verify, write, write] => NULL;        ENDCASE => ERROR;    END;  FillDiskAddress: PROCEDURE =    BEGIN    diskDrive.address ¬ [      cylinder: diskDrive.cylinder, head: diskDrive.head,      sector: diskDrive.sector];    END;  GetDiskAddress: PROCEDURE [] RETURNS [DiskChannel.DiskPageNumber] = INLINE    {RETURN[diskDrive.pageNumberBase+diskDrive.pageNumberOffset]};    MakeParamSW: PUBLIC FormSW.ClientItemsProcType =    BEGIN    i: CARDINAL ¬ 0;    nItems: CARDINAL = 17;    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[0] ¬ FormSW.LabelItem[tag: NIL, invisible: TRUE, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Device index"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @diskDrive.driveIndex, proc: NoticeNewDiskDriveIndex,      place: FormSW.newLine];    items[paramPageNumberBaseIndex ¬ i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "Page Number Base"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @diskDrive.pageNumberBase, place: FormSW.newLine];    items[paramPageNumberOffsetIndex ¬ i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "Page Number Offset"L, signed: FALSE, notNegative: TRUE,      radix: decimal, default: 0, value: @diskDrive.pageNumberOffset,      place: FormSW.nextPlace];    items[paramPageNumberIOIndex ¬ i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "Page Number for I/O"L, signed: FALSE, notNegative: TRUE,      radix: decimal, default: 0, value: @diskDrive.pageNumberIO,      readOnly: TRUE, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.LabelItem[      tag: "Disk Address"L, place: FormSW.newLine];    items[paramCylinderIndex ¬ i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "   Cylinder"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @diskDrive.cylinder, place: FormSW.nextPlace];    items[paramHeadIndex ¬ i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Head"L, signed: FALSE, notNegative: TRUE, radix: decimal, default: 0,      value: @diskDrive.head, place: FormSW.nextPlace];    items[paramSectorIndex ¬ i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Sector"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 0, value: @diskDrive.sector, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.CommandItem[      tag: "Convert to page number"L, proc: PageNumberCommand,      place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.CommandItem[      tag: "Convert to disk address"L, proc: DiskAddressCommand,      place: FormSW.nextPlace];    items[paramUseDiskAddressIndex ¬ i ¬ i + 1] ¬ FormSW.BooleanItem[      tag: "Use disk address"L, switch: @diskDrive.useDiskAddress,      proc: UseDiskAddressCommand, place: FormSW.newLine];    items[paramUsePageNumberIndex ¬ i ¬ i + 1] ¬ FormSW.BooleanItem[      tag: "Use page number"L, switch: @diskDrive.usePageNumber,      proc: UsePageNumberCommand, place: FormSW.nextPlace];    BEGIN    enumeratedCommandTypes: ARRAY [0..4) OF FormSW.Enumerated ¬ [      [string: "vvr"L, value: PilotDiskFace.Command[verify, verify, read]], [       string: "vvw"L, value: PilotDiskFace.Command[verify, verify, write]], [       string: "vrr"L, value: PilotDiskFace.Command[verify, read, read]], [       string: "vww"L, value: PilotDiskFace.Command[verify, write, write]]];    enumeratedTerminationConditions: ARRAY [0..2) OF FormSW.Enumerated ¬ [      [string: "goodCompletion"L, value: TerminationCondition[goodCompletion]], [      string: "failure"L, value: TerminationCondition[failure]]];    items[i ¬ i + 1] ¬ FormSW.EnumeratedItem[      tag: "I/O Command"L, feedback: all, copyChoices: TRUE,      value: @diskDrive.currentCommand,      choices: DESCRIPTOR[enumeratedCommandTypes], place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Repeat count"L, signed: FALSE, notNegative: TRUE, radix: decimal,      default: 1, value: @diskDrive.repeatCount, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.EnumeratedItem[      tag: "Termination condition"L, feedback: all, copyChoices: TRUE,      value: @diskDrive.terminationCondition,      choices: DESCRIPTOR[enumeratedTerminationConditions],      place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.CommandItem[      tag: "Do it"L, proc: DoDiskIOCommand, place: FormSW.nextPlace];    END;    IF i ~= nItems - 1 THEN ERROR;  -- indicates that items is incompletely initialized        diskDrive.drive ¬ DriveFromIndex[diskDrive.driveIndex];    diskDrive.channel ¬      IF diskDrive.drive = DiskChannel.nullDrive THEN DiskChannel.nullHandle      ELSE DiskChannel.Create[diskDrive.drive];        RETURN[items, TRUE]    END;  NoticeNewDiskDriveIndex: FormSW.EnumeratedNotifyProcType =    BEGIN    IF oldValue = diskDrive.driveIndex THEN RETURN;    diskDrive.drive ¬ DriveFromIndex[diskDrive.driveIndex];    diskDrive.channel ¬      IF diskDrive.drive = DiskChannel.nullDrive THEN DiskChannel.nullHandle      ELSE DiskChannel.Create[diskDrive.drive];    END;    PageNumberCommand: FormSW.ProcType =    BEGIN    IF ~ValidateDrive[] THEN RETURN;    FillDiskAddress[];    diskDrive.pageNumberIO ¬ DiskChannel.GetPageNumber[      diskDrive.drive, diskDrive.address];    diskDrive.pageNumberBase ¬ diskDrive.pageNumberIO;    diskDrive.pageNumberOffset ¬ 0;    FormSW.DisplayItem[sw, paramPageNumberBaseIndex];    FormSW.DisplayItem[sw, paramPageNumberOffsetIndex];    FormSW.DisplayItem[sw, paramPageNumberIOIndex];    END;  DriveFromIndex: PROCEDURE [index: CARDINAL]    RETURNS [DiskChannel.Drive] =    BEGIN    drive: DiskChannel.Drive;    found: BOOLEAN ¬ FALSE;    FOR drive ¬ DiskChannel.GetNextDrive[DiskChannel.nullDrive],        DiskChannel.GetNextDrive[drive] UNTIL drive = DiskChannel.nullDrive  DO      IF index = DiskChannel.GetDriveAttributes[drive].deviceOrdinal THEN        {found ¬ TRUE; EXIT;};      ENDLOOP;    IF found THEN RETURN[drive]    ELSE RETURN[DiskChannel.nullDrive];    END;  UseDiskAddressCommand: FormSW.ProcType =    BEGIN    IF ~ValidateDrive[] THEN RETURN;    diskDrive.usePageNumber ¬ FALSE;    IF DiskChannel.GetPageNumber[diskDrive.drive, diskDrive.address] IN      [0..DiskChannel.GetDriveAttributes[diskDrive.drive].nPages) THEN      diskDrive.diskAddressValid ¬ TRUE    ELSE diskDrive.diskAddressValid ¬ FALSE;    FormSW.DisplayItem[sw, paramUseDiskAddressIndex];    FormSW.DisplayItem[sw, paramUsePageNumberIndex];    END;  UsePageNumberCommand: FormSW.ProcType =    BEGIN    IF ~ValidateDrive[] THEN RETURN;    diskDrive.useDiskAddress ¬ FALSE;    FormSW.DisplayItem[sw, paramUseDiskAddressIndex];    IF GetDiskAddress[] IN      [0..DiskChannel.GetDriveAttributes[diskDrive.drive].nPages) THEN      diskDrive.pageNumberValid ¬ TRUE    ELSE diskDrive.pageNumberValid ¬ FALSE;    FormSW.DisplayItem[sw, paramUseDiskAddressIndex];    FormSW.DisplayItem[sw, paramUsePageNumberIndex];    END;  ValidateDiskHead: PROCEDURE[] RETURNS [BOOLEAN] =    BEGIN RETURN[diskDrive.head IN [0..LAST[HeadAndSectorType]]]; END;  ValidateDiskPageNumber: PROCEDURE[] RETURNS [BOOLEAN] =    BEGIN    RETURN[      GetDiskAddress[] IN        [0..DiskChannel.GetDriveAttributes[diskDrive.drive].nPages)];    END;  ValidateDiskSector: PROCEDURE[] RETURNS [BOOLEAN] =    BEGIN RETURN[diskDrive.sector IN [0..LAST[HeadAndSectorType]]]; END;    ValidateDrive: PROCEDURE [] RETURNS [valid: BOOLEAN] =    BEGIN    valid ¬ (diskDrive.channel ~= DiskChannel.nullHandle);    IF ~valid THEN      BEGIN      MsgSW.Post[sw: DiskEditInternal.msgSW, string: "Invalid device specified"L];      UserTerminal.BlinkDisplay[];      RETURN;      END;    END;  END.LOG10-Sep-81  9:49:21   WDK       Converted to Tajo 8, Pilot 8.13-May-82 10:42:39   AWL         Drive enumeration should be on DeviceTypes.anyPilotDisk.  numDrives declared wrong.13-Oct-82 16:45:36   AWL         Support q2000 as the same device type as q2040.22-Apr-83 14:35:55   EKN      Update to Klamath 27-Jun-83 11:33:02   Yien   Bug fixed in procedure MakeParamSW 15-Jul-83 15:02:18   AWL         Add initialization code for diskDrive in MakeFormSw proc to acknowledge the initial drive.29-Nov-83 17:28:31	EKN      Changed items: diskDrive.driveIndex, diskDrive.pageNumber, diskDrive.cylinder, diskDrive.head, diskDrive.sector, diskDrive.repeatCountto display decimals instead of octals.10-Jan-84 17:33:21   KEK        DriveFromIndex always chose drive 0.12-Apr-84 17:37:40   AWL          Two part page numbers.21-Aug-84 15:09:48   CAJ     Convert to WindowSwap.22-Apr-85 16:34:35   CAJ     Make DoDiskIOCommand resilient to being called while window registering not quite complete.
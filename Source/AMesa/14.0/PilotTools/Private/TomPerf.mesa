-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- TomPerf.mesa (last edited by CJS     25-Sep-84 14:41:29)DIRECTORY  AddressTranslation USING [Error, StringToNetworkAddress],  Courier USING [Error, ErrorCode, VersionMismatch],  String USING [CopyToNewString, Empty, Equal, FreeString],  System USING [NetworkAddress],  TomOps,   Put USING [LongString],  Window USING [Handle];   TomPerf:  MONITOR -- protecting instance specific data  LOCKS ctx USING ctx: TomOps.CtxHandle  IMPORTS AddressTranslation, Courier, String, TomOps, Put  EXPORTS TomOps   SHARES TomOps =  BEGIN OPEN TomOps;        -- Tom end of most of the Perf routines  GetInterfaceNamesAndCatchErrors:    PUBLIC INTERNAL PROCEDURE[ctx:CtxHandle]     RETURNS [names:Names, freeNamesProc:FreeNamesProcType] =    BEGIN    r:PerfErrReason;    BEGIN    UpdatePlaceHandle[ctx];    [names, freeNamesProc] ¬ GetInterfaceNames[ctx.placeHandle !      PerfErr                 => {r ¬ reason; GOTO perfErr};      Courier.Error           => {CourierError[ctx, errorCode]; GOTO remoteError};      Courier.VersionMismatch => {CourierVersionMismatch[ctx];  GOTO remoteError}]    EXITS      perfErr     => [names, freeNamesProc] ¬ GetPerfErrMsgNames[r];      remoteError => [names, freeNamesProc] ¬ GetErrMsgNames["remote error!"];    END;    END;	    GetVariableNamesAndCatchErrors:     PUBLIC INTERNAL PROCEDURE[ctx:CtxHandle]     RETURNS [names:Names, freeNamesProc:FreeNamesProcType] =    BEGIN    r:PerfErrReason;    BEGIN    firstTime:BOOLEAN ¬ TRUE;    UpdatePlaceHandle[ctx];    [names, freeNamesProc] ¬ GetVariableNames[ctx.placeHandle, ctx.interfaceName !        PerfErr =>          {IF firstTime AND reason=interfaceNotFound AND ctx.placeHandle.type=local	  THEN {firstTime ¬ FALSE; 	        IF TryToLoad[ctx.interfaceName, interface, ctx.msgSW] THEN RETRY};	  r ¬ reason;		  GOTO perfErr};        Courier.Error           => {CourierError[ctx, errorCode]; GOTO remoteError};        Courier.VersionMismatch => {CourierVersionMismatch[ctx];  GOTO remoteError}];    EXITS      perfErr     => [names, freeNamesProc] ¬ GetPerfErrMsgNames[r];      remoteError => [names, freeNamesProc] ¬ GetErrMsgNames["remote error!"];    END;    END;       	       InitializeUpdateInterfacesAndCatchErrors:     PUBLIC INTERNAL PROCEDURE[ctx:CtxHandle, items:Items] RETURNS [ok:BOOLEAN ¬ TRUE] =    BEGIN    prevName:LONG STRING ¬ NIL;    ctx.updateHandle ¬ InitializeUpdateInterfaces[ctx.placeHandle, items      ! PerfErr =>           -- error can be invoked for potentially every item, so simple boolean	  -- flag firstTime cannot be used - cf GetVariableNamesAndCatchErrors         {IF reason=interfaceNotFound AND ctx.placeHandle.type=local	     AND NOT String.Equal[interfaceName, prevName]	  THEN {prevName ¬ interfaceName; 	  	  -- the string body will be in items, so extent ok; no need to copy	        IF TryToLoad[interfaceName, interface, ctx.msgSW] THEN RETRY};	  WritePerfErr[ctx, reason, interfaceName, variableName];	  GOTO quit};	Courier.Error           => {CourierError[ctx, errorCode]; GOTO quit};        Courier.VersionMismatch => {CourierVersionMismatch[ctx];  GOTO quit}];    ctx.updateCH ¬ ctx.placeHandle.cH;    EXITS      quit => ok ¬ FALSE    END;      UpdateInterfacesAndCatchErrors:     PUBLIC INTERNAL PROCEDURE[ctx:CtxHandle] RETURNS [ok:BOOLEAN ¬ TRUE] =    BEGIN        Write: PROCEDURE [s:LONG STRING] = {Put.LongString[ctx.msgSW, s]};    UpdateInterfaces[ctx.updateHandle      ! PerfErr =>         {WritePerfErr[ctx, reason, interfaceName, variableName]; ok¬FALSE; CONTINUE};	Courier.Error           => {CourierError[ctx, errorCode]; ok¬FALSE; CONTINUE};        Courier.VersionMismatch => {CourierVersionMismatch[ctx];  ok¬FALSE; CONTINUE}];    END;          TerminateUpdateInterfacesAndCatchErrors:     PUBLIC INTERNAL PROCEDURE[ctx:CtxHandle, mode:TerminateMode ¬ normal] =    BEGIN    IF ctx.updateHandle#NIL     THEN       BEGIN      ok:BOOLEAN ¬ TRUE;      TerminateUpdateInterfaces[ctx.updateHandle, mode       !PerfErr =>          {WritePerfErr[ctx, reason, interfaceName, variableName]; ok¬FALSE; CONTINUE};        Courier.Error           => {CourierError[ctx, errorCode]; ok¬FALSE; CONTINUE};        Courier.VersionMismatch => {CourierVersionMismatch[ctx];  ok¬FALSE; CONTINUE}];      IF ~ok AND mode=normal       THEN TerminateUpdateInterfaces[ctx.updateHandle, abandon];      ctx.updateHandle ¬ NIL      END;    IF ctx.updateCH#NIL    THEN {IF ctx.placeHandle.cH#ctx.updateCH  -- do not kill it if it still being used!          THEN DeleteCourierHandle[ctx.updateCH];	  ctx.updateCH ¬ NIL};    END;                 -- miscellaneous ...        UpdatePlaceHandle: PUBLIC INTERNAL PROCEDURE[ctx:CtxHandle] =    BEGIN    Write:PROCEDURE[s:LONG STRING] = {Put.LongString[ctx.msgSW, s]};        IF String.Equal[ctx.placeHandle.name, ctx.remoteName] THEN RETURN;        String.FreeString[s:ctx.placeHandle.name, z:z];    ctx.placeHandle.name ¬ String.CopyToNewString[s:ctx.remoteName, z:z];        IF ctx.placeHandle.type=remote     THEN {IF ctx.placeHandle.cH#ctx.updateCH  -- do not kill it if it still being used!          THEN DeleteCourierHandle[ctx.placeHandle.cH];	  ctx.placeHandle.cH ¬ NIL};        IF String.Empty[ctx.remoteName]    THEN ctx.placeHandle.type ¬ local    ELSE      BEGIN      addr:System.NetworkAddress;      [addr:addr] ¬ AddressTranslation.StringToNetworkAddress[ctx.remoteName !        AddressTranslation.Error => 	     	{Write["problem in address translation"]; GOTO bad}];      ctx.placeHandle.cH ¬ CreateCourierHandle[addr];      ctx.placeHandle.type ¬ remote      EXITS        bad => ctx.placeHandle.type ¬ bad      END;		     SELECT ctx.placeHandle.type       FROM      local  => Write["local"];      bad    => Write["bad"];      remote => Write["remote"];      ENDCASE;    Write["\n"];          END;	 	      -- routines to produce error messages in menu items ...    GetPerfErrMsgNames:     PROCEDURE [reason:PerfErrReason]     RETURNS [names:Names, freeNamesProc:FreeNamesProcType] =    BEGIN    SELECT reason       FROM      badRemoteName     => RETURN GetErrMsgNames["bad remote name!"];      noInterfaces	=> RETURN GetErrMsgNames["no interfaces!"];      noInterfaceGiven  => RETURN GetErrMsgNames["no interface given!"];      interfaceNotFound => RETURN GetErrMsgNames["interface not found!"];      variableNotFound  => RETURN GetErrMsgNames["variable not found!"];       badInterface      => RETURN GetErrMsgNames["bad interface!"];      alreadyBeingMonitored => RETURN GetErrMsgNames["already being monitored!"];      invalidCall	=> RETURN GetErrMsgNames["invalid call!"];      ENDCASE           => RETURN GetErrMsgNames["unknown error!"];    END;       GetErrMsgNames:PROCEDURE [s:LONG STRING]     RETURNS [names:Names, freeNamesProc:FreeNamesProcType] =    BEGIN    seq:SeqOfStringsP ¬ z.NEW[SeqOfStrings[1]];      seq[0] ¬ String.CopyToNewString[z:z, s:s];    RETURN [ArrayFromSequence[seq, 1], FreeNames]    END;      -- routines to write error messages to message sub-window  WritePerfErr: PROCEDURE [ctx:CtxHandle, reason:PerfErrReason,       		    interfaceName, variableName:LONG STRING ¬ NIL] =    BEGIN    Write: PROCEDURE[s:LONG STRING] = {IF s#NIL THEN Put.LongString[ctx.msgSW, s]};    SELECT reason       FROM      badRemoteName     => Write["bad remote name"];      noInterfaceGiven  => Write["no interface given"];      interfaceNotFound => {Write["interface not found:"]; Write[interfaceName]};      variableNotFound  =>        {Write["variable not found:"]; 	 Write[interfaceName]; Write["."]; Write[variableName]};      badInterface      => Write["bad interface"];      alreadyBeingMonitored => Write["remote site already being monitored"];      invalidCall	=> Write["invalid call to remote site"];      ENDCASE           => Write["unknown error"];    Write["\n"];    END;    	      CourierError: PROCEDURE [ctx:CtxHandle, errorCode:Courier.ErrorCode] =      BEGIN    Write: PROCEDURE[s:LONG STRING] = {IF s#NIL THEN Put.LongString[ctx.msgSW, s]};     Write["Courier error: "];    SELECT errorCode      FROM       transportTimeout 		       => Write["low level timeout\n"];      noCourierAtRemoteSite	       => Write["no Courier at remote site"];      remoteSystemElementNotResponding => Write["remote site not responding\n"];      tooManyConnections 	       => Write["too many connections\n"];      noSuchProcedureNumber => Write["no such procedure number\n"];      returnTimedOut => Write["return timed out\n"];      callerAborted => Write["caller aborted"];      unknownErrorInRemoteProcedure => Write["unknown error in remote procedure\n"];      parameterInconsistency => Write["parameter inconsistency\n"];      invalidArguments => Write["invalid arguments\n"];      noSuchProgramNumber => Write["no such program number\n"];      protocolMismatch => Write["protocol mismatch\n"];      noSuchProgramExport => Write["no such program export\n"];      invalidHandle => Write["invalid  Courier handle\n"];      ENDCASE =>  {Write["unusual Courier error"];       			--ERROR Courier.Error[errorCode]--  };    END;      CourierVersionMismatch: PROCEDURE [ctx:CtxHandle] =      {Put.LongString[ctx.msgSW, "version mismatch at remote machine\n"]};    END....        -- LOG25-Sep-84 14:42:55  CJS      AddressTranslation only exports Error, rather than four error conditions.
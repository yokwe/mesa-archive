-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Script13.mesa   22-Aug-83 13:35:27 by AWL      -- Virtual memory test program, Klamath Pilot.-- Script13 is a stripped down Script14 to find a MakeReadOnly/CopyIn problem.DIRECTORY  Environment USING [PageNumber],  ScriptGeneric USING [CopyBugTest, RestoreProc],  ScriptOps USING [RegisterScript],  Space USING [SwapUnitSize],  VM USING [Interval, ReturnWait],  VMTestOperations-- USING [all the operations]--,  VMTestScript USING [GetHeap, GetTestVMSize, GiveBackHeap, MakeBackingData,    MakeIrregularSwapData, MakeUniformSwapData, MakeUnitarySwapData];Script13: PROGRAM  IMPORTS ScriptGeneric, ScriptOps, VMTestOperations, VMTestScript =  BEGIN  ------------  -- PUBLIC procedures:  -- RunTests is a registered script procedure which may be called by the  -- VMTest driver.  The tests in the script may use procedures from  -- VMTestOperations (for VM operations) and VMTestScript (for test utilities).  RunTests: PROCEDURE =    BEGIN    heap: UNCOUNTED ZONE ¬ VMTestScript.GetHeap[];    -- Insert tests or test subprocedures here    TestA[heap];        heap ¬ VMTestScript.GiveBackHeap[heap];    END;  ------------  -- PRIVATE procedures:  -- Initial (and restored) state:  --  readWrite, swappable, backed, alive, clean, out  TestA: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    -- Restore testVM to initial state:    --  readWrite, swappable, (backed,) alive, clean, out    Restore: ScriptGeneric.RestoreProc =      BEGIN      MakeSwappable[[0, vmSize]];      MakeWritable[[0, vmSize]];      Touch[[0, vmSize], write];      Deactivate[[0, vmSize], wait];      END;    halfMapUnit: CARDINAL;    mapUnitSize: CARDINAL;    maxMapUnitSize: CARDINAL;    page: Environment.PageNumber;    pBacking: LONG POINTER;    pSwap: LONG POINTER;    vmSize: CARDINAL;    vmSize ¬ CARDINAL[GetTestVMSize[]];  -- known to be short    maxMapUnitSize ¬ MAX[vmSize/4, 1];    -- BackingStore for all map units through all map unit sizes consists of    -- 3 runs, 2 each about half the map unit with a single page in between.    -- The existence of a run boundary in the map unit and its location relative    -- to swap units will vary as the map unit size increases.  For all but the    -- last round, the backing store extends past the end of the map unit.    halfMapUnit ¬ MAX[maxMapUnitSize/2, 1];    pBacking ¬ heap.NEW[ARRAY[0..3) OF WORD ¬      [halfMapUnit, 1, maxMapUnitSize - halfMapUnit]];    pSwap  ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [1]];    FOR mapUnitSize IN [1..maxMapUnitSize] DO      -- Map uniform, irregular, unitary, uniform, irregular, ...      -- Doing Maps non-sequentially      FOR page ¬ 0, page + mapUnitSize * 3 UNTIL page > vmSize - mapUnitSize DO        Map[id: "uniform"L,          interval: [page, mapUnitSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pBacking, 3]],          access: readWrite,          swapUnits: MakeUniformSwapData[3],          life: alive,          swappability: swappable];        ENDLOOP;  -- end map loop      FOR page ¬ mapUnitSize, page + mapUnitSize * 3          UNTIL page > vmSize - mapUnitSize DO        Map[id: "irregular"L,          interval: [page, mapUnitSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pBacking, 3]],          access: readWrite,          swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwap, 1]],          life: alive,          swappability: swappable];        ENDLOOP;  -- end map loop      FOR page ¬ mapUnitSize * 2, page + mapUnitSize * 3          UNTIL page > vmSize - mapUnitSize DO        Map[id: "unitary"L,          interval: [page, mapUnitSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pBacking, 3]],          access: readWrite,          swapUnits: MakeUnitarySwapData[],          life: alive,          swappability: swappable];        ENDLOOP;  -- end map loop      ScriptGeneric.CopyBugTest[CopyIn, CopyOut, Restore, vmSize];      -- unmap      FOR page ¬ 0, page + mapUnitSize UNTIL page > vmSize - mapUnitSize DO        Unmap [page] ENDLOOP;  -- end unmap loop      ENDLOOP;  -- end mapUnitSize loop    heap.FREE[@pBacking];    heap.FREE[@pSwap];    END;  ------------  -- PUBLIC SIGNALs and ERRORs: none  ------------  -- Initialization:  -- Register the given script proc and identifying name with the script  -- handling facility at start time.  Module must be explicitly started.  ScriptOps.RegisterScript[script: RunTests, name: "copy bug tests"L];  END.LOG17-Mar-83 13:59:05   CAJ    Created file.22-Aug-83 13:35:23   AWL         ScriptGeneric.CopyProc was never used.
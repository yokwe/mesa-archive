-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- RandomTestUtilities.mesa     3-Mar-83 10:36:42 by LXD      -- Utilities for the Random System Test Package (RandomTestControl, etc.).-- Note:  No entry procedure in this module may call SaveState, because SaveState requires that all processes be idle, but some process could be waiting on our monitor lock.DIRECTORY  Ascii USING [CR, DEL, ESC, NUL, TAB],  -- Environment USING [Long],  File USING [Delete, File, GetSize, nullFile, Unknown],  Heap USING [systemZone],  Runtime USING [CallDebugger],  Stream USING [EndOfStream, GetChar, Handle, SetInputOptions],  String USING [AppendChar, AppendString, EquivalentStrings, StringToNumber],  -- System USING [GetGreenwichMeanTime, SecondsSinceEpoch],  TestFrameworkDefs USING [    Base, CreateFileWithinTransaction, ModelTransHandle, nil, Node,    nullModelTransHandle, ParameterVal, RealTransaction, Register, RelPtr,    SaveState, StartStop, Transactionid, Verbosity, VWF1],  CWF USING [WF0, WF1, WF2, WF3, WF4, WFC, WFCR, WFN];RandomTestUtilities: MONITOR  IMPORTS File, Heap, Runtime, Stream, String, --System,-- TestFrameworkDefs, CWF  EXPORTS TestFrameworkDefs =  BEGIN  -- - - - - - - - - - Constants, Parameters: - - - - - - - - -  initialMaxNumberOfTrans: CARDINAL ¬ 20;  -- used at cold start only.  z: UNCOUNTED ZONE = Heap.systemZone;  nullTransactionid: Transactionid = [    File.nullFile, TestFrameworkDefs.nullModelTransHandle, 0, ALL[0]];  placeHolderTransactionid: Transactionid =  -- (used in the process of checking one out.)    [File.nullFile, TestFrameworkDefs.nullModelTransHandle, 1, ALL[1]];  tickVerbosity: TestFrameworkDefs.Verbosity = 3;  -- - - - - - - - - - Types: - - - - - - - - -  Base: TYPE = TestFrameworkDefs.Base;  Capability: TYPE = File.File;  ModelTransHandle: TYPE = TestFrameworkDefs.ModelTransHandle;  RealTransaction: TYPE = TestFrameworkDefs.RealTransaction;  RelPtr: TYPE = TestFrameworkDefs.RelPtr;    Transactionid: PUBLIC TYPE = RECORD [    cap: Capability,    mTrans: ModelTransHandle,    index: CARDINAL,    fill: ARRAY      [0..SIZE[TestFrameworkDefs.Transactionid] - SIZE[Capability] - SIZE[            ModelTransHandle] - SIZE[CARDINAL]) OF UNSPECIFIED];  UtilitiesData: TYPE = RECORD [    currentVerbosity: TestFrameworkDefs.Verbosity,    random: CARDINAL,    tick: CARDINAL,    tickTarget: CARDINAL,    maxNumberOfTrans: CARDINAL,    trans: SEQUENCE COMPUTED CARDINAL OF Transactionid];      UtilitiesDataPtr: TYPE = Base RELATIVE POINTER TO UtilitiesData;  -- - - - - - - - - - Global Variables: - - - - - - - - -  base: Base;  -- base pointer to stable storage.  data: UtilitiesDataPtr ¬ TestFrameworkDefs.nil;  -- Note:  most global variables are placed at the beginning of the relevant code.  -- - - - - - - - - - Module start/stop: - - - - - - - - -  RegisterParametersUtility: PROCEDURE =    BEGIN    RegisterParameter[      "currentVerbosity"L, [cv[@LOOPHOLE[currentVerbosity, CARDINAL]]]];    RegisterParameter["randomSeed"L, [cv[@randomSeed]]];    RegisterParameter["tickTarget"L, [cv[@tickTarget]]];    END;  ColdStart: PROCEDURE [zoneBase: Base]    RETURNS [registerThisNode: UtilitiesDataPtr] =    BEGIN    base ¬ zoneBase;    currentVerbosity ¬ MIN[LAST[TestFrameworkDefs.Verbosity], currentVerbosity];    InitRandom[randomSeed];    registerThisNode ¬ data ¬ TestFrameworkDefs.Node[      SIZE[UtilitiesData [initialMaxNumberOfTrans]]];    SaveMyState[];    base[data].maxNumberOfTrans ¬ initialMaxNumberOfTrans;    FOR i: CARDINAL IN [0..base[data].maxNumberOfTrans) DO      base[data].trans[i] ¬ nullTransactionid; ENDLOOP;    END;  Restart: PROCEDURE [zoneBase: Base, registeredNode: UtilitiesDataPtr] =    BEGIN    base ¬ zoneBase;    data ¬ registeredNode;    currentVerbosity ¬ base[data].currentVerbosity;    tick ¬ base[data].tick;    tickTarget ¬ base[data].tickTarget;    InitRandom[base[data].random];    END;  SaveMyState: PROCEDURE[] =    BEGIN    base[data].currentVerbosity ¬ currentVerbosity;    base[data].tick ¬ tick;    base[data].tickTarget ¬ tickTarget;    base[data].random ¬ randomTable[randomTrailer];    END;  -- - - - - - - - - - Count operations: - - - - - - - - -  tick: CARDINAL ¬ 0;  nullTickTarget: CARDINAL ¬ LAST[CARDINAL];  tickTarget: CARDINAL ¬ nullTickTarget;  TickStop: SIGNAL = CODE;  ticksSinceLastRestore: CARDINAL ¬ 0;  Tick: PUBLIC ENTRY PROCEDURE [] =    BEGIN    tick ¬ tick + 1;    IF (tick MOD 10 = 0) THEN      TestFrameworkDefs.VWF1[tickVerbosity, "*Ntick becomes: %UD  "L, @tick]    ELSE {      tickModTen: CARDINAL ¬ tick MOD 10;      TestFrameworkDefs.VWF1[tickVerbosity, " %U"L, @tickModTen] };    IF tick = tickTarget AND tickTarget ~= nullTickTarget THEN      Runtime.CallDebugger["Tick target reached"L];    ticksSinceLastRestore ¬ ticksSinceLastRestore + 1;    END;  CurrentTick: PUBLIC ENTRY PROCEDURE[] RETURNS [currentTick: CARDINAL] = {    currentTick ¬ tick};  -- - - - - - - - - - Reproducible hash: - - - - - - - - -  ExpandString: PUBLIC PROCEDURE [seed: CARDINAL, s: LONG STRING] =    BEGIN    chars: STRING ¬      "abcdefghijkLmnopqrstuvwxyzaeiouLNRSTaeiouLNRST0123456789./.-$-%-"L;    FillOut: PROCEDURE [nextRandom: PROCEDURE RETURNS [CARDINAL]] =      BEGIN      THROUGH [1..nextRandom[] MOD s.maxlength + 1] DO        String.AppendChar[s, chars[nextRandom[] MOD 64]]; ENDLOOP;      END;    s.length ¬ 0;    PrivateGenerator[seed, FillOut];    END;  DisplayString: PUBLIC PROCEDURE [seed: CARDINAL, maxlength: CARDINAL] =    BEGIN  -- Callable from debugger    s: LONG STRING ¬ z.NEW[StringBody [maxlength]];    ExpandString[seed, s];    CWF.WF1["*n%s*n"L, s];    z.FREE[@s];    END;  PrivateGenerator: PUBLIC PROCEDURE [    seed: CARDINAL,    wantsRandoms: PROCEDURE [nextRandom: PROCEDURE RETURNS [CARDINAL]]] =    BEGIN    -- from random number stuff (February 13, 1978)     Degree: CARDINAL = 33;    MidPower: CARDINAL = 13;    randomTable: ARRAY [0..Degree) OF CARDINAL;    randomIndex: CARDINAL ¬ 0;    randomTrailer: CARDINAL ¬ Degree - MidPower;    InitPrivateRandom: PROCEDURE [seed: CARDINAL] =      BEGIN      i: CARDINAL;      xseed: CARDINAL;      FOR i IN [0..Degree) DO randomTable[i] ¬ 0 ENDLOOP;      randomTable[0] ¬ 2*seed + 1;      xseed ¬ seed;      FOR i IN [1..MIN[16, Degree - 1]] DO        randomTable[i] ¬ IF LOOPHOLE[xseed, INTEGER] < 0 THEN 1 ELSE 0;        xseed ¬ 2*xseed;        ENDLOOP;      randomIndex ¬ 0;      randomTrailer ¬ Degree - MidPower;      THROUGH [1..55] DO [] ¬ PrivateRandom[] ENDLOOP;      -- note: this repeat count has been reduced for the purpose of this test code, original value was 2000.      RETURN;      END;    PrivateRandom: PROCEDURE RETURNS [CARDINAL] =      BEGIN      Result: CARDINAL = randomTable[randomIndex] + randomTable[randomTrailer];      randomTable[randomIndex] ¬ Result;      SELECT randomIndex + 1 FROM        < Degree =>          BEGIN          randomIndex ¬ randomIndex + 1;          randomTrailer ¬            IF randomTrailer < Degree - 1 THEN randomTrailer + 1 ELSE 0;          END;        = Degree => BEGIN randomIndex ¬ 0; randomTrailer ¬ Degree - MidPower; END;        ENDCASE => ERROR;  -- should never be greater than Degree      RETURN[Result];      END;    --START HERE.    InitPrivateRandom[seed];    wantsRandoms[PrivateRandom];    END;  -- - - - - - - - - - Random Numbers: - - - - - - - - -  randomSeed: CARDINAL ¬    -- LOOPHOLE[System.SecondsSinceEpoch[  ++ Use this one for a different test each run.    --   System.GetGreenwichMeanTime[]], Environment.Long].lowbits;    12345;  -- Use this one for the same test each run:      Degree: CARDINAL = 33;  MidPower: CARDINAL = 13;  randomTable: ARRAY [0..Degree) OF CARDINAL ¬ [    56572B, 112312B, 4714B, 100763B, 62510B, 1572B, 12255B, 132113B, 166574B,    2440B, 104704B, 105254B, 106030B, 7053B, 56322B, 41163B, 11105B, 136203B,    55327B, 125100B, 76206B, 167173B, 173672B, 33211B, 134253B, 153317B, 25327B,    136567B, 171517B, 23161B, 44276B, 72324B, 143455B];  -- these initial values were obtained by calling InitRandom[123].  randomIndex: CARDINAL ¬ 0;  randomTrailer: CARDINAL ¬ Degree - MidPower;  -- from random number stuff (February 13, 1978)   InitRandom: --ENTRY-- PROCEDURE [seed: CARDINAL] =    BEGIN    i: CARDINAL;    xseed: CARDINAL;    FOR i IN [0..Degree) DO randomTable[i] ¬ 0 ENDLOOP;    randomTable[0] ¬ 2*seed + 1;    xseed ¬ seed;    FOR i IN [1..MIN[16, Degree - 1]] DO      randomTable[i] ¬ IF LOOPHOLE[xseed, INTEGER] < 0 THEN 1 ELSE 0;      xseed ¬ 2*xseed;      ENDLOOP;    randomIndex ¬ 0;    randomTrailer ¬ Degree - MidPower;    THROUGH [1..2000] DO [] ¬ Random[] ENDLOOP;    RETURN;    END;  Random: PUBLIC ENTRY PROCEDURE[] RETURNS [CARDINAL] =    BEGIN    Result: CARDINAL = randomTable[randomIndex] + randomTable[randomTrailer];    randomTable[randomIndex] ¬ Result;    SELECT randomIndex + 1 FROM      < Degree =>        BEGIN        randomIndex ¬ randomIndex + 1;        randomTrailer ¬          IF randomTrailer < Degree - 1 THEN randomTrailer + 1 ELSE 0;        END;      = Degree => BEGIN randomIndex ¬ 0; randomTrailer ¬ Degree - MidPower; END;      ENDCASE => ERROR;  -- should never be greater than Degree    RETURN[Result];    END;  RandomCase: PUBLIC PROCEDURE [d: LONG DESCRIPTOR FOR ARRAY OF CARDINAL]    RETURNS [CARDINAL] =    BEGIN    x: CARDINAL ¬ 0;    FOR i: CARDINAL IN [0..LENGTH[d]) DO x ¬ x + d[i]; ENDLOOP;    x ¬ Random[] MOD x;    FOR i: CARDINAL IN [0..LENGTH[d]) DO      IF x < d[i] THEN RETURN[i] ELSE x ¬ x - d[i]; ENDLOOP;    ERROR;    END;  -- - - - - - - - - - Parameter initialization: - - - - - - - - -  ParameterItem: TYPE = RECORD [    next: LONG POINTER TO ParameterItem,    k: LONG STRING,  -- key    val: ParameterVal];  ParameterVal: TYPE = TestFrameworkDefs.ParameterVal;  parameterChain: LONG POINTER TO ParameterItem ¬ NIL;  parameterRegistrationOpen: BOOLEAN ¬ TRUE;  RegisterParameter: PUBLIC ENTRY PROCEDURE [key: LONG STRING, val: ParameterVal] =    BEGIN    r: LONG POINTER TO ParameterItem;    rcd: LONG POINTER TO ParameterItem ¬ z.NEW[      ParameterItem ¬ [      next: parameterChain, k: z.NEW[StringBody [key.length]], val: val]];    IF NOT parameterRegistrationOpen THEN ERROR;    FOR r ¬ parameterChain, r.next WHILE r # NIL DO      IF String.EquivalentStrings[r.k, key] THEN ERROR; ENDLOOP;    String.AppendString[from: key, to: rcd.k];    parameterChain ¬ rcd;    END;  CloseParameterItemRegistration: PUBLIC ENTRY PROCEDURE[] =    BEGIN    IF NOT parameterRegistrationOpen THEN ERROR;    parameterRegistrationOpen ¬ FALSE;    END;  DisplayParameterValues: PUBLIC ENTRY PROCEDURE[] =    BEGIN    r: LONG POINTER TO ParameterItem;    CWF.WFCR;    FOR r ¬ parameterChain, r.next WHILE r # NIL DO      WITH p: r.val SELECT FROM        str => CWF.WF2["%s = %s*N"L, r.k, p.str];        cv => CWF.WF2["%s = %d*N"L, r.k, p.cv];        bv => CWF.WF2["%s = %s*N"L, r.k, IF p.bv­ THEN "TRUE"L ELSE "FALSE"L];        ENDCASE => ERROR;      ENDLOOP;    END;  DeallocateParameterState: PUBLIC ENTRY PROCEDURE[] =    BEGIN    r: LONG POINTER TO ParameterItem;    UNTIL parameterChain = NIL DO      r ¬ parameterChain;      parameterChain ¬ r.next;      z.FREE[@r.k];      z.FREE[@r];      ENDLOOP;    END;  UpdateParameter: PROCEDURE [val: LONG STRING, key: LONG STRING] =    BEGIN    r: LONG POINTER TO ParameterItem;    FOR r ¬ parameterChain, r.next WHILE r # NIL DO      IF String.EquivalentStrings[r.k, key] THEN EXIT;      REPEAT        FINISHED => {          Runtime.CallDebugger["No such parameter. Proceed to ignore."L];	  RETURN };      ENDLOOP;    WITH p: r.val SELECT FROM      str => {p.str.length ¬ 0; String.AppendString[from: val, to: p.str]};      cv => p.cv­ ¬ String.StringToNumber[s: val, radix: 10];      bv =>        p.bv­ ¬          SELECT val[0] FROM 't, 'T => TRUE, 'f, 'F => FALSE, ENDCASE => ERROR;      ENDCASE => ERROR;    CWF.WF2["*T%s ¬ %s;*N"L, key, val];    END;  ProcessParameterFile: PUBLIC ENTRY PROCEDURE [sH: Stream.Handle] =    BEGIN    argString: STRING ¬ [100];    keyString: STRING ¬ [100];    gotOne, noFurtherItems: BOOLEAN;    NextItem: PROCEDURE[ --argString, keyString-- ]      RETURNS [gotOne: BOOLEAN, noFurtherItems: BOOLEAN] =      BEGIN      char: CHARACTER ¬ ' ;      argString.length ¬ 0;      keyString.length ¬ 0;      BEGIN      ENABLE Stream.EndOfStream => GO TO NoMoreItems;      FOR char ¬ ' , Stream.GetChar[sH] WHILE Delim[char] DO ENDLOOP;  -- skip any initial delimiters.      END;      BEGIN      ENABLE Stream.EndOfStream => ERROR;  -- item has no value.      FOR char ¬ char, Stream.GetChar[sH] UNTIL Delim[char] DO  -- accumulate name..        String.AppendChar[keyString, char]; ENDLOOP;      FOR char ¬ ' , Stream.GetChar[sH] WHILE Delim[char] DO ENDLOOP;  -- skip separating delimiters.      END;      BEGIN      ENABLE Stream.EndOfStream => GO TO LastItem;  -- end of stream terminates value.      FOR char ¬ char, Stream.GetChar[sH] UNTIL Delim[char] DO        String.AppendChar[argString, char];  -- accumulate value.        ENDLOOP;      END;      RETURN[gotOne: TRUE, noFurtherItems: FALSE];      EXITS        LastItem => RETURN[gotOne: TRUE, noFurtherItems: TRUE];        NoMoreItems => RETURN[gotOne: FALSE, noFurtherItems: TRUE];      END;    Delim: PROCEDURE [c: CHARACTER] RETURNS [isDelimiter: BOOLEAN] = {      RETURN[        c = Ascii.CR OR c = Ascii.DEL OR c = Ascii.ESC OR c = Ascii.NUL OR c = '           OR c = Ascii.TAB OR c = '; OR c = '¬]};    Stream.SetInputOptions[      sH, [FALSE, FALSE, FALSE, FALSE, --signalEndOfStream:-- TRUE, FALSE]];    -- UNTIL no more items--    DO      [gotOne, noFurtherItems] ¬ NextItem[ --argString, keyString-- ];      IF gotOne THEN UpdateParameter[val: argString, key: keyString];      IF noFurtherItems THEN EXIT;      ENDLOOP;    END;  -- - - - - - - - - - Verbosity-controlled Printing: - - - - - - - - -  currentVerbosity: PUBLIC TestFrameworkDefs.Verbosity ¬ LAST[    TestFrameworkDefs.Verbosity];  -- (public so it can be set dynamically by operator)  VWF0: PUBLIC PROCEDURE [vrb: TestFrameworkDefs.Verbosity, str: LONG STRING] = {    IF vrb <= currentVerbosity THEN CWF.WF0[str]};  VWF1: PUBLIC PROCEDURE [    vrb: TestFrameworkDefs.Verbosity, str: LONG STRING, a: LONG POINTER] = {    IF vrb <= currentVerbosity THEN CWF.WF1[str, a]};  VWF2: PUBLIC PROCEDURE [    vrb: TestFrameworkDefs.Verbosity, str: LONG STRING, a, b: LONG POINTER] = {    IF vrb <= currentVerbosity THEN CWF.WF2[str, a, b]};  VWF3: PUBLIC PROCEDURE [    vrb: TestFrameworkDefs.Verbosity, str: LONG STRING, a, b, c: LONG POINTER] = {    IF vrb <= currentVerbosity THEN CWF.WF3[str, a, b, c]};  VWF4: PUBLIC PROCEDURE [    vrb: TestFrameworkDefs.Verbosity, str: LONG STRING, a, b, c, d: LONG POINTER] = {    IF vrb <= currentVerbosity THEN CWF.WF4[str, a, b, c, d]};  VWFC: PUBLIC PROCEDURE [vrb: TestFrameworkDefs.Verbosity, ch: CHARACTER] = {    IF vrb <= currentVerbosity THEN CWF.WFC[ch]};  VWFCR: PUBLIC PROCEDURE [vrb: TestFrameworkDefs.Verbosity] = {    IF vrb <= currentVerbosity THEN CWF.WFCR[]};  VWFN: PUBLIC PROCEDURE [    vrb: TestFrameworkDefs.Verbosity, str: LONG STRING,    desc: DESCRIPTOR FOR ARRAY OF LONG POINTER] = {    IF vrb <= currentVerbosity THEN CWF.WFN[str, desc]};  -- - - - - - - - - - Transaction Identifiers: - - - - - - - - -  ObtainTransactionIdentifier: PUBLIC PROCEDURE [    rTrans: RealTransaction, mTrans: ModelTransHandle]    RETURNS [transID: Transactionid] =    -- (not an entry procedure.)    BEGIN OPEN d: base[data];    slot: CARDINAL;    AllocateTransIDSlot: ENTRY PROCEDURE[] RETURNS [slot: CARDINAL] =      BEGIN      FOR slot IN [0..d.maxNumberOfTrans) DO        IF d[slot] = nullTransactionid THEN {          d[slot] ¬ placeHolderTransactionid; RETURN};        REPEAT FINISHED => ERROR;  -- no slots available for another transaction.        ENDLOOP;      END;    RememberFile: PROCEDURE [fileCreated: File.File] = {      transID ¬ d[slot] ¬ [fileCreated, mTrans, slot, ALL[0]];      TestFrameworkDefs.SaveState[]};    transID ¬ nullTransactionid;  -- keeps compiler uninitialized checker happy.    slot ¬ AllocateTransIDSlot[];    -- (We can't call CreateFileWithinTransaction while holding our monitor lock,    --   because it does a SaveState, which requires that all processes be idle,    --   but some process could be waiting on our monitor lock.)    TestFrameworkDefs.CreateFileWithinTransaction[      rTrans, --andDo:-- RememberFile --[slot]-- ];    END;  ReleaseTransactionIdentifier: PUBLIC PROCEDURE [transID: Transactionid] =    -- (not an entry procedure.)    BEGIN OPEN d: base[data];    ReleaseTransIDSlot: ENTRY PROCEDURE [slot: CARDINAL] = {      d[transID.index] ¬ nullTransactionid};    file: File.File = transID.cap;    IF d[transID.index] # transID THEN ERROR;    d[transID.index] ¬ placeHolderTransactionid;  -- (will be released if we crash)    TestFrameworkDefs.SaveState[];    File.Delete[file ! File.Unknown => CONTINUE];  -- (file will have been deleted if transaction aborted.)    ReleaseTransIDSlot[transID.index];    END;  DidTransactionCommit: PUBLIC ENTRY PROCEDURE [transID: Transactionid]    RETURNS [committed: BOOLEAN] =    BEGIN OPEN d: base[data];    IF d[transID.index] # transID THEN ERROR;    committed ¬ TRUE;    [] ¬ File.GetSize[      transID.cap ! File.Unknown => {committed ¬ FALSE; CONTINUE}];    END;  EnumerateTrans: PUBLIC --ENTRY-- PROCEDURE [    eachTrans: PROCEDURE [mt: ModelTransHandle, id: Transactionid]] =    -- (can't be an entry proc since eachTrans may call DidTransactionCommit.)    BEGIN OPEN d: base[data];    IF base = NIL THEN ERROR;  -- EnumerateTrans called before coldstart/restart proc was called.    FOR i: CARDINAL IN [0..d.maxNumberOfTrans) DO      IF d[i] = placeHolderTransactionid THEN d[i] ¬ nullTransactionid;  -- (placeHolder      -- was in slot just before crash.)      IF d[i] # nullTransactionid THEN eachTrans[d[i].mTrans, d[i]];      ENDLOOP;    END;  -- - - - - - - - - - Module initialization: - - - - - - - - -  startStop: TestFrameworkDefs.StartStop ¬ [    moduleName: "TestUtilities", coldStart: ColdStart, restart: Restart,    saveState: SaveMyState];  TestFrameworkDefs.Register[@startStop];  END.LOGSeptember 29, 1980  1:47 PM   JXI      Created file.October 22, 1980  1:40 PM   WDK       Use String instead of StringDefs.  Catch File.Unknown in ReleaseTransID.  Use fixed upper limit for number of transactions.  Monitorized.  Added VWF stuff.February 9, 1981  5:37 PM   WDK       SEQUENCE should have been declared COMPUTED.February 9, 1981  6:08 PM   SXY      maxNumberOfTrans is declared separately.8-Sep-81 14:03:07   WDK       Converted from using WF to use CWF.  LONGified.17-Dec-81 14:28:26   CAJ    Fix arg list for Stream.SetInputOptions. 2-Mar-83 10:57:46  LXD        Conversion to Klamath.  File.Capability becomes File.File.
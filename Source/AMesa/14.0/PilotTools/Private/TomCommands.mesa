-- Copyright (C) 1983, 1985, 1986  by Xerox Corporation. All rights reserved. -- TomCommands.mesa (last edited by RSV      7-Nov-86 14:28:20)DIRECTORY  Ascii USING [CR, NUL],  CmFile USING [Close, Error, FindSection, Handle, NextValue, Open, TableError],  Cursor USING [Set],  Format USING [CR, Decimal, Line, LongString, StringProc],  FormSW USING [DisplayItem, ModifyEditable, ProcType],  MsgSW USING [Clear],  MStream USING [Error, WriteOnly],  TomOps,   Process USING [priorityBackground, priorityForeground, priorityNormal],  Put USING [Line],  Stream USING [Delete, Handle, PutString],  String USING [AppendExtensionIfNeeded, CopyToNewString, Empty, Equal],  StringLookUp USING [InTable, noMatch, TableDesc],  TextSW USING [DeleteText, GetEOF, InsertChar, InsertString, SetInsertion],  Token USING [AlphaNumeric, Filtered, FreeTokenString, GetCharProcType, Handle,     Item, Number, Object, Skip, SyntaxError, WhiteSpace],  Tool USING [Destroy],  UserInput USING [WaitForConfirmation],  Window USING [Handle];   TomCommands:  MONITOR   -- protecting instance specific data  LOCKS ctx USING ctx: TomOps.CtxHandle  IMPORTS CmFile, Cursor, Format, FormSW, MsgSW, MStream, TomOps, Tool, Process,    Put, Stream, String, StringLookUp, TextSW, Token, UserInput  EXPORTS TomOps   SHARES TomOps =  BEGIN OPEN TomOps;  	  	    MainFormCommandProc: PUBLIC FormSW.ProcType =    BEGIN    ctx:CtxHandle ¬ GetContext[sw];    MsgSW.Clear[ctx.msgSW];    SELECT index FROM    -- iAnother => Another[...]; -- -- done in TomGlobal --       iDestroy => Destroy[ctx];       iReset   => Reset[ctx];       iLoad    => Load[ctx];       iSave    => Save[ctx];       iAdd     => Add[ctx];       iApply   => Apply[ctx];      ENDCASE    END;          Add: ENTRY PROCEDURE[ctx:CtxHandle] =    BEGIN    Add1: PROCEDURE [variableName: LONG STRING] =      BEGIN      TextSW.SetInsertion[ctx.parmSW, TextSW.GetEOF[ctx.parmSW]];      TextSW.InsertString[ctx.parmSW, ctx.interfaceName];      TextSW.InsertChar[ctx.parmSW, '.];      TextSW.InsertString[ctx.parmSW, variableName];      TextSW.InsertChar[ctx.parmSW, Ascii.CR]      END;    IF String.Empty[ctx.interfaceName] THEN        {Put.Line[ctx.msgSW, "no interface name given"]; RETURN};        IF String.Empty[ctx.variableName] OR String.Equal[ctx.variableName, "<ALL>"]    THEN       BEGIN      names:Names; freeNamesProc:FreeNamesProcType;      [names, freeNamesProc] ¬ GetVariableNamesAndCatchErrors[ctx];      IF LENGTH[names]=1      THEN Put.Line[ctx.msgSW, names[0]]  -- it will be an error message!      ELSE FOR i:CARDINAL IN [1..LENGTH[names])            DO Add1[names[i]] ENDLOOP; -- omit "<ALL>"      freeNamesProc[names]      END    ELSE       Add1[ctx.variableName]  	      END;         Apply: ENTRY PROCEDURE [ctx:CtxHandle] =      BEGIN    o:Token.Object ¬ [getChar:GetChar, break:Ascii.NUL];    h:Token.Handle ¬ @o;    s:LONG STRING ¬ ctx.parmString;    p:CARDINAL ¬ 0; ended:BOOLEAN ¬ FALSE;    ReadChar: PROCEDURE [] RETURNS [ch:CHARACTER] = INLINE      {IF p>=s.length THEN {ch ¬ Ascii.NUL; ended ¬ TRUE} ELSE {ch ¬ s[p]; p¬p+1}};    BackSpace: PROCEDURE[] = INLINE {IF p#0 THEN p ¬ p-1};    GetChar: Token.GetCharProcType = {RETURN [ReadChar[]]};    SkipBlank: PROCEDURE[] =  INLINE       {Token.Skip[h:h,data:NIL,filter:Token.WhiteSpace];  BackSpace[]};    NextName: PROCEDURE[] RETURNS [value:LONG STRING] = INLINE      {value ¬ Token.Filtered[h:h, data:NIL, filter:Token.AlphaNumeric, skip:none,		             temporary:FALSE];       BackSpace[];       RETURN [value]};    Copy: PROCEDURE[s:LONG STRING] RETURNS [LONG STRING] = INLINE      {RETURN [String.CopyToNewString[z:z, s:s]]};        newItems:Items;    newDisplay:DisplayHandle;    ok:BOOLEAN ¬ TRUE;    item, firstItem: ItemP ¬ NIL;    nextItem: LONG POINTER TO ItemP ¬ @firstItem;    nItems:CARDINAL ¬ 0;        UpdatePlaceHandle[ctx];    IF ctx.placeHandle.type=bad     THEN {Put.Line[ctx.msgSW, "bad remote name!"]; RETURN};        newDisplay ¬ GetDisplayAndCatchErrors[ctx];    IF newDisplay=NIL THEN RETURN;         -- parse the list of interfaces and variables into a list of items ...    -- (they must eventually end up as an Items, but until we know    --  the size, we cannot allocate the array, so chain the items through    --  the client LONG POINTER field, pro tem)    IF NOT String.Empty[ctx.parmString]    THEN      BEGIN      nextItem­ ¬         z.NEW[Item ¬ [Copy["Timer"L], Copy["milliseconds"L], NIL, [0,FALSE], NIL]];      nextItem ¬ @(nextItem­.client);      nItems ¬ nItems+1;      SkipBlank[];      UNTIL ended OR ~ok        DO        interfaceName, variableName: LONG STRING ¬ NIL;        BEGIN ENABLE Token.SyntaxError => GOTO quit;        interfaceName ¬ NextName[];        IF ReadChar[]#'. THEN GOTO quit;        variableName ¬ NextName[];        SkipBlank[];        nextItem­ ¬ z.NEW[Item ¬ [interfaceName, variableName, NIL, [0, FALSE], NIL]];        nextItem ¬ @(nextItem­.client);        nItems ¬ nItems+1;        EXITS          quit => 	    {ok ¬ FALSE;	     Put.Line[ctx.msgSW, "syntax error parsing list"];             IF interfaceName#NIL THEN [] ¬ Token.FreeTokenString[interfaceName];             IF variableName#NIL  THEN [] ¬ Token.FreeTokenString[variableName]};        END;        ENDLOOP;      END;        newItems ¬ AllocateItems[nItems];    item ¬ firstItem;    FOR i:CARDINAL IN [0..nItems) DO newItems[i] ¬ item; item ¬ item.client ENDLOOP;        IF ~ok THEN {FreeItems[newItems]; RETURN};        SetDisplay[ctx, newDisplay, newItems];    END;        Destroy: --ENTRY--  PROCEDURE [ctx:CtxHandle] =    BEGIN    Destroy1: ENTRY PROCEDURE [ctx:CtxHandle] =      BEGIN      -- we have to cancel any active display before destroying the tool so that      -- the call in the transition proc won't fail      SetDisplay[ctx, NIL, NIL];      END;    Destroy1[ctx];    Tool.Destroy[ctx.toolWindow];    -- will call transition proc and delete context    END;      Load: ENTRY PROCEDURE [ctx:CtxHandle] =     BEGIN    Option: TYPE =       MACHINE DEPENDENT{display(0), priority, interval, noMatch(StringLookUp.noMatch)};    DefinedOption: TYPE = Option[display..interval];    optionTable: ARRAY DefinedOption OF LONG STRING ¬      [display:"display"L, priority:"priority"L, interval:"interval"L];    h:CmFile.Handle ¬ NIL;    CheckType:PROCEDURE[h:CmFile.Handle, table:StringLookUp.TableDesc]      RETURNS [index:CARDINAL] = CmFile.NextValue;    MyNextValue:       PROCEDURE[h:CmFile.Handle,       		table:LONG DESCRIPTOR FOR ARRAY DefinedOption OF LONG STRING]      RETURNS [index:Option] = LOOPHOLE[CheckType];    option:Option;    ch:CHARACTER;    prevChar: CHARACTER;        IF ~String.Empty[ctx.parmString]    THEN       BEGIN      Put.Line[ctx.msgSW, "parameter window not empty - click POINT to confirm"];      Cursor.Set[mouseRed];      IF UserInput.WaitForConfirmation[].okay       THEN TextSW.DeleteText[sw:ctx.parmSW, pos:0, count:ctx.parmString.length,       			     keepTrash:FALSE]      ELSE {Cursor.Set[textPointer]; RETURN}      END;	      Cursor.Set[hourGlass];    [] ¬ String.AppendExtensionIfNeeded[@ctx.parmFileName, ".tom", z];    h ¬ CmFile.Open[ctx.parmFileName!CmFile.Error => GOTO openError];        IF CmFile.FindSection[h, "Parameters"L]    THEN      DO      SELECT (option ¬ MyNextValue[h:h, table:DESCRIPTOR[optionTable]      				   ! CmFile.TableError => RESUME])      FROM        noMatch => EXIT;	display => 	  {IF ctx.displayName#NIL THEN z.FREE[@ctx.displayName];	   ctx.displayName ¬ Token.Item[h:h, temporary:FALSE];		   FormSW.DisplayItem[ctx.formSW, iDisplay]};          priority => 	  {priorityTable:ARRAY [0..3) OF LONG STRING ¬	     ["background"L, "normal"L, "foreground"L];	   value:LONG STRING ¬ Token.Item[h];	   ctx.priority ¬	     SELECT StringLookUp.InTable[value, DESCRIPTOR[priorityTable]]	     FROM	       0 => Process.priorityBackground,	       1 => Process.priorityNormal,	       2 => Process.priorityForeground,	       ENDCASE => Process.priorityBackground;	   [] ¬ Token.FreeTokenString[value];	   FormSW.DisplayItem[ctx.formSW, iPriority]};	interval =>	  {ctx.interval ¬ Token.Number[h:h, radix:10 ! Token.SyntaxError => CONTINUE];	   FormSW.DisplayItem[ctx.formSW, iInterval]};      ENDCASE;      ENDLOOP;			        IF CmFile.FindSection[h, "Variables"L] THEN      BEGIN      prevChar ¬ Ascii.CR;  -- make IF statement below work properly      UNTIL (ch ¬ h­.getChar[h])=Ascii.NUL DO        TextSW.InsertChar[ctx.parmSW, ch];	prevChar ¬ ch;        ENDLOOP;      -- if no carriage return at end of file, add one.      IF prevChar # Ascii.CR THEN TextSW.InsertChar[ctx.parmSW, Ascii.CR];      END;    [] ¬ CmFile.Close[h];    Cursor.Set[textPointer];    EXITS      openError => Put.Line[ctx.msgSW, "error opening file for input"];    END;          Reset: ENTRY PROCEDURE [ctx:CtxHandle] =    BEGIN    Clear:PROCEDURE[i:CARDINAL] = {FormSW.ModifyEditable[ctx.formSW, i, 0, 0]};    Clear[iDisplay];    Clear[iInterface];    Clear[iVariable];    Clear[iParmFile];    Clear[iRemoteMachine];    ctx.priority ¬ Process.priorityBackground;    FormSW.DisplayItem[ctx.formSW, iPriority];    ctx.interval ¬ 1000;    FormSW.DisplayItem[ctx.formSW, iInterval];          IF ~String.Empty[ctx.parmString]    THEN TextSW.DeleteText[sw:ctx.parmSW, pos:0, count:ctx.parmString.length,       			     keepTrash:FALSE];			         IF ctx.display#NIL    THEN SetDisplay[ctx, NIL, NIL];    END;          Save: ENTRY PROCEDURE [ctx:CtxHandle] =    BEGIN    stream:Stream.Handle;     p:Format.StringProc = {Stream.PutString[sH:stream, string:s]};    [] ¬ String.AppendExtensionIfNeeded[@ctx.parmFileName, ".tom", z];    stream ¬ MStream.WriteOnly[name:ctx.parmFileName, release:[NIL,NIL], type:text    			       ! MStream.Error => GOTO openError];			           Format.Line[p, "[Parameters]"L];        IF ~String.Empty[ctx.displayName]    THEN {Format.LongString[p, "display: "L];           Format.Line[p, ctx.displayName]};	      Format.LongString[p, "priority: "L];    Format.Line[p,       SELECT ctx.priority FROM        Process.priorityBackground => "background"L,        Process.priorityForeground => "foreground"L,        Process.priorityNormal => "normal"L,        ENDCASE => "background"L];	    Format.LongString[p, "interval: "L];    Format.Decimal[p, ctx.interval];        THROUGH [1..2] DO Format.CR[p] ENDLOOP;    		           IF ~String.Empty[ctx.parmString]			     THEN {Format.Line[p, "[Variables]"L];           Format.LongString[p, ctx.parmString]};    Stream.Delete[stream];    EXITS      openError => Put.Line[ctx.msgSW, "error opening file for output"];    END;				               END....  LOG25-Apr-83  9:54:57  JXG  created file19-Nov-85 13:59:05  RSV  Added MsgSW.Clear in MainFormCommandProc (AR 5521) and a RETURN in Add in String.Empty.  7-Nov-86 14:28:20  RSV  Changed Load command to add a carriage return even if one is not in the file.
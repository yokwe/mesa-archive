-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Script11.mesa       26-Apr-83 17:20:59 by CAJ -- Virtual memory test program, Klamath Pilot.-- Script11 tests Activate, Deactivate, ForceOut, and Kill.DIRECTORY  Environment USING [PageCount, PageNumber],  ScriptOps USING [RegisterScript],  Space USING [SwapUnitSize],  VM USING [Interval, nullBackingStoreRuns],  VMTestOperations --USING [all the operations]--,  VMTestScript USING [GetHeap, GetTestVMSize, GiveBackHeap, MakeBackingData,    MakeIrregularSwapData, MakeUniformSwapData, MakeUnitarySwapData, Ticker];Script11: PROGRAM  IMPORTS ScriptOps, VMTestOperations, VMTestScript =  BEGIN  ------------  -- PUBLIC procedures:  -- RunTests is a script of tests using VMTestOperations procedures  RunTests: PUBLIC PROCEDURE =    BEGIN OPEN VMTestOperations, VMTestScript;    heap: UNCOUNTED ZONE ¬ GetHeap[];    TestActivate[heap];    TestComboA[heap];    TestComboB[heap];    heap ¬ GiveBackHeap[heap];    END;  ------------  -- PRIVATE procedures:  -- Map unit attribute combinations  TestActivate: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    vmSize: CARDINAL = CARDINAL[GetTestVMSize[]];  -- known to be short    pArray: LONG POINTER;    -- Activates with normal case Map (readWrite, alive, swappable)    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "readWrite, alive, swappable"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 6]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: alive,      swappability: swappable];    -- Each test uses a new interval unless reuse is relevant to the test or    -- otherwise noted.    -- activate single swap unit    Activate[[3, 1], wait];    Ticker[];    -- activate overlap to next    Activate[[4, 5], wait];    Ticker[];    -- activate already activated    Activate[[4, 5], wait];    Ticker[];    -- activate already in, clean    Touch[[1, 1], read];    Activate[[0, 3], wait];    Ticker[];    -- activate already in, dirty    Touch[[2, 1], write];    Activate[[0, 3], wait];    Ticker[];    -- activate less than swap unit    Activate[[14, 1], wait];    Ticker[];    -- activate running off end of map unit    Activate[[17, 4], wait];    Ticker[];    -- activate unmapped    Activate[[20, 5], wait];    Ticker[];    -- activate all of testVM    Activate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Activates on space Mapped dead    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "swappable + readWrite + dead"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 6]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: dead,      swappability: swappable];    -- activate single swap unit    Activate[[3, 1], wait];    Ticker[];    -- activate overlap to next    Activate[[4, 5], wait];    Ticker[];    -- activate already activated    Activate[[4, 5], wait];    Ticker[];    -- activate already in    Touch[[1, 1], read];    Activate[[0, 3], wait];    Ticker[];    -- activate less than swap unit    Activate[[14, 1], wait];    Ticker[];    -- activate running off end of map unit    Activate[[17, 4], wait];    Ticker[];    -- activate all of testVM    Activate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Activates on space Mapped resident + readWrite + alive    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "resident + readWrite + alive"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 6]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: alive,      swappability: resident];    -- activate single swap unit    Activate[[3, 1], wait];    Ticker[];    -- activate overlap to next    Activate[[4, 5], wait];    Ticker[];    -- activate already activated    Activate[[4, 5], wait];    Ticker[];    -- activate already in, dirty    Touch[[2, 1], write];    Activate[[0, 3], wait];    Ticker[];    -- activate less than swap unit    Activate[[14, 1], wait];    Ticker[];    -- activate running off end of map unit    Activate[[17, 4], wait];    Ticker[];    -- activate all of testVM    Activate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Activates on space Mapped resident + readWrite + dead    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "resident + readWrite + dead"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 6]],      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: dead,      swappability: resident];    -- activate single swap unit    Activate[[3, 1], wait];    Ticker[];    -- activate overlap to next    Activate[[4, 5], wait];    Ticker[];    -- activate already activated    Activate[[4, 5], wait];    Ticker[];    -- activate already in, dirty    Touch[[2, 1], write];    Activate[[0, 3], wait];    Ticker[];    -- activate less than swap unit    Activate[[14, 1], wait];    Ticker[];    -- activate running off end of map unit    Activate[[17, 4], wait];    Ticker[];    -- activate all of testVM    Activate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Activates on space Mapped resident + not backed (standard data space)    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "resident + readWrite + not backed"L,      interval: [0, 19],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: alive,      swappability: resident];    -- activate single swap unit    Activate[[3, 1], wait];    Ticker[];    -- activate overlap to next    Activate[[4, 5], wait];    Ticker[];    -- activate already activated    Activate[[4, 5], wait];    Ticker[];    -- activate dirty    Touch[[2, 1], write];    Activate[[0, 3], wait];    Ticker[];    -- activate less than swap unit    Activate[[14, 1], wait];    Ticker[];    -- activate running off end of map unit    Activate[[17, 4], wait];    Ticker[];    -- activate all of testVM    Activate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Activates on space Mapped resident + not backed + dead    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "resident + not backed + dead"L,      interval: [0, 19],      backed: FALSE,      runs:  VM.nullBackingStoreRuns,      access: readWrite,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: dead,      swappability: resident];    -- activate single swap unit    Activate[[3, 1], wait];    Ticker[];    -- activate overlap to next    Activate[[4, 5], wait];    Ticker[];    -- activate already activated    Activate[[4, 5], wait];    Ticker[];    -- activate dirty    Touch[[2, 1], write];    Activate[[0, 3], wait];    Ticker[];    -- activate less than swap unit    Activate[[14, 1], wait];    Ticker[];    -- activate running off end of map unit    Activate[[17, 4], wait];    Ticker[];    -- activate all of testVM    Activate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Activates on space Mapped resident + readOnly + alive    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "resident + readOnly + alive"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 6]],      access: readOnly,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: alive,      swappability: resident];    -- activate single swap unit    Activate[[3, 1], wait];    Ticker[];    -- activate overlap to next    Activate[[4, 5], wait];    Ticker[];    -- activate already activated    Activate[[4, 5], wait];    Ticker[];    -- activate referenced    Touch[[1, 1], read];    Activate[[0, 3], wait];    Ticker[];    -- activate less than swap unit    Activate[[14, 1], wait];    Ticker[];    -- activate running off end of map unit    Activate[[17, 4], wait];    Ticker[];    -- activate all of testVM    Activate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Activates on space Mapped swappable + readOnly + alive    pArray ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, 4, 5, 4, 2]];    Map[id: "swappable + readOnly + alive"L,      interval: [0, 19],      backed: TRUE,      runs:  MakeBackingData[DESCRIPTOR[pArray, 6]],      access: readOnly,      swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 6]],      life: alive,      swappability: swappable];    -- activate single swap unit    Activate[[3, 1], wait];    Ticker[];    -- activate overlap to next    Activate[[4, 5], wait];    Ticker[];    -- activate already activated    Activate[[4, 5], wait];    Ticker[];    -- activate referenced    Touch[[1, 1], read];    Activate[[0, 3], wait];    Ticker[];    -- activate less than swap unit    Activate[[14, 1], wait];    Ticker[];    -- activate running off end of map unit    Activate[[17, 4], wait];    Ticker[];    -- activate all of testVM    Activate[[0, vmSize], wait];    Ticker[];    Unmap[page: 0];    heap.FREE[@pArray];    -- Case swappable + readOnly + dead is illegal Map option    END;  TestComboA: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    count: Environment.PageCount;    page: Environment.PageNumber;    pRuns: LONG POINTER;    swapUnitSize: Space.SwapUnitSize;    vmSize: CARDINAL = CARDINAL[GetTestVMSize[]];  -- known to be short    FOR swapUnitSize IN [1..vmSize/3] DO      -- Activate/Deactivate single pages with readWrite space      pRuns ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, vmSize - 15, 5, 4, 2]];      Map[id: "readWrite, alive, swappable"L,        interval: [0, vmSize],        backed: TRUE,        runs:  MakeBackingData[DESCRIPTOR[pRuns, 6]],        access: readWrite,        swapUnits: MakeUniformSwapData[swapUnitSize],        life: alive,        swappability: swappable];      -- Activate each page separately      FOR page IN [0..vmSize) DO Activate[[page, 1], wait]; ENDLOOP;      Ticker[];      -- Dirty every fifth page (arbitrary)      count ¬ 1;      FOR page ¬ 0, page + 5 UNTIL page > vmSize - 1 DO	Touch[[page, count], write]; ENDLOOP;      -- Then Deactivate each page      FOR page IN [0..vmSize) DO Deactivate[[page, 1], wait]; ENDLOOP;      Ticker[];      -- Dirty a few pages      count ¬ 2;      FOR page ¬ 0, page + swapUnitSize + 1 UNTIL page > vmSize - count DO	Touch[[page, count], write]; ENDLOOP;      -- Activate then immediately Deactivate each page separately      -- With return      FOR page IN [0..vmSize) DO	Activate[[page, 1], return];	Deactivate[[page, 1], return];        ENDLOOP;      Ticker[];      Unmap[page: 0];      heap.FREE[@pRuns];      -- Activate/Deactivate variable intervals with readWrite space      pRuns ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, vmSize - 15, 5, 4, 2]];      Map[id: "readWrite, alive, swappable"L,        interval: [0, vmSize],        backed: TRUE,        runs:  MakeBackingData[DESCRIPTOR[pRuns, 6]],        access: readWrite,        swapUnits: MakeUniformSwapData[swapUnitSize],        life: alive,        swappability: swappable];      -- Activate/Deactivate each interval separately      FOR count IN [1..vmSize) DO        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Activate[[page, count], wait]; ENDLOOP;        Ticker[];        -- Touch every fourth page (arbitrary)        FOR page ¬ 0, page + 4 UNTIL page > vmSize - 1 DO	  Touch[[page, 1], read]; ENDLOOP;        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Deactivate[[page, count], wait]; ENDLOOP;        Ticker[];	ENDLOOP;  -- end Activate/Deactivate each interval separately      -- Touch a few pages      count ¬ 2;      FOR page ¬ 0, page + swapUnitSize + 1 UNTIL page > vmSize - count DO	Touch[[page, count], read]; ENDLOOP;      -- Activate then immediately Deactivate each interval separately      -- With return      FOR count DECREASING IN [vmSize-1..0) DO        FOR page ¬ 0, page + count UNTIL page >= vmSize DO	  Activate[[page, count], return]; Deactivate[[page, count], return];	  ENDLOOP;        Ticker[];	ENDLOOP;      Unmap[page: 0];      heap.FREE[@pRuns];      ENDLOOP;  -- end loop through swap unit sizes    END;  TestComboB: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    count: Environment.PageCount;    page: Environment.PageNumber;    pArray: LONG POINTER;    pRuns: LONG POINTER;    vmSize: CARDINAL = CARDINAL[GetTestVMSize[]];  -- known to be short      -- Bang on Activate/Deactivate, same place      pRuns ¬ heap.NEW[ARRAY[0..6) OF WORD ¬ [3, 1, vmSize - 15, 5, 4, 2]];      Map[id: "readWrite, alive, swappable"L,        interval: [0, vmSize],        backed: TRUE,        runs:  MakeBackingData[DESCRIPTOR[pRuns, 6]],        access: readWrite,        swapUnits: MakeUnitarySwapData[],        life: alive,        swappability: swappable];      IF vmSize >= 4 THEN        BEGIN        THROUGH [0..50) DO	  Activate[[1, 3], wait]; Deactivate[[1, 3], wait];	  ENDLOOP;        Ticker[];        -- Again with reference        THROUGH [0..50) DO	  Activate[[1, 3], wait]; Touch[[1, 3], write]; Deactivate[[1, 3], wait];	  ENDLOOP;        Ticker[];        END;      Unmap[page: 0];      heap.FREE[@pRuns];      -- Activate/Deactivate each page separately on unmapped space      FOR page IN [0..vmSize) DO	Activate[[page, 1], wait]; ENDLOOP;      Ticker[];      FOR page IN [0..vmSize) DO	Deactivate[[page, 1], wait]; ENDLOOP;      Ticker[];    -- Map every other page and Activate/Deactivate a variety of intervals        pArray ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [1]];    FOR page ¬ 0, page + 2 UNTIL page >= vmSize DO      Map[id: "readWrite, alive, swappable"L,        interval: [page, 1],        backed: TRUE,        runs:  MakeBackingData[DESCRIPTOR[pArray, 1]],        access: readWrite,        swapUnits: MakeIrregularSwapData[DESCRIPTOR[pArray, 1]],        life: alive,        swappability: swappable];      ENDLOOP;    FOR count IN [1..vmSize) DO      -- Touch every fourth page, then Activate all      FOR page ¬ 0, page + 4 UNTIL page >= vmSize DO	Touch[[page, 1], read]; ENDLOOP;      FOR page ¬ 0, page + count UNTIL page > vmSize - count DO        Activate[[page, count], wait]; ENDLOOP;      Ticker[];      -- Dirty every fourth page, different from before, then Deactivate all      FOR page ¬ 2, page + 4 UNTIL page >= vmSize DO	Touch[[page, 1], write]; ENDLOOP;      FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	Deactivate[[page, count], wait]; ENDLOOP;      Ticker[];            ENDLOOP;  -- end loop over count sizes    FOR page ¬ 0, page + 2 UNTIL page >= vmSize DO Unmap[page]; ENDLOOP;    heap.FREE[@pArray];    END;  ------------  -- PUBLIC SIGNALs and ERRORs: none  ------------  -- Initialization:  ScriptOps.RegisterScript[RunTests, "Activate"L];  END.LOG31-Jan-83 17:45:12   CAJ    Created file.
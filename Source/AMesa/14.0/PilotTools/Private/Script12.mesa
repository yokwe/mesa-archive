-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Script12.mesa       27-Apr-83 13:52:58 by CAJ -- Virtual memory test program, Klamath Pilot.-- Script12 tests combinations of Activate, Deactivate, ForceOut, Kill, and-- Make(Resident/Swappable/ReadOnly/Writable).DIRECTORY  Environment USING [PageCount, PageNumber],  ScriptOps USING [RegisterScript],  VM USING [Interval],  VMTestOperations --USING [all the operations]--,  VMTestScript USING [GetHeap, GetTestVMSize, GiveBackHeap, MakeBackingData,    MakeIrregularSwapData, MakeUniformSwapData, MakeUnitarySwapData, Ticker];Script12: PROGRAM  IMPORTS ScriptOps, VMTestOperations, VMTestScript =  BEGIN  ------------  -- PUBLIC procedures:  -- RunTests is a script of tests using VMTestOperations procedures  RunTests: PUBLIC PROCEDURE =    BEGIN OPEN VMTestScript;    heap: UNCOUNTED ZONE ¬ GetHeap[];    Test1[heap];    Test2[heap];    Test3[heap];    Test4[heap];    heap ¬ GiveBackHeap[heap];    END;  ------------  -- PRIVATE procedures:  -- Test various combinations of Activate, Deactivate, ForceOut, Kill, Touch  Test1: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    count: Environment.PageCount;    page: Environment.PageNumber;    pArrayIrregular: LONG POINTER;    pArrayUniform: LONG POINTER;    pArrayUnitary: LONG POINTER;    pSwapIrregular: LONG POINTER;    swapUnitSize: CARDINAL;    vmSize: CARDINAL ¬ CARDINAL[GetTestVMSize[]];  -- known to be short    FOR swapUnitSize IN [1..vmSize/10) DO      firstMapSize: CARDINAL = swapUnitSize * 2;      secondMapSize: CARDINAL = swapUnitSize * 3;      thirdMapSize: CARDINAL = swapUnitSize;      wholeMapSize: CARDINAL = firstMapSize + secondMapSize + thirdMapSize;      pArrayIrregular ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [secondMapSize]];      pArrayUniform ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [firstMapSize]];      pArrayUnitary ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [thirdMapSize]];      pSwapIrregular ¬ heap.NEW[ARRAY[0..3) OF WORD ¬        [swapUnitSize, swapUnitSize, swapUnitSize]];      -- Map intervals of pages uniform, irregular, unitary, ...      -- Doing Maps non-sequentially      FOR page ¬ 0, page + wholeMapSize UNTIL page > vmSize - firstMapSize DO        Map[id: "uniform"L,          interval: [page, firstMapSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArrayUniform, 1]],          access: readWrite,          swapUnits: MakeUniformSwapData[swapUnitSize],          life: alive,          swappability: swappable];        ENDLOOP;  -- end page loop      FOR page ¬ firstMapSize, page + wholeMapSize          UNTIL page > vmSize - secondMapSize DO        Map[id: "irregular"L,          interval: [page, secondMapSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArrayIrregular, 1]],          access: readWrite,          swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapIrregular, 3]],          life: alive,          swappability: swappable];        ENDLOOP;  -- end page loop      FOR page ¬ firstMapSize + secondMapSize, page + wholeMapSize          UNTIL page > vmSize - thirdMapSize DO        Map[id: "unitary"L,          interval: [page, thirdMapSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArrayUnitary, 1]],          access: readWrite,          swapUnits: MakeUnitarySwapData[],          life: alive,          swappability: swappable];        ENDLOOP;  -- end page loop      BEGIN ENABLE VMTestOperations.CannotTouch => CONTINUE;      -- Just skip Touch if page isn't mapped.      -- Activate - ForceOut - Kill      FOR count IN [1..vmSize/2] DO  -- vary interval size        FOR page IN [0..vmSize/2] DO  -- vary starting location	  beginning: VM.Interval ¬ [page, count];	  end: VM.Interval ¬ [vmSize - page - count, count];	  Activate[beginning, wait];	  Activate[end, wait];	  ForceOut[beginning, wait];	  ForceOut[end, wait];	  Kill[beginning];	  Kill[end];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Touch[[0, vmSize], write];  -- un-Kill      Deactivate[[0, vmSize], return];      -- Touch - Activate - ForceOut - Kill      FOR count IN [1..vmSize) DO        -- first dirty every (count+1) page	FOR page ¬ 0, page + count + 1 UNTIL page >= vmSize DO          Touch[[page, 1], write]; ENDLOOP;	-- Activate by count-sized groups        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Activate[[page, count], return]; ENDLOOP;        -- ForceOut every other page	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 2 DO	  ForceOut[[page, 1], return]; ENDLOOP;	-- Kill everything at once	Kill[[0, vmSize]];        Ticker[];	ENDLOOP;  -- end loop over interval sizes      -- Restore state      Touch[[0, vmSize], write];  -- un-Kill      Deactivate[[0, vmSize], return];      -- Touch alt. read/write - ForceOut - Activate      FOR count DECREASING IN [1..vmSize) DO        -- Touch alternate pages read/write/read/write/...	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 2 DO          Touch[[page, 1], read]; Touch[[page + 1, 1], write]; ENDLOOP;	-- ForceOut by count-sized groups        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  ForceOut[[page, count], return]; ENDLOOP;	-- Activate backwards        FOR page ¬ vmSize - count, page - count DO	  Activate[[page, count], return];	  IF page < count THEN EXIT; -- really need REPEAT UNTIL	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Deactivate[[0, vmSize], return];      -- Touch alt. read/write - Deactivate - Touch - ForceOut      FOR count IN [1..vmSize) DO        -- Touch alternate pages write/read/write/read/...	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 2 DO          Touch[[page, 1], write]; Touch[[page + 1, 1], read]; ENDLOOP;        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Deactivate[[page, count], return];	  Touch[[page, 1], read];	  ForceOut[[page, count], return];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Deactivate[[0, vmSize], return];      -- Touch write - Deactivate - Touch - Kill      FOR count IN [1..vmSize) DO  -- vary interval size        -- first dirty all the pages	Touch[[0, vmSize], write];        -- Deactivate moving forward, and Kill moving downward	FOR page IN [0..vmSize - count) DO  -- vary starting location	  beginning: VM.Interval ¬ [page, count];	  end: VM.Interval ¬ [vmSize - page - count, count];	  Deactivate[beginning, wait];	  Kill[end];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Touch[[0, vmSize], write];  -- un-Kill      Deactivate[[0, vmSize], return];      -- Activate - Kill - ForceOut      FOR count DECREASING IN [1..vmSize) DO        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Activate[[page, count], return];	  Kill[[page, count]];	  ForceOut[[page, count], return];	  ENDLOOP;        Ticker[];	ENDLOOP;      END;  -- end scope of enable      -- Unmap the whole works      FOR page  ¬ 0, page + swapUnitSize UNTIL page > vmSize - swapUnitSize DO        Unmap[page] ENDLOOP;      heap.FREE[@pArrayUnitary];      heap.FREE[@pArrayUniform];      heap.FREE[@pArrayIrregular];      heap.FREE[@pSwapIrregular];      ENDLOOP;  -- end swapUnitSize loop  END;  -- Same tests as Test1 with alternate swap units made resident  Test2: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    count: Environment.PageCount;    page: Environment.PageNumber;    pArrayIrregular: LONG POINTER;    pArrayUniform: LONG POINTER;    pArrayUnitary: LONG POINTER;    pSwapIrregular: LONG POINTER;    swapUnitSize: CARDINAL;    vmSize: CARDINAL ¬ CARDINAL[GetTestVMSize[]];  -- known to be short    FOR swapUnitSize IN [1..vmSize/10) DO      firstMapSize: CARDINAL = swapUnitSize * 2;      secondMapSize: CARDINAL = swapUnitSize * 3;      thirdMapSize: CARDINAL = swapUnitSize;      wholeMapSize: CARDINAL = firstMapSize + secondMapSize + thirdMapSize;      pArrayIrregular ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [secondMapSize]];      pArrayUniform ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [firstMapSize]];      pArrayUnitary ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [thirdMapSize]];      pSwapIrregular ¬ heap.NEW[ARRAY[0..3) OF WORD ¬        [swapUnitSize, swapUnitSize, swapUnitSize]];      -- Map intervals of pages uniform, irregular, unitary, ...      -- Doing Maps non-sequentially      FOR page ¬ 0, page + wholeMapSize UNTIL page > vmSize - firstMapSize DO        Map[id: "uniform"L,          interval: [page, firstMapSize],  -- usually will be runts          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArrayUniform, 1]],          access: readWrite,          swapUnits: MakeUniformSwapData[swapUnitSize],          life: alive,          swappability: swappable];        ENDLOOP;  -- end page loop      FOR page ¬ firstMapSize, page + wholeMapSize          UNTIL page > vmSize - secondMapSize DO        Map[id: "irregular"L,          interval: [page, secondMapSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArrayIrregular, 1]],          access: readWrite,          swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapIrregular, 3]],          life: alive,          swappability: swappable];        ENDLOOP;  -- end page loop      FOR page ¬ firstMapSize + secondMapSize, page + wholeMapSize          UNTIL page > vmSize - thirdMapSize DO        Map[id: "unitary"L,          interval: [page, thirdMapSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArrayUnitary, 1]],          access: readWrite,          swapUnits: MakeUnitarySwapData[],          life: alive,          swappability: swappable];        ENDLOOP;  -- end page loop      FOR page ¬ 0, page + swapUnitSize * 2        UNTIL page > vmSize - swapUnitSize * 2 DO          MakeResident[[page, 1], wait]; ENDLOOP;      BEGIN ENABLE VMTestOperations.CannotTouch => CONTINUE;      -- Just skip Touch if page isn't mapped.      -- Activate - ForceOut - Kill      FOR count IN [1..vmSize/2] DO  -- vary interval size        FOR page IN [0..vmSize/2] DO  -- vary starting location	  beginning: VM.Interval ¬ [page, count];	  end: VM.Interval ¬ [vmSize - page - count, count];	  Activate[beginning, wait];	  Activate[end, wait];	  ForceOut[beginning, wait];	  ForceOut[end, wait];	  Kill[beginning];	  Kill[end];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Touch[[0, vmSize], write];  -- un-Kill      Deactivate[[0, vmSize], return];      -- Touch - Activate - ForceOut - Kill      FOR count IN [1..vmSize) DO        -- first dirty every (count+1) page	FOR page ¬ 0, page + count + 1 UNTIL page >= vmSize DO          Touch[[page, 1], write]; ENDLOOP;	-- Activate by count-sized groups        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Activate[[page, count], return]; ENDLOOP;        -- ForceOut every other page	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 2 DO	  ForceOut[[page, 1], return]; ENDLOOP;	-- Kill everything at once	Kill[[0, vmSize]];        Ticker[];	ENDLOOP;  -- end loop over interval sizes      -- Restore state      Touch[[0, vmSize], write];  -- un-Kill      Deactivate[[0, vmSize], return];      -- Touch alt. read/write - ForceOut - Activate      FOR count DECREASING IN [1..vmSize) DO        -- Touch alternate pages read/write/read/write/...	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 2 DO          Touch[[page, 1], read]; Touch[[page + 1, 1], write]; ENDLOOP;	-- ForceOut by count-sized groups        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  ForceOut[[page, count], return]; ENDLOOP;	-- Activate backwards        FOR page ¬ vmSize - count, page - count DO	  Activate[[page, count], return];	  IF page < count THEN EXIT; -- really need REPEAT UNTIL	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Deactivate[[0, vmSize], return];      -- Touch alt. read/write - Deactivate - Touch - ForceOut      FOR count IN [1..vmSize) DO        -- Touch alternate pages write/read/write/read/...	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 2 DO          Touch[[page, 1], write]; Touch[[page + 1, 1], read]; ENDLOOP;        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Deactivate[[page, count], return];	  Touch[[page, 1], read];	  ForceOut[[page, count], return];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Deactivate[[0, vmSize], return];      -- Touch write - Deactivate - Touch - Kill      FOR count IN [1..vmSize) DO  -- vary interval size        -- first dirty all the pages	Touch[[0, vmSize], write];        -- Deactivate moving forward, and Kill moving downward	FOR page IN [0..vmSize - count) DO  -- vary starting location	  beginning: VM.Interval ¬ [page, count];	  end: VM.Interval ¬ [vmSize - page - count, count];	  Deactivate[beginning, wait];	  Kill[end];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Touch[[0, vmSize], write];  -- un-Kill      Deactivate[[0, vmSize], return];      -- Activate - Kill - ForceOut      FOR count DECREASING IN [1..vmSize) DO        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Activate[[page, count], return];	  Kill[[page, count]];	  ForceOut[[page, count], return];	  ENDLOOP;        Ticker[];	ENDLOOP;      END;  -- end scope of enable      -- Unmap the whole works      FOR page  ¬ 0, page + swapUnitSize UNTIL page > vmSize - swapUnitSize DO        Unmap[page] ENDLOOP;      heap.FREE[@pArrayUnitary];      heap.FREE[@pArrayUniform];      heap.FREE[@pArrayIrregular];      heap.FREE[@pSwapIrregular];    ENDLOOP;  -- end swapUnitSize loop  END;  -- Same tests as Test1, with alternate swap units made readonly  Test3: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    count: Environment.PageCount;    page: Environment.PageNumber;    pArrayIrregular: LONG POINTER;    pArrayUniform: LONG POINTER;    pArrayUnitary: LONG POINTER;    pSwapIrregular: LONG POINTER;    swapUnitSize: CARDINAL;    vmSize: CARDINAL ¬ CARDINAL[GetTestVMSize[]];  -- known to be short    FOR swapUnitSize IN [1..vmSize/10) DO      firstMapSize: CARDINAL = swapUnitSize * 2;      secondMapSize: CARDINAL = swapUnitSize * 3;      thirdMapSize: CARDINAL = swapUnitSize;      wholeMapSize: CARDINAL = firstMapSize + secondMapSize + thirdMapSize;      pArrayIrregular ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [secondMapSize]];      pArrayUniform ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [firstMapSize]];      pArrayUnitary ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [thirdMapSize]];      pSwapIrregular ¬ heap.NEW[ARRAY[0..3) OF WORD ¬        [swapUnitSize, swapUnitSize, swapUnitSize]];      -- Map intervals of pages uniform, irregular, unitary, ...      -- Doing Maps non-sequentially      FOR page ¬ 0, page + wholeMapSize UNTIL page > vmSize - firstMapSize DO        Map[id: "uniform"L,          interval: [page, firstMapSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArrayUniform, 1]],          access: readWrite,          swapUnits: MakeUniformSwapData[swapUnitSize],          life: alive,          swappability: swappable];        ENDLOOP;  -- end page loop      FOR page ¬ firstMapSize, page + wholeMapSize          UNTIL page > vmSize - secondMapSize DO        Map[id: "irregular"L,          interval: [page, secondMapSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArrayIrregular, 1]],          access: readWrite,          swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapIrregular, 3]],          life: alive,          swappability: swappable];        ENDLOOP;  -- end page loop      FOR page ¬ firstMapSize + secondMapSize, page + wholeMapSize          UNTIL page > vmSize - thirdMapSize DO        Map[id: "unitary"L,          interval: [page, thirdMapSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArrayUnitary, 1]],          access: readWrite,          swapUnits: MakeUnitarySwapData[],          life: alive,          swappability: swappable];        ENDLOOP;  -- end page loop      FOR page ¬ 0, page + swapUnitSize * 2        UNTIL page > vmSize - swapUnitSize * 2 DO          MakeReadOnly[[page, 1]]; ENDLOOP;      BEGIN ENABLE        VMTestOperations.CannotTouch, VMTestOperations.CannotWrite => CONTINUE;        -- Just skip Touch if page is readonly or not mapped.      -- Activate - ForceOut - Kill      FOR count IN [1..vmSize/2] DO  -- vary interval size        FOR page IN [0..vmSize/2] DO  -- vary starting location	  beginning: VM.Interval ¬ [page, count];	  end: VM.Interval ¬ [vmSize - page - count, count];	  Activate[beginning, wait];	  Activate[end, wait];	  ForceOut[beginning, wait];	  ForceOut[end, wait];	  Kill[beginning];	  Kill[end];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Touch[[0, vmSize], write];  -- un-Kill      Deactivate[[0, vmSize], return];      -- Touch - Activate - ForceOut - Kill      FOR count IN [1..vmSize) DO        -- first reference every (count+1) page	FOR page ¬ 0, page + count + 1 UNTIL page >= vmSize DO          Touch[[page, 1], read]; ENDLOOP;	-- Activate by count-sized groups        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Activate[[page, count], return]; ENDLOOP;        -- ForceOut every other page	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 2 DO	  ForceOut[[page, 1], return]; ENDLOOP;	-- Kill everything at once	Kill[[0, vmSize]];        Ticker[];	ENDLOOP;  -- end loop over interval sizes      -- Restore state      Touch[[0, vmSize], write];  -- un-Kill      Deactivate[[0, vmSize], return];      -- Touch alt. read/write - ForceOut - Activate      FOR count DECREASING IN [1..vmSize) DO        -- Touch alternate pages read/write/read/write/...	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 2 DO          Touch[[page, 1], read]; Touch[[page + 1, 1], write]; ENDLOOP;	-- ForceOut by count-sized groups        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  ForceOut[[page, count], return]; ENDLOOP;	-- Activate backwards        FOR page ¬ vmSize - count, page - count DO	  Activate[[page, count], return];	  IF page < count THEN EXIT; -- really need REPEAT UNTIL	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Deactivate[[0, vmSize], return];      -- Touch alt. read/write - Deactivate - Touch - ForceOut      FOR count IN [1..vmSize) DO        -- Touch alternate pages write/read/write/read/...	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 2 DO          Touch[[page, 1], write]; Touch[[page + 1, 1], read]; ENDLOOP;        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Deactivate[[page, count], return];	  Touch[[page, 1], read];	  ForceOut[[page, count], return];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Deactivate[[0, vmSize], return];      -- Touch write - Deactivate - Touch - Kill      FOR count IN [1..vmSize) DO  -- vary interval size        -- first dirty all the pages	Touch[[0, vmSize], write];        -- Deactivate moving forward, and Kill moving downward	FOR page IN [0..vmSize - count) DO  -- vary starting location	  beginning: VM.Interval ¬ [page, count];	  end: VM.Interval ¬ [vmSize - page - count, count];	  Deactivate[beginning, wait];	  Kill[end];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Touch[[0, vmSize], write];  -- un-Kill      Deactivate[[0, vmSize], return];      -- Activate - Kill - ForceOut      FOR count DECREASING IN [1..vmSize) DO        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Activate[[page, count], return];	  Kill[[page, count]];	  ForceOut[[page, count], return];	  ENDLOOP;        Ticker[];	ENDLOOP;      END;  -- end scope of the enable      -- Unmap the whole works      FOR page  ¬ 0, page + swapUnitSize UNTIL page > vmSize - swapUnitSize DO        Unmap[page] ENDLOOP;      heap.FREE[@pArrayUnitary];      heap.FREE[@pArrayUniform];      heap.FREE[@pArrayIrregular];      heap.FREE[@pSwapIrregular];      ENDLOOP;  -- end mapCount loop  END;  -- Same tests as Test1, with alternate swap units made resident and readonly  Test4: PROCEDURE [heap: UNCOUNTED ZONE] =    BEGIN OPEN VMTestOperations, VMTestScript;    count: Environment.PageCount;    page: Environment.PageNumber;    pArrayIrregular: LONG POINTER;    pArrayUniform: LONG POINTER;    pArrayUnitary: LONG POINTER;    pSwapIrregular: LONG POINTER;    swapUnitSize: CARDINAL;    vmSize: CARDINAL ¬ CARDINAL[GetTestVMSize[]];  -- known to be short    FOR swapUnitSize IN [1..vmSize/10) DO      firstMapSize: CARDINAL = swapUnitSize * 2;      secondMapSize: CARDINAL = swapUnitSize * 3;      thirdMapSize: CARDINAL = swapUnitSize;      wholeMapSize: CARDINAL = firstMapSize + secondMapSize + thirdMapSize;      pArrayIrregular ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [secondMapSize]];      pArrayUniform ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [firstMapSize]];      pArrayUnitary ¬ heap.NEW[ARRAY[0..1) OF WORD ¬ [thirdMapSize]];      pSwapIrregular ¬ heap.NEW[ARRAY[0..3) OF WORD ¬        [swapUnitSize, swapUnitSize, swapUnitSize]];      -- Map intervals of pages uniform, irregular, unitary, ...      -- Doing Maps non-sequentially      FOR page ¬ 0, page + wholeMapSize UNTIL page > vmSize - firstMapSize DO        Map[id: "uniform"L,          interval: [page, firstMapSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArrayUniform, 1]],          access: readWrite,          swapUnits: MakeUniformSwapData[swapUnitSize],          life: alive,          swappability: swappable];        ENDLOOP;  -- end page loop      FOR page ¬ firstMapSize, page + wholeMapSize          UNTIL page > vmSize - secondMapSize DO        Map[id: "irregular"L,          interval: [page, secondMapSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArrayIrregular, 1]],          access: readWrite,          swapUnits: MakeIrregularSwapData[DESCRIPTOR[pSwapIrregular, 3]],          life: alive,          swappability: swappable];        ENDLOOP;  -- end page loop      FOR page ¬ firstMapSize + secondMapSize, page + wholeMapSize          UNTIL page > vmSize - thirdMapSize DO        Map[id: "unitary"L,          interval: [page, thirdMapSize],          backed: TRUE,          runs:  MakeBackingData[DESCRIPTOR[pArrayUnitary, 1]],          access: readWrite,          swapUnits: MakeUnitarySwapData[],          life: alive,          swappability: swappable];        ENDLOOP;  -- end page loop      FOR page ¬ swapUnitSize, page + swapUnitSize * 2        UNTIL page > vmSize - swapUnitSize * 2 DO          MakeResident[[page, 1], wait]; MakeReadOnly[[page, 1]]; ENDLOOP;      BEGIN ENABLE        VMTestOperations.CannotTouch, VMTestOperations.CannotWrite => CONTINUE;        -- Just skip Touch if page is readonly or not mapped.      -- Activate - ForceOut - Kill      FOR count IN [1..vmSize/2] DO  -- vary interval size        FOR page IN [0..vmSize/2] DO  -- vary starting location	  beginning: VM.Interval ¬ [page, count];	  end: VM.Interval ¬ [vmSize - page - count, count];	  Activate[beginning, wait];	  Activate[end, wait];	  ForceOut[beginning, wait];	  ForceOut[end, wait];	  Kill[beginning];	  Kill[end];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Touch[[0, vmSize], write];  -- un-Kill      Deactivate[[0, vmSize], return];      -- Touch - Activate - ForceOut - Kill      FOR count IN [1..vmSize) DO        -- first reference every (count+1) page	FOR page ¬ 0, page + count + 1 UNTIL page >= vmSize DO          Touch[[page, 1], read]; ENDLOOP;	-- Activate by count-sized groups        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Activate[[page, count], return]; ENDLOOP;        -- ForceOut every other page	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 2 DO	  ForceOut[[page, 1], return]; ENDLOOP;	-- Kill everything at once	Kill[[0, vmSize]];        Ticker[];	ENDLOOP;  -- end loop over interval sizes      -- Restore state      Touch[[0, vmSize], write];  -- un-Kill      Deactivate[[0, vmSize], return];      -- Touch alt. read/write - ForceOut - Activate      FOR count DECREASING IN [1..vmSize) DO        -- Touch alternate pages read/write/read/write/...	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 2 DO          Touch[[page, 1], read]; Touch[[page + 1, 1], write]; ENDLOOP;	-- ForceOut by count-sized groups        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  ForceOut[[page, count], return]; ENDLOOP;	-- Activate backwards        FOR page ¬ vmSize - count, page - count DO	  Activate[[page, count], return];	  IF page < count THEN EXIT; -- really need REPEAT UNTIL	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Deactivate[[0, vmSize], return];      -- Touch alt. read/write - Deactivate - Touch - ForceOut      FOR count IN [1..vmSize) DO        -- Touch alternate pages write/read/write/read/...	FOR page ¬ 0, page + 2 UNTIL page > vmSize - 2 DO          Touch[[page, 1], write]; Touch[[page + 1, 1], read]; ENDLOOP;        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Deactivate[[page, count], return];	  Touch[[page, 1], read];	  ForceOut[[page, count], return];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Deactivate[[0, vmSize], return];      -- Touch write - Deactivate - Touch - Kill      FOR count IN [1..vmSize) DO  -- vary interval size        -- first dirty all the pages	Touch[[0, vmSize], write];        -- Deactivate moving forward, and Kill moving downward	FOR page IN [0..vmSize - count) DO  -- vary starting location	  beginning: VM.Interval ¬ [page, count];	  end: VM.Interval ¬ [vmSize - page - count, count];	  Deactivate[beginning, wait];	  Kill[end];	  ENDLOOP;        Ticker[];	ENDLOOP;      -- Restore state      Touch[[0, vmSize], write];  -- un-Kill      Deactivate[[0, vmSize], return];      -- Activate - Kill - ForceOut      FOR count DECREASING IN [1..vmSize) DO        FOR page ¬ 0, page + count UNTIL page > vmSize - count DO	  Activate[[page, count], return];	  Kill[[page, count]];	  ForceOut[[page, count], return];	  ENDLOOP;        Ticker[];	ENDLOOP;      END;  -- end scope of the enable      -- Unmap the whole works      FOR page  ¬ 0, page + swapUnitSize UNTIL page > vmSize - swapUnitSize DO        Unmap[page] ENDLOOP;      heap.FREE[@pArrayUnitary];      heap.FREE[@pArrayUniform];      heap.FREE[@pArrayIrregular];      heap.FREE[@pSwapIrregular];      ENDLOOP;  -- end swapUnitSize loop    END;  ------------  -- PUBLIC SIGNALs and ERRORs: none  ------------  -- Initialization:  ScriptOps.RegisterScript[RunTests, "ADFKM*"L];  END.LOG 8-Mar-83 17:16:09   CAJ    Created file.
-- Copyright (C) 1983, 1985, 1987, 1988  by Xerox Corporation. All rights reserved. -- MugTorment.mesa	last edited by: CAJ   	 5-May-88 17:19:05-- Torment Subwindow handling for the Disk Torment-and-Scavenge ToolDIRECTORY  Cursor USING [Fetch, Object, Set],  DDC USING [ChannelCommand, corruptDataHandle, corruptLabelAndDataHandle,    DDCHardwareBits, IOCBshortPtr, normalDeviceHandle],  DiskChannel USING [DiskPageNumber, GetDriveAttributes, GetPageAddress],  DLionInputOutput USING [diskCSBOffset, Input, IOPage],  Environment USING [Base, wordsPerPage],  File USING [ID, PageNumber, Type],  Format USING [],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, Enumerated,    EnumeratedItem, line0, line1, nextPlace, ProcType, TagOnlyItem],  Inline USING [BITNOT, LongCOPY],  MsgSW USING [Clear],  MugInternal USING [BadCommand, diskData, FilePageToPVPage, NewCommand,    PageSpec, toolData],  PilotDisk USING [FaceLabel, Handle, Label, SetLabelFilePage],  PilotDiskFace USING [Command, ControllerHandle, DiskAddress,    GetNextController, Initiate, nullControllerHandle, OperationPtr,    Poll, Status],  PilotFileTypes-- USING [all the reserved types]--,  ProcessOperations USING [DisableInterrupts, EnableInterrupts],  Put USING [Char, Line, LongNumber, Text],  Space USING [GetMapUnitAttributes, PageFromLongPointer],  SpecialSpace USING [    MakeProcedureResident, MakeProcedureSwappable, SpecialError],  UserInput USING [WaitForConfirmation],  VM USING [Interval, MakeResident, MakeSwappable, ReturnWait],  Window USING [Handle];MugTorment: MONITOR  IMPORTS Cursor, DLionInputOutput, DiskChannel, FormSW, Inline, MsgSW,    MugInternal, PilotDisk, PilotDiskFace, ProcessOperations, Put, Space,    SpecialSpace, UserInput, VM  EXPORTS MugInternal =  BEGIN    -- csb, CSB, and nil are copied from SA4000HeadDLion.mesa.  If any change there,  -- they must also be changed here.  -- Controller status block, only one per DLion.  only state.next is  --   known by microcode.  CSB: TYPE = MACHINE DEPENDENT RECORD [    cylinder(0):              CARDINAL,    next(1):                  Environment.Base RELATIVE POINTER TO        DDC.ChannelCommand,    tail(2):                  DDC.IOCBshortPtr,  -- last iocb. Used by initiate    transferMask(3):          WORD,          -- naked notify mask.     needRecalibrate(4:0..15): BOOLEAN];      -- TRUE => recalibrate required.  csb: LONG POINTER TO CSB = LOOPHOLE[DLionInputOutput.IOPage +      DLionInputOutput.diskCSBOffset];  nil: Environment.Base RELATIVE POINTER = LOOPHOLE[0];  SavedState: TYPE = ARRAY [0..5) OF WORD;  TormentTask: TYPE = {makeMissing, makeOrphan, makeUnreadable};  nDiskPages: DiskChannel.DiskPageNumber;      MakeTSW: PUBLIC FormSW.ClientItemsProcType =    BEGIN OPEN F: FormSW, M: MugInternal;    i: CARDINAL ¬ 0;    nItems: CARDINAL = 6;    pageSpec: ARRAY [0..2) OF F.Enumerated ¬ [      ["Use PV page"L, M.PageSpec[pvPage]],      ["Use File page"L, M.PageSpec[filePage]]];    items ¬ F.AllocateItemDescriptor[nItems];    items[i] ¬ F.TagOnlyItem[      tag: "MAKE PAGE"L, place: [0, F.line0]];    items[i¬i+1] ¬ F.CommandItem[      tag: "Unreadable"L, place: [100, F.line0], proc: MakeUnreadable];    items[i¬i+1] ¬ F.CommandItem[      tag: "Orphan"L, place: [180, F.line0], proc: MakeOrphan];    items[i¬i+1] ¬ F.CommandItem[      tag: "Missing"L, place: [250, F.line0], proc: MakeMissing];    items[i¬i+1] ¬ F.CommandItem[      tag: "Undo"L, place: [400, F.line0], proc: Undo];    items[i¬i+1] ¬ F.EnumeratedItem[      tag: "Page"L, place: [100, F.line1], feedback: all,      value: @M.toolData.pageTranslation,      choices: DESCRIPTOR[pageSpec]];    nDiskPages ¬      DiskChannel.GetDriveAttributes[MugInternal.diskData.drive].nPages;    RETURN[items: items, freeDesc: TRUE];    END;      AddressFromPvPage: INTERNAL PROC [page: DiskChannel.DiskPageNumber]      RETURNS [addr: PilotDiskFace.DiskAddress] =    BEGIN    addr ¬ DiskChannel.GetPageAddress[MugInternal.diskData.drive, page];    END;    DoDiskIO: INTERNAL PROC [      cmd: PilotDiskFace.Command,      page: DiskChannel.DiskPageNumber, dH: PilotDisk.Handle]      RETURNS [status: PilotDiskFace.Status] =    BEGIN OPEN d: MugInternal.diskData, t: MugInternal.toolData;    cH: PilotDiskFace.ControllerHandle ¬      PilotDiskFace.GetNextController[PilotDiskFace.nullControllerHandle];    dataInterval: VM.Interval ¬ [page: Space.PageFromLongPointer[d.dataPtr],      count: Space.GetMapUnitAttributes[d.dataPtr].interval.count];    labelInterval: VM.Interval ¬ [page: Space.PageFromLongPointer[d.labelPtr],      count: Space.GetMapUnitAttributes[d.labelPtr].interval.count];    stash: SavedState;    -- This is a real dirtball disk driver        VM.MakeResident[dataInterval, wait];    VM.MakeResident[labelInterval, wait];    -- attempt to fool Mother Nature    stash ¬ GrabDisk[];    d.operation­ ¬ [      clientHeader: AddressFromPvPage[page],      labelPtr: PilotDisk.FaceLabel[d.labelPtr],      dataPtr: d.dataPtr,      incrementDataPtr: FALSE,      command: cmd,      tries: 10,  -- arbitrary      pageCount: 1,      deviceStatus: NULL,  -- set by Poll      diskHeader: NULL,  -- not used by us      device: dH];    PilotDiskFace.Initiate[d.operation];    DO      op: PilotDiskFace.OperationPtr;      [status, op] ¬ PilotDiskFace.Poll[cH];      IF status ~= inProgress THEN        IF op = d.operation THEN EXIT;      IF (cH ¬ PilotDiskFace.GetNextController[cH]) =        PilotDiskFace.nullControllerHandle THEN	  cH ¬ PilotDiskFace.GetNextController[cH];      ENDLOOP;    ReleaseDisk[stash];    VM.MakeSwappable[dataInterval];    VM.MakeSwappable[labelInterval];    RETURN [status];    END;  DoPage: ENTRY PROC [task: TormentTask] =    BEGIN OPEN d: MugInternal.diskData, t: MugInternal.toolData;    cmd: PilotDiskFace.Command;    dH: PilotDisk.Handle;    ok: BOOLEAN ¬ TRUE;    pvPage: DiskChannel.DiskPageNumber;    s: PilotDiskFace.Status;    MugInternal.NewCommand[];    MakeProcsResident[];    IF t.pageTranslation = filePage      THEN [ok, pvPage] ¬ MugInternal.FilePageToPVPage[t.fileID, t.filePage]      ELSE {pvPage ¬ t.pvPage; ok ¬ ValidDiskPage[pvPage]};    IF ~ok THEN GOTO badPage;    -- Check page is on target volume; stop with message if not    -- Read existing page label and data    IF (s ¬ DoDiskIO[[verify, read, read], pvPage, DDC.normalDeviceHandle]) ~=        goodCompletion      THEN Put.Text[t.logSW, "read error: "L]      ELSE BEGIN      IF ~OkToTrash[] THEN GOTO stopNow;      -- save for undo      Inline.LongCOPY[from: d.dataPtr, nwords: Environment.wordsPerPage,        to: d.saveData];      Inline.LongCOPY[from: d.labelPtr, nwords: SIZE[PilotDisk.Label],        to: d.saveLabel];      d.savePage ¬ pvPage;      SELECT task FROM        makeMissing =>	  BEGIN	  cmd ¬ [verify, write, noOp];	  -- Rewrite bogus label, taking care to make it filePage 0	  d.labelPtr.fileID ¬ [	    volumeRelative [LOOPHOLE[LONG[PilotFileTypes.tFreePage]]]];	  d.labelPtr.type ¬ PilotFileTypes.tFreePage;	  PilotDisk.SetLabelFilePage[d.labelPtr, LONG[0]];	  dH ¬ DDC.normalDeviceHandle;	  END;	makeOrphan =>	  BEGIN	  cmd ¬ [verify, write, write];          -- Use special device handle to request a label CRC error	  dH ¬ DDC.corruptLabelAndDataHandle;	  END;	makeUnreadable =>	  BEGIN	  cmd ¬ [verify, verify, write];          -- Use special device handle to request a data CRC error	  dH ¬ DDC.corruptDataHandle;	  END;	ENDCASE => {MakeProcsSwappable[]; ERROR};  -- impossible command      s ¬ DoDiskIO[cmd, pvPage, dH];      d.undoValid ¬ TRUE;      END;    WritePVPage[t.logSW, pvPage];    Put.Text[h: t.logSW, s: " ... "L];    Put.Line[h: t.logSW, s: SELECT s FROM      goodCompletion => "successful"L,      notReady => "notReady"L,      recalibrateError => "recalibrateError"L,      seekTimeout => "seekTimeout"L,      headerCRCError => "headerCRCError"L,      labelCRCError => "labelCRCError"L,      dataCRCError => "dataCRCError"L,      headerNotFound => "headerNotFound"L,      labelVerifyError => "labelVerifyError"L,      dataVerifyError => "dataVerifyError"L,      overrunError => "overrunError"L,      writeFault => "writeFault"L,      memoryError => "memoryError"L,      memoryFault => "memoryFault"L,      clientError => "clientError"L,      operationReset => "operationReset"L,      otherError => "otherError"L,      ENDCASE => "unexpected error"L];    MakeProcsSwappable[];    EXITS      badPage =>        {MugInternal.BadCommand["Illegal page"L]; MakeProcsSwappable[]; RETURN};      stopNow =>        {Put.Line[MugInternal.toolData.logSW, "...aborted"L];	 MakeProcsSwappable[]; RETURN};    END;    GrabDisk: PUBLIC PROC RETURNS [savedState: SavedState] =    BEGIN OPEN s: LOOPHOLE[savedState, CSB];    -- GetDDCHardwareBits is copied from SA4000HeadDLion.mesa.  If it changes    -- there, it must be changed here also.    -- DLion boards return status with negative logic    GetDDCHardwareBits: PROC RETURNS [DDC.DDCHardwareBits] = INLINE {    RETURN[LOOPHOLE[Inline.BITNOT[DLionInputOutput.Input[KStatus]]]]};    DO      ProcessOperations.DisableInterrupts[];      IF ~GetDDCHardwareBits[].firmwareBusy THEN EXIT;      ProcessOperations.EnableInterrupts[];      ENDLOOP;    s ¬ csb­;    csb.next ¬ csb.tail ¬ nil;    csb.transferMask ¬ 0;    END;    MakeMissing: FormSW.ProcType =    {Put.Text[MugInternal.toolData.logSW, "Make missing "L]; DoPage[makeMissing]};  MakeOrphan: FormSW.ProcType =    {Put.Text[MugInternal.toolData.logSW, "Make orphan "L]; DoPage[makeOrphan]};  MakeUnreadable: FormSW.ProcType =    {Put.Text[MugInternal.toolData.logSW, "Make unreadable "L];     DoPage[makeUnreadable]};  OkToTrash: PROC RETURNS [ok: BOOLEAN] =    BEGIN OPEN PFT: PilotFileTypes;    lastReservedType: File.Type = PFT.tRootDirectory;    saveCursor: Cursor.Object;    type: File.Type =  MugInternal.diskData.labelPtr.type;    IF type > lastReservedType      OR type = PFT.tUnassigned      OR type = PFT.tFreePage      OR type = PFT.tAnonymousFile THEN RETURN[TRUE]    ELSE BEGIN      Put.Text[MugInternal.toolData.msgSW, "Confirm OK to trash: "L];      Put.Line[MugInternal.toolData.msgSW, SELECT type FROM        PFT.tPhysicalVolumeRootPage =>"PV root page"L,        PFT.tBadPageList =>"Bad page list"L,        PFT.tBadPage =>"Bad page"L,        PFT.tSubVolumeMarkerPage =>"Marker page"L,        PFT.tLogicalVolumeRootPage =>"LV root page"L,        PFT.tVolumeAllocationMap =>"Vol alloc map"L,        PFT.tVolumeFileMap =>"Vol file map"L,        PFT.tScavengerLog =>"Scavenger log"L,        PFT.tTempFileList =>"Temp file list"L,        PFT.tTransactionStateFile =>"Transaction state file"L,        PFT.tVMBackingFile =>"VM backing file"L,        PFT.tBeingMoved,        PFT.tBeingReplicated =>"File in motion"L,        PFT.tTransactionLog =>"Transaction log"L,        PFT.tScavengerLogOtherVolume =>"Scavenger log, other volume"L,	PFT.tRootDirectory =>"Root Directory"L,        ENDCASE => "(unknown)"L];      Cursor.Fetch[@saveCursor];      Cursor.Set[mouseRed];      ok ¬ UserInput.WaitForConfirmation[].okay;      Cursor.Set[saveCursor.info.type];      MsgSW.Clear[MugInternal.toolData.msgSW];      END;    END;  MakeProcsResident: PROCEDURE =    BEGIN    SpecialSpace.MakeProcedureResident[LOOPHOLE[DiskChannel.GetPageAddress]      ! SpecialSpace.SpecialError => IF error = alreadyResident        THEN CONTINUE ELSE REJECT];    SpecialSpace.MakeProcedureResident[LOOPHOLE[DoDiskIO]      ! SpecialSpace.SpecialError => IF error = alreadyResident        THEN CONTINUE ELSE REJECT];    SpecialSpace.MakeProcedureResident[LOOPHOLE[GrabDisk]      ! SpecialSpace.SpecialError => IF error = alreadyResident        THEN CONTINUE ELSE REJECT];    SpecialSpace.MakeProcedureResident[LOOPHOLE[AddressFromPvPage]      ! SpecialSpace.SpecialError => IF error = alreadyResident        THEN CONTINUE ELSE REJECT];    SpecialSpace.MakeProcedureResident[LOOPHOLE[ReleaseDisk]      ! SpecialSpace.SpecialError => IF error = alreadyResident        THEN CONTINUE ELSE REJECT];    END;  MakeProcsSwappable: PROCEDURE =    BEGIN    SpecialSpace.MakeProcedureSwappable[LOOPHOLE[DiskChannel.GetPageAddress]      ! SpecialSpace.SpecialError => IF error = alreadySwappable        THEN CONTINUE ELSE REJECT];    SpecialSpace.MakeProcedureSwappable[LOOPHOLE[DoDiskIO]      ! SpecialSpace.SpecialError => IF error = alreadySwappable        THEN CONTINUE ELSE REJECT];    SpecialSpace.MakeProcedureSwappable[LOOPHOLE[GrabDisk]      ! SpecialSpace.SpecialError => IF error = alreadySwappable        THEN CONTINUE ELSE REJECT];    SpecialSpace.MakeProcedureSwappable[LOOPHOLE[AddressFromPvPage]      ! SpecialSpace.SpecialError => IF error = alreadySwappable        THEN CONTINUE ELSE REJECT];    SpecialSpace.MakeProcedureSwappable[LOOPHOLE[ReleaseDisk]      ! SpecialSpace.SpecialError => IF error = alreadySwappable        THEN CONTINUE ELSE REJECT];    END;  ReleaseDisk: PUBLIC PROC [savedState: SavedState] =    BEGIN OPEN s: LOOPHOLE[savedState, CSB];    cyl: CARDINAL ¬ csb.cylinder;    csb­ ¬ s;    csb.cylinder ¬ cyl;    csb.needRecalibrate ¬ TRUE;  -- play it safe    ProcessOperations.EnableInterrupts[];    END;  Undo: ENTRY FormSW.ProcType =    BEGIN OPEN d: MugInternal.diskData;    s: PilotDiskFace.Status;    MugInternal.NewCommand[];    IF ~d.undoValid THEN GOTO invalidUndo;    IF ~ValidDiskPage[d.savePage] THEN GOTO invalidPage;    Inline.LongCOPY[d.saveData, Environment.wordsPerPage, d.dataPtr];    Inline.LongCOPY[d.saveLabel, SIZE[PilotDisk.Label], d.labelPtr];    Put.Text[MugInternal.toolData.logSW, "Undo: rewrite  "L];    WritePVPage[MugInternal.toolData.logSW, d.savePage];    s ¬ DoDiskIO[[verify, write, write], d.savePage, DDC.normalDeviceHandle];    Put.Line[MugInternal.toolData.logSW, IF s=goodCompletion      THEN " ...successful."L ELSE " ...failed."L];    d.undoValid ¬ FALSE;    EXITS      invalidPage => MugInternal.BadCommand["Invalid page"L];      invalidUndo => MugInternal.BadCommand["Nothing to Undo"L];    END;  ValidDiskPage: PUBLIC PROC [page: DiskChannel.DiskPageNumber]      RETURNS[valid: BOOLEAN] =    {RETURN[page IN      [0..DiskChannel.GetDriveAttributes[MugInternal.diskData.drive].nPages)]};  WritePVPage: PROC [w: Window.Handle, page: DiskChannel.DiskPageNumber] =    BEGIN    Put.Char[w, '[];    Put.LongNumber[h: w, n: page,      format: [base: 10, zerofill: FALSE, unsigned: TRUE, columns: 0]];    Put.Char[w, ']];    END;  END.LOGTime:    10-Sep-81 15:07:38  By: CAJ 	 Action: Created file.Time:     6-Oct-81 17:03:33  By: CAJ 	 Action: Added MakeMissing, Undo, reserved type 	 trash protection, assorted support and improvements.Time:     5-Dec-81 13:11:40  By: CAJ 	 Action: Converted from SA4000Face to PilotDiskFace; correct number of label words saved for undo.Time:    24-Aug-82 11:06:38  By: CRF	 Action: Converted from FunnySA4000HeadDLion to new SA4000HeadDLion, moving GrabDisk and ReleaseDisk here from FunnySA4000HeadDLion, and copying csb, CSB, nil, and GetDDCHardwareBits from SA4000HeadDLion; added call to DetermineDiskShape.Time:    14-Apr-83 17:04:29  By: EKN    Action: Converted to KlamathTime:    18-Oct-83 11:31:23  By: JXP    Action: Make appropriate procs. resident.Time:    13-Nov-85 18:58:01  By: RSV    Action: Added PFT.tRootDirectory as last known filetype and gave it a message.Time:     5-Oct-87 12:14:53  By: RSV    Action: Make DiskChannel.GetPageAddress resident (it is currently in DiskChannelSwappable).Time:    17-Dec-87 14:52:55  By: CAJ 	Action: Make PV page# output decimal to match input.  Replace bufferless DetermineDiskShape with DiskChannel.InspectDiskShape, and don't repeat it for each page.Time:     5-May-88 17:18:58  By: CAJ    Action: Initialize nPages before any command can run.  Remove InspectDiskShape - we can assume that's taken care of by the environment this tool runs in.
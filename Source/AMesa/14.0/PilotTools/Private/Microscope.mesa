-- Copyright (C) 1984, 1986, 1987  by Xerox Corporation. All rights reserved. -- Microscope.mesa   17-Mar-87 11:28:20 by RSV    -- This program is a debugger or a client tool used for looking at the virtual=>real PageMap.DIRECTORY  Boot USING [countGermVM, mdsiGerm, pageGerm],  DebugUsefulDefs USING [InvalidAddress],  DebugUsefulDefsExtras2 USING [GetPageState, GetVMSize, SwapState],  Environment USING [    LongPointerFromPage, maxPagesInMDS, PageCount, PageNumber, wordsPerPage],  Exec USING [AddCommand, ExecProc, RemoveCommand, OutputProc],  Format USING [NumberFormat],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Enumerated, EnumeratedItem, line0, LongNumberItem, nextLine, ProcType, sameLine],  MSegment USING [FreeWords, GetWords],  MsgSW USING [Clear, Post],  PageMap USING [    GetState, Flags, flagsClean, flagsVacant, IsMapped, IsVacant, RealPageNumber],  Put USING [CR, Line, LongNumber, Number, Text],  Runtime USING [GetBcdTime],  Space USING [virtualMemory],  String USING [AppendString],  Time USING [Append, Unpack],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType, Activate],  UserInput USING [ResetUserAbort, UserAbort],  UserTerminal USING [BlinkDisplay],  Window USING [Handle],  WindowFont USING [CharWidth];Microscope: PROGRAM  IMPORTS    DebugUsefulDefs, DebugUsefulDefsExtras2, Environment, Exec, FormSW,    MSegment, MsgSW, PageMap, Put, Runtime, Space, String, Time, Tool,    ToolWindow, UserInput, UserTerminal, WindowFont  SHARES PageMap =  BEGIN  -- PARAMETERS:  debug: BOOLEAN ¬ FALSE;  -- shall we go to the debugger on errors?  -- TYPEs and type conversion:  PageNumber: TYPE = Environment.PageNumber;  PageCount: TYPE = Environment.PageCount;  RealVM: TYPE = {real, vm};  -- Constants:  pageZero: PageNumber = FIRST[PageNumber];  wordsPerPage: CARDINAL = Environment.wordsPerPage;  flagsVacant: PageMap.Flags = PageMap.flagsVacant;  flagsClean: PageMap.Flags = PageMap.flagsClean;  -- Germ storage allocation and use:  pageGerm: PageNumber = Boot.pageGerm + Boot.mdsiGerm*Environment.maxPagesInMDS;  -- (page 1)  pageEndGermVM: PageNumber = pageGerm + Boot.countGermVM;  -- end VM page usable by Germ.  VolumeType: TYPE = {local, client};  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = RECORD [    -- Note: enumerateds and booleans must be word boundary    --   aligned as addresses for them must be generated    msgSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    startPage: PageNumber ¬ 0,    count: Environment.PageCount ¬ 1,    verbose: BOOLEAN ¬ FALSE,    pageLastDisplayed: PageNumber ¬ 0,    volume: VolumeType ¬ local];  -- Variables:  d: DataHandle ¬ NIL;  wh: Window.Handle;  AbortThyself: SIGNAL = CODE;  LogicProblem: PRIVATE SIGNAL;  -- program logic or client data problem. Proceed at your own risk.  realVM: RealVM ¬ real;  --=======================================================  -- Initialization:  --=======================================================  Initialize: PROCEDURE =    BEGIN    herald: STRING ¬ [60];    Exec.AddCommand[      "Microscope.~"L, MicroExec, MicroHelp, MicroUnload];    String.AppendString[herald, "Microscope of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    herald.length ¬ herald.length - 8;  -- omit hours, mins, zone.    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition,      name: herald, cmSection: "Microscope"L];    END;      MicroExec: Exec.ExecProc =    BEGIN    ToolWindow.Activate[wh];    END;      MicroHelp: Exec.ExecProc =    BEGIN    h.OutputProc[]["This program is a debugger or a client tool used for looking at the virtual=>real PageMap.  c.f. [idun]<P>Microscope.doc."L];    END;      MicroUnload: Exec.ExecProc =    BEGIN    d ¬ NIL;    IF wh # NIL THEN Tool.Destroy[wh];    wh ¬ NIL;    [] ¬ Exec.RemoveCommand[h, "Microscope.~"L];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "Microscope.log"L];    d.msgSW ¬ Tool.MakeMsgSW[window: window];    d.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    d.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    END;  MakeForm: FormSW.ClientItemsProcType --RETURNS [items, freeDesc]--  =    --           1         2         3         4         5         6    -- 0123456789012345678901234567890123456789012345678901234567890    -- Page: 000000B     Count: 000         verbose    volume: client    -- Display Real Pages!   Display VM Pages!    Next!    Prev!    --    BEGIN OPEN F: FormSW;    cw: CARDINAL = WindowFont.CharWidth['M];    nItems: CARDINAL = 8;    item: CARDINAL ¬ 0;    CurItemAndIncr: PROC RETURNS [curItem: CARDINAL] = {      IF (curItem ¬ item) >= nItems THEN ERROR; item ¬ SUCC[item]};    items ¬ F.AllocateItemDescriptor[nItems];    d.startPage ¬ pageGerm;    items[CurItemAndIncr[]] ¬ F.LongNumberItem[      tag: "Page "L, place: [0*cw, F.line0], boxWidth: 10*cw, drawBox: FALSE,      signed: FALSE, notNegative: TRUE, value: @d.startPage];    d.count ¬ 1;    items[CurItemAndIncr[]] ¬ F.LongNumberItem[      tag: "Count "L, place: [18*cw, F.sameLine], drawBox: FALSE, signed: FALSE,      notNegative: TRUE, value: @d.count];    d.verbose ¬ FALSE;    items[CurItemAndIncr[]] ¬ F.BooleanItem[      tag: "verbose"L, place: [37*cw, F.sameLine], switch: @d.verbose];    BEGIN    VolumeTypeNames: ARRAY VolumeType OF F.Enumerated ¬ [      ["local"L, VolumeType[local]], ["client"L, VolumeType[client]]];    d.volume ¬ local;    items[CurItemAndIncr[]] ¬ F.EnumeratedItem[      tag: "volume"L, place: [48*cw, F.sameLine], feedback: one,      value: @d.volume,      choices: LOOPHOLE[DESCRIPTOR[VolumeTypeNames], DESCRIPTOR FOR ARRAY [0..0) OF      F.Enumerated]];    END;    items[CurItemAndIncr[]] ¬ F.CommandItem[      tag: "Display Real Pages"L, place: [0*cw, F.nextLine], proc: DisplayRealPages];    items[CurItemAndIncr[]] ¬ F.CommandItem[      tag: "Display VM Pages"L, place: [22*cw, F.sameLine], proc: DisplayVMPages];    items[CurItemAndIncr[]] ¬ F.CommandItem[      tag: "Next"L, place: [42*cw, F.sameLine], proc: Next];    items[CurItemAndIncr[]] ¬ F.CommandItem[      tag: "Prev"L, place: [49*cw, F.sameLine], proc: Prev];    IF item # nItems THEN ERROR;    RETURN[items: items, freeDesc: TRUE];    END;  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      (old = inactive) =>        IF d = NIL THEN {d ¬ MSegment.GetWords[SIZE[Data]]; d­ ¬ []};      (new = inactive) => IF d ~= NIL THEN {MSegment.FreeWords[d]; d ¬ NIL};      ENDCASE;    END;  --=======================================================  -- Error messages, text output, tool control:  --=======================================================  AbortMe: PROCEDURE =    BEGIN UserInput.ResetUserAbort[wh]; SIGNAL AbortThyself END;  PostErrorString: PROCEDURE [    text: LONG STRING, begin: {startsLine, continuingLine},    end: {endsLine, lineContinues}] =    -- Posts message both in Message sw and in log sw.    -- A CR is supplied if end = endsLine.    BEGIN    UserTerminal.BlinkDisplay[];    MsgSW.Post[      sw: d.msgSW, string: text, prefix: (begin = startsLine), severity: warning,      endOfMsg: (end = endsLine)];    Put.Text[d.fileSW, text];    IF end = endsLine THEN Put.CR[d.fileSW];    END;  PutBlock: PROCEDURE [    data: DESCRIPTOR FOR ARRAY OF UNSPECIFIED, format: Format.NumberFormat] =    BEGIN    FOR k: CARDINAL IN [0..LENGTH[data]] DO      Put.Number[d.fileSW, data[k], format]; ENDLOOP;    END;  Trouble: PROCEDURE[] = {    IF debug THEN SIGNAL LogicProblem;    PostErrorString["program logic error"L, startsLine, endsLine]};  Width: PROCEDURE [width: CARDINAL] RETURNS [Format.NumberFormat] = {    RETURN[[base: 10, zerofill: FALSE, unsigned: TRUE, columns: width]]};  WidthOctal: PROCEDURE [width: CARDINAL] RETURNS [Format.NumberFormat] = {    RETURN[[base: 8, zerofill: FALSE, unsigned: TRUE, columns: width]]};  --=======================================================  -- Worker routines:  --=======================================================  DisplayRealPages: FormSW.ProcType =    BEGIN    ENABLE {AbortThyself => GO TO Aborted;            DebugUsefulDefs.InvalidAddress =>	      {Put.Text[d.fileSW, "..confused about vmPage."L]; GO TO Aborted} };    VMemSize: Environment.PageCount ¬       IF d.volume = client THEN DebugUsefulDefsExtras2.GetVMSize[]       ELSE Space.virtualMemory.count;    realVM ¬ real; --set global, for "Next!"    MsgSW.Clear[d.msgSW];    Put.CR[d.fileSW];  -- blank line to separate from prev text.    FOR vmPage: PageNumber IN [d.startPage..d.startPage + d.count) DO      realPage: PageMap.RealPageNumber;      IF vmPage >= VMemSize THEN        {Put.Text[d.fileSW, "End of VM."L]; GO TO Aborted};      realPage ¬ GetRealPage[vmPage];      DisplayPage[vmPage, realPage];      ENDLOOP;    EXITS Aborted => Put.Line[d.fileSW, " ..aborted."L];    END; --DisplayRealPages      DisplayVMPages: FormSW.ProcType =    BEGIN    -- This searches the pageMap for the vmPage (if any) mapped to this realPage.    ENABLE {AbortThyself => GO TO Aborted;            DebugUsefulDefs.InvalidAddress =>	      {Put.Text[d.fileSW, "..confused about vmPage."L]; GO TO Aborted} };    VMemSize: Environment.PageCount ¬       IF d.volume = client THEN DebugUsefulDefsExtras2.GetVMSize[]       ELSE Space.virtualMemory.count;    realVM ¬ vm; --set global, for "Next!"    MsgSW.Clear[d.msgSW];    Put.CR[d.fileSW];  -- blank line to separate from prev text.    IF VMemSize = 0 THEN      {Put.Text[d.fileSW, "ERROR: volume seems to not be booted."L]; GO TO Aborted};    IF d.startPage = 0 THEN      {Put.Line[d.fileSW, "ERROR: can't list vmPages for realPage = 0."L]}    ELSE    FOR realPage: PageNumber IN [d.startPage..d.startPage + d.count) DO      noneFound: BOOLEAN ¬ TRUE;      FOR vmPage: PageNumber IN [0..VMemSize) DO        IF UserInput.UserAbort[wh] THEN AbortMe[];        IF GetRealPage[vmPage] = realPage THEN	  {DisplayPage[vmPage, realPage]; noneFound ¬ FALSE; EXIT};        ENDLOOP;      IF noneFound THEN --this realPage is FREE        BEGIN        Put.Text[d.fileSW, IF d.volume = client	  THEN "client-realPage ="L ELSE " local-realPage ="L];	Put.LongNumber[d.fileSW, realPage, Width[6]];	Put.Text[d.fileSW, " is FREE."L];	Put.CR[d.fileSW];	END;      ENDLOOP;    EXITS Aborted => Put.Line[d.fileSW, " ..aborted."L];    END; --DisplayVMPages  Next: FormSW.ProcType =    BEGIN    tempStart: PageNumber ¬ d.startPage; tempCount: Environment.PageCount ¬ d.count;      BEGIN ENABLE AbortThyself => GO TO Aborted;      MsgSW.Clear[d.msgSW];      d.startPage ¬ d.pageLastDisplayed.SUCC; d.count ¬ 1; -- (sets pageLastDisplayed)      IF realVM = real THEN DisplayRealPages[] ELSE DisplayVMPages[];      d.startPage ¬ tempStart; d.count ¬ tempCount;      EXITS Aborted => Put.Line[d.fileSW, " ..aborted."L];      END; --ENABLE    d.startPage ¬ tempStart; d.count ¬ tempCount;    END;  Prev: FormSW.ProcType =    BEGIN    tempStart: PageNumber ¬ d.startPage; tempCount: Environment.PageCount ¬ d.count;      BEGIN ENABLE AbortThyself => GO TO Aborted;      MsgSW.Clear[d.msgSW];      IF d.pageLastDisplayed > 0 THEN        {d.startPage ¬ d.pageLastDisplayed.PRED; d.count ¬ 1; -- (sets pageLastDisplayed)         IF realVM = real THEN DisplayRealPages[] ELSE DisplayVMPages[]}      ELSE Put.Line[d.fileSW, "Beginning of memory."L];      EXITS Aborted => Put.Line[d.fileSW, " ..aborted."L];      END; --ENABLE    d.startPage ¬ tempStart; d.count ¬ tempCount;    END;      --=======================================================  -- Internal Utility routines:  --=======================================================  DisplayPage: PROCEDURE [vmPage: PageNumber, realPage: PageMap.RealPageNumber] =    BEGIN    --           1         2         3         4         5         6         7    -- 01234567890123456789012345678901234567890123456789012345678901234567890    -- client-vmPage    pppp =       aaaaB­: realPage =    rrr, dirty unrefd readOnly    flags: PageMap.Flags;          Put.Text[d.fileSW,      IF d.volume = client THEN "client-vmPage"L ELSE " local-vmPage"L];    Put.LongNumber[d.fileSW, vmPage, Width[6]];    Put.Text[d.fileSW, " ="L];    Put.LongNumber[      d.fileSW, Environment.LongPointerFromPage[vmPage], WidthOctal[9]];    Put.Text[d.fileSW, "B­:"L];    flags ¬ GetFlags[vmPage];    IF realPage # 0 THEN      BEGIN  --mapped vmPage--      PageOfData: TYPE = [0..Environment.wordsPerPage);      pPage: LONG POINTER TO ARRAY PageOfData OF CARDINAL =        Environment.LongPointerFromPage[vmPage];      Put.Text[d.fileSW, " realPage ="L];      Put.LongNumber[d.fileSW, realPage, Width[6]];      Put.Text[d.fileSW, IF flags.dirty THEN ", dirty"L ELSE ", clean"L];      Put.Text[d.fileSW, IF flags.referenced THEN "  ref'd"L ELSE " unrefd"L];      Put.Text[d.fileSW, IF flags.readonly THEN " readOnly"L ELSE " readWrite"L];      IF d.volume = local AND realVM = real AND d.verbose THEN        FOR word: CARDINAL IN PageOfData DO          IF word MOD 8 = 0 THEN {            Put.CR[d.fileSW];            Put.Number[d.fileSW, word, WidthOctal[4]];            Put.Text[d.fileSW, ":"L]};          Put.Number[d.fileSW, pPage[word], WidthOctal[7]];          ENDLOOP;      Put.CR[d.fileSW];      END;    d.pageLastDisplayed ¬ IF realVM = real THEN vmPage ELSE realPage;    IF UserInput.UserAbort[wh] THEN AbortMe[];    END;          GetRealPage: PROCEDURE [vmPage: Environment.PageNumber]    RETURNS [realPage: PageMap.RealPageNumber] =    BEGIN    IF d.volume = local THEN      BEGIN      IF PageMap.IsMapped[vmPage] THEN RETURN [PageMap.GetState[vmPage].real]      ELSE RETURN[0];      END    ELSE  --d.volume = client--      BEGIN      RETURN[DebugUsefulDefsExtras2.GetPageState[vmPage].real];      END;    END; --GetRealPage--      GetFlags: PROCEDURE [vmPage: Environment.PageNumber]    RETURNS [flags: PageMap.Flags] =    BEGIN    IF d.volume = client THEN      BEGIN      SELECT DebugUsefulDefsExtras2.GetPageState[vmPage].swapState FROM        in => RETURN[DebugUsefulDefsExtras2.GetPageState[vmPage].flags];        out => {Put.Line[d.fileSW, " is swapped out."L]; RETURN[PageMap.flagsVacant]};        unmapped => {Put.Line[d.fileSW, " is unmapped."L];RETURN[PageMap.flagsVacant]};	ENDCASE;      END    ELSE --d.volume = local--      BEGIN      SELECT TRUE FROM        PageMap.IsMapped[vmPage] => RETURN[PageMap.GetState[vmPage].state.flags];        PageMap.IsVacant[vmPage] =>	  {Put.Line[d.fileSW, " is vacant."L];	   RETURN[PageMap.flagsVacant]};	ENDCASE =>	  {Put.Line[d.fileSW, " is *CONFUSED* about swapstate!"L];            RETURN[PageMap.flagsVacant]};      END;    END; --GetFlags--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- MAIN:  Initialize[];  END.LOG-- 28-Sep-84 18:16:30 KEK        Add client-capability, better exec-proc stuff, real-page stuff.-- 17-Feb-86 17:15:38 KEK        add end-of-vm check to DisplayRealPage...-- 17-Mar-87 11:28:20 RSV        Convert to Sword and MDS relief.
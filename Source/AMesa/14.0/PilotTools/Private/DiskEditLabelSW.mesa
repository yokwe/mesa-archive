-- Copyright (C) 1983, 1984, 1985  by Xerox Corporation. All rights reserved. -- DiskEditLabelSW.mesa    21-Nov-85 17:13:11 by RS     DIRECTORY  DiskEditInternal USING [diskLabel, ReplaceUIDString, ValidateUID],  File USING [lastPageNumber],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, FilterProcType,    ItemHandle, LabelItem, LongNumberItem, LongNumberNotifyProcType, MenuProcType,    newLine, nextPlace, NumberItem, NumberNotifyProcType, StringEditProc,    StringItem],  System USING [UniversalID],  UserTerminal USING [BlinkDisplay];DiskEditLabelSW: PROGRAM  IMPORTS DiskEditInternal, FormSW, UserTerminal  EXPORTS DiskEditInternal =  BEGIN    PilotDiskAddress: TYPE = RECORD [a, b: CARDINAL];  label: MACHINE DEPENDENT RECORD [    fileIDString(0): LONG STRING ¬ NIL,    filePageNumber(2): LONG CARDINAL ¬ 0,    pad1(4): CARDINAL ¬ 0,    pad2(5): CARDINAL ¬ 0,    temporary(6:0..15): BOOLEAN ¬ FALSE];  CleanupLabelSW: PUBLIC PROCEDURE =    BEGIN    filePageNumber: MACHINE DEPENDENT RECORD [      filePageLo(0): CARDINAL,      filePageHi(1:0..6): [0..128),      pad(1:7..15): [0..0]];    pad1: MACHINE DEPENDENT RECORD [a(0:0..8): [0..0], pad1(0:9..15): [0..128)];    pad2: MACHINE DEPENDENT RECORD [a(0:0..14): [0..0], pad2(0:15..15): [0..2)];    pad1 ¬ LOOPHOLE[label.pad1];    pad2 ¬ LOOPHOLE[label.pad2];    filePageNumber ¬ LOOPHOLE[label.filePageNumber];    DiskEditInternal.diskLabel.filePageLo ¬ filePageNumber.filePageLo;    DiskEditInternal.diskLabel.filePageHi ¬ filePageNumber.filePageHi;    DiskEditInternal.diskLabel.pad1 ¬ pad1.pad1;    DiskEditInternal.diskLabel.pad2 ¬ pad2.pad2;    DiskEditInternal.diskLabel.temporary ¬ label.temporary;    END;  FillLabelSW: PUBLIC PROCEDURE =    BEGIN    file: System.UniversalID ¬ LOOPHOLE[DiskEditInternal.diskLabel.fileID];    label.filePageNumber ¬      LONG[LAST[CARDINAL]]*DiskEditInternal.diskLabel.filePageHi + LONG[        DiskEditInternal.diskLabel.filePageLo];    DiskEditInternal.ReplaceUIDString[      @label.fileIDString, file];    label.pad1 ¬ DiskEditInternal.diskLabel.pad1;    label.pad2 ¬ DiskEditInternal.diskLabel.pad2;    label.temporary ¬ DiskEditInternal.diskLabel.temporary;    END;  MakeLabelSW: PUBLIC FormSW.ClientItemsProcType =    BEGIN    bootChainLink: LONG POINTER TO PilotDiskAddress = LOOPHOLE[@DiskEditInternal.diskLabel.bootChainLink];    i: CARDINAL ¬ 0;    nItems: CARDINAL = 11;    items ¬ FormSW.AllocateItemDescriptor[nItems];    items[0] ¬ FormSW.LabelItem[tag: NIL, invisible: TRUE, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LabelItem[tag: "Label"L, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.StringItem[      tag: "File ID"L, inHeap: TRUE, string: @label.fileIDString,      filterProc: ValidateLabelFileID, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.LongNumberItem[      tag: "File Page Number"L, signed: FALSE, notNegative: TRUE, default: 0,      radix: decimal, value: @label.filePageNumber,      proc: ValidateLabelFilePageNumber, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "File type"L, signed: FALSE, notNegative: TRUE, default: 0,      radix: decimal, value: @DiskEditInternal.diskLabel.type,      place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.BooleanItem[      tag: "temporary"L, switch: @label.temporary, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Pad 1"L, signed: FALSE, notNegative: TRUE, default: 0, radix: decimal,      value: @label.pad1, proc: ValidateLabelPad1, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "Pad 2"L, signed: FALSE, notNegative: TRUE, default: 0, radix: decimal,      value: @label.pad2, proc: ValidateLabelPad2, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.LabelItem[tag: "Boot link"L, place: FormSW.newLine];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "a"L, signed: FALSE, notNegative: TRUE, default: 0, radix: decimal,      value: @bootChainLink.a, place: FormSW.nextPlace];    items[i ¬ i + 1] ¬ FormSW.NumberItem[      tag: "b"L, signed: FALSE, notNegative: TRUE, default: 0, radix: decimal,      value: @bootChainLink.b, place: FormSW.nextPlace];        IF i ~= nItems - 1 THEN ERROR;  -- indicates that items is incompletely initialized    RETURN[items, TRUE]    END;  ValidateLabelFileID: FormSW.FilterProcType =    BEGIN    id: System.UniversalID;    valid: BOOLEAN;    FormSW.StringEditProc[sw, item, insert, string];    [valid, id] ¬ DiskEditInternal.ValidateUID[label.fileIDString];    IF ~valid THEN UserTerminal.BlinkDisplay[]    ELSE DiskEditInternal.diskLabel.fileID ¬ LOOPHOLE[id];    END;  ValidateLabelPad1: FormSW.NumberNotifyProcType =    BEGIN IF label.pad1 ~IN [0..128) THEN UserTerminal.BlinkDisplay[]; END;    ValidateLabelPad2: FormSW.NumberNotifyProcType =    BEGIN IF label.pad2 ~IN [0..2) THEN UserTerminal.BlinkDisplay[]; END;  ValidateLabelFilePageNumber: FormSW.LongNumberNotifyProcType =    BEGIN    IF label.filePageNumber ~IN [0..File.lastPageNumber] THEN      UserTerminal.BlinkDisplay[];    END;  END.LOG 3-Sep-81 10:16:20   WDK       LONGified.  Converted to opaque Label and Address21-Apr-83 14:45:41   EKN       Update to Klamath 29-Nov-83 16:49:57   EKN       Changed (long) number items in label to be displayed as decimal instead of octal.21-Nov-85 17:13:21   RSV       Added pad2 support (AR 6856)
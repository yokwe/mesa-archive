-- Copyright (C) 1982, 1985  by Xerox Corporation. All rights reserved. --  ByteBltTest.mesa, last edited by:   RSV on  4-Dec-85 12:43:08DIRECTORY  Ascii USING [CR],  ByteBlt USING [ByteBlt, OverLapOption, StartIndexGreaterThanStopIndexPlusOne],  Environment USING [Block, Byte, nullBlock],  Exec USING [AddCommand, CheckForAbort, ExecProc, GetTTY, ReleaseTTY],  Heap USING [systemZone],  Inline USING [LowByte],  Process USING [Yield],  TTY USING [Handle, PutChar, PutDecimal, PutLine, PutLongDecimal, PutString];ByteBltTest: PROGRAM  IMPORTS ByteBlt, Exec, Heap, Inline, Process, TTY =  BEGIN  sizeTestArray: CARDINAL = 20;  TestArrayDescriptor: TYPE = LONG DESCRIPTOR FOR PACKED ARRAY OF Environment.Byte;  ActualTestArray: TYPE = PACKED ARRAY [0..sizeTestArray) OF Environment.Byte;  test, control, work: TestArrayDescriptor;    z: UNCOUNTED ZONE = Heap.systemZone;    TestResult: TYPE = {ok, wrongReturn, wrongMove, wrongError, aborted};  FillArrays: PROCEDURE =    BEGIN    FOR i: CARDINAL IN [0.. sizeTestArray) DO      test[i] ¬ control[i] ¬ Inline.LowByte[i];      ENDLOOP;    END;  SeeIfOK: PROCEDURE RETURNS [i: CARDINAL] =    BEGIN    FOR i: CARDINAL IN [0.. sizeTestArray) DO      IF test[i] # control[i] THEN RETURN [i];      ENDLOOP;    RETURN [sizeTestArray+1];    END;  SafeByteBlt: PROCEDURE [    to, from: Environment.Block, overLap: ByteBlt.OverLapOption]    RETURNS [nBytes: CARDINAL] =    BEGIN    i: CARDINAL ¬ from.startIndex;    j: CARDINAL ¬ to.startIndex;    amount: CARDINAL = MIN[      from.stopIndexPlusOne-from.startIndex, to.stopIndexPlusOne-to.startIndex];    IF from.stopIndexPlusOne < from.startIndex      OR to.stopIndexPlusOne < to.startIndex      THEN ERROR ByteBlt.StartIndexGreaterThanStopIndexPlusOne;    SELECT overLap FROM      ripple => THROUGH [0.. amount) DO        to.blockPointer[j] ¬ from.blockPointer[i];        i ¬ i+1; j ¬ j+1;        ENDLOOP;      move => BEGIN        THROUGH [0.. amount) DO          work[j] ¬ from.blockPointer[i];          i ¬ i+1; j ¬ j+1;          ENDLOOP;        j ¬ to.startIndex;        THROUGH [0.. amount) DO          to.blockPointer[j] ¬ work[j];          j ¬ j+1;          ENDLOOP;        END;      ENDCASE;    RETURN [amount];    END;  Test: PROCEDURE [Abort: PROCEDURE RETURNS [BOOLEAN]] RETURNS [    answer: TestResult, overLap: ByteBlt.OverLapOption, index: CARDINAL,    source, sink: Environment.Block, testCase: LONG CARDINAL] =    BEGIN    check, result, controlResult: CARDINAL;    controlSource, controlSink: Environment.Block;    testCase ¬ 0;      FOR toStart: CARDINAL IN [0.. sizeTestArray) DO        FOR toStopPlus1: CARDINAL IN [toStart.. sizeTestArray) DO          FOR fromStart: CARDINAL IN [0.. sizeTestArray) DO	    IF Abort[] THEN GOTO aborted;	    Process.Yield[];            FOR fromStopPlus1: CARDINAL IN [fromStart.. sizeTestArray) DO              source ¬ [LOOPHOLE[BASE[test]], fromStart, fromStopPlus1];              sink ¬ [LOOPHOLE[BASE[test]], toStart, toStopPlus1];              controlSource ¬ [LOOPHOLE[BASE[control]], fromStart, fromStopPlus1];              controlSink ¬ [LOOPHOLE[BASE[control]], toStart, toStopPlus1];              FOR overLap IN [ripple.. move] DO                testCase ¬ testCase+1;                FillArrays[];                result ¬ ByteBlt.ByteBlt[sink, source, overLap !                  ByteBlt.StartIndexGreaterThanStopIndexPlusOne => GOTO error];                controlResult ¬ SafeByteBlt[controlSink, controlSource, overLap];                check ¬ SeeIfOK[];                IF check # sizeTestArray+1 THEN                   RETURN[wrongMove, overLap, check, source, sink, testCase];                IF result # controlResult THEN                   RETURN[		     wrongReturn, overLap, sizeTestArray+1, source, sink,		     testCase];                ENDLOOP;              ENDLOOP;            ENDLOOP;        ENDLOOP;      ENDLOOP;    RETURN [      ok, overLap, sizeTestArray+1, Environment.nullBlock, Environment.nullBlock,      testCase];    EXITS      error =>             RETURN [wrongError, overLap, sizeTestArray+1, source, sink, testCase];      aborted => RETURN [        aborted, overLap, sizeTestArray+1, Environment.nullBlock,         Environment.nullBlock, testCase];    END;  DoTest: Exec.ExecProc =    BEGIN    Abort: PROCEDURE RETURNS [BOOLEAN] = {RETURN[Exec.CheckForAbort[h]]};    result: TestResult;    index: CARDINAL;    testCase: LONG CARDINAL;    overLap: ByteBlt.OverLapOption;    source, sink: Environment.Block;    tty: TTY.Handle ¬ Exec.GetTTY[h];    test ¬ DESCRIPTOR[z.NEW[ActualTestArray], sizeTestArray];    control ¬ DESCRIPTOR[z.NEW[ActualTestArray], sizeTestArray];    work ¬ DESCRIPTOR[z.NEW[ActualTestArray], sizeTestArray];    TTY.PutLine[tty, "ByteBlt Test..."L];    [result, overLap, index, source, sink, testCase] ¬ Test[Abort];    SELECT result FROM      aborted => TTY.PutLine[tty, "Aborted before any problems found"L];      ok => TTY.PutLine[tty, "No problems found"L];      wrongReturn => TTY.PutLine[tty, "Returned nByte wrong!"L];      wrongMove =>         BEGIN	TTY.PutString[tty, "Failed on test case "L];	TTY.PutLongDecimal[tty, testCase];	TTY.PutChar[tty, Ascii.CR];        IF overLap = ripple THEN TTY.PutString[tty, "Rippled move ["L]        ELSE TTY.PutString[tty, "Move ["L];        TTY.PutDecimal[tty, source.startIndex];        TTY.PutString[tty, ".. "L];        TTY.PutDecimal[tty, source.stopIndexPlusOne];        TTY.PutString[tty, ") => ["L];        TTY.PutDecimal[tty, sink.startIndex];        TTY.PutString[tty, ".. "L];        TTY.PutDecimal[tty, sink.stopIndexPlusOne];        TTY.PutString[tty, ") => ("L];        TTY.PutLine[tty, " done wrong!"L];        END;      wrongError =>  TTY.PutLine[        tty, "Raised StartIndexGreaterThanStopIndexPlusOne!"L];      ENDCASE;    Exec.ReleaseTTY[tty];    z.FREE[@test.BASE];    z.FREE[@control.BASE];    z.FREE[@work.BASE];    END;  Exec.AddCommand["ByteBltTest.~", DoTest];  END.  LOGAWL  22-Feb-82 15:32:33KAM  19-Feb-82 17:19:14RSV   4-Dec-85 15:25:59  Created log.  Moved off of Storage and use Heap instead (AR 6359)
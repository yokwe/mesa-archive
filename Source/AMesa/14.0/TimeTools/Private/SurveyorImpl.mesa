-- File: SurveyorImpl.mesa - last edit:-- AOF                 25-Feb-87 13:28:18-- kam                 16-Dec-85 11:40:26-- Copyright (C) 1985, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  NSBuffer USING [Body, Buffer],  NSConstants USING [timeServerSocket],  PacketExchange USING [ExchangeClientType],  Real USING [FDiv, Fix, RealError, RealException],  Router USING [GetDelayToNet, NoTableEntryForNet],  Socket USING [    ChannelHandle, Create, Delete, GetPacket,    GetSendBuffer, PutPacket, ReturnBuffer, SetPacketWords, SetWaitTime,    TimeOut],  System USING [    broadcastHostNumber, GetClockPulses, GetGreenwichMeanTime,    GreenwichMeanTime, NetworkAddress, nullSocketNumber, Pulses,     PulsesToMicroseconds, SecondsSinceEpoch],  TimeServerFormat USING [TSPacket, Version, WireToGMT, WireToLong],  TimeServiceToolOps USING [    AccessProc, ServerInfo, ServerInfoRecord, SurveyorInfo, zone];SurveyorImpl: MONITOR LOCKS server USING server: TimeServiceToolOps.ServerInfo  IMPORTS Real, Router, Socket, System, TimeServiceToolOps, TimeServerFormat  EXPORTS TimeServiceToolOps =  BEGIN  z: UNCOUNTED ZONE = TimeServiceToolOps.zone;  AccessProc: TYPE = TimeServiceToolOps.AccessProc;  triesForInternalTimeResponse: CARDINAL = 1;  triesForTimeResponse: CARDINAL = 3;  CalculateRelativeRate: PUBLIC PROCEDURE [item: TimeServiceToolOps.ServerInfo]    RETURNS [low, high: LONG INTEGER] =    << Calculates an interval in which the negative of the rate of the local    clock as compared to a standard must lie if the remote clock is valid.    These funny units give an "intuitive" meaning to the interval - i.e.,    if the remote clock is twice the rate of the local clock, this will calculate    an interval around the value one (100% fast). The rates are calculated    in terms of microseconds/second >>    BEGIN    ENABLE {Real.RealException => RESUME[vp]; Real.RealError => GOTO Error};    drift: REAL = Real.FDiv[1000000, 86400];  -- in microseconds/second    delI: REAL =       System.SecondsSinceEpoch[item.at] - System.SecondsSinceEpoch[item.baseAt];    delJ: REAL = item.offset - item.base + delI;    realLow, realHigh: REAL;    IF NOT item.validRateInfo OR delI = 0 THEN      RETURN[FIRST[LONG INTEGER], LAST[LONG INTEGER]];    realLow ¬ realHigh ¬ delJ/delI * 1D6;    realLow ¬ realLow -      (delJ * drift + (1D6 + drift) * (item.baseDelay + 2000) / 1D3) / delI;    realHigh ¬ realHigh +       (delJ * drift + (1D6 + 3 * drift) * (item.delay + 2000) / 1D3) / delI;    RETURN[Real.Fix[realLow] - 1D6, Real.Fix[realHigh] - 1D6];    EXITS Error => RETURN[FIRST[LONG INTEGER], LAST[LONG INTEGER]];    END;  CollectStatsInformation: PROCEDURE [    info: TimeServiceToolOps.SurveyorInfo, socket: Socket.ChannelHandle] =    BEGIN    b: NSBuffer.Buffer;    body: NSBuffer.Body;    req: LONG POINTER TO statisticRequest TimeServerFormat.TSPacket;    rep: LONG POINTER TO statisticResponse TimeServerFormat.TSPacket;    Access: INTERNAL AccessProc =      BEGIN      resetOn: System.GreenwichMeanTime = TimeServerFormat.WireToGMT[        rep.timeSet];      server.numberRequests ¬ TimeServerFormat.WireToLong[rep.numberRequests];      server.active ¬ rep.active;      server.resetting ¬ rep.resetting;      IF resetOn # server.resetOn THEN {        server.resetOn ¬ resetOn; server.validRateInfo ¬ FALSE};      server.resetBy ¬ TimeServerFormat.WireToLong[rep.lastChange];      server.resetUsing ¬ rep.source;      server.gen ¬ info.gen;      END;    THROUGH [0..3) DO      body ¬ (b ¬ Socket.GetSendBuffer[socket]).ns;      req ¬ LOOPHOLE[@body.exchangeBody];      body.packetType ¬ packetExchange;      body.exchangeType ¬ PacketExchange.ExchangeClientType[timeService];      body.destination ¬ [        info.net, System.broadcastHostNumber, NSConstants.timeServerSocket];      Socket.SetPacketWords[        b, 3 + SIZE[statisticRequest TimeServerFormat.TSPacket]];      req^ ¬ [version: TimeServerFormat.Version, tsBody: statisticRequest[]];      Socket.PutPacket[socket, b];      DO        b ¬ Socket.GetPacket[socket ! Socket.TimeOut => EXIT];        rep ¬ LOOPHOLE[@body.exchangeBody];        GetServerInfo[info, body.source, Access];        Socket.ReturnBuffer[b];        ENDLOOP;      ENDLOOP;    END;  CollectTimeInformation: PROCEDURE [    info: TimeServiceToolOps.SurveyorInfo, socket: Socket.ChannelHandle] =    BEGIN    b: NSBuffer.Buffer;    body: NSBuffer.Body;    req: LONG POINTER TO timeRequest TimeServerFormat.TSPacket;    rep: LONG POINTER TO timeResponse TimeServerFormat.TSPacket;    iReq: LONG POINTER TO internalTimeRequest TimeServerFormat.TSPacket;    iRep: LONG POINTER TO internalTimeResponse TimeServerFormat.TSPacket;    delay: LONG CARDINAL;    GetResponse: INTERNAL AccessProc =      BEGIN      server.timeAvailable ¬ TRUE;      server.offset ¬        System.SecondsSinceEpoch[TimeServerFormat.WireToGMT[rep.time]] - Now[];      server.at ¬ System.GetGreenwichMeanTime[];      server.errorAccurate ¬ rep.errorAccurate;      server.error ¬ TimeServerFormat.WireToLong[rep.absoluteError];      server.delay ¬ (delay + 500) / 1000;      server.hasVersion ¬ FALSE;      server.gen ¬ info.gen;      IF NOT server.validRateInfo THEN FillRateInfo[server];      END;    GetInternalResponse: INTERNAL AccessProc =      BEGIN      server.timeAvailable ¬ TRUE;      server.offset ¬        System.SecondsSinceEpoch[TimeServerFormat.WireToGMT[iRep.time]] - Now[];      server.at ¬ System.GetGreenwichMeanTime[];      server.error ¬ TimeServerFormat.WireToLong[iRep.absoluteError];      server.errorAccurate ¬ server.error # LAST[LONG CARDINAL];      server.delay ¬ (delay + 500) / 1000;      server.hasVersion ¬ TRUE;      server.version ¬ TimeServerFormat.WireToLong[iRep.timeVersion];      server.gen ¬ info.gen;      IF NOT server.validRateInfo THEN FillRateInfo[server];      END;    FillRateInfo: INTERNAL AccessProc =      BEGIN      server.validRateInfo ¬ TRUE;      server.baseAt ¬ server.at;      server.base ¬ server.offset;      server.baseDelay ¬ server.delay;      END;    Send: INTERNAL AccessProc =      BEGIN      sent: System.Pulses;      gotOne: BOOLEAN ¬ FALSE;      FOR try: CARDINAL IN        [0..triesForInternalTimeResponse + triesForTimeResponse) UNTIL gotOne DO        sent ¬ System.GetClockPulses[];        (IF try < triesForInternalTimeResponse THEN SendInternalRequest         ELSE SendRequest)[server];        b ¬ Socket.GetPacket[socket ! Socket.TimeOut => LOOP];        delay ¬ System.PulsesToMicroseconds[[System.GetClockPulses[] - sent]];        WITH        reply: LOOPHOLE[@body.exchangeBody, LONG POINTER TO          TimeServerFormat.TSPacket]^ SELECT FROM          timeResponse => {rep ¬ @reply; GetResponse[server]; gotOne ¬ TRUE};          internalTimeResponse => {            iRep ¬ @reply; GetInternalResponse[server]; gotOne ¬ TRUE};          ENDCASE;        Socket.ReturnBuffer[b];        ENDLOOP;      END;    SendInternalRequest: INTERNAL AccessProc =      BEGIN      body ¬ (b ¬ Socket.GetSendBuffer[socket]).ns;      iReq ¬ LOOPHOLE[@body.exchangeBody];      body.packetType ¬ packetExchange;      body.exchangeType ¬ PacketExchange.ExchangeClientType[timeService];      body.destination ¬ server.who;      Socket.SetPacketWords[        b, 3 + SIZE[internalTimeRequest TimeServerFormat.TSPacket]];      iReq^ ¬ [        version: TimeServerFormat.Version, tsBody: internalTimeRequest[]];      Socket.PutPacket[socket, b];      END;    SendRequest: INTERNAL AccessProc =      BEGIN      body ¬ (b ¬ Socket.GetSendBuffer[socket]).ns;      req ¬ LOOPHOLE[@body.exchangeBody];      body.packetType ¬ packetExchange;      body.exchangeType ¬ PacketExchange.ExchangeClientType[timeService];      body.destination ¬ server.who;      Socket.SetPacketWords[b, 3 + SIZE[timeRequest TimeServerFormat.TSPacket]];      req^ ¬ [version: TimeServerFormat.Version, tsBody: timeRequest[]];      Socket.PutPacket[socket, b];      END;    EnumerateServerInfo[info, Send, 0];    END;  EnumerateServerInfo: PUBLIC PROCEDURE [    info: TimeServiceToolOps.SurveyorInfo, access: AccessProc, trim: CARDINAL] =    BEGIN    s: TimeServiceToolOps.ServerInfo ¬ info.first;    CallWithThisOne: ENTRY PROCEDURE [server: TimeServiceToolOps.ServerInfo]      RETURNS [next: TimeServiceToolOps.ServerInfo] =      BEGIN      ENABLE UNWIND => NULL;      IF trim = 0 OR info.gen < server.gen + trim THEN access[server];      RETURN[server.next];      END;    UNTIL s = NIL DO s ¬ CallWithThisOne[s] ENDLOOP;    END;  --  Calls access with the appropriate server information record locked  GetServerInfo: PUBLIC PROCEDURE [    info: TimeServiceToolOps.SurveyorInfo, who: System.NetworkAddress,    access: AccessProc] =    BEGIN    CallWithThisOne: ENTRY PROCEDURE [server: TimeServiceToolOps.ServerInfo] = {      ENABLE UNWIND => NULL; access[server]};    CheckThisOne: ENTRY PROCEDURE [server: TimeServiceToolOps.ServerInfo]      RETURNS [called: BOOLEAN] =      BEGIN      ENABLE UNWIND => NULL;      IF server.who.host = who.host THEN {access[server]; RETURN[TRUE]}      ELSE RETURN[FALSE];      END;    MakeOne: PROCEDURE RETURNS [server: TimeServiceToolOps.ServerInfo] =      BEGIN      server ¬ z.NEW[TimeServiceToolOps.ServerInfoRecord ¬ [who: who]];      server.who.net ¬ info.net;      RETURN[server];      END;    Next: ENTRY PROCEDURE [server: TimeServiceToolOps.ServerInfo]      RETURNS [TimeServiceToolOps.ServerInfo] = {      ENABLE UNWIND => NULL; RETURN[server.next]};    SetNext: ENTRY PROCEDURE [server, next: TimeServiceToolOps.ServerInfo] = {      ENABLE UNWIND => NULL; server.next ¬ next};    IF info.first = NIL THEN CallWithThisOne[info.first ¬ MakeOne[]]    ELSE      FOR s: TimeServiceToolOps.ServerInfo ¬ info.first, Next[s] DO        IF CheckThisOne[s] THEN EXIT;        IF Next[s] = NIL THEN {          SetNext[s, MakeOne[]]; CallWithThisOne[Next[s]]; EXIT};        ENDLOOP;    END;  Now: PROCEDURE RETURNS [LONG CARDINAL] = {    RETURN[System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]]]};  Survey: PUBLIC PROCEDURE [info: TimeServiceToolOps.SurveyorInfo] =    BEGIN    socket: Socket.ChannelHandle;    Delay: PROCEDURE RETURNS [CARDINAL] =      BEGIN      hops: CARDINAL = Router.GetDelayToNet[info.net];      RETURN[(IF hops < 3 THEN 3 ELSE 3 + (hops - 3)) * 1000];      END;    Socket.SetWaitTime[      socket ¬ Socket.Create[System.nullSocketNumber, 1, 5], Delay[      ! Router.NoTableEntryForNet => GOTO NoSuchNet]];    BEGIN    ENABLE ABORTED => GOTO Aborted;    CollectStatsInformation[info, socket];    CollectTimeInformation[info, socket];    EXITS Aborted => NULL;    END;    Socket.Delete[socket];    EXITS NoSuchNet => NULL;    END;  END...
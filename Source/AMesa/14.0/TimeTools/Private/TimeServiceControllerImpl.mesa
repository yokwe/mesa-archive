-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.-- TimeServiceControllerImpl.mesa, last edited by:-- KAM		 4-Mar-85 19:59:29DIRECTORY  AddressTranslation USING [Error, NetworkAddress, StringToNetworkAddress],  Ascii USING [CR, NUL],  Auth USING [IdentityHandle],  CmFile USING [Error, FreeString, UserDotCmLine],  Environment USING [bytesPerPage, PageCount],  Format USING [    Char, CR, Date, Decimal, LongDecimal, LongNumber, NetworkAddress, StringProc],  Heap USING [systemZone],  Inline USING [UDDivMod],  MFile USING [AddNotifyProc, NotifyProc],  MStream USING [    Error, GetLength, Handle, Log, PleaseReleaseProc, ReadOnly, SetLogReadLength],  Process USING [Detach, SecondsToTicks, SetTimeout],  Profile USING [GetID],  Stream USING [Delete, EndOfStream, GetChar, GetPosition, PutString],  String USING [    Equivalent, InvalidNumber, Length, StringToDecimal, StringToLongNumber],  System USING [    GetGreenwichMeanTime, gmtEpoch, GreenwichMeanTime, NetworkAddress,    nullNetworkAddress, SecondsSinceEpoch],  Time USING [Current],  TimeServiceStub USING [Reset, Stop],  Token USING [    FilterProcType, FreeTokenString, GetCharProcType, MaybeQuoted, Object,    Skip, UnterminatedQuote];TimeServiceControllerImpl: MONITOR  IMPORTS    AddressTranslation, CmFile, Format, Heap, Inline, MFile, MStream,    Process, Profile, Stream, String, System, Time, TimeServiceStub, Token =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;  tasks: Task ¬ NIL;  log: MStream.Handle;  minPause: CARDINAL ¬ 300;  -- seconds --  pause: CONDITION;  maxPagesInLog: Environment.PageCount ¬ 100;  Action: TYPE = {reset, stop};  Task: TYPE = LONG POINTER TO TaskRecord;  TaskRecord: TYPE = RECORD [    who: System.NetworkAddress ¬ System.nullNetworkAddress,    next: Task ¬ NIL,    period: LONG CARDINAL ¬ 0,    last: System.GreenwichMeanTime ¬ System.gmtEpoch,    var: SELECT action: Action FROM      reset => [from: System.NetworkAddress ¬ System.nullNetworkAddress],      stop => NULL,      ENDCASE];  DoTasks: ENTRY PROCEDURE =    BEGIN    DO      FOR task: Task ¬ tasks, task.next UNTIL task = NIL DO        now: System.GreenwichMeanTime = System.GetGreenwichMeanTime[];        IF System.SecondsSinceEpoch[now] - System.SecondsSinceEpoch[task.last] <          task.period THEN LOOP;        task.last ¬ now;        WITH t: task SELECT FROM          reset => Reset[task.who, t.from];          stop => Stop[task.who];          ENDCASE;        ENDLOOP;      WAIT pause;      ENDLOOP;    END;  FreeTasks: INTERNAL PROCEDURE =    BEGIN    UNTIL tasks = NIL DO      next: Task ¬ tasks.next; z.FREE[@tasks]; tasks ¬ next ENDLOOP;    END;  ProcessCommandFile: ENTRY PROCEDURE =    BEGIN    sH: MStream.Handle;    t: Token.Object ¬ [GetChar, Ascii.NUL];    SyntaxError: ERROR = CODE;    EndOfFile: ERROR = CODE;    auth: Auth.IdentityHandle;    GetID: PROCEDURE [id: Auth.IdentityHandle] = {auth ¬ id};    GetAction: PROCEDURE RETURNS [action: Action, who: System.NetworkAddress] =      BEGIN      token: LONG STRING ¬ NIL;      BEGIN      ENABLE UNWIND => IF token # NIL THEN [] ¬ Token.FreeTokenString[token];      token ¬ Token.MaybeQuoted[        @t, NIL !        Token.UnterminatedQuote => {          LogError["Missing quote"L, 1]; ERROR EndOfFile}];      IF String.Length[token] = 0 THEN ERROR EndOfFile;      SELECT TRUE FROM        String.Equivalent[token, "Reset"L] => action ¬ reset;        String.Equivalent[token, "Stop"L] => action ¬ stop;        String.Equivalent[token, "--"L] => ERROR SyntaxError;        ENDCASE => {          Log["Unknown action "L];          LogError[token, token.length];          ERROR SyntaxError};      [] ¬ Token.FreeTokenString[token];      token ¬ Token.MaybeQuoted[        @t, NIL !        Token.UnterminatedQuote => {          LogError["Missing quote"L, 1]; ERROR SyntaxError}];      IF String.Length[token] = 0 THEN {        LogError["Missing network address"L, 1]; ERROR SyntaxError};      who ¬ AddressTranslation.StringToNetworkAddress[        token, auth !        AddressTranslation.Error => {          LogError["Illegal or unknown host address"L, token.length];          ERROR SyntaxError}].addr;      [] ¬ Token.FreeTokenString[token];      END;      END;    GetFrom: PROCEDURE RETURNS [who: System.NetworkAddress] =      BEGIN      token: LONG STRING ¬ NIL;      BEGIN      ENABLE UNWIND => IF token # NIL THEN [] ¬ Token.FreeTokenString[token];      token ¬ Token.MaybeQuoted[        @t, NIL !        Token.UnterminatedQuote => {          LogError["Missing quote"L, 1]; ERROR SyntaxError}];      IF String.Length[token] = 0 OR NOT String.Equivalent[token, "From"L] THEN        {Log["Missing from field "L]; LogError[token, 1]; ERROR SyntaxError};      [] ¬ Token.FreeTokenString[token];      token ¬ Token.MaybeQuoted[        @t, NIL !        Token.UnterminatedQuote => {          LogError["Missing quote"L, 1]; ERROR SyntaxError}];      IF String.Length[token] = 0 THEN {        LogError["Missing network address"L, 1]; ERROR SyntaxError};      who ¬ AddressTranslation.StringToNetworkAddress[        token, auth !        AddressTranslation.Error => {          LogError["Illegal or unknown host address"L, token.length];          ERROR SyntaxError}].addr;      [] ¬ Token.FreeTokenString[token];      END;      END;    GetPeriod: PROCEDURE RETURNS [period: LONG CARDINAL] =      BEGIN      token: LONG STRING ¬ NIL;      noValue: BOOLEAN ¬ FALSE;      BEGIN      ENABLE UNWIND => IF token # NIL THEN [] ¬ Token.FreeTokenString[token];      token ¬ Token.MaybeQuoted[        @t, NIL !        Token.UnterminatedQuote => {          LogError["Missing quote"L, 1]; ERROR SyntaxError}];      IF String.Length[token] = 0 OR NOT String.Equivalent[token, "Every"L] THEN        {Log["Missing period field "L]; LogError[token, 1]; ERROR SyntaxError};      [] ¬ Token.FreeTokenString[token];      token ¬ Token.MaybeQuoted[        @t, NIL !        Token.UnterminatedQuote => {          LogError["Missing quote"L, 1]; ERROR SyntaxError}];      period ¬ String.StringToLongNumber[        token ! String.InvalidNumber => {period ¬ 1; noValue ¬ TRUE; CONTINUE}];      IF NOT noValue THEN {        [] ¬ Token.FreeTokenString[token];        token ¬ Token.MaybeQuoted[          @t, NIL !          Token.UnterminatedQuote => {            LogError["Missing quote"L, 1]; ERROR SyntaxError}]};      IF String.Length[token] = 0 THEN {        LogError["Missing time units"L, 1]; ERROR SyntaxError};      SELECT TRUE FROM        Prefix[token, "seconds"L] => NULL;        Prefix[token, "minutes"L] => period ¬ period * 60;        Prefix[token, "hours"L] => period ¬ period * 3600;        Prefix[token, "days"L] => period ¬ period * 86400;        ENDCASE => {          Log["Unknown time units "L];          LogError[token, token.length];          ERROR SyntaxError};      period ¬ MAX[period, minPause];      [] ¬ Token.FreeTokenString[token];      END;      END;    GetChar: Token.GetCharProcType = {      c ¬ sH.GetChar[ ! Stream.EndOfStream => {c ¬ Ascii.NUL; CONTINUE}]};    LogError: PROCEDURE [s: LONG STRING, back: CARDINAL] =      BEGIN      Log[s];      Log[" at position "L];      Format.LongDecimal[Log, sH.GetPosition[] - back - 1];      Format.CR[Log];      END;    Prefix: PROCEDURE [prefix, value: LONG STRING] RETURNS [BOOLEAN] =      BEGIN      IF prefix.length > value.length THEN RETURN[FALSE];      FOR i: CARDINAL IN [0..prefix.length) DO        IF prefix[i] # value[i] THEN RETURN[FALSE] ENDLOOP;      RETURN[TRUE];      END;    CR: Token.FilterProcType = {RETURN[c # Ascii.CR AND c # Ascii.NUL]};    lastTask: Task ¬ NIL;    Profile.GetID[strong, GetID];    sH ¬ MStream.ReadOnly[      "TimeServiceController.txt"L, [] ! MStream.Error => GOTO NoParameters];    FreeTasks[];    Log["\nNew command file at "L];    Format.Date[Log, Time.Current[], full];    Log[":\n"L];    DO      ENABLE {        SyntaxError => {Token.Skip[@t, NIL, CR]; LOOP}; EndOfFile => EXIT};      period: LONG CARDINAL ¬ 0;      action: Action ¬ stop;      task: Task ¬ NIL;      who, from: System.NetworkAddress ¬ System.nullNetworkAddress;      [action, who] ¬ GetAction[];      IF action = reset THEN from ¬ GetFrom[];      period ¬ GetPeriod[];      task ¬        IF action = stop THEN z.NEW[        TaskRecord ¬ [who, NIL, period, System.gmtEpoch, stop[]]]        ELSE z.NEW[          TaskRecord ¬ [who, NIL, period, System.gmtEpoch, reset[from]]];      IF lastTask = NIL THEN tasks ¬ task ELSE lastTask.next ¬ task;      lastTask ¬ task;      ENDLOOP;    sH.Delete[];    PrintTaskList[];    NOTIFY pause;    EXITS NoParameters => Log["Could no acquire TimeServiceController.txt\n"L];    END;  PrintTaskList: INTERNAL PROCEDURE =    BEGIN    IF tasks = NIL THEN Log["No valid commands found\n"L]    ELSE      FOR task: Task ¬ tasks, task.next UNTIL task = NIL DO        Format.NetworkAddress[Log, task.who, octal];        Log[" will be "L];        WITH t: task SELECT FROM          reset => {            Log["reset from "L]; Format.NetworkAddress[Log, t.from, octal]};          stop => Log["stopped"L];          ENDCASE;        Log[" every "L];        SELECT TRUE FROM          task.period = 1 => Log["second"L];          task.period = 60 => Log["minute"L];          task.period = 3600 => Log["hour"L];          task.period = 86400 => Log["day"L];          ENDCASE =>            BEGIN            first: BOOLEAN ¬ TRUE;            q, r: LONG CARDINAL;            [q, r] ¬ Inline.UDDivMod[task.period, 86400];            IF q # 0 THEN {              first ¬ FALSE; Format.LongNumber[Log, q, [10, FALSE, TRUE, 0]]};            [q, r] ¬ Inline.UDDivMod[r, 3600];            IF q # 0 OR NOT first THEN {              IF NOT first THEN {                Format.Char[Log, ':];                Format.LongNumber[Log, q, [10, TRUE, TRUE, 2]]}              ELSE {                first ¬ FALSE;                Format.LongNumber[Log, q, [10, FALSE, TRUE, 0]]}};            [q, r] ¬ Inline.UDDivMod[r, 60];            IF NOT first THEN Format.Char[Log, ':];            Format.LongNumber[Log, q, [10, TRUE, TRUE, 2]];            Format.Char[Log, ':];            Format.LongNumber[Log, r, [10, TRUE, TRUE, 2]];            END;        Format.CR[Log];        ENDLOOP;    Format.CR[Log];    END;  Reset: PROCEDURE [who, from: System.NetworkAddress] =    BEGIN    ok: BOOLEAN = TimeServiceStub.Reset[who, from, 3];    Format.NetworkAddress[Log, who, octal];    IF NOT ok THEN Log[" failed to"L];    Log[" reset from "L];    Format.NetworkAddress[Log, from, octal];    Log[" at "L];    Format.Date[Log, Time.Current[], full];    IF NOT ok THEN Log[" ¬¬¬¬¬¬¬¬"L];    Format.CR[Log];    END;  Stop: PROCEDURE [who: System.NetworkAddress] =    BEGIN    ok: BOOLEAN = TimeServiceStub.Stop[who, 3];    Format.NetworkAddress[Log, who, octal];    Log[      IF ok THEN " stopped at "L      ELSE " did not stop (or there was no respose) at "L];    Format.Date[Log, Time.Current[], full];    IF NOT ok THEN Log[" ¬¬¬¬¬¬¬¬"L];    Format.CR[Log];    END;  Init: PROCEDURE =    BEGIN    ProcessCmFile[];    Process.SetTimeout[@pause, Process.SecondsToTicks[minPause]];    log ¬ MStream.Log["TimeServiceController.log"L, [ReleaseLog, NIL]];    Log["Time Service Controller started at "L];    Format.Date[Log, Time.Current[], full];    Log["\nThe log will be trimmed at "L];    Format.LongDecimal[Log, maxPagesInLog];    Log[" pages.\nThe minimum pause is "L];    Format.Decimal[Log, minPause];    Log[" seconds.\n"L];    ProcessCommandFile[];    MFile.AddNotifyProc[      NewCommands, ["TimeServiceController.txt"L, null, readOnly], NIL];    DoTasks[];    END;    ProcessCmFile: PROCEDURE =    BEGIN    value: LONG STRING;    BEGIN ENABLE CmFile.Error => CONTINUE;    value ¬ CmFile.UserDotCmLine["TimeServiceController"L, "pause"L];    IF value # NIL THEN {      minPause ¬ String.StringToDecimal[        value ! String.InvalidNumber => CONTINUE];      value ¬ CmFile.FreeString[value]};    value ¬ CmFile.UserDotCmLine["TimeServiceController"L, "logPages"L];    IF value # NIL THEN {      maxPagesInLog ¬ String.StringToLongNumber[        value ! String.InvalidNumber => CONTINUE];      value ¬ CmFile.FreeString[value]};    END;    END;  Log: Format.StringProc = {    IF log.GetPosition[] < Environment.bytesPerPage * maxPagesInLog THEN      log.PutString[s]};  NewCommands: MFile.NotifyProc = {IF file # NIL THEN ProcessCommandFile[]};  ReleaseLog: MStream.PleaseReleaseProc = {    MStream.SetLogReadLength[log, MStream.GetLength[log]]; RETURN[no]};  Process.Detach[FORK Init[]];  END...    
-- File: TimeServiceToolCommands.mesa - last edit:-- AOF                 25-Feb-87 13:35:43-- kam                 16-Dec-85 11:40:39-- Copyright (C) 1985, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Format USING [Decimal, StringProc],  NSBuffer USING [Body, Buffer],  NSConstants USING [timeServerSocket],  Overlap USING [    BadMaxErr, ConstructCorrectInterval, IncorrectSubset, IntervalRecord,    IntervalSet, zone],  Process USING [Detach, Pause, SecondsToTicks, Ticks],  Router USING [    endEnumeration, EnumerateRoutingTable, FillRoutingTable, startEnumeration],  Socket USING [    BroadcastPacketToAllConnectedNets, ChannelHandle,    Create, Delete, GetPacket, GetSendBuffer, PutPacket, ReturnBuffer,    SetPacketWords, SetWaitTime, TimeOut, WaitTime],  String USING [AppendLongDecimal],  System USING [    broadcastHostNumber, NetworkAddress, NetworkNumber, nullNetworkNumber,    nullSocketNumber],  TimeServerFormat USING [TSPacket, Version],  TimeServiceToolOps USING [AddDP, Command, DisplaySequence, IntersectType, zone];TimeServiceToolCommands: MONITOR  IMPORTS Format, Overlap, Process, Router, Socket, String, TimeServiceToolOps  EXPORTS TimeServiceToolOps =  BEGIN  timeout: Socket.WaitTime = 5000;    z: UNCOUNTED ZONE = TimeServiceToolOps.zone;  FindNetsWithTimeServers: PUBLIC PROCEDURE [    hops: CARDINAL, net: PROCEDURE [n: System.NetworkNumber]] =    BEGIN    processes: CARDINAL = 10;    processesAlive: CARDINAL ¬ processes;    last: System.NetworkNumber ¬ Router.startEnumeration;    lastHop: CARDINAL ¬ 0;    second: Process.Ticks = Process.SecondsToTicks[1];    Next: ENTRY PROCEDURE RETURNS [net: System.NetworkNumber] =      BEGIN      last ¬ Router.EnumerateRoutingTable[last, lastHop];      WHILE last = Router.endEnumeration AND lastHop < hops DO        lastHop ¬ SUCC[lastHop];        last ¬ Router.EnumerateRoutingTable[Router.startEnumeration, lastHop];        ENDLOOP;      RETURN[last];      END;    Check: ENTRY PROCEDURE RETURNS [BOOLEAN] = {RETURN[processesAlive = 0]};    Die: ENTRY PROCEDURE = {processesAlive ¬ PRED[processesAlive]};    Header: TYPE = MACHINE DEPENDENT RECORD [      id(0): LONG CARDINAL,      packetExchange(2): WORD,      body(3): TimeServerFormat.TSPacket];    Poller: PROCEDURE =      BEGIN      packet: LONG POINTER TO Header;      b: NSBuffer.Buffer;      body: NSBuffer.Body;      gotOne: BOOLEAN;      timeouts: CARDINAL;      cH: Socket.ChannelHandle;      n: System.NetworkNumber;      Socket.SetWaitTime[        cH ¬ Socket.Create[System.nullSocketNumber, 1, 5], timeout];      FOR n ¬ Next[], Next[] UNTIL n = Router.endEnumeration DO        gotOne ¬ FALSE;        timeouts ¬ 0;        UNTIL timeouts >= 3 DO  -- also exits if get a good reply          body ¬ (b ¬ Socket.GetSendBuffer[cH]).ns;          packet ¬ LOOPHOLE[@body.nsWords[0]];          packet^ ¬ [            id: 1234567B, packetExchange: 1,            body: [            version: TimeServerFormat.Version, tsBody: statisticRequest[]]];          body.destination ¬ [            n, System.broadcastHostNumber, NSConstants.timeServerSocket];          Socket.SetPacketWords[            b, 3 + SIZE[statisticRequest TimeServerFormat.TSPacket]];          (IF n = System.nullNetworkNumber THEN           Socket.BroadcastPacketToAllConnectedNets ELSE Socket.PutPacket)[            cH, b];          DO  -- exits if get a good reply or Socket.GetPacket times out            body ¬ (b ¬ Socket.GetPacket[cH ! Socket.TimeOut => GOTO TimeOut]).ns;            packet ¬ LOOPHOLE[@body.nsWords[0]];            IF body.source.net = n THEN              WITH reply: packet.body SELECT FROM                statisticResponse =>                  IF reply.version = TimeServerFormat.Version THEN GOTO GotOne;                ENDCASE;            Socket.ReturnBuffer[b];            REPEAT TimeOut => timeouts ¬ SUCC[timeouts];            ENDLOOP;          REPEAT GotOne => {Socket.ReturnBuffer[b]; gotOne ¬ TRUE};          ENDLOOP;        IF gotOne THEN net[n];        ENDLOOP;      Socket.Delete[cH];      Die[];      END;    Router.FillRoutingTable[hops];    Process.Pause[5 * second];    THROUGH [0..processes) DO Process.Detach[FORK Poller[]] ENDLOOP;    UNTIL Check[] DO Process.Pause[second] ENDLOOP;    Router.FillRoutingTable[0];    END;  Intersect: PUBLIC PROCEDURE [    set: Overlap.IntervalSet, type: TimeServiceToolOps.IntersectType,    maxErr: CARDINAL, out: Format.StringProc] RETURNS [maxErrUsed: CARDINAL] =    BEGIN    work: LONG STRING ¬ [32];    OutCR: Format.StringProc = {out[s]; out["\n"L]};    correctInterval: Overlap.IntervalRecord;    correct, incorrect: Overlap.IntervalSet;    dp: CARDINAL = (IF type = time THEN 3 ELSE 6);    IF set = NIL THEN RETURN[maxErr];    correctInterval ¬ Overlap.ConstructCorrectInterval[      set, maxErr ! Overlap.BadMaxErr =>        BEGIN        maxErr ¬ smallest;	out["At least "L];	Format.Decimal[out, smallest];	OutCR[" values must be incorrect"L];	RETRY	END];    [correct, incorrect] ¬ Overlap.IncorrectSubset[set, maxErr];    TimeServiceToolOps.DisplaySequence[correct, out];    out[" ["L];    work.length ¬ 0;    String.AppendLongDecimal[work, correctInterval.start];    TimeServiceToolOps.AddDP[work, dp];    out[work];    out[", "L];    work.length ¬ 0;    String.AppendLongDecimal[work, correctInterval.stop];    TimeServiceToolOps.AddDP[work, dp];    out[work];    OutCR["]"L];    TimeServiceToolOps.DisplaySequence[incorrect, out];    Overlap.zone.FREE[@correct];    Overlap.zone.FREE[@incorrect];    END;  SendCommand: PUBLIC PROCEDURE [    who, by: System.NetworkAddress, cmd: TimeServiceToolOps.Command]    RETURNS [ack: BOOLEAN] =    BEGIN    failed: BOOLEAN ¬ FALSE;    tries: CARDINAL ¬ 0;    maxTries: CARDINAL = 3;    cH: Socket.ChannelHandle;    b: NSBuffer.Buffer;    body: NSBuffer.Body;    packet: LONG POINTER TO TimeServerFormat.TSPacket;    Socket.SetWaitTime[cH ¬ Socket.Create[System.nullSocketNumber, 1, 8], timeout];    body ¬ (b ¬ Socket.GetSendBuffer[cH]).ns;    body.destination ¬ who;    body.destination.socket ¬ NSConstants.timeServerSocket;    body.packetType ¬ packetExchange;    body.nsWords[2] ¬ 1;    packet ¬ LOOPHOLE[@body.exchangeBody];    packet^ ¬      SELECT cmd FROM        reset => [TimeServerFormat.Version, resetRequest[by]],        start => [TimeServerFormat.Version, startRequest[]],        ENDCASE -- stop -- => [TimeServerFormat.Version, stopRequest[]];    Socket.SetPacketWords[      b,      3 +        (SELECT cmd FROM           reset => SIZE[resetRequest TimeServerFormat.TSPacket],           start => SIZE[startRequest TimeServerFormat.TSPacket],           ENDCASE => SIZE[stopRequest TimeServerFormat.TSPacket])];    Socket.PutPacket[cH, b];    b ¬ Socket.GetPacket[      cH !      Socket.TimeOut =>        BEGIN        IF (tries ¬ SUCC[tries]) = maxTries THEN {failed ¬ TRUE; CONTINUE}        ELSE RETRY;        END];    IF failed THEN RETURN[FALSE];    body ¬ b.ns;    packet ¬ LOOPHOLE[@body.exchangeBody];    ack ¬      WITH reply: packet SELECT FROM        resetResponse => cmd = reset,        startResponse => cmd = start,        stopResponse => cmd = stop,        ENDCASE => FALSE;    Socket.ReturnBuffer[b];    Socket.Delete[cH];    END;  END...
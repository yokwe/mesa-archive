-- File: SurveyorControl.mesa - last edit:-- kam         16-Dec-85 11:40:09-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Process USING [Abort, Detach, EnableAborts, SecondsToTicks, SetTimeout],  System USING [GetGreenwichMeanTime, NetworkNumber, SecondsSinceEpoch],  TimeServiceToolOps USING [Survey, ServerInfo, SurveyorInfo, zone];SurveyorControl: MONITOR  IMPORTS Process, System, TimeServiceToolOps EXPORTS TimeServiceToolOps =  BEGIN  <<  This module controls the processes which survey the networks. When it  is time for a network to be surveyed, the process TimeServiceToolOps.Survey  is created. This process terminates when the survey is complete or when it  is aborted.     All the networks are maintained in a circular queue, and the control is  passed in a round robin manner among maximumSurveyors processes. The variable  surveyorRing points to the last nondeleted entry that has been started. New  entries are inserted after this point.  >>  maximumSurveyors: CARDINAL ¬ 40;  delayBetweenSurvey: CARDINAL ¬ 60;  startOne, surveyCompleted, cpTerminated: CONDITION;  countActive: CARDINAL ¬ 0;  countInRing: CARDINAL ¬ 0;  z: UNCOUNTED ZONE = TimeServiceToolOps.zone;  controlProcess: PROCESS;  cpActive: BOOLEAN ¬ FALSE;  surveyorRing: LONG POINTER TO SurveyorTableEntry ¬ NIL;  firstForEnumerate: LONG POINTER TO SurveyorTableEntry ¬ NIL;  SurveyorTableEntry: TYPE = RECORD [    info: TimeServiceToolOps.SurveyorInfo,    lastSurveyed: LONG CARDINAL,    beingSurveyed: BOOLEAN,    process: PROCESS,    last, next: LONG POINTER TO SurveyorTableEntry];  ControlProcess: ENTRY PROCEDURE =    BEGIN    ENABLE UNWIND => NULL;    CanStartNext: PROCEDURE RETURNS [BOOLEAN] =      BEGIN      RETURN[        countActive < maximumSurveyors AND NOT surveyorRing.next.beingSurveyed          AND Now[] - surveyorRing.next.lastSurveyed > delayBetweenSurvey];      END;    StartNext: PROCEDURE =      BEGIN      surveyorRing ¬ surveyorRing.next;      surveyorRing.beingSurveyed ¬ TRUE;      countActive ¬ SUCC[countActive];      Process.Detach[surveyorRing.process ¬ FORK Survey[surveyorRing]];      END;    DO      ENABLE ABORTED => EXIT;      WHILE NOT CanStartNext[] DO WAIT startOne ENDLOOP;      StartNext[];      WHILE CanStartNext[] DO StartNext[] ENDLOOP;      ENDLOOP;    cpActive ¬ FALSE;    NOTIFY cpTerminated;    END;  DeleteSurveyors: PUBLIC ENTRY PROCEDURE =    BEGIN    e: LONG POINTER TO SurveyorTableEntry ¬ surveyorRing;    eNext: LONG POINTER TO SurveyorTableEntry;    svr, s: TimeServiceToolOps.ServerInfo;    IF e = NIL THEN RETURN;    Process.Abort[controlProcess];    WHILE cpActive DO WAIT cpTerminated ENDLOOP;    DO      IF e.beingSurveyed THEN        BEGIN        Process.Abort[e.process];        WHILE e.beingSurveyed DO WAIT surveyCompleted ENDLOOP;        END;      eNext ¬ e.next;      svr ¬ e.info.first;      UNTIL svr = NIL DO s ¬ svr; svr ¬ svr.next; z.FREE[@s] ENDLOOP;      z.FREE[@e.info];      z.FREE[@e];      IF (e ¬ eNext) = surveyorRing THEN EXIT;      ENDLOOP;    countInRing ¬ 0;    surveyorRing ¬ firstForEnumerate ¬ NIL;    END;  EnumerateSurveyors: PUBLIC ENTRY PROCEDURE [    last: TimeServiceToolOps.SurveyorInfo]    RETURNS [next: TimeServiceToolOps.SurveyorInfo] =    BEGIN    IF last = NIL THEN      RETURN[IF firstForEnumerate = NIL THEN NIL ELSE firstForEnumerate.info];    FOR p: LONG POINTER TO SurveyorTableEntry ¬ firstForEnumerate, p.next DO      IF p.info = last THEN        RETURN[IF p.next = firstForEnumerate THEN NIL ELSE p.next.info];      IF p.next = firstForEnumerate THEN EXIT;      ENDLOOP;    RETURN[NIL];    END;  GetParameters: PUBLIC ENTRY PROCEDURE    RETURNS [maxSurveyors, delay, minimumTimesSurveyed: CARDINAL] =    BEGIN ENABLE UNWIND => NULL;    count: CARDINAL;    minimumTimesSurveyed ¬ LAST[CARDINAL];    IF firstForEnumerate = NIL THEN minimumTimesSurveyed ¬ 0    ELSE FOR q: LONG POINTER TO SurveyorTableEntry ¬ firstForEnumerate, q.next DO      count ¬ q.info.gen - (IF q.beingSurveyed THEN 1 ELSE 0);      IF count < minimumTimesSurveyed THEN minimumTimesSurveyed ¬ count;      IF q.next = firstForEnumerate THEN EXIT;      ENDLOOP;    RETURN[maximumSurveyors, delayBetweenSurvey, minimumTimesSurveyed];    END;  Init: PROCEDURE =    BEGIN    Process.EnableAborts[@startOne];    Process.SetTimeout[@startOne, Process.SecondsToTicks[5]];    END;  InsertEntryInRing: PUBLIC ENTRY PROCEDURE [    info: TimeServiceToolOps.SurveyorInfo] RETURNS [inserted: BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    p: LONG POINTER TO SurveyorTableEntry ¬ z.NEW[      SurveyorTableEntry ¬ [      info: info, lastSurveyed: 0, beingSurveyed: FALSE, process:, last: NIL,      next: NIL]];    IF NOT cpActive THEN      BEGIN      Process.Detach[controlProcess ¬ FORK ControlProcess[]];      cpActive ¬ TRUE;      surveyorRing ¬ firstForEnumerate ¬ p.next ¬ p.last ¬ p;      END    ELSE      BEGIN      FOR q: LONG POINTER TO SurveyorTableEntry ¬ surveyorRing, q.next DO        IF q.info.net = info.net THEN {z.FREE[@p]; RETURN[FALSE]};        IF q.next = surveyorRing THEN EXIT;        ENDLOOP;      p.last ¬ surveyorRing;      p.next ¬ surveyorRing.next;      surveyorRing.next ¬ p.next.last ¬ p;      countInRing ¬ SUCC[countInRing];      NOTIFY startOne;      END;    RETURN[TRUE];    END;  Now: PROCEDURE RETURNS [LONG CARDINAL] = {    RETURN[System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]]]};  SetParameters: PUBLIC ENTRY PROCEDURE [maxSurveyors, delay: CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    IF maxSurveyors # 0 THEN maximumSurveyors ¬ maxSurveyors;    IF delay # 0 THEN      BEGIN      delayBetweenSurvey ¬ delay;      Process.SetTimeout[@startOne, Process.SecondsToTicks[delay / 10]];      NOTIFY startOne;      END;    END;  Survey: PROCEDURE [entry: LONG POINTER TO SurveyorTableEntry] =    BEGIN    NotifyComplete: ENTRY PROCEDURE =      BEGIN      ENABLE UNWIND => NULL;      entry.beingSurveyed ¬ FALSE;      entry.lastSurveyed ¬ Now[];      countActive ¬ PRED[countActive];      NOTIFY surveyCompleted;      NOTIFY startOne;      END;    entry.info.gen ¬ SUCC[entry.info.gen];    TimeServiceToolOps.Survey[entry.info];    NotifyComplete[];    END;    SurveyActive: PUBLIC ENTRY PROCEDURE [info: TimeServiceToolOps.SurveyorInfo]    RETURNS [active: BOOLEAN] =    BEGIN    FOR p: LONG POINTER TO SurveyorTableEntry ¬ surveyorRing, p.next DO      IF p.info = info THEN RETURN[p.beingSurveyed];      IF p.next = surveyorRing THEN EXIT;      ENDLOOP;    RETURN[FALSE];    END;  Init[];  END...  
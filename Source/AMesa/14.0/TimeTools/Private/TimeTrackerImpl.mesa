-- File: TimeTrackerImpl.mesa - last edit:-- AOF                 25-Apr-88 11:30:59-- KAM                 12-Jul-84  9:04:39-- Copyright (C) 1984, 1988 by Xerox Corporation. All rights reserved.DIRECTORY  Event USING [swapping],  EventTypes USING [newSession, resumeSession],  Exec USING [    AddCommand, EndOfCommandLine, ExecProc, FreeTokenString, GetToken, Handle,    OutputProc, RemoveCommand],  Format USING [    Blank, CR, Date, Decimal, Line, LongDecimal, NetworkAddress, Number,    StringProc],  Heap USING [Create, Delete],  HeraldWindow USING [AppendMessage],  Process USING [    Abort, Pause, priorityBackground, SecondsToTicks, SetPriority, Ticks],  String USING [    AppendString, AppendStringAndGrow, InvalidNumber, StringToDecimal],  StringLookUp USING [ambiguous, InTable, noMatch, TableDesc],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, RemoveDependency,    SubsystemHandle],  System USING [GetGreenwichMeanTime, GreenwichMeanTime, NetworkAddress],  TimeServerClock USING [    Error, GetParameters, Invalid, Rate, Read, ResyncNow, SetParameters, Start,    Stop, undefined],  TimeServerLog USING [],  UserTerminal USING [BlinkDisplay];TimeTrackerImpl: MONITOR  IMPORTS    Event, Exec, Format, Heap, HeraldWindow, Process, String, StringLookUp,    Supervisor, System, TimeServerClock, UserTerminal  EXPORTS TimeServerLog =  BEGIN  Action: TYPE = {start, stop, resync, log, info, params, null, error};  z: UNCOUNTED ZONE = Heap.Create[20];  LogEntry: TYPE = LONG POINTER TO LogEntryRecord;  LogEntryRecord: TYPE = RECORD [value: LONG STRING, next: LogEntry];  log: LogEntry ¬ NIL;  entries: CARDINAL ¬ 0;  -- in [0.. maxEntries]  maxEntries: CARDINAL = 30;  defaultResyncPeriod: CARDINAL = 120;  -- minutes --  defaultMaxPctError: CARDINAL = 5;  -- max percent error   started: BOOLEAN ¬ FALSE;  countResyncs, countInconsistencies: CARDINAL ¬ 0;  accumulatedChange: LONG INTEGER ¬ 0;  clockWatcher: PROCESS;  worldSwapAgent: Supervisor.SubsystemHandle = Supervisor.CreateSubsystem[    agent: WorldSwapAgent];  ClockWatcher: PROCEDURE =    BEGIN    invalid: BOOLEAN ¬ FALSE;    Out: Format.StringProc = {HeraldWindow.AppendMessage[s]};    longTicks: Process.Ticks = Process.SecondsToTicks[300];    shortTicks: Process.Ticks = Process.SecondsToTicks[10];    Process.SetPriority[Process.priorityBackground];    DO      ENABLE ABORTED => EXIT;      Process.Pause[IF invalid THEN shortTicks ELSE longTicks];      invalid ¬ FALSE;      [] ¬ TimeServerClock.Read[        ! TimeServerClock.Invalid => {invalid ¬ TRUE; Invalid[Out]; CONTINUE}];      ENDLOOP;    END;  DeleteLog: ENTRY PROCEDURE =    BEGIN    e, next: LogEntry;    FOR e ¬ log, next UNTIL e = NIL DO      next ¬ e.next; z.FREE[@e.value]; z.FREE[@e] ENDLOOP;    log ¬ NIL;    entries ¬ 0;    accumulatedChange ¬ countResyncs ¬ countInconsistencies ¬ 0;    END;  DisplayCtrs: PROCEDURE [Out: Format.StringProc] =    BEGIN    Number: PROCEDURE [x: CARDINAL] = {      IF x = 0 THEN Out["no"L] ELSE Format.Decimal[Out, x]};    Out["There have been "L];    Number[countResyncs];    Out[" resyncs and "L];    Number[countInconsistencies];    Out[" inconsistencies. The accumulated change to the clock has been "L];    Format.LongDecimal[Out, accumulatedChange];    Out[" seconds."L];    END;  DisplayLog: ENTRY PROCEDURE [Out: Format.StringProc] =    BEGIN    DisplayCtrs[Out];    Format.CR[Out];    IF entries = 0 THEN Out["The log is empty"L]    ELSE      FOR e: LogEntry ¬ log, e.next UNTIL e = NIL DO        Format.Line[Out, e.value] ENDLOOP;    IF countResyncs + countInconsistencies > maxEntries THEN      Format.Line[Out, "..."L];    END;  DisplayState: PROCEDURE [Out: Format.StringProc] =    BEGIN    timeLastReset: System.GreenwichMeanTime;    changeLastReset: LONG INTEGER;    error: TimeServerClock.Error;    accurate, invalid: BOOLEAN ¬ FALSE;    version: LONG CARDINAL;    resetPeriod: CARDINAL;    [timeLastReset: timeLastReset, changeLastReset: changeLastReset,      resetPeriod: resetPeriod] ¬        TimeServerClock.GetParameters[];    [error: error, accurate: accurate, version: version] ¬ TimeServerClock.Read[      ! TimeServerClock.Invalid => {invalid ¬ TRUE; CONTINUE}];    IF invalid THEN {Invalid[Out]; RETURN};    Out[IF started THEN "Started"L ELSE "Stopped"L];    Out[". Last reset on "L];    Format.Date[Out, timeLastReset, full];    Out[" by "L];    Format.LongDecimal[Out, changeLastReset];    Out[" version "L];    Format.LongDecimal[Out, version];    Out[". The uncertainty is "L];    IF error = TimeServerClock.undefined THEN Out["undefined"L]    ELSE      BEGIN      Format.LongDecimal[Out, error];      Out[" milliseconds"L];      IF NOT accurate THEN Out[", but currently inaccurate"L];      END;    Out[".\nThe reset period is "L];    Format.Decimal[Out, resetPeriod];    Out[" minutes. "L];    DisplayCtrs[Out];    END;  ExecProc: Exec.ExecProc =    BEGIN    Out: Format.StringProc = Exec.OutputProc[h];    SELECT GetAction[h] FROM      start =>        IF NOT started THEN {          started ¬ TRUE; TimeServerClock.Start[]; Out["Started."L]}        ELSE Out["Already started"L];      stop =>        IF started THEN {          started ¬ FALSE; TimeServerClock.Stop[]; Out["Stopped."L]}        ELSE Out["Already stopped"L];      resync => {TimeServerClock.ResyncNow[]; Out["Resynch requested."L]};      log => DisplayLog[Out];      info => DisplayState[Out];      params =>         BEGIN	pctError, resync: CARDINAL;	[pctError, resync] ¬ GetParams[h];	SetParams[pctError, resync];	END;      null => Format.Date[Out, System.GetGreenwichMeanTime[], full];      ENDCASE => outcome ¬ error;    END;  GetAction: ENTRY PROCEDURE [h: Exec.Handle] RETURNS [action: Action] =    BEGIN    lastCmd: CARDINAL = Action.LAST.ORD;    cmdTable: ARRAY [0..lastCmd] OF LONG STRING ¬ [      "Start"L, "Stop"L, "Resync"L, "Log"L, "Info"L, "Params"L, "Null"L, "XXX"L];    cmds: StringLookUp.TableDesc = DESCRIPTOR[cmdTable];    xlate: ARRAY [0..lastCmd] OF Action = [      start, stop, resync, log, info, params, null, error];    token, switches: LONG STRING;    index: CARDINAL;    Out: Format.StringProc = Exec.OutputProc[h];    IF Exec.EndOfCommandLine[h] THEN RETURN[null];    [token, switches] ¬ Exec.GetToken[h];    switches ¬ Exec.FreeTokenString[switches];    index ¬ StringLookUp.InTable[token, cmds];    SELECT index FROM      StringLookUp.ambiguous => {        action ¬ error;        Format.Blank[Out];        Out[token];        Format.Line[Out, " is ambiguous"L]};      StringLookUp.noMatch => {        action ¬ error;        Format.Blank[Out];        Out[token];        Format.Line[Out, " does not match any command"L]};      > lastCmd => {action ¬ error; Format.Line[Out, " Bug!"L]};      ENDCASE => action ¬ xlate[index];    token ¬ Exec.FreeTokenString[token];    END;  GetParams: ENTRY PROCEDURE [h: Exec.Handle]    RETURNS [pctError, resync: CARDINAL] =    BEGIN    token, switches: LONG STRING;    Out: Format.StringProc = Exec.OutputProc[h];    pctError ¬ defaultMaxPctError;    resync ¬ defaultResyncPeriod;    UNTIL Exec.EndOfCommandLine[h] DO      [token, switches] ¬ Exec.GetToken[h];      BEGIN      work: CARDINAL;      IF switches = NIL OR switches.length = 0 THEN        BEGIN        Out[token];        Format.Line[Out, " has no switch"L];	GO TO Reject;	END;      work ¬ String.StringToDecimal[	token !	String.InvalidNumber =>	  BEGIN	  Out[token];	  Format.Line[Out, " is not a number"L];	  GO TO Reject;	  END];      IF work = 0 THEN {Format.Line[Out, "Value of zero ignored"L]; GOTO Reject};      SELECT switches[0] FROM        'p, 'P => pctError ¬ work;	'r, 'R => resync ¬ work;	ENDCASE =>	  BEGIN	  Out[switches];	  Format.Line[Out, " is an unknown switch"L];	  GOTO Reject;	  END;      EXITS Reject => NULL;      END;      token ¬ Exec.FreeTokenString[token];      ENDLOOP;    IF pctError NOT IN [0..100] THEN      BEGIN      Format.Decimal[Out, pctError];      Out[" is not a percentage"L];      pctError ¬ defaultMaxPctError;      END;    END;  HelpProc: ENTRY Exec.ExecProc =    BEGIN    Out: Format.StringProc = Exec.OutputProc[h];    Line: Format.StringProc = {Format.Line[Out, s]};    Line["TimeTracker.~ Start starts tracker"L];    Line["TimeTracker.~ Stop stops the tracker"L];    Line["TimeTracker.~ Resync resyncs the local clock"L];    Line["TimeTracker.~ Information gives the current state"L];    Line["TimeTracker.~ Log gives the last 30 resyncs"L];    Line["TimeTracker.~ Params pct/P resetDelay/R sets the max percent of"L];    Out["    faulty servers to pct (default "L];    Format.Decimal[Out, defaultMaxPctError];    Line["%) and sets the period between"L];    Out["    resets to resetDelay minutes (default "L];    Format.Decimal[Out, defaultResyncPeriod];    Line[" minutes)."L];    END;  Init: PROCEDURE =    BEGIN    Exec.AddCommand["TimeTracker.~"L, ExecProc, HelpProc, UnloadProc];    SetParams[resync: defaultResyncPeriod, pctError: defaultMaxPctError];    started ¬ TRUE;    TimeServerClock.Start[];    Supervisor.AddDependency[worldSwapAgent, Event.swapping];    clockWatcher ¬ FORK ClockWatcher[];    END;  Invalid: PROCEDURE [Out: Format.StringProc] = {    UserTerminal.BlinkDisplay[];    Out["The clock is invalid! Please check uses of time and reboot"L]};  Log: ENTRY PROCEDURE [s: LONG STRING] =    BEGIN    log ¬ z.NEW[LogEntryRecord ¬ [s, log]];    IF entries # maxEntries THEN entries ¬ SUCC[entries]    ELSE      BEGIN      FOR e: LogEntry ¬ log, e.next UNTIL e.next.next = NIL DO        REPEAT FINISHED => {z.FREE[@e.next.value]; z.FREE[@e.next]} ENDLOOP;      END;    END;  LogClockChange: PUBLIC <<TimeServerLog>> PROCEDURE [    time: System.GreenwichMeanTime, delta: LONG INTEGER,    whoFrom: System.NetworkAddress, errorAccurate: BOOLEAN,    oldError, newError, flightTime: LONG CARDINAL] =    BEGIN    out: LONG STRING ¬ z.NEW[StringBody[120]];    Out: Format.StringProc = {      IF s.length + out.length > s.maxlength THEN        String.AppendStringAndGrow[@out, s, z, 20]      ELSE String.AppendString[out, s]};    countResyncs ¬ SUCC[countResyncs];    Out["Clock changed at "L];    Format.Date[Out, time, full];    Out[" by "L];    Format.NetworkAddress[Out, whoFrom, octal];    Out["\n	delta: "L];    Format.LongDecimal[Out, delta];    Out["\n	oldError: "L];    Format.LongDecimal[Out, oldError];    Out["\n	newError: "L];    Format.LongDecimal[Out, newError];    Out["\n	flightTime: "L];    Format.LongDecimal[Out, flightTime];    IF errorAccurate THEN Out["\n	errorAccurate"L];    Out["\n"L];    Log[out];    accumulatedChange ¬ accumulatedChange + delta;    END;  LogInconsistancy: PUBLIC <<TimeServerLog>> PROCEDURE [    whoWith: System.NetworkAddress, myTime: System.GreenwichMeanTime,    myError: LONG CARDINAL, theirTime: System.GreenwichMeanTime,    theirError: LONG CARDINAL] =    BEGIN    out: LONG STRING ¬ z.NEW[StringBody[80]];    Out: Format.StringProc = {      IF s.length + out.length > s.maxlength THEN        String.AppendStringAndGrow[@out, s, z, 20]      ELSE String.AppendString[out, s]};    countInconsistencies ¬ SUCC[countInconsistencies];    Out["Service inconsistent with "L];    Format.NetworkAddress[Out, whoWith, octal];    Out[" at "L];    Format.Date[Out, myTime, full];    Out["\n	theirTime: "L];    Format.Date[Out, theirTime, full];    Out["\n	myError: "L];    Format.LongDecimal[Out, myError];    Out["\n	theirError: "L];    Format.LongDecimal[Out, theirError];    Log[out];    END;  SetParams: PROCEDURE [pctError, resync: CARDINAL] =    BEGIN    drift, wobble: TimeServerClock.Rate;    [drift: drift, wobble: wobble] ¬ TimeServerClock.GetParameters[];    TimeServerClock.SetParameters[drift, wobble, resync];    END;  UnloadProc: Exec.ExecProc =    BEGIN    Out: Format.StringProc = Exec.OutputProc[h];    IF started THEN {      started ¬ FALSE; TimeServerClock.Stop[]; Format.Line[Out, "Stopped."L]};    DisplayLog[Out];    DeleteLog[];    Format.CR[Out];    Exec.RemoveCommand[h, "TimeTracker.~"L];    Supervisor.RemoveDependency[worldSwapAgent, Event.swapping];    Process.Abort[clockWatcher];    JOIN clockWatcher;    Heap.Delete[z];    END;  WorldSwapAgent: Supervisor.AgentProcedure = {    IF (event = EventTypes.newSession OR event = EventTypes.resumeSession)      AND started THEN TimeServerClock.ResyncNow[]};  Init[];  END...
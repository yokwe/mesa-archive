-- TTYDMTImpl.mesa - edited by:--  Wagner	 7-Feb-86 10:14:05DIRECTORY  BitBlt,  Brush,  Display,  Environment,  Exec,  Format USING [StringProc],  Heap,  Inline USING [HighHalf],  MFile,  MSegment,  Process,  Runtime,  SimpleTTYDefs,  String,  System,  UserTerminal,  Window;TTYDMTImpl: MONITOR  IMPORTS    BitBlt, Brush, Exec, Heap, Inline, MFile, MSegment, Process,     Runtime, SimpleTTYDefs, String, System, UserTerminal =  BEGIN    OPEN BitBlt;    -- Constants  wordsPerLine:CARDINAL = UserTerminal.screenWidth/Environment.bitsPerWord;  bitMapSize: LONG CARDINAL = wordsPerLine * UserTerminal.screenHeight;  bitMapPages:CARDINAL =      CARDINAL[(bitMapSize + Environment.wordsPerPage - 1) /         Environment.wordsPerPage];  -- Types.  BrushHandle: TYPE = LONG POINTER TO BrushRec;  BrushRec: TYPE = RECORD [hdr: BrushHeader, bitmap: ARRAY [0..0) OF INTEGER];  BrushHeader: TYPE = RECORD [    version: [0..256),    masked: BOOLEAN,    size: Window.Dims,    place: Window.Place,    offset: Window.Place,    wpl: INTEGER];  -- Globals.  defaultBrush: BrushHandle ¬     LOOPHOLE[Runtime.GetTableBase[LOOPHOLE[Brush]]];  brush: BrushHandle ¬ NIL;  currentBox: Window.Box;  newBox: Window.Box;  saveBitMap:BitAddress;  bitMapPlace: BitAddress;    -- Brush routines.  JumpBrushes: PROCEDURE = INLINE    BEGIN      JumpABrush[];    END;      JumpABrush: PROCEDURE [] =    BEGIN    ChooseNewPosition[];    Black[currentBox];    PaintBrush[newBox];    currentBox ¬ newBox;    END;    PaintBrush: PROCEDURE [box: Window.Box] =    BEGIN      bbTab: BBTableSpace;      bbt: BBptr ¬ AlignedBBTable[@bbTab];      brushBitmap: LONG POINTER ¬ @brush.bitmap;          bbt­ ¬ [        dst: [	  word: bitMapPlace.word + box.place.y * wordsPerLine +	    box.place.x/Environment.bitsPerWord,	  reserved: 0, 	  bit: box.place.x MOD Environment.bitsPerWord],	dstBpl: UserTerminal.screenWidth,	src: [brushBitmap,0,0], 	srcDesc: [srcBpl[brush.hdr.wpl*16]],	width: box.dims.w, height: box.dims.h,	flags: Display.replaceFlags];       BITBLT[bbt];    END;    Black: PROCEDURE [box: Window.Box] = BEGIN    bbTab: BBTableSpace;    bbt: BBptr ¬ AlignedBBTable[@bbTab];    black: ARRAY [0..1) OF CARDINAL ¬ ALL[LAST[CARDINAL]];    bbt­ ¬ [      dst: [        word: bitMapPlace.word + box.place.y * wordsPerLine +        box.place.x/Environment.bitsPerWord,       reserved: 0,       bit: box.place.x MOD Environment.bitsPerWord],      dstBpl: UserTerminal.screenWidth,      src: [@black,0,0], srcDesc: [gray[gray: [0,0,0,0]]],      width: box.dims.w, height: box.dims.h,      flags: Display.replaceGrayFlags];    BITBLT[bbt];  END;  -- Support routines.  seed: LONG CARDINAL ¬ System.GetClockPulses[] MOD 1048576;  -- Returns a number in [0..range).  Random: PROCEDURE [range: CARDINAL [0..1023]] RETURNS [CARDINAL] =    BEGIN    seed ¬ (seed * 1093 + 221587) MOD 1048576;    RETURN[Inline.HighHalf[seed*range] / 16];    END;  ChooseNewPosition: PROCEDURE =    BEGIN    newPlace: Window.Place;      -- Compute the new position of the brush.    newPlace ¬ [      Random[UserTerminal.screenWidth - currentBox.dims.w + 1],      Random[UserTerminal.screenHeight - currentBox.dims.h + 1]];    newBox.place ¬ newPlace;    RETURN;    END;  -- Setup routines.  Init: PROCEDURE =    BEGIN      IF Runtime.IsBound[@SimpleTTYDefs.dontDisplay] THEN	Exec.AddCommand["TTYDMT.~"L, DoIt, Help]    END;    busy: BOOLEAN ¬ FALSE;    DoIt: ENTRY Exec.ExecProc = {    IF ~busy THEN {      token, switches, brushname: LONG STRING ¬ NIL;      busy ¬ TRUE;      [token, switches] ¬ Exec.GetToken[h];      IF token#NIL THEN         brushname ¬ String.CopyToNewString[token, Heap.systemZone];      [] ¬ Exec.FreeTokenString[token];      [] ¬ Exec.FreeTokenString[switches];      Process.Detach[FORK TTYDMTCommand[brushname]];      }    ELSE {      Exec.OutputProc[h]["TTYDMT is already running."L];      }    };    Done: ENTRY PROCEDURE = {busy ¬ FALSE};    downUp: TYPE = {down, up};  keycount: CARDINAL = 112;  Keyarray: TYPE = LONG POINTER TO PACKED ARRAY [0..keycount) OF downUp;    TTYDMTCommand: PROCEDURE [brushname: LONG STRING] =    BEGIN    black: ARRAY [0..1) OF CARDINAL ¬ ALL[LAST[CARDINAL]];    bbts: BBTableSpace;    bbt: BBptr ¬ AlignedBBTable[@bbts];    file, tempfile: MFile.Handle ¬ NIL;    seg, tempseg: MSegment.Handle ¬ NIL;    i: CARDINAL ¬ 0;        BEGIN      ENABLE         UNWIND, ABORTED => {	  IF seg # NIL THEN MSegment.Delete[seg];	  IF tempseg # NIL THEN MSegment.Delete[tempseg];	  Done[]; };	      Process.SetPriority[Process.priorityBackground];      IF brushname#NIL THEN {	[] ¬ String.AppendExtensionIfNeeded[@brushname, ".brush"L, 	  Heap.systemZone];	file ¬ MFile.ReadOnly[brushname,[]! MFile.Error => {	  brush ¬ defaultBrush;	  file ¬ NIL;	  CONTINUE}];	IF file # NIL THEN {	  seg ¬ MSegment.Create[file, []];	  brush ¬ MSegment.Address[seg];	  };	}      ELSE	brush ¬ defaultBrush;	      IF brushname#NIL THEN String.FreeString[Heap.systemZone, brushname];            currentBox ¬ [[0,0],brush.hdr.size];      newBox ¬ [[0,0],brush.hdr.size];          bbt­ ¬ UserTerminal.GetBitBltTable[];      tempfile ¬ MFile.AcquireTemp[binary, bitMapSize*Environment.bytesPerWord];      MFile.SetLength[tempfile, bitMapSize*Environment.bytesPerWord];      tempseg ¬ MSegment.Create[tempfile, []];      saveBitMap ¬ [word: MSegment.Address[tempseg],bit:0];      bitMapPlace ¬ bbt.src;      -- save original bitmap      bbt.flags.disjoint ¬ bbt.flags.disjointItems ¬ TRUE;      bbt.dst ¬ saveBitMap;      BITBLT[bbt];      IF Runtime.IsBound[@SimpleTTYDefs.dontDisplay] THEN {        SimpleTTYDefs.dontDisplay ¬ TRUE;	};      IF UserTerminal.hasBorder THEN UserTerminal.SetBorder[377B,377B];      bbt­ ¬ [	dst: bitMapPlace, dstBpl: bbt.dstBpl,	src: [@black,0,0], srcDesc: [gray[gray: [0,0,0,0]]],	width: bbt.width, height: bbt.height,	flags: Display.replaceGrayFlags];      BITBLT[bbt];      DO        IF LOOPHOLE[UserTerminal.keyboard, Keyarray][77] = down THEN 	  EXIT;	IF i MOD 16 = 0 THEN JumpBrushes[];	i ¬ i+1; «i++ (:-)»	Process.Pause[Process.MsecToTicks[100]];      ENDLOOP;      IF UserTerminal.hasBorder THEN UserTerminal.SetBorder[210B,42B];      IF Runtime.IsBound[@SimpleTTYDefs.dontDisplay] THEN        SimpleTTYDefs.dontDisplay ¬ FALSE;      bbt­ ¬ [	dst: bitMapPlace, dstBpl: bbt.dstBpl,	src: saveBitMap,srcDesc: [srcBpl[srcBpl: UserTerminal.screenWidth]],	width: bbt.width, height: bbt.height,	flags: Display.replaceFlags];      BITBLT[bbt];      IF seg # NIL THEN MSegment.Delete[seg];      IF tempseg # NIL THEN MSegment.Delete[tempseg];    END;    Done[];    END;  Help: Exec.ExecProc =    BEGIN    OutputProc: Format.StringProc = Exec.OutputProc[h];    END;  -- Mainline.  Init[];  END.
-- File: TimeServiceStubImpl.mesa - last edit:-- AOF                  6-Apr-88 16:33:15-- KAM                  4-Mar-85 19:45:22-- Copyright (C) 1985, 1988 by Xerox Corporation. All rights reserved.DIRECTORY  NSBuffer USING [Body, Buffer],  NSConstants USING [timeServerSocket],  NSTypes USING [WaitTime],  Socket USING [    ChannelHandle, Create, Delete, GetPacket, GetSendBuffer, PutPacket,    ReturnBuffer, SetPacketWords, SetWaitTime, TimeOut, WaitTime],  System USING [    GetClockPulses, NetworkAddress, nullSocketNumber, Pulses,    PulsesToMicroseconds],  TimeServerFormat USING [TSPacket, Version, WireToGMT, WireToLong],  TimeServiceStub USING [    InternalTimeResponse, StatisticsResponse, TimeResponse];TimeServiceStubImpl: PROGRAM  IMPORTS Socket, System, TimeServerFormat EXPORTS TimeServiceStub =  BEGIN  Command: TYPE = {start, stop, reset, time, internalTime, statistics};  ImplementationError: ERROR = CODE;  InfoProc: TYPE = PROCEDURE [    delay: LONG CARDINAL, data: LONG POINTER TO TimeServerFormat.TSPacket]    RETURNS [done: BOOLEAN ¬ FALSE];  Start: PUBLIC PROCEDURE [server: System.NetworkAddress, tries: CARDINAL]    RETURNS [responded: BOOLEAN] = {    RETURN SendCommand[server, server, start, tries]};  Stop: PUBLIC PROCEDURE [server: System.NetworkAddress, tries: CARDINAL]    RETURNS [responded: BOOLEAN] = {    RETURN SendCommand[server, server, stop, tries]};  Reset: PUBLIC PROCEDURE [server, from: System.NetworkAddress, tries: CARDINAL]    RETURNS [responded: BOOLEAN] = {    RETURN SendCommand[server, from, reset, tries]};  Time: PUBLIC PROCEDURE [    server: System.NetworkAddress, tries: CARDINAL,    responses: LONG DESCRIPTOR FOR ARRAY OF TimeServiceStub.TimeResponse] =    BEGIN    i: CARDINAL ¬ 0;    GotOne: InfoProc =      BEGIN      IF i = responses.LENGTH THEN RETURN[TRUE];      WITH d: data SELECT FROM        timeResponse =>          responses[i] ¬ [            flight: delay, time: TimeServerFormat.WireToGMT[d.time],            zoneS: d.zoneS, zoneH: d.zoneH, zoneM: d.zoneM,            beginDST: d.beginDST, endDST: d.endDST,            errorAccurate: d.errorAccurate,            absoluteError: TimeServerFormat.WireToLong[d.absoluteError]];        ENDCASE;      RETURN[(i ¬ SUCC[i]) = responses.LENGTH];      END;    IF responses = NIL THEN RETURN;    CollectInfo[server, time, tries, GotOne];    END;  InternalTime: PUBLIC PROCEDURE [    server: System.NetworkAddress, tries: CARDINAL,    responses: LONG DESCRIPTOR FOR ARRAY OF      TimeServiceStub.InternalTimeResponse] =    BEGIN    i: CARDINAL ¬ 0;    GotOne: InfoProc =      BEGIN      IF i = responses.LENGTH THEN RETURN[TRUE];      WITH d: data SELECT FROM        internalTimeResponse =>          responses[i] ¬ [            flight: delay, time: TimeServerFormat.WireToGMT[d.time],            absoluteError: TimeServerFormat.WireToLong[d.absoluteError],            timeVersion: TimeServerFormat.WireToLong[d.timeVersion]];        ENDCASE;      RETURN[(i ¬ SUCC[i]) = responses.LENGTH];      END;    IF responses = NIL THEN RETURN;    CollectInfo[server, internalTime, tries, GotOne];    END;  Statistics: PUBLIC PROCEDURE [    server: System.NetworkAddress, tries: CARDINAL,    responses: LONG DESCRIPTOR FOR ARRAY OF      TimeServiceStub.StatisticsResponse] =    BEGIN    i: CARDINAL ¬ 0;    GotOne: InfoProc =      BEGIN      IF i = responses.LENGTH THEN RETURN[TRUE];      WITH d: data SELECT FROM        statisticResponse =>          responses[i] ¬ [            flight: delay,            numberRequests: TimeServerFormat.WireToLong[d.numberRequests],            active: d.active, resetting: d.resetting,            timeSet: TimeServerFormat.WireToGMT[d.timeSet],            lastChange: TimeServerFormat.WireToLong[d.lastChange],            source: d.source];        ENDCASE;      RETURN[(i ¬ SUCC[i]) = responses.LENGTH];      END;    IF responses = NIL THEN RETURN;    CollectInfo[server, statistics, tries, GotOne];    END;  SendCommand: PROCEDURE [    who, by: System.NetworkAddress, cmd: Command, maxTries: CARDINAL]    RETURNS [ack: BOOLEAN ¬ FALSE] =    BEGIN    b: NSBuffer.Buffer;    body: NSBuffer.Body;    cH: Socket.ChannelHandle;    timeout: Socket.WaitTime = 10000;    packet: LONG POINTER TO TimeServerFormat.TSPacket;    Socket.SetWaitTime[cH ¬ Socket.Create[System.nullSocketNumber], timeout];    THROUGH [0..maxTries) UNTIL ack DO      body ¬ (b ¬ Socket.GetSendBuffer[cH]).ns;      body.destination ¬ who;      body.destination.socket ¬ NSConstants.timeServerSocket;      body.packetType ¬ packetExchange;      body.nsWords[2] ¬ 1;      packet ¬ LOOPHOLE[@body.exchangeBody];      packet­ ¬        SELECT cmd FROM          start => [TimeServerFormat.Version, startRequest[]],          reset => [TimeServerFormat.Version, resetRequest[by]],          stop => [TimeServerFormat.Version, stopRequest[]],          ENDCASE => ERROR ImplementationError;      Socket.SetPacketWords[        b,        3 +          (SELECT cmd FROM             start => SIZE[startRequest TimeServerFormat.TSPacket],             reset => SIZE[resetRequest TimeServerFormat.TSPacket],             stop => SIZE[stopRequest TimeServerFormat.TSPacket],             ENDCASE => ERROR ImplementationError)];      Socket.PutPacket[cH, b];      body ¬ (b ¬ Socket.GetPacket[cH ! Socket.TimeOut => LOOP]).ns;      packet ¬ LOOPHOLE[@body.exchangeBody];      ack ¬        WITH reply: packet SELECT FROM          resetResponse => cmd = reset,          stopResponse => cmd = stop,          startResponse => cmd = start,          ENDCASE => FALSE;      Socket.ReturnBuffer[b];      ENDLOOP;    Socket.Delete[cH];    END;  CollectInfo: PROCEDURE [    who: System.NetworkAddress, cmd: Command, tries: CARDINAL, Info: InfoProc] =    BEGIN    b: NSBuffer.Buffer;    body: NSBuffer.Body;    pulses: System.Pulses;    cH: Socket.ChannelHandle;    timeout: Socket.WaitTime = 10000;    packet: LONG POINTER TO TimeServerFormat.TSPacket;    Socket.SetWaitTime[      cH ¬ Socket.Create[System.nullSocketNumber, 1, 20], timeout];    THROUGH [0..tries) DO      body ¬ (b ¬ Socket.GetSendBuffer[cH]).ns;      body.destination ¬ who;      body.destination.socket ¬ NSConstants.timeServerSocket;      body.packetType ¬ packetExchange;      body.nsWords[2] ¬ 1;      packet ¬ LOOPHOLE[@body.exchangeBody];      packet­ ¬        SELECT cmd FROM          time => [TimeServerFormat.Version, timeRequest[]],          internalTime => [TimeServerFormat.Version, internalTimeRequest[]],          statistics => [TimeServerFormat.Version, statisticRequest[]],          ENDCASE => ERROR ImplementationError;      Socket.SetPacketWords[        b,        3 +          (SELECT cmd FROM             time => SIZE[timeRequest TimeServerFormat.TSPacket],             internalTime => SIZE[               internalTimeRequest TimeServerFormat.TSPacket],             statistics => SIZE[statisticRequest TimeServerFormat.TSPacket],             ENDCASE => ERROR ImplementationError)];      pulses ¬ System.GetClockPulses[];      Socket.PutPacket[cH, b];      DO        body ¬ (b ¬ Socket.GetPacket[cH ! Socket.TimeOut => EXIT]).ns;        IF Info[          CARDINAL[          (System.PulsesToMicroseconds[[System.GetClockPulses[] - pulses]] +             999) / 1000], LOOPHOLE[@body.exchangeBody]] THEN GOTO Done;        ENDLOOP;      Socket.ReturnBuffer[b];      REPEAT Done => Socket.ReturnBuffer[b];      ENDLOOP;    Socket.Delete[cH];    END;  END...    
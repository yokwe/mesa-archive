-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- BrowniesB.mesa - last edited by:-- BJD    	12-Oct-83 15:31:15-- primitives for NS BrownieDIRECTORY  BrownieOps USING [],  BrownieQOps USING [    FileAttributes, FileAttributesRecord, FreeQ, FreeQueueElement, GetFront,    InitializePause, IsEmpty, MyCopyAttributes, MyFreeAttributes, PtrQE, PutRear,    Q, QElement, QHead, SetFinished, WaitUntilQGetsSmaller],  Courier USING [Error, ErrorCode],  FileName USING [VFN],  FileTransfer USING [    Confirmation, Connection, ConnectionObject, Error, ErrorCode, FileInfo,    ValidProperties],  FileTransferNSOps USING [    EnumerationClass, MesaFileType, NSData, NSDataHandle,    OpenCatalogAndEnumerate],  FileTransferOps USING [    CommandObject, Connection, ConnectionObject, FTHandle, maxFileName,    NSPrimitives, PrimitivesObject, RetrieveStreamCommand, z],  FileTransferUtils USING [    CheckAbort, CreateFT, HasWildCard, Post, WriteDate],  Heap USING [systemZone],  NSDataStream USING [Aborted, Handle, Sink, SourceStream],  NSFile USING [    Attributes, AttributesProc, AttributeType, Close, CopyAttributes, Error, ErrorRecord,    FreeAttributes, Handle, List, nullHandle, nullTime, OpenByReference,    ReferenceRecord, Retrieve, Selections, String],  NSString USING [    AppendToMesaString, CopyString, EquivalentStrings, StringBoundsFault],  ParseDefs USING [z],  Process USING [Abort, Detach, DisableTimeout, EnableAborts, InvalidProcess],  Stream USING [Delete, DeleteProcedure, Handle],  String USING [    AppendChar, AppendNumber, AppendString, AppendStringAndGrow, Empty, Equivalent,    MakeString, Replace, StringBoundsFault];  BrowniesB: MONITOR LOCKS rData USING rData: RetrieveData  IMPORTS    BrownieQOps, Courier, FileTransfer, FileTransferNSOps, FileTransferOps,    FileTransferUtils, Heap, NSDataStream, NSFile, NSString, ParseDefs, Process,    Stream, String  EXPORTS BrownieOps, FileTransfer =  BEGIN OPEN BrownieQOps;    CommandObject: TYPE = FileTransferOps.CommandObject;  Connection: TYPE = FileTransferOps.Connection;  ConnectionObject: PUBLIC TYPE = FileTransferOps.ConnectionObject;  VFN: TYPE = FileName.VFN;  CR: STRING = "";  heap: UNCOUNTED ZONE = Heap.systemZone;  done: FileTransfer.Confirmation = LOOPHOLE[5];    fileQ, directoryQ: Q ¬ NIL;  secondsBetweenRetries: CARDINAL = 5;      NSGetStreamInfo: PUBLIC PROC [ft: FileTransferOps.FTHandle] = {    GetRemoteInfo[ft.conn, RData[ft].fileAttributes]};    NSRetrieveStream: PUBLIC PROC [    c: Connection, p: FileTransferOps.RetrieveStreamCommand] =    BEGIN    ft: FileTransferOps.FTHandle ¬ NIL;    producer: PROCESS;    IF FileTransferUtils.HasWildCard[p.remote.directory] OR      String.Empty[p.remote.directory] THEN {      FileTransferUtils.Post[c, fatal, "Illegal directory"L, CR];      ERROR FileTransfer.Error[c, skip]};    IF c.stream # NIL THEN {c.stream.delete[c.stream]; c.stream ¬ NIL};    FileTransferUtils.CheckAbort[c];    ft ¬ FileTransferUtils.CreateFT[      c, p, String.MakeString[heap, FileTransferOps.maxFileName]];    ft.op ¬ retrieveStream;    ft.free ¬ FreeRetrieveObject;    ft.data ¬ FileTransferOps.z.NEW[      RetrieveObject ¬ [        pathnameLength: FileTransferNSOps.NSData[c].directory.length]];    DisableTimeouts[RData[ft]];    AllocQs[RData[ft]];    EnableAborts[RData[ft]];    Process.Detach[producer ¬ FORK ProduceFileObjects[c, ft, p.remote]];    SetProducer[RData[ft], producer];    UNTIL NSRetrieveNextStream[c, ft] = do DO      ft ¬ LOOPHOLE[c.stream];      IF ft = NIL THEN RETURN      ENDLOOP;    END;      NSRetrieveEntry: ENTRY PROC [c: Connection, rData: RetrieveData, fH: NSFile.Handle]    RETURNS [Stream.Handle] =-- Retrieve is accomplished by forking a process (CallRetrieve) which calls NSFile.Retrieve with a procedure (Sink) that remains allocated until the client deletes the stream (or the next stream is requested).    BEGIN ENABLE UNWIND => NULL;    Process.Detach[FORK CallRetrieve[c, fH, rData]];    WaitOnStreamAvailable[rData];        IF rData.errorEncountered THEN     WITH rData.error SELECT FROM      ns => ERROR NSFile.Error[error];      courier => ERROR Courier.Error[errorCode]      ENDCASE;    RETURN[rData.sH]    END;    CallRetrieve: ENTRY PROC [c: Connection, fH: NSFile.Handle, rData: RetrieveData] =    BEGIN ENABLE UNWIND => NULL;    DeleteSource: Stream.DeleteProcedure =      BEGIN      NotifyDelete[rData];      WaitOnOkayToDelete[rData];      END;    Sink: INTERNAL PROC [source: NSDataStream.SourceStream] =      BEGIN ENABLE {		NSDataStream.Aborted => CONTINUE;		UNWIND => Stream.Delete[source]};      oldDelete: Stream.DeleteProcedure ¬ source.delete;      source.delete ¬ DeleteSource;      rData.sH ¬ source;      NotifyStreamAvailable[rData];      WaitOnDel[rData];      source.delete ¬ oldDelete;      Stream.Delete[source ! NSDataStream.Aborted => CONTINUE];      END;    {    NSFile.Retrieve[fH, [proc [Sink]], FileTransferNSOps.NSData[c].session !     NSFile.Error =>       IF error = [transfer[problem:aborted]] THEN CONTINUE -- Deleted before done;      ELSE { rData.error ¬ [ns[error]]; GOTO handleError };     Courier.Error => {        rData.error ¬ [courier[errorCode]]; GOTO handleError}    ];    CloseNSFile[c, @fH];    NotifyOkayToDelete[rData];    EXITS     handleError => {       rData.errorEncountered ¬ TRUE;       NotifyOkayToDelete[rData];       NotifyStreamAvailable[rData]};    }    END; -- of CallRetrieve    NSRetrieveNextStream: PUBLIC PROC     [c: Connection, ft: FileTransferOps.FTHandle ¬ NIL] RETURNS [FileTransfer.Confirmation] =    BEGIN    confirm: FileTransfer.Confirmation;    stream: Stream.Handle = LOOPHOLE[ft];    fp: PtrQE ¬ NIL;    {ENABLE UNWIND => stream.delete[stream];    IF ft.stream # NIL THEN {      Stream.Delete[ft.stream]; -- A call to DeleteSource;      ft.stream ¬ NIL};    fp ¬ GetOneFile[ft];    IF RData[ft].errorEncountered THEN     WITH RData[ft].error SELECT FROM      ns => ERROR NSFile.Error[error];      courier => ERROR Courier.Error[errorCode]      ENDCASE;    IF fp = NIL THEN {  -- done      stream: Stream.Handle = LOOPHOLE[ft];      stream.delete[stream]; -- sets c.stream to NIL, to be looked at by ReadNextInner;      RETURN[done]};    IF RData[ft].fileAttributes#NIL THEN {      BrownieQOps.MyFreeAttributes[RData[ft].fileAttributes];      RData[ft].fileAttributes ¬ NIL};    confirm ¬ Retrieve[c, ft, fp];  -- retrieveProc stuff    FreeQueueElement[fp];    RETURN[confirm]    }    END; -- of NSRetrieveNextStream      Retrieve: PROCEDURE [    c: Connection, ft: FileTransferOps.FTHandle, filePtr: PtrQE]    RETURNS [answer: FileTransfer.Confirmation] =    BEGIN      file: NSFile.Handle ¬ NSFile.nullHandle;      name: LONG STRING ¬ [FileTransferOps.maxFileName];    GetInfo: PROC [conn: Connection]      RETURNS [source, target: FileTransfer.FileInfo] = {      GetRemoteInfo[conn, filePtr.fileAttributes];      RETURN[source: conn.info[source], target: NIL]};    StripDirectory[FileTransferNSOps.NSData[c], RData[ft]];    AppendDirectory[FileTransferNSOps.NSData[c], filePtr.fileAttributes.pathname];    RData[ft].fileAttributes ¬ CopyAttributes[filePtr.fileAttributes];    MakeFileName[c, name, filePtr.fileAttributes, TRUE];    String.Replace[@(ft.file), name, heap];    FileTransferUtils.Post[c, terse, ft.file];    c.good ¬ ALL[FALSE];    IF ft.dates THEN {        GetRemoteInfo[c, filePtr.fileAttributes];        FileTransferUtils.WriteDate[c, source]};    IF ft.veto # NIL THEN [answer, ft.dates] ¬ ft.veto[        c, c.clientData, c.post, GetInfo, ft.dates]    ELSE answer ¬ do;    SELECT answer FROM        do => {          refRec: NSFile.ReferenceRecord ¬ [	   fileID: filePtr.fileAttributes.fileID, systemElement: FileTransferNSOps.NSData[c].systemElement];          file ¬ NSFile.OpenByReference[            reference: @refRec, session: FileTransferNSOps.NSData[c].session !	      NSFile.Error => -- If in the mean time, file has been deleted, ignore;	        IF error = [access[problem:fileNotFound]] THEN GOTO skip];          ft.stream ¬ NSRetrieveEntry[c, RData[ft], file];          ft.object.options ¬ ft.stream.options;          c.stream ¬ LOOPHOLE[ft]}; -- file closed in NSRetrieveEntry after stream deleted (CallRetrieve)        skip => {	  FileTransferUtils.Post[c, terse, " XXX"L, CR];	  RETURN[answer]};        abort => ERROR ABORTED;      ENDCASE;    EXITS      skip => RETURN[skip]    END;           -- -- -- -- -- -- -- -- -- --  -- Monitor stuff    NSorCourierError: TYPE = RECORD [    SELECT type: * FROM    ns => [error: NSFile.ErrorRecord],    courier => [errorCode: Courier.ErrorCode],    aborted => NULL    ENDCASE];      RetrieveData: TYPE = LONG POINTER TO RetrieveObject;  RetrieveObject: TYPE = MONITORED RECORD [    fileAttributes: BrownieQOps.FileAttributes ¬ NIL, -- only those needed for Brownie;    sH: Stream.Handle ¬ NIL,    errorEncountered: BOOLEAN ¬ FALSE,	-- NSFile or Courier error encountered?    error: NSorCourierError ¬ NULL,	-- The error itself;    continue: BOOLEAN ¬ TRUE,		-- Continue the enumeration?    streamAvailable, deleted,    okayToDelete, producerHasDied: CONDITION,    producer: PROCESS,    streamAvail, del, okay, producerDead: BOOLEAN ¬ FALSE,    pathnameLength: CARDINAL ¬ 0];    SetError: ENTRY PROC [rData: RetrieveData, error: NSorCourierError] = {    rData.error ¬ error; rData.errorEncountered ¬ TRUE};      SetProducer: ENTRY PROC [rData: RetrieveData, producer: PROCESS] = {    rData.producer ¬ producer};      NotifyOkayToDelete: INTERNAL PROC [rData: RetrieveData] = {    rData.okay ¬ TRUE;    NOTIFY rData.okayToDelete};    WaitOnOkayToDelete: ENTRY PROC [rData: RetrieveData] =    BEGIN ENABLE UNWIND => NULL;    WHILE ~rData.okay DO WAIT rData.okayToDelete ENDLOOP;    rData.okay ¬ FALSE    END;  NotifyStreamAvailable: INTERNAL PROC [rData: RetrieveData] = {    rData.streamAvail ¬ TRUE;    NOTIFY rData.streamAvailable};    WaitOnStreamAvailable: INTERNAL PROC [rData: RetrieveData]=    BEGIN ENABLE UNWIND => NULL;    WHILE ~rData.errorEncountered AND ~rData.streamAvail DO      WAIT rData.streamAvailable ENDLOOP;    rData.streamAvail ¬ FALSE    END;  NotifyDelete: ENTRY PROC [rData: RetrieveData] = {    rData.del ¬ TRUE;    NOTIFY rData.deleted};    WaitOnDel: INTERNAL PROC [rData: RetrieveData] =    BEGIN    WHILE ~rData.errorEncountered AND ~rData.del DO WAIT rData.deleted ENDLOOP;    rData.del ¬ FALSE    END;     NotifyThatProducerHasDied: ENTRY PROC [rData: RetrieveData] = {    rData.producerDead ¬ TRUE;    NOTIFY rData.producerHasDied};    WaitForProducerToDie: ENTRY PROC [rData: RetrieveData] =    BEGIN    WHILE ~rData.producerDead DO WAIT rData.producerHasDied ENDLOOP;    rData.producerDead ¬ FALSE    END;    -- Do I really need these?  DisableTimeouts: PROC [rData: RetrieveData] =    BEGIN    Process.DisableTimeout[@(rData.deleted)];    Process.DisableTimeout[@(rData.okayToDelete)];    END;      EnableAborts: PROC [rData: RetrieveData] =    BEGIN    Process.EnableAborts[@fileQ.available];    Process.EnableAborts[@directoryQ.available];    END;      CleanupStream: PROC [ft: FileTransferOps.FTHandle] = {    IF ft = NIL OR ft.stream = NIL THEN RETURN;    Stream.Delete[ft.stream ! NSDataStream.Aborted => CONTINUE];     ft.stream ¬ NIL};  FreeRetrieveObject: PROC [ft: FileTransferOps.FTHandle, rData: RetrieveData] = {    ProducerDead: ENTRY PROC [rData: RetrieveData] RETURNS [BOOLEAN] = {      RETURN[rData.producerDead]};    IF ~ProducerDead[rData] THEN {      Process.Abort[rData.producer ! Process.InvalidProcess => CONTINUE];      WaitForProducerToDie[rData]};    FreeQ[@fileQ]; FreeQ[@directoryQ];    IF rData.fileAttributes#NIL THEN      BrownieQOps.MyFreeAttributes[rData.fileAttributes];    FileTransferOps.z.FREE[@rData]};             -- Consumer  GetOneFile: PROCEDURE [ft: FileTransferOps.FTHandle] RETURNS [qe: PtrQE] =    BEGIN    RETURN[GetFront[fileQ]];    END;          -- Producer    ProduceFileObjects: PROCEDURE [    c: Connection, ft: FileTransferOps.FTHandle, vfn: VFN] =     BEGIN    versionClass: FileTransferNSOps.EnumerationClass ¬ DetermineVersion[vfn.version];    dirQE: PtrQE ¬ NIL;    localError: NSorCourierError;    { ENABLE {       NSFile.Error => {localError ¬ [ns[error]]; GOTO setError};       Courier.Error => {localError ¬ [courier[errorCode]]; GOTO setError};       ABORTED => {GOTO finished} -- this process has been aborted;       };    InitQs[c, ft, vfn, versionClass];    WHILE ~IsEmpty[directoryQ] DO      WaitUntilQGetsSmaller[fileQ];      dirQE ¬ GetFront[directoryQ];      EnumerateOneDirectory[c, ft, dirQE, versionClass];      FreeQueueElement[dirQE];      ENDLOOP;    Finished[RData[ft]];    EXITS    setError => {      SetError[RData[ft], localError];      Finished[RData[ft]]};    finished =>       Finished[RData[ft]];    }    END;      Finished: PROC[rData: RetrieveData] = {    SetFinished[fileQ, TRUE];    SetFinished[directoryQ, TRUE];    NotifyThatProducerHasDied[rData]};    AllocQs: PROC [rData: RetrieveData] = {    fileQ ¬ ParseDefs.z.NEW[QHead ¬ []];    directoryQ ¬ ParseDefs.z.NEW[QHead ¬ []];    BrownieQOps.InitializePause[secondsBetweenRetries]};  InitQs: PROCEDURE [    c: Connection, ft: FileTransferOps.FTHandle, vfn: VFN,    versionClass: FileTransferNSOps.EnumerationClass] =     BEGIN    found: BOOLEAN ¬ FALSE;    enumProc: NSFile.AttributesProc =       BEGIN      qe: PtrQE ¬ NIL;      found ¬ TRUE;      qe ¬ ParseDefs.z.NEW[        QElement ¬ [fileAttributes: BrownieQOps.MyCopyAttributes[attributes]]];      IF attributes.isDirectory THEN        PutRear[directoryQ, qe]      ELSE        PutRear[fileQ, qe];      END;    FileTransferNSOps.OpenCatalogAndEnumerate[c, enumProc, vfn, versionClass];    IF ~found THEN ERROR NSFile.Error[[access[fileNotFound]]];    END;      EnumerateOneDirectory: PROC [    c: Connection, ft: FileTransferOps.FTHandle, dirQE: PtrQE,    versionClass: FileTransferNSOps.EnumerationClass] =     BEGIN    enumProc: NSFile.AttributesProc =       BEGIN      qe: PtrQE ¬ NIL;      qe ¬ ParseDefs.z.NEW[        QElement ¬ [fileAttributes: BrownieQOps.MyCopyAttributes[attributes]]];      AppendPathname[@(qe.fileAttributes.pathname), dirQE];      IF attributes.isDirectory THEN        PutRear[directoryQ, qe]      ELSE        PutRear[fileQ, qe];      END;    refRec: NSFile.ReferenceRecord ¬ [      fileID: dirQE.fileAttributes.fileID,      systemElement: FileTransferNSOps.NSData[c].systemElement];    dirH: NSFile.Handle ¬ NSFile.OpenByReference[      reference: @refRec, session: FileTransferNSOps.NSData[c].session !      NSFile.Error => -- If in the mean time, directory has been deleted, ignore;        IF error = [access[problem:fileNotFound]] THEN GOTO return];    Enumerate[c, dirH, enumProc, versionClass]    EXITS      return => NULL    END; -- of EnumerateOneDirectory      Enumerate: PROCEDURE [    c: Connection, dirH: NSFile.Handle, proc: NSFile.AttributesProc,    class: FileTransferNSOps.EnumerationClass] =    BEGIN    previous: NSFile.Attributes ¬ NIL;    stopped: BOOLEAN ¬ FALSE;    ListLowestVersions: NSFile.AttributesProc = {     IF previous = NIL OR        NOT NSString.EquivalentStrings[previous.name, attributes.name] THEN {       continue ¬ proc[attributes];       IF previous # NIL THEN NSFile.FreeAttributes[previous];       previous ¬ NSFile.CopyAttributes[attributes]}};    ListHighestVersions: NSFile.AttributesProc = {     IF previous # NIL THEN { -- Skip 1st time through if = NIL;       IF NOT NSString.EquivalentStrings[previous.name, attributes.name] THEN          continue ¬ proc[previous]; stopped ¬ ~continue;       NSFile.FreeAttributes[previous];       previous ¬ NSFile.CopyAttributes[attributes]       }     ELSE  previous ¬ NSFile.CopyAttributes[attributes]};    EnumProc: NSFile.AttributesProc = {        continue ¬ SELECT class FROM          lowest => ListLowestVersions[attributes],          highest => ListHighestVersions[attributes],	ENDCASE => proc[attributes]};    { ENABLE UNWIND => IF previous#NIL THEN NSFile.FreeAttributes[previous];    NSFile.List[      directory: dirH, selections: DesiredSelections[c],      proc: EnumProc, session: FileTransferNSOps.NSData[c].session,      scope: [       direction: IF class = allBackward THEN backward ELSE forward]];    IF previous # NIL THEN {      IF class = highest AND ~stopped THEN [] ¬ proc[previous]; -- last file      NSFile.FreeAttributes[previous]}    }	    END; -- of Enumerate        SetUpForNSCopy: PUBLIC PROCEDURE [c: Connection] =     BEGIN    c.nsPrimitives ¬ ParseDefs.z.NEW[      FileTransferOps.PrimitivesObject ¬ FileTransferOps.NSPrimitives­];    c.nsPrimitives.retrieveStream ¬ NSRetrieveStream;    c.nsPrimitives.retrieveNextStream ¬ NSRetrieveNextStream;    c.nsPrimitives.getStreamInfo ¬ NSGetStreamInfo;    END;      ResetPrimitives: PUBLIC PROCEDURE [c: Connection] =    BEGIN    ParseDefs.z.FREE[@c.nsPrimitives];    c.nsPrimitives ¬ FileTransferOps.NSPrimitives;    END;  RData: PROC [ft: FileTransferOps.FTHandle] RETURNS[RetrieveData] = INLINE {    RETURN[ LOOPHOLE[ft.data, RetrieveData] ]};    DesiredSelections: PROC [c: Connection]    RETURNS [selections: NSFile.Selections ¬ []] = {    FOR i: FileTransfer.ValidProperties IN [body..readProtect] DO      selections.interpreted[map[i]] ¬ c.desiredProps[i]      ENDLOOP;    selections.interpreted[fileID] ¬ TRUE;  -- I depend on these internally;    selections.interpreted[type] ¬ TRUE;    selections.interpreted[name] ¬ TRUE;    selections.interpreted[isDirectory] ¬ TRUE;    selections.interpreted[sizeInBytes] ¬ TRUE; -- in the case of Retrieve        selections.interpreted[createdOn] ¬ TRUE;  -- left out of FileTransfer defs;    };   map: ARRAY FileTransfer.ValidProperties OF NSFile.AttributeType = [     host: fileID, -- these 2 are dummies; no corresponding NS type;     directory: fileID,          body: name,      version: version,     author: createdBy,      size: sizeInBytes,      type: type,      oldFile: modifiedOn, readProtect: readOn];--left out read, write, create in defs     CloseNSFile: PROC [c: Connection, fH: POINTER TO NSFile.Handle] = {    IF fH­ # NSFile.nullHandle THEN {      NSFile.Close[fH­, FileTransferNSOps.NSData[c].session !        NSFile.Error, Courier.Error => CONTINUE];      fH­ ¬ NSFile.nullHandle}};  AppendDirectory: PROC [    nsData: FileTransferNSOps.NSDataHandle, pathname: LONG STRING] = {    IF String.Empty[pathname] THEN RETURN;    String.AppendChar[nsData.directory, '>];    String.AppendString[nsData.directory, pathname]};   StripDirectory: PROC [    nsData: FileTransferNSOps.NSDataHandle, rData: RetrieveData] = INLINE {    nsData.directory.length ¬ rData.pathnameLength};      AppendPathname: PROC [pathnamePtr: LONG POINTER TO LONG STRING, dirQE: PtrQE] = {    fullName: LONG STRING ¬ [FileTransferOps.maxFileName];    IF ~String.Empty[dirQE.fileAttributes.pathname] THEN {      String.AppendString[fullName, dirQE.fileAttributes.pathname];      String.AppendChar[fullName, '>]};    NSString.AppendToMesaString[fullName, dirQE.fileAttributes.name];    String.AppendStringAndGrow[      to: pathnamePtr, from: fullName, z: ParseDefs.z, extra: 20]};      DetermineVersion: PROCEDURE [version: LONG STRING]    RETURNS [vClass: FileTransferNSOps.EnumerationClass] = {    vClass ¬ SELECT TRUE FROM     String.Empty[version] => highest,      String.Equivalent[version, "*"L] => vClass ¬ all,     String.Equivalent[version, "H"L] => vClass ¬ highest,     String.Equivalent[version, "L"L] => vClass ¬ lowest,     ENDCASE => null};       GetRemoteInfo:  PUBLIC PROC [ -- only need these two for Brownie    conn: FileTransferOps.Connection, fileAttributes: BrownieQOps.FileAttributes] = {    ConvertNSInfo[FileTransferNSOps.NSData[conn], fileAttributes, conn.info[source]];    conn.good[source] ¬ TRUE};          ConvertNSInfo: PUBLIC PROC [    nsData: FileTransferNSOps.NSDataHandle,    attributes: BrownieQOps.FileAttributes, info: FileTransfer.FileInfo] = {    IF attributes = NIL THEN {info­ ¬ [oldFile: FALSE]; RETURN};    nsData.body.length ¬ 0;    nsData.author.length ¬ 0;    nsData.version.length ¬ 0;    NSString.AppendToMesaString[      nsData.body, attributes.name ! NSString.StringBoundsFault => CONTINUE];    String.AppendNumber[nsData.version, attributes.version !      String.StringBoundsFault => RESUME[NIL]];    info­ ¬ [      body: nsData.body, 	author: nsData.author,      version: nsData.version, 	directory: nsData.directory,      create: attributes.createdOn, read: NSFile.nullTime,      write: NSFile.nullTime, size: attributes.sizeInBytes,      type: FileTransferNSOps.MesaFileType[attributes.type]     ];    };      MakeFileName: PUBLIC PROC [    c: Connection, name: LONG STRING,    attributes: BrownieQOps.FileAttributes, d: BOOLEAN ¬ FALSE] =    BEGIN    name.length ¬ 0;    IF d THEN {      String.AppendString[name, FileTransferNSOps.NSData[c].directory !        String.StringBoundsFault => RESUME[NIL]];      String.AppendChar[name, '> !        String.StringBoundsFault => RESUME[NIL]]};    IF c.desiredProps[body] THEN      NSString.AppendToMesaString[name, attributes.name !	NSString.StringBoundsFault => CONTINUE];    SELECT FileTransferNSOps.MesaFileType[attributes.type] FROM      binary, text =>         IF c.desiredProps[version] THEN {	String.AppendChar[name, '! !	  String.StringBoundsFault => RESUME[NIL]];        String.AppendNumber[name, attributes.version !	  String.StringBoundsFault => RESUME[NIL]]}      ENDCASE;    END;            CopyAttributes: PROC [attributes: BrownieQOps.FileAttributes]     RETURNS [fileAttributes: BrownieQOps.FileAttributes] = {    fileAttributes ¬ ParseDefs.z.NEW[FileAttributesRecord ¬ [      name: NSString.CopyString[ParseDefs.z, attributes.name],      version: attributes.version,      type: attributes.type,      sizeInBytes: attributes.sizeInBytes,      createdOn: attributes.createdOn,      fileID: attributes.fileID]]};           END.
-- File: BrownieParse.mesa - last edit:-- bjd                 13-May-87 15:17:46-- Copyright (C) 1983, 1984, 1987  by Xerox Corporation. All rights reserved. -- File: BrownieParse.mesa, last edited by:--  BJD    	13-Feb-87 11:10:38--  RKJ     	27-Feb-83 13:55:21--  DSC  	 3-Oct-84 13:24:45 DIRECTORY  Ascii USING [CR, NUL],  BrownieOps USING [    Copy, levelNames, Level, Login, MakeTime, PostLine, PostString, SecondsTilTime,    SetLevel, ttyH],  FileName USING [AllocVFN, FreeVFN, Error, VirtualFilename],  FileTransfer USING [ServerType],  Heap USING [MakeNode],  ParseDefs USING [    Command, CommandIndex, CommandType, Connect, ConnectPtr, Data, DataHandle,    Info, InfoHandle, LogIn, LogInIndex],  Profile USING [GetUser],  Space USING [],  Stream USING [EndOfStream, GetChar, Handle],  String USING [    AppendChar, AppendDecimal, AppendNumber, AppendString, Empty, EquivalentString,    InvalidNumber, StringBoundsFault, UpperCase],  System USING [GreenwichMeanTime],  Time USING [Append, Current, defaultTime, Pack, Unpacked, Unpack],  Token USING [    Alphabetic, AlphaNumeric, Brackets, FileName, Filtered, FilterProcType,    FilterState, FreeTokenString, GetCharProcType, Handle, Line, MaybeQuoted,    Object, Skip, StandardFilterState, Switches],  TTY USING [PutChar, PutCR, PutString, UserAbort];BrownieParse: PROGRAM  IMPORTS BrownieOps, FileName, Heap, Profile, Stream, String, Time, Token, TTY  EXPORTS ParseDefs =  BEGIN OPEN BrownieOps, ParseDefs;  data: ParseDefs.Data; -- Command object holding data from command parsing;  h: Token.Handle ¬ NIL; -- Token object.	  tData: Token.StandardFilterState ;  sHin: Stream.Handle ¬ NIL;  -- Input stream on brownie script file;  token: LONG STRING ¬ NIL;  -- Global token holds current token from script file;  useBreak: BOOLEAN ¬ FALSE; -- Determines whether to use break char as next char;  endOfFile: BOOLEAN ¬ FALSE; -- TRUE if end of script file occurs;      -- Command switches, defaults in ResetSwitches;  -- follows FTP-like conventions.    always, update, all, destConnect, sourceConnect: BOOLEAN ¬ FALSE;    nLogins: CARDINAL = 16;  -- Maximum number of different hosts;    nCommands: CARDINAL = 600;  -- Maximum number of commands;    -- Can't use ASCII.CR since this is a STRING, not a CHAR  CR: LONG STRING = "";  hours, minutes: CARDINAL;  -- Start time values, to be converted to secs;  startNow: BOOLEAN;  -- Whether to start immediately or not;  errorsEncountered: CARDINAL ¬ 0;  -- Number of parsing errors encountered;  -- ************************************************  --  Token Stuff  -- Supply the token package with a stream of characters.    GetChar: Token.GetCharProcType =  -- PROC[h: Token.Handle] RETURNS[c: CHAR]    BEGIN    IF useBreak THEN {c ¬ h.break; useBreak ¬ FALSE}    ELSE      c ¬ Stream.GetChar[        sHin !        Stream.EndOfStream =>          IF ~endOfFile THEN {endOfFile ¬ TRUE; c ¬ Ascii.NUL; CONTINUE}          ELSE REJECT]    END;    -- Return true is character is alphebetic or a : or a slash.  AlphaColonSlash: Token.FilterProcType =    BEGIN    RETURN[      SELECT c FROM        IN ['a..'z], IN ['A..'Z], = ':, = '/ => TRUE,        ENDCASE => FALSE];    END;      -- Return true is character is alphanumeric or a colon  -- We could actually use Token.AlphaNumeric OR c = ':       AlphaNumericColon: Token.FilterProcType =    BEGIN    RETURN[      SELECT c FROM        IN ['a..'z], IN ['A..'Z], IN ['0..'9], = ': => TRUE,        ENDCASE => FALSE];    END;   -- Return true is character back arrow, used to denote  dest ¬ src.   BackArrow: Token.FilterProcType =    BEGIN RETURN[IF c = '¬  OR c = '¬ THEN TRUE ELSE FALSE] END;  -- ********************************  --  Parsing Parameter Stuff  ParseError: SIGNAL = CODE;    -- Notify an error in a parameter line.  -- doesn't tell you WHAT went wrong, however.    ParameterFailure: PROCEDURE [n: CARDINAL] =    BEGIN    s: STRING ¬ [10];    errorsEncountered ¬ errorsEncountered + 1;    String.AppendNumber[s, n + 1];    PostLine[fatal, " in parameter line #"L, s, "."L];    SkipLine[];    token ¬ Token.FreeTokenString[token];    token ¬ Token.Filtered[h, @tData, AlphaColonSlash];    END;  -- Gets the level of information to be logged  -- can be: verbose, or terse.  -- looks like the fatal and warning parameters aren't documented  -- in the MUG.   -- Also, it only takes the first 3 characters, which is ok for most  -- situations, except that misspellings are not noted.      -- Note: the return value is ALWAYS true. Why is it there?  -- perhaps the ENDCASE should set it to FALSE... DSC    ReadLevel: PROCEDURE RETURNS [exists: BOOLEAN ¬ TRUE] =    BEGIN OPEN String;    l: BrownieOps.Level;    token.length ¬ 3;        -- Set the local level state here.    SELECT TRUE FROM      EquivalentString[token, "fat"L] => l ¬ fatal;      EquivalentString[token, "war"L] => l ¬ warning;      EquivalentString[token, "ter"L] => l ¬ terse;      EquivalentString[token, "ver"L] => l ¬ verbose;      ENDCASE => {  -- Level omitted: default is terse        PostLine[verbose, "Posting level is terse."L]; RETURN[FALSE]};	    -- Do the actual global setting of the level here.    BrownieOps.SetLevel[l];        PostLine[verbose];    PostLine[verbose, "Posting level is "L, BrownieOps.levelNames[l], "."L];    token ¬ Token.FreeTokenString[token];    token ¬ Token.MaybeQuoted[h, NIL, AlphaColonSlash, Token.Brackets];    END;  -- Get user specified parameters.    ReadParameters: PROCEDURE =    BEGIN    -- ReadLevel always returns TRUE, so cnt is set to 1 always.        cnt: CARDINAL ¬ IF ReadLevel[] THEN 1 ELSE 0;        -- Say for now that we will start immediately.        startNow ¬ TRUE;        -- Read the parameters in the order expected, until the finish reading the comment.        FOR n: CARDINAL ¬ cnt, n + 1 DO      -- Token is a global that holds the current token from the script file.            -- No parameters?            IF token = NIL THEN {        PostString[fatal, "Illegal parameter."L]; ParameterFailure[n]; LOOP};	      -- A single slash starts a comment. Note that in the documentation, it seems      -- like you need << TWO >> slashes to start the comment.                  IF token[0] = '/ THEN {        SkipLine[];		-- don't need the rest of the line.        token ¬ Token.FreeTokenString[token];			-- clean up.        token ¬ Token.Filtered[h, @tData, Token.AlphaNumeric];	-- get next token.        EXIT -- Once we have the comment, we can stop reading the parameters	};	      -- for the purpose of comparing it against      -- a list of keywords of length 4.            token.length ¬ 4;			      SELECT TRUE FROM              String.EquivalentString[token, "STAR"L] =>	    -- start time? of form:	    -- start: [xx:yy]  	    startNow ¬ ReadStartTime[ ! ParseError => {ParameterFailure[n]; LOOP}]; 	         String.EquivalentString[token, "STOP"L] =>	    -- Stop time? of form:	    -- stop: [xx:yy]	    ReadStopTime[ ! ParseError => {ParameterFailure[n]; LOOP}];	          -- future enhancements here	        ENDCASE => {PostString[fatal, "Illegal parameter"L]; ParameterFailure[n]};      cnt ¬ cnt + 1      ENDLOOP;    END;  -- ReadParameters  -- Here are TWO procedures that look very similar. Perhaps they could  -- share some common code.     ReadStartTime: PROCEDURE RETURNS [now: BOOLEAN ¬ TRUE] =    BEGIN    s: LONG STRING;    {    token ¬ Token.FreeTokenString[token];    s ¬ token ¬ Token.MaybeQuoted[h, NIL, AlphaNumericColon, Token.Brackets];    IF s = NIL THEN GOTO now;    IF String.UpperCase[s[0]] # 'N THEN      BEGIN      now ¬ FALSE;      [hours, minutes] ¬ BrownieOps.MakeTime[s ! String.InvalidNumber => GOTO now];      -- Wait until logins are done, before determining secs until start		       END;    IF now THEN PostLine[verbose, "Starting now."L]    ELSE      BEGIN      s.length ¬ 0;      String.AppendDecimal[s, hours];      PostString[terse, "Start at "L, s, ":"L];      s.length ¬ 0;      String.AppendDecimal[s, minutes];      PostLine[terse, s, "."L];      END;    token ¬ Token.FreeTokenString[token];    token ¬ Token.Filtered[h, @tData, AlphaColonSlash];    EXITS      now =>        BEGIN        PostString[fatal, "Starting now."L, " Can't parse start time"L];        SIGNAL ParseError        END;    }    END;  -- ReadStartTime  ReadStopTime: PROCEDURE =    BEGIN    s: LONG STRING;    hours, minutes: INTEGER;    time: System.GreenwichMeanTime  -- 24 hrs from now --       ¬ System.GreenwichMeanTime[Time.Current[] + 86400];    day: Time.Unpacked ¬ Time.Unpack[time];    token ¬ Token.FreeTokenString[token];    s ¬ token ¬ Token.MaybeQuoted[h, NIL, AlphaNumericColon, Token.Brackets];    IF s = NIL THEN GOTO bad;    [hours, minutes] ¬ BrownieOps.MakeTime[s ! String.InvalidNumber => GOTO bad];    IF hours >= day.hour THEN  -- if stop time is later today stop today,      day ¬ Time.Unpack[Time.defaultTime];  -- else stop tomorrow    day.hour ¬ hours;    day.minute ¬ minutes;    day.second ¬ 0;    data.stop ¬ Time.Pack[day, FALSE];    s.length ¬ 0;    Time.Append[s, day];    PostLine[terse, "Stop at "L, s, "."L];    token ¬ Token.FreeTokenString[token];    token ¬ Token.Filtered[h, @tData, AlphaColonSlash];    EXITS      bad =>        BEGIN        PostLine[fatal, "Will stop when finished."L, " Can't parse stop time"L];        SIGNAL ParseError        END;    END;  -- ReadStopTime  -- *******************************************************  -- Parsing Commands Stuff  -- The three commands available are:  --  -- copy/switches QualifiedFileName/nsSwitch ¬ QualifiedFileName/nsSwitch  -- rename/switches QualifiedFileName/nsSwitch ¬ QualifiedFileName/nsSwitch  -- delete/switches QualifiedFileName/nsSwitch  --  -- Switches available are:  -- COPY  --  /c 	connect to TARGET	(should be /t?)  --  /s 	connect to SOURCE  --  /u 	UPDATE	(as in FTP)	(Should add '>' for FTP compatibility )  --  /a	ALWAYS  (as in FTP)	  -- RENAME  --    -- These are the acutal commands that do the file transfer operations.  -- we've decided to allow no verification for the delete operation.      -- Boolean used in ReadOneFile to determine within the callee which invocation of the  -- procedure it is among that two cases that is used. This allows one to determine  -- whether the qualifiedFileName being read is a TARGET of a copy or not.      CommandRec: TYPE = RECORD [    SELECT type: CommandType FROM      copy => [target: BOOLEAN ¬ TRUE],      rename => NULL,       delete => NULL      ENDCASE   ];  ReadCommands: PROCEDURE RETURNS [cnt: CommandIndex] =    BEGIN    fromInfo, toInfo: InfoHandle ¬ NIL;    cmd: CommandRec;    -- Reads files for either copy, rename , or delete commands depending on (global) cmd type    ReadFiles: PROCEDURE =      BEGIN      ENABLE UNWIND => IF toInfo # NIL THEN z.FREE[@toInfo];            -- the break tells you what the FINAL CHARACTER read was.      -- so if it is a ¬/, we have a SWITCH on our hands.            sw: BOOLEAN ¬ (h.break = '/);      -- Need to process some switches.            IF sw THEN {        token ¬ Token.FreeTokenString[token];        token ¬ Token.Filtered[h, @tData, Token.Switches];        WITH cmd SELECT FROM          copy => ProcessCopySwitches[token];          rename => ProcessRenameSwitches[token];          delete => ProcessDeleteSwitches[token];          ENDCASE;        };            -- In any case, go ahead and read the first file name.      -- This occurs in all cases.            ReadOneFile[infoPtr: @toInfo, cmdPtr: @cmd];            -- Must be selective about reading the rest of the command      -- line depending on the command since we have a variable number      -- of parameters. (Delete has only one)            WITH cmd SELECT FROM        copy, rename 	=> 		BEGIN 			ReadBackArrow[];			ReadOneFile[infoPtr: @fromInfo, cmdPtr: @cmd];		END;	 delete 	=> NULL;				ENDCASE;	      END;  -- ReadCopyFiles    -- Read a qualified FILE NAME into infoPtr, with state info in cmdPtr.    -- This procedure is called TWICE, depending on the command being used.        ReadOneFile: PROCEDURE [      infoPtr: POINTER TO InfoHandle, cmdPtr: POINTER TO CommandRec] =      BEGIN      vfn: FileName.VirtualFilename ¬ NIL;      st: FileTransfer.ServerType;      BEGIN      ENABLE UNWIND => IF vfn # NIL THEN FileName.FreeVFN[vfn];      SetUseBreak["[¬"L];      token ¬ Token.FreeTokenString[token];      token ¬ Token.MaybeQuoted[h, @tData, Token.FileName];            IF token = NIL THEN {      	PostString[fatal, "Bad file name"L]; SIGNAL ParseError	};	      WITH cmdPtr SELECT FROM        copy => 		      -- The target should be true the first time this is called for a copy	      -- operation since that is the default, but the second time around,	      -- it will be set to FALSE. 	      	      IF target THEN {	-- if called the FIRST TIME		--  then shorten the file name if it has a trainling '*		IF token[token.length - 1] = '* THEN token.length ¬ token.length - 1;		target ¬ FALSE	      }	      ELSE  {  -- if CALLED the SECOND TIME? 		IF token[token.length - 1] = '> THEN String.AppendChar[token, '*];	      };	      	rename =>  -- Can't do an ambigious rename... 	      IF HasWildCard[token] THEN {		PostString[fatal, "* not allowed in Rename"L]; SIGNAL ParseError};			delete => -- No particular restriction to the file name being deleted.		  -- But may want to add this capability:		  -- if the filename is of form: [host]<dir> 		  -- then expand this to form:   [host]<dir>*	  	 	NULL;		        ENDCASE;      vfn ¬ FileName.AllocVFN[        token !	    FileName.Error => {	      PostString[fatal, "Bad file name"L]; 	      SIGNAL ParseError	      }      ];      IF String.Empty[vfn.host] OR String.Empty[vfn.directory] THEN {        PostString[fatal, "Bad file name"L]; 	SIGNAL ParseError	};      st ¬ DetermineServerType[vfn.host];            infoPtr­ ¬ z.NEW[Info];            (infoPtr­)­ ¬ [        logInIndex: ---- , connectIndex: ---- , serverType: st, vfn: vfn];      END      END;  -- ReadFile    DetermineServerType: PROC [host: LONG STRING]      RETURNS [st: FileTransfer.ServerType ¬ null] =      BEGIN      ProcessFileSwitches: PROC [switches: LONG STRING]        RETURNS [st: FileTransfer.ServerType ¬ null] = {        nsSwitch, flag: BOOLEAN ¬ TRUE;        IF String.Empty[switches] THEN RETURN[null];        FOR i: CARDINAL IN [0..switches.length) DO          msg: STRING ¬ [1];          SELECT switches[i] FROM            'n, 'N => nsSwitch ¬ flag;            'p, 'P => nsSwitch ¬ ~flag;            '~, '- => flag ¬ ~flag;            ENDCASE => {              String.AppendChar[msg, switches[i]];              PostString[fatal, "Illegal switch: "L, msg];              SIGNAL ParseError}          ENDLOOP;	RETURN[IF nsSwitch THEN ns ELSE ifs]};      IF (h.break = '/) THEN {        token ¬ Token.FreeTokenString[token];        token ¬ Token.Filtered[h, @tData, Token.Switches];        st ¬ ProcessFileSwitches[token]};      END;    ReadBackArrow: PROCEDURE =      BEGIN      SetUseBreak["[¬"L];      token ¬ Token.FreeTokenString[token];      token ¬ Token.Filtered[h, @tData, BackArrow];      END;    CommandFailure: PROCEDURE [n: CARDINAL] =      BEGIN      s: STRING ¬ [10];      errorsEncountered ¬ errorsEncountered + 1;      String.AppendNumber[s, n + 1];      PostLine[fatal, " in command line #"L, s, "."L];      SkipLine[];      token ¬ Token.FreeTokenString[token];      token ¬ Token.Filtered[h, @tData, Token.AlphaNumeric]      END;    -- ******************************************    --         BEGIN  ReadCommands     -- ******************************************    PostLine[verbose, "Reading Commands.  "];    cnt ¬ 0;  -- counts legal commands            -- Read all commands until the end of the file.    -- currently, no comments are allowed in there...        FOR i: CARDINAL ¬ 0, i + 1 UNTIL endOfFile DO      ENABLE Stream.EndOfStream => EXIT;            -- reset global swithches..            ResetSwitches[];      IF cnt > LENGTH[data.commands] THEN {  -- should reallocate storage for array        PostLine[          fatal, "Too many Command records.  "L, "Ignoring an extra one.  "L];        token ¬ Token.FreeTokenString[token];        token ¬ Token.Filtered[h, @tData, Token.AlphaNumeric];        LOOP};      SELECT TRUE FROM        token = NIL => {          	PostString[fatal, "No command specified"L]; 		CommandFailure[i]; 		LOOP		};        String.EquivalentString[token, "copy"L] => {          	cmd ¬ [copy[]]; 		ReadFiles[ ! ParseError => {CommandFailure[i];LOOP}]		};        String.EquivalentString[token, "rename"L] => {          	cmd ¬ [rename[]]; 		ReadFiles[ ! ParseError => {CommandFailure[i]; LOOP}]		};	String.EquivalentString[token, "delete"L] => {          	cmd ¬ [delete[]]; 		ReadFiles[ ! ParseError => {CommandFailure[i]; LOOP}]		};	ENDCASE => {	      PostString[fatal, "Illegal command"L]; 	      CommandFailure[i];	      LOOP -- to next command and don't process comment	      };	      	        SELECT cmd.type FROM        -- Set the command with the parameters set with the boolean flags!        copy =>		data.commands[cnt] ¬ Command[fromInfo, toInfo, copy[always, update]];        rename =>		data.commands[cnt] ¬ Command[fromInfo, toInfo, rename[all, update]];	delete =>	-- the toInfo will be blank...		data.commands[cnt] ¬ Command[fromInfo, toInfo, delete[all]];        ENDCASE;	      -- Abort key hit?            CheckAbort[];            IF data.queryForLogin THEN PromptAndGetLogins[cnt];      cnt ¬ cnt + 1;      token ¬ Token.FreeTokenString[token];      token ¬ Token.Filtered[h, @tData, Token.Alphabetic];      ENDLOOP;    RETURN[cnt];    END;  -- ReadCommands   ProcessCopySwitches: PROCEDURE [switches: LONG STRING] =    BEGIN    flag: BOOLEAN ¬ TRUE;    IF String.Empty[switches] THEN RETURN;    FOR i: CARDINAL IN [0..switches.length) DO      msg: STRING ¬ [1];      SELECT switches[i] FROM        'a, 'A => always ¬ flag;        'u, 'U => update ¬ flag;        'c, 'C => destConnect ¬ flag;        's, 'S => sourceConnect ¬ flag;        '~, '- => flag ¬ ~flag;        ENDCASE => {          String.AppendChar[msg, switches[i]];          PostString[fatal, "Illegal switch: "L, msg];          SIGNAL ParseError}      ENDLOOP;    END;  -- ProcessCopySwitches   ProcessRenameSwitches: PROCEDURE [switches: LONG STRING] =    BEGIN    flag: BOOLEAN ¬ TRUE;    IF String.Empty[switches] THEN RETURN;    FOR i: CARDINAL IN [0..switches.length) DO      msg: STRING ¬ [1];      SELECT switches[i] FROM        'c, 'C => destConnect ¬ flag;        'a, 'A => all ¬ flag;        'u, 'U => update ¬ flag;        ENDCASE => {          String.AppendChar[msg, switches[i]];          PostString[fatal, "Illegal switch: "L, msg];          SIGNAL ParseError}      ENDLOOP;    END;  -- ProcessRenameSwitches        ProcessDeleteSwitches: PROCEDURE [switches: LONG STRING] =    BEGIN    flag: BOOLEAN ¬ TRUE;    IF String.Empty[switches] THEN RETURN;    FOR i: CARDINAL IN [0..switches.length) DO      msg: STRING ¬ [1];      SELECT switches[i] FROM        'a, 'A => all ¬ flag;        'c, 'C => destConnect ¬ flag;        ENDCASE => {          String.AppendChar[msg, switches[i]];          PostString[fatal, "Illegal switch: "L, msg];          SIGNAL ParseError}      ENDLOOP;    END;  ResetSwitches: PROCEDURE =    BEGIN    all ¬ FALSE;    always ¬ TRUE;    update ¬ FALSE;    destConnect ¬ FALSE;    sourceConnect ¬ FALSE    END;  PromptAndGetLogins: PROCEDURE [command: ParseDefs.CommandIndex] =    BEGIN    ENABLE      String.StringBoundsFault => {        BrownieOps.PostLine[fatal, "String too long!"L]; ERROR ABORTED};    SetLogin: PROC [info: ParseDefs.InfoHandle]      RETURNS [index: ParseDefs.LogInIndex] =      BEGIN      userName: STRING ¬ [50];      password: STRING ¬ [20];      AppendName: PROC [name, password: LONG STRING] = {        String.AppendString[userName, name]};      ok: BOOLEAN;      [index, ok] ¬ FindLogIn[info.vfn.host];      -- IF index >= LENGTH[data.logIns] THEN {do the right stuff};      IF ~ok THEN {        TTY.PutString[ttyH, "Login for ["L];        TTY.PutString[ttyH, info.vfn.host];        TTY.PutString[ttyH, "] --> "L];        Profile.GetUser[AppendName];        BrownieOps.Login[userName, password, "Name: "L];        data.logIns[index].hostID ¬ BrownieOps.Copy[info.vfn.host];        data.logIns[index].loginName ¬ BrownieOps.Copy[userName];        data.logIns[index].loginPassword ¬ BrownieOps.Copy[password];        data.logInCnt ¬ data.logInCnt + 1;        TTY.PutCR[ttyH]}      END;    SetConnect: PROC [info: ParseDefs.InfoHandle] =      BEGIN      found: BOOLEAN;      connName: STRING ¬ [50];      connPassword: STRING ¬ [20];      MakeConnectName[info.vfn.directory, connName];      [info.connectIndex, found] ¬ FindConnect[info.vfn.host, connName];      IF ~found THEN {  -- get secondary credentials        BrownieOps.Login[connName, connPassword, "Connect: "L];        info.connectIndex.host ¬ BrownieOps.Copy[info.vfn.host];        info.connectIndex.connectName ¬ BrownieOps.Copy[connName];        info.connectIndex.connectPassword ¬ BrownieOps.Copy[connPassword];        TTY.PutCR[ttyH]}      END;    -- One needs to prompt for both the source and the destination when doing    -- a copy or a rename, but not for the delete operation.        SELECT data.commands[command].type FROM    rename, copy => 	BEGIN	data.commands[command].to.logInIndex ¬ SetLogin[data.commands[command].to];        data.commands[command].from.logInIndex ¬ SetLogin[data.commands[command].from];			END;    delete =>		BEGIN	data.commands[command].to.logInIndex ¬ SetLogin[data.commands[command].to];			END;    ENDCASE;        IF destConnect THEN SetConnect[data.commands[command].to];    IF sourceConnect THEN SetConnect[data.commands[command].from];    END;  -- PromptAndGetLogins  -- *******************************************************  -- Called after logins are done to get accurate start time  SetStartTime: PROCEDURE = INLINE    BEGIN data.start ¬ BrownieOps.SecondsTilTime[hours, minutes] END;  -- *******************************************************  -- Some Utility Procedures  CheckAbort: PROCEDURE =    BEGIN     	IF TTY.UserAbort[BrownieOps.ttyH] 	THEN ERROR ABORTED    END;  FindLogIn: PROCEDURE [host: LONG STRING]    RETURNS [index: ParseDefs.LogInIndex, found: BOOLEAN] =    BEGIN    i: CARDINAL;    FOR i IN [0..data.logInCnt) DO      IF String.EquivalentString[host, data.logIns[i].hostID] THEN        RETURN[i, TRUE];      ENDLOOP;    RETURN[data.logInCnt, FALSE]    END;  FindConnect: PROCEDURE [host, directory: LONG STRING]    RETURNS [ptr: ConnectPtr, found: BOOLEAN] =    BEGIN    q: ConnectPtr ¬ data.connects;    IF data.connects = NIL THEN {      data.connects ¬ z.NEW[Connect ¬ [NIL, NIL, NIL, NIL]];      RETURN[data.connects, FALSE]    };        FOR p: ConnectPtr ¬ data.connects, p.next UNTIL p = NIL DO      IF String.EquivalentString[host, p.host]        AND String.EquivalentString[directory, p.connectName]       THEN RETURN[p, TRUE];      q ¬ p      ENDLOOP;    ptr ¬ z.NEW[Connect ¬ [NIL, NIL, NIL, NIL]];    q.next ¬ ptr;    RETURN[ptr, FALSE]    END;  MakeConnectName: PROCEDURE [dir, name: LONG STRING] =    BEGIN  -- strips off the subdirectories of a directory name    i, j: CARDINAL;    i ¬ IF dir[0] = '< THEN 1 ELSE 0;    FOR j IN [i..dir.length) DO      IF dir[j] # '> THEN String.AppendChar[name, dir[j]] ELSE EXIT ENDLOOP;    END;  HasWildCard: PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN] = {    FOR i: CARDINAL IN [0..s.length) DO IF s[i] = '* THEN RETURN[TRUE] ENDLOOP;    RETURN[FALSE]};  -- Use the break character as input if it appears in chars  SetUseBreak: PROCEDURE [chars: LONG STRING] =    BEGIN    FOR i: CARDINAL IN [0..chars.length) WHILE NOT useBreak DO      useBreak ¬ (chars[i] = h.break) ENDLOOP    END;  SkipLine: PROCEDURE = INLINE {    IF h.break # Ascii.CR THEN Token.Skip[h, NIL, Token.Line]; };  PostAnyCommand: PROCEDURE [    dH: DataHandle, num: CommandIndex, title: STRING, updateNow: BOOLEAN ¬ TRUE] =    BEGIN OPEN cmd: dH.commands[num];    l: Level = IF updateNow THEN terse ELSE verbose;        WITH c: cmd SELECT FROM    copy, rename =>      	BEGIN        -- posting the source source file server NAME        --[ Server     	PostString[l, title, " ["L, cmd.from.vfn.host];	 -- posting the source file server TYPE         -- [ Server (TYPE)        PostString[	    l,	    SELECT cmd.from.serverType FROM	      ns => " (NS)"L,	      ifs => " (IFS)"L	      ENDCASE => NIL];          --  [ Server (TYPE) ]<Directory>    	PostString[l, "]"L, cmd.from.vfn.directory, ">"L];		-- [ Server (TYPE) ]<Directory>FileName		PostString[l, cmd.from.vfn.name];		-- [ Server (TYPE) ]<Directory>FileName to    		PostString[l, " to ["L, NIL, NIL];	END;    delete => PostString[l, "["L, NIL, NIL];    ENDCASE;    PostString[l, cmd.to.vfn.host, NIL, NIL];        -- same stuff..        PostString[      l,      SELECT cmd.to.serverType FROM        ns => " (NS)"L,	ifs => " (IFS)"L        ENDCASE => NIL];    PostString[l, "]"L, cmd.to.vfn.directory, ">"L];        PostString[l, cmd.to.vfn.name];        -- list the options selected..        WITH c: cmd SELECT FROM      copy =>        PostLine[          l, IF c.always THEN ", Always"L ELSE NIL,          IF c.update THEN ", Update"L ELSE NIL];      rename =>        PostLine[          l, IF c.all THEN ", All Versions"L ELSE NIL,          IF c.update THEN ", Update"L ELSE NIL];      delete =>        PostLine[          l, IF c.all THEN ", All Versions"L ELSE NIL]	ENDCASE;    END;              -- Feedback that looks like this:  -- Will copy [Igor (IFS)]<Conde>Source>BrownieTest.brownie to [Igor (IFS)]<Conde>target>BrownieTest.brownie, Always, Update  PostCommand: PUBLIC PROCEDURE [    dH: DataHandle, num: CommandIndex, updateNow: BOOLEAN ¬ TRUE] =    BEGIN OPEN String;    msg: STRING ¬ [20];    SELECT dH.commands[num].type FROM      copy =>        IF ~updateNow THEN AppendString[msg, "Will copy"L]        ELSE AppendString[msg, "Starting copy of"L];      rename =>        IF ~updateNow THEN AppendString[msg, "Will rename"L]        ELSE AppendString[msg, "Starting rename of"L];      delete =>        IF ~updateNow THEN AppendString[msg, "Will delete"L]        ENDCASE;    PostAnyCommand[dH, num, msg, updateNow];    END;  PostCommandsAndLogins: PROCEDURE =    BEGIN    num: STRING ¬ [10];    String.AppendNumber[num, data.commandCnt];    PostString[verbose, CR];    FOR i: CommandIndex IN [0..data.commandCnt) DO      PostCommand[@data, i, FALSE] ENDLOOP;    PostLine[      terse, num, " command"L, IF data.commandCnt > 1 THEN "s"L ELSE NIL,      " read."L];    PostString[verbose, CR];    num.length ¬ 0;    String.AppendNumber[num, data.logInCnt];    FOR j: LogInIndex IN [0..data.logInCnt) DO      OPEN data.logIns[j];      PostString[verbose, "Host = """L, hostID, """, login name = """L, loginName];      PostLine[verbose, """"L];      ENDLOOP;    PostLine[      terse, num, " login"L, IF data.logInCnt > 1 THEN "s"L ELSE NIL, " read.\n"L];    END;  ProcessGlobalSwitches: PROCEDURE [    data: ParseDefs.DataHandle, switches: LONG STRING] =    BEGIN    flag: BOOLEAN ¬ TRUE;    IF String.Empty[switches] THEN RETURN;    FOR i: CARDINAL IN [0..switches.length) DO      sw: STRING ¬ [1];      SELECT switches[i] FROM        'q, 'Q => data.queryForLogin ¬ flag;        '~, '- => flag ¬ ~flag;        ENDCASE => {          String.AppendChar[sw, switches[i]];          PostLine[fatal, "Illegal switch, "L, sw, ", ignored.L"]}      ENDLOOP;    END;  -- ProcessGlobalSwitches  CleanUp: PROCEDURE =    BEGIN    IF token # NIL THEN token ¬ Token.FreeTokenString[token];    z.FREE[@h];    END;  -- *******************************************************  --  Public Stuff  z: PUBLIC UNCOUNTED ZONE;  ParseCommands: PUBLIC PROCEDURE [    stream: Stream.Handle, globalSwitches: LONG STRING]    RETURNS [dH: DataHandle, nErrors: CARDINAL ¬ 0] =    BEGIN    ENABLE { Stream.EndOfStream => {CleanUp[]; GOTO return}; UNWIND => CleanUp[]};    h ¬ z.NEW[Token.Object ¬ [getChar: GetChar]];    data ¬ [      start: 0, stop: System.GreenwichMeanTime[LAST[LONG CARDINAL]], logInCnt: 0,      commandCnt: 0,      logIns: DESCRIPTOR[Heap.MakeNode[z, nLogins * SIZE[LogIn]], nLogins],      commands: DESCRIPTOR[Heap.MakeNode[z, nCommands * SIZE[Command]], nCommands],      connects: NIL,      queryForLogin: TRUE];          sHin ¬ stream;    useBreak ¬ endOfFile ¬ FALSE;    errorsEncountered ¬ 0;        ProcessGlobalSwitches[data: @data, switches: globalSwitches];    token ¬ Token.MaybeQuoted[h: h, data: NIL, filter: AlphaColonSlash, isQuote: Token.Brackets];    -- Read items such as start time, stop time, and comments (which are considered to be parameters???)    -- I plan to allow comments ANYWHERE soon.    ReadParameters[];        -- Get the commands, such as Copy, Rename, or Delete.     data.commandCnt ¬ ReadCommands[];    IF ~startNow THEN SetStartTime[];    PostCommandsAndLogins[];    CleanUp[];    RETURN[dH: @data, nErrors: errorsEncountered];    EXITS return => RETURN[@data, nErrors];    END;  --ParseCommands	  END.    12-Mar-84 16:17:14	DSC  	added Delete command plus more comments 3-Oct-84 13:24:54	DSC  	removed interior comments with MY name on it. 12-Feb-87 15:23:51	bjd  	changed DetermineServerType to default to ns.
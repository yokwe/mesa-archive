-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- BrowniesC.mesa - last edited by:-- BJD    	12-Oct-83 15:37:38-- primitives for NS Brownie Queue manipulationDIRECTORY  BrownieQOps USING [FileAttributes, FileAttributesRecord, PtrQE, Q, QHead],  NSFile USING [Attributes],  NSString USING [CopyString, FreeString],  ParseDefs USING [z],  Process USING [InitializeCondition, EnableAborts, SecondsToTicks];    BrowniesC: MONITOR LOCKS q USING q: Q  IMPORTS NSString, ParseDefs, Process   EXPORTS BrownieQOps =  BEGIN OPEN BrownieQOps;    Q: TYPE = BrownieQOps.Q;  QHead: TYPE = BrownieQOps.QHead;    maxQCount: CARDINAL = 100;  untilQGetsSmaller: CONDITION;  IsEmpty: PUBLIC ENTRY PROCEDURE [q: Q] RETURNS [BOOLEAN] = {    RETURN[q = NIL OR q.front = NIL]};  IsEmptyInternal: INTERNAL PROCEDURE [q: Q]    RETURNS [BOOLEAN] = {RETURN[q = NIL OR q.front = NIL]};  GetFront: PUBLIC ENTRY PROCEDURE [q: Q] RETURNS [qf: PtrQE] =    BEGIN ENABLE UNWIND => NULL;    WHILE IsEmptyInternal[q] AND ~q.finished DO      WaitForQElement[q]      ENDLOOP;    IF IsEmptyInternal[q] THEN RETURN[NIL];    qf ¬ q.front;    q.front ¬ q.front.link;    q.count ¬ q.count - 1;    END;  PutRear: PUBLIC ENTRY PROCEDURE [q: Q, qe: PtrQE] =    BEGIN    IF q.front = NIL THEN q.front ¬ q.rear ¬ qe    ELSE {      q.rear.link ¬ qe;      q.rear ¬ qe};    NotifyQElementAvail[q];    q.count ¬ q.count + 1    END;          FreeQ: PUBLIC PROC [q: LONG POINTER TO Q] = {    IF q­ # NIL THEN {      IF q­.front # NIL THEN FreeElements[q­];      ParseDefs.z.FREE[q]}};        FreeElements: PROC [q: Q] = {    i,j: PtrQE ¬ NIL;    FOR i ¬ q.front, j UNTIL i=NIL DO      j ¬ i.link;      FreeQueueElement[i]      ENDLOOP};  FreeQueueElement: PUBLIC PROCEDURE [qe: PtrQE] =     BEGIN    MyFreeAttributes[qe.fileAttributes];    ParseDefs.z.FREE[@qe]    END;  SetFinished: PUBLIC ENTRY PROC [q: Q, finished: BOOLEAN] = {    q.finished ¬ finished;    NOTIFY q.available};      NotifyQElementAvail: INTERNAL PROC [q: Q] = {    q.isAvailable ¬ TRUE;    NOTIFY q.available};    WaitForQElement: INTERNAL PROC [q: Q] =    BEGIN    WHILE ~q.finished AND ~q.isAvailable DO      WAIT q.available ENDLOOP;    q.isAvailable ¬ FALSE    END;    WaitUntilQGetsSmaller: PUBLIC ENTRY PROC [q: Q] =    BEGIN ENABLE UNWIND => NULL;    WHILE q.count > maxQCount DO      WAIT untilQGetsSmaller      ENDLOOP;    END;    InitializePause: PUBLIC PROCEDURE [secs: CARDINAL] = {    Process.InitializeCondition[@untilQGetsSmaller, Process.SecondsToTicks[secs]];    Process.EnableAborts[@untilQGetsSmaller]};  MyCopyAttributes: PUBLIC PROC [attributes: NSFile.Attributes]     RETURNS [fileAttributes: BrownieQOps.FileAttributes] = {    fileAttributes ¬ ParseDefs.z.NEW[FileAttributesRecord ¬ [      name: NSString.CopyString[ParseDefs.z, attributes.name],      pathname: ParseDefs.z.NEW[StringBody[20]],      version: attributes.version,      type: attributes.type,      sizeInBytes: attributes.sizeInBytes,      createdOn: attributes.createdOn,      fileID: attributes.fileID]]};      MyFreeAttributes: PUBLIC PROC [fileAttributes: BrownieQOps.FileAttributes] = {    NSString.FreeString[ParseDefs.z, fileAttributes.name];    ParseDefs.z.FREE[@fileAttributes.pathname];    ParseDefs.z.FREE[@fileAttributes]};              END.      
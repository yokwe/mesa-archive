-- File: BrowniesA.mesa - last edit:-- bjd                 13-Feb-87 11:07:54-- Brownie Utility stuff-- Copyright (C) 1983, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Ascii USING [CR],  BrownieOps USING [ErrorCode, Level],  Exec USING [GetNameandPassword, Handle],  Inline USING [LongDivMod],  MStream USING [Handle, Error, Log, ReadOnly],  ParseDefs USING [z],  Process USING [Pause, SecondsToTicks],  Runtime USING [GetBcdTime],  Stream USING [Handle, PutChar],  String USING [    AppendChar, AppendString, EmptyString, StringBoundsFault, StringToDecimal],  System USING [GreenwichMeanTime],  Time USING [Append, AppendCurrent, defaultTime, Unpacked, Unpack],  TTY USING [Handle, PutCR, PutString, Rubout],  Version USING [Append];BrowniesA: PROGRAM  IMPORTS    Exec, Inline, MStream, ParseDefs, Process, Runtime, Stream,    String,Time, TTY, Version  EXPORTS BrownieOps =  BEGIN OPEN BrownieOps;  InitVariables: PUBLIC PROCEDURE = BEGIN logFile ¬ NIL; END;  MakeTime: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [hours, minutes: CARDINAL] =    BEGIN    i: CARDINAL;    num: STRING ¬ [2];    FOR i ¬ 0, i + 1 UNTIL i = 2 OR i + 2 = s.length DO      IF s[i] = ': THEN EXIT; String.AppendChar[num, s[i]]; ENDLOOP;    hours ¬ String.StringToDecimal[num];    num.length ¬ 0;    IF s[i] = ': THEN i ¬ i + 1;    FOR i ¬ i, i + 1 UNTIL i = s.length DO      String.AppendChar[num, s[i]]; IF num.length = 2 THEN EXIT; ENDLOOP;    minutes ¬ String.StringToDecimal[num];    END;  SecondsTilTime: PUBLIC PROCEDURE [hour, minute: CARDINAL]    RETURNS [seconds: LONG INTEGER] =    BEGIN    now: Time.Unpacked ¬ Time.Unpack[Time.defaultTime];    minToT: LONG INTEGER ¬ (hour MOD 24) * 60 + MIN[minute, 59];    minToT ¬ minToT - (now.hour * 60 + now.minute);    IF minToT < 0 THEN minToT ¬ minToT + 60 * 24;  -- start tomorrow    RETURN[minToT * 60]    END;  -- **********************************  --  String Stuff  Copy: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [s1: LONG STRING] =    BEGIN    IF String.EmptyString[s] THEN RETURN[NIL];    s1 ¬ (ParseDefs.z).NEW[StringBody [s.length]];    String.AppendString[s1, s]    END;  StringCopy: PUBLIC PROCEDURE [s: LONG STRING, t: LONG STRING] = {    IF String.EmptyString[t] THEN s.length ¬ 0    ELSE {      FOR i: CARDINAL IN [0..t.length) DO s[i] ¬ t[i]; ENDLOOP;      s.length ¬ t.length}};  -- ***********************************  -- Input/Output, PostString, PostLine stuff  eH: PUBLIC Exec.Handle;  Login: PUBLIC PROCEDURE [    name, password: LONG STRING, prompt: LONG STRING ¬ NIL] =    BEGIN    Exec.GetNameandPassword[      eH, name, password, prompt ! TTY.Rubout => GOTO quit;      String.StringBoundsFault => {        PostLine[fatal, "String too long! "L]; GOTO quit}];    EXITS quit => ERROR ABORTED;    END;  messageSeverityLevel: Level;  severityOfLastMessage: Level;  startingNewLine: BOOLEAN;  lineHeaders: ARRAY Level OF LONG STRING = ["", "", "", "** Error: "];  levelNames: PUBLIC ARRAY Level OF LONG STRING = [    "Verbose"L, "Terse"L, "Warning"L, "Fatal"L];  GetLevel: PUBLIC PROCEDURE RETURNS [l: Level] =    BEGIN RETURN[messageSeverityLevel] END;  SetLevel: PUBLIC PROCEDURE [l: Level] = BEGIN messageSeverityLevel ¬ l END;  ttyH: PUBLIC TTY.Handle;  logFile: MStream.Handle;  Write: PUBLIC PROCEDURE [s: LONG STRING] =    BEGIN    IF s = NIL THEN RETURN;    TTY.PutString[ttyH, s];    IF logFile # NIL THEN      FOR i: CARDINAL IN [0..s.length) DO Stream.PutChar[logFile, s[i]]; ENDLOOP;    END;  Writeln: PUBLIC PROCEDURE [s: LONG STRING ¬ NIL] =    BEGIN    Write[s];    TTY.PutCR[ttyH];    IF logFile # NIL THEN Stream.PutChar[logFile, Ascii.CR];    END;  PostString: PUBLIC --ENTRY-- PROCEDURE [    l: Level, s1, s2, s3, s4: LONG STRING ¬ NIL] =    BEGIN DoIt[l, s1, s2, s3, s4] END;  PostLine: PUBLIC --ENTRY-- PROCEDURE [    l: Level, s1, s2, s3, s4: LONG STRING ¬ NIL] =    BEGIN    DoIt[l, s1, s2, s3, s4];    IF l < messageSeverityLevel THEN RETURN;    Writeln[];    startingNewLine ¬ TRUE    END;  DoIt: PROCEDURE [l: Level, s1, s2, s3, s4: LONG STRING] =    BEGIN    IF l < messageSeverityLevel THEN RETURN;    Indent[l];    IF s1 ~= NIL THEN Write[s1];    IF s2 ~= NIL THEN Write[s2];    IF s3 ~= NIL THEN Write[s3];    IF s4 ~= NIL THEN Write[s4]    END;  Indent: PROCEDURE [lev: Level] =    BEGIN    IF startingNewLine THEN      BEGIN startingNewLine ¬ FALSE; Write[lineHeaders[lev]]; END    ELSE      IF (lev = fatal) AND (lev # severityOfLastMessage) THEN        BEGIN  -- force a new line        Writeln[];        Write[lineHeaders[lev]];        END;    severityOfLastMessage ¬ lev;    END;  -- ***********************************  -- BrownieControl Utilities  Error: PUBLIC SIGNAL [kind: BrownieOps.ErrorCode] = CODE;  WaitAround: PUBLIC PROCEDURE [seconds: LONG INTEGER] =    BEGIN    SecsPer30Mins: CARDINAL = 60 * 30;    ticks, remainder, intervals: CARDINAL;    secs: LONG CARDINAL;    IF seconds < 0 THEN RETURN;    secs ¬ LOOPHOLE[seconds, LONG CARDINAL];    [intervals, remainder] ¬ Inline.LongDivMod[secs, SecsPer30Mins];    ticks ¬ Process.SecondsToTicks[SecsPer30Mins];    FOR i: CARDINAL IN [0..intervals) DO Process.Pause[ticks] ENDLOOP;    ticks ¬ Process.SecondsToTicks[remainder];    Process.Pause[ticks];    END;  WriteHerald: PUBLIC PROCEDURE =    BEGIN OPEN Time;    time: STRING ¬ [18];    herald: STRING ¬ [25];    String.AppendString[herald, "Brownie "L];    Version.Append[herald];    Append[time, Unpack[Runtime.GetBcdTime[]]];    PostLine[terse, herald, " of "L, time];    time.length ¬ 0;    AppendCurrent[time];    PostLine[terse, time];    END;  OpenScriptFile: PUBLIC PROCEDURE [name: LONG STRING]    RETURNS [sh: Stream.Handle] =    BEGIN    fileName: LONG STRING;    triedNoExt: BOOLEAN ¬ FALSE;    IF String.EmptyString[name] THEN SIGNAL Error[normal];    fileName ¬ ParseDefs.z.NEW[StringBody [name.length + 8]];    String.AppendString[fileName, name];    String.AppendString[fileName, ".brownie"L];    sh ¬ MStream.ReadOnly[      fileName, [] !      MStream.Error =>        SELECT code FROM          fileNotAvailable =>            IF triedNoExt THEN SIGNAL Error[fileNotFound]            ELSE {              triedNoExt ¬ TRUE;              ParseDefs.z.FREE[@fileName];              fileName ¬ name;              RETRY};          ENDCASE];    END;  OpenLogFile: PUBLIC PROCEDURE =    BEGIN    logName: STRING = [50];    String.AppendString[logName, "Brownie.log"L];    WHILE logFile = NIL AND logName.length < logName.maxlength DO      logFile ¬ MStream.Log[        logName, [] ! MStream.Error => {String.AppendChar[logName, 'X]; CONTINUE}];      ENDLOOP    END;  CloseLogFile: PUBLIC PROCEDURE =    BEGIN OPEN BrownieOps;    IF logFile # NIL THEN logFile.delete[logFile];    logFile ¬ NIL    END;  HasWildCard: PUBLIC PROC [name: LONG STRING] RETURNS [BOOLEAN] = {    IF name = NIL THEN RETURN[FALSE];    FOR i: CARDINAL IN [0..name.length) DO      IF name[i] = '* THEN RETURN[TRUE]; ENDLOOP;    RETURN[FALSE]};  END.
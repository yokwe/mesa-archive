-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- FILE: BrownieControl.mesa-- Last edited by:-- BJD    	 13-Feb-87 11:56:16-- RKJ     	 9-Feb-83 11:31:13-- DSC  	 12-Mar-84 13:52:08  added Delete command.DIRECTORY  BrownieOps USING [    CloseLogFile, eH, Error, GetLevel, HasWildCard, InitVariables, Level, Login,    --OpenLogFile, -- OpenScriptFile, PostLine, PostString,    --ResetPrimitives, SetUpForNSCopy, -- ttyH, WaitAround, WriteHerald],  Cursor USING [Defined],  Exec USING [    AddCommand, FreeTokenString, GetToken, GetTTY, Handle, Outcome, OutputProc,    ReleaseTTY],  FileName USING [FreeVFN, VFN],  FileTransfer USING [    CheckAbortProc, ClientProc, CodeToString, Confirmation, Connection, Copy,    Create, Delete, Destroy, Enumerate, Error, FileInfo, ListProc, MessageProc, SetProcs,    SetDefaultServerType, SetPrimaryCredentials, SetSecondaryCredentials,    ServerType, VetoProc],  FileTransferOps USING [Connection],  FileTransferPupOps USING [PupClose, PupOpen],  FileTransferUtils USING [AppendVFN],  Heap USING [Create, Delete, systemZone],  HeraldWindow USING [    CursorState, FreeCursorSlot, GetCursorSlot, SetCursor, SetCursorState, Slot],  ParseDefs USING [    Command, CommandIndex, CommandType, DataHandle, LogInIndex, ParseCommands,    PostCommand, z],  STP USING [Error, ErrorCode, Handle, Rename],  Stream USING [Delete, Handle],  String USING [    AppendChar, AppendLongNumber, AppendNumber, AppendString, AppendStringAndGrow,    Empty, Equivalent, FreeString, Replace, StringBoundsFault],  Time USING [AppendCurrent, Current, Packed],  TTY USING [UserAbort];BrownieControl: MONITOR  -- to exclude multiple instances (Not re-entrant yet)   IMPORTS    BrownieOps, Exec, FileName, FileTransfer, FileTransferPupOps,    FileTransferUtils, Heap, HeraldWindow, ParseDefs, STP, Stream, String, Time,    TTY =  BEGIN  heap: UNCOUNTED ZONE = Heap.systemZone;  fileName, switches: LONG STRING;  sh: Stream.Handle;  dh: ParseDefs.DataHandle;  toConn, fromConn: FileTransfer.Connection ¬ NIL;  slot: HeraldWindow.Slot ¬ NIL;  cursorState: HeraldWindow.CursorState ¬ positive;  CR: LONG STRING = "";	-- Not using ASCII.CR since we need a string here.  maxFileName: CARDINAL = 100;  MyDataHandle: TYPE = LONG POINTER TO MyClientData;  MyClientData: TYPE = RECORD [    conn: FileTransfer.Connection, parseData: ParseDefs.DataHandle];  myTo, myFrom: MyDataHandle;  -- ***************************  --  Process Command Procedures  --  PostVerbose: FileTransfer.MessageProc =    BEGIN BrownieOps.PostString[level, s1, s2, s3, s4] END;  PostTerse: FileTransfer.MessageProc =    BEGIN    IF level >= warning THEN BrownieOps.PostString[level, s1, s2, s3, s4]    END;  CheckAbort: FileTransfer.CheckAbortProc    -- PROC[clientData:LONG POINTER]  RETURNS[abort: BOOLEAN] --  =    BEGIN    myData: MyDataHandle ¬ LOOPHOLE[clientData];    IF myData # NIL AND myData.parseData.stop # LAST[CARDINAL]      AND myData.parseData.stop <= Time.Current[] THEN {      time: STRING ¬ [18];      Time.AppendCurrent[time];      BrownieOps.PostLine[        terse, CR, "Time's up! Stopping Brownie at "L, time, "."L];      abort ¬ TRUE}    ELSE abort ¬ TTY.UserAbort[BrownieOps.ttyH];    END;  LoginAndSet: FileTransfer.ClientProc -- PROC[clientData:LONG POINTER] --  =    BEGIN    user: STRING ¬ [20];    password: STRING ¬ [20];    myH: MyDataHandle ¬ LOOPHOLE[clientData];    BrownieOps.Login[user, password];    FileTransfer.SetPrimaryCredentials[myH.conn, user, password];    END;  NoteProgress: FileTransfer.ClientProc =    BEGIN    IF cursorState = negative THEN {      HeraldWindow.SetCursor[slot, Cursor.Defined[ftpBoxes]]; cursorState ¬ invert}    ELSE HeraldWindow.SetCursorState[slot, cursorState];    END;  Result: TYPE = {win, closeAndRetry, reduceCredentials, protocolProblem, reject};  -- Process commands after the command line has been parsed and has no errors.  -- ParseDefs.DataHandle  contains all the data required for the command.    ProcessCommands: PROCEDURE [ptData: ParseDefs.DataHandle] =    BEGIN OPEN ptData­;    i: ParseDefs.CommandIndex;  		-- index into CommandArray    toI, fromI: ParseDefs.LogInIndex;   	-- index into LogInArray        -- variant records  designated to be:    copyCmd:    copy ParseDefs.Command;		-- of type copy	    renameCmd:  rename ParseDefs.Command;	-- of type rename    deleteCmd: delete ParseDefs.Command;	-- of type delete        singleFile: BOOLEAN ¬ FALSE;            DeleteFiles: PROCEDURE = {      total: CARDINAL ¬ 0;      sum: STRING ¬ [10];	      FileTransfer.Delete[        conn: toConn,	file: deleteCmd.to.vfn];      String.AppendNumber[sum, total ! String.StringBoundsFault => RESUME [NIL]];      IF ~singleFile THEN        BrownieOps.PostString[          terse, CR, "Total of "L, sum,          IF total = 1 THEN " file deleted."L ELSE " files deleted."L];      BrownieOps.PostString[terse, CR];    };        CopyFiles: PROCEDURE =      BEGIN      total, fileCnt: CARDINAL ¬ 0;      showDates: BOOLEAN ¬ BrownieOps.GetLevel[] = verbose;      directory: LONG STRING ¬ NIL;      sum: STRING ¬ [10];      source, target: FileTransfer.FileInfo;      TerseFeedback: PROC [c: FileTransfer.Confirmation] =        BEGIN        IF ~String.Equivalent[directory, source.directory] THEN {          fileCnt ¬ 0;          BrownieOps.PostString[            terse, IF directory = NIL THEN NIL ELSE CR, source.directory, ">"L]};        String.Replace[@directory, source.directory, ParseDefs.z];        SELECT c FROM          do => {            IF singleFile THEN              BrownieOps.PostString[terse, source.body, "...copying"L]            ELSE {              fileCnt ¬ fileCnt + 1;              IF fileCnt MOD 10 = 0 THEN {                num: STRING ¬ [10];                String.AppendNumber[                  num, fileCnt ! String.StringBoundsFault => RESUME [NIL]];                BrownieOps.PostString[terse, num]}              ELSE BrownieOps.PostString[terse, "."L]}};          skip =>            IF singleFile THEN BrownieOps.PostString[terse, source.body, " XXX"L]          ENDCASE       END;      VerboseFeedback: PROC [c: FileTransfer.Confirmation] = BEGIN END;      FilterProc: FileTransfer.VetoProc =        BEGIN        c: FileTransfer.Confirmation;        [source, target] ¬ info[conn];        IF ~target.oldFile THEN c ¬ IF copyCmd.always THEN do ELSE skip        ELSE          c ¬            SELECT TRUE FROM              copyCmd.update => IF source.create > target.create THEN do ELSE skip,              copyCmd.always => do,              ENDCASE => skip;        IF c = do THEN total ¬ total + 1;        SELECT BrownieOps.GetLevel[] FROM          verbose => VerboseFeedback[c];          terse => TerseFeedback[c];          ENDCASE;        RETURN[c, showingDates];        END;      {      ENABLE        UNWIND => NULL;          <<IF copyCmd.from.serverType = ns THEN            BrownieOps.ResetPrimitives[LOOPHOLE[fromConn]];>>      <<IF copyCmd.from.serverType = ns THEN        BrownieOps.SetUpForNSCopy[LOOPHOLE[fromConn]];>>      FileTransfer.Copy[        copyCmd.from.vfn, copyCmd.to.vfn, fromConn, toConn, FilterProc, showDates !	  FileTransfer.Error =>	    SELECT code FROM accessDenied, skipFile => RESUME ENDCASE => REJECT];      String.AppendNumber[sum, total ! String.StringBoundsFault => RESUME [NIL]];      IF ~singleFile THEN        BrownieOps.PostString[          terse, CR, "Total of "L, sum,          IF total = 1 THEN " file copied."L ELSE " files copied."L];      BrownieOps.PostString[terse, CR];      IF directory # NIL THEN ParseDefs.z.FREE[@directory];      <<IF copyCmd.from.serverType = ns THEN        BrownieOps.ResetPrimitives[LOOPHOLE[fromConn]];>>      }      END;    -- ******************************    -- End of Copy    -- ******************************            -- ******************************    --   Start of Renaming    -- ******************************    NSRenameFiles: PROCEDURE =      BEGIN      BrownieOps.PostLine[fatal, "NS Brownie rename not implemented."L, CR];      ERROR BrownieOps.Error[skip];      END;    PupRenameFiles: PROCEDURE =      BEGIN OPEN renameCmd;      new: LONG STRING ¬ [maxFileName];      nNew: CARDINAL;      oneFile: BOOLEAN ¬ ~String.Empty[from.vfn.name];      nameLength: CARDINAL =        IF from.vfn.name = NIL THEN 0 ELSE from.vfn.name.length;      dirLength: CARDINAL =        SELECT TRUE FROM          from.vfn.directory = NIL => 0,          from.vfn.directory[0] = '< => from.vfn.directory.length,          ENDCASE => from.vfn.directory.length + 1;      unexpandedLength: CARDINAL = nameLength + dirLength + 1;      opsConn: FileTransferOps.Connection = LOOPHOLE[toConn];      delim: CHARACTER = '!;      RenameOneFile: FileTransfer.ListProc        -- PROC[conn: Connection, ..., file: LONG STRING] RETURNS[Confirmation]         = {        qualified: STRING ¬ [maxFileName];        new.length ¬ nNew;        FOR i: CARDINAL IN [unexpandedLength..file.length) UNTIL file[i] = delim DO          String.AppendChar[qualified, file[i]] 	ENDLOOP;        String.AppendString[new, qualified];        BrownieOps.PostString[terse, file, " renamed to "L];        STP.Rename[          opsConn.stp, file, new !          STP.Error =>            SELECT code FROM              requestRefused =>                SELECT reply FROM                  'J => {  -- file already exists; change for update                    BrownieOps.PostLine[fatal, error]; GOTO return}                  ENDCASE;              accessDenied => {  -- file protected                BrownieOps.PostLine[fatal, error]; GOTO return}              ENDCASE; ];        BrownieOps.PostLine[terse, new, "."L];        RETURN[do];        EXITS return => RETURN[do]};      SetHost[opsConn, from.vfn];      -- if all, FileTransfer does the right thing in enumerating all versions            IF ~renameCmd.all THEN  -- if not, only rename highest version              -- oneFile means that the from.vfn.name is NOT empty.	        IF oneFile AND String.Empty[from.vfn.version] THEN          String.AppendStringAndGrow[            @from.vfn.version, "H"L,            heap]        ELSE {          String.AppendStringAndGrow[            @from.vfn.name, "*"L,            heap];          String.AppendStringAndGrow[            @from.vfn.version, "H"L,            heap]};      new.length ¬ 0;      FileTransferUtils.AppendVFN[s: new, vfn: to.vfn, remote: TRUE, rename: TRUE];      nNew ¬ new.length;      DO        ENABLE          UNWIND =>            FileTransferPupOps.PupClose[              c: opsConn, printErrs: TRUE, freeObject: TRUE];        howWent: Result ¬ win;        IF CheckAbort[NIL] THEN ERROR ABORTED;        FileTransferPupOps.PupOpen[opsConn, from.vfn.directory];        FileTransfer.Enumerate[          fromConn, from.vfn, RenameOneFile !          STP.Error => {            howWent ¬ PupError[opsConn, stp, code, error];            SELECT howWent FROM              reject => REJECT;              protocolProblem => ERROR BrownieOps.Error[skip];              ENDCASE => CONTINUE}];        IF CheckAbort[NIL] THEN ERROR ABORTED;        SELECT howWent FROM          win => EXIT;          closeAndRetry => FileTransferPupOps.PupClose[opsConn, FALSE, FALSE];          ENDCASE;        ENDLOOP;      FileTransferPupOps.PupClose[c: opsConn, printErrs: TRUE, freeObject: TRUE];      END;  -- PupRenameFiles    -- ******************************    -- END OF RENAMING    -- ******************************        SetUpFileTransferInformation: PROCEDURE =      BEGIN      OPEN commands[i];      st: FileTransfer.ServerType;      {      SELECT type FROM         copy, rename => {	   IF queryForLogin THEN {	      FileTransfer.SetPrimaryCredentials[		toConn, logIns[toI].loginName, logIns[toI].loginPassword];			      FileTransfer.SetPrimaryCredentials[		fromConn, logIns[fromI].loginName, logIns[fromI].loginPassword];			      IF to.connectIndex # NIL THEN		FileTransfer.SetSecondaryCredentials[		  toConn, to.connectIndex.connectName, to.connectIndex.connectPassword];		  	      IF from.connectIndex # NIL THEN		FileTransfer.SetSecondaryCredentials[		  fromConn, from.connectIndex.connectName,		  from.connectIndex.connectPassword]};			    IF to.serverType # null THEN	      FileTransfer.SetDefaultServerType[toConn, to.serverType !	        FileTransfer.Error => {st ¬ to.serverType; GOTO notLoaded}];	    IF from.serverType # null THEN	      FileTransfer.SetDefaultServerType[fromConn, from.serverType !	        FileTransfer.Error =>  {st ¬ from.serverType; GOTO notLoaded}];	 };	 delete => {	   IF queryForLogin THEN {	      FileTransfer.SetPrimaryCredentials[		toConn, logIns[toI].loginName, logIns[toI].loginPassword];	      IF to.connectIndex # NIL THEN		FileTransfer.SetSecondaryCredentials[		  toConn, to.connectIndex.connectName, to.connectIndex.connectPassword]};	      IF to.serverType # null THEN	      FileTransfer.SetDefaultServerType[toConn, to.serverType !	        FileTransfer.Error => {st ¬ to.serverType; GOTO notLoaded}];	 };      ENDCASE;      EXITS notLoaded => {        type: LONG STRING = IF st=ns THEN "NS"L ELSE "Pup"L;        BrownieOps.PostLine[fatal, type, " file transfer package not loaded"L];	ERROR BrownieOps.Error[skip]};      };      END;            DoActualOperation: PROCEDURE =      BEGIN      OPEN commands[i];      SELECT type FROM        copy => {		copyCmd ¬ LOOPHOLE[commands[i]]; 		CopyFiles[]		};	rename => {          	renameCmd ¬ LOOPHOLE[commands[i]];          	IF from.serverType = ns 		THEN 			NSRenameFiles[] 		ELSE 			PupRenameFiles[]		};	delete => {          	deleteCmd ¬ LOOPHOLE[commands[i]];		DeleteFiles[];		};        ENDCASE;	      END;          -- begin ProcessCommands    startTime: Time.Packed = Time.Current[];    timeString: STRING = [24];        -- Determine which procedure to use for messages depending on the    -- message severity parameter that was set previously.    post: FileTransfer.MessageProc ¬      	IF BrownieOps.GetLevel[] < terse 	THEN    PostVerbose 	-- a procedure.	ELSE 		PostTerse;        myTo ¬ ParseDefs.z.NEW[MyClientData ¬ [toConn, ptData]];    myFrom ¬ ParseDefs.z.NEW[MyClientData ¬ [fromConn, ptData]];            FileTransfer.SetProcs[      conn: toConn, clientData: myTo, messages: post, login: LoginAndSet,      noteProgress: NoteProgress, checkAbort: CheckAbort];          FileTransfer.SetProcs[      conn: fromConn, clientData: myFrom, messages: post, login: LoginAndSet,      noteProgress: NoteProgress, checkAbort: CheckAbort];    Time.AppendCurrent[timeString];        BrownieOps.PostLine[terse, "Brownie starting at "L, timeString];    -- for each command line given...    FOR i IN [0..commandCnt) DO	  OPEN commands[i];	  ENABLE	    BEGIN	    FileTransfer.Error =>	      SELECT code FROM		retry => RETRY;		skipFile, skipOperation, directoryFull, notFound, accessDenied =>		  LOOP;		ENDCASE => {		  msg: STRING ¬ [20];		  FileTransfer.CodeToString[code, msg];		  BrownieOps.PostLine[fatal, msg];		  LOOP};	    STP.Error => {	      BrownieOps.PostLine[fatal, "Unexpected STP error:"L, error]; LOOP};	    BrownieOps.Error => {SELECT kind FROM skip => LOOP; ENDCASE}	    END;	    	  SELECT type FROM	    copy, rename => BEGIN	 	  singleFile ¬ ~String.Empty[from.vfn.name]  AND		  ~BrownieOps.HasWildCard[from.vfn.name];	 	  toI ¬ to.logInIndex;		  fromI ¬ from.logInIndex;			    END;	    delete => 	BEGIN		toI ¬ to.logInIndex;		singleFile ¬ ~String.Empty[to.vfn.name] AND	         ~BrownieOps.HasWildCard[to.vfn.name];	    		END;	  ENDCASE;	 	  SetUpFileTransferInformation[];	  BrownieOps.PostLine[terse, NIL];	  IF ~singleFile THEN {	    ParseDefs.PostCommand[dH: ptData, num: i, updateNow: TRUE];	  };	  DoActualOperation[]; 	      ENDLOOP;    -- Done with all command lines.    -- post statistics on this run.        timeString.length ¬ 0;    Time.AppendCurrent[timeString];    BrownieOps.PostLine[terse, "Brownie finished at "L, timeString];    timeString.length ¬ 0;    AppendElapsedTime[Time.Current[] - startTime, timeString];    BrownieOps.PostLine[terse, "Elapsed time "L, timeString];    END;  -- ProcessCommands  -- used only once   AppendElapsedTime: PROC [et: LONG CARDINAL, s: LONG STRING] = {    minutes, seconds: CARDINAL;    seconds ¬ CARDINAL[et MOD 60];    et ¬ et / 60;    minutes ¬ CARDINAL[et MOD 60];    et ¬ et / 60;    String.AppendLongNumber[s, et];    String.AppendChar[s, ':];    IF minutes < 10 THEN String.AppendChar[s, '0];    String.AppendNumber[s, minutes];    String.AppendChar[s, ':];    IF seconds < 10 THEN String.AppendChar[s, '0];    String.AppendNumber[s, seconds]};  SetHost: PROC [c: FileTransferOps.Connection, vfn: FileName.VFN] = {    -- future: use SetHost[]  in FTa    IF vfn = NIL OR String.Equivalent[c.host, vfn.host] THEN RETURN;    IF String.Empty[vfn.host] THEN {String.FreeString[heap, c.host]; c.host ¬ NIL}    ELSE String.Replace[@c.host, vfn.host, heap];    c.serverType ¬ ifs;    };  PupError: PROCEDURE [    conn: FileTransferOps.Connection, stp: STP.Handle, code: STP.ErrorCode,    msg: LONG STRING] RETURNS [Result] =    BEGIN    IF stp # NIL AND stp # conn.stp THEN RETURN[reject];    SELECT code FROM      protocolError => {        BrownieOps.PostLine[warning, msg, " while connected to "L, conn.host];        RETURN[protocolProblem]};      noRouteToNetwork, noConnection, connectionClosed, connectionRejected,        connectionTimedOut => {        BrownieOps.PostLine[warning, msg, " while connected to "L, conn.host];        RETURN[closeAndRetry]};      accessDenied, illegalUserAccount, illegalConnectName, illegalConnectPassword,        credentailsMissing => {        BrownieOps.PostString[fatal, msg]; BrownieOps.Error[skip]};      illegalFileName, requestRefused => {        BrownieOps.PostLine[fatal, msg]; BrownieOps.Error[skip]}      ENDCASE;    RETURN[reject];    END;  CleanUp: PROCEDURE [dh: ParseDefs.DataHandle] =    BEGIN    i: ParseDefs.CommandIndex;    IF dh # NIL THEN      FOR i IN [0..dh.commandCnt) DO        OPEN dh.commands[i];        IF from # NIL THEN FileName.FreeVFN[from.vfn];        IF to # NIL THEN FileName.FreeVFN[to.vfn];        ENDLOOP;    IF sh # NIL THEN Stream.Delete[sh];    slot ¬ HeraldWindow.FreeCursorSlot[slot];    IF toConn # NIL THEN FileTransfer.Destroy[toConn];    IF fromConn # NIL THEN FileTransfer.Destroy[fromConn];    Exec.ReleaseTTY[BrownieOps.ttyH];    BrownieOps.CloseLogFile[];    IF fileName # NIL THEN fileName ¬ Exec.FreeTokenString[fileName];    IF switches # NIL THEN switches ¬ Exec.FreeTokenString[switches];    Heap.Delete[ParseDefs.z];    END;  Initialize: PROCEDURE =    BEGIN    BrownieOps.InitVariables[];  -- starts BrowniesA    BrownieOps.ttyH ¬ Exec.GetTTY[BrownieOps.eH];    BrownieOps.WriteHerald[];    ParseDefs.z ¬ Heap.Create[initial: 5, ownerChecking: TRUE, checking: TRUE];    sh ¬ NIL;    dh ¬ NIL;    toConn ¬ fromConn ¬ NIL;    [fileName, switches] ¬ Exec.GetToken[BrownieOps.eH];    -- BrownieOps.OpenLogFile[]; ** write only to the exec    sh ¬ BrownieOps.OpenScriptFile[fileName];    toConn ¬ FileTransfer.Create[];    fromConn ¬ FileTransfer.Create[];    slot ¬ HeraldWindow.GetCursorSlot[];    cursorState ¬ negative;    HeraldWindow.SetCursor[slot, Cursor.Defined[blank]];    END;  -- Main routine	  RunBrownie: PROCEDURE =    BEGIN    nErrors: CARDINAL ¬ 0;    msg: STRING ¬ [50];    {    ENABLE      BEGIN      UNWIND => CleanUp[dh];      FileTransfer.Error => {        FileTransfer.CodeToString[code, msg];        BrownieOps.PostLine[fatal, "From FileTransfer, "L, msg];        GOTO done};      ABORTED => {BrownieOps.PostLine[fatal, "Aborted."L]; GOTO done}      END;          -- Set up all data     Initialize[      !      BrownieOps.Error =>        SELECT kind FROM          fileNotFound => {            BrownieOps.PostLine[fatal, fileName, " not found."L]; GOTO done};          normal => GOTO done          ENDCASE];	      -- Parse the commands, but do not do the operations 	      [dh, nErrors] ¬ ParseDefs.ParseCommands[stream: sh, globalSwitches: switches];          -- Exit the program if there are any command line errors.    IF nErrors # 0 THEN {      BrownieOps.PostLine[fatal, "Errors encountered."L];      GOTO done    };         -- Wait until startup time.    BrownieOps.WaitAround[dh.start];        -- Actually do it here.        ProcessCommands[dh];        CleanUp[dh];    EXITS done => CleanUp[dh]}    END;  -- RunBrownie  -- Used in Main to avoid concurrent execution.  busy: BOOLEAN ¬ FALSE;  -- monitored data    Busy: ENTRY PROCEDURE RETURNS [BOOLEAN] = {RETURN[busy]};      SetBusy: ENTRY PROCEDURE [b: BOOLEAN] = {busy ¬ b};   Main: PROCEDURE [h: Exec.Handle, clientData: LONG POINTER ¬ NIL] RETURNS [o: Exec.Outcome ¬ normal] =    BEGIN    -- don't do anything if Brownie is still executing,    -- possibly invoked from another Exec window.    IF Busy[] THEN Exec.OutputProc[h]["Brownie is busy."L]    -- Save ExecHandle and run. Turn on "semaphore" to prevent execution.    ELSE {SetBusy[TRUE]; BrownieOps.eH ¬ h; RunBrownie[]; SetBusy[FALSE]; };   END;  -- Main-- Main line code.  Exec.AddCommand["Brownie.~"L, Main];  END..  -- Of BrownieControl
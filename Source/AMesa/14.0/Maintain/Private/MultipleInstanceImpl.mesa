-- File: MultipleInstanceImpl.mesa - last edit:-- Sturtevant.PA       15-Nov-84 13:58:03-- Copyright (C) 1984 by Xerox Corporation. All rights reserved. <<** MultipleInstanceImpl - implementation for MultipleInstance.** The hardest thing about this is the synchronization.**  Synchronization:**    Within the monitor lock -**	functions that add and remove things from the linked list of instances**	  in the globals for each tool.**	functions that modify individual WindowRecords.**	functions that modify g.**	functions that wait and notify condition variables.**      None of these can take much time.**	Includes SetProcess, Join, WindowToInstanceInfo, which are public**  **    Functions that affect one instance (and are non exclusive)**	  CreateInstance and DestroyInstance which create and destroy window**          handles**      It is the client's responsibility to synchronize these, and avoid calling**      more then one of them at a time per-instance.  This should be easy, as**      normally, there is one process per-instance which might be calling them.**      A count of the number of these functions active for a given tool is in**      g.createsAndDestroysActive.  These are locked out by DestroyForUnload****    Functions which affect all instances**	  These are DestroyForUnload and EnumerateInstances.**      They wait for all**      of the  functions affecting one instance to complete, lock out others**      from starting, and then go.  Functions locked out by DestroyForUnload**      simply return.  Functions locked out by EnumerateInstances wait until**      the enumeration is finished.  It is ok to have several enumerations in**      progress at the same time, as they don't modify the list, only read it.>>DIRECTORY  LockSync USING [LockNoWait, Unlock],  MultipleInstance USING [    EnumerateInstancesProc, GlobalsHandle, InstanceInfo, InstanceInfoRecord,    StringCallBack, WindowRecord],  Process USING [Abort, Pause, SecondsToTicks, Ticks],  Runtime USING [GetBcdTime],  String USING [AppendNumber, AppendString, CopyToNewString, Empty, FreeString],  Time USING [Append, Unpack],  Tool USING [Create, Destroy, MakeSWsProc, State],  ToolWindow USING [Activate, GetState, State, TransitionProcType],  UserInput USING [ResetUserAbort, UserAbort],  Window USING [Box, Handle];MultipleInstanceImpl: MONITOR  IMPORTS LockSync, Process, Runtime, String, Time, Tool, ToolWindow, UserInput  EXPORTS MultipleInstance =  BEGIN  bugType: TYPE = {nilWindow, nilG, unknownWindowState};  Bug: ERROR [type: bugType] = CODE;  << CommandEnumerator >>  <<  ** CommandEnumerator - process that watches the STOP key.  ** forked off by IncIC when 1st instance created, joined by DecIC.  ** Also checks for and harvests dead processes (those that have unlocked  ** themselves.)  ** The CONTINUE for ABORTED should have us RETURN - end of the process  >>  CommandEnumerator: PROCEDURE [g: MultipleInstance.GlobalsHandle] =    BEGIN    ENABLE ABORTED => CONTINUE;    EnumProc: MultipleInstance.EnumerateInstancesProc =      BEGIN      p: PROCESS ¬ NIL;      forked: BOOLEAN;      [p, forked] ¬ CheckOutProcess[ii];      IF g.abortable AND p # NIL AND UserInput.UserAbort[ii.wh] THEN {        Process.Abort[p]; UserInput.ResetUserAbort[ii.wh]; };      IF p # NIL AND LockSync.LockNoWait[@ii.lock] THEN {        << ok to lock here? >>        LockSync.Unlock[@ii.lock];	IF forked THEN JOIN p;	p ¬ NIL;        };      CheckInProcess[ii, p, forked];      RETURN[~g.unloading];  << if not unloading, continue >>      END;  -- EnumProc    pauseTime: Process.Ticks ¬      IF g.stopCheckInterval = 0 THEN Process.SecondsToTicks[1] / 2      ELSE g.stopCheckInterval;    DO EnumerateInstances[g, EnumProc]; Process.Pause[pauseTime]; ENDLOOP;    END;  -- StopKeyWatcher  << PUBLIC PROCEDURES >>  WindowRecord: PUBLIC TYPE = RECORD [    ii: MultipleInstance.InstanceInfoRecord,    link: LONG POINTER TO WindowRecord ¬ NIL];  <<  ** createsAndDestroysDone  **  - EnumerateInstances & DestroyForUnload wait for me  >>  createsAndDestroysDone: CONDITION;  enumerationDone: CONDITION;  << SOME enumeration has finished >>  <<  ** toolOnList - close race condition between Tool.Create and adding tool  ** to the list.  We could concievably do a Join on a tool that hasn't yet  ** been put on the list.  In that case we wait on toolOnList  >>  toolOnList: CONDITION;  <<  ** UnregisteredBirthOrder - in CreateInstance, we call MakeSWs as a call  ** back after we know the birth order of the new tool, and before we know  ** the window handle.  Therefore, we can't put the new instance on the list  ** for MakeSWs to find the birthOrder in the normal fashion.  Nor can we pass  ** it as a parameter to MakeSWs, since it is a callback of predefined type.  ** Nor can we leave the birthOrder in some global, as it is instance data.  ** The only solution seems to be to use the dynamic scoping of signals (Mesa  ** fortunately has one (at least) of everything).  ** Used by MakeSWs & the StringCallBacks in CreateInstance only.  >>  UnregisteredBirthOrder: PUBLIC SIGNAL RETURNS [birthOrder: CARDINAL] = CODE;  CreateInstance: PUBLIC PROCEDURE [    g: MultipleInstance.GlobalsHandle,    nameCallBack: MultipleInstance.StringCallBack, makeSWsProc: Tool.MakeSWsProc,    initialState: Tool.State, clientTransition: ToolWindow.TransitionProcType,    movableBoundaries: BOOLEAN, initialBox: Window.Box,    cmSectionCallBack, tinyName1CallBack, tinyName2CallBack:      MultipleInstance.StringCallBack, named: BOOLEAN]    RETURNS [window: Window.Handle] =    BEGIN    z: UNCOUNTED ZONE = g.z;    ic: CARDINAL ¬ 0;  << number of instances (counting this one) >>    ii: MultipleInstance.InstanceInfo ¬ NIL;    newBirthOrder: CARDINAL;  << name birthOrder conflicts w/ sig param >>    callBackName: LONG STRING ¬ NIL;  << name returned by nameCallBack >>    name: LONG STRING ¬ NIL;  << tool name - constructed or ­ >>    {  -- spurious scoping for EXITS    IF ~IncCD[g] THEN RETURN[NIL];  << one more create in progress >>    IF (ii ¬ FindInactiveInstance[g]) # NIL THEN {      ToolWindow.Activate[        window ¬ ii.wh ! UnregisteredBirthOrder => RESUME [ii.birthOrder];  << for MakeSWs >>        ];      GOTO done;      };  -- find inactive instance    << Create new tool instance (wh = NIL) >>    ic ¬ IncIC[g];    IF g.maxInstances > 0 AND ic > g.maxInstances THEN {DecIC[g]; GOTO done; };    << max exist >>    << Nothing to activate, create a new one >>    newBirthOrder ¬ RegisterBirth[g];    IF nameCallBack = NIL OR String.Empty[callBackName ¬ nameCallBack[]] THEN {      << construct name >>      name ¬ String.CopyToNewString[z: z, s: g.rootName, longer: 62];      IF newBirthOrder # 1 THEN {        String.AppendString[to: name, from: " #"L];        String.AppendNumber[name, newBirthOrder, 10];        };      String.AppendString[to: name, from: " of "L];      Time.Append[        s: name, unpacked: Time.Unpack[time: Runtime.GetBcdTime[]], zone: TRUE];      }    ELSE name ¬ String.CopyToNewString[z: z, s: callBackName];    window ¬ Tool.Create[      name: name, makeSWsProc: makeSWsProc, initialState: initialState,      clientTransition: clientTransition, movableBoundaries: movableBoundaries,      initialBox: initialBox,      cmSection:      IF cmSectionCallBack = NIL THEN g.rootName ELSE cmSectionCallBack[],      tinyName1: IF tinyName1CallBack = NIL THEN NIL ELSE tinyName1CallBack[],      tinyName2: IF tinyName2CallBack = NIL THEN NIL ELSE tinyName2CallBack[],      named: named ! UnregisteredBirthOrder => RESUME [newBirthOrder]; ];  << see comment for UnregisteredBirthOrder >>    AddToList[g, window, newBirthOrder];  << AddToList BROADCASTS to close race >>    GOTO done;    EXITS      done => {        IF name # NIL THEN String.FreeString[z, name]; DecCD[g]; RETURN[window]; };    };    END;  -- CreateInstance  DestroyInstance: PUBLIC PROCEDURE [    g: MultipleInstance.GlobalsHandle, wh: Window.Handle] =    BEGIN    IF g = NIL THEN ERROR Bug[nilG];    IF wh = NIL THEN ERROR Bug[nilWindow];    IF ~IncCD[g] THEN RETURN;    << Tool.Destroy calls ClientTransition calls Join, so must leave on list >>    Tool.Destroy[wh];  << NOTIFIER held, so can't have 2 destroys on same tool >>    RemoveFromList[g, wh];    DecIC[g];    DecCD[g];    TerminateCommandEnumerator[g];    END;  -- DestroyInstance  <<  ** Join - harvest the sub process for a window handle  ** NOTE: this gets called during DestroyForUnload. (ClientTransition)  >>  Join: PUBLIC PROCEDURE [g: MultipleInstance.GlobalsHandle, wh: Window.Handle] =    BEGIN    p: PROCESS ¬ NIL;    forked: BOOLEAN;    ii: MultipleInstance.InstanceInfo ¬ NIL;    IF g = NIL THEN ERROR Bug[nilG];    IF wh = NIL THEN ERROR Bug[nilWindow];    ii ¬ GetInstanceInfo[g, wh, TRUE];    [p, forked] ¬ CheckOutProcess[ii];	<< synchronously - ii.p = NIL now >>    IF p # NIL AND forked THEN JOIN p;    p ¬ NIL;    CheckInProcess[ii, p, forked];    END;  -- Join  <<  ** WindowToInstanceInfo - return MultipleInstance's per-instance data  ** NOTE: this gets called during DestroyForUnload. (ClientTransition)  >>  WindowToInstanceInfo: PUBLIC PROCEDURE [    g: MultipleInstance.GlobalsHandle, wh: Window.Handle, wait: BOOLEAN]    RETURNS [ii: MultipleInstance.InstanceInfo] =    BEGIN    IF g = NIL THEN ERROR Bug[nilG];    IF wh = NIL THEN ERROR Bug[nilWindow];    RETURN[GetInstanceInfo[g, wh, wait]];    END;  -- WindowToInstanceInfo  SetProcess: PUBLIC PROCEDURE [    g: MultipleInstance.GlobalsHandle, wh: Window.Handle, p: PROCESS,    forked: BOOLEAN] =    BEGIN    ii: MultipleInstance.InstanceInfo ¬ NIL;    IF g = NIL THEN ERROR Bug[nilG];    IF wh = NIL THEN ERROR Bug[nilWindow];    ii ¬ GetInstanceInfo[g, wh, TRUE];    CheckInProcess[ii, p, forked];    END;  -- SetProcess  <<  ** DestroyForUnload - Tool.Destroy on all window handles, and Heap.Delete on  ** the heap.  ** Sets g.unloading TRUE, so nothing else will commence, then waits for  ** everything in progress to finish (WaitForCreatesAndDestroysToFinish and  ** WaitForEnumeration), then pulls each window off the list and destroys it.  >>  DestroyForUnload: PUBLIC PROCEDURE [g: MultipleInstance.GlobalsHandle] =    BEGIN    wh: Window.Handle ¬ NIL;    first: LONG POINTER TO WindowRecord;  << seems to be needed for opaque type >>    IF g = NIL THEN ERROR Bug[nilG];    SetUnloading[g];  << monitored >>    WaitForCreatesAndDestroysToFinish[g];    << unloading TRUE, so no more will start. >>    WaitForEnumeration[g];    << EVERYTHING's quiesced >>    WHILE (first ¬ g.windows) # NIL DO      Tool.Destroy[wh ¬ first.ii.wh]; RemoveFromList[g, wh]; DecIC[g]; ENDLOOP;    TerminateCommandEnumerator[g];    END;  -- DestroyForUnload  EnumerateInstances: PUBLIC PROCEDURE [    g: MultipleInstance.GlobalsHandle,    callBack: MultipleInstance.EnumerateInstancesProc] =    BEGIN    IF g = NIL THEN ERROR Bug[nilG];    IF ~StartEnumerating[g] THEN RETURN;  << can't set enumerate so get out>>    << ... enumerate ... >>    FOR w: LONG POINTER TO WindowRecord ¬ g.windows, w.link WHILE w # NIL      AND callBack[@w.ii] DO ENDLOOP;    StopEnumerating[g];    END;  -- EnumerateInstances  <<  ** TerminateCommandEnumerator - harvest the command enumerator  ** called whenever we do a DecIC.  Outside of locks so the command enumerator  ** isn't waiting for us.  Can get called twice - once when last instance  ** destroyed, again on unload.  >>  TerminateCommandEnumerator: PROCEDURE [g: MultipleInstance.GlobalsHandle] =    BEGIN    p: PROCESS ¬ NIL;    IF GetIC[g] > 0 THEN RETURN;    p ¬ GetCommandEnumerator[g];    IF p # NIL THEN { Process.Abort[p]; JOIN p; };    END;  -- TerminateCommandEnumerator  << ENTRY PROCEDURES >>  <<  ** IncCD & DecCD - count the number of CreateInstance and DeleteInstance  ** active.  We need to wait for all of these to finish before doing our  ** DestroyForUnload.  Don't want to use the monitor's mutual exclusion, because  **  1) ok to have more than one CreateInstance and DeleteInstance at a time.  **  2) CreateInstance & esp. DestroyInstance can take a LONG time.  ** NOTE than procedures waiting on createsAndDestroysDone are awakened anytime  ** any tool has the count hit 0.  The alternative is to add a condition  ** variable to g - much the inferior choice.  **  ** IncCD and DecCD must properly bracket all creates and destroys.  >>  IncCD: ENTRY PROCEDURE [g: MultipleInstance.GlobalsHandle]    RETURNS [proceed: BOOLEAN ¬ TRUE] =    BEGIN    ENABLE UNWIND => NULL;    IF g.unloading THEN RETURN[FALSE];    WHILE g.enumerationsInProgress > 0 DO WAIT enumerationDone; ENDLOOP;    IF g.unloading THEN RETURN[FALSE];  << again after the WAIT >>    g.createsAndDestroysActive ¬ g.createsAndDestroysActive + 1;    END;  DecCD: ENTRY PROCEDURE [g: MultipleInstance.GlobalsHandle] =    BEGIN    ENABLE UNWIND => NULL;    g.createsAndDestroysActive ¬ g.createsAndDestroysActive - 1;    IF g.createsAndDestroysActive = 0 THEN BROADCAST createsAndDestroysDone;    END;  -- DecCD  SetUnloading: ENTRY PROCEDURE [g: MultipleInstance.GlobalsHandle] = {    ENABLE UNWIND => NULL; g.unloading ¬ TRUE; };  StartEnumerating: ENTRY PROCEDURE [g: MultipleInstance.GlobalsHandle]    RETURNS [ableToSet: BOOLEAN ¬ FALSE] =    BEGIN    ENABLE UNWIND => NULL;    IF g.unloading THEN {  << can't set >>      BROADCAST enumerationDone; RETURN[FALSE]; };    WHILE g.createsAndDestroysActive > 0 DO WAIT createsAndDestroysDone; ENDLOOP;    g.enumerationsInProgress ¬ g.enumerationsInProgress + 1;    RETURN[TRUE];    END;  -- StartEnumerating  StopEnumerating: ENTRY PROCEDURE [g: MultipleInstance.GlobalsHandle] =    BEGIN    ENABLE UNWIND => NULL;    g.enumerationsInProgress ¬ g.enumerationsInProgress - 1;    BROADCAST enumerationDone;    END;  -- StopEnumerating  WaitForCreatesAndDestroysToFinish: ENTRY PROCEDURE [    g: MultipleInstance.GlobalsHandle] =    BEGIN    ENABLE UNWIND => NULL;    WHILE g.createsAndDestroysActive > 0 DO WAIT createsAndDestroysDone; ENDLOOP;    END;  --WaitForCreatesAndDestroysToFinish  WaitForEnumeration: ENTRY PROCEDURE [g: MultipleInstance.GlobalsHandle] =    BEGIN    ENABLE UNWIND => NULL;    WHILE g.enumerationsInProgress > 0 DO WAIT enumerationDone; ENDLOOP;    END;  -- WaitForEnumeration  <<  ** IncIC & DecIC - count the number of tool instances currently existing  ** IncIC returns # after increment  ** IncIC fires off the StopKeyWatcher when the first instance is created.  ** DecIC DOES NOT abort the CommandEnumerator when the last instance is deleted.  ** instead, everyone who does a DecIC should call TerminateCommandEnumerator  ** outside of both DecIC & DecCD, whic will harvest the CommandEnumerator if  ** there are no more instances.  ** RegisterBirth - a new tool has been created  >>  IncIC: ENTRY PROCEDURE [g: MultipleInstance.GlobalsHandle] RETURNS [CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    g.numberOfInstances ¬ g.numberOfInstances + 1;    IF g.numberOfInstances = 1 THEN  << this was the first >>      g.commandEnumerator ¬ FORK CommandEnumerator[g];    RETURN[g.numberOfInstances];    END;  -- IncIC  DecIC: ENTRY PROCEDURE [g: MultipleInstance.GlobalsHandle] =    BEGIN    ENABLE UNWIND => NULL;    g.numberOfInstances ¬ g.numberOfInstances - 1;    END;  -- DecIC  GetIC: ENTRY PROCEDURE [g: MultipleInstance.GlobalsHandle]    RETURNS [ic: CARDINAL] = {RETURN[g.numberOfInstances]; };  GetCommandEnumerator: ENTRY PROCEDURE [g: MultipleInstance.GlobalsHandle]    RETURNS [p: PROCESS] = {p ¬ g.commandEnumerator; g.commandEnumerator ¬ NIL; };  <<  ** CheckOutProcess, CheckInProcess - only one thing at a time  ** can have access to the process of an instance.  ** This avoids multiple joins, other race conditions.  >>  CheckOutProcess: ENTRY PROCEDURE [ii: MultipleInstance.InstanceInfo]    RETURNS [p: PROCESS, forked: BOOLEAN] =    {p ¬ ii.p; forked ¬ ii.forked; ii.p ¬ NIL; };  CheckInProcess: ENTRY PROCEDURE [    ii: MultipleInstance.InstanceInfo, p: PROCESS, forked: BOOLEAN] =    {ii.p ¬ p; ii.forked ¬ forked; };  RegisterBirth: ENTRY PROCEDURE [g: MultipleInstance.GlobalsHandle]    RETURNS [CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    g.numberOfBirths ¬ g.numberOfBirths + 1;    RETURN[g.numberOfBirths];    END;  -- RegisterBirth  AddToList: ENTRY PROCEDURE [    g: MultipleInstance.GlobalsHandle, wh: Window.Handle, birthOrder: CARDINAL] =    BEGIN    ENABLE UNWIND => NULL;    g.windows ¬ g.z.NEW[      WindowRecord ¬ [ii: [wh: wh, birthOrder: birthOrder], link: g.windows]];    BROADCAST toolOnList;    END;  -- AddToList  FindInactiveInstance: ENTRY PROCEDURE [g: MultipleInstance.GlobalsHandle]    RETURNS [ii: MultipleInstance.InstanceInfo] =    BEGIN    ENABLE UNWIND => NULL;    FOR w: LONG POINTER TO WindowRecord ¬ g.windows, w.link WHILE w # NIL DO      SELECT ToolWindow.GetState[w.ii.wh] FROM        active, tiny => NULL;        inactive => RETURN[@w.ii];        ENDCASE => ERROR Bug[unknownWindowState];      ENDLOOP;    RETURN[NIL];    END;  -- FindInactiveInstance  RemoveFromList: ENTRY PROCEDURE [    g: MultipleInstance.GlobalsHandle, wh: Window.Handle] =    BEGIN    ENABLE UNWIND => NULL;    w: LONG POINTER TO LONG POINTER TO WindowRecord;    FOR w ¬ @g.windows, @w.link WHILE w­ # NIL DO      IF w.ii.wh = wh THEN {  << found it, remove it >>        flush: LONG POINTER TO WindowRecord ¬ w­;        w­ ¬ w.link;        g.z.FREE[@flush];        RETURN;        };      ENDLOOP;    END;  -- RemoveFromList  <<  ** GetInstanceInfo - return the InstanceInfo given a window handle.  ** if the handle is not on the list, it is either for a window which  ** is not associated with a tool, in which case we will hang, and there  ** is a bug in the client's code, or for one which has been created, but  ** not yet put on the list.  In that case, CreateInstance has started, and  ** will soon finish, so we don't hang.  >>  GetInstanceInfo: ENTRY PROCEDURE [    g: MultipleInstance.GlobalsHandle, wh: Window.Handle, wait: BOOLEAN]    RETURNS [ii: MultipleInstance.InstanceInfo] =    BEGIN    << InternalGetInstanceInfo - get instance infor for wh if on the list. >>    InternalGetInstanceInfo: INTERNAL PROCEDURE [      g: MultipleInstance.GlobalsHandle, wh: Window.Handle]      RETURNS [ii: MultipleInstance.InstanceInfo] =      BEGIN      FOR w: LONG POINTER TO WindowRecord ¬ g.windows, w.link WHILE w # NIL DO        IF w.ii.wh = wh THEN RETURN[@w.ii]; ENDLOOP;      RETURN[NIL];      END;  -- InternalGetInstanceInfo    -- GetInstanceInfo starts    WHILE (ii ¬ InternalGetInstanceInfo[g, wh]) = NIL AND wait DO      WAIT toolOnList; ENDLOOP;    RETURN[ii];    END;  -- GetInstanceInfo  END.LOG  Created Sturtevant 12-Oct-84 11:34:21
-- File: MaintainPrivate.mesa - last edit:-- Sturtevant.PA       25-Jan-85 13:14:59-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.<<** Template is an example tool which can have multiple instances, runs** commands in the background (only one at a time), is unloadable, registers** itself with the ToolDriver, and is believed to be uncrashable.** This is the DEFINITIONs file.  Implementations are in TemplateImpl and** TemplateForkImpl.  Template.config is the sample config.**** To create a tool "Oyster" following the example of Template, create an** OysterPrivate.mesa, OysterImpl.mesa and OysterForkImpl.mesa modeled after** TemplatePrivate, TemplateImpl, and TemplateForkImpl.  FormSWLayoutTool** can be used to layout the formSW fields.** MultipleInstance and LockSync do not need to be changed or recompiled.**** This tool registers itself with the ToolDriver.  The multiple instances** are called Template, Template2, Template3, etc.  The subwindows are called** MsgSW, FromSW, and FileSW.  NOTE that there must be a blank line after each** entry in Tool.sws.**** The User.cm section for all instances of the tool is [Template].>>DIRECTORY  Auth USING [IdentityHandle],  NSName USING [Name],  Supervisor USING [SubsystemHandle],  Window USING [Handle];<<** Definitions file for MaintainWindowImpl, MaintainCmdsAImpl,** MaintainCmdsBImpl>>MaintainPrivate: DEFINITIONS =  BEGIN  DoDebug: BOOLEAN = TRUE;  <<  ** SWs - subwindows of the main window.  ** Does not change with differend tools.  >>  SWs: TYPE = RECORD [  << SubWindows >>    msgSW: Window.Handle ¬ NIL,    formSW: Window.Handle ¬ NIL,    fileSW: Window.Handle ¬ NIL,    main: Window.Handle ¬ NIL];  Level: TYPE = {normal, owner, admin};  -- level  ListMode: TYPE = {members, friends, owners};  -- gMode  PwdType: TYPE = {strong, simple, both};  -- iPwdType  <<  ** Items - data for fields of FormSW.  Partially generated  ** by FormSWLayoutTool &c.  Changes with different tools.  ** Default values for booleans and enumerateds given here.  >>  Items: TYPE = MACHINE DEPENDENT RECORD [  << formSW fields >>    level(0): Level ¬ normal,    anyEntry(1): BOOLEAN ¬ FALSE,    group(2): LONG STRING ¬ NIL,    gNameList(4): LONG STRING ¬ NIL,    gMode(6): ListMode ¬ members,    gRemark(7): LONG STRING ¬ NIL,    gAlias(9): LONG STRING ¬ NIL,    individual(11): LONG STRING ¬ NIL,    iPwdType(13): PwdType ¬ both,    iPassword(14): LONG STRING ¬ NIL,    iRemark(16): LONG STRING ¬ NIL,    iMailbox(18): LONG STRING ¬ NIL,    iAlias(20): LONG STRING ¬ NIL,    useBackground(22): BOOLEAN ¬ TRUE,    checkNames(23): BOOLEAN ¬ TRUE];  -- types for passing data to commands  -- the combination of GroupIndiv, CreateDelete and CommandType uniquely  -- identifies the command + gMode.  GroupIndiv: TYPE = {group, indiv, invalid};  -- operate on group or individual?  CreateDelete: TYPE = {create, delete, invalid};  CommandType: TYPE = {    summary, matches, members, aliases, details, arSelf, arMembers, arOwners,    arFriends, arAlias, arMailbox, setRemark, setPwd, createDelete, invalid};  -- ar=add/remove  -- all the data needed by a fork'ed command.  <<  ** This is not simply Items, as we process stuff a bit before  ** forking the command proc.  Here we differ from Template.  >>  ForkData: TYPE = RECORD [    anyEntry: BOOLEAN ¬ FALSE,    entry: LONG STRING ¬ NIL,  -- group or indiv    nameList: LONG STRING ¬ NIL,    remark: LONG STRING ¬ NIL,    alias: LONG STRING ¬ NIL,    pwdType: PwdType ¬ both,    password: LONG STRING ¬ NIL,    mailbox: LONG STRING ¬ NIL,    gi: GroupIndiv ¬ invalid,    cd: CreateDelete ¬ invalid,    command: CommandType ¬ invalid,    mode: ListMode ¬ members,    useBackground: BOOLEAN ¬ TRUE,    checkNames: BOOLEAN ¬ TRUE];  <<  ** Globals - all data global to one instantiation of the tool  ** This changes with the tool  >>  Globals: TYPE = RECORD [    idh: Auth.IdentityHandle ¬ NIL,    defaultsName: NSName.Name ¬ NIL,  -- name from profile    ssh: Supervisor.SubsystemHandle ¬ NULL];  Instance: TYPE = LONG POINTER TO InstanceData;  << InstanceData - per-instane tool data  ** ALL the per-instance tool data has to be packaged together for a multiple  ** instance tool.  The instance data for the current instance is retrieved  ** from the Window.Handle (which we're usually passed in call-backs) using  ** Context.  **  ** Does not change with different tools.  **  **   lock is used to syncronize the tools actions across a process boundary.  **     Needed to ensure only one command process (per-instance) at a time.  **   sws is the subwindows for the tool window.  **   windowItems is the storage for the formSW fields managed by FormSW.  **     These are allocated and deallocated automagically, and can change at  **     ANY time (i.e. mid execution of a command process.  **   windowItemsCopy is a copy of the data in windowItems, faithful to the time  **     the command was bugged.  Command processes should use the data in  **     windowItems, with the possible exception of BOOLEANS and enumerateds  **     that they want to allow to change mid-command.  **   globals is additional, tool specific per-instance state data.  >>  InstanceData: TYPE = RECORD [  << Per-instance data packaged together >>    sws: LONG POINTER TO SWs ¬ NIL,    windowItems: LONG POINTER TO Items ¬ NIL,    windowItemsCopy: LONG POINTER TO ForkData ¬ NIL,    globals: LONG POINTER TO Globals ¬ NIL];  << Type for forked command processes >>  CommandProcType: TYPE = PROCEDURE [i: Instance];  <<  ** the Command Proc's.  These are the procedures envoked whenever an action  ** is bugged in the formSW.  >>  << These exported by MaintainFork?Impl >>  DoInfoCommand: CommandProcType;  DoAmmendCommand: CommandProcType;  DoCDCommand: CommandProcType;  DoUpdateIdentity: CommandProcType;  <<  ** CommandProcInit, CommandProcCleanup - called before any other command proc, and  ** after all command procs have been called.  For initializing & cleaningup  ** after the command procs.  CommandProcCleanup is called after the zone for the  ** window stuff has been destroyed.  ** Both of these are called with the notifier held.  >>  CommandProcInit: PROCEDURE;  CommandProcCleanup: PROCEDURE;  <<  ** FreeGlobals - called from ClientTransition to free globals of one instance  ** (which are allocated from Cmds heap)  >>  FreeGlobals: PROCEDURE [i: Instance];  END.LOG  MaintainPrivate templatized by Sturtevant on 22-Oct-84 13:42:34
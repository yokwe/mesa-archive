-- File: MCHNameExtras.mesa - last edit:-- Sturtevant.PA       29-Jan-85 15:50:03-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  CH USING [ConversationHandle, PropertyID, ReturnCode, unspecified],  MCHStringExtras USING [CallBack],  NSName USING [FreeName, Name, NameRecord],  NSString USING [String];MCHNameExtras: DEFINITIONS  IMPORTS NSName =  BEGIN    « IsPattern - *'s in any field of the name? »  IsPattern: PROCEDURE [pattern: NSName.Name] RETURNS [isPattern: BOOLEAN];  « IsEmpty - tolerates name = NIL, or any of name fields = NIL »  IsEmpty: PROCEDURE [name: NSName.Name] RETURNS [isEmpty: BOOLEAN];  « AllocName - allocate a name of maximum legal size »  AllocName: PROCEDURE [z: UNCOUNTED ZONE] RETURNS [name: NSName.Name];  «  * ScopedMesaStringFromName - call callBack w/ the LONG STRING form of name  * wantLocal, wantDomain, and wantOrg determine which of the fields are  * in string callBack  »  ScopedMesaStringFromName: PROCEDURE [    name: NSName.Name, wantLocal, wantDomain, wantOrg: BOOLEAN ¬ TRUE,    callBack: MCHStringExtras.CallBack, clientData: LONG POINTER ¬ NIL];  «  * NameFromMesaString - translate a mesa string to an NSName.  * Malformed strings and NIL or empty strings appear as NIL.  * No error is given.  The caller should call NameFromMesaString  * and then check for errors using IsEmpty, instead of checking for  * String.Empty and then calling NameFromMesaString, and assuming the string is  * reasonable.  This folds malformed strings into nonexistant strings.  »  NameFromMesaString: PROCEDURE [    s: LONG STRING, z: UNCOUNTED ZONE, defaults: NSName.Name ¬ NIL]    RETURNS [name: NSName.Name];  «  * ScopedNameFromMesaString - translate a mesa string to an NSName.  * with call back  »  ScopedNameFromMesaString: PROCEDURE [    s: LONG STRING, defaults: NSName.Name ¬ NIL, callBack: CallBack,    clientData: LONG POINTER ¬ NIL];  « FreeName - like NSName.FreeName, but tolerates NIL »  FreeName: PROCEDURE [z: UNCOUNTED ZONE, name: NSName.Name] = INLINE {    IF name # NIL THEN NSName.FreeName[z, name]; };  « NameList - type for list of names (same as MailTransport.NameList) »  NameList: TYPE = LONG DESCRIPTOR FOR ARRAY CARDINAL OF NSName.NameRecord;    «  * CallBack - procedure to call with the name  * clientData first to be compatible with Put  »  CallBack: TYPE = PROCEDURE [LONG POINTER ¬ NIL, NSName.Name];  «  * ParseNameList - turns an NSString into an array of NSName.  * Parameters:  *   namesString - the names, comma separated.  *   defaults - the default domain & org  *   zone - zone to allocate nameList from  *   resolveAliases - if TRUE map aliases to distinguished names  *   expandPatterns - if TRUE, expand patterns  *   validateNames - if TRUE, raise UnfoundName for names not in  *     database. return includeIt TRUE to include the name, FALSE to exclude it  *   validatePatterns - if TRUE, raise UnfoundName for patterns that  *     match nothing in database.  Return includeIt TRUE to include the pattern,  *     FALSE to exclude it (if expandPatterns is FALSE).  *   pid - CH.PropertyID for expanding patterns  *   ch - conversation handle for CH calls  *   nameList - names returned.  * can raise TooManySeparators for malformed names (name is NSString bad name)  * if resolveAliases, expandPatterns, validateNames, or validatePatterns,  * can raise EnumerateProblem for ANY ch problem.  * rc is CH problem, name is NSName we had trouble w/ (may be a pattern).  »  ParseNameList: PROCEDURE [    namesString: NSString.String, defaults: NSName.Name ¬ NIL,    zone: UNCOUNTED ZONE,    resolveAliases, expandPatterns, validateNames, validatePatterns: BOOLEAN ¬ FALSE,    pid: CH.PropertyID ¬ CH.unspecified, ch: CH.ConversationHandle ¬ [NIL, NIL]]    RETURNS [nameList: NameList];  « Signals raised by ParseNameList »  TooManySeparators: SIGNAL [name: NSString.String];  EnumerateProblem: SIGNAL [rc: CH.ReturnCode, name: NSName.Name];  UnfoundName: SIGNAL [name: NSName.Name] RETURNS [includeIt: BOOLEAN];  «  * FreeNames frees the nameList returned by ParseNameList.  * Tolerates nameList = NIL  »  FreeNames: PROCEDURE [nameList: NameList, zone: UNCOUNTED ZONE];  END.LOG  14-Jan-85 13:39:28 - Sturtevant - created
-- File: MultipleInstance.mesa - last edit:-- Sturtevant.PA       14-Nov-84 15:24:39-- MultipleInstance.mesa-- Created Sturtevant 12-Oct-84 12:34:21<<** MultipleInstance - Defs file for procedures for maintaining multiple** instances of a tool.** Implementation is in MultipleInstanceImpl.** Use with a tool modeled after Template.** This module should be general enough that it won't have to be recompiled** for different tools.  In addition, it can be used by several tools with out** binding a separate copy into each one.** For each tool (not each instance), a separate process (StopKeyWatcher) is** forked, which raises ABORTED in a tool instance if the STOP key is hit** while the cursor is in the tool's window.****  Defines:**    Globals - record of info about this tool.  Passed into each function.**    CreateInstance - create an new instance of the tool**    DestroyInstance - destroy a specific instance**    DestroyForUnload - destroy all instances, and disallow CreateInstance**    EnumerateInstances - give data on each instance through a callback**    BirthOrder - give birth order for one instance**    SetProcess & Join - for harvesting subprocesses.**** For more information, see Template.doc, and comments in MultipleInstanceImpl.>>DIRECTORY  LockSync USING [Lock],  Process USING [Ticks],  Tool USING [MakeSWsProc, State],  ToolWindow USING [Box, Handle, nullBox, State, TransitionProcType],  Window USING [Box, Handle];MultipleInstance: DEFINITIONS =  BEGIN  <<  ** InstanceInfo - per-instance info.  ** WindowRecord is a linked list of these, not publically avail,  ** to hide the link, as management of the list must be synchronized.  ** The info is the window handle of the tool window, the birth order of the  ** tool, the process of any command (NIL for no command now), whether that  ** command is forked or not, and the lock by which the command announces  ** it's done.  >>  WindowRecord: TYPE;  InstanceInfo: TYPE = LONG POINTER TO InstanceInfoRecord;  InstanceInfoRecord: TYPE = RECORD [    wh: Window.Handle ¬ NIL,    birthOrder: CARDINAL ¬ 0,    p: PROCESS ¬ NIL,    forked: BOOLEAN ¬ FALSE,    lock: LockSync.Lock];  <<  ** Globals - data global to all instances of the tool  ** Each tool has just one of these, which is simply global to the tool  **   z is the UNCOUNTED ZONE for all the tool's storage.  **   rootName is the name of the tool.  It is registered in the Executive as  **     rootName.~.  **   maxInstances is the maximum number of instances the tool will permit.  **     it defaults to 0, for an infinite number.  **   abortable if TRUE, we raise ABORTED in command procs when the STOP  **     key is hit.  **   stopCheckInterval - how often to check for STOP key.  Default is 2x a sec.  **   windows is the list of windows (instances) - managed by this module  **   commandEnumerator - process watching STOP key & reaping dead processes.  **   numberOfInstances is the number of currently existing windows  **   numberOfBirths is the number that have ever existed  **   unloading is set TRUE when we start unloading, afterwhich anything new  **     bails out asap.  **   createsAndDestroysActive is # of CreateInstance, DestroyInstance, and  **     BirthOrder in progress.  **   enumerationsInProgress is # of EnumerationInstance's in progress.  >>  Globals: TYPE = RECORD [    << These are set in client >>    z: UNCOUNTED ZONE ¬ NIL,    rootName: LONG STRING ¬ NIL,    maxInstances: CARDINAL ¬ 0,    abortable: BOOLEAN ¬ TRUE,    stopCheckInterval: Process.Ticks ¬ 0,    << These managed by MultipleInstance - don't change in client >>    << This one is set by MultipleInstance, but can be referenced outside >>    unloading: BOOLEAN ¬ FALSE,    << These are private fields for MultipleInstance functions >>    windows: LONG POINTER TO WindowRecord ¬ NIL,    commandEnumerator: PROCESS ¬ NIL,    numberOfInstances: CARDINAL ¬ 0,    numberOfBirths: CARDINAL ¬ 0,    createsAndDestroysActive: CARDINAL ¬ 0,    enumerationsInProgress: CARDINAL ¬ 0];  GlobalsHandle: TYPE = LONG POINTER TO Globals;  << These from MultipleInstanceImpl>>  UnregisteredBirthOrder: SIGNAL RETURNS [birthOrder: CARDINAL];  <<  ** StringCallBack - type for call backs for string parameters to  ** Tool.Create.  ** Used by CreateInstance.  If this procedure  ** is non NIL, it is called.  The string it returns is passed to  ** Tool.Create.  The string still belongs to the call back.  ** Raise UnregisteredBirthOrder to find out the birthOrder of the tool  ** being created.  Don't call BirthOrder, as it's not yet on the list.  >>  StringCallBack: TYPE = PROCEDURE RETURNS [s: LONG STRING];  <<  ** CreateInstance - create a new instance of the tool, or reactivate an  ** inactive one.  Returns the window handle of the new tool.  ** Parameters are just those for Tool.Create, except that instead of  ** passing strings, you pass StringCallBack's.  If name is defaulted,  ** the name stripe name used is "rootName #n of bcd date".  Otherwise  ** nameCallBack is called, and whatever it returns is used.  ** The default cmSection is g.rootName.  >>  CreateInstance: PUBLIC PROCEDURE [    g: GlobalsHandle, nameCallBack: StringCallBack ¬ NIL,    makeSWsProc: Tool.MakeSWsProc, initialState: Tool.State ¬ default,    clientTransition: ToolWindow.TransitionProcType ¬ NIL,    movableBoundaries: BOOLEAN ¬ TRUE, initialBox: Window.Box ¬ ToolWindow.nullBox,    cmSectionCallBack, tinyName1CallBack, tinyName2CallBack: StringCallBack ¬ NIL,    named: BOOLEAN ¬ TRUE] RETURNS [window: Window.Handle];  <<  ** DestroyInstance - call Tool.Destroy on the window w.  ** Removes this instance from our list of instances.  ** Returns FALSE if we're unloading or the window handle isn't found.  >>  DestroyInstance: PROCEDURE [g: GlobalsHandle, wh: Window.Handle];  <<  ** DestroyForUnload - do a Tool.Destroy on every instance.  ** Sets g.unloading, so no more tools can be created (or destroyed).  ** Since it does a Tool.Destroy which calls ClientTransition which  ** waits for command processes to finish, it can take awhile.  ** Should be called from UnloadProc after Exec.RemoveCommand  **  ** DO NOT call EnumerateWindowHandles inside the call back.  Thank you.  >>  DestroyForUnload: PROCEDURE [g: GlobalsHandle];  <<  ** WindowToInstanceInfo - return the InstanceInfo for a window handle.  ** returns NIL for unfound handle.  ** Because there is no monitor making one wait between the end of the  ** Tool.Create and when the InstanceInfo is on the list and available  ** WindowToInstanceInfo will normally wait until that window handle  ** appears on the list.  If this is never, we will just hang.  >>  WindowToInstanceInfo: PROCEDURE [    g: GlobalsHandle, wh: Window.Handle, wait: BOOLEAN ¬ TRUE]    RETURNS [ii: InstanceInfo];  <<  ** SetProcess - record the PROCESS for an abortable command.  ** see Join, below.  >>  SetProcess: PROCEDURE [    g: GlobalsHandle, wh: Window.Handle, p: PROCESS, forked: BOOLEAN];  <<  ** Join - harvest a process.  >>  Join: PROCEDURE [g: GlobalsHandle, wh: Window.Handle];  <<  ** EnumerateInstancesProc - type for call back for EnumerateInstances  ** If continue is false, the enumeration is aborted.  ** NOTE that you shouldn't call other MultipleInstance functions from  ** within the call back (such as BirthOrder), or you'll deadlock on the  ** monitor.  ** Is passed the window handle, the birthorder, and the process of any  ** command proc for each instance.  p will be NIL if there is no command  ** proc running (in foreground or background).  >>  EnumerateInstancesProc: TYPE = PROCEDURE [ii: InstanceInfo]    RETURNS [continue: BOOLEAN ¬ TRUE];  <<  ** EnumerateInstances - enumeration procedure for all the window handles of  ** a tool.  ** The call back enumerateWindowHandlesProc is calledfor each of the  ** tool's instances.  ** NOTE that other MultipleInstance functions for the same tool will  ** wait until the enumeration finishes,  ** This is protected inside the monitor instead of just having the linked  ** list of window handles available in Globals to syncronize properly  ** with the creation and deletion of instances.  >>  EnumerateInstances: PROCEDURE [    g: GlobalsHandle, callBack: EnumerateInstancesProc];  END.LOG  Sturtevant - added wait to WindowToInstanceInfo - 14-Nov-84 15:24:36      
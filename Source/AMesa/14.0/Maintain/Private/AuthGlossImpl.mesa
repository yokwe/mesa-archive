-- AuthGlossImpl.mesa-- last edited by Mweeks,   7-Feb-85 18:09:06DIRECTORY  Auth USING [AuthenticationProblem, CallProblem, WhichArg],  AuthGloss USING [StringProc],  String USING [AppendChar, AppendOctal, AppendString];AuthGlossImpl: PROGRAM IMPORTS String EXPORTS AuthGloss =  BEGIN    AuthProblemToString: PUBLIC PROC [    authProblem: Auth.AuthenticationProblem, proc: AuthGloss.StringProc,    h: LONG POINTER ¬ NIL] = {        AuthProblemRange: TYPE = Auth.AuthenticationProblem[credentialsInvalid..inappropriateCredentials];    authProblemStrings: ARRAY AuthProblemRange OF LONG STRING = [      "credentialsInvalid"L,       "verifierInvalid"L,       "verifierExpired"L,      "verifierReused"L,       "credentialsExpired"L,       "inappropriateCredentials"L];        proc[h, "Auth.AuthenticationProblem["L];    IF authProblem IN AuthProblemRange THEN      proc[h, authProblemStrings[authProblem]]  -- index into array of strings    ELSE Unknown[proc, authProblem, h];    proc[h, "]"L];    };  CallProblemToString: PUBLIC PROC [    callProblem: Auth.CallProblem, which: Auth.WhichArg,    proc: AuthGloss.StringProc, h: LONG POINTER ¬ NIL] = {        WhichArgRange: TYPE = Auth .WhichArg[notApplicable..recipient];    CallProblemRange: TYPE = Auth .CallProblem[tooBusy..other];    callProblemStrings: ARRAY CallProblemRange OF LONG STRING = [      "tooBusy"L,       "cannotReachAS"L,      "keysUnavailable"L,      "strongKeyDoesNotExist"L,      "simpleKeyDoesNotExist"L,       "badKey"L, "accessRightsInsufficient"L,      "strongKeyAlreadyRegistered"L,       "simpleKeyAlreadyRegistered"L,      "domainForNewKeyUnavailable"L,       "domainForNewKeyUnknown"L,       "badNameForNewKey"L,      "databaseFull"L,      "other"L];    whichArgStrings: ARRAY WhichArgRange OF LONG STRING = [      "notApplicable"L,       "initiator"L,       "recipient"L];    proc[h, "Auth.CallProblem["L];    IF callProblem IN CallProblemRange THEN      proc[h, callProblemStrings[callProblem]]    ELSE Unknown[proc, callProblem, h];    proc[h, ", "L];    IF which IN WhichArgRange THEN proc[h, whichArgStrings[which]]    ELSE Unknown[proc, which, h];    proc[h, "]"];    };  Unknown: PROCEDURE [    proc: AuthGloss.StringProc, which: UNSPECIFIED, h: LONG POINTER ¬ NIL] =    BEGIN    s: STRING _ [10];    String.AppendString[s, "?("];    String.AppendOctal[s, which];    String.AppendChar[s, ')];    proc[h, s];    END;  END.LOG 7-Dec-83 16:38:30 - JMaloney - Created16-Jan-84 13:03:59 - Gealy - changed style 5-Apr-84 16:55:40 - Stucke - Stripped out the NSString stuff.  See AuthMessages, AuthMessagesImpl, and AuthGlossNSImpl for Multinational messages. 7-Feb-85 18:09:21 - Mweeks - allowed clientdata to passed with callback
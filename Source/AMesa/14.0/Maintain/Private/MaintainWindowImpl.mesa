-- File: MaintainWindowImpl.mesa - last edit:-- Sturtevant.PA       29-Jan-85  9:49:39-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Auth USING [GetIdentityDetails, IdentityHandle],  Context USING [Create, Data, Find, Type, UniqueType],  Event USING [primaryCredentials, tajoDefaults],  EventTypes USING [domain, organization, primaryCredentials],  Exec USING [AddCommand, ExecProc, Handle, RemoveCommand],  FileSW USING [GetFile],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem, Destroy,    Display, Enumerated, EnumeratedItem, EnumeratedNotifyProcType, FindItem, line0,    line1, line2, line3, line4, line5, line6, line7, line8, line9, LineN, ProcType,    StringItem],  Heap USING [Create],  LockSync USING [LockAndWait, LockNoWait, Unlock],  MCHStringExtras USING [FreeString],  MsgSW USING [Clear, Post],  MStream USING [Handle, SetLogReadLength],  MultipleInstance USING [    CreateInstance, DestroyForUnload, DestroyInstance, Globals, InstanceInfo,    Join, SetProcess, UnregisteredBirthOrder, WindowToInstanceInfo],  MaintainPrivate USING [    CommandProcCleanup, CommandProcInit, CommandProcType, CommandType,    CreateDelete, DoAmmendCommand, DoCDCommand, DoInfoCommand, DoUpdateIdentity,    ForkData, FreeGlobals, Globals, GroupIndiv, Instance, InstanceData, Items,    Level, SWs],  NSName USING [AppendNameToString, maxFullNameLength, Name],  NSString USING [AppendToMesaString, FreeString, MakeString, String],  Process USING [CancelAbort, GetCurrent, priorityNormal, SetPriority],  Profile USING [GetID],  Stream USING [GetPosition],  String USING [AppendNumber, AppendString, CopyToNewString],  Supervisor USING [    AddDependency, AgentProcedure, CreateSubsystem, RemoveDependency],  Tool USING [MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolWindow USING [Handle, TransitionProcType, WindowForSubwindow],  Window USING [Handle],  WindowFont USING [CharWidth];MaintainWindowImpl: MONITOR  IMPORTS    Auth, Context, Event, Exec, FileSW, FormSW, Heap, LockSync, MsgSW, MStream,    MultipleInstance, MaintainPrivate, NSName, NSString, Process, Profile,    Supervisor, Stream,    String, MCHStringExtras, Tool, ToolDriver, ToolWindow, WindowFont =  BEGIN  <<  ** Some common Variable Names:  **  g - the data which is global to all the instances of the tool.  A pointer  **      to g is passed to all of the MultipleInstance routines to identify the  **	  tool.  **  i - the instance data for one particular instance of the tool.  This is  **      Context instance data keyed on the window handle of the tool window.  **	  Always a local variable or a parameter.  >>  <<  ** FormItems - enumerated type for each field of FormSW.  ** generated automatically by FormSWLayoutTool & others of that ilk.  >>  FormItems: TYPE = {    level, anyEntry, group,  -- normal    gSummary, gMatches, gMembers, gAliases, gAddSelf, gRemoveSelf, gNameList,  -- owner    gAdd, gRemove, gMode, gSetRemark, gRemark, gAddAlias, gRemoveAlias, gAlias,  -- administrative    gDetails, gCreate, gDelete, individual,  -- normal    iSummary, iMatches, iAliases, iSetPwd, iPwdType, iPassword, iSetRemark,    iRemark,  -- owner    iAddMailbox, iRemoveMailbox, iMailbox,  -- administrative    iAddAlias, iRemoveAlias, iAlias, iDetails, iCreate, iDelete,  -- normal    another, destroy, useBackground, checkNames};  levels: ARRAY FormItems OF MaintainPrivate.Level = [    level: normal, anyEntry: admin, group: normal, gSummary: normal,    gMatches: normal, gMembers: normal, gAliases: normal, gAddSelf: normal,    gRemoveSelf: normal, gNameList: owner, gAdd: owner, gRemove: owner,    gMode: owner, gSetRemark: owner, gRemark: owner, gAddAlias: admin,    gRemoveAlias: admin, gAlias: admin, gDetails: admin, gCreate: admin,    gDelete: admin, individual: normal, iSummary: normal, iMatches: normal,    iAliases: normal, iSetPwd: normal, iPwdType: normal, iPassword: normal,    iSetRemark: owner, iRemark: owner, iAddMailbox: admin, iRemoveMailbox: admin,    iMailbox: admin, iAddAlias: admin, iRemoveAlias: admin, iAlias: admin,    iDetails: admin, iCreate: admin, iDelete: admin, another: normal,    destroy: normal, useBackground: admin, checkNames: admin];  <<  ** THE GLOBAL VARIABLES   ** g.z is the UNCOUNTED ZONE everything is allocated from.  >>  g: MultipleInstance.Globals ¬ [];  contextType: Context.Type = Context.UniqueType[];  saveLogFile: BOOLEAN = FALSE;  << TRUE saves log file before each new command >>  <<  ** FreeItems - deallocate storage in MaintainPrivate.Items.  ** Must change when Items changes for other tools.  >>  FreeItems: PROCEDURE [    z: UNCOUNTED ZONE, items: LONG POINTER TO MaintainPrivate.ForkData] =    BEGIN      MCHStringExtras.FreeString[z, items.entry]; items.entry ¬ NIL;      MCHStringExtras.FreeString[z, items.nameList]; items.nameList ¬ NIL;      MCHStringExtras.FreeString[z, items.remark]; items.remark ¬ NIL;      MCHStringExtras.FreeString[z, items.alias]; items.alias ¬ NIL;      MCHStringExtras.FreeString[z, items.password]; items.password ¬ NIL;      MCHStringExtras.FreeString[z, items.mailbox]; items.mailbox ¬ NIL;    END;  -- FreeItems  <<  ** SnapShotItems - snap shot the state of the formSW as windowItemsCopy.  ** Must change when Items changes for other tools.  >>  SnapShotItems: PROCEDURE [    z: UNCOUNTED ZONE, i: MaintainPrivate.Instance,    gi: MaintainPrivate.GroupIndiv] =    BEGIN    to: LONG POINTER TO MaintainPrivate.ForkData = i.windowItemsCopy;    from: LONG POINTER TO MaintainPrivate.Items = i.windowItems;    FreeItems[z, i.windowItemsCopy];    IF gi = group THEN {      to.entry ¬ String.CopyToNewString[z: z, s: from.group];      to.nameList ¬ String.CopyToNewString[z: z, s: from.gNameList];      to.remark ¬ String.CopyToNewString[z: z, s: from.gRemark];      to.alias ¬ String.CopyToNewString[z: z, s: from.gAlias];      to.mode ¬ from.gMode;      }    ELSE {      to.entry ¬ String.CopyToNewString[z: z, s: from.individual];      to.remark ¬ String.CopyToNewString[z: z, s: from.iRemark];      to.alias ¬ String.CopyToNewString[z: z, s: from.iAlias];      to.password ¬ String.CopyToNewString[z: z, s: from.iPassword];      to.pwdType ¬ from.iPwdType;      to.mailbox ¬ String.CopyToNewString[z: z, s: from.iMailbox];      };    to.anyEntry ¬ from.anyEntry;    to.useBackground ¬ from.useBackground;    to.checkNames ¬ from.checkNames;    to.gi ¬ gi;    -- cd & command filled in elsewhere.    END;  -- SnapShotItems  <<  ** CmdProc - dispatcher for all commands invoked from formSW  ** (except Another!, Destroy!).  ** CommandProc initialization changes when tool changes.  ** All the FormSW.ProcType's must check unloading, and bail out if it's TRUE.  >>  -- CmdProc - called when any action bugged.  If we're not already busy,  -- we now are, and a process is forked to do the actual work.  -- I want to prevent the data fields in the tool from changing until I've  -- copied them (when I fork), but I don't know how.  -- busies the window  -- Doesn't fork if ~useBackground (ToolDriver)  -- ProcType = PROC[sw: Window.Handle, item: ItemHandle, index: CARDINAL];  CmdProc: FormSW.ProcType =    BEGIN    z: UNCOUNTED ZONE = g.z;    command: FormItems = VAL[index];  << index is arg >>    i: MaintainPrivate.Instance = GetInstanceSW[sw];    p: PROCESS ¬ NIL;  << Compiler bug.  [] ¬ FORK  won't work >>    SaveLogFile: PROCEDURE [logSW: Window.Handle] =      BEGIN      s: MStream.Handle = FileSW.GetFile[logSW].s;      IF saveLogFile THEN        MStream.SetLogReadLength[stream: s, position: Stream.GetPosition[s]];      END;  -- SaveLogFile    -- InfoCommand - called for commands which just give information on    -- a clearinghouse entry.    InfoCommand: PROCEDURE [      gi: MaintainPrivate.GroupIndiv, command: MaintainPrivate.CommandType] =      BEGIN      SnapShotItems[z, i, gi];      i.windowItemsCopy.gi ¬ gi;      i.windowItemsCopy.cd ¬ invalid;      i.windowItemsCopy.command ¬ command;      SaveLogFile[i.sws.fileSW];      << Do it. >>      IF i.windowItemsCopy.useBackground THEN        p ¬ FORK Nanny[i, MaintainPrivate.DoInfoCommand, TRUE]      ELSE Nanny[i, MaintainPrivate.DoInfoCommand, FALSE];      END;  -- InfoCommand    -- AmmendCommand - called for commands which modify a clearinghouse entry    AmmendCommand: PROCEDURE [      gi: MaintainPrivate.GroupIndiv, cd: MaintainPrivate.CreateDelete,      command: MaintainPrivate.CommandType] =      BEGIN      SnapShotItems[z, i, gi];      i.windowItemsCopy.gi ¬ gi;      i.windowItemsCopy.cd ¬ cd;      i.windowItemsCopy.command ¬ command;      SaveLogFile[i.sws.fileSW];      << Do it. >>      IF i.windowItemsCopy.useBackground THEN        p ¬ FORK Nanny[i, MaintainPrivate.DoAmmendCommand, TRUE]      ELSE Nanny[i, MaintainPrivate.DoAmmendCommand, FALSE];      END;  -- AmmendCommand    -- CreateDeleteCommand - called for commands which create or delete an    -- entire clearinghouse entry.    CreateDeleteCommand: PROCEDURE [      gi: MaintainPrivate.GroupIndiv, cd: MaintainPrivate.CreateDelete] =      BEGIN      SnapShotItems[z, i, gi];      i.windowItemsCopy.gi ¬ gi;      i.windowItemsCopy.cd ¬ cd;      i.windowItemsCopy.command ¬ invalid;      SaveLogFile[i.sws.fileSW];      << Do it. >>      IF i.windowItemsCopy.useBackground THEN        p ¬ FORK Nanny[i, MaintainPrivate.DoCDCommand, TRUE]      ELSE Nanny[i, MaintainPrivate.DoCDCommand, FALSE];      END;  -- CreateDeleteCommand    MsgSW.Clear[i.sws.msgSW];    IF g.unloading THEN {UnloadingMsg[i]; RETURN; };    IF ~LockNoWait[i] THEN {BusyMsg[i]; RETURN; };    <<    ** JOIN synchronously - CommandEnumerator in MultipleInstance may not    ** have gotten around to it.    >>    MultipleInstance.Join[@g, i.sws.main];  << JOIN synchronously >>    << We have the lock set, & we're joined >>    SELECT command FROM      gSummary => InfoCommand[group, summary];      gMatches => InfoCommand[group, matches];      gMembers => InfoCommand[group, members];      gAliases => InfoCommand[group, aliases];      gDetails => InfoCommand[group, details];      iSummary => InfoCommand[indiv, summary];      iMatches => InfoCommand[indiv, matches];      iAliases => InfoCommand[indiv, aliases];      iDetails => InfoCommand[indiv, details];      gAddSelf => AmmendCommand[group, create, arSelf];      gRemoveSelf => AmmendCommand[group, delete, arSelf];      gAdd, gRemove =>        AmmendCommand[          group, IF command = gAdd THEN create ELSE delete,          SELECT i.windowItems.gMode FROM            members => arMembers,            owners => arOwners,            friends => arFriends,            ENDCASE => ERROR];      gAddAlias => AmmendCommand[group, create, arAlias];      gRemoveAlias => AmmendCommand[group, delete, arAlias];      iAddMailbox => AmmendCommand[indiv, create, arMailbox];      iRemoveMailbox => AmmendCommand[indiv, delete, arMailbox];      iAddAlias => AmmendCommand[indiv, create, arAlias];      iRemoveAlias => AmmendCommand[indiv, delete, arAlias];      gSetRemark => AmmendCommand[group, create, setRemark];      iSetPwd => AmmendCommand[indiv, create, setPwd];      iSetRemark => AmmendCommand[indiv, create, setRemark];      gCreate => CreateDeleteCommand[group, create];      gDelete => CreateDeleteCommand[group, delete];      iCreate => CreateDeleteCommand[indiv, create];      iDelete => CreateDeleteCommand[indiv, delete];      ENDCASE => ERROR;    END;  -- CmdProc  <<  ** Nanny - shell procedure for the command procedure  ** It's function is to get the responsibility for the unlock out of  ** the Worker, and of recording the process out of the CmdProc.¬  ** Does not change with the tool.  ** NOTE - only call after tool is created (not from ClientTransition)  >>  Nanny: PROCEDURE [    i: MaintainPrivate.Instance, CommandProc: MaintainPrivate.CommandProcType,    forked: BOOLEAN] =    BEGIN    Done: PROCEDURE =      BEGIN      MultipleInstance.SetProcess[@g, i.sws.main, Process.GetCurrent[], forked];      Unlock[i];      <<      ** now that the process is unlocked, the CommandEnumerator in      ** MultipleInstance will JOIN it.  We don't get JOINed unless the      ** SetProcess worked, so it's worth a second try - we may have come here      ** on a signal.      >>      END;  -- Done    {    ENABLE {      ABORTED => {Process.CancelAbort[Process.GetCurrent[]]; GOTO done; };      UNWIND => Done[];      };    IF forked THEN Process.SetPriority[Process.priorityNormal];    MultipleInstance.SetProcess[@g, i.sws.main, Process.GetCurrent[], forked];    CommandProc[i];    GOTO done;    EXITS done => Done[];    };    END;  -- Nanny  <<  ** Destroy = command for Destroy!  ** CAUTION - Destroy calls Tool.Destroy, which calls ClientTransition.  ** ClientTransition waits on i.lock, so we have to leave that unlocked.  ** As we aren't in a subprocess, I think it's safe to release the lock  ** before calling Tool.Destroy.  We have to call LockNoWait, so we can  ** abort things if someone else has the lock.  **  ** Does not change for other tools.  >>  Destroy: FormSW.ProcType =    BEGIN    i: MaintainPrivate.Instance = GetInstanceSW[sw];    w: Window.Handle = ToolWindow.WindowForSubwindow[sw];    MsgSW.Clear[i.sws.msgSW];    IF g.unloading THEN {UnloadingMsg[i]; RETURN; };    IF ~LockNoWait[i] THEN {BusyMsg[i]; RETURN; };    << We have the i.lock >>    Unlock[i];  << ok to call Client Transition >>    << Safe to unlock, because we have the notifier >>    MultipleInstance.DestroyInstance[@g, w];    END;  -- Destroy  <<  ** Another - command for Another!.  ** brings up a deactivated tool if possible, otherwise creates a new one  ** AND adds it to the list of window handles in g.  ** MultipleInstance.CreateInstance looks for inactive tools to reactivate.  ** Does not change when tool changes  >>  Another: FormSW.ProcType =    BEGIN    i: MaintainPrivate.Instance = GetInstanceSW[sw];    MsgSW.Clear[i.sws.msgSW];    IF g.unloading THEN {UnloadingMsg[i]; RETURN; };    IF MultipleInstance.CreateInstance[      g: @g, clientTransition: ClientTransition, makeSWsProc: MakeSWs] = NIL THEN      MsgSW.Post[sw: i.sws.msgSW, string: "No more instances allowed"L];    END;  -- Another  -- UpdateIdentity - fork a process to update identity handle  -- called from CatchEvents & ClientTransition  -- NOTE - we can be called from ClientTransition before the  -- tool is entirely created, in which case can't refer to stuff in  -- MultipleInstance.  UpdateIdentity: PROCEDURE [i: MaintainPrivate.Instance] =    BEGIN    p: PROCESS ¬ NIL;    IF i.sws.main = NIL THEN {MaintainPrivate.DoUpdateIdentity[i]; RETURN; };    << no fancy synchronization possible >>    [] ¬ LockAndWait[i];  -- WAITS for lock    MultipleInstance.Join[@g, i.sws.main];    << Do it. >>    IF i.windowItemsCopy.useBackground THEN      p ¬ FORK Nanny[i, MaintainPrivate.DoUpdateIdentity, TRUE]    ELSE Nanny[i, MaintainPrivate.DoUpdateIdentity, FALSE];    END;  -- UpdateIdentity  -- CatchEvents - catch procedure for events.  Called when any of the  -- ones we're interested in (and maybe others?) happen.  -- Called several times when one logs in: once for each event.  -- AgentProcedure = PROC[event: Event, eventData: LONG POINTER,  --			   instanceData: LONG POINTER]  CatchEvents: Supervisor.AgentProcedure =    BEGIN    SELECT event FROM      EventTypes.primaryCredentials, EventTypes.domain, EventTypes.organization =>        IF instanceData # NIL THEN UpdateIdentity[instanceData];      << I'm not sure how to check that we're ready to do this...	>>      ENDCASE;    END;  -- CatchEvents  <<  ** ClientTransition - called when ever tool changes activation state  ** Freeing the i.globals is the only part of this that should change  ** with different tools.  >>  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    z: UNCOUNTED ZONE = g.z;    i: MaintainPrivate.Instance ¬ GetInstance[window];    SELECT TRUE FROM      old = inactive => {  << ACTIVATE >>        << z has been allocated (by Init) >>        IF i = NIL THEN {          <<	  ** NOTE that the dependant storage on the instance record	  ** is created and destroyed whenever the tool is activated	  ** or deactivated, but that the instance record itself stays	  ** around until the tool is destroyed.	  ** Therefore, i may or may not exist (this tool may be undergoing	  ** its very first activation), but the fields pendant on i are	  ** sure not to exist.	  >>          i ¬ z.NEW[MaintainPrivate.InstanceData ¬ []];          Context.Create[contextType, i, DestroyContext, window];          };        << allocate all fields for this instance >>        i.sws ¬ z.NEW[MaintainPrivate.SWs ¬ []];        i.windowItems ¬ z.NEW[MaintainPrivate.Items ¬ []];        i.windowItemsCopy ¬ z.NEW[MaintainPrivate.ForkData ¬ []];        i.globals ¬ z.NEW[MaintainPrivate.Globals ¬ []];        -- Event stuff, so we catch changes in name etc.        -- i is the instanceData passed to CatchEvents on every call        i.globals.ssh ¬ Supervisor.CreateSubsystem[          agent: CatchEvents, instanceData: i];        Supervisor.AddDependency[          client: i.globals.ssh, implementor: Event.tajoDefaults];        Supervisor.AddDependency[          client: i.globals.ssh, implementor: Event.primaryCredentials];        UpdateIdentity[i];  -- make ch in child process        };      new = inactive => {  << DEACTIVATE >>        <<	** NOTE that when we return from ClientTransition, the forked procedure	** has not only finished, but been joined.  So, safe to unload.	>>        toolDriverName: LONG STRING ¬ NIL;        IF i = NIL THEN RETURN;        [] ¬ LockAndWait[i];        << Tool has finished >>        MultipleInstance.Join[@g, i.sws.main];  << JOIN synchronously >>        Unlock[i];  << unlock deactivated tool >>        << undo tool driver stuff >>        toolDriverName ¬ String.CopyToNewString[z: z, s: g.rootName, longer: 4];        IF BirthOrder[i] # 1 THEN  << 1st is special >>          String.AppendNumber[toolDriverName, BirthOrder[i], 10];  << base 10 >>        ToolDriver.RemoveSWs[tool: toolDriverName];        MCHStringExtras.FreeString[z, toolDriverName];        << Free everything >>        FormSW.Destroy[i.sws.formSW];        << windowItems strings deallocated by FromSW.Destroy >>        z.FREE[@i.windowItems];        FreeItems[z, i.windowItemsCopy];        z.FREE[@i.windowItemsCopy];        << free whatever's allocated in i.globals >>        MaintainPrivate.FreeGlobals[i];        Supervisor.RemoveDependency[          client: i.globals.ssh, implementor: Event.tajoDefaults];        Supervisor.RemoveDependency[          client: i.globals.ssh, implementor: Event.primaryCredentials];        z.FREE[@i.globals];        z.FREE[@i.sws];        };      ENDCASE;    END;  -- ClientTransition  -- LevelChanged - make things invisible/visible for  current level  LevelChanged: FormSW.EnumeratedNotifyProcType = {    i: MaintainPrivate.Instance = GetInstanceSW[sw];    oldLevel: MaintainPrivate.Level = oldValue;    FOR fi: FormItems IN FormItems DO      FormSW.FindItem[sw, ORD[fi]].flags.invisible ¬        (i.windowItems.level < levels[fi]);      ENDLOOP;    FormSW.Display[sw]};  MakeForm: FormSW.ClientItemsProcType =    BEGIN    -- for any font tool    charWidth: CARDINAL ¬ WindowFont.CharWidth['0];    CharPos: PROC [char: CARDINAL] RETURNS [x: INTEGER] = {x ¬ charWidth * char};    i: MaintainPrivate.Instance = GetInstanceSW[sw];    z: UNCOUNTED ZONE = g.z;    SetIndividual: PROCEDURE [id: Auth.IdentityHandle] =      BEGIN      name: NSName.Name;	<<name ptr into identity>>      nsStringName: NSString.String ¬ [NIL, 0, 0];      BEGIN        ENABLE UNWIND => NSString.FreeString[z, nsStringName];	[name, ,] ¬ Auth.GetIdentityDetails[id];	<<name -> nsStringName>>	nsStringName ¬ NSString.MakeString[z, NSName.maxFullNameLength];	nsStringName ¬ NSName.AppendNameToString[nsStringName, name];	<<nsStringName -> i.windowItems.individual>>	i.windowItems.individual ¬ z.NEW[StringBody[nsStringName.length]];	NSString.AppendToMesaString[i.windowItems.individual, nsStringName];      END;      NSString.FreeString[z, nsStringName];      END;	-- SetIndividual    nItems: CARDINAL = FormItems.LAST.ORD + 1;    level: ARRAY [0..3) OF FormSW.Enumerated ¬ [      ["normal"L, 0], ["owner"L, 1], ["administrative"L, 2]];    gMode: ARRAY [0..3) OF FormSW.Enumerated ¬ [      ["members"L, 0], ["friends"L, 1], ["owners"L, 2]];    iPwdType: ARRAY [0..3) OF FormSW.Enumerated ¬ [      ["strong"L, 0], ["simple"L, 1], ["both"L, 2]];    items ¬ FormSW.AllocateItemDescriptor[nItems, z];    Profile.GetID[strong, SetIndividual];  -- initialize individual    items[FormItems.level.ORD] ¬ FormSW.EnumeratedItem[      tag: "Level"L, place: [CharPos[13], FormSW.line0], feedback: all,      choices: DESCRIPTOR[level], value: @i.windowItems.level, z: z,      proc: LevelChanged];    items[FormItems.anyEntry.ORD] ¬ FormSW.BooleanItem[      tag: "AnyEntry"L, place: [CharPos[54], FormSW.line0],      switch: @i.windowItems.anyEntry, z: z];    items[FormItems.group.ORD] ¬ FormSW.StringItem[      tag: "Group"L, place: [CharPos[0], FormSW.line1], drawBox: TRUE,      inHeap: TRUE, string: @i.windowItems.group, z: z];    items[FormItems.gSummary.ORD] ¬ FormSW.CommandItem[      tag: "Summary"L, place: [CharPos[3], FormSW.line2], proc: CmdProc, z: z];    items[FormItems.gMatches.ORD] ¬ FormSW.CommandItem[      tag: "Matches"L, place: [CharPos[14], FormSW.line2], proc: CmdProc, z: z];    items[FormItems.gMembers.ORD] ¬ FormSW.CommandItem[      tag: "Members"L, place: [CharPos[24], FormSW.line2], proc: CmdProc, z: z];    items[FormItems.gAliases.ORD] ¬ FormSW.CommandItem[      tag: "Aliases"L, place: [CharPos[34], FormSW.line2], proc: CmdProc, z: z];    items[FormItems.gAddSelf.ORD] ¬ FormSW.CommandItem[      tag: "Add Self"L, place: [CharPos[3], FormSW.line3], proc: CmdProc, z: z];    items[FormItems.gRemoveSelf.ORD] ¬ FormSW.CommandItem[      tag: "Remove Self"L, place: [CharPos[14], FormSW.line3], proc: CmdProc,      z: z];    items[FormItems.gNameList.ORD] ¬ FormSW.StringItem[      tag: "Name List"L, place: [CharPos[3], FormSW.line4], inHeap: TRUE,      string: @i.windowItems.gNameList, z: z];    items[FormItems.gAdd.ORD] ¬ FormSW.CommandItem[      tag: "Add"L, place: [CharPos[3], FormSW.line5], proc: CmdProc, z: z];    items[FormItems.gRemove.ORD] ¬ FormSW.CommandItem[      tag: "Remove"L, place: [CharPos[10], FormSW.line5], proc: CmdProc, z: z];    items[FormItems.gMode.ORD] ¬ FormSW.EnumeratedItem[      tag: "Which"L, place: [CharPos[20], FormSW.line5], feedback: all,      choices: DESCRIPTOR[gMode], value: @i.windowItems.gMode, z: z];    items[FormItems.gSetRemark.ORD] ¬ FormSW.CommandItem[      tag: "Set"L, place: [CharPos[3], FormSW.line6], proc: CmdProc, z: z];    items[FormItems.gRemark.ORD] ¬ FormSW.StringItem[      tag: "Remark"L, place: [CharPos[10], FormSW.line6], inHeap: TRUE,      string: @i.windowItems.gRemark, z: z];    items[FormItems.gAddAlias.ORD] ¬ FormSW.CommandItem[      tag: "Add"L, place: [CharPos[3], FormSW.line7], proc: CmdProc, z: z];    items[FormItems.gRemoveAlias.ORD] ¬ FormSW.CommandItem[      tag: "Remove"L, place: [CharPos[10], FormSW.line7], proc: CmdProc, z: z];    items[FormItems.gAlias.ORD] ¬ FormSW.StringItem[      tag: "Alias"L, place: [CharPos[20], FormSW.line7], inHeap: TRUE,      string: @i.windowItems.gAlias, z: z];    items[FormItems.gDetails.ORD] ¬ FormSW.CommandItem[      tag: "Details"L, place: [CharPos[3], FormSW.line8], proc: CmdProc, z: z];    items[FormItems.gCreate.ORD] ¬ FormSW.CommandItem[      tag: "Create"L, place: [CharPos[14], FormSW.line8], proc: CmdProc, z: z];    items[FormItems.gDelete.ORD] ¬ FormSW.CommandItem[      tag: "Delete"L, place: [CharPos[23], FormSW.line8], proc: CmdProc, z: z];    items[FormItems.individual.ORD] ¬ FormSW.StringItem[      tag: "Individual"L, place: [CharPos[0], FormSW.line9], drawBox: TRUE,      inHeap: TRUE, string: @i.windowItems.individual, z: z];    items[FormItems.iSummary.ORD] ¬ FormSW.CommandItem[      tag: "Summary"L, place: [CharPos[3], FormSW.LineN[10]], proc: CmdProc, z: z];    items[FormItems.iMatches.ORD] ¬ FormSW.CommandItem[      tag: "Matches"L, place: [CharPos[14], FormSW.LineN[10]], proc: CmdProc,      z: z];    items[FormItems.iAliases.ORD] ¬ FormSW.CommandItem[      tag: "Aliases"L, place: [CharPos[24], FormSW.LineN[10]], proc: CmdProc,      z: z];    items[FormItems.iSetPwd.ORD] ¬ FormSW.CommandItem[      tag: "Set"L, place: [CharPos[3], FormSW.LineN[11]], proc: CmdProc, z: z];    items[FormItems.iPwdType.ORD] ¬ FormSW.EnumeratedItem[      tag: " "L, place: [CharPos[9], FormSW.LineN[11]], feedback: one,      choices: DESCRIPTOR[iPwdType], value: @i.windowItems.iPwdType, z: z];    items[FormItems.iPassword.ORD] ¬ FormSW.StringItem[      tag: "Password"L, place: [CharPos[30], FormSW.LineN[11]], inHeap: TRUE,      string: @i.windowItems.iPassword, z: z, feedback: password];    items[FormItems.iSetRemark.ORD] ¬ FormSW.CommandItem[      tag: "Set"L, place: [CharPos[3], FormSW.LineN[12]], proc: CmdProc, z: z];    items[FormItems.iRemark.ORD] ¬ FormSW.StringItem[      tag: "Remark"L, place: [CharPos[10], FormSW.LineN[12]], inHeap: TRUE,      string: @i.windowItems.iRemark, z: z];    items[FormItems.iAddMailbox.ORD] ¬ FormSW.CommandItem[      tag: "Add"L, place: [CharPos[3], FormSW.LineN[13]], proc: CmdProc, z: z];    items[FormItems.iRemoveMailbox.ORD] ¬ FormSW.CommandItem[      tag: "Remove"L, place: [CharPos[10], FormSW.LineN[13]], proc: CmdProc, z: z];    items[FormItems.iMailbox.ORD] ¬ FormSW.StringItem[      tag: "Mailbox"L, place: [CharPos[20], FormSW.LineN[13]], inHeap: TRUE,      string: @i.windowItems.iMailbox, z: z];    items[FormItems.iAddAlias.ORD] ¬ FormSW.CommandItem[      tag: "Add"L, place: [CharPos[3], FormSW.LineN[14]], proc: CmdProc, z: z];    items[FormItems.iRemoveAlias.ORD] ¬ FormSW.CommandItem[      tag: "Remove"L, place: [CharPos[10], FormSW.LineN[14]], proc: CmdProc, z: z];    items[FormItems.iAlias.ORD] ¬ FormSW.StringItem[      tag: "Alias"L, place: [CharPos[20], FormSW.LineN[14]], inHeap: TRUE,      string: @i.windowItems.iAlias, z: z];    items[FormItems.iDetails.ORD] ¬ FormSW.CommandItem[      tag: "Details"L, place: [CharPos[3], FormSW.LineN[15]], proc: CmdProc, z: z];    items[FormItems.iCreate.ORD] ¬ FormSW.CommandItem[      tag: "Create"L, place: [CharPos[14], FormSW.LineN[15]], proc: CmdProc, z: z];    items[FormItems.iDelete.ORD] ¬ FormSW.CommandItem[      tag: "Delete"L, place: [CharPos[23], FormSW.LineN[15]], proc: CmdProc, z: z];    items[FormItems.another.ORD] ¬ FormSW.CommandItem[      tag: "Another"L, place: [CharPos[0], FormSW.LineN[16]], proc: Another, z: z];    items[FormItems.destroy.ORD] ¬ FormSW.CommandItem[      tag: "Destroy"L, place: [CharPos[10], FormSW.LineN[16]], proc: Destroy,      z: z];    items[FormItems.useBackground.ORD] ¬ FormSW.BooleanItem[      tag: "UseBackground"L, place: [CharPos[20], FormSW.LineN[16]],      switch: @i.windowItems.useBackground, z: z];    items[FormItems.checkNames.ORD] ¬ FormSW.BooleanItem[      tag: "CheckNames"L, place: [CharPos[37], FormSW.LineN[16]],      switch: @i.windowItems.checkNames, z: z];    FOR fi: FormItems IN FormItems DO      IF levels[fi] # i.windowItems.level THEN        items[ORD[fi]].flags.invisible ¬ TRUE;      ENDLOOP;    RETURN[items: items, freeDesc: TRUE];    END;  <<  ** Init - called just once at the very beginning of time.  ** Init registers the command with the executive.  When RegisterCommand  ** is called, the global data will be allocated.  ** NOTE: Impossible to call UnloadProc before g is  ** initialized.  ** only the name of the tool in Rootname needs to change when the tool changes  ** can also add a help proc to the Exec.AddCommand.  >>  Init: PROCEDURE =    BEGIN    z: UNCOUNTED ZONE ¬ NIL;    commandName: LONG STRING ¬ NIL;    z ¬ Heap.Create[initial: 4, increment: 1, ownerChecking: TRUE, checking: TRUE];    g.rootName ¬ String.CopyToNewString[z: z, s: "Maintain"L];    g.z ¬ z;  << zone in g >>    commandName ¬ String.CopyToNewString[s: g.rootName, z: z, longer: 2];    String.AppendString[to: commandName, from: ".~"L];    Exec.AddCommand[name: commandName, proc: RegisterCommand, unload: UnloadProc];    MCHStringExtras.FreeString[z, commandName];    MaintainPrivate.CommandProcInit[];  << initialization for Command Procs >>    END;  -- Init  << THE EXEC PROCS >>  <<  ** RegisterCommand - called whenever we try to start things from the  ** executive.  ** g allocated once & for all in Init.  ** We activate an inactive instance if one  ** exists, otherwise call CreateInstance.  This is what starts things  ** going by calling CreateInstance.  ** Note that CreateInstance will simply awaken an inactive instance if one  ** exists.  ** This does not have to be modified for other tools.  >>  RegisterCommand: Exec.ExecProc =    BEGIN    IF g.unloading THEN RETURN;    IF MultipleInstance.CreateInstance[      g: @g, clientTransition: ClientTransition, makeSWsProc: MakeSWs] = NIL THEN      RETURN[error];  << too many instances >>    END;  -- RegisterCommand  <<  ** UnloadProc - called from executive to unload.  ** Sets unloading to TRUE, so no one else trys to do anything.  ** There is a race condition here, as FormSW can continue to  ** have code in this module called even when we're unloading.  ** Once we're in the module and can do something about it, it's too  ** late.  However, checking & returning instantly is the best we can  ** do, and should work ok on a single processor system.  ** waits for all instances to complete (ClientTransition via Tool.Destroy),  ** destroys g and g.z  **  ** CAUTION: ClientTransition is called as a side effect of Tool.Destroy  ** in MultipleInstance.DestroyForUnload. ClientTransition waits for forked  ** operations to complete.  **  ** This shouldn't have to be modified for other tools, unless there is other  ** cleanup to do.  **  ** Exec.ExecProc: TYPE = PROCEDURE [h: Exec.Handle,  **				      clientData: LONG POINTER ¬ NIL]  **   RETURNS [outcome: Exec.Outcome ¬ normal];  >>  UnloadProc: Exec.ExecProc =    BEGIN    commandName: LONG STRING ¬ NIL;    g.unloading ¬ TRUE;  << everyone else aborts >>    commandName ¬ String.CopyToNewString[s: g.rootName, z: g.z, longer: 2];    String.AppendString[to: commandName, from: ".~"L];    Exec.RemoveCommand[h, commandName];  << delete command from executive >>    MCHStringExtras.FreeString[g.z, commandName];    MultipleInstance.DestroyForUnload[@g];    MaintainPrivate.CommandProcCleanup[];    <<    ** now we return, are unloaded, and the world goes away.    >>    END;  -- UnloadProc  <<  ** DestroyContext - called by Context.Destroy in DestroyInstance  ** Tool.Destroy has been called, which called ClientTransition, which  ** freed everything except the i record.  ** Does not change for other tools  >>  DestroyContext: PROCEDURE [i: Context.Data, wh: Window.Handle] = {    z: UNCOUNTED ZONE = g.z; z.FREE[@i]; };  <<  ** MakeSWs - called from CreateInstance (once per-instance)  ** If the tool is just being reactivated, then the instance info is on the  ** list, and we can retrieve it by normal means (w/o waiting).  ** If not, then we are  ** called from MultipleInstance.CreateInstance, and can get the birthOrder  ** off of the dynamic scoping with the signal UnregisteredBirthOrder.  >>  MakeSWs: Tool.MakeSWsProc =    BEGIN    z: UNCOUNTED ZONE = g.z;    logName: LONG STRING ¬ [24];    logRoot: LONG STRING ¬ NIL;    i: MaintainPrivate.Instance = GetInstance[window];    birthOrder: CARDINAL;    ii: MultipleInstance.InstanceInfo;    toolDriverName: LONG STRING ¬ NIL;    addresses: ARRAY [0..3) OF ToolDriver.Address;    logRoot ¬ String.CopyToNewString[z: z, s: g.rootName, longer: 4];    String.AppendString[to: logRoot, from: ".log"L];    Tool.UnusedLogName[unused: logName, root: logRoot];    MCHStringExtras.FreeString[z, logRoot];    i.sws.main ¬ window;    i.sws.msgSW ¬ Tool.MakeMsgSW[window: window];    i.sws.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm, zone: z];    i.sws.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    << ToolDriver stuff >>    toolDriverName ¬ String.CopyToNewString[z: z, s: g.rootName, longer: 4];    ii ¬ MultipleInstance.WindowToInstanceInfo[@g, i.sws.main, FALSE];    IF ii # NIL THEN birthOrder ¬ ii.birthOrder    ELSE birthOrder ¬ SIGNAL MultipleInstance.UnregisteredBirthOrder[];    IF birthOrder # 1 THEN  << 1st is special >>      String.AppendNumber[toolDriverName, birthOrder, 10];  << base 10 >>    addresses ¬ [      [name: "MsgSW"L, sw: i.sws.msgSW], [name: "FormSW"L, sw: i.sws.formSW], [      name: "FileSW"L, sw: i.sws.fileSW]];    ToolDriver.NoteSWs[tool: toolDriverName, subwindows: DESCRIPTOR[addresses]];    MCHStringExtras.FreeString[z, toolDriverName];    END;  -- MakeSWs  <<  ** These two map from window handle to InstanceData  ** Do not change with the tool.  >>  GetInstance: PROCEDURE [w: Window.Handle] RETURNS [Context.Data] = {    RETURN Context.Find[contextType, w]; };  GetInstanceSW: PROCEDURE [sw: Window.Handle] RETURNS [Context.Data] = {    RETURN Context.Find[contextType, ToolWindow.WindowForSubwindow[sw]]; };  <<  ** Functions which call MultipleInstance.WindowToInstanceInfo.  ** These don't change with the tool.  >>  <<  ** BirthOrder - birthOrder of instance  ** Does not change with the tool.  >>  BirthOrder: PROCEDURE [i: MaintainPrivate.Instance] RETURNS [CARDINAL] =    BEGIN    ii: MultipleInstance.InstanceInfo = MultipleInstance.WindowToInstanceInfo[      @g, i.sws.main];    IF ii = NIL THEN RETURN[0];    RETURN[ii.birthOrder];    END;  -- BirthOrder  LockNoWait: PROCEDURE [i: MaintainPrivate.Instance]    RETURNS [gotTheLock: BOOLEAN] =    BEGIN    ii: MultipleInstance.InstanceInfo = MultipleInstance.WindowToInstanceInfo[      @g, i.sws.main];    IF ii = NIL THEN RETURN[FALSE];    RETURN[LockSync.LockNoWait[@ii.lock]];    END;  -- LockNoWait  LockAndWait: PROCEDURE [i: MaintainPrivate.Instance]    RETURNS [noWait: BOOLEAN] =    BEGIN    ii: MultipleInstance.InstanceInfo = MultipleInstance.WindowToInstanceInfo[      @g, i.sws.main];    IF ii = NIL THEN ERROR;    RETURN[LockSync.LockAndWait[@ii.lock]];    END;  -- LockAndWait  << NOTE - can't unlock when i.sws = NIL >>  Unlock: PROCEDURE [i: MaintainPrivate.Instance] =    BEGIN    ii: MultipleInstance.InstanceInfo = MultipleInstance.WindowToInstanceInfo[      @g, i.sws.main];    IF ii = NIL THEN RETURN;    LockSync.Unlock[@ii.lock];    END;  -- Unlock  <<  ** BusyMsg & UnloadingMsg - functions to post to MsgSW  ** BusyMsg - Maintain is busy  ** UnloadingMsg - Maintain is unloading  >>  BusyMsg: PROCEDURE [i: MaintainPrivate.Instance] =    BEGIN    MsgSW.Post[sw: i.sws.msgSW, string: g.rootName, endOfMsg: FALSE];    MsgSW.Post[i.sws.msgSW, " is busy"L];    RETURN;    END;  -- BusyMsg  UnloadingMsg: PROCEDURE [i: MaintainPrivate.Instance] =    BEGIN    MsgSW.Post[sw: i.sws.msgSW, string: g.rootName, endOfMsg: FALSE];    MsgSW.Post[i.sws.msgSW, " is unloading"L];    RETURN;    END;  -- UnloadingMsg  Init[];  << Mainline code >>  END.LOG  Templatized by Sturtevant 22-Oct-84 14:00:06  Create by FormSWLayoutTool on  6-Apr-84 14:33  added Supervisor dependancy stuff Sturtevant 11-Apr-84  9:42:30  put ConvHandle initializing stuff in monitor - Sturtevant 13-Apr-84 11:50:57  forked processes to do real work. Sturtevant 16-Apr-84 11:51:40  started to add other commands.  Sturtevant 24-Apr-84 16:40:12  renamed MaintainWindowImpl.mesa on  2-May-84 11:08:45  converted to resemble CHBenchMark Sturtevant 24-Jul-84 16:24:22  Calaverafied - Sturtevant -  4-Jan-85 12:41:03
-- File: MCHNameExtrasImpl.mesa - last edit:-- Sturtevant.PA       12-Feb-85 17:47:24-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Ascii USING [CR, LF, TAB, SP],  CH USING [    ConversationHandle, Enumerate, FreeProperties, GetProperties, NameStreamProc,    Properties, PropertyID, ReturnCode, unspecified],  Environment USING [Byte],  Heap USING [FreeNode, MakeNode],  MCHNameExtras USING [    AllocName, CallBack, FreeName, NameList, IsPattern, UnfoundName],  MCHStringExtras USING [CallBack, NSIsEmpty],  NSName USING [    CopyNameFields, Error, FreeNameFields, MakeName, maxDomainLength,    maxLocalLength, maxOrgLength, Name,    NameFromString, NameRecord, separator, SubdivideName, wildCardCharacter],  NSString USING [    AppendSubString, AppendToMesaString, FreeString, MakeString, nullString,    ScanForCharacter, String, StringFromMesaString, SubStringDescriptor],  String USING [AppendChar, Empty];MCHNameExtrasImpl: PROGRAM  IMPORTS CH, Heap, MCHNameExtras, MCHStringExtras, NSName, NSString, String  EXPORTS MCHNameExtras =  BEGIN  ScopedMesaStringFromName: PUBLIC PROCEDURE [    name: NSName.Name, wantLocal, wantDomain, wantOrg: BOOLEAN ¬ TRUE,    callBack: MCHStringExtras.CallBack, clientData: LONG POINTER] =    BEGIN    nameString: LONG STRING ¬ [      NSName.maxOrgLength + NSName.maxDomainLength + NSName.maxLocalLength + 2];    IF IsEmpty[name] THEN {      String.AppendChar[nameString, NSName.separator];      String.AppendChar[nameString, NSName.separator];    }    ELSE {      IF wantLocal AND ~MCHStringExtras.NSIsEmpty[name.local] THEN	NSString.AppendToMesaString[nameString, name.local];      String.AppendChar[nameString, NSName.separator];      IF wantDomain AND ~MCHStringExtras.NSIsEmpty[name.domain] THEN	NSString.AppendToMesaString[nameString, name.domain];      String.AppendChar[nameString, NSName.separator];      IF wantOrg AND ~MCHStringExtras.NSIsEmpty[name.org] THEN	NSString.AppendToMesaString[nameString, name.org];    };    callBack[clientData, nameString];    END;  -- ScopedMesaStringFromName  IsPattern: PUBLIC PROCEDURE [pattern: NSName.Name]    RETURNS [isPattern: BOOLEAN] =    BEGIN    RETURN[      pattern # NIL        AND           ((pattern.local.bytes # NIL AND NSString.ScanForCharacter[NSName.wildCardCharacter, pattern.local] #             LAST[CARDINAL])            OR              (pattern.domain.bytes # NIL AND NSString.ScanForCharacter[NSName.wildCardCharacter, pattern.domain]                # LAST[CARDINAL])            OR              (pattern.org.bytes # NIL AND NSString.ScanForCharacter[NSName.wildCardCharacter, pattern.org] #                LAST[CARDINAL]))];    END;  -- IsPattern  IsEmpty: PUBLIC PROCEDURE [name: NSName.Name] RETURNS [isEmpty: BOOLEAN] =    BEGIN    RETURN[      name = NIL        OR          ((name.org.length = 0 OR name.org.bytes = NIL)            AND (name.domain.length = 0 OR name.domain.bytes = NIL)            AND (name.local.length = 0 OR name.local.bytes = NIL))];    END;  -- IsEmpty  AllocName: PUBLIC PROCEDURE [z: UNCOUNTED ZONE] RETURNS [NSName.Name] =    BEGIN    RETURN[      NSName.MakeName[        z, NSName.maxOrgLength, NSName.maxDomainLength, NSName.maxLocalLength]];    END;  -- AllocName  «  * NameFromMesaString - translate a mesa string to an NSName.  * We translate malformed strings and NIL or empty strings to NIL.  * No error is given.  The caller should call MesaStringToNSName  * and then check for errors using IsEmptyNSName, instead of checking for  * String.Empty and then calling MesaStringToNSName, and assuming the string is  * reasonable.  This has the effect of folding malformed strings into  * nonexistant strings.  »  NameFromMesaString: PUBLIC PROCEDURE [    s: LONG STRING, z: UNCOUNTED ZONE, defaults: NSName.Name]    RETURNS [name: NSName.Name ¬ NIL] =    BEGIN    ENABLE NSName.Error => {MCHNameExtras.FreeName[z, name]; name ¬ NIL; CONTINUE; };    IF String.Empty[s] THEN RETURN[NIL];    name ¬ NSName.NameFromString[z, NSString.StringFromMesaString[s], defaults];    RETURN[name];    END;	-- NameFromMesaString  «  * ScopedNameFromMesaString - translate a mesa string to an NSName.  * with call back  * will probably blow up if s is NIL.  What should we do in that case?  »  ScopedNameFromMesaString: PUBLIC PROCEDURE [    s: LONG STRING, defaults: NSName.Name,    callBack: MCHNameExtras.CallBack, clientData: LONG POINTER] =    BEGIN      LocalCallBack: PROCEDURE [n: NSName.Name] ={ callBack[clientData, n]; };      NSName.SubdivideName[        NSString.StringFromMesaString[s], LocalCallBack, defaults];      END;	-- ScopedNameFromMesaString«******************************************************************************»«Stuff for ParseNameList»  -- PUBLIC SIGNALS  TooManySeparators: PUBLIC SIGNAL [name: NSString.String] = CODE;  EnumerateProblem: PUBLIC SIGNAL [rc: CH.ReturnCode, name: NSName.Name] = CODE;  UnfoundName: PUBLIC SIGNAL [name: NSName.Name] RETURNS [includeIt: BOOLEAN]    = CODE;  -- CONSTANTS  comma: Environment.Byte = LOOPHOLE[',];  space: Environment.Byte = LOOPHOLE[Ascii.SP];  « now treats these three like space - Sturtevant 20-Aug-84 16:48:33 »  cr: Environment.Byte = LOOPHOLE[Ascii.CR];  lf: Environment.Byte = LOOPHOLE[Ascii.LF];  tab: Environment.Byte = LOOPHOLE[Ascii.TAB];  -- PUBLIC PROCS  --**************************************  FreeNames: PUBLIC PROC [nameList: MCHNameExtras.NameList, zone: UNCOUNTED ZONE] =    -- free the storage of a name list.    BEGIN    IF nameList = NIL THEN RETURN;    FOR i: CARDINAL IN [0..LENGTH[nameList]) DO      NSName.FreeNameFields[zone, @nameList[i]]; ENDLOOP;    Heap.FreeNode[zone, BASE[nameList]];    END;  -- proc. FreeNames  --***************************************  «  * CallError is for problems arrising if we're passed bad args.  Bug is for  * internal inconsistancies, indicating a bug in the code.  »  CallError: ERROR [problem: CallErrorType] = CODE;  CallErrorType: TYPE = {needCH};  ParseNameList: PUBLIC PROC [    namesString: NSString.String, defaults: NSName.Name, zone: UNCOUNTED ZONE,    resolveAliases, expandPatterns, validateNames, validatePatterns: BOOLEAN,    pid: CH.PropertyID, ch: CH.ConversationHandle]    RETURNS [nameList: MCHNameExtras.NameList] =    -- Converts namesString (e.g. reply-to field) to an array of FULLY QUALIFIED    -- NSName.NameRecords using the defaults passed in which should be the logged    -- in user's name so the default domain and org are that of the logged in user    -- Can raise SIGNAL TooManySeparators[name].    BEGIN    needCH: BOOLEAN = resolveAliases OR expandPatterns OR validateNames      OR validatePatterns;    arrayPtr: LONG POINTER TO ARRAY OF NSName.NameRecord ¬ NIL;    nsstrName: NSString.String ¬ NSString.nullString;    ss: NSString.SubStringDescriptor ¬ [base: namesString, offset: 0, length: 0];    index: CARDINAL ¬ 0;    saveIndex: CARDINAL ¬ 0;    stop: CARDINAL ¬ namesString.length;    char: Environment.Byte;    state: {lookForName, lookEndName, storeName, passComma} ¬ lookForName;    count: CARDINAL ¬ 0;    init, max: CARDINAL ¬      IF namesString.length < 7 THEN namesString.length      ELSE namesString.length / 7;  -- guess for # of names    incrBy: CARDINAL ¬ 10;    IF namesString = NSString.nullString OR namesString.length = 0 THEN      RETURN[NIL];    IF needCH AND ch = [NIL, NIL] THEN ERROR CallError[needCH];    BEGIN    ENABLE      UNWIND => {        NSString.FreeString[zone, nsstrName];        FreeNames[DESCRIPTOR[arrayPtr, count], zone]};    BumpIndex: PROC =      -- gets the next character, updates the index.      BEGIN      saveIndex ¬ index;      char ¬ namesString.bytes[index];      index ¬ index + 1;      END;  -- proc. BumpIndex    GetNonBlanks: PROC =      -- will parse til it reaches a non-blank character and set the parsing state appropriately      BEGIN      WHILE index < stop DO  -- parse name list        BumpIndex[];        SELECT char FROM          comma, space, cr, lf, tab => LOOP;  -- skip blanks          ENDCASE => {            state ¬ lookEndName;  -- time to find name end            RETURN;            };        ENDLOOP;      END;  -- proc. GetNonBlanks    GetNonAlpha: PROC =      -- will parse til it reaches a non-alphabetic character and set the parsing state appropriately.      BEGIN      oldIndex: CARDINAL;  -- index char found starts at      spaceIndex: CARDINAL;      firstSpace: BOOLEAN ¬ TRUE;      Store: PROC =        BEGIN        IF firstSpace THEN spaceIndex ¬ oldIndex;  -- reached end of string        ss.length ¬ spaceIndex - ss.offset;  -- length of name        StoreName[];        state ¬ lookForName;        END;  -- proc. Store      ss.offset ¬ saveIndex;  -- name starts here      state ¬ storeName;  -- default if we reach end of $      WHILE index < stop DO  -- parse name list        oldIndex ¬ index;  -- save the index        BumpIndex[];        SELECT char FROM          space, cr, lf, tab => {  -- end of name            IF firstSpace THEN {spaceIndex ¬ oldIndex; firstSpace ¬ FALSE; }; };          comma => {  -- end of name            Store[]; RETURN; };          ENDCASE => {firstSpace ¬ TRUE; spaceIndex ¬ oldIndex; LOOP; };  -- still in name        ENDLOOP;      oldIndex ¬ index;      Store[];      END;  -- END GetNonAlpha    StoreName: PROC =      -- converts the SubStringDescriptor to an NSString.String and converts      -- the NSString.String to an NSName.NameRecord.       BEGIN      AddName: CH.NameStreamProc = {        IF count = max THEN IncreaseArray[];  -- need bigger array        arrayPtr[count] ¬ [          NSString.nullString, NSString.nullString, NSString.nullString];        NSName.CopyNameFields[          z: zone, source: currentName, destination: @arrayPtr[count]];        IF nameOK THEN count ¬ count + 1;        namesAdded ¬ namesAdded + 1;        };  -- AddName      CountName: CH.NameStreamProc = {namesAdded ¬ namesAdded + 1; };  -- CountName      Done: PROCEDURE =        BEGIN        MCHNameExtras.FreeName[zone, name];        name ¬ NIL;        MCHNameExtras.FreeName[zone, dname];        dname ¬ NIL;        IF properties # NIL THEN CH.FreeProperties[@properties, zone];        END;  -- Done      name: NSName.Name ¬ NIL;      dname: NSName.Name ¬ MCHNameExtras.AllocName[zone];      rc: CH.ReturnCode;      properties: CH.Properties ¬ NIL;      nameOK: BOOLEAN ¬ TRUE;      i: INTEGER ¬ 0;      namesAdded: CARDINAL ¬ 0;  «incremented by AddName & CountName»      {      ENABLE UNWIND => Done[];      nsstrName.length ¬ 0;  -- reset      nsstrName ¬ NSString.AppendSubString[nsstrName, @ss];  -- append name      name ¬ NSName.NameFromString[        zone, nsstrName, defaults !        NSName.Error => {          SIGNAL TooManySeparators[nsstrName]; nameOK ¬ FALSE; CONTINUE}];      IF ~nameOK THEN GOTO done;      «nameOK is TRUE»      IF ~needCH THEN {  «nothing fancy»        AddName[name]; GOTO done; };      IF MCHNameExtras.IsPattern[name] THEN        SELECT TRUE FROM          expandPatterns => {            rc ¬ CH.Enumerate[ch, name, pid, AddName];            IF rc.code # done THEN {              SIGNAL EnumerateProblem[rc, name]; nameOK ¬ FALSE; };            IF namesAdded = 0 AND validatePatterns THEN              [] ¬ SIGNAL MCHNameExtras.UnfoundName[name];            };          validatePatterns => {            rc ¬ CH.Enumerate[ch, name, pid, CountName];            IF rc.code # done THEN {              SIGNAL EnumerateProblem[rc, name]; nameOK ¬ FALSE; };            IF namesAdded = 0 THEN              IF SIGNAL MCHNameExtras.UnfoundName[name] THEN AddName[name];            };          ENDCASE => AddName[name]      ELSE {  «~IsPattern[name]»        «Enumerate doesn't map aliases to distinguished names»        [rc, properties] ¬ CH.GetProperties[ch, name, dname, zone];        SELECT rc.code FROM          noSuchLocal, noSuchDomain, noSuchOrg =>            IF validateNames THEN {              IF SIGNAL MCHNameExtras.UnfoundName[name] THEN AddName[name]; }  «dangling ELSE»            ELSE IF pid = CH.unspecified THEN AddName[name];  «else drop it»          done => {            nameToAdd: NSName.Name = IF resolveAliases THEN dname ELSE name;            «pid 0 not returned by GetProperties»            IF pid = CH.unspecified THEN AddName[nameToAdd]            ELSE              FOR i: CARDINAL IN [0..LENGTH[properties]) DO                IF properties[i] = pid THEN AddName[nameToAdd]; ENDLOOP;            };          ENDCASE => {SIGNAL EnumerateProblem[rc, name]; nameOK ¬ FALSE; };        };      GOTO done;      EXITS done => Done[];      };      END;  -- END StoreName    IncreaseArray: PROC =      -- gets more storage for the name array      BEGIN  -- BEGIN IncreaseArray      newPtr: LONG POINTER TO ARRAY OF NSName.NameRecord ¬ Heap.MakeNode[        zone, (max + incrBy) * SIZE[NSName.NameRecord]];      FOR n: CARDINAL IN [0..max) DO newPtr[n] ¬ arrayPtr[n]; ENDLOOP;  -- copy each NameRecord      max ¬ max + incrBy;      Heap.FreeNode[zone, arrayPtr];      arrayPtr ¬ newPtr;      END;  -- proc. IncreaseArray    nsstrName ¬ NSString.MakeString[zone, namesString.length];    arrayPtr ¬ Heap.MakeNode[zone, init * SIZE[NSName.NameRecord]];    WHILE index < stop DO  -- parse the name list      SELECT state FROM        lookForName => GetNonBlanks[];  -- find start of name        lookEndName => GetNonAlpha[];  -- find end of name        storeName => {StoreName[]; state ¬ lookEndName; };  -- store in array        passComma => {  -- pass comma between names          StoreName[]; IF index < stop THEN BumpIndex[]; state ¬ lookForName; };        ENDCASE => NULL;      ENDLOOP;    IF state = storeName THEN StoreName[];  -- reached end $ before store    END;  -- ENABLE block    NSString.FreeString[zone, nsstrName];    RETURN[DESCRIPTOR[arrayPtr, count]];  -- here's the names    END;  -- END ParseNameList  END.LOG 22-Jan-85 15:03:57 - created - Sturtevant-- ParseNameList log-- stolen from ITSStringUtilitiesImpl.  13-Apr-83 12:59:51		-- name defaults  default to NIL  16-May-83 12:16:19	-- added zones to procs for general use.  20-Aug-84 15:34:03 - Sturtevant - created  25-Oct-83 15:12:13 - Brenda Hankins - now for NSHardy use  30-Nov-83 12:05:49 - AlHall - forked away from NSHardy  16-Jan-85 13:41:32 - Sturtevant - added resolveAliases, expandPatterns, validateNames, validatePatterns
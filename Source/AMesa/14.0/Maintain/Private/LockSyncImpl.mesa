-- File: LockSyncImpl.mesa - last edit:-- Sturtevant.PA        7-Nov-84 13:47:16-- Copyright (C) 1984 by Xerox Corporation. All rights reserved. DIRECTORY  LockSync USING [Lock];<<** NOTE: This is a monitor, and all the procedures are entry procedures** because they must be indivisible to avoid race conditions.  WAIT unlocks** the monitor while it's waiting, so the lock is never held for very long at all.>>LockSyncImpl: MONITOR EXPORTS LockSync =  BEGIN  <<  ** LockAndWait - Lock the lock.  Monitor lock is released on WAIT, so  ** we don't deadlock here.  >>  LockAndWait: PUBLIC ENTRY PROCEDURE [lock: LONG POINTER TO LockSync.Lock]    RETURNS [noWait: BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;  -- So I release monitor lock    noWait ¬ ~lock.busy;  -- initial state    WHILE lock.busy DO WAIT lock.cond ENDLOOP;    lock.busy ¬ TRUE;    RETURN;  -- returns initial state - of interest if we didn't wait    END;  LockNoWait: PUBLIC ENTRY PROCEDURE [lock: LONG POINTER TO LockSync.Lock]    RETURNS [gotTheLock: BOOLEAN] =    BEGIN    ENABLE UNWIND => NULL;    gotTheLock ¬ ~lock.busy;    lock.busy ¬ TRUE;  -- locked, we return FALSE if lock held by us.    RETURN;    END;  Unlock: PUBLIC ENTRY PROCEDURE [lock: LONG POINTER TO LockSync.Lock] =    BEGIN    ENABLE UNWIND => NULL;  -- So I release monitor lock    lock.busy ¬ FALSE;    NOTIFY lock.cond;  << Mark Gealy thinks this should be a BROADCAST >>    <<    ** NOTE that by doing NOTIFY and not BROADCAST, things get unlocked in    ** order.  May need to rethink this somewhat if things ever deadlock    ** on dropped NOTIFYs.    >>    END;  END.LOG  Created Sturtevant 22-Aug-84  6:46:16
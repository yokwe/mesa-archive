-- File: MaintainCmdsBImpl.mesa - last edit:-- Sturtevant.PA       29-Jan-85 10:45:18-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Auth USING [    CallError, ChangeMyPasswords, CreateSimpleKey, CreateStrongKey,    DeleteSimpleKey, DeleteStrongKey, HashSimplePassword, PasswordStringToKey],  AuthGloss USING [CallProblemToString],  CH USING [    AddAlias, AddDistinguishedName, AddGroupMember, AddGroupProperty, AddSelf,    AddValueProperty, Buffer, ChangeValueProperty, ConversationHandle,    DeleteAlias, DeleteDistinguishedName, DeleteGroupMember, DeleteSelf,    EnumerateNewGroupElements, FreeConversationHandle, FreeRhs,    LookupDistinguishedName, Name, NameStreamProc, PropertyID, ReturnCode,    SerializeIntoRhs, unspecified],  CHEntries USING [DescribePrimary, DescribeUserData, UserData],  CHGloss USING [ReturnCodeToString],  CHPIDs USING [members, user, userData, userGroup],  MCHNameExtras USING [    AllocName, EnumerateProblem, FreeName, FreeNames, IsPattern,    NameFromMesaString, NameList, ParseNameList, TooManySeparators,    UnfoundName],  MCHPutExtras USING [Name, PutNSString],  MoreCH USING [AddPropertyAccessMember, DeletePropertyAccessMember],  MsgSW USING [AppendString, Clear],  MaintainCmds USING [MakeCh, MissingFieldRequest, NotFoundError, nullCH],  MaintainPrivate USING [CommandProcType, CreateDelete, GroupIndiv, Instance],  NSName USING [EquivalentNames, FreeName, Name],  NSString USING [String, StringFromMesaString],  Process USING [Pause, SecondsToTicks, Ticks],  Put USING [CR, Text],  String USING [Empty],  ToolWindow USING [Handle, WindowForSubwindow],  Window USING [Handle];MaintainCmdsBImpl: PROGRAM  IMPORTS    Auth, AuthGloss, CH, CHEntries, CHGloss, MoreCH, MsgSW, MCHNameExtras,    MaintainCmds,    NSName, NSString, Process, Put, MCHPutExtras, String, ToolWindow  EXPORTS MaintainPrivate, MaintainCmds =  BEGIN  bugType: TYPE = {unknownSelect};  Bug: ERROR [type: bugType] = CODE;  z: UNCOUNTED ZONE ¬ NIL;  << allocated in CmdsA >>  << these 2 exported to MaintainCmds >>  CmdsBInit: PUBLIC PROCEDURE [zone: UNCOUNTED ZONE] = {z ¬ zone; };  CmdsBCleanup: PUBLIC PROCEDURE = {z ¬ NIL};  << on overflowOfDataBase, we always assume that we're just ahead of the  ** scavenger, wait and retry.  If the data base is really full, this wil be  ** an infinite loop until interupted.  (Interupt at top of retried procs).  >>  PauseAndRetry: SIGNAL = CODE;  Pause: PROCEDURE [i: MaintainPrivate.Instance] =    BEGIN    threeMinutes: Process.Ticks = Process.SecondsToTicks[60 * 3];    MsgSW.AppendString[i.sws.msgSW, "DataBase full, waiting for scavenger"L];    Put.Text[i.sws.fileSW, "\nDataBase full, waiting for scavenger"L];    Process.Pause[threeMinutes];    MsgSW.Clear[i.sws.msgSW];    END;  -- Pause  -- Things done in separate processes here,  -- processes forked from MaintainWindowImpl  -- DoAmmendCommand - forked by AmmendCommand  DoAmmendCommand: PUBLIC MaintainPrivate.CommandProcType =    BEGIN    -- one time only conversation handle    ch: CH.ConversationHandle ¬ MaintainCmds.nullCH;    entryDataName: NSName.Name ¬ NIL;  -- just a pointer, no storage    wh: Window.Handle = i.sws.fileSW;    window: Window.Handle = ToolWindow.WindowForSubwindow[wh];    -- Enumerate Commands for DoAmmendCommand    AddSelf: CH.NameStreamProc =      BEGIN      rc: CH.ReturnCode;      Put.Text[wh, "\nAdding to: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "..."L];      rc ¬ CH.AddSelf[ch, currentName, CHPIDs.members, NIL];      IF rc.code = propertyIDNotFound THEN {  -- add property & retry        rc ¬ CH.AddGroupProperty[ch, currentName, CHPIDs.members, NIL, NIL];        IF rc.code # done THEN {          Put.Text[wh, "AddGroupProperty (members): "L];          CHGloss.ReturnCodeToString[rc, Put.Text, wh];          RETURN;          };        rc ¬ CH.AddSelf[ch, currentName, CHPIDs.members, NIL];        };      SELECT rc.code FROM        noChange => Put.Text[wh, "Already a member"L];        done => Put.Text[wh, "ok"L];        overflowOfDataBase => SIGNAL PauseAndRetry;        ENDCASE => {          Put.Text[wh, "AddSelf "L];          CHGloss.ReturnCodeToString[rc, Put.Text, wh];          };      END;  -- AddSelf    RemoveSelf: CH.NameStreamProc =      BEGIN      rc: CH.ReturnCode;      Put.Text[wh, "\nRemoving from: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "..."L];      rc ¬ CH.DeleteSelf[ch, currentName, CHPIDs.members, NIL];      SELECT TRUE FROM        MaintainCmds.NotFoundError[rc], rc.code = propertyIDNotFound, rc.code =          noChange => Put.Text[wh, "Not a member"L];        rc.code = overflowOfDataBase => SIGNAL PauseAndRetry;        rc.code = done => Put.Text[wh, "ok"L];        ENDCASE => {          Put.Text[wh, "DeleteSelf: "L];          CHGloss.ReturnCodeToString[rc, Put.Text, wh];          };      END;  -- RemoveSelf    <<    ** MembershipReport - report on return code from attempted addition,    ** deletion of a member, owner, friend.    >>    MembershipReport: PROCEDURE [      rc: CH.ReturnCode, member: NSName.Name, group: NSName.Name,      copyFields: MaintainPrivate.CreateDelete, tag: LONG STRING,      proc: LONG STRING] =      BEGIN      SELECT copyFields FROM        create => {          SELECT rc.code FROM            noChange => {              MCHPutExtras.Name[wh, member];              Put.Text[wh, " Already a "L];              Put.Text[wh, tag];              };            done => {              MCHPutExtras.Name[wh, member];              Put.Text[wh, " added to "L];              Put.Text[wh, tag];              Put.Text[wh, "s of "L];              MCHPutExtras.Name[wh, group];              };            overflowOfDataBase => SIGNAL PauseAndRetry;            ENDCASE => {              Put.Text[wh, proc];              Put.Text[wh, ": "L];              CHGloss.ReturnCodeToString[rc, Put.Text, wh];              };          };        delete => {          SELECT TRUE FROM            MaintainCmds.NotFoundError[rc], rc.code = propertyIDNotFound,              rc.code = noChange => {              MCHPutExtras.Name[wh, member];              Put.Text[wh, " Not a "L];              Put.Text[wh, tag];              };            rc.code = done => {              MCHPutExtras.Name[wh, member];              Put.Text[wh, " removed from "L];              Put.Text[wh, tag];              Put.Text[wh, "s of "L];              MCHPutExtras.Name[wh, group];              };            rc.code = overflowOfDataBase => SIGNAL PauseAndRetry;            ENDCASE => {              Put.Text[wh, proc];              Put.Text[wh, ": "L];              CHGloss.ReturnCodeToString[rc, Put.Text, wh];              };          };        ENDCASE => ERROR Bug[unknownSelect];      END;  -- MembershipReport    AddMembers: CH.NameStreamProc =      BEGIN      rc: CH.ReturnCode;      Put.Text[wh, "\nAdding to: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "..."L];      rc ¬ CH.AddGroupMember[ch, entryDataName, currentName, CHPIDs.members, NIL];      IF rc.code = propertyIDNotFound THEN {  -- add property & retry        rc ¬ CH.AddGroupProperty[ch, currentName, CHPIDs.members, NIL, NIL];        IF rc.code # done THEN {          Put.Text[wh, "AddGroupProperty (members): "L];          CHGloss.ReturnCodeToString[rc, Put.Text, wh];          RETURN;          };        rc ¬ CH.AddGroupMember[          ch, entryDataName, currentName, CHPIDs.members, NIL];        };      MembershipReport[        rc, entryDataName, currentName, create, "member"L, "AddGroupMember"L];      END;  -- AddMembers    RemoveMembers: CH.NameStreamProc =      BEGIN      rc: CH.ReturnCode;      Put.Text[wh, "\nRemoving from: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "..."L];      rc ¬ CH.DeleteGroupMember[        ch, entryDataName, currentName, CHPIDs.members, NIL];      MembershipReport[        rc, entryDataName, currentName, delete, "member"L, "DeleteGroupMember"L];      END;  -- RemoveMembers    AddOwners: CH.NameStreamProc =      BEGIN      rc: CH.ReturnCode;      Put.Text[wh, "\nAdding to: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "..."L];      rc ¬ MoreCH.AddPropertyAccessMember[        ch, entryDataName, currentName, CHPIDs.members, administrators, NIL];      IF rc.code = propertyIDNotFound THEN {  -- add property & retry        rc ¬ CH.AddGroupProperty[ch, currentName, CHPIDs.members, NIL, NIL];        SELECT rc.code FROM          done => NULL;          overflowOfDataBase => SIGNAL PauseAndRetry;          ENDCASE => {            Put.Text[wh, "AddGroupProperty (members): "L];            CHGloss.ReturnCodeToString[rc, Put.Text, wh];            RETURN;            };        rc ¬ MoreCH.AddPropertyAccessMember[          ch, entryDataName, currentName, CHPIDs.members, administrators, NIL];        };      MembershipReport[        rc, entryDataName, currentName, create, "owner"L,        "AddPropertyAccessMember (administrators)"L];      END;  -- AddOwners    RemoveOwners: CH.NameStreamProc =      BEGIN      rc: CH.ReturnCode;      Put.Text[wh, "\nRemoving from: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "..."L];      rc ¬ MoreCH.DeletePropertyAccessMember[        ch, entryDataName, currentName, CHPIDs.members, administrators, NIL];      MembershipReport[        rc, entryDataName, currentName, delete, "owner"L,        "DeletePropertyAccessMember (administrators)"L];      END;  -- RemoveOwners    AddFriends: CH.NameStreamProc =      BEGIN      rc: CH.ReturnCode;      Put.Text[wh, "\nAdding to: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "..."L];      rc ¬ MoreCH.AddPropertyAccessMember[        ch, entryDataName, currentName, CHPIDs.members, selfControllers, NIL];      IF rc.code = propertyIDNotFound THEN {  -- add property & retry        rc ¬ CH.AddGroupProperty[ch, currentName, CHPIDs.members, NIL, NIL];        SELECT rc.code FROM          done => NULL;          overflowOfDataBase => SIGNAL PauseAndRetry;          ENDCASE => {            Put.Text[wh, "\nAddGroupProperty (members): "L];            CHGloss.ReturnCodeToString[rc, Put.Text, wh];            RETURN;            };        rc ¬ MoreCH.AddPropertyAccessMember[          ch, entryDataName, currentName, CHPIDs.members, selfControllers, NIL];        };      MembershipReport[        rc, entryDataName, currentName, create, "friend"L,        "AddPropertyAccessMember (selfControllers)"L];      END;  -- AddFriends    RemoveFriends: CH.NameStreamProc =      BEGIN      rc: CH.ReturnCode;      Put.Text[wh, "\nRemoving from: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "..."L];      rc ¬ MoreCH.DeletePropertyAccessMember[        ch, entryDataName, currentName, CHPIDs.members, selfControllers, NIL];      MembershipReport[        rc, entryDataName, currentName, delete, "friend"L,        "DeletePropertyAccessMember (selfControllers)"L];      END;  -- RemoveFriends    AddAlias: CH.NameStreamProc =      BEGIN      rc: CH.ReturnCode;      rc ¬ CH.AddAlias[ch, currentName, entryDataName, NIL];      SELECT rc.code FROM        noChange => {          Put.CR[wh];          MCHPutExtras.Name[wh, entryDataName];          Put.Text[wh, " is already an entry"L];          };        done => {          Put.CR[wh];          MCHPutExtras.Name[wh, currentName];          Put.Text[wh, " has the alias "L];          MCHPutExtras.Name[wh, entryDataName];          };        overflowOfDataBase => SIGNAL PauseAndRetry;        ENDCASE => {          Put.Text[wh, "\nAddAlias: "L];          CHGloss.ReturnCodeToString[rc, Put.Text, wh];          };      END;  -- AddAlias    RemoveAlias: CH.NameStreamProc =      BEGIN      Done: PROCEDURE =        BEGIN        MCHNameExtras.FreeName[z, dname];        MCHNameExtras.FreeName[z, dalias];        END;  -- Done      rc: CH.ReturnCode;      dname: NSName.Name ¬ MCHNameExtras.AllocName[z];      dalias: NSName.Name ¬ MCHNameExtras.AllocName[z];      {      ENABLE UNWIND => Done[];      Put.CR[wh];      rc ¬ CH.LookupDistinguishedName[ch, currentName, dname];      IF rc.code # done THEN {        CHGloss.ReturnCodeToString[rc, Put.Text, wh]; GOTO done; };      rc ¬ CH.LookupDistinguishedName[ch, entryDataName, dalias];      IF MaintainCmds.NotFoundError[rc] THEN {        MCHPutExtras.Name[wh, entryDataName];        Put.Text[wh, " does not exist"L];        GOTO done;        };      SELECT rc.code FROM        done => NULL;        overflowOfDataBase => SIGNAL PauseAndRetry;        ENDCASE => {          Put.Text[wh, "LookupDistinguishedName: "L];          CHGloss.ReturnCodeToString[rc, Put.Text, wh];          GOTO done;          };      IF ~NSName.EquivalentNames[dname, dalias] THEN {        MCHPutExtras.Name[wh, entryDataName];        Put.Text[wh, " is not an alias of "L];        MCHPutExtras.Name[wh, currentName];        GOTO done;        };      rc ¬ CH.DeleteAlias[ch, entryDataName, NIL];      SELECT rc.code FROM        done => {          MCHPutExtras.Name[wh, currentName];          Put.Text[wh, " no longer has the alias "L];          MCHPutExtras.Name[wh, entryDataName];          };        overflowOfDataBase => SIGNAL PauseAndRetry;        ENDCASE => {          Put.Text[wh, "DeleteAlias"L];          CHGloss.ReturnCodeToString[rc, Put.Text, wh];          };      GOTO done;      EXITS done => Done[];      };      END;  -- RemoveAlias    AddMailbox: CH.NameStreamProc =      BEGIN      <<rc: CH.ReturnCode;>>      Put.Text[wh, "\nAdding mailbox to: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "..."L];      Put.Text[wh, "AddMailbox Unimplimented"L];      END;  -- AddMailbox    RemoveMailbox: CH.NameStreamProc =      BEGIN      <<rc: CH.ReturnCode;>>      Put.Text[wh, "\nRemoving mailbox from: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "..."L];      Put.Text[wh, "RemoveMailbox Unimplimented"L];      END;  -- RemoveMailbox    SetRemark: PROCEDURE [currentName: NSName.Name, pid: CH.PropertyID] =      BEGIN      Done: PROCEDURE = {CH.FreeRhs[b, z]; };      rc: CH.ReturnCode;      b: CH.Buffer;      nss: NSString.String;	<<for converting string to primary property>>      {      ENABLE UNWIND => Done[];      Put.Text[wh, "\nSetting remark for: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "..."L];      nss ¬ NSString.StringFromMesaString[        IF String.Empty[i.windowItemsCopy.remark] THEN ""L        ELSE i.windowItemsCopy.remark];      b ¬ CH.SerializeIntoRhs[[@nss, CHEntries.DescribePrimary], z];      rc ¬ CH.ChangeValueProperty[ch, currentName, pid, b, NIL];      SELECT rc.code FROM        done => Put.Text[wh, "ok"L];        overflowOfDataBase => SIGNAL PauseAndRetry;        ENDCASE => {          Put.Text[wh, "ChangeValueProperty: "L];          CHGloss.ReturnCodeToString[rc, Put.Text, wh];          };      Done[];      };      END;  -- SetRemark    SetGroupRemark: CH.NameStreamProc = {      SetRemark[currentName, CHPIDs.userGroup]; };    SetIndivRemark: CH.NameStreamProc = {SetRemark[currentName, CHPIDs.user]; };    SetIndivPwd: PROCEDURE [currentName: NSName.Name] =      BEGIN      ENABLE        Auth.CallError => {	  AuthGloss.CallProblemToString[reason, whichArg, Put.Text, wh];          CONTINUE;          };      Done: PROCEDURE =        BEGIN        MCHNameExtras.FreeName[z, dname];        MCHNameExtras.FreeName[z, origionalDname];        END;  -- Done      rc: CH.ReturnCode;      dname: NSName.Name ¬ MCHNameExtras.AllocName[z];  -- dname for currentName      origionalDname: NSName.Name ¬ MCHNameExtras.AllocName[z];      -- dname for origionalName  if this is same as name I'm changing, do      -- changeMyPasswords, otherwise, have to delete & recreate      doStrong: BOOLEAN =        (i.windowItemsCopy.pwdType = strong OR i.windowItemsCopy.pwdType = both);      doSimple: BOOLEAN =        (i.windowItemsCopy.pwdType = simple OR i.windowItemsCopy.pwdType = both);      {      ENABLE UNWIND => Done[];      Put.Text[wh, "\nSetting password for: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "..."L];      rc ¬ CH.LookupDistinguishedName[ch, currentName, dname];      IF rc.code # done THEN {        Put.Text[wh, "LookupDistinguishedName: "L];        CHGloss.ReturnCodeToString[rc, Put.Text, wh];        GOTO done;        };      rc ¬ CH.LookupDistinguishedName[ch, i.globals.defaultsName, origionalDname];      IF rc.code # done THEN {        Put.Text[wh, "LookupDistinguishedName: "L];        CHGloss.ReturnCodeToString[rc, Put.Text, wh];        GOTO done;        };      << if person logged on is person who's password we're changing, than      ** we do ChangMyPasswords, otherwise we can't      >>      IF NSName.EquivalentNames[dname, origionalDname] THEN {        Auth.ChangeMyPasswords[          i.globals.idh, NSString.StringFromMesaString[i.windowItemsCopy.password],          NIL, doStrong, doSimple];        }      ELSE {  -- changing someone else's        password: NSString.String ¬ NSString.StringFromMesaString[          i.windowItemsCopy.password];        -- no storage allocated        IF doStrong THEN {          Auth.DeleteStrongKey[            i.globals.idh, currentName !            Auth.CallError => {              IF reason = strongKeyDoesNotExist THEN CONTINUE ELSE REJECT; }];          Auth.CreateStrongKey[            i.globals.idh, currentName, Auth.PasswordStringToKey[password]];          };        IF doSimple THEN {          Auth.DeleteSimpleKey[            i.globals.idh, currentName !            Auth.CallError => {              IF reason = simpleKeyDoesNotExist THEN CONTINUE ELSE REJECT; }];          Auth.CreateSimpleKey[            i.globals.idh, currentName, Auth.HashSimplePassword[password]];          };        };      Put.Text[wh, "ok"L];      GOTO done;      EXITS done => Done[];      };      END;  -- SetIndivPwd    -- DoAmmendCommand starts    Done: PROCEDURE =      BEGIN      Put.Text[wh, "\nDone\n"L];      MCHNameExtras.FreeNames[entryNameList, z];      MCHNameExtras.FreeNames[eDataNameList, z];      CH.FreeConversationHandle[@ch, z];  -- free conversation handle      END;  -- Done;    handleOk: BOOLEAN ¬ FALSE;  -- ch is rc    n: NSName.Name ¬ NIL;  -- temporary for entryPattern.    entryNameList: MCHNameExtras.NameList ¬ NIL;    entryI: CARDINAL ¬ 0;  -- index for entryNameList    eDataNameList: MCHNameExtras.NameList ¬ NIL;    eDataI: CARDINAL ¬ 0;    eData: LONG STRING ¬ NIL;  -- ptr into one of i.windowItemsCopy (nothing allocated)    Command: CH.NameStreamProc;    emptyString: LONG STRING ¬ ""L;    {    ENABLE UNWIND => GOTO done;    IF String.Empty[i.windowItemsCopy.entry] THEN {      IF i.windowItemsCopy.gi = group THEN        MaintainCmds.MissingFieldRequest[i, "group"L]      ELSE MaintainCmds.MissingFieldRequest[i, "individual"L];      GOTO done;      };    SELECT i.windowItemsCopy.command FROM  -- set eData      arMembers, arOwners, arFriends => {        IF String.Empty[i.windowItemsCopy.nameList] THEN {          MaintainCmds.MissingFieldRequest[i, "Name List"L]; GOTO done; };        eData ¬ i.windowItemsCopy.nameList;        };      arAlias => {        IF String.Empty[i.windowItemsCopy.alias] THEN {          MaintainCmds.MissingFieldRequest[i, "Alias"L]; GOTO done; };        eData ¬ i.windowItemsCopy.alias;        };      setRemark => {        IF String.Empty[i.windowItemsCopy.remark] THEN eData ¬ emptyString        ELSE eData ¬ i.windowItemsCopy.remark;        };      arMailbox => {        IF String.Empty[i.windowItemsCopy.mailbox] THEN {          MaintainCmds.MissingFieldRequest[i, "Mailbox"L]; GOTO done; };        eData ¬ i.windowItemsCopy.mailbox;        };      setPwd => {        IF String.Empty[i.windowItemsCopy.password] THEN {          MaintainCmds.MissingFieldRequest[i, "Password"L]; GOTO done; };        eData ¬ i.windowItemsCopy.password;        };      invalid => ERROR Bug[unknownSelect];      ENDCASE => NULL;    [ch, handleOk] ¬ MaintainCmds.MakeCh[z, i];    IF ~handleOk THEN GOTO done;    -- opening anouncement (for each on list)    Put.CR[wh];    IF i.windowItemsCopy.cd = create THEN      Put.Text[        wh,        SELECT i.windowItemsCopy.command FROM          arSelf => "\nAdd self to "L,          arMembers => "\nAdd members to "L,          arOwners => "\nAdd owners to "L,          arFriends => "\nAdd friends to "L,          arAlias => "\nAdd alias to "L,          arMailbox => "\nAdd mailbox to "L,          setRemark => "\nSet remark for "L,          setPwd => "\nSet password for "L,          ENDCASE => ERROR Bug[unknownSelect]]    ELSE      Put.Text[        wh,        SELECT i.windowItemsCopy.command FROM          arSelf => "\nRemove self from "L,          arMembers => "\nRemove members from "L,          arOwners => "\nRemove owners from "L,          arFriends => "\nRemove friends from "L,          arAlias => "\nRemove alias for "L,          arMailbox => "\nRemove mailbox of "L,          ENDCASE => ERROR Bug[unknownSelect]];    Put.Text[wh, i.windowItemsCopy.entry];    Put.Text[wh, "..."L];    << set Command >>    SELECT i.windowItemsCopy.cd FROM      create =>        Command ¬          SELECT i.windowItemsCopy.command FROM            arMembers => AddMembers,            arOwners => AddOwners,            arFriends => AddFriends,            arAlias => AddAlias,            arMailbox => AddMailbox,            arSelf => AddSelf,            setRemark =>              IF i.windowItemsCopy.gi = group THEN SetGroupRemark              ELSE SetIndivRemark,            setPwd => SetIndivPwd,            ENDCASE => ERROR Bug[unknownSelect];      delete =>        Command ¬          SELECT i.windowItemsCopy.command FROM            arMembers => RemoveMembers,            arOwners => RemoveOwners,            arFriends => RemoveFriends,            arAlias => RemoveAlias,            arMailbox => RemoveMailbox,            arSelf => RemoveSelf,            ENDCASE => ERROR Bug[unknownSelect];      ENDCASE => ERROR Bug[unknownSelect];    <<    * do for EACH name in entry    * This expands patterns and maps aliases to distinguished names.  Objects    * w/ no distinguished name are excluded.  No way to tell where name came    * from after this.    >>    entryNameList ¬ MCHNameExtras.ParseNameList[      namesString: NSString.StringFromMesaString[i.windowItemsCopy.entry],      defaults: i.globals.defaultsName, zone: z,      resolveAliases: i.windowItemsCopy.checkNames,      expandPatterns: i.windowItemsCopy.checkNames,      validateNames: i.windowItemsCopy.checkNames,      validatePatterns: i.windowItemsCopy.checkNames,      pid:      SELECT TRUE FROM        i.windowItemsCopy.anyEntry => CH.unspecified,        i.windowItemsCopy.gi = group => CHPIDs.userGroup,        i.windowItemsCopy.gi = indiv => CHPIDs.user,        ENDCASE => ERROR Bug[unknownSelect], ch: ch !      MCHNameExtras.TooManySeparators => {  -- name is arg        Put.Text[wh, "\nInvalid name: "L];        MCHPutExtras.PutNSString[wh, name];        RESUME        ;        };      MCHNameExtras.EnumerateProblem => {  -- rc & name are args        SELECT TRUE FROM          MaintainCmds.NotFoundError[rc] => {            Put.CR[wh];            MCHPutExtras.Name[wh, name];            Put.Text[wh, " is not a "L];            Put.Text[              wh,              SELECT i.windowItemsCopy.gi FROM                group => "group"L,                indiv => "user"L,                ENDCASE => ERROR Bug[unknownSelect]];            };          ENDCASE => {            Put.Text[wh, "\nCH problem "L];            CHGloss.ReturnCodeToString[rc, Put.Text, wh];            };        RESUME        ;        };      MCHNameExtras.UnfoundName => {        Put.CR[wh];        Put.Text[wh, "No "];        Put.Text[          wh,          SELECT i.windowItemsCopy.gi FROM            group => "group"L,            indiv => "user"L,            ENDCASE => ERROR Bug[unknownSelect]];        Put.Text[wh, " matches "L];        MCHPutExtras.Name[wh, name];        RESUME [FALSE];        }; ];  <<end ParseNameList>>    <<    IF entryNameList = NIL OR LENGTH[entryNameList] = 0 THEN {      Put.CR[wh];      Put.Text[wh, "no "L];      Put.Text[        wh,        SELECT i.windowItemsCopy.gi FROM          group => "group"L,          indiv => "user"L,          ENDCASE => ERROR Bug[unknownSelect]];      Put.Text[wh, " matched"L];      GOTO done;      };>>    <<    ** For arMembers, arOwners, arFriends, arAlias, arMailbox the 2nd arg    ** (entryData) is a list of names.  We expand it to eDataNameList, with    ** individual names entryDataName.  For all other commands, the second    ** arg is the string entryData.    ** For arMembers, arOwners, arFriends, we map aliases to distinguished names    >>    SELECT i.windowItemsCopy.command FROM      arMembers, arOwners, arFriends => {        <<note: CH.unspecified as both user & userGroup make sense>>        eDataNameList ¬ MCHNameExtras.ParseNameList[          namesString: NSString.StringFromMesaString[eData],          defaults: i.globals.defaultsName, zone: z,	  resolveAliases: i.windowItemsCopy.checkNames,          expandPatterns: FALSE,	  validateNames: i.windowItemsCopy.checkNames,          validatePatterns: FALSE,	  pid: CH.unspecified, ch: ch !          MCHNameExtras.TooManySeparators => {  -- name is arg            Put.Text[wh, "\nInvalid name: "L];            MCHPutExtras.PutNSString[wh, name];            RESUME;            };          MCHNameExtras.EnumerateProblem => {  -- rc & name are args            SELECT TRUE FROM              MaintainCmds.NotFoundError[rc] => {                Put.CR[wh];                MCHPutExtras.Name[wh, name];                Put.Text[wh, " is not a "L];                Put.Text[                  wh,                  SELECT i.windowItemsCopy.gi FROM                    group => "group"L,                    indiv => "user"L,                    ENDCASE => ERROR Bug[unknownSelect]];                };              ENDCASE => {                Put.Text[wh, "\nCH problem "L];                CHGloss.ReturnCodeToString[rc, Put.Text, wh];                };            RESUME;            };          MCHNameExtras.UnfoundName => {            Put.CR[wh];            Put.Text[wh, "Warning: "];            MCHPutExtras.Name[wh, name];            Put.Text[wh, " Has no distinguished name."L];            RESUME [TRUE];  <<warn, and include it anyway>>            }; ];        };      arAlias => {        eDataNameList ¬ MCHNameExtras.ParseNameList[          namesString: NSString.StringFromMesaString[eData],          defaults: i.globals.defaultsName, zone: z !          MCHNameExtras.TooManySeparators => {  -- name is arg            Put.Text[wh, "\nInvalid name: "L];            MCHPutExtras.PutNSString[wh, name];            RESUME;            }; ];        IF LENGTH[entryNameList] # 1 THEN {          -- don't allow multiple individuals          Put.Text[wh, "\nAliases must be unique"L]; GOTO done; };        };      arMailbox => {        eDataNameList ¬ MCHNameExtras.ParseNameList[          namesString: NSString.StringFromMesaString[eData],          defaults: i.globals.defaultsName, zone: z !          MCHNameExtras.TooManySeparators => {  -- name is arg            Put.Text[wh, "\nInvalid name: "L];            MCHPutExtras.PutNSString[wh, name];            RESUME;            }; ];        };      ENDCASE => NULL;    FOR entryI IN [0..LENGTH[entryNameList]) DO  -- for each name in entry      IF eDataNameList # NIL THEN {  -- for each name in eData        -- not NIL, so must be command that uses it        FOR eDataI IN [0..LENGTH[eDataNameList]) DO          entryDataName ¬ @eDataNameList[eDataI];          Command[@entryNameList[entryI] ! PauseAndRetry => {Pause[i]; RETRY; }; ];          ENDLOOP;  -- once for each name in eData.        }      ELSE  <<command that has string 2nd arg>>        Command[@entryNameList[entryI] ! PauseAndRetry => {Pause[i]; RETRY; }; ];      ENDLOOP;  -- for each name in entry    GOTO done;    EXITS done => Done[];    };    END;  -- DoAmmendCommand  DoCDCommand: PUBLIC MaintainPrivate.CommandProcType =    BEGIN    -- one time only conversation handle    ch: CH.ConversationHandle ¬ MaintainCmds.nullCH;    entryPattern: NSName.Name ¬ NIL;    wh: Window.Handle = i.sws.fileSW;    window: Window.Handle = ToolWindow.WindowForSubwindow[wh];    <<    ** CreateEntry - create a new entry in the database, always a user or    ** userGroup.  The entry is initialized w/ the remark in the form,    ** and members are initialized for a group (since it's a huge efficiency    ** for large groups.)    ** Should eventually more completely initialize new elements.    >>    CreateEntry: PROCEDURE [      newEntry: NSName.Name, gi: MaintainPrivate.GroupIndiv] =      BEGIN      << ElemEnum - add initial members (members ONLY) to a group as      ** we're creating it.  We call the PROC eachName w/ each name to add.      ** BEWARE that this can get called more than once due to strangenesses in      ** the CH.      >>      -- CH.EnumerateNewGroupElements: TYPE      --   = PROCEDURE [eachName: CH.NameStreamProc];      ElemEnum: CH.EnumerateNewGroupElements =        BEGIN        Done: PROCEDURE = { MCHNameExtras.FreeNames[nameList, z]; };        nameList: MCHNameExtras.NameList ¬ NIL;        {        ENABLE UNWIND => Done[];        IF i.windowItemsCopy.mode # members THEN RETURN;  << only members >>        nameList ¬ MCHNameExtras.ParseNameList[          namesString: NSString.StringFromMesaString[i.windowItemsCopy.nameList],          defaults: i.globals.defaultsName, zone: z,	  resolveAliases: i.windowItemsCopy.checkNames,          validateNames: i.windowItemsCopy.checkNames,          pid: CH.unspecified, ch: ch !          MCHNameExtras.TooManySeparators => {  -- name is arg            Put.Text[wh, "\nInvalid name: "L];            MCHPutExtras.PutNSString[wh, name];            RESUME;            };          MCHNameExtras.EnumerateProblem => {  -- rc & name are args            SELECT TRUE FROM              MaintainCmds.NotFoundError[rc] => {                Put.CR[wh];                MCHPutExtras.Name[wh, name];                Put.Text[wh, " is not a "L];                Put.Text[                  wh,                  SELECT i.windowItemsCopy.gi FROM                    group => "group"L,                    indiv => "user"L,                    ENDCASE => ERROR Bug[unknownSelect]];                };              ENDCASE => {                Put.Text[wh, "\nCH problem "L];                CHGloss.ReturnCodeToString[rc, Put.Text, wh];                };            RESUME;            };          MCHNameExtras.UnfoundName => {            Put.CR[wh];            Put.Text[wh, "Warning: "];            MCHPutExtras.Name[wh, name];            Put.Text[wh, " Has no distinguished name."L];            RESUME [TRUE];  <<warn, and include it anyway>>            }; ];  <<end ParseNameList>>        IF nameList = NIL OR LENGTH[nameList] = 0 THEN GOTO done;        FOR nli IN [0..LENGTH[nameList]) DO eachName[@nameList[nli]]; ENDLOOP;        GOTO done;        EXITS done => Done[];        };        END;  -- ElemEnum      Done: PROCEDURE =        BEGIN        MCHNameExtras.FreeName[z, dname];        IF b # NIL THEN CH.FreeRhs[b, z];        END;  -- Done      rc: CH.ReturnCode;      dname: NSName.Name ¬ MCHNameExtras.AllocName[z];      b: CH.Buffer ¬ NIL;      nss: NSString.String;	<<for converting string to primary property>>      {      ENABLE UNWIND => Done[];      Put.Text[wh, "\nCreating "L];      MCHPutExtras.Name[wh, newEntry];      Put.Text[wh, "..."L];      rc ¬ CH.LookupDistinguishedName[ch, newEntry, dname];      SELECT TRUE FROM        MaintainCmds.NotFoundError[rc] => NULL;  -- things as they should be        rc.code = done => {          MCHPutExtras.Name[wh, newEntry];          Put.Text[wh, " already exists, distinguished name is: "L];          MCHPutExtras.Name[wh, dname];          GOTO done;          };        ENDCASE => {          Put.Text[wh, "LookupDistinguishedName: "L];          CHGloss.ReturnCodeToString[rc, Put.Text, wh];          GOTO done;          };      -- no such entry of any type, create one      rc ¬ CH.AddDistinguishedName[ch, newEntry, NIL];      SELECT rc.code FROM        done => NULL;        overflowOfDataBase => SIGNAL PauseAndRetry;        ENDCASE => {          Put.Text[wh, "AddDistinguishedName: "L];          CHGloss.ReturnCodeToString[rc, Put.Text, wh];          GOTO done;          };      nss ¬ NSString.StringFromMesaString[        IF String.Empty[i.windowItemsCopy.remark] THEN ""L        ELSE i.windowItemsCopy.remark];      b ¬ CH.SerializeIntoRhs[[@nss, CHEntries.DescribePrimary], z];      rc ¬ CH.AddValueProperty[        ch, newEntry,        SELECT i.windowItemsCopy.gi FROM          group => CHPIDs.userGroup,          indiv => CHPIDs.user,          ENDCASE => ERROR Bug[unknownSelect], b, NIL];      SELECT rc.code FROM        done => NULL;        overflowOfDataBase => SIGNAL PauseAndRetry;        ENDCASE => {          Put.Text[wh, "AddValueProperty: "L];          CHGloss.ReturnCodeToString[rc, Put.Text, wh];          RETURN;          };      IF i.windowItemsCopy.gi = group THEN {        rc ¬ CH.AddGroupProperty[ch, newEntry, CHPIDs.members, ElemEnum, NIL];        SELECT rc.code FROM          done => NULL;          overflowOfDataBase => SIGNAL PauseAndRetry;          ENDCASE => {            Put.Text[wh, "AddGroupProperty: "L];            CHGloss.ReturnCodeToString[rc, Put.Text, wh];            };        }      ELSE {  -- user added.        -- have to initialize userData property        emptyName: NSName.Name	  ¬ MCHNameExtras.NameFromMesaString["::"L, z];        userData: CHEntries.UserData ¬ [0, emptyName];        b: CH.Buffer ¬ CH.SerializeIntoRhs[          [@userData, CHEntries.DescribeUserData], z];        rc ¬ CH.AddValueProperty[ch, newEntry, CHPIDs.userData, b, NIL];        SELECT rc.code FROM          done => NULL;          overflowOfDataBase => SIGNAL PauseAndRetry;          ENDCASE => {            Put.Text[wh, "AddValueProperty (userData): "L];            CHGloss.ReturnCodeToString[rc, Put.Text, wh];            };        MCHNameExtras.FreeName[z, emptyName];        CH.FreeRhs[b, z];        };      Put.Text[wh, "Entry Added"L];      GOTO done;      EXITS done => Done[];      };      END;  -- CreateEntry    DeleteEntry: CH.NameStreamProc =      BEGIN      Done: PROCEDURE = {MCHNameExtras.FreeName[z, dname]; };      dname: NSName.Name ¬ MCHNameExtras.AllocName[z];      rc: CH.ReturnCode;      {      ENABLE UNWIND => {Done[]; REJECT; };      Put.Text[wh, "\nDeleting: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "..."L];      rc ¬ CH.DeleteDistinguishedName[ch, currentName, dname];      SELECT rc.code FROM        done => NULL;        overflowOfDataBase => SIGNAL PauseAndRetry;        ENDCASE => {          Put.Text[wh, "DeleteDistinguishedName: "L];          CHGloss.ReturnCodeToString[rc, Put.Text, wh];          MCHNameExtras.FreeName[z, dname];          RETURN;          };      Put.Text[wh, "Entry Deleted"L];      Done[];      };      END;  -- DeleteEntry    Done: PROCEDURE =      BEGIN      Put.Text[wh, "\nDone\n"L];      MCHNameExtras.FreeNames[nameList, z];      CH.FreeConversationHandle[@ch, z];  -- free conversation handle      END;  -- Done    handleOk: BOOLEAN ¬ FALSE;  -- ch is rc    n: NSName.Name ¬ NIL;  -- temporary for entryPattern.    nameList: MCHNameExtras.NameList ¬ NIL;  -- all the names in entry.    nli: CARDINAL ¬ 0;  -- index for nameList    -- if the entry we're passed has no *'s, we dereference it to it's    -- distinguished name, otherwise not.    {  -- DoCDCommand starts    ENABLE UNWIND => {Done[]; REJECT; };    IF String.Empty[i.windowItemsCopy.entry] THEN {      IF i.windowItemsCopy.gi = group THEN        MaintainCmds.MissingFieldRequest[i, "group"L]      ELSE MaintainCmds.MissingFieldRequest[i, "individual"L];      GOTO done;      };    [ch, handleOk] ¬ MaintainCmds.MakeCh[z, i];    IF ~handleOk THEN GOTO done;    -- opening anouncement    Put.Text[      wh,      IF i.windowItemsCopy.cd = create THEN "\n\nCreating "L      ELSE "\n\nDeleting "L];    Put.Text[wh, i.windowItemsCopy.entry];    IF i.windowItemsCopy.cd = create THEN      nameList ¬ MCHNameExtras.ParseNameList[        namesString: NSString.StringFromMesaString[i.windowItemsCopy.entry],        defaults: i.globals.defaultsName, zone: z !        MCHNameExtras.TooManySeparators => {  -- name is arg          Put.Text[wh, "\nInvalid name: "L];          MCHPutExtras.PutNSString[wh, name];          RESUME          ;          }; ]    ELSE      nameList ¬ MCHNameExtras.ParseNameList[        namesString: NSString.StringFromMesaString[i.windowItemsCopy.entry],        defaults: i.globals.defaultsName, zone: z,        resolveAliases: i.windowItemsCopy.checkNames,        expandPatterns: i.windowItemsCopy.checkNames,        validateNames: i.windowItemsCopy.checkNames,        validatePatterns: i.windowItemsCopy.checkNames,        pid:        SELECT TRUE FROM          i.windowItemsCopy.anyEntry => CH.unspecified,          i.windowItemsCopy.gi = group => CHPIDs.userGroup,          i.windowItemsCopy.gi = indiv => CHPIDs.user,          ENDCASE => ERROR Bug[unknownSelect], ch: ch !        MCHNameExtras.TooManySeparators => {  -- name is arg          Put.Text[wh, "\nInvalid name: "L];          MCHPutExtras.PutNSString[wh, name];          RESUME          ;          };        MCHNameExtras.EnumerateProblem => {  -- rc & name are args          SELECT TRUE FROM            MaintainCmds.NotFoundError[rc] => {              Put.CR[wh];              MCHPutExtras.Name[wh, name];              Put.Text[wh, " is not a "L];              Put.Text[                wh,                SELECT i.windowItemsCopy.gi FROM                  group => "group"L,                  indiv => "user"L,                  ENDCASE => ERROR Bug[unknownSelect]];              };            ENDCASE => {              Put.Text[wh, "\nCH problem "L];              CHGloss.ReturnCodeToString[rc, Put.Text, wh];              };          RESUME          ;          };        MCHNameExtras.UnfoundName => {          Put.CR[wh];          Put.Text[wh, "No "];          Put.Text[            wh,            SELECT i.windowItemsCopy.gi FROM              group => "group"L,              indiv => "user"L,              ENDCASE => ERROR Bug[unknownSelect]];          Put.Text[wh, " matches "L];          MCHPutExtras.Name[wh, name];          RESUME [FALSE];          }; ];    <<    IF nameList = NIL OR LENGTH[nameList] = 0 THEN {      Put.CR[wh];      Put.Text[wh, "no "L];      Put.Text[        wh,        SELECT i.windowItemsCopy.gi FROM          group => "group"L,          indiv => "user"L,          ENDCASE => ERROR Bug[unknownSelect]];      Put.Text[wh, " matched"L];      GOTO done;      };>>    SELECT i.windowItemsCopy.cd FROM      create => {        FOR nli IN [0..LENGTH[nameList]) DO          n ¬ @nameList[nli];  -- don't deallocate.  FreeName does that          IF MCHNameExtras.IsPattern[n] THEN {            Put.Text[wh, "\nName of new object cannot include *'s"L]; LOOP; };          CreateEntry[            n, i.windowItemsCopy.gi ! PauseAndRetry => {Pause[i]; RETRY; }; ];          ENDLOOP;        };      delete => {        FOR nli IN [0..LENGTH[nameList]) DO          n ¬ @nameList[nli];  -- don't deallocate.  FreeName does that          DeleteEntry[n ! PauseAndRetry => {Pause[i]; RETRY; }; ];          ENDLOOP;        };      ENDCASE => ERROR Bug[unknownSelect];    GOTO done;    EXITS done => Done[];    };    END;  -- DoCDCommand  END.LOG  Created by Sturtevant  2-May-84 11:05:33  Templateized by Sturtevant 22-Oct-84 15:23:20  Further Templatized & Gealified - Sturtevant -  6-Nov-84  9:50:08  REJECT all UNWINDS - sturtevant -  7-Nov-84 14:55:17  calaverafied - Sturtevant -  4-Jan-85 14:35:10  24-Jan-85 11:41:52 - expand aliases to distinguished names for membership lists - Sturtevant
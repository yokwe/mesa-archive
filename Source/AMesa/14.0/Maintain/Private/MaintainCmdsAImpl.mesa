-- File: MaintainCmdsAImpl.mesa - last edit:-- Sturtevant.PA       29-Jan-85  9:46:13-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Auth USING [    CallProblem, CopyIdentity, FreeIdentity, GetIdentityDetails, IdentityHandle],  AuthGloss USING [CallProblemToString],  CH USING [    Buffer, ConversationHandle, DeserializeFromRhs, FreeConversationHandle,    FreeRhs, LookupAliasesOfName, LookupGroupProperty, LookupValueProperty,    MakeConversationHandle, MakeRhs, maxBufferSize, Name, NameStreamProc,    ReturnCode, unspecified],  CHEntries USING [DescribePrimary, DescribeUserData, UserData],  CHEntriesExtras USING [AuthenticationLevel, DescribeAuthenticationLevel],  CHGloss USING [ReturnCodeToString],  CHPIDs USING [authenticationLevel, members, user, userData, userGroup],  Courier USING [Free, nullParameters, Parameters],  Heap USING [Create, Delete],  MCHNameExtras USING [    EnumerateProblem, FreeName, FreeNames, NameList, ParseNameList,    TooManySeparators, UnfoundName],  MCHPutExtras USING [Name, PutNSString],  MoreCH USING [LookupPropertyAccess],  MaintainCmds USING [    CmdsBCleanup, CmdsBInit, MakeCh, MissingFieldRequest, NotFoundError, nullCH],  MaintainPrivate USING [CommandProcType, Instance],  NSName USING [CopyName, FreeName, Name],  NSString USING [nullString, String, StringFromMesaString],  Profile USING [GetID],  Put USING [CR, LongDecimal, Text],  String USING [Empty],  ToolWindow USING [Handle, WindowForSubwindow],  Window USING [Handle];MaintainCmdsAImpl: PROGRAM  IMPORTS    Auth, AuthGloss, CH, CHEntries, CHEntriesExtras, CHGloss, Courier, Heap,    MoreCH, MCHNameExtras, MaintainCmds, NSName, NSString, Profile, Put,    MCHPutExtras, String, ToolWindow  EXPORTS MaintainPrivate, MaintainCmds =  BEGIN  bugType: TYPE = {unknownSelect};  Bug: ERROR [type: bugType] = CODE;  z: UNCOUNTED ZONE ¬ NIL;  CommandProcInit: PUBLIC PROCEDURE  << MaintainPrivate >>     = {z ¬ Heap.Create[1]; MaintainCmds.CmdsBInit[z]; };  CommandProcCleanup: PUBLIC PROCEDURE  << MaintainPrivate >>     = {MaintainCmds.CmdsBCleanup[]; Heap.Delete[z]; z ¬ NIL; };  FreeGlobals: PUBLIC PROCEDURE [i: MaintainPrivate.Instance] =    BEGIN    Auth.FreeIdentity[@i.globals.idh, z];    MCHNameExtras.FreeName[z, i.globals.defaultsName];    i.globals.defaultsName ¬ NIL;    END;  -- FreeGlobals  -- Things done in separate processes here,  -- processes forked from MaintainWindowImpl  MissingFieldRequest: PUBLIC PROCEDURE [    i: MaintainPrivate.Instance, s: LONG STRING] =  << Exported to Maintain >>    BEGIN    wh: Window.Handle = i.sws.fileSW;    Put.Text[wh, "\nPlease fill in the \""L];    Put.Text[wh, s];    Put.Text[wh, "\" field"L];    END;  -- MissingFieldRequest  -- MakeCh - make new ch  -- called at start of each command process.  -- prints any warning or error msgs  << Exported to Maintain >>  MakeCh: PUBLIC PROCEDURE [z: UNCOUNTED ZONE, i: MaintainPrivate.Instance]    RETURNS [      ch: CH.ConversationHandle ¬ MaintainCmds.nullCH,      handleOk: BOOLEAN ¬ TRUE] =    BEGIN    wh: Window.Handle = i.sws.fileSW;    ae: Auth.CallProblem;    IF i.globals.idh # NIL THEN  -- If we have a chance      [ch, handleOk, ae] ¬ CH.MakeConversationHandle[i.globals.idh, z];    IF ~handleOk THEN {  -- unreported problem      Put.Text[wh, "\nAuthentication Call Problem --"L];      AuthGloss.CallProblemToString[ae, notApplicable, Put.Text, wh];      };    IF i.globals.idh = NIL OR ~handleOk THEN {  -- don't have good handle      Put.Text[wh, "\nPlease login"L];  -- complain every time      Put.Text[i.sws.msgSW, "\nPlease login"L];  -- complain every time      RETURN[MaintainCmds.nullCH, FALSE];  -- no handle      }    ELSE RETURN[ch, TRUE];    END;  -- MakeCh  -- A 'Primary Property'  - e.g. remark  PutPrimary: PUBLIC PROCEDURE [wh: Window.Handle, b: CH.Buffer] =    BEGIN    strbuf: NSString.String ¬ NSString.nullString;    params: Courier.Parameters ¬ Courier.nullParameters;    s: LONG STRING ¬ NIL;    params ¬ [@strbuf, CHEntries.DescribePrimary];    IF ~CH.DeserializeFromRhs[params, z, b] THEN {      Put.Text[wh, "Deserialize failed"L]; }    ELSE MCHPutExtras.PutNSString[wh, strbuf];    Courier.Free[params, z];    RETURN;    END;  -- PutPrimary  -- DoInfoCommand - forked by InfoCommand.  -- the commands which just give information on an entry.  -- entry is the name[s] of the ch entry to give info on.  -- gi tells whether this should be a group or individual entry.  -- command is type of info to give.  -- entry belongs to us, and must be deallocated.  <<  ** All procedures called from w/in this made local, so they can refer to i  ** Sturtevant - 26-Jul-84 10:16:44  ** the currentName param to each of the CH.NameStreamProc's is already  ** the distinguished name.  These are called directly from DoInfoCommand,  ** so don't have to have exactly these args, etc.  >>  DoInfoCommand: PUBLIC MaintainPrivate.CommandProcType =    BEGIN    <<    ** this is the conversation handle used by all the forked processes.  The    ** first thing a forked process does is to create a new ch from the identity    ** handle.  The last thing it does if free the ch.  As we should only have    ** one of the command processes running at a time, there should be no    **  conflict.    >>    -- one time only conversation handle    ch: CH.ConversationHandle ¬ MaintainCmds.nullCH;    <<    ** NOTE... contrary to the documentation, Enumerate & friends DO pass    ** an entirely valid name.    ** EntryPattern - i.copyData.entry in form of NSName.    ** If entry is several things,    ** this will be each in turn.  In any case, the domain and org are specified.    >>    startOfList: BOOLEAN ¬ TRUE;  -- we're at beginning of ',' sep list    wh: Window.Handle = i.sws.fileSW;    window: Window.Handle = ToolWindow.WindowForSubwindow[wh];    -- Enumerate Procedures for DoInfoCommand    -- using WriteNameList    -- OneName - print just the name for this entry.    -- CH.NameStreamProc = PROC[currentName: NSName.Name];    OneName: CH.NameStreamProc = {      Put.Text[wh, "   "L]; MCHPutExtras.Name[wh, currentName]; };    -- OneSummary - do Summary for one entry    OneSummary: CH.NameStreamProc =      BEGIN      Done: PROCEDURE = {IF buffer # NIL THEN CH.FreeRhs[buffer, z]; };      howManyMembers: CARDINAL ¬ 0;      MemberCount: CH.NameStreamProc = {howManyMembers ¬ howManyMembers + 1; };      buffer: CH.Buffer ¬ CH.MakeRhs[CH.maxBufferSize, z];      ok: CH.ReturnCode;      -- OneSummaryStarts      {  -- spurious scoping for exits      ENABLE UNWIND => Done[];      Put.Text[wh, "\nSummary of: "L];      MCHPutExtras.Name[wh, currentName];      -- user summary      ok ¬ CH.LookupValueProperty[ch, currentName, CHPIDs.user, buffer, NIL];      IF ok.code # propertyIDNotFound THEN {  -- This is a user        Put.Text[wh, "\nUser remark: "L];        IF ok.code # done THEN {          CHGloss.ReturnCodeToString[ok, Put.Text, wh]; GOTO done; };        PutPrimary[wh, buffer];        -- file service        Put.Text[wh, "\nFile service: "L];        ok ¬ CH.LookupValueProperty[ch, currentName, CHPIDs.userData, buffer, NIL];        IF ok.code # done THEN CHGloss.ReturnCodeToString[ok, Put.Text, wh]        ELSE {  -- deserialize userData          userData: CHEntries.UserData ¬ [0, NIL];          params: Courier.Parameters ¬ [@userData, CHEntries.DescribeUserData];          IF ~CH.DeserializeFromRhs[params, z, buffer] THEN            Put.Text[wh, "Deserialize failed"L]          ELSE MCHPutExtras.Name[wh, userData.fileService];          Courier.Free[params, z];          };        };      -- group summary      ok ¬ CH.LookupValueProperty[ch, currentName, CHPIDs.userGroup, buffer, NIL];      IF ok.code # propertyIDNotFound THEN {  -- This is a group        Put.Text[wh, "\nGroup remark: "L];        IF ok.code # done THEN {          CHGloss.ReturnCodeToString[ok, Put.Text, wh]; GOTO done; };        PutPrimary[wh, buffer];        -- membership count        Put.Text[wh, "\nNumber of members: "L];        ok ¬ CH.LookupGroupProperty[          ch, currentName, CHPIDs.members, MemberCount, NIL];        SELECT ok.code FROM          propertyIDNotFound, done => Put.LongDecimal[wh, howManyMembers];          ENDCASE => CHGloss.ReturnCodeToString[ok, Put.Text, wh]};      GOTO done;      EXITS done => Done[];      };  -- spurious scoping for exits      END;  -- OneSummary    WriteNameList: CH.NameStreamProc =      BEGIN      IF ~startOfList THEN Put.Text[wh, ", "L];      startOfList ¬ FALSE;      MCHPutExtras.Name[wh, currentName];      END;  -- WriteNameList    OneMembers: CH.NameStreamProc =      BEGIN      ok: CH.ReturnCode;      Put.Text[wh, "\nMembers of: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "\nMembers: "L];      ok ¬ CH.LookupGroupProperty[        ch, currentName, CHPIDs.members, WriteNameList, NIL];      SELECT ok.code FROM        done => NULL;        propertyIDNotFound => Put.Text[wh, "None"L];        ENDCASE => CHGloss.ReturnCodeToString[ok, Put.Text, wh];      END;  -- OneMembers    OneAliases: CH.NameStreamProc =      BEGIN      ok: CH.ReturnCode;      Put.Text[wh, "\nDistinguished Name: "L];      MCHPutExtras.Name[wh, currentName];      Put.Text[wh, "\nAliases:"L];      ok ¬ CH.LookupAliasesOfName[ch, currentName, WriteNameList, NIL];      IF ok.code = propertyIDNotFound THEN Put.Text[wh, "None"L]      ELSE IF ok.code # done THEN CHGloss.ReturnCodeToString[ok, Put.Text, wh];      END;  -- OneAliases    OneDetails: CH.NameStreamProc =      BEGIN      Done: PROCEDURE = {IF buffer # NIL THEN CH.FreeRhs[buffer, z]; };      buffer: CH.Buffer ¬ CH.MakeRhs[CH.maxBufferSize, z];      ok: CH.ReturnCode;      {  -- OneDetails      ENABLE UNWIND => Done[];      Put.Text[wh, "\nDistinguished Name: "L];      -- distinguished name      MCHPutExtras.Name[wh, currentName];      -- Aliases      Put.Text[wh, "\nAliases: "L];      startOfList ¬ TRUE;      ok ¬ CH.LookupAliasesOfName[ch, currentName, WriteNameList, NIL];      SELECT ok.code FROM        done => NULL;        propertyIDNotFound => Put.Text[wh, "None"L];        ENDCASE => CHGloss.ReturnCodeToString[ok, Put.Text, wh];      -- Password Type      ok ¬ CH.LookupValueProperty[        ch, currentName, CHPIDs.authenticationLevel, buffer, NIL];      SELECT ok.code FROM        propertyIDNotFound => NULL;        done => {          authLevel: CHEntriesExtras.AuthenticationLevel ¬ [FALSE, FALSE];          params: Courier.Parameters = [            @authLevel, CHEntriesExtras.DescribeAuthenticationLevel];          Put.Text[wh, "\nAuthentication level: "L];          IF ok.code # done THEN {            CHGloss.ReturnCodeToString[ok, Put.Text, wh]; GOTO done; };          IF ~CH.DeserializeFromRhs[params, z, buffer] THEN            Put.Text[wh, "Deserialize failed"L]          ELSE {            IF authLevel.simpleSupported THEN Put.Text[wh, "simple "L];            IF authLevel.strongSupported THEN Put.Text[wh, "strong"L];            };          Courier.Free[params, z];          };        ENDCASE => {          Put.Text[wh, "\nAuthentication level: "L];          CHGloss.ReturnCodeToString[ok, Put.Text, wh];          };      -- user summary      ok ¬ CH.LookupValueProperty[ch, currentName, CHPIDs.user, buffer, NIL];      SELECT ok.code FROM        propertyIDNotFound => NULL;        done => {  -- user          Put.Text[wh, "\nUser remark: "L];          IF ok.code # done THEN {            CHGloss.ReturnCodeToString[ok, Put.Text, wh]; GOTO done; };          -- User remark          PutPrimary[wh, buffer];          -- file service          Put.Text[wh, "\nFile service: "L];          ok ¬ CH.LookupValueProperty[            ch, currentName, CHPIDs.userData, buffer, NIL];          IF ok.code # done THEN CHGloss.ReturnCodeToString[ok, Put.Text, wh]          ELSE {            userData: CHEntries.UserData ¬ [0, NIL];            params: Courier.Parameters ¬ [@userData, CHEntries.DescribeUserData];            IF ~CH.DeserializeFromRhs[params, z, buffer] THEN              Put.Text[wh, "Deserialize failedn"L]            ELSE MCHPutExtras.Name[wh, userData.fileService];            Courier.Free[params, z];            };          -- Mailboxes (unimplimented)          };        ENDCASE => {          Put.Text[wh, "\nLookupValueProperty (user)"L];          CHGloss.ReturnCodeToString[ok, Put.Text, wh];          };      -- group summary      ok ¬ CH.LookupValueProperty[ch, currentName, CHPIDs.userGroup, buffer, NIL];      SELECT ok.code FROM        propertyIDNotFound => NULL;        done => {  -- group          Put.Text[wh, "\nGroup remark: "L];          IF ok.code # done THEN {            CHGloss.ReturnCodeToString[ok, Put.Text, wh]; GOTO done; };          -- Group Remark          PutPrimary[wh, buffer];          -- Members           Put.Text[wh, "\nMembers: "L];          startOfList ¬ TRUE;          ok ¬ CH.LookupGroupProperty[            ch, currentName, CHPIDs.members, WriteNameList, NIL];          SELECT ok.code FROM            done => NULL;            propertyIDNotFound => Put.Text[wh, "None"L]            ENDCASE => CHGloss.ReturnCodeToString[ok, Put.Text, wh];          -- Owners          Put.Text[wh, "\nOwners: "L];          startOfList ¬ TRUE;          ok ¬ MoreCH.LookupPropertyAccess[            ch, currentName, CHPIDs.members, administrators, WriteNameList, NIL];          SELECT ok.code FROM            done => NULL;            propertyIDNotFound => Put.Text[wh, "None"L]            ENDCASE => CHGloss.ReturnCodeToString[ok, Put.Text, wh];          -- Friends          Put.Text[wh, "\nFriends: "L];          startOfList ¬ TRUE;          ok ¬ MoreCH.LookupPropertyAccess[            ch, currentName, CHPIDs.members, selfControllers, WriteNameList, NIL];          SELECT ok.code FROM            done => NULL;            propertyIDNotFound => Put.Text[wh, "None"L]            ENDCASE => CHGloss.ReturnCodeToString[ok, Put.Text, wh];          };        ENDCASE => {          Put.Text[wh, "\nLookupValueProperty (userGroup)"L];          CHGloss.ReturnCodeToString[ok, Put.Text, wh];          };      GOTO done;      EXITS done => Done[];      };      END;  -- OneDetails    -- DoInfoCommandStarts (these variables not used in sub-procedures)    Done: PROCEDURE =      BEGIN      Put.Text[wh, "\nDone\n"L];      MCHNameExtras.FreeNames[nameList, z];      CH.FreeConversationHandle[@ch, z];  -- free conversation handle      END;  -- Done    handleOk: BOOLEAN ¬ FALSE;  -- ch is ok    inl: CARDINAL ¬ 0;  -- index for nameList    -- (current elem in nameList)    nameList: MCHNameExtras.NameList ¬ NIL;  -- all the names in entry.    <<    ** now expanded out by StringsAndNames.ParseNameList which does the    ** enumerate & maps to distinguished names.    >>    Command: CH.NameStreamProc =      SELECT i.windowItemsCopy.command FROM        summary => OneSummary,        matches => WriteNameList,        members => OneMembers,        aliases => OneAliases,        details => OneDetails,        ENDCASE => ERROR Bug[unknownSelect];    {    ENABLE UNWIND => Done[];    IF String.Empty[i.windowItemsCopy.entry] THEN {      SELECT i.windowItemsCopy.gi FROM        group => MaintainCmds.MissingFieldRequest[i, "group"L];        indiv => MaintainCmds.MissingFieldRequest[i, "individual"L];        ENDCASE => ERROR Bug[unknownSelect];      GOTO done;      };    [ch, handleOk] ¬ MaintainCmds.MakeCh[z, i];  -- error printed (if any)    IF ~handleOk THEN GOTO done;    -- write something first thing    Put.CR[wh];    Put.Text[      wh,      SELECT i.windowItemsCopy.command FROM        summary => "\nSummary of "L,        matches => "\nNames matching "L,        members => "\nMembers of "L,        aliases => "\nAliases for "L,        details => "\nDetails of "L,        ENDCASE => ERROR Bug[unknownSelect]];    Put.Text[wh, i.windowItemsCopy.entry];    Put.Text[wh, "..."L];    <<    ** do for EACH name in entry    ** This expands things out by doing an enumerate, and thereby also maps    ** names to distinguished names.  No way to tell where name came    ** from after this.    >>    nameList ¬ MCHNameExtras.ParseNameList[      namesString: NSString.StringFromMesaString[i.windowItemsCopy.entry],      defaults: i.globals.defaultsName, zone: z,      resolveAliases: i.windowItemsCopy.checkNames,      expandPatterns: i.windowItemsCopy.checkNames,      validateNames: i.windowItemsCopy.checkNames,      validatePatterns: i.windowItemsCopy.checkNames,      pid: SELECT TRUE FROM        i.windowItemsCopy.anyEntry => CH.unspecified,        i.windowItemsCopy.gi = group => CHPIDs.userGroup,        i.windowItemsCopy.gi = indiv => CHPIDs.user,        ENDCASE => ERROR Bug[unknownSelect], ch: ch !      MCHNameExtras.TooManySeparators => {  -- name is arg        Put.Text[wh, "\nInvalid name: "L];        MCHPutExtras.PutNSString[wh, name];        RESUME;        };      MCHNameExtras.EnumerateProblem => {  -- rc & name are args        SELECT TRUE FROM          MaintainCmds.NotFoundError[rc] => {            Put.CR[wh];            MCHPutExtras.Name[wh, name];            Put.Text[wh, " is not a "L];            Put.Text[              wh,              SELECT i.windowItemsCopy.gi FROM                group => "group"L,                indiv => "user"L,                ENDCASE => ERROR Bug[unknownSelect]];            };          ENDCASE => {            Put.Text[wh, "\nCH problem "L];            CHGloss.ReturnCodeToString[rc, Put.Text, wh];            };        RESUME;        };      MCHNameExtras.UnfoundName => {        Put.CR[wh];        Put.Text[wh, "No "];        Put.Text[          wh,          SELECT i.windowItemsCopy.gi FROM            group => "group"L,            indiv => "user"L,            ENDCASE => ERROR Bug[unknownSelect]];        Put.Text[wh, " matches "L];        MCHPutExtras.Name[wh, name];        RESUME [FALSE];        }; ];    <<    IF nameList = NIL OR LENGTH[nameList] = 0 THEN {      Put.CR[wh];      Put.Text[wh, "no "L];      Put.Text[        wh,        SELECT i.windowItemsCopy.gi FROM          group => "group"L,          indiv => "user"L,          ENDCASE => ERROR Bug[unknownSelect]];      Put.Text[wh, " matched"L];      GOTO done;      };>>    FOR inl IN [0..LENGTH[nameList]) DO      Command[@nameList[inl]];  << DO IT >>      ENDLOOP;    GOTO done    EXITS done => Done[];    };    END;  -- DoInfoCommand  -- DoUpdateIdentity - forked by UpdateIdentity  -- Update idh, and complain about any errors.  DoUpdateIdentity: PUBLIC MaintainPrivate.CommandProcType =    BEGIN    SetIdentityAndDefaultName: PROCEDURE [id: Auth.IdentityHandle] =      BEGIN      name: NSName.Name;  <<name belongs to GetIdentityDetails>>      [name, , ] ¬ Auth.GetIdentityDetails[id];      i.globals.idh ¬ Auth.CopyIdentity[id, z];      i.globals.defaultsName ¬ NSName.CopyName[z, name];      END;  -- SetIdentityAndDefaultName    -- DoUpdateIdentity starts    Auth.FreeIdentity[@i.globals.idh, z];    MCHNameExtras.FreeName[z, i.globals.defaultsName];    i.globals.defaultsName ¬ NIL;    Profile.GetID[strong, SetIdentityAndDefaultName];    END;  -- DoUpdateIdentity  END.	-- MaintainCmdsAImpl.mesaLOG  Created by Sturtevant  2-May-84 11:05:33  Templatized by Sturtevant - 22-Oct-84 16:52:02  No longer check for abort - rely on ABORTED being raised - Sturtevant  5-Nov-84 16:07:43  Always REJECT UNWIND - Sturtevant -  7-Nov-84 14:29:33  Calaverafied - Sturtevant -  4-Jan-85 12:41:03
-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- SimHashImpl.mesa-- Last edit by DEG     : 26-Sep-84 23:19:41DIRECTORY  Environment USING [    Byte, bytesPerWord, charsPerWord, PageCount, wordsPerPage],  Inline USING [BITAND, BITXOR, LongCOPY, LongDiv],  MSegment USING [Address, Create, Delete, Handle],  SimHashDefs USING [    Base, FirstAvailSlot, Hash, HashBlock, HNull, HVSize, PtrIndex, PtrTable],  Stream USING [Delete, Handle, PutBlock, PutWord, Word],  String USING [AppendString, EqualStrings, EquivalentStrings],  SymbolTableDefs USING [STData];SimHashImpl: PROGRAM  IMPORTS Inline, MSegment, Stream, String  EXPORTS SimHashDefs =  BEGIN  data: SimHashDefs.Base;  dataMSH: MSegment.Handle;  nextPtrIndex: SimHashDefs.PtrIndex;  ptrTable: LONG POINTER TO SimHashDefs.PtrTable;  ptrTableMSH: MSegment.Handle;  tableIncr: Environment.PageCount = 8;  NewEntry: PRIVATE PROCEDURE [s: LONG STRING, next: SimHashDefs.Hash]    RETURNS [h: SimHashDefs.Hash] =    BEGIN    w: CARDINAL = SIZE[SimHashDefs.HashBlock] +        (s.length + Environment.charsPerWord - 1)/Environment.charsPerWord;    IF LOOPHOLE[data.nextAvail + w, CARDINAL] >      LOOPHOLE[data.nPages*Environment.wordsPerPage, CARDINAL] THEN        BEGIN  --make more space        np, nw: CARDINAL;        oldData: SimHashDefs.Base ¬ data;        oldDataMSH: MSegment.Handle ¬ dataMSH;        np ¬ data.nPages + CARDINAL[tableIncr]; <<coerced tableIncr to CARDINAL so compiler doesn't complain!  Perhaps we need to make sure that tableIncr is always in CARDINAL. >>        nw ¬ LOOPHOLE[data.nextAvail];  -- number of words in old data        dataMSH ¬ MSegment.Create[release: [NIL, NIL], pages: np];        data ¬ MSegment.Address[dataMSH];        Inline.LongCOPY[from: oldData, to: data, nwords: nw];        MSegment.Delete[oldDataMSH];        data.nPages ¬ np;        END;    h ¬ data.nextAvail;    data.nextAvail ¬ data.nextAvail + w;    data[h] ¬ [      next: next, reloc: TRUE, ptrIndex: 0,      string: [length: 0, maxlength: s.length, text:]];    String.AppendString[@data[h].string, s];    END;  HashBlockSize: PRIVATE PROCEDURE [h: SimHashDefs.Hash]     RETURNS [CARDINAL] =       {RETURN[        SIZE[SimHashDefs.HashBlock] +        (data[h].string.maxlength + Environment.charsPerWord - 1)/Environment.charsPerWord]};  PagesForWords: PRIVATE PROCEDURE [nWords: CARDINAL] RETURNS [CARDINAL] = {    RETURN[Inline.LongDiv[      LONG[nWords] + Environment.wordsPerPage - 1, Environment.wordsPerPage]]};  FreeHash: PRIVATE PROCEDURE [h: SimHashDefs.Hash] =    BEGIN    link: SimHashDefs.Hash ¬ NewHash[data[h].next];    delta: CARDINAL ¬ HashBlockSize[h];    above: CARDINAL;    NewHash: PROCEDURE [old: SimHashDefs.Hash] RETURNS [SimHashDefs.Hash] =      BEGIN      RETURN[        SELECT old FROM          SimHashDefs.HNull => SimHashDefs.HNull,          h => link,          > h => old - delta,          ENDCASE => old];      END;    UpdateLinks: PROCEDURE [old: SimHashDefs.Hash] RETURNS [BOOLEAN] =      BEGIN data[old].next ¬ NewHash[data[old].next]; RETURN[TRUE] END;    IF h = SimHashDefs.HNull OR h >= data.nextAvail THEN RETURN;    data.nextAvail ¬ data.nextAvail - delta;    above ¬ data.nextAvail - h;    IF above > 0 THEN      Inline.LongCOPY[from: @data[h] + delta, to: @data[h], nwords: above];    FOR i: CARDINAL IN [0..SimHashDefs.HVSize) DO      data.hVec[i] ¬ NewHash[data.hVec[i]] ENDLOOP;    [] ¬ EnumerateEntries[UpdateLinks];    END;  HashFn: PRIVATE PROCEDURE [s: LONG STRING] RETURNS [[0..SimHashDefs.HVSize)] =    BEGIN  -- computes the hash index for string s    CharBits: PROCEDURE [CHARACTER, WORD] RETURNS [WORD] =      LOOPHOLE[Inline.BITAND];    Mask: WORD = 337B;  -- masks out ASCII case shifts    n: CARDINAL = s.length;    v: WORD;    v ¬ CharBits[s[0], Mask]*177B + CharBits[s[n - 1], Mask];    RETURN[Inline.BITXOR[v, n*17B] MOD SimHashDefs.HVSize]    END;  Lookup: PUBLIC PROC [s: LONG STRING, insert: BOOLEAN]    RETURNS [h: SimHashDefs.Hash, old: BOOLEAN] =    BEGIN    i: [0..SimHashDefs.HVSize) ¬ HashFn[s];    compareFn: PROCEDURE [str1: LONG STRING, str2: LONG STRING] RETURNS [BOOLEAN] = INLINE {RETURN[      IF data.caseHeed THEN String.EqualStrings[str1, str2]      ELSE String.EquivalentStrings[str1, str2]]};    h ¬ data.hVec[i];    WHILE h # SimHashDefs.HNull DO      IF compareFn[s, @data[h].string] THEN RETURN[h, TRUE];      h ¬ data[h].next;      ENDLOOP;    IF insert THEN data.hVec[i] ¬ h ¬ NewEntry[s, data.hVec[i]]    ELSE h ¬ SimHashDefs.HNull;    RETURN[h, FALSE];    END;  StringForHash: PUBLIC PROC [h: SimHashDefs.Hash, s: STRING] =    BEGIN s.length ¬ 0; String.AppendString[s, @data[h].string] END;  TempStringForHash: PUBLIC PROC [h: SimHashDefs.Hash] RETURNS [LONG STRING] =    BEGIN RETURN[@data[h].string] END;  GetInfo: PUBLIC PROC [h: SimHashDefs.Hash]    RETURNS [BOOLEAN, LONG POINTER TO SymbolTableDefs.STData] =     {RETURN[data[h].reloc, ptrTable[data[h].ptrIndex]]};  PutInfo: PUBLIC PROC [    h: SimHashDefs.Hash, b: BOOLEAN, d: LONG POINTER TO SymbolTableDefs.STData] = {    data[h].reloc    ¬ b;    ptrTable[nextPtrIndex]  ¬ d;    data[h].ptrIndex  ¬ nextPtrIndex;    nextPtrIndex  ¬ nextPtrIndex + 1};  JamValue: PUBLIC PROC [h: SimHashDefs.Hash, b: BOOLEAN, v: CARDINAL] = {    data[h].reloc    ¬ b;    data[h].ptrIndex  ¬ LOOPHOLE[v, SimHashDefs.PtrIndex]};  CaseHeed: PUBLIC PROC [f: BOOLEAN] = {data.caseHeed ¬ f};  Create: PUBLIC PROC [nPages: CARDINAL] =    BEGIN    DestroyST[];    dataMSH ¬ MSegment.Create[release: [NIL, NIL], pages: nPages];    data ¬ MSegment.Address[dataMSH];    data.nPages ¬ nPages;    FOR i: CARDINAL IN [0..SimHashDefs.HVSize) DO      data.hVec[i] ¬ SimHashDefs.HNull; ENDLOOP;    data.nextAvail ¬ SimHashDefs.FirstAvailSlot;    data.caseHeed ¬ FALSE;    ptrTableMSH ¬ MSegment.Create[      release: [NIL, NIL],       pages: PagesForWords[SIZE[SimHashDefs.PtrTable]]];    ptrTable ¬ MSegment.Address[ptrTableMSH];    FOR i: CARDINAL IN SimHashDefs.PtrIndex DO ptrTable[i] ¬ NIL; ENDLOOP;    END;  DestroyST: PUBLIC PROC = {    IF ptrTableMSH#NIL THEN {      MSegment.Delete[ptrTableMSH];       nextPtrIndex ¬ 0; ptrTableMSH ¬ NIL; ptrTable ¬ NIL};    IF dataMSH#NIL THEN {MSegment.Delete[dataMSH]; dataMSH ¬ NIL; data ¬ NIL}};  DumpToStream: PUBLIC PROC [stream: Stream.Handle] =    BEGIN    Stream.PutWord[sH: stream, word: LOOPHOLE[data.nextAvail, Stream.Word]];    Stream.PutBlock[      sH: stream,      block: [      blockPointer: LOOPHOLE[        data, LONG POINTER TO PACKED ARRAY INTEGER[0..0) OF Environment.Byte],       startIndex: 0,      stopIndexPlusOne:      Environment.bytesPerWord*LOOPHOLE[data.nextAvail, CARDINAL]],      endRecord: FALSE];    Stream.Delete[sH: stream];    END;  EnumerateEntries: PUBLIC PROC [    action: PROCEDURE [SimHashDefs.Hash] RETURNS [BOOLEAN]]    RETURNS [h: SimHashDefs.Hash] =    BEGIN    h ¬ SimHashDefs.FirstAvailSlot;    WHILE h < data.nextAvail DO      IF ~action[h] THEN EXIT;      h ¬ h + HashBlockSize[h];      REPEAT FINISHED => h ¬ SimHashDefs.HNull;      ENDLOOP;    END;  Init: PROC = {    nextPtrIndex ¬ 0; ptrTable ¬ NIL; ptrTableMSH ¬ NIL;    data ¬ NIL; dataMSH ¬ NIL};  Init[];    END....  -- LOG  -- ETN        -  1-Apr-82 14:05:12 - Convert to Trinity.  -- ETN        - 20-Apr-82 11:23:15 - Fix infoHigh bug.  -- ETN        -  4-Oct-82 16:24:36 - Alto-Burdock compatability and cleanup.  -- DEG     	- 31-Jan-83  8:17:17 - Convert to Sierra  -- DEG     	- 29-May-83  1:42:37 - Convert to Klamath  -- Time: 26-Sep-84 23:19:37	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- SymHasher.mesa, HGM,  7-Feb-85  1:58:40DIRECTORY  Heap USING [Create, Delete, systemZone],  Inline USING [BITAND, BITXOR],  String USING [AppendString, Equal],    SymHash USING [nullHash];SymHasher: PROGRAM  IMPORTS Heap, Inline, String  EXPORTS SymHash =  BEGIN  Handle: PUBLIC TYPE = LONG POINTER TO HashRegion;  Hash: PUBLIC TYPE = LONG POINTER TO HashBlock;    hVSize: CARDINAL = 71;  HashBlock: TYPE = RECORD [    next, chain: Hash,    info: LONG UNSPECIFIED,    string: LONG STRING];     HashRegion: TYPE = RECORD [    hVec: ARRAY [0..hVSize) OF Hash,    zone: UNCOUNTED ZONE,    pages: CARDINAL,    head, tail: Hash ];      HashFn: PROCEDURE [s: LONG STRING] RETURNS [[0..hVSize)] =    BEGIN  -- computes the hash index for string s    CharBits: PROCEDURE [CHARACTER, WORD] RETURNS [WORD] =      LOOPHOLE[Inline.BITAND];    Mask: WORD = 337B;  -- masks out ASCII case shifts    n: CARDINAL = s.length;    v: WORD;    v ¬ CharBits[s[0], Mask]*177B + CharBits[s[n - 1], Mask];    RETURN[Inline.BITXOR[v, n*17B] MOD hVSize]    END;  Lookup: PUBLIC PROCEDURE [data: Handle, key: LONG STRING] RETURNS [h: Hash] =    BEGIN    i: [0..hVSize);    IF key = NIL THEN RETURN[SymHash.nullHash];    i ¬ HashFn[key];    h ¬ data.hVec[i];    WHILE h # NIL DO      IF String.Equal[key, h.string] THEN RETURN[h];      h ¬ h.chain;      ENDLOOP;    RETURN[SymHash.nullHash];    END;  Insert: PUBLIC PROCEDURE [handle: Handle, key: LONG STRING] RETURNS [h: Hash] =    BEGIN    i: [0..hVSize) ¬ HashFn[key];    h ¬ handle.hVec[i];    WHILE h # NIL DO      IF String.Equal[key, h.string] THEN ERROR;      h ¬ h.chain;      ENDLOOP;    h ¬ NewEntry[handle, key, handle.hVec[i]];    handle.hVec[i] ¬ h;    END;      NewEntry: PRIVATE PROCEDURE [handle: Handle, key: LONG STRING, chain: Hash]    RETURNS [Hash] =    BEGIN    h: Hash ¬ handle.zone.NEW[HashBlock];    h­ ¬ [      next: NIL, chain: chain, info: 0,      string: handle.zone.NEW[StringBody[key.length]] ];    String.AppendString[h.string, key];    IF handle.head = NIL THEN handle.head ¬ h ELSE handle.tail.next ¬ h;    handle.tail ¬ h;    RETURN[h];    END;  GetString: PUBLIC PROCEDURE [data: Handle, h: Hash] RETURNS [LONG STRING] =    BEGIN RETURN[h.string] END;  PutInfo: PUBLIC PROCEDURE [data: Handle, h: Hash, info: LONG UNSPECIFIED] =    BEGIN    h.info ¬ info;    END;  GetInfo: PUBLIC PROCEDURE [data: Handle, h: Hash] RETURNS [LONG UNSPECIFIED] =    BEGIN    RETURN[h.info];    END;  Create: PUBLIC PROCEDURE [pages: CARDINAL] RETURNS [handle: Handle] =    BEGIN    handle ¬ Heap.systemZone.NEW[HashRegion];    handle­ ¬ [      hVec: ALL[SymHash.nullHash],      zone: Heap.Create[initial: pages, increment: 10],      pages: pages,      head: NIL,      tail: NIL ];    END;    Reset: PUBLIC PROCEDURE [handle: Handle] =    BEGIN    pages: CARDINAL ¬ handle.pages;    Heap.Delete[handle.zone];    handle­ ¬ [      hVec: ALL[SymHash.nullHash],      zone: Heap.Create[initial: pages, increment: 10],      pages: pages,      head: NIL,      tail: NIL ];    END;    Destroy: PUBLIC PROCEDURE [handle: Handle] =    BEGIN    Heap.Delete[handle.zone];    Heap.systemZone.FREE[@handle];    END;  EnumerateStrings: PUBLIC PROCEDURE [handle: Handle, action: PROCEDURE [LONG STRING]] =    BEGIN    FOR h: Hash ¬ handle.head, h.next UNTIL h = NIL DO      action[h.string];      ENDLOOP;    END;  EnumerateEntries: PUBLIC PROCEDURE [handle: Handle, action: PROCEDURE [Hash]] =    BEGIN    FOR h: Hash ¬ handle.head, h.next UNTIL h = NIL DO      action[h];      ENDLOOP;    END;      END....
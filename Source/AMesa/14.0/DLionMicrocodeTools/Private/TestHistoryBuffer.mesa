-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- TestHistoryBuffer.mesa, HGM,  4-Oct-83 23:38:03DIRECTORY  DLionInputOutput USING [IOPage, processorCommandOffset, processorCSBOffset],  Environment USING [Byte],  FormSW USING [    ClientItemsProcType, ProcType, AllocateItemDescriptor, newLine, CommandItem],  Inline USING [BITAND, BITNOT, BITROTATE, BITXOR, BytePair, HighByte, LowByte],  Process USING [Yield],  Put USING [Number, Text, Line],  Runtime USING [GetBcdTime],  String USING [AppendString],  Time USING [Append, Unpack],  Tool USING [    Create, MakeSWsProc, UnusedLogName, MakeFormSW, MakeFileSW],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle];TestHistoryBuffer: PROGRAM  IMPORTS    DLionInputOutput, FormSW, Inline, Process, Put,    Runtime, String, Time, Tool, UserInput =  BEGIN  ProcessorCommand: TYPE = MACHINE DEPENDENT {    null(0), readIOPByte(5), writeIOPByte(6)};  pProcessorCommand: LONG POINTER TO ProcessorCommand = DLionInputOutput.IOPage + DLionInputOutput.processorCommandOffset;  ProcessorCSB: TYPE = MACHINE DEPENDENT RECORD [    data2(0): WORD,    data1(1): WORD,      data0(2): WORD];  pProcessorCSB: LONG POINTER TO ProcessorCSB = DLionInputOutput.IOPage + DLionInputOutput.processorCSBOffset;    baseAddress: WORD = 100200B;  -- Hex 8080  controlByte: WORD = baseAddress + 0;    run: WORD = 0;    boot: WORD = 1B;    useCsa: WORD = 2B;    useRam: WORD = 4B;    clearCpByteReady: WORD = 10B;    singleStep: WORD = 20B;    stop: WORD = 100B;  statusByte: WORD = baseAddress + 0;    cycle1: WORD = 4B;    cycle2: WORD = 2B;    cycle3: WORD = 1B;    bufferFromCpFull: WORD = 10B;    bufferToCpFull: WORD = 20B;    hbDone: WORD = 40B;    stopBar: WORD = 100B;  cpData: WORD = baseAddress + 1;  finger: WORD = baseAddress + 2;  contents: WORD = baseAddress + 3;    Register: TYPE = MACHINE DEPENDENT {    -- Control Store section starts at 0    csaMsb(0B), csaLsb(1B),    csData0(2B), csData1(3B), csData2(4B), csData3(5B), csData4(6B), csData5(7B),    niaMsb(10B), niaLsb(11B),    temp(12B),    -- History Buffer section starts at 20B    hbAddr(20B),    hbPCMsb(21B), hbPCLsb(22B), hbPCExtra(23B),    hbMatchMsb(24B), hbMatchLsb(25B),    hbCount(26B), hbBits(27B),    (0FFH) };  -- HB ControlBits:  hbTrigger: WORD = 1B;  hbSeeAllClocks: WORD = 0B;  hbSeeOnlyDoIt: WORD = 2B;  hbSeeOnlyIBDisp: WORD = 4B;    hbSec: WORD = LOOPHOLE[Register[hbAddr]];  sizeOfHB: CARDINAL = 256;  ReadIOP: PROCEDURE [address: CARDINAL] RETURNS [Environment.Byte] =    BEGIN    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ address;    pProcessorCommand­ ¬ readIOPByte;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    RETURN[Inline.LowByte[pProcessorCSB.data1]];    END;  WriteIOP: PROCEDURE [address: CARDINAL, data: Environment.Byte] =    BEGIN    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ address;    pProcessorCSB.data1 ¬ data;    pProcessorCommand­ ¬ writeIOPByte;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    END;  DebuggerBoardNotResponding: ERROR = CODE;  Mixup: ERROR [s: STRING, expected, found: UNSPECIFIED] = CODE;  Initialize: PROCEDURE =    BEGIN    temp: WORD;    temp ¬ ReadIOP[statusByte];    IF temp = 0 THEN ERROR DebuggerBoardNotResponding; -- c1, c2, or c3 should be on    IF temp = 0FFH THEN ERROR DebuggerBoardNotResponding;  -- high bit wired to GND    WriteIOP[controlByte, stop+useRam+useCsa];  -- Take control, feed CSA to Matcher    temp ¬ ReadIOP[statusByte];    IF Inline.BITAND[temp, stopBar] # 0 THEN ERROR DebuggerBoardNotResponding;  -- Stop didn't clear run    IF Inline.BITAND[temp, 07H] = 0 THEN ERROR DebuggerBoardNotResponding;  -- DLion Umbilical does this    END;  SetRun: PROCEDURE =    BEGIN    WriteIOP[controlByte, useRam+useCsa];  -- Turn off Stop    END;  ResetRun: PROCEDURE =    BEGIN    WriteIOP[controlByte, stop+useRam+useCsa];  -- Turn on Stop    END;  Status: FormSW.ProcType =    BEGIN    Put.Text[log, "Status byte is ... "L];    FOR i: CARDINAL IN [0..5) DO      temp: WORD ¬ ReadIOP[statusByte];      Put.Number[log, temp, [16, FALSE, TRUE, 3]];      ENDLOOP;    Put.Line[log, "."L];    END;    Section: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Section byte is ... "L];    Initialize[];    FOR i: CARDINAL IN [0..5) DO      temp: WORD ¬ ReadIOP[finger];      Put.Number[log, temp, [16, FALSE, TRUE, 3]];      ENDLOOP;    Put.Line[log, "."L];    END;         NIA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    nia: WORD;    Put.Text[log, "NIA is "L];    Initialize[];    WriteIOP[controlByte, stop+useRam];    SetFinger[niaMsb];    nia ¬ ReadIOP[contents] * 400B;    nia ¬ nia + ReadIOP[contents];    Put.Number[log, nia, [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    END;      CSA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    csa: WORD;    Put.Text[log, "CSA is "L];    Initialize[];    SetFinger[csaMsb];    csa ¬ ReadIOP[contents] * 400B;    csa ¬ csa + ReadIOP[contents];    Put.Number[log, csa, [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    END;        TestHBReg: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Testing HBReg ... "L];    Initialize[];    DO      FOR i: CARDINAL IN [0..100) DO        found: WORD;        WriteIOP[finger,  hbSec + 0];        found ¬ ReadIOP[finger];        IF found # hbSec + 0 THEN ERROR Mixup["HBReg readback mixup"L, hbSec + 0, found];        WriteIOP[finger, hbSec + 07H];        found ¬ ReadIOP[finger];        IF found # hbSec + 07H THEN ERROR Mixup["HBReg readback mixup"L, hbSec + 07H, found];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    TestHBRegIncr: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Testing HBReg Incr ... "L];    Initialize[];    WriteIOP[finger, hbSec];    DO      FOR i: CARDINAL IN [0..20) DO        TestIncr[hbAddr, hbPCMsb];        TestIncr[hbPCMsb, hbPCLsb];        TestIncr[hbPCLsb, hbPCExtra];        TestIncr[hbPCExtra, hbPCMsb];        TestIncr[hbMatchMsb, hbMatchLsb];        TestIncr[hbMatchLsb, hbCount];        TestIncr[hbCount, hbBits];        TestIncr[hbBits, hbBits];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    TestIncr: PROCEDURE [reg, bumped: Register] =    BEGIN    found: Register;    SetFinger[reg];    found ¬ LOOPHOLE[ReadIOP[finger]];    IF found # reg THEN ERROR Mixup["HBReg readback mixup"L, Register[reg], found];    [] ¬ ReadIOP[contents];    found ¬ LOOPHOLE[ReadIOP[finger]];    IF found # bumped THEN ERROR Mixup["HBReg incr mixup after read"L, Register[bumped], found];    SetFinger[reg];    found ¬ LOOPHOLE[ReadIOP[finger]];    IF found # reg THEN ERROR Mixup["HBReg readback mixup"L, Register[reg], found];    WriteIOP[contents, 0];    found ¬ LOOPHOLE[ReadIOP[finger]];    IF found # bumped THEN ERROR Mixup["HBReg incr mixup after write"L, Register[bumped], found];    END;    ReadWriteHBReg: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>              BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Reading and Writing HBReg ... "L];    Initialize[];    WriteIOP[finger, hbSec];    DO      FOR i: CARDINAL IN [0..100) DO        WriteIOP[finger, hbSec + 0];        [] ¬ ReadIOP[finger];        WriteIOP[finger, hbSec + 0FH];        [] ¬ ReadIOP[finger];	ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    WriteHBReg: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Writing HBReg ... "L];    Initialize[];    WriteIOP[finger, hbSec];    DO      FOR i: CARDINAL IN [0..100) DO        WriteIOP[finger, hbSec + 0];        WriteIOP[finger, hbSec + 0FH];	ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    ReadHBReg: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Reading HBReg ... "L];    Initialize[];    WriteIOP[finger, hbSec];    DO      FOR i: CARDINAL IN [0..100) DO        [] ¬ ReadIOP[finger];        [] ¬ ReadIOP[finger];	ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    Bits: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Bits are "L];    Initialize[];    SetFinger[hbBits];    Put.Number[log, ReadIOP[contents], [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    END;      TestBits: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Testing Ctl/Sts Bits ... "L];    Initialize[];    SetFinger[hbBits];    DO      FOR i: CARDINAL IN [0..100) DO        found: WORD;        WriteIOP[contents, 0];        found ¬ Inline.BITAND[ReadIOP[contents], 0FH];        IF found # 0 THEN ERROR Mixup["Bits readback mixup"L, 0, found];        WriteIOP[contents, 17B];        found ¬ Inline.BITAND[ReadIOP[contents], 0FH];        IF found # 0FH THEN ERROR Mixup["Bits readback mixup"L, 0FH, found];        Process.Yield[];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    Match: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    match: WORD;    Put.Text[log, "Match is "L];    Initialize[];    SetFinger[hbMatchMsb];    match ¬ ReadIOP[contents] * 400B;    match ¬ match + ReadIOP[contents];    Put.Number[log, match, [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    END;      TestMatch: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Testing Match ... "L];    Initialize[];    SetFinger[hbMatchMsb];    DO      FOR i: CARDINAL IN [0..100) DO        found: WORD;	temp: Register;	        SetFinger[hbMatchMsb];        WriteIOP[contents, 0];  -- msb        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # hbMatchLsb THEN Mixup["HBReg didn't incr writing MatchMsb"L, Register[hbMatchLsb], temp];        WriteIOP[contents, 0];  -- lsb        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # hbCount THEN Mixup["HBReg didn't incr writing MatchLsb"L, Register[hbCount], temp];	        SetFinger[hbMatchMsb];        found ¬ ReadIOP[contents];        IF found # 0 THEN ERROR Mixup["MatchMsb readback mixup"L, 0, found];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # hbMatchLsb THEN Mixup["HBReg didn't incr reading MatchMsb"L, Register[hbMatchLsb], temp];        found ¬ ReadIOP[contents];        IF found # 0 THEN ERROR Mixup["MatchLsb readback mixup"L, 0, found];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # hbCount THEN Mixup["HBReg didn't incr reading MatchLsb"L, Register[hbCount], temp];	        SetFinger[hbMatchMsb];        WriteIOP[contents, 0FFH];        WriteIOP[contents, 0FFH];        SetFinger[hbMatchMsb];        found ¬ ReadIOP[contents];        IF found # 0FFH THEN ERROR Mixup["MatchMsb readback mixup"L, 0FFH, found];        found ¬ ReadIOP[contents];        IF found # 0FFH THEN ERROR Mixup["MatchLsb readback mixup"L, 0FFH, found];	        Process.Yield[];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    SetMatch: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Setting Match to CSA ... "L];    Initialize[];    SetMatcher[];    SetRun[];    Put.Line[log, "ok."L];    END;    SetMatcher: PROCEDURE =    BEGIN    csa: WORD;    SetFinger[csaMsb];    csa ¬ ReadIOP[contents] * 400B;    csa ¬ csa + ReadIOP[contents];    SetFinger[hbMatchMsb];    WriteIOP[contents, Inline.HighByte[csa]];    WriteIOP[contents, Inline.LowByte[csa]];    WriteBits[hbSeeAllClocks];    END;  ClearMatch: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Setting Match to ~csa ... "L];    Initialize[];    ClearMatcher[];    SetRun[];    Put.Line[log, "ok."L];    END;    ClearMatcher: PROCEDURE =    BEGIN    csa: WORD;    SetFinger[csaMsb];    csa ¬ ReadIOP[contents] * 400B;    csa ¬ csa + ReadIOP[contents];    csa ¬ Inline.BITNOT[csa];    SetFinger[hbMatchMsb];    WriteIOP[contents, Inline.HighByte[csa]];    WriteIOP[contents, Inline.LowByte[csa]];    WriteBits[hbSeeAllClocks];    END;  HBA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "HB Address is "L];    Initialize[];    SetFinger[hbAddr];    Put.Number[log, ReadIOP[contents], [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    END;      TestHBA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Testing HB Address ... "L];    Initialize[];  -- Stop keeps HBA from spinning    DO      FOR i: CARDINAL IN [0..100) DO        found: WORD;	temp: Register;	        SetFinger[hbAddr];        WriteIOP[contents, 0];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # hbPCMsb THEN Mixup["HBReg didn't incr writing HBA"L, Register[hbPCMsb], temp];        SetFinger[hbAddr];        found ¬ ReadIOP[contents];        IF found # 0 THEN ERROR Mixup["HBA readback mixup"L, 0, found];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # hbPCMsb THEN Mixup["HBReg didn't incr reading HBA"L, Register[hbPCMsb], temp];	        SetFinger[hbAddr];        WriteIOP[contents, 0FFH];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # hbPCMsb THEN Mixup["HBReg didn't incr writing HBA"L, Register[hbPCMsb], temp];        SetFinger[hbAddr];        found ¬ ReadIOP[contents];        IF found # 0FFH THEN ERROR Mixup["HBA readback mixup"L, 0FFH, found];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # hbPCMsb THEN Mixup["HBReg didn't incr reading HBA"L, Register[hbPCMsb], temp];	        Process.Yield[];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    Count: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Count is "L];    Initialize[];    SetFinger[hbCount];    Put.Number[log, ReadIOP[contents], [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    END;      TestCount: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Testing Count Register ... "L];    Initialize[];  -- Stop keeps Count from changing, even if Matched    DO      FOR i: CARDINAL IN [0..100) DO        found: WORD;        SetFinger[hbCount];        WriteIOP[contents, 0];        SetFinger[hbCount];        found ¬ ReadIOP[contents];        IF found # 0 THEN ERROR Mixup["Count readback mixup"L, 0, found];        SetFinger[hbCount];        WriteIOP[contents, 0FFH];        SetFinger[hbCount];        found ¬ ReadIOP[contents];        IF found # 0FFH THEN ERROR Mixup["Count readback mixup"L, 0FFH, found];        Process.Yield[];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    ReadWriteCount: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Reading and Writing Count Register ... "L];    Initialize[];  -- Stop keeps Count from changing, even if Matched    DO      FOR i: CARDINAL IN [0..100) DO        found: WORD;        SetFinger[hbCount];        WriteIOP[contents, 0];        SetFinger[hbCount];        found ¬ ReadIOP[contents];        SetFinger[hbCount];        WriteIOP[contents, 0FFH];        SetFinger[hbCount];        found ¬ ReadIOP[contents];        Process.Yield[];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    SpinCount: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Spinning Count Register ... "L];    Initialize[];    SetMatcher[];  -- So Count counts down    DO      ResetRun[];      SetFinger[hbCount];      WriteIOP[contents, 0];      SetRun[];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    KickCount: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Kicking Count Register ... "L];    Initialize[];    SetMatcher[];  -- So Count counts down    DO      ResetRun[];      SetFinger[hbCount];      WriteIOP[contents, 0FEH];      SetRun[];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;              TestMatcher: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    csa: CARDINAL;    Put.Text[log, "Testing Matcher and side effects ... "L];    Initialize[];    csa ¬ ReadCSA[];    DO      FOR count: CARDINAL IN [0..0FFH) DO        FOR i: CARDINAL IN [0..16) DO	  bit: WORD = Inline.BITROTATE[1, i];	  mismatch: WORD = Inline.BITXOR[csa, bit];	  notCsa: WORD = Inline.BITNOT[csa];	  notMisMatch: WORD = Inline.BITXOR[notCsa, bit];          TestOneMatch[csa, mismatch, count];          TestOneMatch[notCsa, notMisMatch, count];          csa ¬ csa + 1;	  ENDLOOP;        Put.Text[log, "!"L];        Process.Yield[];        IF UserInput.UserAbort[log] THEN EXIT;	ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    TestOneMatch: PROCEDURE [csa, mismatch, count: WORD] =    BEGIN    found: WORD;    hba: CARDINAL;    WriteCSA[csa];    WriteBits[hbSeeAllClocks];    WriteMatch[mismatch];    WriteCount[count];    KickClock[10];    found ¬ ReadCount[];    IF found # count THEN ERROR Mixup["Count changed while mismatched"L, count, found];    found ¬ HBDone[];    IF found # 0 THEN ERROR Mixup["Done while mismatched"L, 0, found];    hba ¬ ReadHBA[];    KickClock[10];    FOR i: CARDINAL IN [0..10) DO      KickClock[10];      IF hba # ReadHBA[] THEN EXIT;      REPEAT FINISHED => Mixup["HBA not changing"L, hba, hba];      ENDLOOP;    WriteCount[0FFH];    hba ¬ ReadHBA[];    KickClock[10];    found ¬ ReadHBA[];    IF found # hba THEN ERROR Mixup["HBA changed while count = FF (no match)"L, hba, found];    WriteMatch[csa];    KickClock[10];    found ¬ ReadHBA[];    IF found # hba THEN ERROR Mixup["HBA changed while count = FF (matched)"L, found, hba];    WriteCount[count];    KickClock[300];    found ¬ ReadCount[];    IF found # 0FFH THEN ERROR Mixup["Count not FF after match"L, 0FFH, found];    found ¬ ReadHBA[];    IF found # ByteAdd[hba, 0FFH-count] THEN ERROR Mixup["HBA didn't incr by count"L, ByteAdd[hba, 0FFH-count], found];    found ¬ HBDone[];    IF found # hbDone THEN ERROR Mixup["Done expected"L, hbDone, found];    END;    HB: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "HB["L];    Initialize[];    SetFinger[hbAddr];    Put.Number[log, ReadIOP[contents], [16, FALSE, TRUE, 0]];    Put.Text[log, "] is ... "L];    FOR i: CARDINAL IN [0..3) DO      temp: WORD ¬ ReadIOP[contents];      Put.Number[log, temp, [16, FALSE, TRUE, 3]];      ENDLOOP;    Put.Line[log, "."L];    END;      TestHB: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    found: WORD;    Put.Text[log, "Testing HB ... "L];    Initialize[];    WriteCount[0];  -- Avoid auto incr    Put.Line[log, "."L];    Put.Text[log, "Filling with 0s ... "L];    WriteCSA[0];    FOR hba: CARDINAL IN [0..sizeOfHB) DO      SetFinger[hbAddr];      WriteIOP[contents, hba];      WriteIOP[contents, 0];      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      ENDLOOP;    Put.Text[log, "checking ... "L];    SetFinger[hbAddr];    WriteIOP[contents, 0];    FOR hba: CARDINAL IN [0..sizeOfHB) DO      FOR i: CARDINAL IN [0..3) DO        found ¬ ReadIOP[contents];        IF found # 0 THEN Mixup["Didn't get a 0 back"L, 0, found];        ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      ENDLOOP;    found ¬ ReadHBA[];    IF found # 0 THEN ERROR Mixup["HBA didn't incr back to 0"L, 0, found];    Put.Line[log, "ok."L];    Put.Text[log, "Filling with 1s ... "L];    WriteCSA[0FFFFH];    FOR hba: CARDINAL IN [0..sizeOfHB) DO      SetFinger[hbAddr];      WriteIOP[contents, hba];      WriteIOP[contents, 0FFH];      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      ENDLOOP;    Put.Text[log, "checking ... "L];    SetFinger[hbAddr];    WriteIOP[contents, 0];    FOR hba: CARDINAL IN [0..sizeOfHB) DO      FOR i: CARDINAL IN [0..3) DO        found ¬ ReadIOP[contents];        IF found # 0FFH THEN Mixup["Didn't get a FF back"L, 0FFH, found];        ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      ENDLOOP;    found ¬ ReadHBA[];    IF found # 0 THEN ERROR Mixup["HBA didn't incr back to 0"L, 0, found];    Put.Line[log, "ok."L];    Put.Text[log, "Filling with addresses ... "L];    FOR hba: CARDINAL IN [0..sizeOfHB) DO      WriteCSA[hba*400B+hba];      SetFinger[hbAddr];      WriteIOP[contents, hba];      WriteIOP[contents, hba];      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      ENDLOOP;    Put.Text[log, "checking ... "L];    SetFinger[hbAddr];    WriteIOP[contents, 0];    FOR hba: CARDINAL IN [0..sizeOfHB) DO      FOR i: CARDINAL IN [0..3) DO        found ¬ ReadIOP[contents];        IF found # hba THEN Mixup["Didn't get address back"L, hba, found];        ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      ENDLOOP;    found ¬ ReadHBA[];    IF found # 0 THEN ERROR Mixup["HBA didn't incr back to 0"L, 0, found];    Put.Line[log, "ok."L];    Put.Line[log, "Yea!"L];    END;    WriteHB: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Writing HB ... "L];    Initialize[];    WriteCount[0];  -- Avoid auto incr    Put.Line[log, "."L];    DO      FOR hba: CARDINAL IN [0..sizeOfHB) DO	WriteCSA[0];	SetFinger[hbAddr];	WriteIOP[contents, hba];	WriteIOP[contents, 0];	WriteCSA[0FFFFH];	SetFinger[hbAddr];	WriteIOP[contents, hba];	WriteIOP[contents, 0FFH];	Process.Yield[];	IF UserInput.UserAbort[log] THEN EXIT;	ENDLOOP;      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    PrintMixup: PROCEDURE [s: STRING, expected, found: UNSPECIFIED] =    BEGIN    Put.Text[log, s];    Put.Text[log, "; expected: "L];    Put.Number[log, expected, [16, FALSE, TRUE, 0]];    Put.Text[log, ", found: "L];    Put.Number[log, found, [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    END;    HBDone: PROCEDURE RETURNS [done: WORD] =    BEGIN    RETURN[Inline.BITAND[ReadIOP[statusByte], hbDone]];    END;    SetFinger: PROCEDURE [reg: Register] =    BEGIN    found: Register;    WriteIOP[finger, LOOPHOLE[reg]];    found ¬ LOOPHOLE[ReadIOP[finger]];    IF found # reg THEN ERROR Mixup["Section/Reg readback didn't work"L, reg, found];    END;    WriteCSA: PROCEDURE [csa: CARDINAL] =    BEGIN    SetFinger[csaMsb];    WriteIOP[contents, Inline.HighByte[csa]];    WriteIOP[contents, Inline.LowByte[csa]];    END;    ReadCSA: PROCEDURE RETURNS [csa: CARDINAL] =    BEGIN    SetFinger[csaMsb];    WriteIOP[contents, Inline.HighByte[csa]];    WriteIOP[contents, Inline.LowByte[csa]];    END;    WriteBits: PROCEDURE [bits: Environment.Byte] =    BEGIN    SetFinger[hbBits];    WriteIOP[contents, bits];    END;    KickClock: PROCEDURE [n: CARDINAL] =    BEGIN    FOR i: CARDINAL IN [0..n) DO      WriteIOP[controlByte, singleStep+useRam+useCsa];      ENDLOOP;    END;    WriteMatch: PROCEDURE [match: CARDINAL] =    BEGIN    SetFinger[hbMatchMsb];    WriteIOP[contents, Inline.HighByte[match]];    WriteIOP[contents, Inline.LowByte[match]];    END;    WriteCount: PROCEDURE [count: Environment.Byte] =    BEGIN    SetFinger[hbCount];    WriteIOP[contents, count];    END;    ReadCount: PROCEDURE RETURNS [count: Environment.Byte] =    BEGIN    SetFinger[hbCount];    RETURN[ReadIOP[contents]];    END;    ReadHBA: PROCEDURE RETURNS [hba: Environment.Byte] =    BEGIN    SetFinger[hbAddr];    RETURN[ReadIOP[contents]];    END;    ByteAdd: PROCEDURE [a, b: Environment.Byte] RETURNS [Environment.Byte] =    BEGIN    RETURN[Inline.LowByte[a + b + 1]];    END;    form, log: Window.Handle ¬ NIL;  Init: PROCEDURE =    BEGIN    herald: STRING = [100];    String.AppendString[herald, "TestHistoryBuffer of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    [] ¬ Tool.Create[      name: herald, makeSWsProc: MakeSWs, clientTransition: ClientTransition];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    Tool.UnusedLogName[logFileName, "TestHistoryBuffer.log$"L];    log ¬ Tool.MakeFileSW[window: window, name: logFileName];    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 26;    i: INTEGER ¬ -1;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Status"L, proc: Status, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Section"L, proc: Section];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "NIA"L, proc: NIA];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "CSA"L, proc: CSA];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestHBReg"L, proc: TestHBReg, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestHBRegIncr"L, proc: TestHBRegIncr];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadWriteHBReg"L, proc: ReadWriteHBReg];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteHBReg"L, proc: WriteHBReg];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadHBReg"L, proc: ReadHBReg];        items[i¬i+1] ¬ FormSW.CommandItem[tag: "Bits"L, proc: Bits, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestBits"L, proc: TestBits];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Match"L, proc: Match, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestMatch"L, proc: TestMatch];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "SetMatch"L, proc: SetMatch];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ClearMatch"L, proc: ClearMatch];        items[i¬i+1] ¬ FormSW.CommandItem[tag: "HBA"L, proc: HBA, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestHBA"L, proc: TestHBA];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Count"L, proc: Count, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestCount"L, proc: TestCount];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadWriteCount"L, proc: ReadWriteCount];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "SpinCount"L, proc: SpinCount];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "KickCount"L, proc: KickCount];        items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestMatcher"L, proc: TestMatcher, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "HB"L, proc: HB, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestHB"L, proc: TestHB];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteHB"L, proc: WriteHB];        IF (i+1) # nParams THEN ERROR;    RETURN[items, TRUE];    END;  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN        END;      ENDCASE;    END;	  Init[];  END....
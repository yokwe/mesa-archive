-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- MakeControlStoreMB.mesa, HGM,  5-Oct-83  0:13:19-- MakeControlStoreMB.~ Out.mb ¬ In.fbDIRECTORY  Ascii USING [CR],  Environment USING [bytesPerWord],  Exec USING [    AddCommand, ExecProc, FreeTokenString, GetToken, Outcome, OutputProc],  Format USING [Line, StringProc],  Inline USING [BITXOR],  MFile USING [Acquire, dontRelease, Error, GetCreateDate, Handle, Release],  MStream USING [Create],  Stream USING [Delete, GetBlock, Handle, PutByte, PutString, PutWord],  String USING [AppendChar, AppendDecimal, AppendString, Empty, Equal],  Time USING [Append, Unpack],    CP USING [RealCS, sizeOfCS, wordsPerBank],  CPMI USING [MI],  MassFileFormat USING [FinalBinaryRec];MakeControlStoreMB: PROGRAM  IMPORTS Exec, Format, Inline, MFile, MStream, Stream, String, Time =  BEGIN  memoryName: STRING = "ControlStore";    sizeOfProm: CARDINAL = 4096;  -- 2732 = 4K x 8    check: CARDINAL [0..0] = CP.wordsPerBank-sizeOfProm;--  ControlStore.cm--  PNew ControlStore.mb/f ControlStore/m 0/t 0/b 0/c 0/a 0/s 8/s 16/s 24/s 32/s 40/s  MakeControlStoreMB: Exec.ExecProc =    BEGIN    fbrBytes: CARDINAL = Environment.bytesPerWord*SIZE[MassFileFormat.FinalBinaryRec];    b: POINTER = @fbr;    fbr: MassFileFormat.FinalBinaryRec ¬ TRASH;    pb: POINTER TO CPMI.MI = LOOPHOLE[@fbr.partialBinary];    offset: CARDINAL ¬ 0;  -- For second bank....    instructions: CARDINAL ¬ 0;    info: STRING = [100];    output: Format.StringProc = Exec.OutputProc[h];    outName, separater, inName, switches: LONG STRING ¬ NIL;    in, out: Stream.Handle ¬ NIL;    inFile, outFile: MFile.Handle;    Cleanup: PROC [s: STRING] =      BEGIN      IF s # NIL THEN Format.Line[output, s];      outName ¬ Exec.FreeTokenString[outName];      separater ¬ Exec.FreeTokenString[separater];      inName ¬ Exec.FreeTokenString[inName];      IF in # NIL THEN Stream.Delete[in];      IF out # NIL THEN Stream.Delete[out];      END;    [outName, switches] ¬ Exec.GetToken[h];    switches ¬ Exec.FreeTokenString[switches];    [separater, switches] ¬ Exec.GetToken[h];    switches ¬ Exec.FreeTokenString[switches];    [inName, switches] ¬ Exec.GetToken[h];    switches ¬ Exec.FreeTokenString[switches];    IF String.Empty[outName] THEN {      Cleanup["Output filename is empty."L]; RETURN[error]};    IF String.Empty[inName] THEN {      Cleanup["Input filename is empty."L]; RETURN[error]};    IF ~String.Equal[separater, "¬"L] THEN {      Cleanup["Separater must be ""¬""."L]; RETURN[error]};    inFile ¬ MFile.Acquire[      name: inName, access: readOnly, release: MFile.dontRelease !      MFile.Error =>        BEGIN Cleanup["Can't read Input File"L]; GOTO GetOutOfHere; END];    outFile ¬ MFile.Acquire[      name: outName, access: writeOnly, release: MFile.dontRelease !      MFile.Error =>        BEGIN        MFile.Release[inFile];        Cleanup["Can't write Output File"L];        GOTO GetOutOfHere;        END];    in ¬ MStream.Create[inFile, [NIL, NIL]];    out ¬ MStream.Create[outFile, [NIL, NIL]];    String.AppendString[info, inName];    String.AppendString[info, " of "L];    Time.Append[info, Time.Unpack[MFile.GetCreateDate[inFile].create]];    Stream.PutWord[out, 4]; -- 4 => define memory    Stream.PutWord[out, 2]; -- memory #    Stream.PutWord[out, 16];    Stream.PutString[out, info];  -- Asciz string    Stream.PutByte[out, 0];    IF (info.length MOD 2) = 0 THEN Stream.PutByte[out, 0];    Stream.PutWord[out, 4]; -- 4 => define memory    Stream.PutWord[out, 1]; -- only one memory    Stream.PutWord[out, SIZE[CPMI.MI]*16];    Stream.PutString[out, memoryName];  -- Asciz string    Stream.PutByte[out, 0];    IF (memoryName.length MOD 2) = 0 THEN Stream.PutByte[out, 0];    DO      bytes: CARDINAL;      [bytes, , ] ¬ Stream.GetBlock[          sH: in,          block: [            blockPointer: b,	    startIndex: 0,            stopIndexPlusOne: fbrBytes]];      IF bytes # fbrBytes THEN ERROR;      IF fbr.addr >= CP.sizeOfCS THEN EXIT;      fbr.addr ¬ fbr.addr + offset;      IF fbr.miNum = 0FFFFH THEN NULL  -- Setting a TPC      ELSE        BEGIN	addr: CP.RealCS ¬ fbr.addr + offset;	mi: CPMI.MI ¬ pb­;	p: POINTER ¬ @mi;	FixupMI[@mi];        Stream.PutWord[out, 2];  -- 2 => Set Current Memory        Stream.PutWord[out, 1];  -- only one memory        Stream.PutWord[out, addr];  -- location counter        Stream.PutWord[out, 1];  -- 1 => Memory Contents        Stream.PutWord[out, 0];  -- Source line number	FOR i: CARDINAL IN [0..SIZE[CPMI.MI]) DO          Stream.PutWord[out, (p+i)­];	  ENDLOOP;	instructions ¬ instructions + 1;        END;      ENDLOOP;    Stream.PutWord[out, 0];  -- 0 => End of file    BEGIN    temp: STRING = [200];    String.AppendString[temp, inName];    String.AppendString[temp, " contains "L];    String.AppendDecimal[temp, instructions];    String.AppendString[temp, " instructions."L];    String.AppendChar[temp, Ascii.CR];    Exec.OutputProc[h][temp];    END;    Cleanup[NIL];    RETURN[normal];    EXITS GetOutOfHere => RETURN[error];    END;  -- See also VirturalToReal in CPKernelCSDicentra  FixupMI: PROCEDURE [mi: POINTER TO CPMI.MI] =    BEGIN    p: POINTER = mi + 2;    p­ ¬ Inline.BITXOR[p­, 17B];  -- Low 4 bits of NIA are upside down    END;      Exec.AddCommand["MakeControlStoreMB.~", MakeControlStoreMB];  END...
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- TestDebuggerBoard.mesa, HGM, 12-Oct-83 21:23:59DIRECTORY  DLionInputOutput USING [IOPage, processorCommandOffset, processorCSBOffset],  Environment USING [Byte],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, newLine, NumberItem, ProcType],  Inline USING [BITAND, BytePair, HighByte, LowByte],  Process USING [MsecToTicks, Pause, Yield],  Put USING [Number, Text, Line],  Runtime USING [GetBcdTime],  String USING [AppendString],  System USING [GetClockPulses, MicrosecondsToPulses, Pulses],  Time USING [Append, Unpack],  Tool USING [    Create, MakeSWsProc, UnusedLogName, MakeFormSW, MakeFileSW],  ToolWindow USING [TransitionProcType],  UserInput USING [ReturnToNotifier, UserAbort],  Window USING [Handle];TestDebuggerBoard: PROGRAM  IMPORTS    DLionInputOutput, FormSW, Inline, Process, Put,    Runtime, String, System, Time, Tool, UserInput =  BEGIN  Timeout: ERROR [reason: LONG STRING] = CODE;  Mixup: ERROR [s: LONG STRING, expected, found: UNSPECIFIED] = CODE;  ProcessorCommand: TYPE = MACHINE DEPENDENT {    null(0), readIOPByte(5), writeIOPByte(6)};  pProcessorCommand: LONG POINTER TO ProcessorCommand = DLionInputOutput.IOPage + DLionInputOutput.processorCommandOffset;  ProcessorCSB: TYPE = MACHINE DEPENDENT RECORD [    data2(0): WORD,    data1(1): WORD,      data0(2): WORD];  pProcessorCSB: LONG POINTER TO ProcessorCSB = DLionInputOutput.IOPage + DLionInputOutput.processorCSBOffset;    baseAddress: WORD = 100200B;  -- Hex 8080  controlByte: WORD = baseAddress + 0;    run: WORD = 0;    boot: WORD = 1B;    useCsa: WORD = 2B;    useRam: WORD = 4B;    singleStep: WORD = 20B;    stop: WORD = 100B;    running: WORD = 100B;  statusByte: WORD = baseAddress + 0;    cycle1: WORD = 4B;    cycle2: WORD = 2B;    cycle3: WORD = 1B;    bufferFromCpFull: WORD = 10B;    bufferToCpFull: WORD = 20B;    hbDone: WORD = 40B;  cpData: WORD = baseAddress + 1;  finger: WORD = baseAddress + 2;  contents: WORD = baseAddress + 3;  Register: TYPE = MACHINE DEPENDENT {    -- Control Store section starts at 0    csaMsb(0B), csaLsb(1B),    csData0(2B), csData1(3B), csData2(4B), csData3(5B), csData4(6B), csData5(7B),    niaMsb(10B), niaLsb(11B),    temp(12B),    -- History Buffer section starts at 20B    hbAddr(20B),    hbPCMsb(21B), hbPCLsb(22B), hbPCExtra(23B),    hbMatchMsb(24B), hbMatchLsb(25B),    hbCount(26B), hbStatusControl(27B),    (0FFH) };  sizeOfCS: CARDINAL = 4096;    csa: CARDINAL ¬ 0;  ReadIOP: PROCEDURE [address: CARDINAL] RETURNS [Environment.Byte] =    BEGIN    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ address;    pProcessorCommand­ ¬ readIOPByte;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    RETURN[Inline.LowByte[pProcessorCSB.data1]];    END;  WriteIOP: PROCEDURE [address: CARDINAL, data: Environment.Byte] =    BEGIN    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ address;    pProcessorCSB.data1 ¬ data;    pProcessorCommand­ ¬ writeIOPByte;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    END;  ReadCPReady: PROCEDURE RETURNS [BOOLEAN] =    BEGIN    temp: WORD ¬ ReadIOP[statusByte];    RETURN[Inline.BITAND[temp, bufferFromCpFull] = bufferFromCpFull];    END;    ReadCPByte: PROCEDURE RETURNS [data: Environment.Byte] =    BEGIN    temp: WORD;    FOR i: CARDINAL IN [0..250) DO  -- 1/2 second      temp ¬ ReadIOP[statusByte];      IF Inline.BITAND[temp, bufferFromCpFull] = bufferFromCpFull THEN EXIT;      REPEAT FINISHED => ERROR Timeout["Timeout reading byte from CP"L];      ENDLOOP;    data ¬ Inline.LowByte[ReadIOP[cpData]];    END;    WriteCPByte: PROCEDURE [data: Environment.Byte] =    BEGIN    temp: WORD;    WriteIOP[cpData, data];    FOR i: CARDINAL IN [0..250) DO  -- 1/2 second      temp ¬ ReadIOP[statusByte];      IF Inline.BITAND[temp, bufferToCpFull] = 0 THEN EXIT;      REPEAT FINISHED => ERROR Timeout["Timeout writing byte to CP"L];      ENDLOOP;    END;      Initialize: PROCEDURE =    BEGIN    temp: WORD;    temp ¬ ReadIOP[statusByte];    IF temp = 0 THEN DebuggerBoardNotResponding[]; -- c1, c2, or c3 should be on    IF temp = 0FFH THEN DebuggerBoardNotResponding[];  -- high bit wired to GND    WriteIOP[controlByte, stop+useRam];  -- Take control    temp ¬ ReadIOP[statusByte];    IF Inline.BITAND[temp, running] # 0 THEN DebuggerBoardNotResponding[];  -- Stop didn't read back    IF Inline.BITAND[temp, 7B] = 0 THEN DebuggerBoardNotResponding[];  -- DLion Umbilical does this    END;    DebuggerBoardNotResponding: PROCEDURE =    BEGIN    Put.Line[NIL, "Debugger board not Responding.."L];    ERROR UserInput.ReturnToNotifier[NIL];    END;  SwitchToRom: PROCEDURE =    BEGIN    WriteIOP[controlByte, useCsa+stop]; -- Turn off useRam    END;      Status: FormSW.ProcType =    BEGIN    Put.Text[log, "Status byte is ... "L];    FOR i: CARDINAL IN [0..5) DO      temp: WORD ¬ ReadIOP[statusByte];      Put.Number[log, temp, [16, FALSE, TRUE, 3]];      ENDLOOP;    Put.Line[log, "."L];    END;  ReadStatus: FormSW.ProcType =    BEGIN    DoIt: PROCEDURE =      BEGIN      [] ¬ ReadIOP[statusByte];      [] ¬ ReadIOP[statusByte];      END;    Put.Text[log, "Reading Status register ... "L];    DoUntilStop[DoIt];    Put.Line[log, "ok."L];    END;  WriteControl: FormSW.ProcType =    BEGIN    DoIt: PROCEDURE =      BEGIN      WriteIOP[controlByte, 0];      WriteIOP[controlByte, 0FFH];      END;    Put.Text[log, "Writing Control register ... "L];    DoUntilStop[DoIt];    Put.Line[log, "ok."L];    END;         ManyInit: FormSW.ProcType =    BEGIN    DoIt: PROCEDURE =      BEGIN      [] ¬ ReadIOP[statusByte];      WriteIOP[controlByte, stop+useRam];      [] ¬ ReadIOP[statusByte];      Process.Pause[1];      END;    Put.Text[log, "Flapping Init stuff ... "L];    DoUntilStop[DoIt];    Put.Line[log, "ok."L];    END;  FlapBoot: FormSW.ProcType =    BEGIN    Put.Text[log, "Flapping Boot Line ... "L];    DO      Initialize[];      WriteIOP[controlByte, useRam+boot];      Spin[1];      WriteIOP[controlByte, useRam+run];      Spin[1];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    Spin: PROCEDURE [ms: CARDINAL] =    BEGIN    start: System.Pulses ¬ System.GetClockPulses[];    delta: System.Pulses ¬ System.MicrosecondsToPulses[ms*1000];    UNTIL System.GetClockPulses[] > (start + delta) DO ENDLOOP;    END;          	  BootDebugee: FormSW.ProcType =    BEGIN    Put.Text[log, "Booting Debugee ... "L];    Initialize[];    WriteIOP[controlByte, useRam+useCsa+boot];    Process.Pause[Process.MsecToTicks[100]];    WriteIOP[controlByte, useRam];    Put.Line[log, "ok."L];    END;    Section: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Section byte is ... "L];    Initialize[];    FOR i: CARDINAL IN [0..5) DO      temp: WORD ¬ ReadIOP[finger];      Put.Number[log, temp, [16, FALSE, TRUE, 2]];      ENDLOOP;    Put.Line[log, "."L];    END;         TestSection: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Testing Section Register ... "L];    Initialize[];    DO      FOR i: CARDINAL IN [0..100) DO        found: WORD;        WriteIOP[finger, 0];        found ¬ ReadIOP[finger];        IF Inline.BITAND[found, 360B] # 0 THEN ERROR Mixup["Section Register readback mixup"L, 0, found];        WriteIOP[finger, 360B];        found ¬ ReadIOP[finger];        IF Inline.BITAND[found, 360B] # 360B THEN ERROR Mixup["Section Register readback mixup"L, 360B, found];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    ReadWriteSection: FormSW.ProcType =    BEGIN    DoIt: PROCEDURE =      BEGIN      WriteIOP[finger, 0];      [] ¬ ReadIOP[finger];      WriteIOP[finger, 360B];      [] ¬ ReadIOP[finger];      END;    Put.Text[log, "Reading and Writing Section Register ... "L];    Initialize[];    DoUntilStop[DoIt];    Put.Line[log, "ok."L];    END;    WriteSection: FormSW.ProcType =    BEGIN    DoIt: PROCEDURE =      BEGIN      WriteIOP[finger, 0];      WriteIOP[finger, 360B];      END;    Put.Text[log, "Writing Section Register ... "L];    Initialize[];    DoUntilStop[DoIt];    Put.Line[log, "ok."L];    END;    ReadSection: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    DoIt: PROCEDURE =      BEGIN      [] ¬ ReadIOP[finger];      [] ¬ ReadIOP[finger];      END;    Put.Text[log, "Reading Section Register ... "L];    Initialize[];    DoUntilStop[DoIt];    Put.Line[log, "ok."L];    END;      TestCSReg: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Testing CSReg ... "L];    Initialize[];    WriteIOP[finger, 0];    DO      FOR i: CARDINAL IN [0..100) DO        found: WORD;        WriteIOP[finger, 0];        found ¬ ReadIOP[finger];        IF found # 0 THEN ERROR Mixup["CSReg readback mixup"L, 0, found];        WriteIOP[finger, 17B];        found ¬ ReadIOP[finger];        IF found # 17B THEN ERROR Mixup["CSReg readback mixup"L, 17B, found];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    TestCSRegIncr: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Testing CSReg Incr ... "L];    Initialize[];    DO      FOR i: CARDINAL IN [0..20) DO        TestIncr[csaMsb, csaLsb];        TestIncr[csaLsb, csData0];        TestIncr[csData0, csData1];        TestIncr[csData1, csData2];        TestIncr[csData2, csData3];        TestIncr[csData3, csData4];        TestIncr[csData4, csData5];        TestIncr[csData5, csaMsb];        TestIncr[niaMsb, niaLsb];        TestIncr[niaLsb, temp];        TestIncr[temp, temp];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    TestIncr: PROCEDURE [reg, bumpedReg: Register] =    BEGIN    found: Register;    WriteIOP[finger, LOOPHOLE[reg]];    found ¬ LOOPHOLE[ReadIOP[finger]];    IF found # reg THEN ERROR Mixup["CSReg readback mixup"L, reg, found];    [] ¬ ReadIOP[contents];    found ¬ LOOPHOLE[ReadIOP[finger]];    IF found # bumpedReg THEN ERROR Mixup["CSReg incr mixup after read"L, bumpedReg, found];    WriteIOP[finger, LOOPHOLE[reg]];    found ¬ LOOPHOLE[ReadIOP[finger]];    IF found # reg THEN ERROR Mixup["CSReg readback mixup"L, reg, found];    WriteIOP[contents, 0];    found ¬ LOOPHOLE[ReadIOP[finger]];    IF found # bumpedReg THEN ERROR Mixup["CSReg incr mixup after write"L, bumpedReg, found];    END;    ReadWriteCSReg: FormSW.ProcType =    BEGIN    DoIt: PROCEDURE =      BEGIN      WriteIOP[finger, 0];      [] ¬ ReadIOP[finger];      WriteIOP[finger, 17B];      [] ¬ ReadIOP[finger];      END;    Put.Text[log, "Reading and Writing CSReg ... "L];    Initialize[];    DoUntilStop[DoIt];    Put.Line[log, "ok."L];    END;    WriteCSReg: FormSW.ProcType =    BEGIN    DoIt: PROCEDURE =      BEGIN      WriteIOP[finger, 0];      WriteIOP[finger, 17B];      END;    Put.Text[log, "Writing CSReg ... "L];    Initialize[];    DoUntilStop[DoIt];    Put.Line[log, "ok."L];    END;    ReadCSReg: FormSW.ProcType =    BEGIN    DoIt: PROCEDURE =      BEGIN      [] ¬ ReadIOP[finger];      [] ¬ ReadIOP[finger];      END;    Put.Text[log, "Reading CSReg ... "L];    Initialize[];    DoUntilStop[DoIt];    Put.Line[log, "ok."L];    END;    Temp: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Temp byte is ... "L];    Initialize[];    SetFinger[temp];    FOR i: CARDINAL IN [0..5) DO      temp: WORD ¬ ReadIOP[contents];      IF i # 0 THEN Put.Text[log, ", "L];      Put.Number[log, temp, [16, FALSE, TRUE, 0]];      ENDLOOP;    Put.Line[log, "."L];    END;  TestTemp: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Testing Temp (with 0 and FF) ... "L];    Initialize[];    SetFinger[temp];    DO      FOR i: CARDINAL IN [0..100) DO        found: WORD;        WriteIOP[contents, 0];        found ¬ ReadIOP[contents];        IF found # 0 THEN ERROR Mixup["Temp readback mixup"L, 0, found];        WriteIOP[contents, 0FFH];        found ¬ ReadIOP[contents];        IF found # 0FFH THEN ERROR Mixup["Temp readback mixup"L, 0FFH, found];        Process.Yield[];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    TestTempRipple: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Testing Temp (with [0..256)) ... "L];    Initialize[];    SetFinger[temp];    DO      FOR i: CARDINAL IN [0..256) DO        found: WORD;        WriteIOP[contents, i];        found ¬ ReadIOP[contents];        IF found # i THEN ERROR Mixup["Temp readback mixup"L, i, found];        Process.Yield[];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;    ReadWriteTemp: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Reading and Writing Temp ... "L];    Initialize[];    DO      SetFinger[temp];      FOR i: CARDINAL IN [0..100) DO        WriteIOP[contents, 0];        [] ¬ ReadIOP[contents];        WriteIOP[contents, 0FFH];        [] ¬ ReadIOP[contents];	ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    WriteTemp: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Writing Temp ... "L];    Initialize[];    DO      SetFinger[temp];      FOR i: CARDINAL IN [0..100) DO        WriteIOP[contents, 0];        WriteIOP[contents, 0FFH];	ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    ReadTemp: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Reading Temp ... "L];    Initialize[];    DO      SetFinger[temp];      FOR i: CARDINAL IN [0..100) DO        [] ¬ ReadIOP[contents];        [] ¬ ReadIOP[contents];	ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;      NIA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    nia: WORD;    Put.Text[log, "NIA is "L];    Initialize[];    WriteIOP[controlByte, stop+useRam];    SetFinger[niaMsb];    nia ¬ ReadIOP[contents] * 400B;    nia ¬ nia + ReadIOP[contents];    Put.Number[log, nia, [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    END;      ReadNIA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Reading NIA ... "L];    Initialize[];    DO      FOR i: CARDINAL IN [0..100) DO        SetFinger[niaMsb];        [] ¬ ReadIOP[contents];        [] ¬ ReadIOP[contents];	ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;      CSA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    csa: WORD;    Put.Text[log, "CSA is "L];    Initialize[];    SetFinger[csaMsb];    csa ¬ ReadIOP[contents] * 400B;    csa ¬ csa + ReadIOP[contents];    Put.Number[log, csa, [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    END;      TestCSA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Testing CSA ... "L];    Initialize[];    DO      FOR i: CARDINAL IN [0..20) DO        found: WORD;	temp: Register;	        SetFinger[csaMsb];        WriteIOP[contents, 0];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # csaLsb THEN Mixup["CSReg didn't incr writing csaMsb"L, Register[csaLsb], temp];        WriteIOP[contents, 0];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # csData0 THEN Mixup["CSReg didn't incr writing csaLsb"L, Register[csData0], temp];        SetFinger[csaMsb];        found ¬ ReadIOP[contents];	IF found # 0 THEN Mixup["csaMsb picked bits"L, 0, found];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # csaLsb THEN Mixup["CSReg didn't incr reading csaMsb"L, Register[csaLsb], temp];        found ¬ ReadIOP[contents];	IF found # 0 THEN Mixup["csaLsb picked bits"L, 0, found];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # csData0 THEN Mixup["CSReg didn't incr reading csaLsb"L, Register[csData0], temp];        SetFinger[csData5];        WriteIOP[contents, i];  -- Write should bump CSA from 0 to 1        SetFinger[csaMsb];        found ¬ ReadIOP[contents];	IF found # 0 THEN Mixup["csaMsb changed"L, 0, found];        found ¬ ReadIOP[contents];	IF found # 1 THEN Mixup["csaLsb didn't incr"L, 1, found];	        SetFinger[csaMsb];        WriteIOP[contents, 0FFH];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # csaLsb THEN Mixup["CSReg didn't incr writing csaMsb"L, Register[csaLsb], temp];        WriteIOP[contents, 0FFH];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # csData0 THEN Mixup["CSReg didn't incr writing csaLsb"L, Register[csData0], temp];        SetFinger[csaMsb];        found ¬ ReadIOP[contents];	IF found # 0FFH THEN Mixup["csaMsb dropped bits"L, 0FFH, found];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # csaLsb THEN Mixup["CSReg didn't incr reading csaMsb"L, Register[csaLsb], temp];        found ¬ ReadIOP[contents];	IF found # 0FFH THEN Mixup["csaLsb dropped bits"L, 0FFH, found];        temp ¬ LOOPHOLE[ReadIOP[finger]];	IF temp # csData0 THEN Mixup["CSReg didn't incr reading csaLsb"L, Register[csData0], temp];        SetFinger[csData5];        [] ¬ ReadIOP[contents];  -- Read should bump CSA from 0FFFFH to 0        SetFinger[csaMsb];        found ¬ ReadIOP[contents];	IF found # 0 THEN Mixup["csaMsb didn't incr"L, 0, found];        found ¬ ReadIOP[contents];	IF found # 0 THEN Mixup["csaLsb didn't incr"L, 0, found];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;  TestCSARipple: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    cs: CARDINAL ¬ 0;    Put.Text[log, "Testing CSA (Ripple mode)... "L];    Initialize[];    DO      FOR i: CARDINAL IN [0..0FFH) DO        found: WORD;        SetCSAddr[cs];        found ¬ GetCSAddr[];        IF found # cs THEN Mixup["CSA didn't readback right"L, cs, found];	cs ¬ cs + 1;	IF cs = 0 THEN Put.Line[log, "Wow."L];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " ok."L];    END;  WriteCSA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Writing CSA ... "L];    Initialize[];    DO      FOR i: CARDINAL IN [0..100) DO        SetFinger[csaMsb];        WriteIOP[contents, 0];        WriteIOP[contents, 0];        SetFinger[csaMsb];        WriteIOP[contents, 0FFH];        WriteIOP[contents, 0FFH];	ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;      ReadCSA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Reading CSA ... "L];    Initialize[];    DO      FOR i: CARDINAL IN [0..100) DO        SetFinger[csaMsb];        [] ¬ ReadIOP[contents];        [] ¬ ReadIOP[contents];	ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;      IncrCSA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Incrementing CSA ... "L];    Initialize[];    DO      FOR i: CARDINAL IN [0..100) DO        SetFinger[csData5];        [] ¬ ReadIOP[contents];        SetFinger[csData5];        WriteIOP[contents, i];	ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;      SetCSA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Setting CSA to "L];    Put.Number[log, csa, [16, FALSE, TRUE, 0]];    Initialize[];    SetFinger[csaMsb];    WriteIOP[contents, Inline.HighByte[csa]];    WriteIOP[contents, Inline.LowByte[csa]];    Put.Line[log, "."L];    END;  SendCPData: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Timeout => BEGIN Put.Text[log, reason]; Put.Line[log, "."L]; CONTINUE; END;      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Echoing to CP (hope you loaded it).. "L];    [] ¬ Inline.LowByte[ReadIOP[cpData]];    DO      FOR i: CARDINAL IN [0..400B) DO        found: WORD;        WriteIOP[cpData, i];        found ¬ Inline.LowByte[ReadIOP[cpData]];	ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "."L];    END;      Echo: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Timeout => BEGIN Put.Text[log, reason]; Put.Line[log, "."L]; CONTINUE; END;      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Echoing to CP (hope you loaded it).. "L];    [] ¬ Inline.LowByte[ReadIOP[cpData]];    DO      FOR i: CARDINAL IN [0..400B) DO        found: WORD;	WriteCPByte[i];	found ¬ ReadCPByte[];	IF found # i THEN Mixup["Didn't get expected byte back"L, i, found];	ENDLOOP;      Put.Text[log, "!"L];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "."L];    END;      FlapStop: FormSW.ProcType =    BEGIN    DoIt: PROCEDURE =      BEGIN      WriteIOP[controlByte, stop+useRam];      WriteIOP[controlByte, run+useRam];      END;    Put.Text[log, "Flapping Stop.. "L];    DoUntilStop[DoIt, 100];    Put.Line[log, "."L];    END;      PokeCount: FormSW.ProcType =    BEGIN    DoIt: PROCEDURE =      BEGIN      WriteIOP[controlByte, stop+useRam];      WriteIOP[finger, LOOPHOLE[Register[hbCount]]];      WriteIOP[contents, 2];      WriteIOP[controlByte, useRam];      END;    Put.Text[log, "Poking Count (while Stopped).. "L];    DoUntilStop[DoIt, 100];    Put.Line[log, "."L];    END;      PokeMatch: FormSW.ProcType =    BEGIN    DoIt: PROCEDURE =      BEGIN      WriteIOP[controlByte, stop+useRam];      WriteIOP[finger, LOOPHOLE[Register[hbMatchMsb]]];      WriteIOP[contents, 0];      WriteIOP[contents, 0FFH];      WriteIOP[controlByte, useRam];      END;    Put.Text[log, "Poking Match (while Stopped).. "L];    DoUntilStop[DoIt, 100];    Put.Line[log, "."L];    END;      CSRam: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    csa: WORD;    Put.Text[log, "CS(ram)["L];    Initialize[];    SetFinger[csaMsb];    csa ¬ ReadIOP[contents] * 400B;    csa ¬ csa + ReadIOP[contents];    Put.Number[log, csa, [16, FALSE, TRUE, 0]];    Put.Text[log, "] is ... "L];    FOR i: CARDINAL IN [0..6) DO      temp: WORD ¬ ReadIOP[contents];      Put.Number[log, temp, [16, FALSE, TRUE, 3]];      ENDLOOP;    Put.Line[log, "."L];    END;    CSRom: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    csa: WORD;    Put.Text[log, "CS(rom)["L];    Initialize[];    SwitchToRom[];    SetFinger[csaMsb];    csa ¬ ReadIOP[contents] * 400B;    csa ¬ csa + ReadIOP[contents];    Put.Number[log, csa, [16, FALSE, TRUE, 0]];    Put.Text[log, "] is ... "L];    FOR i: CARDINAL IN [0..6) DO      temp: WORD ¬ ReadIOP[contents];      Put.Number[log, temp, [16, FALSE, TRUE, 3]];      ENDLOOP;    Put.Line[log, "."L];    END;        TestCS: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    found: WORD;    Put.Text[log, "Testing CS (first 4K) ... "L];    Initialize[];    WriteIOP[controlByte, stop+useRam+useCsa];    WriteIOP[finger, 0];    Put.Line[log, "."L];    Put.Text[log, "Checking first word ... "L];    SetCSAddr[0];    FOR i: CARDINAL IN [0..6) DO      WriteIOP[contents, i];      found ¬ ReadIOP[finger];      SELECT i FROM        IN [0..5) => IF found # (i + 3) THEN Mixup["Register didn't incr on on write"L, i+3, found];        5 => IF found # 0 THEN Mixup["Register didn't wrap on on write"L, 0, found];	ENDCASE => ERROR;      ENDLOOP;    found ¬ GetCSAddr[];    IF found # 1 THEN Mixup["CSAddr didn't incr to 1 on write"L, 1, found];    SetCSAddr[0];    FOR i: CARDINAL IN [0..6) DO      found ¬ ReadIOP[contents];      IF found # i THEN Mixup["Didn't get byte offset back"L, i, found];      found ¬ ReadIOP[finger];      SELECT i FROM        IN [0..5) => IF found # (i + 3) THEN Mixup["Register didn't incr on on read"L, i+3, found];        5 => IF found # 0 THEN Mixup["Register didn't wrap on on read"L, 0, found];	ENDCASE => ERROR;      ENDLOOP;    found ¬ GetCSAddr[];    IF found # 1 THEN Mixup["CSAddr didn't incr to 1 on read"L, 1, found];    Put.Line[log, "ok."L];    Put.Text[log, "Filling with 0s ... "L];    FOR cs: CARDINAL IN [0..sizeOfCS) DO      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      SetCSAddr[cs];      FOR i: CARDINAL IN [0..6) DO WriteIOP[contents, 0]; ENDLOOP;      ENDLOOP;    found ¬ GetCSAddr[];    IF found # sizeOfCS THEN  Mixup["CS Addr didn't incr right"L, sizeOfCS, found];    Put.Text[log, "checking ... "L];    FOR cs: CARDINAL IN [0..sizeOfCS) DO      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      SetCSAddr[cs];      FOR i: CARDINAL IN [0..6) DO        found ¬ ReadIOP[contents];        IF found # 0 THEN Mixup["Didn't get a 0 back"L, 0, found];        ENDLOOP;      ENDLOOP;    found ¬ GetCSAddr[];    IF found # sizeOfCS THEN  Mixup["CS Addr didn't incr right"L, sizeOfCS, found];    Put.Line[log, "ok."L];    Put.Text[log, "Filling with 1s ... "L];    FOR cs: CARDINAL IN [0..sizeOfCS) DO      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      SetCSAddr[cs];      FOR i: CARDINAL IN [0..6) DO WriteIOP[contents, 0FFH]; ENDLOOP;      ENDLOOP;    found ¬ GetCSAddr[];    IF found # sizeOfCS THEN  Mixup["CS Addr didn't incr right"L, sizeOfCS, found];    Put.Text[log, "checking ... "L];    FOR cs: CARDINAL IN [0..sizeOfCS) DO      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      SetCSAddr[cs];      FOR i: CARDINAL IN [0..6) DO        found ¬ ReadIOP[contents];        IF found # 0FFH THEN Mixup["Didn't get a 0FFH back"L, 0FFH, found];        ENDLOOP;      ENDLOOP;    found ¬ GetCSAddr[];    IF found # sizeOfCS THEN  Mixup["CS Addr didn't incr right"L, sizeOfCS, found];    Put.Line[log, "ok."L];    Put.Text[log, "Filling with addresses ... "L];    FOR cs: CARDINAL IN [0..sizeOfCS) DO      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      SetCSAddr[cs];      FOR i: CARDINAL IN [0..6/2) DO        WriteIOP[contents, Inline.HighByte[cs]];        WriteIOP[contents, Inline.LowByte[cs]];        ENDLOOP;      ENDLOOP;    found ¬ GetCSAddr[];    IF found # sizeOfCS THEN  Mixup["CS Addr didn't incr right"L, sizeOfCS, found];    Put.Text[log, "checking ... "L];    FOR cs: CARDINAL IN [0..sizeOfCS) DO      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      SetCSAddr[cs];      FOR i: CARDINAL IN [0..6/2) DO        found ¬ ReadIOP[contents];        IF found # Inline.HighByte[cs] THEN Mixup["Didn't get a address(msb) back"L, Inline.HighByte[cs], found];        found ¬ ReadIOP[contents];        IF found # Inline.LowByte[cs] THEN Mixup["Didn't get a address(lsb) back"L, Inline.LowByte[cs], found];        ENDLOOP;      ENDLOOP;    found ¬ GetCSAddr[];    IF found # sizeOfCS THEN  Mixup["CS Addr didn't incr right"L, sizeOfCS, found];    Put.Line[log, "ok."L];    Put.Line[log, "Yea!"L];    END;    WriteCS: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Writing CS ... "L];    Initialize[];    WriteIOP[controlByte, stop+useRam+useCsa];    WriteIOP[finger, 0];    DO      FOR i: CARDINAL IN [0..100) DO        SetFinger[csaMsb];	FOR k: CARDINAL IN [0..8) DO  -- 2 bytes of address, 6 for a micro instruction          WriteIOP[contents, 0];	  ENDLOOP;        SetFinger[csaMsb];	FOR k: CARDINAL IN [0..8) DO          WriteIOP[contents, 0FFH];	  ENDLOOP;        Process.Yield[];	ENDLOOP;      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    ClearCS: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    found: WORD;    Put.Text[log, "Clearing CS ... "L];    Initialize[];    SetFinger[csaMsb];    WriteIOP[contents, 0];  -- CSA Msb    WriteIOP[contents, 0];  -- CSA Lsb    SetFinger[csaMsb];    FOR cs: CARDINAL IN [0..sizeOfCS) DO      found ¬ ReadIOP[contents];      IF found # Inline.HighByte[cs] THEN ERROR Mixup["csaMsb mixup"L, Inline.HighByte[cs], found];      found ¬ ReadIOP[contents];      IF found # Inline.LowByte[cs] THEN ERROR Mixup["csaLsb mixup"L, Inline.LowByte[cs], found];      FOR k: CARDINAL IN [0..6) DO        WriteIOP[contents, 0];        ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    SetCS: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    found: WORD;    Put.Text[log, "Setting CS ... "L];    Initialize[];    SetFinger[csaMsb];    WriteIOP[contents, 0];  -- CSA Msb    WriteIOP[contents, 0];  -- CSA Lsb    SetFinger[csaMsb];    FOR cs: CARDINAL IN [0..sizeOfCS) DO      found ¬ ReadIOP[contents];      IF found # Inline.HighByte[cs] THEN ERROR Mixup["csaMsb mixup"L, Inline.HighByte[cs], found];      found ¬ ReadIOP[contents];      IF found # Inline.LowByte[cs] THEN ERROR Mixup["csaLsb mixup"L, Inline.LowByte[cs], found];      FOR k: CARDINAL IN [0..6) DO        WriteIOP[contents, 0FFH];        ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    ReadCS: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    Put.Text[log, "Reading CS ... "L];    Initialize[];    WriteIOP[controlByte, stop+useRam+useCsa];    DO      FOR cs: CARDINAL IN [0..sizeOfCS) DO        SetFinger[csaMsb];        WriteIOP[contents, Inline.HighByte[cs]];        WriteIOP[contents, Inline.LowByte[cs]];	FOR k: CARDINAL IN [0..6) DO          [] ¬ ReadIOP[contents];	  ENDLOOP;        Process.Yield[];        IF UserInput.UserAbort[log] THEN EXIT;	ENDLOOP;      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;         DoUntilStop: PROCEDURE [proc: PROCEDURE, bangs: CARDINAL ¬ LAST[CARDINAL]] =    BEGIN    ENABLE      BEGIN      Timeout => BEGIN Put.Text[log, reason]; Put.Line[log, "."L]; CONTINUE; END;      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      END;    DO      FOR i: CARDINAL IN [0..bangs) DO        proc[];        Process.Yield[];        IF UserInput.UserAbort[log] THEN RETURN;	ENDLOOP;      IF bangs # LAST[CARDINAL] THEN Put.Text[log, "!"L];      ENDLOOP;    END;  PrintMixup: PROCEDURE [s: LONG STRING, expected, found: UNSPECIFIED] =    BEGIN    Put.Text[log, s];    Put.Text[log, "; expected: "L];    Put.Number[log, expected, [16, FALSE, TRUE, 0]];    Put.Text[log, ", found: "L];    Put.Number[log, found, [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    END;    SetFinger: PROCEDURE [reg: Register] =    BEGIN    found: Register;    WriteIOP[finger, LOOPHOLE[reg]];    found ¬ LOOPHOLE[ReadIOP[finger]];    IF found # reg THEN ERROR Mixup["Section/Reg readback didn't work"L, reg, found];    END;  SetCSAddr: PROCEDURE [cs: CARDINAL] =    BEGIN    SetFinger[csaMsb];    WriteIOP[contents, Inline.HighByte[cs]];    WriteIOP[contents, Inline.LowByte[cs]];    END;    GetCSAddr: PROCEDURE RETURNS [cs: CARDINAL] =    BEGIN    bytes: Inline.BytePair;    SetFinger[csaMsb];    bytes.high ¬ ReadIOP[contents];    bytes.low ¬ ReadIOP[contents];    RETURN[LOOPHOLE[bytes]];    END;    form, log: Window.Handle ¬ NIL;  Init: PROCEDURE =    BEGIN    herald: STRING = [100];    String.AppendString[herald, "TestDebuggerBoard of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    [] ¬ Tool.Create[name: herald, makeSWsProc: MakeSWs, clientTransition: ClientTransition];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    Tool.UnusedLogName[logFileName, "TestDebuggerBoard.log$"L];    log ¬ Tool.MakeFileSW[window: window, name: logFileName];    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 44;    i: INTEGER ¬ -1;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Status"L, proc: Status, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadStatus"L, proc: ReadStatus];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteControl"L, proc: WriteControl];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ManyInit"L, proc: ManyInit];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "FlapBoot"L, proc: FlapBoot];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "BootDebugee"L, proc: BootDebugee];        items[i¬i+1] ¬ FormSW.CommandItem[tag: "Section"L, proc: Section, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestSection"L, proc: TestSection];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadWriteSection"L, proc: ReadWriteSection];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteSection"L, proc: WriteSection];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadSection"L, proc: ReadSection];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestCSReg"L, proc: TestCSReg, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestCSRegIncr"L, proc: TestCSRegIncr];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadWriteCSReg"L, proc: ReadWriteCSReg];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteCSReg"L, proc: WriteCSReg];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadCSReg"L, proc: ReadCSReg];        items[i¬i+1] ¬ FormSW.CommandItem[tag: "Temp"L, proc: Temp, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestTemp"L, proc: TestTemp];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestTempRipple"L, proc: TestTempRipple];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadWriteTemp"L, proc: ReadWriteTemp];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteTemp"L, proc: WriteTemp];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadTemp"L, proc: ReadTemp];        items[i¬i+1] ¬ FormSW.CommandItem[tag: "NIA"L, proc: NIA, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadNIA"L, proc: ReadNIA];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "CSA"L, proc: CSA, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestCSA"L, proc: TestCSA];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestCSARipple"L, proc: TestCSARipple];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteCSA"L, proc: WriteCSA];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadCSA"L, proc: ReadCSA];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "IncrCSA"L, proc: IncrCSA];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "SetCSA"L, proc: SetCSA, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.NumberItem[tag: "CSA"L, notNegative: TRUE, radix: octal, value: @csa];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "SendCPData"L, proc: SendCPData, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Echo"L, proc: Echo];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "FlapStop"L, proc: FlapStop];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "PokeCount"L, proc: PokeCount];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "PokeMatch"L, proc: PokeMatch];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "CSRam"L, proc: CSRam, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "CSRom"L, proc: CSRom];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestCS"L, proc: TestCS];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteCS"L, proc: WriteCS];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ClearCS"L, proc: ClearCS];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "SetCS"L, proc: SetCS];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadCS"L, proc: ReadCS];    IF (i+1) # nParams THEN ERROR;    RETURN[items, TRUE];    END;  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN        END;      ENDCASE;    END;	  Init[];  END....
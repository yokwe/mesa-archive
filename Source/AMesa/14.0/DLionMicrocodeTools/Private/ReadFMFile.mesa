-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- ReadFMFile.mesa-- Created by DEG     .PA @ 14-Feb-83 15:09:49-- Last Edit by DEG     .PA @ 26-Sep-84 23:17:48DIRECTORY  Environment USING [charsPerWord],  Exec USING [AddCommand, ExecProc, FreeTokenString, GetToken, OutputProc],  Format USING [Char, Number, StringProc, Text],  MFile USING [ReadOnly],  MSegment USING [Address, Create, Delete, Handle],  SimHashDefs USING [Base, Hash, HashBlock, HNull, FirstAvailSlot];  ReadFMFile: PROGRAM IMPORTS Exec, Format, MFile, MSegment =  BEGIN    HBase: TYPE = SimHashDefs.Base;  Hash: TYPE = SimHashDefs.Hash;  HNull: Hash ¬ SimHashDefs.HNull;    FirstAvailSlot: Hash ¬ SimHashDefs.FirstAvailSlot;    HashTableOffsetInFM: CARDINAL = 2;    FMBase: TYPE = LONG BASE POINTER TO FTRegion;  FTPtr: TYPE = FMBase RELATIVE ORDERED POINTER TO FTEntry;  FTEntry: TYPE = RECORD [fileNumber, assemblyFileNumber, startAddress, stopAddressPlusOne, stringLength: CARDINAL, string: PACKED ARRAY [0..0) OF CHARACTER];  FTRegion: TYPE = RECORD [ARRAY [0..0) OF FTEntry];  FTNull: FTPtr = LOOPHOLE[0];    hashTable: HBase ¬ NIL;  hash: Hash ¬ FirstAvailSlot;    fileTable: FMBase ¬ NIL;  fileTableEntry: FTPtr ¬ FTNull;  lastEntry: CARDINAL = 177777B;  aFTPtr: FTPtr ¬ FTNull;      segmentHandle: MSegment.Handle ¬ NIL;  name, switches: LONG STRING ¬ NIL;    DumpFMFile: Exec.ExecProc =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];        Cleanup: PROCEDURE = {      name ¬ Exec.FreeTokenString[name];      switches ¬ Exec.FreeTokenString[switches]};        DO      ENABLE UNWIND => {Cleanup[]};            [name, switches] ¬ Exec.GetToken[h];      IF name = NIL AND switches = NIL THEN EXIT;      segmentHandle ¬ MSegment.Create[file: MFile.ReadOnly[name: name, release: []], release: []];      [fileTable, hashTable] ¬ GetBasePointers[];      PrintFileTable[Write: Write];      PrintHashTable[Write: Write];      MSegment.Delete[segment: segmentHandle];    ENDLOOP;    Cleanup[];    END;      GetBasePointers: PROCEDURE[] RETURNS[fileTable: FMBase, hashTable:HBase] =    BEGIN      fileTable ¬ MSegment.Address[segment: segmentHandle];      aFTPtr ¬ FTNull;      UNTIL fileTable[aFTPtr].fileNumber = lastEntry DO        aFTPtr ¬ aFTPtr + (SIZE[FTEntry] + (fileTable[aFTPtr].stringLength + Environment.charsPerWord - 1)/ Environment.charsPerWord);      ENDLOOP;      hashTable ¬ LOOPHOLE[@fileTable[aFTPtr] + HashTableOffsetInFM, HBase];    END;    PrintFileTable: PROCEDURE[Write: Format.StringProc] =    BEGIN      aFTPtr ¬ FTNull;      UNTIL fileTable[aFTPtr].fileNumber = lastEntry DO        Format.Text[Write, "File number: "L];        Format.Number[proc: Write, n: fileTable[aFTPtr].fileNumber, format: []];        Format.Text[Write, "\nAssembly File number: "L];        Format.Number[proc: Write, n: fileTable[aFTPtr].assemblyFileNumber, format: []];        Format.Text[Write, "\nStart Address: "L];        Format.Number[proc: Write, n: fileTable[aFTPtr].startAddress, format: [base: 16]];        Format.Text[Write, " (Hex)\nEnding Address: "L];        Format.Number[proc: Write, n: fileTable[aFTPtr].stopAddressPlusOne - 1, format: [base: 16]];        Format.Text[Write, " (Hex)\nFile Name: "L];        FOR index: CARDINAL IN [0..fileTable[aFTPtr].stringLength) DO          Format.Char[Write, fileTable[aFTPtr].string[index]];        ENDLOOP;        Format.Text[Write, "\n\n"L];        aFTPtr ¬ aFTPtr + (SIZE[FTEntry] + (fileTable[aFTPtr].stringLength + Environment.charsPerWord - 1)/ Environment.charsPerWord);      ENDLOOP;    END;      PrintHashTable: PROCEDURE[Write: Format.StringProc] =    BEGIN      UNTIL hash = hashTable.nextAvail DO        IF hashTable[hash].reloc THEN Format.Text[Write, "[reloc: TRUE, "L]          ELSE Format.Text[Write, "[reloc: FALSE, "L];        Format.Text[Write, "address: "L];        Format.Number[proc: Write, n: hashTable[hash].ptrIndex, format: [base: 16]];        Format.Text[Write, "(Hex), label: "L];        Format.Text[Write, @hashTable[hash].string];        Format.Text[Write, "]\n"L];        hash ¬ hash + (SIZE[SimHashDefs.HashBlock] + (hashTable[hash].string.length + Environment.charsPerWord - 1)/ Environment.charsPerWord);      ENDLOOP;      Format.Text[Write, "\n"L];    END;    ReadFMFileHelp: Exec.ExecProc =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];    Format.Text[Write, "ReadFMFile is a program to display the contents of a File Map (*.fm).\n"L];    Format.Text[Write, "Currently only Domino.fm is displayed.\n"L];    END;    Exec.AddCommand[name: "ReadFMFile.~ "L, proc: DumpFMFile, help: ReadFMFileHelp];    END.    LOG  Created by DEG     .PA @ 14-Feb-83 15:09:49  Last Edit by DEG     .PA @ 28-Feb-83 13:30:30  Time: 26-Sep-84 23:17:44	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
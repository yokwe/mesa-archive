-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- TestUmbilical.mesa, HGM, 20-Jan-84 16:16:42-- TestUmbilical.mesa, Dennis DEG     ,  2-Oct-84 20:51:11DIRECTORY  DLionInputOutput USING [IOPage, processorCommandOffset, processorCSBOffset],  Environment USING [Block, Byte],  FormSW USING [    ClientItemsProcType, ProcType, AllocateItemDescriptor, newLine, CommandItem],  Inline USING [BITAND, BytePair, HighByte, HighHalf, LowByte, LowHalf],  Process USING [MsecToTicks, Pause, Yield],  Put USING [Char, Date, Number, Text, Line, LongDecimal],  Runtime USING [GetBcdTime],  String USING [AppendString],  System USING [GetClockPulses, GetGreenwichMeanTime, Pulses, PulsesToMicroseconds],  Time USING [Append, Unpack],  Tool USING [Create, MakeSWsProc, UnusedLogName, MakeFormSW, MakeFileSW],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle];TestUmbilical: PROGRAM  IMPORTS    DLionInputOutput, FormSW, Inline, Process, Put,    Runtime, String, System, Time, Tool, UserInput =  BEGIN  ProcessorCommand: TYPE = MACHINE DEPENDENT {    null(0), readIOPByte(5), writeIOPByte(6), readUmbilicalBlock(7), writeUmbilicalBlock(8)};  pProcessorCommand: LONG POINTER TO ProcessorCommand = DLionInputOutput.IOPage + DLionInputOutput.processorCommandOffset;  ProcessorCSB: TYPE = MACHINE DEPENDENT RECORD [    data2(0): WORD,    data1(1): WORD,      data0(2): WORD];  pProcessorCSB: LONG POINTER TO ProcessorCSB = DLionInputOutput.IOPage + DLionInputOutput.processorCSBOffset;  ReadIOP: PROCEDURE [address: CARDINAL] RETURNS [Environment.Byte] =    BEGIN    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ address;    pProcessorCommand­ ¬ readIOPByte;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    RETURN[Inline.LowByte[pProcessorCSB.data1]];    END;  ReadUmbilicalBlock: PROCEDURE [dataPtr: LONG POINTER, size: [0..0FFH]] =    BEGIN    before, after: ProcessorCSB;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ size;    pProcessorCSB.data1 ¬ Inline.LowHalf[dataPtr];    pProcessorCSB.data0 ¬ Inline.HighHalf[dataPtr];    before ¬ pProcessorCSB­;  -- Debugging    pProcessorCommand­ ¬ readUmbilicalBlock;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    after ¬ pProcessorCSB­;  -- Debugging    IF pProcessorCSB.data0 # 0 THEN ERROR Timeout;    END;      WriteIOP: PROCEDURE [address: CARDINAL, data: Environment.Byte] =    BEGIN    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ address;    pProcessorCSB.data1 ¬ data;    pProcessorCommand­ ¬ writeIOPByte;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    END;  WriteUmbilicalBlock: PROCEDURE [dataPtr: LONG POINTER, size: [0..0FFH]] =    BEGIN    before, after: ProcessorCSB;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ size;    pProcessorCSB.data1 ¬ Inline.LowHalf[dataPtr];    pProcessorCSB.data0 ¬ Inline.HighHalf[dataPtr];    before ¬ pProcessorCSB­;  -- Debugging    pProcessorCommand­ ¬ writeUmbilicalBlock;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    after ¬ pProcessorCSB­;  -- Debugging    IF pProcessorCSB.data0 # 0 THEN ERROR Timeout;    END;      ppiBase: CARDINAL = 100200B;  -- Hex 8080  ppiA: CARDINAL = ppiBase + 0;  ppiB: CARDINAL = ppiBase + 1;  ppiC: CARDINAL = ppiBase + 2;  ppiCtl: CARDINAL = ppiBase + 3;  ppiTest: CARDINAL = 202B;  -- Mode 0  ppiInit: CARDINAL = 246B;  -- Hex A6  ppiEnableA: CARDINAL = 15B; -- Hex 0D  ppiEnableB: CARDINAL = 5;  ppiSetBoot: CARDINAL = 9;  ppiClearBoot: CARDINAL = 8;  intAMask: CARDINAL = 10B;  -- Hex 8  intBMask: CARDINAL = 1;    UmbilicalNotWorking: ERROR = CODE;  Initialize: PROCEDURE =    BEGIN    -- Beware, Mode setting clears all FFs which turns on Boot    temp: WORD;    WriteIOP[ppiCtl, ppiTest];    WriteIOP[ppiCtl, ppiClearBoot];    WriteIOP[ppiA, 0];    temp ¬ ReadIOP[ppiA];    IF temp # 0 THEN ERROR UmbilicalNotWorking;    WriteIOP[ppiA, 0FFH];    temp ¬ ReadIOP[ppiA];    IF temp # 0FFH THEN ERROR UmbilicalNotWorking;    WriteIOP[ppiCtl, ppiInit];    WriteIOP[ppiCtl, ppiClearBoot];    WriteIOP[ppiCtl, ppiEnableA];    WriteIOP[ppiCtl, ppiEnableB];    [] ¬ ReadIOP[ppiB];  -- Discard garbage byte (if any)    END;  Timeout: ERROR = CODE;  maxWrite: CARDINAL ¬ 0;  WriteBurdock: PROCEDURE [data: Environment.Byte] =    BEGIN    temp: WORD;    WriteIOP[ppiA, data];    FOR i: CARDINAL IN [0..500) DO  -- ~ 1 second      temp ¬ ReadIOP[ppiC];      maxWrite ¬ MAX[maxWrite, i];      IF Inline.BITAND[temp, intAMask] # 0 THEN EXIT;      REPEAT FINISHED => ERROR Timeout;      ENDLOOP;    END;  WriteBurdockFast: PROCEDURE [data: Environment.Byte] =    BEGIN    temp: WORD;    WriteIOP[ppiA, data];    FOR i: CARDINAL IN [0..100) DO  -- ~ 1/5 second      temp ¬ ReadIOP[ppiC];      maxWrite ¬ MAX[maxWrite, i];      IF Inline.BITAND[temp, intAMask] # 0 THEN EXIT;      REPEAT FINISHED => ERROR Timeout;      ENDLOOP;    END;  WriteBurdockWord: PROCEDURE [data: WORD] =    BEGIN    WriteBurdock[Inline.LowByte[data]];    WriteBurdock[Inline.HighByte[data]];    END;  WriteBurdockBlock: PROCEDURE [finger: Environment.Block] =    BEGIN    IF finger.startIndex # 0 THEN ERROR;  -- Code not written yet    WriteUmbilicalBlock[finger.blockPointer, finger.stopIndexPlusOne];    END;    maxRead: CARDINAL ¬ 0;  ReadBurdock: PROCEDURE RETURNS [Environment.Byte] =    BEGIN    temp: WORD;    FOR i: CARDINAL IN [0..500) DO  -- ~ 1 second      temp ¬ ReadIOP[ppiC];      maxRead ¬MAX[maxRead, i];      IF Inline.BITAND[temp, intBMask] # 0 THEN EXIT;      REPEAT FINISHED => ERROR Timeout;      ENDLOOP;    RETURN[ReadIOP[ppiB]];    END;  ReadBurdockFast: PROCEDURE RETURNS [Environment.Byte] =    BEGIN    temp: WORD;    FOR i: CARDINAL IN [0..100) DO  -- ~ 1/5 second      temp ¬ ReadIOP[ppiC];      maxRead ¬MAX[maxRead, i];      IF Inline.BITAND[temp, intBMask] # 0 THEN EXIT;      REPEAT FINISHED => ERROR Timeout;      ENDLOOP;    RETURN[ReadIOP[ppiB]];    END;  ReadBurdockWord: PROCEDURE RETURNS [WORD] =    BEGIN    bytes: Inline.BytePair;    bytes.low ¬ ReadBurdock[];    bytes.high ¬ ReadBurdock[];    RETURN[LOOPHOLE[bytes]];    END;  ReadBurdockBlock: PROCEDURE [finger: Environment.Block] =    BEGIN    IF finger.startIndex # 0 THEN ERROR;  -- Code not written yet    ReadUmbilicalBlock[finger.blockPointer, finger.stopIndexPlusOne];    END;  ReadHisByte: PROCEDURE [addr: CARDINAL] RETURNS [Environment.Byte] =    BEGIN    WriteBurdock[2];    WriteBurdockWord[addr];    WriteBurdock[1];    RETURN[ReadBurdock[]];    END;  WriteHisByte: PROCEDURE [addr: CARDINAL, data: Environment.Byte] =    BEGIN    WriteBurdock[1];    WriteBurdockWord[addr];    WriteBurdock[1];    WriteBurdock[data];    END;  hostAddress: CARDINAL = 100260B;  -- Hex 80B0  ReadMyHostNumber: FormSW.ProcType =    BEGIN    Nibble: TYPE = [0..20B);    hostID: ARRAY [0..16) OF Nibble;    Put.Text[log, "Reading My Host Number ... "L];    FOR i: CARDINAL IN [0..16) DO      hostID[i] ¬ Inline.BITAND[ReadIOP[hostAddress+i], 17B];      ENDLOOP;    -- The nibbles for a byte are in the wrong order.    FOR i: CARDINAL ¬ 0, i + 2 UNTIL i >= 16 DO      temp: Nibble ¬ hostID[i];      hostID[i] ¬ hostID[i+1];      hostID[i+1] ¬ temp;      ENDLOOP;    FOR i: CARDINAL IN [0..16) DO      c: Nibble ¬ hostID[i];      SELECT c FROM        IN [0..9] => Put.Char[log, '0 + c];	IN [10..15] => Put.Char[log, 'A + c - 10];	ENDCASE => ERROR;      ENDLOOP;    Put.Line[log, "."L];    END;  miscClocks: CARDINAL = 100351B;  -- Hex 80E9  incMPanel: WORD = 40B;  -- Hex 20B  KickMyMP: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    Put.Text[log, "Kicking My MP ... "L];    FOR i: CARDINAL IN [0..10) DO      WriteIOP[miscClocks, 0FFH - incMPanel];      WriteIOP[miscClocks, 0FFH];  -- This may have happened by now (IOP reading clock...)      Put.Char[log, '!];      ENDLOOP;    Put.Line[log, "."L];    END;  ManyInit: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    Put.Text[log, "Flapping Init stuff ... "L];    FOR i: CARDINAL IN [0..10000) DO      Initialize[];      Process.Pause[Process.MsecToTicks[200]];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "."L];    END;  FlapBoot: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    Put.Text[log, "Flapping Boot Line ... "L];    FOR i: CARDINAL IN [0..10000) DO      Initialize[];      WriteIOP[ppiCtl, ppiSetBoot];      Process.Pause[Process.MsecToTicks[100]];      WriteIOP[ppiCtl, ppiClearBoot];      Process.Pause[Process.MsecToTicks[200]];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "."L];    END;  RepeatBootSequence: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    Put.Line[log, "Repeating Boot Sequence ... "L];    Put.Line[log, "G => No Greeting."L];    Put.Line[log, "I => Invalid Greeting."L];    Put.Line[log, "W => No Write (on Cold Start Command)."L];    Put.Line[log, "R => No Response from Cold Start."L];    Put.Line[log, "X => Weird Response from Cold Start."L];    Put.Line[log, "! => Worked."L];    FOR i: CARDINAL IN [0..10000) DO      IF UserInput.UserAbort[log] THEN EXIT;      Initialize[];      WriteIOP[ppiCtl, ppiSetBoot];      Process.Pause[Process.MsecToTicks[100]];      WriteIOP[ppiCtl, ppiClearBoot];      BEGIN      response: WORD;      response ¬ ReadBurdockFast[ ! Timeout => GOTO NoGreeting];      IF response # 0FFH THEN GOTO WeirdInitialResponse;      WriteBurdockFast[20B ! Timeout => GOTO NoWrite];  -- ColdStartTest      response ¬ ReadBurdock[ ! Timeout => GOTO NoResponse];      IF response # 376B THEN GOTO WeirdDiagResponse;      EXITS        NoGreeting => BEGIN Put.Char[log, 'G]; LOOP; END;        WeirdInitialResponse => BEGIN Put.Char[log, 'I]; LOOP; END;        NoWrite => BEGIN Put.Char[log, 'W]; LOOP; END;        NoResponse => BEGIN Put.Char[log, 'X]; LOOP; END;        WeirdDiagResponse => BEGIN Put.Char[log, 'D]; LOOP; END;      END;      Put.Char[log, '!];      Process.Pause[Process.MsecToTicks[200]];      ENDLOOP;    Put.Line[log, "."L];    END;  BootDebugee: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    response: WORD;    Put.Text[log, "Booting Debugee ... "L];    Initialize[];    WriteIOP[ppiCtl, ppiSetBoot];    Process.Pause[Process.MsecToTicks[100]];    WriteIOP[ppiCtl, ppiClearBoot];    response ¬ ReadBurdock[ ! Timeout => GOTO TimedOut];    Put.Text[log, " response code was "L];    Put.Number[log, response, [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    Put.Text[log, "  Running memory test ... "L];    WriteBurdock[25B ! Timeout => GOTO TimedOut];  -- ColdStartTest    Process.Pause[Process.MsecToTicks[2000]];  -- Test takes a while    response ¬ ReadBurdock[ ! Timeout => GOTO TimedOut];    Put.Text[log, " response code was "L];    Put.Number[log, response, [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    EXITS TimedOut => Put.Line[log, "  *** Timeout"L];    END;  GetConfig: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    PrintInfo: PROCEDURE [s: STRING] =      BEGIN      Put.Text[log, s];      Put.Text[log, ": "L];      Put.Number[log, ReadBurdockWord[], [16, FALSE, TRUE, 0]];      Put.Line[log, "."L];      END;    Put.Text[log, "Reading Config ... "L];    WriteBurdock[5 ! Timeout => GOTO TimedOut];    Put.Line[log, "."L];    PrintInfo["  Prm size"L ! Timeout => GOTO TimedOut];    PrintInfo["  Ram strt"L ! Timeout => GOTO TimedOut];    PrintInfo["  Mem size"L ! Timeout => GOTO TimedOut];    PrintInfo["  Stk strt"L ! Timeout => GOTO TimedOut];    PrintInfo["  Save loc"L ! Timeout => GOTO TimedOut];    PrintInfo["  Brkp loc"L ! Timeout => GOTO TimedOut];    EXITS TimedOut => Put.Line[log, "  *** Timeout"L];    END;  ReadHisHostNumber: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    Nibble: TYPE = [0..20B);    hostID: ARRAY [0..16) OF Nibble;    Put.Text[log, "Reading His Host Number ... "L];    FOR i: CARDINAL IN [0..16) DO      hostID[i] ¬ Inline.BITAND[ReadHisByte[hostAddress+i ! Timeout => GOTO TimedOut], 17B];      ENDLOOP;    -- The nibbles for a byte are in the wrong order.    FOR i: CARDINAL ¬ 0, i + 2 UNTIL i >= 16 DO      temp: Nibble ¬ hostID[i];      hostID[i] ¬ hostID[i+1];      hostID[i+1] ¬ temp;      ENDLOOP;    FOR i: CARDINAL IN [0..16) DO      c: Nibble ¬ hostID[i];      SELECT c FROM        IN [0..9] => Put.Char[log, '0 + c];	IN [10..15] => Put.Char[log, 'A + c - 10];	ENDCASE => ERROR;      ENDLOOP;    Put.Line[log, "."L];    EXITS TimedOut => Put.Line[log, "  *** Timeout"L];    END;  KickHisMP: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    Put.Text[log, "Kicking His MP ... "L];    FOR i: CARDINAL IN [0..10) DO      WriteHisByte[miscClocks, 0FFH - incMPanel ! Timeout => GOTO TimedOut];      WriteHisByte[miscClocks, 0FFH ! Timeout => GOTO TimedOut];      Put.Char[log, '!];      ENDLOOP;    Put.Line[log, "."L];    EXITS TimedOut => Put.Line[log, "  *** Timeout"L];    END;  TimeReads: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    start, stop: System.Pulses;    microseconds: LONG CARDINAL;    loop: CARDINAL = 10000;    Put.Text[log, "Timing read ... "L];    start ¬ System.GetClockPulses[];    FOR i: CARDINAL IN [0..loop) DO      [] ¬ ReadIOP[0];      ENDLOOP;    stop ¬ System.GetClockPulses[];    microseconds ¬ System.PulsesToMicroseconds[[stop - start]]/loop;    Put.Line[log, "."L];    Put.Text[log, "   It took "L];    Put.LongDecimal[log, microseconds];    Put.Line[log, " microseconds to read a byte from our IOP's address space."L];    END;      TimeWrites: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    start, stop: System.Pulses;    microseconds: LONG CARDINAL;    loop: CARDINAL = 10000;    Put.Text[log, "Timing writes ... "L];    start ¬ System.GetClockPulses[];    FOR i: CARDINAL IN [0..loop/2) DO      WriteIOP[miscClocks, 0FFH - incMPanel];      WriteIOP[miscClocks, 0FFH];      ENDLOOP;    stop ¬ System.GetClockPulses[];    microseconds ¬ System.PulsesToMicroseconds[[stop - start]]/loop;    Put.Line[log, "."L];    Put.Text[log, "   It took "L];    Put.LongDecimal[log, microseconds];    Put.Line[log, " microseconds to write a byte into our IOP's address space."L];    END;      TimeNOPs: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    start, stop: System.Pulses;    microseconds: LONG CARDINAL;    loop: CARDINAL = 1000;    Put.Text[log, "Timing NOPs to IOP Kernel ... "L];    start ¬ System.GetClockPulses[];    FOR i: CARDINAL IN [0..loop) DO      WriteBurdock[4 ! Timeout => GOTO TimedOut];      ENDLOOP;    stop ¬ System.GetClockPulses[];    microseconds ¬ System.PulsesToMicroseconds[[stop - start]]/loop;    Put.Line[log, "."L];    Put.Text[log, "   It took "L];    Put.LongDecimal[log, microseconds];    Put.Line[log, " microseconds for the IOP Kernel to process a NOP."L];    EXITS TimedOut => Put.Line[log, "  *** Timeout"L];    END;  TimeGetConfig: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    start, stop: System.Pulses;    microseconds: LONG CARDINAL;    loop: CARDINAL = 1000;    Put.Text[log, "Timing GetConfig ... "L];    start ¬ System.GetClockPulses[];    FOR i: CARDINAL IN [0..loop) DO      WriteBurdock[5 ! Timeout => GOTO TimedOut];      FOR i: CARDINAL IN [0..6) DO         [] ¬ ReadBurdockWord[ ! Timeout => GOTO TimedOut];	 ENDLOOP;      ENDLOOP;    stop ¬ System.GetClockPulses[];    microseconds ¬ System.PulsesToMicroseconds[[stop - start]]/loop;    Put.Line[log, "."L];    Put.Text[log, "   It took "L];    Put.LongDecimal[log, microseconds];    Put.Line[log, " microseconds to get the IOP configuration."L];    EXITS TimedOut => Put.Line[log, "  *** Timeout"L];    END;  ReadIOPRam: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    start, stop: System.Pulses;    microseconds: LONG CARDINAL;    loop: CARDINAL = 100;    Put.Text[log, "Timing reading IOP ... "L];    start ¬ System.GetClockPulses[];    FOR i: CARDINAL IN [0..loop) DO      foo: ARRAY [0..10) OF WORD;      WriteBurdock[2 ! Timeout => GOTO TimedOut];      WriteBurdockWord[hostAddress ! Timeout => GOTO TimedOut];      WriteBurdock[10 ! Timeout => GOTO TimedOut];      FOR k: CARDINAL IN [0..10) DO foo[k] ¬ ReadBurdock[ ! Timeout => GOTO TimedOut]; ENDLOOP;      ENDLOOP;    stop ¬ System.GetClockPulses[];    microseconds ¬ System.PulsesToMicroseconds[[stop - start]]/loop;    Put.Line[log, "."L];    Put.Text[log, "   It took "L];    Put.LongDecimal[log, microseconds];    Put.Line[log, " microseconds to read 10 bytes from the debugee IOP's address space."L];    EXITS TimedOut => Put.Line[log, "  *** Timeout"L];    END;  WriteIOPRam: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    start, stop: System.Pulses;    microseconds: LONG CARDINAL;    loop: CARDINAL = 100;    Put.Text[log, "Timing writing IOP ... "L];    start ¬ System.GetClockPulses[];    FOR i: CARDINAL IN [0..loop) DO      WriteBurdock[1 ! Timeout => GOTO TimedOut];      WriteBurdockWord[hostAddress ! Timeout => GOTO TimedOut];      WriteBurdock[10 ! Timeout => GOTO TimedOut];      FOR k: CARDINAL IN [0..10) DO WriteBurdock[0 ! Timeout => GOTO TimedOut]; ENDLOOP;      ENDLOOP;    stop ¬ System.GetClockPulses[];    microseconds ¬ System.PulsesToMicroseconds[[stop - start]]/loop;    Put.Line[log, "."L];    Put.Text[log, "   It took "L];    Put.LongDecimal[log, microseconds];    Put.Line[log, " microseconds to write 10 bytes into the debugee IOP's address space."L];    EXITS TimedOut => Put.Line[log, "  *** Timeout"L];    END;  startOfRam: CARDINAL = 40000B;  MemTest: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    clumpSize: Environment.Byte = 254;  -- Must fit in a byte    read, write: LONG CARDINAL ¬ 0;    bytes: LONG CARDINAL ¬ 0;    Put.Text[log, "Testing IOP memory ... "L];    DO      FOR data: Environment.Byte IN Environment.Byte DO        start, stop: System.Pulses;        buffer: PACKED ARRAY [0..clumpSize) OF Environment.Byte;	block: Environment.Block ¬ [LOOPHOLE[LONG[@buffer]], 0, clumpSize];        WriteBurdock[1 ! Timeout => GOTO TimedOut];        WriteBurdockWord[startOfRam ! Timeout => GOTO TimedOut];        WriteBurdock[clumpSize ! Timeout => GOTO TimedOut];        FOR k: CARDINAL IN [0..clumpSize) DO buffer[k] ¬ data; ENDLOOP;        start ¬ System.GetClockPulses[];        WriteBurdockBlock[block ! Timeout => GOTO TimedOut];        stop ¬ System.GetClockPulses[];	write ¬ write + System.PulsesToMicroseconds[[stop - start]];        WriteBurdock[2 ! Timeout => GOTO TimedOut];        WriteBurdockWord[startOfRam ! Timeout => GOTO TimedOut];        WriteBurdock[clumpSize ! Timeout => GOTO TimedOut];        start ¬ System.GetClockPulses[];        ReadBurdockBlock[block ! Timeout => GOTO TimedOut];        stop ¬ System.GetClockPulses[];	read ¬ read + System.PulsesToMicroseconds[[stop - start]];        FOR k: CARDINAL IN [0..clumpSize) DO	  found: WORD ¬ buffer[k];	  IF found # data THEN	    BEGIN	    Put.Text[log, "  Data mismatch!  Expected "L];	    Put.Number[log, data, [16, FALSE, TRUE, 0]];	    Put.Text[log, " but found: "L];	    Put.Number[log, found, [16, FALSE, TRUE, 0]];	    Put.Line[log, ".  ****"L];	    GOTO Exit;	    END;          ENDLOOP;        WriteHisByte[miscClocks, 0FFH - incMPanel ! Timeout => GOTO TimedOut];        WriteHisByte[miscClocks, 0FFH ! Timeout => GOTO TimedOut];	bytes ¬ bytes + clumpSize;        Process.Yield[];        IF UserInput.UserAbort[log] THEN EXIT;        ENDLOOP;      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "."L];    Put.Text[log, "It took "L];    Put.LongDecimal[log, write];    Put.Text[log, " microseconds to write "L];    Put.LongDecimal[log, bytes];    Put.Text[log, " bytes.  That's "L];    Put.LongDecimal[log, bytes*1000/(write/8000)];    Put.Line[log, " bits per second."L];    Put.Text[log, "It took "L];    Put.LongDecimal[log, read];    Put.Text[log, " microseconds to read "L];    Put.LongDecimal[log, bytes];    Put.Text[log, " bytes.  That's "L];    Put.LongDecimal[log, bytes*1000/(read/8000)];    Put.Line[log, " bits per second."L];    EXITS      TimedOut => Put.Line[log, "  *** Timeout"L];      Exit => NULL;    END;        MemTestOdd: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    clumpSize: Environment.Byte = 11;  -- Must fit in a byte    read, write: LONG CARDINAL ¬ 0;    bytes: LONG CARDINAL ¬ 0;    Put.Text[log, "Testing IOP memory ... "L];    DO      FOR data: Environment.Byte IN Environment.Byte DO        start, stop: System.Pulses;        buffer: PACKED ARRAY [0..clumpSize) OF Environment.Byte;	block: Environment.Block ¬ [LOOPHOLE[LONG[@buffer]], 0, clumpSize];        WriteBurdock[1 ! Timeout => GOTO TimedOut];        WriteBurdockWord[startOfRam ! Timeout => GOTO TimedOut];        WriteBurdock[clumpSize ! Timeout => GOTO TimedOut];        FOR k: CARDINAL IN [0..clumpSize) DO buffer[k] ¬ data; ENDLOOP;        start ¬ System.GetClockPulses[];        WriteBurdockBlock[block ! Timeout => GOTO TimedOut];        stop ¬ System.GetClockPulses[];	write ¬ write + System.PulsesToMicroseconds[[stop - start]];        WriteBurdock[2 ! Timeout => GOTO TimedOut];        WriteBurdockWord[startOfRam ! Timeout => GOTO TimedOut];        WriteBurdock[clumpSize ! Timeout => GOTO TimedOut];        start ¬ System.GetClockPulses[];        ReadBurdockBlock[block ! Timeout => GOTO TimedOut];        stop ¬ System.GetClockPulses[];	read ¬ read + System.PulsesToMicroseconds[[stop - start]];        FOR k: CARDINAL IN [0..clumpSize) DO	  found: WORD ¬ buffer[k];	  IF found # data THEN	    BEGIN	    Put.Text[log, "  Data mismatch!  Expected "L];	    Put.Number[log, data, [16, FALSE, TRUE, 0]];	    Put.Text[log, " but found: "L];	    Put.Number[log, found, [16, FALSE, TRUE, 0]];	    Put.Line[log, ".  ****"L];	    GOTO Exit;	    END;          ENDLOOP;        WriteHisByte[miscClocks, 0FFH - incMPanel ! Timeout => GOTO TimedOut];        WriteHisByte[miscClocks, 0FFH ! Timeout => GOTO TimedOut];	bytes ¬ bytes + clumpSize;        Process.Yield[];        IF UserInput.UserAbort[log] THEN EXIT;        ENDLOOP;      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "."L];    Put.Text[log, "It took "L];    Put.LongDecimal[log, write];    Put.Text[log, " microseconds to write "L];    Put.LongDecimal[log, bytes];    Put.Text[log, " bytes.  That's "L];    Put.LongDecimal[log, bytes*1000/(write/8000)];    Put.Line[log, " bits per second."L];    Put.Text[log, "It took "L];    Put.LongDecimal[log, read];    Put.Text[log, " microseconds to read "L];    Put.LongDecimal[log, bytes];    Put.Text[log, " bytes.  That's "L];    Put.LongDecimal[log, bytes*1000/(read/8000)];    Put.Line[log, " bits per second."L];    EXITS      TimedOut => Put.Line[log, "  *** Timeout"L];      Exit => NULL;    END;        SloshZeros: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    clumpSize: Environment.Byte = 254;  -- Must fit in a byte    Put.Text[log, "Reading+Writing lots of 0s ... "L];    DO      buffer: PACKED ARRAY [0..clumpSize) OF Environment.Byte;      block: Environment.Block ¬ [LOOPHOLE[LONG[@buffer]], 0, clumpSize];      WriteBurdock[1 ! Timeout => GOTO TimedOut];      WriteBurdockWord[startOfRam ! Timeout => GOTO TimedOut];      WriteBurdock[clumpSize ! Timeout => GOTO TimedOut];      FOR k: CARDINAL IN [0..clumpSize) DO buffer[k] ¬ 0; ENDLOOP;      WriteBurdockBlock[block ! Timeout => GOTO TimedOut];      WriteBurdock[2 ! Timeout => GOTO TimedOut];      WriteBurdockWord[startOfRam ! Timeout => GOTO TimedOut];      WriteBurdock[clumpSize ! Timeout => GOTO TimedOut];      ReadBurdockBlock[block ! Timeout => GOTO TimedOut];      FOR k: CARDINAL IN [0..clumpSize) DO	  found: WORD ¬ buffer[k];	  IF found # 0 THEN	    BEGIN	    Put.Text[log, "  Data mismatch!  Expected "L];	    Put.Number[log, 0, [16, FALSE, TRUE, 0]];	    Put.Text[log, " but found: "L];	    Put.Number[log, found, [16, FALSE, TRUE, 0]];	    Put.Line[log, ".  ****"L];	    GOTO Exit;	    END;          ENDLOOP;      WriteHisByte[miscClocks, 0FFH - incMPanel ! Timeout => GOTO TimedOut];      WriteHisByte[miscClocks, 0FFH ! Timeout => GOTO TimedOut];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "."L];    EXITS      TimedOut => Put.Line[log, "  *** Timeout"L];      Exit => NULL;    END;        SloshOnes: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    clumpSize: Environment.Byte = 254;  -- Must fit in a byte    Put.Text[log, "Reading+Writing lots of 1s ... "L];    DO      buffer: PACKED ARRAY [0..clumpSize) OF Environment.Byte;      block: Environment.Block ¬ [LOOPHOLE[LONG[@buffer]], 0, clumpSize];      WriteBurdock[1 ! Timeout => GOTO TimedOut];      WriteBurdockWord[startOfRam ! Timeout => GOTO TimedOut];      WriteBurdock[clumpSize ! Timeout => GOTO TimedOut];      FOR k: CARDINAL IN [0..clumpSize) DO buffer[k] ¬ 0FFH; ENDLOOP;      WriteBurdockBlock[block ! Timeout => GOTO TimedOut];      WriteBurdock[2 ! Timeout => GOTO TimedOut];      WriteBurdockWord[startOfRam ! Timeout => GOTO TimedOut];      WriteBurdock[clumpSize ! Timeout => GOTO TimedOut];      ReadBurdockBlock[block ! Timeout => GOTO TimedOut];      FOR k: CARDINAL IN [0..clumpSize) DO	  found: WORD ¬ buffer[k];	  IF found # 0FFH THEN	    BEGIN	    Put.Text[log, "  Data mismatch!  Expected "L];	    Put.Number[log, 0FFH, [16, FALSE, TRUE, 0]];	    Put.Text[log, " but found: "L];	    Put.Number[log, found, [16, FALSE, TRUE, 0]];	    Put.Line[log, ".  ****"L];	    GOTO Exit;	    END;          ENDLOOP;      WriteHisByte[miscClocks, 0FFH - incMPanel ! Timeout => GOTO TimedOut];      WriteHisByte[miscClocks, 0FFH ! Timeout => GOTO TimedOut];      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "."L];    EXITS      TimedOut => Put.Line[log, "  *** Timeout"L];      Exit => NULL;    END;        SloshAlt: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    clumpSize: Environment.Byte = 254;  -- Must fit in a byte    sample: PACKED ARRAY [0..clumpSize) OF Environment.Byte;    Put.Text[log, "Reading+Writing alternate bytes of 0s and 1s ... "L];    FOR k: CARDINAL IN [0..clumpSize) DO      IF (k MOD 2) = 0 THEN sample[k] ¬ 0FFH      ELSE sample[k] ¬ 0;      ENDLOOP;    DO      buffer: PACKED ARRAY [0..clumpSize) OF Environment.Byte;      block: Environment.Block ¬ [LOOPHOLE[LONG[@buffer]], 0, clumpSize];      WriteBurdock[1 ! Timeout => GOTO TimedOut];      WriteBurdockWord[startOfRam ! Timeout => GOTO TimedOut];      WriteBurdock[clumpSize ! Timeout => GOTO TimedOut];      FOR k: CARDINAL IN [0..clumpSize) DO buffer[k] ¬ sample[k]; ENDLOOP;      WriteBurdockBlock[block ! Timeout => GOTO TimedOut];      WriteBurdock[2 ! Timeout => GOTO TimedOut];      WriteBurdockWord[startOfRam ! Timeout => GOTO TimedOut];      WriteBurdock[clumpSize ! Timeout => GOTO TimedOut];      ReadBurdockBlock[block ! Timeout => GOTO TimedOut];      FOR k: CARDINAL IN [0..clumpSize) DO	  found: WORD ¬ buffer[k];	  IF found # sample[k] THEN	    BEGIN	    Put.Text[log, "  Data mismatch!  Expected "L];	    Put.Number[log,  0FFH, [16, FALSE, TRUE, 0]];	    Put.Text[log, " but found: "L];	    Put.Number[log, found, [16, FALSE, TRUE, 0]];	    Put.Line[log, ".  ****"L];	    GOTO Exit;	    END;          ENDLOOP;      WriteHisByte[miscClocks, 0FFH - incMPanel ! Timeout => GOTO TimedOut];      WriteHisByte[miscClocks, 0FFH ! Timeout => GOTO TimedOut];      Process.Pause[Process.MsecToTicks[100]];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "."L];    EXITS      TimedOut => Put.Line[log, "  *** Timeout"L];      Exit => NULL;    END;        KillKernel0: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    Put.Text[log, "Killing IOP Kernel (via 0 byte) ... "L];    WriteBurdock[0 ! Timeout => GOTO TimedOut];    Put.Line[log, "."L];    EXITS TimedOut => Put.Line[log, "  *** Timeout"L];    END;  KillKernel377: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    Put.Text[log, "Killing IOP Kernel (via 0FFH byte) ... "L];    WriteBurdock[0FFH ! Timeout => GOTO TimedOut];    Put.Line[log, "."L];    EXITS TimedOut => Put.Line[log, "  *** Timeout"L];    END;  Status: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    temp: WORD;    Put.Text[log, "Status of Burdock link is "L];    temp ¬ ReadIOP[ppiC];    Put.Number[log, temp, [16, FALSE, TRUE, 0]];    FOR i: CARDINAL IN [0..100) UNTIL Inline.BITAND[temp, intBMask] = 0 DO      data: WORD ¬ ReadBurdock[ ! Timeout => GOTO TimedOut];      IF i = 0 THEN Put.Line[log, "."L] ELSE Put.Text[log, ", "L];      Put.Number[log, data, [16, FALSE, TRUE, 0]];      temp ¬ ReadIOP[ppiC];      ENDLOOP;    Put.Line[log, "."L];    EXITS TimedOut => Put.Line[log, "  *** Unexpected Timeout !!"L];    END;  ReadStatusLoop: FormSW.ProcType =    BEGIN ENABLE UmbilicalNotWorking =>      BEGIN      Put.Line[log, "UmbilicalNotWorking!"L];      CONTINUE;      END;    Put.Text[log, "Reading Status (to wiggle wires) ..."L];    DO      temp: WORD ¬ ReadIOP[ppiC];      IF temp # 0CCH THEN        BEGIN        Put.Date[log, System.GetGreenwichMeanTime[], dateTime];	Put.Text[log, "  Status changed to "L];        Put.Number[log, temp, [16, FALSE, TRUE, 0]];	Put.Line[log, "."L];	RETURN;	END;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, " done."L];    END;              form, log: Window.Handle ¬ NIL;  Init: PROCEDURE =    BEGIN    herald: STRING = [100];    String.AppendString[herald, "TestUmbilical of  "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    [] ¬ Tool.Create[      name: herald, makeSWsProc: MakeSWs, clientTransition: ClientTransition];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    Tool.UnusedLogName[logFileName, "TestUmbilical.log$"L];    log ¬ Tool.MakeFileSW[window: window, name: logFileName];    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 24;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[0] ¬ FormSW.CommandItem[      tag: "ReadMyHostNumber"L, proc: ReadMyHostNumber, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "KickMyMP"L, proc: KickMyMP];    items[2] ¬ FormSW.CommandItem[tag: "ManyInit"L, proc: ManyInit];    items[3] ¬ FormSW.CommandItem[tag: "FlapBoot"L, proc: FlapBoot];    items[4] ¬ FormSW.CommandItem[tag: "RepeatBootSequence"L, proc: RepeatBootSequence];    items[5] ¬ FormSW.CommandItem[tag: "BootDebugee"L, proc: BootDebugee, place: FormSW.newLine];    items[6] ¬ FormSW.CommandItem[tag: "GetConfig"L, proc: GetConfig];    items[7] ¬ FormSW.CommandItem[tag: "ReadHisHostNumber"L, proc: ReadHisHostNumber];    items[8] ¬ FormSW.CommandItem[tag: "KickHisMP"L, proc: KickHisMP];    items[9] ¬ FormSW.CommandItem[tag: "TimeReads"L, proc: TimeReads, place: FormSW.newLine];    items[10] ¬ FormSW.CommandItem[tag: "TimeWrites"L, proc: TimeWrites];    items[11] ¬ FormSW.CommandItem[tag: "TimeNOPs"L, proc: TimeNOPs];    items[12] ¬ FormSW.CommandItem[tag: "TimeGetConfig"L, proc: TimeGetConfig];    items[13] ¬ FormSW.CommandItem[tag: "ReadIOPRam"L, proc: ReadIOPRam];    items[14] ¬ FormSW.CommandItem[tag: "WriteIOPRam"L, proc: WriteIOPRam];    items[15] ¬ FormSW.CommandItem[tag: "MemTest"L, proc: MemTest, place: FormSW.newLine];    items[16] ¬ FormSW.CommandItem[tag: "MemTestOdd"L, proc: MemTestOdd];    items[17] ¬ FormSW.CommandItem[tag: "SloshZeros"L, proc: SloshZeros];    items[18] ¬ FormSW.CommandItem[tag: "SloshOnes"L, proc: SloshOnes];    items[19] ¬ FormSW.CommandItem[tag: "SloshAlt"L, proc: SloshAlt];    items[20] ¬ FormSW.CommandItem[tag: "KillKernel0"L, proc: KillKernel0, place: FormSW.newLine];    items[21] ¬ FormSW.CommandItem[tag: "KillKernel377"L, proc: KillKernel377];    items[22] ¬ FormSW.CommandItem[tag: "Status"L, proc: Status];    items[23] ¬ FormSW.CommandItem[tag: "ReadStatusLoop"L, proc: ReadStatusLoop];    RETURN[items, TRUE];    END;  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN        END;      ENDCASE;    END;	  Init[];  END....
{Dicentra.dfn, HGM, 21-Sep-83 22:29:36}{R AND RH REGISTER DEFINITIONSSince there are no task specific registers in the machine, task identifiers are not bound to the register numbers with which they are shown.Q is reserved for the Emulator Task.Also, the stackP, STK, ib, and pc16 registers are reserved for the Emulator task.}{REGISTERS 0 - 6: EMULATOR}RegDef[TOS,		R,	0];RegDef[Hold,		R,	0];	{BBLoops}RegDef[Rbb0,		R,	0];	{BitBlt and TextBlt}RegDef[VS,		R,	0];	{BitBlt}RegDef[Mask2,		R,	0];	{BitBlt}RegDef[rhMDS,		RH,	0];	{VA of 64K aligned MDS}RegDef[rhVS,		RH,	0];	{BitBlt uses fact that rhVS = rhMDS}RegDef[T,		R,	1];RegDef[Save,		R,	1];	{BitBlt}RegDef[VD,		R,	1];	{BitBlt}RegDef[Rbb1,		R,	1];	{BitBlt and TextBlt}RegDef[Mask1,		R,	1];	{BitBlt}RegDef[rhT,		RH,	1];	{temporary}RegDef[rhVD,		RH,	1];	{BitBlt}RegDef[TT,		R,	2];RegDef[Src,		R,	2];	{BitBlt}RegDef[Rbb2,		R,	2];	{BitBlt and TextBlt Rbb2 must equal TT to share MaskTbl}RegDef[Temp,		R,	2];	{BitBlt}RegDef[TempDelta,	R,	2];	{BitBlt}RegDef[rhTT,		RH,	2];	{temporary}RegDef[rhType,		RH,	2];	{BitBlt}RegDef[L,		R,	3];RegDef[Dst,		R,	3];	{BitBlt}RegDef[TempBpl,		R,	3];	{BitBlt}RegDef[Rbb3,		R,	3];	{BitBlt and TextBlt}RegDef[rhL,		RH,	3];	{local frame (RA, extended by rhL=real rhMDS)}RegDef[rhWho,		RH,	3];	{BitBlt}RegDef[G,		R,	4];RegDef[SrcA,		R,	4];	{BitBlt}RegDef[Rbb4,		R,	4];	{BitBlt and TextBlt}RegDef[rDrh,		RH,	4];	{base register for second 64K}RegDef[rhG,		RH,	4];	{global frame (RA, extended by rhG=real rhMDS)}RegDef[rhSrcA,		RH,	4];	{BitBlt}RegDef[PC,		R,	5];RegDef[DstA,		R,	5];	{BitBlt}RegDef[rhPC,		RH,	5];	{word address of next inst (RA, extended by rhPC=real UvChigh)}RegDef[rhDstA,		RH,	5];	{BitBlt}RegDef[Rx,		R,	6];RegDef[Lcount,		R,	6];	{BitBlt}RegDef[TempB,		R,	6];	{BitBlt}RegDef[rhRx,		RH,	6];	{temporary}RegDef[rhRet,		RH,	6];	{BitBlt}{REGISTERS 7 - E: Interrupt processing}{REGISTER D: Interrupt processing}RegDef[SCC,		R,	08];RegDef[SCCh,		RH,	08];RegDef[IOCB,		R,	09];RegDef[IOCBh,		RH,	09];RegDef[CSB,		R,	0A];RegDef[CSBh,		RH,	0A];RegDef[Buffer,		R,	0B];RegDef[BufferH,		RH,	0B];RegDef[state,		R,	0C];RegDef[count,		R,	0D];RegDef[rhInt,		RH,	0D]; {Don't smash this in the phone lines}RegDef[Rio,		R,	0E];RegDef[rhRio,		RH,	0E];RegDef[temp,		R,	0E];RegDef[tempH,		RH,	0E]; {For mapping things}{REGISTER F: Kernel}RegDef[rK,		R,	0F];RegDef[RHrK,		RH,	0F];{The allocation of Link registers:#    taskL0    EmulatorL1    EmulatorL2    EmulatorL3    EmulatorL4    SDLC}{U REGISTER DEFINITIONSRegisters indicated by ** contain Emulator state and must not be modified.}{U REGISTER BLOCK 0 -- EMULATOR STACK}RegDef[uBlock0,		U,	0]:RegDef[uStack1,		U,	1];RegDef[uStack2,		U,	2];RegDef[UBitBltArg,	U,	2];	{BitBlt}RegDef[uStack3,		U,	3];RegDef[UHeight,		U,	3];	{BitBlt}RegDef[uStack4,		U,	4];RegDef[UDstVALo,	U,	4];	{BitBlt}RegDef[uStack5,		U,	5];RegDef[UDstBit,		U,	5];	{BitBlt}RegDef[uStack6,		U,	6];RegDef[USrcVALo,	U,	6];	{BitBlt}RegDef[uStack7,		U,	7];RegDef[USrcBit,		U,	7];	{BitBlt}RegDef[uStack8,		U,	8];RegDef[UGray,		U,	8];	{BitBlt -- shares with USrcBpl}RegDef[USrcBpl,		U,	8];	{BitBlt -- shares with UGray}RegDef[uStack9,		U,	9];RegDef[UDstBpl,		U,	9];	{BitBlt}RegDef[uStackA,		U,	0A];RegDef[UrhVS,		U,	0A];	{BitBlt}RegDef[uStackB,		U,	0B];RegDef[UrhVD,		U,	0B];	{BitBlt}RegDef[uStackC,		U,	0C];RegDef[UFlags,		U,	0C];	{BitBlt}RegDef[uStackD,		U,	0D];RegDef[UWidth,		U,	0D];	{BitBlt}RegDef[uStackE,		U,	0E];RegDef[uStackF,		U,	0F];{U REGISTER BLOCK 1 -- EMULATOR}RegDef[uHeaderBlock,	UY,	1]:RegDef[uBlock1,		U,	10]:RegDef[uWP,		U,	10];	{** wakeups pending, rA = T}RegDef[UvC,		U,	11];	{** rA = T low half of code (VA, extended by UvChigh)}RegDef[uPCCross,	U,	12];	{**}RegDef[uPPMask,		U,	13];	{** rA = T, constant = 7000}RegDef[uWW,		U,	14];RegDef[u3FFF,		U,	15];	{** constant, rA = T}RegDef[uPMask,		U,	16];	{** rA = T; constant = 0FFC}RegDef[UXferType,	U,	17];	{type of Xfer in progress}RegDef[uWDC,		U,	18];	{** wakeup disable counter}RegDef[UGsave,		U,	19];RegDef[Udest,		U,	1A];	{rA = T; destination link of Xfer in progress}RegDef[uPsbLink,	U,	1B];	{rA = T, fZ = _RH}RegDef[UvLPhigh,	U,	1B];RegDef[uT,		U,	1C];	{rA = T}RegDef[uTemp,		U,	1D];	{rA = T, fZ = _ib}RegDef[UrhMDSsave,	U,	1E];RegDef[uDestHighSave,	U,	1F];	{Block}{U REGISTER BLOCK 2 -- EMULATOR}RegDef[uBlock2,		U,	20]:RegDef[uXTS,		U,	20];	{** Xfer Trap Status}RegDef[UvG,		U,	21];	{** rA = TT, global frame address  (VA)}RegDef[UvChigh,		U,	22];	{** rA = TT, high address bits of code segment (VA)}RegDef[UvMDS,		U,	23];	{** rA = TT; MDS pointer (VA)}RegDef[uSourceHighSaveTemp,	U,	24];	{Block}RegDef[uFrame,		U,	25];	{rA = TT}RegDef[uSDAddr,		U,	26];	{** constant = 1100'b}RegDef[uFaultParm0,	U,	26];	{** rA = TT; fault parameter}RegDef[uTTemp,		U,	27];	{rA = TT}RegDef[uSourceHighSave,	U,	27];	{rA = TT = 2. }RegDef[UBrkByte,	U,	28];	{** loaded by LST, used by Xfer}RegDef[UTrapParm,	U,	29];	{**}RegDef[uFileNumber2,	U,	29];	{Etherbooting}RegDef[uTicks,		U,	2A];RegDef[UvL,		U,	2B];	{** rA = TT, fZ = _RH; local frame address  (VA)}RegDef[Ufsi,		U,	2C];	{rA = TT; temp used in Xfer}RegDef[UvPCpage,	U,	2D];	{** rA = TT, fZ = _ib; (PC page address)}RegDef[u1FFF,		U,	2E];	{** constant}RegDef[u7FF,		U,	2F];	{** constant}{U REGISTER BLOCK 3 -- EMULATOR}RegDef[uBlock3,		U,	30];RegDef[UQSave,		U,	31];	{BitBlt temp}	RegDef[uStackPSave,	U,	31];	{used by Block rA = L = 3}  RegDef[uPTC,		U,	32];	{** Process Tick Count}RegDef[uStkDepth,	U,	33]	{temp in Process, Xfer}RegDef[UWidthM1,	U,	34];	{BitBlt temp}	RegDef[Umask1,		U,	35];	{BitBlt temp}	RegDef[Usource,		U,	36]	{rA = L, source link of Xfer in progress}RegDef[uFaultParm1,	U,	37];	{fault parameter}RegDef[Umask2,		U,	37];	{BitBlt temp}	RegDef[UmaskL,		U,	38];	{BitBlt temp}	RegDef[uPSB,		U,	39];	{** Current PSB}RegDef[ULsave,		U,	3A];	{rA = L = 3. fZ = ErrnIBnStkp = A}RegDef[UrL,		U,	3B];	{rA = L, fZ = _RH}RegDef[UrhLsave,	U,	3B];	{bank 3, 'B' = _ rh }		RegDef[UrLHi,		U,	3C];RegDef[uCrSaveStkp,	U,	3E];	{**}RegDef[uTickCount,	U,	3F];	{** process tick interval}{U REGISTER BLOCK 4 -- EMULATOR}RegDef[uBlock4,		U,	40]:RegDef[uCrSaveTOS,	U,	40];	{**}RegDef[uCrSavePC,	U,	41];	{**}RegDef[UvQ1Hi,		U,	42];RegDef[UXsave,		U,	42];	{BitBlt temp}RegDef[UvQ1,		U,	43];RegDef[UVSsave,		U,	43];	{BitBlt temp}RegDef[UvQ2Hi,		U,	44];RegDef[USrcVALoSav,	U,	44];	{BitBlt temp}RegDef[UvQ2,		U,	45];	{rA = G}RegDef[UvQTempHi,	U,	46];RegDef[UvQTemp,		U,	47];RegDef[uIntLevel,	U,	48];	{rA = G; used in interrupts}RegDef[UrG,		U,	4B];	{rA = G, fZ = _RH}RegDef[UrhGsave,	U,	4B];	{rA = G, fZ = _RH}RegDef[UrGHi,		U,	4C];{U REGISTER BLOCK 5 -- EMULATOR}RegDef[uBlock5,		U,	50]:RegDef[UrPC,		U,	5B];	{rA = PC, fZ = _RH}RegDef[UrhPCsave,	U,	5B];	{rA = PC, fZ = _RH}RegDef[UrPCHi,		U,	5C];RegDef[UDstVALoSav,	U,	5C];	{BitBlt temp}RegDef[UreturnPC,	U,	5D];	{rA = PC, fZ = _ib}RegDef[UWidthW,		U,	5D];	{BitBlt temp}RegDef[uPCValid,	U,	5E];	{** rA = PC; flag for faults}{U REGISTER BLOCK 6 -- EMULATOR}RegDef[uBlock6,		U,	60];RegDef[ULcntsav,	U,	60];	{BitBlt temp rA = Lcount}RegDef[uRx,		U,	60];	{Xfer temp rA = Rx}RegDef[u8000,		U,	61];	{** rA = Rx; constant = 8000}RegDef[uPMask2,		U,	62];	{** rA = Rx; constant = 0FFC}RegDef[uRetC,		U,	66];	{Xfer Temp, rA = Rx}RegDef[uSourceLowSave,	U,	66];	{used by Block rA = Rx = 6}RegDef[uRetPChi,	U,	67];	{Xfer Temp, rA = Rx}RegDef[uSourceOffset,	U,	6A];	{used by Block rA = Rx = 6.  }RegDef[uDestLowSave,	U,	6B];	{Block}{U REGISTER BLOCK 7}{U REGISTER BLOCK 8}{U REGISTER BLOCK 9}{U REGISTER BLOCK A}{U REGISTER BLOCK B}{U REGISTER BLOCK C}{U REGISTER BLOCK D}RegDef[uInterruptMasks,	UY,	0D]:RegDef[uNxmExpected,	U,	0D0];RegDef[uMP,		U,	0D1];	{Current value of MP}RegDef[uInts,		U,	0D2];	{Interrupts from last time we looked}RegDef[uMisc,		U,	0D3];	{Base Address of Misc Board}RegDef[uMiscStatus,	U,	0D4];	{Status/Control reg on Misc Board}RegDef[uPhoneCSB,	U,	0D5];RegDef[uPhoneFlag,	U,	0D6];	{#0 => Use microcode}RegDef[uInt0Mask,	U,	0D8];RegDef[uInt1Mask,	U,	0D9];RegDef[uInt2Mask,	U,	0DA];RegDef[uInt3Mask,	U,	0DB];RegDef[uIntPhone,	U,	0DC];RegDef[uInt5Mask,	U,	0DD];RegDef[uInt6Mask,	U,	0DE];RegDef[uInt7Mask,	U,	0DF];{U REGISTER BLOCK E -- EMULATOR, KERNEL}RegDef[uPFlags,		U,	0EB];	{Emulator -- fZ = _RH; flags for process}RegDef[UKSaveDisp,	U,	0EF];{U REGISTER BLOCK F -- EMULATOR, KERNEL}RegDef[UPCsave,		U,	0F0];	{Emulator}RegDef[UrefillType,	U,	0F1];	{BitBlt}RegDef[uKSaveQ,		U,	0F6];RegDef[uKernAC,		U,	0F7];RegDef[u1F,		U,	0FB];	{01F'x}RegDef[uRegsKern,	U,	0FC];RegDef[uKAddr,		U,	0FC];RegDef[uKCount,		U,	0FD];RegDef[UKernMD,		U,	0FE];RegDef[UBreakID,	U,	0FF];	{UBreakID[0-3] = rK}RegDef[UKTemp,		U,	0FF];	{UBreakID = UKTemp}{KERNEL Author: R. RXG    Created: 4 Oct 79, Last Edited: R. RXG   , October 28, 1980  2:16 PM}Set[KBufferLoc, 0FF4];  {First location of overlay area, had better be even!}Set[KBufferEnd, 0FFF];Set[GetIOPByteLoc, 0FD0];Set[KBufferExtenLoc, Add[GetIOPByteLoc, 8]];Set[KBufferExtenEnd, Add[GetIOPByteLoc, 0F]];Set[KWaitLoc, 0FE0];Set[K1EntryLoc, 0F80];Set[K2EntryLoc, 0FBF];Set[K3EntryLoc, 0FCF];Set[KcLoc, 0FA0];  {WriteLink exploits the fact that IA.7=0}Set[K1ELoc, 0FB8];Set[KBELoc, 0FB9];
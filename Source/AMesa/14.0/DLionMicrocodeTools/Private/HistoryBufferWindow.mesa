-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- HistoryBufferWindow.mesa, HGM, 11-Feb-84 23:53:50DIRECTORY  Environment USING [Byte],  Format USING [StringProc],  FormSW USING [    AllocateItemDescriptor, BooleanItem, ClientItemsProcType, CommandItem,    Enumerated, EnumeratedItem, EnumeratedNotifyProcType, newLine, NumberItem, ProcType, StringItem],  Heap USING [systemZone],  Inline USING [BITAND],  Process USING [MsecToTicks],  Put USING [Char, CR, Line, Number, Text],  Runtime USING [GetBcdTime],  Selection USING [Convert],  String USING [AppendString, CopyToNewString, Empty],  TextSW USING [ForceOutput],  Time USING [Append, Unpack],  Tool USING [Create, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [    CancelPeriodicNotify, CreatePeriodicNotify, PeriodicNotifyHandle, PeriodicProcType,    UserAbort],  Version USING [Append],  Window USING [Handle],    CP USING [Cycle, RealCS, Task],  CPBreak USING [Reset],  CPCommand USING [Error, Load, LoadSymbols],  CPKernel USING [Boot, Error, StartKernel],  CPPanel USING [Initialize],  CPSymbols USING [    AppendVirturalCS, ClearSymbolTable, nullVirturalCS,    RealToVirturalCS, VirturalCS],  HBCommand USING [Arm, Error],  HistoryBuffer USING [Clocks, Error, GetInfo, ManualTrigger, SetSeeClocks, Triggered],  IOPCommand USING [Boot, Error],  Teather USING [    Continue, Error, PokeInit, ReadWord,    SetUseRom, SingleCycleFromCSA, SingleCycleFromNIA, Stop];HistoryBufferWindow: PROGRAM  IMPORTS    FormSW, Heap, Inline, Process, Put, Runtime, Selection, String,    TextSW, Time, Tool, UserInput, Version,    CPBreak, CPCommand, CPKernel, CPPanel, CPSymbols,    HBCommand, HistoryBuffer, IOPCommand, Teather =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    log, form: Window.Handle ¬ NIL;  armed, ready: BOOLEAN ¬ FALSE;  savedOffset: CARDINAL;  notifier: UserInput.PeriodicNotifyHandle;    target, filename: LONG STRING ¬ NIL;  offset: CARDINAL ¬ 100;  before, after: CARDINAL ¬ 10;  clocks: HistoryBuffer.Clocks ¬ cycle;  useRom: BOOLEAN ¬ FALSE;  clockChoices: ARRAY HistoryBuffer.Clocks OF FormSW.Enumerated ¬ [    clock: ["ARC", HistoryBuffer.Clocks[clock]],    cycle: ["Clock", HistoryBuffer.Clocks[cycle]],    click: ["Cycle1", HistoryBuffer.Clocks[click]],    ibDisp: ["IBDisp", HistoryBuffer.Clocks[ibDisp]]];    Arm: FormSW.ProcType =    BEGIN ENABLE      BEGIN      HBCommand.Error => BEGIN TailMessage[reason]; CONTINUE; END;      HistoryBuffer.Error => BEGIN TailMessage[reason]; CONTINUE; END;      END;    where: LONG STRING ¬ String.CopyToNewString[target, z];    BEGIN ENABLE UNWIND => z.FREE[@where];    IF String.Empty[where] THEN where ¬ Selection.Convert[string];    PostMessage[NIL];    ArmIt[where];    z.FREE[@where];    END;    ready ¬ FALSE;    armed ¬ TRUE;    END;  ArmIt: PROCEDURE [where: LONG STRING] =    BEGIN    HBCommand.Arm[LogString, log, where, offset];    savedOffset ¬ offset;    ready ¬ FALSE;    armed ¬ TRUE;    END;	  Display: FormSW.ProcType =    BEGIN ENABLE HistoryBuffer.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    Put.Line[log, "History Buffer contents ..."L];    ShowInfo[];    END;    ShowInfo: PROCEDURE =    BEGIN ENABLE HistoryBuffer.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    FOR i: CARDINAL IN [savedOffset-before..savedOffset+after] DO      pc: WORD;      extra: Environment.Byte;      virt: CPSymbols.VirturalCS;      observedCycle, expectedCycle: CP.Cycle;      [pc, extra] ¬ HistoryBuffer.GetInfo[i];      IF i = savedOffset THEN Put.Char[log, '*] ELSE Put.Char[log, ' ];      Put.Number[log, i, [10, FALSE, TRUE, 4]];      Put.Number[log, pc, [16, FALSE, TRUE, 6]];      Put.Text[log, "  "L];      Put.Number[log, extra, [2, TRUE, TRUE, 8]];      Put.Number[log, extra, [16, FALSE, TRUE, 4]];      IF Inline.BITAND[extra, 10B] # 0 THEN Put.Text[log, " D "L]      ELSE Put.Text[log, "   "L];      SELECT Inline.BITAND[extra, 7B] FROM        4 => BEGIN Put.Text[log, "c1"L]; observedCycle ¬ c1; END;        2 => BEGIN Put.Text[log, "c2"L]; observedCycle ¬ c2; END;        1 => BEGIN Put.Text[log, "c3"L]; observedCycle ¬ c3; END;        ENDCASE => BEGIN Put.Text[log, "c?"L]; observedCycle ¬ any; END;      [virt, expectedCycle, ] ¬ CPSymbols.RealToVirturalCS[pc];      IF virt # CPSymbols.nullVirturalCS THEN        BEGIN	temp: STRING = [100];	Put.Text[log, "  "L];        CPSymbols.AppendVirturalCS[temp, virt];	Put.Text[log, temp];	IF observedCycle # any THEN 	  BEGIN	  SELECT expectedCycle FROM	    c1 => IF observedCycle # c3 THEN Put.Text[log, " ¬¬¬¬ c3 expected"L];	    c2 => IF observedCycle # c1 THEN Put.Text[log, " ¬¬¬¬ c1 expected"L];	    c3 => IF observedCycle # c2 THEN Put.Text[log, " ¬¬¬¬ c2 expected"L];	    any => NULL;	    ENDCASE => ERROR;	  END;        END;      Put.CR[log];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.CR[log];    END;      ManualTrigger: FormSW.ProcType =    BEGIN ENABLE HistoryBuffer.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    HistoryBuffer.ManualTrigger[];    END;   Clocks: FormSW.EnumeratedNotifyProcType =    BEGIN    HistoryBuffer.SetSeeClocks[clocks];    END;    LoadArmGo: FormSW.ProcType =    BEGIN ENABLE      BEGIN      HBCommand.Error => BEGIN TailMessage[reason]; CONTINUE; END;      HistoryBuffer.Error => BEGIN TailMessage[reason]; CONTINUE; END;      CPCommand.Error => BEGIN TailMessage[reason]; CONTINUE; END;      CPKernel.Error => BEGIN TailMessage[reason]; CONTINUE; END;      IOPCommand.Error => BEGIN TailMessage[reason]; CONTINUE; END;      END;    Message["Load, Arm, and Go .."L];    CPSymbols.ClearSymbolTable[];    CPBreak.Reset[];    IOPCommand.Boot[LogString, log];    CPKernel.Boot[];    CPCommand.Load[LogString, log, filename];    CPCommand.LoadSymbols[LogString, log, filename];    ArmIt[target];    CPKernel.StartKernel[];    CPPanel.Initialize[];    Teather.SetUseRom[useRom];    END;    BB: FormSW.ProcType =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN TailMessage[reason]; CONTINUE; END;      END;    PostMessage["Poke Init ..."L];    Teather.PokeInit[];    TailMessage[" ok"L];    END;    Stop: FormSW.ProcType =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN TailMessage[reason]; CONTINUE; END;      END;    PostMessage["Stopping ..."L];    Teather.Stop[];    PrintNIA[];    END;    Step: FormSW.ProcType =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN TailMessage[reason]; CONTINUE; END;      END;    PostMessage["Stepping ..."L];    Teather.SingleCycleFromNIA[];    PrintNIA[];    END;    StepFast: FormSW.ProcType =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN TailMessage[reason]; CONTINUE; END;      END;    PostMessage["Stepping as fast as I can ..."L];    DO      Teather.SingleCycleFromNIA[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    PrintNIA[];    END;    StepFastFromCSA: FormSW.ProcType =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN TailMessage[reason]; CONTINUE; END;      END;    PostMessage["Stepping as fast as I can (SingleCycleFromCSA PATCH!!!!) ..."L];    DO      Teather.SingleCycleFromCSA[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    PrintNIA[];    END;    PrintNIA: PROCEDURE =    BEGIN    pc: WORD ¬ Teather.ReadWord[niaMsb];    virt: CPSymbols.VirturalCS;    Put.Text[log, " NIA = "L];    Put.Number[log, pc, [16, FALSE, TRUE, 0]];    [virt, , ] ¬ CPSymbols.RealToVirturalCS[pc];    IF virt # CPSymbols.nullVirturalCS THEN      BEGIN      temp: STRING = [100];      Put.Text[log, " = "L];      CPSymbols.AppendVirturalCS[temp, virt];      Put.Text[log, temp];      END;    TailMessage[NIL];    END;    Go: FormSW.ProcType =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN TailMessage[reason]; CONTINUE; END;      HistoryBuffer.Error => BEGIN TailMessage[reason]; CONTINUE; END;      END;    PostMessage["Go ..."L];    Teather.Continue[];    TailMessage[" ok"L];    END;    UseRom: FormSW.ProcType =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN PostMessage["Humm, "L]; TailMessage[reason]; CONTINUE; END;      END;    Teather.SetUseRom[useRom];    END;    Watcher: UserInput.PeriodicProcType =    BEGIN ENABLE HistoryBuffer.Error =>      BEGIN      armed ¬ FALSE;      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    IF ~armed THEN RETURN;    IF ready THEN RETURN;    IF ~HistoryBuffer.Triggered[] THEN RETURN;    ready ¬ TRUE;    Message["Triggered .."L];    ShowInfo[];    END;      LogString: Format.StringProc =    BEGIN    Put.Text[clientData, s];    END;  Message: PROCEDURE [s: LONG STRING] =    BEGIN    PostMessage[s];    TailMessage[NIL]    END;  PostMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.CR[log];    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  AppendHex: PROCEDURE [n: WORD] =    BEGIN    Put.Number[log, n, [16, FALSE, TRUE, 0]];    TextSW.ForceOutput[log]    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    Put.Line[log, "."L];    TextSW.ForceOutput[log]    END;    Initialize: PROCEDURE =    BEGIN    herald: STRING = [100];    String.AppendString[herald, "HistoryBuffer "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    [] ¬ Tool.Create[      name: herald,      cmSection: "History Buffer"L,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    Tool.UnusedLogName[logFileName, "HistoryBuffer.log$"L];    log ¬ Tool.MakeFileSW[window: window, name: logFileName, h: 100];    HistoryBuffer.SetSeeClocks[clocks];    END;      MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 17;    i: INTEGER ¬ -1;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Arm"L, proc: Arm, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.NumberItem[tag: "Before"L, notNegative: TRUE, value: @before, boxWidth: 30];    items[i¬i+1] ¬ FormSW.NumberItem[tag: "Offset"L, notNegative: TRUE, value: @offset, boxWidth: 40];    items[i¬i+1] ¬ FormSW.NumberItem[tag: "After"L, notNegative: TRUE, value: @after, boxWidth: 30];    items[i¬i+1] ¬ FormSW.StringItem[tag: "Target"L, string: @target, inHeap: TRUE];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Display"L, proc: Display, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ManualTrigger"L, proc: ManualTrigger];    items[i¬i+1] ¬ FormSW.EnumeratedItem[      tag: "Clocks"L, proc: Clocks, value: @clocks, choices: LOOPHOLE[LONG[DESCRIPTOR[clockChoices]]]];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "LoadArmGo"L, proc: LoadArmGo];    items[i¬i+1] ¬ FormSW.StringItem[tag: "File"L, string: @filename, inHeap: TRUE];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "BB"L, proc: BB, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Stop"L, proc: Stop];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Step"L, proc: Step];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "StepFast"L, proc: StepFast];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "StepFastCSA"L, proc: StepFastFromCSA];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Go"L, proc: Go];    items[i¬i+1] ¬ FormSW.BooleanItem[tag: "UseRom"L, proc: UseRom, switch: @useRom];    IF (i+1) # nParams THEN ERROR;    RETURN[items, TRUE];    END;       ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN	target ¬ z.NEW[StringBody[20]];	filename ¬ z.NEW[StringBody[20]];	notifier ¬ UserInput.CreatePeriodicNotify[Watcher, window, Process.MsecToTicks[500]];        END;      new = inactive =>        BEGIN	notifier ¬ UserInput.CancelPeriodicNotify[notifier];	z.FREE[@target];	z.FREE[@filename];        END;      ENDCASE;    END;	  Initialize[];  END.
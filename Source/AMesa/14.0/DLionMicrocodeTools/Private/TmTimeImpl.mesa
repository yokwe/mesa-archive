-- Copyright (C) 1982  by Xerox Corporation. All rights reserved. -- File: TmTimeImpl.mesa -- Last edit: DEG        26-Sep-84 21:04:11-- Last edit: ETN     16-Jul-82 13:50:34DIRECTORY  TmLabel USING [byteTiming, niblTiming, stw],  TmAssembler;TmTimeImpl: PROGRAM IMPORTS TmLabel EXPORTS TmAssembler =  BEGIN OPEN TmLabel, TmAssembler;  GetTiming: PUBLIC PROCEDURE [e: EncodingPtr] RETURNS [timingok: BOOLEAN] =    BEGIN    time: CARDINAL ¬ 0;    ADA: BOOLEAN;  -- true if the A bypass    atype: {word, byte, nibl, log};  -- what type of alu operation    IOXOut, IOYOut: BOOLEAN ¬ FALSE;    IF stw THEN RETURN[TRUE];    ADA ¬ (e.aD.value = aDA);    atype ¬      SELECT e.aF.value FROM        aFrPlusS, aFrMinusS, aFsMinusR =>          (SELECT TRUE FROM             niblTiming => nibl,             byteTiming => byte,             ENDCASE => word),        ENDCASE => log;    IF (e.fS01.value = fS01IOOut) THEN      SELECT e.fY.value FROM        fYDOAData, fYDOBData, fYMctl, fYDctl => IOYOut ¬ TRUE;        ENDCASE => IOXOut ¬ TRUE;    -- calculate time due to destination    SELECT e.aS.value FROM      aSDA, aSDQ, aSD0 =>        time ¬ MAX[  -- insures X bus used in alu          IF (e.mem.value # 1) THEN 0          ELSE            SELECT e.cy.value FROM              c1 => IF ADA THEN 45 ELSE 78,  -- MAR ¬ X op A              c2 =>                IF ADA THEN 45                ELSE                  IF (atype = word) THEN 77                  ELSE IF (atype = byte) THEN 70 ELSE 45,  -- MDR ¬ X op A              ENDCASE => 0,          IF ADA THEN 0          ELSE            IF (e.enSU.value # 1 OR e.cin.value # 1) THEN 0            ELSE              IF (atype = word) THEN 119 ELSE IF (atype = byte) THEN 112 ELSE 87,          -- SU ¬ X op A          SELECT e.fX.value FROM            fXshift =>              IF (atype = word) THEN 89 ELSE IF (atype = byte) THEN 80 ELSE 50,  -- [] ¬ X op A LShift1            fXcycle =>              IF (atype = word) THEN 99 ELSE IF (atype = byte) THEN 90 ELSE 60,  -- [] ¬ X op A LRot1            ENDCASE => 0,          SELECT e.fS01.value FROM            fS01fYNorm => IF (e.fY.value = fYstackP) THEN 48 ELSE 0,  -- stackP ¬ X op A            fS01IOOut =>              IF NOT IOYOut THEN 0              ELSE                IF (atype = word) THEN 80 ELSE IF (atype = byte) THEN 73 ELSE 48,            -- IOYOut ¬ X op A            fS01dispBr =>              SELECT e.fY.value FROM                fYNegBr => IF (atype # log) THEN 87 ELSE 58,  -- [] ¬ X op A, NegBr                fYZeroBr => IF (atype # log) THEN 95 ELSE 58,  -- [] ¬ X op A, ZeroBr                fYNZeroBr => IF (atype # log) THEN 100 ELSE 63,  -- [] ¬ X op A, NZeroBr                fYPgCarryBr => 65,  -- [] ¬ X + A, PgCrossBr                fYCarryBr => 80,  -- [] ¬ X + A, CarryBr                fYYDisp => IF (NOT ADA) THEN 68 ELSE 0,  -- [] ¬ X op A, YDisp                fYPgCr => 77,  -- [] ¬ X + A, PgCrOvDisp                ENDCASE => 0,            ENDCASE => 0,          IF ADA OR e.aD.value = aDnoWrite THEN 0          ELSE IF (atype = word) THEN 74 ELSE IF (atype = byte) THEN 66 ELSE 40  -- B ¬ X op A          ];      ENDCASE =>        IF (e.enSU.value = 1 AND e.cin.value = 1 AND NOT ADA) THEN          time ¬            IF (atype = word) THEN 154            ELSE              IF (atype = byte) THEN 150 ELSE IF (atype = nibl) THEN 128 ELSE 0;  -- SU ¬ A + B    time ¬ MAX[      time,  -- these cases are when the X bus is used directly      IF (e.fX.value = fXRH) THEN 21 ELSE 0,  -- RH ¬ X      IF (e.fS01.value = fS01dispBr AND e.fY.value = fYXDisp) THEN 26 ELSE 0,  -- [] ¬ X, XDisp      IF (e.fS01.value = fS01fYNorm AND e.fY.value = fYib) THEN 36 ELSE 0,  -- ib ¬ X      IF IOXOut THEN 22 ELSE 0  -- IOXOut ¬ X      ];    -- add time due to source    time ¬      time + MAX[        IF (e.fS2.value = fS2nibble AND e.fS3.value = fS3nibble) THEN 59 ELSE 0,  -- nibble or byte        IF (e.mem.value = 1 AND e.cy.value = c3) THEN 97 ELSE 0,  -- MD        IF (e.enSU.value = 1 AND e.cin.value = 0) THEN 75 ELSE 0,  -- SU        IF        (e.fS2.value = fS2fZNorm AND e.fS3.value = fS3fZNorm          AND e.fZ.value IN [fZLRotLo..fZLRotHi]) THEN        IF ADA THEN 91        ELSE          IF (atype = word) THEN 131          ELSE IF (atype = byte) THEN 127 ELSE IF (atype = nibl) THEN 105 ELSE 102        ELSE 0,  -- A LRot ; A + B LRot ; A or B LRot        IF (e.fS2.value = fS2IOIn AND e.fS3.value = fS3IOIn) THEN        SELECT e.fZ.value FROM          fZErrIBstkP => 59,  -- ¬ErrIBStkp          fZRH => 74,  -- ¬RH          fZib => 59,  -- ¬ib          fZibLow => 59,  -- ¬ibLow          fZibHigh => 59,  -- ¬ibHigh          ENDCASE => 63  -- ¬IOXIn other        ELSE 0];    IF (atype # log) AND (e.mem.value = 0)      AND        (e.fX.value = fXMap OR (e.fY.value = fYMap AND e.fS01.value = fS01fYNorm))      AND (e.aS.value = aSDA OR e.aS.value = aSDQ OR e.aS.value = aSD0)      AND NOT ADA THEN time ¬ 150;    IF time < 141 THEN RETURN[TRUE] ELSE RETURN[FALSE];    END;  -- end GetTiming  END...    -- Log:  -- 16-Jul-82 10:11:23 - ETN        - TrinityMass Version 1  -- Time: 26-Sep-84 21:04:06	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
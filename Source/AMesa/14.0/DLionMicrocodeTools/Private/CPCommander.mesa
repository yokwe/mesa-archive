-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- CPCommander.mesa, HGM, 21-Jan-84 15:27:03DIRECTORY  Format USING [Decimal, Line, Number, StringProc, Text],  Process USING [MsecToTicks, Pause],  String USING [AppendDecimal, AppendString, InvalidNumber, StringToNumber],  System USING [AdjustGreenwichMeanTime, GetGreenwichMeanTime, GreenwichMeanTime],    CommandFile USING [AbortProc],  CP USING [Bank, Cycle, RealCS, Task],  CPMI USING [MI],  CPCommand USING [Load, RefreshWindow],  CPBreak USING [    Break, Error, GetLastBreakInfo, InstallBreaks, RemoveBreaks, Reset, Unbreak],  CPKernel USING [    AtBreak, Boot, Continue, ContinueAfterBreak, Error, FindBanks, GetState,    LoadKernel, LoadKernelHigh, ProbeForStateChange, ReadTpc,    Reset, StartKernel, State, Stop, WriteBank, WriteTpc],  CPPanel USING [Initialize],  CPSymbols USING [    AppendRealCS, AppendVirturalCS, ClearSymbolTable, Error, GetPcCycleAndTask,    nullVirturalCS, RealToVirturalCS, VirturalCS],  IOPCommand USING [Boot, Continue, Error, Stop],  IOPKernel USING [GetState];CPCommander: PROGRAM  IMPORTS    Format, Process, String, System,    CPBreak, CPCommand, CPKernel, CPPanel, CPSymbols, IOPCommand, IOPKernel  EXPORTS CPCommand =  BEGIN  Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    Boot: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    banks: CP.Bank;    IOPCommand.Boot[log, arg, TRUE ! IOPCommand.Error => ERROR Error[reason] ];    Format.Text[log, "Booting CP ... "L, arg];    CPSymbols.ClearSymbolTable[];    CPBreak.Reset[];    CPKernel.Boot[];    Format.Text[log, "Loading Kernel ... "L, arg];    CPKernel.LoadKernel[];    CPKernel.StartKernel[];    CPPanel.Initialize[];    banks ¬ CPKernel.FindBanks[];    IF banks # 1 THEN      BEGIN      Format.Line[log, "ok."L, arg];      Format.Text[log, "This machine has "L, arg];      Format.Decimal[log, banks, arg];      Format.Text[log, " banks of control store.  Loading extra Kernels ... "L, arg];      FOR bank: CP.Bank IN [1..banks) DO        CPKernel.LoadKernelHigh[bank];        ENDLOOP;      CPKernel.WriteBank[0];      END;    PrintState[log, arg];    END;  SetBank: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      String.InvalidNumber => ERROR Error["Can't parse bank string"L];      END;    bank: CP.Bank ¬ String.StringToNumber[s];    CPKernel.WriteBank[bank];    Format.Text[log, "Now using bank "L, arg];    Format.Decimal[log, bank, arg];    Format.Line[log, "."L, arg];    END;  LoadRaw: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, filename: LONG STRING] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    CPSymbols.ClearSymbolTable[];    CPBreak.Reset[];    IOPCommand.Boot[log, arg ! IOPCommand.Error => ERROR Error[reason] ];    CPKernel.Boot[];    CPCommand.Load[log, arg, filename];    CPKernel.StartKernel[];    CPPanel.Initialize[];    END;  Reset: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    CPSymbols.ClearSymbolTable[];    CPBreak.Reset[];    CPKernel.Reset[];    CPPanel.Initialize[];    END;  SetPC: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN ENABLE CPKernel.Error => ERROR Error[reason];    pc: CP.RealCS;    cycle: CP.Cycle;    task: CP.Task;    Format.Text[log, "Setting PC to "L, arg];    Format.Text[log, s, arg];    BeSureIOPHalted[log, arg];    [pc, cycle, task] ¬ CPSymbols.GetPcCycleAndTask[s ! CPSymbols.Error => ERROR Error[reason] ];    Format.Text[log, " (task "L, arg];    Format.Number[log, task, [16, FALSE, TRUE, 0], arg];    Format.Text[log, ", .CR "L, arg];    Format.Number[log, pc, [16, FALSE, TRUE, 0], arg];    SELECT cycle FROM     c1 => NULL;     c2 => Format.Text[log, ", c2"L, arg];     c3 => Format.Text[log, ", c3"L, arg];     any => Format.Text[log, ", c*"L, arg];     ENDCASE => ERROR;    Format.Text[log, ")"L, arg];    IF cycle # c1 THEN ERROR Error["Can't set TPC to c2/c3/c*"L];    CPKernel.WriteTpc[task, pc];    Format.Line[log, "."L, arg];    END;     Continue: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, silent: BOOLEAN] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    Format.Text[log, "Continuing CP ... "L, arg];    CPKernel.ProbeForStateChange[];    BeSureIOPHalted[log, arg];    CPBreak.RemoveBreaks[];    IF CPKernel.AtBreak[] THEN      BEGIN      location, currentTpc: CP.RealCS;      cycle: CP.Cycle;      task: CP.Task;      mi: CPMI.MI;      [location, cycle, task, mi] ¬ CPBreak.GetLastBreakInfo[];      Format.Text[log, "(from Break) "L, arg];      currentTpc ¬ CPKernel.ReadTpc[task];      CPBreak.InstallBreaks[];      IF location # currentTpc THEN CPKernel.Continue[]      ELSE CPKernel.ContinueAfterBreak[mi, cycle, task];      END    ELSE      BEGIN      CPBreak.InstallBreaks[];      CPKernel.Continue[];      END;    IF IOPKernel.GetState[] # booted THEN      IOPCommand.Continue[log, arg, ~silent ! IOPCommand.Error => ERROR Error[reason] ];    -- Give easy breaks time to take => avoid double state change printout    Process.Pause[Process.MsecToTicks[250]];    IF ~silent THEN PrintState[log, arg];    CPCommand.RefreshWindow[];    END;    ContinueAndWait: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, abort: CommandFile.AbortProc, ms: LONG CARDINAL] =    BEGIN ENABLE      BEGIN      CPBreak.Error => ERROR Error[reason];      CPKernel.Error => ERROR Error[reason];      END;    start: System.GreenwichMeanTime = System.GetGreenwichMeanTime[];    stop: System.GreenwichMeanTime = System.AdjustGreenwichMeanTime[start, (ms+999)/1000];    Continue[log, arg, FALSE];    DO      CPKernel.ProbeForStateChange[];      IF CPKernel.GetState[] # running THEN EXIT;      Process.Pause[Process.MsecToTicks[500]];      IF abort[] THEN ERROR Error["UserAborted (STOP)"L];      IF ms = 0 THEN LOOP;  -- Forever case      IF System.GetGreenwichMeanTime[] > stop THEN ERROR Error["Didn't stop in time"L];      ENDLOOP;    CPBreak.RemoveBreaks[];    PrintState[log, arg];    CPCommand.RefreshWindow[];    END;    Stop: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE CPKernel.Error => ERROR Error[reason];    Format.Text[log, "Stopping CP ... "L, arg];    CPKernel.Stop[];    PrintState[log, arg];    CPCommand.RefreshWindow[];    END;    Break: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN    pc: CP.RealCS;    cycle: CP.Cycle;    task: CP.Task;    Format.Text[log, "Setting CP Break at "L, arg];    Format.Text[log, s, arg];    Format.Text[log, " = "L, arg];    [pc, cycle, task] ¬ CPSymbols.GetPcCycleAndTask[s ! CPSymbols.Error => ERROR Error[reason] ];    Format.Text[log, ".CR "L, arg];    Format.Number[log, pc, [16, FALSE, TRUE, 0], arg];    IF cycle = any THEN ERROR Error["Can't set breaks on c*"L];    CPBreak.Break[pc, cycle, task ! CPBreak.Error => ERROR Error[reason] ];    Format.Line[log, " ok."L, arg];    SELECT cycle FROM     c1 => NULL;     c2, c3 => Format.Line[log, "*** Warning: c2/c3 breaks are a bit flakey"L, arg];     ENDCASE => ERROR;    END;    Unbreak: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN    pc: CP.RealCS;    cycle: CP.Cycle;    task: CP.Task;    Format.Text[log, "Clearing CP Break at "L, arg];    IF s # NIL THEN Format.Text[log, s, arg]    ELSE      BEGIN      Format.Text[log, "current break"L, arg];      IF ~CPKernel.AtBreak[] THEN ERROR Error["Not at Break"L];      END;    Format.Text[log, " = "L, arg];    IF s = NIL THEN      BEGIN      [pc, cycle, task, ] ¬ CPBreak.GetLastBreakInfo[];      END    ELSE [pc, cycle, task] ¬ CPSymbols.GetPcCycleAndTask[s ! CPSymbols.Error => ERROR Error[reason] ];    Format.Text[log, ".CR "L, arg];    Format.Number[log, pc, [16, FALSE, TRUE, 0], arg];    CPBreak.Unbreak[pc, cycle, task ! CPBreak.Error => ERROR Error[reason] ];    Format.Line[log, " ok."L, arg];    END;      PrintState: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN    state: CPKernel.State = CPKernel.GetState[];    SELECT state FROM      dead => Format.Text[log, "CP and/or IOP is dead"L, arg];      halted => Format.Text[log, "CP halted"L, arg];      running => Format.Text[log, "CP is running"L, arg];      cpBreak =>        BEGIN	temp: STRING = [200];	location: CP.RealCS;        cycle: CP.Cycle;        task: CP.Task;	virt: CPSymbols.VirturalCS;        CPBreak.RemoveBreaks[ ! CPBreak.Error => ERROR Error[reason] ];        [location, cycle, task, ] ¬ CPBreak.GetLastBreakInfo[];	[virt, , ] ¬ CPSymbols.RealToVirturalCS[location];	Format.Text[log, "CP Break at "L, arg];        CPSymbols.AppendRealCS[temp, location];	IF virt # CPSymbols.nullVirturalCS THEN	  BEGIN	  String.AppendString[temp, ", ("L];          CPSymbols.AppendVirturalCS[temp, virt];	  String.AppendString[temp, ")"L];	  END;	String.AppendString[temp, ", task "L];	String.AppendDecimal[temp, task];	String.AppendString[temp, ", "L];        AppendCycle[temp, cycle];	Format.Text[log, temp, arg];	END;      iopStopped => Format.Text[log, "IOP stopped"L, arg];      ENDCASE => ERROR;    Format.Line[log, "."L, arg];    END;      AppendCycle: PROCEDURE [s: LONG STRING, cycle: CP.Cycle] =    BEGIN    SELECT cycle FROM      c1 => String.AppendString[s, "c1"L];      c2 => String.AppendString[s, "c2"L];      c3 => String.AppendString[s, "c3"L];      any => String.AppendString[s, "c*"L];      ENDCASE => ERROR;    END;   BeSureIOPHalted: PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN    SELECT IOPKernel.GetState[] FROM      dead => ERROR Error["IOP dead"L];      booted, halted, iopBreak, cpStop => RETURN;      running => IOPCommand.Stop[log, arg ! IOPCommand.Error => ERROR Error[reason] ];      ENDCASE => ERROR;    END;      END.
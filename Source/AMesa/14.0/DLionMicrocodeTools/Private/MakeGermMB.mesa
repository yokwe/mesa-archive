-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- MakeGermMB.mesa, HGM, 30-Oct-83  6:36:52-- MakeGermMB.~ Out.mb ¬ In.germDIRECTORY  Ascii USING [CR],  Environment USING [bytesPerWord],  Exec USING [    AddCommand, ExecProc, FreeTokenString, GetToken, Outcome, OutputProc],  Format USING [Line, StringProc],  MFile USING [Acquire, dontRelease, Error, GetCreateDate, Handle, Release],  MStream USING [Create, GetLength],  Stream USING [Delete, GetByte, Handle, PutByte, PutString, PutWord],  String USING [AppendChar, AppendLongDecimal, AppendString, Empty, Equal],  Time USING [Append, Unpack];MakeGermMB: PROGRAM  IMPORTS Exec, Format, MFile, MStream, Stream, String, Time =  BEGIN  memoryName: STRING = "Germ";    bytesInOneChip: CARDINAL = 8192;  -- 2764 = 8K x 8  headerWords: CARDINAL = 256;  -- For other parms and such  headerBytes: CARDINAL = Environment.bytesPerWord*headerWords;  MakeGermMB: Exec.ExecProc =    BEGIN    bytes: LONG CARDINAL;    info: STRING = [100];    output: Format.StringProc = Exec.OutputProc[h];    outName, separater, inName, switches: LONG STRING ¬ NIL;    in, out: Stream.Handle ¬ NIL;    inFile, outFile: MFile.Handle;    temp: STRING = [300];    free, chips: LONG CARDINAL;    Cleanup: PROC [s: STRING] =      BEGIN      IF s # NIL THEN Format.Line[output, s];      outName ¬ Exec.FreeTokenString[outName];      separater ¬ Exec.FreeTokenString[separater];      inName ¬ Exec.FreeTokenString[inName];      IF in # NIL THEN Stream.Delete[in];      IF out # NIL THEN Stream.Delete[out];      END;    [outName, switches] ¬ Exec.GetToken[h];    switches ¬ Exec.FreeTokenString[switches];    [separater, switches] ¬ Exec.GetToken[h];    switches ¬ Exec.FreeTokenString[switches];    [inName, switches] ¬ Exec.GetToken[h];    switches ¬ Exec.FreeTokenString[switches];    IF String.Empty[outName] THEN {      Cleanup["Output filename is empty."L]; RETURN[error]};    IF String.Empty[inName] THEN {      Cleanup["Input filename is empty."L]; RETURN[error]};    IF ~String.Equal[separater, "¬"L] THEN {      Cleanup["Separater must be ""¬""."L]; RETURN[error]};    inFile ¬ MFile.Acquire[      name: inName, access: readOnly, release: MFile.dontRelease !      MFile.Error =>        BEGIN Cleanup["Can't read Input File"L]; GOTO GetOutOfHere; END];    outFile ¬ MFile.Acquire[      name: outName, access: writeOnly, release: MFile.dontRelease !      MFile.Error =>        BEGIN        MFile.Release[inFile];        Cleanup["Can't write Output File"L];        GOTO GetOutOfHere;        END];    in ¬ MStream.Create[inFile, [NIL, NIL]];    out ¬ MStream.Create[outFile, [NIL, NIL]];    String.AppendString[info, inName];    String.AppendString[info, " of "L];    Time.Append[info, Time.Unpack[MFile.GetCreateDate[inFile].create]];    Stream.PutWord[out, 4]; -- 4 => define memory    Stream.PutWord[out, 2]; -- memory #    Stream.PutWord[out, 16];    Stream.PutString[out, info];  -- Asciz string    Stream.PutByte[out, 0];    IF (info.length MOD 2) = 0 THEN Stream.PutByte[out, 0];    Stream.PutWord[out, 4]; -- 4 => define memory    Stream.PutWord[out, 1]; -- only one memory    Stream.PutWord[out, 8]; -- bits ber word    Stream.PutString[out, memoryName];  -- Asciz string    Stream.PutByte[out, 0];    IF (memoryName.length MOD 2) = 0 THEN Stream.PutByte[out, 0];    bytes ¬ MStream.GetLength[in];    IF (bytes MOD 2) # 0 THEN       BEGIN      Cleanup["The input file has an odd number of bytes."L];      RETURN[error];      END;    Stream.PutWord[out, 2];  -- 2 => Set Current Memory    Stream.PutWord[out, 1];  -- only one memory    Stream.PutWord[out, headerBytes];  -- location counter    FOR i: LONG CARDINAL IN [0..bytes) DO      Stream.PutWord[out, 1];  -- 1 => Memory Contents      Stream.PutWord[out, 0];  -- Source line number      Stream.PutByte[out, Stream.GetByte[in]];  -- Left justified      Stream.PutByte[out, 0];  -- 2 bytes per word      ENDLOOP;    Stream.PutWord[out, 0];  -- 0 => End of file        chips ¬ (bytes + headerBytes + bytesInOneChip - 1) / bytesInOneChip;    free ¬ (chips * bytesInOneChip) - bytes - headerBytes;    String.AppendString[temp, outName];    String.AppendString[temp, " contains "L];    String.AppendLongDecimal[temp, bytes];    String.AppendString[temp, " bytes."L];    String.AppendChar[temp, Ascii.CR];    String.AppendString[temp, "That's "L];    String.AppendLongDecimal[temp, chips];    String.AppendString[temp, " chips and "L];    String.AppendLongDecimal[temp, free];    String.AppendString[temp, " free bytes."L];    String.AppendChar[temp, Ascii.CR];    Exec.OutputProc[h][temp];        Cleanup[NIL];    RETURN[normal];    EXITS GetOutOfHere => RETURN[error];    END;  Exec.AddCommand["MakeGermMB.~", MakeGermMB];  END...
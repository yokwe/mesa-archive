-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CPKernelBreaker.mesa, HGM,  7-Mar-83 17:14:50  -- This code works on both the DLion and Dicentra.  One critical factor is that FYNorm 0 and 1 (Enter/Exit Kernel) don't do anything nasty on Dicentra.  DIRECTORY  Inline USING [BITAND, BITSHIFT],  CP USING [Bank, Cycle, RealCS, UReg, Task, wordsPerBank],  CPKernel USING [Byte, Nibble],  CPKernelConstants ,  CPKernelOps USING [GetStateInternal, ReadURegInternal, WriteCSInternal, WriteTpcInternal],  CPMI USING [MI],  IOPKernelOps USING [lock, InitializeLock];CPKernelBreaker: MONITOR LOCKS IOPKernelOps.lock  IMPORTS Inline, CPKernelOps, IOPKernelOps  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelConstants;    Nibble: TYPE = CPKernel.Nibble;  Byte: TYPE = CPKernel.Byte;  currentBreakID: CARDINAL;  AtBreak: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] =    BEGIN RETURN[CPKernelOps.GetStateInternal[] = cpBreak]; END;    SaveCurrentBreakID: PUBLIC INTERNAL PROCEDURE =    BEGIN    currentBreakID ¬ CPKernelOps.ReadURegInternal[uBreakID];    END;    GetBreakID: PUBLIC ENTRY PROCEDURE RETURNS [CARDINAL] =    BEGIN RETURN[currentBreakID]; END;      SetBreak: PUBLIC ENTRY PROCEDURE [pc: CP.RealCS, cycle: CP.Cycle, id: Byte] =    BEGIN    idH: Nibble ¬ Inline.BITAND[Inline.BITSHIFT[id, -4], 17B];    idL: Nibble ¬ Inline.BITAND[id, 17B];    IF pc ~IN CP.RealCS THEN ERROR;    SELECT cycle FROM      c1 =>        IF id < 16 THEN	  BEGIN          --RHrK ¬ BreakID, EnterKernel, DISP4[k1Entry], c1;          CPKernelOps.WriteCSInternal[            pc, CPMI.MI[            , rK, , , , , , , , , nibble, loadRH, [n[enterKernel]], [d[idL]], k1Entry]];	  END	ELSE	  BEGIN  -- Dicentra, EnterKernel not needed          --RHrK ¬ BreakID, DISP4[k1Entry], c1;          CPKernelOps.WriteCSInternal[            pc, CPMI.MI[            , rK, , , , , , , , byte, nibble, loadRH, [d[idH]], [d[idL]], k1Entry]];	  END;      c2 =>      --RHrK ¬ BreakID, CANCELBR[k2Entry, 0F], c2;      CPKernelOps.WriteCSInternal[        pc, CPMI.MI[        , rK, , , , , , , , byte, nibble, loadRH, [d[idH]], [d[idL]], k2Entry]];      c3 =>      --RHrK ¬ BreakID, CANCELBR[k3Entry, 0F], c3;      CPKernelOps.WriteCSInternal[        pc, CPMI.MI[        , rK, , , , , , , , byte, nibble, loadRH, [d[idH]], [d[idL]], k3Entry]];      ENDCASE => ERROR;      END;  PrepareToContinueAfterBreak: PUBLIC INTERNAL PROCEDURE [    mi: CPMI.MI, cycle: CP.Cycle, task: CP.Task, bank: CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    offset: CARDINAL;    IF task = 0 THEN offset ¬ bank * CP.wordsPerBank    ELSE offset ¬ 0;    SELECT cycle FROM      c1 =>        --kBuffer+4: Noop, c1;        --           Noop, c2;        --           Xbus ¬ UKSaveDisp, XDisp, c3;        --           <copy of original c1 inst>, c1;        BEGIN        CPKernelOps.WriteCSInternal[          kBuffer + offset + 4, CPMI.MI[          , , , , , , , , , , , , , , kBuffer + 5]];        CPKernelOps.WriteCSInternal[          kBuffer + offset + 5, CPMI.MI[          , , , , , , , , , , , , , , kBuffer + 6]];        CPKernelOps.WriteCSInternal[          kBuffer + offset + 6, CPMI.MI[          uKSaveDispH, , , , , , , TRUE, , dispBr, uAddr, , [b[xDisp]], [d[uKSaveDispL]], kBuffer + 7]];        CPKernelOps.WriteCSInternal[kBuffer + offset + 7, mi];        END;      c2 =>        --kBuffer+4: Xbus ¬ UKSaveDisp, XDisp, c1;        --           <copy of original c2 inst>, c2;        BEGIN        CPKernelOps.WriteCSInternal[          kBuffer + offset + 4, CPMI.MI[          uKSaveDispH, , , , , , , TRUE, , dispBr, uAddr, , [b[xDisp]], [d[uKSaveDispL]], kBuffer + 5]];        CPKernelOps.WriteCSInternal[kBuffer + offset + 5, mi];        END;      c3 =>        -- kBuffer+4: Noop, c1;        --            Xbus ¬ UKSaveDisp, XDisp, c2;        --            <copy of original c3 inst>, c3;        BEGIN  --write register before microinstruction        CPKernelOps.WriteCSInternal[          kBuffer + offset + 4, CPMI.MI[          , , , , , , , , , , , , , , kBuffer + 5]];        CPKernelOps.WriteCSInternal[          kBuffer + offset + 5, CPMI.MI[          uKSaveDispH, , , , , , , TRUE, , dispBr, uAddr, , [b[xDisp]], [d[uKSaveDispL]], kBuffer + 6]];        CPKernelOps.WriteCSInternal[kBuffer + offset + 6, mi];        END;      ENDCASE => ERROR;    CPKernelOps.WriteTpcInternal[task, kBuffer + offset + 4];    END;	  [] ¬ IOPKernelOps.InitializeLock[];  END.
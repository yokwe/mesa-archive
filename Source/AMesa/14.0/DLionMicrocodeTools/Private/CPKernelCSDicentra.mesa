-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CPKernelCSDicentra.mesa, HGM, 13-Nov-83  2:21:27DIRECTORY  Environment USING [Block, Byte],  Inline USING [BITSHIFT, BITXOR, HighByte, LowByte],  CP USING [RealCS, wordsPerBank],  CPKernel USING [CSBlock, Error, OneMI],  CPKernelConstants ,  CPKernelOps USING [AddressOutOfRange, SetNewState, WriteCPWord],  CPMI USING [AD, AF, AS, FS01, FS23, FX, FY, FZ, MI],  IOPKernelOps USING [lock, InitializeLock],  Teather USING [Error, ReadBlock, WriteBlock, WriteWord];CPKernelCSDicentra: MONITOR LOCKS IOPKernelOps.lock  IMPORTS    Inline, CPKernel, CPKernelOps, IOPKernelOps, Teather  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelConstants;      WriteCS: PUBLIC ENTRY PROCEDURE [real: CP.RealCS, mi: CPMI.MI] =    BEGIN ENABLE UNWIND => NULL; WriteCSInternal[real, mi] END;  WriteCSInternal: PUBLIC INTERNAL PROCEDURE [real: CP.RealCS, mi: CPMI.MI] =    BEGIN    realMi: MIReal ¬ VirturalToReal[mi];    IF real ~IN CP.RealCS THEN CPKernelOps.AddressOutOfRange[];    FixParity[@realMi];    WriteMIRealInternal[real, @realMi]    END;  WriteCSBad: PUBLIC ENTRY PROCEDURE [real: CP.RealCS, mi: CPMI.MI] =    BEGIN ENABLE UNWIND => NULL; WriteCSBadInternal[real, mi] END;  WriteCSBadInternal: PUBLIC INTERNAL PROCEDURE [real: CP.RealCS, mi: CPMI.MI] =    BEGIN    realMi: MIReal ¬ VirturalToReal[mi];    IF real ~IN CP.RealCS THEN CPKernelOps.AddressOutOfRange[];    FixParity[@realMi];    realMi.ep ¬ ~realMi.ep;    WriteMIRealInternal[real, @realMi]    END;  -- Parity better be right  WriteMIRealInternal: INTERNAL PROCEDURE [real: CP.RealCS, mi: LONG POINTER TO MIReal] =    BEGIN ENABLE      Teather.Error => BEGIN CPKernelOps.SetNewState[dead]; CPKernel.Error[reason]; END;    words: LONG POINTER = mi;    temp: PACKED ARRAY [0..8) OF Environment.Byte;    block: Environment.Block ¬ [LOOPHOLE[LONG[@temp]], 0, 8];    IF FALSE THEN      BEGIN      CPKernelOps.WriteCPWord[real];        -- Send CSAddr[0-11]      CPKernelOps.WriteCPWord[(words+0)­];  -- Write CS[0-15]      CPKernelOps.WriteCPWord[(words+1)­];  -- Write CS[16-31]      CPKernelOps.WriteCPWord[(words+2)­];  -- Write CS[32-47]      RETURN;      END;    temp[0] ¬ Inline.HighByte[real];    temp[1] ¬ Inline.LowByte[real];    temp[2] ¬ Inline.HighByte[(words+0)­];    temp[3] ¬ Inline.LowByte[(words+0)­];    temp[4] ¬ Inline.HighByte[(words+1)­];    temp[5] ¬ Inline.LowByte[(words+1)­];    temp[6] ¬ Inline.HighByte[(words+2)­];    temp[7] ¬ Inline.LowByte[(words+2)­];    Teather.WriteBlock[csaMsb, block];    END;  WriteCSBlock: PUBLIC ENTRY PROCEDURE [count: CARDINAL, clump: LONG POINTER TO CPKernel.CSBlock] =    BEGIN ENABLE UNWIND => NULL;    WriteCSBlockInternal[count, @clump[0]];    END;  WriteCSBlockInternal: PUBLIC INTERNAL PROCEDURE [count: CARDINAL, clump: LONG POINTER TO CPKernel.OneMI] =    BEGIN ENABLE      Teather.Error => BEGIN CPKernelOps.SetNewState[dead]; CPKernel.Error[reason]; END;    finger: CARDINAL ¬ 0;    bytesPerMi: CARDINAL = 8;    bufferSize: CARDINAL = 10*bytesPerMi;    temp: PACKED ARRAY [0..bufferSize) OF Environment.Byte;    block: Environment.Block ¬ [LOOPHOLE[LONG[@temp]], 0, bufferSize];    IF FALSE THEN      BEGIN      FOR i: CARDINAL IN [0..count) DO        real: MIReal ¬ VirturalToReal[clump.mi];        FixParity[@real];	WriteMIRealInternal[clump.real, @real];        clump ¬ clump + SIZE[CPKernel.OneMI];	ENDLOOP;      RETURN;      END;    FOR i: CARDINAL IN [0..count) DO      real: MIReal ¬ VirturalToReal[clump.mi];      words: POINTER = @real;      FixParity[@real];      temp[finger + 0] ¬ Inline.HighByte[clump.real];      temp[finger + 1] ¬ Inline.LowByte[clump.real];      temp[finger + 2] ¬ Inline.HighByte[(words+0)­];      temp[finger + 3] ¬ Inline.LowByte[(words+0)­];      temp[finger + 4] ¬ Inline.HighByte[(words+1)­];      temp[finger + 5] ¬ Inline.LowByte[(words+1)­];      temp[finger + 6] ¬ Inline.HighByte[(words+2)­];      temp[finger + 7] ¬ Inline.LowByte[(words+2)­];      finger ¬ finger + bytesPerMi;      IF finger = bufferSize THEN        BEGIN        Teather.WriteBlock[csaMsb, block];	finger ¬ 0;	END;      clump ¬ clump + SIZE[CPKernel.OneMI];      ENDLOOP;    IF finger # 0 THEN      BEGIN      block.stopIndexPlusOne ¬ finger;      Teather.WriteBlock[csaMsb, block];      END;    END;  FixParity: PROCEDURE [data: LONG POINTER TO MIReal] =    BEGIN    words: LONG POINTER = data;    parity: WORD ¬ 0;    data.ep ¬ FALSE;    FOR i: CARDINAL IN [0..SIZE[MIReal]) DO      parity ¬ Inline.BITXOR[parity, (words+i)­];      ENDLOOP;    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -8]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -4]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -2]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -1]];    data.ep ¬ LOOPHOLE[parity];    END;  ReadCS: PUBLIC ENTRY PROCEDURE [real: CP.RealCS] RETURNS [CPMI.MI] =    BEGIN ENABLE UNWIND => NULL; RETURN[ReadCSInternal[real]] END;  ReadCSInternal: PUBLIC INTERNAL PROCEDURE [real: CP.RealCS] RETURNS [CPMI.MI] =    BEGIN ENABLE      Teather.Error => BEGIN CPKernelOps.SetNewState[dead]; CPKernel.Error[reason]; END;    block: Environment.Block ¬ [LOOPHOLE[LONG[@data]], 0, 2*SIZE[MIReal]];    data: MIReal;    IF real ~IN CP.RealCS THEN CPKernelOps.AddressOutOfRange[];    Teather.WriteWord[csaMsb, real];    Teather.ReadBlock[csData0, block];    RETURN[RealToVirtural[data]];    END;  MIReal: TYPE = MACHINE DEPENDENT RECORD [    rA, rB: Nibble,    aS: CPMI.AS, aF: CPMI.AF,    aD: CPMI.AD,  --word 0    ep, cIn, enSU, mem: BOOLEAN,    fS01: CPMI.FS01, fS23: CPMI.FS23,    fX: CPMI.FX, fY: CPMI.FY,  --word 1    fZ: CPMI.FZ, inia: [0..CP.wordsPerBank)];  --word 2  -- See also FixupMI in MakeControlStoreMB  VirturalToReal: PROCEDURE [virtural: CPMI.MI] RETURNS [real: MIReal] =    BEGIN    mir: POINTER TO MIReal = @real;    miv: POINTER TO CPMI.MI = @virtural;    BEGIN OPEN miv;    mir­ ¬ [      rA, rB, aS, aF, aD, ep, cIn, enSU, mem, fS01, fS23, fX, fY, fZ, Inline.BITXOR[inia,17B]]    END    END;  RealToVirtural: PROCEDURE [real: MIReal] RETURNS [virtural: CPMI.MI] =    BEGIN    mir: POINTER TO MIReal = @real;    miv: POINTER TO CPMI.MI = @virtural;    BEGIN OPEN mir;    miv­ ¬ [      rA, rB, aS, aF, aD, ep, cIn, enSU, mem, fS01, fS23, fX, fY, fZ, Inline.BITXOR[inia,17B]]    END;    END;  [] ¬ IOPKernelOps.InitializeLock[];  END.
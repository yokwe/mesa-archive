-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- MakeBurdockGerm.mesa     26-Sep-84 16:27:39 by DEG     <<This program produces three real memory image files of a germ, suitable for using with the Burdock Real Memory Load command.The real memory image contains the initial memory map, the germ, and the unused real memory. Note that the Boot.Request that the invoker of the germ must supply is also written into the germ's memory.This program reads an germ boot file, as produced by MakeBoot, and produces PilotDLion.germRM, PilotDLion256K.germRM, and PilotDLion384K.germRM. It runs under the MDE Exec.Command line to the Exec:    >MakeBurdockGerm.~ DLion.germIf no input germ file name is given, DLion.germ is assumed.See RMRecordFormat below for the format of the records in the real memory file. The file is terminated by a record with length=0.>>DIRECTORY  Boot,  DeviceTypes,  DLionInputOutput,  Environment,  Exec,  Inline,  MFile,  MStream,  PageMap,  Stream,  System,  TTY;MakeBurdockGerm: PROGRAM  IMPORTS Environment, Exec, Inline, MFile, MStream, Stream, TTY =  BEGIN OPEN DIO: DLionInputOutput;    debugging: BOOLEAN = FALSE;  -- Parameters:  defaultInputFileName: STRING = "DLion.germ";  outputFileName: STRING = "PilotDLion.germRM";  output256kFileName: STRING = "PilotDLion256K.germRM";  output384kFileName: STRING = "PilotDLion384K.germRM";  output768kFileName: STRING = "PilotDLion768K.germRM";  output1024kFileName: STRING = "PilotDLion1024K.germRM";  -- TYPEs.  RMRecordFormat: TYPE = MACHINE DEPENDENT RECORD [    -- The format wanted by Burdock.    length: CARDINAL,    realAddressHigh: WORD,  -- High order bits of real memory address    realAddressLow: WORD,  -- Low order bits of real memory address    data: ARRAY [0..0) OF WORD];  -- actually [0..length)    eofRecord: RMRecordFormat ¬ [    length: 0, realAddressHigh: 0, realAddressLow: 0, data: NULL];    RealAddress: TYPE = LONG CARDINAL;  RealPageCount: TYPE = CARDINAL;  mapWordRealModulus: CARDINAL = 256;  MapWordLow: TYPE = [0..mapWordRealModulus);  MapWordRealHigh: TYPE = [0..16);  DLionMapWord: TYPE = MACHINE DEPENDENT RECORD [    realLow: MapWordLow, logSingle: BOOLEAN ¬ FALSE,    flags: PageMap.Flags, realHigh: MapWordRealHigh];  -- DLion memory map entry for a virtual page.  vacant: DLionMapWord = [    realLow: 0, logSingle: FALSE, flags: PageMap.flagsVacant, realHigh: 0];  -- Layout of real memory:  <<DisplayRealPage: TYPE = DIO.RealPageNumber    [DIO.firstReservedPage..DIO.firstReservedPage+CARDINAL[DIO.reservedPageCount]);>>  MapRealPage: TYPE = DIO.RealPageNumber    [DIO.firstMapPage..DIO.firstMapPage+CARDINAL[DIO.mapPagesCount]);  firstVanillaRealPage: DIO.RealPageNumber = MapRealPage.LAST+1;    ioRealPage: DIO.RealPageNumber =  DIO.ioPageNumber;  -- Layout of virtual memory:  ioVirtualPage: Environment.PageNumber = 377B;  -- SHOULD be in DLionInputOutput!  pageGermMDS: Environment.PageNumber =    Boot.mdsiGerm * Environment.maxPagesInMDS;  firstGermVirtPage: Environment.PageNumber = pageGermMDS + Boot.pageGerm;    firstGFTVirtPage: Environment.PageNumber = 512;      <<lastGermMDSVirtPage: Environment.PageNumber =    firstGermMDSVirtPage+Environment.maxPagesInMDS-1;>>      <<GermMDSVirtPage: TYPE = Environment.PageNumber    [firstGermMDSVirtPage..firstGermMDSVirtPage+Environment.maxPagesInMDS);>>  wordsPerPage: CARDINAL = Environment.wordsPerPage;  WordOfPage: TYPE = [0..wordsPerPage);  PageOfData: TYPE = ARRAY WordOfPage OF WORD;  Run: Exec.ExecProc --[h: Exec.Handle, clientData]--  =    BEGIN    givenInputFileName, switches, actualInputFileName: LONG STRING;    tty: TTY.Handle = Exec.GetTTY[h];    inputFile: MFile.Handle;    [givenInputFileName, switches] ¬ Exec.GetToken[h];    actualInputFileName ¬ givenInputFileName;  -- assume.    IF givenInputFileName = NIL THEN {      TTY.PutLine[tty, "No input file given. DLion.germ assumed."L];      actualInputFileName ¬ defaultInputFileName};    BEGIN  --scope of Exit--    inputFile ¬ MFile.Acquire[name: actualInputFileName, access: anchor, release: [] !      MFile.Error --[file, code]-- =>        BEGIN        TTY.PutString[tty, " Input file "L];        TTY.PutString[tty, actualInputFileName];        IF code = noSuchFile THEN	  TTY.PutLine[tty, " does not exist."L]	ELSE TTY.PutLine[tty, ": errors acquiring."L];        GOTO Exit;	END];    TTY.PutString[tty, "Reading "L];    TTY.PutString[tty, actualInputFileName];    TTY.PutLine[tty, ".. "L];    --MakeBurdockRealMemFile[k192, actualInputFileName, outputFileName, tty];    --MakeBurdockRealMemFile[k256, actualInputFileName, output256kFileName, tty];    MakeBurdockRealMemFile[k384, actualInputFileName, output384kFileName, tty];    --MakeBurdockRealMemFile[k768, actualInputFileName, output768kFileName, tty];    --MakeBurdockRealMemFile[k1024, actualInputFileName, output1024kFileName, tty];    TTY.PutLine[tty, " done."L];    MFile.Release[inputFile];    EXITS Exit => NULL;    END;  --scope of Exit--    givenInputFileName ¬ Exec.FreeTokenString[givenInputFileName];    switches ¬ Exec.FreeTokenString[switches];    Exec.ReleaseTTY[tty];    END;  MakeBurdockRealMemFile: PROC [    size: {k192, k256, k384, k768, k1024}, inputFileName,     outputFileName: LONG STRING,    tty: TTY.Handle] =    -- Note that the caller guarantees that inputFileName exists.    BEGIN    inputFile, outputFile: Stream.Handle ¬ NIL;    mapWordsOfGermsMDS: ARRAY WordOfPage OF DLionMapWord;    TTY.PutString[tty, "Creating "L];    TTY.PutString[tty, outputFileName];    TTY.PutString[tty, ".. "L];    BEGIN  --scope of Exit--    ENABLE UNWIND => {      IF inputFile # NIL THEN Stream.Delete[inputFile];      IF outputFile # NIL THEN Stream.Delete[outputFile]};    outputFile ¬ MStream.ReadWrite[outputFileName, [], binary !      MFile.Error --[file, code]-- =>        BEGIN        TTY.PutString[tty, "Trouble acquiring "L];        TTY.PutString[tty, inputFileName];	TTY.PutLine[tty, ". Skipped."L];        GOTO Exit;	END];    inputFile ¬ MStream.ReadOnly[inputFileName, []];    -- Create and output memory map real pages:    BEGIN    mapWords: ARRAY WordOfPage OF DLionMapWord;    realMemoryCount: RealPageCount = (     SELECT size FROM      k192 => 256*3, k256 => 256*4, k384 => 256*6, k768 => 256*12,       k1024 => 256*16,      ENDCASE => ERROR);    virtual: Environment.PageNumber ¬ 0;    realForVirtual: DIO.RealPageNumber ¬ firstVanillaRealPage;    vanillaRealPagesRemaining: RealPageCount ¬      realMemoryCount      - CARDINAL[DIO.reservedPageCount] - CARDINAL[DIO.mapPagesCount];    IF debugging THEN TTY.PutCR[tty];    FOR realForMap: MapRealPage IN MapRealPage DO      firstVirtualOfMapPage: Environment.PageNumber ¬ virtual;      FOR outputIndex: WordOfPage IN WordOfPage DO	SELECT virtual FROM	  pageGermMDS => {	    mapWords[outputIndex] ¬ vacant;	    realForVirtual ¬ realForVirtual.SUCC;	    };	  ioVirtualPage => {	    mapWords[outputIndex] ¬ [	      realLow: ioRealPage MOD mapWordRealModulus,	      logSingle: FALSE, flags: PageMap.flagsClean,	      realHigh: ioRealPage/mapWordRealModulus];	    };	  firstGFTVirtPage => {	    mapWords[outputIndex] ¬ [	      realLow: firstVanillaRealPage MOD mapWordRealModulus,	      logSingle: FALSE, flags: PageMap.flagsClean,	      realHigh: firstVanillaRealPage/mapWordRealModulus];	    };	  ENDCASE => {	    mapWords[outputIndex] ¬ (	      IF vanillaRealPagesRemaining > 0 THEN [		realLow: realForVirtual MOD mapWordRealModulus,		logSingle: FALSE, flags: PageMap.flagsClean,		realHigh: realForVirtual/mapWordRealModulus]	      ELSE vacant);	    IF (realForVirtual ¬ realForVirtual.SUCC) = ioRealPage	    THEN realForVirtual ¬ realForVirtual.SUCC;	    };	IF mapWords[outputIndex] # vacant AND debugging THEN {	  temppage: CARDINAL ¬ 	    (mapWords[outputIndex].realHigh * mapWordRealModulus) + mapWords[outputIndex].realLow;	  TTY.PutNumber[tty, outputIndex, [base: 16]];	  TTY.PutText[tty, ": "L];	  TTY.PutNumber[tty, temppage, [base: 16]];	  TTY.PutText[tty, ", "L];	  };        virtual ¬ virtual.SUCC;        -- realForVirtual has already been bumped.        IF vanillaRealPagesRemaining > 0 THEN          vanillaRealPagesRemaining ¬ vanillaRealPagesRemaining.PRED;        ENDLOOP;      IF firstVirtualOfMapPage = pageGermMDS THEN        mapWordsOfGermsMDS ¬ mapWords;  -- save for later.      OutputPage[        stream: outputFile, realPage: realForMap,	data: @LOOPHOLE[mapWords, PageOfData]];      ENDLOOP;    tty.PutCR[];    END;  --writing map--    -- Write germ real memory image:    BEGIN    requestVirtPage: Environment.PageNumber =      Environment.PageFromLongPointer[Boot.pRequest];    requestVirtPageStart: LONG POINTER =      Environment.LongPointerFromPage[requestVirtPage];    IF Environment.PageFromLongPointer[Boot.pRequest + Boot.Request.SIZE]      # requestVirtPage THEN ERROR;  -- request crosses page boundary.    FOR germVirtPage: Environment.PageNumber ¬ pageGermMDS, germVirtPage + 1 DO      data: PageOfData;      germRealPage: Environment.PageNumber =        firstVanillaRealPage + germVirtPage;      [] ¬ Stream.GetBlock[inputFile, [LOOPHOLE[LONG[@data]], 0, 512]];      IF germVirtPage = requestVirtPage THEN        BEGIN  -- write Request into germ's memory        requestInData: LONG POINTER TO Boot.Request =          LOOPHOLE[@data, POINTER TO Boot.Request].LONG            + (Boot.pRequest - requestVirtPageStart);        requestInData­ ¬ [          requestBasicVersion: Boot.currentRequestBasicVersion,          action: Boot.bootPhysicalVolume,          location: [            deviceType: DeviceTypes.anyPilotDisk, deviceOrdinal: 0,            vp: TRASH],          switches: System.defaultSwitches,          requestExtensionVersion: Boot.currentRequestExtensionVersion,	  pStartListHeader: TRASH,	  inLoadMode: TRASH,	  session: TRASH];	  END;      OutputPage[outputFile, CARDINAL[germRealPage], @data];      IF debugging THEN {	TTY.PutLongNumber[tty, germVirtPage, [base:16, columns: 8]];	TTY.PutLongNumber[tty, germRealPage, [base:16, columns: 8]];	tty.PutCR[]; };      IF MStream.EndOf[inputFile] THEN EXIT;      ENDLOOP;    -- Output empty block to terminate file:    Stream.PutBlock[        outputFile,	[LOOPHOLE[LONG[@eofRecord]], 0,	  RMRecordFormat.SIZE * Environment.bytesPerWord]];    Stream.Delete[outputFile];    outputFile ¬ NIL;    Stream.Delete[inputFile];    inputFile ¬ NIL;    END;  --writing germ--    EXITS Exit => NULL;    END;  --scope of Exit--    END;  --MakeBurdockRealMemFile--  OutputPage: PROC [    stream: Stream.Handle, realPage: DIO.RealPageNumber,    data: LONG POINTER TO PageOfData] =    -- Writes length, addrHi, addrLo, data.    BEGIN    realAddr: RealAddress = Inline.LongMult[realPage, wordsPerPage];    Stream.PutWord[stream, wordsPerPage];    Stream.PutWord[stream, Inline.HighHalf[realAddr]];    Stream.PutWord[stream, Inline.LowHalf[realAddr]];    Stream.PutBlock[stream, [LOOPHOLE[data], 0, Environment.bytesPerPage]];    END;  --OutputPage--  -- MAIN  Exec.AddCommand["MakeBurdockGerm", Run];  END.LOG??? 9-Feb-82 20:55:46   JXF        ??? 7-Jun-83  9:50:22   wDK        Converted to Sierra. Now takes germ file name from command line. Documented operation. Added execution feedback and error messages. Ditch blanket OPEN.26-Jul-83 16:28:05   wDK        pRequest changed for 11.0b bootstrap.26-Jul-83 16:28:05   wDK        Rework to use defs files instead of private copies of constants and types. Define lots of types and constants. Redo crufty logic. Use better names. Document. Add logic for ioRealPage not being first vanilla page.16-Sep-83 17:41:46	DEG       Converted to Klamath 11.0b.  On MStream.ReadWrite added the type of file being binary.12-Oct-83 10:42:50   AEF        Move the ioVirtualPage for larger VMTime: 26-Sep-84 16:27:36	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
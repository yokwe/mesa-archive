-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- IOPKerneler.mesa, HGM,  4-Oct-83 23:31:04DIRECTORY  Environment USING [Block, Byte],  Inline USING [BITOR, BITAND, BytePair, HighByte, LowByte],  Put USING [CR, Line],  String USING [AppendNumber, AppendString],    IOP USING [Address, Instruction, LengthOfInstruction, Register, RegPair, UnimplimentedInstruction],  IOPKernel USING [State],  IOPKernelOps USING [Command, Response],  Umbilical USING [    Boot, Initialize, maxBytesInBuffer, ReadByte, ReadReady, ReadWord, Timeout,    WriteBlock, WriteByte, WriteWord];IOPKerneler: MONITOR LOCKS lock  IMPORTS Inline, Put, String, IOP, Umbilical  EXPORTS IOPKernel, IOPKernelOps =  BEGIN  Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    state: IOPKernel.State ¬ dead;  seq, boot: CARDINAL ¬ 0;    lock: PUBLIC MONITORLOCK;  InKernel: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] =    BEGIN ENABLE UNWIND => NULL;    RETURN[SELECT state FROM      dead => FALSE,      booted, halted => TRUE,      running => FALSE,      iopBreak, cpStop => TRUE,      ENDCASE => ERROR ];    END;        GetState: PUBLIC ENTRY PROCEDURE RETURNS [IOPKernel.State] =    BEGIN ENABLE UNWIND => NULL;    RETURN[state];    END;  GetStateInternal: PUBLIC INTERNAL PROCEDURE RETURNS [IOPKernel.State] =    BEGIN    RETURN[state];    END;  GetStateSeq: PUBLIC ENTRY PROCEDURE RETURNS [CARDINAL] =    BEGIN ENABLE UNWIND => NULL;    RETURN[seq];    END;    GetBootSeq: PUBLIC ENTRY PROCEDURE RETURNS [CARDINAL] =    BEGIN ENABLE UNWIND => NULL;    RETURN[boot];    END;      GetBootSeqInternal: PUBLIC INTERNAL PROCEDURE RETURNS [CARDINAL] =    BEGIN RETURN[boot]; END;    ProbeForStateChange: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    ProbeForStateChangeInternal[];    END;  ProbeForStateChangeInternal: PUBLIC INTERNAL PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    IF state = running AND Umbilical.ReadReady[] THEN      BEGIN  -- It's trying to tell us something      GetResponse[];      END;    END;  Boot: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    BootInternal[];    END;      BootInternal: PUBLIC INTERNAL PROCEDURE =    BEGIN    temp: IOPKernelOps.Response;    SetNewState[dead];    IF ~Umbilical.Initialize[] THEN ERROR Error["Can't talk to Umbilical box"L];    boot ¬ boot + 1;    Umbilical.Boot[];    temp ¬ ReadResponseInternal[];    SELECT temp FROM      LOOPHOLE[0] => ERROR Error["HGM is confused (initial response)"L];      iopGreeting => NULL;      ENDCASE => ERROR Error["IOP Seems confused (initial response)"L];    WriteCommandInternal[iopColdStart];    temp ¬ ReadResponseInternal[];    SELECT temp FROM      atKernelStart => NULL;      diagnosticsFailed => ERROR Error["Diagnostics failed"L];      ENDCASE => ERROR Error["IOP Seems confused (second response)"L];    SetNewState[booted];    GetConfigurationInternal[];    END;      Stop: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    StopHelper[];    END;      StopInternal: PUBLIC INTERNAL PROCEDURE =    BEGIN    StopHelper[];    IF state = halted THEN SetNewState[cpStop];    END;    StopHelper: PUBLIC INTERNAL PROCEDURE =    BEGIN    SELECT state FROM      dead => ERROR Error["IOP dead"L];      booted, halted, iopBreak, cpStop => RETURN;      running => NULL;      ENDCASE => ERROR;    IF ~Umbilical.ReadReady[] THEN WriteCommandInternal[interrupt];  --  ******** RACE HERE    GetResponse[];    END;  lastResponse: IOPKernelOps.Response;  -- global for debuging  GetResponse: INTERNAL PROCEDURE =    BEGIN    SELECT lastResponse ¬ ReadResponseInternal[] FROM      atKernelStart => SetNewState[booted];  -- Proceed after Boot      debugStop => SetNewState[halted];      iopBreak => SetNewState[iopBreak];      cpBreak => SetNewState[cpStop];      ENDCASE =>         BEGIN	temp: STRING = [40];        SetNewState[dead];	String.AppendString[temp, "Unexpected stop code = "L];	String.AppendNumber[temp, lastResponse, 16];        Put.CR[NIL];	Put.Line[NIL, temp];        END;    END;  Continue: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    ContinueInternal[];    END;      ContinueInternal: PUBLIC INTERNAL PROCEDURE =    BEGIN    BeSureInKernel[];    IF state = booted THEN ERROR Error["IOP PC hasn't been set yet"L];    WriteCommandInternal[iopStart];    SetNewState[running];    END;  ReadMemory: PUBLIC ENTRY PROCEDURE [ra: IOP.Address] RETURNS [data: Environment.Byte] =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    data ¬ ReadMemoryInternal[ra];    END;  ReadMemoryWord: PUBLIC ENTRY PROCEDURE [ra: IOP.Address] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    bytes: Inline.BytePair;    BeSureInKernel[];    bytes.low ¬ ReadMemoryInternal[ra];    bytes.high ¬ ReadMemoryInternal[ra + 1];    RETURN[LOOPHOLE[bytes]];    END;  ReadMemoryInternal: INTERNAL PROCEDURE [a: IOP.Address] RETURNS [data: Environment.Byte] =    BEGIN    WriteCommandInternal[memoryRead];    WriteWordInternal[a];    WriteByteInternal[1];    data ¬ ReadByteInternal[];    END;  ReadMemoryBlock: PUBLIC ENTRY PROCEDURE [    a: IOP.Address, n: CARDINAL, target: LONG POINTER] =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    WriteCommandInternal[memoryRead];    WriteWordInternal[a];    WriteByteInternal[n];    THROUGH [0..n) DO target­ ¬ ReadByteInternal[]; target ¬ target + 1; ENDLOOP;    END;  ReadWordInternal: PUBLIC INTERNAL PROCEDURE RETURNS [data: WORD] =    BEGIN    RETURN[Umbilical.ReadWord[! Umbilical.Timeout => Timeout[]]];    END;  ReadResponseInternal: PROCEDURE RETURNS [response: IOPKernelOps.Response] = LOOPHOLE[ReadByteInternal];  ReadByteInternal: PUBLIC INTERNAL PROCEDURE RETURNS [data: Environment.Byte] =    BEGIN    RETURN[Umbilical.ReadByte[! Umbilical.Timeout => Timeout[]]];    END;  WriteMemory: PUBLIC ENTRY PROCEDURE [ra: IOP.Address, data: Environment.Byte] =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    WriteMemoryInternal[ra, data];    END;  WriteMemoryWord: PUBLIC ENTRY PROCEDURE [ra: IOP.Address, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    WriteMemoryInternal[ra, Inline.LowByte[data]];    WriteMemoryInternal[ra + 1, Inline.HighByte[data]];    END;  WriteMemoryInternal: INTERNAL PROCEDURE [a: IOP.Address, data: Environment.Byte] =    BEGIN    WriteCommandInternal[memoryWrite];    WriteWordInternal[a];    WriteByteInternal[1];    WriteByteInternal[data];    END;    WriteMemoryBlock: PUBLIC ENTRY PROCEDURE [address: IOP.Address, data: Environment.Block] =    BEGIN ENABLE UNWIND => NULL;    temp: PACKED ARRAY [0..300) OF Environment.Byte;    finger: CARDINAL ¬ 4;    bytes: CARDINAL ¬ data.stopIndexPlusOne - data.startIndex;    IF bytes = 0 OR bytes > 255 THEN ERROR;    BeSureInKernel[];    IF FALSE THEN      BEGIN      WriteCommandInternal[memoryWrite];      WriteWordInternal[address];      WriteByteInternal[bytes];      WriteBlockInternal[data];      RETURN;      END;    temp[0] ¬ LOOPHOLE[IOPKernelOps.Command[memoryWrite]];    temp[1] ¬ Inline.LowByte[address];    temp[2] ¬ Inline.HighByte[address];    temp[3] ¬ bytes;    FOR i: CARDINAL IN [data.startIndex..data.stopIndexPlusOne) DO      temp[finger] ¬ LOOPHOLE[data.blockPointer[i]];      finger ¬ finger + 1;      ENDLOOP;    WriteBlockInternal[[LOOPHOLE[LONG[@temp]], 0, finger]];    END;  WriteBlockInternal: PUBLIC INTERNAL PROCEDURE [data: Environment.Block] =    BEGIN    bytes: CARDINAL ¬ data.stopIndexPlusOne - data.startIndex;    IF bytes = 0 OR bytes > Umbilical.maxBytesInBuffer THEN ERROR;    Umbilical.WriteBlock[data ! Umbilical.Timeout => Timeout[] ];    END;  WriteWordInternal: PUBLIC INTERNAL PROCEDURE [data: WORD] =    BEGIN    Umbilical.WriteWord[data ! Umbilical.Timeout => Timeout[] ];    END;  WriteCommandInternal: PUBLIC PROCEDURE [command: IOPKernelOps.Command] = LOOPHOLE[WriteByteInternal];  WriteByteInternal: PUBLIC INTERNAL PROCEDURE [data: Environment.Byte] =    BEGIN    Umbilical.WriteByte[data ! Umbilical.Timeout => Timeout[] ];    END;  ReadInstruction: PUBLIC ENTRY PROCEDURE [ra: IOP.Address]    RETURNS [ins: IOP.Instruction] =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    ins.byte2 ¬ ins.byte3 ¬ 0;    ins.operation ¬ ReadMemoryInternal[ra];    ins.length ¬ IOP.LengthOfInstruction[ins.operation !      IOP.UnimplimentedInstruction => UnimplimentedInstruction[]];    IF ins.length > 1 THEN ins.byte2 ¬ ReadMemoryInternal[ra + 1];    IF ins.length > 2 THEN ins.byte3 ¬ ReadMemoryInternal[ra + 2];    END;    UnimplimentedInstruction: PROCEDURE =    BEGIN    ERROR Error["Unimplemented Instruction"L];    END;  WriteInstruction: PUBLIC ENTRY PROCEDURE [ra: IOP.Address, ins: IOP.Instruction] =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    WriteMemoryInternal[ra, ins.operation];    IF ins.length > 1 THEN WriteMemoryInternal[ra + 1, ins.byte2];    IF ins.length > 2 THEN WriteMemoryInternal[ra + 2, ins.byte3];    END;      ReadRegister: PUBLIC ENTRY PROCEDURE [reg: IOP.Register] RETURNS [data: Environment.Byte] =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    data ¬ ReadSavedRegister[reg];    END;      ReadSavedRegister: INTERNAL PROCEDURE [reg: IOP.Register] RETURNS [data: Environment.Byte] =    BEGIN ENABLE UNWIND => NULL;    data ¬ ReadMemoryInternal[saveArea + saveOffsetOfRegister[reg]];    END;      WriteRegister: PUBLIC ENTRY PROCEDURE [reg: IOP.Register, data: Environment.Byte] =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    WriteSavedRegister[reg, data];    END;      WriteSavedRegister: INTERNAL PROCEDURE [reg: IOP.Register, data: Environment.Byte] =    BEGIN    WriteMemoryInternal[saveArea + saveOffsetOfRegister[reg], data];    END;    ReadPC: PUBLIC PROCEDURE RETURNS [IOP.Address] =    BEGIN RETURN[ReadPair[pc]]; END;  ReadPair: PUBLIC ENTRY PROCEDURE [pair: IOP.RegPair] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    highReg, lowReg: IOP.Register;    highData, lowData: Environment.Byte;    BeSureInKernel[];    SELECT pair FROM      bc => BEGIN highReg ¬ b; lowReg ¬ c; END;      de => BEGIN highReg ¬ d; lowReg ¬ e; END;      hl => BEGIN highReg ¬ h; lowReg ¬ l; END;      sp => BEGIN highReg ¬ spH; lowReg ¬ spL; END;      psw => BEGIN highReg ¬ flags; lowReg ¬ a; END;      pc => BEGIN highReg ¬ pcH; lowReg ¬ pcL; END;      ENDCASE => ERROR;    highData ¬ ReadSavedRegister[highReg];    lowData ¬ ReadSavedRegister[lowReg];    data ¬ highData * 256 + lowData;    END;      WritePC: PUBLIC PROCEDURE [pc: IOP.Address] =    BEGIN WritePair[pc, pc]; END;  WritePair: PUBLIC ENTRY PROCEDURE [pair: IOP.RegPair, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    highReg, lowReg: IOP.Register;    highData, lowData: Environment.Byte;    BeSureInKernel[];    SELECT pair FROM      bc => BEGIN highReg ¬ b; lowReg ¬ c; END;      de => BEGIN highReg ¬ d; lowReg ¬ e; END;      hl => BEGIN highReg ¬ h; lowReg ¬ l; END;      sp => BEGIN highReg ¬ spH; lowReg ¬ spL; END;      psw => BEGIN highReg ¬ flags; lowReg ¬ a; END;      pc => BEGIN highReg ¬ pcH; lowReg ¬ pcL; END;      ENDCASE => ERROR;    highData ¬ Inline.HighByte[data];    lowData ¬ Inline.LowByte[data];    WriteSavedRegister[highReg, highData];    WriteSavedRegister[lowReg, lowData];    IF pair = pc AND state = booted THEN SetNewState[halted];    END;      BeSureInKernel: INTERNAL PROCEDURE =    BEGIN    finkyDebugger: BOOLEAN ¬ TRUE;    IF finkyDebugger THEN SELECT state FROM      dead => ERROR Error["IOP is dead"L];      booted, halted => NULL;      running => ERROR Error["IOP is running"L];      iopBreak, cpStop => NULL;      ENDCASE => ERROR;    END;  Timeout: INTERNAL PROCEDURE =    BEGIN    finkyDebugger: BOOLEAN ¬ TRUE;    SetNewState[dead];    IF finkyDebugger THEN ERROR Error["Timeout"L];    END;    GetConfigurationInternal: INTERNAL PROCEDURE =    BEGIN    WriteCommandInternal[getConfig];    [] ¬ ReadWordInternal[];  -- Prom size    [] ¬ ReadWordInternal[];  -- RAM start    [] ¬ ReadWordInternal[];  -- Memroy size    [] ¬ ReadWordInternal[];  -- Stack start    saveArea ¬ ReadWordInternal[];    [] ¬ ReadWordInternal[];    END;      IOPRetransmit: PUBLIC INTERNAL PROCEDURE [data: Environment.Byte] =    BEGIN    flags: Environment.Byte;    WriteMemoryInternal[saveArea + iopInDataSaveOffset, data];    flags ¬ ReadMemoryInternal[saveArea + iopKernelFlagsOffset];    flags ¬ Inline.BITOR[flags, iopKernelFlagsInDataFull];    WriteMemoryInternal[saveArea + iopKernelFlagsOffset, flags];    END;      NeedForCPToRetransmit: PUBLIC INTERNAL PROCEDURE RETURNS [yes: BOOLEAN] =    BEGIN    flags: Environment.Byte;    flags ¬ ReadMemoryInternal[saveArea + iopKernelFlagsOffset];    RETURN[Inline.BITAND[flags, iopKernelFlagsOutDataFull] # 0];    END;      GetCPData: PUBLIC INTERNAL PROCEDURE RETURNS [data: Environment.Byte] =    BEGIN    RETURN[ReadMemoryInternal[saveArea + iopOutDataSaveOffset]];    END;         saveArea: IOP.Address;  iopInDataSaveOffset: INTEGER = -1;  iopOutDataSaveOffset: INTEGER = -2;  iopKernelFlagsOffset: INTEGER = -3;    iopKernelFlagsInDataFull: CARDINAL = 100B;    iopKernelFlagsOutDataFull: CARDINAL = 200B;    saveOffsetOfRegister: ARRAY IOP.Register OF CARDINAL = [    b: 3,  -- Save B    c: 2,  -- Save C    d: 5,  -- Save D    e: 4,  -- Save E    h: 7,  -- Save H    l: 6,  -- Save L    m: 0,  -- should never be used    a: 1,  -- Save Acc    pcH: 9,  -- Save PCH    pcL: 8,  -- Save PCL    spH: 11,  -- Save SPH    spL: 10,  -- Save SPL    flags: 0,  -- Save Flags    rim: 12];  -- Save RIM        SetNewState: INTERNAL PROCEDURE [new: IOPKernel.State] =    BEGIN    state ¬ new;    seq ¬ seq + 1;    END;    InitializeLock: PUBLIC PROCEDURE = BEGIN END;    END.
-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- CommandFiler.mesa, DEG     , 27-Jan-85  9:10:45DIRECTORY  Ascii USING [CR, NUL],  Format USING [CR, Date, Line, LongDecimal, StringProc, Text],  Heap USING [Create, Delete, systemZone],  Inline USING [LowHalf],  MStream USING [Error, GetLength, ReadOnly, WriteOnly],  Process USING [SecondsToTicks, SetTimeout, Yield],  ProcessorFace USING [SetMP],  Stream USING [    Delete, EndOfStream, GetChar, GetPosition, Handle, Position,    PutChar, PutString, SetPosition],  String USING [    AppendExtensionIfNeeded, AppendString, AppendChar, AppendNumber,    AppendSubString, CopyToNewString, Equal,    StringBoundsFault, SubString, SubStringDescriptor],  System USING [GetClockPulses, GetGreenwichMeanTime, Pulses, PulsesToMicroseconds],  Time USING [AppendCurrent],  CommandFile USING [AbortProc],  CPCommand USING [    Boot, Break, Compare, Continue, ContinueAndWait,    Error, Load, LoadBootFile, LoadGerm, LoadReal, LoadSymbols, Reset,    SetBank, SetPC, SetVmEnumItem, Stop, Unbreak],  CPPanel USING [Clear, GetPanel],  HBCommand USING [Arm, Error],  IOPCommand USING [    Boot, Break, Continue, ContinueAndWait, Error,    Load, LoadModuleSymbols, LoadSymbols, SetPC, Stop, Unbreak],  IOPPanel USING [Clear, GetPanel],  PanelSW USING [    ClientError, Handle, ModifyLH, nilTileIndex, ReadTile, TileError, TileIndex,    TileIndexFromRowColumn, WriteTile],  StringExtras USING [    BlankCharacter, CheckHexString, CheckLongHexString,    InvalidHexString, NextToken, TrimString],  SymHash USING [    Create, Destroy, GetInfo, GetString, Handle, Hash,    Insert, Lookup, nullHash, PutInfo];CommandFiler: MONITOR  IMPORTS    Format, Heap, Inline, MStream, StringExtras, Process, ProcessorFace,    Stream, String, System, Time,    CPCommand, CPPanel, HBCommand, IOPCommand, IOPPanel,    PanelSW, SymHash  EXPORTS CommandFile =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  KeyRec: TYPE = RECORD [s: LONG STRING, t: Type, function: PROCEDURE ¬ Noop];  Noop: PROCEDURE = BEGIN END;  Type: TYPE = {Null, Loc, Break, String, Tag, Function, StringConstant};  KeyDomain: TYPE = {    alterAddress, arm, boot, bootIOP, break, breakIOP, buffer,    clearCPPanel, clearIOPPanel, close, compare, continue, contintueIOP,    cp, goTo, if, iop, load, loadBoot, loadMore, loadNoSymbols,    loadIOP, loadIOPModuleSymbols, loadIOPNoSymbols, loadIOPSymbols,    loadGerm, loadReal, openToAppend, openToWrite,    reset, setBank, setMP, start, startIOP, stop, stopIOP,    unbreak, unbreakIOP, write, writeLine, writeLoc, writeTime, setVMSize};  BreakRec: TYPE = RECORD [c: CHARACTER, r: PROCEDURE];  BreakDomain: TYPE = {    colon, semi, shriek, arrow, oldArrow, quote, less, equal, notEqual, greater, openBrace,    openBracket, closeBracket, closeBrace, comment};  RelationDomain: TYPE = BreakDomain [less..openBrace];  Relation: TYPE = {x, gt, eq, ne, lt, le, ge};  SymbolValue: TYPE = RECORD [    SELECT type: Type FROM      Tag => [si: Stream.Position],      String => [s: LONG STRING],      Loc => [panel: Panel, x, y: CARDINAL],      Function => [apply: PROCEDURE],      Null, Break => NULL,      ENDCASE];  StackCell: TYPE = RECORD [    type: Type,    p: LONG POINTER,    v: UNSPECIFIED,    previous: LONG POINTER TO StackCell];  Panel: TYPE = {CP, IOP};  Error: PUBLIC ERROR [reason: LONG STRING, position: Stream.Position] = CODE;    Trouble: ERROR [message: LONG STRING] = CODE;    running: BOOLEAN ¬ FALSE;  waitTillDone: CONDITION;  SomebodyRunning: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] =    BEGIN RETURN[running]; END;    StartRunning: ENTRY PROCEDURE [abort: CommandFile.AbortProc] =    BEGIN    WHILE running DO      IF abort[] THEN ERROR Trouble["UserAborted"L ! UNWIND => NULL];      WAIT waitTillDone;      ENDLOOP;    running ¬ TRUE;    END;  StopRunning: ENTRY PROCEDURE =    BEGIN    running ¬ FALSE;    NOTIFY waitTillDone;    END;  CommandsFromFile: PUBLIC PROCEDURE [      log: Format.StringProc, arg: LONG POINTER, abort: CommandFile.AbortProc, file: LONG STRING] =    BEGIN    start, stop: System.Pulses;    ms: LONG CARDINAL;    stream: Stream.Handle;    filename: LONG STRING;    start ¬ System.GetClockPulses[];    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "burdock"L, z];    Format.Date[log, System.GetGreenwichMeanTime[], dateTime, ANSI, arg];    Format.Text[log, "  Running commands from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] !      MStream.Error => ERROR Error["Can't open input file"L, 0] ];    CommandsFromStream[log, arg, abort, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to run "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    z.FREE[@filename];    END;        CommandsFromStream: PUBLIC PROCEDURE [      log: Format.StringProc, arg: LONG POINTER, abort: CommandFile.AbortProc, stream: Stream.Handle] =    BEGIN          stack: LONG POINTER TO StackCell;    output: Stream.Handle ¬ NIL;    limbo: CHARACTER;    heap: UNCOUNTED ZONE ¬ NIL;    symbols: SymHash.Handle;    in: LONG STRING;  --input buffer--    sc: LONG STRING;  --string constant--    lastBreak: BreakDomain;    rssd: String.SubStringDescriptor;    tssd: String.SubStringDescriptor;    rest: String.SubString ¬ @rssd;    token: String.SubString ¬ @tssd;    braces: INTEGER;    stopCommands: BOOLEAN;        -- Oops, these go away when things are deactivated    cpHandle: PanelSW.Handle = CPPanel.GetPanel[];    iopPanel: PanelSW.Handle = IOPPanel.GetPanel[];  keys: ARRAY KeyDomain OF KeyRec ¬ [    alterAddress: ["AlterAddress"L, Function, AlterAddress],    arm: ["Arm"L, Function, Arm],    boot: ["Boot"L, Function, Boot],    bootIOP: ["BootIOP"L, Function, BootIOP],    break: ["Break"L, Function, Break],    breakIOP: ["BreakIOP"L, Function, BreakIOP],    buffer: ["Buffer"L, String],    clearCPPanel: ["ClearCPPanel"L, Function, ClearCPPanel],    clearIOPPanel: ["ClearIOPPanel"L, Function, ClearIOPPanel],    close: ["Close"L, Function, CloseLog],    compare: ["Compare"L, Function, Compare],    continue: ["Continue"L, Function, Continue],    contintueIOP: ["ContinueIOP"L, Function, ContinueIOP],    cp: ["CP"L, Loc],    goTo: ["GOTO"L, Function, GoTo],    if: ["IF"L, Break],    iop: ["IOP"L, Loc],    load: ["Load"L, Function, Load],    loadBoot: ["LoadBoot"L, Function, LoadBoot],    loadMore: ["LoadMore"L, Function, LoadMore],    loadNoSymbols: ["LoadNoSymbols"L, Function, LoadNoSymbols],    loadIOP: ["LoadIOP"L, Function, LoadIOP],    loadIOPModuleSymbols: ["LoadIOPModuleSymbols"L, Function, LoadIOPModuleSymbols],    loadIOPNoSymbols: ["LoadIOPNoSymbols"L, Function, LoadIOPNoSymbols],    loadIOPSymbols: ["LoadIOPSymbols"L, Function, LoadIOPSymbols],    loadGerm: ["LoadGerm"L, Function, LoadGerm],    loadReal: ["LoadReal"L, Function, LoadReal],    openToAppend: ["OpenToAppend"L, Function, OpenToAppend],    openToWrite: ["OpenToWrite"L, Function, OpenToWrite],    reset: ["Reset"L, Function, Reset],    setBank: ["SetBank"L, Function, SetBank],    setMP: ["SetMP"L, Function, SetMP],    start: ["Start"L, Function, Start],    startIOP: ["StartIOP"L, Function, StartIOP],    stop: ["Stop"L, Function, Stop],    stopIOP: ["StopIOP"L, Function, StopIOP],    unbreak: ["Unbreak"L, Function, Unbreak],    unbreakIOP: ["UnbreakIOP"L, Function, UnbreakIOP],    write: ["Write"L, Function, Write],    writeLine: ["WriteLine"L, Function, WriteLine],    writeLoc: ["WriteLoc"L, Function, WriteLoc],    writeTime: ["WriteTime"L, Function, WriteTime],    setVMSize: ["SetVMSize"L, Function, SetVMSize]];  Breaks: ARRAY BreakDomain OF BreakRec ¬ [    colon: [':, DoColon],    semi: [';, DoSemi],    shriek: ['!, DoShriek],    arrow: ['¬, DoBack],    oldArrow: ['_, DoBack],    quote: ['", DoQuote],    less: ['<, DoLess],  --all relationals are bracketed by < and {    equal: ['=, DoEqual],  --see definition of RelationDomain below    notEqual: ['#, DoNotEqual],    greater: ['>, DoGreater],    openBrace: ['{, DoOpenBrace],    openBracket: ['[, DoOpenBracket],    closeBracket: ['], DoCloseBracket],    closeBrace: ['}, DoCloseBrace],    comment: ['|, DoComment]];  LegalRelations: ARRAY RelationDomain OF ARRAY RelationDomain OF Relation =    --     <   =  #  >  {       --    [    --<-- [x, le, x, x, lt],    --=-- [le, x, x, ge, eq],    --#-- [x, x, x, x, ne],    -->-- [x, ge, x, x, gt],    --{-- [x, x, x, x, x]];    EvaluateTile: PROCEDURE [h: PanelSW.Handle, x, y: CARDINAL]      RETURNS [s: LONG STRING] =      BEGIN      ti: PanelSW.TileIndex = PanelSW.TileIndexFromRowColumn[h, x, y];      IF ti = PanelSW.nilTileIndex THEN ERROR Trouble["No Tile there => Window Reset?"L];      s ¬ PanelSW.ReadTile[h, [right, ti] !	PanelSW.TileError => ERROR Trouble["Can't do that"L];        PanelSW.ClientError => ERROR Trouble[msg] ];      END;    VisibleTile: PROCEDURE [h: PanelSW.Handle, x, y: CARDINAL] RETURNS [BOOLEAN] =      BEGIN      ti: PanelSW.TileIndex = PanelSW.TileIndexFromRowColumn[h, x, y];      RETURN[ti # PanelSW.nilTileIndex]      END;    symbolSize: CARDINAL = SIZE[SymbolValue];    CommandLoop: PROCEDURE =      BEGIN ENABLE        BEGIN        Trouble => ERROR Error[message, Stream.GetPosition[stream]];        Stream.EndOfStream =>           IF stack = NIL THEN CONTINUE ELSE ERROR Error["Unexpected end of file"L, Stream.GetPosition[stream]];        CPCommand.Error => BEGIN ERROR Trouble[reason]; END;        HBCommand.Error => BEGIN ERROR Trouble[reason]; END;        IOPCommand.Error => BEGIN ERROR Trouble[reason]; END;        END;      UNTIL stopCommands DO        ReadPhrase[];        Breaks[lastBreak].r;        Process.Yield[];	IF abort[] THEN ERROR Trouble["UserAborted"L];        ENDLOOP;      END;    ReadPhrase: PROCEDURE =      BEGIN      c: CHARACTER;      in.length ¬ 0;      UNTIL GotBreak[c ¬ Read[]] --sets lastBreak-- DO        String.AppendChar[          s: in, c: c !          String.StringBoundsFault =>            BEGIN	    ns ¬ heap.NEW[StringBody [s.length*2]];            String.AppendString[to: ns, from: s];            heap.FREE[@s];            in ¬ ns;            RESUME            END]        ENDLOOP;      token­ ¬ [in, 0, 0];      rest­ ¬ [in, 0, in.length];      END;    ReleaseStructures: PROCEDURE =      BEGIN      stopCommands ¬ TRUE;      IF output # NIL THEN Stream.Delete[output];      SymHash.Destroy[symbols];      Heap.Delete[heap];      heap ¬ NIL;      END;    --action routines--    DoQuote: PROCEDURE =      BEGIN      c: CHARACTER;      sc.length ¬ 0;      IF (c ¬ Read[]) = '" THEN RETURN;      limbo ¬ c;      DO        BEGIN        ENABLE          String.StringBoundsFault =>            BEGIN	    ns ¬ heap.NEW[StringBody [s.length*2]];            String.AppendString[to: ns, from: s];            heap.FREE[@s];            sc ¬ ns;            RESUME            END;        IF (c ¬ Read[]) # '" THEN          BEGIN String.AppendChar[s: sc, c: c]; LOOP END;        IF (c ¬ Read[]) = '" THEN          BEGIN String.AppendChar[s: sc, c: c]; LOOP END;        limbo ¬ c;        RETURN        END        ENDLOOP      END;    DoComment: PROCEDURE =      BEGIN      DO        ReadPhrase[];        SELECT lastBreak FROM quote => DoQuote[]; comment => EXIT; ENDCASE;        ENDLOOP;      END;    DoColon: PROCEDURE =      BEGIN      h: SymHash.Hash;      here: Stream.Position = Stream.GetPosition[stream];      sv: LONG POINTER TO SymbolValue;      id: LONG STRING;      IF ~NextID[] THEN ERROR Trouble["Illegal or Null Tag"L];      id ¬ StringFromSubString[token];      BEGIN      ENABLE UNWIND => heap.FREE[@id];      h ¬ SymHash.Lookup[symbols, id];      IF h # SymHash.nullHash THEN        BEGIN        sv ¬ SymHash.GetInfo[symbols, h];        WITH sv SELECT FROM          Tag => IF si # here THEN MultiplyDefined[] ELSE RETURN;          ENDCASE => MultiplyDefined[];        END;      h ¬ SymHash.Insert[symbols, id];      sv ¬ heap.NEW[SymbolValue ¬ [Tag[here]]];      SymHash.PutInfo[symbols, h, sv]      END;      heap.FREE[@id];      END;    DoEqual: PROCEDURE =      BEGIN      h: SymHash.Hash;      sv: LONG POINTER TO SymbolValue;      xNew, yNew: CARDINAL;      panelNew: Panel;      IF DidCondition[] --does a NextID-- THEN RETURN;      PushSubString[token];      [] ¬ NextID[];      IF token.length # 0 THEN ERROR Trouble["Garbage before equal"L];      ReadPhrase[];      IF lastBreak # openBracket THEN        BEGIN        Push[Break, NIL, BreakDomain[equal]];        Breaks[lastBreak].r;        RETURN;        END;      DoOpenBracket[];      SELECT stack.type FROM        Loc =>          BEGIN          panelNew ¬ LOOPHOLE[stack.p, LONG POINTER TO Loc SymbolValue].panel;          xNew ¬ LOOPHOLE[stack.p, LONG POINTER TO Loc SymbolValue].x;          yNew ¬ LOOPHOLE[stack.p, LONG POINTER TO Loc SymbolValue].y          END;        ENDCASE => ERROR Trouble["Loc must follow equal here"L];      RetireTop[];  --loc--      h ¬ SymHash.Lookup[symbols, stack.p];      IF h # SymHash.nullHash THEN        BEGIN        sv ¬ SymHash.GetInfo[symbols, h];        WITH sv SELECT FROM          Loc =>            IF x # xNew OR y # yNew OR panel # panelNew THEN              ERROR Trouble["Symbol assigned to different loc"L];          ENDCASE => ERROR Trouble["Symbol already defined not loc"L]        END      ELSE        BEGIN        h ¬ SymHash.Insert[symbols, stack.p];        sv ¬ heap.NEW[SymbolValue ¬ [Loc[panelNew, xNew, yNew]]];        SymHash.PutInfo[symbols, h, sv]        END;      RetireTop[];  --string--      Push[Loc, sv, 0]      END;    DoSemi: PROCEDURE =      BEGIN      Legal: TYPE = {semiI, arrowI, shriekI, equalI};      last: Legal ¬ LAST[Legal];      i, item: Legal ¬ FIRST[Legal];      Template: ARRAY Legal OF RECORD [        b: BreakDomain, s: LONG POINTER TO StackCell] ¬ [        [semi, NIL], [arrow, NIL], [shriek, NIL], [equal, NIL]];      bit: WORD ¬ 1;      value: CARDINAL ¬ 0;      define, loc, phrase, val: LONG STRING ¬ NIL;      error: BOOLEAN ¬ FALSE;      [] ¬ NextID[];      IF token.length # 0 THEN PushString[s: in];      IF stack = NIL THEN RETURN;      UNTIL stack = NIL DO        IF error THEN BEGIN RetireTop[]; LOOP END;        SELECT stack.type FROM          Tag, Null, Break => BEGIN error ¬ TRUE; LOOP END;          ENDCASE;        IF Template[item].s # NIL THEN BEGIN error ¬ TRUE; LOOP END;        Template[item].s ¬ Pop[];        IF stack = NIL THEN EXIT;        IF stack.type # Break THEN BEGIN error ¬ TRUE; LOOP END;        FOR i IN (item..last] DO          IF LOOPHOLE[stack.v, BreakDomain] = Template[i].b THEN EXIT          REPEAT FINISHED => error ¬ TRUE          ENDLOOP;        item ¬ i;        RetireTop[]        ENDLOOP;      FOR i IN [arrowI..equalI] DO        IF Template[i].s # NIL THEN value ¬ value + bit; bit ¬ bit + bit ENDLOOP;      BEGIN      a: LONG POINTER TO StackCell = Template[equalI].s;      x: LONG POINTER TO StackCell = Template[semiI].s;      y: LONG POINTER TO StackCell = Template[arrowI].s;      z: LONG POINTER TO StackCell = Template[shriekI].s;      SELECT value FROM        1 => --      y¬ x;-- Assign[y, x];        2 => --   z!    x;-- DisplayContents[z, x];        3 => --   z! y¬ x;-- BEGIN DisplayContents[z, y]; WriteContents[z, x] END;        4 => --a=       x;-- Equivalence[a, x];        5 => --a=    y¬ x;-- ERROR Trouble["Can't interpret statement"L];        6 => --a= z!    x;-- BEGIN Equivalence[a, z]; DisplayContents[z, x]; END;        7 => --a= z! y¬ x;--          BEGIN Equivalence[a, z]; DisplayContents[z, y]; WriteContents[z, x] END;        ENDCASE => ERROR Trouble["Illegal statement"L]      END;      FOR i IN Legal DO FreeStackCell[Template[i].s] ENDLOOP;      IF error THEN ERROR Trouble["Can't interpret statement"L];      END;    DoShriek: PROCEDURE =      BEGIN      sv: LONG POINTER TO SymbolValue;      idFlag: BOOLEAN ¬ NextID[];      IF (stack # NIL) AND (stack.type = Loc) THEN        BEGIN IF token.length # 0 THEN ERROR Trouble["Extra garbage before shriek"L] END      ELSE        BEGIN	old: BOOLEAN;        IF ~idFlag THEN ERROR Trouble["Can't parse shriek"L];        [old, , sv] ¬ LookupSubString[token, FALSE];        IF ~old OR sv.type # Loc THEN MustBeLocation[];        Push[Loc, sv, 0]        END;      Push[Break, NIL, BreakDomain[shriek]]      END;    DoOpenBracket: PROCEDURE =      BEGIN      sv: LONG POINTER TO SymbolValue;      h: SymHash.Hash;      s: LONG STRING;      panelName: LONG STRING;      old: BOOLEAN;      xNew, yNew: CARDINAL;      p: LONG POINTER TO StackCell;      AppendDigits: PROCEDURE [s: LONG STRING, v, n: CARDINAL] =        BEGIN        t: LONG STRING ¬ [6];        String.AppendNumber[t, v, 16];        THROUGH [t.length..n - 1] DO String.AppendChar[s, '0] ENDLOOP;        String.AppendString[s, t]        END;      IF ~NextID[] THEN ERROR Trouble["Garbage before open bracket"L];      [old, h, sv] ¬ LookupSubString[token, FALSE];      IF ~old THEN ERROR Trouble["Unknown ID before open bracket"L];      WITH sv SELECT FROM        Function => BEGIN p ¬ stack; apply[]; ClearStack[p] END;        Loc =>          BEGIN          panel: Panel;          panelName ¬ SymHash.GetString[symbols, h];          [xNew, yNew] ¬ GetXY[];          IF            ~(SELECT panel ¬ PanelFromName[panelName] FROM                CP => VisibleTile[cpHandle, xNew, yNew],                IOP => VisibleTile[iopPanel, xNew, yNew],                ENDCASE => ERROR) THEN ERROR Trouble["Illegal location"L];          --create symbol of form {panelName}xxxyyy--          String.AppendString[            to: s ¬ heap.NEW[StringBody [panelName.length + 6]], from: panelName];          AppendDigits[s, xNew, 3];          AppendDigits[s, yNew, 3];          h ¬ SymHash.Lookup[symbols, s];          IF h # SymHash.nullHash THEN --previously used-- sv ¬ SymHash.GetInfo[symbols, h]          ELSE            BEGIN            h ¬ SymHash.Insert[symbols, s];            sv ¬ heap.NEW[SymbolValue ¬ [Loc[panel, xNew, yNew]]];            SymHash.PutInfo[symbols, h, sv]            END;          Push[Loc, sv, 0]          END;        ENDCASE => ERROR Trouble["Illegal Type"L]      END;    DoBack: PROCEDURE =      BEGIN      [] ¬ NextID[];      IF token.length # 0 THEN PushString[s: in];      Push[Break, NIL, BreakDomain[arrow]]      END;    DoLess: PROCEDURE =      BEGIN IF ~DidCondition[] THEN WhereIsTheIF[]; END;    DoGreater: PROCEDURE =      BEGIN IF ~DidCondition[] THEN WhereIsTheIF[]; END;    DoNotEqual: PROCEDURE =      BEGIN IF ~DidCondition[] THEN WhereIsTheIF[]; END;    DoCloseBracket: PROCEDURE = BEGIN ERROR Trouble["Dangling close bracket"L] END;    DoOpenBrace: PROCEDURE = BEGIN ERROR Trouble["Dangling open brace"L] END;    DoCloseBrace: PROCEDURE =      BEGIN      IF (braces ¬ braces - 1) < 0 THEN ERROR Trouble["Dangling close brace"L];      DoSemi      END;    DidCondition: PROCEDURE RETURNS [BOOLEAN] =      BEGIN      h: SymHash.Hash;      old: BOOLEAN;      cc1, cc2: BreakDomain ¬ lastBreak;      v1, v2: LONG INTEGER;      r: Relation;      [] ¬ NextID[];      IF token.length = 0 THEN GarbagedConditional;      [old, h, ] ¬ LookupSubString[token, FALSE];      IF ~old OR ~String.Equal["IF"L, SymHash.GetString[symbols, h]]        THEN RETURN[FALSE];      v1 ¬ EvaluateLoc[];      ReadPhrase[];      cc2 ¬ lastBreak;      IF lastBreak IN RelationDomain THEN        BEGIN        IF lastBreak # openBrace THEN          BEGIN  --compound relation--          [] ¬ NextID[];          IF token.length # 0 OR rest.length # 0 THEN GarbagedConditional;          ReadPhrase[];          IF lastBreak # openBrace THEN GarbagedConditional          END        END      ELSE GarbagedConditional;      IF (r ¬ LegalRelations[cc1][cc2]) = x THEN GarbagedConditional;      v2 ¬ EvaluateLoc[];      IF        ~(SELECT r FROM            gt => v1 > v2,            eq => v1 = v2,            ne => v1 # v2,            lt => v1 < v2,            le => v1 <= v2,            ge => v1 >= v2,            ENDCASE => ERROR) THEN        BEGIN  --skip over stuff until matching closeBrace--        v1 ¬ 1;  --brace level--        WHILE v1 > 0 DO          ReadPhrase[];          SELECT lastBreak FROM            openBrace => v1 ¬ v1 + 1;            closeBrace => v1 ¬ v1 - 1;            quote => Breaks[quote].r;            ENDCASE          ENDLOOP;        RETURN[TRUE]        END;      braces ¬ braces + 1;      RETURN[TRUE]      END;        GetCardinal: PROCEDURE RETURNS [short: CARDINAL] =      BEGIN      number: LONG POINTER TO StackCell ¬ Pop[];      short ¬ StringExtras.CheckHexString[number.p !        StringExtras.InvalidHexString => NumberExpected[] ];      FreeStackCell[number];      END;    GetLongCardinal: PROCEDURE RETURNS [long: LONG CARDINAL] =      BEGIN      number: LONG POINTER TO StackCell ¬ Pop[];      long ¬ StringExtras.CheckLongHexString[number.p !        StringExtras.InvalidHexString => NumberExpected[] ];      FreeStackCell[number];      END;    OpenToAppend: PROCEDURE =      BEGIN OpenToWrite[]; Stream.SetPosition[output, MStream.GetLength[output]]; END;    OpenToWrite: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      IF output # NIL THEN BEGIN Stream.Delete[output]; output ¬ NIL; END;      output ¬ MStream.WriteOnly[stack.p, [], text];--        MStream.Error => ERROR Trouble["Can't open output file"L] ];      RetireTop[];      END;    Write: PROCEDURE =      BEGIN      SELECT GetParameters[] FROM        0 => NULL;        1 => BEGIN LogString[stack.p]; RetireTop[]; END;        ENDCASE => WrongNumberArguments[];      END;    WriteLine: PROCEDURE =      BEGIN      Write[];      LogCR[];      END;    WriteLoc: PROCEDURE =      BEGIN      temp: LONG STRING ¬ [50];      SELECT GetParameters[] FROM        1 => String.AppendString[temp, EvaluateSymbolicString[stack.p]];        2 =>	  BEGIN	  space: LONG STRING = " "L;	  width: CARDINAL = GetCardinal[];	  String.AppendString[temp, EvaluateSymbolicString[stack.p]];	  FOR i: CARDINAL IN [temp.length..width) DO LogString[space]; ENDLOOP;	  END;        ENDCASE => WrongNumberArguments[];      LogString[temp];      RetireTop[];      END;    WriteTime: PROCEDURE =      BEGIN      s: LONG STRING ¬ [32];      IF GetParameters[] # 0 THEN WrongNumberArguments[];      Time.AppendCurrent[s];      LogString[s]      END;          SetVMSize: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      IF NOT CPCommand.SetVmEnumItem[stack.p] THEN         BEGIN	 ERROR Trouble[" Parameter for SetVMSize must be 22, 23 or 24.\n"L];	 END;      RetireTop[];      END;          AlterAddress: PROCEDURE =      BEGIN      suffix: LONG POINTER TO StackCell;      ti: PanelSW.TileIndex;      h: PanelSW.Handle;      IF GetParameters[] # 2 THEN WrongNumberArguments[];      IF (suffix ¬ Pop[]).type # StringConstant THEN        ERROR Trouble["Must be string constant"L];      [h, ti] ¬ DecodeLoc[stack, TRUE];      PanelSW.ModifyLH[h, [left, ti], suffix.p !	PanelSW.TileError => ERROR Trouble["Can't do that"L];        PanelSW.ClientError => ERROR Trouble[msg] ];      FreeStackCell[suffix]      END;           Arm: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      HBCommand.Arm[log, arg, stack.p, 100];      RetireTop[];      END;    Boot: PROCEDURE =      BEGIN      IF GetParameters[] # 0 THEN WrongNumberArguments[];      CPCommand.Boot[log, arg];      END;    BootIOP: PROCEDURE =      BEGIN      IF GetParameters[] # 0 THEN WrongNumberArguments[];      IOPCommand.Boot[log, arg];      END;    Break: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      CPCommand.Break[log, arg, stack.p];      RetireTop[];      END;    BreakIOP: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      IOPCommand.Break[log, arg, stack.p];      RetireTop[];      END;    ClearCPPanel: PROCEDURE =      BEGIN      IF GetParameters[] # 0 THEN WrongNumberArguments[];      CPPanel.Clear[]      END;	    ClearIOPPanel: PROCEDURE =      BEGIN      IF GetParameters[] # 0 THEN WrongNumberArguments[];      IOPPanel.Clear[];      END;	    CloseLog: PROCEDURE =      BEGIN      IF GetParameters[] # 0 THEN WrongNumberArguments[];      IF output # NIL THEN Stream.Delete[output];      output ¬ NIL      END;    Compare: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      CPCommand.Reset[log, arg];      CPCommand.Compare[log, arg, stack.p];      RetireTop[];      END;    Continue: PROCEDURE =      BEGIN      SELECT GetParameters[] FROM        0 => CPCommand.Continue[log, arg];        1 =>          BEGIN	  ms: LONG CARDINAL = GetLongCardinal[];	  CPCommand.ContinueAndWait[log, arg, abort, ms];          END;        ENDCASE => WrongNumberArguments[];      END;    ContinueIOP: PROCEDURE =      BEGIN      SELECT GetParameters[] FROM        0 => IOPCommand.Continue[log, arg];        1 =>          BEGIN	  ms: LONG CARDINAL = GetLongCardinal[];	  IOPCommand.ContinueAndWait[log, arg, abort, ms];          END;        ENDCASE => WrongNumberArguments[];      END;	    GoTo: PROCEDURE =      BEGIN      target: Stream.Position;            GotLabel: PROCEDURE [s: LONG STRING] RETURNS [old: BOOLEAN] =        BEGIN        h: SymHash.Hash;        h ¬ SymHash.Lookup[symbols, s];	old ¬ h # SymHash.nullHash;        IF old THEN          BEGIN          sv: LONG POINTER TO SymbolValue ¬ SymHash.GetInfo[symbols, h];          WITH sv SELECT FROM            Tag => target ¬ si;            ENDCASE => ERROR Trouble["Illegal target"L];          END        END;            IF GetParameters[] # 1 THEN WrongNumberArguments[];      IF GotLabel[stack.p] THEN        BEGIN RetireTop[]; Stream.SetPosition[stream, target]; RETURN; END;      DO        ReadPhrase[];        SELECT lastBreak FROM          comment, quote => Breaks[lastBreak].r;          colon => BEGIN Breaks[lastBreak].r; IF GotLabel[stack.p] THEN EXIT END;          ENDCASE        ENDLOOP;      RetireTop[];      END;          Load: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      CPCommand.Reset[log, arg];      CPCommand.Load[log, arg, stack.p];      CPCommand.LoadSymbols[log, arg, stack.p];      RetireTop[];      END;    LoadBoot: PROCEDURE =      BEGIN      SELECT GetParameters[] FROM        1 => CPCommand.LoadBootFile[log, arg, stack.p, 0];        2 =>          BEGIN          pagesOrbanks: CARDINAL ¬ GetCardinal[];          CPCommand.LoadBootFile[log, arg, stack.p, pagesOrbanks];          END;        ENDCASE => WrongNumberArguments[];      RetireTop[];      END;        LoadMore: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      CPCommand.Load[log, arg, stack.p];      CPCommand.LoadSymbols[log, arg, stack.p];      RetireTop[];      END;    LoadNoSymbols: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      CPCommand.Reset[log, arg];      CPCommand.Load[log, arg, stack.p];      RetireTop[];      END;    LoadIOP: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      IOPCommand.Load[log, arg, stack.p];      IOPCommand.LoadSymbols[log, arg, stack.p];      RetireTop[];      END;    LoadIOPModuleSymbols: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      IOPCommand.LoadModuleSymbols[log, arg, stack.p];      RetireTop[];      END;    LoadIOPNoSymbols: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      IOPCommand.Load[log, arg, stack.p];      RetireTop[];      END;    LoadIOPSymbols: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      IOPCommand.LoadSymbols[log, arg, stack.p];      RetireTop[];      END;    LoadGerm: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      CPCommand.LoadGerm[log, arg, stack.p];      RetireTop[];      END;    LoadReal: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      CPCommand.LoadReal[log, arg, stack.p];      RetireTop[];      END;    Reset: PROCEDURE =      BEGIN      IF GetParameters[] # 0 THEN WrongNumberArguments[];      CPCommand.Reset[log, arg];      RetireTop[];      END;    SetBank: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      CPCommand.SetBank[log, arg, stack.p];      RetireTop[];      END;    SetMP: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      ProcessorFace.SetMP[Inline.LowHalf[EvaluateSymbolicInt[stack.p]]];      RetireTop[];      END;    Start: PROCEDURE =      BEGIN      SELECT GetParameters[] FROM        1 =>	  BEGIN	  CPCommand.SetPC[log, arg, stack.p];	  CPCommand.Continue[log, arg];	  END;        2 =>          BEGIN	  ms: LONG CARDINAL = GetLongCardinal[];	  CPCommand.SetPC[log, arg, stack.p];	  CPCommand.ContinueAndWait[log, arg, abort, ms];          END;        ENDCASE => WrongNumberArguments[];      RetireTop[];      END;          StartIOP: PROCEDURE =      BEGIN      SELECT GetParameters[] FROM        1 =>	  BEGIN	  IOPCommand.SetPC[log, arg, stack.p];	  IOPCommand.Continue[log, arg];	  END;        2 =>          BEGIN	  ms: LONG CARDINAL = GetLongCardinal[];	  IOPCommand.SetPC[log, arg, stack.p];	  IOPCommand.ContinueAndWait[log, arg, abort, ms];          END;        ENDCASE => WrongNumberArguments[];      RetireTop[];      END;     Stop: PROCEDURE =      BEGIN      IF GetParameters[] # 0 THEN WrongNumberArguments[];      CPCommand.Stop[log, arg];      END;    StopIOP: PROCEDURE =      BEGIN      IF GetParameters[] # 0 THEN WrongNumberArguments[];      IOPCommand.Stop[log, arg];      END;    Unbreak: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      CPCommand.Unbreak[log, arg, stack.p];      RetireTop[];      END;    UnbreakIOP: PROCEDURE =      BEGIN      IF GetParameters[] # 1 THEN WrongNumberArguments[];      IOPCommand.Unbreak[log, arg, stack.p];      RetireTop[];      END;    HandleForPanel: PROCEDURE [p: Panel] RETURNS [PanelSW.Handle] = INLINE {      RETURN[SELECT p FROM IOP => iopPanel, CP => cpHandle, ENDCASE => ERROR]};    DecodeLoc: PROCEDURE [stack: LONG POINTER TO StackCell, pop: BOOLEAN]      RETURNS [h: PanelSW.Handle, ti: PanelSW.TileIndex] =      BEGIN      sv: LONG POINTER TO Loc SymbolValue;      SELECT stack.type FROM        String, StringConstant =>          BEGIN          h: SymHash.Hash;          h ¬ SymHash.Lookup[symbols, stack.p];          IF h = SymHash.nullHash THEN ERROR Trouble["Undefined symbol"L];          sv ¬ SymHash.GetInfo[symbols, h];          IF sv.type # Loc THEN MustBeLocation[];          END;        Loc => sv ¬ stack.p;        ENDCASE => MustBeLocation[];      h ¬ HandleForPanel[sv.panel];      ti ¬ PanelSW.TileIndexFromRowColumn[h, sv.x, sv.y];      IF ti = PanelSW.nilTileIndex THEN ERROR Trouble["Invisible tile"L];      IF pop THEN RetireTop[];      END;    GetParameters: PROCEDURE RETURNS [n: CARDINAL] =      BEGIN      n ¬ 0;      DO        ReadPhrase[];        SELECT lastBreak FROM          closeBracket => BEGIN n ¬ n + ParseList[TRUE]; EXIT END;          quote =>            BEGIN n ¬ n + 1 + ParseList[FALSE]; DoQuote; PushString[s: sc] END;          ENDCASE => ERROR Trouble["Illegal parameter"L];        ENDLOOP      END;    ParseList: PROCEDURE [end: BOOLEAN] RETURNS [n: CARDINAL] =      BEGIN      --This routine still has problems.  Things which won't work include:      --[ ] and [x ]      n ¬ 0;      DO        [] ¬ NextID[];        IF token.length = 0 THEN          IF n = 0 THEN --null list is okay-- RETURN          ELSE ERROR Trouble["Unexpected end of list"L];        IF IDBreaks[token.base[token.offset]] THEN {          IF end THEN ERROR Trouble["Null ID in list"L] ELSE EXIT};        PushString[s: StringFromSubString[token]];        n ¬ n + 1;        IF rest.length = 0 THEN          BEGIN IF ~end THEN ERROR Trouble["Last element null"L] ELSE RETURN END        ELSE          IF rest.base[rest.offset] # ', THEN            ERROR Trouble["Comma must separate list elements"L];        [] ¬ NextID[]  --skip over the break--        ENDLOOP      END;    --EvaluateLoc does NextID checks for hex constant or location id.  IF a    --location ID then attempts to read it.  Gives an Error on the slightest    --provocation    EvaluateLoc: PROCEDURE RETURNS [v: LONG INTEGER] =      BEGIN      s: LONG STRING;      IF ~NextID[] THEN GarbagedConditional[];      s ¬ StringFromSubString[token];      v ¬ StringExtras.CheckLongHexString[s !        StringExtras.InvalidHexString =>          BEGIN v ¬ EvaluateSymbolicInt[s]; CONTINUE END];      heap.FREE[@s];      END;    EvaluateSymbolicInt: PROCEDURE [s: LONG STRING] RETURNS [v: LONG INTEGER] =      BEGIN      h: SymHash.Hash;      sv: LONG POINTER TO Loc SymbolValue;      t: LONG STRING;      h ¬ SymHash.Lookup[symbols, s];      IF h = SymHash.nullHash THEN ERROR Trouble["Undefined symbol"L];      sv ¬ SymHash.GetInfo[symbols, h];      IF sv.type # Loc THEN MustBeLocation[];      SELECT sv.panel FROM        CP => t ¬ EvaluateTile[cpHandle, sv.x, sv.y];        IOP => t ¬ EvaluateTile[iopPanel, sv.x, sv.y];        ENDCASE;      v ¬ StringExtras.CheckLongHexString[t !          StringExtras.InvalidHexString => ERROR Trouble["Can't parse that string"L] ];      END;    EvaluateSymbolicString: PROCEDURE [s: LONG STRING] RETURNS [t: LONG STRING] =      BEGIN      h: SymHash.Hash;      sv: LONG POINTER TO Loc SymbolValue;      h ¬ SymHash.Lookup[symbols, s];      IF h = SymHash.nullHash THEN ERROR Trouble["Undefined symbol"L];      sv ¬ SymHash.GetInfo[symbols, h];      IF sv.type # Loc THEN MustBeLocation[];      SELECT sv.panel FROM        CP => t ¬ EvaluateTile[cpHandle, sv.x, sv.y];        IOP => t ¬ EvaluateTile[iopPanel, sv.x, sv.y];        ENDCASE;      END;    GetXY: PROCEDURE RETURNS [x, y: CARDINAL] =      BEGIN      IllegalLoc: PROCEDURE = BEGIN ERROR Trouble["Illegal location"L] END;      IF GetParameters[] # 2 THEN IllegalLoc[];      y ¬ StringExtras.CheckHexString[        stack.p ! StringExtras.InvalidHexString => IllegalLoc[]];      RetireTop[];      x ¬ StringExtras.CheckHexString[        stack.p ! StringExtras.InvalidHexString => IllegalLoc[]];      RetireTop[];      END;    Read: PROCEDURE RETURNS [CHARACTER] =      BEGIN      c: CHARACTER;      IF (c ¬ limbo) = Ascii.NUL THEN RETURN[Stream.GetChar[stream]];      limbo ¬ Ascii.NUL;      RETURN[c]      END;    NextID: PROCEDURE RETURNS [BOOLEAN] =      BEGIN      break, tail: String.SubStringDescriptor;      StringExtras.NextToken[rest, token, IDBreaks];      IF token.length > 0        AND StringExtras.BlankCharacter[token.base[token.offset]] THEN        --skip leading spaces--        StringExtras.NextToken[rest, token, IDBreaks];      IF rest.length # 0 THEN        BEGIN  --eat trailing spaces--        tail ¬ rest­;        StringExtras.NextToken[@tail, @break, IDBreaks];        IF ~StringExtras.BlankCharacter[break.base[break.offset]] THEN          RETURN[FALSE];        rest­ ¬ tail        END;      RETURN[token.length # 0 AND rest.length = 0];      END;    GotBreak: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] =      BEGIN      i: BreakDomain;      FOR i IN BreakDomain DO        IF Breaks[i].c = c THEN BEGIN lastBreak ¬ i; RETURN[TRUE] END ENDLOOP;      RETURN[FALSE]      END;    StringFromSubString: PROCEDURE [ss: String.SubString] RETURNS [s: LONG STRING] =      BEGIN      s ¬ heap.NEW[StringBody [ss.length]];      String.AppendSubString[s, ss]      END;    LookupSubString: PROCEDURE [ss: String.SubString, insert: BOOLEAN]      RETURNS [        old: BOOLEAN, h: SymHash.Hash, sv: LONG POINTER TO SymbolValue] =      BEGIN      s: LONG STRING ¬ heap.NEW[StringBody [ss.length]];      String.AppendSubString[s, ss];      h ¬ SymHash.Lookup[symbols, s];      old ¬ h # SymHash.nullHash;      IF ~old AND insert THEN h ¬ SymHash.Insert[symbols, s];      heap.FREE[@s];      IF ~old THEN BEGIN sv ¬ NIL; RETURN END;      sv ¬ SymHash.GetInfo[symbols, h]      END;    Push: PROCEDURE [type: Type, p: LONG POINTER, value: UNSPECIFIED] =      BEGIN      sc: LONG POINTER TO StackCell ¬ heap.NEW[        StackCell ¬ [type, p, value, stack]];      stack ¬ sc      END;    PushString: PROCEDURE [s: LONG STRING] =      BEGIN      c: LONG STRING ¬ heap.NEW[StringBody [s.length]];      String.AppendString[to: c, from: s];      Push[StringConstant, c, 0]      END;    PushSubString: PROCEDURE [ss: String.SubString] =      BEGIN      s: LONG STRING ¬ heap.NEW[StringBody [ss.length]];      String.AppendSubString[to: s, from: ss];      Push[StringConstant, s, 0]      END;    Pop: PROCEDURE RETURNS [p: LONG POINTER TO StackCell] =      BEGIN IF (p ¬ stack) # NIL THEN stack ¬ p.previous END;    FreeStackCell: PROCEDURE [p: LONG POINTER TO StackCell] =      BEGIN      IF p = NIL THEN RETURN;      SELECT p.type FROM        StringConstant => IF p.p # NIL THEN heap.FREE[@p­.p];        ENDCASE;      heap.FREE[@p];      END;    RetireTop: PROCEDURE = BEGIN FreeStackCell[Pop[]] END;    ClearStack: PROCEDURE [p: LONG POINTER TO StackCell] =      BEGIN UNTIL stack = p DO RetireTop[]; ENDLOOP END;    --these are different when string variables come along--    WriteContents, Assign: PROCEDURE [target, value: LONG POINTER TO StackCell] =      BEGIN      h: PanelSW.Handle;      ti: PanelSW.TileIndex;      SELECT target.type FROM        StringConstant =>          BEGIN          s: LONG STRING = LOOPHOLE[target.p];          id: String.SubString ¬ token;          tail: String.SubString ¬ rest;          sv: LONG POINTER TO SymbolValue;          old: BOOLEAN;          idD: String.SubStringDescriptor;          tailD: String.SubStringDescriptor ¬ [s, 0, s.length];          token ¬ @idD;          rest ¬ @tailD;          IF ~NextID[] THEN ERROR Trouble["Garbage before back arrow"L];          [old, , sv] ¬ LookupSubString[token, FALSE];          IF ~old THEN ERROR Trouble["Undefined location"L];          heap.FREE[@target­.p];  --before overwriting target­--          WITH sv SELECT FROM            Loc => target­ ¬ [Loc, sv, 0, target.previous];            ENDCASE => MustBeLocation[];          token ¬ id;          rest ¬ tail          END;        Loc => NULL;        ENDCASE => MustBeLocation[];      [h, ti] ¬ DecodeLoc[target, FALSE];      IF ~(value.type = String OR value.type = StringConstant) THEN        ERROR Trouble["Only strings and constants here"L];      IF value.type = StringConstant THEN        [] ¬ StringExtras.TrimString[value.p];      PanelSW.WriteTile[        h, [right, ti], value.p, FALSE !	  PanelSW.TileError => AssignmentLost[];	  PanelSW.ClientError => ERROR Trouble[msg] ];      END;    DisplayContents: PROCEDURE [target, value: LONG POINTER TO StackCell] =      BEGIN      ti: PanelSW.TileIndex;      h: PanelSW.Handle;      IF ~(value.type = String OR value.type = StringConstant) THEN        ERROR Trouble["Only strings and constants here"L];      [h, ti] ¬ DecodeLoc[target, FALSE];      [] ¬ StringExtras.TrimString[value.p];      PanelSW.WriteTile[        h, [left, ti], value.p, FALSE !	  PanelSW.TileError => AssignmentLost[];	  PanelSW.ClientError => ERROR Trouble[msg] ];      END;    Equivalence: PROCEDURE [target, value: LONG POINTER TO StackCell] =      BEGIN      old: BOOLEAN;      h: SymHash.Hash;      sv: LONG POINTER TO SymbolValue;      loc: LONG POINTER TO Loc SymbolValue = value.p;      stoken: String.SubString = token;      srest: String.SubString = rest;      td: String.SubStringDescriptor ¬ [target.p, 0, 0];      rd: String.SubStringDescriptor ¬ [        target.p, 0, LOOPHOLE[target.p,LONG  STRING].length];      IF value.type # Loc THEN ERROR Trouble["Loc must follow equals"L];      token ¬ @td;      rest ¬ @rd;      IF ~NextID[] THEN ERROR Trouble["ID must preceed equal"L];      [old, h, sv] ¬ LookupSubString[token, TRUE];      IF old THEN        WITH sv SELECT FROM          Loc => IF ~(loc.x = x AND loc.y = y) THEN MultiplyDefined[];          ENDCASE => ERROR Trouble["Loc must preceed equal"L]      ELSE        BEGIN        sv ¬ heap.NEW[SymbolValue ¬ [Loc[loc.panel, loc.x, loc.y]]];        SymHash.PutInfo[symbols, h, sv]        END;      token ¬ stoken;      rest ¬ srest;      END;    LogString: PROCEDURE [s: LONG STRING] =      BEGIN      IF output = NIL THEN Format.Text[log, s, arg]      ELSE Stream.PutString[output, s];      END;        LogCR: PROCEDURE =      BEGIN      IF output = NIL THEN Format.CR[log, arg]      ELSE Stream.PutChar[output, Ascii.CR];      END;            StartRunning[abort];    BEGIN ENABLE UNWIND => BEGIN ReleaseStructures[]; StopRunning[]; END;    symbols ¬ SymHash.Create[10];    heap ¬ Heap.Create[initial: 2];    in ¬ heap.NEW[StringBody [64]];    sc ¬ heap.NEW[StringBody [32]];    stack ¬ NIL;    braces ¬ 0;    limbo ¬ Ascii.NUL;    stopCommands ¬ FALSE;    FOR i: KeyDomain IN KeyDomain DO      h: SymHash.Hash ¬ SymHash.Insert[symbols, keys[i].s];      sv: LONG POINTER TO SymbolValue ¬ heap.NEW[SymbolValue];      SELECT keys[i].t FROM        Null => sv­ ¬ [Null[]];        Break => sv­ ¬ [Break[]];        String => sv­ ¬ [String[heap.NEW[StringBody [32]]]];        Loc => sv­ ¬ [Loc[PanelFromName[SymHash.GetString[symbols, h]], 0, 0]];        Function => sv­ ¬ [Function[keys[i].function]];        ENDCASE => ERROR;      SymHash.PutInfo[symbols, h, sv]      ENDLOOP;    CommandLoop[];    ReleaseStructures[];    StopRunning[];    END;    END;    IDBreaks: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] =    BEGIN    SELECT c FROM      IN ['0..'9], IN ['A..'Z], IN ['a..'z], '@, '. => RETURN[FALSE];      ENDCASE => RETURN[TRUE];    END;  PanelFromName: PROCEDURE [panelName: LONG STRING] RETURNS [Panel] =    BEGIN    SELECT TRUE FROM      String.Equal[panelName, "CP"L] => RETURN[CP];      String.Equal[panelName, "IOP"L] => RETURN[IOP];      ENDCASE => ERROR;    END;  AssignmentLost: PROCEDURE = BEGIN ERROR Trouble["Assignment lost"L]; END;  GarbagedConditional: PROCEDURE = BEGIN ERROR Trouble["Garbaged conditional"L]; END;  MultiplyDefined: PROCEDURE = BEGIN ERROR Trouble["Multiply defined symbol"L]; END;  MustBeLocation: PROCEDURE = BEGIN ERROR Trouble["Must be location"L]; END;  NumberExpected: PROCEDURE = BEGIN ERROR Trouble["Number Expected"L]; END;  WhereIsTheIF: PROCEDURE = BEGIN ERROR Trouble["Where is the IF?"L]; END;  WrongNumberArguments: PROCEDURE = BEGIN ERROR Trouble["Wrong number of arguments"L]; END;  Process.SetTimeout[@waitTillDone, Process.SecondsToTicks[1]];  END.-- CommandFiler.mesa, HGM, 13-Feb-84 19:33:09edited: Dennis DEG     , converted to 11.1/12.0 to use old arrows as well.
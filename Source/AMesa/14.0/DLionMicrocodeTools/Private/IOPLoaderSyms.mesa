-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- IOPLoaderSyms.mesa, HGM,  5-Oct-83  0:13:04DIRECTORY  Environment USING [bytesPerWord, charsPerWord],  Format USING [Decimal, Line, StringProc, Text],  Heap USING [systemZone],  MStream USING [Error, ReadOnly],  Stream USING [Delete, GetBlock, GetWord, Handle],  String USING [AppendExtensionIfNeeded, AppendString, CopyToNewString, WordsForString],    IOP USING [Address],  IOPCommand USING [Error],  IOPSyms USING [    AddExternalSymbol, AddModuleSymbol, CreateModule, CreateModuleSymbols,    Error, FindModule, Module];IOPLoaderSyms: PROGRAM  IMPORTS    Format, Heap, MStream, Stream, String,    IOPCommand, IOPSyms  EXPORTS IOPCommand =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;  LoadSymbols: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "fm"L, z];    Format.Text[log, "Loading module info from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] !      MStream.Error => ERROR IOPCommand.Error["Can't find that file"L] ];    -- leaves stream and filename dangling if troubles beyond here    UNTIL ReadFMRecord[log, arg, stream] DO ENDLOOP;    BuildExternalSymbolTable[stream];    Stream.Delete[stream];    z.FREE[@filename];    END;      BuildExternalSymbolTable: PROCEDURE [stream: Stream.Handle] =    BEGIN    externalSymbols: MyHandle;    CopyOver: PROCEDURE [who: MyHash] =      BEGIN      IOPSyms.AddExternalSymbol[@externalSymbols[who].string, externalSymbols[who].info];      END;    [externalSymbols, ] ¬ MakeFromStream[stream];    EnumerateEntries[externalSymbols, CopyOver];    z.FREE[@externalSymbols];    END;  ReadFMRecord: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] RETURNS [end: BOOLEAN] =    BEGIN    bytes, clump: CARDINAL;    base, top: IOP.Address;    name: STRING = [100];    IF Stream.GetWord[stream] = 0FFFFH THEN RETURN[TRUE];    [] ¬ Stream.GetWord[stream];    base ¬ Stream.GetWord[stream];    top ¬ Stream.GetWord[stream];    bytes ¬ Stream.GetWord[stream];    IF bytes > name.maxlength THEN ERROR IOPCommand.Error["Huge Module name"L];    clump ¬ Environment.charsPerWord*((bytes + Environment.charsPerWord -                                   1)/Environment.charsPerWord);    name.length ¬ bytes;    [] ¬ Stream.GetBlock[      sH: stream,      block: [      blockPointer: LOOPHOLE[LONG[@name.text]], startIndex: 0,      stopIndexPlusOne: clump]];    IF base # top THEN      BEGIN      module: IOPSyms.Module;      module ¬ IOPSyms.CreateModule[name, base, top];      IF FALSE THEN  -- Takes too long      LoadModuleSyms[log, arg, name, module, base];      END;    RETURN[FALSE];    END;        LoadModuleSymbols: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, name: LONG STRING] =    BEGIN    module: IOPSyms.Module;    base: IOP.Address;    [module, base] ¬ IOPSyms.FindModule[name ! IOPSyms.Error => IOPCommand.Error[reason] ];    LoadModuleSyms[log, arg, name, module, base];    END;  LoadModuleSyms: PUBLIC PROCEDURE [    log: Format.StringProc,    arg: LONG POINTER,    name: LONG STRING,    module: IOPSyms.Module,    base: IOP.Address] =    BEGIN    filename: LONG STRING ¬ [36];    stream: Stream.Handle ¬ NIL;    pages: CARDINAL;    symbols: MyHandle;    sym, tag: CARDINAL ¬ 0;        CopyOver: PROCEDURE [h: MyHash] =      BEGIN      IF symbols[h].reloc THEN        BEGIN        symbols[h].info ¬ symbols[h].info + base;	tag ¬ tag + 1;	END;      IOPSyms.AddModuleSymbol[module, @symbols[h].string, symbols[h].info];      sym ¬ sym + 1;      END;        String.AppendString[filename, name];    String.AppendString[filename, ".am"L];    Format.Text[log, "Loading symbols from "L, arg];    Format.Text[log, filename, arg];    Format.Text[log, " ..."L, arg];    stream ¬ MStream.ReadOnly[filename, [] !      MStream.Error =>         BEGIN        Format.Line[log, "  Can't read that file."L, arg];	CONTINUE;	END; ];    IF stream = NIL THEN RETURN;    -- Skip AM stuff    -- There is an entry for each line of source code.    -- It contains: source file position, address, offset from tag, and hash for tag    WHILE SkipAMRecord[stream] DO ENDLOOP;	    -- Skip UL stuff  (I don't know what they are)    WHILE Stream.GetWord[stream] # 0FFFFH DO      WHILE Stream.GetWord[stream] # 0FFFFH DO ENDLOOP;      ENDLOOP;	    [symbols, pages] ¬ MakeFromStream[stream];    IOPSyms.CreateModuleSymbols[module, pages];    EnumerateEntries[symbols, CopyOver];    z.FREE[@symbols];    Stream.Delete[stream];        Format.Line[log, " ok."L, arg];    Format.Text[log, "Loaded "L, arg];    Format.Decimal[log, sym, arg];    Format.Text[log, " symbols, and "L, arg];    Format.Decimal[log, tag, arg];    Format.Line[log, " tags.", arg];    END;      SkipAMRecord: PROCEDURE [stream: Stream.Handle] RETURNS [more: BOOLEAN] =    BEGIN    w: WORD ¬ Stream.GetWord[stream];    wordsPerBlock: CARDINAL = 5;    junk: ARRAY [0..wordsPerBlock) OF WORD;    IF w = 0FFFFH THEN RETURN [FALSE];    [] ¬ Stream.GetBlock[      sH: stream,      block: [        blockPointer: LOOPHOLE[LONG[@junk]],        startIndex: 0,        stopIndexPlusOne: Environment.bytesPerWord*wordsPerBlock]];    RETURN [TRUE];    END;        -- Copied from SymHasher (and such)    MyHash: TYPE = MyHandle RELATIVE ORDERED POINTER [0..7777B] TO MyHashBlock;  MyHashBlock: TYPE = RECORD [    reloc: BOOLEAN,    next: MyHash,    info: UNSPECIFIED,    string: StringBody];     hVSize: CARDINAL = 71;  firstAvailSlot: MyHash = LOOPHOLE[SIZE[MyHashRegion]];  --@firstAvail  MyHandle: TYPE = LONG BASE POINTER TO MyHashRegion;  MyHashRegion: TYPE = RECORD [    hVec: ARRAY [0..hVSize) OF MyHash,    pages: CARDINAL,    caseHeed: BOOLEAN,    nextAvail: MyHash,    firstAvail: ARRAY [0..0) OF MyHashBlock    -- as many more HashBlocks as will fit in pages    ];  MakeFromStream: PROCEDURE [stream: Stream.Handle] RETURNS [handle: MyHandle, pages: CARDINAL] =    BEGIN    Words: TYPE = RECORD [seq: SEQUENCE l:CARDINAL OF WORD];    temp: LONG POINTER;    words: CARDINAL ¬ Stream.GetWord[sH: stream];    pages ¬ words / 256;    temp ¬ z.NEW[Words[words]];    handle ¬ LOOPHOLE[temp];    [] ¬ Stream.GetBlock[      sH: stream,      block: [        blockPointer: LOOPHOLE[handle],         startIndex: 0,        stopIndexPlusOne: Environment.bytesPerWord*words]];    END;       EnumerateEntries: PUBLIC PROCEDURE [data: MyHandle, action: PROCEDURE [MyHash]] =    BEGIN    h: MyHash ¬ firstAvailSlot + 1;  --  ********************* I don't know.  HGM    WHILE h < data.nextAvail DO      action[h];      h ¬ h + SizeOfExistingHashBlock[data, h];      ENDLOOP;    END;     SizeOfExistingHashBlock: PROCEDURE [data: MyHandle, h: MyHash]  RETURNS [CARDINAL] =    BEGIN    RETURN[      SIZE[MyHashBlock] +      String.WordsForString[data[h].string.maxlength] -      SIZE[StringBody[0]]];    END;    	     END.
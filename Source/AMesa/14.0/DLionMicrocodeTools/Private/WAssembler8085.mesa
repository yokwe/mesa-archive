-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: WAssembler8085.mesa-- last edited by DEG     : 26-Sep-84 23:26:07   See log at endDIRECTORY  AssInputDefs USING [    NextChar, CurrentChar, MakeWord, GetLabel, GetOp, GetArg, GetStringArg,    SetInputStream, RestoreInputStream, AssErr, GetRelocFlag, TurnOffReloc,    StartOfLine, StreamIndexOfCurrentLine],  CodeOutputDefs USING [    BuildAndPutCodeLine, WindUpCodeFile, GetPC, SetPC, ModifyPC, SetBinaryStream,    GetBinaryStreamIndex],  CommandDefs,  ExpressionDefs USING [    ConstructReversePolishStack, EvaluateReversePolishStack, EvalResult],  Heap USING [systemZone],  HeraldWindow USING [FreeCursorSlot, GetCursorSlot, SetCursorState, Slot, StoreCursor],  MFile USING [CopyFileHandle, Delete, Handle],  Inline USING [BITOR, BITSHIFT],  ListOutputDefs USING [    ReportError, ErrorsDetected, PutCode, PutArg, PutArg2, PutString, PutTitle,    TurnOnListing, TurnOffListing, ResetListing, PutPC, WriteToListing],  ListingStreamDefs USING [SetListingStream],  MStream USING [Error, GetFile, ReadOnly, ReadWrite, SetLength],  NewStateDefs USING [Operation],  PrivateStorage USING [heapPointer],  PrivateStringDefs USING [CopyString],  Stream USING [    Delete, EndOfStream, GetPosition, Handle, Position, PutChar, SetPosition],  String USING [AppendString, EqualStrings, AppendChar],  SymbolTableDefs USING [STData, PutInSymbolTable, LookUpInSymbolTable],  SymTabIODefs USING [    WriteSymbolTable, PutAddressMapInformation, RemoveLastMapEntry,    CreateMapStream],  UserTerminal USING [CursorArray];WAssembler8085: PROGRAM  IMPORTS    AssInputDefs, CodeOutputDefs, ExpressionDefs, Inline, Heap,  HeraldWindow, ListingStreamDefs, ListOutputDefs, MFile, MStream, PrivateStorage, PrivateStringDefs,    Stream, String, SymbolTableDefs, SymTabIODefs  EXPORTS CommandDefs =  BEGIN OPEN SymbolTableDefs, SymTabIODefs;  PAGETHROW: CHARACTER = '\F;  AssemblerError: SIGNAL = CODE;  FileNotFound: PUBLIC SIGNAL [fname: LONG STRING] = CODE;  EndOfInput: SIGNAL = CODE;  AsmErr: PUBLIC SIGNAL [ErrCt: CARDINAL] = CODE;  InputStream, BinaryStream, ListStream, SymbolStream: Stream.Handle;  MiscString: LONG STRING;  GetFile: LONG STRING;  GetStack: LONG POINTER TO FileStack;  FileStack: TYPE = RECORD [    fileno: CARDINAL,    SI: Stream.Position,    FH: Stream.Handle,    backptr: LONG POINTER TO FileStack];  StatementLabel: LONG STRING;  LastLabel: LONG STRING;  offset: CARDINAL;  firstchar: BOOLEAN;  list: BOOLEAN;  char: CHARACTER;  PrevPC: CARDINAL;  currfileno, maxfileno: CARDINAL;  AssembleOneInstruction: PROCEDURE =    BEGIN OPEN CodeOutputDefs, AssInputDefs;    op: NewStateDefs.Operation;    CurrentPC: CARDINAL ¬ GetPC[];    si: Stream.Position;        WHILE StartOfLine[] DO      lab: LONG STRING ¬ NIL;      si ¬ StreamIndexOfCurrentLine[];      lab ¬ GetLabel[];      PrivateStringDefs.CopyString[StatementLabel, lab];      PrivateStorage.heapPointer.FREE[@lab];      PutAddressMapInformation[StatementLabel, 0, CurrentPC, currfileno, si];      ENDLOOP;    IF NOT String.EqualStrings[StatementLabel, LastLabel] THEN      BEGIN      PrivateStringDefs.CopyString[LastLabel, StatementLabel];      PrevPC ¬ 177777B;  -- to force call of PutAddressMapInformation      offset ¬ 0;      END    ELSE      BEGIN      offset ¬ offset + 1;      IF PrevPC # CurrentPC THEN        BEGIN        PutAddressMapInformation[          StatementLabel, offset, CurrentPC, currfileno, StreamIndexOfCurrentLine[          ]];        PrevPC ¬ CurrentPC;        END;      END;    op ¬ GetOp[];    AssembleAndDisgorgeBinary[op];    END;  AssembleAndDisgorgeBinary: PROCEDURE [op: NewStateDefs.Operation] =    BEGIN OPEN AssInputDefs, CodeOutputDefs, ListOutputDefs;    rec: LONG POINTER TO FileStack;    i, part: CARDINAL;    w: LONG STRING ¬ NIL;    STE: LONG POINTER TO STData;    EvalRes: ExpressionDefs.EvalResult;        SELECT op.type FROM      Type6, end, page, list, nolist => NULL;      ENDCASE =>        BEGIN        char ¬ CurrentChar[];        WHILE char = '  OR char = '\T  DO char ¬ NextChar[]; ENDLOOP;        END;    SELECT op.type FROM      Type1 =>        BEGIN        part ¬ Inline.BITOR[op.value, Inline.BITSHIFT[GetArg[reg], 3]];        char ¬ NextChar[];        PutCode[Inline.BITOR[part, GetArg[reg]]];        END;      Type2 =>        BEGIN        PutCode[Inline.BITOR[op.value, Inline.BITSHIFT[GetArg[reg], 3]]];        char ¬ NextChar[];        PutArg[GetArg[byte]];        END;      Type3 =>        BEGIN        PutCode[Inline.BITOR[op.value, Inline.BITSHIFT[GetArg[regpr], 4]]];        char ¬ NextChar[];        PutArg2[GetArg[word]];        END;      Type4 => BEGIN PutCode[op.value]; PutArg2[GetArg[word]]; END;      Type5 => PutCode[Inline.BITOR[op.value, Inline.BITSHIFT[GetArg[regpr], 4]]];      Type6 => PutCode[op.value];      Type7 => PutCode[Inline.BITOR[op.value, GetArg[reg]]];      Type8 => BEGIN PutCode[op.value]; PutArg[GetArg[byte]]; END;      Type9 => PutCode[Inline.BITOR[op.value, Inline.BITSHIFT[GetArg[reg], 3]]];      rst =>        BEGIN        part ¬ GetArg[byte];        IF part > 7 THEN SIGNAL AssErr[14];        PutCode[Inline.BITOR[op.value, Inline.BITSHIFT[part, 3]]];        END;      reg => SIGNAL AssErr[13];      org =>        BEGIN SetPC[GetArg[word]]; TurnOffReloc[]; BuildAndPutCodeLine[]; END;      end =>        BEGIN        [] ¬ TurnOnListing[];        DO          char ¬ NextChar[            !            Stream.EndOfStream =>              IF GetStack = NIL THEN                BEGIN WindUpCodeFile[]; SIGNAL EndOfInput; END              ELSE                BEGIN                BuildAndPutCodeLine[];                PutString[BinaryStream, "/E"L];                Stream.PutChar[BinaryStream, '\N ];                Stream.PutChar[BinaryStream, '\L ];                currfileno ¬ GetStack.fileno;                rec ¬ GetStack;                GetStack ¬ GetStack.backptr;                Stream.Delete[sH: InputStream];                InputStream ¬ rec.FH;                Stream.SetPosition[InputStream, rec.SI];                RestoreInputStream[InputStream];                PrivateStorage.heapPointer.FREE[@rec];                IF GetStack = NIL THEN [] ¬ ResetListing[list];                EXIT;                END];          ENDLOOP;        END;      dw =>        BEGIN        PutPC[];        i ¬ 0;        DO  -- forever          IF i = 2 THEN BEGIN PutPC[]; i ¬ 0; END;          PutArg2[GetArg[word]];          char ¬ CurrentChar[];          IF char = '  OR char = '\T  OR char = '\N  THEN EXIT;          i ¬ i + 1;          char ¬ NextChar[];          ENDLOOP;        END;      db =>        BEGIN        PutPC[];        i ¬ 0;        char ¬ CurrentChar[];        DO  -- forever          WHILE char = '\T  OR char = '  DO char ¬ NextChar[]; ENDLOOP;          IF char = '\N  THEN EXIT;          IF char = '" THEN            BEGIN            char ¬ NextChar[];            WHILE char # '" DO              IF i = 4 THEN BEGIN PutPC[]; i ¬ 0; END;              PutArg[LOOPHOLE[char]];              i ¬ i + 1;              char ¬ NextChar[];              ENDLOOP;            char ¬ NextChar[];            SELECT char FROM              ' , '\T , '\N  => EXIT;              ', => char ¬ NextChar[];              ENDCASE => SIGNAL AssErr[11];            END          ELSE            BEGIN            IF i = 4 THEN BEGIN PutPC[]; i ¬ 0; END;            PutArg[GetArg[byte]];            char ¬ CurrentChar[];            IF char = '  OR char = '\T  OR char = '\N  THEN EXIT;            i ¬ i + 1;            char ¬ NextChar[];            END;          ENDLOOP;        END;      ds => BEGIN PutPC[]; ModifyPC[GetArg[word]]; BuildAndPutCodeLine[]; END;      page => Stream.PutChar[ListStream, PAGETHROW];      space =>        THROUGH [1..GetArg[word]] DO          Stream.PutChar[ListStream, '\N ]; ENDLOOP;      equ =>        BEGIN        RemoveLastMapEntry[];  -- to avoid cluttering up the map        PrevPC ¬ 177777B;  -- to force call of PutAddressMapInformation        EvalRes ¬ ExpressionDefs.EvaluateReversePolishStack[          ExpressionDefs.ConstructReversePolishStack[2]];        WITH EvalRes SELECT FROM          TRUE =>            BEGIN            w ¬ PrivateStorage.heapPointer.NEW[StringBody [32]];            PrivateStringDefs.CopyString[w, StatementLabel];            STE ¬ LookUpInSymbolTable[w];            STE­ ¬ [              [IOPmain[res.v]], DefSym, STE.extern, res.r, STE.useChain, NIL];            PrivateStorage.heapPointer.FREE[@w];            END;          FALSE => SIGNAL AssErr[18];          ENDCASE;        END;      get =>        BEGIN        GetFile ¬ GetStringArg[];        char ¬ CurrentChar[];        WHILE char # '\N  DO char ¬ NextChar[]; ENDLOOP;        IF NoExt[GetFile] THEN String.AppendString[GetFile, ".asm"L];        --  Insert line with Get Filename.        MiscString.length ¬ 0;  -- Clear string        String.AppendChar[MiscString, '\T ];        String.AppendString[MiscString, "get"L];        String.AppendChar[MiscString, '\T ];        String.AppendChar[MiscString, '"];        String.AppendString[MiscString, GetFile];        String.AppendChar[MiscString, '"];        String.AppendChar[MiscString, '\N ];        ListOutputDefs.WriteToListing[MiscString];        --  Check if file is there.        rec ¬ PrivateStorage.heapPointer.NEW[          FileStack ¬ [          currfileno, Stream.GetPosition[InputStream], InputStream, GetStack]];  -- Push current context        GetStack ¬ rec;        currfileno ¬ maxfileno ¬ maxfileno + 1;        InputStream ¬ MStream.ReadOnly[name: GetFile, release: [NIL, NIL]!          MStream.Error =>            SELECT code FROM fileNotAvailable => ERROR FileNotFound[GetFile]; 	    ENDCASE => REJECT;];        SetInputStream[InputStream];        BuildAndPutCodeLine[];        PutString[BinaryStream, "/File - "L];        ReplaceExtension[GetFile, "bin"L];        PutString[BinaryStream, GetFile];        Stream.PutChar[BinaryStream, '\N ];        Stream.PutChar[BinaryStream, '\L ];        list ¬ TurnOffListing[];        PrivateStorage.heapPointer.FREE[@GetFile];        END;      imp, exp =>        BEGIN        char ¬ CurrentChar[];        DO          w ¬ MakeWord[];          STE ¬ LookUpInSymbolTable[w];          IF STE # NIL THEN SIGNAL AssErr[20];          [] ¬ PutInSymbolTable[            w, [IOPmain[0]], UnDef, IF op.type = imp THEN imported ELSE exported,            GetRelocFlag[], FALSE, GetPC[], 2, GetBinaryStreamIndex[]];          char ¬ CurrentChar[];          SELECT char FROM            ' , '\T , '\N  => EXIT;            ', => NULL;            ENDCASE => SIGNAL AssErr[9];          char ¬ NextChar[];          ENDLOOP;        END;      file =>        BEGIN        f: LONG STRING ¬ NIL;        BuildAndPutCodeLine[];        PutString[BinaryStream, "$File - "L];        PutString[BinaryStream, (f ¬ GetStringArg[])];        Stream.PutChar[BinaryStream, '\N ];        Stream.PutChar[BinaryStream, '\L ];        PrivateStorage.heapPointer.FREE[@f];        END;      title =>        BEGIN        t: LONG STRING ¬ GetStringArg[];        PutTitle[t];        PrivateStorage.heapPointer.FREE[@t];        END;      list => [] ¬ TurnOnListing[];      nolist => [] ¬ TurnOffListing[];      ENDCASE => NULL;    END;  NoExt: PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN] =    BEGIN    FOR i: CARDINAL IN [0..s.length) DO IF s[i] = '. THEN RETURN[FALSE]; ENDLOOP;    RETURN[TRUE];    END;  ReplaceExtension: PROCEDURE [f, e: LONG STRING] =    BEGIN    i: CARDINAL;    FOR i IN [0..f.length) DO IF f[i] = '. THEN EXIT; ENDLOOP;    f.length ¬ i + 1;    String.AppendString[f, e];    END;  Assem8085: PUBLIC PROCEDURE [FileName: LONG STRING] =    BEGIN OPEN AssInputDefs;    fname: STRING ¬ [30];    ErrCt: CARDINAL;    cursorArray: UserTerminal.CursorArray ¬ [177400B, 177400B, 177400B, 177400B, 177400B, 177400B, 177400B, 177400B, 377B, 377B, 377B, 377B, 377B, 377B, 377B, 377B];    hearldWindowSlot: HeraldWindow.Slot ¬ NIL;    CleanUp: PROCEDURE = {      IF BinaryStream # NIL THEN Stream.Delete[sH: BinaryStream];      IF ListStream # NIL THEN Stream.Delete[sH: ListStream];      IF SymbolStream # NIL THEN Stream.Delete[sH: SymbolStream];      IF InputStream # NIL THEN Stream.Delete[sH: InputStream];      BinaryStream ¬ ListStream ¬ SymbolStream ¬ InputStream ¬ NIL;      hearldWindowSlot ¬ HeraldWindow.FreeCursorSlot[slot: hearldWindowSlot]};    PrivateStringDefs.CopyString[fname, FileName];    BEGIN    ENABLE       BEGIN        MStream.Error =>          SELECT code FROM            fileNotAvailable => ERROR FileNotFound[fname];          ENDCASE => REJECT;	UNWIND => {CleanUp[]};      END;    hearldWindowSlot ¬ HeraldWindow.GetCursorSlot[];    HeraldWindow.StoreCursor[slot: hearldWindowSlot, cursor: @cursorArray];    HeraldWindow.SetCursorState[slot: hearldWindowSlot, state: positive];    IF NoExt[fname] THEN String.AppendString[fname, ".asm"L];    ReplaceExtension[fname, "bin"L];    IF BinaryStream # NIL THEN Stream.Delete[sH: BinaryStream];    BinaryStream ¬ MStream.ReadWrite[name: fname, release: [NIL, NIL], type: text];    CodeOutputDefs.SetBinaryStream[BinaryStream];    ReplaceExtension[fname, "lst"L];    IF ListStream # NIL THEN Stream.Delete[sH: ListStream];    ListStream ¬ MStream.ReadWrite[name: fname, release: [NIL, NIL], type: text];    ReplaceExtension[fname, "sym"L];    IF SymbolStream # NIL THEN Stream.Delete[sH: SymbolStream];    SymbolStream ¬ MStream.ReadWrite[name: fname, release: [NIL, NIL], type: text];    ListingStreamDefs.SetListingStream[ListStream];    ReplaceExtension[fname, "am"L];    CreateMapStream[fname];    PrivateStringDefs.CopyString[StatementLabel, "$$Start$"L];    [] ¬ SymbolTableDefs.PutInSymbolTable[      StatementLabel, [IOPmain[0]], DefSym, internal, FALSE, FALSE, 0, 0, 0];    ReplaceExtension[fname, "asm"L];    IF InputStream # NIL THEN Stream.Delete[sH: InputStream];    InputStream ¬ MStream.ReadOnly[name: fname, release: [NIL, NIL]];    SetInputStream[InputStream];    END; -- end ENABLE MStream.Error        currfileno ¬ maxfileno ¬ 0;  -- Initialize the file numbers.    DO  -- forever      AssembleOneInstruction[        ! EndOfInput => EXIT;        Stream.EndOfStream =>          BEGIN          ListOutputDefs.ReportError[23];          MiscString.length ¬ 0;  -- Clear string          String.AppendChar[MiscString, '\N ];          ListOutputDefs.WriteToListing[MiscString];          EXIT;          END; 	AssErr => {ListOutputDefs.ReportError[Code]; CONTINUE};	FileNotFound => {CleanUp[]; REJECT}];        HeraldWindow.SetCursorState[slot: hearldWindowSlot, state: invert];      ENDLOOP;    SymTabIODefs.WriteSymbolTable[SymbolStream];    Stream.Delete[sH: InputStream];    Stream.Delete[sH: ListStream];    Stream.Delete[sH: SymbolStream];    InputStream ¬ ListStream ¬ SymbolStream ¬ NIL;    hearldWindowSlot ¬ HeraldWindow.FreeCursorSlot[slot: hearldWindowSlot];    IF (ErrCt ¬ ListOutputDefs.ErrorsDetected[]) # 0 THEN      BEGIN      fh: MFile.Handle;      fh ¬ MFile.CopyFileHandle[        file: MStream.GetFile[BinaryStream],         release: [NIL, NIL],	access: delete];      Stream.Delete[sH: BinaryStream];      BinaryStream ¬ NIL;      MFile.Delete[file: fh];      SIGNAL AsmErr[ErrCt];      END    ELSE      BEGIN      MStream.SetLength[        stream: BinaryStream, 	fileLength: Stream.GetPosition[sH: BinaryStream]];      Stream.Delete[sH: BinaryStream];      BinaryStream ¬ NIL;      END;    END;  ReInit: PUBLIC PROC =    BEGIN    GetFile ¬ NIL;    GetStack ¬ NIL;    offset ¬ 0;    firstchar ¬ FALSE;    list ¬ TRUE;    PrevPC ¬ 177777B;    currfileno ¬ maxfileno ¬ 0;    IF BinaryStream # NIL THEN Stream.Delete[sH: BinaryStream];    IF ListStream # NIL THEN Stream.Delete[sH: ListStream];    IF SymbolStream # NIL THEN Stream.Delete[sH: SymbolStream];    IF InputStream # NIL THEN Stream.Delete[sH: InputStream];    InputStream ¬ BinaryStream ¬ ListStream ¬ SymbolStream ¬ NIL;    END;  Init: PROCEDURE =    BEGIN    MiscString ¬ Heap.systemZone.NEW[StringBody[120]];    GetFile ¬ NIL;    GetStack ¬ NIL;    StatementLabel ¬ Heap.systemZone.NEW[StringBody[32]];    LastLabel ¬ Heap.systemZone.NEW[StringBody[32]];    offset ¬ 0;    firstchar ¬ FALSE;    list ¬ TRUE;    PrevPC ¬ 177777B;    currfileno ¬ maxfileno ¬ 0;    InputStream ¬ BinaryStream ¬ ListStream ¬ SymbolStream ¬ NIL;    END;  Init[];  END.-- LOG:-- August 16, 1979  11:31 AM - PaD  DXS  -- July 7, 1980  11:23 AM - Roy RXO  -- October 6, 1981  6:27 PM - PXO      - Changed interfaces to run on Dandelion-- October 21, 1981  5:43 PM - PXO      - Changed some procs to deal in longs.-- 14-Apr-82 16:50:39 - ETN   - Convert to Trinity.-- 17-May-82 15:56:19 - ETN   - Fix bug in handling assembly errors.-- 25-Jan-83 13:42:56 - ETN   - Sierra. Heap.systemZone.NEW => Storage.String -- 23-May-83 23:08:51 - DEG      - Release streams if error(s) encountered.  Also, make sure that cursor is positive when done.-- 29-May-83 17:03:12 - DEG      - Replace Cursor interface with HeraldWindow interface-- 30-May-83 16:13:05 - DEG      - Remove references to the Ascii interface-- 16-Sep-83  1:17:49 - DEG      - converted to Klamath 11.0b--  8-Oct-83  1:39:48 - DEG      - fixed EndOfStream bug-- Time: 26-Sep-84 23:26:01	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
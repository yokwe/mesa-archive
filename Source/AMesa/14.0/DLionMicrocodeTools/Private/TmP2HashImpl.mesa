-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TmP2HashImpl.mesa.-- Last edit: ETN     21-Jan-83 10:44:11-- Last edit: DEG        26-Sep-84 20:55:26DIRECTORY  Heap USING [Create, Delete, MakeNode],  Stream USING [Position],  Time USING [Current],  TmLabel USING [ConstraintChain, ia7Type, MiSeqNum],  TmModule,  TmP2Hash;TmP2HashImpl: PROGRAM  IMPORTS Heap, Time  EXPORTS TmModule, TmP2Hash =  BEGIN OPEN TmP2Hash;  -- GLOBAL VARIABLES  constraintArray: PUBLIC LONG POINTER TO TmP2Hash.ConstraintArray;  curID: PUBLIC ExportID;  curMI: PUBLIC CARDINAL [0..5120);  errorLevel: PUBLIC CARDINAL;  -- from MassPass2  exportRecList: PUBLIC TmP2Hash.ExportDataRecPtr;  ia7Array: PUBLIC LONG POINTER TO TmP2Hash.Ia7Array;  miLtoV: PUBLIC LONG POINTER TO TmP2Hash.MiLtoV;  miVtoLtxt: PUBLIC LONG POINTER TO TmP2Hash.MiVtoLtxt;  labIoff: PUBLIC ARRAY [0..maxSrcFiles) OF CARDINAL;  miRtoV: PUBLIC LONG POINTER TO TmP2Hash.MiRtoV;  miVtoR: PUBLIC LONG POINTER TO TmP2Hash.MiVtoR;  mi2Res: PUBLIC LONG POINTER TO TmP2Hash.Mi2Res;  miIoff: PUBLIC ARRAY [0..maxSrcFiles) OF CARDINAL;  pass2HashTable: LONG POINTER TO ARRAY [0..pass2HashSize) OF Pass2HashEntryPtr;  pass2MiSpace: UNCOUNTED ZONE;  pass2HashSize: CARDINAL = 997;  -- should be a prime  pass2HashSpace: UNCOUNTED ZONE;  realMI: PUBLIC TmLabel.MiSeqNum;  xSpace: UNCOUNTED ZONE;  -- PROCEDURES  InitGlobalP2Hash: PUBLIC PROCEDURE =    BEGIN    constraintArray ¬ NIL;    curID ¬ LOOPHOLE[Time.Current[], TmP2Hash.ExportID];    curMI ¬ 0;    errorLevel ¬ 0;  -- from MassPass2    exportRecList ¬ NIL;    ia7Array ¬ NIL;    miLtoV ¬ NIL;    miVtoLtxt ¬ NIL;    miRtoV ¬ NIL;    miVtoR ¬ NIL;    mi2Res ¬ NIL;    pass2HashTable ¬ NIL;    pass2MiSpace ¬ NIL;    pass2HashSpace ¬ NIL;    realMI ¬ 0;    xSpace ¬ NIL;    END;  --  of Procedure InitGlobalP2Hash  BuildHashCode: PROCEDURE [str: LONG STRING] RETURNS [hc: CARDINAL] = INLINE    BEGIN    i: CARDINAL;    hc ¬ 0;    FOR i IN [0..str.length) DO hc ¬ (2*hc) + LOOPHOLE[str[i], CARDINAL]; ENDLOOP;    hc ¬ (hc + (hc/16)) MOD pass2HashSize;    RETURN[hc];    END;  --  of Procedure BuildHashCode  DisplayPass2Hash: PUBLIC PROCEDURE [proc: PROCEDURE [Pass2HashEntryPtr]] =    BEGIN    i: CARDINAL;    p: Pass2HashEntryPtr;    FOR i IN [0..pass2HashSize) DO      p ¬ pass2HashTable[i];      UNTIL p = NIL DO proc[p]; p ¬ p.next; ENDLOOP;      ENDLOOP;    END;  --  of Procedure DisplayPass2Hash  EqualString: PROCEDURE [str1, str2: LONG STRING] RETURNS [BOOLEAN] = INLINE    BEGIN    i: CARDINAL;    IF str1.length # str2.length THEN RETURN[FALSE];    FOR i IN [0..str1.length) DO IF str1[i] # str2[i] THEN RETURN[FALSE]; ENDLOOP;    RETURN[TRUE];    END;  --  of Procedure EqualString  EraseMiSpace: PUBLIC PROCEDURE =    BEGIN    IF pass2MiSpace # NIL THEN Heap.Delete[pass2MiSpace];    pass2MiSpace ¬ NIL;    END;  ErasePass2Hash: PUBLIC PROCEDURE =    BEGIN    IF pass2HashSpace # NIL THEN Heap.Delete[pass2HashSpace];    pass2HashSpace ¬ NIL;    END;  EraseXSpace: PUBLIC PROCEDURE =    BEGIN IF xSpace # NIL THEN Heap.Delete[xSpace]; xSpace ¬ NIL; END;  FindPass2Label: PUBLIC PROCEDURE [str: LONG STRING]    RETURNS [h: Pass2HashEntryPtr] =    BEGIN    hashCode: CARDINAL;    p: Pass2HashEntryPtr;    hashCode ¬ BuildHashCode[str];    p ¬ pass2HashTable[hashCode];    UNTIL p = NIL DO      IF EqualString[p.key, str] THEN RETURN[p]; p ¬ p.next; ENDLOOP;    RETURN[NIL];    END;  -- of procedure FindPass2Hash  GetMiSpace: PUBLIC PROCEDURE [nwords: CARDINAL] RETURNS [p: LONG POINTER] = {    p ¬ Heap.MakeNode[pass2MiSpace, nwords]};  GetPass2Space: PUBLIC PROCEDURE [nwords: CARDINAL] RETURNS [p: LONG POINTER] = {    p ¬ Heap.MakeNode[pass2HashSpace, nwords]};  GetXSpace: PUBLIC PROCEDURE [nwords: CARDINAL] RETURNS [p: LONG POINTER] = {    p ¬ Heap.MakeNode[xSpace, nwords]};  GetXString: PUBLIC PROCEDURE [nchars: CARDINAL] RETURNS [s: LONG STRING] =    BEGIN s ¬ xSpace.NEW [StringBody[nchars]]; END;  -- end GetXString  InitPass2Space: PUBLIC PROCEDURE =    BEGIN    i: CARDINAL;    pass2HashSpace ¬ Heap.Create[      initial: 16, increment: 8];    xSpace ¬ Heap.Create[initial: 4, increment: 2];    pass2HashTable ¬ GetPass2Space[pass2HashSize*SIZE[Pass2HashEntryPtr]];    FOR i IN [0..pass2HashSize) DO pass2HashTable[i] ¬ NIL; ENDLOOP;    pass2MiSpace ¬ Heap.Create[      initial: 125, increment: 50, largeNodeThreshold: 11000];    END;  -- end InitPass2Space  InsertPass2Hash: PUBLIC PROCEDURE [h: Pass2HashEntryPtr] =    BEGIN    hashCode: CARDINAL;    hp: LONG POINTER TO Pass2HashEntryPtr;    p: Pass2HashEntryPtr;    hashCode ¬ BuildHashCode[h.key];    p ¬ pass2HashTable[hashCode];    hp ¬ @pass2HashTable[hashCode];    UNTIL p = NIL DO hp ¬ @p.next; p ¬ p.next; ENDLOOP;    hp­ ¬ h;    END;  -- of procedure InsertPass2Hash  END... -- end MassPass2Hash    -- Log  -- 16-Jul-82 10:11:23 - ETN        - TrinityMass Version 1  -- 21-Jan-83 10:44:05 - ETN        - Sierra. Replace Heap.MakeString.  --                                   Eliminate use of mySpace and mySpace2  --                                   as Heap.Create.parent  -- Time: 26-Sep-84 20:55:02	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.  
-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TmEncodePatternImpl.mesa.-- Last edit: DEG      26-Sep-84 20:41:05-- Last edit: JAC    11-Jul-83 13:54:38  -- Last edit: ETN    9-Jun-82 13:28:22-- The purpose of this module is to fill in Encoding records from patterns.  If a pattern cannot be encoded due to a field conflict or bus conflict, an error message will be chained to phrase.tempErrorMsgs.  If an alternate pattern can be encoded, the error messages will be deleted; otherwise they will be chained onto phrase.errorMsgs by the Encode module.        DIRECTORY  TmAssembler;TmEncodePatternImpl: PROGRAM IMPORTS TmAssembler EXPORTS TmAssembler =  BEGIN OPEN TmAssembler;  -- GLOBAL VARIABLES  dontCare: CARDINAL = 177777B;  initialEncoding: Encoding ¬ [];  -- SIGNALS AND ERRORS GENERATED  EncodePatternError: ERROR [    {    rAinvalid, rBinvalid, aDinvalid, aFinvalid, aSinvalid, cinInvalid, cyInvalid,    enSUInvalid, fS01Invalid, fS2Invalid, fS3Invalid, fXinvalid, fYinvalid,    fZinvalid, ia7Invalid, memInvalid, booleanValue, xInInvalid, xOutInvalid,    yInInvalid, yOutInvalid, RHrefInvalid, unknownXBusSource}] = CODE;  AllocateEncodingRecord: PUBLIC PROCEDURE RETURNS [encoding: EncodingPtr] =    BEGIN OPEN encoding;    -- Allocate and initialize Encoding record.     encoding ¬ GetStmtSpace[SIZE[Encoding]];    encoding­ ¬ initialEncoding;    RETURN;    END;  -- end AllocateEncodingRecord  EncodePattern: PUBLIC PROCEDURE [    phrase: PhrasePtr, pattern: PatternPtr, encoding: EncodingPtr,    assignment: Assignment] RETURNS [successful: BOOLEAN] =    BEGIN    -- Given a pointer to a pattern, a pointer to an Encoding record, and two arguments, fill in the Encoding record. The Assignment indicates what the field is being assigned to: a macro, an expression, or a register assignment.  This is used to print an error message in case of a conflict.      arg2: CARDINAL ¬ phrase.arg2;    arg1: CARDINAL ¬ phrase.arg1;    arg: CARDINAL ¬ phrase.arg;    fa: FieldAssignment;    savedEncoding: Encoding;    text: LONG STRING;    value: CARDINAL;    Field: PROCEDURE = INLINE      BEGIN      IF fa.assignment.type # null THEN        IF fa.value # value THEN          BEGIN          FormatError[phrase, assignment, fa.assignment, text];          successful ¬ FALSE;          END;      END;  -- end Field    IF encoding = NIL THEN RETURN[FALSE];    savedEncoding ¬ encoding­;    successful ¬ TRUE;  -- Assume this is going to work.    IF pattern.rA # x THEN      BEGIN      value ¬        SELECT pattern.rA FROM          a1 => arg1,          a2 => arg2,          aH => arg/16,          ENDCASE => ERROR EncodePatternError[rAinvalid];      fa ¬ encoding.rA;      text ¬ "rA"L;      Field[];      encoding.rA ¬ FieldAssignment[assignment, value];      END;    IF pattern.rB # x THEN      BEGIN      value ¬        SELECT pattern.rB FROM          a1 => arg1,          a2 => arg2,          aL => arg,          ENDCASE => ERROR EncodePatternError[rBinvalid];      fa ¬ encoding.rB;      text ¬ "rB"L;      Field[];      encoding.rB ¬ FieldAssignment[assignment, value];      END;    IF pattern.aS # x THEN      BEGIN      value ¬        SELECT pattern.aS FROM          AQ => aSAQ,          AB => aSAB,          ZQ => aS0Q,          ZB => aS0B,          ZA => aS0A,          DA => aSDA,          DQ => aSDQ,          DZ => aSD0,          ENDCASE => ERROR EncodePatternError[aSinvalid];      fa ¬ encoding.aS;      text ¬ "aS"L;      Field[];      encoding.aS ¬ FieldAssignment[assignment, value];      END;    IF pattern.aF # x THEN      BEGIN      value ¬        SELECT pattern.aF FROM          rPlusS => aFrPlusS,          sMinusR => aFsMinusR,          rMinusS => aFrMinusS,          rOrS => aFrOrS,          rAndS => aFrAndS,          notRandS => aFnotRandS,          rXorS => aFrXorS,          notRxorS => aFnotRxorS,          ENDCASE => ERROR EncodePatternError[aFinvalid];      fa ¬ encoding.aF;      text ¬ "aF"L;      Field[];      encoding.aF ¬ FieldAssignment[assignment, value];      encoding.aluOut ¬ TRUE;      END;    IF pattern.cin # x THEN      BEGIN      value ¬        SELECT pattern.cin FROM          t => 1,          f => 0,          ENDCASE => ERROR EncodePatternError[cinInvalid];      fa ¬ encoding.cin;      text ¬ "cin"L;      Field[];      encoding.cin ¬ FieldAssignment[assignment, value];      END;    IF pattern.enSU # x THEN      BEGIN      value ¬        SELECT pattern.enSU FROM          t => 1,          f => 0,          ENDCASE => ERROR EncodePatternError[enSUInvalid];      fa ¬ encoding.enSU;      text ¬ "enSU"L;      Field[];      encoding.enSU ¬ FieldAssignment[assignment, value];      END;    IF pattern.mem # x THEN      BEGIN      value ¬        SELECT pattern.mem FROM          t => 1,          f => 0,          ENDCASE => ERROR EncodePatternError[memInvalid];      fa ¬ encoding.mem;      text ¬ "mem"L;      Field[];      encoding.mem ¬ FieldAssignment[assignment, value];      END;    IF pattern.cy # x THEN      BEGIN      value ¬        SELECT pattern.cy FROM          c1 => 1,          c2 => 2,          c3 => 3,          cX => 4,          ENDCASE => ERROR EncodePatternError[cyInvalid];      fa ¬ encoding.cy;      text ¬ "cy"L;      Field[];      encoding.cy ¬ FieldAssignment[assignment, value];      END;    IF pattern.ia7 # x THEN      BEGIN      value ¬        SELECT pattern.ia7 FROM          t => 3,          f => 2,          ENDCASE => ERROR EncodePatternError[ia7Invalid];      fa ¬ encoding.ia7;      text ¬ "ia7"L;      Field[];      encoding.ia7 ¬ FieldAssignment[assignment, value];      END;    IF pattern.fS01 # x THEN      BEGIN      value ¬        SELECT pattern.fS01 FROM          byte => fS01byte,          Disp => fS01dispBr,          norm => fS01fYNorm,          IOut => fS01IOOut,          ENDCASE => ERROR EncodePatternError[fS01Invalid];      fa ¬ encoding.fS01;      text ¬ "fS01"L;      Field[];      encoding.fS01 ¬ FieldAssignment[assignment, value];      END;    IF pattern.fS2 # x THEN      BEGIN      value ¬        SELECT pattern.fS2 FROM          stkP => fS2stackP,          norm => fS2fZNorm,          nibl => fS2nibble,          IOIn => fS2IOIn,          uadr => fS2uaddr,          byte => fS2byte,          ENDCASE => ERROR EncodePatternError[fS2Invalid];      fa ¬ encoding.fS2;      text ¬ "fS2"L;      Field[];      encoding.fS2 ¬ FieldAssignment[assignment, value];      END;    IF pattern.fS3 # x THEN      BEGIN      value ¬        SELECT pattern.fS3 FROM          norm => fS3fZNorm,          nibl => fS3nibble,          IOIn => fS3IOIn,          byte => fS3byte,          ENDCASE => ERROR EncodePatternError[fS3Invalid];      fa ¬ encoding.fS3;      text ¬ "fS3"L;      Field[];      encoding.fS3 ¬ FieldAssignment[assignment, value];      END;    IF pattern.aD # x THEN      BEGIN      value ¬        SELECT pattern.aD FROM          a1 => arg1,          A => aDA,          B => aDB,          ENDCASE => ERROR EncodePatternError[aDinvalid];      IF NOT FieldaD[phrase, encoding, assignment, value] THEN successful ¬ FALSE;      END;    IF pattern.fX # x THEN      BEGIN      value ¬        SELECT pattern.fX FROM          a1 => arg1,          s => fXshift,          c => fXcycle,          RH => fXRH,          ENDCASE => ERROR EncodePatternError[fXinvalid];      fa ¬ encoding.fX;      text ¬ "fX"L;      Field[];      encoding.fX ¬ FieldAssignment[assignment, value];      END;    IF pattern.fY # x THEN      BEGIN      value ¬        SELECT pattern.fY FROM          a1 => arg1,          aH => arg/16,          aL => arg MOD 16,          c => fYcycle,          ENDCASE => ERROR EncodePatternError[fYinvalid];      fa ¬ encoding.fY;      text ¬ "fY"L;      Field[];      encoding.fY ¬ FieldAssignment[assignment, value];      END;    IF pattern.fZ # x THEN      BEGIN      value ¬        SELECT pattern.fZ FROM          a1 => arg1,          aL => arg MOD 16,          RH => fZRH,          ib => fZib,          ibLow => fZibLow,          ibHigh => fZibHigh,          ENDCASE => ERROR EncodePatternError[fZinvalid];      fa ¬ encoding.fZ;      text ¬ "fZ"L;      Field[];      encoding.fZ ¬ FieldAssignment[assignment, value];      END;    SELECT pattern.wU FROM t => encoding.wU ¬ TRUE; ENDCASE;    SELECT pattern.xIn FROM      f => NULL;      t =>        -- This function requires input from the X bus.        encoding.xIn ¬ TRUE;      ENDCASE => ERROR EncodePatternError[xInInvalid];    SELECT pattern.yIn FROM      f => NULL;      t =>        -- This function requires input from the Y bus.        encoding.yIn ¬ TRUE;      ENDCASE => ERROR EncodePatternError[yInInvalid];    SELECT pattern.xOut FROM      f => NULL;      t => encoding.xOut ¬ TRUE;      ENDCASE => ERROR EncodePatternError[xOutInvalid];    SELECT pattern.yOut FROM      f => NULL;      t =>        -- This function puts a signal on the Y Bus.        encoding.yOut ¬ TRUE;      ENDCASE => ERROR EncodePatternError[yOutInvalid];    SELECT pattern.aluIn FROM      f => NULL;      t =>        -- This function requires input from the ALU.        encoding.aluIn ¬ TRUE;      ENDCASE => ERROR EncodePatternError[yInInvalid];    SELECT pattern.RHref FROM      x => NULL;      r =>        BEGIN        IF encoding.RHref = w THEN          BEGIN MultipleReference[phrase, "RH"L]; successful ¬ FALSE; END;        encoding.RHref ¬ r;        END;      w =>        BEGIN        IF encoding.RHref = r THEN          BEGIN MultipleReference[phrase, "RH"L]; successful ¬ FALSE; END;        encoding.RHref ¬ w;        END;      ENDCASE => ERROR EncodePatternError[RHrefInvalid];    SELECT pattern.xl FROM      f => NULL;      t =>        -- This function requires input from the X bus.        encoding.xbusLoad ¬ TRUE;      ENDCASE => ERROR EncodePatternError[yInInvalid];    SELECT pattern.yl FROM      f => NULL;      t =>        -- This function requires input from the Y or F bus.        encoding.ybusLoad ¬ TRUE;      ENDCASE => ERROR EncodePatternError[yInInvalid];    IF NOT successful THEN encoding­ ¬ savedEncoding;    RETURN;    END;  -- end EncodePattern  FieldaD: PUBLIC PROCEDURE [    phrase: PhrasePtr, encoding: EncodingPtr, assignment: Assignment,    value: CARDINAL] RETURNS [valid: BOOLEAN] =    BEGIN    assignQ: CARDINAL = 0;    assignY: CARDINAL = 2;    assignB: CARDINAL = 3;    BEGIN  -- Begin FieldaD    valid ¬ TRUE;  -- Assume this will work.    IF value = dontCare THEN RETURN;    IF encoding.aD.value = value THEN RETURN;    IF encoding.aD.assignment.type = null THEN GO TO AssignNewValue;    SELECT encoding.aD.value FROM      assignQ => GO TO FormatError;      assignY =>        IF value = assignB THEN encoding.assignB ¬ TRUE          -- The new value is assign to rB.  We leave the code assignY because this also assigns ALU output to rB.  We set assignB to remember that rB has been assigned.        ELSE GO TO FormatError;      assignB =>        IF value = assignQ THEN GO TO FormatError ELSE GO TO AssignNewValue;      ENDCASE => GO TO FormatError;    EXITS      AssignNewValue =>        BEGIN        encoding.aD.assignment ¬ assignment;        encoding.aD.value ¬ value;        SELECT value FROM          assignY => encoding.assignBrequired ¬ TRUE;          -- assignY also causes assignment to the register specified in field rB.  We must be sure that the instruction also requires assignment to rB.          IN [3..7] => encoding.assignB ¬ TRUE;          ENDCASE;        END;  -- of AssignNewValue      FormatError =>        BEGIN        FormatError[phrase, assignment, encoding.aD.assignment, "aD"L];        valid ¬ FALSE;        END;    END;    RETURN;    END;  -- end FieldaD    -- MAIN LINE CODE  END...    -- Log:  -- Time: 26-Sep-84 20:40:58	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.  -- 11-Jul-83 14:02:14 - JAC        - Using statement segments  -- 16-Jul-82 10:11:23 - ETN        - TrinityMass Version 1
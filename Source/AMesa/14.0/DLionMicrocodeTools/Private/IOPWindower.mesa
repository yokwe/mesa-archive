-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- IOPWindower.mesa, HGM,  9-Nov-83 18:41:50DIRECTORY  Format USING [StringProc],  Environment USING [Byte],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, newLine, NumberItem, ProcType,    StringItem, ToggleVisibility],  Heap USING [systemZone],  Process USING [Detach, MsecToTicks, Pause],  Put USING [CR, Date, Decimal, Line, Text],  Runtime USING [GetBcdTime],  Selection USING [Convert],  String USING [    AppendLongDecimal, AppendNumber, AppendString,    AppendStringAndGrow, CopyToNewString, Empty],  System USING [GetGreenwichMeanTime],  TextSW USING [ForceOutput],  Time USING [Append, Unpack],  Tool USING [Create, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [    CancelPeriodicNotify, CreatePeriodicNotify, PeriodicNotifyHandle, PeriodicProcType,    UserAbort],  Version USING [Append],  Window USING [Handle],    CommandFile USING [CommandsFromFile, Error, SomebodyRunning],  CPCommand USING [Continue, Error],  CPKernel USING [GetState],  IOP USING [Address, Instruction],  IOPBreak USING [ClearAllBreaks, EnumerateBreaks, Error, RemoveBreaks],  IOPCommand USING [    Boot, Break, Error, Continue, Load, LoadModuleSymbols,    LoadSymbols, PrintState, SetPC, Step, Stop, Unbreak],  IOPKernel USING [    Error, GetBootSeq, GetState, GetStateSeq, InKernel, ProbeForStateChange,    ReadInstruction, ReadMemory, ReadPair, State],  IOPPanel USING [Destroy, MakePanelSW, Refresh],  IOPSyms USING [    Error, Eval, AppendInstruction, AppendMemoryAddress, AppendRegister, Symbol];IOPWindower: PROGRAM  IMPORTS    FormSW, Heap, Process, Put, Runtime, Selection, String, System,    TextSW, Time, Tool, UserInput, Version,    CPCommand, CPKernel, CommandFile, IOPBreak, IOPCommand, IOPKernel, IOPPanel, IOPSyms  EXPORTS IOPCommand =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    typeIn, run: LONG STRING ¬ NIL;  topForm, log, form, panel: Window.Handle;  state: IOPKernel.State;  seq, boot: CARDINAL;  refreshNeeded, flushDuplicates, flushStateChange: BOOLEAN ¬ FALSE;  notifier: UserInput.PeriodicNotifyHandle;  clumpSize: CARDINAL ¬ 10;  Boot: FormSW.ProcType =    BEGIN ENABLE IOPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    IOPCommand.Boot[LogString, log];    END;  Load: FormSW.ProcType =    BEGIN ENABLE IOPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    IOPCommand.Load[LogString, log, filename];    IOPCommand.LoadSymbols[LogString, log, filename];    z.FREE[@filename];    END;    END;  Start: FormSW.ProcType =    BEGIN ENABLE IOPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    pc: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@pc];    PostDate[];    IOPCommand.SetPC[LogString, log, pc];    IOPCommand.Continue[LogString, log];    z.FREE[@pc];    END;    END;  Continue: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPCommand.Error => BEGIN TailMessage[reason]; CONTINUE; END;      IOPCommand.Error => BEGIN TailMessage[reason]; CONTINUE; END;      END;    PostDate[];    IF CPKernel.GetState[] # dead THEN CPCommand.Continue[LogString, log, TRUE]    ELSE IOPCommand.Continue[LogString, log];    END;  Step: FormSW.ProcType =    BEGIN ENABLE IOPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    IOPCommand.Step[LogString, log];    END;  Stop: FormSW.ProcType =    BEGIN ENABLE IOPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    IOPCommand.Stop[LogString, log];    END;  Run: FormSW.ProcType =    BEGIN    filename: LONG STRING ¬ String.CopyToNewString[run, z];    IF String.Empty[filename] THEN filename ¬ Selection.Convert[string];    Put.CR[log];    flushStateChange ¬ TRUE;    FormSW.ToggleVisibility[form, runIx];    Process.Detach[FORK Runner[filename]];    FOR i: CARDINAL IN [0..10) DO      IF CommandFile.SomebodyRunning[] THEN EXIT;      Process.Pause[Process.MsecToTicks[100]];      ENDLOOP;    END;    Runner: PROCEDURE [filename: LONG STRING] =    BEGIN    BEGIN ENABLE CommandFile.Error =>      BEGIN      temp: STRING = [200];      String.AppendString[temp, "Error in command file at position "L];      String.AppendLongDecimal[temp, position];      String.AppendString[temp, ": "L];      String.AppendString[temp, reason];      TailMessage[temp];      CONTINUE;      END;    CommandFile.CommandsFromFile[LogString, log, Abort, filename];    END;    z.FREE[@filename];    FormSW.ToggleVisibility[form, runIx];    END;  LoadNoSyms: FormSW.ProcType =    BEGIN ENABLE IOPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    IOPCommand.Load[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadSymbols: FormSW.ProcType =    BEGIN ENABLE IOPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@filename];    IOPCommand.LoadSymbols[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadModSyms: FormSW.ProcType =    BEGIN ENABLE IOPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@filename];    IOPCommand.LoadModuleSymbols[LogString, log, filename];    z.FREE[@filename];    END;    END;  Refresh: FormSW.ProcType =    BEGIN    refreshNeeded ¬ flushStateChange ¬ TRUE;    END;    What: FormSW.ProcType =    BEGIN ENABLE      IOPSyms.Error => BEGIN TailMessage[reason]; CONTINUE; END;    string: LONG STRING ¬ Selection.Convert[string];    other: LONG STRING = [200];    value: IOPSyms.Symbol;    BEGIN ENABLE UNWIND => z.FREE[@string];    PostMessage["Decoding "L];    IF string = NIL THEN      BEGIN      TailMessage["  Selection required"L];      RETURN;      END;    TailMessage[string];    value ¬ IOPSyms.Eval[string];    WITH value SELECT FROM      number =>        BEGIN	String.AppendString[other, "Number: "L];        IOPSyms.AppendMemoryAddress[other, n, TRUE];	AppendLotsOfModes[other, n];	END;      at =>        BEGIN	String.AppendString[other, "IOP memory location of (@) "L];        IOPSyms.AppendMemoryAddress[other, to, TRUE];	AppendLotsOfModes[other, to];	END;      reg =>        BEGIN	String.AppendString[other, "IOP register "L];        IOPSyms.AppendRegister[other, reg];	END;      pair =>        BEGIN	String.AppendString[other, "IOP pair "L];	String.AppendString[other, "????? "L];	END;      byte =>        BEGIN	String.AppendString[other, "IOP memory location "L];        IOPSyms.AppendMemoryAddress[other, mem, TRUE];	AppendLotsOfModes[other, mem];	END;      word =>        BEGIN	String.AppendString[other, "IOP memory location (word) "L];        IOPSyms.AppendMemoryAddress[other, mem, TRUE];	AppendLotsOfModes[other, mem];	END;      instruction =>        BEGIN	String.AppendString[other, "IOP memory location (instruction) "L];        IOPSyms.AppendMemoryAddress[other, mem, TRUE];	AppendLotsOfModes[other, mem];	END;      ENDCASE => ERROR;    TailMessage[other];    z.FREE[@string];    END;    END;    AppendLotsOfModes: PROCEDURE [s: LONG STRING, d: WORD] =    BEGIN    String.AppendString[s, " = "L];    String.AppendNumber[s, d, 16];    String.AppendString[s, "'X = "L];    String.AppendNumber[s, d, 10];    String.AppendString[s, "'D = "L];    String.AppendNumber[s, d, 8];    String.AppendString[s, "'B"L];    END;   Break: FormSW.ProcType =    BEGIN ENABLE IOPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    where: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@where];    IF where = NIL THEN where ¬ String.CopyToNewString[typeIn, z];    IF where = NIL THEN      BEGIN      TailMessage["  Selection/Typein required"L];      RETURN;      END;    IOPCommand.Break[LogString, log, where];    z.FREE[@where];    END;    END;   Unbreak: FormSW.ProcType =    BEGIN ENABLE IOPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    where: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@where];    IOPCommand.Unbreak[LogString, log, where];    z.FREE[@where];    END;    END;   ClearAllBreaks: FormSW.ProcType =    BEGIN ENABLE IOPBreak.Error =>      BEGIN      PostMessage["Oops, "L];      TailMessage[reason];      CONTINUE;      END;    PostMessage["Clearing All IOP Breaks "L];    AppendMessage[" ... "L];    IOPBreak.ClearAllBreaks[];    TailMessage["ok"L];    END;  ListBreaks: FormSW.ProcType =    BEGIN ENABLE IOPBreak.Error =>      BEGIN      PostMessage["Oops, "L];      TailMessage[reason];      CONTINUE;      END;    i: CARDINAL ¬ 0;    PrintOne: PROCEDURE [pc: IOP.Address] =      BEGIN      temp: STRING = [100];      i ¬ i + 1;      Put.Text[log, "IOP Break #"L];      Put.Decimal[log, i];      Put.Text[log, " is located at "L];      String.AppendNumber[temp, pc, 16];      String.AppendString[temp, " ("L];      IOPSyms.AppendMemoryAddress[temp, pc, TRUE];      String.AppendString[temp, ")."L];      Put.Line[log, temp];      END;    Put.CR[log];    Put.Line[log, "IOP Breakpoints:"L];    IOPBreak.EnumerateBreaks[PrintOne];    Put.Line[log, "Done"L];    END;   Stack: FormSW.ProcType =    BEGIN ENABLE IOPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    sp: IOP.Address;    PostMessage["Scanning IOP Stack ..."L];    sp ¬ IOPKernel.ReadPair[sp];    TailMessage[NIL];    FOR i: CARDINAL IN [0..clumpSize) DO      temp: STRING = [100];      high, low: Environment.Byte;      word: IOP.Address;      IF UserInput.UserAbort[log] THEN EXIT;      high ¬ IOPKernel.ReadMemory[sp+1];      low ¬ IOPKernel.ReadMemory[sp];      word ¬ high * 256 + low;      String.AppendNumber[temp, sp, 16];      String.AppendString[temp, "/ "L];      String.AppendNumber[temp, word, 16];      String.AppendString[temp, " = "L];      IOPSyms.AppendMemoryAddress[temp, word, TRUE];      Put.Line[log, temp];      sp ¬ sp + 2;      ENDLOOP;    END;   Instructions: FormSW.ProcType =    BEGIN ENABLE      BEGIN      IOPSyms.Error => BEGIN TailMessage[reason]; CONTINUE; END;      IOPKernel.Error => BEGIN TailMessage[reason]; CONTINUE; END;      END;    finger: IOP.Address;    where: LONG STRING ¬ Selection.Convert[string];    value: IOPSyms.Symbol;    BEGIN ENABLE UNWIND => z.FREE[@where];    PostMessage["Dumping IOP Instructions ..."L];    IF where = NIL THEN      BEGIN      TailMessage["Selection expected"L];      z.FREE[@where];      RETURN;      END;    value ¬ IOPSyms.Eval[where];    WITH value SELECT FROM      number => finger ¬ n;      at, reg, pair =>        BEGIN	TailMessage["PC should be in IOP Memory"L];        z.FREE[@where];        RETURN;	END;      byte, word, instruction => finger ¬ mem;      ENDCASE => ERROR;    TailMessage[NIL];    FOR i: CARDINAL IN [0..clumpSize) DO      temp: STRING = [100];      instruction: IOP.Instruction;      IF UserInput.UserAbort[log] THEN EXIT;      instruction ¬ IOPKernel.ReadInstruction[finger];      IOPSyms.AppendMemoryAddress[temp, finger];      String.AppendString[temp, "/ "L];      IOPSyms.AppendInstruction[temp, instruction];      Put.Line[log, temp];      finger ¬ finger + instruction.length;      ENDLOOP;    z.FREE[@where];    END;    END;   RefreshWindow: PUBLIC PROCEDURE =    BEGIN    seq ¬ IOPKernel.GetStateSeq[];    boot ¬ IOPKernel.GetBootSeq[];    state ¬ IOPKernel.GetState[];    refreshNeeded ¬ TRUE;    END;      Watcher: UserInput.PeriodicProcType =    BEGIN    IF CommandFile.SomebodyRunning[] THEN RETURN;    ProbeForStateChange[];    IF ~refreshNeeded AND seq = IOPKernel.GetStateSeq[] AND boot = IOPKernel.GetBootSeq[] THEN      BEGIN      refreshNeeded ¬ flushDuplicates ¬ flushStateChange ¬ FALSE;      RETURN;      END;    IF state # IOPKernel.GetState[] THEN flushDuplicates ¬ FALSE;    seq ¬ IOPKernel.GetStateSeq[];    boot ¬ IOPKernel.GetBootSeq[];    state ¬ IOPKernel.GetState[];    IF IOPKernel.InKernel[] THEN BEGIN RemoveBreaks[]; IOPPanel.Refresh[]; END;    IF ~flushDuplicates THEN      BEGIN      PostDate[];      IF ~flushStateChange THEN AppendMessage["State changed: "L];      IOPCommand.PrintState[LogString, log];      END;    FormSW.DisplayItem[form, stateIx];    refreshNeeded ¬ flushDuplicates ¬ flushStateChange ¬ FALSE;    END;      ProbeForStateChange: PROCEDURE =    BEGIN ENABLE IOPKernel.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    IOPKernel.ProbeForStateChange[];    END;      RemoveBreaks: PROCEDURE =    BEGIN ENABLE IOPBreak.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    IOPBreak.RemoveBreaks[];    END;      PostDate: PROCEDURE =    BEGIN    Put.CR[log];    Put.Date[log, System.GetGreenwichMeanTime[], dateTime];    Put.Text[log, "  "L];    TextSW.ForceOutput[log];    flushDuplicates ¬ TRUE;    END;  PostMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.CR[log];    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    Put.Line[log, "."L];    TextSW.ForceOutput[log]    END;  LogString: Format.StringProc =    BEGIN    Put.Text[clientData, s];    END;  Abort: PROCEDURE RETURNS [BOOLEAN] =    BEGIN    RETURN[UserInput.UserAbort[log]];    END;  Initialize: PROCEDURE =    BEGIN    herald: STRING = [100];    String.AppendString[herald, "IOP Panel "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    [] ¬ Tool.Create[      name: herald,      cmSection: "IOP Panel"L,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    Tool.UnusedLogName[logFileName, "IOP.log$"L];    topForm ¬ Tool.MakeFormSW[window: window, formProc: MakeTopForm];    log ¬ Tool.MakeFileSW[window: window, name: logFileName, h: 100];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    panel ¬ IOPPanel.MakePanelSW[window, log, ModifyTypeIn, @typeIn];    END;    stateChoices: ARRAY IOPKernel.State OF FormSW.Enumerated ¬ [    dead: ["Dead", IOPKernel.State[dead]],    booted: ["Booted", IOPKernel.State[booted]],    halted: ["Halted", IOPKernel.State[halted]],    running: ["Running", IOPKernel.State[running]],    iopBreak: ["IOP Break", IOPKernel.State[iopBreak]],    cpStop: ["CP Halt/Break", IOPKernel.State[cpStop]]];    runIx: CARDINAL = 6;  stateIx: CARDINAL = 11;  typeInIx: CARDINAL = 14;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 19;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[0] ¬ FormSW.CommandItem[tag: "Boot"L, proc: Boot, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "Load"L, proc: Load];    items[2] ¬ FormSW.CommandItem[tag: "Start"L, proc: Start];    items[3] ¬ FormSW.CommandItem[tag: "Step"L, proc: Step];    items[4] ¬ FormSW.CommandItem[tag: "Continue"L, proc: Continue];    items[5] ¬ FormSW.CommandItem[tag: "Stop"L, proc: Stop];    items[runIx] ¬ FormSW.CommandItem[tag: "Run"L, proc: Run];    items[7] ¬ FormSW.StringItem[tag: "File"L, string: @run, inHeap: TRUE];    items[8] ¬ FormSW.CommandItem[tag: "LoadNoSyms"L, proc: LoadNoSyms, place: FormSW.newLine];    items[9] ¬ FormSW.CommandItem[tag: "LoadSymbols"L, proc: LoadSymbols];    items[10] ¬ FormSW.CommandItem[tag: "LoadModSyms"L, proc: LoadModSyms];    items[stateIx] ¬ FormSW.EnumeratedItem[      tag: "State"L, value: @state, readOnly: TRUE, place: FormSW.newLine,      choices: LOOPHOLE[LONG[DESCRIPTOR[stateChoices]]]];    items[12] ¬ FormSW.CommandItem[tag: "Refresh"L, proc: Refresh];    items[13] ¬ FormSW.CommandItem[tag: "What"L, proc: What];    items[typeInIx] ¬ FormSW.StringItem[tag: "TypeIn"L, string: @typeIn, inHeap: TRUE];    items[15] ¬ FormSW.CommandItem[tag: "ListBreaks"L, proc: ListBreaks, place: FormSW.newLine];    items[16] ¬ FormSW.CommandItem[tag: "ClearAllBreaks"L, proc: ClearAllBreaks];    items[17] ¬ FormSW.CommandItem[tag: "Unbreak"L, proc: Unbreak];    items[18] ¬ FormSW.CommandItem[tag: "Break"L, proc: Break];    RETURN[items, TRUE];    END;       MakeTopForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 3;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[0] ¬ FormSW.CommandItem[tag: "Stack"L, proc: Stack, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "Instructions"L, proc: Instructions];    items[2] ¬ FormSW.NumberItem[tag: "ClumpSize"L, value: @clumpSize, default: 10];    RETURN[items, TRUE];    END;       ModifyTypeIn: PROCEDURE [newTypeIn: LONG STRING, replace: BOOLEAN] =    BEGIN    IF newTypeIn = NIL OR replace THEN typeIn.length ¬ 0;    IF newTypeIn # NIL THEN String.AppendStringAndGrow[@typeIn, newTypeIn, z];    FormSW.DisplayItem[form, typeInIx];    END;        ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN	typeIn ¬ z.NEW[StringBody[20]];	run ¬ z.NEW[StringBody[20]];	state ¬ IOPKernel.GetState[];	seq ¬ 0;        boot ¬ 0;	notifier ¬ UserInput.CreatePeriodicNotify[Watcher, window, Process.MsecToTicks[500]];        END;      new = inactive =>        BEGIN	notifier ¬ UserInput.CancelPeriodicNotify[notifier];	IOPPanel.Destroy[];	z.FREE[@typeIn];	z.FREE[@run];        END;      ENDCASE;    END;	  Initialize[];  END.
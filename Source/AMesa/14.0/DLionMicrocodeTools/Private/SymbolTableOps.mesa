-- Copyright (C) 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- SymbolTableOps.mesa-- Last edit JAC - 16-May-85 17:18:24DIRECTORY  BinaryTreeDefs USING [    FindItemInTree, InitializeTree, InsertItemInTree, Node, Item, DestroyTree],  Heap USING [Create, Delete, FreeNode, NWords, MakeNode],  MStream USING [Error, ReadOnly],  NewStateDefs USING [Address, MemoryAddress, OpType],  PrivateStringDefs USING [CopyString],  SimHashDefs USING [    CaseHeed, Create, DestroyST, EnumerateEntries, GetInfo, Hash, Lookup, PutInfo,    TempStringForHash],  Stream USING [Delete, EndOfStream, GetChar, Handle, Position],  String USING [AppendChar],  SymbolTableDefs USING [STData, OTData, RTData, PlaceList, unfItem, Scope] << ,  ZoneAllocator USING [EraseHeap, InitHeap] >>;SymbolTableOps: PROGRAM  IMPORTS    BinaryTreeDefs, Heap, MStream, PrivateStringDefs, SimHashDefs,    Stream, String <<, ZoneAllocator >>  EXPORTS SymbolTableDefs =  BEGIN  OpTab: LONG POINTER TO BinaryTreeDefs.Node;  RegTab: LONG POINTER TO BinaryTreeDefs.Node;  ExtSymTab: LONG POINTER TO BinaryTreeDefs.Node;  ExtSymTabValid: BOOLEAN;  SymTabHeap, OpAndRegHeap: UNCOUNTED ZONE;  NoOpsFile: PUBLIC SIGNAL = CODE;  PrimeTables: PUBLIC PROCEDURE =    BEGIN    stream: Stream.Handle ¬ MStream.ReadOnly[name: "8085asm.ops"L,      release: [NIL, NIL] !      MStream.Error =>        SELECT code FROM fileNotAvailable => SIGNAL NoOpsFile;	ENDCASE => REJECT; ];    ch: CHARACTER;    w: STRING ¬ [6];    n: CARDINAL;    t: NewStateDefs.OpType;    GetWord: PROCEDURE [stream: Stream.Handle, w: STRING] =      BEGIN      w.length ¬ 0;      ch ¬ GetNonBlank[stream];      DO        SELECT ch FROM          IN ['0..'9], IN ['A..'Z], IN ['a..'z] => String.AppendChar[w, ch];          ENDCASE => EXIT;        ch ¬ Stream.GetChar[sH: stream];        ENDLOOP;      END --GetWord-- ;    GetNumber: PROCEDURE [stream: Stream.Handle] RETURNS [n: CARDINAL] =      BEGIN      w: STRING ¬ [6];      b: CARDINAL ¬ 10;      i: CARDINAL;      n ¬ 0;      GetWord[stream, w];      IF w[w.length - 1] NOT IN ['0..'9] THEN        BEGIN        w.length ¬ w.length - 1;        SELECT w[w.length] FROM          'x, 'X, 'h, 'H => b ¬ 16;          'b, 'B => b ¬ 8;          ENDCASE => ERROR;        END;      FOR i IN [0..w.length) DO n ¬ n*b + w[i] - '0 ENDLOOP      END --GetNumber-- ;    GetNonBlank: PROCEDURE [stream: Stream.Handle] RETURNS [ch: CHARACTER] =      BEGIN      DO        ch ¬ Stream.GetChar[sH: stream];        SELECT ch FROM          '  , '\T , '\N , '\L  => LOOP;          ENDCASE => RETURN;        ENDLOOP;      END --GetNonBlank-- ;    DO  -- until eof      ENABLE Stream.EndOfStream => EXIT;      GetWord[stream, w];      n ¬ GetNumber[stream];      t ¬ LOOPHOLE[GetNumber[stream]];      SELECT t FROM        reg, regpair => [] ¬ PutInRegTable[w, [IOPregister[LOOPHOLE[n]]], t];        UnDef, DefSym => ERROR;        ENDCASE => [] ¬ PutInOpTable[w, n, t];      ENDLOOP;    Stream.Delete[sH: stream];    END --PrimeTables-- ;  PutInSymbolTable: PUBLIC PROCEDURE [    s: LONG STRING, v: NewStateDefs.Address, t: NewStateDefs.OpType,    ext: SymbolTableDefs.Scope, rel, use: BOOLEAN, pc, size: CARDINAL,    si: Stream.Position] RETURNS [LONG POINTER TO SymbolTableDefs.STData] =    BEGIN    hash: SimHashDefs.Hash;    old: BOOLEAN;    STD: LONG POINTER TO SymbolTableDefs.STData ¬ SymTabHeap.NEW[      SymbolTableDefs.STData ¬ [v, t, ext, rel, NIL, NIL]];    IF use THEN      STD.useChain ¬ SymTabHeap.NEW[        SymbolTableDefs.PlaceList ¬ [si, size, pc, NIL]];    [hash, old] ¬ SimHashDefs.Lookup[s, TRUE];    SimHashDefs.PutInfo[hash, rel, STD];    RETURN[STD];    END;  LookUpInSymbolTable: PUBLIC PROCEDURE [s: LONG STRING]    RETURNS [p: LONG POINTER TO SymbolTableDefs.STData] =    BEGIN    hash: SimHashDefs.Hash;    old: BOOLEAN;    [hash, old] ¬ SimHashDefs.Lookup[s, FALSE];    IF old THEN [, p] ¬ SimHashDefs.GetInfo[hash] ELSE p ¬ NIL;    END;  PutInOpTable: PROCEDURE [s: STRING, v: CARDINAL, t: NewStateDefs.OpType]    RETURNS [LONG POINTER TO SymbolTableDefs.OTData] =    BEGIN    OTEntry: LONG POINTER TO BinaryTreeDefs.Item ¬ OpAndRegHeap.NEW[      BinaryTreeDefs.Item];    OTD: LONG POINTER TO SymbolTableDefs.OTData ¬ OpAndRegHeap.NEW[      SymbolTableDefs.OTData ¬ [v, t]];    OTEntry.key ¬ OpAndRegHeap.NEW[StringBody [s.length]];    PrivateStringDefs.CopyString[OTEntry.key, s];    OTEntry.ptr ¬ OTD;    OpTab ¬ BinaryTreeDefs.InsertItemInTree[OTEntry, OpTab];    RETURN[OTD];    END;  LookUpInOpTable: PUBLIC PROCEDURE [s: LONG STRING]    RETURNS [LONG POINTER TO SymbolTableDefs.OTData] =    BEGIN    OTEntry: LONG POINTER TO BinaryTreeDefs.Item ¬ BinaryTreeDefs.FindItemInTree[      s, OpTab];    RETURN[IF OTEntry = NIL THEN NIL ELSE OTEntry.ptr];    END;  PutInRegTable: PROCEDURE [    s: STRING, v: NewStateDefs.Address, t: NewStateDefs.OpType]    RETURNS [LONG POINTER TO SymbolTableDefs.RTData] =    BEGIN    RTEntry: LONG POINTER TO BinaryTreeDefs.Item ¬ OpAndRegHeap.NEW[      BinaryTreeDefs.Item];    RTD: LONG POINTER TO SymbolTableDefs.RTData ¬ OpAndRegHeap.NEW[      SymbolTableDefs.RTData ¬ [v, t]];    RTEntry.key ¬ OpAndRegHeap.NEW[StringBody [s.length]];    PrivateStringDefs.CopyString[RTEntry.key, s];    RTEntry.ptr ¬ RTD;    RegTab ¬ BinaryTreeDefs.InsertItemInTree[RTEntry, RegTab];    RETURN[RTD];    END;  LookUpInRegTable: PUBLIC PROCEDURE [s: LONG STRING]    RETURNS [LONG POINTER TO SymbolTableDefs.RTData] =    BEGIN    RTEntry: LONG POINTER TO BinaryTreeDefs.Item ¬ BinaryTreeDefs.FindItemInTree[      s, RegTab];    RETURN[IF RTEntry = NIL THEN NIL ELSE RTEntry.ptr];    END;  BuildExternalSymbolTable: PUBLIC PROCEDURE =    BEGIN    ExtSymTab ¬ BinaryTreeDefs.InitializeTree[];    ExtSymTabValid ¬ TRUE;    [] ¬ SimHashDefs.EnumerateEntries[PutInExtSymbolTable];    SimHashDefs.DestroyST[];    END;  PutInExtSymbolTable: PROCEDURE [h: SimHashDefs.Hash] RETURNS [BOOLEAN] =    BEGIN    ESTEntry: LONG POINTER TO BinaryTreeDefs.Item ¬ SymTabHeap.NEW[      BinaryTreeDefs.Item];    s: LONG STRING ¬ SimHashDefs.TempStringForHash[h];    ESTEntry.key ¬ SymTabHeap.NEW[StringBody [s.length]];    PrivateStringDefs.CopyString[ESTEntry.key, s];    [, ESTEntry.ptr] ¬ SimHashDefs.GetInfo[h];    IF NOT ExtSymTabValid THEN ERROR;    ExtSymTab ¬ BinaryTreeDefs.InsertItemInTree[ESTEntry, ExtSymTab];    RETURN[TRUE];    END;  LookUpInExternalSymbolTable: PUBLIC PROCEDURE [s: STRING]    RETURNS [LONG POINTER TO SymbolTableDefs.STData] =    BEGIN    ESTEntry: LONG POINTER TO BinaryTreeDefs.Item;    IF NOT ExtSymTabValid THEN RETURN[NIL];    ESTEntry ¬ BinaryTreeDefs.FindItemInTree[s, ExtSymTab];    RETURN[IF ESTEntry = NIL THEN NIL ELSE ESTEntry.ptr];    END;  GetSymTabNode: PUBLIC PROCEDURE [nwords: Heap.NWords] RETURNS [LONG POINTER] =    BEGIN RETURN[Heap.MakeNode[z: SymTabHeap, n: nwords]] END;  FreeSymTabNode: PUBLIC PROCEDURE [p: LONG POINTER] =    BEGIN Heap.FreeNode[z: SymTabHeap, p: p] END;  ClearSymbolTable: PUBLIC PROCEDURE =    BEGIN    << SymTabHeap ¬ ZoneAllocator.EraseHeap[SymTabHeap]; >>    Heap.Delete[z: SymTabHeap--, checkEmpty: TRUE--];    SymTabHeap ¬ NIL;    --StripTree[ExtSymTab];  SymTabHeap already erased--    IF ExtSymTabValid THEN BinaryTreeDefs.DestroyTree[ExtSymTab];    ExtSymTab ¬ NIL;    ExtSymTabValid ¬ FALSE;    << OpAndRegHeap ¬ ZoneAllocator.EraseHeap[OpAndRegHeap]; >>    Heap.Delete[z: OpAndRegHeap--, checkEmpty: TRUE--];    OpAndRegHeap ¬ NIL;    BinaryTreeDefs.DestroyTree[OpTab];        BinaryTreeDefs.DestroyTree[RegTab];    OpTab ¬ BinaryTreeDefs.InitializeTree[];    RegTab ¬ BinaryTreeDefs.InitializeTree[];    PrimeStorage[];    PrimeTables[];    END;  StripTree: PROCEDURE [tree: LONG POINTER TO BinaryTreeDefs.Node] =    BEGIN    IF tree = NIL THEN RETURN;    SymTabHeap.FREE[@tree.data];    StripTree[tree.left];    StripTree[tree.right];    END;  PrimeStorage: PROCEDURE =    BEGIN    << SymTabHeap ¬ ZoneAllocator.InitHeap[SymTabHeap, 8];    OpAndRegHeap ¬ ZoneAllocator.InitHeap[OpAndRegHeap, 1]; >>    SymTabHeap ¬ Heap.Create[initial: 8];    OpAndRegHeap ¬ Heap.Create[initial: 1];    SimHashDefs.Create[8];    SimHashDefs.CaseHeed[FALSE]    END;  ReInit: PUBLIC PROC =    BEGIN    OpTab ¬ BinaryTreeDefs.InitializeTree[];    RegTab ¬ BinaryTreeDefs.InitializeTree[];    ExtSymTab ¬ NIL;    ExtSymTabValid ¬ FALSE;    PrimeStorage[];    END;  Init: PROCEDURE =    BEGIN    OpTab ¬ BinaryTreeDefs.InitializeTree[];    RegTab ¬ BinaryTreeDefs.InitializeTree[];    ExtSymTab ¬ NIL;    ExtSymTabValid ¬ FALSE;    SymTabHeap ¬ OpAndRegHeap ¬ NIL;    PrimeStorage[];    END;  Init[];  END....    -- LOG  -- ETN         8-Oct-81 20:50:00 - Convert to Trinity.  -- ETN        29-Sep-82 12:47:25 - More pages for initial symbol table.  -- DEG     	12-Jan-83 20:05:11 - Convert to Sierra.  -- DEG     	30-May-83 16:03:22 - Remove references to the Ascii interface.  -- Time: 26-Sep-84 23:23:11	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.  -- JAC     	16-May-85 17:19:28 - comment out "checkEmpty: TRUE" in calls to Heap.Delete in ClearSymbolTable since implemented in 12.0 and nodes haven't been freed
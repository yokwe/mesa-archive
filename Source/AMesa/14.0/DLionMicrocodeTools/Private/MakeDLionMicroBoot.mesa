-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- MakeDLionMicroBoot.mesa-- Last edit by JWF       6-Aug-87 15:00:16   See log at end DIRECTORY  Ascii USING [CR, TAB],  DandelionBoot USING [Block, LastBlockFlags, SpecialType, uPhysical],  Environment USING [Byte, bytesPerWord, wordsPerPage],  Exec USING [AddCommand, FreeTokenString, GetToken, Handle, Outcome, OutputProc],  Format USING [Char, CR, Decimal, Line, Number, Text, StringProc],  Heap USING [FreeNode, MakeNode, systemZone],  Inline USING [BITAND, BITOR, BITSHIFT, HighByte, HighHalf, LowByte, LowHalf],  MassBurdockInterface USING [    Bits1, Bits2, Bits3, Bits4, FinalBinaryRec, PartialBinary],  MFile USING [ReadOnly, GetCreateDate, Handle],  MSegment USING [Address, Create, Delete, GetFile, GetFilePages, Handle],  MStream USING [EndOf, Error, GetFile, Handle, ReadOnly, ReleaseData, WriteOnly],  Runtime USING [CallDebugger, GetBcdTime],  Stream USING [    Delete, EndOfStream, GetBlock, GetChar, GetPosition, GetWord, Handle,    Position, PutBlock, PutChar, PutString, PutWord, SetPosition],  String USING [    AppendChar, AppendExtensionIfNeeded,    CopyToNewString, Equivalent, StringBoundsFault, Copy, AppendString],  Time USING [Packed, Unpack, Append];MakeDLionMicroBoot: PROGRAM  IMPORTS Exec, Format, Heap, Inline, MFile, MSegment, MStream, Runtime,           Stream, String, Time  =  BEGIN  Error: ERROR [mess: STRING] = CODE;  InMode: TYPE = {fb, uReg, cpr, bin, db};  InStuff: TYPE = RECORD [    name: LONG STRING ¬ NIL,    switch: LONG STRING ¬ NIL,    mode: InMode,    sh: Stream.Handle ¬ NIL,    seg: MSegment.Handle ¬ NIL];  OutMode: TYPE = {bin, db};  OutStuff: TYPE = RECORD [    name: LONG STRING ¬ NIL,    switch: LONG STRING ¬ NIL,    mode: OutMode,    sh: Stream.Handle ¬ NIL,    files: CARDINAL ¬ 0,  -- count of input files    checksum: WORD ¬ 0,    lengthOfFile: WORD ¬ 0,    dbVectorFlag: BOOLEAN ¬ FALSE,    byteAddress: CARDINAL ¬ 0];      TsFileStreamHandle: MStream.Handle ¬ NIL;  Driver: PROC [h: Exec.Handle, clientData: LONG POINTER] RETURNS [    o: Exec.Outcome ¬ normal] =    BEGIN    out: POINTER TO OutStuff = @outStuff;    outStuff: OutStuff;    tty: Format.StringProc ¬ Exec.OutputProc[h];    BEGIN  -- EXIT block    InitializeOutAndVerifyArrow[      h, out, tty ! Error => {Format.Line[proc: tty, s: mess]; GOTO problem};      UNWIND => ReleaseOut[out]];    IF FALSE THEN Runtime.CallDebugger["Early CallDebugger"L];    ProcessInputFiles[      h, tty, out ! Error => {Format.Line[proc: tty, s: mess]; GOTO problem};      UNWIND => ReleaseOut[out]];    FinishOutput[      out, tty ! Error => {Format.Line[proc: tty, s: mess]; GOTO problem};      UNWIND => ReleaseOut[out]];    Format.Decimal[proc: tty, n: out.files];    Format.Line[proc: tty, s: " input files"L];    ReleaseOut[out];    EXITS problem => {ReleaseOut[out]; RETURN[error]};    END;    END;  -- End of Driver              OpenTsFile: PROCEDURE[outFileName: LONG STRING] =     BEGIN     tsFileName: LONG STRING ¬ [100];     toolVersionString: LONG STRING ¬ [100];     errorMsg: STRING ¬ [100];     String.Copy[tsFileName, outFileName];          << If extension = ".db" then change to ".ts" >>     IF tsFileName.length > 2 AND     	 tsFileName[tsFileName.length - 3] = '.  AND        (tsFileName[tsFileName.length - 2] = 'd  OR	 tsFileName[tsFileName.length - 2] = 'D) AND	(tsFileName[tsFileName.length - 1] = 'b  OR	 tsFileName[tsFileName.length - 1] = 'B) THEN	BEGIN	tsFileName[tsFileName.length - 2]  ¬ 't;	tsFileName[tsFileName.length - 1]  ¬ 's;	END     ELSE << If extension is not ".db" then append ".ts" >>        BEGIN	IF tsFileName.length <= tsFileName.maxlength - 3 THEN	   BEGIN	   tsFileName.length ¬ tsFileName.length + 3;	   tsFileName[tsFileName.length - 3]  ¬ '.;	   tsFileName[tsFileName.length - 2]  ¬ 't;	   tsFileName[tsFileName.length - 1]  ¬ 's;	   END;	END;          TsFileStreamHandle ¬ MStream.WriteOnly[tsFileName, [] , text !        MStream.Error => IF code = fileNotAvailable THEN	   BEGIN	   TsFileStreamHandle ¬ NIL;	   String.Copy[errorMsg, "Error -- """L];	   String.AppendString[errorMsg, tsFileName];	   String.AppendString[errorMsg, """ can not be opened."L];	   Error[errorMsg];	   END];          String.AppendString[toolVersionString, "MakeDLionMicroBoot of "L];     Time.Append[toolVersionString, Time.Unpack[Runtime.GetBcdTime[]]];         Stream.PutString[TsFileStreamHandle, "-- "L];     Stream.PutString[TsFileStreamHandle, tsFileName];     Stream.PutChar[TsFileStreamHandle, Ascii.CR];     Stream.PutString[TsFileStreamHandle, "-- "L];     Stream.PutString[TsFileStreamHandle, "Created By "L];     Stream.PutString[TsFileStreamHandle, toolVersionString];     Stream.PutChar[TsFileStreamHandle, Ascii.CR];     Stream.PutChar[TsFileStreamHandle, Ascii.CR];     Stream.PutString[TsFileStreamHandle, "Input Files:"L];     Stream.PutChar[TsFileStreamHandle, Ascii.CR];     Stream.PutChar[TsFileStreamHandle, Ascii.CR];               END;  CloseTsFile: PROC[out: POINTER TO OutStuff] =     BEGIN     s: Stream.Handle;     errorMsg: STRING ¬ [100];          IF TsFileStreamHandle # NIL THEN        BEGIN	IF out.name # NIL THEN	   BEGIN	   s ¬ MStream.ReadOnly[out.name, [] !           MStream.Error => IF code = fileNotAvailable THEN	      BEGIN	      String.Copy[errorMsg, "Error -- """L];	      String.AppendString[errorMsg, out.name];	      String.AppendString[errorMsg, """ can not be opened to read create date."L];	      Error[errorMsg];	      END];	   Stream.PutChar[TsFileStreamHandle, Ascii.CR];           Stream.PutChar[TsFileStreamHandle, Ascii.CR];           Stream.PutString[TsFileStreamHandle, "Output File:"L];           Stream.PutChar[TsFileStreamHandle, Ascii.CR];           Stream.PutChar[TsFileStreamHandle, Ascii.CR];        	   AddEntryToTsFile[out.name, NIL, 	      MFile.GetCreateDate[MStream.GetFile[s]]];	   Stream.Delete[s];	   s ¬ NIL;	   END	ELSE	   BEGIN	   Error["Error -- No Output file found for reading create date."];	   END;	           Stream.Delete[TsFileStreamHandle];        TsFileStreamHandle ¬ NIL;        END;     END;           AddEntryToTsFile: PROCEDURE[fileName, switches: LONG STRING, timeDateStamp: Time.Packed] =     BEGIN     NumberOfTabsToSwitches: INTEGER = 3;     timeStampString: LONG STRING ¬ [50];          timeStampString.length ¬ 0;     Time.Append[timeStampString, Time.Unpack[timeDateStamp]];          Stream.PutChar[TsFileStreamHandle, Ascii.TAB];     Stream.PutString[TsFileStreamHandle, fileName];     FOR i: INTEGER IN[1..NumberOfTabsToSwitches - fileName.length/8 ]        DO	Stream.PutChar[TsFileStreamHandle, Ascii.TAB];	ENDLOOP;     IF switches # NIL THEN        BEGIN	Stream.PutString[TsFileStreamHandle,"/"];        Stream.PutString[TsFileStreamHandle, switches];	Stream.PutChar[TsFileStreamHandle, Ascii.TAB];	Stream.PutChar[TsFileStreamHandle, Ascii.TAB];	END     ELSE        BEGIN	Stream.PutString[TsFileStreamHandle,"no switches"];	Stream.PutChar[TsFileStreamHandle, Ascii.TAB];	END;     Stream.PutString[TsFileStreamHandle, timeStampString];     Stream.PutChar[TsFileStreamHandle, Ascii.CR];     END;     FinishOutput: PROCEDURE [out: POINTER TO OutStuff, tty: Format.StringProc] =    BEGIN    fence: lastBlock special DandelionBoot.Block;    startCP: BOOLEAN ¬ TRUE;    IF out.switch # NIL AND ~String.Equivalent[s1: out.switch, s2: "S"L] THEN {      IF String.Equivalent[s1: out.switch, s2: "~S"L] THEN startCP ¬ FALSE       ELSE Error[" Illegal switch. See documentation. "L]};     fence ¬ [special, special[LOOPHOLE[DandelionBoot.SpecialType[lastBlock]],lastBlock[[inhibitStartCP: ~startCP, unused: 0]]]];    WriteToBoot[out, @fence, SIZE[lastBlock special DandelionBoot.Block]];    SELECT out.mode FROM      db =>        BEGIN        -- out.lengthOfFile has length so far, checksum has checksum so far        -- Assume checksum (next word) will be 0, compute new checksum,        --  and then compute what it should have been.        -- That strange sequence is because NewValueToMakeChecksumZero works        --  if the scratch word is in the middle of the file.        offset: CARDINAL = out.lengthOfFile;        extraWord: WORD ¬ 0;        out.lengthOfFile ¬ out.lengthOfFile + 1;        out.checksum ¬ MoreChecksum[out.checksum, @extraWord, 1];        extraWord ¬ NewValueToMakeChecksumZero[          out.checksum, extraWord, offset, out.lengthOfFile];        WriteToBoot[out, @extraWord, 1];        END;      bin => {        Stream.PutString[out.sh, ":00000001FF"L];        Stream.PutChar[out.sh, '\N];        Stream.PutChar[out.sh, '\L]};      ENDCASE => ERROR;    END;  -- end FinishOutput proc  GetExtension: PROCEDURE [name: LONG STRING, ext: LONG STRING] =    BEGIN    i, j: CARDINAL;    FOR i IN [0..name.length) DO      IF name[i] = '. THEN EXIT      REPEAT FINISHED => ERROR  -- apended       ENDLOOP;    FOR j IN [i..name.length) DO      String.AppendChar[ext, name[j] ! String.StringBoundsFault => GOTO tooBig]      ENDLOOP;    EXITS tooBig => Error[" Illegal extension "L];    END;  -- end GetExtension proc  GetHexByte: PROCEDURE [dh: Stream.Handle] RETURNS [v: CARDINAL ¬ 0] =    BEGIN    c: CHARACTER;    THROUGH [1..2] DO      SELECT c ¬ Stream.GetChar[sH: dh] FROM        IN ['0..'9] => v ¬ v*16 + c - '0;        IN ['A..'F] => v ¬ v*16 + c + 10 - 'A;        ENDCASE => Error[" Illegal hex digit"L]      ENDLOOP;    END;  GetHexWord: PROCEDURE [dh: Stream.Handle] RETURNS [CARDINAL] = {    b: CARDINAL = GetHexByte[dh]; RETURN[b*256 + GetHexByte[dh]]};  GetNextInFile: PROCEDURE [h: Exec.Handle, in: POINTER TO InStuff]    RETURNS [gotIt: BOOLEAN] =    BEGIN    [in.name, in.switch] ¬ GetNextName[h];    IF in.name = NIL THEN RETURN[FALSE];    [] ¬ String.AppendExtensionIfNeeded[LONG[@in.name], "fb"L, Heap.systemZone];    SetInMode[in];    IF in.mode = fb THEN      BEGIN      in.seg ¬ MSegment.Create[        file: MFile.ReadOnly[name: in.name, release: -- No -- [NIL, NIL]],        release: -- No -- [NIL, NIL]];      AddEntryToTsFile[in.name, in.switch, MFile.GetCreateDate[         MSegment.GetFile[in.seg]]];      END    ELSE       BEGIN       in.sh ¬ MStream.ReadOnly[name: in.name, release: -- No -- [NIL, NIL]];       AddEntryToTsFile[in.name, in.switch, MFile.GetCreateDate[          MStream.GetFile[in.sh]]];       END;    RETURN[TRUE];    END;  -- GetNextInFile proc  GetNextName: PROCEDURE [h: Exec.Handle] RETURNS [name, switch: LONG STRING] =    BEGIN    execName, execSwitch: LONG STRING ¬ NIL;    BEGIN    ENABLE      UNWIND => {        [] ¬ Exec.FreeTokenString[execName]; [] ¬ Exec.FreeTokenString[execSwitch]};    [execName, execSwitch] ¬ Exec.GetToken[h];    name ¬ String.CopyToNewString[execName, Heap.systemZone];    switch ¬ String.CopyToNewString[execSwitch, Heap.systemZone];    END;  -- end unwind block    [] ¬ Exec.FreeTokenString[execName];    [] ¬ Exec.FreeTokenString[execSwitch];    END;  -- end GetNextName proc  GetOutFile: PROCEDURE [h: Exec.Handle, out: POINTER TO OutStuff]    RETURNS [gotIt: BOOLEAN] =    BEGIN    [out.name, out.switch] ¬ GetNextName[h];    IF out.name = NIL THEN RETURN[FALSE];    [] ¬ String.AppendExtensionIfNeeded[LONG[@out.name], "db"L, Heap.systemZone];    SetOutMode[out];    out.sh ¬ MStream.WriteOnly[      name: out.name, release: [NIL, NIL], type: binary];    OpenTsFile[out.name];    RETURN[TRUE];    END;  -- GetOutFile proc  GetTokenDiscardSwitches: PROC [h: Exec.Handle] RETURNS [token: LONG STRING] = {    temp: LONG STRING;    [token, temp] ¬ Exec.GetToken[h];    [] ¬ Exec.FreeTokenString[temp]};  Init: PROC = {Exec.AddCommand[name: "MakeDLionMicroBoot.~"L, proc: Driver]};  InitializeOutAndVerifyArrow: PROCEDURE [    h: Exec.Handle, out: POINTER TO OutStuff, tty: Format.StringProc] =    BEGIN    IF ~GetOutFile[      h, out !      MStream.Error =>        IF code = fileNotAvailable THEN GOTO notAvailable ELSE REJECT] THEN      GOTO badCommand;    IF ~String.Equivalent[GetTokenDiscardSwitches[h], "¬"L] THEN      GOTO badCommand;    Format.Text[proc: tty, s: "Writing... "L];    Format.Text[proc: tty, s: out.name];    Format.CR[proc: tty];    EXITS      badCommand => Error[" Error - arguments must be: output ¬ inputList "L];      notAvailable => Error[" Can't aquire output file "L];    END;  -- end of InitOutFileCheckArrow proc  MakeIgnoreBlock: PROCEDURE [page: LONG POINTER] =    BEGIN    block: ignore special DandelionBoot.Block ¬ [      special, special[      LOOPHOLE[DandelionBoot.SpecialType[ignore], CARDINAL], ignore[      Environment.wordsPerPage - SIZE[ignore special DandelionBoot.Block]]]];    ZeroPage[page];    LOOPHOLE[page, LONG POINTER TO ignore special DandelionBoot.Block]­ ¬ block    END;  LeftCycle: PROCEDURE [a: WORD, b: CARDINAL] RETURNS [c: CARDINAL] =    BEGIN    n: CARDINAL ¬ b MOD 16;    c ¬ a;    IF b >= 100000B THEN n ¬ n + 16;    UNTIL n = 0 DO c ¬ IF c < 100000B THEN c*2 ELSE c*2 + 1; n ¬ n - 1; ENDLOOP;    END;  -- Subroutines for Checksum  -- The rule is that the checksum of the whole file is 0.  MoreChecksum: PROCEDURE [cs: WORD, q: LONG POINTER, size: CARDINAL]    RETURNS [WORD] =    BEGIN    p: LONG POINTER TO ARRAY [0..0) OF WORD = q;    FOR i: CARDINAL IN [0..size) DO      t: CARDINAL = cs + p[i];      cs ¬ (IF cs > t THEN t + 1 ELSE t);      cs ¬ (IF cs >= 100000B THEN cs*2 + 1 ELSE cs*2);      ENDLOOP;    IF cs = 177777B THEN cs ¬ 0;    RETURN[cs];    END;  NewValueToMakeChecksumZero: PROCEDURE [    oldChecksum: WORD, oldValue: WORD, offsetOfOldValue: CARDINAL,  -- words    length: CARDINAL] RETURNS [newValue: WORD] =    BEGIN    newValue ¬ OnesAdd[      LeftCycle[OnesSub[0, oldChecksum], offsetOfOldValue - length], oldValue];    END;  OnesAdd: PROCEDURE [a, b: CARDINAL] RETURNS [c: CARDINAL] = {    c ¬ a + b; IF c < a THEN c ¬ c + 1; IF c = 177777B THEN c ¬ 0};  OnesSub: PROCEDURE [a, b: CARDINAL] RETURNS [c: CARDINAL] =    BEGIN    c ¬ a + (-b - 1);    IF c < a THEN c ¬ c + 1;    IF c = 177777B THEN c ¬ 0;    END;  ProcessBin: PROCEDURE [    in: POINTER TO InStuff, out: POINTER TO OutStuff, tty: Format.StringProc]    RETURNS [count: CARDINAL ¬ 0] =    BEGIN    dh: Stream.Handle;    addr, cs, ct, lineType: CARDINAL;    c: CHARACTER;    EOF: CARDINAL = 1;    size: CARDINAL = SIZE[loadIOP special DandelionBoot.Block];    bytes: PACKED ARRAY [0..Environment.bytesPerWord*size + 20) OF [0..377B] ¬      ALL[0];    IOPstartAddr: CARDINAL ¬ 20000B;    start: startIOP special DandelionBoot.Block;    IF in.switch # NIL THEN -- Switch is a hex IOP start addr      BEGIN      IOPstartAddr ¬ 0;      FOR i: CARDINAL IN [0..in.switch.length) DO        IOPstartAddr ¬ 16*IOPstartAddr + (SELECT in.switch.text[i] FROM          '0 => 0, '1 => 1, '2 => 2, '3 => 3, '4 => 4, '5 => 5, '6 => 6, '7 => 7,          '8 => 8, '9 => 9, 'A => 10, 'B => 11, 'C => 12, 'D => 13, 'E => 14, 	  'F => 15, 'a => 10, 'b => 11, 'c => 12, 'd => 13, 'e => 14, 'f => 15,          ENDCASE => Error[" Illegal start address as a switch on .bin file. "L])        ENDLOOP;      END;    start ¬ [      special, special[        LOOPHOLE[DandelionBoot.SpecialType[startIOP], CARDINAL], 	startIOP[IOPstartAddr]]];    dh ¬ in.sh;    DO      IF (c ¬ Stream.GetChar[sH: dh]) = 'R THEN EXIT;      WHILE c # ': DO c ¬ Stream.GetChar[sH: dh] ENDLOOP;      ct ¬ cs ¬ GetHexByte[dh];      addr ¬ GetHexWord[dh];      cs ¬ cs + Inline.HighByte[addr] + Inline.LowByte[addr];      IF (lineType ¬ GetHexByte[dh]) = EOF THEN EXIT;      FOR i: CARDINAL IN         [Environment.bytesPerWord*size..Environment.bytesPerWord*size + ct) DO        bytes[i] ¬ GetHexByte[dh]; cs ¬ cs + bytes[i] ENDLOOP;      IF Inline.LowByte[cs + GetHexByte[dh]] # 0 THEN Error[" Checksum error"L];      LOOPHOLE[@bytes, POINTER TO loadIOP special DandelionBoot.Block]­ ¬ [        special, special[        LOOPHOLE[DandelionBoot.SpecialType[loadIOP], CARDINAL], loadIOP[        IOPaddress: addr, IOPbyteCount: ct]]];      IF ct # 0 THEN        BEGIN        p: ORDERED POINTER ¬ LOOPHOLE[@bytes + size];        FOR p IN          [p..p + (ct + Environment.bytesPerWord - 1)/Environment.bytesPerWord) DO          SwapBytes[p] ENDLOOP;        WriteToBoot[          out, @bytes,          size + (ct + Environment.bytesPerWord - 1)/Environment.bytesPerWord]        END;      count ¬ count + ct;      [] ¬ Stream.GetChar[sH: dh];      [] ¬ Stream.GetChar[sH: dh];      ENDLOOP;    WHILE c # '\L DO c ¬ Stream.GetChar[sH: dh] ENDLOOP;    IF NOT MStream.EndOf[stream: dh] THEN      Error[" Extra garbage at end of bin file"L];    WriteToBoot[out, @start, SIZE[startIOP special DandelionBoot.Block]]    END;  --Special purpose code to read DiskIOCBs from a CPR format file.  There  --ought to be only 1 block, less than 256 words that starts at 100 hex;  --anything else results in an error.  It should also be the first block in  --the file; but, no error results if this condition is not fulfilled.  ProcessCPR: PROCEDURE [in: POINTER TO InStuff, out: POINTER TO OutStuff]    RETURNS [CARDINAL] =    BEGIN    Illegal: PROCEDURE = INLINE BEGIN Error[" Illegal CPR block"L] END;    count: CARDINAL = Stream.GetWord[in.sh];    addrHigh: CARDINAL = Stream.GetWord[in.sh];    addrLow: CARDINAL = Stream.GetWord[in.sh];    size: CARDINAL = SIZE[ignore special DandelionBoot.Block];    cprPage: LONG POINTER = Heap.MakeNode[n: Environment.wordsPerPage];    BEGIN    ENABLE UNWIND => Heap.FreeNode[p: cprPage];    MakeIgnoreBlock[cprPage];    IF count < size OR count > Environment.wordsPerPage OR addrHigh # 0      OR addrLow # 256 THEN Illegal[];    IF Stream.GetWord[in.sh] # LOOPHOLE[cprPage, LONG POINTER TO WORD]­ THEN      Illegal[];    IF Stream.GetWord[in.sh] # LOOPHOLE[cprPage + 1, LONG POINTER TO WORD]­ THEN      Illegal[];    IF Stream.GetBlock[      sH: in.sh,      block: [      blockPointer: cprPage + size, startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*(count - 2)]].bytesTransferred #      Environment.bytesPerWord*(count - 2) THEN Illegal[];    WriteToBoot[out, cprPage, Environment.wordsPerPage];    END;  -- end of UNWIND     Heap.FreeNode[p: cprPage];    IF Stream.GetWord[in.sh] # 0 THEN Illegal[];    RETURN[count]    END;  ProcessDB: PROCEDURE [    in: POINTER TO InStuff, out: POINTER TO OutStuff, dbVectorPage: LONG POINTER,    tty: Format.StringProc] RETURNS [count: CARDINAL ¬ 0] =    BEGIN    VectorDomain: TYPE =      [0..Environment.wordsPerPage - SIZE[ignore special DandelionBoot.Block]);    DBVectorPage: TYPE = LONG POINTER TO MACHINE DEPENDENT RECORD [      header: ignore special DandelionBoot.Block,      index: ARRAY VectorDomain OF WORD];    currentPosition: Stream.Position;    IF out.files = 0 THEN {      out.dbVectorFlag ¬ TRUE;      MakeIgnoreBlock[dbVectorPage];      -- Don't call WriteToBoot because it will mixup checksum later      Stream.PutBlock[        sH: out.sh,        block: [          blockPointer: dbVectorPage, startIndex: 0,	  stopIndexPlusOne: Environment.wordsPerPage*Environment.bytesPerWord], 	endRecord: FALSE]}    ELSE IF ~out.dbVectorFlag THEN Error[" Incompatible input files. "L];    IF out.files ~IN VectorDomain THEN Error[" Too many db files. "L];    currentPosition ¬ Stream.GetPosition[out.sh];    IF Inline.HighHalf[currentPosition/Environment.bytesPerWord] # 0 THEN      Error[" Vectored db file exceeds 64K "L];    LOOPHOLE[dbVectorPage, DBVectorPage].index[out.files] ¬ Inline.LowHalf[      currentPosition/Environment.bytesPerWord];    DO      temp: WORD;      temp ¬ Stream.GetWord[in.sh ! Stream.EndOfStream => EXIT; ];      Stream.PutWord[out.sh, temp];      count ¬ count + 1;      ENDLOOP;    END;  ProcessFB: PROCEDURE [    in: POINTER TO InStuff, out: POINTER TO OutStuff, tty: Format.StringProc]    RETURNS [count: CARDINAL] =    BEGIN    min, max: CARDINAL;    P: TYPE = LONG ORDERED POINTER TO MassBurdockInterface.FinalBinaryRec;    this: P;    miSize: CARDINAL = 4096;    l: CARDINAL = SIZE[MassBurdockInterface.FinalBinaryRec];    tpc: ARRAY [0..7] OF INTEGER ¬ ALL[-1];    block: u15 DandelionBoot.Block;    buffered: CARDINAL ¬ 0;    last: CARDINAL;    tpcBlock: TPC0 special DandelionBoot.Block;    BufferReset: PROCEDURE = INLINE {block.uA ¬ this.addr; BufferAppend};    BufferAppend: PROCEDURE = INLINE      BEGIN      block.uI[buffered] ¬ VirtualToReal[@this.partialBinary];      last ¬ this.addr;      buffered ¬ buffered + 1;      min ¬ MIN[min, last];      max ¬ MAX[max, last]      END;    BufferWrite: PROCEDURE =      BEGIN      block.type ¬ LOOPHOLE[buffered];      WriteToBoot[        out, @block,        SIZE[u1 DandelionBoot.Block] +          (buffered - 1)*SIZE[DandelionBoot.uPhysical]];      buffered ¬ 0      END;    -- ProcessFB starts here    count ¬ max ¬ 0;    min ¬ miSize;    IF MSegment.GetFilePages[in.seg] = 0 THEN RETURN;    this ¬ LOOPHOLE[MSegment.Address[in.seg]];    WHILE this.addr < miSize DO      IF this.miNum = 177777B THEN tpc[this.partialBinary.task] ¬ this.addr      ELSE        IF buffered = 0 THEN BufferReset[]        ELSE          IF this.addr = last + 1 AND buffered < 15 THEN BufferAppend[]          ELSE {BufferWrite[]; BufferReset[]};      count ¬ count + 1;      this ¬ this + l      ENDLOOP;    IF buffered # 0 THEN BufferWrite;    FOR i: CARDINAL IN [0..7] DO      IF tpc[i] = -1 THEN LOOP;      tpcBlock ¬ [special, special[i, TPC0[tpc[i]]]];      WriteToBoot[out, @tpcBlock, SIZE[TPC0 special DandelionBoot.Block]]      ENDLOOP;    IF count = 0 THEN RETURN;    Format.Text[tty, "  ("L];    Format.Number[      proc: tty, n: min,      format: [base: 16, zerofill: FALSE, unsigned: TRUE, columns: 0]];    Format.Char[proc: tty, char: '-];    Format.Number[      proc: tty, n: max,      format: [base: 16, zerofill: FALSE, unsigned: TRUE, columns: 0]];    Format.Text[proc: tty, s: ") "L]    END;  ProcessInputFiles: PROCEDURE [    h: Exec.Handle, tty: Format.StringProc, out: POINTER TO OutStuff] =    BEGIN    dbVectorPage: LONG POINTER = Heap.MakeNode[n: Environment.wordsPerPage];    BEGIN    ENABLE UNWIND => Heap.FreeNode[p: dbVectorPage];    DO      fileSize: CARDINAL;      in: POINTER TO InStuff = @inStuff;      inStuff: InStuff;      IF ~GetNextInFile[        h, in !        MStream.Error =>          IF code = fileNotAvailable THEN {            Heap.FreeNode[p: dbVectorPage]; ReleaseIn[in]; GOTO notAvailable}          ELSE REJECT; UNWIND => ReleaseIn[in]] THEN EXIT;      BEGIN      ENABLE UNWIND => ReleaseIn[in];      Format.Text[proc: tty, s: "Reading... "L];      Format.Text[proc: tty, s: in.name];      fileSize ¬        SELECT in.mode FROM          fb => ProcessFB[in, out, tty],          uReg => ProcessUReg[in, out],          cpr => ProcessCPR[in, out],          bin => ProcessBin[in, out, tty],          db => out.lengthOfFile ¬ out.lengthOfFile + ProcessDB[in, out, dbVectorPage, tty],          ENDCASE => ERROR;      END;  -- end of ReleaseIn[in] UNWIND block      ReleaseIn[in];      Format.Text[tty, "  ("L];      Format.Decimal[tty, fileSize];      Format.Line[tty, ")"L];      out.files ¬ out.files + 1;      ENDLOOP;    IF out.dbVectorFlag THEN {      currentPosition: Stream.Position;      -- The checksum calc requires wordsPerPage be a multiple of bitsPerWord      UNTIL out.lengthOfFile MOD 16 = 0 DO        zero: WORD ¬ 0; WriteToBoot[out, @zero, 1]; ENDLOOP;      currentPosition ¬ Stream.GetPosition[out.sh];      Format.Line[proc: tty, s: "Writing db Vector table"L];      Stream.SetPosition[out.sh, 0];      WriteToBoot[out, dbVectorPage, Environment.wordsPerPage];      Stream.SetPosition[out.sh, currentPosition]};    END;  -- end of UNWIND block for Heap.FreeNode[p: dbVectorPage]     Heap.FreeNode[p: dbVectorPage];    EXITS notAvailable => Error[" Can't aquire input file "L];    END;  -- End of ProcessInputFiles procedure  ProcessUReg: PROCEDURE [in: POINTER TO InStuff, out: POINTER TO OutStuff]    RETURNS [count: CARDINAL ¬ 0] =    BEGIN    block: loadU special DandelionBoot.Block;    block.type ¬ special;    block.uUnused ¬ 0;    block.specialType ¬ LOOPHOLE[DandelionBoot.SpecialType[loadU], CARDINAL];    DO      n: CARDINAL;      n ¬ URegParseLineGetNumber[in ! Stream.EndOfStream => EXIT];      block.uBlock ¬ Inline.BITAND[n, 17B];      block.uDevice ¬ Inline.BITAND[Inline.BITSHIFT[n, -4], 17B];      FOR i: CARDINAL IN [0..17B] DO        block.uData[i] ¬ URegParseLineGetNumber[          in ! Stream.EndOfStream => IF i = 17B THEN EXIT ELSE GOTO syntax]        ENDLOOP;      count ¬ count + 16;      WriteToBoot[out, @block, SIZE[loadU special DandelionBoot.Block]]      ENDLOOP;    EXITS syntax => Error[" illegal syntax within uReg file "L];    END;  ReleaseIn: PROCEDURE [in: POINTER TO InStuff] =    BEGIN    Heap.systemZone.FREE[@in.name];         -- also sets in.name ¬ NIL    IF in.sh # NIL THEN {Stream.Delete[in.sh]; in.sh ¬ NIL};    IF in.seg # NIL THEN {MSegment.Delete[in.seg]; in.seg ¬ NIL};    END;  -- end ReleaseIn proc  ReleaseOut: PROCEDURE [out: POINTER TO OutStuff] =    BEGIN    IF out.sh # NIL THEN {Stream.Delete[out.sh]; out.sh ¬ NIL};    CloseTsFile[out];    Heap.systemZone.FREE[@out.name];         -- also sets out.name ¬ NIL    END;  -- end ReleaseOut proc  SetInMode: PROCEDURE [in: POINTER TO InStuff] =    BEGIN    mode: InMode;    extNames: ARRAY InMode OF STRING = [".fb", ".uReg", ".cpr", ".bin", ".db"];    ext: LONG STRING ¬ [5];    GetExtension[in.name, ext];    FOR mode IN InMode DO      IF String.Equivalent[ext, extNames[mode]] THEN EXIT      REPEAT FINISHED => Error[" Illegal input file extension "L]      ENDLOOP;    in.mode ¬ mode;    END;  -- end SetInMode proc  SetOutMode: PROCEDURE [out: POINTER TO OutStuff] =    BEGIN    mode: OutMode;    extNames: ARRAY OutMode OF STRING = [".bin", ".db"];    ext: LONG STRING ¬ [5];    GetExtension[out.name, ext];    FOR mode IN OutMode DO      IF String.Equivalent[ext, extNames[mode]] THEN EXIT      REPEAT FINISHED => Error[" Illegal output file extension "L]      ENDLOOP;    out.mode ¬ mode;    END;  -- end SetOutMode proc  SwapBytes: PROCEDURE [p: LONG POINTER] = INLINE {    temp: WORD = Inline.BITSHIFT[p­, 8];    p­ ¬ Inline.BITOR[temp, Inline.HighByte[p­]];    };  URegParseLineGetNumber: PROCEDURE [in: POINTER TO InStuff]    RETURNS [n: CARDINAL ¬ 0] =    BEGIN    c: CHARACTER;    DO  -- skip blank lines and leading spaces or tabs      c ¬ Stream.GetChar[in.sh];      IF c # '  AND c # '\N AND c # '\T THEN EXIT      ENDLOOP;    Stream.SetPosition[in.sh, Stream.GetPosition[in.sh] - 1];    n ¬ GetHexWord[in.sh];  -- The next 4 chars must be THE 4 Hex digits.    -- Next character must be a CR SP TAB or EndOfStream    -- EndOfStream is handled in ProcessUReg(the caller).    c ¬ Stream.GetChar[in.sh];    IF c # '\N THEN      IF c = '  OR c = '\T THEN        UNTIL Stream.GetChar[in.sh] = '\N DO ENDLOOP      ELSE Error[" illegal syntax within uReg file "L];    END;  VirtualToReal: PROCEDURE [    virtual: LONG POINTER TO MassBurdockInterface.PartialBinary]    RETURNS [real: DandelionBoot.uPhysical] =    BEGIN    mir: POINTER TO MACHINE DEPENDENT RECORD [      rA, rB: MassBurdockInterface.Bits4,      aS, aF: MassBurdockInterface.Bits3,      aD: MassBurdockInterface.Bits2,  --word 0      ep, Cin, enSU, mem: MassBurdockInterface.Bits1,      fS1: MassBurdockInterface.Bits2,      fS2, fS3: MassBurdockInterface.Bits1,  --word 1      fY, INIA0to3: MassBurdockInterface.Bits4,      fX, INIA4to7, fZ, INIA8to11: MassBurdockInterface.Bits4]  --word 2       = LOOPHOLE[@real];    BEGIN OPEN virtual;    mir­ ¬ [      rA, rB, aS, aF, aD, parity, cin, enSU, mem, fS01, fS2, fS3, fY,      Inline.BITAND[17B, Inline.BITSHIFT[addr, -8]], fX, Inline.BITAND[      17B, Inline.BITSHIFT[addr, -4]], fZ, Inline.BITAND[17B, addr]]    END;    SwapBytes[mir];    SwapBytes[mir + 1];    SwapBytes[mir + 2]    END;  WriteToBoot: PROCEDURE [    out: POINTER TO OutStuff, p: LONG POINTER, c: CARDINAL] =    BEGIN    SELECT out.mode FROM      db =>        BEGIN        out.checksum ¬ MoreChecksum[out.checksum, p, c];        out.lengthOfFile ¬ out.lengthOfFile + c;        Stream.PutBlock[          sH: out.sh,          block: [          blockPointer: p, startIndex: 0,          stopIndexPlusOne: Environment.bytesPerWord*c], endRecord: FALSE];        END;      bin =>        BEGIN        Hex: ARRAY [0..17B] OF CHARACTER = [          '0, '1, '2, '3, '4, '5, '6, '7, '8, '9, 'A, 'B, 'C, 'D, 'E, 'F];        cks, base: CARDINAL ¬ 0;        left: CARDINAL ¬ Environment.bytesPerWord*c;  --convert to bytes        BinPutByte: PROCEDURE [w: WORD] =          BEGIN          b: POINTER TO MACHINE DEPENDENT RECORD [            unused: [0..400B), hi, low: [0..20B)] = LOOPHOLE[@w];          Stream.PutChar[sH: out.sh, char: Hex[b.hi]];          Stream.PutChar[sH: out.sh, char: Hex[b.low]];          cks ¬ cks + w          END;        BinPutWord: PROCEDURE [w: WORD] = {          BinPutByte[w/256]; BinPutByte[w MOD 256]};        BinPutWordSwapped: PROCEDURE [w: WORD] = {          BinPutByte[w MOD 256]; BinPutByte[w/256]};        WHILE left > 0 DO          size: CARDINAL = MIN[16, left];          Stream.PutChar[sH: out.sh, char: ':];          BinPutByte[size];  --data bytes          BinPutWord[out.byteAddress + base];          BinPutByte[0];  --flag           FOR i: CARDINAL IN            [base/Environment.bytesPerWord..((size +                                                base)/Environment.bytesPerWord))            DO BinPutWordSwapped[(p + i)­] ENDLOOP;          BinPutByte[0 - cks];  -- "0 -" because of bounds faults          Stream.PutChar[out.sh, '\N];          Stream.PutChar[out.sh, '\L];          left ¬ left - size;          base ¬ base + size;          cks ¬ 0          ENDLOOP;        END;      ENDCASE => ERROR;    out.byteAddress ¬ out.byteAddress + Environment.bytesPerWord*c    END;  ZeroPage: PROC [p: LONG POINTER] = INLINE {    LOOPHOLE[p, LONG POINTER TO ARRAY [0..Environment.wordsPerPage) OF CARDINAL]­      ¬ ALL[0]};  --main line code  Init[];  END...    -- LOG  -- ETN        23-Feb-82 17:38:33 - convert to Trinity  -- ETN        25-Feb-82 15:41:45 - Get Hal's Feb 8 checksum fixes  -- ETN         9-Sep-82 17:12:38 - Implemented /s and /~s   -- ETN        10-Sep-82 13:45:59 - Fixed initial PutBlock of dbVectorPage   -- ETN        13-Sep-82 15:56:57 - db => out.lengthOfFile¬ ... ProcessDB[...   -- ETN        21-Oct-82 17:02:35 - Implement IOPstartAddr   -- ETN        21-Jan-83 19:52:56 - Sierra. Heap, String => Storage  --                                 Add clientData to Driver   --                                 Add type to MStream.WriteOnly   -- HGM        22-Jan-83 16:28:16 - BugFix String.CopyToNewString => CopyString   -- ETN        24-Jan-83 12:06:22 - Better form of turned-off CallDebugger  -- DEG     	30-May-83 19:51:04 - Remove references to the Ascii interface  -- JWF	 6-Aug-87 15:00:16 - Added ".ts" file generation    
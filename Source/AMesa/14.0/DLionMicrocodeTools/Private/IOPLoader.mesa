-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- IOPLoader.mesa, HGM, 14-Feb-83 12:52:39DIRECTORY  Environment USING [Block, Byte],  Format USING [CR, Line, LongDecimal, StringProc, Text],  Heap USING [systemZone],  MStream USING [Error, GetLength, ReadOnly],  Stream USING [Delete, GetChar, GetPosition, Handle],  String USING [AppendExtensionIfNeeded, CopyToNewString],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],    IOP USING [Address],  IOPCommand USING [Error, RefreshWindow],  IOPKernel USING [Error, WriteMemoryBlock];IOPLoader: PROGRAM  IMPORTS    Format, Heap, MStream, Stream, String, System, IOPKernel,    IOPCommand  EXPORTS IOPCommand =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;  Load: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "bin"L, z];    Format.Text[log, "Loading IOP from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR IOPCommand.Error["Can't read that file"] ];    LoadFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END; ];    Stream.Delete[stream];    z.FREE[@filename];    IOPCommand.RefreshWindow[];    END;  LoadFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN    start, stop: System.Pulses;    ms: LONG CARDINAL;    bytes: LONG CARDINAL ¬ 0;    blocks: CARDINAL ¬ 0;    EOF: CARDINAL = 1;    start ¬ System.GetClockPulses[];    DO      bufferSize: CARDINAL = 50;      mem: IOP.Address;      cs, ct, linetype: CARDINAL;      buffer: PACKED ARRAY [0..bufferSize) OF Environment.Byte;      block: Environment.Block ¬ [LOOPHOLE[LONG[@buffer]], 0, ];      c: CHARACTER ¬ Stream.GetChar[stream];      IF c = 'R THEN EXIT;      WHILE c # ': DO c ¬ Stream.GetChar[stream]; ENDLOOP;      cs ¬ ct ¬ GetHexByte[stream];      mem ¬ GetHexWord[stream];      cs ¬ cs + mem/256 + mem MOD 256;      linetype ¬ GetHexByte[stream];      -- checksum does not change as type = 0 for non-eof records      IF linetype = EOF THEN EXIT;      IF ct >= bufferSize THEN ERROR IOPCommand.Error["Block too large"];      FOR i: CARDINAL IN [0..ct) DO        buffer[i] ¬ GetHexByte[stream]; cs ¬ cs + buffer[i]; ENDLOOP;      cs ¬ cs + GetHexByte[stream];      IF cs MOD 256 # 0 THEN ERROR IOPCommand.Error["Checksum mismatch"L];      block.stopIndexPlusOne ¬ ct;      IF ct # 0 THEN        BEGIN	IOPKernel.WriteMemoryBlock[mem, block !          IOPKernel.Error => ERROR IOPCommand.Error[reason] ];        bytes ¬ bytes + ct;        blocks ¬ blocks + 1;	END;      [] ¬ Stream.GetChar[stream];      [] ¬ Stream.GetChar[stream];  --  ******  LF(?)      ENDLOOP;    [] ¬ Stream.GetChar[stream];    [] ¬ Stream.GetChar[stream];  --  ******  LF(?)    IF MStream.GetLength[stream] # Stream.GetPosition[stream] THEN ERROR IOPCommand.Error["Leftover data in the file"L];    stop ¬ System.GetClockPulses[];        ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, bytes];    END;    Info: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, bytes: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, bytes, arg];    Format.Text[log, " bytes of data into the IOP."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, bytes*8*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;  GetHexByte: PROCEDURE [str: Stream.Handle] RETURNS [v: CARDINAL ¬ 0] =    BEGIN    THROUGH [0..1] DO      c: CHARACTER ¬ Stream.GetChar[str];      SELECT c FROM        IN ['0..'9] => v ¬ v*16 + c - '0;        IN ['A..'F] => v ¬ v*16 + c + 10 - 'A;        ENDCASE => ERROR IOPCommand.Error["Invalid HEX Digit"L];      ENDLOOP;    END;  GetHexWord: PROCEDURE [str: Stream.Handle] RETURNS [w: CARDINAL] =    BEGIN w ¬ GetHexByte[str]*256; w ¬ w + GetHexByte[str]; END;  END.
-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: TmFileImpl.mesa-- Last edit: DEG      26-Sep-84 20:45:28-- Last edit: JAC    27-Jan-84 13:36:59 -- Edit by ETN    21-Jan-83 15:50:54DIRECTORY  Ascii USING [CR],  Environment USING [Block, Byte, bytesPerWord],  Exec USING [Outcome],  Inline USING [HighHalf, LowHalf],    MFile USING [    Acquire, Delete, Error, GetAccess, GetCreateDate, GetLength, GetTimes, Handle, Release],  MSegment USING [Address, Create, Delete, Handle],  MStream USING [    Error, GetFile, Handle, ReadOnly, ReadWrite, SetLength, WriteOnly],  Stream USING [    Block, Delete, GetBlock, GetPosition, GetWord, Handle, PutBlock, PutChar,     PutString, PutWord, SetPosition],  String USING [AppendString, Copy, EqualStrings],  System USING [GetGreenwichMeanTime, SecondsSinceEpoch],  Time USING [Append, Packed, Unpack],  TmAssembler USING [version],  TmControl USING [BeginTime,    errorsInThisFile, ifsInThisFile, errorsExist, FatalError, TtyLine, TtyText2],  TmFile USING [fileNameMaxlenght, maxNumFiles],    TmModule USING [LogSourceLine, ScanInit];TmFileImpl: PROGRAM  IMPORTS     Inline, MFile, MSegment, MStream, Stream, String, System, Time, TmAssembler, TmControl, TmModule  EXPORTS TmFile, TmModule =  BEGIN  -- Public Variables  aFlagSet: PUBLIC BOOLEAN;  currentFile: PUBLIC LONG STRING ¬ [64];  defsFilesCnt: PUBLIC CARDINAL [0..TmFile.maxNumFiles);  defsFileNames: PUBLIC ARRAY [0..TmFile.maxNumFiles) OF LONG STRING;  ebStream: PUBLIC Stream.Handle;  erStream: PUBLIC Stream.Handle;  fbFileSize: PUBLIC LONG CARDINAL;  fbInStream: PUBLIC Stream.Handle;  fbOutStream: PUBLIC Stream.Handle;  fbSeg: PUBLIC MSegment.Handle;  fImc: PUBLIC CARDINAL [0..TmFile.maxNumFiles);  ftStream: PUBLIC Stream.Handle;  importsOnly: PUBLIC PACKED ARRAY [0..TmFile.maxNumFiles) OF BOOLEAN;  mlStream: PUBLIC Stream.Handle;  outFile: PUBLIC LONG STRING ¬ [64];  passTwoOnly: PUBLIC PACKED ARRAY [0..TmFile.maxNumFiles) OF BOOLEAN;  PassFileHandle: PUBLIC MFile.Handle;  -- fixed portion of  siPrologLength is  version, time, defsCount  siPrologLength: PUBLIC CARDINAL;  siStream: PUBLIC Stream.Handle;  sourceFilesCnt: PUBLIC CARDINAL [0..TmFile.maxNumFiles);  sourceFileNames: PUBLIC ARRAY [0..TmFile.maxNumFiles) OF LONG STRING;  stStream: PUBLIC Stream.Handle;  StmtFileHandle: PUBLIC MFile.Handle;  -- Private Variables  createDate: LONG STRING ¬ [20];  createTime: Time.Packed;  curSI: CARDINAL [0..TmFile.maxNumFiles);  defsTimes: ARRAY [0..TmFile.maxNumFiles) OF LONG CARDINAL;  errorsInFile: PACKED ARRAY [0..TmFile.maxNumFiles) OF BOOLEAN;  fIdf: CARDINAL [0..TmFile.maxNumFiles);  fIeb: CARDINAL [0..TmFile.maxNumFiles);  fIfb: CARDINAL [0..TmFile.maxNumFiles);    fIml: CARDINAL [0..TmFile.maxNumFiles);  fIsi: CARDINAL [0..TmFile.maxNumFiles);  ifsInFile: PACKED ARRAY [0..TmFile.maxNumFiles) OF BOOLEAN;  sourceFile: MFile.Handle;  sourceSegment: MSegment.Handle;  -- Public Procedures  InitBackupFile: PUBLIC PROCEDURE =     BEGIN        NoRoom: PROCEDURE =      BEGIN      errorMessage: LONG STRING = "No room on volume.  Please clean up before retrying.";      TmControl.TtyLine[errorMessage];      LogLine[errorMessage];            TmControl.FatalError      END;              StmtFileHandle ¬ MFile.Acquire[name: ReplaceExt[outFile, "sf"], access: readWrite, release: [NIL,NIL] ! MFile.Error =>        IF code = noRoomOnVolume THEN NoRoom];    PassFileHandle ¬ MFile.Acquire[name: ReplaceExt[outFile, "pf"], access: readWrite, release: [NIL,NIL] ! MFile.Error =>        IF code = noRoomOnVolume THEN { MFile.Release[StmtFileHandle]; 	  MFile.Delete[MFile.Acquire[name: ReplaceExt[outFile, "sf"], access: delete, release: [NIL,NIL]]];	  NoRoom}]    END; --InitBackupFile        InitGlobalFile: PUBLIC PROCEDURE =    BEGIN    -- Public Variables    aFlagSet ¬ FALSE;    ebStream ¬ NIL;    erStream ¬ NIL;    fbFileSize ¬ 0;    fbInStream ¬ NIL;    fbOutStream ¬ NIL;    fbSeg ¬ NIL;        ftStream ¬ NIL;    mlStream ¬ NIL;    StmtFileHandle ¬ NIL;    PassFileHandle ¬ NIL;    outFile.length ¬ 0;    -- fixed portion of  siPrologLength is version, time, defsCount    siPrologLength ¬      Environment.bytesPerWord*(SIZE[CARDINAL] + SIZE[LONG CARDINAL] + SIZE[                                  CARDINAL]) + TmAssembler.version.length;    siStream ¬ NIL;    stStream ¬ NIL;    -- Private Variables    fIdf ¬ 0;    fIeb ¬ 0;    fIfb ¬ 0;    fImc ¬ 0;    fIml ¬ 0;    fIsi ¬ 0;    sourceFile ¬ NIL;    currentFile.length ¬ 0;    sourceSegment ¬ NIL;    FOR index: CARDINAL IN [0..TmFile.maxNumFiles) DO       importsOnly[index] ¬ passTwoOnly[index] ¬ FALSE    ENDLOOP;    END;  -- InitGlobalFile  Finish: PUBLIC PROCEDURE[outcome: Exec.Outcome] =    BEGIN    IF ebStream # NIL THEN ebStream ¬ CloseStream[ebStream];    IF erStream # NIL THEN erStream ¬ CloseStream[erStream];    IF fbInStream # NIL THEN fbInStream ¬ CloseStream[fbInStream];    IF fbOutStream # NIL THEN fbOutStream ¬ CloseStream[fbOutStream];    IF fbSeg # NIL THEN fbSeg ¬ DeleteSegment[fbSeg];    IF ftStream # NIL THEN ftStream ¬ CloseStream[ftStream];    IF sourceSegment # NIL THEN {      MSegment.Delete[sourceSegment]; sourceSegment ¬ NIL; sourceFile ¬ NIL};    IF sourceFile # NIL THEN {MFile.Release[sourceFile]; sourceFile ¬ NIL};    IF mlStream # NIL THEN mlStream ¬ CloseStream[mlStream];    IF siStream # NIL THEN {      siStream ¬ CloseStream[siStream];      IF (outcome # normal) AND (currentFile.length # 0) THEN         MFile.Delete[MFile.Acquire[ReplaceExt[currentFile, "si"], delete, [NIL,NIL]]]};    IF stStream # NIL THEN stStream ¬ CloseStream[stStream];    END;  -- Finish  CloseStream: PUBLIC PROCEDURE [sh: Stream.Handle]    RETURNS [nilSh: Stream.Handle ¬ NIL] = {    IF sh = NIL THEN ERROR;     SELECT MFile.GetAccess[MStream.GetFile[sh]] FROM        readWrite, writeOnly => MStream.SetLength[sh, Stream.GetPosition[sh]];    ENDCASE;    Stream.Delete[sh];    sh ¬ NIL};  CreateLogFile: PUBLIC PROCEDURE =    BEGIN    erStream ¬ MStream.WriteOnly[ReplaceExt[outFile, "er"], [NIL, NIL], text];    END;  -- CreateLogFile    DeleteSegment: PUBLIC PROCEDURE [sh: MSegment.Handle] RETURNS [nilsh: MSegment.Handle ¬ NIL] =    BEGIN    MSegment.Delete[sh];    sh ¬ NIL;        END;   --DeleteSegment      DeleteSIs: PUBLIC PROCEDURE =    BEGIN    FOR curSI IN [0..sourceFilesCnt) DO      IF errorsInFile[curSI] OR (TmControl.errorsExist AND ifsInFile[curSI]) THEN        MFile.Delete[MFile.Acquire[          ReplaceExt[sourceFileNames[curSI], "si"], delete, [NIL, NIL]]]    ENDLOOP;    END;  LogErrArgAndSrcLines: PUBLIC PROCEDURE [str1, str2: LONG STRING] =    BEGIN LogErrLine2[str1, str2]; TmModule.LogSourceLine[]; END;  LogErrAndSrcLines: PUBLIC PROCEDURE [str: LONG STRING] = {    LogErrLine[str]; TmModule.LogSourceLine[]};  LogErrAndSrcLinesBadChar: PUBLIC PROCEDURE [char: CHARACTER] =    BEGIN    Stream.PutString[erStream, "The character: "L];    Stream.PutChar[erStream, char];    LogErrAndSrcLines[" is illegal in arguments."L];    END;  LogErrLine: PUBLIC PROCEDURE [str: LONG STRING] = {    LogErrText[str]; Stream.PutChar[erStream, Ascii.CR]};  LogErrLine2: PUBLIC PROCEDURE [str1, str2: LONG STRING] = {    LogText[str1]; LogErrLine[str2]};  LogErrLineBadFile: PROCEDURE [str: LONG STRING] = {    LogErrLine2["Can't aquire file: "L, str]};  LogErrText: PUBLIC PROCEDURE [str: LONG STRING] =    BEGIN    TmControl.errorsInThisFile ¬ TRUE;    TmControl.errorsExist ¬ TRUE;    Stream.PutString[erStream, str];    END;    LogErrText2: PUBLIC PROCEDURE [str1, str2: LONG STRING] = {    LogText[str1]; LogErrText[str2]};  LogLine: PUBLIC PROCEDURE [str: LONG STRING] = {    Stream.PutString[erStream, str]; Stream.PutChar[erStream, Ascii.CR]};    LogText: PUBLIC PROCEDURE [str: LONG STRING] = {    Stream.PutString[erStream, str]};  LogText2: PUBLIC PROCEDURE [str1, str2: LONG STRING] = {    LogText[str1]; LogText[str2]};  OpenFbOut: PUBLIC PROCEDURE =    BEGIN    fbOutStream ¬ MStream.WriteOnly[      ReplaceExt[outFile, "fb"], [NIL, NIL], binary !      MStream.Error => IF code = fileNotAvailable THEN GOTO fna ELSE REJECT];    EXITS fna => {LogErrLineBadFile[outFile]; TmControl.FatalError};    END;  OpenFbSort: PUBLIC PROCEDURE RETURNS [p: LONG POINTER] =    BEGIN    fbHandle: MFile.Handle;        fbHandle ¬ MFile.Acquire[      name: ReplaceExt[outFile, "fb"], access: readWrite, release: [NIL, NIL]];    IF (fbFileSize ¬ MFile.GetLength[fbHandle]) = 0 THEN {MFile.Release[fbHandle];       RETURN};    fbSeg ¬ MSegment.Create[file: fbHandle, release: [NIL, NIL]];    p ¬ MSegment.Address[segment: fbSeg];    END;  OpenFt: PUBLIC PROCEDURE =    BEGIN    ftStream ¬ MStream.WriteOnly[      ReplaceExt[outFile, "ft"], [NIL, NIL], binary !      MStream.Error => IF code = fileNotAvailable THEN GOTO fna ELSE REJECT];    EXITS fna => {LogErrLineBadFile[outFile]; TmControl.FatalError};    END;  OpenNextDf: PUBLIC PROCEDURE RETURNS [thru: BOOLEAN ¬ FALSE] =    BEGIN    dfName: LONG STRING;    TmControl.BeginTime ¬ System.GetGreenwichMeanTime[];    IF fIdf = 0 THEN LogLine["Reading Defs Files ..."L]    ELSE {MSegment.Delete[sourceSegment]; sourceSegment ¬ NIL};    IF fIdf = defsFilesCnt THEN RETURN[TRUE];    dfName ¬ defsFileNames[fIdf];    sourceFile ¬ MFile.Acquire[      name: dfName, access: readOnly, release: [NIL, NIL] !      MFile.Error =>        SELECT TRUE FROM	    code = conflictingAccess, (code = noSuchFile) AND (dfName[dfName.length - 1] # 'n) => {LogErrLineBadFile[dfName]; GOTO fNA};	    (code = noSuchFile) AND (dfName[dfName.length - 1] = 'n) => 	      {dfName.length ¬ dfName.length - 1;	       siPrologLength ¬ siPrologLength -1;	       RETRY}	  ENDCASE => REJECT];    createTime ¬ MFile.GetCreateDate[file: sourceFile];    defsTimes[fIdf] ¬  System.SecondsSinceEpoch[createTime];    createDate.length ¬ 0;    Time.Append[s: createDate,      unpacked: Time.Unpack[time: createTime],      zone: FALSE];    CreateSourceSegment[dfName];    TmControl.TtyText2[dfName, "   of "L];    TmControl.TtyText2[createDate,"  "L];    LogText2[dfName, "   of "L];    LogLine[createDate];    fIdf ¬ fIdf + 1;    EXITS fNA => TmControl.FatalError;    END;  -- of OpenNextDf proc  OpenNextEb: PUBLIC PROCEDURE RETURNS [thru: BOOLEAN ¬ FALSE] =    BEGIN    sfi: CARDINAL [0..TmFile.maxNumFiles);    IF fIeb # 0 THEN ebStream ¬ CloseStream[ebStream];    FOR sfi IN [fIeb..sourceFilesCnt) DO      IF importsOnly[sfi] THEN LOOP;      ebStream ¬ MStream.ReadOnly[        ReplaceExt[sourceFileNames[sfi], "eb"], [NIL, NIL]];      fIeb ¬ sfi + 1;      RETURN[FALSE];      REPEAT FINISHED => RETURN[TRUE];      ENDLOOP;    END;  -- of OpenNextEb proc  OpenNextFb: PUBLIC PROCEDURE RETURNS [thru: BOOLEAN ¬ FALSE] =    BEGIN    sfi: CARDINAL [0..TmFile.maxNumFiles);    IF fIfb # 0 THEN fbInStream ¬ CloseStream[fbInStream];    FOR sfi IN [fIfb..sourceFilesCnt) DO      IF ~importsOnly[sfi] THEN LOOP;      fbInStream ¬ MStream.ReadOnly[        ReplaceExt[sourceFileNames[sfi], "fb"], [NIL, NIL]];      fIfb ¬ sfi + 1;      RETURN[FALSE];      REPEAT FINISHED => RETURN[TRUE];      ENDLOOP;    END;  -- of OpenNextFb proc  OpenNextMc: PUBLIC PROCEDURE RETURNS [thru: BOOLEAN ¬ FALSE] =    BEGIN        sfi: CARDINAL [0..TmFile.maxNumFiles);    mcTime: LONG CARDINAL;    TmControl.BeginTime ¬ System.GetGreenwichMeanTime[];    createDate.length ¬ 0;    IF fImc = 0 THEN LogLine["Reading Source Files ..."L]    ELSE {      errorsInFile[fImc - 1] ¬ TmControl.errorsInThisFile;      ifsInFile[fImc - 1] ¬ TmControl.ifsInThisFile;      MSegment.Delete[sourceSegment];      sourceSegment ¬ NIL;      mlStream ¬ CloseStream[mlStream];      ebStream ¬ CloseStream[ebStream];      siStream ¬ CloseStream[siStream]};    TmControl.errorsInThisFile ¬ FALSE;    TmControl.ifsInThisFile ¬ FALSE;    FOR sfi IN [fImc..sourceFilesCnt) DO      IF passTwoOnly[sfi] OR importsOnly[sfi] THEN LOOP;      String.Copy[currentFile, sourceFileNames[sfi]];      sourceFile ¬ MFile.Acquire[        name: currentFile, access: readOnly, release: [NIL, NIL] !        MFile.Error =>          IF code = noSuchFile OR code = conflictingAccess THEN GOTO fNA          ELSE REJECT];      createTime ¬ MFile.GetCreateDate[file: sourceFile];      mcTime ¬ System.SecondsSinceEpoch[createTime];      IF aFlagSet THEN        IF PresentAndTimely[ReplaceExt[currentFile, "eb"], mcTime]          AND PresentAndTimely[ReplaceExt[currentFile, "ml"], mcTime]          AND PresentAndTimely[ReplaceExt[currentFile, "si"], mcTime]          AND CheckSiProlog[currentFile, mcTime] THEN {          MFile.Release[sourceFile]; sourceFile ¬ NIL; LOOP};      Time.Append[s: createDate,          unpacked: Time.Unpack[time: createTime],	zone: FALSE];      CreateSourceSegment[ReplaceExt[currentFile, "mc"]];      TmControl.TtyText2[currentFile, "  of "L];      TmControl.TtyText2[createDate, "  "L];      LogText2[currentFile, "    of "L];      LogLine[createDate];      ebStream ¬ MStream.WriteOnly[        name: ReplaceExt[currentFile, "eb"], release: [NIL, NIL], type: binary !        MStream.Error => IF code = fileNotAvailable THEN GOTO fNA ELSE REJECT];      mlStream ¬ MStream.WriteOnly[        name: ReplaceExt[currentFile, "ml"], release: [NIL, NIL], type: binary !        MStream.Error => IF code = fileNotAvailable THEN GOTO fNA ELSE REJECT];      siStream ¬ MStream.WriteOnly[        name: ReplaceExt[currentFile, "si"], release: [NIL, NIL], type: binary !        MStream.Error => IF code = fileNotAvailable THEN GOTO fNA ELSE REJECT];      WriteSiProlog[mcTime];      fImc ¬ sfi + 1;      RETURN[FALSE];      REPEAT        fNA => {LogErrLineBadFile[currentFile]; TmControl.FatalError};        FINISHED => RETURN[TRUE];      ENDLOOP;    END;  -- of OpenNextMc proc  OpenNextMl: PUBLIC PROCEDURE RETURNS [thru: BOOLEAN ¬ FALSE] =    BEGIN    sfi: CARDINAL [0..TmFile.maxNumFiles);    IF fIml # 0 THEN mlStream ¬ CloseStream[mlStream];    FOR sfi IN [fIml..sourceFilesCnt) DO      IF importsOnly[sfi] THEN LOOP;      mlStream ¬ MStream.ReadOnly[        ReplaceExt[sourceFileNames[sfi], "ml"], [NIL, NIL]];      fIml ¬ sfi + 1;      RETURN[FALSE];      REPEAT FINISHED => RETURN[TRUE];      ENDLOOP;    END;  -- of OpenNextMl proc  OpenNextSi: PUBLIC PROCEDURE RETURNS [thru: BOOLEAN ¬ FALSE] =    BEGIN    sfi: CARDINAL [0..TmFile.maxNumFiles);    IF fIsi = 0 THEN LogLine["Reading SI Files ..."L]    ELSE {      siStream ¬ CloseStream[siStream];      IF ifsInFile[fIsi - 1] THEN        MFile.Delete[          MFile.Acquire[          ReplaceExt[sourceFileNames[fIsi - 1], "si"], delete, [NIL, NIL]]]};    FOR sfi IN [fIsi..sourceFilesCnt) DO      IF importsOnly[sfi] THEN LOOP;      siStream ¬ MStream.ReadOnly[        ReplaceExt[sourceFileNames[sfi], "si"], [NIL, NIL]];      Stream.SetPosition[siStream, siPrologLength];  -- skip siProlog      LogText2[sourceFileNames[sfi], "   "L];      fIsi ¬ sfi + 1;      RETURN[FALSE];      REPEAT FINISHED => RETURN[TRUE];      ENDLOOP;    END;  -- of OpenNextSi proc  OpenStFile: PUBLIC PROCEDURE =    BEGIN    stStream ¬ MStream.ReadWrite[ReplaceExt[outFile, "st"], [NIL, NIL], binary];    END;  -- of OpenStFile proc  PutHex: PUBLIC PROCEDURE [sh: Stream.Handle, c: CARDINAL] =    BEGIN    FourHexDigits: TYPE = PACKED ARRAY [0..4) OF [0..15];    hexChars: ARRAY [0..17B] OF CHARACTER = [      '0, '1, '2, '3, '4, '5, '6, '7, '8, '9, 'A, 'B, 'C, 'D, 'E, 'F];    i: CARDINAL;    FOR i IN [0..4) DO      Stream.PutChar[sh, hexChars[LOOPHOLE[c, FourHexDigits][i]]]; ENDLOOP;    END;  ReplaceExt: PUBLIC PROCEDURE [name, ext: LONG STRING] RETURNS [LONG STRING] = {    name.length ¬ name.length - 2; String.AppendString[name, ext]; RETURN[name]};  -- Private Procedures  CheckSiProlog: PROCEDURE [name: LONG STRING, sftime: LONG CARDINAL]    RETURNS [consistent: BOOLEAN ¬ FALSE] =    BEGIN    dfi: CARDINAL [0..TmFile.maxNumFiles);    nameSink: LONG STRING ¬ [TmFile.fileNameMaxlenght];    nameBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[@nameSink.text], startIndex: 0, stopIndexPlusOne: 0      -- variable -- ];    sh: MStream.Handle;    timeSink: LONG CARDINAL;    timeBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@timeSink]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LONG CARDINAL]];    versionSink: LONG STRING ¬ [18];    versionBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[@versionSink.text], startIndex: 0, stopIndexPlusOne:       0];    sh ¬ MStream.ReadOnly[name: name, release: [NIL, NIL]];    versionSink.length ¬ versionBlock.stopIndexPlusOne ¬ Stream.GetWord[sh];    IF Stream.GetBlock[sh, versionBlock].why = normal       AND String.EqualStrings[TmAssembler.version, versionSink]      AND Stream.GetBlock[sh, timeBlock].why = normal AND sftime = timeSink      AND defsFilesCnt = Stream.GetWord[sh] THEN      FOR dfi IN [0..defsFilesCnt) DO        nameSink.length ¬ nameBlock.stopIndexPlusOne ¬ Stream.GetWord[sh];        IF Stream.GetBlock[sh, nameBlock].why # normal          OR Stream.GetBlock[sh, timeBlock].why # normal          OR ~String.EqualStrings[defsFileNames[dfi], nameSink]          OR defsTimes[dfi] # timeSink THEN EXIT;        REPEAT FINISHED => consistent ¬ TRUE;        ENDLOOP;    sh ¬ CloseStream[sh];    END;  -- of CheckSiProlog proc  CreateSourceSegment: PROCEDURE [name: LONG STRING] =    BEGIN    es: LONG STRING ¬ [64];  -- error string    length: LONG CARDINAL ¬ MFile.GetLength[sourceFile];    IF length = 0 THEN {      LogErrText2[name, " of "L];      LogErrLine2[createDate, " is a zero length file."L]; TmControl.FatalError};    IF Inline.HighHalf[length] # 0 THEN {      LogErrLine2[name, " length > 64k pages."L]; TmControl.FatalError};    sourceSegment ¬ MSegment.Create[file: sourceFile, release: [NIL, NIL]];    sourceFile ¬ NIL;    TmModule.ScanInit[MSegment.Address[sourceSegment], Inline.LowHalf[length]];    END;  -- of CreateSourceSegment proc  PresentAndTimely: PROCEDURE [name: LONG STRING, mcTime: LONG CARDINAL]    RETURNS [pat: BOOLEAN ¬ TRUE] =    BEGIN    fh: MFile.Handle;    fh ¬ MFile.Acquire[      name: name, access: readOnly, release: [NIL, NIL] !      MFile.Error =>        IF code = noSuchFile THEN GOTO notPresent        ELSE IF code = conflictingAccess THEN GOTO fNA ELSE REJECT];    pat ¬ mcTime < System.SecondsSinceEpoch[MFile.GetTimes[fh].create];    MFile.Release[fh];    EXITS      notPresent => pat ¬ FALSE;      fNA => {LogErrLineBadFile[name]; TmControl.FatalError};    END;  -- of PresentAndTimely proc  WriteSiProlog: PROCEDURE [mcTime: LONG CARDINAL] =    BEGIN    dfi: CARDINAL [0..TmFile.maxNumFiles);    timeSource: LONG CARDINAL;    timeBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@timeSource]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LONG CARDINAL]];    Stream.PutWord[siStream, TmAssembler.version.length];    Stream.PutString[siStream, TmAssembler.version];    timeSource ¬ mcTime;    Stream.PutBlock[siStream, timeBlock];    Stream.PutWord[siStream, defsFilesCnt];    FOR dfi IN [0..defsFilesCnt) DO      Stream.PutWord[siStream, defsFileNames[dfi].length];      Stream.PutString[siStream, defsFileNames[dfi]];      timeSource ¬ defsTimes[dfi];      Stream.PutBlock[siStream, timeBlock];      ENDLOOP;    END;  -- of WriteSiProlog proc  END.... -- of MassFiles  -- Log  -- 16-Jul-82 11:32:22 - ETN        - TrinityMass Version 1  -- 25-Oct-82 16:35:29 - ETN        - Added MStream.SetLength to CloseStream   --  1-Nov-82 13:53:26 - ETN        - Change OpenFbSort for fb Trunc fix   -- 21-Jan-83 15:50:49 - ETN        - Sierra. Added type: to MStream.WriteOnly  --                                   Handled type change for MStream.SetLength   -- 15-Jul-83 16:19:30 - JAC        - Klamath changes Change OpenNextDf to use .dfn then .df to maintain backwards compatibility. Initialize global variables for Klamath. Fix bug introduced when using .df instead of .dfn files  --  3-Aug-83 14:58:44 - JAC        - Added backup file for stmt segment   --  8-Aug-83 17:34:17 - JAC        - Added backup file for pass segment  -- 12-Aug-83 10:32:28 - JAC        - Added error hanndling for insufficient space when creating backup file and make version a long string consisting of date and time instead of a cardinal  -- 17-Aug-83 12:51:30 - JAC        - delete si if abort or a fatal error exists OpenFbSort creates a segment not a stream  -- 16-Sep-83  9:00:22 - DEG     	- convert to Klamath 11.0b  -- 26-Jan-84 16:04:44 - JAC        - Implement procedure to delete .si's when errors were found in pass 1  -- 27-Jan-84 16:31:34 - JAC        - error log contains date stamp  -- Time: 26-Sep-84 20:45:24	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
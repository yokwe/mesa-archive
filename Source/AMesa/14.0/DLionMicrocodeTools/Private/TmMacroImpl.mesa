-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TmMacroImpl.mesa-- Last edit: JAC     6-Nov-85 16:42:44   -- Last edit: ETN    21-Jan-83 10:31:22DIRECTORY  Heap USING [systemZone],  String USING [AppendChar, AppendString, StringBoundsFault, WordsForString],  TmAssembler USING [    CharOf, ElementRec, EofChar, Flagword, GetStmtSpace, maxStringLength, MEntryPtr,    MyString, MyStringPtr, Phrase, PhrasePtr, PhraseElement, PhraseElementPtr,    RetType, sizeArgArray],  TmControl USING [argBuf, linkLoad, linkVal, numArgs, statement],  TmFile USING [    LogErrAndSrcLines, LogErrAndSrcLinesBadChar, LogErrArgAndSrcLines],  TmLabel USING [ProcessLineLabel],  TmModule USING [BreakPhraseArg, BreakPhraseMain, FindM, SaveArgs];TmMacroImpl: PROGRAM  IMPORTS TmControl, TmFile, TmLabel, TmModule, TmAssembler, Heap, String  EXPORTS TmModule =  BEGIN  OPEN TmControl, TmModule, TmAssembler;  ExpandArrow: PUBLIC PROCEDURE [flags: Flagword]    RETURNS [peptr: PhraseElementPtr] =    BEGIN    -- Arrow phrase is in argBuf[0..numArgs] .  Phrase must be expanded into a phrase record with a chain of phrase elements.    -- first look-up each syntactic element in the symbol table and build a chain of phrase elements.    invalid: BOOLEAN ¬ FALSE;    i: CARDINAL;    mynumArgs: CARDINAL ¬ numArgs;    myS: MyString;    memRef: BOOLEAN ¬ flags.HasArgs;    newpeptr: PhraseElementPtr ¬ NIL;    pe: PhraseElement;    er: ElementRec;    valu: CARDINAL;    mptr: MEntryPtr;    ArgArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    SaveArgs[@ArgArray, mynumArgs];    peptr ¬ NIL;    UNTIL ArgArray[mynumArgs].length # 0 DO mynumArgs ¬ mynumArgs - 1 ENDLOOP;    FOR i DECREASING IN [0..mynumArgs] DO      myS ¬ [0, ArgArray[i]];      er ¬ InterpretArg[BreakPhraseArg[@myS]];            WITH er SELECT FROM        arrow =>          BEGIN          -- delete rh reference          IF memRef THEN            BEGIN            memRef ¬ FALSE;            IF peptr = NIL THEN              BEGIN              TmFile.LogErrAndSrcLines["Invalid arrow statement "L];              invalid ¬ TRUE;              EXIT;              END;            peptr ¬ peptr.nextElement;            END;          -- try "XX¬" first          IF i = 0 THEN            BEGIN            TmFile.LogErrAndSrcLines["Leading arrow illegal "L];            invalid ¬ TRUE;            EXIT;            END;          String.AppendChar[ArgArray[i - 1], '¬];          mptr ¬ FindM[ArgArray[i - 1]];          IF mptr = NIL THEN            BEGIN  -- "XX¬" not in ST            ArgArray[i - 1].length ¬ ArgArray[i - 1].length - 1;            newpeptr ¬ GetStmtSpace[SIZE[PhraseElement]];            newpeptr­ ¬ PhraseElement[peptr, ElementRec[arrow[]]];            peptr ¬ newpeptr;            END          ELSE            BEGIN  -- "XX¬" is in ST            pe.elementRec ¬ mptr.ptr­;            WITH pe.elementRec SELECT FROM              partialArrow =>                BEGIN                String.AppendString[ArgArray[i - 1], ArgArray[i + 1]];                mptr ¬ FindM[ArgArray[i - 1]];                IF mptr = NIL THEN                  BEGIN                  TmFile.LogErrArgAndSrcLines[                    "Unknown macro in arrow clause"L, ArgArray[i - 1]];                  invalid ¬ TRUE;                  END                ELSE                  BEGIN  -- "XX¬Y" is in ST                  peptr­ ¬ PhraseElement[peptr­.nextElement, mptr.ptr­];                  EXIT;                  END;                END;              link =>                BEGIN                valu ¬ 16;                IF peptr = NIL THEN                  BEGIN                  TmFile.LogErrAndSrcLines["Link value not known"L];                  invalid ¬ TRUE;                  EXIT;                  END;                WITH peptr­.elementRec SELECT FROM                  constant => valu ¬ value;                  variable => valu ¬ val;                  ENDCASE;                IF valu NOT IN [0..15] THEN                  BEGIN                  TmFile.LogErrAndSrcLines["Link value not in 0 - 15"L];                  invalid ¬ TRUE;                  EXIT;                  END                ELSE BEGIN linkLoad ¬ TRUE; linkVal ¬ valu; END;                peptr­ ¬ PhraseElement[NIL, ElementRec[macro[macroIndex]]];                EXIT;                END;              ENDCASE;            END;          LOOP;          END;        variable =>          BEGIN          IF val NOT IN [0..255] THEN            BEGIN            TmFile.LogErrAndSrcLines["Invalid variable value not in [0..255]"L];            er ¬ ElementRec[constant[255]];            END          ELSE er ¬ ElementRec[constant[val]];          END;        constant =>          IF value NOT IN [0..255] THEN            BEGIN            TmFile.LogErrAndSrcLines["Invalid constant value NOT IN [0..255]"L];            er ¬ ElementRec[constant[255]];            END;        undefinedToken =>          BEGIN          TmFile.LogErrArgAndSrcLines[            "Unknown macro in arrow clause"L, ArgArray[i]];          invalid ¬ TRUE;          LOOP;          END;        ENDCASE;      -- token not arrow      IF invalid THEN EXIT;      newpeptr ¬ GetStmtSpace[SIZE[PhraseElement]];      newpeptr­ ¬ PhraseElement[peptr, er];      peptr ¬ newpeptr;      ENDLOOP;    IF invalid THEN peptr ¬ NIL;        END;  -- end ExpandArrow  ExpandRHmem: PUBLIC PROCEDURE RETURNS [peptr: PhraseElementPtr] =    BEGIN    i: CARDINAL;    newpeptr: PhraseElementPtr ¬ NIL;    mptr: MEntryPtr;    peptr ¬ NIL;    FOR i DECREASING IN [0..numArgs] DO      IF argBuf[i][0] = '¬ THEN        BEGIN        mptr ¬ FindM[argBuf[i + 1]];        IF mptr # NIL THEN          WITH mptr­.ptr­ SELECT FROM            register =>              BEGIN              newpeptr ¬ GetStmtSpace[SIZE[PhraseElement]];              newpeptr­ ¬ PhraseElement[peptr, ElementRec[register[RHm, regnum]]];              peptr ¬ newpeptr;              EXIT;              END;            ENDCASE;        END;      ENDLOOP;    END;  -- end ExpandRHmem  ExpandUserMacroArg: PROCEDURE [ET: userMacro ElementRec, myS: MyStringPtr] =    BEGIN    char: CHARACTER;    val: INTEGER;    argMacroArg: MyString ¬ [0, ET.str];    argMacro: MyStringPtr ¬ @argMacroArg;    myS.String.length ¬ 0;    DO      char ¬ Nextch[argMacro];      SELECT char FROM        '# =>          BEGIN          char ¬ Nextch[argMacro];          IF char NOT IN ['0..'9] THEN TmFile.LogErrAndSrcLinesBadChar[char];          val ¬ char - '0;          SELECT val FROM            0 => MyAppendChar[myS.String, CharOf[numArgs]];            <= numArgs => MyAppendString[myS.String, argBuf[val]];            ENDCASE;          END;        EofChar => EXIT;        ENDCASE => MyAppendChar[myS.String, char];      ENDLOOP;    END;  -- end ExpandUserMacroArg  ExpandUserMacroMain: PROCEDURE [ET: userMacro ElementRec] =    BEGIN    char: CHARACTER;    val: INTEGER;    str: LONG STRING ¬ [maxStringLength];    argMacroArg: MyString ¬ [0, ET.str];    argMacro: MyStringPtr ¬ @argMacroArg;    tempString: MyString ¬ MyString[0, str];    DO      char ¬ Nextch[argMacro];      SELECT char FROM        '# =>          BEGIN          char ¬ Nextch[argMacro];          IF char NOT IN ['0..'9] THEN TmFile.LogErrAndSrcLinesBadChar[char];          val ¬ char - '0;          SELECT val FROM            0 => MyAppendChar[str, CharOf[numArgs]];            <= numArgs => MyAppendString[str, argBuf[val]];            ENDCASE;          END;        EofChar => EXIT;        ENDCASE => MyAppendChar[str, char];      ENDLOOP;    MyAppendChar[str, ',];    tempString.NextChar ¬ 0;    UNTIL tempString.String.length <= tempString.NextChar DO      InterpretMain[BreakPhraseMain[@tempString]] ENDLOOP;    END;  -- end ExpandUserMacroMain  IntegerConvert: PROCEDURE [str: LONG STRING] RETURNS [value: INTEGER] =    BEGIN    val, octVal, decVal, hexVal: INTEGER ¬ 0;    notOctal, notDecimal: BOOLEAN ¬ FALSE;    i: CARDINAL;    char: CHARACTER;    IntVal: PROCEDURE [char: CHARACTER] RETURNS [value: INTEGER] =      BEGIN      value ¬        SELECT char FROM          IN ['0..'9] => char - '0,          IN ['a..'f] => (char - 'a) + 10,          IN ['A..'F] => (char - 'A) + 10,          ENDCASE => 0;      END;  -- end IntVal    value ¬ 0;    FOR i IN [0..str.length) DO      char ¬ str[i];      SELECT char FROM        IN ['0..'7] => NULL;        IN ['8..'9] => notOctal ¬ TRUE;        IN ['a..'f], IN ['A..'F] => notOctal ¬ notDecimal ¬ TRUE;        '' =>          BEGIN  -- base will follow prime character          IF i + 2 # str.length THEN {            TmFile.LogErrAndSrcLines["Number has illegal format, 0 used"L];            RETURN[0];            };          SELECT str[i + 1] FROM            'b, 'B =>              IF notOctal THEN                TmFile.LogErrAndSrcLines["non-octal character in octal string"L]  -- octal base              ELSE value ¬ octVal;            'd, 'D =>              IF notDecimal THEN                TmFile.LogErrAndSrcLines[                  "non-decimal character in decimal string"L]  -- decimal base              ELSE value ¬ decVal;            'x, 'X => value ¬ hexVal;  -- hex base            ENDCASE => TmFile.LogErrAndSrcLines["illegal digit in number"L];          RETURN[value];          END;        ENDCASE => TmFile.LogErrAndSrcLines["illegal digit in number"L];      val ¬ IntVal[char];      octVal ¬ 8*octVal + val;      decVal ¬ 10*decVal + val;      hexVal ¬ 16*hexVal + val;      ENDLOOP;    RETURN[hexVal];  -- default is hex base    END;  -- end IntegerConvert  InterpretArg: PUBLIC PROCEDURE [inFlags: Flagword]    RETURNS [et: ElementRec] =    -- evaluate an arg or arrow element    BEGIN    ret: RetType;    mptr: MEntryPtr;    str: LONG STRING;        myS: MyString;      SELECT TRUE FROM      inFlags.LeadDigit =>        et ¬ ElementRec[constant[IntegerConvert[argBuf[0]]]];      ENDCASE =>        BEGIN        mptr ¬ FindM[argBuf[0]];        IF mptr = NIL THEN et ¬ ElementRec[undefinedToken[]]        ELSE et ¬ mptr.ptr­;        END;    DO        WITH x: et SELECT FROM        userMacro =>          BEGIN          str ¬ Heap.systemZone.NEW[StringBody[maxStringLength]];          myS ¬ MyString[0, str];          ExpandUserMacroArg[x, @myS];          et ¬ InterpretArg[BreakPhraseArg[@myS]];          Heap.systemZone.FREE[@str];          LOOP;          END;        builtinMacro =>          BEGIN                    ret ¬ x.proc[x.type];          WITH ret SELECT FROM            Null => et ¬ ElementRec[empty[]];            Text =>              BEGIN              myS ¬ MyString[0, txt];              et ¬ InterpretArg[BreakPhraseArg[@myS]];              END;            Value => et ¬ ElementRec[constant[val]];            ENDCASE;          LOOP;          END;        ENDCASE => RETURN;      ENDLOOP;    END;  -- end InterpretArg  InterpretMain: PUBLIC PROCEDURE [inFlags: Flagword] =    BEGIN    ChainPhraseRecord: PROCEDURE [peptr: PhraseElementPtr] =      BEGIN      -- create phrase record      pptr: PhrasePtr;      IF peptr = NIL THEN RETURN;      pptr ¬ GetStmtSpace[SIZE[Phrase]];      pptr­ ¬ Phrase[];      pptr­.firstElement ¬ peptr;      -- chain phrase record onto statement record      pptr­.nextPhrase ¬ statement.firstPhrase;      statement.firstPhrase ¬ pptr;      END;  -- end ChainPhraseRecord    er: ElementRec;    mptr: MEntryPtr;    peptr: PhraseElementPtr ¬ NIL;    IF argBuf[0].length = 0 THEN RETURN;    SELECT TRUE FROM      inFlags.ArrowClause =>        BEGIN        IF inFlags.HasArgs THEN ChainPhraseRecord[ExpandRHmem[]];        er ¬ ElementRec[arrowPhrase[]];        END;      inFlags.Label => er ¬ ElementRec[label[argBuf[0], 0]];      ENDCASE =>        BEGIN        mptr ¬ FindM[argBuf[0]];        IF mptr = NIL THEN er ¬ ElementRec[undefinedToken[]] ELSE er ¬ mptr.ptr­;        END;    WITH x: er SELECT FROM      arrowPhrase => peptr ¬ ExpandArrow[inFlags];      userMacro => ExpandUserMacroMain[x];      macro =>        BEGIN        peptr ¬ GetStmtSpace[SIZE[PhraseElement]];        peptr­ ¬ PhraseElement[NIL, x];        END;      builtinMacro => [] ¬ x.proc[x.type];      label => [] ¬ TmLabel.ProcessLineLabel[x.str];      undefinedToken => {        TmFile.LogErrArgAndSrcLines["Undefined Macro "L, argBuf[0]]};      ENDCASE;    ChainPhraseRecord[peptr];    END;  -- end InterpretMain  Nextch: PROCEDURE [myS: MyStringPtr] RETURNS [char: CHARACTER] = INLINE    BEGIN    IF myS.NextChar >= myS.String.length THEN RETURN[EofChar];    char ¬ myS.String[myS.NextChar];    myS.NextChar ¬ myS.NextChar + 1;    END;  -- end Nextch  MyAppendString: PROCEDURE [str, strX: LONG STRING] = INLINE    BEGIN    String.AppendString[      str, strX !      String.StringBoundsFault =>        BEGIN        ns ¬ TmAssembler.GetStmtSpace[String.WordsForString[str.length + strX.length + 20]];   --get new storage the size of the 2 strings and some extra space	ns­ ¬ [maxlength: str.length + strX.length + 20, length: 0, text: ];        String.AppendString[ns, str];                RESUME [str ¬ ns];        END];    END;  -- end MyAppendString  MyAppendChar: PROCEDURE [str: LONG STRING, char: CHARACTER] = INLINE    BEGIN    String.AppendChar[      str, char !      String.StringBoundsFault =>        BEGIN        ns ¬ TmAssembler.GetStmtSpace[String.WordsForString[str.length + 20]];	ns­ ¬ [maxlength: str.length + 20, length: 0, text: ];        String.AppendString[ns, str];                RESUME [str ¬ ns];        END];    END;  -- end MyAppendString  END...    -- Log  -- 16-Jul-82 13:28:13 - ETN        - TrinityMass Version 1  -- 21-Jan-83 10:31:17 - ETN        - Sierra.  Heap => Storage  --  9-Aug-83 14:48:47 - JAC        - eliminate use of system zone in MyAppendString and MyAppendChar  --  6-Nov-85 16:42:56 - JAC        - initializae extra paramter to label in ElementRec as a result of adding SetLabel
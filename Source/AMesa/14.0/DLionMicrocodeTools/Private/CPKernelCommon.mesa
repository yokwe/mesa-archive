-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CPKernelCommon.mesa, HGM, 27-Oct-83  2:25:02DIRECTORY  Environment USING [LongNumber],  Inline USING [BITAND, BITSHIFT, HighHalf, LowHalf],  CP USING [    IOReg, Link, Map, mapOffset, OtherReg, RealMemory, RReg, UReg, VirturalMemory],  CPKernel USING [machine, ReadRealMemory, ReadRH, ReadRReg, WriteRH, WriteRReg],  CPKernelConstants ,  CPKernelOps USING [ExecuteCPBuffer, ReadRealMemoryInternal, WriteCSInternal, WriteUSpecial],  CPMI USING [FX, FYNorm, FZNorm, MI],  IOPKernelOps USING [InitializeLock, lock];CPKernelCommon: MONITOR LOCKS IOPKernelOps.lock  IMPORTS    Inline, CPKernel, CPKernelOps, IOPKernelOps  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelConstants;    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    WriteRReg: PUBLIC ENTRY PROCEDURE [r: CP.RReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    -- kBuffer: R<addr> ¬ UKTemp, GOTO[kWait];    -- Write UKTemp with data first    IF r ~IN CP.RReg THEN AddressOutOfRange[];    CPKernelOps.WriteUSpecial[uKTemp, data];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      uKTempH, r, dz, rOrS, wrB, , , TRUE, , , uAddr, , , [d[uKTempL]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    END;   WriteLink: PUBLIC ENTRY PROCEDURE [link: CP.Link, data: Nibble] =    BEGIN ENABLE UNWIND => NULL;    --kBuffer: []¬ data, XDisp, c1;    --	       L<addr> ¬ 0, DISP4[Kc0], c2;    -- k1E is overwritten and restored.    translate: ARRAY CP.Link OF CPMI.FX = [	  pCallRet0, pCallRet1, pCallRet2, pCallRet3,	  pCallRet4, pCallRet5, pCallRet6, pCallRet7];    IF link NOT IN CP.Link THEN AddressOutOfRange[];    IF data NOT IN Nibble THEN DataOutOfRange[];    CPKernelOps.WriteCSInternal[      k1E, CPMI.MI[      , , , , , , , , , , , , , , kWait]];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      , , , , , , , , , dispBr, nibble, , [b[xDisp]], [d[data]], kBuffer + 1]];    CPKernelOps.WriteCSInternal[      kBuffer + 1, CPMI.MI[      , , , , , , , , , , , translate[link], , , kc0Loc]];    CPKernelOps.ExecuteCPBuffer[];    CPKernelOps.WriteCSInternal[      k1E, CPMI.MI[      , , , , , , , , , , , , , , kBELoc]];    END;    WriteRH: PUBLIC ENTRY PROCEDURE [rh: CP.RReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    dataH: Nibble ¬ Inline.BITAND[Inline.BITSHIFT[data, -4], 0FH];    dataL: Nibble ¬ Inline.BITAND[data, 0FH];    --kBuffer:	RH<addr>¬ data, GOTO[kWait];    IF rh ~IN CP.RReg THEN AddressOutOfRange[];    IF data ~IN [0..0FFH] THEN DataOutOfRange[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      , rh, , , , , , , , byte, nibble, loadRH, [d[dataH]], [d[dataL]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    END;   WriteUReg: PUBLIC ENTRY PROCEDURE [u: CP.UReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    dataHH: Nibble ¬ Inline.BITAND[Inline.BITSHIFT[data, -12], 0FH];    dataHL: Nibble ¬ Inline.BITAND[Inline.BITSHIFT[data, -8], 0FH];    dataLH: Nibble ¬ Inline.BITAND[Inline.BITSHIFT[data, -4], 0FH];    dataLL: Nibble ¬ Inline.BITAND[data, 0FH];    addrH: Nibble ¬ Inline.BITAND[Inline.BITSHIFT[u, -4], 0FH];    addrL: Nibble ¬ Inline.BITAND[u, 0FH];    --kBuffer: rK¬ data0-7, c1;    --	       rK¬ rK lRot8, c2;    --	       rK¬ rK .or. data8-15, c3;    --	       U<addr>¬ rK, GOTO[kWait], c1;    IF u ~IN CP.UReg THEN AddressOutOfRange[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      , rK, dz, rOrS, wrB, , , , , byte, nibble, , [d[dataHH]], [d[dataHL]], kBuffer + 1]];    CPKernelOps.WriteCSInternal[      kBuffer + 1, CPMI.MI[      rK, rK, dz, rOrS, aPass, , , , , , , , , [n[lRot8]], kBuffer + 2]];    CPKernelOps.WriteCSInternal[      kBuffer + 2, CPMI.MI[      rK, rK, da, rOrS, wrB, , , , , byte, nibble, , [d[dataLH]], [d[dataLL]], kBuffer + 3]];    CPKernelOps.WriteCSInternal[      kBuffer + 3, CPMI.MI[      addrH, rK, zb, rOrS, , , TRUE, TRUE, , , uAddr, , , [d[addrL]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    END;    ReadRAndRH: PUBLIC PROCEDURE [r: CP.RReg] RETURNS [data: LONG POINTER] =    BEGIN    temp: Environment.LongNumber;    temp.high ¬ CPKernel.ReadRH[r];    temp.low ¬ CPKernel.ReadRReg[r];    RETURN[temp.lp];    END;  WriteRAndRH: PUBLIC PROCEDURE [r: CP.RReg, data: LONG POINTER] =    BEGIN    CPKernel.WriteRH[r, Inline.HighHalf[data]];    CPKernel.WriteRReg[r, Inline.LowHalf[data]];    END;  ReadMap: PUBLIC ENTRY PROCEDURE [map: CP.Map] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadMapInternal[map]];    END;   ReadMapInternal: INTERNAL PROCEDURE [map: CP.Map] RETURNS [WORD] =    BEGIN    IF map ~IN CP.Map THEN AddressOutOfRange[];    RETURN[CPKernelOps.ReadRealMemoryInternal[LOOPHOLE[map + CP.mapOffset]]];    END;   WriteMap: PUBLIC ENTRY PROCEDURE [map: CP.Map, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    IF map ~IN CP.Map THEN AddressOutOfRange[];    WriteRealMemoryInternal[LOOPHOLE[map + CP.mapOffset], data];    END;   WriteRealMemory: PUBLIC ENTRY PROCEDURE [real: CP.RealMemory, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    WriteRealMemoryInternal[real, data];    END;  WriteRealMemoryInternal: INTERNAL PROCEDURE [real: CP.RealMemory, data: WORD] =    BEGIN    -- kBuffer: Noop, c1;    --	        rK¬ UKTemp, c2;    --	        Noop, c3;    --	        MAR ¬ [RHrK, rK+0], RawRef, c1;    --	        MDR ¬ UKernMD, GOTO[kWait], c2;    -- first write UKernMD with data and UKTemp with real.    SELECT CPKernel.machine FROM      dlion => IF Inline.HighHalf[real] ~IN [0..11] THEN AddressOutOfRange[];  -- 768K      dicentra => IF Inline.HighHalf[real] ~IN [0..255] THEN AddressOutOfRange[];      ENDCASE => ERROR;    CPKernelOps.WriteUSpecial[uKernMD, data];    CPKernelOps.WriteUSpecial[uKTemp, Inline.LowHalf[real]];    CPKernelOps.WriteUSpecial[uKCount, Inline.HighHalf[real]];  --loads RHrK as a side effect    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      , , , , , , , , , , , , , , kBuffer + 1]];    CPKernelOps.WriteCSInternal[      kBuffer + 1, CPMI.MI[      uKTempH, rK, dz, rOrS, wrB, , , TRUE, , , uAddr, , , [d[uKTempL]], kBuffer + 2]];    CPKernelOps.WriteCSInternal[      kBuffer + 2, CPMI.MI[      , , , , , , , , , , , , , , kBuffer + 3]];    CPKernelOps.WriteCSInternal[      kBuffer + 3, CPMI.MI[      , rK, zb, rPlusS, , , , , TRUE, , , , [n[rawRef]], , kBuffer + 4]];    CPKernelOps.WriteCSInternal[      kBuffer + 4, CPMI.MI[      uKernMDH, , dz, rOrS, , , , TRUE, TRUE, , uAddr, , , [d[uKernMDL]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    END;   ReadVirturalMemory: PUBLIC PROCEDURE [virt: CP.VirturalMemory] RETURNS [WORD] =    BEGIN    RETURN[CPKernel.ReadRealMemory[MapAddress[virt]]];    END;   WriteVirturalMemory: PUBLIC PROCEDURE [virt: CP.VirturalMemory, data: WORD] =    BEGIN    WriteRealMemory[MapAddress[virt], data];    END;   MapAddress: ENTRY PROCEDURE [virt: CP.VirturalMemory] RETURNS [CP.RealMemory] =    BEGIN ENABLE UNWIND => NULL;    a: LONG CARDINAL ¬ LOOPHOLE[virt];    page: CARDINAL = Inline.LowHalf[a/256];    offset: CARDINAL = Inline.LowHalf[a MOD 256];    mapEntry: MACHINE DEPENDENT RECORD [      pageLow: [0..0FFH], dp, w, d, rp: BOOLEAN, pageHigh: [0..0FH]];    mapEntry ¬ LOOPHOLE[ReadMapInternal[page]];    IF mapEntry.w AND mapEntry.d THEN      ERROR Error["Map entry is marked invalid"L];    a ¬ mapEntry.pageHigh*10000H + mapEntry.pageLow*256 + offset;    RETURN[LOOPHOLE[a]];    END;      WriteIOOut: PUBLIC ENTRY PROCEDURE [io: CP.IOReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    WriteIOOutInternal[io, data];    END;  WriteIOOutInternal: PUBLIC INTERNAL PROCEDURE [io: CP.IOReg, data: WORD] =    BEGIN    -- kBuffer:  IOOut<addr> ¬ UKTemp, GOTO[kWait], c1;    IF io ~IN [0..0FH] THEN AddressOutOfRange[];    CPKernelOps.WriteUSpecial[uKTemp, data];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      uKTempH, , dz, rOrS, , , , TRUE, , ioOut, uAddr, , [d[io]], [d[uKTempL]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    END;  WriteOther: PUBLIC ENTRY PROCEDURE [other: CP.OtherReg, data: WORD] =    BEGIN ENABLE UNWIND => NULL;    WriteOtherInternal[other, data];    END;   WriteOtherInternal: INTERNAL PROCEDURE [other: CP.OtherReg, data: WORD] =    BEGIN    SELECT other FROM      q =>        --kBuffer:  Q ¬ UKTemp, GOTO[kWait];        --Write UKTemp with data first        BEGIN        CPKernelOps.WriteUSpecial[uKTemp, data];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          uKTempH, , dz, rOrS, wrQ, , , TRUE, , , uAddr, , , [d[uKTempL]], kWait]];        END;      ib =>        --kBuffer:  IB ¬ UKTemp, GOTO[kWait], c1;        -- first set UKTemp to data.        BEGIN        CPKernelOps.WriteUSpecial[uKTemp, data];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          uKTempH, , , , , , , TRUE, , , uAddr, , [n[loadIB]], [d[uKTempL]], kWait]];        END;         pc16 =>        --kBuffer:  rK ¬ <data>+pc16, YDisp, c1;        --          BRANCH[KFlip, KNoFlip, 0E], c2;        --KFlip:    Cin ¬ pc16, GOTO[kWait], c3, at[0FFE];        --KNoFlip:  GOTO[kWait], c3, at[0FFF];        BEGIN        IF data ~IN [0..1] THEN DataOutOfRange[];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , rK, dz, rPlusS, wrB, , , , , dispBr, nibble, cinPC16, [b[yDisp]], [d[data]], kBuffer + 1]];        CPKernelOps.WriteCSInternal[          kBuffer + 1, CPMI.MI[          , , , , , , , , , , , , , , 0FFEH]];        CPKernelOps.WriteCSInternal[          0FFEH, CPMI.MI[  --KFlip          , , , , , , , , , , , cinPC16, , , kWait]];        CPKernelOps.WriteCSInternal[          0FFFH, CPMI.MI[  --KNoFlip          , , , , , , , , , , , , , , kWait]];        END;	       stackP =>        --kBuffer:	stackP ¬ <data>, GOTO[kWait], c1;        BEGIN        IF data ~IN [0..0FH] THEN DataOutOfRange[];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , , dz, rOrS, , , , , , , nibble, , [n[loadStackP]], [d[data]], kWait]];	        END;	      ibPtr =>        --kBuffer:	IBPtr ¬ <data>, GOTO[kWait], c1;        BEGIN	foo: CPMI.FZNorm = IF data = 0 THEN iBPtrTo0 ELSE iBPtrTo1;        IF data ~IN [0..1] THEN DataOutOfRange[];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , , , , , , , , , , , , , [n[foo]], kWait]];        END;	        mInt =>        --kBuffer:  ClrIntErr, GOTO[kWait], c1;	{if 0}        --kBuffer:  MesaIntRq, GOTO[kWait], c1;	{if 1}        BEGIN	foo: CPMI.FYNorm = IF data = 0 THEN clrIntErr ELSE mesaIntRq;        IF data ~IN [0..1] THEN DataOutOfRange[];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , , , , , , , , , , , , [n[foo]], , kWait]];        END;	        ekErr => CantWriteThatRegister[];	        ENDCASE => CantWriteThatRegister[];    CPKernelOps.ExecuteCPBuffer[];    RETURN;    END;        AddressOutOfRange: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Address out of Range"L];    END;  DataOutOfRange: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Data out of Range"L];    END;    CantReadThatRegister: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Can't read that register"L];    END;  CantWriteThatRegister: PUBLIC PROCEDURE =    BEGIN    ERROR Error["Can't write that register"L];    END;        IOPKernelOps.InitializeLock[];  END.
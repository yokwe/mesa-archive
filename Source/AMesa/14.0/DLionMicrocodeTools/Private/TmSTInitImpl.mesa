-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TmSTInitImpl.mesa-- Last edit: JAC      6-Nov-85 15:35:18-- Last edit: DEG     26-Sep-84 21:02:12-- Last edit: JAC     12-Aug-83 15:03:40 -- Last edit: ETN     17-Jul-82 19:43:19DIRECTORY  Ascii USING [CR],  Inline USING [BITAND, BITOR, BITSHIFT, BITXOR],  Heap USING [MakeNode],  String USING [    AppendChar, AppendNumber, AppendString, EqualString, WordsForString],  TmAssembler USING [    BuiltinMacroType, ElementRec, maxArgLength, MEntry, MEntryPtr, MyString,    RegisterType, RetType, sizeArgArray],  TmControl USING [config, curTask, ifsInThisFile, numArgs],  TmFile USING [LogErrAndSrcLines, LogErrArgAndSrcLines, LogLine],  TmLabel USING [    BrConstrain, byteTiming, canceledBr, canceledBr2, Constrain, masked, maxNumMI,    mdok, mdrok, natc, niblTiming, pci, ProcessAt, ProcessExternal,    ProcessReserve, ProcSA, SetDest, stw, wok],  TmModule USING [    BreakPhraseArg, BreakPhraseMain, FindM, InsertM, InterpretArg, InterpretMain,    MTtempHeap, SaveArgs, SkipUntil];TmSTInitImpl: PROGRAM  IMPORTS Heap, Inline, String, TmControl, TmFile, TmLabel, TmModule  EXPORTS TmModule =  BEGIN OPEN TmAssembler;  numBuiltins: INTEGER = 16;  builtinProcs: ARRAY [0..numBuiltins) OF PROCEDURE [BuiltinMacroType]    RETURNS [ret: RetType] = [    Arith  -- [00]    -- add  adds up to nine args    -- and  ands up to nine args    -- mul  muls up to nine args    -- or  ors up to nine args    -- xor  xors up to nine args    , Arith2  -- [01]    -- lshift  left shift arg1 by arg2    -- rshift  right shift arg1 by arg2    -- sub  subtracts arg2 from arg1    , Branch  -- [02]    -- goto  arg1 is destination label    -- gotoabs  arg1 is absolute destination    -- branch  arg1 = 0 dest, arg1 = 1 dest, arg3 = branch condition    -- cancelbr  arg1 is destination label, arg2 (optional) is a mask    -- disp2  arg1 = dest, arg2 = mask (2 bit dispatch)    -- disp3  arg1 = dest, arg2 = mask (3 bit dispatch)    -- disp4  arg1 = dest, arg2 = mask (4 bit dispatch)    -- dispni  arg1 = dest (8 bit dispatch)    -- ret  arg1 is destination label, acts like disp4    , If  -- [03]    -- equal  if arg1 = arg2 then arg3 else arg4    -- greater  if arg1 > arg2 then arg3 else arg4    -- andZero  if (arg1 and arg2) = 0 then arg3 else arg4    , Set  -- [04] sets variable named in arg1 to value of arg2    , PrintVar  -- [05] print variable named in arg1    , MacroDef  -- [06] arg1 = user macro name, arg2 = expansion    , RegDef  -- [07] arg1 = register name, arg2 = U/UY/R/RH, arg3 = reg address    , External  -- [08]    -- import  imports up to nine symbols    -- export  exports up to nine symbols    , At  -- [09]     -- at  arg1 = offset, arg2 = modulo (default 4096),    --arg3 = label (default current micro-instruction)    , Reserve  -- [10] reserve locations from arg1 thru arg2    , PrintString  -- [11] print string onto error file.  String must not contain commas, comment brackets, parens or brackets.    , SetTask  -- [12] arg1 is task numbrer [0..7]    , StartAddress  -- [13] arg1 is starting label    , SkipTo  -- [14] arg1 bang label to skip to    , LoopHole  -- [15] adds loophole of type arg1    ];  AddBuiltin: PROCEDURE [    str: LONG STRING, procnum: INTEGER, type: BuiltinMacroType] =    BEGIN    s: LONG STRING;    proc: PROCEDURE [BuiltinMacroType] RETURNS [RetType];    mptr: MEntryPtr ¬ Heap.MakeNode[      TmModule.MTtempHeap,      SIZE[builtinMacro ElementRec] + SIZE[MEntry] + String.WordsForString[        str.length]];    ETptr: LONG POINTER TO ElementRec;    ETptr ¬ LOOPHOLE[mptr + SIZE[MEntry]];    s ¬ LOOPHOLE[ETptr + SIZE[builtinMacro ElementRec]];    s­ ¬ StringBody[maxlength: str.length, length: 0, text:];    String.AppendString[s, str];    proc ¬ builtinProcs[procnum];    ETptr­ ¬ ElementRec[builtinMacro[proc, type]];    mptr­ ¬ MEntry[s, ETptr, NIL];    IF TmModule.InsertM[mptr] THEN      TmFile.LogErrArgAndSrcLines["Builtin already defined"L, str];    END;  -- end AddBuiltin  AddSTEntry: PROCEDURE [str: LONG STRING, er: ElementRec, erSize: CARDINAL] =    BEGIN    s: LONG STRING;    erptr: LONG POINTER TO ElementRec ¬ Heap.MakeNode[      TmModule.MTtempHeap,      erSize + SIZE[MEntry] + String.WordsForString[str.length]];    mptr: MEntryPtr;    erptr­ ¬ er;    mptr ¬ LOOPHOLE[erptr + erSize];    s ¬ LOOPHOLE[mptr + SIZE[MEntry]];    s­ ¬ StringBody[maxlength: str.length, length: 0, text:];    String.AppendString[s, str];    mptr­ ¬ MEntry[s, erptr, NIL];    [] ¬ TmModule.InsertM[mptr];    END;  Arith: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    i: CARDINAL;    val: INTEGER;    myS: MyString;    mynumArgs: CARDINAL ¬ TmControl.numArgs;    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    et: ElementRec;    TmModule.SaveArgs[@argArray, mynumArgs];    val ¬ SELECT type FROM mul => 1, and => -1, ENDCASE => 0;    FOR i IN [1..mynumArgs] DO      myS ¬ [0, argArray[i]];      et ¬ TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]];      SELECT type FROM        add => val ¬ val + GetValue[et];        and => val ¬ Inline.BITAND[val, GetValue[et]];        mul => val ¬ val*GetValue[et];        or => val ¬ Inline.BITOR[val, GetValue[et]];        xor => val ¬ Inline.BITXOR[val, GetValue[et]];        ENDCASE;      ENDLOOP;        RETURN[RetType[Value[val]]];    END;  -- end Arith  Arith2: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    val, val1, val2: INTEGER;    myS: MyString;    mynumArgs: CARDINAL ¬ TmControl.numArgs;    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    TmModule.SaveArgs[@argArray, mynumArgs];    IF TmControl.numArgs # 2 THEN      TmFile.LogErrAndSrcLines["Sub and shift require two args"L];    myS ¬ [0, argArray[1]];    val1 ¬ GetValue[TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]];    myS ¬ [0, argArray[2]];    val2 ¬ GetValue[TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]];    val ¬      SELECT type FROM        sub => val1 - val2,        lshift => Inline.BITSHIFT[val1, val2],        rshift => Inline.BITSHIFT[val1, -val2],        ENDCASE => 0;        RETURN[RetType[Value[val]]];    END;  -- end Arith2  At: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    et: ElementRec;    myS: MyString;    mynumArgs: CARDINAL ¬ TmControl.numArgs;    modA: INTEGER;    offset: INTEGER;    modulo: INTEGER;    name: LONG STRING;    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    Log: PROCEDURE [in: INTEGER] RETURNS [out: CARDINAL] = INLINE      BEGIN      out ¬ SELECT in FROM 2 => 1, 4 => 2, 8 => 3, 16 => 4, ENDCASE => 0;      IF out = 0 THEN        TmFile.LogErrAndSrcLines["Illegal modulo in at -- not 2,4,8, or 16 "L];      END;  -- end Log    TmModule.SaveArgs[@argArray, mynumArgs];    IF mynumArgs NOT IN [1..3] THEN      TmFile.LogErrAndSrcLines["at requires 1, 2, or 3 args"L];    name ¬ IF mynumArgs < 3 THEN NIL ELSE argArray[3];    myS ¬ MyString[0, argArray[2]];    modA ¬      IF mynumArgs > 1 THEN GetValue[      TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]] ELSE 4096;    modulo ¬ IF mynumArgs < 2 THEN 5 ELSE Log[modA];    myS ¬ MyString[0, argArray[1]];    et ¬ TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]];    WITH et SELECT FROM      variable, constant => offset ¬ GetValue[et];      label =>         IF mynumArgs > 1 THEN {	  offset ¬ 0;	  TmFile.LogErrAndSrcLines["Illegal argument in at phrase"L]}        ELSE offset ¬ value;      ENDCASE => TmFile.LogErrAndSrcLines["Illegal argument in at phrase"L];    IF offset NOT IN [0..modA) THEN      BEGIN      TmFile.LogErrAndSrcLines["Illegal offset in at -- not in [0..modulo] "L];      offset ¬ 0;      END;    TmLabel.ProcessAt[LOOPHOLE[offset], modulo, name];        RETURN[RetType[Null[]]];    END;  -- end At  Branch: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    myS: MyString;    mynumArgs: CARDINAL ¬ TmControl.numArgs;    offset1: CARDINAL ¬ 0;    offset2: CARDINAL ¬ 1;    modulo: CARDINAL ¬ 1;    andMask: INTEGER ¬ TmLabel.maxNumMI - 1;    noSetDest: BOOLEAN ¬ FALSE;    orMask: INTEGER ¬ 0;    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    TmModule.SaveArgs[@argArray, mynumArgs];    IF TmControl.numArgs < 1 THEN      TmFile.LogErrAndSrcLines["No args for goto type macro"L]    ELSE      BEGIN      SELECT type FROM        goto => NULL;        branch =>          BEGIN          IF mynumArgs NOT IN [2..3] THEN            TmFile.LogErrAndSrcLines["Wrong number of args for BRANCH"L]          ELSE            BEGIN            TmLabel.masked ¬ 1;            IF mynumArgs = 3 THEN              BEGIN              myS ¬ MyString[0, argArray[3]];              offset1 ¬ GetValue[                TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]];              modulo ¬                SELECT offset1 FROM                  1, 2 => 2,                  3, 5, 6 => 3,                  7, 11, 13, 14 => 4,                  ENDCASE => 0;              IF modulo = 0 THEN                TmFile.LogErrArgAndSrcLines["Illegal BRANCH mask"L, argArray[3]];              TmLabel.masked ¬ 3;              END;            TmLabel.BrConstrain[argArray[1], argArray[2], offset1, modulo];            noSetDest ¬ TRUE;            END;          END;        cancelbr =>          BEGIN          TmLabel.masked ¬ 1;          IF mynumArgs NOT IN [1..2] THEN            TmFile.LogErrAndSrcLines["Wrong number of args for CANCELBR"L]          ELSE            IF mynumArgs = 2 THEN              BEGIN              myS ¬ MyString[0, argArray[2]];              offset1 ¬ GetValue[                TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]];              modulo ¬                SELECT offset1 FROM                  = 0 => 6,                  < 2 => 1,                  < 4 => 2,                  < 8 => 3,                  < 16 => 4,                  ENDCASE => 5;              TmLabel.masked ¬ Inline.BITAND[offset1, 3];              IF modulo = 6 THEN TmLabel.masked ¬ 3;              IF modulo = 5 THEN                TmFile.LogErrArgAndSrcLines[                  "Illegal CANCELBR mask"L, argArray[2]];              IF modulo < 5 THEN                TmLabel.Constrain[argArray[1], argArray[1], offset1, modulo];              END            ELSE TmLabel.Constrain[argArray[1], argArray[1], 1, modulo];          IF Inline.BITAND[offset1, 2] # 0 THEN TmLabel.canceledBr2 ¬ TRUE;          END;        disp2 =>          BEGIN          TmLabel.masked ¬ 3;          andMask ¬ TmLabel.maxNumMI - 4;          myS ¬ MyString[0, argArray[2]];          IF mynumArgs = 2 THEN            orMask ¬ GetValue[              TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]];          END;        disp3 =>          BEGIN          TmLabel.masked ¬ 3;          andMask ¬ TmLabel.maxNumMI - 8;          myS ¬ MyString[0, argArray[2]];          IF mynumArgs = 2 THEN            orMask ¬ GetValue[              TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]];          END;        ret, disp4 =>          BEGIN          TmLabel.masked ¬ 3;          andMask ¬ TmLabel.maxNumMI - 16;          myS ¬ MyString[0, argArray[2]];          IF mynumArgs = 2 THEN            orMask ¬ GetValue[              TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]];          END;        dispni => BEGIN andMask ¬ TmLabel.maxNumMI - 256; END;        gotoabs =>          BEGIN	  et: ElementRec;          myS ¬ MyString[0, argArray[1]];	  et ¬ TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]];	  WITH et SELECT FROM            variable, constant => andMask ¬ GetValue[et];            label => andMask ¬ value;            ENDCASE => TmFile.LogErrAndSrcLines["Illegal argument for GOTOABS"L];          argArray[1].length ¬ 0;          END;        ENDCASE;      IF Inline.BITAND[orMask, andMask] # 0 THEN        TmFile.LogErrAndSrcLines["DISP mask conflicts with DISP size"L];      IF Inline.BITAND[orMask, 2] # 0 THEN TmLabel.canceledBr2 ¬ TRUE;      IF type # goto THEN TmLabel.canceledBr ¬ TRUE;      IF NOT noSetDest THEN TmLabel.SetDest[argArray[1], andMask, orMask];      END;        RETURN[RetType[Null[]]];    END;  BuildLabelSTEntry: PROCEDURE [var: LONG STRING, val: CARDINAL]    RETURNS [mptr: MEntryPtr] =    --build label entry for symbol table.  used only for SetLabel. check to make sure label value isn't bigger than bank size.    BEGIN    str1: LONG STRING;    etptr: LONG POINTER TO label ElementRec ¬ Heap.MakeNode[      TmModule.MTtempHeap,      SIZE[label ElementRec] + SIZE[MEntry] + String.WordsForString[var.length]];    mptr ¬ LOOPHOLE[etptr + SIZE[label ElementRec]];    str1 ¬ LOOPHOLE[mptr + SIZE[MEntry]];    str1­ ¬ StringBody[maxlength: var.length, length: 0, text:];    String.AppendString[str1, var];    IF val NOT IN [0..TmLabel.maxNumMI) THEN {      TmFile.LogErrAndSrcLines["Invalid SetLabel value"L]; val ¬ 0};    etptr­ ¬ ElementRec[label[str1, val]];    mptr­ ¬ MEntry[str1, etptr, NIL];    END;  -- end BuildLabelSTEntry  BuildMacroSTEntry: PROCEDURE [mac: LONG STRING, exp: LONG STRING]    RETURNS [mptr: MEntryPtr] =    BEGIN    str1: LONG STRING;    str2: LONG STRING;    etptr: LONG POINTER TO userMacro ElementRec ¬ Heap.MakeNode[      TmModule.MTtempHeap,      SIZE[userMacro ElementRec] + SIZE[MEntry] + String.WordsForString[        mac.length] + String.WordsForString[exp.length]];    mptr ¬ LOOPHOLE[etptr + SIZE[userMacro ElementRec]];    str1 ¬ LOOPHOLE[mptr + SIZE[MEntry]];    str2 ¬ LOOPHOLE[str1 + String.WordsForString[mac.length]];    str1­ ¬ StringBody[maxlength: mac.length, length: 0, text:];    str2­ ¬ StringBody[maxlength: exp.length, length: 0, text:];    String.AppendString[str1, mac];    String.AppendString[str2, exp];    etptr­ ¬ ElementRec[userMacro[str2]];    mptr­ ¬ MEntry[str1, etptr, NIL];    END;  -- end BuildMacroSTEntry  BuildRegSTEntry: PROCEDURE [name: LONG STRING, rt: RegisterType, val: INTEGER]    RETURNS [mptr: MEntryPtr] =    BEGIN    str1: LONG STRING;    etptr: LONG POINTER TO ElementRec ¬ Heap.MakeNode[      TmModule.MTtempHeap,      SIZE[register ElementRec] + SIZE[MEntry] + String.WordsForString[        name.length]];    mptr ¬ LOOPHOLE[etptr + SIZE[register ElementRec]];    str1 ¬ LOOPHOLE[mptr + SIZE[MEntry]];    str1­ ¬ StringBody[maxlength: name.length, length: 0, text:];    String.AppendString[str1, name];    SELECT rt FROM      R =>        BEGIN        IF val NOT IN [0..16) THEN          TmFile.LogErrArgAndSrcLines["R register not in 0..15"L, name];        etptr­ ¬ ElementRec[register[R, Inline.BITAND[15, val]]];        END;      RH =>        BEGIN        IF val NOT IN [0..16) THEN          TmFile.LogErrArgAndSrcLines["RH register not in 0..15"L, name];        etptr­ ¬ ElementRec[register[RH, Inline.BITAND[15, val]]];        END;      U =>        BEGIN        IF val NOT IN [0..256) THEN          TmFile.LogErrArgAndSrcLines["U register not in 0..255"L, name];        etptr­ ¬ ElementRec[register[U, Inline.BITAND[255, val]]];        END;      UY =>        BEGIN        IF val NOT IN [0..16) THEN          TmFile.LogErrArgAndSrcLines["UY register not in 0..15"L, name];        etptr­ ¬ ElementRec[register[UY, Inline.BITAND[15, val]]];        END;      ENDCASE;    mptr­ ¬ MEntry[str1, etptr, NIL];    END;  -- end BuildRegSTEntry  BuildVarSTEntry: PROCEDURE [var: LONG STRING, val: INTEGER]    RETURNS [mptr: MEntryPtr] =    BEGIN    str1: LONG STRING;    etptr: LONG POINTER TO variable ElementRec ¬ Heap.MakeNode[      TmModule.MTtempHeap,      SIZE[variable ElementRec] + SIZE[MEntry] + String.WordsForString[        var.length]];    mptr ¬ LOOPHOLE[etptr + SIZE[variable ElementRec]];    str1 ¬ LOOPHOLE[mptr + SIZE[MEntry]];    str1­ ¬ StringBody[maxlength: var.length, length: 0, text:];    String.AppendString[str1, var];    etptr­ ¬ ElementRec[variable[val]];    mptr­ ¬ MEntry[str1, etptr, NIL];    END;  -- end BuildVarSTEntry  External: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    i: CARDINAL;    mynumArgs: CARDINAL ¬ TmControl.numArgs;    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    TmModule.SaveArgs[@argArray, mynumArgs];    FOR i IN [1..mynumArgs] DO      TmLabel.ProcessExternal[type, argArray[i]]; ENDLOOP;        RETURN[RetType[Null[]]];    END;  -- end External  GetValue: PROCEDURE [et: ElementRec] RETURNS [value: INTEGER] =    BEGIN    WITH et SELECT FROM      constant => RETURN[value];      variable => RETURN[val];      ENDCASE =>        BEGIN        TmFile.LogErrAndSrcLines["Invalid argument: numeric value expected"L];        RETURN[0];        END;    END;  -- end GetValue  If: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    myS, myS1, myS2: MyString;    mynumArgs: CARDINAL ¬ TmControl.numArgs;    val1, val2: INTEGER;    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    TmModule.SaveArgs[@argArray, mynumArgs];    IF TmControl.numArgs NOT IN [3..4] THEN      TmFile.LogErrAndSrcLines["Wrong number of args for if type macro"L];    myS1 ¬ [0, argArray[1]];    myS2 ¬ [0, argArray[2]];    val1 ¬ GetValue[TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS1]]];    val2 ¬ GetValue[TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS2]]];    myS ¬      SELECT type FROM        equal => IF val1 = val2 THEN [0, argArray[3]] ELSE [0, argArray[4]],        greater => IF val1 > val2 THEN [0, argArray[3]] ELSE [0, argArray[4]],        andZero =>          IF Inline.BITAND[val1, val2] = 0 THEN [0, argArray[3]]          ELSE [0, argArray[4]],        ENDCASE => [0, NIL];    IF myS.String # NIL THEN      BEGIN      String.AppendChar[myS.String, ',];      UNTIL myS.String.length <= myS.NextChar DO        TmModule.InterpretMain[TmModule.BreakPhraseMain[@myS]] ENDLOOP;      END;        END;  -- end If  InitMacroTable: PUBLIC PROCEDURE =    BEGIN    -- insert builtin's    AddBuiltin["Add"L, 0, add];    AddBuiltin["And"L, 0, and];    AddBuiltin["Mul"L, 0, mul];    AddBuiltin["Or"L, 0, or];    AddBuiltin["Xor"L, 0, xor];    AddBuiltin["Lshift"L, 1, lshift];    AddBuiltin["Rshift"L, 1, rshift];    AddBuiltin["Sub"L, 1, sub];    AddBuiltin["GOTO"L, 2, goto];    AddBuiltin["CALL"L, 2, goto];    AddBuiltin["GOTOABS"L, 2, gotoabs];    AddBuiltin["BRANCH"L, 2, branch];    AddBuiltin["CANCELBR"L, 2, cancelbr];    AddBuiltin["DISP2"L, 2, disp2];    AddBuiltin["DISP3"L, 2, disp3];    AddBuiltin["DISP4"L, 2, disp4];    AddBuiltin["DISPNI"L, 2, dispni];    AddBuiltin["RET"L, 2, ret];    AddBuiltin["IfEqual"L, 3, equal];    AddBuiltin["IfGreater"L, 3, greater];    AddBuiltin["IfAndZero"L, 3, andZero];    AddBuiltin["Set"L, 4, setConstant];    AddBuiltin["SetLabel"L, 4, setLabel];    AddBuiltin["PrintVar"L, 5, null];    AddBuiltin["MacroDef"L, 6, null];    AddBuiltin["RegDef"L, 7, null];    AddBuiltin["IMPORT"L, 8, import];    AddBuiltin["EXPORT"L, 8, export];    AddBuiltin["at"L, 9, null];    AddBuiltin["Reserve"L, 10, null];    AddBuiltin["Print"L, 11, null];    AddBuiltin["SetTask"L, 12, null];    AddBuiltin["StartAddress"L, 13, null];    AddBuiltin["SkipTo"L, 14, null];    AddBuiltin["LOOPHOLE"L, 15, null];    AddSTEntry["¬"L, ElementRec[arrow[]], SIZE[arrow ElementRec]];    AddSTEntry["+"L, ElementRec[plus[]], SIZE[plus ElementRec]];    AddSTEntry["-"L, ElementRec[minus[]], SIZE[minus ElementRec]];    AddSTEntry[""L, ElementRec[minus[]], SIZE[minus ElementRec]];    AddSTEntry["~"L, ElementRec[not[]], SIZE[not ElementRec]];    AddSTEntry["and"L, ElementRec[logical[and]], SIZE[logical ElementRec]];    AddSTEntry["or"L, ElementRec[logical[or]], SIZE[logical ElementRec]];    AddSTEntry["xor"L, ElementRec[logical[xor]], SIZE[logical ElementRec]];    AddSTEntry["PC16"L, ElementRec[pc16[]], SIZE[pc16 ElementRec]];    AddSTEntry[      "Cin¬"L, ElementRec[partialArrow[]], SIZE[partialArrow ElementRec]];    AddSTEntry["SE¬"L, ElementRec[partialArrow[]], SIZE[partialArrow ElementRec]];    AddSTEntry[      "fXCin¬"L, ElementRec[partialArrow[]], SIZE[partialArrow ElementRec]];    AddSTEntry[      "IBPtr¬"L, ElementRec[partialArrow[]], SIZE[partialArrow ElementRec]];    AddSTEntry[      "pc16"L, ElementRec[partialArrow[]], SIZE[partialArrow ElementRec]];    AddSTEntry["Q"L, ElementRec[register[Q, 0]], SIZE[register ElementRec]];    AddSTEntry["STK"L, ElementRec[register[STK, 0]], SIZE[register ElementRec]];    AddSTEntry["MD"L, ElementRec[register[MD, 0]], SIZE[register ElementRec]];    AddSTEntry["[]"L, ElementRec[register[bus, 0]], SIZE[register ElementRec]];    AddSTEntry["cycle2"L, ElementRec[constant[14]], SIZE[constant ElementRec]];    AddSTEntry["XNeg"L, ElementRec[constant[1]], SIZE[constant ElementRec]];    AddSTEntry["XOdd"L, ElementRec[constant[2]], SIZE[constant ElementRec]];    AddSTEntry["XLowNeg"L, ElementRec[constant[1]], SIZE[constant ElementRec]];    AddSTEntry["YOdd"L, ElementRec[constant[14]], SIZE[constant ElementRec]];    AddSTEntry["CSParErr"L, ElementRec[constant[7]], SIZE[constant ElementRec]];    AddSTEntry["Config"L, ElementRec[variable[TmControl.config]], SIZE[constant ElementRec]];    AddSTEntry["Style"L, ElementRec[variable[0]], SIZE[constant ElementRec]];    END;  LoopHole: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    mynumArgs: CARDINAL ¬ TmControl.numArgs;    TmModule.SaveArgs[@argArray, mynumArgs];    IF TmControl.numArgs # 1 THEN      TmFile.LogErrAndSrcLines["Wrong number of args for LOOPHOLE"L];    SELECT TRUE FROM      String.EqualString[argArray[1], "wok"L] => TmLabel.wok ¬ TRUE;      String.EqualString[argArray[1], "stw"L] => TmLabel.stw ¬ TRUE;      String.EqualString[argArray[1], "mdok"L] => TmLabel.mdok ¬ TRUE;      String.EqualString[argArray[1], "mdrok"L] => TmLabel.mdrok ¬ TRUE;      String.EqualString[argArray[1], "natc"L] => TmLabel.natc ¬ TRUE;      String.EqualString[argArray[1], "niblTiming"L] => TmLabel.niblTiming ¬ TRUE;      String.EqualString[argArray[1], "byteTiming"L] => TmLabel.byteTiming ¬ TRUE;      String.EqualString[argArray[1], "pci"L] => TmLabel.pci ¬ TRUE;      ENDCASE => TmFile.LogErrAndSrcLines["Unknown argument to LOOPHOLE"L];        RETURN[RetType[Null[]]];    END;  -- end MacroDef  MacroDef: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    mptr: MEntryPtr;    mynumArgs: CARDINAL ¬ TmControl.numArgs;    TmModule.SaveArgs[@argArray, mynumArgs];    IF TmControl.numArgs # 2 THEN      TmFile.LogErrAndSrcLines["Wrong number of args for MacroDef"L];    mptr ¬ BuildMacroSTEntry[argArray[1], argArray[2]];    IF TmModule.InsertM[mptr] THEN      TmFile.LogErrArgAndSrcLines["Macro already defined"L, argArray[1]];        RETURN[RetType[Null[]]];    END;  -- end MacroDef  PrintString: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    mynumArgs: CARDINAL ¬ TmControl.numArgs;    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    TmModule.SaveArgs[@argArray, mynumArgs];    TmFile.LogLine[argArray[1]];        RETURN[RetType[Null[]]];    END;  -- end PrintString  PrintVar: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    msg: LONG STRING ¬ [maxArgLength];    myS: MyString;    mynumArgs: CARDINAL ¬ TmControl.numArgs;        et: ElementRec;    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    TmModule.SaveArgs[@argArray, mynumArgs];    IF TmControl.numArgs > 1 THEN      TmFile.LogErrAndSrcLines["Too many args for PrintVar"L];    String.AppendString[msg, argArray[1]];    String.AppendString[msg, " = "L];    myS ¬ [0, argArray[1]];    et ¬ TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]];        WITH et SELECT FROM      variable =>        BEGIN        String.AppendNumber[msg, val, 8];        String.AppendChar[msg, Ascii.CR];        END;      ENDCASE => RETURN[RetType[Error[]]];                            TmFile.LogLine[msg];        RETURN[RetType[Null[]]];    END;  -- end PrintVar  RegDef: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    myS: MyString;    val: INTEGER;    mptr: MEntryPtr;    regtype: RegisterType;    mynumArgs: CARDINAL ¬ TmControl.numArgs;    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    TmModule.SaveArgs[@argArray, mynumArgs];    IF TmControl.numArgs # 3 THEN      TmFile.LogErrAndSrcLines["RegDef requires 3 args"L];    IF argArray[2].length > 2 THEN      TmFile.LogErrArgAndSrcLines[        "Illegal register type in RegDef, R assumed"L, argArray[2]];    regtype ¬      SELECT argArray[2][0] FROM        'R, 'r =>          IF argArray[2].length = 1 THEN R          ELSE IF argArray[2][1] = 'H OR argArray[2][1] = 'h THEN RH ELSE Q,        'U, 'u =>          IF argArray[2].length = 1 THEN U          ELSE IF argArray[2][1] = 'Y OR argArray[2][1] = 'y THEN UY ELSE Q,        ENDCASE => Q;    IF regtype = Q THEN      BEGIN      regtype ¬ R;      TmFile.LogErrArgAndSrcLines[        "Illegal register type in RegDef, R assumed"L, argArray[2]];      END;    myS ¬ [0, argArray[3]];    val ¬ GetValue[TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]];    mptr ¬ BuildRegSTEntry[argArray[1], regtype, val];    IF TmModule.InsertM[mptr] THEN      TmFile.LogErrArgAndSrcLines["Register name already defined"L, argArray[1]];        RETURN[RetType[Null[]]];    END;  -- end RegDef  Reserve: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    myS: MyString;    low, high: INTEGER;    mynumArgs: CARDINAL ¬ TmControl.numArgs;    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    TmModule.SaveArgs[@argArray, mynumArgs];    IF TmControl.numArgs NOT IN [1..2] THEN      BEGIN      TmFile.LogErrAndSrcLines["Reserve requires one or two args"L];            RETURN[RetType[Null[]]];      END;    myS ¬ [0, argArray[1]];    low ¬ GetValue[TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]];    IF mynumArgs = 2 THEN      BEGIN      myS ¬ [0, argArray[2]];      high ¬ GetValue[TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]];      TmLabel.ProcessReserve[low, high];      END    ELSE TmLabel.ProcessReserve[low, low];        RETURN[RetType[Null[]]];    END;  -- end RegDef  Set: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    value: INTEGER;    myS: MyString;    mptr: MEntryPtr;    mynumArgs: CARDINAL ¬ TmControl.numArgs;    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    et: ElementRec;    TmModule.SaveArgs[@argArray, mynumArgs];    IF mynumArgs # 2 THEN      BEGIN      TmFile.LogErrAndSrcLines["Set requires two args"L];            RETURN[RetType[Null[]]];      END;    myS ¬ [0, argArray[2]];    value ¬ GetValue[TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]];    myS ¬ [0, argArray[1]];    et ¬ TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]];    IF type = setConstant THEN          WITH et SELECT FROM	variable =>	  BEGIN	  mptr ¬ TmModule.FindM[argArray[1]];	  mptr­.ptr­ ¬ ElementRec[variable[value]];	  END;	undefinedToken =>	  BEGIN	  mptr ¬ BuildVarSTEntry[argArray[1], value];	  [] ¬ TmModule.InsertM[mptr];	  END;	ENDCASE => RETURN[RetType[Error[]]]      ELSE        WITH et SELECT FROM        undefinedToken =>          BEGIN          mptr ¬ BuildLabelSTEntry[argArray[1], value];          [] ¬ TmModule.InsertM[mptr];          END;        ENDCASE => {	  TmFile.LogErrAndSrcLines["Label already defined"L];	  RETURN[RetType[Error[]]]};      RETURN[RetType[Null[]]];    END;  -- end Set  SetTask: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    value: INTEGER;    myS: MyString;    mynumArgs: CARDINAL ¬ TmControl.numArgs;    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    TmModule.SaveArgs[@argArray, mynumArgs];    IF TmControl.numArgs # 1 THEN      TmFile.LogErrAndSrcLines["SetTask requires one arg"L];    myS ¬ [0, argArray[1]];    value ¬ GetValue[TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]];    IF value > 7 THEN TmFile.LogErrAndSrcLines["Task must be less than 8"L];    TmControl.curTask ¬ value MOD 8;        RETURN[RetType[Null[]]];    END;  -- end SetTask  SkipTo: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    mynumArgs: CARDINAL ¬ TmControl.numArgs;    TmModule.SaveArgs[@argArray, mynumArgs];    IF TmControl.numArgs # 1 THEN      TmFile.LogErrAndSrcLines["SkipTo requires one arg"L];    TmModule.SkipUntil[argArray[1]];    TmControl.ifsInThisFile ¬ TRUE;  -- force .si to be deleted        RETURN[RetType[Null[]]];    END;  -- end SetTask  StartAddress: PROCEDURE [type: BuiltinMacroType] RETURNS [ret: RetType] =    BEGIN    myS: MyString;    value: INTEGER ¬ 0;    mynumArgs: CARDINAL ¬ TmControl.numArgs;    argArray: ARRAY [0..TmAssembler.sizeArgArray] OF LONG STRING ¬ ALL[NIL];    TmModule.SaveArgs[@argArray, mynumArgs];    IF TmControl.numArgs NOT IN [1..2] THEN      TmFile.LogErrAndSrcLines["StartAddress requires one or two args"L];    IF TmControl.numArgs = 2 THEN      BEGIN      myS ¬ [0, argArray[2]];      value ¬ GetValue[TmModule.InterpretArg[TmModule.BreakPhraseArg[@myS]]];      END;    TmLabel.ProcSA[argArray[1], value];        RETURN[RetType[Null[]]];    END;  -- end StartAddress  END...    -- LOG      -- 17-Jul-82 19:43:12 - ETN        - TrinityMass Version 1  -- 30-Jun-83 13:57:07 - JAC        - InterpretArg returns ElementRec  -- 12-Jul-83 14:07:46 - JAC        - Eliminate use of tempHeap  -- 12-Aug-83 15:04:48 - JAC        - replace errorsInThisFile with ifsInThisFile in SkipTo  -- Time: 26-Sep-84 21:02:08	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.  --  6-Nov-85 15:35:57 - JAC        - added the macro SetLabel to aid in bank switching
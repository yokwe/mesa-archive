-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TmMergeImpl.mesa.-- Last edit: DEG        26-Sep-84 20:50:37 -- Last edit: ETN     16-Jul-82 13:30:36 -- The purpose of this module is to merge the Encoding records associated with each Phrase of a statement into a single Encoding record.  Each Phrase will have at least one Encoding record.  A Phrase will have more than one Encoding record if there is more than one possible encoding of the Phrase.    DIRECTORY  TmFile USING [LogErrAndSrcLines],  TmAssembler;TmMergeImpl: PROGRAM IMPORTS TmFile, TmAssembler EXPORTS TmAssembler =  BEGIN OPEN TmAssembler;  -- GLOBAL VARIABLES  -- SIGNALS AND ERRORS GENERATED  MergeError: ERROR [{aDinvalid, aluInInvalid, operationInvalid}] = CODE;  ArithmeticOperation: PUBLIC PROCEDURE [operation: CARDINAL]    RETURNS [arithmetic: BOOLEAN] =    BEGIN    arithmetic ¬      SELECT operation FROM        IN [0..2] => TRUE,        IN [3..7] => FALSE,        ENDCASE => ERROR MergeError[operationInvalid];    RETURN;    END;    MergeEncoding: PROCEDURE [    phrase: PhrasePtr, mergedEncoding: EncodingPtr, trialEncoding: EncodingPtr]    RETURNS [successful: BOOLEAN] =    BEGIN    -- Attempt to merge trialEncoding into mergedEncoding.  Return TRUE if all fields can be merged.  If any format errors are encountered, a Field procedure will create an error message and chain it onto phrase.tempErrorMsgs.  These error messages can be printed later if no encoding can be successfully merged.     oldFA, newFA: FieldAssignment;    text: LONG STRING;    Field: PROCEDURE = INLINE      BEGIN      IF oldFA.assignment.type # null THEN        IF newFA.value # oldFA.value THEN          BEGIN          FormatError[phrase, newFA.assignment, oldFA.assignment, text];          successful ¬ FALSE;          END;      END;  -- end Field    successful ¬ TRUE;  -- assume successful    IF trialEncoding.rA.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.rA;      newFA ¬ trialEncoding.rA;      text ¬ "rA"L;      Field[];      mergedEncoding.rA ¬ newFA;      END;    IF trialEncoding.rB.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.rB;      newFA ¬ trialEncoding.rB;      text ¬ "rB"L;      Field[];      mergedEncoding.rB ¬ newFA;      END;    IF trialEncoding.aS.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.aS;      newFA ¬ trialEncoding.aS;      text ¬ "aS"L;      Field[];      mergedEncoding.aS ¬ newFA;      END;    IF trialEncoding.aF.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.aF;      newFA ¬ trialEncoding.aF;      text ¬ "aF"L;      Field[];      mergedEncoding.aF ¬ newFA;      END;    IF trialEncoding.aD.assignment.type # null THEN      IF NOT FieldaD[        phrase, mergedEncoding, trialEncoding.aD.assignment,        trialEncoding.aD.value] THEN successful ¬ FALSE;    IF trialEncoding.cin.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.cin;      newFA ¬ trialEncoding.cin;      text ¬ "cin"L;      Field[];      mergedEncoding.cin ¬ newFA;      END;    IF trialEncoding.enSU.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.enSU;      newFA ¬ trialEncoding.enSU;      text ¬ "enSU"L;      Field[];      mergedEncoding.enSU ¬ newFA;      END;    IF trialEncoding.mem.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.mem;      newFA ¬ trialEncoding.mem;      text ¬ "mem"L;      Field[];      mergedEncoding.mem ¬ newFA;      END;    IF trialEncoding.ia7.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.ia7;      newFA ¬ trialEncoding.ia7;      text ¬ "ia7"L;      Field[];      mergedEncoding.ia7 ¬ newFA;      END;    IF trialEncoding.cy.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.cy;      newFA ¬ trialEncoding.cy;      text ¬ "cy"L;      Field[];      mergedEncoding.cy ¬ newFA;      END;    IF trialEncoding.fS01.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.fS01;      newFA ¬ trialEncoding.fS01;      text ¬ "fS01"L;      Field[];      mergedEncoding.fS01 ¬ newFA;      END;    IF trialEncoding.fS2.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.fS2;      newFA ¬ trialEncoding.fS2;      text ¬ "fS2"L;      Field[];      mergedEncoding.fS2 ¬ newFA;      END;    IF trialEncoding.fS3.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.fS3;      newFA ¬ trialEncoding.fS3;      text ¬ "fS3"L;      Field[];      mergedEncoding.fS3 ¬ newFA;      END;    IF trialEncoding.fX.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.fX;      newFA ¬ trialEncoding.fX;      text ¬ "fX"L;      Field[];      mergedEncoding.fX ¬ newFA;      END;    IF trialEncoding.fY.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.fY;      newFA ¬ trialEncoding.fY;      text ¬ "fY"L;      Field[];      mergedEncoding.fY ¬ newFA;      END;    IF trialEncoding.fZ.assignment.type # null THEN      BEGIN      oldFA ¬ mergedEncoding.fZ;      newFA ¬ trialEncoding.fZ;      text ¬ "fZ"L;      Field[];      mergedEncoding.fZ ¬ newFA;      END;    mergedEncoding.wU ¬ trialEncoding.wU OR mergedEncoding.wU;    mergedEncoding.xIn ¬ trialEncoding.xIn OR mergedEncoding.xIn;    mergedEncoding.yIn ¬ trialEncoding.yIn OR mergedEncoding.yIn;    mergedEncoding.yOut ¬ trialEncoding.yOut OR mergedEncoding.yOut;    mergedEncoding.aluIn ¬ trialEncoding.aluIn OR mergedEncoding.aluIn;    mergedEncoding.aluOut ¬ trialEncoding.aluOut OR mergedEncoding.aluOut;    mergedEncoding.assignBrequired ¬ trialEncoding.assignBrequired      OR mergedEncoding.assignBrequired;    mergedEncoding.assignB ¬ trialEncoding.assignB OR mergedEncoding.assignB;    SELECT trialEncoding.RHref FROM      x => NULL;      r =>        IF mergedEncoding.RHref = w THEN          BEGIN successful ¬ FALSE; MultipleReference[phrase, "RH"L]; END        ELSE mergedEncoding.RHref ¬ r;      w =>        IF mergedEncoding.RHref = r THEN          BEGIN successful ¬ FALSE; MultipleReference[phrase, "RH"L]; END        ELSE mergedEncoding.RHref ¬ w;      ENDCASE;    IF trialEncoding.xOut THEN mergedEncoding.xOut ¬ TRUE;    RETURN;    END;  MergePhraseEncoding: PROCEDURE [phrase: PhrasePtr, mergedEncoding: EncodingPtr]    RETURNS [successful: BOOLEAN] =    BEGIN    -- Attempt to merge the Encoding of the phrase into the merged Encoding record.  Start with the first Encoding record for the Phrase.  If that doesn't work, try each successive Encoding record.  Return FALSE if none work.    trialEncoding: EncodingPtr;    nextPhrase: PhrasePtr;    savedEncoding: Encoding;    value: CARDINAL;    savedEncoding ¬ mergedEncoding­;  -- Save the merged Encoding so that we can restore it if this trial doesn't work.    trialEncoding ¬ phrase.encoding;  -- Try the first Encoding for this Phrase.  If this doesn't work, try the next Encoding for the Phrase, if there is one.    successful ¬ TRUE;  -- Assume this is going to work.    DO      IF MergeEncoding[phrase, mergedEncoding, trialEncoding] THEN        BEGIN  -- The Encoding of the current Phrase has been merged.        IF (nextPhrase ¬ phrase.nextPhrase) = NIL THEN          BEGIN          -- Every Phrase in the Statement has been merged.  Now check and see if the bus signals work out.  If there is an input required from the X bus, then there must be a signal on that bus.          IF mergedEncoding.xOut THEN            IF NOT mergedEncoding.xIn THEN              BEGIN successful ¬ FALSE; BusMismatch[phrase, "X bus"L]; END;          IF mergedEncoding.xIn THEN            IF NOT mergedEncoding.xOut THEN              BEGIN successful ¬ FALSE; BusMismatch[phrase, "X bus"L]; END;          IF mergedEncoding.yIn THEN            IF NOT mergedEncoding.yOut THEN              BEGIN successful ¬ FALSE; BusMismatch[phrase, "Y bus"L]; END;          IF mergedEncoding.yOut THEN            IF NOT (mergedEncoding.yIn OR mergedEncoding.aluIn) THEN              BEGIN successful ¬ FALSE; BusMismatch[phrase, "Y bus"L]; END;          IF mergedEncoding.aluIn THEN            IF NOT mergedEncoding.aluOut THEN              BEGIN successful ¬ FALSE; BusMismatch[phrase, "ALU"L]; END;          IF mergedEncoding.assignBrequired THEN            IF NOT mergedEncoding.assignB THEN              BEGIN              -- If the instruction puts A on the Y Bus (aD = 2), the output of the ALU is assigned to register B.  If aD = 2 and the statement does not assign anything to rB, it will be destroyed.              successful ¬ FALSE;              AssignBrequired[phrase];              END;          IF mergedEncoding.xOut THEN            BEGIN            value ¬ XBusCheck[mergedEncoding];            IF value > 1 THEN              BEGIN successful ¬ FALSE; BusConflict[phrase, "X bus"L]; END;            IF value < 1 THEN              BEGIN successful ¬ FALSE; BusMismatch[phrase, "X bus"L]; END;            END;          IF NOT mergedEncoding.wU THEN            IF (mergedEncoding.enSU.value = 1 AND mergedEncoding.cin.value = 1)              THEN BEGIN successful ¬ FALSE; WriteUConflict[phrase]; END;          IF successful THEN            IF NOT GetTiming[mergedEncoding] THEN              TmFile.LogErrAndSrcLines["WARNING: statement has timing error"L];          IF successful THEN RETURN;          IF (trialEncoding ¬ trialEncoding.nextEncoding) = NIL THEN            RETURN[FALSE];          -- set up for another try          mergedEncoding­ ¬ savedEncoding;          successful ¬ TRUE;          LOOP;          END;  -- of every Phrase in the Statement has been merged.        -- The Encoding of the current Phrase has been merged, and there is another Phrase in the Statement.  Call MergePhrase recursively, pointing to the next Phrase in the statement.        IF MergePhraseEncoding[nextPhrase, mergedEncoding] THEN RETURN;        END;  -- of current Phrase has been merged      -- The current Encoding for the Phrase did not work.  Restore the merged Encoding to what it was before this trial.        mergedEncoding­ ¬ savedEncoding;      -- See if there is another Encoding for this Phrase.  If not, this Phrase cannot be Encoded.  This does not necessarily mean the Statement cannot be Encoded.  If we back up, we may be able to encode a previous Phrase differently.      IF (trialEncoding ¬ trialEncoding.nextEncoding) = NIL THEN RETURN[FALSE];      ENDLOOP;    END;  MergeStatementEncoding: PUBLIC PROCEDURE [statement: StatementPtr]    RETURNS [successful: BOOLEAN] =    BEGIN    -- Create a single Encoding record by merging the Encoding records from each Phrase in the statement.  If any errors are detected, error messages will be queued on phrase.errorMsgs.    mergedEncoding: EncodingPtr;    mergedEncoding ¬ TmAssembler.AllocateEncodingRecord[];    statement.encoding ¬ mergedEncoding;    successful ¬ MergePhraseEncoding[statement.firstPhrase, mergedEncoding];    -- We now have a merged Encoding record.    -- The aD field needs to be fixed up.  If the value is greater than 3, the high order bit is represented by the fX field.    SELECT mergedEncoding.aD.value FROM      IN [0..3] => NULL;      IN [4..7] => mergedEncoding.aD.value ¬ mergedEncoding.aD.value - 4;      ENDCASE => ERROR MergeError[aDinvalid];    RETURN;    END;  XBusCheck: PROCEDURE [encoding: EncodingPtr] RETURNS [count: CARDINAL] =    BEGIN    enSU: CARDINAL ¬ encoding.enSU.value;    fS01: CARDINAL ¬ encoding.fS01.value;    fS2: CARDINAL ¬ encoding.fS2.value;    fS3: CARDINAL ¬ encoding.fS3.value;    fY: CARDINAL ¬ encoding.fY.value;    fZ: CARDINAL ¬ encoding.fZ.value;    count ¬ 0;    IF fS01 = fS01IOOut AND (fY = 11 OR fY = 14) THEN  -- The signal source is IOIn.      count ¬ count + 1;    IF fS2 = fS2IOIn AND fS3 = fS3IOIn THEN  -- The signal source is IOIn.      count ¬ count + 1;    IF fS2 = fS2fZNorm AND fS3 = fS3fZNorm AND fZ IN [fZLRotLo..fZLRotHi] THEN  -- The signal source is LRot      count ¬ count + 1;    IF fS2 = fS2nibble AND fS3 = fS3nibble THEN  -- The signal source is nibble or byte      count ¬ count + 1;    IF enSU = 1 AND encoding.cin.value = 0 THEN  -- The signal source is U Register      count ¬ count + 1;    IF encoding.cy.value = 3 AND encoding.mem.value = 1 THEN  -- The signal source is MD      count ¬ count + 1;    END;  -- end XBusCheck  -- MAIN LINE CODE  END...    -- Log:  -- 16-Jul-82 13:31:12 - ETN        - TrinityMass Version 1  -- Time: 26-Sep-84 20:50:28	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
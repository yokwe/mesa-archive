-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- ReadAMFile.mesa-- Created by DEG     .PA @ 15-Feb-83 10:00:04-- Last Edit by DEG     .PA @ 26-Sep-84 23:16:44DIRECTORY  Environment USING [charsPerWord],  Exec USING [AddCommand, ExecProc, FreeTokenString, GetToken, OutputProc],  Format USING [-- Char, -- LongNumber, Number, StringProc, Text],  MFile USING [ReadOnly],  MSegment USING [Address, Create, Delete, Handle],  SimHashDefs USING [Base, Hash, HashBlock, HNull, FirstAvailSlot],  Stream USING [Position];  ReadAMFile: MONITOR IMPORTS Exec, Format, MFile, MSegment =  BEGIN    HBase: TYPE = SimHashDefs.Base;  Hash: TYPE = SimHashDefs.Hash;  HNull: Hash ¬ SimHashDefs.HNull;    FirstAvailSlot: Hash ¬ SimHashDefs.FirstAvailSlot;    HashTableOffsetInAM: CARDINAL = 3;    RealAddress: TYPE = CARDINAL;  SymbolicAddress: TYPE = RECORD [    symbol: Hash,    offset: CARDINAL];    AMBase: TYPE = LONG BASE POINTER TO AMRegion;  AMPtr: TYPE = AMBase RELATIVE ORDERED POINTER TO AMEntry;  AMEntry: TYPE = RECORD [    symbolicAddress: SymbolicAddress,    realAddress: RealAddress,    fileNumber: CARDINAL,    streamIndexHigh, streamIndexLow: CARDINAL];  AMRegion: TYPE = RECORD [ARRAY [0..0) OF AMEntry];  AMNull: AMPtr = LOOPHOLE[0];    ULBase: TYPE = LONG BASE POINTER TO ULRegion;  ULPtr: TYPE = ULBase RELATIVE ORDERED POINTER TO ULEntry;  ULEntry: TYPE = RECORD [    dummy: WORD,    hash: Hash,    useListEntry: ARRAY [0..0) OF ULBlock];  ULRegion: TYPE = RECORD [ARRAY [0..0) OF ULEntry];  ULBlock: TYPE = RECORD [    size: CARDINAL,    address: CARDINAL];      ULNull: ULPtr = LOOPHOLE[0];    hashTable: HBase ¬ NIL;  hash: Hash ¬ FirstAvailSlot;    lastEntry: CARDINAL = 177777B;   addressMap: AMBase ¬ NIL;  addressMapEntry: AMPtr ¬ AMNull;  anAMPtr: AMPtr ¬ AMNull;    useList: ULBase ¬ NIL;  useListEntry: ULPtr ¬ ULNull;  anULPtr: ULPtr ¬ ULNull;      segmentHandle: MSegment.Handle ¬ NIL;  name, switches: LONG STRING ¬ NIL;    DumpAMFile: ENTRY Exec.ExecProc =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];        Cleanup: PROCEDURE = {      name ¬ Exec.FreeTokenString[name];      switches ¬ Exec.FreeTokenString[switches]};        DO      ENABLE UNWIND => {Cleanup[]};            [name , switches] ¬ Exec.GetToken[h];      IF name = NIL AND switches = NIL THEN EXIT;      segmentHandle ¬ MSegment.Create[file: MFile.ReadOnly[name: name, release: []], release: []];      [addressMap, useList, hashTable] ¬ GetBasePointers[];      PrintAddressMap[Write: Write];      PrintUseList[Write: Write];      PrintHashTable[Write: Write];      MSegment.Delete[segment: segmentHandle];    ENDLOOP;    Cleanup[];    END;      GetBasePointers: PROCEDURE[] RETURNS[addressMap: AMBase, useList: ULBase, hashTable: HBase] =    BEGIN      addressMap ¬ MSegment.Address[segment: segmentHandle];      anAMPtr ¬ AMNull;      UNTIL addressMap[anAMPtr].symbolicAddress.symbol = LOOPHOLE[lastEntry, Hash] DO        anAMPtr ¬ anAMPtr + SIZE[AMEntry];      ENDLOOP;      useList ¬ LOOPHOLE[@addressMap[anAMPtr], ULBase];      anULPtr ¬ ULNull;      UNTIL useList[anULPtr].hash = LOOPHOLE[lastEntry, Hash] DO        count: CARDINAL ¬ 0;	UNTIL useList[anULPtr].useListEntry[count].size = lastEntry DO	  count ¬ count + 1;	ENDLOOP;        anULPtr ¬ anULPtr + SIZE[ULEntry] + count * SIZE[ULBlock];      ENDLOOP;       hashTable ¬ LOOPHOLE[@useList[anULPtr] + HashTableOffsetInAM, HBase];    END;    PrintAddressMap: PROCEDURE[Write: Format.StringProc] =    BEGIN      streamIndex: Stream.Position;      anAMPtr ¬ AMNull;      UNTIL addressMap[anAMPtr].symbolicAddress.symbol = LOOPHOLE[lastEntry, Hash] DO	Format.Text[Write, @hashTable[addressMap[anAMPtr].symbolicAddress.symbol].string];	Format.Text[Write, " + "L];	Format.Number[proc: Write, n: addressMap[anAMPtr].symbolicAddress.offset, format: []];	Format.Text[Write, " is at "L];	Format.Number[proc: Write, n: addressMap[anAMPtr].realAddress, format: [base: 16]];	Format.Text[Write, "(Hex) in file number "L];	Format.Number[proc: Write, n: addressMap[anAMPtr].fileNumber, format: []];	Format.Text[Write, " at position "L];	streamIndex ¬ 512 * addressMap[anAMPtr].streamIndexHigh + addressMap[anAMPtr].streamIndexLow;	Format.LongNumber[proc: Write, n: streamIndex, format: []];	Format.Text[Write, "\n"L];	anAMPtr ¬ anAMPtr + SIZE[AMEntry];      ENDLOOP;      Format.Text[Write, "\n"L];    END;      PrintHashTable: PROCEDURE[Write: Format.StringProc] =    BEGIN      hash ¬ FirstAvailSlot;      UNTIL hash = hashTable.nextAvail DO        IF hashTable[hash].reloc THEN Format.Text[Write, "[reloc: TRUE, "L]          ELSE Format.Text[Write, "[reloc: FALSE, "L];        Format.Text[Write, "address/value: "L];        Format.Number[proc: Write, n: hashTable[hash].ptrIndex, format: [base: 16]];        Format.Text[Write, "(Hex), label: "L];        Format.Text[Write, @hashTable[hash].string];        Format.Text[Write, "]\n"L];        hash ¬ hash + (SIZE[SimHashDefs.HashBlock] + (hashTable[hash].string.length + Environment.charsPerWord - 1)/ Environment.charsPerWord);      ENDLOOP;      Format.Text[Write, "\n"L];    END;      PrintUseList: PROCEDURE[Write: Format.StringProc] =    BEGIN      anULPtr ¬ ULNull;      UNTIL useList[anULPtr].hash = LOOPHOLE[lastEntry, Hash] DO        count: CARDINAL ¬ 0;	Format.Text[Write, @hashTable[useList[anULPtr].hash].string];	UNTIL useList[anULPtr].useListEntry[count].size = lastEntry DO      	  Format.Text[Write, "\n\tEntry #"L];	  Format.Number[proc: Write, n: count, format: []];	  Format.Text[Write, " ("L];	  IF useList[anULPtr].useListEntry[count].size = 1 THEN	    Format.Text[Write, "byte"L] ELSE Format.Text[Write, "word"L];	  Format.Text[Write, ") at address: "L];	  Format.Number[proc: Write, n: useList[anULPtr].useListEntry[count].address, format: [base: 16]];	  count ¬ count + 1;	ENDLOOP;	Format.Text[Write, "\n"L];        anULPtr ¬ anULPtr + SIZE[ULEntry] + count * SIZE[ULBlock];      ENDLOOP;      Format.Text[Write, "\n"L];    END;    ReadAMFileHelp: Exec.ExecProc =    BEGIN    Write: Format.StringProc = Exec.OutputProc[h];    Format.Text[Write, "ReadAMFile is a program to display the contents of an Address Map (*.am).\n"L];    END;    Exec.AddCommand[name: "ReadAMFile.~ "L, proc: DumpAMFile, help: ReadAMFileHelp];    END.    LOG  Created by DEG     .PA @ 15-Feb-83 10:00:04  DEG     .PA @ 28-Feb-83 12:00:54  DEG     .PA @  5-Mar-84 14:35:56	fix to make address print in HEX like it should do.  Time: 26-Sep-84 23:16:36	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
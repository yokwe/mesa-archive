-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CPLoaderBoot.mesa, HGM, 11-Oct-83 21:25:24DIRECTORY  Boot USING [bootPhysicalVolume, countGermVM, pageGerm, pRequest, Request],  BootFile USING [    currentVersion, MapEntry, Header, maxEntriesPerHeader, maxEntriesPerTrailer,    Trailer],  DeviceTypes USING [anyPilotDisk],  DLionInputOutput USING [firstMapPage, ioPageNumber, ioPageRealAddr, mapPagesCount],  Environment USING [bytesPerPage, PageCount, PageNumber, wordsPerPage],  Format USING [CR, Line, LongDecimal, StringProc, Text],  Heap USING [systemZone],  Inline USING [LowByte, LowHalf],  MStream USING [EndOf, Error, ReadOnly],  PageMap USING [],  PilotSwitches USING [hang],  Stream USING [Delete, EndOfStream, GetBlock, Handle],  String USING [AppendExtensionIfNeeded, CopyToNewString],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],  Space USING [LongPointerFromPage, PageFromLongPointer],    CP USING [RealMemory, VirturalMemory],  CPCommand USING [Error, RefreshWindow, vMBitsOver22],  CPKernel USING [    Error, machine, ReadMap, ResetMap, WriteMemoryBlock, WriteNextMemoryBlock]; CPLoaderBoot: PROGRAM  IMPORTS    Format, Heap, Inline, MStream, Stream, String, System,    CPCommand, CPKernel, Space  EXPORTS CPCommand =  BEGIN  z: UNCOUNTED ZONE = Heap.systemZone;  -- DLion physical memory layout  -- func	octal		decimal  -- display	[0..377)	[0..256)  -- map	[400..500)	[256..320)  -- IO Page	500		320  -- free	[501..1400)	[321..768)     ++ 192K DLion  -- Dicentra physical memory layout  -- func	octal		decimal  -- free	[0..377)	[0..256)  -- map	[400..500)	[256..320)  -- free	[500..2000)	[320..1024)     ++ 512K Dicentra    -- For both machines, the germ goes into virtural [1..n).  -- The rest of free memory is mapped behind the germ.  -- After the germ loads a boot file, free memory is behind the boot file.  realMapLoc: LONG POINTER = Space.LongPointerFromPage[DLionInputOutput.firstMapPage];  realPageForGermSD: CARDINAL = DLionInputOutput.ioPageNumber + 1;  virtualPageForGerm: LONG CARDINAL = Space.PageFromLongPointer[Boot.pRequest];  LoadGerm: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "germ"L, z];    Format.Text[log, "Loading Germ from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    LoadGermFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommand.RefreshWindow[];    END;   LoadGermFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      Stream.EndOfStream => ERROR CPCommand.Error["Truncated germ file"L];    buffer: ARRAY [0..Environment.wordsPerPage) OF WORD;    start, stop: System.Pulses;    ms: LONG CARDINAL;    words, blocks: LONG CARDINAL ¬ 0;    from: CP.VirturalMemory ¬ LOOPHOLE[Boot.pageGerm*Environment.wordsPerPage];    start ¬ System.GetClockPulses[];    DO      bytes: CARDINAL;      to: CP.RealMemory;      IF MStream.EndOf[stream] THEN EXIT;      [bytes, , ] ¬ Stream.GetBlock[        sH: stream,        block: [	  blockPointer: LOOPHOLE[LONG[@buffer]],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerPage]];      IF bytes # Environment.bytesPerPage THEN        ERROR CPCommand.Error["Truncated Germ File"L];      to ¬ MapGermPage[from];      IF blocks = 0 THEN        BEGIN        CPKernel.WriteMemoryBlock[to, Environment.wordsPerPage, @buffer          ! CPKernel.Error => ERROR CPCommand.Error[reason] ];        END      ELSE        CPKernel.WriteNextMemoryBlock[to, Environment.wordsPerPage, @buffer          ! CPKernel.Error => ERROR CPCommand.Error[reason] ];      blocks ¬ blocks + 1;      words ¬ words + Environment.wordsPerPage;      from ¬ from + Environment.wordsPerPage;      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, words, blocks];    END;	  LoadBootFile: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING, pagesOrbanks: CARDINAL] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    pages: Environment.PageCount;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "boot"L, z];    Format.Text[log, "Loading CP boot file from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    SELECT TRUE FROM      pagesOrbanks = 0 =>        BEGIN        pages ¬ FindPages[];        Format.Text[log, "This machine has "L, arg];        Format.LongDecimal[log, pages, arg];        Format.Line[log, " pages of memory."L, arg];        END;      pagesOrbanks < 16 => pages ¬ 256 * pagesOrbanks      ENDCASE => pages ¬ pagesOrbanks;    LoadBootFileFromStream[log, arg, stream, pages !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommand.RefreshWindow[];    END;  BitsToMultiplier: PROC[bits: CARDINAL] RETURNS[CARDINAL] =     BEGIN     SELECT bits FROM	0 => RETURN[1];	1 => RETURN[2];	2 => RETURN[4];	ENDCASE => RETURN[1];     END;      LoadBootFileFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle, pages: Environment.PageCount] =    BEGIN ENABLE      Stream.EndOfStream => ERROR CPCommand.Error["Truncated germ file"L];    headerStorage: ARRAY [0..Environment.wordsPerPage) OF WORD;    header: LONG POINTER TO BootFile.Header = LOOPHOLE[LONG[@headerStorage]];    bufferStorage: ARRAY [0..Environment.wordsPerPage) OF WORD;    buffer: LONG POINTER = @bufferStorage;    realPage: Environment.PageCount ¬ FirstUsablePage[];    FirstWrite: PROCEDURE [ra: LONG POINTER, p: POINTER, nwords: CARDINAL] =      BEGIN      CPKernel.WriteMemoryBlock[to: ra, count: nwords, data: p          ! CPKernel.Error => ERROR CPCommand.Error[reason] ];      blocks ¬ blocks + 1;      words ¬ words + nwords;      END;    WriteMem: PROCEDURE [ra: LONG POINTER, p: LONG POINTER, nwords: CARDINAL] =      BEGIN      CPKernel.WriteNextMemoryBlock[to: ra, count: nwords, data: p          ! CPKernel.Error => ERROR CPCommand.Error[reason] ];      blocks ¬ blocks + 1;      words ¬ words + nwords;      END;    GetRealPage: PROCEDURE [vp: Environment.PageCount] RETURNS [rp: Environment.PageCount] =      BEGIN      IF pages = 0 THEN ERROR CPCommand.Error["Oops, ran out of pages"L];      rp ¬ realPage;      realPage ¬ realPage + 1;      SELECT realPage FROM        DLionInputOutput.firstMapPage => realPage ¬ realPage +        DLionInputOutput.mapPagesCount * BitsToMultiplier[CPCommand.vMBitsOver22];        realPageForGermSD => realPage ¬ realPage + 1;	ENDCASE => NULL;      pages ¬ pages - 1;      END;    start, stop: System.Pulses;    ms: LONG CARDINAL;    words, blocks: LONG CARDINAL ¬ 0;    thisRealPage: Environment.PageCount;    lastUsedVMPage: Environment.PageCount ¬ 0;    countData, countGroup: LONG CARDINAL;    entries: LONG POINTER TO ARRAY [0..0) OF BootFile.MapEntry;    start ¬ System.GetClockPulses[];    CPKernel.ResetMap[ ! CPKernel.Error => ERROR CPCommand.Error[reason] ];  -- Fill with vacant    IF pages < DLionInputOutput.firstMapPage + DLionInputOutput.mapPagesCount * BitsToMultiplier[CPCommand.vMBitsOver22] + 2 THEN      ERROR CPCommand.Error["Not enough pages for map (and such)"L];    pages ¬ pages - DLionInputOutput.mapPagesCount * BitsToMultiplier[CPCommand.vMBitsOver22] - 1;  -- Map, Germ's SD    SELECT CPKernel.machine FROM      dlion =>        BEGIN  -- IO Page: Virtural = last page of MDS 0; Physical = first page past map        me: MapEntry;        me ¬ [          rpLow: DLionInputOutput.ioPageNumber MOD 400B,	  rpHigh: DLionInputOutput.ioPageNumber/400B,          dp: FALSE, w: FALSE, d: TRUE, rp: TRUE];        FirstWrite[ra: realMapLoc + LOOPHOLE[0FFH], p: @me, nwords: SIZE[MapEntry]];        pages ¬ pages - 1;        pages ¬ pages - 256;  -- Display Bank	END;      dicentra =>        BEGIN	END;      ENDCASE => ERROR;    [] ¬ Stream.GetBlock[      sH: stream,      block: [        blockPointer: LOOPHOLE[header], startIndex: 0,        stopIndexPlusOne: Environment.bytesPerPage]];    IF header.version # BootFile.currentVersion THEN      ERROR CPCommand.Error["not (current) bootfile"L];    BEGIN  -- initilize the germ's SD vector page    pRequestOffset: WORD = Inline.LowByte[Inline.LowHalf[Boot.pRequest]];    pRequest: LONG POINTER TO Boot.Request =       Space.LongPointerFromPage[realPageForGermSD] + pRequestOffset;    request: Boot.Request;    me: MapEntry;    me ¬ [  -- Germ's SD      rpLow: realPageForGermSD MOD 400B, rpHigh: realPageForGermSD/400B,      dp: FALSE, w: FALSE, d: TRUE, rp: TRUE];    FirstWrite[ra: realMapLoc + virtualPageForGerm, p: @me, nwords: SIZE[MapEntry]];    request ¬ [      action: Boot.bootPhysicalVolume,      location: [deviceType: DeviceTypes.anyPilotDisk, deviceOrdinal: 0, vp: ],      pStartListHeader: header.pStartListHeader,      inLoadMode: ,      session: ];    request.switches[PilotSwitches.hang] ¬ down;    WriteMem[ra: pRequest, p: @request, nwords: SIZE[Boot.Request]];    END;    IF (countData ¬ header.countData) > pages THEN      ERROR CPCommand.Error["Not enough pages for Boot file"L];    countGroup ¬ MIN[countData, BootFile.maxEntriesPerHeader];    entries ¬ LOOPHOLE[@header.entries];    DO      trailer: LONG POINTER TO BootFile.Trailer = LOOPHOLE[header];      FOR i: LONG CARDINAL IN [0..countGroup) DO        OPEN bfe: entries[IF i > LAST[CARDINAL] THEN ERROR ELSE CARDINAL[i]];        me: MapEntry;        [] ¬ Stream.GetBlock[          sH: stream,          block: [            blockPointer: buffer,	    startIndex: 0,            stopIndexPlusOne: Environment.bytesPerPage]];        thisRealPage ¬ GetRealPage[bfe.virtual];       << Perhaps a check should be placed in here for a large "thisRealPage">>       me ¬ [          rpLow: CARDINAL[thisRealPage MOD 400B], rpHigh: CARDINAL[thisRealPage/400B],          dp: FALSE, w: bfe.flags.readonly,          d: bfe.flags.dirty, rp: bfe.flags.referenced];        WriteMem[ra: realMapLoc + bfe.virtual, p: @me, nwords: 1];        WriteMem[          ra: Space.LongPointerFromPage[thisRealPage],          p: buffer, nwords: Environment.wordsPerPage];        lastUsedVMPage ¬ MAX[lastUsedVMPage, bfe.virtual];        ENDLOOP;      IF (countData ¬ countData - countGroup) = 0 THEN EXIT;      countGroup ¬ MIN[countData, BootFile.maxEntriesPerTrailer];      [] ¬ Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[trailer],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerPage]];      IF header.version # BootFile.currentVersion THEN        ERROR CPCommand.Error["bad trailer version?"L];      entries ¬ LOOPHOLE[@trailer.entries];      ENDLOOP;    -- Put any extra memory in map following last used mapped VM    WHILE pages > 0 DO      me: MapEntry;      lastUsedVMPage ¬ lastUsedVMPage + 1;      thisRealPage ¬ GetRealPage[lastUsedVMPage];      << Perhaps a check should be placed in here for a large "thisRealPage">>      me ¬ [        rpLow: CARDINAL[thisRealPage MOD 400B], rpHigh: CARDINAL[thisRealPage/400B], dp: FALSE,        w: FALSE, d: FALSE, rp: FALSE];      WriteMem[ra: realMapLoc + lastUsedVMPage, p: @me, nwords: 1];      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, words, blocks];    END;  MapGermPage: PROCEDURE [virtural: CP.VirturalMemory] RETURNS [real: CP.RealMemory] =    BEGIN    page: Environment.PageCount ¬ Space.PageFromLongPointer[virtural];    IF page ~IN [Boot.pageGerm..Boot.countGermVM) THEN      ERROR CPCommand.Error["Germ doesn't fit in allocated space"L];    SELECT CPKernel.machine FROM      dlion =>        BEGIN        offset: Environment.PageNumber = 256 + DLionInputOutput.mapPagesCount * BitsToMultiplier[CPCommand.vMBitsOver22];  -- 64K Display bank, 16K Map        IF page = 0 OR page = 0FFH THEN ERROR CPCommand.Error["MapGermPage confusion"L];        page ¬ page + offset;        RETURN[Space.LongPointerFromPage[page]];	END;      dicentra =>        BEGIN	RETURN[virtural];	END;      ENDCASE => ERROR;    END;   FindPages: PROCEDURE RETURNS [pages: Environment.PageCount] =    BEGIN  -- Binary search    low: CARDINAL ¬ 0;    high: CARDINAL ¬ 0FFFH;  -- 16K Map for now ############    WHILE high > low DO      probe: CARDINAL = (low + high ) / 2;      me: MapEntry = LOOPHOLE[CPKernel.ReadMap[probe        ! CPKernel.Error => ERROR CPCommand.Error[reason] ]];      IF Vacant[me] THEN high ¬ probe - 1      ELSE        BEGIN        low ¬ probe + 1;	pages ¬ RealPageNumber[me] + 1;	END;      ENDLOOP;    END;      FirstUsablePage: PROCEDURE RETURNS [Environment.PageCount] =    BEGIN    SELECT CPKernel.machine FROM      dlion =>        BEGIN        firstUsableAddr: LONG POINTER = DLionInputOutput.ioPageRealAddr;        RETURN[Space.PageFromLongPointer[firstUsableAddr] + 2];	END;      dicentra =>        BEGIN	RETURN[0];	END;      ENDCASE => ERROR;    END;      MapEntry: TYPE = MACHINE DEPENDENT RECORD [    rpLow: [0..0FFH], dp, w, d, rp: BOOLEAN, rpHigh: [0..17B]];      Vacant: PROCEDURE [me: MapEntry] RETURNS [BOOLEAN] =    BEGIN    RETURN[me.w AND me.d AND ~me.dp AND ~ me.rp];    END;      RealPageNumber: PROCEDURE [me: MapEntry] RETURNS [CARDINAL] =    BEGIN    RETURN[me.rpHigh*400B + me.rpLow];    END;      Info: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, words, blocks: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, words, arg];    Format.Text[log, " words in "L, arg];    Format.LongDecimal[log, blocks, arg];    Format.Text[log, " blocks."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, words*16*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;    END.    -- HGM, 14-Feb-83 12:51:33  -- Dennis DEG     ,  3-Jun-83 21:43:29 changed all definitions of type *page from CARDINAL to Environment.PageCount  -- Dennis DEG     , 18-Sep-83 19:40:29 Converted to Klamath 11.0b
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- TestControlStore.mesa, HGM,  5-Oct-83  0:07:59DIRECTORY  DLionInputOutput USING [IOPage, processorCommandOffset, processorCSBOffset],  Environment USING [Byte],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, newLine, NumberItem, ProcType],  Inline USING [BITAND, BytePair, HighByte, LowByte],  Process USING [Yield],  Put USING [Char, Number, Text, Line],  Runtime USING [GetBcdTime],  String USING [AppendString],  Time USING [Append, Unpack],  Tool USING [    Create, MakeSWsProc, UnusedLogName, MakeFormSW, MakeFileSW],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle];TestControlStore: PROGRAM  IMPORTS    DLionInputOutput, FormSW, Inline, Process, Put,    Runtime, String, Time, Tool, UserInput =  BEGIN  DebuggerBoardNotResponding: ERROR = CODE;  Mixup: ERROR [s: LONG STRING, expected, found: UNSPECIFIED] = CODE;  ProcessorCommand: TYPE = MACHINE DEPENDENT {    null(0), readIOPByte(5), writeIOPByte(6)};  pProcessorCommand: LONG POINTER TO ProcessorCommand = DLionInputOutput.IOPage + DLionInputOutput.processorCommandOffset;  ProcessorCSB: TYPE = MACHINE DEPENDENT RECORD [    data2(0): WORD,    data1(1): WORD,      data0(2): WORD];  pProcessorCSB: LONG POINTER TO ProcessorCSB = DLionInputOutput.IOPage + DLionInputOutput.processorCSBOffset;    baseAddress: WORD = 100200B;  -- Hex 8080  controlByte: WORD = baseAddress + 0;    run: WORD = 0;    boot: WORD = 1B;    useCsa: WORD = 2B;    useRam: WORD = 4B;    singleStep: WORD = 20B;    stop: WORD = 100B;  statusByte: WORD = baseAddress + 0;    cycle1: WORD = 4B;    cycle2: WORD = 2B;    cycle3: WORD = 1B;    bufferFromCpFull: WORD = 10B;    bufferToCpFull: WORD = 20B;    hbDone: WORD = 40B;    stopBar: WORD = 100B;  cpData: WORD = baseAddress + 1;  finger: WORD = baseAddress + 2;  contents: WORD = baseAddress + 3;  Register: TYPE = MACHINE DEPENDENT {    -- Control Store section starts at 0    csaMsb(0B), csaLsb(1B),    csData0(2B), csData1(3B), csData2(4B), csData3(5B), csData4(6B), csData5(7B),    niaMsb(10B), niaLsb(11B),    temp(12B),    -- History Buffer section starts at 20B    hbAddr(20B),    hbPCMsb(21B), hbPCLsb(22B), hbPCExtra(23B),    hbMatchMsb(24B), hbMatchLsb(25B),    hbCount(26B), hbStatusControl(27B),    (0FFH) };    csa: CARDINAL ¬ 0;  banks: CARDINAL ¬ 1;    wordsPerBank: CARDINAL = 4096;  ReadIOP: PROCEDURE [address: CARDINAL] RETURNS [Environment.Byte] =    BEGIN    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ address;    pProcessorCommand­ ¬ readIOPByte;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    RETURN[Inline.LowByte[pProcessorCSB.data1]];    END;  WriteIOP: PROCEDURE [address: CARDINAL, data: Environment.Byte] =    BEGIN    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ address;    pProcessorCSB.data1 ¬ data;    pProcessorCommand­ ¬ writeIOPByte;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    END;  Initialize: PROCEDURE =    BEGIN    temp: WORD;    temp ¬ ReadIOP[statusByte];    IF temp = 0 THEN ERROR DebuggerBoardNotResponding; -- c1, c2, or c3 should be on    IF temp = 0FFH THEN ERROR DebuggerBoardNotResponding;  -- high bit wired to GND    WriteIOP[controlByte, stop+useRam+useCsa];  -- Take control, feed CSA to Matcher    temp ¬ ReadIOP[statusByte];    IF Inline.BITAND[temp, stopBar] # 0 THEN ERROR DebuggerBoardNotResponding;  -- Stop didn't clear run    IF Inline.BITAND[temp, 7B] = 0 THEN ERROR DebuggerBoardNotResponding;  -- DLion Umbilical does this    END;  CSA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    csa: WORD;    Put.Text[log, "CSA is "L];    Initialize[];    SetFinger[csaMsb];    csa ¬ ReadIOP[contents] * 400B;    csa ¬ csa + ReadIOP[contents];    Put.Number[log, csa, [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    END;      CS: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    csa: WORD;    Put.Text[log, "CS["L];    Initialize[];    SetFinger[csaMsb];    csa ¬ ReadIOP[contents] * 400B;    csa ¬ csa + ReadIOP[contents];    Put.Number[log, csa, [16, FALSE, TRUE, 0]];    Put.Text[log, "] is ... "L];    FOR i: CARDINAL IN [0..6) DO      temp: WORD ¬ ReadIOP[contents];      Put.Number[log, temp, [16, FALSE, TRUE, 3]];      ENDLOOP;    Put.Line[log, "."L];    END;  SetCSA: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Setting CSA to "L];    Put.Number[log, csa, [16, FALSE, TRUE, 0]];    Initialize[];    SetFinger[csaMsb];    WriteIOP[contents, Inline.HighByte[csa]];    WriteIOP[contents, Inline.LowByte[csa]];    Put.Line[log, "."L];    END;    TestCS: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    found: WORD;    Put.Text[log, "Testing CS ... "L];    Initialize[];    WriteIOP[controlByte, stop+useRam+useCsa];    WriteIOP[finger, 0];    Put.Line[log, "."L];    Put.Text[log, "Checking first word ... "L];    SetCSAddr[0];    FOR i: CARDINAL IN [0..6) DO      WriteIOP[contents, i];      found ¬ ReadIOP[finger];      SELECT i FROM        IN [0..5) => IF found # (i + 3) THEN Mixup["Register didn't incr on on write"L, i+3, found];        5 => IF found # 0 THEN Mixup["Register didn't wrap on on write"L, 0, found];	ENDCASE => ERROR;      ENDLOOP;    found ¬ GetCSAddr[];    IF found # 1 THEN Mixup["CSAddr didn't incr to 1 on write"L, 1, found];    SetCSAddr[0];    FOR i: CARDINAL IN [0..6) DO      found ¬ ReadIOP[contents];      IF found # i THEN Mixup["Didn't get byte offset back"L, i, found];      found ¬ ReadIOP[finger];      SELECT i FROM        IN [0..5) => IF found # (i + 3) THEN Mixup["Register didn't incr on on read"L, i+3, found];        5 => IF found # 0 THEN Mixup["Register didn't wrap on on read"L, 0, found];	ENDCASE => ERROR;      ENDLOOP;    found ¬ GetCSAddr[];    IF found # 1 THEN Mixup["CSAddr didn't incr to 1 on read"L, 1, found];    Put.Line[log, "ok."L];    Put.Text[log, "Filling with 0s ... "L];    FOR cs: CARDINAL IN [0..banks*wordsPerBank) DO      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      SetCSAddr[cs];      FOR i: CARDINAL IN [0..6) DO WriteIOP[contents, 0]; ENDLOOP;      IF cs MOD wordsPerBank = (wordsPerBank-1) THEN Put.Char[log, '!];      ENDLOOP;    found ¬ GetCSAddr[];    IF found # banks*wordsPerBank THEN  Mixup["CS Addr didn't incr right"L, banks*wordsPerBank, found];    Put.Text[log, " checking ... "L];    FOR cs: CARDINAL IN [0..banks*wordsPerBank) DO      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      SetCSAddr[cs];      FOR i: CARDINAL IN [0..6) DO        found ¬ ReadIOP[contents];        IF found # 0 THEN Mixup["Didn't get a 0 back"L, 0, found];        ENDLOOP;      IF cs MOD wordsPerBank = (wordsPerBank-1) THEN Put.Char[log, '!];      ENDLOOP;    found ¬ GetCSAddr[];    IF found # banks*wordsPerBank THEN  Mixup["CS Addr didn't incr right"L, banks*wordsPerBank, found];    Put.Line[log, " ok."L];    Put.Text[log, "Filling with 1s ... "L];    FOR cs: CARDINAL IN [0..banks*wordsPerBank) DO      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      SetCSAddr[cs];      FOR i: CARDINAL IN [0..6) DO WriteIOP[contents, 0FFH]; ENDLOOP;      IF cs MOD wordsPerBank = (wordsPerBank-1) THEN Put.Char[log, '!];      ENDLOOP;    found ¬ GetCSAddr[];    IF found # banks*wordsPerBank THEN  Mixup["CS Addr didn't incr right"L, banks*wordsPerBank, found];    Put.Text[log, " checking ... "L];    FOR cs: CARDINAL IN [0..banks*wordsPerBank) DO      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      SetCSAddr[cs];      FOR i: CARDINAL IN [0..6) DO        found ¬ ReadIOP[contents];        IF found # 0FFH THEN Mixup["Didn't get a FF back"L, 0FFH, found];        ENDLOOP;      IF cs MOD wordsPerBank = (wordsPerBank-1) THEN Put.Char[log, '!];      ENDLOOP;    found ¬ GetCSAddr[];    IF found # banks*wordsPerBank THEN  Mixup["CS Addr didn't incr right"L, banks*wordsPerBank, found];    Put.Line[log, " ok."L];    Put.Text[log, "Filling with addresses ... "L];    FOR cs: CARDINAL IN [0..banks*wordsPerBank) DO      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      SetCSAddr[cs];      FOR i: CARDINAL IN [0..6/2) DO        WriteIOP[contents, Inline.HighByte[cs]];        WriteIOP[contents, Inline.LowByte[cs]];        ENDLOOP;      IF cs MOD wordsPerBank = (wordsPerBank-1) THEN Put.Char[log, '!];      ENDLOOP;    found ¬ GetCSAddr[];    IF found # banks*wordsPerBank THEN  Mixup["CS Addr didn't incr right"L, banks*wordsPerBank, found];    Put.Text[log, " checking ... "L];    FOR cs: CARDINAL IN [0..banks*wordsPerBank) DO      Process.Yield[];      IF UserInput.UserAbort[log] THEN BEGIN Put.Line[log, " aborted."L]; RETURN; END;      SetCSAddr[cs];      FOR i: CARDINAL IN [0..6/2) DO        found ¬ ReadIOP[contents];        IF found # Inline.HighByte[cs] THEN Mixup["Didn't get a address(msb) back"L, Inline.HighByte[cs], found];        found ¬ ReadIOP[contents];        IF found # Inline.LowByte[cs] THEN Mixup["Didn't get a address(lsb) back"L, Inline.LowByte[cs], found];        ENDLOOP;      IF cs MOD wordsPerBank = (wordsPerBank-1) THEN Put.Char[log, '!];      ENDLOOP;    found ¬ GetCSAddr[];    IF found # banks*wordsPerBank THEN  Mixup["CS Addr didn't incr right"L, banks*wordsPerBank, found];    Put.Line[log, " ok."L];    Put.Line[log, "Yea!"L];    END;    WriteCS: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Writing CS ... "L];    Initialize[];    WriteIOP[controlByte, stop+useRam+useCsa];    DO      FOR i: CARDINAL IN [0..100) DO        SetFinger[csaMsb];	FOR k: CARDINAL IN [0..8) DO  -- 2 bytes of address, 6 for a micro instruction          WriteIOP[contents, 0];	  ENDLOOP;        SetFinger[csaMsb];	FOR k: CARDINAL IN [0..8) DO          WriteIOP[contents, 0FFH];	  ENDLOOP;        Process.Yield[];	ENDLOOP;      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    ClearCS: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    found: WORD;    Put.Text[log, "Clearing CS ... "L];    Initialize[];    SetFinger[csaMsb];    WriteIOP[contents, 0];  -- CSA Msb    WriteIOP[contents, 0];  -- CSA Lsb    SetFinger[csaMsb];    FOR cs: CARDINAL IN [0..banks*wordsPerBank) DO      found ¬ ReadIOP[contents];      IF found # Inline.HighByte[cs] THEN ERROR Mixup["csaMsb mixup"L, Inline.HighByte[cs], found];      found ¬ ReadIOP[contents];      IF found # Inline.LowByte[cs] THEN ERROR Mixup["csaLsb mixup"L, Inline.LowByte[cs], found];      FOR k: CARDINAL IN [0..6) DO        WriteIOP[contents, 0];        ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    SetCS: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    found: WORD;    Put.Text[log, "Setting CS ... "L];    Initialize[];    SetFinger[csaMsb];    WriteIOP[contents, 0];  -- CSA Msb    WriteIOP[contents, 0];  -- CSA Lsb    SetFinger[csaMsb];    FOR cs: CARDINAL IN [0..banks*wordsPerBank) DO      found ¬ ReadIOP[contents];      IF found # Inline.HighByte[cs] THEN ERROR Mixup["csaMsb mixup"L, Inline.HighByte[cs], found];      found ¬ ReadIOP[contents];      IF found # Inline.LowByte[cs] THEN ERROR Mixup["csaLsb mixup"L, Inline.LowByte[cs], found];      FOR k: CARDINAL IN [0..6) DO        WriteIOP[contents, 0FFH];        ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    ReadCS: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Reading CS ... "L];    Initialize[];    WriteIOP[controlByte, stop+useRam+useCsa];    DO      FOR cs: CARDINAL IN [0..banks*wordsPerBank) DO        SetFinger[csaMsb];        WriteIOP[contents, Inline.HighByte[cs]];        WriteIOP[contents, Inline.LowByte[cs]];	FOR k: CARDINAL IN [0..6) DO          [] ¬ ReadIOP[contents];	  ENDLOOP;        Process.Yield[];        IF UserInput.UserAbort[log] THEN EXIT;	ENDLOOP;      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    ReadWriteWord: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    csa: WORD;    Put.Text[log, "Reading and Writing CS["L];    Initialize[];    WriteIOP[controlByte, stop+useRam+useCsa];    SetFinger[csaMsb];    csa ¬ ReadIOP[contents] * 400B;    csa ¬ csa + ReadIOP[contents];    Put.Number[log, csa, [16, FALSE, TRUE, 0]];    Put.Text[log, "] ... "L];    DO      SetFinger[csaMsb];      WriteIOP[contents, Inline.HighByte[csa]];      WriteIOP[contents, Inline.LowByte[csa]];      FOR k: CARDINAL IN [0..6) DO WriteIOP[contents, 0]; ENDLOOP;      SetFinger[csaMsb];      WriteIOP[contents, Inline.HighByte[csa]];      WriteIOP[contents, Inline.LowByte[csa]];      FOR k: CARDINAL IN [0..6) DO [] ¬ ReadIOP[contents]; ENDLOOP;      SetFinger[csaMsb];      WriteIOP[contents, Inline.HighByte[csa]];      WriteIOP[contents, Inline.LowByte[csa]];      FOR k: CARDINAL IN [0..6) DO WriteIOP[contents, 0FFH]; ENDLOOP;      SetFinger[csaMsb];      WriteIOP[contents, Inline.HighByte[csa]];      WriteIOP[contents, Inline.LowByte[csa]];      FOR k: CARDINAL IN [0..6) DO [] ¬ ReadIOP[contents]; ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;    SpinBank: FormSW.ProcType =    BEGIN    ENABLE      BEGIN      Mixup => BEGIN PrintMixup[s, expected, found]; CONTINUE; END;      DebuggerBoardNotResponding =>        BEGIN Put.Line[log, "Debugger board not responding."L]; CONTINUE; END;      END;    Put.Text[log, "Spinning Bank register ..."L];    Initialize[];    WriteIOP[controlByte, stop+useRam+useCsa];    DO      FOR bank: CARDINAL IN [0..16) DO        SetFinger[csaMsb];        WriteIOP[contents, bank*16];	ENDLOOP;      Process.Yield[];      IF UserInput.UserAbort[log] THEN EXIT;      ENDLOOP;    Put.Line[log, "ok."L];    END;  	            PrintMixup: PROCEDURE [s: LONG STRING, expected, found: UNSPECIFIED] =    BEGIN    Put.Text[log, s];    Put.Text[log, "; expected: "L];    Put.Number[log, expected, [16, FALSE, TRUE, 0]];    Put.Text[log, ", found: "L];    Put.Number[log, found, [16, FALSE, TRUE, 0]];    Put.Line[log, "."L];    END;    SetFinger: PROCEDURE [reg: Register] =    BEGIN    found: Register;    WriteIOP[finger, LOOPHOLE[reg]];    found ¬ LOOPHOLE[ReadIOP[finger]];    IF found # reg THEN ERROR Mixup["Section/Reg readback didn't work"L, reg, found];    END;  SetCSAddr: PROCEDURE [cs: CARDINAL] =    BEGIN    SetFinger[csaMsb];    WriteIOP[contents, Inline.HighByte[cs]];    WriteIOP[contents, Inline.LowByte[cs]];    END;    GetCSAddr: PROCEDURE RETURNS [cs: CARDINAL] =    BEGIN    bytes: Inline.BytePair;    SetFinger[csaMsb];    bytes.high ¬ ReadIOP[contents];    bytes.low ¬ ReadIOP[contents];    RETURN[LOOPHOLE[bytes]];    END;    form, log: Window.Handle ¬ NIL;  Init: PROCEDURE =    BEGIN    herald: STRING = [100];    String.AppendString[herald, "TestControlStore of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    [] ¬ Tool.Create[name: herald, makeSWsProc: MakeSWs, clientTransition: ClientTransition];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    Tool.UnusedLogName[logFileName, "TestControlStore.log$"L];    log ¬ Tool.MakeFileSW[window: window, name: logFileName];    END;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 12;    i: INTEGER ¬ -1;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "CSA"L, proc: CSA, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "CS"L, proc: CS];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "SetCSA"L, proc: SetCSA];    items[i¬i+1] ¬ FormSW.NumberItem[tag: "CSA"L, notNegative: TRUE, radix: octal, value: @csa];    items[i¬i+1] ¬ FormSW.NumberItem[tag: "Banks"L, notNegative: TRUE, radix: octal, value: @banks];        items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestCS"L, proc: TestCS, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteCS"L, proc: WriteCS];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ClearCS"L, proc: ClearCS];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "SetCS"L, proc: SetCS];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadCS"L, proc: ReadCS];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadWriteWord"L, proc: ReadWriteWord];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "SpinBank"L, proc: SpinBank];    IF (i+1) # nParams THEN ERROR;    RETURN[items, TRUE];    END;  ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN        END;      ENDCASE;    END;	  Init[];  END....
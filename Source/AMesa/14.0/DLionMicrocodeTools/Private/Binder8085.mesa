-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File:  Binder8085.mesa-- Last edit by DEG     : 26-Sep-84 23:03:27-- 8085 BinderDIRECTORY  CodeOutputDefs USING [    GetBinaryStreamIndex, GetPC, PutCodeLine, PutEOFLine, ReleaseMapChain,    RelocRec, SetBinaryStream, SetPC],  CommandDefs,  Environment USING [Byte, bytesPerPage, charsPerWord],  Format USING [Line, StringProc, Text],  Heap USING [systemZone],  MStream USING [Error, ReadOnly, ReadWrite, SetLength, WriteOnly],  NewStateDefs USING [Address, MemoryAddress],  PrivateStorage USING [heapPointer],  PrivateStringDefs USING [AppendHexNumber, CopyString, StringFromHex],  SimHashDefs USING [    Create, DumpToStream, EnumerateEntries, GetInfo, Hash, JamValue,    TempStringForHash],  Stream USING [Delete, EndOfStream, GetChar, GetPosition, Handle, Position, PutByte, PutString, PutWord, SetPosition],  String USING [AppendChar, AppendString],  SymbolTableDefs USING [LookUpInSymbolTable, PutInSymbolTable, STData],  SymTabIODefs USING [AddToUseChain, ProcessUseChain],  MFile USING[ReadOnly,Release,GetTimes,Handle],  Time USING[Unpack,Append,Packed,Unpacked];Binder8085: PROGRAM  IMPORTS    CodeOutputDefs, Format, Heap, MStream, PrivateStorage, PrivateStringDefs, SimHashDefs, Stream, String, SymbolTableDefs,    SymTabIODefs,MFile,Time  EXPORTS CommandDefs =  BEGIN  EOF: CARDINAL = 1;  DefaultAddress: NewStateDefs.MemoryAddress = 20000B;  CurrentBase, CurrentAddr, LastAddr: NewStateDefs.MemoryAddress;  MiscString: LONG STRING;  BinFileName: LONG STRING;  OutputFile: LONG STRING;  char, cfgchar: CHARACTER;  ConfigStream, BinaryStream: Stream.Handle;  BaseSI: Stream.Position;  RelocChain: LONG POINTER TO CodeOutputDefs.RelocRec;  NoOutputStream: BOOLEAN;  InvalidBinderInput: PUBLIC SIGNAL [code: CARDINAL] = CODE;  BinderFileError: PUBLIC SIGNAL [fn: LONG STRING] = CODE;  UndefinedSymbol: PUBLIC SIGNAL [name: LONG STRING] = CODE;  UnreferencedSymbol: PUBLIC SIGNAL [name: LONG STRING] = CODE;  MultipleDef: PUBLIC SIGNAL [name: LONG STRING] = CODE;  EndOfList: SIGNAL = CODE;  EndOfConfig: SIGNAL = CODE;  CommandLine: SIGNAL = CODE;  ItemType: TYPE = RECORD [    SELECT tag: * FROM    address => [addr: NewStateDefs.MemoryAddress],    file => [stream: Stream.Handle],    eof => [done: BOOLEAN],    ENDCASE];  FTEntry: TYPE = RECORD [    chain: LONG POINTER TO FTEntry,    fileno, assfileno, start, end: CARDINAL,    name: LONG STRING];  FileTable: LONG POINTER TO FTEntry;  afn, level: CARDINAL;  fnst: ARRAY [0..16) OF CARDINAL;  MakeFTEntry: PROCEDURE [n: LONG STRING] =    BEGIN    fn: CARDINAL ¬ IF FileTable = NIL THEN 0 ELSE FileTable.fileno + 1;    ft: LONG POINTER TO FTEntry;    ft ¬ PrivateStorage.heapPointer.NEW[FTEntry];    ft­ ¬ [FileTable, fn, afn, CurrentAddr, 0, PrivateStorage.heapPointer.NEW[StringBody[n.length]]];    String.AppendString[ft.name, n];    fnst[level] ¬ afn;    afn ¬ afn + 1;    level ¬ level + 1;    FileTable ¬ ft;    END;  EndFTEntry: PROCEDURE =    BEGIN    ft: LONG POINTER TO FTEntry ¬ FileTable;    level ¬ level - 1;    WHILE ft # NIL AND ft.assfileno # fnst[level] DO ft ¬ ft.chain; ENDLOOP;    IF ft = NIL THEN ERROR;    ft.end ¬ CurrentAddr;    END;  PutFTEntries: PROCEDURE [fname: LONG STRING] =    BEGIN    ftf: STRING ¬ [32];    fmstr: Stream.Handle;    ft: LONG POINTER TO FTEntry ¬ FileTable;    String.AppendString[ftf, fname];    String.AppendString[ftf, ".fm"L];    fmstr ¬ MStream.WriteOnly[name: ftf, release: [NIL, NIL], type: text];  <<MStream.WriteOnly as of Sierra requires that you specify the type of file.>>    WHILE ft # NIL DO      WriteFMRecord[fmstr, ft];      ft ¬ ft.chain;      PrivateStorage.heapPointer.FREE[@FileTable];      FileTable ¬ ft;      ENDLOOP;    PutExternalSymbolTable[fmstr];    END;  WriteFMRecord: PROCEDURE [str: Stream.Handle, ft: LONG POINTER TO FTEntry] =    BEGIN    len: CARDINAL = ft­.name.length;    Stream.PutWord[sH: str, word: ft­.fileno];    Stream.PutWord[sH: str, word: ft­.assfileno];    Stream.PutWord[sH: str, word: ft­.start];    Stream.PutWord[sH: str, word: ft­.end];    Stream.PutWord[sH: str, word: len];    Stream.PutString[sH: str, string: ft­.name];-- Burdock and others want things to be word-aligned:    IF (len MOD Environment.charsPerWord) # 0 THEN {    THROUGH [1..Environment.charsPerWord - (len MOD Environment.charsPerWord)] DO       Stream.PutByte[sH: str, byte: 0];      ENDLOOP};    END;  PutExternalSymbolTable: PROCEDURE [str: Stream.Handle] =    BEGIN    Stream.PutWord[sH: str, word: 177777B];  -- to mark end of FT entries    [] ¬ SimHashDefs.EnumerateEntries[PutValueOfSymbol];    SimHashDefs.DumpToStream[str];    END;  PutValueOfSymbol: PROCEDURE [h: SimHashDefs.Hash] RETURNS [BOOLEAN] =    BEGIN    p: LONG POINTER TO SymbolTableDefs.STData;    v: CARDINAL;    [, p] ¬ SimHashDefs.GetInfo[h];    v ¬ WITH p.val SELECT FROM IOPmain => addr, ENDCASE => ERROR;    SimHashDefs.JamValue[h, TRUE, v];    RETURN[TRUE];    END;  NextChar: PROCEDURE [str: Stream.Handle] RETURNS [CHARACTER] =    BEGIN RETURN[char ¬ Stream.GetChar[sH: str]]; END;  GetItem: PROCEDURE [str: Stream.Handle] RETURNS [ItemType] =    BEGIN    stream: Stream.Handle;    fname: STRING ¬ [32];    IF cfgchar = '  OR cfgchar = '\T OR cfgchar = '\N      OR cfgchar = '\L THEN cfgchar ¬ GetNonBlank[str];    IF cfgchar = '} THEN RETURN[[eof[TRUE]]];    IF cfgchar = ', OR cfgchar = '{ THEN cfgchar ¬ GetNonBlank[str]    ELSE SIGNAL InvalidBinderInput[4];    IF cfgchar = '@ THEN RETURN[[address[GetHexNumber[str]]]];    GetName[str, fname];    cfgchar ¬ char;    PrivateStringDefs.CopyString[BinFileName, fname];    String.AppendString[fname, ".bin"L];    stream ¬ MStream.ReadOnly[name: fname, release: [NIL, NIL]!      MStream.Error =>        SELECT code FROM          fileNotAvailable => SIGNAL BinderFileError[fname];          ENDCASE => REJECT;];    RETURN[[file[stream]]];    END;  SetUpOutputStream: PROCEDURE [fname: LONG STRING] =    BEGIN    PrivateStringDefs.CopyString[OutputFile, fname];    String.AppendString[OutputFile, ".bin"L];    IF BinaryStream ~= NIL THEN Stream.Delete[sH: BinaryStream];    BinaryStream ¬ MStream.ReadWrite[name: OutputFile, release: [NIL, NIL], type: text];    NoOutputStream ¬ FALSE;    END;  GetAndUpdateCodeLine: PROCEDURE [str: Stream.Handle, c: STRING]    RETURNS [len, Flag, cs: CARDINAL] =    BEGIN    val, addr: CARDINAL;    p: LONG POINTER TO CodeOutputDefs.RelocRec;    i: CARDINAL;    WHILE char # ': DO      LookFor[str, '\L]; IF char = '/ THEN SIGNAL CommandLine; ENDLOOP;    c.length ¬ 0;    len ¬ ReadCodeByte[str];    addr ¬ ReadCodeNumber[str];    Flag ¬ ReadCodeByte[str];    IF Flag = EOF THEN RETURN;    CurrentAddr ¬ addr + CurrentBase;    cs ¬ 0;    FOR i IN [0..len) DO      IF RelocChain ~= NIL AND addr + i = RelocChain.addr THEN        BEGIN        val ¬ ReadCodeByte[str];        val ¬ val + ReadCodeByte[str]*256 + CurrentBase;        PrivateStringDefs.AppendHexNumber[c, val MOD 256, 2];        PrivateStringDefs.AppendHexNumber[c, val/256, 2];        cs ¬ cs + val/256 + val MOD 256;        p ¬ RelocChain;        RelocChain ¬ RelocChain.prev;        PrivateStorage.heapPointer.FREE[@p];        i ¬ i + 1;  --  frig the value of the control variable        END      ELSE        BEGIN        val ¬ ReadCodeByte[str];        cs ¬ cs + val;        PrivateStringDefs.AppendHexNumber[c, val, 2];        END;      ENDLOOP;    CodeOutputDefs.SetPC[CurrentAddr + len];    END;  ProcessRelocationEntries: PROCEDURE [str: Stream.Handle] =    BEGIN    ENABLE Stream.EndOfStream => GOTO Exit;    addr: NewStateDefs.MemoryAddress;    ch: CHARACTER ¬ char;    DO      WHILE ch # '/ DO LookFor[str, '\L]; ch ¬ char; ENDLOOP;      ch ¬ NextChar[str];      IF ch = 'R THEN EXIT;      IF ch = 'D OR ch = 'U THEN RETURN;      ENDLOOP;    LookFor[str, '\L];    ch ¬ char;    DO      addr ¬ GetHexNumber[str ! Stream.EndOfStream, EndOfList => EXIT];      AddToRelocChain[addr];      ENDLOOP;    EXITS Exit => NULL;    END;  AddToRelocChain: PROCEDURE [addr: NewStateDefs.MemoryAddress] =    BEGIN    p: LONG POINTER TO CodeOutputDefs.RelocRec ¬ PrivateStorage.heapPointer.NEW[      CodeOutputDefs.RelocRec ¬ [addr, ]];    rr: LONG POINTER TO CodeOutputDefs.RelocRec ¬ RelocChain;    IF rr = NIL OR addr < rr.addr THEN      BEGIN p.prev ¬ RelocChain; RelocChain ¬ p; RETURN; END;    WHILE rr.prev # NIL AND rr.prev.addr < addr DO rr ¬ rr.prev; ENDLOOP;    p.prev ¬ rr.prev;    rr.prev ¬ p;    END;  ProcessSymbolTableEntries: PROCEDURE [str: Stream.Handle] =    BEGIN    ENABLE Stream.EndOfStream => GOTO Exit;    ste: LONG POINTER TO SymbolTableDefs.STData;    addr: NewStateDefs.MemoryAddress;    Symbol: STRING ¬ [32];    si: Stream.Position;    size: CARDINAL ¬ 2;    IF char = '/ THEN char ¬ NextChar[str];    IF char = 'D THEN      BEGIN      DO        LookFor[str, '\L];        GetName[str, Symbol ! EndOfList => EXIT];        ste ¬ SymbolTableDefs.LookUpInSymbolTable[Symbol];        addr ¬ GetHexNumber[str] + CurrentBase;        IF ste = NIL THEN          [] ¬ SymbolTableDefs.PutInSymbolTable[            Symbol, [IOPmain[addr]], DefSym, exported, FALSE, FALSE,            CodeOutputDefs.GetPC[], 2, CodeOutputDefs.GetBinaryStreamIndex[]]        ELSE          BEGIN          IF ste.type = DefSym THEN SIGNAL MultipleDef[Symbol];          ste.type ¬ DefSym;          ste.val ¬ [IOPmain[addr]];          END;        ENDLOOP;      END;    IF char = '/ THEN char ¬ NextChar[str];    IF char # 'U THEN RETURN;    --  Process imported symbols.    LookFor[str, '\L];    DO      GetName[str, Symbol ! EndOfList => EXIT];      ste ¬ SymbolTableDefs.LookUpInSymbolTable[Symbol];      IF ste = NIL THEN        ste ¬ SymbolTableDefs.PutInSymbolTable[          Symbol, [IOPmain[0]], UnDef, imported, FALSE, FALSE,          CodeOutputDefs.GetPC[], size, CodeOutputDefs.GetBinaryStreamIndex[]];      DO        addr ¬ GetHexNumber[str] + CurrentBase;        LookFor[str, '(];        --  Check for unreferenced imported symbols.        IF char = 'u THEN          BEGIN  --  Unreferenced imported symbol will be "Name 0000 (unreferenced)"          LookFor[str, ')];          END        ELSE          BEGIN  --  Symbol has been referenced.          IF char = 'w THEN size ¬ 2 ELSE size ¬ 1;          LookFor[str, '(];          si ¬ GetHexNumber[str];          si ¬ (si*Environment.bytesPerPage) + GetHexNumber[str];          si ¬ si + BaseSI;          SymTabIODefs.AddToUseChain[ste, si, size, addr];          char ¬ NextChar[str];          END;        char ¬ GetNonBlank[str];        IF char IN ['A..'Z] OR char IN ['a..'z] THEN EXIT;        ENDLOOP;      ENDLOOP;    EXITS Exit => NULL;    END;  ResolveExternalReferences: PROCEDURE [h: SimHashDefs.Hash] RETURNS [BOOLEAN] =    BEGIN    ste: LONG POINTER TO SymbolTableDefs.STData;    [, ste] ¬ SimHashDefs.GetInfo[h];    IF ste.type = UnDef THEN      BEGIN      IF ste.useChain = NIL THEN        SIGNAL UnreferencedSymbol[SimHashDefs.TempStringForHash[h]]      ELSE SIGNAL UndefinedSymbol[SimHashDefs.TempStringForHash[h]]      END    ELSE SymTabIODefs.ProcessUseChain[ste];    RETURN[TRUE];    END;  ProcessCommandLine: PROCEDURE [str: Stream.Handle] =    BEGIN    fname: STRING ¬ [32];    char ¬ NextChar[str];    SELECT char FROM      'F =>        BEGIN        LookFor[str, ' ];        LookFor[str, ' ];        GetName[str, fname];        MakeFTEntry[fname];        END;      'E => EndFTEntry[];      ENDCASE => NULL;    END;  ProcessOneFile: PROCEDURE [str: Stream.Handle] =    BEGIN    len, Flag, cs: CARDINAL;    c: STRING ¬ [48];    ProcessRelocationEntries[str];    ProcessSymbolTableEntries[str];    Stream.SetPosition[sH: str, position: 0];    char ¬ NextChar[str];    DO      [len, Flag, cs] ¬ GetAndUpdateCodeLine[        str, c ! CommandLine => BEGIN ProcessCommandLine[str]; RESUME ; END];      IF Flag = EOF THEN RETURN;      CodeOutputDefs.PutCodeLine[CurrentAddr, c, cs];      CurrentAddr ¬ CurrentAddr + len;      ENDLOOP;    END;  ReadCodeNumber: PROCEDURE [str: Stream.Handle] RETURNS [CARDINAL] =    BEGIN n: CARDINAL ¬ ReadCodeByte[str]; RETURN[n*256 + ReadCodeByte[str]]; END;  ReadCodeByte: PROCEDURE [str: Stream.Handle] RETURNS [CARDINAL] =    BEGIN    n: CARDINAL ¬ ReadCodeDigit[str];    RETURN[n*16 + ReadCodeDigit[str]];    END;  ReadCodeDigit: PROCEDURE [str: Stream.Handle] RETURNS [CARDINAL] =    BEGIN    char ¬ NextChar[str];    SELECT char FROM      IN ['0..'9] => RETURN[char - '0];      IN ['A..'F] => RETURN[char - 'A + 10];      IN ['a..'f] => RETURN[char - 'a + 10];      ENDCASE => SIGNAL InvalidBinderInput[1];    RETURN[0];    END;  GetHexNumber: PROCEDURE [str: Stream.Handle] RETURNS [n: CARDINAL ¬ 0] =    BEGIN    WHILE char NOT IN ['0..'9] AND char NOT IN ['A..'F] AND char NOT IN ['a..'f]      DO IF char = '/ THEN SIGNAL EndOfList; char ¬ GetNonBlank[str]; ENDLOOP;    DO      SELECT char FROM        IN ['0..'9] => n ¬ n*16 + char - '0;        IN ['A..'F] => n ¬ n*16 + char - 'A + 10;        IN ['a..'f] => n ¬ n*16 + char - 'a + 10;        ENDCASE => EXIT;      char ¬ NextChar[str];      ENDLOOP;    END;  LookFor: PROCEDURE [str: Stream.Handle, ch: CHARACTER] =    BEGIN    WHILE char # ch DO char ¬ NextChar[str]; ENDLOOP;    char ¬ NextChar[str];    END;  NoExt: PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN] =    BEGIN    FOR i: CARDINAL IN [0..s.length) DO IF s[i] = '. THEN RETURN[FALSE]; ENDLOOP;    RETURN[TRUE];    END;  ReplaceExtension: PROCEDURE [f, e: STRING] =    BEGIN    FOR i: CARDINAL IN [0..f.length) DO      IF f[i] = '. THEN        BEGIN f.length ¬ i + 1; String.AppendString[f, e]; RETURN; END;      ENDLOOP;    END;  GetNonBlank: PROCEDURE [str: Stream.Handle] RETURNS [CHARACTER] =    BEGIN    DO      char ¬ NextChar[str];      IF char # '  AND char # '\T AND char # '\N        AND char # '\L THEN RETURN[char];      ENDLOOP;    END;  GetName: PROCEDURE [str: Stream.Handle, s: LONG STRING] =    BEGIN    IF char = '  OR char = '\T OR char = '\N OR char = '\L      THEN char ¬ GetNonBlank[str];    IF char = '/ THEN SIGNAL EndOfList;    s.length ¬ 0;    WHILE char IN ['A..'Z] OR char IN ['a..'z] OR char IN ['0..'9] DO      IF s.length < s.maxlength THEN String.AppendChar[s, char];      char ¬ NextChar[str];      ENDLOOP;    END;  RemoveExtension: PROCEDURE [fname: LONG STRING] =    BEGIN    FOR i: CARDINAL IN [0..fname.length) DO      IF fname[i] = '. THEN BEGIN fname.length ¬ i; EXIT; END; ENDLOOP;    END;    GetStringOfLastEditedTime: PROCEDURE[filename:LONG STRING, timeString:LONG STRING] ={    --String body of filename  is required " xxx.bin " form.      BEGIN    mfileHandle:MFile.Handle;    lastEditedDataPacked:Time.Packed;    lastEditedDataUnpacked:Time.Unpacked;    timeString­.length ¬ 0;             mfileHandle ¬ MFile.ReadOnly[filename,,];    lastEditedDataPacked ¬ MFile.GetTimes[mfileHandle].create;    lastEditedDataUnpacked ¬ Time.Unpack[lastEditedDataPacked];     Time.Append[timeString,lastEditedDataUnpacked];     MFile.Release[mfileHandle];     mfileHandle ¬ NIL;    --timeString­.length ¬ timeString­.length - 9    END};   Bind8085: PUBLIC PROCEDURE [FileName: LONG STRING, output: Format.StringProc] =    BEGIN    firstCfgItem: BOOLEAN ¬ TRUE;    timeString:LONG STRING ¬ [32];    IF NoExt[FileName] THEN String.AppendString[FileName, ".cfg"L];    Format.Text[output, "\nConfiguration:  "L];    Format.Line[output, FileName];    IF ConfigStream ~= NIL THEN Stream.Delete[sH: ConfigStream];    ConfigStream ¬ MStream.ReadOnly[name: FileName, release: [NIL, NIL]!      MStream.Error =>        SELECT code FROM          fileNotAvailable => SIGNAL BinderFileError[FileName];          ENDCASE => REJECT;];    RemoveExtension[FileName];    SimHashDefs.Create[2];    cfgchar ¬ GetNonBlank[ConfigStream];    SELECT cfgchar FROM      '{ => NULL;      IN ['A..'Z], IN ['a..'z] =>        BEGIN        GetName[ConfigStream, OutputFile];        String.AppendString[OutputFile, ".bin"L];        IF char # ': THEN SIGNAL InvalidBinderInput[4];        cfgchar ¬ GetNonBlank[ConfigStream];        IF char # '{ THEN SIGNAL InvalidBinderInput[4];        IF BinaryStream ~= NIL THEN Stream.Delete[sH: BinaryStream];        BinaryStream ¬ MStream.ReadWrite[	  name: OutputFile, release: [NIL, NIL], type: text];        CodeOutputDefs.SetBinaryStream[BinaryStream];        NoOutputStream ¬ FALSE;        END;      ENDCASE => SIGNAL InvalidBinderInput[4];    Format.Line[output, "Building File Table..."L];    DO      ConfigItem: ItemType ¬ GetItem[ConfigStream];      WITH ConfigItem SELECT FROM        address =>          BEGIN          CurrentBase ¬ addr;          cfgchar ¬ char;          IF firstCfgItem THEN CurrentAddr ¬ addr  --  Change default start address          ELSE IF CurrentBase < CurrentAddr THEN SIGNAL InvalidBinderInput[3];          CurrentAddr ¬ CurrentBase;	  Format.Text[output, "... Set Base Address to:  "L];          PrivateStringDefs.StringFromHex[MiscString, CurrentBase];	  Format.Line[output, MiscString];          END;        file =>          BEGIN	  extensionAdded: BOOLEAN;	  Format.Text[output, "... Module:  "L];	  Format.Text[output, BinFileName];	  Format.Text[output," of "L];	  IF (extensionAdded ¬ NoExt[s: BinFileName]) THEN String.AppendString[BinFileName,".bin"L];	  GetStringOfLastEditedTime[BinFileName, timeString];	  IF extensionAdded THEN RemoveExtension[fname: BinFileName];	  Format.Text[output, timeString];	  Format.Text[output, "... Base address is:  "L];          PrivateStringDefs.StringFromHex[MiscString, CurrentBase];	  Format.Line[output, MiscString];          afn ¬ 0;          MakeFTEntry[BinFileName];          IF NoOutputStream THEN SetUpOutputStream[FileName];          ProcessOneFile[stream];          EndFTEntry[];          CurrentBase ¬ CurrentAddr;          LastAddr ¬ CurrentAddr - 1;  --  Set value of last address used          BaseSI ¬ CodeOutputDefs.GetBinaryStreamIndex[];          Stream.Delete[sH: stream];          END;        eof => EXIT;        ENDCASE => NULL;      firstCfgItem ¬ FALSE;      ENDLOOP;    Stream.Delete[sH: ConfigStream];    ConfigStream ¬ NIL;    Format.Text[output, "... Last address used:  "L];    PrivateStringDefs.StringFromHex[MiscString, LastAddr];    Format.Line[output, MiscString];    Format.Text[output, "\nResolving external references... "L];    [] ¬ SimHashDefs.EnumerateEntries[ResolveExternalReferences];    Format.Line[output, "... done."L];    CodeOutputDefs.PutEOFLine[];    CodeOutputDefs.ReleaseMapChain[];    Format.Text[output, "Writing File Map... "L];    PutFTEntries[FileName];    MStream.SetLength[      stream: BinaryStream, fileLength: Stream.GetPosition[sH: BinaryStream]];    Stream.Delete[sH: BinaryStream];    BinaryStream ¬ NIL;    Format.Line[output, "... done."L];    -- the following code tidies things up for a possible repeat bind    afn ¬ level ¬ 0;    char ¬ cfgchar ¬ '\N;    CurrentBase ¬ CurrentAddr ¬ DefaultAddress;    BaseSI ¬ 0;    END;  ReInit: PUBLIC PROC =    BEGIN    CurrentBase ¬ CurrentAddr ¬ LastAddr ¬ DefaultAddress;    char ¬ cfgchar ¬ '\N;    ConfigStream ¬ BinaryStream ¬ NIL;    BaseSI ¬ 0;    RelocChain ¬ NIL;    NoOutputStream ¬ TRUE;    FileTable ¬ NIL;    afn ¬ level ¬ 0;    END;  Init: PROC =    BEGIN    CurrentBase ¬ CurrentAddr ¬ LastAddr ¬ DefaultAddress;    MiscString ¬ Heap.systemZone.NEW[StringBody[48]];    BinFileName ¬ Heap.systemZone.NEW[StringBody[32]];    OutputFile ¬ Heap.systemZone.NEW[StringBody[32]];    char ¬ cfgchar ¬ '\N;    ConfigStream ¬ BinaryStream ¬ NIL;    BaseSI ¬ 0;    RelocChain ¬ NIL;    NoOutputStream ¬ TRUE;    FileTable ¬ NIL;    afn ¬ level ¬ 0;    END;  Init[];  END...    -- LOG  --   ETN      - 12-Apr-82 10:48:22 - Convert to Trinity.   --   ETN      - 19-Apr-82 10:11:55 - Fix Pad Bug.   --   ETN      -  4-Oct-82 16:33:38 - Fix Alto compatability.  --   DEG     	- 13-Jan-83 15:14:52 - Convert to Sierra  --   ETN   	- 25-Jan-83 13:38:54 - Heap.systemZone.NEW => Storage.String  --   DEG      - 31-Jan-83  6:44:38 - Replace TTY with Format  --   DEG      - 30-May-83 15:43:55 - Remove references to the Ascii interface  --   DEG      - 16-Sep-83  0:30:33 - Converted to Klamath 11.0b  --   KxI      - 16-Jan-84 18:23:05 - Add edited Time to Logfile  --   DEG      & KxI      -  5-Mar-84 14:26:17 - fix output to .fm file so as not to confuse Burdock.  -- Time: 26-Sep-84 23:03:19	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
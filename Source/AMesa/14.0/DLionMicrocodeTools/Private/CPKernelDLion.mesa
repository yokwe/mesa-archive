-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- CPKernelDLion.mesa, HGM, 21-Jan-84 14:46:15DIRECTORY  Environment USING [Block, Byte],  Inline USING [BITAND, BITOR, BITSHIFT, HighByte, HighHalf, LowByte, LowHalf],  Runtime USING [GetTableBase],  BurdockTables USING [    KernelDLion, KernelHighDLion, ReadLinkDLion, ResetMapDLion, WriteBlockDLion],  CP USING [    Bank, BankAndWordsPerBank, Cycle, Link, numberOfBanks,    RealCS, UReg, Task, wordsPerBank],  CPKernel USING [Error, Machine, State],  CPKernelConstants ,  CPKernelOps USING [    AddressOutOfRange, DataOutOfRange, LoadFromMemory, LoadOverlay,    PrepareToContinueAfterBreak, ReadCSInternal, ReadURegInternal,    SaveCurrentBreakID, WriteCSInternal, WriteIOOutInternal],  CPMI USING [AD, AF, AS, FS01, FS23, FX, FY, FYNorm, FZ, MI],  IOPKernel USING [Error, State],  IOPKernelOps USING [    BootInternal, Command, GetBootSeqInternal, GetCPData, GetStateInternal,    InitializeLock, IOPRetransmit, lock, NeedForCPToRetransmit, ProbeForStateChangeInternal,    ReadByteInternal, ReadWordInternal, StopInternal,    WriteBlockInternal, WriteByteInternal, WriteCommandInternal, WriteWordInternal];CPKernelDLion: MONITOR LOCKS IOPKernelOps.lock  IMPORTS    Inline, Runtime,    BurdockTables, CPKernel, CPKernelOps, IOPKernel, IOPKernelOps  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelConstants;    machine: PUBLIC CPKernel.Machine ¬ dlion;  maxBreaks: PUBLIC CARDINAL ¬ 16;      Command: TYPE = MACHINE DEPENDENT {exitKernel(0), refresh(1), writeU(2), executeBuffer(3)};  state: CPKernel.State ¬ dead;  seq, boot, iopBoot: CARDINAL ¬ 0;  kernelLoaded: BOOLEAN ¬ FALSE;  currentBank, savedBank: CARDINAL ¬ 0;  banksThisMachine: CARDINAL ¬ 0;    InKernel: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] =    BEGIN ENABLE UNWIND => NULL;    RETURN[SELECT state FROM      dead => FALSE,      halted => TRUE,      running => FALSE,      cpBreak, iopStopped => TRUE,      ENDCASE => ERROR ];    END;        GetState: PUBLIC ENTRY PROCEDURE RETURNS [CPKernel.State] =    BEGIN    RETURN[state];    END;  GetStateInternal: PUBLIC INTERNAL PROCEDURE RETURNS [CPKernel.State] =    BEGIN    RETURN[state];    END;  GetStateSeq: PUBLIC ENTRY PROCEDURE RETURNS [CARDINAL] =    BEGIN    RETURN[seq];    END;    GetBootSeq: PUBLIC ENTRY PROCEDURE RETURNS [CARDINAL] =    BEGIN    RETURN[boot];    END;    ProbeForStateChange: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    iop: IOPKernel.State;    IF iopBoot # IOPKernelOps.GetBootSeqInternal[] THEN      BEGIN      iopBoot ¬ IOPKernelOps.GetBootSeqInternal[];      SetNewState[dead];      RETURN;      END;    IF state = dead THEN RETURN;  -- Who cares what it's doing?    IOPKernelOps.ProbeForStateChangeInternal[];    iop ¬ IOPKernelOps.GetStateInternal[];    SELECT iop FROM      dead => BEGIN MaybeSetNewState[dead]; RETURN; END;      booted =>        BEGIN	temp: WORD;	IF state # running THEN RETURN;	-- Check for Break (the hard way) when no IOP program has been loaded	WriteIOPCommand[pollIOP];	temp ¬ ReadIOPByte[];	SELECT temp FROM	  0 => RETURN;	  374B => -- IOPKernelOps.Response[cpBreak]	    BEGIN	    savedBank ¬ currentBank ¬ ReadBankInternal[];	    CPKernelOps.SaveCurrentBreakID[];	    SetNewState[cpBreak];	    END;	  ENDCASE => ERROR CPKernel.Error["Unreasonable response byte from IOP"L];	END;      running => RETURN;  -- It will tell us if it gets a CP Break      halted, iopBreak =>        BEGIN        IF state = running THEN          BEGIN          WriteIOPCommand[haltCP];	  savedBank ¬ currentBank ¬ ReadBankInternal[];          SetNewState[iopStopped];          END;	END;      cpStop =>        BEGIN 	SELECT state FROM	  halted, cpBreak => RETURN;	  running, iopStopped => 	    BEGIN	    savedBank ¬ currentBank ¬ ReadBankInternal[];	    CPKernelOps.SaveCurrentBreakID[];	    SetNewState[cpBreak];	    END;	  ENDCASE => SetNewState[dead];	END;      ENDCASE => ERROR;    END;    Boot: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    SetNewState[dead];    boot ¬ boot + 1;    iopBoot ¬ IOPKernelOps.GetBootSeqInternal[];    kernelLoaded ¬ FALSE;    currentBank ¬ savedBank ¬ 0;    banksThisMachine ¬ 1;    END;    HalfBoot: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    SetNewState[dead];    boot ¬ boot + 1;    IOPKernelOps.BootInternal[ ! IOPKernel.Error => ERROR CPKernel.Error[reason] ];    iopBoot ¬ IOPKernelOps.GetBootSeqInternal[];    kernelLoaded ¬ FALSE;    currentBank ¬ savedBank ¬ 0;    banksThisMachine ¬ 1;    SetNewState[halted];    END;    FindBanks: PUBLIC ENTRY PROCEDURE RETURNS [CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    banksThisMachine ¬ CP.numberOfBanks;  -- Bypass error trap    FOR bank: CP.Bank IN [1..CP.numberOfBanks) DO      cs: CP.RealCS = bank * CP.wordsPerBank + kBuffer + 2;  -- SetNewBank uses kBuffer[0..1]      Three: TYPE = RECORD [a, b, c: WORD];      address: CPMI.MI = LOOPHOLE[Three[cs, 0, cs]];  -- parity      CPKernelOps.WriteCSInternal[cs, address];      IF CPKernelOps.ReadCSInternal[kBuffer + 2] = address THEN        BEGIN	IF bank # 1 THEN ERROR CPKernel.Error["Bank searching mixup - write smashed bank 0"L];	RETURN[banksThisMachine ¬ 1];	END;      IF CPKernelOps.ReadCSInternal[cs] # address THEN        BEGIN	RETURN[banksThisMachine ¬ bank];	END;      ENDLOOP;    RETURN[banksThisMachine ¬ CP.numberOfBanks];    END;    Reset: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    SetNewState[dead];    boot ¬ boot + 1;    savedBank ¬ 0;    iopBoot ¬ IOPKernelOps.GetBootSeqInternal[];    FOR task: CP.Task IN [0..5] DO      WriteTpcInternal[task, kIdle];  -- GOTO[kIdle]      ENDLOOP;    SetNewState[halted];    END;    LoadKernel: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    SetNewBank[0];    CPKernelOps.LoadFromMemory[Runtime.GetTableBase[BurdockTables.KernelDLion], 0];    END;    LoadKernelHigh: PUBLIC ENTRY PROCEDURE [bank: CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    SetNewBank[bank];    CPKernelOps.LoadFromMemory[Runtime.GetTableBase[BurdockTables.KernelHighDLion], bank];    END;    StartKernel: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    WriteIOPCommand[startKernel];    SetNewState[halted];    kernelLoaded ¬ TRUE;    END;    Continue: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    RestoreCPPort[];    SetNewBank[savedBank];    SetupToGetBackToBank0[];    WriteIOPCommand[startCP];    SetNewState[running];    END;    ContinueAfterBreak: PUBLIC ENTRY PROCEDURE [    mi: CPMI.MI, cycle: CP.Cycle, task: CP.Task] =    BEGIN ENABLE UNWIND => NULL;    RestoreCPPort[];    CPKernelOps.PrepareToContinueAfterBreak[mi, cycle, task, savedBank];    SetNewBank[savedBank];   -- noop if emulator since side effect of writing patch    SetupToGetBackToBank0[];    WriteIOPCommand[startCP];    SetNewState[running];    END;  Stop: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    SELECT state FROM      dead => ERROR CPKernel.Error["CP/IOP is dead"L];      halted => RETURN;      running => NULL;      cpBreak, iopStopped => RETURN;      ENDCASE => ERROR;    IOPKernelOps.StopInternal[ ! IOPKernel.Error => ERROR CPKernel.Error[reason] ];    WriteIOPCommand[haltCP];    savedBank ¬ currentBank ¬ ReadBankInternal[];    SetNewState[halted];    END;    MaybeSetNewState: INTERNAL PROCEDURE [new: CPKernel.State] =    BEGIN    IF state = new THEN RETURN;    SetNewState[new];    END;    SetNewState: PUBLIC INTERNAL PROCEDURE [new: CPKernel.State] =    BEGIN    seq ¬ seq + 1;    state ¬ new;    END;  WriteCPCommand: PUBLIC INTERNAL PROCEDURE [command: Command] =    BEGIN    WriteByteInternal[LOOPHOLE[command]];    END;    WriteIOPCommand: PUBLIC INTERNAL PROCEDURE [command: IOPKernelOps.Command] =    BEGIN    IOPKernelOps.WriteCommandInternal[command ! IOPKernel.Error => ERROR CPKernel.Error[reason] ];    END;    WriteByteInternal: PUBLIC INTERNAL PROCEDURE [data: Environment.Byte] =    BEGIN    IOPKernelOps.WriteByteInternal[data ! IOPKernel.Error => ERROR CPKernel.Error[reason] ];    END;      WriteWordInternal: PUBLIC INTERNAL PROCEDURE [data: WORD] =    BEGIN    IOPKernelOps.WriteWordInternal[data ! IOPKernel.Error => ERROR CPKernel.Error[reason] ];    END;      ReadWordInternal: PUBLIC INTERNAL PROCEDURE RETURNS [WORD] =    BEGIN    RETURN[IOPKernelOps.ReadWordInternal[ ! IOPKernel.Error => ERROR CPKernel.Error[reason] ]];    END;      ReadCPByte: PUBLIC INTERNAL PROCEDURE RETURNS [Environment.Byte] =    BEGIN    WriteIOPCommand[readPort];    RETURN[ReadIOPByte[]];    END;    ReadIOPByte: INTERNAL PROCEDURE RETURNS [Environment.Byte] =    BEGIN    RETURN[IOPKernelOps.ReadByteInternal[ ! IOPKernel.Error => ERROR CPKernel.Error[reason] ]];    END;  WriteBank: PUBLIC ENTRY PROCEDURE [bank: CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    WriteBankInternal[bank];    END;  RawWriteBank: PUBLIC ENTRY PROCEDURE [bank: CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    -- Yetch, copy all this code to avoid error trap    IF (kBuffer + 11) # 0FFFH THEN ERROR;  -- Catch dangling branch    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't switch banks until Kernel has been loaded"L];    IF currentBank # 0 THEN      BEGIN      currentBank ¬ 0;      ExecuteCPBuffer[];  -- The instruction we left behind      END;    IF bank = 0 THEN RETURN;    CPKernelOps.WriteCSInternal[      kBuffer + 0, CPMI.MI[      , , dz, rOrS, , , , , , , nibble, , [n[bank]], [d[0]], kWait]];    CPKernelOps.WriteCSInternal[      kBuffer + 1, CPMI.MI[      , , dz, rOrS, , , , , , , nibble, , [n[bank]], [d[bank]], kBuffer + 11]];    CPKernelOps.WriteCSInternal[      kBuffer + 11, CPMI.MI[      , , , , , , , , , , , , , , kWait]];    WriteTpcInternal[7, kBuffer + 1];    currentBank ¬ bank;    END;  WriteBankInternal: INTERNAL PROCEDURE [bank: CP.Bank] =    BEGIN    SetNewBank[bank];  -- Validity check    savedBank ¬ bank;    END;  SetupToGetBackToBank0: INTERNAL PROCEDURE =    BEGIN    IF banksThisMachine = 1 THEN RETURN;    IF currentBank # 0 THEN RETURN;    CPKernelOps.WriteCSInternal[      kBuffer + 0, CPMI.MI[      , , dz, rOrS, , , , , , , nibble, , [n[bank]], [d[0]], kWait]];    END;  SetNewBank: PUBLIC INTERNAL PROCEDURE [bank: CP.Bank] =    BEGIN    IF (kBuffer + 11) # 0FFFH THEN ERROR;  -- Catch dangling branch    IF bank = currentBank THEN RETURN;    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't switch banks until Kernel has been loaded"L];    IF bank >= banksThisMachine THEN ERROR CPKernel.Error["Bank number too big"L];    IF currentBank # 0 THEN      BEGIN      currentBank ¬ 0;      ExecuteCPBuffer[];  -- The instruction we left behind      END;    IF bank = 0 THEN RETURN;    SetupToGetBackToBank0[];    CPKernelOps.WriteCSInternal[      kBuffer + 1, CPMI.MI[      , , dz, rOrS, , , , , , , nibble, , [n[bank]], [d[bank]], kBuffer + 11]];    CPKernelOps.WriteCSInternal[      kBuffer + 11, CPMI.MI[      , , , , , , , , , , , , , , kWait]];    WriteTpcInternal[7, kBuffer + 1];    currentBank ¬ bank;    END;  ExecuteCPBuffer: PUBLIC INTERNAL PROCEDURE =    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    block: Environment.Block ¬ [LOOPHOLE[LONG[@temp]], 0, 2];    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't Execute Buffer before Kernel loaded"L];    IF currentBank # 0 THEN ERROR CPKernel.Error["Can't Execute Buffer in wrong bank"L];    IF FALSE THEN      BEGIN      WriteIOPCommand[writePort];      WriteCPCommand[executeBuffer];      RETURN;      END;    temp[0] ¬ LOOPHOLE[IOPKernelOps.Command[writePort]];    temp[1] ¬ LOOPHOLE[Command[executeBuffer]];    IOPKernelOps.WriteBlockInternal[block ! IOPKernel.Error => ERROR CPKernel.Error[reason] ];    END;  WriteUSpecial: PUBLIC INTERNAL PROCEDURE [u: CP.UReg, data: WORD] =    BEGIN    temp: PACKED ARRAY [0..8) OF Environment.Byte;    block: Environment.Block ¬ [LOOPHOLE[LONG[@temp]], 0, 8];    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't WriteU before Kernel loaded"L];    IF FALSE THEN      BEGIN      WriteIOPCommand[writePort];      WriteCPCommand[writeU];      WriteIOPCommand[writePort];      WriteByteInternal[Inline.HighByte[data]];      WriteIOPCommand[writePort];      WriteByteInternal[Inline.LowByte[data]];      WriteIOPCommand[writePort];      WriteByteInternal[u];      RETURN;      END;    temp ¬ [      LOOPHOLE[IOPKernelOps.Command[writePort]],      LOOPHOLE[Command[writeU]],      LOOPHOLE[IOPKernelOps.Command[writePort]],      Inline.HighByte[data],      LOOPHOLE[IOPKernelOps.Command[writePort]],      Inline.LowByte[data],      LOOPHOLE[IOPKernelOps.Command[writePort]],      u];    IOPKernelOps.WriteBlockInternal[block ! IOPKernel.Error => ERROR CPKernel.Error[reason] ];    END;     TcAndTpc: TYPE = RECORD [tc: CP.Task, tpc: [0..CP.wordsPerBank)];  ReadTpc: PUBLIC ENTRY PROCEDURE [task: CP.Task] RETURNS [CP.RealCS] =    BEGIN ENABLE UNWIND => NULL;    data: CP.BankAndWordsPerBank;    IF task ~IN CP.Task THEN CPKernelOps.AddressOutOfRange[];    WriteIOPCommand[readTPC];    WriteByteInternal[task];  -- 3 bits tpc address    data ¬ LOOPHOLE[ReadWordInternal[]];    IF task # 0 OR banksThisMachine = 1 THEN RETURN[data.wordInBank];    RETURN[savedBank*CP.wordsPerBank + data.wordInBank];    END;   ReadBank: PUBLIC ENTRY PROCEDURE RETURNS [CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    RETURN[savedBank];    END;   RawReadBank: PUBLIC ENTRY PROCEDURE RETURNS [CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadBankInternal[]];    END;   ReadBankInternal: INTERNAL PROCEDURE RETURNS [CP.Bank] =    BEGIN    data: CP.BankAndWordsPerBank;    IF banksThisMachine = 1 THEN RETURN[0];    WriteIOPCommand[readTPC];    WriteByteInternal[0];  -- 3 bits tpc address    data ¬ LOOPHOLE[ReadWordInternal[]];    RETURN[Inline.BITAND[data.bank, 3]];  -- Yetch, only 2 bits come back    END;   WriteTpc: PUBLIC ENTRY PROCEDURE [task: CP.Task, pc: CP.RealCS] =    BEGIN ENABLE UNWIND => NULL;    WriteTpcInternal[task, pc];    END;   WriteTpcInternal: PUBLIC INTERNAL PROCEDURE [task: CP.Task, pc: CP.RealCS] =    BEGIN ENABLE UNWIND => NULL;    data: CP.BankAndWordsPerBank = LOOPHOLE[pc];    IF task ~IN CP.Task THEN CPKernelOps.AddressOutOfRange[];    IF pc ~IN CP.RealCS THEN CPKernelOps.DataOutOfRange[];    IF task # 0 AND data.bank # 0 THEN CPKernelOps.DataOutOfRange[];    WriteIOPCommand[writeTPC];    WriteByteInternal[task];  -- 3 bits tpc address    WriteWordInternal[data.wordInBank];    IF task = 0 AND banksThisMachine > 1 THEN savedBank ¬ data.bank;    END;   ReadTc: PUBLIC ENTRY PROCEDURE [task: CP.Task] RETURNS [Nibble] =    BEGIN ENABLE UNWIND => NULL;    data: TcAndTpc;    IF task ~IN CP.Task THEN CPKernelOps.AddressOutOfRange[];    IF banksThisMachine > 1 THEN ERROR CPKernel.Error["Can't read TC bits if banks > 1"L];    WriteIOPCommand[readTPC];    WriteByteInternal[task];    data ¬ LOOPHOLE[ReadWordInternal[]];    RETURN[data.tc]    END;   WriteTc: PUBLIC PROCEDURE [task: CP.Task, tc: Nibble] =    BEGIN    ERROR CPKernel.Error["Can't write TC bits"L];    END;	  RestoreCPPort: INTERNAL PROCEDURE =    BEGIN    flag: WORD ¬ CPKernelOps.ReadURegInternal[uIOPStatusSave];    IF Inline.BITAND[flag, uIOPIDataFull] # 0 THEN      IOPKernelOps.IOPRetransmit[CPKernelOps.ReadURegInternal[uIOPIDataSave]];    IF IOPKernelOps.NeedForCPToRetransmit[] THEN      CPKernelOps.WriteIOOutInternal[0, IOPKernelOps.GetCPData[]];    END;        WriteMemoryBlock: PUBLIC ENTRY PROCEDURE [    to: LONG POINTER, count: CARDINAL, data: LONG POINTER] =    BEGIN ENABLE UNWIND => NULL;    CPKernelOps.LoadOverlay[Runtime.GetTableBase[BurdockTables.WriteBlockDLion]];    WriteNextMemoryBlockInternal[to, count, data];    END;  WriteNextMemoryBlock: PUBLIC ENTRY PROCEDURE [    to: LONG POINTER, count: CARDINAL, data: LONG POINTER] =    BEGIN ENABLE UNWIND => NULL;    WriteNextMemoryBlockInternal[to, count, data];    END;  WriteNextMemoryBlockInternal: INTERNAL PROCEDURE [    to: LONG POINTER, count: CARDINAL, data: LONG POINTER] =    BEGIN    bufferWords: CARDINAL = 600;    block: Environment.Block;    IF Inline.HighHalf[to] ~IN [0..3] THEN CPKernelOps.AddressOutOfRange[];  --18 bit addr    WriteUSpecial[uKCount, count];    WriteUSpecial[uKAddr, Inline.LowHalf[to]];    WriteUSpecial[uKernMD, Inline.HighHalf[to]];  --must be last, loads RHrk    ExecuteCPBuffer[];    WriteIOPCommand[sendCPBlock];    WriteWordInternal[2*count];    IF FALSE THEN      BEGIN      FOR i: CARDINAL IN [0..count) DO        WriteWordInternal[(data+i)­];        ENDLOOP;      RETURN;      END;    UNTIL count < bufferWords DO      block ¬ [data, 0, 2*bufferWords];      IOPKernelOps.WriteBlockInternal[block ! IOPKernel.Error => ERROR CPKernel.Error[reason] ];      data ¬ data + bufferWords;      count ¬ count - bufferWords;      ENDLOOP;    IF count # 0 THEN      BEGIN      block ¬ [data, 0, 2*count];      IOPKernelOps.WriteBlockInternal[block ! IOPKernel.Error => ERROR CPKernel.Error[reason] ];      END;    END;            ResetMap: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    CPKernelOps.LoadOverlay[Runtime.GetTableBase[BurdockTables.ResetMapDLion]];    ExecuteCPBuffer[];    --this takes ~5 msec, overlay sends a byte when done to synchronize    [] ¬ ReadCPByte[]    END;      ReadLink: PUBLIC ENTRY PROCEDURE [link: CP.Link] RETURNS [data: Nibble] =    BEGIN ENABLE UNWIND => NULL;    -- Link is read in three parts: Link[2-3], Link[0], & Link[1].    -- Link[0] & Link[1] are read by 1-inst overlays at kBuffer+1.    --kBuffer: pRet0,				c1, at[kBuffer];    --	       DISP2[KLinkC, C],		c2, at[0FF5x] {+1};    --KLink7:  IOPOData¬ 0, GOTO[kWait],	c3, at[0FF7x] {+3};    --KLinkB:  IOPOData¬ 0, GOTO[kWait],	c3, at[0FFBx] {+7};    --KLinkC:  IOPOData¬ 0, GOTO[kWait],	c3, at[0FFCx] {+8};    --         IOPOData¬ 1, GOTO[kWait],	c3, at[0FFDx] {+9};    --         IOPOData¬ 2, GOTO[kWait],	c3, at[0FFEx] {+A};    --KLinkF:  IOPOData¬ 3, GOTO[kWait],	c3, at[0FFFx] {+B};    --         BRANCH[KLink7, KLinkF, 7], at[kBufferExten];   {Get Link[0]}    --         BRANCH[KLinkB, KLinkF, 0B], at[kBufferExten+1];   {Get Link[1]}    IF link ~IN CP.Link THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.LoadOverlay[Runtime.GetTableBase[BurdockTables.ReadLinkDLion]];    CPKernelOps.WriteCSInternal[kBuffer, CPMI.MI[      , , , , , , , , , , , LOOPHOLE[link], , , kBuffer+1]];    ExecuteCPBuffer[];    data ¬ ReadCPByte[];  -- Link[2-3]    CPKernelOps.WriteCSInternal[kBuffer + 1, CPMI.MI[      , , , , , , , , , , , , , , kBuffer+3]];    ExecuteCPBuffer[];    data ¬ Inline.BITOR[data, Inline.BITSHIFT[Inline.BITAND[ReadCPByte[], 1], 3]];  -- Link[0]    CPKernelOps.WriteCSInternal[kBuffer + 1, CPMI.MI[      , , , , , , , , , , , , , , kBuffer+7]];    ExecuteCPBuffer[];    data ¬ Inline.BITOR[data, Inline.BITSHIFT[Inline.BITAND[ReadCPByte[], 1], 2]];  --Link[1]    END;    [] ¬ IOPKernelOps.InitializeLock[];  END.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- UmbilicalDLion.mesa, HGM,  4-Oct-83 23:33:52DIRECTORY  DLionInputOutput USING [IOPage, processorCommandOffset, processorCSBOffset],  Environment USING [Block, Byte],  Inline USING [BITAND, BytePair, HighByte, HighHalf, LowByte, LowHalf],  Process USING [MsecToTicks, Pause],    Umbilical USING [];UmbilicalDLion: PROGRAM  IMPORTS DLionInputOutput, Inline, Process  EXPORTS Umbilical =  BEGIN  Timeout: PUBLIC ERROR = CODE;  Initialize: PUBLIC PROCEDURE RETURNS [ok: BOOLEAN] =    BEGIN    temp: WORD;    WriteIOP[ppiCtl, ppiTest];    WriteIOP[ppiA, 0];    temp ¬ ReadIOP[ppiA];    IF temp # 0 THEN RETURN[FALSE];    WriteIOP[ppiA, 0FFH];    temp ¬ ReadIOP[ppiA];    IF temp # 0FFH THEN RETURN[FALSE];    WriteIOP[ppiCtl, ppiInit];    WriteIOP[ppiCtl, ppiEnableA];    WriteIOP[ppiCtl, ppiEnableB];    [] ¬ ReadIOP[ppiB];  -- Discard garbage byte (if any)    RETURN[TRUE];    END;  Boot: PUBLIC PROCEDURE =    BEGIN    WriteIOP[ppiCtl, ppiSetBoot];    Process.Pause[Process.MsecToTicks[50]+1];  -- Beware of partial ticks    [] ¬ ReadIOP[ppiB];  -- Discard garbage byte (if any)    WriteIOP[ppiCtl, ppiClearBoot];    END;      WriteByte: PUBLIC PROCEDURE [data: Environment.Byte] =    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    IF FALSE THEN      BEGIN      temp: WORD;      WriteIOP[ppiA, data];      FOR i: CARDINAL IN [0..500) DO  -- ~ 1 second        temp ¬ ReadIOP[ppiC];        IF Inline.BITAND[temp, intAMask] # 0 THEN EXIT;        REPEAT FINISHED => ERROR Timeout;        ENDLOOP;      RETURN;      END;    temp[0] ¬ Inline.LowByte[data];    WriteUmbilicalBlock[@temp, 1];    END;  WriteWord: PUBLIC PROCEDURE [data: WORD] =    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    IF FALSE THEN      BEGIN      WriteByte[Inline.LowByte[data]];      WriteByte[Inline.HighByte[data]];      RETURN;      END;    temp[0] ¬ Inline.LowByte[data];    temp[1] ¬ Inline.HighByte[data];    WriteUmbilicalBlock[@temp, 2];    END;  WriteBlock: PUBLIC PROCEDURE [finger: Environment.Block] =    BEGIN    maxBytesPerClump: CARDINAL = 254;    IF finger.startIndex >= finger.stopIndexPlusOne THEN ERROR;    IF (finger.startIndex MOD 2) # 0 THEN      BEGIN      WriteByte[finger.blockPointer[finger.startIndex]];      finger.startIndex ¬ finger.startIndex + 1;      END;    IF finger.startIndex # 0 THEN      BEGIN      finger.blockPointer ¬ finger.blockPointer + finger.startIndex/2;      finger.stopIndexPlusOne ¬ finger.stopIndexPlusOne - finger.stopIndexPlusOne;      END;    UNTIL finger.stopIndexPlusOne < maxBytesPerClump DO      WriteUmbilicalBlock[finger.blockPointer, maxBytesPerClump];      finger.blockPointer ¬ finger.blockPointer + maxBytesPerClump/2;      finger.stopIndexPlusOne ¬ finger.stopIndexPlusOne - maxBytesPerClump      ENDLOOP;    IF finger.stopIndexPlusOne # 0 THEN      WriteUmbilicalBlock[finger.blockPointer, finger.stopIndexPlusOne];    END;  ReadReady: PUBLIC PROCEDURE RETURNS[BOOLEAN] =    BEGIN    temp: WORD ¬ ReadIOP[ppiC];    RETURN[Inline.BITAND[temp, intBMask] # 0];    END;  ReadByte: PUBLIC PROCEDURE RETURNS [Environment.Byte] =    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    IF FALSE THEN      BEGIN      temp: WORD;      FOR i: CARDINAL IN [0..500) DO  -- ~ 1 second        temp ¬ ReadIOP[ppiC];        IF Inline.BITAND[temp, intBMask] # 0 THEN EXIT;        REPEAT FINISHED => ERROR Timeout;        ENDLOOP;      RETURN[ReadIOP[ppiB]];      END;    ReadUmbilicalBlock[@temp, 1];    RETURN[temp[0]];    END;    ReadWord: PUBLIC PROCEDURE RETURNS [WORD] =    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    bytes: Inline.BytePair;    IF FALSE THEN      BEGIN      bytes.low ¬ ReadByte[];      bytes.high ¬ ReadByte[];      RETURN[LOOPHOLE[bytes]];      END;    ReadUmbilicalBlock[@temp, 2];    bytes.low ¬ temp[0];    bytes.high ¬ temp[1];    RETURN[LOOPHOLE[bytes]];    END;    ReadBlock: PUBLIC PROCEDURE [finger: Environment.Block] =    BEGIN    maxBytesPerClump: CARDINAL = 254;    IF finger.startIndex >= finger.stopIndexPlusOne THEN ERROR;    IF (finger.startIndex MOD 2) # 0 THEN      BEGIN      finger.blockPointer[finger.startIndex] ¬ ReadByte[];      finger.startIndex ¬ finger.startIndex + 1;      END;    IF finger.startIndex # 0 THEN      BEGIN      finger.blockPointer ¬ finger.blockPointer + finger.startIndex/2;      finger.stopIndexPlusOne ¬ finger.stopIndexPlusOne - finger.stopIndexPlusOne;      END;    UNTIL finger.stopIndexPlusOne < maxBytesPerClump DO      ReadUmbilicalBlock[finger.blockPointer, maxBytesPerClump];      finger.blockPointer ¬ finger.blockPointer + maxBytesPerClump/2;      finger.stopIndexPlusOne ¬ finger.stopIndexPlusOne - maxBytesPerClump      ENDLOOP;    IF finger.stopIndexPlusOne # 0 THEN      ReadUmbilicalBlock[finger.blockPointer, finger.stopIndexPlusOne];    END;  ppiBase: CARDINAL = 100200B;  -- Hex 8080  ppiA: CARDINAL = ppiBase + 0;  ppiB: CARDINAL = ppiBase + 1;  ppiC: CARDINAL = ppiBase + 2;  ppiCtl: CARDINAL = ppiBase + 3;  ppiTest: CARDINAL = 202B;  -- Mode 0  ppiInit: CARDINAL = 246B;  -- Hex A6  ppiEnableA: CARDINAL = 15B; -- Hex 0D  ppiEnableB: CARDINAL = 5;  ppiSetBoot: CARDINAL = 9;  ppiClearBoot: CARDINAL = 8;  intAMask: CARDINAL = 10B;  -- Hex 8  intBMask: CARDINAL = 1;  ProcessorCommand: TYPE = MACHINE DEPENDENT {    null(0), readIOPByte(5), writeIOPByte(6), readUmbilicalBlock(7), writeUmbilicalBlock(8)};  pProcessorCommand: LONG POINTER TO ProcessorCommand = DLionInputOutput.IOPage + DLionInputOutput.processorCommandOffset;  ProcessorCSB: TYPE = MACHINE DEPENDENT RECORD [    data2(0): WORD,    data1(1): WORD,      data0(2): WORD];  pProcessorCSB: LONG POINTER TO ProcessorCSB = DLionInputOutput.IOPage + DLionInputOutput.processorCSBOffset;  ReadIOP: PROCEDURE [address: CARDINAL] RETURNS [Environment.Byte] =    BEGIN    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ address;    pProcessorCommand­ ¬ readIOPByte;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    RETURN[Inline.LowByte[pProcessorCSB.data1]];    END;    ReadUmbilicalBlock: PROCEDURE [dataPtr: LONG POINTER, size: [0..0FFH]] =    BEGIN    before, after: ProcessorCSB;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ size;    pProcessorCSB.data1 ¬ Inline.LowHalf[dataPtr];    pProcessorCSB.data0 ¬ Inline.HighHalf[dataPtr];    before ¬ pProcessorCSB­;  -- Debugging    pProcessorCommand­ ¬ readUmbilicalBlock;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    after ¬ pProcessorCSB­;  -- Debugging    IF pProcessorCSB.data0 # 0 THEN ERROR Timeout;    END;      WriteIOP: PROCEDURE [address: CARDINAL, data: Environment.Byte] =    BEGIN    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ address;    pProcessorCSB.data1 ¬ data;    pProcessorCommand­ ¬ writeIOPByte;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    END;      WriteUmbilicalBlock: PROCEDURE [dataPtr: LONG POINTER, size: [0..0FFH]] =    BEGIN    before, after: ProcessorCSB;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ size;    pProcessorCSB.data1 ¬ Inline.LowHalf[dataPtr];    pProcessorCSB.data0 ¬ Inline.HighHalf[dataPtr];    before ¬ pProcessorCSB­;  -- Debugging    pProcessorCommand­ ¬ writeUmbilicalBlock;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    after ¬ pProcessorCSB­;  -- Debugging    IF pProcessorCSB.data0 # 0 THEN ERROR Timeout;    END;      END....
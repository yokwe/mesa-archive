-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- CPSymboler.mesa, HGM,  7-Feb-85  2:06:08DIRECTORY  Heap USING [Create],  Inline USING [LowHalf],  String USING [AppendChar, AppendLongNumber, AppendNumber, AppendString],    CP USING [    Bank, BankAndWordsPerBank, Cycle, IOReg, Link, Map, OtherReg,    RealCS, RealMemory, RReg, Task, UReg, VirturalMemory, wordsPerBank],  CPMI USING [MI],  CPSymbols USING [nullRealCS, nullVirturalCS, Symbol, VirturalCS],  SymHash USING [    Create, EnumerateEntries, GetInfo, GetString,    Handle, Hash, Insert, Lookup, nullHash, PutInfo, Reset];CPSymboler: MONITOR  IMPORTS Heap, Inline, String, SymHash  EXPORTS CPSymbols =  BEGIN    WordInBank: TYPE = [0..CP.wordsPerBank);  z: UNCOUNTED ZONE = Heap.Create[10];    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    csSymbols: SymHash.Handle ¬ SymHash.Create[100];  rRegSymbols: SymHash.Handle ¬ SymHash.Create[2];  rHSymbols: SymHash.Handle ¬ SymHash.Create[2];  uRegSymbols: SymHash.Handle ¬ SymHash.Create[10];    csInverse: ARRAY CP.Bank OF LONG POINTER TO ARRAY WordInBank OF SymHash.Hash ¬ ALL[NIL];  rRegInverse: LONG POINTER TO ARRAY CP.RReg OF SymHash.Hash ¬ z.NEW[ARRAY CP.RReg OF SymHash.Hash];  rHInverse: LONG POINTER TO ARRAY CP.RReg OF SymHash.Hash ¬ z.NEW[ARRAY CP.RReg OF SymHash.Hash];  uRegInverse: LONG POINTER TO ARRAY CP.UReg OF SymHash.Hash ¬ z.NEW[ARRAY CP.UReg OF SymHash.Hash];    ClearSymbolTable: PUBLIC ENTRY PROCEDURE =    BEGIN    FOR bank: CP.Bank IN CP.Bank DO      IF info[bank] = NIL THEN LOOP;      info[bank]­ ¬ ALL [[FALSE, , , ]];      ENDLOOP;    FOR bank: CP.Bank IN CP.Bank DO      IF csInverse[bank] = NIL THEN LOOP;      csInverse[bank]­ ¬ ALL[SymHash.nullHash];      ENDLOOP;    rRegInverse­ ¬ ALL[SymHash.nullHash];    rHInverse­ ¬ ALL[SymHash.nullHash];    uRegInverse­ ¬ ALL[SymHash.nullHash];    SymHash.Reset[csSymbols];    SymHash.Reset[rRegSymbols];    SymHash.Reset[rHSymbols];    SymHash.Reset[uRegSymbols];    END;          AddCSSymbol: PUBLIC ENTRY PROCEDURE [tag: LONG STRING, virt: CPSymbols.VirturalCS] =    BEGIN ENABLE UNWIND => NULL;    hash: SymHash.Hash;    bank: CP.Bank;    wordInBank: WordInBank;    IF tag = NIL OR tag.length = 0 THEN ERROR Error["Empty CS Symbol"L];    hash ¬ SymHash.Lookup[csSymbols, tag];    IF hash # SymHash.nullHash THEN      BEGIN      IF virt = SymHash.GetInfo[csSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate CS Symbol"L];      END;    hash ¬ SymHash.Insert[csSymbols, tag];    SymHash.PutInfo[csSymbols, hash, virt];    [bank, wordInBank] ¬ SplitVirt[virt];    BeSureInverseExists[bank, wordInBank];    csInverse[bank][wordInBank] ¬ hash;    END;      AddRRegSymbol: PUBLIC ENTRY PROCEDURE [tag: LONG STRING, r: CP.RReg] =    BEGIN ENABLE UNWIND => NULL;    hash: SymHash.Hash;    IF tag = NIL OR tag.length = 0 THEN ERROR Error["Empty RReg Symbol"L];    hash ¬ SymHash.Lookup[rRegSymbols, tag];    IF hash # SymHash.nullHash THEN      BEGIN      IF r = SymHash.GetInfo[rRegSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate RReg Symbol"L];      END;    hash ¬ SymHash.Insert[rRegSymbols, tag];    SymHash.PutInfo[rRegSymbols, hash, r];    rRegInverse[r] ¬ hash;    END;      AddRHSymbol: PUBLIC ENTRY PROCEDURE [tag: LONG STRING, r: CP.RReg] =    BEGIN ENABLE UNWIND => NULL;    hash: SymHash.Hash;    IF tag = NIL OR tag.length = 0 THEN ERROR Error["Empty RH Symbol"L];    hash ¬ SymHash.Lookup[rHSymbols, tag];    IF hash # SymHash.nullHash THEN      BEGIN      IF r = SymHash.GetInfo[rHSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate RH Symbol"L];      END;    hash ¬ SymHash.Insert[rHSymbols, tag];    SymHash.PutInfo[rHSymbols, hash, r];    rHInverse[r] ¬ hash;    END;      AddURegSymbol: PUBLIC ENTRY PROCEDURE [tag: LONG STRING, u: CP.UReg] =    BEGIN ENABLE UNWIND => NULL;    hash: SymHash.Hash;    IF tag = NIL OR tag.length = 0 THEN ERROR Error["Empty UReg Symbol"L];    hash ¬ SymHash.Lookup[uRegSymbols, tag];    IF hash # SymHash.nullHash THEN      BEGIN      IF u = SymHash.GetInfo[uRegSymbols, hash] THEN RETURN;  -- Ignore duplicates      ERROR Error["Duplicate UReg Symbol"L];      END;    hash ¬ SymHash.Insert[uRegSymbols, tag];    SymHash.PutInfo[uRegSymbols, hash, u];    uRegInverse[u] ¬ hash;    END;    LookupInCSTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, virt: CPSymbols.VirturalCS] =    BEGIN    hash: SymHash.Hash;    bank: CP.Bank;    wordInBank: WordInBank;    IF tag = NIL OR tag.length = 0 THEN RETURN[FALSE, ];    hash ¬ SymHash.Lookup[csSymbols, tag];    IF hash = SymHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    virt ¬ Inline.LowHalf[SymHash.GetInfo[csSymbols, hash]];    [bank, wordInBank] ¬ SplitVirt[virt];    BeSureInverseExists[bank, wordInBank];    csInverse[bank][wordInBank] ¬ hash;    END;      LookupInRRegTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, r: CP.RReg] =    BEGIN    hash: SymHash.Hash;    IF tag = NIL OR tag.length = 0 THEN RETURN[FALSE, ];    hash ¬ SymHash.Lookup[rRegSymbols, tag];    IF hash = SymHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    r ¬ Inline.LowHalf[SymHash.GetInfo[rRegSymbols, hash]];    rRegInverse[r] ¬ hash;    END;      LookupInRHTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, r: CP.RReg] =    BEGIN    hash: SymHash.Hash;    IF tag = NIL OR tag.length = 0 THEN RETURN[FALSE, ];    hash ¬ SymHash.Lookup[rHSymbols, tag];    IF hash = SymHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    r ¬ Inline.LowHalf[SymHash.GetInfo[rHSymbols, hash]];    rHInverse[r] ¬ hash;    END;      LookupInURegTable: PUBLIC ENTRY PROCEDURE [tag: LONG STRING] RETURNS [ok: BOOLEAN, u: CP.UReg] =    BEGIN    hash: SymHash.Hash;    IF tag = NIL OR tag.length = 0 THEN RETURN[FALSE, ];    hash ¬ SymHash.Lookup[uRegSymbols, tag];    IF hash = SymHash.nullHash THEN RETURN[FALSE, ];    ok ¬ TRUE;    u ¬ Inline.LowHalf[SymHash.GetInfo[uRegSymbols, hash]];    uRegInverse[u] ¬ hash;    END;          AppendAllVirturalCS: PUBLIC PROCEDURE [s: LONG STRING, virturalCS: CPSymbols.VirturalCS] =    BEGIN    hit: BOOLEAN ¬ FALSE;    PrintMatches: PROCEDURE [hash: SymHash.Hash] =      BEGIN      IF SymHash.GetInfo[csSymbols, hash] # virturalCS THEN RETURN;      IF hit THEN String.AppendString[s, ", "L];      String.AppendString[s, SymHash.GetString[csSymbols, hash]];      hit ¬ TRUE;      END;    SymHash.EnumerateEntries[csSymbols, PrintMatches];    END;      AppendAllRReg: PUBLIC PROCEDURE [s: LONG STRING, r: CP.RReg] =    BEGIN    hit: BOOLEAN ¬ FALSE;    PrintMatches: PROCEDURE [hash: SymHash.Hash] =      BEGIN      IF SymHash.GetInfo[rRegSymbols, hash] # r THEN RETURN;      IF hit THEN String.AppendString[s, ", "L];      String.AppendString[s, SymHash.GetString[rRegSymbols, hash]];      hit ¬ TRUE;      END;    SymHash.EnumerateEntries[rRegSymbols, PrintMatches];    END;  AppendAllRH: PUBLIC PROCEDURE [s: LONG STRING, r: CP.RReg] =    BEGIN    hit: BOOLEAN ¬ FALSE;    PrintMatches: PROCEDURE [hash: SymHash.Hash] =      BEGIN      IF SymHash.GetInfo[rHSymbols, hash] # r THEN RETURN;      IF hit THEN String.AppendString[s, ", "L];      String.AppendString[s, SymHash.GetString[rHSymbols, hash]];      hit ¬ TRUE;      END;    SymHash.EnumerateEntries[rHSymbols, PrintMatches];    END;      AppendAllUReg: PUBLIC PROCEDURE [s: LONG STRING, u: CP.UReg] =    BEGIN    hit: BOOLEAN ¬ FALSE;    PrintMatches: PROCEDURE [hash: SymHash.Hash] =      BEGIN      IF SymHash.GetInfo[uRegSymbols, hash] # u THEN RETURN;      IF hit THEN String.AppendString[s, ", "L];      String.AppendString[s, SymHash.GetString[uRegSymbols, hash]];      hit ¬ TRUE;      END;    SymHash.EnumerateEntries[uRegSymbols, PrintMatches];    END;      AppendSymbol: PUBLIC PROCEDURE [s: LONG STRING, symbol: CPSymbols.Symbol] =    BEGIN    WITH symbol SELECT FROM      tpc => AppendTpc[s, task];      tc => AppendTc[s, task];      link => AppendLink[s, link];      realCS => AppendRealCS[s, real];      virtCS => AppendVirturalCS[s, virt];      rReg => AppendRReg[s, r];      rH => AppendRH[s, r];      rAndRh => AppendRAndRh[s, r];      uReg => AppendUReg[s, u];      ioIn => AppendIOIn[s, io];      ioOut => AppendIOOut[s, io];      map => AppendMap[s, map];      real => AppendReal[s, real];      virt => AppendVirtural[s, virt];      other => AppendOther[s, other];      ENDCASE => ERROR;    END;  AppendTpc: PUBLIC PROCEDURE [s: LONG STRING, task: CP.Task] =    BEGIN    String.AppendString[s, ".TPC "L];    AppendNumber[s, task];    END;      AppendTc: PUBLIC PROCEDURE [s: LONG STRING, task: CP.Task] =    BEGIN    String.AppendString[s, ".TC "L];    AppendNumber[s, task];    END;      AppendLink: PUBLIC PROCEDURE [s: LONG STRING, link: CP.Link] =    BEGIN    String.AppendString[s, "L"L];    String.AppendNumber[s, link, 16];    END;      AppendRealCS: PUBLIC PROCEDURE [s: LONG STRING, realCS: CP.RealCS] =    BEGIN    String.AppendString[s, ".CR "L];    AppendNumber[s, realCS];    END;      AppendVirturalCS: PUBLIC PROCEDURE [s: LONG STRING, virturalCS: CPSymbols.VirturalCS] =    BEGIN    FOR i: CARDINAL IN [0..100) DO      hash: SymHash.Hash;      bank: CP.Bank;      wordInBank: WordInBank;      IF virturalCS < i THEN EXIT;      [bank, wordInBank] ¬ SplitVirt[virturalCS - i];      IF csInverse[bank] = NIL THEN LOOP;      hash ¬ csInverse[bank][wordInBank];      IF hash # SymHash.nullHash THEN        BEGIN        String.AppendString[s, SymHash.GetString[csSymbols, hash]];	IF i > 0 THEN	  BEGIN	  String.AppendChar[s, '+];	  IF i > 9 THEN String.AppendChar[s, '0];	  String.AppendNumber[s, i, 16];	  END;        RETURN;        END;      ENDLOOP;    String.AppendString[s, ".CV "L];    AppendNumber[s, virturalCS];    END;      AppendRReg: PUBLIC PROCEDURE [s: LONG STRING, r: CP.RReg] =    BEGIN    hash: SymHash.Hash;    IF r ~IN CP.RReg THEN AddressOutOfRange[];    hash ¬ rRegInverse[r];    IF hash # SymHash.nullHash THEN      BEGIN      String.AppendString[s, SymHash.GetString[rRegSymbols, hash]];      RETURN;      END;    String.AppendString[s, ".R "L];    AppendNumber[s, r];    END;  AppendRH: PUBLIC PROCEDURE [s: LONG STRING, r: CP.RReg] =    BEGIN    hash: SymHash.Hash;    IF r ~IN CP.RReg THEN AddressOutOfRange[];    hash ¬ rHInverse[r];    IF hash # SymHash.nullHash THEN      BEGIN      String.AppendString[s, SymHash.GetString[rHSymbols, hash]];      RETURN;      END;    String.AppendString[s, ".RH "L];    AppendNumber[s, r];    END;      AppendRAndRh: PUBLIC PROCEDURE [s: LONG STRING, r: CP.RReg] =    BEGIN    hash: SymHash.Hash;    IF r ~IN CP.RReg THEN AddressOutOfRange[];    String.AppendChar[s, '$];    hash ¬ rRegInverse[r];    IF hash # SymHash.nullHash THEN      BEGIN      String.AppendString[s, SymHash.GetString[rRegSymbols, hash]];      RETURN;      END;    String.AppendString[s, ".R "L];    AppendNumber[s, r];    END;  AppendUReg: PUBLIC PROCEDURE [s: LONG STRING, u: CP.UReg] =    BEGIN    hash: SymHash.Hash;    IF u ~IN CP.UReg THEN AddressOutOfRange[];    hash ¬ uRegInverse[u];    IF hash # SymHash.nullHash THEN      BEGIN      String.AppendString[s, SymHash.GetString[uRegSymbols, hash]];      RETURN;      END;    String.AppendString[s, ".U "L];    AppendNumber[s, u];    END;      AppendIOIn: PUBLIC PROCEDURE [s: LONG STRING, io: CP.IOReg] =    BEGIN    String.AppendString[s, ".IOIN "L];    AppendNumber[s, io];    END;      AppendIOOut: PUBLIC PROCEDURE [s: LONG STRING, io: CP.IOReg] =    BEGIN    String.AppendString[s, ".IOOUT "L];    AppendNumber[s, io];    END;      AppendMap: PUBLIC PROCEDURE [s: LONG STRING, map: CP.Map] =    BEGIN    String.AppendString[s, ".MAP "L];    AppendNumber[s, map];    END;      AppendReal: PUBLIC PROCEDURE [s: LONG STRING, real: CP.RealMemory] =    BEGIN    String.AppendString[s, ".MR "L];    AppendLongNumber[s, real];    END;      AppendVirtural: PUBLIC PROCEDURE [s: LONG STRING, virtural: CP.VirturalMemory] =    BEGIN    String.AppendString[s, ".MV "L];    AppendLongNumber[s, virtural];    END;    AppendOther: PUBLIC PROCEDURE [s: LONG STRING, other: CP.OtherReg] =    BEGIN    SELECT other FROM      q => String.AppendString[s, ".Q"L];      ib => String.AppendString[s, ".IB"L];      pc16 => String.AppendString[s, ".PC16"L];      stackP => String.AppendString[s, ".STACKP"L];      ibPtr => String.AppendString[s, ".IBPTR"L];      mInt => String.AppendString[s, ".MINT"L];      ekErr => String.AppendString[s, ".EKERR"L];      ENDCASE => ERROR;    END;    AppendMI: PUBLIC PROCEDURE [s: LONG STRING, mi: CPMI.MI] =    BEGIN    foo: POINTER = @mi;    FOR i: CARDINAL IN [0..SIZE[CPMI.MI]) DO      temp: STRING = [4];      IF i # 0 THEN String.AppendChar[s, ' ];      String.AppendNumber[temp, (foo + i)­, 16];      FOR k: CARDINAL IN [temp.length..4) DO String.AppendChar[s, ' ]; ENDLOOP;      String.AppendString[s, temp];      ENDLOOP;    END;    AppendNumber: PUBLIC PROCEDURE [s: LONG STRING, w: UNSPECIFIED] =    BEGIN    IF w < 1000B THEN String.AppendChar[s, '0];    String.AppendNumber[s, w, 16];    END;   AppendLongNumber: PUBLIC PROCEDURE [s: LONG STRING, w: LONG UNSPECIFIED] =    BEGIN    IF w < 1000B THEN String.AppendChar[s, '0];    String.AppendLongNumber[s, w, 16];    END;          info: ARRAY CP.Bank OF LONG POINTER TO ARRAY WordInBank OF Info ¬ ALL[NIL];  Info: TYPE = RECORD [    valid: BOOLEAN,    cycle: CP.Cycle,    task: CP.Task,    virtural: CPSymbols.VirturalCS];        AddToMap: PUBLIC ENTRY PROCEDURE [real: CP.RealCS, virtural: CPSymbols.VirturalCS, cycle: CP.Cycle, task: CP.Task] =    BEGIN    bank: CP.Bank;    wordInBank: WordInBank;    IF real ~IN CP.RealCS THEN ERROR;    [bank, wordInBank] ¬ SplitReal[real];    BeSureInfoExists[bank, wordInBank];    info[bank][wordInBank] ¬ [TRUE, cycle, task, virtural];    END;    RealToVirturalCS: PUBLIC ENTRY PROCEDURE [real: CP.RealCS]    RETURNS [CPSymbols.VirturalCS, CP.Cycle, CP.Task] =    BEGIN    p: LONG POINTER TO Info;    bank: CP.Bank;    wordInBank: WordInBank;    [bank, wordInBank] ¬ SplitReal[real];    IF info[bank] = NIL THEN RETURN[CPSymbols.nullVirturalCS, , ];    p ¬ @info[bank][wordInBank];    IF ~p.valid THEN RETURN[CPSymbols.nullVirturalCS, , ];    RETURN[p.virtural, p.cycle, p.task];    END;      VirturalToRealCS: PUBLIC ENTRY PROCEDURE [virtural: CPSymbols.VirturalCS]    RETURNS [CP.RealCS, CP.Cycle, CP.Task] =    BEGIN    FOR real: CP.RealCS IN CP.RealCS DO      p: LONG POINTER TO Info;      bank: CP.Bank;      wordInBank: WordInBank;      [bank, wordInBank] ¬ SplitReal[real];      IF info[bank] = NIL THEN LOOP;      p ¬ @info[bank][wordInBank];      IF p.valid AND virtural = p.virtural THEN RETURN[real, p.cycle, p.task];      ENDLOOP;    RETURN[CPSymbols.nullRealCS, , ];    END;  EnumerateCSSymbols: PUBLIC --ENTRY-- PROCEDURE [proc: PROCEDURE [LONG STRING, CPSymbols.VirturalCS]] =    BEGIN ENABLE UNWIND => NULL;    CallHim: PROCEDURE [hash: SymHash.Hash] =      BEGIN      virt: CPSymbols.VirturalCS ¬ Inline.LowHalf[SymHash.GetInfo[csSymbols, hash]];      proc[SymHash.GetString[csSymbols, hash], virt];      END;    SymHash.EnumerateEntries[csSymbols, CallHim];    END;      EnumerateRRegSymbols: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE [LONG STRING, CP.RReg]] =    BEGIN ENABLE UNWIND => NULL;    CallHim: PROCEDURE [hash: SymHash.Hash] =      BEGIN      r: CP.RReg ¬ Inline.LowHalf[SymHash.GetInfo[rRegSymbols, hash]];      proc[SymHash.GetString[rRegSymbols, hash], r];      END;    SymHash.EnumerateEntries[rRegSymbols, CallHim];    END;      EnumerateRHSymbols: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE [LONG STRING, CP.RReg]] =    BEGIN ENABLE UNWIND => NULL;    CallHim: PROCEDURE [hash: SymHash.Hash] =      BEGIN      r: CP.RReg ¬ Inline.LowHalf[SymHash.GetInfo[rHSymbols, hash]];      proc[SymHash.GetString[rHSymbols, hash], r];      END;    SymHash.EnumerateEntries[rHSymbols, CallHim];    END;      EnumerateURegSymbols: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE [LONG STRING, CP.UReg]] =    BEGIN ENABLE UNWIND => NULL;    CallHim: PROCEDURE [hash: SymHash.Hash] =      BEGIN      u: CP.UReg ¬ Inline.LowHalf[SymHash.GetInfo[uRegSymbols, hash]];      proc[SymHash.GetString[uRegSymbols, hash], u];      END;    SymHash.EnumerateEntries[uRegSymbols, CallHim];    END;      EnumerateMap: PUBLIC ENTRY PROCEDURE [    proc: PROCEDURE [CP.RealCS, CPSymbols.VirturalCS, CP.Cycle, CP.Task]] =    BEGIN ENABLE UNWIND => NULL;    FOR real: CP.RealCS IN CP.RealCS DO      p: LONG POINTER TO Info;      bank: CP.Bank;      wordInBank: WordInBank;      [bank, wordInBank] ¬ SplitReal[real];      IF info[bank] = NIL THEN LOOP;      p ¬ @info[bank][wordInBank];      IF ~p.valid THEN LOOP;      proc[real, p.virtural, p.cycle, p.task];      ENDLOOP;    END;      SplitReal: PROCEDURE [real: CP.RealCS] RETURNS [bank: CP.Bank, wordInBank: WordInBank] =    BEGIN    temp: CP.BankAndWordsPerBank = LOOPHOLE[real];    RETURN[temp.bank, temp.wordInBank];    END;    BeSureInfoExists: PROCEDURE [bank: CP.Bank, wordInBank: WordInBank] =    BEGIN    IF info[bank] # NIL THEN RETURN;    info[bank] ¬ z.NEW[ARRAY WordInBank OF Info];    info[bank]­ ¬ ALL [[FALSE, , , ]];    END;      SplitVirt: PROCEDURE [virt: CPSymbols.VirturalCS] RETURNS [bank: CP.Bank, wordInBank: WordInBank] =    BEGIN    temp: CP.BankAndWordsPerBank = LOOPHOLE[virt];    RETURN[temp.bank, temp.wordInBank];    END;    BeSureInverseExists: PROCEDURE [bank: CP.Bank, wordInBank: WordInBank] =    BEGIN    IF csInverse[bank] # NIL THEN RETURN;    csInverse[bank] ¬ z.NEW[ARRAY WordInBank OF SymHash.Hash];    csInverse[bank]­ ¬ ALL [SymHash.nullHash];    END;      AddressOutOfRange: PROCEDURE =    BEGIN    foo: BOOLEAN ¬ TRUE;    IF foo THEN ERROR Error["Address out of range"L];    END;      ClearSymbolTable[];  END.
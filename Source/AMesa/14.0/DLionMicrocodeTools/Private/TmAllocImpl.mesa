-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TmAllocImpl.mesa -- Last edit: DEG       26-Sep-84 20:21:28-- Last edit: JAC    13-Jul-83  9:57:24   -- Last edit: ETN    16-Jul-82 12:01:51 DIRECTORY  Ascii USING [CR],  Inline USING [BITAND],  String USING [AppendString, AppendChar],  MassBurdockInterface,  TmAssembler,  TmFile USING [LogErrAndSrcLines, LogLine],  TmLabel,  TmP2Hash USING [    bad, constraintArray, curMI, errorLevel, ia7Array, miRtoV, miVtoR, Not];TmAllocImpl: PROGRAM  IMPORTS Inline, String, TmAssembler, TmFile, TmLabel, TmP2Hash EXPORTS TmLabel =  BEGIN OPEN MassBurdockInterface, TmAssembler, TmLabel;  AddConstraint: PUBLIC PROCEDURE [ccp: LONG POINTER TO ConstraintChain] =    BEGIN    AppendConstraint: PROCEDURE [      ccTail, ccHead: LONG POINTER TO ConstraintChain] =      -- append the Tail chain at the back of The Head chain (Head will be the new head) .      BEGIN      UNTIL ccHead.nextConstraint = NIL DO ccHead ¬ ccHead.nextConstraint ENDLOOP;      ccHead.nextConstraint ¬ ccTail;      END;  -- end AppendConstraint    ChangeConstraintPtrs: PROCEDURE [      ccNew, ccOld: LONG POINTER TO ConstraintChain] =      BEGIN      -- update all constraintArray entries which point to ccOld, so that they point to ccNew.      ccCur: LONG POINTER TO ConstraintChain ¬ ccOld;      UNTIL ccCur = NIL DO        TmP2Hash.constraintArray[ccCur­.miIndex1] ¬ ccNew;        IF ccCur.modulo # maxmaxModulo THEN          TmP2Hash.constraintArray[ccCur­.miIndex2] ¬ ccNew;        ccCur ¬ ccCur.nextConstraint;        ENDLOOP;      END;  -- end ChangeConstraintPtrs    IF ccp­.modulo = maxmaxModulo THEN      -- absolute placement, miIndex2 not useful       IF TmP2Hash.constraintArray[ccp­.miIndex1] = NIL THEN        -- one label only. . not listed        TmP2Hash.constraintArray[ccp­.miIndex1] ¬ ccp      ELSE        -- one label only. . listed        AppendConstraint[ccp, TmP2Hash.constraintArray[ccp­.miIndex1]]    ELSE      -- not an absolute placement.  both Indecis useful      IF TmP2Hash.constraintArray[ccp­.miIndex1] = NIL THEN        BEGIN        IF TmP2Hash.constraintArray[ccp­.miIndex2] = NIL THEN          BEGIN          -- neither label listed          TmP2Hash.constraintArray[ccp­.miIndex1] ¬ ccp;          TmP2Hash.constraintArray[ccp­.miIndex2] ¬ ccp;          END        ELSE          BEGIN          -- label 2 only listed          TmP2Hash.constraintArray[ccp­.miIndex1] ¬ TmP2Hash.constraintArray[            ccp­.miIndex2];          AppendConstraint[ccp, TmP2Hash.constraintArray[ccp­.miIndex2]];          END;        END      ELSE        BEGIN        IF TmP2Hash.constraintArray[ccp­.miIndex2] = NIL THEN          BEGIN          -- label 1 only listed          TmP2Hash.constraintArray[ccp­.miIndex2] ¬ TmP2Hash.constraintArray[            ccp­.miIndex1];          AppendConstraint[ccp, TmP2Hash.constraintArray[ccp­.miIndex1]];          END        ELSE          -- both labels listed          IF TmP2Hash.constraintArray[ccp­.miIndex1] # TmP2Hash.constraintArray[            ccp­.miIndex2] THEN            BEGIN            -- both labels in different chains            AppendConstraint[              TmP2Hash.constraintArray[ccp­.miIndex2], TmP2Hash.constraintArray[              ccp­.miIndex1]];            ChangeConstraintPtrs[              TmP2Hash.constraintArray[ccp­.miIndex1], TmP2Hash.constraintArray[              ccp­.miIndex2]];            AppendConstraint[ccp, TmP2Hash.constraintArray[ccp­.miIndex1]]            END            -- both labels listed in same chain          ELSE AppendConstraint[ccp, TmP2Hash.constraintArray[ccp­.miIndex1]];        END;    END;  -- end AddConstraint  AllocateUnconstrained: PUBLIC PROCEDURE =    BEGIN    v: CARDINAL;    r: CARDINAL ¬ 0;    FOR v IN [0..TmP2Hash.curMI) DO      IF TmP2Hash.miVtoR[v] = TmP2Hash.Not AND TmP2Hash.ia7Array[v] = x THEN        BEGIN        UNTIL r >= 4096 OR TmP2Hash.miRtoV[r] = Empty DO r ¬ r + 1 ENDLOOP;        IF r >= 4096 THEN BEGIN ErrMsg[toomany, "(no ia7) "L, v]; RETURN; END;        TmP2Hash.miVtoR[v] ¬ r;        TmP2Hash.miRtoV[r] ¬ v;        END;      ENDLOOP;    END;  -- end AllocateUnconstrained  BuildCAList: PUBLIC PROCEDURE    RETURNS [caOut: LONG POINTER TO ConstraintAttribute] =    BEGIN    ca: LONG POINTER TO ConstraintAttribute;    ccCur: LONG POINTER TO ConstraintChain;    ccOut: LONG POINTER TO ConstraintChain;    i: CARDINAL;    max: CARDINAL [0..maxmaxModulo];    myia7: ia7Type;    caOut ¬ NIL;    FOR i IN [0..4096) DO  -- scan constraintArray for ConstraintChain's      IF TmP2Hash.constraintArray[i] # NIL THEN        BEGIN        ccOut ¬ TmP2Hash.constraintArray[i];        max ¬ 0;        myia7 ¬ x;        ccCur ¬ TmP2Hash.constraintArray[i];        IF ccCur.modulo = 5 THEN          myia7 ¬            SELECT Inline.BITAND[16, ccCur.offset] FROM 0 => f, ENDCASE => t;        UNTIL ccCur = NIL DO  -- scan ConstraintChain for Attributes          max ¬ MAX[max, ccCur.modulo];          IF TmP2Hash.constraintArray[ccCur­.miIndex1] # NIL THEN            BEGIN            IF ccCur­.miIndex1 <= TmP2Hash.curMI              AND TmP2Hash.miVtoR[ccCur­.miIndex1] # TmP2Hash.Not THEN              max ¬ maxmaxModulo;            TmP2Hash.constraintArray[ccCur­.miIndex1] ¬ NIL;            IF TmP2Hash.ia7Array[ccCur­.miIndex1] # x THEN              BEGIN              IF myia7 # x AND myia7 # TmP2Hash.ia7Array[ccCur­.miIndex1] THEN                ErrMsg[ia7, NIL, ccCur­.miIndex1]              ELSE myia7 ¬ TmP2Hash.ia7Array[ccCur­.miIndex1];              END;            END;          IF ccCur.modulo # maxmaxModulo THEN            IF TmP2Hash.constraintArray[ccCur­.miIndex2] # NIL THEN              BEGIN              IF ccCur­.miIndex2 <= TmP2Hash.curMI                AND TmP2Hash.miVtoR[ccCur­.miIndex2] # TmP2Hash.Not THEN                max ¬ maxmaxModulo;              TmP2Hash.constraintArray[ccCur­.miIndex2] ¬ NIL;              IF TmP2Hash.ia7Array[ccCur­.miIndex2] # x THEN                BEGIN                IF myia7 # x AND myia7 # TmP2Hash.ia7Array[ccCur­.miIndex2] THEN                  ErrMsg[ia7, NIL, ccCur­.miIndex2]                ELSE myia7 ¬ TmP2Hash.ia7Array[ccCur­.miIndex2];                END;              END;          ccCur ¬ ccCur.nextConstraint;          ENDLOOP;  -- end scan of ConstraintChain's for Attributes        ca ¬ GetPassSpace[SIZE[ConstraintAttribute]];        ca­ ¬ ConstraintAttribute[caOut, ccOut, myia7, max];        caOut ¬ ca;        END;      ENDLOOP;  -- end scan for ConstraintChain's    END;  -- end BuildCAList  ErrMsg: PROCEDURE [type: {uncon, toomany, ia7}, s: LONG STRING, mi1: MIIndex] =    BEGIN    Estr: LONG STRING ¬ [150];  -- string for error messages    Estr.length ¬ 0;    IF TmP2Hash.errorLevel < TmP2Hash.bad THEN      TmFile.LogErrAndSrcLines["Allocation Errors:"L];    TmP2Hash.errorLevel ¬ 200;    SELECT type FROM      uncon =>        BEGIN        String.AppendString[Estr, "Unable to allocate unconstrained "L];        String.AppendString[Estr, s];        AppendSymbolName[Estr, mi1];        String.AppendChar[Estr, Ascii.CR];        String.AppendString[Estr, "Possibly control memory full."L];        END;      ia7 =>        BEGIN        String.AppendString[Estr, "ia7 conflict in block containing "L];        AppendSymbolName[Estr, mi1];        END;      toomany =>        BEGIN        String.AppendString[          Estr, "Too many m-i's plus reserves.  Control memory full."L];        END;      ENDCASE;    String.AppendChar[Estr, Ascii.CR];    TmFile.LogLine[Estr];    END;  -- end ErrMsg  END...    -- Log  -- 13-Jul-83  9:58:20 - JAC        - Use pass segments instead of heap  -- 16-Jul-82 12:02:29 - ETN        - TrinityMass Version 1  -- 26-Sep-84 20:21:25	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
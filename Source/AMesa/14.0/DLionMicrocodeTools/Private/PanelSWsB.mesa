-- Copyright (C) 1980, 1981, 1982, 1983  by Xerox Corporation. All rights reserved. -- PanelSWsB.mesa, HGM, 12-Feb-83 14:55:55-- AMD, 22-Dec-82 11:14:06-- Mark: 22-Aug-80  2:27:34-- PXJ   : August 16, 1980  5:57 PM-- Last edit by PXO      on October 22, 1981  8:56 PM - Changed some procs to deal in longs.-- incremental display maintenanceDIRECTORY  Atom: TYPE USING [ATOM, MakeAtom],  Context USING [Find],  Cursor USING [Set],  Display: TYPE USING [Black, Block, Invert, Text, White],  Environment: TYPE USING [Block],  Heap: TYPE USING [systemZone],  Inline USING [DIVMOD],  Menu USING [Handle, Invoke, MCRType],  PanelSW USING [    ClientError, Handle, nilTileIndex, Object, RegisterSpec, ResolvePlaceToTile,    TileError, TileField, TileIndex, TileLayout, TileSpec],  PanelSWOps USING [    ActOnPanelProcType, ActOnTileProcType, BitFieldSpec, FindContext, FreeTile,    Handle, LockProcType, Object, PaintOp, Tile, TileFromSpec, TileObject],  Put USING [CR, Line],  Selection USING [Convert],  String USING [    AppendString, CopyToNewString, Equivalent, ExpandString, InvalidNumber, Length,    StringBoundsFault, StringToNumber],  TIP: TYPE USING [CreateTable, First, InvalidTable, NotifyProc, Results, Rest, Table],  ToolWindow USING [DisplayProcType],  UserTerminal: TYPE USING [BlinkDisplay],  Window USING [    Box, EnumerateInvalidBoxes, GetBox, Handle, InvalidateBox, Place, Validate],  WindowFont USING [CharWidth, Handle];PanelSWsB: MONITOR LOCKS h.lock USING h: PanelSWOps.Handle  IMPORTS    Atom, Context, Cursor, D: Display, Heap, Inline, Menu, PanelSW, PanelSWOps, Put, Selection, String, TIP, UserTerminal, Window, WindowFont  EXPORTS PanelSW, PanelSWOps =  BEGIN  -- Standard preamble to hook up EXPORTed TYPEs  Object: PUBLIC TYPE = PanelSWOps.Object;  -- Global Data and STUFF  menuPNRDownPlace: Window.Place;  TwoFields: TYPE = RECORD [white, paint: PanelSWOps.BitFieldSpec];    -- PUBLIC Procedures  Clear: PUBLIC PanelSWOps.ActOnPanelProcType = {    LockedFreeAllTiles: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      FOR i: PanelSW.TileIndex IN [0..h.tiles.length) DO        PanelSWOps.FreeTile[h.tiles[i], h.cProcs.freeRS];        h.tiles[i] ¬ NIL        ENDLOOP};    IF h # NIL THEN {LockedFreeAllTiles[h]; Display[h]}};  ClearTile: PUBLIC PanelSWOps.ActOnTileProcType = {    LockedFreeTile: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      PanelSWOps.FreeTile[h.tiles[ts.index], h.cProcs.freeRS];      h.tiles[ts.index] ¬ NIL};    IF h # NIL THEN {LockedFreeTile[h]; DisplayTile[h, ts]}};  Display: PUBLIC PanelSWOps.ActOnPanelProcType = {    IF h # NIL THEN {      h.sw.InvalidateBox[[[0, 0], h.sw.GetBox.dims], isDirty];      h.sw.Validate}};  DisplayTile: PUBLIC PanelSWOps.ActOnTileProcType = {    LockedDisplayTile: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      isCurrent: BOOLEAN;      IF ts.index >= h.tiles.length THEN RETURN;      isCurrent ¬ (ts.index = h.current.index AND h.marked);      InternalDisplayTile[        h, ts.index, h.tiles[ts.index], [white: ALL[TRUE], paint: ALL[TRUE]]];      IF isCurrent THEN {h.marked ¬ FALSE; MarkCurrent[h]}};    IF h # NIL THEN LockedDisplayTile[h]};  ReadTile: PUBLIC PROC [h: PanelSWOps.Handle, ts: PanelSW.TileSpec]    RETURNS [s: LONG STRING] = {    tile: PanelSWOps.Tile = PanelSWOps.TileFromSpec[h, ts];    LockedReadTile: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL; ReadTarget[h, ts]};    s ¬ NIL;    -- this is not safe in the face of preemptive processes!!!    IF tile # NIL THEN {LockedReadTile[h]; DisplayTile[h, ts]; RETURN[tile.rh]}};  StringFromTile: PUBLIC PROC [h: PanelSWOps.Handle, ts: PanelSW.TileSpec]    RETURNS [s: LONG STRING] =  {    tile: PanelSWOps.Tile = PanelSWOps.TileFromSpec[h, ts];    -- this is not safe in the face of preemptive processes!!!    RETURN[      IF tile = NIL THEN NIL ELSE IF ts.field = right THEN tile.rh ELSE tile.lh]};  Update: PUBLIC PanelSWOps.ActOnPanelProcType = {    LockedUpdate: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      fields: TwoFields ¬ [white: ALL[FALSE], paint: ALL[FALSE]];      tile: PanelSWOps.Tile;      i, j: PanelSW.TileIndex;      IF h.marked THEN UnmarkCurrent[h];      FOR i IN [0..h.numCols) DO -- try to use same CP overlay in Burdock        D.White[          h.sw, [          [x: h.rowPlaceDesc[i][flag], y: 0], [          w: h.rowDesc[i][flag], h: h.sw.GetBox.dims.h]]];  -- Clear all flags        FOR j ¬ i, j + h.numCols UNTIL j >= h.tiles.length DO          ReadTarget[h, [field: right, index: j] !            PanelSW.ClientError => {	      Put.CR[h.err];	      Put.Line[h.err, msg];	      CONTINUE}];          IF (tile ¬ h.tiles[j]) # NIL THEN {            fields.paint[flag] ¬ (tile.state # old);            fields.paint[right] ¬ fields.white[right] ¬ (tile.state = changed);            InternalDisplayTile[h, j, tile, fields]};          ENDLOOP;        ENDLOOP;      MarkCurrent[h]};    IF h # NIL THEN LockedUpdate[h]};  UpdateTile: PUBLIC PanelSWOps.ActOnTileProcType = {    LockedUpdateTile: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      isCurrent: BOOLEAN = (h.current.index = ts.index);      tile: PanelSWOps.Tile;      IF isCurrent AND h.marked THEN UnmarkCurrent[h];      ReadTarget[h, ts];      IF (tile ¬ h.tiles[ts.index]) # NIL THEN {        fields: PanelSWOps.BitFieldSpec ¬ [          flag: TRUE, left: FALSE, right: (tile.state = changed)];        InternalDisplayTile[h, ts.index, tile, [fields, fields]]};      IF isCurrent THEN MarkCurrent[h]};    IF h # NIL THEN LockedUpdateTile[h]};  InternalDisplayTile: INTERNAL PROC [    h: PanelSWOps.Handle, ti: PanelSW.TileIndex, tile: PanelSWOps.Tile,    fields: TwoFields] = {    col: CARDINAL;    row: CARDINAL;    rowDesc, rowPlaceDesc: LONG POINTER TO PanelSW.TileLayout;    x, y, w: INTEGER;    s: LONG STRING;    [row, col] ¬ Inline.DIVMOD[ti, h.numCols];    IF fields.white # ALL[FALSE] THEN      DoSomethingToFields[h, col, row, fields.white, whiten];    IF tile = NIL THEN RETURN;    y ¬ row*h.lineHeight;    rowDesc ¬ h.rowDesc[col].BASE;    rowPlaceDesc ¬ h.rowPlaceDesc[col].BASE;    IF fields.paint[flag] THEN {      s ¬        SELECT tile.state FROM          bogus => "~"L,          changed => "*"L,          old => NIL,          ENDCASE => ERROR;      IF s # NIL THEN {        x ¬ rowPlaceDesc[flag];        w ¬ rowDesc[flag];	[] ¬ D.Text[	  window: h.sw, string: s, place: [x, y], font: h.font, lineLength: w]}};    IF fields.paint[left] THEN {      IF (s ¬ tile.lh) # NIL THEN {        x ¬ rowPlaceDesc[left];        w ¬ rowDesc[left];	[] ¬ D.Text[	  window: h.sw, string: s, place: [x, y], font: h.font, lineLength: w]}};    IF fields.paint[right] THEN {      IF (s ¬ tile.rh) # NIL THEN {        spacer: INTEGER = 5;        fieldW: INTEGER = rowDesc[right];	block: Environment.Block ¬ [LOOPHOLE[@s.text], 0, s.length];        charW: INTEGER;        -- First figure out how long it is (for right justification)        w ¬ spacer;        FOR i: CARDINAL DECREASING IN [0..s.length) DO          IF w + (charW ¬ WindowFont.CharWidth[s[i], h.font]) > fieldW THEN {            IF w = spacer THEN GOTO Bogus;	    block.startIndex ¬ block.startIndex.SUCC;            EXIT};          w ¬ w + charW;          REPEAT FINISHED => block.startIndex ¬ 0;          ENDLOOP;        x ¬ rowPlaceDesc[right] + fieldW - w;        [] ¬ D.Block[	  window: h.sw, block: block, lineLength: w, place: [x, y],	  font: h.font]};      EXITS Bogus => NULL}};  WriteTile: PUBLIC PROC [    h: PanelSWOps.Handle, ts: PanelSW.TileSpec, s: LONG STRING,    normalize: BOOLEAN] = {    leftWriteLost: BOOLEAN ¬ TRUE;    tile: PanelSWOps.Tile;    newVal: LONG STRING ¬ NIL;    regSpec: PanelSW.RegisterSpec ¬ NIL;    LockedStartTile: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      tile ¬ h.tiles[ts.index];      IF ts.field = left THEN DoLeftTile[]      ELSE        IF tile # NIL THEN {          -- set up for outward call without monitor protection          regSpec ¬ tile.regSpec;          tile.regSpec ¬ NIL;}}; -- now regSpec is only copy in existence    DoLeftTile: INTERNAL PROC = {      -- I think UNWINDing out of the next line is ok.  /HGM      [newVal, regSpec] ¬ h.cProcs.lhTypeInEval[ts, s, normalize];      leftWriteLost ¬ (newVal = NIL);      IF tile # NIL THEN {        -- Reset tile (except for rh)        Heap.systemZone.FREE[@tile.lh];        h.cProcs.freeRS[tile.regSpec];        tile.regSpec ¬ NIL;        IF leftWriteLost THEN {          -- Free up tile          Heap.systemZone.FREE[@tile.rh];	  Heap.systemZone.FREE[@tile];          h.tiles[ts.index] ¬ NIL}};      IF ~leftWriteLost THEN {        IF tile = NIL THEN h.tiles[ts.index] ¬ tile ¬ Heap.systemZone.NEW[	  PanelSWOps.TileObject ¬ []];        tile.lh ¬ newVal;        newVal ¬ h.cProcs.readTarget[regSpec, TRUE]};      FinalizeTile[]};    LockedNewValue: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      tile ¬ h.tiles[ts.index];  -- might have been zapped      FinalizeTile[]};    FinalizeTile: INTERNAL PROC = {      fields: PanelSWOps.BitFieldSpec ¬ ALL[TRUE];      isCurrent: BOOLEAN = (h.current.index = ts.index AND h.marked);      IF tile # NIL THEN {        IF tile.regSpec # NIL THEN RETURN; -- oops, zapped!        tile.regSpec ¬ regSpec; -- put only copy back        NewValue[tile, newVal];        fields[right] ¬ (tile.state = changed);        IF ts.field = left THEN {IF tile.state = old THEN tile.state ¬ changed}        ELSE fields[left] ¬ FALSE};      IF isCurrent AND fields # ALL[TRUE] THEN InvertCurrent[h];      InternalDisplayTile[h, ts.index, tile, [fields, fields]];      IF isCurrent THEN {h.marked ¬ FALSE; InvertCurrent[h]}};    IF h # NIL AND ts.index < h.tiles.length THEN {      LockedStartTile[h];      IF ts.field = right AND tile # NIL AND regSpec # NIL THEN {          newVal ¬ h.cProcs.rhTypeInEval[ts, s, regSpec ! UNWIND => LockedNewValue[h]];          LockedNewValue[h]};      IF newVal = NIL THEN ERROR PanelSW.TileError[readFailed, ts]}};  -- Semi-PUBLIC PROCs  DisplayProc: PUBLIC ToolWindow.DisplayProcType = {    h: PanelSWOps.Handle = PanelSWOps.FindContext[window];    DoAnInvalidBox: PROC [wh: Window.Handle, box: Window.Box] = {      LockedDisplayProc: ENTRY PanelSWOps.LockProcType = {	ENABLE UNWIND => NULL;        topLeft, bottomRight: PanelSW.TileSpec;        leftCol, rightCol, offset, curIndex: PanelSW.TileIndex;        isCurrent: BOOLEAN;        [topLeft, bottomRight] ¬ DetermineAffectedTiles[h, @box];        IF topLeft.index = PanelSW.nilTileIndex THEN RETURN;        leftCol ¬ topLeft.index MOD h.numCols;        rightCol ¬ bottomRight.index MOD h.numCols;        offset ¬ 0;        THROUGH [leftCol..rightCol] DO  -- do col at a time          FOR curIndex ¬ topLeft.index + offset, curIndex + h.numCols UNTIL            curIndex > bottomRight.index DO            IF (isCurrent ¬ (h.current.index = curIndex)) AND h.marked THEN              {DoSomethingToCurrent[h, whiten]; h.marked ¬ FALSE};            InternalDisplayTile[  -- do partial tiles, but for now...              h, curIndex, h.tiles[curIndex], [              white: ALL[FALSE], paint: ALL[TRUE]]];            IF isCurrent THEN InvertCurrent[h];            ENDLOOP;          offset ¬ offset + 1;          ENDLOOP};      LockedDisplayProc[h]};    IF h # NIL THEN window.EnumerateInvalidBoxes[DoAnInvalidBox]};  PaintTile: PUBLIC PROC [h: PanelSWOps.Handle, tile: PanelSW.TileIndex] = {    LockedPaintTile: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      isCurrent: BOOLEAN;      IF tile >= h.tiles.length THEN RETURN;      IF (isCurrent ¬ (h.current.index = tile)) AND h.marked THEN        UnmarkCurrent[h];      InternalDisplayTile[        h, tile, h.tiles[tile], [white: ALL[FALSE], paint: ALL[TRUE]]];      IF isCurrent THEN MarkCurrent[h]};    IF h # NIL THEN LockedPaintTile[h]};  TileWidth: PUBLIC PROC [h: PanelSWOps.Handle, tile: PanelSW.TileIndex]    RETURNS [w: CARDINAL] = {    tileLayout: LONG POINTER TO PanelSW.TileLayout =       h.rowDesc[tile MOD h.numCols].BASE;    w ¬ 0;    FOR tf: PanelSW.TileField IN PanelSW.TileField DO      w ¬ w + tileLayout[tf]; ENDLOOP};  -- Maintaining the "current" tile  InvertCurrent: PUBLIC INTERNAL PanelSWOps.ActOnPanelProcType = {    -- Caller guarantees h # NIL and h.current.index < h.tiles.length.    DoSomethingToCurrent[h, invert];    h.marked ¬ ~h.marked};  DoSomethingToCurrent: PUBLIC INTERNAL PROC [    h: PanelSWOps.Handle, op: PanelSWOps.PaintOp] = {    -- Caller guarantees h # NIL and h.current.index < h.tiles.length.    col, row: PanelSW.TileIndex;    fields: PanelSWOps.BitFieldSpec;    [row, col] ¬ Inline.DIVMOD[h.current.index, h.numCols];    FOR tf: PanelSW.TileField IN PanelSW.TileField DO      fields[tf] ¬ (h.current.field = tf) ENDLOOP;    DoSomethingToFields[h, col, row, fields, op]};  DoSomethingToFields: PUBLIC INTERNAL PROC [    h: PanelSWOps.Handle, col, row: PanelSW.TileIndex,    fields: PanelSWOps.BitFieldSpec, op: PanelSWOps.PaintOp] = {    y: INTEGER = row*h.lineHeight;    rowDesc: LONG POINTER TO PanelSW.TileLayout = h.rowDesc[col].BASE;    rowPlaceDesc: LONG POINTER TO PanelSW.TileLayout = h.rowPlaceDesc[col].BASE;    FOR tf: PanelSW.TileField IN PanelSW.TileField DO      IF fields[tf] THEN {        -- start here        x: INTEGER ¬ rowPlaceDesc[tf];        w: INTEGER ¬ rowDesc[tf];        FOR tfInner: PanelSW.TileField IN (tf..PanelSW.TileField.LAST] DO          IF ~fields[tfInner] THEN EXIT;          w ¬ w + rowDesc[tfInner];          fields[tfInner] ¬ FALSE;  -- mark these fields as done          ENDLOOP;        (SELECT op FROM           whiten => D.White,           blacken => D.Black,           invert => D.Invert,           ENDCASE => ERROR)[h.sw, [[x: x, y: y], [w: w, h: h.lineHeight]]]};      REPEAT FINISHED => RETURN;      ENDLOOP};  MarkCurrent: PUBLIC INTERNAL PanelSWOps.ActOnPanelProcType = {    -- Caller guarantees h # NIL.    IF h.current.index < h.tiles.length AND ~h.marked THEN InvertCurrent[h]};  UnmarkCurrent: PUBLIC INTERNAL PanelSWOps.ActOnPanelProcType = {    -- Caller guarantees h # NIL.    IF h.current.index < h.tiles.length AND h.marked THEN InvertCurrent[h]};  -- TIP stuff and MCRTypes  table: TIP.Table ¬ NIL;  track, enter, exit, plusOne, minusOne, writeSelection, fillColumn,    unmarkAndInvokeMenu, modifyTypeIn: Atom.ATOM ¬ NIL;    GetTable: PUBLIC PROC RETURNS [TIP.Table] = {    IF table = NIL THEN {      track ¬ Atom.MakeAtom["Track"L];      enter ¬ Atom.MakeAtom["Enter"L];      exit ¬ Atom.MakeAtom["Exit"L];      plusOne ¬ Atom.MakeAtom["PlusOne"L];      minusOne ¬ Atom.MakeAtom["MinusOne"L];      writeSelection ¬ Atom.MakeAtom["WriteSelection"L];      fillColumn ¬ Atom.MakeAtom["FillColumn"L];      unmarkAndInvokeMenu ¬ Atom.MakeAtom["UnmarkAndInvokeMenu"L];      modifyTypeIn ¬ Atom.MakeAtom["ModifyTypeIn"L];      table ¬ TIP.CreateTable[        file: "PanelSW.TIP"L, contents: "-- PanelSW.TIP, created by Burdock-- Version of 11-Feb-83 18:22:17SELECT TRIGGER FROM  MOUSE => COORDS, Track;    Point Down => SELECT TRIGGER FROM    Adjust Down BEFORE 250 =>      SELECT ENABLE FROM        LeftShift Down => COORDS, FillColumn;        ENDCASE => COORDS, UnmarkAndInvokeMenu;    ENDCASE => SELECT ENABLE FROM      LeftShift Down => COORDS, PlusOne;      ENDCASE => COORDS, WriteSelection;    Menu Down => SELECT ENABLE FROM    LeftShift Down => COORDS, FillColumn;    ENDCASE => COORDS, UnmarkAndInvokeMenu;  MENU Down => SELECT ENABLE FROM    LeftShift Down => COORDS, FillColumn;    ENDCASE => COORDS, UnmarkAndInvokeMenu;    Adjust Down => SELECT TRIGGER FROM    Point Down BEFORE 250 =>      SELECT ENABLE FROM        LeftShift Down => COORDS, FillColumn;        ENDCASE => COORDS, UnmarkAndInvokeMenu;    ENDCASE => SELECT ENABLE FROM      LeftShift Down => COORDS, MinusOne;      ENDCASE => COORDS, ModifyTypeIn;      ENTER => Enter;  EXIT => Exit;    ENDCASE..."L ! TIP.InvalidTable => {        UserTerminal.BlinkDisplay[];        RESUME}]};    RETURN[table]};    TIPMe: PUBLIC TIP.NotifyProc = {    h: PanelSWOps.Handle = PanelSWOps.FindContext[window];    place: Window.Place;    IF h = NIL THEN RETURN;    FOR r: TIP.Results ¬ results, r.Rest UNTIL r = NIL DO      WITH z: r.First SELECT FROM        coords => place ¬ z.place;	atom => SELECT z.a FROM	  track => Track[h, place];	  enter => {	    Cursor.Set[textPointer]; h.lastPlace ¬ [INTEGER.LAST, INTEGER.LAST]};	  exit => {	    LockedUnmarkCurrent: ENTRY PanelSWOps.LockProcType = {	      ENABLE UNWIND => NULL;	      UnmarkCurrent[h];	      h.current.index ¬ PanelSW.nilTileIndex};	    LockedUnmarkCurrent[h]};	  plusOne => {	    menuPNRDownPlace ¬ place; PlusOne[window, NIL, CARDINAL.LAST]};	  minusOne => {	    menuPNRDownPlace ¬ place; MinusOne[window, NIL, CARDINAL.LAST]};	  writeSelection => WriteSelection[h, place];	  fillColumn => {	    menuPNRDownPlace ¬ place;	    FillColumn[window, NIL, CARDINAL.LAST]};	  unmarkAndInvokeMenu => {            LockedUnmarkCurrent: ENTRY PanelSWOps.LockProcType = {	      ENABLE UNWIND => NULL;              UnmarkCurrent[h];              h.current.index ¬ PanelSW.nilTileIndex};       	    marked: BOOLEAN;	    menuPNRDownPlace ¬ place;	    IF (marked ¬ 	      (h.current.index # PanelSW.nilTileIndex AND h.marked)) THEN 	      LockedUnmarkCurrent[h];	    Menu.Invoke[window, place]};	  modifyTypeIn => {	    ts: PanelSW.TileSpec ¬ PanelSW.ResolvePlaceToTile[h, place, FALSE];	    tile: PanelSWOps.Tile;	    h.cProcs.modifyTypeIn[	      IF ts.index >= h.tiles.length 	        OR (tile ¬ h.tiles[ts.index]) = NIL THEN NIL 	      ELSE IF ts.field = right THEN tile.rh ELSE tile.lh, FALSE]};	  ENDCASE;	ENDCASE;      ENDLOOP};    Track: PROC [h: PanelSWOps.Handle, place: Window.Place] = {    LockedTrack: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      ts: PanelSW.TileSpec;      IF place = h.lastPlace THEN RETURN;      h.lastPlace ¬ place;      ts ¬ PanelSW.ResolvePlaceToTile[h, place, FALSE];      IF ts.field = flag THEN ts.field ¬ left;      IF ts # h.current THEN UnmarkCurrent[h];      IF ts.index < h.tiles.length THEN {h.current ¬ ts; MarkCurrent[h]}};    LockedTrack[h]};  WriteSelection: PROC [h: PanelSWOps.Handle, place: Window.Place] = {    ts: PanelSW.TileSpec;    selection: LONG STRING ¬ NIL;    text: LONG STRING;    IF h.typeIn = NIL THEN RETURN;    ts ¬ PanelSW.ResolvePlaceToTile[h, place, FALSE];    IF ts.index = PanelSW.nilTileIndex THEN RETURN;    IF ts.field = flag THEN ts.field ¬ left;    IF h.typeIn­ = NIL OR h.typeIn­.length = 0 THEN {      selection ¬ Selection.Convert[string];      text ¬ selection}    ELSE text ¬ h.typeIn­;    WriteTile[h, ts, text, FALSE !      PanelSW.TileError => CONTINUE;      PanelSW.ClientError => {	Put.CR[h.err];	Put.Line[h.err, msg];	CONTINUE}];    IF selection # NIL THEN Heap.systemZone.FREE[@selection]};  FillColumn: PUBLIC Menu.MCRType = {    count: CARDINAL ¬ CARDINAL.LAST;    h: PanelSWOps.Handle;    ts: PanelSW.TileSpec;    tile: PanelSWOps.Tile;    s: LONG STRING;    clearing: BOOLEAN;    TryThisString: PROC RETURNS [LONG STRING] = {      String.ExpandString[@s, 20, Heap.systemZone]; RETURN[s]};    IF (h ¬ PanelSWOps.FindContext[window]) = NIL THEN RETURN;    ts ¬ PanelSW.ResolvePlaceToTile[h, menuPNRDownPlace, FALSE];    IF ts.index = PanelSW.nilTileIndex THEN RETURN;    clearing ¬ (tile ¬ h.tiles[ts.index]) = NIL OR tile.lh = NIL;    IF ts.field = flag THEN ts.field ¬ left;    IF h.typeIn # NIL AND h.typeIn­ # NIL THEN      count ¬ String.StringToNumber[        h.typeIn­, 10 ! String.InvalidNumber => CONTINUE];    IF count = 0 THEN RETURN;  -- What a turkey user!    IF clearing THEN s ¬ NIL    ELSE {      side: LONG STRING = (IF ts.field = left THEN tile.lh ELSE tile.rh);      s ¬ String.CopyToNewString[        side, Heap.systemZone, 100 - String.Length[side]]};    FOR i: CARDINAL IN [1..count] DO      IF (ts.index ¬ ts.index + h.numCols) >= h.tiles.length THEN EXIT;      IF clearing THEN {ClearTile[h, ts]; LOOP};      IF ts.field = left THEN        String.AppendString[          s, "+1"L ! String.StringBoundsFault => RESUME[TryThisString[]]];      WriteTile[        h, ts, s, TRUE !	  PanelSW.TileError => EXIT;	  PanelSW.ClientError => {Put.CR[h.err]; Put.Line[h.err, msg]; EXIT};          UNWIND => Heap.systemZone.FREE[@s]];      IF (tile ¬ h.tiles[ts.index]) = NIL OR tile.lh = NIL THEN EXIT;      IF ts.field = left THEN {        s.length ¬ 0;        String.AppendString[          s, tile.lh ! String.StringBoundsFault => RESUME[TryThisString[]]]};      ENDLOOP;    IF ~clearing THEN {      Heap.systemZone.FREE[@s];      IF (tile ¬ h.tiles[ts.index - h.numCols]) # NIL AND tile.lh # NIL THEN        IF ts.field = left THEN h.cProcs.modifyTypeIn[tile.lh, TRUE]}};  MinusOne: PUBLIC Menu.MCRType = {PlusOrMinusOne[window, "-1"L]};  PlusOne: PUBLIC Menu.MCRType = {PlusOrMinusOne[window, "+1"L]};  UpdateMCR: PUBLIC Menu.MCRType = {Update[PanelSWOps.FindContext[window]]};  MenuPNRDownPlace: PUBLIC PROC [h: PanelSWOps.Handle]    RETURNS [place: Window.Place] = {place ¬ menuPNRDownPlace};  ModifyLH: PUBLIC PROC [    h: PanelSWOps.Handle, ts: PanelSW.TileSpec, suffix: LONG STRING] = {    RealModifyLH[h, ts, suffix, FALSE]};  -- PRIVATE PROCs  DetermineAffectedTiles: PROC [h: PanelSWOps.Handle, box: POINTER TO Window.Box]    RETURNS [topLeft, bottomRight: PanelSW.TileSpec] = {    topLeft ¬ PanelSW.ResolvePlaceToTile[h, box.place, FALSE];    bottomRight ¬      IF topLeft.index = PanelSW.nilTileIndex THEN topLeft      ELSE PanelSW.ResolvePlaceToTile[        h, [x: box.place.x + box.dims.w - 1, y: box.place.y + box.dims.h - 1],        TRUE]};  NewValue: INTERNAL PROC [tile: PanelSWOps.Tile, new: LONG STRING] = {    IF new = NIL THEN tile.state ¬ bogus    ELSE {      tile.state ¬        IF String.Equivalent[tile.rh, new] THEN old ELSE changed;      Heap.systemZone.FREE[@tile.rh];      tile.rh ¬ new}};  PlusOrMinusOne: PROC [sw: Window.Handle, suffix: LONG STRING] = {    h: PanelSWOps.Handle;    ts: PanelSW.TileSpec;    IF (h ¬ PanelSWOps.FindContext[sw]) = NIL THEN RETURN;    ts ¬ PanelSW.ResolvePlaceToTile[h, menuPNRDownPlace, FALSE];    RealModifyLH[h, ts, suffix, TRUE !      PanelSW.TileError => CONTINUE;      PanelSW.ClientError => {Put.CR[h.err]; Put.Line[h.err, msg]; CONTINUE}]};  ReadTarget: INTERNAL PanelSWOps.ActOnTileProcType = {    tile: PanelSWOps.Tile = h.tiles[ts.index];    newRh: LONG STRING;    IF tile = NIL THEN RETURN;    newRh ¬ h.cProcs.readTarget[tile.regSpec, FALSE];    NewValue[tile, newRh]};  RealModifyLH: PROC [    h: PanelSWOps.Handle, ts: PanelSW.TileSpec, suffix: LONG STRING,    fudgeNil: BOOLEAN] = {    tile: PanelSWOps.Tile = PanelSWOps.TileFromSpec[h, ts];    s: LONG STRING;    IF tile = NIL OR tile.lh = NIL THEN      IF fudgeNil THEN {        IF h.typeIn # NIL THEN s ¬ String.CopyToNewString[	  h.typeIn­, Heap.systemZone, suffix.length]}      ELSE RETURN    ELSE s ¬ String.CopyToNewString[      h.tiles[ts.index].lh, Heap.systemZone, suffix.length];    String.AppendString[s, suffix];    ts.field ¬ left;    WriteTile[h, ts, s, TRUE];    Heap.systemZone.FREE[@s];    h.cProcs.modifyTypeIn[h.tiles[ts.index].lh, TRUE]};  END.  -- of PanelSWsB.mesa
-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: SymTabIOOps.mesa-- Last edit by DEG     : 26-Sep-84 23:25:04 -- Symbol Table Input/Output proceduresDIRECTORY  AssInputDefs USING [AssErr],  CodeOutputDefs USING [AddToRelocChain, UpdateStoredAddress],  Environment USING [bytesPerPage, bytesPerWord],  ExpressionDefs USING [EvalResult, EvaluateReversePolishStack, StackItem],  Inline USING [LowHalf],  ListOutputDefs USING [PutString, ReportUndefSymbol],  MStream USING [ReadWrite],  NewStateDefs USING [Address, MemoryAddress, OpType],  PrivateStringDefs USING [AppendHexNumber, CopyString],  SimHashDefs USING [    DumpToStream, EnumerateEntries, GetInfo, Hash, Lookup, JamValue,    TempStringForHash],  Stream USING [    Delete, GetPosition, Handle, Position, PutChar, PutWord, SetPosition],  String USING [AppendChar, AppendString],  SymbolStreamDefs USING [SetSymbolStream, WriteChar, WriteHex, WriteString],  SymbolTableDefs USING [    FreeSymTabNode, GetSymTabNode, LookUpInSymbolTable, PlaceList, Scope, STData,    unfItem],  SymTabIODefs USING [];SymTabIOOps: PROGRAM  IMPORTS    AssInputDefs, CodeOutputDefs, ExpressionDefs, Inline,    ListOutputDefs, MStream, PrivateStringDefs, SimHashDefs, Stream, String,    SymbolStreamDefs, SymbolTableDefs  EXPORTS SymTabIODefs =  BEGIN  UndefList, UndefListTail: LONG POINTER TO UndefListItem;  UndefListItem: TYPE = RECORD [    name: SimHashDefs.Hash, nxt: LONG POINTER TO UndefListItem];  DefList, DefListTail: LONG POINTER TO DefListItem;  DefListItem: TYPE = RECORD [    name: SimHashDefs.Hash,    value: NewStateDefs.MemoryAddress,    nxt: LONG POINTER TO DefListItem];  mapstream: Stream.Handle;  WriteToDotSymFile: PROCEDURE [h: SimHashDefs.Hash] RETURNS [BOOLEAN] =    BEGIN    d: LONG POINTER TO SymbolTableDefs.STData;    str: LONG STRING ¬ SimHashDefs.TempStringForHash[h];    q, r: LONG POINTER TO SymbolTableDefs.PlaceList;    ma: NewStateDefs.MemoryAddress;    [, d] ¬ SimHashDefs.GetInfo[h];    ma ¬      WITH x: d.val SELECT FROM        IOPmain => x.addr,        IOPregister => 0,  -- should never happen!        ENDCASE => ERROR;    q ¬ d.useChain;    SELECT d.type FROM      UnDef, DefSym =>        BEGIN        SymbolStreamDefs.WriteHex[ma, 6];        SymbolStreamDefs.WriteString[          SELECT d.extern FROM            exported => " E ",            imported => " I ",            ENDCASE => "   "];        SymbolStreamDefs.WriteString[str];        THROUGH [str.length..10] DO SymbolStreamDefs.WriteChar['  ]; ENDLOOP;        SymbolStreamDefs.WriteString[IF d.reloc THEN " R " ELSE " A "];        WHILE q # NIL DO          SymbolStreamDefs.WriteHex[q.pc, 5];          r ¬ q;          q ¬ q.nxt;          SymbolTableDefs.FreeSymTabNode[r];          ENDLOOP;        SymbolStreamDefs.WriteChar['\N ];        END;      ENDCASE => NULL;    RETURN[TRUE];    END;  WriteSymbolTable: PUBLIC PROCEDURE [s: Stream.Handle] =    BEGIN    SymbolStreamDefs.SetSymbolStream[s];    [] ¬ SimHashDefs.EnumerateEntries[WriteToDotSymFile];    Stream.PutWord[mapstream, 177777B];  --  mark end of Map Information    [] ¬ SimHashDefs.EnumerateEntries[PutExternalUseList];    Stream.PutWord[mapstream, 177777B];  --  mark end of External Use Lists    SimHashDefs.DumpToStream[mapstream];    mapstream ¬ NIL;    END;  PutExternalUseList: PROCEDURE [h: SimHashDefs.Hash] RETURNS [BOOLEAN] =    BEGIN    p: LONG POINTER TO SymbolTableDefs.STData;    q: LONG POINTER TO SymbolTableDefs.PlaceList;    v: NewStateDefs.MemoryAddress;    [, p] ¬ SimHashDefs.GetInfo[h];    q ¬ p.useChain;    v ¬ WITH p.val SELECT FROM IOPmain => addr, ENDCASE => ERROR;    SimHashDefs.JamValue[h, p.reloc, v];    IF p.extern # imported THEN RETURN[TRUE];    Stream.PutWord[mapstream, LOOPHOLE[h, CARDINAL]];    WHILE q # NIL DO      Stream.PutWord[mapstream, q.size];      Stream.PutWord[mapstream, q.pc];      q ¬ q.nxt;      ENDLOOP;    Stream.PutWord[mapstream, 177777B];  -- mark end of list    RETURN[TRUE];    END;  WriteBinderInformation: PUBLIC PROCEDURE [s: Stream.Handle] =    BEGIN    p: LONG POINTER TO DefListItem;    q: LONG POINTER TO UndefListItem;    ste: LONG POINTER TO SymbolTableDefs.STData;    u: LONG POINTER TO SymbolTableDefs.PlaceList;    str: STRING ¬ [48];    [] ¬ SimHashDefs.EnumerateEntries[BuildBinderTables];    IF DefList # NIL THEN      BEGIN      ListOutputDefs.PutString[s, "/Defined External Symbols"];      Stream.PutChar[s, '\N ];      Stream.PutChar[s, '\L ];      p ¬ DefList;      WHILE p # NIL DO        PrivateStringDefs.CopyString[str, SimHashDefs.TempStringForHash[p.name]];        String.AppendChar[str, '\T ];        PrivateStringDefs.AppendHexNumber[str, p.value, 5];        ListOutputDefs.PutString[s, str];        Stream.PutChar[s, '\N ];        Stream.PutChar[s, '\L ];        p ¬ p.nxt;        SymbolTableDefs.FreeSymTabNode[DefList];        DefList ¬ p;        ENDLOOP;      DefListTail ¬ DefList;      END;    IF UndefList # NIL THEN      BEGIN      ListOutputDefs.PutString[s, "/Undefined External Symbols"];      Stream.PutChar[s, '\N ];      Stream.PutChar[s, '\L ];      q ¬ UndefList;      WHILE q # NIL DO        ListOutputDefs.PutString[s, SimHashDefs.TempStringForHash[q.name]];        [, ste] ¬ SimHashDefs.GetInfo[q.name];        u ¬ ste.useChain;        IF u = NIL THEN  --  Not used in module          BEGIN          Stream.PutChar[s, '\T ];          ListOutputDefs.PutString[s, "0000 (unreferenced)"L];          Stream.PutChar[s, '\N ];          Stream.PutChar[s, '\L ];          END        ELSE          WHILE u # NIL DO            Stream.PutChar[s, '\T ];            str.length ¬ 0;            PrivateStringDefs.AppendHexNumber[str, u.pc, 4];            String.AppendString[              str, IF u.size = 2 THEN " (word)"L ELSE " (byte)"L];            String.AppendString[str, "  at ("L];            PrivateStringDefs.AppendHexNumber[              str, Inline.LowHalf[u.StreamPlace/Environment.bytesPerPage], 2];            String.AppendString[str, ","L];            PrivateStringDefs.AppendHexNumber[              str, Inline.LowHalf[u.StreamPlace MOD Environment.bytesPerPage], 2];            String.AppendChar[str, ')];            ListOutputDefs.PutString[s, str];            Stream.PutChar[s, '\N ];            Stream.PutChar[s, '\L ];            u ¬ u.nxt;            ENDLOOP;        q ¬ q.nxt;        SymbolTableDefs.FreeSymTabNode[UndefList];        UndefList ¬ q;        ENDLOOP;      UndefListTail ¬ UndefList;      END;    END;  BuildBinderTables: PROCEDURE [h: SimHashDefs.Hash] RETURNS [BOOLEAN] =    BEGIN    d: LONG POINTER TO SymbolTableDefs.STData;    ma: NewStateDefs.MemoryAddress;    [, d] ¬ SimHashDefs.GetInfo[h];    ma ¬      WITH x: d.val SELECT FROM        IOPmain => x.addr,        IOPregister => 0,        ENDCASE => ERROR;    IF d.extern = imported THEN AddToUndefList[h]    ELSE      BEGIN      IF d.extern = exported THEN AddToDefList[h, ma];      IF d.type = UnDef THEN        ListOutputDefs.ReportUndefSymbol[SimHashDefs.TempStringForHash[h]];      END;    RETURN[TRUE];    END;  AddToUndefList: PROCEDURE [s: SimHashDefs.Hash] =    BEGIN    UndefListTail ¬      (IF UndefListTail = NIL THEN SymbolTableDefs.GetSymTabNode[       SIZE[UndefListItem]]       ELSE         (UndefListTail.nxt ¬ SymbolTableDefs.GetSymTabNode[           SIZE[UndefListItem]]));    UndefListTail­ ¬ [s, NIL];    IF UndefList = NIL THEN UndefList ¬ UndefListTail;    END;  AddToDefList: PROCEDURE [s: SimHashDefs.Hash, ma: NewStateDefs.MemoryAddress] =    BEGIN    DefListTail ¬      (IF DefListTail = NIL THEN SymbolTableDefs.GetSymTabNode[SIZE[DefListItem]]       ELSE (DefListTail.nxt ¬ SymbolTableDefs.GetSymTabNode[SIZE[DefListItem]]));    DefListTail­ ¬ [s, ma, NIL];    IF DefList = NIL THEN DefList ¬ DefListTail;    END;  AddToUseChain: PUBLIC PROCEDURE [    hd: LONG POINTER TO SymbolTableDefs.STData, p: Stream.Position,    size: CARDINAL, pc: NewStateDefs.MemoryAddress] =    BEGIN    new: LONG POINTER TO SymbolTableDefs.PlaceList ¬ SymbolTableDefs.GetSymTabNode[      SIZE[SymbolTableDefs.PlaceList]];    u: LONG POINTER TO SymbolTableDefs.PlaceList ¬ hd.useChain;    new­ ¬ [p, size, pc, ];    IF u = NIL OR pc < u.pc THEN      BEGIN new.nxt ¬ hd.useChain; hd.useChain ¬ new; RETURN; END;    WHILE u.nxt # NIL AND u.nxt.pc < pc DO u ¬ u.nxt; ENDLOOP;    new.nxt ¬ u.nxt;    u.nxt ¬ new;    END;  ProcessUseChain: PUBLIC PROCEDURE [STE: LONG POINTER TO SymbolTableDefs.STData] =    BEGIN    p: LONG POINTER TO SymbolTableDefs.PlaceList;    ma: NewStateDefs.MemoryAddress ¬      WITH x: STE.val SELECT FROM IOPmain => x.addr, ENDCASE => ERROR;    p ¬ STE.useChain;    WHILE p # NIL DO      CodeOutputDefs.UpdateStoredAddress[p.pc, p.size, ma]; p ¬ p.nxt; ENDLOOP;    END;  AddToUnfinishedChain: PUBLIC PROCEDURE [    u: LONG POINTER TO ExpressionDefs.StackItem, id: LONG STRING, size: CARDINAL,    pc: NewStateDefs.MemoryAddress] =    BEGIN    rec: LONG POINTER TO SymbolTableDefs.unfItem ¬ SymbolTableDefs.GetSymTabNode[      SIZE[SymbolTableDefs.unfItem]];    ste: LONG POINTER TO SymbolTableDefs.STData ¬ SymbolTableDefs.LookUpInSymbolTable[      id];    unf: LONG POINTER TO SymbolTableDefs.unfItem;    IF ste = NIL THEN SIGNAL AssInputDefs.AssErr[18];    unf ¬ ste.unfinishedChain;    rec­ ¬ [u, size, pc, ];    IF unf = NIL OR pc < unf.pc THEN      BEGIN rec.nxt ¬ ste.unfinishedChain; ste.unfinishedChain ¬ rec; RETURN; END;    WHILE unf.nxt # NIL AND unf.nxt.pc < pc DO unf ¬ unf.nxt; ENDLOOP;    rec.nxt ¬ unf.nxt;    unf.nxt ¬ rec;    END;  ProcessUnfinishedChain: PUBLIC PROCEDURE [    ste: LONG POINTER TO SymbolTableDefs.STData] =    BEGIN    ptr: LONG POINTER TO SymbolTableDefs.unfItem ¬ ste.unfinishedChain;    rec: LONG POINTER TO SymbolTableDefs.unfItem;    EvalRes: ExpressionDefs.EvalResult;    ste.unfinishedChain ¬ NIL;    WHILE ptr # NIL DO      rec ¬ ptr;      ptr ¬ ptr.nxt;      EvalRes ¬ ExpressionDefs.EvaluateReversePolishStack[rec.rps];      WITH EvalRes SELECT FROM        TRUE =>          BEGIN          CodeOutputDefs.UpdateStoredAddress[rec.pc, 2, res.v];          IF res.r THEN CodeOutputDefs.AddToRelocChain[rec.pc];          END;        FALSE => AddToUnfinishedChain[rps, id, rec.size, rec.pc];        ENDCASE;      SymbolTableDefs.FreeSymTabNode[rec];      ENDLOOP;    END;  PutAddressMapInformation: PUBLIC PROCEDURE [    s: LONG STRING, off, pc, f: CARDINAL, si: Stream.Position] =    BEGIN    h: SimHashDefs.Hash;    old: BOOLEAN;    [h, old] ¬ SimHashDefs.Lookup[s, FALSE];    IF ~old THEN ERROR;    Stream.PutWord[mapstream, LOOPHOLE[h]];    Stream.PutWord[mapstream, off];    Stream.PutWord[mapstream, pc];    Stream.PutWord[mapstream, f];    Stream.PutWord[mapstream, Inline.LowHalf[si/Environment.bytesPerPage]];    Stream.PutWord[mapstream, Inline.LowHalf[si MOD Environment.bytesPerPage]];    END;  RemoveLastMapEntry: PUBLIC PROCEDURE =    BEGIN    t: Stream.Position = Stream.GetPosition[mapstream];    Stream.SetPosition[      mapstream,      IF t > (6*Environment.bytesPerWord) THEN t - (6*Environment.bytesPerWord)      ELSE 0];  -- = 6 words    END;  CreateMapStream: PUBLIC PROCEDURE [fname: STRING] =    BEGIN    IF mapstream ~= NIL THEN Stream.Delete[sH: mapstream];    mapstream ¬ MStream.ReadWrite[name: fname, release: [NIL, NIL], type: binary];    END;  ReInit: PUBLIC PROC =    BEGIN    UndefList ¬ UndefListTail ¬ NIL;    DefList ¬ DefListTail ¬ NIL;    IF mapstream # NIL THEN Stream.Delete[sH: mapstream];    mapstream ¬ NIL;    END;  Init: PROCEDURE =    BEGIN    UndefList ¬ UndefListTail ¬ NIL;    DefList ¬ DefListTail ¬ NIL;    mapstream ¬ NIL;    END;  Init[];  END...    -- LOG  --   ETN      -  4-Apr-82 20:50:00  - Convert to Trinity.  --   ETN      -  4-Oct-82 16:28:45  - Fix Alto compatability.  --   DEG     	- 15-Feb-83 14:59:30  - Fix symbol relocation bug.  --   DEG      - 29-May-83 16:34:36  - Release map stream during ReInit if necessary.  --	DEG      - 30-May-83 16:35:19 - Remove references to the Ascii interface.  --   DEG      - 16-Sep-83 10:01:33 - Converted to Klamath 11.0b  -- Time: 26-Sep-84 23:24:59	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
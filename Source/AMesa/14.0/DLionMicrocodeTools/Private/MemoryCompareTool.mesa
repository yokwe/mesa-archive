-- MemoryCompareTool.mesa-- Create by FormSWLayoutTool on 13-Nov-87 10:57DIRECTORY  Exec,  Format,  FormSW,  Heap,  MStream,   Process,  Put,  Runtime,  Stream,  String,  StringExtras,  Time,  Tool,  ToolWindow,  UserInput,  Window,  WindowFont,  Bindweed,  CPKernel,  IOPKernel;MemoryCompareTool: MONITOR  IMPORTS    Exec, Format, FormSW, Heap, MStream, Process, Put, Runtime, Stream, String, StringExtras, Time, Tool, UserInput, WindowFont, CPKernel, Bindweed, IOPKernel = {  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    formSW(2): Window.Handle ¬ NIL,    fileSW(4): Window.Handle ¬ NIL,    verbose(6): BOOLEAN ¬ TRUE,    abortOnMismatch(7): BOOLEAN ¬ FALSE,    machineType(8): MachineTypeType ¬ DLion,    startingAddress(9): LONG STRING ¬ NIL,    addressType(11): AddressTypeType ¬ Real,    endingAddress(12): LONG STRING ¬ NIL,    outputBase(14): OutputBaseType ¬ Hex,    file(15): LONG STRING ¬ NIL];          MachineTypeType: TYPE = {DLion, Dove};  AddressTypeType: TYPE = {Real, Virtual, IOP};  OutputBaseType: TYPE = {Octal, Decimal, Hex};  FormItems: TYPE = {compare, dump, instructions, verbose, abortOnMismatch, machineType, startingAddress, addressType, endingAddress, outputBase, file};  data: DataHandle ¬ NIL;  wh: Window.Handle ¬ NIL;  zone: UNCOUNTED ZONE ¬ Heap.systemZone;  busyBit: BOOLEAN ¬ FALSE;  Busy: ENTRY PROCEDURE RETURNS [isBusy: BOOLEAN] = {    ENABLE UNWIND => NULL;    isBusy ¬ busyBit;    busyBit ¬ TRUE };  Done: ENTRY PROCEDURE = {    ENABLE UNWIND => NULL;    busyBit ¬ FALSE;    Write["\nDone.\n"L]};  Write: Format.StringProc = {Put.Text[data.fileSW, s]};  Msg: Format.StringProc = {Put.Text[data.msgSW, s]};    <<     =========================================================================     Global Variables     =========================================================================>>startingAddress, endingAddress, currentAddress: LONG CARDINAL ¬ 0;filePosition, mismatchCount: LONG CARDINAL ¬ 0;mismatchFound: BOOLEAN ¬ FALSE;streamWord, memoryWord: CARDINAL ¬ 0;handle: MStream.Handle ¬ NIL;ok: BOOLEAN ¬ FALSE;wordCount: CARDINAL ¬ 0;readBlockSequence: LONG POINTER TO Bindweed.Sequence ¬ NIL;       OpenInputFile: PROC [file: LONG STRING]     RETURNS [s: MStream.Handle _ NIL] =     BEGIN     OPEN MStream;            s _ MStream.ReadOnly[file, [] !	   MStream.Error => IF code = fileNotAvailable THEN GO TO notFound];	          RETURN[s];              EXITS       notFound =>           BEGIN	  RETURN[NIL];	  END;	     END;       WriteCardinal: PROC[n: CARDINAL, base: CARDINAL, rightJustify: BOOLEAN] =     BEGIN     s: LONG STRING ¬ [40];     zeroString: LONG STRING ¬ "0000000000000000"L;          String.AppendLongNumber[s, LONG[n], base];          SELECT base FROM        8 => String.AppendChar[s, 'B];        10 => String.AppendChar[s, 'D];        ENDCASE;          IF rightJustify THEN        BEGIN	zeroString.length ¬ 0;	IF base = 8 AND s.length < 7 THEN	      zeroString.length ¬ 7 - s.length	ELSE IF base = 10 AND s.length < 6 THEN	      zeroString.length ¬ 6 - s.length	ELSE IF base = 16 AND s.length < 4 THEN	      zeroString.length ¬ 4 - s.length;	Write[zeroString];	END;	     Write[s];     END;       WriteByte: PROC[n: CARDINAL, base: CARDINAL, rightJustify: BOOLEAN] =     BEGIN     s: LONG STRING ¬ [40];     zeroString: LONG STRING ¬ "0000000000000000"L;          String.AppendLongNumber[s, LONG[n], base];          SELECT base FROM        8 => String.AppendChar[s, 'B];        10 => String.AppendChar[s, 'D];        ENDCASE;          IF rightJustify THEN        BEGIN	zeroString.length ¬ 0;	IF base = 8 AND s.length < 4 THEN	      zeroString.length ¬ 4 - s.length	ELSE IF base = 10 AND s.length < 4 THEN	      zeroString.length ¬ 4 - s.length	ELSE IF base = 16 AND s.length < 2 THEN	      zeroString.length ¬ 2 - s.length;	Write[zeroString];	END;	     Write[s];     END;        WriteLongCardinal: PROC[n: LONG CARDINAL, base: CARDINAL] =     BEGIN     s: LONG STRING ¬ [40];          String.AppendLongNumber[s, n, base];          SELECT base FROM        8 => String.AppendChar[s, 'B];        16 => String.AppendChar[s, 'H];        ENDCASE;          Write[s];     END;    Error: PUBLIC PROC[s1,s2,s3,s4: LONG STRING ¬ NIL] =      BEGIN      Write["Error -- "];      IF s1 # NIL THEN Write[s1];      IF s2 # NIL THEN Write[s2];      IF s3 # NIL THEN Write[s3];      IF s4 # NIL THEN Write[s4];      Write["\n"];      END;     EnumToBase: PROC[enumBase: OutputBaseType] RETURNS[CARDINAL] =     BEGIN     SELECT enumBase FROM	Octal => RETURN[8];	Decimal => RETURN[10];	Hex => RETURN[16];	ENDCASE;     RETURN[16];     END;            DateFormatProc: Format.StringProc =   BEGIN   Write[s];   END;     GetMemWordOrByte: PROC[address: LONG CARDINAL] RETURNS[CARDINAL] =     BEGIN          readBlockSequence.length ¬ 1;          IF data.machineType = DLion THEN        BEGIN	SELECT data.addressType FROM	   Real => RETURN[CPKernel.ReadRealMemory[LOOPHOLE[address]]];	   Virtual => RETURN[CPKernel.ReadVirturalMemory[LOOPHOLE[address]]];	   IOP => RETURN[CARDINAL[IOPKernel.ReadMemory[CARDINAL[address]]]];	   ENDCASE => RETURN[0];	END     ELSE        BEGIN	SELECT data.addressType FROM	   Real =>	      BEGIN	      RETURN[0];	      <<	      Bindweed.ReadMemoryBlock[LOOPHOLE[address], real, readBlockSequence];	      RETURN[CARDINAL[readBlockSequence[0]]];	      >>	      END;	   Virtual =>	      BEGIN	      RETURN[0];	      <<	      Bindweed.ReadMemoryBlock[LOOPHOLE[address], virtual, readBlockSequence];	      RETURN[CARDINAL[readBlockSequence[0]]];	      >>	      END;	   IOP =>	      BEGIN	      Bindweed.ReadMemoryBlock[LOOPHOLE[address], iOPLogical, readBlockSequence];	      RETURN[CARDINAL[readBlockSequence[0]]];	      END;	   ENDCASE => RETURN[0];	END;     END;  Compare:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK CompareInternal[]]};  CompareInternal: PROCEDURE = {    ENABLE       BEGIN       ABORTED =>          BEGIN	  Done[]; CONTINUE	  END;       CPKernel.Error => 	  BEGIN	  Write["Error -- "L];	  Write[reason];	  Write["\nCompare Aborted.\n"L];	  GO TO Stop;	  END;       END;        IF data.machineType = DLion AND NOT Runtime.IsBound[LOOPHOLE[CPKernel.ReadRealMemory, Runtime.ControlLink]] THEN       BEGIN       Error["Burdock must be running to use this tool with MachineType = DLion.\n",,,];       Done[];       RETURN[];       END    ELSE IF data.machineType = Dove AND    NOT Runtime.IsBound[LOOPHOLE[Bindweed.ReadMemoryBlock, Runtime.ControlLink]] THEN       BEGIN       Error["Bermuda must be running to use this tool with MachineType = Dove.\n",,,];       Done[];       RETURN[];       END;                   Write["\nStarting Compare		"L];    Format.Date[DateFormatProc, Time.Current[], dateTime];    Write["\n"L];        IF data.file = NIL OR data.file.length = 0 THEN      BEGIN      Error["No file name specified.\n",,,];      Done[];      RETURN[];      END;          IF data.startingAddress = NIL OR data.startingAddress.length = 0 THEN      BEGIN      Error["No starting address specified.\n",,,];      Done[];      RETURN[];      END;            IF data.endingAddress = NIL OR data.endingAddress.length = 0 THEN      BEGIN      Error["No ending address specified.\n",,,];      Done[];      RETURN[];      END;      [ok, startingAddress] ¬       StringExtras.StringToLongCardinal[data.startingAddress];      IF NOT ok THEN      BEGIN      Error["Starting Address is not a valid number.\n",,,];      Done[];      RETURN[];      END;      [ok, endingAddress] ¬       StringExtras.StringToLongCardinal[data.endingAddress];          IF NOT ok THEN      BEGIN      Error["Ending Address is not a valid number.\n",,,];      Done[];      RETURN[];      END;       <<      startingAddress ¬ String.StringToLongNumber[data.startingAddress, 10!      String.InvalidNumber =>         BEGIN	 Error["Starting Address is not a valid number.",,,];	 GO TO Stop;	 END];         endingAddress ¬ String.StringToLongNumber[data.endingAddress, 10!      String.InvalidNumber =>         BEGIN	 Error["Ending Address is not a valid number.",,,];	 GO TO Stop;	 END];	 >>        IF startingAddress > endingAddress THEN      BEGIN      Error["Starting address must be less than ending address.\n",,,];      Done[];      RETURN[];      END;         handle ¬ OpenInputFile[data.file];   IF handle = NIL THEN      BEGIN      Error["File """, data.file, """ cannot be opened.\n",];      Done[];      RETURN[];      END;               filePosition ¬ 0;   mismatchCount ¬ 0;   mismatchFound ¬ FALSE;   streamWord ¬ memoryWord ¬ 0;   wordCount ¬ 0;   currentAddress ¬ startingAddress;      WHILE (NOT MStream.EndOf[handle]) AND (currentAddress <= endingAddress)      DO      IF data.addressType = IOP THEN         streamWord ¬ CARDINAL[Stream.GetByte[handle]]      ELSE	 streamWord ¬ CARDINAL[Stream.GetWord[handle!	    Stream.EndOfStream =>	       BEGIN	       streamWord ¬ 0;	       Write["Warning -- File """L];	       Write[data.file];	       Write[""" contains an odd number of bytes."L];	       CONTINUE;	       END]];      	          memoryWord ¬ GetMemWordOrByte[currentAddress];<<            IF data.addressType = Real THEN         memoryWord ¬ CPKernel.ReadRealMemory[LOOPHOLE[currentAddress]]      ELSE         memoryWord ¬ CPKernel.ReadVirturalMemory[LOOPHOLE[currentAddress]];>>	       IF streamWord # memoryWord THEN         BEGIN	 mismatchFound ¬ TRUE;	 mismatchCount ¬ mismatchCount + 1;	 IF data.verbose THEN	    BEGIN	    Write["\nMismatch - file pos: "L];	    WriteLongCardinal[filePosition, 10];	    Write[", "L];	    	    Write["Adrs: "L];	    WriteLongCardinal[currentAddress, 16];	    Write[".  "L];	    	    Write["File Word: "L];	    IF data.addressType = IOP THEN	       WriteByte[streamWord, EnumToBase[data.outputBase], TRUE]	    ELSE	       WriteCardinal[streamWord, EnumToBase[data.outputBase], TRUE];	       	    Write[", Memory Word: "L];	    IF data.addressType = IOP THEN	       WriteByte[memoryWord, EnumToBase[data.outputBase], TRUE]	    ELSE	       WriteCardinal[memoryWord, EnumToBase[data.outputBase], TRUE];	       	    Write[". \n"L];	    END;	 END;	       IF data.addressType = IOP THEN         filePosition ¬ filePosition + 1      ELSE         filePosition ¬ filePosition + 2;	       currentAddress ¬ currentAddress + 1;	       IF UserInput.UserAbort[data.fileSW] THEN         BEGIN	 Write["User Abort.\n"];	 Stream.Delete[handle];	 Done[];	 RETURN[];	 END;	       IF data.abortOnMismatch AND mismatchCount > 0 THEN         BEGIN	 Write["\nCompare stopped after first missmatch.\n"];	 Stream.Delete[handle];	 Done[];	 RETURN[];	 END;      Process.Yield[];            wordCount ¬ wordCount + 1;      IF wordCount >= 100 THEN         BEGIN         Write["."L];	 wordCount ¬ 0;	 END;	       ENDLOOP;       IF NOT MStream.EndOf[handle] THEN      BEGIN      Write["Warning -- End of block encountered before EOF.\n"L];      END   ELSE IF currentAddress <= endingAddress THEN      BEGIN      Write["Warning -- Early EOF found for """L];      Write[data.file];      Write[""".  "L];      END;      Stream.Delete[handle];      IF NOT mismatchFound THEN      BEGIN      Write["Files found to be identical.  \n"];      END   ELSE      BEGIN      IF mismatchCount > 1 THEN         BEGIN	 WriteLongCardinal[mismatchCount, 10];	 Write[" mismatches found.  "L];	 END      ELSE         BEGIN	 WriteLongCardinal[mismatchCount, 10];	 Write[" mismatch found.  "L];	 END;	       Write["\n"];      END;            Done[]             EXITS        Stop => { Done[] };        };  Dump:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK DumpInternal[]]};  DumpInternal: PROCEDURE = {    ENABLE       BEGIN       ABORTED =>          BEGIN	  Done[]; CONTINUE	  END;       CPKernel.Error => 	  BEGIN	  Write["Error -- "L];	  Write[reason];	  Write["\nCompare Aborted.\n"L];	  GO TO Stop;	  END;       END;        cardsOnLine: CARDINAL = 8;    bytesOnLine: CARDINAL = 16;    numbersOnLineCount: CARDINAL ¬ 0;        IF NOT Runtime.IsBound[LOOPHOLE[CPKernel.ReadRealMemory, Runtime.ControlLink]] THEN       BEGIN       Error["Burdock must be running to use this tool.\n",,,];       Done[];       RETURN[];       END;           Write["\nStarting Memory Dump...\n\n"L];        IF data.startingAddress = NIL OR data.startingAddress.length = 0 THEN      BEGIN      Error["No starting address specified.\n",,,];      Done[];      RETURN[];      END;            IF data.endingAddress = NIL OR data.endingAddress.length = 0 THEN      BEGIN      Error["No ending address specified.\n",,,];      Done[];      RETURN[];      END;   [ok, startingAddress] ¬       StringExtras.StringToLongCardinal[data.startingAddress];      IF NOT ok THEN      BEGIN      Error["Starting Address is not a valid number.",,,];      RETURN[];      END;      [ok, endingAddress] ¬       StringExtras.StringToLongCardinal[data.endingAddress];          IF NOT ok THEN      BEGIN      Error["Ending Address is not a valid number.",,,];      RETURN[];      END;       <<      startingAddress ¬ String.StringToLongNumber[data.startingAddress, 10!      String.InvalidNumber =>         BEGIN	 Error["Starting Address is not a valid number.",,,];	 GO TO Stop;	 END];         endingAddress ¬ String.StringToLongNumber[data.endingAddress, 10!      String.InvalidNumber =>         BEGIN	 Error["Ending Address is not a valid number.",,,];	 GO TO Stop;	 END];>>	          IF startingAddress > endingAddress THEN      BEGIN      Error["Starting address must be less than ending address.\n",,,];      Done[];      RETURN[];      END;         currentAddress ¬ startingAddress;      WriteLongCardinal[currentAddress, 16];   Write[":	"L];   WHILE currentAddress <= endingAddress      DO            memoryWord ¬ GetMemWordOrByte[currentAddress];<<            IF data.addressType = Real THEN         memoryWord ¬ CPKernel.ReadRealMemory[LOOPHOLE[currentAddress]]      ELSE         memoryWord ¬ CPKernel.ReadVirturalMemory[LOOPHOLE[currentAddress]];	 >>       IF data.addressType = IOP THEN	 WriteByte[memoryWord, EnumToBase[data.outputBase], TRUE]      ELSE	 WriteCardinal[memoryWord, EnumToBase[data.outputBase], TRUE];	                   IF data.addressType = IOP THEN         Write[" "L]      ELSE         Write["  "L];	       numbersOnLineCount ¬ numbersOnLineCount + 1;      currentAddress ¬ currentAddress + 1;            IF (data.addressType = IOP AND numbersOnLineCount >= bytesOnLine) OR         (data.addressType # IOP AND numbersOnLineCount >= cardsOnLine) THEN         BEGIN         Write["\n"L];	 IF currentAddress <= endingAddress THEN	    BEGIN	    WriteLongCardinal[currentAddress, 16];	    Write[":	"L];	    END;	 numbersOnLineCount ¬ 0;	 END;	       IF UserInput.UserAbort[data.fileSW] THEN         BEGIN	 Write["User Abort.\n"];	 Done[];	 RETURN[];	 END;            ENDLOOP;            Done[]             EXITS        Stop => { Done[] };	       };  Instructions:  FormSW.ProcType = {    ENABLE ABORTED => {Done[]; CONTINUE};    IF Busy[] THEN {      Msg["Tool is busy.\n"L];      RETURN};    Process.Detach[FORK InstructionsInternal[]]};  InstructionsInternal: PROCEDURE = {    ENABLE ABORTED => {Done[]; CONTINUE};    Write["Instructions called\n"L];    Done[] };  ClientTransition: ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>         BEGIN         IF data = NIL THEN data ¬ zone.NEW[Data ¬ []];	 readBlockSequence ¬ zone.NEW[Bindweed.Sequence[1]];	 END;      new = inactive =>         BEGIN        IF data # NIL THEN {zone.FREE[@data]};	zone.FREE[@readBlockSequence];	END;      ENDCASE;    };  Init: PROCEDURE = {    Exec.AddCommand["MemoryCompareTool.~"L, NoOp, NIL, Unload];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: "MemoryCompareTool"L,      cmSection: "MemoryCompareTool"L];    };      NoOp: Exec.ExecProc = { };    Unload: Exec.ExecProc = {    IF Busy[] THEN {      Exec.OutputProc[h]["Tool is busy. Sorry.\n"L];      RETURN[error] };    Tool.Destroy[wh];    Exec.RemoveCommand[h, "MemoryCompareTool.~"L];    Done[] };  MakeSWs: Tool.MakeSWsProc = {    logName: LONG STRING ¬ [24];    Tool.UnusedLogName[unused: logName, root: "MemoryCompareTool.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    };  charWidth: CARDINAL ¬ WindowFont.CharWidth['0];  CharPos: PROC[char: CARDINAL] RETURNS [x: INTEGER] = {    x ¬ charWidth * char};  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    machineType: ARRAY[0..2) OF Enumerated ¬ [      ["DLion"L, 0], ["Dove"L, 1]];    addressType: ARRAY[0..3) OF Enumerated ¬ [      ["Real"L, 0], ["Virtual"L, 1],      ["IOP"L, 2]];    outputBase: ARRAY[0..3) OF Enumerated ¬ [      ["Octal"L, 0],      ["Decimal"L, 1], ["Hex"L, 2]];    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.compare.ORD] ¬ CommandItem[      tag: "Compare"L, place: [CharPos[2], line0], proc: Compare];    items[FormItems.dump.ORD] ¬ CommandItem[      tag: "Dump"L, place: [CharPos[12], line0], proc: Dump];    items[FormItems.instructions.ORD] ¬ CommandItem[      tag: "Instructions"L, place: [CharPos[19], line0], proc: Instructions];    items[FormItems.verbose.ORD] ¬ BooleanItem[      tag: "Verbose"L, place: [CharPos[34], line0], switch: @data.verbose];    items[FormItems.abortOnMismatch.ORD] ¬ BooleanItem[      tag: "AbortOnMismatch"L, place: [CharPos[43], line0], switch: @data.abortOnMismatch];    items[FormItems.machineType.ORD] ¬ EnumeratedItem[      tag: "MachineType"L, place: [CharPos[60], line0], choices: DESCRIPTOR[machineType], value: @data.machineType];    items[FormItems.startingAddress.ORD] ¬ StringItem[      tag: "StartingAddress "L, place: [CharPos[2], line1], inHeap: TRUE, string: @data.startingAddress];    items[FormItems.addressType.ORD] ¬ EnumeratedItem[      tag: "AddressType"L, place: [CharPos[43], line1], choices: DESCRIPTOR[addressType], value: @data.addressType];    items[FormItems.endingAddress.ORD] ¬ StringItem[      tag: "EndingAddress   "L, place: [CharPos[2], line2], inHeap: TRUE, string: @data.endingAddress];    items[FormItems.outputBase.ORD] ¬ EnumeratedItem[      tag: "OutputBase"L, place: [CharPos[43], line2], choices: DESCRIPTOR[outputBase], value: @data.outputBase];    items[FormItems.file.ORD] ¬ StringItem[      tag: "File"L, place: [CharPos[2], line3], inHeap: TRUE, string: @data.file];    RETURN[items: items, freeDesc: TRUE];    };  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
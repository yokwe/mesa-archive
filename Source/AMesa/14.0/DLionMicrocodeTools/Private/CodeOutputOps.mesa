-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- Last edited by DEG      on 26-Sep-84 23:06:37 - See Log at end--  CodeOutputOps.mesa--  This module handles all output to the .bin fileDIRECTORY  CodeOutputDefs USING [DefaultCodeLineLength, MapType, PrefixLength, RelocRec],  Heap USING [systemZone],  Inline USING [BITSHIFT, BITAND],  ListOutputDefs USING [PutString],  NewStateDefs USING [MemoryAddress],  PrivateStorage USING [heapPointer],  PrivateStringDefs USING [AppendHexNumber],  Stream USING [GetChar, GetPosition, Handle, Position, PutChar, SetPosition],  String USING [AppendString, AppendChar],  SymTabIODefs USING [WriteBinderInformation];CodeOutputOps: PROGRAM  IMPORTS    Heap, Inline, ListOutputDefs, PrivateStorage, PrivateStringDefs, Stream, String, SymTabIODefs  EXPORTS CodeOutputDefs =  BEGIN  CodeLine: LONG STRING;  BinaryStream: Stream.Handle;  MapChain: LONG POINTER TO CodeOutputDefs.MapType;  pc, CheckSum, LinePC: CARDINAL;  CodeLineComplete: BOOLEAN;  RelocChain: LONG POINTER TO CodeOutputDefs.RelocRec;  UpdateStoredAddress: PUBLIC PROCEDURE [    p, size: CARDINAL, val: NewStateDefs.MemoryAddress] =    BEGIN    SaveSI: Stream.Position ¬ Stream.GetPosition[BinaryStream];    cs, valcs: CARDINAL;    cll: CARDINAL ¬ CodeLine.length;    s: STRING ¬ [4];    ptr: LONG POINTER TO CodeOutputDefs.MapType ¬ MapChain;    TempLine: LONG STRING ¬ Heap.systemZone.NEW[StringBody[48]];    copyTemp: LONG STRING ¬ TempLine; -- for freeing when done    valcs ¬ val MOD 256;    PrivateStringDefs.AppendHexNumber[s, valcs, 2];    IF size = 2 THEN      BEGIN      PrivateStringDefs.AppendHexNumber[s, val/256, 2];      valcs ¬ valcs + val/256;      END;    IF p < LinePC THEN      BEGIN      WHILE ptr.ProgCntr > p DO ptr ¬ ptr.backptr; ENDLOOP;      Stream.SetPosition[BinaryStream, ptr.SI];      GetCodeLine[BinaryStream, TempLine];      Stream.SetPosition[BinaryStream, ptr.SI];      cll ¬ TempLine.length;      TempLine.length ¬ 2*(p - ptr.ProgCntr) + CodeOutputDefs.PrefixLength;      END    ELSE BEGIN TempLine ¬ CodeLine; TempLine.length ¬ 2*(p - LinePC); END;    String.AppendString[TempLine, s];    TempLine.length ¬ cll;    IF TempLine # CodeLine THEN      BEGIN      cs ¬        (IF TempLine[cll - 2] IN ['0..'9] THEN TempLine[cll - 2] - '0         ELSE TempLine[cll - 2] - 'A + 10)*16 +          (IF TempLine[cll - 1] IN ['0..'9] THEN TempLine[cll - 1] - '0           ELSE TempLine[cll - 1] - 'A + 10);      cs ¬ valcs - cs;      TempLine.length ¬ cll - 2;      PrivateStringDefs.AppendHexNumber[TempLine, 0 - cs, 2];      ListOutputDefs.PutString[BinaryStream, TempLine];      END    ELSE CheckSum ¬ CheckSum + valcs;    Stream.SetPosition[BinaryStream, SaveSI];    Heap.systemZone.FREE[@copyTemp];    END;  GetCodeLine: PROCEDURE [str: Stream.Handle, s: LONG STRING] =    BEGIN    i: CARDINAL;    s.length ¬ 0;    String.AppendChar[s, Stream.GetChar[sH: str]];    String.AppendChar[s, Stream.GetChar[sH: str]];    String.AppendChar[s, Stream.GetChar[sH: str]];    i ¬      (IF s[1] IN ['0..'9] THEN s[1] - '0 ELSE s[1] - 'A + 10)*16 +        (IF s[2] IN ['0..'9] THEN s[2] - '0 ELSE s[2] - 'A + 10);    THROUGH [0..2*i + 8) DO      String.AppendChar[s, Stream.GetChar[sH: str]]; ENDLOOP;    END;  CodePut: PUBLIC PROCEDURE [b, n: CARDINAL] =    BEGIN    IF CodeLineComplete THEN      BEGIN CodeLineComplete ¬ FALSE; BuildAndPutCodeLine[]; END;    PrivateStringDefs.AppendHexNumber[CodeLine, b, 2];    CheckSum ¬ CheckSum + b MOD 256;    IF n = 2 THEN      BEGIN      PrivateStringDefs.AppendHexNumber[CodeLine, Inline.BITSHIFT[b, -8], 2];      CheckSum ¬ CheckSum + b/256;      END;    IF CodeLine.length >= 2*CodeOutputDefs.DefaultCodeLineLength THEN      CodeLineComplete ¬ TRUE;    END;  AddToMapChain: PUBLIC PROCEDURE [    s: Stream.Position, p: NewStateDefs.MemoryAddress] =    BEGIN    ptr: LONG POINTER TO CodeOutputDefs.MapType;    m: LONG POINTER TO CodeOutputDefs.MapType ¬ PrivateStorage.heapPointer.NEW[      CodeOutputDefs.MapType];    IF MapChain = NIL OR p >= MapChain.ProgCntr THEN      BEGIN m.backptr ¬ MapChain; MapChain ¬ m; END    ELSE      BEGIN      ptr ¬ MapChain;      WHILE ptr.backptr # NIL AND ptr.backptr.ProgCntr > p DO        ptr ¬ ptr.backptr; ENDLOOP;      m.backptr ¬ ptr.backptr;      ptr.backptr ¬ m;      END;    m.ProgCntr ¬ p;    m.SI ¬ s;    END;  ReleaseMapChain: PUBLIC PROCEDURE =    BEGIN    p: LONG POINTER TO CodeOutputDefs.MapType;    WHILE MapChain # NIL DO      p ¬ MapChain.backptr;      PrivateStorage.heapPointer.FREE[@MapChain];      MapChain ¬ p;      ENDLOOP;    END;  BuildAndPutCodeLine: PUBLIC PROCEDURE =    BEGIN    PutCodeLine[LinePC, CodeLine, CheckSum];    CheckSum ¬ CodeLine.length ¬ 0;    END;  PutCodeLine: PUBLIC PROCEDURE [lpc: CARDINAL, c: LONG STRING, cs: CARDINAL] =    BEGIN    OutCodeLine: STRING ¬ [48];    LinePC ¬ pc;    String.AppendChar[OutCodeLine, ':];    PrivateStringDefs.AppendHexNumber[OutCodeLine, c.length/2, 2];    PrivateStringDefs.AppendHexNumber[OutCodeLine, lpc, 4];    String.AppendString[OutCodeLine, "00"L];    AddToMapChain[Stream.GetPosition[BinaryStream], lpc];    String.AppendString[OutCodeLine, c];    cs ¬ Inline.BITAND[cs + c.length/2 + lpc MOD 256 + lpc/256, 377B];    PrivateStringDefs.AppendHexNumber[OutCodeLine, 0 - cs, 2];    String.AppendChar[OutCodeLine, '\N];    String.AppendChar[OutCodeLine, '\L];    ListOutputDefs.PutString[BinaryStream, OutCodeLine];    END;  PutEOFLine: PUBLIC PROCEDURE =    BEGIN    ListOutputDefs.PutString[BinaryStream, ":00000001"L];    Stream.PutChar[sH: BinaryStream, char: '\N];    Stream.PutChar[sH: BinaryStream, char: '\L];    END;  WindUpCodeFile: PUBLIC PROCEDURE =    BEGIN    BuildAndPutCodeLine[];    PutEOFLine[];    OutputRelocationChain[BinaryStream];    SymTabIODefs.WriteBinderInformation[BinaryStream];    ReleaseMapChain[];    CheckSum ¬ LinePC ¬ pc ¬ 0;    END;  AddToRelocChain: PUBLIC PROCEDURE [pc: NewStateDefs.MemoryAddress] =    BEGIN    rec: LONG POINTER TO CodeOutputDefs.RelocRec ¬ PrivateStorage.heapPointer.NEW[      CodeOutputDefs.RelocRec ¬ [pc, ]];    rr: LONG POINTER TO CodeOutputDefs.RelocRec ¬ RelocChain;    IF rr = NIL OR pc < rr.addr THEN      BEGIN rec.prev ¬ RelocChain; RelocChain ¬ rec; RETURN; END;    WHILE rr.prev # NIL AND rr.prev.addr < pc DO rr ¬ rr.prev; ENDLOOP;    rec.prev ¬ rr.prev;    rr.prev ¬ rec;    END;  OutputRelocationChain: PUBLIC PROCEDURE [s: Stream.Handle] =    BEGIN    p: LONG POINTER TO CodeOutputDefs.RelocRec ¬ RelocChain;    i: CARDINAL ¬ 0;    IF RelocChain = NIL THEN RETURN;    ListOutputDefs.PutString[s, "/Relocation Chain"L];    Stream.PutChar[sH: s, char: '\N];    Stream.PutChar[sH: s, char: '\L];    CodeLine.length ¬ 0;    WHILE p # NIL DO      PrivateStringDefs.AppendHexNumber[CodeLine, p.addr, 5];      i ¬ i + 1;      p ¬ p.prev;      PrivateStorage.heapPointer.FREE[@RelocChain];      IF i = 9 OR p = NIL THEN        BEGIN        ListOutputDefs.PutString[s, CodeLine];        Stream.PutChar[sH: s, char: '\N];        Stream.PutChar[sH: s, char: '\L];        CodeLine.length ¬ i ¬ 0;        END;      RelocChain ¬ p;      ENDLOOP;    ListOutputDefs.PutString[s, CodeLine];    END;  GetPC: PUBLIC PROCEDURE RETURNS [NewStateDefs.MemoryAddress] =    BEGIN RETURN[pc]; END;  SetPC: PUBLIC PROCEDURE [p: NewStateDefs.MemoryAddress] = BEGIN pc ¬ p; END;  ModifyPC: PUBLIC PROCEDURE [i: INTEGER] = BEGIN pc ¬ pc + i; END;  SetBinaryStream: PUBLIC PROCEDURE [s: Stream.Handle] =    BEGIN BinaryStream ¬ s; END;  SetBinaryStreamIndex: PUBLIC PROCEDURE [si: Stream.Position] =    BEGIN Stream.SetPosition[BinaryStream, si]; END;  GetBinaryStreamIndex: PUBLIC PROCEDURE RETURNS [Stream.Position] =    BEGIN RETURN[Stream.GetPosition[BinaryStream]]; END;  ReInit: PUBLIC PROC =    BEGIN    BinaryStream ¬ NIL;    MapChain ¬ NIL;    pc ¬ CheckSum ¬ LinePC ¬ 0;    CodeLineComplete ¬ FALSE;    RelocChain ¬ NIL;    END;  Init: PROCEDURE =    BEGIN    CodeLine ¬ Heap.systemZone.NEW[StringBody[48]];    BinaryStream ¬ NIL;    MapChain ¬ NIL;    pc ¬ CheckSum ¬ LinePC ¬ 0;    CodeLineComplete ¬ FALSE;    RelocChain ¬ NIL;    END;  Init[];  END...    -- Log    --  6-Apr-82 13:34:09 - ETN           - Convert to Trinity  -- 26-Jan-83 10:22:32 - ETN           - Sierra.  Heap.systemZone => Storage  -- 30-May-83 15:47:24 - DEG     	- Remove references to the Ascii interface  -- Time: 26-Sep-84 23:06:30	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
-- Copyright (C) 1980, 1982, 1983  by Xerox Corporation. All rights reserved. -- PanelSWsA.mesa-- HGM:  5-Jan-83 16:14:02-- AMD: 22-Dec-82 10:31:55-- Mark: Aug 22, 1980 12:42 AM-- PXJ   : October 16, 1980  7:02 PM-- creation, destruction, and wholesale redisplay routinesDIRECTORY  Context USING [Create, Destroy],  Heap: TYPE USING [systemZone],  Inline USING [LongCOPY],  PanelSW USING [    ClientProcs, Error, FreeRSProcType, LineHeight, Options, RowDesc, TileField,    TileLayout],  PanelSWOps USING [    ActOnPanelProcType, context, DisplayProc, FindContext, FreeTile, GetTable,    Handle, LockProcType, nilTileSpec, Object, RowDesc, RowSeq, Tile, TileSeq,    TIPMe, ValidateHandle],  TIP: TYPE USING [CreateClient, DestroyClient],  Tool USING [RegisterSWType, SWProc, SWType],  ToolWindow USING [AdjustProcType, State],  UserInput USING [DestroyStringInOut],  Window USING [GetBox, InvalidateBox, Handle, SetDisplayProc, Validate],  WindowFont USING [Handle];PanelSWsA: MONITOR LOCKS h.lock USING h: PanelSWOps.Handle  IMPORTS    Context, Heap, Inline, PanelSW, PanelSWOps, TIP, Tool, UserInput, Window  EXPORTS PanelSW =  BEGIN    swType: Tool.SWType = Tool.RegisterSWType[    adjust: Adjuster,    sleep: Sleeper,    wakeup: Wakeuper];  -- Standard preamble to hook up EXPORTed TYPEs  Object: PUBLIC TYPE = PanelSWOps.Object;  -- Global Data and STUFF  -- Procedures Implementing the PanelSW Interface  Adjuster: PUBLIC ToolWindow.AdjustProcType = {    h: PanelSWOps.Handle = PanelSWOps.FindContext[window];    LockedAdjust: ENTRY PanelSWOps.LockProcType = {      ENABLE UNWIND => NULL;      h.tiles ¬ NewTiles[        h.tiles, TilesForHeight[h, h.numCols, box.dims.h], h.cProcs.freeRS]};    IF h # NIL AND when = after THEN LockedAdjust[h]};  Create: PUBLIC PROC [    sw: Window.Handle, err: Window.Handle, numTiles: CARDINAL,    rowDesc: PanelSW.RowDesc, clientProcs: PanelSW.ClientProcs,    typeIn: LONG POINTER TO LONG STRING, options: PanelSW.Options ¬ [],    initialState: ToolWindow.State ¬ active]    RETURNS [h: PanelSWOps.Handle] = {    IF sw = NIL OR rowDesc.BASE = NIL OR rowDesc.LENGTH = 0 OR numTiles = 0 THEN      ERROR PanelSW.Error[badArgs];    IF (h ¬ PanelSWOps.FindContext[sw]) # NIL THEN {      SIGNAL PanelSW.Error[alreadyAPanelSW]; Destroy[h]};    -- Allocate and initialize context    h ¬ Heap.systemZone.NEW[Object ¬       [sw: sw, font: options.font, numCols: rowDesc.LENGTH, rowDesc: NIL,      rowPlaceDesc: NIL, typeIn: typeIn, err: err, cProcs: clientProcs,      tiles: NIL, lastPlace: [INTEGER.LAST, INTEGER.LAST],      current: PanelSWOps.nilTileSpec, marked: FALSE, lineHeight: TRASH]];    --do this one last--    h.lineHeight ¬ PanelSW.LineHeight[h];    --revist some of the fields--    [h.rowDesc, h.rowPlaceDesc] ¬ MakeRowDescription[rowDesc];    h.tiles ¬ NewTiles[      h.tiles, TilesForHeight[h, h.numCols, sw.GetBox.dims.h], h.cProcs.freeRS];    Context.Create[PanelSWOps.context, h, DestroyContext, sw];    -- Set up display bits stuff    [] ¬ sw.SetDisplayProc[PanelSWOps.DisplayProc];    IF initialState = active THEN Wakeup[h];    -- Set up user input    TIP.CreateClient[sw, PanelSWOps.GetTable[], PanelSWOps.TIPMe]};  Destroy: PUBLIC PanelSWOps.ActOnPanelProcType = {    sw: Window.Handle;    PanelSWOps.ValidateHandle[h];    sw ¬ h.sw;    -- Return to default PNRs state    UserInput.DestroyStringInOut[sw];    -- UserInput.SetDefaultPNRs[sw];  not yet available, so for now...    TIP.DestroyClient[sw];    Context.Destroy[PanelSWOps.context, sw]};  SetOptions: PUBLIC PROC [h: PanelSWOps.Handle, options: PanelSW.Options] = {    LockedChangeOptions: ENTRY PanelSWOps.LockProcType = {      h.font ¬ options.font; h.lineHeight ¬ PanelSW.LineHeight[h]};    IF h # NIL THEN {      Sleep[h];      LockedChangeOptions[h];      h.sw.InvalidateBox[[[0, 0], h.sw.GetBox.dims], isDirty];      Wakeup[h];      h.sw.Validate}};  Sleep: PUBLIC PanelSWOps.ActOnPanelProcType = {IF h # NIL THEN RealSleep[h]};  Sleeper: Tool.SWProc = {    h: PanelSWOps.Handle = PanelSWOps.FindContext[sw];    Sleep[h]};  Wakeup: PUBLIC PanelSWOps.ActOnPanelProcType = {    -- Recreates all state related ONLY to the displayed bits.    LockedWakeup: ENTRY PanelSWOps.LockProcType = {ENABLE UNWIND => NULL;};    IF h # NIL THEN LockedWakeup[h]};  Wakeuper: Tool.SWProc = {    h: PanelSWOps.Handle = PanelSWOps.FindContext[sw];    Wakeup[h]};  -- Utilities  DestroyContext: PROC [myContext: PanelSWOps.Handle, sw: Window.Handle] = {    PanelSWOps.ValidateHandle[      myContext ! PanelSW.Error => IF code = notAPanelSW THEN GOTO Punt];    -- Selection.ClearOnMatch[myContext];    RealSleep[myContext];    -- free all tiles and associated storage    myContext.tiles ¬ NewTiles[myContext.tiles, 0, myContext.cProcs.freeRS];    Heap.systemZone.FREE[@myContext.rowDesc];    Heap.systemZone.FREE[@myContext.rowPlaceDesc];    Heap.systemZone.FREE[@myContext];    EXITS Punt => NULL};  MakeRowDescription: PROC [clientDesc: PanelSW.RowDesc]    RETURNS [rowDesc, rowPlaceDesc: PanelSWOps.RowDesc] = {    -- Caller must check that clientDesc.BASE # NIL AND clientDesc.LENGTH # 0    tlSize: CARDINAL = PanelSW.TileLayout.SIZE;    rdSize: CARDINAL = tlSize*clientDesc.LENGTH;    x: CARDINAL ¬ 0;    rowDesc ¬ Heap.systemZone.NEW[PanelSWOps.RowSeq[clientDesc.LENGTH]];    rowPlaceDesc ¬ Heap.systemZone.NEW[PanelSWOps.RowSeq[clientDesc.LENGTH]];    Inline.LongCOPY[from: clientDesc.BASE, to: @rowDesc[0], nwords: rdSize];    FOR i: CARDINAL IN [0..clientDesc.LENGTH) DO      FOR tf: PanelSW.TileField IN PanelSW.TileField DO        rowPlaceDesc[i][tf] ¬ x; x ¬ x + rowDesc[i][tf]; ENDLOOP;      ENDLOOP};  NewTiles: PROC [    old: LONG POINTER TO PanelSWOps.TileSeq, count: CARDINAL,    freeRS: PanelSW.FreeRSProcType]    RETURNS [new: LONG POINTER TO PanelSWOps.TileSeq] = {    minNewOld: CARDINAL;    IF old = NIL THEN      BEGIN  -- Avoid lots of NIL Faults      new ¬        IF count = 0 THEN NIL        ELSE Heap.systemZone.NEW[PanelSWOps.TileSeq[count]];      new[0] ¬ NIL;      Inline.LongCOPY[        from: @new[0], to: @new[1], nwords: PanelSWOps.Tile.SIZE*(count - 1)];      RETURN;      END;    IF count = old.length THEN RETURN[old];    -- Allocate node, and copy all of old that fits    new ¬      IF count = 0 THEN NIL      ELSE Heap.systemZone.NEW[PanelSWOps.TileSeq[count]];    minNewOld ¬ MIN[old.length, count];    IF new # NIL THEN {      Inline.LongCOPY[        from: @old[0], to: @new[0], nwords: PanelSWOps.Tile.SIZE*minNewOld];      IF count = minNewOld THEN {        -- Free objects referenced by rest of old        FOR i: CARDINAL IN [minNewOld..old.length) DO          PanelSWOps.FreeTile[old[i], freeRS]; ENDLOOP}      ELSE {        -- NIL out rest of new        new[minNewOld] ¬ NIL;        Inline.LongCOPY[          from: @new[minNewOld], to: @new[minNewOld + 1],          nwords: PanelSWOps.Tile.SIZE*(count - minNewOld - 1)]}};    Heap.systemZone.FREE[@old]};  RealSleep: PROC [h: PanelSWOps.Handle] = {    << Tosses away all state related ONLY to the displayed bits.      Do not call with myContext = NIL! >>    LockedSleep: ENTRY PanelSWOps.LockProcType = {ENABLE UNWIND => NULL;};    LockedSleep[h]};  TilesForHeight: PROC [    h: PanelSWOps.Handle, numCols: CARDINAL, dimsH: INTEGER]    RETURNS [lines: CARDINAL] = {    RETURN[      numCols*(IF dimsH > 0 THEN (dimsH + h.lineHeight - 1)/h.lineHeight        ELSE 0)]};    SWType: PUBLIC PROC RETURNS [Tool.SWType] = {RETURN[swType]};    END.  -- of PanelSWsA.mesa
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CPLoader.mesa, HGM, 23-Oct-83 18:33:47DIRECTORY  Environment USING [bytesPerWord, LongNumber, wordsPerPage],  Format USING [CR, Line, LongDecimal, StringProc, Text],  Heap USING [systemZone],  MStream USING [Error, ReadOnly],  Stream USING [Delete, EndOfStream, GetBlock, GetWord, Handle],  String USING [AppendExtensionIfNeeded, CopyToNewString],  System USING [GetClockPulses, Pulses, PulsesToMicroseconds],  CP USING [Bank, Cycle, RealCS, sizeOfCS, wordsPerBank],  CPMI USING [MI],  CPCommand USING [Error, RefreshWindow],  CPKernel USING [    Error, OneMI, ReadBank,    WriteMemoryBlock, WriteNextMemoryBlock, WriteCSBlock, WriteTpc],  CPKernelOps USING [WriteCSBlockInternal, WriteTpcInternal],  CPSymbols USING [    AddCSSymbol, AddRHSymbol, AddRRegSymbol, AddToMap, AddURegSymbol,    Error, VirturalCS],  MassFileFormat USING [FinalBinaryRec, LabelSymbolRec];CPLoader: PROGRAM  IMPORTS    Format, Heap, MStream, Stream, String, System,    CPCommand, CPKernel, CPKernelOps, CPSymbols  EXPORTS CPCommand, CPKernelOps =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  Load: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "fb"L, z];    Format.Text[log, "Loading CP from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    LoadFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommand.RefreshWindow[];    END;  LoadFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      BEGIN      Stream.EndOfStream => ERROR CPCommand.Error["Truncated fb file"L];      CPKernel.Error => ERROR CPCommand.Error[reason];      END;    start, stop: System.Pulses;    ms: LONG CARDINAL;    instructions: CARDINAL ¬ 0;    fbrBytes: CARDINAL = Environment.bytesPerWord*SIZE[MassFileFormat.FinalBinaryRec];    b: POINTER = @fbr;    fbr: MassFileFormat.FinalBinaryRec ¬ TRASH;    pb: POINTER TO CPMI.MI = LOOPHOLE[@fbr.partialBinary];    maxMiInClump: CARDINAL = 20;    miInClump: CARDINAL ¬ 0;    clump: ARRAY [0..maxMiInClump) OF CPKernel.OneMI;    offset: CARDINAL = CPKernel.ReadBank[] * CP.wordsPerBank;  -- ***  Hack until Mass is smarter    start ¬ System.GetClockPulses[];    DO      bytes: CARDINAL;      [bytes, , ] ¬ Stream.GetBlock[          sH: stream,          block: [            blockPointer: b,	    startIndex: 0,            stopIndexPlusOne: fbrBytes]];      IF bytes # fbrBytes THEN ERROR CPCommand.Error["Truncated fb"];      IF fbr.addr >= CP.sizeOfCS THEN EXIT;      fbr.addr ¬ fbr.addr + offset;      IF fbr.miNum = 0FFFFH THEN        BEGIN        CPKernel.WriteTpc[fbr.partialBinary.task, fbr.addr];        END      ELSE        BEGIN	IF offset # 0 AND fbr.partialBinary.task # 0 THEN	  CPCommand.Error["IO microcode won't run in extra Banks"];	IF miInClump = maxMiInClump THEN	  BEGIN          CPKernel.WriteCSBlock[miInClump, @clump];	  miInClump ¬ 0;	  END;	clump[miInClump] ¬ [fbr.addr, pb­];	miInClump ¬ miInClump + 1;	instructions ¬ instructions + 1;        IF TRUE THEN	  BEGIN          cycle: CP.Cycle;          cycle ¬ SELECT fbr.partialBinary.cycle FROM	    0 => any,            1 => c1,            2 => c2,            3 => c3,	    ENDCASE => ERROR;	  fbr.miNum ¬ fbr.miNum + offset;	  CPSymbols.AddToMap[fbr.addr, fbr.miNum, cycle, fbr.partialBinary.task];	  END;        END      ENDLOOP;    IF miInClump # 0 THEN CPKernel.WriteCSBlock[miInClump, @clump];    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    Info[log, arg, ms, instructions];    END;      LoadFromMemory: PUBLIC PROCEDURE [fbFile: LONG POINTER, bank: CP.Bank] =    BEGIN    fbr: LONG POINTER TO MassFileFormat.FinalBinaryRec ¬ fbFile;    maxMiInClump: CARDINAL = 20;    miInClump: CARDINAL ¬ 0;    clump: ARRAY [0..maxMiInClump) OF CPKernel.OneMI;    offset: CARDINAL = bank * CP.wordsPerBank;  -- ***  Hack until Mass is smarter    DO      IF fbr.addr >= CP.sizeOfCS THEN EXIT;      -- (WriteProtected) fbr.addr ¬ fbr.addr + offset;      IF fbr.miNum = 0FFFFH THEN        BEGIN        CPKernelOps.WriteTpcInternal[fbr.partialBinary.task, fbr.addr + offset];        END      ELSE        BEGIN        pb: LONG POINTER TO CPMI.MI = LOOPHOLE[@fbr.partialBinary];	IF miInClump = maxMiInClump THEN	  BEGIN          CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];	  miInClump ¬ 0;	  END;	clump[miInClump] ¬ [fbr.addr + offset, pb­];	miInClump ¬ miInClump + 1;        END;      fbr ¬ fbr + SIZE[MassFileFormat.FinalBinaryRec];      ENDLOOP;    IF miInClump # 0 THEN CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];    END;      LoadOverlay: PUBLIC PROCEDURE [fbFile: LONG POINTER] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR CPCommand.Error[reason];      END;    fbr: LONG POINTER TO MassFileFormat.FinalBinaryRec ¬ fbFile;    maxMiInClump: CARDINAL = 20;    miInClump: CARDINAL ¬ 0;    clump: ARRAY [0..maxMiInClump) OF CPKernel.OneMI;    DO      IF fbr.addr >= CP.sizeOfCS THEN EXIT;      IF fbr.miNum = 0FFFFH THEN  ERROR CPKernel.Error["Can't set TPC in Overlay"L]      ELSE        BEGIN        pb: LONG POINTER TO CPMI.MI = LOOPHOLE[@fbr.partialBinary];	IF miInClump = maxMiInClump THEN CPKernel.Error["Overlay too big"L];      	clump[miInClump] ¬ [fbr.addr, pb­];	miInClump ¬ miInClump + 1;        END;      fbr ¬ fbr + SIZE[MassFileFormat.FinalBinaryRec];      ENDLOOP;    IF miInClump # 0 THEN CPKernelOps.WriteCSBlockInternal[miInClump, @clump[0]];    END;      Info: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, instructions: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, instructions, arg];    Format.Text[log, " instructions."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, instructions*16*SIZE[CPMI.MI]*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;   LoadSymbols: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "st"L, z];    Format.Text[log, "Loading CP symbols from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    LoadSymbolsFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    END;      LoadSymbolsFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN    start, stop: System.Pulses;    ms: LONG CARDINAL;    tags, rReg, rH, uReg: CARDINAL ¬ 0;    lsr: MassFileFormat.LabelSymbolRec ¬ TRASH;    bytesPerRec: CARDINAL = Environment.bytesPerWord*SIZE[MassFileFormat.LabelSymbolRec];    sym: LONG STRING = [100];    offset: CARDINAL = CPKernel.ReadBank[] * CP.wordsPerBank;  -- ***  Hack until Mass is smarter    start ¬ System.GetClockPulses[];    DO      bytes, wordsExpected: CARDINAL;      [bytes, , ] ¬ Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[LONG[@lsr]],	  startIndex: 0,          stopIndexPlusOne: bytesPerRec]];      IF bytes = 0 THEN EXIT;      IF bytes # bytesPerRec THEN ERROR CPCommand.Error["Symbol file truncated"L];      IF lsr.length = 0 THEN ERROR CPCommand.Error["Zero length tag"L];      IF lsr.length > sym.maxlength THEN ERROR CPCommand.Error["Huge label string"L];      wordsExpected ¬ (lsr.length + (Environment.bytesPerWord - 1))/Environment.bytesPerWord;      [bytes, , ] ¬  Stream.GetBlock[        sH: stream,        block: [          blockPointer: LOOPHOLE[@sym.text],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerWord*wordsExpected]];      sym.length ¬ lsr.length;      BEGIN ENABLE CPSymbols.Error =>        BEGIN	Format.Text[log, "Troubles adding "L, arg];	Format.Text[log, sym, arg];	Format.Text[log, " to symbol table: "L, arg];	Format.Text[log, reason, arg];	Format.CR[log, arg];	CONTINUE;	END;      WITH lsr SELECT FROM        label =>	  BEGIN	  virt: CPSymbols.VirturalCS;	  IF miIndex >= 4096 THEN ERROR;	  virt ¬ miIndex + offset;	  CPSymbols.AddCSSymbol[sym, virt];	  tags ¬ tags + 1;	  END;        regR =>	  BEGIN	  CPSymbols.AddRRegSymbol[sym, addr];	  rReg ¬ rReg + 1;	  END;        regRH =>	  BEGIN	  CPSymbols.AddRHSymbol[sym, addr];	  rH ¬ rH + 1;	  END;        regU =>	  BEGIN	  CPSymbols.AddURegSymbol[sym, addr];	  uReg ¬ uReg + 1;	  END;        ENDCASE => ERROR CPSymbols.Error["Unrecognized type in symbol record"L];       END;      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoSymbols[log, arg, ms, tags, rReg, rH, uReg];    END;    InfoSymbols: PROCEDURE [    log: Format.StringProc, arg: LONG POINTER, ms: LONG CARDINAL, tags, rReg, rH, uReg: CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, tags, arg];    Format.Text[log, " tags, "L, arg];    Format.LongDecimal[log, rReg, arg];    Format.Text[log, " R, "L, arg];    Format.LongDecimal[log, rH, arg];    Format.Text[log, " RH, and "L, arg];    Format.LongDecimal[log, uReg, arg];    Format.Line[log, " U Reg symbols."L, arg];    END;  LoadReal: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, file: LONG STRING] =    BEGIN    filename: LONG STRING;    stream: Stream.Handle;    filename ¬ String.CopyToNewString[file, z];    [] ¬ String.AppendExtensionIfNeeded[@filename, "cpr"L, z];    Format.Text[log, "Loading real memory from "L, arg];    Format.Text[log, filename, arg];    Format.Line[log, "."L, arg];    stream ¬ MStream.ReadOnly[filename, [] ! MStream.Error =>      ERROR CPCommand.Error["Can't read that file"] ];    LoadRealFromStream[log, arg, stream !      UNWIND => BEGIN Stream.Delete[stream]; z.FREE[@filename]; END ];    Stream.Delete[stream];    z.FREE[@filename];    CPCommand.RefreshWindow[];    END;  LoadRealFromStream: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, stream: Stream.Handle] =    BEGIN ENABLE      Stream.EndOfStream => ERROR CPCommand.Error["Truncated cpr file"L];    buffer: ARRAY [0..Environment.wordsPerPage) OF WORD;    start, stop: System.Pulses;    ms: LONG CARDINAL;    wordsStored, blocks: LONG CARDINAL ¬ 0;    start ¬ System.GetClockPulses[];    DO      words, bytes: CARDINAL ¬ 0;      where: Environment.LongNumber;      words ¬ Stream.GetWord[stream];      IF words = 0 THEN EXIT;      IF words > Environment.wordsPerPage THEN        ERROR CPCommand.Error["CPR Block larger than a page"L];      where.highbits ¬ Stream.GetWord[stream];      where.lowbits ¬ Stream.GetWord[stream];      [bytes, , ] ¬ Stream.GetBlock[        sH: stream,        block: [	  blockPointer: LOOPHOLE[LONG[@buffer]],	  startIndex: 0,          stopIndexPlusOne: Environment.bytesPerWord*words]];      IF bytes # Environment.bytesPerWord * words THEN ERROR CPCommand.Error["Truncated CPR"L];      IF blocks = 0 THEN        BEGIN        CPKernel.WriteMemoryBlock[where.lp, words, @buffer          ! CPKernel.Error => ERROR CPCommand.Error[reason] ];        END      ELSE        CPKernel.WriteNextMemoryBlock[where.lp, words, @buffer          ! CPKernel.Error => ERROR CPCommand.Error[reason] ];      blocks ¬ blocks + 1;      wordsStored ¬ wordsStored + words;      ENDLOOP;    stop ¬ System.GetClockPulses[];    ms ¬ System.PulsesToMicroseconds[[stop - start]]/1000;    InfoReal[log, arg, ms, wordsStored, blocks];    END;	  InfoReal: PROCEDURE [log: Format.StringProc, arg: LONG POINTER, ms, words, blocks: LONG CARDINAL] =    BEGIN    Format.Text[log, "It took "L, arg];    Format.LongDecimal[log, ms, arg];    Format.Text[log, " ms to load "L, arg];    Format.LongDecimal[log, words, arg];    Format.Text[log, " words in "L, arg];    Format.LongDecimal[log, blocks, arg];    Format.Text[log, " blocks."L, arg];    IF ms # 0 THEN      BEGIN      Format.Text[log, " ("L, arg];      Format.LongDecimal[log, words*16*1000/ms, arg];      Format.Text[log, " bits/sec)"L, arg];      END;    Format.CR[log, arg];    END;  END.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- IOPCommander.mesa, HGM, 10-Nov-83 13:31:46DIRECTORY  Format USING [Line, StringProc, Text],  Process USING [MsecToTicks, Pause],  String USING [AppendChar, AppendString, AppendNumber],  System USING [AdjustGreenwichMeanTime, GetGreenwichMeanTime, GreenwichMeanTime],  CommandFile USING [AbortProc],  IOP USING [Address],  IOPBreak USING [AtBreak, Break, Error, InstallBreaks, RemoveBreaks, Reset, Unbreak],  IOPCommand USING [RefreshWindow],  IOPKernel USING [    Boot, Continue, Error, GetState, ProbeForStateChange, ReadPC, State, Stop, WritePC],  IOPPanel USING [Initialize],  IOPSyms USING [AppendMemoryAddress, ClearSymbolTable, Error, Eval, Symbol];IOPCommander: PROGRAM  IMPORTS    Format, Process, String, System,    IOPBreak, IOPCommand, IOPKernel, IOPPanel, IOPSyms  EXPORTS IOPCommand =  BEGIN  Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    Boot: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, silent: BOOLEAN] =    BEGIN ENABLE      BEGIN      IOPBreak.Error => ERROR Error[reason];      IOPKernel.Error => ERROR Error[reason];      END;    Format.Text[log, "Booting IOP ... "L, arg];    IOPSyms.ClearSymbolTable[];    IOPBreak.Reset[];    IOPKernel.Boot[];    IOPPanel.Initialize[];    IF ~silent THEN PrintState[log, arg];    END;  SetPC: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN ENABLE      BEGIN      IOPSyms.Error => ERROR Error[reason];      IOPKernel.Error => ERROR Error[reason];      END;    value: IOPSyms.Symbol;    Format.Text[log, "Setting IOP PC to "L, arg];    Format.Text[log, s, arg];    IF s = NIL THEN Error["Arg expected"L];    value ¬ IOPSyms.Eval[s];    WITH value SELECT FROM      number => IOPKernel.WritePC[n];      at, reg, pair => ERROR Error["PC should be in IOP Memory"L];      byte, word, instruction => IOPKernel.WritePC[mem];      ENDCASE => ERROR;    Format.Line[log, "."L, arg];    END;      Step: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE      BEGIN      IOPBreak.Error => ERROR Error[reason];      IOPKernel.Error => ERROR Error[reason];      END;    Format.Text[log, "Steping IOP ... "L, arg];    IOPBreak.RemoveBreaks[];  -- Backup PC if at Break    IOPBreak.InstallBreaks[TRUE];    IOPKernel.Continue[];    THROUGH [0..10) DO      IOPKernel.ProbeForStateChange[];      SELECT IOPKernel.GetState[] FROM        dead => ERROR Error["IOP Died"];        booted => ERROR Error["IOP Has recently been booted"];        running => NULL;        halted => ERROR Error["IOP halted while trying to SS"L];        iopBreak => EXIT;        cpStop => ERROR Error["CP Break while trying to SS"L];        ENDCASE => ERROR;      Process.Pause[Process.MsecToTicks[100]];      REPEAT FINISHED => ERROR Error["IOP didn't stop"L];      ENDLOOP;    IOPBreak.RemoveBreaks[];    PrintState[log, arg];    IOPCommand.RefreshWindow[];    END;      Continue: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, silent: BOOLEAN] =    BEGIN ENABLE      BEGIN      IOPBreak.Error => ERROR Error[reason];      IOPKernel.Error => ERROR Error[reason];      END;    pc: IOP.Address;    Format.Text[log, "Continuing IOP ... "L, arg];    IOPBreak.RemoveBreaks[];  -- Backup PC if at Break    pc ¬ IOPKernel.ReadPC[];    IF IOPBreak.AtBreak[pc] THEN      BEGIN      new: IOP.Address;      IOPBreak.InstallBreaks[TRUE];      IOPKernel.Continue[];      THROUGH [0..10) DO        IOPKernel.ProbeForStateChange[];        SELECT IOPKernel.GetState[] FROM	  dead => ERROR Error["IOP Died"];	  booted => ERROR Error["IOP Has recently been booted (Set the PC)"];	  running => NULL;	  halted => ERROR Error["IOP halted while trying to SS"L];	  iopBreak => EXIT;	  cpStop => ERROR Error["CP Break while trying to SS"L];	  ENDCASE => ERROR;	REPEAT FINISHED => ERROR Error["IOP didn't stop"L];        ENDLOOP;      IOPBreak.RemoveBreaks[];  -- Slow      new ¬ IOPKernel.ReadPC[];      IF IOPBreak.AtBreak[new] THEN        BEGIN        IF ~silent THEN PrintState[log, arg];        IOPCommand.RefreshWindow[];	RETURN;	END;      END;    IOPBreak.InstallBreaks[FALSE];    IOPKernel.Continue[];    -- Give easy breaks time to take => avoid double state change printout    Process.Pause[Process.MsecToTicks[250]];    IF ~silent THEN PrintState[log, arg];    IOPCommand.RefreshWindow[];    END;      ContinueAndWait: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, abort: CommandFile.AbortProc, ms: LONG CARDINAL] =    BEGIN ENABLE      BEGIN      IOPBreak.Error => ERROR Error[reason];      IOPKernel.Error => ERROR Error[reason];      END;    start: System.GreenwichMeanTime = System.GetGreenwichMeanTime[];    stop: System.GreenwichMeanTime = System.AdjustGreenwichMeanTime[start, (ms+999)/1000];    Continue[log, arg, TRUE];    DO      IOPKernel.ProbeForStateChange[];      IF IOPKernel.GetState[] # running THEN EXIT;      Process.Pause[Process.MsecToTicks[500]];      IF abort[] THEN ERROR Error["UserAborted (STOP)"L];      IF ms = 0 THEN LOOP;  -- Forever case      IF System.GetGreenwichMeanTime[] > stop THEN ERROR Error["Didn't stop in time"L];      ENDLOOP;    IOPBreak.RemoveBreaks[];    END;  Stop: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN ENABLE IOPKernel.Error => ERROR Error[reason];    Format.Text[log, "Stopping IOP ... "L, arg];    IOPKernel.Stop[];    PrintState[log, arg];    IOPCommand.RefreshWindow[];    END;    Break: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN    pc: IOPSyms.Symbol;    where: IOP.Address;    Format.Text[log, "Setting IOP Break at "L, arg];    Format.Text[log, s, arg];    pc ¬ IOPSyms.Eval[s ! IOPSyms.Error => ERROR Error[reason] ];    WITH pc SELECT FROM      number => where ¬ n;      byte, word, instruction =>        BEGIN	temp: STRING = [20];	where ¬ mem;        String.AppendString[temp, " = "L];        String.AppendNumber[temp, where, 16];        String.AppendChar[temp, ' ];        Format.Text[log, temp, arg];	END;      ENDCASE => ERROR Error["IOP Memory address required"L];    Format.Text[log, " ... "L, arg];    IOPBreak.Break[where ! IOPBreak.Error => ERROR Error[reason] ];    Format.Line[log, "ok."L, arg];    END;    Unbreak: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER, s: LONG STRING] =    BEGIN    pc: IOPSyms.Symbol;    where: IOP.Address;    Format.Text[log, "Clearing IOP Break at "L, arg];    IF s = NIL THEN      BEGIN      temp: STRING = [20];      Format.Text[log, "current PC ... "L, arg];      where ¬ IOPKernel.ReadPC[ ! IOPKernel.Error => ERROR Error[reason] ];      String.AppendString[temp, " = "L];      String.AppendNumber[temp, where, 16];      String.AppendChar[temp, ' ];      Format.Text[log, temp, arg];      Format.Text[log, " ... "L, arg];      IOPBreak.Unbreak[where ! IOPBreak.Error => ERROR Error[reason] ];      Format.Line[log, "ok."L, arg];      RETURN;      END;    Format.Text[log, s, arg];    pc ¬ IOPSyms.Eval[s ! IOPSyms.Error => ERROR Error[reason] ];    WITH pc SELECT FROM      number => where ¬ n;      byte, word, instruction =>        BEGIN	temp: STRING = [20];	where ¬ mem;        String.AppendString[temp, " = "L];        String.AppendNumber[temp, where, 16];        String.AppendChar[temp, ' ];        Format.Text[log, temp, arg];	END;      ENDCASE => ERROR Error["IOP Memory address required"L];    Format.Text[log, " ... "L, arg];    IOPBreak.Unbreak[where ! IOPBreak.Error => ERROR Error[reason] ];    Format.Line[log, "ok."L, arg];    END;      PrintState: PUBLIC PROCEDURE [log: Format.StringProc, arg: LONG POINTER] =    BEGIN    state: IOPKernel.State = IOPKernel.GetState[];    SELECT state FROM      dead => Format.Text[log, "IOP is dead"L, arg];      booted => Format.Text[log, "IOP was booted"L, arg];      running => Format.Text[log, "IOP is running"L, arg];      halted =>        BEGIN        pc: IOP.Address = IOPKernel.ReadPC[];        temp: STRING = [100];        Format.Text[log, "IOP halted at "L, arg];        String.AppendNumber[temp, pc, 16];        String.AppendString[temp, " ("L];        IOPSyms.AppendMemoryAddress[temp, pc];        String.AppendString[temp, ")"L];        Format.Text[log, temp, arg];        END;      iopBreak =>        BEGIN        pc: IOP.Address = IOPKernel.ReadPC[];        temp: STRING = [100];        Format.Text[log, "IOP Break at "L, arg];        String.AppendNumber[temp, pc, 16];        String.AppendString[temp, " ("L];        IOPSyms.AppendMemoryAddress[temp, pc];        String.AppendString[temp, ")"L];        Format.Text[log, temp, arg];        END;      cpStop => Format.Text[log, "IOP Stopped for CP Halt/Break"L, arg];      ENDCASE => ERROR;    Format.Line[log, "."L, arg];    END;      END.
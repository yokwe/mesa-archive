-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CPKernelRead.mesa, HGM, 13-Jun-83 16:24:25-- This module works for both DLion and Dicentra because IOPData¬ and DebA¬ have the same encoding and both get their data from the X bus.DIRECTORY  Environment USING [Byte],  Inline USING [BITAND, BITNOT, BITOR, BITSHIFT, HighHalf, LowHalf],  CP USING [IOReg, OtherReg, RealMemory, RReg, UReg],  CPKernel USING [machine],  CPKernelConstants ,  CPKernelOps USING [AddressOutOfRange, CantReadThatRegister, ExecuteCPBuffer, ReadCPByte, WriteCSInternal, WriteUSpecial],  CPMI USING [FX, FZNorm, MI],  IOPKernelOps USING [InitializeLock, lock];CPKernelRead: MONITOR LOCKS IOPKernelOps.lock  IMPORTS    Inline, CPKernel, CPKernelOps, IOPKernelOps  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelConstants;    ReadRReg: PUBLIC ENTRY PROCEDURE [r: CP.RReg] RETURNS [WORD] =    BEGIN ENABLE UNWIND => NULL;    -- R is read in two parts: R[0-7] then R[8-15]    --kBuffer:	IOPOData¬ R<addr> lRot8, GOTO[kWait];    --kBuffer:	IOPOData¬ R<addr> lRot0, GOTO[kWait];    dataHigh, dataLow: Environment.Byte;    IF r ~IN CP.RReg THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      r, , za, rOrS, , , , , , ioOut, , , [i[iopOData]], [n[lRot8]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    dataHigh ¬ CPKernelOps.ReadCPByte[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      r, , za, rOrS, , , , , , ioOut, , , [i[iopOData]], [n[lRot0]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    dataLow ¬ CPKernelOps.ReadCPByte[];    RETURN[Inline.BITSHIFT[dataHigh, 8] + dataLow];    END;   ReadRH: PUBLIC ENTRY PROCEDURE [rh: CP.RReg] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    --kBuffer: IOPOData¬ RH<addr>, GOTO[kWait];    IF rh ~IN CP.RReg THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      , rh, , , , , , , , ioOut, ioxIn, , [i[iopOData]], [i[rh]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    data ¬ CPKernelOps.ReadCPByte[];    END;   ReadUReg: PUBLIC ENTRY PROCEDURE [u: CP.UReg] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadURegInternal[u]];    END;  ReadURegInternal: PUBLIC INTERNAL PROCEDURE [u: CP.UReg] RETURNS [data: WORD] =    BEGIN    dataHigh, dataLow: Environment.Byte;    addrH: Nibble ¬ Inline.BITAND[Inline.BITSHIFT[u, -4], 17B];    addrL: Nibble ¬ Inline.BITAND[u, 17B];    -- Read in two parts: U[0-7] first, then U[8-15]    --kBuffer: rK¬ U<addr>, c1;    --	       IOPOData¬ rK lRot8, GOTO[kWait], c2;    --kBuffer: IOPOData¬ U<addr>, GOTO[kWait], c1;    IF u ~IN CP.UReg THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      addrH, rK, dz, rOrS, wrB, , , TRUE, , , uAddr, , , [d[addrL]], kBuffer + 1]];    CPKernelOps.WriteCSInternal[      kBuffer + 1, CPMI.MI[      rK, , za, rOrS, , , , , , ioOut, , , [i[iopOData]], [n[lRot8]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    dataHigh ¬ CPKernelOps.ReadCPByte[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      addrH, , , , , , , TRUE, , ioOut, uAddr, , [i[iopOData]], [d[addrL]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    dataLow ¬ CPKernelOps.ReadCPByte[];    data ¬ Inline.BITSHIFT[dataHigh, 8] + dataLow;    END;   ReadRealMemory: PUBLIC ENTRY PROCEDURE [real: CP.RealMemory] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    RETURN[ReadRealMemoryInternal[real]];    END;  ReadRealMemoryInternal: PUBLIC INTERNAL PROCEDURE [real: CP.RealMemory] RETURNS [data: WORD] =    BEGIN    --Read in two parts, first mem[0-7] then mem[8-15].    --kBuffer: Noop, c1;    --         rK¬ UKTemp, c2;    --         Noop, c3;    --         MAR¬ [RHrK, rK+0], RawRef, c1;    --         []¬ UKCount, NegBr, c2;    --         rK¬ MD, BRANCH[kBuffer+6, kBuffer+7] c3;    --         IOPOData¬ rK lRot8, GOTO[kWait], c1, at[kBuffer+6];    --         IOPOData¬ rK lRot0, GOTO[kWait], c1, at[kBuffer+7];    SELECT CPKernel.machine FROM      dlion => IF Inline.HighHalf[real] ~IN [0..11] THEN CPKernelOps.AddressOutOfRange[];  -- 768K      dicentra => IF Inline.HighHalf[real] ~IN [0..255] THEN CPKernelOps.AddressOutOfRange[];      ENDCASE => ERROR;    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      , , , , , , , , , , , , , , kBuffer + 1]];    CPKernelOps.WriteCSInternal[      kBuffer + 1, CPMI.MI[      uKTempH, rK, dz, rOrS, wrB, , , TRUE, , , uAddr, , , [d[uKTempL]], kBuffer + 2]];    CPKernelOps.WriteCSInternal[      kBuffer + 2, CPMI.MI[      , , , , , , , , , , , , , , kBuffer + 3]];    CPKernelOps.WriteCSInternal[      kBuffer + 3, CPMI.MI[      , rK, zb, rPlusS, , , , , TRUE, , , ,[n[ rawRef]], , kBuffer + 4]];    CPKernelOps.WriteCSInternal[      kBuffer + 4, CPMI.MI[      uKCountH, , dz, rOrS, , , , TRUE, , dispBr, uAddr, , [b[negBr]], [d[uKCountL]], kBuffer + 5]];    CPKernelOps.WriteCSInternal[      kBuffer + 5, CPMI.MI[      , rK, dz, rOrS, wrB, , , , TRUE, , , , , , kBuffer + 6]];    CPKernelOps.WriteCSInternal[      kBuffer + 6, CPMI.MI[      , rK, zb, rOrS, , , , , , ioOut, , , [i[iopOData]], [n[lRot8]], kWait]];    CPKernelOps.WriteCSInternal[      kBuffer + 7, CPMI.MI[      , rK, zb, rOrS, , , , , , ioOut, , , [i[iopOData]], [n[lRot0]], kWait]];    CPKernelOps.WriteUSpecial[uKTemp, Inline.LowHalf[real]];    CPKernelOps.WriteUSpecial[uKCount, Inline.HighHalf[real]];  --writes RHrK as side effect    CPKernelOps.ExecuteCPBuffer[];    data ¬ CPKernelOps.ReadCPByte[];    CPKernelOps.WriteUSpecial[uKCount, Inline.BITOR[Inline.HighHalf[real], 100000B]];    CPKernelOps.ExecuteCPBuffer[];    RETURN[Inline.BITSHIFT[data, 8] + CPKernelOps.ReadCPByte[]];    END;   ReadOther: PUBLIC ENTRY PROCEDURE [other: CP.OtherReg] RETURNS [data: WORD] =    BEGIN ENABLE UNWIND => NULL;    SELECT other FROM      q =>  -- Read in two parts: Q[0-7] first, then Q[8-15]        --kBuffer:	IOPOData¬ Q lRot8, GOTO[kWait];        --kBuffer:	IOPOData¬ Q lRot0, GOTO[kWait];        BEGIN        dataHigh, dataLow: Environment.Byte;        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , , zq, rOrS, , , , , , ioOut, , , [i[iopOData]], [n[lRot8]], kWait]];        CPKernelOps.ExecuteCPBuffer[];        dataHigh ¬ CPKernelOps.ReadCPByte[];        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , , zq, rOrS, , , , , , ioOut, , , [i[iopOData]], [n[lRot0]], kWait]];        CPKernelOps.ExecuteCPBuffer[];        dataLow ¬ CPKernelOps.ReadCPByte[];        data ¬ Inline.BITSHIFT[dataHigh, 8] + dataLow;        END;      ib =>  --IOXIn[C'x] ¬ibNA        BEGIN        data ¬ ReadIOInInternal[0CH];        END;      pc16 =>        --kBuffer:	rK ¬ 0+pc16, c1;        --		IOPOData¬ rK lRot0, Cin¬pc16 GOTO[kWait], c2;        BEGIN        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , rK, dz, rPlusS, wrB, , , , , , nibble, cinPC16, , [d[0]], kBuffer + 1]];        CPKernelOps.WriteCSInternal[          kBuffer + 1, CPMI.MI[          rK, , za, rOrS, , , , , , ioOut, , cinPC16, [i[iopOData]], [n[lRot0]], kWait]];        CPKernelOps.ExecuteCPBuffer[];        data ¬ CPKernelOps.ReadCPByte[];        END;      mInt =>        --kBuffer: MesaIntBr, c1;        --         BRANCH[MIZero, MIOne], c2;        --MIZero:  IOPOData ¬ 0, GOTO[kWait], c3;        --MIOne:   IOPOData ¬ 1, GOTO[kWait], c3;        BEGIN        CPKernelOps.WriteCSInternal[          kBuffer, CPMI.MI[          , , , , , , , , , dispBr, , , [b[mesaIntBr]], , kBuffer + 1]];        CPKernelOps.WriteCSInternal[          kBuffer + 1, CPMI.MI[          , , , , , , , , , , , , , , kBuffer + 2]];        CPKernelOps.WriteCSInternal[          kBuffer + 2, CPMI.MI[  --KFlip          , , , , , , , , , ioOut, nibble, , [i[iopOData]], [d[0]], kWait]];        CPKernelOps.WriteCSInternal[          kBuffer + 3, CPMI.MI[  --KNoFlip          , , , , , , , , , ioOut, nibble, , [i[iopOData]], [d[1]], kWait]];        CPKernelOps.ExecuteCPBuffer[];        data ¬ CPKernelOps.ReadCPByte[];        END;      stackP =>  --low 4 bits of ~IOXIn[A'x]        BEGIN        data ¬ ReadIOInInternal[10];        data ¬ Inline.BITAND[Inline.BITNOT[data], 17B];        END;      ibPtr =>  --bits [10-11] of ~IOXIn[A'x]        BEGIN        data ¬ ReadIOInInternal[10];        data ¬ Inline.BITAND[Inline.BITSHIFT[Inline.BITNOT[data], -4], 3];        END;      ekErr =>  --bits [8-9] of IOXIn[A'x]        BEGIN        data ¬ ReadIOInInternal[10];        data ¬ Inline.BITAND[Inline.BITSHIFT[data, -6], 3];        END;      ENDCASE => CPKernelOps.CantReadThatRegister[];    RETURN[data];    END;    ReadIOIn: PUBLIC ENTRY PROCEDURE [io: CP.IOReg] RETURNS [data: WORD] =    BEGIN    RETURN[ReadIOInInternal[io]];    END;  ReadIOInInternal: INTERNAL PROCEDURE [io: CP.IOReg] RETURNS [data: WORD] =    BEGIN    -- Read in two parts: IOXIn[0-7] first, then IOXIn[8-15]    -- kBuffer:  rK ¬ IOXIn<addr>, c1;    --           IOPOData ¬ rK lRot8, GOTO[kWait], c2;    -- kBuffer:  IOPOData ¬ IOXIn<addr>, GOTO[kWait], c1;    dataHigh, dataLow: Environment.Byte;    IF io ~IN CP.IOReg THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      , rK, dz, rOrS, wrB, , , , , , ioxIn, , , [d[io]], kBuffer + 1]];    CPKernelOps.WriteCSInternal[      kBuffer + 1, CPMI.MI[      rK, , za, rOrS, , , , , , ioOut, , , [i[iopOData]], [n[lRot8]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    dataHigh ¬ CPKernelOps.ReadCPByte[];    CPKernelOps.WriteCSInternal[      kBuffer, CPMI.MI[      , , , , , , , , , ioOut, ioxIn, , [i[iopOData]], [d[io]], kWait]];    CPKernelOps.ExecuteCPBuffer[];    dataLow ¬ CPKernelOps.ReadCPByte[];    data ¬ Inline.BITSHIFT[dataHigh, 8] + dataLow;    END;      IOPKernelOps.InitializeLock[];  END.
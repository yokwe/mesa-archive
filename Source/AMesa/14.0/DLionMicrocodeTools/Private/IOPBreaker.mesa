-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- IOPBreaker.mesa, HGM,  8-Nov-83 19:09:41DIRECTORY  Environment USING [Byte],  Heap USING [systemZone],    IOP USING [Address, Instruction, JumpAddress, JumpTarget, MightJump],  IOPBreak USING [],  IOPKernel USING [    Error, InKernel, ReadInstruction, ReadPair, ReadMemory, ReadPC, WriteInstruction, WritePC];IOPBreaker: MONITOR  IMPORTS Heap, IOP, IOPKernel  EXPORTS IOPBreak =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    head, first, second: Breakpoint ¬ NIL;  breaksInstalled: BOOLEAN ¬ FALSE;  breaksVisible: BOOLEAN ¬ FALSE;    breakInstruction: IOP.Instruction = [1, 327B, 0, 0];  -- = D7 (hex)  nopInstruction: IOP.Instruction = [1, 0, 0, 0];    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    Breakpoint: TYPE = LONG POINTER TO  BreakpointInfo;  BreakpointInfo: TYPE = RECORD [    location: IOP.Address,    instruction: IOP.Instruction,    next: Breakpoint];    Break: PUBLIC ENTRY PROCEDURE [a: IOP.Address] =    BEGIN ENABLE      BEGIN      IOPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    new: Breakpoint;    BeSureInKernel[];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF finger.location = a THEN ERROR Error["Breakpoint already set there"L];      ENDLOOP;    new ¬ z.NEW[BreakpointInfo];    new­ ¬ [a, IOPKernel.ReadInstruction[a], head];    head ¬ new;    END;	    Unbreak: PUBLIC ENTRY PROCEDURE [a: IOP.Address] =    BEGIN ENABLE      BEGIN      IOPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    previous: Breakpoint ¬ NIL;    BeSureInKernel[];    RemoveBreaksInternal[];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF finger.location = a THEN        BEGIN	temp: Breakpoint ¬ finger;  -- Rats, can't smash LOOP control variable	IF previous = NIL THEN head ¬ finger.next	ELSE previous.next ¬ finger.next;	z.FREE[@temp];	RETURN;	END;      previous ¬ finger;      ENDLOOP;    IF IOPKernel.ReadInstruction[a] = breakInstruction THEN      BEGIN  -- Deleting a compiled in break      IOPKernel.WriteInstruction[a, nopInstruction];      END;    ERROR Error["Breakpoint not found"L];    END;    Reset: PUBLIC ENTRY PROCEDURE =    BEGIN    Smash[];    END;    ClearAllBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    Smash[];    END;  Smash: INTERNAL PROCEDURE =    BEGIN    breaksInstalled ¬ FALSE;    UNTIL head = NIL DO      temp: Breakpoint ¬ head;      head ¬ head.next;      z.FREE[@temp];      ENDLOOP;    z.FREE[@first];    z.FREE[@second];    END;  EnumerateBreaks: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE[IOP.Address]] =    BEGIN ENABLE UNWIND => NULL;    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      proc[finger.location];      ENDLOOP;    END;    InstallBreaks: PUBLIC ENTRY PROCEDURE [single: BOOLEAN] =    BEGIN ENABLE      BEGIN      IOPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    pc: IOP.Address = IOPKernel.ReadPC[];    BeSureInKernel[];    IF breaksInstalled THEN RETURN;    breaksInstalled ¬ TRUE;    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      finger.instruction ¬ IOPKernel.ReadInstruction[finger.location];      IF finger.location = pc THEN LOOP;      IOPKernel.WriteInstruction[finger.location, breakInstruction];      ENDLOOP;    IF single THEN      BEGIN      instruction: IOP.Instruction;      current, next: IOP.Address;      current ¬ IOPKernel.ReadPC[];      instruction ¬ IOPKernel.ReadInstruction[current];      next ¬ current + instruction.length;      first ¬ SetBreak[next];      IF IOP.MightJump[instruction] THEN second ¬ SetBreak[JumpAddress[instruction]];      END;    END;    SetBreak: INTERNAL PROCEDURE [where: IOP.Address] RETURNS [bp: Breakpoint] =    BEGIN    IF AtBreakInternal[where] THEN RETURN[NIL];    bp ¬ z.NEW[BreakpointInfo];    bp­ ¬ [where, IOPKernel.ReadInstruction[where], NIL];    IOPKernel.WriteInstruction[where, breakInstruction];    END;    RemoveBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    RemoveBreaksInternal[];    END;      RemoveBreaksInternal: INTERNAL PROCEDURE =    BEGIN ENABLE IOPKernel.Error => ERROR Error[reason];    pc: IOP.Address;    BeSureInKernel[];    IF ~breaksInstalled THEN RETURN;    breaksInstalled ¬ FALSE;    pc ¬ IOPKernel.ReadPC[] -1 ;    IF OneOfOurs[pc] THEN IOPKernel.WritePC[pc];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IOPKernel.WriteInstruction[finger.location, finger.instruction];      ENDLOOP;    IF first # NIL THEN IOPKernel.WriteInstruction[first.location, first.instruction];    IF second # NIL THEN IOPKernel.WriteInstruction[second.location, second.instruction];    z.FREE[@first];    z.FREE[@second];    END;    OneOfOurs: INTERNAL PROCEDURE [pc: IOP.Address] RETURNS [yes: BOOLEAN] =    BEGIN    IF first # NIL AND first.location = pc THEN RETURN[TRUE];    IF second # NIL AND second.location = pc THEN RETURN[TRUE];    RETURN[AtBreakInternal[pc]];    END;    AtBreak: PUBLIC ENTRY PROCEDURE [pc: IOP.Address] RETURNS [yes: BOOLEAN] =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    RETURN[AtBreakInternal[pc]];    END;    AtBreakInternal: INTERNAL PROCEDURE [pc: IOP.Address] RETURNS [yes: BOOLEAN] =    BEGIN    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF finger.location = pc THEN RETURN[TRUE];      ENDLOOP;    RETURN[FALSE];    END;    BeSureInKernel: INTERNAL PROCEDURE =    BEGIN    IF ~IOPKernel.InKernel[] THEN ERROR Error["Can't adjust breaks while running (or crashed)"L];    END;    -- This lives here (rather than in IOP/IOPsA) because it calls the Kernel on funny cases  JumpAddress: PROCEDURE [instruction: IOP.Instruction]    RETURNS [IOP.Address] =    BEGIN    target: IOP.JumpTarget ¬ IOP.JumpAddress[instruction];    WITH target SELECT FROM      next => ERROR;      tos =>         BEGIN	high, low: Environment.Byte;	sp: IOP.Address = IOPKernel.ReadPair[sp];	high ¬ IOPKernel.ReadMemory[sp+1];	low ¬ IOPKernel.ReadMemory[sp];	RETURN[high * 256 + low];	END;      hl => RETURN[IOPKernel.ReadPair[hl]];      jumps => RETURN[to];      ENDCASE => ERROR;    END;  END.
-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- Last Edited by DEG     , 30-May-83 19:47:25 - See Log at end-- File: MakeDLionCpr.mesa-- Translates test image of Dandelion main memory to binaryDIRECTORY  Exec USING [    AddCommand, ExecProc, FreeTokenString, GetToken, Handle, OutputProc],  Format USING [CR],  MStream USING [Error, ReadOnly, ReleaseData, WriteOnly],  Stream USING [    EndOfStream, GetChar, GetWord, Delete, Handle, Position, PutWord,    SetPosition],  String USING [AppendChar, Empty, Equivalent, StringBoundsFault];MakeCprDLion: PROGRAM IMPORTS Exec, Format, MStream, Stream, String =  BEGIN  -- This is a program used to translate a text file describing main memory into a binary file.  -- The text file contains comments extending from a ";" to the end of the line, physical  -- addresses beginning with "@" and data words.  All numbers are in Hexadecimal.  Only the  -- least significant 8 digits of an address and the 4 least significant digits of a data  -- word are used.  The binary file is composed of an indefinite number of blocks, each  -- starting with one word of word count, the high word of the physical address, the low word  -- of the physical address and finally wordcount words of data.  There is no checksum or  -- other error detection.  A block with a word count of 0 signals the end of the file.  -- Numeric labels were added on January 16, 1980.  Label definitions take the form:  -- #<hex number>  (not necessarily in column 1).  -- Label invocations take the form: [<hex number>  -- For example, a line beginning with the location denoted by label 14 containing a  -- reference to the location denoted by label FFFF could be written  -- #14	2 [FFFF  -- This program makes two passes through the file so forward addressing is allowed.  -- The ability to "include" a binary file was added on April 28, 1980.  -- If a "<filename>" (actually enclosed in "<>") is found in the input file, the contents  -- of the binary file filename are inserted in the output file at that point.  BinaryFileProblem: ERROR [problemType: {noName, tooLong, cantGetFile}] = CODE;  GetBinaryFile: PROCEDURE [dh: Stream.Handle]    RETURNS [outStream: Stream.Handle] =    BEGIN    fileName: STRING = [50];    streamNo: MStream.ReleaseData = [NIL, NIL];    fileName.length ¬ 0;    DO  -- look for start of file name      fchar: CHARACTER = Stream.GetChar[dh];  -- get next file char      SELECT fchar FROM  -- what char is it?        '\N, '; => ERROR BinaryFileProblem[noName];        ' , '\T, ', => LOOP;  -- skip over white space        ENDCASE => {String.AppendChar[fileName, fchar]; EXIT};      ENDLOOP;    DO  -- accumulate the file name      fchar: CHARACTER = Stream.GetChar[dh];  -- get next char from file      SELECT fchar FROM        '\N, ' , '\T, ',, ';, '> => EXIT;  -- separator => end of file name        ENDCASE =>          String.AppendChar[            fileName, fchar ! String.StringBoundsFault => GOTO tooLong];      ENDLOOP;    outStream ¬ MStream.ReadOnly[      name: fileName, release: streamNo ! MStream.Error => GOTO cantGetFile];    EXITS      tooLong => ERROR BinaryFileProblem[tooLong];      cantGetFile => ERROR BinaryFileProblem[cantGetFile];    END;  -- This procedure is used to filter Bravo control chars from the input stream and echo it  -- during pass one.  The echo output contains hex addresses at the beginning of each line.  -- The first hex address is put in mesa.typescript by the main code.  The listing file ends  -- up in mesa.typescript.  -- Note that a CR seen while fetching a number will terminate the number, so the next line  -- should begin with the next address.  GetChar: PROCEDURE [dh: Stream.Handle] RETURNS [ch: CHARACTER] =    BEGIN    ch ¬ Stream.GetChar[dh];  -- get char from input stream    IF ch = '\032 << Ascii.ControlZ >> THEN  -- gobble up the Bravo formatting to eof/CR      WHILE ch # '\N DO        ch ¬ Stream.GetChar[dh];  -- get next formatting char in this line        ENDLOOP;    RETURN[ch];  -- return the final character read    END;  GetTokenDiscardSwitches: PROC [h: Exec.Handle] RETURNS [token: LONG STRING] = {    temp: LONG STRING;    [token, temp] ¬ Exec.GetToken[h];    [] ¬ Exec.FreeTokenString[temp]};  -- It is useful to have a procedure to discard the portion of a line containing  -- comments.  GobbleLine does this.  GobbleLine: PROCEDURE [dh: Stream.Handle] =    BEGIN    ch: CHARACTER;  -- holds chars read in from file    ch ¬ GetChar[dh];  -- get 1st char of rest of line    WHILE ch # '\N DO  -- discard the rest of the line      ch ¬ GetChar[dh];  -- EndOfStream handled by signal      ENDLOOP;    END;  -- This procedure translates a characters string describing a hex number into its binary equivalent.  -- The most significant digit of the number is passed in mSChar, as it was used to recognize that   -- this is a number by a higher level routine and can't be put back on the disk for this one.  The character immediately following the number is passed back in nChar so it may be  -- parsed properly in the higher level routine.  HexFromASCII: PROCEDURE [dh: Stream.Handle, mSChar: CHARACTER]    RETURNS [hiWord, loWord: CARDINAL, nChar: CHARACTER] =    BEGIN    charsInt: CARDINAL;  -- cardinal corresponding to character    stillDigit: BOOLEAN ¬ TRUE;  -- => next char found was a digit    GetHexDigit: PROCEDURE [charIn: CHARACTER]      RETURNS [wasDigit: BOOLEAN, digit: CARDINAL] =      BEGIN  -- used to translate char to hex digit      wasDigit ¬ TRUE;  -- assume char is a digit      SELECT charIn FROM        IN ['0..'9] => digit ¬ charIn - '0;  -- was a digit from zero through nine        IN ['A..'F] => digit ¬ charIn - 'A + 10;  -- was 10 through 15, upper case        IN ['a..'f] => digit ¬ charIn - 'a + 10;  -- was 10 through 15, lower case        ENDCASE => wasDigit ¬ FALSE;  -- wasn't a hex digit      RETURN[wasDigit, digit];  -- return final values      END;    -- body of HexFromASCII    hiWord ¬ loWord ¬ 0;  -- intialize accumulators    nChar ¬ mSChar;  -- initialize last char seen    [stillDigit, charsInt] ¬ GetHexDigit[mSChar];  -- get digit for char passed as most significant    -- digit of number    WHILE stillDigit DO  -- accumulate characters      hiWord ¬ 16*hiWord + (loWord/4096);  -- shift hi word over 1 hex digit      loWord ¬ 16*loWord + charsInt;  -- shift lo word over 1 hex digit, accum new digit      nChar ¬ GetChar[dh];  -- get either next char in number or 1st char      -- after number.      [stillDigit, charsInt] ¬ GetHexDigit[nChar];  --get next digit of number or end of #      ENDLOOP;    RETURN[hiWord, loWord, nChar];    END;  DoCpr: Exec.ExecProc =  -- PROC [h: Exec.Handle] RETURNS [o: Exec.Outcome ¬ normal]    BEGIN    -- declare names, handles needed for the disk files    streamNo: MStream.ReleaseData = [NIL, NIL];    inputFileName: LONG STRING;    outputFileName: LONG STRING;    inputFile, outputFile: Stream.Handle;    -- Assume procedure is invoked as MakeDLionCpr outputFileName ¬ inputFileName    -- Where inputFileName is a text(even bravo) file.     Write: PROCEDURE [s: LONG STRING, clientData: LONG POINTER ¬ NIL] =      Exec.OutputProc[h];    BEGIN    outputFileName ¬ GetTokenDiscardSwitches[h];    inputFileName ¬ GetTokenDiscardSwitches[h];    IF ~String.Equivalent[inputFileName, "¬"L] THEN {      Write[s: "Error - Required command format is: MakeDLionCpr output ¬ input"L];      GOTO out};    inputFileName ¬ Exec.FreeTokenString[inputFileName];    inputFileName ¬ GetTokenDiscardSwitches[h];    IF String.Empty[outputFileName] OR String.Empty[inputFileName]      THEN {      Write[s: "Error - Required command format is: MakeDLionCpr output ¬ input"L];      GOTO out};    inputFile ¬ MStream.ReadOnly[      name: inputFileName, release: streamNo !      MStream.Error => {Write[s: "Can't aquire file"L]; GOTO out}];    outputFile ¬ MStream.WriteOnly[      name: outputFileName, release: streamNo, type: binary!      MStream.Error => {        Stream.Delete[inputFile]; Write[s: "Can't aquire file"L]; GOTO out}];    ReallyDoCpr[      Write, inputFile, outputFile !      BinaryFileProblem => {        Write[s:           IF problemType = noName THEN "Illeagal binary file syntax"L          ELSE            IF problemType = tooLong THEN "Binary file name too long"L            ELSE              IF problemType = cantGetFile THEN "Can't open binary file"L              ELSE "Unknown binary file problem"L];        Stream.Delete[outputFile];        Stream.Delete[inputFile];        GOTO out};      UNWIND => {        Stream.Delete[outputFile];        Stream.Delete[inputFile];        inputFileName ¬ Exec.FreeTokenString[inputFileName];        outputFileName ¬ Exec.FreeTokenString[outputFileName]}];    Stream.Delete[outputFile];    Stream.Delete[inputFile];    Write[s: ". Done     "L];    Write[s: outputFileName];    Write[s: " produced "];    Format.CR[Write];    inputFileName ¬ Exec.FreeTokenString[inputFileName];    outputFileName ¬ Exec.FreeTokenString[outputFileName];    EXITS      out => {        inputFileName ¬ Exec.FreeTokenString[inputFileName];        outputFileName ¬ Exec.FreeTokenString[outputFileName];        RETURN[error]};    END;    END;  ReallyDoCpr: PROC [    Write: PROCEDURE [s: LONG STRING, clientData: LONG POINTER ¬ NIL],     inputFile, outputFile: Stream.Handle] =    BEGIN    streamBeginning: Stream.Position = 0;    -- Data blocks are accumulated in the array dataBlock. The next word will go in main    -- memory address curAddrHi,,curAddrLo. There are always blockLen words in dataBlock.    maxBlockLen: CARDINAL = 256;    dataBlock: ARRAY [0..maxBlockLen] OF CARDINAL;    blockLen, curAddrHi, curAddrLo: CARDINAL ¬ 0;    -- The label-address correspondence is kept in the array label.    label: ARRAY [0..1024] OF CARDINAL ¬ ALL[0];    -- we need variables to hold the characters read in from the file    addrLo, addrHi, labelNum, newData: CARDINAL;    -- the format of the hex addresses being written out    nextChar: CHARACTER ¬ ' ;  -- one should not ignore the char immediately    -- following a hex number. This variable is used to    -- pass this char back so it may be parsed.    -- This is a procedure to append one data word onto the block in dataBlock.  It also updates    -- curAddrLo, curAddrHi and blockLen.  If the block is already full, it is written out before    -- the new number is added.    AppendNum: PROCEDURE [dh: Stream.Handle, newNum: CARDINAL] =      BEGIN      IF blockLen >= maxBlockLen THEN  -- Write out this block        SendBlock[dh];      dataBlock[blockLen] ¬ newNum;  -- add new number to end of block      blockLen ¬ blockLen + 1;      curAddrLo ¬ curAddrLo + 1;  -- increment low word of current main memory address      IF curAddrLo = 0 THEN curAddrHi ¬ curAddrHi + 1;  --if carry, increment high addr word      RETURN;      END;    -- A procedure is needed to write the data block out to disk.  The word count in blockLen is written    -- followed by curAddrHi, curAddrLo and the data words in dataBlock.  On completion, blockLen is    -- reset to 0 to clear the block.  curAddrHi and curAddrLo are not changed in case the next block is    -- contiguous.    SendBlock: PROCEDURE [dh: Stream.Handle] =      BEGIN      blockIndex: CARDINAL;  -- used to index through the block      Stream.PutWord[dh, blockLen];  -- start block with word count      IF blockLen > curAddrLo THEN  -- then the block crossed a 64k boundry so        Stream.PutWord[dh, curAddrHi - 1]  -- write # of cur 64k block - 1      ELSE  -- started in this 64k block        Stream.PutWord[dh, curAddrHi];  -- so write its number      Stream.PutWord[dh, curAddrLo - blockLen];  -- write lo word of starting address      FOR blockIndex IN [0..blockLen) DO  -- send out elements of data block        Stream.PutWord[dh, dataBlock[blockIndex]]; ENDLOOP;      blockLen ¬ 0;  -- clear out data block      END;    -- Now start pass one through the file.  Here we look for addresses beginning with '@' to initialize    -- a program counter.  Strings beginning with '[' or a character other than ControlZ or ';' are used    -- to increment the counter in curAddrhi,,curAddrLo.  Comments are ignored.  Each time a string    -- beginning with '#' is found, the hex string immediately following is used as an index into the    -- array label.  The number in curAddrLo is stored in that location as the label's value.    Format.CR[Write];    Write[s: " Pass 1 .."L];    --now begin looking for label declarations    DO  -- parse the whole input file. eof by EndOfStream Signal      ENABLE Stream.EndOfStream => EXIT;      char: CHARACTER;      IF nextChar = '  THEN  -- no char saved from last number so get one        char ¬ GetChar[inputFile]  -- from the input file      ELSE  -- parse the char that ended the last number        {char ¬ nextChar; nextChar ¬ ' };  -- and reset that char to "don't care"      SELECT char FROM        '\T, ' , ' , '\N => LOOP;  -- skip over white space        '; => GobbleLine[inputFile];  -- skip over comments        '@ =>          BEGIN  -- found an address          [addrHi, addrLo, nextChar] ¬ HexFromASCII[inputFile, '0];  -- get it          curAddrHi ¬ addrHi;  -- update addr          curAddrLo ¬ addrLo;          END;  -- if new address is contiguous, ignore it        '# =>          BEGIN  -- found a label declaration          [, labelNum, nextChar] ¬ HexFromASCII[inputFile, '0];  -- get          -- label's number          label[labelNum] ¬ curAddrLo;  -- set its value          END;        '[ =>          BEGIN  -- a label invocation has been found          [, labelNum, nextChar] ¬ HexFromASCII[inputFile, '0];  -- get and          -- ignore label ID          curAddrLo ¬ curAddrLo + 1;  -- increment memory for the place this invocation          IF curAddrLo = 0 THEN curAddrHi ¬ curAddrHi + 1;  -- will take          END;        '< =>          BEGIN  -- found first delim for name of binary file          binaryFile: Stream.Handle = GetBinaryFile[inputFile];          DO  -- read the whole file            [] ¬ Stream.GetWord[binaryFile ! Stream.EndOfStream => EXIT; ];            curAddrLo ¬ curAddrLo + 1;  -- increment the current address 			                          IF curAddrLo = 0 THEN curAddrHi ¬ curAddrHi + 1;            ENDLOOP;  -- either at end of line or end of file          Stream.Delete[binaryFile];          END;        IN ['0..'9], IN ['A..'F], IN ['a..'f] =>          BEGIN  -- found a number to be stored          [, newData, nextChar] ¬ HexFromASCII[inputFile, char];  -- get          -- number          curAddrLo ¬ curAddrLo + 1;  -- increment memory for the place this number          IF curAddrLo = 0 THEN curAddrHi ¬ curAddrHi + 1;  -- will take          END;        ENDCASE => LOOP;  -- ignore other characters      ENDLOOP;    -- now begin pass two.  Wherever a string beginning with "#" is found, it is ignored.  Every string    -- beginning with "[" is assumed to be a label invocation, and is replaced with the value of the    -- corresponding label.    Write[s: ". Pass 2 .."L];    Stream.SetPosition[inputFile, streamBeginning];    curAddrHi ¬ curAddrLo ¬ blockLen ¬ 0;  -- reinitialize block parameters    nextChar ¬ ' ;  -- reinitialize parsing character    DO  -- parse the whole input file. eof by EndOfStream Signal      ENABLE Stream.EndOfStream => EXIT;      char: CHARACTER;      IF nextChar = '  THEN  -- no char saved from last number so get one        char ¬ GetChar[inputFile]  -- from the input file      ELSE  -- parse the char that ended the last number        {char ¬ nextChar; nextChar ¬ ' };  -- and reset that char to "don't care"      SELECT char FROM        '\T, ' , '\N, ', => LOOP;  -- skip over white space        '; => GobbleLine[inputFile];  -- skip over comments        '@ =>          BEGIN  -- found an address          [addrHi, addrLo, nextChar] ¬ HexFromASCII[inputFile, '0];  -- get it          IF ((addrHi # curAddrHi) OR (addrLo # curAddrLo)) AND (blockLen > 0)            THEN SendBlock[outputFile];  -- end of this block, so send it          curAddrHi ¬ addrHi;  -- update addr in either case          curAddrLo ¬ addrLo;          END;  -- if new address is contiguous, ignore it        '# =>          BEGIN  -- found a label declaration, bypass its          -- characters          [, labelNum, nextChar] ¬ HexFromASCII[inputFile, '0];  -- get its chars          END;  -- and ignore them        '[ =>          BEGIN  -- a label invocation has been found          [, labelNum, nextChar] ¬ HexFromASCII[inputFile, '0];  -- get label ID          AppendNum[outputFile, label[labelNum]];  -- replace with label's value          END;        '< =>          BEGIN  -- found first delim for name of binary file          binaryFile: Stream.Handle = GetBinaryFile[inputFile];          DO  -- copy the whole file            wd: WORD;            wd ¬ Stream.GetWord[binaryFile ! Stream.EndOfStream => EXIT];            AppendNum[outputFile, wd ! UNWIND => Stream.Delete[binaryFile]];            ENDLOOP;          Stream.Delete[binaryFile];          END;        IN ['0..'9], IN ['A..'F], IN ['a..'f] =>          BEGIN  -- found a number to be stored          [, newData, nextChar] ¬ HexFromASCII[inputFile, char];  -- get number          AppendNum[outputFile, newData];          END;        ENDCASE => LOOP;  -- ignore other characters      ENDLOOP;    -- now have translated the entire text file.  Kick out the last block followed by a null block    -- signalling end of file.    IF blockLen > 0 THEN SendBlock[outputFile];  -- send last block    SendBlock[outputFile];  -- send null block to finish file    END;  -- End of REallyDoCpr procedure  Init: PROC = {Exec.AddCommand[name: "MakeDLionCpr.~"L, proc: DoCpr]};  --main line code  Init[];  END.... --  MakeCprDLion    -- Log  --  3-Mar-82 11:53:22 - ETN   - Created as Trinity from Alto Mesa MakeBinFile  -- 26-Jan-83 12:36:45 - ETN   - Sierra. String => Storage, Add ClientData to Write  -- 30-May-83 19:47:22 - DEG      - Remove references to the Ascii interface
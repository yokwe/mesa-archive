-- Copyright (C) 1980, 1981, 1983  by Xerox Corporation. All rights reserved. -- PanelSW.mesa, HGM, 10-Feb-83 23:43:53-- Mark August 20, 1980  7:27 PM-- PXJ    August 20, 1980  7:11 PM-- Last edit by PXO      on October 22, 1981  8:58 PM - Changed some procs to deal in longs.DIRECTORY  Menu USING [MCRType],  Tool USING [SWType],  ToolWindow USING [AdjustProcType, State],  Window USING [Handle, Place],  WindowFont USING [Handle];PanelSW: DEFINITIONS =  BEGIN  -- +++ Interface out to client +++  -- Data TYPEs  RegisterSpec: TYPE = LONG POINTER TO RegisterSpecObject;  RegisterSpecObject: TYPE = RECORD [UNSPECIFIED];  -- Should be EXPORTed TYPE, but Burdock must have multiple EXPORTs.  ClientProcs: TYPE = LONG POINTER TO ClientProcsObject;  ClientProcsObject: TYPE = RECORD [    freeRS: FreeRSProcType,    lhTypeInEval: LHTypeInEvalProcType,    modifyTypeIn: ModifyTypeInProcType,    readTarget: ReadTargetProcType,    rhTypeInEval: RHTypeInEvalProcType];  -- PROCEDURE TYPEs  FreeRSProcType: TYPE = PROCEDURE [rs: RegisterSpec];  LHTypeInEvalProcType: TYPE =  -- converts any string to register spec    PROCEDURE [ts: TileSpec, typeIn: --READONLY-- LONG STRING, normalize: BOOLEAN]    RETURNS [display: LONG STRING, newRs: RegisterSpec];  ModifyTypeInProcType: TYPE =  -- affects client's typeIn    PROCEDURE [newTypeIn: --READONLY-- LONG STRING, replace: BOOLEAN];  ReadTargetProcType: TYPE =  -- reads from hardware    PROCEDURE [rs: RegisterSpec, newLH: BOOLEAN]    RETURNS [s: LONG STRING];  -- SIGNALs ClientError if read fails.  RHTypeInEvalProcType: TYPE =  -- converts any string to right hand side    PROCEDURE [    ts: TileSpec, typeIn: --READONLY-- LONG STRING, rs: RegisterSpec] RETURNS [display: LONG STRING];  -- SIGNALs ClientError if write fails.  WriteTargetProcType: TYPE = PROCEDURE [    rs: RegisterSpec, s: --READONLY-- LONG STRING];  -- SIGNALs ClientError if write fails.  -- SIGNALS and ERRORs  ClientError: SIGNAL [code: ClientErrorCode, msg: LONG STRING];  ClientErrorCode: TYPE = {readOnly, writeFailed, writeOnly, unknown};  -- +++ Tile description +++  TileState: TYPE = {bogus, changed, old};  TileField: TYPE = MACHINE DEPENDENT{flag(0), left(1), right(2)};  TileIndex: TYPE = CARDINAL [0..37777B];  TileSpec: TYPE = RECORD [field: TileField, index: TileIndex];  TileLayout: TYPE = ARRAY TileField OF CARDINAL;  RowDesc: TYPE = DESCRIPTOR FOR ARRAY OF TileLayout;  -- Constants  -- nilTileIndex must be >= TileCount[h] for all known h    nilTileIndex: TileIndex = LAST[TileIndex];  -- +++ Procedural interface +++  ActOnTileProcType: TYPE = PROCEDURE [h: Handle, ts: TileSpec];  ActOnPanelProcType: TYPE = PROCEDURE [h: Handle];  -- Individual tile operations  ClearTile: ActOnTileProcType;  -- frees all storage associated with the tile  DisplayTile: ActOnTileProcType;  -- redisplay from backing store  UpdateTile: ActOnTileProcType;  -- redisplay from hardware  -- ... and their panel counterparts  Clear: ActOnPanelProcType;  Display: ActOnPanelProcType;  Update: ActOnPanelProcType;  -- Panel setup and teardown  Handle: TYPE = LONG POINTER TO Object;  Object: TYPE;  Options: TYPE = RECORD [font: WindowFont.Handle ¬ NIL];  Adjust: ToolWindow.AdjustProcType;  Create: PROCEDURE [    sw: Window.Handle, err: Window.Handle, numTiles: CARDINAL, rowDesc: RowDesc,    clientProcs: ClientProcs, typeIn: LONG POINTER TO LONG STRING, options: Options ¬ [],    initialState: ToolWindow.State ¬ active] RETURNS [h: Handle];  Destroy: ActOnPanelProcType;  SetOptions: PROCEDURE [h: Handle, options: Options];  Sleep: ActOnPanelProcType;  -- making window tiny  SWType: PROCEDURE RETURNS [Tool.SWType];  Wakeup: ActOnPanelProcType;  -- making window normal  -- +++ Routines provided for benefit of command files +++  ModifyLH: PROCEDURE [h: Handle, ts: TileSpec, suffix: LONG STRING];  -- Raises TileError.  ReadTile: PROCEDURE [h: Handle, ts: TileSpec]    RETURNS [s: --READONLY-- LONG STRING];  -- always reads hardware  StringFromTile: PROCEDURE [h: Handle, ts: TileSpec]    RETURNS [s: --READONLY-- LONG STRING];  -- never reads hardware  WriteTile: PROCEDURE [    h: Handle, ts: TileSpec, s: --READONLY-- LONG STRING, normalize: BOOLEAN];  -- Call this to load up a lhs, or to write a value into a rhs  -- Raises TileError.  TileIndexFromRowColumn: PROCEDURE [h: Handle, row, column: CARDINAL]    RETURNS [ti: TileIndex];  -- Object conversion  HandleFromSubwindow: PROCEDURE [sw: Window.Handle] RETURNS [h: Handle];  SubwindowFromHandle: PROCEDURE [h: Handle] RETURNS [sw: Window.Handle];  RegSpecFromTileSpec: PROCEDURE [h: Handle, ts: TileSpec]    RETURNS [rs: RegisterSpec];  -- +++ Utilities +++  IsIt: PROCEDURE [sw: Window.Handle] RETURNS [yes: BOOLEAN] = INLINE    BEGIN yes ¬ (HandleFromSubwindow[sw] # NIL); END;  LineHeight: PROCEDURE [h: Handle] RETURNS [CARDINAL];  NeededHeight: PROCEDURE [h: Handle] RETURNS [min, current: CARDINAL];  ResolvePlaceToTile: PROCEDURE [    h: Handle, place: Window.Place, mustResolve: BOOLEAN] RETURNS [ts: TileSpec];  TileCount: PROCEDURE [h: Handle] RETURNS [count: CARDINAL];  FillColumn: Menu.MCRType;  MinusOne: Menu.MCRType;  PlusOne: Menu.MCRType;  UpdateMCR: Menu.MCRType;  MenuPNRDownPlace: PROCEDURE [h: Handle] RETURNS [place: Window.Place];  -- +++ SIGNALS and ERRORs +++  Error: SIGNAL [code: ErrorCode];  ErrorCode: TYPE = {alreadyAPanelSW, badArgs, notAPanelSW};  TileError: SIGNAL [code: TileErrorCode, ts: TileSpec];  TileErrorCode: TYPE = {readFailed, writeFailed};  END.  -- of PanelSW.mesaThe initial state of a PanelSW is:  Clear display  Empty backing store  Arbitrary hardware state  The steady state of a PanelSW is:  [0..numTiles) displayed using an arbitrary subset of the display slots  Full backing store that is a snapshot of the hardware  Arbitrary hardware state  Display can be completely reconstructed from the backing store  Data flow:  Backing store: (Bst == Backing store tile)    Bstl/r ¬ clientProcs.typeInEval[TypeIn]    Bstr ¬ clientProcs.readTarget[...]  -- SIGNALs if cannot read  Hardware store:    clientProcs.writeTarget[...].  Display:    Always built from the backing store  TypeIn ¬ Display (as seen by user):    Actual operation is TypeIn ¬ Bstl/r  Display tile leftside ¬ TypeIn (as seen by user):    Actual operation sequence is:      [Bstl, registerSpec] ¬ clientProcs.typeInEval[TypeIn]      Bstr ¬ clientProcs.readTarget[registerSpec]  -- SIGNALs if cannot read  Display tile rightside ¬ TypeIn (as seen by user):    Actual operation sequence is:      [Bstr, registerSpec] ¬ clientProcs.typeInEval[TypeIn]      clientProcs.writeTarget[registerSpec, Bstr]  -- SIGNALs if cannot write      If a read fails, the tile is flagged as bogus.
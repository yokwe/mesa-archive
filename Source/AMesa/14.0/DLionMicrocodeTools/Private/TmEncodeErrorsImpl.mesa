-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TmEncodeErrorsImpl.mesa.-- Last edit: DEG      26-Sep-84 20:39:39-- Last edit: JAC    11-Jul-83 10:13:05-- Last edit: ETN    16-Jul-82 13:15:52-- The purpose of this module is to create, delete, and print error messages that occur during encoding.  Syntax error messages are queued onto phrase.errorMsgs.  Other error messages are created and queued onto phrase.tempErrorMsgs.  Messages are saved here temporarily because an alternate encoding may save the day.  If no encoding works, MakeTempErrorMsgsPermamanent will be called to requeue the messages onto phrase.errorMsgs.    DIRECTORY  Inline USING [LDIVMOD],  TmFile USING [LogErrAndSrcLines, LogLine],  TmAssembler,  String USING [AppendChar, AppendString, WordsForString];TmEncodeErrorsImpl: PROGRAM  IMPORTS Inline, TmFile, TmAssembler, String EXPORTS TmAssembler =  BEGIN OPEN TmAssembler;  -- GLOBAL VARIABLES  constant: LONG STRING ¬ [10];  msg: LONG STRING ¬ [250];  -- All messages are created in this string.  -- SIGNALS AND ERRORS GENERATED  EncodeErrorsError: ERROR [    {    invalidSyntaxErrorCode, invalidLogical, invalidRegister, invalidPhraseElement,    invalidAssignment}] = CODE;  AppendAssignment: PROCEDURE [assignment: Assignment] =    BEGIN    -- Append the cause of an assignment onto msg.  For every field in the Encoding record, we remember what caused the assignment just for this purpose.  When two elements conflict, we can say what what phrase elements cause the conflict.    WITH assignment SELECT FROM      expression => String.AppendString[msg, "expression"L];      macro =>        BEGIN        String.AppendString[msg, "macro "L];        String.AppendString[msg, macroTable[macroIndex].macro.name];        END;      register => String.AppendString[msg, RegisterTypeString[registerType]];      ENDCASE => ERROR EncodeErrorsError[invalidAssignment];    RETURN;    END;  AppendDecimal: PROCEDURE [string: LONG STRING, number: CARDINAL] =    BEGIN    base: CARDINAL = 10;    charZero: CARDINAL = LOOPHOLE['0];    Digit: PROCEDURE =      BEGIN      remainder: CARDINAL;      IF number # 0 THEN        BEGIN        [number, remainder] ¬ Inline.LDIVMOD[number, 0, base];        Digit;        String.AppendChar[string, LOOPHOLE[remainder + charZero, CHARACTER]];        END;      RETURN;      END;    IF number = 0 THEN String.AppendChar[string, '0] ELSE Digit;    RETURN;    END;  AppendElementType: PROCEDURE [phrase: PhrasePtr] =    BEGIN    -- Append the name of a  Phrase Element onto msg.    string: LONG STRING;    IF phrase.currentElement = NIL THEN      BEGIN String.AppendString[msg, "null element"L]; RETURN; END;    string ¬      WITH phrase.currentElement­.elementRec SELECT FROM        arrow => "¬"L,        plus => "+"L,        minus => "-"L,        not => "~"L,        macro => macroTable[macroIndex].macro.name,        LRot => macroTable[macroIndex].macro.name,        logical =>          SELECT logicalOperation FROM            and => "and"L,            or => "or"L,            xor => "xor"L,            ENDCASE => ERROR EncodeErrorsError[invalidLogical],        register => RegisterTypeString[registerType],        constant => ConstantString[value],        IOXIn => "IOXIn"L,        ENDCASE => ERROR EncodeErrorsError[invalidPhraseElement];    String.AppendString[msg, string];    RETURN;    END;  AssignBrequired: PUBLIC PROCEDURE [phrase: PhrasePtr] =    BEGIN    -- If the instruction puts A on the Y Bus (aD = 2), the output of the ALU is assigned to register B.  When aD = 2, we must be sure that the statement includes an assignment to rB.    msg.length ¬ 0;    String.AppendString[msg, "Assignment to register B required"L];    ChainMsg[@phrase.tempErrorMsgs];    RETURN;    END;  BusMismatch: PUBLIC PROCEDURE [phrase: PhrasePtr, busName: LONG STRING] =    BEGIN    msg.length ¬ 0;    String.AppendString[msg, "Input from or Output to "L];    String.AppendString[msg, busName];    String.AppendString[msg, " required"L];    ChainMsg[@phrase.tempErrorMsgs];    RETURN;    END;  BusConflict: PUBLIC PROCEDURE [phrase: PhrasePtr, busName: LONG STRING] =    BEGIN    msg.length ¬ 0;    String.AppendString[msg, "More than one signal on "L];    String.AppendString[msg, busName];    ChainMsg[@phrase.tempErrorMsgs];    RETURN;    END;  ChainMsg: PROCEDURE [list: LONG POINTER TO ErrorMsgPtr] =    BEGIN    -- Chain msg onto phrase.errorMsgs.    newErrorMsg: ErrorMsgPtr;    lastErrorMsg: ErrorMsgPtr;    -- Allocate a new error message and initialize it with the contents of msg.    newErrorMsg ¬ GetStmtSpace[SIZE[ErrorMsg] + String.WordsForString[msg.length]];    newErrorMsg­ ¬ [      nextMsg: NIL, msg: LOOPHOLE[@newErrorMsg.length, LONG STRING], length: 0,      maxlength: msg.length];    String.AppendString[newErrorMsg.msg, msg];    -- Chain the new error mesesage onto the list.    IF list­ = NIL THEN      BEGIN  -- the chain is empty.  Chain the first record.      list­ ¬ newErrorMsg;      RETURN;      END;    lastErrorMsg ¬ list­;    DO  -- Find the end of the chain      IF lastErrorMsg.nextMsg = NIL THEN EXIT;      lastErrorMsg ¬ lastErrorMsg.nextMsg;      ENDLOOP;    lastErrorMsg.nextMsg ¬ newErrorMsg;    RETURN;    END;  ConstantString: PROCEDURE [value: CARDINAL] RETURNS [LONG STRING] =    BEGIN    -- Convert value to string and append to global constant.    constant.length ¬ 0;    AppendDecimal[constant, value];    RETURN[constant];    END;    FormatError: PUBLIC PROCEDURE [    phrase: PhrasePtr, assignment1, assignment2: Assignment,    fieldName: LONG STRING] =    BEGIN    -- There is a conflict in field fieldName.  assignment1 has already been assigned, and assignment2 conflicts.  Create an error message and chain it onto phrase.tempErrorMsgs.  The error messages will be chained onto phrase.errorMsgs if no pattern that works can be found.    msg.length ¬ 0;    AppendAssignment[assignment1];    String.AppendString[msg, " conflicts with "L];    AppendAssignment[assignment2];    String.AppendString[msg, " in field "L];    String.AppendString[msg, fieldName];    ChainMsg[@phrase.tempErrorMsgs];    RETURN;    END;  InvalidLRotPath: PUBLIC PROCEDURE [phrase: PhrasePtr] =    BEGIN    -- This occurs whenever the LHS of an expression requires input from the Y Bus.  This would create two signals on the Y Bus: one for input to the Rot box, and another as output from the ALU.    msg.length ¬ 0;    String.AppendString[msg, "Invalid data path for LRot"L];    ChainMsg[@phrase.tempErrorMsgs];    RETURN;    END;  MakeTempErrorMsgsPermanent: PUBLIC PROCEDURE [phrase: PhrasePtr] =    BEGIN    -- Move phrase.tempErrorMsgs to phrase.errorMsgs.    lastErrorMsg: ErrorMsgPtr;    IF phrase.tempErrorMsgs = NIL THEN RETURN;    phrase.formatError ¬ TRUE;    IF phrase.errorMsgs = NIL THEN phrase.errorMsgs ¬ phrase.tempErrorMsgs    ELSE      BEGIN      lastErrorMsg ¬ phrase.errorMsgs;      DO  -- Find the end of the chain        IF lastErrorMsg.nextMsg = NIL THEN EXIT;        lastErrorMsg ¬ lastErrorMsg.nextMsg;        ENDLOOP;      lastErrorMsg.nextMsg ¬ phrase.tempErrorMsgs;      END;    phrase.tempErrorMsgs ¬ NIL;    RETURN;    END;  MultipleReference: PUBLIC PROCEDURE [phrase: PhrasePtr, name: LONG STRING] =    BEGIN    msg.length ¬ 0;    String.AppendString[msg, name];    String.AppendString[msg, " cannot be referenced more than once per cycle"L];    ChainMsg[@phrase.tempErrorMsgs];    RETURN;    END;  NoLRotDestination: PUBLIC PROCEDURE [phrase: PhrasePtr] =    BEGIN    msg.length ¬ 0;    String.AppendString[msg, "LRot has no destination"L];    ChainMsg[@phrase.tempErrorMsgs];    RETURN;    END;  PrintPhraseErrorMsgs: PROCEDURE [phrase: PhrasePtr] =    BEGIN    errorMsg: ErrorMsgPtr ¬ phrase.errorMsgs;    UNTIL errorMsg = NIL DO      TmFile.LogLine[errorMsg.msg]; errorMsg ¬ errorMsg.nextMsg; ENDLOOP;    errorMsg ¬ phrase.tempErrorMsgs;    UNTIL errorMsg = NIL DO      TmFile.LogLine[errorMsg.msg]; errorMsg ¬ errorMsg.nextMsg; ENDLOOP;    RETURN;    END;  PrintStatementErrorMsgs: PUBLIC PROCEDURE [statement: StatementPtr] =    BEGIN    phrase: PhrasePtr ¬ statement.firstPhrase;    UNTIL phrase = NIL DO      PrintPhraseErrorMsgs[phrase];            phrase ¬ phrase.nextPhrase;      ENDLOOP;    TmFile.LogErrAndSrcLines["Unable to encode Statement"L];    RETURN;    END;  RegisterTypeString: PROCEDURE [registerType: RegisterType]    RETURNS [string: LONG STRING] =     BEGIN    string ¬      SELECT registerType FROM        R => "R register",        RH => "RH register",        U => "U register",        UY => "UY register",        STK => "STK",        Q => "Q",        bus => "[]",        ENDCASE => "unknownRegType";    RETURN;    END;  LRotConflict: PUBLIC PROCEDURE [phrase: PhrasePtr] =    BEGIN    msg.length ¬ 0;    String.AppendString[      msg, "Registers must have same address for LRot expression"L];    ChainMsg[@phrase.tempErrorMsgs];    RETURN;    END;  SyntaxError: PUBLIC PROCEDURE [phrase: PhrasePtr, code: SyntaxErrorCode] =    BEGIN    msg.length ¬ 0;    SELECT code FROM      invalidExpression => String.AppendString[msg, "Invalid expression"L];      arrowMissing => String.AppendString[msg, "Arrow missing"L];      noRHS => String.AppendString[msg, "Right hand side of expression missing"L];      unexpectedLHS =>        BEGIN        String.AppendString[msg, "Unexpected element in LHS of expression: "L];        AppendElementType[phrase];        END;      operationMissing =>        BEGIN        String.AppendString[msg, "Operation expected, "L];        AppendElementType[phrase];        String.AppendString[msg, " found"L];        END;      missingPlusOrMinus =>        BEGIN        String.AppendString[msg, "Plus or minus one expected, "L];        AppendElementType[phrase];        String.AppendString[msg, " found"L];        END;      unexpectedRHS =>        BEGIN        String.AppendString[msg, "Unexpected element in RHS of expression: "L];        AppendElementType[phrase];        END;      invalidSecondOperand =>        BEGIN        String.AppendString[msg, "Invalid second operand, "L];        AppendElementType[phrase];        String.AppendString[msg, " found"L];        END;      doubleNot => String.AppendString[msg, "Only one not operand permitted"L];      oneMissing =>        BEGIN        String.AppendString[msg, "One following plus expected, "L];        AppendElementType[phrase];        String.AppendString[msg, " found"L];        END;      invalidPlus => String.AppendString[msg, "+1 is invalid"L];      invalidMinus => String.AppendString[msg, "-1 is invalid"L];      noOperand => String.AppendString[msg, "No operand follows operation"L];      operationMissing =>        BEGIN        String.AppendString[msg, "Operation expected, "L];        AppendElementType[phrase];        String.AppendString[msg, " found"L];        END;      endOfPhrase => String.AppendString[msg, "Unexpected end of phrase"L];      multipleLRot => String.AppendString[msg, "Only one LRot permitted"L];      noLRotExpression => String.AppendString[msg, "Operand with LRot missing"L];      ENDCASE => ERROR EncodeErrorsError[invalidSyntaxErrorCode];    ChainMsg[@phrase.errorMsgs];    phrase.syntaxError ¬ TRUE;    RETURN;    END;  UaddressConflict: PUBLIC PROCEDURE [phrase: PhrasePtr] =    BEGIN    msg.length ¬ 0;    String.AppendString[      msg, "U Address must equal low order 4 bits of rA field"L];    ChainMsg[@phrase.tempErrorMsgs];    RETURN;    END;  WriteUConflict: PUBLIC PROCEDURE [phrase: PhrasePtr] =    BEGIN    msg.length ¬ 0;    String.AppendString[      msg, "U Register will be written  although you didn't want it"L];    ChainMsg[@phrase.tempErrorMsgs];    RETURN;    END;  END...    -- Log   -- Time: 26-Sep-84 20:39:35	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.  -- 15-Nov-83 11:28:50 - DEG        - allocate strings in RegisterTypeString from global frame instead of local frame.  -- 11-Jul-83 10:13:35 - JAC        -Removed calls to GetSpace and FreeSpace  -- 16-Jul-82 13:16:18 - ETN        - TrinityMass Version 1   
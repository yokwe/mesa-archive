-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TmAssembler.mesa.-- Last edit: JAC     6-Nov-85 15:31:18-- Last edit: DEG      26-Sep-84 21:14:59-- Last edit: JAC    12-Aug-83  9:29:12-- HGM, 22-Jan-83 17:38:39, More room in macro table -- Last edit: ETN   16-Jul-82 10:13:06 DIRECTORY  MFile USING [Handle],  MSegment USING [Handle];TmAssembler: DEFINITIONS =  BEGIN  -- CONSTANTS  -- The following values are for the fS field.  The fS field is broken into three parts: fS01, fS2, and fS3.  The value of fS is fS01*4 + fS2*2 + fS3.  fS01dispBr: CARDINAL = 0;  -- value for fS01 (bits 0-1 of FS)  fS01fYNorm: CARDINAL = 1;  -- value for fS01 (bits 0-1 of FS)  fS01IOOut: CARDINAL = 2;  -- value for fS01 (bits 0-1 of FS)  fS01byte: CARDINAL = 3;  -- value for fS01 (bits 0-1 of FS)  fS2stackP: CARDINAL = 0;  -- value for fS2 (bit 2 of FS)  fS2fZNorm: CARDINAL = 0;  -- value for fS2 (bit 2 of FS)  fS2nibble: CARDINAL = 0;  -- value for fS2 (bit 2 of FS)  fS2IOIn: CARDINAL = 1;  -- value for fS2 (bit 2 of FS)  fS2uaddr: CARDINAL = 1;  -- value for fS2 (bit 2 of FS)  fS2byte: CARDINAL = 0;  -- value for fS2 (bit 2 of FS)  fS3fZNorm: CARDINAL = 0;  -- value for fS3 (bit 3 of FS)  fS3nibble: CARDINAL = 1;  -- value for fS3 (bit 3 of FS)  fS3IOIn: CARDINAL = 1;  -- value for fS3 (bit 3 of FS)  fS3byte: CARDINAL = 1;  -- value for fS2 (bit 2 of FS)  -- The following values are for the aS field:  aSAQ: CARDINAL = 0;  -- A,Q  aSAB: CARDINAL = 1;  -- A,B  aS0Q: CARDINAL = 2;  -- 0,Q  aS0B: CARDINAL = 3;  -- 0,B  aS0A: CARDINAL = 4;  -- 0,A  aSDA: CARDINAL = 5;  -- D,A  aSDQ: CARDINAL = 6;  -- D,Q  aSD0: CARDINAL = 7;  -- D,0  -- The following values are for the aF field:  aFrPlusS: CARDINAL = 0;  -- R + S  aFsMinusR: CARDINAL = 1;  -- S - R  aFrMinusS: CARDINAL = 2;  -- R - S  aFrOrS: CARDINAL = 3;  -- R or S  aFrAndS: CARDINAL = 4;  -- R and S  aFnotRandS: CARDINAL = 5;  -- ~R and S  aFrXorS: CARDINAL = 6;  -- R xor S  aFnotRxorS: CARDINAL = 7;  -- ~R xor S  -- The following values are for the aD field:  aDA: CARDINAL = 2;  aDB: CARDINAL = 3;  aDnoWrite: CARDINAL = 1;  -- The following values are for the cy field:  c1: CARDINAL = 1;  c2: CARDINAL = 2;  c3: CARDINAL = 3;  cX: CARDINAL = 4;  -- The following values are for the fX field:  fXRH: CARDINAL = 9;  -- assign to RH  fXshift: CARDINAL = 10;  fXcycle: CARDINAL = 11;  fXcinpc16: CARDINAL = 12;  fXMap: CARDINAL = 13;  -- The following values are for the fY field:  fYNegBr: CARDINAL = 0;  -- fY = DispBr  fYZeroBr: CARDINAL = 1;  -- fY = DispBr  fYNZeroBr: CARDINAL = 2;  -- fY = DispBr  fYPgCarryBr: CARDINAL = 4;  -- fY = DispBr  fYCarryBr: CARDINAL = 5;  -- fY = DispBr  fYXDisp: CARDINAL = 8;  -- fY = DispBr  fYYDisp: CARDINAL = 9;  -- fY = DispBr  fYPgCr: CARDINAL = 15;  -- fY = DispBr  fYDOAData: CARDINAL = 6;  -- fY = IOOut  fYDctl: CARDINAL = 7;  -- fY = IOOut  fYDOBData: CARDINAL = 8;  -- fY = IOOut  fYMctl: CARDINAL = 10;  -- fY = IOOut  fYIBDisp: CARDINAL = 3;  -- fY = norm , IBDisp  fYstackP: CARDINAL = 5;  -- fY = norm , stackP¬  fYib: CARDINAL = 6;  -- fY = norm , ib¬  fYcycle: CARDINAL = 7;  -- fY = norm , cycle  fYMap: CARDINAL = 9;  -- fY = norm , Map¬  -- The following values are for the fZ field:  fZIgnorePgCr: CARDINAL = 4;  -- Ignore PgCr   fZErrIBstkP: CARDINAL = 10;  -- assign from ErrIBstkP (IOXIn index)  fZRH: CARDINAL = 11;  -- assign from RH (IOXIn index)  fZib: CARDINAL = 13;  -- assign from ib (IOXIn index)  fZibLow: CARDINAL = 14;  -- assign from ibLow (IOXIn index)  fZibHigh: CARDINAL = 15;  -- assign from ibHigh (IOXIn index)  fZLRotLo: CARDINAL = 12;  -- fZ = norm  fZLRotHi: CARDINAL = 15;  -- fZ = norm  fZcinpc16: CARDINAL = 3;  noop: CARDINAL = 8;  -- for fXNorm, fYNorm, fZNorm  -- TYPE DECLARATIONS  Assignment: TYPE = RECORD [    -- This record is used to keep track of what causes a field assignment.  This allows us to print a meaningful error message when a field assignment conflicts.    element: SELECT type: * FROM      null => NULL,      expression => NULL,      macro => [macroIndex: MacroIndex],      register => [registerType: RegisterType],      ENDCASE];  BuiltinMacroType: TYPE = {    add, and, mul, or, xor  -- use Arith proc    , sub, lshift, rshift  -- use Arith2 proc    , goto, gotoabs, branch, cancelbr, disp2, disp3, disp4, dispni, ret  -- use Branch proc    , equal, greater, andZero  -- use If proc    , import, export  -- use External proc    , setConstant, setLabel  --use Set proc    , null  -- for other procs    };  Carry: TYPE = {zero, one, x};  DSource: TYPE = {    x, stk, u, uy, nibl, byte, ioInY, ioInZ, rh, rhm, mem, ib, ibLow, ibHigh,    lrot, zero, one};  DSourcePattern: TYPE = RECORD [dSource: DSource, pattern: Pattern];  ElementRec: TYPE = RECORD [    element: SELECT type: * FROM      name => [string: LONG STRING],      arrow => NULL,      partialArrow => NULL,      plus => NULL,      minus => NULL,      not => NULL,      logical => [logicalOperation: LogicalOperation],      register => [registerType: RegisterType, regnum: CARDINAL],      constant => [value: INTEGER],      variable => [val: INTEGER],      macro => [macroIndex: MacroIndex],      LRot => [macroIndex: MacroIndex],      link => [macroIndex: MacroIndex],      IOXIn => [IOInAddr: [0..16), fField: {y, z}],      arrowPhrase => NULL,      userMacro => [str: LONG STRING],      label => [str: LONG STRING, value: CARDINAL],      builtinMacro => [        proc: PROCEDURE [BuiltinMacroType] RETURNS [RetType],        type: BuiltinMacroType],      undefinedToken => NULL,      empty => NULL,      pc16 => [macroIndex: MacroIndex ¬ pc16index],      ENDCASE];  Encoding: TYPE = RECORD [    nextEncoding: EncodingPtr ¬ NIL,  -- points to next possible encoding of phrase;  NIL if no alternate.    rA: FieldAssignment ¬ [Assignment[null[]], 0],  -- 2901 A register address, Uaddr[0-3]    rB: FieldAssignment ¬ [Assignment[null[]], 0],  -- 2901 B register address, RH address    aS: FieldAssignment ¬ [Assignment[null[]], aS0B],  -- 2901 Source operands    aF: FieldAssignment ¬ [Assignment[null[]], aFrAndS],  -- 2901 Function control    aD: FieldAssignment ¬ [Assignment[null[]], aDnoWrite],  -- 2901 Destination control    cin: FieldAssignment ¬ [Assignment[null[]], 0],  -- 2901 Cin, Shift Ends, writeSU    enSU: FieldAssignment ¬ [Assignment[null[]], 0],  -- enableSU, nCycle    -- fS = fS01*4 + fS2*2 + fS3    mem: FieldAssignment ¬ [Assignment[null[]], 0],  -- memory op    ia7: FieldAssignment ¬ [Assignment[null[]], 0],  -- 0 for call, 1 for ret, else x    fS01: FieldAssignment ¬ [Assignment[null[]], fS01fYNorm],  -- 0-1 of fS: dispBr, fYNorm, IOOout, Byte    fS2: FieldAssignment ¬ [Assignment[null[]], fS2fZNorm],  -- bit 2 of fS: stackP, rAfZ, fZNorm, nibble, IOIn, uaddr    fS3: FieldAssignment ¬ [Assignment[null[]], fS3fZNorm],  -- bit 3 of fS: fZNorm, nibble, IOIn, uaddr    fX: FieldAssignment ¬ [Assignment[null[]], noop],  -- X Function field    fY: FieldAssignment ¬ [Assignment[null[]], noop],  -- Y Function field    fZ: FieldAssignment ¬ [Assignment[null[]], noop],  -- Z Function field    cy: FieldAssignment ¬ [Assignment[null[]], 0],  -- Cycle    -- The following fields are used to keep track of signals on the X and Y buses.  It is not OK to have more than one signal on a bus.  For example, if xOut is set, it cannot be set again by a different source.  We remember the source of the X bus signal in xBusSignalSource.  It is OK to have more than one input from a bus.  If there is an input from a bus, there must be an output to the bus.  For example, if xIn is set, then xOut must be set also in the final merged Encoding record.  The Y Bus could have more than one source: register A or the output of the ALU.  However, we do not check for more than one signal on the Y Bus.  This does not seem to be necessary.    wU: BOOLEAN ¬ FALSE,  -- U register to be written    xIn: BOOLEAN ¬ FALSE,  -- takes input from X bus    xOut: BOOLEAN ¬ FALSE,  -- puts signal on X bus    yIn: BOOLEAN ¬ FALSE,  -- takes input from Y bus    yOut: BOOLEAN ¬ FALSE,  -- puts signal on Y bus    aluIn: BOOLEAN ¬ FALSE,  -- takes signal from ALU    aluOut: BOOLEAN ¬ FALSE,  -- creates ALU output    RHref: {r, w, x} ¬ x,  -- RH referenced    assignBrequired: BOOLEAN ¬ FALSE,  -- assignment to rB required    assignB: BOOLEAN ¬ FALSE,  -- rB assigned    xbusLoad: BOOLEAN ¬ FALSE,  -- TRUE if destination is loaded from the Xbus    ybusLoad: BOOLEAN ¬ FALSE  -- TRUE if Y or F bus is stored    -- If the instruction puts A on the Y Bus (aD = 2), the output of the ALU is assigned to register B.  When aD = 2, we must be sure that the statement includes an assignment to rB.    ];  EncodingPtr: TYPE = LONG POINTER TO Encoding;  ErrorMsg: TYPE = RECORD [    nextMsg: ErrorMsgPtr,    msg: LONG STRING,  -- points to length    length: CARDINAL,    maxlength: CARDINAL];  -- followed by text  ErrorMsgPtr: TYPE = LONG POINTER TO ErrorMsg;  Expression: TYPE = RECORD [    operation: Operation ¬ x,    operand1: Operand ¬ x,    operand2: Operand ¬ x,    dSource: DSource ¬ x,    carry: Carry ¬ x];  ExpressionArgs: TYPE = RECORD [operand1: Operand, operand2: Operand];  ExpressionPattern: TYPE = RECORD [    expressionArgs: ExpressionArgs, pattern: Pattern];  ExpressionPatternPtr: TYPE = LONG POINTER TO ExpressionPattern;  FieldAssignment: TYPE = RECORD [assignment: Assignment, value: CARDINAL];  LogicalOperation: TYPE = {and, or, xor};  Macro: TYPE = RECORD [name: LONG STRING, value: CARDINAL [0..256)];  MacroIndex: TYPE = [0..256);  MacroPattern: TYPE = RECORD [macro: Macro, pattern: Pattern];  MacroPatternPtr: TYPE = LONG POINTER TO MacroPattern;  Operand: TYPE = {x, AB, Q, D, RHm, zero};  Operation: TYPE = {x, Nx, or, and, Nand, xor, Nxor, plus, minus};    passMultiSeg: TYPE = RECORD[PassFileHandle: MFile.Handle ¬ NIL,    PassSeg: MSegment.Handle,    PassSegPtr: LONG POINTER,    nextSeg: LONG POINTER TO passMultiSeg ¬ NIL];  passMultiSegPtr: TYPE = LONG POINTER TO passMultiSeg;  Pattern: TYPE = RECORD [    -- x means don't care.      -- t is for true (one), f is for false (zero)    rA: {x, a1, a2, aH} ¬ x,    rB: {x, a1, a2, aL} ¬ x,    -- a1 means arg1, a2 means arg2, aH means the high order four bits of arg, aL means the low order four bits of arg.    aS: {x, AQ, AB, ZQ, ZB, ZA, DA, DQ, DZ} ¬ x,    aF: {x, rPlusS, sMinusR, rMinusS, rOrS, rAndS, notRandS, rXorS, notRxorS} ¬ x,    cin: {x, t, f} ¬ x,  -- t is for true (one), f is for false (zero)    enSU: {x, t, f} ¬ x,  -- t is for true (one), f is for false (zero)    wU: {x, t} ¬ x,  -- t is for write U register    fS01: {x, byte, Disp, norm, IOut} ¬ x,    fS2: {x, stkP, norm, nibl, IOIn, uadr, byte} ¬ x,    fS3: {x, norm, nibl, IOIn, byte} ¬ x,    aD: {x, a1, A, B} ¬ x,    -- a1 is for arg1 (macro value), A means put A on the Y Bus, B means assign to register rB..    mem: {x, t, f} ¬ x,  -- t is for true (one), f is for false (zero)    fX: {x, a1, s, c, RH} ¬ x,    -- a1 is for arg1 (macro value), s is for  shift, c is for cycle, RH is for assign to RH.    fY: {x, a1, aH, aL, c} ¬ x,    fZ: {x, a1, aL, RH, ib, ibLow, ibHigh, lrot} ¬ x,    -- a1 means arg1, aL means the low order 4 bits of arg, RH means assign from RH, ib{Low/High} means assign from ib{Low/High}.    ia7: {x, t, f} ¬ x,  -- t means INIA7 = 1, f means INIA7 = 0    cy: {x, c1, c2, c3, cX} ¬ x,  -- Cycle    xIn: {t, f} ¬ f,  -- t means requires input from X bus    xOut: {t, f} ¬ f,  -- t means puts signal on X bus    yIn: {t, f} ¬ f,  -- t means requires input from Y bus    yOut: {t, f} ¬ f,  -- t means puts signal on Y bus    aluIn: {t, f} ¬ f,  -- t means requires input from ALU    RHref: {r, w, x} ¬ x,  -- r means RH read, w means RH written    xl: {t, f} ¬ f,  -- t means loaded from the X bus    yl: {t, f} ¬ f  -- t means loaded from the Y or F bus    ];  PatternPtr: TYPE = LONG POINTER TO Pattern;  Phrase: TYPE = RECORD [    nextPhrase: PhrasePtr ¬ NIL,  -- next phrase in stataement; NIL if end of statement    firstElement: PhraseElementPtr ¬ NIL,  -- points to first PhraseElement of phrase    currentElement: PhraseElementPtr ¬ NIL,  -- points to current PhraseElement of phrase being scanned by EncodePhrase    encoding: EncodingPtr ¬ NIL,  -- points to encoding for this phrase    expression: Expression ¬ [],  -- if this phrase has an expression, this will be filled in.    arg: CARDINAL ¬ 0,  -- used for constants and u addresses    arg1: CARDINAL ¬ 0,  -- used for expression, if any    arg2: CARDINAL ¬ 0,  -- used for expression, if any    syntaxError: BOOLEAN ¬ FALSE,    formatError: BOOLEAN ¬ FALSE,    ALRot: BOOLEAN ¬ FALSE,    XLRot: BOOLEAN ¬ FALSE,    tempErrorMsgs: ErrorMsgPtr ¬ NIL,    errorMsgs: ErrorMsgPtr ¬ NIL    -- When format errors are encountered, they are chained onto tempErrorMsgs.  If a pattern is found that works, this list will be deleted; otherwise it will be chained onto errorMsgs.    ];  PhrasePtr: TYPE = LONG POINTER TO Phrase;  PhraseElement: TYPE = RECORD [    nextElement: PhraseElementPtr,  -- next element in phrase;  NIL if end of phrase    elementRec: ElementRec];  PhraseElementPtr: TYPE = LONG POINTER TO PhraseElement;    RegisterType: TYPE = {R, RH, RHm, U, UY, STK, Q, MD, bus};  -- bus is []    Statement: TYPE = RECORD [    firstPhrase: PhrasePtr ¬ NIL,    encoding: EncodingPtr ¬ NIL,    syntaxError: BOOLEAN ¬ FALSE,    formatError: BOOLEAN ¬ FALSE];  StatementPtr: TYPE = LONG POINTER TO Statement;    stmtMultiSeg: TYPE = RECORD[StmtFileHandle: MFile.Handle ¬ NIL,    StmtSeg: MSegment.Handle,    StmtSegPtr: LONG POINTER,    nextSeg: LONG POINTER TO stmtMultiSeg ¬ NIL];  stmtMultiSegPtr: TYPE = LONG POINTER TO stmtMultiSeg;    SyntaxErrorCode: TYPE = {    invalidExpression, arrowMissing, noRHS, unexpectedLHS, operationMissing,    missingPlusOrMinus, unexpectedRHS, invalidSecondOperand, doubleNot,    oneMissing, invalidPlus, invalidMinus, noOperand, endOfPhrase, multipleLRot,    noLRotExpression};  lrotSize: CARDINAL = 4;  linkSize: CARDINAL = 12;  apassindex: CARDINAL = 12;  pc16index: CARDINAL = 13;  macroTableSize: CARDINAL = 145;  macroTable: LONG POINTER TO ARRAY [0..macroTableSize) OF MacroPattern;  patternAssignR: Pattern;  patternAssignRH: Pattern;  patternAssignU: Pattern;  patternAssignUY: Pattern;  patternCin0: Pattern;  patternCin1: Pattern;  --PROCEDURES  AllocateEncodingRecord: PROCEDURE RETURNS [encoding: EncodingPtr];  -- in EncodePatternProcs  ArithmeticOperation: PROCEDURE [operation: CARDINAL]    RETURNS [arithmetic: BOOLEAN];  --  in Merge  AssignBrequired: PROCEDURE [phrase: PhrasePtr];  -- in EncodeErrors  BusConflict: PROCEDURE [phrase: PhrasePtr, busName: LONG STRING];  -- in EncodeErrors  BusMismatch: PROCEDURE [phrase: PhrasePtr, busName: LONG STRING];  -- in EncodeErrors  CreatePassSegment: PROCEDURE;   --in TempSpaceImpl  CreateStmtSegment: PROCEDURE;  DeletePassSegment: PROCEDURE;     DeleteStmtSegment: PROCEDURE;    EncodePattern: PROCEDURE [    phrase: PhrasePtr, pattern: PatternPtr, encoding: EncodingPtr,    assignment: Assignment] RETURNS [successful: BOOLEAN];  -- in EncodePatternProcs  EncodeStatement: PROCEDURE [statement: StatementPtr]    RETURNS [successful: BOOLEAN];  -- in Encode  FieldaD: PROCEDURE [PhrasePtr, EncodingPtr, Assignment, CARDINAL]    RETURNS [BOOLEAN];  -- in EncodePatternProcs  FormatError: PROCEDURE [    phrase: PhrasePtr, assignment1, assignment2: Assignment,    fieldName: LONG STRING];  -- in EncodeErrors     FreePassSpace: PROCEDURE;   --in TempSpaceImpl  FreeStmtSpace: PROCEDURE;    GetPassSpace: PROCEDURE[nWords: CARDINAL] RETURNS [LONG POINTER];  GetStmtSpace: PROCEDURE[nWords: CARDINAL] RETURNS [LONG POINTER];  GetTiming: PROCEDURE [e: EncodingPtr] RETURNS [timingok: BOOLEAN];  -- in MassTime    InvalidLRotPath: PROCEDURE [phrase: PhrasePtr];  -- in EncodeErrors  MakeTempErrorMsgsPermanent: PROCEDURE [phrase: PhrasePtr];  -- in EncodeErrors  MultipleReference: PROCEDURE [phrase: PhrasePtr, name: LONG STRING];  -- in EncodeErrors  NoLRotDestination: PROCEDURE [phrase: PhrasePtr];  -- in EncodeErrors  PrintStatementErrorMsgs: PROCEDURE [statement: StatementPtr];  -- in EncodeErrors  MergeStatementEncoding: PROCEDURE [statement: StatementPtr]    RETURNS [successful: BOOLEAN];  -- in Merge  LRotConflict: PROCEDURE [phrase: PhrasePtr];  -- in EncodeErrors  SyntaxError: PROCEDURE [phrase: PhrasePtr, code: SyntaxErrorCode];  -- in EncodeErrors  UaddressConflict: PROCEDURE [phrase: PhrasePtr];  -- in EncodeErrors  WriteUConflict: PROCEDURE [phrase: PhrasePtr];  -- in EncodeErrors  -- constants  maxArgLength: CARDINAL = 56;  maxStringLength: CARDINAL = 400;  sizeArgArray: CARDINAL = 11;  version: LONG STRING;  -- characters  EofChar: CHARACTER = 004C;  NUL: CHARACTER = 0C;  semiChar: CHARACTER = ';;  -- character arrays  CharOf: ARRAY [0..9] OF CHARACTER = ['0, '1, '2, '3, '4, '5, '6, '7, '8, '9];  -- structures  Flagword: TYPE = RECORD [    FirstChar: BOOLEAN ¬ TRUE,    ArrowClause: BOOLEAN ¬ FALSE,    HasArgs: BOOLEAN ¬ FALSE,    LeadDigit: BOOLEAN ¬ FALSE,    LeadBrkt: BOOLEAN ¬ FALSE,    Semi: BOOLEAN ¬ FALSE,    Label: BOOLEAN ¬ FALSE,    Error: BOOLEAN ¬ FALSE,    Eof: BOOLEAN ¬ FALSE];  MEntry: TYPE = RECORD [    key: LONG STRING, ptr: LONG POINTER TO ElementRec, next: MEntryPtr];  MEntryPtr: TYPE = LONG POINTER TO MEntry;  MyString: TYPE = RECORD [NextChar: CARDINAL, String: LONG STRING];  MyStringPtr: TYPE = LONG POINTER TO MyString;  RetType: TYPE = RECORD [    Type: SELECT Element: * FROM      Value => [val: INTEGER],      Text => [txt: LONG STRING],      Null => NULL,      Error => NULL,      ENDCASE];            -- A statement consists of a list of Phrase records and a list of Encoding records.  The Encoding record represents how the Statement will be encoded into fields of the microinstruction.    -- A Phrase represents the text in a statement between commas.  Each Phrase consists of a list of PhraseElement records and a list of Encoding records.  A PhraseElement represents an element of a Phrase such as a U Register, a "+" operation, a constant, etc.  The Encoding record represents how the Phrase will be encoded into fields of the microinstruction.  There will be more than one Encoding record if the Phrase has more than one possible way of being encoded.    <<		     Statement     	  | firstPhrase  |---  | encoding     |  |    |	   |    |	   |    |	   |    |               V   Phrase       			     Phrase        	    |  	|  nextPhrase    |------------->	|    nextPhrase   |    |	|  firstElement  |--------	|	|                 |    |	|  encoding      |-----	|	|	|                 |    |		|	|    | 		|	|       PhraseElement   	  PhraseElement  	    |		|	|--->	|   nextElement  |----->	|  nextElement  |    |		|		|                |	|               |    |		|		|                |	|               |    |		|		|                |	|               |    V  Encoding     	|  |  nextEncoding  |	|		   Encoding       	   Encoding      	  |                |	|----->	|  nextEncoding  |------>	|  nextEncoding  |  |                |			|                |	|                |  |                |			|                |	|                |  |                |			|                |	|                |				|                |	|                |>>  END...    -- Log  -- 16-Jul-82 10:13:34 - ETN        - TrinityMass Version 1  -- 14-Jul-83 11:28:37 - JAC        - Eliminate tempHeap procedures  --  8-Aug-83 17:40:11 - JAC        - Added File Handles to backup Stmt and Pass segments  -- 12-Aug-83  9:29:47 - JAC        - Made version a long string consisting of the date and time instead of a cardinal   -- 26-Sep-84 21:14:52 -  DEG     	Action: Added copyright notice and rebuild for 11.1 release.  --  6-Nov-85 15:31:46 - JAC        - added setConstant and setLabel to BuiltinMacroType
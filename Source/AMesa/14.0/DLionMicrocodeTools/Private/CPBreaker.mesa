-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CPBreaker.mesa, HGM,  7-Nov-83 17:12:44DIRECTORY  Heap USING [systemZone],  String USING [AppendNumber, AppendString],    CP USING [Cycle, RealCS, Task],  CPMI USING [MI],  CPBreak USING [],  CPKernel USING [    AtBreak, Error, GetBreakID, InKernel, maxBreaks, ReadCS, SetBreak, WriteCS, WriteTpc];CPBreaker: MONITOR  IMPORTS Heap, String, CPKernel  EXPORTS CPBreak =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    head: Breakpoint ¬ NIL;  breaksInstalled: BOOLEAN ¬ FALSE;    lastBreakInfo: RECORD [location: CP.RealCS, cycle: CP.Cycle, task: CP.Task, mi: CPMI.MI];    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;    Breakpoint: TYPE = LONG POINTER TO  BreakpointInfo;  BreakpointInfo: TYPE = RECORD [    location: CP.RealCS,    mi: CPMI.MI,    cycle: CP.Cycle,    task: CP.Task,    next: Breakpoint];    Break: PUBLIC ENTRY PROCEDURE [location: CP.RealCS, cycle: CP.Cycle, task: CP.Task] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    new: Breakpoint;    id: CARDINAL ¬ 1;  -- The one we want to add    BeSureInKernel[];    RemoveBreaksInternal[];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF finger.location = location THEN ERROR Error["Breakpoint already set there"L];      id ¬ id + 1;      ENDLOOP;    IF id >= CPKernel.maxBreaks THEN ERROR Error["Too many breakpoints"L];    new ¬ z.NEW[BreakpointInfo];    new­ ¬ [location, CPKernel.ReadCS[location], cycle, task, head];    head ¬ new;    END;	    Unbreak: PUBLIC ENTRY PROCEDURE [location: CP.RealCS, cycle: CP.Cycle, task: CP.Task] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    previous: Breakpoint ¬ NIL;    BeSureInKernel[];    RemoveBreaksInternal[];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF finger.location = location THEN        BEGIN	temp: Breakpoint ¬ finger;  -- Rats, can't smash LOOP control variable	IF cycle # finger.cycle OR task # finger.task THEN	  ERROR Error["Cycle/Task confusion"L];	IF previous = NIL THEN head ¬ finger.next	ELSE previous.next ¬ finger.next;	z.FREE[@temp];	RETURN;	END;      previous ¬ finger;      ENDLOOP;    ERROR Error["Breakpoint not found"L];    END;    Reset: PUBLIC ENTRY PROCEDURE =    BEGIN    Smash[];    END;    ClearAllBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    BeSureInKernel[];    Smash[];    END;  Smash: INTERNAL PROCEDURE =    BEGIN    breaksInstalled ¬ FALSE;    UNTIL head = NIL DO      temp: Breakpoint ¬ head;      head ¬ head.next;      z.FREE[@temp];      ENDLOOP;    END;  EnumerateBreaks: PUBLIC ENTRY PROCEDURE [proc: PROCEDURE[CP.RealCS, CP.Cycle, CP.Task]] =    BEGIN ENABLE UNWIND => NULL;    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      proc[finger.location, finger.cycle, finger.task];      ENDLOOP;    END;    InstallBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    id: CARDINAL ¬ 0;    BeSureInKernel[];    IF breaksInstalled THEN RETURN;    breaksInstalled ¬ TRUE;    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      finger.mi ¬ CPKernel.ReadCS[finger.location];      CPKernel.SetBreak[finger.location, finger.cycle, id];      id ¬ id + 1;      ENDLOOP;    IF id >= CPKernel.maxBreaks THEN ERROR;    END;    BreakStillSet: PUBLIC ENTRY PROCEDURE [    location: CP.RealCS, cycle: CP.Cycle, task: CP.Task, mi: CPMI.MI] RETURNS [BOOLEAN] =    BEGIN ENABLE      BEGIN      CPKernel.Error => ERROR Error[reason];      UNWIND => NULL;      END;    BeSureInKernel[];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF finger.location # location THEN LOOP;      IF finger.cycle # cycle OR finger.task # task THEN ERROR;      RETURN[TRUE];      ENDLOOP;    RETURN[FALSE];    END;    RemoveBreaks: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    RemoveBreaksInternal[];    END;    RemoveBreaksInternal: INTERNAL PROCEDURE =    BEGIN ENABLE CPKernel.Error => ERROR Error[reason];    id: CARDINAL ¬ 0;    currentBreakID: CARDINAL ¬ nullBreakID;    nullBreakID: CARDINAL = LAST[CARDINAL];    BeSureInKernel[];    IF ~breaksInstalled THEN RETURN;    breaksInstalled ¬ FALSE;    IF CPKernel.AtBreak[] THEN currentBreakID ¬ CPKernel.GetBreakID[];    FOR finger: Breakpoint ¬ head, finger.next UNTIL finger = NIL DO      IF id = currentBreakID THEN        BEGIN  -- In case it gets deleted	lastBreakInfo ¬ [finger.location, finger.cycle, finger.task, finger.mi];	currentBreakID ¬ nullBreakID;	CPKernel.WriteTpc[finger.task, finger.location];	END;      CPKernel.WriteCS[finger.location, finger.mi];      id ¬ id + 1;      ENDLOOP;    IF currentBreakID # nullBreakID THEN      BEGIN      text: STRING = [200];      String.AppendString[text, "Breakpoint confusion -- break probably hit on wrong cycle. ID = "L];      String.AppendNumber[text, currentBreakID, 16];      ERROR Error[text];      END;    END;    GetLastBreakInfo: PUBLIC PROCEDURE RETURNS [CP.RealCS, CP.Cycle, CP.Task, CPMI.MI] =    BEGIN    RemoveBreaks[];    RETURN[lastBreakInfo.location, lastBreakInfo.cycle, lastBreakInfo.task, lastBreakInfo.mi];    END;    BeSureInKernel: INTERNAL PROCEDURE =    BEGIN    IF ~CPKernel.InKernel[] THEN ERROR Error["Can't adjust breaks while running (or crashed)"L];    END;    END.
-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- AssInputOps.mesa-- Last edited by DEG      26-Sep-84 22:55:08  -  See log at endDIRECTORY  AssInputDefs USING [MaxIdLen],  CodeOutputDefs USING [AddToRelocChain, GetPC, GetBinaryStreamIndex],  ExpressionDefs USING [    ConstructReversePolishStack, EvalResult, EvaluateReversePolishStack,    StackItem],  Heap USING [systemZone],  Inline USING [BITAND],  ListOutputDefs USING [WriteToListing],  NewStateDefs USING [OpType, Operation, ArgType, MemoryAddress],  PrivateStorage USING [heapPointer],  PrivateStringDefs USING [CopyString],  Stream USING [EndOfStream, GetChar, GetPosition, Handle, Position, SetPosition],  String USING [AppendChar, StringToNumber, StringToOctal],  SymbolTableDefs USING [    STData, OTData, RTData, LookUpInSymbolTable, LookUpInOpTable,    LookUpInRegTable, PutInSymbolTable],  SymTabIODefs USING [AddToUnfinishedChain, ProcessUnfinishedChain];AssInputOps: PROGRAM  IMPORTS    CodeOutputDefs, ExpressionDefs, Heap, Inline, ListOutputDefs,    PrivateStorage, PrivateStringDefs, Stream, String, SymbolTableDefs,    SymTabIODefs  EXPORTS AssInputDefs =  BEGIN  AssErr: PUBLIC SIGNAL [Code: CARDINAL] = CODE;  InputStream: Stream.Handle;  SourceLine: LONG STRING;  GlobalWordBuffer: LONG STRING;  char: CHARACTER;  CurrentLineSI: Stream.Position;  firstchar, relocFlag: BOOLEAN;  StartOfLine: PUBLIC PROCEDURE RETURNS [BOOLEAN] =    BEGIN    DO      SELECT char FROM        ' , '\N, '\T => char ¬ NextCh[];        ENDCASE => RETURN[firstchar];      ENDLOOP;    END;  StreamIndexOfCurrentLine: PUBLIC PROCEDURE RETURNS [Stream.Position] =    BEGIN RETURN[CurrentLineSI]; END;  NextChar: PUBLIC PROCEDURE RETURNS [CHARACTER] =    BEGIN char ¬ NextCh[]; RETURN[char]; END;  NextCh: PROCEDURE RETURNS [CHARACTER] =    BEGIN    c: CHARACTER;    zFlag: BOOLEAN ¬ FALSE;    ControlZ: CHARACTER = '\026;    IF SourceLine.length ~= 0 AND SourceLine[SourceLine.length - 1] = '\N      THEN ListOutputDefs.WriteToListing[SourceLine];    firstchar ¬ char = '\N;    IF firstchar THEN CurrentLineSI ¬ Stream.GetPosition[InputStream];    c ¬ getandcheck[InputStream, FALSE];    WHILE c = '{ DO      DO c ¬ NextChar[]; IF c = '} THEN EXIT; ENDLOOP;      c ¬ getandcheck[InputStream, FALSE];      ENDLOOP;    WHILE c = ControlZ OR c = '; DO      IF c = ControlZ THEN        BEGIN        zFlag ¬ TRUE;  -- Set flag for getandcheck        SourceLine.length ¬ SourceLine.length - 1;  -- Flush the ControlZ        END;      c ¬ getandcheck[InputStream, zFlag];      WHILE c # '\N DO        IF c = ControlZ THEN          BEGIN          zFlag ¬ TRUE;  -- Set flag for getandcheck          SourceLine.length ¬ SourceLine.length - 1;  -- Flush the ControlZ          END;        c ¬ getandcheck[InputStream, zFlag];        ENDLOOP;      -- Bravo formatting has been flushed, last CR inserted.  Clear zFlag.      zFlag ¬ FALSE;      ENDLOOP;    RETURN[c];    END;  getandcheck: PROCEDURE [s: Stream.Handle, flag: BOOLEAN] RETURNS [c: CHARACTER] =    BEGIN    c ¬ Stream.GetChar[sH: s ! Stream.EndOfStream =>      {String.AppendChar[SourceLine, '\N];      ListOutputDefs.WriteToListing[SourceLine];      char ¬ c ¬ '\N;      REJECT}];    IF flag AND (c # '\N) AND (c # '}) THEN RETURN[c];  -- Not Bravo formatting information.    String.AppendChar[SourceLine, c];    IF (SourceLine.length < 105) OR (c = '\N) OR (c = '}) THEN      NULL    ELSE      BEGIN      String.AppendChar[s: SourceLine, c: '\N];      ListOutputDefs.WriteToListing[SourceLine];      END;    RETURN[c];    END;  CurrentChar: PUBLIC PROCEDURE RETURNS [CHARACTER] = BEGIN RETURN[char]; END;  MakeWord: PUBLIC PROCEDURE RETURNS [LONG STRING] =    BEGIN    WHILE char = '  OR char = '\T OR char = '\N DO      char ¬ NextCh[]; ENDLOOP;    GlobalWordBuffer.length ¬ 0;    WHILE char IN ['0..'9] OR char IN ['a..'z] OR char IN ['A..'Z] DO      IF GlobalWordBuffer.length < AssInputDefs.MaxIdLen THEN        String.AppendChar[GlobalWordBuffer, char];      char ¬ NextCh[! Stream.EndOfStream => GOTO exit];      ENDLOOP;    RETURN[GlobalWordBuffer];    EXITS      exit => RETURN[GlobalWordBuffer];    END;  MakeNumber: PUBLIC PROCEDURE RETURNS [v: CARDINAL] =    BEGIN    s: LONG STRING ¬ MakeWord[];    IF s[s.length - 1] IN ['0..'9] THEN v ¬ String.StringToNumber[s: s, radix: 10]    ELSE      BEGIN      s.length ¬ s.length - 1;      SELECT s[s.length] FROM        'B, 'b => v ¬ String.StringToOctal[s];        'X, 'x, 'H, 'h => v ¬ StringToHex[s];        ENDCASE => SIGNAL AssErr[5];      END;    RETURN[v];    END;  StringToHex: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [v: CARDINAL ¬ 0] =    BEGIN    FOR i: CARDINAL IN [0..s.length) DO      SELECT s[i] FROM        IN ['0..'9] => v ¬ v*16 + s[i] - '0;        IN ['A..'F] => v ¬ v*16 + s[i] - 'A + 10;        IN ['a..'f] => v ¬ v*16 + s[i] - 'a + 10;        ENDCASE => SIGNAL AssErr[5];      ENDLOOP;    END;  Capitalize: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [LONG STRING] =    BEGIN    FOR i: CARDINAL IN [0..s.length) DO      IF s[i] IN ['a..'z] THEN s[i] ¬ (s[i] - 'a) + 'A; ENDLOOP;    RETURN[s];    END;  GetOctalNumber: PUBLIC PROCEDURE RETURNS [CARDINAL] =    BEGIN RETURN[MakeNumber[]]; END;  GetType: PUBLIC PROCEDURE RETURNS [NewStateDefs.OpType] =    BEGIN RETURN[LOOPHOLE[MakeNumber[]]]; END;  GetLabel: PUBLIC PROCEDURE RETURNS [w: LONG STRING] =    BEGIN    Lab: LONG POINTER TO SymbolTableDefs.STData;    pc: NewStateDefs.MemoryAddress ¬ CodeOutputDefs.GetPC[];    w ¬ PrivateStorage.heapPointer.NEW[StringBody[AssInputDefs.MaxIdLen]];    PrivateStringDefs.CopyString[w, MakeWord[]];    IF char # ': AND char # '  AND char # '\T AND char # '\N THEN      SIGNAL AssErr[0];    DO      char ¬ NextCh[];      SELECT char FROM ' , '\N, '\T => NULL; ENDCASE => EXIT;      ENDLOOP;    Lab ¬ SymbolTableDefs.LookUpInSymbolTable[w];    IF Lab = NIL THEN      [] ¬ SymbolTableDefs.PutInSymbolTable[        w, [IOPmain[pc]], DefSym, internal, relocFlag, FALSE,        CodeOutputDefs.GetPC[], 0, CodeOutputDefs.GetBinaryStreamIndex[]]    ELSE      BEGIN      IF Lab.extern = imported THEN SIGNAL AssErr[19];      IF Lab.type # UnDef THEN SIGNAL AssErr[1];      WITH x: Lab.val SELECT FROM IOPmain => x.addr ¬ pc; ENDCASE => ERROR;      Lab.type ¬ DefSym;      Lab.reloc ¬ relocFlag;      SymTabIODefs.ProcessUnfinishedChain[Lab];      END;    RETURN[w];    END;  GetOp: PUBLIC PROCEDURE RETURNS [NewStateDefs.Operation] =    BEGIN    ote: LONG POINTER TO SymbolTableDefs.OTData;    ote ¬ SymbolTableDefs.LookUpInOpTable[Capitalize[MakeWord[]]];    IF ote = NIL OR ote.type NOT IN [Type1..rst] THEN SIGNAL AssErr[3];    RETURN[[ote.val, ote.type]];    END;  GetArg: PUBLIC PROCEDURE [at: NewStateDefs.ArgType] RETURNS [CARDINAL] =    BEGIN    RTE: LONG POINTER TO SymbolTableDefs.RTData;    regval: CARDINAL;    RPS: LONG POINTER TO ExpressionDefs.StackItem;    EvalRes: ExpressionDefs.EvalResult;    SELECT at FROM      regpr, reg =>        BEGIN        RTE ¬ SymbolTableDefs.LookUpInRegTable[Capitalize[MakeWord[]]];        IF RTE = NIL OR RTE.type NOT IN [reg..regpair] THEN SIGNAL AssErr[6];        regval ¬          WITH x: RTE.val SELECT FROM            IOPregister => LOOPHOLE[x.reg],            IOPmain => 0,            ENDCASE => ERROR;        IF at = regpr THEN RETURN[regval/2] ELSE RETURN[regval];        END;      byte, word =>        BEGIN        RPS ¬ ExpressionDefs.ConstructReversePolishStack[          IF at = byte THEN 1 ELSE 2];        EvalRes ¬ ExpressionDefs.EvaluateReversePolishStack[RPS];        WITH EvalRes SELECT FROM          TRUE =>            BEGIN            IF at = byte THEN              BEGIN              IF res.r THEN SIGNAL AssErr[12];              res.v ¬ Inline.BITAND[res.v, 377B];              END            ELSE              IF res.r THEN                CodeOutputDefs.AddToRelocChain[CodeOutputDefs.GetPC[]];            RETURN[res.v];            END;          FALSE =>            SymTabIODefs.AddToUnfinishedChain[              RPS, id, IF at = byte THEN 1 ELSE 2, CodeOutputDefs.GetPC[]];          ENDCASE;        END;      ENDCASE => NULL;    RETURN[0];    END;  GetStringArg: PUBLIC PROCEDURE RETURNS [s: LONG STRING] =    BEGIN    IF char # '" THEN SIGNAL AssErr[4];    char ¬ NextCh[];    s ¬ PrivateStorage.heapPointer.NEW[StringBody[64]];    DO  -- forever      String.AppendChar[s, char];      char ¬ NextCh[];      IF char = '" THEN BEGIN char ¬ NextCh[]; EXIT; END;      ENDLOOP;    RETURN[s];    END;  SetChar: PUBLIC PROCEDURE [c: CHARACTER] = BEGIN char ¬ c; END;  SetInputStream: PUBLIC PROCEDURE [s: Stream.Handle] =    BEGIN    Stream.SetPosition[sH: s, position: CurrentLineSI ¬ 0];    InputStream ¬ s;    END;  RestoreInputStream: PUBLIC PROCEDURE [s: Stream.Handle] =    BEGIN InputStream ¬ s; END;  TurnOffReloc: PUBLIC PROCEDURE = BEGIN relocFlag ¬ FALSE; END;  GetRelocFlag: PUBLIC PROCEDURE RETURNS [BOOLEAN] = BEGIN RETURN[relocFlag]; END;  ReInit: PUBLIC PROC =    BEGIN    char ¬ '\N;    CurrentLineSI ¬ 0;    firstchar ¬ relocFlag ¬ TRUE;    InputStream ¬ NIL;    END;  Init: PROCEDURE =    BEGIN    SourceLine ¬ Heap.systemZone.NEW[StringBody[200]];    char ¬ '\N;    GlobalWordBuffer ¬ Heap.systemZone.NEW[StringBody[AssInputDefs.MaxIdLen]];    CurrentLineSI ¬ 0;    firstchar ¬ relocFlag ¬ TRUE;    InputStream ¬ NIL;    END;  Init[];  END.-- LOG:--  5-Apr-82 10:37:11 ETN         - Convert to Trinity.-- 25-Jan-83 13:16:12 ETN         - Sierra. Heap.systemZone.NEW => Storage.String-- 30-May-83 15:39:34 DEG     	  - Remove references to the Ascii interface.--  8-Oct-83  1:41:54 DEG         - fix EndOfStream bug.-- Time: 26-Sep-84 22:55:04	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
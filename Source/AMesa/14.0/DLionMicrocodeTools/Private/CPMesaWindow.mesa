-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CPMesaWindow.mesa, HGM, 26-May-83 16:06:04-- Please don't forget to update the herald...DIRECTORY  Environment USING [Long],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem, newLine, ProcType],  Inline USING [BITAND, HighByte, LowByte],  Put USING [CR, Line, Number, Text],  TextSW USING [ForceOutput],  Tool USING [Create, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle],    CP USING [UReg],  CPKernel USING [Error, InKernel, ReadUReg, ReadVirturalMemory],  CPSymbols USING [Error, Eval, Symbol];CPMesaWindow: PROGRAM  IMPORTS    FormSW, Inline, Put, TextSW, Tool, UserInput,    CPKernel, CPSymbols =  BEGIN    log, form: Window.Handle ¬ NIL;   DispStack: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        PostMessage["Oops, "L];        TailMessage[reason];        CONTINUE;        END;      CPSymbols.Error => CONTINUE;      END;    uMDS, uPSB, uGF, uLF: CP.UReg;    mds: WORD;    psb, gf, lf: ORDERED POINTER;    IF ~CPKernel.InKernel[] THEN      ERROR CPKernel.Error["Can't poke around while CP not in Kernel"L];    Put.CR[log];    Put.Text[log, "Display Stack: "L];    uMDS ¬ FindUReg["UvMDS"L];    uPSB ¬ FindUReg["uPSB"L];    uGF ¬ FindUReg["UvG"L];    uLF ¬ FindUReg["UvL"L];    mds ¬ ReadUReg[uMDS];    psb ¬ ReadUReg[uPSB];    gf ¬ ReadUReg[uGF];    lf ¬ ReadUReg[uLF];    Put.Text[log, "MDS="L];    Put.Number[log, mds, [16,FALSE,TRUE,0]];    Put.Text[log, ", PSB="L];    Put.Number[log, psb, [16,FALSE,TRUE,0]];    Put.Text[log, ", GF="L];    Put.Number[log, gf, [16,FALSE,TRUE,0]];    Put.Text[log, ", LF="L];    Put.Number[log, lf, [16,FALSE,TRUE,0]];    Put.CR[log];    Put.Line[log, "LF-4/  FSI  RET   GF   PC"L];    FOR i: CARDINAL IN [0..100) UNTIL UserInput.UserAbort[log] DO      IF lf = NIL OR Inline.BITAND[lf, 3] # 0 THEN EXIT;      Put.Number[log, lf-4, [16,FALSE,TRUE,4]];      Put.Text[log, "/"L];      FOR p: ORDERED POINTER ¬ lf - 4, p + 1 UNTIL p > lf + 3 DO        Put.Number[log, ReadMemory[p, mds], [16,FALSE,TRUE,5]];        ENDLOOP;      lf ¬ ReadMemory[lf-3, mds];      Put.CR[log];      ENDLOOP;    END;   ListProc: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        PostMessage["Oops, "L];        TailMessage[reason];        CONTINUE;        END;      END;    uPTC: CP.UReg;    pdaMds: CARDINAL = 1;    firstProcess: CARDINAL = 20B;    pdaCount: POINTER = LOOPHOLE[1];    pdaTimers: POINTER = LOOPHOLE[2];    stateVectors: POINTER = LOOPHOLE[8];    count: CARDINAL;    timers: POINTER;    now: CARDINAL;    psb: ORDERED POINTER ¬ LOOPHOLE[firstProcess*4];    IF ~CPKernel.InKernel[] THEN      ERROR CPKernel.Error["Can't poke around while CP not in Kernel"L];    Put.CR[log];    Put.Text[log, "List Processes: "L];    uPTC ¬ FindUReg["uPTC"L];    now ¬ ReadUReg[uPTC];    count ¬ ReadMemory[pdaCount, pdaMds];    timers ¬ ReadMemory[pdaTimers, pdaMds];    Put.Text[log, "uPTC="L];    Put.Number[log, now, [16,FALSE,TRUE,0]];    Put.Text[log, ", Count="L];    Put.Number[log, count, [16,FALSE,TRUE,0]];    Put.Text[log, ", timers="L];    Put.Number[log, timers, [16,FALSE,TRUE,0]];    Put.CR[log];    Put.Text[log, "SV="L];    FOR i: CARDINAL IN [0..8) DO      Put.Number[log, ReadMemory[stateVectors+i, pdaMds], [16,FALSE,TRUE,5]];      ENDLOOP;    Put.CR[log];    timers ¬ timers + firstProcess;    Put.Line[log, " PSB Time link flag  CTX  MDS"L];    FOR i: CARDINAL IN [0..count) UNTIL UserInput.UserAbort[log] DO      time, link, flags, mds: WORD;      context: POINTER ¬ ReadMemory[psb+2, pdaMds];      IF context = NIL THEN BEGIN psb ¬ psb + 4; LOOP; END;      Put.Number[log, psb, [16,FALSE,TRUE,4]];      time ¬ ReadMemory[timers + i, pdaMds];      IF time = 0 THEN Put.Text[log, "     "L]      ELSE Put.Number[log, time-now, [16,FALSE,TRUE,5]];      link ¬ ReadMemory[psb+0, pdaMds];      flags ¬ ReadMemory[psb+1, pdaMds];      mds ¬ ReadMemory[psb+3, pdaMds];      Put.Number[log, link, [16,FALSE,TRUE,5]];      Put.Number[log, flags, [16,FALSE,TRUE,5]];      Put.Number[log, context, [16,FALSE,TRUE,5]];      Put.Number[log, mds, [16,FALSE,TRUE,5]];      IF Inline.BITAND[link, 1] # 0 THEN        BEGIN  -- context is a state vector	insAndStackP: WORD = ReadMemory[context+14, pdaMds];	instByte: WORD = Inline.HighByte[insAndStackP];	stackP: WORD = Inline.LowByte[insAndStackP];	IF instByte # 0 THEN	  BEGIN          Put.Text[log, "  InstByte="L];          Put.Number[log, instByte, [16,FALSE,TRUE,0]];	  END;	IF stackP # 0 THEN	  BEGIN          Put.Text[log, "  StackP="L];          Put.Number[log, instByte, [16,FALSE,TRUE,0]];          Put.CR[log];          Put.Text[log, "         "L];	  FOR i: CARDINAL IN [0..stackP) DO            Put.Number[log, ReadMemory[context+i, pdaMds], [16,FALSE,TRUE,5]];	    ENDLOOP;	  END	ELSE Put.Text[log, "   Stack Empty"L];        Put.CR[log];        Put.Text[log, "         "L];	FOR i: CARDINAL IN [15..20) DO          Put.Number[log, ReadMemory[context+i, pdaMds], [16,FALSE,TRUE,5]];	  ENDLOOP;	END;      psb ¬ psb + 4;      Put.CR[log];      ENDLOOP;    END;   FindUReg: PROCEDURE [s: LONG STRING] RETURNS [u: CP.UReg] =    BEGIN    value: CPSymbols.Symbol;    value ¬ CPSymbols.Eval[s !      CPSymbols.Error =>        BEGIN        PostMessage["Can't find "L];        PostMessage[s];        PostMessage[" in symbol table: "L];        TailMessage[reason];	-- Let Error go up the stack        END];    WITH value SELECT FROM      uReg => RETURN[u];      ENDCASE =>        BEGIN        PostMessage[s];        PostMessage[" isn't a U Register"L];	ERROR CPSymbols.Error[NIL];	END;    END;  ReadUReg: PROCEDURE [u: CP.UReg] RETURNS [UNSPECIFIED] =    BEGIN    RETURN[CPKernel.ReadUReg[u]];    END;    ReadMemory: PROCEDURE [where: POINTER, mds: CARDINAL] RETURNS [UNSPECIFIED] =    BEGIN    long: Environment.Long ¬ [any[low: where, high: mds]];    RETURN[CPKernel.ReadVirturalMemory[long.lp]];    END;  PostMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.CR[log];    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    Put.Line[log, "."L];    TextSW.ForceOutput[log]    END;    Initialize: PROCEDURE =    BEGIN    herald: STRING = "CP Mesa of 26-May-83 16:06:01"L;    [] ¬ Tool.Create[      name: herald,      cmSection: "CP Mesa"L,      initialState: inactive,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    Tool.UnusedLogName[logFileName, "CPMesa.log$"L];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    log ¬ Tool.MakeFileSW[window: window, name: logFileName, h: 100];    END;    MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 2;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[0] ¬ FormSW.CommandItem[tag: "DispStack"L, proc: DispStack, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "ListProc"L, proc: ListProc];    RETURN[items, TRUE];    END;       ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN        END;      ENDCASE;    END;	  Initialize[];  END.
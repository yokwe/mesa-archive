-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- File: MicroCentral.mesa - last edit by:-- DEG     .PA 26-Sep-84 23:13:39DIRECTORY  CmFile USING [Error, Line],  Exec USING [AddCommand, CheckAbortProc, ExecProc, Handle, Outcome, OutputProc, ProcessCommandLine, RemoveCommand],  Format USING [StringProc, Text],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType,    CommandItem, Display, Enumerated, EnumeratedItem, line0, line2, line3, line4,    nullEnumeratedValue, ProcType, StringItem],  Heap USING [Create, Delete, systemZone],  Menu USING [Free, Handle, Instantiate, Make, MCRType, Uninstantiate],  Process USING [Detach],  Put USING [Line, Text],  String USING [AppendChar, AppendString, Copy, FreeString, Length, MakeString],  Tool USING [    Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [ResetUserAbort, UserAbort],  Window USING [Handle];MicroCentral: MONITOR LOCKS l USING l: Lock  IMPORTS     CmFile, Exec, Format, FormSW, Heap, Menu, Process, Put, String, Tool, UserInput =      BEGIN  -- TYPEs  Lock: TYPE = LONG POINTER TO MONITORLOCK;  StringNames: TYPE = {assemble, bind};  DataHandle: TYPE = LONG POINTER TO Data;  Data: TYPE = MACHINE DEPENDENT RECORD [    msgSW(0): Window.Handle ¬ NIL,    fileSW(2): Window.Handle ¬ NIL,    formSW(4): Window.Handle ¬ NIL,    log(6): UNSPECIFIED ¬ NULL,    menu(7): Menu.Handle ¬ NIL,    strings(9): ARRAY StringNames OF LONG STRING ¬ ALL[NIL]];  LogType: TYPE = {asm8085, bind8085, mass};  -- Variable declarations  commandBusy: BOOLEAN ¬ FALSE;  commandDone: CONDITION;  commandLock: MONITORLOCK ¬ [];  commandRegistered: BOOLEAN ¬ FALSE;  CommandRegisteredLock: MONITORLOCK ¬ [];  switches: LONG STRING ¬ NIL;  token: LONG STRING ¬ NIL;  toolData: DataHandle ¬ NIL;  toolInUse: BOOLEAN ¬ FALSE;  toolLock: MONITORLOCK ¬ [];  wh: Window.Handle;  -- Tool's window  workingString: LONG STRING ¬ NIL;  cmdLine: LONG STRING ¬ NIL;  internalHeap: UNCOUNTED ZONE ¬ NIL;    AsmBind8085: FormSW.ProcType =    BEGIN    IF ~OkayToGo[l: @toolLock] THEN {ToolInUseMsg[]; RETURN};    cmdLine ¬ String.MakeString[z: internalHeap, maxlength: 20 + String.Length[toolData.strings[assemble]] + String.Length[toolData.strings[bind]]];    String.Copy[to: cmdLine, from: "Asm8085 "L];    String.AppendString[to: cmdLine, from: toolData.strings[assemble]];    String.AppendString[to: cmdLine, from: "; Bind8085 "L];    String.AppendString[to: cmdLine, from: toolData.strings[bind]];    String.AppendChar[s: cmdLine, c: '\n];    Process.Detach[FORK DoCommand[]];    END;  Assemble8085: FormSW.ProcType =    BEGIN    IF ~OkayToGo[l: @toolLock] THEN {ToolInUseMsg[]; RETURN};    cmdLine ¬ String.MakeString[z: internalHeap, maxlength: 9 + String.Length[toolData.strings[assemble]]];    String.Copy[to: cmdLine, from: "Asm8085 "L];    String.AppendString[to: cmdLine, from: toolData.strings[assemble]];    String.AppendChar[s: cmdLine, c: '\n];    Process.Detach[FORK DoCommand[]];    END;      Bind8085: FormSW.ProcType =    BEGIN    IF ~OkayToGo[l: @toolLock] THEN {ToolInUseMsg[]; RETURN};    cmdLine ¬ String.MakeString[z: internalHeap, maxlength: 10 + String.Length[toolData.strings[bind]]];    String.Copy[to: cmdLine, from: "Bind8085 "L];    String.AppendString[to: cmdLine, from: toolData.strings[bind]];    String.AppendChar[s: cmdLine, c: '\n];    Process.Detach[FORK DoCommand[]];    END;      ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        IF toolData = NIL THEN toolData ¬ Heap.systemZone.NEW[Data ¬ []];      new = inactive =>        IF toolData # NIL THEN {	  Menu.Uninstantiate[menu: toolData.menu, window: window];	  Menu.Free[toolData.menu];	  Heap.systemZone.FREE[@toolData]};      ENDCASE;    END;  DoCommand: PROCEDURE =    BEGIN    outcome: Exec.Outcome;    Write: Format.StringProc = {Put.Text[toolData.fileSW, s]};    CheckForAbort: Exec.CheckAbortProc = {abort ¬ UserInput.UserAbort[wh];  IF abort THEN UserInput.ResetUserAbort[wh]};    Put.Line[toolData.fileSW, cmdLine];    outcome ¬ Exec.ProcessCommandLine[cmd: cmdLine, write: Write, checkAbort: CheckForAbort];    Put.Text[toolData.fileSW, "\n"L];    String.FreeString[z: internalHeap, s: cmdLine];    IAmDone[@toolLock];    END;      IAmDone: ENTRY PROCEDURE[l: Lock] =    BEGIN    toolInUse ¬ FALSE;    END;      MakeForm: FormSW.ClientItemsProcType =    BEGIN OPEN FormSW;    nItems: CARDINAL = 8;    item: INTEGER ¬ -1;        logDesc: ARRAY [0..3) OF Enumerated ¬ [      ["Asm8085"L, LogType[asm8085]], ["Bind8085"L, LogType[bind8085]], ["Mass"L, LogType[mass]]];    items ¬ AllocateItemDescriptor[nItems];    toolData.strings[assemble] ¬ toolData.strings[bind] ¬ NIL;    items[item ¬ item + 1] ¬ CommandItem[      tag: "Asm8085"L, place: [0, line0], proc: Assemble8085];    items[item ¬ item + 1] ¬ CommandItem[      tag: "Bind8085"L, place: [75, line0], proc: Bind8085];    items[item ¬ item + 1] ¬ CommandItem[      tag: "8085"L, place: [150, line0], proc: AsmBind8085];    items[item ¬ item + 1] ¬ CommandItem[      tag: "Mass"L, place: [275, line0], proc: MicrocodeAssemble];    items[item ¬ item + 1] ¬ CommandItem[      tag: "Options"L, place: [400, line0], proc: Options];    items[item ¬ item + 1] ¬ StringItem[      tag: "Assemble"L, place: [0, line2], string: @toolData.strings[assemble],      inHeap: TRUE];    items[item ¬ item + 1] ¬ StringItem[      tag: "Bind"L, place: [0, line3], string: @toolData.strings[bind],      inHeap: TRUE];    items[item ¬ item + 1] ¬ EnumeratedItem[      tag: "Log"L, place: [0, line4], feedback: one,      value: @toolData.log, choices: DESCRIPTOR[logDesc]];    toolData.log ¬ FormSW.nullEnumeratedValue;    RETURN[items: items, freeDesc: TRUE];    END;  MakeSWs: Tool.MakeSWsProc =    BEGIN    logName: STRING ¬ [40];    menuStrings: ARRAY [0..2) OF LONG STRING ¬ [      "Domino"L, "Microcode"L];    toolData.menu ¬ Menu.Make[      name: "Build"L, strings: DESCRIPTOR[menuStrings],      mcrProc: MenuCommandRoutine];    Tool.UnusedLogName[unused: logName, root: "MicroCentral.log"L];    toolData.msgSW ¬ Tool.MakeMsgSW[window: window];    toolData.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    toolData.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    Menu.Instantiate[toolData.menu, window];    END;  MenuCommandRoutine: Menu.MCRType =    BEGIN    ENABLE      CmFile.Error => GOTO exit;    IF toolData.strings[assemble] # NIL THEN Heap.systemZone.FREE[@toolData.strings[assemble]];    toolData.strings[assemble] ¬ NIL;    IF toolData.strings[bind] # NIL THEN Heap.systemZone.FREE[@toolData.strings[bind]];    toolData.strings[bind] ¬ NIL;   SELECT index FROM      0 => {toolData.strings[assemble] ¬ CmFile.Line[fileName: "Microcoders.cm"L, title: "MicroCentral"L, name: "Asm8085"L];   toolData.strings[bind] ¬ CmFile.Line[fileName: "Microcoders.cm"L, title: "MicroCentral"L, name: "Bind8085"L]};      1 => {toolData.strings[assemble] ¬ CmFile.Line[fileName: "Microcoders.cm"L, title: "MicroCentral"L, name: "Mass"L]};      ENDCASE => Put.Line[toolData.msgSW, "*** ERROR ***"L];      FormSW.Display[sw: toolData.formSW];      EXITS        exit => FormSW.Display[sw: toolData.formSW];    END;  MicrocodeAssemble: FormSW.ProcType =    BEGIN    IF ~OkayToGo[l: @toolLock] THEN {ToolInUseMsg[]; RETURN};    cmdLine ¬ String.MakeString[z: internalHeap, maxlength: 6 + String.Length[toolData.strings[assemble]]];    String.Copy[to: cmdLine, from: "Mass "L];    String.AppendString[to: cmdLine, from: toolData.strings[assemble]];    String.AppendChar[s: cmdLine, c: '\n];    Process.Detach[FORK DoCommand[]];    END;    MicroHelp: Exec.ExecProc =    BEGIN    Write: Format.StringProc ¬ Exec.OutputProc[h];    Format.Text[Write, "Micro Central is a tool like Command Central which is used in the microcoder's environment.\n"L];    END;  MicroStart: Exec.ExecProc =    BEGIN    internalHeap ¬ Heap.Create[initial: 1];    wh ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: active,      clientTransition: ClientTransition, name: "Micro Central"L,      tinyName1: "Micro"L, tinyName2: "Central"L, cmSection: "Micro Central"L];    END;    MicroUnload: Exec.ExecProc =    BEGIN    IF ~OkayToGo[l: @toolLock] THEN RETURN[abort];    << IF cmdLine # NIL THEN internalHeap.FREE[@cmdLine]; >>    Tool.Destroy[window: wh];    Heap.Delete[z: internalHeap, checkEmpty: TRUE];    [] ¬ Exec.RemoveCommand[h: h, name: "MicroCentral.~ "];    END;      NotifyCommandDone: ENTRY PROCEDURE[l: Lock] =    BEGIN    commandBusy ¬ FALSE;    NOTIFY commandDone;    END;    OkayToGo: ENTRY PROCEDURE[l: Lock] RETURNS[ok: BOOLEAN] =    BEGIN    ok ¬ ~toolInUse;    toolInUse ¬ TRUE;    END;  Options: FormSW.ProcType =    BEGIN    Put.Line[toolData.fileSW, "No options are currently available."L];    END;      ToolInUseMsg: PROCEDURE = {Put.Line[toolData.msgSW, "Micro Central busy!"L]};    WaitCommandDone: ENTRY PROCEDURE[l: Lock] =    BEGIN      WHILE commandBusy DO WAIT commandDone ENDLOOP;      commandBusy ¬ TRUE;    END;     -- Mainline code  Exec.AddCommand[name: "MicroCentral.~ "L, proc: MicroStart, help: MicroHelp, unload: MicroUnload];  -- this gets string out of global frame  END...    Created by DEG     .PA: 30-May-83 19:30:08  Last edited by Dennis DEG      @  8-Oct-83  2:47:25: implement STOP  Time: 26-Sep-84 23:13:31	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.  
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CPKernelCSDLion.mesa, HGM, 11-Oct-83 22:13:41DIRECTORY  Environment USING [Block, Byte],  Inline USING [BITSHIFT, BITXOR, HighByte, LowByte],  CP USING [Bank, BankAndWordsPerBank, RealCS],  CPKernel USING [CSBlock, Error, OneMI],  CPKernelConstants ,  CPKernelOps USING [AddressOutOfRange, ReadWordInternal, SetNewBank, WriteIOPCommand, WriteWordInternal],  CPMI USING [AD, AF, AS, FS01, FS23, FX, FY, FZ, MI],  IOPKernel USING [Error],  IOPKernelOps USING [Command, InitializeLock, lock, WriteBlockInternal];CPKernelCSDLion: MONITOR LOCKS IOPKernelOps.lock  IMPORTS    Inline, CPKernel, CPKernelOps, IOPKernel, IOPKernelOps  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelConstants;      WriteCS: PUBLIC ENTRY PROCEDURE [real: CP.RealCS, mi: CPMI.MI] =    BEGIN ENABLE UNWIND => NULL; WriteCSInternal[real, mi] END;  WriteCSInternal: PUBLIC INTERNAL PROCEDURE [real: CP.RealCS, mi: CPMI.MI] =    BEGIN    bankAndWordsPerBank: CP.BankAndWordsPerBank = LOOPHOLE[real];    realMi: MIReal ¬ VirturalToReal[mi];    IF real ~IN CP.RealCS THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.SetNewBank[bankAndWordsPerBank.bank];    FixParity[@realMi];    WriteMIRealInternal[real, @realMi]    END;  WriteCSBad: PUBLIC ENTRY PROCEDURE [real: CP.RealCS, mi: CPMI.MI] =    BEGIN ENABLE UNWIND => NULL; WriteCSBadInternal[real, mi] END;  WriteCSBadInternal: PUBLIC INTERNAL PROCEDURE [real: CP.RealCS, mi: CPMI.MI] =    BEGIN    bankAndWordsPerBank: CP.BankAndWordsPerBank = LOOPHOLE[real];    realMi: MIReal ¬ VirturalToReal[mi];    IF real ~IN CP.RealCS THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.SetNewBank[bankAndWordsPerBank.bank];    FixParity[@realMi];    realMi.ep ¬ ~realMi.ep;    WriteMIRealInternal[real, @realMi]    END;  -- Parity better be right  WriteMIRealInternal: INTERNAL PROCEDURE [real: CP.RealCS, mi: LONG POINTER TO MIReal] =    BEGIN    words: LONG POINTER = mi;    temp: PACKED ARRAY [0..9) OF Environment.Byte;    block: Environment.Block ¬ [LOOPHOLE[LONG[@temp]], 0, 9];    IF FALSE THEN      BEGIN      CPKernelOps.WriteIOPCommand[writeCS];      CPKernelOps.WriteWordInternal[real];        -- Send CSAddr[0-11]      CPKernelOps.WriteWordInternal[(words+2)­];  -- Write CS[32-47]      CPKernelOps.WriteWordInternal[(words+1)­];  -- Write CS[16-31]      CPKernelOps.WriteWordInternal[(words+0)­];  -- Write CS[0-15]      RETURN;      END;    temp[0] ¬ LOOPHOLE[IOPKernelOps.Command[writeCS]];    temp[1] ¬ Inline.LowByte[real];    temp[2] ¬ Inline.HighByte[real];    temp[3] ¬ Inline.LowByte[(words+2)­];    temp[4] ¬ Inline.HighByte[(words+2)­];    temp[5] ¬ Inline.LowByte[(words+1)­];    temp[6] ¬ Inline.HighByte[(words+1)­];    temp[7] ¬ Inline.LowByte[(words+0)­];    temp[8] ¬ Inline.HighByte[(words+0)­];    IOPKernelOps.WriteBlockInternal[block ! IOPKernel.Error => ERROR CPKernel.Error[reason] ];    END;  WriteCSBlock: PUBLIC ENTRY PROCEDURE [count: CARDINAL, clump: LONG POINTER TO CPKernel.CSBlock] =    BEGIN ENABLE UNWIND => NULL;    WriteCSBlockInternal[count, @clump[0]];    END;  WriteCSBlockInternal: PUBLIC INTERNAL PROCEDURE [count: CARDINAL, clump: LONG POINTER TO CPKernel.OneMI] =    BEGIN    finger: CARDINAL ¬ 0;    bytesPerMi: CARDINAL = 9;    bufferSize: CARDINAL = 10*bytesPerMi;    temp: PACKED ARRAY [0..bufferSize) OF Environment.Byte;    block: Environment.Block ¬ [LOOPHOLE[LONG[@temp]], 0, bufferSize];    IF FALSE THEN      BEGIN      FOR i: CARDINAL IN [0..count) DO        real: MIReal ¬ VirturalToReal[clump.mi];        FixParity[@real];	WriteMIRealInternal[clump.real, @real];        clump ¬ clump + SIZE[CPKernel.OneMI];	ENDLOOP;      RETURN;      END;    FOR i: CARDINAL IN [0..count) DO      real: MIReal ¬ VirturalToReal[clump.mi];      words: POINTER = @real;      FixParity[@real];      temp[finger + 0] ¬ LOOPHOLE[IOPKernelOps.Command[writeCS]];      temp[finger + 1] ¬ Inline.LowByte[clump.real];      temp[finger + 2] ¬ Inline.HighByte[clump.real];      temp[finger + 3] ¬ Inline.LowByte[(words+2)­];      temp[finger + 4] ¬ Inline.HighByte[(words+2)­];      temp[finger + 5] ¬ Inline.LowByte[(words+1)­];      temp[finger + 6] ¬ Inline.HighByte[(words+1)­];      temp[finger + 7] ¬ Inline.LowByte[(words+0)­];      temp[finger + 8] ¬ Inline.HighByte[(words+0)­];      finger ¬ finger + bytesPerMi;      IF finger = bufferSize THEN        BEGIN        IOPKernelOps.WriteBlockInternal[block ! IOPKernel.Error => ERROR CPKernel.Error[reason] ];	finger ¬ 0;	END;      clump ¬ clump + SIZE[CPKernel.OneMI];      ENDLOOP;    IF finger # 0 THEN      BEGIN      block.stopIndexPlusOne ¬ finger;      IOPKernelOps.WriteBlockInternal[block ! IOPKernel.Error => ERROR CPKernel.Error[reason] ];      END;    END;  FixParity: PROCEDURE [data: LONG POINTER TO MIReal] =    BEGIN    words: LONG POINTER = data;    parity: WORD ¬ 0;    data.ep ¬ FALSE;    FOR i: CARDINAL IN [0..SIZE[MIReal]) DO      parity ¬ Inline.BITXOR[parity, (words+i)­];      ENDLOOP;    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -8]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -4]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -2]];    parity ¬ Inline.BITXOR[parity, Inline.BITSHIFT[parity, -1]];    data.ep ¬ LOOPHOLE[parity];    END;  ReadCS: PUBLIC ENTRY PROCEDURE [real: CP.RealCS] RETURNS [CPMI.MI] =    BEGIN ENABLE UNWIND => NULL; RETURN[ReadCSInternal[real]] END;  ReadCSInternal: PUBLIC INTERNAL PROCEDURE [real: CP.RealCS] RETURNS [CPMI.MI] =    BEGIN    bankAndWordsPerBank: CP.BankAndWordsPerBank = LOOPHOLE[real];    data: MIReal;    words: POINTER = @data;    IF real ~IN CP.RealCS THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.SetNewBank[bankAndWordsPerBank.bank];    CPKernelOps.WriteIOPCommand[readCS];    CPKernelOps.WriteWordInternal[real];  --Send CSAddr[0-11]    (words+2)­ ¬ CPKernelOps.ReadWordInternal[];  --Read CS[32-47]    (words+1)­ ¬ CPKernelOps.ReadWordInternal[];  --Read CS[16-31]    (words+0)­ ¬ CPKernelOps.ReadWordInternal[];  --Read CS[0-15]    RETURN[RealToVirtural[data]];    END;  MIReal: TYPE = MACHINE DEPENDENT RECORD [    rA, rB: Nibble,    aS: CPMI.AS, aF: CPMI.AF,    aD: CPMI.AD,  --word 0    ep, cIn, enSU, mem: BOOLEAN,    fS01: CPMI.FS01, fS23: CPMI.FS23,    fY: CPMI.FY, inia0to3: Nibble,  --word 1    fX: CPMI.FX, inia4to7: Nibble, fZ: CPMI.FZ, inia8to11: Nibble];  --word 2  VirturalToReal: PROCEDURE [virtural: CPMI.MI] RETURNS [real: MIReal] =    BEGIN    mir: POINTER TO MIReal = @real;    miv: POINTER TO CPMI.MI = @virtural;    foo: RECORD [extra, a, b, c: Nibble] = LOOPHOLE[miv.inia];    BEGIN OPEN miv;    mir­ ¬ [      rA, rB, aS, aF, aD, ep, cIn, enSU, mem, fS01, fS23, fY, foo.a, fX, foo.b, fZ, foo.c]    END    END;  RealToVirtural: PROCEDURE [real: MIReal] RETURNS [virtural: CPMI.MI] =    BEGIN    mir: POINTER TO MIReal = @real;    miv: POINTER TO CPMI.MI = @virtural;    foo: RECORD [extra, a, b, c: Nibble] = [0, mir.inia0to3, mir.inia4to7, mir.inia8to11];    BEGIN OPEN mir;    miv­ ¬ [      rA, rB, aS, aF, aD, ep, cIn, enSU, mem, fS01, fS23, fX, fY, fZ, LOOPHOLE[foo]]    END;    END;    [] ¬ IOPKernelOps.InitializeLock[];  END.
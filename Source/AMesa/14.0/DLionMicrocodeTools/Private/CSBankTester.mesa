-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CSBankTester.mesa, HGM, 11-Oct-83 23:17:28-- Please don't forget to update the heraldDIRECTORY  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    newLine, ProcType],  Format USING [StringProc],  Inline USING [BITXOR],  Process USING [Yield],  Put USING [CR, Line, Number, Text],  String USING [AppendChar, AppendString],  TextSW USING [ForceOutput],  Tool USING [Create, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle],    CP USING [Bank, RealCS, wordsPerBank],  CPCommand USING [Boot, Error],  CPKernel USING [    Continue, Error, HalfBoot, ReadCS, StartKernel, WriteBank, WriteCS, WriteTpc],  CPKernelOps USING [RawReadBank, RawWriteBank],  CPMI USING [MI],  CPSymbols USING [AppendMI, AppendRealCS];CSBankTester: PROGRAM --LOCKS IOPKernelOps.lock  IMPORTS    FormSW, Inline, Process, Put, String, TextSW, Tool, UserInput,    CPCommand, CPKernel, CPKernelOps, CPSymbols =  BEGIN    form, log: Window.Handle;    wordsToTest: CARDINAL = CP.wordsPerBank - 300;  -- Don't stomp on Kernel  TestBankReg: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      END;    PostMessage["Testing Bank register ..."L];    TailMessage[NIL];    BootCP[];    UNTIL UserInput.UserAbort[log] DO      FOR bank: CP.Bank IN CP.Bank DO        temp: CP.Bank;	CPKernelOps.RawWriteBank[bank];	temp ¬ CPKernelOps.RawReadBank[];	IF temp # bank THEN	  BEGIN	  TailMessage[""L];	  NewMessage["Trouble reading bank register: expected = "L];	  Put.Number[log, bank, [16, FALSE, TRUE, 0]];	  AppendMessage[", result = "L];	  Put.Number[log, temp, [16, FALSE, TRUE, 0]];	  TextSW.ForceOutput[log];	  END;        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;     FlapBank: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    loc0: CP.RealCS ¬ 0;    loc1: CP.RealCS ¬ 1;    loc2: CP.RealCS ¬ 2;    PostMessage["Putting Square Wave on Bank Register ... "L];    BootIOP[];    CPKernel.WriteCS[loc0, CPMI.MI[      , , , , , , , , , fyNorm, , , [n[clrIntErr]], , loc1]];    CPKernel.WriteCS[loc1, CPMI.MI[      , , dz, rOrS, , , , , , fyNorm, nibble, , [n[bank]], [d[3]], loc2]];    CPKernel.WriteCS[loc2, CPMI.MI[      , , dz, rOrS, , , , , , fyNorm, nibble, , [n[bank]], [d[0]], loc1]];    CPKernel.WriteTpc[7, loc1];    CPKernel.StartKernel[];    TailMessage[ "ok"L];    END;        ReadWriteBank: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      END;    PostMessage["Reading and writing Bank Register ... "L];    UNTIL UserInput.UserAbort[log] DO      FOR bank: CP.Bank IN CP.Bank DO	CPKernelOps.RawWriteBank[bank];	[] ¬ CPKernelOps.RawReadBank[];        Process.Yield[];        ENDLOOP;      ENDLOOP;    TailMessage["ok"L];    END;        JumpBank: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      END;    loc0: CP.RealCS = 0;    loc1: CP.RealCS = 1;    loc2: CP.RealCS = 2;    loc3: CP.RealCS = 3;    loc10: CP.RealCS = 10B;    loc20: CP.RealCS = 20B;    loc30: CP.RealCS = 30B;    loc100: CP.RealCS = 100B;    PostMessage["Jumping between banks."L];    -- Note that RA has bank number for watching writes that go to several banks    TailMessage[NIL];    BootCP[];    -- On a DLion the Pattern should be 0.1, 0.2, 0.3 => 1.10, 1.20, 1.30....    -- On a Dicentra the Pattern should be 0.1, 0.2 => 1.3, 1.100....    CPKernel.WriteCS[loc0 + 0*CP.wordsPerBank, CPMI.MI[      0, , , , , , , , , fyNorm, , , [n[clrIntErr]], , loc1]];    CPKernel.WriteCS[loc1 + 0*CP.wordsPerBank, CPMI.MI[      0, , dz, rOrS, , , , , , fyNorm, nibble, , [n[bank]], [d[1]], loc2]];    CPKernel.WriteCS[loc2 + 0*CP.wordsPerBank, CPMI.MI[      0, , , , , , , , , , , , , , loc3]];    CPKernel.WriteCS[loc3 + 0*CP.wordsPerBank, CPMI.MI[      0, , , , , , , , , , , , , , loc10]];  -- To second bank    CPKernel.WriteCS[loc0 + 1*CP.wordsPerBank, CPMI.MI[      1, , , , , , , , , fyNorm, , , [n[clrIntErr]], , loc10]];    CPKernel.WriteCS[loc10 + 1*CP.wordsPerBank, CPMI.MI[      1, , dz, rOrS, , , , , , fyNorm, nibble, , [n[bank]], [d[0]], loc20]];    CPKernel.WriteCS[loc20 + 1*CP.wordsPerBank, CPMI.MI[      1, , , , , , , , , , , , , , loc30]];    CPKernel.WriteCS[loc30 + 1*CP.wordsPerBank, CPMI.MI[      1, , , , , , , , , , , , , , loc1]];  -- To first bank    CPKernel.WriteCS[loc3 + 1*CP.wordsPerBank, CPMI.MI[      1, , dz, rOrS, , , , , , fyNorm, nibble, , [n[bank]], [d[0]], loc100]];    CPKernel.WriteCS[loc100 + 1*CP.wordsPerBank, CPMI.MI[      1, , , , , , , , , fyNorm, , , [n[clrIntErr]], , loc1]];    CPKernel.WriteTpc[0, loc1];    CPKernel.Continue[];    TailMessage["ok"L];    END;        Bank0: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Switching to Bank 0 ..."L];    CPKernel.WriteBank[0];    TailMessage[" ok"L];    END;        TestBank0: FormSW.ProcType =    BEGIN ENABLE      BEGIN CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      Hickup =>        BEGIN	WriteInfo[where, expected, found];	IF UserInput.UserAbort[log] THEN CONTINUE;        RESUME;        END;      END;    PostMessage["Testing Bank 0 of control store (! = 64 wds)"L];    BootIOP[];    TailMessage[""L];    FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO      zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];      ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];      address: CPMI.MI = LOOPHOLE[Three[cs, 0, cs]];  -- parity      result: CPMI.MI;      IF UserInput.UserAbort[log] THEN EXIT;      SELECT TRUE FROM        (cs = 0) => NULL;        ((cs MOD 64) = 0) => AppendMessage["!"L];	ENDCASE => NULL;      CPKernel.WriteCS[cs, zeros];      result ¬ CPKernel.ReadCS[cs];      IF result # zeros THEN SIGNAL Hickup[cs, zeros, result];      CPKernel.WriteCS[cs, ones];      result ¬ CPKernel.ReadCS[cs];      IF result # ones THEN SIGNAL Hickup[cs, ones, result];      CPKernel.WriteCS[cs, address];      result ¬ CPKernel.ReadCS[cs];      IF result # address THEN SIGNAL Hickup[cs, address, result];      Process.Yield[];      ENDLOOP;    TailMessage[" ok"L];    IF UserInput.UserAbort[log] THEN RETURN;    NewMessage["Check pass ... (! = 64 wds)"L];    TailMessage[""L];    FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO      address: CPMI.MI = LOOPHOLE[Three[cs, 0, cs]];      result: CPMI.MI;      IF UserInput.UserAbort[log] THEN EXIT;      SELECT TRUE FROM        (cs = 0) => NULL;        ((cs MOD 64) = 0) => AppendMessage["!"L];	ENDCASE => NULL;      result ¬ CPKernel.ReadCS[cs];      IF result # address THEN SIGNAL Hickup[cs, address, result];      ENDLOOP;    TailMessage[" ok"L];    END;    WriteInfo: PROCEDURE [where: CP.RealCS, expected, found: CPMI.MI] =    BEGIN    xor: CPMI.MI;    text: STRING = [200];    FOR i: CARDINAL IN [0..SIZE[CPMI.MI]) DO      a: POINTER = LOOPHOLE[@expected+i];      b: POINTER = LOOPHOLE[@found+i];      c: POINTER = LOOPHOLE[@xor+i];      c­ ¬ Inline.BITXOR[a­, b­];      ENDLOOP;    IF mismatches = 0 THEN      Put.Line[log, "    Addr         expected            found              xor"L];    mismatches ¬ mismatches + 1;    CPSymbols.AppendRealCS[text, where];    FOR i: CARDINAL IN [text.length..8) DO String.AppendChar[text, ' ]; ENDLOOP;    String.AppendString[text, "   "L];    CPSymbols.AppendMI[text, expected];    String.AppendString[text, "   "L];    CPSymbols.AppendMI[text, found];    String.AppendString[text, "   "L];    CPSymbols.AppendMI[text, xor];    Put.Line[log, text];    TextSW.ForceOutput[log];    END;  WriteBank0: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Writing Bank 0 of control store"L];    BootIOP[];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO        zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];        ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteCS[cs, zeros];        CPKernel.WriteCS[cs, ones];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        ReadBank0: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Reading Bank 0 of control store"L];    BootIOP[];    TailMessage[""L];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO        IF UserInput.UserAbort[log] THEN EXIT;        [] ¬ CPKernel.ReadCS[cs];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        WriteReadBank0: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Writing and Reading Bank 0 of control store"L];    BootIOP[];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO        zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];        ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteCS[cs, zeros];        [] ¬ CPKernel.ReadCS[cs];        CPKernel.WriteCS[cs, ones];        [] ¬ CPKernel.ReadCS[cs];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        Bank1: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Switching to Bank 1 ..."L];    CPKernel.WriteBank[1];    TailMessage[" ok"L];    END;        TestBank1: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      Hickup =>        BEGIN	WriteInfo[where, expected, found];	IF UserInput.UserAbort[log] THEN CONTINUE;        RESUME;        END;      END;    PostMessage["Testing Bank 1 of control store (! = 64 wds)"L];    TailMessage[""L];    BootCP[];    CPKernelOps.RawWriteBank[1];    TestBank[1];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    NewMessage["Check pass ... (! = 64 wds)"L];    TailMessage[""L];    CheckBank[1];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    END;    WriteBank1: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      END;    PostMessage["Writing Bank 1 of control store"L];    TailMessage[""L];    BootCP[];    CPKernelOps.RawWriteBank[1];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [1*CP.wordsPerBank..1*wordsToTest+CP.wordsPerBank) DO        zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];        ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteCS[cs, zeros];        CPKernel.WriteCS[cs, ones];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        ReadBank1: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      END;    PostMessage["Reading Bank 1 of control store"L];    TailMessage[""L];    BootCP[];    CPKernelOps.RawWriteBank[1];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [1*CP.wordsPerBank..1*wordsToTest+CP.wordsPerBank) DO        IF UserInput.UserAbort[log] THEN EXIT;        [] ¬ CPKernel.ReadCS[cs];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        WriteReadBank1: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      END;    PostMessage["Writing and Reading Bank 1 of control store"L];    TailMessage[""L];    BootCP[];    CPKernelOps.RawWriteBank[1];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [1*CP.wordsPerBank..wordsToTest+1*CP.wordsPerBank) DO        zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];        ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteCS[cs, zeros];        [] ¬ CPKernel.ReadCS[cs];        CPKernel.WriteCS[cs, ones];        [] ¬ CPKernel.ReadCS[cs];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        Bank2: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Switching to Bank 2 ..."L];    CPKernel.WriteBank[2];    TailMessage[" ok"L];    END;        TestBank2: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      Hickup =>        BEGIN	WriteInfo[where, expected, found];	IF UserInput.UserAbort[log] THEN CONTINUE;        RESUME;        END;      END;    PostMessage["Testing Bank 2 of control store (! = 64 wds)"L];    TailMessage[""L];    BootCP[];    CPKernelOps.RawWriteBank[2];    TestBank[2];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    NewMessage["Check pass ... (! = 64 wds)"L];    TailMessage[""L];    CheckBank[2];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    END;    WriteBank2: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      END;    PostMessage["Writing Bank 2 of control store"L];    TailMessage[""L];    BootCP[];    CPKernelOps.RawWriteBank[2];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [2*CP.wordsPerBank..2*wordsToTest+CP.wordsPerBank) DO        zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];        ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteCS[cs, zeros];        CPKernel.WriteCS[cs, ones];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        ReadBank2: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      END;    PostMessage["Reading Bank 2 of control store"L];    TailMessage[""L];    BootCP[];    CPKernelOps.RawWriteBank[2];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [2*CP.wordsPerBank..2*wordsToTest+CP.wordsPerBank) DO        IF UserInput.UserAbort[log] THEN EXIT;        [] ¬ CPKernel.ReadCS[cs];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        WriteReadBank2: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      END;    PostMessage["Writing and Reading Bank 2 of control store"L];    TailMessage[""L];    BootCP[];    CPKernelOps.RawWriteBank[2];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [2*CP.wordsPerBank..wordsToTest+2*CP.wordsPerBank) DO        zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];        ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteCS[cs, zeros];        [] ¬ CPKernel.ReadCS[cs];        CPKernel.WriteCS[cs, ones];        [] ¬ CPKernel.ReadCS[cs];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        Bank3: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Switching to Bank 3 ..."L];    CPKernel.WriteBank[3];    TailMessage[" ok"L];    END;        TestBank3: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      Hickup =>        BEGIN	WriteInfo[where, expected, found];	IF UserInput.UserAbort[log] THEN CONTINUE;        RESUME;        END;      END;    PostMessage["Testing Bank 3 of control store (! = 64 wds)"L];    TailMessage[""L];    BootCP[];    CPKernelOps.RawWriteBank[3];    TestBank[3];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    NewMessage["Check pass ... (! = 64 wds)"L];    TailMessage[""L];    CheckBank[3];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    END;    WriteBank3: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      END;    PostMessage["Writing Bank 3 of control store"L];    TailMessage[""L];    BootCP[];    CPKernelOps.RawWriteBank[3];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [3*CP.wordsPerBank..3*wordsToTest+CP.wordsPerBank) DO        zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];        ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteCS[cs, zeros];        CPKernel.WriteCS[cs, ones];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        ReadBank3: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      END;    PostMessage["Reading Bank 3 of control store"L];    TailMessage[""L];    BootCP[];    CPKernelOps.RawWriteBank[3];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [3*CP.wordsPerBank..3*wordsToTest+CP.wordsPerBank) DO        IF UserInput.UserAbort[log] THEN EXIT;        [] ¬ CPKernel.ReadCS[cs];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        WriteReadBank3: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      END;    PostMessage["Writing and Reading Bank 3 of control store"L];    TailMessage[""L];    BootCP[];    CPKernelOps.RawWriteBank[3];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [3*CP.wordsPerBank..wordsToTest+3*CP.wordsPerBank) DO        zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];        ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteCS[cs, zeros];        [] ¬ CPKernel.ReadCS[cs];        CPKernel.WriteCS[cs, ones];        [] ¬ CPKernel.ReadCS[cs];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        TestBank0And1: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      Hickup =>        BEGIN	WriteInfo[where, expected, found];	IF UserInput.UserAbort[log] THEN CONTINUE;        RESUME;        END;      END;    PostMessage["Testing Bank 0 of control store (! = 64 wds)"L];    TailMessage[""L];    BootCP[];    TestBank[0];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    NewMessage["Testing Bank 1 of control store (! = 64 wds)"L];    TailMessage[""L];    TestBank[1];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    AppendMessage["Checking bank 0 ... (! = 64 wds) "L];    CheckBank[0];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    AppendMessage["Checking bank 1 ... (! = 64 wds) "L];    CheckBank[1];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    END;  TestBank0And1And2: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      Hickup =>        BEGIN	WriteInfo[where, expected, found];	IF UserInput.UserAbort[log] THEN CONTINUE;        RESUME;        END;      END;    PostMessage["Testing Bank 0 of control store (! = 64 wds)"L];    TailMessage[""L];    BootCP[];    TestBank[0];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    NewMessage["Testing Bank 1 of control store (! = 64 wds)"L];    TailMessage[""L];    TestBank[1];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    NewMessage["Testing Bank 2 of control store (! = 64 wds)"L];    TailMessage[""L];    TestBank[2];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    AppendMessage["Checking bank 0 ... (! = 64 wds) "L];    CheckBank[0];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    AppendMessage["Checking bank 1 ... (! = 64 wds) "L];    CheckBank[1];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    AppendMessage["Checking bank 2 ... (! = 64 wds) "L];    CheckBank[2];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    END;  TestBank0And1And2And3: FormSW.ProcType =    BEGIN ENABLE      BEGIN      CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      CPCommand.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      Hickup =>        BEGIN	WriteInfo[where, expected, found];	IF UserInput.UserAbort[log] THEN CONTINUE;        RESUME;        END;      END;    PostMessage["Testing Bank 0 of control store (! = 64 wds)"L];    TailMessage[""L];    BootCP[];    TestBank[0];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    NewMessage["Testing Bank 1 of control store (! = 64 wds)"L];    TailMessage[""L];    TestBank[1];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    NewMessage["Testing Bank 2 of control store (! = 64 wds)"L];    TailMessage[""L];    TestBank[2];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    NewMessage["Testing Bank 3 of control store (! = 64 wds)"L];    TailMessage[""L];    TestBank[3];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    AppendMessage["Checking bank 0 ... (! = 64 wds) "L];    CheckBank[0];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    AppendMessage["Checking bank 1 ... (! = 64 wds) "L];    CheckBank[1];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    AppendMessage["Checking bank 2 ... (! = 64 wds) "L];    CheckBank[2];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    AppendMessage["Checking bank 3 ... (! = 64 wds) "L];    CheckBank[3];    IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;    TailMessage[" ok"L];    END;  HalfBoot: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Booting IOP and HalfBooting CP (Not loading Kernel) ... "L];    BootIOP[];    TailMessage["OK."L];    END;        mismatches: CARDINAL ¬ 0;  Hickup: SIGNAL [where: CP.RealCS, expected, found: CPMI.MI] = CODE;  Three: TYPE = RECORD [a, b, c: WORD];    TestBank: PROCEDURE [bank: CP.Bank] =    BEGIN    begin, end: CP.RealCS;    begin ¬ bank*CP.wordsPerBank;    end ¬ begin + wordsToTest;    FOR cs: CP.RealCS IN [begin..end) DO      zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];      ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];      address: CPMI.MI = LOOPHOLE[Three[cs, 0, cs]];  -- parity      result: CPMI.MI;      IF UserInput.UserAbort[log] THEN RETURN;      SELECT TRUE FROM        (cs = 0) => NULL;        ((cs MOD 64) = 0) => AppendMessage["!"L];	ENDCASE => NULL;      CPKernel.WriteCS[cs, zeros];      result ¬ CPKernel.ReadCS[cs];      IF result # zeros THEN SIGNAL Hickup[cs, zeros, result];      CPKernel.WriteCS[cs, ones];      result ¬ CPKernel.ReadCS[cs];      IF result # ones THEN SIGNAL Hickup[cs, ones, result];      CPKernel.WriteCS[cs, address];      result ¬ CPKernel.ReadCS[cs];      IF result # address THEN SIGNAL Hickup[cs, address, result];      Process.Yield[];      ENDLOOP;    END;    CheckBank: PROCEDURE [bank: CP.Bank] =    BEGIN    begin, end: CP.RealCS;    begin ¬ bank*CP.wordsPerBank;    end ¬ begin + wordsToTest;    FOR cs: CP.RealCS IN [begin..end) DO      address: CPMI.MI = LOOPHOLE[Three[cs, 0, cs]];      result: CPMI.MI;      IF UserInput.UserAbort[log] THEN EXIT;      SELECT TRUE FROM        (cs = 0) => NULL;        ((cs MOD 64) = 0) => AppendMessage["!"L];	ENDCASE => NULL;      result ¬ CPKernel.ReadCS[cs];      IF result # address THEN SIGNAL Hickup[cs, address, result];      ENDLOOP;    END;    BootIOP: PROCEDURE =    BEGIN    CPKernel.HalfBoot[];    END;    BootCP: PROCEDURE =    BEGIN    mismatches ¬ 0;    CPCommand.Boot[LogString, log];    END;  LogString: Format.StringProc =    BEGIN    Put.Text[clientData, s];    END;  PostMessage: PROCEDURE [s: LONG STRING, clear: BOOLEAN ¬ TRUE] =    BEGIN    Put.CR[log];    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  NewMessage: PROCEDURE [s: LONG STRING, clear: BOOLEAN ¬ TRUE] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    Put.Line[log, "."L];    TextSW.ForceOutput[log]    END;  Initialize: PROCEDURE =    BEGIN    herald: STRING = "CSBank Tester of 11-Oct-83 23:11:04"L;    [] ¬ Tool.Create[      name: herald,      cmSection: "CSBank Tester"L,      initialState: inactive,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    Tool.UnusedLogName[logFileName, "CSBankTester.log$"L];    log ¬ Tool.MakeFileSW[window: window, name: logFileName];    END;    MakeForm: FormSW.ClientItemsProcType =    BEGIN    i: INTEGER ¬ -1;    nParams: CARDINAL = 27;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestBankReg"L, proc: TestBankReg, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "FlapBank"L, proc: FlapBank];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadWriteBank"L, proc: ReadWriteBank];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "JumpBank"L, proc: JumpBank];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Bank0"L, proc: Bank0, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestBank0"L, proc: TestBank0];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteBank0"L, proc: WriteBank0];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadBank0"L, proc: ReadBank0];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteReadBank0"L, proc: WriteReadBank0];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Bank1"L, proc: Bank1, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestBank1"L, proc: TestBank1];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteBank1"L, proc: WriteBank1];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadBank1"L, proc: ReadBank1];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteReadBank1"L, proc: WriteReadBank1];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Bank2"L, proc: Bank2, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestBank2"L, proc: TestBank2];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteBank2"L, proc: WriteBank2];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadBank2"L, proc: ReadBank2];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteReadBank2"L, proc: WriteReadBank2];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Bank3"L, proc: Bank3, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestBank3"L, proc: TestBank3];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteBank3"L, proc: WriteBank3];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadBank3"L, proc: ReadBank3];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteReadBank3"L, proc: WriteReadBank3];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestBank0And1"L, proc: TestBank0And1, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestBank0And1And2"L, proc: TestBank0And1And2];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestBank0And1And2And3"L, proc: TestBank0And1And2And3];    IF (i+1) # nParams THEN ERROR;    RETURN[items, TRUE];    END;       ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN        END;      ENDCASE;    END;	  Initialize[];  END.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- IOPSymbols.mesa, HGM, 12-Nov-83 22:51:52DIRECTORY  Heap USING [Create],  Inline USING [DIVMOD, LowHalf],  String USING [AppendChar, AppendNumber, AppendString, Equivalent],    IOP USING [Address],  IOPSyms USING [],  SymHash USING [    Create, Destroy, GetInfo, GetString, Handle,    Hash, Insert, Lookup, nullHandle, nullHash, PutInfo, Reset];IOPSymbols: PROGRAM  IMPORTS Heap, Inline, String, SymHash  EXPORTS IOPSyms =  BEGIN  z: UNCOUNTED ZONE = Heap.Create[10];    Error: PUBLIC ERROR [reason: LONG STRING] = CODE;  externalSymbols: SymHash.Handle ¬ SymHash.Create[20];  modules: Module ¬ NIL;  inverseKnown: ARRAY Clump OF LONG POINTER TO PACKED ARRAY Slot OF BOOLEAN ¬ ALL [NIL];  inverse: ARRAY Clump OF LONG POINTER TO ARRAY Slot OF Info ¬ ALL [NIL];    Clump: TYPE = [0..16);  Slot: TYPE = [0..4096);    Info: TYPE = RECORD [module: Module, hash: SymHash.Hash];  -- module=NIL => external  Module: PUBLIC TYPE = LONG POINTER TO ModuleObject;  ModuleObject: TYPE = RECORD [    base, top: IOP.Address,    name: LONG STRING,    symbols: SymHash.Handle,    next: Module];      ClearSymbolTable: PUBLIC PROCEDURE =    BEGIN    UNTIL modules = NIL DO      temp: Module = modules.next;      IF modules.symbols # SymHash.nullHandle THEN        BEGIN        SymHash.Destroy[modules.symbols];	END;      z.FREE[@modules.name];      z.FREE[@modules];      modules ¬ temp;      ENDLOOP;    SymHash.Reset[externalSymbols];    FOR clump: Clump IN Clump DO      IF inverseKnown[clump] = NIL THEN LOOP;      inverseKnown[clump]­ ¬ ALL [FALSE];      inverse[clump]­ ¬ ALL [[NIL, SymHash.nullHash]];      ENDLOOP;    END;  AddExternalSymbol: PUBLIC PROCEDURE [s: LONG STRING, a: IOP.Address] =    BEGIN    hash: SymHash.Hash;    clump: Clump;    slot: Slot;    hash ¬ SymHash.Lookup[externalSymbols, s];    IF hash # SymHash.nullHash THEN      BEGIN      IF a = SymHash.GetInfo[externalSymbols, hash] THEN RETURN;  -- Ignore Duplicates      END;    hash ¬ SymHash.Insert[externalSymbols, s];    SymHash.PutInfo[externalSymbols, hash, a];    [clump, slot] ¬ Split[a];    BeSureSlotExists[clump, slot];    inverseKnown[clump][slot] ¬ TRUE;    inverse[clump][slot] ¬ [NIL, hash];    END;  LookUpInExternalSymbolTable: PUBLIC PROCEDURE [s: LONG STRING]    RETURNS [ok: BOOLEAN, a: IOP.Address] =    BEGIN    hash: SymHash.Hash;    IF externalSymbols = SymHash.nullHandle THEN RETURN[FALSE,];    hash ¬ SymHash.Lookup[externalSymbols, s];    IF hash # SymHash.nullHash THEN      BEGIN      RETURN[TRUE, Inline.LowHalf[SymHash.GetInfo[externalSymbols, hash]]];      END;    RETURN[FALSE, ];    END;  CreateModule: PUBLIC PROCEDURE [name: LONG STRING, base, top: IOP.Address]    RETURNS [module: Module] =    BEGIN    module ¬ z.NEW[ModuleObject];    module­ ¬ [      base: base,      top: top,      name: z.NEW[StringBody[name.length]],      symbols: SymHash.nullHandle,      next: modules];    String.AppendString[module.name, name];    modules ¬ module;    END;  FindModule: PUBLIC PROCEDURE [name: LONG STRING] RETURNS [module: Module, base: IOP.Address] =    BEGIN    FOR module ¬ modules, module.next UNTIL module = NIL DO      IF String.Equivalent[name, module.name] THEN RETURN [module, module.base];      ENDLOOP;    ERROR Error["Module not found"L];    END;  CreateModuleSymbols: PUBLIC PROCEDURE [module: Module, pages: CARDINAL] =    BEGIN    IF module.symbols # SymHash.nullHandle THEN SymHash.Destroy[modules.symbols];    module.symbols ¬ SymHash.Create[pages];    END;  AddModuleSymbol: PUBLIC PROCEDURE [module: Module, s: LONG STRING, a: IOP.Address] =    BEGIN    hash: SymHash.Hash;    clump: Clump;    slot: Slot;    hash ¬ SymHash.Lookup[module.symbols, s];    IF hash # SymHash.nullHash THEN      BEGIN      IF a = SymHash.GetInfo[module.symbols, hash] THEN RETURN;  -- Ignore Duplicates      END;    hash ¬ SymHash.Insert[module.symbols, s];    SymHash.PutInfo[module.symbols, hash, a];    [clump, slot] ¬ Split[a];    BeSureSlotExists[clump, slot];    inverseKnown[clump][slot] ¬ TRUE;    inverse[clump][slot] ¬ [module, hash];    END;  LookUpInSymbolTable: PUBLIC PROCEDURE [s: LONG STRING]    RETURNS [ok: BOOLEAN, a: IOP.Address] =    BEGIN    FOR module: Module ¬ modules, module.next UNTIL module = NIL DO      hash: SymHash.Hash;      IF module.symbols = SymHash.nullHandle THEN LOOP;      hash ¬ SymHash.Lookup[module.symbols, s];      IF hash # SymHash.nullHash THEN        BEGIN        RETURN[TRUE, Inline.LowHalf[SymHash.GetInfo[module.symbols, hash]]];        END;      ENDLOOP;    RETURN[FALSE, ];    END;        SymbolicExists: PUBLIC PROCEDURE [a: IOP.Address] RETURNS [BOOLEAN] =    BEGIN    clump: Clump;    slot: Slot;    IF a < 400B THEN RETURN[FALSE];  -- Don't use flag bits and such    FOR i: CARDINAL IN [0..25) DO      IF a < i THEN EXIT;      [clump, slot] ¬ Split[a - i];      IF inverseKnown[clump] = NIL THEN LOOP;      IF inverseKnown[clump][slot] THEN RETURN [TRUE];      ENDLOOP;    RETURN[FALSE];    END;      AppendMemoryAddress: PUBLIC PROCEDURE [s: LONG STRING, a: IOP.Address, showModule: BOOLEAN] =    BEGIN    clump: Clump;    slot: Slot;    FOR i: CARDINAL IN [0..100) DO      module: Module;      symbols: SymHash.Handle ¬ externalSymbols;      hash: SymHash.Hash;      IF a < i THEN EXIT;      [clump, slot] ¬ Split[a - i];      IF inverseKnown[clump] = NIL THEN LOOP;      IF ~inverseKnown[clump][slot] THEN LOOP;      module ¬ inverse[clump][slot].module;      IF module # NIL THEN        BEGIN	symbols ¬ module.symbols;	IF showModule THEN	  BEGIN	  String.AppendString[s, module.name];	  String.AppendString[s, "$"L];	  END;	END;      hash ¬ inverse[clump][slot].hash;      String.AppendString[s, SymHash.GetString[symbols, hash]];      IF i > 0 THEN	BEGIN	String.AppendChar[s, '+];	IF i > 9 THEN String.AppendChar[s, '0];	String.AppendNumber[s, i, 16];	END;      RETURN;      ENDLOOP;    IF a < 1000B THEN String.AppendChar[s, '0];    String.AppendNumber[s, a, 16];    END;    Split: PROCEDURE [a: IOP.Address] RETURNS [clump: Clump, slot: Slot] =    BEGIN    [clump, slot] ¬ Inline.DIVMOD[a, LAST[Slot]+1];    END;    BeSureSlotExists: PROCEDURE [clump: Clump, slot: Slot] =    BEGIN    IF inverseKnown[clump] # NIL THEN RETURN;    inverseKnown[clump] ¬ z.NEW[PACKED ARRAY Slot OF BOOLEAN];    inverseKnown[clump]­ ¬ ALL [FALSE];    inverse[clump] ¬ z.NEW[ARRAY Slot OF Info];    inverse[clump]­ ¬ ALL [[NIL, SymHash.nullHash]];    END;       ClearSymbolTable[];  END.
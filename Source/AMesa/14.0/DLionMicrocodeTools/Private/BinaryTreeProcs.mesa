-- Copyright (C) 1979, 1980, 1981, 1982  by Xerox Corporation. All rights reserved. -- Binary-Tree procedures for symbol table handling-- These procedures are expected to work entirely in core-- last edited by CRS August 14, 1979  4:12 PM-- last edited by PXJ    May 22, 1980  1:43 PM-- last edited by ETN   on  8-Apr-82 11:13:10 - Convert to Trinity.-- last edited by PXO      on October 21, 1981  3:56 PM - Changed some strings and pointers to long.-- last edited by PXO      on October 8, 1981  8:19 PM - Added proc ReInit.-- last edited by PXO      on October 6, 1981  6:08 PM - Reworked to use NEWs and FREEs instead of FSPDefs, to run on Dandelion.-- Time: 26-Sep-84 23:02:30	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.DIRECTORY  BinaryTreeDefs USING [Item, Node],  Heap USING [Create, Delete],  Space USING [PageCount],  String USING [EqualStrings];BinaryTreeProcs: PROGRAM IMPORTS Heap, String EXPORTS BinaryTreeDefs =  BEGIN  SymbolAlreadyDefined: PUBLIC SIGNAL [Ent: LONG POINTER TO BinaryTreeDefs.Item] =    CODE;  SymbolNotDefined: PUBLIC SIGNAL = CODE;  TreeHeap: UNCOUNTED ZONE;  TreeCount: CARDINAL;  initsize: Space.PageCount = 4;  InsertItemInTree: PUBLIC PROC [    k: LONG POINTER TO BinaryTreeDefs.Item, t: LONG POINTER TO BinaryTreeDefs.Node]    RETURNS [LONG POINTER TO BinaryTreeDefs.Node] =    BEGIN    IF t = NIL THEN      RETURN[        TreeHeap.NEW[BinaryTreeDefs.Node ¬ [data: k, left: NIL, right: NIL]]];    IF String.EqualStrings[t.data.key, k.key] THEN SIGNAL SymbolAlreadyDefined[k]    ELSE      IF LessString[k.key, t.data.key] THEN t.left ¬ InsertItemInTree[k, t.left]      ELSE t.right ¬ InsertItemInTree[k, t.right];    RETURN[t];    END;  -- InsertItemInTree  FindItemInTree: PUBLIC PROC [s: LONG STRING, t: LONG POINTER TO BinaryTreeDefs.Node]    RETURNS [LONG POINTER TO BinaryTreeDefs.Item] =    BEGIN    IF t = NIL THEN RETURN[NIL];    IF String.EqualStrings[s, t.data.key] THEN RETURN[t.data];    IF LessString[s, t.data.key] THEN RETURN[FindItemInTree[s, t.left]]    ELSE RETURN[FindItemInTree[s, t.right]];    END;  -- of procedure FindItemInTree;  LessString: PROC [s1, s2: LONG STRING] RETURNS [BOOLEAN] =    BEGIN    l: CARDINAL ¬ 0;    WHILE l < s1.length DO      IF l = s2.length THEN RETURN[FALSE];      IF s1[l] # s2[l] THEN RETURN[s1[l] < s2[l]];      l ¬ l + 1;      ENDLOOP;    RETURN[TRUE];    END;  --  of Procedure LessString  DisplayTree: PUBLIC PROC [    t: LONG POINTER TO BinaryTreeDefs.Node,    Disp: PROC [LONG POINTER TO BinaryTreeDefs.Item]] =    BEGIN    IF t # NIL THEN      BEGIN      DisplayTree[t.left, Disp];      Disp[t.data];      DisplayTree[t.right, Disp];      END;    END;  --  of Procedure DisplayTable  RedefineItemInTree: PUBLIC PROC [    k: POINTER TO BinaryTreeDefs.Item, t: POINTER TO BinaryTreeDefs.Node]    RETURNS [LONG POINTER TO BinaryTreeDefs.Item] =    BEGIN    i: LONG POINTER TO BinaryTreeDefs.Item ¬ FindItemInTree[k.key, t];    IF i = NIL THEN BEGIN SIGNAL SymbolNotDefined; RETURN[NIL] END    ELSE BEGIN i.ptr ¬ k.ptr; RETURN[i] END;    END;  -- RedefineItemInTree  InitializeTree: PUBLIC PROC RETURNS [POINTER TO BinaryTreeDefs.Node] =    BEGIN    IF TreeCount = 0 AND TreeHeap = NIL THEN InitTreeHeap[initsize];    TreeCount ¬ TreeCount + 1;    RETURN[NIL];    END;  --  of Procedure InitializeTree  DestroyTree: PUBLIC PROC [tree: LONG POINTER TO BinaryTreeDefs.Node] =    BEGIN    IF (TreeCount ¬ TreeCount - 1) = 0 THEN EraseHeap[] ELSE UnpickTree[tree];    END;  UnpickTree: PROC [tree: LONG POINTER TO BinaryTreeDefs.Node] =    BEGIN    IF tree = NIL THEN RETURN;    UnpickTree[tree.left];    UnpickTree[tree.right];    TreeHeap.FREE[@tree];    END;  -- Now the private storage management routines  InitTreeHeap: PROC [npages: Space.PageCount] =    BEGIN    IF TreeHeap ~= NIL THEN EraseHeap[];    TreeHeap ¬ Heap.Create[initial: npages];    END;  EraseHeap: PROC = BEGIN Heap.Delete[z: TreeHeap]; TreeHeap ¬ NIL; END;  ReInit: PUBLIC PROC =    BEGIN IF TreeHeap ~= NIL THEN EraseHeap[]; TreeCount ¬ 0; END;  Init: PROC = BEGIN TreeHeap ¬ NIL; TreeCount ¬ 0; END;  Init[];  END.
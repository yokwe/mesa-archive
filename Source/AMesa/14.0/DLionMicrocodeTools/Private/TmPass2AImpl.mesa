-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TmPass2AImpl.mesa -- Last edit: DEG      26-Sep-84 20:57:51 -- Last edit: JAC    15-Jul-83 16:29:38 -- Edited by ETN    16-Jul-82 11:55:05 DIRECTORY  Ascii USING [SP],  Environment USING [Byte, bytesPerWord, Block],  MassBurdockInterface,  Stream USING [GetBlock, GetPosition, GetWord, PutChar, PutBlock, SetPosition],  String USING [AppendNumber, AppendDecimal, AppendString, WordsForString],  TmAssembler USING [MEntryPtr],  TmControl USING [noFinalFiles],  TmFile USING [    fbInStream, LogErrLine, LogLine, LogText, OpenNextFb, OpenNextSi, OpenStFile,    siStream, stStream],  TmLabel,  TmModule USING [DisplayM, ReleaseMTSpace],  TmP2Hash USING [    bad, curID, curMI, DisplayPass2Hash, errorLevel, ExportDataRec,    ExportDataRecPtr, exportRecList, ExportRec, ExportRecPtr, FindPass2Label,    GetMiSpace, GetPass2Space, GetXSpace, GetXString, InsertPass2Hash, MiLtoV,    miLtoV, MiVtoLtxt, miVtoLtxt, labIoff, miVtoR, MiVtoR, Mi2Res, mi2Res, miIoff,    Not, NoTxt, Pass2Entry, Pass2HashEntry, Pass2HashEntryPtr, realMI, RefChain,    RefChainPtr];TmPass2AImpl: PROGRAM  IMPORTS Stream, String, TmControl, TmFile, TmLabel, TmModule, TmP2Hash  EXPORTS TmLabel, TmModule =  BEGIN OPEN MassBurdockInterface, TmLabel;  AppendSymbolName: PUBLIC PROCEDURE [str: LONG STRING, mi: CARDINAL [0..5120)] =    BEGIN    i, j: CARDINAL ¬ 0;    name: LONG STRING ¬ [64];    FOR i DECREASING IN [0..mi] DO      IF TmP2Hash.miVtoLtxt[i] # TmP2Hash.NoTxt THEN BEGIN j ¬ i; EXIT; END;      ENDLOOP;    IF TmP2Hash.miVtoLtxt[j] = TmP2Hash.NoTxt THEN      String.AppendString[str, "beginning m-i "L]    ELSE      BEGIN      Stream.SetPosition[TmFile.stStream, TmP2Hash.miVtoLtxt[j]];      ReadLabelFromST[name];      String.AppendString[str, name];      IF mi <= j THEN RETURN;      String.AppendString[str, " + "L];      String.AppendNumber[str, mi - j, 16];      END;    END;  -- end AppendSymbolName  MoveExportsAndCheck: PROCEDURE =    BEGIN    nextEP: LONG POINTER TO TmP2Hash.ExportDataRecPtr ¬ @TmP2Hash.exportRecList;    FinalSTScan: PROCEDURE [hePtr: TmP2Hash.Pass2HashEntryPtr] =      BEGIN      export: BOOLEAN ¬ hePtr.ptr.export;      import: BOOLEAN ¬ hePtr.ptr.import;      incons: BOOLEAN ¬ hePtr.ptr.incons;      target: BOOLEAN ¬ hePtr.ptr.target;      isCycle: Cycle ¬ hePtr.ptr.isCycle;      needsCycle: Cycle ¬ hePtr.ptr.needsCycle;      tempP: TmP2Hash.RefChainPtr;      WITH x: hePtr.ptr­ SELECT FROM        notFound => {          IF export THEN SymbolError[notFexport, hePtr.key];          IF import THEN SymbolError[notFimport, hePtr.key];          IF NOT export AND NOT import AND NOT incons THEN            SymbolError[notFound, hePtr.key];          IF incons AND NOT target THEN SymbolError[notarganon, hePtr.key];          IF NOT export AND NOT import AND incons THEN {            tempP ¬ x.refChain;            UNTIL tempP = NIL DO  -- satisfy ref chain              TmP2Hash.miLtoV[tempP.labIndex] ¬ TmP2Hash.curMI;              tempP ¬ tempP.next;              ENDLOOP;            TmP2Hash.curMI ¬ TmP2Hash.curMI + 1;            };          };        found =>          BEGIN          IF export THEN            BEGIN            nextEP­ ¬ TmP2Hash.GetXSpace[SIZE[TmP2Hash.ExportDataRec]];            nextEP.id ¬ TmP2Hash.curID;            nextEP.miIndex ¬ x.miIndex;            nextEP.next ¬ NIL;            nextEP.s ¬ TmP2Hash.GetXString[hePtr.key.length];            String.AppendString[nextEP.s, hePtr.key];            nextEP ¬ @nextEP.next;            END;          IF import THEN SymbolError[import, hePtr.key]          ELSE {  -- cycle check            };          IF isCycle # cX AND needsCycle # x AND needsCycle # isCycle THEN            SymbolError[wrongcycle, hePtr.key];          END;        impVal =>          BEGIN          IF export THEN            BEGIN            nextEP­ ¬ TmP2Hash.GetXSpace[SIZE[TmP2Hash.ExportDataRec]];            nextEP.id ¬ x.expPtr.id;            nextEP.addr ¬ x.expPtr.addr;            nextEP.miIndex ¬ Empty;            nextEP.next ¬ NIL;            nextEP.s ¬ TmP2Hash.GetXString[hePtr.key.length];            String.AppendString[nextEP.s, hePtr.key];            nextEP ¬ @nextEP.next;            END;          END;        ENDCASE;      END;  -- end FinalSTScan    TmP2Hash.realMI ¬ TmP2Hash.curMI;    TmP2Hash.DisplayPass2Hash[FinalSTScan];    END;  -- end MoveExportsAndCheck  Pass2: PUBLIC PROCEDURE[] =    BEGIN    Pass2Init0[];    TmFile.OpenStFile[];    ReadSIFiles[];    ReadFBFiles[];    MoveExportsAndCheck[];    Pass2Part2[];    END;  -- end Pass2  Pass2Init0: PROCEDURE =    BEGIN    i: CARDINAL;    TmP2Hash.miVtoLtxt ¬ TmP2Hash.GetMiSpace[SIZE[TmP2Hash.MiVtoLtxt]];    TmP2Hash.miVtoR ¬ TmP2Hash.GetMiSpace[SIZE[TmP2Hash.MiVtoR]];    FOR i IN [0..5120) DO      TmP2Hash.miVtoLtxt[i] ¬ TmP2Hash.NoTxt;      TmP2Hash.miVtoR[i] ¬ TmP2Hash.Not;      ENDLOOP;    TmP2Hash.miLtoV ¬ TmP2Hash.GetMiSpace[SIZE[TmP2Hash.MiLtoV]];    TmP2Hash.mi2Res ¬ TmP2Hash.GetMiSpace[SIZE[TmP2Hash.Mi2Res]];    FOR i IN [0..4096) DO TmP2Hash.mi2Res[i] ¬ FALSE; ENDLOOP;    END;  -- end Pass2Init1  ProcessExports: PROCEDURE =    BEGIN    hePtr: TmP2Hash.Pass2HashEntryPtr;    str: LONG STRING;    strBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[@str.text], startIndex: 0, stopIndexPlusOne: 0      -- dynamic -- ];    tempP: TmP2Hash.RefChainPtr;    xrp: TmP2Hash.ExportRecPtr ¬ TmP2Hash.GetPass2Space[SIZE[TmP2Hash.ExportRec]];    xrpBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[xrp], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[TmP2Hash.ExportRec]];    DO  -- for each export record      [] ¬ Stream.GetBlock[TmFile.fbInStream, xrpBlock];      IF xrp.length = 0 THEN EXIT;  -- we are at end of file      str ¬ TmP2Hash.GetPass2Space[String.WordsForString[xrp.length]];      str­ ¬ [length: xrp.length, maxlength: xrp.length, text:];      strBlock.stopIndexPlusOne ¬ xrp.length;      [] ¬ Stream.GetBlock[TmFile.fbInStream, strBlock];      hePtr ¬ TmP2Hash.FindPass2Label[str];      IF hePtr = NIL THEN LOOP;  -- not seen yet      IF NOT hePtr.ptr.import THEN LOOP;  -- not used here      WITH x: hePtr.ptr­ SELECT FROM        found => NULL;  -- previously caused error        notFound =>          BEGIN          tempP ¬ x.refChain;          UNTIL tempP = NIL DO  -- satisfy ref chain            TmP2Hash.miLtoV[tempP.labIndex] ¬ TmP2Hash.curMI;            tempP ¬ tempP.next;            ENDLOOP;          TmP2Hash.miVtoR[TmP2Hash.curMI] ¬ xrp.addr;          TmP2Hash.curMI ¬ TmP2Hash.curMI + 1;          hePtr.ptr­ ¬ TmP2Hash.Pass2Entry[            export: hePtr.ptr.export, import: TRUE, incons: hePtr.ptr.incons,            isCycle: x, needsCycle: x, entry: impVal[xrp]];          xrp ¬ TmP2Hash.GetPass2Space[SIZE[TmP2Hash.ExportRec]];          END;        impVal =>          BEGIN IF xrp.id # x.expPtr.id THEN SymbolError[export, hePtr.key]; END;        ENDCASE;      ENDLOOP;  -- end for each export record    END;  -- end ProcessExports  PutOutRegister: PROCEDURE [Mptr: TmAssembler.MEntryPtr] =    BEGIN    lsr: LabelSymbolRec;    lsrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@lsr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LabelSymbolRec]];    lsr ¬ LabelSymbolRec[      external: FALSE, labIndex: 0, length: Mptr­.key.length, element: regU[0]];    WITH Mptr­.ptr SELECT FROM      register =>        BEGIN        SELECT registerType FROM          R => lsr.element ¬ regR[regnum];          RH => lsr.element ¬ regRH[regnum];          U => lsr.element ¬ regU[regnum];          ENDCASE => RETURN;        END;      ENDCASE => RETURN;    [] ¬ Stream.PutBlock[TmFile.stStream, lsrBlock];    [] ¬ Stream.PutBlock[      TmFile.stStream, Environment.Block[      blockPointer: LOOPHOLE[@Mptr­.key.text], startIndex: 0,      stopIndexPlusOne: lsr.length]];    -- for Alto Mesa compatibility    IF lsr.length MOD 2 = 1 THEN Stream.PutChar[TmFile.stStream, Ascii.SP];    END;  -- end PutOutRegister  PutOutToST: PROCEDURE [hePtr: TmP2Hash.Pass2HashEntryPtr] =    BEGIN    lsr: LabelSymbolRec;    lsrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@lsr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LabelSymbolRec]];    lsr ¬ LabelSymbolRec[      external: FALSE, pad3: 0, labIndex: 0, length: hePtr­.key.length,      element: label[pad1: 0, miIndex: 0]];    WITH x: hePtr.ptr­ SELECT FROM      found => lsr.element ¬ label[pad1: 0, miIndex: x.miIndex];      ENDCASE;    [] ¬ Stream.PutBlock[TmFile.stStream, lsrBlock];    [] ¬ Stream.PutBlock[      TmFile.stStream, Environment.Block[      blockPointer: LOOPHOLE[@hePtr­.key.text], startIndex: 0,      stopIndexPlusOne: lsr.length]];    -- for Alto Mesa compatibility    IF lsr.length MOD 2 = 1 THEN Stream.PutChar[TmFile.stStream, Ascii.SP];    END;  -- end PutOutToST  ReadFBFiles: PROCEDURE =    BEGIN    fbr: FinalBinaryRec;    fbrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@fbr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[FinalBinaryRec]];    UNTIL TmFile.OpenNextFb[] DO  -- for each fb file      DO  -- for each fb record        [] ¬ Stream.GetBlock[TmFile.fbInStream, fbrBlock];        IF fbr.addr = 177777B THEN EXIT;        TmP2Hash.mi2Res[fbr.addr] ¬ TRUE;        ENDLOOP;  -- end of fb record      ProcessExports[];      ENDLOOP;  -- end of fb file    END;  ReadLabelFromST: PUBLIC PROCEDURE [str: LONG STRING] =    BEGIN    lsr: LabelSymbolRec;    lsrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@lsr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LabelSymbolRec]];    [] ¬ Stream.GetBlock[TmFile.stStream, lsrBlock];    [] ¬ Stream.GetBlock[      TmFile.stStream, Environment.Block[      blockPointer: LOOPHOLE[@str.text], startIndex: 0,      stopIndexPlusOne: lsr.length]];    str.length ¬ lsr.length;    END;  -- end ReadLabelFromST  ReadSIFiles: PROCEDURE =    BEGIN    miIoffset, labIoffset: CARDINAL ¬ 0;    misize, labsize: CARDINAL ¬ 0;    lsr: LabelIntRec ¬ LabelIntRec[miIndex: Empty];    lsrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@lsr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[LabelIntRec]];    hePtr: TmP2Hash.Pass2HashEntryPtr;    refChainPtr: TmP2Hash.RefChainPtr;    stIndex: CARDINAL ¬ 0;    str: LONG STRING ¬ [64];    tempP: TmP2Hash.RefChainPtr;    TmP2Hash.curMI ¬ TmP2Hash.miIoff[0] ¬ TmP2Hash.labIoff[0] ¬ 0;    -- first put out registers    IF NOT TmControl.noFinalFiles THEN TmModule.DisplayM[PutOutRegister];    TmModule.ReleaseMTSpace[];    -- next read each si file    UNTIL TmFile.OpenNextSi[] OR TmP2Hash.errorLevel > TmP2Hash.bad DO  -- for each si file      miIoffset ¬ TmP2Hash.miIoff[stIndex];      labIoffset ¬ TmP2Hash.labIoff[stIndex];      UNTIL TmP2Hash.errorLevel > TmP2Hash.bad DO  -- for each si record        [] ¬ Stream.GetBlock[TmFile.siStream, lsrBlock];        IF lsr.length = 0 THEN          BEGIN  -- we are at end of file          --update offsets and save for reading ml files          stIndex ¬ stIndex + 1;          misize ¬ Stream.GetWord[TmFile.siStream];          labsize ¬ Stream.GetWord[TmFile.siStream];          TmFile.LogText["The number of micro-instructions in this file =  "L];          str.length ¬ 0;          String.AppendDecimal[str, misize];          TmFile.LogLine[str];          IF TmP2Hash.miIoff[stIndex - 1] + misize > 4096 THEN            BEGIN            TmP2Hash.errorLevel ¬ 200;            TmFile.LogErrLine["You have more than 4096 m-i's."L];            EXIT;            END;          TmP2Hash.curMI ¬ TmP2Hash.miIoff[stIndex] ¬            TmP2Hash.miIoff[stIndex - 1] + misize;          TmP2Hash.labIoff[stIndex] ¬ TmP2Hash.labIoff[stIndex - 1] + labsize;          EXIT;  -- get next si file          END;        IF lsr.found AND (lsr.miIndex + miIoffset > 4096) THEN          BEGIN          TmP2Hash.errorLevel ¬ 200;          TmFile.LogErrLine["You have more than 4096 m-i's."L];          EXIT;          END;        str.length ¬ lsr.length;        [] ¬ Stream.GetBlock[          TmFile.siStream, Environment.Block[          blockPointer: LOOPHOLE[@str.text], startIndex: 0,          stopIndexPlusOne: lsr.length]];        hePtr ¬ TmP2Hash.FindPass2Label[str];        IF hePtr = NIL THEN          BEGIN  -- not seen yet          hePtr ¬ TmP2Hash.GetPass2Space[            SIZE[TmP2Hash.Pass2HashEntry] + SIZE[TmP2Hash.Pass2Entry] +              String.WordsForString[str.length]];          hePtr.ptr ¬ LOOPHOLE[hePtr + SIZE[TmP2Hash.Pass2HashEntry]];          hePtr.key ¬ LOOPHOLE[hePtr.ptr + SIZE[TmP2Hash.Pass2Entry]];          hePtr.key­ ¬ [length: 0, maxlength: str.length, text:];          String.AppendString[hePtr.key, str];          hePtr.next ¬ NIL;          TmP2Hash.InsertPass2Hash[hePtr];          IF lsr.found THEN            BEGIN  -- new found            hePtr.ptr­ ¬ TmP2Hash.Pass2Entry[              export: lsr.export, import: lsr.import, incons: lsr.incons,              target: lsr.target, isCycle: lsr.isCycle,              needsCycle: lsr.needsCycle, entry: found[lsr.miIndex + miIoffset]];            TmP2Hash.miLtoV[lsr.labIndex + labIoffset] ¬ lsr.miIndex + miIoffset;            TmP2Hash.miVtoLtxt[lsr.miIndex + miIoffset] ¬ Stream.GetPosition[              TmFile.stStream];            PutOutToST[hePtr];            END  -- end new found          ELSE            BEGIN  -- new not found            refChainPtr ¬ TmP2Hash.GetPass2Space[SIZE[TmP2Hash.RefChain]];            refChainPtr­ ¬ TmP2Hash.RefChain[lsr.labIndex + labIoffset, NIL];            hePtr.ptr­ ¬ TmP2Hash.Pass2Entry[              export: lsr.export, import: lsr.import, incons: lsr.incons,              target: lsr.target, isCycle: lsr.isCycle,              needsCycle: lsr.needsCycle, entry: notFound[refChainPtr]];            END;  -- end new not found          END  -- end not seen yet        ELSE          BEGIN  -- seen before          hePtr.ptr.export ¬ hePtr.ptr.export OR lsr.export;          hePtr.ptr.import ¬ hePtr.ptr.import OR lsr.import;          hePtr.ptr.incons ¬ hePtr.ptr.incons OR lsr.incons;          hePtr.ptr.target ¬ hePtr.ptr.target OR lsr.target;          hePtr.ptr.needsCycle ¬            IF (lsr.needsCycle = cX OR hePtr.ptr.needsCycle = cX) THEN cX            ELSE              IF lsr.needsCycle = x THEN hePtr.ptr.needsCycle              ELSE                IF hePtr.ptr.needsCycle = x THEN lsr.needsCycle                ELSE                  IF lsr.needsCycle # hePtr.ptr.needsCycle THEN cX                  ELSE lsr.needsCycle;          IF lsr.found THEN            BEGIN  -- (found) and label seen before            hePtr.ptr.isCycle ¬ lsr.isCycle;            WITH x: hePtr.ptr­ SELECT FROM              found => BEGIN SymbolError[multiple, hePtr.key]; END;              notFound =>                BEGIN                tempP ¬ x.refChain;                UNTIL tempP = NIL DO                  TmP2Hash.miLtoV[tempP.labIndex] ¬ lsr.miIndex + miIoffset;                  tempP ¬ tempP.next;                  ENDLOOP;                hePtr.ptr­ ¬ TmP2Hash.Pass2Entry[                  export: hePtr.ptr.export, import: hePtr.ptr.import,                  incons: hePtr.ptr.incons, target: hePtr.ptr.target,                  isCycle: hePtr.ptr.isCycle, needsCycle: hePtr.ptr.needsCycle,                  entry: found[lsr.miIndex + miIoffset]];                TmP2Hash.miLtoV[lsr.labIndex + labIoffset] ¬                  lsr.miIndex + miIoffset;                TmP2Hash.miVtoLtxt[lsr.miIndex + miIoffset] ¬ Stream.GetPosition[                  TmFile.stStream];                PutOutToST[hePtr];                END;              ENDCASE;            END  -- end (found) and label seen before          ELSE            BEGIN  -- (NOT found) and label seen before            WITH x: hePtr.ptr­ SELECT FROM              found =>                BEGIN TmP2Hash.miLtoV[lsr.labIndex + labIoffset] ¬ x.miIndex; END;              notFound =>                BEGIN  -- chain onto refChain                tempP ¬ x.refChain;                x.refChain ¬ TmP2Hash.GetPass2Space[SIZE[TmP2Hash.RefChain]];                x.refChain.labIndex ¬ lsr.labIndex + labIoffset;                x.refChain.next ¬ tempP;                END;              ENDCASE;            END;  -- end (NOT found) and label seen before          END;  -- end seen before        ENDLOOP;  -- for each si record      ENDLOOP;  -- for each si file    TmFile.LogText["The TOTAL number of micro-instructions =  "L];    str.length ¬ 0;    String.AppendNumber[str, TmP2Hash.curMI, 10];    TmFile.LogLine[str];    END;  -- end ReadSIFiles  SymbolError: PROCEDURE [    type: {      undefined, multiple, import, export, notFexport, notFimport, notFound,      notarganon, wrongcycle}, s: LONG STRING] =    BEGIN    IF TmP2Hash.errorLevel < TmP2Hash.bad THEN      TmFile.LogErrLine["Allocation Errors:"L];    TmP2Hash.errorLevel ¬ 200;    TmFile.LogText[      (SELECT type FROM         undefined => "symbol is Undefined : "L,         multiple => "symbol is Multiply defined : "L,         import => "symbol is imported AND defined : "L,         export => "symbol is imported AND Multiply exported : "L,         notFexport => "symbol is exported AND NOT defined : "L,         notFimport => "symbol is imported AND NOT exported : "L,         notarganon => "symbol is used as base address AND NOT gone to : "L,         wrongcycle => "symbol is wrong cycle : "L,         ENDCASE => "symbol was not found : "L)];    TmFile.LogLine[s];    END;  -- end SymbolError  END...    -- Log  -- 16-Jul-82 10:11:23 - ETN        - TrinityMass Version 1  -- 115-Jul-83 16:30:00 - JAC        - Klamath changes. Changed to agree with MassBurdockInterface.mesa.  (ie. LabelSymbolRec changed. pad became either pad3 or pad1 because the compiler complains about multiply defined labels now  -- Time: 26-Sep-84 20:57:42	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- IOPEvaler.mesa, HGM, 10-Feb-83 17:36:16DIRECTORY  Ascii USING [CR, LF, FF, SP, TAB],  Inline USING [LowHalf],  String USING [AppendString, SubString, SubStringDescriptor],    IOP USING [Address, Register],  Evaluate USING [Error, EvaluateSubString, Type, unspecified, Value],  IOPSyms USING [    Error, LookUpInSymbolTable, LookUpInExternalSymbolTable, LookUpInRegTable, Symbol, Type],  StringExtras USING [StringToLongCardinal];IOPEvaler: PROGRAM  IMPORTS String, Evaluate, Inline, IOPSyms, StringExtras  EXPORTS IOPSyms =  BEGIN  Eval: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [IOPSyms.Symbol] =    BEGIN    type: Evaluate.Type;    value: Evaluate.Value;    t: IOPSyms.Type;    atsign, word, instruction: BOOLEAN ¬ FALSE;    ss: String.SubStringDescriptor ¬ [base: s, offset: 0, length: s.length];    TrimSubString[@ss];    SELECT TRUE FROM      ss.base[ss.offset] = '@ =>        BEGIN        ss ¬ [base: ss.base, offset: ss.offset + 1, length: ss.length - 1];	atsign ¬ TRUE;        END;      ss.base[ss.offset] = '$ =>        BEGIN        ss ¬ [base: ss.base, offset: ss.offset + 1, length: ss.length - 1];	word ¬ TRUE;        END;      ss.base[ss.offset] = '% =>        BEGIN        ss ¬ [base: ss.base, offset: ss.offset + 1, length: ss.length - 1];	instruction ¬ TRUE;        END;      ENDCASE => NULL;    [type, value] ¬ Evaluate.EvaluateSubString[@ss, Lookup !        Evaluate.Error => ERROR IOPSyms.Error[reason] ];    t ¬ IF type = Evaluate.unspecified THEN number ELSE LOOPHOLE[type];    IF atsign THEN t ¬ at;    IF word THEN t ¬ word;    IF instruction THEN t ¬ instruction;    SELECT t FROM      number => RETURN[[number[Inline.LowHalf[value]]]];      at => RETURN[[at[Inline.LowHalf[value]]]];      reg => RETURN[[reg[Inline.LowHalf[value]]]];      pair => RETURN[[pair[Inline.LowHalf[value]]]];      byte => RETURN[[byte[Inline.LowHalf[value]]]];      word => RETURN[[word[Inline.LowHalf[value]]]];      instruction => RETURN[[instruction[Inline.LowHalf[value]]]];      ENDCASE => ERROR;    END;        Lookup: PROCEDURE [s: LONG STRING] RETURNS [type: Evaluate.Type, value: Evaluate.Value] =    BEGIN    ok: BOOLEAN;    val: IOPSyms.Symbol;    ste: IOP.Address;    [ok, ste] ¬ IOPSyms.LookUpInExternalSymbolTable[s];    IF ok THEN RETURN[LOOPHOLE[IOPSyms.Type[byte]], LONG[ste]];    [ok, ste] ¬ IOPSyms.LookUpInSymbolTable[s];    IF ok THEN RETURN[LOOPHOLE[IOPSyms.Type[byte]], LONG[ste]];    [ok, val] ¬ IOPSyms.LookUpInRegTable[s];    IF ok THEN      BEGIN      WITH val SELECT FROM        number => value ¬ n;        at => value ¬ to;        reg => value ¬ LOOPHOLE[reg, CARDINAL];        pair => value ¬ LOOPHOLE[pair, CARDINAL];        byte => value ¬ mem;        word => value ¬ mem;        instruction => value ¬ mem;        ENDCASE => ERROR;      RETURN[LOOPHOLE[val.type], value];      END;    [ok, value] ¬ StringExtras.StringToLongCardinal[s];    IF ok THEN RETURN[Evaluate.unspecified, value];    BEGIN    temp: LONG STRING = [100];    String.AppendString[temp, "Undefined Symbol: "L];    String.AppendString[temp, s];    ERROR IOPSyms.Error[temp];    END;    END;  TrimSubString: PROCEDURE [ss: String.SubString] =    BEGIN    FOR i: CARDINAL IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove leading blanks        ss.length ¬ ss.length - (i - ss.offset);        ss.offset ¬ i;	EXIT;	END;      REPEAT FINISHED =>        BEGIN  --all blanks	ss.length ¬ 0;        RETURN;	END;      ENDLOOP;    FOR i: CARDINAL DECREASING IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove trailing blanks        ss.length ¬ ss.length - (ss.offset + ss.length - 1 - i);	EXIT;	END;      ENDLOOP;    END;      BlankCharacter: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] =    BEGIN    SELECT c FROM      Ascii.FF, Ascii.SP, Ascii.CR, Ascii.LF, Ascii.TAB => RETURN[TRUE];      ENDCASE => RETURN[FALSE];    END;    END.
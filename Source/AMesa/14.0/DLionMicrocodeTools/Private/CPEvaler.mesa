-- Copyright (C) 1983, 1985  by Xerox Corporation. All rights reserved. -- CPEvaler.mesa, HGM,  7-Feb-85  2:14:54DIRECTORY  Ascii USING [CR, LF, FF, SP, TAB],  Inline USING [LowHalf],  String USING [AppendString, Equivalent, SubString, SubStringDescriptor],    CP USING [    Cycle, IOReg, Link, Map, OtherReg, RealCS, RealMemory, RReg,    Task, UReg, VirturalMemory],  CPSymbols USING [    Error, LookupInCSTable, LookupInRRegTable, LookupInRHTable, LookupInURegTable,    nullRealCS, nullVirturalCS, RealToVirturalCS, Symbol, Type, VirturalCS, VirturalToRealCS],  Evaluate USING [Error, EvaluateSubString, Type, unspecified, Value],  StringExtras USING [StringToLongCardinal];CPEvaler: PROGRAM  IMPORTS Inline, String, CPSymbols, Evaluate, StringExtras  EXPORTS CPSymbols =  BEGIN    GetPcCycleAndTask: PUBLIC PROCEDURE [s: LONG STRING]    RETURNS [pc: CP.RealCS, cycle: CP.Cycle, task: CP.Task] =    BEGIN    symbol: CPSymbols.Symbol ¬ Eval[s];    WITH symbol SELECT FROM      number =>        BEGIN	virt: CPSymbols.VirturalCS;	pc ¬ Inline.LowHalf[n];	[virt, cycle, task] ¬ CPSymbols.RealToVirturalCS[pc];	IF virt = CPSymbols.nullVirturalCS THEN ERROR CPSymbols.Error["Can't find task info"L];	END;      realCS =>        BEGIN	virt: CPSymbols.VirturalCS;	pc ¬ real;	[virt, cycle, task] ¬ CPSymbols.RealToVirturalCS[pc];	IF virt = CPSymbols.nullVirturalCS THEN ERROR CPSymbols.Error["Can't find task info"L];	END;      virtCS =>        BEGIN	[pc, cycle, task] ¬ CPSymbols.VirturalToRealCS[virt];	IF pc = CPSymbols.nullRealCS THEN ERROR CPSymbols.Error["Can't translate to a real CS address"L];	END;      ENDCASE => ERROR CPSymbols.Error["CP ControlStore address required"L];    END;	  GetPc: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [pc: CP.RealCS] =    BEGIN    symbol: CPSymbols.Symbol ¬ Eval[s];    WITH symbol SELECT FROM      number => pc ¬ Inline.LowHalf[n];      realCS => pc ¬ real;      virtCS =>        BEGIN	[pc, , ] ¬ CPSymbols.VirturalToRealCS[virt];	IF pc = CPSymbols.nullRealCS THEN ERROR CPSymbols.Error["Can't translate to a real CS address"L];	END;      ENDCASE => ERROR CPSymbols.Error["CP ControlStore address required"L];    END;	  Eval: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [CPSymbols.Symbol] =    BEGIN    type: Evaluate.Type;    value: Evaluate.Value;    shortValue: CARDINAL;    pointer: LONG POINTER;    t: CPSymbols.Type;    rAndRH: BOOLEAN ¬ FALSE;    ss: String.SubStringDescriptor;    IF s = NIL OR s.length = 0 THEN ERROR CPSymbols.Error["Can't evaluate Empty string"L];    ss ¬ [base: s, offset: 0, length: s.length];    TrimSubString[@ss];    SELECT TRUE FROM      ss.base[ss.offset] = '$ =>        BEGIN        ss ¬ [base: ss.base, offset: ss.offset + 1, length: ss.length - 1];	rAndRH ¬ TRUE;        END;      ENDCASE => NULL;    [type, value] ¬ Evaluate.EvaluateSubString[@ss, Lookup !        Evaluate.Error => ERROR CPSymbols.Error[reason] ];    shortValue ¬ Inline.LowHalf[value];    pointer ¬ LOOPHOLE[value];    t ¬ IF type = Evaluate.unspecified THEN number ELSE LOOPHOLE[type];    IF rAndRH THEN      BEGIN      IF t = rReg OR t = rH THEN t ¬ rAndRh      ELSE InconsistentExpression[];      END;    SELECT t FROM      number => RETURN[[number[value]]];      tpc =>        BEGIN	IF value ~IN CP.Task THEN AddressOutOfRange[];        RETURN[[tpc[shortValue]]];	END;      tc =>        BEGIN	IF value ~IN CP.Task THEN AddressOutOfRange[];        RETURN[[tc[shortValue]]];	END;      link =>        BEGIN	IF value ~IN CP.Link THEN AddressOutOfRange[];        RETURN[[link[shortValue]]];	END;      realCS => RETURN[[realCS[shortValue]]];      virtCS => RETURN[[virtCS[shortValue]]];      rReg =>        BEGIN	IF value ~IN CP.RReg THEN AddressOutOfRange[];	RETURN[[rReg[shortValue]]];	END;      rH =>        BEGIN	IF value ~IN CP.RReg THEN AddressOutOfRange[];	RETURN[[rH[shortValue]]];	END;      rAndRh =>        BEGIN	IF value ~IN CP.RReg THEN AddressOutOfRange[];	RETURN[[rAndRh[shortValue]]];	END;      uReg =>        BEGIN	IF value ~IN CP.UReg THEN AddressOutOfRange[];	RETURN[[uReg[shortValue]]];	END;      ioIn => RETURN[[ioIn[shortValue]]];      ioOut => RETURN[[ioOut[shortValue]]];      map =>        BEGIN	IF value ~IN CP.Map THEN AddressOutOfRange[];	RETURN[[map[shortValue]]];	END;      real => RETURN[[real[pointer]]];      virt => RETURN[[virt[pointer]]];      other => RETURN[[other[LOOPHOLE[shortValue]]]];      pc => RETURN[[pc[]]];      ENDCASE => ERROR;    END;        Lookup: PROCEDURE [s: LONG STRING] RETURNS [type: Evaluate.Type, value: Evaluate.Value] =    BEGIN    ok: BOOLEAN;    virt: CPSymbols.VirturalCS;    r: CP.RReg;    u: CP.UReg;    symbol: CPSymbols.Symbol;    [ok, virt] ¬ CPSymbols.LookupInCSTable[s];    IF ok THEN RETURN[LOOPHOLE[CPSymbols.Type[virtCS]], LONG[virt]];    [ok, r] ¬ CPSymbols.LookupInRRegTable[s];    IF ok THEN RETURN[LOOPHOLE[CPSymbols.Type[rReg]], LONG[r]];    [ok, r] ¬ CPSymbols.LookupInRHTable[s];    IF ok THEN RETURN[LOOPHOLE[CPSymbols.Type[rH]], LONG[r]];    [ok, u] ¬ CPSymbols.LookupInURegTable[s];    IF ok THEN RETURN[LOOPHOLE[CPSymbols.Type[uReg]], LONG[u]];    [ok, symbol] ¬ StringAsSpecial[s];    IF ok THEN      BEGIN      type ¬ LOOPHOLE[symbol.type];      WITH symbol SELECT FROM        number => value ¬ n;        tpc, tc => value ¬ task;        link => value ¬ link;        realCS => value ¬ real;        virtCS => value ¬ virt;        rReg, rH => value ¬ r;        uReg => value ¬ u;        ioIn, ioOut => value ¬ io;        map => value ¬ map;        real => value ¬ LOOPHOLE[real];        virt => value ¬ LOOPHOLE[virt];        other => value ¬ LONG[LOOPHOLE[other]];	pc => value ¬ 0;        ENDCASE => ERROR;      RETURN;      END;    [ok, value] ¬ StringExtras.StringToLongCardinal[s];    IF ok THEN RETURN[Evaluate.unspecified, value];    BEGIN    temp: LONG STRING = [100];    String.AppendString[temp, "Undefined Symbol: "L];    String.AppendString[temp, s];    ERROR CPSymbols.Error[temp];    END;    END;  StringAsSpecial: PROCEDURE [s: LONG STRING] RETURNS [BOOLEAN, CPSymbols.Symbol] =    BEGIN    SELECT TRUE FROM      String.Equivalent[s, ".CR"L] => RETURN[TRUE, [realCS[0]]];      String.Equivalent[s, ".CV"L] => RETURN[TRUE, [virtCS[0]]];      String.Equivalent[s, ".RH"L] => RETURN[TRUE, [rH[0]]];      String.Equivalent[s, ".R"L] => RETURN[TRUE, [rReg[0]]];      String.Equivalent[s, ".U"L] => RETURN[TRUE, [uReg[0]]];      String.Equivalent[s, ".TPC"L] => RETURN[TRUE, [tpc[0]]];      String.Equivalent[s, ".TC"L] => RETURN[TRUE, [tc[0]]];      String.Equivalent[s, ".LINK"L] => RETURN[TRUE, [link[0]]];      String.Equivalent[s, ".MAP"L] => RETURN[TRUE, [map[0]]];      String.Equivalent[s, ".MR"L] => RETURN[TRUE, [real[NIL]]];      String.Equivalent[s, ".MV"L] => RETURN[TRUE, [virt[NIL]]];      String.Equivalent[s, ".IOIN"L] => RETURN[TRUE, [ioIn[0]]];      String.Equivalent[s, ".IOXIN"L] => RETURN[TRUE, [ioIn[0]]];      String.Equivalent[s, ".IOOUT"L] => RETURN[TRUE, [ioOut[0]]];      String.Equivalent[s, "Q"L] => RETURN[TRUE, [other[q]]];      String.Equivalent[s, ".Q"L] => RETURN[TRUE, [other[q]]];      String.Equivalent[s, ".IB"L] => RETURN[TRUE, [other[ib]]];      String.Equivalent[s, ".PC16"L] => RETURN[TRUE, [other[pc16]]];      String.Equivalent[s, ".STACKP"L] => RETURN[TRUE, [other[stackP]]];      String.Equivalent[s, ".IBPTR"L] => RETURN[TRUE, [other[ibPtr]]];      String.Equivalent[s, ".MINT"L] => RETURN[TRUE, [other[mInt]]];      String.Equivalent[s, ".EKERR"L] => RETURN[TRUE, [other[ekErr]]];      String.Equivalent[s, "L0"L] => RETURN[TRUE, [link[0]]];      String.Equivalent[s, "L1"L] => RETURN[TRUE, [link[1]]];      String.Equivalent[s, "L2"L] => RETURN[TRUE, [link[2]]];      String.Equivalent[s, "L3"L] => RETURN[TRUE, [link[3]]];      String.Equivalent[s, "L4"L] => RETURN[TRUE, [link[4]]];      String.Equivalent[s, "L5"L] => RETURN[TRUE, [link[5]]];      String.Equivalent[s, "L6"L] => RETURN[TRUE, [link[6]]];      String.Equivalent[s, "L7"L] => RETURN[TRUE, [link[7]]];      String.Equivalent[s, ".PC"L] => RETURN[TRUE, [pc[]]];      ENDCASE => RETURN[FALSE, ];    END;        InconsistentExpression: PROCEDURE =    BEGIN    foo: BOOLEAN ¬ TRUE;    IF foo THEN ERROR CPSymbols.Error["Inconsistent expression"L];    END;      AddressOutOfRange: PROCEDURE =    BEGIN    foo: BOOLEAN ¬ TRUE;    IF foo THEN ERROR CPSymbols.Error["Address out of range"L];    END;      TrimSubString: PROCEDURE [ss: String.SubString] =    BEGIN    FOR i: CARDINAL IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove leading blanks        ss.length ¬ ss.length - (i - ss.offset);        ss.offset ¬ i;	EXIT;	END;      REPEAT FINISHED =>        BEGIN  --all blanks	ss.length ¬ 0;        RETURN;	END;      ENDLOOP;    FOR i: CARDINAL DECREASING IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN        BEGIN  --  remove trailing blanks        ss.length ¬ ss.length - (ss.offset + ss.length - 1 - i);	EXIT;	END;      ENDLOOP;    END;      BlankCharacter: PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] =    BEGIN    SELECT c FROM      Ascii.FF, Ascii.SP, Ascii.CR, Ascii.LF, Ascii.TAB => RETURN[TRUE];      ENDCASE => RETURN[FALSE];    END;    END.
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- IOPPaneler.mesa, HGM, 22-Nov-83  5:57:10DIRECTORY  Heap USING [systemZone],  String USING [AppendChar, AppendNumber, AppendString, CopyToNewString],  Tool USING [AddThisSW],  ToolWindow USING [CreateSubwindow, nullBox],  Window USING [Box, Handle],  WindowFont USING [CharWidth, defaultFont, FontHeight, Handle],    IOP USING [Address, Instruction, Register],  IOPKernel USING [    Error, InKernel, ReadInstruction, ReadRegister, ReadPair, ReadMemory, ReadMemoryWord,    WriteRegister, WritePair, WriteMemory, WriteMemoryWord],  IOPPanel USING [],  IOPSyms USING [    AppendInstruction, AppendMemoryAddress, AppendRegister, AppendRegPair,    Error, Eval, Symbol, SymbolicExists],  PanelSW USING [    Clear, ClientError, ClientProcsObject, Create, Destroy, FreeRSProcType,    LHTypeInEvalProcType, Handle, ModifyTypeInProcType, ReadTargetProcType, RegisterSpec,    RHTypeInEvalProcType, SWType, TileError, TileLayout, Update, WriteTile];IOPPaneler: PROGRAM  IMPORTS    Heap, String,    Tool, ToolWindow, WindowFont,    IOPKernel, IOPSyms, PanelSW  EXPORTS IOPPanel =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  panel: PanelSW.Handle ¬ NIL;  font: WindowFont.Handle = WindowFont.defaultFont;  fontHeight: INTEGER = WindowFont.FontHeight[font];  digitWidth: INTEGER = WindowFont.CharWidth['0, font];  tileHeight: INTEGER = fontHeight;  tileRows: INTEGER = 17;  tileColumns: INTEGER = 3;  tileFlagLength: INTEGER = digitWidth;  tileLVLength: INTEGER = 12*digitWidth + 4;  tileRVLength: INTEGER = 6*digitWidth + 4;  tileLength: INTEGER = tileFlagLength + tileLVLength + tileRVLength;  tileBoxWidth: INTEGER = tileColumns*(tileLength);  numTiles: INTEGER = tileRows*tileColumns;  rowLayout: ARRAY [0..tileColumns) OF PanelSW.TileLayout ¬ [    [tileFlagLength, tileLVLength, tileRVLength],    [tileFlagLength, tileLVLength, tileRVLength],    [tileFlagLength, tileLVLength, tileRVLength + 23*digitWidth]];  panelProcs: PanelSW.ClientProcsObject ¬ [    FreeRS, LHTypeInEval, NIL, ReadTarget, RHTypeInEval];  RegisterSpec: TYPE = LONG POINTER TO RegisterSpecObject;  RegisterSpecObject: PUBLIC TYPE = IOPSyms.Symbol;  AbsToRep: PROCEDURE [rs: PanelSW.RegisterSpec] RETURNS [RegisterSpec] = INLINE    BEGIN RETURN[LOOPHOLE[rs]] END;  RepToAbs: PROCEDURE [rs: RegisterSpec] RETURNS [PanelSW.RegisterSpec] = INLINE    BEGIN RETURN[LOOPHOLE[rs]] END;  LHTypeInEval: PanelSW.LHTypeInEvalProcType =    BEGIN    value: IOPSyms.Symbol;    display ¬ NIL;    newRs ¬ NIL;    IF typeIn = NIL OR typeIn.length = 0 THEN RETURN;    value ¬ IOPSyms.Eval[typeIn !      IOPSyms.Error => ERROR PanelSW.ClientError[unknown, reason] ];    WITH value SELECT FROM      number => value ¬ [byte[n]];      ENDCASE => NULL;    newRs ¬ AllocateRegisterSpec[value];    IF normalize THEN      BEGIN      temp: STRING ¬ [64];      WITH value SELECT FROM       number => ERROR;       at =>         BEGIN	 String.AppendChar[temp, '@];         IOPSyms.AppendMemoryAddress[temp, to];         END;       reg => IOPSyms.AppendRegister[temp, reg];       pair => IOPSyms.AppendRegPair[temp, pair];       byte => IOPSyms.AppendMemoryAddress[temp, mem];       word =>         BEGIN	 String.AppendChar[temp, '$];         IOPSyms.AppendMemoryAddress[temp, mem];         END;       instruction =>         BEGIN	 String.AppendChar[temp, '%];         IOPSyms.AppendMemoryAddress[temp, mem];         END;       ENDCASE => ERROR;      display ¬ String.CopyToNewString[temp, z];      END    ELSE display ¬ String.CopyToNewString[typeIn, z];    END;      RHTypeInEval: PanelSW.RHTypeInEvalProcType =    BEGIN    myrs: RegisterSpec = AbsToRep[rs];    symbol: IOPSyms.Symbol;    value: CARDINAL;    display ¬ NIL;    IF rs = NIL OR typeIn = NIL OR typeIn.length = 0 THEN RETURN;    IF ~IOPKernel.InKernel[] THEN RETURN;    symbol ¬ IOPSyms.Eval[typeIn !      IOPSyms.Error => ERROR PanelSW.ClientError[unknown, reason] ];    WITH symbol SELECT FROM      number => value ¬ n;      at => ERROR PanelSW.ClientError[readOnly, "Indirect slots are READONLY"L];      reg => ERROR PanelSW.ClientError[readOnly, "Don't understand value of registers"L];      pair => ERROR PanelSW.ClientError[readOnly, "Don't understand value of register pairs"L];      byte => value ¬ mem;      word => value ¬ mem;      instruction => value ¬ mem;      ENDCASE => ERROR;    BEGIN ENABLE IOPKernel.Error => ERROR PanelSW.ClientError[unknown, reason];    WITH myrs SELECT FROM      number => ERROR;      at => ERROR PanelSW.ClientError[readOnly, "Indirect slots are READONLY"L];      reg => IOPKernel.WriteRegister[reg, value];      pair => IOPKernel.WritePair[pair, value];      byte => IOPKernel.WriteMemory[mem, value];      word => IOPKernel.WriteMemoryWord[mem, value];      instruction => PanelSW.ClientError[readOnly, "Not Implemented"L];      ENDCASE => ERROR;    END;    display ¬ ReadTarget[rs, TRUE];    END;      FreeRS: PanelSW.FreeRSProcType = BEGIN IF rs # NIL THEN z.FREE[@rs] END;  AllocateRegisterSpec: PROCEDURE [value: IOPSyms.Symbol]    RETURNS [PanelSW.RegisterSpec] =    BEGIN    rs: RegisterSpec ¬ z.NEW[RegisterSpecObject];    rs­ ¬ value;    RETURN[RepToAbs[rs]]    END;  ReadTarget: PanelSW.ReadTargetProcType =    BEGIN    myrs: RegisterSpec = AbsToRep[rs];    value: CARDINAL;    s ¬ NIL;    IF rs = NIL THEN RETURN;    IF ~IOPKernel.InKernel[] THEN RETURN;    BEGIN ENABLE IOPKernel.Error => ERROR PanelSW.ClientError[unknown, reason];    WITH myrs SELECT FROM      number => ERROR;      at => value ¬ to;      reg => value ¬ IOPKernel.ReadRegister[reg];      pair =>        BEGIN        value ¬ IOPKernel.ReadPair[pair];	IF IOPSyms.SymbolicExists[value] THEN	  BEGIN          s ¬ z.NEW[StringBody[50]];	  String.AppendNumber[s, value, 16];	  String.AppendString[s, " ("L];	  IOPSyms.AppendMemoryAddress[s, value];	  String.AppendString[s, ")"L];	  RETURN;	  END;	END;      byte => value ¬ IOPKernel.ReadMemory[mem];      word => value ¬ IOPKernel.ReadMemoryWord[mem];      instruction =>        BEGIN	ins: IOP.Instruction;	ins ¬ IOPKernel.ReadInstruction[mem];        s ¬ z.NEW[StringBody[30]];	IOPSyms.AppendInstruction[s, ins];	RETURN;	END      ENDCASE => ERROR;    END;    s ¬ z.NEW[StringBody[4]];    String.AppendNumber[s, value, 16];    END;      MakePanelSW: PUBLIC PROCEDURE [    parent: Window.Handle,    err: Window.Handle,    modifyTypeIn: PanelSW.ModifyTypeInProcType,    typeIn: LONG POINTER TO LONG STRING] RETURNS [psw: Window.Handle] =    BEGIN    box: Window.Box ¬ ToolWindow.nullBox;    box.dims.h ¬ tileRows*tileHeight;    panelProcs.modifyTypeIn ¬ modifyTypeIn;    psw ¬ ToolWindow.CreateSubwindow[parent: parent, box: box];    panel ¬ PanelSW.Create[      psw, err, numTiles, DESCRIPTOR[rowLayout], @panelProcs, typeIn];    Tool.AddThisSW[window: parent, sw: psw, swType: PanelSW.SWType[]];    END;      Destroy: PUBLIC PROCEDURE =    BEGIN    IF panel # NIL THEN PanelSW.Destroy[panel];    panel ¬ NIL;    END;  GetPanel: PUBLIC PROCEDURE RETURNS [PanelSW.Handle] = BEGIN RETURN[panel]; END;  Clear: PUBLIC PROCEDURE = BEGIN IF panel # NIL THEN PanelSW.Clear[panel]; END;  Refresh: PUBLIC PROCEDURE = BEGIN IF panel # NIL THEN PanelSW.Update[panel] END;  Initialize: PUBLIC PROCEDURE =    BEGIN    tiles: CARDINAL = 15;    InitString: ARRAY [0..tiles) OF STRING = [      "A"L, "SP"L, "PC"L, "B"L, NIL, NIL, "C"L, NIL, NIL, "D"L, "H"L,      "RIM"L, "E"L, "L"L, "Flags"L];    IF panel = NIL THEN RETURN;    PanelSW.Clear[panel];    FOR tile: CARDINAL IN [0..tiles) DO      PanelSW.WriteTile[        panel, [left, tile], InitString[tile], FALSE !        PanelSW.TileError => CONTINUE];      ENDLOOP    END;  END.
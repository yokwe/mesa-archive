// DESChip.doc, HGM, 19-Feb-84 18:10:34The 16K control store CP board also contains a DES chip.  It's an AMD and/or Zilog 8068.  (AMD also calls it a 9518.)The DES chip is clocked once per click so clicks and clocks are interchangeable in the following discussion.DES works with 56 bit keys and data blocks of 8 (8 bit) bytes.  The 8th bit in each key byte is used for parity.  The encryption algorithm is used in 2 modes.  ECB (Electronic Code Book) takes 8 data bytes and 56 key bits, scrambles things, and produces 8 result bytes.  CBC (Cypher Block Chaining) uses the same basic scrambling algorithim but it also includes a 64 bit vector that is XORed with the data before encryption.  After encrypting each block, the encrypted data is saved for use as the next  64 bit vector.  (You do things in a slightly differnet order when decrypting.)  To encrypt things, you set the desired mode, load the key, and then (with the left hand) start feeding data into the chip and, after a slight delay, (with the right hand) start extracting the encrypted data.  It takes two hands because there is a long pipeline in the chip, and you must overlap things to keep the chip busy.If you keep the pipeline full, the chip will encrypt an 8 byte block in 18 clocks.  That works out to 8.6 megabits/second.  Ignoring the startup problem, if you want to keep the chip busy you have 18 clicks to read 4 words from memory, store 8 bytes into the chip, extract 8 bytes from the chip, and write 4 words to memory.  That's not trivial, you obviously can't do things in that order, but it's not very hard.  (You will probably miss a beat when crossing page boundries and/or when IO tasks steal cycles.)We use the chip in the "Dual-Port Configuration, Multiplexed Control".  There is no way to insert a master key through the auxiliary port.The specs don't quite describe the way we actually use the chip.  They expected it to be used to interface to a disk or tape drive.  That way all the encrypted data would be on the slave port, and you would encrypt by storing clear text into the master port and extracting encrypted data from the slave port.  Decryption would reverse the direction of data flow and store encrypted data into the slave port and read the clear text from teh master port.  We do it differently.  On the DLion, you always store into the master port, and read from the slave port.  Encryption/deryption is selected by using the using appropiate mode bits.The DES chip adds 3 function decodes to a DLion:  DESCtl _ is FZ 09.  It must be issued in c2.   DESCtl does an address strobe cycle to the chip using the data from the Y bus as the address.  This determines where bytes stored into the master port will go.  0 is the data register, 2 is the command register, and 6 is the mode register.    DESMP _ (DES Master Port) is also FZ 09.  It stores a byte of data from the Y bus into the master port.  It is valid in c1 or c3.  If it is used in c3, it must not be used in the following click.  _ DESSP (DES Slave Port) is FZNorm 0A.  (Beware, Mass can't yet process reading things with FZNorm decodes, so the existing boards have blue wired _DESSP to be the same as TIData.)  It reads the a byte from the slave port onto the X bus.  The high byte is cleared.  It can be given in any cycle, but if it is used in c2 or c3, it must not be used in the following click.  There is no way to read any status bits.   In particular you can't tell if the chip gets a key parity error.  Interesting Mode register bits:  00H decrypts in ECB mode.  02H decrypts in CBC mode.  14H encrypts in ECB mode.  16H encrypts in CBC mode.  Interesting Command bytes:  00H resets the chip.  11H loads the encryption key.  12H loads the decryption key.  84H loads the initial vector for CBC decryption.  85H loads the initial vector for CBC encryption.  C0H starts crunching bytes, encrypting or decrypting as setup by the mode.  After setting the mode and/or storing a command, you need to wait 6 clocks.After writing the 8th byte of an input block, you have to wait 6 clocks before storing any more data.  Similarly after reading the 8th byte of an output block, you also have to wait 8 clocks before reading the first byte of the next block.The programmer is responsible for meeting the timing constraints.  The idea it to count cycles.  There isn't time enough to read a status bit.  Besides, there isn't any hardware to read them.Unfortunately, there is no clean way to reset the DES logic.  It's possible to get a byte trapped in the output buffer.  The initialization code should read a byte (even if there isn't one available) and discard it.The state machines used to control the input and output to/from the DES chip have an extra bit that may be helpful for debugging microcode.  It comes on when a byte is read/written before the hardware has emptied/refilled the buffer.  (Unfortunately, the initialization sequence described above will normally set this bit.)Microcode and a (Trinity) Mesa test program are stored on [Idun]<HGM   >DES>.
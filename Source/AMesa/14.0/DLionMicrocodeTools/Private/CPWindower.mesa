-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- CPWindower.mesa, HGM, 14-Feb-84  1:13:28DIRECTORY  Format USING [StringProc],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    DisplayItem, Enumerated, EnumeratedItem, newLine, ProcType,    StringItem, ToggleVisibility],  Heap USING [systemZone],  Process USING [Detach, MsecToTicks, Pause],  Put USING [CR, Date, Decimal, Line, Text],  Runtime USING [GetBcdTime],  Selection USING [Convert],  String USING [    AppendDecimal, AppendLongDecimal, AppendLongNumber, AppendString,    AppendStringAndGrow, CopyToNewString, Empty, Equal],  System USING [GetGreenwichMeanTime],  TextSW USING [ForceOutput],  Time USING [Append, Unpack],  Tool USING [Create, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [    CancelPeriodicNotify, CreatePeriodicNotify, PeriodicNotifyHandle, PeriodicProcType,    UserAbort],  Version USING [Append],  Window USING [Handle],    CommandFile USING [CommandsFromFile, Error, SomebodyRunning],  CP USING [Cycle, RealCS, Task],  CPBreak USING [ClearAllBreaks, EnumerateBreaks, Error, RemoveBreaks],  CPCommand USING [    Boot, Break, Error, Compare, Continue, CrossJump, Load, LoadBootFile, LoadGerm,    LoadRaw, LoadReal, LoadSymbols, PrintState, Reset, SetPC, Stop, Unbreak],  CPKernel USING [    Error, GetBootSeq, GetState, GetStateSeq,    InKernel, ProbeForStateChange, State],  CPPanel USING [Destroy, MakePanelSW, Refresh],  CPSymbols USING [    AppendAllRH, AppendAllRReg, AppendAllUReg, AppendNumber, AppendAllVirturalCS,    AppendIOIn, AppendIOOut, AppendLink, AppendMap, AppendOther,    AppendReal, AppendRealCS, AppendTc, AppendTpc,    AppendVirtural, AppendVirturalCS,    Error, Eval, nullRealCS, nullVirturalCS,    RealToVirturalCS, Symbol, VirturalCS, VirturalToRealCS];CPWindower: PROGRAM  IMPORTS    FormSW, Heap, Process, Put, Runtime, Selection, String, System,    TextSW, Time, Tool, UserInput, Version,    CommandFile, CPBreak, CPCommand, CPKernel, CPPanel, CPSymbols  EXPORTS CPCommand =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;    typeIn, run: LONG STRING ¬ NIL;  vMBitsOver22: PUBLIC CARDINAL ¬ 0; -- 0 for 22 bit VM, 1 for 23 bit VM, 2 for 24 bit VM  log, form, panel: Window.Handle ¬ NIL;  state: CPKernel.State;  seq, boot: CARDINAL;  refreshNeeded, flushDuplicates, flushStateChange: BOOLEAN ¬ FALSE;  notifier: UserInput.PeriodicNotifyHandle;  clumpSize: CARDINAL ¬ 10;  Boot: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommand.Boot[LogString, log];    END;  Load: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.Reset[LogString, log];    CPCommand.Load[LogString, log, filename];    CPCommand.LoadSymbols[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadMore: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.Load[LogString, log, filename];    CPCommand.LoadSymbols[LogString, log, filename];    z.FREE[@filename];    END;    END;  Compare: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.Compare[LogString, log, filename];    z.FREE[@filename];    END;    END;  CrossJump: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.CrossJump[LogString, log, filename];    z.FREE[@filename];    END;    END;  Start: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    pc: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@pc];    PostDate[];    CPCommand.SetPC[LogString, log, pc];    CPCommand.Continue[LogString, log];    z.FREE[@pc];    END;    END;  Continue: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommand.Continue[LogString, log];    END;  Stop: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostDate[];    CPCommand.Stop[LogString, log];    END;  Run: FormSW.ProcType =    BEGIN    filename: LONG STRING ¬ String.CopyToNewString[run, z];    IF String.Empty[filename] THEN filename ¬ Selection.Convert[string];    Put.CR[log];    flushStateChange ¬ TRUE;    FormSW.ToggleVisibility[form, runIx];    Process.Detach[FORK Runner[filename]];    -- Dally so Watcher can't sneak in and reset flushStateChange before     --  the process we just forked gets started.    FOR i: CARDINAL IN [0..10) DO      IF CommandFile.SomebodyRunning[] THEN EXIT;      Process.Pause[Process.MsecToTicks[100]];      ENDLOOP;    END;    Runner: PROCEDURE [filename: LONG STRING] =    BEGIN    BEGIN ENABLE CommandFile.Error =>      BEGIN      temp: STRING = [200];      String.AppendString[temp, "Error in command file at position "L];      String.AppendLongDecimal[temp, position];      String.AppendString[temp, ": "L];      String.AppendString[temp, reason];      TailMessage[temp];      CONTINUE;      END;    CommandFile.CommandsFromFile[LogString, log, Abort, filename];    END;    z.FREE[@filename];    FormSW.ToggleVisibility[form, runIx];    END;  LoadRaw: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadRaw[LogString, log, filename];    CPCommand.LoadSymbols[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadNoSyms: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.Load[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadSymbols: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadSymbols[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadGerm: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadGerm[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadReal: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadReal[LogString, log, filename];    z.FREE[@filename];    END;    END;  LoadBoot: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    filename: LONG STRING ¬ Selection.Convert[string];    PostDate[];    BEGIN ENABLE UNWIND => z.FREE[@filename];    CPCommand.LoadBootFile[LogString, log, filename, 0];    z.FREE[@filename];    END;    END;  Refresh: FormSW.ProcType =    BEGIN    refreshNeeded ¬ flushStateChange ¬ TRUE;    END;    What: FormSW.ProcType =    BEGIN ENABLE      CPSymbols.Error => BEGIN TailMessage[reason]; CONTINUE; END;    string: LONG STRING ¬ Selection.Convert[string];    temp: LONG STRING = [200];    value: CPSymbols.Symbol;    BEGIN ENABLE UNWIND => z.FREE[@string];    PostMessage["Decoding "L];    IF string = NIL THEN      BEGIN      TailMessage["  Selection required"L];      RETURN;      END;    TailMessage[string];    value ¬ CPSymbols.Eval[string];    WITH value SELECT FROM      number =>        BEGIN	String.AppendString[temp, "Number: "L];	AppendLotsOfModes[temp, n];	END;      tpc =>        BEGIN        CPSymbols.AppendTpc[temp, task];	AppendLotsOfModes[temp, task];	END;      tc =>        BEGIN        CPSymbols.AppendTc[temp, task];	AppendLotsOfModes[temp, task];	END;      link =>        BEGIN        CPSymbols.AppendLink[temp, link];	AppendLotsOfModes[temp, link];	END;      realCS =>        BEGIN	virt: CPSymbols.VirturalCS;	cycle: CP.Cycle;	task: CP.Task;	String.AppendString[temp, "RealCS: "L];        CPSymbols.AppendRealCS[temp, real];	AppendLotsOfModes[temp, real];	[virt, cycle, task] ¬ CPSymbols.RealToVirturalCS[real];	IF virt # CPSymbols.nullVirturalCS THEN	  BEGIN	  String.AppendString[temp, ", (VirturalCS = .CV "L];          CPSymbols.AppendNumber[temp, virt];          String.AppendString[temp, " = "L];          CPSymbols.AppendVirturalCS[temp, virt];	  String.AppendString[temp, ", "L];          AppendCycle[temp, cycle];	  String.AppendString[temp, ", task = "L];          String.AppendDecimal[temp, task];	  String.AppendString[temp, ")"L];	  END;	END;      virtCS =>        BEGIN	real: CP.RealCS;	cycle: CP.Cycle;	task: CP.Task;	String.AppendString[temp, "VirturalCS: "L];	String.AppendString[temp, ".CV "L];	CPSymbols.AppendNumber[temp, virt];        String.AppendString[temp, " = "L];        CPSymbols.AppendAllVirturalCS[temp, virt];	AppendLotsOfModes[temp, virt];	[real, cycle, task] ¬ CPSymbols.VirturalToRealCS[virt];	IF real # CPSymbols.nullRealCS THEN	  BEGIN	  String.AppendString[temp, ", (RealCS = "L];          CPSymbols.AppendRealCS[temp, real];	  String.AppendString[temp, ", "L];          AppendCycle[temp, cycle];	  String.AppendString[temp, ", task = "L];          String.AppendDecimal[temp, task];	  String.AppendString[temp, ")"L];	  END;	END;      rReg, rAndRh =>        BEGIN	IF value.type = rAndRh THEN	  String.AppendString[temp, "(R+RH mode)"L];	String.AppendString[temp, "RReg: "L];	String.AppendString[temp, ".R "L];	CPSymbols.AppendNumber[temp, r];        String.AppendString[temp, " = "L];        CPSymbols.AppendAllRReg[temp, r];	AppendLotsOfModes[temp, r];	END;      rH =>        BEGIN	String.AppendString[temp, "RH: "L];	String.AppendString[temp, ".RH "L];	CPSymbols.AppendNumber[temp, r];        String.AppendString[temp, " = "L];        CPSymbols.AppendAllRH[temp, r];	AppendLotsOfModes[temp, r];	END;      uReg =>        BEGIN	String.AppendString[temp, "UReg: "L];	String.AppendString[temp, ".U "L];	CPSymbols.AppendNumber[temp, u];        String.AppendString[temp, " = "L];        CPSymbols.AppendAllUReg[temp, u];	AppendLotsOfModes[temp, u];	END;      ioIn =>        BEGIN        CPSymbols.AppendIOIn[temp, io];	AppendLotsOfModes[temp, io];	END;      ioOut =>        BEGIN        CPSymbols.AppendIOOut[temp, io];	AppendLotsOfModes[temp, io];	END;      map =>        BEGIN        CPSymbols.AppendMap[temp, map];	AppendLotsOfModes[temp, map];	END;      real =>        BEGIN        CPSymbols.AppendReal[temp, real];	AppendLotsOfModes[temp, LOOPHOLE[real]];	END;      virt =>        BEGIN        CPSymbols.AppendVirtural[temp, virt];	AppendLotsOfModes[temp, LOOPHOLE[virt]];	END;      other =>        BEGIN        CPSymbols.AppendOther[temp, other];	END;      pc =>        BEGIN        String.AppendString[temp, ".PC (a Speudo Register)"L];	END;      ENDCASE => ERROR;    TailMessage[temp];    z.FREE[@string];    END;    END;    AppendLotsOfModes: PROCEDURE [s: LONG STRING, d: LONG CARDINAL] =    BEGIN    String.AppendString[s, " = "L];    String.AppendLongNumber[s, d, 16];    String.AppendString[s, "'X = "L];    String.AppendLongNumber[s, d, 10];    String.AppendString[s, "'D = "L];    String.AppendLongNumber[s, d, 8];    String.AppendString[s, "'B"L];    END;    AppendCycle: PROCEDURE [s: LONG STRING, cycle: CP.Cycle] =    BEGIN    SELECT cycle FROM      c1 => String.AppendString[s, "c1"L];      c2 => String.AppendString[s, "c2"L];      c3 => String.AppendString[s, "c3"L];      any => String.AppendString[s, "c*"L];      ENDCASE => ERROR;    END;   Break: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    where: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@where];    IF where = NIL THEN where ¬ String.CopyToNewString[typeIn, z];    IF where = NIL THEN      BEGIN      TailMessage["  Selection/Typein required"L];      RETURN;      END;    CPCommand.Break[LogString, log, where];    z.FREE[@where];    END;    END;   Unbreak: FormSW.ProcType =    BEGIN ENABLE CPCommand.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    where: LONG STRING ¬ Selection.Convert[string];    BEGIN ENABLE UNWIND => z.FREE[@where];    CPCommand.Unbreak[LogString, log, where];    z.FREE[@where];    END;    END;   ClearAllBreaks: FormSW.ProcType =    BEGIN ENABLE CPBreak.Error =>      BEGIN      PostMessage["Oops, "L];      TailMessage[reason];      CONTINUE;      END;    PostMessage["Clearing All CP Breaks "L];    AppendMessage[" ... "L];    CPBreak.ClearAllBreaks[];    TailMessage["ok"L];    END;  ListBreaks: FormSW.ProcType =    BEGIN ENABLE CPBreak.Error =>      BEGIN      PostMessage["Oops, "L];      TailMessage[reason];      CONTINUE;      END;    i: CARDINAL ¬ 0;    PrintOne: PROCEDURE [pc: CP.RealCS, cycle: CP.Cycle, task: CP.Task] =      BEGIN      temp: STRING = [200];      virt: CPSymbols.VirturalCS;      i ¬ i + 1;      Put.Text[log, "CP Break #"L];      Put.Decimal[log, i];      Put.Text[log, " is located at "L];      CPSymbols.AppendRealCS[temp, pc];      [virt, , ] ¬ CPSymbols.RealToVirturalCS[pc];      IF virt # CPSymbols.nullVirturalCS THEN        BEGIN        String.AppendString[temp, ", (VirturalCS = "L];        CPSymbols.AppendVirturalCS[temp, virt];        String.AppendString[temp, ")"L];        END;      String.AppendString[temp, ", "L];      AppendCycle[temp, cycle];      String.AppendString[temp, ", task = "L];      String.AppendLongDecimal[temp, task];      Put.Line[log, temp];      END;    Put.CR[log];    Put.Line[log, "CP Breakpoints:"L];    CPBreak.EnumerateBreaks[PrintOne];    Put.Line[log, "Done"L];    END;  SetVmEnumItem: PUBLIC PROCEDURE [vMSize: LONG STRING] RETURNS[BOOLEAN] =    BEGIN    IF String.Equal[vMSize, "22"L] THEN       vMBitsOver22 ¬ 0    ELSE IF String.Equal[vMSize, "23"L] THEN       vMBitsOver22 ¬ 1    ELSE IF String.Equal[vMSize, "24"L] THEN       vMBitsOver22 ¬ 2    ELSE       RETURN[FALSE];           FormSW.DisplayItem[form, 24];    RETURN[TRUE];    END;       RefreshWindow: PUBLIC PROCEDURE =    BEGIN    seq ¬ CPKernel.GetStateSeq[];    boot ¬ CPKernel.GetBootSeq[];    state ¬ CPKernel.GetState[];    refreshNeeded ¬ TRUE;    END;      Watcher: UserInput.PeriodicProcType =    BEGIN    IF CommandFile.SomebodyRunning[] THEN RETURN;    ProbeForStateChange[];    IF ~refreshNeeded AND seq = CPKernel.GetStateSeq[] AND boot = CPKernel.GetBootSeq[] THEN      BEGIN      refreshNeeded ¬ flushDuplicates ¬ flushStateChange ¬ FALSE;      RETURN;      END;    IF state # CPKernel.GetState[] THEN flushDuplicates ¬ FALSE;    seq ¬ CPKernel.GetStateSeq[];    boot ¬ CPKernel.GetBootSeq[];    state ¬ CPKernel.GetState[];    IF ~flushDuplicates THEN      BEGIN      PostDate[];      IF ~flushStateChange THEN AppendMessage["State changed: "L];      IF CPKernel.InKernel[] THEN RemoveBreaks[];      PrintState[];      END;    IF CPKernel.InKernel[] THEN BEGIN RemoveBreaks[]; CPPanel.Refresh[]; END;    FormSW.DisplayItem[form, stateIx];    refreshNeeded ¬ flushDuplicates ¬ flushStateChange ¬ FALSE;    END;      ProbeForStateChange: PROCEDURE =    BEGIN ENABLE CPKernel.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    CPKernel.ProbeForStateChange[];    END;      RemoveBreaks: PROCEDURE =    BEGIN ENABLE CPBreak.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    CPBreak.RemoveBreaks[];    END;      PrintState: PROCEDURE =    BEGIN ENABLE CPCommand.Error =>      BEGIN      PostMessage["Humm, "L];      TailMessage[reason];      CONTINUE;      END;    CPCommand.PrintState[LogString, log];    END;      PostDate: PROCEDURE =    BEGIN    Put.CR[log];    Put.Date[log, System.GetGreenwichMeanTime[], dateTime];    Put.Text[log, "  "L];    TextSW.ForceOutput[log];    flushDuplicates ¬ TRUE;    END;  PostMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.CR[log];    Put.Text[log, s];    TextSW.ForceOutput[log];    END;  AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log];    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    Put.Line[log, "."L];    TextSW.ForceOutput[log];    END;    LogString: Format.StringProc =    BEGIN    Put.Text[clientData, s];    END;  Abort: PROCEDURE RETURNS [BOOLEAN] =    BEGIN    RETURN[UserInput.UserAbort[log]];    END;  Initialize: PROCEDURE =    BEGIN    herald: STRING = [100];    String.AppendString[herald, "CP Panel "L];    Version.Append[herald];    String.AppendString[herald, " of "L];    Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];    [] ¬ Tool.Create[      name: herald,      cmSection: "CP Panel"L,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    Tool.UnusedLogName[logFileName, "CP.log$"L];    log ¬ Tool.MakeFileSW[window: window, name: logFileName, h: 100];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    panel ¬ CPPanel.MakePanelSW[window, log, ModifyTypeIn, @typeIn];    END;    stateChoices: ARRAY CPKernel.State OF FormSW.Enumerated ¬ [    dead: ["CP/IOP Dead", CPKernel.State[dead]],    halted: ["Halted", CPKernel.State[halted]],    running: ["Running", CPKernel.State[running]],    cpBreak: ["CPBreak", CPKernel.State[cpBreak]],    iopStopped: ["IOP Stopped", CPKernel.State[iopStopped]]];    runIx: CARDINAL = 6;  stateIx: CARDINAL = 14;  typeInIx: CARDINAL = 17;  MakeForm: FormSW.ClientItemsProcType =    BEGIN    nParams: CARDINAL = 25;    VMType: ARRAY[0..3) OF FormSW.Enumerated ¬ [["22"L, 0], ["23"L, 1], ["24"L, 2]];    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[0] ¬ FormSW.CommandItem[tag: "Boot"L, proc: Boot, place: FormSW.newLine];    items[1] ¬ FormSW.CommandItem[tag: "Load"L, proc: Load];    items[2] ¬ FormSW.CommandItem[tag: "LoadMore"L, proc: LoadMore];    items[3] ¬ FormSW.CommandItem[tag: "Start"L, proc: Start];    items[4] ¬ FormSW.CommandItem[tag: "Continue"L, proc: Continue];    items[5] ¬ FormSW.CommandItem[tag: "Stop"L, proc: Stop];    items[runIx] ¬ FormSW.CommandItem[tag: "Run"L, proc: Run];    items[7] ¬ FormSW.StringItem[tag: "File"L, string: @run, inHeap: TRUE];    items[8] ¬ FormSW.CommandItem[tag: "LoadRaw"L, proc: LoadRaw, place: FormSW.newLine];    items[9] ¬ FormSW.CommandItem[tag: "LoadNoSyms"L, proc: LoadNoSyms];    items[10] ¬ FormSW.CommandItem[tag: "LoadSymbols"L, proc: LoadSymbols];    items[11] ¬ FormSW.CommandItem[tag: "LoadGerm"L, proc: LoadGerm];    items[12] ¬ FormSW.CommandItem[tag: "LoadReal"L, proc: LoadReal];    items[13] ¬ FormSW.CommandItem[tag: "LoadBoot"L, proc: LoadBoot];    items[stateIx] ¬ FormSW.EnumeratedItem[      tag: "State"L, value: @state, readOnly: TRUE, place: FormSW.newLine,      choices: LOOPHOLE[LONG[DESCRIPTOR[stateChoices]]]];    items[15] ¬ FormSW.CommandItem[tag: "Refresh"L, proc: Refresh];    items[16] ¬ FormSW.CommandItem[tag: "What"L, proc: What];    items[typeInIx] ¬ FormSW.StringItem[tag: "TypeIn"L, string: @typeIn, inHeap: TRUE];    items[18] ¬ FormSW.CommandItem[tag: "ListBreaks"L, proc: ListBreaks, place: FormSW.newLine];    items[19] ¬ FormSW.CommandItem[tag: "ClearAllBreaks"L, proc: ClearAllBreaks];    items[20] ¬ FormSW.CommandItem[tag: "Unbreak"L, proc: Unbreak];    items[21] ¬ FormSW.CommandItem[tag: "Break"L, proc: Break];    items[22] ¬ FormSW.CommandItem[tag: "Compare"L, proc: Compare];    items[23] ¬ FormSW.CommandItem[tag: "CrossJump"L, proc: CrossJump];    items[24] ¬ FormSW.EnumeratedItem[tag: "VM"L, choices: DESCRIPTOR[VMType], value: @vMBitsOver22];    RETURN[items, TRUE];    END;       ModifyTypeIn: PROCEDURE [newTypeIn: LONG STRING, replace: BOOLEAN] =    BEGIN    IF newTypeIn = NIL OR replace THEN typeIn.length ¬ 0;    IF newTypeIn # NIL THEN String.AppendStringAndGrow[@typeIn, newTypeIn, z];    FormSW.DisplayItem[form, typeInIx];    END;        ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN	typeIn ¬ z.NEW[StringBody[20]];	run ¬ z.NEW[StringBody[20]];	state ¬ CPKernel.GetState[];	seq ¬ 0;	boot ¬ 0;	notifier ¬ UserInput.CreatePeriodicNotify[Watcher, window, Process.MsecToTicks[500]];        END;      new = inactive =>        BEGIN	notifier ¬ UserInput.CancelPeriodicNotify[notifier];	CPPanel.Destroy[];	z.FREE[@typeIn];	z.FREE[@run];        END;      ENDCASE;    END;	  Initialize[];  END.
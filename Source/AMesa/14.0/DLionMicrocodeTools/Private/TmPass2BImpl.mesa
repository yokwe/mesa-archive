-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- File: TmPass2BImpl.mesa-- Last edit: JAC       16-May-85 15:34:36 DIRECTORY  Ascii USING [CR],  Environment USING [Byte, bytesPerWord, Block],    Inline USING [BITAND, BITOR, BITSHIFT, BITXOR],  MassBurdockInterface,  MSegment USING [Delete],  Stream USING [    GetBlock, GetPosition, GetWord, Position, PutBlock, PutChar, PutString,    SetPosition],  String USING [AppendString, AppendChar, AppendDecimal],  Time USING [AppendCurrent],  TmAssembler USING [GetPassSpace],  TmControl USING [FatalError, noFinalFiles, noFTfile],  TmFile USING [    CloseStream, ebStream, fbFileSize, fbOutStream, fbSeg,  ftStream, LogErrAndSrcLines,    LogLine, LogText, mlStream, OpenFbOut, OpenFbSort, OpenFt, OpenNextEb,    OpenNextMl, outFile, PutHex, stStream],  TmLabel,    TmP2Hash USING [    bad, ConstraintArray, constraintArray, curID, EraseMiSpace, ErasePass2Hash,    EraseXSpace, errorLevel, ExportDataRecPtr, ExportRec, exportRecList,    GetMiSpace, ia7Array, Ia7Array, maxMI, miLtoV, miVtoLtxt, labIoff, MiRtoV, miRtoV,    miVtoR, Mi2Res, mi2Res, miIoff, NoTxt, realMI, Reserved];TmPass2BImpl: PROGRAM  IMPORTS    Inline, MSegment, Stream, String, Time, TmAssembler, TmControl, TmFile, TmLabel,    TmP2Hash  EXPORTS TmLabel =  BEGIN OPEN MassBurdockInterface, TmAssembler, TmLabel;  Words: TYPE = RECORD [word1, word2, word3, word4: CARDINAL];  SortTable: TYPE = ARRAY [0..TmP2Hash.maxMI+maxSA] OF FinalBinaryRec;    maxSA: CARDINAL = 7;  totalMIs:  MIIndex;  sortTable: LONG POINTER TO SortTable;  GenParity: PROCEDURE [pbPtr: LONG POINTER TO PartialBinary] = {    words: Words ¬ LOOPHOLE[pbPtr­];    sum: CARDINAL;    sum ¬ Inline.BITXOR[words.word1, words.word2];    sum ¬ Inline.BITXOR[sum, words.word3];    sum ¬ Inline.BITXOR[sum, Inline.BITSHIFT[sum, -8]];    sum ¬ Inline.BITXOR[sum, Inline.BITSHIFT[sum, -4]];    sum ¬ Inline.BITXOR[sum, Inline.BITSHIFT[sum, -2]];    sum ¬ Inline.BITXOR[sum, Inline.BITSHIFT[sum, -1]];    sum ¬ Inline.BITAND[sum, 1];    IF sum = 1 THEN pbPtr­.parity ¬ Inline.BITXOR[1, pbPtr­.parity];    };  -- end GenParity  Pass2Init1: PROCEDURE = {    i: CARDINAL;    TmP2Hash.ErasePass2Hash[];    TmP2Hash.constraintArray ¬ TmP2Hash.GetMiSpace[      SIZE[TmP2Hash.ConstraintArray]];    TmP2Hash.ia7Array ¬ TmP2Hash.GetMiSpace[SIZE[TmP2Hash.Ia7Array]];    FOR i IN [0..5120) DO      TmP2Hash.ia7Array[i] ¬ x; TmP2Hash.constraintArray[i] ¬ NIL; ENDLOOP;    sortTable ¬ NIL;    };  -- end Pass2Init1  Pass2Init2: PROCEDURE = {    i: CARDINAL;    resCount: CARDINAL ¬ 0;    str: LONG STRING ¬ [10];    TmP2Hash.miRtoV ¬ TmP2Hash.GetMiSpace[SIZE[TmP2Hash.MiRtoV]];    -- TmP2Hash.miRtoV[address] = MIIndex of MI at that address    FOR i IN [0..4096) DO      IF TmP2Hash.mi2Res[i] THEN {        TmP2Hash.miRtoV[i] ¬ TmP2Hash.Reserved; resCount ¬ resCount + 1; }      ELSE TmP2Hash.miRtoV[i] ¬ Empty;      ENDLOOP;    TmFile.LogText["The number of reserved locations = "L];    String.AppendDecimal[str, resCount];    TmFile.LogLine[str];    TmFile.LogText["The number of free locations = "L];    str.length ¬ 0;    String.AppendDecimal[str, 4096 - TmP2Hash.realMI - resCount];    TmFile.LogLine[str];    };  -- end Pass2Init2  Pass2Part2: PUBLIC PROCEDURE = {    ca: LONG POINTER TO ConstraintAttribute;    strIndex: Stream.Position;    {    Pass2Init1[];    strIndex ¬ Stream.GetPosition[TmFile.stStream];    IF TmP2Hash.errorLevel > TmP2Hash.bad THEN GOTO Thru;        ReadInConstraint[];    IF TmP2Hash.errorLevel > TmP2Hash.bad THEN GOTO Thru;    ca ¬ BuildCAList[];    Pass2Init2[];    ProcessConstraints[ca];        IF TmP2Hash.errorLevel > TmP2Hash.bad THEN GOTO Thru;    AllocateUnconstrained[];    IF TmP2Hash.errorLevel > TmP2Hash.bad THEN GOTO Thru;    IF ~TmControl.noFinalFiles THEN {      WriteFinalBinary[];      TmP2Hash.EraseMiSpace[];      TmP2Hash.EraseXSpace[];      Stream.SetPosition[TmFile.stStream, strIndex];      MySort[];      RETURN;      };    GOTO Thru;    EXITS Thru => Stream.SetPosition[TmFile.stStream, strIndex];    };    };  -- end Pass2Part2  ReadInConstraint: PROCEDURE = {    miIoffset, labIoffset: CARDINAL ¬ 0;    cr: ConstraintRec;    crBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@cr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[ConstraintRec]];    ccp: LONG POINTER TO ConstraintChain;    i: CARDINAL;    mii: [0..5120) --MIIndex--;    <<pre-12.0 versions were compiled without bounds checking so that it didn't matter that MIIndex is [0..4097].  When Mass encounters an "at[offset, module, label]" and label is not found it creates a bogus instruction (I think) and as a result the total number of instructions may be over 4096.>>    str: LONG STRING ¬ [100];    mi2Restemp: LONG POINTER TO TmP2Hash.Mi2Res ¬ TmP2Hash.GetMiSpace[      SIZE[TmP2Hash.Mi2Res]];    resHere: BOOLEAN ¬ FALSE;    stIndex: CARDINAL ¬ 0;    spCnt: CARDINAL ¬ 0;    ccHere: LONG POINTER TO ConstraintChain ¬ NIL;    AddCC: PROCEDURE RETURNS [ccPtr: LONG POINTER TO ConstraintChain] = INLINE {      IF spCnt = 0 THEN {        ccHere ¬ TmAssembler.GetPassSpace[SIZE[ConstraintChain]*250]; spCnt ¬ 249; }      ELSE {        ccHere ¬ LOOPHOLE[ccHere + SIZE[ConstraintChain]]; spCnt ¬ spCnt - 1; };      ccPtr ¬ ccHere;      };  -- end AddCC    UNTIL TmFile.OpenNextMl[] DO  -- for each ml file      miIoffset ¬ TmP2Hash.miIoff[stIndex];      labIoffset ¬ TmP2Hash.labIoff[stIndex];      DO  -- for each constraint record        [] ¬ Stream.GetBlock[TmFile.mlStream, crBlock];        IF cr.label2.type = special THEN EXIT;        mii ¬          WITH cr.label1 SELECT FROM            unlabeled => miseqnum + miIoffset,            labeled => TmP2Hash.miLtoV[labelseqnum + labIoffset],            ENDCASE => 0;        IF cr.modulo = 0 THEN {          IF (TmP2Hash.ia7Array[mii] = t AND cr.offset = 2)            OR (TmP2Hash.ia7Array[mii] = f AND cr.offset = 3) THEN {            IF TmP2Hash.errorLevel < TmP2Hash.bad THEN              TmFile.LogErrAndSrcLines["Allocation Errors:"L];            TmP2Hash.errorLevel ¬ 200;            str.length ¬ 0;            String.AppendString[str, "ia7 conflict in address of "L];            AppendSymbolName[str, mii];            String.AppendChar[str, Ascii.CR];            TmFile.LogLine[str];            };          TmP2Hash.ia7Array[mii] ¬ SELECT cr.offset FROM 2 => f, ENDCASE => t;          LOOP;          };        ccp ¬ AddCC[];        ccp­.nextConstraint ¬ NIL;        ccp­.offset ¬ cr.offset;        ccp­.modulo ¬ cr.modulo;        ccp.miIndex1 ¬ mii;        WITH cr.label2 SELECT FROM          unlabeled => ccp.miIndex2 ¬ miseqnum + miIoffset;          labeled => ccp.miIndex2 ¬ TmP2Hash.miLtoV[labelseqnum + labIoffset];          special => EXIT;          ENDCASE;        IF ccp.miIndex1 = Empty OR ccp.miIndex2 = Empty THEN LOOP;        AddConstraint[ccp];        ENDLOOP;  -- end for each constraint record      resHere ¬ LOOPHOLE[Stream.GetWord[TmFile.mlStream], BOOLEAN];      IF resHere THEN {        [] ¬ Stream.GetBlock[          TmFile.mlStream, Environment.Block[          blockPointer: LOOPHOLE[mi2Restemp], startIndex: 0,          stopIndexPlusOne: Environment.bytesPerWord*SIZE[TmP2Hash.Mi2Res]]];        FOR i IN [0..4096) DO          TmP2Hash.mi2Res[i] ¬ TmP2Hash.mi2Res[i] OR mi2Restemp[i]; ENDLOOP};      stIndex ¬ stIndex + 1;      ENDLOOP;  -- end for each ml file    };  -- end ReadInConstraint  MySort: PROCEDURE =    BEGIN            Index: TYPE = CARDINAL;    fbrSize: CARDINAL = SIZE[FinalBinaryRec];            Swap: PROCEDURE [p1, p2: Index] =      BEGIN      tempFbr: FinalBinaryRec;            tempFbr ¬ sortTable[p1];      sortTable[p1] ¬ sortTable[p2];      sortTable[p2] ¬ tempFbr;      END;  -- end Swap                 BubbleSort: PROCEDURE [min, max: Index] =      BEGIN            bound: Index ¬ max;      t: Index;      DO        t ¬ 0;	FOR j: Index IN [min..bound) DO	  IF sortTable[j].addr > sortTable[j+1].addr THEN {	    Swap[j, j+1];	    t ¬ j};	  ENDLOOP;	IF t = 0 THEN EXIT ELSE bound ¬ t;	ENDLOOP;       END;  -- end InsertionSort                Sort: PROCEDURE [min, max: Index] =      BEGIN      doMax: BOOLEAN ¬ TRUE;      middle: Index = (max + min) / 2;      i, j: Index;            IF min >=  max THEN RETURN;  <<fix for sort mechanism>>                 IF max - min < 8 THEN {BubbleSort[min, max]; RETURN};                  -- put the median of min, max, and middle at min       IF sortTable[middle].addr > sortTable[max].addr THEN Swap[middle, max];       IF sortTable[middle].addr > sortTable[min].addr THEN Swap[middle, min];       IF sortTable[min].addr > sortTable[max].addr THEN Swap[min, max];              i ¬ min;       j ¬ max;       WHILE i < j DO         IF sortTable[i].addr > sortTable[j].addr THEN {           Swap[i, j];	   doMax ¬ ~doMax};         IF doMax THEN j ¬ j - 1 ELSE i ¬ i + 1;         ENDLOOP;       Sort[min, i - 1];       Sort[i + 1, max];       END;  --end Sort              sortTable ¬ TmFile.OpenFbSort[];    IF TmFile.fbFileSize = 0 THEN RETURN;        Sort[0, totalMIs - 1];        MSegment.Delete[TmFile.fbSeg];    TmFile.fbSeg ¬ NIL;    sortTable ¬ NIL;    END;  -- of MySort proc  WriteFinalBinary: PROCEDURE = {    count: INTEGER ¬ -1;    curLnum: MIIndex ¬ 0;    curMInum: MIIndex ¬ 0;    dest: LONG STRING ¬ [100];    ebr: EarlyBinaryRec;    ebrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@ebr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[EarlyBinaryRec]];    exportRec: TmP2Hash.ExportRec;    exrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@exportRec]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[TmP2Hash.ExportRec]];    fbr: FinalBinaryRec;    fbrBlock: Environment.Block ¬ Environment.Block[      blockPointer: LOOPHOLE[LONG[@fbr]], startIndex: 0,      stopIndexPlusOne: Environment.bytesPerWord*SIZE[FinalBinaryRec]];    j: CARDINAL ¬ 0;    miOff, labOff: CARDINAL ¬ 0;    sI: CARDINAL ¬ 0;    name: LONG STRING ¬ [64];    saaddr: [0..5120) --used to be MIIndex; se comment at mii above--;    saname: LONG STRING ¬ [64];    destination: CARDINAL;    ptr: TmP2Hash.ExportDataRecPtr;    WriteFT: PROCEDURE = {      word: CARDINAL;      minum: CARDINAL;      ptr: LONG POINTER ¬ @fbr;      i: CARDINAL;      HexConvert: PROCEDURE [nbits: [1..4]] = {        hexChar: ARRAY [0..15] OF CHARACTER = [          '0, '1, '2, '3, '4, '5, '6, '7, '8, '9, 'A, 'B, 'C, 'D, 'E, 'F];        String.AppendChar[          dest, hexChar[Inline.BITSHIFT[word, nbits - 16] MOD 16]];        word ¬ Inline.BITSHIFT[word, nbits];        };  -- end HexConvert      dest.length ¬ 0;      -- first word = virtual mi number      word ¬ LOOPHOLE[ptr­, CARDINAL];      FOR i IN [1..4] DO HexConvert[4]; ENDLOOP;      String.AppendChar[dest, ' ];      -- second word = real address      minum ¬ word ¬ LOOPHOLE[(ptr + 1)­, CARDINAL];      FOR i IN [1..4] DO HexConvert[4]; ENDLOOP;      String.AppendChar[dest, ' ];      -- third word = rA,rB,aS,aF,aD      word ¬ LOOPHOLE[(ptr + 2)­, CARDINAL];      FOR i IN [1..4] DO HexConvert[4]; ENDLOOP;      String.AppendChar[dest, ' ];      --fourth word = ep,cin,ensu,mem,fS,fX,fY      word ¬ LOOPHOLE[(ptr + 3)­, CARDINAL];      FOR i IN [1..4] DO HexConvert[4]; ENDLOOP;      String.AppendChar[dest, ' ];      -- fifth word = fZ,inia      word ¬ LOOPHOLE[(ptr + 4)­, CARDINAL];      FOR i IN [1..4] DO HexConvert[4]; ENDLOOP;      String.AppendChar[dest, ' ];      -- third word = rA,rB,aS,aF,aD      word ¬ LOOPHOLE[(ptr + 2)­, CARDINAL];      word ¬ Inline.BITSHIFT[word, 8];      HexConvert[3];      HexConvert[3];      HexConvert[2];      String.AppendChar[dest, ' ];      -- sixth word = cycle,null,task      word ¬ LOOPHOLE[(ptr + 5)­, CARDINAL];      HexConvert[2];      word ¬ Inline.BITSHIFT[word, 2];      HexConvert[3];      String.AppendChar[dest, ' ];      IF fbr.miNum = 177777B THEN {        Stream.SetPosition[TmFile.stStream, TmP2Hash.miVtoLtxt[saaddr]];        ReadLabelFromST[saname];        String.AppendString[dest, saname];        Stream.PutString[TmFile.ftStream, dest];        Stream.PutChar[TmFile.ftStream, Ascii.CR];        RETURN;        };      IF TmP2Hash.miVtoLtxt[curLnum] = TmP2Hash.NoTxt THEN count ¬ count + 1      ELSE {        count ¬ 0;        Stream.SetPosition[TmFile.stStream, TmP2Hash.miVtoLtxt[j]];        ReadLabelFromST[name];        };      String.AppendString[dest, name];      Stream.PutString[TmFile.ftStream, dest];      IF count # 0 THEN {        Stream.PutString[TmFile.ftStream, " + "L];        TmFile.PutHex[TmFile.ftStream, count]};      Stream.PutChar[TmFile.ftStream, Ascii.CR];      };  -- end WriteFT    --  temp kludge for testing fbr.charIndex ¬ 1023220556B;    totalMIs ¬ 0;    TmFile.OpenFbOut[];    IF ~TmControl.noFTfile THEN {      TmFile.OpenFt[];      String.AppendString[dest, TmFile.outFile];      String.AppendString[dest, " file created: "L];      Time.AppendCurrent[dest];      Stream.PutString[TmFile.ftStream, dest];      Stream.PutChar[TmFile.ftStream, Ascii.CR];      TmFile.LogLine[dest];      Stream.PutString[        TmFile.ftStream, "Vadr Radr  W0   W1   W2  SFD CT LABEL NAME"L];      Stream.PutChar[TmFile.ftStream, Ascii.CR];      String.AppendString[name, "beginning m-i"L]};    UNTIL TmFile.OpenNextEb[] DO  -- for each eb file      miOff ¬ TmP2Hash.miIoff[sI];      labOff ¬ TmP2Hash.labIoff[sI];      sI ¬ sI + 1;      DO  -- for each eb record        [] ¬ Stream.GetBlock[TmFile.ebStream, ebrBlock];        IF ebr.last THEN EXIT;        fbr.partialBinary ¬ ebr.partialBinary;        fbr.miNum ¬ curMInum;        fbr.addr ¬ TmP2Hash.miVtoR[curMInum];        curLnum ¬ j ¬ curMInum;        WITH ebr.destMI.dest SELECT FROM          unlabeled => destination ¬ TmP2Hash.miVtoR[miseqnum + miOff];          labeled => {            destination ¬ TmP2Hash.miVtoR[TmP2Hash.miLtoV[labelseqnum + labOff]];            saaddr ¬ TmP2Hash.miLtoV[labelseqnum + labOff];            };          absolute => destination ¬ value;          ENDCASE;        IF ebr.sa THEN {          fbr.miNum ¬ 177777B;          j ¬ curMInum - 1;          fbr.partialBinary.addr ¬ ebr.partialBinary.addr;          fbr.addr ¬ destination;          }        ELSE          fbr.partialBinary.addr ¬ Inline.BITOR[            ebr.destMI.orMask, Inline.BITAND[destination, ebr.destMI.andMask]];        GenParity[@fbr.partialBinary];        IF ~TmControl.noFTfile THEN WriteFT[];        [] ¬ Stream.PutBlock[TmFile.fbOutStream, fbrBlock];        curMInum ¬ j + 1;	totalMIs ¬ totalMIs + 1;        ENDLOOP;  -- end eb record      ENDLOOP;  -- end eb file    fbr.miNum ¬ 0;    fbr.addr ¬ 177777B;    [] ¬ Stream.PutBlock[TmFile.fbOutStream, fbrBlock];    -- now put out exports    ptr ¬ TmP2Hash.exportRecList;    UNTIL ptr = NIL DO      exportRec ¬ TmP2Hash.ExportRec[        id: ptr.id,        addr:        IF ptr.miIndex = Empty THEN ptr.addr ELSE TmP2Hash.miVtoR[ptr.miIndex],        length: ptr.s.length];      [] ¬ Stream.PutBlock[TmFile.fbOutStream, exrBlock];      [] ¬ Stream.PutBlock[        TmFile.fbOutStream, Environment.Block[        blockPointer: LOOPHOLE[@ptr.s.text], startIndex: 0,        stopIndexPlusOne: exportRec.length]];      ptr ¬ ptr.next;      ENDLOOP;    exportRec ¬ TmP2Hash.ExportRec[id: TmP2Hash.curID, addr: 0, length: 0];    [] ¬ Stream.PutBlock[TmFile.fbOutStream, exrBlock];    TmFile.fbOutStream ¬ TmFile.CloseStream[TmFile.fbOutStream];    IF ~TmControl.noFTfile THEN      TmFile.ftStream ¬ TmFile.CloseStream[TmFile.ftStream];        IF curMInum > TmP2Hash.maxMI THEN {      TmFile.LogLine["Number of microinstructions exceeds maximum(4096)"];      TmControl.FatalError};    };  -- end WriteFinalBinary  END...    -- Log  -- 16-Jul-82 10:11:23 - ETN        - TrinityMass Version 1  --  1-Nov-82 13:51:04 - ETN        - Fix fb truc. bug in MySort  -- 15-Jul-83 10:43:03 - JAC        - Removed tempHeap  -- 17-Aug-83 12:59:36 - JAC        - Use new sort for sorting fb   -- 18-Aug-83 12:04:01 - JAC        - abort if number of microinstructions exeeds 4096  -- 29-Sep-83  0:16:35 - DEG     	- Fix sorting algorithm so as not to run out of VM.  -- Time: 26-Sep-84 20:58:41	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.  -- 16-May-85 15:34:09 - JAC        - fix problem with bounds checking at mii and saadr
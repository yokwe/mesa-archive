-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- TeatherDLion.mesa, HGM, 12-Sep-85 22:52:13DIRECTORY  DLionInputOutput USING [    IOPage, processorCommandOffset, processorCSBOffset, unusedCommandAreaOffset],  Environment USING [Block, Byte],  Inline USING [BITAND, BITOR, BytePair, HighByte, LowByte, LowHalf],  Process USING [Pause, SetTimeout],  Put USING [Line],  ResidentHeap USING [MakeNode, first64K],  SpecialRuntime USING [AllocateNakedCondition],  System USING [GetClockPulses, MicrosecondsToPulses, Pulses],  Zone USING [Base, Status],    HistoryBuffer USING [Clocks, Index, sizeOfHistoryBuffer],  Teather USING [Register];TeatherDLion: MONITOR  IMPORTS DLionInputOutput, Inline, Process, Put, ResidentHeap, SpecialRuntime, System  EXPORTS HistoryBuffer, Teather =  BEGIN    running: BOOLEAN ¬ FALSE;  clocks: HistoryBuffer.Clocks ¬ cycle;  Error: PUBLIC ERROR [reason: LONG STRING] = CODE;  maxBytesPerClump: CARDINAL = 1536;  baseAddress: WORD = 100200B;  -- Hex 8080  statusByte: WORD = baseAddress + 0;    cycle1: WORD = 4B;    cycle2: WORD = 2B;    cycle3: WORD = 1B;    bufferFromCpFull: WORD = 10B;    bufferToCpFull: WORD = 20B;    hbDone: WORD = 40B;    stopBar: WORD = 100B;  controlByte: WORD = baseAddress + 0;    run: WORD = 0;    boot: WORD = 1B;    useCsa: WORD = 2B;    useRam: WORD = 04B;    singleCycle: WORD = 20B;    singleClick: WORD = 40B;    stop: WORD = 100B;  cpData: WORD = baseAddress + 1;  finger: WORD = baseAddress + 2;  contents: WORD = baseAddress + 3;  -- HB ControlBits:  hbTrigger: WORD = 1;  hbClock: WORD = 0;  hbCycle: WORD = 2;  hbClick: WORD = 6;  hbIBDisp: WORD = 4;    Command: TYPE = MACHINE DEPENDENT {    readUmbilicalBlock(1), writeUmbilicalBlock(2),    readDebuggerBlock(3), writeDebuggerBlock(4),    readCPBlock(5), writeCPBlock(6),    (0FFH) };  Initialize: PUBLIC PROCEDURE =    BEGIN    temp: WORD;    running ¬ FALSE;    temp ¬ ReadIOP[statusByte];    IF temp = 0 THEN ERROR Error["Can't talk to Debugger Board: c1 or c2 or c3 should be on"L];    IF temp = 0FFH THEN ERROR Error["Can't talk to Debugger Board: Looks like Power is off"L];    WriteIOP[controlByte, stop + forceRam];  -- Take control    temp ¬ ReadIOP[statusByte];    IF Inline.BITAND[temp, stopBar] # 0 THEN ERROR Error["Can't talk to Debugger Board: Stop didn't work"L];    IF Inline.BITAND[temp, 7H] = 0 THEN ERROR Error[        "Can't talk to Debugger Board: No cycle. Maybe this is connected to a DLion rather than a Dicentra"L];    END;  Boot: PUBLIC PROCEDURE =    BEGIN    bits: WORD;    SELECT clocks FROM      clock => bits ¬ hbClock;      cycle => bits ¬ hbCycle;      click => bits ¬ hbClick;      ibDisp => bits ¬ hbIBDisp;      ENDCASE => ERROR;    running ¬ FALSE;    WriteIOP[controlByte, stop+forceRam];    WriteIOP[finger, LOOPHOLE[Teather.Register[hbBits]]];    WriteIOP[contents, bits];    WriteIOP[controlByte, boot+forceRam];    Spin[10];    WriteIOP[controlByte, stop+forceRam];    [] ¬ ReadIOP[cpData];  -- Discard old trash    END;      PokeInit: PUBLIC PROCEDURE =    BEGIN    WriteIOP[controlByte, boot+forceRam];    Spin[10];    IF running THEN WriteIOP[controlByte, run+forceRam]    ELSE WriteIOP[controlByte, stop+forceRam];    END;      Spin: PROCEDURE [ms: CARDINAL] =    BEGIN    start: System.Pulses ¬ System.GetClockPulses[];    delta: System.Pulses ¬ System.MicrosecondsToPulses[ms*1000];    UNTIL System.GetClockPulses[] > (start + delta) DO ENDLOOP;    END;          	  GetCycle: PUBLIC PROCEDURE RETURNS [[1..3]] =    BEGIN    temp: WORD ¬ ReadIOP[statusByte];    IF temp = 0FFH THEN Error["Looks like power is off"];  -- high bit wired to GND    -- Doesn't check for illegal combinations so we can play without a CP board.    IF Inline.BITAND[temp, cycle1] # 0 THEN RETURN[1];    IF Inline.BITAND[temp, cycle2] # 0 THEN RETURN[2];    IF Inline.BITAND[temp, cycle3] # 0 THEN RETURN[3];    ERROR Error["Can't find current cycle"];    END;      Stop: PUBLIC PROCEDURE =    BEGIN    running ¬ FALSE;    StopCleanly[];    END;  maxTries: CARDINAL ¬ 0;  StopCleanly: PROCEDURE =    BEGIN    WriteIOP[controlByte, singleClick+forceRam];  -- singleClick => wait for memory idle    FOR i: CARDINAL IN [0..10) DO      temp: WORD ¬ ReadIOP[statusByte];      IF Inline.BITAND[temp, stopBar] = 0 THEN        BEGIN	IF i > maxTries THEN maxTries ¬ i;	RETURN;	END;      IF temp = 0FFH THEN Error["Looks like power is off"];  -- high bit wired to GND      Process.Pause[1];      REPEAT FINISHED => Put.Line[NIL, "Yetch.  Looks like we are stuck in a Memory Loop."L];      ENDLOOP;    WriteIOP[controlByte, singleCycle+forceRam];  -- singleCycle => finish this instruction    FOR i: CARDINAL IN [0..10) DO      temp: WORD ¬ ReadIOP[statusByte];      IF Inline.BITAND[temp, stopBar] = 0 THEN        BEGIN	IF i > maxTries THEN maxTries ¬ i;	RETURN;	END;      IF temp = 0FFH THEN Error["Looks like power is off"];  -- high bit wired to GND      Process.Pause[1];      REPEAT FINISHED => Put.Line[NIL, "Wow.  Looks like the Bus is hung."L];      ENDLOOP;    WriteIOP[controlByte, stop+forceRam];  -- stop => drop dead now    FOR i: CARDINAL IN [0..10) DO      temp: WORD ¬ ReadIOP[statusByte];      IF Inline.BITAND[temp, stopBar] = 0 THEN        BEGIN	IF i > maxTries THEN maxTries ¬ i;	RETURN;	END;      IF temp = 0FFH THEN Error["Looks like power is off"];  -- high bit wired to GND      Process.Pause[1];      REPEAT FINISHED => Error["Stop didn't work."L];      ENDLOOP;    END;      SingleClickFromNIA: PUBLIC PROCEDURE =    BEGIN    running ¬ FALSE;    WriteIOP[controlByte, singleClick+forceRam];    END;      SingleCycleFromNIA: PUBLIC PROCEDURE =    BEGIN    running ¬ FALSE;    WriteIOP[controlByte, singleCycle+forceRam];    END;      -- useCsa known to be off except for here  -- Beware: You can't read nia if useCsa gets left on  SingleClickFromCSA: PUBLIC PROCEDURE =    BEGIN    running ¬ FALSE;    WriteIOP[controlByte, stop+useCsa+forceRam];    WriteIOP[controlByte, singleClick+useCsa+forceRam];    WriteIOP[controlByte, stop+forceRam];    END;      SingleCycleFromCSA: PUBLIC PROCEDURE =    BEGIN    running ¬ FALSE;    WriteIOP[controlByte, stop+useCsa+forceRam];    WriteIOP[controlByte, singleCycle+useCsa+forceRam];    WriteIOP[controlByte, stop+forceRam];    END;      Continue: PUBLIC PROCEDURE =    BEGIN    running ¬ TRUE;    WriteIOP[controlByte, run+forceRam];    END;  ReadCPReady: PUBLIC PROCEDURE RETURNS [BOOLEAN] =    BEGIN    temp: WORD ¬ ReadIOP[statusByte];    IF temp = 0FFH THEN Error["Looks like power is off"];  -- high bit wired to GND    RETURN[Inline.BITAND[temp, bufferFromCpFull] = bufferFromCpFull];    END;    ReadCPByte: PUBLIC PROCEDURE RETURNS [data: Environment.Byte] =    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    ReadCPClump[@temp, 1];    RETURN[temp[0]];    END;    ReadCPWord: PUBLIC PROCEDURE RETURNS [WORD] =    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    bytes: Inline.BytePair;    ReadCPClump[@temp, 2];    bytes.high ¬ temp[0];    bytes.low ¬ temp[1];    RETURN[LOOPHOLE[bytes]];    END;    ReadCPBlock: PUBLIC PROCEDURE [finger: Environment.Block] =    BEGIN    IF finger.startIndex >= finger.stopIndexPlusOne THEN ERROR;    IF (finger.startIndex MOD 2) # 0 THEN      BEGIN      finger.blockPointer[finger.startIndex] ¬ ReadCPByte[];      finger.startIndex ¬ finger.startIndex + 1;      END;    IF finger.startIndex # 0 THEN      BEGIN      finger.blockPointer ¬ finger.blockPointer + finger.startIndex/2;      finger.stopIndexPlusOne ¬ finger.stopIndexPlusOne - finger.stopIndexPlusOne;      END;    UNTIL finger.stopIndexPlusOne < maxBytesPerClump DO      ReadCPClump[finger.blockPointer, maxBytesPerClump];      finger.blockPointer ¬ finger.blockPointer + maxBytesPerClump/2;      finger.stopIndexPlusOne ¬ finger.stopIndexPlusOne - maxBytesPerClump      ENDLOOP;    IF finger.stopIndexPlusOne # 0 THEN      ReadCPClump[finger.blockPointer, finger.stopIndexPlusOne];    END;    ReadCPClump: ENTRY PROCEDURE [data: LONG POINTER, bytes: CARDINAL] =    BEGIN ENABLE UNWIND => NULL;    WHILE busy DO WAIT queue; ENDLOOP;    busy ¬ TRUE;    iocb­ ¬ [readCPBlock, , interruptBits, data, bytes];    pBurdockIocb­ ¬ shortIocb;    UNTIL pBurdockIocb­ = nullIocb DO WAIT wait­; ENDLOOP;    busy ¬ FALSE;    BROADCAST queue;    IF iocb.command # readCPBlock THEN ERROR Error["Domino Command Rejection"];    IF iocb.bytes # 0 THEN ERROR Error["Timeout"];    END;    WriteCPByte: PUBLIC PROCEDURE [data: Environment.Byte] =    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    temp[0] ¬ Inline.LowByte[data];    WriteCPClump[@temp, 1];    END;    WriteCPWord: PUBLIC PROCEDURE [data: WORD] =    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    temp[0] ¬ Inline.HighByte[data];    temp[1] ¬ Inline.LowByte[data];    WriteCPClump[@temp, 2];    END;      WriteCPBlock: PUBLIC PROCEDURE [finger: Environment.Block] =    BEGIN    IF finger.startIndex >= finger.stopIndexPlusOne THEN ERROR;    IF (finger.startIndex MOD 2) # 0 THEN      BEGIN      WriteCPByte[finger.blockPointer[finger.startIndex]];      finger.startIndex ¬ finger.startIndex + 1;      END;    IF finger.startIndex # 0 THEN      BEGIN      finger.blockPointer ¬ finger.blockPointer + finger.startIndex/2;      finger.stopIndexPlusOne ¬ finger.stopIndexPlusOne - finger.stopIndexPlusOne;      END;    UNTIL finger.stopIndexPlusOne < maxBytesPerClump DO      WriteCPClump[finger.blockPointer, maxBytesPerClump];      finger.blockPointer ¬ finger.blockPointer + maxBytesPerClump/2;      finger.stopIndexPlusOne ¬ finger.stopIndexPlusOne - maxBytesPerClump      ENDLOOP;    IF finger.stopIndexPlusOne # 0 THEN      WriteCPClump[finger.blockPointer, finger.stopIndexPlusOne];    END;    WriteCPClump: ENTRY PROCEDURE [data: LONG POINTER, bytes: CARDINAL] =    BEGIN ENABLE UNWIND => NULL;    WHILE busy DO WAIT queue; ENDLOOP;    busy ¬ TRUE;    iocb­ ¬ [writeCPBlock, , interruptBits, data, bytes];    pBurdockIocb­ ¬ shortIocb;    UNTIL pBurdockIocb­ = nullIocb DO WAIT wait­; ENDLOOP;    busy ¬ FALSE;    BROADCAST queue;    IF iocb.command # writeCPBlock THEN ERROR Error["Domino Command Rejection"];    IF iocb.bytes # 0 THEN ERROR Error["Timeout"];    END;    ReadByte: PUBLIC PROCEDURE [reg: Teather.Register] RETURNS [data: Environment.Byte] =    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    SetupDebugger[];    ReadClump[reg, @temp, 1];    FinishDebugger[];    RETURN[temp[0]];    END;    ReadWord: PUBLIC PROCEDURE [reg: Teather.Register] RETURNS [data: WORD] =    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    bytes: Inline.BytePair;    SetupDebugger[];    ReadClump[reg, @temp, 2];    FinishDebugger[];    bytes.high ¬ temp[0];    bytes.low ¬ temp[1];    RETURN[LOOPHOLE[bytes]];    END;      ReadBlock: PUBLIC PROCEDURE [reg: Teather.Register, finger: Environment.Block] =    BEGIN    IF finger.startIndex >= finger.stopIndexPlusOne THEN ERROR;    IF (finger.startIndex MOD 2) # 0 THEN      BEGIN      finger.blockPointer[finger.startIndex] ¬ ReadByte[reg];      finger.startIndex ¬ finger.startIndex + 1;      END;    IF finger.startIndex # 0 THEN      BEGIN      finger.blockPointer ¬ finger.blockPointer + finger.startIndex/2;      finger.stopIndexPlusOne ¬ finger.stopIndexPlusOne - finger.stopIndexPlusOne;      END;    SetupDebugger[];    UNTIL finger.stopIndexPlusOne < maxBytesPerClump DO      ReadClump[reg, finger.blockPointer, maxBytesPerClump];      finger.blockPointer ¬ finger.blockPointer + maxBytesPerClump/2;      finger.stopIndexPlusOne ¬ finger.stopIndexPlusOne - maxBytesPerClump      ENDLOOP;    IF finger.stopIndexPlusOne # 0 THEN      ReadClump[reg, finger.blockPointer, finger.stopIndexPlusOne];    FinishDebugger[];    END;    ReadClump: ENTRY PROCEDURE [reg: Teather.Register, data: LONG POINTER, bytes: CARDINAL] =    BEGIN ENABLE UNWIND => NULL;    WHILE busy DO WAIT queue; ENDLOOP;    busy ¬ TRUE;    iocb­ ¬ [readDebuggerBlock, reg, interruptBits, data, bytes];    pBurdockIocb­ ¬ shortIocb;    UNTIL pBurdockIocb­ = nullIocb DO WAIT wait­; ENDLOOP;    BROADCAST queue;    busy ¬ FALSE;    IF iocb.command # readDebuggerBlock THEN Error["Domino Command Rejection"];    IF iocb.bytes # 0 THEN ERROR Error["Timeout"];    END;    WriteByte: PUBLIC PROCEDURE [reg: Teather.Register, data: Environment.Byte] =    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    temp[0] ¬ Inline.LowByte[data];    SetupDebugger[];    WriteClump[reg, @temp, 1];    FinishDebugger[];    END;    WriteWord: PUBLIC PROCEDURE [reg: Teather.Register, data: WORD] =    BEGIN    temp: PACKED ARRAY [0..2) OF Environment.Byte;    SetupDebugger[];    temp[0] ¬ Inline.HighByte[data];    temp[1] ¬ Inline.LowByte[data];    WriteClump[reg, @temp, 2];    FinishDebugger[];    END;      WriteBlock: PUBLIC PROCEDURE [reg: Teather.Register, finger: Environment.Block] =    BEGIN    IF finger.startIndex >= finger.stopIndexPlusOne THEN ERROR;    IF (finger.startIndex MOD 2) # 0 THEN      BEGIN      WriteByte[reg, finger.blockPointer[finger.startIndex]];      finger.startIndex ¬ finger.startIndex + 1;      END;    IF finger.startIndex # 0 THEN      BEGIN      finger.blockPointer ¬ finger.blockPointer + finger.startIndex/2;      finger.stopIndexPlusOne ¬ finger.stopIndexPlusOne - finger.stopIndexPlusOne;      END;    SetupDebugger[];    UNTIL finger.stopIndexPlusOne < maxBytesPerClump DO      WriteClump[reg, finger.blockPointer, maxBytesPerClump];      finger.blockPointer ¬ finger.blockPointer + maxBytesPerClump/2;      finger.stopIndexPlusOne ¬ finger.stopIndexPlusOne - maxBytesPerClump      ENDLOOP;    IF finger.stopIndexPlusOne # 0 THEN      WriteClump[reg, finger.blockPointer, finger.stopIndexPlusOne];    FinishDebugger[];    END;    WriteClump: ENTRY PROCEDURE [reg: Teather.Register, data: LONG POINTER, bytes: CARDINAL] =    BEGIN ENABLE UNWIND => NULL;    WHILE busy DO WAIT queue; ENDLOOP;    busy ¬ TRUE;    iocb­ ¬ [writeDebuggerBlock, reg, interruptBits, data, bytes];    pBurdockIocb­ ¬ shortIocb;    UNTIL pBurdockIocb­ = nullIocb DO WAIT wait­; ENDLOOP;    busy ¬ FALSE;    BROADCAST queue;    IF iocb.command # writeDebuggerBlock THEN Error["Domino Command Rejection"];    IF iocb.bytes # 0 THEN ERROR Error["Timeout"];    END;    forceRam: CARDINAL ¬ useRam;  -- set to 0 to forceRom    SetUseRom: PUBLIC PROCEDURE [useRom: BOOLEAN] =    BEGIN    forceRam ¬ IF useRom THEN 0 ELSE useRam;    END;  SetupDebugger: PROCEDURE =    BEGIN    IF running THEN StopCleanly[];    END;      FinishDebugger: PROCEDURE =    BEGIN    IF running THEN WriteIOP[controlByte, run+forceRam];    END;        -- History Buffer  triggered: BOOLEAN ¬ FALSE;  savedOffset: CARDINAL;  savedAddress: CARDINAL;  SetSeeClocks: PUBLIC PROCEDURE [new: HistoryBuffer.Clocks] =    BEGIN    clocks ¬ new;    SetBits[];    END;      SetBits: PUBLIC PROCEDURE [extra: WORD ¬ 0, allClocks: BOOLEAN ¬ FALSE] =    BEGIN    bits: WORD ¬ extra;    IF allClocks THEN bits ¬ Inline.BITOR[bits, hbClock]    ELSE      SELECT clocks FROM        clock => bits ¬ Inline.BITOR[bits, hbClock];        cycle => bits ¬ Inline.BITOR[bits, hbCycle];        click => bits ¬ Inline.BITOR[bits, hbClick];        ibDisp => bits ¬ Inline.BITOR[bits, hbIBDisp];	ENDCASE => ERROR;    WriteByte[hbBits, bits];    END;    Arm: PUBLIC PROCEDURE [pc: WORD, offset: HistoryBuffer.Index] =    BEGIN    IF offset > HistoryBuffer.sizeOfHistoryBuffer THEN ERROR Error["Offset too big"];    savedOffset ¬ offset;    triggered ¬ FALSE;    WriteWord[hbMatchMsb, pc];    WriteByte[hbCount, offset - 1];    END;    ManualTrigger: PUBLIC PROCEDURE =    BEGIN    SetBits[hbTrigger];    IF ~Triggered[] THEN SetBits[hbTrigger, TRUE];    SetBits[];    END;    Triggered: PUBLIC PROCEDURE RETURNS [BOOLEAN] =    BEGIN    temp: WORD;    IF triggered THEN RETURN [TRUE];    temp ¬ ReadIOP[statusByte];    IF temp = 0FFH THEN Error["Looks like power is off"];  -- high bit wired to GND    triggered ¬ Inline.BITAND[temp, hbDone] = hbDone;    IF ~triggered THEN RETURN [FALSE];    savedAddress ¬ ReadByte[hbAddr];    RETURN[TRUE];    END;    GetInfo: PUBLIC PROCEDURE  [offset: HistoryBuffer.Index] RETURNS [pc: WORD, extra: Environment.Byte] =    BEGIN    targetAddress: Environment.Byte ¬ Inline.BITAND[savedAddress + offset, 0FFH];    IF offset > HistoryBuffer.sizeOfHistoryBuffer THEN ERROR Error["Can't look forward that far"];    WriteByte[hbAddr, targetAddress];    pc ¬ ReadWord[hbPCMsb];    extra ¬ ReadByte[hbPCExtra];    RETURN;    END;        -- Interface to Pilot        ProcessorCommand: TYPE = MACHINE DEPENDENT {    null(0), readIOPByte(5), writeIOPByte(6), (7), (8)};  pProcessorCommand: LONG POINTER TO ProcessorCommand = DLionInputOutput.IOPage + DLionInputOutput.processorCommandOffset;  ProcessorCSB: TYPE = MACHINE DEPENDENT RECORD [    data2(0): WORD,    data1(1): WORD,      data0(2): WORD];  pProcessorCSB: LONG POINTER TO ProcessorCSB = DLionInputOutput.IOPage + DLionInputOutput.processorCSBOffset;  ReadIOP: PROCEDURE [address: CARDINAL] RETURNS [Environment.Byte] =    BEGIN    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ address;    pProcessorCommand­ ¬ readIOPByte;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    RETURN[Inline.LowByte[pProcessorCSB.data1]];    END;    WriteIOP: PROCEDURE [address: CARDINAL, data: Environment.Byte] =    BEGIN    UNTIL pProcessorCommand­ = null DO ENDLOOP;    pProcessorCSB.data2 ¬ address;    pProcessorCSB.data1 ¬ data;    pProcessorCommand­ ¬ writeIOPByte;    UNTIL pProcessorCommand­ = null DO ENDLOOP;    END;      pBurdockIocb: LONG POINTER TO ShortBurdockIocb = DLionInputOutput.IOPage + DLionInputOutput.unusedCommandAreaOffset;  BurdockIocb: TYPE = LONG POINTER TO BurdockIocbBody;  ShortBurdockIocb: TYPE = POINTER TO BurdockIocbBody;  nullIocb: ShortBurdockIocb = LOOPHOLE[0];    BurdockIocbBody: TYPE = RECORD [    command: Command,    register: Teather.Register,    interruptBits: WORD,    data: LONG POINTER,    bytes: CARDINAL];    interruptBits: WORD;  wait: LONG POINTER TO CONDITION;  queue: CONDITION;  shortIocb: ShortBurdockIocb;  iocb: BurdockIocb;  busy: BOOLEAN ¬ FALSE;    InitPilotCrap: PROCEDURE =    BEGIN    ResidentZoneTrouble: ERROR = CODE;    status: Zone.Status;    p: Zone.Base RELATIVE POINTER;    [p, status] ¬ ResidentHeap.MakeNode[SIZE[BurdockIocbBody]];    IF status # okay THEN ERROR ResidentZoneTrouble;    iocb ¬ @ResidentHeap.first64K[p];    shortIocb ¬ Inline.LowHalf[iocb];    [wait, interruptBits] ¬ SpecialRuntime.AllocateNakedCondition[];    iocb.interruptBits ¬ interruptBits;    END;    InitPilotCrap[];  Process.SetTimeout[@queue, 1];  END....
-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CPPaneler.mesa, HGM, 21-Nov-83  0:19:16DIRECTORY  Heap USING [systemZone],  Inline USING [HighHalf, LowHalf],  String USING [AppendLongNumber, AppendNumber, AppendString, CopyToNewString],  Tool USING [AddThisSW],  ToolWindow USING [CreateSubwindow, nullBox],  Window USING [Box, Handle],  WindowFont USING [CharWidth, defaultFont, FontHeight, Handle],  CP USING [Cycle, RealCS, RReg, UReg, Task],  CPMI USING [MI],  CPKernel USING [    Error, InKernel, ReadCS, ReadIOIn, ReadLink, ReadMap, ReadOther, ReadPC, ReadRealMemory,    ReadRAndRH, ReadRH, ReadRReg, ReadTc, ReadTpc, ReadUReg, ReadVirturalMemory,    WriteIOOut, WriteLink, WriteMap, WriteOther, WritePC, WriteRAndRH, WriteRealMemory, WriteRH,    WriteRReg, WriteTc, WriteTpc, WriteUReg, WriteVirturalMemory],  CPPanel USING [],  CPSymbols USING [    AppendMI, AppendSymbol, AppendVirturalCS, Error, Eval, nullRealCS, nullVirturalCS,    RealToVirturalCS, Symbol, VirturalCS, VirturalToRealCS],  IOPKernel USING [InKernel],  PanelSW USING [    Clear, ClientError, ClientProcsObject, Create, Destroy, FreeRSProcType,    LHTypeInEvalProcType, ModifyTypeInProcType, Handle,    ReadTargetProcType, RegisterSpec,    RHTypeInEvalProcType, SWType, TileLayout, Update];CPPaneler: PROGRAM  IMPORTS    Heap, Inline, String,    Tool, ToolWindow, WindowFont,    CPKernel, CPSymbols, IOPKernel, PanelSW  EXPORTS CPPanel =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  messages: Window.Handle = NIL;    font: WindowFont.Handle = WindowFont.defaultFont;  fontHeight: INTEGER = WindowFont.FontHeight[font];  digitWidth: INTEGER = WindowFont.CharWidth['0, font];  lineHeight: CARDINAL = fontHeight + 2;  tileHeight: CARDINAL = lineHeight;  tileRows: CARDINAL = 18;  tileColumns: CARDINAL = 3;  tileFlagLength: CARDINAL = digitWidth;  tileLVLength: CARDINAL = 12*digitWidth + 4;  tileRVLength: CARDINAL = 7*digitWidth + 5;  tileLength: CARDINAL = tileFlagLength + tileLVLength + tileRVLength;  tileBoxWidth: CARDINAL = tileColumns*tileLength + 12*digitWidth;  tilesPerRow: CARDINAL = tileBoxWidth/tileLength;  numTiles: CARDINAL = tileRows*tilesPerRow;  rowLayout: ARRAY [0..tileColumns) OF PanelSW.TileLayout ¬ [    [tileFlagLength, tileLVLength, tileRVLength],    [tileFlagLength, tileLVLength, tileRVLength],    [tileFlagLength, tileLVLength, tileRVLength + 21*digitWidth] ];  panelProcs: PanelSW.ClientProcsObject ¬ [    FreeRS, LHTypeInEval, NIL, ReadTarget, RHTypeInEval];  panel: PanelSW.Handle ¬ NIL;  RegisterSpec: TYPE = LONG POINTER TO RegisterSpecObject;  RegisterSpecObject: TYPE = CPSymbols.Symbol;  AbsToRep: PROCEDURE [rs: PanelSW.RegisterSpec] RETURNS [RegisterSpec] = INLINE    BEGIN RETURN[LOOPHOLE[rs, RegisterSpec]] END;  RepToAbs: PROCEDURE [rs: RegisterSpec] RETURNS [PanelSW.RegisterSpec] = INLINE    BEGIN RETURN[LOOPHOLE[rs, PanelSW.RegisterSpec]] END;  FreeRS: PanelSW.FreeRSProcType = BEGIN z.FREE[@rs]; END;  AllocateRegisterSpec: PROCEDURE [value: CPSymbols.Symbol]    RETURNS [PanelSW.RegisterSpec] =    BEGIN    rs: RegisterSpec;    rs ¬ z.NEW[CPSymbols.Symbol];    rs­ ¬ value;    RETURN[RepToAbs[rs]];    END;  ReadTarget: PanelSW.ReadTargetProcType =    BEGIN    myrs: RegisterSpec = AbsToRep[rs];    value: LONG CARDINAL;    s ¬ NIL;    IF rs = NIL THEN RETURN;    IF ~IOPKernel.InKernel[] THEN RETURN;    IF ~CPKernel.InKernel[] THEN RETURN;    BEGIN ENABLE CPKernel.Error => ERROR PanelSW.ClientError[unknown, reason];    WITH myrs SELECT FROM      number => ERROR;      tpc =>        BEGIN	real: CP.RealCS;	virt: CPSymbols.VirturalCS;        s ¬ z.NEW[StringBody[200]];	real ¬ CPKernel.ReadTpc[task];	[virt, , ] ¬ CPSymbols.RealToVirturalCS[real];	IF virt # CPSymbols.nullVirturalCS THEN CPSymbols.AppendVirturalCS[s, virt]	ELSE String.AppendNumber[s, real, 16];        RETURN;	END;      tc => value ¬ CPKernel.ReadTc[task];      link => value ¬ CPKernel.ReadLink[link];      realCS =>        BEGIN	mi: CPMI.MI ¬ CPKernel.ReadCS[real];        s ¬ z.NEW[StringBody[30]];	CPSymbols.AppendMI[s, mi];	RETURN;	END;      virtCS =>        BEGIN	real: CP.RealCS;	mi: CPMI.MI;	[real, , ] ¬ CPSymbols.VirturalToRealCS[virt];        s ¬ z.NEW[StringBody[30]];	IF real = CPSymbols.nullRealCS THEN	  BEGIN	  String.AppendString[s, "????"L];	  RETURN;	  END;	mi ¬ CPKernel.ReadCS[real];	CPSymbols.AppendMI[s, mi];	RETURN;	END;      rReg => value ¬ CPKernel.ReadRReg[r];      rH => value ¬ CPKernel.ReadRH[r];      rAndRh => value ¬ LOOPHOLE[CPKernel.ReadRAndRH[r]];      uReg => value ¬ CPKernel.ReadUReg[u];      ioIn => value ¬ CPKernel.ReadIOIn[io];      ioOut => ERROR PanelSW.ClientError[unknown, "Can't read output registers"L];      map => value ¬ CPKernel.ReadMap[map];      real => value ¬ CPKernel.ReadRealMemory[real];      virt => value ¬ CPKernel.ReadVirturalMemory[virt];      other => value ¬ CPKernel.ReadOther[other];      pc => value ¬ CPKernel.ReadPC[];      ENDCASE => ERROR;    END;    s ¬ z.NEW[StringBody[16]];    IF Inline.HighHalf[value] # 0 THEN      BEGIN      low: CARDINAL = Inline.LowHalf[value];      String.AppendNumber[s, Inline.HighHalf[value], 16];      SELECT TRUE FROM        (low > 0FFFH) => NULL;        (low > 0FFH) => String.AppendString[s, "0"L];        (low > 0FH) => String.AppendString[s, "00"L];        ENDCASE => String.AppendString[s, "000"L];      String.AppendLongNumber[s, low, 16];      END    ELSE String.AppendLongNumber[s, value, 16];    END;  RHTypeInEval: PanelSW.RHTypeInEvalProcType =    BEGIN    myrs: RegisterSpec = AbsToRep[rs];    symbol: CPSymbols.Symbol;        display ¬ NIL;    IF rs = NIL OR typeIn = NIL OR typeIn.length = 0 THEN RETURN;    IF ~IOPKernel.InKernel[] THEN RETURN;    IF ~CPKernel.InKernel[] THEN RETURN;    symbol ¬ CPSymbols.Eval[typeIn !      CPSymbols.Error => ERROR PanelSW.ClientError[unknown, reason] ];    BEGIN ENABLE CPKernel.Error => ERROR PanelSW.ClientError[unknown, reason];    WITH myrs SELECT FROM      tpc => CPKernel.WriteTpc[task, ExtractRealCS[symbol]];      tc => CPKernel.WriteTc[task, ExtractNumber[symbol]];      link => CPKernel.WriteLink[link, ExtractNumber[symbol]];      realCS, virtCS => ERROR PanelSW.ClientError[unknown, "Not implemented yet"L];      rReg => CPKernel.WriteRReg[r, ExtractNumber[symbol]];      rH => CPKernel.WriteRH[r, ExtractNumber[symbol]];      rAndRh => CPKernel.WriteRAndRH[r, ExtractLongNumber[symbol]];      uReg => CPKernel.WriteUReg[u, ExtractNumber[symbol]];      ioIn => ERROR PanelSW.ClientError[unknown, "Can't write input register"L];      ioOut => CPKernel.WriteIOOut[io, ExtractNumber[symbol]];      map => CPKernel.WriteMap[map, ExtractNumber[symbol]];      real => CPKernel.WriteRealMemory[real, ExtractNumber[symbol]];      virt => CPKernel.WriteVirturalMemory[virt, ExtractNumber[symbol]];      other => CPKernel.WriteOther[other, ExtractNumber[symbol]];      pc => CPKernel.WritePC[ExtractNumber[symbol]];      ENDCASE => ERROR;    END;    display ¬ ReadTarget[rs, TRUE];    END;    ExtractRealCS: PROCEDURE [symbol: CPSymbols.Symbol] RETURNS [CP.RealCS] =    BEGIN    WITH symbol SELECT FROM      number => RETURN[Inline.LowHalf[n]];      realCS => RETURN[real];      virtCS =>        BEGIN	real: CP.RealCS;	cycle: CP.Cycle;	task: CP.Task;	[real, cycle, task] ¬ CPSymbols.VirturalToRealCS[virt];	IF real = CPSymbols.nullRealCS THEN	  ERROR PanelSW.ClientError[unknown, "Can't translate that address to a .CR"L];	IF cycle # c1 THEN	  ERROR PanelSW.ClientError[unknown,"Please start in c1"L];      	RETURN[real];	END;      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;    ExtractNumber: PROCEDURE [symbol: CPSymbols.Symbol] RETURNS [WORD] =    BEGIN    WITH symbol SELECT FROM      number => RETURN[Inline.LowHalf[n]];      real => RETURN[CPKernel.ReadRealMemory[real]];      virt => RETURN[CPKernel.ReadVirturalMemory[virt]];      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;  ExtractLongNumber: PROCEDURE [symbol: CPSymbols.Symbol] RETURNS [LONG UNSPECIFIED] =    BEGIN    WITH symbol SELECT FROM      number => RETURN[n];      ENDCASE;    ERROR PanelSW.ClientError[unknown, "Unreasonable source/dest combination"L];    END;  LHTypeInEval: PanelSW.LHTypeInEvalProcType =    BEGIN    value: CPSymbols.Symbol;    display ¬ NIL;    newRs ¬ NIL;    IF typeIn = NIL OR typeIn.length = 0 THEN RETURN;    value ¬ CPSymbols.Eval[typeIn !      CPSymbols.Error => ERROR PanelSW.ClientError[unknown, reason] ];    WITH value SELECT FROM      number => value ¬ [real[LOOPHOLE[n]]];      ENDCASE => NULL;    newRs ¬ AllocateRegisterSpec[value];    IF normalize THEN      BEGIN      temp: STRING ¬ [200];      CPSymbols.AppendSymbol[temp, value];      display ¬ String.CopyToNewString[temp, z];      END    ELSE display ¬ String.CopyToNewString[typeIn, z];    END;    MakePanelSW: PUBLIC PROCEDURE [    parent: Window.Handle,    err: Window.Handle,    modifyTypeIn: PanelSW.ModifyTypeInProcType,    typeIn: LONG POINTER TO LONG STRING] RETURNS [psw: Window.Handle] =    BEGIN    box: Window.Box ¬ ToolWindow.nullBox;    box.dims.h ¬ tileRows*tileHeight;    panelProcs.modifyTypeIn ¬ modifyTypeIn;    psw ¬ ToolWindow.CreateSubwindow[parent: parent, box: box];    panel ¬ PanelSW.Create[      psw, err, numTiles, DESCRIPTOR[rowLayout], @panelProcs, typeIn];    Tool.AddThisSW[window: parent, sw: psw, swType: PanelSW.SWType[]];    END;      Destroy: PUBLIC PROCEDURE =    BEGIN    IF panel # NIL THEN PanelSW.Destroy[panel];    panel ¬ NIL;    END;      GetPanel: PUBLIC PROCEDURE RETURNS [PanelSW.Handle] = BEGIN RETURN[panel]; END;      Clear: PUBLIC PROCEDURE = BEGIN IF panel # NIL THEN PanelSW.Clear[panel]; END;      Refresh: PUBLIC PROCEDURE = BEGIN IF panel # NIL THEN PanelSW.Update[panel] END;      Initialize: PUBLIC PROCEDURE =    BEGIN    IF panel # NIL THEN PanelSW.Clear[panel];    END;      END.
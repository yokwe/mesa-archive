-- Copyright (C) 1981, 1983  by Xerox Corporation. All rights reserved. --  Last edited by PaD  DXS : August 7, 1979  4:51 PM-- Last edited by Roy RXO : May 28, 1980  2:46 PM--    "main" changed to "IOPmain"--  Last edited by PXO      on October 21, 1981  11:17 AM - Changed some procs to deal in longs. --  Last edited by PXO      on October 8, 1981  8:36 PM - Added proc ReInit. --  Last edited by PXO      on October 8, 1981  1:05 AM - Changed calls on ZoneAllocator to NEWs and FREEs. --  Last edited by PXO      on October 6, 1981  9:06 PM - Changed calls on Storage to calls on ZoneAllocator. --  Last edited by PXO      on October 6, 1981  4:41 PM - Changed interfaces to run on Dandelion. --  Last edited by PXO      on 29-Sep-81 18:40:38 - Added test for NIL in proc AddToRPStack, added test for Top = 0 in proc ConstructReversePolishStack, changed "-a" to "0-a" in proc EvaluateReversePolishStack because of bounds faults.-- Last edited by Dennis DEG      on 30-May-83 15:50:29 - Remove references to the Ascii interface.-- Time: 26-Sep-84 23:09:07	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.--  Module to evaluate (as far as possible) the operand of an instructionDIRECTORY  AssInputDefs USING [    NextChar, CurrentChar, MakeWord, MakeNumber, GetRelocFlag, AssErr],  CodeOutputDefs USING [GetPC, GetBinaryStreamIndex],  ExpressionDefs USING [    EvalResult, EvalType, MaxStack, Operation, StackItem, Token],  PrivateStorage USING [heapPointer],  PrivateStringDefs USING [CopyString],  SymbolTableDefs USING [STData, LookUpInSymbolTable, PutInSymbolTable],  SymTabIODefs USING [AddToUseChain];ExpressionOps: PROGRAM  IMPORTS    AssInputDefs, CodeOutputDefs, PrivateStorage, PrivateStringDefs,    SymbolTableDefs, SymTabIODefs  EXPORTS ExpressionDefs =  BEGIN  RPFirst, RPLast: LONG POINTER TO ExpressionDefs.StackItem;  EvalTop, Top: CARDINAL;  OpSt: ARRAY [0..ExpressionDefs.MaxStack) OF ExpressionDefs.Operation;  EvalSt: ARRAY [0..ExpressionDefs.MaxStack) OF ExpressionDefs.EvalType;  a, b: CARDINAL;  ar, br: BOOLEAN;  GetToken: PROCEDURE RETURNS [ExpressionDefs.Token] =    BEGIN    c, char: CHARACTER ¬ AssInputDefs.CurrentChar[];    w, s: LONG STRING;    WHILE char = '  OR char = '\T DO      char ¬ AssInputDefs.NextChar[]; ENDLOOP;    SELECT char FROM      ',, ' , '\N, '\T => RETURN[[op[end]]];      '$, '. =>        BEGIN        c ¬ AssInputDefs.NextChar[];        RETURN[[pc[CodeOutputDefs.GetPC[] - 1]]];        END;      IN ['0..'9] => RETURN[[value[AssInputDefs.MakeNumber[]]]];      IN ['a..'z], IN ['A..'Z] =>        BEGIN        s ¬ AssInputDefs.MakeWord[];        w ¬ PrivateStorage.heapPointer.NEW[StringBody [s.length]];        PrivateStringDefs.CopyString[w, s];        RETURN[[name[w]]];        END;      '', '" =>        BEGIN        c ¬ AssInputDefs.NextChar[];        IF char = '" AND AssInputDefs.NextChar[] # '" THEN          SIGNAL AssInputDefs.AssErr[11]        ELSE [] ¬ AssInputDefs.NextChar[];        RETURN[[value[LOOPHOLE[c]]]];        END;      '+, '-, '*, '/, '(, ') =>        BEGIN        [] ¬ AssInputDefs.NextChar[];        RETURN[          [            op[            SELECT char FROM              '+ => plus,              '- => minus,              '* => mult,              '/ => div,              '( => bra,              ENDCASE => ket]]];        END;      ENDCASE => SIGNAL AssInputDefs.AssErr[11];    RETURN[[value[0]]];    END;  AddToRPStack: PROCEDURE [t: ExpressionDefs.Token] =    BEGIN    s: LONG POINTER TO ExpressionDefs.StackItem = PrivateStorage.heapPointer.NEW[      ExpressionDefs.StackItem ¬ [tok: t, nxt: NIL]];    RPLast ¬ (IF RPLast = NIL THEN s ELSE (RPLast.nxt ¬ s));    IF RPFirst = NIL THEN RPFirst ¬ RPLast;    END;  ConstructReversePolishStack: PUBLIC PROCEDURE [size: CARDINAL]    RETURNS [LONG POINTER TO ExpressionDefs.StackItem] =    BEGIN    t: ExpressionDefs.Token;    firsttokeninexpr: BOOLEAN ¬ TRUE;    ImportUsed: BOOLEAN ¬ FALSE;    ste: LONG POINTER TO SymbolTableDefs.STData;    RPFirst ¬ RPLast ¬ NIL;    DO      t ¬ GetToken[];      WITH t SELECT FROM        pc, value => BEGIN AddToRPStack[t]; firsttokeninexpr ¬ FALSE; END;        name =>          BEGIN          AddToRPStack[t];          firsttokeninexpr ¬ FALSE;          IF (ste ¬ SymbolTableDefs.LookUpInSymbolTable[id]) = NIL THEN LOOP;          IF ste.extern = imported THEN ImportUsed ¬ TRUE;          SymTabIODefs.AddToUseChain[            ste, CodeOutputDefs.GetBinaryStreamIndex[], size,            CodeOutputDefs.GetPC[]];          END;        op =>          SELECT opn FROM            bra => BEGIN firsttokeninexpr ¬ TRUE; Push[opn]; END;            plus, minus =>              BEGIN              IF firsttokeninexpr THEN opn ¬ pred[opn];              IF Top = 0 OR OpSt[Top - 1] = bra THEN Push[opn]              ELSE BEGIN AddToRPStack[[op[Pop[]]]]; Push[opn]; END;              END;            mult, div =>              BEGIN              IF Top ~= 0 AND (OpSt[Top - 1] = mult OR OpSt[Top - 1] = div) THEN                BEGIN AddToRPStack[[op[Pop[]]]]; Push[opn]; END              ELSE Push[opn];              END;            ket =>              BEGIN              WHILE OpSt[Top - 1] # bra DO AddToRPStack[[op[Pop[]]]]; ENDLOOP;              [] ¬ Pop[];              END;            end =>              DO                IF Top = 0 THEN                  BEGIN                  IF ImportUsed AND RPFirst # RPLast THEN                    SIGNAL AssInputDefs.AssErr[22];                  RETURN[RPFirst];                  END;                IF OpSt[Top - 1] = bra THEN SIGNAL AssInputDefs.AssErr[16];                AddToRPStack[[op[Pop[]]]];                ENDLOOP;            ENDCASE => SIGNAL AssInputDefs.AssErr[3];        ENDCASE;      ENDLOOP;    END;  Push: PROCEDURE [opn: ExpressionDefs.Operation] =    BEGIN    IF Top = ExpressionDefs.MaxStack THEN SIGNAL AssInputDefs.AssErr[17];    OpSt[Top] ¬ opn;    Top ¬ Top + 1;    END;  Pop: PROCEDURE RETURNS [ExpressionDefs.Operation] =    BEGIN    IF Top = 0 THEN SIGNAL AssInputDefs.AssErr[17];    Top ¬ Top - 1;    RETURN[OpSt[Top]];    END;  pred: PROCEDURE [op: ExpressionDefs.Operation]    RETURNS [ExpressionDefs.Operation] =    BEGIN    IF op = FIRST[ExpressionDefs.Operation] THEN ERROR;    RETURN[LOOPHOLE[LOOPHOLE[op, CARDINAL] - 1]];    END;  EvaluateReversePolishStack: PUBLIC PROCEDURE [    RPS: LONG POINTER TO ExpressionDefs.StackItem]    RETURNS [ExpressionDefs.EvalResult] =    BEGIN    ste: LONG POINTER TO SymbolTableDefs.STData;    ptr: LONG POINTER TO ExpressionDefs.StackItem ¬ RPS;    rec: LONG POINTER TO ExpressionDefs.StackItem;    defval: CARDINAL;    WHILE ptr # NIL DO      WITH ptr.tok SELECT FROM        pc => EvalPush[[v, AssInputDefs.GetRelocFlag[]]];        name =>          BEGIN          IF (ste ¬ SymbolTableDefs.LookUpInSymbolTable[id]) = NIL THEN            ste ¬ SymbolTableDefs.PutInSymbolTable[              id, [IOPmain[0]], UnDef, internal, FALSE, TRUE,              CodeOutputDefs.GetPC[], 2, CodeOutputDefs.GetBinaryStreamIndex[]];          IF ste.type = UnDef THEN            BEGIN            WHILE Top # 0 DO              rec ¬ PrivateStorage.heapPointer.NEW[                ExpressionDefs.StackItem ¬ [tok: [value[EvalPop[].v]], nxt: ptr]];              ptr ¬ rec;              ENDLOOP;            RETURN[[FALSE[ptr, id]]];            END          ELSE            IF ste.type = DefSym THEN              BEGIN              defval ¬                WITH x: ste.val SELECT FROM IOPmain => x.addr, ENDCASE => ERROR;              EvalPush[[defval, ste.reloc]];              PrivateStorage.heapPointer.FREE[@id];              END            ELSE SIGNAL AssInputDefs.AssErr[9];          END;        value => EvalPush[[v, FALSE]];        op =>          SELECT opn FROM            unaryplus => NULL;            plus =>              BEGIN              [a, ar] ¬ EvalPop[].res;              [b, br] ¬ EvalPop[].res;              IF ar AND br THEN SIGNAL AssInputDefs.AssErr[12];              EvalPush[[a + b, ar OR br]];              END;            unaryminus =>              BEGIN              [a, ar] ¬ EvalPop[].res;              IF ar THEN SIGNAL AssInputDefs.AssErr[12];              EvalPush[[0 - a, ar]];              END;            minus =>              BEGIN              [a, ar] ¬ EvalPop[].res;              [b, br] ¬ EvalPop[].res;              IF ar AND ~br THEN SIGNAL AssInputDefs.AssErr[12];              EvalPush[[b - a, XOR[ar, br]]];              END;            mult =>              BEGIN              [a, ar] ¬ EvalPop[].res;              [b, br] ¬ EvalPop[].res;              IF ar OR br THEN SIGNAL AssInputDefs.AssErr[12];              EvalPush[[a*b, FALSE]];              END;            div =>              BEGIN              [a, ar] ¬ EvalPop[].res;              [b, br] ¬ EvalPop[].res;              IF ar OR br THEN SIGNAL AssInputDefs.AssErr[12];              EvalPush[[b/a, FALSE]];              END;            ENDCASE => NULL;        ENDCASE;      rec ¬ ptr;      ptr ¬ ptr.nxt;      PrivateStorage.heapPointer.FREE[@rec];      ENDLOOP;    IF EvalTop # 1 THEN SIGNAL AssInputDefs.AssErr[17];    RETURN[[TRUE[EvalPop[]]]];    END;  EvalPush: PROCEDURE [a: ExpressionDefs.EvalType] =    BEGIN    IF EvalTop = ExpressionDefs.MaxStack THEN SIGNAL AssInputDefs.AssErr[17];    EvalSt[EvalTop] ¬ a;    EvalTop ¬ EvalTop + 1;    END;  EvalPop: PROCEDURE RETURNS [res: ExpressionDefs.EvalType] =    BEGIN    IF EvalTop = 0 THEN SIGNAL AssInputDefs.AssErr[17];    EvalTop ¬ EvalTop - 1;    RETURN[EvalSt[EvalTop]];    END;  XOR: PROCEDURE [a, b: BOOLEAN] RETURNS [BOOLEAN] =    BEGIN RETURN[IF a THEN ~b ELSE b]; END;  ReInit: PUBLIC PROC = BEGIN Init[]; END;  Init: PROCEDURE = BEGIN RPFirst ¬ RPLast ¬ NIL; EvalTop ¬ Top ¬ 0; END;  Init[];  END.
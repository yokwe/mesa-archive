-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- Private String Procedures for use with the Debugging Tool-- Last edited by PaD  DXS  May 4, 1979  11:24 AM-- Last edited by PXJ    December 29, 1980  10:51 AM-- Last edited by ETN   on October 20, 1981  8:34 PM - Convert to Trinity.-- Last edited by PXO      on October 23, 1981  1:40 PM - Changed some procs to deal in longs.-- Last edited by PXO      on October 20, 1981  8:34 PM - Changed interfaces to run on Dandelion.-- Last edited by Dennis DEG      on 30-May-83 15:59:05 - Removed references to the Ascii interface.DIRECTORY  Environment USING [bitsPerWord],  PrivateStringDefs USING [BreakProc],  String USING [AppendChar, AppendLongNumber, AppendNumber, AppendString, AppendSubString, SubString, SubStringDescriptor],  System USING [Microseconds, Pulses, PulsesToMicroseconds];PrivateStringProcs: PROGRAM  IMPORTS String, System EXPORTS PrivateStringDefs =  BEGIN  InvalidOctalString: PUBLIC SIGNAL = CODE;  InvalidHexString: PUBLIC SIGNAL = CODE;  CopyString: PUBLIC PROCEDURE [to, from: LONG STRING] =    BEGIN    IF from = to THEN RETURN;    to.length ¬ 0;    String.AppendString[to, from]    END;  ReplaceLeadingZeroes: PUBLIC PROCEDURE [s: STRING] =    BEGIN    FOR i: CARDINAL IN [0..s.length - 1) DO IF s[i] # '0 THEN EXIT; s[i] ¬ '  ENDLOOP    END;  RemoveLeadingBlanks: PUBLIC PROCEDURE [s: LONG STRING] =    BEGIN    i: CARDINAL;    FOR i IN [0..s.length) DO      IF ~BlankCharacter[s[i]] THEN EXIT REPEAT FINISHED => i ¬ s.length ENDLOOP;    IF i # 0 THEN FOR j: CARDINAL IN [i..s.length) DO s[j - i] ¬ s[j] ENDLOOP;    s.length ¬ s.length - i    END;  CheckOctalString: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [v: CARDINAL ¬ 0] =    BEGIN    IF s.length > 6 THEN SIGNAL InvalidOctalString;    FOR i: CARDINAL IN [0..s.length) DO      IF s[i] IN ['0..'7] THEN v ¬ v*8 + (s[i] - '0) ELSE InvalidOctalString;      ENDLOOP;    RETURN[v]    END;  CheckHexString: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [v: CARDINAL ¬ 0] =    BEGIN    IF s.length > 4 THEN SIGNAL InvalidHexString;    FOR i: CARDINAL IN [0..s.length) DO      SELECT s[i] FROM        IN ['0..'9] => v ¬ v*16 + (s[i] - '0);        IN ['A..'F] => v ¬ v*16 + (s[i] - 'A + 10);        IN ['a..'f] => v ¬ v*16 + (s[i] - 'a + 10);        ENDCASE => SIGNAL InvalidHexString;      ENDLOOP    END;  StringFromOctal: PUBLIC PROCEDURE [str: STRING, v: CARDINAL] =    BEGIN    str.length ¬ 6;    FOR i: CARDINAL DECREASING IN [0..5] DO str[i] ¬ v MOD 8 + '0; v ¬ v/8 ENDLOOP;    END;  StringFromHex: PUBLIC PROCEDURE [str: LONG STRING, v: CARDINAL] =    BEGIN    str.length ¬ 4;    FOR i: CARDINAL DECREASING IN [0..3] DO      r: CARDINAL ¬ v MOD 16;      str[i] ¬ IF r < 10 THEN r + '0 ELSE r - 10 + 'A;      v ¬ v/16      ENDLOOP    END;  AppendHexNumber: PUBLIC PROCEDURE [s: LONG STRING, n, w: CARDINAL] =    BEGIN    ls: STRING ¬ [4];    ls.length ¬ 4;    FOR i: CARDINAL DECREASING IN [0..3] DO      m: CARDINAL ¬ n MOD 16;      n ¬ n/16;      ls[i] ¬ IF m < 10 THEN m + '0 ELSE m + 'A - 10      ENDLOOP;    IF w > 4 THEN      BEGIN      THROUGH [4..w) DO String.AppendChar[s, ' ] ENDLOOP;      String.AppendString[s, ls];      END    ELSE FOR i: CARDINAL IN [4 - w..4) DO String.AppendChar[s, ls[i]] ENDLOOP;    END;  FindRoot: PUBLIC PROCEDURE [s, root, ext: STRING] RETURNS [CARDINAL] =    BEGIN    ssd: String.SubStringDescriptor;    ss: String.SubString = @ssd;    IF TrimString[s] = 0 THEN RETURN[0];    root.length ¬ 0;    String.AppendString[root, s];    FOR i: CARDINAL DECREASING IN [0..s.length - 1] DO      IF s[i] = '. THEN GO TO Found      REPEAT        Found => IF i = 0 THEN RETURN[0] ELSE ss­ ¬ [s, 0, i];        FINISHED =>          BEGIN          ss­ ¬ [s, 0, s.length];          String.AppendChar[s, '.];          String.AppendString[s, ext]          END      ENDLOOP;    root.length ¬ 0;    String.AppendSubString[root, ss];    RETURN[root.length]    END;  AppendRateInfo: PUBLIC PROCEDURE [    s: STRING, start, stop: System.Pulses, count: LONG CARDINAL,    blocks: CARDINAL] =    BEGIN    StartMuSec: System.Microseconds = System.PulsesToMicroseconds[start];    StopMuSec: System.Microseconds = System.PulsesToMicroseconds[stop];    mSec: LONG CARDINAL =      (IF StopMuSec >= StartMuSec THEN (StopMuSec - StartMuSec)       ELSE ((LAST[LONG CARDINAL] - StartMuSec) + 1 + StopMuSec))/1000;    String.AppendNumber[s, blocks, 10];    String.AppendString[s, " blocks ("L];    String.AppendLongNumber[s, count, 10];    String.AppendString[s, " words) in "L];    String.AppendLongNumber[s, mSec, 10];    String.AppendString[s, " msec, "L];    String.AppendLongNumber[s, (count*1000*Environment.bitsPerWord)/mSec, 10];    String.AppendString[s, " bits/sec"L]    END;  RemoveTrailingBlanks: PUBLIC PROCEDURE [s: LONG STRING] =    BEGIN    IF s.length = 0 THEN RETURN;    FOR i: CARDINAL DECREASING IN [0..s.length - 1] WHILE BlankCharacter[s[i]] DO      s.length ¬ s.length - 1 ENDLOOP    END;  BlankCharacter: PUBLIC PROCEDURE [c: CHARACTER] RETURNS [BOOLEAN] =    BEGIN    RETURN[      SELECT c FROM        '\F, ' , '\N, '\L, '\T => TRUE,        ENDCASE => FALSE]    END;  TrimSubString: PUBLIC PROCEDURE [ss: String.SubString] RETURNS [CARDINAL] =    BEGIN    i: CARDINAL;    IF ss.length = 0 THEN RETURN[0];    --remove leading blanks--    FOR i IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN EXIT      REPEAT FINISHED => --all blanks-- RETURN[ss.length ¬ 0]      ENDLOOP;    IF (ss.length ¬ ss.length - (i - ss.offset)) = 0 THEN RETURN[0];    ss.offset ¬ i;    --remove trailing blanks--    FOR i DECREASING IN [ss.offset..ss.offset + ss.length) DO      IF ~BlankCharacter[ss.base[i]] THEN EXIT REPEAT FINISHED => ERROR ENDLOOP;    RETURN[ss.length ¬ ss.length - (ss.offset + ss.length - 1 - i)]    END;  TrimString: PUBLIC PROCEDURE [s: LONG STRING] RETURNS [CARDINAL] =    BEGIN RemoveTrailingBlanks[s]; RemoveLeadingBlanks[s]; RETURN[s.length] END;  NextToken: PUBLIC PROCEDURE [    rest, token: String.SubString, Break: PrivateStringDefs.BreakProc] =    BEGIN    lop, i: CARDINAL;    punctuation: BOOLEAN;    token­ ¬ rest­;    IF rest.length = 0 THEN RETURN;    punctuation ¬ Break[rest.base[rest.offset]];    FOR i IN [rest.offset..rest.offset + rest.length - 1] DO      IF Break[rest.base[i]] # punctuation THEN GO TO More      REPEAT        More => token.length ¬ i - rest.offset;        FINISHED => token.length ¬ rest.length      ENDLOOP;    rest.offset ¬ i;    rest.length ¬ rest.length - token.length;    IF ~punctuation THEN RETURN;    --strip off leading spaces--    FOR i IN [token.offset..token.offset + token.length - 1] DO      IF ~BlankCharacter[token.base[i]] THEN EXIT      REPEAT        FINISHED => --token is all spaces-- BEGIN token.length ¬ 1; RETURN END      ENDLOOP;    token.length ¬ token.length - (i - token.offset);    token.offset ¬ i;    --accumulate non-spaces--    FOR i IN [token.offset..token.offset + token.length - 1] DO      IF BlankCharacter[token.base[i]] THEN EXIT      REPEAT FINISHED => --no trailing spaces-- RETURN      ENDLOOP;    lop ¬ token.length - (i - token.offset);    token.length ¬ token.length - lop;    --discard tail of token onto beginning of rest--    rest.offset ¬ rest.offset - lop;    rest.length ¬ rest.length + lop;    --strip spaces away from beginning of rest--    FOR i IN [rest.offset..rest.offset + rest.length - 1] DO      IF ~BlankCharacter[rest.base[i]] THEN EXIT      REPEAT        FINISHED =>          BEGIN  --rest is all spaces--          rest.offset ¬ rest.length;          rest.length ¬ 0;          RETURN          END      ENDLOOP;    rest.length ¬ rest.length - (i - rest.offset);    rest.offset ¬ i    END;  END.
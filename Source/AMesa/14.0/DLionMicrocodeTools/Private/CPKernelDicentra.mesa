-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- CPKernelDicentra.mesa, HGM, 19-Feb-84 18:03:48DIRECTORY  Environment USING [Block, Byte],  Inline USING [BITAND, BITOR, BITSHIFT, HighByte, HighHalf, LowByte, LowHalf],  Runtime USING [GetTableBase],  BurdockTables USING [    KernelDicentra, KernelHighDicentra, ReadLinkDicentra, ResetMapDicentra, WriteBlockDicentra],  CP USING [    Bank, BankAndWordsPerBank, Cycle, Link, numberOfBanks,    RealCS, UReg, Task, wordsPerBank],  CPKernel USING [Error, Machine, State],  CPKernelConstants ,  CPKernelOps USING [    AddressOutOfRange, LoadFromMemory, LoadOverlay,    PrepareToContinueAfterBreak, ReadCSInternal,    SaveCurrentBreakID, WriteCSInternal],  CPMI USING [AD, AF, AS, FS01, FS23, FX, FY, FYNorm, FZ, MI],  IOPKernelOps USING [lock, InitializeLock],  Teather USING [    Boot, Continue, Error, GetCycle, Initialize,    PokeInit, ReadWord, ReadCPByte, ReadCPReady,    SingleCycleFromCSA, SingleCycleFromNIA, Stop, WriteCPByte,    WriteCPBlock, WriteCPWord, WriteWord];CPKernelDicentra: MONITOR LOCKS IOPKernelOps.lock  IMPORTS    Inline, Runtime,    BurdockTables, CPKernel, CPKernelOps, IOPKernelOps, Teather  EXPORTS CPKernel, CPKernelOps =  BEGIN OPEN CPKernelConstants;    machine: PUBLIC CPKernel.Machine ¬ dicentra;  maxBreaks: PUBLIC CARDINAL ¬ 256;      state: CPKernel.State ¬ dead;  seq, boot: CARDINAL ¬ 0;  kernelLoaded: BOOLEAN ¬ FALSE;  currentBank, savedBank: CARDINAL ¬ 0;  banksThisMachine: CARDINAL ¬ 0;  savedTpc, kernelTpc: CP.RealCS;    InKernel: PUBLIC ENTRY PROCEDURE RETURNS [BOOLEAN] =    BEGIN ENABLE UNWIND => NULL;    RETURN[SELECT state FROM      dead => FALSE,      halted => TRUE,      running => FALSE,      cpBreak, iopStopped => TRUE,      ENDCASE => ERROR ];    END;        GetState: PUBLIC ENTRY PROCEDURE RETURNS [CPKernel.State] =    BEGIN    RETURN[state];    END;  GetStateInternal: PUBLIC INTERNAL PROCEDURE RETURNS [CPKernel.State] =    BEGIN    RETURN[state];    END;  GetStateSeq: PUBLIC ENTRY PROCEDURE RETURNS [CARDINAL] =    BEGIN    RETURN[seq];    END;    GetBootSeq: PUBLIC ENTRY PROCEDURE RETURNS [CARDINAL] =    BEGIN    RETURN[boot];    END;      ProbeForStateChange: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    IF state # running THEN RETURN;    IF ~Teather.ReadCPReady[] THEN RETURN;    -- The only reason that it sends us anything is to tell us about a breakpoint    [] ¬ ReadCPByte[];    Teather.Stop[];    SetNewBank[0];    Teather.Continue[];    CPKernelOps.SaveCurrentBreakID[];    SetNewState[cpBreak];    END;    Boot: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      Teather.Error => CPKernel.Error[reason];      UNWIND => NULL;      END;    SetNewState[dead];    boot ¬ boot + 1;    kernelLoaded ¬ FALSE;    currentBank ¬ savedBank ¬ 0;    banksThisMachine ¬ 1;    Teather.Initialize[];    Teather.Boot[];    END;    HalfBoot: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      Teather.Error => CPKernel.Error[reason];      UNWIND => NULL;      END;    SetNewState[dead];    boot ¬ boot + 1;    kernelLoaded ¬ FALSE;    currentBank ¬ savedBank ¬ 0;    banksThisMachine ¬ 1;    Teather.Initialize[];    Teather.Boot[];    SetNewState[halted];    END;    FindBanks: PUBLIC ENTRY PROCEDURE RETURNS [CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    Teather.Stop[];  -- Kernel is running..    banksThisMachine ¬ CP.numberOfBanks;  -- Bypass error trap    FOR bank: CP.Bank IN [1..CP.numberOfBanks) DO      cs: CP.RealCS = bank * CP.wordsPerBank + kBuffer + 2;  -- SetNewBank uses kBuffer[0..1]      Three: TYPE = RECORD [a, b, c: WORD];      address: CPMI.MI = LOOPHOLE[Three[cs, 0, cs]];  -- parity      CPKernelOps.WriteCSInternal[cs, address];      IF CPKernelOps.ReadCSInternal[kBuffer + 2] = address THEN        BEGIN	IF bank # 1 THEN ERROR CPKernel.Error["Bank searching mixup - write smashed bank 0"L];	Teather.Continue[];	RETURN[banksThisMachine ¬ 1];	END;      IF CPKernelOps.ReadCSInternal[cs] # address THEN        BEGIN	Teather.Continue[];	RETURN[banksThisMachine ¬ bank];	END;      ENDLOOP;    Teather.Continue[];    RETURN[banksThisMachine ¬ CP.numberOfBanks];    END;    Reset: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    SetNewState[dead];    boot ¬ boot + 1;    savedBank ¬ 0;    WriteTpcInternal[0, kIdle];  -- GOTO[kIdle]    SetNewState[halted];    END;    LoadKernel: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    SetNewBank[0];    CPKernelOps.LoadFromMemory[Runtime.GetTableBase[BurdockTables.KernelDicentra], 0];    END;    LoadKernelHigh: PUBLIC ENTRY PROCEDURE [bank: CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    SetNewBank[bank];    CPKernelOps.LoadFromMemory[Runtime.GetTableBase[BurdockTables.KernelHighDicentra], bank];    SetNewBank[0];    Teather.PokeInit[]; -- Kernel catches all Traps.    END;    StartKernel: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    RawWriteTpcInternal[kernelTpc, TRUE];    Teather.Continue[];    Teather.PokeInit[]; -- Kernel catches all Traps.    SetNewState[halted];    kernelLoaded ¬ TRUE;    END;    Continue: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    Teather.Stop[];    SetNewBank[savedBank];    RawWriteTpcInternal[savedTpc, FALSE];    SetNewState[running];    Teather.Continue[];    END;    ContinueAfterBreak: PUBLIC ENTRY PROCEDURE [    mi: CPMI.MI, cycle: CP.Cycle, task: CP.Task] =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    Teather.Stop[];    SetNewBank[savedBank];    CPKernelOps.PrepareToContinueAfterBreak[mi, cycle, task, savedBank];    RawWriteTpcInternal[savedTpc, FALSE];    SetNewState[running];    Teather.Continue[];    END;  Stop: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    SELECT state FROM      dead => ERROR CPKernel.Error["CP/IOP is dead"L];      halted => RETURN;      running => NULL;      cpBreak, iopStopped => RETURN;      ENDCASE => ERROR;    savedTpc ¬ GetCleanPCAndStartKernel[];    savedBank ¬ LOOPHOLE[savedTpc, CP.BankAndWordsPerBank].bank;    Teather.Stop[];    SetNewBank[0];    Teather.Continue[];    SetNewState[halted];    END;    MaybeSetNewState: INTERNAL PROCEDURE [new: CPKernel.State] =    BEGIN    IF state = new THEN RETURN;    SetNewState[new];    END;    SetNewState: PUBLIC INTERNAL PROCEDURE [new: CPKernel.State] =    BEGIN    seq ¬ seq + 1;    state ¬ new;    END;  WriteCPCommand: PUBLIC INTERNAL PROCEDURE [command: Command] =    BEGIN    WriteCPByte[LOOPHOLE[command]];    END;    WriteCPByte: PUBLIC INTERNAL PROCEDURE [data: Environment.Byte] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    Teather.WriteCPByte[data];    END;      WriteCPWord: PUBLIC INTERNAL PROCEDURE [data: WORD] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    Teather.WriteCPWord[data];    END;      ReadCPByte: PUBLIC INTERNAL PROCEDURE RETURNS [Environment.Byte] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    RETURN[Teather.ReadCPByte[]];    END;  WriteBank: PUBLIC ENTRY PROCEDURE [bank: CP.Bank] =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    Teather.Stop[];    SetNewBank[bank];  -- Validity check    savedBank ¬ bank;    SetNewBank[0];    Teather.Continue[];    END;  RawWriteBank: PUBLIC ENTRY PROCEDURE [bank: CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    -- Yetch, copy all this code to avoid error trap    IF (kBuffer + 11) # 0FFFH THEN ERROR;  -- Catch dangling branch    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't switch banks until Kernel has been loaded"L];    IF currentBank # 0 THEN      BEGIN      currentBank ¬ 0;      ExecuteCPBuffer[];  -- The instruction we left behind      END;    IF bank = 0 THEN RETURN;    CPKernelOps.WriteCSInternal[      kBuffer + 0, CPMI.MI[      , , dz, rOrS, , , , , , , nibble, , [n[bank]], [d[0]], kWait]];    CPKernelOps.WriteCSInternal[      kBuffer + 1, CPMI.MI[      , , dz, rOrS, , , , , , , nibble, , [n[bank]], [d[bank]], kBuffer + 11]];    CPKernelOps.WriteCSInternal[      kBuffer + 11, CPMI.MI[      , , , , , , , , , , , , , , kWait]];    WriteTpcInternal[7, kBuffer + 1];    currentBank ¬ bank;    END;  SetNewBank: PUBLIC INTERNAL PROCEDURE [bank: CP.Bank] =    BEGIN ENABLE      BEGIN      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;      UNWIND => NULL;      END;    locOfTemp: CP.RealCS = kBuffer + 11;    IF bank = currentBank THEN RETURN;    IF bank >= banksThisMachine THEN ERROR CPKernel.Error["Bank number too big"L];    CPKernelOps.WriteCSInternal[      locOfTemp, CPMI.MI[ , , dz, rOrS, , , , , , fyNorm, nibble, , [n[bank]], [d[bank]] , kWait]];    Teather.WriteWord[csaMsb, locOfTemp];    Teather.SingleCycleFromCSA[];    currentBank ¬ bank;    END;  ExecuteCPBuffer: PUBLIC INTERNAL PROCEDURE =    BEGIN    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't Execute Buffer before Kernel loaded"L];    WriteCPCommand[Command[executeBuffer]];    END;  WriteUSpecial: PUBLIC INTERNAL PROCEDURE [u: CP.UReg, data: WORD] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    temp: PACKED ARRAY [0..4) OF Environment.Byte;    block: Environment.Block ¬ [LOOPHOLE[LONG[@temp]], 0, 4];    IF ~kernelLoaded THEN ERROR CPKernel.Error["Can't WriteU before Kernel loaded"L];    IF FALSE THEN      BEGIN      WriteCPCommand[writeU];      WriteCPByte[Inline.HighByte[data]];      WriteCPByte[Inline.LowByte[data]];      WriteCPByte[u];      RETURN;      END;    temp ¬ [      LOOPHOLE[Command[writeU]],      Inline.HighByte[data],      Inline.LowByte[data],      u];    Teather.WriteCPBlock[block];    END;     ReadTpc: PUBLIC ENTRY PROCEDURE [task: CP.Task] RETURNS [CP.RealCS] =    BEGIN ENABLE UNWIND => NULL;    SELECT task FROM      0 => RETURN[savedTpc];      kernelTask => RETURN[kernelTpc];      ENDCASE => ERROR CPKernel.Error["Can't read strange TPC"L];     END;   ReadBank: PUBLIC ENTRY PROCEDURE RETURNS [CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    RETURN[savedBank];    END;   RawReadBank: PUBLIC ENTRY PROCEDURE RETURNS [CP.Bank] =    BEGIN ENABLE UNWIND => NULL;    RETURN[RawReadBankInternal[]];    END;   RawReadBankInternal: INTERNAL PROCEDURE RETURNS [CP.Bank] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    nia: CP.BankAndWordsPerBank;    nia ¬ LOOPHOLE[Teather.ReadWord[niaMsb]];    RETURN[nia.bank];    END;   RawReadTpcInternal: INTERNAL PROCEDURE RETURNS [CP.RealCS] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    nia: CP.BankAndWordsPerBank;    nia ¬ LOOPHOLE[Teather.ReadWord[niaMsb]];    RETURN[nia.wordInBank];    END;   WriteTpc: PUBLIC ENTRY PROCEDURE [task: CP.Task, pc: CP.RealCS] =    BEGIN ENABLE UNWIND => NULL;    WriteTpcInternal[task, pc];    END;   WriteTpcInternal: PUBLIC INTERNAL PROCEDURE [task: CP.Task, pc: CP.RealCS] =    BEGIN    data: CP.BankAndWordsPerBank = LOOPHOLE[pc];    SELECT task FROM      0 =>        BEGIN	savedTpc ¬ pc;        IF banksThisMachine > 1 THEN savedBank ¬ data.bank;	END;      kernelTask => kernelTpc ¬ pc;      ENDCASE => ERROR CPKernel.Error["Can't write strange TPC"L];     END;    -- This is a bit complicated because of the pipelining in MIR.  -- We need to execute our GOTO[x] twice since the instruction already in MIR may  -- be a branch that would mangle our target address. Next, we have to wait for c3.  -- During c3, we will fetch the instruction to be executed in the next c1, so we   -- single step once more using NIA rather than CSA.  -- As a hack/convience, we also ClrIntErrs since Boot leaves a danging Init trap.  -- Also, somebody has to check for a wedged machine.  RawWriteTpcInternal: INTERNAL PROCEDURE [pc: CP.RealCS, clearInterrupts: BOOLEAN] =    BEGIN    locOfTemp: CP.RealCS = savedBank * CP.wordsPerBank + kBuffer + 11;    temp: CPMI.MI = CPKernelOps.ReadCSInternal[locOfTemp];    fy: CPMI.FYNorm = IF clearInterrupts THEN clrIntErr ELSE noop;    CPKernelOps.WriteCSInternal[locOfTemp, CPMI.MI[ , , , , , , , , , fyNorm, , , [n[fy]], , pc]];    Teather.WriteWord[csaMsb, locOfTemp];    Teather.SingleCycleFromCSA[];    Teather.SingleCycleFromCSA[];    Teather.SingleCycleFromCSA[];    Teather.SingleCycleFromCSA[];    FOR i: CARDINAL IN [0..6) DO      Teather.SingleCycleFromCSA[];      IF Teather.GetCycle[] = 1 THEN EXIT;      REPEAT FINISHED => ERROR CPKernel.Error["Didn't get to cycle 1"L];      ENDLOOP;    FOR i: CARDINAL IN [0..6) DO      Teather.SingleCycleFromCSA[];      IF Teather.GetCycle[] = 3 THEN EXIT;      REPEAT FINISHED => ERROR CPKernel.Error["Didn't get to cycle 3"L];      ENDLOOP;    Teather.SingleCycleFromNIA[];    CPKernelOps.WriteCSInternal[locOfTemp, temp];    END;    -- More complications...  We want to stop on a click boundry and save the PC.  -- If we just stop, the instruction in MIR will get lost.  -- So we wait till c3, save NIA, and execute what's in MIR.  GetCleanPCAndStartKernel: INTERNAL PROCEDURE RETURNS [nia: CP.RealCS] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    locOfTemp: CP.RealCS = kBuffer + 11;    temp: CPMI.MI;    check: CP.RealCS;    Teather.Stop[];    temp ¬ CPKernelOps.ReadCSInternal[locOfTemp];    IF Teather.GetCycle[] # 3 THEN ERROR CPKernel.Error["Didn't stop on cycle 3"L];    nia ¬ Teather.ReadWord[niaMsb];    CPKernelOps.WriteCSInternal[locOfTemp, CPMI.MI[ , , , , , , , , , , , , , , kWait]];    Teather.WriteWord[csaMsb, locOfTemp];    Teather.SingleCycleFromCSA[];    IF Teather.GetCycle[] # 1 THEN ERROR CPKernel.Error["Didn't get to cycle 1"L];    check ¬ Teather.ReadWord[niaMsb];    IF check # kWait THEN ERROR CPKernel.Error["Didn't get to kWait"L];    CPKernelOps.WriteCSInternal[locOfTemp, temp];    Teather.Continue[];    END;       ReadTc: PUBLIC ENTRY PROCEDURE [task: CP.Task] RETURNS [Nibble] =    BEGIN ENABLE UNWIND => NULL;    ERROR CPKernel.Error["Can't read TC bits"L];    END;   WriteTc: PUBLIC PROCEDURE [task: CP.Task, tc: Nibble] =    BEGIN    ERROR CPKernel.Error["Can't write TC bits"L];    END;        WriteMemoryBlock: PUBLIC ENTRY PROCEDURE [    to: LONG POINTER, count: CARDINAL, data: LONG POINTER] =    BEGIN ENABLE UNWIND => NULL;    CPKernelOps.LoadOverlay[Runtime.GetTableBase[BurdockTables.WriteBlockDicentra]];    WriteNextMemoryBlockInternal[to, count, data];    END;  WriteNextMemoryBlock: PUBLIC ENTRY PROCEDURE [    to: LONG POINTER, count: CARDINAL, data: LONG POINTER] =    BEGIN ENABLE UNWIND => NULL;    WriteNextMemoryBlockInternal[to, count, data];    END;  WriteNextMemoryBlockInternal: INTERNAL PROCEDURE [    to: LONG POINTER, count: CARDINAL, data: LONG POINTER] =    BEGIN ENABLE      Teather.Error => BEGIN SetNewState[dead]; CPKernel.Error[reason]; END;    bufferSize: CARDINAL = 1000;    block: Environment.Block;    IF Inline.HighHalf[to] ~IN [0..07H] THEN CPKernelOps.AddressOutOfRange[];  -- No P2    IF Inline.HighHalf[to] ~IN [0..0FH] THEN CPKernelOps.AddressOutOfRange[];    WriteUSpecial[uKCount, count];    WriteUSpecial[uKAddr, Inline.LowHalf[to]];    WriteUSpecial[uKernMD, Inline.HighHalf[to]];  --must be last, loads RHrk    ExecuteCPBuffer[];    IF FALSE THEN      BEGIN      FOR i: CARDINAL IN [0..count) DO        WriteCPWord[(data+i)­];        ENDLOOP;      RETURN;      END;    UNTIL count < bufferSize DO      block ¬ [data, 0, 2*bufferSize];      Teather.WriteCPBlock[block];      data ¬ data + bufferSize;      count ¬ count - bufferSize;      ENDLOOP;    IF count # 0 THEN      BEGIN      block ¬ [data, 0, 2*count];      Teather.WriteCPBlock[block];      END;    END;    ResetMap: PUBLIC ENTRY PROCEDURE =    BEGIN ENABLE UNWIND => NULL;    CPKernelOps.LoadOverlay[Runtime.GetTableBase[BurdockTables.ResetMapDicentra]];    ExecuteCPBuffer[];    --this takes ~5 msec, overlay sends a byte when done to synchronize    [] ¬ ReadCPByte[]    END;      ReadLink: PUBLIC ENTRY PROCEDURE [link: CP.Link] RETURNS [data: Nibble] =    BEGIN ENABLE UNWIND => NULL;    -- Link is read in three parts: Link[2-3], Link[0], & Link[1].    -- Link[0] & Link[1] are read by 1-inst overlays at kBuffer + 1.    --kBuffer: pRet0,				c1, at[kBuffer];    --	       DISP2[KLinkC, C],		c2, at[0FF5x] {+1};    --KLink7:  IOPOData¬ 0, GOTO[kWait],	c3, at[0FF7x] {+3};    --KLinkB:  IOPOData¬ 0, GOTO[kWait],	c3, at[0FFBx] {+7};    --KLinkC:  IOPOData¬ 0, GOTO[kWait],	c3, at[0FFCx] {+8};    --         IOPOData¬ 1, GOTO[kWait],	c3, at[0FFDx] {+9};    --         IOPOData¬ 2, GOTO[kWait],	c3, at[0FFEx] {+A};    --KLinkF:  IOPOData¬ 3, GOTO[kWait],	c3, at[0FFFx] {+B};    --         BRANCH[KLink7, KLinkF, 7], at[kBufferExten];   {Get Link[0]}    --         BRANCH[KLinkB, KLinkF, 0B], at[kBufferExten+1];   {Get Link[1]}    IF link ~IN CP.Link THEN CPKernelOps.AddressOutOfRange[];    CPKernelOps.LoadOverlay[Runtime.GetTableBase[BurdockTables.ReadLinkDicentra]];    CPKernelOps.WriteCSInternal[kBuffer, CPMI.MI[      , , , , , , , , , , , LOOPHOLE[link], , , kBuffer + 1]];    ExecuteCPBuffer[];    data ¬ ReadCPByte[];  -- Link[2-3]    CPKernelOps.WriteCSInternal[kBuffer + 1, CPMI.MI[      , , , , , , , , , , , , , , kBuffer + 3]];    ExecuteCPBuffer[];    data ¬ Inline.BITOR[data, Inline.BITSHIFT[Inline.BITAND[ReadCPByte[], 1], 3]];  -- Link[0]    CPKernelOps.WriteCSInternal[kBuffer + 1, CPMI.MI[      , , , , , , , , , , , , , , kBuffer + 7]];    ExecuteCPBuffer[];    data ¬ Inline.BITOR[data, Inline.BITSHIFT[Inline.BITAND[ReadCPByte[], 1], 2]];  --Link[1]    END;    [] ¬ IOPKernelOps.InitializeLock[];  END.
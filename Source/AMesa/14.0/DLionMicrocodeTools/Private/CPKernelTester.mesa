-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- CPKernelTester.mesa, HGM, 18-Oct-83 21:15:12-- Please don't forget to update the heraldDIRECTORY  Environment USING [Byte],  FormSW USING [    AllocateItemDescriptor, ClientItemsProcType, CommandItem,    newLine, ProcType],  Inline USING [BITAND],  Process USING [Yield],  Put USING [CR, Line, Number, Text],  TextSW USING [ForceOutput],  Tool USING [Create, MakeFormSW, MakeFileSW, MakeSWsProc, UnusedLogName],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  Window USING [Handle],    CP USING [Bank, RReg, RealCS, Task, UReg, wordsPerBank],  CPKernel USING [    Error, HalfBoot, ReadCS, ReadRReg, ReadTpc, ReadUReg,    StartKernel, WriteBank, WriteCS, WriteCSBad, WriteRReg, WriteTpc, WriteUReg],  CPKernelOps USING [ReadCPByte],  CPMI USING [MI],  IOPKernelOps USING [lock];CPKernelTester: MONITOR LOCKS IOPKernelOps.lock  IMPORTS    FormSW, Inline, Process, Put, TextSW, Tool, UserInput,    CPKernel, CPKernelOps, IOPKernelOps =  BEGIN    form, log: Window.Handle;    TestTpc: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Testing TPCs ... "L];    BootIOP[];    FOR task: CP.Task IN CP.Task DO      found: WORD;      CPKernel.WriteTpc[task, 0];      found ¬ CPKernel.ReadTpc[task];      IF found # 0 THEN PrintTPCMixup[task, 0, found];      CPKernel.WriteTpc[task, 0FFFH];      found ¬ CPKernel.ReadTpc[task];      IF found # 0FFFH THEN PrintTPCMixup[task, 0FFFH, found];      CPKernel.WriteTpc[task, task];      found ¬ CPKernel.ReadTpc[task];      IF found # task THEN PrintTPCMixup[task, task, found];      ENDLOOP;    FOR task: CP.Task IN CP.Task DO      found: WORD;      found ¬ CPKernel.ReadTpc[task];      IF found # task THEN PrintTPCMixup[task, task, found];      ENDLOOP;    TailMessage["ok"L];    END;  WriteTpc: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Writing TPCs ... "L];    BootIOP[];    UNTIL UserInput.UserAbort[log] DO      FOR task: CP.Task IN CP.Task DO        CPKernel.WriteTpc[task, 0];        CPKernel.WriteTpc[task, 0FFFH];        ENDLOOP;      ENDLOOP;    TailMessage["ok"L];    END;  ReadTpc: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Reading TPCs ... "L];    BootIOP[];    UNTIL UserInput.UserAbort[log] DO    FOR task: CP.Task IN CP.Task DO        [] ¬ CPKernel.ReadTpc[task];        ENDLOOP;      ENDLOOP;    TailMessage["ok"L];    END;  WriteReadTpc: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Writing and Reading TPCs ... "L];    BootIOP[];    UNTIL UserInput.UserAbort[log] DO    FOR task: CP.Task IN CP.Task DO        CPKernel.WriteTpc[task, 0];        [] ¬ CPKernel.ReadTpc[task];        CPKernel.WriteTpc[task, 0FFFH];        [] ¬ CPKernel.ReadTpc[task];        ENDLOOP;      ENDLOOP;    TailMessage["ok"L];    END;      Bank0: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Switching to Bank 0 ..."L];    CPKernel.WriteBank[0];    TailMessage[" ok"L];    END;        Hickup: SIGNAL [reason: LONG STRING, cs: CP.RealCS, found, expected: CPMI.MI] = CODE;  Three: TYPE = RECORD [a, b, c: WORD];  TestBank0: FormSW.ProcType =    BEGIN ENABLE      BEGIN CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      Hickup =>        BEGIN	WriteInfo[reason, cs, found, expected];	IF UserInput.UserAbort[log] THEN CONTINUE;        RESUME;        END;      END;    PostMessage["Testing Bank 0 of control store (! = 64 wds)"L];    BootIOP[];    TailMessage[""L];    error ¬ FALSE;    FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO      zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];      ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];      address: CPMI.MI = LOOPHOLE[Three[cs, 0, cs]];  -- parity      result: CPMI.MI;      IF UserInput.UserAbort[log] THEN EXIT;      SELECT TRUE FROM        (cs = 0) => NULL;        ((cs MOD 64) = 0) => AppendMessage["!"L];	ENDCASE => NULL;      CPKernel.WriteCS[cs, zeros];      result ¬ CPKernel.ReadCS[cs];      IF result # zeros THEN SIGNAL Hickup["Didn't get zeros back"L, cs, result, zeros];      CPKernel.WriteCS[cs, ones];      result ¬ CPKernel.ReadCS[cs];      IF result # ones THEN SIGNAL Hickup["Didn't get ones back"L, cs, result, ones];      CPKernel.WriteCS[cs, address];      result ¬ CPKernel.ReadCS[cs];      IF result # address THEN SIGNAL Hickup["Didn't get address back"L, cs, result, address];      Process.Yield[];      ENDLOOP;    TailMessage[" ok"L];    IF UserInput.UserAbort[log] THEN RETURN;    NewMessage["Check pass ... (! = 64 wds)"L];    TailMessage[""L];    FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO      address: CPMI.MI = LOOPHOLE[Three[cs, 0, cs]];      result: CPMI.MI;      IF UserInput.UserAbort[log] THEN EXIT;      SELECT TRUE FROM        (cs = 0) => NULL;        ((cs MOD 64) = 0) => AppendMessage["!"L];	ENDCASE => NULL;      result ¬ CPKernel.ReadCS[cs];      IF result # address THEN SIGNAL Hickup["Didn't get address back"L, cs, result, address];      ENDLOOP;    TailMessage[" ok"L];    END;    TestMIR: FormSW.ProcType =    BEGIN ENABLE      BEGIN CPKernel.Error =>        BEGIN        TailMessage[reason];        CONTINUE;        END;      Hickup =>        BEGIN	WriteInfo[reason, cs, found, expected];	IF UserInput.UserAbort[log] THEN CONTINUE;        RESUME;        END;      END;    cs: CP.RealCS = 0;    -- 2 bits on at the same time to make parity come out right    low: CPMI.MI ¬ LOOPHOLE[Three[0, 0, 3]];    high: CPMI.MI ¬ LOOPHOLE[Three[0FFFFH, 0FFFFH, 177774B]];    PostMessage["Testing for shorted bits in MIR..."L];    BootIOP[];    TailMessage[""L];    error ¬ FALSE;    FOR i: CARDINAL IN [0..48) DO      result: CPMI.MI;      IF UserInput.UserAbort[log] THEN EXIT;      CPKernel.WriteCS[cs, low];      result ¬ CPKernel.ReadCS[cs];      IF result # low THEN SIGNAL Hickup["Didn't get zeros back"L, cs, result, low];      CPKernel.WriteCS[cs, high];      result ¬ CPKernel.ReadCS[cs];      IF result # high THEN SIGNAL Hickup["Didn't get ones back"L, cs, result, high];      Process.Yield[];      low ¬ Rotate[low];      high ¬ Rotate[high];      ENDLOOP;    TailMessage[" ok"L];    END;  Rotate: PROCEDURE [in: CPMI.MI] RETURNS [CPMI.MI] =    BEGIN    temp: Three ¬ LOOPHOLE[in];    out: Three;    out.a ¬ temp.a * 2;    out.b ¬ temp.b * 2;    out.c ¬ temp.c * 2;    IF Inline.BITAND[temp.a, 8000H] # 0 THEN out.c ¬ out.c + 1;    IF Inline.BITAND[temp.b, 8000H] # 0 THEN out.a ¬ out.a + 1;    IF Inline.BITAND[temp.c, 8000H] # 0 THEN out.b ¬ out.b + 1;    RETURN[LOOPHOLE[out]];    END;  error: BOOLEAN;  WriteInfo: PROCEDURE [reason: LONG STRING, cs: CP.RealCS, found, expected: CPMI.MI] =    BEGIN    IF ~error THEN      BEGIN      Put.Line[log, "."L];      Put.Line[log, " loc          found          expected"L];      error ¬ TRUE;      END;    Put.Number[log, cs, [16, FALSE, TRUE, 4]];    WriteMI[found];    WriteMI[expected];    AppendMessage["  "L];    Put.Line[log, reason];    TextSW.ForceOutput[log];    END;  WriteMI: PROCEDURE [mi: CPMI.MI] =    BEGIN    foo: Three = LOOPHOLE[mi];    Put.Number[log, foo.a, [16, FALSE, TRUE, 7]];    Put.Number[log, foo.b, [16, FALSE, TRUE, 5]];    Put.Number[log, foo.c, [16, FALSE, TRUE, 5]];    END;  WriteBank0: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Writing Bank 0 of control store"L];    BootIOP[];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO        zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];        ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteCS[cs, zeros];        CPKernel.WriteCS[cs, ones];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        ReadBank0: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Reading Bank 0 of control store"L];    BootIOP[];    TailMessage[""L];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO        IF UserInput.UserAbort[log] THEN EXIT;        [] ¬ CPKernel.ReadCS[cs];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        WriteReadBank0: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Writing and Reading Bank 0 of control store"L];    BootIOP[];    UNTIL UserInput.UserAbort[log] DO      FOR cs: CP.RealCS IN [0..CP.wordsPerBank) DO        zeros: CPMI.MI = LOOPHOLE[Three[0, 0, 0]];        ones: CPMI.MI = LOOPHOLE[Three[0FFFFH, 0FFFFH, 0FFFFH]];        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteCS[cs, zeros];        [] ¬ CPKernel.ReadCS[cs];        CPKernel.WriteCS[cs, ones];        [] ¬ CPKernel.ReadCS[cs];        Process.Yield[];        ENDLOOP;      AppendMessage["!"L];      ENDLOOP;    TailMessage[" ok"L];    END;        FlapNIA: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Flapping NIA..."L];    BootIOP[];    UNTIL UserInput.UserAbort[log] DO      FOR i: CARDINAL IN [0..100) DO        [] ¬ CPKernel.ReadCS[0];        [] ¬ CPKernel.ReadCS[CP.wordsPerBank-1];        ENDLOOP;      Process.Yield[];      ENDLOOP;    TailMessage[" ok"L];    END;              TestRRegs: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Testing RRegs ... "L];    FOR r: CP.RReg IN [0..16B] DO  -- R 17B used by Kernel      found: WORD;      CPKernel.WriteRReg[r, 0];      found ¬ CPKernel.ReadRReg[r];      IF found # 0 THEN PrintRRegMixup[r, 0, found];      CPKernel.WriteRReg[r, 0FFFFH];      found ¬ CPKernel.ReadRReg[r];      IF found # 0FFFFH THEN PrintRRegMixup[r, 0FFFFH, found];      CPKernel.WriteRReg[r, r];      found ¬ CPKernel.ReadRReg[r];      IF found # r THEN PrintRRegMixup[r, r, found];      ENDLOOP;    AppendMessage[", check pass ... "L];    FOR r: CP.RReg IN [0..16B] DO  -- R 17B used by Kernel      found: WORD;      found ¬ CPKernel.ReadRReg[r];      IF found # r THEN PrintRRegMixup[r, r, found];      ENDLOOP;    TailMessage["ok"L];    END;        FlapRRegs: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Flapping RRegs ... "L];    DO      IF UserInput.UserAbort[log] THEN EXIT;      FOR r: CP.RReg IN [0..16B] DO  -- R 17B used by Kernel        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteRReg[r, 0];        [] ¬ CPKernel.ReadRReg[r];        CPKernel.WriteRReg[r, 0FFFFH];        [] ¬ CPKernel.ReadRReg[r];        ENDLOOP;      ENDLOOP;    TailMessage["ok"L];    END;        TestURegs: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Testing URegs (! = 8 regs) ... "L];    FOR u: CP.UReg IN [0..256-16-1) DO      found: WORD;      SELECT TRUE FROM        (u = 0) => NULL;        ((u MOD 8) = 0) => AppendMessage["!"L];	ENDCASE => NULL;      IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;      CPKernel.WriteUReg[u, 0];      found ¬ CPKernel.ReadUReg[u];      IF found # 0 THEN PrintURegMixup[u, 0, found];      CPKernel.WriteUReg[u, 0FFFFH];      found ¬ CPKernel.ReadUReg[u];      IF found # 0FFFFH THEN PrintURegMixup[u, 0FFFFH, found];      CPKernel.WriteUReg[u, u];      found ¬ CPKernel.ReadUReg[u];      IF found # u THEN PrintURegMixup[u, u, found];      ENDLOOP;    AppendMessage[", check pass ... "L];    FOR u: CP.UReg IN [0..256-16-1) DO      found: WORD;      IF UserInput.UserAbort[log] THEN BEGIN TailMessage[" aborted"L]; RETURN; END;      found ¬ CPKernel.ReadUReg[u];      IF CPKernel.ReadUReg[u] # u THEN PrintURegMixup[u, u, found];      ENDLOOP;    TailMessage[" ok"L];    END;        FlapURegs: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Flapping URegs ... "L];    DO      IF UserInput.UserAbort[log] THEN EXIT;      FOR u: CP.UReg IN [0..256-16-1) DO        IF UserInput.UserAbort[log] THEN EXIT;        CPKernel.WriteUReg[u, 0];        [] ¬ CPKernel.ReadUReg[u];        CPKernel.WriteUReg[u, 0FFFFH];        [] ¬ CPKernel.ReadUReg[u];        ENDLOOP;      ENDLOOP;    TailMessage[" ok"L];    END;        ZeroURegs: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Zeroing URegs (! = 64 regs) ... "L];    FOR u: CP.UReg IN [0..256-16-1) DO      SELECT TRUE FROM        (u = 0) => NULL;        ((u MOD 64) = 0) => AppendMessage["!"L];	ENDCASE => NULL;      IF UserInput.UserAbort[log] THEN EXIT;      CPKernel.WriteUReg[u, 0];      IF CPKernel.ReadUReg[u] # 0 THEN CPKernel.Error["Didn't get a 0 back"L];      ENDLOOP;    AppendMessage[", check pass ... "L];    FOR u: CP.UReg IN [0..256-16-1) DO      IF UserInput.UserAbort[log] THEN EXIT;      IF CPKernel.ReadUReg[u] # 0 THEN CPKernel.Error["Didn't get a 0 back (check pass)"L];      ENDLOOP;    TailMessage[ "ok"L];    END;        JumpNext: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Filling CS with Jump $ ... "L];    BootIOP[];    FOR cs: CP.RealCS IN [0..CP.wordsPerBank-1) DO      CPKernel.WriteCS[cs, CPMI.MI[, , , , , , , , , , , , , , cs+1]];      ENDLOOP;    CPKernel.WriteCS[CP.wordsPerBank-1, CPMI.MI[, , , , , , , , , , , , , , FIRST[CP.RealCS]]];    CPKernel.WriteCS[0, CPMI.MI[      , , , , , , , , , fyNorm, , , [n[clrIntErr]], , 1]];    CPKernel.WriteTpc[7, FIRST[CP.RealCS]];    CPKernel.StartKernel[];    TailMessage[ "ok"L];    END;        GrabCPByte: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    data: WORD;    PostMessage["Grabbing CP Byte ... "L];    data ¬ ReadCPByte[];    Put.Text[log, "data = "L];    Put.Number[log, data, [16, FALSE, TRUE, 0]];    Put.Text[log, "(16) = "L];    Put.Number[log, data, [8, FALSE, TRUE, 0]];    TailMessage["(8)."L];    END;  ReadCPByte: ENTRY PROCEDURE RETURNS [Environment.Byte] =    BEGIN ENABLE UNWIND => NULL;    RETURN[CPKernelOps.ReadCPByte[]];    END;    HalfBoot: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Booting IOP and HalfBooting CP (Not loading Kernel) ... "L];    BootIOP[];    TailMessage["OK."L];    END;     FillBadParity: FormSW.ProcType =    BEGIN ENABLE CPKernel.Error =>      BEGIN      TailMessage[reason];      CONTINUE;      END;    PostMessage["Filling CS with Jump Bad Parity ... "L];    BootIOP[];    FOR cs: CP.RealCS IN [0..CP.wordsPerBank-1) DO      CPKernel.WriteCSBad[cs, CPMI.MI[, , , , , , , , , , , , , , cs]];      ENDLOOP;    TailMessage[ "ok"L];    END;        BootIOP: PROCEDURE =    BEGIN    CPKernel.HalfBoot[];    END;    PostMessage: PROCEDURE [s: LONG STRING, clear: BOOLEAN ¬ TRUE] =    BEGIN    Put.CR[log];    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  NewMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  AppendMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    TextSW.ForceOutput[log]    END;  TailMessage: PROCEDURE [s: LONG STRING] =    BEGIN    Put.Text[log, s];    Put.Line[log, "."L];    TextSW.ForceOutput[log]    END;  PrintTPCMixup: PROCEDURE [tpc: CP.Task, expected, found: UNSPECIFIED] =    BEGIN    Put.Text[log, "TPC "L];    Put.Number[log, tpc, [16, FALSE, TRUE, 2]];    Put.Text[log, " mixup; expected: "L];    Put.Number[log, expected, [16, FALSE, TRUE, 4]];    Put.Text[log, ", found: "L];    Put.Number[log, found, [16, FALSE, TRUE, 4]];    Put.Line[log, "."L];    END;    PrintRRegMixup: PROCEDURE [r: CP.RReg, expected, found: UNSPECIFIED] =    BEGIN    Put.Text[log, "R "L];    Put.Number[log, r, [16, FALSE, TRUE, 2]];    Put.Text[log, " mixup; expected: "L];    Put.Number[log, expected, [16, FALSE, TRUE, 4]];    Put.Text[log, ", found: "L];    Put.Number[log, found, [16, FALSE, TRUE, 4]];    Put.Line[log, "."L];    END;    PrintURegMixup: PROCEDURE [u: CP.UReg, expected, found: UNSPECIFIED] =    BEGIN    Put.Text[log, "U "L];    Put.Number[log, u, [16, FALSE, TRUE, 2]];    Put.Text[log, " mixup; expected: "L];    Put.Number[log, expected, [16, FALSE, TRUE, 4]];    Put.Text[log, ", found: "L];    Put.Number[log, found, [16, FALSE, TRUE, 4]];    Put.Line[log, "."L];    END;    Initialize: PROCEDURE =    BEGIN    herald: STRING = "CPKernel Tester of 18-Oct-83 21:15:08"L;    [] ¬ Tool.Create[      name: herald,      cmSection: "CPKernel Tester"L,      initialState: inactive,      makeSWsProc: MakeSWs,      clientTransition: ClientTransition];    END;    MakeSWs: Tool.MakeSWsProc =    BEGIN    logFileName: STRING = [40];    form ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    Tool.UnusedLogName[logFileName, "CPKernelTester.log$"L];    log ¬ Tool.MakeFileSW[window: window, name: logFileName];    END;    MakeForm: FormSW.ClientItemsProcType =    BEGIN    i: INTEGER ¬ -1;    nParams: CARDINAL = 20;    items ¬ FormSW.AllocateItemDescriptor[nParams];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestTpc"L, proc: TestTpc, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteTpc"L, proc: WriteTpc];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadTpc"L, proc: ReadTpc];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteReadTpc"L, proc: WriteReadTpc];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "Bank0"L, proc: Bank0, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestMIR"L, proc: TestMIR];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestBank0"L, proc: TestBank0];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteBank0"L, proc: WriteBank0];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ReadBank0"L, proc: ReadBank0];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "WriteReadBank0"L, proc: WriteReadBank0];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "FlapNIA"L, proc: FlapNIA];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "JumpNext"L, proc: JumpNext, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "FillBadParity"L, proc: FillBadParity];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestRRegs"L, proc: TestRRegs, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "FlapRRegs"L, proc: FlapRRegs];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "TestURegs"L, proc: TestURegs];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "FlapURegs"L, proc: FlapURegs];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "ZeroURegs"L, proc: ZeroURegs];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "GrabCPByte"L, proc: GrabCPByte, place: FormSW.newLine];    items[i¬i+1] ¬ FormSW.CommandItem[tag: "HalfBoot"L, proc: HalfBoot];    IF (i+1) # nParams THEN ERROR;    RETURN[items, TRUE];    END;       ClientTransition: ToolWindow.TransitionProcType =    BEGIN    SELECT TRUE FROM      old = inactive =>        BEGIN        END;      new = inactive =>        BEGIN        END;      ENDCASE;    END;	  Initialize[];  END.
-- File: BackupImpl.mesa - last edit:-- bjd                 15-Oct-87 12:18:54-- Copyright (C) 1985, 1986, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Auth USING [IdentityHandle],  Backup USING [],  Courier USING [Error, ErrorCode],  Environment USING [Block, bytesPerPage],  Heap USING [systemZone],  MsgOps USING [CourierErrToMsg, FilingErrToMsg],  NSAssignedTypes USING [tText, tDirectory],  NSFile,  NSFileName,  NSFileStream USING [Create, Handle],  NSString,  Space USING [ScratchMap, Unmap],  Stream USING [Block, CompletionCode, defaultInputOptions, EndOfStream, Handle, SetPosition, SubSequenceType],  System USING [GetGreenwichMeanTime],  XChar,  XString;BackupImpl: PROGRAM  IMPORTS Courier, Heap, MsgOps, NSFile, NSFileName, NSFileStream, NSString, Space, Stream, System, XChar, XString  EXPORTS Backup =  BEGIN       CmdProcType: TYPE = PROCEDURE [vpn: NSFileName.VPN];    zone: UNCOUNTED ZONE = Heap.systemZone;  File: PUBLIC PROCEDURE [   hostAndPath: NSString.String, -- destination   name: NSString.String,	 -- the rest of the file name   file: NSFile.Handle, session: NSFile.Session,   versionsToKeep: CARDINAL,   messageZone: UNCOUNTED ZONE,  -- for allocating message if success = FALSE   for: Auth.IdentityHandle]   RETURNS [success: BOOLEAN, message: NSString.String] =   BEGIN   storeAndDelver: CmdProcType = {     fH, dH: NSFile.Handle ¬ NSFile.nullHandle;     dirAttrs: ARRAY [0..2) OF NSFile.Attribute        ¬ [ [service[vpn.service]], [pathname[vpn.pathname]]];     a: ARRAY [0..1) OF NSFile.Attribute ¬ [[name[name]]];     date: ARRAY [0..1) OF NSFile.Attribute;     Cleanup: PROCEDURE = {CloseFile[dH, session]; CloseFile[fH, session]};     {ENABLE UNWIND => Cleanup[];     dH ¬ NSFile.Open[       directory: NSFile.nullHandle, attributes: DESCRIPTOR[dirAttrs],       session: session ! NSFile.Error => IF error=[access[fileNotFound]] THEN {         dH ¬ NSFile.nullHandle; CONTINUE}];     IF dH = NSFile.nullHandle THEN -- only try the dir. creation code if we have to     dH ¬ OpenDirectory[ -- closes directory;       directory: OpenRoot[vpn.service, session], session: session,       path: vpn.pathname, z: messageZone];     fH ¬ NSFile.Copy[       file: file, destination: dH,       attributes: DESCRIPTOR[a], session: session !         UNWIND => CloseFile[dH, session]];     date ¬ [[createdOn[Now[]]]];     NSFile.ChangeAttributes[       file: fH, attributes: DESCRIPTOR[date], session: session];     Delver[       session: session, directory: dH, fileName: name, keep: versionsToKeep];       Cleanup[];   }};   [success, message] ¬ CatchErrors[     hostAndPath: hostAndPath, user: for, proc: storeAndDelver, z: messageZone];   END;  RecoverFile: PUBLIC PROCEDURE [   hostAndPath: NSString.String, -- source   name: NSString.String,	 -- the rest of the file name (local and remote)   destination: NSFile.Handle,	 -- the directory to put it into   session: NSFile.Session,   messageZone: UNCOUNTED ZONE,	 -- for allocating message if success = FALSE   for: Auth.IdentityHandle]   RETURNS [success: BOOLEAN, message: NSString.String] =   BEGIN   recover: CmdProcType = {     file, fH, dH: NSFile.Handle ¬ NSFile.nullHandle;     dirAttrs: ARRAY [0..2) OF NSFile.Attribute        ¬ [ [service[vpn.service]], [pathname[vpn.pathname]]];     fileAttrs: ARRAY [0..1) OF NSFile.Attribute ¬ [[name[name]]];     dH ¬ NSFile.Open[attributes: DESCRIPTOR[dirAttrs], session: session];     file ¬ NSFile.Open[       attributes: DESCRIPTOR[fileAttrs], directory: dH, session: session];     fH ¬ NSFile.Copy[  -- bumps version       file: file, destination: destination,       attributes: DESCRIPTOR[fileAttrs], session: session !         UNWIND => CloseFile[dH, session]];   --NSFile.Delete[xxx]; delete old version     CloseFile[file, session];     CloseFile[fH, session];     CloseFile[dH, session];   };   [success, message] ¬ CatchErrors[     hostAndPath: hostAndPath, user: for, proc: recover, z: messageZone];   END;  AppendToFile: PUBLIC PROCEDURE [   hostAndPath: NSString.String, -- destination   name: NSString.String,	 -- the rest of the file name   startingAt: LONG CARDINAL,	 -- in the destination file   source: NSFileStream.Handle, session: NSFile.Session,   sourceBytes: LONG CARDINAL,   messageZone: UNCOUNTED ZONE, -- for allocating message if success = FALSE   for: Auth.IdentityHandle]   RETURNS [success: BOOLEAN, message: NSString.String] =   -- must leave position of stream at 'sourceBytes', especially if it fails;   -- FOR NOW just store a new file;     BEGIN   appendToFile: CmdProcType = {     bytes: LONG CARDINAL ¬ 0;     sourceFH, dirFH, tempFH: NSFile.Handle ¬ NSFile.nullHandle;     sH: NSFileStream.Handle ¬ [NIL];     attr: ARRAY [0..1) OF NSFile.Attribute ¬ [ [name[name]] ];     Cleanup: PROC = {       CloseFile[dirFH, session]; CloseFile[sourceFH, session]};     BEGIN ENABLE UNWIND => Cleanup[];     dirFH ¬ NSFile.OpenByName[       directory: NSFile.nullHandle, path: hostAndPath, session: session];     sourceFH ¬ NSFile.OpenByName[       directory: dirFH, path: name, session: session ! NSFile.Error =>	 IF error = [access[fileNotFound]] THEN {	   sourceFH ¬ NSFile.nullHandle; CONTINUE}];     IF sourceFH = NSFile.nullHandle THEN { -- must create it       attrs: ARRAY [0..2) OF NSFile.Attribute ¬ [         [name[name]], [type[NSAssignedTypes.tText]]];       sourceFH ¬ NSFile.Create[         directory: dirFH, attributes: DESCRIPTOR[attrs], session: session]};     tempFH ¬ NSFile.Copy[       file: sourceFH, destination: NSFile.nullHandle, session: session];     -- lengthInBytes ¬ GetFileSizeInBytes[tempFH, session];     sH ¬ NSFileStream.Create[file: tempFH, session: session, closeOnDelete: FALSE];     Stream.SetPosition[sH, sourceBytes];     IF (bytes ¬ CopyStream[from: source, to: sH]) = 0 THEN {       sH.delete[sH]; Cleanup[]; RETURN};     sH.delete[sH];     NSFile.Move[  -- to original destination       file: tempFH, destination: dirFH,       attributes: DESCRIPTOR[attr], session: session !         UNWIND => sH.delete[sH]];    Cleanup[];    END    };      [success, message] ¬ CatchErrors[     hostAndPath: hostAndPath, user: for, proc: appendToFile, z: messageZone];   END;     bufferPages: CARDINAL = 4;  bufferBytes: CARDINAL = bufferPages*Environment.bytesPerPage;    CopyStream: PROC [from, to: Stream.Handle]     RETURNS [bytes: LONG CARDINAL] = {    buffer: LONG POINTER ¬ Space.ScratchMap[bufferPages];    bytes _ 0;    DO      bytesTransferred: CARDINAL;      why: Stream.CompletionCode;      savedSST: Stream.SubSequenceType;      block: Stream.Block _ [buffer, 0, bufferBytes];      [bytesTransferred, why, savedSST] _ from.get[        from, block, Stream.defaultInputOptions !        Stream.EndOfStream => {          why _ endOfStream; bytesTransferred _ nextIndex; CONTINUE}];      block.stopIndexPlusOne _ bytesTransferred;      bytes _ bytes + bytesTransferred;      to.put[to, block, FALSE];      IF why = endOfStream THEN EXIT;      ENDLOOP;    buffer ¬ Space.Unmap[buffer]};        CatchErrors: PROCEDURE [    hostAndPath: NSString.String, user: Auth.IdentityHandle,    proc: CmdProcType, z: UNCOUNTED ZONE]    RETURNS [ok: BOOLEAN, message: NSString.String ¬ NSString.nullString] =    BEGIN    vpn: NSFileName.VPNRecord ¬ [service: NIL];    msg: NSString.String;    {    ENABLE {      NSFile.Error => {msg ¬ MsgOps.FilingErrToMsg[error].msg; GOTO failed};      Courier.Error => {        msg ¬ MsgOps.CourierErrToMsg[errorCode].msg; GOTO failed}};    NSFileName.VPNFieldsFromString[      z: z, s: hostAndPath, destination: @vpn !      NSFileName.Error => {        msg ¬ S["Invalid syntax"L];        GOTO failed}];    ok ¬ TRUE;    proc[@vpn];    NSFileName.FreeVPNFields[z: z, vpn: @vpn];    EXITS      failed => {	message ¬ NSString.CopyString[z: z, s: msg];	IF vpn.service # NIL THEN NSFileName.FreeVPNFields[z: z, vpn: @vpn];        ok ¬ FALSE};    }    END;      OpenFileSession: PROCEDURE [fileService: NSFile.Service, user: Auth.IdentityHandle]    RETURNS [session: NSFile.Session] = {    session ¬ NSFile.LogonDirect[      identity: user, service: fileService]};  CloseFileSession: PROCEDURE [session: NSFile.Session] = {	    NSFile.Logoff[session !      NSFile.Error, Courier.Error => CONTINUE]};      OpenRoot: PROCEDURE [fileService: NSFile.Service, session: NSFile.Session]    RETURNS [NSFile.Handle] = {    a: ARRAY [0..1) OF NSFile.Attribute ¬ [[service[fileService]]];    RETURN[NSFile.Open[      directory: NSFile.nullHandle, attributes: DESCRIPTOR[a], session: session]]};  OpenDirectory: PROCEDURE [    path: NSFile.String, directory: NSFile.Handle ¬ NSFile.nullHandle,    session: NSFile.Session ¬ NSFile.nullSession, controls: NSFile.Controls ¬ [],    z: UNCOUNTED ZONE] RETURNS [fh: NSFile.Handle ¬ NSFile.nullHandle] =    -- create directories that don't already exist;  this is gross using xstring's and nsstring's, but xstring provides some decent string operations.  closes directory passed in;    BEGIN    a: ARRAY [0..3) OF NSFile.Attribute;    dh: NSFile.Handle ¬ directory;    rootName: NSString.String ¬ NSString.nullString;    root: XString.WriterBody ¬ XString.NewWriterBody[NSFile.maxStringLength, z];    fileName: XString.ReaderBody ¬ XString.FromNSString[path];    CleanUp: PROCEDURE = {      XString.FreeWriterBytes[@root];      IF rootName # NSString.nullString THEN NSString.FreeString[z, rootName]};    {ENABLE UNWIND => CleanUp[];    WHILE ~XString.Empty[@fileName] DO -- existing dirs.      GetRoot[@fileName, @root];      rootName ¬ XString.NSStringFromReader[XString.ReaderFromWriter[@root], z];      a[0] ¬ [name[rootName]];      fh ¬ NSFile.Open[        directory: dh, attributes: DESCRIPTOR[BASE[a], 1], controls: controls,        session: session !        NSFile.Error =>         IF error=[access[fileNotFound]] THEN EXIT];      IF XString.Empty[@fileName] THEN GOTO return;      NSString.FreeString[z, rootName];      CloseFile[dh, session];      dh ¬ fh;      ENDLOOP;    DO -- non-existing dirs.      a ¬ [        [name[rootName]], [isDirectory[TRUE]], [type[NSAssignedTypes.tDirectory]]];      fh ¬ NSFile.Create[        directory: dh, attributes: DESCRIPTOR[a], session: session];      NSFile.Close[dh, session];      dh ¬ fh;      NSString.FreeString[z, rootName];      GetRoot[@fileName, @root];      rootName ¬ XString.NSStringFromReader[XString.ReaderFromWriter[@root], z];      IF XString.Empty[@fileName] THEN EXIT;      ENDLOOP;    CleanUp[];    EXITS      return => {        CleanUp[];	RETURN[fh]};    };    END;  -- OpenDirectory      nameVersionPairSeparator: XChar.Character =   XChar.Make[     NSFileName.nameVersionPairSeparator.chset,     NSFileName.nameVersionPairSeparator.code];  GetRoot: PROC [fileName: XString.Reader, root: XString.Writer] = {    XString.ClearWriter[root];    WHILE ~XString.Empty[fileName] DO      SELECT XString.First[fileName] FROM        nameVersionPairSeparator =>  EXIT;        ENDCASE => XString.AppendChar[root, XString.Lop[fileName]];      ENDLOOP;    IF XString.Empty[fileName] THEN RETURN;    [] ¬ XString.Lop[fileName]};  CloseFile: PROCEDURE [fH: NSFile.Handle, session: NSFile.Session] = {	    IF fH # NSFile.nullHandle THEN      NSFile.Close[fH, session !         Courier.Error, NSFile.Error => CONTINUE]};  Delver: PROC [    session: NSFile.Session, directory: NSFile.Handle,    fileName: NSString.String, keep: CARDINAL] =    BEGIN    cnt: CARDINAL ¬ 0;    nameAttribute: NSFile.Attribute ¬ [name [fileName]];    delVerProc: NSFile.AttributesProc = {      IF cnt >= keep THEN {	id: ARRAY [0..2) OF NSFile.Attribute ¬ [	  [fileID[attributes.fileID]], [service[attributes.service]] ];	fh: NSFile.Handle ¬ NSFile.Open[	  attributes: DESCRIPTOR[id], session: session];	NSFile.Delete[fh, session ! UNWIND => CloseFile[fh, session]]};      cnt ¬ cnt+1};    NSFile.List[      directory: directory, selections: [interpreted: [fileID: TRUE, service: TRUE]],      session: session, scope: [filter: [equal[nameAttribute]], direction: backward],      proc: delVerProc];    END;  Now: PROC RETURNS [NSFile.Time] = INLINE {RETURN[System.GetGreenwichMeanTime[]]};  S: PROC [s: LONG STRING] RETURNS [NSString.String] = INLINE {    RETURN[NSString.StringFromMesaString[s]]};  END.  -- of BackupImpl 
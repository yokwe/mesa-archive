-- File: AccessCHImpl.mesa - last edit:-- bjd                  3-Nov-87 18:18:30-- DJW  		 10-Jan-85 10:34:21-- Copyright (C) 1985, 1986, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  AccessCH USING [adobeServicePID, AuthLevelSupported, librarianServicePID, PID, PIDList, Problem, ProblemType],  Auth USING [CallError, CallProblem, ConversationHandle, IdentityHandle, Key, MakeStrongIdentityUsingKey, WhichArg],  CH USING [AddDistinguishedName, AddGroupMember, AddGroupProperty, AddValueProperty, Buffer, ConversationHandle, DeleteDistinguishedName, DeleteGroupMember, FreeConversationHandle, FreeRhs, LookupGroupProperty, MakeConversationHandle, Name, NameStreamProc, Properties, PropertyID, ReturnCode, SerializeIntoRhs],  CHEntries USING [DescribePrimary, PrimaryData],  CHPIDs USING [authenticationLevel, members, nsAddress, userData],  Courier USING [Parameters],  MsgOps USING [AuthCallErrToMsg, ChsErrToMsg],  NSAssignedTypes USING [AssignedType],  NSExec USING [ClientID, Error, Handle, nullHandle, PutErrorMessage, ServerIdentity, UserIdentity],  NSName USING [FreeName, Name],  NSString USING [nullString, String, StringFromMesaString],  SelfReg USING [nullProperties, RegisterCode, Register, UnRegister, UnRegisterCode],  ServicesAssignedTypes USING [firstLibrarianType, firstAdobeType];AccessCHImpl: PROGRAM   IMPORTS Auth, AccessCH, CH, CHEntries, MsgOps, NSExec, NSName, NSString, SelfReg   EXPORTS AccessCH = {  OPEN AccessCH;  -- Service stuff  -- Generic Property IDs ... these are type-independent properties   groupPID:      PID = CHPIDs.members;  netAddressPID: PID = CHPIDs.nsAddress;  authLevelPID:  PID = CHPIDs.authenticationLevel;    -- Secondary Property IDs ... these are type-dependent properties  dataPID: PID = CHPIDs.userData;  MesaServices: TYPE = {adobe, librarian, spare1, spare2};  stableData: ARRAY MesaServices OF NSAssignedTypes.AssignedType =    [ServicesAssignedTypes.firstLibrarianType,     ServicesAssignedTypes.firstAdobeType, 0, 0];  adobeGenericPIDsArray: ARRAY [0..3) OF PID ¬ [    netAddressPID, authLevelPID, groupPID];  adobeGenericPIDs: PUBLIC PIDList ¬ DESCRIPTOR[adobeGenericPIDsArray];    databaseGenericPIDsArray: ARRAY [0..1) OF PID ¬ [groupPID];  databaseGenericPIDs: PUBLIC PIDList ¬ DESCRIPTOR[databaseGenericPIDsArray];    librarianGenericPIDsArray: ARRAY [0..3) OF PID ¬ [    netAddressPID, authLevelPID, groupPID];  librarianGenericPIDs: PUBLIC PIDList ¬ DESCRIPTOR[librarianGenericPIDsArray];    Operation: TYPE = {    regSvc, unregSvc, regDB, unregDB, delDB, enum, null};      -- Clearinghouse entry stuff  CHStatusCode: TYPE = MACHINE DEPENDENT {    ok(0), noEntry, entryNotUsed, incompleteEntry, myEntry,    noCH, entryIsAlias, entryInUse, clientReject, other, null(31)};      Entry: TYPE = LONG POINTER TO EntryObject;  EntryObject: TYPE = RECORD [    -- service entry information    chStatus: CHStatusCode ¬ ok,    op: Operation ¬ null,    primary: CH.PropertyID ¬ LAST[LONG CARDINAL],    generics: CH.Properties ¬ SelfReg.nullProperties,    secondaries: CH.Properties ¬ SelfReg.nullProperties,    name: NSName.Name ¬ NIL,    desc: CHEntries.PrimaryData ¬ NSString.nullString,    identity: Auth.IdentityHandle ¬ NIL,    execHandle: NSExec.Handle ¬ NSExec.nullHandle,    conv: CH.ConversationHandle ¬ [NIL, NIL],    z: UNCOUNTED ZONE ¬ NIL    ];          RegisterService: PUBLIC PROC [    primaryPID: PID, genericPIDs: PIDList, secondaryPIDs: PIDList,    authLevel: AuthLevelSupported ¬ neither, execHandle: NSExec.Handle,    clientID: NSExec.ClientID, z: UNCOUNTED ZONE]    RETURNS [      name: NSName.Name, desc: NSString.String, key: Auth.Key,      identity: Auth.IdentityHandle] =    BEGIN    code: SelfReg.RegisterCode;    -- Do service registration, this sets authLevel to "both"    [code: code, name: name, desc: desc, key: key] ¬      SelfReg.Register[        primary: primaryPID, <<generics: genericPIDs,>> -- workaround        secondaries: secondaryPIDs,        stableType: stableData[MapPidToService[primaryPID]],	exec: execHandle, clientID: clientID,        operator: TRUE, asyncMessage: FALSE, z: z];    identity ¬ Auth.MakeStrongIdentityUsingKey[      myName: name, myKey: key, z: z !         Auth.CallError => {	  HandleAuthError[execHandle, reason, whichArg];	  ERROR Problem[authProblem]}];     HandleRegCode[code];    -- Install authLevel property if not "both"    -- This needs to get done!    -- The following code is a workaround, until SelfReg(Extra).(Special)Register bug gets fixed:  doesn't update entry with the generic properties.  AR ???      { -- begin workaround      convHandle: CH.ConversationHandle;      ok: BOOLEAN ¬ FALSE;      dName: CH.Name ¬ NIL;      identity: Auth.IdentityHandle ¬ GetIdentity[execHandle];      rc: CH.ReturnCode;      [conversation: convHandle, ok: ok] ¬ CH.MakeConversationHandle[identity];      IF ~ ok THEN ERROR Problem[authProblem];      rc ¬ CH.AddGroupProperty[	conversation: convHandle, pn: groupPID, name: name, distingName: dName];      CH.FreeConversationHandle[conversation: @convHandle];      IF (rc.code # done) AND (rc.code # noChange) THEN {        NSName.FreeName[z, name];	ERROR Problem[accessProblem]};      };  -- end workaround    END;   UnRegisterService: PUBLIC PROC [    primaryPID: PID, genericPIDs: PIDList, secondaryPIDs: PIDList,    execHandle: NSExec.Handle, clientID: NSExec.ClientID] = {    -- Do service unregistration    HandleUnRegCode[SelfReg.UnRegister[      primary: primaryPID, generics: genericPIDs, secondaries: secondaryPIDs,      stableType: stableData[MapPidToService[primaryPID]],      exec: execHandle, clientID: clientID,      asyncMessage: FALSE]]};          -- Database stuff  RegisterDatabase: PUBLIC PROC [    database: NSName.Name, service: NSName.Name, primaryPID: PID,    genericPIDs: PIDList, secondaryPIDs: PIDList,    desc: NSString.String ¬ NSString.nullString,     execHandle: NSExec.Handle, z: UNCOUNTED ZONE]    RETURNS [ok: BOOLEAN ¬ TRUE] =    BEGIN    entryRec: EntryObject ¬ [      z: z, name: database, desc: desc, op: regDB,      identity: GetIdentity[execHandle], execHandle: execHandle,      primary:  primaryPID, generics: genericPIDs, secondaries: secondaryPIDs];    rc: CH.ReturnCode;    authError: Auth.CallProblem;    FreeConv: PROC = {      CH.FreeConversationHandle[conversation: @entryRec.conv]};    -- Do database registration    [conversation: entryRec.conv, ok: ok, authCallError: authError] ¬       CH.MakeConversationHandle[entryRec.identity];    IF ~ ok THEN {HandleAuthError[entryRec.execHandle, authError]; RETURN[ok: FALSE]};    { ENABLE Problem => {FreeConv[]; GOTO failed};    UpdateCH[@entryRec];    -- Add service to database group    rc ¬ CH.AddGroupMember[conversation: entryRec.conv, element: service,      name: database, pn: groupPID, distingName: NIL];    HandleCHCode[@entryRec, rc];    -- Add database to service group    rc ¬ CH.AddGroupMember[conversation: entryRec.conv, element: database,      name: service, pn: groupPID, distingName: NIL];    HandleCHCode[@entryRec, rc];    CH.FreeConversationHandle[conversation: @entryRec.conv];    };    EXITS      failed =>  RETURN[ok: FALSE]    END;  UpdateCH: PROCEDURE [entry: Entry] =    BEGIN    AbortOperation: PROC = {--attempt to back out; if it fails, those are the breaks      [] ¬ CH.DeleteDistinguishedName[        conversation: entry.conv, name: entry.name, distingName: NIL]};    rc: CH.ReturnCode;    -- create a new entry    rc ¬ CH.AddDistinguishedName[      conversation: entry.conv, name: entry.name, distingName: NIL];    HandleCHCode[entry, rc];    {ENABLE UNWIND => AbortOperation[];     -- fill in its properties    AddDescription[entry];    AddGenerics[entry]; -- AddSecondaries[entry];  for now leave a no-op.    };    END;      AddGenerics: PROCEDURE [entry: Entry] =    BEGIN  -- for now just add the group property    rc: CH.ReturnCode ¬ CH.AddGroupProperty[      conversation: entry.conv, pn: groupPID, name: entry.name, distingName: NIL];    HandleCHCode[entry, rc];    END;      AddDescription: PROCEDURE [entry: Entry] =    -- Stores the description of a service under its entry in the Clearinghouse    BEGIN    rc: CH.ReturnCode;    descBuffer: CH.Buffer ¬ NIL;    descParms: Courier.Parameters       ¬ [location: @entry.desc, description: CHEntries.DescribePrimary];    BEGIN    ENABLE UNWIND =>        IF descBuffer # NIL THEN CH.FreeRhs[rhs: descBuffer, heap: entry.z];     descBuffer ¬ CH.SerializeIntoRhs[parms: descParms, heap: entry.z];    rc ¬ CH.AddValueProperty[      conversation: entry.conv, name: entry.name, pn: entry.primary,       rhs: descBuffer, distingName: NIL];    HandleCHCode[entry, rc];    END;    IF descBuffer # NIL THEN CH.FreeRhs[rhs: descBuffer, heap: entry.z];    END;    Quit: ERROR = CODE;  UnRegisterDatabase: PUBLIC PROC [database: NSName.Name,     service: NSName.Name, execHandle: NSExec.Handle, z: UNCOUNTED ZONE]    RETURNS [ok: BOOLEAN ¬ TRUE] = {    entryRec: EntryObject ¬ [      z: z, name: database, op: unregDB,      identity: GetIdentity[execHandle], execHandle: execHandle];    rc: CH.ReturnCode ¬ [done, first];    authError: Auth.CallProblem;    empty: BOOLEAN ¬ TRUE;    myProc: CH.NameStreamProc = {empty ¬ FALSE; ERROR Quit};    {      [conversation: entryRec.conv, ok: ok] ¬	 CH.MakeConversationHandle[entryRec.identity];      IF ~ ok THEN {	HandleAuthError[entryRec.execHandle, authError]; RETURN[ok: FALSE]};      rc ¬ CH.DeleteGroupMember[conversation: entryRec.conv, element: service,	name: database, pn: groupPID, distingName: NIL];      HandleCHCode[@entryRec, rc ! Problem => GOTO failed];      rc ¬ CH.DeleteGroupMember[conversation: entryRec.conv, element: database,	name: service, pn: groupPID, distingName: NIL];      HandleCHCode[@entryRec, rc ! Problem => GOTO failed];      rc ¬ CH.LookupGroupProperty[conversation: entryRec.conv, name: database,         pn: groupPID, eachElement: myProc, distingName: NIL ! Quit => CONTINUE];      HandleCHCode[@entryRec, rc ! Problem => GOTO failed];      IF empty THEN {          	rc ¬ CH.DeleteDistinguishedName[	  conversation: entryRec.conv, name: database, distingName: NIL];	HandleCHCode[@entryRec, rc ! Problem => GOTO failed]};      CH.FreeConversationHandle[conversation: @entryRec.conv];    EXITS      failed => {        CH.FreeConversationHandle[conversation: @entryRec.conv];	ok ¬ FALSE}}};  RemoveDatabaseFromService: PUBLIC PROC [database: NSName.Name,     service: NSName.Name, execHandle: NSExec.Handle, z: UNCOUNTED ZONE]    RETURNS [ok: BOOLEAN ¬ FALSE] = {    entryRec: EntryObject ¬ [      z: z, name: database, op: delDB,      identity: GetIdentity[execHandle], execHandle: execHandle];    rc: CH.ReturnCode;    authError: Auth.CallProblem;    FreeConv: PROC = INLINE {      CH.FreeConversationHandle[conversation: @entryRec.conv]};    BEGIN    [conversation: entryRec.conv, ok: ok] ¬       CH.MakeConversationHandle[entryRec.identity];    IF ~ ok THEN {      HandleAuthError[entryRec.execHandle, authError]; RETURN[ok: FALSE]};    rc ¬ CH.DeleteGroupMember[conversation: entryRec.conv, element: database,      name: service, pn: groupPID, distingName: NIL];    HandleCHCode[@entryRec, rc ! UNWIND => FreeConv[]];    CH.FreeConversationHandle[conversation: @entryRec.conv];    END};      GetIdentity: PROCEDURE [exec: NSExec.Handle]     RETURNS[identity: Auth.IdentityHandle] = {    -- identity is owned by the NSExec implementation; no need to free;    identity ¬ NSExec.ServerIdentity[];     identity ¬ NSExec.UserIdentity[exec !      NSExec.Error => IF type = noUser THEN CONTINUE]};  MapPidToService: PROCEDURE [pid: PID] RETURNS [ms: MesaServices ¬ spare2] =    INLINE {    SELECT pid FROM      adobeServicePID => ms ¬ adobe;      librarianServicePID => ms ¬ librarian;      ENDCASE => ERROR};      HandleRegCode: PROC [code: SelfReg.RegisterCode] = {    SELECT code FROM      entryCreated   => NULL;      entryExisted    => NULL;      noClearinghouse => ERROR Problem[noClearinghouse];      alreadyAlias    => ERROR Problem[alreadyAlias];      inUse           => ERROR Problem[inUse];      badServiceName  => ERROR Problem[badServiceName];      noOperator      => ERROR Problem[noOperator];      authProblem     => ERROR Problem[authProblem];      accessProblem   => ERROR Problem[accessProblem];      userAbort       => ERROR Problem[userAbort];      other           => ERROR Problem[other];      ENDCASE         => ERROR Problem[other]};  HandleUnRegCode: PROC [code: SelfReg.UnRegisterCode] = {    SELECT code FROM      entryDeleted    => NULL;      noClearinghouse => ERROR Problem[noClearinghouse];      alreadyAlias    => ERROR Problem[alreadyAlias];      inUse           => ERROR Problem[inUse];      badServiceName  => ERROR Problem[badServiceName];      noStableData    => ERROR Problem[noStableData];      noCHData        => ERROR Problem[noCHData];      authProblem     => ERROR Problem[authProblem];      accessProblem   => ERROR Problem[accessProblem];      userAbort       => ERROR Problem[userAbort];      other           => ERROR Problem[other];      ENDCASE         => ERROR Problem[other]};        HandleCHCode: PROC [entry: Entry, rc: CH.ReturnCode] = {  -- this proc should probably be split, one for posting, one for raising errors;    type: AccessCH.ProblemType;    IF entry = NIL THEN {IF rc.code = done THEN RETURN}    ELSE  -- called from server side;       SELECT entry.op FROM 	regSvc, unregSvc => NULL;	regDB, unregDB, delDB => {	  entry.chStatus ¬ SELECT rc.code FROM 	    done--, noChange-- => ok ENDCASE => null;	  IF entry.chStatus = ok THEN RETURN	  ELSE PostCHReturnCode[entry.execHandle, rc]};	ENDCASE;    type ¬ SELECT rc.code FROM      noChange => entryExisted,      rejectedTooBusy, allDown, wasUpNowDown => noClearinghouse,      IN [credentialsInvalid..credentialsTooWeak] => authProblem,      badProtocol, illegalPropertyID,      propertyIDNotFound, wrongPropertyType,      outOfDate, overflowOfName,      overflowOfDataBase		 => --clearinghouseProblem--noCHData,      IN [illegalOrgName..noSuchLocal]	 => badDatabaseName,      notAllowed			 => accessProblem,      ENDCASE => other;    ERROR Problem[type]};  HandleAuthError: PROC [    exec: NSExec.Handle, reason: Auth.CallProblem,    whichArg: Auth.WhichArg ¬ notApplicable] = {    msg: NSString.String ¬ MsgOps.AuthCallErrToMsg[reason, whichArg].msg;    NSExec.PutErrorMessage[exec, msg]};  PostCHReturnCode: PROC [exec: NSExec.Handle, rc: CH.ReturnCode] = {    -- this code change is to get some reasonable message for when the database is already registered without doing to much work;    IF rc.code = noChange THEN rc.code ¬ illegalLocalName;    NSExec.PutErrorMessage[exec, MsgOps.ChsErrToMsg[rc].msg]};  S: PROC [mS: LONG STRING] RETURNS [NSString.String] = INLINE     { RETURN[NSString.StringFromMesaString[mS]] };    }... end of AccessCH 
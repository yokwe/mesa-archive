-- File: AccessCH.doc - created by DJW. Last edit:-- djw                  6-May-85 18:47:00-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.USER'S MANUAL   The Adobe Service and the Librarian Service are examples of Distributed Services. A Distributed Service consists of many individual service instances (services). For example, Lamborghini:OSBU North:Xerox is a librarian service instance. Each service has one or more databases.  Services can replicate copies of a given database, that is, a database can be duplicated on several services.        Each service and each database should have a Clearinghouse entry. The entry for a service will consist of (among other things) a group of names of its databases. The entry for a database will consist of a group of names of the services that support the database.        This interface provides the registration and unregistration of services and databases, although it does not guarantee that the Clearinghouse will always have the correct data (that's up to the client).   -- An extended example-- Service self registration   Here is a "typical" example of AccessCH usage. Suppose that an Adobe service named Aardvark:OSBU North:Xerox, with databases X and Y wishes to register. Then Aardvark could use the following code, where handle and zone are Aardvark's local variables (the exec handle is often passed as a parameter to service procedures):  serviceName: NSName.Name;  desc: NSString.String;  id: Auth.IdentityHandle;  string: NSString.String  ¬ ... ;  [name: serviceName, desc: desc, identity: id] ¬ AccessCH.RegisterService[    primaryPID:    AccessCH.adobeServicePID,    genericPIDs:   AccessCH.adobeGenericPIDs,    secondaryPIDs: AccessCH.adobeSecondaryPIDs,    execHandle:    handle,    clientID:      clientID,    -- get this from NSExec.AssignClientID[]    z:             zone    ! AccessCH.Problems => {        string ¬ AccessCh.AppendProblem[problem: problem, s: string];	NSExec.PutIndentedMessage[exec: handle, string: string];        CROAK}];      NSString.FreeString[z: zone, s: desc];     The above call to AccessCH.RegisterService[] will create (if it does not already exist) a Clearinghouse entry with the properties found in the primaryPID, genericPIDs, and secondaryPIDs parameters, namely: (1) the primary property AccessCH.adobeServicePID, (2, 3, 4) three generic properties (net address, authentication level, and database group from AccessCH.adobeGenericPIDs), and no secondary properties (since AccessCH.adobeSecondaryPIDs is null). If the entry already exists, it will be checked to see that the desired properties are there.    In this example, Aardvark passed as the genericPIDs and secondaryPIDs parameters the predeclared ARRAYs AccessCH.adobeGenericPIDs and AccessCH.adobeSecondaryPIDs.  Aardvark could instead have declared its own ARRAYs of PID and then passed LONG DESCRIPTORs to them as parameters, for example:      myPIDs: ARRAY [0..1] of AccessCH.PID ¬     [AccessCH.mailboxesPID, AccessCH.groupPID];   .....      [...] ¬ AccessCH.RegisterService[... genericPIDs: LONG DESCRIPTOR[myPIDs] ...];        The predeclared PIDLists are here as a convenience for the expected customers of this interface.      The exec handle is used by RegisterService[] for printing messages to the user who is starting the service, and the clientID is used to identify the service that is requesting the registration. The zone is used to allocate the return parameters. Note that the authLevel parameter has been defaulted here to the value "neither".   RegisterService[] returns four parameters: (1) the name of the service as registered, (2) the string that describes the service in the Clearinghouse, and (3) the Authentication key and (4) IdentityHandle that are returned by the Authentication Service.  Space is allocated from zone for the name and desc return parameters and it is up to the user to deallocate them (use NSName.FreeName and NSString.FreeString, respectively).      RegisterService[] can raise AccessCH.Problem if it encounters errors.   -- Database registration   Aardvark will now attempt to register its databases X and Y. Suppose that XName and YName are NSName.Names for the databases, that is, XName represents "X:OSBU North:Xerox" and YName represents "Y:OSBU North:Xerox".      XName: NSName.Name ¬ ...     YName: NSName.Name ¬ ...      ......  RegisterDatabase [    database:      XName,    service:       serviceName,		-- "Aardvark:OSBU North: Xerox"    primaryPID:    AccessCH.adobeSystemPID,    genericPIDs:   AccessCH.databaseGenericPIDs,    secondaryPIDs: AccessCH.databaseSecondaryPIDs,    desc:	   NSString.StringFromMesaString["Hi! My name is X."L],    identity:      id];      Notice that in the above call, serviceName and id can be the return parameters from RegisterService[]. Of course, they can also be generated in some other way. RegisterDatabase will first see if an entry exists for this database already, and if not, will create one. The descriptive string will be installed as the value of the entry's primary property.     The properties that the new entry contains will be its primary id from the primaryPID parameter AccessCH.adobeSystemPID and a members group as a generic property from the genericPIDs parameter AccessCH.databaseGenericPIDs. Since AccessCH.databaseSecondaryPIDs is null, there will be no secondary properties.    Aardvark will repeat the call to RegisterDatabase[] for YName to register the second database. At this point, Aardvark is completely registered.    RegisterDatabase can raise the signal AccessCH.Problem.  -- Unregistering Services  If Aardvark is expunged as a service, then UnregisterService[] is called to wipe out Aardvark's Clearinghouse entry. The entire property list for Aardvark is deleted and its name is removed from the Clearinghouse. Here is how Aardvark would call UnregisterService[] to unregister itself:     UnregisterService [    primaryPID:    AccessCH.adobeServicePID,    genericPIDs:   AccessCH.adobeGenericPIDs,    secondaryPIDs: AccessCH.adobeSecondaryPIDs,    execHandle:    handle,    clientID:      clientID];      The user has to pass in the genericPIDs and secondaryPIDs because the UnRegister[] procedure in the Services SelfReg interface wants them for some reason.     Before calling UnregisterService[], the user will likely wish to call UnRegisterDatabase[] for each database in the service's database group. One easy way to do this is to use the EnumerateGroup[] proc (described below), where the user supplied enumProc in turn calls UnRegisterDatabase[]. Here is an example of such an enumProc:    MyEnumProc: CH.NameStreamProc = {	-- PROCEDURE [currentName: CH.Element]    UnRegisterDatabase[      database: currentName,      service: serviceName,		-- global variable        execHandle: handle,      z: zone      ! AccessCH.Problem => ... ]};        Then the calls:     EnumerateGroup[name: serviceName, enumProc: MyEnumProc, identity: id];  UnregisterService[ .. as above ];    will do the right thing.   -- Unregistering Databases    UnregisterDatabase[] is used when a service deletes its copy of the database.  For example, if Aardvark wishes to delete its copy of the X database, it can do so by     UnregisterDatabase[    database: XName,    service:  serviceName,  -- "Aardvark:OSBU North: Xerox"    execHandle: handle,    z: zone];      This will remove X from Aardvark's database group, and remove Aardvark from X's service group. If Aardvark was the last service in X's service group, then X is not supported by any service, so the Clearinghouse entry for X is deleted.  -- Enumerating Clearinghouse data   AccessCH provides answers to the following four questions:     (1) What services know about database X?     (2) What databases does some service S know about?     (3) What are all the services (of some particular kind) in a given domain?     (4) What are all the databases (of some particular kind) in a given domain?      Questions (1) and (2) are a lot alike and hence can use the same procedure EnumerateGroup[]. EnumerateGroup[] is called with a name, which can be the Clearinghouse name of either a service or a database. If it is a service name, then the enumProc is called for each database in the service's database group. If the name is a database, then the enumProc is called for each service in the database's service group.      For example, if Aardvark makes the call      EnumerateGroup[    name:     serviceName,   -- where serviceName is "Aardvark:OSBU North:Xerox"    enumProc: myEnumProc,    identity: id];      then myEnumProc is called twice, once with X's name and once with Y's name. If on the other hand, the call is made like    EnumerateGroup[    name:     XName,   -- where XName is "X:OSBU North:Xerox"    enumProc: myEnumProc,    identity: id];      then myEnumProc is called once with Aardvark's name.      Questions (3) and (4) are also quite alike and hence use the same procedure EnumerateEntriesWithinDomain[]. Here the pid parameter specifies the primary property ID of the objects to be enumerated, for example AccessCH.adobeServicePID. Then within the domain specified by the pattern parameter, the enumProc is called for each Clearinghouse entry with that primary property ID. This is a convenient way to list all librarian services or all adobe databases.  The pattern parameter is used in two ways: (1) the domain and organization are taken from it (hence no wildcards are allowed in the domain and organization fields) and (2) the enumProc is called only for those entries with the primary property ID AND a name that matches the Pattern. If the domain or organization fields are left empty, then they are filled in by extracting the domain and organization from the Auth.IdentityHandle parameter.  Suppose that Aardvark wishes to list all adobe databases in OSBU North. This is how the call might be made:    EnumerateEntriesWithinDomain[    pid:           AccessCH.adobeSystemPID,    domainPattern: "*:OSBU North:Xerox",    enumProc:      myEnumProc,    identity:      id];      Here myEnumProc would be called for every adobe system in OSBU North:Xerox. On the other hand, if Aardvark wishes to list the adobe services whose names start with the letter Z and are at least four characters long, then the call     EnumerateEntriesWithinDomain[    pid:           AccessCH.adobeServicePID,    domainPattern: "Z###*:OSBU North:Xerox",    enumProc:      myEnumProc,    identity:      id];      will match just those services. If the local field of the pattern is empty, then * is substituted automatically.              
-- File: ChatImpl.mesa - last edit:-- JAV                 28-Jul-87 12:55:09-- BGY     		15-Nov-84 14:45:12-- BJD    		 4-Oct-84 11:16:25-- DWR    		28-Jan-85 11:01:04-- Create by FormSWLayoutTool on 25-Jul-84 13:36-- Copyright (C) 1984, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  AddressTranslation,  Ascii,  CH,  CmFile,  Context,  Environment,  Exec,  Format,  FormSW,  GateStream,  Heap,  Process,  Put,  NetworkStream,  ChatOps,  Profile,  Selection,  Stream,  String,  System,  TextSW,  TextSource,  TIP,  Token,  Tool,  ToolWindow,  TTY,  TTYServiceTypes,  TTYSW,  UserInput,  UserTerminal,  Window;ChatImpl: MONITOR  IMPORTS    AddressTranslation, CmFile, Context, Exec, FormSW,     GateStream, Heap, ChatOps, Process, Profile, Put,     Selection, Stream, String, TextSW, TextSource, TIP, Token,    Tool, ToolWindow, TTY, TTYSW, UserInput, UserTerminal,    Window   EXPORTS ChatOps = {  OPEN ChatOps;    zone: UNCOUNTED ZONE ¬ Heap.systemZone;  waiter: CONDITION;  context: Context.Type ¬ Context.UniqueType[];  defaultHostType: LONG CARDINAL ¬ TTYServiceTypes.exec;  defaultLogin: BOOLEAN ¬ TRUE;  Write: PUBLIC PROC[data: DataHandle, s: LONG STRING] ={Put.Text[data.ttySW, s]};  Msg: PUBLIC PROC[data: DataHandle, s: LONG STRING] = {Put.Text[data.msgSW, s]};  tip: PUBLIC TIP.Table ¬ NIL;    StartChat: PROC[data: DataHandle] = {    session: GateStream.SessionParameterObject ¬ [      ttyHost[charLength: 7, parity: even, stopBits:2, frameTimeout:100]];    transport: ARRAY[0..2) OF GateStream.TransportObject ¬ [      [service[id: data.realHostType]], [teletype[]]];    data.host ¬ Selection.Convert[string];    IF data.host = NIL THEN {      Flash[];      Write[data, "No host selected\n"L];      RETURN};    Msg[data, data.host]; Msg[data, "..."L];    data.service ¬ AddressTranslation.StringToNetworkAddress[data.host].addr;    data.stream ¬ GateStream.Create[      service: data.service, sessionParameterHandle: @session,       transportList: DESCRIPTOR[transport]!        GateStream.Error => {data.GateError[reason]; GOTO quit}];    data.stream.SetInputOptions[      [terminateOnEndRecord: TRUE, signalEndOfStream: TRUE]];    [] ¬ data.tty.SetEcho[none];    data.aborting ¬ FALSE;    data.watcherProcess ¬ FORK AwaitControl[data];    data.putDataProcess ¬ FORK PutChars[data];    data.getDataProcess ¬ FORK GetChars[data];    Msg[data, "opened"L];    IF data.realLogin THEN Login[data];    EXITS quit => NULL;    };    Login: PROC[data: DataHandle] = {    ok: BOOLEAN ¬ FALSE;    Test: PROC[name: LONG STRING, password: LONG STRING] = {      ok ¬ String.Length[password] > 0};    StuffUser: PROC[name: LONG STRING, password: LONG STRING] = {      [] ¬ UserInput.StuffString[data.ttySW, name];      [] ¬ UserInput.StuffString[data.ttySW, "\n"L];      [] ¬ UserInput.StuffString[data.ttySW, password];      [] ¬ UserInput.StuffString[data.ttySW, "\n"L];      };    Profile.GetUser[Test];    IF ~ok THEN RETURN;    [] ¬ UserInput.StuffString[data.ttySW, "Log\n"L];    Profile.GetUser[StuffUser, clearinghouse];        BEGIN    userCm: CmFile.Handle ¬ CmFile.UserDotCmOpen[! CmFile.Error => GOTO fail];    IF CmFile.FindItem[userCm, "Chat", data.host]    THEN {      message: LONG STRING ¬         Token.MaybeQuoted[userCm, NIL, Token.NonWhiteSpace, Token.Quote];      [] ¬ UserInput.StuffString[data.ttySW, message];      message ¬ Token.FreeTokenString[message]};    userCm ¬ CmFile.Close[userCm];    EXITS fail => NULL;    END    };    FindContext: PROC[sw: Window.Handle] RETURNS [data: DataHandle] = INLINE {    RETURN[Context.Find[      context, ToolWindow.WindowForSubwindow[sw]]]};    Connect:  FormSW.ProcType = {    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    IF data.stream # NIL THEN {      Msg[data, "Connection already opened.\n"L];      Flash[];      RETURN};    IF data.localMode # NIL THEN Process.Abort[data.localMode];    WHILE data.localMode # NIL DO Pause[]  ENDLOOP;    Msg[data, "Opening connection to "L];    Umbrella[StartChat, data];    Msg[data, "\n"L];    -- check to see if connection was successful.    IF data.putDataProcess = NIL AND data.localMode = NIL THEN LocalMode[data];    };  Disconnect:  FormSW.ProcType = {    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    IF data.stream = NIL THEN {      Msg[data, "No connection opened.\n"L];      Flash[];      RETURN};    data.aborting ¬ TRUE;    Process.Abort[data.watcherProcess];    JOIN data.watcherProcess;    data.watcherProcess ¬ NIL;    Msg[data, "\n"L];    };  Another:  FormSW.ProcType = {    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    [] ¬ MakeOne[data.realHostType, data.realLogin];    };  MyDestroy:  ENTRY FormSW.ProcType = {    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    Process.Detach[FORK Destroyer[data, sw]];    };  Destroyer: ENTRY PROC[data: DataHandle, sw: Window.Handle] = {    Tool.Destroy[ToolWindow.WindowForSubwindow[sw]]};    Pause: ENTRY PROC = {ENABLE UNWIND => NULL; WAIT waiter};    BreakKey:  FormSW.ProcType = {    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    AbortHit[data.ttySW]};  GetData: SIGNAL RETURNS [DataHandle] = CODE;    MyOptions:  FormSW.ProcType = {    data: DataHandle ¬ FindContext[sw];    myBox: Window.Box;    IF data = NIL THEN RETURN;    IF data.optionW # NIL THEN {      Flash[];      Msg[data, "Option sheet already exists!\n"L];      RETURN};    myBox ¬ [ToolWindow.WindowForSubwindow[sw].GetBox[].place, [300, 50]];    myBox.place.x ¬ myBox.place.x + 50;    myBox.place.y ¬ myBox.place.y + 50;    data.logIn ¬ data.realLogin;    data.hostType ¬ data.realHostType;    data.optionW ¬ Tool.Create[      makeSWsProc: MakeOptSWs, initialState: default, initialBox: myBox,      name: "Chat Options"L, cmSection: "ChatOptions"L,      clientTransition: Transition!        GetData => RESUME[data]]};  Transition: ToolWindow.TransitionProcType = {    data: DataHandle ¬ Context.Find[context, window];    SELECT TRUE FROM      old = inactive => IF data = NIL THEN {        data ¬ SIGNAL GetData[];        Context.Create[context, data, NullDestroy, window]};      new = inactive => NULL;      ENDCASE;    };    MakeOptSWs: Tool.MakeSWsProc = {    data: DataHandle ¬ Context.Find[context, window];    IF data = NIL THEN RETURN;    data.optformSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeOption];    };  Apply:  ENTRY FormSW.ProcType = {    data: DataHandle ¬ FindContext[sw];    name: LONG STRING ¬ [100];    IF data = NIL THEN RETURN;    data.realLogin ¬ data.logIn;    IF data.realHostType # data.hostType THEN {      ChangeName[data.hostType, name];      ToolWindow.SetName[ToolWindow.WindowForSubwindow[data.formSW], name];      };    data.realHostType ¬ data.hostType;    Process.Detach[FORK Destroyer[data, sw]];    };  Abort:  ENTRY FormSW.ProcType = {    data: DataHandle ¬ FindContext[sw];    IF data = NIL THEN RETURN;    Process.Detach[FORK Destroyer[data, sw]];    };  OptionItems: TYPE = {apply, abort, logIn, hostType};  MakeOption: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = OptionItems.LAST.ORD + 1;    hostType: ARRAY[0..4) OF Enumerated ¬ [      ["any"L, 0], ["sa"L, 1],      ["exec"L, 2], ["its"L, 3]];    data: DataHandle ¬ FindContext[sw];    items ¬ AllocateItemDescriptor[nItems];    items[OptionItems.apply.ORD] ¬ CommandItem[      tag: "Apply"L, place: [0, line0], proc: Apply];    items[OptionItems.abort.ORD] ¬ CommandItem[      tag: "Abort"L, place: [50, line0], proc: Abort];    items[OptionItems.logIn.ORD] ¬ BooleanItem[      tag: "LogIn"L, place: [100, line0], switch: @data.logIn];    items[OptionItems.hostType.ORD] ¬ EnumeratedItem[      tag: "HostType"L, place: [156, line0], choices: DESCRIPTOR[hostType], value: @data.hostType];    RETURN[items: items, freeDesc: TRUE];    };  Umbrella:  PROC[proc: PROC[data: DataHandle], data: DataHandle] = {    LocalMsg: Format.StringProc = {Msg[data, s]};    BEGIN ENABLE {      AddressTranslation.Error => {	AddressTranslation.PrintError[error: errorRecord, proc: LocalMsg];	GOTO nope};      };    proc[data];    EXITS nope => NULL;    END;    };      AbortHit: UserInput.AttentionProcType = {    data: DataHandle ¬ FindContext[window];    IF data = NIL THEN RETURN;    IF data.stream = NIL THEN RETURN;    data.stream.SendAttention[GateStream.interrupt];    };    AwaitControl: PROC[data: DataHandle] =    -- Process to wait for generic controls    BEGIN    control: Stream.Byte;    -- this with return a control when attention data is implemented    -- for now, it just means interrupt (BELL)    DO ENABLE {ABORTED => EXIT; Stream.EndOfStream => GOTO remotequit};      IF data.stream = NIL THEN GOTO remotequit      ELSE control ¬ Stream.WaitForAttention[data.stream];      SELECT control FROM        GateStream.audibleSignal =>Flash[];        GateStream.interrupt => Msg[data, " Break received\n"L];        GateStream.mediumDown => GOTO remotequit;        ENDCASE;      ENDLOOP;    IF ~data.aborting THEN Process.Detach[FORK JoinMe[data]];    Msg[data, "Closing connection to "L];    Msg[data, data.host];    Cleanup[data];    zone.FREE[@data.host];    Msg[data, " ... done\n"L];    Write[data, "\n~~~~~~~~ Connection closed ~~~~~~~~\n"L];    LocalMode[data];    EXITS remotequit => {      Msg[data, " Connection closed by remote host\n"L];      Flash[];      Process.Detach[FORK Disconnect[data.formSW]]};    END;  JoinMe: PROC[data: DataHandle] = {    ENABLE UNWIND => NULL;    JOIN data.watcherProcess;    data.watcherProcess ¬ NIL;    };    GetChars: PROC[data: DataHandle] = {    s: LONG STRING ¬ [128];    i, j, bytes: CARDINAL;    why: Stream.CompletionCode;    sst: Stream.SubSequenceType;    BEGIN    DO ENABLE {      ABORTED => EXIT;      Stream.EndOfStream => {Msg[data, "Get: EOS\n"L]; GOTO exit};      Stream.SSTChange => {IF sst # GateStream.none THEN         data.PrintSST[sst]; RESUME};      };      [bytes, why, sst] ¬ data.stream.GetBlock[        [LOOPHOLE[@s.text], 0, s.maxlength]!	  Stream.TimeOut => {bytes ¬ nextIndex; CONTINUE}];      s.length ¬ bytes;      IF why = sstChange AND sst # GateStream.none THEN data.PrintSST[sst];      IF s.length = 0 THEN LOOP;      j ¬ 0;      FOR i IN [0..s.length) DO 	SELECT  s[i] FROM	  Ascii.NUL, Ascii.LF => NULL;	  Ascii.BS => {	    IF j > 0 THEN {s.length ¬ j; data.tty.PutString[s]; s.length ¬ j ¬ 0};	    data.tty.RemoveCharacter[]};	  ENDCASE => {s[j] ¬ s[i]; j ¬ j + 1};        ENDLOOP;      IF j > 0 THEN {s.length ¬ j; data.tty.PutString[s]};      ENDLOOP    EXITS exit => NULL;    END;    };      PutChars: PROC[data: DataHandle] = {    chs: PACKED ARRAY [0..2) OF Environment.Byte;    ch: CHARACTER;    BEGIN    data.stream.SetSST[GateStream.none];    DO ENABLE {      ABORTED => EXIT;      Stream.EndOfStream => {Msg[data, "Put: EOS\n"L]; GOTO exit};      Stream.SSTChange => {IF sst # GateStream.none THEN         data.PrintSST[sst]; RESUME};      Stream.TimeOut => {Msg[data, "Stream timeout\n"L]; CONTINUE};      };      ch ¬ data.tty.GetChar[];      chs[1] ¬ LOOPHOLE[ch];      data.stream.PutBlock[[@chs, 1, 2], TRUE];      ENDLOOP    EXITS exit => NULL;    END;    };    Cleanup: PROC[data: DataHandle] =    -- perform cleanup    BEGIN    Process.Abort[data.getDataProcess];    Process.Abort[data.putDataProcess];    JOIN data.putDataProcess;    JOIN data.getDataProcess;    data.putDataProcess ¬ NIL;    data.getDataProcess ¬ NIL;    data.stream.Delete[];    data.stream ¬ NIL;    END;    Echo: PROC[data: DataHandle] = {    s: LONG STRING ¬ [128];    source: TextSource.Handle = TextSW.GetSource[data.ttySW];    right: TextSource.Position;    left: TextSource.Position;    GetChar: PROC[c: CHARACTER] RETURNS[status: TTY.CharStatus] = {      SELECT c FROM        '\200 => status ¬ stop;	ENDCASE => status ¬ ok;      };    BEGIN ENABLE ABORTED => GOTO quit;    s.length ¬ 0;    [] ¬ data.tty.SetEcho[plain];    WHILE data.tty.GetEditedString[s, GetChar!        TTY.LineOverflow => {s.length ¬ 0; RESUME};	TTY.Rubout => {Write[data, " XXX\n"L]; RESUME}] # '\200 DO      s.length ¬ 0;      ENDLOOP;    TextSW.ForceOutput[data.ttySW];    right ¬ TextSW.GetInsertion[data.ttySW];    left ¬ TextSource.AsciiScanText[source, right - 1, line, left];    Put.CR[data.ttySW];    TextSW.SetSelection[data.ttySW, left, right];    data.localMode ¬ NIL;    Connect[data.formSW];    EXITS quit => data.localMode ¬ NIL;    END;    NotifyQuit[];    };  NotifyQuit: ENTRY PROC = {BROADCAST waiter};  ClientTransition: ToolWindow.TransitionProcType = {    data: DataHandle ¬ Context.Find[context, window];    SELECT TRUE FROM      old = inactive =>        IF data = NIL THEN {	  data ¬ zone.NEW[Data ¬ []];	  Context.Create[context, data, DestroyContext, window];	  };      new = inactive => IF data # NIL THEN {         IF data.stream # NIL THEN Disconnect[data.formSW];	IF data.optionW # NIL THEN Tool.Destroy[data.optionW];	};      ENDCASE;    };  NullDestroy: PROC[data: DataHandle, window: Window.Handle] = {    data.optionW ¬ NIL;    data.optformSW ¬ NIL};      DestroyContext: PROC[data: DataHandle, window: Window.Handle] = {    IF data.stream # NIL THEN {Disconnect[data.formSW]};    zone.FREE[@data];    };    MakeOne: PROC[hostType: LONG CARDINAL, login: BOOLEAN ¬ TRUE]     RETURNS [window: Window.Handle] = {    name: LONG STRING ¬ [100];    data: DataHandle ¬ NIL;    ChangeName[hostType, name];    window ¬ Tool.Create[      makeSWsProc: MakeSWs, initialState: default,      clientTransition: ClientTransition, name: name,      cmSection: "Chat"L];    data ¬ Context.Find[context, window];    IF data # NIL THEN {      data.realHostType ¬ hostType;      data.realLogin ¬ login};    };  ChangeName: PROC[hostType: LONG CARDINAL, s: LONG STRING] = {    s.length ¬ 0;    String.AppendString[s, "Chat: "L];    String.AppendString[s, SELECT hostType FROM      TTYServiceTypes.sa => "Remote System Administration"L,      TTYServiceTypes.exec => "Remote Executive"L,      TTYServiceTypes.its => "Remote Interactive Terminal Service"L,      ENDCASE => "Unimplemented Transport"L];    };    LocalMode: PROC[data: DataHandle] = {    IF data.localMode # NIL THEN RETURN;    Process.Detach[data.localMode ¬ FORK Echo[data]];    };    MakeSWs: Tool.MakeSWsProc = {    data: DataHandle ¬ Context.Find[context, window];    logName: LONG STRING ¬ [40];    Tool.UnusedLogName[unused: logName, root: "Chat.log"L];    data.msgSW ¬ Tool.MakeMsgSW[window: window];    data.formSW ¬ Tool.MakeFormSW[      window: window, formProc: MakeForm];    data.ttySW ¬ Tool.MakeTTYSW[window: window, name: logName];    data.tty ¬ TTYSW.GetTTYHandle[data.ttySW];    UserInput.SetAttention[data.ttySW, AbortHit];    IF tip # NIL THEN [] ¬ TIP.SetTable[data.ttySW, tip];    LocalMode[data];    };  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = FormItems.LAST.ORD + 1;    data: DataHandle ¬ FindContext[sw];    items ¬ AllocateItemDescriptor[nItems];    items[FormItems.connect.ORD] ¬ CommandItem[      tag: "Connect"L, place: [0, line0], proc: Connect];    items[FormItems.disconnect.ORD] ¬ CommandItem[      tag: "Disconnect"L, place: [72, line0], proc: Disconnect];    items[FormItems.breakKey.ORD] ¬ CommandItem[      tag: "BreakKey"L, place: [162, line0], proc: BreakKey];    items[FormItems.another.ORD] ¬ CommandItem[      tag: "Another"L, place: [240, line0], proc: Another];    items[FormItems.destroy.ORD] ¬ CommandItem[      tag: "Destroy"L, place: [312, line0], proc: MyDestroy];    items[FormItems.options.ORD] ¬ CommandItem[      tag: "Options"L, place: [384, line0], proc: MyOptions];    RETURN[items: items, freeDesc: TRUE];    };  Init: PROC = {    firstTime: BOOLEAN ¬ TRUE;    fileName: STRING = "Chat.TIP"L;    log, host: LONG STRING ¬ NIL;    contents: LONG STRING ="-- Chat.TIP; of 27-Jul-84 12:15:07-- Created by System  SELECT TRIGGER FROM  DOIT Down => \"\\200\";  ENDCASE..."L;    tip ¬ TIP.CreateTable[file: fileName, contents: contents !      TIP.InvalidTable =>        IF type = badSyntax THEN {          IF firstTime THEN {firstTime ¬ FALSE; Flash[]; RESUME}	  ELSE CONTINUE}];    IF tip  # NIL THEN      [] ¬ TIP.PushLocal[push: tip , onto: TIP.globalTable[ttySW]];    Process.SetTimeout[@waiter, Process.MsecToTicks[50]];    Process.EnableAborts[@waiter];    Exec.AddCommand["Chat.~"L, Main];    log ¬ CmFile.UserDotCmLine["Chat"L, "LogIn"L];    host ¬ CmFile.UserDotCmLine["Chat"L, "HostType"L];    defaultLogin ¬ IF String.Equivalent[log, "TRUE"L] THEN TRUE ELSE FALSE;    defaultHostType ¬ SELECT TRUE FROM      String.Equivalent[host, "any"L] => TTYServiceTypes.any,      String.Equivalent[host, "sa"L] => TTYServiceTypes.sa,      String.Equivalent[host, "exec"L] => TTYServiceTypes.exec,      String.Equivalent[host, "its"L] => TTYServiceTypes.its,      ENDCASE => TTYServiceTypes.exec;    IF log # NIL THEN log ¬ CmFile.FreeString[log];    IF host # NIL THEN host ¬ CmFile.FreeString[host];    };  Main: Exec.ExecProc = {    hostType: LONG CARDINAL ¬ defaultHostType;    window: Window.Handle ¬ NIL;    data: DataHandle ¬ NIL;    switch, name: LONG STRING ¬ NIL;    [name, switch] ¬ h.GetToken[];    IF switch # NIL THEN hostType ¬ SELECT switch[0] FROM      'a => TTYServiceTypes.any,      's => TTYServiceTypes.sa,      'e => TTYServiceTypes.exec,      'i => TTYServiceTypes.its,      ENDCASE => TTYServiceTypes.exec;    window ¬ MakeOne[hostType, defaultLogin];    data ¬ Context.Find[context, window];    IF name # NIL THEN {      String.AppendString[name, "\200"L];      [] ¬ UserInput.StuffString[data.ttySW, name];      };    IF name # NIL THEN name ¬ Exec.FreeTokenString[name];    IF switch # NIL THEN switch ¬ Exec.FreeTokenString[switch];    };    Flash: PUBLIC PROCEDURE =    BEGIN    ENABLE ABORTED => CONTINUE;    UserTerminal.BlinkDisplay[];    UserTerminal.Beep[262, 75];  -- c    UserTerminal.Beep[392, 75];  -- g    UserTerminal.Beep[659, 75];  -- e    END;  -- Mainline code  Init[];  -- this gets string out of global frame  }...    
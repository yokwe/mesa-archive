-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- CompareControl.mesa-- Last edited by:-- RXR                          3-Mar-82 11:27:36-- BTL                         13-May-82 14:43:42-- TXS                         22-Feb-83 13:49:50-- RSF      		        3-Aug-84 11:00:26-- DWR    	14-Jan-85 14:03:28DIRECTORY  CompareDefs,  Exec,  FileName,  FileTransfer,  FileTransferOps,  Format,  Heap,  MFile,  MStream,  Put,  Stream,  String;CompareControl: PROGRAM  IMPORTS     CompareDefs, Exec, FileName, FileTransfer, Format, Heap,     MFile, MStream, Put, Stream, String  EXPORTS CompareDefs =  BEGIN OPEN def: CompareDefs;    WordType: TYPE = RECORD [seq: SEQUENCE l:CARDINAL OF WORD];  s1, s2: PUBLIC Stream.Handle ¬ NIL;  diffFileName: PUBLIC LONG STRING ¬ NIL;  c1, c2: FileTransfer.Connection ¬ NIL;  vfn1, vfn2: FileName.VirtualFilename ¬ NIL;      DoComparison: PUBLIC PROC[Output: Format.StringProc, dataHandle: LONG POINTER TO def.DataHandle, myZone: LONG POINTER TO UNCOUNTED ZONE] = {    ENABLE {UNWIND  => Done[dataHandle, myZone];            ABORTED => {Output["Compare ABORTED."L]; Format.CR[Output];	    	        GOTO cleanUp}};    Init[];    DO      ENABLE       -- The following signals should only be raised when Compare is running      -- in the Executive window.        {MissingF2 => {Output["Missing second file name."L]; Format.CR[Output];	               GOTO cleanUp};	GlobalSwitchError => {Output["Error in specification of global switches."L]; 	               Format.CR[Output]; GOTO cleanUp}};      -- Check that file names are given for File1 and File2 in tool      IF ~def.inExec THEN {        IF dataHandle.file1 = NIL OR dataHandle.file1.length = 0 THEN	  {Output["No File 1 specified"L]; Done[dataHandle, myZone];	  EXIT};	IF dataHandle.file2 = NIL OR dataHandle.file2.length = 0 THEN	  {Output["No File 2 specified"L]; Done[dataHandle, myZone];	  EXIT}};      -- Check for more tokens on the command line.      IF def.inExec AND ~ReadCommandLine[dataHandle­] THEN {Done[dataHandle, myZone]; EXIT};            [vfn1] ¬ FileName.AllocVFN[dataHandle.file1 ! FileName.Error =>        {Output["File 1 is an invalid file name."L]; GOTO cleanUp}];      [vfn2] ¬ FileName.AllocVFN[dataHandle.file2 ! FileName.Error =>        {Output["File 2 is an invalid file name."L]; GOTO cleanUp}];	      -- ReadStream opens a stream on a file, either local or remote.  NIL is      -- returned if a match is not found.      s1 ¬ ReadStream[conn: c1, files: vfn1, type: temporary, long: dataHandle.file1        ! FileTransfer.Error => {	IF def.CheckAbort[] THEN GOTO abortMyself;	SELECT code FROM	  retry  =>	    {Output["FileTranser error: Connection not made. Retrying..."L];	     RETRY};	  notFound =>	    Output["File 1 not found."L];	ENDCASE;	GOTO cleanUp}];      IF s1 = NIL THEN {Output[dataHandle.file1];         Output[" not accessible."L]; GOTO cleanUp};      --there should eventually be a better way of determining this.      IF LOOPHOLE[s1, FileTransferOps.FTHandle].stream = NIL THEN        {Output[	  "FileTransfer error: File is protected - access denied."L];	 GOTO cleanUp};	      s2 ¬ ReadStream[conn: c2, files: vfn2, type: temporary, long: dataHandle.file2         ! FileTransfer.Error => {	IF def.CheckAbort[] THEN GOTO abortMyself;	SELECT code FROM	  retry  =>	    {Output["FileTransfer error: Connection not made. Retrying..."L];	     RETRY};	  notFound =>	    Output["File 2 not found."L];	ENDCASE;	GOTO cleanUp}];      IF s2 = NIL THEN {Output[dataHandle.file2];         Output[" not accessible."L]; GOTO cleanUp};      --there should eventually be a better way of determining this.      IF LOOPHOLE[s2, FileTransferOps.FTHandle].stream = NIL THEN        {Output[	  "FileTransfer error: File is protected - access denied."L];	 GOTO cleanUp};      IF ~def.inExec THEN {        Put.Text[dataHandle.fileSW, dataHandle.file1];         Put.Text[dataHandle.fileSW, ", "L];         Put.Line[dataHandle.fileSW, dataHandle.file2];         Put.CR[dataHandle.fileSW]}      ELSE {Output[dataHandle.file1]; Output[", "L]; Output[dataHandle.file2];        Format.CR[Exec.OutputProc[def.exec]]};      IF def.inExec THEN MakeDiffFileName[myZone­];      def.CompareFiles[Output, dataHandle­, myZone­];            -- Free storage used by previous pair of files read from the command line. --      IF def.inExec THEN        {dataHandle.file1 ¬ Exec.FreeTokenString[dataHandle.file1];         dataHandle.file2 ¬ Exec.FreeTokenString[dataHandle.file2];         myZone.FREE[@diffFileName]};      Stream.Delete[s1]; s1 ¬ NIL;      Stream.Delete[s2]; s2 ¬ NIL;       FileName.FreeVFN[vfn1]; vfn1 ¬ NIL;      FileName.FreeVFN[vfn2]; vfn2 ¬ NIL;    IF ~def.inExec THEN GOTO cleanUp;    ENDLOOP;      EXITS      abortMyself => {Done[dataHandle, myZone]; Output["Aborted by user."L]};      cleanUp     => {Done[dataHandle, myZone]};    };  -- End DoComparison. --        Init: PROC =     {c1 ¬ FileTransfer.Create[];  c2 ¬ FileTransfer.Create[];    -- Create makes a new ConnecitonObject. --     MakeConnection[c1];  MakeConnection[c2]};          Done: PROC[    dataHandle: LONG POINTER TO def.DataHandle,     myZone: LONG POINTER TO UNCOUNTED ZONE] = {    IF def.inExec THEN {      IF diffFileName # NIL AND myZone­ # NIL THEN myZone.FREE[@diffFileName];      IF dataHandle.file1 # NIL THEN         dataHandle.file1 ¬ Exec.FreeTokenString[dataHandle.file1];      IF dataHandle.file2 # NIL THEN         dataHandle.file2 ¬ Exec.FreeTokenString[dataHandle.file2];      IF myZone­ # NIL THEN myZone.FREE[dataHandle];      def.inExec ¬ FALSE;      def.exec ¬ NIL};    IF s1 # NIL THEN {Stream.Delete[s1]; s1 ¬ NIL};    IF s2 # NIL THEN {Stream.Delete[s2]; s2 ¬ NIL};    DestroyConn[@c1, @vfn1];  DestroyConn[@c2, @vfn2];    IF myZone­ # NIL THEN Heap.Delete[z: myZone­, checkEmpty: FALSE];    myZone­ ¬ NIL;    def.Unlock[];    IF ~def.inExec AND dataHandle­ # NIL THEN      Put.Line[dataHandle.msgSW, " Done."L]};         ReadStream: PROCEDURE [    conn: FileTransfer.Connection, files: FileName.VFN,     veto: FileTransfer.VetoProc ¬ NIL, showDates: BOOLEAN ¬ FALSE,     type: FileTransfer.StreamType ¬ remote, long: LONG STRING]     RETURNS [Stream.Handle] = {    mstream: Stream.Handle ¬ NIL;    IF String.Length[files.host] = 0 THEN       mstream ¬ MStream.ReadOnly[long, []!MStream.Error => CONTINUE]    ELSE {      temp: Stream.Handle ¬ NIL;      info: FileTransfer.FileInfo;      mfile: MFile.Handle ¬ NIL;      temp ¬ FileTransfer.ReadStream[conn: conn, files: files, type: remote];      info ¬ FileTransfer.GetStreamInfo[temp];      mfile ¬ MFile.AcquireTemp[text, info.size];      mstream ¬ MStream.Create[mfile, []];      Stream.SetPosition[mstream, 0];      [] ¬ MStream.Copy[from: temp, to: mstream, bytes: info.size];      Stream.Delete[temp];      Stream.SetPosition[mstream, 0];      };    RETURN[mstream];    };    MakeDiffFileName: PROC[myZone: UNCOUNTED ZONE] = {    nDollarSigns: CARDINAL ¬ 0;    extensionPresent: BOOLEAN ¬ FALSE;    i: CARDINAL;    diffFileName ¬ String.MakeString[myZone, 20];    String.AppendStringAndGrow[@diffFileName,vfn1.name, myZone, 10];        FOR i DECREASING IN [0..diffFileName.length) DO      IF diffFileName[i] # '$ THEN EXIT      ELSE nDollarSigns ¬ nDollarSigns + 1;      ENDLOOP;    FOR i IN [0..diffFileName.length) DO      IF diffFileName[i] = '. THEN {        diffFileName.length ¬ i;  extensionPresent ¬ TRUE;  EXIT};      ENDLOOP;    IF (nDollarSigns > 0) AND extensionPresent THEN  --append $ before .dif      FOR i IN [0..nDollarSigns) DO String.AppendStringAndGrow[@diffFileName, "$"L, myZone]; ENDLOOP;    String.AppendStringAndGrow[@diffFileName, ".dif"L, myZone];    };  -- End MakeDiffFileName.  --          -- Command line processing routines. --  MissingF2: SIGNAL = CODE;  GlobalSwitchError: SIGNAL = CODE;    ReadCommandLine: PROC[dataHandle: def.DataHandle] RETURNS [moreInput: BOOLEAN ¬ TRUE] = {    globalSwitch: LONG STRING ¬ NIL;        {ENABLE UNWIND =>       -- If there is any error, we must free everything we have allocated.      {IF dataHandle.file1 # NIL THEN         dataHandle.file1 ¬ Exec.FreeTokenString[dataHandle.file1];      IF dataHandle.file2 # NIL THEN         dataHandle.file2 ¬ Exec.FreeTokenString[dataHandle.file2];      IF globalSwitch # NIL THEN globalSwitch ¬ Exec.FreeTokenString[globalSwitch]};             -- Check for global switches.               [dataHandle.file1, globalSwitch] ¬ Exec.GetToken[def.exec];      IF (dataHandle.file1 = NIL OR dataHandle.file1.length = 0) AND globalSwitch # NIL THEN	{GlobalSwitches[dataHandle, globalSwitch];	globalSwitch ¬ Exec.FreeTokenString[globalSwitch];	[dataHandle.file1] ¬ Exec.GetToken[def.exec]};            -- If file1 = NIL then there are no more tokens on the command line.      IF dataHandle.file1 = NIL OR dataHandle.file1.length = 0 THEN        RETURN[FALSE];             -- Read file2 from the command line.      [dataHandle.file2] ¬ Exec.GetToken[def.exec];      IF dataHandle.file2 = NIL OR dataHandle.file2.length = 0 THEN        SIGNAL MissingF2;              }  -- End of ENABLE.    };  -- End ReadCommandLine.  --       GlobalSwitches: PROC [dataHandle: def.DataHandle, switches: LONG STRING] = {    i: CARDINAL ¬ 0;    flag: BOOLEAN ¬ TRUE;        WHILE i < switches.length DO      SELECT switches[i] FROM	'~, '- => flag ¬ ~flag;        's, 'S => {dataHandle.statementDelimiter ¬ flag;		  flag ¬ TRUE};		  		          IN ['0..'9] =>{number: CARDINAL;                      temp: STRING ¬ [5];                      IF flag = FALSE THEN SIGNAL GlobalSwitchError;                        WHILE i < switches.length AND switches[i] IN ['0..'9] DO                        IF temp.length >= 5 THEN SIGNAL GlobalSwitchError;                        temp[temp.length] ¬ switches[i];                        temp.length ¬ temp.length + 1;                        i ¬ i + 1;                        ENDLOOP;                      number ¬ String.StringToNumber[                      temp, 10 ! String.InvalidNumber => SIGNAL GlobalSwitchError];		      IF i >= switches.length THEN SIGNAL GlobalSwitchError;                        SELECT switches[i] FROM                         'm, 'M => dataHandle.linesForMatch ¬ number;                         'c, 'C => dataHandle.linesForContext ¬ number;			 'b, 'B => dataHandle.fileBufferSize ¬ number;                        ENDCASE => SIGNAL GlobalSwitchError		      };		              ENDCASE => SIGNAL GlobalSwitchError;	      i ¬ i + 1;      ENDLOOP;  };  -- GlobalSwitches.  --              -- Connection management   MakeConnection: PROC [conn: FileTransfer.Connection] =    {FileTransfer.SetProcs[conn: conn, clientData: conn, messages: MsgProc]};   MsgProc: FileTransfer.MessageProc = {    IF level = fatal THEN {       IF ~def.inExec THEN        {Put.Text[def.toolData.msgSW, "FileTransfer Error: "L];         Put.Text[def.toolData.msgSW, s1];	 Put.Text[def.toolData.msgSW, s2];         Put.Text[def.toolData.msgSW, s3];         Put.Text[def.toolData.msgSW, s4]}     ELSE         {Output: Format.StringProc ¬ Exec.OutputProc[def.exec];	 Output["FileTransfer Error: "L];	 Output[s1]; Output[s2]; Output[s3]; Output[s4];	 Format.CR[Exec.OutputProc[def.exec]]}}    };      DestroyConn: PROC [conn: LONG POINTER TO FileTransfer.Connection,      myVfn: LONG POINTER TO FileName.VirtualFilename] =     {IF conn­ # NIL THEN {FileTransfer.Destroy[conn­]; conn­ ¬ NIL};    IF myVfn­ # NIL THEN {FileName.FreeVFN[myVfn­]; myVfn­ ¬ NIL}};           END.  LOGDWR    	14-Jan-85 14:03:22  Changed checkEmpty to FALSE.
-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File CompareImpl.mesa-- Last edited by: -- RXR   	               3-Mar-82  9:46:44-- BTL  	              13-May-82 14:41:55-- TXS                        18-Feb-83 14:54:59-- RSF                        10-Feb-84 10:54:16DIRECTORY  Ascii USING [CR, NUL, SP, TAB],  CompareDefs USING [CheckAbort, DataHandle, diffFileName, exec, execData, inExec, s1, s2, toolData],  Environment USING [Block, bytesPerPage, LongNumber],  Exec USING [Handle, OutputProc],  Format USING [Blank, Char, CR, Line, LongNumber, NumberFormat, StringProc],  Heap USING [Error],  Inline USING [BITAND, BITXOR, LongNumber],  MSegment USING [Address, Create, Delete, Handle],  MStream USING [Error, Handle, Log],  Put USING [CR, Text],  Runtime USING [GetBcdTime],  Stream USING [Block, CompletionCode, EndOfStream, GetBlock, Handle,    PutString, SetPosition, SubSequenceType],  String USING [AppendChar, AppendCharAndGrow, AppendString, AppendStringAndGrow, CopyToNewString, MakeString, StringBoundsFault],  Time USING [Append, defaultTime, Unpack],  Version USING [Append],  Volume USING [InsufficientSpace];     CompareImpl: PROGRAM    IMPORTS CompareDefs, Exec, Format, Heap, Inline, MSegment, MStream, Put, Runtime, Stream, String, Time, Version, Volume     EXPORTS CompareDefs =  BEGIN OPEN def: CompareDefs;   -- Part of this algorithm taken from -- Heckel, Paul.  A Technique For Isolating Differences Between Files. -- Comm. ACM 21,4 (April 1978), 264-268.    Quit: SIGNAL = CODE;  UserAbort: ERROR = CODE;  EOF: SIGNAL[emptyLine: BOOLEAN] = CODE;     SP:  CHARACTER = Ascii.SP;  TAB: CHARACTER = Ascii.TAB;  CR:  CHARACTER = Ascii.CR;  NUL: CHARACTER = Ascii.NUL;  SymTableProcedure: TYPE = PROC [key: SymTabKey];    WordType: TYPE = RECORD [seq: SEQUENCE l:CARDINAL OF WORD];  longPtr: LONG POINTER TO UNSPECIFIED ¬ NIL;    differencesSeen: BOOLEAN;  -- file array descriptors, one entry for each line  f1: FileArray ¬ DESCRIPTOR[NIL,0];  f2: FileArray ¬ DESCRIPTOR[NIL,0];  f1Lines, f2Lines: CARDINAL;  index1, index2: CARDINAL;  startDifF1, startDifF2: CARDINAL;      FileArray: TYPE = LONG DESCRIPTOR FOR ARRAY[0..0) OF FileArrayEntry ¬ DESCRIPTOR[NIL,0];  FileArrayEntry: TYPE = RECORD [    position:   LONG CARDINAL,   -- initialize to 0  --    otherFLineNo: [0..77777B),   -- initialize to 0  --    symTabKey:    SymTabKey,     -- initialize to NIL  --    length:       [0..4000B)];   -- initialize to 0  --    -- symTabKey is a pointer to a specific symbol table entry.  fileArrayEntrySize: CARDINAL = SIZE[FileArrayEntry];    -- one entry for each distinct line  symTab: ARRAY [0..119) OF SymTabKey;   -- symTab is the hash code table.  SymTabKey: TYPE = LONG POINTER TO SymTabEntry;  SymTabEntry: TYPE = RECORD [    right, left:  SymTabKey,    f1Count:      [0..2],        -- actually 0, 1, or many    f1LineNo:     [0..37777B),    f2Count:      [0..2],    f2LineNo:     [0..37777B),    hashCode:     LONG CARDINAL];       -- Create file buffer.   fileBuffer: LONG POINTER TO PACKED ARRAY [0..0) OF CHARACTER;  fileBufferSeg: MSegment.Handle ¬ NIL;  block: Environment.Block;  fileIndex: LONG CARDINAL;  eofSeen: BOOLEAN;          CompareFiles: PUBLIC PROC[Output: Format.StringProc, dataHandle: def.DataHandle, myZone: UNCOUNTED ZONE] = { line: LONG STRING ¬ String.MakeString[myZone, 60]; whiteSpace: LONG STRING ¬ String.MakeString[myZone, 60];  BEGIN ENABLE {Quit => {Done[myZone]; GOTO exit};             UserAbort => {Output["Aborted by User."L]; Done[myZone];	       GOTO exit};	     Volume.InsufficientSpace => {Output["Insufficient space to continue compare...aborting."L]; GOTO insuffSpace}};        Init[dataHandle];    Pass1[Output, dataHandle, myZone, @line, @whiteSpace];   -- record first file's lines and enter into symbol table    Pass2[Output, dataHandle, myZone, @line, @whiteSpace];   -- record second file's lines and enter into symbol table    Pass3[];   -- match singleton lines in each file    Pass4[];   -- find matched blocks by scanning forward from matched singletons    Pass5[];   -- extend matched blocks by scanning backwards from matched lines    Pass6[dataHandle];   -- cancel matches if matched blocks are too short    ComputeNumberFormat[];    Pass7[dataHandle];   -- print differences    FinishUp[Output, dataHandle];    Done[myZone];    EXITS      exit => NULL;      insuffSpace => Done[myZone]; --do here so already Unwound    END};        Init: PROC[dataHandle: def.DataHandle] = {     symTab ¬ ALL[NIL];    difStream ¬ NIL;    differencesSeen ¬ FALSE;    f1Lines ¬ 0;  f2Lines ¬ 0;    fileBufferSeg ¬ MSegment.Create[file: NIL, release: [], pages: dataHandle.fileBufferSize];    fileBuffer ¬ MSegment.Address[fileBufferSeg]};      FinishUp: PROC[Output: Format.StringProc, dataHandle: def.DataHandle] = {    IF ~differencesSeen AND def.inExec THEN       {Output["No differences seen."L];      Format.CR[Output]}    ELSE IF ~differencesSeen THEN {WriteLine["No differences seen."L]; WriteCR[]};    IF differencesSeen AND def.inExec THEN       {Output["Differences in local file "L];      Output[def.diffFileName];      Format.CR[Output];      Output["End of differences seen."];      Format.CR[Output];      WriteCR[];      WriteLine["End of differences seen. "L];      WriteCR[]}    ELSE IF differencesSeen THEN      {WriteCR[];       WriteLine["End of differences seen. "L];      WriteCR[];      WriteCR[];      Put.CR[dataHandle.msgSW]}};    Done: PROC[myZone: UNCOUNTED ZONE] = {    FreeSymTable[myZone]; -- Frees all symbol table nodes.    -- Free the file arrays (BASE[f1] gives the address of the node allocated     -- for the array).     IF f1 # NIL THEN {longPtr ¬ BASE[f1]; myZone.FREE[@longPtr]; f1 ¬ NIL};    IF f2 # NIL THEN {longPtr ¬ BASE[f2]; myZone.FREE[@longPtr]; f2 ¬ NIL};    IF difStream # NIL THEN {difStream.delete[difStream]; difStream ¬ NIL};    IF fileBufferSeg # NIL THEN {MSegment.Delete[fileBufferSeg]; fileBufferSeg ¬ NIL}         };  -- End Done. --     Pass1: PROC[Output: Format.StringProc, dataHandle: def.DataHandle, myZone: UNCOUNTED ZONE, line, whiteSpace: LONG POINTER TO LONG STRING] = {    -- (a) Read each line i of file1 in sequence.    -- (b) Compute a hashcode and create a symbol table entry for each line i     --     if it does not exist.    -- (c) Increment f1Count.    -- (d) Set the file array entry f1[i] to point to the symbol table entry of line i.        ENABLE UNWIND => {longPtr ¬ BASE[f1]; myZone.FREE[@longPtr]; f1 ¬ NIL};    -- Initialize the fileBuffer.    nwords: CARDINAL;    fileIndex ¬ 0;    block ¬ [blockPointer: LOOPHOLE[fileBuffer], startIndex: 0, stopIndexPlusOne: 0];     eofSeen ¬ FALSE;    -- Allocate the array, f1, and initialize all of it's items.     nwords ¬ fileArrayEntrySize*1280;    f1 ¬ DESCRIPTOR[myZone.NEW[WordType[nwords]], 1280]; -- Allocate 30 pages of storage for f1. --    FOR i: CARDINAL IN [0..1280) DO     f1[i] ¬ [0, 0, NIL,0];     ENDLOOP;           DO      BEGIN ENABLE Heap.Error => IF type = otherError THEN {	IF def.inExec THEN	  Output["File1 exceeds maximum size.  Only the first 5120 lines will be compared.\n"L]	ELSE {          Output["File1 exceeds maximum size."L];	  Write["File1 exceeds maximum size.  Only the first 5120 lines will be compared."L]; WriteCR[]};	GOTO done};       IF def.CheckAbort[] THEN ERROR UserAbort;      IF f1Lines >= LENGTH[f1] THEN GrowFileArray[@f1, 640, myZone]; -- Grow fileArray in 15 page increments. --      ReadLine[f1, def.s1, f1Lines, dataHandle, myZone, line, whiteSpace! EOF => {IF ~emptyLine THEN f1Lines ¬ f1Lines + 1; GOTO done}];      f1Lines ¬ f1Lines + 1;      END; --enable      ENDLOOP;    EXITS      done => {         IF f1Lines = 0 THEN 	  {Output["Empty first file!"L]; SIGNAL Quit}}    };  -- End Pass1. --        Pass2: PROC[Output: Format.StringProc, dataHandle: def.DataHandle, myZone: UNCOUNTED ZONE, line, whiteSpace: LONG POINTER TO LONG STRING] = {  -- Identical to Pass1 except that it acts on file2.  fileIndex must be reset to 0 so  -- the second file will be read into the fileBuffer.    ENABLE UNWIND => {longPtr ¬ BASE[f2]; myZone.FREE[@longPtr]; f2 ¬ NIL};    nwords: CARDINAL;    fileIndex ¬ 0;    block.startIndex ¬ 0; block.stopIndexPlusOne ¬ 0;    eofSeen ¬ FALSE;    -- Allocate the array, f2, and initialize all of it's items.     nwords ¬ fileArrayEntrySize*1280;    f2 ¬ DESCRIPTOR[myZone.NEW[WordType[nwords]], 1280]; -- Allocate 30 pages of storage for f2. --    FOR i:CARDINAL IN [0..1280) DO      f2[i] ¬ [0,0,NIL,0];      ENDLOOP;           DO      BEGIN ENABLE Heap.Error => IF type = otherError THEN {	IF def.inExec THEN	  Output["File2 exceeds maximum size.  Only the first 5120 lines will be compared.\n"L]	ELSE {	  Output["File2 exceeds maximum size."L];	  Write["File2 exceeds maximum size.  Only the first 5120 lines will be compared"L]; WriteCR[]};	GOTO done};       IF def.CheckAbort[] THEN ERROR UserAbort;      IF f2Lines >= LENGTH[f2] THEN GrowFileArray[@f2, 640, myZone]; -- Grow fileArray in 15 page increments. --      ReadLine[f2, def.s2, f2Lines, dataHandle, myZone, line, whiteSpace! EOF => {IF ~emptyLine THEN f2Lines ¬ f2Lines + 1; GOTO done}];      f2Lines ¬ f2Lines + 1;      END;      ENDLOOP;    EXITS      done => {        IF f2Lines = 0 THEN 	  {Output["Empty second file!"L]; SIGNAL Quit}}    };  -- End Pass2. --         Pass3: PROC = {   -- Match singleton lines, those having f1Count = f2Count = 1, in each file.     MatchSingletonLines: SymTableProcedure = {       IF key.f2Count = 1 AND key.f1Count = 1 THEN          -- point lines at each other         {f1[key.f1LineNo].otherFLineNo ¬ key.f2LineNo;         f2[key.f2LineNo].otherFLineNo ¬ key.f1LineNo}       };  -- End MatchSingletonLines.            ScanSymTable[MatchSingletonLines]    };  -- End Pass3. --      Pass4: PROC = {  -- Find matching blocks by scanning forward from matched singleton lines.  -- If f1[i] points to f2[j] and f1[i+1] and f2[j+1] contain identical symTabKey  -- pointers, then f2[j+1] is set to line i+1 and f1[i+1] is set to line j+1.      index1 ¬ 0;    WHILE index1 < f1Lines DO      IF f1[index1].otherFLineNo # 0 THEN {  -- was matched to a singleton in f2        index2 ¬ f1[index1].otherFLineNo + 1;        index1 ¬ index1 + 1;		WHILE index1 < f1Lines AND index2 < f2Lines DO	  IF  f1[index1].otherFLineNo = 0 AND f2[index2].otherFLineNo = 0            AND f1[index1].symTabKey = f2[index2].symTabKey THEN            {f1[index1].otherFLineNo ¬ index2;             f2[index2].otherFLineNo ¬ index1}          ELSE	    IF f1[index1].symTabKey # f2[index2].symTabKey THEN	     GOTO endOfBlock;          index1 ¬ index1 + 1;  index2 ¬ index2 + 1;          REPEAT endOfBlock => NULL;          ENDLOOP}	        ELSE index1 ¬ index1 + 1;      ENDLOOP     };  -- End Pass4.  --       Pass5: PROC = {  -- Extend matched blocks by scanning backwards from matched lines.  -- If f1[i] points to f2[j] and f1[i-1] and f2[j-1] contain identical symTabKey  -- pointers, then f1[i-1] is set to j-1 and f2[j-1] is set to i-1.      index1 ¬ f1Lines - 1;    WHILE index1 >= 1 DO      IF f1[index1].otherFLineNo # 0 THEN  -- was matched to a line in f2        {index2 ¬ f1[index1].otherFLineNo - 1;         index1 ¬ index1 - 1; 		        WHILE index1 > 0 AND index2 > 0 DO          IF f1[index1].otherFLineNo = 0 AND f2[index2].otherFLineNo = 0             AND f1[index1].symTabKey = f2[index2].symTabKey THEN 	      -- the previous lines are indentical and have not been	      -- matched before.              {f1[index1].otherFLineNo ¬ index2;               f2[index2].otherFLineNo ¬ index1}          ELSE            {IF f1[index1].symTabKey # f2[index2].symTabKey THEN GOTO endOfBlock;            index1 ¬ index1 - 1;	    index2 ¬ index2 - 1};	  REPEAT endOfBlock => NULL;          ENDLOOP}	       ELSE index1 ¬ index1 - 1;      ENDLOOP    };  -- End Pass5. --       Pass6: PROC[dataHandle: def.DataHandle] = {  -- Cancel matches if matched blocks are too short.    IF dataHandle.linesForMatch > 1 THEN {      index1 ¬ 0;            WHILE index1 < f1Lines DO        IF f1[index1].otherFLineNo # 0 THEN  -- a matched line	  {start: CARDINAL ¬ index1;          index1 ¬ index1 + 1;	  WHILE index1 < f1Lines AND f1[index1].otherFLineNo = f1[index1-1].otherFLineNo+1 DO            index1 ¬ index1 + 1;	    ENDLOOP;	  IF (index1 - start) < dataHandle.linesForMatch AND index1 < f1Lines THEN            CancelMatch[array1: f1, array2: f2, file1Total: f1Lines, start: start]}	  	          ELSE index1 ¬ index1 + 1;        ENDLOOP}    };  -- End Pass6. --      Pass7: PROC[dataHandle: def.DataHandle] = {   -- Print differences  -- Array f1 now contains the information needed to list the differences.   -- If f1[i] points to a symbol table entry, then we assume that line i is an insert, and  -- we can flag it as new text.  If it points to f2[j], but f1[i+1] does not point to f2[j+1],  -- then line i is at the boundary of a deletion or block move and can be flagged as such.          printDiff: BOOLEAN ¬ FALSE;    IF def.CheckAbort[] THEN ERROR UserAbort;    index1 ¬ index2 ¬ 0;        WHILE index1 <= f1Lines AND index2 <= f2Lines AND      f1[index1].symTabKey = f2[index2].symTabKey DO        -- Match initial block.        index1 ¬ index1 + 1;  index2 ¬ index2 + 1;      ENDLOOP;    startDifF1 ¬ index1;  startDifF2 ¬ index2;        WHILE index1 < f1Lines AND index2 < f2Lines DO      IF def.CheckAbort[] THEN ERROR UserAbort;      IF f1[index1].otherFLineNo # 0 OR f2[index2].otherFLineNo # 0 THEN         -- at least one was matched        {IF f1[index1].otherFLineNo # 0 AND f2[index2].otherFLineNo # 0 THEN 	  -- both were matched	  {IF f1[index1].symTabKey = f2[index2].symTabKey THEN	    GOTO printOK;  -- they were matched to each other	  IF (f1[index1].otherFLineNo - index2) > (f2[index2].otherFLineNo - index1) THEN	    CancelMatch[array1: f1, array2: f2, file1Total: f1Lines, start: index1]          ELSE CancelMatch[array1: f2, array2: f1, file1Total: f2Lines, start: index2]};	IF f1[index1].otherFLineNo # 0 THEN 	  printDiff ¬ TryToResolveConflicts[f1, f2, index1, index2]          ELSE printDiff ¬ TryToResolveConflicts[f2, f1, index2, index1];	EXITS printOK => printDiff ¬ TRUE	};	      IF printDiff THEN {PrintDifferences[dataHandle];  printDiff ¬ FALSE}      ELSE {index1 ¬ index1 + 1;  index2 ¬ index2 + 1};      ENDLOOP;          IF startDifF1 < f1Lines OR startDifF2 < f2Lines THEN PrintDifferences[dataHandle, TRUE]    };  -- End Pass7.  --    GetChar: PROC[stream: Stream.Handle, dataHandle: def.DataHandle] RETURNS [ch: CHARACTER] = {    card: CARDINAL;    why: Stream.CompletionCode;    sst: Stream.SubSequenceType;    IF block.startIndex = block.stopIndexPlusOne THEN      {IF eofSeen THEN SIGNAL Stream.EndOfStream[nextIndex: 0];      Stream.SetPosition[stream, fileIndex];      block.startIndex ¬ 0;      block.stopIndexPlusOne ¬ dataHandle.fileBufferSize * Environment.bytesPerPage;      [bytesTransferred: card, why: why, sst: sst] ¬ Stream.GetBlock[stream, block];      SELECT why FROM        normal => NULL;	endOfStream => {eofSeen ¬ TRUE;	  IF card = 0 THEN SIGNAL Stream.EndOfStream[nextIndex: 0];	  block.stopIndexPlusOne ¬ card};	ENDCASE => ERROR      };    ch ¬ fileBuffer[block.startIndex];    block.startIndex ¬ block.startIndex + 1;    fileIndex ¬ fileIndex + 1;    RETURN[ch]    };  -- End GetChar. --      ReadLine: PROC[file: FileArray, s: Stream.Handle, lineNo: CARDINAL, dataHandle: def.DataHandle, myZone: UNCOUNTED ZONE, line, whiteSpace: LONG POINTER TO LONG STRING] = {  -- ReadLine reads the next line in a file into the provided string.  The string is reset  -- after the position of the first char has been entered into the file array and a symbol  -- table entry has been created or updated.    		      primaryHash, totalLength: CARDINAL ¬ 0;    secondaryHash, marker: LONG CARDINAL;    spaces: CARDINAL ¬ 0;    ch: CHARACTER;    				     		          GetPrimaryHashCode: PROC = {        CharBits: PROC[CHARACTER, WORD] RETURNS[WORD] = LOOPHOLE[Inline.BITAND];        Mask: WORD = 337b;		-- Masks out ASCII case shifts. --        v: WORD;        v ¬ CharBits[line[0], Mask]*177b + CharBits[line[line.length - 1], Mask];        primaryHash ¬ Inline.BITXOR[v, line.length*17b] MOD 119	};  -- End GetPrimaryHashCode. --            GetSecondaryHashCode: PROC = {        temp: CARDINAL;        dummy: Inline.LongNumber;        dummy.lc ¬ 0;        FOR i: CARDINAL IN [0..line.length) DO          temp ¬ LOOPHOLE[line[i]];          dummy.lowbits ¬ dummy.lowbits*31 + temp;          dummy.highbits ¬ dummy.highbits + temp;          ENDLOOP;        secondaryHash ¬ dummy.lc        }; -- End GetSecondaryHashCode. --                     SetLine: PROC = {        file[lineNo].position ¬ marker;        file[lineNo].length ¬ totalLength;        CreateSymTabEntry[file, lineNo, primaryHash, secondaryHash, myZone];	--reset string pointers	line.length ¬ 0;	whiteSpace.length ¬ 0;        };  -- End SetLine. --        {ENABLE {UNWIND => {IF line­ # NIL THEN line.length ¬ 0;                        IF whiteSpace­ # NIL THEN whiteSpace.length ¬ 0};            Stream.EndOfStream => 	      IF line.length = 0 THEN SIGNAL EOF[emptyLine: TRUE]	      ELSE {totalLength ¬ line.length; GetPrimaryHashCode[];		    GetSecondaryHashCode[];	            SetLine[]; SIGNAL EOF[emptyLine: FALSE]};		    	    String.StringBoundsFault => {line­ ¬ String.CopyToNewString[s: s, z: myZone, longer: 60];--may not need to free s since coming from private heap.              myZone.FREE[@s]; RESUME [line­]}};	    marker ¬ fileIndex;         DO    -- Discard leading blanks and tabs.    ch ¬ GetChar[s, dataHandle];    UNTIL ch # SP AND ch # TAB DO      spaces ¬ spaces + 1;      ch ¬ GetChar[s, dataHandle];      ENDLOOP;        -- Leading and trailing whitespace is ignored for computing hash codes.  --    UNTIL ch = CR OR ch = NUL DO      IF ch = SP THEN        {UNTIL ch = CR OR ch # SP DO	  String.AppendCharAndGrow[whiteSpace, ch, myZone];	  ch ¬ GetChar[s, dataHandle];	  ENDLOOP;	IF ch = CR THEN EXIT  -- discard trailing white space. --	  ELSE -- whiteSpace contains imbeded white space that must be appended to line. --	  {String.AppendStringAndGrow[line, whiteSpace­, myZone]; whiteSpace.length ¬ 0}};	      String.AppendChar[line­, ch];      IF ch = '; AND dataHandle.statementDelimiter = FALSE THEN {totalLength ¬ line.length; GOTO finish};      ch ¬ GetChar[s, dataHandle];      ENDLOOP;          String.AppendChar[line­, CR];  -- CR is a delimiter for comparisons.    totalLength ¬ line.length + whiteSpace.length;    IF line.length # 1 THEN {GetPrimaryHashCode[]; GetSecondaryHashCode[]; GOTO finish};    -- Reset the line. --    line.length ¬ 0; whiteSpace.length ¬ 0; spaces ¬ 0; marker ¬ fileIndex;     REPEAT       finish => NULL;    ENDLOOP;    totalLength ¬ totalLength + spaces;    SetLine[];    RETURN;    }};  -- End ReadLine.  --       CreateSymTabEntry: PROC[file: FileArray, lineNo: CARDINAL, primaryHash: CARDINAL,                           secondaryHash: LONG CARDINAL, myZone: UNCOUNTED ZONE] = {    ENABLE UNWIND => FreeSymTable[myZone];    node, nextNode: SymTabKey;    alreadyInTree: BOOLEAN;    root: SymTabKey ¬ symTab[primaryHash];    [alreadyInTree, node] ¬ FindHash[root, secondaryHash];        IF alreadyInTree THEN       {SELECT file FROM       f1 => IF node.f1Count < 2 THEN node.f1Count ¬ node.f1Count + 1;       f2 => {IF node.f2Count = 0 THEN node.f2LineNo ¬ lineNo;              IF node.f2Count < 2 THEN node.f2Count ¬ node.f2Count + 1};	ENDCASE; 	file[lineNo].symTabKey ¬ node}       ELSE       {nextNode ¬ myZone.NEW[SymTabEntry];      IF file = f1 THEN nextNode­ ¬ SymTabEntry[NIL, NIL, 1, lineNo, 0, 0, secondaryHash]      ELSE nextNode­ ¬ SymTabEntry[NIL, NIL, 0, 0, 1, lineNo, secondaryHash];      IF root = NIL THEN symTab[primaryHash] ¬ nextNode      ELSE IF secondaryHash < node.hashCode THEN node.left ¬ nextNode ELSE node.right ¬ nextNode;      file[lineNo].symTabKey ¬ nextNode}    };  -- End CreateSymTabEntry. --      FindHash: PROC[root: SymTabKey, val: LONG CARDINAL] RETURNS[inTree: BOOLEAN, node: SymTabKey] = {    nextNode: SymTabKey ¬ root;    IF root = NIL THEN RETURN[FALSE, NIL];    UNTIL nextNode = NIL DO      node ¬ nextNode;      nextNode ¬ SELECT val FROM        < node.hashCode => node.left,        > node.hashCode => node.right,        ENDCASE         => NIL;      ENDLOOP;    RETURN[val=node.hashCode, node]    };  -- End FindHash. --      ScanSymTable: PROC [Test: SymTableProcedure] = {  -- Scans each node in the symbol table.            ProcessEntry: PROC [key: SymTabKey, Test: SymTableProcedure] =       {IF key = NIL THEN RETURN;       Test[key];       ProcessEntry[key.left, Test];       ProcessEntry[key.right, Test]};           FOR index: CARDINAL IN [0..119) DO      ProcessEntry[symTab[index], Test];      ENDLOOP    };  -- End ScanSymTable.  --    	    FreeSymTable: PROC[myZone: UNCOUNTED ZONE] =    {FOR i: CARDINAL IN [0..119) DO      IF symTab[i] # NIL THEN {        FreeSymbolEntries[symTab[i], myZone];	symTab[i] ¬ NIL};      ENDLOOP};    FreeSymbolEntries: PROC [ptr: SymTabKey, myZone: UNCOUNTED ZONE] =     {IF ptr.left # NIL THEN FreeSymbolEntries[ptr.left, myZone];     IF ptr.right # NIL THEN FreeSymbolEntries[ptr.right, myZone];     myZone.FREE[@ptr]};        	        GrowFileArray: PROC [arrayPtr: LONG POINTER TO FileArray, larger: CARDINAL, myZone: UNCOUNTED ZONE] = {  -- GrowFileArray enlarges the storage area of a file array descriptor.    freeOnUnwind: BOOLEAN ¬ TRUE;     {ENABLE UNWIND => IF freeOnUnwind THEN {        longPtr ¬ BASE[arrayPtr­];        myZone.FREE[@longPtr]; arrayPtr­ ¬ NIL};        nwords: CARDINAL;    oldFileArray: FileArray ¬ arrayPtr­;    oldLength: CARDINAL = LENGTH[oldFileArray];    newLength: CARDINAL = oldLength + larger;          -- Make a new array of the correct size.    nwords ¬ fileArrayEntrySize * newLength;    arrayPtr­ ¬ DESCRIPTOR [myZone.NEW[WordType[nwords]      ! Heap.Error => IF type = otherError THEN {freeOnUnwind ¬ FALSE;        REJECT}], newLength];          -- Copy the items from the old array to the new one.    FOR i: CARDINAL IN [0..oldLength) DO      arrayPtr[i] ¬ oldFileArray[i];      ENDLOOP;	    -- Initialize the new items in the new array.    FOR i: CARDINAL IN [oldLength..newLength) DO       arrayPtr[i] ¬ [0,0,NIL,0];       ENDLOOP;	     -- Free up the old array, but NOT the strings.    longPtr ¬ BASE[oldFileArray]; myZone.FREE[@longPtr];    oldFileArray ¬ NIL;    }};  -- End GrowFileArray.  --      CancelMatch: PROC [array1, array2: FileArray, file1Total, start: CARDINAL] = {    i: CARDINAL ¬ start;    UNTIL array1[i].otherFLineNo = 0 DO      oldValue: CARDINAL ¬ array1[i].otherFLineNo;      array1[i].otherFLineNo ¬ array2[array1[i].otherFLineNo].otherFLineNo ¬ 0;      i ¬ i + 1;      IF i >= file1Total OR         --run of matched lines is over --         array1[i].otherFLineNo # oldValue+1 THEN RETURN;      ENDLOOP    };  -- End CancelMatch. --      TryToResolveConflicts: PROC [    array1, array2: FileArray, index1, index2: CARDINAL]    RETURNS [okToDumpDiff: BOOLEAN] = {    lastRange1: CARDINAL;        IF array1[index1].otherFLineNo < index2 THEN      --This matches line(s) we've already passed in our processing      {CancelMatch[array1, array2, f1Lines, index1];      RETURN[okToDumpDiff: FALSE]};          lastRange1 ¬ index1 + array1[index1].otherFLineNo - index2;    FOR i: CARDINAL IN [index2..array1[index1].otherFLineNo) DO      IF array2[i].otherFLineNo # 0 THEN         {IF array2[i].otherFLineNo > lastRange1 THEN          CancelMatch[array2, array1, f2Lines, i]        ELSE           {CancelMatch[array1, array2, f1Lines, index1];          RETURN[okToDumpDiff: FALSE]}};      ENDLOOP;    RETURN[okToDumpDiff: TRUE]    };  -- End TryToResolveConflicts.  --        PrintDifferences: PROC[dataHandle: def.DataHandle, endOfFile: BOOLEAN ¬ FALSE] = {    i, last: CARDINAL;        IF ~differencesSeen AND def.inExec THEN OpenDifFile[def.diffFileName];    IF ~differencesSeen THEN {WriteTwoAster[]; differencesSeen ¬ TRUE};          IF index1 > f1Lines OR index2 > f2Lines THEN {index1 ¬ f1Lines; index2 ¬ f2Lines}    ELSE      IF f1[index1].otherFLineNo # 0 THEN index2 ¬ f1[index1].otherFLineNo      ELSE IF f2[index2].otherFLineNo # 0 THEN index1 ¬ f2[index2].otherFLineNo;          -- print block from file 1    IF endOfFile THEN last ¬ f1Lines    ELSE last ¬ MIN[index1 + dataHandle.linesForContext - 1, f1Lines];    IF startDifF1 < f1Lines THEN       {WriteFile1Positions[from: f1[startDifF1].position, to: f1[last].position + f1[last].length];       FOR i IN [startDifF1..last] DO         IF def.CheckAbort[] THEN ERROR UserAbort;         Print[def.s1, f1[i].position, f1[i].length ! Stream.EndOfStream => {WriteCR; EXIT}];       ENDLOOP};    WriteCR[]; WriteAster[];  WriteCR[];        -- print block from file 2    IF endOfFile THEN last ¬ f2Lines    ELSE last ¬ MIN[index2 + dataHandle.linesForContext - 1, f2Lines];    IF startDifF2 < f2Lines THEN       {WriteFile2Positions[from: f2[startDifF2].position, to: f2[last].position + f2[last].length];       FOR i IN [startDifF2..last] DO         IF def.CheckAbort[] THEN ERROR UserAbort;         Print[def.s2, f2[i].position, f2[i].length ! Stream.EndOfStream => {WriteCR; EXIT}];       ENDLOOP};    WriteCR[]; WriteTwoAster[];        i ¬ index1 + 1;    WHILE i < f1Lines AND f1[i].otherFLineNo # 0 DO      IF f1[i].otherFLineNo # f1[i-1].otherFLineNo+1 THEN EXIT;      i ¬ i + 1;      ENDLOOP;    index2 ¬ index2 + (i-index1);     index1 ¬ i;     startDifF1 ¬ index1;  startDifF2 ¬ index2  };  -- End PrintDifferences.  --      -- Output stream management  difStream: Stream.Handle ¬ NIL;  numFormat: Format.NumberFormat;    OpenDifFile: PROC [name: LONG STRING] =     {difStream ¬ MStream.Log[name, []       ! MStream.Error => {Format.Line[Exec.OutputProc[def.exec], "Unable to open difference file."L]; Format.CR[Exec.OutputProc[def.exec]]; SIGNAL Quit}];      WriteHerald[]};        WriteHerald: PROC =    {herald: STRING ¬ [60];     WriteCR[];     String.AppendString[herald, "Compare "L];      Version.Append[herald];     String.AppendString[herald, " of "L];     Time.Append[herald, Time.Unpack[Runtime.GetBcdTime[]]];     herald.length ¬ herald.length-3;     WriteLine[herald];      herald.length ¬ 0;     String.AppendString[herald, "  "L];     Time.Append[herald, Time.Unpack[Time.defaultTime]];     herald.length ¬ herald.length-3;     WriteLine[herald];     WriteCR[];     Write["Differences between "L];      Write[def.execData.file1];     Write[" and "L];      WriteLine[def.execData.file2];     WriteCR[]};    Print: PROC [s: Stream.Handle, start: LONG CARDINAL, stopIndex: CARDINAL] =    {Stream.SetPosition[s, start];     [] ¬ Stream.GetBlock[s, [blockPointer: LOOPHOLE[fileBuffer],                             startIndex: 0,			     stopIndexPlusOne: stopIndex]			     ! Stream.EndOfStream => CONTINUE];     FOR i:  CARDINAL IN [0..stopIndex) DO       WriteChar[fileBuffer[i] ! Stream.EndOfStream => EXIT];       ENDLOOP};              Write: Format.StringProc = {    IF def.inExec AND difStream # NIL THEN      Stream.PutString[difStream, s]    ELSE       Put.Text[def.toolData.fileSW, s]};        WriteLine: PROC [s: LONG STRING] = {Write[s];  WriteCR[]};  WriteCR: PROC = {Format.CR[Write]};  WriteChar: PROC [c: CHARACTER] = {Format.Char[Write, c]};  WriteSP: PROC = {Format.Blank[Write]};  WriteAster: PROC = {Write["**************************************"L]};  WriteTwoAster: PROC = {WriteAster[];  WriteAster[];  WriteCR[]};  WriteNumber: PROC [n: LONG UNSPECIFIED, f: Format.NumberFormat] = {Format.LongNumber[Write, n, f]};      ComputeNumberFormat: PROC = {    col: [0..255] ¬ 1;    max: CARDINAL ¬ MAX[f1Lines, f2Lines];    UNTIL (max ¬ max/10) = 0 DO col ¬ col+1 ENDLOOP;    numFormat ¬ [base: 10, zerofill: TRUE, unsigned: TRUE, columns: col]};      WriteFile1Positions: PROC [from, to: LONG CARDINAL] = {    Write["File 1: Positions "L];  WriteNumber[from, numFormat];    IF to > from THEN {Write[" - "];  WriteNumber[to, numFormat]} ELSE WriteSP[];    WriteCR[]; WriteCR[]};      WriteFile2Positions: PROC [from, to: LONG CARDINAL] = {    Write["File 2: Positions "L];  WriteNumber[from, numFormat];    IF to > from THEN {Write[" - "];  WriteNumber[to, numFormat]} ELSE WriteSP[];    WriteCR[]; WriteCR[]};            END.  
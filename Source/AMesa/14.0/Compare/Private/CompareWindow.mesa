-- Copyright (C) 1982, 1984  by Xerox Corporation. All rights reserved. -- CompareWindow.mesa-- Last edited by:-- TXS 				     23-Dec-82 13:51:52-- RSF      			      2-Aug-84 15:28:33-- DWR    	14-Jan-85 14:04:30DIRECTORY  CompareDefs USING [AbortType, Data, DataHandle, DoComparison],  Exec USING [AddCommand, CheckForAbort, ExecProc, Handle, OutputProc, RemoveCommand],  Format USING [StringProc],  FormSW USING [AllocateItemDescriptor, ClientItemsProcType, CommandItem, Enumerated, EnumeratedItem, line0, nextLine, NumberItem, ProcType, sameLine, StringItem],  Heap USING [Create, Delete, systemZone],  MsgSW USING [Clear],  Process USING [Detach],  Put USING [Line, Text],  Runtime USING [GetBcdTime, IsBound],  String USING [AppendString],  Time USING [Append, Unpack],  Tool USING [Create, Destroy, MakeFileSW, MakeFormSW, MakeMsgSW, MakeSWsProc, UnusedLogName],  ToolDriver USING [Address, NoteSWs, RemoveSWs],  ToolWindow USING [TransitionProcType],  UserInput USING [UserAbort],  UserTerminal USING [BlinkDisplay],  Version USING [Append],  Window USING [Handle];CompareWindow: MONITOR   IMPORTS CompareDefs, Exec, FormSW, Heap, MsgSW, Process, Put, Runtime, String, Time, Tool, ToolDriver, UserInput, UserTerminal, Version  EXPORTS CompareDefs =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  myExecZone: UNCOUNTED ZONE ¬ NIL;  myToolZone: UNCOUNTED ZONE ¬ NIL;  wh: PUBLIC Window.Handle ¬ NIL;  toolData, execData: PUBLIC CompareDefs.DataHandle ¬ NIL;  inExec: PUBLIC BOOLEAN ¬ FALSE;  exec: PUBLIC Exec.Handle ¬ NIL;  busy: BOOLEAN ¬ FALSE;  condition: CONDITION;    Abort: CompareDefs.AbortType ¬ NIL;  CheckAbort: PUBLIC CompareDefs.AbortType = {RETURN[Abort[]]};  WindowAbort: CompareDefs.AbortType = {RETURN[UserInput.UserAbort[wh]]};    FormSWCommandRoutine: FormSW.ProcType = {    abort: CompareDefs.AbortType = {RETURN[UserInput.UserAbort[wh]]};    {ENABLE UNWIND => {Unlock[];                        Heap.Delete[z: myExecZone, checkEmpty: FALSE]};    MsgSW.Clear[toolData.msgSW];    Put.Text[toolData.msgSW, "Comparing..."L];    IF ~Go[] THEN     {Put.Text[toolData.msgSW, "Compare is busy! "L];     UserTerminal.BlinkDisplay[];     RETURN};    Abort ¬ WindowAbort;    IF myToolZone = NIL THEN myToolZone ¬ Heap.Create[initial: 30, increment: 15];    Process.Detach[FORK CompareDefs.DoComparison[OutputMsgSW, @toolData, @myToolZone]]}};        OutputMsgSW: Format.StringProc = {     IF toolData.msgSW # NIL THEN Put.Line[toolData.msgSW, s]};    ClientTransition: ENTRY ToolWindow.TransitionProcType = {    SELECT TRUE FROM      old = inactive =>       -- Use the system Zone to manage the storage of the string fields in the --      -- tool.  Create a private heap for each Compare! --      IF toolData = NIL THEN toolData ¬ z.NEW[CompareDefs.Data ¬ []];      new = inactive =>        {IF toolData # NIL THEN		  {WHILE busy DO WAIT condition ENDLOOP;	  z.FREE[@toolData]};	 ToolDriver.RemoveSWs["Compare"L]};      ENDCASE};  MakeForm: FormSW.ClientItemsProcType = {    OPEN FormSW;    nItems: CARDINAL = 7;    delimiterArray: ARRAY [0..2) OF Enumerated ¬ [      ["CR"L, TRUE], [";"L, FALSE]];    bufferSizeArray: ARRAY [0..3) OF Enumerated ¬ [      ["small"L, 10], ["medium"L, 30], ["large"L, 50]];    items ¬ AllocateItemDescriptor[nItems];    items[0] ¬ StringItem[      tag: "File 1"L, place: [0, line0], string:  @toolData.file1, inHeap: TRUE];    items[1] ¬ StringItem[      tag: "File 2"L, place: [0, nextLine], string: @toolData.file2, inHeap: TRUE];    items[2] ¬ EnumeratedItem[      tag: "File Size"L, place: [0, nextLine], feedback: one,      value: @toolData.fileBufferSize, choices: DESCRIPTOR[bufferSizeArray]];    items[3] ¬ EnumeratedItem[      tag: "Delimiter"L, place: [200, sameLine], feedback: one,      value: @toolData.statementDelimiter, choices: DESCRIPTOR[delimiterArray]];    items[4] ¬ NumberItem[      tag: "Lines For Context"L,      value: @toolData.linesForContext,      signed: FALSE,      default: 1,      place: [0, nextLine]];    items[5] ¬ NumberItem[      tag: "Lines For Match"L,      value: @toolData.linesForMatch,      signed: FALSE,      default: 1,      place: [200, sameLine]];    items[6] ¬ CommandItem[      tag: "Compare"L, place: [0, nextLine], proc: FormSWCommandRoutine];    RETURN[items: items, freeDesc: TRUE];    };  MakeSWs: Tool.MakeSWsProc = {    logName: STRING ¬ [40];    addresses: ARRAY [0..3) OF ToolDriver.Address;    Tool.UnusedLogName[unused: logName, root: "Compare.log"L];    toolData.msgSW ¬ Tool.MakeMsgSW[window: window, lines: 2];    toolData.formSW ¬ Tool.MakeFormSW[window: window, formProc: MakeForm];    toolData.fileSW ¬ Tool.MakeFileSW[window: window, name: logName];    addresses ¬ [      [name: "msgSW"L, sw: toolData.msgSW],      [name: "formSW"L, sw: toolData.formSW],      [name: "fileSW"L, sw: toolData.fileSW]];    ToolDriver.NoteSWs["Compare"L, DESCRIPTOR[addresses]]    };     CompareExec: Exec.ExecProc = {    ExecAbortProc: CompareDefs.AbortType = {RETURN[Exec.CheckForAbort[exec]]};    {ENABLE UNWIND => {Unlock[];                        Heap.Delete[z: myExecZone, checkEmpty: FALSE]};    IF ~Go[] THEN      {Exec.OutputProc[h]["Compare is busy."L]; RETURN};    IF myExecZone = NIL THEN myExecZone ¬ Heap.Create[initial: 30, increment: 15];    IF execData = NIL THEN execData ¬ myExecZone.NEW[CompareDefs.Data¬ []];    exec ¬ h;    inExec ¬ TRUE;    Abort ¬ ExecAbortProc;    CompareDefs.DoComparison[Exec.OutputProc[exec], @execData, @myExecZone]}};      MyUnload: Exec.ExecProc = {    IF wh # NIL THEN Tool.Destroy[wh];    Exec.RemoveCommand[h, "Compare"L]};      Init: PROCEDURE = {    name: STRING = [50];    IF Runtime.IsBound[LOOPHOLE[Tool.Create]] AND wh = NIL THEN     {String.AppendString[name, "Compare "L];      Version.Append[name];      String.AppendString[name, " of "L];      Time.Append[name, Time.Unpack[Runtime.GetBcdTime[]]];      wh ¬ Tool.Create[        makeSWsProc: MakeSWs, initialState: default,        clientTransition: ClientTransition, name: name,        cmSection: "Compare"L, tinyName1: "Compare"L]};    Exec.AddCommand[name: "Compare.~"L, proc: CompareExec, unload: MyUnload]};      Go: PUBLIC PROC RETURNS [BOOLEAN] = {RETURN[enter[]]};  Unlock: PUBLIC PROC = {leave[]};    enter: ENTRY PROC RETURNS [okay: BOOLEAN] = {    ENABLE UNWIND => NULL;    IF busy THEN RETURN[FALSE];    busy ¬ TRUE;  RETURN[TRUE]};      leave: ENTRY PROC = {    ENABLE UNWIND => NULL;    busy ¬ FALSE;  NOTIFY condition};      -- Mainline code  Init[];  -- This removes strings from the global frame.  END.LOGDWR    	14-Jan-85 14:04:14  changed checkEmpty to FALSE  
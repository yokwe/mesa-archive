-- Copyright (C) 1984, 1985, 1987  by Xerox Corporation. All rights reserved. -- BootChannelFloppy.mesa   28-Apr-87  8:10:01 by CAJ-- Last edited by:          27-Nov-89 15:30:47 by TSS  <<  This is a general-case floppy driver designed for use with the germ.  It was constructed from BootChannelFloppyDLion.mesa, using BootChannelDisk.mesa as an example...    Note how this makes for A LOT of code ("what's the matter, spock?" "I just felt a million vulcans die: eaten by a monster virus!" "Bones, quick -- a shot of monster antibodies!");  a giant germ.  Don't fret, the germ will be shrunk down to size after it is packaged and knows how to reclaim memory out from under the code (BootChannelFloppy, eg) it ceases to require.    OK, it's now packaged and real memory under initialization code gets returned after initialization (everybody's, not just this module), and under floppy code gets returned after inload.>>DIRECTORY  Boot USING [Location, DiskFileID],  BootChannel USING [    Create, Handle, Operation, Result, transferCleanup, transferWait],  Device USING [Type],  DeviceTypes USING [sa800],  DeviceTypesExtras4 USING [ExtendedFloppy, FloppyTape],  Environment USING [Byte, first64K, LongNumber, LongPointerFromPage,    --PageFromLongPointer, --PageNumber],  GermOps USING [GermWorldError],  Inline USING [DIVMOD, LowHalf],  PilotMP USING [cGermDeviceError, cGermERROR, Code],  ProcessorFace USING [SetMP],  ResidentHeap USING [FreeNode, MakeNode],  FloppyDiskFace USING [    DeviceHandle, DiskAddress, DiskChangeClear, GetDeviceAttributes,    GetNextDevice, Initialize, initialAllocationLength, Initiate,    nullDeviceHandle, operationAlignment, operationBlockLength, OperationPtr,    Poll, SetContext, Status, Tries];BootChannelFloppy: PROGRAM  IMPORTS    RemainingChannels: BootChannel, Environment, FloppyDiskFace, GermOps, Inline, ProcessorFace, ResidentHeap   EXPORTS BootChannel  SHARES Device, GermOps =  BEGIN    Ops: TYPE = [0..maxOps);  maxOps: CARDINAL = 2;    -- To stay within heapspace, max maxOps = 5(DLion) or 2(Dove).  OpsDescriptor: TYPE = RECORD [    op: FloppyDiskFace.OperationPtr,    state: {idle, busy}, -- idle means operation AND ERROR HANDLING are done.    opState: {running, completed}, -- completed means operation ONLY is done.    status: FloppyDiskFace.Status];  cylinders: CARDINAL;  tracksPerCylinder, sectorsPerTrack: Environment.Byte;  ops: ARRAY Ops OF OpsDescriptor;  initialOp: FloppyDiskFace.OperationPtr;  --used only in Create.  diskAddress: FloppyDiskFace.DiskAddress;  floppyTape: BOOLEAN;  maxTries: FloppyDiskFace.Tries = 128;  -- try real hard  -- The 128 is a magic number which fulfills the following conditions:  --   causes as many retries as possible,  --   >= DLion head's (floppy tape) private maxRetries value (30),  --   =  DLion head's (floppy disk) only value to cause retries (128),  --   >= Dove head's ActualNumberOfRetriesWhenDMAHit (50).  -- Changes in either head could invalidate the value.          Create: PUBLIC --BootChannel.-- PROCEDURE [    pLocation: LONG POINTER TO Boot.Location, operation: BootChannel.Operation,    buffer: LONG POINTER]    RETURNS [result: BootChannel.Result, handle: BootChannel.Handle] =    BEGIN    -- The buffer arg is not used by this boot channel.    IF pLocation.deviceType = DeviceTypes.sa800      OR pLocation.deviceType IN DeviceTypesExtras4.ExtendedFloppy      THEN RETURN CreateInternal[pLocation, operation, buffer]    ELSE        -- not anything I implement.  Pass it on.      RETURN RemainingChannels.Create[pLocation, operation];    END; --Create--  -- CreateInternal exists so that when memory backing germ-floppy code is  -- discarded, create code can be discarded without breaking the BootChannel  -- chain.  CreateInternal: PROCEDURE [    pLocation: LONG POINTER TO Boot.Location, operation: BootChannel.Operation, buffer: LONG POINTER]    RETURNS [result: BootChannel.Result, handle: BootChannel.Handle] =    BEGIN    -- At present, we don't pass errors back to caller via result.    -- This is because it is not thought to be particularly useful.    device: FloppyDiskFace.DeviceHandle;    tries: CARDINAL ¬ 0; --used in count for while loop    noBootFileFound: FloppyDiskFace.DiskAddress ¬ [0,0,0]; -- an illegal address        IF pLocation.deviceOrdinal # 0 OR operation = write THEN      GermOps.GermWorldError[PilotMP.cGermDeviceError];    floppyTape ¬ pLocation.deviceType IN DeviceTypesExtras4.FloppyTape;    initialOp ¬ @Environment.first64K[      ResidentHeap.MakeNode[FloppyDiskFace.initialAllocationLength,	FloppyDiskFace.operationAlignment].node];    FloppyDiskFace.Initialize[notify: 0, initialAllocation: initialOp];    device ¬ FloppyDiskFace.GetNextDevice[FloppyDiskFace.nullDeviceHandle];    FloppyDiskFace.DiskChangeClear[device];        FOR i: Ops IN Ops DO      operation: LONG POINTER TO FloppyDiskFace.OperationPtr = @ops[i].op;      operation­ ¬ @Environment.first64K[        ResidentHeap.MakeNode[FloppyDiskFace.operationBlockLength,	  FloppyDiskFace.operationAlignment].node];      operation.device ¬ device;      operation.function ¬ readSector;      operation.incrementDataPointer ¬ TRUE;      operation.tries ¬ maxTries;      ops[i].state ¬ idle;      ENDLOOP;	    [] ¬ FloppyDiskFace.SetContext[device, [FALSE, IBM, double, 256]];    diskAddress ¬ LOOPHOLE[pLocation.diskFileID.da];    [[numberOfCylinders: cylinders,      numberOfHeads: tracksPerCylinder,      maxSectorsPerTrack: sectorsPerTrack]] ¬      FloppyDiskFace.GetDeviceAttributes[device];         WHILE (diskAddress = noBootFileFound) DO  -- boot file not on this floppy    	diskAddress ¬ GetBootfileFromAnotherFloppy[buffer, device];    ENDLOOP;    RETURN[[ok[]], Transfer];        END;  --CreateInternal--      GetBootfileFromAnotherFloppy: PROCEDURE [buffer: LONG POINTER, device: FloppyDiskFace.DeviceHandle] RETURNS [da: FloppyDiskFace.DiskAddress]      =    << Handles the case where germ is on floppy #1, boot file is on floppy #2. This is the booting methodology used if the bootfile, germ, and or ucode are too large for one floppy.          Procedure flow:    1. Wait for the user to put the 2nd floppy in the drive.      1a. Cycle MP code between 2222 and FFFF    2. Attempt a read to see if the correct floppy is there. If no floppy, status will be notReady. If a floppy without bootfile is in the drive, the RETURNed address will be incorrect and we will return to GetBootfileFromAnotherFloppy[] amd try again.    >>        BEGIN    	FloppyBootFileType: TYPE = MACHINE DEPENDENT        	{hardMicrocode, softMicrocode, germ, pilot, alternateMicrocode};        arrayForBootFileType: TYPE = ARRAY FloppyBootFileType OF Boot.DiskFileID;	arrayPtr: LONG POINTER TO arrayForBootFileType; --structure being read from bootrootpage	operation: FloppyDiskFace.OperationPtr ¬ ops[0].op;	status: FloppyDiskFace.Status ¬ notReady; --initialize status	noBootFileMP: CARDINAL ¬ 2222; --MP code indicating no boot file on floppy	noBootFileMPAlso: CARDINAL ¬ 2222; -- no blinking MP code,now-maybe later 	bootRootPage: FloppyDiskFace.DiskAddress = [cylinder:4, head:0, sector:1];  --from rootPageAddress in FBStompToolDove.mesa			ToggleMPCodes: PROCEDURE [] =	BEGIN	   i: CARDINAL; --loop counter	   toggleCount: CARDINAL ¬ 10;	   loopCount: CARDINAL ¬ 6; -- makes it run for ~20secs	   FOR i IN [1..loopCount) DO	      ProcessorFace.SetMP[noBootFileMP]; --first MP code	      THROUGH [1..toggleCount) DO --wait 	   	   THROUGH [1..LAST[CARDINAL]] DO ENDLOOP;	      ENDLOOP;	      ProcessorFace.SetMP[noBootFileMPAlso]; --second MP code	      THROUGH [1..toggleCount) DO --wait 	   	   THROUGH [1..LAST[CARDINAL]] DO ENDLOOP;	      ENDLOOP;	   ENDLOOP;	END; --ToggleMPCodes		WHILE status = notReady DO	   ToggleMPCodes[];	   -- wait for user to put floppy with bootfile into drive.	   -- Wait time = (each ToggleMPCodes call = 20 seconds)	   --  Attempt to read floppy now.	   [] ¬ FloppyDiskFace.SetContext[device, [FALSE, IBM, double, 256]];	   [[numberOfCylinders: cylinders,      	   numberOfHeads: tracksPerCylinder,     	   maxSectorsPerTrack: sectorsPerTrack]] ¬     	  	 FloppyDiskFace.GetDeviceAttributes[device];	   operation.address ¬ bootRootPage;    	   operation.dataPtr ¬ buffer;    	   operation.count ¬ 1; 	   operation.function ¬ readSector;	   [] ¬ FloppyDiskFace.Initiate[operation];	   WHILE (status ¬ FloppyDiskFace.Poll[ops[0].op].status) = inProgress 	   DO		THROUGH [0..100) DO ENDLOOP;  -- give the IOP a break		--code ¬ code +1; GermOps.ShowCodeInMP[code];debug	   ENDLOOP;	ENDLOOP; --of WHILE status = notReady	-- Process status	IF status # goodCompletion THEN        BEGIN --process bad status		GermOps.GermWorldError[PilotMP.cGermDeviceError];  	END	ELSE BEGIN --process good status		arrayPtr ¬ buffer;		da.cylinder ¬ arrayPtr[pilot].da.cylinder; -- new disk address		da.head ¬ arrayPtr[pilot].da.head;		da.sector ¬ arrayPtr[pilot].da.sector;	END;	    END; -- GetBootfileFromAnotherFloppy       Transfer: BootChannel.Handle  --    --PROC [page, count] RETURNS [result: BootChannel.Result]-- =    BEGIN    -- At present, we don't pass errors back to caller via result.    -- This is because it is not thought to be particularly useful.    SELECT count FROM      = BootChannel.transferCleanup =>          BEGIN	  [] ¬ ResidentHeap.FreeNode[Inline.LowHalf[initialOp]];          FOR i: Ops IN Ops DO            [] ¬ ResidentHeap.FreeNode[Inline.LowHalf[ops[i].op]];	    ENDLOOP;	  END;      = BootChannel.transferWait =>          BEGIN          THROUGH Ops DO	    FinishRequest[];	    RotateOps[];	    ENDLOOP;	  END;      NOT IN CARDINAL => GermOps.GermWorldError[PilotMP.cGermERROR];      ENDCASE =>        BEGIN	IF ops[0].state = busy THEN FinishRequest[];	SubmitRequest[page, CARDINAL[count]];      	RotateOps[];	END; --ENDCASE--    RETURN[[ok[]]];    END; --Transfer--           FinishRequest: PROCEDURE =                 -- forces ops[0] to the idle state    BEGIN    ForceCompleted: PROCEDURE =      BEGIN      status: FloppyDiskFace.Status;      IF ops[0].state = idle THEN RETURN;      IF ops[0].opState = running THEN        BEGIN	WHILE (status ¬ FloppyDiskFace.Poll[ops[0].op].status) = inProgress DO	  THROUGH [0..100) DO ENDLOOP;  -- give the IOP a break	  ENDLOOP;	ops[0].opState ¬ completed;        ops[0].status ¬ status;        END;      END; --ForceCompleted--        UNTIL ops[0].state = idle DO      ForceCompleted[];      IF ops[0].status # goodCompletion THEN        BEGIN --error handler--	code: PilotMP.Code ¬	  (IF floppyTape AND (ops[0].status = otherError)	    THEN code ¬ 926--cGermMediaProblem--	  -- Replace 926 with PilotMP.cGermMediaProblem when we can use	  -- PilotMP.mesa it's in.	  ELSE PilotMP.cGermDeviceError);        GermOps.GermWorldError[code];	END --error handler--      ELSE        ops[0].state ¬ idle;      ENDLOOP;    END; --FinishRequest--      SubmitRequest: PROCEDURE [    page: Environment.PageNumber, count: CARDINAL] =    -- Initiates ops[0].    BEGIN    operation: FloppyDiskFace.OperationPtr ¬ ops[0].op;    ops[0].state ¬ busy;    ops[0].opState ¬ running;    operation.address ¬ diskAddress;    operation.dataPtr ¬ Environment.LongPointerFromPage[page];    operation.count ¬ count;    [] ¬ FloppyDiskFace.Initiate[operation]; -- throw away early status    diskAddress ¬ NewAddress[count];    -- note diskAddress already updated, so no retries    END; --SubmitRequest--          RotateOps: PROCEDURE =    BEGIN    t: OpsDescriptor = ops[0];    FOR i: Ops IN [1..LAST[Ops]] DO      ops[i-1] ¬ ops[i];      ENDLOOP;    ops[LAST[Ops]] ¬ t;    RETURN;    END; --RotateOps--          NewAddress: PROCEDURE [count: CARDINAL]    RETURNS [da: FloppyDiskFace.DiskAddress] =    BEGIN    q: CARDINAL;    [q, da.sector] ¬      Inline.DIVMOD[diskAddress.sector - 1 + count, sectorsPerTrack];    da.sector ¬ da.sector + 1;  -- sectors start with 1    [q, da.head] ¬ Inline.DIVMOD[diskAddress.head + q, tracksPerCylinder];    da.cylinder ¬ diskAddress.cylinder + q;    END;    END.LOG 30-Nov-81  8:07:40	FXH       Created file..12-Feb-82 16:57:10	LXD         Bug fix in ReadPage29-Jul-82  9:55:16	AEF        Modify for new IOPage layout13-Apr-83  9:58:49	WDK        Get LongPointerFromPage from Environment. Make compatible with new BootChannel. 8-Jun-84 13:34:34	AWL         Modify for new BootChannel (muliple buffering).  First implementation does single buffering. 1-Nov-84 12:34:02	KEK       Modify for Dove: remove FloppyDLion specific code (rename from BootChannelFloppyDLion.mesa, remove all stuff copied from SA800HeadDlion & FloppyDiskFace).  Much adapted from BootChannelDisk (incl double buffering?)... 7-Dec-84 16:05:05	KEK       convert to FloppyDiskFace.21-Mar-85 16:08:49	CAJ    Look for device types from DeviceTypesExtras.Floppy; add delay to Poll loop. 2-May-85 14:21:13	CAJ    Correct length for Ops operation allocation; replace straight a4 with   FloppyDiskFace.operationAlignment. 4-Feb-87  7:40:26	CAJ    Expand devices covered to include DeviceTypesExtras4.ExtendedFloppy. 6-Mar-87  7:15:07	CAJ    Modify NewAddress to increment the disk address rather than convert to page number, increment, and reconvert to disk address, to avoid CARDINAL overflow on new larger media (like floppy tape).  Set maxTries from 3 to 128 (magic number explained) and replace resubmitting of operation on error with GermWorldError.  2-Apr-87 12:45:07	CAJ    Put up retention MP code if error is otherError and device is floppy tape. 28-Apr-87  8:09:56	CAJ    Add buffer arg to Create for BootChannel change. 7-Nov-89 10:29:24 - TSS - Added BootFileNotOnThisFloppy[] proc so that we could use a two floppy approach for boot/ucode/germ file combos which are too big to fit on a 360KB floppy. Strategy is to have germ only on floppy #1, ucode and bootfile on floppy #2. The mpcode indicates the user should now put in the floppy #2. 27-Nov-89 15:30:58 - TSS - Finalize changes for Helen. Modify GetBootfileFromAnotherFloppy[] only.    
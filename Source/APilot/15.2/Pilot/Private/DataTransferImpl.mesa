-- Copyright (C) 1986, 1987  by Xerox Corporation. All rights reserved. -- DataTransferImpl.mesa        7-Jan-87 15:05:07 by RRR -- This module implements the various data transfer operations used by Pilot.-- The MONITOR protects the buffer used for scratch storage.-- Since data transfer operations are not expected to be done often through this-- module, this is not expected to be a serious performance bottleneck.DIRECTORY  DataTransfer USING [DataStatus, DiskStatus],  DiskBackingStore USING [ChannelHandle, GetDiskChannel, ReportErrorToDebugger],  DiskChannel USING [    defaultTries, DiskPageNumber, DoIO, goodCompletion, Handle, IORequest,    IOStatus, Tries],  Environment USING [PageNumber, wordsPerPage],  File USING [PageCount, PageNumber],  FileBasicsPerf USING [HistIndex],  FileBasicsPrograms USING [],  KernelFile USING [Descriptor, PageGroup],  KernelSpaceUsage USING [miscFileBasics],  PhysicalVolumeFormat USING [PageNumber],  RuntimeInternal USING [Bug],  Space USING [LongPointerFromPage],  StoragePrograms USING [AllocateVM],  VM USING [Interval, Map, Unmap],  VolTable USING [FindSV, SVDesc],  Volume USING [ID, PageNumber];DataTransferImpl: MONITOR  IMPORTS    DiskBackingStore, DiskChannel, RuntimeInternal,    Space, StoragePrograms, VM, VolTable  EXPORTS FileBasicsPerf, FileBasicsPrograms, DataTransfer =  BEGIN  -- Types and Constants.  OpType: TYPE = {  -- order of items is important here!    -- Operations for which useSamePage = TRUE:    readData, verifyLabel, verifyData, writeDataSamePage,    -- Operations for which useSamePage = FALSE:    writeData};  Operation: TYPE = RECORD [    memoryPage: Environment.PageNumber,    body: SELECT operation: OpType FROM      readData => [        volumePage: Volume.PageNumber, vID: Volume.ID],      verifyData,      writeData, writeDataSamePage => [        fileP: POINTER TO READONLY KernelFile.Descriptor,        groupPtr: POINTER TO READONLY KernelFile.PageGroup],      ENDCASE];  -- MONITOR DATA:  -- The vars. buffer and bufferPtr define the buffer into which and  -- out of which I/O occurs. logging and hist are exported to FileBasicsPerf.  buffer: Environment.PageNumber;  -- length = 1 page.  logging: PUBLIC --FileBasicsPerf.-- BOOLEAN ¬ FALSE;  -- (altered only by debugger)  hist: PUBLIC --FileBasicsPerf.-- ARRAY FileBasicsPerf.HistIndex OF LONG    CARDINAL ¬ ALL[0];  -- Errors and Bugs  BugType: TYPE = {    cleanupNotImplemented, impossibleEndcase, invalidChannel, invalidDriveState, noSuchSubvolume};  InitDataTransfer: PUBLIC --FileBasicsPrograms.-- PROCEDURE =    BEGIN    buffer ¬ StoragePrograms.AllocateVM[      count: 1, location: hyperspace, usage: KernelSpaceUsage.miscFileBasics,      mapping: partiallyOrSometimesMapped];    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Public Procedures Exported to DataTransfer:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    DiskStatusToDataStatus: PUBLIC PROCEDURE [diskStatus: DataTransfer.DiskStatus]    RETURNS [dataStatus: DataTransfer.DataStatus] =    BEGIN    RETURN[      SELECT diskStatus.status FROM        goodCompletion => valid,        notReady, recalibrateError, seekTimeout, headerNotFound, overrunError,          writeFault, memoryError, memoryFault => diskError,        inProgress, headerCRCError, dataCRCError,	  dataVerifyError, clientError, operationReset, otherError => invalid,        ENDCASE => BugV[impossibleEndcase]];    END;  RealReadData: PUBLIC PROCEDURE [    volume: Volume.ID, volumePage: Volume.PageNumber,    memoryPage: Environment.PageNumber, handleErrors: BOOLEAN]    RETURNS [status: DataTransfer.DiskStatus] =    BEGIN    op: Operation ¬ [memoryPage, readData[volumePage, volume]];    status ¬ Perform[@op, handleErrors].status    END;  --RealReadData--  ReadPVData: PUBLIC ENTRY PROCEDURE [    channel: DiskChannel.Handle, pvPage: PhysicalVolumeFormat.PageNumber,    memoryPage: Environment.PageNumber]    RETURNS [status: DiskChannel.IOStatus] =    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    status ¬ SubmitRequest[      op: readData, tries: DiskChannel.defaultTries, count: 1, diskPage: pvPage,      memoryPage: memoryPage, diskChannel: channel, handleErrors: FALSE].status;    END;  --ReadPVData--  RealVerifyData: PUBLIC ENTRY PROCEDURE [    file: KernelFile.Descriptor, group: KernelFile.PageGroup,    handleErrors: BOOLEAN]    RETURNS [countValid: File.PageCount, status: DataTransfer.DiskStatus] =    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    op: Operation ¬ [buffer, verifyData[@file, @group]];    ResidentMap[[buffer, 1]];    [status, countValid] ¬ Perform[      op: @op,      handleErrors: handleErrors,      tries: DiskChannel.defaultTries];    VM.Unmap[buffer];    END;  --RealVerifyData--          RealWriteData: PUBLIC ENTRY PROCEDURE [    file: KernelFile.Descriptor, group: KernelFile.PageGroup, data: VM.Interval,    handleErrors: BOOLEAN]    RETURNS [status: DataTransfer.DiskStatus] =    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    op: Operation;    groupRemaining: KernelFile.PageGroup ¬ group;    IF data.count > 0 THEN      BEGIN  -- Use however much data the client supplied..      groupRemaining.nextFilePage ¬ MIN[        group.nextFilePage, group.filePage + data.count];      op ¬ [data.page, writeData[@file, @groupRemaining]];      status ¬ Perform[        op: @op, handleErrors: handleErrors].status;      IF status # DiskChannel.goodCompletion THEN RETURN;      groupRemaining ¬ [        filePage: group.filePage + data.count,        volumePage: group.volumePage + data.count,        nextFilePage: group.nextFilePage];      END;    -- All pages yet to be written are filled with zeroes:    IF groupRemaining.filePage < groupRemaining.nextFilePage THEN      BEGIN      bufferWords: LONG POINTER TO ARRAY [0..Environment.wordsPerPage) OF WORD =        Space.LongPointerFromPage[buffer];      ResidentMap[[buffer, 1]];      bufferWords­ ¬ ALL[0];      op ¬ [buffer, writeDataSamePage[@file, @groupRemaining]];      status ¬ Perform[        op: @op, handleErrors: handleErrors].status;      VM.Unmap[buffer];      END;    END;  --RealWriteData--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Support and other miscellaneous PROCEDUREs:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Bug: PROCEDURE [b: BugType] = {RuntimeInternal.Bug[b]};    BugV: PROCEDURE [b: BugType] RETURNS [UNSPECIFIED] = {    Bug[impossibleEndcase]; RETURN[0]};  Log: PROCEDURE [size: LONG CARDINAL] =    -- The logging boolean must be true for this to function (see above).    BEGIN    FOR i: CARDINAL IN FileBasicsPerf.HistIndex DO      IF size = 0 THEN {hist[i] ¬ hist[i] + 1; EXIT} ELSE size ¬ size/2; ENDLOOP    END;  Perform: PROCEDURE [    op: POINTER TO READONLY Operation, handleErrors: BOOLEAN,    tries: DiskChannel.Tries ¬ DiskChannel.defaultTries]    RETURNS [status: DataTransfer.DiskStatus, countValid: File.PageCount] =    -- Performs the requested operation. The returned countValid    -- is the number of pages sucessfuly transferred.    BEGIN    vID: Volume.ID;    found: BOOLEAN;    sv: VolTable.SVDesc;    count: File.PageCount;    vPage: Volume.PageNumber;    ioStatus: DiskChannel.IOStatus;    channel: DiskBackingStore.ChannelHandle;    WITH o: op SELECT FROM      readData => {        vPage ¬ o.volumePage; vID ¬ o.vID; count ¬ 1};      verifyData, writeData, writeDataSamePage =>        BEGIN        vID ¬ o.fileP.volumeID;        vPage ¬ o.groupPtr.volumePage;        count ¬ o.groupPtr.nextFilePage - o.groupPtr.filePage;  --      op.label.fileID ¬ [volumeRelative[fileID: o.fileP.fileID]];  --      PilotDisk.SetLabelFilePage[op.label, o.groupPtr.filePage];  --      op.label.type ¬ o.fileP.type;  --      op.label.bootChainLink ¬ link;  --      op.label.temporary ¬  --        (IF o.groupPtr.filePage = 0 THEN o.fileP.temporary ELSE FALSE);        END;      ENDCASE => Bug[impossibleEndcase];    -- Now find the correct SV and submit the request    [found, channel] ¬ VolTable.FindSV[vID, vPage, @sv];    IF ~found THEN Bug[noSuchSubvolume];    [ioStatus, countValid] ¬ SubmitRequest[      op: op.operation, tries: tries, count: count,      diskPage: sv.pvPageOfSV + vPage,      memoryPage: op.memoryPage, handleErrors: handleErrors,      diskChannel: DiskBackingStore.GetDiskChannel[channel]];    WITH s: ioStatus SELECT FROM      disk => status ¬ s;      invalidDriveState => Bug[invalidDriveState];      invalidChannel => Bug[invalidChannel];      ENDCASE => Bug[impossibleEndcase];    END;  ResidentMap: PROCEDURE [mapUnit: VM.Interval] = INLINE    BEGIN    VM.Map[      interval: mapUnit, transferProc: NIL, backingStoreRuns: NIL,      swapUnits: [unitary[]], life: dead, swappability: resident];    END;  SubmitRequest: PROCEDURE [    op: OpType, tries: DiskChannel.Tries ¬ DiskChannel.defaultTries,    count: File.PageCount, diskPage: DiskChannel.DiskPageNumber,    memoryPage: Environment.PageNumber, diskChannel: DiskChannel.Handle,    handleErrors: BOOLEAN]    RETURNS [status: DiskChannel.IOStatus, countValid: File.PageCount] =    BEGIN    request: DiskChannel.IORequest;    IF logging THEN Log[count];    DO  --until successful or client will accept errors--      request ¬ [        diskPage: diskPage, memoryPage: memoryPage, tries: tries,        count: count, useSamePage: op IN [readData..writeDataSamePage],        command:        SELECT op FROM	  verifyData, readData         => read,          writeData, writeDataSamePage => write,          ENDCASE => BugV[impossibleEndcase]];      [status, countValid] ¬ DiskChannel.DoIO[diskChannel, @request];      WITH boundStatus: status SELECT FROM        invalidChannel => Bug[invalidChannel];        invalidDriveState => Bug[invalidDriveState];        disk =>	  IF boundStatus.status = goodCompletion OR NOT handleErrors THEN EXIT          ELSE DiskBackingStore.ReportErrorToDebugger[	    diskChannel, @request, countValid, boundStatus.status];        ENDCASE => Bug[impossibleEndcase];      ENDLOOP;   -- Loop to try again.    --ASSERT: Finished sucessfully or    --  <finished in error but client said I should not handle errors>.    END;  END.LOG 8-Jul-86 17:19:05   RSV      Created for labelessness from LabelTransferImpl.  Got rid of everything referencing labels.  Added procedure ReadPVData.  Changed PilotDiskFace.Command variables.  Changed name of DiskStatusToLabelStatus to DiskStatusToDataStatus 7-Jan-87 15:05:07 RRR   Corrections necessary to move root page without changing lv numbering.
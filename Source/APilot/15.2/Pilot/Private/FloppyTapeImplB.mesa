-- Copyright (C) 1987, 1988  by Xerox Corporation.  All rights reserved. -- FloppyTapeImplB.mesa          26-Dec-88 14:17:33 by RSVDIRECTORY  Environment USING [    Base, bytesPerPage, first64K, PageFromLongPointer, wordsPerPage],  File USING [File, nullFile],  FloppyChannel USING [    DiskAddress, Error, Handle, «Nop,» nullHandle, ReadSectors, Status,    WriteSectors],  FloppyDiskFace USING [    DeviceHandle, DiskAddress, operationAlignment, operationBlockLength,    OperationPtr, Status, SuggestedTries],  FloppyTape USING [    ByteCount, ByteOffset, Drive, Error, ErrorType, FileHandle, FileID,    maxBytesInName, nullFileID, nullSectorNumber, SectorNumber,    VolumeHandle],  FloppyTapeFormat USING [    BadSectorList, badSectorListSize, badSectorListSector, BadSectorType,    BootPageDiskAddress, BootPageFormat, DiskAddressToSector,    firstDataAddress, FloppyTapeSeal, FloppyTapeVersion, MarkerPage,    MarkerSeal, MarkerPageVersion, maxNumberBadSectors, PackBadSectorNumber,    RootPage, rootPageDiskAddress, SectorToDiskAddress],  FloppyTapeInternal USING [    bufferLock, BytesToPages, DiskChanged, DoOperation, FilterStatus,    ForceOutBuffers, GetCountDone, GetWriteProtectStatus, InternalIOError,    MarkBadSectorEntryInternal, minNumTicks, operationLock, OperationProc,    residentBufferSize, verifyBufferSize, volumeDesc, volumeDescLock,    WordsToPages],  PilotDiskFace USING [DiskAddress],  Process USING [Pause],  ResidentHeap USING [FreeNode, MakeNode],  RuntimeInternal USING [Bug],  Space USING [    Allocate, Deallocate, Error, Kill, InsufficientSpace, Interval, Map,    nullInterval, PageCount, SwapUnitOption, Unmap],  SpecialFloppyChannel USING [DoDirectIO],  SpecialFloppyChannelExtras USING [GetDeviceHandle, Retention],  SpecialFloppyTape USING [BootFilePointer, nullBootFilePointer],  SpecialFloppyTapeFace USING [LogicalAddressToPhysicalAddress],  VM USING [ScratchMap, Unmap],  Zone USING [Status];FloppyTapeImplB: MONITOR LOCKS ml USING ml: LONG POINTER TO MONITORLOCK  IMPORTS     Environment, FloppyChannel, FloppyDiskFace, FloppyTape, FloppyTapeInternal,    FloppyTapeFormat, Process, ResidentHeap, RuntimeInternal, Space,    SpecialFloppyChannel, SpecialFloppyChannelExtras, SpecialFloppyTape,    SpecialFloppyTapeFace, VM  EXPORTS FloppyTapeInternal, SpecialFloppyTape =  BEGIN  -- types --  VolumeHandleInternal: TYPE = RECORD [    deviceIndex: FloppyTape.Drive, changeCount: CARDINAL];    -- must be the same as FloppyTapeImplA$VolumeHandle.      BugType: TYPE = {floppyIocbAllocError, floppyIocbFreeError};  -- variables --  markerPageSize: CARDINAL =    CARDINAL[FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.MarkerPage]]];  -- procedures --  AllocIOCB: PUBLIC --FloppyTapeInternal-- PROCEDURE [    wds: CARDINAL] RETURNS [p: LONG POINTER] = {    status: Zone.Status;    gsp: Environment.Base RELATIVE POINTER;    IF wds = 0 THEN RETURN[NIL];    [gsp, status] ¬ ResidentHeap.MakeNode[      n: wds, alignment: FloppyDiskFace.operationAlignment];    IF status # okay THEN Bug[floppyIocbAllocError];    RETURN[@Environment.first64K[gsp]]};  Bug: PROCEDURE [bugType: BugType] = {RuntimeInternal.Bug[bugType]};  CheckBadSectorList: PUBLIC --FloppyTapeInternal-- PROCEDURE [    badSectorList: FloppyTapeFormat.BadSectorList, countBadSectors: CARDINAL,    maxSectorAvailable: FloppyTape.SectorNumber] =    BEGIN    badSector: FloppyTape.SectorNumber;    temp: FloppyTape.SectorNumber ¬ FloppyTape.nullSectorNumber;    FOR i: CARDINAL IN [0..countBadSectors) DO      badSector ¬         FloppyTapeFormat.PackBadSectorNumber[          badSectorList[i].badSectorLow,	  badSectorList[i].badSectorHigh];      IF badSector = FloppyTape.nullSectorNumber OR         badSector > maxSectorAvailable OR	temp >= badSector THEN ERROR FloppyTape.Error[notFormatted];      temp ¬ badSector;      ENDLOOP;    END;  --CheckBadSectorList--  CheckBootFile: PUBLIC --SpecialFloppyTape-- PROCEDURE [    file: FloppyTape.FileHandle] =    BEGIN    volume: FloppyTape.VolumeHandle ¬ file.volume;    fileID: FloppyTape.FileID ¬ file.file;    requestedSize: Space.PageCount = markerPageSize;    buffer: Space.Interval ¬ Space.nullInterval;    CheckBootFileEntry: ENTRY PROCEDURE [      ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND =>        buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];      buffer ¬ CreateBuffer[requestedSize];      IF buffer.count # requestedSize THEN ERROR;      CheckBootFileInternal[fileID, buffer];      buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];      END;  --CheckBootFileEntry--    CheckBootFileMain: FloppyTapeInternal.OperationProc =      BEGIN       ValidateHandle[volume];      IF ~FloppyTapeInternal.GetWriteProtectStatus[        @FloppyTapeInternal.volumeDescLock] THEN        FloppyTapeInternal.ForceOutBuffers[@FloppyTapeInternal.bufferLock];      CheckBootFileEntry[@FloppyTapeInternal.volumeDescLock];      END;  --CheckBootFileMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, CheckBootFileMain, checkBootFile];    END;  --CheckBootFile--  CheckBootFileInternal: INTERNAL PROCEDURE [    file: FloppyTape.FileID, buffer: Space.Interval] =    -- buffer must be at least of SIZE[FloppyTapeFormat.MarkerPage] words    BEGIN    markerPage: LONG POINTER TO FloppyTapeFormat.MarkerPage;    IF file # FloppyTape.nullFileID THEN      BEGIN      markerPage ¬ LOOPHOLE[buffer.pointer];      -- loop is a hack to try to avoid getting fileNotFound when stream      -- select fails....I'm just letting fileNotFound fly by after two tries.      FOR i: CARDINAL IN [0..2) DO	ReadMarkerPage[markerPage, file !	  FloppyTapeInternal.DiskChanged => 	    ERROR FloppyTape.Error[invalidVolumeHandle]];	CheckMarkerPage[markerPage, file !	  FloppyTape.Error =>	    IF i = 0 THEN	      BEGIN	      status: FloppyChannel.Status;	      IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN		FloppyTapeInternal.volumeDesc.notifyClientOnRetention[		  FloppyTapeInternal.volumeDesc.drive, start];	      status ¬ SpecialFloppyChannelExtras.Retention[		FloppyTapeInternal.volumeDesc.fcHandle];	      IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN		FloppyTapeInternal.volumeDesc.notifyClientOnRetention[		  FloppyTapeInternal.volumeDesc.drive, stop];	      IF status # goodCompletion THEN		ERROR FloppyTape.Error[hardwareError];	      LOOP;	      END]; 	    -- may raise fileNotFound	EXIT; -- if we got to here, we read the page correctly        ENDLOOP;  --hack--      IF CountBadPagesInFile[RealFileIDLoc[file].sector,	markerPage.logicalSize].countBadPages > LONG[0] THEN	ERROR FloppyTape.Error[badSectors];      END;    END;  --CheckBootFileInternal--  CheckMarkerPage: PUBLIC --FloppyTapeInternal-- PROCEDURE [    markerPage: LONG POINTER TO FloppyTapeFormat.MarkerPage,    fileID: FloppyTape.FileID] =    BEGIN    IF markerPage.seal # FloppyTapeFormat.MarkerSeal OR      markerPage.version # FloppyTapeFormat.MarkerPageVersion OR      markerPage.file # fileID THEN ERROR FloppyTape.Error[fileNotFound];    END;  CheckRootPage: PUBLIC --FloppyTapeInternal-- PROCEDURE [    rootPage: LONG POINTER TO FloppyTapeFormat.RootPage] =    BEGIN    IF rootPage.seal # FloppyTapeFormat.FloppyTapeSeal OR      rootPage.version # FloppyTapeFormat.FloppyTapeVersion OR      rootPage.labelSize > FloppyTape.maxBytesInName OR      rootPage.numberOfBadPages > FloppyTapeFormat.maxNumberBadSectors OR      rootPage.numberOfStreams = 0 OR      rootPage.numberOfTracks = 0 OR      rootPage.sectorsPerTrack = 0 THEN ERROR FloppyTape.Error[notFormatted];    IF rootPage.changing THEN ERROR FloppyTape.Error[needsScavenging];    END;  --CheckRootPage--  CloseVolumeInternal: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE =    BEGIN    -- Must have monitor lock while operating here    -- Do not increment volumeDesc.changeCount here, otherwise you can't close    --   and already closed volumeHandle.    -- Do not deallocate rootPage and badSectorList buffers.    FloppyTapeInternal.volumeDesc.notifyClientOnRetention ¬ NIL;    FloppyTapeInternal.volumeDesc.open ¬ FALSE;    IF ~FloppyTapeInternal.volumeDesc.writeProtected THEN      BEGIN      VM.Unmap[Environment.PageFromLongPointer[        FloppyTapeInternal.volumeDesc.residentBuffer1] !        Space.Error => CONTINUE];      VM.Unmap[Environment.PageFromLongPointer[        FloppyTapeInternal.volumeDesc.residentBuffer2] !        Space.Error => CONTINUE];      VM.Unmap[Environment.PageFromLongPointer[        FloppyTapeInternal.volumeDesc.verifyBuffer] !	Space.Error => CONTINUE];      Space.Deallocate[[FloppyTapeInternal.volumeDesc.residentBuffer1,        FloppyTapeInternal.residentBufferSize] !	  Space.Error => CONTINUE];      Space.Deallocate[[FloppyTapeInternal.volumeDesc.residentBuffer2,        FloppyTapeInternal.residentBufferSize] !	  Space.Error => CONTINUE];      Space.Deallocate[[FloppyTapeInternal.volumeDesc.verifyBuffer,        FloppyTapeInternal.verifyBufferSize] !	  Space.Error => CONTINUE];      END;    FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.nullHandle;    -- use Space.Kills because they are faster    Space.Kill[[      FloppyTapeInternal.volumeDesc.rootPage,      FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.RootPage]] +        FloppyTapeFormat.badSectorListSize] !      Space.Error => CONTINUE];    END;  --CloseVolumeInternal--  ConvertToStreamAddr: PUBLIC --FloppyTapeinternal-- INTERNAL PROCEDURE [    bootFile: SpecialFloppyTape.BootFilePointer]     RETURNS [streamAddr: PilotDiskFace.DiskAddress] =    BEGIN    channelAddr: FloppyChannel.DiskAddress;    sector: FloppyTape.SectorNumber;    IF bootFile = SpecialFloppyTape.nullBootFilePointer THEN      RETURN[[cylinder: 0, head: 0, sector: 0]];    sector ¬ RealFileIDLoc[bootFile.file].sector +      FloppyTapeInternal.BytesToPages[bootFile.offset] +       FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.MarkerPage]];    channelAddr ¬ FloppyTapeFormat.SectorToDiskAddress[sector,      FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,      FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,      FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack];    streamAddr ¬ LOOPHOLE[SpecialFloppyTapeFace.LogicalAddressToPhysicalAddress[      LOOPHOLE[channelAddr, FloppyDiskFace.DiskAddress]]];    «[streamAddr.head, streamAddr.cylinder] ¬      Inline.DIVMOD[channelAddr.cylinder, FloppyTapeFormat.tracksPerStream];    streamAddr.head ¬ streamAddr.head + 1;    streamAddr.sector ¬ channelAddr.sector;»    END;  --ConvertToStreamAddr--  CountBadPagesInFile: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE [    firstPage: FloppyTape.SectorNumber, logicalSize: FloppyTape.ByteCount]    RETURNS [countBadPages: LONG CARDINAL] =    BEGIN    lastPage: FloppyTape.SectorNumber ¬      firstPage + FloppyTapeInternal.BytesToPages[logicalSize];    badSector: FloppyTape.SectorNumber ¬ 0;    i: CARDINAL;    countBadPages ¬ 0;    FOR i IN [0..FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages) DO      badSector ¬ FloppyTapeFormat.PackBadSectorNumber[	FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorLow,	FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorHigh];      IF badSector >= firstPage THEN EXIT;      ENDLOOP;    IF badSector < firstPage THEN RETURN;  -- countBadPages = 0    WHILE i < FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages AND      FloppyTapeFormat.PackBadSectorNumber[	FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorLow,	FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorHigh] <= lastPage      DO      countBadPages ¬ countBadPages + 1;      i ¬ i + 1;      lastPage ¬ lastPage + 1;      ENDLOOP;    END;  --CountBadPagesInFile--          ConvertFileIDToSector: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE [    fileID: FloppyTape.FileID]    RETURNS [FloppyTape.SectorNumber] =     BEGIN    RETURN[FloppyTapeFormat.DiskAddressToSector[      LOOPHOLE[fileID],      FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,       FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,      FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack]];    END;  --ConvertFileIDToSector--      ConvertSectorToFileID: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE [    sector: FloppyTape.SectorNumber]     RETURNS [FloppyTape.FileID] =     BEGIN    RETURN[LOOPHOLE[FloppyTapeFormat.SectorToDiskAddress[sector,      FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,      FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,      FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack]]];    END;  --ConvertSectorToFileID--  CreateBuffer: PUBLIC --FloppyTapeInternal-- PROCEDURE [size: Space.PageCount]    RETURNS [buffer: Space.Interval] =    BEGIN    uniformSize: Space.SwapUnitOption ¬ [unitary[]];    buffer ¬ Space.nullInterval;    IF size = 0 THEN RETURN;    buffer ¬ Space.Map[window: [File.nullFile, 0, size], swapUnits: uniformSize !      Space.InsufficientSpace => CONTINUE; --it is possible to get InsufficientSpace (see PPM), but what action do we want to take?      Space.Error => CONTINUE];  --what action do we want to take?    END;  --CreateBuffer--  CreateResidentBuffer: PUBLIC --FloppyTapeInternal-- PROCEDURE [    size: Space.PageCount]    RETURNS [buffer: Space.Interval] =    BEGIN    buffer ¬ Space.nullInterval;    IF size = 0 THEN RETURN;    buffer ¬ Space.Allocate[size !       Space.InsufficientSpace => GO TO return;  --what action (try something smaller)?      Space.Error => GO TO return];  --?    VM.ScratchMap[      [Environment.PageFromLongPointer[buffer.pointer], buffer.count]];      -- what errors can VM.ScratchMap raise?    EXITS      return => RETURN[Space.nullInterval];    END;  --CreateResidentBuffer--  FreeIOCB: PUBLIC --FloppyTapeInternal-- PROCEDURE [    p: LONG POINTER] RETURNS [LONG POINTER] = {    status: Zone.Status;    gsp: Environment.Base RELATIVE POINTER ¬      LOOPHOLE[CARDINAL[p - Environment.first64K]];    status ¬ ResidentHeap.FreeNode[p: gsp, location: first64K];    IF status # okay THEN Bug[floppyIocbFreeError];    RETURN[NIL]};  GetBootFiles: PUBLIC --SpecialFloppyTape-- PROCEDURE [    volume: FloppyTape.VolumeHandle]    RETURNS [initialMicrocode, pilotMicrocode, diagnosticMicrocode, germ,    pilotBootFile: SpecialFloppyTape.BootFilePointer] =    BEGIN    GetBootFilesInternal: ENTRY PROCEDURE [      ml: LONG POINTER TO MONITORLOCK] =      BEGIN      IF ~FloppyTapeInternal.volumeDesc.open THEN         RETURN WITH ERROR FloppyTape.Error[invalidVolumeHandle];      initialMicrocode ¬ FloppyTapeInternal.volumeDesc.rootPage.initialMicrocode;      pilotMicrocode ¬ FloppyTapeInternal.volumeDesc.rootPage.pilotMicrocode;      diagnosticMicrocode ¬        FloppyTapeInternal.volumeDesc.rootPage.diagnosticMicrocode;      germ ¬ FloppyTapeInternal.volumeDesc.rootPage.germ;      pilotBootFile ¬ FloppyTapeInternal.volumeDesc.rootPage.pilotBootFile;      END;  --GetBootFilesInternal--    GetBootFilesMain: FloppyTapeInternal.OperationProc =      BEGIN      ValidateHandle[volume];      GetBootFilesInternal[@FloppyTapeInternal.volumeDescLock];      END;  --GetBootFilesMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, GetBootFilesMain, getBootFiles];    END;  --GetBootFiles--  GetDiskAddress: PUBLIC --SpecialFloppyTape-- PROCEDURE [    file: FloppyTape.FileHandle, byteOffset: FloppyTape.ByteOffset]    RETURNS [diskAddress: FloppyChannel.DiskAddress] =    BEGIN    volume: FloppyTape.VolumeHandle ¬ file.volume;    fileID: FloppyTape.FileID ¬ file.file;    GetDiskAddressInternal: ENTRY PROCEDURE [      ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      buffer: Space.Interval ¬ Space.nullInterval;      startSector: FloppyTape.SectorNumber;      actualSector: FloppyTape.SectorNumber;      requestedSize: Space.PageCount;      savedError: FloppyTape.ErrorType;      BEGIN      ENABLE        BEGIN	FloppyTapeInternal.InternalIOError =>	  {savedError ¬ needsScavenging; GO TO otherError};	FloppyTapeInternal.DiskChanged =>	  {savedError ¬ invalidVolumeHandle; GO TO otherError};	UNWIND => buffer.pointer ¬ Space.Unmap[buffer.pointer !	            Space.Error => CONTINUE];	END;      IF ~FloppyTapeInternal.volumeDesc.open THEN         RETURN WITH ERROR FloppyTape.Error[invalidVolumeHandle];      requestedSize ¬ markerPageSize;      buffer ¬ CreateBuffer[requestedSize];      IF buffer.count # requestedSize THEN ERROR;      -- loop is a hack to try to avoid getting fileNotFound when stream      -- select fails      FOR i: CARDINAL IN [0..2) DO	ReadMarkerPage[buffer.pointer, fileID !	  FloppyTape.Error => {savedError ¬ error; GO TO otherError}];	CheckMarkerPage[buffer.pointer, fileID !	  FloppyTape.Error => {	    IF i = 0 THEN	      BEGIN	      status: FloppyChannel.Status;	      IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN		FloppyTapeInternal.volumeDesc.notifyClientOnRetention[		  FloppyTapeInternal.volumeDesc.drive, start];	      status ¬ SpecialFloppyChannelExtras.Retention[		FloppyTapeInternal.volumeDesc.fcHandle];	      IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN		FloppyTapeInternal.volumeDesc.notifyClientOnRetention[		  FloppyTapeInternal.volumeDesc.drive, stop];	      IF status # goodCompletion THEN		ERROR FloppyTape.Error[hardwareError];	      LOOP;	      END	    ELSE	      savedError ¬ error; GO TO otherError}]; 	    -- may raise fileNotFound	EXIT; -- if we got to here, we read the page correctly	ENDLOOP;  --hack--      startSector ¬ ConvertFileIDToSector[fileID];      actualSector ¬        startSector +markerPageSize + FloppyTapeInternal.BytesToPages[byteOffset];      diskAddress ¬ FloppyTapeFormat.SectorToDiskAddress[        RealFileIDLoc[ConvertSectorToFileID[actualSector]].sector, 	FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,        FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack];      buffer.pointer ¬ Space.Unmap[buffer.pointer];      EXITS        otherError =>	  BEGIN	  buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];	  RETURN WITH ERROR FloppyTape.Error[savedError];	  END;      END;  --ENABLE--      END;  --GetDiskAddressInternal--    GetDiskAddressMain: FloppyTapeInternal.OperationProc =      BEGIN      ValidateHandle[volume];      GetDiskAddressInternal[@FloppyTapeInternal.volumeDescLock];      END;  --GetDiskAddressMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, GetDiskAddressMain, getDiskAddress];    END;  --GetDiskAddress--  IsPageBad: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE [    page: FloppyTape.SectorNumber] RETURNS [BOOLEAN] =    BEGIN    badSector: FloppyTape.SectorNumber;    FOR i:CARDINAL IN [0..FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages)      DO      badSector ¬         FloppyTapeFormat.PackBadSectorNumber[	  FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorLow,	  FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorHigh];      IF page = badSector THEN RETURN[TRUE];      IF page < badSector THEN RETURN[FALSE];      ENDLOOP;    RETURN[FALSE];    END;  --IsPageBad--  IsPageBadAndType: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE [    page: FloppyTape.SectorNumber]    RETURNS [badPage: BOOLEAN, type: FloppyTapeFormat.BadSectorType] =    BEGIN    badSector: FloppyTape.SectorNumber;    FOR i:CARDINAL IN [0..FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages)      DO      badSector ¬         FloppyTapeFormat.PackBadSectorNumber[	  FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorLow,	  FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorHigh];      IF (page = badSector) THEN	RETURN[	  TRUE, FloppyTapeInternal.volumeDesc.badSectorList[i].typeOfBadPage];      IF page < badSector THEN RETURN[FALSE, TRASH];      ENDLOOP;    RETURN[FALSE, TRASH];    END;  --IsPageBadAndType--  ReadBadSectorList: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE =    BEGIN ENABLE      FloppyChannel.Error => IF type = invalidHandle THEN GO TO diskChanged;    -- read bad sector list from tape into volumeDesc.badSectorList­    status: FloppyChannel.Status;    countDone: CARDINAL;    FOR i: CARDINAL IN [0..2) DO -- must try again if retention required      [status, countDone] ¬ FloppyChannel.ReadSectors[	FloppyTapeInternal.volumeDesc.fcHandle, 	FloppyTapeFormat.SectorToDiskAddress[	  FloppyTapeFormat.badSectorListSector, 	  FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	  FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks, 	  FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack],	FloppyTapeInternal.volumeDesc.badSectorList, 	FloppyTapeFormat.badSectorListSize, TRUE];      SELECT status FROM	goodCompletion => RETURN;	diskChange     => ERROR FloppyTapeInternal.DiskChanged;	notReady       => ERROR FloppyTape.Error[notReady];	cylinderError  => ERROR FloppyTape.Error[notFormatted];	recordNotFound => ERROR FloppyTape.Error[notFormatted];	deletedData    => ERROR FloppyTape.Error[needsScavenging];	headerError    => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataError      => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataLost       => ERROR FloppyTape.Error[needsScavenging];	writeFault     => ERROR FloppyTape.Error[writeInhibited];	otherError     => 	  BEGIN	  IF i = 0 THEN	    BEGIN	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, start];	    status ¬ SpecialFloppyChannelExtras.Retention[	      FloppyTapeInternal.volumeDesc.fcHandle];	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, stop];	    END;	  IF status # goodCompletion THEN ERROR FloppyTape.Error[hardwareError];	  END;	ENDCASE        => ERROR;      ENDLOOP;    EXITS      diskChanged => ERROR FloppyTapeInternal.DiskChanged;  -- what error goes to clients?    END;  --ReadBadSectorList--  ReadMarkerPage: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE [    buffer: LONG POINTER TO FloppyTapeFormat.MarkerPage,    fileID: FloppyTape.FileID] =    BEGIN ENABLE      FloppyChannel.Error => IF type = invalidHandle THEN GO TO diskChanged;    status: FloppyChannel.Status;    countDone: CARDINAL;    FOR i: CARDINAL IN [0..2) DO -- must try again if retention required      [status, countDone] ¬ FloppyChannel.ReadSectors[	FloppyTapeInternal.volumeDesc.fcHandle, RealFileIDLoc[fileID].da, buffer,        CARDINAL[FloppyTapeInternal.WordsToPages[SIZE[	  FloppyTapeFormat.MarkerPage]]], FALSE];      SELECT status FROM	goodCompletion => RETURN;	diskChange     => ERROR FloppyTapeInternal.DiskChanged;	notReady       => ERROR FloppyTape.Error[notReady];	cylinderError  => ERROR FloppyTape.Error[needsScavenging];	recordNotFound => ERROR FloppyTape.Error[needsScavenging];	deletedData    => ERROR FloppyTape.Error[needsScavenging];	headerError    => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataError      => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataLost       => ERROR FloppyTape.Error[needsScavenging];	writeFault     => ERROR FloppyTape.Error[writeInhibited];	otherError     => 	  BEGIN	  IF i = 0 THEN	    BEGIN	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, start];	    status ¬ SpecialFloppyChannelExtras.Retention[	      FloppyTapeInternal.volumeDesc.fcHandle];	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, stop];	    END;	  IF status # goodCompletion THEN ERROR FloppyTape.Error[hardwareError];	  END;	ENDCASE        => ERROR;      ENDLOOP;    EXITS      diskChanged => ERROR FloppyTapeInternal.DiskChanged;  -- what error goes to clients?    END;  --ReadMarkerPage--  ReadRootPage: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE  =    BEGIN ENABLE      FloppyChannel.Error => IF type = invalidHandle THEN GO TO diskChanged;    -- read root page from tape into volumeDesc.rootPage­    status: FloppyChannel.Status;    countDone: CARDINAL;    FOR i: CARDINAL IN [0..2) DO -- must try again if retention required      [status, countDone] ¬ FloppyChannel.ReadSectors[	FloppyTapeInternal.volumeDesc.fcHandle, 	FloppyTapeFormat.rootPageDiskAddress,	FloppyTapeInternal.volumeDesc.rootPage, 	CARDINAL[FloppyTapeInternal.WordsToPages[	  SIZE[FloppyTapeFormat.RootPage]]],	FALSE];      SELECT status FROM	goodCompletion => RETURN;	diskChange     => ERROR FloppyTapeInternal.DiskChanged;	notReady       => ERROR FloppyTape.Error[notReady];	cylinderError  => ERROR FloppyTape.Error[notFormatted];	recordNotFound => ERROR FloppyTape.Error[notFormatted];	deletedData    => ERROR FloppyTape.Error[needsScavenging];	headerError    => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataError      => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataLost       => ERROR FloppyTape.Error[needsScavenging];	writeFault     => ERROR FloppyTape.Error[writeInhibited];	otherError     => 	  BEGIN	  IF i = 0 THEN	    BEGIN	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, start];	    status ¬ SpecialFloppyChannelExtras.Retention[	      FloppyTapeInternal.volumeDesc.fcHandle];	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, stop];	    END;	  IF status # goodCompletion THEN ERROR FloppyTape.Error[hardwareError];	  END;	ENDCASE        => ERROR;      ENDLOOP;    EXITS      diskChanged => ERROR FloppyTapeInternal.DiskChanged;  -- what error goes to clients?    END;  --ReadRootPage--  ReadRootAndBadSectorList: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE  =    BEGIN ENABLE      FloppyChannel.Error => IF type = invalidHandle THEN GO TO diskChanged;    -- read root page from tape into volumeDesc.rootPage­    status: FloppyChannel.Status;    countDone: CARDINAL;    FOR i: CARDINAL IN [0..2) DO -- must try again if retention required      [status, countDone] ¬ FloppyChannel.ReadSectors[	FloppyTapeInternal.volumeDesc.fcHandle, 	FloppyTapeFormat.rootPageDiskAddress,	FloppyTapeInternal.volumeDesc.rootPage, 	CARDINAL[FloppyTapeInternal.WordsToPages[	  SIZE[FloppyTapeFormat.RootPage]]] + FloppyTapeFormat.badSectorListSize,	TRUE];      SELECT status FROM	goodCompletion => RETURN;	diskChange     => ERROR FloppyTapeInternal.DiskChanged;	notReady       => ERROR FloppyTape.Error[notReady];	cylinderError  => ERROR FloppyTape.Error[notFormatted];	recordNotFound => ERROR FloppyTape.Error[notFormatted];	deletedData    => ERROR FloppyTape.Error[needsScavenging];	headerError    => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataError      => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataLost       => ERROR FloppyTape.Error[needsScavenging];	writeFault     => ERROR FloppyTape.Error[writeInhibited];	otherError     => 	  BEGIN	  IF i = 0 THEN	    BEGIN	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, start];	    status ¬ SpecialFloppyChannelExtras.Retention[	      FloppyTapeInternal.volumeDesc.fcHandle];	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, stop];	    END;	  IF status # goodCompletion THEN ERROR FloppyTape.Error[hardwareError];	  END;	ENDCASE        => ERROR;      ENDLOOP;    EXITS      diskChanged => ERROR FloppyTapeInternal.DiskChanged;  -- what error goes to clients?    END;  --ReadRootAndBadSectorList--  RealFileIDLoc: PUBLIC -- FloppyTapeInternal -- INTERNAL PROCEDURE [    fileID: FloppyTape.FileID] RETURNS    [da: FloppyChannel.DiskAddress, sector: FloppyTape.SectorNumber] =    BEGIN    badSector: FloppyTape.SectorNumber;    firstDataSector: FloppyTape.SectorNumber ¬      FloppyTapeFormat.DiskAddressToSector[	FloppyTapeFormat.firstDataAddress,	FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack];    sector ¬ ConvertFileIDToSector[fileID];    FOR i:CARDINAL IN [0..FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages)      DO      badSector ¬ 	FloppyTapeFormat.PackBadSectorNumber[         FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorLow, 	 FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorHigh];      IF (badSector <= sector) THEN {        IF ((badSector >= firstDataSector) AND          (FloppyTapeInternal.volumeDesc.badSectorList[i].typeOfBadPage =	  beforeFileWritten))  OR  (badSector = sector) THEN sector ¬ sector + 1;        LOOP};      EXIT;  --exhausted list--      ENDLOOP;    da ¬ FloppyTapeFormat.SectorToDiskAddress[sector,     FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,     FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,     FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack];    END;  --RealFileIDLoc--  SetBootFiles: PUBLIC --SpecialFloppyTape-- PROCEDURE [    volume: FloppyTape.VolumeHandle, pilotMicrocode, diagnosticMicrocode, germ,    pilotBootFile: SpecialFloppyTape.BootFilePointer] =    BEGIN    buffer: Space.Interval ¬ Space.nullInterval;    requestedSize: Space.PageCount ¬ MAX[      FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.BootPageFormat]],      FloppyTapeInternal.WordsToPages[SIZE[FloppyTapeFormat.MarkerPage]]];    SetBootFilesInternal: ENTRY PROCEDURE [      ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      bootPage: LONG POINTER TO FloppyTapeFormat.BootPageFormat;      savedError: FloppyTape.ErrorType;      BEGIN        ENABLE	  BEGIN	  FloppyTapeInternal.DiskChanged => 	    {savedError ¬ invalidVolumeHandle; GO TO otherError};	  FloppyTapeInternal.InternalIOError => 	    {savedError ¬ badSectors; GO TO otherError};	  END;        IF ~FloppyTapeInternal.volumeDesc.open THEN         RETURN WITH ERROR FloppyTape.Error[invalidVolumeHandle];      IF FloppyTapeInternal.volumeDesc.writeProtected THEN         RETURN WITH ERROR FloppyTape.Error[writeInhibited];            buffer ¬ CreateBuffer[requestedSize];      IF buffer.count # requestedSize THEN ERROR;      CheckBootFileInternal[pilotMicrocode.file, buffer !         FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      CheckBootFileInternal[diagnosticMicrocode.file, buffer !         FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      CheckBootFileInternal[germ.file, buffer !         FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      CheckBootFileInternal[pilotBootFile.file, buffer !         FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      FloppyTapeInternal.volumeDesc.rootPage.pilotMicrocode ¬ pilotMicrocode;      FloppyTapeInternal.volumeDesc.rootPage.diagnosticMicrocode ¬        diagnosticMicrocode;      FloppyTapeInternal.volumeDesc.rootPage.germ ¬ germ;      FloppyTapeInternal.volumeDesc.rootPage.pilotBootFile ¬ pilotBootFile;            -- now reuse this buffer to do the boot page stuff      LOOPHOLE[buffer.pointer,	LONG POINTER TO ARRAY [0..Environment.wordsPerPage) OF CARDINAL]­ ¬	ALL[0];      bootPage ¬ LOOPHOLE[buffer.pointer];      bootPage.bootingInfo[hardMicrocode].da ¬        ConvertToStreamAddr[diagnosticMicrocode];      bootPage.bootingInfo[softMicrocode].da ¬        ConvertToStreamAddr[pilotMicrocode];      bootPage.bootingInfo[germ].da ¬ ConvertToStreamAddr[germ];      bootPage.bootingInfo[pilot].da ¬        IF pilotBootFile.file # FloppyTape.nullFileID THEN	  LOOPHOLE[FloppyTapeFormat.SectorToDiskAddress[	    RealFileIDLoc[pilotBootFile.file].sector +	    FloppyTapeInternal.BytesToPages[pilotBootFile.offset] +	      markerPageSize,	    FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	    FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	    FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack]]	  ELSE [cylinder: 0, head: 0, sector: 0];      WriteFloppyTape[buffer.pointer, FloppyTapeFormat.BootPageDiskAddress, 	requestedSize * Environment.wordsPerPage !	  FloppyTape.Error => {savedError ¬ error; GO TO otherError};	  FloppyTapeInternal.InternalIOError =>	    {savedError ¬ badTape; GO TO otherError}];      WriteRootPage[ !	FloppyTape.Error => {savedError ¬ error; GO TO otherError};	FloppyTapeInternal.InternalIOError => 	  {savedError ¬ badTape; GO TO otherError}];      EXITS	otherError => 	  BEGIN	  buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];	  RETURN WITH ERROR FloppyTape.Error[savedError];	  END;      END;  --ENABLE--      END;  --SetBootFilesInternal--    SetBootFilesMain: FloppyTapeInternal.OperationProc =      BEGIN      ValidateHandle[volume];      -- make sure all the bootfiles are on tape, before checking them      FloppyTapeInternal.ForceOutBuffers[@FloppyTapeInternal.bufferLock];      SetBootFilesInternal[@FloppyTapeInternal.volumeDescLock];      END;  --SetBootFilesMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, SetBootFilesMain, setBootFiles];    END;  --SetBootFiles--  ValidateHandle: PUBLIC --FloppyTapeInternal-- PROCEDURE [    volume: FloppyTape.VolumeHandle] =    BEGIN    volumeHandle: VolumeHandleInternal ¬ LOOPHOLE[volume];        CloseVolumeWithLock: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      {CloseVolumeInternal[]};     CheckChangeCount: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      BEGIN «ENABLE        FloppyChannel.Error => IF type = invalidHandle THEN GO TO diskChanged      status: FloppyChannel.Status;»      IF volumeHandle.changeCount ~= FloppyTapeInternal.volumeDesc.changeCount        THEN RETURN WITH ERROR FloppyTape.Error[invalidVolumeHandle];      «status ¬ FloppyChannel.Nop[FloppyTapeInternal.volumeDesc.fcHandle];      -- this NoOp could be expensive (causes ShoeShining.  May just want to let      -- it slide and catch the error later when using the floppy channel?      SELECT status FROM        goodCompletion => NULL;	writeFault     => NULL;	diskChange     => RETURN WITH ERROR FloppyTape.Error[invalidVolumeHandle];	ENDCASE        => RETURN WITH ERROR FloppyTape.Error[hardwareError];      EXITS        diskChanged => RETURN WITH ERROR FloppyTape.Error[invalidVolumeHandle];»      END;  --CheckChangeCount--    IF ~ValidDrive[volumeHandle.deviceIndex] THEN       ERROR FloppyTape.Error[invalidVolumeHandle];    CheckChangeCount[@FloppyTapeInternal.volumeDescLock];    END;  --ValidateHandle--  ValidDrive: PUBLIC --FloppyTapeInternal-- PROCEDURE [drive: FloppyTape.Drive]    RETURNS [exists: BOOLEAN] =    BEGIN    RETURN[      (FloppyTapeInternal.volumeDesc # NIL) AND      (drive = FloppyTapeInternal.volumeDesc.drive)];    END;  --ValidDrive--  WriteBadSectorList: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE =    BEGIN ENABLE      FloppyChannel.Error => IF type = invalidHandle THEN GO TO diskChanged;    -- write bad sector list from volumeDesc.badSectorList­ out to tape.    status: FloppyChannel.Status;    countDone: CARDINAL;    FOR i: CARDINAL IN [0..2) DO -- must try again if retention required      [status, countDone] ¬ FloppyChannel.WriteSectors[	FloppyTapeInternal.volumeDesc.fcHandle,	FloppyTapeFormat.SectorToDiskAddress[	  FloppyTapeFormat.badSectorListSector,	  FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	  FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks, 	  FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack],	FloppyTapeInternal.volumeDesc.badSectorList, 	FloppyTapeFormat.badSectorListSize, TRUE];      SELECT status FROM	goodCompletion => RETURN;	diskChange     => ERROR FloppyTapeInternal.DiskChanged;	notReady       => ERROR FloppyTape.Error[notReady];	cylinderError  => ERROR FloppyTape.Error[notFormatted];	recordNotFound => ERROR FloppyTape.Error[notFormatted];	deletedData    => ERROR FloppyTape.Error[needsScavenging];	headerError    => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataError      => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataLost       => ERROR FloppyTape.Error[needsScavenging];	writeFault     => ERROR FloppyTape.Error[writeInhibited];	otherError     =>  	  BEGIN	  IF i = 0 THEN	    BEGIN	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, start];	    status ¬ SpecialFloppyChannelExtras.Retention[	      FloppyTapeInternal.volumeDesc.fcHandle];	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, stop];	    END;	  IF status # goodCompletion THEN ERROR FloppyTape.Error[hardwareError];	  END;	ENDCASE        => ERROR;      ENDLOOP;    EXITS      diskChanged => ERROR FloppyTapeInternal.DiskChanged;    END;  --WriteBadSectorList--  WriteFloppyTape: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE [    buffer: LONG POINTER,    address: FloppyChannel.DiskAddress, count: FloppyTape.ByteCount] =    BEGIN ENABLE      FloppyChannel.Error => IF type = invalidHandle THEN GO TO diskChanged;    status: FloppyChannel.Status;    countDone: LONG CARDINAL;    countLeft: LONG CARDINAL ¬ FloppyTapeInternal.BytesToPages[count];    previouslyDone: LONG CARDINAL ¬ 0;    DO  -- write out the information      FOR i: CARDINAL IN [0..2) DO	[status, countDone] ¬ FloppyChannel.WriteSectors[	  FloppyTapeInternal.volumeDesc.fcHandle,	  address, buffer, CARDINAL[MIN[countLeft, LAST[CARDINAL]]], TRUE];	IF (status = otherError) AND (i = 0) THEN	  BEGIN	  IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	    FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	      FloppyTapeInternal.volumeDesc.drive, start];	  status ¬ SpecialFloppyChannelExtras.Retention[	    FloppyTapeInternal.volumeDesc.fcHandle];	  IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	    FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	      FloppyTapeInternal.volumeDesc.drive, stop];	  IF status # goodCompletion THEN ERROR FloppyTape.Error[hardwareError];	  END	ELSE EXIT;  -- otherwise, don't need to do WriteSectors again	ENDLOOP;  --FOR i: CARDINAL--      IF (status = goodCompletion) AND ((countLeft ¬ countLeft - countDone) = 0)        THEN RETURN;      previouslyDone ¬ previouslyDone + countDone;      SELECT status FROM        goodCompletion => NULL;	diskChange     => ERROR FloppyTapeInternal.DiskChanged;	notReady       => ERROR FloppyTape.Error[notReady];	cylinderError  => ERROR FloppyTapeInternal.InternalIOError[	                    previouslyDone * Environment.bytesPerPage];	recordNotFound => ERROR FloppyTapeInternal.InternalIOError[	                    previouslyDone * Environment.bytesPerPage];	deletedData    => ERROR FloppyTape.Error[needsScavenging];	headerError    => ERROR FloppyTapeInternal.InternalIOError[	                    previouslyDone * Environment.bytesPerPage];	dataError      => ERROR FloppyTapeInternal.InternalIOError[	                    previouslyDone * Environment.bytesPerPage];	dataLost       => ERROR FloppyTape.Error[needsScavenging];	writeFault     => ERROR FloppyTape.Error[writeInhibited];	otherError     => ERROR FloppyTape.Error[hardwareError];	ENDCASE        => ERROR;      address ¬ FloppyTapeFormat.SectorToDiskAddress[        (FloppyTapeFormat.DiskAddressToSector[address,	  FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	  FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	  FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack] + countDone),	FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack];      ENDLOOP;    EXITS      diskChanged => ERROR FloppyTapeInternal.DiskChanged;    END;  --WriteFloppyTape--  WriteMarkerPage: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE [    marker: LONG POINTER TO FloppyTapeFormat.MarkerPage,    fileID: FloppyTape.FileID] =    BEGIN ENABLE      FloppyChannel.Error => IF type = invalidHandle THEN GO TO diskChanged;    status: FloppyChannel.Status;    countDone: CARDINAL;    FOR i: CARDINAL IN [0..2) DO -- must try again if retention required      [status, countDone] ¬ FloppyChannel.WriteSectors[	FloppyTapeInternal.volumeDesc.fcHandle,	RealFileIDLoc[fileID].da, marker,        CARDINAL[FloppyTapeInternal.WordsToPages[SIZE[	  FloppyTapeFormat.MarkerPage]]],	FALSE];      SELECT status FROM	goodCompletion => RETURN;	diskChange     => ERROR FloppyTapeInternal.DiskChanged;	notReady       => ERROR FloppyTape.Error[notReady];	cylinderError  => ERROR FloppyTape.Error[needsScavenging];	recordNotFound => ERROR FloppyTape.Error[needsScavenging];	deletedData    => ERROR FloppyTape.Error[needsScavenging];	headerError    => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataError      => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataLost       => ERROR FloppyTape.Error[needsScavenging];	writeFault     => ERROR FloppyTape.Error[writeInhibited];	otherError     => 	  BEGIN	  IF i = 0 THEN	    BEGIN	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, start];	    status ¬ SpecialFloppyChannelExtras.Retention[	      FloppyTapeInternal.volumeDesc.fcHandle];	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, stop];	    END;	  IF status # goodCompletion THEN ERROR FloppyTape.Error[hardwareError];	  END;	ENDCASE        => ERROR;      ENDLOOP;    EXITS      diskChanged => ERROR FloppyTapeInternal.DiskChanged;  -- what error goes to clients?    END;  --WriteMarkerPage--  WriteRootPage: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE =    BEGIN ENABLE      FloppyChannel.Error => IF type = invalidHandle THEN GO TO diskChanged;    -- write tape root page from volumeDesc.rootPage­ out to tape    status: FloppyChannel.Status;    countDone: CARDINAL;    FOR i: CARDINAL IN [0..2) DO -- must try again if retention required      [status, countDone] ¬ FloppyChannel.WriteSectors[	-- get this tape address correct another way!	FloppyTapeInternal.volumeDesc.fcHandle,	FloppyTapeFormat.rootPageDiskAddress,	FloppyTapeInternal.volumeDesc.rootPage,	CARDINAL[FloppyTapeInternal.WordsToPages[	  SIZE[FloppyTapeFormat.RootPage]]],	FALSE];      SELECT status FROM	goodCompletion => RETURN;	diskChange     => ERROR FloppyTapeInternal.DiskChanged;	notReady       => ERROR FloppyTape.Error[notReady];	cylinderError  => ERROR FloppyTape.Error[notFormatted];	recordNotFound => ERROR FloppyTape.Error[notFormatted];	deletedData    => ERROR FloppyTape.Error[needsScavenging];	headerError    => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataError      => ERROR FloppyTapeInternal.InternalIOError[			    countDone * Environment.bytesPerPage];	dataLost       => ERROR FloppyTape.Error[needsScavenging];	writeFault     => ERROR FloppyTape.Error[writeInhibited];	otherError     => 	  BEGIN	  IF i = 0 THEN	    BEGIN	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, start];	    status ¬ SpecialFloppyChannelExtras.Retention[	      FloppyTapeInternal.volumeDesc.fcHandle];	    IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	      FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	        FloppyTapeInternal.volumeDesc.drive, stop];	    END;	  IF status # goodCompletion THEN ERROR FloppyTape.Error[hardwareError];	  END;	ENDCASE        => ERROR;      ENDLOOP;    EXITS      diskChanged => ERROR FloppyTapeInternal.DiskChanged;   -- what error does the client see?    END;  --WriteRootPage--  WriteWithSameData: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE [    buffer: LONG POINTER, address: FloppyChannel.DiskAddress,    count: FloppyTape.ByteCount] =    BEGIN ENABLE      FloppyChannel.Error => IF type = invalidHandle THEN GO TO diskChanged;          CleanUp: PROC = {      tempIocb ¬ FreeIOCB[tempIocb]};    -- buffer is a one page buffer, which is written to the disk count times    -- starting at address.    sectorCountThisRun: LONG CARDINAL;    currentSector: FloppyTape.SectorNumber ¬      FloppyTapeFormat.DiskAddressToSector[address,        FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack];    result: FloppyDiskFace.Status;    status: FloppyChannel.Status;    sectorCount: LONG CARDINAL ¬ FloppyTapeInternal.BytesToPages[count];    tempIocb: FloppyDiskFace.OperationPtr ¬      AllocIOCB[FloppyDiskFace.operationBlockLength];    deviceHandle: FloppyDiskFace.DeviceHandle =       SpecialFloppyChannelExtras.GetDeviceHandle[        FloppyTapeInternal.volumeDesc.fcHandle];          BEGIN  -- nested so we can clean up tempIocb      ENABLE UNWIND => CleanUp[];    WHILE (sectorCount >= 0) DO  -- write out the information      Process.Pause[FloppyTapeInternal.minNumTicks];  -- allow aborts      sectorCountThisRun ¬ MIN[sectorCount, LAST[CARDINAL]];      tempIocb­ ¬ [        device:   deviceHandle,	function: writeSector,	address:  LOOPHOLE[FloppyTapeFormat.SectorToDiskAddress[	  currentSector, FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	  FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	  FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack]],	dataPtr:  buffer,	incrementDataPointer: FALSE,	tries:    FloppyDiskFace.SuggestedTries[deviceHandle],	count:    CARDINAL[sectorCountThisRun]];      [result,,] ¬ SpecialFloppyChannel.DoDirectIO[tempIocb];            -- temporary hack for Daybreak Tapes due to a bug in the head.      «-- tempIocb got updated by head/handler      sectorCountThisRun ¬ sectorCountThisRun - tempIocb.count;»      IF (result # goodCompletion) THEN         sectorCountThisRun ¬	  FloppyTapeInternal.GetCountDone[currentSector, tempIocb]      ELSE        sectorCountThisRun ¬ sectorCountThisRun - tempIocb.count;            sectorCount ¬ sectorCount - sectorCountThisRun;      currentSector ¬ currentSector + sectorCountThisRun;      IF (sectorCountThisRun = LAST[CARDINAL]) AND        (result = goodCompletion) THEN LOOP;      status ¬ FloppyTapeInternal.FilterStatus[result];      -- so if we are here, we are done (result = goodCompletion), the      -- tape needs retentioning (result = otherError), we got some kind of      -- strange error (result = diskChange, writeFault, notReady), or we have      -- a bad sector (result = cylinderError, recordNotFound, deletedData,      -- headerError, dataError, dataLost)!      SELECT status FROM        goodCompletion => EXIT;	diskChange     => ERROR FloppyTapeInternal.DiskChanged;	notReady       => ERROR FloppyTape.Error[notReady];	cylinderError, recordNotFound, deletedData, headerError, dataError,	  dataLost     => BEGIN	                  FloppyTapeInternal.MarkBadSectorEntryInternal[			    beforeFileWritten, currentSector];			  currentSector ¬ currentSector + 1;			  IF sectorCount >= 0 THEN sectorCount ¬ sectorCount - 1;			    -- protect against going < 0			  END;	writeFault     => ERROR FloppyTape.Error[writeInhibited];	otherError     => BEGIN	                  IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention			    # NIL THEN			    FloppyTapeInternal.volumeDesc.notifyClientOnRetention[			      FloppyTapeInternal.volumeDesc.drive, start];			  status ¬ SpecialFloppyChannelExtras.Retention[			      FloppyTapeInternal.volumeDesc.fcHandle];			  IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention			    # NIL THEN			    FloppyTapeInternal.volumeDesc.notifyClientOnRetention[			      FloppyTapeInternal.volumeDesc.drive, stop];			  IF status # goodCompletion THEN			    ERROR FloppyTape.Error[hardwareError];			  END;	ENDCASE        => ERROR;      ENDLOOP;    CleanUp[];    END;    EXITS      diskChanged => ERROR FloppyTapeInternal.DiskChanged;    END;  --WriteWithSameData--  END.LOG 8-Feb-87 18:26:32  RSV  Created File 8-Feb-87 23:47:08  ET	 Changed monitoring and some minor twiddles. 9-Feb-87 19:33:54  RSV  Rewrote CountBadPagesInFile procedure.  Various changes for RealFileIDLoc.10-Feb-87 15:54:43  ET   More compiling twiddles.19-Feb-87 16:50:25  RSV  Added ConvertToStreamAddr.  Changed address in WriteFloppyTape to FloppyChannel.DiskAddress from SectorNumber.21-Feb-87 13:29:32  RSV  Added ValidateHandle and ValidDrive. 2-Mar-87 15:48:17  ET   Added comment ConvertToStreamAddr for RSV. 2-Mar-87 23:00:58  RSV  Changed ConvertToStreamAddr to call face.13-Mar-87  7:39:10  RSV  Changed ConvertToStreamAddr to take into account marker page.21-Mar-87 23:05:52  RSV  Added ClosedVolumeInternal from FloppyTapeImplA. 4-May-87 12:16:49  RSV  Added ReadRootAndBadSectorList.  Space.Kill rootPage and badSectorList together.19-Jun-87 13:45:02  RSV  Deleted IsDriveWriteProtected.  Moved in ReadFileIDLoc and AllocIOCB.  Added FreeIOCB.  Catch FloppyChannel.Error[invalidHandle]. 9-Jul-87 10:48:18  RSV  Reimplement WriteWithSameData to be faster (DoDirectIO).14-Jul-87 22:59:49  RSV  Added DoOperation stuff.21-Jul-87 10:48:38  RSV  Deleted closing volume in ValidateHandle if error.27-Jul-87 17:14:46  RSV  Added catching DiskChanged where needed.14-Aug-87 10:55:49  RSV  Fix RealFileIDLoc to not exit loop prematurely.16-Sep-87  9:58:22  RSV  Added IsPageBadAndType and fixed RealFileIDLoc to not end on a bad page (regardless of type).22-Sep-87 13:51:35  RSV  Fixed bug in CountBadPagesInFile which caused low bad sectors to effect all files above them.25-Sep-87 11:12:14  RSV  For certain recordNotFound and cylinderError's, raise needsScavenging or InternIOError instead of notFormatted (exceptions are root and bad sector list).25-Sep-87 12:23:45  RSV  Use volumeDesc.drive instead of localDrive.11-Oct-87 23:15:09  RSV  SpecialFloppyChannelExtras.GetDeviceHandle instead of FloppyTapeInternal.GetDeviceHandle.  Fix up comment for writeFault in ValidateHandle.  Move CheckBootFile out of nested place. 1-Dec-87 14:03:22  RSV  Deallocate verifyBuffer in CloseVolumeInternal 3-Jun-88 11:58:58  RSV  Added code in WriteWithSameData for temporary hack for Daybreak Tape problems resulting from AR 13249 against the Daybreak heads.26-Dec-88 14:17:33  RSV  Added temporary code in CheckBootFileInternal and GetDiskAddressInternal to deal with not correctly doing stream selects and thus not always finding a marker page when you should.
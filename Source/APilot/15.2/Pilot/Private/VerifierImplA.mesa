--Copyright (C) 1986, 1987, 1988 by Xerox Corporation.  All rights reserved.--VerifierImplA.mesa          18-Mar-88 14:23:47 by ETDIRECTORY  BackingStore USING [Run],  DiskBackingStore USING [ChannelHandle, GetDiskChannel],  DiskChannel USING [Handle, IOStatus],  Environment USING [bitsPerWord, PageCount, PageNumber, wordsPerPage],  ETable, -- USING [Close, CreateFile, lvBucketInfo, Open, WhichETableFile],  ETableInternal USING [fileHeaderSize, Hash, normalBucketSize,     nullETableFilePage, overflowBufferSize, ReplacePageInternal,    SetTemporaryInternal,WhereIsFilePageOnVolume],  File USING [File, ID, nullFile, nullID, PageCount, PageNumber],   FileInternal USING [FileID],   FileTypes USING [PilotFileType],   Inline USING [LongCOPY, LongCOPYReverse],  KernelFile USING [Descriptor, PageGroup],   KernelVolume USING [],  LogicalVolumeFormat USING [Handle, rootPageSize, SubmarkerHandle],  PhysicalVolume USING [PageNumber],  PhysicalVolumeFormat,   PilotFileTypes USING [tScavengerLog],   RuntimeInternal USING [Bug],  Scavenger,   Space USING [Allocate, Deallocate, Interval, InsufficientSpace,      PageFromLongPointer],   VerifierInternal,   VM USING [BackingStoreRuns, Interval, ForceOut,      Map, nullInterval, ScratchMap, Unmap],  VolAllocMap USING [AllocPageGroup, Close],  VolTable USING  [FindSV,  GetLVStatus, LockEntireLV, LVAccessProc, LVToken,      SVDesc, SVToken],  Volume USING [ID, PageCount, PageNumber, InsufficientSpace]; VerifierImplA: MONITORIMPORTS   DiskBackingStore,   ETableInternal, Inline, RuntimeInternal,   Space, VerifierInternal, VM, VolAllocMap, VolTable, VolumeEXPORTS  Scavenger, VerifierInternal =     BEGIN    OPEN ETI: ETableInternal, LVF: LogicalVolumeFormat, PVF: PhysicalVolumeFormat,     ET: ETable, VI: VerifierInternal;  -- PARAMETERS:    diskChannel: PUBLIC DiskChannel.Handle;        -- TYPEs and Constants:  BadPageDescriptor: TYPE = LONG DESCRIPTOR FOR ARRAY OF Volume.PageNumber;  goodCompletion: DiskChannel.IOStatus = [disk[goodCompletion]];  dataError: DiskChannel.IOStatus = [disk[dataCRCError]];  bitsPerPage: CARDINAL = Environment.bitsPerWord * Environment.wordsPerPage;  Bug: PROCEDURE [bug: BugType] = {RuntimeInternal.Bug[bug]};  BugType: TYPE = {    impossibleEndcase, impossibleFaceStatus,     impossibleProblemType, invalidChannel, invalidDriveState,      logicError, notImplemented, outOfDiskSpace, outOfVM,     residentHeapFreeNodeFailure, residentHeapMakeNodeFailure,    unableToFreeResidentHeapNode,     unexpectedHardwareError, unexpectedVolTableError};      -- The following are for the array of ETable errors found during the scan    maximumNumberOfErrorsInErrorList: PUBLIC CARDINAL ¬ 200;  errorListSize:  PUBLIC Volume.PageCount;  numberOfErrorsInErrorList: PUBLIC CARDINAL ¬ 0;  errorList: PUBLIC LONG POINTER TO ARRAY [0..0) OF VI.ErrorListInfo;  errorListOverflowed:  PUBLIC BOOLEAN ¬ FALSE;   numberOfFilesInFileList: PUBLIC CARDINAL ¬ 0;        --The following are for the list of file ID's found during the scan    largestAllocatedFileID:  PUBLIC LONG CARDINAL¬ LAST[FileTypes.PilotFileType];  maximumNumberOfFilesInFileList:  CARDINAL = 4000;  fileListSize:  Volume.PageCount;  fileList:  LONG POINTER TO ARRAY [0..0) OF File.ID;  fileListOverflowed:  BOOLEAN ¬ FALSE;  firstFree: LONG CARDINAL;    -- The following are used the Verifier Access Proc    bsChannel: DiskBackingStore.ChannelHandle;  dataLost: BOOLEAN;  filePage: File.PageNumber;  i: CARDINAL;  lvbid: ET.LVBucketInfoData;  lvbi: ET.LVBucketInfo ¬ @lvbid;  currentETable: ET.ETableHandle;  TempETableType: TYPE = RECORD[header: ET.ETableHeader,     pageGroups: ARRAY[0..1) OF ET.PageGroup];  TempETablePrimary: TempETableType;  TempETableCopy: TempETableType;  primaryETFETTemp: LONG POINTER TO TempETableType ¬ @TempETablePrimary;  copyETFETTemp: LONG POINTER TO TempETableType ¬ @TempETableCopy;  globalForVolume: Volume.ID;  globalForReadOnly: BOOLEAN;  globalForLogFile: File.File;  scavengingNeededFlag: BOOLEAN;	       -- The following are for the array of bucket overflow counts.  These are   -- collected when the ETables are scanned.  If an overflow count is  -- incorrect, the correct count is written to the bucket at the end of  -- the scan.      maximumNumberOfBucketsForBucketOverflowList: CARDINAL;  bucketOverflowListSize: Volume.PageCount;  bucketOverflowList: PUBLIC LONG POINTER TO ARRAY[0..0) OF VI.BucketOverflowInfo;  numberOfRecordsinBucketOverflowList: CARDINAL;    localScavengerLogFileExists: PUBLIC BOOLEAN;  minimalScavenge: PUBLIC BOOLEAN;  skipClientPageCorrections: PUBLIC BOOLEAN;  mustCompactOverflowFiles:  BOOLEAN ¬ FALSE;      Error: PUBLIC ERROR [Scavenger.ErrorType] = CODE;       -------------------------------------------------------------------------------  -- AddFileToFileList  -------------------------------------------------------------------------------      AddFileToFileList: PUBLIC PROCEDURE [fileID: File.ID]     RETURNS [BOOLEAN] =     -- If the file.ID of the ETable is in the fileList, return TRUE.  Otherwise     -- add the file.ID to the fileList and return FALSE.    BEGIN    i: CARDINAL;    FOR i IN [0..numberOfFilesInFileList) DO       IF fileID = fileList[i] THEN 	RETURN[TRUE];      ENDLOOP;    IF numberOfFilesInFileList = maximumNumberOfFilesInFileList THEN      fileListOverflowed ¬ TRUE      ELSE      BEGIN      fileList[numberOfFilesInFileList] ¬ fileID;      numberOfFilesInFileList ¬ numberOfFilesInFileList + 1;      END;    RETURN[FALSE];    END;  --AddFileToFileList--             -------------------------------------------------------------------------------  -- CleanupVerifier  -------------------------------------------------------------------------------      CleanupVerifier: PROCEDURE [] =      BEGIN            -- Release the space for the bucketOverflowList            IF VI.bucketOverflowList ~= NIL THEN         BEGIN         VM.Unmap[Space.PageFromLongPointer[VI.bucketOverflowList]];         Space.Deallocate[[VI.bucketOverflowList, bucketOverflowListSize]];	 END;            -- Release the space for the fileList            VM.Unmap[Space.PageFromLongPointer[fileList]];      Space.Deallocate[[fileList, fileListSize]];            -- Release the space for the errorList            VM.Unmap[Space.PageFromLongPointer[VI.errorList]];      Space.Deallocate[[VI.errorList, VI.errorListSize]];            -- Release the space for the badPageList            VM.Unmap[Space.PageFromLongPointer[VI.badPageList]];      Space.Deallocate[[VI.badPageList, VI.badPageListSize]];            -- Release the space for the badDataPageList            <<      VM.Unmap[Space.PageFromLongPointer[badDataPageList]];      Space.Deallocate[[badDataPageList, badDataPageListSize]];      >>            -- Release the space for the bucket buffer            VM.Unmap[Space.PageFromLongPointer[lvbi.bucketHandle]];      Space.Deallocate[[lvbi.bucketHandle, ETI.normalBucketSize]];            -- Release the space for the overflow buffer            VM.Unmap[Space.PageFromLongPointer[lvbi.overflowHandle]];      Space.Deallocate[[lvbi.overflowHandle, ETI.overflowBufferSize]];            -- Release the space for the primary ETFET             IF lvbi.primaryETableHandle ~= NIL THEN         BEGIN         VM.Unmap[Space.PageFromLongPointer[lvbi.primaryETableHandle]];         Space.Deallocate[[lvbi.primaryETableHandle,	    lvbi.fileHandle.maxETableSize]];	 END;            -- Release the space for the copy ETFET            IF lvbi.copyETableHandle ~= NIL THEN         BEGIN         VM.Unmap[Space.PageFromLongPointer[lvbi.copyETableHandle]];         Space.Deallocate[[lvbi.copyETableHandle,	    lvbi.fileHandle.maxETableSize]]; 	 END;            -- Release space for preImage            IF lvbi.preImageLogHandle ~= NIL THEN         BEGIN         VM.Unmap[Space.PageFromLongPointer[lvbi.preImageLogHandle]];         Space.Deallocate[[lvbi.preImageLogHandle,	    lvbi.fileHandle.preImageSize]];	 END;                  -- Release the space for the file header            VM.Unmap[Space.PageFromLongPointer[lvbi.fileHandle]];      Space.Deallocate[[lvbi.fileHandle, ETI.fileHeaderSize]];            END; --CleanupVerifier--        -------------------------------------------------------------------------------  -- FileIDFromNumber  -------------------------------------------------------------------------------    FileIDFromNumber: PROC [id: FileInternal.FileID] RETURNS [File.ID] = INLINE {    RETURN[LOOPHOLE[id]]};    -------------------------------------------------------------------------------  -- GetETableSize  -------------------------------------------------------------------------------    GetETableSize: PROCEDURE [eTable: ET.ETableHandle] RETURNS [CARDINAL] =     INLINE {  RETURN[CARDINAL[     SIZE[ET.ETableHeader] +      (SIZE[ET.PageGroup] * eTable.header.howManyGroups)]] };         --------------------------------------------------------------------------    -- FixETableFilePages - STEP 10 of verifier.       --------------------------------------------------------------------------      ModifyETFETable: PROCEDURE [     eTable: ET.ETableHandle,      numberOfNewPageGroups: CARDINAL,       newIndex: CARDINAL] =      -- Make a hole in the specified ETable for numberOfNewPageGroups at position     -- newIndex.  Sufficient space for the new entries is assumed.     BEGIN     offset: CARDINAL ¬         SIZE[ET.ETableHeader] + newIndex * SIZE[ET.PageGroup];     Inline.LongCOPYReverse[        from: eTable + offset,        nwords: GetETableSize[eTable] - offset,         to: eTable + offset + numberOfNewPageGroups * SIZE[ET.PageGroup]];     eTable.header.howManyGroups ¬         eTable.header.howManyGroups + numberOfNewPageGroups;     END; --ModifyETFETable--           FixETableFilePages: PROCEDURE [lvbi: ETable.LVBucketInfo]     RETURNS [markerPageModified: BOOLEAN ¬ FALSE,       svTok: VolTable.SVToken, markerSpace: Space.Interval] =        BEGIN    -- STEP 10:   Replace bad pages with good pages for ETable file pages.      --            Client files will be fixed later.        primaryETFETModified: BOOLEAN ¬ FALSE;    copyETFETModified: BOOLEAN ¬ FALSE;    headerModified: BOOLEAN ¬ FALSE;	      FOR i:CARDINAL IN [0..VI.numberOfErrorsInErrorList) DO       fileD: KernelFile.Descriptor;       group: KernelFile.PageGroup;       newVolumePage: Volume.PageNumber;       status: DiskChannel.IOStatus;       eTableHandleBadPage, eTableHandleGoodPage: ET.ETableHandle;              -- Ignore anything other than bad pages in an ETable file       -- Ignore bad etable in buckets. It's only meant to trigger client scavenger.	              IF VI.errorList[i].problem = badClientPage OR 	  VI.errorList[i].problem = badClientData OR 	  VI.errorList[i].problem = badPilotPage OR 	  VI.errorList[i].problem = badPilotData OR	  VI.errorList[i].problem = badETableInBucket THEN LOOP;              -- Obtain a replacement volume page              group ¬ [0, 0, 1];       VolAllocMap.AllocPageGroup[	  lvbi.lvHandle, @fileD, @group, VM.nullInterval, lvbi.token ! 	  Volume.InsufficientSpace => Bug[outOfDiskSpace]];       newVolumePage ¬ group.volumePage;              IF VI.errorList[i].which = primary THEN 	  BEGIN	  primaryETFETModified ¬ TRUE;	  eTableHandleBadPage ¬ lvbi.primaryETableHandle;	  eTableHandleGoodPage ¬ lvbi.copyETableHandle;	  END       ELSE 	  BEGIN	  copyETFETModified ¬ TRUE;	  eTableHandleBadPage ¬ lvbi.copyETableHandle;	  eTableHandleGoodPage ¬ lvbi.primaryETableHandle;	  END;              -- Now replace a bad page in an ETable file              BEGIN             additionalPageGroups: CARDINAL;       currentFilePage: File.PageNumber ¬ 0;                found: BOOLEAN ¬ FALSE;       j: CARDINAL ¬ 0;       problemFilePage: File.PageNumber ¬ -- special case due to STEP 5	 SELECT VI.errorList[i].problem FROM	   badFirstPageOfPrimaryETFET =>	     VI.errorList[i].filePage + ETI.fileHeaderSize	     + lvbi.fileHandle.preImageSize,	   badFirstPageOfCopyETFET =>	     VI.errorList[i].filePage + ETI.fileHeaderSize	     + lvbi.fileHandle.preImageSize + lvbi.fileHandle.maxETableSize,	   ENDCASE => VI.errorList[i].filePage;       UNTIL (j = eTableHandleBadPage.header.howManyGroups) 	     OR found DO 	  SELECT TRUE FROM	  	     ((problemFilePage = currentFilePage) AND	     (eTableHandleBadPage.pageGroups[j].count = 1)) =>		BEGIN				-- The first page of a page group of 1		-- A special case since no new page groups must be added				eTableHandleBadPage.pageGroups[j].volumePage ¬		   newVolumePage;		found ¬ TRUE;		END;			     (problemFilePage = currentFilePage) => 		BEGIN				-- The first page of a page group larger than 1		-- Insert one page group before this page group				additionalPageGroups ¬ 1;		ModifyETFETable[eTableHandleBadPage, additionalPageGroups, j];		eTableHandleBadPage.pageGroups[j] ¬ [newVolumePage, 1];		eTableHandleBadPage.pageGroups[j+1] ¬ [ 		   SUCC[eTableHandleBadPage.pageGroups[j + 1].volumePage],		   PRED[eTableHandleBadPage.pageGroups[j + 1].count]];		found ¬ TRUE;		END;			     (problemFilePage = (currentFilePage + 		eTableHandleBadPage.pageGroups[j].count - 1)) =>		BEGIN				-- The last page of a page group		-- Insert one page group after this page group				additionalPageGroups ¬ 1;		ModifyETFETable[eTableHandleBadPage, additionalPageGroups, j + 1];		eTableHandleBadPage.pageGroups[j] ¬ [		   eTableHandleBadPage.pageGroups[j].volumePage, 		   PRED[eTableHandleBadPage.pageGroups[j].count]];		eTableHandleBadPage.pageGroups[j+1] ¬ [newVolumePage, 1];		found ¬ TRUE;		END;			     ((problemFilePage > currentFilePage) AND 		(problemFilePage < (currentFilePage + 		   eTableHandleBadPage.pageGroups[j].count - 1))) => 		BEGIN 				-- In the middle of a page group (must be 3 or more pages)		-- Insert page group in between (creates 2 additional groups)				firstGroupSize: CARDINAL ¬ CARDINAL[problemFilePage -		   currentFilePage];		lastGroupSize: CARDINAL ¬		   CARDINAL[eTableHandleBadPage.pageGroups[j].count - 		   firstGroupSize - 1];		additionalPageGroups ¬ 2;		ModifyETFETable[eTableHandleBadPage, additionalPageGroups, j + 1];		eTableHandleBadPage.pageGroups[j+2] ¬ 		   [eTableHandleBadPage.pageGroups[j].volumePage + firstGroupSize + 1, 		   eTableHandleBadPage.pageGroups[j].count - firstGroupSize - 1];		eTableHandleBadPage.pageGroups[j] ¬ 		   [eTableHandleBadPage.pageGroups[j].volumePage,		   firstGroupSize];		eTableHandleBadPage.pageGroups[j+1] ¬ [newVolumePage, 1];		found ¬ TRUE;		END;			     ENDCASE => 				-- Not in this page group				NULL;			  currentFilePage ¬ 	     currentFilePage + eTableHandleBadPage.pageGroups[j].count;	  j ¬ j + 1;	  ENDLOOP;	         IF ~found THEN Bug[logicError];       status ¬	  VI.ReadPage[ETI.WhereIsFilePageOnVolume[problemFilePage, 	  eTableHandleGoodPage].volumePage,	  Space.PageFromLongPointer[lvbi.bucketHandle], 	  VI.diskChannel, VI.firstPVPageOfLV];       IF VI.WritePage[ETI.WhereIsFilePageOnVolume[problemFilePage, 	  eTableHandleBadPage].volumePage,	  Space.PageFromLongPointer[lvbi.bucketHandle], 	  VI.diskChannel, VI.firstPVPageOfLV] ~= goodCompletion OR	  status ~= goodCompletion THEN Bug[unexpectedHardwareError];              -- If the header must be changed, change it.              SELECT VI.errorList[i].problem FROM       	  badHeaderPage =>	  	     BEGIN	     lvmp: LogicalVolumeFormat.SubmarkerHandle;	     [svTok, markerSpace] ¬ VI.MapMarkerPage[globalForVolume, lvbi.token];	     lvmp ¬ @LOOPHOLE[markerSpace.pointer, PVF.MarkerHandle].logical;	     IF VI.errorList[i].which = primary THEN {		lvbi.lvHandle.primaryETableStartPage ¬ newVolumePage;		lvmp.primaryETableStartPage ¬ newVolumePage }	     ELSE {		lvbi.lvHandle.copyETableStartPage ¬ newVolumePage;		lvmp.copyETableStartPage ¬ newVolumePage};	     	     -- The root page will be forced out at the end of verification.	     -- But force the marker page	     markerPageModified ¬ TRUE;	     END;	     	  badLogPage =>	  	     BEGIN -- only if first page in preimage log	     IF problemFilePage = ETI.fileHeaderSize THEN 	       BEGIN	       IF VI.errorList[i].which = primary THEN		  lvbi.fileHandle.primaryETFHeader.firstPreImagePage ¬		     newVolumePage	       ELSE		  lvbi.fileHandle.copyETFHeader.firstPreImagePage ¬		     newVolumePage;	       headerModified ¬ TRUE;	       END;	     END;	     	  badFirstPageOfOverflow =>	  	     BEGIN	     IF VI.errorList[i].which = primary THEN		lvbi.fileHandle.primaryETFHeader.firstOverflowPage ¬		   newVolumePage	     ELSE		lvbi.fileHandle.copyETFHeader.firstOverflowPage ¬		   newVolumePage;	     headerModified ¬ TRUE;	     END;		  	  badFirstPageOfPrimaryETFET =>	  	     BEGIN	     IF VI.errorList[i].which = primary THEN		lvbi.fileHandle.primaryETFHeader.myFirstETablePage ¬ 		   newVolumePage	     ELSE		lvbi.fileHandle.copyETFHeader.otherFirstETablePage ¬ 		   newVolumePage;	     headerModified ¬ TRUE;	     END;	     	  badFirstPageOfCopyETFET =>	  	     BEGIN	     IF VI.errorList[i].which = primary THEN		lvbi.fileHandle.primaryETFHeader.otherFirstETablePage ¬ 		   newVolumePage	     ELSE		lvbi.fileHandle.copyETFHeader.myFirstETablePage ¬ 		   newVolumePage;	     headerModified ¬ TRUE;	     END;		     	  ENDCASE => NULL;       END;       ENDLOOP;        -- If necessary, write out the ETable file header to both ETable files.        IF headerModified THEN       BEGIN       IF VI.WritePage[	  lvbi.lvHandle.primaryETableStartPage, 	  Space.PageFromLongPointer[lvbi.fileHandle],	  VI.diskChannel, 	  VI.firstPVPageOfLV] ~= goodCompletion THEN 	     Bug[unexpectedHardwareError];       IF VI.WritePage[	  lvbi.lvHandle.copyETableStartPage, 	  Space.PageFromLongPointer[lvbi.fileHandle],	  VI.diskChannel, 	  VI.firstPVPageOfLV] ~= goodCompletion THEN 	     Bug[unexpectedHardwareError];       END;	         -- If necessary, write out primary ETFET.        IF primaryETFETModified THEN       BEGIN        filePage: File.PageNumber ¬ 	  ETI.fileHeaderSize + lvbi.fileHandle.preImageSize;       memPage: Environment.PageNumber ¬	  Space.PageFromLongPointer[lvbi.primaryETableHandle];       --       -- First, modify the ETFET for the primary ETable file in the primary        -- ETable file.       --       FOR i: CARDINAL IN [0..lvbi.fileHandle.maxETableSize) DO 	  IF VI.WritePage[	     ETI.WhereIsFilePageOnVolume[		filePage, lvbi.primaryETableHandle].volumePage, 	     memPage, VI.diskChannel, VI.firstPVPageOfLV] ~= goodCompletion THEN 	     Bug[unexpectedHardwareError];	  filePage ¬ filePage + 1;	  memPage ¬ memPage + 1;	  ENDLOOP;       --       -- Second, modify the ETFET for the primary ETable file in the copy        -- ETable file.       --       filePage ¬ ETI.fileHeaderSize + lvbi.fileHandle.preImageSize;       memPage ¬ Space.PageFromLongPointer[lvbi.primaryETableHandle];       FOR i: CARDINAL IN [0..lvbi.fileHandle.maxETableSize) DO 	  IF VI.WritePage[	     ETI.WhereIsFilePageOnVolume[		filePage, lvbi.copyETableHandle].volumePage, 	     memPage, VI.diskChannel, VI.firstPVPageOfLV] ~= goodCompletion THEN 	     Bug[unexpectedHardwareError];	  filePage ¬ filePage + 1;	  memPage ¬ memPage + 1;	  ENDLOOP;       END;    IF copyETFETModified THEN       BEGIN       filePage: Volume.PageNumber ¬ ETI.fileHeaderSize +	  lvbi.fileHandle.preImageSize + lvbi.fileHandle.maxETableSize;       memPage: Environment.PageNumber ¬	  Space.PageFromLongPointer[lvbi.copyETableHandle];       --       -- First, modify the ETFET for the copy ETable file in the primary        -- ETable file.       --       FOR i: CARDINAL IN [0..lvbi.fileHandle.maxETableSize) DO 	  IF VI.WritePage[	     ETI.WhereIsFilePageOnVolume[		filePage, lvbi.primaryETableHandle].volumePage, 	     memPage, VI.diskChannel, VI.firstPVPageOfLV] ~= goodCompletion THEN 	     Bug[unexpectedHardwareError];	  filePage ¬ filePage + 1;	  memPage ¬ memPage + 1;	  ENDLOOP;       --       -- Second, modify the ETFET for the primary ETable file in the copy        -- ETable file.       --       filePage ¬ ETI.fileHeaderSize +	  lvbi.fileHandle.preImageSize + lvbi.fileHandle.maxETableSize;       memPage ¬ Space.PageFromLongPointer[lvbi.copyETableHandle];       FOR i: CARDINAL IN [0..lvbi.fileHandle.maxETableSize) DO 	  IF VI.WritePage[	     ETI.WhereIsFilePageOnVolume[		filePage, lvbi.copyETableHandle].volumePage, 	     memPage, VI.diskChannel, VI.firstPVPageOfLV] ~= goodCompletion THEN 	     Bug[unexpectedHardwareError];	  filePage ¬ filePage + 1;	  memPage ¬ memPage + 1;	  ENDLOOP;       END;    END;       -------------------------------------------------------------------------------  -- InitializeVerifier  -------------------------------------------------------------------------------    InitializeVerifier:  PROCEDURE [     tok: VolTable.LVToken, lvHandle: LVF.Handle, volume: Volume.ID] =       BEGIN          largestAllocatedFileID ¬ LAST[FileTypes.PilotFileType];     mustCompactOverflowFiles ¬ FALSE;     errorListOverflowed ¬ FALSE;     fileListOverflowed ¬ FALSE;          localScavengerLogFileExists ¬ FALSE;     VI.numberOfFiles ¬ 0;     skipClientPageCorrections ¬ FALSE;          -- Set up diskChannel for I/O           bsChannel ¬ VI.GetDiskIOInfo[        globalForVolume, 0, LVF.rootPageSize].channel;     diskChannel ¬ DiskBackingStore.GetDiskChannel[bsChannel];          -- Space for bucketOverflowList not allocated here          VI.bucketOverflowList ¬ NIL;           -- Back fileList with real resident memory           fileListSize ¬ ((maximumNumberOfFilesInFileList *         SIZE[File.ID]) / Environment.wordsPerPage) + 1;     fileList ¬ LOOPHOLE[        Space.Allocate[fileListSize ! Space.InsufficientSpace =>Bug[outOfVM]].pointer];     VM.ScratchMap[[Space.PageFromLongPointer[fileList], fileListSize]];     numberOfFilesInFileList ¬ 0;             -- Back errorList with real resident memory and initialize          VI.errorListSize ¬ ((VI.maximumNumberOfErrorsInErrorList *         SIZE[VI.ErrorListInfo]) / Environment.wordsPerPage) + 1;     VI.errorList ¬ LOOPHOLE[        Space.Allocate[VI.errorListSize ! Space.InsufficientSpace =>Bug[outOfVM]].pointer];     VM.ScratchMap[[Space.PageFromLongPointer[VI.errorList], VI.errorListSize]];     VI.numberOfErrorsInErrorList ¬ 0;	       -- Set up in memory list of bad pages           VI.CreateBadPageList[tok, volume];	       -- Set up in memory list of pages which have lost their data           VI.CreateBadDataPageList[tok, volume];                       -- Initialize lvBucketInfo            -- First allocate VM for the various buffers and back them with real      -- resident memory.  Not all of the lvBucketInfo can be initialized      -- here.  Some must wait until the ETFET headers are read in (done      -- later) since data in the headers is used.          -- Allocate VM for the bucket buffer				       lvbi.bucketHandle ¬ LOOPHOLE[Space.Allocate[ETI.normalBucketSize        ! Space.InsufficientSpace => Bug[outOfVM]].pointer];     VM.ScratchMap[[Space.PageFromLongPointer[lvbi.bucketHandle],         ETI.normalBucketSize]];	     -- Allocate VM for the overflow buffer          lvbi.overflowHandle ¬        LOOPHOLE[Space.Allocate[ETI.overflowBufferSize        ! Space.InsufficientSpace => Bug[outOfVM]].pointer];     VM.ScratchMap[[Space.PageFromLongPointer[lvbi.overflowHandle],         ETI.overflowBufferSize]];          -- Space for primaryETable not allocated here.          lvbi.primaryETableHandle ¬ NIL;          -- Space for copyETable not allocated here.          lvbi.copyETableHandle ¬ NIL;          -- Space for preImageLog not allocated here.          lvbi.preImageLogHandle ¬ NIL;     -- Allocate VM for the file header          lvbi.fileHandle ¬ Space.Allocate[ETI.fileHeaderSize, !        Space.InsufficientSpace => Bug[outOfVM]].pointer;     VM.ScratchMap[interval:        [Space.PageFromLongPointer[lvbi.fileHandle],        ETI.fileHeaderSize]];           -- Initialize lvbi: Initialize other variables          lvbi.lvHandle ¬ lvHandle;     lvbi.fileID ¬ File.nullID;     lvbi.eTableHandle ¬ NIL;     lvbi.inBucket ¬ FALSE;     lvbi.currentOverflowPage ¬ lvbi.currentBucketPage ¬ ETI.nullETableFilePage;     lvbi.token ¬ LOOPHOLE[0];     lvbi.nextLVBucketInfo ¬ LOOPHOLE[0];           END; --InitializeVerifier--                ---------------------------------------------------------------------------  -- Verifier  ---------------------------------------------------------------------------        Verifier: PUBLIC ENTRY PROCEDURE [volume: Volume.ID, checkOnly: BOOLEAN,        optionalLogFile: File.File]     RETURNS[logFile: File.File]  =       BEGIN ENABLE UNWIND => NULL;            scavengingNeededFlag ¬ TRUE;      globalForVolume ¬ volume;      globalForReadOnly ¬ checkOnly;      globalForLogFile ¬ optionalLogFile;      VolTable.LockEntireLV [        volume, VerifierAccessProc, write, allSVsOnline];      RETURN[globalForLogFile];      END; --Verifier--    ---------------------------------------------------------------------------    -- VerifierWithLock    ---------------------------------------------------------------------------        VerifierWithLock: PUBLIC ENTRY PROCEDURE [      tok: VolTable.LVToken, lvHandle: LVF.Handle, volume: Volume.ID,       checkOnly: BOOLEAN, optionalLogFile: File.File]     RETURNS[logFile: File.File]  =            BEGIN ENABLE UNWIND => NULL;            scavengingNeededFlag ¬ FALSE;      globalForVolume ¬ volume;      globalForReadOnly ¬ checkOnly;      globalForLogFile ¬ optionalLogFile;       VerifierAccessProc[tok, lvHandle];      RETURN[globalForLogFile];      END; --VerifierWithLock--        ---------------------------------------------------------------------------    -- CompactDisk    ---------------------------------------------------------------------------        CompactDisk: PUBLIC ENTRY PROCEDURE [volume: Volume.ID] =        BEGIN ENABLE UNWIND => NULL;       scavengingNeededFlag ¬ TRUE;       globalForVolume ¬ volume;       globalForReadOnly ¬ FALSE;       globalForLogFile ¬ File.nullFile;       mustCompactOverflowFiles ¬ TRUE;       VolTable.LockEntireLV [          volume, VerifierAccessProc, write, allSVsOnline];       END;    ---------------------------------------------------------------------------    -- VerifierAccessProc    ---------------------------------------------------------------------------        VerifierAccessProc: VolTable.LVAccessProc --[tok, lvHandle]-- =        BEGIN       markerSpace: Space.Interval;      svTok: VolTable.SVToken;      markerPageModified: BOOLEAN ¬ FALSE;      mustCompactOverflow: BOOLEAN ¬ FALSE;            --------------------------------------------------------------------------      -- STEP 0:   Handle readOnly volumes here.      --------------------------------------------------------------------------            IF globalForReadOnly = TRUE THEN RETURN;      IF VolTable.GetLVStatus[globalForVolume].readOnly = TRUE THEN RETURN;                    --------------------------------------------------------------------------      -- STEP 1:   Set up the Verifier.  Code does no validation or correction.      --------------------------------------------------------------------------            BEGIN       svDesc: VolTable.SVDesc;      [] ¬ VolTable.FindSV[globalForVolume, 0, @svDesc];      VI.firstPVPageOfLV ¬ svDesc.pvPageOfSV;      VI.lastPVPageOfLV ¬ VI.firstPVPageOfLV + svDesc.svLength - 1;          InitializeVerifier[tok, lvHandle, globalForVolume];            minimalScavenge ¬ FALSE;      IF scavengingNeededFlag = FALSE THEN     -- Can assume lv root page is ok	 IF lvHandle.changing = FALSE AND             VI.numberOfBadPages = lvHandle.numberOfBadPagesLastTime AND  	    VI.numberOfBadDataPages = 0 THEN	       minimalScavenge ¬ TRUE;      END;	             ----------------------------------------------------------------------------      -- STEP 2:  Verify and correct the lv root and marker pages.      --          Notice that this means that lvbi.lvHandle and      --          lvbi.lvHandle.volumeSize are correct.  Also, the root page       --          will be mapped and the state set to online.         ----------------------------------------------------------------------------             VI.VerifyAndCorrectLVRootAndMarkerPages[tok, @lvbi, globalForVolume];            ----------------------------------------------------------------------------      -- STEP 3:  Initialize the VAM to all free (setting the volume's lower bound      --          in the process).  Then set to inuse the root page, all pages       --          in the VAM itself, and and the pages of the badPageTable.      ----------------------------------------------------------------------------            BEGIN      badPages: BadPageDescriptor;      badPages ¬ DESCRIPTOR[VI.badPageList, VI.numberOfBadPages];      VI.VamInit[lvHandle, badPages, tok];            END;	       --------------------------------------------------------------------------      --  STEP 4:  Read into resident memory the ETable headers.  First try to       --           read pages from the primary file.      --           If pages in the primary cannot be read, use the information      --           from the copy. Write this information (with read after write      --           check) to the copy.  Where possible, replace the bad data       --           (but cannot yet replace bad pages since we do not know which      --           pages are unused).  Bad pages are recorded in errorList for      --           later correction.      --      --           Complete the lvbi (except for freeSpaceInOverflow).      --------------------------------------------------------------------------            -- Read in the ETable header.            primaryETFETTemp.header.howManyGroups ¬ 1;      primaryETFETTemp.pageGroups[0] ¬	 [lvbi.lvHandle.primaryETableStartPage, 1];      copyETFETTemp.header.howManyGroups ¬ 1;      copyETFETTemp.pageGroups[0] ¬ 	 [lvbi.lvHandle.copyETableStartPage, 1];       IF VI.ReadParallelAndCorrect[	 Space.PageFromLongPointer[lvbi.fileHandle], 	 ETI.fileHeaderSize, 0, LOOPHOLE[primaryETFETTemp, ET.ETableHandle], 	 0, LOOPHOLE[copyETFETTemp, ET.ETableHandle], badHeaderPage].dataLost THEN         ERROR Error[eTableFilesHeaderLost];            -- Back primaryETableHandle­, copyETableHandle­, and preImageLogHandle­       -- with real memory.            lvbi.primaryETableHandle ¬ 	 Space.Allocate[lvbi.fileHandle.maxETableSize, !	 Space.InsufficientSpace => Bug[outOfVM]].pointer;      VM.ScratchMap[interval:	 [Space.PageFromLongPointer[lvbi.primaryETableHandle],	 lvbi.fileHandle.maxETableSize]];      lvbi.copyETableHandle ¬	 Space.Allocate[lvbi.fileHandle.maxETableSize, !	 Space.InsufficientSpace => Bug[outOfVM]].pointer;      VM.ScratchMap[interval:	 [Space.PageFromLongPointer[lvbi.copyETableHandle],	 lvbi.fileHandle.maxETableSize]];       lvbi.preImageLogHandle ¬	 Space.Allocate[lvbi.fileHandle.preImageSize, !	 Space.InsufficientSpace => Bug[outOfVM]].pointer;      VM.ScratchMap[interval:	 [Space.PageFromLongPointer[lvbi.preImageLogHandle],	 lvbi.fileHandle.preImageSize]];      lvbi.hash ¬ lvbi.fileHandle.numberOfBuckets;      maximumNumberOfBucketsForBucketOverflowList ¬         lvbi.fileHandle.numberOfBuckets;             -- Back bucketOverflowList with real resident memory and initialize            bucketOverflowListSize ¬ ((maximumNumberOfBucketsForBucketOverflowList *          SIZE[VI.BucketOverflowInfo]) / Environment.wordsPerPage) + 1;      VI.bucketOverflowList ¬ LOOPHOLE[Space.Allocate[bucketOverflowListSize !          Space.InsufficientSpace => Bug[outOfVM]].pointer];      VM.ScratchMap[[Space.PageFromLongPointer[VI.bucketOverflowList],          bucketOverflowListSize]];      numberOfRecordsinBucketOverflowList ¬ 0;      VI.bucketOverflowList[0] ¬ [0, 0];      Inline.LongCOPY[        from: @VI.bucketOverflowList[0],	nwords: SIZE[VerifierInternal.BucketOverflowInfo] *	  (maximumNumberOfBucketsForBucketOverflowList - 1),	to: @VI.bucketOverflowList[1]];      -- The above is equivalent to the following:      -- FOR i: CARDINAL IN [0..maximumNumberOfBucketsForBucketOverflowList) DO       --   VI.bucketOverflowList[i].oldCount ¬ 0;      --   VI.bucketOverflowList[i].newCount ¬ 0;      --   ENDLOOP;	       lvbi.firstBucketPage ¬         ETI.fileHeaderSize + lvbi.fileHandle.preImageSize +         (2*lvbi.fileHandle.maxETableSize);      lvbi.firstOverflowPage ¬         lvbi.firstBucketPage + 	 lvbi.fileHandle.numberOfBuckets;            --------------------------------------------------------------------------      -- STEP 5:  Read in the first page of the ETable for the ETable file for      --          both of the files.  This will be an incomplete ETable but is        --          assumed to contain enough information to locate the files       --          pages up to the buckets. In particular, it will locate the       --          preimage logs and the ETables for the ETable files.      --------------------------------------------------------------------------            primaryETFETTemp.pageGroups[0] ¬	 [lvbi.fileHandle.primaryETFHeader.myFirstETablePage, 1];      copyETFETTemp.pageGroups[0] ¬ 	 [lvbi.fileHandle.copyETFHeader.otherFirstETablePage, 1];      IF VI.ReadParallelAndCorrect[         Space.PageFromLongPointer[lvbi.primaryETableHandle], 1, 0, 	 LOOPHOLE[primaryETFETTemp, ET.ETableHandle], 0, 	 LOOPHOLE[copyETFETTemp, ET.ETableHandle],	 badFirstPageOfPrimaryETFET].dataLost THEN ERROR Error[primaryETFETLost];      primaryETFETTemp.pageGroups[0] ¬	 [lvbi.fileHandle.primaryETFHeader.otherFirstETablePage, 1];      copyETFETTemp.pageGroups[0] ¬ 	 [lvbi.fileHandle.copyETFHeader.myFirstETablePage, 1];      IF VI.ReadParallelAndCorrect[         Space.PageFromLongPointer[lvbi.copyETableHandle], 1, 0, 	 LOOPHOLE[primaryETFETTemp, ET.ETableHandle], 0, 	 LOOPHOLE[copyETFETTemp, ET.ETableHandle], 	 badFirstPageOfCopyETFET].dataLost THEN ERROR Error[copyETFETLost];            --------------------------------------------------------------------------      --  STEP 6:  Read into resident memory the ETables for the ETable files.      --           Read pages from the primary file.      --           If pages in the primary cannot be read, use the information        --           from the copy. Write this information (with read after        --           write check) to the copy.  Where possible, replace the bad        --           data (but cannot yet replace bad pages since we do not         --           know which pages are unused). Bad pages are recorded in         --           errorList for later replacement.      --------------------------------------------------------------------------        IF VI.ReadParallelAndCorrect[         Space.PageFromLongPointer[lvbi.primaryETableHandle] + 1,	 lvbi.fileHandle.maxETableSize - 1, 	 ETI.fileHeaderSize + lvbi.fileHandle.preImageSize + 1,	 lvbi.primaryETableHandle, 	 ETI.fileHeaderSize + lvbi.fileHandle.preImageSize + 1, 	 lvbi.copyETableHandle, 	 badETFETPrimaryPage].dataLost THEN ERROR Error[primaryETFETLost];      IF  VI.ReadParallelAndCorrect[         Space.PageFromLongPointer[lvbi.copyETableHandle] + 1,	 lvbi.fileHandle.maxETableSize - 1,	 ETI.fileHeaderSize + lvbi.fileHandle.preImageSize +	    lvbi.fileHandle.maxETableSize + 1, 	 lvbi.primaryETableHandle,  	 ETI.fileHeaderSize + lvbi.fileHandle.preImageSize +	    lvbi.fileHandle.maxETableSize + 1,	 lvbi.copyETableHandle, 	 badETFETCopyPage].dataLost THEN ERROR Error[copyETFETLost];         --------------------------------------------------------------------------      -- STEP 7:  Read in and process preimage log. Read pages from primary file.      --          If pages in the primary cannot be read, use the information       --          from the copy.  Bad pages are recorded in errorList.              --      --          Note the assumption that, even though the ETFET's are in a       --          state of disarray, their first pages are accurate in describing      --          the ETF's up to their buckets.      --------------------------------------------------------------------------	        BEGIN      IF lvbi.fileHandle.numberOfPagesLogged = 0 THEN GOTO exitStep7;      -- Step 1: Read into memory the correct data and then write       --         it to its position on the ETF's      SELECT lvbi.fileHandle.itemLogged FROM               eTFET =>	 	    BEGIN	    	    -- First the primary ETFET	                IF VI.ReadParallelAndCorrect[               Space.PageFromLongPointer[lvbi.primaryETableHandle],	       lvbi.fileHandle.maxETableSize, 1, lvbi.primaryETableHandle, 	       1, lvbi.copyETableHandle, badLogPage].dataLost THEN	       ERROR Error[eTFLogLost];	    VI.WriteOutPageRun[	       lvbi.fileHandle.maxETableSize, 	       ETI.fileHeaderSize + lvbi.fileHandle.preImageSize, 	       lvbi.primaryETableHandle,  	       Space.PageFromLongPointer[lvbi.primaryETableHandle]]; 	    VI.WriteOutPageRun[	       lvbi.fileHandle.maxETableSize, 	       ETI.fileHeaderSize + lvbi.fileHandle.preImageSize, 	       lvbi.copyETableHandle,                Space.PageFromLongPointer[lvbi.primaryETableHandle]];	    	    -- Next the copy ETFET	                IF VI.ReadParallelAndCorrect[               Space.PageFromLongPointer[lvbi.copyETableHandle],	       lvbi.fileHandle.maxETableSize,	       1 + lvbi.fileHandle.maxETableSize, lvbi.primaryETableHandle, 	       1 + lvbi.fileHandle.maxETableSize, lvbi.copyETableHandle, 	       badLogPage].dataLost THEN ERROR Error[eTFLogLost];	    VI.WriteOutPageRun[	       lvbi.fileHandle.maxETableSize, 	       ETI.fileHeaderSize + lvbi.fileHandle.preImageSize + 	          lvbi.fileHandle.maxETableSize, 	       lvbi.primaryETableHandle, 	       Space.PageFromLongPointer[lvbi.copyETableHandle]]; 	    VI.WriteOutPageRun[	       lvbi.fileHandle.maxETableSize, 	       ETI.fileHeaderSize + lvbi.fileHandle.preImageSize + 	          lvbi.fileHandle.maxETableSize, 	       lvbi.copyETableHandle,                  Space.PageFromLongPointer[lvbi.copyETableHandle]];	    	    END;	    	 overflowBucket => 	    BEGIN	    IF VI.ReadParallelAndCorrect[               Space.PageFromLongPointer[lvbi.overflowHandle],	       lvbi.fileHandle.overflowSize, 1, lvbi.primaryETableHandle, 	       1, lvbi.copyETableHandle, badLogPage].dataLost THEN 	       ERROR Error[eTFLogLost];	    VI.WriteOutPageRun[	       ETI.overflowBufferSize, 	       lvbi.fileHandle.firstFilePageLogged, 	       lvbi.primaryETableHandle,  	       Space.PageFromLongPointer[lvbi.overflowHandle]]; 	    VI.WriteOutPageRun[	       ETI.overflowBufferSize, 	       lvbi.fileHandle.firstFilePageLogged, 	       lvbi.copyETableHandle,  	       Space.PageFromLongPointer[lvbi.overflowHandle]]; 	    END;	    	 nothingLogged => NULL;	 	 ENDCASE => Bug[impossibleEndcase];	       -- Step 2: Correct the log info in the headers and write them out            lvbi.fileHandle.numberOfPagesLogged ¬ 0;      lvbi.fileHandle.itemLogged ¬ nothingLogged;      VI.WriteOutPageRun[	 ETI.fileHeaderSize, 	 0,          lvbi.primaryETableHandle,           Space.PageFromLongPointer[lvbi.fileHandle]];      VI.WriteOutPageRun[	 ETI.fileHeaderSize, 	 0,          lvbi.copyETableHandle,           Space.PageFromLongPointer[lvbi.fileHandle]];	       EXITS         exitStep7 => 	   -- just do this to detect bad, data lost, or unreadable pages	   -- no, I don't know why this is in here???????  The returned values 	   -- is should return are NEVER used before being set!!!!!	   [] ¬ VI.ReadParallelAndCorrect[	     Space.PageFromLongPointer[lvbi.preImageLogHandle],	     lvbi.fileHandle.preImageSize, 1, lvbi.primaryETableHandle, 	     1, lvbi.copyETableHandle, badLogPage];      END;            --------------------------------------------------------------------------      -- STEP 8:   Set to busy the bits in the VAM corresponding to the ETFET's.       --------------------------------------------------------------------------            BEGIN      volumePage: Volume.PageNumber;      count: LONG CARDINAL;      currentETable ¬ lvbi.primaryETableHandle;      filePage ¬ 0;      FOR i: CARDINAL IN [0..currentETable.header.howManyGroups) DO         [volumePage, count] ¬ currentETable.pageGroups[i];         UNTIL count = 0 DO            IF VI.MarkVAMPagesAsBusy[lvHandle, tok, @volumePage, @count] THEN  	       ERROR Error[primaryETFETLost];	    ENDLOOP;         filePage ¬ filePage + currentETable.pageGroups[i].count;         ENDLOOP;      currentETable ¬ lvbi.copyETableHandle;      FOR i: CARDINAL IN [0..currentETable.header.howManyGroups) DO         [volumePage, count] ¬ currentETable.pageGroups[i];         UNTIL count = 0 DO            IF VI.MarkVAMPagesAsBusy[lvHandle, tok, @volumePage, @count] THEN  	       ERROR Error[copyETFETLost];	    ENDLOOP;         filePage ¬ filePage + currentETable.pageGroups[i].count;         ENDLOOP;	 END;      --------------------------------------------------------------------------    -- STEP 9:   Scan the ETables in ETF2.  Make any corrections that can     --           be made without having any free pages available.    --------------------------------------------------------------------------        --------------------------------------------------------------------------      -- STEP 9a:  Scan the overflow.    --------------------------------------------------------------------------          BEGIN      offsetInOverflow: LONG CARDINAL;      blockSize: CARDINAL ¬ ETI.overflowBufferSize * Environment.wordsPerPage;      overflowBlockModified: BOOLEAN ¬ FALSE;            -- Set up loop on ETables in overflow            dataLost ¬ VI.ReadParallelAndCorrect[         Space.PageFromLongPointer[lvbi.overflowHandle], ETI.overflowBufferSize,	 lvbi.firstOverflowPage, lvbi.primaryETableHandle,	 lvbi.firstOverflowPage, lvbi.copyETableHandle, 	 badFirstPageOfOverflow].dataLost;      lvbi.currentOverflowPage ¬ lvbi.firstOverflowPage;      lvbi.freeSpaceInOverflow ¬         lvbi.overflowHandle.header.freeSpace; -- lvbi is now complete.      IF dataLost THEN ERROR Error[overflowIsLost];      firstFree ¬ LOOPHOLE[lvbi.overflowHandle.header.freeSpace];      offsetInOverflow ¬ SIZE[ET.FreeSpaceInOverflow];      currentETable ¬ @lvbi.overflowHandle.eTables[0];            -- Now examine each ETable in overflow            UNTIL offsetInOverflow = firstFree DO               -- If an ETable is present, validate it.	          IF currentETable.header.fileID ~= File.nullID THEN	    BEGIN	    IF VI.ValidateETable[lvHandle, tok, currentETable] THEN	       BEGIN	       mustCompactOverflow ¬ TRUE;	       overflowBlockModified ¬ TRUE;	       currentETable.header.fileID ¬ File.nullID;	       currentETable.header.length ¬		  GetETableSize[currentETable];	       END	    ELSE 	       BEGIN 	       i ¬ CARDINAL[ETI.Hash[lvbi, currentETable.header.fileID]];	       VI.bucketOverflowList[i].newCount ¬		  VI.bucketOverflowList[i].newCount + 1;	       END;	    END; 	 	 -- Move to next ETable.	 	 IF currentETable.header.fileID ~= File.nullID THEN 	    BEGIN	    offsetInOverflow ¬ offsetInOverflow + GetETableSize[currentETable];	    currentETable ¬ currentETable + GetETableSize[currentETable];	    END	 ELSE	    BEGIN	    mustCompactOverflow ¬ TRUE;	    IF (currentETable.header.length = 0) OR 	       (LOOPHOLE[currentETable + currentETable.header.length, LONG CARDINAL] > 	       LOOPHOLE[lvbi.overflowHandle + blockSize, LONG CARDINAL]) OR 	       (offsetInOverflow + currentETable.header.length > firstFree) THEN 	          ERROR Error[overflowIsLost];	    	    offsetInOverflow ¬ offsetInOverflow + currentETable.header.length;	    currentETable ¬ currentETable + currentETable.header.length;	    END;	 	 -- Continue loop if more ETables in block.	 	 IF ~(currentETable = LOOPHOLE[lvbi.overflowHandle + blockSize, ET.ETableHandle] 	    OR offsetInOverflow = firstFree) THEN LOOP;	 	 -- If modified, write out the block.	 	 IF overflowBlockModified THEN 	    BEGIN 	    FOR i: CARDINAL IN [0..ETI.overflowBufferSize) DO                IF VI.WritePage[	          ETI.WhereIsFilePageOnVolume[lvbi.currentOverflowPage + i, 	          lvbi.copyETableHandle].volumePage,	          Space.PageFromLongPointer[lvbi.overflowHandle] + i, 	          diskChannel, VI.firstPVPageOfLV] ~= 	             goodCompletion THEN 	             Bug[unexpectedHardwareError];	       ENDLOOP;	    FOR i: CARDINAL IN [0..ETI.overflowBufferSize) DO 	       IF VI.WritePage[	          ETI.WhereIsFilePageOnVolume[lvbi.currentOverflowPage + i, 	          lvbi.primaryETableHandle].volumePage,	          Space.PageFromLongPointer[lvbi.overflowHandle] + i, 	          diskChannel, VI.firstPVPageOfLV] ~= 	             goodCompletion THEN 	             Bug[unexpectedHardwareError];	       ENDLOOP;	    overflowBlockModified ¬ FALSE;	    END;	 	 -- Finished if at end of overflow, else read in next block and loop.	 	 IF offsetInOverflow = firstFree THEN EXIT;	 currentETable ¬ LOOPHOLE[lvbi.overflowHandle]; --for non-first block	 lvbi.currentOverflowPage ¬ 	    lvbi.currentOverflowPage + ETableInternal.overflowBufferSize;	 IF VI.ReadParallelAndCorrect[	   Space.PageFromLongPointer[lvbi.overflowHandle], ETI.overflowBufferSize,	   lvbi.currentOverflowPage, lvbi.primaryETableHandle,	   lvbi.currentOverflowPage, lvbi.copyETableHandle, 	   badOverflowPage].dataLost THEN ERROR Error[overflowIsLost];         ENDLOOP;      END;            --------------------------------------------------------------------------      -- STEP 9b:  Scan the buckets.      --------------------------------------------------------------------------       -- Do the fast runs-of-bucket io if we are running with minimalScavenge.       -- It assumes no bad pages or data lost pages      lvbi.token ¬ tok; -- lvbi.lvHandle better be correct at this point       IF minimalScavenge THEN VI.FastVerify[lvbi]      -- Do the slow one-by-one bucket io to handle buckets with bad data pages      ELSE BEGIN  -- Slow verifier	FOR filePage IN [lvbi.firstBucketPage..lvbi.firstOverflowPage) DO 	  bucketModifiedFlag: BOOLEAN ¬ FALSE;	  oldNumberOfFilesInFileList: CARDINAL ¬ numberOfFilesInFileList;	  IF VI.ReadParallelAndCorrect[	    Space.PageFromLongPointer[lvbi.bucketHandle], 1, filePage,	    lvbi.primaryETableHandle, filePage, lvbi.copyETableHandle,	    badBucketPage].dataLost THEN ERROR Error[bucketPageLost];	  i ¬ CARDINAL[filePage - lvbi.firstBucketPage];	  VI.bucketOverflowList[i].oldCount ¬ 	     lvbi.bucketHandle.header.eTablesInOverflowCount;	  currentETable ¬ @lvbi.bucketHandle.eTables[0];	  UNTIL currentETable =	     @lvbi.bucketHandle[lvbi.bucketHandle.header.firstFree] DO	     IF VI.ValidateETable[lvHandle, tok, currentETable] THEN		BEGIN		countToSmashAway: CARDINAL ¬ GetETableSize[currentETable];		countToMove: CARDINAL ¬ CARDINAL[      		  @lvbi.bucketHandle[lvbi.bucketHandle.header.firstFree]		  - currentETable] - countToSmashAway;		Inline.LongCOPY[		   from: currentETable + countToSmashAway, 		   nwords: countToMove,		   to: currentETable];		lvbi.bucketHandle.header.firstFree ¬ 		   lvbi.bucketHandle.header.firstFree - countToSmashAway;		bucketModifiedFlag ¬ TRUE;		END	     ELSE currentETable ¬ currentETable + GetETableSize[currentETable];	     ENDLOOP;	  numberOfFilesInFileList ¬ oldNumberOfFilesInFileList;	  IF ~bucketModifiedFlag THEN LOOP;	  [] ¬ VI.WritePage[	     ETI.WhereIsFilePageOnVolume[filePage,lvbi.copyETableHandle].volumePage,	     Space.PageFromLongPointer[lvbi.bucketHandle], 	     diskChannel, VI.firstPVPageOfLV];	  [] ¬ VI.WritePage[ 	  ETI.WhereIsFilePageOnVolume[filePage,lvbi.primaryETableHandle].volumePage,	     Space.PageFromLongPointer[lvbi.bucketHandle], 	     diskChannel, VI.firstPVPageOfLV];	  ENDLOOP;	END; -- Slow verifier	      --------------------------------------------------------------------------      -- STEP 10:   Replace bad pages with good pages for ETable file pages.        --            Client files will be fixed later..      --------------------------------------------------------------------------            -- this add to be moved to another module for compiling pass 5 sake      [markerPageModified, svTok, markerSpace] ¬ FixETableFilePages[lvbi];	       --------------------------------------------------------------------------      -- STEP 11:   Fix incorrect overflow counts in buckets.      --------------------------------------------------------------------------            FOR i: CARDINAL IN [0..CARDINAL[lvbi.hash]) DO	IF VI.bucketOverflowList[i].oldCount # VI.bucketOverflowList[i].newCount THEN 	   BEGIN	   status: DiskChannel.IOStatus;	   filePage: File.PageNumber ¬ lvbi.firstBucketPage + i;	   status ¬ VI.ReadPage[ETI.WhereIsFilePageOnVolume[filePage, 	      lvbi.copyETableHandle].volumePage,	      Space.PageFromLongPointer[lvbi.bucketHandle], 	      diskChannel, VI.firstPVPageOfLV];	   lvbi.bucketHandle.header.eTablesInOverflowCount ¬ 	     VI.bucketOverflowList[i].newCount;	   IF VI.WritePage[ETI.WhereIsFilePageOnVolume[filePage, 	      lvbi.copyETableHandle].volumePage,	      Space.PageFromLongPointer[lvbi.bucketHandle], 	      diskChannel, VI.firstPVPageOfLV] ~= goodCompletion THEN 		 Bug[unexpectedHardwareError];	   IF VI.WritePage[ETI.WhereIsFilePageOnVolume[filePage, 	      lvbi.primaryETableHandle].volumePage,	      Space.PageFromLongPointer[lvbi.bucketHandle], 	      diskChannel, VI.firstPVPageOfLV] ~= goodCompletion THEN 		 Bug[unexpectedHardwareError];	   END;         ENDLOOP;             --------------------------------------------------------------------------      -- STEP 12:  Set up the lv root page and write out both it and the VAM.       --------------------------------------------------------------------------                        lvbi.lvHandle.lastIDAllocated ¬ largestAllocatedFileID;      lvbi.lvHandle.numberOfFile ¬ VI.numberOfFiles;      lvbi.lvHandle.changing ¬ FALSE;      lvbi.lvHandle.numberOfBadPagesLastTime ¬ VI.numberOfBadPages;      VolAllocMap.Close[lvHandle.vID, forceOut, tok];      -- get the marker page out there if it changed      IF markerPageModified THEN VI.UnmapMarkerPage[svTok, markerSpace];      VM.ForceOut[         [Space.PageFromLongPointer[lvbi.lvHandle], LVF.rootPageSize], wait];            --------------------------------------------------------------------------      -- STEP 13:  Open the ETable File ETables so other software can be used.      --           Since previous code has really simulated an Open, all that       --           must be done is to rationalize lvbi.           --------------------------------------------------------------------------            lvbi.currentBucketPage ¬ lvbi.currentOverflowPage ¬          ETI.nullETableFilePage;      lvbi.fileID ¬ File.nullID;      lvbi.eTableHandle ¬ NIL;      lvbi.inBucket ¬ FALSE;            --------------------------------------------------------------------------      -- STEP 14:  Replace bad scavenger log pages with good pages.          --------------------------------------------------------------------------            FOR i: CARDINAL IN [0..VI.numberOfErrorsInErrorList) DO	 newVolumePage: Volume.PageNumber;	 fileD: KernelFile.Descriptor;	 group: KernelFile.PageGroup;	 IF VI.errorList[i].problem ~= badPilotPage OR 	    VI.errorList[i].file ~= FileIDFromNumber[PilotFileTypes.tScavengerLog]  	    THEN LOOP;	 group ¬ [0, 0, 1];	 VolAllocMap.AllocPageGroup[	    lvbi.lvHandle, @fileD, @group, VM.nullInterval, tok ! 	    Volume.InsufficientSpace => Bug[outOfDiskSpace]]; 	 newVolumePage ¬ group.volumePage;	 ETI.ReplacePageInternal[lvbi, VI.errorList[i].file,	    VI.errorList[i].filePage, newVolumePage];         ENDLOOP;            --------------------------------------------------------------------------       -- STEP 15:   Produce the client scavenger log.      --------------------------------------------------------------------------            globalForLogFile ¬          VI.ProduceScavengerLog[lvHandle, tok, globalForLogFile, lvbi];      ETI.SetTemporaryInternal[lvbi, tok, globalForLogFile.fileID, FALSE];            --------------------------------------------------------------------------      -- STEP 16:  Replace bad client pages with good pages.          --------------------------------------------------------------------------            -- Invalidates firstFree.            IF skipClientPageCorrections THEN VI.numberOfErrorsInErrorList ¬ 0;      FOR i: CARDINAL IN [0..VI.numberOfErrorsInErrorList) DO	 newVolumePage: Volume.PageNumber;	 fileD: KernelFile.Descriptor;	 group: KernelFile.PageGroup;	 IF (VI.errorList[i].problem ~= badClientPage) AND	    (VI.errorList[i].problem ~= badPilotPage OR 	    VI.errorList[i].file = FileIDFromNumber[PilotFileTypes.tScavengerLog])	   THEN LOOP;	 group ¬ [0, 0, 1];	 VolAllocMap.AllocPageGroup[	    lvbi.lvHandle, @fileD, @group, VM.nullInterval, tok ! 	    Volume.InsufficientSpace => Bug[outOfDiskSpace]]; 	 newVolumePage ¬ group.volumePage;	 ETI.ReplacePageInternal[lvbi, VI.errorList[i].file,	    VI.errorList[i].filePage, newVolumePage];         ENDLOOP;	       --------------------------------------------------------------------------      -- Step 17:   Clear the DataLostPageList of all pages within this volume.      --------------------------------------------------------------------------            IF ~skipClientPageCorrections THEN         VI.ClearDataLostPageList[globalForVolume];            --------------------------------------------------------------------------      -- STEP 18:   Compact the overflow area.      --------------------------------------------------------------------------             -- STEP 18  moves all the true ETable's in the overflow to the beginning       -- of the overflow area, squeezing out the space occupied by deleted       -- ETables.  The space freed up can then be reused.                  -- Only the destination block is ever written.  If the computer should fail      -- in the middle of processing, we would only be left with duplicated       -- entries.  Previous Verifier steps would then handle this case the next       -- time the volume is opened.  Since an overflow      -- block is several pages, preimaging must be used to guarantee completion       -- of an initiated write operation.            IF mustCompactOverflow = TRUE THEN VI.CompactOverflow[@lvbi, firstFree];            --------------------------------------------------------------------------      -- STEP 19:   If requested, compact the files in the overflow area.        --            When possible, the ETable will be moved back to its bucket.      --------------------------------------------------------------------------         IF mustCompactOverflowFiles = TRUE THEN VI.CompactFilesInOverflow[         @lvbi, lvHandle, tok];      --------------------------------------------------------------------------      -- STEP 20:   Validate or Repair the Volume Root Directory      --------------------------------------------------------------------------      VI.ValidateAndRepairRootDirectory[@lvbi, lvHandle, tok];      --------------------------------------------------------------------------      -- STEP 21:  Cleanup.  The allocated memory will be freed here.           --------------------------------------------------------------------------            CleanupVerifier[];            RETURN;      END; --VerifierAccessProc--           END...  LOG00-00-87  00:00:00	RRR	Created file.27-Oct-87 19:28:24	ET	Put commented out minimalScavenge back in.18-Nov-87  7:22:13      ET      Added call to FastVerify in STEP 9b. (AR 11895).11-Dec-87 16:29:26	ET	Only ClearDataLostTable if the scavenger log is fresh. (AR 11896). Added badPilotData and badPilotPage logic. Took out BUG[unexpectedHardwareError] in last steps of 9b to WritePage calls, cause the ReadParallelAndCorrect only did not subsitute bad pages. Step 10 will do that. (AR 12437).17-Dec-87 10:13:22	ET	Added badETableInBucket logic (AR 11904).12-Jan-88  0:07:58	ET	Various fixes for AR 12589 - Handle mugging preimage log in STEP 7 when numberOfPagesLogged = 0. Handle badFirstPageOfOverflow in STEP 10. Special case problemFilePage in STEP 10. Change badFirstPageOfPreimageLog in STEP 10 to badLogPage and test for first page. Make sure marker page is written out if badHeaderOfEtables files. (STEP 10 again). Move STEP 10 in procedure, FixETableFilePages so we compile past pass 5.20-Jan-88 18:35:38	ET	Fix AR 12663 - FileIds too high even after Erase, since largestAllocatedFileID is only initialized at start module time. (Reset globals largestAllocatedFileID, fileListOverflowed, errorListOverflowed, mustCompactOverflowFiles in InitializeVerifier. Remove unused globals lvRootValid, lvMarkerValid, logBufferSize. Changed global variable maximumNumberOfFilesInFileList to global constant). 5-Feb-88 17:57:07     ET       Fix AR 12766 - Have STEP 16 IF stmt LOGIC not LOOP all the time for when bad client pages exist. 18-Mar-88 14:24:01     ET	Added UNWINDs to VerifierWithLock, Verifier, and CompactDisk.29-Jun-88 17:29:46     RSV      Changed AddFileToFileList to be a function.  dataLos is no longer a LONG POINTER but rather the BOOLEAN itself.  Deleted copyUsed and deleted variables.
-- Copyright (C) 1984, 1985, 1986, 1987  by Xerox Corporation. All rights reserved. -- FileMgr>VolumeImpl.mesa      6-Dec-87 18:21:50 by RSV    << NOTES:  * For clarity, the following interfaces have been opened with rename:    VolAllocMap => VAM, LogicalVolumeFormat => LVF.  * All PUBLIC items which don't name the interface they are exported to    are exported to Volume.  * The invariant which is preserved across volume Creates, Opens and Closes is    that a volume is writable when closed.  This is convenient for Open: and    Erase, which want either an open or closed volume and need for it to be    writable.  * A number of operations need to access the logical volume root page when the    volume is in the online state.    - If the seal is incorrect, the page is assumed to be trash and      NeedsScavenging is raised.    - If any but the invariant fields of the root page (as defined by      LogicalVolumeFormat) need to be accessed, the version number of the root      page and the changing flag are also checked.  If the version is not       current or the changing flag is set, NeedsScavenging is raised.>>DIRECTORY   BackingStore USING [Data, Run],   Boot USING [DiskFileID, Location, LVBootFiles, NullDiskFileID, VolumeType],   DataTransfer USING [DiskStatusToDataStatus, ReadData],   DebuggerSwap USING [canSwap, parameters],   Device USING [nullType, Type],   DiskBackingStore USING [Data, Transfer],   DiskChannel USING [      defaultTries, DoIO, Drive, GetDriveAttributes, GetPageNumber, Handle,      IORequest, IOStatus],   Environment USING [PageCount, PageNumber],   ETable USING [Close, MinPagesForETables, Open],   File USING [File, ID, nullFile, nullID, PageCount, Type, Unknown],   FileBasicsPerf USING [ForceConsistency],   FileInternal USING [CreateInternal, MakePermanentOrTemporary],   FileTypes USING [tUntypedFile],   FMPrograms USING [],   KernelSpaceUsage USING [lvRootPage, markerPage],   KernelVolume USING [EraseLV],   LogicalVolumeFormat USING [      currentVersion, Handle, MaxEntriesInRootDirectory,      maxLogicalVolumeLabelLength, MaxPagesInRootDirectory, nullBoot,      RootDirectory, RootDirEntry, RootDirSeal, RootDirVersion, rootPageNumber,      rootPageSize, lvRootSeal, SetETable, SetFree, SetVam],   PhysicalVolume USING [Error, ID, PageCount, PageNumber],   PhysicalVolumeFormat USING [      DuplicateHandle, duplicateRootPageSize, Handle, MarkerHandle,      markerPageSize, maxSubVols, rootPageSize],   PilotDisk USING [nullFileID],   PilotFileTypes USING [tRootDirectory],   PilotMP USING [cBadDebuggerPointers],   PilotSwitches USING [remoteDebug],   PilotSwitchesExtra7 USING [volumeAccessWatching],   PrincOps USING [LocalFrameHandle],   ProcessorFace USING [SetMP],   RuntimeInternal USING [Bug],   Scavenger USING [Error],   ScavengerUtilities USING [      CheckLVConsistency, FreeLVMarkerPages, GatherLVMarkerPages, SVInfo],   SimpleFile USING [GetBackingStoreData, UpdateLogicalMarkerPages],   Space USING [      Allocate, Deallocate, InsufficientSpace, Interval,      PageFromLongPointer],   SpecialRuntime USING [GetCurrentSignal, ReraiseError],   SpecialVolume USING [Access, InvalidParameters],   System USING [      GetUniversalID, GetGreenwichMeanTime, GreenwichMeanTime, PhysicalVolumeID,      switches],   VerifierInternal USING [VerifierWithLock],   VM USING [      Deactivate, ForceOut, Interval, MakeResident, MakeSwappable, Map,      nullInterval, PageNumber, ScratchMap, Unmap],   VolAllocMap USING [Close, PagesForVam],   VolTable USING [      GetDiskChannel, GetDrive, GetNextLV, GetNextSV,      GetLVStatus, GetSVToken, LockEntireLV, LockState, LVAccess, LVAccessProc,      LVEntryState, LVToken, MapDuplicatePVRootPage,      MapPVRootPage, nullSVDesc, PVAccess, PVAccessProc, PVToken,      RootPageReadability, SetClosed, SetLVOffline, SetLVOnline, SetOpen,      SetReadOnlyStatus, SetSVOnline, SVAccess, SVAccessProc, SVDesc, SVToken,      TableAccess, TableAccessProc, UnmapDuplicatePVRootPage,      UnmapPVRootPage],   Volume USING [      Error, ErrorType, ID, NotOpen, nullID, onlyEnumerateCurrentType, PageCount,      PageNumber, ReadOnly, RootDirectoryErrorType, Status, systemID, Type,      TypeSet],      VolumeInternal USING [LockVolume, UnlockVolume];VolumeImpl: MONITOR  -- lock protects volume root directory operations   IMPORTS      Boot, DataTransfer, DebuggerSwap, DiskBackingStore, DiskChannel, ETable,      File, FileBasicsPerf, FileInternal, KernelVolume, LogicalVolumeFormat,      PhysicalVolume, ProcessorFace, RuntimeInternal, Scavenger,      ScavengerUtilities, SimpleFile, Space, SpecialRuntime, SpecialVolume,      System, VerifierInternal, VM, VolAllocMap, VolTable, Volume, VolumeInternal   EXPORTS FMPrograms, KernelVolume, SpecialVolume, VolTable, Volume =   BEGIN OPEN  VAM: VolAllocMap, LVF: LogicalVolumeFormat;   -- EXPORTED TYPES, VARIABLES, and ERRORS   ClientData: PUBLIC --VolTable-- TYPE = Space.Interval;   systemID: PUBLIC Volume.ID ¬ Volume.nullID;   debuggerVolumeID: PUBLIC Volume.ID ¬ Volume.nullID;   maxEntriesInRootDirectory: PUBLIC CARDINAL ¬ LVF.MaxEntriesInRootDirectory;   minPagesPerVolume: PUBLIC Volume.PageCount ¬ 500;   -- The volume space Pilot estimates it needs for its own data structures   -- on a volume.   InsufficientSpace: PUBLIC ERROR [      currentFreeSpace: Volume.PageCount, volume: Volume.ID] = CODE;   NeedsScavenging: PUBLIC ERROR [volume: Volume.ID] = CODE;   NotOnline: PUBLIC ERROR [volume: Volume.ID] = CODE;   NotOpen: PUBLIC ERROR [volume: Volume.ID] = CODE;   ReadOnly: PUBLIC ERROR [volume: Volume.ID] = CODE;   Unknown: PUBLIC ERROR [volume: Volume.ID] = CODE;   Error: PUBLIC ERROR [error: Volume.ErrorType] = CODE;   RootDirectoryError: PUBLIC ERROR [type: Volume.RootDirectoryErrorType] = CODE;   InvalidParameters: PUBLIC --SpecialVolume-- ERROR = CODE;   -- TYPES   RootDirectoryIndex: TYPE = CARDINAL [0..LVF.MaxEntriesInRootDirectory);   RootDirectoryAccessProc: TYPE = PROCEDURE;   RootDirectoryAccessMode: TYPE = VolTable .LockState[read..write];   BugType: TYPE = {      diskChannelError, diskNotAvailable, fileSystemError, noSuchCase, outOfVM,      whereDidTheSystemVolumeGo};   -- GLOBAL VARIABLES   systemVolumeType: Boot.VolumeType;   rootDirectory: LONG POINTER TO LVF.RootDirectory;   rootDirectoryPage: Environment.PageNumber;   doVolumeLocking: BOOLEAN ¬ FALSE;  -- no Pilot switch, no locking.   -- Initialization   InitVolume: PUBLIC --FMPrograms-- PROCEDURE [] =      -- Initializes the Volume Implementation.      BEGIN      IF minPagesPerVolume <         (VAM.PagesForVam[minPagesPerVolume] + 	 ETable.MinPagesForETables[minPagesPerVolume] +         LVF.rootPageSize) THEN Bug[fileSystemError];      << Check that our notion of minPagesPerVolume is correct.       Implementation note: in the future this might also include the       rootDirectory, and scavenger log: i.e., space for       whatever it takes for Volume.Create to succeed in a given instantiation       of Pilot. >>      rootDirectory ¬ Space.Allocate[LVF.MaxPagesInRootDirectory].pointer;      -- Allocate VM for root directory buffer      rootDirectoryPage ¬ Space.PageFromLongPointer[rootDirectory];      IF System.switches[PilotSwitchesExtra7.volumeAccessWatching] = down THEN        doVolumeLocking ¬ ~doVolumeLocking;      END;  --InitVolume   -- MAIN PROCEDURES   Bug: PROCEDURE [bugType: BugType] = {RuntimeInternal.Bug[bugType]};   BugWithValue: PROCEDURE [bugType: BugType] RETURNS [UNSPECIFIED] = {      RuntimeInternal.Bug[bugType]; RETURN[0]};   AllRightToTakePVAway: PUBLIC --KernelVolume-- PROCEDURE [      pvID: PhysicalVolume.ID] RETURNS [allRight: BOOLEAN] =      BEGIN      svDesc: VolTable.SVDesc;      OfflineLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         VolTable.SetLVOffline[tok];  --unmaps the root page if volume was online         IF lvHandle # NIL THEN            Space.Deallocate[[pointer: lvHandle, count: LVF.rootPageSize]];         END;  --OfflineLVProc      -- NOTE: volume table is locked, so nothing can disappear between operations      -- First check for open volumes:      VolTable.GetNextSV[[byPV[pvToEnum: pvID, sv: [first[]]]], @svDesc];        UNTIL svDesc = VolTable.nullSVDesc DO        IF VolTable.GetLVStatus[svDesc.lvID].entryState = open THEN          RETURN[allRight: FALSE];	VolTable.GetNextSV[[byPV[pvToEnum: pvID, sv: [next[svDesc.pvPageOfSV]]]], @svDesc];        ENDLOOP;      -- Assert: no LVs of this PV are open      -- Offline them:      VolTable.GetNextSV[[byPV[pvToEnum: pvID, sv: [first[]]]], @svDesc];      UNTIL svDesc = VolTable.nullSVDesc DO        VolTable.LVAccess[          lvID: svDesc.lvID, proc: OfflineLVProc, lock: maybeWrite,          entryState: partiallyOnline];	VolTable.GetNextSV[[byPV[pvToEnum: pvID, sv: [next[svDesc.pvPageOfSV]]]], @svDesc];        ENDLOOP;      RETURN[allRight: TRUE];      END;  --AllRightToTakePVAway   ChangeLabelString: PUBLIC PROCEDURE [volume: Volume.ID, newLabel: LONG STRING] =      BEGIN      ChangeLabelLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         lvHandle.labelLength ¬            IF newLabel = NIL THEN 0            ELSE MIN[newLabel.length, LVF.maxLogicalVolumeLabelLength];         FOR i: CARDINAL IN [0..lvHandle.labelLength) DO            lvHandle.label[i] ¬ newLabel[i]; ENDLOOP;         SimpleFile.UpdateLogicalMarkerPages[lvHandle, tok];         END;  --ChangeLabelLVProc      VolTable.LVAccess[         lvID: volume, proc: ChangeLabelLVProc, lock: writeWithChangingFlag,         entryState: open];      END;  -- ChangeLabelString   ChangeVolumeType: PUBLIC --SpecialVolume-- PROCEDURE [      lvID: Volume.ID, newType: Volume.Type] =      BEGIN      ChangeTypeLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         lvHandle.type ¬ newType;         SimpleFile.UpdateLogicalMarkerPages[lvHandle, tok];         END;  --ChangeTypeLVProc      VolTable.LVAccess[         lvID: lvID, proc: ChangeTypeLVProc, lock: writeWithChangingFlag,         entryState: open !         Volume.NotOpen, Volume.ReadOnly => ERROR SpecialVolume.InvalidParameters];      END;  --ChangeVolumeType   Close: PUBLIC PROCEDURE [volume: Volume.ID] =      BEGIN      CloseLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         ENABLE ANY => Bug[fileSystemError];         -- We don't use ForceConsistency below since we want to unmap,         -- not forceOut, buffers.         ETable.Close[token: tok];         VAM.Close[vol: volume, disposition: unmap, tok: tok];         IF lvHandle.changing THEN lvHandle.changing ¬ FALSE;	 IF doVolumeLocking THEN VolumeInternal.UnlockVolume[lvHandle];         VM.Deactivate[  -- overrides any operation sequence in effect            [page: Space.PageFromLongPointer[lvHandle], count: LVF.rootPageSize],            wait];         VolTable.SetReadOnlyStatus[tok: tok, readOnly: FALSE];         VolTable.SetClosed[tok];         END;  --CloseLVProc      IF volume = systemID THEN {         ClosingSystemVolumeNotAllowed: PRIVATE ERROR = CODE;  -- public someday?         ERROR ClosingSystemVolumeNotAllowed};      VolTable.LVAccess[         lvID: volume, proc: CloseLVProc, lock: maybeWrite, entryState: open !         Volume.NotOpen => CONTINUE];      END;  --Close   Create: PUBLIC PROCEDURE [      pvID: System.PhysicalVolumeID, size: Volume.PageCount, name: LONG STRING,      type: Volume.Type, minPVPageNumber: PhysicalVolume.PageNumber]      RETURNS [volume: Volume.ID] =      BEGIN      CreateLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         lvToken: VolTable.LVToken = tok;  --avoid later name conflict         rootPageBuffer: LVF.Handle ¬ NIL;         EraseSVProc: VolTable.SVAccessProc --[tok]--  = {            KernelVolume.EraseLV[volume, rootPageBuffer, lvToken]};         CreatePVProc: VolTable.PVAccessProc --[tok, rootPageLoc]--  =            BEGIN            pvToken: VolTable.PVToken = tok;  --avoid later name conflict            CreateSVProc: VolTable.SVAccessProc --[tok]--  =               BEGIN               svToken: VolTable.SVToken = tok;  --for clarity only               pvHandle: PhysicalVolumeFormat.Handle ¬ NIL;               duplicatePVHandle: PhysicalVolumeFormat.DuplicateHandle ¬ NIL;               thisSV: CARDINAL;               thisSVStartPage: PhysicalVolume.PageNumber;               actualSize: Volume.PageCount ¬ size;               markerPageSize: CARDINAL [1..1] = CARDINAL[                  PhysicalVolumeFormat.markerPageSize];               rootPageMapped: BOOLEAN ¬ FALSE;               markerPageBuffer: PhysicalVolumeFormat.MarkerHandle ¬ NIL;               diskChannel: DiskChannel.Handle;               request: DiskChannel.IORequest;               CleanUp: PROCEDURE =  --use for cleanup after errors                  BEGIN                  IF pvHandle # NIL THEN {                     VolTable.UnmapPVRootPage[pvToken, pvHandle];                     Space.Deallocate[                        [pvHandle, PhysicalVolumeFormat.rootPageSize]]};		  IF duplicatePVHandle # NIL THEN {		     VolTable.UnmapDuplicatePVRootPage[		        pvToken, duplicatePVHandle];		     Space.Deallocate[[duplicatePVHandle,		        PhysicalVolumeFormat.duplicateRootPageSize]]};                  IF rootPageMapped THEN                     VM.Unmap[Space.PageFromLongPointer[rootPageBuffer]];                  IF rootPageBuffer # NIL THEN                     Space.Deallocate[[rootPageBuffer, LVF.rootPageSize]];                  IF markerPageBuffer # NIL THEN {                     VM.Unmap[page: Space.PageFromLongPointer[markerPageBuffer]];                     Space.Deallocate[                        [markerPageBuffer, PhysicalVolumeFormat.markerPageSize]]};                  END;  --CleanUp               DoDiskIO: PROCEDURE [                  channel: DiskChannel.Handle,                  ioRequest: LONG POINTER TO DiskChannel.IORequest] =                  BEGIN                  status: DiskChannel.IOStatus;                  status ¬ DiskChannel.DoIO[channel, ioRequest].status;                  WITH s: status SELECT FROM                     invalidChannel => Bug[diskNotAvailable];                     invalidDriveState => Bug[fileSystemError];                     disk =>                        SELECT s.status FROM                           goodCompletion => NULL;                           inProgress, clientError, operationReset, otherError =>                              Bug[diskChannelError];                           notReady => Bug[diskNotAvailable];                           ENDCASE => PhysicalVolume.Error[hardwareError];                     ENDCASE => Bug[noSuchCase];                  END;  --DoDiskIO               CreateMarkerPage: PROCEDURE [                  physicalSubvolumeNumber: CARDINAL, channel: DiskChannel.Handle] =                  BEGIN OPEN sv: pvHandle.subVolumes[physicalSubvolumeNumber];                  -- Note the OPEN                  request: DiskChannel.IORequest;                  markerPageBuffer ¬ Space.Allocate[                     PhysicalVolumeFormat.markerPageSize !                     Space.InsufficientSpace => Bug[outOfVM]].pointer;                  VM.Map[                     interval: [                     page: Space.PageFromLongPointer[markerPageBuffer],                     count: PhysicalVolumeFormat.markerPageSize],                     transferProc: NIL, backingStoreRuns: NIL,                     swapUnits: [unitary[]], life: dead, swappability: resident,                     usage: KernelSpaceUsage.markerPage];                  markerPageBuffer­ ¬ [logical: [                     labelLength: rootPageBuffer.labelLength,                     type: rootPageBuffer.type, label: rootPageBuffer.label,                     bootingInfo: rootPageBuffer.bootingInfo,                     volumeRootDirectory: rootPageBuffer.volumeRootDirectory]];                  request ¬ [                     diskPage: sv.pvPage + sv.nPages,                     memoryPage: Space.PageFromLongPointer[markerPageBuffer],		     tries: DiskChannel.defaultTries,                     count: PhysicalVolumeFormat.markerPageSize,		     useSamePage: FALSE, command: write];                  DoDiskIO[channel, @request];                  VM.Unmap[page: Space.PageFromLongPointer[markerPageBuffer]];                  Space.Deallocate[                     [markerPageBuffer, PhysicalVolumeFormat.markerPageSize]];                  markerPageBuffer ¬ NIL;                  END;  --CreateMarkerPage               -- Begin main text of CreateSVProc               BEGIN               ENABLE { UNWIND => NULL; ANY => {CleanUp[]; REJECT}};               pvHandle ¬ Space.Allocate[                  PhysicalVolumeFormat.rootPageSize !                  Space.InsufficientSpace => Bug[outOfVM]].pointer;               VolTable.MapPVRootPage[tok: pvToken, rootPage: pvHandle];               VM.MakeResident[                  interval: [                  page: Space.PageFromLongPointer[pvHandle],                  count: PhysicalVolumeFormat.rootPageSize], returnWait: wait];               duplicatePVHandle ¬ Space.Allocate[                  PhysicalVolumeFormat.duplicateRootPageSize !                  Space.InsufficientSpace => Bug[outOfVM]].pointer;               VolTable.MapDuplicatePVRootPage[	         tok: pvToken, rootPage: duplicatePVHandle];               VM.MakeResident[                  interval: [                  page: Space.PageFromLongPointer[duplicatePVHandle],                  count: PhysicalVolumeFormat.duplicateRootPageSize],		  returnWait: wait];	       -- Need to guarantee that pv root pages are not swapped out until               -- marker pages have been written.               IF (thisSV ¬ pvHandle.subVolumeCount) >=                  PhysicalVolumeFormat.maxSubVols THEN                  ERROR Volume.Error[tooManySubvolumes];               thisSVStartPage ¬                  IF thisSV = 0 THEN                  rootPageLoc + PhysicalVolumeFormat.rootPageSize                  ELSE                     pvHandle.subVolumes[thisSV - 1].pvPage + pvHandle.subVolumes[                        thisSV - 1].nPages + PhysicalVolumeFormat.markerPageSize;               thisSVStartPage ¬ MAX[thisSVStartPage, minPVPageNumber];               -- Assure LVRootPage on a good page               WHILE IsBadPage[pvHandle, thisSVStartPage] DO                  thisSVStartPage ¬ thisSVStartPage + 1;                  IF (actualSize ¬ actualSize - 1) < minPagesPerVolume THEN                     ERROR Volume.Error[subvolumeHasTooManyBadPages];                  ENDLOOP;               -- Assure MarkerPage on a good page               WHILE IsBadPage[pvHandle, thisSVStartPage + actualSize] DO                  IF (actualSize ¬ actualSize - 1) < minPagesPerVolume THEN                     ERROR Volume.Error[subvolumeHasTooManyBadPages];                  ENDLOOP;               BEGIN               goodPages: PhysicalVolume.PageCount ¬ 0;               FOR page: PhysicalVolume.PageNumber IN                  [thisSVStartPage..thisSVStartPage + actualSize] DO                  IF NOT IsBadPage[pvHandle, page]                     AND ((goodPages ¬ goodPages + 1) >= minPagesPerVolume) THEN                     EXIT;                  -- Should really look for contiguous VAM, but prob. not worth                  -- the extra code                  REPEAT                     FINISHED => ERROR Volume.Error[subvolumeHasTooManyBadPages];                  ENDLOOP;               END;               IF thisSVStartPage + actualSize >= DiskChannel.GetDriveAttributes[                  VolTable.GetDrive[pvToken]].nPages THEN                  ERROR PhysicalVolume.Error[insufficientSpace];               rootPageBuffer ¬ Space.Allocate[                  LVF.rootPageSize !                  Space.InsufficientSpace => Bug[outOfVM]].pointer;               VM.Map[                  interval: [                  page: Space.PageFromLongPointer[rootPageBuffer],                  count: LVF.rootPageSize], usage: KernelSpaceUsage.lvRootPage,                  transferProc: NIL, backingStoreRuns: NIL, swapUnits: [unitary[]],                  life: dead, swappability: resident];               rootPageMapped ¬ TRUE;               -- Fill in root page:               rootPageBuffer­ ¬ [                  vID: volume, type: type, volumeSize: actualSize, changing: TRUE];               LVF.SetFree[rootPageBuffer];               LVF.SetVam[rootPageBuffer];	       LVF.SetETable[rootPageBuffer];               rootPageBuffer.labelLength ¬ MIN[                  name.length, LVF.maxLogicalVolumeLabelLength];               FOR i: CARDINAL IN [0..rootPageBuffer.labelLength) DO                  rootPageBuffer.label[i] ¬ name[i]; ENDLOOP;               -- Write it all out               diskChannel ¬ VolTable.GetDiskChannel[pvToken];               request ¬ [                  diskPage: thisSVStartPage,                  memoryPage: Space.PageFromLongPointer[rootPageBuffer],		  tries: DiskChannel.defaultTries,                  count: LVF.rootPageSize, useSamePage: FALSE,		  command: write];               DoDiskIO[diskChannel, @request];               pvHandle.subVolumes[pvHandle.subVolumeCount] ¬ [                  lvID: volume, lvSize: actualSize, lvPage: LVF.rootPageNumber,                  pvPage: thisSVStartPage, nPages: actualSize];	       duplicatePVHandle.subVolumes[duplicatePVHandle.subVolumeCount] ¬ [                  lvID: volume, lvSize: actualSize, lvPage: LVF.rootPageNumber,                  pvPage: thisSVStartPage, nPages: actualSize];               pvHandle.subVolumeCount ¬ pvHandle.subVolumeCount + 1;	       duplicatePVHandle.subVolumeCount ¬	          duplicatePVHandle.subVolumeCount + 1;               -- We can now write the subvolume structures               CreateMarkerPage[                  physicalSubvolumeNumber: thisSV, channel: diskChannel];               VolTable.SetSVOnline[                  tok: svToken, pvPageOfSV: thisSVStartPage,                  lvPageOfSV: LVF.rootPageNumber, svLength: actualSize];	       VM.MakeSwappable[                  interval: [                  page: Space.PageFromLongPointer[duplicatePVHandle],                  count: PhysicalVolumeFormat.duplicateRootPageSize]];               VM.ForceOut[                  [                  page: Space.PageFromLongPointer[duplicatePVHandle],                  count: PhysicalVolumeFormat.duplicateRootPageSize], wait];               VM.MakeSwappable[                  interval: [                  page: Space.PageFromLongPointer[pvHandle],                  count: PhysicalVolumeFormat.rootPageSize]];               VM.ForceOut[                  [                  page: Space.PageFromLongPointer[pvHandle],                  count: PhysicalVolumeFormat.rootPageSize], wait];               rootPageBuffer.changing ¬ FALSE;               request ¬ [                  diskPage: thisSVStartPage,                  memoryPage: Space.PageFromLongPointer[rootPageBuffer],		  tries: DiskChannel.defaultTries,                  count: LVF.rootPageSize, useSamePage: FALSE,		  command: write];               DoDiskIO[diskChannel, @request];               IF NOT IsConsistentInternal[volume, rootPageBuffer, lvToken] THEN                  Bug[fileSystemError];               VM.Unmap[page: Space.PageFromLongPointer[rootPageBuffer]];               rootPageMapped ¬ FALSE;               VolTable.SetLVOnline[                  tok: lvToken, rootPage: rootPageBuffer,                  readability: rootPageUnreadable];               END;  --ENABLE               VolTable.UnmapDuplicatePVRootPage[pvToken, duplicatePVHandle];	       VolTable.UnmapPVRootPage[pvToken, pvHandle];               Space.Deallocate[[pvHandle, PhysicalVolumeFormat.rootPageSize]];	       Space.Deallocate[[duplicatePVHandle,	          PhysicalVolumeFormat.duplicateRootPageSize]];               END;  --CreateSVProc            VolTable.SVAccess[               pvID: pvID, lvID: volume, lvPage: LVF.rootPageNumber,               proc: CreateSVProc, lock: write, entryState: offline];            END;  --CreatePVProc         VolTable.PVAccess[            pvID: pvID, proc: CreatePVProc, lock: write, entryState: online];         IF type # nonPilot THEN            VolTable.SVAccess[               pvID: pvID, lvID: volume, lvPage: LVF.rootPageNumber,               proc: EraseSVProc, lock: write, entryState: online];         --Scavenger currently does a PVAccess, so this call needs to be here.         END;  --CreateLVProc      IF name = NIL OR name.length = 0 THEN ERROR Volume.Error[nameRequired];      IF size < minPagesPerVolume THEN         ERROR Volume.Error[pageCountTooSmallForVolume];      volume ¬ [System.GetUniversalID[]];      VolTable.LVAccess[         lvID: volume, proc: CreateLVProc, lock: maybeWrite, entryState: offline];      END;  --Create   Erase: PUBLIC PROCEDURE [volume: Volume.ID] =      BEGIN      EraseLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         volumeState: VolTable.LVEntryState;         volumeState ¬ VolTable.GetLVStatus[volume].entryState;         IF volumeState = open THEN VolTable.SetClosed[tok];         KernelVolume.EraseLV[volume, lvHandle, tok];         IF volumeState = open THEN VolTable.SetOpen[tok];         END;  --EraseLVProc      IF volume = systemID THEN {         ErasingSystemVolumeNotAllowed: PRIVATE ERROR = CODE;  -- public someday?         ERROR ErasingSystemVolumeNotAllowed};      VolTable.LockEntireLV[         lvID: volume, proc: EraseLVProc, lock: write, entryState: allSVsOnline];      END;  --Erase   FindDebugger: PUBLIC --FMPrograms-- PROCEDURE [      pvID: PhysicalVolume.ID, pDebuggerResult: POINTER TO Boot.DiskFileID,      pDebuggeeResult: POINTER TO Boot.DiskFileID]      RETURNS [debuggerDeviceType: Device.Type, debuggerDeviceOrdinal: CARDINAL] =      BEGIN      FindDebuggerTableAccessProc: VolTable.TableAccessProc =         BEGIN         FindDebuggerPVProc: VolTable.PVAccessProc --[tok, rootPageLoc]--  =            BEGIN            lvBootFiles: Boot.LVBootFiles;            drive: DiskChannel.Drive ¬ VolTable.GetDrive[tok];            SELECT TRUE FROM               System.switches[PilotSwitches.remoteDebug] = down =>                  GO TO NoLocalDebugger;               DebuggerSwap.canSwap =>  --                  -- Debugger pointers are set. If can't prove them wrong, believe them.                  BEGIN		  svDesc: VolTable.SVDesc;                  debuggerPage: PhysicalVolume.PageNumber ¬                     DiskChannel.GetPageNumber[                     drive, DebuggerSwap.parameters.locDebugger.diskFileID.da];                  -- Find volume this page lives in:  i.e., set debuggerVolumeID                  VolTable.GetNextSV[[byPV[pvToEnum: pvID, sv: [first[]]]], @svDesc];		  UNTIL svDesc = VolTable.nullSVDesc DO                    IF debuggerPage IN                       [svDesc.pvPageOfSV..svDesc.pvPageOfSV + svDesc.svLength)                       THEN                       BEGIN                       GetLogicalVolumeBootFiles[svDesc.lvID, @lvBootFiles];                       IF lvBootFiles[debugger] #                          DebuggerSwap.parameters.locDebugger.diskFileID                          OR lvBootFiles[debuggee] #                             DebuggerSwap.parameters.locDebuggee.diskFileID THEN                          GO TO DebuggerPointersAreWrong                       ELSE                          BEGIN                          debuggerVolumeID ¬ svDesc.lvID;                          pDebuggerResult­ ¬                             DebuggerSwap.parameters.locDebugger.diskFileID;                          pDebuggeeResult­ ¬                             DebuggerSwap.parameters.locDebuggee.diskFileID;                          [deviceType: debuggerDeviceType,                             deviceOrdinal: debuggerDeviceOrdinal] ¬                             DiskChannel.GetDriveAttributes[drive];                          RETURN;                          END;                       END;		    VolTable.GetNextSV[[byPV[pvToEnum: pvID, sv: [next[svDesc.pvPageOfSV]]]], @svDesc];                    REPEAT                       FINISHED =>  -- Debugger pointers set to nonexistent volume                          GO TO DebuggerPointersAreWrong;                    ENDLOOP;                  EXITS                     DebuggerPointersAreWrong => {                        DO                           ProcessorFace.SetMP[PilotMP.cBadDebuggerPointers];                           ENDLOOP};                  END;               ENDCASE =>                  BEGIN  --look for debugger on local disk--		  svDesc: VolTable.SVDesc;                  IF systemVolumeType = nonPilot                     OR systemVolumeType = debuggerDebugger THEN                     GO TO NoLocalDebugger;  -- these guys have no debugger                  VolTable.GetNextSV[[byPV[pvToEnum: pvID, sv: [first[]]]], @svDesc];		  UNTIL svDesc = VolTable.nullSVDesc DO BEGIN                    type: Volume.Type =                       GetType[                       svDesc.lvID !  -- violates locking heirarchy                       NeedsScavenging, NotOnline => EXIT];                    IF ((systemVolumeType = normal AND type = debugger)                             OR                                (systemVolumeType = debugger                                   AND type = debuggerDebugger)) THEN                       BEGIN                       GetLogicalVolumeBootFiles[svDesc.lvID, @lvBootFiles];                       IF Boot.NullDiskFileID[lvBootFiles[debugger]]                          OR Boot.NullDiskFileID[lvBootFiles[debuggee]] THEN  --                          EXIT;  -- Keep looking                       pDebuggerResult­ ¬ lvBootFiles[debugger];                       pDebuggeeResult­ ¬ lvBootFiles[debuggee];                       [deviceType: debuggerDeviceType,                          deviceOrdinal: debuggerDeviceOrdinal] ¬                          DiskChannel.GetDriveAttributes[drive];                       debuggerVolumeID ¬ svDesc.lvID;                       RETURN;                       END;		    END;		    VolTable.GetNextSV[[byPV[pvToEnum: pvID, sv: [next[svDesc.pvPageOfSV]]]], @svDesc];                    ENDLOOP;                  GO TO NoLocalDebugger;                  END;  --look for debugger on local disk--            EXITS               NoLocalDebugger =>                  BEGIN                  -- Leave debuggerVolumeID as Volume.nullID;                  pDebuggerResult­ ¬ pDebuggeeResult­ ¬ [                     fID: PilotDisk.nullFileID, firstPage: 0,                     da: LOOPHOLE[LONG[0]]];                  debuggerDeviceType ¬ Device.nullType;                  debuggerDeviceOrdinal ¬ LAST[CARDINAL];                  RETURN;                  END;            END;  --FindDebuggerPVProc         VolTable.PVAccess[            pvID: pvID, proc: FindDebuggerPVProc, lock: read, entryState: online];         END;  --FindDebuggerTableAccessProc      << We need to violate the volume table locking hierarchy, so we get a         table lock. Since this procedure is called only at system init. time,	 getting a lock on the whole table doesn't make any difference anyway.>>      VolTable.TableAccess[FindDebuggerTableAccessProc];      END;  --FindDebugger--   FindSystemLV: PUBLIC --FMPrograms-- PROCEDURE [      pvID: PhysicalVolume.ID,      bootFile: LONG POINTER TO READONLY disk Boot.Location] =      BEGIN      FindSystemLVPVProc: VolTable.PVAccessProc --[tok, rootPageLoc]--  =         BEGIN	 svDesc: VolTable.SVDesc;         drive: DiskChannel.Drive ¬ VolTable.GetDrive[tok];         bootFilePage: PhysicalVolume.PageNumber ¬ DiskChannel.GetPageNumber[            drive, bootFile.diskFileID.da];         -- Find volume this bootFilePage lives in         VolTable.GetNextSV[[byPV[pvToEnum: pvID, sv: [first[]]]], @svDesc];	 UNTIL svDesc = VolTable.nullSVDesc DO           IF bootFilePage IN              [svDesc.pvPageOfSV..svDesc.pvPageOfSV + svDesc.svLength) THEN             BEGIN             systemID ¬ svDesc.lvID;             -- (can't get sys vol type now cause may need scavenging.)             RETURN;             END;	   VolTable.GetNextSV[[byPV[pvToEnum: pvID, sv: [next[svDesc.pvPageOfSV]]]], @svDesc];           ENDLOOP;         Bug[whereDidTheSystemVolumeGo];         END;  --FindSystemLVPVProc      VolTable.PVAccess[pvID, FindSystemLVPVProc, read, online];      END;  --FindSystemLV--   GetAttributes: PUBLIC PROCEDURE [volume: Volume.ID]      RETURNS [volumeSize, freePageCount: Volume.PageCount, readOnly: BOOLEAN] =      BEGIN      GetAttributesLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         entryState: VolTable.LVEntryState;         IF lvHandle.seal # LVF.lvRootSeal OR lvHandle.version # LVF.currentVersion            THEN ERROR NeedsScavenging[volume];         [entryState, readOnly] ¬ VolTable.GetLVStatus[volume];         IF entryState # open AND lvHandle.changing THEN            ERROR NeedsScavenging[volume];         volumeSize ¬ lvHandle.volumeSize;         freePageCount ¬ lvHandle.freePageCount;         END;  --GetAttributesLVProc      VolTable.LVAccess[         lvID: volume, proc: GetAttributesLVProc, lock: read, entryState: online];      END;  --GetAttributes   GetLabelString: PUBLIC PROCEDURE [volume: Volume.ID, s: LONG STRING] =      BEGIN      GetLabelStringLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         IF lvHandle.seal # LVF.lvRootSeal THEN ERROR NeedsScavenging[volume];         s.length ¬ MIN[s.maxlength, lvHandle.labelLength, LENGTH[lvHandle.label]];         FOR i: CARDINAL IN [0..s.length) DO s[i] ¬ lvHandle.label[i]; ENDLOOP;         END;  --GetLabelStringProc      IF s # NIL THEN         VolTable.LVAccess[            lvID: volume, proc: GetLabelStringLVProc, lock: read,            entryState: online];      END;  --GetLabelString    GetLogicalVolumeBootFiles: PUBLIC --SpecialVolume-- PROCEDURE [      lvID: Volume.ID, pBootFiles: LONG POINTER TO Boot.LVBootFiles] =      BEGIN      GetLogicalVolumeBootFilesLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         IF lvHandle.seal # LVF.lvRootSeal THEN ERROR NeedsScavenging[lvID];         pBootFiles­ ¬ lvHandle.bootingInfo;         END;      IF pBootFiles # NIL THEN         VolTable.LVAccess[            lvID: lvID, proc: GetLogicalVolumeBootFilesLVProc, lock: read,            entryState: online];      END;  --GetLogicalVolumeBootFiles    GetNext: PUBLIC PROCEDURE [      volume: Volume.ID, includeWhichVolumes: Volume.TypeSet]      RETURNS [nextVolume: Volume.ID] =      BEGIN      actualVolSet: Volume.TypeSet ¬ includeWhichVolumes;      IF includeWhichVolumes = Volume.onlyEnumerateCurrentType THEN         BEGIN         IF systemID = Volume.nullID THEN actualVolSet ¬ ALL[TRUE]         ELSE {            actualVolSet ¬ ALL[FALSE];            actualVolSet[GetType[Volume.systemID]] ¬ TRUE};  -- may raise NeedsScavenging.         END;      nextVolume ¬ volume;      DO  -- until suitable volume found         nextVolume ¬ VolTable.GetNextLV[nextVolume];         IF --UNTIL-- nextVolume = Volume.nullID THEN RETURN;         IF VolTable.GetLVStatus[nextVolume].entryState >= online            AND               (actualVolSet = ALL[TRUE]  -- avoiding NeedsScavenging signal                  OR actualVolSet[GetType[nextVolume]]) THEN RETURN;         ENDLOOP;      END;  --GetNext    GetStatus: PUBLIC PROCEDURE [volume: Volume.ID]      RETURNS [status: Volume.Status] =      BEGIN      readOnly: BOOLEAN;      entryState: VolTable.LVEntryState;      [entryState, readOnly] ¬ VolTable.GetLVStatus[volume];      status ¬         SELECT entryState FROM            offline => unknown,            partiallyOnline => partiallyOnLine,            allSVsOnline => closedAndInconsistent,            online =>               IF IsConsistent[volume] THEN closedAndConsistent               ELSE closedAndInconsistent,            open => IF readOnly THEN openRead ELSE openReadWrite,            ENDCASE => BugWithValue[noSuchCase];      END;  --GetStatus   GetType: PUBLIC PROCEDURE [volume: Volume.ID] RETURNS [type: Volume.Type] =      BEGIN      GetTypeLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         IF lvHandle.seal # LVF.lvRootSeal THEN ERROR NeedsScavenging[volume];         type ¬ lvHandle.type;         END;      VolTable.LVAccess[         lvID: volume, proc: GetTypeLVProc, lock: read, entryState: online];      END;  --GetType   IsBadPage: PROCEDURE [      pvHandle: PhysicalVolumeFormat.Handle, page: PhysicalVolume.PageNumber]      RETURNS [BOOLEAN] =      BEGIN      FOR i: CARDINAL IN [0..CARDINAL[pvHandle.badPageCount]) DO         IF pvHandle.badPageList[i] = page THEN RETURN[TRUE]; ENDLOOP;      RETURN[FALSE];      END;  --IsBadPage   IsConsistent: PROCEDURE [volume: Volume.ID] RETURNS [isConsistent: BOOLEAN] =      BEGIN      IsConsistentLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  = {         isConsistent ¬ IsConsistentInternal[volume, lvHandle, tok]};      VolTable.LockEntireLV[         lvID: volume, proc: IsConsistentLVProc, lock: read,         entryState: allSVsOnline];      END;  --IsConsistent   IsConsistentInternal: PROCEDURE [      volume: Volume.ID, lvHandle: LVF.Handle, tok: VolTable.LVToken]      RETURNS [isConsistent: BOOLEAN] =      -- Entire LV must be locked by caller      BEGIN      subvolumeInfo: LONG DESCRIPTOR FOR ARRAY OF ScavengerUtilities.SVInfo;      subvolumeInfo ¬ ScavengerUtilities.GatherLVMarkerPages[tok, volume];      isConsistent ¬ ScavengerUtilities.CheckLVConsistency[         lvHandle, subvolumeInfo].consistent;      ScavengerUtilities.FreeLVMarkerPages[subvolumeInfo];      END;  --IsConsistentInternal   LastOpenedForWrite: PUBLIC --SpecialVolume-- PROCEDURE [lvID: Volume.ID]      RETURNS [System.GreenwichMeanTime] =      BEGIN      time: System.GreenwichMeanTime;            LastOpenedForWriteInternal: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN	 IF lvHandle.changing THEN ERROR NeedsScavenging[lvID];         time ¬ lvHandle.lastTimeOpendForWrite;	 END;	       VolTable.LVAccess[         lvID: lvID, proc: LastOpenedForWriteInternal, lock: read,         entryState: online];      RETURN[time];      END;  -- LastOpenedForWrite   NewPVOnline: PUBLIC --KernelVolume-- PROCEDURE [pvID: PhysicalVolume.ID] =      BEGIN      svOfPV: VolTable.SVDesc;      subvolumeMarkerHandle: PhysicalVolumeFormat.MarkerHandle;      CheckIfNewLVToOnline: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         svOfLV: VolTable.SVDesc;         svToken: VolTable.SVToken;         rootPageReadability: VolTable.RootPageReadability;         rootSubVolumeForThisLV: VolTable.SVDesc;         CheckRootPageReadability: PROCEDURE [            lvID: Volume.ID, lvPage: Volume.PageNumber]            RETURNS [rootPageReadability: VolTable.RootPageReadability] =            BEGIN            diskStatus: DiskChannel.IOStatus;	    interval: Space.Interval ¬ Space.Allocate[1, !                  Space.InsufficientSpace => Bug[outOfVM]];	    vmPage: VM.PageNumber ¬ Space.PageFromLongPointer[interval.pointer];            VM.ScratchMap[[vmPage, interval.count]];            diskStatus ¬ DataTransfer.ReadData[lvID, lvPage, vmPage, FALSE, tok];            VM.Unmap[vmPage];	    Space.Deallocate[interval];            WITH status: diskStatus SELECT FROM               invalidChannel, invalidDriveState => Bug[fileSystemError];               disk =>                  rootPageReadability ¬                     SELECT DataTransfer.DiskStatusToDataStatus[status] FROM			valid => rootPageReadable,                        invalid, diskError => rootPageUnreadable,                        ENDCASE => BugWithValue[noSuchCase];               ENDCASE => Bug[noSuchCase];            END;         LVRootPageInBPT: PROCEDURE [            pvID: PhysicalVolume.ID, page: PhysicalVolume.PageNumber]            RETURNS [inBPT: BOOLEAN] =            BEGIN            LVRootPageInBPTProc: VolTable.PVAccessProc --[tok, rootPageLoc]--  =               BEGIN               pvHandle: PhysicalVolumeFormat.Handle ¬ Space.Allocate[                  PhysicalVolumeFormat.rootPageSize !                  Space.InsufficientSpace => Bug[outOfVM]].pointer;               VolTable.MapPVRootPage[tok, pvHandle];               inBPT ¬ IsBadPage[pvHandle, page];               VolTable.UnmapPVRootPage[tok, pvHandle];               Space.Deallocate[[pvHandle, PhysicalVolumeFormat.rootPageSize]];               END;            VolTable.PVAccess[pvID, LVRootPageInBPTProc, read, online];            END;         -- BEGIN CheckIfNewLVToOnline--         -- Find out how many pages are in the logical volume	          svToken ¬ VolTable.GetSVToken[token: tok, lvPage: svOfPV.lvPageOfSV];	 VolTable.GetNextSV[[byLV[lvToEnum: svOfPV.lvID, sv: [first[]]]], @svOfLV];	 IF svOfLV = VolTable.nullSVDesc THEN RETURN;  --Volume isn't there yet.         rootSubVolumeForThisLV ¬ svOfLV;         -- The logical volume is all there, check root page for readability.	          rootPageReadability ¬            IF LVRootPageInBPT[            rootSubVolumeForThisLV.pvID, rootSubVolumeForThisLV.pvPageOfSV +	    rootSubVolumeForThisLV.lvPageOfSV] THEN rootPageUnreadable            ELSE CheckRootPageReadability[               rootSubVolumeForThisLV.lvID, rootSubVolumeForThisLV.lvPageOfSV];         VolTable.SetLVOnline[            tok: tok, readability: rootPageReadability,            rootPage: Space.Allocate[            LVF.rootPageSize ! Space.InsufficientSpace => Bug[outOfVM]].pointer];         END;  --CheckIfNewLVToOnline      --BEGIN main text of NewPVOnline--      subvolumeMarkerHandle ¬ Space.Allocate[         PhysicalVolumeFormat.markerPageSize !         Space.InsufficientSpace => Bug[outOfVM]].pointer;      BEGIN      ENABLE         UNWIND =>            Space.Deallocate[               [subvolumeMarkerHandle, PhysicalVolumeFormat.markerPageSize]];      VolTable.GetNextSV[[byPV[pvToEnum: pvID, sv: [first[]]]], @svOfPV];      UNTIL svOfPV = VolTable.nullSVDesc DO        IF VolTable.GetLVStatus[svOfPV.lvID].entryState = partiallyOnline THEN           VolTable.LockEntireLV[              lvID: svOfPV.lvID, proc: CheckIfNewLVToOnline, lock: maybeWrite,              entryState: partiallyOnline];        -- Otherwise, we've processed it already	VolTable.GetNextSV[[byPV[pvToEnum: pvID, sv: [next[svOfPV.pvPageOfSV]]]], @svOfPV];        ENDLOOP;      END;  --ENABLE      Space.Deallocate[         [subvolumeMarkerHandle, PhysicalVolumeFormat.markerPageSize]];      END;  --NewPVOnline       Open: PUBLIC PROCEDURE [volume: Volume.ID] =      BEGIN      readOnly: BOOLEAN;      OpenLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         readOnly ¬            (systemID # Volume.nullID AND volume # systemID               AND lvHandle.type > systemVolumeType);         OpenInternal[volume, lvHandle, tok, readOnly];         IF volume = systemID THEN systemVolumeType ¬ lvHandle.type;         END;  --OpenLVProc      VolTable.LockEntireLV[         lvID: volume, proc: OpenLVProc, lock: maybeWrite, entryState: online];      IF ~readOnly THEN FileBasicsPerf.ForceConsistency[volume];      -- Must do this manually since we locked with "maybeWrite".      END;  --Open     OpenInternal: --INTERNAL-- PROCEDURE [      volume: Volume.ID, lvHandle: LVF.Handle, tok: VolTable.LVToken,      readOnly: BOOLEAN] =      -- The entire LV must have been locked by caller to enable Scavenger      -- to run consistency checks      BEGIN      entryState: VolTable.LVEntryState;      entryState ¬ VolTable.GetLVStatus[volume].entryState;      IF entryState = open THEN RETURN;      IF doVolumeLocking THEN VolumeInternal.LockVolume[lvHandle, readOnly];      [] ¬ VerifierInternal.VerifierWithLock[  -- performs IsConsistentInternal        tok, lvHandle, volume, readOnly !	  Scavenger.Error => GO TO needsScavenging];      ETable.Open[tok];      VolTable.SetReadOnlyStatus[tok, readOnly];      IF ~readOnly THEN          lvHandle.lastTimeOpendForWrite ¬ System.GetGreenwichMeanTime[];      VM.ForceOut[  -- eases debugging         [page: Space.PageFromLongPointer[lvHandle], count: LVF.rootPageSize],         wait];      VolTable.SetOpen[tok];      EXITS        needsScavenging => ERROR NeedsScavenging[volume];      END;  --OpenInternal     OpenVolume: PUBLIC --SpecialVolume-- PROCEDURE [      volume: Volume.ID, access: SpecialVolume.Access] =      BEGIN      readOnly: BOOLEAN;      OpenVolumeLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         readOnly ¬            SELECT access FROM               read => TRUE,               readWrite => FALSE,               default =>                  (systemID # Volume.nullID AND volume # systemID                     AND lvHandle.type > systemVolumeType),               ENDCASE => BugWithValue[noSuchCase];         IF volume = systemID THEN systemVolumeType ¬ lvHandle.type;         OpenInternal[volume, lvHandle, tok, readOnly];         END;  --OpenVolumeLVProc      VolTable.LockEntireLV[         lvID: volume, proc: OpenVolumeLVProc, lock: maybeWrite,         entryState: online];      IF ~readOnly THEN FileBasicsPerf.ForceConsistency[volume];      -- Must do this manually since we locked with "maybeWrite".      END;  --OpenVolume     SetLogicalVolumeBootFiles: PUBLIC --SpecialVolume-- PROCEDURE [      lvID: Volume.ID, pBootFiles: LONG POINTER TO Boot.LVBootFiles] =      BEGIN      SetLogicalVolumeBootFilesLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =         BEGIN         lvHandle.bootingInfo ¬ pBootFiles­;         SimpleFile.UpdateLogicalMarkerPages[lvHandle, tok];         END;  --SetLogicalVolumeBootFilesProc      IF pBootFiles # NIL THEN         VolTable.LVAccess[            lvID: lvID, proc: SetLogicalVolumeBootFilesLVProc,            lock: writeWithChangingFlag, entryState: open];      END;  --SetLogicalVolumeBootFiles   --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   --  Root Directory Implementation   --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   FindRootFileEntry: --INTERNAL-- PROCEDURE [type: File.Type]      RETURNS [found: BOOLEAN, index: RootDirectoryIndex] =      BEGIN      FOR index IN [0..rootDirectory.countEntries) DO         IF rootDirectory.entries[index].type = type THEN            RETURN[found: TRUE, index: index];         REPEAT FINISHED => found ¬ FALSE;         ENDLOOP;      END;  --FindRootFileEntry   GetNextRootFile: PUBLIC PROCEDURE [lastType: File.Type, volume: Volume.ID]      RETURNS [file: File.File, type: File.Type] =      BEGIN      GetNextRootFileInternal: RootDirectoryAccessProc =         BEGIN         found: BOOLEAN;         index: RootDirectoryIndex;         file.volumeID ¬ volume;         IF lastType = FileTypes.tUntypedFile THEN            IF rootDirectory.countEntries = 0 THEN {               type ¬ FileTypes.tUntypedFile; file ¬ File.nullFile}            ELSE [type, file.fileID] ¬ rootDirectory.entries[0]         ELSE            BEGIN            [found, index] ¬ FindRootFileEntry[lastType];            IF NOT found THEN ERROR RootDirectoryError[rootFileUnknown];            IF index = rootDirectory.countEntries - 1 THEN {               type ¬ FileTypes.tUntypedFile; file ¬ File.nullFile}            ELSE [type, file.fileID] ¬ rootDirectory.entries[index + 1];            END;         END;  --GetNextRootFileInternal       RootDirectoryAccess[         volume: volume, proc: GetNextRootFileInternal, access: read];      END;  --GetNextRootFile   InsertRootFile: PUBLIC PROCEDURE [type: File.Type, file: File.File] =      BEGIN      InsertRootFileInternal: RootDirectoryAccessProc =         BEGIN         IF rootDirectory.countEntries >= rootDirectory.maxEntries THEN            ERROR RootDirectoryError[directoryFull];         IF FindRootFileEntry[type].found THEN            ERROR RootDirectoryError[duplicateRootFile];         rootDirectory.entries[rootDirectory.countEntries] ¬ [type, file.fileID];         rootDirectory.countEntries ¬ rootDirectory.countEntries + 1;         END;  --InsertRootFileInternal      IF type = FileTypes.tUntypedFile THEN         ERROR RootDirectoryError[invalidRootFileType];      RootDirectoryAccess[         volume: file.volumeID, proc: InsertRootFileInternal, access: write,         createDirOK: TRUE];      END;  --InsertRootFile   LookUpRootFile: PUBLIC PROCEDURE [type: File.Type, volume: Volume.ID]      RETURNS [file: File.File] =      BEGIN      LookUpRootFileInternal: RootDirectoryAccessProc =         BEGIN         found: BOOLEAN;         index: RootDirectoryIndex;         [found, index] ¬ FindRootFileEntry[type];         IF NOT found THEN ERROR RootDirectoryError[rootFileUnknown];         file ¬ [rootDirectory.entries[index].file, volume];         END;  --LookUpRootFileInternal      RootDirectoryAccess[         volume: volume, proc: LookUpRootFileInternal, access: read];      END;  --LookUpRootFile     RemoveRootFile: PUBLIC PROCEDURE [type: File.Type, volume: Volume.ID] =      BEGIN      RemoveRootFileInternal: RootDirectoryAccessProc =         BEGIN         found: BOOLEAN;         index: RootDirectoryIndex;         [found, index] ¬ FindRootFileEntry[type];         IF NOT found THEN ERROR RootDirectoryError[rootFileUnknown];         FOR i: CARDINAL IN [index + 1..rootDirectory.countEntries) DO            << Note that "i: RootDirectoryIndex" fails above since           rootDirectory.countEntries is a CARDINAL >>            rootDirectory.entries[i - 1] ¬ rootDirectory.entries[i]; ENDLOOP;         rootDirectory.countEntries ¬ rootDirectory.countEntries - 1;         rootDirectory.entries[rootDirectory.countEntries] ¬ [            type: FileTypes.tUntypedFile, file: File.nullID];         END;  --RemoveRootFileInternal      RootDirectoryAccess[         volume: volume, proc: RemoveRootFileInternal, access: write];      END;  --RemoveRootFile   RootDirectoryAccess: PROCEDURE [      volume: Volume.ID, proc: RootDirectoryAccessProc,      access: RootDirectoryAccessMode, createDirOK: BOOLEAN ¬ FALSE] =      BEGIN      signal: --GENERIC-- SIGNAL ¬ NIL;      signalArgs: PrincOps.LocalFrameHandle;      RootDirectoryAccessEntry: ENTRY PROCEDURE [] =         BEGIN         haveToUnmap: BOOLEAN ¬ FALSE;         lock: VolTable.LockState ¬ access;         needWriteWithChangingFlagLock: ERROR = CODE;         RootDirectoryAccessLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =            BEGIN            rootDirSize: CARDINAL [1..1] = CARDINAL[LVF.MaxPagesInRootDirectory];            data: DiskBackingStore.Data;            runLength: File.PageCount;            backingStoreRun: ARRAY [0..0] OF BackingStore.Run;            needInitialize: BOOLEAN ¬ FALSE;            IF lvHandle.volumeRootDirectory = File.nullID THEN               BEGIN               IF NOT createDirOK THEN ERROR RootDirectoryError[rootFileUnknown]               ELSE                  IF lock < writeWithChangingFlag THEN                     ERROR needWriteWithChangingFlagLock                  ELSE                     BEGIN                     VM.ForceOut[                        [                        page: Space.PageFromLongPointer[lvHandle],                        count: LVF.rootPageSize], wait];                     FileInternal.CreateInternal[                        file: [                        LOOPHOLE[LONG[PilotFileTypes.tRootDirectory], File.ID],                        volume], lvHandle: lvHandle, tok: tok,                        initialSize: LVF.MaxPagesInRootDirectory,                        type: PilotFileTypes.tRootDirectory,                        interval: VM.nullInterval];                     lvHandle.volumeRootDirectory ¬ LOOPHOLE[LONG[                        PilotFileTypes.tRootDirectory], File.ID];                     SimpleFile.UpdateLogicalMarkerPages[lvHandle, tok];                     VM.ForceOut[                        [                        page: Space.PageFromLongPointer[lvHandle],                        count: LVF.rootPageSize], wait];                     FileInternal.MakePermanentOrTemporary[                        file: [lvHandle.volumeRootDirectory, volume],                        fileD: [                        fileID: lvHandle.volumeRootDirectory, volumeID: volume,                        temporary: TRUE, type: PilotFileTypes.tRootDirectory,                        size: LVF.MaxPagesInRootDirectory], action: makePermanent,                        lvHandle: lvHandle, tok: tok];                     needInitialize ¬ TRUE;                     END               END;            [data, runLength, ] ¬ SimpleFile.GetBackingStoreData[               file: lvHandle.volumeRootDirectory, lvHandle: lvHandle, filePage: 0,               tok: tok, type: PilotFileTypes.tRootDirectory !               File.Unknown => Bug[fileSystemError]];            backingStoreRun[0] ¬ [               count: LOOPHOLE[runLength, Environment.PageCount],               data: LOOPHOLE[data, BackingStore.Data]];            VM.Map[               interval: [               page: rootDirectoryPage, count: LVF.MaxPagesInRootDirectory],               transferProc: DiskBackingStore.Transfer,               backingStoreRuns: LONG[DESCRIPTOR[backingStoreRun]],               swapUnits: [unitary[]]];            IF needInitialize THEN               BEGIN               rootDirectory.seal ¬ LVF.RootDirSeal;               rootDirectory.version ¬ LVF.RootDirVersion;               rootDirectory.maxEntries ¬ maxEntriesInRootDirectory;               rootDirectory.countEntries ¬ 0;               END;            proc[ ! ANY => {haveToUnmap ¬ TRUE; REJECT}];            VM.Unmap[rootDirectoryPage];            END;  --RootDirectoryAccessLVProc         BEGIN         ENABLE            ANY =>               BEGIN               [signal, signalArgs] ¬ SpecialRuntime.GetCurrentSignal[];               IF haveToUnmap THEN VM.Unmap[rootDirectoryPage];               CONTINUE;               END;         VolTable.LVAccess[            lvID: volume, proc: RootDirectoryAccessLVProc, lock: lock,            entryState: open !            needWriteWithChangingFlagLock => {               lock ¬ writeWithChangingFlag; RETRY}];         END;         END;  --RootDirectoryAccessEntry      [] ¬ RootDirectoryAccessEntry[];      IF signal # NIL THEN SpecialRuntime.ReraiseError[signalArgs, signal];      END;  --RootDirectoryAccess   END.LOG  (For earlier log entries, see Pilot 10.0 archive version.)18-Nov-82 16:23:59   LXD      	Klamath rewrite23-Dec-82  9:58:16   AWL         RootDirectoryIndex is a subrange of CARDINAL21-Jan-83 15:41:44   LXD      	Converted to new VolTable. 1-Feb-83 11:03:23   LXD         New MP codes cBadDebuggerPointers, cDiskHardwareError.  3-Feb-83 16:46:55   LXD         New LV lock state maybeWrite provides exclusive access to volume;  minor corrections to Create. 4-Feb-83 22:46:40   LXD         New VolTable LVEntryState enabled  re-factoring of Create14-Feb-83 10:46:27   LXD         Refactored locking in Create.  Previous LockEntireLV had the effect that   code tried to unlock a SV which was already unlocked when SVAccess had returned.15-Feb-83 14:34:53   LXD      	Stylistic modifications and better documentation23-Feb-83 10:42:53   LXD         Modified Erase to accommodate lower-level restrictions on volumes marked as open in the VolTable.  Added calls to VolFileMap.Open24-Feb-83 12:37:22   LXD      	Added ForceConsistency call to Close  1-Mar-83 10:45:11   LXD         OpenInitialVolumes now opens system volume only. 2-Mar-83 15:52:31   Minor modifications, documentation. 21-Mar-83 13:57:44   LXD         Revised FindDebuggerAndSystemLV for new FMPrograms.  Removed OpenInitialVolumes22-Mar-83 10:23:51   ???   LogicalVolumeFormat.seal becomes LogicalVolumeFormat.lvRootSeal22-Apr-83  8:54:29   AWL         Couldn't find local debugger - debuggerVolumeID set after calling   GetLogicalVolumeBootFiles with it as an argument.22-Apr-83 13:56:15   WDK        Debugger vol was set even if no debugger.22-Apr-83 17:05:18   AWL      	GetNext fails if onWhichVolumes not ALL[FALSE].26-Apr-83 10:16:22   JXP      Remember to unmap during error recovery in RootDirectoryAccess. Fill in   lastTimeOpendForWrite field when opening for write. 2-Jun-83 16:37:27   JXP      If the volume is Open, then ignore the changing bit in GetAttributes. 6-Jun-83 10:11:38   JXP      Don't ForceConsistency when closing a ReadOnly volume. 8-Jun-83 17:29:11   JXP   	Fix problem withing closing closed volumes.25-Jul-83 11:00:50   JXP      Names changed in the interface, update names in impl. 3-Sep-83 13:43:42   JXP   	Implement LastOpenedForWrite in SpecialVolume.12-Sep-83 15:53:11   JXP      Must manually force consistency in Open and OpenVolume.13-Sep-83 17:53:28   JXP   	Fix the bugs I put in Open and OpenVolume. 1-Dec-83 15:18:36   WDK        Split FindDebuggerAndSystemLVPVProc in two. OpenVolume had wrong logic   for default. Looking for debugger failed to catch NeedsScavenging.   AR4795: Volume.Close didn't clean-up the root page correctly.   AR695: Should disallow Volume.Erase[systemVolume] (or Close).   GetNext[all] should not die if vol needs scavenging.   GetNext ignored requested type in UtilityPilot.14-Dec-83  7:45:31   WDK     	ForceOut when timeOpenedForWrite updated. 7-Sep-84 14:33:01   CJS       Close: Deactivates lv rootpage after use. See AR 6201.13-Nov-84 16:41:56   CJS      Fix AR 6509. DeleteTemporaryFiles in OpenInternal.10-Dec-84 13:03:27   EKN      Fix AR 6690: NewPVOnline needs to check if lv root page is in bad page table and if not, to also read the data field.12-Dec-84 11:30:27   EKN      Fixed NewPVOnline again to do a VM.ScratchMap vs. Space.ScratchMap24-Jan-85 11:19:21   CJS      Twiddled VolTable.GetNextSV calls per AR 6275.15-Feb-85 11:04:17   CJS      Fixed my infinite loop in FindDebuggerPVProc. 9-Jun-86 17:21:27   RSV      Modified CreateSVProc to accomodate duplicate root page.12-Jun-86 17:17:08   RSV      Added CHANGE comments.  Changed InitVolume, Close, OpenInternal, and OpenVolumeLVProc to use ETables.  Changed CreateSVProc, CreateMarkerPage, NewPVOnline for labelessness.  Fixed AR 6283 in LastOpenedForWrite (check for NeedsScavenging).  Changed minPagesPerVolume to 500 temporarily.18-Jul-86 10:32:47   RSV      Actually did CHANGE comments for labeless.  Also changed PilotDiskFace.Command to new version.29-Sep-86 16:36:24   RSV      Modified CreateMarkerPage to set maxDataLostPages field in PV Marker page.  Modified OpenInternal to reflect new VerifierInternal.VerifierWithLock.20-Oct-86 13:31:13   RSV      Added throw away of return value from VerifierWithLock.13-Nov-86 16:42:31   RSV      Deleted last of CHANGE comments.  Also set lastOpenedForWrite in OpenInternal 7-Jan-87 15:09:44   RRR   Made changes necessary to move lv root page without changing lv numbering.15-Jan-87  0:06:59   RSV   Raise NeedsScavenging when getting a Verifier error.23-Jan-87 11:56:26   RRR   More changes necessary to move lv root page without changing lv numbering. 2-Feb-87  9:01:07   CJS   Introduce doVolumeLocking and LockVolume call in OpenInternal, and Unlock in Close. And PilotSwitch to turn on/off.12-Mar-87 16:12:27   RRR   Remove PV marker page support. 6-Dec-87 18:21:50   RSV   in CheckRootPageReadability, have the call to ReadData not handleErrors.
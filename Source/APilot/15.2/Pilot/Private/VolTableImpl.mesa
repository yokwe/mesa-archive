-- Copyright (C) 1984, 1985, 1986, 1987  by Xerox Corporation. All rights reserved. -- FileBasics>VolTableImpl.mesa     7-Jan-87 15:07:52   by RRR    -- ORGANIZATION:---- * Public procedures in this module are grouped into major sections--   just as they are in the VolTable interface; private procedures--   are in a separate major section at the end, ordered alphabetically--   EXCEPT that INLINEs are defined in a major section at the very--   beginning so as to have them declared before use.--   The major sections are, in order:--     Initialization--     INLINEs--     Stateless enumeration of Physical, Logical, and SubVolumes--     Onlining Volumes:--     Offlining Volumes:--     Utility Procedures.--     Volume Locking Routines:--     Special Operations:--     Exported to VolBackingStore--     Exported to FileBasicsPerf--     Private and Internal Procedures:-- * The major sections are separated by two rows of tildas. To find--   the sections quickly, select these tildas v~~~~~~~v and use FIND.-- NOTES:---- * Due to the expected pattern of use by PhysicalVolume.AssertPilotVolume,--   the implementation does not allow the situation of having a--   pv root page offline but some of its subvolumes online.-- ASSUMPTIONS:-- * Currently VolTableImpl caches the result of the last sucessful--   search for an LV. In current use, a typical machine only--   has one PV and there is only one SV per logical volume. Thus--   searches for PVs and SVs are expected to be fast without accelerators.-- THINGS TO CONSIDER:-- * Consider an LV going offline while its operationCount is--    still > 0. It would be good to our customers if we made--    the disk consistent before doing so. At what point should--    we do so? At close? At SetLVOffline?DIRECTORY  BackingStore USING [Data, Run],  DiskBackingStore USING [ChannelHandle, GetDiskChannel],  DiskChannel USING [Drive, GetDrive, GetDriveAttributes, GetPageNumber, Handle],  Environment USING [Base, PageCount, PageNumber],  File USING [PageNumber, Type],  FileBasicsPerf USING [],  FileBasicsPrograms USING [    InitDiskBackingStore, InitETable, InitDataTransfer, InitSimpleFile,    InitVolAllocMap, InitVolBackingStore],  Inline USING [LowHalf],  KernelSpaceUsage USING [lvRootPage, markerPage, pvRootPage],  LogicalVolumeFormat USING [Descriptor, Handle, rootPageNumber, rootPageSize],  PilotDiskFace USING [DeviceHandle, GetDriveInfo],  PhysicalVolume USING [Error, ErrorType, ID, nullID, PageNumber],  PhysicalVolumeFormat USING [    Descriptor, DuplicateHandle, duplicateRootPageSize, Handle, MarkerHandle,    MarkerID, markerPageSize, rootPageNumber, rootPageSize],  PilotFileTypes USING [    tLogicalVolumeRootPage, tPhysicalVolumeRootPage, tSubVolumeMarkerPage],  PrincOps USING [LocalFrameHandle],  ProcessInternal USING [GetCurrent],  ResidentHeap USING [first64K, FreeNode, MakeNode],  RuntimeInternal USING [Bug],  Space USING [PageFromLongPointer],  SpecialRuntime USING [GetCurrentSignal, ReraiseError],  StoragePrograms USING [],  System USING [GetClockPulses, nullID, Pulses, UniversalID],  VM USING [ForceOut, Deactivate, Map, PageCount, Unmap],  VolAllocMap USING [Close],  VolBackingStore USING [BSDataFromVolData, Transfer],  VolTable USING [    ClientData, Context, LockState, LVAccessProc, LVEntryState, LVID, LVLockType,    LVToken, nullLVPage, nullPVPage, nullSVDesc, PVAccessProc, PVEntryState, PVID,    PVLockType, PVToken, RootPageReadability, SVAccessProc, SVDesc, SVDescPtr,    SVEntryState, SVEnumKey, SVLockType, SVToken, TableAccessProc],  Volume USING [    ID, NeedsScavenging, NotOnline, NotOpen, nullID, PageCount, PageNumber,    ReadOnly, Unknown],  Zone USING [BlockSize, Status];VolTableImpl: MONITOR  IMPORTS    DiskBackingStore, DiskChannel, FileBasicsPrograms, Inline,    PhysicalVolume, PilotDiskFace, ProcessInternal, ResidentHeap,    RuntimeInternal, Space, SpecialRuntime, System, VM, VolAllocMap,    VolBackingStore, Volume  EXPORTS FileBasicsPerf, StoragePrograms, VolBackingStore, VolTable  SHARES VolTable =  BEGIN OPEN LVF: LogicalVolumeFormat, PVF: PhysicalVolumeFormat;  -- TYPEs defining the table entries:  LVEntry: TYPE = RECORD [    lvID: Volume.ID,    handle: LVF.Handle,  -- handle on the root page    state: VolTable.LVEntryState,    readOnly, entireLVLocked: BOOLEAN,    currentAccesses: CurrentAccesses,    operationSeqsInProgress: CARDINAL,    clientData: VolTable.ClientData,    etableInfo: VolTable.Context,    nextLV: LVRelPtr,    firstSV: SVRelPtr,    lock: Lock];  PVEntry: TYPE = RECORD [    pvID: PhysicalVolume.ID,    markerID: PVF.MarkerID,    bsChannel: DiskBackingStore.ChannelHandle,  -- used to map PV root, markers.    duplicateRootPageNumber: PhysicalVolume.PageNumber,       -- location of duplicate PV root page, a drive dependent number    state: VolTable.PVEntryState,    countMainMapped: CARDINAL,    countDuplicateMapped: CARDINAL,    nextPV: PVRelPtr,    firstSV: SVRelPtr,    lock: Lock];  SVEntry: TYPE = RECORD [    --~~~ First 2 fields identify the SV:    lvPage: Volume.PageNumber,    pvPage: PhysicalVolume.PageNumber,    --~~~ End identifying fields.    svLength: Volume.PageCount,    state: VolTable.SVEntryState,    countMapped: CARDINAL,    rootLV: LVRelPtr,    nextSVOfLV: SVRelPtr,    rootPV: PVRelPtr,    nextSVOfPV: SVRelPtr,    lock: Lock];  Lock: TYPE = RECORD [    SELECT state: VolTable.LockState FROM    unlocked => [],    maybeWrite => [process: PROCESS],  -- only used for LVs.    write => [process: PROCESS],    writeWithChangingFlag => [process: PROCESS],  -- only used for LVs.    read => [count: CARDINAL],    ENDCASE];  Lockability: TYPE = {okToLock, mustWait};  -- Lock interrogation procedures return a Lockability.  -- If the value $okToLock is returned, the client may acquire the lock.  -- If the value $mustWait is returned, the client must WAIT, then try again;  -- after WAITing, the client naturally MUST discard any cached data  -- which depends on the VolTable database and reacquire it.  -- "WAIT, then take a lobotomy."  CurrentAccesses: TYPE = [0..128);  -- enough to never overflow.  TableBase: TYPE = Environment.Base;  PVRelPtr: TYPE = TableBase RELATIVE POINTER TO PVEntry;  LVRelPtr: TYPE = TableBase RELATIVE POINTER TO LVEntry;  SVRelPtr: TYPE = TableBase RELATIVE POINTER TO SVEntry;  PVPtr: TYPE = LONG POINTER TO PVEntry;  LVPtr: TYPE = LONG POINTER TO LVEntry;  SVPtr: TYPE = LONG POINTER TO SVEntry;  PVToken: PUBLIC TYPE = PVRelPtr;  LVToken: PUBLIC TYPE = LVRelPtr;  SVToken: PUBLIC TYPE = SVRelPtr;  IDHandle: PUBLIC --VolBackingStore.-- TYPE = RECORD [    SELECT OVERLAID * FROM    lv => [lv: LVToken],    pv => [pv: PVToken],    sv => [pvOfSv: PVToken],  -- The marker ID is stored in the PV entry.    ENDCASE];  -- Other TYPEs and Constants used in this module.  -- Many are just abbreviations for TYPEs defined elsewhere.  -- Logical Volume Definitions  LVAccessProc: TYPE = VolTable.LVAccessProc;  LVID: TYPE = Volume.ID;  nullLVID: LVID = Volume.nullID;  LVPage: TYPE = Volume.PageNumber;  -- Physical Volume Definitions    PVID: TYPE = PhysicalVolume.ID;  nullPVID: PVID = PhysicalVolume.nullID;  PVPage: TYPE = PhysicalVolume.PageNumber;  -- Other Definitions  nullMarkerPageLoc: PVPage = 0;  nullMarkerID: PVF.MarkerID = [System.nullID];  nil: TableBase RELATIVE POINTER = LOOPHOLE[0];  markerPageSize: Environment.PageCount = PVF.markerPageSize;  -- ERRORs:  BugType: TYPE = {    allocationError, alreadyMapped, alreadyUnmapped, alreadyOffline,    cantMapWithoutRoot, cantOfflineOpenLV, cleanupNotImplemented,    didntLockEntireLV, entryInUseForMapping, freeError, impossibleCase,    impossibleLockValue, impossibleLockRequired, inappropriateState,    insufficientPermission, lvStillInUse, lvWithNoSVs, noLVForOperationSequence,    noMultipleEntireLVLocks, overflow, stillLocked, pvAlreadyOnline, pvNotOnline,    pvNotPresent, svAlreadyOnline, svOffline, svStillInUse, svsStillOnline,    underflow, unknownLV, unknownPV, unknownSV, wrongStateForOnline};  -- Variables:  table: TableBase = ResidentHeap.first64K;  -- Pointer to the Base of the Table  firstLV: LVRelPtr ¬ nil;  -- Pointer to the first LV Entry  firstPV: PVRelPtr ¬ nil;  -- Pointer to the first PV Entry  somethingUnlocked: CONDITION;  -- BROADCASTed when entry or table is unlocked.  tableLock: Lock ¬ [unlocked[]];  locksOutstanding: CARDINAL ¬ 0;  -- Number of table items currently locked.  lvLastFound: LVRelPtr ¬ nil;  -- Meters exported to the Perf interface.  locks: PUBLIC CARDINAL ¬ 0;  lvLockWaits: PUBLIC CARDINAL ¬ 0;  pvLockWaits: PUBLIC CARDINAL ¬ 0;  svLockWaits: PUBLIC CARDINAL ¬ 0;  timeInClientProc: PUBLIC System.Pulses ¬ [0];  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Initialization  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  InitializeFileBasics: PUBLIC --StoragePrograms.-- PROCEDURE =    BEGIN    -- Starts the FileBasics Layer. The ordering of initialization    -- is not important at this time. The order given simply    -- reflects the general hieracrhy of the system.    FileBasicsPrograms.InitDiskBackingStore[];    FileBasicsPrograms.InitDataTransfer[];    FileBasicsPrograms.InitVolBackingStore[];    FileBasicsPrograms.InitVolAllocMap[];    FileBasicsPrograms.InitETable[];    FileBasicsPrograms.InitSimpleFile[];    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- INLINEs:  (declared before used)  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- The following three routines free table entries.  -- They are currently defined as inlines due to their simplicity, but   -- are kept as procedures to shield their clients from possible future   -- complexity in the allocation strategy.  FreeLVEntry: INTERNAL PROCEDURE [lv: LVRelPtr] = INLINE    BEGIN IF ResidentHeap.FreeNode[lv].s ~= okay THEN Bug[freeError]; END;  FreePVEntry: INTERNAL PROCEDURE [pv: PVRelPtr] = INLINE {    IF ResidentHeap.FreeNode[pv].s ~= okay THEN Bug[freeError]};  FreeSVEntry: INTERNAL PROCEDURE [sv: SVRelPtr] = INLINE {    IF ResidentHeap.FreeNode[sv].s ~= okay THEN Bug[freeError]};  FreeLVIfUnusedAndOffline: INTERNAL PROCEDURE [lv: LVPtr] = INLINE {    -- Frees lv­ if offline and not being used for LVAccess.    IF lv.state = offline AND lv.currentAccesses = 0 THEN FreeLV[lv]};  LVRelPtrFromLVPtr: PROCEDURE [lv: LVPtr] RETURNS [lvRelPtr: LVRelPtr] = INLINE {    RETURN[Inline.LowHalf[lv - table]]};  NewEntry: PROCEDURE [size: Zone.BlockSize]    RETURNS [node: TableBase RELATIVE POINTER] = INLINE    BEGIN    status: Zone.Status;    [node, status] ¬ ResidentHeap.MakeNode[size];    IF status ~= okay THEN Bug[allocationError];    END;  NewLVEntry: PROCEDURE RETURNS [LVRelPtr] = INLINE {    RETURN[NewEntry[SIZE[LVEntry]]]};  NewPVEntry: PROCEDURE RETURNS [PVRelPtr] = INLINE {    RETURN[NewEntry[SIZE[PVEntry]]]};  NewSVEntry: PROCEDURE RETURNS [SVRelPtr] = INLINE {    RETURN[NewEntry[SIZE[SVEntry]]]};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Stateless enumeration of Physical, Logical, and SubVolumes  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetNextLV: PUBLIC ENTRY PROCEDURE [lvID: LVID] RETURNS [nextLV: LVID] =    BEGIN    IF lvID = nullLVID THEN      RETURN[IF firstLV = nil THEN nullLVID ELSE table[firstLV].lvID]    ELSE      BEGIN      currentLV: LVRelPtr ¬ FindLV[lvID];      IF currentLV = nil THEN RETURN WITH ERROR Volume.Unknown[lvID];      IF table[currentLV].nextLV = nil THEN RETURN[nullLVID]      ELSE RETURN[table[table[currentLV].nextLV].lvID];      END;    END;  --GetNextLV--  GetNextPV: PUBLIC ENTRY PROCEDURE [pvID: PVID] RETURNS [nextPV: PVID] =    BEGIN    IF pvID = nullPVID THEN      RETURN[IF firstPV = nil THEN nullPVID ELSE table[firstPV].pvID]    ELSE      BEGIN      currentPV: PVRelPtr ¬ FindPV[pvID];      IF currentPV = nil THEN        RETURN WITH ERROR PhysicalVolume.Error[physicalVolumeUnknown];      IF table[currentPV].nextPV = nil THEN RETURN[nullPVID];      RETURN[table[table[currentPV].nextPV].pvID];      END;    END;  --GetNextPV--  GetNextSV: PUBLIC ENTRY PROCEDURE [key: VolTable.SVEnumKey, svdPtr: VolTable.SVDescPtr] =    BEGIN    WITH ky: key SELECT FROM      byLV =>        BEGIN        lv: LVRelPtr ¬ FindLV[ky.lvToEnum];        lowestQualifyingSV: SVRelPtr ¬ nil;        IF lv = nil THEN Bug[unknownLV];        FOR sv: SVRelPtr ¬ table[lv].firstSV, table[sv].nextSVOfLV UNTIL sv = nil          DO          IF lowestQualifyingSV = nil            OR table[sv].lvPage < table[lowestQualifyingSV].lvPage THEN            WITH k: ky.sv SELECT FROM              first => lowestQualifyingSV ¬ sv;              next => IF table[sv].lvPage > k.lvPage THEN lowestQualifyingSV ¬ sv;              ENDCASE => Bug[impossibleCase];          ENDLOOP;	ConstructSVDesc[lowestQualifyingSV, svdPtr];        RETURN;        END;  --byLV--      byPV =>        BEGIN        pv: PVRelPtr ¬ FindPV[ky.pvToEnum];        lowestQualifyingSV: SVRelPtr ¬ nil;        IF pv = nil THEN Bug[unknownPV];        FOR sv: SVRelPtr ¬ table[pv].firstSV, table[sv].nextSVOfPV UNTIL sv = nil          DO          IF lowestQualifyingSV = nil            OR table[sv].pvPage < table[lowestQualifyingSV].pvPage THEN            WITH k: ky.sv SELECT FROM              first => lowestQualifyingSV ¬ sv;              next => IF table[sv].pvPage > k.pvPage THEN lowestQualifyingSV ¬ sv;              ENDCASE => Bug[impossibleCase];          ENDLOOP;	ConstructSVDesc[lowestQualifyingSV, svdPtr];        RETURN;        END;  --byPV--      ENDCASE => Bug[impossibleCase];    END;  --GetNextSV--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Onlining Volumes:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetLVOnline: PUBLIC ENTRY PROCEDURE [    tok: LVToken, rootPage: LVF.Handle,    readability: VolTable.RootPageReadability] =    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    IF table[tok].state ~= partiallyOnline THEN Bug[wrongStateForOnline];    table[tok].handle ¬ rootPage;    SELECT readability FROM      rootPageUnreadable => table[tok].state ¬ allSVsOnline;      rootPageReadable =>        BEGIN table[tok].state ¬ online; MapLVRootPage[tok]; END;      ENDCASE => Bug[impossibleCase];    END;  SetPVOnline: PUBLIC ENTRY PROCEDURE [    tok: PVToken, bsChannel: DiskBackingStore.ChannelHandle] =    BEGIN    drive: DiskChannel.Drive;    deviceHandle: PilotDiskFace.DeviceHandle;    IF table[tok].state = online THEN Bug[pvAlreadyOnline];    table[tok].bsChannel ¬ bsChannel;    table[tok].state ¬ online;    drive ¬ DiskChannel.GetDrive[DiskBackingStore.GetDiskChannel[bsChannel]];    deviceHandle ¬ DiskChannel.GetDriveAttributes[drive].deviceHandle;    table[tok].duplicateRootPageNumber ¬ DiskChannel.GetPageNumber[drive,      PilotDiskFace.GetDriveInfo[deviceHandle].lastPageOfInitialMicrocode] + 1;    END;  RegisterPVMarkerID: PUBLIC ENTRY PROCEDURE    [tok: PVToken, markerID: PVF.MarkerID] =    BEGIN    IF table[tok].state ~= online THEN Bug[pvNotOnline];    table[tok].markerID ¬ markerID;    END;  SetSVOnline: PUBLIC ENTRY PROCEDURE [    tok: SVToken, pvPageOfSV: PVPage, lvPageOfSV: LVPage,    svLength: Volume.PageCount] =    BEGIN    sv: SVPtr = @table[tok];    IF sv.state = online THEN Bug[svAlreadyOnline];    sv.pvPage ¬ pvPageOfSV;    sv.lvPage ¬ lvPageOfSV;    sv.svLength ¬ svLength;    sv.state ¬ online;    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Offlining Volumes:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetLVOffline: PUBLIC ENTRY PROCEDURE [tok: LVToken] =    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    lv: LVPtr = @table[tok];    IF lv.lock.state = read THEN Bug[insufficientPermission];    SELECT lv.state FROM      offline, partiallyOnline, allSVsOnline => NULL;      online => VM.Unmap[Space.PageFromLongPointer[lv.handle]];      open => Bug[cantOfflineOpenLV];      ENDCASE => Bug[impossibleCase];    lv.handle ¬ NIL;    lv.state ¬ IF lv.firstSV = nil THEN offline ELSE partiallyOnline;    END;  --SetLVOffline--  SetPVOffline: PUBLIC ENTRY PROCEDURE [tok: PVToken] =    BEGIN    pv: PVPtr = @table[tok];    IF pv.lock.state = read THEN Bug[insufficientPermission];    IF pv.countMainMapped ~= 0 OR pv.countDuplicateMapped ~= 0 THEN      Bug[entryInUseForMapping];    IF pv.state = offline THEN Bug[alreadyOffline];    pv.state ¬ offline;    -- (Entry will disappear when PVAccess exits.)    END;  --SetPVOffline--  SetSVOffline: PUBLIC ENTRY PROCEDURE [tok: SVToken] =    BEGIN    IF table[tok].countMapped ~= 0 THEN Bug[entryInUseForMapping];    IF table[tok].lock.state ~= write THEN Bug[insufficientPermission];    IF table[tok].state = offline THEN Bug[alreadyOffline];    table[tok].state ¬ offline;    -- (Entry will disappear when SVAccess exits.)    END;  -- SetSVOffline  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Utility Procedures.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- LV Utilities:  AssertRootPageReadability: PUBLIC ENTRY PROCEDURE [    tok: LVToken, readability: VolTable.RootPageReadability] =    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    lv: LVPtr = @table[tok];    SELECT lv.state FROM      offline, partiallyOnline, open => Bug[inappropriateState];      allSVsOnline =>        IF readability = rootPageReadable THEN          BEGIN MapLVRootPage[tok]; lv.state ¬ online; END;      online =>        IF readability = rootPageUnreadable THEN          BEGIN          VM.Unmap[Space.PageFromLongPointer[lv.handle]];          lv.state ¬ allSVsOnline;          END;      ENDCASE => Bug[impossibleCase];    END;  GetClientData: PUBLIC ENTRY PROCEDURE [    tok: LVToken, data: LONG POINTER TO VolTable.ClientData] = {    data­ ¬ table[tok].clientData};  GetLVStatus: PUBLIC ENTRY PROCEDURE [lvID: LVID]    RETURNS [entryState: VolTable.LVEntryState, readOnly: BOOLEAN] =    BEGIN    lv: LVRelPtr ¬ FindLV[lvID];    IF lv = nil THEN RETURN WITH ERROR Volume.Unknown[lvID];    RETURN[table[lv].state, table[lv].readOnly];    END;  GetETableContext: PUBLIC ENTRY PROCEDURE [    tok: LVToken, context: LONG POINTER TO VolTable.Context] = {    context­ ¬ table[tok].etableInfo};  GetVolumeIndex: PUBLIC ENTRY PROCEDURE [lvID: LVID]    RETURNS [volumeIndex: CARDINAL] =    -- Returns a compacted unique runtime representation of the volume ID or     -- returns zero if LV is not found.    BEGIN    RETURN[LOOPHOLE[FindLV[lvID], CARDINAL]];    END;      SetClientData: PUBLIC ENTRY PROCEDURE    [tok: LVToken, data: VolTable.ClientData] = {    table[tok].clientData ¬ data};  SetClosed: PUBLIC ENTRY PROCEDURE [tok: LVToken] =    BEGIN    -- CHECK OTHER CONDITIONS!    IF table[tok].state ~IN [online..open] THEN Bug[inappropriateState];    table[tok].operationSeqsInProgress ¬ 0;    -- (Other consistency actions are done by Volume.Close.)    table[tok].state ¬ online;    END;  SetOpen: PUBLIC ENTRY PROCEDURE [tok: LVToken] =    BEGIN    IF table[tok].state ~IN [online..open] THEN Bug[inappropriateState];    table[tok].operationSeqsInProgress ¬ 0;    table[tok].state ¬ open;    END;  SetReadOnlyStatus: PUBLIC ENTRY PROCEDURE [tok: LVToken, readOnly: BOOLEAN] = {    table[tok].readOnly ¬ readOnly};  SetETableContext: PUBLIC ENTRY PROCEDURE [    tok: LVToken, context: VolTable.Context] = {    table[tok].etableInfo ¬ context};      GetLVHandle: PUBLIC ENTRY PROCEDURE [tok: LVToken] RETURNS [LogicalVolumeFormat.Handle] =    {RETURN[table[tok].handle]};      GetLVID: PUBLIC ENTRY PROCEDURE [tok: LVToken] RETURNS [Volume.ID] = {    RETURN[table[tok].lvID]};  -- PV Utilities:  GetBSChannel: PUBLIC ENTRY PROCEDURE [tok: PVToken]    RETURNS [channel: DiskBackingStore.ChannelHandle] =    BEGIN    IF table[tok].state ~= online THEN Bug[pvNotOnline];    RETURN[table[tok].bsChannel];    END;  GetDiskChannel: PUBLIC ENTRY PROCEDURE [tok: PVToken]    RETURNS [channel: DiskChannel.Handle] =    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    IF table[tok].state ~= online THEN Bug[pvNotOnline];    RETURN DiskBackingStore.GetDiskChannel[table[tok].bsChannel];    END;  GetDrive: PUBLIC ENTRY PROCEDURE [tok: PVToken]    RETURNS [drive: DiskChannel.Drive] =    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    IF table[tok].state ~= online THEN Bug[pvNotOnline];    RETURN DiskChannel.GetDrive[      DiskBackingStore.GetDiskChannel[table[tok].bsChannel]];    END;  MapPVRootPage: PUBLIC ENTRY PROCEDURE [tok: PVToken, rootPage: PVF.Handle] =    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    pv: PVPtr = @table[tok];    runs: ARRAY [0..1) OF BackingStore.Run;    IF pv.state ~= online THEN Bug[pvNotOnline];    IF pv.countMainMapped ~= 0 AND table[tok].lock.state = write THEN      Bug[alreadyMapped];    -- This lock can't possibly be for write if someone else    -- has already mapped the root page.    pv.countMainMapped ¬ pv.countMainMapped.SUCC;    runs[0] ¬ [      count: PVF.rootPageSize,      data: VolBackingStore.BSDataFromVolData[      [      id: IDHandle[pv[tok]], type: PilotFileTypes.tPhysicalVolumeRootPage,      pvPage: PVF.rootPageNumber, filePage: PVF.rootPageNumber,      channelHandle: pv.bsChannel]]];    VM.Map[      interval: [      page: Space.PageFromLongPointer[rootPage], count: PVF.rootPageSize],      transferProc: VolBackingStore.Transfer, backingStoreRuns: DESCRIPTOR[runs],      usage: KernelSpaceUsage.pvRootPage, class: file, swapUnits: [unitary[]],      access: IF table[tok].lock.state = write THEN readWrite ELSE readOnly];    END;  UnmapPVRootPage: PUBLIC ENTRY PROCEDURE [tok: PVToken, rootPage: PVF.Handle] =    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    IF table[tok].countMainMapped = 0 THEN Bug[alreadyUnmapped];    table[tok].countMainMapped ¬ table[tok].countMainMapped.PRED;    VM.Unmap[Space.PageFromLongPointer[rootPage]];    END;  MapDuplicatePVRootPage: PUBLIC ENTRY PROCEDURE [    tok: PVToken, rootPage: PVF.DuplicateHandle] =    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    pv: PVPtr = @table[tok];    runs: ARRAY [0..1) OF BackingStore.Run;    IF pv.state ~= online THEN Bug[pvNotOnline];    IF pv.countDuplicateMapped ~= 0 AND table[tok].lock.state = write THEN      Bug[alreadyMapped];    -- This lock can't possibly be for write if someone else    -- has already mapped the duplicate root page.    pv.countDuplicateMapped ¬ pv.countDuplicateMapped.SUCC;    runs[0] ¬ [      count: PVF.duplicateRootPageSize,      data: VolBackingStore.BSDataFromVolData[      [      id: IDHandle[pv[tok]], type: PilotFileTypes.tPhysicalVolumeRootPage,      pvPage: pv.duplicateRootPageNumber, filePage: pv.duplicateRootPageNumber,      channelHandle: pv.bsChannel]]];    VM.Map[      interval: [      page: Space.PageFromLongPointer[rootPage],      count: PVF.duplicateRootPageSize],      transferProc: VolBackingStore.Transfer, backingStoreRuns: DESCRIPTOR[runs],      usage: KernelSpaceUsage.pvRootPage, class: file, swapUnits: [unitary[]],      access: IF table[tok].lock.state = write THEN readWrite ELSE readOnly];    END;  UnmapDuplicatePVRootPage: PUBLIC ENTRY PROCEDURE [    tok: PVToken, rootPage: PVF.DuplicateHandle] =    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    IF table[tok].countDuplicateMapped = 0 THEN Bug[alreadyUnmapped];    table[tok].countDuplicateMapped ¬ table[tok].countDuplicateMapped.PRED;    VM.Unmap[Space.PageFromLongPointer[rootPage]];    END;  -- SV Utilities:  FindSV: PUBLIC ENTRY PROCEDURE [lvID: LVID, page: LVPage, svdPtr: VolTable.SVDescPtr]    RETURNS [      found: BOOLEAN,      channel: DiskBackingStore.ChannelHandle] = {        RETURN FindSVInternal[lvID, page, svdPtr]};   MapMarkerPage: PUBLIC ENTRY PROCEDURE    [tok: SVToken, markerPage: PVF.MarkerHandle] =    -- The associated subvolume must be registered in the table.    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    sv: SVPtr = @table[tok];    runs: ARRAY [0..1) OF BackingStore.Run;    pv: PVRelPtr = table[tok].rootPV;    page: PVPage = sv.pvPage + sv.svLength;    IF sv.state ~= online THEN Bug[unknownSV];    IF sv.countMapped ~= 0 AND table[tok].lock.state IN [write..maybeWrite] THEN      Bug[alreadyMapped];    -- This lock can't possibly be for write if someone else    -- has already mapped the root page.    sv.countMapped ¬ sv.countMapped.SUCC;    runs[0] ¬ [      count: markerPageSize,      data: VolBackingStore.BSDataFromVolData[      [      id: IDHandle[sv[pvOfSv: pv]], type: PilotFileTypes.tSubVolumeMarkerPage,      pvPage: page, filePage: page, channelHandle: table[pv].bsChannel]]];    VM.Map[      interval: [      page: Space.PageFromLongPointer[markerPage], count: markerPageSize],      transferProc: VolBackingStore.Transfer, backingStoreRuns: DESCRIPTOR[runs],      usage: KernelSpaceUsage.markerPage, class: file, swapUnits: [unitary[]],      access: IF table[tok].lock.state IN [write..maybeWrite]        THEN readWrite ELSE readOnly];    END;  UnmapMarkerPage: PUBLIC ENTRY PROCEDURE    [tok: SVToken, markerPage: PVF.MarkerHandle] =    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    IF table[tok].countMapped = 0 THEN Bug[alreadyUnmapped];    VM.Unmap[page: Space.PageFromLongPointer[markerPage]];    table[tok].countMapped ¬ table[tok].countMapped.PRED;    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Volume Locking Routines:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  LVAccess: PUBLIC PROCEDURE [    lvID: LVID, proc: VolTable.LVAccessProc, lock: VolTable.LVLockType,    entryState: VolTable.LVEntryState] =    BEGIN    accessRequired: VolTable.LVLockType = lock;  -- for clarity below.    LockLV: ENTRY PROCEDURE RETURNS [lvRelPtr: LVRelPtr] =      -- Other actual args: lvID, accessRequired, entryState.      BEGIN      ENABLE UNWIND => NULL;  -- unlock monitor.      lv: LVPtr;      lvLockWaitsAtEntry: CARDINAL = lvLockWaits;      DO  --UNTIL table and lv are unlocked to me--        IF TableLockStatus[] = okToLock THEN          BEGIN          lvRelPtr ¬ FindLV[lvID];          IF lvRelPtr = nil THEN            BEGIN            IF entryState = offline THEN  --              lvRelPtr ¬ CreateLVEntry[lvID]  --              -- ASSERT: No errors will be raised, thus no error cleanup              -- of this newly-created LV will be required.            ELSE ERROR Volume.Unknown[lvID];            END;          lv ¬ @table[lvRelPtr];          IF LockStatus[accessRequired, @lv.lock] = okToLock THEN EXIT;          END;        IF lvLockWaits = lvLockWaitsAtEntry THEN lvLockWaits ¬ SUCC[lvLockWaits];        WAIT somethingUnlocked;        ENDLOOP;      -- ASSERT: Table and lv are unlocked to me.      IF lv.state < entryState THEN        SELECT lv.state FROM          offline => Bug[impossibleCase];          partiallyOnline => ERROR Volume.NotOnline[lvID];          allSVsOnline =>            SELECT entryState FROM              online => ERROR Volume.NeedsScavenging[lvID];              open => ERROR Volume.NotOpen[lvID];              offline, partiallyOnline, allSVsOnline => Bug[impossibleCase];              ENDCASE => Bug[impossibleCase];          online => ERROR Volume.NotOpen[lvID];          open => Bug[impossibleCase];          ENDCASE => Bug[impossibleCase];      IF lv.readOnly        AND (accessRequired = write OR accessRequired = writeWithChangingFlag)        THEN ERROR Volume.ReadOnly[lvID];      -- ASSERT: All error conditions have been checked.      AcquireLock[accessRequired, @lv.lock, lv];      IF lv.currentAccesses = CurrentAccesses.LAST THEN Bug[overflow];      lv.currentAccesses ¬ lv.currentAccesses.SUCC;      END;  --LockLV--    UnlockLV: PROCEDURE [lvRelPtr: LVRelPtr, tStart: System.Pulses] =      BEGIN      lv: LVPtr = @table[lvRelPtr];      UnlockLVEntry: ENTRY PROCEDURE =        BEGIN        ENABLE ANY => Bug[cleanupNotImplemented];        tElapsed: System.Pulses =  -- for PerfTool.          [System.GetClockPulses[] - tStart];        timeInClientProc ¬ [timeInClientProc + tElapsed];        Unlock[@lv.lock];        IF lv.currentAccesses = CurrentAccesses.FIRST THEN Bug[underflow];        lv.currentAccesses ¬ lv.currentAccesses.PRED;        FreeLVIfUnusedAndOffline[lv];        END;  --UnlockLVEntry--      IF lv.lock.state = writeWithChangingFlag THEN        BEGIN  -- Must do this before giving up the lock on the LV        EndOperationSequenceInternal[lv];        IF lv.operationSeqsInProgress = 0 THEN ForceConsistencyInternal[lv];        END;      UnlockLVEntry[];      END;  --UnlockLV--    -- Begin main text of LVAccess:    BEGIN  --scope of vars--    tStart: System.Pulses;    signal: SIGNAL ¬ NIL;    sigArgs: PrincOps.LocalFrameHandle;    token: LVToken;    unlocked: BOOLEAN ¬ FALSE;    token ¬ LockLV[      ! ANY => {[signal, sigArgs] ¬ SpecialRuntime.GetCurrentSignal[]; CONTINUE}];    IF signal ~= NIL THEN SpecialRuntime.ReraiseError[sigArgs, signal];    tStart ¬ System.GetClockPulses[];    proc[      token, table[token].handle !  -- Call the client proc.      ANY => {         IF table[token].state # open THEN 	  VM.Deactivate[            [page: Space.PageFromLongPointer[table[token].handle],	     count: LVF.rootPageSize], wait];                                    -- unlock vol before client sees signal.        IF ~unlocked THEN {          unlocked ¬ TRUE; UnlockLV[token, tStart] --must not fail!-- };        REJECT}];    IF table[token].state # open THEN       VM.Deactivate[        [page: Space.PageFromLongPointer[table[token].handle],	 count: LVF.rootPageSize], wait];    UnlockLV[token, tStart];    END;  --scope of vars--    END;  --LVAccess--  PVAccess: PUBLIC PROCEDURE [    pvID: PVID, proc: VolTable.PVAccessProc, lock: VolTable.PVLockType,    entryState: VolTable.PVEntryState] =    BEGIN    accessRequired: VolTable.PVLockType = lock;  -- for clarity below.    LockPV: ENTRY PROCEDURE RETURNS [pv: PVRelPtr] =      -- Other actual arguments: pvID, accessRequired, entryState.       BEGIN      ENABLE UNWIND => NULL;  -- unlock monitor.      pvLockWaitsAtEntry: CARDINAL = pvLockWaits;      DO  --UNTIL table and pv are unlocked to me--        IF TableLockStatus[] = okToLock THEN          BEGIN  --table unlocked--          pv ¬ FindPV[pvID];          SELECT entryState FROM            online =>              IF pv = nil THEN PhysicalVolume.Error[physicalVolumeUnknown];            offline =>              BEGIN  --create PV entry--              IF pv # nil THEN Bug[pvAlreadyOnline];              pv ¬ NewPVEntry[];              table[pv] ¬ PVEntry[  -- (compile-time constant)                pvID: TRASH, state: offline, markerID: --TRASH-- nullMarkerID,		bsChannel: TRASH, duplicateRootPageNumber: TRASH,	        countMainMapped: 0, countDuplicateMapped: 0,	        nextPV: TRASH, firstSV: nil, lock: [unlocked[]]];              table[pv].pvID ¬ pvID;              table[pv].nextPV ¬ firstPV;              firstPV ¬ pv;              END;  --create PV entry--            ENDCASE => Bug[impossibleCase];          IF LockStatus[accessRequired, @table[pv].lock] = okToLock THEN EXIT;          END;  --table unlocked--        IF pvLockWaits = pvLockWaitsAtEntry THEN pvLockWaits ¬ SUCC[pvLockWaits];        WAIT somethingUnlocked;        ENDLOOP;      -- ASSERT: Table and pv are unlocked to me.      AcquireLock[accessRequired, @table[pv].lock];      END;  --LockPV--    UnlockPV: ENTRY PROCEDURE [pvRelPtr: PVRelPtr, tStart: System.Pulses] =      BEGIN      ENABLE ANY => Bug[cleanupNotImplemented];      pv: PVPtr = @table[pvRelPtr];      tElapsed: System.Pulses =  -- for PerfTool.        [System.GetClockPulses[] - tStart];      timeInClientProc ¬ [timeInClientProc + tElapsed];      Unlock[@pv.lock];      IF pv.state = offline THEN        BEGIN  -- delete the PV entry        IF pv.firstSV # nil THEN Bug[svsStillOnline];        IF pv.lock # [unlocked[]] THEN Bug[stillLocked];        -- Relink the list of PV's to exclude this one:        IF firstPV = pvRelPtr THEN firstPV ¬ pv.nextPV        ELSE          BEGIN          currentPV: PVRelPtr ¬ firstPV;          WHILE table[currentPV].nextPV # pvRelPtr DO            currentPV ¬ table[currentPV].nextPV; ENDLOOP;          table[currentPV].nextPV ¬ pv.nextPV;          END;        FreePVEntry[pvRelPtr];        END;      END;  --UnlockPV--    -- Begin main text of PVAccess:    BEGIN  --scope of vars--    tStart: System.Pulses;    signal: SIGNAL ¬ NIL;    sigArgs: PrincOps.LocalFrameHandle;    token: PVToken;    unlocked: BOOLEAN ¬ FALSE;    token ¬ LockPV[      ! ANY => {[signal, sigArgs] ¬ SpecialRuntime.GetCurrentSignal[]; CONTINUE}];    IF signal ~= NIL THEN SpecialRuntime.ReraiseError[sigArgs, signal];    tStart ¬ System.GetClockPulses[];    proc[      token, PVF.rootPageNumber !  -- Call the client proc.      UNWIND => NULL;      ANY => {  -- unlock vol before client sees signal.        IF ~unlocked THEN {          unlocked ¬ TRUE; UnlockPV[token, tStart] --must not fail!-- };        REJECT}];    UnlockPV[token, tStart];    END;  --scope of vars--    END;  SVAccess: PUBLIC PROCEDURE [    pvID: PVID, lvID: LVID, lvPage: LVPage, proc: VolTable.SVAccessProc,    lock: VolTable.SVLockType, entryState: VolTable.SVEntryState] =    BEGIN    accessRequired: VolTable.PVLockType = lock;  -- for clarity below.    LockSV: ENTRY PROCEDURE RETURNS [sv: SVRelPtr] =      -- Other actual arguments: pvID, lvID, lvPage, accessRequired, entryState.      BEGIN      ENABLE UNWIND => NULL;  -- unlock monitor.      svLockWaitsAtEntry: CARDINAL = svLockWaits;      DO  --UNTIL table and sv are unlocked to me--        IF TableLockStatus[] = okToLock THEN          BEGIN          pv: PVRelPtr ¬ FindPV[pvID];          IF pv = nil THEN Bug[pvNotPresent];          sv ¬ SVFromLVID[lvID, lvPage];          SELECT entryState FROM            online => IF sv = nil THEN Bug[unknownSV];            offline =>              BEGIN              IF sv # nil THEN Bug[svAlreadyOnline];              sv ¬ CreateSVEntry[lvID, pv];              END;            ENDCASE => Bug[impossibleCase];          IF LockStatus[accessRequired, @table[sv].lock] = okToLock THEN EXIT;          END;        IF svLockWaits = svLockWaitsAtEntry THEN svLockWaits ¬ SUCC[svLockWaits];        WAIT somethingUnlocked;        ENDLOOP;      -- ASSERT: Table and sv are unlocked to me.      AcquireLock[accessRequired, @table[sv].lock];      END;  --LockSV--    UnlockSV: ENTRY PROCEDURE [sv: SVRelPtr, tStart: System.Pulses] =      BEGIN      ENABLE ANY => Bug[cleanupNotImplemented];      tElapsed: System.Pulses =  -- for PerfTool.        [System.GetClockPulses[] - tStart];      timeInClientProc ¬ [timeInClientProc + tElapsed];      UnlockSVInternal[sv];      END;  --UnlockSV--    -- Begin main text of SVAccess:    BEGIN  --scope of vars--    tStart: System.Pulses;    signal: SIGNAL ¬ NIL;    sigArgs: PrincOps.LocalFrameHandle;    token: SVToken;    unlocked: BOOLEAN ¬ FALSE;    token ¬ LockSV[      ! ANY => {[signal, sigArgs] ¬ SpecialRuntime.GetCurrentSignal[]; CONTINUE}];    IF signal ~= NIL THEN SpecialRuntime.ReraiseError[sigArgs, signal];    tStart ¬ System.GetClockPulses[];    proc[      token !  -- Call the client proc.      UNWIND => NULL;      ANY => {  -- unlock vol before client sees signal.        IF ~unlocked THEN {          unlocked ¬ TRUE; UnlockSV[token, tStart] --must not fail!-- };        REJECT}];    UnlockSV[token, tStart];    END;  --scope of vars--    END;  --SVAccess--  TableAccess: PUBLIC PROCEDURE [proc: VolTable.TableAccessProc] =    BEGIN    LockTable: ENTRY PROCEDURE =      -- Raises no signals; can not fail.      BEGIN      UNTIL tableLock = [unlocked[]] AND locksOutstanding = 0 DO        WAIT somethingUnlocked ENDLOOP;      tableLock ¬ [write[process: ProcessInternal.GetCurrent[]]];      END;    UnlockTable: ENTRY PROCEDURE [tStart: System.Pulses] =      BEGIN      tElapsed: System.Pulses =  -- for PerfTool.        [System.GetClockPulses[] - tStart];      timeInClientProc ¬ [timeInClientProc + tElapsed];      tableLock ¬ [unlocked[]];      BROADCAST somethingUnlocked;      END;  --UnlockTable--    tStart: System.Pulses;    unlocked: BOOLEAN ¬ FALSE;    LockTable[];    tStart ¬ System.GetClockPulses[];    proc[      !  -- Call the client proc.      UNWIND => NULL;      ANY => {  -- unlock before client sees signal.        IF ~unlocked THEN {          unlocked ¬ TRUE; UnlockTable[tStart] --must not fail!-- };        REJECT}];    UnlockTable[tStart];    END;  --TableAccess--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Special Operations:  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  LockEntireLV: PUBLIC PROCEDURE [    lvID: LVID, proc: VolTable.LVAccessProc, lock: VolTable.LVLockType,    entryState: VolTable.LVEntryState] =    BEGIN    accessRequired: VolTable.LVLockType = lock;  -- for clarity below.    LockEntireLVInternal: --VolTable.LVAccessProc-- PROCEDURE [      tok: LVRelPtr, lvHandle: LogicalVolumeFormat.Handle] =      -- Other actual args: accessRequired.      -- Locks all subvolumes of the lv, then calls proc, then unlocks.      BEGIN      LockAllSVs: ENTRY PROCEDURE [] =        -- Other actual arguments: accessRequired.        BEGIN        ENABLE UNWIND => NULL;  -- unlock monitor.        svLockWaitsAtEntry: CARDINAL = svLockWaits;        -- Note that table must be unlocked since we hold an lv lock.        WHILE table[tok].entireLVLocked OR	  LockRemainingSVs[table[tok].firstSV, accessRequired].lockability =          mustWait DO          IF svLockWaits = svLockWaitsAtEntry THEN svLockWaits ¬ svLockWaits.SUCC;          WAIT somethingUnlocked;          ENDLOOP;        table[tok].entireLVLocked ¬ TRUE;        END;  --LockAllSVs--      UnlockAllSVs: ENTRY PROCEDURE [tStart: System.Pulses] =        BEGIN        ENABLE ANY => Bug[cleanupNotImplemented];        tElapsed: System.Pulses =  -- for PerfTool.          [System.GetClockPulses[] - tStart];        timeInClientProc ¬ [timeInClientProc + tElapsed];        table[tok].entireLVLocked ¬ FALSE;        UnlockRemainingSVs[table[tok].firstSV];        END;  --UnlockAllSVs--      -- Begin main text of LockEntireLVInternal:      BEGIN  --scope of vars--      tStart: System.Pulses;      signal: SIGNAL ¬ NIL;      sigArgs: PrincOps.LocalFrameHandle;      unlocked: BOOLEAN ¬ FALSE;      LockAllSVs[        !        ANY => {[signal, sigArgs] ¬ SpecialRuntime.GetCurrentSignal[]; CONTINUE}];      IF signal ~= NIL THEN SpecialRuntime.ReraiseError[sigArgs, signal];      tStart ¬ System.GetClockPulses[];      proc[        tok, lvHandle !  -- Call the client proc.        UNWIND => NULL;        ANY => {  -- unlock vol before client sees signal.          IF ~unlocked THEN {            unlocked ¬ TRUE; UnlockAllSVs[tStart] --must not fail!-- };          REJECT}];      UnlockAllSVs[tStart];      END;  --scope of vars--      END;  --LockEntireLVInternal--    -- Begin main text of LockEntireLV:    LVAccess[lvID, LockEntireLVInternal, lock, entryState];    END;  --LockEntireLV--  ChangeSubVolume: PUBLIC ENTRY PROCEDURE [    tok: SVToken, lvPage: LVPage, pvPage: PVPage, svLength: Volume.PageCount] =    BEGIN    sv: SVPtr = @table[tok];    IF sv.state = offline THEN Bug[svOffline];    sv.lvPage ¬ lvPage;    sv.pvPage ¬ pvPage;    sv.svLength ¬ svLength;    END;  GetSVToken: PUBLIC --EXTERNAL-- PROCEDURE [token: LVToken, lvPage: LVPage]    RETURNS [svTok: SVToken] =    -- Caller MUST have monitor, table, or entire lv locked.    -- If sv is not found, nil is returned (should only    -- happen for calls from inside VolTableImpl).    BEGIN    currentSV: SVRelPtr ¬ table[token].firstSV;    DO  --until sv found--      curSV: SVPtr = @table[currentSV];      IF currentSV = nil THEN RETURN[nil];      IF lvPage IN [0..curSV.svLength) THEN        RETURN[currentSV];      currentSV ¬ curSV.nextSVOfLV;      ENDLOOP;    END;  --GetSVToken--  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Exported to VolBackingStore  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetID: PUBLIC --VolBackingStore.-- PROCEDURE [    idHandle: IDHandle, type: File.Type] RETURNS [id: System.UniversalID] =    BEGIN    SELECT type FROM      PilotFileTypes.tPhysicalVolumeRootPage => id ¬ table[idHandle.pv].pvID;      PilotFileTypes.tLogicalVolumeRootPage => id ¬ table[idHandle.lv].lvID;      PilotFileTypes.tSubVolumeMarkerPage => id ¬ table[idHandle.pvOfSv].markerID;      ENDCASE => Bug[impossibleCase];    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Exported to FileBasicsPerf  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  EndOperationSequence: PUBLIC PROCEDURE [volume: Volume.ID] =    BEGIN    EndOpSeq: LVAccessProc = {      EndOperationSequenceInternal[@table[LOOPHOLE[tok, LVRelPtr]]]};    LVAccess[volume, EndOpSeq, writeWithChangingFlag, open];    END;  BeginOperationSequence: PUBLIC PROCEDURE [volume: Volume.ID] =    BEGIN    BegOpSeq: LVAccessProc = {      BeginOperationSequenceInternal[@table[LOOPHOLE[tok, LVRelPtr]]]};    LVAccess[volume, BegOpSeq, read, open];    END;  ForceConsistency: PUBLIC PROCEDURE [volume: Volume.ID] =    BEGIN    ForceConsis: LVAccessProc = {      ForceConsistencyInternal[@table[LOOPHOLE[tok, LVRelPtr]]]};    LVAccess[volume, ForceConsis, write, open];    END;  GetOperationSequenceCount: PUBLIC PROCEDURE [volume: Volume.ID]    RETURNS [count: CARDINAL] =    BEGIN    GetOpSeqCount: LVAccessProc = {      count ¬ table[LOOPHOLE[tok, LVRelPtr]].operationSeqsInProgress};    LVAccess[volume, GetOpSeqCount, write, open];    END;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Private and Internal Procedures:  (ordered alphabetically)  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AcquireLock: INTERNAL PROCEDURE [    accessRequired: VolTable.LVLockType, lock: LONG POINTER TO Lock,    lv: LVPtr ¬ NIL] =    -- Acquires the requested lock. Caller MUST have verified that this is legal.    -- lv is required for accessRequired = writeWithChangingFlag; otherwise ignored.    BEGIN    SELECT accessRequired FROM      maybeWrite => lock­ ¬ [maybeWrite[process: ProcessInternal.GetCurrent[]]];      write => lock­ ¬ [write[process: ProcessInternal.GetCurrent[]]];      writeWithChangingFlag =>        BEGIN        BeginOperationSequenceInternal[lv];        lock­ ¬ [writeWithChangingFlag[process: ProcessInternal.GetCurrent[]]];        END;      read =>        lock­ ¬          WITH l: lock SELECT FROM            unlocked => [read[count: 1]],            read => [read[count: l.count.SUCC]],            write, writeWithChangingFlag => BugV[impossibleLockValue],            ENDCASE => BugV[impossibleCase];      ENDCASE => Bug[impossibleCase];    locksOutstanding ¬ SUCC[locksOutstanding];    locks ¬ SUCC[locks];  -- perf data    END;  --AcquireLock--  BeginOperationSequenceInternal: PROCEDURE [lv: LVPtr] =    BEGIN    IF lv = NIL THEN Bug[noLVForOperationSequence];    IF lv.handle.changing = FALSE THEN      BEGIN      lv.handle.changing ¬ TRUE;      VM.ForceOut[        interval: [        page: Space.PageFromLongPointer[lv.handle], count: LVF.rootPageSize],        returnWait: wait];      END;    lv.operationSeqsInProgress ¬ lv.operationSeqsInProgress.SUCC;    END;  Bug: PROCEDURE [b: BugType] = {RuntimeInternal.Bug[b]};  BugV: PROCEDURE [b: BugType] RETURNS [UNSPECIFIED] = {    RuntimeInternal.Bug[b]; RETURN[0]};  ConstructSVDesc: PROCEDURE [svPtr: SVRelPtr, descPtr: VolTable.SVDescPtr]  =    -- Builds a subvolume descriptor from fields in the sv entry.    BEGIN    sv: SVPtr = @table[svPtr];    IF svPtr = nil THEN descPtr­ ¬ VolTable.nullSVDesc    ELSE      descPtr­ ¬ [         lvID: table[table[svPtr].rootLV].lvID,         pvID: table[table[svPtr].rootPV].pvID,         lvPageOfSV: sv.lvPage, pvPageOfSV: sv.pvPage,         svLength: sv.svLength];    END;  CreateSVEntry: INTERNAL PROCEDURE [lvID: LVID, pv: PVRelPtr]    RETURNS [svRelPtr: SVRelPtr] =    -- Creates an SV Entry and links it to parent pv and lv,    -- creating lv if necessary.    -- pv MUST not be nil!    BEGIN    lv: LVRelPtr;    sv: SVPtr;    svRelPtr ¬ NewSVEntry[];    sv ¬ @table[svRelPtr];    sv­ ¬ SVEntry[  -- (compile-time constant)      lvPage: --TRASH-- VolTable.nullLVPage,      pvPage: --TRASH-- VolTable.nullPVPage, state: offline, svLength: 0,      countMapped: 0, rootLV: TRASH, nextSVOfLV: TRASH, rootPV: TRASH,      nextSVOfPV: TRASH, lock: [unlocked[]]];    -- Link to LV:    lv ¬ FindLV[lvID];    IF lv = nil THEN lv ¬ CreateLVEntry[lvID];    sv.nextSVOfLV ¬ table[lv].firstSV;    sv.rootLV ¬ lv;    table[lv].firstSV ¬ svRelPtr;    table[lv].state ¬ partiallyOnline;    -- Link to PV:    sv.nextSVOfPV ¬ table[pv].firstSV;    sv.rootPV ¬ pv;    table[pv].firstSV ¬ svRelPtr;    END;  --CreateSVEntry--  CreateLVEntry: INTERNAL PROCEDURE [lvID: LVID] RETURNS [lv: LVRelPtr] =    BEGIN    lv ¬ NewLVEntry[];    table[lv] ¬ LVEntry[  -- (compile-time constant)      lvID: TRASH, handle: NIL, state: offline, readOnly: FALSE,      entireLVLocked: FALSE, currentAccesses: 0,      operationSeqsInProgress: 0, clientData: TRASH, etableInfo: TRASH,      nextLV: TRASH, firstSV: nil, lock: [unlocked[]]];    table[lv].lvID ¬ lvID;    table[lv].nextLV ¬ firstLV;    firstLV ¬ lv;    END;  --CreateLVEntry--  DecrementLocksOutstanding: INTERNAL PROCEDURE =    BEGIN locksOutstanding ¬ PRED[locksOutstanding]; END;  EndOperationSequenceInternal: PROCEDURE [lv: LVPtr] =    BEGIN    IF lv = NIL THEN Bug[noLVForOperationSequence];    IF lv.operationSeqsInProgress > 0 THEN      lv.operationSeqsInProgress ¬ lv.operationSeqsInProgress.PRED;    END;  --EndOperationSequenceInternal--  FindLV: INTERNAL PROCEDURE [lvID: LVID] RETURNS [lvPtr: LVRelPtr] =    -- Returns pointer to requested LV, nil if not found.    -- Caller MUST have monitor or entire lv locked.    BEGIN    IF lvLastFound ~= nil AND table[lvLastFound].lvID = lvID THEN      RETURN[lvLastFound];    FOR lvPtr ¬ firstLV, table[lvPtr].nextLV WHILE lvPtr ~= nil DO      IF table[lvPtr].lvID = lvID THEN {lvLastFound ¬ lvPtr; RETURN[lvPtr]};      ENDLOOP;    RETURN[nil];    END;  FindPV: INTERNAL PROCEDURE [pvID: PVID] RETURNS [pvPtr: PVRelPtr] =    -- Returns pointer to requested PV, nil if not found.    BEGIN    IF pvID = nullPVID THEN RETURN[nil];    FOR pvPtr ¬ firstPV, table[pvPtr].nextPV WHILE pvPtr ~= nil DO      IF table[pvPtr].pvID = pvID THEN RETURN[pvPtr]; ENDLOOP;    RETURN[nil];    END;  FindSVInternal: INTERNAL PROCEDURE [lvID: LVID, page: LVPage, svdPtr: VolTable.SVDescPtr]    RETURNS [      found: BOOLEAN,      channel: DiskBackingStore.ChannelHandle] =    BEGIN    svPtr: SVRelPtr ¬ SVFromLVID[lvID, page];    IF svPtr = nil THEN {      svdPtr­ ¬ VolTable.nullSVDesc;      RETURN[found: FALSE, channel: TRASH];}    ELSE {      ConstructSVDesc[svPtr, svdPtr];    -- Fill client's SVDesc through svdPtr.      RETURN[found: TRUE, channel: table[table[svPtr].rootPV].bsChannel];};    END;  ForceConsistencyInternal: PROCEDURE [lv: LVPtr] =    BEGIN    lvToken: LVToken = LVRelPtrFromLVPtr[lv];    IF lv = NIL THEN Bug[noLVForOperationSequence];    VolAllocMap.Close[lv.lvID, forceOut, lvToken];    lv.handle.changing ¬ FALSE;    VM.ForceOut[      [page: Space.PageFromLongPointer[lv.handle], count: LVF.rootPageSize],      wait];    END;  --ForceConsistencyInternal--  FreeLV: INTERNAL PROCEDURE [lv: LVPtr] =    -- Frees lv­.    -- Clients should invoke only via FreeLVIfUnusedAndOffline.    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    lvRelPtr: LVRelPtr = LVRelPtrFromLVPtr[lv];    IF lv.state ~= offline OR lv.currentAccesses > 0      OR lv.lock ~= [unlocked[]] OR lv.entireLVLocked THEN Bug[lvStillInUse];    -- Relink remaining LVs:    IF firstLV = lvRelPtr THEN firstLV ¬ lv.nextLV    ELSE      BEGIN  -- not first in list..      prevLV: LVRelPtr;      FOR prevLV ¬ firstLV, table[prevLV].nextLV UNTIL table[prevLV].nextLV =        lvRelPtr DO ENDLOOP;      table[prevLV].nextLV ¬ lv.nextLV;      END;    FreeLVEntry[lvRelPtr];    lvLastFound ¬ nil;  -- simplest to always invalidate on deletion.    END;  --FreeLVIfUnusedAndOffline--  LockRemainingSVs: INTERNAL PROCEDURE [    sv: SVRelPtr, accessRequired: VolTable.LVLockType]    RETURNS [lockability: Lockability] =    -- Locks sv and all of the LV's SVs which follow it in the chain    -- and returns lockability=okToLock; Note that locks ARE acquired.    -- If any of locks requested can not be acquired,    -- returns lockability=mustWait and no locks are acquired.    BEGIN    IF sv = nil THEN RETURN[okToLock];    IF LockStatus[accessRequired, @table[sv].lock] = mustWait THEN      RETURN[mustWait];    IF LockRemainingSVs[table[sv].nextSVOfLV, accessRequired] = mustWait THEN      RETURN[mustWait];    --ASSERT: All SVs following sv are locked.    AcquireLock[accessRequired, @table[sv].lock];    RETURN[okToLock];    END;  --LockRemainingSVs--  LockStatus: INTERNAL PROCEDURE [    accessRequired: VolTable.LVLockType, lock: LONG POINTER TO Lock]    RETURNS [lockability: Lockability] =    -- If caller can acquire the requested access to lock­, returns    -- $okToLock (lock is NOT acquired); otherwise, returns $mustWait.    BEGIN    IF accessRequired NOT IN VolTable.LVLockType THEN Bug[impossibleLockRequired];    RETURN[      SELECT accessRequired FROM        read =>          IF lock.state = read OR lock.state = unlocked THEN okToLock          ELSE mustWait,        maybeWrite, write, writeWithChangingFlag =>          IF lock.state = unlocked THEN okToLock ELSE mustWait,        ENDCASE => BugV[impossibleCase]];    END;  --LockStatus--  MapLVRootPage: INTERNAL PROCEDURE [tok: LVToken] =    BEGIN    root: LVF.Handle = table[tok].handle;    found: BOOLEAN;    svDesc: VolTable.SVDesc;    channel: DiskBackingStore.ChannelHandle;    runs: ARRAY [0..1) OF BackingStore.Run;    [found, channel] ¬ FindSVInternal[table[tok].lvID, LVF.rootPageNumber, @svDesc];    IF ~found THEN Bug[cantMapWithoutRoot];    runs[0] ¬ [      count: 1,      data: VolBackingStore.BSDataFromVolData[      [      id: IDHandle[lv[tok]], type: PilotFileTypes.tLogicalVolumeRootPage,      pvPage: svDesc.pvPageOfSV + svDesc.lvPageOfSV,      filePage: svDesc.lvPageOfSV, channelHandle: channel]]];    VM.Map[      interval: [Space.PageFromLongPointer[root], LVF.rootPageSize],      transferProc: VolBackingStore.Transfer, backingStoreRuns: DESCRIPTOR[runs],      usage: KernelSpaceUsage.lvRootPage];    END;  SVFromLVID: INTERNAL PROCEDURE [lvID: LVID, lvPage: LVPage]    RETURNS [sv: SVRelPtr] =    -- Returns pointer to requested sv, or nil if not found.    -- Caller MUST have monitor or entire lv locked.    BEGIN    lv: LVRelPtr ¬ FindLV[lvID];    IF lv = nil THEN RETURN[nil];    RETURN GetSVToken[lv, lvPage];    END;  --SVFromLVID--  TableLockStatus: INTERNAL PROCEDURE RETURNS [lockability: Lockability] =    -- If caller may not attempt to acquire access to any volumes,    -- returns $mustWait; otherwise returns returns $okToLock.    BEGIN    RETURN[      WITH tab: tableLock SELECT FROM        unlocked => okToLock,        read, writeWithChangingFlag => BugV[impossibleLockValue],        write =>          IF ProcessInternal.GetCurrent[] = tab.process THEN okToLock          ELSE mustWait,        ENDCASE => BugV[impossibleCase]];    END;  --TableLockStatus--  Unlock: INTERNAL PROCEDURE [lock: LONG POINTER TO Lock] =    -- Releases the lock held by caller.    BEGIN    newLock: Lock;    WITH old: lock SELECT FROM      unlocked => Bug[impossibleLockValue];      read =>        newLock ¬          (IF old.count > 1 THEN [read[count: old.count.PRED]] ELSE [unlocked[]]);      maybeWrite, write, writeWithChangingFlag => newLock ¬ [unlocked[]];      ENDCASE => Bug[impossibleCase];    lock­ ¬ newLock;    DecrementLocksOutstanding[];    IF newLock = [unlocked[]] THEN BROADCAST somethingUnlocked;    END;  --Unlock--  UnlockRemainingSVs: INTERNAL PROCEDURE [sv: SVRelPtr] =    -- Unlocks sv and all of the LV's SVs which follow it in the chain.    BEGIN    -- Since unlocking an sv may cause it to be deleted,    -- it is the most robust and understandable to delete the    -- last one in the chain first. This is done below.    IF table[sv].nextSVOfLV # nil THEN UnlockRemainingSVs[table[sv].nextSVOfLV];    --ASSERT: All SVs following sv are unlocked.    UnlockSVInternal[sv];    END;  --UnlockRemainingSVs--  UnlockSVInternal: INTERNAL PROCEDURE [svRelPtr: SVRelPtr] =    -- Releases caller's lock on sv.    -- Frees svRelPtr­ if offline; in this case, the order of the remaining    -- SVs on the LV and PV lists is guaranteed to be unchanged.    -- Frees LV of sv if it will have no SVs remaining.    BEGIN    ENABLE ANY => Bug[cleanupNotImplemented];    sv: SVPtr = @table[svRelPtr];    Unlock[@sv.lock];    IF sv.state = offline THEN      BEGIN  --delete the SV entry--      lvRelPtr: LVRelPtr = sv.rootLV;      lv: LVPtr = @table[lvRelPtr];      pv: PVPtr ¬ @table[sv.rootPV];      IF sv.countMapped ~= 0 OR sv.lock ~= [unlocked[]] THEN Bug[svStillInUse];      -- Relink SV's along the PV path:      IF pv.firstSV = svRelPtr THEN pv.firstSV ¬ sv.nextSVOfPV      ELSE        BEGIN  -- not first in list..        prevSV: SVRelPtr;        FOR prevSV ¬ pv.firstSV, table[prevSV].nextSVOfPV UNTIL table[          prevSV].nextSVOfPV = svRelPtr DO ENDLOOP;        table[prevSV].nextSVOfPV ¬ sv.nextSVOfPV;        END;      -- Relink SV's along the LV path:      IF lv.firstSV = svRelPtr THEN lv.firstSV ¬ sv.nextSVOfLV      ELSE        BEGIN  -- not first in list..        prevSV: SVRelPtr;        FOR prevSV ¬ lv.firstSV, table[prevSV].nextSVOfLV UNTIL table[          prevSV].nextSVOfLV = svRelPtr DO ENDLOOP;        table[prevSV].nextSVOfLV ¬ sv.nextSVOfLV;        END;      FreeSVEntry[svRelPtr];      lv.state ¬ IF lv.firstSV = nil THEN offline ELSE partiallyOnline;      FreeLVIfUnusedAndOffline[lv];      END;  --delete the SV entry--    END;  --UnlockSVInternal--  END.LOG11-Oct-82 14:02:44   JXP   	Created file for Klamath.12-Dec-82 13:27:39   JXP      Moved constants nullSVDesc, nullPVPage, nullLVPage to interface.   Implemented LockEntireLV[], GetSVToken[]. Removed the bsChannel and   markerPageLoc parameters from MapMarkerPage. Added GetID[]. Track   changes to interface. Add Get and Set Client Data Procs. Add lvPage parm.   to RegisterSV. Add entryState parm to LockEntireLV. Implement LV cache,   Remove  Inc and Dec PieceCount. Added tok parms to UnmapPVRoot and   UnmapMarkerPage. Make MapPVRootPage take a token and no funny args. FindSV   returns a BOOLEAN. Implement changing counts for LV consistency.15-Dec-82 14:15:55   JXP      Initialize DiskBackingStore using FileBascisPrograms.InitDiskBackingStore.13-Jan-83 11:24:03   JXP      Add RegisterPVMarkerID. Fix DeRegisterLV so it does not delete the entry.   Redo LV entry states to simply and add functionality. Change the names of   some of the utility procedures. Change the LV structure force out procs.   to use a stacking like interrupts. 4-Feb-83 11:10:59   WDK        Make compatible with new VolTable. Redid operation sequence stuff:   deleted forceOutCounterJustSet; use RETURN WITH ERROR. Redo up error   handling. Use long pointers where appropriate. MapPVRootPage,   UnmapPVRootPage, MapMarkerPage, UnmapMarkerPage, SetLVOffline,   SetSVOffline, GetVFMContext, SetClientData, SetClosed, SetOpen,   SetReadOnlyStatus, SetVFMContext, GetSVToken, ChangeSubVolume no   longer ENTRY. Redo errors raised by LVAccess per new VolTable.   Only check state of volume after it is unlocked. Clean up signals   vis-a-vis UNWIND. All volume types now use one type of lock.   Moved replicated locking code into subroutines. TableAccess allowed   concurrent table locks. Merged unlocked CONDITIONs.   LockEntireLV locks sv's atomically. LockEntireLV didn't make   offline sv's vanish. Demultiplexed sv parent pointer and next sv pointer.   Use common code to find svs. FreeLV didn't patch up lv list.   LV now created when needed: either on SVAccess or LVAccess;   and freed when no longer needed. lv's initial state now is writable.14-Feb-83 11:23:58   WDK        LockEntireLV[offlineVol] address faulted. SVFromLVID should return   nil if not found. LockStatus failed to check all flavors of write lock.   GetNextSV[next] died if prev sv went offline.   GetSVToken no longer requires LockEntireLV.23-Feb-83  9:39:28   WDK        LVAccessProc should not hide lv buffer. GetStatus renamed to GetLVStatus to solve export conflict in VolImpl. 5-May-83 10:13:38   AWL         *Access unlocked twice if client raised a signal from a catch phrase.27-May-83 11:49:05   JXP      Fix a problem having to do with multiple readers vs. mapping of PV root   and marker pages. Can't just keep a boolean isMapped, must keep count. 2-Jun-83 15:07:59   JXP      Restructure a bit so that "upward" calls to the VAM and VFM are not made   while holding the module's MONITOR. Changes to the following procedures:   LVAccess, UnlockLV, EndOperationSequence, EndOperationSequenceInternal,   ForceConsistency, GetOperationSequenceCount, BeginOperationSequence.   Procs which are no longer INTERNAL: EndOperationSequenceInternal,   BeginOperationSequenceInternal, ForceConsistencyInternal.26-Aug-83 15:00:30   JXP      Check changing flag, not op. seq. count to determine whether to force out   the root page in BeginOperationSequenceInternal22-Sep-83 17:56:45   CAJ    LockEntireLVInternal and TableAccess must use unlocked boolean in   userproc catch ANY.21-Nov-83 16:58:02   WDK        AR4795: SetOpen, SetClosed must set operationSeqsInProgress ¬ 0.   AR4902: LockEntireLVInternal did not wait for ~entireLVLocked. 6-Aug-84 14:54:53   AWL         Missing ENTRY on some procs28-Aug-84 15:20:50   CJS       Removed usedForMap field from LVEntry, and lvID field from SVEntry.   First was unused, second was redundant.(AR 6056,6055).12-Sep-84 16:24:07  CJS       Do VM.Deactivate of rootpage after an LVAccess if accessed vol was not open.   See AR 6201. 25-Oct-84 11:20:50  CJS       Make FindLV INTERNAL, to protect lvlastFound. Split FindSV into entry/internal and monitor call path to FindLV.29-Jan-85 15:05:47  CJS       Implement ConstructSVDesc such that it fills client pointer rather than returning large return frame.  Make GetNextSV and FindSV play this game. AR 6275.11-Jun-86 16:55:39  CJS  Added GetLVHandle and GetLVID for ETable implementation.11-Jun-86 17:45:06  RSV   Added MapDuplicatePVRootPage and UnmapDuplicatePVRootPage procedures.  Changed PVEntry.countMapped to countMainMapped and added countDuplicateMapped.18-Jun-86 11:15:17  CJS  Twiddling LVEntry.vfmInfo ¬ etableInfo. No more ETable.Close in ForceConsistencyInternal. 7-Jul-86 17:31:19  RSV   Changed InitLabelTransfer to InitDataTransfer.19-Nov-86 15:36:53  RSV   Added GetVolumeIndex procedure.  Changed MapMarkerPage to map readWrite if write OR maybeWrite15-Dec-86 15:40:33  RSV   Deleted PVF.duplicateRootPageNumber and instead get its location from PilotDiskFace.GetDeviceAttributes at table set-up time.  Therefore, also add entry to PVEntry for duplicateRootPageNumber  7-Jan-87 15:07:52 RRR   Made changes necessary to move lv root page without changing lv numbering
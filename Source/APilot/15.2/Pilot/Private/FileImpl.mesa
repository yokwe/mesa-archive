-- Copyright (C) 1984, 1985, 1986, 1987, 1988, 1989  by Xerox Corporation. All rights reserved. -- FileImpl.mesa  10-May-89 23:28:14 by TxH   DIRECTORY  BackingStore USING [Data, Run],  Boot USING [BootFileDescriptorPageHandle, BootFileDescriptorPageSeal,    BootFileDescriptorPageVersion, BootFileType, eofDescriptorLink, LVBootFiles,    maxPageRunsPerPage],  DataTransfer USING [ReadData],  Device USING [Type],  DiskBackingStore USING [    BSDataFromDiskData, ChannelHandle, Data, DiskDataFromBSData, GetDiskChannel,    PackFilePageNumber, UnpackFilePageNumber],  DiskChannel USING [    defaultTries, DiskChannelPrivate, diskOpWordAlignment, DirectOperation,    DoDirectIO, Drive, GetDrive, GetDriveAttributes, GetPageAddress, Handle,    IOStatus, operationSize],  Environment USING [    Base, first64K, PageCount, PageFromLongPointer, PageNumber, wordsPerPage],  ETable USING [    CreateETable, DeleteETable, Error, GetFileAttributes, GetPageGroup,     PageGroup, PageGroupHandle, SetBootable, SetTemporary],  File USING [    ErrorType, File, ID, maxPagesPerFile, nullID, PageCount, PageNumber, Type],  FileExtras USING [],  FileInternal USING [FileID, MakePermanentOrTemporaryAction],  FileLock USING [GetFileIDFromLock, IsOkToDeleteFile, lockingEnabled],  FileMgrPerf USING [],  FileTypes USING [tUnassigned],  FMPrograms USING [],  Inline USING [LongCOPY, LowHalf],  KernelFile USING [Cache, Descriptor, FilePtr, PageGroup],  KernelSpaceUsage USING [miscFileImplData],  LogicalVolumeFormat USING [Handle],  PhysicalVolume USING [Error, ID, nullID, PageNumber],  PilotDisk USING [FileID, FilePageNumber],  PilotDiskFace USING [Command, DiskAddress],  PilotFileTypes USING [PilotRootFileType, PilotVFileType],  ResidentHeap USING [FreeNode, MakeNode],  RuntimeInternal USING [Bug],  SimpleFile USING [    GetAttributes, GetBackingStoreData, GetFileDescriptor, GetSize, SetSize,    SetSizeInternal],  Space USING [    Allocate, Deallocate, Error, InsufficientSpace, Interval,    PageFromLongPointer],  SpecialFile USING [GetBackingStoreRun, InvalidParameters],  SpecialVolume USING [GetLogicalVolumeBootFiles, SetLogicalVolumeBootFiles],  System USING [VolumeID],  TemporaryBootingExtras USING [ErrorType],  VM USING [Interval, Map, nullInterval, Unmap],  VolAllocMap USING [AllocPageGroup, FreePageGroup],  VolTable USING [    FindSV, GetBSChannel, GetNextPV, GetNextSV, GetLVStatus, LVAccess,    LVAccessProc, LVToken, nullPVPage, PVAccess, PVAccessProc, SVDesc],  Volume USING [ID, InsufficientSpace, PageCount, PageNumber],  Zone USING [Status];FileImpl: PROGRAM  IMPORTS    DataTransfer, DiskBackingStore, DiskChannel, ETable, FileLock, Inline,    PhysicalVolume, ResidentHeap, RuntimeInternal, SimpleFile, Space,    SpecialFile, SpecialVolume, VM, VolAllocMap, Volume, VolTable  EXPORTS    File, FileExtras, FileInternal, FileMgrPerf, FMPrograms,    KernelFile, SpecialFile, TemporaryBootingExtras =  BEGIN  -- Public Items:    ID: PUBLIC --File-- TYPE = FileInternal.FileID;  nCreates, nDeletes, nGetAttributes, nSetSizes:    PUBLIC --FileMgrPerf.-- LONG CARDINAL ¬ 0;  Error: PUBLIC --File-- ERROR [type: File.ErrorType] = CODE;  MissingPages: PUBLIC --File-- ERROR [    file: File.File, firstMissing: File.PageNumber,    countMissing: File.PageCount] = CODE;  Unknown: PUBLIC --File-- ERROR [file: File.File] = CODE;  FileIsMapped: PUBLIC --FileExtraExtras-- ERROR [file: File.File] = CODE;  InvalidParameters: PUBLIC --SpecialFile-- ERROR = CODE;  BootableFileError: PUBLIC --TemporaryBootingExtras-- ERROR [    type: TemporaryBootingExtras.ErrorType] = CODE;  << /// TEMPORARY /// >>  MultiGroupUCodeOrGerm: PUBLIC --TemporaryBootingExtras-- SIGNAL = CODE;  -- Private Items:    initialPageGroups: CARDINAL = 10; -- initial number of page groups for sequences  AllocationSource: TYPE = {frame, createdSpace}; -- where is storage from  PageGroups: TYPE = RECORD [    pageGroups: ETable.PageGroupHandle,    storage: SELECT allocated: AllocationSource FROM      frame => [], createdSpace => [interval: Space.Interval] ENDCASE];      ExistingFile: ERROR [file: File.File] = CODE;  Bug: PROCEDURE [bugType: BugType] = {RuntimeInternal.Bug[bugType]};  BugV: PROCEDURE [bugType: BugType] RETURNS [UNSPECIFIED] = {    Bug[bugType]; RETURN[0]};  BugType: TYPE = {    allocationError, badIOStatus, clientError, duplicateFileIDError,    fileExcessivelyFragmented, fileSystemError, fileSystemInconsistency,    freeError, noSuchCase, notValidPilotRootFileType, outOfFileIDs};  InitFile: PUBLIC --FMPrograms-- PROCEDURE[] =    BEGIN    END;  Create: PUBLIC --File-- PROCEDURE [    volume: System.VolumeID, initialSize: File.PageCount, type: File.Type]    RETURNS [file: File.File] =    BEGIN    CreateLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =      BEGIN      file.fileID ¬ CreateFileID[lvHandle, tok];      CreateInternal[        file: file, lvHandle: lvHandle, tok: tok, initialSize: initialSize,        type: type, interval: VM.nullInterval !        ExistingFile => Bug[duplicateFileIDError]];      END;  --CreateLVProc--          IF initialSize = 0 OR initialSize > File.maxPagesPerFile THEN      ERROR Error[invalidParameters];    IF type IN PilotFileTypes.PilotVFileType THEN ERROR Error[reservedType];    file.volumeID ¬ volume;    VolTable.LVAccess[      lvID: volume, proc: CreateLVProc, lock: writeWithChangingFlag,      entryState: open];    END;  --Create--  CreateFileID: PROCEDURE [    lvHandle: LogicalVolumeFormat.Handle, tok: VolTable.LVToken]    RETURNS [fileID: File.ID] =    BEGIN    IF lvHandle.lastIDAllocated >= LAST[ID] THEN Bug[outOfFileIDs]    ELSE RETURN[lvHandle.lastIDAllocated ¬ lvHandle.lastIDAllocated + 1];    END;  --CreateFileID--  CreateInternal: PUBLIC --FileInternal-- PROCEDURE [    file: File.File, lvHandle: LogicalVolumeFormat.Handle, tok: VolTable.LVToken,    initialSize: File.PageCount, type: File.Type, interval: VM.Interval] =    BEGIN        GetMorePageGroups: PROCEDURE [old: PageGroups] RETURNS [new: PageGroups] =      BEGIN      newSize: CARDINAL =  -- allocate a single extra page	WITH o: old SELECT FROM	  frame => 1,	  createdSpace =>	    IF o.interval.count = LAST[CARDINAL] THEN	      BugV[fileExcessivelyFragmented]	    ELSE CARDINAL[o.interval.count + 1],	  ENDCASE => BugV[noSuchCase];      newSpace: Space.Interval = 	Space.Allocate[newSize ! Space.InsufficientSpace => Bug[allocationError]];      VM.Map[	interval: [Space.PageFromLongPointer[newSpace.pointer], newSize],	transferProc: NIL, backingStoreRuns: NIL, life: alive,	usage: KernelSpaceUsage.miscFileImplData, swappability: resident,	swapUnits: [unitary[]]];      new ¬ [	DESCRIPTOR[	  newSpace.pointer,	  (newSize * Environment.wordsPerPage) / SIZE[ETable.PageGroup]],	createdSpace[newSpace]];      Inline.LongCOPY[        from: @old.pageGroups[0],	nwords: LENGTH[old.pageGroups] * SIZE[ETable.PageGroup],	to: @new.pageGroups[0]];      -- The above is equivalent to:      -- FOR i: CARDINAL IN [0..LENGTH[old.pageGroups]) DO      --   new.pageGroups[i] ¬ old.pageGroups[i];      --   ENDLOOP;      FinishWithPageGroups[old];      END;  --GetMorePageGroups--    FinishWithPageGroups: PROCEDURE [pageGroups: PageGroups] =      BEGIN      WITH group: pageGroups SELECT FROM	frame => NULL;	createdSpace =>	  BEGIN	  [] ¬ VM.Unmap[Space.PageFromLongPointer[group.interval.pointer]];	  Space.Deallocate[group.interval];	  END;	ENDCASE => Bug[noSuchCase];      END;  --FinishWithPageGroups--    fileD: KernelFile.Descriptor ¬ [      fileID: file.fileID, volumeID: file.volumeID, temporary: TRUE, size: 0,      type: type];    group: KernelFile.PageGroup;    prevGroup: KernelFile.PageGroup ¬ [      filePage: 0, volumePage: 0, nextFilePage: 0];    remaining: File.PageCount;    groupSize: CARDINAL;    currentContents: VM.Interval ¬ interval;    countPageGroups: CARDINAL ¬ 0;    defaultPageGroups: ARRAY [0..initialPageGroups) OF ETable.PageGroup;    pageGroups: PageGroups ¬ [DESCRIPTOR[defaultPageGroups], frame[]];    filePage: File.PageNumber;        IF type = FileTypes.tUnassigned THEN ERROR Error[reservedType];    IF SimpleFile.GetFileDescriptor[      file: file, lvHandle: lvHandle, tok: tok, fileDescPtr: @fileD].found THEN      ERROR ExistingFile[file];    IF lvHandle.freePageCount < initialSize      THEN ERROR Volume.InsufficientSpace[lvHandle.freePageCount, file.volumeID];    nCreates ¬ nCreates + 1;    -- must get all page groups at once and pass to ETable software    UNTIL (fileD.size = initialSize) DO      BEGIN      ENABLE ANY => Bug[fileSystemError];      group ¬ [        filePage: prevGroup.nextFilePage,        volumePage: prevGroup.volumePage +	   (prevGroup.nextFilePage - prevGroup.filePage),        nextFilePage: initialSize];      VolAllocMap.AllocPageGroup[        vol: lvHandle, filePtr: @fileD, groupPtr: @group,        data: currentContents, tok: tok !        Volume.InsufficientSpace => GO TO Undo];	-- results in modified group and FilePtr.size      remaining ¬ group.nextFilePage - group.filePage;      WHILE remaining > 0 DO        groupSize ¬ 	  CARDINAL[MIN[group.nextFilePage - group.filePage, LAST[CARDINAL]]];	IF countPageGroups >= LENGTH[pageGroups.pageGroups] THEN	  pageGroups ¬ GetMorePageGroups[pageGroups];        pageGroups.pageGroups[countPageGroups] ¬          [count: groupSize, volumePage: group.volumePage];        countPageGroups ¬ countPageGroups + 1;        SELECT TRUE FROM          currentContents.count = 0 => NULL; -- currentContents = VM.nullInterval	  currentContents.count > groupSize =>	    currentContents ¬	      [currentContents.page+groupSize, currentContents.count-groupSize];	  ENDCASE => -- currentContents.count <= groupSize	    currentContents ¬ VM.nullInterval;	group ¬ [	  filePage: group.filePage + groupSize,	  volumePage: group.volumePage + groupSize,	  nextFilePage: group.nextFilePage];	  -- don't increment nextFilePage since we it should always be set to	  -- the next file page after what the VAM allocated (as it already is 	  -- is from before entering loop).	remaining ¬ remaining - groupSize;	ENDLOOP;      prevGroup ¬ group;      END;  --ENABLE      REPEAT        Undo => {	  filePage ¬ 0;	  FOR i: CARDINAL IN [0..countPageGroups) DO	    group ¬ [filePage, pageGroups.pageGroups[i].volumePage,	      filePage + pageGroups.pageGroups[i].count];            VolAllocMap.FreePageGroup[	      vol: lvHandle, filePtr: @fileD, groupPtr: @group, tok: tok];	    filePage ¬ filePage + pageGroups.pageGroups[i].count;            ENDLOOP;	  FinishWithPageGroups[pageGroups];	  ERROR Volume.InsufficientSpace[lvHandle.freePageCount, file.volumeID];	  };      ENDLOOP;    pageGroups.pageGroups.LENGTH ¬ countPageGroups;    ETable.CreateETable[tok, fileD.fileID, pageGroups.pageGroups, type !      Volume.InsufficientSpace => {        filePage ¬ 0;        FOR i: CARDINAL IN [0..countPageGroups) DO	  group ¬ [filePage, pageGroups.pageGroups[i].volumePage,	    filePage + pageGroups.pageGroups[i].count];          VolAllocMap.FreePageGroup[	    vol: lvHandle, filePtr: @fileD, groupPtr: @group, tok: tok];          ENDLOOP;	FinishWithPageGroups[pageGroups];        ERROR Volume.InsufficientSpace[          lvHandle.freePageCount, file.volumeID];}];    FinishWithPageGroups[pageGroups];    lvHandle.numberOfFile ¬ lvHandle.numberOfFile.SUCC;    END;  --CreateInternal--      CreateWithContents: PUBLIC --SpecialFile-- PROCEDURE [    volume: System.VolumeID, initialSize: File.PageCount, type: File.Type,    contents: Space.Interval, requestedID: ID] RETURNS [file: File.File] =    BEGIN    CreateWithContentsLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =      BEGIN      IF requestedID = LOOPHOLE[File.nullID, ID] THEN        file.fileID ¬ CreateFileID[lvHandle, tok]      ELSE {        IF requestedID >= LAST[ID] THEN ERROR SpecialFile.InvalidParameters;	lvHandle.lastIDAllocated ¬ MAX[lvHandle.lastIDAllocated, requestedID];	file.fileID ¬ requestedID};      CreateInternal[        file: file, lvHandle: lvHandle, tok: tok, initialSize: initialSize,        type: type,        interval: [	  page: Space.PageFromLongPointer[contents.pointer],	  count: contents.count] !        ExistingFile => ERROR SpecialFile.InvalidParameters];      END;  --CreateWithContentsLVProc--    IF initialSize = 0 OR initialSize > File.maxPagesPerFile THEN      ERROR SpecialFile.InvalidParameters;    IF type IN PilotFileTypes.PilotVFileType THEN ERROR Error[reservedType];    file.volumeID ¬ volume;    VolTable.LVAccess[      lvID: volume, proc: CreateWithContentsLVProc, lock: writeWithChangingFlag,      entryState: open];    END;  --CreateWithContents--  Delete: PUBLIC --File-- PROCEDURE [file: File.File] =    BEGIN    DeleteLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =      BEGIN      DeleteInternal[file: file, lvHandle: lvHandle, tok: tok];      END;  --DeleteLVProc--    VolTable.LVAccess[      lvID: file.volumeID, proc: DeleteLVProc, lock: write,      entryState: open];    END;  --Delete--  DeleteInternal: PUBLIC --FileInternal-- PROCEDURE [     file: File.File, lvHandle: LogicalVolumeFormat.Handle,    tok: VolTable.LVToken] =    BEGIN    PageGroupsType: TYPE = RECORD [      pageGroups: LONG DESCRIPTOR FOR ARRAY OF KernelFile.PageGroup,      storage: SELECT allocated: AllocationSource FROM        frame => [], createdSpace => [interval: Space.Interval] ENDCASE];    countPageGroups: CARDINAL ¬ 0;    filePage: File.PageCount ¬ 0;    fileD: KernelFile.Descriptor;    group: KernelFile.PageGroup;    defaultPageGroups: ARRAY [0..initialPageGroups) OF KernelFile.PageGroup;    pageGroups: PageGroupsType ¬ [DESCRIPTOR[defaultPageGroups], frame[]];    success: BOOLEAN;        GetMorePageGroups: PROCEDURE [old: PageGroupsType]       RETURNS [new: PageGroupsType] =      BEGIN      newSize: CARDINAL =  -- allocate a single extra page	WITH o: old SELECT FROM	  frame => 1,	  createdSpace =>	    IF o.interval.count = LAST[CARDINAL] THEN	      BugV[fileExcessivelyFragmented]	    ELSE CARDINAL[o.interval.count + 1],	  ENDCASE => BugV[noSuchCase];      newSpace: Space.Interval = 	Space.Allocate[newSize ! Space.InsufficientSpace => Bug[allocationError]];      VM.Map[	interval: [Space.PageFromLongPointer[newSpace.pointer], newSize],	transferProc: NIL, backingStoreRuns: NIL, life: alive,	usage: KernelSpaceUsage.miscFileImplData, swappability: resident,	swapUnits: [unitary[]]];      new ¬ [	DESCRIPTOR[	  newSpace.pointer,	  (newSize * Environment.wordsPerPage) / SIZE[KernelFile.PageGroup]],	createdSpace[newSpace]];      Inline.LongCOPY[        from: @old.pageGroups[0],	nwords: LENGTH[old.pageGroups] * SIZE[KernelFile.PageGroup],	to: @new.pageGroups[0]];      -- The above is equivalent to:      -- FOR i: CARDINAL IN [0..LENGTH[old.pageGroups]) DO      --   new.pageGroups[i] ¬ old.pageGroups[i];      --   ENDLOOP;      FinishWithPageGroups[old];      END;  --GetMorePageGroups--    FinishWithPageGroups: PROCEDURE [pageGroups: PageGroupsType] =      BEGIN      WITH group: pageGroups SELECT FROM	frame => NULL;	createdSpace =>	  BEGIN	  [] ¬ VM.Unmap[Space.PageFromLongPointer[group.interval.pointer]];	  Space.Deallocate[group.interval];	  END;	ENDCASE => Bug[noSuchCase];      END;  --FinishWithPageGroups--    nDeletes ¬ nDeletes + 1;    GetFileDescriptorSignals[      file: file, lvHandle: lvHandle, tok: tok, fileDescPtr: @fileD];    IF NOT FileLock.IsOkToDeleteFile[file] THEN <<**>>      ERROR Space.Error[stillMapped];  -- File is still mapped    IF ETable.GetFileAttributes[tok, file.fileID].bootable      THEN fileD.size ¬ MakeUnbootableInternal[        tok: tok, file: file, fileSize: fileD.size, type: fileD.type,        lvHandle: lvHandle ! BootableFileError => CONTINUE];    DO  -- Get page groups starting with first through the last.      [success, group] ¬ ETable.GetPageGroup[  --get last page group--        token: tok, fileID: file.fileID, filePage: filePage];  	-- group.nextFile page is size of file      IF countPageGroups >= LENGTH[pageGroups.pageGroups] THEN         pageGroups ¬ GetMorePageGroups[pageGroups];      pageGroups.pageGroups[countPageGroups] ¬ group;      countPageGroups ¬ countPageGroups + 1;      filePage ¬ group.nextFilePage;      IF filePage = fileD.size  THEN EXIT;      ENDLOOP;    pageGroups.pageGroups.LENGTH ¬ countPageGroups;    ETable.DeleteETable[tok, file.fileID];    WHILE countPageGroups > 0 DO      group ¬ pageGroups.pageGroups[countPageGroups - 1];      VolAllocMap.FreePageGroup[        vol: lvHandle, filePtr: @fileD, groupPtr: @group, tok: tok];      countPageGroups ¬ countPageGroups - 1;      ENDLOOP;    FinishWithPageGroups[pageGroups];    END;  --DeleteInternal--  DoBootfileOp: PROC [drive: DiskChannel.Drive, command: PilotDiskFace.Command,    da: PilotDiskFace.DiskAddress, dataPtr: LONG POINTER, count: CARDINAL]    RETURNS [success: BOOLEAN, diskHeader: PilotDiskFace.DiskAddress] =    BEGIN    ioStatus: DiskChannel.IOStatus;    op: LONG POINTER TO DiskChannel.DirectOperation;    opStorage: Environment.Base RELATIVE POINTER;    AllocateDirectOperation: PROC      RETURNS [        pOp: LONG POINTER TO DiskChannel.DirectOperation,        pStorage: Environment.Base RELATIVE POINTER TO UNSPECIFIED] =      -- pOp will be aligned per requirements of DoDirectIO.      -- pStorage should be used when freeing.      INLINE BEGIN      rpDirOp: Environment.Base RELATIVE POINTER TO DiskChannel.DirectOperation;      status: Zone.Status;      [pStorage, status] ¬ ResidentHeap.MakeNode[        n: DiskChannel.operationSize + DiskChannel.diskOpWordAlignment - 1,        alignment: a1];      IF status ~= okay THEN Bug[allocationError];      rpDirOp ¬ pStorage;      pOp ¬ @Environment.first64K[rpDirOp];      pOp ¬ LOOPHOLE[((LOOPHOLE[pOp, LONG CARDINAL] +        SIZE[DiskChannel.DiskChannelPrivate] + DiskChannel.diskOpWordAlignment-1)	  / DiskChannel.diskOpWordAlignment) * DiskChannel.diskOpWordAlignment	    - SIZE[DiskChannel.DiskChannelPrivate]];      END;  --AllocateDirectOperation--    FreeDirectOperation: PROC [pStorage: Environment.Base RELATIVE POINTER] =      INLINE {status: Zone.Status ¬ ResidentHeap.FreeNode[pStorage];      IF status ~= okay THEN Bug[freeError]};    [op, opStorage] ¬ AllocateDirectOperation[];    op.diskOp ¬ [      clientHeader: da, dataPtr: dataPtr, incrementDataPtr: TRUE,      command: command, tries: DiskChannel.defaultTries, pageCount: count,      device: DiskChannel.GetDriveAttributes[drive].deviceHandle];    ioStatus ¬      DiskChannel.DoDirectIO[operation: op, mode: channelException].status;    diskHeader ¬ op.diskOp.diskHeader;    FreeDirectOperation[opStorage];    WITH s: ioStatus SELECT FROM      invalidChannel, invalidDriveState => Bug[badIOStatus];      disk =>        SELECT s.status FROM          inProgress => Bug[badIOStatus];          goodCompletion => success ¬ TRUE;          notReady, recalibrateError, seekTimeout, headerCRCError, reserved6,            dataCRCError, headerNotFound, reserved9, dataVerifyError,            overrunError, writeFault, memoryError, memoryFault, clientError,            operationReset, otherError => success ¬ FALSE;          ENDCASE => Bug[noSuchCase];      ENDCASE => Bug[noSuchCase];    END;  --DoBootfileOp--  GetAttributes: PUBLIC --File-- PROCEDURE [file: File.File]    RETURNS [type: File.Type, temporary: BOOLEAN] =    BEGIN     nGetAttributes ¬ nGetAttributes+1;    RETURN SimpleFile.GetAttributes[file];     END;  --GetAttributes--  GetBackingStoreRun: PUBLIC --SpecialFile-- PROCEDURE [    file: File.File, page: File.PageNumber, type: File.Type]    RETURNS [run: BackingStore.Run, resultType: File.Type] =    BEGIN    data: DiskBackingStore.Data;    runLength: File.PageCount;    GetBackingStoreRunLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =      BEGIN      [fileData: data, runLength: runLength, resultType: resultType] ¬        SimpleFile.GetBackingStoreData[file.fileID, lvHandle, page, type, tok];      END;  --GetBackingStoreRunLVProc--    VolTable.LVAccess[      lvID: file.volumeID, proc: GetBackingStoreRunLVProc, lock: read,      entryState: open];    RETURN[      run: [count: runLength, data: DiskBackingStore.BSDataFromDiskData[data]],        resultType: resultType];    END;  --GetBackingStoreRun--  GetBackingStoreRunWithCache: PUBLIC --KernelFile-- PROCEDURE [    file: File.File, page: File.PageNumber, type: File.Type,    cache: KernelFile.Cache]    RETURNS [run: BackingStore.Run, resultType: File.Type] =    BEGIN    oldData: DiskBackingStore.Data;    oldPage: File.PageNumber;    fileID: File.ID;    IF cache # NIL THEN       BEGIN       oldData ¬ LOOPHOLE[cache.data];      oldPage ¬ DiskBackingStore.PackFilePageNumber[                  oldData.filePageLow, oldData.filePageHigh];      WITH d: oldData SELECT FileLock.lockingEnabled FROM        TRUE => fileID ¬ FileLock.GetFileIDFromLock[d.lock].fileID;	FALSE => fileID ¬ d.file;	ENDCASE;      IF fileID = file.fileID AND page IN [oldPage..oldPage+cache.count) THEN         BEGIN        -- update old data from cache --	[oldData.filePageLow, oldData.filePageHigh] ¬          DiskBackingStore.UnpackFilePageNumber[page];        oldData.volumePage ¬ oldData.volumePage + (page-oldPage);        run.data ¬ LOOPHOLE[oldData];        run.count ¬ cache.count - (page-oldPage);        resultType ¬ oldData.type;	RETURN;        END;      END;    -- IF cache=nil or page not in cache get new data for cache --    [run, resultType] ¬ SpecialFile.GetBackingStoreRun[file, page, type];    cache­ ¬ run;    END;  --GetBackingStoreRunWithCache--  GetBootLocation: PUBLIC --KernelFile-- PROCEDURE [    file: File.File, filePage: File.PageNumber]    RETURNS [      deviceType: Device.Type, deviceOrdinal: CARDINAL,      diskAddress: PilotDiskFace.DiskAddress] =    BEGIN    GetBootLocationLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =      BEGIN      bootable: BOOLEAN;      buffer: Space.Interval;      bufferSize: CARDINAL = 2;      drive: DiskChannel.Drive;      fileSize: File.PageCount;      Cleanup: PROC =        {VM.Unmap[Environment.PageFromLongPointer[buffer.pointer]];        Space.Deallocate[buffer]};      [fileSize: fileSize, bootable: bootable] ¬        ETable.GetFileAttributes[token: tok, fileID: file.fileID	! ETable.Error => IF error = fileNotFound THEN ERROR Unknown[file]];      IF ~bootable THEN ERROR BootableFileError[notBootable];      IF filePage >= fileSize THEN ERROR SpecialFile.InvalidParameters;      buffer ¬ Space.Allocate[count: bufferSize];      -- The data space here allocated consists of one page for the first      -- descriptor page and one for the head-level buffer.      VM.Map[interval: [Environment.PageFromLongPointer[buffer.pointer],        bufferSize], transferProc: NIL, backingStoreRuns: NIL,        usage: KernelSpaceUsage.miscFileImplData, class: file, access: readWrite,        swapUnits: [unitary[]], life: alive, swappability: resident];      BEGIN ENABLE UNWIND => Cleanup[];      [diskAddress: diskAddress, drive: drive] ¬ GetBootLocationInternal[        file: file, filePage: filePage, fileSize: fileSize, buffer: buffer,        tok: tok];      END;  -- scope of ENABLE      Cleanup[];      [deviceType: deviceType, deviceOrdinal: deviceOrdinal] ¬        DiskChannel.GetDriveAttributes[drive];      END;  --GetBootLocationLVProc--    VolTable.LVAccess[      lvID: file.volumeID, proc: GetBootLocationLVProc, lock: read,      entryState: open];    END;  --GetBootLocation--  GetBootLocationInternal: PROCEDURE [    file: File.File, filePage: File.PageNumber, fileSize: File.PageCount,    buffer: Space.Interval, tok: VolTable.LVToken]    RETURNS [diskAddress: PilotDiskFace.DiskAddress, drive: DiskChannel.Drive] =    BEGIN    daFilePage: PilotDiskFace.DiskAddress;    desc: Boot.BootFileDescriptorPageHandle ¬      buffer.pointer + Environment.wordsPerPage;    descFilePage: File.PageNumber;    success: BOOLEAN;    [drive: drive, address: daFilePage] ¬ GetDiskAddress[volume: file.volumeID,      volumePage: GetVolumePage[file.fileID, filePage, tok]];    descFilePage ¬ fileSize - 1;    DO -- Look through all descriptors for one with filePage first      GetDescriptor[file: file, filePage: descFilePage, desc: desc, tok: tok];      IF desc.pageRuns[0].da = daFilePage THEN EXIT;  -- found right descriptor      IF desc.header.totalDescriptorPages = desc.header.thisDescriptorPages	THEN ERROR BootableFileError[notBootable];  -- no more descriptors      descFilePage ¬ descFilePage - desc.header.thisDescriptorPages;      ENDLOOP;    -- Get head level to tell us what boot location is for this one.    [success: success, diskHeader: diskAddress] ¬ DoBootfileOp[      drive: drive, command: getBootLocation, dataPtr: buffer.pointer,      count: CARDINAL[buffer.count], da: GetDiskAddress[volume: file.volumeID,      volumePage: GetVolumePage[file.fileID, descFilePage, tok]].address];    IF ~success THEN ERROR BootableFileError[fileAccessProblem];    END;  --GetBootLocationInternal--  GetDescriptor: PROCEDURE [file: File.File, filePage: File.PageNumber,    desc: Boot.BootFileDescriptorPageHandle, tok: VolTable.LVToken] =    BEGIN    [] ¬ DataTransfer.ReadData[volume: file.volumeID,      volumePage: GetVolumePage[file.fileID, filePage, tok],      memoryPage: Environment.PageFromLongPointer[desc], handleErrors: TRUE,      tok: tok];    IF desc.header.seal ~= Boot.BootFileDescriptorPageSeal OR      desc.header.version ~= Boot.BootFileDescriptorPageVersion	THEN ERROR BootableFileError[notBootable];    END;  GetDiskAddress: PROCEDURE [volume: Volume.ID, volumePage: Volume.PageNumber]    RETURNS [      diskChannelHandle: DiskChannel.Handle,      diskBackingStoreChannelHandle: DiskBackingStore.ChannelHandle,      drive: DiskChannel.Drive,      physicalVolumePageNumber: PhysicalVolume.PageNumber,      address: PilotDiskFace.DiskAddress] =    BEGIN    svDesc: VolTable.SVDesc;    [channel: diskBackingStoreChannelHandle] ¬ VolTable.FindSV[      lvID: volume, page: volumePage, svdPtr: @svDesc];    diskChannelHandle ¬ DiskBackingStore.GetDiskChannel[      diskBackingStoreChannelHandle];    drive ¬ DiskChannel.GetDrive[diskChannelHandle];    physicalVolumePageNumber ¬      svDesc.pvPageOfSV + volumePage;    address ¬ DiskChannel.GetPageAddress[      drive: drive, page: physicalVolumePageNumber];    END;  --GetDiskAddress--  GetFileAttributes: PUBLIC --KernelFile-- PROCEDURE [file: File.File]    RETURNS [size: File.PageCount, readOnly: BOOLEAN] =    {RETURN[      SimpleFile.GetSize[file], VolTable.GetLVStatus[file.volumeID].readOnly]};  GetFileDescriptorSignals: PROCEDURE [    file: File.File, lvHandle: LogicalVolumeFormat.Handle, tok: VolTable.LVToken,    fileDescPtr: KernelFile.FilePtr] = INLINE    BEGIN    IF NOT SimpleFile.GetFileDescriptor[      file: file, lvHandle: lvHandle, tok: tok, fileDescPtr: fileDescPtr].found      THEN ERROR Unknown[file];    END;  --GetFileDescriptorSignals--  GetRootFile: PUBLIC --KernelFile-- PROCEDURE [    volume: Volume.ID, type: File.Type] RETURNS [file: File.ID] =    BEGIN    GetRootFileProc: VolTable.LVAccessProc --[tok, lvHandle]--  =      BEGIN file ¬ GetRootFileInternal[lvHandle, type]; END;  --GetRootFileProc    IF type NOT IN PilotFileTypes.PilotRootFileType THEN      Bug[notValidPilotRootFileType];    VolTable.LVAccess[      lvID: volume, proc: GetRootFileProc, lock: read, entryState: open];    END;  --GetRootFile--  GetRootFileInternal: PROCEDURE [    lvHandle: LogicalVolumeFormat.Handle, type: File.Type]    RETURNS [file: File.ID] = INLINE {file ¬ lvHandle.rootFileID[type]};  GetSize: PUBLIC --File-- PROCEDURE [file: File.File]    RETURNS [size: File.PageCount] = {RETURN[SimpleFile.GetSize[file]]};  GetVolumePage: PROCEDURE    [fileID: File.ID, filePage: File.PageNumber, tok: VolTable.LVToken]    RETURNS [volumePage: Volume.PageNumber] =    BEGIN    found: BOOLEAN;    group: KernelFile.PageGroup;    [found: found, group: group] ¬ ETable.GetPageGroup[      token: tok, fileID: fileID, filePage: filePage];    IF ~found THEN SpecialFile.InvalidParameters;  -- no such filePage    volumePage ¬ group.volumePage + (filePage - group.filePage);    END;  InterpretBackingStoreRun: PUBLIC --SpecialFile-- PROCEDURE [    run: BackingStore.Run]    RETURNS [file: File.File, page: File.PageNumber, fileType: File.Type] =    BEGIN    data: DiskBackingStore.Data;    pvID: PhysicalVolume.ID;    pvChannelHandle: DiskBackingStore.ChannelHandle;    found: BOOLEAN ¬ FALSE;    InterpretBackingStoreRunPVProc: VolTable.PVAccessProc --[tok, rootPageLoc]-- =      BEGIN      svDesc: VolTable.SVDesc;      IF (pvChannelHandle ¬ VolTable.GetBSChannel[tok]) = data.channelHandle THEN       {VolTable.GetNextSV[[byPV[pvToEnum: pvID, sv: [first[]]]], @svDesc];	UNTIL svDesc.pvPageOfSV = VolTable.nullPVPage DO          IF data.volumePage IN           [svDesc.pvPageOfSV..svDesc.pvPageOfSV + svDesc.svLength) THEN          BEGIN file.volumeID ¬ svDesc.lvID; found ¬ TRUE; RETURN; END;          VolTable.GetNextSV[            [byPV[pvToEnum: pvID, sv: [next[svDesc.pvPageOfSV]]]], @svDesc];	  REPEAT FINISHED => ERROR SpecialFile.InvalidParameters; --SV not found          ENDLOOP;};      END;  --InterpretBackingStoreRunPVProc--    data ¬ DiskBackingStore.DiskDataFromBSData[run.data];    -- There is an invariant here.  Whenever anything is in a run, it's lock must    -- point to a file lock structure so that the fileID can be determined!    --find the physical volume:    UNTIL found       DO       BEGIN      ENABLE {	-- catch problems in offlining a physical volume while you have the handle        PhysicalVolume.Error => SELECT error FROM	                          physicalVolumeUnknown => LOOP;				  ENDCASE               => REJECT;};      FOR pvID ¬ VolTable.GetNextPV[PhysicalVolume.nullID],          VolTable.GetNextPV[pvID]        UNTIL pvID = PhysicalVolume.nullID DO        VolTable.PVAccess[pvID, InterpretBackingStoreRunPVProc, read, online];        IF found THEN EXIT;        REPEAT FINISHED => ERROR SpecialFile.InvalidParameters;  -- PV not found        ENDLOOP;      END;      ENDLOOP;    WITH d: data SELECT FileLock.lockingEnabled FROM      TRUE => file.fileID ¬ FileLock.GetFileIDFromLock[d.lock].fileID;      FALSE => file.fileID ¬ d.file;      ENDCASE;    RETURN[      file: file,      page: DiskBackingStore.PackFilePageNumber[        low: data.filePageLow, high: data.filePageHigh],      fileType: data.type];    END;  --InterpretBackingStoreRun--  GetType: PUBLIC --FileExtras-- PROCEDURE [file: File.File]    RETURNS [type: File.Type] =    BEGIN    GetTypeInternal: VolTable.LVAccessProc = {      type ¬ ETable.GetFileAttributes[tok, file.fileID !        ETable.Error => IF error = fileNotFound THEN ERROR Unknown[file]].type;      };    VolTable.LVAccess[lvID: file.volumeID, proc: GetTypeInternal, lock: read];    END;  --GetType--  MakeBootable: PUBLIC --KernelFile-- PROCEDURE [    file: File.File, firstPage: File.PageNumber, count: File.PageCount,    type: Boot.BootFileType]    RETURNS [link: PilotDiskFace.DiskAddress] =    BEGIN    MakeBootableLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =      BEGIN      bootable: BOOLEAN;      buffer: Space.Interval;      bufferPages: CARDINAL;      countLeft: File.PageCount;      currentRun: CARDINAL;      desc: Boot.BootFileDescriptorPageHandle;      drive: DiskChannel.Drive;      filePage: File.PageNumber;      fileType: File.Type;      found: BOOLEAN;      group: KernelFile.PageGroup;      groupCount: CARDINAL;      howManyGroups: CARDINAL;      initialFileSize: File.PageCount;      success: BOOLEAN;      thisDescPages: CARDINAL ¬ 0;      totalDescPages: CARDINAL ¬ 0;      Cleanup: PROC =        {VM.Unmap[Environment.PageFromLongPointer[buffer.pointer]];        Space.Deallocate[buffer]};      [fileSize: initialFileSize, bootable: bootable, type: fileType,        howManyGroups: howManyGroups] ¬          ETable.GetFileAttributes[token: tok, fileID: file.fileID            ! ETable.Error => IF error = fileNotFound THEN ERROR Unknown[file]];      IF firstPage + count > initialFileSize THEN ERROR InvalidParameters;      bufferPages ¬ 1 + ((howManyGroups + Boot.maxPageRunsPerPage - 1)/        Boot.maxPageRunsPerPage);      buffer ¬ Space.Allocate[count: bufferPages];      -- The data space here allocated consists of the number of pages necessary      -- for the descriptor plus one extra buffer page for the head-level      -- makeBootable operation.  This area is expected to be arranged with      -- the buffer page first, followed by the descriptor, and it must be      -- resident and contiguous in memory.  Note that the space allocated      -- may be larger than actually used if the bootable section is only      -- part of the file.      VM.Map[interval: [Environment.PageFromLongPointer[buffer.pointer],        bufferPages], transferProc: NIL, backingStoreRuns: NIL,        usage: KernelSpaceUsage.miscFileImplData, class: file, access: readWrite,        swapUnits: [unitary[]], life: alive, swappability: resident];      BEGIN ENABLE UNWIND =>        {IF thisDescPages > 0 THEN -- already grew file; put it back	  SimpleFile.SetSizeInternal[	    fileD: [fileID: file.fileID, volumeID: file.volumeID, type: fileType,	      temporary: TRASH, size: initialFileSize + thisDescPages],	    vol: lvHandle, size: initialFileSize, tok: tok,	    data: VM.nullInterval];        IF bootable THEN          ETable.SetBootable[token: tok, fileID: file.fileID, bootable: TRUE];        Cleanup[]};      desc ¬ buffer.pointer + Environment.wordsPerPage;      IF bootable THEN        BEGIN	-- Is the file section requested already bootable?	link ¬ GetBootLocationInternal[	  file: file, filePage: firstPage, fileSize: initialFileSize,	  buffer: buffer, tok: tok	  ! BootableFileError => IF type = notBootable THEN	    -- Nope.  Make a new bootable part.	    GOTO isNewBootableSection].diskAddress;	-- Yep, already bootable.  We're done.	RETURN;	EXITS isNewBootableSection =>	  -- Make it ETable-wise unbootable temporarily so we can use SetSize,          -- find descriptors already there for total, and continue.	  BEGIN	  ETable.SetBootable[token: tok, fileID: file.fileID, bootable: FALSE];          GetDescriptor[	    file: file, filePage: initialFileSize - 1, desc: desc, tok: tok];	  totalDescPages ¬ desc.header.totalDescriptorPages;	  END;	END;  -- bootable      countLeft ¬ count;      currentRun ¬ 0;      FOR filePage ¬ firstPage, group.nextFilePage UNTIL countLeft = 0 DO        [found: found, group: group] ¬ ETable.GetPageGroup[          token: tok, fileID: file.fileID, filePage: filePage];        IF ~found THEN Bug[fileSystemInconsistency];        groupCount ¬ CARDINAL[MIN[group.nextFilePage - filePage, countLeft]];        desc.pageRuns[currentRun] ¬ [          da: GetDiskAddress[	    volume: file.volumeID,	    volumePage: group.volumePage + (filePage - group.filePage)].address,	  count: groupCount];        countLeft ¬ countLeft - groupCount;        IF (currentRun ¬ currentRun + 1) = Boot.maxPageRunsPerPage THEN          IF countLeft > 0 THEN -- only update if not at the end	    BEGIN	    desc.header.pageRunsCount ¬ currentRun;	    currentRun ¬ 0;	    desc ¬ desc + Environment.wordsPerPage;	    END;        ENDLOOP;      FOR i: CARDINAL IN [currentRun..Boot.maxPageRunsPerPage) DO        desc.pageRuns[i] ¬ [[0,0,0], 0] ENDLOOP;      -- now know exactly how many desc pages; can SetSize      thisDescPages ¬ CARDINAL[desc - buffer.pointer]/Environment.wordsPerPage;        -- actually, ((desc + Environment.wordsPerPage) -        --  (buffer.pointer + Environment.wordsPerPage))/Environment.wordsPerPage      SimpleFile.SetSizeInternal[        fileD: [fileID: file.fileID, volumeID: file.volumeID, type: fileType,	  temporary: TRASH, size: initialFileSize ],        vol: lvHandle, tok: tok, size: initialFileSize + thisDescPages,        data: VM.nullInterval];      -- Link descriptor pages      -- The descriptor is built with consecutive descriptor pages in pages      -- with increasing memory addresses, but it will be written to the disk      -- in decreasing (but not necessarily contiguous) disk addresses.  In this      -- manner the first descriptor page becomes the last page of the file.      -- So, beginning with the last descriptor page built, and moving backwards,      -- assign links (disk addresses) corresponding to the first new file page      -- through last new file page.      link ¬ Boot.eofDescriptorLink;      FOR filePage IN [initialFileSize..initialFileSize + thisDescPages) DO        desc.header ¬ [          seal: Boot.BootFileDescriptorPageSeal,          version: Boot.BootFileDescriptorPageVersion,          bootFileType: type,          pageRunsCount: currentRun,          nextPage: link,          thisDescriptorPages: thisDescPages,          totalDescriptorPages: totalDescPages + thisDescPages];        currentRun ¬ Boot.maxPageRunsPerPage;        IF filePage NOT IN [group.filePage..group.nextFilePage)          THEN group ¬ ETable.GetPageGroup[            token: tok, fileID: file.fileID, filePage: filePage].group;        [drive: drive, address: link] ¬ GetDiskAddress[volume: file.volumeID,          volumePage: group.volumePage + (filePage - group.filePage)];        desc ¬ desc - Environment.wordsPerPage;        ENDLOOP;      -- Get the head level to make its version of a bootfile      [success: success, diskHeader: link] ¬ DoBootfileOp[        drive: drive, command: makeBootable, da: link, dataPtr: buffer.pointer,        count: thisDescPages + 1];      IF ~success THEN ERROR BootableFileError[fileAccessProblem];      ETable.SetBootable[token: tok, fileID: file.fileID, bootable: TRUE];      END;  -- scope of ENABLE      Cleanup[];      END;  --MakeBootableLVProc--    VolTable.LVAccess[      lvID: file.volumeID, proc: MakeBootableLVProc, lock: write,      entryState: open];  --write lock serializes access to file    END;  --MakeBootable--  MakePermanent: PUBLIC --File-- PROCEDURE [file: File.File] =    BEGIN    MakePermanentLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =      BEGIN      fileD: KernelFile.Descriptor;      GetFileDescriptorSignals[        file: file, lvHandle: lvHandle, tok: tok, fileDescPtr: @fileD];      MakePermanentOrTemporary[        file: file, fileD: fileD, action: makePermanent, lvHandle: lvHandle,        tok: tok];      END;  --MakePermanentLVProc--    VolTable.LVAccess[      lvID: file.volumeID, proc: MakePermanentLVProc, lock: write,      entryState: open];  --write lock serializes access to file    END;  --MakePermanent--  MakePermanentOrTemporary: PUBLIC --FileInternal-- PROCEDURE [    file: File.File, fileD: KernelFile.Descriptor,    action: FileInternal.MakePermanentOrTemporaryAction,    lvHandle: LogicalVolumeFormat.Handle, tok: VolTable.LVToken] =    BEGIN    SELECT action FROM      makePermanent => ETable.SetTemporary[tok, file.fileID, FALSE !                          ETable.Error => IF error = fileNotFound THEN			                    ERROR Unknown[file]];      makeTemporary => ETable.SetTemporary[tok, file.fileID, TRUE !                          ETable.Error => IF error = fileNotFound THEN			                    ERROR Unknown[file]];      ENDCASE       => Bug[noSuchCase];    END;  --MakePermanentOrTemporary--  MakeTemporary: PUBLIC --SpecialFile-- PROCEDURE [file: File.File] =    BEGIN    MakeTemporaryLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =      BEGIN      fileD: KernelFile.Descriptor;      GetFileDescriptorSignals[file, lvHandle, tok, @fileD];      MakePermanentOrTemporary[        file: file, fileD: fileD, action: makeTemporary, lvHandle: lvHandle,        tok: tok];      END;  --MakeTemporaryLVProc--    VolTable.LVAccess[      lvID: file.volumeID, proc: MakeTemporaryLVProc, lock: write,      entryState: open];  --write lock serializes access to file    END;  --MakeTemporary --   MakeUnbootable: PUBLIC --KernelFile-- PROCEDURE [    file: File.File, firstPage: File.PageNumber, count: File.PageCount] =    BEGIN    MakeUnbootableLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =      BEGIN      bootable: BOOLEAN;      fileSize: File.PageCount;      fileType: File.Type;      [fileSize: fileSize, bootable: bootable, type: fileType] ¬        ETable.GetFileAttributes[token: tok, fileID: file.fileID          ! ETable.Error => IF error = fileNotFound THEN ERROR Unknown[file]];      IF ~bootable THEN RETURN;      IF firstPage + count > fileSize THEN ERROR SpecialFile.InvalidParameters;      -- We really ignore the count and make all bootable sections unbootable.      -- To make a single section of a multi-bootfile file unbootable, it will      -- be necessary to resolve what to do about nulled out descriptors.      [] ¬ MakeUnbootableInternal[tok, file, fileSize, fileType, lvHandle];      END;    VolTable.LVAccess[      lvID: file.volumeID, proc: MakeUnbootableLVProc, lock: write,      entryState: open];  --write lock serializes access to file    END;  --MakeUnbootable--  MakeUnbootableInternal: --FileInternal--PUBLIC PROCEDURE [    tok: VolTable.LVToken, file: File.File, fileSize: File.PageCount,    type: File.Type, lvHandle: LogicalVolumeFormat.Handle]    RETURNS [newSize: File.PageCount] =    BEGIN    buf: LONG POINTER;    bufPages: CARDINAL ¬ 2;    da: PilotDiskFace.DiskAddress;    desc: Boot.BootFileDescriptorPageHandle;    drive: DiskChannel.Drive;    filePage: File.PageNumber;    Cleanup: PROC =      {VM.Unmap[Environment.PageFromLongPointer[buf]];      Space.Deallocate[[buf, bufPages]]};    buf ¬ Space.Allocate[count: bufPages].pointer;    -- The data space here allocated consists of one page for the head-level    -- buffer, and one for the first descriptor page, in that order.    VM.Map[interval: [Environment.PageFromLongPointer[buf], bufPages],      transferProc: NIL, backingStoreRuns: NIL,      usage: KernelSpaceUsage.miscFileImplData, class: file, access: readWrite,      swapUnits: [unitary[]], life: alive, swappability: resident];    BEGIN ENABLE UNWIND => Cleanup[];    desc ¬ buf + Environment.wordsPerPage;    filePage ¬ fileSize - 1;    DO  -- Process all descriptors present      -- Read the first descriptor page to get its size.      GetDescriptor[file: file, filePage: filePage, desc: desc, tok: tok];      IF desc.header.thisDescriptorPages > (bufPages - 1) THEN        BEGIN	-- Current buffer size wasn't enough.	-- Gotta have the whole thing contiguous and mapped (but head reads it).	oldSize: CARDINAL ¬ bufPages;	bufPages ¬ desc.header.thisDescriptorPages + 1;        VM.Unmap[Environment.PageFromLongPointer[buf]];        Space.Deallocate[[buf, oldSize]];	buf ¬ Space.Allocate[count: bufPages].pointer;        VM.Map[interval: [Environment.PageFromLongPointer[buf], bufPages],          transferProc: NIL, backingStoreRuns: NIL,          usage: KernelSpaceUsage.miscFileImplData, class: file,	  access: readWrite, swapUnits: [unitary[]], life: alive,	  swappability: resident];	END;      -- Do head-level makeUnbootable      [drive: drive, address: da] ¬ GetDiskAddress[volume: file.volumeID,        volumePage: GetVolumePage[file.fileID, filePage, tok]];      IF ~DoBootfileOp[        drive: drive, command: makeUnbootable, da: da, dataPtr: buf,        count: desc.header.thisDescriptorPages + 1].success	  THEN ERROR BootableFileError[fileAccessProblem];      filePage ¬ filePage - desc.header.thisDescriptorPages;      IF desc.header.totalDescriptorPages = desc.header.thisDescriptorPages        THEN EXIT;  -- no more descriptors      ENDLOOP;    END;  -- scope of ENABLE    Cleanup[];    ETable.SetBootable[token: tok, fileID: file.fileID, bootable: FALSE];    newSize ¬ filePage + 1;    SimpleFile.SetSizeInternal[      fileD: [fileID: file.fileID, volumeID: file.volumeID, temporary: TRASH,        size: fileSize, type: type],      vol: lvHandle, size: newSize, tok: tok, data: VM.nullInterval];    END;  --MakeUnbootableInternal--  PutRootFile: PUBLIC --KernelFile-- PROCEDURE [    file: File.File, type: File.Type] =    BEGIN    PutRootFileLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =      {PutRootFileInternal[lvHandle, type, file.fileID]};    IF type NOT IN PilotFileTypes.PilotRootFileType THEN      Bug[notValidPilotRootFileType];    VolTable.LVAccess[      lvID: file.volumeID, proc: PutRootFileLVProc, lock: writeWithChangingFlag,      entryState: open];    END;  --PutRootFile--  PutRootFileInternal: PROCEDURE [    lvHandle: LogicalVolumeFormat.Handle, type: File.Type, file: File.ID] =    INLINE {lvHandle.rootFileID[type] ¬ file};  SetDebuggerFiles: PUBLIC --SpecialFile-- PROCEDURE [    debugger: File.File, debuggee: File.File, debuggerFirstPage: File.PageNumber,    debuggeeFirstPage: File.PageNumber] =    BEGIN    bootFiles: Boot.LVBootFiles;    debuggerDeviceType: Device.Type;    debuggeeDeviceType: Device.Type;    debuggerDeviceOrdinal: CARDINAL;    debuggeeDeviceOrdinal: CARDINAL;    debuggerLink: PilotDiskFace.DiskAddress;    debuggeeLink: PilotDiskFace.DiskAddress;    IF debugger.volumeID # debuggee.volumeID THEN      ERROR SpecialFile.InvalidParameters;    [deviceType: debuggerDeviceType, deviceOrdinal: debuggerDeviceOrdinal,      diskAddress: debuggerLink] ¬ GetBootLocation[debugger, debuggerFirstPage];      -- Signals if file unknown    [deviceType: debuggeeDeviceType, deviceOrdinal: debuggeeDeviceOrdinal,      diskAddress: debuggeeLink] ¬ GetBootLocation[debuggee, debuggeeFirstPage];    IF debuggerDeviceType # debuggeeDeviceType      OR debuggerDeviceOrdinal # debuggeeDeviceOrdinal THEN      ERROR SpecialFile.InvalidParameters;    SpecialVolume.GetLogicalVolumeBootFiles[      lvID: debugger.volumeID, pBootFiles: @bootFiles];  --performs an LVAccess    bootFiles[debugger] ¬ [      [volumeRelative[fileID: debugger.fileID]], debuggerFirstPage, debuggerLink];    bootFiles[debuggee] ¬ [      [volumeRelative[fileID: debuggee.fileID]], debuggeeFirstPage, debuggeeLink];    SpecialVolume.SetLogicalVolumeBootFiles[      lvID: debugger.volumeID, pBootFiles: @bootFiles];  --performs an LVAccess    END;  --SetDebuggerFiles--  SetSize: PUBLIC --File-- PROCEDURE [file: File.File, size: File.PageCount] =    BEGIN    IF size = 0 OR size > File.maxPagesPerFile THEN      ERROR Error[invalidParameters];    nSetSizes ¬ nSetSizes + 1;    SimpleFile.SetSize[file, size, VM.nullInterval];    END;  SetSizeWithContents: PUBLIC --SpecialFile-- PROCEDURE [    file: File.File, size: File.PageCount, contents: Space.Interval] =    BEGIN    IF size = 0 OR size > File.maxPagesPerFile      OR size - SimpleFile.GetSize[file] > contents.count THEN      ERROR SpecialFile.InvalidParameters;    nSetSizes ¬ nSetSizes + 1;    SimpleFile.SetSize[      file, size, [Space.PageFromLongPointer[contents.pointer], contents.count]];    END;  --SetSizeWithContents--      END.  --FileImpl    LOGFor earlier log entries, see Pilot 8.0 archive version28-Oct-82 17:24:58   LXD      	Klamath rewrite23-Dec-82 13:40:37   AWL      	Get base type for File.ID from FileInternal31-Jan-83 18:35:18   LXD      	Minor corrections.  Converted to new VolTable.11-Feb-83 12:19:32   LXD      	Upgraded documentation. 15-Feb-83 15:36:25   LXD         Temporary file list is now created using PilotFileTypes.tTempFileList as its ID.17-Feb-83 14:17:26   LXD         Deadlock in TempsEnter fixed.   DeleteTemps (without list) didn't enumerate  correctly.25-Feb-83 10:57:41   LXD      	Added KernelSpaceUsage.miscFileImplData. 1-Mar-83 11:06:52   LXD      	MakePermanent now does a TempsListRemove. 4-Mar-83 10:59:28   LXD         TempsListEnter failed to set fileD when doing a SetSize.   4-Mar-83 16:46:36   JXP   .   Modify GetBackingStoreRun to match interface. Don't check the file size there   lower levels will do it. 15-Mar-83 14:23:18   LXD         Added GetNextFile. MRU index in TempsFindAndExchangeInBuffer was suboptimal.30-Mar-83 16:41:52   WDK     	Made compatible with new SpecialFile/KernelFile. 15-Apr-83 16:45:01   JXP   	GetBootLocation never set diskAddress.26-Apr-83 14:23:27   JXG    	add FileMgrPerf interface26-Aug-83 17:13:18   JXP   	Implement FileExtras.GetType 4-Sep-83 13:48:50   JXP   	Twiddles28-Sep-83 10:19:56   JXP   	Create must back out correctly17-Oct-83 13:36:22   JXP   	Fix a bug in GetType.14-Nov-83 17:43:30   WDK        GetType did not notice file not found. MakePermanentOrTemporary could raise   MissingPages instead of Unknown. CreateWithContents failed to update   lastIDAllocated.23-Nov-83 20:34:39   WDK        TempsListRemoveAll forgot to null volumeTempsBufferMappedTo.15-Dec-83 11:01:39   WDK     	Disallow files of type tUnassigned.30-Dec-83 10:58:22   AWL      	TempsFileRemove: did not Unmap tempsBuffer10-Jan-84 11:57:40   AWL      	TempsFileRemove must be inside of the monitor.13-Jan-84 15:37:37   AWL        CreateInternal did not work correctly if interval.count IN [1..initialSize)23-Jan-85 21:52:28   CJS      Twiddled calls to VolTable.(FindSV & GetNextSV) per AR 6275.  20-Oct-85 15:18:58   RSV  Added catch phrase and loop in InterpretBackingStoreRun for problem with already starting to enumerate physcial volumes and then offlining the one you currently have a handle to (AR 8135).23-Apr-86 12:22:06   RSV  Added slop parameter to call to AllocPageGroup in CreateInternal. 2-Jun-86 16:29:35   RSV  Got rid of slop parameter in call to AllocPageGroup.11-Jun-86 11:30:41   RSV  Added CHANGE comments.  Not a MONITOR any more.  Changed CreateInternal, Delete, DeleteInternal, GetBootLocation, GetType, MakePermanent, MakePermanentOrTemporary, MakeTemporary to not use labels and the VFM.  Created MakeBootableOrUnbootableInternal procedure from MakeBootableOrUnbootableLVProc.  Created MorePageGroups,  FinishWithPageGroups, and MakeFileList procedures.  Deleted most of section on TemporaryFileList and also deleted GetNextFile procedure.16-Jun-86 18:41:16   RSV  Changed GetMorePageGroups to set length of sequence properly.19-Jun-86 10:14:46   RSV  Re-add getting a file ID when creating a file.  Changed DeleteInternal to free node upon exit and got rid of references to ETable.PageGroupSeq. 9-Jul-86 13:41:04   RSV  Deleted DeleteTemporaryFilesOnVolume and FlushTempsData, made CHANGE comment changes concerning labeless and writeWithChangingFlag. 4-Aug-86 11:31:36   CAJ  Major overhaul of MakeBootable, MakeUnbootable, and GetBootLocation for replacement of label boot chain links with bootfile descriptors. 6-Aug-86 11:10:01   RSV  Temporarily re-added writeWithChangingFlag to Create, CreateWithContents, and Delete. 6-Aug-86 16:56:27   CAJ  Temporarily added TemporaryBootingExtras.MultiGroupUCodeOrGerm to cover until initial microcode can handle runs.12-Aug-86 17:12:03   RSV  Moved temporary hack on MultiGroupUCodeOrGerm one line up to before we set the file bootable.29-Aug-86 12:18:51   CAJ  Commented out TemporaryBootingExtras.MultiGroupUCodeOrGerm. 4-Sep-86 12:13:17   RSV  Uncommented out TemporaryBootingExtras.MultiGroupUCodeOrGerm.12-Sep-86 12:39:07   CAJ  Added new option, mode=channelException, to DoDirectIO for bootfile ops.15-Sep-86 16:46:44   RSV  Commented out TemporaryBootingExtras.MultiGroupUCodeOrGerm again. 6-Oct-86 16:39:42   CAJ/RSV  Clear unused boot descriptor page runs.  MultiGroupUCodeOrGerm changed from ERROR to SIGNAL, moved past the SetBootable (so file will be bootable when signal is raised and CONTINUE'd) and out of scope of the ENABLE (so UNWIND processing won't strip off descriptor).  Still commented out though.  Fixed CreateInternal to do page groups larger than LAST[CARDINAL] correctly. 9-Oct-86 10:14:08   RSV  Added additional check for status # okay returned from ResidentHeap.MakeNode.14-Oct-86 15:06:23   RSV  Reraise Volume.InsufficientSpace in Undo of CreateInternal.  Moved test to grow pageGroup sequence into remaining loop in CreateInternal and stopped incrementing group.nextFilePage in same loop.  Change ResidentHeap.FreeNode calls to store status for later debugging.17-Nov-86 13:08:37   RSV  Changed GetBackingStoreRunWithCache and InterpretBackingStoreRun for file locking. 4-Dec-86 17:22:33   RSV  Added clientError if file being deleted is still mapped.10-Dec-86 11:42:14   CAJ  Fixed off by one error in zeroing unused boot descriptor entries. 9-Jan-87 12:50:01   RRR/RSV/CAJ  Changes necessary to move logical volume root page/Delete last of CHANGE comments/Remove use of File.MissingPages by GetBootLocation, Make(Un)Bootable.28-Jan-87 13:58:05   RSV  Changed MakeFileList to call OldMakeFileList (to get it ready to be deleted). 6-Feb-87 16:04:46   RSV  Deleted MakeFileList.10-Feb-87 18:15:52   RSV  Uncomment out stuff on TemporaryBootingExtras.MultiGroupUCodeOrGerm.12-Mar-87 15:23:39   RSV  Raise Space.Error[stillMapped] instead of Bug[clientError] when deleting file which is still mapped.27-Jun-87 10:23:30   CAJ  Made MakeUnbootableInternal public.  Rationalized errors and reaaranged bootables.  Made MultiGroupUCodeOrGerm apply to hardMicrocode as well.21-Jul-87  8:28:48   CAJ  MakeUnbootableInternal fixes.20-Oct-87 11:45:56   RSV  SetSizeWithContents should update nSetSizes (AR 12095).22-Oct-87 15:12:22   CAJ  Initial now handles page groups: remove signal raised in MakeBootable if ucode or germ has >1 page group.  Signal itself stays until we can recompile the interface.28-Jun-88 11:10:52   RSV  Allocate page groups from local frame or from Space ourselves....don't use the ResidentHeap for this anymore.  Use Inline.LongCOPY instead of FOR loops.  Delete now uses write instead of writeWithChangingFlag.30-Jul-88 17:36:32   RSV  Fix for disabling mapped file locking.10-May-89 23:28:11   TxH  Use FileLock.IsOkToDeleteFile instead of FileLock.IsLocked in DeleteInternal.
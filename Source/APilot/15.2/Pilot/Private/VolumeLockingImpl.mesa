-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. -- FileMgr>VolumeLockingImpl	 2-Feb-87 10:55:07DIRECTORY   LogicalVolumeFormat USING [Handle, LockState],   RuntimeInternal USING [Bug],   VolTable USING [LVAccess, LVAccessProc],   Volume USING [ID, nullID, systemID],   VolumeExtras, VolumeInternal;   VolumeLockingImpl: PROGRAM  IMPORTS RuntimeInternal, VolumeExtras, VolTable, Volume  EXPORTS VolumeExtras, VolumeInternal =   BEGIN OPEN LVF: LogicalVolumeFormat;  AlreadyReadOpen: PUBLIC --VolumeExtras-- SIGNAL [volume, by: Volume.ID]    RETURNS [forceIt: BOOLEAN ¬ FALSE] = CODE;  AlreadyWriteOpen: PUBLIC --VolumeExtras-- SIGNAL [volume, by: Volume.ID]    RETURNS [forceIt: BOOLEAN ¬ FALSE] = CODE;  BugType: TYPE = {fileSystemError, impossibleEndcase, lockChanged};  Bug: PROCEDURE [b: BugType] = {RuntimeInternal.Bug[b]};          LockVolume: PUBLIC --VolumeInternal-- PROCEDURE [desiredVolume: LVF.Handle, readOnly: BOOLEAN] =    BEGIN    accessDesired, lockState: LVF.LockState;    owner: Volume.ID;    count: INTEGER;    force: BOOLEAN ¬ FALSE;        IF readOnly THEN accessDesired ¬ read ELSE accessDesired ¬ write;    [owner, lockState, count] ¬ VolumeLockQuery[desiredVolume];    SELECT accessDesired FROM      write => {        -- if someone else holds a lock the default is still to let client have it.	SELECT lockState FROM	  unlocked => {force ¬ TRUE};	  read => IF owner # Volume.systemID OR count > 1 THEN	    force ¬ SIGNAL VolumeExtras.AlreadyReadOpen[desiredVolume.vID, owner]	    ELSE force ¬ TRUE;	  write => IF owner # Volume.systemID THEN	    force ¬ SIGNAL VolumeExtras.AlreadyWriteOpen[desiredVolume.vID, owner]	    ELSE force ¬ FALSE;  -- cause I already hold it.	 ENDCASE;	 -- possibly aquire lock if RESUMEd.	 IF force THEN WriteLockVolume[desiredVolume]	 };      read =>	SELECT lockState FROM	  unlocked => ReadLockVolume[desiredVolume, TRUE];	  read => {	    IF owner # Volume.systemID AND owner # Volume.nullID THEN	      ReadLockVolume[desiredVolume, FALSE];	      -- somebody other than me has read access, leave their ID in lock	      -- on assumption that I will give up lock before they do.	    IF owner = Volume.nullID THEN	      ReadLockVolume[desiredVolume, TRUE];	      -- unknown other has lock, might as well put my ID there.	    -- IF owner = Volume.systemID THEN don't lock again.	    };	  write => {	    -- read lock is not by default granted to caller because allowing	    -- read while another holds write lock is likely(?) to be painless,	    -- and if we granted lock we would lose write lock.	    IF owner # Volume.systemID THEN force ¬	      SIGNAL VolumeExtras.AlreadyWriteOpen[desiredVolume.vID, owner]	    -- Note: if caller RESUMEs when lock still belongs to previous writer,	    -- caller must chose to force lock.	    -- The assumption is: as long as caller cleans up before PROCEEDing	    -- the write lock holder, no inconsistencies will arise.	    	    ELSE ReadLockVolume[desiredVolume, TRUE];	    -- If I was the last to open for write, I can switch to read lock.	    IF force THEN ReadLockVolume[desiredVolume, TRUE];	    }	ENDCASE; -- of checking lock when want read.    ENDCASE; -- of accessDesired.  END;  VolumeLockQuery: PROC [v: LVF.Handle]    RETURNS [owner: Volume.ID, ls: LVF.LockState, count: INTEGER] = {    owner ¬ v.lock.owner;    WITH l: v.lock SELECT FROM      unlocked => {ls ¬ unlocked; count ¬ 0};      write => {ls ¬ write; count ¬ 0};      read => {ls ¬ read; count ¬ l.count};      ENDCASE => Bug[impossibleEndcase];    };      WriteLockVolume: PROC [v: LVF.Handle] = INLINE {    v.lock.owner ¬ Volume.systemID;    v.lock.lock ¬ write[null: 0];    };    ReadLockVolume: PROC [v: LVF.Handle, update: BOOLEAN] = {    count: INTEGER ¬ 0;    IF update THEN v.lock.owner ¬ Volume.systemID;    WITH l: v.lock SELECT FROM      read => count ¬ l.count;      write => NULL;      ENDCASE;    v.lock.lock ¬ read[count: count+1];    };      UnlockVolume: PUBLIC  --VolumeInternal-- PROC [v: LVF.Handle] = {    -- only set lock to unlocked if I am sole owner.    count: INTEGER ¬ 0;        WITH l: v.lock SELECT FROM      read => {count ¬ l.count - 1;        IF count = 0 THEN v.lock.lock ¬ unlocked[null: 0]	ELSE v.lock.lock ¬ read[count: count]};      write => {        IF v.lock.owner = Volume.systemID THEN v.lock.lock ¬ unlocked[null: 0]};      ENDCASE;    IF v.lock.owner = Volume.systemID THEN v.lock.owner ¬ Volume.nullID;    };            ForcefullyLockInternal: PUBLIC --VolumeInternal-- PROC [v: LVF.Handle, readOnly: BOOLEAN] = {    v.lock.owner ¬ Volume.systemID;    IF readOnly THEN v.lock.lock ¬ write[0]    ELSE v.lock.lock ¬ read[count: 1];    };      ForcefullyUnlockInternal: PUBLIC --VolumeInternal-- PROC [v: LVF.Handle] = {    v.lock.owner ¬ Volume.nullID;    v.lock.lock ¬ unlocked[null: 0];    };  ForcefullyUnlock: PUBLIC --VolumeExtras-- PROC [volume: Volume.ID] =    BEGIN        UnlockLVProc: VolTable.LVAccessProc --[tok, lvHandle]--  =    BEGIN    ENABLE ANY => Bug[fileSystemError];    ForcefullyUnlockInternal[lvHandle];    END;  --UnlockLVProc      VolTable.LVAccess[    lvID: volume, proc: UnlockLVProc, lock: maybeWrite, entryState: online];   END;   END..
--Copyright (C) 1987, 1988, 1989, 1992  by Xerox Corporation.  All rights reserved.--VerifierImplB.mesa    4-Mar-92 11:40:01 by RSV DIRECTORY  BackingStore USING [Run],   DiskBackingStore USING [     ChannelHandle, GetDiskChannel],  DiskChannel USING [     defaultTries, DiskPageCount, DoIO, Handle, IORequest, IOStatus],   Environment USING [PageCount, PageNumber, wordsPerPage],  ETable, ETableInternal,     File USING [File, ID, nullFile, nullID, PageCount, PageNumber, Type],   FileInternal USING [CreateInternal, FileID],   FileTypes USING [PilotFileType],   Inline USING [LowHalf],  KernelVolume USING[],   LogicalVolumeFormat USING [     currentVersion, Handle, LSMCurrentVersion, LSMSeal, lvRootSeal,     maxLogicalVolumeLabelLength, nullBoot, nullName,      rootPageSize, SubmarkerHandle],  PhysicalVolume USING [PageNumber],   PhysicalVolumeExtras USING [nullDataLostPage, GetNextDataLostPage],   PhysicalVolumeFormat,  PhysicalVolumeInternal,   PilotFileTypes USING [     PilotFileType, PilotRootFileType, tFreePage, tScavengerLog,     tScavengerLogOtherVolume, tVMBackingFile, tVolumeAllocationMap, tVolumeFileMap],   PilotFileTypesExtraExtras USING [tETable],   RuntimeInternal USING [Bug],   Scavenger,   ScavengerUtilities,   Space USING [     Allocate, Deallocate, Error, InsufficientSpace, Interval, LongPointerFromPage,      Map, nullInterval,     PageCount, PageFromLongPointer, PagesFromWords, Unmap, Window],  SpecialFile USING [CreateWithContents],   System USING [GetGreenwichMeanTime],   VerifierInternal,  VM USING [BackingStoreRuns, ForceOut, Interval, Map, nullInterval, ScratchMap, Unmap],  VolAllocMap USING [Close, PagesForVam, SetPageGroup],  VolTable USING [     AssertRootPageReadability, ChangeSubVolume, FindSV, GetLVStatus, GetNextSV,     GetSVToken, LVAccess, LVAccessProc,  LVToken , MapMarkerPage,      MapDuplicatePVRootPage, UnmapDuplicatePVRootPage, MapPVRootPage,      PVAccess, PVAccessProc, SVDesc,  UnmapMarkerPage,  UnmapPVRootPage],  Volume USING [     ID, InsufficientSpace, NotOnline, NotOpen, nullID, PageCount, PageNumber, ReadOnly, Type, Unknown]; VerifierImplB: MONITORIMPORTS   DiskBackingStore, DiskChannel, ETable, ETableInternal, FileInternal, Inline,   PhysicalVolumeExtras, PhysicalVolumeInternal, RuntimeInternal,    Scavenger, ScavengerUtilities, Space, SpecialFile, System,    VerifierInternal, VM, VolAllocMap, VolTable, VolumeEXPORTS KernelVolume, VerifierInternal, Scavenger =     BEGIN        OPEN LVF: LogicalVolumeFormat, PVF: PhysicalVolumeFormat,      VI: VerifierInternal, ET: ETable, ETI: ETableInternal;    -- TYPE's and constants    BadPageDescriptor: TYPE = LONG DESCRIPTOR FOR ARRAY OF Volume.PageNumber;  goodCompletion: DiskChannel.IOStatus = [disk[goodCompletion]];  Bug: PROCEDURE [bug: BugType] = {RuntimeInternal.Bug[bug]};  BugType: TYPE = {    allocationError, badInfoFromVFM, impossibleEndcase,     impossibleFaceStatus,  impossibleLabelTransferError,    impossibleProblemType, invalidChannel, invalidDriveState,      lvChangedSize, logicError, missingFileFromVfm, neededFileNotInVFM,    needMorePageGroups,     notImplemented, outOfFileIDs, outOfVM, pvNeedsScavenging,     residentHeapFreeNodeFailure, residentHeapMakeNodeFailure,    subvolumeTooSmallForRootPage, unableToFreeResidentHeapNode,    unexpectedVolFileMapError, unexpectedVolTableError, vfmFileEnumeratorLied,    volumeUnverifier};       -- Scavenger public variables    tScavengerLog: PUBLIC File.Type ¬ PilotFileTypes.tScavengerLog;  tScavengerLogOtherVolume: PUBLIC File.Type ¬    PilotFileTypes.tScavengerLogOtherVolume;     -- The following are for the list of bad pages on the logical volume being  -- opened    badPageListSize:  PUBLIC Volume.PageCount;  numberOfBadPages:  PUBLIC CARDINAL;  badPageList:  PUBLIC LONG POINTER TO ARRAY [0..0) OF Volume.PageNumber;    -- The following are for the list of pages on the logical volume being opened  -- which diagnostics (probably) have caused to lose their data    badDataPageListSize: PUBLIC Volume.PageCount;  numberOfBadDataPages: PUBLIC  CARDINAL;  badDataPageList: PUBLIC  LONG POINTER TO ARRAY [0..0) OF VI.BadDataPageEntry;      firstPVPageOfLV: PUBLIC PhysicalVolume.PageNumber;  lastPVPageOfLV: PUBLIC PhysicalVolume.PageNumber;    numberOfFiles: PUBLIC LONG CARDINAL;    pvPageNumberOfLVRootPage, pvPageNumberOfMarkerPage: PhysicalVolume.PageNumber;  lvPageNumberOfLVRootPage, lvPageNumberOfMarkerPage: Volume.PageNumber ¬ 0;    fileListType: File.Type = [PilotFileTypes.PilotFileType.LAST];    fudgeFactor: Volume.PageCount = 50;    -- a fudge factor used to not shrink volumes too much  ------------------------------------------------------------------------------  -- VerifyAndCorrectLVRootAndMarkerPages  ------------------------------------------------------------------------------    VerifyAndCorrectLVRootAndMarkerPages: PUBLIC PROCEDURE [tok: VolTable.LVToken,    lvBucketInfo: LONG POINTER TO ETable.LVBucketInfo, volume: Volume.ID] =        BEGIN    count: Volume.PageCount;    diskStatus: DiskChannel.IOStatus;    workingSpace: Space.Interval;    workingSpacePage: Environment.PageNumber;    lvHandle: LogicalVolumeFormat.Handle;    volumePage: Volume.PageNumber;    volumeSize: Volume.PageCount;    lvMarkerValid: BOOLEAN;    lvRootValid: BOOLEAN;    lvToken: VolTable.LVToken;    lvmp: LogicalVolumeFormat.SubmarkerHandle;    markerSpace: Space.Interval;    rootPageWasInitiallyReadable, markerPageWasInitiallyReadable: BOOLEAN;     subvolume: VI.SVInfo;            workingSpace ¬ Space.Allocate[       MAX[LVF.rootPageSize, PVF.rootPageSize, PVF.markerPageSize]];    workingSpacePage ¬ Space.PageFromLongPointer[workingSpace.pointer];    markerSpace ¬ Space.Allocate[PVF.markerPageSize];        ------------------------------------------------------------------------------    -- STEP 1:  Read into resident memory the lv's subvolume information    ------------------------------------------------------------------------------    lvToken ¬ tok;        lvHandle ¬ lvBucketInfo.lvHandle;    IF VolTable.GetLVStatus[volume].entryState = open THEN        ERROR Scavenger.Error[volumeOpen];                 -- Force VolTable to unmap the root page.  The status could be either     -- allSVsOnline, in which case it is not mapped, or online, in which case     -- it is.  We will exit with the root page being mapped.       VolTable.AssertRootPageReadability[lvToken, rootPageUnreadable];          BEGIN    svDesc: VolTable.SVDesc;    VolTable.GetNextSV[[byLV[volume, [first[]]]], @svDesc];    subvolume ¬ [       TRUE, VolTable.GetSVToken[lvToken, svDesc.lvPageOfSV], svDesc,       markerSpace.pointer];    volumeSize ¬ svDesc.svLength;    END;      ------------------------------------------------------------------------------    -- STEP 2:  Guarantee root page and marker page readability.  If the root page    --          is bad, it will be relocated forward to the first readable page.    --          In this case its contents will be reconstructed from the marker    --          page.  If the marker page is bad, it will be relocated backward    --          to the first readable page.  In this case its contents will be    --          reconstructed from the root page.  If both pages are bad, then    --          there are major problems, and that logical volume is lost.    --          Notice that relocation of either page will have the effect of    --          possibly losing a page of data in a client file.  Such a page    --          must later be replaced with another page.  The data, however,    --          will still be lost.    ------------------------------------------------------------------------------         BEGIN        channel: DiskBackingStore.ChannelHandle;    lvRootPage: LVF.Handle = workingSpace.pointer;    lvMarkerPage: LVF.SubmarkerHandle =      @LOOPHOLE[workingSpace.pointer, PVF.MarkerHandle].logical;    moveRootPage, moveMarkerPage: BOOLEAN;    VM.ScratchMap[[workingSpacePage, LVF.rootPageSize]];    BEGIN    ENABLE      UNWIND =>        VM.Unmap[          workingSpacePage !          Space.Error --[type]-- =>            IF type = notMapped THEN CONTINUE ELSE REJECT];    [channel, , , pvPageNumberOfLVRootPage, lvPageNumberOfLVRootPage] ¬       GetDiskIOInfo[volume, 0, LVF.rootPageSize];    pvPageNumberOfMarkerPage ¬ firstPVPageOfLV + volumeSize;    lvPageNumberOfMarkerPage ¬ volumeSize;        moveRootPage ¬ moveMarkerPage ¬ FALSE;    rootPageWasInitiallyReadable ¬ markerPageWasInitiallyReadable ¬ TRUE;        volumePage ¬ lvPageNumberOfLVRootPage;    count ¬ 1;    IF IsPageBad[@volumePage, @count] THEN        BEGIN       moveRootPage ¬ TRUE;        rootPageWasInitiallyReadable ¬ FALSE;       END    ELSE           BEGIN       diskStatus ¬ ScavengerUtilities.ReadPages[          data: lvRootPage, firstPage: pvPageNumberOfLVRootPage,          count: LVF.rootPageSize, try: normalRetry,          diskChannel: DiskBackingStore.GetDiskChannel[channel]];       IF diskStatus ~= goodCompletion THEN           BEGIN          rootPageWasInitiallyReadable ¬ FALSE;	  	  -- Try to rewrite the page.          lvRootPage­ ¬ [             -- Put reasonable data in in case we crash before we can reconstruct             -- the root page from the marker pages but after we successfully             -- rewrite it.             vID: volume, type: normal, volumeSize: volumeSize, changing: TRUE];          diskStatus ¬ ScavengerUtilities.WritePages[             data: lvRootPage, firstPage: pvPageNumberOfLVRootPage,             count: LVF.rootPageSize, try: normalRetry,             diskChannel: DiskBackingStore.GetDiskChannel[channel]];          IF diskStatus ~= goodCompletion THEN              moveRootPage ¬ TRUE          END;       END;    volumePage ¬ volumeSize;      -- this assumes that volumeSize always starts from 0...note that we      -- can't say lvPageNumberOfLVRootPage+volumeSize 'cause the root page      -- can move, thus changing lvPageNumberOfLVRootPage.    count ¬ 1;    IF IsPageBad[@volumePage, @count] THEN       BEGIN       moveMarkerPage ¬ TRUE;       markerPageWasInitiallyReadable ¬ FALSE;       END    ELSE       BEGIN       diskStatus ¬ ScavengerUtilities.ReadPages[          data: lvMarkerPage, firstPage: pvPageNumberOfMarkerPage,	  count: PVF.markerPageSize, try: normalRetry,          diskChannel: DiskBackingStore.GetDiskChannel[channel]];       IF diskStatus ~= goodCompletion THEN           BEGIN	            markerPageWasInitiallyReadable ¬ FALSE;	  	  -- Try to rewrite the page.	            lvMarkerPage­ ¬ [type: normal];             -- Put reasonable data in in case we crash before we can reconstruct             -- the marker page from the root page but after we successfully             -- rewrite it.          diskStatus ¬ ScavengerUtilities.WritePages[             data: lvMarkerPage, firstPage: pvPageNumberOfMarkerPage,             count: PVF.markerPageSize, try: normalRetry,             diskChannel: DiskBackingStore.GetDiskChannel[channel]];          IF diskStatus ~= goodCompletion THEN              moveMarkerPage ¬ TRUE          END;       END;    VM.Unmap[workingSpacePage];    END;  -- scope of UNWIND        IF moveMarkerPage THEN       BEGIN       countMoved: DiskChannel.DiskPageCount;       okay: BOOLEAN;       pvRootPage: PVF.Handle = workingSpace.pointer;       svDesc: VolTable.SVDesc;              MoveMarkerPagePVProc: VolTable.PVAccessProc =          BEGIN	  sv: VolTable.SVDesc;	  i: CARDINAL;          pvRootPage: PVF.Handle ¬ workingSpace.pointer;          VolTable.MapPVRootPage[tok, pvRootPage];	  [] ¬ VolTable.FindSV[volume, lvPageNumberOfLVRootPage, @sv];          [okay, countMoved] ¬ ScavengerUtilities.MovePages[             firstPage: pvPageNumberOfMarkerPage, count: PVF.markerPageSize,	     direction: backward,             diskChannel: DiskBackingStore.GetDiskChannel[channel],             badPages: DESCRIPTOR[                @pvRootPage.badPageList, Inline.LowHalf[pvRootPage.badPageCount]],             maxMove: sv.svLength - PVF.markerPageSize - fudgeFactor !             UNWIND => VolTable.UnmapPVRootPage[tok, pvRootPage]];	  volumeSize ¬ volumeSize - countMoved;	  	  -- update the globals	  pvPageNumberOfMarkerPage ¬ pvPageNumberOfMarkerPage - countMoved;	  lvPageNumberOfMarkerPage ¬ lvPageNumberOfMarkerPage - countMoved;	  lastPVPageOfLV ¬ lastPVPageOfLV - countMoved;	  	  --	  -- Update the subvolume descriptor in the primary pv root page.	  --  	  FOR i IN [0..pvRootPage.subVolumeCount) DO	     IF pvRootPage.subVolumes[i].lvID = volume THEN	        BEGIN	        pvRootPage.subVolumes[i].lvSize ¬ 		   pvRootPage.subVolumes[i].lvSize - countMoved;		pvRootPage.subVolumes[i].nPages ¬		   pvRootPage.subVolumes[i].nPages - countMoved;		END;	  ENDLOOP;	              VolTable.UnmapPVRootPage[tok, pvRootPage];	  --	  -- Update the subvolume descriptor in the duplicate pv root page.	  -- 	  VolTable.MapDuplicatePVRootPage[tok, LOOPHOLE[pvRootPage]];	  FOR i IN [0..pvRootPage.subVolumeCount) DO	     IF pvRootPage.subVolumes[i].lvID = volume THEN	        BEGIN	        pvRootPage.subVolumes[i].lvSize ¬ 		   pvRootPage.subVolumes[i].lvSize - countMoved;		pvRootPage.subVolumes[i].nPages ¬		   pvRootPage.subVolumes[i].nPages - countMoved;		END;	  ENDLOOP;	  VolTable.UnmapDuplicatePVRootPage[tok, LOOPHOLE[pvRootPage]];          END;  --MoveMarkerPagePVProc--       [] ¬ VolTable.FindSV[volume, lvPageNumberOfLVRootPage, @svDesc];       VolTable.PVAccess[          pvID: svDesc.pvID, proc: MoveMarkerPagePVProc, lock: write];       IF ~okay THEN Scavenger.Error[diskHardwareError];       subvolume.svDesc.svLength ¬ subvolume.svDesc.svLength - countMoved;       VolTable.ChangeSubVolume[	  subvolume.svTok, subvolume.svDesc.lvPageOfSV,	  subvolume.svDesc.pvPageOfSV, subvolume.svDesc.svLength];       END;  --IF moveMarkerPage--           -- now should be able to map marker page    VolTable.MapMarkerPage[subvolume.svTok, subvolume.marker];    lvmp ¬ @subvolume.marker.logical;    IF moveRootPage THEN       BEGIN       countMoved: DiskChannel.DiskPageCount;       okay: BOOLEAN;       pvRootPage: PVF.Handle = workingSpace.pointer;       svDesc: VolTable.SVDesc;              MoveRootPagePVProc: VolTable.PVAccessProc =          BEGIN	  sv: VolTable.SVDesc;	  i: CARDINAL;          pvRootPage: PVF.Handle ¬ workingSpace.pointer;          VolTable.MapPVRootPage[tok, pvRootPage];	  [] ¬ VolTable.FindSV[volume, lvPageNumberOfLVRootPage, @sv];          [okay, countMoved] ¬ ScavengerUtilities.MovePages[             firstPage: pvPageNumberOfLVRootPage, count: LVF.rootPageSize,	     direction: forward,	     diskChannel: DiskBackingStore.GetDiskChannel[channel],             badPages: DESCRIPTOR[                @pvRootPage.badPageList, Inline.LowHalf[pvRootPage.badPageCount]],             maxMove: sv.svLength - LVF.rootPageSize - fudgeFactor !             UNWIND => VolTable.UnmapPVRootPage[tok, pvRootPage]];	     	  -- update the globals	  pvPageNumberOfLVRootPage ¬ pvPageNumberOfLVRootPage + countMoved;	  lvPageNumberOfLVRootPage ¬ lvPageNumberOfLVRootPage + countMoved;	  --	  -- Update the subvolume descriptor in the primary pv root page.	  --  	  FOR i IN [0..pvRootPage.subVolumeCount) DO	     IF pvRootPage.subVolumes[i].lvID = volume THEN	        pvRootPage.subVolumes[i].lvPage ¬ 		   pvRootPage.subVolumes[i].lvPage + countMoved;	  ENDLOOP;	              VolTable.UnmapPVRootPage[tok, pvRootPage];	  --	  -- Update the subvolume descriptor in the duplicate pv root page.	  -- 	  VolTable.MapDuplicatePVRootPage[tok, LOOPHOLE[pvRootPage]];	  FOR i IN [0..pvRootPage.subVolumeCount) DO	     IF pvRootPage.subVolumes[i].lvID = volume THEN	        pvRootPage.subVolumes[i].lvPage ¬ 		   pvRootPage.subVolumes[i].lvPage + countMoved;	  ENDLOOP;	  VolTable.UnmapDuplicatePVRootPage[tok, LOOPHOLE[pvRootPage]];          END;  --MoveRootPagePVProc--	       [] ¬ VolTable.FindSV[volume, lvPageNumberOfLVRootPage, @svDesc];       VolTable.PVAccess[          pvID: svDesc.pvID, proc: MoveRootPagePVProc, lock: write];       IF ~okay THEN Scavenger.Error[diskHardwareError];       subvolume.svDesc.lvPageOfSV ¬ subvolume.svDesc.lvPageOfSV + countMoved;       VolTable.ChangeSubVolume[	  subvolume.svTok, subvolume.svDesc.lvPageOfSV,	  subvolume.svDesc.pvPageOfSV, subvolume.svDesc.svLength];       END;  --IF moveRootPage--    END;  --MakeRootAndMarkerPagesReadable--        ------------------------------------------------------------------------------    -- STEP 3: Make the invariant parts of the root page and the marker page     --         both self-consistent and mutually consistent.    ------------------------------------------------------------------------------    VolTable.AssertRootPageReadability[lvToken, rootPageReadable];    VolAllocMap.Close[volume, unmap, lvToken];    lvHandle.changing ¬ TRUE;  -- Force the volume to be changing    VM.ForceOut[[Space.PageFromLongPointer[lvHandle], 1], wait];<<    This procedure only fixes up the first 125B words of the root page    and the first 115B words of the logical marker submarker.  Note that    these are guaranteed to have the same meanings, and bit patterns, in	    all versions of Pilot for all time. >>              BEGIN    lvRootValid ¬ rootPageWasInitiallyReadable        AND lvHandle.seal = LVF.lvRootSeal       AND lvHandle.vID = volume       AND lvHandle.labelLength IN [0..LVF.maxLogicalVolumeLabelLength]       «AND lvHandle.volumeSize = volumeSize»         -- not done cause marker may have moved, thus changing the size        AND lvHandle.type IN Volume.Type;    lvMarkerValid ¬ markerPageWasInitiallyReadable       AND lvmp.seal = LVF.LSMSeal       AND lvmp.labelLength IN [0..LVF.maxLogicalVolumeLabelLength]        AND lvmp.pad = 0        AND lvmp.type IN Volume.Type;    -- At this point we have the root page and marker page in hand.    -- We also know which might have valid information and which certainly     -- doesn't.        IF ((~lvMarkerValid) AND (~lvRootValid)) THEN  -- Nothing is valid       BEGIN  -- temporarily supply (presumed) safe values       lvHandle.vID ¬ volume;       lvHandle.labelLength ¬ 0;       lvHandle.label ¬ LVF.nullName;       lvHandle.type ¬ normal;       lvHandle.bootingInfo ¬ LVF.nullBoot;       END;    -- Compute correct values for all fields.    -- The correct values are placed in the root page and then copied to the    -- marker pages, if needed.    -- First fields with known values        lvHandle.seal ¬ LVF.lvRootSeal;    lvHandle.version ¬ LVF.currentVersion;    lvHandle.vID ¬ volume;        lvHandle.volumeSize ¬ volumeSize;      -- THIS ASSIGNMENT MUST BE DONE, IF THE MARKER PAGE HAS BEEN MOVED    IF lvMarkerValid THEN       BEGIN                lvHandle.labelLength ¬ lvmp.labelLength;       lvHandle.label ¬ lvmp.label;       lvHandle.type ¬ lvmp.type;       lvHandle.bootingInfo ¬ lvmp.bootingInfo;       END;          --ELSE Believe the values in the root page since no marker pages will do.    -- At this point, the root page contains the correct information.  Copy it    -- back into the marker page.          lvmp.seal ¬ LVF.LSMSeal;       lvmp.pad ¬ 0;      IF lvmp.labelLength ~= lvHandle.labelLength THEN          lvmp.labelLength ¬ lvHandle.labelLength;      IF lvmp.type ~= lvHandle.type THEN lvmp.type ¬ lvHandle.type;      IF lvmp.label ~= lvHandle.label THEN lvmp.label ¬ lvHandle.label;    END;        ------------------------------------------------------------------------------    -- STEP 4:   Make variable parts of root and marker pages consistent with    --            each other    ------------------------------------------------------------------------------              BEGIN     lvRootValid ¬ lvRootValid AND lvHandle.version = LVF.currentVersion;        -- The version number refers to the body of the descriptor; i.e. the    -- variable part. That is why it is checked here even though the version    -- field itself is an invariant field.    subvolume.valid ¬        (subvolume.marker.logical.version = LVF.LSMCurrentVersion);       -- At this point we have the root page and marker page in hand.    -- We also know which might have valid information and which doesn't.    -- We also know that the invariant parts of the root and marker pages are    -- self consistent.    IF ((~lvMarkerValid) AND (~lvRootValid)) THEN       BEGIN       lvHandle.volumeRootDirectory ¬ File.nullID;       lvHandle.lastIDAllocated ¬ LAST[FileTypes.PilotFileType];       lvHandle.scavengerLogVolume ¬ Volume.nullID;       END;    -- Compute correct values for all fields.    -- The correct values are placed in the root page and then copied to the    -- marker pages, if needed.    -- First fields with known values        lvHandle.pad ¬ 0;    lvHandle.freePageCount ¬ 0;    lvHandle.vamStart ¬ lvPageNumberOfLVRootPage + LVF.rootPageSize;    lvHandle.checksum ¬ 0;    lvHandle.lastTimeOpendForWrite ¬ System.GetGreenwichMeanTime[];        FOR t: PilotFileTypes.PilotRootFileType IN PilotFileTypes.PilotRootFileType DO      lvHandle.rootFileID[t] ¬        SELECT t FROM           PilotFileTypes.tFreePage, PilotFileTypes.tScavengerLog,	      PilotFileTypes.tVolumeAllocationMap => FileIDFromNumber[t],	   PilotFileTypes.tVolumeFileMap => 	     FileIDFromNumber[PilotFileTypesExtraExtras.tETable],	   PilotFileTypes.tVMBackingFile => lvHandle.rootFileID[t], 	   ENDCASE => File.nullID;  -- includes TempFileList       ENDLOOP;           lvHandle.fill ¬ ALL[0];    lvHandle.lowerBound ¬ LVF.rootPageSize;    IF lvMarkerValid THEN       BEGIN       lvHandle.volumeRootDirectory ¬ lvmp.volumeRootDirectory;       lvHandle.bootingInfo ¬ lvmp.bootingInfo;       lvHandle.primaryETableStartPage ¬ lvmp.primaryETableStartPage;       lvHandle.statusPrimaryETableFile ¬ lvmp.statusPrimaryETableFile;       lvHandle.copyETableStartPage ¬ lvmp.copyETableStartPage;       lvHandle.statusCopyETableFile ¬ lvmp.statusCopyETableFile;       END;    -- ELSE assume information in the root page        -- At this point, the root page contains the most correct information.    -- Force it out then copy it back into the marker page.           VM.ForceOut[[Space.PageFromLongPointer[lvHandle], 1], wait];    lvmp.version ¬ LVF.LSMCurrentVersion;    lvmp.bootingInfo ¬ lvHandle.bootingInfo;    lvmp.volumeRootDirectory ¬ lvHandle.volumeRootDirectory;    lvmp.primaryETableStartPage ¬ lvHandle.primaryETableStartPage;    lvmp.copyETableStartPage ¬ lvHandle.copyETableStartPage;                         lvmp.statusPrimaryETableFile ¬ lvHandle.statusPrimaryETableFile;    lvmp.statusCopyETableFile ¬ lvHandle.statusCopyETableFile;    lvmp.padding ¬ ALL[0];    END;  --MakeVariablePartsOfRootAndMarkerPagesConsistent--        -- Release the space for the marker page (which forces it out)        Space.Deallocate[workingSpace];    VolTable.UnmapMarkerPage[subvolume.svTok, subvolume.marker];    Space.Deallocate[markerSpace];        END; --VerifyAndCorrectLVRootAndMarkerPages--        -------------------------------------------------------------------------------  -- ClearDataLostPageList  -------------------------------------------------------------------------------    ClearDataLostPageList: PUBLIC PROCEDURE [volume: Volume.ID] =           -- Remove from dataLostPageList all pages from the specified logical volume.     -- Correspondingly decrement counts in pv root pages.          BEGIN     svDesc: VolTable.SVDesc;     dataLostPage: PhysicalVolume.PageNumber;          VolTable.GetNextSV[[byLV[volume, [first[]]]], @svDesc];     FOR i: CARDINAL IN [0..numberOfBadDataPages) DO         IF NOT badDataPageList[i].processed THEN LOOP;        dataLostPage ¬ badDataPageList[i].page + svDesc.pvPageOfSV;	PhysicalVolumeInternal.ClearDataLostPage[svDesc.pvID, dataLostPage];        ENDLOOP;       END; --ClearDataLostPageList--    -------------------------------------------------------------------------------  -- CreateBadDataPageList  -------------------------------------------------------------------------------    CreateBadDataPageList: PUBLIC PROCEDURE [     tok: VolTable.LVToken, volume: Volume.ID] =           -- Set up in memory list of pages which have lost their data          BEGIN     svDesc: VolTable.SVDesc;     dataLostPage: PhysicalVolume.PageNumber;       CreateBadDataPageList: VolTable.PVAccessProc =      BEGIN     numberOfBadDataPages ¬ 0;     dataLostPage ¬ PhysicalVolumeExtras.nullDataLostPage;     DO        dataLostPage ¬ 	   PhysicalVolumeExtras.GetNextDataLostPage[svDesc.pvID, dataLostPage];	        IF dataLostPage = PhysicalVolumeExtras.nullDataLostPage THEN EXIT;        IF dataLostPage IN	   [svDesc.pvPageOfSV..svDesc.pvPageOfSV + svDesc.svLength) THEN	   numberOfBadDataPages ¬ numberOfBadDataPages + 1;        ENDLOOP;     badDataPageListSize ¬ MAX[Space.PagesFromWords[numberOfBadDataPages *        SIZE[VI.BadDataPageEntry]], 1];     badDataPageList ¬ Space.Allocate[badDataPageListSize         ! Space.InsufficientSpace => Bug[outOfVM]].pointer;     VM.ScratchMap[[Space.PageFromLongPointer[badDataPageList],        badDataPageListSize]];     numberOfBadDataPages ¬ 0;     dataLostPage ¬ PhysicalVolumeExtras.nullDataLostPage;         DO        dataLostPage ¬ 	   PhysicalVolumeExtras.GetNextDataLostPage[svDesc.pvID, dataLostPage];	IF dataLostPage = PhysicalVolumeExtras.nullDataLostPage THEN EXIT;        IF dataLostPage IN	   [svDesc.pvPageOfSV..svDesc.pvPageOfSV + svDesc.svLength) THEN	   BEGIN	   badDataPageList[numberOfBadDataPages].page ¬	      (dataLostPage - svDesc.pvPageOfSV);	   badDataPageList[numberOfBadDataPages].processed ¬ FALSE;	   numberOfBadDataPages ¬ numberOfBadDataPages + 1;	   END;        ENDLOOP;     END; --CreateBadDataPageList PVAccessProc--       VolTable.GetNextSV[[byLV[volume, [first[]]]], @svDesc];     VolTable.PVAccess[pvID: svDesc.pvID, proc: CreateBadDataPageList, lock: read];          END; --CreateBadDataPageList--    -------------------------------------------------------------------------------  -- CreateBadPageList  -------------------------------------------------------------------------------    CreateBadPageList: PUBLIC PROCEDURE [     tok: VolTable.LVToken, volume: Volume.ID] =     BEGIN     svDesc: VolTable.SVDesc;     pv: PVF.Handle ¬ Space.Allocate[PVF.rootPageSize         ! Space.InsufficientSpace => Bug[outOfVM]].pointer;       CreateBadPageList: VolTable.PVAccessProc =      BEGIN     numberOfBadPages ¬ 0;     VolTable.MapPVRootPage[tok, pv];     FOR i: CARDINAL IN [0..CARDINAL[pv.badPageCount]) DO        IF pv.badPageList[i] IN	   [svDesc.pvPageOfSV..svDesc.pvPageOfSV + svDesc.svLength] THEN	   numberOfBadPages ¬ numberOfBadPages + 1;        ENDLOOP;     badPageListSize ¬ MAX[Space.PagesFromWords[numberOfBadPages *         SIZE[Volume.PageNumber]], 1];     badPageList ¬ Space.Allocate[badPageListSize         ! Space.InsufficientSpace => Bug[outOfVM]].pointer;     VM.ScratchMap[[Space.PageFromLongPointer[badPageList], badPageListSize]];     numberOfBadPages ¬ 0;         FOR i: CARDINAL IN [0..CARDINAL[pv.badPageCount]) DO        IF pv.badPageList[i] IN	   [svDesc.pvPageOfSV..svDesc.pvPageOfSV + svDesc.svLength] THEN	   BEGIN	   badPageList[numberOfBadPages] ¬	      (pv.badPageList[i] - svDesc.pvPageOfSV);	    numberOfBadPages ¬ numberOfBadPages + 1;	   END;        ENDLOOP;     VolTable.UnmapPVRootPage[tok, pv];     Space.Deallocate[[pv, PVF.rootPageSize]];     END; --CreateBadPageList PVAccessProc--       VolTable.GetNextSV[[byLV[volume, [first[]]]], @svDesc];     VolTable.PVAccess[pvID: svDesc.pvID, proc: CreateBadPageList, lock: read];     END; --CreateBadPageList--       -------------------------------------------------------------------------------  -- ClearLog   -------------------------------------------------------------------------------    ClearLog: PUBLIC PROCEDURE [     logFile: File.File] =        -- Set the number of entries in the specified scavenger log to zero.       BEGIN          window: Space.Window;     logHeaderInterval: Space.Interval;     logHeaderPointer: LONG POINTER TO Scavenger.Header;           window ¬ [file: logFile, base: 0, count: 1];     logHeaderInterval ¬ Space.Map[window, , , , , ];     logHeaderPointer ¬ logHeaderInterval.pointer;     logHeaderPointer.logEntries ¬ 0;     [] ¬ Space.Unmap[logHeaderPointer, wait];          END;  --ClearLog--    -------------------------------------------------------------------------------  -- CrudeBucketValidation  -------------------------------------------------------------------------------    CrudeBucketValidation: PROCEDURE[bucket: ET.BucketHandle]   RETURNS[valid: BOOLEAN] =     -- Makes a crude syntactical validation that the page passed in is or is not   -- an ETable bucket page.       BEGIN     valid ¬ TRUE;     IF bucket.header.eTablesInOverflowCount > 1000 OR         LOOPHOLE[bucket.header.firstFree, CARDINAL] < 2 OR	LOOPHOLE[bucket.header.firstFree, CARDINAL] > 256 THEN valid ¬ FALSE;     END; --CrudeBucketValidation--       -------------------------------------------------------------------------------  -- CrudeETFETValidation  -------------------------------------------------------------------------------    CrudeETFETValidation: PROCEDURE[eTable: ET.ETableHandle]   RETURNS[valid: BOOLEAN] =     -- Makes a crude syntactical validation that the page passed in is or is not   -- an ETFET page.       BEGIN     valid ¬ TRUE;  --     IF eTable.header.unused ~= 0 OR     !!! FIX THIS       IF eTable.header.howManyGroups = 0 OR         eTable.header.bootable = TRUE OR 	eTable.header.temporary = TRUE THEN valid ¬ FALSE;     END; --CrudeETFETValidation--    -------------------------------------------------------------------------------  -- CrudeFirstOverflowPageValidation  -------------------------------------------------------------------------------    CrudeFirstOverflowPageValidation: PROCEDURE[firstOverflow: ET.BucketHandle]   RETURNS[valid: BOOLEAN] =     -- Makes a crude syntactical validation that the page passed in is or is not   -- a first page of the overflow area.       BEGIN     valid ¬ TRUE;  --   IF LOOPHOLE[firstOverflow.header.freeSpace, LONG CARDINAL] < 2 OR   --      LOOPHOLE[firstOverflow.header.freeSpace, LONG CARDINAL] > 512000 THEN   --      valid ¬ FALSE;   !!! FIX THIS     END; --CrudeFirstOverflowPageValidation--    -------------------------------------------------------------------------------  -- CrudeHeaderValidation  -------------------------------------------------------------------------------    CrudeHeaderValidation: PROCEDURE[header: ET.FileHeaderHandle]   RETURNS[valid: BOOLEAN] =     -- Makes a crude syntactical validation that the page passed in is or is not   -- an ETable header page.       BEGIN     valid ¬ TRUE;     IF header.seal # ETable.fileSystemSeal OR        header.version > ETable.fileSystemVersion OR        header.numberOfBuckets = 0 OR         header.numberOfBuckets > 7000 OR  -- 7000 is an arbitrary number of buckets --	header.numberOfPagesLogged > header.preImageSize OR 	header.maxETableSize = 0 OR 	header.maxETableSize > 50 THEN valid ¬ FALSE;     END; --CrudeHeaderValidation--       -------------------------------------------------------------------------------  -- CrudeOverflowPageValidation  -------------------------------------------------------------------------------    CrudeOverflowPageValidation: PROCEDURE[]   RETURNS[valid: BOOLEAN] =     -- Makes a crude syntactical validation that the page passed in is or is not   -- a non-first page of the overflow area.       BEGIN     valid ¬ TRUE;          -- IS ANY VALIDATION POSSIBLE HERE!!!          END; --CrudeOverflowPageValidation--    -------------------------------------------------------------------------------  -- EraseLV  -------------------------------------------------------------------------------    EraseLV: PUBLIC PROCEDURE [     lvID: Volume.ID, lvHandle: LVF.Handle, tok: VolTable.LVToken] =        -- Deletes all data from the specified logical volume.    -- NOTE: lvHandle is not mapped at this point.      BEGIN    channel: DiskBackingStore.ChannelHandle;    countValid: Volume.PageCount;    diskChannel: DiskChannel.Handle;    diskStatus: DiskChannel.IOStatus;    firstPVPageOfLV: PhysicalVolume.PageNumber;    memPage: Environment.PageNumber;    memPagePtr: LONG POINTER TO ARRAY[0..Environment.wordsPerPage) OF CARDINAL;    pvPage: PhysicalVolume.PageNumber;    svDesc: VolTable.SVDesc;    volumeSize: Volume.PageCount;    vol: LVF.Handle;    badPages: BadPageDescriptor ¬      ScavengerUtilities.GatherLVBadPages[tok, lvID];    subvolumes: LONG DESCRIPTOR FOR ARRAY OF ScavengerUtilities.SVInfo;    lvValid, anyMarkersValid: BOOLEAN ¬ TRUE;    currentLVPage: Volume.PageNumber;        -- Eliminate all entries in the dataLostPageList for this logical volume.        ClearDataLostPageList[lvID];    IF VolTable.GetLVStatus[lvID].entryState = open THEN      ERROR Scavenger.Error[volumeOpen];  -- can't erase an open volume          -- Force VolTable to unmap the root page        VolTable.AssertRootPageReadability[tok, rootPageUnreadable];    vol ¬ lvHandle;        -- The following just makes sure the root page is readable.          VM.ScratchMap[[Space.PageFromLongPointer[vol], LVF.rootPageSize]];    [channel, pvPage, countValid, pvPageNumberOfLVRootPage, lvPageNumberOfLVRootPage] ¬       GetDiskIOInfo[lvID, 0, LVF.rootPageSize];    firstPVPageOfLV ¬ pvPage;    diskChannel ¬ DiskBackingStore.GetDiskChannel[channel];    diskStatus ¬ ScavengerUtilities.ReadPages[      data: vol,      firstPage: pvPageNumberOfLVRootPage,      count: LVF.rootPageSize,      try: normalRetry,      diskChannel: diskChannel];    IF diskStatus ~= goodCompletion THEN       ERROR Scavenger.Error[needsRiskyRepair];    VM.Unmap[Space.PageFromLongPointer[vol]];           VolTable.AssertRootPageReadability[tok, rootPageReadable];        -- Volume is now changing        vol.changing ¬ TRUE;    VM.ForceOut[[Space.PageFromLongPointer[vol], LVF.rootPageSize], wait];        subvolumes ¬ ScavengerUtilities.GatherLVMarkerPages[tok, lvID];    VolTable.GetNextSV[[byLV[lvID, [first[]]]], @svDesc];    volumeSize ¬ svDesc.svLength;          lvValid ¬ vol.seal = LogicalVolumeFormat.lvRootSeal AND vol.vID = lvID AND      vol.labelLength IN [0..LogicalVolumeFormat.maxLogicalVolumeLabelLength]      AND vol.type IN Volume.Type;    FOR subvolumeIndex: CARDINAL IN [0..LENGTH[subvolumes]) DO      lvmp: LogicalVolumeFormat.SubmarkerHandle =        @subvolumes[subvolumeIndex].marker.logical;      subvolumes[subvolumeIndex].valid ¬ lvmp.seal = LVF.LSMSeal        AND lvmp.labelLength IN [0..LogicalVolumeFormat.maxLogicalVolumeLabelLength]	AND lvmp.pad = 0 AND lvmp.type IN Volume.Type;      anyMarkersValid ¬ anyMarkersValid OR subvolumes[subvolumeIndex].valid;      ENDLOOP;          -- At this pointer we have the root page and all marker pages in hand.    -- We also know which might have valid information and which certainly don't.    IF ((~anyMarkersValid) AND (~lvValid)) THEN -- Nothing is valid      BEGIN      vol.vID ¬ lvID;      vol.labelLength ¬ 0;      vol.label ¬ LogicalVolumeFormat.nullName;      vol.type ¬ normal;      END    ELSE IF ~lvValid THEN  -- at least one marker is valid      BEGIN      vol.vID ¬ lvID;      -- just pick first valid marker page for label information      FOR subvolumeIndex: CARDINAL IN [0..LENGTH[subvolumes]) DO        lvmp: LogicalVolumeFormat.SubmarkerHandle = 	  @subvolumes[subvolumeIndex].marker.logical;	IF subvolumes[subvolumeIndex].valid THEN	  BEGIN	  vol.labelLength ¬ lvmp.labelLength;	  vol.label ¬ lvmp.label;	  vol.type ¬ lvmp.type;	  END;	ENDLOOP;      END;        vol.seal ¬ LogicalVolumeFormat.lvRootSeal;    vol.version ¬ LogicalVolumeFormat.currentVersion;    vol.volumeSize ¬ volumeSize;    vol.bootingInfo ¬ LogicalVolumeFormat.nullBoot;    vol.pad ¬ 0;    vol.pad1 ¬ 0;    vol.freePageCount ¬ 0;    vol.vamStart ¬ GetDiskIOInfo[lvID, 0, LVF.rootPageSize].lvPageNumberOfLVRootPage +       LVF.rootPageSize;        vol.primaryETableStartPage ¬ 0;    vol.copyETableStartPage ¬ 0;    vol.lowerBound ¬ LogicalVolumeFormat.rootPageSize;    vol.volumeRootDirectory ¬ File.nullID;    vol.numberOfFile ¬ 0;    FOR t: PilotFileTypes.PilotRootFileType IN PilotFileTypes.PilotRootFileType DO      vol.rootFileID[t] ¬        SELECT t FROM	  PilotFileTypes.tFreePage, PilotFileTypes.tVolumeAllocationMap => 	     FileIDFromNumber[t],	  PilotFileTypes.tVolumeFileMap =>	    FileIDFromNumber[PilotFileTypesExtraExtras.tETable],	  ENDCASE => File.nullID;      ENDLOOP;    vol.lastIDAllocated ¬ LAST[FileTypes.PilotFileType];    vol.scavengerLogVolume ¬ Volume.nullID;    vol.lastTimeOpendForWrite ¬ System.GetGreenwichMeanTime[];    vol.statusPrimaryETableFile ¬ 0;    vol.statusCopyETableFile ¬ 0;    vol.fill ¬ ALL[0];    vol.checksum ¬ 0;    vol.numberOfBadPagesLastTime ¬ 0;        -- At this point, the root page contains the correct information.  Copy it     -- back into the marker pages.    FOR subvolumeIndex: CARDINAL IN [0..LENGTH[subvolumes]) DO       lvmp: LogicalVolumeFormat.SubmarkerHandle =          @subvolumes[subvolumeIndex].marker.logical;	      -- Note that we check before writing into certain fields to minimize the      -- number of times that we must write the marker pages.            IF ~subvolumes[subvolumeIndex].valid THEN        BEGIN lvmp.seal ¬ LogicalVolumeFormat.LSMSeal;  lvmp.pad ¬ 0; END;      IF lvmp.version # LogicalVolumeFormat.LSMCurrentVersion THEN         lvmp.version ¬ LogicalVolumeFormat.LSMCurrentVersion;      IF lvmp.labelLength # vol.labelLength THEN lvmp.labelLength ¬ vol.labelLength;      IF lvmp.type # vol.type THEN lvmp.type ¬ vol.type;      IF lvmp.label # vol.label THEN lvmp.label ¬ vol.label;      lvmp.bootingInfo ¬ LogicalVolumeFormat.nullBoot;      lvmp.volumeRootDirectory ¬ File.nullID;      lvmp.primaryETableStartPage ¬ 0;      lvmp.copyETableStartPage ¬ 0;      lvmp.statusPrimaryETableFile ¬ 0;      lvmp.statusCopyETableFile ¬ 0;      lvmp.padding ¬ ALL[0];      ENDLOOP;    -- Zero out data on every page of volume         memPagePtr ¬ LOOPHOLE[Space.Allocate[1        ! Space.InsufficientSpace => Bug[outOfVM]].pointer];    memPage ¬ Space.PageFromLongPointer[memPagePtr];    VM.ScratchMap[[memPage, 1]];    memPagePtr­ ¬ ALL[0];    currentLVPage ¬ lvPageNumberOfLVRootPage + LVF.rootPageSize;    FOR badPageIndex: CARDINAL IN [0..LENGTH[badPages]) DO      badPage: Volume.PageNumber ¬ badPages[badPageIndex];      IF badPage < currentLVPage THEN LOOP; -- skips over bad root page      IF badPage # currentLVPage THEN          [] ¬ WriteMultipleCopies[currentLVPage, badPage - currentLVPage,	  memPage, diskChannel, firstPVPageOfLV];      currentLVPage ¬ SUCC[badPage];  -- skip over bad page      ENDLOOP;    -- now take care of all pages after last bad page or all pages on logical    -- volume if there are no bad pages.    -- BROKEN IF MOVED MARKER BACKWARDS, IF VOLUMESIZE DOESN'T REFLECT IT?    IF currentLVPage < volumeSize THEN       [] ¬ WriteMultipleCopies[currentLVPage, volumeSize - currentLVPage,        memPage, diskChannel, firstPVPageOfLV];    VM.Unmap[memPage];    Space.Deallocate[[memPagePtr, 1]];        «[] ¬ DataTransfer.WriteData[file: [File.nullID, vID, FALSE, count],      group: [filepage, volumePage, nextFilePage],      data: VM.nullInterval, handleErrors: TRUE, tok: tok];»        VamInit[vol, badPages, tok];    ETableInit[vol, tok];        -- At this point, the root page contains the correct information.  Copy it     -- back into the marker pages.    FOR subvolumeIndex: CARDINAL IN [0..LENGTH[subvolumes]) DO      lvmp: LogicalVolumeFormat.SubmarkerHandle =         @subvolumes[subvolumeIndex].marker.logical;      lvmp.primaryETableStartPage ¬ vol.primaryETableStartPage;      lvmp.copyETableStartPage ¬ vol.copyETableStartPage;      lvmp.statusPrimaryETableFile ¬ vol.statusPrimaryETableFile;      lvmp.statusCopyETableFile ¬ vol.statusCopyETableFile;      ENDLOOP;        VolAllocMap.Close[lvID, forceOut, tok];    ETable.Close[tok];    ScavengerUtilities.FreeLVBadPages[badPages !      Space.Error --[typ]-- => IF type = notMapped THEN CONTINUE ELSE REJECT];    ScavengerUtilities.FreeLVMarkerPages[subvolumes !      Space.Error --[typ]-- => IF type = notMapped THEN CONTINUE ELSE REJECT];    vol.changing ¬ FALSE;    VM.ForceOut[[Space.PageFromLongPointer[vol], LVF.rootPageSize], wait];        END; --EraseLV--    -------------------------------------------------------------------------------  -- ETableInit  -------------------------------------------------------------------------------  ETableInit: PROCEDURE [vol: LVF.Handle, lvToken: VolTable.LVToken] =    BEGIN    numberOfBuckets: CARDINAL = CARDINAL[MAX[(vol.volumeSize/100 + 5)*3/10,      ETI.minBuckets]];    eTableFileETableSize: CARDINAL = 3;    overflowSize: CARDINAL = 4;    primaryStartPageHint: Volume.PageNumber = vol.volumeSize/2 - numberOfBuckets;    preImageSize: CARDINAL ¬ MAX[(2 * eTableFileETableSize) + 1, overflowSize];        EnoughSpace: PROC RETURNS [BOOLEAN] = {  -- saves code space      RETURN[vol.freePageCount >= ETable.MinPagesForETables[vol.volumeSize]]};     -- First free up enough pages so that we can initialize the ETables:        UNTIL EnoughSpace[] DO      freeAtStartOfPass: Volume.PageCount = vol.freePageCount;      Bug[notImplemented];      ENDLOOP;    -- Now that there are enough free pages, we can initialize the map.        ETable.CreateFile[      lvHandle: vol, tok: lvToken, primaryStartPageHint: primaryStartPageHint,      copyStartPageHint: primaryStartPageHint + numberOfBuckets + 18 + 32,      eTableSize: eTableFileETableSize, preImageSize: preImageSize,      numberOfBuckets: numberOfBuckets, overflowSize: overflowSize];    ETable.Open[lvToken];    END;  --ETableInit--  -------------------------------------------------------------------------------  -- FileIDFromNumber  -------------------------------------------------------------------------------    FileIDFromNumber: PROC [id: FileInternal.FileID] RETURNS [File.ID] = INLINE {    RETURN[LOOPHOLE[id]]};  -------------------------------------------------------------------------------  -- GetDiskIOInfo  -------------------------------------------------------------------------------    GetDiskIOInfo: PUBLIC PROCEDURE [    volume: Volume.ID, firstPage: Volume.PageNumber, count: Volume.PageCount]    RETURNS [      channel: DiskBackingStore.ChannelHandle,      diskPage: PhysicalVolume.PageNumber,       countValid: Volume.PageCount,       pvPageNumberOfLVRootPage: PhysicalVolume.PageNumber,       lvPageNumberOfLVRootPage: Volume.PageNumber] =    BEGIN    found: BOOLEAN;    svDesc: VolTable.SVDesc;    bsChannel: DiskBackingStore.ChannelHandle;    [found, bsChannel] ¬ VolTable.FindSV[volume, firstPage, @svDesc];    IF ~found THEN Bug[unexpectedVolTableError];    RETURN[      channel: bsChannel,      diskPage: svDesc.pvPageOfSV + firstPage,      countValid: MIN[count, svDesc.svLength - firstPage],       pvPageNumberOfLVRootPage: svDesc.pvPageOfSV + svDesc.lvPageOfSV,       lvPageNumberOfLVRootPage: svDesc.lvPageOfSV];    END; --GetDiskIOInfo--      -------------------------------------------------------------------------------  -- GetLog  -------------------------------------------------------------------------------    GetLog: PUBLIC PROCEDURE [volume: Volume.ID] RETURNS [logFile: File.File] =     BEGIN     GetLogAccessProc: VolTable.LVAccessProc --[tok,lvHandle]--  = {       logFile ¬ File.nullFile;       IF lvHandle.scavengerLogVolume = Volume.nullID THEN          RETURN;         logFile.fileID ¬ lvHandle.rootFileID[PilotFileTypes.tScavengerLog];       logFile.volumeID ¬ lvHandle.scavengerLogVolume};            VolTable.LVAccess[volume, GetLogAccessProc, read];     END;  --GetLog--      -------------------------------------------------------------------------------  -- IsDataOnPageBad  -------------------------------------------------------------------------------       IsDataOnPageBad: PUBLIC PROCEDURE [firstPage: LONG POINTER TO Volume.PageNumber,     count: LONG POINTER TO Volume.PageCount]   RETURNS[BOOLEAN] =    -- Returns FALSE if the specified interval does not contain a page which has   -- lost its data.  If the specified interval does contain such a page, returns   -- TRUE with firstPage being the page after the page which has lost its data.    -- The idea is that, after processing the page, this procedure can be called   -- to process the remaining pages.          BEGIN    FOR i: CARDINAL IN [0..numberOfBadDataPages) DO        IF badDataPageList[i].page >= firstPage­ AND           badDataPageList[i].page < firstPage­ + count­ THEN	     BEGIN	     count­ ¬ count­ - (badDataPageList[i].page - firstPage­) - 1;	     firstPage­ ¬ badDataPageList[i].page + 1;	     RETURN[TRUE];	     END;       ENDLOOP;    count­ ¬ 0;    RETURN[FALSE];    END; --IsDataOnPageBad--      -------------------------------------------------------------------------------  -- IsPageBad     -------------------------------------------------------------------------------    IsPageBad: PUBLIC PROCEDURE [firstPage:  LONG POINTER TO Volume.PageNumber,     count: LONG POINTER TO Volume.PageCount]   RETURNS[BOOLEAN] =    -- Returns FALSE if the specified interval does not contain a page which    -- is bad.  If the specified interval does contain a bad page, returns   -- TRUE with firstPage being the page after the page which is bad.    -- The idea is that, after processing the page, this procedure can be called   -- to process the remaining pages.    BEGIN    FOR i: CARDINAL IN [0..numberOfBadPages) DO        IF badPageList[i] >= firstPage­ AND           badPageList[i] < firstPage­ + count­ THEN	     BEGIN	     count­ ¬ count­ - (badPageList[i] - firstPage­) - 1;	     firstPage­ ¬ badPageList[i] + 1;	     RETURN[TRUE];	     END;       ENDLOOP;    count­ ¬ 0;    RETURN[FALSE];    END; --IsPageBad--      -------------------------------------------------------------------------------  -- MarkItProcessed    -------------------------------------------------------------------------------      MarkItProcessed: PROCEDURE [volumePage: Volume.PageNumber] =      BEGIN      FOR i: CARDINAL IN [0..numberOfBadDataPages) DO 	 IF badDataPageList[i].page = volumePage THEN	    badDataPageList[i].processed ¬ TRUE;	 ENDLOOP;      END; --MarkItProcessed--            -------------------------------------------------------------------------------  -- MarkItUnProcessed    -------------------------------------------------------------------------------      MarkItUnProcessed: PROCEDURE [firstPage: Volume.PageNumber] =      BEGIN      FOR i: CARDINAL IN [0..numberOfBadDataPages) DO 	 IF badDataPageList[i].page = firstPage THEN	    badDataPageList[i].processed ¬ FALSE;	 ENDLOOP;      END; --MarkItUnProcessed--       -------------------------------------------------------------------------------  -- MakeFileList    -------------------------------------------------------------------------------    MakeFileList: PUBLIC PROCEDURE [    volume, logDestination: Volume.ID]    RETURNS [logFile: File.File] =    BEGIN        MakeFileListAccessProc: VolTable.LVAccessProc --[tok,lvHandle]--  =      -- This procedure should (if logDestination = volume) really create the      -- file, call SimpleFile.GetBackingStoreData multiple times (to construct      -- total runs of the file), call VM.Map, and then ETable.MakeFileList.      -- If logDestination # volume then this procedure can create the file,      -- call Space.Map on it, and finally call ETable.MakeFileList (converting      -- the space interval to a VM.Interval as required.      BEGIN      spaceInterval: Space.Interval ¬ Space.nullInterval;      vmInterval: VM.Interval ¬ VM.nullInterval;      log: LONG POINTER TO Scavenger.LogFormat;      requestedSize: Space.PageCount ¬         WordsToPages[SIZE[Scavenger.Header] + 	(lvHandle.numberOfFile * SIZE[Scavenger.FileEntry])];      BEGIN      ENABLE         Volume.InsufficientSpace, Volume.Unknown, Volume.NotOpen,	Volume.NotOnline, Volume.ReadOnly => 	  BEGIN	  VM.Unmap[vmInterval.page ! Space.Error => CONTINUE];	  Space.Deallocate[spaceInterval ! Space.Error => CONTINUE];	  GO TO CantWriteLog;	  END;      spaceInterval ¬ Space.Allocate[requestedSize];      log ¬ LOOPHOLE[spaceInterval.pointer, LONG POINTER TO Scavenger.LogFormat];      vmInterval ¬         [Space.PageFromLongPointer[spaceInterval.pointer], spaceInterval.count];      VM.ScratchMap[vmInterval];      ETable.MakeFileList[tok, vmInterval];      IF logDestination # volume THEN        logFile ¬ SpecialFile.CreateWithContents[	  logDestination, requestedSize, fileListType, spaceInterval !	    Volume.InsufficientSpace => 	      BEGIN	      requestedSize ¬ currentFreeSpace;	      log.header.incomplete ¬ TRUE;	      log.header.logEntries ¬	        ((Environment.wordsPerPage * currentFreeSpace) -		SIZE[Scavenger.Header]) / SIZE[Scavenger.FileEntry];	      RETRY;	      END]      ELSE  -- logDestination = volume        BEGIN        IF lvHandle.lastIDAllocated >= FileInternal.FileID.LAST THEN 	  Bug[outOfFileIDs]	ELSE logFile.fileID ¬ LOOPHOLE[(lvHandle.lastIDAllocated ¬ 	  lvHandle.lastIDAllocated.SUCC), File.ID];	logFile.volumeID ¬ logDestination;	FileInternal.CreateInternal[	  logFile, lvHandle, tok, requestedSize, fileListType, vmInterval !	    Volume.InsufficientSpace => 	      BEGIN	      requestedSize ¬ currentFreeSpace;	      log.header.incomplete ¬ TRUE;	      log.header.logEntries ¬	        ((Environment.wordsPerPage * currentFreeSpace) -		SIZE[Scavenger.Header]) / SIZE[Scavenger.FileEntry];	      RETRY;	      END];	END;      -- Cleanup      VM.Unmap[vmInterval.page];      Space.Deallocate[spaceInterval];      EXITS        CantWriteLog => ERROR Scavenger.Error[cannotWriteLog];      END;  --ENABLE--      END;  --MakeFileListAccessProc--    VolTable.LVAccess[volume, MakeFileListAccessProc,      IF volume = logDestination THEN writeWithChangingFlag ELSE read];    END;  --MakeFileList--  -------------------------------------------------------------------------------  -- MarkVAMPagesAsBusy    -------------------------------------------------------------------------------    MarkVAMPagesAsBusy: PUBLIC PROCEDURE [     lvHandle:LVF.Handle, lvToken: VolTable.LVToken,      volumePage: LONG POINTER TO Volume.PageNumber,      count: LONG POINTER TO LONG CARDINAL]  RETURNS[busyPage: BOOLEAN] =    -- In the VAM, marks the specified pages as busy and returns FALSE.    If one of  -- the pages is already busy, returns TRUE with volumePage set to the page after  -- the busy page and count set to the number of pages following the busy page.  -- The idea is that this procedure can then immediately be called to process  -- the remaining pages.    -- CURRENTLY DOES NOT CHECK FOR BUSY PAGES!!!  THIS SHOULD BE ADDED!!!    BEGIN    VolAllocMap.SetPageGroup[     lvHandle, volumePage­, count­, busy, ignorePrevSetting, lvToken];  count­ ¬ 0;  RETURN[FALSE];    END; --MarkVAMPagesAsBusy--  ---------------------------------------------------------------------------  -- ReadPage   ---------------------------------------------------------------------------    ReadPage: PUBLIC PROCEDURE [volumePage: Volume.PageNumber,      memPage: Environment.PageNumber, diskChannel: DiskChannel.Handle,     firstPVPageOfLV: PhysicalVolume.PageNumber]  RETURNS [status: disk DiskChannel.IOStatus] =     -- Read the specified page into resident memory.  -- It is assumed that diskChannel has already been initialized.  -- Will not work if LV's can span PV's.    BEGIN  ioStatus: DiskChannel.IOStatus;  request: DiskChannel.IORequest;  countValid: File.PageCount;  request ¬ [      command: read, diskPage: firstPVPageOfLV + volumePage, memoryPage: memPage,      tries: DiskChannel.defaultTries,      count: LONG[1], useSamePage: FALSE];  [ioStatus, countValid] ¬ DiskChannel.DoIO[diskChannel, @request];  WITH diskStatus: ioStatus SELECT FROM     invalidChannel => Bug[invalidChannel];     invalidDriveState => Bug[invalidDriveState];     disk => status ¬ diskStatus;     ENDCASE => Bug[impossibleEndcase];  END; --ReadPage--    ---------------------------------------------------------------------------  -- ReadParallelAndCorrect  ---------------------------------------------------------------------------    ReadParallelAndCorrect: PUBLIC PROCEDURE [     memPage: Environment.PageNumber, pageCount: LONG CARDINAL,     primaryFilePage:File.PageNumber,      primaryETFET: ETable.ETableHandle,      copyFilePage: File.PageNumber,      copyETFET: ETable.ETableHandle,      problem: VI.ETableErrorType]     RETURNS [dataLost: BOOLEAN ¬ FALSE] =         -- SHOULDN'T PRIMARY RATHER THAN COPY BE USED!!    --    -- This procedure reads the specified copy interval of disk data into the     -- specified real memory interval.  For each page we have the following cases:    --    --   1. The pages of the copy are fine.  In this case the data is read into     --      memory from the copy.    --   2. A page from the copy has lost its data but the page is    --      still good.  In this case, the data is read into memory from the    --      parallel primary interval and then written to the copy.    --   3. A page from the copy interval is bad (either in the badPageTable     --      or cannot be read).  In this case the data is read into memory from     --      the parallel primary interval and the bad page is entered into the     --      errorList for later correction.    --    -- After obtaining each presumably good page of data, the page is written to    -- the other interval.  If a page from the interval is bad      -- (either in badPageTable or cannot be written) the bad page is entered into     -- the errorList for later correction.  Otherwise the in memory data is     -- written to the interval.    --    -- If there is bad data in two parallel pages, the pages are put into the     -- errorList, marked as either good but having lost data or bad, and dataLost     -- is returned as TRUE.     --     -- All writes are performed with a read after write check to guarantee the     -- file's integrety.    --    -- The result of this processing (unless dataLost = TRUE) is that the in    -- memory interval will represent the true value of the pages, pages     -- which are still good but have lost their data will have had their data    -- replaced, and pages which are bad will be entered into the errorList for     -- later processing.  Every page in both intervals will have been either read    -- or written and therefore, to some extent, verified.         BEGIN    tempVolumePageOfCopy, tempVolumePageOfPrimary, tempVolumePage: Volume.PageNumber;    badPageOfCopy, badDataOfCopy, badPageOfPrimary, badDataOfPrimary: BOOLEAN;    statusOfCopy, statusOfPrimary:  DiskChannel.IOStatus;    currentFilePageInIntervalOfCopy: File.PageNumber ¬ copyFilePage;    currentFilePageInIntervalOfPrimary: File.PageNumber ¬ primaryFilePage;    currentMemPage: Environment.PageNumber ¬ memPage;    count: LONG CARDINAL;        --    -- Process page by page    --        FOR i: LONG CARDINAL IN [0..pageCount) DO       --       -- Determine the status of the primary page and its corresponding copy page       --       tempVolumePageOfCopy ¬ ETI.WhereIsFilePageOnVolume[	  currentFilePageInIntervalOfCopy, copyETFET].volumePage;       tempVolumePageOfPrimary ¬ ETI.WhereIsFilePageOnVolume[          currentFilePageInIntervalOfPrimary, primaryETFET].volumePage;       tempVolumePage ¬ tempVolumePageOfCopy;       count ¬ 1;       badPageOfCopy ¬ IsPageBad[@tempVolumePage, @count];       tempVolumePage ¬ tempVolumePageOfPrimary;       count ¬ 1;       badPageOfPrimary ¬ IsPageBad[@tempVolumePage, @count];       tempVolumePage ¬ tempVolumePageOfCopy;       count ¬ 1;       IF badDataOfCopy ¬ IsDataOnPageBad[@tempVolumePage, @count] THEN         MarkItProcessed[tempVolumePageOfCopy];       badDataOfCopy ¬ badDataOfCopy OR badPageOfCopy;       tempVolumePage ¬ tempVolumePageOfPrimary;       count ¬ 1;       IF badDataOfPrimary ¬ IsDataOnPageBad[@tempVolumePage, @count] THEN         MarkItProcessed[tempVolumePageOfPrimary];       badDataOfPrimary ¬ badDataOfPrimary OR badPageOfPrimary;       --       -- If copy supposedly has good data, try to read it in       --       IF ~badDataOfCopy THEN          BEGIN	  statusOfCopy ¬ ReadPage[	     tempVolumePageOfCopy, currentMemPage, VI.diskChannel, firstPVPageOfLV];	  IF statusOfCopy ~= goodCompletion THEN badDataOfCopy ¬ TRUE;	  	  -- Perform a crude syntactical validation of the page.  If not  	  -- syntactically correct, then badDataOfCopy ¬ TRUE.	  	  badDataOfCopy ¬ badDataOfCopy OR 	     ~ValidPage[problem, currentMemPage];	    	  END;       --       -- Check 'badness' of each of the pages by appropriate reading and writing.       -- The reading and writing may be performed even though the data involved       -- is meaningless.       --       statusOfCopy ¬ statusOfPrimary ¬ goodCompletion;       SELECT TRUE FROM                  badDataOfCopy = FALSE AND badDataOfPrimary = FALSE AND VI.minimalScavenge = TRUE => 	     	     -- Good page from copy in memory and no reason for full scavenge.	     	     statusOfPrimary ¬ goodCompletion;	               badDataOfCopy = FALSE => 	  	     -- A good page from copy is in memory, and there is a reason to write 	     -- to primary	     	     BEGIN	     IF ~badPageOfPrimary THEN 		statusOfPrimary ¬ WritePage[		   tempVolumePageOfPrimary, currentMemPage, VI.diskChannel, firstPVPageOfLV];	     END;	     	  badPageOfCopy = FALSE  => 	  	     -- The data from copy page is not good, but the page itself is probably OK. 	     -- Fill memory and copy with primary.	     	     BEGIN	     IF badDataOfPrimary OR badPageOfPrimary THEN	        dataLost ¬ TRUE;	     IF ~badPageOfPrimary THEN 	        BEGIN 	        statusOfPrimary ¬ ReadPage[		   tempVolumePageOfPrimary, currentMemPage, VI.diskChannel, firstPVPageOfLV];	        IF statusOfPrimary ~= goodCompletion THEN	           BEGIN		   dataLost ¬ TRUE;		   badDataOfPrimary ¬ TRUE;		   statusOfPrimary ¬ WritePage[		      tempVolumePageOfPrimary, currentMemPage, 		      VI.diskChannel, firstPVPageOfLV];		   END;		badDataOfPrimary ¬ badDataOfPrimary OR 		   ~ValidPage[problem, currentMemPage];		END;	     statusOfCopy ¬ WritePage[tempVolumePageOfCopy, currentMemPage, 	        VI.diskChannel, firstPVPageOfLV];	     IF badDataOfPrimary THEN dataLost ¬ TRUE;	     END;	     	  badDataOfPrimary = FALSE => 	  	     -- The data from copy page is not good and neither is the page itself.	     -- Fill memory with primary. The copy page is bad and cannot be filled.	     	     BEGIN	     IF badDataOfPrimary OR badPageOfPrimary THEN 	        dataLost ¬ TRUE;	     IF ~badPageOfPrimary THEN 	        BEGIN	        statusOfPrimary ¬ ReadPage[		   tempVolumePageOfPrimary, currentMemPage, VI.diskChannel, firstPVPageOfLV];	        IF statusOfPrimary ~= goodCompletion THEN	           BEGIN		   dataLost ¬ TRUE;		   badDataOfPrimary ¬ TRUE;		   statusOfPrimary ¬ WritePage[tempVolumePageOfPrimary, currentMemPage,		      VI.diskChannel, firstPVPageOfLV];		   END;		   	        -- Perform a crude syntactical validation of the page.  If not 	        -- correct, then badDataOfPrimary ¬ TRUE and dataLost ¬ TRUE.	  	        badDataOfPrimary ¬ badDataOfPrimary OR 	           ~ValidPage[problem, currentMemPage];	        END;	     IF badDataOfPrimary THEN dataLost ¬ TRUE;	     END;	     	  ENDCASE =>	  	     -- Both copy and primary have bad pages.	     	     BEGIN	     dataLost ¬ TRUE;	     END;	            IF statusOfCopy ~= goodCompletion OR badPageOfCopy THEN  {-- Replace page          VI.AddToErrorList[	     File.nullID, copy, problem, currentFilePageInIntervalOfCopy];	   IF VI.errorListOverflowed THEN 	     MarkItUnProcessed[tempVolumePageOfCopy]};       IF statusOfPrimary ~= goodCompletion OR badPageOfPrimary THEN {-- Replace page          VI.AddToErrorList[	     File.nullID, primary, problem, currentFilePageInIntervalOfPrimary];	  IF VI.errorListOverflowed THEN 	    MarkItUnProcessed[tempVolumePageOfPrimary]};       currentMemPage ¬ currentMemPage + 1;       currentFilePageInIntervalOfCopy ¬ currentFilePageInIntervalOfCopy + 1;       currentFilePageInIntervalOfPrimary ¬ currentFilePageInIntervalOfPrimary + 1;       ENDLOOP;    END; --ReadParallelAndCorrect--       ---------------------------------------------------------------------------  -- Validate Page  ---------------------------------------------------------------------------      ValidPage: PUBLIC PROCEDURE [      problem: VI.ETableErrorType, currentMemPage: Environment.PageNumber]    RETURNS [BOOLEAN] =          BEGIN            -- Perform a crude syntactical validation of the page.  If not        -- syntactically correct, then return FALSE.	        SELECT problem FROM	           VI.ETableErrorType.badHeaderPage =>	    RETURN[CrudeHeaderValidation[	       LOOPHOLE[Space.LongPointerFromPage[currentMemPage], ET.FileHeaderHandle]]];		   	 VI.ETableErrorType.badFirstPageOfPrimaryETFET, 	 VI.ETableErrorType.badFirstPageOfCopyETFET =>	   RETURN[CrudeETFETValidation[	       LOOPHOLE[Space.LongPointerFromPage[currentMemPage], ET.ETableHandle]]];	              VI.ETableErrorType.badBucketPage => 	    RETURN[CrudeBucketValidation[	       LOOPHOLE[Space.LongPointerFromPage[currentMemPage], ET.BucketHandle]]];			 VI.ETableErrorType.badFirstPageOfOverflow => 	    RETURN[CrudeFirstOverflowPageValidation[	       LOOPHOLE[Space.LongPointerFromPage[currentMemPage], ET.BucketHandle]]];	              ENDCASE => RETURN[TRUE];      END; --Valid Page--           ---------------------------------------------------------------------------  -- VamFind  ---------------------------------------------------------------------------    VamFind: PROCEDURE [vol: LVF.Handle, badPages: BadPageDescriptor] =           -- Finds the first run of consecutive good pages on the volume which is     -- large enough to hold the VAM.  Stores first volume page in the lv root     -- page.  Notice that there can be pages before the VAM which are usable    -- by clients.          -- Notice that there is no check here for VAM being off volume.  Also,     -- the assumption is that the badPageList is sorted is ascending order.          BEGIN    page: Volume.PageNumber ¬ lvPageNumberOfLVRootPage + LVF.rootPageSize;    vamSize: Volume.PageCount ¬ VolAllocMap.PagesForVam[vol.volumeSize];    FOR badPage: CARDINAL IN [0..LENGTH[badPages]) DO      IF badPages[badPage] < lvPageNumberOfLVRootPage THEN LOOP;      -- easier to loop above, then adding in moved rootpage offset to page below      IF badPages[badPage] >= page + vamSize THEN        EXIT      ELSE page ¬ badPages[badPage] + 1;         ENDLOOP;    vol.vamStart ¬ page;    END; --VamFind--          ---------------------------------------------------------------------------  -- VamInit  ---------------------------------------------------------------------------  VamInit: PUBLIC PROCEDURE [    vol: LVF.Handle, badPages: BadPageDescriptor, lvToken: VolTable.LVToken] =        -- Initializes the VAM to free then marks as busy the root page, the VAM     -- pages themselves, and the bad pages. Sets up freePageCount in the     -- root page.        BEGIN    vamEnd: Volume.PageNumber;    VamFind[vol, badPages];  -- sets vol.vamStart    vamEnd ¬ vol.vamStart + VolAllocMap.PagesForVam[vol.volumeSize];    -- CONSIDER: doing a read after write to validate the following I/O    VolAllocMap.SetPageGroup[  -- mark whole vol free      vol, 0, vol.volumeSize, free, ignorePrevSetting, lvToken];    vol.freePageCount ¬ vol.volumeSize;    vol.lowerBound ¬ 0;    VolAllocMap.SetPageGroup[  -- root page is busy.      vol, lvPageNumberOfLVRootPage, LVF.rootPageSize, busy, ignorePrevSetting, lvToken];    VolAllocMap.SetPageGroup[  -- vam is busy.      vol, vol.vamStart, vamEnd - vol.vamStart, busy, ignorePrevSetting,      lvToken];    FOR i: CARDINAL IN [0..LENGTH[badPages]) DO      IF badPages[i] < vol.volumeSize THEN        -- makes sure that pages we are marking as busy are in the proper range	-- (i.e. reside on the volume proper...not on the marker page or past,	-- since this would cause ObjAlloc problems)        VolAllocMap.SetPageGroup[  -- bad pages are busy	  vol, badPages[i], 1, busy, ignorePrevSetting, lvToken];      ENDLOOP;    END;  --VamInit--    ---------------------------------------------------------------------------  -- ValidateETable  ---------------------------------------------------------------------------      ValidateETable: PUBLIC PROCEDURE [lvHandle: LVF.Handle,     lvToken: VolTable.LVToken, currentETable: ET.ETableHandle]      RETURNS [deleted: BOOLEAN ¬ FALSE] =     BEGIN        -- Returns TRUE if another ETable with the same ID has already been    -- processed, if the file is temporary, or if the ETable is syntactically     -- incorrect.  Since every client ETable is passed through this software,      -- also compute largestAllocatedFileID, and set the VAM.    --    -- NOTICE THAT FILE LIST COULD BE KEPT MUCH SMALLER IF HAD FILE ID'S FROM    -- OVERFLOW FIRST.  WOULD THEN ONLY HAVE TO KEEP FILE ID'S PER BUCKET. !!!     --         alreadyInTable, doesNotMakeSense: BOOLEAN;    filePage: File.PageNumber;    volumePage: Volume.PageNumber;    count: LONG CARDINAL;    pilotFile: BOOLEAN;    typeOfProblem: VI.ETableErrorType;    vamEnd: Volume.PageNumber =       lvHandle.vamStart + VolAllocMap.PagesForVam[lvHandle.volumeSize] - 1;    alreadyInTable ¬ doesNotMakeSense ¬ FALSE;    filePage ¬ 0;    -- First, does the ETable seem to make sense (syntactically)? If not,    -- delete it and report it.      FOR i: CARDINAL IN [0..currentETable.header.howManyGroups) DO       BEGIN       smashedPage: File.PageNumber;       start: Volume.PageNumber =         currentETable.pageGroups[i].volumePage;       end: Volume.PageNumber =          currentETable.pageGroups[i].volumePage+currentETable.pageGroups[i].count	 - 1;	        -- firstPVPageOfLV is not updated if marker or root page are moved,       -- but lvPageNumberOfLVRootPage, lvPageNumberOfMarkerPage, and        -- lastPVPageOfLV have been updated.               IF (firstPVPageOfLV + end) > lastPVPageOfLV THEN {	  doesNotMakeSense ¬ TRUE;	  VI.AddToErrorList[File.nullID, both, badETableInBucket, 0];	  EXIT};	        -- Check if rootpage, vam, or marker page moved and smashed any used pages.      -- All this range checking is unnessary if MarkVAMPagesAsBusy/VolAllocMap      -- could tell if pages were used or not. Then all that's needed here is      -- adding entries to errorlist.      -- Note, if the rootpage moves, so does the VAM, so separate it off            typeOfProblem ¬ 	IF (currentETable.header.type IN FileTypes.PilotFileType) 	THEN badPilotPage ELSE badClientPage;      IF (start <= lvPageNumberOfLVRootPage) THEN         BEGIN        count ¬ 	  MIN[lvPageNumberOfLVRootPage-start+1,currentETable.pageGroups[i].count];	smashedPage ¬ filePage;	FOR j: Volume.PageCount IN [0..count) DO  	  VI.AddToErrorList[	    currentETable.header.fileID, both, typeOfProblem, smashedPage+j];		  -- IF errorListFull THEN ???	  ENDLOOP;	END;      count ¬ 0;      SELECT TRUE FROM 	(end >= lvPageNumberOfMarkerPage)  => { -- marker page was moved	  count ¬ end - lvPageNumberOfMarkerPage + 1;	  smashedPage ¬ filePage + currentETable.pageGroups[i].count - count};	(start IN [lvHandle.vamStart..vamEnd]) => { -- VAM moved this way	  FOR temp: Volume.PageNumber IN [start..MIN[end, vamEnd]] DO	    IF temp IN [lvHandle.vamStart..vamEnd] THEN count ¬ count + 1;	  ENDLOOP;	  smashedPage ¬ filePage};	(end IN [lvHandle.vamStart..vamEnd])  => { -- VAM moved that way	  FOR temp: Volume.PageNumber IN	      [MAX[lvHandle.vamStart, start]..end] DO	    IF temp IN [lvHandle.vamStart..vamEnd] THEN count ¬ count + 1;	    ENDLOOP;	  smashedPage ¬  filePage + currentETable.pageGroups[i].count - count}; 	(lvHandle.vamStart IN [start..end]) => { -- VAM moved in the midst	  count ¬ lvHandle.vamStart - vamEnd + 1;	  smashedPage ¬ filePage + lvHandle.vamStart - start };	ENDCASE;		FOR j: Volume.PageCount IN [0..count) DO  	  VI.AddToErrorList[	    currentETable.header.fileID, both, typeOfProblem, smashedPage+j];	  -- IF errorListFull THEN ???	  ENDLOOP;	         -- ANY SUGGESTIONS FOR OTHER TESTS HERE!!!       END;       filePage ¬ filePage + currentETable.pageGroups[i].count;       ENDLOOP;        IF currentETable.header.temporary OR doesNotMakeSense THEN        RETURN[TRUE];    IF VI.AddFileToFileList[currentETable.header.fileID] THEN       RETURN[TRUE];    numberOfFiles ¬ numberOfFiles + 1;    VI.largestAllocatedFileID ¬        MAX[VI.largestAllocatedFileID, LOOPHOLE[currentETable.header.fileID]];    IF currentETable.header.fileID =       FileIDFromNumber[PilotFileTypes.tScavengerLog] THEN        VI.localScavengerLogFileExists ¬ TRUE;         --    -- Make entries in the errorList for file pages which are bad,      -- have lost their data,    -- or have already been allocated by a previously encountered file.  Mark     -- in  VAM as busy all pages in the file. Process one page group at a time.        filePage ¬ 0;    pilotFile ¬ IF currentETable.header.type IN FileTypes.PilotFileType THEN       TRUE ELSE FALSE;    FOR i: CARDINAL IN [0..currentETable.header.howManyGroups) DO       [volumePage, count] ¬ currentETable.pageGroups[i];       UNTIL count = 0 DO 	  IF (VI.IsPageBad[@volumePage, @count]) THEN 	    BEGIN	    typeOfProblem ¬ IF pilotFile THEN badPilotPage ELSE badClientPage;	    VI.AddToErrorList[currentETable.header.fileID, both, typeOfProblem, 	       filePage + currentETable.pageGroups[i].count - count - 1];	    END;	  ENDLOOP;       [volumePage, count] ¬ currentETable.pageGroups[i];       -- better save volumePage cause IsDataOnPageBad updates it.       UNTIL count = 0 DO	  IF (VI.IsDataOnPageBad[@volumePage, @count]) THEN 	     BEGIN	     typeOfProblem ¬ IF pilotFile THEN badPilotData ELSE badClientData;	     VI.AddToErrorList[currentETable.header.fileID, both, typeOfProblem,		filePage + currentETable.pageGroups[i].count - count - 1];	     IF NOT VI.errorListOverflowed THEN 	       MarkItProcessed[volumePage - 1];	     END;	  ENDLOOP;       [volumePage, count] ¬ currentETable.pageGroups[i];       UNTIL count = 0 DO	  IF MarkVAMPagesAsBusy[lvHandle, lvToken, @volumePage, @count] THEN  	     BEGIN	     typeOfProblem ¬ IF pilotFile THEN badPilotPage ELSE badClientPage;	     VI.AddToErrorList[currentETable.header.fileID, both, typeOfProblem,		filePage + currentETable.pageGroups[i].count - count - 1];	     END;	  ENDLOOP;       filePage ¬ filePage + currentETable.pageGroups[i].count;       ENDLOOP;    END; --ValidateETable--      ---------------------------------------------------------------------------  -- WordsToPages  ---------------------------------------------------------------------------  WordsToPages: PROCEDURE [count: LONG CARDINAL]    RETURNS [Space.PageCount] = INLINE    {RETURN[      (count + Environment.wordsPerPage - 1) / Environment.wordsPerPage]};  ---------------------------------------------------------------------------  -- WriteMultipleCopies  ---------------------------------------------------------------------------  WriteMultipleCopies: PUBLIC PROCEDURE [volumePage: Volume.PageNumber,     count: Volume.PageCount, memPage: Environment.PageNumber,     diskChannel: DiskChannel.Handle,     firstPVPageOfLV: PhysicalVolume.PageNumber]    RETURNS [status:disk DiskChannel.IOStatus] =     -- Write the specified page from real memory to disk count times starting at    -- volumePage.    -- Will not work if LV's can span PV's.    BEGIN    ioStatus: DiskChannel.IOStatus;    request: DiskChannel.IORequest;    countValid: File.PageCount;    request ¬ [	diskPage: firstPVPageOfLV + volumePage, memoryPage: memPage, 	useSamePage: TRUE, count: count, command: write, 	tries: DiskChannel.defaultTries];    [ioStatus, countValid] ¬ DiskChannel.DoIO[diskChannel, @request];    WITH diskStatus: ioStatus SELECT FROM       invalidChannel => Bug[invalidChannel];       invalidDriveState => Bug[invalidDriveState];       disk => status ¬ diskStatus;       ENDCASE => Bug[impossibleEndcase];    END; --WriteMultipleCopies--  ---------------------------------------------------------------------------  -- WritePage  ---------------------------------------------------------------------------  WritePage: PUBLIC PROCEDURE [volumePage: Volume.PageNumber,      memPage: Environment.PageNumber, diskChannel: DiskChannel.Handle,     firstPVPageOfLV: PhysicalVolume.PageNumber]    RETURNS [status:disk DiskChannel.IOStatus] =     -- Write the specified page from real memory to disk.        -- Assumes diskChannel previously initialized.    -- MIGHT WANT TO ADD A READ AFTER WRITE CHECK HERE,     -- BUT WILL SLOW DOWN VERIFIER!!!    BEGIN    ioStatus: DiskChannel.IOStatus;    request: DiskChannel.IORequest;    countValid: File.PageCount;    request ¬ [	diskPage: firstPVPageOfLV + volumePage, memoryPage: memPage, 	useSamePage: FALSE, 	count:LONG[1], command: write, 	tries: DiskChannel.defaultTries];    [ioStatus, countValid] ¬ DiskChannel.DoIO[diskChannel, @request];    WITH diskStatus: ioStatus SELECT FROM       invalidChannel => Bug[invalidChannel];       invalidDriveState => Bug[invalidDriveState];       disk => status ¬ diskStatus;       ENDCASE => Bug[impossibleEndcase];    END; --WritePage--  END...LOG12-Mar-87 10:54:08  RRR/RSV  Created file.31-Aug-87 14:13:01  RSV      Fixed AR 11802 about the volume for which a file list is being made for should be allowed to be readOnly. 6-Nov-87  8:44:07  ET	     Export ValidPage.15-Dec-87 10:44:44  ET	     Added badPilotPage and badPilotData so they can be used later to screen from the scavenger log. (AR 12028). Don't raise Bug[logicError] in any Crude* procedures (AR 12437). MakeFileList should use writeWithChangingFlag (vs write) for Voltable access. (AR 12453)10-Jan-88 11:46:55  ET	     Added badETableInBucket logic (AR 11904). Added MarkItProcessed/MarkItUnprocessed. Changed ClearDataLostPageList. (AR 12538). 2-Mar-88 17:49:44  RSV      Fix AR 12836 (VerifierImplB.MakeFileList has a relatively large resident memory space leak).15-Mar-88 11:44:38  RSV      Fix ARs 12933 and 12934 by mucking with VerifyAndCorrectLVRootAndMarkerPages, CreateBadPageList, and VamInit in order to allow moving the marker page in the Verifier.23-Mar-88 16:57:54   1) Fix Erase code so if root page was moved due to bad page, the erase code only erases the right number, not a small negative number. (ET)  2) Fix VamFind to not allocate the VAM over bad pages. (RV) 3) Fix ValidateEtable to handle pages smashed by rootpage, marker page, or VAM moves. Also edit moveRootPage and moveMarkerPage code to update globals pvPageNumberOfLVRootPage, lvPageNumberOfLVRootPage, lvPageNumberOfMarkerPage, and pvPageNumberOfMarkerPage. (ET) 4) Replaced pvPageNumberOfLVRootPage with firstPVPageOfLV when setting pvPageNumberOfMarkerPage, so if root page was moved marker page can still be found. (ET). 5) Fix VamFind to not start VAM over moved root page if bad pages exist only before the rootpage and not in the VAM range. (ET) 6) Changed VamInit to mark busy the root page not page 0. Only a problem if root page was moved. (ET)  7) Fixed VerifyAndCorrectLVRootAndMarkerPages to not use lvPageNumberOfLVRootPage when determining if marker page is bad. (RV)30-Jun-88 10:51:53   RSV      Changed from passing in LONG POINTER TO BOOLEAN instead to just returning the BOOLEAN in ValidateETable and ReadParallelAndCorrect (plus ReadParallelAndCorrect only returns dataLost, not copyUsed anymore).  Changed EraseLV to do ALL assignment instead of FOR loop. 9-Oct-89 10:12:00   KT       Fixed the bug in ValidateETable Procedure, that data lost page dose not clear form Data Lost Table when it exists expect top of file. 4-Mar-92 11:40:01   RSV      Fixed up CrudeHeaderValidation to only bomb out if more than 7000 buckets....also put in checks of the seal and the version in CrudeHeaderValidation.
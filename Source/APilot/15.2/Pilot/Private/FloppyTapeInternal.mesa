-- Copyright (C) 1987, 1988  by Xerox Corporation.  All rights reserved. -- FloppyTapeInternal.mesa           3-Jun-88 11:56:15 by RSVDIRECTORY  Environment USING [bytesPerPage, wordsPerPage],  File USING [Type],  FloppyChannel USING [DiskAddress, Handle, Status],  FloppyDiskFace USING [OperationPtr, Status],  FloppyTape USING [    ByteCount, Drive, FileHandle, FileID, NotifyClientProc, SectorNumber,    VolumeHandle],  FloppyTapeFormat USING [    BadSectorList, BadSectorType, MarkerPage, RootPage],  PilotDiskFace USING [DiskAddress],  Process USING [Ticks],  Space USING [Interval, PageCount],  SpecialFloppyTape USING [BootFilePointer];FloppyTapeInternal: DEFINITIONS   IMPORTS FloppyTapeFormat =  BEGIN  minNumTicks: Process.Ticks = LOOPHOLE[1];  MaxVolumes: CARDINAL = 1;  --?  VolumeDesc: TYPE = LONG POINTER TO VolumeDescObject;  VolumeDescObject: TYPE = RECORD [    drive: FloppyTape.Drive,    open: BOOLEAN,    changeCount: CARDINAL, -- change count at last open    writeProtected: BOOLEAN, -- either physically or logically write protected    fcHandle: FloppyChannel.Handle, -- handle on this instance of the floppytape    size: FloppyTape.ByteCount, -- count of the total bytes on the volume    rootPage: LONG POINTER TO FloppyTapeFormat.RootPage, -- valid only when open    badSectorList: FloppyTapeFormat.BadSectorList, -- valid only when open    cachedFile: CachedFile,    currentPosition: FloppyTape.SectorNumber,    lastEOTonTape: FloppyTape.SectorNumber,    notifyClientOnRetention: FloppyTape.NotifyClientProc,    verifyAfterWrite: BOOLEAN,    sectorsPerStream: FloppyTape.SectorNumber,    verifyBuffer: LONG POINTER,    residentBuffer1: ResidentBufferPtr,   -- allocated only when open    residentBuffer2: ResidentBufferPtr];  -- allocated only when open      volumeDesc: VolumeDesc;  volumeDescLock: MONITORLOCK;  residentBufferSize: CARDINAL = 160; -- in pages  ResidentBuffer: TYPE = ARRAY [0..0) OF WORD;  ResidentBufferPtr: TYPE = LONG ORDERED BASE POINTER TO ResidentBuffer;  buffer:  ResidentBufferPtr;  bufferLock: MONITORLOCK;    verifyBufferSize: CARDINAL = 1;  -- in pages  operationLock: MONITORLOCK;  OperationProc: TYPE = PROCEDURE [];  OperationType: TYPE = {    none,     -- the following are operations which "lock" the drive    changeVolume, erase, format, openVolume, reserveDiagnosticArea, scavenge,    retention,     -- the following are operations which do not "lock" the drive    appendFile, checkBootFile, closeVolume, createInitialMicrocodeFile,    forceOut, forceOutBuffersOnly, getFileAttributes, getNextBadSector,    getBootFiles, getDiskAddress, getNextFile, getVolumeAttributes,    markSectorBad, readFile, rewriteFile, setBootFiles, setRootFile,    setVerifyAfterWrite, writeFile};    myIocb: FloppyDiskFace.OperationPtr;  CachedFile: TYPE = RECORD [    id: FloppyTape.FileID,    da: FloppyChannel.DiskAddress,    size: FloppyTape.ByteCount,    type: File.Type];  -- last file looked at      BadSector: SIGNAL [sector: FloppyTape.SectorNumber];  DiskChanged: ERROR;  InternalIOError: ERROR [countDone: FloppyTape.ByteCount];  AllocIOCB: PROCEDURE [wds: CARDINAL] RETURNS [p: LONG POINTER];  BytesToPages: PROCEDURE [count: LONG CARDINAL] RETURNS [LONG CARDINAL] = INLINE    {RETURN[      (count + Environment.bytesPerPage - 1) / Environment.bytesPerPage]};  CheckBadSectorList: PROCEDURE [    badSectorList: FloppyTapeFormat.BadSectorList, countBadSectors: CARDINAL,    maxSectorAvailable: FloppyTape.SectorNumber];  CheckMarkerPage: PROCEDURE [    markerPage: LONG POINTER TO FloppyTapeFormat.MarkerPage, fileID: FloppyTape.FileID];  CheckRootPage: PROCEDURE [rootPage: LONG POINTER TO FloppyTapeFormat.RootPage];    CloseVolumeInternal: PROCEDURE [];  ConvertDiskAddressToFileID: PROCEDURE [diskAddress: FloppyChannel.DiskAddress]    RETURNS [FloppyTape.FileID] = INLINE    {RETURN[LOOPHOLE[diskAddress, FloppyTape.FileID]]};      ConvertToStreamAddr: PROCEDURE [bootFile: SpecialFloppyTape.BootFilePointer]    RETURNS [streamAddr: PilotDiskFace.DiskAddress];  ConvertFileIDToDiskAddress: PROCEDURE [fileID: FloppyTape.FileID]    RETURNS [FloppyChannel.DiskAddress] = INLINE    {RETURN[LOOPHOLE[fileID, FloppyChannel.DiskAddress]]};  ConvertFileIDToSector: PROCEDURE [fileID: FloppyTape.FileID]    RETURNS [FloppyTape.SectorNumber];  ConvertSectorToFileID: PROCEDURE [sector: FloppyTape.SectorNumber]     RETURNS [FloppyTape.FileID];  CountBadPagesInFile: PROCEDURE [    firstPage: FloppyTape.SectorNumber, logicalSize: FloppyTape.ByteCount]    RETURNS [countBadPages: LONG CARDINAL];  CreateBuffer: PROCEDURE [size: Space.PageCount]    RETURNS [buffer: Space.Interval];  CreateResidentBuffer: PROCEDURE [size: Space.PageCount]    RETURNS [buffer: Space.Interval];  DoOperation: PROCEDURE [ml: LONG POINTER TO MONITORLOCK,    mainLineProc: OperationProc, operation: OperationType];  FilterStatus: PROCEDURE [s: FloppyDiskFace.Status]    RETURNS [status: FloppyChannel.Status];  ForceOutBuffers: PROCEDURE [ml: LONG POINTER TO MONITORLOCK];  FreeIOCB: PROCEDURE [p: LONG POINTER] RETURNS [LONG POINTER];  -- temporary hack for Daybreak Tapes  GetCountDone: PROCEDURE [previousSector: FloppyTape.SectorNumber,    iocb: FloppyDiskFace.OperationPtr]    RETURNS [LONG CARDINAL];    GetFileAttributesEntry: PROCEDURE [    ml: LONG POINTER TO MONITORLOCK, file: FloppyTape.FileHandle]    RETURNS [size: FloppyTape.ByteCount, type: File.Type];  GetRealPosition: PROCEDURE [    pos: FloppyTape.SectorNumber, ml: LONG POINTER TO MONITORLOCK]    RETURNS [FloppyTape.SectorNumber];  GetWriteProtectStatus: PUBLIC PROCEDURE [ml: LONG POINTER TO MONITORLOCK]    RETURNS [writeProtected: BOOLEAN];  InitBadSectors: PROCEDURE[    start: FloppyTape.SectorNumber, type: FloppyTapeFormat.BadSectorType];      IsItABadPageError: PROCEDURE [status: FloppyChannel.Status]     RETURNS [badPage: BOOLEAN];  IsPageBad: PROCEDURE [page: FloppyTape.SectorNumber]    RETURNS [BOOLEAN];  IsPageBadAndType: PROCEDURE [page: FloppyTape.SectorNumber]    RETURNS [badPage: BOOLEAN, type: FloppyTapeFormat.BadSectorType];  MarkBadSectorEntryInternal: PROCEDURE [    type: FloppyTapeFormat.BadSectorType, sector: FloppyTape.SectorNumber];  ReadBadSectorList: PROCEDURE [];  ReadMarkerPage: PROCEDURE [    buffer: LONG POINTER TO FloppyTapeFormat.MarkerPage,    fileID: FloppyTape.FileID];  ReadRootPage: PROCEDURE [];    ReadRootAndBadSectorList: PROCEDURE [];    RealFileIDLoc:PROCEDURE [fileID: FloppyTape.FileID]     RETURNS [da: FloppyChannel.DiskAddress, sector: FloppyTape.SectorNumber];      ReportErrorToClient: PROCEDURE [status: FloppyChannel.Status];  SearchOurBufferForFile: PROCEDURE [fid: FloppyTape.FileID]    RETURNS [size: FloppyTape.ByteCount ¬ 0, type: File.Type];      SetBlock: PROCEDURE [   p: LONG POINTER, length: CARDINAL, value: CARDINAL] = INLINE   {FOR i: CARDINAL IN [0..length) DO (p+i)­ ¬ value ENDLOOP};     ValidateHandle: PROCEDURE [volume: FloppyTape.VolumeHandle];    ValidDrive: PROCEDURE [drive: FloppyTape.Drive] RETURNS [exists: BOOLEAN];    WordsToPages: PROCEDURE [count: LONG CARDINAL] RETURNS [LONG CARDINAL] = INLINE   {RETURN [     (count + Environment.wordsPerPage - 1) / Environment.wordsPerPage]};  WriteBadSectorList: PROCEDURE [];  WriteFloppyTape: PROCEDURE [    buffer: LONG POINTER, address: FloppyChannel.DiskAddress,    count: FloppyTape.ByteCount];  WriteMarkerPage: PROCEDURE [    marker: LONG POINTER TO FloppyTapeFormat.MarkerPage,    fileID: FloppyTape.FileID];  WriteRootPage: PROCEDURE [];  WriteWithSameData: PROCEDURE [    buffer: LONG POINTER, address: FloppyChannel.DiskAddress,    count: FloppyTape.ByteCount];  END...  LOG23-Jan-87 13:28:03  RSV  Created File12-Feb-87 12:14:47  ET	    Changed currentPosition to SectorNumber. Added da to cachedFile. Added volumeDesc. Added ResidentBufferPtr. Took out operationsInProgress. Added some procs. Added ValidateHandle. Added buffer.19-Feb-87 16:49:18  RSV  Added ConvertToStreamAddr.  Changed address in WriteFloppyTape to a FloppyChannel.DiskAddress (from SectorNumber).21-Feb-87 13:24:58  RSV  Added actualVolumes, ValidateHandle, and ValidDrive. 5-Mar-87 20:37:59  ET	 Added myIocb, SearchOurBufferForFile, lastEOTonTape. 4-May-87  9:57:29  RSV  Added ReadRootAndBadSectorList.18-Jun-87 10:50:33  RSV  Deleted IsDriveWriteProtected.  Added notifyClientOnRetention to VolumeDesc.  Added minNumTicks, FreeIOCB, and AllocIOCB.27-Jun-87 15:35:45  RSV  Added GetDeviceHandle. 9-Jul-87 10:54:44  RSV  Added MarkBadSectorEntryInternal.17-Jul-87 11:28:57  RSV  Added DoOperation stuff.23-Jul-87 11:23:56  RSV  Added verifyAfterWrite to VolumeDescObject.16-Sep-87  9:53:02  RSV  Added IsPageBadAndType and GetRealPosition.25-Sep-87 11:18:07  RSV  Added drive to volumeDesc.12-Oct-87 12:22:56  RSV  Deleted GetDeviceHandle and actualVolumes.  Added checkBootFile to OperationType.15-Nov-87 17:31:59  RSV  Added forceOutBuffersOnly.18-Nov-87 23:54:46  RSV  Added sectorsPerStream to VolumeDescObject. 3-Dec-87 21:09:15  RSV  Added verifyBuffer to VolumeDescObject and verifyBufferSize constant.  Added GetWriteProtectStatus. 3-Jun-88 11:56:15  RSV     Added GetCountDone for temporary hack for Daybreak Tape problems resulting from AR 13249 against the Daybreak heads.  Added ReportErrorToClient
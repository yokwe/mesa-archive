-- Copyright (C) 1984, 1985, 1986, 1987, 1988  by Xerox Corporation. All rights-- reserved. -- FileMgr>PhysicalVolumeScavengerImpl.mesa    7-Jan-88 19:23:58 by ET ----------------------------------------------------------------------------------  LIMITING ASSUMPTIONS:--  This scavenger cannot recover from the simultaneous loss of the data in --  both pv root pages or the physical loss (unwritable) of either pv root pages. --------------------------------------------------------------------------------DIRECTORY  DataTransfer USING [DiskStatus],  DiskChannel USING [    Create, defaultTries, DiskPageCount, DoIO, Drive, GetDrive,    GetDriveAttributes, GetPageNumber, Handle, InspectDiskShape, IORequest, IOStatus,    nullDrive, nullHandle],  Environment USING [PageCount, PageNumber, wordsPerPage],  Inline USING [HighHalf],  KernelPhysicalVolume USING [PVHandle],  PhysicalVolume USING [    Error, ErrorType, lastPageNumber, noProblems, PageCount, PageNumber,    RepairType, ScavengerStatus],  PhysicalVolumeFormat USING [    currentVersion, DuplicateHandle, duplicateRootPageSize, Handle,    MarkerID, maxNumberBadPages, maxNumberDataLostPages,    maxSubVols, nullBadPage, PageCount, PageNumber, physicalVolumeLabelLength,    rootPageNumber, rootPageSize, Seal,    SubVolumeDesc],  PilotDiskFace USING [Command, DeviceHandle, GetDriveInfo],  RuntimeInternal USING [Bug],  Space USING [    Allocate, Deallocate, Interval, LongPointerFromPage, PageFromLongPointer,    PageNumber],  System USING [    LocalTimeParameters, nullID, UniversalID, VolumeID],  VM USING [    GetMapUnitAttributes, Interval, MakeResident, MakeSwappable, Map,    nullInterval, PageCount, Unmap];PhysicalVolumeScavengerImpl: MONITOR  IMPORTS    DiskChannel, Inline, PhysicalVolume, PilotDiskFace, RuntimeInternal, Space, VM  EXPORTS KernelPhysicalVolume =  BEGIN   OPEN PVF: PhysicalVolumeFormat;  ----------  -- TYPEs  ----------  PVRoot: TYPE = RECORD [  -- Data about a single page of the PV Descriptor.    pvrStatus: DataTransfer.DiskStatus,    pvrPage: PhysicalVolume.PageNumber];  PVRoots: TYPE = RECORD [  -- Data relevant to the whole PV Descriptor.    mainPVRootPageSelfConsistent, duplicatePVRootPageSelfConsistent,    mainAndDuplicateMutuallyConsistent: BOOLEAN ¬ FALSE,    mainPVRootPagesData: PVF.Handle ¬ NIL,    mainPVRootPagesInterval: VM.Interval ¬ VM.nullInterval,    mainPages: ARRAY [0..rootPagePages) OF PVRoot,    duplicatePVRootPagesData: PVF.DuplicateHandle ¬ NIL,    duplicatePVRootPagesInterval: VM.Interval ¬ VM.nullInterval,    duplicatePages: ARRAY [0..duplicateRootPagePages) OF PVRoot];  TransferCommand: TYPE = {vr, vw};  SubVolumeRange: TYPE = [0..PVF.maxSubVols);  PageAsArray: TYPE = ARRAY [0..Environment.wordsPerPage) OF WORD;  SVDescPtr: TYPE = LONG POINTER TO PVF.SubVolumeDesc;      ----------------  -- Global Data  ----------------    drive: DiskChannel.Drive;  -- Drive being scavenged.  channel: DiskChannel.Handle ¬ DiskChannel.nullHandle;    -- Cache the return status here (set as side effect of various procedures)     scavengerStatus: PhysicalVolume.ScavengerStatus;   -- Global space for use by various procedures. It is used to avoid creating  -- and deleting buffer spaces over and over.    scratchSpace: VM.Interval ¬ VM.nullInterval;  --------------  -- Constants  --------------  goodCompletion: DataTransfer.DiskStatus = [disk[goodCompletion]];  dataVerifyError: DataTransfer.DiskStatus = [disk[dataVerifyError]];  dataCRCError: DataTransfer.DiskStatus = [disk[dataCRCError]];  rootPagePages: CARDINAL = CARDINAL[PVF.rootPageSize];  duplicateRootPagePages: CARDINAL =      CARDINAL[PVF.duplicateRootPageSize];  maxRetries: CARDINAL ¬ 10;  ----------------------  -- Debugging Stuff  ----------------------  BugType: TYPE = {    cantMakeMutuallyConsistent, diskChannelFunny,    impossibleEndcase, makePVConsistentAndReadableFailed};  ----------------------------------------------------------------------------  -- ScavengeWithLock  ----------------------------------------------------------------------------  ScavengeWithLock: PUBLIC ENTRY PROCEDURE [    instance: KernelPhysicalVolume.PVHandle,     repair: PhysicalVolume.RepairType,    okayToConvert: BOOLEAN]  --Not used    RETURNS [status: PhysicalVolume.ScavengerStatus] =    BEGIN ENABLE UNWIND => NULL;    pvRoots: PVRoots;    localError: PhysicalVolume.ErrorType;    mainPVRootPageOK: BOOLEAN;    duplicatePVRootPageOK: BOOLEAN;    pvRootPagesMutuallyConsistent: BOOLEAN;        ----------------------------------------------------------------------------    -- STEP 1:	Initialize the scavenger.    ----------------------------------------------------------------------------    BEGIN ENABLE PhysicalVolume.Error => {localError ¬ error; GO TO PVError};    scratchSpace ¬ Allocate[1];    drive ¬ instance.drive;    channel ¬ DiskChannel.Create[drive];    IF instance.changeCount ~=      DiskChannel.GetDriveAttributes[DiskChannel.GetDrive[channel]].changeCount        THEN ERROR PhysicalVolume.Error[invalidHandle];    [] ¬ DiskChannel.InspectDiskShape[drive, quickReadOnly];  -- See if working.    scavengerStatus ¬ PhysicalVolume.noProblems;        ----------------------------------------------------------------------------    -- STEP 2:	Determine the readability, self-consistency, and mutual     --          consistency of the main and duplicate root pages.  No repairing    --          is done in this step.    ----------------------------------------------------------------------------        mainPVRootPageOK ¬ ReadAndValidateMainPVRootPage[@pvRoots, repair];    duplicatePVRootPageOK ¬        ReadAndValidateDuplicatePVRootPage[@pvRoots, repair];    pvRootPagesMutuallyConsistent ¬ CompareMainAndDuplicatePVRootPages[@pvRoots];        ----------------------------------------------------------------------------    -- STEP 3:	Make the two pv root pages selfconsistent and identical (and     --          therefore mutually consistent).      --     --          This will not be possible if they are both self-inconsistent or     --          if the self-inconsistent one cannot be written.  In this case the     --          disk is (hopefully temporarily) lost.    ----------------------------------------------------------------------------        SELECT TRUE FROM              (mainPVRootPageOK AND duplicatePVRootPageOK AND          pvRootPagesMutuallyConsistent) =>           	  -- If both internal and mutual consistency there is nothing to do.	            NULL;           ~(mainPVRootPageOK OR duplicatePVRootPageOK) =>                  -- If neither page is completely correct, then have a bad disk.          {localError ¬ PhysicalVolume.Error[badDisk]; GO TO PVError};	         repair = checkOnly => 	           -- If repair is both needed and possible, return status to that effect	           {scavengerStatus.internalStructures ¬ damaged; RETURN[scavengerStatus]};	          mainPVRootPageOK =>              -- Main page is good, so copy to duplicate.                 BEGIN          IF WritePage[             pvRoots.duplicatePages[0].pvrPage,           	        pvRoots.mainPVRootPagesInterval.page] ~= goodCompletion THEN 	     {localError ¬ PhysicalVolume.Error[badDisk]; GO TO PVError};          duplicatePVRootPageOK ¬              ReadAndValidateDuplicatePVRootPage[@pvRoots, repair];          IF ~duplicatePVRootPageOK THEN 	     {localError ¬ PhysicalVolume.Error[badDisk]; GO TO PVError};          END;            duplicatePVRootPageOK =>                -- Duplicate page is good, so copy to main.                 BEGIN          IF WritePage[             pvRoots.mainPages[0].pvrPage,  -- write to main with duplicate's info	     pvRoots.duplicatePVRootPagesInterval.page] ~= goodCompletion THEN	     {localError ¬ PhysicalVolume.Error[badDisk]; GO TO PVError};	  mainPVRootPageOK ¬ ReadAndValidateMainPVRootPage[@pvRoots, repair];	  IF ~mainPVRootPageOK THEN 	     {localError ¬ PhysicalVolume.Error[badDisk]; GO TO PVError};          END;              ENDCASE => NULL;	           ----------------------------------------------------------------------------    -- STEP 4:	Confirm that the bad page table is readable. If bad page table     --          is partially/completely unreadable, reset it to empty and try to    --          rewrite it.  Give up if the rewrite fails, because we cannot     --          relocate the bad page table. This step does not try to rediscover     --          the bad pages.     ----------------------------------------------------------------------------           BEGIN     badPageListPage: CARDINAL = 1; -- Should be in PhysicalVolumeFormat    okay: BOOLEAN ¬ TRUE;    plainPVID: System.UniversalID = pvRoots.mainPVRootPagesData.pvID;     FOR i: CARDINAL IN [badPageListPage..rootPagePages) DO       okay ¬ okay AND pvRoots.mainPages[i].pvrStatus = goodCompletion;       ENDLOOP;    IF okay THEN GO TO exitFromCheckBadPageTable;    IF repair = checkOnly THEN       {scavengerStatus.badPageList ¬ damaged; GO TO exitFromCheckBadPageTable};            -- All or part of the bad page table is unreadable.    -- Reset the bad page table to empty and rewrite it.        pvRoots.mainPVRootPagesData.badPageList ¬       ALL[PVF.nullBadPage];    scavengerStatus.badPageList ¬ lost;    pvRoots.mainPVRootPagesData.badPageCount ¬ 0;    pvRoots.duplicatePVRootPagesData.badPageCount ¬ 0;    pvRoots.mainPages[0].pvrStatus ¬       WritePage[           pvRoots.mainPages[0].pvrPage, 	  pvRoots.mainPVRootPagesInterval.page];    pvRoots.duplicatePages[0].pvrStatus ¬       WritePage[	  pvRoots.duplicatePages[0].pvrPage, 	  pvRoots.duplicatePVRootPagesInterval.page];    okay ¬ (pvRoots.mainPages[0].pvrStatus = goodCompletion) AND            (pvRoots.duplicatePages[0].pvrStatus = goodCompletion);    FOR i: CARDINAL IN [badPageListPage..rootPagePages) DO       OPEN bpl: pvRoots.mainPages[i];       bpl.pvrStatus ¬          WritePage[bpl.pvrPage, pvRoots.mainPVRootPagesInterval.page + i];       okay ¬ okay AND bpl.pvrStatus = goodCompletion;       ENDLOOP;    IF ~okay THEN {localError ¬ PhysicalVolume.Error[badDisk]; GO TO PVError};    EXITS       exitFromCheckBadPageTable => NULL;    END;  -- CheckBadPageTable            ----------------------------------------------------------------------------    -- STEP 5:	Check the DataLostTable.    ----------------------------------------------------------------------------        BEGIN     firstDataLostPage: CARDINAL = CARDINAL[pvRoots.duplicatePages[0].pvrPage + 1];    okay: BOOLEAN ¬ TRUE;    -- skip the first root page page since we are want to look at the data list    FOR i: CARDINAL IN [1..duplicateRootPagePages) DO       okay ¬ okay AND pvRoots.duplicatePages[i].pvrStatus = goodCompletion;       ENDLOOP;    -- better make sure the the header doesn't look bogus    okay ¬ okay AND       Inline.HighHalf[       pvRoots.duplicatePVRootPagesData.dataLostPageList.header.countPages] = 0;    IF okay THEN GO TO exitFromCheckDataLostTable;    IF repair = checkOnly THEN       {scavengerStatus.badPageList ¬ damaged; GO TO exitFromCheckDataLostTable};            -- All or part of the datalost table is unreadable.    -- Reset the datalost table to empty and rewrite it.        pvRoots.duplicatePVRootPagesData.dataLostPageList.pages ¬       ALL[PVF.nullBadPage];    pvRoots.duplicatePVRootPagesData.dataLostPageList.header.countPages ¬ 0;    pvRoots.duplicatePVRootPagesData.dataLostPageList.header.maxEntries ¬     PVF.maxNumberDataLostPages;    scavengerStatus.badPageList ¬ lost;    okay ¬ TRUE;    FOR i: CARDINAL IN [1..duplicateRootPagePages) DO       OPEN bpl: pvRoots.duplicatePages[i];       bpl.pvrStatus ¬ WritePage[         bpl.pvrPage, pvRoots.duplicatePVRootPagesInterval.page + i];       okay ¬ okay AND bpl.pvrStatus = goodCompletion;       ENDLOOP;    IF ~okay THEN {localError ¬ PhysicalVolume.Error[badDisk]; GO TO PVError};    EXITS       exitFromCheckDataLostTable => NULL;    END;  -- CheckDataLostTable    ----------------------------------------------------------------------------    -- STEP 6:	Cleanup and exit from the scavenger.    ----------------------------------------------------------------------------        EXITS      PVError =>        BEGIN	TidyUp[@pvRoots];	RETURN WITH ERROR PhysicalVolume.Error[localError];        END;	    END;  -- ENABLE scope        TidyUp[@pvRoots];    RETURN[scavengerStatus];        END;  -- ScavengeWithLock    ----------------------------------------------------------------------------  -- Private Internal Procedures  ----------------------------------------------------------------------------  Allocate: PROCEDURE [count: VM.PageCount] RETURNS [interval: VM.Interval] =    BEGIN    spaceInt: Space.Interval ¬ Space.Allocate[count];    interval.page ¬ Space.PageFromLongPointer[spaceInt.pointer];    interval.count ¬ spaceInt.count;    END;  Bug: PROCEDURE [b: BugType] = {RuntimeInternal.Bug[b]};  BugV: PROCEDURE [b: BugType] RETURNS [UNSPECIFIED] =    {RuntimeInternal.Bug[b]; RETURN[0]};  CompareMainAndDuplicatePVRootPages: PROCEDURE [pvRoots: POINTER TO PVRoots]    RETURNS[pvRootPagesMutuallyConsistent: BOOLEAN] =    BEGIN    OPEN main: pvRoots.mainPVRootPagesData, dup: pvRoots.duplicatePVRootPagesData;    pvRootPagesMutuallyConsistent ¬       main.seal = dup.seal AND        main.version = dup.version AND       main.labelLength = dup.labelLength AND        main.pvID = dup.pvID AND       main.bootingInfo = dup.bootingInfo AND       main.subVolumeCount = dup.subVolumeCount AND       main.subVolumeMarkerID = dup.subVolumeMarkerID AND       main.badPageCount = dup.badPageCount AND       main.maxBadPages = dup.maxBadPages AND       main.dataLostPageCount = dup.dataLostPageCount AND       main.maxDataLostPages = dup.maxDataLostPages AND       main.onLineCount = dup.onLineCount AND        main.fill1 = dup.fill1 AND       main.localTimeParametersValid = dup.localTimeParametersValid AND       main.localTimeParameters = dup.localTimeParameters AND       main.checksum = dup.checksum;    FOR i: CARDINAL IN [0..MIN[      main.labelLength, PhysicalVolumeFormat.physicalVolumeLabelLength]) DO        pvRootPagesMutuallyConsistent ¬ 	  pvRootPagesMutuallyConsistent AND main.label[i] = dup.label[i];      ENDLOOP;         FOR i: CARDINAL IN [0..MIN[      main.subVolumeCount, PhysicalVolumeFormat.maxSubVols]) DO        pvRootPagesMutuallyConsistent ¬ pvRootPagesMutuallyConsistent AND	  main.subVolumes[i] = dup.subVolumes[i];      ENDLOOP;    pvRoots.mainAndDuplicateMutuallyConsistent ¬ pvRootPagesMutuallyConsistent;    END;      GetRidOfSpace: PROCEDURE [interval: VM.Interval] =    BEGIN    IF interval = VM.nullInterval THEN RETURN;    IF IsMapped[interval] THEN [] ¬ VM.Unmap[interval.page];    Space.Deallocate[Space.Interval[      pointer: Space.LongPointerFromPage[interval.page],      count: interval.count]];    END;  IsMapped: PROCEDURE [interval: VM.Interval] RETURNS [mapped: BOOLEAN] =    BEGIN    RETURN [      (VM.GetMapUnitAttributes[interval.page, NIL].mapUnit        ~= VM.nullInterval)]    END;      ReadAndValidateDuplicatePVRootPage: PROCEDURE [    pvRoots: POINTER TO PVRoots, repair: PhysicalVolume.RepairType]     RETURNS [okay: BOOLEAN] =        -- Reads the duplicate PV root page and the bad page list into memory and     -- validates the root page itself.  Note that if the bad page list itself     -- is unreadable, ReadPage is not allowed to rewrite it. In this case we     -- want CheckBadPageTable to write out an empty bad page table.    -- "okay" indicates the absolute correctness of the  duplicate root page.        BEGIN    duplicateRootPageNumber: PVF.PageNumber;    deviceHandle: PilotDiskFace.DeviceHandle ¬      DiskChannel.GetDriveAttributes[drive].deviceHandle;    duplicateRootPageNumber ¬      DiskChannel.GetPageNumber[drive,      PilotDiskFace.GetDriveInfo[deviceHandle].lastPageOfInitialMicrocode] + 1;    pvRoots.duplicatePVRootPagesInterval ¬ Allocate[duplicateRootPagePages];    pvRoots.duplicatePVRootPagesData ¬      Space.LongPointerFromPage[pvRoots.duplicatePVRootPagesInterval.page];    ResidentMap[pvRoots.duplicatePVRootPagesInterval];    FOR i: CARDINAL IN [0..duplicateRootPagePages) DO          -- Must read one page at a time in order to collect all the labels.      -- Try to clear transient read errors through a rewrite on root page only.            pvRoots.duplicatePages[i].pvrPage ¬ duplicateRootPageNumber + i;      pvRoots.duplicatePages[i].pvrStatus ¬ ReadPage[        pvRoots.duplicatePages[i].pvrPage,        pvRoots.duplicatePVRootPagesInterval.page + i,        repair, pvRoots.duplicatePages[i].pvrPage = duplicateRootPageNumber];      ENDLOOP;        -- Now perform validity checks on the duplicate PV root page.        BEGIN OPEN duplicatePVData: pvRoots.duplicatePVRootPagesData;    okay ¬ pvRoots.duplicatePVRootPageSelfConsistent ¬       pvRoots.duplicatePages[0].pvrStatus = goodCompletion AND      pvRoots.duplicatePages[0].pvrPage = duplicateRootPageNumber AND      duplicatePVData.seal = PVF.Seal AND      duplicatePVData.version = PVF.currentVersion AND      duplicatePVData.labelLength IN         [0..PVF.physicalVolumeLabelLength] AND      duplicatePVData.subVolumeCount IN [0..PVF.maxSubVols] AND      duplicatePVData.subVolumeMarkerID # System.nullID AND      duplicatePVData.badPageCount IN          [0..PVF.maxNumberBadPages] AND      duplicatePVData.maxBadPages <= PVF.maxNumberBadPages AND      duplicatePVData.dataLostPageCount IN         [0..PVF.maxNumberDataLostPages] AND      (~duplicatePVData.localTimeParametersValid OR         ValidTimeParms[@duplicatePVData.localTimeParameters]) AND      SubVolumesOkay[LOOPHOLE[pvRoots.duplicatePVRootPagesData]] AND      duplicatePVData.checksum = 0;    END;  -- pvRoots.duplicatePVRootPagesData scope    END;  -- ReadAndValidateDuplicatePVRootPage  ReadAndValidateMainPVRootPage: PROCEDURE [    pvRoots: POINTER TO PVRoots, repair: PhysicalVolume.RepairType]     RETURNS [okay: BOOLEAN] =        -- Reads the PV root page and the bad page list into memory and validates     -- the root page itself.  If the bad page list itself is unreadable,    -- ReadPage is not allowed to rewrite it.  In that case  we want    -- CheckBadPageTable to write out an empty bad page table.    -- "okay" indicates the absolute correctness of the root page.        BEGIN    pvRoots.mainPVRootPagesInterval ¬ Allocate[rootPagePages];    pvRoots.mainPVRootPagesData ¬       Space.LongPointerFromPage[pvRoots.mainPVRootPagesInterval.page];    ResidentMap[pvRoots.mainPVRootPagesInterval];    FOR i: CARDINAL IN [0..rootPagePages) DO                   -- Must read one page at a time in order to collect all the labels.       -- Try to clear transient read errors through a rewrite on root page only.             pvRoots.mainPages[i].pvrPage ¬ PVF.rootPageNumber + i;       pvRoots.mainPages[i].pvrStatus ¬ ReadPage[          pvRoots.mainPages[i].pvrPage, pvRoots.mainPVRootPagesInterval.page + i,          repair, pvRoots.mainPages[i].pvrPage =	     PVF.rootPageNumber];       ENDLOOP;          -- Now perform validity checks on the PV root page.        BEGIN OPEN mainPVData: pvRoots.mainPVRootPagesData;     okay ¬ pvRoots.mainPVRootPageSelfConsistent ¬        pvRoots.mainPages[0].pvrStatus = goodCompletion AND       pvRoots.mainPages[0].pvrPage = PVF.rootPageNumber AND       mainPVData.seal = PVF.Seal AND       mainPVData.version = PVF.currentVersion AND       mainPVData.labelLength IN          [0..PVF.physicalVolumeLabelLength] AND       mainPVData.subVolumeCount IN [0..PVF.maxSubVols] AND       mainPVData.subVolumeMarkerID # System.nullID AND       mainPVData.badPageCount IN [0..PVF.maxNumberBadPages] AND       mainPVData.maxBadPages <= PVF.maxNumberBadPages AND       mainPVData.dataLostPageCount IN          [0..PVF.maxNumberDataLostPages] AND       (~mainPVData.localTimeParametersValid OR          ValidTimeParms[@mainPVData.localTimeParameters]) AND       SubVolumesOkay[pvRoots.mainPVRootPagesData] AND       mainPVData.checksum = 0;    END;  -- mainPVRootPagesData scope    END;  -- ReadAndValidateMainPVRootPage  ReadPage: PROCEDURE [     page: PhysicalVolume.PageNumber, memoryPage: Space.PageNumber,     repair: PhysicalVolume.RepairType, rewriteDesired: BOOLEAN]     RETURNS [status: DataTransfer.DiskStatus] =     BEGIN         -- Tries very hard to read the page.  If repair = safeRepair or     -- riskyRepair and the caller has indicated a rewrite is desired, tries     -- to rewrite the page (whether the read succeeded or not) to clear the     -- flakiness.  If repair = checkOnly, just indicates problem with     -- internal structures to alert the client that repair (at least     -- rewriting) is needed.         status ¬ dataCRCError;  -- just for loop initialization     THROUGH [0..maxRetries) WHILE status # goodCompletion DO        status ¬ TransferPageRun[page, vr, memoryPage, 1].status;       ENDLOOP;     IF status = goodCompletion THEN RETURN;     IF repair = checkOnly THEN        {scavengerStatus.internalStructures ¬ damaged; RETURN};	     -- From here on repair = safeRepair or riskyRepair.          IF rewriteDesired THEN        BEGIN		-- Try to clear transient error by overwriting.	        status ¬ WritePage[page, memoryPage];        	-- Read one more time to see if the write cleared the error and to        -- return a read, not write, status.	              status ¬ TransferPageRun[page, vr, memoryPage, 1].status;          END;     END;  -- ReadPage  ResidentMap: PROCEDURE [at: VM.Interval] = INLINE    BEGIN    VM.Map [      interval: at, transferProc: NIL, backingStoreRuns: NIL,      swapUnits: [unitary[]], life: dead, swappability: resident];    END;  SubVolumeDescOkay: PROCEDURE [    descriptor: LONG POINTER TO PVF.SubVolumeDesc]    RETURNS [okay: BOOLEAN] =        -- This procedure, as far as possible, validates the     -- specified subvolume description.        BEGIN OPEN descriptor;    pvSize: PVF.PageCount =      DiskChannel.GetDriveAttributes[drive].nPages;    okay ¬ lvID ~= System.nullID AND           (lvSize > 0) AND 	   (lvSize >= nPages) AND           (lvPage <= PhysicalVolume.lastPageNumber) AND           (pvPage < pvSize) AND 	   (nPages < pvSize) AND 	   (pvPage + nPages < pvSize);    END;  -- SubVolumeDescOkay  SubVolumesOkay: PROCEDURE [    pvHandle: PVF.Handle]     RETURNS [okay: BOOLEAN] =        -- This procedure, as far as possible, validates the subvolume     -- descriptions in the specified root page.  Both individual and     -- mutual consistency are tested.        BEGIN OPEN pvHandle;    iSubVolEnd, jSubVolEnd: PhysicalVolume.PageNumber;    okay ¬ TRUE;    FOR i: CARDINAL IN [0..MIN[      subVolumeCount, PhysicalVolumeFormat.maxSubVols]) WHILE okay DO      okay ¬ SubVolumeDescOkay[@subVolumes[i]];      iSubVolEnd ¬ subVolumes[i].pvPage + subVolumes[i].nPages;      FOR j: CARDINAL IN [0..i) WHILE okay DO        -- This loop assumes that the SV's in the sv array are in disk order.        OPEN iSVD: subVolumes[i], jSVD: subVolumes[j];	jSubVolEnd ¬ jSVD.pvPage + jSVD.nPages;	okay ¬  -- check for disjointness of subvolumes	  ~(jSVD.pvPage >= iSVD.pvPage AND jSVD.pvPage <= iSubVolEnd) AND	  ~(jSubVolEnd >= iSVD.pvPage AND jSubVolEnd <= iSubVolEnd);	ENDLOOP;      ENDLOOP;    END;  -- SubVolumesOkay  TidyUp: PROCEDURE [    pvRoots: POINTER TO PVRoots] =    BEGIN    channel ¬ DiskChannel.nullHandle;    drive ¬ DiskChannel.nullDrive;    GetRidOfSpace[scratchSpace];    GetRidOfSpace[pvRoots.mainPVRootPagesInterval];    GetRidOfSpace[pvRoots.duplicatePVRootPagesInterval];    END;  -- TidyUp  TransferPageRun: PROCEDURE [    page: PhysicalVolume.PageNumber, command: TransferCommand,    dataBuffer: Space.PageNumber, count: DiskChannel.DiskPageCount]    RETURNS [      countValid: DiskChannel.DiskPageCount, status: DataTransfer.DiskStatus] =    -- Transfers one or more pages.    BEGIN    req: DiskChannel.IORequest;    ioStatus: DiskChannel.IOStatus;    diskCommand: PilotDiskFace.Command;    diskCommand ¬ SELECT command FROM      vw => write,      vr => read,      ENDCASE => BugV[impossibleEndcase];    req ¬ [      command: diskCommand, diskPage: page, memoryPage: dataBuffer,      tries: DiskChannel.defaultTries, count: count];    VM.MakeResident[      interval: [page: dataBuffer, count: count], returnWait: wait];    [ioStatus, countValid] ¬ DiskChannel.DoIO[channel, @req];    VM.MakeSwappable[interval: [page: dataBuffer, count: count]];    WITH ioS: ioStatus SELECT FROM      invalidChannel => ERROR PhysicalVolume.Error[invalidHandle];      invalidDriveState => Bug[diskChannelFunny];      disk => status ¬ ioS;      ENDCASE => Bug[impossibleEndcase];    END;  -- TransferPageRun  ValidTimeParms: PROCEDURE    [parms: LONG POINTER TO System.LocalTimeParameters]    RETURNS [okay: BOOLEAN] =    BEGIN OPEN parms;    okay ¬ zone IN [0..12] AND zoneMinutes IN [0..59] AND      beginDST IN [0..366] AND endDST IN [0..366];    END;  -- ValidTimeParms  WritePage: PROCEDURE [    page: PhysicalVolume.PageNumber, memoryPage: Space.PageNumber]    RETURNS [status: DataTransfer.DiskStatus] =    BEGIN    verifyPage: Space.PageNumber ¬ Allocate[1].page;    verifyData: LONG POINTER TO PageAsArray =      Space.LongPointerFromPage[verifyPage];    suppliedData: LONG POINTER TO PageAsArray =       Space.LongPointerFromPage[memoryPage];    ResidentMap[[verifyPage, 1]];    status ¬ dataVerifyError;  -- set to error just for loop initialization    THROUGH [0..maxRetries) UNTIL status = goodCompletion DO      IF (status ¬ TransferPageRun[ -- write the page	   page, vw, memoryPage, 1].status) = goodCompletion AND	(status ¬ TransferPageRun[  -- read it back into a separate buffer	page, vr, verifyPage, 1].status) = goodCompletion AND	verifyData­ # suppliedData­ THEN status ¬ dataVerifyError;	  -- compare to make sure the write was correct      ENDLOOP;    VM.Unmap[verifyPage];    Space.Deallocate[[pointer: verifyData, count: 1]];    IF scavengerStatus.internalStructures # damaged THEN      scavengerStatus.internalStructures ¬ repaired;      -- reporting unrepaired damage takes priority over reporting repairs    END;  -- WritePage  END.  LOG12-Oct-81 15:27:21	CRF	Created file.30-Oct-81  9:02:02	CRF	Split repair mode into safeRepair and riskyRepair. 3-Nov-81 10:17:57	CRF	Converted to 8.0c interfaces. 9-Nov-81 14:41:05	AWL      	PhysicalVolume.CanNotScavenge => PhysicalVolume.Error[alreadyAsserted]25-Nov-81 17:58:53	CRF	PhysicalVolumeExtras => PhysicalVolume; okay => noProblems; EXPORT	VolumeImplInterface instead of PhysicalVolumeExtras; moved PV online check	to PhysicalVolumeImpl. 6-Dec-81 18:08:30	CRF	Fixed bug in Coerce*Page procs in debugging check at end; turned off	debugging checks; removed code from MakeLVConsistentAndReadable that cut	loose the temp file list file (now handled in LV scavenger). 8-Jan-82 13:56:11	CRF	Coerce*Page procs now set the self-consistent flag to TRUE if debug off.27-Jan-82 11:18:14	CRF	Fixed off-by-one errors in Validate* procs (labelLength & subVolumeCount);	added RubiconVolume hack to allow Rubicon Star volumes on Trinity PV.23-Dec-82 13:12:58	AWL      	Dummy up a Klamath scavenger (always returns okay).26-Feb-83 13:48:51	JXP   	Remove all Logical Volume stuff - make this purely a PV Scavenger. Convert	to the new Klamath interfaces. Add to ReplaceIncorrigibleMarker so that	it can deal with multi-SV LV's on a single PV.22-Mar-83  9:49:13	JXP   	Fix TidyUp so that it only unmaps/deallocates the used intervals. 3-May-83 15:30:09	JXP   	Check the Marker ID when validating PV Root Page. 5-May-83 15:43:29	JXP   	Add SetDriveState to ScavengeWithLock. 5-May-83 17:10:31	JXP   	Move DriveState manipulation to PhysicalVolumeImpl. We assume that the	drive state is channel when we are called.12-May-83 14:33:54	JXP   	Before using markers[i], check that markerData is non-NIL. Unlock the	monitor if we get a PV Error in ScavengeWithLock17-May-83 13:49:03	JXP   	When checking for mutual consistency, check that subvolumeMarkerID in	the PV Root page is actually the ID in the marker page labels.12-Jul-83 10:47:47	JXP   	ScavengeWithLock needs okayToConvert parm.27-Jul-83 10:30:58	JXP   	Start using the okayToConvert parm now passed to ScavengeWithLock. 6-Jan-84 12:57:15	AWL      	Fix up the subvolumeMarkerID if it is wrong, but still	consider the root page to be valid.18-Jan-84 12:17:02	AWL      	Check, and fix, label in bad page list page(s) of the PV root page.	More complete checking of PV root page label.31-Jan-84 17:40:58	CAJ 	Change default start of scan for marker pages to skip PV root page,        remove fill field checks, check for missing marker page when rebuilding        PV root page, ensure up-to-date drive attributes in ScavengeWithLock,	more checking of subvolume descriptors.15-Jan-85 12:33:27	CJS    	ScanForMarkers calls PilotDiskFaceExtras.GetDriveInfo rather than using        FormatPilotDisk constants.   9-Jul-86 14:30:35      RSV        Changed maxBadPages to maxNumberBadPages.  Added duplicate PV root page        things to PVRoots type, and to procedures CollectPVPages.  Numerous         changes to get rid of references to labels.  Changed to reflect new 	PilotDiskFace.Command structure.  Changed PVRootPageOkay and 	DuplicatePVRootPageOkay to not return onlySVIDWrong.29-Sep-86 15:56:21      RSV        Added things in CoercePVMarkerPage, CompareMainAndDuplicatePVRootPages,        MutualConsistencyCheck, ValidateDuplicatePVRootPage, ValidatePVMarkerPage,        and ValidatePVRootPage to support dataLostPageCount and maxDataLostPages 	in PV root pages and marker pages.  SOMETHING STILL NEEDS TO BE DONE        ABOUT REBUILDING THE DataLostTable IF IT IS DAMAGED.15-Dec-86 15:12:59      RSV        Deleted PVF.duplicateRootPageNumber.  Instead get it from         PilotDiskFace.GetDriveInfo.26-Jan-87 19:22:15      RSV        Changed ReplaceIncorrigibleMarker to not do multiple SV's per LV.  Also        changed it to update duplicate PV root page.  Added DELETE comments to do 	later.  Don't check PVF.maxNumberDataLostPages against various things. 12-Mar-87 10:46:29      RRR           Rearranged, simplified,  and cleaned up code to work properly with         duplicate PV root pages.19-Mar-87 19:38:43      RRR        Unknown changes.19-Nov-87 15:47:11      RSV        in FOR loops make sure we don't go out of range of possible values.16-Dec-87 18:01:08      RSV        RETURN[scavengerStatus] in catchphrase in ScavengeWithLock instead of just RETURN. 7-Jan-88 19:23:52	ET	Filled in STEP 5 - Repair of datalost table.
-- Copyright (C) 1984, 1985, 1986, 1987  by Xerox Corporation. All rights reserved. -- FileBasics>DiskBackingStoreImpl.mesa   15-Jan-87  0:16:12 by ET -- This module implements a backing store based on disk channels.-- From the VM Fun Spec: ... a TransferProc itself is not allowed to cause any page faults while performing the requested I/O. If any monitor locks are required for the TransferProc to do its job, all code executed within those monitors must also not cause page faults. The restriction of not causing any page faults severely limits the Mesa and Pilot facilities which can be used.-- PACKAGING CONSIDERATIONS: Transfer, and all code that it calls, and all code executed inside the monitor, must be resident.DIRECTORY  BackingStore USING [Operation, TransferProc, TransferData],  DiskBackingStore USING [ChannelHandle, Data, PDiskDataFromPBSData, Result],  DiskChannel USING [    defaultTries, DiskPageCount, DiskPageNumber, DoIO, Drive, GetDrive,    GetDriveAttributes, goodCompletion, Handle, IORequest, IORequestHandle,    IOStatus, nullHandle],  Environment USING [Base, first64K, PageCount, PageNumber],  File USING [PageCount],  FileBasicsPrograms USING [],  Inline USING [DIVMOD, HighHalf, LongDivMod, LowHalf],  PhysicalVolume USING [PageNumber],  PilotDiskFace USING [Command, Status],  Process USING [DisableAborts, DisableTimeout],  ResidentHeap USING [FreeNode, MakeNode],  Runtime USING [CallDebugger],  RuntimeInternal USING [Bug],  SpecialFile USING [],  VM USING [],  Zone USING [Status];DiskBackingStoreImpl: MONITOR  IMPORTS    DiskBackingStore, DiskChannel, Inline, Process, ResidentHeap,    Runtime, RuntimeInternal  EXPORTS DiskBackingStore, FileBasicsPrograms, SpecialFile =  BEGIN  --~~~~~~~~~~ PARAMETERS:  numberOfErrorRecords: CARDINAL = 2;  -- Number of recoverable disk errors which can be processes in parallel by   -- helper processes. We just need a small number, given the paucity of  -- disk errors.  enoughErrorRecords: BOOLEAN [TRUE..TRUE] = (numberOfErrorRecords >= 2);  -- A minimum of two error records are required, one for a primary disk  -- error, and one temporarily used by Restart while trying to repair it.  numberOfHandlesInGlobalFrame: CARDINAL = 4;  -- Number of disk backing store channel handles that are kept in the global  -- frame (rather than in the resident heap). This module is written so that  -- the channel handles in the range [0.. numberOfHandlesInGlobalFrame) are   -- accessed more efficently than the others. Four is a good number since  -- four is the maximum number of drives currently supported by Pilot. See  -- the description of the disk channel table immediately following.  --~~~~~~~~~~ Types and variables for disk channel table:  -- The disk channel table is the vector which translates from  -- DiskChannel.Handles to DiskBackingStore.ChannelHandles. The table  -- is stored in two pieces:  --  --   handleArray: For values of DiskBackingStore.ChannelHandle <  --     numberOfHandlesInGlobalFrame, handleArray[DiskBackingStore.ChannelHandle]  --     is the corresponding DiskChannel.Handle if the channelHandle is in use,   --     and DiskChannel.nullHandle if the channelHandle is free.  --  --   ChannelRecord, handleList: If more than  --     numberOfHandlesInGlobalFrame are allocated, the conversion information  --     is stored in the resident heap as a singly-linked list in ascending   --     ChannelHandle order.  ChannelRecord: TYPE = RECORD [    channelHandle: DiskBackingStore.ChannelHandle,    diskChannel: DiskChannel.Handle,    next: PChanRec];  HandleArrayIndex: TYPE = DiskBackingStore.ChannelHandle[    0..numberOfHandlesInGlobalFrame);    handleArray: ARRAY HandleArrayIndex OF DiskChannel.Handle ¬ ALL[    DiskChannel.nullHandle];  PChanRec: TYPE = LONG POINTER TO ChannelRecord;  handleList: PChanRec ¬ NIL;  --~~~~~~~~~~ Error recovery types and variables:  -- These items implement a simple "numberOfErrorRecords-slot" buffer  ErrorRecord: TYPE = RECORD [    errStatus: {recordFree, awaitingProcessing, beingProcessed, repaired},    op: DiskChannel.IORequest,    diskStatus: PilotDiskFace.Status,    data: PTransferData];  errorRecord: ARRAY ErrorIndex OF ErrorRecord;  ErrorIndex: TYPE = [0..numberOfErrorRecords);  countHelperProcesses: CARDINAL ¬ 0;  -- number of processes which have registered with RegisterErrorProcess  recordFree, awaitingProcessing, repaired: CONDITION;  --~~~~~~~~~~ Other types and defs:  InvalidChannelHandle: PUBLIC ERROR = CODE;  TooManyChannels: PUBLIC ERROR = CODE;  PTransferData: TYPE =  -- (not readonly per AR 12396)    LONG POINTER TO --READONLY-- BackingStore.TransferData;  base: Environment.Base = Environment.first64K;  -- for allocation out of the resident heap  BugType: TYPE = {    funnyCase, invalidChannel, invalidChannelHandle, invalidDriveState,    invalidTransferData, noHelperProcesses, noSuchOperationInProgress,    pointerDomainError, residentHeapError, awaitWithNoHelperProcesses};  Result: TYPE = DiskBackingStore.Result;  --~~~~~~~~~~ Initialization:  InitDiskBackingStore: PUBLIC --FileBasicsPrograms.-- PROCEDURE[] =    BEGIN    FOR e: ErrorIndex IN ErrorIndex DO      errorRecord[e].errStatus ¬ recordFree; ENDLOOP;    Process.DisableAborts[@awaitingProcessing];    Process.DisableTimeout[@awaitingProcessing];    Process.DisableAborts[@repaired];    Process.DisableTimeout[@repaired];    Process.DisableAborts[@recordFree];    Process.DisableTimeout[@recordFree];    END;  --~~~~~~~~~~ PUBLIC Procedures:  AwaitError: PUBLIC ENTRY PROCEDURE    RETURNS [      op: DiskChannel.IORequest, status: PilotDiskFace.Status,      transData: LONG POINTER TO --READONLY-- BackingStore.TransferData] =    BEGIN    IF countHelperProcesses = 0 THEN Bug[awaitWithNoHelperProcesses];    DO  --UNTIL got an error--      FOR e: ErrorIndex IN ErrorIndex DO        entry: LONG POINTER TO ErrorRecord = @errorRecord[e];        --UNTIL--        IF entry.errStatus = awaitingProcessing THEN {          RETURN[entry.op, entry.diskStatus, entry.data]};        ENDLOOP;      WAIT awaitingProcessing;      ENDLOOP;    END;  --AwaitError--  GetDiskChannel: PUBLIC PROCEDURE [channel: DiskBackingStore.ChannelHandle]    RETURNS [channelHandle: DiskChannel.Handle] = {    result: Result;    [result, channelHandle] ¬ GetDiskChannelInternal[channel];    IF result = error THEN ERROR InvalidChannelHandle};  RegisterChannel: PUBLIC ENTRY PROCEDURE [channel: DiskChannel.Handle]    RETURNS [channelHandle: DiskBackingStore.ChannelHandle] =    BEGIN    -- Try to allocate a ChannelHandle out of the global frame    FOR channelHandle IN HandleArrayIndex DO      IF handleArray[channelHandle] = DiskChannel.nullHandle THEN {        handleArray[channelHandle] ¬ channel; RETURN[channelHandle]}      ENDLOOP;    IF handleList = NIL OR handleList.channelHandle > numberOfHandlesInGlobalFrame      --      -- We can allocate a channel handle between the last one in the global      -- frame and the first one in the resident heap      THEN      BEGIN      handleList ¬ NewChannelRecord[  -- Allocate the first record in handleList.        (channelHandle ¬ numberOfHandlesInGlobalFrame), channel, handleList];      RETURN;      END;    -- Go down the linked list looking for unused channel handles:    FOR ch: PChanRec ¬ handleList, ch.next UNTIL ch.next = NIL DO      IF ch.next.channelHandle > SUCC[ch.channelHandle] THEN {        ch.next ¬ NewChannelRecord[          (channelHandle ¬ SUCC[ch.channelHandle]), channel, ch.next];        RETURN};      REPEAT        FINISHED =>          -- No unused channel handles in interior of list.          IF ch.channelHandle < LAST[DiskBackingStore.ChannelHandle] THEN            BEGIN            --ASSERT: ch.next = NIL.            ch.next ¬ NewChannelRecord[              (channelHandle ¬ SUCC[ch.channelHandle]), channel, --NIL-- ch.next];            -- (Using ch.next instead of NIL allows cross jumping to share the code.)            RETURN;            END          ELSE  -- No room at the end, we've run out of handles...            RETURN WITH ERROR TooManyChannels;      ENDLOOP;    END;  RegisterErrorProcess: PUBLIC ENTRY PROCEDURE = {    countHelperProcesses ¬ SUCC[countHelperProcesses]};  ReleaseHandle: PUBLIC ENTRY PROCEDURE [    channelHandle: DiskBackingStore.ChannelHandle] =    BEGIN    IF channelHandle IN HandleArrayIndex THEN      handleArray[channelHandle] ¬ DiskChannel.nullHandle    ELSE      BEGIN      rp: Environment.Base RELATIVE POINTER TO ChannelRecord;      prev, rec: PChanRec;      result: Result;      [result: result, prev: prev, rec: rec] ¬ GetHandleRec[channelHandle];      IF result = error THEN RETURN WITH ERROR InvalidChannelHandle;      IF prev = NIL THEN handleList ¬ rec.next ELSE prev.next ¬ rec.next;      IF Inline.HighHalf[rec - base] # 0 THEN Bug[pointerDomainError]      ELSE rp ¬ LOOPHOLE[Inline.LowHalf[rec - base]];      IF ResidentHeap.FreeNode[rp] # okay THEN Bug[residentHeapError];      END;    END;  RemoveErrorProcess: PUBLIC ENTRY PROCEDURE = {    IF countHelperProcesses # 0 THEN      countHelperProcesses ¬ PRED[countHelperProcesses]    ELSE Bug[noHelperProcesses]};  ReportErrorToDebugger: PUBLIC --EXTERNAL-- PROCEDURE [    channel: DiskChannel.Handle, request: DiskChannel.IORequestHandle,    countValid: File.PageCount, status: PilotDiskFace.Status] =    BEGIN    message: STRING ¬ "Unrecoverable disk error on RDX (Drive X), page XXXXXXXX"L;        DoN: PROCEDURE [num, other, start, n: CARDINAL] =      BEGIN      -- Plugs number into specified place in message.      dig: CARDINAL;      FOR i: CARDINAL IN [start..start + n) DO        [num, dig] ¬ Inline.DIVMOD[num, 10];        message[message.length - i] ¬          IF dig = 0 AND num = 0 AND other = 0 THEN '  ELSE '0 + dig;        ENDLOOP;      END;    diskPage: DiskChannel.DiskPageNumber ¬ request.diskPage + countValid;    driveOrdinal: CARDINAL ¬ DiskChannel.GetDriveAttributes[      DiskChannel.GetDrive[channel]].deviceOrdinal;    ignoreError: BOOLEAN;    left, right: CARDINAL;    posDrive: CARDINAL = 17;  -- rightmost char position, counting from end    posRDX: CARDINAL = 26;  -- rightmost char position, counting from end        -- THIS ASSUMES driveOrdinal IS SINGLE-DIGIT. PRINTS TRASH IF NOT.    message[message.length - posRDX] ¬ '0 + driveOrdinal;    message[message.length - posDrive] ¬ '1 + driveOrdinal;    [left, right] ¬ Inline.LongDivMod[diskPage, 10000];    DoN[num: right, other: left, start: 1, n: 4];    DoN[num: left, other: 0, start: 5, n: 4];    IF diskPage = 0 THEN message[message.length - 1] ¬ '0;    ignoreError ¬ FALSE;    UNTIL ignoreError DO      Runtime.CallDebugger[message];      -- If you wish to ignore the error (usually a poor idea), set      -- ignoreError ¬ TRUE from the debugger, and proceed. If you do so,      -- you are entirely responsible for whatever happens subsequently      -- to your workstation. Don't call us about what happens!      -- THE BEST THING TO DO IS TO GET YOUR DISK FIXED!      ENDLOOP;    END;  --ReportErrorToDebugger--  Restart: PUBLIC ENTRY PROCEDURE [    transData: LONG POINTER TO --READONLY-- BackingStore.TransferData]    RETURNS [      result: DiskBackingStore.Result, op: DiskChannel.IORequest,      status: PilotDiskFace.Status] =    BEGIN    transferResult: Result;    pErrorRecord: LONG POINTER TO ErrorRecord;    [transferResult, pErrorRecord] ¬ TransferInternal[transData];    SELECT transferResult FROM      ok =>        BEGIN        FOR e: ErrorIndex IN ErrorIndex DO          --UNTIL--          IF errorRecord[e].errStatus = awaitingProcessing            AND errorRecord[e].data.pageBuffer = transData.pageBuffer THEN            BEGIN            errorRecord[e].errStatus ¬ repaired;            BROADCAST repaired;            RETURN[ok, NULL, NULL];            END;          REPEAT FINISHED => Bug[noSuchOperationInProgress];          ENDLOOP;        END;      error => {        pErrorRecord.errStatus ¬ recordFree;        NOTIFY recordFree;        RETURN[          error, pErrorRecord.op, pErrorRecord.diskStatus]};      ENDCASE => Bug[funnyCase];    END;  --Restart--  Transfer: PUBLIC BackingStore.TransferProc --[transData] RETURNS [result]--  =    BEGIN    transferResult: Result;    pErrorRecord: LONG POINTER TO ErrorRecord;    [transferResult, pErrorRecord] ¬ TransferInternal[transData];    IF transferResult = error THEN AwaitErrorRepaired[pErrorRecord];    RETURN[[done[]]];    END;  --Transfer--  --~~~~~~~~~~~~ PRIVATE Procedures:  AwaitErrorRepaired: ENTRY PROCEDURE [pErrorRecord: LONG POINTER TO ErrorRecord] =    INLINE    BEGIN    UNTIL pErrorRecord.errStatus = repaired DO WAIT repaired; ENDLOOP;    pErrorRecord.errStatus ¬ recordFree;    NOTIFY recordFree;    END;  Bug: PROCEDURE [type: BugType] = INLINE {RuntimeInternal.Bug[type]};  GetDiskChannelInternal: ENTRY PROCEDURE [    channelHandle: DiskBackingStore.ChannelHandle]    RETURNS [result: Result, diskChannel: DiskChannel.Handle] =    -- result = error means invalid handle.    BEGIN    IF channelHandle IN HandleArrayIndex THEN {      diskChannel ¬ handleArray[channelHandle];      result ¬ (IF diskChannel = DiskChannel.nullHandle THEN error ELSE ok);      RETURN}    ELSE {      rec: PChanRec;      [result: result, rec: rec] ¬ GetHandleRec[channelHandle];      IF result = ok THEN diskChannel ¬ rec.diskChannel;  -- else garbage.      RETURN};    END;  GetHandleRec: INTERNAL PROCEDURE [c: DiskBackingStore.ChannelHandle]    RETURNS [result: Result, prev, rec: PChanRec] =    -- result = error means invalid handle.    BEGIN    IF handleList = NIL THEN RETURN[result: error, prev: NULL, rec: NULL];    IF handleList.channelHandle = c THEN      RETURN[result: ok, prev: NIL, rec: handleList];    FOR prev ¬ handleList, prev.next UNTIL prev.next = NIL DO      IF prev.next.channelHandle = c THEN        RETURN[result: ok, prev: prev, rec: prev.next];      REPEAT FINISHED => RETURN[result: error, prev: NULL, rec: NULL];      ENDLOOP;    END;  HandleError: ENTRY PROCEDURE [    channel: DiskChannel.Handle, iorh: DiskChannel.IORequestHandle,    transferData: PTransferData, countDone: DiskChannel.DiskPageCount,    status: DiskChannel.IOStatus]    RETURNS [pErrRec: LONG POINTER TO ErrorRecord] = INLINE    -- Returns NIL if operator said to ignore the error.    BEGIN    pErrRec ¬ NIL;  -- keep compiler happy.    WITH boundStatus: status SELECT FROM      invalidDriveState => Bug[invalidDriveState];      invalidChannel => Bug[invalidChannel];      disk =>        IF countHelperProcesses = 0 THEN          ReportErrorToDebugger[channel, iorh, countDone, boundStatus.status]        ELSE          BEGIN          DO  --UNTIL error record free--            FOR e: ErrorIndex IN ErrorIndex DO              --UNTIL--              IF errorRecord[e].errStatus = recordFree THEN                BEGIN                errorRecord[e] ¬ [                  errStatus: awaitingProcessing, op: iorh­,                  diskStatus: boundStatus.status, data: transferData];                NOTIFY awaitingProcessing;                RETURN[@errorRecord[e]];                END;              ENDLOOP;            WAIT recordFree;            ENDLOOP;          END;      ENDCASE => Bug[funnyCase];    END;  --HandleError--  NewChannelRecord: INTERNAL PROCEDURE [    c: DiskBackingStore.ChannelHandle, d: DiskChannel.Handle, next: PChanRec]    RETURNS [new: PChanRec] =    BEGIN    status: Zone.Status;    rp: Environment.Base RELATIVE POINTER TO ChannelRecord;    [rp, status] ¬ ResidentHeap.MakeNode[SIZE[ChannelRecord]];    IF status ~= okay THEN Bug[residentHeapError];    new ¬ @base[rp];    new­ ¬ [channelHandle: c, diskChannel: d, next: next];    RETURN[new];    END;  TransferInternal: PROCEDURE [transferData: PTransferData]    RETURNS [result: Result, pErrorRecord: LONG POINTER TO ErrorRecord] =    BEGIN    status: DiskChannel.IOStatus;    countDone: DiskChannel.DiskPageCount;    diskChannel: DiskChannel.Handle;    ioRequest: DiskChannel.IORequest;    pData: LONG POINTER TO DiskBackingStore.Data =      DiskBackingStore.PDiskDataFromPBSData[@transferData.data];    command: PilotDiskFace.Command;    SELECT transferData.operation FROM      read => command ¬ read;      write => command ¬ write;      ENDCASE => Bug[funnyCase];    ioRequest ¬ [      command: command, diskPage: pData.volumePage + transferData.offsetFromData,      memoryPage: transferData.pageBuffer, tries: DiskChannel.defaultTries,      useSamePage: FALSE, count: transferData.countBuffer];    [result, diskChannel] ¬ GetDiskChannelInternal[pData.channelHandle];    IF result = error THEN Bug[invalidChannelHandle];    [status, countDone] ¬ DiskChannel.DoIO[diskChannel, @ioRequest];    pErrorRecord ¬ NIL;  -- assume no error..    IF status # DiskChannel.goodCompletion THEN      pErrorRecord ¬ HandleError[        diskChannel, @ioRequest, transferData, countDone, status];    result ¬ (IF pErrorRecord = NIL THEN ok ELSE error);    END;  END.LOG29-Jun-82 15:56:01   KAM     	Created file.26-Jul-82 16:43:40   KAM     	Fixed bug in AwaitError and added documentation.13-Sep-82 16:36:57   WDK        Make compatible with new BackingStore - passing things by reference.   Remove errors from inside entry procs. Significant rework.20-Oct-82 16:12:43   WDK        TransferInternal didn't adjust label for non-first page of run.21-Oct-82  8:45:15   WDK        TransferInternal set wrong label.temporary for non-first page of run.27-Oct-82 17:10:33   WDK     	Remove READONLY per AR 12396.15-Dec-82 12:01:16   JXP      Export FileBasicsPrograms not FilerPrograms. InitializeDBS[] => InitDBS[].   Update label stuff for no immutable and zeroSize fields.22-Dec-82  9:40:34   AWL         Export Initialization code to FileBasicsPrograms.28-Apr-83 14:26:18   JXP      When a label verify error occurs on page 0 of a file, invert the temporary bit   and try again.22-Jun-83 17:39:24   WDK     	ReportErrorToDebugger becomes public. 4-Jan-84 15:57:29   AWL         Export Transfer to SpecialFile. 5-Apr-85 14:54:03 18:11:41   CAJ    Unrecoverable disk error now reports drive number as well as page in error.17-May-85 17:27:25   CAJ    Add drive number and page in error to Disk label check.14-May-86 22:58:03   CAJ    Unrecoverable disk error, Disk label check messages now say "RDX (Drive Y)". 4-Aug-86  9:57:20   RSV   Changed ErrorRecrod definition, deleted labelVerifyError status, changed to reflect new PilotDiskFace.Command type, changed AwaitError to not take in a label, changed ReportErrorToDebugger to not give label verify error message, changed Restart to not use a label, changed HandleError to set up errorRecord properly, and changed TransferInternal to be labeless.27-Oct-86 14:05:02   RSV   Don't import ETable (why import it in the first place?).15-Jan-87  0:16:24   ET  mds relief: change POINTER to global variable to LONG POINTER to global variable.
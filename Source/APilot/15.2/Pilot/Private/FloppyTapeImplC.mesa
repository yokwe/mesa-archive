-- Copyright (C) 1986, 1987, 1988 by Xerox Corporation. All rights reserved. -- FloppyTapeImplC.mesa       27-Dec-88 15:38:44 RSVDIRECTORY  Environment USING [    Byte, bytesPerPage, bytesPerWord, PageCount, PageFromLongPointer,    wordsPerPage],  Inline USING [LongCOPY, LongMult, LowByte],  File USING [Type],  FloppyChannel USING [    Attributes, DiskAddress, Error, GetDeviceAttributes, Handle, GetHandle, Nop,    nullHandle, SetContext, Status],  FloppyDiskFace USING [    DeviceHandle, DiskAddress, OperationPtr, operationBlockLength,    Status, SuggestedTries],  FloppyTape USING [    ByteCount, ByteOffset, localDrive, Drive, Error, ErrorType, FileID,     FileHandle, IOError, nullSectorNumber, ScatteredVM, SectorNumber,    VolumeHandle],  FloppyTapeFormat USING [    BadSectorList, BadSectorType, DiskAddressToSector,     firstDiagnosticCylinder, floppyTapeContext, MarkerSeal, MarkerPageVersion,    MarkerPageSize, MarkerPage, maxNumberBadSectors, PackBadSectorNumber,     rootPageSector, SectorToDiskAddress, UnpackBadSectorNumber],  FloppyTapeInternal USING [    AllocIOCB, BytesToPages, CachedFile, CheckBadSectorList, CheckRootPage,     ConvertFileIDToSector, ConvertSectorToFileID, CloseVolumeInternal,    DiskChanged, DoOperation, FreeIOCB, GetCountDone, GetFileAttributesEntry,    InternalIOError, minNumTicks, operationLock, OperationProc,    ReadMarkerPage, ReadRootAndBadSectorList, RealFileIDLoc,    ReportErrorToClient, residentBufferSize, ResidentBufferPtr, ValidDrive,    ValidateHandle, volumeDesc, volumeDescLock, WordsToPages, WriteBadSectorList,    WriteMarkerPage, WriteRootPage],  Process USING [Detach, Pause, priorityForeground, SetPriority],  RuntimeInternal USING [Bug],  Space USING [Error, ScratchMap, Unmap],  SpecialFloppyChannel USING [DoDirectIO],  SpecialFloppyChannelExtras USING [GetDeviceHandle, Retention],  SpecialFloppyTape USING [],  SpecialFloppyTapeFace USING [GetTapeParameters],  System USING [GetGreenwichMeanTime],  VM USING [MakeResident, MakeSwappable];FloppyTapeImplC: MONITOR LOCKS ml USING ml: LONG POINTER TO MONITORLOCK  IMPORTS    Environment, FloppyChannel, FloppyDiskFace, FloppyTape, FloppyTapeFormat,     FloppyTapeInternal, Inline, Process, RuntimeInternal,     Space, SpecialFloppyChannel, SpecialFloppyChannelExtras,     SpecialFloppyTapeFace, System, VM  EXPORTS FloppyTape, FloppyTapeInternal, SpecialFloppyTape =    BEGIN     «WHAT'S LEFT TO DO?    1) Want warning when BadSectorTableFull.»    -- globals --    -- temporary globals for not getting large runs of bad pages  lastConsecutiveBadPage: FloppyTape.SectorNumber ¬ FloppyTape.nullSectorNumber;  countConsecutiveBadPages: CARDINAL ¬ 0;  maxConsecutiveBadPages: CARDINAL = 6;  bufferLock: PUBLIC -- FloppyTapeInternal -- MONITORLOCK;  --locks buffer     buffer: PUBLIC -- FloppyTapeInternal -- FloppyTapeInternal.ResidentBufferPtr;   -- buffer is set by OpenVolume  bufferIndex: CARDINAL ¬ nullBufferIndex;  nullBufferIndex: CARDINAL = 0;  numberOfBuffers: CARDINAL = 2;  OpType: TYPE = {read, write, verify, spare};    myIocb: PUBLIC FloppyDiskFace.OperationPtr;    markerByteSize: CARDINAL =     FloppyTapeFormat.MarkerPageSize*Environment.bytesPerWord;  markerPageSize: CARDINAL =    CARDINAL[FloppyTapeInternal.WordsToPages[FloppyTapeFormat.MarkerPageSize]];      SectorCount: TYPE = Environment.PageCount;  ShortSectorCount: TYPE = CARDINAL; -- FloppyChannel takes < CARDINAL counts   WordArray: TYPE =       LONG POINTER TO ARRAY [0..Environment.wordsPerPage) OF CARDINAL;      -- private types and variables for DoAsyncIO and DoAsyncIOHelperProcess      ioLock: MONITORLOCK;  --locks currentMsg  msgQueueEmpty: CONDITION;  newMessage: CONDITION;  currentMsg: Message ¬ [    inuse: FALSE, countRequested: 0, buffer: NIL, countDone: 0,    badTape: FALSE, result: okay[]];      MessagePtr: TYPE = LONG POINTER TO Message;  Message: TYPE = RECORD [    inuse: BOOLEAN ¬ FALSE,    countRequested: ShortSectorCount,    buffer: LONG POINTER,    countDone: ShortSectorCount,    badTape: BOOLEAN,    result:        SELECT resultTag:* FROM        error => [errorType: FloppyChannel.Status],        inProgress => NULL,        okay => NULL,        ENDCASE];	    MissingPages: SIGNAL [    firstHole: FloppyTape.SectorNumber, howManyHoles: CARDINAL] = CODE;  HoleInFile: SIGNAL [firstHole: FloppyTape.SectorNumber] = CODE;    BugType: TYPE = {impossibleEndcase, unexpectedErrorStatus};      -- Procedures --    AppendFile: PUBLIC PROCEDURE [    file: FloppyTape.FileHandle, scatteredVM: FloppyTape.ScatteredVM,    updateEndOfFile: BOOLEAN] =    BEGIN    savedError: FloppyTape.ErrorType;    lastFile: BOOLEAN;    numOfSectors: SectorCount;    scatteredCount: FloppyTape.ByteCount ¬ 0;    size: FloppyTape.ByteCount;    found: BOOLEAN ¬ FALSE;    special: BOOLEAN ¬ FALSE;        InitBadSectorsWithLock: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]  =      BEGIN      InitBadSectors[        FloppyTapeInternal.volumeDesc.currentPosition, beforeFileWritten];      END;        IsThereSpace: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]  =      BEGIN      newPosition: FloppyTape.SectorNumber;      FOR i: CARDINAL IN [0..scatteredVM.length) DO	scatteredCount ¬ scatteredCount + scatteredVM[i].count;	ENDLOOP;      numOfSectors ¬ FloppyTapeInternal.BytesToPages[scatteredCount];      IF lastFile ¬         (FloppyTapeInternal.volumeDesc.rootPage.lastFileID = file.file) THEN           newPosition ¬ FloppyTapeInternal.volumeDesc.rootPage.currentEOT      ELSE newPosition ¬ FloppyTapeInternal.BytesToPages[size] +         FloppyTapeFormat.DiskAddressToSector[	  LOOPHOLE[file.file],	  FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	  FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	  FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack];      IF (newPosition + numOfSectors) >         FloppyTapeInternal.BytesToPages[FloppyTapeInternal.volumeDesc.size] THEN	RETURN WITH ERROR FloppyTape.Error[insufficientSpace];      --ELSE FloppyTapeInternal.volumeDesc.currentPosition ¬ newPosition;      END;          UpdateSizeInMarkerPage: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      savedError: FloppyTape.ErrorType;      BEGIN ENABLE        BEGIN        FloppyTapeInternal.InternalIOError =>	  {savedError ¬ needsScavenging; GO TO otherError};	FloppyTapeInternal.DiskChanged =>	  {savedError ¬ invalidVolumeHandle; GO TO otherError};	END;      newSize: FloppyTape.ByteCount ¬         (FloppyTapeInternal.volumeDesc.rootPage.currentEOT -	  FloppyTapeInternal.ConvertFileIDToSector[file.file]) * 	  Environment.bytesPerPage;      FloppyTapeInternal.ReadMarkerPage[LOOPHOLE[buffer], file.file !        FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      LOOPHOLE[buffer,        LONG POINTER TO FloppyTapeFormat.MarkerPage]­.logicalSize ¬ newSize;      FloppyTapeInternal.WriteMarkerPage[LOOPHOLE[buffer], file.file !        FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      -- clear or fix the cache so we don't use the wrong size by accident      IF (file.file = FloppyTapeInternal.volumeDesc.cachedFile.id) THEN        FloppyTapeInternal.volumeDesc.cachedFile.size ¬ newSize;      EXITS        otherError => RETURN WITH ERROR FloppyTape.Error[savedError];      END;      END;        UpdateRootPage: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      -- copy the client data from their buffers into our buffer      FloppyTapeInternal.volumeDesc.rootPage.lastFileID ¬ file.file;      FloppyTapeInternal.volumeDesc.rootPage.currentEOT ¬         FloppyTapeInternal.volumeDesc.rootPage.currentEOT + numOfSectors;      FloppyTapeInternal.volumeDesc.rootPage.nextUnusedFileID ¬  	FloppyTapeInternal.ConvertSectorToFileID[ 	  FloppyTapeInternal.volumeDesc.rootPage.currentEOT];      -- do we write root page for currentEOT or do we make the scavenger      -- scan entire volume? I vote for scavenger changes.      END;    AppendFileMain: FloppyTapeInternal.OperationProc =      BEGIN ENABLE FloppyTape.Error => {savedError ¬ error; GO TO errorExit};      volume: FloppyTape.VolumeHandle = file.volume;      FloppyTapeInternal.ValidateHandle[volume];      size ¬ markerByteSize + FloppyTapeInternal.GetFileAttributesEntry[        @FloppyTapeInternal.volumeDescLock, file].size;	-- GetFileAttributesInternal will raise notOpen or fileNotFound if needed      CanWeWrite[@FloppyTapeInternal.volumeDescLock];      IsThereSpace[@FloppyTapeInternal.volumeDescLock !        FloppyTape.Error => IF error = insufficientSpace THEN special ¬ TRUE];	-- don't want to close volume (and thus require scavenge) on an 	-- insufficientSpace from here, since nothing will have made it out to 	-- tape yet.  However, do want to require scavenge from other sources if	-- things make it out to tape.      -- do we have to backtrack      IF NOT lastFile THEN {	ForceOutBuffers[@bufferLock ! 	  -- temporary fix....don't close the tape when badTape is raised, so	  -- that the client can still store out the directory	  FloppyTape.Error => IF error = badTape THEN special ¬ TRUE];	-- got to reset any soft bad pages (afterFileWritten) to 	-- hard bad sectors (beforeFileWritten)	InitBadSectorsWithLock[@FloppyTapeInternal.volumeDescLock] };      -- otherwise      UpdateRootPage[@FloppyTapeInternal.volumeDescLock];      BufferFile[scatteredVM, scatteredCount, @bufferLock !        -- temporary fix....don't close the tape when badTape is raised, so	-- that the client can still store out the directory	FloppyTape.Error => IF error = badTape THEN special ¬ TRUE];      IF updateEndOfFile THEN 	BEGIN	ForceOutBuffers[@bufferLock !	  -- temporary fix....don't close the tape when badTape is raised, so	  -- that the client can still store out the directory	  FloppyTape.Error => IF error = badTape THEN special ¬ TRUE]; --again --	UpdateSizeInMarkerPage[@bufferLock];	END;      EXITS        errorExit => {	  ForceOutBuffers[@bufferLock ! FloppyTape.Error => CONTINUE];	  IF ~special THEN FloppyTapeInternal.CloseVolumeInternal[];	  ERROR FloppyTape.Error[savedError]};      END;  --AppendFileMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, AppendFileMain, appendFile];    END;  --AppendFile--      BufferFile: ENTRY PROCEDURE [    scatteredVM: FloppyTape.ScatteredVM, scatteredCount: FloppyTape.ByteCount,    ml: LONG POINTER TO MONITORLOCK] =    BEGIN ENABLE UNWIND => NULL;    countLeftHere: LONG CARDINAL;    countToCopy: CARDINAL;    status: FloppyChannel.Status;    vm: LONG POINTER;    badTape: BOOLEAN;    FOR i: CARDINAL IN [0..scatteredVM.length) DO      countLeftHere ¬ BytesToWords[scatteredVM[i].count];      vm ¬ scatteredVM[i].vm;      WHILE countLeftHere # 0 DO 	countToCopy ¬ CARDINAL[MIN[	  countLeftHere,	  PagesToWords[FloppyTapeInternal.residentBufferSize] - bufferIndex]];	Inline.LongCOPY[from: vm, nwords: countToCopy, to: buffer + bufferIndex];	bufferIndex ¬ bufferIndex + countToCopy;	IF (FloppyTapeInternal.WordsToPages[bufferIndex] =	     FloppyTapeInternal.residentBufferSize) THEN 	  BEGIN	  [, status, badTape] ¬ DoAsyncIO[	    CARDINAL[FloppyTapeInternal.WordsToPages[bufferIndex]],	    buffer, @ioLock];	  SwitchBuffers[];	    -- must switch buffers before raising an error to make sure that	    -- we reset bufferIndex	  IF badTape THEN RETURN WITH ERROR FloppyTape.Error[badTape];	  IF status # goodCompletion THEN	    FloppyTapeInternal.ReportErrorToClient[status];	  END;	countLeftHere ¬ countLeftHere - countToCopy;	vm ¬ vm + countToCopy;	ENDLOOP;      ENDLOOP;    END;      BytesToWords: PROCEDURE [bytes: FloppyTape.ByteCount] RETURNS [LONG CARDINAL] =     INLINE {RETURN[(bytes+1)/Environment.bytesPerWord] };      Bug: PROCEDURE [bugType: BugType] = {RuntimeInternal.Bug[bugType]};    CanWeWrite: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =     BEGIN    IF FloppyTapeInternal.volumeDesc.writeProtected THEN      RETURN WITH ERROR FloppyTape.Error[writeInhibited];    END;      DoAsyncIO: ENTRY PROCEDURE [    count: ShortSectorCount, buffer: FloppyTapeInternal.ResidentBufferPtr,    ml: LONG POINTER TO MONITORLOCK]    RETURNS [      previousCount:ShortSectorCount, previousResult: FloppyChannel.Status,      badTape: BOOLEAN] =    BEGIN ENABLE UNWIND => NULL;    WHILE currentMsg.inuse DO      WAIT msgQueueEmpty;      ENDLOOP;    -- get status of previous io operation    previousCount ¬ currentMsg.countDone;    badTape ¬ currentMsg.badTape;    WITH currentMsg SELECT FROM       okay => previousResult ¬ goodCompletion;      error => previousResult ¬ errorType;      ENDCASE;    -- send a new io request    IF count = 0 OR previousResult # goodCompletion OR badTape THEN       -- exit early so we don't keep writing the tape.      BEGIN      currentMsg.result ¬ okay[];      currentMsg.badTape ¬ FALSE;      RETURN;      END;    currentMsg ¬ [      inuse: TRUE, countRequested: count, buffer: buffer,       countDone: 0, badTape: FALSE, result: inProgress[]];    NOTIFY newMessage;    END;  --DoAsyncIO--       -- Maximum grossness here with bad page handling....  DoAsyncIOHelperProcess: PROCEDURE =    -- This procedure doesn't need to worry about adding new bad pages to a     -- readOnly disk since this procedure only is operating during writing    -- to a disk.    BEGIN    countRequested, restartCountWrite, restartCountRead, countDone:      ShortSectorCount;    countProcessedWrite, countProcessedRead: ShortSectorCount;    buffer, restartBufferWrite, restartBufferRead: LONG POINTER;    bufferPosition: LONG POINTER;    tapePosition, offsetOfPosition, restartTapeWrite, restartTapeRead:      FloppyTape.SectorNumber;    badPages, badTape, doVerifyPass: BOOLEAN;    status: FloppyChannel.Status ¬ goodCompletion;        Process.SetPriority[Process.priorityForeground];      -- raise priority to make sure tape is going as much as possible      -- and besides, the Poll will let go of the cpu anyway.    DO  --forever      [countRequested, buffer] ¬ WaitForNewMessage[ml: @ioLock];      restartBufferWrite ¬ restartBufferRead ¬ buffer;      -- When should we test for eot?      badPages ¬ badTape ¬ FALSE; -- assume no bad pages or problems.       offsetOfPosition ¬ GetLastEOTonTape[@FloppyTapeInternal.volumeDescLock];      restartTapeWrite ¬ restartTapeRead ¬         GetRealPosition[offsetOfPosition, @FloppyTapeInternal.volumeDescLock];      restartCountWrite ¬ countRequested;      countProcessedWrite ¬ countProcessedRead ¬ 0;            UNTIL (countProcessedWrite = countRequested) DO        restartCountWrite ¬ restartCountRead ¬ 	  DontCrossStream[restartTapeWrite, restartCountWrite];        [bufferPosition, tapePosition, countDone, status] ¬ MoveTheBits[	  restartBufferWrite, restartTapeWrite, restartCountWrite, write];	countProcessedWrite ¬ countProcessedWrite + countDone;	IF status # goodCompletion AND IsItABadPageError[status] THEN	  BEGIN	  restartCountWrite ¬ countRequested - countProcessedWrite;	  restartBufferWrite ¬ bufferPosition;	  restartTapeWrite ¬ tapePosition + 1;	  MarkBadSectorEntry[	    beforeFileWritten, tapePosition, @FloppyTapeInternal.volumeDescLock !	      FloppyTape.Error => IF error = badTape THEN {	                            badPages ¬ TRUE;				    badTape ¬ TRUE;				    EXIT}];	  badPages ¬ TRUE;	  LOOP;  -- if entering this IF statement, always will loop	  END;	IF (status = goodCompletion) AND	  (doVerifyPass ¬ VerifyAfterWrite[@FloppyTapeInternal.volumeDescLock])	  THEN	  BEGIN  --the verify pass--	  [bufferPosition, tapePosition, countDone, status] ¬ MoveTheBits[	    restartBufferRead, restartTapeRead, restartCountRead, verify];	    -- always a verify here, since this procedure always writes the tape	  IF status = goodCompletion THEN NULL  -- want to exit the verify IF	  ELSE IF IsItABadPageError[status] THEN	    BEGIN	    countProcessedWrite ¬ countProcessedRead ¬	      countProcessedRead + countDone;	    restartCountWrite ¬ restartCountRead ¬ 	      countRequested - countProcessedRead;	    restartBufferWrite ¬ restartBufferRead ¬ bufferPosition;	    restartTapeWrite ¬ restartTapeRead ¬ tapePosition + 1;	    MarkBadSectorEntry[beforeFileWritten, tapePosition,	      @FloppyTapeInternal.volumeDescLock !	        FloppyTape.Error => IF error = badTape THEN {		                      badPages ¬ TRUE;				      badTape ¬ TRUE;				      EXIT}];	    badPages ¬ TRUE;	    LOOP;  -- if entering this IF statement, always will loop	    END;	  END;  --the verify pass--	IF countProcessedWrite = countRequested THEN EXIT	ELSE  --countProcessedWrite # countRequested--	  BEGIN	  -- get to here if crossed a stream boundary	  restartCountWrite ¬ countRequested - countProcessedWrite;	    -- don't need to set restartCountRead since this will be set 	    -- in first statement in this loop.	  restartBufferWrite ¬ restartBufferRead ¬ bufferPosition;	  restartTapeWrite ¬ restartTapeRead ¬ tapePosition;	  LOOP;	  END;	ENDLOOP;  --UNTIL (countProcessedWrite = countRequested)--            UpdateLastEOTonTape[        countProcessedWrite, @FloppyTapeInternal.volumeDescLock];      IF badPages THEN        UpdateBadPages[@FloppyTapeInternal.volumeDescLock !	  FloppyTape.Error => {badTape ¬ TRUE; CONTINUE}];      SendNewMessageProcessed[countProcessedWrite, status, badTape, @ioLock];      ENDLOOP;  --DO forever--    END; --DoAsyncIOHelperProcess      DontCrossStream: PROCEDURE [    start: FloppyTape.SectorNumber, count: ShortSectorCount]    RETURNS [newCount: ShortSectorCount] =    BEGIN    end: FloppyTape.SectorNumber = start + count;    max: FloppyTape.SectorNumber = FloppyTapeInternal.volumeDesc.sectorsPerStream;    SELECT TRUE FROM      (start MOD max) = 0                => RETURN[1];      (end MOD max) = 0                  => RETURN[count];      ((start MOD max) <= (end MOD max)) => RETURN[count];      ENDCASE                            => RETURN[                                             CARDINAL[max - (start MOD max) + 1]];        --((start MOD max) > (end MOD max))--    END;  DoSynchIO: PROCEDURE [    opType: OpType, scatteredVM: FloppyTape.ScatteredVM,     tapePosition: FloppyTape.SectorNumber, countRequested: SectorCount] =    BEGIN    -- DoSynchIO pins client buffers and leave ours available.    -- Is it a win (avoid copying of buffers) or a wash (streaming problems)?    bufferRestart: LONG POINTER;    countCompleted, countDone, countToCopy: ShortSectorCount;    countProcessed, vmCount: SectorCount ¬ 0;    currentPosition, firstBad: FloppyTape.SectorNumber;    firstTime: BOOLEAN ¬ TRUE;    gotAProblem, badPages: BOOLEAN ¬ FALSE;    numberOfBadPages, numberOfHoles: CARDINAL ¬ 0;    status: FloppyChannel.Status;    vmBuffer: LONG POINTER;    tapePositionWrite: FloppyTape.SectorNumber;    doVerifyPass: BOOLEAN = VerifyAfterWrite[@FloppyTapeInternal.volumeDescLock];    writeProtected: BOOLEAN =       GetWriteProtectStatus[@FloppyTapeInternal.volumeDescLock];        DebugTouch: PROCEDURE =      BEGIN      touchArray: ARRAY[0..Environment.wordsPerPage) OF CARDINAL ¬         ALL[LAST[CARDINAL]];      mem: LONG POINTER TO ARRAY[0..Environment.wordsPerPage) OF CARDINAL ¬       LOOPHOLE[vmBuffer];      THROUGH [0..countToCopy) DO        mem­ ¬ touchArray;        mem ¬ mem + Environment.wordsPerPage;      ENDLOOP;      END;          tapePositionWrite ¬ tapePosition ¬      GetRealPosition[tapePosition, @FloppyTapeInternal.volumeDescLock];    -- this loop goes through client buffers    FOR i: CARDINAL IN [0..scatteredVM.length) DO      vmBuffer ¬ scatteredVM[i].vm;      vmCount ¬ FloppyTapeInternal.BytesToPages[scatteredVM[i].count];            -- this loop breaks requests into cardinal values for the channel io      UNTIL (vmCount = 0) OR (countRequested = 0) OR (gotAProblem) DO	countToCopy ¬ CARDINAL[MIN[vmCount, countRequested, LAST[CARDINAL]]];	VM.MakeResident[	  [Environment.PageFromLongPointer[vmBuffer], countToCopy], wait];	-- IF opType # write THEN DebugTouch[];	IF opType = write THEN  -- do the write before the verify pass --	  BEGIN	  bufferRestart ¬ vmBuffer;	  countCompleted ¬ 0;	  UNTIL (countCompleted = countToCopy) OR (gotAProblem) DO	    [bufferRestart, tapePositionWrite, countDone, status] ¬	      MoveTheBits[bufferRestart, tapePositionWrite,	        countToCopy - countCompleted, write !		  HoleInFile => {		    IF firstTime THEN {		      firstBad ¬ firstHole;		      firstTime ¬ FALSE};		    -- don't increment numberOfHoles since this will be done		    -- on read again. (numberOfHoles ¬ numberOfHoles + 1)		    RESUME}];	    countCompleted ¬ countCompleted + countDone;	    SELECT TRUE FROM	      status = goodCompletion => NULL; --must be done	      IsItABadPageError[status] => BEGIN -- happened just now		MarkBadSectorEntry[		  afterFileWritten, tapePositionWrite, 		  @FloppyTapeInternal.volumeDescLock];		IF firstTime THEN {		  firstBad ¬ tapePositionWrite;		  firstTime ¬ FALSE};		badPages ¬ TRUE;		-- don't increment numberOfBadPages because we will be 		-- incrementing numberOfHoles on the read instead.		bufferRestart ¬ bufferRestart + Environment.wordsPerPage;		tapePositionWrite ¬ tapePositionWrite + 1;		countCompleted ¬ countCompleted + 1;		END;	      ENDCASE => gotAProblem ¬ TRUE;	    ENDLOOP;  -- finish writing	  END;  --IF opType = write--	  	countCompleted ¬ 0;	bufferRestart ¬ vmBuffer;		-- this loop handles problem pages	UNTIL (countCompleted = countToCopy) OR (gotAProblem) OR 	  ((opType = write) AND ~doVerifyPass) DO	  [bufferRestart, tapePosition, countDone, status] ¬ MoveTheBits[	    bufferRestart, tapePosition, countToCopy - countCompleted, 	    IF opType = read THEN read ELSE verify !	      HoleInFile => { 	        IF firstTime THEN {		  firstBad ¬ firstHole;		  firstTime ¬ FALSE};	        numberOfHoles ¬ numberOfHoles + 1;	        RESUME}];	  countCompleted ¬ countCompleted + countDone;	  SELECT TRUE FROM	    status = goodCompletion => NULL; --must be done	    IsItABadPageError[status] => BEGIN -- happened just now	      IF ~writeProtected THEN  -- only update bad pages if able to write		MarkBadSectorEntry[		  afterFileWritten, tapePosition, 		  @FloppyTapeInternal.volumeDescLock];	      IF firstTime THEN {	        firstBad ¬ tapePosition;		firstTime ¬ FALSE };	      numberOfBadPages ¬ numberOfBadPages + 1;	      badPages ¬ TRUE;	      IF opType = read THEN 		LOOPHOLE[bufferRestart, WordArray]­ ¬ ALL[0];	      -- skip over the bad sector	      bufferRestart ¬ bufferRestart + Environment.wordsPerPage;	      tapePosition ¬ tapePosition + 1; 	      countCompleted ¬ countCompleted + 1;	      END;	    ENDCASE => gotAProblem ¬ TRUE;	  ENDLOOP; -- finish handling problem pages	  	VM.MakeSwappable[	  [Environment.PageFromLongPointer[vmBuffer], countToCopy]];	countRequested ¬ countRequested - countCompleted;	countProcessed ¬ countProcessed + countCompleted;	vmCount ¬ vmCount - countCompleted;	vmBuffer ¬ vmBuffer + PagesToWords[countCompleted];	ENDLOOP; --finish breaking it into cardinal values      ENDLOOP; -- finish the client buffers          IF gotAProblem THEN FloppyTapeInternal.ReportErrorToClient[status];    IF (~badPages) THEN      BEGIN -- we have no holes or bad pages      currentPosition ¬ GetCurrentPosition[@FloppyTapeInternal.volumeDescLock];      UpdateCurrentPosition[        currentPosition + countProcessed, @FloppyTapeInternal.volumeDescLock];      IF (numberOfHoles # 0) THEN SIGNAL MissingPages[firstBad, numberOfHoles];      END    ELSE IF ~writeProtected THEN      BEGIN -- got a bad page, maybe holes too and we can write to the tape      UpdateBadPages[@FloppyTapeInternal.volumeDescLock];      UpdateCurrentPosition[        FloppyTapeFormat.rootPageSector, @FloppyTapeInternal.volumeDescLock];      SIGNAL MissingPages[firstBad, numberOfBadPages + numberOfHoles];      END    ELSE      BEGIN  -- got a bad page, maybe holes too but we can't write to the tape      currentPosition ¬ GetCurrentPosition[@FloppyTapeInternal.volumeDescLock];      UpdateCurrentPosition[        currentPosition + countProcessed, @FloppyTapeInternal.volumeDescLock];      SIGNAL MissingPages[firstBad, numberOfBadPages + numberOfHoles];      END;    END;      FilterStatus: PUBLIC --FloppyTapeInternal-- PROCEDURE [s: FloppyDiskFace.Status]    RETURNS [status: FloppyChannel.Status] =    BEGIN    SELECT s FROM       inProgress => NULL;       goodCompletion => status ¬ goodCompletion;       diskChange => status ¬ diskChange;       notReady => status ¬ notReady;        cylinderError => status ¬ cylinderError;        recordNotFound => status ¬ recordNotFound;        headerError => status ¬ headerError;       dataError => status ¬ dataError;       dataLost => status ¬ dataLost;       deletedData => status ¬ deletedData;       writeFault => status ¬ writeFault;       otherError => status ¬ otherError;       memoryError, invalidOperation, aborted => Bug[unexpectedErrorStatus];       ENDCASE => Bug[impossibleEndcase];      END;     ForceOutBuffers: PUBLIC -- FloppyTapeInternal -- ENTRY PROCEDURE    [ml: LONG POINTER TO MONITORLOCK] =    BEGIN ENABLE UNWIND => NULL;    previousResult: FloppyChannel.Status;    badTape: BOOLEAN;    -- only one buffer need be flushed, since the other should have been done     [, previousResult, badTape] ¬       DoAsyncIO[        CARDINAL[FloppyTapeInternal.WordsToPages[bufferIndex]], buffer, @ioLock];     bufferIndex ¬ nullBufferIndex;      -- we want to do this first, before we exit this proc by way of ERROR    IF badTape THEN RETURN WITH ERROR FloppyTape.Error[badTape];    IF previousResult # goodCompletion THEN      FloppyTapeInternal.ReportErrorToClient[previousResult];    -- KLUDGE TIME     -- DoAsyncIO will return without doing IO since countRequested is zero --    [, previousResult, badTape] ¬ DoAsyncIO[0, buffer, @ioLock];       IF badTape THEN RETURN WITH ERROR FloppyTape.Error[badTape];    IF previousResult # goodCompletion THEN      FloppyTapeInternal.ReportErrorToClient[previousResult];    END;  IsVolumeOpen: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]    RETURNS [BOOLEAN] = {RETURN[FloppyTapeInternal.volumeDesc.open]};  GenerateDataBuffer: PRIVATE INTERNAL PROCEDURE [    unit: CARDINAL, cylinder: CARDINAL, head: CARDINAL, sector: CARDINAL,    wordCount: LONG CARDINAL, pointer: LONG POINTER TO ARRAY OF WORD] =    BEGIN    -- unit is always equal to 0 in this case.    -- will do  one cylinder (volumeDesc.rootPage.sectorsPerTrack *    -- Environment.wordsPerPage) words at a time.    index: CARDINAL ¬ 0;    byteIndex: CARDINAL ¬ 0;       countToGetTo:CARDINAL;    sectorsDone:CARDINAL ¬ 0;    maxSector: CARDINAL = FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack;    minSector: CARDINAL = 1;    maxHead: CARDINAL = FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks - 1;    minHead: CARDINAL = 0;    bytePointer: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬      LOOPHOLE[pointer];    IF pointer = NIL OR wordCount = 0 THEN RETURN;    UNTIL index >= wordCount DO      pointer[index] ¬ unit;      index ¬ index + 1;      pointer[index] ¬ cylinder;      index ¬ index + 1;      pointer[index] ¬ head;      index ¬ index + 1;      pointer[index] ¬ sector;  -- four words put at beginning      index ¬ index + Environment.wordsPerPage - 3;  --point to the next page      byteIndex ¬ (sectorsDone * Environment.bytesPerPage) +        (Environment.bytesPerWord * (4 * SIZE[CARDINAL]));        -- point to the first data byte      countToGetTo ¬ (sectorsDone + 1) * Environment.bytesPerPage;      UNTIL byteIndex = countToGetTo DO        bytePointer[byteIndex] ¬ Inline.LowByte[byteIndex];        byteIndex ¬ byteIndex + 1;        ENDLOOP; -- byteIndex = countToGetTo      -- increments sector, head, and cylinder      sectorsDone ¬ sectorsDone + 1;      sector ¬ sector + 1;      IF sector > maxSector THEN         BEGIN        sector ¬ minSector;        head ¬ head+ 1;        IF head > maxHead THEN	  BEGIN          head ¬ minHead;          cylinder ¬ cylinder + 1;	  END;	END;      ENDLOOP; --UNTIL index >= wordCount    END;  --GenerateDataBuffer--  GetCurrentPosition: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]    RETURNS [pos: FloppyTape.SectorNumber] = {      RETURN[FloppyTapeInternal.volumeDesc.currentPosition]};        GetLastEOTonTape: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]    RETURNS [pos: FloppyTape.SectorNumber] = {      RETURN[FloppyTapeInternal.volumeDesc.lastEOTonTape]};        GetRealPosition: PUBLIC ENTRY PROCEDURE [    pos: FloppyTape.SectorNumber, ml: LONG POINTER TO MONITORLOCK]    RETURNS [FloppyTape.SectorNumber] = {      RETURN[FloppyTapeInternal.RealFileIDLoc[	FloppyTapeInternal.ConvertSectorToFileID[pos]].sector]};      GetVolumeSize: PROCEDURE [ml: LONG POINTER TO MONITORLOCK]     RETURNS [volumeSize: SectorCount] = {    volumeSize ¬       FloppyTapeInternal.BytesToPages[FloppyTapeInternal.volumeDesc.size]};  GetWriteProtectStatus: PUBLIC ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]    RETURNS [writeProtected: BOOLEAN] = {    RETURN[FloppyTapeInternal.volumeDesc.writeProtected]};  InitBadSectors: PUBLIC -- FloppyTapeInternal -- INTERNAL PROCEDURE [    start: FloppyTape.SectorNumber, type: FloppyTapeFormat.BadSectorType] =    BEGIN    badSector: FloppyTape.SectorNumber;    numToChange: CARDINAL ¬ 0;    FOR i:CARDINAL IN [0..FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages)      DO      badSector ¬ 	FloppyTapeFormat.PackBadSectorNumber[         FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorLow, 	 FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorHigh];      IF (badSector >= start) AND 	(FloppyTapeInternal.volumeDesc.badSectorList[i].typeOfBadPage # type)	    THEN {	FloppyTapeInternal.volumeDesc.badSectorList[i].typeOfBadPage ¬ type;        numToChange ¬ numToChange + 1 };       ENDLOOP;      IF numToChange # 0 THEN FloppyTapeInternal.WriteBadSectorList[ !        FloppyTapeInternal.DiskChanged => ERROR FloppyTape.Error[notReady]];    END;     IsItABadPageError: PUBLIC -- FloppyTapeInternal -- PROCEDURE [    status: FloppyChannel.Status]    RETURNS [badPage: BOOLEAN] =    BEGIN    SELECT status FROM      cylinderError, dataError, dataLost, deletedData, headerError,         recordNotFound => badPage ¬ TRUE;      otherError, notReady, diskChange => badPage ¬ FALSE;      goodCompletion, writeFault => Bug[unexpectedErrorStatus];      ENDCASE => Bug[impossibleEndcase];    END;     MarkBadSectorEntry: PRIVATE ENTRY PROCEDURE [    type: FloppyTapeFormat.BadSectorType, sector: FloppyTape.SectorNumber,    ml: LONG POINTER TO MONITORLOCK] =    BEGIN ENABLE UNWIND => NULL;    MarkBadSectorEntryInternal[type, sector];    END;  --MarkBadSectorEntry--      MarkBadSectorEntryInternal: PUBLIC --FloppyTapeInternal-- INTERNAL PROCEDURE [    type: FloppyTapeFormat.BadSectorType, sector: FloppyTape.SectorNumber] =    BEGIN    -- trust that anybody who calls this only calls it with legal sector numbers.    badSector, temp: FloppyTape.SectorNumber;    tempType: FloppyTapeFormat.BadSectorType;    totalBad: CARDINAL ¬ FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages;    FOR i:CARDINAL IN [0..totalBad) DO      badSector ¬	FloppyTapeFormat.PackBadSectorNumber[	  FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorLow,	  FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorHigh];      IF badSector = sector THEN {        FloppyTapeInternal.volumeDesc.badSectorList[i].typeOfBadPage ¬ type; 	RETURN};      IF badSector < sector THEN LOOP;      -- once past down to here, we know we have a new bad page.  we only      -- want to put it into our table IF we have room for another entry.      -- yes, it is a waste to do this test every time, but I really don't see      -- any other way.      IF totalBad >= FloppyTapeFormat.maxNumberBadSectors THEN        RETURN WITH ERROR FloppyTape.Error[badTape];      -- now it is safe to put the new bad sector into the table.      temp ¬ badSector;      tempType ¬ FloppyTapeInternal.volumeDesc.badSectorList[i].typeOfBadPage;      [FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorLow,      FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorHigh] ¬ 	FloppyTapeFormat.UnpackBadSectorNumber[sector];      FloppyTapeInternal.volumeDesc.badSectorList[i].typeOfBadPage ¬ type;      sector ¬ temp;      type ¬ tempType;      ENDLOOP;    -- have to check again, because this new bad sector may be larger than any    -- current bad sectors, and it also may NOT have room in the bad sector list.    IF totalBad >= FloppyTapeFormat.maxNumberBadSectors THEN      RETURN WITH ERROR FloppyTape.Error[badTape];    -- get the first or last case, and there is room in the table.    [FloppyTapeInternal.volumeDesc.badSectorList[totalBad].badSectorLow,    FloppyTapeInternal.volumeDesc.badSectorList[totalBad].badSectorHigh] ¬       FloppyTapeFormat.UnpackBadSectorNumber[sector];    FloppyTapeInternal.volumeDesc.badSectorList[totalBad].typeOfBadPage ¬ type;    -- update the rootpage in memory    FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages ¬ totalBad + 1;        -- temporary hack to detect bad tapes by looking for runs of bad pages    IF sector = lastConsecutiveBadPage + 1 THEN      BEGIN      IF countConsecutiveBadPages >= maxConsecutiveBadPages THEN        RETURN WITH ERROR FloppyTape.Error[badTape]      ELSE        BEGIN        countConsecutiveBadPages ¬ countConsecutiveBadPages + 1;	lastConsecutiveBadPage ¬ sector;	END;      END    ELSE      BEGIN      countConsecutiveBadPages ¬ 1;      lastConsecutiveBadPage ¬ sector;      END;    END;  --MarkBadSectorEntryInternal--      MoveTheBits: PROCEDURE [    bufferPosition: LONG POINTER, tapePosition: FloppyTape.SectorNumber,     count: ShortSectorCount, opType: OpType]     RETURNS [newBufferPos: LONG POINTER, newTapePos: FloppyTape.SectorNumber,    countCompleted: ShortSectorCount, status: FloppyChannel.Status] =    BEGIN    badSector, badPage: FloppyTape.SectorNumber;    type: FloppyTapeFormat.BadSectorType;    countDoneThisRun: ShortSectorCount;    countRun: SectorCount;    result: FloppyDiskFace.Status ¬ goodCompletion;    i, lastBad: CARDINAL ¬ 0;    countCompleted ¬ 0;    status ¬ goodCompletion;    UNTIL (countCompleted >= count) OR (status # goodCompletion) DO      -- skip over existing bad pages      FOR i IN [lastBad..FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages) DO        badSector ¬ 	  FloppyTapeFormat.PackBadSectorNumber[           FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorLow, 	   FloppyTapeInternal.volumeDesc.badSectorList[i].badSectorHigh];        IF badSector >= tapePosition THEN {          badPage ¬ badSector; 	  type ¬ FloppyTapeInternal.volumeDesc.badSectorList[i].typeOfBadPage;	  lastBad ¬ i;	  EXIT }	REPEAT        FINISHED =>	  badPage ¬ GetVolumeSize[@FloppyTapeInternal.volumeDescLock];        ENDLOOP;      countRun ¬ MIN[count - countCompleted, badPage - tapePosition];      -- set up iocb for channel and face      countDoneThisRun ¬ CARDINAL[countRun];      FOR j: CARDINAL IN [0..2) DO  -- must try again if retention needed	SetUpIORequest[	  IF opType = verify THEN FloppyTapeInternal.volumeDesc.verifyBuffer	    ELSE bufferPosition,	  countDoneThisRun, opType, tapePosition];	IF myIocb.count = 0 THEN EXIT;	  -- exit if nothing to do since Heads will come back with	  -- a recordNotFound status if you enter with myIocb.count = 0.	[result, , ] ¬ SpecialFloppyChannel.DoDirectIO[myIocb !	  FloppyChannel.Error =>	    IF type = invalidHandle THEN {status ¬ diskChange; CONTINUE}];	-- myIocb got updated by head/handler	status ¬ FilterStatus[result];	IF (status = otherError) AND (j = 0) THEN 	  BEGIN	  IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	    FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	      FloppyTapeInternal.volumeDesc.drive, start];	  status ¬ SpecialFloppyChannelExtras.Retention[	    FloppyTapeInternal.volumeDesc.fcHandle !	      FloppyChannel.Error => 	        IF type = invalidHandle THEN {status ¬ diskChange; CONTINUE}];	  IF FloppyTapeInternal.volumeDesc.notifyClientOnRetention # NIL THEN	    FloppyTapeInternal.volumeDesc.notifyClientOnRetention[	      FloppyTapeInternal.volumeDesc.drive, stop];	  IF status # goodCompletion THEN EXIT;  -- if still not OK, then exit	  END	ELSE EXIT;	ENDLOOP;  --FOR j: CARDINAL--	      -- temporary hack for Daybreak Tapes due to a bug in the head.      «countDoneThisRun ¬ countDoneThisRun - myIocb.count;»      IF (result # goodCompletion) THEN        countDoneThisRun ¬ 	  CARDINAL[FloppyTapeInternal.GetCountDone[tapePosition, myIocb]]      ELSE        countDoneThisRun ¬ countDoneThisRun - myIocb.count;            countCompleted ¬ countCompleted + countDoneThisRun;      tapePosition ¬ tapePosition + countDoneThisRun;      bufferPosition ¬ bufferPosition + PagesToWords[countDoneThisRun];      -- what if a couple bad pages...      IF (tapePosition = badPage) AND (countCompleted < count) THEN         BEGIN	IF (type = afterFileWritten) THEN {	  IF opType # verify THEN LOOPHOLE[bufferPosition, WordArray]­ ¬ ALL[0];          bufferPosition ¬ bufferPosition + Environment.wordsPerPage;	  countCompleted ¬ countCompleted + 1;	  SIGNAL HoleInFile[tapePosition]}; -- keep tab of this hole	tapePosition ¬ tapePosition + 1;	END;      ENDLOOP;    RETURN[bufferPosition, tapePosition, countCompleted, status];    END;  --MoveTheBits--      PagesToWords: PROCEDURE [pages: LONG CARDINAL] RETURNS [LONG CARDINAL] = INLINE    {RETURN [pages*Environment.wordsPerPage] };     ReadFile: PUBLIC PROCEDURE [    file: FloppyTape.FileHandle, first: FloppyTape.ByteOffset,     scatteredVM: FloppyTape.ScatteredVM] =    BEGIN    ReadFileMain: FloppyTapeInternal.OperationProc =      BEGIN      size: FloppyTape.ByteCount;      volume: FloppyTape.VolumeHandle = file.volume;      FloppyTapeInternal.ValidateHandle[volume];      size ¬ FloppyTapeInternal.GetFileAttributesEntry[        @FloppyTapeInternal.volumeDescLock, file].size;	-- GetFileAttributesInternal will raise notOpen or fileNotFound if needed      ForceOutBuffers[@bufferLock];      ReadOrRewrite[read, file, first, scatteredVM, size];      END;  --ReadFileMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, ReadFileMain, readFile];    END;      ReadOrRewrite: PROCEDURE [    opType: OpType, file: FloppyTape.FileHandle, first: FloppyTape.ByteOffset,     scatteredVM: FloppyTape.ScatteredVM, size: FloppyTape.ByteCount] =    BEGIN ENABLE FloppyTape.Error => {      savedError: FloppyTape.ErrorType ¬ error;      ForceOutBuffers[@bufferLock ! FloppyTape.Error => CONTINUE];      -- it is a hack to check for badTape here....should just do the      -- CloseVolumeInternal only, without checking for badTape      IF savedError # badTape THEN FloppyTapeInternal.CloseVolumeInternal[]};    byte: FloppyTape.ByteOffset;    countHoles: CARDINAL;    countRequested: LONG CARDINAL;    hole, sector: FloppyTape.SectorNumber;    scatteredCount: FloppyTape.ByteCount ¬ 0;        GetSector: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]      RETURNS [FloppyTape.SectorNumber] =      BEGIN       -- this assumes GetFileAttributes was called earlier and cached the id      RETURN[         FloppyTapeFormat.DiskAddressToSector[          LOOPHOLE[FloppyTapeInternal.volumeDesc.cachedFile.id],          FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,          FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,          FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack] +	FloppyTapeInternal.BytesToPages[first] + markerPageSize];      END;          BEGIN -- for exits clause      IF (first >= size) OR (first MOD Environment.bytesPerPage # 0) THEN	ERROR FloppyTape.Error[invalidByteOffset];      FOR i: CARDINAL IN [0..scatteredVM.length) DO	scatteredCount ¬ scatteredCount + scatteredVM[i].count;	ENDLOOP;      IF (opType = write AND scatteredCount + first > size) THEN        ERROR FloppyTape.Error[insufficientSpace];      countRequested ¬ 	FloppyTapeInternal.BytesToPages[MIN[scatteredCount, size - first]];      sector ¬ GetSector[@FloppyTapeInternal.volumeDescLock];      UpdateCurrentPosition[sector, @FloppyTapeInternal.volumeDescLock];      DoSynchIO[opType, scatteredVM, sector, countRequested 	! MissingPages => {	    hole ¬ firstHole; countHoles ¬ howManyHoles; GOTO ioError}];      EXITS       ioError => {         byte ¬ (hole - 	   GetRealPosition[sector-FloppyTapeInternal.BytesToPages[first], 	     @FloppyTapeInternal.volumeDescLock]) * 	     Environment.bytesPerPage;         ERROR FloppyTape.IOError[file, byte, hole, countHoles]};      END;    END;  ReserveDiagnosticArea: PUBLIC --SpecialFloppyTape-- PROCEDURE [    drive: FloppyTape.Drive ¬ FloppyTape.localDrive]     RETURNS [ableToReserve: BOOLEAN] =    BEGIN    -- this procedure will truncate the tape down to streams 1 through 5,     -- (cylinders 1 through 1224) and will write data on streams 6 and 7     -- (cylinders 1225 through 1714) that diagnostics expects there.    ReserveDiagnosticAreaInternal: ENTRY PROCEDURE [      ml: LONG POINTER TO MONITORLOCK] RETURNS [BOOLEAN] =      BEGIN ENABLE        UNWIND => 	  FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.nullHandle;      savedError: FloppyTape.ErrorType;            BEGIN ENABLE        BEGIN	FloppyChannel.Error =>	  IF type = invalidHandle THEN {savedError ¬ notReady; GO TO otherError};        FloppyTapeInternal.InternalIOError =>	  {savedError ¬ badTape; GO TO otherError};        FloppyTapeInternal.DiskChanged =>	  {savedError ¬ notReady; GO TO otherError};	ABORTED => GO TO aborted;	END;      status: FloppyChannel.Status;      attributes: FloppyChannel.Attributes;      IF FloppyTapeInternal.volumeDesc.open THEN         RETURN WITH ERROR FloppyTape.Error[volumeOpen];      FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.GetHandle[drive];      attributes ¬ FloppyChannel.GetDeviceAttributes[        FloppyTapeInternal.volumeDesc.fcHandle].attributes;      FOR i: CARDINAL IN [0..2) DO  -- if retention required, just try once	status ¬ FloppyChannel.Nop[FloppyTapeInternal.volumeDesc.fcHandle];	SELECT status FROM	  goodCompletion => EXIT;	  notReady       => RETURN WITH ERROR FloppyTape.Error[notReady];	  writeFault     => RETURN WITH ERROR FloppyTape.Error[writeInhibited];	  otherError     =>	    BEGIN	    IF i = 0 THEN	      status ¬ SpecialFloppyChannelExtras.Retention[	        FloppyTapeInternal.volumeDesc.fcHandle];	    IF status # goodCompletion THEN	      RETURN WITH ERROR FloppyTape.Error[hardwareError];	    END;	  ENDCASE        => RETURN WITH ERROR FloppyTape.Error[hardwareError];	ENDLOOP;  --FOR i: CARDINAL--      Process.Pause[FloppyTapeInternal.minNumTicks];  -- allow abort      IF ~FloppyChannel.SetContext[        FloppyTapeInternal.volumeDesc.fcHandle, 	FloppyTapeFormat.floppyTapeContext] THEN	RETURN WITH ERROR FloppyTape.Error[badTape];      FloppyTapeInternal.ReadRootAndBadSectorList[ !        FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      FloppyTapeInternal.CheckRootPage[FloppyTapeInternal.volumeDesc.rootPage !        FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      FloppyTapeInternal.CheckBadSectorList[        FloppyTapeInternal.volumeDesc.badSectorList,        FloppyTapeInternal.volumeDesc.rootPage.numberOfBadPages, 	Inline.LongMult[attributes.numberOfCylinders, 	  attributes.maxSectorsPerTrack] * attributes.numberOfHeads !        FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      -- check if already over the diagnostic area      IF (FloppyTapeInternal.RealFileIDLoc[        FloppyTapeInternal.ConvertSectorToFileID[          FloppyTapeInternal.volumeDesc.rootPage.currentEOT - 1]].da.cylinder >=	FloppyTapeFormat.firstDiagnosticCylinder.cylinder) THEN RETURN[FALSE];      WriteDataInReservedArea[ !         FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      Process.Pause[FloppyTapeInternal.minNumTicks];      FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams ¬        FloppyTapeFormat.firstDiagnosticCylinder.cylinder - 1;      FloppyTapeInternal.WriteRootPage[ !        FloppyTape.Error => {savedError ¬ error; GO TO otherError}];      RETURN[TRUE];      EXITS	otherError => 	  BEGIN	  FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.nullHandle;	  RETURN WITH ERROR FloppyTape.Error[savedError];	  END;	aborted =>	  BEGIN	  FloppyTapeInternal.volumeDesc.fcHandle ¬ FloppyChannel.nullHandle;	  RETURN WITH ERROR ABORTED;	  END;      END;      END;  --ReserveDiagnosticAreaInternal--    ReserveDiagnosticAreaMain: FloppyTapeInternal.OperationProc =      BEGIN      IF ~FloppyTapeInternal.ValidDrive[drive] THEN	ERROR FloppyTape.Error[noSuchDrive];      ableToReserve ¬         ReserveDiagnosticAreaInternal[@FloppyTapeInternal.volumeDescLock];      END;  --ReserveDiagnosticAreaMain--    FloppyTapeInternal.DoOperation[@FloppyTapeInternal.operationLock,       ReserveDiagnosticAreaMain, reserveDiagnosticArea];    END;  --ReserveDiagnosticArea--  RewriteFile: PUBLIC PROCEDURE [    file: FloppyTape.FileHandle, first: FloppyTape.ByteOffset,    scatteredVM: FloppyTape.ScatteredVM] =    BEGIN    RewriteFileMain: FloppyTapeInternal.OperationProc =      BEGIN      size: FloppyTape.ByteCount;      volume: FloppyTape.VolumeHandle = file.volume;      FloppyTapeInternal.ValidateHandle[volume];      size ¬ FloppyTapeInternal.GetFileAttributesEntry[	@FloppyTapeInternal.volumeDescLock, file].size; 	-- GetFileAttributesEntry will raise notOpen and fileNotFound if needed      CanWeWrite[@FloppyTapeInternal.volumeDescLock];      ForceOutBuffers[@bufferLock];      ReadOrRewrite[write, file, first, scatteredVM, size];      END;  --RewriteFileMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, RewriteFileMain, rewriteFile];    END;  SearchOurBufferForFile: PUBLIC -- FloppyTapeInternal -- PROCEDURE [    fid: FloppyTape.FileID]    RETURNS [size: FloppyTape.ByteCount ¬ 0, type: File.Type] =    BEGIN    -- do we monitor this procedure?    oldBuffer: FloppyTapeInternal.ResidentBufferPtr;    end: LONG ORDERED POINTER ¬ buffer + bufferIndex;    ptr: LONG ORDERED POINTER TO FloppyTapeFormat.MarkerPage ¬ LOOPHOLE[buffer];    -- goes page by page until the first marker page is found    FOR i: CARDINAL IN [0..numberOfBuffers) DO      UNTIL (ptr = NIL OR ptr >= end) DO	IF (ptr.seal = FloppyTapeFormat.MarkerSeal AND 	    ptr.version = FloppyTapeFormat.MarkerPageVersion) THEN	  IF ptr.file = fid THEN RETURN[ptr.logicalSize, ptr.type]	  ELSE ptr ¬ ptr + BytesToWords[ptr.logicalSize]	ELSE ptr ¬ ptr + Environment.wordsPerPage;	ENDLOOP;      -- If we are here, the file wasn't in this buffer. Maybe it's in the other      -- full buffer and hasn't completely been written out yet.      oldBuffer ¬ IF buffer = FloppyTapeInternal.volumeDesc.residentBuffer1 	THEN FloppyTapeInternal.volumeDesc.residentBuffer2	ELSE FloppyTapeInternal.volumeDesc.residentBuffer1;      end ¬ oldBuffer +         FloppyTapeInternal.residentBufferSize*Environment.wordsPerPage;      ptr ¬ LOOPHOLE[oldBuffer];      ENDLOOP;    END;            SendNewMessageProcessed: ENTRY PROCEDURE [    countDone: ShortSectorCount, err: FloppyChannel.Status, badTape: BOOLEAN,    ml: LONG POINTER TO MONITORLOCK] =    BEGIN    currentMsg.countDone ¬ countDone;    IF err = goodCompletion THEN currentMsg.result ¬ okay[]    ELSE currentMsg.result ¬ error[err];    currentMsg.inuse ¬ FALSE;    currentMsg.badTape ¬ badTape;    NOTIFY msgQueueEmpty;    END;      SetUpIORequest: PROCEDURE [    buffer: LONG POINTER, count: CARDINAL, op: OpType,     address: FloppyTape.SectorNumber] =    BEGIN    myIocb.device ¬ SpecialFloppyChannelExtras.GetDeviceHandle[      FloppyTapeInternal.volumeDesc.fcHandle];    SELECT op FROM      read => myIocb.function ¬ readSector;      verify => myIocb.function ¬ readSector;      write => myIocb.function ¬ writeSector;      ENDCASE => Bug[impossibleEndcase];    myIocb.address ¬ LOOPHOLE[      FloppyTapeFormat.SectorToDiskAddress[address,	FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack], 	FloppyDiskFace.DiskAddress];    myIocb.dataPtr ¬ buffer;    myIocb.incrementDataPointer ¬ IF op = verify THEN FALSE ELSE TRUE;    myIocb.tries ¬ FloppyDiskFace.SuggestedTries[myIocb.device];    myIocb.count ¬ count;    END;       SwitchBuffers: PROCEDURE =    BEGIN    bufferIndex ¬ nullBufferIndex;    buffer ¬ IF buffer = FloppyTapeInternal.volumeDesc.residentBuffer1       THEN FloppyTapeInternal.volumeDesc.residentBuffer2      ELSE FloppyTapeInternal.volumeDesc.residentBuffer1;    END;      UpdateCurrentPosition: ENTRY PROCEDURE    [pos: FloppyTape.SectorNumber, ml: LONG POINTER TO MONITORLOCK] = {    FloppyTapeInternal.volumeDesc.currentPosition ¬ pos };      UpdateLastEOTonTape: ENTRY PROCEDURE    [count: SectorCount, ml: LONG POINTER TO MONITORLOCK] = {    FloppyTapeInternal.volumeDesc.lastEOTonTape ¬       FloppyTapeInternal.volumeDesc.lastEOTonTape + count };      UpdateBadPages: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =    BEGIN ENABLE UNWIND => NULL;    FloppyTapeInternal.WriteBadSectorList[ !       FloppyTapeInternal.DiskChanged =>        ERROR FloppyTape.Error[invalidVolumeHandle]];    FloppyTapeInternal.WriteRootPage[ !      FloppyTapeInternal.DiskChanged =>         ERROR FloppyTape.Error[invalidVolumeHandle]];    END;      VerifyAfterWrite: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]    RETURNS [verifyAfterWrite: BOOLEAN] = {    RETURN[FloppyTapeInternal.volumeDesc.verifyAfterWrite]};  WaitForNewMessage: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK]     RETURNS [      countRequested: ShortSectorCount,       buffer: FloppyTapeInternal.ResidentBufferPtr] =    BEGIN    WHILE NOT currentMsg.inuse DO      WAIT newMessage;      ENDLOOP;    countRequested ¬ currentMsg.countRequested;    buffer ¬ LOOPHOLE[currentMsg.buffer, FloppyTapeInternal.ResidentBufferPtr];    END;  WriteDataInReservedArea : PRIVATE INTERNAL PROCEDURE [] =    -- this procedure should be called from ReserveDiagnosticArea    BEGIN ENABLE UNWIND => NULL;        CleanUp: PROC = {      VM.MakeSwappable[        [Environment.PageFromLongPointer[pointer], sectorsPerRun]];      pointer ¬ Space.Unmap[pointer ! Space.Error => CONTINUE];      tempIocb ¬ FloppyTapeInternal.FreeIOCB[tempIocb]};    sectorsPerRun: CARDINAL =      FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack * 4;    pointer: LONG POINTER;    startCylinder: CARDINAL ¬ FloppyTapeFormat.firstDiagnosticCylinder.cylinder;    endCylinder: CARDINAL ¬ FloppyTapeFormat.firstDiagnosticCylinder.cylinder +      (2 * SpecialFloppyTapeFace.GetTapeParameters[        SpecialFloppyChannelExtras.GetDeviceHandle[	  FloppyTapeInternal.volumeDesc.fcHandle]].parameters.maxTracksPerStream);       -- goes for two streams    cylinder: CARDINAL ¬ startCylinder;    status: FloppyChannel.Status;    countDoneThisRun: CARDINAL;    head: CARDINAL ¬ 0;  -- this should never change!!    sector: CARDINAL ¬ 1;    diskSector: FloppyTape.SectorNumber;    result: FloppyDiskFace.Status ¬ goodCompletion;    tempIocb: FloppyDiskFace.OperationPtr ¬      FloppyTapeInternal.AllocIOCB[FloppyDiskFace.operationBlockLength];        BEGIN ENABLE       BEGIN      FloppyChannel.Error => GO TO notReady;      ABORTED => GO TO aborted;      END;    pointer ¬ Space.ScratchMap[sectorsPerRun];    VM.MakeResident[      [Environment.PageFromLongPointer[pointer], sectorsPerRun], wait];    tempIocb.device ¬ SpecialFloppyChannelExtras.GetDeviceHandle[      FloppyTapeInternal.volumeDesc.fcHandle];    tempIocb.incrementDataPointer ¬ TRUE;    tempIocb.function ¬ writeSector;    -- first write all the data, then verify it.    UNTIL cylinder >= endCylinder DO      Process.Pause[FloppyTapeInternal.minNumTicks];  -- allow aborts.      sector ¬ 1;      GenerateDataBuffer[unit: 0, cylinder: cylinder, head: head, sector: sector,        wordCount: PagesToWords[sectorsPerRun], pointer: LOOPHOLE[pointer]];  	-- we will write one "run" at a time.      countDoneThisRun ¬ 0;      UNTIL (countDoneThisRun >= sectorsPerRun) DO        beginningAddress: FloppyChannel.DiskAddress = [cylinder, head, sector];	tempIocb.address ¬ [cylinder, head, sector];	tempIocb.dataPtr ¬ pointer + PagesToWords[countDoneThisRun];	tempIocb.tries ¬ FloppyDiskFace.SuggestedTries[tempIocb.device];	tempIocb.count ¬ sectorsPerRun - countDoneThisRun;	[result, , ] ¬ SpecialFloppyChannel.DoDirectIO[tempIocb];		-- temporary hack for Daybreak Tapes due to a bug in the head.	«-- tempIocb got updated by head/handler	countDoneThisRun ¬ sectorsPerRun - tempIocb.count;»       	IF (result # goodCompletion) THEN	  countDoneThisRun ¬ CARDINAL[FloppyTapeInternal.GetCountDone[	    FloppyTapeFormat.DiskAddressToSector[	      beginningAddress,	      FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	      FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	      FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack],	    tempIocb]]	ELSE	  countDoneThisRun ¬ sectorsPerRun - tempIocb.count;		status ¬ FilterStatus[result];	-- However, recordNotFound is possible to get out of this	-- and these needs to be taken care of.  (recordNotFound means some	-- formatting problem)	SELECT status FROM	  goodCompletion => 	    cylinder ¬ cylinder + (sectorsPerRun /	      FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack);	  otherError     =>	    BEGIN	    status ¬ SpecialFloppyChannelExtras.Retention[	      FloppyTapeInternal.volumeDesc.fcHandle];	    IF status = goodCompletion THEN LOOP	    ELSE	      BEGIN	      CleanUp[];	      ERROR FloppyTape.Error[hardwareError];	      END;	    END;	  recordNotFound => ERROR FloppyTape.Error[hardwareError];	    -- recordNotFound on write possible here	  ENDCASE        => ERROR FloppyTape.Error[hardwareError];      ENDLOOP;    ENDLOOP;  --writing of data--    -- now verify the writing of the data    tempIocb.function ¬ readSector;    tempIocb.incrementDataPointer ¬ FALSE;    cylinder ¬ startCylinder;    UNTIL cylinder >= endCylinder DO      Process.Pause[FloppyTapeInternal.minNumTicks];  -- allow aborts      sector ¬ 1;      countDoneThisRun ¬ 0;            UNTIL (countDoneThisRun >= sectorsPerRun) DO        beginnningSector: FloppyChannel.DiskAddress = [cylinder, head, sector];	tempIocb.function ¬ readSector;	tempIocb.address ¬ [cylinder, head, sector];	tempIocb.dataPtr ¬ pointer;  -- just keep reading into same page	tempIocb.tries ¬ FloppyDiskFace.SuggestedTries[tempIocb.device];	tempIocb.count ¬ sectorsPerRun - countDoneThisRun;	[result, , ] ¬ SpecialFloppyChannel.DoDirectIO[tempIocb];		-- temporary hack for Daybreak Tapes due to a bug in the head.	«-- tempIocb got updated by head/handler	countDoneThisRun ¬ sectorsPerRun - tempIocb.count;»	IF (result # goodCompletion) THEN	  countDoneThisRun ¬ CARDINAL[FloppyTapeInternal.GetCountDone[	    FloppyTapeFormat.DiskAddressToSector[	      beginnningSector,	      FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	      FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	      FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack],	    tempIocb]]	ELSE	  countDoneThisRun ¬ sectorsPerRun - tempIocb.count;	status ¬ FilterStatus[result];        SELECT TRUE FROM	  status = goodCompletion =>	    cylinder ¬ cylinder + (sectorsPerRun /	      FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack);	  status = otherError =>	    BEGIN	    status ¬ SpecialFloppyChannelExtras.Retention[	      FloppyTapeInternal.volumeDesc.fcHandle];	    IF status = goodCompletion THEN LOOP	    ELSE	      BEGIN	      CleanUp[];	      ERROR FloppyTape.Error[hardwareError];	      END;	    END;  --status = otherError--	  IsItABadPageError[status] => BEGIN	    diskSector ¬ FloppyTapeFormat.DiskAddressToSector[	      [cylinder: cylinder, head: 0,  sector: 1],	      FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	      FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	      FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack]	      + countDoneThisRun;	    -- MarkBadSectorEntryInternal will take care of incrementing	    -- numberOfBadPages, if needed.  We must be prepared to CleanUp if	    -- an error is raised.	    MarkBadSectorEntryInternal[beforeFileWritten, diskSector !	      FloppyTape.Error => CleanUp[]];	    countDoneThisRun ¬ countDoneThisRun + 1;	    [cylinder: cylinder, head: head, sector: sector] ¬	      FloppyTapeFormat.SectorToDiskAddress[	      diskSector + 1,	      FloppyTapeInternal.volumeDesc.rootPage.numberOfStreams,	      FloppyTapeInternal.volumeDesc.rootPage.numberOfTracks,	      FloppyTapeInternal.volumeDesc.rootPage.sectorsPerTrack].diskAddress	    END  --IF IsItABadPageError--	  ENDCASE => BEGIN	    CleanUp[];	    ERROR FloppyTape.Error[hardwareError];	    END;      ENDLOOP;        ENDLOOP;   --verifying data--     CleanUp[];    EXITS      notReady => {CleanUp[]; ERROR FloppyTape.Error[notReady]};      aborted => {CleanUp[]; ERROR ABORTED};    END;  --ENABLE ABORTED--    END;  --WriteDataInReservedArea--  WriteFile: PUBLIC PROCEDURE [    volume: FloppyTape.VolumeHandle, type: File.Type,    scatteredVM: FloppyTape.ScatteredVM]     RETURNS [fileId: FloppyTape.FileID] =    BEGIN    savedError: FloppyTape.ErrorType;    previousResult: FloppyChannel.Status;    scatteredCount: FloppyTape.ByteCount ¬ 0;    special: BOOLEAN ¬ FALSE;        BufferMarkerPage: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      -- Write out buffer if it cannot fit marker page with this file.      -- However, this probably isn't necessary anymore...Note that when      -- this line of code is changed, both the Environment.wordsPerPage AND      -- the >= should be taken out (should just be >), since this currently      -- allows  FloppyTapeInternal.residentBufferSize,      -- FloppyTapeInternal.residentBufferSize-1, and      -- FloppyTapeInternal.residentBufferSize-2 as calls to DoAsyncIO.      IF (bufferIndex+FloppyTapeFormat.MarkerPageSize+Environment.wordsPerPage) >=	  PagesToWords[FloppyTapeInternal.residentBufferSize] THEN	BEGIN	[, previousResult] ¬ DoAsyncIO[	   CARDINAL[FloppyTapeInternal.WordsToPages[bufferIndex]], 	   buffer, @ioLock];	SwitchBuffers[];	  -- make sure we switch buffers (to reset bufferIndex) before we could	  -- raise an error	IF previousResult # goodCompletion THEN       	  FloppyTapeInternal.ReportErrorToClient[previousResult];	END;      -- buffer the marker page      LOOPHOLE[buffer+bufferIndex,LONG POINTER TO FloppyTapeFormat.MarkerPage]­ ¬        [seal: FloppyTapeFormat.MarkerSeal, 	version: FloppyTapeFormat.MarkerPageVersion, 	file: fileId, type: type, 	logicalSize: scatteredCount + markerByteSize, 	timeStamp: System.GetGreenwichMeanTime[], 	markerPageType: file, pad: ALL[0]];      bufferIndex ¬ bufferIndex + FloppyTapeFormat.MarkerPageSize;      END;        UpdateVolumeDescForWrite: ENTRY PROCEDURE [ml: LONG POINTER TO MONITORLOCK] =      BEGIN ENABLE UNWIND => NULL;      IF ~FloppyTapeInternal.volumeDesc.open THEN        RETURN WITH ERROR FloppyTape.Error[invalidVolumeHandle];      IF FloppyTapeInternal.volumeDesc.writeProtected THEN         RETURN WITH ERROR FloppyTape.Error[writeInhibited];      FOR i: CARDINAL IN [0..scatteredVM.length) DO	scatteredCount ¬ scatteredCount + scatteredVM[i].count;	ENDLOOP;      IF (FloppyTapeInternal.volumeDesc.rootPage.currentEOT + markerPageSize + 	FloppyTapeInternal.BytesToPages[scatteredCount] > 	FloppyTapeInternal.BytesToPages[FloppyTapeInternal.volumeDesc.size]) THEN	  RETURN WITH ERROR FloppyTape.Error[insufficientSpace];      fileId ¬ FloppyTapeInternal.volumeDesc.rootPage.nextUnusedFileID;      FloppyTapeInternal.volumeDesc.rootPage.lastFileID ¬ fileId;      FloppyTapeInternal.volumeDesc.rootPage.nextUnusedFileID ¬   	FloppyTapeInternal.ConvertSectorToFileID[ 	FloppyTapeInternal.ConvertFileIDToSector[	  FloppyTapeInternal.volumeDesc.rootPage.nextUnusedFileID] +	  FloppyTapeInternal.BytesToPages[scatteredCount] + markerPageSize];      --FloppyTapeInternal.volumeDesc.currentPosition ¬        -- FloppyTapeInternal.volumeDesc.rootPage.currentEOT;      FloppyTapeInternal.volumeDesc.rootPage.currentEOT ¬  	FloppyTapeInternal.ConvertFileIDToSector[	FloppyTapeInternal.volumeDesc.rootPage.nextUnusedFileID];      END;    WriteFileMain: FloppyTapeInternal.OperationProc =      BEGIN ENABLE FloppyTape.Error => {savedError ¬ error; GO TO errorExit};      IF ~IsVolumeOpen[@FloppyTapeInternal.volumeDescLock] THEN 	RETURN WITH ERROR FloppyTape.Error[invalidVolumeHandle];      FloppyTapeInternal.ValidateHandle[volume];      UpdateVolumeDescForWrite[@FloppyTapeInternal.volumeDescLock !        FloppyTape.Error => IF error = insufficientSpace THEN special ¬ TRUE];	-- want to special case insufficientSpace out of here since we really	-- don't want to close volume and require a scavenge at this point.	-- However, if buffering any of these pages causes an insufficientSpace,	-- then do want to require a scavenge  since something may have already	-- made it out to tape.      BufferMarkerPage[@bufferLock !        -- the following is a hack to make sure we do NOT close the tape	-- on a badTape so that the directory may try to be written out	FloppyTape.Error => IF error = badTape THEN special ¬ TRUE];      BufferFile[scatteredVM, scatteredCount, @bufferLock !        -- the following is a hack to make sure we do NOT close the tape	-- on a badTape so that the directory may try to be written out	FloppyTape.Error => IF error = badTape THEN special ¬ TRUE];      EXITS        errorExit => {	  ForceOutBuffers[@bufferLock ! FloppyTape.Error => CONTINUE];	  IF ~special THEN FloppyTapeInternal.CloseVolumeInternal[];	  ERROR FloppyTape.Error[savedError]};      END;  --WriteFileMain--    FloppyTapeInternal.DoOperation[      @FloppyTapeInternal.operationLock, WriteFileMain, writeFile];    END;      -- Module initialization    myIocb ¬ FloppyTapeInternal.AllocIOCB[FloppyDiskFace.operationBlockLength];  [] ¬ Process.Detach[FORK DoAsyncIOHelperProcess[]];  END.  LOG  10-Feb-87 17:26:30	ET	Created file.19-Feb-87  7:08:09      ET      Grossed out procedures using CloseVolumeInternal and ForceOutBuffers to get monitor locking to work. Initialize bufferIndex. Better pin my iocb! And twiddles.20-Feb-87  7:56:24      ET       DebugTouch added for testing Read operations greater than 256 pages.23-Feb-87 19:19:03      ET       Fixed ReadFile and RewriteFile to not call GetFileAttributes until the ForceOut is done. And more twiddles.  Picked up Scavenge from FloppyTapeImplA. DebugTouch removed for testing. 2-Mar-87 18:08:44	ET	Append always does ForceOut workaround. AppendFile  updates currentEOT in rootpage correctly if doing more than one append per file. Added ReservedDiagnosticArea for RSV. 9-Mar-87 17:51:27	ET/RSV	Implemented SearchBufferForFileSize.  Fixed up some possible monitor locks. WriteDataInReservedArea should do loop on >=, not just >. Changed cache entry during AppendFile.13-Mar-87  7:57:43      ET     Twiddles and some for bad sector handling in DoSynchIO and MoveTheBits. Made MissingPages translate to IOError for client.13-Mar-87 17:35:07	ET	Fix fileNotFound during AppendFile on big writes of files.23-Mar-87 20:03:32	ET/RSV	Fix to DoAsynchIOHelperProcess for using lastEOTonTape. Fix to RealFileIDLoc to take into account bad sectors after current sector and before new calculated one AND to start checkind bad sectors from firstDataAddress. Fixed up CheckBadSectorList not to bomb out if Diagnostic cylinders have been reserved already.  Also broke out a MarkBadSectorEntryInternal procedure.  Fixed up WriteDataInReservedArea to continue even if there are bad sectors.  Finally, don't let InternalIOError propogate up to clients.26-Mar-87 17:43:22	RSV	Fix MarkBadSectorEntryInternal so that it doesn't write the same page number to the table n times.30-Mar-87 16:50:48	ET	Have SearchOurBuffer...look in both buffers.21-May-87  8:31:36	ET	Fix AR 10912: [notFormattted] error after IOError. Fix AR 10825: RewriteFile failed to raise [insufficientSpace]. And Bug: SearchOurBuffer....address faults if bogus file gets passed in...added NIL check.29-May-87  8:28:45	ET	Merged in RSV's edits I lost from:  (4-May-87 12:18:29      RSV)     Don't always assign fcHandle ¬ FloppyChannel.nullHandle so that we can cache GetNextBadSector information.  Use ReadRootAndBadSectorList19-Jun-87 11:35:16      RSV     Modified WriteDataInReservedArea to do direct IO, instead of using the channel.  Moved RealFileIDLoc to FloppyTapeImplB.  Be able to handle errors on writing of data, not just reading.  Added abortable ReserveDiagnosticArea.  Moved AllocIOCB to FloppyTapeImplB.  Don't CloseVolumeInternal on FloppyTape.IOError's, only on FloppyTape.Error's.  Catch FloppyChannel.Error[invalidHandle].27-Jun-87 15:36:27      RSV     GetDeviceHandle is now exported to FloppyTapeInternal. 9-Jul-87 10:55:03      RSV     MarkBadSectorEntryInternal is now public.14-Jul-87 23:48:30      RSV     Added DoOperation stuff.20-Jul-87 11:23:02      RSV     Fixed AR 11367 in MoveTheBits and fixed a monitor lock in AppendFile.23-Jul-87 11:52:58      RSV     Acquire monitor lock when looking at writeProtected in DoSynchIO.  Also implemented volumeDesc.verifyAfterWrite.30-Jul-87 17:03:15      RSV     Catch DiskChanged where needed.  Fix monitor lock situations in WriteFile and AppendFile.12-Aug-87 14:02:16      RSV     Fixed DoSynchIO to set countToCopy before using it.17-Sep-87 18:18:57      RSV     Public GetRealPosition.  Fixed up messages to have badTape status.  Set badTape appropriately in other place which use messages.22-Sep-87 19:53:59      RSV     Set priority of AsynchIOHelperProc to background.25-Sep-87 12:26:57      RSV     Use volumeDesc.drive instead of localDrive. 7-Oct-87 16:32:00      RSV     SpecialFloppyChannelExtras.GetDeviceHandle instead of local version of GetDeviceHandle.  EXIT from Nop loops instead of NULL on goodCompletion.22-Oct-87 13:46:32      RSV     Fix DoAsyncIO to stop when hitting an error.  Don't close the volume (and thus require a scavenge) when we hit insufficientSpace in some instances in AppendFile and WriteFile.  Moved ForceOut to FloppyTapeImplD.  Bump priority of AsynchIOHelperProc to priorityForeground (assumes the rest is at normal!!!)20-Nov-87 10:11:20      RSV     Try to save 30 minutes per tape by mucking with DoAsynchIOHelperProc. 3-Dec-87 21:06:15      RSV     When on a verify pass, handle things so that you don't zero out the original buffer (modified MoveTheBits, DoSynchIO, and SetUpIORequest).  PUBLIC GetWriteProtectStatus27-Jan-88 14:30:38      RSV     Fix AR 12687 in DontCrossStream. 5-Feb-88 10:10:02      RSV     Fix AR 12754 in ReserveDiagnosticArea 3-Jun-88 12:09:32      RSV     Added code in MoveTheBits and WriteDataInReservedArea (2x) for temporary hack for Daybreak Tape problems resulting from AR 13249 against the Daybreak heads.  Made ReportErrorToClient public and moved Retention to FloppyTapeImplD (cause of storage overflow).27-Dec-88 15:38:44      RSV     Added temporary globals lastConsecutiveBadPage, countConsecutiveBadPages, and maxConsecutiveBadPages, plus temporary code in procedures MarkBadSectorEntryInternal and WriteDataInReservedArea to find specified number of bad pages in a row and then raise badTape.  Also the previous procedures were modified so as not to bump the count of bad pages over the maximum number of bad pages allowed (so that subsequent opens still work).  Temporary code added to AppendFileMain, ReadOrRewrite, and WriteFileMain so that the volume is NOT closed on raising badTape, so that the directory can be forced out.  Moved ReportErrorToClient to FloppyTapeImplD.  Moved resetting of bufferIndex before we could possibly exit ForceOutBuffers (instead of at end of procedure).  Also do the switch buffers in BufferMarkerPage and BufferFile before we could raise an error (once again, so that we reset bufferIndex no matter what).
-- Copyright (C) 1986, 1987  by Xerox Corporation. All rights reserved. -- FloppyTapeFormat.mesa	 RSV	  20-Sep-87 19:32:04	DIRECTORY   Boot USING [PVBootFiles],   Environment USING [LongNumber, wordsPerPage],   File USING [Type],   FloppyTape USING [FileID, maxBytesInName, SectorNumber],   FloppyChannel USING [Context, DiskAddress],   Inline USING [DIVMOD, HighHalf, LongDivMod, LongMult, LowHalf],   SpecialFloppyTape USING [BootFilePointer],   System USING [GreenwichMeanTime];FloppyTapeFormat: DEFINITIONS   IMPORTS Inline  =  BEGIN    -- Types, constants, and variables    -- sectors are numbered [1..sectors per track] and that  -- Sector 0 is unused while Sector 1 is address [stream: 0, track: 0, sec: 1]  firstSector: FloppyTape.SectorNumber = 1;  -- the proper floppy channel context for floppy tapes  floppyTapeContext: FloppyChannel.Context =    [protect: FALSE, format: IBM, density: double, sectorLength: 256];  -- mark put on the tape during a security erase  eraseWord: CARDINAL = 0FFFFH;    -- mark put on the tape during a format  formatWord: CARDINAL = 0FFFFH;  -- root page     FloppyTapeSeal: CARDINAL = 141414B; -- must not change  FloppyTapeVersion: CARDINAL = 1;  -- change when layout of track 0 changes    rootPageSector: FloppyTape.SectorNumber = 1;  rootPageDiskAddress: FloppyChannel.DiskAddress = [0,0,1];    RootPageSize: [256..256] = SIZE[RootPage];    RootPage: TYPE = MACHINE DEPENDENT RECORD [     -- less variable items     seal (0): CARDINAL ¬ FloppyTapeSeal,     version (1): CARDINAL ¬ FloppyTapeVersion,     numberOfStreams (2): CARDINAL,     numberOfTracks (3): CARDINAL,     sectorsPerTrack (4): CARDINAL,     -- more variable items      initialMicrocode(5): SpecialFloppyTape.BootFilePointer ¬        [LOOPHOLE[LONG[0]], 0],     pilotMicrocode (9): SpecialFloppyTape.BootFilePointer ¬        [LOOPHOLE[LONG[0]], 0],     diagnosticMicrocode (13): SpecialFloppyTape.BootFilePointer ¬        [LOOPHOLE[LONG[0]], 0],     germ (17): SpecialFloppyTape.BootFilePointer ¬        [LOOPHOLE[LONG[0]], 0],     pilotBootFile (21): SpecialFloppyTape.BootFilePointer ¬        [LOOPHOLE[LONG[0]], 0],     clientWord(25): WORD ¬ LOOPHOLE[0],     -- most variable items     currentEOT (26): FloppyTape.SectorNumber,     lastFileID (28): FloppyTape.FileID,     nextUnusedFileID (30): FloppyTape.FileID,     numberOfBadPages (32): CARDINAL,     changing (33: 0..0): BOOLEAN ¬ FALSE,     pad (33: 1..15): CARDINAL [0..77777B) ¬ 0,     -- and for our file system client's usage     rootFile (34): FloppyTape.FileID ¬ LOOPHOLE[LONG[0], FloppyTape.FileID],       --FloppyTape.nullFileID     labelSize (36) : CARDINAL ¬ 0,     label (37): PACKED ARRAY [0..FloppyTape.maxBytesInName) OF CHARACTER ¬ ALL[' ],     -- Reserved for future expansion. MUST be zero!     spare (87): ARRAY [0..Environment.wordsPerPage-87) OF WORD ¬ ALL[0]];         -- bad sector table     badSectorListSector: FloppyTape.SectorNumber = 2;  badSectorListSize: CARDINAL = 2; -- length in sectors (pages)    BadSectorList: TYPE = LONG POINTER TO BadSectorListArray;  BadSectorListArray: TYPE = ARRAY [0..maxNumberBadSectors) OF BadSectorEntry;    maxNumberBadSectors: CARDINAL = badSectorListSize *    (Environment.wordsPerPage / SIZE[BadSectorEntry]);    BadSectorType: TYPE = {beforeFileWritten, afterFileWritten, spare1, spare2};  BadSectorEntry: TYPE = MACHINE DEPENDENT RECORD [    badSectorLow(0:0..15): FilePageLow,    badSectorHigh(0:16..29): FilePageHigh,    typeOfBadPage(0:30..31): BadSectorType];      FilePageLow: TYPE = CARDINAL;  -- since Mesa will not pack 30 bit fields.  FilePageHigh: TYPE = CARDINAL [0..16384);         -- marker pages    MarkerSeal: CARDINAL = 031313B;  -- must not change  MarkerPageVersion: CARDINAL = 1; -- change  when layout of marker page changes    MarkerPageSize: [256..256] = SIZE[MarkerPage];      MarkerPageEntryType: TYPE =     MACHINE DEPENDENT {free(0), file (1), (177777B)};    MarkerPage: TYPE = MACHINE DEPENDENT RECORD [     seal (0): CARDINAL ¬ MarkerSeal,     version (1): CARDINAL ¬ MarkerPageVersion,     file (2): FloppyTape.FileID,     type (4): File.Type,     logicalSize (5): LONG CARDINAL,     timeStamp(7): System.GreenwichMeanTime,  --?     markerPageType (9): MarkerPageEntryType,     pad(10): ARRAY [0..Environment.wordsPerPage-10) OF WORD ¬ ALL[0]];  -- boot page     BootPageFormat: TYPE = MACHINE DEPENDENT RECORD [    pad(0): ARRAY [0..10B) OF WORD ¬ ALL[0],    bootingInfo(10B): Boot.PVBootFiles];  -- locations    InitialMicrocodeDiskAddress: FloppyChannel.DiskAddress =    [cylinder: 0, head: 0, sector: 6];         BootPageDiskAddress: FloppyChannel.DiskAddress =    [cylinder: 0, head: 0, sector: 32];         firstDataAddress: FloppyChannel.DiskAddress =     [cylinder: 1, head: 0, sector: 1];      firstDiagnosticCylinder: FloppyChannel.DiskAddress =    [cylinder: 1225, head: 0, sector: 1];          -- Inline procedures    SectorToDiskAddress: PROCEDURE [  -- IS THIS STILL CORRECT? --     sector: FloppyTape.SectorNumber, streams: CARDINAL,    tracksPerStream: CARDINAL, sectorsPerTrack: CARDINAL]    RETURNS [diskAddress: FloppyChannel.DiskAddress] = INLINE    BEGIN    temp: CARDINAL;    [quotient: temp, remainder: diskAddress.sector] ¬ Inline.LongDivMod[sector-1, sectorsPerTrack];    diskAddress.sector ¬ diskAddress.sector + 1; -- sectors begin at 1 --    [quotient: diskAddress.cylinder, remainder: diskAddress.head] ¬       Inline.DIVMOD[temp, tracksPerStream];    END;    DiskAddressToSector: PROCEDURE [      diskAddress: FloppyChannel.DiskAddress, streams: CARDINAL,    tracksPerStream: CARDINAL, sectorsPerTrack: CARDINAL]    RETURNS [sector: FloppyTape.SectorNumber] = INLINE {    sector ¬       diskAddress.sector +      Inline.LongMult[        sectorsPerTrack,	(diskAddress.head + tracksPerStream * diskAddress.cylinder)]};	     PackBadSectorNumber: PROCEDURE [low: FilePageLow, high: FilePageHigh]    RETURNS [page: FloppyTape.SectorNumber] = INLINE {    RETURN[      LOOPHOLE[Environment.LongNumber[num[lowbits: low, highbits: high]]]]};        UnpackBadSectorNumber: PROCEDURE [sector: FloppyTape.SectorNumber]    RETURNS [low: FilePageLow, high: FilePageHigh] = INLINE {    RETURN[low: Inline.LowHalf[sector], high: Inline.HighHalf[sector]]}  END.LOG23-Dec-86 19:24:09    ET      Created file31-Dec-86 15:48:18    RSV     Syntactic change to MarkerPage.  Added gaps to RootPage (temporarily).  Also can't use FloppyTape.nullFileID here since you it doesn't have permanent value.  Changed module name to FloppyTapeFormat.  Added floppyTapeContext. 5-Jan-87 10:39:35    RSV     Added rootPageSector, badSectorListSector.16-Jan-87 10:59:22    RSV     Deleted SectorNumber and nullSectorNumber.18-Jan-87 16:22:23    RSV     Added clientWord to RootPage.23-Jan-87 14:39:48    RSV     Changed boot file pointer form SectorNumber to BootFilePointer.  Added entry for initial microcode.  Added firstSector.  Added rootPageDiskAddress. 8-Feb-87 18:24:45    ET      Changed badSector Table definition, currentEOT type to SectorNumber.13-Feb-87 11:25:21    ET      LongMult to DiskAddressToSector.19-Feb-87 16:53:09    RSV     Added BootPageFormat and tracksPerStream.21-Feb-87 12:38:04    RSV     Added firstDiagnosticCylinder.22-Mar-87  0:00:28    RSV     Deleted tracksPerStream (info now gotten from head). 9-Jul-87 10:30:35    RSV     Added eraseWord.20-Sep-87 19:32:04    RSV     Format and erase codes now FFFFH
$MOD186$PAGELENGTH (47)$PAGEWIDTH (142);;-- file RS232Hdl.ASM;Copyright (C) 1984, 1985, 1986, 1987, 1988, 1989 by Xerox Corporation. All rights reserved.;-- Last Edited by:	GRG	18-Aug-90 16:05:10	: Turned off interrupts in RsRxCatchData procedure;							: to allow safe updating of catch buffer counter.  This;							: prevents BadRxInterrupt from coming in.  SPAR 219.;-- Last Edited by:	LLHH	 9-Aug-89 15:50:20	: The test for frame timeout in BadRxInterrupt was wrong.;							: (It should have been checking;							: rsRxBufferFrameTimeout = TRUE not rsRxFrameTimeOutValue = 0);-- Last Edited by:	LLHH	25-Jan-88 15:10:44	: moved release of rsRxActiveBuffer to RsRxComplete so that the flag;							: is not active across calls to WaitForSystem.  Also corrected;							: check for frame timeout option in the bad receive interrupt routine;							: BadRxInterrupt (RsBadRxInt);							: SS ar# 12222;-- Last Edited by:	DMS	31-Oct-85 11:28:26	: Added new task to allow frame timeout to be in mSecs.;-- Last Edited by:	DMS	21-Oct-85 09:45:22	: Parity bit stripping fixed;-- Last Edited by:	DMS	27-Sep-85 11:44:47	: Fixed code so buffer can go to next page;-- Last Edited by:	DMS	 9-Sep-85 13:51:58	: disabled interrupts during reg.writes;-- Last Edited by:	JPM	12-Aug-85  9:22:09	: Change IOPEInRAM alignment to WORD.;-- Last Edited by: 	DMS	 8-Aug-85 15:20:51	: FrameTimeout/Variable WatchDog;-- Last Edited by: 	JPM  	 8-Aug-85  8:50:50	: Opie redesign conversion;-- Last Edited by: 	DMS  	 7-Aug-85 13:22:19	: added frametimeout code though it is still commented out ;  ;................................................................; Important Notes:;	The Opie Macros Enable and Disable will not work with Rs232c handler;;      PORT # 		READ			   	  WRITE;	40H	Ch A(DTE) Rx Data (Rs232c Port)		Ch A Tx Data;	444H	Ch A(DTE) Status (Rs232c Port)		Ch A Cmd/Parm;;	The Interrupt Vector Mode table is set as follows:;	0	Tx Buffer Empty Int (Ch B);	1	Ext/Status Change Int (Ch B) ** Not implemented;	2	Rx Char. available Int (Ch B);	3	Special Rx condition [Parity,overrun,EndOfFrame] (Ch B);	4	Tx Buffer Empty Int (Ch A);	5	Ext/Status Change Int (Ch A);	6	Rx Char. available Int (Ch A);	7	Special Rx condition [Parity,overrun,EndOfFrame] (Ch A);		**************************************;;		BAUD RATE CLOCKS FOR Rs232c Port;The programmable interval timer which provides the clock to the MPSC chip is an ;i8254 (input clock =6 Mhz);;     PORT #		READ			   WRITE;	;	20H	Timer Counter ;0 (DTE/A)	Timer Counter 0;	26H	--------------			Timer Mode Control;	**************************************;;;  	PORT ADDR			WRITE Only;	80H = 0200H		Select Ch A to use internal clock else clock must be;				provided by DCE device.;	PORT ADDR			READ ONLY;	80H = 0400H		rs232c Port Ch A DSR (active Low);	80H = 0200H		rs232c Port Ch A Rind Indicator (active Low);----------------------------------------------------------------------------	$NOLIST$INCLUDE		(RSIOFace.asm)$INCLUDE		(RSHDFace.asm)$INCLUDE		(HardDefs.asm)$INCLUDE		(QueMacro.asm)$INCLUDE		(IOPMacro.asm)$INCLUDE		(RamEEP.asm)$INCLUDE		(OpieDefs.asm)$LIST;----------------------------------------------------------------------------NAME		RS232HDL;PUBLIC		RS232CInitEXTRN		RS232CHandlerID:	ABSEXTRN		RS232TxInterrupt:	ABSEXTRN		RS232ExtStatInterrupt:	ABSEXTRN		RS232RxInterrupt:	ABSEXTRN		RS232SpecRxInterrupt:	ABS;================================================================================;;	IOREGION SEGMENT;================================================================================RS232CIOR	SEGMENT	COMMONEXTRN		rs232CFCB: 		RS232CFCBRecordEXTRN		rs232DCB: 		RS232DCBRecordEXTRN		rs232HdlOnly:		RS232HdlOnlyRecordRS232CIOR	ENDS;================================================================================;;	STACK SEGMENT;================================================================================RS232CSTK	SEGMENT	COMMONEXTRN		RS232CMainStack: 	WORDEXTRN		RS232CTxStack: 		WORDEXTRN		RS232CSpecRxStack: 	WORDEXTRN		RS232CRxStack: 		WORDEXTRN		RS232CExtStatStack: 	WORDEXTRN		RS232CWatchStack:	WORDRS232CSTK	ENDS;================================================================================;  OPIEIOROpieIOR			SEGMENT	COMMONEXTRN			systemQueue: IOPEQueueOpieIOR			ENDS;================================================================================;  IOPELocalRAMIOPELocalRAM		SEGMENT	AT 0EXTRN			IORSegmentTableAddress: SegmentAndOffsetEXTRN			IOROpieSegmentAddress: WORDIOPELocalRAM		ENDS;================================================================================;  OpieIORinRAMOpieIORinRAM		SEGMENT	WORD COMMONEXTRN			RS232RxICB:	InterruptContextBlockOpieIORinRAM		ENDSOpieIORComplete		GROUP	OpieIOR, OpieIORinRAM;;================================================================================;;	RS232C HANDLER CODE SEGMENT;================================================================================IOPEInRAM	SEGMENT	WORD PUBLIC		ASSUME	CS:IOPEInRAM;--------------------------------------------------------------------------------;$EJECT;;--------------------------------------------------------------------------------;										;        RS232c Initialization Task for OPIE						-;--------------------------------------------------------------------------------RS232CInit	 PROC FAR	%InitializeTask (RS232CHandlerID,OFFSET rs232HdlOnly.rsWatchDogTcb, RsWatchDogTask,OFFSET RS232CWatchStack)	%InitializeTask (RS232CHandlerID,OFFSET rS232CFCB.rS232CMainTaskTcb, RS232CMainTask,OFFSET RS232CMainStack)	%InitializeTask (RS232CHandlerID,OFFSET rS232CFCB.txTaskChATcb, TxTaskChA,OFFSET RS232CTxStack)	%InitializeTask (RS232CHandlerID,OFFSET rS232CFCB.specRxTaskChATcb, SpecRxTaskChA,OFFSET RS232CSpecRxStack)	%InitializeTask (RS232CHandlerID,OFFSET rS232CFCB.rxTaskChATcb, RxTaskChA,OFFSET RS232CRxStack)	%InitializeTask (RS232CHandlerID,OFFSET rS232CFCB.extStatTaskChATcb, ExtStatTaskChA,OFFSET RS232CExtStatStack)	RETRS232CInit ENDP	;		ASSUME  DS:RS232CIOR;;................................................................................;										;	INTERRUPT-DRIVEN Tx/Rx RS232C COMMAND TASKS			;................................................................................;; RS232C Main task is triggered by a notify from the RS232C Mesa Head when there; is work to be done.  Work can be a request to change parameter registers, transfer; characters, or abort a transfer or receive.  After the work has been done,; rs232c FCB status is updated, work to do flag is cleared and the client (RS232CDriver); is notified.;RS232CMainTask:	%DisableInterruptsTillNextWait	%Jam (RS232CHandlerID, OFFSET rs232HdlOnly.rsWatchDogTcb)	CALL	RS232CParmInit   RS232CMainTaskLoop:	%WaitForCondition (OFFSET  rS232DCB.rs232ChAWork,noTimeout)	CALL	RSCheckWorkList	CALL	RSCheckCommandList	CALL	ReadAllStatusRegisters		;UpDate Read Regs in FCB	%MesaLockedOut(AND, OFFSET rs232DCB.rsCommandWorkList, noCommandInProgress, rs232CFCB.rs232LockMask)	%NotifyClientCondition(rs232DCB.rsClientConditionChA)  RSWorkExit: 	JMP	RS232CMainTaskLoop;*******************************************************************************;...............................................................................;									       .; 		MAIN LOOP TO TRANSMIT OVER THE COMM PORT 		       .;...............................................................................;; Rs232c Transfer task (Tx) is triggered via a notify from the RS232c Main task.; The task aquires the IOCB and buffer via OPIE macros, then checks if flowControl; has been selected and if the mode is asynchronous, if so and if the Xoff flag has; been set must wait for the Xon before characters can be sent.  The wait has a timeout; in order to allow the transfer to be aborted by client.  When all is clear then the; character is moved from the client's buffer to the 8274 output port, then the task; waits for a TxBufferEmpty interrupt from the 8274.  If the interrupt does not come; before the OPIE watch dog time then the BadTxInterrupt routine is called and the ; transfer ends with status disaster, otherwise the character is considered transfered,; the counters are updated, and another character is transfered untill requested bytes; are transfered.  If flowcontrol has been selected then before each character is ; transfered Xoff status is checked. If mode is bitsync then after all characters are tx'ed; a TxIntReset command is performed which signals the chip to transfer the CRC bytes.; The task waits for a txBufferEmpty interrupt to occur which singifies that that the flag; has been transfered.  Then for both modes a TxIntReset command is performed, IOCB statuses; and FCB statuses are updated, the rs232c global variables are reset, the Client is notified; that the transfer is compelete and the queue is advanced.  If nothing else is on the; queue then the task waits for another notify from rs232c main task, else next iocb; in the queue is serviced. ;TxTaskChA:	%ThisTaskServices (RS232TxInterrupt, BadTxInterrupt)TxTaskWorkLoop:	%WaitForCondition(OFFSET rS232DCB.TxChAWork,noTimeout)TxTaskWorkStartIOCB:	CMP	rs232HdlOnly.rsSendFlowRequest, TRUE	JNE	TxTaskCheckForIOCB	MOV	AL, rs232HdlOnly.rsFlowSendByte	MOV	rs232HdlOnly.rsSendFlowRequest, FALSE	%DisableInterruptsTillNextWait	OUT	i8274DCommADataAddr, AL		%WaitForInterrupt (rsTxBufEmptyWaitTime)       	JNC	TxTaskCheckForIOCB	JMP	RsTxIntTimeout	TxTaskCheckForIOCB:	%JumpIfMesaIOCBNextNil(rs232cFCB.rsQueueTxChA.queueNext, TxTaskWorkLoop)	;------------------------------------------------	; Set up access to IOCB	;Running at sytem level here	MOV	rs232HdlOnly.rsTxActiveBuffer, TRUE	%EstablishIOPAccess (generalMapRegister, rs232CFCB.rsQueueTxChA.queueNext)	MOV	AX, ES:[DI].rsBufferSize	MOV	rs232HdlOnly.rsBytesToTransfer, AX	MOV	ES:[DI].rsActiveIOCB, TRUE	PUSH	ES	PUSH	DI	MOV     CX, ES:[DI].rsBufferPtr.OpieAddressHigh	MOV     DX, ES:[DI].rsBufferPtr.OpieAddressLow	PUSH    CX	PUSH    DX	; CX and DX must be perserve	;Setting up access to dataBuffer	%EstablishIOPAccess (comSendMapRegister,CX-DX)	POP     DX	POP     CX	CALL	RsFigureBytesTillNextPage	;------------------------------------------------	; Flow Control Check	MOV	rs232HdlOnly.rsCheckFlowControl, FALSE			;Initialize checkFlowFlag to FALSE	CMP	rs232DCB.rs232Mode, asynch	JNE	RsTxSDLCMode	CMP	rs232DCB.rs232flowControl.flowType, none	;FlowControl?	JE	RsTxSendByte					;No then branch	MOV	rs232HdlOnly.rsCheckFlowControl, TRUE					;set check flag TRUE	;------------------------------------------------	;-- Flow Control Check loop	TxTaskByteLoop:	 ;-- Flow Control Check loop	CMP	rs232HdlOnly.rsFlowOff, TRUE 		;Status = XOFF ?	JNE	RsTxSendByte			;No THEN Branch	MOV     AL, serialCmd5			;Reset Tx interrupts	OUT	i8274DCommACtlrAddr, AL	PUSHA	%WaitForCondition (OFFSET rS232DCB.TxChAWaitXOn,noTimeout)	POPA	JMP	TxTaskByteLoop		;------------------------------------------------RsTxSDLCMode:	%DisableInterruptsTillNextWait					MOV	AL, i8274CommCRCRstTx	OUT	i8274DCommACtlrAddr, AL		MOV	AL, ES:[DI]		;Output first character in SDLC mode	OUT	i8274DCommADataAddr, AL			MOV	AL, i8274RstTxUndEOM		;Reset Transmit Underrun/EOM Latch	OUT	i8274DCommACtlrAddr, AL		JMP	SHORT RsTxWaitForTxBufferEmpty		;------------------------------------------------	; Alls clear - Send ByteRsTxSendByte:	MOV	AL, ES:[DI]			;Get next char to TxRsTxByteOut:	%DisableInterruptsTillNextWait		;Added in for the first case situation	OUT	i8274DCommADataAddr, AL		;Output it to 8274RsTxWaitForTxBufferEmpty:	PUSHA		%WaitForInterrupt (rsTxBufEmptyWaitTime)       	JC	RsTxIntTimeout			;Bad Interrupt? Yes then Disaster		;------------------------------------------------	; Transfer made - Now update countersRsTxGotIntrpt:	POPA	CMP	rs232HdlOnly.rsSendFlowRequest, TRUE		;Request for flowcontrol from the receive task?	JNE	RsTxUpdatePointers		;If no then jump 	MOV	AL, rs232HdlOnly.rsFlowSendByte		;If yes then output the flow control character	MOV	rs232HdlOnly.rsSendFlowRequest, FALSE	;Reset the request flag	JMP	RsTxByteOutRsTxUpdatePointers:	INC	rs232HdlOnly.rsBytesTransfered	;add one to transfer count	DEC	rs232HdlOnly.rsBytesToTransfer		;decrement "bytes left" to transfer counter	JZ	RsTxStopSendBytes		;More bytes to transfer?	INC	DI	MOV	AX, comSendMapRegister	CALL    RsCheckForPageBoundary	CMP	rs232HdlOnly.rsCheckFlowControl, TRUE	;Yes then flow control checking?	JE	TxTaskByteLoop			;Yes then go check		JMP	RsTxSendByte			;Else go Transfer characters	;------------------------------------------------RsTxStopSendBytes:	MOV	BL, complete			;status = complete	CMP	rs232DCB.rs232Mode, asynch	JE	RsTransferCleanUp		;------------------------------------------------	; Wait for last interrupt from flag transmition after CRCRsTxCompleteSDLC:	%DisableInterruptsTillNextWait	MOV     AL, serialCmd5			;Reset Tx interrupts	OUT	i8274DCommACtlrAddr, AL	PUSHA	%WaitForInterrupt (rsTxBufEmptyWaitTime)       	JC	RsTxIntTimeout			;Bad Interrupt? Yes then Disaster	POPA	JMP	SHORT RsTransferCleanUp		;------------------------------------------------RsTxIntTimeout:	POPA	INC	rS232DCB.badTxIntTimeout	MOV	BL, disaster			       	;status = disaster		;------------------------------------------------	; Finished with this IOCB CleanUp and get next oneRsTransferCleanUp:	MOV     AL, serialCmd5			;Reset Tx interrupts	OUT	i8274DCommACtlrAddr, AL	MOV	rs232HdlOnly.rsTxActiveBuffer, FALSE	MOV	AL, FALSE			;This input to RsCleanUpIOCB says that Tx using routine	POP	DI	POP	ES	MOV	CX, rs232HdlOnly.rsBytesTransfered	CALL	RsCleanUpIOCB	;Now running at system level	MOV	rs232HdlOnly.rsBytesTransfered, 0	;Reset global variables	; Notify Client and advance queue		%AdvanceMesaIOCB (rs232CFCB.rsQueueTxChA.queueNext,rsNextIocbChA,rs232CFCB.rs232LockMask,mapped)	%NotifyClientCondition (rS232DCB.rsClientConditionChA)	%WaitForSystemRsTxTaskEnd:	JMP	TxTaskWorkStartIOCB;*******************************************************************************;...............................................................................;									       .;	 RS232 RECEIVE TASK FOR BOTH ASYNC AND SDLC FRAME FORMAT 	       .;...............................................................................; Rs232c receive task (Rx) is triggered by an 8274 receive interrupt.  The character; is read and the unneccessary bits are masked out.  The character is then compared; to the flowcontrol characters if flowcontrol mode has been selected and if the; character signals stopping transmition the OffFlag is set and if the character; signifies re-starting transmition then the transfer task is notified and the OffFlag ; is cleared.  At this point if an IOCB not has been accessed and the queue is empty ; then the datalost flag is set and the task waits for the next rx interrupt, else if ; the queue is not empty an IOCB and a buffer are accessed.  The character is then put ; into the buffer, the counters are updated and if there is still room in the buffer,; the task waitsfor another rx interrupt.  If the buffer is full or endOfFrame then ; the IOCB statuses and FCB statuses are updated, the global variables are reset, the ; client notified, and the queue is advanced.  Then the tasks returns to waiting for; the next rx interrupt. ; Register Description for this Task:; ES:[DI] = pointer to the IOCB then to the buffer, CX-DX = OPIE pointer to buffer, ; BX = bytes till next page boundary, AX general purpose and dataCharacter holder.; RxTaskChA:	%ThisTaskServices (RS232RxInterrupt, BadRxInterrupt)RsRxTaskLoop:	PUSHA	%WaitForInterrupt (noTimeout)	JNC	RsRxGetChar		;------------------------------------------------------	; FrameTimeOutRsRxIntTimeout:	POPA	CMP	rs232HdlOnly.rsRxActiveBuffer, TRUE		;Active buffer?	JNE	RsRxCheckForAnIOCB		;If not then see if one is available	JMP	RsRxFrameTimeout		;Else complete active bufferRsRxCheckForAnIOCB:	;  Flow Control on.  Attempting to access new IOCB.	MOV	AX, rs232HdlOnly.rsRxFrameTimeOutValue	;Start watchDog timer again.	MOV	rs232HdlOnly.rsRxWatchDogValue, AX	%JumpIfMesaIOCBNextNil(rs232cFCB.rsQueueRxChA.queueNext, RsRxTaskLoop)	CALL	RsRxAccessIOCB			;Access IOCB	PUSH	ES				;Save pointer to IOCB	PUSH	DI	CALL	RsRxSetUpBuffer			;Access and set up Client buffer	CMP	AL, TRUE			;Client buffer full?	JNE	RsRxTaskLoop			;No then wait for interrupt	JMP	RsRxComplete			;Yes then cleanup IOCB		;------------------------------------------------	; DataLost or character goes into Catch BufferRsRxNoIOCBAvailable:	CALL	RsRxCatchData	JMP	RsRxTaskLoop		;------------------------------------------------	; Got a characterRsRxGetChar:	POPA	XOR	AX, AX	IN	AL, i8274DCommADataAddr		;Get Character	CMP	rs232DCB.rs232Mode, asynch	JNE	RsRxCheckDForActiveBuffer	CALL	RsRxSkinCharacterOfBits		;Clear extra bits	CALL	RsRxCheckForFlowCharacter	;Check for flowControl character if FlowControl is used	CMP	AH, TRUE			;If flowControl on and character a flow char then	JE	RsRxTaskLoop			;go wait for another char else put char in bufferRsRxCheckDForActiveBuffer:	CMP	rs232HdlOnly.rsRxActiveBuffer, TRUE	JE	RsRxCharInBuffer	%JumpIfMesaIOCBNextNil(rs232cFCB.rsQueueRxChA.queueNext, RsRxNoIOCBAvailable)	MOV	rs232HdlOnly.rxFirstCharacterSave, AL	;Preserver first charater while accessing goes on	;------------------------------------------------	; Access IOCB and Receive BufferRsRxEstAccIOCB:		CALL	RsRxAccessIOCB			;Access IOCB	PUSH	ES				;Save pointer to IOCB	PUSH	DI	CALL	RsRxSetUpBuffer			;Access and set up Client buffer	CMP	AL, TRUE			;Client buffer full?	JNE	RsRxFirstCharInBuffer		;No then put character in buffer	MOV	AL, rs232HdlOnly.rxFirstCharacterSave	; Put character into catch buffer if room without triggering flowControl	MOV	CX, rs232DCB.rs232flowControl.flowType	MOV	rs232DCB.rs232flowControl.flowType, none	CALL	RsRxCatchData	MOV	rs232DCB.rs232flowControl.flowType, CX	JMP	RsRxComplete			;Else buffer is complete (char is in catch buffer)RsRxFirstCharInBuffer:	MOV	AL, rs232HdlOnly.rxFirstCharacterSave	;------------------------------------------------RsRxCharInBuffer:	MOV	ES:[DI], ALRsRxUpdateCounters:	INC	DI				;Update index	INC	rs232HdlOnly.rsBytesReceived	;Update count of bytes received	MOV	AX, rs232HdlOnly.rsBytesReceived	CMP	AX, rs232HdlOnly.rsBytesToReceive 		;Receive buffer full?	JGE	RsRxCheckBufferOverflow			;Yes then exit	CMP	rs232HdlOnly.rsEndFrame, TRUE		;End of frame?	JE	RsRxComplete			;If yes then exit	MOV	AX, comRecMapRegister		;Check for page boundary crossing	CALL    RsCheckForPageBoundary	CMP	rs232HdlOnly.rsRxFrameTimeOutValue, 0		JNE	RsRxResetFrameTimeout	JMP	RsRxTaskLoopRsRxResetFrameTimeout:				;If using frameTimeout then reset	MOV	AX, rs232HdlOnly.rsRxFrameTimeOutValue	;watchDog value to original setting	MOV	rs232HdlOnly.rsRxWatchDogValue, AX	JMP	RsRxTaskLoop		;------------------------------------------------	; Check if the buffer provided was too smallRsRxCheckBufferOverflow:	CMP	rs232DCB.rs232Mode, asynch	JE	RsRxComplete	CMP	rs232HdlOnly.rsEndFrame, TRUE	JE	RsRxComplete	MOV	BL, dataLost	OR	rs232DCB.rsLatchedStatus, latchDataLost		JMP	SHORT RsRxCleanUp		;------------------------------------------------	; Completed IOCBRsRxComplete:	MOV	rs232HdlOnly.rsRxActiveBuffer, FALSE	;don't want flag active across call to WaitForSystem	      	MOV	BL, complete	JMP	SHORT RsRxCleanUp	;------------------------------------------------	; FrameTimeoutRsRxFrameTimeout:	CMP	rs232DCB.rsTTYHost, TRUE	;If TTYHost then status = complete	JNE	RsTimeOutNotTTYHost	MOV	BL, complete	JMP	SHORT RsRxCleanUpRsTimeOutNotTTYHost:	MOV	BL, frameTimeout		;Status = frameTimeout	;------------------------------------------------	;------------------------------------------------	; Rs232c Rx CleanUp operationRsRxCleanUp:	CMP	rs232DCB.rsFrameTimeoutValue, 0	JE	RsRxGeneralCleanUp	%Jam (RS232CHandlerID, OFFSET rs232HdlOnly.rsWatchDogTcb)RsRxGeneralCleanUp:	MOV	AL, TRUE		;This is input to RsCleanUpIOCB saying Rx using routine	POP	DI	POP	ES	MOV	CX, rs232HdlOnly.rsBytesReceived	CALL	RsCleanUpIOCB	; Now running at system levelRsRxResetValues:	;Reset global variables	MOV	rs232HdlOnly.rsRxActiveBuffer, FALSE			MOV	rs232HdlOnly.rsBytesReceived, 0	MOV	rs232HdlOnly.rsEndFrame, FALSE	MOV	rs232HdlOnly.saveValueRR1, 0	MOV	rs232HdlOnly.rsRxBufferFrameTimeout, FALSE	%AdvanceMesaIOCB (rs232CFCB.rsQueueRxChA.queueNext,rsNextIocbChA,rs232CFCB.rs232LockMask,mapped)	%NotifyClientCondition (rS232DCB.rsClientConditionChA)RsRxTaskEnd:	JMP	RsRxTaskLoop	;******************************************************************************;...............................................................................;									       .; RS232 SPECIAL RECEIVE CONDITION TASK FOR Error HANDLING AND STATUS UPDATE    .;...............................................................................;; Rs232c Spec receive task is triggered by a special receive interrupt from the 8274.; A special receive interrupt can be caused by a parity error, a receive overrun error,; a framing error or and end of Frame (in SDLC mode).;   If there is an active IOCB when this error occurs then the IOCB statuses are updated,; the IOCB is forced to completion, and made inactive.  In all occurances of error the; FCB statuses are updated, the error is reset with the Error Reset command, the; client is notified and then the task waits for another spec receive error.;SpecRxTaskChA:	%ThisTaskServices(RS232SpecRxInterrupt, BadSpecRxInterrupt)RsSpecRxTaskLoop:	%WaitForInterrupt (noTimeout)RsSpecRxGotIntterrupt:	CALL	ReadAllStatusRegisters			;Update FCB status registers	MOV	AL, i8274ErrorReset			;Reset error latches in RR1	OUT	i8274DCommACtlrAddr, AL			;to enable other error conditions	CMP	rs232HdlOnly.rsRxActiveBuffer, TRUE			;	JE	RsSpecRxSaveRR1	CMP	rs232HdlOnly.rsRxCatchBufferCount, rsRxCatchBufferSize ;catch buf full? yes then branch	JE	RsSpecRxCheckForEOF			;If there is an active bufferRsSpecRxSaveRR1:	MOV	AL, rs232DCB.rsReadRegister1		;then save ReadRegister 1	MOV	rs232HdlOnly.saveValueRR1, AL	MOV	rs232HdlOnly.rsEndFrame, TRUE			;set EndFrame TrueRsSpecRxCheckForEOF:	AND	AL, serialEndOfFrame			;End of Frame?	JZ	RsSpecReceiveErrorRpt			;No then branch	MOV	AL, i8274CommCRCRstRx			;Reset Receive CRC checker	OUT	i8274DCommACtlrAddr, AL		MOV	AL, rs232DCB.rsReadRegister1		;CRC error?  	AND	AL, serialFrameError	JZ	RsSpecRxOverRunCheck			;No then branchRsSpecRxCRCError:	INC	rS232DCB.rsRxCRCErrorCnt		;Increment CRC counter	RsSpecRxOverRunCheck:	MOV	AL, rs232DCB.rsReadRegister1		;UnderRun Error?	AND	AL, serialRxOverrun	JZ	RsSpecRxEndLoop			;No then branch.RsSpecRxOverRun:	INC	rS232DCB.rsOverRunErrors		;Increment OverRun counter	JMP	SHORT RsSpecRxEndLoop			;End...	;--------------------------------------------------------RsSpecReceiveErrorRpt:	INC	rS232DCB.specErrorCount		;Increment error count	RsSpecRxEndLoop:	JMP	RsSpecRxTaskLoop;******************************************************************************;...............................................................................;									       .; RS232 Extern Status Routine						       .;...............................................................................; Rs232c External Status task is triggered by an 8274 external status interrupt.; An external status interrupt is caused when one of the following status conditions; changes: CD, CTS, SYNDET, or BREAK.  The error is reset by doing a reset; external status interrupt commands.  Statuses in FCB are updated.  ; Then task then returns to waiting for an interrupt.;ExtStatTaskChA:	%ThisTaskServices (RS232ExtStatInterrupt,BadExtStatInterrupt)ExtStatTaskLoop:	%WaitForInterrupt (noTimeout)RsExtGotInterrupt:	MOV	AL, i8274RstIntrCommand		;reset Ext/Status Interrupt 	OUT	i8274DCommACtlrAddr, AL		CALL	ReadAllStatusRegisters		;Update FCB after Resets	%NotifyClientCondition (rS232DCB.rsClientConditionChA)RsExtStatLoopEnd:	JMP	ExtStatTaskLoop	;******************************************************************************;...............................................................................;									       .; RS232 Watch Dog Receive Interrupt Task						       .;...............................................................................; Rs232c Watch Dog Rx Interrupt task is a watch dog task made special for the Rs232c; receive task to have millisecond resolution.  Since the OPIE watchDog is has a; resolution of one second it is not efficient for frametimeout monitoring.RsWatchDogTask:	%LoadOpieSegment (ES,AX)		;Set ES to point to OPIE IORegion SegmentRsWatchWait:	%WaitForTime	(rsFrameTOBase)	CLI	DEC	rs232HdlOnly.rsRxWatchDogValue	JNZ	RsWatchWaitRsWatchTimeOut:	MOV	rs232HdlOnly.rsRxBufferFrameTimeout, TRUE	MOV	DI, OFFSET OPIEIORComplete:RS232RxICB	AND	ES:[DI].ICBcontext.interruptStatus, NOT (MASK ICTaskWaiting OR MASK ICTimed)	MOV	SI, OFFSET rS232CFCB.rxTaskChATcb	ASSUME  DS:RS232CIOR	CALL	RsInsertInSystemQueue	;put task on system queue.	MOV	BX, [SI].taskSP	OR	WORD PTR SS:[BX]+waitStackFlagOffset, MASK i80186CF ;set timeout flag	STI       	JMP	RsWatchWait;******************************************************************************RsInsertInSystemQueue:; DS:[SI] points to task; ES points to Opie's IORegion; BX can be trashed			ASSUME	ES:OpieIOR			SHL	[SI].taskState, Nibble	;stamp it with previous			OR	[SI].taskState, waitForSystemState ;and current state.			MOV	[SI].taskQueue.IOPEQueueType, systemQueueType			MOV	[SI].taskQueue.nextHandlerID, nilHandlerID			MOV	AH, [SI].taskHandlerID			MOV	AL, systemQueue.handlerIDforTail			MOV	DI, systemQueue.linkPtrforTail			MOV	systemQueue.handlerIDforTail, AH			MOV	systemQueue.linkPtrforTail, SI			CMP	AL, nilHandlerID			JNE	RsLinkTheSystemQueueTCBs			MOV	systemQueue.handlerIDforHead, AH			MOV	systemQueue.linkPtrforHead, SI			RETRsLinkTheSystemQueueTCBs:				PUSH	DS			PUSH	AX			CBW			%LoadHandlerSegment	(DS,BX)			POP	AX			MOV	[DI].taskQueue.nextHandlerID, AH			MOV	[DI].taskQueue.nextTCBLinkPtr, SI			POP	DS			RET			ASSUME	ES:NOTHING;...............................................................................;									       .;			 RS232 COMM SUPPORT SUBROUTINES   	       	       .;...............................................................................;************************************************************************; ;    Initialization Routines					     	;************************************************************************;; This routine is called only once at the beginning of rs232c Main task.; Its purpose is to initialize the 8274 chip Channel A, the 8254 clock, the IOP port (80H),; FCB parameters, and rs232c handler global parameters. I8274 channel A register intitialization; is read from EEProm and has the following intitial values:;  Write Register1: Initialize receiver to interrupt on all receive characters (parity does;    not effect vector);  Write Register3: 7 bit Rx character, Auto Enable On (CD enables Rx, CTS enables Tx).;  Write Register4: clock/data rate multiplier for Tx and Rx set to ;   clock rate = data rate * 16, 1 stop bit, even parity.;  Write Register5: 7 bit Tx character.; IOP Port 80H is set for channel A using internal clock.; Baud rate is intitialized to 1200bps. ;RS232CParmInit	PROC	NEAR	;-----------------------------------------------------	; Read EEPROM 	%ReadEEProm(eePromRS232DTEtype,1)	MOV	rs232DCB.rsEEpromImage.rsDeviceTypeChA, AL	%ReadEEProm(eePromRS232DTEattr,1) 	MOV	rs232DCB.rsEEpromImage.rsChAAttributes, AL	;---------------------------------------------------------	; Initialize hardware	MOV	DX, i8274DCommACtlrAddr		;point DX to RS232 (DTE) port on IOP	MOV	AL, i8274ErrorReset	OUT	DX, AL		MOV	AL, i8274RstIntrCommand	OUT	DX, AL	MOV	AL, i8274RstIntrCommand	OUT	DX, AL	MOV	rs232DCB.rsBaudRateChA, Baud1200	CALL	SetBaud	;-- Initialize DCB	MOV	rs232DCB.rs232Mode, asynch	MOV	rs232DCB.rs232FlowControl.flowType, none	XOR	AX, AX	MOV	rs232DCB.rsWorkList, AX  	MOV	rs232DCB.rsCommandWorkList, AX	MOV	rs232DCB.rsWR0ofi8274ChA, AL	MOV	rs232DCB.rsWR1ofi8274ChA, AL 		MOV	rs232DCB.rsWR3ofi8274ChA, AL 		MOV	rs232DCB.rsWR4ofi8274ChA, AL	MOV	rs232DCB.rsWR5ofi8274ChA, AL 		MOV	rs232DCB.rsWR6ofi8274ChA, AL 		MOV	rs232DCB.rsWR7ofi8274ChA, AL	MOV	rs232HdlOnly.rsBytesTransfered, AX	MOV	rs232HdlOnly.rsBytesReceived, AX	MOV	rs232HdlOnly.rsFrameTimeoutValue, AX	MOV	rS232DCB.rsRxCRCErrorCnt, AX	MOV	rS232DCB.rsOverRunErrors, AX	MOV	rS232DCB.specErrorCount, AX	MOV	rS232DCB.badTxIntCnts, AX		MOV	rS232DCB.badRxIntCnts, AX		MOV	rS232DCB.badSpecRxIntCnts, AX	 	MOV	rS232DCB.badExtStatIntCnts, AX	MOV	rS232DCB.badTxIntTimeout, AX	MOV	rs232HdlOnly.saveValueRR1, AL	MOV	rs232HdlOnly.rsRxCatchBufferCount, AX	MOV	rs232HdlOnly.rsRxCatchBufferIndex, AX	MOV	rs232HdlOnly.rsEndFrame, FALSE	MOV	rs232HdlOnly.rsRxActiveBuffer, FALSE	MOV	rs232HdlOnly.rsRxWatchDogValue, 0FFFFH	MOV	rs232HdlOnly.rsRxBufferFrameTimeout, FALSE	MOV	rs232HdlOnly.rsReceiverInXOFFState, FALSE	MOV	rs232HdlOnly.rsFlowOff, FALSE	MOV	rs232HdlOnly.rsSendFlowRequest, FALSE	MOV	rs232HdlOnly.rsTxActiveBuffer, FALSE	%GetLockMask 	MOV   rs232CFCB.rs232LockMask, AX	;Initialize lock mask returned in macro	%GetWorkMaskForCondition (OFFSET rS232DCB.rs232ChAWork)	MOV	rs232CFCB.rs232WorkMask,AX	CALL	ReadAllStatusRegisters			;Initialize Read Registers in DCB	; Initially set up for asynchronous using internal clock	%ControlRegister(CRRS232AInternalClock,CRRS232AInternalClock)	RETRS232CParmInit	ENDP;************************************************************************; SUBROUTINE :  SetBaud;	RS232C use output of the 8254 Input clock freq is 4MHz;	For now, we set up for Program Timers to generate; 	sq wave and divide input clock by 26 Set rate factor on 8274 ;	so, 4 MHz / 208 / 16 = 1200 baud;; This routine is called whenever the BaudRate needs to be set.;SetBaud   PROC   NEAR;    Timer 0	MOV	AL, i8254SelCount0+i8254LSBthenMSB+i8254SqWave+i8254BinaryCount	OUT	i8254Ctlr, AL	MOV	AX, rS232DCB.rsBaudRateChA	;use 0026 for default init @4Mhz	OUT	i8254Count0, AL	;ls byte 	MOV	AL, AH	OUT	i8254Count0, AL	;ms byte 	RETSetBaud 	ENDP	;	******************;************************************************************************;;  	 Rs232C Handler Work and Status Routines ;************************************************************************; RsFigureBytesTillNextPage:; Input DX, CX Low and high Opie Address to the buffer.  Returns BX = Number of ; Bytes till next Page Boundary.RsFigureBytesTillNextPage PROC 	NEAR	;Set Up BytesToNextPage Counter	CMP	DL, 0			;If address is at the beginning of a page	JE	RsStartsAtPageBoundary	MOV	BX, DX			;Here's the formula:  Use Dx to compute	NOT	BL			;The number of Byte till the next page	XOR	BH, BH			;512 bytes till next page	INC	BX			;Multiply by 2 to get bytes till next page	SHL	BX, 1	JMP	SHORT RsFigureNextPageEndRsStartsAtPageBoundary:	MOV	BX, bytesPerPageRsFigureNextPageEnd:		RETRsFigureBytesTillNextPage   ENDP; RsCheckForPageBoundary Routine:;  This routine checks to see if end of Page. If so then re-establishes access to the;  buffer.  Input: CX: High OPIE Address, DX Low OPie address, AX: MapRegister, Bx: Bytes till;  next page.;  If new page then CX = to updated High Opie address and ES and DI point;  to continueing buffer.RsCheckForPageBoundary  PROC    NEAR	DEC	BX	JNZ	RsCheckForPageEndRsEndOfPage: 	XOR	DL, DL			;Set Dx to point to next page	ADD	DH, 1			;Null out the low byte. Add 1 to high byte	ADC	CL, 0			;If carry over add it to low byte of CX	PUSH    CX	PUSH    DX	%EstablishIOPAccess (AX,CX-DX) 	POP     DX	POP     CX	MOV	BX, bytesPerPageRsCheckForPageEnd:	RETRsCheckForPageBoundary  ENDP            ;RS232C RsCleanUpIOCB routine:  ; The procedure takes care of doing the cleanup operations for the Tx and Rx; tasks.  It up dates the statuses in the IOCB as well as in the FCB.  A WaitForSystem; is done before doing the major part of the cleanup since the time it takes to; cleanup is longer than the max time a task is allowed to run at system level.; Inputs are BL= result of operation, Al= {RX:TRUE, TX:FALSE}, ES:[DI] must point to IOCB.; CX = final count.; Note: This routine was an attempt to shrink code by combining common cleanup functions of; the rx and tx task.RsCleanUpIOCB	PROC	NEAR	CALL	ReadAllStatusRegisters	PUSHA	%WaitForSystem	POPA	CMP	AL, TRUE	JNE	RsCleanUpStoreIOCBValues	CMP	rs232HdlOnly.saveValueRR1, 0		;If a SpecRx err occured report that status	JE	RsCleanUpStoreIOCBValues	MOV	AL, rs232HdlOnly.saveValueRR1 	MOV	rs232DCB.rsReadRegister1, AL 	;Use RR1 value from Spec Rx RsCleanUpStoreIOCBValues:	CALL	PutAllRRegStatusInIOCB	MOV	ES:[DI].rsTransferCountChA, CX	MOV	ES:[DI].rsActiveIOCB, False	MOV	ES:[DI].currentOpStatus, BL	RETRsCleanUpIOCB	ENDP	;************************************************************************; RsSetupFrameTimeOut:  This routine determines if the client wants to use; frametimeout, and if so starts off the RsWatchDog task.RsSetupFrameTimeOut	PROC	NEAR	MOV	rs232HdlOnly.rsRxFrameTimeOutValue, 0	CMP	rs232DCB.rsFrameTimeoutValue, 0				JE	RsSetFrameTOExit	PUSH    DX	PUSH    BX	MOV	AX, rs232DCB.rsFrameTimeoutValue	; Divide requested millisecond frameTimeout by 10 since can only 	; measure with this granularity.	MOV	BX, rsFrameTOBase	XOR	DX, DX	DIV	BX	CMP	DX, 0			;Remainder?	JE	RsStoreWDogValue	ADD	AX, 1			;If remainder add 1 to resultRsStoreWDogValue:	MOV	rs232HdlOnly.rsRxWatchDogValue, AX	;Set counter to new value	MOV	rs232HdlOnly.rsRxFrameTimeOutValue, AX	PUSH	DI	PUSH	CX	%Restart (RS232CHandlerID,OFFSET rs232HdlOnly.rsWatchDogTcb,RsWatchDogTask,OFFSET RS232CWatchStack)	POP	CX	POP	DI	POP     BX	POP     DX	CMP	rs232DCB.rsTTYHost, TRUE	;Timing total frame ?	JE	RsSetFrameTOExit		;No then branchRsSetFrameTOExit:	RETRsSetupFrameTimeOut	ENDP;************************************************************************; This routines checks to see if there are characters in the catch Buffer.; If there are then the bytes are moved from the catch buffer to the client buffer.; If there are not then nothing is done.  Input to this routine is ES and DI; pointing to the client buffer, BX the number of bytes to the next page, ; and CX and DX OPIE address pointers to the buffer.; Output from this routine is in AL.  If AL = TRUE; then client buffer is now full otherwise it still has some available room.RsRxCheckCatchBuffer	PROC	NEAR	MOV	AL, FALSE	CMP	rs232DCB.rs232Mode, asynch	;If not async mode exit	JE	RsRxCheckCatchBufEmpty	JMP	RsRxCheckCatchBufExitRsRxCheckCatchBufEmpty:	CMP	rs232HdlOnly.rsRxCatchBufferCount, 0		;If nothing in the buffer exit	JNE	RsRxCatchToClientSetUp	JMP	RsRxCheckCatchBufExitRsRxCatchToClientSetUp:	MOV	SI, rs232HdlOnly.rsRxCatchBufferIndex	;get indexRsRxCopyCatchToClient:	MOV	AL, rs232HdlOnly.rsRxCatchBuffer[SI]	MOV	ES:[DI], AL			;copy character	INC	DI				;Update indexes and counters	INC	rs232HdlOnly.rsBytesReceived	INC	SI	INC	rs232HdlOnly.rsRxCatchBufferIndex	MOV	AX, rs232HdlOnly.rsRxCatchBufferCount	CMP	rs232HdlOnly.rsRxCatchBufferIndex, AX	;If Index = count then buffer emptied	JGE	RsRxCatchBufferEmpty	MOV	AX, rs232HdlOnly.rsBytesReceived	CMP	AX, rs232HdlOnly.rsBytesToReceive 		;Receive buffer full?	JGE	RsRxClientBufferFull	MOV	AX, comRecMapRegister		;Check for page boundary crossing	CALL    RsCheckForPageBoundary	JMP	RsRxCopyCatchToClient	RsRxCatchBufferEmpty:	MOV	rs232HdlOnly.rsRxCatchBufferCount, 0		;Reset pointers	MOV	rs232HdlOnly.rsRxCatchBufferIndex, 0	MOV	AX, rs232HdlOnly.rsBytesReceived	CMP	AX, rs232HdlOnly.rsBytesToReceive 		;Receive buffer full?	JGE	RsRxClientBufferFull	MOV	AL, FALSE	JMP	RsRxCatchBufCheckFlowRsRxClientBufferFull:	MOV	AL, TRUERsRxCatchBufCheckFlow:	CMP	rs232DCB.rs232flowControl.flowType, none	;using flowControl ?	JE	RsRxCheckCatchBufExit			;No then branch	CMP	rs232HdlOnly.rsReceiverInXOFFState, TRUE		;If not in XOff state don't send XON	JNE	RsRxCheckCatchBufExit	CMP	rs232HdlOnly.rsRxCatchBufferCount, 0			;Catch buffer empty?	JNE	RsRxCheckCatchBufExit		;No then don't send an XON	PUSH	AX			MOV	AX, rs232DCB.rs232FlowControl.xOn	MOV	rs232HdlOnly.rsFlowSendByte, AL		;Output XON	MOV	rs232HdlOnly.rsSendFlowRequest, TRUE		;Set request to do flow transfer	MOV	rs232HdlOnly.rsReceiverInXOFFState, FALSE	;Set XOFF flag False	PUSH	BX	%NotifyCondition (OFFSET rS232DCB.TxChAWork)	POP	BX	POP	AXRsRxCheckCatchBufExit:	RETRsRxCheckCatchBuffer	ENDP;************************************************************************; RsRxCatchData:  This routine is called when a receive character is available; in the chip but there is no buffer available to store it in.  The character is; put into the catch buffer and if flowcontrol is being used then an XOff character is; sent.  If the catch buffer is full or mode being used in bitsync then the dataLost; flag is set.  Input:  AL contains the input character.  RsRxCatchData	PROC	NEAR	CMP	rs232DCB.rs232Mode, asynch	JNE	RsRxDataLost	CMP	rs232HdlOnly.rsRxCatchBufferCount, rsRxCatchBufferSize	JE	RsRxDataLost	CLI			;Clear all interrupts to prevent BadRxInterrupt				;from coming in and double inc counter.	MOV	DI, rs232HdlOnly.rsRxCatchBufferCount	;Put character in catch buffer	MOV	rs232HdlOnly.rsRxCatchBuffer[DI], AL	INC	rs232HdlOnly.rsRxCatchBufferCount		;Update pointerRsRxCheckFlowControl:	STI			; Start interrupts.	CMP	rs232DCB.rs232flowControl.flowType, none	JNE	RsRxSendXOff	JMP	RsRxCatchDataExitRsRxSendXOff:	CMP	rs232HdlOnly.rsReceiverInXOFFState, TRUE	JE	RsRxResetWatchDog	MOV	AX, rs232DCB.rs232FlowControl.xOff	MOV	rs232HdlOnly.rsFlowSendByte, AL		;Set character to be outputed to be XOff character	MOV	rs232HdlOnly.rsSendFlowRequest, TRUE		;Set request to do flow transfer	MOV	rs232HdlOnly.rsReceiverInXOFFState, TRUE	;Set XOFF flag true	%NotifyCondition (OFFSET rs232DCB.TxChAWork)	CALL	RsSetupFrameTimeOut	CMP	rs232HdlOnly.rsRxFrameTimeOutValue, 0	JNE	RsRxCatchDataExit		MOV	rs232HdlOnly.rsRxWatchDogValue, rsRxWatchDogDefault 	MOV	rs232HdlOnly.rsRxFrameTimeOutValue, rsRxWatchDogDefault	%Restart (RS232CHandlerID,OFFSET rs232HdlOnly.rsWatchDogTcb,RsWatchDogTask,OFFSET RS232CWatchStack)	JMP	RsRxCatchDataExitRsRxResetWatchDog:	MOV	AX, rs232HdlOnly.rsRxFrameTimeOutValue	MOV	rs232HdlOnly.rsRxWatchDogValue, AX	JMP	RsRxCatchDataExit	;------------------------------------------------	; DataLostRsRxDataLost:	OR	rs232DCB.rsLatchedStatus, latchDataLostRsRxCatchDataExit:	RETRsRxCatchData	ENDP;************************************************************************;RsRxSkinCharacterOfBits: Clear bits which are not part of character; Input: AL = character received.  Output: AX with high byte Null and low byte; equal to the character cleared of unneeded bits.RsRxSkinCharacterOfBits 	PROC	NEAR	MOV	AH, rs232DCB.rsWR3ofi8274ChA	;Clear unsignificant bits	AND	AH, rxCharLength		;depending on CharLength	JZ	RsRxChar5Bits			;5 bit Character	CMP	AH, i8274Rx6BitChar		;	JE	RsRxChar6Bits			;	CMP	AH, i8274Rx8BitChar	JE	RsRxSkinCharOfBitsExit		;If 8 bits leave character as is	AND	AL, rxChar7Bits			;For 7 clear MS bit	JMP	SHORT RsRxSkinCharOfBitsExitRsRxChar6Bits:	AND	AL, rxChar6Bits			;For 6 clear 2 MS bits	JMP	SHORT RsRxSkinCharOfBitsExitRsRxChar5Bits:	AND	AL, rxChar5Bits			;For 7 clear 3 MS bitsRsRxSkinCharOfBitsExit:	XOR	AH, AH	RETRsRxSkinCharacterOfBits	ENDP;************************************************************************; RsRxCheckForFlowCharacter: Input: AX contains receive character. Output:; AH = TRUE then flowcharacter else not.; If mode = async and FlowControl then check char for Xon/XoffRsRxCheckForFlowCharacter	PROC	NEAR	PUSH	BX	MOV	BL, FALSE		;Initialize return value to false	CMP	rs232DCB.rs232FlowControl.flowType, none	JE	RsRxCheckFlowExitRsTestforXOff:	; Flow Control	CMP	AX, rs232DCB.rs232FlowControl.xOff	;is xOff received ?	JNE	RsTestforXon	MOV	rs232HdlOnly.rsFlowOff, TRUE				;Set XOff Received flag	MOV	BL, TRUE				;Set return flag to true	JMP	RsRxCheckFlowExitRsTestforXOn:	CMP	AX, rs232DCB.rs232FlowControl.xOn	;is XOn received ?	JNE	RsRxCheckFlowExit	MOV	rs232HdlOnly.rsFlowOff, FALSE			;Clear XOFF Flag	%NotifyCondition (OFFSET rS232DCB.TxChAWaitXOn)	MOV	BL, TRUE				;Set return flag to trueRsRxCheckFlowExit:	MOV	AH, TRUE	CMP	BL, TRUE	JE	RsRxCheckFlowReturn	MOV	AH, FALSERsRxCheckFlowReturn:	POP	BX			RETRsRxCheckForFlowCharacter	ENDP;************************************************************************; RsRxAccessIOCB: Output ES:[DI] pointing to the IOCBRsRxAccessIOCB	PROC	NEAR	%EstablishIOPAccess (generalMapRegister, rS232CFCB.rsQueueRxChA.queueNext)	MOV	AX, ES:[DI].rsBufferSize	MOV	rs232HdlOnly.rsBytesToReceive,  AX	MOV	ES:[DI].rsActiveIOCB, True	RETRsRxAccessIOCB	ENDP;************************************************************************; RsRxSetUpBuffer: Input: ES:[DI] points to IOCB.  Ouput: ES:[DI] pointing to; the buffer, CX-DX OPIE pointers to the buffer, the buffer set up for receiving,; and AL = TRUE if the catchBuffer filled up the client buffer.RsRxSetUpBuffer	PROC	NEAR	MOV     CX, ES:[DI].rsBufferPtr.OpieAddressHigh	MOV     DX, ES:[DI].rsBufferPtr.OpieAddressLow	PUSH    CX	PUSH    DX		%EstablishIOPAccess (comRecMapRegister,CX-DX)	POP     DX	POP     CX	CALL	RsFigureBytesTillNextPage	;-- Initailize boundary crossing logic	CALL	RsSetupFrameTimeOut		;-- Set up for FrameTimeOut if Requested	MOV	rs232HdlOnly.rsRxActiveBuffer, TRUE		;-- Active buffer 	CALL	RsRxCheckCatchBuffer		;-- If data in catch buffer put it in client buffer	RETRsRxSetUpBuffer	ENDP;************************************************************************; This routine is called by rs232c Main task and is called when ever there is work to be; done.  It reads the value of the work-list and sets it to zero, then analyzes the bits; in the work-list finding what work needs to be done.  The type of work that can be done; is changes to the write Registers, baud rate, or iopPort (80H) ChannelA internal; clock bit.  The new value for the write registers and baud rate are pulled from the; fcb, and the setting of the IOP port is determined by the mode setting in the FCB ; (async or sync).  Note that interrupts are disabled while these settings are changed; in case any rs232c interrupts are triggered during this period.  Interrupts are ; re-enabled by doing a WaitForSystem macro.;RSCheckWorkList	PROC	NEAR	MOV	BL, FALSE			;Initialize work flag to false	MOV	AX, rs232DCB.rsWorkList	AND	AX, workFori8274		;Work to be done ?	JNZ	CheckModeChange			;No then Exit	JMP	RsCheckWorkListExit	;CheckModeChange:	CLI	MOV	DX, i8274DCommACtlrAddr		;point DX to printer(DCE) port on IOP	MOV	AX, rs232DCB.rsWorkList	AND	AX, rsChangeMode		;New Mode?	JZ	RsCheckWorkWR4			;No then branch	MOV	AL, i8274ChanReset	OUT	DX, AL	NOP					;Allow 4 extra system clock cycles to occur	NOP	NOP	NOP	MOV	AL, i8274ErrorReset		;Reset Error	OUT	DX, AL	MOV	AL, i8274WriteRegister2		;Set up interrupt structure	OUT	DX, AL	MOV	AL, i8274OpieInitCommand		OUT	DX, AL	CMP	rs232DCB.rs232Mode, asynch	;Change to Async mode?	JNE	RSModeChangeSDLC	%ControlRegister(CRRS232AInternalClock,CRRS232AInternalClock)	JMP	SHORT RsCheckWorkWR4RSModeChangeSDLC:	%ControlRegister(CRRS232AInternalClock,0)	;RsCheckWorkWR4: 		;Write Reg 4 must be writen to before registers 1, 3, 5, 6, and 7 	MOV	CX, rs232DCB.rsWorkList	MOV	AX, CX	AND	AX, rsWorkWR4			;Work for WR4?	JZ	RsCheckWorkWR0			;No branch	MOV	AL, i8274WriteRegister4	OUT	DX, AL	MOV	AL, rs232DCB.rsWR4ofi8274ChA	;Write new value 	OUT	DX, ALRsCheckWorkWR0:	MOV	AX, CX	AND	AX, rsWorkWR0			;Work for WR0?	JZ	RsCheckWorkWR1			;No branch Controller	MOV	AL, rs232DCB.rsWR0ofi8274ChA	;Write new value 	OUT	DX, AL	RsCheckWorkWR1:	MOV	AX, CX	AND	AX, rsWorkWR1			;Work for WR1?	JZ	RsCheckWorkWR3			;No branch Controller	MOV	AL, i8274WriteRegister1	OUT	DX, AL	MOV	AL, rs232DCB.rsWR1ofi8274ChA	;Write new value 	OUT	DX, ALRsCheckWorkWR3:	MOV	AX, CX	AND	AX, rsWorkWR3			;Work for WR3?	JZ	RsCheckWorkWR5			;No branch Controller	MOV	AL, i8274WriteRegister3	OUT	DX, AL	MOV	AL, rs232DCB.rsWR3ofi8274ChA 	;Write new value 	OUT	DX, AL	RsCheckWorkWR5:	MOV	AX, CX	AND	AX, rsWorkWR5			;Work for WR5?	JZ	RsCheckWorkWR6		;No branch Controller	MOV	AL, i8274WriteRegister5	OUT	DX, AL	MOV	AL, rs232DCB.rsWR5ofi8274ChA	;Write new value 	OUT	DX, AL	RsCheckWorkWR6:	MOV	AX, CX	AND	AX, rsWorkWR6			;Work for WR6?	JZ	RsCheckWorkWR7			;No branch	MOV	AL, i8274WriteRegister6	OUT	DX, AL	MOV	AL, rs232DCB.rsWR6ofi8274ChA	;Write new value 	OUT	DX, ALRsCheckWorkWR7:	MOV	AX, CX	AND	AX, rsWorkWR7			;Work for WR7 ?	JZ	RsCheckWorkBaudRate			;No Branch	MOV	AL, i8274WriteRegister7	OUT	DX, AL	MOV	AL, rs232DCB.rsWR7ofi8274ChA	;Write new WR7 value 	OUT	DX, ALRsCheckWorkBaudRate:	MOV	AX, CX	AND	AX, rsNewBaudRate		;BaudRate changed?	JZ	RsCheckModeChangeAgain	 	;No Branch	CALL	SetBaud			;RsCheckModeChangeAgain:	MOV	AX, CX	AND	AX, rsChangeMode		;New Mode?	JZ	RsCheckWorkListCleanUp	CMP	rs232DCB.rs232Mode, asynch	;Change to Async mode?	JE	RsCheckWorkListCleanUp	;-- If mode is SDLC then do the following resets	MOV	AL, i8274CommCRCRstRx+i8274RstExtStat	OUT	DX, AL	MOV	AL, i8274RstExtStat+i8274CommCRCRstTx	OUT	DX, AL	MOV	AL, i8274ErrorReset	OUT	DX, ALRsCheckWorkListCleanUp:	;Re-enable interrupt by doing a wait	STIRsCheckWorkListExit:	MOV	rs232DCB.rsWorkList, 0			;Clear workList	 	RETRsCheckWorkList	ENDP	;	************************;; This Routine is called by rs232c Main Task and is called when ever a command work may ; need to be done.  The only commands requiring special work are transferring an IOCB, and getting a; device status, since for other commands the work is all in the workList. ; RsCheckCommandList	PROC 	NEAR	MOV	AX, rs232DCB.rsCommandWorkList	AND	AX, getDeviceStatus		;request for device status?	JZ	RsCheckGoTx			;No then branch	%MesaLockedOut(AND, OFFSET rs232DCB.rsCommandWorkList, cleargetDevStat, rs232CFCB.rs232LockMask)RsCheckGoTx:	MOV	AX, rs232DCB.rsCommandWorkList			AND	AX, newTx			;Request to Transfer	JZ	RsCheckAbortTx			;No Then branch	%NotifyCondition (OFFSET rs232DCB.TxChAWork)	%MesaLockedOut(AND, OFFSET rs232DCB.rsCommandWorkList, clearNewTx, rs232CFCB.rs232LockMask)RsCheckAbortTx:	MOV	AX, rs232DCB.rsCommandWorkList			AND	AX, abortTx	JZ	RsCheckAbortRx	%Restart(RS232CHandlerID,OFFSET rS232CFCB.txTaskChATcb,TxTaskWorkLoop,OFFSET RS232CTxStack)	; Reset parameters	MOV	rs232HdlOnly.rsBytesTransfered, 0	MOV	rS232CFCB.rsQueueTxChA.queueNext, 0	MOV	rs232HdlOnly.rsTxActiveBuffer, FALSE	;-- Do this twice in case running bitsync mode	MOV     AL, serialCmd5			;Reset Tx interrupts	OUT	i8274DCommACtlrAddr, AL	MOV     AL, serialCmd5			;Reset Tx interrupts	OUT	i8274DCommACtlrAddr, AL	%MesaLockedOut(AND, OFFSET rs232DCB.rsCommandWorkList, clearAbortTx, rs232CFCB.rs232LockMask)RsCheckAbortRx:	MOV	AX, rs232DCB.rsCommandWorkList			AND	AX, abortRx	JNZ	RsAbortRx	JMP	RsCheckResetValuesRsAbortRx:	%Restart(RS232CHandlerID,OFFSET rS232CFCB.rxTaskChATcb,RsRxTaskLoop,OFFSET RS232CRxStack)	;-- If frameTimeOut is used then Jam the RS232C WatchDog task	CMP	rs232DCB.rsFrameTimeoutValue, 0	JE	RsAbortRxResetValues	%Jam (RS232CHandlerID, OFFSET rs232HdlOnly.rsWatchDogTcb)RsAbortRxResetValues:	XOR	AX, AX	MOV	rs232HdlOnly.rsBytesReceived, AX	MOV	rs232HdlOnly.rsRxCatchBufferCount, AX	MOV	rs232HdlOnly.rsRxCatchBufferIndex, AX	MOV	rs232HdlOnly.saveValueRR1, 0	MOV	rS232CFCB.rsQueueRxChA.queueNext, 0        MOV	rs232HdlOnly.rsReceiverInXOFFState, FALSE	MOV	rs232HdlOnly.rsRxBufferFrameTimeout, FALSE	MOV	rs232HdlOnly.rsSendFlowRequest, FALSE	MOV	rs232HdlOnly.rsRxActiveBuffer, FALSE	MOV	rs232HdlOnly.rsEndFrame, FALSE	MOV	rs232HdlOnly.rsFlowOff, FALSE	;---	MOV	AL, i8274CommCRCRstRx			;Reset Rx CRC checker	OUT	i8274DCommACtlrAddr, AL		%MesaLockedOut(AND, OFFSET rs232DCB.rsCommandWorkList, clearAbortRx, rs232CFCB.rs232LockMask)RsCheckResetValues:	MOV	AX, rs232DCB.rsCommandWorkList			AND	AX, resetValues	JZ	RsExitCheckCommandList	MOV	rs232HdlOnly.rsRxCatchBufferCount, 0	MOV	rs232HdlOnly.rsRxCatchBufferIndex, 0	MOV	rs232HdlOnly.rsReceiverInXOFFState, FALSE	MOV	rs232HdlOnly.rsFlowOff, FALSE	MOV	rs232HdlOnly.rsSendFlowRequest, FALSE	%MesaLockedOut(AND, OFFSET rs232DCB.rsCommandWorkList, clearResetValues, rs232CFCB.rs232LockMask)RsExitCheckCommandList:	RETRSCheckCommandList	ENDP;	************************;; This routine updates FCB statuses including Read Register 0, 1, and 2,; and the IOP port status (80H)	which effects two parameters the rsIOPSystemInputPort,; and rsLatchedStatus which records if ringIndicator has been heard.; No register inputs and no register outputs;      ReadAllStatusRegisters PROC NEAR	PUSH    DX	PUSH    CX	PUSH	AX	CLI	MOV	DX, i8274DCommACtlrAddr	CMP	rs232DCB.rs232Mode, asynch	;-- perform 2 reset external status interrupt commands	;-- to get the true readings of CTS and CD bits	;-- since not catching external/status interrupts in asynch mode	JNE	RsReadAllRegisters	MOV	AL, i8274RstIntrCommand	OUT	DX, AL	MOV	AL, i8274RstIntrCommand	OUT	DX, ALRsReadAllRegisters:	MOV	AL, i8274ReadRegister0	OUT	DX,  AL			;Point to RR0	IN	AL, DX			;get RR0	MOV	rS232DCB.rsReadRegister0, AL	MOV	AL, i8274ReadRegister1	OUT	DX, AL			;Point to RR1	IN	AL, DX			;get RR1	MOV	rS232DCB.rsReadRegister1, AL	IN	AX, ReadInputPort	;Read input port	MOV	rs232DCB.rsIOPSystemInputPort, AX	MOV	CX, AX	AND	AX, iopRingIndctr	;Ring Heard?	JNZ	CheckNextLatchStatus	MOV	AL, rs232DCB.rsLatchedStatus	MOV	DL, AL	AND	AL, latchRingHeard	;Already set	JNZ	CheckNextLatchStatus	MOV	AL, DL	XOR	AL, latchRingHeard	;Set RingHeard	MOV	rs232DCB.rsLatchedStatus, ALCheckNextLatchStatus: 	;-- Set other status here if needed later	STI	POP	AX	POP     CX	POP     DX	RETReadAllStatusRegisters	ENDP ;	******************; This routine updates the status in the current IOCB. NOTE: This routine assumes ; there is an IOCB pointed to by ES:[DI].  The status update come from the FCB; rather that from directly reading the chip to assure that the same statuses exist; in the FCB and the IOCB.  This means to have the latest info on the chip; ReadAllStatusRegisters must be called first.; PutAllRRegStatusInIOCB	PROC NEAR	MOV	AL, rS232DCB.rsReadRegister0	MOV	ES:[DI].rsIocbStatusByte0, AL	MOV	AL, rS232DCB.rsReadRegister1	MOV	ES:[DI].rsIocbStatusByte1, AL	MOV	AL, rS232DCB.rsReadRegister2	MOV	ES:[DI].rsIocbStatusByte2, ALExitPutAllRegInIOCB:	RETPutAllRRegStatusInIOCB ENDP	;	******************;************************************************************************;;  	 Bad Interupt Service Routines		ASSUME	DS:NOTHING;************************************************************************; This routine is called when a txBufferEmpty interrupt comes in when the Rs232CTx task; is not waiting for it. BadTxInterrupt	PROC	FARRsBadTxInt:	%EstablishHandlerAccess (RS232CHandlerID)		ASSUME	ES:RS232CIOR	INC	rS232DCB.badTxIntCnts			;count up bad intr.	MOV     AL, serialCmd5			;Reset Tx interrupts	OUT	i8274DCommACtlrAddr, ALRsBadTxIntEnd: 	RET			BadTxInterrupt	ENDP		ASSUME	ES:NOTHING;	******************; This routine is called when a rxCharacter interrupt comes in when the Rs232CRx task; is not waiting for it.BadRxInterrupt	PROC	FARRsBadRxInt:	PUSH	DS		%EstablishHandlerAccess (RS232CHandlerID)	MOV	AX, ES	MOV	DS, AX		ASSUME	DS:RS232CIOR	IN      AL, i8274DCommADataAddr	; This has been added to take into account situations which could occur	; if the task was at system level when an interrupt occurs.	CMP	rs232DCB.rs232Mode, asynch	JNE	RsBadIntCharacterLost	CMP	rs232HdlOnly.rsRxActiveBuffer, TRUE	JNE	RsBadIntCheckBufFull	CMP	rs232HdlOnly.rsRxBufferFrameTimeout, TRUE	JNE	RsBadIntCharacterLostRsBadIntCheckBufFull:	CMP	rs232HdlOnly.rsRxCatchBufferCount, rsRxCatchBufferSize	JE	RsBadIntCharacterLost	CALL	RsRxSkinCharacterOfBits	CALL	RsRxCheckForFlowCharacter	CMP	BL, TRUE	JE	RsBadIntCharacterExit	MOV	DI, rs232HdlOnly.rsRxCatchBufferCount	;Put character in catch buffer	MOV	rs232HdlOnly.rsRxCatchBuffer[DI], AL	INC	rs232HdlOnly.rsRxCatchBufferCount		;Update pointer  	JMP	RsBadIntCharacterExitRsBadIntCharacterLost:	INC	rS232DCB.badRxIntCnts		;Increment the number of bad int	%MesaLockedOut(OR, OFFSET rs232DCB.rsLatchedStatus, latchDataLost, rs232CFCB.rs232LockMask)RsBadIntCharacterExit:	POP	DS	RET					;The waitForInterrupt is still in effectBadRxInterrupt	ENDP 	ASSUME	DS:NOTHING;	******************; This routine is called when a specRx interrupt comes in when the Rs232CSpecRx; task is not waiting for it.BadSpecRxInterrupt	PROC	FARRsBadSpecRxInt:	%EstablishHandlerAccess (RS232CHandlerID)		ASSUME	ES:RS232CIOR	INC	rS232DCB.badSpecRxIntCnts	;Increment the number of intr. counts	MOV	AL, i8274ErrorReset		;reset error latches in RR1	OUT	i8274DCommACtlrAddr, AL		;to enable other error conditions	RET				;The waitForInterrupt is still in effectBadSpecRxInterrupt	ENDP 		ASSUME	ES:NOTHING;	******************; This routine is called when an externalStatus interrupt comes in when the ; Rs232CExtStat task is not waiting for it.BadExtStatInterrupt	PROC	FARRsBadExtStatInt:	%EstablishHandlerAccess (RS232CHandlerID)		ASSUME	ES:RS232CIOR	INC	rS232DCB.badExtStatIntCnts	;Increment the number of intr. counts	MOV	AL, i8274RstIntrCommand		;reset Ext/Status Interrupt 	OUT	i8274DCommACtlrAddr, AL			MOV	AL, i8274RstIntrCommand		;reset Ext/Status Interrupt 	OUT	i8274DCommACtlrAddr, AL		RET				;The waitForInterrupt is still in effectBadExtStatInterrupt	ENDP 		ASSUME	ES:NOTHING;			******************IOPEInRAM	ENDS			END
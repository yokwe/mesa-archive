{ImageProcessing.dfnCreated:	 8-Oct-87 15:27:32,	JPM,	from Daybreak.dfn, Floyd.dfn, GrayBlt.dfn, and Mesa.dfnLast edited:	13-Nov-87 13:09:59,	JPM,	comment out register definitions (still in Daybreak.dfn) and link macros (still in Mesa.dfn)}{	Copyright (C) 1987 by Xerox Corporation.  All rights reserved. }{{R AND RH REGISTER DEFINITIONS}RegDef[Grayword,	R,	0]; {BLTLineGray}RegDef[length,		R,	0]; {ChainBlt}RegDef[Count,		R,	0]; {CountBits}RegDef[width,		R,	0]; {FlipX}RegDef[rTT2,		R,	0]; {Floyd: temp R register}RegDef[rCount,		R,	0]; {GrayBlt, Scale}RegDef[rMargin,		R,	0]; {LineBreak}RegDef[rReason,		R,	0]; {LineBreak}RegDef[wplDst,		R,	0]; {Rotate}RegDef[GCount,		R,	1]; {BLTLineGray}RegDef[tempC,		R,	1]; {BLTLineGray: the Count register is free sometimes to be used as a temp register tempC for other operations}RegDef[offset,		R,	1]; {BumpBitAddress}RegDef[rdstlow,		R,	1]; {ChainBlt}{RegDef[VD,		R,	1]; {ComMapSub}}RegDef[Limit,		R,	1]; {CountBits}RegDef[rtemp,		R,	1]; {FlipX}RegDef[rError,		R,	1]; {Floyd: new error for current pixel value }RegDef[PIX,		R,	1]; {Floyd: current pixel pair }RegDef[rSumLow,		R,	1]; {GrayBlt}RegDef[rThreshold,	R,	1]; {GrayBlt}RegDef[rGrTRC,		R,	1]; {GrayBlt}RegDef[rSrcWord,	R,	1]; {Halftone: working source pixels(2)}RegDef[rMicaLength,	R,	1]; {LineBreak}RegDef[wplSrc,		R,	1]; {Rotate}RegDef[rPPW,		R,	1]; {Scale}RegDef[rhFunction,	RH,	1]; {BLTLineGray}RegDef[rhdsthigh,	RH,	1]; {ChainBlt}{RegDef[rhVD,		RH,	1]; {BitBlt}}RegDef[rhGrTRC,		RH,	1]; {GrayBlt}RegDef[DstBit,		R,	2]; {BLTLineGray}RegDef[rwrdaddh,	R,	2]; {BumpBitAddress}RegDef[bitWidth,	R,	2]; {ComMapSub}RegDef[byteWidth,	R,	2]; {ComMapSub}RegDef[wordWidth,	R,	2]; {ComMapSub}RegDef[rrightreal,	R,	2]; {FlipX}RegDef[rSrcReal,	R,	2]; {Floyd, GrayBlt, Scale}RegDef[rScanLineLength,	R,	2]; {Halftone}RegDef[rNewHToffset,	R,	2]; {Halftone}RegDef[rHalfToneElement,R,	2]; {Halftone: current Halftone element}RegDef[rTextReal,	R,	2]; {LineBreak}RegDef[rSylCount,	R,	2]; {LineBreak}RegDef[dstWidth,	R,	2]; {TrapezoidBlt dst width, bits}RegDef[rhrightreal,	RH,	2]; {FlipX}RegDef[rhSrcReal,	RH,	2]; {Floyd, GrayBlt, Scale}RegDef[rhTextReal,	RH,	2]; {LineBreak}RegDef[rSrcLow,		R,	3]; {Floyd: real source address low 16 bits}RegDef[rHTAddrLo,	R,	3]; {Halftone: current Halftone lo addr}RegDef[rMinSpMLength,	R,	3]; {LineBreak: must be saved and restored}RegDef[rSylType,	R,	3]; {LineBreak: must be saved and restored}RegDef[rSylBitLength,	R,	3]; {LineBreak: must be saved and restored}RegDef[rhSrcHi,		RH,	3]; {Floyd: real source address high 5 bits}RegDef[rhHTAddrHi,	RH,	3]; {Halftone: current Halftone hi addr}RegDef[rDstLow,		R,	4]; {Floyd: real destination address low 16 bits}RegDef[rSrcPixel,	R,	4]; {Halftone: current source pixel}RegDef[rMinSpPLength,	R,	4]; {LineBreak: must be saved and restored}RegDef[rFit,		R,	4]; {LineBreak: must be saved and restored}RegDef[rSylByteCount,	R,	4]; {LineBreak: must be saved and restored}RegDef[rhDstHi,		RH,	4]; {Floyd: real destination address high 5 bits}RegDef[rErrLow,		R,	5]; {Floyd: real error address low 16 bits}RegDef[rWhiteSpaceIncr,	R,	5]; {LineBreak: must be saved and restored}RegDef[rMinWidth,	R,	5]; {LineBreak: must be saved and restored}RegDef[rhErrHi,		RH,	5]; {Floyd: real error address hi 5 bits}RegDef[rRealDest,	R,	6]; {BLTLineGray}RegDef[SrcBit,		R,	6]; {CountBits}RegDef[rleftreal,	R,	6]; {FlipX}RegDef[rTT,		R,	6]; {Floyd: temp R register} RegDef[rDstReal,	R,	6]; {Floyd, GrayBlt, Scale}RegDef[rHTOffset,	R,	6]; {Halftone: current Halftone offset}RegDef[rArgReal,	R,	6]; {LineBreak}RegDef[rCacheObj,	R,	6]; {LineBreak}RegDef[srcBitOffset,	R,	6]; {TrapezoidBlt gray brick bit offset}RegDef[TzbUpdVar,	R,	6]; {TrapezoidBlt update loop variables reg.}RegDef[rhRealDest,	RH,	6]; {BLTLineGray}RegDef[rhleftreal,	RH,	6]; {FlipX}RegDef[rhDstReal,	RH,	6]; {Floyd, GrayBlt, Scale}RegDef[rhArgReal,	RH,	6]; {LineBreak}RegDef[rhCacheObj,	RH,	6]; {LineBreak}RegDef[rOldErrorLow,	R,	7]; {Floyd: previous pixel location in real error buffer}RegDef[rGr00FF,		R,	7]; {GrayBlt: must restore to 0100 at int/fault/exit}RegDef[rCtMinusIx,	R,	7]; {LineBreak: must restore to 0100 at exit}RegDef[rhOldErrorHi,	RH,	7]; {Floyd: previous pixel location in real error buffer}{RegDef[rTemp,		R,	9]; {GrayBlt, Scale}}RegDef[bitnum,		R,	9]; {BumpBitAddress}RegDef[DBit,       	R,	9]; {ComMapSub}RegDef[DByte,       	R,	9]; {ComMapSub}RegDef[rwork,		R,	9]; {FlipX}RegDef[rTT3,		R,	9]; {Floyd: temp R register}RegDef[rDstOrgWord,	R,	9]; {Halftone: current original dest word}RegDef[rBitLength,	R,	9]; {LineBreak}RegDef[rDstVirt,	R,	9]; {Rotate}RegDef[Tzbtmp,		R,	9]; {TrapezoidBlt temporary}{RegDef[rhTemp,		RH,	9]; {BandBLT, GrayBlt, Scale}}RegDef[rhLBHyphenPL,	RH,	9]; {LineBreak}RegDef[rtmpadd,		R,	0B]; {BumpBitAddress}RegDef[rchainbasel,	R,	0B]; {ChainBlt}RegDef[Regb,       	R,	0B]; {ComMapSub}RegDef[rcheck,		R,	0B]; {FlipX}RegDef[rTT4,		R,	0B]; {Floyd: temp R register} RegDef[rVirtualL,	R,	0B]; {FlipX, Floyd, GrayBlt, LineBreak, Scale}RegDef[rGrSrcTemp,	R,	0B]; {GrayBlt}RegDef[rDstPixel,	R,	0B]; {Halftone: current dest pixel}RegDef[rByteCount,	R,	0B]; {LineBreak}RegDef[rSrcVirt,	R,	0B]; {Rotate}RegDef[dstBitAdjust,	R,	0B]; {TrapezoidBlt dst bit adjustment}RegDef[TzbAnother,	R,	0B]; {TrapezoidBlt working register}RegDef[rhchainbaseh,	RH,	0B]; {ChainBlt}RegDef[rhVirtualH,	RH,	0B]; {FlipX, Floyd, GrayBlt, LineBreak, Scale}RegDef[rhGrSrcTemp,	RH,	0B]; {GrayBlt}RegDef[rhSrcVirt,	RH,	0B]; {Rotate}RegDef[SourceData,	R,	0C]; {BLTLineGray}RegDef[rtmpbit,		R,	0C]; {BumpBitAddress}RegDef[writebit,	R,	0C]; {ChainBlt}RegDef[BARealALo,	R,	0C]; {ComMapSub}RegDef[Data,		R,	0C]; {CountBits, Scale}RegDef[rcount,		R,	0C]; {FlipX}RegDef[rGrFF00,		R,	0C]; {GrayBlt}RegDef[rAddrLo,		R,	0C]; {Halftone: current real lo addr}RegDef[rSpCount,	R,	0C]; {LineBreak: paired with rhSuffixChar}RegDef[wordCount,	R,	0C]; {Rotate: linked with rhDstVirt for fast map loop}RegDef[BARealAHi,	RH,	0C]; {ComMapSub}RegDef[rhGrDispCond,	RH,	0C]; {GrayBlt}RegDef[rhAddrHi,	RH,	0C]; {Halftone: current real hi addr}RegDef[rhSuffixChar,	RH,	0C]; {LineBreak: paired with rSpCount}RegDef[rhDstVirt,	RH,	0C]; {Rotate: linked with wordCount for fast map loop}RegDef[temp,	        R,      0E]; {BLTLineGray}RegDef[rwrdaddl,	R,	0E]; {BumpBitAddress}RegDef[rchaintemp,	R,      0E]; {ChainBlt}RegDef[rworkR,		R,	0E]; {FlipX}RegDef[rThisCell,	R,	0E]; {Floyd: R Register of UThisCell}RegDef[rSumHigh,	R,	0E]; {GrayBlt}RegDef[rDstWord,	R,	0E]; {GrayBlt}RegDef[rMaskN,		R,	0E]; {GrayBlt}RegDef[rDstBitCount,	R,	0E]; {Halftone: current dst bit offset}RegDef[rWhiteSpace,	R,	0E]; {LineBreak}RegDef[bitCount,	R,	0E]; {Rotate}RegDef[srcData,		R,	0E]; {Rotate}RegDef[rPixelCount,	R,	0E]; {Scale}RegDef[srcWrdOffset,	R,	0E]; {TrapezoidBlt source word offset in bits}RegDef[rHE,	        RH,     0E]; {BLTLineGray}RegDef[rhDstWord,	RH,	0E]; {GrayBlt}RegDef[rhLBFlags,	RH,	0E]; {LineBreak}{U REGISTER DEFINITIONS}{U REGISTER BLOCK 0 -- EMULATOR STACK}RegDef[uyStack,		UY,	0]; {GrayBltSubs AltUaddr addressing}RegDef[Urleft,		U,	2]; {FlipX}RegDef[uArgVL,		U,	2]; {Floyd: arg. pointer into virtual space (low 16 bits)}RegDef[uCount,		U,	2]; {Floyd: number of input pixels}RegDef[uGrDstLow,	U,	2]; {GrayBlt}RegDef[uGrSumLow,	U,	2]; {GrayBlt}RegDef[uHTsrcLo,	U,	2]; {Halftone: source pointer lo}RegDef[uSBTGDstVALow,	U,	2]; {Scale}{RegDef[UDtzVALo,	U,	2]; {TrapezoidBlt lower Dst VAddr}}RegDef[UTrapezBltArgLo,	U,	2]; {TrapezoidBlt argument pointer lo}RegDef[Urhleft,		U,	3]; {FlipX}RegDef[uArgVH,		U,	3]; {Floyd: arg. pointer into virtual space (high 8 bits)}RegDef[uThreshAndMax,	U,	3]; {Floyd: threshold and max value}RegDef[uGrDstHigh,	U,	3]; {GrayBlt}RegDef[uGrSumHigh,	U,	3]; {GrayBlt}RegDef[uHTsrcHi,	U,	3]; {Halftone: source pointer hi}RegDef[uSBTGDstVAHigh,	U,	3]; {Scale}{RegDef[UdstBpl,	U,	3]; {TrapezoidBlt dst bits per line}}RegDef[UTrapezBltArgHi,	U,	3]; {TrapezoidBlt argument pointer hi}RegDef[Uwidth,		U,	4]; {FlipX}RegDef[uSaveINWrd,	U,	4]; {Floyd: save input word containing 2 pixels}RegDef[uGrDstBit,	U,	4]; {GrayBlt}RegDef[uGrDstByte,	U,	4]; {GrayBlt}RegDef[uHTsrcByteOffset,U,	4]; {Halftone: source byte offset}RegDef[uSBTGDstByte,	U,	4]; {Scale}{RegDef[UStzVALo,	U,	4]; {TrapezoidBlt lower Src VAddr}}RegDef[uInPtrVH,	U,	5]; {Floyd: ptr. to input gray scale data in virtual space (high 8 bits) }RegDef[uGrDstBPL,	U,	5]; {GrayBlt}RegDef[uHTscanLineLength,U,	5]; {Halftone: scan line length}RegDef[uSBTGSrcVALow,	U,	5]; {Scale}{RegDef[UrhTzbVSD,	U,	5]; {TrapezoidBlt higher Src and Dst VAddr}}RegDef[uInPtrVL,	U,	6]; {Floyd: ptr. to input gray scale data in virtual space (low 16 bits) }RegDef[uGrSrcLow,	U,	6]; {GrayBlt}RegDef[uHTlineLo,	U,	6]; {Halftone: cell line pointer lo}RegDef[uSBTGSrcVAHigh,	U,	6]; {Scale}{RegDef[UXMinValFrac,	U,	6]; {TrapezoidBlt interpolator}}RegDef[uOutPtrVH,	U,	7]; {Floyd: pointer to output bit data in virtual space (high 8 bits) }RegDef[uGrSrcHigh,	U,	7]; {GrayBlt}RegDef[uHTlineHi,	U,	7]; {Halftone: cell line pointer hi}RegDef[uSBTGSrcBit,	U,	7]; {Scale}{RegDef[UXMinValInt,	U,	7]; {TrapezoidBlt interpolator}}RegDef[uOutPtrVL,	U,	8]; {Floyd: pointer to output bit data in virtual space (low 16 bits)}RegDef[uGrSrcByte,	U,	8]; {GrayBlt}RegDef[uHTlineLength,	U,	8]; {Halftone: cell line length}RegDef[uSBTGSrcBPL,	U,	8]; {Scale}RegDef[UXMindValFrac,	U,	8]; {TrapezoidBlt interpolator}RegDef[uErrorPtrVH,	U,	9]; {Floyd: pointer to error data in virtual space (high 8 bits)}RegDef[uGrSrcBPL,	U,	9]; {GrayBlt}RegDef[uHTlineOffset,	U,	9]; {Halftone: offset into cell line}RegDef[uSBTGPixelCount,	U,	9]; {Scale}RegDef[UXMindValInt,	U,	9]; {TrapezoidBlt interpolator}RegDef[uErrorPtrVL,	U,	0A]; {Floyd: pointer to error data in virtual space (low 16 bits)}RegDef[uGrWidth,	U,	0A]; {GrayBlt}RegDef[uHTdstLo,	U,	0A]; {Halftone: dest. pointer lo}RegDef[uSBTGScale,	U,	0A]; {Scale}RegDef[UXMaxValFrac,	U,	0A]; {TrapezoidBlt interpolator}RegDef[uBit,		U,	0B]; {Floyd: Bit-address of output pixel (only used on PF returns)}RegDef[uGrHeight,	U,	0B]; {GrayBlt}RegDef[uHTdstHi,	U,	0B]; {Halftone: dest. pointer hi}RegDef[uSBTGLineCount,	U,	0B]; {Scale: fZ = ¬RH}RegDef[UXMaxValInt,	U,	0B]; {TrapezoidBlt interpolator}RegDef[uFWDError,	U,	0C]; {Floyd: forward error}RegDef[uGrFlags,	U,	0C]; {GrayBlt}RegDef[uGrThreshold,	U,	0C]; {GrayBlt}RegDef[uHTdstBitOffset,	U,	0C]; {Halftone: dest. bit offset}RegDef[uSBTGSrcBitWidth,U,	0C]; {Scale}RegDef[UXMaxdValFrac,	U,	0C]; {TrapezoidBlt interpolator}RegDef[uRTError,	U,	0D]; {Floyd: right error}RegDef[uGrTRCLow,	U,	0D]; {GrayBlt}RegDef[uGrDstWord,	U,	0D]; {GrayBlt}RegDef[uHTinvertReq,	U,	0D]; {Halftone: invert dest. boolean}RegDef[UXMaxdValInt,	U,	0D]; {TrapezoidBlt interpolator}RegDef[uMIDError,	U,	0E]; {Floyd: middle error}RegDef[uGrTRCHigh,	U,	0E]; {GrayBlt}{RegDef[UTzbFlags,	U,	0E]; {TrapezoidBlt flags}}RegDef[uSTKMisc,	U,	0F]; {Floyd: Misc. values for interrupt/fault handling}{RegDef[UTzbHeight,	U,	0F]; {TrapezoidBlt object height, rA = Rbb0 = 0}}{U REGISTER BLOCK 6 -- EMULATOR}RegDef[uLBTextRealLo,	U,	60]; {LineBreak}RegDef[uLBArgRealLo,	U,	63]; {LineBreak}RegDef[uLBArgRealHi,	U,	64]; {LineBreak}RegDef[uLBTextCount,	U,	65]; {LineBreak}RegDef[uLBCacheLo,	U,	66]; {LineBreak}RegDef[uLBCacheHi,	U,	67]; {LineBreak}RegDef[uLBFont,		U,	68]; {LineBreak}RegDef[uLBPendSyl,	U,	69]; {LineBreak}RegDef[uLBPCtMinusIx,	U,	6A]; {LineBreak}RegDef[uLBPMicaLength,	U,	6B]; {LineBreak}RegDef[uLBPBitLength,	U,	6C]; {LineBreak}RegDef[uLBPSpCount,	U,	6D]; {LineBreak}RegDef[uLBPByteCount,	U,	6E]; {LineBreak}RegDef[uLBPWhiteSpace,	U,	6F]; {LineBreak}{U REGISTER BLOCK B}RegDef[uSBTGDstTempLow,	U,	0BC]; {Scale}RegDef[uSBTGDstTempHigh,U,	0BD]; {Scale}RegDef[uSBTGSrcTempLow,	U,	0BE]; {Scale: rA = rVirtualL}RegDef[uSBTGSrcTempHigh,U,	0BF]; {Scale}{U REGISTER BLOCK C -- EMULATOR}RegDef[uHTlineRealLo,	U,	0C0]; {Halftone: HT line Real Addr lo}RegDef[UtmpHi,		U,	0C0]: {TrapezoidBlt save Source hi virt addr}RegDef[uHTlineRealHi,	U,	0C1]; {Halftone: HT line Real Addr hi}RegDef[UtmpLo,		U,	0C1]: {TrapezoidBlt save Source lo virt addr}RegDef[uHTdstRealLo,	U,	0C2]; {Halftone: Dst Real Addr lo}RegDef[uHTdstRealHi,	U,	0C3]; {Halftone: Dst Real Addr hi}RegDef[uHTsrcRealHi,	U,	0C5]; {Halftone: Src Real Addr hi}RegDef[uHTsrcRealLo,	U,	0CB]; {Halftone: Src Real Addr lo}RegDef[uSBTGHold,	U,	0CB]; {Scale: rA = BARealALo, fZ = ¬RH}{U REGISTER BLOCK E -- EMULATOR}RegDef[uyBlockE,	UY,	0E]; {Rotate: rA = srcData}RegDef[uPolarity,	U,	0E0]; {Floyd: invert output flag -- rA = rThisCell = 0E}RegDef[uGrCurrSrcLow,	U,	0E0]; {GrayBlt}RegDef[uHTmaskN,	U,	0E0]; {Halftone: pixel mask}RegDef[uByte,		U,	0E1]; {Floyd: Byte-address of input pixel}RegDef[uGrCurrSrcHigh,	U,	0E1]; {GrayBlt}RegDef[uRtnReason,	U,	0E2]; {Floyd: reason for saving state and return type}RegDef[uGrCurrDstLow,	U,	0E2]; {GrayBlt}RegDef[uThreshold,	U,	0E3]; {Floyd: work threshold}RegDef[uGrCurrDstHigh,	U,	0E3]; {GrayBlt}RegDef[uMaxValue,	U,	0E4]; {Floyd: work max value}RegDef[uGrSaveCarry,	U,	0E4]; {GrayBlt}RegDef[uBlockEF,	U,	0EF]; {Rotate: rA = srcData}{U REGISTER BLOCK F -- EMULATOR}RegDef[USavelength,	U,	0F4]; {ChainBlt}RegDef[UdstWidth,	U,	0F4]: {TrapezoidBlt temp storage}RegDef[USavecount,	U,	0F5]; {ChainBlt}RegDef[UyOffset,	U,	0F5]: {TrapezoidBlt yOffset storage }RegDef[USavedstbit,	U,	0F6]; {ChainBlt}RegDef[USavechainbasel,	U,	0F7]; {ChainBlt}RegDef[Urightreal,	U,	0F7]; {FlipX}RegDef[Utmpdstbit,	U,	0F7]: {TrapezoidBlt tmp dst bit offset}RegDef[USavewritebit,	U,	0F8]; {ChainBlt}RegDef[Urhrightreal,	U,	0F8]; {FlipX}{RegDef[UtzDstBit,	U,	0F8]: {TrapezoidBlt dst bit offset}}RegDef[USavedstlow,	U,	0F9]; {ChainBlt}RegDef[Urright,		U,	0F9]; {FlipX}{RegDef[UtzSrcBit,	U,	0F9]: {TrapezoidBlt src bit offset}}RegDef[USavechainbaseh,	U,	0FA]; {ChainBlt}RegDef[Urhright,	U,	0FA]; {FlipX}RegDef[USavedsthigh,	U,	0FB]; {ChainBlt}RegDef[Uworkrleft,	U,	0FB]; {FlipX}RegDef[Uworkrhleft,	U,	0FC]; {FlipX}RegDef[UWrkrhVD,	U,	0FC]: {TrapezoidBlt temp higher Dst VAddr}RegDef[USavecheck,	U,	0FD]; {FlipX}RegDef[Urleftreal,	U,	0FE]; {FlipX}RegDef[UWrkrhVS,	U,	0FE]: {TrapezoidBlt temp higher Src VAddr}RegDef[Urhleftreal,	U,	0FF]; {FlipX}}{---------------------------------------------------------}{Image processing subroutine return points}{L0	LoadTable}{MacroDef[LoadTableRet, at[#1,10,LoadTableRtn]];}Set[L0.GrBLT,		0];Set[L0.GrSum,		4];Set[L0.GrThreshold,	8];Set[L0.SBTG,		9];{L0	MapSrc}{MacroDef[MapSrcRet, at[#1,10,MapSrcRtn]];}{MacroDef[MapSrcF, at[#1,10,MapSrcFault]];}Set[L0.ChainBlt,	7];Set[L0.CountBits,	6];Set[L0.FlipXRight,	0D];Set[L0.FlipXLast,	0F];Set[L0.Floyd,		0C];Set[L0.FloydLoop,	0E];{Set[L0.GrBLT,		0];}Set[L0.GrBLTTRC,	1];Set[L0.GrBLTLoop,	3];{Set[L0.GrSum,		4];}Set[L0.GrSumLoop,	5];{Set[L0.GrThreshold,	8];}Set[L0.GrThresholdLoop,	0A];Set[L0.GrThresholdExtra,0B];Set[L0.LineBreak,	2];{Set[L0.SBTG,		9];}{L0	MapDst}{MacroDef[MapDstRet, at[#1,10,MapDstRtn]];}{MacroDef[MapDstF, at[#1,10,MapDstFault]];}Set[L0.BLTLineGray,	1];{Set[L0.FlipXLast,	0F];}Set[L0.FloydErrBuf,	0D];{Set[L0.FloydLoop,	0E];}Set[L0.FloydLoopErrBuf,	0C];{Set[L0.GrBLT,		0];}{Set[L0.GrBLTLoop,	3];}{Set[L0.GrThreshold,	8];}{Set[L0.GrThresholdLoop,0A];}{Set[L0.GrThresholdExtra,0B];}{Set[L0.LineBreak,	2];}{Set[L0.SBTG,		9];}{L1	BumpByteVA}{MacroDef[BumpByteVARet, at[#1,10,BumpByteVARtn]];}Set[L1.GrBLTDstEOL,	0];Set[L1.GrBLTSrcEOL,	1];Set[L1.GrBLTAdjDst,	2];Set[L1.GrBLTDstNextItem,3];Set[L1.GrThresholdAdjDst,4];Set[L1.GrThresholdDstNextItem,5];Set[L1.GrAdjSrc,	6];Set[L1.GrSrcNextItem,	7];Set[L1.GrSrcPageCross,	8];Set[L1.GrDstPageCross,	9];{L0	LRotateN}{MacroDef[LRotateNRet, at[#1,10,RMaskNRtn]];}{Set[L0.BLTLineGray,	1];}{Set[L0.GrThreshold,	8];}Set[L0.fCaseData,	6];{Set[L0.SBTG,		9];}{L0	RMaskN}{MacroDef[RMaskNRet, at[#1,10,RMaskNRtn]];}Set[L0.BLTLineGrayStart,0];Set[L0.BLTLineGrayUnique,2];Set[L0.BLTLineGrayEnd,	3];Set[L0.iCaseMask,	7];{L1	LinkSet}{MacroDef[LinkSetRet, at[#1,10,LinkSetRtn]];}Set[L1.GrBLTSetL2,	0];Set[L1.GrBLTSetL3,	1];Set[L1.GrBLTSetL4,	2];Set[L1.GrBLTSetL5,	3];Set[L1.GrBLTAdjL3,	0C]; {must equal 0C}Set[L1.GrBLTAdjL5,	0D];{L3	BltLineGray}Set[L3.ChainBltBLG,	6];Set[L3.TrapzBLG,	3];{L3	ComMap}Set[L3.ChainBlt,	4];Set[L3.FlipX,		0D];Set[L3.FloydSrc,	5];Set[L3.FloydDst,	6];Set[L3.FloydErrBuf,	7];Set[L3.HTsrcMap,	0B];Set[L3.HTlineMap,	0C];Set[L3.HTdstMap,	0A];Set[L3.SBTGDst,		8];Set[L3.SBTGSrc,		9];Set[L3.TrapzArg,	0];Set[L3.TrapzSrc,	1];Set[L3.TrapzDst,	2];{L4	BumpBitAddress}Set[L4.BumpBitAddress,	0];Set[L4.ChainBlt,	9];Set[L4.SBTG,		0D];Set[L4.TrapzLoop,	4];Set[L4.TrapzBump,	5];{---------------------------------------------------------}{Definitions for the FLOYD algorithm}{Created by:    Martin J. Shramo - June, 1986 Last Edited:	 30-Oct-86 13:56:22}Set[ThisCellInitVal,	01];	{ uThisCell initial value }Set[PFRtn,		0];	{ page fault return flag for uSTKMisc }Set[INTRtn,		04];	{ interrupt return for uSTKMisc }Set[ArgBoundry,		0F];	{ offset for argument list in block }{---------------------------------------------------------}{Definitions for GrayBlt opcodes Created: March 7, 1986 by Jeff Goldfield Last Edited: July 23, 1986 by John Monahan; Additional comments October 14, 1986}{Table loading: size in words, initial offset into stack}Set[GBSizeLess1,	0C];Set[SumSizeLess1,	5];Set[ThresholdSizeLess1,	0A];Set[GBLastIndex,	0E];Set[SumLastIndex,	0B];Set[ThresholdLastIndex,	0C];{GRAYBLT roadmap definitions}Set[gr.fwd,0],Set[gr.rev,8];Set[gr.aligned,0],Set[gr.trc.unaligned.fwd,2],Set[gr.unaligned.fwd,4],Set[gr.unaligned.rev,6];Set[gr.trc.set,4];Set[gr.null,0],Set[gr.inv,1];Set[gr.readDest,0C],Set[gr.writeDest.fwd,7],Set[gr.writeDest.rev,0F],Set[gr.rotateSource.fwd,5],Set[gr.rotateSource.rev,0D],Set[gr.trc,8],Set[gr.trc.aligned,0],Set[gr.trc.unaligned.rev,3];Set[gr.highByteOnly,8],Set[gr.lowByteOnly,1];Set[gr.set,0],Set[gr.add,2],Set[gr.subtract,4],Set[gr.average,6];Set[gr.trc.inHighByte,0],Set[gr.trc.inLowByte,1];Set[gr.noCarry,0],Set[gr.carry,1],Set[gr.noPgCarry,0],Set[gr.pgCarry,1],Set[gr.noCarryover,0],Set[gr.carryover,8];Set[gr.setOK,gr.carryover],Set[gr.trc.setOK,0];Set[gr.bit0,0],Set[gr.bit1,1];Set[gr.noPgCross,0],Set[gr.pgCross,2];{Additional constants and macros: referenced constants found in Mesa.dfn}Set[L0.GrBLTInt, Or[L0.GrBLT,1]];Set[L0.GrSumInt, Or[L0.GrSum,1]];Set[L0.GrThresholdInt, Or[L0.GrThreshold,1]];MacroDef[MapGrSrcI, at[#1,10,MapGrSrcInt]];{ End }
{File name:  RESSupport.mcDescription: RES opcodes to decode, predict, or encode image dataAuthor: JPMCreated: 8-Oct-87Last edited:13-Nov-87 -- JPM -- fix bug at NormalExitc1+2 (restore rCode from rhCode instead of from Q)18-Nov-87 -- JPM -- fix bug at GetRuns src fault from GetN (cover all 4 cases); remove rotates in LoadLocalStream and StoreLocalStream}{ 	Copyright (C) 1987 by Xerox Corporation.  All rights reserved.}{Link register use:	L0 - returns from mapping subroutines	L1 - returns from map fix subroutines	L2 - predict/encode routing (0 = predict, 2 = encode)	      or RippleXOR offset (L2=0 for offset=5, 1 for 6, 2 for 7, 3 for 8)	L3 - returns from get/put subroutines	L4 - misc}@GETRUNS:	Xbus ¬ ErrnIBnStkp, XDisp, L0 ¬ L0.GetRuns,			c1, at[0,10,ESCBn];	rVirtualL ¬ uIMGVL, BRANCH[GetRunsReentry,$,7],			c2;	rhVirtualH ¬ uIMGVH, CALL[LoadLocalStream],			c3;	rSrcWord ¬ rDstWord,						c3, at[L0.GetRuns,10,LSRet];	uScanLineBits ¬ 0, rOffset ¬ 0,					c1;	uScanLineWord ¬ rDstWord ¬ 0, GOTO[GetRunsMapSrc],		c2;GetRunsReentry:	rhVirtualH ¬ uIMGVH, CALL[CheckLocalStream],			c3;	rSrcWord ¬ uStreamWord,						c3, at[L0.GetRuns,10,CSRet];	rSrcBits ¬ uStreamBits,						c1;	rDstWord ¬ uScanLineWord,					c2;GetRunsMapSrc:	CALL[RMapSrc],							c3;	rhVirtualH ¬ uScanLineVH,					c3, RMapSrcRet[L0.GetRuns];	Map ¬ rVirtualL ¬ [rhVirtualH, uScanLineVL], CALL[RMapDstc2],	c1;	rDstBits ¬ uScanLineBits, L3 ¬ L3.CodeHigh, CALL[GetN],		c3, RMapDstRet[L0.GetRuns];GetRunsLoop:	rCode ¬ Q, YDisp,						c2, at[L3.CodeHigh,10,GetNRet];	pCall3, DISP4[GetRunsSel1,3],					c3;{12 bit codes}	[] ¬ rSrcBits and ~0F, NZeroBr, CALL[GetNCont],			c1, at[0F,10,GetRunsSel1];	rCode ¬ rCode and 3, L3 ¬ L3.C12Low,				c2, at[L3.C12Mid,10,GetNRet];	rCode ¬ rCode LRot4 or Q, CALL[GetN],				c3;{the following code tests for illegal and special 12-bit codes:	SELECT Q FROM	  0 => GOTO Bump64s; -- special	  1, 2, 4, 8 => IF rCode < 1A THEN GOTO IllegalG; -- illegal, can use 8-bit codes	  ENDCASE => IF rCode < 2 THEN GOTO IllegalG; -- illegal, can use 8-bit codes}	Ybus ¬ Q and 0C, YDisp, L4 ¬ 2,					c2, at[L3.C12Low,10,GetNRet];	STK ¬ Q, DISP4[C12Hi],						c3;	Ybus ¬ Q and 3, YDisp, GOTO[C12DispLo], {disp to 0|1|2|3}	c1, at[0,10,C12Hi];	[] ¬ Q and 3, NZeroBr, L4Disp, GOTO[C12DispLo], {disp to 2|3}	c1, at[4,10,C12Hi];	[] ¬ Q and 3, NZeroBr, L4Disp, GOTO[C12DispLo], {disp to 2|3}	c1, at[8,10,C12Hi];	[] ¬ Q, NZeroBr, L4Disp, GOTO[C12DispLo], {force to 3}		c1, at[0C,10,C12Hi];C12DispLo:	Q ¬ 1A, DISP2[C12Lo],						c2;	uStreamWord ¬ rSrcWord, GOTO[Bump64s], {nibble=0}		c3, at[0,4,C12Lo];	[] ¬ rCode - Q, CarryBr, GOTO[C12CheckIllegal], {nibble=1}	c3, at[1,4,C12Lo];	[] ¬ rCode - Q, CarryBr, GOTO[C12CheckIllegal], {nibble=2|4|8}	c3, at[2,4,C12Lo];	[] ¬ rCode - 2, CarryBr, GOTO[C12CheckIllegal], {ENDCASE}	c3, at[3,4,C12Lo];	C12CheckIllegal:	Q ¬ STK, NZeroBr {always branch}, BRANCH[NormalOrIllegalG,BumpAndStore], c1;{4 bit codes}	[] ¬ rCode and 3, YDisp,					c1, at[0B,10,GetRunsSel1];	rOffset ¬ rOffset + 1, DISP2[GetRunsSel2],			c2;	Q ¬ 8, GOTO[High8c1],						c3, at[0,4,GetRunsSel2];	Q ¬ 4, GOTO[High8c1],						c3, at[1,4,GetRunsSel2];	Q ¬ 2, GOTO[High8c1],						c3, at[2,4,GetRunsSel2];	Q ¬ 1, GOTO[High8c1],						c3, at[3,4,GetRunsSel2];{8 bit codes}	[] ¬ rSrcBits and ~0F, NZeroBr, L3 ¬ L3.C8Low, CALL[GetNCont],	c1, at[3,10,GetRunsSel1];	[] ¬ rSrcBits and ~0F, NZeroBr, L3 ¬ L3.C8Low, CALL[GetNCont],	c1, at[7,10,GetRunsSel1];	rCode ¬ rCode LRot4 or Q,					c2, at[L3.C8Low,10,GetNRet];	Q ¬ 68,								c3;	rhCode ¬ rCode LRot0, rCode ¬ rCode - Q, NegBr,			c1;	rCode ¬ RShift1 (rCode + Q), YDisp, BRANCH[High8,Low8],		c2;Low8:	rCode ¬ RShift1 (rCode and ~1), NZeroBr, DISP4[Low8Sel,0C],	c3;	Q ¬ 8, ZeroBr {never branch}, BRANCH[NormalOrIllegalG,BumpAndStore], c1, at[0C,10,Low8Sel];	Q ¬ 4, ZeroBr {never branch}, BRANCH[NormalOrIllegalG,BumpAndStore], c1, at[0D,10,Low8Sel];	Q ¬ 2, ZeroBr {never branch}, BRANCH[NormalOrIllegalG,BumpAndStore], c1, at[0E,10,Low8Sel];	Q ¬ 1, ZeroBr {never branch}, BRANCH[NormalOrIllegalG,BumpAndStore], c1, at[0F,10,Low8Sel];High8:	Q ¬ rCode and 0F, BRANCH[$,High8Bump1,0E],			c3;	[] ¬ Q xor 8, ZeroBr,						c1;	[] ¬ Q xor 4, ZeroBr, BRANCH[$,SoiFoundExit],			c2;	rOffset ¬ rOffset + 1, BRANCH[High8c1,$],			c3;	Q ¬ 3, CALL[BumpCommon],					c1;High8c1:	CALL[BumpCommon],						c1;High8Bump1:	[] ¬ Q xor 8, ZeroBr,						c1;	[] ¬ Q xor 4, ZeroBr, BRANCH[$,NormalExit],			c2;	rOffset ¬ rOffset + 2, BRANCH[High8Bump1Call,$],		c3;	Q ¬ 3,								c1;	Noop,								c2;	Noop,								c3;High8Bump1Call:	rDstBits ¬ rDstBits + 4, CALL[BumpCommon],			c1;SoiFoundExit:	rStatus ¬ GetRuns.status.soiInData, CANCELBR[$],		c3;	GOTO[SetUpLocalStore],						c1;NormalOrIllegalG:	BRANCH[$,IllegalGExit],						c2;	rCode ¬ uWpl, GOTO[NormalExitc1],				c3;NormalExit:	rCode ¬ uWpl, CANCELBR[$],					c3;NormalExitc1:	rCode ¬ LShift1 (rCode + rCode),				c1;	[] ¬ rCode - rOffset, NegBr,					c2;	rCode ¬ rhCode, BRANCH[$,ScanTooLong],				c3;	rStatus ¬ GetRuns.status.ok, GOTO[SetUpLocalStore],		c1;ScanTooLong:	rStatus ¬ GetRuns.status.scanTooLong, GOTO[SetUpLocalStore],	c1;IllegalGExit:	rCode ¬ rCode or 0C0,						c3;	rStatus ¬ GetRuns.status.illegalGin12bit,			c1;SetUpLocalStore:	uStreamBits ¬ rSrcBits,						c2;	uStreamWord ¬ rSrcWord,						c3;	MAR ¬ [rhDstReal, rDstReal + 0],				c1;	MDR ¬ rDstWord,							c2;	rVirtualL ¬ uStreamVL,						c3;	Map ¬ MAR ¬ rVirtualL ¬ [rhVirtualH, rSrcReal + 0], {side-effect only} c1;	uStreamVL ¬ rVirtualL,						c2;	stackP ¬ 2,							c3;	rhVirtualH ¬ uIMGVH,						c1;	rVirtualL ¬ uIMGVL, L0 ¬ L0.GetRuns,				c2;	STK ¬ rCode, push, CALL[StoreLocalStream],			c3;	STK ¬ TOS, pop, GOTOABS[Bank1NxtInstc1],			c3, at[L0.GetRuns,10,SSRet];{interrupt returns}GetRunsInt:	uScanLineWord ¬ rDstWord, CANCELBR[$],				c2;	rVirtualL ¬ uStreamVL,						c3;	Map ¬ MAR ¬ rVirtualL ¬ [rhVirtualH, rSrcReal + 0], {side-effect only} c1;	uStreamVL ¬ rVirtualL,						c2;	uStreamBits ¬ rSrcBits, GOTOABS[Bank1Interrupt],		c3;{page fault returns}	GOTO[GetRunsFault],						c3, RMapSrcF[L0.GetRuns];	GOTO[GetRunsFault],						c3, RMapDstF[L0.GetRuns];	uFaultParm1 ¬ Q, L3Disp, CANCELBR[$,3],				c2, at[L1.GetN,10,RMFFaultRtn];	rTemp ¬ uStreamWord, DISP4[GetNBack],				c3;{src fault on first nibble of code: no backup}	Noop,								c1, at[L3.CodeHigh,10,GetNBack];	Q ¬ 10, GOTO[GetNPrevWord],					c2;{src fault on second nibble of 8-bit code: back up one nibble}	rTemp ¬ rTemp LRot12, GOTO[GetRunsSrcBackup1],			c1, at[L3.C8Low,10,GetNBack];{src fault on second nibble of 12-bit code: back up one nibble}	rTemp ¬ rTemp LRot12,						c1, at[L3.C12Mid,10,GetNBack];GetRunsSrcBackup1:	Q ¬ 0C, GOTO[GetNPrevWord],					c2;{src fault on third nibble of 12-bit code: back up two nibbles}	rTemp ¬ rTemp LRot8,						c1, at[L3.C12Low,10,GetNBack];	Q ¬ 8, GOTO[GetNPrevWord],					c2;GetNPrevWord:	rVirtualL ¬ rVirtualL - 1, CarryBr,				c3;	uStreamBits ¬ Q, BRANCH[$,GetNStoreDst],			c1;	Q ¬ uStreamVH,							c2;	Q ¬ Q - 1,							c3;	uStreamVH ¬ Q,							c1;GetNStoreDst:	uStreamVL ¬ rVirtualL,						c2;	rVirtualL ¬ uScanLineVL,					c3;	Map ¬ MAR ¬ rVirtualL ¬ [rhVirtualH, rDstReal + 0], {side-effect only} c1;	uScanLineVL ¬ rVirtualL,					c2;	uStreamWord ¬ rTemp, GOTO[GetRunsFault],			c3;	rVirtualL ¬ uStreamVL,						c3, RMapDstF[L0.BumpRemap];	Map ¬ MAR ¬ rVirtualL ¬ [rhVirtualH, rSrcReal + 0], {side-effect only} c1;	uStreamVL ¬ rVirtualL,						c2;	uStreamBits ¬ rSrcBits,						c3;GetRunsFault:	uScanLineWord ¬ rDstWord,					c1;GoToFault:	GOTOABS[Bank1Fault],						c2;@PREDICT:	rRun ¬ TOS, Xbus ¬ ErrnIBnStkp, XDisp, L2 ¬ L2.Predict,		c1, at[1,10,ESCBn];	rSrcBits ¬ 0, BRANCH[$,PredictReentry,0E],			c2;	uLength ¬ rLength ¬ 0, L0 ¬ L0.PredictEncode,			c3;	stackP ¬ 6,							c1;	uWpl ¬ rWpl,							c2;	rRun ¬ 0, GOTO[PrEnMapSrc],					c3;PredictReentry:	rLength ¬ uLength, L0 ¬ L0.PredictEncode, GOTO[PrEnMapSrc],	c3;{normal return}PredictFinished:	stackP ¬ 2,							c1;	TOS ¬ rLength,							c2;	uStack2 ¬ TOS, pop, GOTOABS[Bank1NxtInstc1],			c3;{fault return}PredictFault:	uLength ¬ rLength, GOTOABS[Bank1Fault],				c2;@ENCODE:	rRun ¬ TOS, Xbus ¬ ErrnIBnStkp, XDisp, L2 ¬ L2.Encode,		c1, at[2,10,ESCBn];	rhVirtualH ¬ uIMGVH, BRANCH[EncodeReentry,$,7],			c2;	rVirtualL ¬ uIMGVL, L0 ¬ L0.PredictEncode, CALL[LoadLocalStream], c3;	uScanLineBits ¬ 0, rRun ¬ 0, CALL[RMapDst],			c3, at[L0.PredictEncode,10,LSRet];EncodeReentry:	rVirtualL ¬ uIMGVL, L0 ¬ L0.PredictEncode, CALL[CheckLocalStream], c3;	rSrcWord ¬ uScanLineWord, CALL[RMapDst],			c3, at[L0.PredictEncode,10,CSRet];	rSrcBits ¬ uScanLineBits, NZeroBr, GOTO[PrEnMapSrc],		c3, RMapDstRet[L0.PredictEncode];{normal return}EncodeFinished:	Map ¬ MAR ¬ rVirtualL ¬ [rhVirtualH, rDstReal + 0], {side-effect only} c1;EncodeExit:	uStreamVL ¬ rVirtualL,						c2;	uStreamWord ¬ rDstWord,						c3;	rhVirtualH ¬ uIMGVH,						c1;	rVirtualL ¬ uIMGVL, L0 ¬ L0.PredictEncode,			c2;	CALL[StoreLocalStream],						c3;	stackP ¬ 0, GOTOABS[Bank1NxtInstc1],				c3, at[L0.PredictEncode,10,SSRet];{fault returns}EncodeSrcFault:	uScanLineBits ¬ 0,						c2;	rVirtualL ¬ uStreamVL,						c3;	Map ¬ MAR ¬ rVirtualL ¬ [rhVirtualH, rDstReal + 0], {side-effect only} c1;	uStreamVL ¬ rVirtualL, GOTOABS[Bank1Fault],			c2;	CANCELBR[EncodeDstFault,3],					c1, at[L3.FaultZ,10,PutNRet];	rSrcBits ¬ rSrcBits + 4, NibCarryBr, CANCELBR[EncodeDstFaultNxtSrc,3], c1, at[L3.FaultC12Low,10,PutNRet];EncodeDstFault:	uStreamBits ¬ rDstBits, L1 ¬ 2,					c2;	TOS ¬ uScanLineWord,						c3;	TOS ¬ TOS LRot12,						c1;	uScanLineWord ¬ TOS,						c2;	rVirtualL ¬ uScanLineVL,					c3;EncodeDstStoreSrc:	Map ¬ MAR ¬ rVirtualL ¬ [rhVirtualH, rSrcReal + 0], {side-effect only} c1;	uScanLineVL ¬ rVirtualL, L1Disp,				c2;	uScanLineBits ¬ rSrcBits, BRANCH[$,EncodeFault,1],		c3;EncodeDstStoreSrcc1:	TOS ¬ 0, GOTO[GoToFault],					c1;EncodeFault:	TOS ¬ rRun, GOTO[GoToFault],					c1;EncodeDstFaultNxtSrc:	uStreamBits ¬ rDstBits, L1 ¬ 0, BRANCH[$,EncodeDstFNxtSrcWord],	c2;	rVirtualL ¬ uScanLineVL, GOTO[EncodeDstStoreSrc],		c3;EncodeDstFNxtSrcWord:	rVirtualL ¬ uScanLineVL,					c3;	Map ¬ MAR ¬ rVirtualL ¬ [rhVirtualH, rSrcReal + 1], {side-effect only} c1;EncodeDstFNxtc2:	uScanLineVL ¬ rVirtualL, BRANCH[$,EncodeDstFPC,1],		c2;	uScanLineBits ¬ 0, GOTO[EncodeDstStoreSrcc1],			c3;EncodeDstFPC:	rVirtualL ¬ rVirtualL + r0100, CarryBr,				c3;	BRANCH[EncodeDstFNxtc2,$],					c1;	Q ¬ uScanLineVH,						c2;	Q ¬ Q + 1,							c3;	uScanLineVH ¬ Q, GOTO[EncodeDstFNxtc2],				c1;{common code for Predict and Enable (using L2 to distinguish when necessary)}PrEnMapSrc:	rWpl ¬ uWpl, NZeroBr, BRANCH[PrEnTestWpl,$],			c1;	rVirtualL ¬ uScanLineVL, CANCELBR[PrEnMapSrcc3],		c2;PrEnTestWpl:	rVirtualL ¬ uScanLineVL, L2Disp, BRANCH[PrEnExit,$],		c2;PrEnMapSrcc3:	rhVirtualH ¬ uScanLineVH, CANCELBR[RMapSrc,2],			c3;	Q ¬ MD,								c3, RMapSrcRet[L0.PredictEncode];	rDstBits ¬ uStreamBits,						c1;	rSrcBits ¬ rSrcBits and 0F, NZeroBr,				c2;	BRANCH[PrEnTestNZ,PrEnNibLoop],					c3;PrEnLoop:	MAR ¬ rSrcReal ¬ [rhSrcReal, rSrcReal + 1], BRANCH[$,PrEnFinishedc2], c1;	rhVirtualH ¬ uScanLineVH, BRANCH[$,PrEnPageCross,1],		c2;PrEnNextRead:	Q ¬ MD,								c3;PrEnTestNZ:	rSrcWord ¬ Q, NZeroBr,						c1;	rWpl ¬ rWpl - 1, ZeroBr, BRANCH[$,PrEnWordNZ],			c2;	rRun ¬ rRun + 4, BRANCH[PrEnLoop,PrEnFinished],			c3;PrEnWordNZ:	uWpl ¬ rWpl, rSrcBits ¬ 0, CANCELBR[$],				c3;PrEnNibLoop:	rSrcWord ¬ rSrcWord LRot4, CANCELBR[$],				c1;	[] ¬ rSrcWord and 0F, NZeroBr,					c2;	uScanLineWord ¬ rSrcWord, BRANCH[$,PrEnNibNZ],			c3;	rSrcBits ¬ rSrcBits + 4, NibCarryBr,				c1;	rRun ¬ rRun + 1, BRANCH[$,PrEnWordDone],			c2;PrEnNibLoopCont:	GOTO[PrEnNibLoop],						c3;PrEnWordDone:	rWpl ¬ rWpl, ZeroBr, GOTO[PrEnLoop],				c3;PrEnNibNZ:	Q ¬ 40, BRANCH[$,EncodeDstFault,1],				c1, at[L3.C12ZLow,10,PutNRet];	[] ¬ rRun - Q, NegBr, L2Disp,					c2;	Q ¬ rSrcWord and 0F, YDisp, DISP4[PERun],			c3;{Predict arms}	rLength ¬ rLength + 3, CANCELBR[$,0F],				c1, at[0,10,PERun];	rRun ¬ rRun and 3F,						c2;	Ybus ¬ Q, YDisp,						c3;	[] ¬ rRun - 2, CarryBr, L2Disp, DISP4[PESel],			c1, at[1,10,PERun];{Encode arms}	push, CANCELBR[$,0F],						c1, at[2,10,PERun];	STK ¬ rRun, pop, L3 ¬ L3.C12ZHighMid,				c2;	rPut2N ¬ RShift1 (rRun and ~3F),				c3;		rPut2N ¬ RShift1 rRun,						c1;	rPut2N ¬ rPut2N LRot12,						c2;	rPut2N ¬ rPut2N or 0C0, CALL[Put2N],				c3;	Q ¬ 0, push, L3 ¬ L3.C12ZLow, BRANCH[$,EnFaultZ,1],		c1, at[L3.C12ZHighMid,10,PutNRet];	rRun ¬ STK, pop, GOTO[EnFinishZ],				c2;EnFaultZ:	rRun ¬ STK, pop, L3 ¬ L3.FaultZ,				c2;EnFinishZ:	rRun ¬ rRun and 3F, CALL[PutN],					c3;	[] ¬ rRun - 2, CarryBr, L2Disp, DISP4[PESel],			c1, at[3,10,PERun];{dispatch on non-zero nibble: nibbles with one bit set (1, 2, 4, 8) are separated}	rhCode ¬ 0B, [] ¬ rRun, NZeroBr, DISP2[PESpc],			c2, at[1,10,PESel];	rhCode ¬ 0A, [] ¬ rRun, NZeroBr, DISP2[PESpc],			c2, at[2,10,PESel];	[] ¬ rRun, ZeroBr, DISP2[PEReg],				c2, at[3,10,PESel];	rhCode ¬ 9, [] ¬ rRun, NZeroBr, DISP2[PESpc],			c2, at[4,10,PESel];	[] ¬ rRun, ZeroBr, DISP2[PEReg],				c2, at[5,10,PESel];	[] ¬ rRun, ZeroBr, DISP2[PEReg],				c2, at[6,10,PESel];	[] ¬ rRun, ZeroBr, DISP2[PEReg],				c2, at[7,10,PESel];	rhCode ¬ 8, [] ¬ rRun, NZeroBr, DISP2[PESpc],			c2, at[8,10,PESel];	[] ¬ rRun, ZeroBr, DISP2[PEReg],				c2, at[9,10,PESel];	[] ¬ rRun, ZeroBr, DISP2[PEReg],				c2, at[0A,10,PESel];	[] ¬ rRun, ZeroBr, DISP2[PEReg],				c2, at[0B,10,PESel];	[] ¬ rRun, ZeroBr, DISP2[PEReg],				c2, at[0C,10,PESel];	[] ¬ rRun, ZeroBr, DISP2[PEReg],				c2, at[0D,10,PESel];	[] ¬ rRun, ZeroBr, DISP2[PEReg],				c2, at[0E,10,PESel];	[] ¬ rRun, ZeroBr, DISP2[PEReg],				c2, at[0F,10,PESel];{predict arms}PrSpcLE1:	rRun ¬ 0, BRANCH[PrLength1,PrLength2c1],			c3, at[0,4,PESpc];PrSpcGE2:	rRun ¬ rRun - 1A, CANCELBR[$],					c3, at[1,4,PESpc];	[] ¬ 0 - rRun - 1, NegBr,					c1;	BRANCH[PrLength2,PrLength3],					c2;PrLength1:	rSrcBits ¬ rSrcBits + 4, NibCarryBr,				c1;	rLength ¬ rLength + 1, BRANCH[PrEnNibLoopCont,PrEnWordDone],	c2;PrLength2:	rRun ¬ 0, CANCELBR[$],						c3, at[0,4,PEReg];PrLength2c1:	rSrcBits ¬ rSrcBits + 4, NibCarryBr,				c1;	rLength ¬ rLength + 2, BRANCH[PrEnNibLoopCont,PrEnWordDone],	c2;PrLength3:	rLength ¬ rLength + 3, CANCELBR[PrEnNibNZDone,0],		c3, at[1,4,PEReg];{encode arms}EnSpcLE1:	Q ¬ rhCode, L3 ¬ L3.Last1or2, BRANCH[PutN,$],			c3, at[2,4,PESpc];	rPut2N ¬ rhCode,						c1;	rPut2N ¬ rPut2N xor 0C, L3 ¬ L3.Last1or2, GOTO[EnCallPut2N],	c2;EnSpcGE2:	Q ¬ 1A, CANCELBR[$],						c3, at[3,4,PESpc];	[] ¬ rRun - Q, NegBr,						c1;	Q ¬ rhCode, BRANCH[$,EnSpcLength2],				c2;	rPut2N ¬ rRun or 0C0, L3 ¬ L3.C12HighMid, CALL[Put2N],		c3;EnSpcLength2:	rPut2N ¬ LShift1 (rRun + rRun),					c3;	Q ¬ Q and 3,							c1;	rPut2N ¬ rPut2N or Q, L3 ¬ L3.Last1or2, GOTO[EnCallPut2N],	c2;EnRegLE1:	rPut2N ¬ rSrcWord and 0F, BRANCH[EnRegE1,EnRegE0],		c3, at[2,4,PEReg];EnRegE0:	[] ¬ rPut2N xor 3, ZeroBr, L3 ¬ L3.Last1or2,			c1;	rPut2N ¬ LShift1 (rPut2N or 30), SE ¬ 0, BRANCH[EnCallPut2N,EnRegLE1Chg], c2;EnRegE1:	[] ¬ rPut2N xor 3, ZeroBr, L3 ¬ L3.Last1or2,			c1;	rPut2N ¬ LShift1 (rPut2N or 30), SE ¬ 1, BRANCH[EnCallPut2N,EnRegLE1Chg], c2;EnCallPut2N:	CALL[Put2N],							c3;EnRegLE1Chg:	rPut2N ¬ rPut2N + 2, CALL[Put2N],				c3;EnRegGE2:	rPut2N ¬ rRun or 0C0, L3 ¬ L3.C12HighMid, CANCELBR[Put2N],	c3, at[3,4,PEReg];	Q ¬ uScanLineWord, L3 ¬ L3.Last1or2, DISP2[EnTestFaultC12],	c1, at[L3.C12HighMid,10,PutNRet];	Q ¬ Q and 0F, GOTO[EnFinishc12],				c2, at[0,4,EnTestFaultC12];	Q ¬ Q and 0F, L3 ¬ L3.FaultC12Low,				c2, at[2,4,EnTestFaultC12];EnFinishc12:	CALL[PutN],							c3;PrEnNibNZDone:	rSrcBits ¬ rSrcBits + 4, NibCarryBr, BRANCH[$,EncodeDstFaultNxtSrc,1], c1, at[L3.Last1or2,10,PutNRet];	rRun ¬ 0, BRANCH[PrEnNibLoopCont,PrEnWordDone],			c2;PrEnPageCross:	uStreamBits ¬ rDstBits, L0 ¬ L0.PredictEncode,			c3;	rVirtualL ¬ uScanLineVL,					c1;	rVirtualL ¬ rVirtualL + r0100, CarryBr,				c2;	rVirtualL ¬ rVirtualL and ~0FF, BRANCH[PrEnHighOK,$],		c3;	Q ¬ rhVirtualH + 1, LOOPHOLE[byteTiming],			c1;	rhVirtualH ¬ Q LRot0,						c2;	uScanLineVH ¬ Q,						c3;PrEnHighOK:	Map ¬ uScanLineVL ¬ [rhVirtualH, rVirtualL],			c1;	uStreamWord ¬ rDstWord, L1 ¬ L1.MapSrc, CALL[RMapSrcc3],	c2;{end of Predict/Encode loop}PrEnFinished:	Noop,								c1;PrEnFinishedc2:	uStreamBits ¬ rDstBits, L2Disp, CANCELBR[$,2],			c2;PrEnExit:	rVirtualL ¬ uStreamVL, BRANCH[PredictFinished,EncodeFinished,1], c3;{page faults}	uWpl ¬ rWpl, L2Disp, GOTO[PrEnFault],				c3, RMapSrcF[L0.PredictEncode];	GOTO[EncodeFault],						c3, RMapDstF[L0.PredictEncode];PrEnFault:	TOS ¬ rRun, BRANCH[PredictFault,EncodeSrcFault,1],		c1;@RIPPLEXOR:	rhVirtualH ¬ uScanLineVH, [] ¬ rWpl, ZeroBr,			c1, at[3,10,ESCBn];	rVirtualL ¬ uScanLineVL, BRANCH[$,RXExit],			c2;	rCarryover ¬ STK, L0 ¬ L0.RippleXOR,				c3;	Ybus ¬ rCarryover and 3, YDisp,					c1;	rCarryover ¬ rCarryover and ~0FF, pCall2, DISP4[RXSet],		c2;	rMaskN ¬ 1F, CALL[RMapDst],					c3, at[0,10,RXSet];	rMaskN ¬ 3F, CALL[RMapDst],					c3, at[1,10,RXSet];	rMaskN ¬ 7F, CALL[RMapDst],					c3, at[2,10,RXSet];	rMaskN ¬ 0FF, CALL[RMapDst],					c3, at[3,10,RXSet];RXLoop:	MAR ¬ rDstReal ¬ [rhDstReal, rDstReal + 1],			c1;	rVirtualL ¬ rVirtualL and ~0FF, BRANCH[$,RXPageCross,1],	c2;	rSrcWord ¬ MD xor rCarryover, L2Disp,				c3, RMapDstRet[L0.RippleXOR];RXLoopCont:	rCarryover ¬ rSrcWord, DISP2[RXRot],				c1;RXor:	rSrcWord ¬ rSrcWord xor rCarryover, DISP2[RXRot],		c1;	rCarryover ¬ RRot1 (rCarryover and ~rMaskN), ZeroBr, GOTO[RXRot12], c2, at[0,4,RXRot];	rCarryover ¬ LRot1 (rCarryover and ~rMaskN), GOTO[RXRot9],	c2, at[1,4,RXRot];	rCarryover ¬ LRot1 (rCarryover and ~rMaskN), ZeroBr, GOTO[RXRot8], c2, at[2,4,RXRot];	rCarryover ¬ rCarryover and ~rMaskN, ZeroBr, GOTO[RXRot8],	c2, at[3,4,RXRot];RXRot8:	rCarryover ¬ rCarryover LRot8, L2Disp, BRANCH[RXor,RXWordOK],	c3;RXRot12:	rCarryover ¬ rCarryover LRot12, L2Disp, BRANCH[RXor,RXWordOK],	c3;RXRot9:	rCarryover ¬ rCarryover LRot1,					c*;	rCarryover ¬ rCarryover LRot8, XC2npcDisp,			c*;	rSrcWord ¬ rSrcWord xor rCarryover, BRANCH[$,RXWordOK,0D],	c*;	rCarryover ¬ LRot1 (rCarryover and ~rMaskN), GOTO[RXRot9],	c*;RXWordOK:	MAR ¬ [rhDstReal, rDstReal + 0], CANCELBR[$,3],			c1;	MDR ¬ rSrcWord, rWpl ¬ rWpl - 1, ZeroBr,			c2;	rSrcWord ¬ LRot1 (rSrcWord and rMaskN), L2Disp, BRANCH[$,RXDone], c3;	rCarryover ¬ LRot1 rSrcWord, DISP2[RXCarry],			c1;	rCarryover ¬ LRot1 rCarryover, GOTO[RXLeftJustify],		c2, at[0,4,RXCarry];	GOTO[RXLeftJustify],						c2, at[1,4,RXCarry];	rCarryover ¬ rSrcWord, GOTO[RXLeftJustify],			c2, at[2,4,RXCarry];	rCarryover ¬ RRot1 rSrcWord, GOTO[RXLeftJustify],		c2, at[3,4,RXCarry];RXLeftJustify:	rCarryover ¬ rCarryover LRot8, GOTO[RXLoop],			c3;RXPageCross:	rVirtualL ¬ rVirtualL + r0100, CarryBr,				c3;	Map ¬ uScanLineVL ¬ [rhVirtualH, rVirtualL], MesaIntBr, BRANCH[$,RXHighCross], c1;	L1 ¬ L1.MapDst, BRANCH[RMapDstc3,RXInt],			c2;RXHighCross:	Q ¬ rhVirtualH + 1, LOOPHOLE[byteTiming], CANCELBR[$],		c2;	rhVirtualH ¬ Q LRot0,						c3;	Map ¬ [rhVirtualH, rVirtualL], MesaIntBr,			c1;	uScanLineVH ¬ Q, L1 ¬ L1.MapDst, BRANCH[RMapDstc3,RXInt],	c2;{interrupt code}RXInt:	Q ¬ STK,							c3;	Q ¬ Q and 3,							c1;	STK ¬ rCarryover or Q,						c2;	GOTOABS[Bank1Interrupt],					c3;{fault code}	Q ¬ STK,							c3, RMapDstF[L0.RippleXOR];	Q ¬ Q and 3,							c1;	STK ¬ rCarryover or Q, GOTOABS[Bank1Fault],			c2;RXDone:	CANCELBR[$,3],							c1;	Noop,								c2;RXExit:	stackP ¬ 0, GOTOABS[Bank1NxtInstc1],				c3;{subroutines}{LoadLocalStream	called with addr of IMGStream in [rhVirtualH, rVirtualL]	loads stack U-regs uStreamVL, uStreamVH, uStreamWord, uStreamBits	loads stream addr into [rhVirtualH, rVirtualL]	loads rDstWord & rSrcBits (caller will have to move one of them)	sets stack size to 12 words (one extra for TOS)	uses rSrcReal, rhSrcReal, Q	returns through L0 to LSRet	jumps to Bank1Fault if addr not mapped or write-protected}LoadLocalStream:	Map ¬ [rhVirtualH, rVirtualL],					c1;	rDstWord ¬ 0C, L1 ¬ L1.LoadLocal,				c2;	rhSrcReal ¬ rSrcReal ¬ MD, XWtOKDisp,				c3;	MAR ¬ Q ¬ [rhSrcReal, rVirtualL + 0], BRANCH[LSFix,$,0D],	c1, at[L1.LoadLocal,10,RMFRtn];	rSrcReal ¬ Q, stackP ¬ rDstWord,				c2;	rVirtualL ¬ MD,							c3;	MAR ¬ [rhSrcReal, rSrcReal + 1],				c1;	uStreamVL ¬ rVirtualL, CANCELBR[$,2],				c2;	rhVirtualH ¬ Q ¬ MD,						c3;	MAR ¬ [rhSrcReal, rSrcReal + 2],				c1;	uStreamVH ¬ Q, CANCELBR[$,2],					c2;	rDstWord ¬ MD,							c3;	MAR ¬ [rhSrcReal, rSrcReal + 3],				c1;	uStreamWord ¬ rDstWord, CANCELBR[$,2],				c2;	rSrcBits ¬ MD,							c3;	uStreamBits ¬ rSrcBits, L0Disp,					c1;LSLast:	RET[LSRet],							c2;LSFix:	CALL[RMapWriteFix],						c2;{fault return from RMapWriteFix comes here}	uFaultParm1 ¬ Q, CANCELBR[RESFault,0F],				c2, at[L1.LoadLocal,10,RMFFaultRtn];{CheckLocalStream	called with addr of IMGStream in [rhVirtualH, rVirtualL]	verifies that addr is mapped and writable	loads uStreamVH into rhVirtualH, uStreamVL into rVirtualL, uStreamWord into rDstWord	uses rDstReal, Q	returns through L0 to CSRet}CheckLocalStream:	Map ¬ Q ¬ [rhVirtualH, rVirtualL],				c1;	rDstWord ¬ uStreamWord, L1 ¬ L1.CheckLocal,			c2;	rDstReal ¬ MD, XWtOKDisp,					c3;	rVirtualL ¬ uStreamVL, L0Disp, BRANCH[CSFix,$,0D],		c1, at[L1.CheckLocal,10,RMFRtn];	rhVirtualH ¬ uStreamVH, RET[CSRet],				c2;CSFix:	rVirtualL ¬ Q, CANCELBR[RMapWriteFix,0F],			c2;{fault return from RMapWriteFix comes here}	uFaultParm1 ¬ Q, CANCELBR[RESFault,0F],				c2, at[L1.CheckLocal,10,RMFFaultRtn];RESFault:	PC ¬ PC - 1, Bank ¬ r0100 {= bank0 in low 4 bits}, push, GOTOABS[Bank1Faultc1], c3;{StoreLocalStream	called with addr of IMGStream in [rhVirtualH, rVirtualL]	  (previously verified by CheckLocalStream, so no page fault)	stores stack U-regs uStreamVL, uStreamVH, uStreamWord, uStreamBits	uses rDstReal, rhDstReal, rDstWord, Q	returns through L0 to SSRet}StoreLocalStream:	Map ¬ [rhVirtualH, rVirtualL],					c1;	rDstWord ¬ uStreamVL,						c2;	rhDstReal ¬ rDstReal ¬ MD, {XWtOKDisp not needed}		c3;	MAR ¬ Q ¬ [rhDstReal, rVirtualL + 0],				c1;	MDR ¬ rDstWord, rDstReal ¬ Q,					c2;	rDstWord ¬ uStreamVH,						c3;	MAR ¬ [rhDstReal, rDstReal + 1],				c1;	MDR ¬ rDstWord, CANCELBR[$,0],					c2;	rDstWord ¬ uStreamWord,						c3;	MAR ¬ [rhDstReal, rDstReal + 2],				c1;	MDR ¬ rDstWord, CANCELBR[$,0],					c2;	rDstWord ¬ uStreamBits,						c3;	MAR ¬ [rhDstReal, rDstReal + 3], L0Disp,			c1;	MDR ¬ rDstWord, RET[SSRet],					c2;{GetN	loads next stream nibble into Q	returns through L3 to GetNRet}GetN:	[] ¬ rSrcBits and ~0F, NZeroBr, BRANCH[$,GetRunsInt],		c1;GetNCont:	rSrcBits ¬ rSrcBits + 4, BRANCH[$,GetNNextWord],		c2;GetNReentry:	rSrcWord ¬ rSrcWord LRot4, L3Disp,				c3;	Q ¬ rSrcWord and 0F, RET[GetNRet],				c1;GetNNextWord:	uScanLineBits ¬ rDstBits, CANCELBR[$,0F],			c3;	MAR ¬ rSrcReal ¬ [rhSrcReal, rSrcReal + 1],			c1;	rhVirtualH ¬ uStreamVH, BRANCH[$,GetNPageCross,1],		c2;GetNNextRead:	rSrcWord ¬ MD,							c3;	rDstBits ¬ uScanLineBits,					c1;	rSrcBits ¬ 4, GOTO[GetNReentry],				c2;GetNPageCross:	rVirtualL ¬ uStreamVL, L1 ¬ L1.GetN,				c3;	Map ¬ rVirtualL ¬ [rhVirtualH, rVirtualL + r0100], CarryBr,	c1;GetNPCc2:	rVirtualL ¬ rVirtualL and ~0FF, BRANCH[$,GetNHighCross],	c2;	rhSrcReal ¬ rSrcReal ¬ MD, XRefBr,				c3;	MAR ¬ rSrcReal ¬ [rhSrcReal, 0 + 0], BRANCH[GNFix,$,2],		c1, at[L1.GetN,10,RMFRtn];	uStreamVL ¬ rVirtualL, GOTO[GetNNextRead],			c2;GetNHighCross:	Q ¬ rhVirtualH + 1, LOOPHOLE[byteTiming],			c3;	rhVirtualH ¬ Q LRot0,						c1;	uStreamVH ¬ Q,							c2;	Noop,								c3;	Map ¬ [rhVirtualH, rVirtualL], GOTO[GetNPCc2],			c1;GNFix:	uStreamWord ¬ rSrcWord,						c2;	rSrcReal ¬ rSrcReal or rhSrcReal, XwdDisp, GOTO[RMapReadFixc1],	c3;{PutN	stores next stream nibble from Q	returns through L3 to PutNRet}PutN:	rDstBits ¬ rDstBits + 4, NibCarryBr,				c1;	rDstWord ¬ rDstWord LRot4 or Q, L3Disp, BRANCH[$,PutNNextWord],	c2;	uStreamWord ¬ rDstWord, RET[PutNRet],				c3;PutNNextWord:	uStreamBits ¬ rDstBits ¬ 0, CANCELBR[$,0F],			c3;	MAR ¬ [rhDstReal, rDstReal], rDstReal ¬ rDstReal + 1,		c1;	MDR ¬ Q ¬ rDstWord, L3Disp, BRANCH[$,PutNPageCross,1],		c2;	uStreamWord ¬ rDstWord ¬ 0, RET[PutNRet],			c3;PutNPageCross:	uStreamWord ¬ rDstWord ¬ 0, CANCELBR[$,0F],			c3;PutNPCc1:	MAR ¬ [rhDstReal, 0FF + 0],					c1;	MDR ¬ Q, rhVirtualH ¬ uStreamVH,				c2;	uStreamBits ¬ rDstBits,						c3;	rVirtualL ¬ uStreamVL, L1 ¬ L1.PutN,				c1;	rVirtualL ¬ rVirtualL + r0100, CarryBr,				c2;	rVirtualL ¬ rVirtualL and ~0FF, BRANCH[PutNHighOK,$],		c3;	Q ¬ rhVirtualH + 1, LOOPHOLE[byteTiming],			c1;	rhVirtualH ¬ Q LRot0,						c2;	uStreamVH ¬ Q,							c3;PutNHighOK:	Map ¬ uStreamVL ¬ [rhVirtualH, rVirtualL],			c1;	uStreamWord ¬ rDstWord,						c2;	rhDstReal ¬ rDstReal ¬ MD, XWtOKDisp,				c3;	MAR ¬ rDstReal ¬ [rhDstReal, 0 + 0], BRANCH[PNFix,$,0D],	c1, at[L1.PutN,10,RMFRtn];	rDstBits ¬ uStreamBits, L3Disp,					c2;	RET[PutNRet],							c3;PNFix:	rDstReal ¬ rDstReal or rhDstReal, GOTO[RMapWriteFix],		c2;	uFaultParm1 ¬ Q, L3Disp, CANCELBR[$,3],				c2, at[L1.PutN,10,RMFFaultRtn];	rDstBits ¬ uStreamBits, L2Disp, RET[PutNRet],			c3;{Put2N	stores next two stream nibbles from rPut2N	returns through L3 to PutNRet}Put2N:	rDstBits ¬ rDstBits + 8, NibCarryBr,				c1;	rDstWord ¬ rDstWord LRot8, L3Disp, BRANCH[$,Put2NNextWord],	c2;	rDstWord ¬ rDstWord or rPut2N, RET[PutNRet],			c3;Put2NNextWord:	rDstBits ¬ rDstBits and 0F, NZeroBr, CANCELBR[$,0F],		c3;	Q ¬ rPut2N and 0F0, BRANCH[$,Put2NWordCross],			c1;	rDstWord ¬ rDstWord or rPut2N, GOTO[PutNNextWord],		c2;Put2NWordCross:	rDstWord ¬ rDstWord or Q,					c2;	rDstWord ¬ rDstWord LRot12,					c3;	MAR ¬ [rhDstReal, rDstReal], rDstReal ¬ rDstReal + 1,		c1;	MDR ¬ Q ¬ rDstWord, L3Disp, BRANCH[$,Put2NPageCross,1],		c2;	rDstWord ¬ rPut2N and 0F, RET[PutNRet],				c3;Put2NPageCross:	rDstWord ¬ rPut2N and 0F, CANCELBR[PutNPCc1,0F],		c3;{BumpAndStore	increments rOffset by rCode + 1	advances scanLine by rCode nibbles,	  writing rDstWord and advancing address if necessary	stores Q into appropriate nibble of rDstWord}BumpAndStore:	rOffset ¬ rOffset + rCode + 1, CANCELBR[$],			c2;	rCode ¬ LShift1 (rCode + rCode),				c3;	rDstBits ¬ rDstBits + rCode,					c1;BumpCommon:	rCode ¬ rDstBits and ~0F, NZeroBr,				c2;	rDstBits ¬ rDstBits + 4, YDisp, BRANCH[$,BumpNewWord],		c3;	rCode ¬ Q, DISP4[StoreSel,3],					c1;BumpNewWord:	MAR ¬ [rhDstReal, rDstReal + 0], CANCELBR[$,0F],		c1;	MDR ¬ rDstWord, rDstWord ¬ 0,					c2;	rCode ¬ rCode LRot12,						c3;	rDstReal ¬ rDstReal + rCode, PgCarryBr,				c1;	rCode ¬ Q, pCall4, BRANCH[$,BumpNoteRemap],			c2;	rDstBits ¬ rDstBits and 0F, YDisp, GOTO[BumpNewWordDisp],	c3, at[0,10];BumpNoteRemap:	rDstBits ¬ rDstBits and 0F, YDisp,				c3;BumpNewWordDisp:	uStreamWord ¬ rSrcWord, L4Disp, DISP4[StoreSel,3],		c1;	rDstBits ¬ 10, L3 ¬ L3.CodeHigh, BRANCH[StoreAndGoOn,BumpRemap], c2, at[3,10,StoreSel];	rCode ¬ rCode LRot12, L3 ¬ L3.CodeHigh, BRANCH[StoreAndGoOn,BumpRemap], c2, at[7,10,StoreSel];	rCode ¬ rCode LRot8, L3 ¬ L3.CodeHigh, BRANCH[StoreAndGoOn,BumpRemap], c2, at[0B,10,StoreSel];	rCode ¬ rCode LRot4, L3 ¬ L3.CodeHigh, BRANCH[StoreAndGoOn,BumpRemap], c2, at[0F,10,StoreSel];StoreAndGoOn:	rDstWord ¬ rDstWord or rCode, CALL[GetN],			c3;BumpRemap:	rDstWord ¬ rDstWord or rCode,					c3;	Q ¬ r0100,							c1;BumpRemapCommon:	uScanLineBits ¬ rDstBits, L3 ¬ L3.CodeHigh,			c2;	rVirtualL ¬ uScanLineVL, L0 ¬ L0.BumpRemap,			c3;	Map ¬ MAR ¬ rVirtualL ¬ [rhVirtualH, rDstReal + 0], {side effect only} c1;	rVirtualL ¬ rVirtualL + Q, CarryBr,				c2;	rhVirtualH ¬ uScanLineVH, BRANCH[BumpRemapHighOK,$],		c3;	Q ¬ rhVirtualH + 1, LOOPHOLE[byteTiming],			c1;	rhVirtualH ¬ Q LRot0,						c2;	uScanLineVH ¬ Q,						c3;BumpRemapHighOK:	Map ¬ uScanLineVL ¬ [rhVirtualH, rVirtualL], CALL[RMapDstc2],	c1;	rDstBits ¬ uScanLineBits, MesaIntBr, CALL[GetN],		c3, RMapDstRet[L0.BumpRemap];{Bump64s	increments rOffset by 64 * rCode	writes rDstWord, then advances scanLine by 16 * rCode words}Bump64s:	MAR ¬ [rhDstReal, rDstReal + 0], CANCELBR[$],			c1;	MDR ¬ rDstWord, rDstWord ¬ 0,					c2;	rCode ¬ rCode LRot4,						c3;	Q ¬ rCode,							c1;	rCode ¬ LShift1 (rCode + rCode),				c2;	rOffset ¬ rOffset + rCode,					c3;	GOTO[BumpRemapCommon],						c1;{RMapSrc	called with virtual addr in [rhVirtualH, rVirtualL]	loads real addr into [rhSrcReal, rSrcReal]	uses Q	returns through L0: to RMapSrcRtn if ok, to RMapSrcFault if fault}RMapSrc:	Map ¬ [rhVirtualH, rVirtualL],					c1;RMapSrcc2:	L1 ¬ L1.MapSrc,							c2;RMapSrcc3:	rhSrcReal ¬ rSrcReal ¬ MD, XRefBr,				c3;	MAR ¬ Q ¬ [rhSrcReal, rVirtualL + 0], L0Disp, BRANCH[RMSFix,$,2], c1, at[L1.MapSrc,10,RMFRtn];	rSrcReal ¬ Q, RET[RMapSrcRtn],					c2;RMSFix:	CANCELBR[RMapReadFix,0F],					c2;{fault return from RMapReadFix comes here}	uFaultParm1 ¬ Q, RET[RMapSrcFault],				c2, at[L1.MapSrc,10,RMFFaultRtn];{RMapDst	called with virtual addr in [rhVirtualH, rVirtualL]	loads real addr into [rhDstReal, rDstReal]	uses Q	returns through L0: to RMapDstRtn if ok, to RMapDstFault if fault or write-protect}RMapDst:	Map ¬ [rhVirtualH, rVirtualL],					c1;RMapDstc2:	L1 ¬ L1.MapDst,							c2;RMapDstc3:	rhDstReal ¬ rDstReal ¬ MD, XWtOKDisp,				c3;	MAR ¬ Q ¬ [rhDstReal, rVirtualL + 0], L0Disp, BRANCH[RMDFix,$,0D], c1, at[L1.MapDst,10,RMFRtn];	rDstReal ¬ Q, RET[RMapDstRtn],					c2;RMDFix:	CANCELBR[RMapWriteFix,0F],					c2;{fault return from RMapWriteFix comes here}	uFaultParm1 ¬ Q, RET[RMapDstFault],				c2, at[L1.MapDst,10,RMFFaultRtn];RMapReadFix:	Xbus ¬ rSrcReal LRot0, XwdDisp,					c3;RMapReadFixc1:	Map ¬ [rhVirtualH, rVirtualL], DISP2[RMFRa],			c1;RMFRa:	MDR ¬ rSrcReal or map.referenced, L1Disp, GOTO[RMFb],		c2, at[0,4];	MDR ¬ rSrcReal or map.referenced, L1Disp, GOTO[RMFb],		c2, at[1,4,RMFRa];	MDR ¬ rSrcReal or map.referenced, L1Disp, GOTO[RMFb],		c2, at[2,4,RMFRa];	T ¬ qPageFault, GOTO[RMFc],					c2, at[3,4,RMFRa];RMFb:	Xbus ¬ 3, XDisp, RET[RMFRtn],					c3;RMFc:	uFaultParm0 ¬ rVirtualL, L1Disp,				c3;	Q ¬ rhVirtualH, L0Disp, RET[RMFFaultRtn],			c1;RMapWriteFix:	Xbus ¬ rDstReal LRot0, XwdDisp,					c3;	Map ¬ [rhVirtualH, rVirtualL], DISP2[RMFWa],			c1;RMFWa:	MDR ¬ rDstReal or map.rd, L1Disp, GOTO[RMFb],			c2, at[0,4];	T ¬ qWriteProtect, GOTO[RMFc],					c2, at[1,4,RMFWa];	MDR ¬ rDstReal or map.rd, L1Disp, GOTO[RMFb],			c2, at[2,4,RMFWa];	T ¬ qPageFault, GOTO[RMFc],					c2, at[3,4,RMFWa];
{File name:  Misc.mcDescription: Miscellaneous Mesa  opcodes,Author: RXG   ,Created: April 3, 1980,Last Edited: JPM	 5-Dec-90 11:05:27  Merge code from SmallTalk, restore @BANDBLT conditionally.Last Edited: JPM	15-Sep-89 15:31:06  Rearranged bank locations, Removed @BANDBLT.Last Edited: SxO/TxH	13-Sep-88 14:30:20  moved @BYTBLT, @BANDBLT, @NextMatchAndDiff and @CLR to bank1.                	13-Sep-88 14:30:14  moved image processing stuff to bank2.	         	13-Sep-88 14:30:10  use @Unimp277 for VMFind assist microcodeLast Edited: TXM	13-Jul-88 13:24:51  Moved @BYTBLT and @BANDBLT to extra bank.Last Edited: JT		17-Mar-88  3:38:46  Add NOOP opcode.Last Edited: JT		11-Mar-88  0:29:00  Reserve Smalltalk escape ops.Last Edited: JPM	 7-Oct-87 15:11:00  Fix location of ESCHi (for future segmentation).Last Edited: AHL/JPM	 6-Jan-87 11:05:36  Changed for MDS relief.Last Edited: JPM	14-Nov-86 10:20:02  Implement @a177 as access to idle count regs.Last Edited:  RCH 21-Jul-86 16:13:20 Removed @Pushbte, @PushByteToWordBoundary, @Writ. @INPUT, @OUTPUT, @RawRead, @RawWrite (all previously commented).Last Edited: JPM	16-Jul-86  9:08:26  Extend bank 1 mechanism to floating-point and include as yet unimplemented opcode ranges.Last Edited: JPM	11-Jul-86 12:47:53  Add general mechanism for invoking bank 1 opcodes, hard-wire address of ESCc.Last Edited: CRF/MRR	16-Jun-86 18:45:28  Add image processing escape opcode dispatch.Last Edited: AHL/JAC	28-Feb-86 20:23:26  Add bytepointer stuffLast Edited: KxI	17-Dec-85 16:26:41  add useful comments from ESCAlpha.mesa..Last Edited: KxI	10-Dec-85  9:50:02  Make changes for @NextMatchAndDiff, @PushByte, @PushByteToWordBoundary and @CLR to be implementedLast Edited: RDH	30-Oct-85 14:15:42  Make changes for Bandblt to be implementedLast Edited: AEF/JPM,	10-Apr-85 16:05:58  Make changes to SM for PCELast Edited: JGS/JPM,	12-Dec-84 13:32:38  added push at SMFc+2Last Edited: JPM,	 9-Oct-84 10:21:50  removed @TXTBLT (now implemented in TextBlt.mc)Last Edited: JPM,	 3-Oct-84 17:02:20  added @Unimp377Last Edited: JPM,	27-Sep-84 14:29:08  use hardware to enable/disable interrupts (at @WRWDC)Last Edited: JPM,	25-Sep-84 16:24:43  add landing places for unimplemented opcode 336b (CAW?) and ESC codes BNDCKL and NILCKLast Edited: JPM,	13-Sep-84 14:23:34  add labels to unimplemented opcodes for debuggingLast Edited: DEG,	 1-Sep-84 19:42:59  Add copyright noticeLast Edited: JPM,	19-Jun-84 12:38:43  Delete Dicentra-specific ESC9n branchLast Edited: JPM,	 1-Jun-84 16:02:51  Redo SM, SMF, and GMF for DaybreakLast Edited: HGM,	14-Nov-83 21:08:37  Delete DLion stuffLast Edited: AXD,	15-Jun-83 19:01:49  new instruction setLast Edited: AEF,	 4-Jan-83 10:52:30  Fix typo in BLTLR commentLast Edited: AEF,	22-Dec-82 10:49:15  Make BLTLR microcode implementationLast Edited: AEF, September 2, 1982  12:19 PM Do STK¬TOS at Unimplemented OpcodesLast Edited: AEF, August 2, 1982  11:41 AM  MaintenancePanelOffsetLast Edited: AEF, April 29, 1982  1:48 PM Add TStatus to @INPUT and TAddr to @OUTPUTLast Edited: AEF, April 23, 1982  2:01 PM  Add conditional assembly for MagTapeEdited: JGS, February 24, 1982  2:18 PM Add SPP instEdited: JGS, November 17, 1981  5:04 PM new instruction setEdited: JGS, April 23, 1981  8:46 AM: Fix Stack on Misc ~IN[0..15]Last Edited: JXF, March 16, 1981  11:51 AM: Allow Block to catch Checksum MiscLast Edited: RXJ, January 22, 1981  1:11 PM}{ 	Copyright (C) 1981, 1982, 1983, 1984, 1985, 1986, 1989, 1990 by Xerox Corporation.  All rights reserved.}{*****************************************************************************	ESC(L) - Escape operations*****************************************************************************}{note:	Some ESC byte codes are already reseved, but not implemented by using M'Code because of a lack of WCS memory..	Some of these ESC byte codes are implemented by Mesa. 	When we call those ESC byte codes, it cause a escOpcodeTrap, and Mesa processor make a control transfer to a corredponding trap handler. its trap handler will call a acutual procedure written by existing mesa byte codes.	We should check ESCAlpha.mesa also to know what escape codes are reserved. }{Macros for causing an ESC code trap or transferring to another bank}MacroDef[UnimplESCRange,(PC ¬ PC + 1, STK ¬ TOS, pop, CANCELBR[EscOpcodeTrap,0F])];MacroDef[UnimplESC,(PC ¬ PC - 1, GOTO[ESCb])];MacroDef[BankESC1Range,(Bank ¬ bank1, pop, CANCELBR[BankESC,0F])];MacroDef[BankESC2Range,(Bank ¬ bank2, pop, CANCELBR[BankESC,0F])];MacroDef[BankESCRange,IfEqual[#1,1,BankESC1Range,BankESC2Range]];MacroDef[Bank1Transfer,(Bank ¬ bank1, L0Disp, GOTO[AltBankESC])];MacroDef[Bank2Transfer,(Bank ¬ bank2, L0Disp, GOTO[AltBankESC])];MacroDef[BankTransfer,IfEqual[#1,1,Bank1Transfer,Bank2Transfer]];@ESCL:	Xbus ¬ ibHigh, XDisp, push, GOTO[ESCx],			c1, opcode[371'b];@ESC:	Xbus ¬ ibHigh, XDisp, push,				c1, opcode[370'b];ESCx:	TT ¬ ib, XDisp, L0 ¬ 0{thru F}, DISP4[ESCHi],		c2;ESCHi:	PC ¬ PC + 1, STK ¬ TOS, pop, DISP4[ESC0n],		c3, at[addrESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, DISP4[ESC1n],		c3, at[ 1,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, DISP4[ESC2n],		c3, at[ 2,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, DISP4[ESC3n],		c3, at[ 3,10,ESCHi];	IfGreater[TheNumberOfBanks,ESC4nBank,BankESCRange[ESC4nBank],UnimplESCRange],								c3, at[ 4,10,ESCHi];	IfGreater[TheNumberOfBanks,ESC5nBank,BankESCRange[ESC5nBank],UnimplESCRange],								c3, at[ 5,10,ESCHi];	IfGreater[TheNumberOfBanks,ESC6nBank,BankESCRange[ESC6nBank],UnimplESCRange],								c3, at[ 6,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, DISP4[ESC7n],		c3, at[ 7,10,ESCHi];	PC ¬ PC + 1, STK ¬ TOS, pop, DISP4[ESC8n],		c3, at[ 8,10,ESCHi];	UnimplESCRange,						c3, at[ 9,10,ESCHi];	IfGreater[TheNumberOfBanks,ESCAnBank,BankESCRange[ESCAnBank],UnimplESCRange],								c3, at[0A,10,ESCHi];	IfGreater[TheNumberOfBanks,ESCBnBank,BankESCRange[ESCBnBank],UnimplESCRange],								c3, at[0B,10,ESCHi];	IfGreater[TheNumberOfBanks,ESCCnBank,BankESCRange[ESCCnBank],UnimplESCRange],								c3, at[0C,10,ESCHi];	IfGreater[TheNumberOfBanks,ESCDnBank,BankESCRange[ESCDnBank],UnimplESCRange],								c3, at[0D,10,ESCHi];	IfGreater[TheNumberOfBanks,ESCEnBank,BankESCRange[ESCEnBank],UnimplESCRange],								c3, at[0E,10,ESCHi];	UnimplESCRange,						c3, at[0F,10,ESCHi];BankESC:	Xbus ¬ TT LRot12, XDisp, GOTOBANK[BankESCx],		c1;AltBankESC:	PC ¬ PC - 1, Ybus ¬ TT, YDisp, push, DISPBANK[BankESCHi],c2;EscOpcodeTrap:	PC ¬ PC - 1,						c1;ESCb:	T ¬ 0FF + TT + 1,					c2;ESCc:	G ¬ 1, GOTO[Trapc1],					c3, at[addrESCc];@a000:	PC ¬ PC - 1, GOTO[ESCb],				c1, at[ 0,10,ESC0n];@a001:	PC ¬ PC - 1, GOTO[ESCb],				c1, at[ 1,10,ESC0n];	{@MW:		in Process				c1, at[ 2,10,ESC0n];}	{@MR:		in Process				c1, at[ 3,10,ESC0n];}	{@NC:		in Process				c1, at[ 4,10,ESC0n];}	{@BC:		in Process				c1, at[ 5,10,ESC0n];}	{@REQ:		in Process				c1, at[ 6,10,ESC0n];}	{@SM:		in Misc					c1, at[ 7,10,ESC0n];}	{@SMF:		in Misc					c1, at[ 8,10,ESC0n];}	{@GMF:		in Misc					c1, at[ 9,10,ESC0n];}	{@AF:		in Xfer					c1, at[0A,10,ESC0n];}	{@FF:		in Xfer					c1, at[0B,10,ESC0n];}	{@PI:		in Xfer					c1, at[0C,10,ESC0n];}	{@PO:		in Xfer					c1, at[0D,10,ESC0n];}	{@POR:		in Xfer					c1, at[0E,10,ESC0n];}	{@SPP:		in Process				c1, at[0F,10,ESC0n];}	{@DI:		in Xfer					c1, at[ 0,10,ESC1n];}	{@EI:		in Xfer					c1, at[ 1,10,ESC1n];}	{@XOR:		in Stack				c1, at[ 2,10,ESC1n];}	{@DAND:		in Stack				c1, at[ 3,10,ESC1n];}	{@DIOR:		in Stack				c1, at[ 4,10,ESC1n];}	{@DXOR:		in Stack				c1, at[ 5,10,ESC1n];}	{@ROTATE:	in Stack				c1, at[ 6,10,ESC1n];}	{@DSHIFT:	in Stack				c1, at[ 7,10,ESC1n];}	{@LINT:		in Stack				c1, at[ 8,10,ESC1n];}	{@JS:		in Jump					c1, at[ 9,10,ESC1n];}	{@RCFS:		in StringField				c1, at[0A,10,ESC1n];}	{@RC:		in Read					c1, at[0B,10,ESC1n];}	{@UDIV:		in Stack				c1, at[0C,10,ESC1n];}	{@LUDIV:	in Stack				c1, at[0D,10,ESC1n];}	{@ROB:		in Read					c1, at[0E,10,ESC1n];}	{@WOB		in Write				c1, at[0F,10,ESC1n];}	{@DSK:		in Xfer					c1, at[ 0,10,ESC2n];}	{@XE:		in Xfer					c1, at[ 1,10,ESC2n];}	{@XF:		in Xfer					c1, at[ 2,10,ESC2n];}	{@LSK:		in Xfer					c1, at[ 3,10,ESC2n];}@BNDCKL:PC ¬ PC - 1, GOTO[ESCb],				c1, at[ 4,10,ESC2n];@NILCK:	PC ¬ PC - 1, GOTO[ESCb],				c1, at[ 5,10,ESC2n];	{@NILCKL:	in Stack				c1, at[ 6,10,ESC2n];}	{@BLTLR:	in Block				c1, at[ 7,10,ESC2n];}	{@BLEL:		in Block				c1, at[ 8,10,ESC2n];}	{@BLECL:	in Block				c1, at[ 9,10,ESC2n];}	{@CKSUM:	in Block				c1, at[0A,10,ESC2n];}	{@BITBLT:	in BBInit				c1, at[0B,10,ESC2n];}	{@TXTBLT:	in TextBlt				c1, at[0C,10,ESC2n];}@BYTBLT:							c1, at[0D,10,ESC2n],IfGreater[TheNumberOfBanks,ByteBLTBank,BankTransfer[ByteBLTBank],UnimplESC];@BYTBLTR:							c1, at[0E,10,ESC2n],IfGreater[TheNumberOfBanks,ByteBLTBank,BankTransfer[ByteBLTBank],UnimplESC];	{@VERSION:	in VersionDxx				c1, at[0F,10,ESC2n];}	@DMUL:	PC ¬ PC - 1, GOTO[ESCb],	{Written by Mesa}	c1, at[ 0,10,ESC3n];@SDIV:	PC ¬ PC - 1, GOTO[ESCb],	{Written by Mesa}	c1, at[ 1,10,ESC3n];@SDDIV:	PC ¬ PC - 1, GOTO[ESCb],	{Written by Mesa}	c1, at[ 2,10,ESC3n];@UDDIV:	PC ¬ PC - 1, GOTO[ESCb],	{Written by Mesa}	c1, at[ 3,10,ESC3n];@NextMatchAndDiff:						c1, at[ 4,10,ESC3n],IfGreater[TheNumberOfBanks,CompressAssistBank,BankTransfer[CompressAssistBank],UnimplESC];	PC ¬ PC - 1, GOTO[ESCb],	{Unimplemented}		c1, at[ 5,10,ESC3n];	PC ¬ PC - 1, GOTO[ESCb],	{Unimplemented}		c1, at[ 6,10,ESC3n];@CLR:								c1, at[ 7,10,ESC3n],IfGreater[TheNumberOfBanks,CompressAssistBank,BankTransfer[CompressAssistBank],UnimplESC];@a70:	PC ¬ PC - 1, GOTO[ESCb],	{Unimplemented}		c1, at[ 8,10,ESC3n];	{noop:				inST80MiscOps		c1, at[ 9,10,ESC3n];}	{doInitializationBytecode:	inST80MiscOps		c1, at[0A,10,ESC3n];}	{doBytecodesBytecode:		inST80MiscOps		c1, at[0B,10,ESC3n];}	{doStabilizationBytecode:	inST80MiscOps		c1, at[0C,10,ESC3n];}	{doCompress:			inST80MiscOps		c1, at[0D,10,ESC3n];}	{pMemFetch:			inST80MiscOps		c1, at[0E,10,ESC3n];}	{pMemSmash:			inST80MiscOps		c1, at[0F,10,ESC3n];}	{--  Read / Write Registers (70H - 7FH are reserved) }	{@WRPSB:	in Misc					c1, at[ 0,10,ESC7n];}	{@WRMDS:	in Misc					c1, at[ 1,10,ESC7n];}	{@WRWP:		in Misc					c1, at[ 2,10,ESC7n];}	{@WRWDC:	in Misc					c1, at[ 3,10,ESC7n];}	{@WRPTC:	in Misc					c1, at[ 4,10,ESC7n];}	{@WRIT:		in Misc					c1, at[ 5,10,ESC7n];}	{@WRXTS:	in Misc					c1, at[ 6,10,ESC7n];}	{@WRMP:		in MiscDaybreak				c1, at[ 7,10,ESC7n];}	{@RRPSB:	in Misc					c1, at[ 8,10,ESC7n];}	{@RRMDS:	in Misc					c1, at[ 9,10,ESC7n];}	{@RRWP:		in Misc					c1, at[0A,10,ESC7n];}	{@RRWDC:	in Misc					c1, at[0B,10,ESC7n];}	{@RRPTC:	in Misc					c1, at[0C,10,ESC7n];}	{@RRIT:		in MiscDaybreak				c1, at[0D,10,ESC7n];}	{@RRXTS:	in Misc					c1, at[0E,10,ESC7n];}	{@a177:		in Misc for performance study		c1, at[0F,10,ESC7n];}	{-- Processor Dependent (80H - 9FH are reserved) }		PC ¬ PC - 1, GOTO[ESCb],				c1, at[0,10,ESC8n];	PC ¬ PC - 1, GOTO[ESCb],				c1, at[1,10,ESC8n];@LOADRAMJ:	PC ¬ PC - 1, GOTO[ESCb],				c1, at[ 2,10,ESC8n];@BANDBLT:							c1, at[ 3,10,ESC8n],IfGreater[TheNumberOfBanks,BandBLTBank,BankTransfer[BandBLTBank],UnimplESC];	PC ¬ PC - 1, GOTO[ESCb],				c1, at[4,10,ESC8n];	PC ¬ PC - 1, GOTO[ESCb],				c1, at[5,10,ESC8n];	{@LOCKQUEUE:	in MiscDaybreak				c1, at[ 6,10,ESC8n];}	{@BYTESWAP:	in MiscDaybreak				c1, at[ 7,10,ESC8n];}	{@LOCKMEM:	in MiscDaybreak				c1, at[ 8,10,ESC8n];}	{@NOTIFYIOP:	in MiscDaybreak				c1, at[ 9,10,ESC8n];}	{@SetWakeupBits:in MiscDaybreak				c1, at[0A,10,ESC8n];}@PCEMedRes:							c1, at[0B,10,ESC8n],IfGreater[TheNumberOfBanks,MiscPCEBank,BankTransfer[MiscPCEBank],UnimplESC];@a214:	PC ¬ PC - 1, GOTO[ESCb],				c1, at[0C,10,ESC8n];@a215:	PC ¬ PC - 1, GOTO[ESCb],				c1, at[0D,10,ESC8n];@a216:	PC ¬ PC - 1, GOTO[ESCb],				c1, at[0E,10,ESC8n];@a217:	PC ¬ PC - 1, GOTO[ESCb],				c1, at[0F,10,ESC8n];{*****************************************************************************	SM	Set Map*****************************************************************************}@SM:	TOS ¬ TOS and 7, pop,				c1, at[7,10,ESC0n];	TT ¬ STK, pop, L0 ¬ 1,						c2;	TT ¬ TT LRot8,							c3;	Rx ¬ ~0FF, pop,							c1;	T ¬ STK, fXpop, fZpop, 						c2;	rhT ¬ T ¬ T LRot8,						c3;	Xbus ¬ TOS LRot0, XDisp, TOS ¬ 0,				c1;SMa:	TT ¬ TT and ~0E0, DISP4[SMb,8],					c2;SMb:	TT ¬ TT or 0, L0Disp, GOTO[SMc],		 c3, at[08,10,SMb];	TT ¬ TT or 80, L0Disp, GOTO[SMc],		 c3, at[09,10,SMb];	TT ¬ TT or 40, L0Disp, GOTO[SMc],		 c3, at[0A,10,SMb];	TT ¬ TT or 0C0, L0Disp, GOTO[SMc],		 c3, at[0B,10,SMb];	TT ¬ TT or 20, L0Disp, GOTO[SMc],		 c3, at[0C,10,SMb];	TT ¬ TT or 0A0, L0Disp, GOTO[SMc],		 c3, at[0D,10,SMb];	TT ¬ TT or 60, GOTO[SMc],			 c3, at[0E,10,SMb];	TT ¬ TT or 0E0, L0Disp, GOTO[SMc],		 c3, at[0F,10,SMb];SMc:	Map ¬ [rhT,T], BRANCH[SMFe, SMd, 0E],				c1;SMd:	MDR ¬ TT, TT ¬ UvL,						c2;	rhTT ¬ UvMDS,							c3;{This section was added for supporting PC emulation.  Pilot has the right to change the real page numbers of L, G, and PC at will, so every time a SM is done, we remap these quantities just in case the SM operation changed their real page number. - AEF}SMe:	Rx ¬ ~0FF,							c1;	T ¬ L and 0FF,							c2;	Q ¬ G and 0FF,							c3;	Map ¬ [rhTT, TT], TT ¬ UvG,					c1;	rhTT ¬ UvGhigh,							c2;	rhL ¬ MD, L ¬ MD and Rx,					c3;	Map ¬ [rhTT, TT], TT ¬ UvPCpage,				c1;	rhTT ¬ UvChigh,							c2;	rhG ¬ MD, G ¬ MD and Rx,					c3;	Map ¬ [rhTT, TT],						c1;	TT ¬ PC and 0FF,						c2;	rhPC ¬ MD, PC ¬ MD and Rx,					c3;	PC ¬ PC or TT,							c1;	L ¬ L or T, IBDisp,						c2;	G ¬ G or Q, pop, DISPNI[OpTable],				c3;{*****************************************************************************	SMF	Set Map Flags*****************************************************************************}@SMF:	pop, L0¬0,					c1, at[8,10,ESC0n];	T ¬ STK, fXpop, fZpop,						c2;SMFa:	rhT ¬ T ¬ T LRot8						c3;	Map ¬ [rhT,T],							c1;	TOS ¬ TOS and 7,						c2;	TT ¬ MD,							c3;	Xbus ¬ TT LRot12, XDisp {disp old flags},			c1;	TT ¬ TT and ~0E0, DISP4[SMFb,1],				c2;SMFb:	Rx ¬ 0, push, GOTO[SMFc],			c3, at[01,10,SMFb];	Rx ¬ 4, push, GOTO[SMFc],			c3, at[03,10,SMFb];	Rx ¬ 2, push, GOTO[SMFc],			c3, at[05,10,SMFb];	Rx ¬ 6, push, L0¬1, GOTO[SMFc],			c3, at[07,10,SMFb];	Rx ¬ 1, push, GOTO[SMFc],			c3, at[09,10,SMFb];	Rx ¬ 5, push, GOTO[SMFc],			c3, at[0B,10,SMFb];	Rx ¬ 3, push, GOTO[SMFc],			c3, at[0D,10,SMFb];	Rx ¬ 7, push, GOTO[SMFc],			c3, at[0F,10,SMFb];SMFc:	STK ¬ Rx,							c1;	Rx ¬ TT LRot8, push, L0Disp,					c2;	STK ¬ Rx, push, BRANCH[SMFd, GMFa],				c3;SMFd:	Xbus ¬ TOS LRot0, XDisp,					c1;	STK ¬ 0, DISP4[SMb,8],						c2;SMFe:	MDR ¬ TT, IBDisp, GOTO[SLa],					c2;	{*****************************************************************************	GMF	Get Map Flags*****************************************************************************}@GMF:	L0¬1,						c1, at[9,10,ESC0n];	T ¬ STK, fXpop, fZpop, GOTO[SMFa],				c2;GMFa:	STK ¬ 0,							c1;	IBDisp, GOTO[SLa],						c2;{*****************************************************************************	WR - Write Registers*****************************************************************************}@WRPSB:	uPSB ¬ TOS,					c1, at[0,10,ESC7n];WRx:	TOS ¬ STK, pop, IBDisp, GOTO[DISPNIonly],		c2;@WRMDS:	TT ¬ UvMDS, fXpop, push,			c1, at[1,10,ESC7n];	rhMDS ¬ TOS LRot0,					c2;	Q ¬ UvL,						c3;WRMDSa:	Map ¬ [rhMDS, Q], BRANCH[WRMDSb,WRMDSc],		c1;WRMDSb:	UvMDS ¬ TOS,						c2;	L ¬ rhL ¬ MD,						c3;	MAR ¬ L ¬ [rhL, Q+0], L0 ¬ 1,				c1;	[] ¬ TT xor UvGhigh, ZeroBr,				c2;	Q ¬ UvG, L0Disp, BRANCH[$,WRMDSa],			c3;	CANCELBR[WRx,1],					c1;WRMDSc:	UvGhigh ¬ TOS,						c2;	G ¬ rhG ¬ MD,						c3;	MAR ¬ G ¬ [rhG, Q+0], GOTO[WRx],			c1;@WRWP:	uWP ¬ TOS, GOTO[WRx],				c1, at[2,10,ESC7n];@WRWDC:	uWDC ¬ TOS, ZeroBr,				c1, at[3,10,ESC7n];	TOS ¬ STK, pop, IBDisp, BRANCH[DisableInts,EnableInts],	c2;DisableInts:	ClrIE, DISPNI[OpTable],					c3;EnableInts:	SetIE, DISPNI[OpTable],					c3;@WRPTC:	uPTC ¬ TOS, GOTO[WRx],				c1, at[4,10,ESC7n];	{@WRIT in MiscDxx				c1, at[5,10,ESC7n];}@WRXTS:	uXTS ¬ TOS, GOTO[WRx],					c1, at[6,10,ESC7n];	{@WRMP in MiscDxx					c1, at[7,10,ESC7n];}{*****************************************************************************	RR - Read Registers*****************************************************************************}@RRPSB:	TOS ¬ uPSB, push, GOTO[RRx],			c1, at[8,10,ESC7n];RRx:	push, fZpop, IBDisp, GOTO[DISPNIonly],			c2;@RRMDS:	TOS ¬ UvMDS, push, GOTO[RRx],			c1, at[9,10,ESC7n];@RRWP:	TOS ¬ uWP, push, GOTO[RRx],			c1, at[0A,10,ESC7n];@RRWDC:	TOS ¬ uWDC, push, GOTO[RRx],			c1, at[0B,10,ESC7n];@RRPTC:	TOS ¬ uPTC, push, GOTO[RRx],			c1, at[0C,10,ESC7n];	{@RRIT in MiscDxx				c1, at[0D,10,ESC7n];}@RRXTS:	TOS ¬ uXTS, push, GOTO[RRx],			c1, at[0E,10,ESC7n];{added for performance study}@a177:	TOS ¬ uIdleCountHigh, push,			c1, at[0F,10,ESC7n];	T ¬ uIdleCountLow, IBDisp, push,		c2;	STK ¬ T, push, fZpop, DISPNI[OpTable],		c3;@STC:	T ¬ 0F,							c1, opcode[77'b];	T ¬ T and ~ErrnIBnStkp,					c2;	Ybus ¬ T xor ib, ZeroBr,				c3;	T ¬ sStackError, BRANCH[Trapc2, $], 			c1;	PC ¬ PC + 1, IBDisp, GOTO[DISPNIonly],			c2;@MBP:	Q ¬ STK, fXpop, fZpop, push,				c1, opcode[175'b];	[] ¬ Q or TOS, ZeroBr, 					c2; 	PC ¬ PC + PC16, BRANCH[$, NxtInstc1],       		c3;	Rx ¬ DLShift1 TOS, Cin ¬ 1,				c1;	TOS ¬ Rx or u8000, 					c2;	STK ¬ Q, GOTO[NxtInstc1], 				c3; 		Set[sBytePointerTrap, 10];	BPErr:	T ¬ sBytePointerTrap, GOTO[Trapc3],			c2;@RBP:	T ¬ STK, L3¬0, 						c1, opcode[176'b];	Q ¬ T + ibNA, L1¬L1.Push, CarryBr, GOTO[BPSub],	LOOPHOLE[stw],	c2;	@WBP:	T ¬ STK, L3¬1, 						c1, opcode[177'b];	Q ¬ T + ibNA, L1¬L1.Push, CarryBr, GOTO[BPSub],	LOOPHOLE[stw], 	c2;	BPSub:	Rx ¬ TOS, NegBr, BRANCH[BPNoCr, BPCar],			c3;BPNoCr: BRANCH[BPErr, BPCont],					c1;BPCar:  Rx ¬ Rx + 1, BRANCH[BPErr, BPCont],			c1;	   BPCont:	Rx ¬ Rx and (~u8000), 					c2;	Rx ¬ DRShift1 (Rx xor 1), Cin ¬ 0, 			c3;	rhTT ¬ Rx LRot0, TT ¬ Q, 				c1;	T ¬ T + ib, 						c2;	pop, GOTO[RLSd],					c3;{*****************************************************************************	Unimplemented Opcodes cause Opcode Trap*****************************************************************************}@Unimp76:	TT ¬ 76'b, push, GOTO[OpcodeTrap],		c1, opcode[76'b];{@Unimp277:	TT ¬ 277'b, push, GOTO[OpcodeTrap],		c1, opcode[277'b]; ---> @VMFIND}@Unimp336:	TT ¬ 336'b, push, GOTO[OpcodeTrap],		c1, opcode[336'b];@Unimp376:	TT ¬ 376'b, push, GOTO[OpcodeTrap],		c1, opcode[376'b];@Unimp377:	TT ¬ 377'b, push, GOTO[OpcodeTrap],		c1, opcode[377'b];OpcodeTrap:	T ¬ sOpcodeTrap, STK ¬ TOS, pop, GOTO[ESCc],		c2;	{ E N D }	
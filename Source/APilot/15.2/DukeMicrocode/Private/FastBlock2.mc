{File name FastBlock2.mcDescription: Mesa Block Transfer op-codes(BLT, BLTL, BLEL)Author: SXO     Created: May 13, 1988Last Edited: TxH  13-Sep-88 10:19:00 changed the file name;                                      moved the register-defs into DukeExtras.dfn;}{ 	Copyright (C) 1982, 1983, 1984, 1985 by Xerox Corporation.  All rights reserved.}{This module handles BlockTransfer(BLT, BLTL) and BlockEqual(BLEL) instructions.For the Block instructions, L2 is used to distinguish the opcodes as follows:Inst.	L2	code	long	Block	Transfer					BLT	3	0	0	1	1BLTC	B	1	0	1	1BLTCL	F	1	1	1	1BLTL	7	0	1	1	1BLEL	6	0	1	1	0BLECL	E	1	1	1	0CKSUM	4	0	1	0	0BLTLR	5	0	1	0	1After L2Disp:	BRANCH[NotBlockTransferInstruction, BlockTransferInstruction, 0E],	BRANCH[ChecksumInstruction, BlockInstruction, 0D],	BRANCH[ShortInstruction, LongInstruction, 0B],		BRANCH[ZeroBase, CodeBase, 7],	}Set[Transfer,0E];Set[Block,0D];Set[Long,0B];{RegDef[rSR,			R,	09];RegDef[rhSR,			RH,	09];RegDef[rWTransferred,		R,	0B];RegDef[rCompResult,		R,	0B];RegDef[rWCount,			R,	0C];RegDef[rSrcData,		R,	0E];RegDef[rStkPSaveTemp,		R,	0E];RegDef[rRMD,			R,	0E];RegDef[uStkPSave,		U,	0E5];RegDef[uCountSave,		U,	0C6];{must be Cx because rWCount(R-0C) is saved}}Set[L0.BLEL.Dst	,	0E];Set[L0.BL.Src	,	0F];Set[L1.first	,	0];Set[L1.second	,	1];{******************************************************************************************	BLT  Block Transfer	   TOS = destLow	   STK = count	   STK-1 = srcLow******************************************************************************************}{		*** For first mapping ***	rhMDS 		= dest and source virtual address high				 *** For second mapping *** 	rhTT, TT	= source virtual address high	rhT		= dest virtual address high			*** First and Second Common ***  	T		= source virtual address low	TOS		= dest virtual address low	rhRx, Rx	= dest real address	rhSR, rSR	= source real address	rWCount		= count	rWTransferred	= words transferred}	@BLT:						InitDstMap.BLT:		Map ¬ Q ¬ [rhMDS, TOS{dstLow} + 0], pop{srcLow}, L2 ¬ BLT,	c1, opcode[363'b];			T ¬ STK{srcLow}, L1 ¬ L1.first{Init}, push{count},		c2;			Rx ¬ rhRx ¬ MD, XWtOKDisp,					c3;		InitSrcMap.BLT:		Map ¬ Q ¬ [rhMDS, T{srcLow}], BRANCH[SetInitDestDirty.BLT, InitDestDirty.BLT, 0D],c1;InitDestDirty.BLT:	rWCount ¬ STK{count}, pop{srcLow}, NZeroBr,			c2;			rSR ¬ rhSR ¬ MD, XRefBr, BRANCH[InitCountIs0.BLT, InitBlockStart.BLT],c3;									InitBlockStart.BLT:	MAR ¬ [rhSR, T + 0], pop{next}, BRANCH[SetInitSrcRef.BLT, InitSrcMapOK.BLT, 0E], c1;   InitSrcMapOK.BLT:	rWTransferred ¬ 0, 						c2;			rSrcData ¬ MD{source}, {L2Disp, GOTO[FirstDest.BL],}		c3;						MAR ¬ Rx ¬ [rhRx, TOS + 0], 					c1;			MDR ¬ rSrcData, rWCount ¬ rWCount - 1, ZeroBr, 			c2;			rWTransferred ¬ rWTransferred + 1,BRANCH[InitReadSrc.BLT, InitCountZero.BLT],c3;			InitReadSrc.BLT:	MAR ¬ rSR ¬ [rhSR, T{Not rSR} + 1], MesaIntBr, GOTO[CheckSource.BL], c1;						{******************************************************************************************	BLTL  Block Transfer Long	   TOS = destHi	   STK = destLow	   STK-1 = count	   STK-2 = srcHi	   STK-3 = srcLow******************************************************************************************}@BLTL:			rStkPSaveTemp ¬ ~ErrnIBnStkp, L2 ¬ BLTL, 	 	c1, opcode[364'b];			rhT ¬ TOS{destHi} LRot0, GOTO[PopDestLow.BL],		c2;			{******************************************************************************************	BLEL  Block Equal Long	   TOS = destHi	   STK = destLow	   STK-1 = count	   STK-2 = srcHi	   STK-3 = srcLow******************************************************************************************}@BLEL:			rStkPSaveTemp ¬ ~ErrnIBnStkp, L2 ¬ BLEL, 	 	c1, at[8,10,ESC2n];			rhT ¬ TOS{destHi} LRot0, GOTO[PopDestLow.BL],		c2;  			{******************************************************************************************			BLTL, BLEL Common******************************************************************************************}PopDestLow.BL:		TOS ¬ STK{destLow}, pop{count},				c3;												rWCount ¬ STK{count}, pop{srcHigh}, ZeroBr,		c1;			TT ¬ rhTT ¬ STK{srcHigh}, pop{srcLow}, BRANCH[PopSrcLow.BL, InitCountIs0.BL],c2;PopSrcLow.BL:		T ¬ STK {srcLow}, pop {next}, GOTO[MapSource.BL],  	c3;											{******************************************************************************************MapSource.BL(BLT, BLTL, BLEL)	Map source and dest virtual addresses					T		= source virtual address low	TOS		= dest virtual address low	rhRx, Rx	= dest real address high	rhSR, rSR	= source real address high	rWCount		= count	rWTransferred	= words transferred******************************************************************************************}MapSource.BL:		Map ¬ Q ¬ [rhTT, T{srcLow} + 0], L0 ¬ L0.BL.Src,	c1;			{uSourceHighSaveTemp ¬ TT,} L1 ¬ L1.second{second}, {TT ¬ rhTT,}			c2;			rSR ¬ rhSR ¬ MD, XRefBr, uStkPSave ¬ rStkPSaveTemp,	c3;			DestMap.BL:		Map ¬ [rhT, TOS{dstLow}], L2Disp, BRANCH[SetSrcRef.BL, SourceMapOK.BL, 0E],c1;SourceMapOK.BL:		Q ¬ rhT{dstHigh}, L0 ¬ L0.BLEL.Dst, BRANCH[DestRead.BLEL, DestWrite.BL, Transfer], c2;{BLT, BLTL}			DestWrite.BL:		Rx ¬ rhRx ¬ MD, XWtOKDisp, {uSourceHighSaveTemp ¬ TT, }GOTO[BlockStart.BL],c3;{BLEL}DestRead.BLEL:		Rx ¬ rhRx ¬ MD, XRefBr, {uSourceHighSaveTemp ¬ TT,} GOTO[CompareStart],	c3;{BLT, BLTL}BlockStart.BL:		MAR ¬ rSR ¬ [rhSR, T + 0], BRANCH[SetDestDirty.BL, DestDirty.BL, 0D],c1;DestDirty.BL:		rWTransferred ¬ 0, {uCountSave ¬ rWCount,}		c2;GetSrcData:		rSrcData ¬ MD{source}, L2Disp, GOTO[FirstDest.BL],	c3;{BLEL}CompareStart:		MAR ¬ rSR ¬ [rhSR, T + 0], BRANCH[SetDestRef.BLEL, DestReferenced.BLEL],c1;DestReferenced.BLEL:	{rWTransferred ¬ 0,} uCountSave ¬ rWCount, GOTO[GetSrcData], c2;{******************************************************************************************		BLT, BLTL & BLEL Loop Body******************************************************************************************}						FirstDest.BL:		MAR ¬ Rx ¬ [rhRx, TOS + 0], BRANCH[ReadNextDest.BLEL,WriteNextDest.BL ,Transfer],c1;{Come here if BLT & BLTL to store the source word in the dest address.}			WriteNextDest.BL:	MDR ¬ rSrcData, rWCount ¬ rWCount - 1, ZeroBr, BRANCH[NoDestWriteCross.BL, DestWriteCross.BL ,1],c2;NoDestWriteCross.BL:	rWTransferred ¬ rWTransferred + 1, BRANCH[ReadSource.BLT, CountZero.BL],c3;{Come here if BLEL to compare the source word to the dest word.}ReadNextDest.BLEL:	rWCount ¬ rWCount - 1,	ZeroBr, BRANCH[NoDestReadPgCross.BLEL, DestReadPgCross.BLEL,1],	c2;NoDestReadPgCross.BLEL:	rCompResult ¬ MD{dest} xor rSrcData,BRANCH[ReadSource.BLEL, CountZero.BLEL],c3;ReadSource.BLEL:	MAR ¬ rSR ¬ [rhSR, rSR + 1], MesaIntBr,			c1;{BLEL}			[] ¬ rCompResult, NZeroBr, DISP2[SourceCheck.BLEL], 	c2;{BLEL}			rSrcData ¬ MD{source}, BRANCH[NextDest.BLEL, False.BLEL],c3, at[0,4,SourceCheck.BLEL];	ReadSource.BLT:		MAR ¬ rSR ¬ [rhSR, rSR + 1], MesaIntBr, GOTO[CheckSource.BL], 	c1;CheckSource.BL:		DISP2[SourceCheck.BL],					c2;			rSrcData ¬ MD {source}, GOTO[NextDest.BL],		c3, at[0,4,SourceCheck.BL];						L1Disp, GOTO[Update.BL,0F], {source page cross}			c3, at[2,4,SourceCheck.BL];			L1Disp, GOTO[Update.BL,0F], {interrupt}				c3, at[1,4,SourceCheck.BL];			L1Disp, GOTO[Update.BL,0F], {source page cross and interrupt}	c3, at[3,4,SourceCheck.BL];						rWTransferred ¬ uCountSave, BRANCH[BLELUpdate, BLELFalse], {source page cross}	c3, at[2,4,SourceCheck.BLEL];			rWTransferred ¬ uCountSave, BRANCH[BLELUpdate, BLELFalse], {interrupt}			c3, at[1,4,SourceCheck.BLEL];			rWTransferred ¬ uCountSave, BRANCH[BLELUpdate, BLELFalse], {source page cross and interrupt}	c3, at[3,4,SourceCheck.BLEL];NextDest.BL:		MAR ¬  Rx ¬ [rhRx, Rx + 1], GOTO[WriteNextDest.BL], 	c1;NextDest.BLEL:		MAR ¬  Rx ¬ [rhRx, Rx + 1], GOTO[ReadNextDest.BLEL], 	c1;DestWriteCross.BL:	rWCount ¬ rWCount + 1, L1Disp, CANCELBR[Update.BL, 0F],	c3;{Come here BLEL Dest read page cross.We must set rWTransferred, since rWTransferred was't counted in main loop}DestReadPgCross.BLEL:	rWCount ¬ rWCount + 1, CANCELBR[$, 0F],		c3; 			rWTransferred ¬ uCountSave,			c1;SetWordTrans.BLEL:	rWTransferred ¬ rWTransferred - rWCount,	c2;			L1Disp, GOTO[Update.BL],			c3;{Come here if BLT first dest map must be fixed for dirtyTOS = virtual sourceLow. rhTT = virtual sourceHi. Set Rx to map data.}SetInitDestDirty.BLT:	TT ¬ rhTT ¬ UvMDS, CALL[WLMapFix.BL],		c2;{Come here if BLT & BLTL dest map must be fixed for dirty}			SetDestDirty.BL:	rhTT ¬ Q{destHigh} LRot0, CALL[WLMapFix.BL],	c2;{Come here if BLEL dest map must be fixed for referencedQ = virtual sourceLow. rhTT = virtual sourceHi. Set rRMD to map data.}SetDestRef.BLEL:	rhTT ¬ Q LRot0{destHigh},			c2;			rRMD ¬ Rx{map data},				c3;			Q ¬ TOS{destLow},  				c1;			CALL[RLMapFix.BL,0F],				c2;{Come here if BLT first source map must be fixed for referenced.Q = virtual sourceLow. rhTT = virtual sourceHi. Set rRMD to map data.}SetInitSrcRef.BLT:	TT ¬ rhTT ¬ UvMDS, {CALL[RLMapFix.BL,0F],}	c2;			Xbus ¬ rSR LRot0, rRMD ¬ rSR{map data}, XwdDisp, CALL[RLMapx.BLT,0F],c3;			{Come here if source map must be fixed for referenced}			SetSrcRef.BL:		rRMD ¬ rSR{map data}, CANCELBR[RLMapFix.BL,0F],	c2;BLELUpdate:		GOTO[SetWordTrans.BLEL],			c1;BLELFalse:		TOS ¬ 0{FALSE}, GOTO[IBDispOnly],		c1;			False.BLEL:		TOS ¬ 0{FALSE}, GOTO[IBDispOnly],		c1;{Come here RLMapFix.BL or WLMapFix.BL in case of trap on BLTL, BLEL}HiTT.BL:		stackP ¬ uStkPSave, L2Disp,					c2;			TOS ¬ Q{destHigh}, BRANCH[HiTT.BLEL, HiTT.BLTL, Transfer],	c3;						HiTT.BLEL:		PC ¬ PC - 1, push, GOTO[HiTT{in Commonsubs}],			c1;HiTT.BLTL:		push, GOTO[HiTT],						c1;{Come here RLMapFix.BL or WLMapFix.BL in case of trap on BLT}HiTT.BLT:		Q ¬ rhTT, push, GOTO[Faultc3],					c2;{******************************************************************************************Update.BL(BLT, BLTL, BLEL)	Come here if we got a source or dest page cross or an interrupt request.		TT = uSourceHighSaveTemp  source virtual address high	rhT = dest virtual address high	T = source virtual address low	TOS = dest virtual address low		rWTransferred = number of words transferred******************************************************************************************}Update.BL:		rSR ¬ ~ErrnIBnStkp, BRANCH[FirstUpdate.BLT, NotFirstUpdate.BL, 0E],c1;NotFirstUpdate.BL:	Noop,{TT ¬ uSourceHighSaveTemp,}				c2;			rhTT ¬ TT LRot0, GOTO[UpdateForward.BL],			c3;	    {Come here if first update for BLT. We must set TT, rhTT and rhT to virtual address high.}			FirstUpdate.BLT:	TT ¬ rhTT ¬ UvMDS, CANCELBR[$, 0F],				c2;			rhT ¬ TT LRot0,							c3;			UpdateForward.BL:	TOS ¬ TOS{dstLow} + rWTransferred {words transferred}, CarryBr,	c1;			TestDestCarry.BL:  	BRANCH[NoDestCarry.BL, DestCarry.BL],	c2;DestCarry.BL:		Q ¬ rhT{destHigh} + 1, LOOPHOLE[byteTiming],			c3;						rhT ¬ Q LRot0,GOTO[TestDestCarry.BL], {delay 1 cycle}		c1;					NoDestCarry.BL:		T ¬ T{srcLow} + rWTransferred {words transferred}, CarryBr,	c3;TestSourceCarry.BL:	BRANCH[UpdateStack.BL, SourceCarry.BLT],			c1;			SourceCarry.BLT:	TT ¬ TT{srcHigh} + 1,						c2;			rhTT ¬ TT LRot0, GOTO[TestSourceCarry.BL], {delay 1 cycle}	c3;{******************************************************************************************UpdateStack.BL(BLT, BLTL, BLEL)	If we must interrupt, we must save the state in the stack.******************************************************************************************}UpdateStack.BL:		Q ¬ rhT {destHi}, push {srcLow}, L2Disp,			c2;			STK ¬ T {srcLow}, push {srcHigh(BLTL, BLEL) or count(BLT)},{Continue next line} 			BRANCH[StoreCountWait.BLT, StoreSrcHi.BL, Long],		c3;			StoreCountWait.BLT:	{L0 ¬ restore.int, }GOTO[StoreCount.BL],			c1;		StoreSrcHi.BL:		STK ¬ TT {srcHi}, push {count},					c1;			StoreCount.BL:		STK ¬ rWCount {count}, L2Disp, push{destLow},			c2;			STK ¬ TOS {destLow}, push{destHigh(Long)}, BRANCH[ShortDone.BLT, StoreDestHi.BL, Long],c3;StoreDestHi.BL:		STK ¬ Q{destHigh}, {L0 ¬ restore.int,} MesaIntBr, GOTO[CheckInt.BL],c1;ShortDone.BLT:		pop, MesaIntBr, GOTO[CheckInt.BL], 				c1;			CheckInt.BL:		rStkPSaveTemp ¬ uStkPSave, L2Disp, BRANCH[$, Interrupt.BL],	c2;       					stackP ¬ rSR,  CANCELBR[MapSource.BL, 0F], 			c3;			Interrupt.BL:		L2Disp, BRANCH[Interrupt.BLT, RestoreTOS.BL, Long],c3;RestoreTOS.BL:		TOS ¬ Q{destHigh}, pop, BRANCH[GetInitPC.BLEL, ByteCode.BLTL, Transfer], c1;GetInitPC.BLEL:		PC ¬ PC - 1, GOTO[BlockInt{in InterruptsDaybreak}],		c2;ByteCode.BLTL:		GOTO[BlockInt{in InterruptsDaybreak}],				c2;			Interrupt.BLT:		pop, CANCELBR[IntDaybreak.BL, 0F],				c1;IntDaybreak.BL:		GOTO[BlockInt{in InterruptsDaybreak}],				c2; {*****************************************************************************************			Initial Count and Count is Zero(BLT, BLTL, BLEL)*****************************************************************************************}{Initial count=0, BLT}InitCountIs0.BLT:	pop{next}, PC ¬ PC + PC16, CANCELBR[$, 0F],			c1;			TOS ¬ STK, pop, IBDisp, GOTO[DISPNIonly],			c2;{Initial count=0, BLTL, BLEL}InitCountIs0.BL:	pop{next}, L2Disp,						c3;			TOS ¬ STK, pop, BRANCH[InitCnt0.BLEL, BlockDone.BL, Transfer],	c1;InitCnt0.BLEL:		push, TOS ¬ 1, IBDisp, GOTO[DISPNIonly],			c2; {Come here if initial count=1, BLT}InitCountZero.BLT:	TOS ¬ STK, pop, CANCELBR[BlockDone.BL, 3],		c1; 			CountZero.BLEL:		[] ¬ rCompResult, NZeroBr,					c1;			IBDisp, BRANCH[CompDone.TRUE, CompDone.FALSE],			c2;			CompDone.TRUE:		TOS ¬ 1{TRUE}, DISPNI[OpTable],					c3;CompDone.FALSE:		TOS ¬ 0{FALSE}, DISPNI[OpTable],				c3;CountZero.BL:		TOS ¬ STK, pop, CANCELBR[$, 3],					c1;BlockDone.BL:		PC ¬ PC + PC16, IBDisp, GOTO[DISPNIonly],			c2;{*****************************************************************************************			Destination Page Fault or Map Fix(BLT, BLTL) *****************************************************************************************}WLMapFix.BL:		{Come here if dest map must be fixed for dirty.			TOS = virtual sourceLow. rhTT = virtual sourceHi. Set Rx to map data.}						Xbus ¬ Rx LRot0, XwdDisp, {L3 ¬ L3.rhTT.Q,}			c3;			Map ¬ [rhTT,TOS], DISP2[WLMapa.BL], 				c1;WLMapa.BL:		MDR ¬ Rx or map.rd, LOOPHOLE[wok], L1Disp, GOTO[WLMapb.BL],	c2, at[0,4,WLMapa.BL];			T ¬ qWriteProtect, L1Disp, GOTO[WLTrap.BL],			c2, at[1,4,WLMapa.BL];			MDR ¬ Rx or map.rd, LOOPHOLE[wok], L1Disp, GOTO[WLMapb.BL],	c2, at[2,4,WLMapa.BL];			T ¬ qPageFault, L1Disp, GOTO[WLTrap.BL],			c2, at[3,4,WLMapa.BL];WLMapb.BL:		Xbus ¬ 2, XDisp, BRANCH[InitSrcMap.BLT, BlockStart.BL ,0E],	c3;WLTrap.BL:		push, uFaultParm0 ¬ TOS{dstLow}, L2Disp, BRANCH[InitWTrapFix.BLT, WTrapFix.BL ,0E],	c3;InitWTrapFix.BLT:	{TOS ¬ STK}CANCELBR[HiTT, 0F],					c1;WTrapFix.BL:		push, Q ¬ rhTT{destHigh}, BRANCH[HiTT.BLT, HiTT.BL, Long], 		c1;{****************************************************************************************			Source Page Fault or Map Fix(BLT, BLTL, BLEL)			Destination Page Fault or Map Fix(BLEL) ***************************************************************************************}RLMapFix.BL:		{Come here if source map must be fixed for referenced.			Q = virtual sourceLow. rhTT = virtual sourceHi. Set rRMD to map data.}						Xbus ¬ rRMD LRot0,XwdDisp, {L3 ¬ L3.rhTT.Q,}			c3;RLMapx.BLT:		Map ¬ [rhTT,Q], DISP2[RMapa.BL], L1Disp,			c1;			RMapa.BL:		MDR ¬ rRMD or map.referenced, L0Disp, BRANCH[InitRMapb.BLT, RMapb.BL ,0E], c2, at[0,10];			MDR ¬ rRMD or map.referenced, L0Disp, BRANCH[InitRMapb.BLT, RMapb.BL ,0E], c2, at[1,10,RMapa.BL];			MDR ¬ rRMD or map.referenced, L0Disp, BRANCH[InitRMapb.BLT, RMapb.BL ,0E], c2, at[2,10,RMapa.BL];IBEmptyTrap.BL:		T ¬ qPageFault, CANCELBR[RTrap.BL, 0F],			c2, at[3,10,RMapa.BL];InitRMapb.BLT:		Xbus ¬ 1, XDisp, push{dummy}, CANCELBR[InitBlockStart.BLT, 0F],	c3;RMapb.BL:		Xbus ¬ 1, XDisp, BRANCH[CompareStart, DestMap.BL, 0E], 		c3;RTrap.BL:		push, uFaultParm0 ¬ Q{srcLow}, L2Disp, 				c3;			Q ¬ rhT{destHigh}, push, BRANCH[HiTT.BLT, HiTT.BL, Long],	c1;
{File name:  LineBreak.mcDescription: LineBreak opcodeAuthor: JPMCreated: December 17, 1986Last Edited:JPM	December 5, 1990	Move new register definitions to Daybreak.dfnJPM	October 8, 1990		Revise algorithm per LineBreakImplJPM	January 8, 1990		Don't do WholeWordBreak if oneBigToken (per LineBreakImpl)JPM	November 21, 1989	Skip Esc space code if inhibit flag is TRUEJPM	November 7, 1989	Fix bug in LBBreakOK (can't let L1 change)JPM	November 3, 1989	Fix bug in ProcessSpace (should set inhibit flag to TRUE)JPM	October 30, 1989	Revise algorithm per LineBreakImpl.mesa, againJPM	October 6, 1989		Fix bug in LBReadPriorIndex (must subtract index from count)JPM	September 14, 1989	Revise algorithm per LineBreakImpl.mesaJPM	December 31, 1986	Fix bug in LBReadPriorIndex (wrong offset)JPM	December 30, 1986	Add (and use) suffixHardHyphen; fix bug in LBTextCross (can't use r0100)JPM	December 19, 1986	Revise algorithm per LineBreakImpl.mesa}{ 	Copyright (C) 1990 by Advanced Workstation Products, Inc., a Xerox company.  All rights reserved. 	Copyright (C) 1986, 1989 by Xerox Corporation.  All rights reserved.}{Link register use:	L0 - returns from MapSrc and MapDst subroutines	L1 - need to write prior U-regs into arg (1 = FALSE, 0 = TRUE) -- init after calls to MapSrc/MapDst	L2 - hyphenate flag (2 = FALSE, 3 = TRUE)	L3 - returns from LBProcessSpace, and other misc. flow control	L4 - returns from LBSaveBreak	L5 - final.class (see below)	L6 - prior.class	L7 - final.inhibitImplicitSpace (0 = FALSE, 8 = TRUE)}{return reasons}Set[reasonMargin, 0];Set[reasonNormal, 1];Set[reasonChangeBase, 2];Set[reasonInvalidProps, 3];Set[reasonContiguousWords, 4];Set[reasonUnableToBreak, 5];Set[reasonSpecialGermanCase, 6];Set[reasonOneBigToken, 7];Set[reasonBreakPoint, 8];Set[reasonSoftHyphen, 9];{escape types}Set[escapeSpace, Or[0,8]];Set[escapeZeroWidthSpace, Or[1,8]];Set[escapeChangeBase, Or[2,8]];Set[escapeInhibitImplicitSpace, Or[3,8]];Set[escapeBreakPoint, Or[4,8]];Set[escapeSoftHyphen, Or[5,8]];{state field constants}Set[spaceCountIncr, Lshift[1,4]];Set[inhibitImplicitSpaceTRUE, Lshift[1,3]];Set[inhibitImplicitSpaceFALSE, 0];Set[suffixCharField, 7];{suffixChar types}Set[suffixSpace, 0];Set[suffixZeroWidthSpace, 1];Set[suffixHyphen, 2];Set[suffixHardHyphen, 3];Set[suffixNull, 4];{class types}Set[storedClassSpace, Lshift[0,2]];Set[classSpace, Or[storedClassSpace,3]];Set[storedClassPuncNoSpaceBefore, Lshift[1,2]];Set[classPuncNoSpaceBefore, Or[storedClassPuncNoSpaceBefore,3]];Set[storedClassPuncSpaceBefore, Lshift[2,2]];Set[classPuncSpaceBefore, Or[storedClassPuncSpaceBefore,3]];Set[storedClassWord, Lshift[3,2]];Set[classWord, Or[storedClassWord,3]];{returns from LBProcessSpace}Set[lbInvProps, 1];Set[lbImplicit, 2];Set[lbEsc, Or[lbImplicit,1]];{returns from LBSaveBreak}Set[lbHyp, 0];Set[lbHHyp, 1];Set[lbPS, escapeSpace];Set[lb0wS, escapeZeroWidthSpace];{misc flow control}Set[lbInit, 0];Set[lbTCr, 2];@LINEBREAK:	rhVirtualH ¬ TOS LRot0,						c1, at[0E,10,ESCAn];	rVirtualL ¬ STK, pop, L0 ¬ L0.LineBreak,			c2;	rVirtualL ¬ rVirtualL + 2, fXpop, push, CALL[MapDst],		c3; {get length 1st}{MapDst subroutine starts in c1, ends in c2}	rCtMinusIx ¬ MD {text.LENGTH},					c3, MapDstRet[L0.LineBreak];	MAR ¬ [rhArgReal, rArgReal + 0B], {offset 0D - 2}		c1;	uLBTextCount ¬ rCtMinusIx, CANCELBR[$,2],			c2;	rTemp ¬ MD {final.class/index},					c3;	rTemp ¬ rTemp LRot4, XDisp,					c1;	rTemp ¬ rTemp and ~0C, L5 ¬ 3{/7/B/F}, DISP4[LBInitClass,3],	c2;	rTemp ¬ rTemp LRot12, GOTO[LBInitCont],				c3, at[classSpace,10,LBInitClass];	rTemp ¬ rTemp LRot12, GOTO[LBInitCont],				c3, at[classPuncNoSpaceBefore,10,LBInitClass];	rTemp ¬ rTemp LRot12, GOTO[LBInitCont],				c3, at[classPuncSpaceBefore,10,LBInitClass];	rTemp ¬ rTemp LRot12, GOTO[LBInitCont],				c3, at[classWord,10,LBInitClass];LBInitCont:	MAR ¬ rArgReal ¬ [rhArgReal, rArgReal - 2],			c1; {start of arg}	rCtMinusIx ¬ rCtMinusIx - rTemp, ZeroBr, CANCELBR[$,2],		c2;	uLBArgRealLo ¬ rArgReal, rVirtualL ¬ MD {text lo}, BRANCH[$,LBFastExit], c3;	MAR ¬ [rhArgReal, rArgReal + 1], L3 ¬ lbInit,			c1;	rVirtualL ¬ rVirtualL + rTemp, CarryBr, CANCELBR[$,2],		c2;	uLBTextRealLo ¬ rVirtualL, rhVirtualH ¬ MD {text hi}, BRANCH[$,LBUpdateHigh], c3;	MAR ¬ [rhArgReal, rArgReal + 11],				c1, at[lbInit,10,LBUpdateHighRet];	Q ¬ suffixCharField, CANCELBR[$,2],				c2;	rSpCount ¬ MD {final.count/inhibitImplicitSpace/suffixChar},	c3;	MAR ¬ [rhArgReal, rArgReal + 10],				c1;	rhSuffixChar ¬ (rSpCount and Q) LRot0, CANCELBR[$,2],		c2;	rBitLength ¬ MD {final.pixelLength},				c3;	MAR ¬ [rhArgReal, rArgReal + 3],				c1;	rSpCount ¬ rSpCount and ~suffixCharField, CANCELBR[$,2],	c2;	Q ¬ MD {propsBase lo},						c3;	MAR ¬ [rhArgReal, rArgReal + 4],				c1;	uLBCacheLo ¬ Q, CANCELBR[$,2],					c2;	Q ¬ MD {propsBase hi},						c3;	MAR ¬ [rhArgReal, rArgReal + 5],				c1;	uLBCacheHi ¬ Q, CANCELBR[$,2],					c2;	Q ¬ MD {hyphenate/font}, XHDisp,				c3;	MAR ¬ [rhArgReal, rArgReal + 6], L2 ¬ 2{/3}, BRANCH[$,LBSetHyphenate,2], c1;	CANCELBR[LBInitCont2,2],					c2;LBSetHyphenate:	Q ¬ Q and ~u8000, CANCELBR[$,2],				c2; {clear high bit}LBInitCont2:	rMargin ¬ MD {margin lo},					c3;	MAR ¬ [rhArgReal, rArgReal + 8],				c1;	uLBFont ¬ Q, CANCELBR[$,2],					c2;	UrG ¬ G, rMinSpPLength ¬ MD {hyphenPixelLength/minSpacePixelLength}, c3;	MAR ¬ [rhArgReal, rArgReal + 0A],				c1;	rhLBHyphenPL ¬ rMinSpPLength LRot8, CANCELBR[$,2],		c2;	UrL ¬ L, rMinSpMLength ¬ MD {minSpaceMicaLength},		c3;	MAR ¬ [rhArgReal, rArgReal + 0B],				c1;	rMinSpPLength ¬ rMinSpPLength and 0FF, CANCELBR[$,2],		c2;	UrPC ¬ PC, rWhiteSpaceIncr ¬ MD {additionalWhiteSpace},		c3;	MAR ¬ [rhArgReal, rArgReal + 0C],				c1;	UrInt ¬ rInt, CANCELBR[$,2],					c2;	rSpMLength ¬ MD {spaceMicaLength},				c3;	MAR ¬ [rhArgReal, rArgReal + 0E],				c1;	Q ¬ rhArgReal, CANCELBR[$,2],					c2;	rMicaLength ¬ MD {final.micaLength},				c3;	MAR ¬ [rhArgReal, rArgReal + 15],				c1;	uLBArgRealHi ¬ Q, CANCELBR[$,2],				c2;	UrIORgn ¬ rIORgn, rTotSpace ¬ MD {final.totalSpaceMicaLength},	c3;	MAR ¬ [rhArgReal, rArgReal + 18],				c1;	rSpCount ¬ rSpCount and ~inhibitImplicitSpaceTRUE, Ybus ¬ rSpCount, YDisp, CANCELBR[$,2], c2;	Q ¬ MD {prior.micaLength}, L7 ¬ 0{/8}, DISP4[LBSetImplicit],	c3;	MAR ¬ [rhArgReal, rArgReal + 1D], GOTO[LBInitCont3],		c1, at[inhibitImplicitSpaceFALSE,10,LBSetImplicit];	MAR ¬ [rhArgReal, rArgReal + 1D],				c1, at[inhibitImplicitSpaceTRUE,10,LBSetImplicit];LBInitCont3:	uLBPMicaLength ¬ Q, CANCELBR[$,2],				c2;	Q ¬ MD {prior.additionalWhiteSpace},				c3;	MAR ¬ [rhArgReal, rArgReal + 13],				c1;	uLBPWhiteSpace ¬ Q, CANCELBR[$,2],				c2;	rWhiteSpace ¬ MD {final.additionalWhiteSpace}, CALL[MapSrc],	c3;{MapSrc subroutine starts in c1, ends in c2}	Q ¬ MD {text[index]}, XHDisp, L1 ¬ 1,				c3, MapSrcRet[L0.LineBreak];	MAR ¬ [rhArgReal, rArgReal + 12], L3 ¬ lbImplicit{/lbEsc}, BRANCH[$,LBFirstEsc,2], c1;	CANCELBR[LBReadyToLoop,2],					c2;LBFirstEsc:	CANCELBR[$,2],							c2;LBReadyToLoop:	rByteCount ¬ MD {final.byteCount}, L3Disp, GOTO[LBMainLoopCont], c3;LBMainLoop:	MAR ¬ rTextReal ¬ [rhTextReal, rTextReal + 1], BRANCH[$,LBNormalExit], c1;LBMainRead:	BRANCH[$,LBTextCross,1],					c2;	Q ¬ MD {text[index]}, XHDisp,					c3;LBMainLoopCont:	Xbus ¬ Q LRot4, XDisp, L3 ¬ lbImplicit{/lbEsc}, BRANCH[$,LBEscape,2], c1;	rCacheObj ¬ LRot1 Q, rhCacheObj ¬ uLBCacheHi, CANCELBR[$,7],	c2;	Q ¬ uLBCacheLo,							c3;LBMapCache:	Map ¬ Q ¬ [rhCacheObj, rCacheObj + Q], CarryBr,			c1;	rCacheObj ¬ rhCacheObj + 1, LOOPHOLE[byteTiming], BRANCH[LBMapCacheCont,$], c2;	rhCacheObj ¬ rCacheObj LRot0, rCacheObj ¬ 0, GOTO[LBMapCache],	c3;LBMapCacheCont:	rhCacheObj ¬ rCacheObj ¬ MD,					c3;	MAR ¬ rCacheObj ¬ [rhCacheObj, Q + 0],				c1;	Q ¬ uLBFont, L4 ¬ lbPS,						c2;	Q ¬ Q xor MD {tokenClass/font}, XHDisp, L7Disp,			c3;LBCheckFont:	[] ¬ Q and u3FFF, NZeroBr, DISP4[LBCheckImplicitSp,6],		c1;	rhLBFlags ¬ Q LRot4, BRANCH[LBCheckMargin,LBInvalidPropsExit],	c2, at[6,10,LBCheckImplicitSp];	rhLBFlags ¬ Q LRot4, BRANCH[LBCheckMargin,LBInvalidPropsExit],	c2, at[0E,10,LBCheckImplicitSp];	rhLBFlags ¬ Q LRot4, BRANCH[LBCheckMargin,LBInvalidPropsExit],	c2, at[0F,10,LBCheckImplicitSp];	rhLBFlags ¬ Q LRot4, BRANCH[$,LBSaveBreakInvProps],		c2, at[7,10,LBCheckImplicitSp];	Q ¬ rSpCount or suffixSpace, rhSuffixChar ¬ suffixSpace, CALL[LBSaveBreak], c3;LBSaveBreakInvProps:	Q ¬ rSpCount or suffixSpace, rhSuffixChar ¬ suffixSpace,	c3;	uLBPMicaLength ¬ rMicaLength, L3 ¬ lbInvProps, CALL[LBSaveBreakCont], c1;	GOTO[LBCheckMarginCont],					c3, at[lbImplicit,4,LBPrcSpRet];LBCheckMargin:	Noop,								c3;LBCheckMarginCont:	MAR ¬ [rhCacheObj, rCacheObj + 1],				c1;	CANCELBR[$,2],							c2;	Q ¬ MD {wordMetrics.micaLength},				c3;	rMicaLength ¬ rMicaLength + Q, L5Disp,				c1;	[] ¬ rMicaLength - rMargin - 1, CarryBr, DISP4[LBCheckClass,3], c2;	Xbus ¬ rhLBFlags, XDisp, BRANCH[LBUpdateMetrics,LBHyphenate],	c3, at[classSpace,10,LBCheckClass];	Xbus ¬ rhLBFlags, XDisp, BRANCH[LBUpdateMetrics,LBHyphenate],	c3, at[classPuncNoSpaceBefore,10,LBCheckClass];	Xbus ¬ rhLBFlags, XDisp, BRANCH[LBUpdateMetrics,LBHyphenate],	c3, at[classPuncSpaceBefore,10,LBCheckClass];	Xbus ¬ rhLBFlags, XDisp, BRANCH[LBCheckContiguous,LBUnableToBreakExit], c3, at[classWord,10,LBCheckClass];LBUpdateMetrics:	MAR ¬ [rhCacheObj, rCacheObj + 3], Xbus ¬ 3, XDisp, L5 ¬ 3{/7/B/F}, DISP4[LBCopyClass,3], c1;LBCheckContiguous:	MAR ¬ [rhCacheObj, rCacheObj + 3], L5 ¬ 3{/7/B/F}, DISP4[LBCopyClass,3], c1;	CANCELBR[LBUpdateMetricsCont,3],				c2, at[classSpace,10,LBCopyClass];	CANCELBR[LBUpdateMetricsCont,3],				c2, at[classPuncNoSpaceBefore,10,LBCopyClass];	CANCELBR[LBUpdateMetricsCont,3],				c2, at[classPuncSpaceBefore,10,LBCopyClass];	BRANCH[LBContiguousExit,LBUpdateMetricsCont,2],			c2, at[classWord,10,LBCopyClass];LBUpdateMetricsCont:	Q ¬ MD {wordMetrics.byteCount},					c3;	MAR ¬ [rhCacheObj, rCacheObj + 2],				c1;	rByteCount ¬ rByteCount + Q, CANCELBR[$,2],			c2;	Q ¬ MD {wordMetrics.pixelLength},				c3;	rBitLength ¬ rBitLength + Q,					c1;	Noop,								c2;	rCtMinusIx ¬ rCtMinusIx - 1, ZeroBr, L7 ¬ inhibitImplicitSpaceFALSE, GOTO[LBMainLoop], c3, at[lbEsc,4,LBPrcSpRet];LBEscape:	L4 ¬ lbPS{/lb0wS/...}, DISP4[LBEsc,escapeSpace],		c2;	L7Disp, GOTO[LBEscSpace],					c3, at[escapeSpace,10,LBEsc];	Q ¬ rSpCount or suffixZeroWidthSpace, rhSuffixChar ¬ suffixZeroWidthSpace, CALL[LBSaveBreak], c3, at[escapeZeroWidthSpace,10,LBEsc];	rReason ¬ reasonChangeBase, GOTO[LBExit],			c3, at[escapeChangeBase,10,LBEsc];	rReason ¬ reasonBreakPoint, GOTO[LBExit],			c3, at[escapeBreakPoint,10,LBEsc];	rReason ¬ reasonSoftHyphen, GOTO[LBExit],			c3, at[escapeSoftHyphen,10,LBEsc];	rCtMinusIx ¬ rCtMinusIx - 1, ZeroBr, L7 ¬ inhibitImplicitSpaceTRUE, c3, at[escapeInhibitImplicitSpace,10,LBEsc];	MAR ¬ rTextReal ¬ [rhTextReal, rTextReal + 1], BRANCH[LBMainRead,LBNormalExit], c1;LBEscSpace:	BRANCH[LBEscSpCont,$,7],					c1;	GOTO[LBMainLoopTest],						c2;LBEscSpCont:	Noop,								c2;	Q ¬ rSpCount or suffixSpace, rhSuffixChar ¬ suffixSpace, CALL[LBSaveBreak], c3;	L5 ¬ classSpace,						c2, at[lb0wS,10,LBSvBkRet];LBMainLoopTest:	rCtMinusIx ¬ rCtMinusIx - 1, ZeroBr, L7 ¬ inhibitImplicitSpaceFALSE, GOTO[LBMainLoop], c3;LBHyphenate:	MAR ¬ [rhCacheObj, rCacheObj + 4], L2Disp, CANCELBR[$,0C],	c1;	rMicaLength ¬ rMicaLength - Q, NegBr, BRANCH[LBNoHyphen,$,2],	c2;	rhTT ¬ MD {breakPointCount}, BRANCH[$,LBDontRehyphenate],	c3;	rSylCount ¬ rhTT, ZeroBr, L2 ¬ 1,				c1;	Q ¬ uLBPWhiteSpace, BRANCH[$,LBNoSylables],			c2;	rMinWidth ¬ rMargin - Q,					c3;	Q ¬ uLBPMicaLength,						c1;	[] ¬ Q - rMinWidth, CarryBr,					c2;	rMinWidth ¬ rMargin, BRANCH[$,LBCheckBigToken],			c3;	MAR ¬ rCacheObj ¬ [rhCacheObj, rCacheObj + 5], L4 ¬ lbHHyp,	c1;	rMinWidth ¬ rMinWidth - rWhiteSpace, CANCELBR[$,2],		c2;LBSylableLoop:	rSylType ¬ MD {thisSylable.type}, XHDisp, BRANCH[$,LBSylLoopEnd], c3;	MAR ¬ [rhCacheObj, rCacheObj + 1], BRANCH[$,LBSpecialGermanExit,2], c1;	rSylType ¬ rSylType LRot8, CANCELBR[$,2],			c2;	Q ¬ MD {thisSylable.micaLength},				c3;	Q ¬ rMicaLength + Q,						c1;	[] ¬ rMargin - Q, CarryBr,					c2;	[] ¬ rSylType and 0F, ZeroBr, BRANCH[LBSkipSyl,$],		c3;	[] ¬ rFit - Q, NegBr, L2Disp, BRANCH[$,LBFoundHard],		c1;	[] ¬ Q - rMinWidth, CarryBr, BRANCH[$,LBSaveSyl],		c2;	BRANCH[LBNextSyl,LBFoundFit],					c3;LBSaveSyl:	uLBPendSyl ¬ rCacheObj, rFit ¬ Q, L2 ¬ 0, BRANCH[$,LBFoundFit], c3;LBNextSyl:	MAR ¬ rCacheObj ¬ [rhCacheObj, rCacheObj + 3], GOTO[LBNextSylable], c1;LBSkipSyl:	MAR ¬ rCacheObj ¬ [rhCacheObj, rCacheObj + 3], CANCELBR[$,1],	c1;LBNextSylable:	rSylCount ¬ rSylCount - 1, ZeroBr, CANCELBR[LBSylableLoop,2],	c2;LBSylLoopEnd:	Q ¬ rFit, L2Disp, CANCELBR[$,3],				c1;	rCacheObj ¬ uLBPendSyl, BRANCH[LBFoundSyl,$],			c2;	GOTO[LBCheckBigToken],						c3;LBFoundSyl:	Noop,								c3;LBFoundFit:	L4 ¬ lbHyp,							c1;	rhSuffixChar ¬ suffixHyphen, GOTO[LBHyphenateOK],		c2;LBFoundHard:	rhSuffixChar ¬ suffixHardHyphen, CANCELBR[$,1],			c2;LBHyphenateOK:	rMicaLength ¬ Q, L5 ¬ classWord,				c3;	MAR ¬ [rhCacheObj, rCacheObj + 0],				c1;	rSylByteCount ¬ 0FF,						c2;	rSylByteCount ¬ rSylByteCount and MD {thisSylable.byteCount},	c3;	MAR ¬ [rhCacheObj, rCacheObj + 2],	 			c1;	rByteCount ¬ rByteCount + rSylByteCount, CANCELBR[$,2],		c2;	rSylBitLength ¬ MD {thisSylable.pixelLength},			c3;	rBitLength ¬ rBitLength + rSylBitLength,			c1;	Q ¬ rSpCount or rhSuffixChar,					c2;	CALL[LBSaveBreak],						c3;	Q ¬ rhLBHyphenPL, GOTO[LBComputeBackup],			c2, at[lbHyp,10,LBSvBkRet];	Q ¬ 0,								c2, at[lbHHyp,10,LBSvBkRet];LBComputeBackup:	rTotSpace ¬ 0,							c3;	MAR ¬ [rhCacheObj, rCacheObj + 1],				c1;	rBitLength ¬ Q - rSylBitLength, CANCELBR[$,2],			c2;	rMicaLength ¬ MD {thisSylable.micaLength},			c3;	rSpCount ¬ 0, rhSuffixChar ¬ suffixNull,			c1;	rArgReal ¬ uLBArgRealLo,					c2;	rhArgReal ¬ uLBArgRealHi,					c3;	MAR ¬ [rhArgReal, rArgReal + 9], L4Disp,			c1;	rByteCount ¬ - rSylByteCount, BRANCH[$,LBBackupHard,2],		c2;	Q ¬ MD {hyphenMicaLength}, GOTO[LBFinishBackup],		c3;LBBackupHard:	Q ¬ 0,								c3;LBFinishBackup:	rMicaLength ¬ Q - rMicaLength, L5 ¬ classSpace,			c1;	rWhiteSpace ¬ 0, L7 ¬ inhibitImplicitSpaceTRUE,			c2;{ code removed per MPalandri request	[] ¬ Q xor uLBPMicaLength, ZeroBr,				c3;	MAR ¬ [rhArgReal, rArgReal + 0E], BRANCH[$,LBSameBreakAsPrev],	c1;	MDR ¬ rMicaLength {final.micaLength}, LOOPHOLE[wok],	  rReason ¬ reasonMargin, CANCELBR[LBStoreFinalCont1,2],	c2;LBSameBreakAsPrev:	rReason ¬ reasonUnableToBreak, CANCELBR[LBRestoreRegs,3],	c2;}	rReason ¬ reasonMargin, GOTO[LBStoreFinalCont],			c3;LBDontRehyphenate:	rReason ¬ reasonUnableToBreak,					c1;	GOTO[LBRestoreRegs],						c2;LBNoSylables:	GOTO[LBCheckBigToken],						c3;LBNoHyphen:	CANCELBR[LBCheckBigToken],					c3;LBCheckBigToken:	[] ¬ uLBPMicaLength, ZeroBr,					c1;	BRANCH[LBWholeWordBreak,$],					c2;	rReason ¬ reasonOneBigToken, GOTO[LBExit],			c3;LBSimpleMarginExit:	Noop,								c2;LBWholeWordBreak:	rCtMinusIx ¬ uLBPCtMinusIx,					c3;	rMicaLength ¬ 0, L5 ¬ classSpace,				c1;	rBitLength ¬ 0, L7 ¬ inhibitImplicitSpaceTRUE,			c2;	rSpCount ¬ 0, rhSuffixChar ¬ suffixNull,			c3;	rByteCount ¬ 0,							c1;	rWhiteSpace ¬ 0,						c2;	rTotSpace ¬ 0, L1Disp,						c3;	rReason ¬ reasonMargin, BRANCH[LBStoreFinal,$],			c1;	rArgReal ¬ uLBArgRealLo,					c2;	rhArgReal ¬ uLBArgRealHi,					c3;	MAR ¬ [rhArgReal, rArgReal + 17],				c1;	rCtMinusIx ¬ uLBTextCount, CANCELBR[$,2],			c2;	Q ¬ MD, {prior.index}						c3;	Q ¬ rCtMinusIx - Q,						c1;	rCtMinusIx ¬ Q and u3FFF,					c2;	GOTO[LBStoreFinalCont],						c3;LBInvalidPropsExit:	rReason ¬ reasonInvalidProps, GOTO[LBExit],			c3, at[lbInvProps,4,LBPrcSpRet];LBContiguousExit:	rMicaLength ¬ rMicaLength - Q, 					c3;	rReason ¬ reasonContiguousWords, GOTO[LBStoreFinal],		c1;LBUnableToBreakExit:	rMicaLength ¬ rMicaLength - Q, CANCELBR[$,0C],			c1;	rReason ¬ reasonUnableToBreak, GOTO[LBExit3],			c2;LBNormalExit:	rReason ¬ reasonNormal, CANCELBR[LBExit3,3],			c2;LBSpecialGermanExit:	rReason ¬ reasonSpecialGermanCase, CANCELBR[$,3],		c2;LBExit3:	Noop,								c3;LBExit:	Noop,								c1;LBStoreFinal:	rArgReal ¬ uLBArgRealLo,					c2;	rhArgReal ¬ uLBArgRealHi,					c3;LBStoreFinalCont:	MAR ¬ [rhArgReal, rArgReal + 0E],				c1;	MDR ¬ rMicaLength {final.micaLength}, LOOPHOLE[wok], CANCELBR[$,2], c2;LBStoreFinalCont1:	Q ¬ rSpCount or rhSuffixChar, L7Disp,				c3;	MAR ¬ [rhArgReal, rArgReal + 10], BRANCH[$,LBSetInhibitFlag,7],	c1;	MDR ¬ rBitLength {final.pixelLength}, LOOPHOLE[wok],	  rSpCount ¬ Q, CANCELBR[LBStoreFinalCont2,2],			c2;LBSetInhibitFlag:	MDR ¬ rBitLength {final.pixelLength}, LOOPHOLE[wok],	  rSpCount ¬ Q or inhibitImplicitSpaceTRUE, CANCELBR[$,2],	c2;LBStoreFinalCont2:	Q ¬ uLBTextCount,						c3;	MAR ¬ [rhArgReal, rArgReal + 11],				c1;	MDR ¬ rSpCount {final.count/inhibitImplicitSpace/suffixChar}, LOOPHOLE[wok], CANCELBR[$,2], c2;	Q ¬ Q - rCtMinusIx, L5Disp,					c3;	MAR ¬ [rhArgReal, rArgReal + 15], DISP4[LBStF,3],		c1;	MDR ¬ rTotSpace {final.totalSpaceMicaLength}, LOOPHOLE[wok],	  rCtMinusIx ¬ storedClassSpace, CANCELBR[LBStoreFinalCont3,2],	c2, at[classSpace,10,LBStF];	MDR ¬ rTotSpace {final.totalSpaceMicaLength}, LOOPHOLE[wok],	  rCtMinusIx ¬ storedClassPuncNoSpaceBefore, CANCELBR[LBStoreFinalCont3,2], c2, at[classPuncNoSpaceBefore,10,LBStF];	MDR ¬ rTotSpace {final.totalSpaceMicaLength}, LOOPHOLE[wok],	  rCtMinusIx ¬ storedClassPuncSpaceBefore, CANCELBR[LBStoreFinalCont3,2], c2, at[classPuncSpaceBefore,10,LBStF];	MDR ¬ rTotSpace {final.totalSpaceMicaLength}, LOOPHOLE[wok],	  rCtMinusIx ¬ storedClassWord, CANCELBR[LBStoreFinalCont3,2],	c2, at[classWord,10,LBStF];LBStoreFinalCont3:	rCtMinusIx ¬ rCtMinusIx LRot12,					c3;	MAR ¬ [rhArgReal, rArgReal + 0D],				c1;	MDR ¬ rCtMinusIx or Q {final.class/index}, LOOPHOLE[wok], CANCELBR[$,2], c2;	Q ¬ uLBTextCount,						c3;	MAR ¬ [rhArgReal, rArgReal + 12],				c1;	MDR ¬ rByteCount {final.byteCount}, LOOPHOLE[wok], CANCELBR[$,2], c2;	rCtMinusIx ¬ uLBPCtMinusIx,					c3;	MAR ¬ [rhArgReal, rArgReal + 13], L1Disp, 			c1;	MDR ¬ rWhiteSpace {final.additionalWhiteSpace}, LOOPHOLE[wok],	  BRANCH[$,LBRestoreRegs,2],					c2;	Q ¬ Q - rCtMinusIx, L6Disp,					c3;	DISP4[LBStP,3],							c1;	rCtMinusIx ¬ storedClassSpace, GOTO[LBStoreFinalCont4],		c2, at[classSpace,10,LBStP];	rCtMinusIx ¬ storedClassPuncNoSpaceBefore, GOTO[LBStoreFinalCont4], c2, at[classPuncNoSpaceBefore,10,LBStP];	rCtMinusIx ¬ storedClassPuncSpaceBefore, GOTO[LBStoreFinalCont4], c2, at[classPuncSpaceBefore,10,LBStP];	rCtMinusIx ¬ storedClassWord, GOTO[LBStoreFinalCont4],		c2, at[classWord,10,LBStP];LBStoreFinalCont4:	rCtMinusIx ¬ rCtMinusIx LRot12,					c3;	MAR ¬ [rhArgReal, rArgReal + 17],				c1;	MDR ¬ rCtMinusIx or Q {prior.class/index}, LOOPHOLE[wok], CANCELBR[$,2], c2;	Q ¬ uLBPMicaLength,						c3;	MAR ¬ [rhArgReal, rArgReal + 18],				c1;	MDR ¬ Q {prior.micaLength}, LOOPHOLE[wok], CANCELBR[$,2],	c2;	Q ¬ uLBPBitLength,						c3;	MAR ¬ [rhArgReal, rArgReal + 1A],				c1;	MDR ¬ Q {prior.pixelLength}, LOOPHOLE[wok], CANCELBR[$,2],	c2;	Q ¬ uLBPSpCount,						c3;	MAR ¬ [rhArgReal, rArgReal + 1B],				c1;	MDR ¬ Q {prior.count/suffixChar}, LOOPHOLE[wok], CANCELBR[$,2],	c2;	Q ¬ uLBPByteCount,						c3;	MAR ¬ [rhArgReal, rArgReal + 1C],				c1;	MDR ¬ Q {prior.byteCount}, LOOPHOLE[wok], CANCELBR[$,2],	c2;	Q ¬ uLBPWhiteSpace,						c3;	MAR ¬ [rhArgReal, rArgReal + 1D],				c1;	MDR ¬ Q {prior.additionalWhiteSpace}, LOOPHOLE[wok], CANCELBR[$,2], c2;	Q ¬ uLBPTotSpace,						c3;	MAR ¬ [rhArgReal, rArgReal + 1F],				c1;	MDR ¬ Q {prior.totalSpaceMicaLength}, LOOPHOLE[wok], CANCELBR[$,3], c2;LBRestoreRegs:	rInt ¬ UrInt,							c3;	L ¬ UrL,							c1;	G ¬ UrG,							c2;	PC ¬ UrPC,							c3;	rIORgn ¬ UrIORgn, GOTO[LBDone],					c1;LBFastExit:	rReason ¬ reasonNormal,						c1;LBDone:	r0100 ¬ 0FF + 1, push,						c2;	STK ¬ TOS, pop, GOTOABS[Bank1NxtInstc1],			c3;{arg record page fault}	PC ¬ PC - 1, Bank ¬ r0100 {= bank0 in low 4 bits}, push, GOTOABS[Bank1Faultc1], c3, MapDstF[L0.LineBreak];{subroutines}{LBSaveBreak: starts in c1, ends in c1, returns through L4 to LBSvBkRet  before calling, must execute Q ¬ rSpCount or rhSuffixChar (or equivalent)}LBSaveBreak:	uLBPMicaLength ¬ rMicaLength,					c1;LBSaveBreakCont:	uLBPCtMinusIx ¬ rCtMinusIx, L1 ¬ 0,				c2;	uLBPBitLength ¬ rBitLength, L5Disp,				c3;	uLBPTotSpace ¬ rTotSpace, L6 ¬ 3{/7/B/F}, DISP4[LBSvB,3],	c1;	uLBPSpCount ¬ Q, GOTO[LBSvBkCont],				c2, at[classSpace,10,LBSvB];	uLBPSpCount ¬ Q, GOTO[LBSvBkCont],				c2, at[classPuncNoSpaceBefore,10,LBSvB];	uLBPSpCount ¬ Q, GOTO[LBSvBkCont],				c2, at[classPuncSpaceBefore,10,LBSvB];	uLBPSpCount ¬ Q, GOTO[LBSvBkCont],				c2, at[classWord,10,LBSvB];LBSvBkCont:	uLBPByteCount ¬ rByteCount, L4Disp,				c3;	uLBPWhiteSpace ¬ rWhiteSpace, DISP4[LBSvBkRet],			c1;{LBProcessSpace: starts in c2 following LBSaveBreak, ends in c2, returns through L3 to LBPrcSpRet}LBProcessSpace:	rMicaLength ¬ rMicaLength + rMinSpMLength,			c2, at[lbPS,10,LBSvBkRet];	[] ¬ rMicaLength - rMargin - 1, CarryBr,			c3;	rBitLength ¬ rBitLength + rMinSpPLength, BRANCH[$,LBSimpleMarginExit], c1;	rSpCount ¬ rSpCount + spaceCountIncr, L7 ¬ inhibitImplicitSpaceTRUE, c2;	rByteCount ¬ rByteCount + 1, L5 ¬ classSpace,			c3;	rWhiteSpace ¬ rWhiteSpace + rWhiteSpaceIncr, L3Disp,		c1;	rTotSpace ¬ rTotSpace + rSpMLength, DISP2[LBPrcSpRet],		c2;{page cross handling}LBTextCross:	rCacheObj ¬ rByteCount {save in temp, since rVirtualL = rByteCount}, c3;	rVirtualL ¬ uLBTextRealLo, L3 ¬ lbTCr,				c1;	Q ¬ 0FF + 1,							c2;	rVirtualL ¬ rVirtualL + Q, CarryBr,				c3;LBTextRemap:	Map ¬ uLBTextRealLo ¬ [rhVirtualH, rVirtualL], BRANCH[$,LBUpdateHighCont], c1, at[lbTCr,10,LBUpdateHighRet];	rByteCount ¬ rCacheObj, {restore from temp}			c2;	rhTextReal ¬ rTextReal ¬ MD,					c3;	MAR ¬ rTextReal ¬ [rhTextReal, 0+0], GOTO[LBMainRead],		c1;LBUpdateHigh:	Noop,								c1;LBUpdateHighCont:	Q ¬ rhVirtualH + 1, LOOPHOLE[byteTiming], L3Disp,		c2;	rhVirtualH ¬ Q LRot0, DISP4[LBUpdateHighRet],			c3;
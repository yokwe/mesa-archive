-- File: XStream.mesa - last edit:-- AOF                 11-Dec-85 10:27:56-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  Courier USING [Description, Handle, SystemElement],  Stream USING [Handle];XStream: DEFINITIONS =  BEGIN  Object: TYPE;  Handle: TYPE = LONG POINTER TO Object;  Request: TYPE = RECORD[SELECT access: * FROM    none => [],    stream => [sH: Stream.Handle],    proc => [proc: PROC[Handle]],    deferred => [sink, source: Courier.SystemElement],    ENDCASE];  Create: PROC[Handle] RETURNS[Stream.Handle];  <<  Create gives the bulk data client a Stream.Handle on which to operate.  The  client is the owner of the representative stream until the stream is deleted  (sH.delete).  >>  Copy: PROC[sink, source: Stream.Handle];  <<  Copy is used to copy the source stream into the sink stream.  The transfer  will terminate when the source stream raises Stream.EndOfStream.  >>  Destroy: PROC[Handle];  Make: PROC[request: Request] RETURNS[handle: Handle];  <<  Destroy and Make are used by the Courier client (at a level of abstraction  below the bulk data client) to create the data structures needed to convey  the information about the stream.  >>  ServerCheckout: PROC[Courier.Handle, Request];  UserCheckout: PROC[Courier.Handle];  <<  ServerCheckout and UserCheckout are used by the Courier client to synchronize  the use of Courier's transport and to complete the information required to  initiate the transfer.  >>  AbortTransfer: PROC[Stream.Handle];  <<  In order to abort a transfer in a consistent manner, the client must call  AbortTransfer.  This operation is applicable for both the source and sink  operation clients.  After a stream is aborted, the only permissible operation  is Delete (sH.delete).  All other operations will result in ERROR ABORTED.  >>  CancelTransfer: PROC[Handle];  <<  CancelTransfer may be called in lieu of ServerCheckout should the party  find itself in a position of not being able to honor the request, such as  on a retrieve and the file does not exist.  This translates to a BulkData  Cancel operation.  >>    DescribeSink: Courier.Description;  DescribeSource: Courier.Description;  <<  Objects are not completely formed when they are created.  They are completed  as access to them unfolds.  In particular, an object is not typed as a sink  or source until it is (de)serialized.  Consequently, only generic Handles are  included as procedure call arguments.  Before they are (de)serialized, they  do not represent streams.  They are translated to streams by the client  supplied procedures contained in the XStream.Request via the XStream.Create  procedure.  Immediate requests don't require the remote's address be known.  There is  no need to have that information since it's available (and implicit) from  the Courier connection.  Objects are created by the client ostensibly for the use with a single remote  procedure call.  An object may be used at most once.  The object must be  deleted after the call for which it was created.   The streams utilized for immediate transfers are variants of Pilot byte streams  (i.e., Stream.Handle) with these restrictions:  o There is only one stream per remote procedure call.  o The stream is simplex, i.e., transfers data in only one direction.  o SSTs are not supported.  The stream's SetSST and GetSST routines result    in ERROR Stream.InvalidOperation.  The implementation will never raise the    signal Stream.SSTChange.  o Attentions not are supported.  The stream's SendAttention and WaitAttenion    routines will raise ERROR Stream.InvalidOperation.  The implementation will    never raise the signal Stream.Attention.  o If a stream is created by a bulk data client within the XStream.Request    callback procedure, then that stream is owned by that client.  Normal    termination of the transfer of data by the source client is signalled    by deleting the stream (sH.delete).  Normal termination is relayed to    the sink client in the form of a Stream.EndOfStream status or signal.  o Clients may provide streams to be used as Bulk Data sources or sinks.  o Client sink streams will not be required to process any signals.  The status    of the transfer will be implied from the results of the remote procedure    call.  The client then has the responsibility for the stream.  o Client source streams signal must signal Stream.EndOfStream to indicate the    end of the transfer.  o Streams may be truncated indicating some sort of transfer error.  This is    done by using calling XStream.AbortTransfer which will resort in ERROR    ABORTED being raised on the other end of the stream.    >>      END. LOG  ( date - person - action ) 2-Jun-85 12:47:20  AOF  Created file
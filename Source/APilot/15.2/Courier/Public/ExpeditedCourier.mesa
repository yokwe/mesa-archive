-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- ExpeditedCourier.mesa - (last edited by AOF  27-Dec-84 18:37:31)<<This defines three major portions of expedited Courier calling: 	1) Expanding ring broadcast in two flavors (race vs find all).	2) Normal expedited Courier Procedure calling. 	3) Server expedited Courier Program dispatching on a (well known) socket.>>DIRECTORY  Courier USING [Description, nullParameters, Parameters, VersionRange],  CourierProtocol USING [Protocol3Body, ProtocolRange],  Environment USING [Block],  Heap USING [Handle],  PacketExchange USING [WaitTime],  Router USING [infinity],  Stream USING [Handle],  System USING [NetworkAddress, SocketNumber];ExpeditedCourier: DEFINITIONS =  BEGIN    Header: TYPE = MACHINE DEPENDENT RECORD [    protRange: CourierProtocol.ProtocolRange ¬ [protocol3, protocol3],    body: CourierProtocol.Protocol3Body];    -- some very useful utilities  DescribeHeader: Courier.Description;  normalReturnHeader: Header = [body: [return[0]]];  MakeAbortedHeader: PROCEDURE[remoteSignalNumber: CARDINAL]    RETURNS [h: Header] =     INLINE { h ¬ [body: [abort[0, remoteSignalNumber]]] };  DeserializeFromBlock: PROCEDURE [    parms: Courier.Parameters, heap: Heap.Handle, blk: Environment.Block]    RETURNS [succeeded: BOOLEAN];    <<    Given a block, this routine tries to deserialize the block according to     parms.  If succeeded is TRUE, then the user is responsible for any storage    that may have been allocated by the Deserialization.    In theory, this procedure produces no SIGNAL.    >>      Hop: TYPE = [0..Router.infinity];  -- distance to a network on the internet.    RingBound: TYPE = RECORD [low: Hop, high: Hop] ¬ [FIRST[Hop], LAST[Hop]];    ExpandingRingAction: TYPE = {    findMostServersInShortTime, reliablyFindAllServers };    <<    These actions are very different.    "findMostServersInShortTime" means that packets are sent in an orderly,    short time-delayed  sequence so that the client can see the responses    from most servers that answered.    "reliablyFindAllServers" sends a larger number of broadcasts to each    net before moving to the next one.  The delays between packets are much    longer than the "findMostServersInShortTime" case.    >>    ElapsedTime: TYPE = PacketExchange.WaitTime; -- LONG CARDINAL in milliseconds    ResponseProc: TYPE = PROCEDURE [    hopsToResponder: Hop,    elapsedTime: ElapsedTime,  -- set before sending the first packet.    header: Header,     serializedResponse: Environment.Block] RETURNS [continue: BOOLEAN];    <<    When the client is called back via a ResponseProc, the header has been     checked and it makes sense;  client need not do sanity checking on the    header.    >>    NewRadiusNotifyProc: TYPE = PROCEDURE [    newRingRadius: Hop ] RETURNS [continue: BOOLEAN];    <<    The user is notified that the ring is being expanded to "ringRadius"    hops.  By returning continue=FALSE, the user may stop the expanding ring    call.    WARNING: The process that calls this procedure is FORKed.  The user    should not raise any SIGNALs in this callback routine.    >>     CallToInternetRing: PROCEDURE [    programNumber: LONG CARDINAL, versionNumber: CARDINAL,    procedureNumber: CARDINAL,    arguments: Courier.Parameters ¬ Courier.nullParameters,    ring: RingBound,    socket: System.SocketNumber,    action: ExpandingRingAction,    eachResponse: ResponseProc,    newRadiusNotify: NewRadiusNotifyProc ¬ NIL,    responseBufferCount: CARDINAL ¬ 5 ];    <<    If the client does know how to specify the first four parameters then    s/he has no business in this interface.    This procedure sends broadcast expedited Courier packets to each network    located in the specified "ring";  the destination socket of these     broadcast packets is specified by "socket".  "action" has been defined    above.  For each valid response from the server in the ring, "eachResponse"    is called.  "responseBufferCount" is important; it reflects the     implementation details of the NS sockets in Pilot.  Pilot will queue up    to "responseBufferCount" buffers for the client.  If the client     cannot consume buffers as fast as they come in then Pilot will    toss any buffers that would cause the buffer queue size to exceed    "responseBufferCount".         THIS PROCEDURE IS VERY EXPENSIVE.  If it is used often, then the client    is doing something wrong.        NOTES and WARNINGS:    1) "arguments" are serialized into an NS buffer of limited size;  the     implementation does NOT catch any errors associated with serialization    of "arguments".  The client should not cause such errors or catch      a) Courier.Error, b) MemoryStream.IndexOutOfRange, and      c) ByteBlt.StartIndexGreaterThanStopIndexPlusOne.    2) There is no duplicate suppression.  The client should expect multiple    answers from any server.    3) You do not get to specifiy the timeout.  You do get elapsed    time since the first packet was sent.    >>    DirectedBroadcastCall: PROCEDURE [    programNumber: LONG CARDINAL, versionNumber: CARDINAL,    procedureNumber: CARDINAL,    arguments: Courier.Parameters,    address: System.NetworkAddress,    action: ExpeditedCourier.ExpandingRingAction,    eachResponse: ExpeditedCourier.ResponseProc,    responseBufferCount: CARDINAL ¬ 5 ];    <<    This is like CallToInternetRing except that the ring and socket    parameters have been replaced with address.  The network and    socket portions of address have been filled in by the client.    >>    Call: PROCEDURE [    programNumber: LONG CARDINAL, versionNumber: CARDINAL,    procedureNumber: CARDINAL,    arguments: Courier.Parameters ¬ Courier.nullParameters,    address: System.NetworkAddress,    response: ResponseProc ]; -- returned boolean is ignored    <<    You know by now what this does. Same NOTES and WARNINGS of    CallToInternetRing apply to this procedure.    >>    CallToAddresses: PROCEDURE [    programNumber: LONG CARDINAL, versionNumber: CARDINAL,    procedureNumber: CARDINAL,    arguments: Courier.Parameters ¬ Courier.nullParameters,    socket: System.SocketNumber,    addresses: AddrList,    response: ResponseProc,    responseBufferCount: CARDINAL ¬ 5 ];    <<    Calls to each system element on the addresses list in a    "findMostServersInShortTime" fashion.    >>    AddrList: TYPE = LONG POINTER TO AddrObject;    AddrObject: TYPE = RECORD [    next: AddrList,    address: System.NetworkAddress ];      -- Server Routines;  not exactly obvious, but ....    GetDefaultSocketNumber: PROCEDURE RETURNS [System.SocketNumber];    DispatcherProc: TYPE = PROCEDURE [    programNumber: LONG CARDINAL, version: CARDINAL,    procedureNumber: CARDINAL,    serializedRequest: Environment.Block,    replyMemoryStream: Stream.Handle,    callWasABroadcast: BOOLEAN ] RETURNS [sendReply: BOOLEAN];    <<    WARNING: The current impl cannot determine the value of callWasABroadcast!    anonymous processes call procedures of this type provided by the client via    RegisterExpeditedService.    Courier program implementors know how to use the first three parameters.    "serializedRequest" contains the parameters of the expedited call.    The results of the call should be streamed into "replyMemoryStream".      The client must catch any errors that may occur while serializing    the results into (the limited sized) "replyMemoryStream".  Remember to call    SerializeHeader before serializing results.  The BOOLEAN "callWasABroadcast"    is important since a server may not want to answer a broadcast if the    answer happens to be an error condition.        WARNING (implementation detail):  "serializedRequest" and the block under    "replyMemoryStream" overlap!  So the client should do ALL deserialization    of  "serializedRequest" before doing ANY serialization to    to "replyMemoryStream".    >>    SerializeHeader: PROCEDURE [rmsH: Stream.Handle, header: Header];  <<    "rmsH" is the replyMemoryStream that the client received via DispatcherProc.    This procedure should always be called before the client serializes    any program dependent results on the stream!    This procedure will raise no errors (when used as specified).    >>     Services: TYPE = LONG DESCRIPTOR FOR ARRAY OF Service;    Service: TYPE = RECORD [    programNumber: LONG CARDINAL, versionRange: Courier.VersionRange,    bindRequestProcedure: CARDINAL,    dispatcher: DispatcherProc];    <<    the dispatcher is capable of filtering out retransmitted packets that     are being processed by the client.  Server implementors may still want to    see all "bindRequest" packets even if they are duplicates.    >>    ExpeditedServiceHandle: TYPE [2];    ExportExpeditedPrograms: PROCEDURE [    services: Services, socket: System.SocketNumber]    RETURNS [h: ExpeditedServiceHandle];    <<    The storage associated with services may be destroyed after calling    this procedure.    >>    UnexportExpeditedPrograms: PROCEDURE [h: ExpeditedServiceHandle];   --h is no longer valid after calling this procedure.    <<  Suggested conventions for implementing expedited services:  1) The "remote procedure" that implements the expanding ring broadcast  "server/service" location replier should be numbered 0.  2) That "server/service" location replier routines should know about  the remote client's ExpandingRingAction.  If the remote client is running  a race and this server is not eager to be found, then this server should  pause for some amount of time (depending on the uneagerness) before  replying;  this is required because the remote client has a limited number of  buffers and these buffers should not be wasted on "uneager replies".  >>        END..  LOG-- created by BLyon, 14-Nov-82 16:27:20-- Changes for NS, BRD, 17-Jan-83 19:17:05-- Changes for NS (Klamath), SMA 11-Apr-83 10:58:22-- changed Hop to [0..Router.infinity], read, 11-Nov-83 18:37:22-- Gunned refs to NSFriends interfaces, AOF, 14-Dec-84  9:58:39
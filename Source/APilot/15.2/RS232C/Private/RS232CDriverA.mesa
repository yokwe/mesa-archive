-- File: RS232CDriverA.mesa - last edit:-- JPM                  3-May-91 11:29:28-- Copyright (C) 1984, 1985, 1987, 1991 by Xerox Corporation. All rights reserved. -- This is the Monitor for RS232C Channel creation/deletionDIRECTORY  Heap USING [FreeNode, MakeNode],  Process USING [InitializeMonitor],  RS232C USING [CommParamHandle, nullLineNumber, ReserveType, Suspend],  RS232CControl USING [],  RS232CFace USING [GetNextLine, GetStatus, Off, On, ParameterRecord, ResetLine],  RS232CInternal USING [    asynchronousDefaults, autoRecognitionDefaults, bitSynchronousDefaults,    byteSynchronousDefaults, ChannelStatus, ChannelStatusHandle, DeleteChannel],  RS232CPrivate USING [];RS232CDriverA: MONITOR  IMPORTS Heap, Process, RS232CFace, RS232CInternal, RS232C  EXPORTS RS232C, RS232CControl, RS232CPrivate =  BEGIN  ChannelHandle: PUBLIC TYPE = RS232CInternal.ChannelStatusHandle;  firstChannel: ChannelHandle ¬ NIL;  channelCreateDelete: CONDITION;  driverStarted: BOOLEAN ¬ TRUE;  ChannelAlreadyExists: PUBLIC ERROR = CODE;  ChannelInUse: PUBLIC ERROR = CODE;  InvalidLineNumber: PUBLIC ERROR = CODE;  NoRS232CHardware: PUBLIC ERROR = CODE;  UnimplementedFeature: PUBLIC ERROR = CODE;  doDebug: BOOLEAN = FALSE;  --TRUE when in system test, else FALSE.  --                                  Old Channel Owner's preemptMe  --                                Never     If Inactive   Always  --   New           Never          Don't        Don't      Don't  -- preempt-    if Inactive        Don't       Preempt    Preempt  --  Others        Always          Don't       Preempt    Preempt  Create: PUBLIC ENTRY PROCEDURE [    lineNumber: CARDINAL, commParams: RS232C.CommParamHandle,    preemptOthers, preemptMe: RS232C.ReserveType]    RETURNS [channel: ChannelHandle] =    BEGIN    ENABLE UNWIND => IF channel # NIL THEN FreeChannelHandle[channel];    nextLine: CARDINAL ¬ RS232C.nullLineNumber;    prevChannel: ChannelHandle;    channel ¬ NIL;    IF ~driverStarted OR RS232CFace.GetNextLine[nextLine] = nextLine THEN      IF doDebug THEN ERROR NoRS232CHardware      ELSE RETURN WITH ERROR NoRS232CHardware;  -- release monitor lock.    -- Check if line number valid    UNTIL (nextLine ¬ RS232CFace.GetNextLine[nextLine]) = RS232C.nullLineNumber      DO      IF nextLine = lineNumber THEN EXIT;      REPEAT FINISHED =>         IF doDebug THEN ERROR InvalidLineNumber        ELSE RETURN WITH ERROR InvalidLineNumber; -- release monitor lock.      ENDLOOP;    -- If others in process of preempting, wait for them to finish    UNTIL (prevChannel ¬ GetChannelHandle[lineNumber]) = NIL      OR ~prevChannel.preemptInProgress DO WAIT channelCreateDelete; ENDLOOP;    IF ~driverStarted THEN       IF doDebug THEN ERROR NoRS232CHardware      ELSE RETURN WITH ERROR NoRS232CHardware;  -- release monitor lock.    IF prevChannel # NIL THEN      BEGIN      preempt: BOOLEAN ¬ FALSE;      SELECT preemptOthers FROM        preemptNever => NULL;  -- fail        preemptInactive =>          SELECT prevChannel.lastPreemptMe FROM            preemptInactive =>  -- if inactive, delete the old channel              IF ~RS232CFace.GetStatus[prevChannel.face].dataSetReady OR	        ~prevChannel.parameterRecord.dataTerminalReady THEN                  preempt ¬ TRUE;            preemptAlways => preempt ¬ TRUE;            ENDCASE => NULL;  --fail        preemptAlways =>          IF prevChannel.lastPreemptMe # preemptNever THEN preempt ¬ TRUE;        ENDCASE;      IF preempt THEN        BEGIN        ENABLE UNWIND => prevChannel.preemptInProgress ¬ FALSE;        -- Give channel client a STRONG HINT to delete the channel at once.        prevChannel.preemptInProgress ¬ TRUE;        RS232C.Suspend[prevChannel, all];        UNTIL prevChannel.deleted DO WAIT channelCreateDelete ENDLOOP;        prevChannel.preemptInProgress ¬ FALSE;        END      ELSE IF doDebug THEN ERROR ChannelInUse           ELSE RETURN WITH ERROR ChannelInUse;  -- release monitor lock.      -- Copy previously used channel handle so we don't allocate a       -- second one later      channel ¬ prevChannel;      END;    -- Allocate and initialize a ChannelStatus record    IF ~driverStarted THEN      IF doDebug THEN ERROR NoRS232CHardware      ELSE RETURN WITH ERROR NoRS232CHardware;  -- release monitor lock.    IF channel = NIL THEN      BEGIN  -- Allocate channel handle and add it to queue of channel handles      channel ¬ Heap.MakeNode[, SIZE[RS232CInternal.ChannelStatus]];      channel.next ¬ firstChannel;      firstChannel ¬ channel;      END;    -- set preemptInProgress first so any SIGNALS handle correctly    channel.preemptInProgress ¬ FALSE;    Process.InitializeMonitor[@channel.LOCK];    channel.parameterRecord ¬      SELECT commParams.lineType FROM        bitSynchronous => RS232CInternal.bitSynchronousDefaults,        byteSynchronous => RS232CInternal.byteSynchronousDefaults,        asynchronous => RS232CInternal.asynchronousDefaults,        autoRecognition => RS232CInternal.autoRecognitionDefaults,        ENDCASE => ERROR;  -- This should be logged as a system error.    channel.parameterRecord.lineSpeed ¬ commParams.lineSpeed;    channel.inputSuspended ¬ channel.outputSuspended ¬ channel.otherSuspended ¬      channel.deleted ¬ FALSE;    channel.lastPreemptMe ¬ preemptMe;    channel.lineNumber ¬ lineNumber;    channel.statusWaitCount ¬ 0;    channel.face ¬ RS232CFace.On[lineNumber];    IF RS232CFace.ResetLine[channel.face, @channel.parameterRecord] # success      THEN      BEGIN      RS232CFace.Off[channel.face];      -- (e.g. autoRecognition)      ERROR UnimplementedFeature;      END;    BROADCAST channelCreateDelete;    END;  Delete: PUBLIC PROCEDURE [channel: ChannelHandle] =    BEGIN    -- Client is responsible for avoiding the passing of an OLD channel handle.    RS232CInternal.DeleteChannel[channel];    -- modify/release channel status record under object monitor    RS232CFace.Off[channel.face];    -- Release block to heap (cannot be done in DeleteChannel,    -- since the MONITOR LOCK, which is in channel record, must still    -- exist to be released at exit from DeleteChannel)    GetLockAndFreeChannelHandle[channel];    END;  GetNextLine: PUBLIC PROCEDURE [lineNumber: CARDINAL]    RETURNS [nextLineNumber: CARDINAL] =    BEGIN RETURN[RS232CFace.GetNextLine[lineNumber]]; END;  GetChannelHandle: INTERNAL PROCEDURE [lineNumber: CARDINAL]    RETURNS [channel: ChannelHandle] =    BEGIN    channel ¬ firstChannel;    FOR channel ¬ firstChannel, channel.next UNTIL channel = NIL DO      IF channel.lineNumber = lineNumber THEN EXIT;      ENDLOOP;    END;  Start: PUBLIC ENTRY PROCEDURE = BEGIN driverStarted ¬ TRUE END;    Stop: PUBLIC ENTRY PROCEDURE [suspendActiveChannels: BOOLEAN] =    BEGIN    channel: ChannelHandle ¬ NIL;    driverStarted ¬ FALSE;    IF suspendActiveChannels THEN      FOR channel ¬ firstChannel, channel.next UNTIL channel = NIL DO        RS232C.Suspend[channel, all];	ENDLOOP;    UNTIL firstChannel = NIL DO WAIT channelCreateDelete ENDLOOP;    END;      FindChannel: PUBLIC ENTRY PROCEDURE [dialerNumber: CARDINAL] RETURNS [channel: ChannelHandle] =  BEGIN    tempChannel: ChannelHandle ¬ firstChannel;       IF tempChannel = NIL THEN RETURN[NIL];          WHILE tempChannel.lineNumber # dialerNumber DO	tempChannel ¬ tempChannel.next;	IF tempChannel = NIL THEN EXIT;      ENDLOOP;      RETURN[tempChannel];  END;    GetParameters: PUBLIC PROCEDURE [channel: ChannelHandle] RETURNS [parameters: RS232CFace.ParameterRecord] =  BEGIN    RETURN[channel.parameterRecord]  END;    GetLockAndFreeChannelHandle: ENTRY PROCEDURE [channel: ChannelHandle] =    BEGIN    ENABLE UNWIND => NULL;    FreeChannelHandle[channel];    END;    FreeChannelHandle: INTERNAL PROCEDURE [channel: ChannelHandle] =    BEGIN    IF channel.preemptInProgress THEN channel.deleted ¬ TRUE    ELSE      BEGIN      prevChannel: ChannelHandle ¬ firstChannel;      IF prevChannel = channel THEN firstChannel ¬ channel.next      ELSE        BEGIN        UNTIL prevChannel.next = channel DO          prevChannel ¬ prevChannel.next ENDLOOP;        prevChannel.next ¬ channel.next;        END;      Heap.FreeNode[, channel];      END;    BROADCAST channelCreateDelete;    END;  -- MAIN PROGRAM --  END. -- RS232CDriverALOG			 Trinity release28-Jun-82 11:28:00  BRD  Remove OISTransporter stuff27-Apr-83 15:46:35  SMA  RETURN WITH ERROR to release monitor lock. 1-Jul-83 14:57:16  SMA  remove ref to CommFlags.11-Jan-84 17:10:38  SMA  doDebug ¬ FALSE (exiting system test soon)29-Oct-85 12:04:34  JAV  added FindChannel exported by RS232CPrivate15-Jan-87 16:29:53  JAV  changed GetLineType to GetParameters to return all channel parameters29-Jan-87 17:53:38  JAV  made an active port be a port that has both DSR and DTR high 3-May-91 11:29:28	JPM	In Create, raise ERROR UnimplementedFeature directly (so that UNWIND catch phrase is enabled)
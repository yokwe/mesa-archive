-- File: RS232CSubDriver.mesa - last edit:-- GRG/RSV	       18-Oct-91 17:08:57-- GRG 		       20-Aug-90 13:53:03 Fix for SPAR 219.  -- BKI                 11-Jan-88 14:57:29-- AOF                 15-Oct-87 19:51:11-- Copyright (C) 1984, 1985, 1987, 1988, 1991 by Xerox Corporation. All rights reserved.<<This MONITOR is a machine-independent implementation of nominally driver-likefunctions which are underneath the current RS-232-C Face. It is hoped that thesefunctions may eventually be incorporated into the RS-232-C driver, and that allmachine-dependent heads would then implement a new interface (herein referred toas NewRS232CFace).>>DIRECTORY  ByteBlt USING [ByteBlt],  Environment USING [Block, Byte, wordsPerPage],  Heap USING [Create, Delete],  NewRS232CFace USING [    Command, CommandStatus, CompletedTransferStatus, DeviceStatus,    GetDeviceStatus, GetHandle, GetNextLine, Handle, Initialize,    InitializeCleanup, InitiateCommand, InitiateReceive, InitiateTransmit,     InitiateResetStatusBits, InitiateSetControlBits, InitiateSetParameters,    IsReviveProcNeeded, nilHandle, Operation, OperationPtr, operationAlignment,    operationLocation, operationSize, ParameterRecord, ParameterStatus,    PollCommand, PollReceiveOrTransmit, PollResetStatusBits,    PollSetControlBits, PollSetParameters, QueueIsBad, ReleaseHandle,    ReviveInputQueue, TransferStatus],  Process USING [    Abort, EnableAborts, InitializeCondition, MsecToTicks,    Pause, Priority, SecondsToTicks, SetPriority, Ticks],  ProcessPriorities USING [priorityRS232C],  ResidentHeap USING [first64K, FreeNode, MakeNode],  RS232CCorrespondents USING [illegal],  RS232CEnvironment USING [    AutoRecognitionOutcome, PhysicalRecord, PhysicalRecordHandle],  RS232CFace USING [    AbortType, DeviceStatus, Handle, Object, ParamHandle, ParameterOutcome,    TransferStatus],  SpecialHeap USING [MakeResident, MakeSwappable],  SpecialRuntime USING [AllocateNakedCondition, DeallocateNakedCondition],  Zone USING [Base, Status];RS232CSubDriver: MONITOR LOCKS root  IMPORTS    ByteBlt, Heap, NewRS232CFace, Process, ResidentHeap, SpecialHeap,    SpecialRuntime  EXPORTS RS232CFace, RS232CEnvironment =  BEGIN  root: PUBLIC MONITORLOCK;  -- PUBLIC TYPE for RS232CEnvironment  CompletionHandle: PUBLIC TYPE = LONG POINTER TO CompletionRecord;    CompletionRecord: TYPE = RECORD  [ operation: Zone.Base RELATIVE POINTER TO NewRS232CFace.Operation,    direction: {receive, transmit}, -- Will proably go away.    status: NewRS232CFace.TransferStatus,    physicalRecord: RS232CEnvironment.PhysicalRecord,    bufferSize: CARDINAL    ];   BufferPtr: TYPE = LONG POINTER TO BufferRecord; -- May not be needed.    BufferRecord: TYPE = RECORD      [      buffer: PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte      ];        -- TYPE for allocating line-specific objects  LineHandle: TYPE = LONG POINTER TO LineObject;  LineObject: TYPE = RECORD  [ object: RS232CFace.Object ¬ [      abort: LocalAbort,      autoRecognitionWait: LocalAutoRecognitionWait,      get: LocalGet,      getStatus: LocalGetStatus,      off: LocalOff,      put: LocalPut,      resetLine: LocalResetLine,      sendBreak: LocalSendBreak,      setParameters: LocalSetParameters,      statusWait: LocalStatusWait,      transferWait: LocalTransferWait,      transmitNow: LocalTransferWait      ],    nakedWakeUpPtr: LONG POINTER TO CONDITION ¬ NIL,    nakedProcess: PROCESS ¬ NIL,    reviveProc: PROCESS ¬ NIL,    closingDown: BOOLEAN ¬ FALSE,    handle: NewRS232CFace.Handle,    bufferZone: UNCOUNTED ZONE,    transfersPending: CARDINAL ¬ 0,    bufferInCnt: LONG CARDINAL ¬ 0,    paramsSupplied: BOOLEAN ¬ FALSE,    params: NewRS232CFace.ParameterRecord ¬ NULL ];  -- global variables  upNotify: CONDITION;  zone: UNCOUNTED ZONE;  statusNotify: CONDITION;  eventCompleted: CONDITION;  waitingForStatus: CARDINAL ¬ 0;  abortStatusWait: BOOLEAN ¬ FALSE;  -- Debug variables and types.  « DebugRec: TYPE = RECORD       [       bufPtr: BufferPtr,       opPtr: NewRS232CFace.OperationPtr,       event: CompletionHandle       ];          debugPtr: ARRAY [0..128) OF DebugRec;   debugCnt: CARDINAL ¬ 0;   debugWrap: BOOLEAN ¬ FALSE; »         -- PUBLIC PROCEDUREs  GetNextLine: PUBLIC PROC [line: CARDINAL] RETURNS [nextLine: CARDINAL] =    {RETURN [NewRS232CFace.GetNextLine [line] ]};  On: PUBLIC ENTRY PROC[lineNumber: CARDINAL] RETURNS[line: RS232CFace.Handle] =    BEGIN    ENABLE UNWIND => NULL;  --I doubt this is worth while    nakedMask: WORD;    lineHandle: LineHandle;    handle: NewRS232CFace.Handle;    handle ¬ NewRS232CFace.GetHandle [lineNumber,      <<(IF DebuggerSwap.canSwap THEN>> normalClient <<ELSE debuggerClient)>>];    IF handle = NewRS232CFace.nilHandle THEN RETURN [NIL];    zone ¬ Heap.Create [      initial: 2, increment: 2,      largeNodeThreshold: (Environment.wordsPerPage * 2)];    SpecialHeap.MakeResident [zone];    lineHandle ¬ zone.NEW [LineObject ¬ [handle: handle, bufferZone: zone] ];    [cv: lineHandle.nakedWakeUpPtr, mask: nakedMask] ¬      SpecialRuntime.AllocateNakedCondition [];    Process.InitializeCondition[      lineHandle.nakedWakeUpPtr, Process.SecondsToTicks [60]];    NewRS232CFace.Initialize [nakedMask];    lineHandle.nakedProcess ¬ FORK NakedWakeUpHere[lineHandle];    IF NewRS232CFace.IsReviveProcNeeded[handle] THEN      lineHandle.reviveProc ¬ FORK ReviveIfNeeded[lineHandle]    ELSE       lineHandle.reviveProc ¬ NIL;    line ¬ @lineHandle.object    END;  -- PRIVATE PROCEDUREs (in instance of RS232CFace.Object)  LocalAbort: ENTRY PROC [line: RS232CFace.Handle, type: RS232CFace.AbortType] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    IF line = NIL THEN RETURN;    SELECT type FROM      input => SendCommand [lineHandle.handle, abortReceive];      output => SendCommand [lineHandle.handle, abortTransmit];      other =>        BEGIN	abortStatusWait ¬ TRUE;	BROADCAST statusNotify	END;       ENDCASE    END;  LocalAutoRecognitionWait: PROC [line: RS232CFace.Handle]    RETURNS [outcome: RS232CEnvironment.AutoRecognitionOutcome] =    BEGIN    RETURN [RS232CCorrespondents.illegal] -- unimplemented    END;  LocalGet: ENTRY PROC [    line: RS232CFace.Handle, rec: RS232CEnvironment.PhysicalRecordHandle]    RETURNS [completionHandle: CompletionHandle] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    dataLength: CARDINAL;    operationPtr: NewRS232CFace.OperationPtr;    storage: BufferPtr;        IF line = NIL OR rec = NIL THEN RETURN [NIL];    dataLength ¬ rec.header.stopIndexPlusOne - rec.header.startIndex +      rec.body.stopIndexPlusOne - rec.body.startIndex +      rec.trailer.stopIndexPlusOne - rec.trailer.startIndex;    completionHandle ¬ lineHandle.bufferZone.NEW [CompletionRecord];    storage ¬ lineHandle.bufferZone.NEW [BufferRecord[dataLength] ];    lineHandle.transfersPending ¬ lineHandle.transfersPending + 1;    DO  -- until EXIT      localStatus: Zone.Status;      [completionHandle.operation, localStatus] ¬ ResidentHeap.MakeNode [        NewRS232CFace.operationSize, NewRS232CFace.operationAlignment,        NewRS232CFace.operationLocation];      IF localStatus = okay THEN EXIT;      WAIT eventCompleted; --wait for someone to release resident heap space    ENDLOOP;    operationPtr ¬ @ResidentHeap.first64K[completionHandle.operation];    operationPtr­ ¬ [      dataBuffer: @storage.buffer, bufferByteLength: dataLength];    completionHandle.direction ¬ receive;    completionHandle.bufferSize ¬ dataLength;    completionHandle.physicalRecord ¬ rec­;    completionHandle.status ¬ NewRS232CFace.InitiateReceive [      lineHandle.handle, operationPtr];«   -- Debug statements.      debugPtr[debugCnt] ¬ [storage, operationPtr, completionHandle];    IF debugCnt = 127 THEN    	{	debugCnt ¬ 0;	debugWrap ¬ TRUE	}    ELSE    	debugCnt ¬ SUCC[debugCnt]»    	    END;  LocalGetStatus: ENTRY PROC [line: RS232CFace.Handle]    RETURNS [stat: RS232CFace.DeviceStatus] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    stat ¬ (IF line = NIL THEN      [breakDetected: FALSE, carrierDetect: FALSE, clearToSend: FALSE,      dataLost: FALSE, dataSetReady: FALSE, ringHeard: FALSE,      ringIndicator: FALSE, deviceError: TRUE]      ELSE GetStatusInternal [lineHandle.handle])    END;  LocalOff: ENTRY PROC [line: RS232CFace.Handle] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    nakedProcessCopy: PROCESS = lineHandle.nakedProcess;    reviveProcessCopy: PROCESS = lineHandle.reviveProc;    IF line = NIL THEN RETURN;    IF lineHandle.transfersPending > 0 THEN      BEGIN      SendCommand [lineHandle.handle, abortReceive];      SendCommand [lineHandle.handle, abortTransmit]      END;    SendCommand [lineHandle.handle, off];    UNTIL lineHandle.transfersPending = 0 DO      WAIT eventCompleted; ENDLOOP;  --that one's not abortable (yet)    UNTIL lineHandle.nakedProcess = NIL DO      Process.EnableAborts[lineHandle.nakedWakeUpPtr];      Process.Abort[nakedProcessCopy];      WAIT eventCompleted;  --give him a chance to bail out      REPEAT FINISHED => JOIN nakedProcessCopy;      ENDLOOP;    lineHandle.closingDown ¬ TRUE;    UNTIL lineHandle.reviveProc = NIL DO      Process.Abort[reviveProcessCopy];      WAIT eventCompleted;  --give him a chance to bail out      REPEAT FINISHED => JOIN reviveProcessCopy;      ENDLOOP;    lineHandle.handle ¬ NewRS232CFace.ReleaseHandle [lineHandle.handle];    SpecialRuntime.DeallocateNakedCondition[lineHandle.nakedWakeUpPtr];    SpecialHeap.MakeSwappable [lineHandle.bufferZone];    Heap.Delete [lineHandle.bufferZone]    END;  LocalPut: ENTRY PROC [    line: RS232CFace.Handle, rec: RS232CEnvironment.PhysicalRecordHandle]    RETURNS [completionHandle: CompletionHandle] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    dataLength: CARDINAL;    operationPtr: NewRS232CFace.OperationPtr;    storage: BufferPtr;    IF line = NIL OR rec = NIL THEN RETURN [NIL];    dataLength ¬ rec.header.stopIndexPlusOne - rec.header.startIndex +      rec.body.stopIndexPlusOne - rec.body.startIndex +      rec.trailer.stopIndexPlusOne - rec.trailer.startIndex;    completionHandle ¬ lineHandle.bufferZone.NEW [CompletionRecord];    storage ¬ lineHandle.bufferZone.NEW [BufferRecord[dataLength] ];    lineHandle.transfersPending ¬ lineHandle.transfersPending + 1;    IF dataLength > 0 THEN -- copy data to data block      BEGIN      block: Environment.Block ¬ Environment.Block[        LOOPHOLE [@storage.buffer], 0, dataLength];      block.startIndex ¬ ByteBlt.ByteBlt [to: block, from: rec.header];      block.startIndex ¬ block.startIndex + ByteBlt.ByteBlt [         to: block, from: rec.body];      [] ¬ ByteBlt.ByteBlt [to: block, from: rec.trailer]      END;    DO  -- until EXIT      localStatus: Zone.Status;      [completionHandle.operation, localStatus] ¬ ResidentHeap.MakeNode [        NewRS232CFace.operationSize, NewRS232CFace.operationAlignment,        NewRS232CFace.operationLocation];      IF localStatus = okay THEN EXIT;      WAIT eventCompleted; --wait for someone to release resident heap space    ENDLOOP;    operationPtr ¬ @ResidentHeap.first64K[completionHandle.operation];    operationPtr­ ¬ [      dataBuffer: @storage.buffer, bufferByteLength: dataLength];    completionHandle.direction ¬ transmit;    completionHandle.physicalRecord ¬ rec­;    completionHandle.status ¬ NewRS232CFace.InitiateTransmit [      lineHandle.handle, operationPtr]    END;  LocalResetLine: ENTRY PROC [    line: RS232CFace.Handle, paramHandle: RS232CFace.ParamHandle]    RETURNS [outcome: RS232CFace.ParameterOutcome] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    IF line = NIL OR paramHandle = NIL THEN RETURN [unimplemented];    IF lineHandle.transfersPending > 0 THEN      BEGIN      SendCommand [lineHandle.handle, abortReceive];      SendCommand [lineHandle.handle, abortTransmit]      END;    IF lineHandle.paramsSupplied THEN       BEGIN      SendCommand [lineHandle.handle, off];      lineHandle.paramsSupplied ¬ FALSE      END;    SetControlBits[lineHandle.handle, paramHandle];<<  NewRS232CFace.SetControlBits [      lineHandle.handle, [dataTerminalReady: paramHandle.dataTerminalReady,      requestToSend: paramHandle.requestToSend] ];>>    IF paramHandle.resetBreakDetected      OR paramHandle.resetDataLost      OR paramHandle.resetRingHeard THEN      ResetStatusBits[lineHandle.handle, paramHandle];<<    NewRS232CFace.ResetStatusBits [        lineHandle.handle, [resetBreakDetected: paramHandle.resetBreakDetected,        resetDataLost: paramHandle.resetDataLost,        resetRingHeard: paramHandle.resetRingHeard] ];>>    lineHandle.params ¬ [      charLength: paramHandle.charLength,      clientType: unknown,      correspondent: paramHandle.correspondent,      echo: paramHandle.echo,      flowControl: paramHandle.flowControl,      frameTimeout: paramHandle.frameTimeout,      lineSpeed: paramHandle.lineSpeed,      lineType: paramHandle.lineType,      parity: paramHandle.parity,      stopBits: paramHandle.stopBits,      syncChar: paramHandle.syncChar,      syncCount: paramHandle.syncCount ];    outcome ¬ SetParameters [@lineHandle];    IF outcome = success THEN SendCommand [lineHandle.handle, on];    END;  LocalSendBreak: ENTRY PROC [line: RS232CFace.Handle] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    IF line = NIL THEN RETURN;    SendCommand [lineHandle.handle, breakOn];    Process.Pause [Process.MsecToTicks [250] ];    -- must be at least 190; 250 is safe    SendCommand [lineHandle.handle, breakOff]    END;  LocalSetParameters: ENTRY PROC [    line: RS232CFace.Handle, paramHandle: RS232CFace.ParamHandle]    RETURNS [outcome: RS232CFace.ParameterOutcome] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    workParams: NewRS232CFace.ParameterRecord;    IF line = NIL OR paramHandle = NIL THEN RETURN [unimplemented];    SetControlBits[lineHandle.handle, paramHandle];<<  NewRS232CFace.SetControlBits [      lineHandle.handle, [dataTerminalReady: paramHandle.dataTerminalReady,      requestToSend: paramHandle.requestToSend] ];>>    IF paramHandle.resetBreakDetected      OR paramHandle.resetDataLost OR paramHandle.resetRingHeard THEN      ResetStatusBits[lineHandle.handle, paramHandle];<<    NewRS232CFace.ResetStatusBits [        lineHandle.handle, [resetBreakDetected: paramHandle.resetBreakDetected,        resetDataLost: paramHandle.resetDataLost,        resetRingHeard: paramHandle.resetRingHeard] ];>>    workParams ¬ [      charLength: paramHandle.charLength,      clientType: unknown,      correspondent: paramHandle.correspondent,      echo: paramHandle.echo,      flowControl: paramHandle.flowControl,      frameTimeout: paramHandle.frameTimeout,      lineSpeed: paramHandle.lineSpeed,      lineType: paramHandle.lineType,      parity: paramHandle.parity,      stopBits: paramHandle.stopBits,      syncChar: paramHandle.syncChar,      syncCount: paramHandle.syncCount ];    IF lineHandle.paramsSupplied AND workParams = lineHandle.params THEN      outcome ¬ success    ELSE      BEGIN      IF lineHandle.paramsSupplied THEN SendCommand [lineHandle.handle, off];      lineHandle.params ¬ workParams;      outcome ¬ SetParameters [@lineHandle]      END;    IF outcome = success THEN SendCommand [lineHandle.handle, on];    END;  LocalStatusWait: ENTRY PROC [    line: RS232CFace.Handle, stat: RS232CFace.DeviceStatus]    RETURNS [newstat: RS232CFace.DeviceStatus] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    IF line = NIL THEN RETURN [stat];    newstat ¬ GetStatusInternal [lineHandle.handle];    waitingForStatus ¬ waitingForStatus + 1;    UNTIL newstat # stat OR abortStatusWait DO      ENABLE UNWIND => IF (waitingForStatus ¬ waitingForStatus - 1) = 0 THEN        abortStatusWait ¬ FALSE;  --ABORTED      WAIT statusNotify;      newstat ¬ GetStatusInternal [lineHandle.handle]    ENDLOOP;    IF (waitingForStatus ¬ waitingForStatus - 1) = 0 THEN      abortStatusWait ¬ FALSE;    END;        LocalTransferWait: ENTRY PROC [    line: RS232CFace.Handle, event: CompletionHandle]    RETURNS [byteCount: CARDINAL, status: RS232CFace.TransferStatus] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    operationPtr: NewRS232CFace.OperationPtr = @ResidentHeap.first64K[event.operation];    statusMap: ARRAY NewRS232CFace.CompletedTransferStatus OF      RS232CFace.TransferStatus = [        success, aborted, asynchFramingError, checksumError, dataLost,        deviceError, disaster, frameTimeout, invalidChar, invalidFrame,        parityError];    IF line = NIL OR event = NIL THEN RETURN [0, disaster];    IF event.status IN NewRS232CFace.CompletedTransferStatus THEN      byteCount ¬ 0    ELSE      BEGIN      DO        ENABLE UNWIND => NULL; --can only be aborted        [byteCount, event.status] ¬ NewRS232CFace.PollReceiveOrTransmit [lineHandle.handle, operationPtr];	IF event.status IN NewRS232CFace.CompletedTransferStatus THEN EXIT;        WAIT upNotify;      ENDLOOP      END;    IF event.direction = receive AND byteCount > 0 THEN      BEGIN        block: Environment.Block ¬ Environment.Block[        LOOPHOLE [operationPtr.dataBuffer], 0, byteCount];              block.startIndex ¬ ByteBlt.ByteBlt [		  to: event.physicalRecord.header, from: block];        block.startIndex ¬ block.startIndex + ByteBlt.ByteBlt [		  to: event.physicalRecord.body, from: block];	[] ¬ ByteBlt.ByteBlt [ to:event.physicalRecord.trailer, from: block];	lineHandle.bufferInCnt ¬ lineHandle.bufferInCnt + 1;      END;          status ¬ statusMap[event.status];    lineHandle.bufferZone.FREE [@operationPtr.dataBuffer];      [] ¬ ResidentHeap.FreeNode [event.operation];      lineHandle.bufferZone.FREE [@event];      lineHandle.transfersPending ¬ lineHandle.transfersPending - 1;    NOTIFY eventCompleted    END;  -- other PRIVATE PROCEDUREs  GetStatusInternal: INTERNAL PROC [    handle: NewRS232CFace.Handle]    RETURNS [stat: RS232CFace.DeviceStatus] = INLINE    BEGIN    devStat: NewRS232CFace.DeviceStatus;    SendCommand [handle, getDeviceStatus];    devStat ¬ NewRS232CFace.GetDeviceStatus [handle];    stat ¬ [      breakDetected: devStat.breakDetected,      carrierDetect: devStat.carrierDetect,      clearToSend: devStat.clearToSend,      dataLost: devStat.dataLost,      dataSetReady: devStat.dataSetReady,      ringHeard: devStat.ringHeard,      ringIndicator: devStat.ringIndicator,      deviceError: FALSE]    END;  Init: PROC =    BEGIN    Process.InitializeCondition [@eventCompleted, Process.MsecToTicks [50]];    Process.InitializeCondition [@statusNotify, Process.MsecToTicks [50]];    NewRS232CFace.InitializeCleanup [];    Process.EnableAborts [@statusNotify];    Process.EnableAborts [@upNotify];    END;  NakedWakeUpHere: ENTRY PROC [lineHandle: LineHandle] =    BEGIN    Process.SetPriority [ProcessPriorities.priorityRS232C];    --UNTIL ABORTED-- DO      ENABLE ABORTED => EXIT;      WAIT lineHandle.nakedWakeUpPtr;      BROADCAST upNotify;      IF waitingForStatus > 0 THEN BROADCAST statusNotify;      ENDLOOP;    NOTIFY eventCompleted;  --tell whoever aborted us we exited    lineHandle.nakedProcess ¬ NIL;  --and set his loop invariant    END;    ResetStatusBits: INTERNAL PROC[handle: NewRS232CFace.Handle, paramHandle: RS232CFace.ParamHandle] =    BEGIN    commandStatus: NewRS232CFace.CommandStatus ¬ rejected;    DO      commandStatus ¬ (IF commandStatus = rejected        THEN NewRS232CFace.InitiateResetStatusBits[	  handle, [resetBreakDetected: paramHandle.resetBreakDetected,	  resetDataLost: paramHandle.resetDataLost,	  resetRingHeard: paramHandle.resetRingHeard] ]	ELSE NewRS232CFace.PollResetStatusBits [handle]);      IF commandStatus = completed THEN EXIT;      WAIT upNotify;      ENDLOOP;    END;<<The IOP board on the 6085 gets wedged.  Without knowing the definitive cause this solution works.  The symptom shows up as rsQueueRxChA.queueNext of the Handle being NIL with the head and tail NON NIL.  There may or may not be data lost.  We wait a second and a half with no data and queueNext being NIL.Note the test for queueNext is very kludgy because of the type of the opieaddress is not advanced by the Opie macros.  Once this condition is found queueNext is reset to the first available IOCB. My best guess is that if the Handler runs faster then the the Head/Driver, then the IOP runs off the queue.  A solution would be a upnotify from the IOP for out of buffers, and then unwedge the queue.  The Head driver would have to keep a bool saying it had caught the problem if there was nothing in the queue.>>     revivesTried: CARDINAL ¬ 0;    revivesDone: CARDINAL ¬ 0;	     ReviveIfNeeded: PROC[line: LineHandle] =    {    revived: BOOL;    count: LONG CARDINAL;    ticks: Process.Ticks ¬ Process.MsecToTicks[1500];    UNTIL line.closingDown DO        ENABLE ABORTED => EXIT;	count ¬ line.bufferInCnt;	<<Note it would be easy to adjust the pause based on the difference of 	the bufferInCnt, but I don't know what would be benificial.  The	problem is more likely to occurr in heavy traffic.  >>	Process.Pause[ticks];	IF (count = line.bufferInCnt AND NewRS232CFace.QueueIsBad[line.handle]) THEN	    {	    revivesTried ¬ revivesTried + 1;	    [revived] ¬ ReviveQueue[line];	    IF revived THEN	    	revivesDone ¬ revivesDone + 1;	    }    ENDLOOP;        line.reviveProc ¬ NIL;	    };      ReviveQueue: ENTRY PROC [line: LineHandle] RETURNS[revived: BOOL] =     {     once: CARDINAL ¬ 0;     skipped: CARDINAL;     UNTIL once = 1 DO     	ENABLE ABORTED => EXIT;	once ¬ 1;	[revived, skipped] ¬ NewRS232CFace.ReviveInputQueue[line.handle];	ENDLOOP;     RETURN[revived];     };       SendCommand: INTERNAL PROC [    handle: NewRS232CFace.Handle, command: NewRS232CFace.Command] =    BEGIN    commandStatus: NewRS232CFace.CommandStatus;    commandStatus ¬ NewRS232CFace.InitiateCommand [handle, command];    UNTIL commandStatus = completed DO      WAIT upNotify;      commandStatus ¬ (IF commandStatus = rejected        THEN NewRS232CFace.InitiateCommand [handle, command]	ELSE NewRS232CFace.PollCommand [handle])    ENDLOOP    END;    SetControlBits: INTERNAL PROC[handle: NewRS232CFace.Handle, paramHandle: RS232CFace.ParamHandle] =    BEGIN    commandStatus: NewRS232CFace.CommandStatus ¬ rejected;    DO      commandStatus ¬ (IF commandStatus = rejected        THEN NewRS232CFace.InitiateSetControlBits[	  handle, [dataTerminalReady: paramHandle.dataTerminalReady,	  requestToSend: paramHandle.requestToSend] ]	ELSE NewRS232CFace.PollSetControlBits [handle]);      IF commandStatus = completed THEN EXIT;      WAIT upNotify;      ENDLOOP;    END;  SetParameters: INTERNAL PROC [    lineHandle: LineHandle] RETURNS [outcome: RS232CFace.ParameterOutcome] =    BEGIN    parameterStatus: NewRS232CFace.ParameterStatus;    parameterStatus ¬ NewRS232CFace.InitiateSetParameters [lineHandle.handle, @lineHandle.params];    UNTIL parameterStatus = completed OR parameterStatus = unimplemented DO      WAIT upNotify;      parameterStatus ¬ (IF parameterStatus = rejected        THEN NewRS232CFace.InitiateSetParameters [lineHandle.handle, @lineHandle.params]	ELSE NewRS232CFace.PollSetParameters [lineHandle.handle])    ENDLOOP;    outcome ¬ (IF (lineHandle.paramsSupplied ¬ (parameterStatus = completed))      THEN success ELSE unimplemented)    END;  -- main code  Init []  END. -- RS232CSubDriverLOG7-Sep-84 -- JPM -- Created (mostly from RS232CHeadDLion).3-Oct-85 -- AOF -- Added EnableAborts and UNWINDs (?)18-Oct-85 -- JPM -- Put fast timeout on statusNotify condition (because some bits don't cause a naked notify)14-Oct-87 -- AOF -- Hummmmmm16-Oct-87 -- BKI -- Init{zone creation} -> On.21-Oct-87 -- BKI -- Comment-out DebuggerSwap.  No one uses this information. 9-Nov-87 -- BKI -- Added DeallocateNakedCondition to LocalOff.11-Jan-88 -- BKI -- Fixed ARs 12511 and 12575.20-Aug-90 -- GRG -- Fixed SPAR 219.  Modified LocalPut, LocalGet, and LocalTransferrWait to fix bad queueing.  Added "revive" procedure.21-Sep-90 -- GRG -- Took out the new routines and references to NewRS232CFaceExtras in prepartion to testing phone net.  <<All code commented out with the notation ListFix the code was part of a partially implemented and tested method of changing the link list created in enqueu to a actual queue.     ListFixEnd>>    <<ListFix LocalTransferWait was only partially debugged.  I switched to LocalTransmitNow and completed most of the debugging.  I never tried DequeueHEAD.      LocalTransferWait: ENTRY PROC [    line: RS232CFace.Handle, event: CompletionHandle]    RETURNS [byteCount: CARDINAL, status: RS232CFace.TransferStatus] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    operationPtr: NewRS232CFace.OperationPtr;    freeOperation: BOOL ¬ TRUE;        statusMap: ARRAY NewRS232CFace.CompletedTransferStatus OF      RS232CFace.TransferStatus = [        success, aborted, asynchFramingError, checksumError, dataLost,        deviceError, disaster, frameTimeout, invalidChar, invalidFrame,        parityError];	    IF line = NIL OR event = NIL THEN RETURN [0, disaster];            DO        ENABLE UNWIND => NULL; --can only be aborted        [byteCount, event.status, operationPtr] ¬ NewRS232CFace.PollReceiveOrTransmit [lineHandle.handle, NIL, TRUE];	IF event.status IN NewRS232CFace.CompletedTransferStatus THEN EXIT;        WAIT upNotify;      ENDLOOP;    -- copy data to user's data buffer         IF byteCount > 0 THEN      BEGIN        block: Environment.Block ¬ Environment.Block[        LOOPHOLE [@operationPtr.dataBuffer], 0, byteCount];              --Note the operationPtr returned by PollReceiveOrTransmit has no relation the client event.operation.  Hence, the size of the buffers may be different.  ByteBlt is nicely behaved and moves minimum of lengths.  Hence there is no overwrite.  The only question is wheteher all the bytes have been moved.        block.startIndex ¬ ByteBlt.ByteBlt [		  to: event.physicalRecord.header, from: block];        block.startIndex ¬ block.startIndex + ByteBlt.ByteBlt [		  to: event.physicalRecord.body, from: block];	block.startIndex ¬ block.startIndex + ByteBlt.ByteBlt [ to:event.physicalRecord.trailer, from: block];        IF byteCount <= event.bufferSize THEN	  NewRS232CFace.DequeueHead[lineHandle.handle]	ELSE	  {	  temp: Environment.Block ¬ [block.blockPointer, 0, byteCount - event.bufferSize];	  	  freeOperation ¬ FALSE;	  [] ¬ ByteBlt.ByteBlt [to: temp, from: block];	  NewRS232CFace.UpdateIOCB[operationPtr, byteCount - event.bufferSize];	  byteCount ¬ event.bufferSize;	  }	        END;    status ¬ statusMap[event.status];    IF freeOperation THEN      {      lineHandle.bufferZone.FREE [@operationPtr.dataBuffer];            --Cough! Cough! ?? Do you know of a better way to convert a LONG POINTER to a RELATIVE POINTER?  FreeNode only accepts RELATIVE POINTERs.  I am fortuantly safe in this operation because everything is allocated from the first64 K of real memory.        event.operation ¬ LOOPHOLE[CARDINAL[Inline.LowHalf[operationPtr]]];      [] ¬ ResidentHeap.FreeNode [event.operation];      lineHandle.transfersPending ¬ lineHandle.transfersPending - 1;      NOTIFY eventCompleted;       };    lineHandle.bufferZone.FREE [@event];    END;    >>
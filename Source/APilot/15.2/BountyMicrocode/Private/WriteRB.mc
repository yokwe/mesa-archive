{File name Write.mcDescription: Mesa Write op-codesAuthor: DXC     Created: February 16, 1980JPM 21-Sep-91 10:13:04 Change subroutine calls.JPM  9-Sep-91 16:40:42 Change Lcount value to 1.JPM 28-Aug-91 10:08:32 Change alignment of FIFO return point, add label to share code.JPM 15-Jul-91 15:14:53 Add FIFO simulation code to WLB (to catch cursor changes).JPM 11-Sep-84 14:04:07 Fix BRANCH mask after XWtOKDisp; fix allocation errors.Last edited: DEG,  1-Sep-84 19:56:21  add copyright notice.JPM 9-May-84 13:20:53 Replaced XDirtyDisp by XWtOKDispAEF 21-Jul-83 11:02:18 Fix stack problem during page fault on second word of double writesAXD 15-Jun-83 18:39:26 New Instruction SetJGS November 2, 1981  4:11 PM New Instruction SetLast edited: RXJ, January 14, 1981  11:04 AMLast edited: RXG, April 2, 1980  10:34 PMLast edited: DXC, March 28, 1980  5:09 PM}{ 	Copyright (C) 1980, 1981, 1983, 1984, 1991 by Xerox Corporation.  All rights reserved.}{Wn	Write n = 0WB	Write ByteWLB	Write Long ByteWDB	Write Double ByteWDLB	Write Double Long BytePSB	Put Swapped BytePSDn	Put Swapped Double n = 0PSDB	Put Swapped Double BytePSLB	Put Swapped Long BytePSDLB	Put Swapped Double Long ByteWLIP	Write Local Indirect PairWLILP	Write Local Indirect Long PairWLDILP	Write Local Double Indirect Long PairWOB	Write Overhead Byte}{*****************************************************************************	WB*****************************************************************************}@W0:	TT ¬ TOS, push, L1¬L1.PushDec,				c1, opcode[111'b];	STK ¬ TOS, pop, PC ¬ PC + PC16, GOTO[Wa],			c2;@WB:	TT ¬ TOS + ib, push, L1¬L1.PushDec2,			c1, opcode[112'b];	STK ¬ TOS, pop, PC ¬ PC + 1,					c2;Wa:	Noop,								c3;WMpc1:	Map ¬ Q ¬ [rhMDS, TT],						c1;WMpc2:	T ¬ STK, pop, L0¬L0.W,						c2;WMpc3:	Rx ¬ rhRx ¬ MD, XWtOKDisp,					c3;W:	MAR ¬ [rhRx, Q + 0], BRANCH[WMUD,$,0D],			c1, WMFRet[L0.W];Wb:	MDR ¬ T, IBDisp, GOTO[SLa],					c2;WMUD:	CALL[WMapFix],							c2;{*****************************************************************************	PSB*****************************************************************************}@PSB:	TT ¬ STK{ptr}, fXpop, fZpop, push,			c1, opcode[113'b];	TT ¬ TT + ib, push, L1¬L1.Dec2,					c2;	STK ¬ TOS, PC ¬ PC + 1, GOTO[WMpc1],				c3;{*****************************************************************************	WLB*****************************************************************************}@WLB:	TT ¬ STK{ptrL}, pop, L1¬L1.Push,			c1, opcode[114'b];	TT ¬ TT + ib, CarryBr, L2¬L2.WL,				c2;	rhTT ¬ TOS{ptrH} LRot0, BRANCH[WLMpc1, WLa],			c3;WLa:	CALL[VAHiInc],							c1;WLMpc1:	Map ¬ Q ¬ [rhTT, TT],			 	       c1, VAHiRet[L2.WL];WLMpc2:	T ¬ STK, L0¬L0.WL,						c2;WLMpc3:	Rx ¬ rhRx ¬ MD, XWtOKDisp,					c3;WL:	MAR ¬ Q ¬ [rhRx, Q + 0], BRANCH[WLMUD,$,0D],	       c1, WLMFRet[L0.WL];WLc:	MDR ¬ T{data}, Rx ¬ DisplayBankMask, pop,			c2;	[] ¬ Rx and rhRx, ZeroBr,					c3;WLd:	uRingBufData0 ¬ Q, BRANCH[$,WLDoRBEntry],	c1, at[RBWrite,10,RBAdvRet];	IBDisp, PC ¬ PC + 1, GOTO[SLa],					c2;WLMUD:	Q ¬ TT, CALL[WLMapFix],						c2;{*****************************************************************************	PSLB*****************************************************************************}@PSLB:	rhTT ¬ STK, pop, 					c1, opcode[115'b];	TT ¬ STK, fXpop, fZpop, push,					c2;	TT ¬ TT + ib, CarryBr, push,					c3;PSLc:	Map ¬ Q ¬ [rhTT, TT], push, L1¬L1.Pop, BRANCH[PSLa, PSLb],	c1;PSLa:	STK ¬ T ¬ TOS, L0¬L0.WL, GOTO[WLMpc3],				c2;PSLb:	Q ¬ rhTT + 1, pop, LOOPHOLE[byteTiming],			c2;	rhTT ¬ Q LRot0, GOTO[PSLc],					c3;	{*****************************************************************************	WDB*****************************************************************************}@WDB:	Q ¬ TOS + ib, L1¬L1.Push2,				c1, opcode[116'b];	T ¬ STK{data1}, pop,						c2;WDd:	Noop,								c3;WDMpc1:	Map ¬ [rhMDS, Q],						c1;WDMpc2:	TT ¬ STK{data0}, pop, L0¬L0.WD,					c2;WDMpc3:	Rx ¬ rhRx ¬ MD, XWtOKDisp,					c3;WD:	MAR ¬ [rhRx,Q + 0], BRANCH[WDMUD,$,0D],			c1, WMFRet[L0.WD];WDc:	MDR ¬ TT, TT ¬ Q + 1, PgCarryBr,				c2;	rhTT ¬ UvMDS, push, BRANCH[WDLd, WDb],				c3;WDb:	Map ¬ Q ¬ [rhTT, Q + 1], L0¬L0.WDB				c1;WDe:	TT ¬ Q,								c2;	Rx ¬ rhRx ¬ MD, XWtOKDisp,					c3;	MAR ¬ Q ¬ [rhRx, Q + 0], BRANCH[WLMUD,WLc,0D],	      c1, WLMFRet[L0.WDB];WDMUD:	CALL[WMapFix],							c2;{*****************************************************************************	PSD0 and PSDB*****************************************************************************}@PSD0:	Q ¬ 0, pop, L1¬L1.PushInc,				c1, opcode[117'b];	T ¬ STK, fXpop, fZpop, push,					c2;	PC ¬ PC - PC16, push, GOTO[PSDa],				c3;@PSDB:	Q ¬ ib, pop,						c1, opcode[120'b];	T ¬ STK, fXpop, fZpop, push,					c2;	L1¬L1.Push, push,						c3;PSDa:	Q ¬ T + Q, push,						c1;	STK ¬ T ¬ TOS, pop, GOTO[WDd],					c2;{*****************************************************************************	WDLB*****************************************************************************}@WDLB:	TT ¬ STK{ptrL}, pop, L1¬L1.Push2,			c1, opcode[121'b];	TT ¬ TT + ib, CarryBr, L2¬L2.WDL,				c2;	rhTT ¬ TOS{ptrH} LRot0, BRANCH[WDLMc1, WDLa],			c3;WDLa:	CALL[VAHiInc],							c1;WDLMc1:	Map ¬ Q ¬ [rhTT,TT],					c1, VAHiRet[L2.WDL];WDLMc2:	T ¬ STK{data1}, pop, L0¬L0.WDL,					c2;WDLMc3:	Rx ¬ rhRx ¬ MD, XWtOKDisp,					c3;	MAR ¬ [rhRx,Q + 0], BRANCH[WDLMUD,$,0D],	      c1, WLMFRet[L0.WDL];	MDR ¬ STK{data0}, L0¬L0.WL,					c2;	[] ¬ TT + 1, PgCarryBr,						c3;WDLd:	MAR ¬ [rhRx,Q + 1], BRANCH[WDLb, WDLc],				c1;WDLb:	MDR ¬ T{data1}, PC ¬ PC + 1, IBDisp, pop, CANCELBR[SLa,0],	c2;WDLc:	[] ¬ Q + 1, CarryBr, CANCELBR[$,2],				c2;	Q ¬ rhTT + 1, LOOPHOLE[byteTiming], BRANCH[WDLe, WDLf],		c3;WDLe:	Map ¬ Q ¬ [rhTT, TT + 1], GOTO[WDe],				c1;WDLf:	rhTT ¬ Q LRot0, GOTO[WDLc],					c1;WDLMUD:	CALL[WLMapFix],							c2;{*****************************************************************************	PSDLB*****************************************************************************}@PSDLB:	pop, L1¬L1.None,					c1, opcode[122'b];	rhTT ¬ STK, pop,						c2;	TT ¬ STK, fXpop, fZpop, push,					c3;	TT ¬ TT + ib, CarryBr, push,					c1;	Q ¬ rhTT + 1, push, LOOPHOLE[byteTiming], BRANCH[PSDLa, PSLDb],	c2;PSDLa:	GOTO[PSDLc],							c3;PSLDb:	rhTT ¬ Q LRot0,GOTO[PSDLc],					c3;PSDLc:	Map ¬ Q ¬ [rhTT, TT], push,					c1;	STK ¬ T ¬ TOS, pop, L0¬L0.WDL, GOTO[WDLMc3],			c2;{*****************************************************************************	WLIP*****************************************************************************}@WLIP:	MAR ¬ Q ¬ [rhL, L+alpha.left], L0¬L0.WLIP, push,	c1, opcode[136'b];	STK ¬ TOS, PC ¬ PC + 1, L2¬L2.LIP, BRANCH[LIPa,LIPb,1],	c2;	Map ¬ Q ¬ [rhMDS, TT], L1¬L1.Dec2, GOTO[WMpc2],		c1, IPRet[L0.WLIP];{*****************************************************************************	WLILP*****************************************************************************}@WLILP:	MAR ¬ Q ¬ [rhL, L+alpha.left], L0¬L0.WLILP, push,	c1, opcode[137'b];	STK ¬ TOS, PC ¬ PC + 1, L2¬L2.LILP0, BRANCH[LILPa,LILPb,1],	c2;	PC ¬ PC - 1, L1¬L1.Pop,					c3, ILPRet[L0.WLILP];	Map ¬ Q ¬ [rhTT, TT], GOTO[WLMpc2],				c1;{*****************************************************************************	WLDILP*****************************************************************************}@WLDILP:	MAR ¬ Q ¬ [rhL, L+alpha.left], L0¬L0.WLDILP, push,	c1, opcode[140'b];	STK ¬ TOS, PC ¬ PC + 1, L2¬L2.LILP0, BRANCH[LILPa,LILPb,1],	c2;	PC ¬ PC - 1, L1¬L1.None, GOTO[WDLMc1],			c3, ILPRet[L0.WLDILP];{*****************************************************************************	WOB	Write Overhead Byte*****************************************************************************}@WOB:	TT ¬ TOS - ib, L1¬L1.PushDec3,			c1, at[0F,10,ESC1n];	PC ¬ PC + PC16, GOTO[Wa],					c2;{Ring buffer entry}WLDoRBEntry:	[] ¬ Q - rDisplayLimit, CarryBr, L5 ¬ RBWrite,			c2;	Lcount ¬ 1, BRANCH[$,WLd],					c3;	uRingBufData1 ¬ Lcount, CALL[RBAdd2Words],			c1;	{ E N D }
{File name RingBuffer.mcDescription: Subroutines for adding information to the video ring bufferJPM, 16-Oct-91 14:21:30, uncommented RBWaitForEmpty and added test for buffer not in useJPM, 21-Sep-91 10:20:57, added RBWaitForEmpty (commented out for now)JPM, 17-Sep-91 16:23:40, moved from BBInitII.mcAuthor: JPM     Created: September, 1991}{ 	Copyright (C) 1991 by Xerox Corporation.  All rights reserved.}{	RBAdd2Words subroutineThis subroutine is used to add two words to the ring buffer.	CYCLESc2 - c1, 5 clicks unless buffer is full	REGISTERSuRingBufPos	address of next word in ring bufferuRingBufData0	first word of datauRingBufData1	second word of dataTb, rhTb, Q	scratch regsL5		return address	RETURNS THRURBAdd2Ret (unless MSB of L5 is 1, then transfers control to RBAdvance)}RBAdd2Words:	rhTb ¬ 0,						c2;RBAdd2BackDoor:	Tb ¬ uRingBufPos,					c3;RBAdd2Resume:	MAR ¬ [rhTb, Tb + 0],					c1;	MDR ¬ uRingBufData0,					c2;	Q ¬ uRingBufEnd,					c3;	MAR ¬ [rhTb, Tb + 1],					c1;	MDR ¬ uRingBufData1, LOOPHOLE[wok], CANCELBR[$,0],	c2;	[] ¬ Tb xor Q, ZeroBr,					c3;	MAR ¬ [rhRingBuf, rRingBuf + 0], L5Disp, BRANCH[$,RBWraparound], c1;	Tb ¬ Tb + 2, BRANCH[RBTestFull,RBTestFullAndAdvance,7],	c2;RBWraparound:	Tb ¬ rRingBuf + 6, BRANCH[RBTestFull,RBTestFullAndAdvance,7], c2;RBWaitNotFull:	MAR ¬ [rhRingBuf, rRingBuf + 0], CANCELBR[$,0F],	c1;	[] ¬ Q, NZeroBr,					c2;RBTestFull:	Q ¬ MD xor Tb, L5Disp, BRANCH[RBWaitNotFull,$],		c3;	uRingBufPos ¬ Tb, DISP3[RBAdd2Ret],			c1;RBWaitToAdvance:	MAR ¬ [rhRingBuf, rRingBuf + 0],			c1;	[] ¬ Q, NZeroBr,					c2;RBTestFullAndAdvance:	Q ¬ MD xor Tb, BRANCH[RBWaitToAdvance,$],		c3;	MAR ¬ [rhRingBuf, rRingBuf + 1],			c1;	MDR ¬ uRingBufPos ¬ Tb, LOOPHOLE[wok], CANCELBR[RBAdvCont,0], c2;{	RBAdvance subroutineThis subroutine is used to advance the ring buffer to the current position.	CYCLESc1 - c3, 3 clicks unless down-notify is required	REGISTERSuRingBufPos	address of next word in ring bufferuRingBufEntry	address of start of current entry in ring bufferTb, rhTb, Q	scratch regsL5		return address	RETURNS THRURBAdvRet}RBAdvance:	MAR ¬ [rhRingBuf, rRingBuf + 1],			c1;	MDR ¬ Tb ¬ uRingBufPos, LOOPHOLE[wok], CANCELBR[$,0],	c2;RBAdvCont:	Q ¬ uRingBufEntry,					c3;	MAR ¬ [rhRingBuf, rRingBuf + 0],			c1;	uRingBufEntry ¬ Tb,					c2;	Q ¬ Q xor MD,						c3;	[] ¬ Q, ZeroBr,						c1;	T ¬ uMesaProc, L5Disp, BRANCH[$,RBDownNotify],		c2;	DISP4[RBAdvRet],					c3;RBDownNotify:	rhT ¬ uIORgnHigh, CANCELBR[$,0F],			c3;	MAR ¬ [rhRingBuf, rRingBuf + 3],			c1;	TT ¬ T + downNotifyBits, CANCELBR[$,0],			c2;	rhRx ¬ Rx ¬ MD,						c3;	MAR ¬ [rhT, T + notifiersLockMask],			c1;	T ¬ Rx and ~0FF, CANCELBR[$,0],				c2;	TOS ¬ MD, L4 ¬ SoftwareLockRets.RB,			c3;	Rx ¬ RShift1 rhRx, XLDisp, GOTO[NotifyIOPCont],		c1;	MDR ¬ 0, L5Disp, CANCELBR[$,0],				c2, at[SoftwareLockRets.RB,10,SoftwareLockRets];	ClrMPIntIOP, DISP4[RBAdvRet],				c3;{	RBWaitForEmpty subroutineThis subroutine is used to wait until the ring buffer is empty (or not in use).	CYCLESc1 - c3, 2 clicks unless wait is required	REGISTERSuRingBufEntry	address of start of current entry in ring bufferQ		scratch regL5		return address	RETURNS THRURBWaitRet}RBWaitForEmpty:	MAR ¬ [rhRingBuf, rRingBuf + 0], BRANCH[$,RBTestForEmpty], c1;	Noop,							c2;	Q ¬ MD,							c3;	[] ¬ Q xor uRingBufEntry, NZeroBr,			c1;RBTestForEmpty:	L5Disp, BRANCH[RBDoneWaiting,$],			c2;	[] ¬ Q, ZeroBr, CANCELBR[RBWaitForEmpty,7],		c3;RBDoneWaiting:	DISP3[RBWaitRet],					c3;	{END}
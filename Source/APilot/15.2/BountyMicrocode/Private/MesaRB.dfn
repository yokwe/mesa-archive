{File name:  Mesa.dfn  Description: Non-Register Definitions for Daybreak Mesa Emulator Microcode, Created: November 18, 1980,Last Edited:JPM 16-Oct-91 14:33:23: modified a few subroutine returns.JPM 21-Sep-91 10:29:53: added ring buffer entry types and more subroutine returns.JPM 18-Sep-91  8:30:18: changed "FIFO" to "RB" (ring buffer), added subroutine returns.JPM 12-Jul-91 13:51:06: added subroutine return point for FIFO simulation.JPM 21-Nov-89 14:24:22: added constants and macros for FastXfer and VMFind.AHL/JPM 31-Dec-86 11:57:45: MDS relief changes.JPM 18-Dec-86 10:49:11: added more subroutine return points for image processing.JPM 10-Oct-86  9:11:14: removed L4.ComMapSub.JPM  9-Oct-86 12:44:43: removed L0.BLTLine.JPM  8-Aug-86 16:26:40: image processing microcode integration.SCJ 14-May-86  9:57:07: merged EIS Mesa.dfn with the existing Mesa.dfn to build a MesaDove with floating point microcodeDEG 10-Mar-86 23:23:38: clean-up code and upgrade to Mesa.dfn of  3-Feb-86 18:19:30 by KxI.DEG 17-Feb-86 22:14:38: added entry point for sqrt.DEG 18-Jan-86 22:40:16: added color, WrPxl, PxlBlT, P18BlT, and P81BlT definitions.DEG 17-Jan-86  5:06:12: added floating point constants and named MesaEIS.dfnJPM 3-Jul-85 11:03:02: added constants from Daybreak.dfn and other .mc filesJPM 11-Sep-84 14:04:18: changed value of L1.Pop to 0E (0 mod 2)DEG  2-Sep-84  0:33:13: add copyright notice.JPM 24-Apr-84 16:07:25: changed rhT encoding for Xfer to use bit 12 rather than bit 11HGM, 28-Nov-83  8:48:52: L0.XWrite ¬ oddAXD 27-Sep-83 14:28:59: Added L0.IOCopy for DicentraDEG 20-Sep-83 20:47:45: Renamed to .dfnAXD 14-Sep-83 16:18:01: Change L0.CLRead for XferAEF 18-Jul-83 14:52:58: Change L0 constants for WLMFRetAXD 27-Jun-83 11:18:05: Changed defs for 32-bit control links and Klamath instruction set shuffle.AEF 22-Dec-82 10:50:59: Add BLTLR constant definitionCRF July 6, 1982  3:47 PM: Added SrcMap return point MapSrcBandBLT for BandBLTBBInit.JGS October 14, 1981  3:59 PM: Change for new instruction setJXF March 11, 1981  2:56 PM: Change BLDest and BLDestR for ChecksumJXF March 4, 1981  4:55 PM: Add entry to RMapFixCallerJXF February 17, 1981  5:02 AM: changes to RMapFixCaller, WMapFixCaller, RFixForTrap, WFixForTrap for new BlockJGS, February 2, 1981  1:11 PMJGS, January 20, 1981  4:48 PMJXF January 8, 1981  10:41 AM}{	Copyright (C) 1981, 1982, 1983, 1984, 1985, 1989, 1991 by Xerox Corporation.  All rights reserved. }{Mesa SD offsets (from SDDefs.mesa)}Set[sBreak,		0'b];Set[sBoot,		1'b];  {@SD[sBoot] MOD 4 = 2!!!}Set[sStackError,	2'b];Set[sRescheduleError,	3'b];Set[sXferTrap,		4'b];Set[sOpcodeTrap,	5'b];Set[sControlTrap,	6'b];Set[sCodeTrap,		7'b];Set[sHardwareError,	10'b];Set[sUnbound,		11'b];Set[sDivZeroTrap,	12'b];Set[sDivCheckTrap,	13'b];Set[sInterruptError,	14'b];Set[sProcessTrap,	15'b];Set[sBoundsTrap,	16'b];Set[sPointerTrap,	17'b];{Fault queue pointers used for Faults}Set[qFrameFault,	60'b];Set[qPageFault,		62'b];Set[qWriteProtect,	64'b];{Xfer value used for Traps}Set[L2.TRAPSpc,		0A];{flag value used for Interrupts and Faults}Set[pInt,		47]; {also in Process}Set[pFault,		03]; {also in Process}{StateVector definition}Set[State.word,		16'b];Set[State.frame,	17'b];Set[State.data,		20'b];Set[State.datam1,	17'b];Set[cSS,		16'b];Set[cSSm1,		15'b];Set[cSSm2,		14'b];Set[cSSp1,		17'b];{Local Frame definition}Set[LF.word,		4];Set[LF.returnLink,	3];Set[LF.globalLink,	2];Set[LF.pc,		1];{Global Frame definition}Set[GF.word,		1];{Global Frame Table definition}Set[GFTHi,		2];Set[GFTE.globalLo,	0];Set[GFTE.globalHi,	1];Set[GFTE.codeLo,	2];Set[GFTE.codeHi,	3];{Link Codes for Common Subroutines}{L0	RMFRtn}MacroDef[RMFRet, at[#1,10,RMFRtn]];Set[L0.R,		00]; {must be even}Set[L0.XRead,		01];Set[L0.RD,		02]; {must be even}Set[L0.RD,		04]; {must be even}Set[L0.DBS,		05];Set[L0.LGCRead,		06]; {must be even; paired with L0.LGCSameG}Set[L0.LGCSameG,	07]; {must be odd; paired with L0.LGCRead}Set[L0.ERefill,		08]; {must be even} Set[L0.NERefill,	0A]; {must be 2 MOD 4}Set[L0.NERefill.Set,	08]; {must end with 00}Set[WhichFixType,	0B]; {used to distinguish between Refill & JRemap}Set[L0.XGfi,		0C]; {must be even}Set[L0.XCode,		0E]; {must be even}Set[L0.JRemap,		0F]; {must be 0F}{L0	RLMFRtn}MacroDef[RLMFRet, at[#1,10,RLMFRtn]];Set[L0.RL,		00]; {must be even}Set[L0.RF,		01];Set[L0.RS,		02]; {must be even}Set[L0.RLFS,		03];Set[L0.BLSource,	05]; Set[L0.RDL0,		06]; {must be even}Set[L0.RDL1,		08]; {must be even}Set[L0.GFTRead,		0A]; {must be 0 mod 2, paired with L0.SameG}Set[L0.SameG,		0B]; {must be 1 mod 2, paired with L0.GFTRead}Set[L0.CLRead,		0C]; {must be even}Set[L0.JI,		0D];Set[L0.BLDestR,		0E]; {must be E}{L0	WMFRtn}MacroDef[WMFRet, at[#1,10,WMFRtn]];Set[L0.WS,	00];Set[L0.W,	01];{1 MOD 4}Set[L0.PO,	02];Set[L0.PI,	03];Set[L0.FF,	04];Set[L0.WL,	05];{1 MOD 4}Set[L0.Alloc1,	07];Set[L0.Alloc2,	08];Set[L0.WD,	09];{1 MOD 4}Set[L0.XWrite,	0B]; {Odd}Set[L0.Xfer,	0C];{must be 0C}Set[L0.Free,	0D];{1 MOD 4}{L0	WLMFRtn}MacroDef[WLMFRet, at[#1,10,WLMFRtn]];Set[L0.WDB,		00]; {0 MOD 2}Set[L0.WLS,		01]; {1 MOD 4}Set[L0.WLFS,		03]; {1 MOD 2}Set[L0.PushByte,	04]; {CompressAssist.mc}Set[L0.WF,		05]; {1 MOD 4}Set[L0.PushByteToWB,	06]; {CompressAssist.mc}Set[L0.ME,		07]; {1 MOD 2}Set[L0.WL,		09]; {1 MOD 4}Set[L0.WDL2,		0B]; {1 MOD 2}Set[L0.WDL,		0D]; {1 MOD 4}Set[L0.IOCopy,		0E]; {for Dicentra}Set[L0.BLDest,		0F]; {must be same as L0.BLDest for RMapFixCaller, must = F}{L1	Common TrapFix}Set[L1.None,	 0]; {JIB,JIW,PLD0,PSDLB,WLDILP}Set[L1.Restore,  1]; {must be 1 mod 2, Block.mc}Set[L1.Dec,	 2]; {SLn,Rn,RDLn,R0F,W0F,WS0F,LLOB,RKIB,RKDIB}Set[L1.Xfer,	 3]; {must be 3 mod 4, Xfer.mc}Set[L1.Dec2,	 4]; {SLB,RB,RDLB,RF,WF,PSB,WLIP,DBS,FF,DSK}Set[L1.PopDec2,	 5]; {LLB,LGB,PLB,PLDB,RDB,RxIP,RxILP,RLIPF,RLILPF,LGMap}Set[L1.PopDec,	 6]; {LLn,LGn,RLI0n,RD0,PS0F}Set[L1.Pop2Dec,	 7]; {LLDn,LGDn,RLDI00,PSF,PSLF}{L1	RTrapFix}Set[L1.Pop2Dec2, 8]; {0 mod 2; = L2.RDL; also RLTrapFix; LxGB,RLDIP,RKDIB}Set[L1.Refill,	 9]; {Refill.mc}{L1	RLTrapFix}{Set[L1.Pop2Dec2,	08]; {also RTrapFix; RLDILP,RKDIB}}Set[L1.Push2,		09]; {also WTrapFix; RLS,RLFS}Set[L1.PushDec,		0A]; {also WTrapFix; RL0,RL0F,RCFS}Set[L1.PushDec2,	0B]; {also WTrapFix; RLB,RLF}{NextMatchAndDiff}Set[L1.Push,		0C]; {also WTrapFix; RS}Set[L1.Dec3,		0D]; {RC,ROB}{L1	WTrapFix}{L1	WTrapFix}Set[L1.PushInc,	 	08]; {PSD0}{Set[L1.Push2,		09]; {also RLTrapFix; WLS,WLFS,WDB,WDLB}}{Set[L1.PushDec,	0A]; {also RLTrapFix; SLDn,WL0F,W0}}{Set[L1.PushDec2,	0B]; {also RLTrapFix; SLDB,WLF,WB}{CLR}}{Set[L1.Push,		0C]; {also RLTrapFix; SLDn,SLDB,SGDB,WS,WLB,PSDB}}Set[L1.PushDec3,	0D]; {WOB}Set[L1.Pop,		0E]; {PSLB,WLILP,SGB,SGDB}Set[L1.Push2Dec2,	0F]; {PushByte, PushByteToWordBoundary}{L2	MaskRet}Set[L2.SSBInv,		00]; {Stack}Set[L2.SSBNorm, 	01]; {Stack}Set[L2.Rotate,		02]; {Stack}Set[maskRet.flags,	03]; {TextBlt}Set[L2.RF,		04]; {Field}Set[L2.WF0,		05]; {Field}Set[L2.WF1,		06]; {Field}Set[maskRet.fQ,		09], {BitBlt}Set[maskRet.f1,		0E], {BitBlt}Set[maskRet.f2,		0D], {BitBlt}Set[maskRet.bQ,		0C], {BitBlt}Set[maskRet.b1,		0B], {BitBlt}Set[maskRet.b2,		0A], {BitBlt}{L0	IPRtn}MacroDef[IPRet, at[#1,10,IPRtn]];Set[L0.RLIPF,	 4];Set[L0.RLIP,	 5];Set[L0.RLDIP,	 6];Set[L0.RGIP,	 7];Set[L0.WLIP,	 8];{L0	ILPRtn}MacroDef[ILPRet, at[#1,10,ILPRtn]];Set[L0.RLILPF,	09];Set[L0.RLILP,	0A];Set[L0.RLDILP,	0B];Set[L0.RGILP,	0C];Set[L0.WLILP,	0D];Set[L0.WLDILP,	0E];{L2	LGMRtn}MacroDef[LGMRet, at[#1,10,LGMRtn]];Set[L2.LIP,	 1];Set[L2.LIPx, Or[L2.LIP, 2]];Set[L2.LILP0,	 5];Set[L2.LILP0x, Or[L2.LILP0, 2]];Set[L2.LILP1,	 8]; {must be 0 mod 2}Set[L2.LILP1x,	 9]; {must be L2.LILP1 or 1}Set[L2.GILP0,	0D]; Set[L2.GILP0x, Or[L2.GILP0, 2]];{L2	VAHiInc}MacroDef[VAHiRet, at[#1,10,VAHiRtn]];Set[L2.WDL,	00]; {must be 0; must be even, someone in odd pair}Set[L2.RDL,	08]; {Same as L1.Pop2Dec2; must be even, someone in odd pair}Set[L2.WL,	04]; {must be even, someone in odd pair}Set[L2.WLF,	06]; {must be even, someone in odd pair}Set[L2.xSL,	0E]; {must be even, someone in odd pair}Set[L2.RLF,	0A]; {must be even, someone in odd pair}Set[L2.RLFS,	0C]; {must be even, someone in odd pair}Set[L2.WLFS,	02]; {must be even, someone in odd pair}{L3	Holds VA location for faults	Bit 0: 0 => Q,     1 => TT	Bit 1: 0 => rhMDS, 1 => rhTT}Set[L3.rhMDS.Q,	 0];Set[L3.rhMDS.TT, 1];Set[L3.rhTT.Q,	 2];Set[L3.rhTT.TT,	 3]; {must be 3 for IBEmptyTrap}Set[OpcodeBase, 500];MacroDef[opcode,	at[Add[#1, OpcodeBase]]];MacroDef[alpha.left,	ibHigh];MacroDef[fd.pos,	ibHigh];MacroDef[alpha.right,	ibLow];MacroDef[fd.size,	ibLow];MacroDef[AlwaysIBDisp,	(IBDisp, IBPtr¬1)];{XFER stuff}{StashPC returns - Link 2}MacroDef[SPCr,	 at[#1,10,SpcRtn]];Set[L2.EFCnSpc,	00];Set[L2.EFCBSpc,	01];Set[L2.LFCSpc,	02];Set[L2.KFCBSpc,	03];Set[L2.SFCSpc,	04];Set[L2.POSpc,	05]; {also XWr}Set[L2.XSpc,	07];Set[L2.BRKSpc,	08];Set[L2.RSSpc,	09];Set[L2.TRAPSpc,	0A]; {0 MOD 2}Set[L2.FAULTSpc,0B]; {1 MOD 2; paired with L2.TRAPSpc and L3.XFault}Set[L2.ESCSpc,	0C];{XferType}Set[XferType.ret,	 0];Set[XferType.call,	 1];Set[XferType.lfc,	 2];Set[XferType.port,	 3];Set[XferType.xfer,	 4];Set[XferType.trap,	 5];Set[XferType.pSwitch,	 6];{rhT encoding:	Bit	Meaning	8	stack must be pushed twice	9-10	amount to backup PC if trap occurs	12	PC saved in UreturnPC if need to backup PC	13	indirect xfer	14	0: trap, 1: LSTF/RET/Call/SFC/PO/pswitch	15	free frame}Set[xtTrap,	 Or[Lshift[0,5], Lshift[0,1]	]];Set[xtX,	 Or[Lshift[3,5], Lshift[1,1]	]];Set[xtFC0,	 2 {Or[Lshift[0,5], Lshift[1,1]	]}];Set[xtFC1,	 Or[Lshift[1,5], Lshift[1,1]]];Set[xtFC2,	 Or[Lshift[2,5], Lshift[1,1]]];Set[xtFC3,	 Or[Lshift[3,5], Lshift[1,1]]];Set[xtXF,	 Or[Lshift[3,5], Lshift[1,1],  1]];Set[xtRET,	 Or[Lshift[0,5], Lshift[1,1],  9]];Set[xtSFC1,	 Or[Lshift[1,5], Lshift[1,1], 80]];Set[xtSFC2,	 Or[Lshift[2,5], Lshift[1,1], 80]];Set[xtAF,	07F];Set[xtPSwitch,	 Lshift[1,1]];{Block and BitBlt stuff}{constant and macro definitions for BitBlt}		{gray (gr) values}Set[gr.gray,1],Set[gr.notgray,5],Set[gr.mask,1],Set[grM,8],		{source function (sf) values}Set[sf.true,4],Set[sf.comp,5],Set[sf.mask,4],Set[sfM,8],		{direction (dir) values}Set[dir.forward,6],Set[dir.backwards,0E],Set[dirM,10],		{dest function (df) values}Set[df.null,8],Set[df.and,0A],Set[df.or,0C],Set[df.xor,0E],Set[dfM,10],		{srcdst function (sd) values}Set[sd.src,0],Set[sd.dst,1],Set[sd.spec,2],Set[sdM,4],{Return points for RestoreRandRHRegs}MacroDef[RestoreBlockRegsRet,	at[#1,10,RestoreCallers]];Set[restore.term,	Sub[grM,1] ],{MUST BE Sub[grM,1]}Set[restore.int,	 0],{restore if interrupt }Set[restore.pf,		 2],{restore if page fault}Set[restore.trap,	 3]; {used by Block if trap}Set[restore.BandBLT,	 6]; {used by BandBLT for at BandBLT's point of return to emulator}Set[BLTfini,		0F]; {used by Block, must = F}Set[BLEQfini,		0E]; {used by Block, must = E}{Return points for DstVAMod}MacroDef[DstVAModRet,	at[#1,4,DstVAModRet]];Set[sdWidth,		 2], {for DstVAMod and SrcVAMod}Set[sdBpl,		 1], {DstVAMod and SrcVAMod}Set[Dest,		 3], {for TextBlt to call DstVAMod}{Return points for SrcMap}MacroDef[SrcMapSpecRet,at[#1,10,SrcMapRet]];Set[sdMap,		 0], {for SrcMap and DstMap}Set[argMap,		 1], {for mapping BitBltArg}Set[MapOne,		 2], {for SrcMap and DstMap}Set[MapArg,		 3], {for TextBlt to map TextBltArg}Set[MapSrcBandBLT,	 4], {for BandBLTBBInit SrcMap}Set[Fetch,		 5], {for TextBlt FetchVS subroutine}Set[MapFont,		 7], {for TextBlt to map FontBody pointer, must be 7}{Return points for SaveRandRHRegs}MacroDef[SaveBlockRegsRet,	at[#1,10,SavebbRegsRet]];MacroDef[SavebbRegsRet,		at[#1,10,SavebbRegsRet]];Set[Savebb.BitBlt,	 0]; {Return from SavebbRegs for BitBlt, must = 0}Set[BLT,		 3]; {Block Transfer, must = 3}Set[BLTL,		 7]; {Block Transfer Long, must = 7}Set[BLEL,		 6]; {Block Equal Long, must = 6}Set[BLTLR,		 5]; {Block Transfer Long Reverse, must = 5}Set[BLECL,		0E]; {Block Equal Code Long, must = E}Set[BLTC,		0B]; {Block Transfer Code, must = 0B}Set[BLTCL,		0F]; {Block Transfer Code Long, must = 0F}Set[CKSUM,		 4]; {Checksum  must = 4}Set[Savebb.BLT,BLT]; {Return from SavebbRegs for BLEQ (Block Transfer), must = 3}Set[Savebb.BLTL,BLTL]; {Return from SavebbRegs for BLTL (Block Transfer Long), must = 7}Set[Savebb.BLEL,BLEL]; {Return from SavebbRegs for BLEL (Block Equal Long), must = 6}Set[Savebb.BLECL,BLECL]; {Return from SavebbRegs for BLECL (Block Equal Code Long), must = E}Set[Savebb.BLTC,BLTC]; {Return from SavebbRegs for BLTC (Block Transfer Code), must = 0B}Set[Savebb.BLTCL,BLTCL]; {Return from SavebbRegs for BLTCL (Block Transfer Code Long), must = 0F}Set[Savebb.CKSUM,CKSUM]; {Return from SavebbRegs for CKSUM (Checksum)  must = 4}Set[Savebb.BANDBLT,0C]; {Return from SavebbRegs for BandBlt}Set[Savebb.TXTBLT,0D]; {Return from SavebbRegs for TextBlt}Set[hbs.1, Or[ Xor[0F, 1] , 8 ] ]; {BandBLT initial call}Set[hbs.2, Or[ Xor[0F, 2] , 8 ] ]; {BitBlt initial call}Set[hbs.3, Or[ Xor[0F, 3] , 8 ] ]; {TrapezoidBLT initial call}Set[hbs.C, Or[ Xor[0F, 0C] , 8 ] ]; {BandBLT-BitBlt return from fault or int}Set[hbs.D, Or[ Xor[0F, 0D] , 8 ] ]; {BitBlt return from fault or int}Set[hbs.E, Or[ Xor[0F, 0E] , 8 ] ]; {BandBLT-TrapzBLT return from fault or int}{WARNING:  Any change to hbs.E has to be manually made also to addrBandBLTIntEntry in Extensions.dfn}Set[hbs.F, Or[ Xor[0F, 0F] , 8 ] ]; {TrapzBLT return from fault or int}MacroDef[scDisp,	L0Disp],MacroDef[dfDisp,	L1Disp],MacroDef[dirDisp,	L1Disp],MacroDef[sdDisp,	L2Disp];MacroDef[sfDisp,	L3Disp],MacroDef[grDisp,	L3Disp];MacroDef[sc1DISP,	DISP4[#1,0E]],MacroDef[sc2DISP,	DISP4[#1,03]],MacroDef[sc3DISP,	DISP4[#1,0D]],MacroDef[dirDISP,	DISP4[#1,6]],MacroDef[dfDISP,	DISP4[#1,8]],MacroDef[sfDISP,	DISP3[#1,sf.mask]],MacroDef[grDISP,	DISP3[#1,gr.mask]];MacroDef[sdDISP,	DISP2[#1]];Set[SRaRet,	 2],{rhRet value for SrcLRemap}Set[SRcRet,	 3],{rhRet value for SrcLRemap}Set[DRaRet,	 2],{rhRet value for DstLRemap}Set[DRbRet,	 3],{rhRet value for DstLRemap}Set[ret.L1pcr,	08],{rhRet value for DstLRemap}Set[ret.L2pcr,	09],{rhRet value for DstLRemap}Set[ret.L1Tpcr,	0A],{rhRet value for DstLRemap}Set[StkSize.normal,	 1],{used for HowBigStack}Set[StkSize.interrupt,	 7],{used for HowBigStack}Set[Type.normal,	 0],{value in rhType}Set[Type.LSEP,		 1],{value in rhType}{WARNING:  Any change to Type.LSEP has to be manually made also to addrTrapzReturn in Extensions.dfn}Set[Type.TextBlt,	 4], {value in rhType tells what to do if page fault}Set[type.notsmall,	 7],Set[type.small,5],Set[typeM,8],Set[dtRet.L0,		 0],{constant value for dT}Set[dtRet.L1,		 1],{constant value for dT}Set[dtRet.L3,		 3],{constant value for dT}Set[dtRet.L4,		 4],{used by BandBLT for dT}Set[dtRet.L5,		 5]{used by BandBLT for dT};Set[VAaRet,	 0],{rhRet value for VAModSub}{even, < 8}Set[VAbRet,	 2],{rhRet value for VAModSub}{even, < 8}Set[srcTP,	 4],{rhRet value for VAModSub}{even, < 8}Set[dstTP,	 6],{rhRet value for VAModSub}{even, < 8}Set[NoPgCr,	 0],Set[PgCr,	 2],Set[LCeq0,	 1],Set[dbsb0,	 0],Set[sbneq0,	 1],Set[dbneq0,	 3],;{MAP FLAG BIT DEFINITIONSThese are the bits for flags in the Map entries. Note that Daybreak does not have the dp flag used in Dandelion.}Set[map.referenced, 80];Set[map.dirty, 40];Set[map.writeProtect, 20];Set[map.rd, 0C0];{LOCK WORDS (offsets from IORegion)}Set[mesaHasLock,0];Set[iopRequestsLock,1];{LOCK OPERATIONS}Set[lock.add,08];Set[lock.and,09];Set[lock.or,0A];Set[lock.xchg,0B];Set[lock.wrIfNil,0C];{UP/DOWN NOTIFY WORDS (offsets from Mesa processor's IOR)}Set[notifiersLockMask,0];Set[upNotifyBits,1];Set[downNotifyBits,2];{software lock return branch values}Set[SoftwareLockRets.LOCKMEM,0];Set[SoftwareLockRets.NOTIFYIOP,1];Set[SoftwareLockRets.Interrupt,2];Set[SoftwareLockRets.RB,3];{---------------------------------------------------------}{**	Floating point definitions.  }{	return points for unpack routines}Set[L0.mult1,		00];Set[L0.mult2,		01];Set[L0.mult3,		02];Set[L0.mult4,		03];Set[L0.mult5,		04];Set[L0.add1,		05];Set[L0.sub1,		06];Set[L0.comp1,		07];Set[L0.round1,		08];Set[L0.round4,		09];Set[L0.round5,		0A];Set[L0.FScale1,		0B];Set[L0.unpacklop,	0C];Set[L0.sqrt1,		0D];{return points for denorm routine, DeNormRets, NOTICE: The allocation is only 3 bits wide on the returns, i.e.,          foo, cx, at[L0.mumble,8,DeNormRets]; }Set[L0.add2,		01];Set[L0.rePack1,		02];Set[L0.div1,		03];Set[L0.round2,		04];{Set[L0.add1,		05]; same as above unpack ret, but occupies space in the DeNormRets}Set[L0.round3,		06];Set[L0.denormop,	07];{return points for rounding routine, RoundRets NOTICE: The allocation is only 3 bits wide, see DeNormRets above. }Set[L0.rePack2, 	01]; {must be 1 mod 2}{Set[L0.round2, 	04];  must be same as the above DeNorm ret, but occupy space in the round rets}{floating point trap args}Set[L1.FpT2,		0];Set[L1.FpT1, 		1];Set[L1.FpT1.5,		2];{divide loop return points}Set[L0.div2,		1];Set[L0.div3,		2];{ return points for FixF routine for unpack opcode }Set [L0.FixF0,		0];Set [L0.FixF1,		1];Set[L0.VMFRtn0,		0];Set[L0.VMFRtn1,		1];Set[L0.VMFRtn2,		2];Set[L0.VMFRtn3,		3];Set[L0.VMFRtn4,		4];Set[L1.SaveLFix,	0F]; { NOTE: see mesa.df ! }{---------------------------------------------------------}{Image processing subroutine return points}{L0	LoadTable}MacroDef[LoadTableRet, at[#1,10,LoadTableRtn]];Set[L0.GrBLT,		0];Set[L0.GrSum,		4];Set[L0.GrThreshold,	8];Set[L0.SBTG,		9];{L0	MapSrc}MacroDef[MapSrcRet, at[#1,10,MapSrcRtn]];MacroDef[MapSrcF, at[#1,10,MapSrcFault]];Set[L0.ChainBlt,	7];Set[L0.CountBits,	6];Set[L0.FlipXRight,	0D];Set[L0.FlipXLast,	0F];Set[L0.Floyd,		0C];Set[L0.FloydLoop,	0E];{Set[L0.GrBLT,		0];}Set[L0.GrBLTTRC,	1];Set[L0.GrBLTLoop,	3];{Set[L0.GrSum,		4];}Set[L0.GrSumLoop,	5];{Set[L0.GrThreshold,	8];}Set[L0.GrThresholdLoop,	0A];Set[L0.GrThresholdExtra,0B];Set[L0.LineBreak,	2];{Set[L0.SBTG,		9];}{L0	MapDst}MacroDef[MapDstRet, at[#1,10,MapDstRtn]];MacroDef[MapDstF, at[#1,10,MapDstFault]];Set[L0.BLTLineGray,	1];{Set[L0.FlipXLast,	0F];}Set[L0.FloydErrBuf,	0D];{Set[L0.FloydLoop,	0E];}Set[L0.FloydLoopErrBuf,	0C];{Set[L0.GrBLT,		0];}{Set[L0.GrBLTLoop,	3];}{Set[L0.GrThreshold,	8];}{Set[L0.GrThresholdLoop,0A];}{Set[L0.GrThresholdExtra,0B];}{Set[L0.LineBreak,	2];}{Set[L0.SBTG,		9];}{L1	BumpByteVA}MacroDef[BumpByteVARet, at[#1,10,BumpByteVARtn]];Set[L1.GrBLTDstEOL,	0];Set[L1.GrBLTSrcEOL,	1];Set[L1.GrBLTAdjDst,	2];Set[L1.GrBLTDstNextItem,3];Set[L1.GrThresholdAdjDst,4];Set[L1.GrThresholdDstNextItem,5];Set[L1.GrAdjSrc,	6];Set[L1.GrSrcNextItem,	7];Set[L1.GrSrcPageCross,	8];Set[L1.GrDstPageCross,	9];{L0	LRotateN}MacroDef[LRotateNRet, at[#1,10,RMaskNRtn]];{Set[L0.BLTLineGray,	1];}{Set[L0.GrThreshold,	8];}Set[L0.fCaseData,	6];{Set[L0.SBTG,		9];}{L0	RMaskN}MacroDef[RMaskNRet, at[#1,10,RMaskNRtn]];Set[L0.BLTLineGrayStart,0];Set[L0.BLTLineGrayUnique,2];Set[L0.BLTLineGrayEnd,	3];Set[L0.iCaseMask,	7];{L1	LinkSet}MacroDef[LinkSetRet, at[#1,10,LinkSetRtn]];Set[L1.GrBLTSetL2,	0];Set[L1.GrBLTSetL3,	1];Set[L1.GrBLTSetL4,	2];Set[L1.GrBLTSetL5,	3];Set[L1.GrBLTAdjL3,	0C]; {must equal 0C}Set[L1.GrBLTAdjL5,	0D];{L3	BltLineGray}Set[L3.ChainBltBLG,	6];Set[L3.TrapzBLG,	3];{L3	ComMap}Set[L3.ChainBlt,	4];Set[L3.FlipX,		0D];Set[L3.FloydSrc,	5];Set[L3.FloydDst,	6];Set[L3.FloydErrBuf,	7];Set[L3.HTsrcMap,	0B];Set[L3.HTlineMap,	0C];Set[L3.HTdstMap,	0A];Set[L3.SBTGDst,		8];Set[L3.SBTGSrc,		9];Set[L3.TrapzArg,	0];Set[L3.TrapzSrc,	1];Set[L3.TrapzDst,	2];{L4	BumpBitAddress}Set[L4.BumpBitAddress,	0];Set[L4.ChainBlt,	9];Set[L4.SBTG,		0D];Set[L4.TrapzLoop,	4];Set[L4.TrapzBump,	5];{************************************************               Pilot 15 Constants ************************************************}{* FastXfer }{Xfer Type - Link 4}MacroDef[XT,	 at[#1,10,XferType]];Set[L4.XTRet,		 0];Set[L4.XTCall,		 1];Set[L4.XTLfc,		 2];Set[L4.XTPort,		 3];Set[L4.XTXfer,		 4];Set[L4.XTTrap,		 5];Set[L4.XTPSwitch,	 6];{L0	XFERRMFRtn}MacroDef[XFERRMFRet, at[#1,10,XFERRMFRtn]];Set[L0.CXCode,		02]; {must be even}Set[L0.RXCode,		04]; {must be even}{L0	XFERRLMFRtn}MacroDef[XFERRLMFRet, at[#1,10,XFERRLMFRtn]];{L0	XFERWMFRtn}MacroDef[XFERWMFRet, at[#1,10,XFERWMFRtn]];{L0	GMFRtn}MacroDef[GMFRet, at[#1,10,GMFRtn]];Set[L0.RLGC,		06]; {must be even}Set[L0.LGC,		0E]; {must be even}{L0	CALLRLMFRtn}MacroDef[CALLRLMFRet, at[#1,10,CALLRLMFRtn]];{XIndirect returns - Link 2; relative to XIDRtn}MacroDef[XIDr, at[#1,10,XIDRtn]];Set[L2.CXIndirect,0A];Set[L2.RXIndirect,0C];{* VMFind }Set[pRunFirst, 14'd];Set[RunSize, 14'd];Set[indexRunFirst, 1];Set[FALSE, 0];Set[TRUE, 1];Set[L0.0, 0];Set[L0.2, 2];Set[L0.4, 4];{*Ring buffer constants}Set[DisplayBankMask,1F]; {non-flag bits in high part of memory address}{*BitBlt ring buffer entry types (L7)}Set[RBEntryNone,0];Set[RBEntryRectangle,1];Set[RBEntryBlock,2];Set[RBEntryPattern,3];Set[RBEntryUnknown,4];Set[RBEntU,Sub[RBEntryUnknown,1]];Set[RBEntN,Or[RBEntryNone,RBEntryUnknown]];Set[RBEntR,Or[RBEntryRectangle,RBEntryUnknown]];Set[RBEntB,Or[RBEntryBlock,RBEntryUnknown]];Set[RBEntP,Or[RBEntryPattern,RBEntryUnknown]];{*Ring buffer subroutine returns (L5)}Set[RBBitBltInit,0]; {must be <8}Set[RBBitBltPat01,1]; {must be <8}Set[RBBitBltPat23OrSrc,2]; {must be <8}Set[RBBitBltDst,3]; {must be <8}Set[RBBitBltFault,8]; {must be >=8 and even}Set[RBBitBltInt,9]; {must be >=8}Set[RBBitBltDone,0B]; {must be >=8 and odd; don't use preceeding value}Set[RBWrite,0D]; {must be >=8 and odd; don't use preceeding value}Set[RBWriteString,0E]; {must be >=8}Set[RBWaitPatOrBlock,0];{END}
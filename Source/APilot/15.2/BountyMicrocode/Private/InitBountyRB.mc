{InitBounty.mcLast Revised:JPM, 21-Sep-91  9:46:33 Change register namesJPM, 11-Jul-91 13:21:54 Revise for FIFO simulation setupJPM, 19-Mar-91 12:43:52 Search vm map for start of IORegion (a la ProcessorHeadBounty)JPM,  5-Dec-90  9:11:26 Add initialization of uTimerType (for sharing emulator with Duke)JPM, 25-Jan-90 12:20:00 Removed timer controlsJPM, 25-Oct-89 11:50:18 Added init of regs for VMFindJPM,  3-Aug-89 16:11:22 Created from InitDaybreak.mc}{ 	Copyright (C) 1989, 1990, 1991 by Xerox Corporation.  All rights reserved.}StartAddress[BootTrap];Set[offsetMaintPanel, Lshift[1,1]];Set[offsetMesaProc, Lshift[2,1]];{Get here when the boot button is pushed, or somebody yanks on INIT/.}BootTrap: {From trap branch in Refill.mc}	ClrIntErr, ClrLOCK, CANCELBR[$,0F]  {must be c1},	c1, at[0];	ClrMPIntIOP,						c2;	G ¬ 0, uPCCross ¬ 0,					c3;	UBrkByte ¬ 0,						c1;	T ¬ 1,							c2;	uWDC ¬ T, ClrIE, {disable interrupts}			c3;SetupConstants:	TT ¬ RShift1 0, SE ¬ 1,					c1;	u8000 ¬ TT,						c2;	TT ¬ LShift1 0FF, SE¬1,					c3;	TT ¬ LShift1 TT, SE¬1,					c1;	TT ¬ TT LShift1, SE¬1,					c2;	u7FF ¬ TT, TT ¬ TT LShift1, SE ¬ 1,			c3;	TT ¬ TT LShift1, SE ¬ 1,				c1;	u1FFF ¬ TT, TT ¬ TT LShift1, SE ¬ 1,			c2;	u3FFF ¬ TT,						c3;	TT ¬ 01F,						c1;	TT ¬ TT LRot8,						c2;	TT ¬ TT or 0F8,						c3;	uPMask ¬ TT, {1FF8}					c1;	uPMask2 ¬ TT,						c2;	r0100 ¬ 0FF + 1, {0100}					c3;	TT ¬ 64,						c1;	TT ¬ TT LRot8,						c2;	UtbFlags ¬ TT, {6400}					c3;	TT ¬ 0E0,						c1;	TT ¬ TT LRot8,						c2;	uPPMask ¬ TT, {E000}					c3;	rRingBuf ¬ 0F4,						c1;	rRingBuf ¬ rRingBuf LRot8, {F400}			c2;	rhRingBuf ¬ 0,						c3;	MAR ¬ [rhRingBuf, rRingBuf + 2],			c1;	TT ¬ rRingBuf + 6, CANCELBR[$,0],			c2;	Q ¬ MD,							c3;	uRingBufEnd ¬ Q,					c1;	uRingBufPos ¬ TT, {F406}				c2;	uRingBufEntry ¬ TT, {F406}				c3;{ The following code is similar to the FindIORegionPtr proc in ProcessorHeadBounty.  It assumes virtual page 255 is the last page in the IORegion,  and steps backwards until it finds a non-contiguous real page;  the IORegionPtr is then set to the beginning of the run of contiguous real pages.}FindIORegionPtr:	rhIORgn ¬ 0,						c1;	rIORgn ¬ 0FF,						c2;	rIORgn ¬ rIORgn LRot8, {IORgn virt addr <= 0FF00}	c3;	Map ¬ [rhIORgn, rIORgn + 0],				c1;	Noop,							c2;	TT ¬ MD,						c3;FindIORegionLoop:	Map ¬ rIORgn ¬ [rhIORgn, rIORgn - r0100],		c1;	Q ¬ TT - r0100, {decrement page number in hi byte}	c2;	Rx ¬ MD,						c3;	[] ¬ Q xor Rx, NZeroBr, {compare map to expected value, branch if not equal} c1;	Q ¬ ~0FF, BRANCH[$,FindIORegionEnd],			c2;	TT ¬ TT - r0100, GOTO[FindIORegionLoop], {this page OK}	c3;FindIORegionEnd:	rhIORgn ¬ TT LRot0, rIORgn ¬ TT and Q, {set real addr}	c3;	Rx ¬ Rx and Q, {get display control addr}		c1;	Rx ¬ Rx + 8, {end of control block}			c2;	rDisplayLimit ¬ Rx,					c3;	MAR ¬ [rhIORgn, rIORgn + offsetMaintPanel],		c1;	uIORgnHigh ¬ TT xor rIORgn, CANCELBR[$,0],		c2;	TT ¬ MD,						c3;	MAR ¬ [rhIORgn, rIORgn + offsetMesaProc],		c1;	uMaintPanel ¬ TT, CANCELBR[$,0],			c2;	TT ¬ MD,						c3;	MAPA ¬ 4, {VM map real addr = 40000H}			c1;	uMesaProc ¬ TT,						c2;	T ¬ 1,							c3;SetUpEmulatorRegs:	temp ¬ pRunFirst,					c1;	uRunMru ¬ temp,						c2;	uTimerType ¬ T,						c3;	rhT ¬ xtFC0,						c1;	UvMDS ¬ T ¬ 0,						c2;	rhMDS ¬ 0, TOS ¬ 0,					c3;	uGFI ¬ Q ¬ 0,						c1;	uIdleCountLow ¬ 0,					c2;	uIdleCountHigh ¬ 0,					c3;	UvG ¬ rInt ¬ 0,						c1;	uXTS ¬ stackP ¬ T, 					c2;	uWP ¬ T, PC ¬ T + 0 + 1{use carry}, SetMPIntIOP,	c3;	TT ¬ 0FF LShift1, SE ¬ 1, {1FF}				c1;	T ¬ TT + 3{@SD[sBoot]},					c2;	uDestLo ¬ T, L ¬ 0, ClrMPIntIOP,			c3;{initialization done, now loop until OS/2 halts the CP}{emulator will resume from this address}Linkage:	GOTOABS[addrLinkage],					c1{c*}, at[addrLinkage];
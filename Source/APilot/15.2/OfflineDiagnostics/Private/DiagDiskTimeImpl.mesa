-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- File: DiagDiskTimeImpl.mesa-- Last edited -  TXM, 19-May-89 19:52:33-- DIRECTORY DiagDiskMkTime		USING	[mkTime], DiagDiskTime		USING	[LocalTime], Inline			USING	[LongNumber], OfflineDiagInterface	USING	[ARow, PutData,				 FixedPositionDisplayRecord,				 GetAFixedPositionDisplayRecord, GetAHelpText,				 GetANumber, GetARow,				 GetYesNo, HelpText,				 PutTestParameters, PutMessage], OthelloOps		USING	[GetTimeFromTimeServer, IsTimeValid,				 SetProcessorTime, TimeServerError], PhysicalVolume		USING	[ID], Process		USING	[Pause], String			USING	[AppendString], System			USING	[WestEast, GetGreenwichMeanTime,				 GreenwichMeanTime, LocalTimeParameters,				 SetLocalTimeParameters], Time			USING	[Append, Pack, Unpack, Unpacked];				 				  DiagDiskTimeImpl: PROGRAM    IMPORTS	DiagDiskMkTime,	OfflineDiagInterface,	OthelloOps,	Process,	String,	System,	Time    EXPORTS	DiagDiskTime = BEGIN    OPEN	DiagDiskMkTime,	Odi: OfflineDiagInterface;				  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SIGNALS  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~				  RealTimeClockFailure:	PUBLIC ERROR = CODE;				 				  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  VARIABLES  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  BaseYear:		CARDINAL = 1968; DaysInFourYears:	CARDINAL = 4*365+1; gmt:			System.GreenwichMeanTime; ltp:			System.LocalTimeParameters; LTPOk:			PUBLIC BOOLEAN ¬ FALSE; MonthTable:		ARRAY [0..12] OF CARDINAL =				[0, 31, 60, 91, 121, 152, 182,				213, 244, 274, 305, 335, 366]; Number:		TYPE = Inline.LongNumber; RTCOk:			PUBLIC BOOLEAN ¬ FALSE; StartWeekDay:		CARDINAL = 0; -- Jan. 1, 1968 was a Monday timeString:		STRING = [31]; TP:			TYPE = RECORD [				beginDST, endDST: CARDINAL,				zone, zoneMinutes: INTEGER]; Unpacked:		TYPE = Time.Unpacked; UP:			TYPE = POINTER TO Unpacked; weekday:		ARRAY [0..6] OF LONG STRING =				[mkTime[weekDayMon],				 mkTime[weekDayTue],				 mkTime[weekDayWed],				 mkTime[weekDayThu],				 mkTime[weekDayFri],				 mkTime[weekDaySat],				 mkTime[weekDaySun]];  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  PROCEDURES  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  AppendTime: PROCEDURE [s: STRING, time: System.GreenwichMeanTime] = BEGIN unpacked:	Time.Unpacked;  Time.Append [s: s, unpacked: (unpacked ¬ Time.Unpack[time]), zone: TRUE]; String.AppendString [to: s, from: " "L]; String.AppendString [to: s, from: mkTime[startPlusOrMin]]; String.AppendString [to: s, from: weekday[unpacked.weekday]]; String.AppendString [to: s, from: mkTime[endPlusOrMin]]; END;    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  CheckDateGE: PROCEDURE [u: UP, dstDay, dstHour: INTEGER] RETURNS [BOOLEAN] =BEGIN weekday: INTEGER ¬ u.weekday; day: INTEGER = MonthTable[u.month] + u.day; RETURN[	IF day < dstDay-6 THEN FALSE	ELSE IF day > dstDay THEN TRUE	ELSE IF weekday = 6 THEN u.hour >= dstHour	ELSE day-weekday > dstDay-6] END;	 -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to get present date and time from Real Time Clock -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	 GetLocalTime:  PUBLIC PROCEDURE [timeString: STRING --31 chars min--] = BEGIN	 IF OthelloOps.IsTimeValid[] THEN {    gmt ¬ System.GetGreenwichMeanTime[];    timeString.length¬ 0;    AppendTime [s: timeString, time: gmt]}       ELSE ERROR RealTimeClockFailure;     END;     -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to get present date and time from user -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     GetLocalTimeFromUser:  PUBLIC PROCEDURE RETURNS [lt: DiagDiskTime.LocalTime] = BEGIN testParmRecordPtr:	LONG POINTER TO Odi.FixedPositionDisplayRecord; paramRow0:		LONG POINTER TO Odi.ARow; helpTextPtr:		LONG POINTER TO Odi.HelpText ¬ 				Odi.GetAHelpText[numberOfLines: 1];-- gooddate:		BOOLEAN¬ FALSE;-- goodtime:		BOOLEAN¬ FALSE;  testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [1]; testParmRecordPtr.rows[0]¬		paramRow0 ¬ Odi.GetARow [1];    -- UNTIL gooddate DO   testParmRecordPtr.displayTitle¬	mkTime[dateRequirem];   testParmRecordPtr.numberOfRows¬	1;   paramRow0.rowItems[0].namePosition ¬ 1;   paramRow0.rowItems[0].name ¬ mkTime[enterQuestForExpl];   paramRow0.rowItems[0].stringValue ¬ NIL;   paramRow0.rowItems[0].valuePosition ¬ 0;   paramRow0.rowItems[0].value ¬ 0;   Odi.PutTestParameters [parameters: testParmRecordPtr, upDateOnly: FALSE];      Odi.PutMessage[message: " "];    -- get the year   helpTextPtr.helpTitle¬ " ";   helpTextPtr.textBody[0]¬ mkTime[supportedYears];   lt.year ¬ Odi.GetANumber [		prompt: mkTime[presentYear],		lowLimit: 1982,		upperLimit: 2050, 		help: helpTextPtr].number;   Odi.PutData[ data: mkTime[year],		numberAfterData: lt.year,		clearHeadingAndData: TRUE];   Odi.PutData[data: mkTime[comma]];				   -- get the month   helpTextPtr.textBody[0]¬ mkTime[supportedMonths];   lt.month ¬ Odi.GetANumber [		prompt: mkTime[presentMonth],		lowLimit: 1,		upperLimit: 12, 		help: helpTextPtr].number;   lt.month¬ lt.month-1; --adjust the month   Odi.PutData[ data: mkTime[month],		numberAfterData: lt.month+1];   Odi.PutData[data: mkTime[comma]];	   -- get the day   helpTextPtr.textBody[0]¬ mkTime[supportedDays];   lt.day ¬ Odi.GetANumber [		prompt: mkTime[presentDay],		lowLimit: 1,		upperLimit: 31, 		help: helpTextPtr].number;   Odi.PutData[ data: mkTime[day],		numberAfterData: lt.day];       << IF NOT Odi.GetYesNo [		prompt: mkTime[dateCorrectQuest]] THEN   { Odi.PutData[clearHeadingAndData: TRUE];     Odi.PutMessage[clearMessageAreaFirst: TRUE];     LOOP;   } ELSE gooddate¬ TRUE; ENDLOOP;>>   Process.Pause [50];-- UNTIL goodtime DO          -- display title   testParmRecordPtr.displayTitle¬ mkTime[timeRequirem];   testParmRecordPtr.numberOfRows¬ 1;      paramRow0.rowItems[0].namePosition ¬ 1;   paramRow0.rowItems[0].name ¬ mkTime[enterQuestForExpl];   paramRow0.rowItems[0].stringValue ¬ NIL;   paramRow0.rowItems[0].valuePosition ¬ 0;   paramRow0.rowItems[0].value ¬ 0;   Odi.PutTestParameters [parameters: testParmRecordPtr, upDateOnly: FALSE];   Odi.PutMessage[message: " "];           -- get the hour   helpTextPtr.textBody[0]¬ mkTime[supportedHours];      lt.hour ¬ Odi.GetANumber [		prompt: mkTime[Hour],		lowLimit: 0,		upperLimit: 23, 		help: helpTextPtr].number;   Odi.PutData[ data: mkTime[Hour],		numberAfterData: lt.hour,		clearHeadingAndData: TRUE];   Odi.PutData[data: mkTime[comma]];		          -- get the minutes   helpTextPtr.textBody[0]¬ mkTime[supportedMinutes];   lt.minute ¬ Odi.GetANumber [		prompt: mkTime[Minute],		lowLimit: 0,		upperLimit: 59, 		help: helpTextPtr].number;   Odi.PutData[ data: mkTime[Minute],		numberAfterData: lt.minute];   Odi.PutData[data: mkTime[comma]];		    <<  -- get the seconds   helpTextPtr.textBody[0]¬ mkTime[supportedSeconds];   lt.second ¬ Odi.GetANumber [		prompt: mkTime[Second],		lowLimit: 0,		upperLimit: 59, 		help: helpTextPtr].number;   Odi.PutData[ data: mkTime[Second],		numberAfterData: lt.second];>>   lt.second ¬ 0;	-- Default	<< IF NOT Odi.GetYesNo [		prompt: mkTime[timeCorrect]] THEN   { Odi.PutData[clearHeadingAndData: TRUE];     Odi.PutMessage[clearMessageAreaFirst: TRUE];     LOOP;    } ELSE goodtime¬ TRUE; ENDLOOP;>>   Process.Pause [50];	 END;  -- GetLocalTimeFromUser --	 -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to get Local Time Parameters from the user -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	 GetLTPFromUser:  PUBLIC PROCEDURE RETURNS [ltp: System.LocalTimeParameters] =BEGIN testParmRecordPtr:	LONG POINTER TO Odi.FixedPositionDisplayRecord; paramRow0:		LONG POINTER TO Odi.ARow; helpTextPtr:		LONG POINTER TO Odi.HelpText ¬ 				Odi.GetAHelpText[numberOfLines: 15];		 testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [1]; testParmRecordPtr.displayTitle¬	mkTime[localDaylightTReq]; testParmRecordPtr.numberOfRows¬	1; testParmRecordPtr.rows[0]¬		paramRow0 ¬ Odi.GetARow [1];    paramRow0.rowItems[0].namePosition ¬ 1; paramRow0.rowItems[0].name ¬ mkTime[enterQuestForExpl]; paramRow0.rowItems[0].stringValue ¬ NIL; paramRow0.rowItems[0].valuePosition ¬ 0; paramRow0.rowItems[0].value ¬ 0;    Odi.PutTestParameters [parameters: testParmRecordPtr, upDateOnly: FALSE]; 	 --get starting/ending day of daylight savings time helpTextPtr.helpTitle¬ " "; helpTextPtr.textBody[00]¬ mkTime[localDaylightTExpl1]; helpTextPtr.textBody[01]¬ mkTime[localDaylightTExpl2]; helpTextPtr.textBody[02]¬ mkTime[localDaylightTExpl3]; helpTextPtr.textBody[03]¬ mkTime[localDaylightTExpl4]; helpTextPtr.textBody[04]¬ mkTime[localDaylightTExpl5]; helpTextPtr.textBody[05]¬ mkTime[localDaylightTExpl6]; helpTextPtr.textBody[06]¬ mkTime[localDaylightTExpl7]; helpTextPtr.textBody[07]¬ mkTime[localDaylightTExpl8]; helpTextPtr.textBody[08]¬ mkTime[localDaylightTExpl9]; helpTextPtr.textBody[09]¬ mkTime[localDaylightTExpl10]; helpTextPtr.textBody[10]¬ mkTime[localDaylightTExpl11]; helpTextPtr.textBody[11]¬ mkTime[localDaylightTExpl12]; helpTextPtr.textBody[12]¬ mkTime[localDaylightTExpl13]; helpTextPtr.textBody[13]¬ mkTime[localDaylightTExpl14]; helpTextPtr.textBody[14]¬ mkTime[localDaylightTExpl15];    Odi.PutMessage[message: " "]; ltp.beginDST ¬ Odi.GetANumber [		prompt: mkTime[firstDayDST],		lowLimit: 0,		upperLimit: 366, 		defaultNumber: 0, -- No DST		help: helpTextPtr].number;   ltp.endDST ¬ Odi.GetANumber [		prompt: mkTime[lastDayDST],		lowLimit: 0,		upperLimit: 366, 		defaultNumber: 0, -- No DST		help: helpTextPtr].number;       [dir: ltp.direction, zone: ltp.zone, zoneMin: ltp.zoneMinutes]¬ GetTimeZone [];    END;  -- GetLTPFromUser --  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   GetTimeZone:  PROCEDURE 		RETURNS [			dir: System.WestEast,			zone: [0..12],			zoneMin: [0..59]] = BEGIN testParmRecordPtr:	LONG POINTER TO Odi.FixedPositionDisplayRecord; paramRow0:		LONG POINTER TO Odi.ARow; helpTextPtr:		LONG POINTER TO Odi.HelpText ¬ 				Odi.GetAHelpText[numberOfLines: 8]; pos:			BOOLEAN; timeZone:		INTEGER; testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [1]; testParmRecordPtr.displayTitle¬	mkTime[localTimeZoneReq]; testParmRecordPtr.numberOfRows¬	1; testParmRecordPtr.rows[0]¬		paramRow0 ¬ Odi.GetARow [1]; paramRow0.rowItems[0].namePosition ¬ 1; paramRow0.rowItems[0].name ¬ mkTime[enterQuestForExpl]; paramRow0.rowItems[0].stringValue ¬ NIL; paramRow0.rowItems[0].valuePosition ¬ 0; paramRow0.rowItems[0].value ¬ 0;  Odi.PutTestParameters [parameters: testParmRecordPtr, upDateOnly: FALSE];     -- get local time offset from Greenwich helpTextPtr.helpTitle¬ " "; helpTextPtr.textBody[00]¬ mkTime[localTimeZoneExpl1]; helpTextPtr.textBody[01]¬ mkTime[localTimeZoneExpl2]; helpTextPtr.textBody[02]¬ mkTime[localTimeZoneExpl3]; helpTextPtr.textBody[03]¬ mkTime[localTimeZoneExpl4]; helpTextPtr.textBody[04]¬ mkTime[localTimeZoneExpl5]; helpTextPtr.textBody[05]¬ mkTime[localTimeZoneExpl6]; helpTextPtr.textBody[06]¬ mkTime[localTimeZoneExpl7]; helpTextPtr.textBody[07]¬ mkTime[localTimeZoneExpl8]; Odi.PutMessage[message: " "];    [number: timeZone, foreward: pos] ¬ Odi.GetANumber [		prompt: mkTime[timeZoneOffset],		lowLimit: 0,		upperLimit: 12, 		defaultNumber: 9, -- Japan		help: helpTextPtr];   dir ¬ IF NOT pos THEN west ELSE east;   zone ¬ ABS[timeZone];	   -- get local minutes offset from Greenwich   helpTextPtr¬ Odi.GetAHelpText[numberOfLines: 2];   helpTextPtr.helpTitle¬ " ";   helpTextPtr.textBody[00]¬ mkTime[minutesOffsetExpl1];   helpTextPtr.textBody[01]¬ mkTime[minutesOffsetExpl2];   zoneMin¬ Odi.GetANumber [		prompt: mkTime[minutesOffset],		lowLimit: 0,		upperLimit: 59, 		defaultNumber: 0,		help: helpTextPtr].number;   END;  -- GetTimeZone --     -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to write the local time parameters on disk -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    SetLTP: PUBLIC PROCEDURE [pvID: PhysicalVolume.ID] = BEGIN      IF NOT RTCOk THEN SetRealTimeClock [			displayMsg: FALSE];  System.SetLocalTimeParameters[params: ltp, pvID: pvID];    END;  -- SetLTP --     -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to set the system Real Time Clock with the gotten GreenwichMeanTime -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   SetRealTimeClock: PUBLIC PROCEDURE [			displayMsg: BOOLEAN¬ FALSE,			timeFromServerOnly: BOOLEAN¬ FALSE] =BEGIN badtimecount:		INTEGER ¬ 3; goodtime:		BOOLEAN¬ FALSE; firstGetTime:		BOOLEAN¬ TRUE; timeFromServerOk:	BOOLEAN¬ TRUE; timeRetry:		INTEGER ¬ 3; testParmRecordPtr:	LONG POINTER TO Odi.FixedPositionDisplayRecord; paramRow0:		LONG POINTER TO Odi.ARow;   -- return if the time was allready set IF RTCOk AND LTPOk THEN RETURN; testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [1]; testParmRecordPtr.rows[0]¬		paramRow0 ¬ Odi.GetARow [1]; testParmRecordPtr.displayTitle¬	mkTime[timeRequired]; testParmRecordPtr.numberOfRows¬	1; paramRow0.rowItems[0].namePosition ¬ 1; paramRow0.rowItems[0].name ¬ mkTime[gettingTime]; paramRow0.rowItems[0].stringValue ¬ NIL; paramRow0.rowItems[0].valuePosition ¬ 0; paramRow0.rowItems[0].value ¬ 0; Odi.PutTestParameters [parameters: testParmRecordPtr, upDateOnly: FALSE];    Odi.PutMessage[message: " "];  UNTIL goodtime OR timeRetry<=0 DO   [serverTime: gmt, serverLTPs: ltp] ¬ OthelloOps.GetTimeFromTimeServer[!      OthelloOps.TimeServerError =>       SELECT error FROM       noResponse, noCommunicationFacilities=>	  IF (timeRetry ¬ timeRetry-1)<=0 THEN	  { timeFromServerOk ¬ FALSE;            IF displayMsg THEN	    { Odi.PutMessage[message: mkTime[noRespFromServer],			     startWithNewLine: TRUE];              Process.Pause [75];	    };             CONTINUE;	  } ELSE RETRY;       ENDCASE => ERROR];   IF timeRetry> 0 THEN   { goodtime¬ TRUE;   timeFromServerOk¬ TRUE;   }; ENDLOOP; --timeRetry<=0  IF timeFromServerOk THEN { System.SetLocalTimeParameters[params: ltp];   OthelloOps.SetProcessorTime[time: gmt];   IF OthelloOps.IsTimeValid[] THEN   { LTPOk ¬ TRUE;     RTCOk¬ TRUE;     RETURN;   } ELSE ERROR RealTimeClockFailure; };  --time from time server was unsuccessful IF timeFromServerOnly THEN RETURN;  UNTIL goodtime DO   --get time from processor   IF firstGetTime AND OthelloOps.IsTimeValid[] THEN --returns valid   { ltp¬  GetLTPFromUser [];     System.SetLocalTimeParameters[params: ltp];     LTPOk ¬ TRUE;     RTCOk¬ TRUE;   } ELSE     --get the time from the user   { localTime: DiagDiskTime.LocalTime;     ltp¬  GetLTPFromUser [];     localTime¬  GetLocalTimeFromUser [];     gmt¬ Time.Pack [unpacked: [		 year: localTime.year,		 month: localTime.month,		 day: localTime.day,		 hour: localTime.hour,		 minute: localTime.minute,		 second: localTime.second,		 weekday: NULL,		 dst: NULL,		 zone: ltp],	       useSystemLTP: FALSE];     System.SetLocalTimeParameters[params: ltp];     OthelloOps.SetProcessorTime[time: gmt];     IF OthelloOps.IsTimeValid[] THEN     { LTPOk ¬ TRUE;       RTCOk¬ TRUE     } ELSE ERROR RealTimeClockFailure;   };   firstGetTime ¬ FALSE;   -- check if the time is ok with the operator   { GetLocalTime [timeString];     Odi.PutData[clearHeadingAndData: TRUE];     Odi.PutMessage[message: timeString,		  clearMessageAreaFirst: TRUE];     IF Odi.GetYesNo [prompt: mkTime[dateTimeCorr]] THEN       goodtime¬ TRUE ELSE     { RTCOk¬ FALSE;       LTPOk¬ FALSE;       Odi.PutData[clearHeadingAndData: TRUE];       Odi.PutMessage[clearMessageAreaFirst: TRUE];     };   };   ENDLOOP; -- until goodtime	   END;  -- SetRealTimeClock --	   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   TimeParameters: PROCEDURE RETURNS [TP] =BEGIN p: TP ¬ [	beginDST: ltp.beginDST, endDST: ltp.endDST,	zone: ltp.zone, zoneMinutes: ltp.zoneMinutes]; IF ltp.direction # west THEN    {p.zone ¬ -p.zone; p.zoneMinutes ¬ -p.zoneMinutes}; RETURN[p] END;  END...--of DiagDiskTimeImpl.mesaLOG17-Apr-89 10:39:01, TXM, changed beginDST and endDST lowLimit to 019-May-89 19:52:33, TXM, changed default number to Japan in GetLTPFromUser			 deleted the seconds and confirmation input in GetLocalTimeFromUser
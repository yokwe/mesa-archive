-- File: OfflineDiagTTYImplDove.mesa. -- Last edited on    20-Mar-87  9:49:22 by  KXW---- Copyright (C) 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved.---- Due to severe space constraints, unnecessary features are removed. This-- module is a stripped down version of oldOfflineDiagTTYImplDove.mesa--DIRECTORY  BitBlt 		USING [AlignedBBTable, BBptr, BBTableSpace, BITBLT,  			       DstFunc, BitBltFlags, SrcDesc, GrayParm],  Environment 		USING [BitAddress, Block, Byte, bitsPerWord],  Inline 		USING [LongMult],  Process 		USING [Detach, EnableAborts, SetPriority, Yield],  ProcessPriorities	USING [priorityIOHigh],  Runtime 		USING [GetTableBase, Interrupt],  SpecialSpace 		USING [MakeGlobalFrameResident,    			       MakeProcedureResident, SpecialError],  Stream 		USING [defaultObject, GetProcedure, Handle, Object,     			       PutProcedure, SendAttentionProcedure,     			       SetSSTProcedure, WaitAttentionProcedure],  TTY			USING [Handle, OutOfInstances],  TTYConstants 		USING [aborted, blinkDisplay, normal, notAborted,  			       removeChars],  UserTerminal		USING [mouse, SetMousePosition, screenWidth, screenHeight,    			       BlinkDisplay, SetState, GetBitBltTable,    			       SetBackground, keyboard, WaitForScanLine,   			       Coordinate, CursorArray, SetCursorPosition,			       SetCursorPattern, SetBorder],  KeyStations 		USING [KeyStation, KeyBits, DownUp],  OfflineDiagTTYDove	USING [xRange, yRange, TTYMode, KeyDescriptor,  			       diagKeyBoard];    OfflineDiagTTYImplDove: MONITOR   		  LOCKS m USING m: POINTER TO MONITORLOCK  IMPORTS BitBlt, Inline, Process, Runtime, SpecialSpace, Stream, UserTerminal,           TTY, OfflineDiagTTYDove  EXPORTS TTY, OfflineDiagTTYDove =BEGIN OPEN Dtty: OfflineDiagTTYDove,	   Env: Environment,	   Term: UserTerminal;  screenLock:   MONITORLOCK;  keyboardLock: MONITORLOCK;-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Common Definitions-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  CHAR: TYPE = CHARACTER;  ControlA:    CHARACTER = 'A - 100B;  BS:          CHARACTER = 10C;       -- Non-destructive backspace.  TAB:         CHARACTER = 11C;  CR:          CHARACTER = 15C;  SP:          CHARACTER = ' ;  DEL:         CHARACTER = 177C;  rubOut:      CHARACTER = 177C;      -- Destuctive back space (RubOut).  ControlZ:    CHARACTER = 'Z - 100B; -- Home and clear screen (ClearScreen).  CLFC:        CHARACTER = 34C;       -- ­\ Clears line starting from carret -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- FONT Definitions and variables-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~font: LONG POINTER TO MACHINE DEPENDENT RECORD [  -- Strike Header  newStyle(0:0..0): BOOLEAN,  indexed(0:1..1):  BOOLEAN,  fixed(0:2..2):    BOOLEAN,  kerned(0:3..3):   BOOLEAN,  pad(0:4..15):     [0..7777B],  min(1):           CHARACTER,   -- First char in font  max(2):           CHARACTER,   -- Last char in font  maxwidth(3):      CARDINAL,  -- Width of characters in font  -- Strike Body  length(4):        CARDINAL,  -- Total number of words in the Strike Body.  ascent(5):        CARDINAL,  -- Ascent + Descent = Character height.  descent(6):       CARDINAL,  xoffset(7):       CARDINAL,  -- 0.  raster(8):        CARDINAL,  -- Number of words per scan-line in the Strike.  chars(9:0..63):  SELECT OVERLAID * FROM    hasBoundingBox => [      boundingBox(9:0..63): RECORD [        FontBBox, FontBBoy, FontBBdx, FontBBDy: INTEGER],      BBBitmap(13):         ARRAY [0..0) OF WORD],    noBoundingBox => [      -- A large bitmap of height scanlines      bitmap(9):            ARRAY [0..0) OF WORD], -- (ascent+descent) scanlines    ENDCASE] = GetFont[];			    bitmap: LONG POINTER = IF font.kerned THEN @font.BBBitmap ELSE @font.bitmap;-- Height of a character in Strike.  charHeight: PUBLIC CARDINAL = font.ascent+font.descent;  wordSize: CARDINAL = Environment.bitsPerWord;-- Pointer into the Strike Body, indexed by character codes.   xInSegment: LONG POINTER TO ARRAY CHARACTER [0C..0C) OF CARDINAL =              bitmap + font.raster*charHeight - (font.min-0C);-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Keyboard Definitions and Constants-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  keyCount: CARDINAL = LAST[KeyStations.KeyStation];  -- Number of keys  old, new: KeyStations.KeyBits;  oldKeys: PUBLIC LONG POINTER TO KeyStations.KeyBits = @old;  newKeys: PUBLIC LONG POINTER TO KeyStations.KeyBits = @new;  keyRep: LONG POINTER TO ARRAY KeyStations.KeyStation OF Dtty.KeyDescriptor;  KeyItem: TYPE = RECORD [  Letter: BOOLEAN, ShiftCode: CHAR [0C..177C], NormalCode: CHAR [0C..377C]];-- Keyboard Info  ctrl:       CARDINAL =  52;  leftShift:  CARDINAL =  57;  shiftLock:  CARDINAL =  72;  rightShift: CARDINAL =  76;  STOPkey:    CARDINAL =  77;  RETURNkey:  CARDINAL =  60;  spaceKey:   CARDINAL =  73;  lastKey:    CARDINAL =  LAST[KeyStations.KeyStation];  -- JLevel-IV info  jShift1:    CARDINAL =  47;  jShift2:    CARDINAL = 111;  jExtraSP:   CARDINAL = 110;-- Range of normal keys as detailed in KeyTable.--  NormalKeyCount: TYPE = [16..77];  NormalKeyCount: TYPE = [0..111];--*******************************************************************************-- This table transforms the bits from the keyBoard bitmap in the IORegion into-- an ASCII character code. The ASCII code is then used as indices to get a -- Gacha12Strike font representation for the ASCII code to be displayed.---- Note: The numeric digits on the numeric keypad are "wire-ored" in this table--       with their corresponding digits on the main key array.--*******************************************************************************-- Table format: Letter/notLetter, Shifted ASCII code, Unshifted ASCII codeKeyTable: ARRAY NormalKeyCount OF KeyItem = [--   Index[0..7]    [FALSE,  00C,  00C],  -- null  [FALSE,  00C,  00C],  -- Bullet  [FALSE,  00C,  00C],  -- SuperSub  [FALSE,  00C,  00C],  -- Case  [FALSE,  00C,  00C],  -- Strikeout  [FALSE,  62C,  62C],  -- KeypadTwo  [FALSE,  63C,  63C],  -- KeypadThree  [FALSE,  47C,  47C],  -- SingleQuote--   Index[8..15]   [FALSE,  53C,  53C],  -- KeypadAdd  [FALSE,  55C,  55C],  -- KeypadSubtract  [FALSE,  52C,  52C],  -- KeypadMultiply  [FALSE,   57C,  57C],  -- KeypadDivide  [FALSE,  05C,  04C],  -- KeypadClear (unShifted=Clear MA, shitfed=Clear DA)  [FALSE,  00C,  00C],  -- Point (left)  [FALSE,  00C,  00C],  -- Adjust (right)  [FALSE,  00C,  00C],  -- Menu   --   Index [16..31]  [FALSE,  45C,  65C],  -- %,5  [FALSE,  44C,  64C],  -- $,4  [FALSE, 176C,  66C],  -- ~,6  [TRUE,  105C, 145C],  -- E  [FALSE,  46C,  67C],  -- &,7  [TRUE,  104C, 144C],  -- D  [TRUE,  125C, 165C],  -- U  [TRUE,  126C, 166C],  -- V  [FALSE,  51C,  60C],  -- ),0  [TRUE,  113C, 153C],  -- K  [FALSE,  30C,  55C],  -- 30C,-  [TRUE,  120C, 160C],  -- P  [FALSE,  77C,  57C],  -- ?,/  [FALSE, 174C, 134C],  -- |,\  [FALSE,  12C,  12C],  -- LF  [FALSE,  10C,  10C],  -- BS   --   Index [32..47]  [FALSE,  43C,  63C],  -- #,3  [FALSE, 100C,  62C],  -- @,2  [TRUE,  127C, 167C],  -- W  [TRUE,  121C, 161C],  -- Q  [TRUE,  123C, 163C],  -- S  [TRUE,  101C, 141C],  -- A  [FALSE,  50C,  71C],  -- (,9  [TRUE,  111C, 151C],  -- I  [TRUE,  130C, 170C],  -- X  [TRUE,  117C, 157C],  -- O  [TRUE,  114C, 154C],  -- L  [FALSE,  74C,  54C],  -- <,,  [FALSE,  42C,  47C],  -- ",'  [FALSE, 175C, 135C],  -- },]  [FALSE,   0C,   0C],  -- SPARE2  [FALSE,   0C,   0C],  -- SPARE1 (jShift1)--   Index [48..63]  [FALSE,  41C,  61C],  -- !,1  [FALSE,  33C,  33C],  -- ESCAPE  [FALSE,  14C,  14C],  -- non-destructive forespace  [TRUE,  106C, 146C],  -- F  [FALSE,    0C,  0C],  -- CONTROL  [TRUE,  103C, 143C],  -- C  [TRUE,  112C, 152C],  -- J  [TRUE,  102C, 142C],  -- B  [TRUE,  132C, 172C],  -- Z  [FALSE,    0C,  0C],  -- LEFT SHIFT  [FALSE,  76C,  56C],  -- >,.  [FALSE,  72C,  73C],  -- :,;  [FALSE,  15C,  15C],  -- CR  [FALSE, 136C, 137C],  -- ­,¬  [FALSE, 177C, 177C],  -- DEL  [FALSE,    0C,  0C],  -- NOT USED (FR5)--    Index [64..79]  [TRUE,  122C, 162C],  -- R  [TRUE,  124C, 164C],  -- T  [TRUE,  107C, 147C],  -- G  [TRUE,  131C, 171C],  -- Y  [TRUE,  110C, 150C],  -- H  [FALSE,  52C,  70C],  -- *,8  [TRUE,  116C, 156C],  -- N  [TRUE,  115C, 155C],  -- M  [FALSE,   0C,   0C],  -- LOCK  [FALSE,  40C,  40C],  -- SPACE  [FALSE, 173C, 133C],  -- {,[  [FALSE,  53C,  75C],  -- +,=  [FALSE,   0C,   0C],  -- RIGHT SHIFT  [FALSE,   0C,   0C],  -- SPARE3 (stop)  [FALSE,   0C,   0C],  -- MOVE  [FALSE,   0C,  07C],  -- UNDO, generates BEL. Used to invert screen--  Index [80..95]  [FALSE,  00C,  00C],  -- MARGIN  [FALSE,  67C,  67C],  -- 7 on numeric key pad  [FALSE,  70C,  70C],  -- 8 on numeric key pad  [FALSE,  71C,  71C],  -- 9 on numeric key pad  [FALSE,  64C,  64C],  -- 4 on numeric key pad  [FALSE,  65C,  65C],  -- 5 on numeric key pad  [FALSE,  00C,  00C],  -- English  [FALSE,  66C,  66C],  -- 6 on numeric key pad  [FALSE,   0C,   0C],  -- Katakana  [FALSE,   0C,   0C],  -- COPY  [FALSE,   0C,   0C],  -- FIND  [FALSE,   0C,   0C],  -- AGAIN  [FALSE,   0C,   0C],  -- Help  [FALSE,   0C,   0C],  -- EXPAND  [FALSE,  61C,  61C],  -- 1 on numeric key pad  [FALSE,  00C,  00C],  -- DiagnosticBitTwo  --  Index [96..111]  [FALSE,  00C,  00C],  -- DiagnosticBitOne  [FALSE,   0C,   0C],  -- CENTER  [FALSE,  60C,  60C],  -- 0 on numeric key pad  [FALSE,   0C,   0C],  -- BOLD  [FALSE,   0C,   0C],  -- ITALIC  [FALSE,   0C,   0C],  -- UNDERLINE  [FALSE,  00C,  00C],  -- Superscript  [FALSE,  00C,  00C],  -- Subscript  [FALSE,   0C,   0C],  -- LARGER/SMALLER  [FALSE,  56C,  56C],  -- Period on numeric key pad  [FALSE,  54C,  54C],  -- Comma on numeric key pad  [FALSE,   0C,   0C],  -- < %European, LeftDakuonShift %Japanese  [FALSE,  42C,  42C],  -- DoubleQuote  [FALSE,   0C,   0C],  -- DEFAULTS  [FALSE,  00C,  00C],  -- Hiragana %Japanese  [FALSE,  00C,  00C]];  -- RightHandDakuonShift %Japanese-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--  System stuff.-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   useCount:       CARDINAL ¬ 0;   simpleStream:   Stream.Object ¬ Stream.defaultObject;   mode: Env.Byte ¬ TTYConstants.normal;   modeVal: CARDINAL ¬ 0;   charsSeen: BOOLEAN ¬ FALSE;   inputBlock: LONG POINTER TO Env.Block ¬ NIL;   diagTTYMode: Dtty.TTYMode  ¬ Dtty.TTYMode[normal];   kAmDiagnosticStopTyped: BOOLEAN ¬ FALSE;-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- DISPLAY DEFINITIONS-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   BBTable: BitBlt.BBTableSpace;   bbPtr:   BitBlt.BBptr = BitBlt.AlignedBBTable[@BBTable];   bitsPerLine: CARDINAL ¬ Term.screenWidth;   screenHeight: CARDINAL ¬ Term.screenHeight;   bitsPerTextLine: PUBLIC CARDINAL;  -- screenWidth*font.height.   bitsPerScreenLine: CARDINAL;  -- Width of screen   pixelsFromOrigin: LONG CARDINAL;  -- Number of pixels from the origin (0,0)-- Character positioning  definitions:   rightEdge: PUBLIC CARDINAL ¬ 0;  -- Right-most character position on a line.                           -- Its value depends on screen width and font.maxWidth.   charPos: PUBLIC CARDINAL ¬ 0;  -- Current character position.   oldCharPos: CARDINAL ¬ 0;  -- For keeping old character position.                                       -- Line positioning definitions:   bottomLine: PUBLIC CARDINAL;  --Number of permissible text lines.   currentLine: PUBLIC CARDINAL; -- Current line carret is on.   oldLine:  CARDINAL ¬ 0; -- Old line.   firstLine: Env.BitAddress; -- Beginning of first display line for text   trueOrigin: Env.BitAddress; -- (0,0) for bitmap   thisLine, oldThisLine: Env.BitAddress; -- Beginning of curent line   referenceLine: CARDINAL = Term.screenHeight/2;  -- Where to draw keyboard   -- Carret control definitions:   doBlink: BOOLEAN ¬ FALSE;  -- Blinking is enabled when TRUE.   blinkerIsDark: BOOLEAN ¬ FALSE; -- Keeps state of carret (TRUE => it is dark).   -- Error   OutOfRange: PUBLIC ERROR = CODE; --~~~~~~~~~~~~~~~~-- Mouse stuff--~~~~~~~~~~~~~~~~--******************************************************************************-- The mouse is represented by a 16X16 pixel square for diagnostics. The mouse-- buttons are represented by 2 sqares, each of which is inverted when depressed. -- --       point => darken left square;--	 adjust => darken right square;--	 chord => darken both sqares.----******************************************************************************  fifteenBits: CARDINAL = 15;  -- heightMinusOne        textPointerMouse: Term.CursorArray = [  --      100000B, 140000B, 160000B, 170000B, 174000B, 176000B, 177000B, 170000B,      154000B, 114000B, 006000B, 006000B, 003000B, 003000B, 001400B, 001400B];<< %Space  upArrowMouse: Term.CursorArray = [  -- Fat up arrow       200B, 700B, 1740B, 3760B, 7770B, 16734B, 30706B, 700B, 700B, 700B, 700B,      700B, 700B, 700B, 700B, 700B];        hourGlass: Term.CursorArray = [  -- Hour Glass      177777B, 100001B, 040002B, 034034B, 017170B, 007560B, 003740B, 001700B,      001100B, 002440B, 004220B, 010610B, 021704B, 047762B, 177777B, 177777B];        questionMark: Term.CursorArray = [  -- ?      017000B, 037600B, 060600B, 140300B, 140300B, 060300B, 000600B, 001400B,      003000B, 006000B, 006000B, 006000B, 000000B, 000000B, 006000B, 006000B];        bullseye: Term.CursorArray = [  --      003700B, 007740B, 014060B, 030030B, 060014B, 140006B, 141606B, 141606B,      141606B, 140006B, 060014B, 030030B, 014060B, 007740B, 003700B, 000000B];>>  --~~~~~~~~~~~~~~~~~~~-- Paints--~~~~~~~~~~~~~~~~~~~  blackPaint: CARDINAL = 177777B;  whitePaint: CARDINAL ¬ 0;   -- For general purpose clearing   --******************************************************************************--  PUBLIC procedure for creating one and only one TTY instance.--******************************************************************************CreateTTYInstance: PUBLIC PROCEDURE [name: LONG STRING, backingStream:                                     Stream.Handle, tty: TTY.Handle]                   RETURNS [ttyImpl: Stream.Handle, backing: Stream.Handle] = {  CreateEntry: ENTRY PROC [m: POINTER TO MONITORLOCK] RETURNS [CARDINAL]=                INLINE {RETURN[useCount ¬ useCount+1]};  IF CreateEntry[@keyboardLock] # 1 THEN ERROR TTY.OutOfInstances;  RETURN[@simpleStream, NIL]};-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--  TTY Procedures to be encapsulated in a Stream.Object.-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--******************************************************************************--  For disposing the stream. --******************************************************************************Delete: PROCEDURE [stream: Stream.Handle] = {  DestroyEntry: ENTRY PROC [m: POINTER TO MONITORLOCK] =                 INLINE {useCount ¬ useCount-1};  DestroyEntry[@keyboardLock]};  --******************************************************************************--   Get the next byte from the stream and store it away. --******************************************************************************GetBlock: Stream.GetProcedure = {  c: CHAR = GetChar[];  -- Get input.  sst ¬ TTYConstants.normal;  why ¬ normal;  bytesTransferred ¬ 1;  block.blockPointer[block.startIndex] ¬ LOOPHOLE[c]};  -- Store in buffer.--******************************************************************************--  Put a byte into the next available position in the stream from memory.--******************************************************************************PutBlock: Stream.PutProcedure = {  SELECT mode FROM    TTYConstants.normal =>       FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO           PutChar[LOOPHOLE[block.blockPointer[i]]] ENDLOOP;    TTYConstants.removeChars =>      BEGIN	FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO	  modeVal ¬ modeVal*256 + block.blockPointer[i];	  ENDLOOP;	END;    ENDCASE};--******************************************************************************--   Wait for an attention to arrive.--******************************************************************************WaitAttention: Stream.WaitAttentionProcedure = {  DoIt: ENTRY PROCEDURE [m: POINTER TO MONITORLOCK]               RETURNS [Env.Byte] =  INLINE {                RETURN[IF stopTyped THEN TTYConstants.aborted                        ELSE TTYConstants.notAborted]};  RETURN[DoIt[@keyboardLock]]};--******************************************************************************--   Send an attention down the stream.--******************************************************************************SendAttention: Stream.SendAttentionProcedure = {  DoIt: ENTRY PROCEDURE [m: POINTER TO MONITORLOCK] =  INLINE {    SELECT byte FROM      TTYConstants.aborted => stopTyped ¬ TRUE;      TTYConstants.notAborted =>stopTyped ¬ FALSE;      ENDCASE};    DoIt[@keyboardLock]};--******************************************************************************--   Change the current SubSequenceType.--******************************************************************************SetSST: Stream.SetSSTProcedure =  {  SELECT mode FROM    TTYConstants.removeChars =>       FOR i: CARDINAL IN [0..modeVal) DO        PutChar[BS]; 	PutChar[SP]; 	PutChar[BS];	ENDLOOP;    TTYConstants.blinkDisplay => Term.BlinkDisplay[];    ENDCASE;  mode ¬ sst;  modeVal ¬ 0};--****************************************************************--  Change OfflineDiagTTY between the normal or diagnostic modes.--****************************************************************SetTTYMode: PUBLIC PROC [mode: Dtty.TTYMode] = {  -- First initialize all keys to "up"  IF mode # normal THEN { -- Initialize keyboard     old ¬ ALL[KeyStations.DownUp[up]];     new ¬ ALL[KeyStations.DownUp[up]] };       diagTTYMode ¬ mode;    -- Set TTY mode  IF mode = normal       THEN { doBlink ¬ TRUE;   -- Returning from KDM diagnostics            charsSeen ¬ FALSE; in ¬ out  -- Flush out input buffer -- }     ELSE { doBlink ¬ FALSE; PutChar [ControlZ] }};  -- Doing KDM diagnostics  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--  Additional PUBLIC procedures-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--******************************************************************************--   PutText allows a client to position the carret and optionally place a--   string of text there. text = NIL => repositions carret only.--******************************************************************************DiagPutText: PUBLIC PROC[xCoordinate: OfflineDiagTTYDove.xRange ¬ 0, -- Line pos.                         yCoordinate: OfflineDiagTTYDove.yRange ¬ 0, -- Line no.	                 text: LONG STRING ¬ NIL] = {         -- Pointer to text.  PutTextEntry: ENTRY PROC [m: POINTER TO MONITORLOCK] = INLINE    BEGIN      inputTextChar: CHAR;      yxBpl: LONG CARDINAL;      IF blinkerIsDark THEN ClearBlinker[];            -- thisLine and firstLine point to beginning of respective screen lines      yxBpl ¬ LONG[(yCoordinate)]*bitsPerTextLine;  -- May be big number.      -- Calculate the number of words to index into destination bitmap.      yxBpl ¬ yxBpl/wordSize;  -- Number of words from beginning.      thisLine.word ¬ firstLine.word + CARDINAL[yxBpl];  -- Desired  text line.      bbPtr.dst ¬ thisLine;  -- Fix up BBTable to point to starting line and      bbPtr.dst ¬ GetBitAddress[bbPtr.dst.word,   -- word and bit positions.                    (bbPtr.dst.bit+(xCoordinate*font.maxwidth))];      bbPtr.srcDesc ¬ [srcBpl[font.raster*wordSize]];	          bbPtr.height ¬ charHeight;  -- Font.ascent + Font.descent.      bbPtr.width ¬ font.maxwidth;	    <<    bbPtr.dst ¬ GetBitAddress[firstLine.word, LONG[(yCoordinate)]*bitsPerTextLine];  bbPtr.dst ¬ GetBitAddress[bbPtr.dst.word,   -- word and bit positions.                    (bbPtr.dst.bit+(xCoordinate*font.maxwidth))];>>      charPos ¬ xCoordinate;  -- Update current char position counter.      currentLine ¬ yCoordinate;   -- Update current-line-position counter.            IF text = NIL THEN RETURN;        -- NIL pointer => Position carret only.      FOR i: CARDINAL IN [0..text.length)  -- Output text.        DO          inputTextChar ¬ text[i];	  DisplayChar[inputTextChar];                ENDLOOP;      doBlink ¬ TRUE;      END; --  of PutTextEntry        IF xCoordinate > rightEdge OR yCoordinate > bottomLine THEN ERROR OutOfRange;   PutTextEntry[@screenLock]};  -- End of DiagPutText  --~~~~~~~~~~~~~~~~~~~~~--  Diagnostic stuffs--~~~~~~~~~~~~~~~~~~~~~--******************************************************************************----	1) A rectangle is a thick horizontal line representing a key.--	2) "key" is the bit position of a key station in the keyboard bit map.--	3) "paint" is a CARDINAL of all 1's or all 0's.--	4) The inside edges of all rectangles overlap by 2 pixels.--	5) Special keys:----	   13 (Point) contains the dimensions for lower half of the RETURN key.----******************************************************************************-- Paints the internal portion of a rectangle as defined in a KeyDescriptor.FillRectangle: PUBLIC PROC [key: KeyStations.KeyStation, paint: CARDINAL] =   BEGIN    anEdge: CARDINAL = 2;  -- Adjustment for one edge (2 pixels)    twoEdges: CARDINAL = 4;  -- Adjustment for 2 edges      RETURNkey: CARDINAL = 60;  -- Return key requires special handling    RETURNkeyLowerHalf: CARDINAL = 13;  -- For painting RETURN key lower half    pixelsToRefLine: LONG CARDINAL ¬ Inline.LongMult[referenceLine, bitsPerLine];    rightEdgeFactor: CARDINAL = 1000;    rightEdgeFudge: CARDINAL = 998;    length: CARDINAL;        keyRep ¬ Dtty.diagKeyBoard;    length ¬ IF keyRep[key].width > rightEdgeFactor THEN     	     keyRep[key].width - rightEdgeFudge ELSE keyRep[key].width;    -- Calculate number of pixels from pixelsFromOrigin    --	                     Lines into Data Area                 Bits into line    pixelsFromOrigin ¬ LONG[keyRep[key].y + anEdge]*bitsPerLine + keyRep[key].x;    pixelsFromOrigin ¬ pixelsFromOrigin + pixelsToRefLine + anEdge;           DrawLineEntry  [m: @screenLock,    	               thickness: keyRep[key].height - anEdge,		       lineLength: length - twoEdges,  		       ink: paint, 		       startingPixel: pixelsFromOrigin];	               -- horizontal: TRUE] ;		           IF key = RETURNkey THEN { -- RETURN is represented by two rectangles.              -- Draw lower half  RETURNlowX  	    RETURNtopX       pixelsFromOrigin ¬ LONG[keyRep[RETURNkeyLowerHalf].y]*bitsPerLine       			  + keyRep[RETURNkeyLowerHalf].x;       pixelsFromOrigin ¬ pixelsFromOrigin + pixelsToRefLine;       DrawLineEntry [m: @screenLock,    	       thickness: keyRep[RETURNkeyLowerHalf].height,	       lineLength: keyRep[RETURNkeyLowerHalf].width,	       ink: paint,	       startingPixel: pixelsFromOrigin] }	       -- horizontal: TRUE] }  	            END;  -- FillRectangle --******************************************************************************--  Fill screen with UserTerminal.CursorArray objects--******************************************************************************FillScreenWithObject: PUBLIC PROCEDURE [object: LONG POINTER TO 						UserTerminal.CursorArray] =  BEGIN      FillScreenEntry: ENTRY PROC [m: POINTER TO MONITORLOCK] = INLINE {      -- Set up BITBLT table for painting the object      bbPtr.dst ¬ trueOrigin;   -- firstLine;      bbPtr.dstBpl ¬ bitsPerScreenLine;      bbPtr.src ¬ [object, 0, 0];       bbPtr.srcDesc ¬ [gray[[0, 0, 0, fifteenBits -- heightMinusOne --]]];       bbPtr.width ¬ bitsPerLine;       bbPtr.height ¬ screenHeight;       bbPtr.flags ¬ [gray: TRUE];       BitBlt.BITBLT[bbPtr];  -- Paint it      bbPtr.flags ¬ [] }; -- End FillScreenEntry        UserTerminal.SetCursorPattern [ALL[0]];    PutChar [ControlZ];   -- Clear screen    FillScreenEntry [@screenLock];    END;  -- FillScreenWithObject--******************************************************************************-- Put an 16X16 object at (x,y)--******************************************************************************PutObject: PUBLIC PROCEDURE [x, y: CARDINAL, -- In pixels/scanlines			     object: LONG POINTER TO UserTerminal.CursorArray] =  BEGIN        PutObjectEntry: ENTRY PROC [m: POINTER TO MONITORLOCK] = INLINE {      bbPtr.dst ¬ GetBitAddress[firstLine.word, LONG[y]*bitsPerScreenLine];        bbPtr.dst ¬ GetBitAddress[bbPtr.dst.word, (bbPtr.dst.bit + x)];      bbPtr.src ¬ [object, 0, 0];      bbPtr.srcDesc ¬ [gray[[0, 0, 0, fifteenBits -- heightMinusOne --]]];      bbPtr.width ¬ 16;      bbPtr.height ¬ 16;      bbPtr.flags ¬ [gray: TRUE];       BitBlt.BITBLT[bbPtr];  -- Paint it      bbPtr.flags ¬ [] }; -- End PutObjectEntry          IF x > bitsPerScreenLine OR y > screenHeight THEN ERROR OutOfRange;    PutObjectEntry [@screenLock];    END;  -- PutObject    --******************************************************************************--  Draws a horizontal line of arbitrary length and thickness on the--  screen.  This is a general purpose routine, whereas DrawKBDLine is tailored --  for drawing the keyboard lines.--******************************************************************************DrawALine: PUBLIC PROCEDURE [x, y, thickness, lineLength, ink: CARDINAL] =   BEGIN  IF (x + lineLength > bitsPerLine) OR (y + thickness > screenHeight)        THEN ERROR OutOfRange;  -- Just in case           pixelsFromOrigin ¬ LONG[y]*bitsPerLine + x;    DrawLineEntry [@screenLock, thickness, lineLength, ink, pixelsFromOrigin];    END;  -- DrawALine    --******************************************************************************-- This procedure is specifically designed for drawing the keyboard in the Data-- Area of the display. The value yRelMiddle is a relative offset from the middle-- of the screen.--******************************************************************************DrawKBDLine: PUBLIC PROCEDURE [x, yRelMiddle, lineLength, ink: CARDINAL,			       horizontal: BOOLEAN] =   BEGIN       edgeThickness: CARDINAL = 2;    referenceLine: CARDINAL = Term.screenHeight/2;  -- Where to draw keyboard        -- Convert x and yRelMiddle to values in terms of bits from origin    pixelsFromOrigin ¬ LONG[yRelMiddle]*bitsPerLine + x -- Offset     	+ Inline.LongMult [referenceLine, bitsPerLine];  -- Reference    -- Now draw the line    DrawLineEntry [m: @screenLock,     		   thickness: IF horizontal THEN edgeThickness ELSE lineLength, 		   lineLength: IF horizontal THEN lineLength ELSE edgeThickness, 		   ink: blackPaint,     		   startingPixel: pixelsFromOrigin -- , orientation -- ];     END;  -- DrawKBDLine          --******************************************************************************--  This ENTRY procedure draws a horizontal or vertical line on the screen.  --  A line can be of arbitrary length and thickness.  All graphics drawn here--  are composed of lines as defined in this module. --****************************************************************************** DrawLineEntry: ENTRY PROC [m: POINTER TO MONITORLOCK,  			   thickness, lineLength, ink: CARDINAL,		   	   startingPixel: LONG CARDINAL] =  BEGIN     erase: BitBlt.DstFunc = and;     blend: BitBlt.DstFunc = or;     longWordSize: CARDINAL = 2*wordSize;          IF thickness = 0 OR lineLength = 0 THEN RETURN;          -- First set up BITBLT arguments     bbPtr.flags ¬ [gray: TRUE];   -- Use gray brick     bbPtr.srcDesc ¬ [gray[[0, 0, 0, 0]]];  -- Gray brick     -- Set up BITBLT table for drawing the line     bbPtr.dst ¬ GetBitAddress [trueOrigin.word, startingPixel];     bbPtr.src ¬ [word: @ink, reserved: 0, bit: 0];     bbPtr.height ¬ IF thickness < Term.screenHeight THEN thickness ELSE Term.screenHeight;     bbPtr.width ¬ IF lineLength < Term.screenWidth THEN lineLength ELSE Term.screenWidth;     bbPtr.flags.dstFunc ¬ IF ink = whitePaint THEN erase ELSE blend;     --     bbPtr.height ¬ IF horizontal THEN thickness ELSE lineLength;--     bbPtr.width ¬ IF horizontal THEN lineLength ELSE thickness;          -- Draw line     BitBlt.BITBLT[bbPtr];     -- Clear flags     bbPtr.srcDesc ¬ [srcBpl[font.raster*wordSize]];     bbPtr.flags ¬ [];          END; -- DrawLineEntry-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--  Keyboard Implementations-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   stopTyped:           BOOLEAN ¬ FALSE;   charactersAvailable: CONDITION;--******************************************************************************--   Keyboard RingBuffer is 50 characters deep. --******************************************************************************  buffer:  PACKED ARRAY [0..50) OF CHAR;  in: CARDINAL ¬ 0;  -- Points to ring buffer location for the next input char.  out: CARDINAL ¬ 0; -- Points to ring buffer location holding the output.-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--  KEYBOARD PROCEDURES-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--******************************************************************************--  All inputs from the keyboard are first buffered in the Keyboard RingBuffer.--******************************************************************************StuffBuffer: ENTRY PROC [c: CHAR, m: POINTER TO MONITORLOCK] = INLINE {  newin: CARDINAL;  IF (newin¬in+1) = LENGTH[buffer] THEN newin ¬ 0;  -- Wrap around.  IF newin#out THEN {buffer[in] ¬ c; in ¬ newin}};  -- Put input into buffer.--******************************************************************************--  Gets the input/inputs from the Keyboard RingBuffer.--******************************************************************************GetChar: PROC RETURNS [c: CHAR] = {  P: ENTRY PROC [m: POINTER TO MONITORLOCK] = INLINE {    ENABLE UNWIND => NULL;    WHILE in=out DO WAIT charactersAvailable ENDLOOP;  -- in=out => no new input.     c ¬ buffer[out];    IF (out¬out+1) = LENGTH[buffer] THEN out ¬ 0};  -- Wrap around.  P[@keyboardLock]}; --******************************************************************************--   Update mouse position.--******************************************************************************TrackMouseCursor:  PROC = INLINE {   mouse: Term.Coordinate ¬ Term.mouse­;  mouse.x ¬ MIN[MAX[0, mouse.x], bitsPerLine];  mouse.y ¬ MIN[MAX[0, mouse.y], screenHeight];  Term.SetCursorPosition[mouse];  Term.SetMousePosition[mouse] };--  UserTerminal.SetCursorPattern [textPointerMouse]};  --******************************************************************************--  This is the main idle loop. It is the detached process that constantly looks--  for inputs from the keyboard.--******************************************************************************ProcessKeyboard: PROC =  BEGIN  pKeyarray: LONG POINTER TO KeyStations.KeyBits = LOOPHOLE [Term.keyboard];    blinkCount:     CARDINAL ¬ 33;  -- Blink carret when count = 0.  interruptState: KeyStations.DownUp ¬ up;    Process.SetPriority [ProcessPriorities.priorityIOHigh];    -- allows interpret calls from the debugger (using priorityPageFaultIO    -- instead would cause a state vector deadlock if an interpret call    -- took a page fault).  old ¬ pKeyarray­;  -- Initialize old Keyarray.    DO  -- Input/Output handler loop.        rubItOut: CARDINAL = 31;  -- "¬" is RubOut here.    Brdcst:  ENTRY PROC [m: POINTER TO MONITORLOCK] = INLINE {      BROADCAST charactersAvailable};  -- Activate process waiting on queue.     XmitChar:  PROC [c: CHARACTER] = {  -- Stuff input char in ring buffer.      StuffBuffer[c, @keyboardLock]; charsSeen ¬ TRUE};    -- Look for inputs.  Keyboard and mouse are polled during retrace.    Term.WaitForScanLine[0];  --  Retrace and system update.    new ¬ pKeyarray­;  --  Get keyboard status after system update.        -- See if any request for world swap.    IF new[STOPkey]=down AND (new[rightShift]=down OR new[leftShift]=down) THEN {      IF interruptState=up THEN Runtime.Interrupt[];  -- Do world swap.      interruptState ¬ down; LOOP};    interruptState ¬ up;        TrackMouseCursor[];  -- Update mouse position.     IF diagTTYMode = abnormalMode AND (new[spaceKey]=up AND old[spaceKey]=down)       THEN { XmitChar[SP]; Brdcst[@keyboardLock] };           IF diagTTYMode # normal THEN {       IF old[STOPkey]=up AND new[STOPkey]=down THEN { stopTyped ¬ TRUE; LOOP };       old ¬ new;       Process.Yield[];       LOOP};    UserTerminal.SetCursorPattern [textPointerMouse];    IF (blinkCount ¬ blinkCount - 1) <= 1 THEN {           BlinkCarret[]; 	  blinkCount ¬ 34 };	      FOR j: CARDINAL IN [0 .. keyCount) DO      char: CHAR; entry: KeyItem;	       -- Normal mode of operation      IF new[j]=up OR old[j]=down THEN LOOP; -- Act on first instance of change       IF j=STOPkey THEN {stopTyped ¬ TRUE; LOOP};             -- ASCII NULL or keys that have no significance for diagnostics      IF (char ¬ (entry ¬ KeyTable[j]).NormalCode) = 0C THEN LOOP;      IF new[leftShift] =down OR new[rightShift]=down	 OR new[jShift1]=down OR new[jShift2]   =down         OR (new[shiftLock]=down AND entry.Letter) THEN  -- Capitol letters.         char ¬ entry.ShiftCode;      IF j = rubItOut THEN char ¬ 177c;   -- Destructive backup      XmitChar[char]; -- Stuffs input char in ring buffer.      ENDLOOP;  -- End of NormalKeyCount loop.    IF new[jExtraSP]=down AND old[jExtraSP] = up THEN XmitChar[SP];    IF charsSeen THEN Brdcst[@keyboardLock];  --Activate process waiting on queue.    old ¬ new;    ENDLOOP  END;  -- ProcessKeyboard  --- ~~~~~~~~~~~~~~~~~~~~--  EXTERNAL PROCEDURES--- ~~~~~~~~~~~~~~~~~~~~--******************************************************************************--  GetBitAddress sets up the src or dst pointers for the next BITBLT operation.--  The word and bit position pointers are properly adjusted to point to the--  beginning word and bit positions of the source or destination bitmap to be--  operated on.--******************************************************************************GetBitAddress: PROCEDURE [reference: LONG POINTER, bitsFromOrigin: LONG CARDINAL] 	         RETURNS [Env.BitAddress] = {  RETURN [[reference + LOOPHOLE[CARDINAL [bitsFromOrigin/wordSize]], 0,  	   CARDINAL [bitsFromOrigin MOD wordSize]]] };--******************************************************************************--  The carret used here is a black rectangle located at font.max+1. Before --  moving the carret, ensure the black rectangle is cleared first.--******************************************************************************BlinkCarret: PROC = INLINE {  BlinkCarretEntry: ENTRY PROC [m: POINTER TO MONITORLOCK] = {    blinker: CHAR = font.max+1;      IF doBlink THEN {      bbPtr.src ¬ GetBitAddress[bitmap,xInSegment[blinker]];  -- Dark rectangle.      blinkerIsDark ¬  ~ blinkerIsDark;  -- Complements blinkerIsDark.      bbPtr.flags ¬ [dstFunc: xor];  -- XOR carret and displayed character.      BitBlt.BITBLT[bbPtr];      bbPtr.flags ¬ []}};  -- Clear XOR  IF doBlink THEN BlinkCarretEntry[@screenLock]};  --******************************************************************************--  External procedure for accessing screen.--******************************************************************************PutChar: PROC [c: CHARACTER] = {   PutCharEntry: ENTRY PROC [m: POINTER TO MONITORLOCK] =    INLINE {doBlink ¬ FALSE;     DisplayChar[c]; IF diagTTYMode = normal THEN doBlink ¬ TRUE};  PutCharEntry[@screenLock]};--******************************************************************************--  Entry procedure for clearing screen.--******************************************************************************ClearScreenEntry: ENTRY PROC [m: POINTER TO MONITORLOCK] = INLINE {ClearScreen[];  doBlink ¬ TRUE};  -- Start blinking the carret.--- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~---  INTERNAL DISPLAY PROCEDURES--- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--******************************************************************************--   ClearBlinker ensures that the carret is cleared before moving on.--******************************************************************************ClearBlinker: INTERNAL PROC = BEGIN  blinkerIsDark ¬  FALSE;  --  Blinker is clear.  bbPtr.src ¬ GetBitAddress[bitmap,xInSegment[font.max+1]];  bbPtr.flags ¬ [dstFunc: xor];  BitBlt.BITBLT[bbPtr];  bbPtr.flags ¬ [];  doBlink ¬ FALSE  -- Disable blinking. Re-enabled by caller.  END;--******************************************************************************--   Backup does a non-destructive backspace.--******************************************************************************Backup: INTERNAL PROC = {  t: CARDINAL = bbPtr.dst.bit + wordSize - font.maxwidth;  IF blinkerIsDark THEN ClearBlinker[]; --Ensure no dark rectangle is left behind.  IF charPos = 0 THEN RETURN; -- Do nothing if at first char position of line.  charPos ¬ charPos - 1;  bbPtr.dst.word ¬ bbPtr.dst.word + t/wordSize - 1;  bbPtr.dst.bit ¬ t MOD wordSize;    doBlink ¬ TRUE};  -- Re-enable blinker.   --*******************************************************************************--   ClearScreen clears the screen and homes the carret. Additionally, the --   user terminal dimensions, which can vary from system to system, are obtained--   from the system via UserTerminal.GetBitBltTable. The following constants are--   initilaized here and are based on the information returned by--   UserTerminal.GetBitBltTable:--	bitsPerScreenLine--      bitsPerTextLine--	firstLine--	rightEdge--	bottomLine--	trueOrigin--*******************************************************************************ClearScreen: INTERNAL PROC = {  bbPtr­ ¬ Term.GetBitBltTable[];  trueOrigin ¬ bbPtr.dst;  -- Save for later use  bitsPerScreenLine ¬ bbPtr.dstBpl;  -- Save destination bits per line  bitsPerTextLine ¬ bitsPerScreenLine * charHeight;  firstLine ¬ thisLine ¬ GetBitAddress[  -- Point to beginning of first line.    bbPtr.dst.word, bbPtr.dst.bit+8+8*bbPtr.dstBpl];  charPos ¬ 0; currentLine ¬ 0;  --Last character position on line. Here, bbPtr.width is width of entire display.  rightEdge ¬ (bbPtr.width-wordSize)/font.maxwidth;   -- Max number of screen lines. bbPtr.height is screen height here.  bottomLine ¬ (bbPtr.height - wordSize)/charHeight;  bbPtr.src ¬ [@whitePaint, 0, 0];  bbPtr.srcDesc ¬ [gray[[0, 0, 0, 0]]];  bbPtr.flags ¬ [gray: TRUE];  -- Alter interpretation of srcBpl to srcDesc.  BitBlt.BITBLT[bbPtr];  -- set up standard arguments for character painting  bbPtr.dst ¬ firstLine;  --bbPtr.dstBpl set  --bbPtr.src set when proc called  bbPtr.srcDesc ¬ [srcBpl[font.raster*wordSize]];  bbPtr.height ¬ charHeight;  -- Font.ascent + Font.descent.  bbPtr.width ¬ font.maxwidth;  bbPtr.flags ¬ []};  -- Clear the flags, especially the gray flag.--*******************************************************************************--   Clears the current screen position pointed to by the carret.--*******************************************************************************ClearThisChar: INTERNAL PROC = {  bbPtr.src ¬ [@whitePaint, 0, 0];  bbPtr.srcDesc ¬ [gray[[0, 0, 0, 0]]];  bbPtr.flags ¬ [gray: TRUE];  BitBlt.BITBLT[bbPtr];  bbPtr.srcDesc ¬ [srcBpl[font.raster*wordSize]];  bbPtr.flags ¬ []};--*****************************************************************************--   rubOut (177C) destructively backs up by one position--*****************************************************************************RubOut: INTERNAL PROC = {  ClearThisChar[];  IF charPos = 0 THEN RETURN;         -- Do nothing if at beginning of line  Backup[];  doBlink ¬ TRUE};  --*******************************************************************************--   ­\ (34c) invokes ClearLineFromCarret, which clears the remainder  of the   --   line starting from the current carret position.--*******************************************************************************ClearLineFromCarret: INTERNAL PROC = {     -- First, save the current position.  oldThisLine ¬ thisLine;  -- Current line  oldCharPos ¬ charPos;    -- Current character position.    -- Clear rest of current line starting from current position.  FOR i: CARDINAL IN [charPos..rightEdge) DO	     ClearThisChar[];    IF i < (rightEdge-1) THEN      bbPtr.dst ¬ GetBitAddress[bbPtr.dst.word, bbPtr.dst.bit+font.maxwidth];    ENDLOOP;    -- Restore the old position.  bbPtr.dst ¬ thisLine ¬ oldThisLine;   bbPtr.dst ¬ GetBitAddress[bbPtr.dst.word, bbPtr.dst.bit+                                (oldCharPos*font.maxwidth)];  charPos ¬ oldCharPos;  doBlink ¬ TRUE};        --*******************************************************************************--   Newline does a Carriage Return and a Line Feed.--******************************************************************************* Newline: INTERNAL PROC = {  doBlink ¬ FALSE;  -- Disable Blinking.  IF currentLine<(bottomLine-1)THEN {  --Not currently at the bottom of screen.    thisLine ¬ GetBitAddress[thisLine.word, thisLine.bit+bitsPerTextLine];    currentLine ¬ currentLine+1}  ELSE {  -- At bottom of screen. Need to move the entire screen up 1 line.    sBBTable: BitBlt.BBTableSpace;    sbbPtr: BitBlt.BBptr = BitBlt.AlignedBBTable[@sBBTable];    sbbPtr­ ¬ [      dst: firstLine, dstBpl: bbPtr.dstBpl,  -- New destination bitmap.      -- New source bitmap is old bitmap minus the bottom line.      src: GetBitAddress[firstLine.word, firstLine.bit+bitsPerTextLine],      srcDesc: [srcBpl[bbPtr.dstBpl]], flags: [direction: forward],      width: -- CARDINAL ¬ -- rightEdge*font.maxwidth,      height: -- CARDINAL ¬ -- charHeight*(bottomLine-1)];    BitBlt.BITBLT[sbbPtr];    sbbPtr­ ¬ [      dst: thisLine, src: [@whitePaint, 0, 0],      dstBpl: bbPtr.dstBpl, srcDesc: [gray[[0, 0, 0, 0]]],      width: rightEdge*font.maxwidth, height: charHeight,      flags: [gray: TRUE]];    BitBlt.BITBLT[sbbPtr]};  bbPtr.dst ¬ thisLine;  charPos ¬ 0;  doBlink ¬ TRUE}; -- Re-enable blinking. End NewLine--*******************************************************************************--   DisplayChar interprets keyboard inputs and cause the correct sequence of--   events to happen. Be carefull with RETURN's !!!--*******************************************************************************DisplayChar: INTERNAL PROC [c: CHARACTER] = {  -- Ensure carret is cleared. Blinking is also disabled.  IF blinkerIsDark THEN ClearBlinker[];   -- Implement commands.    SELECT c FROM    IN (SP..'~] => {  -- Normal characters. Output to screen.      IF c ~IN [font.min..font.max] THEN c ¬ font.max+1;      bbPtr.src ¬ GetBitAddress[bitmap, xInSegment[c]];      BitBlt.BITBLT[bbPtr] };    rubOut => { RubOut[]; RETURN };    SP =>  { ClearThisChar[] };  -- Enter a space.    CR =>  { Newline[]; RETURN };  -- Does a carriage return and line feed.    BS =>  { Backup[]; RETURN };  -- Non-destructive.    ControlZ => { ClearScreen[]; RETURN };    -- Home carret and clear screen.    CLFC => { ClearLineFromCarret[]; RETURN };       IN [0C..SP) => RETURN;    ENDCASE => RETURN;  IF (charPos ¬ charPos+1) >= rightEdge THEN Newline[]  ELSE bbPtr.dst ¬ GetBitAddress[bbPtr.dst.word, bbPtr.dst.bit+font.maxwidth];  doBlink ¬ TRUE };  -- Enable Blinking.--- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~---  Gacha12Strike Font Definition.--- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--*******************************************************************************--  GetFont provides the pointer to the Gacha12Strike font file hard coded here.--*******************************************************************************GetFont: PROC RETURNS [LONG POINTER] = {  Gacha12Strike: ARRAY [0..1470B) OF WORD = [    --   0-- 120000B,     0B,   176B,    10B,  1464B,    13B,     3B,     0B,    --  10--     61B,     0B,     0B,     0B, 10000B,     0B,  2040B,     0B,    --  20--      0B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --  30--      0B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --  40--      0B,     0B,     0B,     0B,     0B,     0B,     0B,    74B,    --  50--     74B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --  60--      0B,     0B,     0B,     0B,     0B,     0B,     0B,  7010B,    --  70--  70000B,     0B,     0B,    10B, 22012B, 34144B, 14010B,  4020B,    -- 100--   4000B,     0B,     2B, 36010B, 36074B,  6076B, 36176B, 36074B,    -- 110--      0B,  2000B, 20074B, 14020B, 74034B, 74176B, 77034B, 41076B,    -- 120--  17102B, 40306B, 41074B, 76074B, 76074B, 77502B, 40501B, 41101B,    -- 130--  77040B, 20004B,     0B,   100B,     2B,    14B,   100B,  4004B,    -- 140--  40070B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    -- 150--  10010B,  4000B,     0B,     0B,    10B, 22012B, 52244B, 22010B,    -- 160--  10010B, 25000B,     0B,     2B, 41030B, 41102B,  6040B, 41002B,    -- 170--  41102B,     0B,  4000B, 10102B, 22020B, 42042B, 42100B, 40042B,    -- 200--  41010B,  1104B, 40306B, 61102B, 41102B, 41102B,  4102B, 40511B,    -- 210--  41101B,  1040B, 20004B,     0B,   100B,     2B,    22B,   100B,    -- 220--   4004B, 40010B,     0B,     0B,     0B,    20B,     0B,     0B,    -- 230--      0B, 10010B,  4000B,     0B,     0B,    10B, 22024B, 52250B,    -- 240--  22010B, 10010B, 16010B,     0B,     4B, 41050B, 41102B, 12040B,    -- 250--  40002B, 41102B,     0B, 10000B,  4102B, 41050B, 42102B, 41100B,    -- 260--  40102B, 41010B,  1110B, 40252B, 61102B, 41102B, 41102B,  4102B,    -- 270--  21111B, 22042B,  2040B, 10004B,  4000B,   100B,     2B,    20B,    -- 300--    100B,     0B, 40010B,     0B,     0B,     0B,    20B,     0B,    -- 310--      0B,     0B, 10010B,  4000B, 74000B,     0B,    10B, 22076B,    -- 320--  50310B, 14010B, 20004B, 25010B,     0B,     4B, 43010B,  1002B,    -- 330--  12174B, 76004B, 41102B,  4010B, 20000B,  2002B, 47050B, 42100B,    -- 340--  41100B, 40100B, 41010B,  1120B, 40252B, 51102B, 41102B, 41040B,    -- 350--   4102B, 21111B, 22042B,  4040B, 10004B, 16020B, 34134B, 36072B,    -- 360--  36174B, 35134B, 34074B, 42010B,167134B, 36134B, 35054B, 36174B,    -- 370--  41102B,101104B, 41174B, 10010B,  4062B, 74000B,     0B,    10B,    -- 400--     24B, 34010B, 10000B, 20004B,  4010B,   176B,    10B, 45010B,    -- 410--   2034B, 22102B, 41004B, 36102B,  4010B, 40176B,  1004B, 51104B,    -- 420--  76100B, 41174B, 76100B, 77010B,  1160B, 40252B, 51102B, 41102B,    -- 430--  76030B,  4102B, 21052B, 14024B,  4040B,  4004B, 25040B, 42142B,    -- 440--  41106B, 41020B, 43142B,  4004B, 44010B,111142B, 41142B, 43062B,    -- 450--  41020B, 41102B,101104B, 41004B, 10010B,  4132B, 74000B,     0B,    -- 460--     10B,    50B, 12020B, 24400B, 20004B,   177B,     0B,    10B,    -- 470--  51010B,  4002B, 22002B, 41010B, 41102B,     0B, 40000B,  1010B,    -- 500--  51104B, 41100B, 41100B, 40116B, 41010B,  1110B, 40222B, 45102B,    -- 510--  76102B, 44004B,  4102B, 12052B, 14024B, 10040B,  4004B,  4177B,    -- 520--   2102B, 40102B, 41020B, 41102B,  4004B, 50010B,111102B, 41102B,    -- 530--  41040B, 40020B, 41044B,111050B, 21010B, 60010B,  3114B, 74000B,    -- 540--  35400B,    10B,   174B, 12023B, 45000B, 20004B,    10B,     0B,    -- 550--     20B, 61010B, 10002B, 42002B, 41010B, 41076B,     0B, 20176B,    -- 560--   2010B, 46104B, 41100B, 41100B, 40102B, 41010B,  1104B, 40222B,    -- 570--  45102B, 40102B, 42002B,  4102B, 12052B, 22010B, 20040B,  2004B,    -- 600--   4040B, 36102B, 40102B, 77020B, 41102B,  4004B, 70010B,111102B,    -- 610--  41102B, 41040B, 36020B, 41044B,111020B, 22020B, 10010B,  4000B,    -- 620--  74000B,     0B,     0B,    50B, 52025B, 42000B, 20004B,    10B,    -- 630--      0B,    20B, 41010B, 20102B, 77102B, 41020B, 41002B,     0B,    -- 640--  10000B,  4000B, 40376B, 41102B, 41100B, 40102B, 41010B, 41104B,    -- 650--  40222B, 43102B, 40102B, 42102B,  4102B, 12024B, 22010B, 20040B,    -- 660--   2004B,  4020B, 42102B, 40102B, 40020B, 41102B,  4004B, 44010B,    -- 670-- 111102B, 41102B, 41040B,  1020B, 41044B,111050B, 12040B, 10010B,    -- 700--   4000B, 74000B,     0B,    10B,   120B, 52045B, 42000B, 10010B,    -- 710--     10B, 14000B,  4040B, 41010B, 40102B,  2102B, 41020B, 41102B,    -- 720--   4030B,  4000B, 10010B, 21202B, 41042B, 42100B, 40046B, 41010B,    -- 730--  41102B, 40202B, 43102B, 40102B, 41102B,  4102B,  4024B, 41010B,    -- 740--  40040B,  1004B,  4000B, 42142B, 41106B, 41020B, 43102B,  4004B,    -- 750--  42010B,111102B, 41142B, 43040B, 41022B, 43030B,111104B, 14100B,    -- 760--  10010B,  4000B, 74000B,     0B,    10B,   120B, 34046B, 35400B,    -- 770--  10010B,     0B,  4000B,  4040B, 36076B, 77074B,  2074B, 36020B,    --1000--  36074B,  4010B,  2000B, 20010B, 16202B, 76034B, 74176B, 40032B,    --1010--  41076B, 36102B, 77202B, 41074B, 40074B, 41074B,  4074B,  4024B,    --1020--  41010B, 77040B,  1004B,     0B, 35134B, 36072B, 36020B, 35102B,    --1030--   4004B, 41010B,111102B, 36134B, 35040B, 36014B, 35030B, 66104B,    --1040--   4176B, 10010B,  4000B, 74000B,     0B,     0B,     0B, 10000B,    --1050--      0B,  4020B,     0B,  4000B,     0B,     0B,     0B,     0B,    --1060--      0B,     0B,    10B,     0B,     0B,     0B,     0B,     0B,    --1070--      0B,     0B,     0B,     0B,     0B,    20B,     0B,     0B,    --1100--      0B,     0B,    40B,     4B,     0B,     0B,     0B,     0B,    --1110--   1000B,     4B,     0B,     0B,   100B,  1000B,     0B,     0B,    --1120--      0B,  4000B, 10010B,  4000B, 74000B,     0B,     0B,     0B,    --1130--      0B,     0B,  2040B,     0B, 10000B,     0B,     0B,     0B,    --1140--      0B,     0B,     0B,    20B,     0B,     0B,     0B,     0B,    --1150--      0B,     0B,     0B,     0B,     0B,     0B,    16B,     0B,    --1160--      0B,     0B,     0B,    74B,    74B,     0B,     0B,     0B,    --1170--      0B, 41000B,   104B,     0B,     0B,   100B,  1000B,     0B,    --1200--      0B,     0B, 50000B,  7010B, 70000B, 74000B,   377B,     0B,    --1210--      0B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --1220--      0B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --1230--      0B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --1240--      0B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --1250--      0B,     0B, 36000B,    70B,     0B,     0B,   100B,  1000B,    --1260--      0B,     0B,     0B, 20000B,     0B,     0B, 74000B,     0B,    --1270--     10B,    10B,    10B,    10B,    10B,    10B,    10B,    10B,    --1300--     10B,    10B,    10B,    10B,    10B,    10B,    10B,    10B,    --1310--     10B,    10B,    10B,    10B,    10B,    10B,    10B,    10B,    --1320--     20B,    20B,    20B,    20B,    20B,    20B,    20B,    20B,    --1330--     30B,    40B,    50B,    60B,    70B,   100B,   110B,   120B,    --1340--    130B,   140B,   150B,   160B,   170B,   200B,   210B,   220B,    --1350--    230B,   240B,   250B,   260B,   270B,   300B,   310B,   320B,    --1360--    330B,   340B,   350B,   360B,   370B,   400B,   410B,   420B,    --1370--    430B,   440B,   450B,   460B,   470B,   500B,   510B,   520B,    --1400--    530B,   540B,   550B,   560B,   570B,   600B,   610B,   620B,    --1410--    630B,   640B,   650B,   660B,   670B,   700B,   710B,   720B,    --1420--    730B,   740B,   750B,   760B,   770B,  1000B,  1010B,  1020B,    --1430--   1020B,  1030B,  1040B,  1050B,  1060B,  1070B,  1100B,  1110B,    --1440--   1120B,  1130B,  1140B,  1150B,  1160B,  1170B,  1200B,  1210B,    --1450--   1220B,  1230B,  1240B,  1250B,  1260B,  1270B,  1300B,  1310B,    --1460--   1320B,  1330B,  1340B,  1350B,  1360B,  1370B,  1400B,  1410B];    -- End of Gacha12Strike font file. This is used as a source bitmap.      p: LONG POINTER TO ARRAY [0..1470B) OF WORD    ¬ Runtime.GetTableBase[LOOPHOLE[OfflineDiagTTYImplDove]]; -- Start of frame.  DO  -- Look for beginning of font table embedded in code.    IF p[0] = Gacha12Strike[0] AND p­ = Gacha12Strike THEN RETURN[p];    p ¬ p+1    ENDLOOP};  -- p points to beginning of the Gacha12Strike font table at RETURN.        --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- MAINLINE CODE ----~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<<  FontError: ERROR = CODE;  IF ~font.newStyle OR font.indexed OR font.min ~IN [0C..177C]     OR font.max+1 ~IN [0C..177C] THEN ERROR FontError;>>-- Encapsulate the simple TTY operations in a Stream.Object.  simpleStream.get ¬ GetBlock;  simpleStream.put ¬ PutBlock;  simpleStream.delete ¬ Delete;  simpleStream.waitAttention ¬ WaitAttention;  simpleStream.sendAttention ¬ SendAttention;  simpleStream.setSST ¬ SetSST;  Process.EnableAborts[@charactersAvailable];  [] ¬ Term.SetState[on];  [] ¬ Term.SetBackground[white];  Term.SetBorder [oddPairs: 252B, evenPairs: 125B];  Term.SetCursorPattern [textPointerMouse];   -- Use the Tajo mouse normally    ClearScreenEntry[@screenLock];  -- Clear display and home carret.   SetTTYMode [normal];  -- Set mode to normal    -- Pin down ProcessKeyboard and OfflineDiagTTYImplDove  ??????????   SpecialSpace.MakeProcedureResident[ProcessKeyboard    ! SpecialSpace.SpecialError =>      IF error = alreadyResident THEN CONTINUE      ELSE REJECT];  SpecialSpace.MakeGlobalFrameResident[OfflineDiagTTYImplDove    ! SpecialSpace.SpecialError =>      IF error = alreadyResident THEN CONTINUE      ELSE REJECT];    -- This is the detached process for sensing inputs.  Process.Detach[FORK ProcessKeyboard];  END.... OfflineDiagTTYImplDove.mesaLOGCreated by KL on 15-Nov-84.  This program is based on the SimpleTTY last edited by Johnson on 6-Apr-83.24-Jan-86: Broke the tie to KDMMsgesAndKBDsDove. Moved diagKeyBoard and           KeyDescriptor to OfflineDiagTTYDove.	    5-Jan-87 by KXW,  Fixed bug in DiagPutText.11-Mar-87 14:16:12  by KXW,  Modified DiagPutText, PutObject and DrawALine to check arguments. 20-Mar-87  9:49:02  by KXW,  Fixed bug in PutObject.       
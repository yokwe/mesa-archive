-- Copyright (C) 1987  by Xerox Corporation. All rights reserved.---- File: DiagFlTapeCmdsImpl.mesa-- Edited by: JMA 13-Jun-88 16:31:21--DIRECTORY DeviceTypesExtras4	USING 	[fad5000], DiagFlTapeCmds		USING	[IOCommandContext, IoCP], DiagFlTapeTestControl	USING	[CmdTimeOutInSeconds], DiagFlTapeTTY		USING   [CheckIfUserAbort], Environment		USING	[Base, first64K, wordsPerPage], FloppyDiskFace		USING	[Operation, OperationPtr, Poll,				 MaxTracksPerFormatOperation,				 Context, SetContext,				 Attributes, Status, DiskAddress,				 DeviceHandle,nullDeviceHandle,				 Reset, Initiate, DiskChangeClear,				 GetDeviceAttributes, GetNextDevice,				 operationBlockLength, operationAlignment], FloppyIOFaceDove	USING   [IOCBPtr, maxTracksPerStream], FloppyTape		USING	[Drive, VolumeHandle], Inline			USING	[LowHalf, LongMult], SpecialFloppyTapeFace	USING	[Retention], ResidentHeap		USING	[MakeNode], Space			USING	[ScratchMap], Time			USING	[Current], Zone			USING	[Status];DiagFlTapeCmdsImpl: PROGRAM  IMPORTS	DiagFlTapeTestControl,	DiagFlTapeTTY,	FloppyDiskFace,	Inline,	SpecialFloppyTapeFace,	ResidentHeap,	Space,	Time  EXPORTS    DiagFlTapeCmds =  BEGIN  OPEN    DiagFlTapeCmds;      --Public variables IoCPIdx:		PUBLIC CARDINAL¬ 0; IoCPA:			PUBLIC ARRAY [0..2] OF IoCP; IOCmdContext:		PUBLIC DiagFlTapeCmds.IOCommandContext; CmdTimedOut:		PUBLIC BOOLEAN¬ FALSE; 		   Sector:		PUBLIC CARDINAL¬ 0; MinSector:		PUBLIC CARDINAL¬ 1; MaxSector:		PUBLIC CARDINAL¬ 32; SectorCount:		PUBLIC CARDINAL¬ 1; MinSectorCount:	PUBLIC CARDINAL¬ 1; MaxSectorCount:	PUBLIC CARDINAL¬ 32*245;	--7840 Head:			PUBLIC CARDINAL¬ 0; MinHead:		PUBLIC CARDINAL¬ 0; MaxHead:		PUBLIC CARDINAL¬ 0; Track:			PUBLIC CARDINAL¬ 0; MinTrack:		PUBLIC CARDINAL¬ 0; MaxTrack:		PUBLIC CARDINAL¬ (245*12)-1;	--[0..2939] TrackCount:		PUBLIC CARDINAL¬ 1; MinTrackCount:		PUBLIC CARDINAL¬ 1; MaxTrackCount:		PUBLIC CARDINAL¬ 12*245;	--2940 Stream:		PUBLIC CARDINAL¬ 1; MinStream:		PUBLIC CARDINAL¬ 1; MaxStream:		PUBLIC CARDINAL¬ 12; WordsPerSector:	PUBLIC CARDINAL¬ 256;		--[0..255] SectorsPerTrack:	PUBLIC CARDINAL¬ 32;		--[0..31] SectorsPerStream:	PUBLIC CARDINAL¬ 32*245;	--7840 SectorsPerTape:	PUBLIC LONG CARDINAL¬ 94080;	--32*245*12 MaxTracksPerFormat:	PUBLIC LONG CARDINAL; TracksPerStream:	PUBLIC CARDINAL¬ 245;		--[0..244] TracksPerTape:		PUBLIC CARDINAL¬ 245*12;	--2940 StreamsPerTape:	PUBLIC CARDINAL¬ 12;		--[1..12] WriteBuffPtr1:		PUBLIC LONG POINTER TO ARRAY OF WORD; WriteBuffPtr2:		PUBLIC LONG POINTER TO ARRAY OF WORD; WrBuffArray:		PUBLIC ARRAY [0..1] OF LONG POINTER TO ARRAY OF WORD; ReadBuffPtr1:		PUBLIC LONG POINTER TO ARRAY OF WORD; ReadBuffPtr2:		PUBLIC LONG POINTER TO ARRAY OF WORD; RdBuffArray:		PUBLIC ARRAY [0..1] OF LONG POINTER TO ARRAY OF WORD; ReadIDBuffPtr1:	PUBLIC LONG POINTER TO ARRAY OF WORD; ReadIDBuffPtr2:	PUBLIC LONG POINTER TO ARRAY OF WORD; RdIDBuffArray:		PUBLIC ARRAY [0..1] OF LONG POINTER TO ARRAY OF WORD; LastReadSize:		PUBLIC CARDINAL¬ 0; LastReadCmdIdx:	PUBLIC CARDINAL¬ 0; LastWriteSize:		PUBLIC CARDINAL¬ 0; LastWriteCmdIdx:	PUBLIC CARDINAL¬ 0; IDBuffHasData:		PUBLIC BOOLEAN ¬ FALSE; LastReadIDCmdIdx:	PUBLIC CARDINAL¬ 0; StatusHasData:		PUBLIC BOOLEAN ¬ FALSE;  --used for status display LastReadStatus:	PUBLIC FloppyDiskFace.Status; --used for status display -- global volume type stuff ValidVolumeHandle:	PUBLIC BOOLEAN; VolumeHandle:		PUBLIC FloppyTape.VolumeHandle; DeviceHandle:		PUBLIC FloppyDiskFace.DeviceHandle¬			  FloppyDiskFace.nullDeviceHandle; CurrentTestDrive:	PUBLIC FloppyTape.Drive ¬ LAST[FloppyTape.Drive];  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- Private variables -- writeBuffSizeInPages:CARDINAL¬ 32; writeBuffSizeInPages:	CARDINAL¬ 160; --to hold one track data for each write -- readBuffSizeInPages:	CARDINAL¬ 32; readBuffSizeInPages:	CARDINAL¬ 160; --to hold one read track data readIDBuffSizeInPages:	CARDINAL¬ 1; --to hold one ID extraBuffer:		CARDINAL¬ 1; -- scratch buffer pageCnt:		CARDINAL¬ (writeBuffSizeInPages+ 				   readBuffSizeInPages+	     --2 buffers for				   readIDBuffSizeInPages+extraBuffer)*2; -- each command  ptr:			LONG POINTER; scratchPageAlignedBuff: LONG POINTER TO ARRAY OF WORD; cmdsSetUp:		CARDINAL¬ 0; cmdCompleted:		BOOLEAN ¬ FALSE; noCmdTimeOut:		BOOLEAN ¬ FALSE; statusToLog:		BOOLEAN ¬ FALSE; opStorage0:		Environment.Base RELATIVE POINTER; opStorage1:		Environment.Base RELATIVE POINTER; opStorage2:		Environment.Base RELATIVE POINTER; tempStr:		LONG STRING ¬ [110]; currentTime:		LONG CARDINAL; goodContext:		BOOLEAN;  -- debug counter: (FloppyDiskFace.Initiate) = (FloppyDiskFace.Poll) -- incr. by 1 after FloppyDiskFace.Initiate and decr. by 1 after FloppyDiskFace.Poll initiateCount:		INTEGER ¬ 0; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- generate the IO operation space and pointer  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetOperationPtr: PROC    RETURNS [      pOp: LONG POINTER TO FloppyDiskFace.Operation,      pStorage: Environment.Base RELATIVE POINTER TO UNSPECIFIED] = -- pOp will be aligned per requirements of FloppyDiskFace.Operation. -- pStorage should be used when freeing the allocated space. BEGIN rpDirOp: Environment.Base RELATIVE POINTER TO FloppyDiskFace.Operation; status: Zone.Status; NoWay: ERROR = CODE; [pStorage, status] ¬ ResidentHeap.MakeNode[   n: FloppyDiskFace.operationBlockLength+ 15,   alignment: FloppyDiskFace.operationAlignment]; IF status ~= okay THEN ERROR NoWay; rpDirOp ¬ pStorage; pOp ¬ @Environment.first64K[rpDirOp]; END;  --GetOperationPtr -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- set up to initial IO operation pointers -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ InitCmdStuff: PUBLIC PROCEDURE = BEGIN END;  --InitCmdStuff -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- look for no longer in progress or command timed out -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ WaitForCompletion: PUBLIC PROCEDURE [index: CARDINAL¬ 0] = BEGIN done: BOOLEAN¬ FALSE; CmdTimedOut¬ FALSE;  initiateCount ¬ initiateCount-1; UNTIL done OR CmdTimedOut DO   [IoCPA[index].rtndStatus, IoCPA[index].retriedCount]¬     FloppyDiskFace.Poll[operationPtr: IoCPA[index].opPtr];   LastReadStatus¬ IoCPA[index].rtndStatus;   StatusHasData¬ TRUE;   IF IoCPA[index].rtndStatus# inProgress THEN   { IF IoCPA[index].rtndStatus# goodCompletion THEN       AR13261Workaround[iocb: IoCPA[index].opPtr, index: index];     DiagFlTapeTTY.CheckIfUserAbort[];     RETURN;   } ELSE   { currentTime¬ Time.Current[];     IF currentTime> IoCPA[index].timeOutTime THEN     { IoCPA[index].cmdTimedOut¬ CmdTimedOut¬ TRUE;       -- force IOCB to return       ResetController [];       EXIT;     };   }; ENDLOOP;  END;  --of WaitForCompletion -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- do the IO command -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ExecuteCmd: PUBLIC PROCEDURE [ioCP: CARDINAL¬ 0] = BEGIN IoCPA[ioCP].timeCmdStarted¬ Time.Current[]; IoCPA[ioCP].timeOutTime¬    IoCPA[ioCP].timeCmdStarted+ DiagFlTapeTestControl.CmdTimeOutInSeconds; IoCPA[ioCP].rtndStatus¬   LocalInitiate[operationPtr: IoCPA[ioCP].opPtr]; END; --ExecuteCmd -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- performs no operation and returns status -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ NoOp: PUBLIC PROCEDURE = BEGIN IoCPA[0].timeCmdStarted¬ Time.Current[]; IoCPA[0].timeOutTime¬    IoCPA[0].timeCmdStarted+ DiagFlTapeTestControl.CmdTimeOutInSeconds; IoCPA[0].rtndStatus¬ LocalInitiate[operationPtr: IoCPA[0].opPtr]; WaitForCompletion[];  END; --NoOp -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- performs a read ID operation -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ << ReadID: PUBLIC PROCEDURE = BEGIN IoCPA[0].timeCmdStarted¬ Time.Current[]; IoCPA[0].timeOutTime¬    IoCPA[0].timeCmdStarted+ DiagFlTapeTestControl.CmdTimeOutInSeconds; IoCPA[0].rtndStatus¬ LocalInitiate[operationPtr: IoCPA[0].opPtr]; WaitForCompletion[];  END; --ReadID >>  << This version of ReadID performs a Read Sector first in order to properly position  the head prior to reading the track ID.  This is a work around for floppy tape limitation. >> ReadID: PUBLIC PROCEDURE = BEGIN oldAddress: FloppyDiskFace.DiskAddress ¬ IoCPA[0].opPtr­.address;  -- First do a read sector for positioning IoCPA[0].timeCmdStarted¬ Time.Current[]; IoCPA[0].timeOutTime¬    IoCPA[0].timeCmdStarted+ DiagFlTapeTestControl.CmdTimeOutInSeconds; IoCPA[0].opPtr­.function ¬ readSector; IoCPA[0].rtndStatus¬ LocalInitiate[operationPtr: IoCPA[0].opPtr]; WaitForCompletion[];  -- perform ReadID IoCPA[0].opPtr­.function ¬ readID; IoCPA[0].opPtr­.address ¬ oldAddress;  -- restore original address IoCPA[0].timeCmdStarted¬ Time.Current[]; IoCPA[0].timeOutTime¬    IoCPA[0].timeCmdStarted+ DiagFlTapeTestControl.CmdTimeOutInSeconds; IoCPA[0].rtndStatus¬ LocalInitiate[operationPtr: IoCPA[0].opPtr]; WaitForCompletion[];  END; --ReadID -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- performs read data operation -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ReadSector: PUBLIC PROCEDURE = BEGIN IoCPA[0].timeCmdStarted¬ Time.Current[]; IoCPA[0].timeOutTime¬    IoCPA[0].timeCmdStarted+ DiagFlTapeTestControl.CmdTimeOutInSeconds; IoCPA[0].rtndStatus¬ LocalInitiate[operationPtr: IoCPA[0].opPtr]; WaitForCompletion[];  END; --ReadSector -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- performs write data operation -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ WriteSector: PUBLIC PROCEDURE = BEGIN IoCPA[0].timeCmdStarted¬ Time.Current[]; IoCPA[0].timeOutTime¬    IoCPA[0].timeCmdStarted+ DiagFlTapeTestControl.CmdTimeOutInSeconds; IoCPA[0].rtndStatus¬ LocalInitiate[operationPtr: IoCPA[0].opPtr]; WaitForCompletion[]; END; --WriteSector -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- performs write deleted sector operation -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ WriteDelSector: PUBLIC PROCEDURE = BEGIN IoCPA[0].timeCmdStarted¬ Time.Current[]; IoCPA[0].timeOutTime¬    IoCPA[0].timeCmdStarted+ DiagFlTapeTestControl.CmdTimeOutInSeconds; IoCPA[0].rtndStatus¬ LocalInitiate[operationPtr: IoCPA[0].opPtr]; WaitForCompletion[]; END; --WriteDelSector -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- performs format track operation -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FormatTrack: PUBLIC PROCEDURE = BEGIN IoCPA[0].timeCmdStarted¬ Time.Current[]; IoCPA[0].timeOutTime¬    IoCPA[0].timeCmdStarted +     DiagFlTapeTestControl.CmdTimeOutInSeconds +       IoCPA[0].sectorOrTrackCount; IoCPA[0].rtndStatus¬ LocalInitiate[operationPtr: IoCPA[0].opPtr]; WaitForCompletion[]; END; --FormatTrack -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- resets the floppy disk controller -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ClearDiskChange: PUBLIC PROCEDURE = BEGIN FloppyDiskFace.DiskChangeClear[device: DeviceHandle]; --pick up a new handle DeviceHandle¬ FloppyDiskFace.nullDeviceHandle; GetDeviceHandle[]; --DeviceHandle¬ FloppyDiskFace.GetNextDevice[DeviceHandle]; IF DeviceHandle= FloppyDiskFace.nullDeviceHandle THEN ERROR;   END;  --ClearDiskChange  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- resets the floppy disk controller -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ResetController: PUBLIC PROCEDURE = BEGIN FloppyDiskFace.Reset[device: DeviceHandle]; --pick up a new handle DeviceHandle¬ FloppyDiskFace.nullDeviceHandle; GetDeviceHandle[]; --DeviceHandle¬ FloppyDiskFace.GetNextDevice[DeviceHandle]; IF DeviceHandle= FloppyDiskFace.nullDeviceHandle THEN ERROR; --set floppy controller context goodContext¬ FloppyDiskFace.SetContext[   device: DeviceHandle,   context: IOCmdContext.floppyTapeContext]; IF NOT goodContext THEN ERROR;   END;  --ResetController -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- returns tape to the beginning of the stream -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Recalibrate: PUBLIC PROCEDURE = BEGIN  END;  --Recalibrate -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- applies the proper tention to the tape -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Retention: PUBLIC PROCEDURE = BEGIN IoCPA[0].timeCmdStarted¬ Time.Current[]; IoCPA[0].timeOutTime¬    IoCPA[0].timeCmdStarted+ DiagFlTapeTestControl.CmdTimeOutInSeconds; IoCPA[0].rtndStatus¬   SpecialFloppyTapeFace.Retention[o: IoCPA[0].opPtr]; initiateCount ¬ initiateCount+1; WaitForCompletion[];  END;  --Retention -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- applies the proper tention to the tape -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RetentionFromErrCheck: PUBLIC PROCEDURE = BEGIN --first reset the controller ResetController[]; --set up the operation pointer IoCPA[2].opPtr­.device¬ DeviceHandle; IoCPA[2].opPtr­.function¬ nop; IoCPA[2].opPtr­.address.cylinder¬ 0; IoCPA[2].opPtr­.address.head¬ 0; IoCPA[2].opPtr­.address.sector¬ 1; IoCPA[2].opPtr­.dataPtr¬ ReadIDBuffPtr2; IoCPA[2].opPtr­.incrementDataPointer¬ FALSE; IoCPA[2].opPtr­.tries¬ 1; IoCPA[2].opPtr­.count¬ 1; IoCPA[2].command¬ retntn;  IoCPA[2].timeCmdStarted¬ Time.Current[]; IoCPA[2].timeOutTime¬ IoCPA[2].timeCmdStarted+ 320; IoCPA[2].rtndStatus¬ SpecialFloppyTapeFace.Retention[o: IoCPA[2].opPtr]; initiateCount ¬ initiateCount+1; WaitForCompletion[index: 2];  END;  -- of RetentionFromErrCheck -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- set the tape drive to the requested stream -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Seek: PUBLIC PROCEDURE = BEGIN  END;  --Seek  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- Get Device Handle   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetDeviceHandle: PROCEDURE = BEGIN DO    DeviceHandle¬ FloppyDiskFace.GetNextDevice[DeviceHandle];   SELECT FloppyDiskFace.GetDeviceAttributes[DeviceHandle].type FROM       DeviceTypesExtras4.fad5000 => EXIT; -- check for the right drive type       ENDCASE 			  => NULL; -- unknown or unsupported drive type   IF DeviceHandle= FloppyDiskFace.nullDeviceHandle THEN EXIT; ENDLOOP; END;  -- GetDeviceHandle   <<This is a workaround for a fix that should really be in the FloppyTapeHead.    See AR13260 &  AR13261.  This workaround taken from FloppyTapeImplD.mesa >> AR13261Workaround: PROCEDURE [iocb: FloppyDiskFace.OperationPtr, index: CARDINAL¬ 0] = BEGIN  machineIOCB: FloppyIOFaceDove.IOCBPtr ¬ LOOPHOLE[iocb, FloppyIOFaceDove.IOCBPtr]; currentStream: CARDINAL; cylinder, head, sector: CARDINAL; startingPage, failingPage: LONG CARDINAL;     IF machineIOCB.CurrentFDCCommand = 0 THEN RETURN;  -- what kind of problem is this?  IF (machineIOCB.fdcCommands[machineIOCB.CurrentFDCCommand].fdcCode = ReadData) OR    (machineIOCB.fdcCommands[machineIOCB.CurrentFDCCommand].fdcCode = WriteData) THEN    BEGIN    IF (machineIOCB.fdcCommands[machineIOCB.CurrentFDCCommand].NumberOfResultBytes #        machineIOCB.fdcCommands[machineIOCB.CurrentFDCCommand].NumberOfResultBytesRead) OR	machineIOCB.FDCHung OR machineIOCB.TimeoutOccurred THEN	 -- either NumberOfResultBytes # NumberOfResultBytesRead or 	 -- fdcHung = TRUE or timeoutOccured = TRUE        RETURN[];	      currentStream ¬ (machineIOCB.operation.address.cylinder /                      FloppyIOFaceDove.maxTracksPerStream) + 1;     -- yes, we want to know what currentStream we ENDED on     cylinder ¬ machineIOCB.fdcCommands[machineIOCB.CurrentFDCCommand].ResultBytes[4] +                 ((currentStream - 1) * FloppyIOFaceDove.maxTracksPerStream);     head ¬ machineIOCB.fdcCommands[machineIOCB.CurrentFDCCommand].ResultBytes[5];     sector ¬ machineIOCB.fdcCommands[machineIOCB.CurrentFDCCommand].ResultBytes[6];     -- point to the correct defective sector     iocb.address.cylinder ¬ cylinder;     iocb.address.head ¬ head;     iocb.address.sector ¬ sector;     --get starting page     startingPage ¬ DiskAddressToPage[     	cylinder: IoCPA[index].track,	sector: IoCPA[index].sector,	sectorsPerTrack: SectorsPerTrack];     --get failing page     failingPage ¬ DiskAddressToPage[     	cylinder: cylinder,	sector: sector,	sectorsPerTrack: SectorsPerTrack];     --calculate remaining page count     failingPage ¬ failingPage - startingPage;     iocb.count ¬ IoCPA[index].sectorOrTrackCount - Inline.LowHalf[failingPage];          END; END;  -- AR13261Workaround       DiskAddressToPage: PROCEDURE [cylinder, sector: CARDINAL, sectorsPerTrack: CARDINAL]    RETURNS [page: LONG CARDINAL] = INLINE    BEGIN     page ¬ sector;     page ¬ page + Inline.LongMult[sectorsPerTrack, cylinder];    END;	     LocalInitiate: PROCEDURE [operationPtr: FloppyDiskFace.OperationPtr]   RETURNS [FloppyDiskFace.Status] =   BEGIN   initiateCount ¬ initiateCount+1;   RETURN [FloppyDiskFace.Initiate[operationPtr]];   END;   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- Main line code  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --get the FLOPPY TAPE drive device handle GetDeviceHandle[];  IF DeviceHandle # FloppyDiskFace.nullDeviceHandle THEN   BEGIN   --get max tracks per format   MaxTracksPerFormat¬  FloppyDiskFace.MaxTracksPerFormatOperation[    device: DeviceHandle];    --get drive attributes   IOCmdContext.deviceParms¬     FloppyDiskFace.GetDeviceAttributes[device: DeviceHandle];   TracksPerTape¬ IOCmdContext.deviceParms.numberOfCylinders;   --SectorsPerTrack¬ IOCmdContext.deviceParms.maxSectorsPerTrack;   IOCmdContext.floppyTapeContext.protect¬ FALSE;   IOCmdContext.floppyTapeContext.format¬ IBM;   IOCmdContext.floppyTapeContext.density¬ double;   IOCmdContext.floppyTapeContext.sectorLength¬ 256; --words     --set floppy controller context   goodContext¬ FloppyDiskFace.SetContext[     device: DeviceHandle,     context: IOCmdContext.floppyTapeContext];   IF goodContext THEN     { --create read and write buffer space and set the pointers     ptr¬ Space.ScratchMap[count: pageCnt];     WrBuffArray[0]¬ WriteBuffPtr1¬ ptr;     ptr¬ ptr+(writeBuffSizeInPages*Environment.wordsPerPage);     RdBuffArray[0]¬ ReadBuffPtr1¬ ptr;     ptr¬ ptr+(readBuffSizeInPages*Environment.wordsPerPage);     RdIDBuffArray[0]¬ ReadIDBuffPtr1¬ ptr;     ptr¬ ptr+(readIDBuffSizeInPages*Environment.wordsPerPage);     WrBuffArray[1]¬ WriteBuffPtr2¬ ptr;     ptr¬ ptr+(writeBuffSizeInPages*Environment.wordsPerPage);     RdBuffArray[1]¬ ReadBuffPtr2¬ ptr;     ptr¬ ptr+(readBuffSizeInPages*Environment.wordsPerPage);     RdIDBuffArray[1]¬ ReadIDBuffPtr2¬ ptr;     -- allocate scratch page-aligned buffer     ptr¬ ptr+(readIDBuffSizeInPages*Environment.wordsPerPage);     scratchPageAlignedBuff ¬ ptr;      --create the IO operation spaces     [pOp: IoCPA[0].opPtr, pStorage: opStorage0] ¬ GetOperationPtr[];     [pOp: IoCPA[1].opPtr, pStorage: opStorage1] ¬ GetOperationPtr[];     [pOp: IoCPA[2].opPtr, pStorage: opStorage2] ¬ GetOperationPtr[];      << Added the next line to compensate for difference the in the way retention and format track      is implemented in DLight and Dove.  Dove retention and format track requires a valid dataPtr,     so to make it happy...>>      -- initialize to point to a valid data space     IoCPA[0].opPtr.dataPtr ¬ WriteBuffPtr1;     } -- IF goodContext...        ELSE DeviceHandle¬ FloppyDiskFace.nullDeviceHandle;  -- NOT goodContext      END;  -- DeviceHandle#FloppyDiskFace.nullDeviceHandle  END...--of DiagFlTapeCmdsImpl.mesa  Log 9-Feb-88 13:38:39 JMA: Added GetDeviceHandle Proc.16-Feb-88  9:55:24 JMA: initialized dataPtr to point to a valid space.18-Feb-88 15:13:35 JMA: Made ReadID proc perform a ReadSector first for positioning. 8-Mar-88 11:32:31 JMA: Don't crash if EEPROM not configured correctly.10-Mar-88 10:51:18 JMA: ResetController[] to force IOCB to return if CmdTimedOut. 8-Jun-88 16:54:29 JMA: added workaround for AR1326111-Jun-88 12:39:08 JMA: replace call to FloppyDiskFace.Initiate with LocalInitiate proc  			for debug.  initiateCount must balance out to 0.  This			means that there was FloppyDiskFace.Poll call for every			FloppyDiskFace.Initiate call.  If not then trouble.   	 
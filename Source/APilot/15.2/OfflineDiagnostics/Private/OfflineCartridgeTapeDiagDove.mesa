-- File: OfflineCartridgeTapeDiagDove.mesa-- Last edited  3-Jun-88 15:49:00 JMA ---- Copyright (C) 1987, 1988 Xerox Corporation. All rights reserved.--DIRECTORY  DiagDiskTime	       USING   [ SetRealTimeClock, RealTimeClockFailure],  DiagDiskMkTime       USING   [ DiagDiskMkTimeImpl, mkTime],  OfflineDiagInterface USING   [ OfflineDiagnosticProc, ResultType, userType,  			         TestItemsForThisNode, GetATestItemsForThisNode,			      	 TestItem, GetATestItem, ClientPackage,			         AMenuOfSelections, GetAMenuOfSelections,			      	 Selections, GetASelectionArray, DiagHeap,			       	 HelpText, GetAHelpText, AbortCurrentTest,			      	 PutData, OptionsRecord, FixedPositionDisplayRecord,				 GetAFixedPositionDisplayRecord, PutTestParameters,				 PutMessage, HitAnyKeyToContinue],  DiagFlTapeDisplay	USING	[LastReadID, ErrorTable, BadPageTable, 				 ReadData, WriteData],  DiagFlTapeMkMenu     	USING	[ mkMenu, MkMenu, DiagFlTapeMkMenuImpl ],  DiagFlTapeMkDispl   	USING 	[ mkDispl, MkDispl, DiagFlTapeMkDisplImpl ],  DiagFlTapeOpInt	USING	[ClearLogIn, Engineering, GetUser, Switch,				 Manufacturing,	SystemAdmin, TechRep, TechSpec,				 User],  DiagFlTapeCmdDrive	USING	[DiagFlTapeCmdDriveImpl],  DiagFlTapeCmdDes	USING	[DiagFlTapeCmdDesImpl ],  DiagFlTapeCmds	USING	[DeviceHandle, DiagFlTapeCmdsImpl],  DiagFlTapeMkIOCmd	USING	[DiagFlTapeMkIOCmdImpl],  DiagFlTapeMkOpInt	USING	[mkOpInt, DiagFlTapeMkOpIntImpl],  DiagFlTapeMkSubtest	USING	[DiagFlTapeMkSubtestImpl],  --DiagMkTime		USING	[DiagMkTimeImpl],  DiagFlTapeRunCmdFile	USING	[BuildNewFile, RunPriorFile, RunSubtests],  DiagFlTapeTestCmdArrays USING	[DiagFlTapeTestCmdArraysImpl],  DiagFlTapeErrorCheck	USING	[NumOfSoftErrs, SoftErrBuffPtr, 				 SoftErrCntBuffPtr, NumOfHardReadErrs,				 HardReadErrBuffPtr, DiagFlTapeErrorCheckImpl],  DiagFlTapeLog		USING	[DisplayErrorLog, DisplayTrace, DiagFlTapeLogImpl],  DiagFlTapeTests	USING	[FormatTape, RetentionTape, ScavengeTape,				 ConfidenceTest, LogBadPage, ManufCheckOut,				 SurfaceVerification, ChecksumTape, 				 Exerciser, WriteKnownData, ReadKnownData],  DiagFlTapeTestControl	USING	[DiagFlTapeTestControlImpl, DisplaySummaryOnHardErr],  DiagFlTapeTestRec    	USING   [DiagFlTapeTestRecImpl ],  String	      	USING   [AppendDecimal, MakeString, AppendString],  DiagFlTapeTTY		USING	[CharsPerLine, DiagFlTapeTTYImpl, Initialize, PutCR,  				 PutMenu, UserAbort, SelectOptions],  DiagFlTapeTestSelect	USING	[],		-- Export it.  FloppyDiskFace	USING	[nullDeviceHandle],  Driver		USING   [Device, GetDeviceChain],  Runtime		USING   [StartFault, UnboundProcedure],  System		USING   [switches],				   OfflineDiagInterfaceExtra USING [];		-- Export it.  OfflineCartridgeTapeDiagDove: PROGRAM	 IMPORTS OfflineDiagInterface,	 	DiagDiskMkTime, DiagDiskTime, 		--Process,-- Runtime, String,		Driver,		DiagFlTapeTTY,		DiagFlTapeCmdDrive,		DiagFlTapeOpInt,		DiagFlTapeCmdDes,		DiagFlTapeCmds,		DiagFlTapeMkDispl,		DiagFlTapeMkIOCmd,		DiagFlTapeMkMenu,		DiagFlTapeMkOpInt,		DiagFlTapeMkSubtest,		DiagFlTapeTestCmdArrays,		--DiagMkTime,		DiagFlTapeDisplay,		DiagFlTapeErrorCheck,		DiagFlTapeLog,		DiagFlTapeTestControl,		DiagFlTapeTests,		DiagFlTapeRunCmdFile,		DiagFlTapeTestRec,		FloppyDiskFace,		System		 		 	 EXPORTS OfflineDiagInterfaceExtra,		 DiagFlTapeTestSelect =BEGIN OPEN  DiagFlTapeMkMenu,	    DiagFlTapeMkDispl,	    DiagFlTapeMkOpInt,	    DiagFlTapeMkIOCmd,	    DiagFlTapeTTY,	    Odi: OfflineDiagInterface; 	 -- ODI stands for OfflineDiagInterface.  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- First declare various structures and constants that will be used.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Private TYPEs  userWantsToCont: BOOLEAN ¬ TRUE;	-- proceed with testing  userWantsToAbort: BOOLEAN ¬ FALSE;  testInProgress: BOOLEAN ¬ FALSE;  abortWatcherGoHome: BOOLEAN ¬ FALSE;  leftEdge: CARDINAL = 3;		-- where fixed display starts on the screen  etherOff: BOOLEAN ¬ FALSE;  -- Public TYPEs and Variables  CTapeTestResult: PUBLIC TYPE = Odi.ResultType;  cTapeTestResult: PUBLIC CTapeTestResult ¬ nullResult;    Exit:		PUBLIC SIGNAL= CODE;  Restart:	PUBLIC SIGNAL= CODE;  Retry:	PUBLIC SIGNAL= CODE;  NotImplemented: PUBLIC SIGNAL = CODE;  currentOptDispl: PUBLIC LONG POINTER TO Odi.OptionsRecord ¬ NIL;    --~~~~~~~~~~~~~~~~~~~~~~~-- Top level menu stuffs--~~~~~~~~~~~~~~~~~~~~~~~  --  -- topLevelMenuNode points to a RECORD, AMenuOfSelections, containing pointers    -- to various elements of the top level menu node.   --  -- Each menu item may be a real test or a submenu. Each submenu is also a  -- AMenuOfSelections.  --    topLevelMenuNode: LONG POINTER TO Odi.AMenuOfSelections;    -- topLevelMenuSelections points to a SEQUENCE containing pointers to all    -- TestItems in the topmenu.  topLevelMenuSelections: LONG POINTER TO Odi.TestItemsForThisNode;     -- Test numbers for the topLevelMenuNode defined for clarity convenience.   -- These correspond to the topLevelMenuSelections indices into which   -- the pointers to TestItems are to be stored. They will be assigned  -- to the selections arrays for each class of user  --  --~~~~~~~~~~~~~~~~~~~~~~~~~~-- First (TOP) level menu stuffs--~~~~~~~~~~~~~~~~~~~~~~~~~~  --  -- first LevelMenuNode is for:  --	utility options  --	confidence test  --	surface verify  --	exerciser  --	write tape  --	read tape  --	display options  --	command file options  --	subtest options  --	manufacturing check out    ctUtilityOpt: CARDINAL = 0;		-- topLevelMenuSelections.nodeItems [0]  ctConfidenceTest: CARDINAL = 1;	-- topLevelMenuSelections.nodeItems [1]  ctSurfaceVerify: CARDINAL = 2; 	-- topLevelMenuSelections.nodeItems [2]  ctExerciser: CARDINAL = 3;		-- topLevelMenuSelections.nodeItems [3]  ctWriteTapeKnownData: CARDINAL = 4;	-- topLevelMenuSelections.nodeItems [4]  ctReadTapeKnownData: CARDINAL = 5;	-- topLevelMenuSelections.nodeItems [5]  ctDisplayOptions: CARDINAL = 6;	-- topLevelMenuSelections.nodeItems [6]  ctCommandFileOptions: CARDINAL = 7; 	-- topLevelMenuSelections.nodeItems [7]  ctSubtestOptions: CARDINAL = 8;	-- topLevelMenuSelections.nodeItems [8]  ctMfgCheckOut: CARDINAL = 9;		-- topLevelMenuSelections.nodeItems [9]    -- pTestItem points to a RECORD containing all the components of a TestItem.   pTestItem: LONG POINTER TO Odi.TestItem;   -- optItem points to a RECORD containing all the components of a AnOptionLine.   --  optItem: LONG POINTER TO Odi.AnOptionLine;  -- The following pointers point to SEQUENCES specifying tests for the various-- user classes.  pAdminSelections, pUserSelections: LONG POINTER TO Odi.Selections;  pFieldServiceSelections, pManufacturingSelections: LONG POINTER TO Odi.Selections;  	  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Declarations for convenience--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  nullResult: Odi.ResultType = none;  goodResult: Odi.ResultType = passed;  badResult: Odi.ResultType = failed;  ambiguousResult: Odi.ResultType = ambiguous;    defaultToYes: BOOLEAN = TRUE;  defaultToNo: BOOLEAN = FALSE;  diagHasBeenStartedBefore: BOOLEAN ¬ FALSE;--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Common definitions --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Help texts--  numOfRepeatHelpTxt, stopAndAskHelpTxt: LONG POINTER TO Odi.HelpText;-- Positionally-fixed data--  repeatTopDisplay: LONG POINTER TO Odi.FixedPositionDisplayRecord;  -- Scratch variables to be re-used thru-out package--  lin1, lin2 : LONG POINTER TO Odi.ARow;--  item2Pos: CARDINAL;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Common support procedures  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    <<This proc used to display the selected display options>> GetDisplay: PROCEDURE = BEGIN   getout: BOOLEAN¬ FALSE;   num: CARDINAL;   title:	LONG STRING¬ mkMenu[dsplOptionsTtl];   options:	ARRAY [0..7] OF LONG STRING¬ [	mkMenu[dsplErrLog],	mkMenu[dsplSoftErrs],	mkMenu[dsplHardRdErrs],	mkMenu[dsplTrace],	mkMenu[dsplReadIDBuff],	mkMenu[dsplWriteBuff],	mkMenu[dsplReadBuff],	mkMenu[dsplBadScTbl]];  questtext:	ARRAY [0..8] OF LONG STRING¬ [	mkMenu[dsplErrLogExpl],	mkMenu[dsplSoftErrsExpl],	mkMenu[dsplHardRdErrsExpl],	mkMenu[dsplTraceExpl],	mkMenu[dsplReadIDBuffExpl],	mkMenu[dsplWriteBuffExpl],	mkMenu[dsplReadBuffExpl],	mkMenu[dsplBadScTblExpl],	mkMenu[returnsToPriorMenu]];   UNTIL getout DO     DiagFlTapeTTY.Initialize [];     DiagFlTapeTTY.PutCR[];	     num¬ DiagFlTapeTTY.PutMenu[	 title: title,	 options: DESCRIPTOR [options],	 numberExplanations: TRUE,	 optionExplanation: DESCRIPTOR [questtext]	! DiagFlTapeTTY.UserAbort=> { num¬ 0; getout¬ TRUE; CONTINUE};	  Odi.AbortCurrentTest=> { num¬ 0; getout¬ TRUE; CONTINUE}];     DiagFlTapeTTY.PutCR [];	      SELECT num FROM      1=>  DiagFlTapeLog.DisplayErrorLog [           ! Exit => CONTINUE;             Retry=> RETRY;             Restart=> CONTINUE;             DiagFlTapeTTY.UserAbort => CONTINUE;	     Odi.AbortCurrentTest=> CONTINUE];      2=>  DiagFlTapeDisplay.ErrorTable [            title: mkDispl[softErrDspL], 	    errorCount: DiagFlTapeErrorCheck.NumOfSoftErrs, 	    errorBuff: DESCRIPTOR[DiagFlTapeErrorCheck.SoftErrBuffPtr­], 	    errorCountBuff: DESCRIPTOR[DiagFlTapeErrorCheck.SoftErrCntBuffPtr­]           ! Exit => CONTINUE;             Retry=> RETRY;             Restart=> CONTINUE;	     DiagFlTapeTTY.UserAbort => CONTINUE;	     Odi.AbortCurrentTest=> CONTINUE];     3=>  DiagFlTapeDisplay.ErrorTable [            title: mkDispl[hardRdErrDspL], 	    errorCount: DiagFlTapeErrorCheck.NumOfHardReadErrs, 	    errorBuff: DESCRIPTOR[DiagFlTapeErrorCheck.HardReadErrBuffPtr­]           ! Exit => CONTINUE;             Retry=> RETRY;             Restart=> CONTINUE;	     DiagFlTapeTTY.UserAbort => CONTINUE;	     Odi.AbortCurrentTest=> CONTINUE];     4=>  DiagFlTapeLog.DisplayTrace [         ! Exit => CONTINUE;           Retry=> RETRY;           Restart=> CONTINUE;	   DiagFlTapeTTY.UserAbort => CONTINUE;	   Odi.AbortCurrentTest=> CONTINUE];     5=>  DiagFlTapeDisplay.LastReadID[         ! Exit => CONTINUE;           Retry=> RETRY;           Restart=> CONTINUE;	   DiagFlTapeTTY.UserAbort => CONTINUE;	   Odi.AbortCurrentTest=> CONTINUE];     6=>  DiagFlTapeDisplay.WriteData[         ! Exit => CONTINUE;           Retry=> RETRY;           Restart=> CONTINUE;	   DiagFlTapeTTY.UserAbort => CONTINUE;	   Odi.AbortCurrentTest=> CONTINUE];     7=>  DiagFlTapeDisplay.ReadData[         ! Exit => CONTINUE;           Retry=> RETRY;           Restart=> CONTINUE;	   DiagFlTapeTTY.UserAbort => CONTINUE;	   Odi.AbortCurrentTest=> CONTINUE];     8=>  DiagFlTapeDisplay.BadPageTable[         ! Exit => CONTINUE;           Retry=> RETRY;           Restart=> CONTINUE;	   DiagFlTapeTTY.UserAbort => CONTINUE;	   Odi.AbortCurrentTest=> CONTINUE];     9=>  getout¬ TRUE;    ENDCASE;  ENDLOOP;	  END; --GetDisplay    --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Procedures menu selections invoke--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- PROCs for FIRST LEVEL MENUUtilityOptMainProc: Odi.OfflineDiagnosticProc =  BEGIN  getout: BOOLEAN¬ FALSE;  num: CARDINAL;  title:	LONG STRING¬ mkMenu[utilOptionsTtl]; options:	ARRAY [0..4] OF LONG STRING¬ [	mkMenu[retentionTape],	mkMenu[formatTape],	mkMenu[logBadPage],	mkMenu[scavengeTape],	mkMenu[checksumTape]]; questtext:	ARRAY [0..5] OF LONG STRING¬ [	mkMenu[retentionTapeExpl],	mkMenu[formatTapeExpl],	mkMenu[logBadPageExpl],	mkMenu[scavengeTapeExpl],	mkMenu[checksumExpl],	mkMenu[returnsToPriorMenu]];   UNTIL getout DO    DiagFlTapeTTY.Initialize [];    DiagFlTapeTTY.PutCR[];    num¬ DiagFlTapeTTY.PutMenu[	 title: title,	 options: DESCRIPTOR [options],	 numberExplanations: TRUE,	 optionExplanation: DESCRIPTOR [questtext]	 ! DiagFlTapeTTY.UserAbort=> { num¬ 0; getout¬ TRUE; CONTINUE};	   Odi.AbortCurrentTest=> { num¬ 0; getout¬ TRUE; CONTINUE}];    DiagFlTapeTTY.PutCR [];      SELECT num FROM      1 => DiagFlTapeTests.RetentionTape[	   ! Restart => {DiagFlTapeOpInt.ClearLogIn []; CONTINUE};	     Retry=> RETRY;	     Exit => CONTINUE;	     DiagFlTapeTTY.UserAbort => CONTINUE;	     Odi.AbortCurrentTest => CONTINUE];      2 => DiagFlTapeTests.FormatTape[	   ! Restart => {DiagFlTapeOpInt.ClearLogIn []; CONTINUE};	     Retry=> RETRY;	     Exit => CONTINUE;	     DiagFlTapeTTY.UserAbort => CONTINUE;	     Odi.AbortCurrentTest => CONTINUE];      3 => DiagFlTapeTests.LogBadPage[	   ! Restart => {DiagFlTapeOpInt.ClearLogIn []; CONTINUE};	     Retry=> RETRY;	     Exit => CONTINUE;	     DiagFlTapeTTY.UserAbort => CONTINUE;	     Odi.AbortCurrentTest => CONTINUE];      4=>  DiagFlTapeTests.ScavengeTape[           ! Exit => CONTINUE;             Retry=> RETRY;             Restart=> CONTINUE;	     DiagFlTapeTTY.UserAbort => CONTINUE;	     Odi.AbortCurrentTest => CONTINUE];       5=>  DiagFlTapeTests.ChecksumTape[           ! Exit => CONTINUE;             Retry=> RETRY;             Restart=> CONTINUE;	     DiagFlTapeTTY.UserAbort => CONTINUE;	     Odi.AbortCurrentTest => CONTINUE];       6=> getout¬ TRUE;      ENDCASE;  ENDLOOP;		  RETURN [nullResult];  END; -- UtilityOptMainProc  ConfidenceMainProc: Odi.OfflineDiagnosticProc =  BEGIN  testParmRecordPtr:	LONG POINTER TO Odi.FixedPositionDisplayRecord;    testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [0];  testParmRecordPtr.displayTitle ¬ mkMenu[confidenceTestTtL];  Odi.PutTestParameters [parameters: testParmRecordPtr, 			upDateOnly: FALSE];			  DiagFlTapeTests.ConfidenceTest[	   ! Restart => {DiagFlTapeOpInt.ClearLogIn []; CONTINUE};	     Retry=> RETRY;	     Exit => CONTINUE;	     DiagFlTapeTTY.UserAbort => CONTINUE];	       RETURN [nullResult];  END; -- ConfidenceMainProc SurfaceVerifyMainProc: Odi.OfflineDiagnosticProc =  BEGIN  testParmRecordPtr:	LONG POINTER TO Odi.FixedPositionDisplayRecord;    testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [0];  testParmRecordPtr.displayTitle ¬ mkMenu[surfaceVerTitlE];  Odi.PutTestParameters [parameters: testParmRecordPtr, 			upDateOnly: FALSE];			  DiagFlTapeTests.SurfaceVerification[	   ! Restart => {DiagFlTapeOpInt.ClearLogIn []; CONTINUE};	     Retry=> RETRY;	     Exit => CONTINUE;	     DiagFlTapeTTY.UserAbort => CONTINUE];	       RETURN [nullResult];  END; -- SurfaceVerifyMainProcExerciserMainProc: Odi.OfflineDiagnosticProc =  BEGIN  testParmRecordPtr:	LONG POINTER TO Odi.FixedPositionDisplayRecord;    testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [0];  testParmRecordPtr.displayTitle ¬ mkMenu[exerciserTitlE];  Odi.PutTestParameters [parameters: testParmRecordPtr, 			upDateOnly: FALSE];	     IF DiagFlTapeOpInt.User THEN        DiagFlTapeOpInt.ClearLogIn[] --User's item 4 is Exit.     ELSE IF DiagFlTapeOpInt.SystemAdmin THEN --SysAdmin's item 4 is Display Opts.       GetDisplay[	  ! Restart => {DiagFlTapeOpInt.ClearLogIn []; CONTINUE};	    Retry=> RETRY;	    Exit => CONTINUE;	    DiagFlTapeTTY.UserAbort => CONTINUE]      ELSE       DiagFlTapeTests.Exerciser[ --Item #4 for everyone else is Exerciser	  ! Restart => {DiagFlTapeOpInt.ClearLogIn []; CONTINUE};	    Retry=> RETRY;	    Exit => CONTINUE;	    DiagFlTapeTTY.UserAbort => CONTINUE];  END; -- ExerciserMainProcWriteDataMainProc: Odi.OfflineDiagnosticProc =  BEGIN  testParmRecordPtr:	LONG POINTER TO Odi.FixedPositionDisplayRecord;    testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [0];  testParmRecordPtr.displayTitle ¬ mkMenu[wrKnwnDtTitlE];  Odi.PutTestParameters [parameters: testParmRecordPtr, 			upDateOnly: FALSE];	  DiagFlTapeTests.WriteKnownData[       ! Restart => {DiagFlTapeOpInt.ClearLogIn []; CONTINUE};         Retry=> RETRY;         Exit => CONTINUE;         DiagFlTapeTTY.UserAbort => CONTINUE];	   RETURN [nullResult];  END; -- WriteDataMainProc    ReadDataMainProc: Odi.OfflineDiagnosticProc =  BEGIN  testParmRecordPtr:	LONG POINTER TO Odi.FixedPositionDisplayRecord;    testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [0];  testParmRecordPtr.displayTitle ¬ mkMenu[rdKnwnDtTitlE];  Odi.PutTestParameters [parameters: testParmRecordPtr, 			upDateOnly: FALSE];	  DiagFlTapeTests.ReadKnownData[       ! Restart => {DiagFlTapeOpInt.ClearLogIn []; CONTINUE};         Retry=> RETRY;         Exit => CONTINUE;         DiagFlTapeTTY.UserAbort => CONTINUE];	   RETURN [nullResult];  END; -- ReadDataMainProc  DisplayOptMainProc: Odi.OfflineDiagnosticProc =  BEGIN  GetDisplay[];  RETURN [nullResult];  END; -- DisplayOptMainProc  CmdFileMainProc: Odi.OfflineDiagnosticProc =  BEGIN  getout:	BOOLEAN¬ FALSE;  num: 		CARDINAL;  options:	ARRAY [0..1] OF LONG STRING¬ [			mkMenu[buildCmdFile],			mkMenu[rerunCmdFile]];  questtext:	ARRAY [0..2] OF LONG STRING¬ [			mkMenu[buildCmdFileExpl],			mkMenu[rerunCmdFileExpl],			mkMenu[returnsToPriorMenu]];  title:	LONG STRING¬ mkMenu[cmdFileOptsTtl];    DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ FALSE;    UNTIL getout DO    DiagFlTapeTTY.Initialize [];    num¬ DiagFlTapeTTY.PutMenu [		title: title,		options: DESCRIPTOR [options],		numberExplanations: TRUE,		optionExplanation: DESCRIPTOR [questtext]	        ! DiagFlTapeTTY.UserAbort=> { getout¬ TRUE; num¬ 0; CONTINUE };		  Odi.AbortCurrentTest=> { getout¬ TRUE; num¬ 0; CONTINUE }];		    SELECT num FROM      1=> DiagFlTapeRunCmdFile.BuildNewFile [	   ! DiagFlTapeTTY.UserAbort => CONTINUE;	     Exit => CONTINUE;	     Odi.AbortCurrentTest=> CONTINUE];       2=> DiagFlTapeRunCmdFile.RunPriorFile [	   ! DiagFlTapeTTY.UserAbort => CONTINUE;	     Exit => CONTINUE;	     Odi.AbortCurrentTest=> CONTINUE];      3=> getout¬ TRUE;    ENDCASE;  ENDLOOP;    RETURN [nullResult];		  END; -- CmdFileMainProc  SubtestOptMainProc: Odi.OfflineDiagnosticProc =  BEGIN	  DiagFlTapeRunCmdFile.RunSubtests[	     ! Restart => {DiagFlTapeOpInt.ClearLogIn []; CONTINUE};	       Retry=> RETRY;	       Exit => CONTINUE;	       DiagFlTapeTTY.UserAbort => CONTINUE];    RETURN [nullResult];  END; -- SubtestOptMainProcMfgCheckOutMainProc: Odi.OfflineDiagnosticProc =  BEGIN  testParmRecordPtr:	LONG POINTER TO Odi.FixedPositionDisplayRecord;    testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [0];  testParmRecordPtr.displayTitle ¬ mkMenu[manufChkOutTitlE];  Odi.PutTestParameters [parameters: testParmRecordPtr, 			upDateOnly: FALSE];	     IF DiagFlTapeOpInt.TechSpec THEN DiagFlTapeOpInt.ClearLogIn[] --Exit     ELSE DiagFlTapeTests.ManufCheckOut[	       ! Restart => {DiagFlTapeOpInt.ClearLogIn []; CONTINUE};	         Retry=> RETRY;	         Exit => CONTINUE;	         DiagFlTapeTTY.UserAbort => CONTINUE];		   RETURN [nullResult];  END; -- MfgCheckOutMainProc  << *** Code taken from Julie Craig's TurnEthernetOff and TurnEthernetOn ***Turning off the ethernet improves floppy disk and cartridge tape performance>>TurnEthernetOff: PROCEDURE =  BEGIN  << If we trip UnboundProcedure then this module is part of OfflineCartTapeDiagDove.boot,  as oppose to OfflineCartridgeTapeDiagnosticConfigDove.bcd of the the multi-floppy system.  The bootfile does not start the communication package and so we don't have to worry about  the ethernet.  Whoever exports Driver does not seem to be bound in with the bootfile.  An alternative would be to bind it in and then turn it off.  Seems like a lot of effort  just to turn shut something down.  The floppy-based diagnostic contains the exporting module --probable in the floppy exec--  and the comm. package is started.  In this situation, we have to turn off the ethernet  to allow cartridge diag to run unaffected. >>   ENABLE Runtime.UnboundProcedure=> GOTO GoHome;      device:Driver.Device ¬ Driver.GetDeviceChain[];  device.alive ¬ FALSE;  device.deactivateDriver[];    EXITS GoHome => {};  END;  -- TurnEthernetOff  << TurnEthernetOn: PROCEDURE =  BEGIN  ENABLE Runtime.UnboundProcedure => GOTO GoHome;    device:Driver.Device ¬ Driver.GetDeviceChain[];  device.activateDriver[];  device.alive ¬ TRUE;    EXITS GoHome => {};  END;  -- TurnEthernetOn>><< Proc to create a different menu if the an unrecoverable error	is detected at CartridgeTape initialization time.  >>CreateAlternateUniverse: PROC =  BEGIN    topLevelMenuNode ¬ Odi.GetAMenuOfSelections [];  -- a universe without any choices! User can only "Return To Previous Menu"    topLevelMenuSelections ¬ Odi.GetATestItemsForThisNode [0];  pTestItem ¬ Odi.GetATestItem [];  -- all users get the same treatmet  pUserSelections ¬ Odi.GetASelectionArray [0];  topLevelMenuNode.menuTitle ¬ mkOpInt[disabledCartTapeDiag];  topLevelMenuNode.userSelections ¬ pUserSelections;  topLevelMenuNode.adminSelections ¬ pUserSelections;  topLevelMenuNode.seSelections ¬ pUserSelections;  topLevelMenuNode.manufacturingSelections ¬ pUserSelections;  topLevelMenuNode.programmerSelections ¬ pUserSelections;  topLevelMenuNode.testItemsForThisNode ¬ topLevelMenuSelections;END;  -- CreateAlternateUniverse--******************************************************************************-- Build up all the data structures for this package, which has three menu nodes--******************************************************************************-- *************************-- CREATE MENU AND SUB-MENUS-- *************************--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Top level menu stuffs - 10 possible selections--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~InitializePackage: PROCEDURE =   BEGIN   menuHelp:	LONG POINTER TO Odi.HelpText;      --***** INTERNAL PROC  *****   SetupMenuHelp: PROCEDURE [] =    BEGIN   textLen:	CARDINAL ¬ 4;   str:		LONG STRING ¬ NIL;   questtext:	ARRAY [0..10] OF LONG STRING¬ ALL [NIL];     questtext	[0]¬ mkMenu[utilOptionsExpl];   questtext	[1]¬ mkMenu[confidenceTestExpl];   questtext	[2]¬ mkMenu[surfaceVerifyExpl];   questtext	[3]¬ mkMenu[returnToBegin];     IF DiagFlTapeOpInt.SystemAdmin THEN   { questtext	[3]¬ mkMenu[dsplOptionsExpl];     questtext	[4]¬ mkMenu[returnToBegin];     textLen ¬ 5;   };     IF DiagFlTapeOpInt.TechRep THEN   { questtext	[3]¬ mkMenu[exerciserExpl];     questtext	[4]¬ mkMenu[dsplOptionsExpl];     questtext	[5]¬ mkMenu[returnToBegin];     textLen ¬ 6;   };       IF  DiagFlTapeOpInt.TechSpec     OR DiagFlTapeOpInt.Manufacturing     OR DiagFlTapeOpInt.Engineering THEN   { questtext	[3]¬ mkMenu[exerciserExpl];     questtext	[4]¬ mkMenu[writeKnownDataExpl];     questtext	[5]¬ mkMenu[readKnownDataExpl];     questtext	[6]¬ mkMenu[dsplOptionsExpl];     questtext	[7]¬ mkMenu[cmdFileOptionsExpl];     questtext	[8]¬ mkMenu[subtestOptionsExpl];     questtext	[9]¬ mkMenu[returnToBegin];     textLen ¬ 10;   };   IF DiagFlTapeOpInt.Manufacturing     OR DiagFlTapeOpInt.Engineering THEN   { questtext	[9]¬ mkMenu[manufCheckOutExpl];     questtext	[10]¬ mkMenu[returnToBegin];     textLen ¬ 11;   };      menuHelp ¬ Odi.GetAHelpText [textLen];   menuHelp.helpTitle ¬ mkMenu[testSelection];   FOR inx:CARDINAL IN [0..textLen) DO      -- create string then append the number and spacing      str ¬ String.MakeString [Odi.DiagHeap, DiagFlTapeTTY.CharsPerLine];      str.length ¬ 0;      String.AppendDecimal [str, inx+1];      String.AppendString [str, " - "L];      String.AppendString [str, questtext[inx]];      menuHelp.textBody[inx] ¬ str;   ENDLOOP;      END; -- SetupMenuHelp    --***** END OF INTERNAL PROC  *****       -- Get a container to hold all items of the top menu node. This is passed to the-- Control Module.  topLevelMenuNode ¬ Odi.GetAMenuOfSelections [];-- There are 10 selections for the top menu; so we need a TestItemsForThisNode -- that can hold 10 pointers to the different TestItems.  topLevelMenuSelections ¬ Odi.GetATestItemsForThisNode [10];  -- For each of the selections, an instance of TestItem is needed.  -- utility options selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ mkMenu [utilOptions]; 	 	 -- Test name     pTestItem.test ¬ UtilityOptMainProc; 			 --   pTestItem.subMenu ¬ NIL;				 --   pTestItem.itemExplanation ¬ mkMenu [utilOptionsExpl];  -- Online help  topLevelMenuSelections.nodeItems [0] ¬ pTestItem;	 -- Store TestItem pointer.  -- Confidence Test selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ mkMenu [confidenceTest]; 	 -- Test name     pTestItem.test ¬ ConfidenceMainProc; 			 --   pTestItem.subMenu ¬ NIL;				 -- no sub-menu  pTestItem.itemExplanation ¬ mkMenu [confidenceTestExpl];	 -- Online help  topLevelMenuSelections.nodeItems [1] ¬ pTestItem;	 -- Store TestItem pointer.  -- Surface Verify selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ mkMenu [surfaceVerify]; 	 	 -- Test name     pTestItem.test ¬ SurfaceVerifyMainProc; 		 -- Actual test procedure  pTestItem.subMenu ¬ NIL;				 -- no sub-menu  pTestItem.itemExplanation ¬ mkMenu [surfaceVerifyExpl];-- Online help  topLevelMenuSelections.nodeItems [2] ¬ pTestItem;	 -- Store TestItem pointer.    -- Exerciser selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ mkMenu [exerciser]; 		 -- Test name   pTestItem.test ¬ ExerciserMainProc; 			 -- Actual test procedure  pTestItem.subMenu ¬ NIL;				 -- no sub-menu  pTestItem.itemExplanation ¬ mkMenu [exerciserExpl];	 -- Online help  topLevelMenuSelections.nodeItems [3] ¬ pTestItem;	 -- Store TestItem pointer.  -- Write Tape selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ mkMenu [writeKnownData]; 	 -- Test name     pTestItem.test ¬ WriteDataMainProc; 		 	 -- Actual test procedure  pTestItem.subMenu ¬ NIL;				 -- no sub-menu  pTestItem.itemExplanation ¬ mkMenu [writeKnownDataExpl]; -- Online help  topLevelMenuSelections.nodeItems [4] ¬ pTestItem;	 -- Store TestItem pointer.    -- Read Tape selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ mkMenu [readKnownData]; 	 -- Test name     pTestItem.test ¬ ReadDataMainProc; 		 -- Not a test but a sub-menu  pTestItem.subMenu ¬ NIL;				 -- no sub-menu  pTestItem.itemExplanation ¬ mkMenu [readKnownDataExpl]; -- Online help  topLevelMenuSelections.nodeItems [5] ¬ pTestItem;	 -- Store TestItem pointer.    -- Display Options selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ mkMenu [dsplOptions]; 		 -- Test name     pTestItem.test ¬ DisplayOptMainProc; 			 --   pTestItem.subMenu ¬ NIL;	 			 --   pTestItem.itemExplanation ¬ mkMenu [dsplOptionsExpl];  -- Online help  topLevelMenuSelections.nodeItems [6] ¬ pTestItem;	 -- Store TestItem pointer.    -- Command File selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ mkMenu [cmdFileOptions]; 	 -- Test name     pTestItem.test ¬ CmdFileMainProc; 			 --   pTestItem.subMenu ¬ NIL;	 			 --   pTestItem.itemExplanation ¬ mkMenu [cmdFileOptionsExpl]; -- Online help  topLevelMenuSelections.nodeItems [7] ¬ pTestItem;	 -- Store TestItem pointer.  -- Subtest selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ mkMenu [subtestOptions]; 	 -- Test name     pTestItem.test ¬ SubtestOptMainProc; 			 -- Actual test procedure  pTestItem.subMenu ¬ NIL;				 --   pTestItem.itemExplanation ¬ mkMenu [subtestOptionsExpl]; -- Online help  topLevelMenuSelections.nodeItems [8] ¬ pTestItem;	 -- Store TestItem pointer.    -- Mfg Check Out selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ mkMenu [manufCheckOut]; 		 -- Test name     pTestItem.test ¬ MfgCheckOutMainProc; 		 -- Actual test procedure  pTestItem.subMenu ¬ NIL;				 -- sub-menu  pTestItem.itemExplanation ¬ mkMenu [manufCheckOutExpl]; -- Online help  topLevelMenuSelections.nodeItems [9] ¬ pTestItem;	 -- Store TestItem pointer.    <<Assign top level selections for the different classes of users.>>    pUserSelections ¬ Odi.GetASelectionArray [3];  pUserSelections.selections[0] ¬ ctUtilityOpt;  pUserSelections.selections[1] ¬ ctConfidenceTest;  pUserSelections.selections[2] ¬ ctSurfaceVerify;  -- Set accessible test selections for NORMAL USER  topLevelMenuNode.userSelections ¬ pUserSelections;    pAdminSelections ¬ Odi.GetASelectionArray [4];  pAdminSelections.selections[0] ¬ ctUtilityOpt;  pAdminSelections.selections[1] ¬ ctConfidenceTest;  pAdminSelections.selections[2] ¬ ctSurfaceVerify;  pAdminSelections.selections[3] ¬ ctDisplayOptions;  -- Set accessible test selections for SA  topLevelMenuNode.adminSelections ¬ pAdminSelections;    pFieldServiceSelections ¬ Odi.GetASelectionArray [9];  pFieldServiceSelections.selections[0] ¬ ctUtilityOpt;  pFieldServiceSelections.selections[1] ¬ ctConfidenceTest;  pFieldServiceSelections.selections[2] ¬ ctSurfaceVerify;  pFieldServiceSelections.selections[3] ¬ ctExerciser;  pFieldServiceSelections.selections[4] ¬ ctWriteTapeKnownData;  pFieldServiceSelections.selections[5] ¬ ctReadTapeKnownData;  pFieldServiceSelections.selections[6] ¬ ctDisplayOptions;  pFieldServiceSelections.selections[7] ¬ ctCommandFileOptions;  pFieldServiceSelections.selections[8] ¬ ctSubtestOptions;  -- Set accessible test selections for SE  topLevelMenuNode.seSelections ¬ pFieldServiceSelections;    pManufacturingSelections ¬ Odi.GetASelectionArray [10];  pManufacturingSelections.selections[0] ¬ ctUtilityOpt;  pManufacturingSelections.selections[1] ¬ ctConfidenceTest;  pManufacturingSelections.selections[2] ¬ ctSurfaceVerify;  pManufacturingSelections.selections[3] ¬ ctExerciser;  pManufacturingSelections.selections[4] ¬ ctWriteTapeKnownData;  pManufacturingSelections.selections[5] ¬ ctReadTapeKnownData;  pManufacturingSelections.selections[6] ¬ ctDisplayOptions;  pManufacturingSelections.selections[7] ¬ ctCommandFileOptions;  pManufacturingSelections.selections[8] ¬ ctSubtestOptions;  pManufacturingSelections.selections[9] ¬ ctMfgCheckOut;  -- Set accessible test selections for Mfg & ENGINEERING  topLevelMenuNode.manufacturingSelections ¬ pManufacturingSelections;  topLevelMenuNode.programmerSelections ¬ pManufacturingSelections;    SetupMenuHelp [];  topLevelMenuNode.menuTitle ¬ mkOpInt [flTapeDiag];  topLevelMenuNode.menuHelp ¬ menuHelp;  topLevelMenuNode.testItemsForThisNode ¬ topLevelMenuSelections;    END;  -- InitializePackage--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- PUBLIC PROCEDURE exported to the Control Module.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~RunCartridgeTapeTests: PUBLIC Odi.ClientPackage =  BEGIN      --~~~~~~~~~~~~~~~~~    -- Main line code.    --~~~~~~~~~~~~~~~~~        -- Fire up Systems    START DiagFlTapeTTY.DiagFlTapeTTYImpl [! Runtime.StartFault => CONTINUE];    START DiagFlTapeMkIOCmd.DiagFlTapeMkIOCmdImpl [! Runtime.StartFault => CONTINUE];    START DiagFlTapeMkMenu.DiagFlTapeMkMenuImpl [! Runtime.StartFault => CONTINUE];    START DiagFlTapeMkOpInt.DiagFlTapeMkOpIntImpl [! Runtime.StartFault => CONTINUE];    START DiagFlTapeMkDispl.DiagFlTapeMkDisplImpl [! Runtime.StartFault => CONTINUE];    START DiagFlTapeMkSubtest.DiagFlTapeMkSubtestImpl [! Runtime.StartFault => CONTINUE];    --START DiagMkTime.DiagMkTimeImpl [! Runtime.StartFault => CONTINUE];    START DiagFlTapeCmdDes.DiagFlTapeCmdDesImpl [! Runtime.StartFault => CONTINUE];    START DiagFlTapeErrorCheck.DiagFlTapeErrorCheckImpl [! Runtime.StartFault => CONTINUE];    START DiagFlTapeTestControl.DiagFlTapeTestControlImpl [! Runtime.StartFault => CONTINUE];    START DiagFlTapeTestCmdArrays.DiagFlTapeTestCmdArraysImpl [! Runtime.StartFault => CONTINUE];    START DiagFlTapeTestRec.DiagFlTapeTestRecImpl [! Runtime.StartFault => CONTINUE];    START DiagFlTapeCmds.DiagFlTapeCmdsImpl [! Runtime.StartFault => CONTINUE];    START DiagFlTapeCmdDrive.DiagFlTapeCmdDriveImpl [! Runtime.StartFault => CONTINUE];    START DiagFlTapeLog.DiagFlTapeLogImpl [! Runtime.StartFault => CONTINUE];    DiagFlTapeOpInt.GetUser [];    -- prompt for developer switches    IF (Odi.userType = Programmer) AND        (System.switches['s]=down OR System.switches['S]=down) THEN {        questtext: ARRAY [0..5) OF LONG STRING;	-- from DiagFlTapeInfo.doc	questtext[0]¬ "Switch: 71= Display the Command file/file array before execution"L;   	questtext[1]¬ "Switch: 81= Do not clear the error log stuff when in subtest options"L;    	questtext[2]¬ "Switch: 91= Display the contents of the IOCB"L;	questtext[3]¬ "Switch: 101= Display the time in seconds required to run 1 pass"L;    	questtext[4]¬ "Switch: 110= bypass this subtest"L;    	DiagFlTapeTTY.SelectOptions [		  prompt: mkOpInt[switches],		  numberArray: DESCRIPTOR [DiagFlTapeOpInt.Switch],		  explanation: DESCRIPTOR [questtext]] };        << Check for successful cartridge tape initialization performed in DiagFlTapeCmdsImpl >>    IF DiagFlTapeCmds.DeviceHandle = FloppyDiskFace.nullDeviceHandle      THEN        { Odi.PutMessage[message: mkOpInt[badDriveType], numOfBlankLines: 3];	  CreateAlternateUniverse [];  --Build a no-choice menu	  Odi.HitAnyKeyToContinue[mkOpInt[typeCharToCont], TRUE];        }      ELSE InitializePackage [];       -- Build up the menu tree and procedural data base        START DiagDiskMkTime.DiagDiskMkTimeImpl [! Runtime.StartFault => CONTINUE];    DiagDiskTime.SetRealTimeClock [displayMsg: TRUE        ! DiagDiskTime.RealTimeClockFailure => {	     Odi.PutData[data: DiagDiskMkTime.mkTime[rTCFailure],	                 clearHeadingAndData: TRUE] }];        << Floppy/floppytape competes with ethernet for bus access and     ethernet is of higher priority.  FloppyTape operations is severely affected     by this.  Since we really don't need ethernet after we get the time, turn it off.>>    IF NOT etherOff THEN {        TurnEthernetOff[];	etherOff ¬ TRUE;	--Odi.PutMessage [message: "Ethernet OFF"L]	};	    <<      -- turn ethernet back on before exiting test    BEGIN    ENABLE Odi.AbortCurrentTest =>       { IF etherOff THEN {                  TurnEthernetOn[];		 etherOff ¬ FALSE;		 --Odi.PutMessage [message: "Ethernet ON"L]-- };	 REJECT };    END;  --Enable    >>        RETURN [topLevelMenuNode];  -- Pass pointer to root node to Control Module    END;  -- Main line code  END...  OfflineCartridgeTapeDiagDove.mesa    LOG22-Oct-87 13:15:29 JMA	- Creation  3-Jun-88  9:23:29 JMA  - turned off ethernet before any floppy tape operations
-- DiagFlTapeTestsChecksumImpl.mesa-- Last edited:-- JMA 10-Mar-88 12:08:27DIRECTORY  Checksum,  Format,  QuickSort,  String,  Space,  Environment,  FloppyChannel,  FloppyDiskFace,  FloppyTape,  FloppyTapeFormat,  FloppyTapeExtras,  SpecialFloppyChannel,  SpecialFloppyChannelExtras,  Inline,  VM,  VerifyRead,  Zone,  ResidentHeap,  DiagFlTapeCmds,  DiagFlTapeTTY,  DiagFlTapeOpInt,  DiagFlTapeTestControl,  DiagFlTapeRunCmdFile,  DiagFlTapeMkMenu,  DiagFlTapeTests;DiagFlTapeTestsChecksumImpl: PROGRAM  IMPORTS    Checksum, Environment, QuickSort, String, Space, FloppyChannel, FloppyDiskFace, FloppyTapeExtras, SpecialFloppyChannel, SpecialFloppyChannelExtras, Inline, VM, ResidentHeap, DiagFlTapeTTY, DiagFlTapeOpInt, DiagFlTapeTestControl, DiagFlTapeRunCmdFile, DiagFlTapeMkMenu, DiagFlTapeTests, DiagFlTapeCmds   EXPORTS     DiagFlTapeTests =      BEGIN<<	#########################################################	Types	######################################################### >>Status: TYPE = {Normal, NoDevice, CantGetHandle, BadRootPage, UnmarkedBadPage, Null};<<	#########################################################	Constants	######################################################### >>		bufferSize: Space.PageCount = 320;nullChecksum: CARDINAL = 0;	<<	#########################################################	Variables	######################################################### >>	rootPage: FloppyTapeFormat.RootPage;gsp: Environment.Base RELATIVE POINTER;VRError: PUBLIC ERROR[error: VerifyRead.VRErrorType] = CODE;<<	#########################################################	Signals	######################################################### >>	<<	#########################################################	Procedures	######################################################### >>Write: PROC[s: LONG STRING] =   BEGIN   DiagFlTapeTTY.PutLine[s];   END;WriteNumber: PUBLIC PROC[n: CARDINAL] =     BEGIN     s: LONG STRING ¬ [20];     String.AppendNumber[s, n, 10];     Write[s];     END;WriteLongNumber: PUBLIC PROC[n: LONG CARDINAL] =     BEGIN     s: LONG STRING ¬ [20];     String.AppendLongNumber[s, n, 10];     Write[s];     END;	PrintResult: PROC[checksum: CARDINAL] =   BEGIN   IF checksum = nullChecksum THEN RETURN;   Write["\n"L];   DiagFlTapeTTY.PutString[DiagFlTapeMkMenu.mkMenu[checksumEquals]];   WriteNumber[checksum];   Write["\n"L];   END;PrintError: PROC[error: FloppyDiskFace.Status] =   BEGIN      SELECT error FROM      notReady =>      { Write[DiagFlTapeMkMenu.mkMenu[csNotReadyError]];        DiagFlTapeOpInt.CallService[fruCode: 2822];      };      ENDCASE =>      { Write[DiagFlTapeMkMenu.mkMenu[checksumReadError]];        DiagFlTapeOpInt.CallService[fruCode: 2824];      };   END;ChannelStatusToFaceStatus: PROC[status: FloppyChannel.Status]   RETURNS[FloppyDiskFace.Status] =   BEGIN      SELECT status FROM      goodCompletion => RETURN[goodCompletion];      diskChange => RETURN[diskChange];      notReady => RETURN[notReady];      cylinderError => RETURN[cylinderError];      deletedData => RETURN[deletedData];      recordNotFound => RETURN[recordNotFound];      headerError => RETURN[headerError];      dataError => RETURN[dataError];      dataLost => RETURN[dataLost];      writeFault => RETURN[writeFault];      otherError => RETURN[otherError];      ENDCASE => RETURN[otherError];         END; ChecksumTape:  PUBLIC PROCEDURE = BEGIN   status: FloppyDiskFace.Status;   drive: FloppyTape.Drive;   handle: FloppyChannel.Handle;   checksum: CARDINAL;  DiagFlTapeRunCmdFile.RunningUserCmdFile ¬ FALSE; DiagFlTapeTestControl.DisplaySummaryOnHardErr ¬ FALSE; --display the title DiagFlTapeOpInt.GetTestRequirements[ 	testTitle: DiagFlTapeMkMenu.mkMenu[getChecksumTtl]];	 --check for ready DiagFlTapeTests.CheckForReady[];            << -------------------------------------	       Get Floppy Tape Handle	       ------------------------------------- >>         drive ¬ FloppyTapeExtras.GetNextFloppyTapeDrive[FloppyTapeExtras.nullDrive];      IF drive = FloppyChannel.nullDrive THEN      BEGIN      Write[DiagFlTapeMkMenu.mkMenu[csNoDeviceError]];      DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];      RETURN[];      END;         handle ¬ FloppyChannel.GetHandle[drive];            << -------------------------------------	       Calculate Checksum	       ------------------------------------- >>      [checksum, status] ¬ ComputeFloppyTapeCheckSum[handle];               << -------------------------------------	       Print Result	       ------------------------------------- >>   DiagFlTapeCmds.LastReadStatus ¬ status;   SELECT status FROM      goodCompletion => PrintResult[checksum];      ENDCASE => PrintError[status];      DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];   END; -- of ChecksumTape      SortBadPageTable: PROC[badPageTable: LONG POINTER TO   FloppyTapeFormat.BadSectorListArray,   numberOfBadPages: CARDINAL] =   BEGIN   dummy: QuickSort.ClientData ¬ NIL;      Swap: PROC [one, two: INTEGER, data: QuickSort.ClientData] = {         temp: FloppyTapeFormat.BadSectorEntry ¬ badPageTable[one];         badPageTable[one] ¬ badPageTable[two];         badPageTable[two] ¬ temp;         };	    Compare: PROC [one, two: INTEGER, data: QuickSort.ClientData]         RETURNS [QuickSort.Comparison] = 	 BEGIN	 IF PackBadSectorNumber[badPageTable[one].badSectorLow,	    badPageTable[one].badSectorHigh] <	    PackBadSectorNumber[badPageTable[two].badSectorLow,	    badPageTable[two].badSectorHigh] THEN	    RETURN[smaller]	 ELSE IF PackBadSectorNumber[badPageTable[one].badSectorLow,	    badPageTable[one].badSectorHigh] >	    PackBadSectorNumber[badPageTable[two].badSectorLow,	    badPageTable[two].badSectorHigh] THEN	    RETURN[bigger]	 ELSE	    RETURN[same];	 END;      QuickSort.Sort[0, numberOfBadPages - 1, Compare, Swap, dummy];   END;      SectorToDiskAddress: PROCEDURE [  -- IS THIS STILL CORRECT? --     sector: FloppyTape.SectorNumber, tracksPerStream: CARDINAL,    sectorsPerTrack: CARDINAL]    RETURNS [diskAddress: FloppyChannel.DiskAddress] = << INLINE >>    BEGIN    temp: CARDINAL;    [quotient: temp, remainder: diskAddress.sector] ¬ Inline.LongDivMod[       sector-1, sectorsPerTrack];    diskAddress.sector ¬ diskAddress.sector + 1; -- sectors begin at 1 --    [quotient: diskAddress.cylinder, remainder: diskAddress.head] ¬       Inline.DIVMOD[temp, tracksPerStream];    END;    DiskAddressToSector: PROCEDURE [      diskAddress: FloppyChannel.DiskAddress, streams: CARDINAL,    tracksPerStream: CARDINAL, sectorsPerTrack: CARDINAL]    RETURNS [sector: FloppyTape.SectorNumber] = INLINE {    sector ¬       diskAddress.sector +      Inline.LongMult[        sectorsPerTrack,	(diskAddress.head + tracksPerStream * diskAddress.cylinder)]};	     PackBadSectorNumber: PROCEDURE [low: FloppyTapeFormat.FilePageLow, high: FloppyTapeFormat.FilePageHigh]    RETURNS [page: FloppyTape.SectorNumber] = INLINE {    RETURN[      LOOPHOLE[Environment.LongNumber[num[lowbits: low, highbits: high]]]]};        UnpackBadSectorNumber: PROCEDURE [sector: FloppyTape.SectorNumber]    RETURNS [low: FloppyTapeFormat.FilePageLow, high: FloppyTapeFormat.FilePageHigh] = INLINE {    RETURN[low: Inline.LowHalf[sector], high: Inline.HighHalf[sector]]};LongChecksum: PROC[cs: CARDINAL ¬ 0, nWords: LONG CARDINAL, p: LONG POINTER]   RETURNS[checksum: CARDINAL] =   BEGIN      checksum ¬ cs;      WHILE nWords > LAST[CARDINAL]      DO      checksum ¬ Checksum.ComputeChecksum[checksum, LAST[CARDINAL], p];      p ¬ p + LAST[CARDINAL];      nWords ¬ nWords -  LAST[CARDINAL];      ENDLOOP;      IF nWords > 0 THEN      checksum ¬ Checksum.ComputeChecksum[checksum, CARDINAL[nWords], p];      END;ComputeFloppyTapeCheckSum: PROC[handle: FloppyChannel.Handle] RETURNS[   checksum: CARDINAL ¬ 0, status: FloppyDiskFace.Status ¬ goodCompletion] =   BEGIN      -- Constants      rootPageSize: CARDINAL = 1;	-- pages   badPageTableDiskAddress: FloppyChannel.DiskAddress = [0,0,2];   badPageTableSize: CARDINAL = 2;	-- pages   pageSize: CARDINAL = 256;	-- Words per sector   diagnosticAreaSize: CARDINAL = 245 * 32 * 2;	-- pages            -- Variables      buffer: Space.Interval;--   rootPage: FloppyTapeFormat.RootPage;   badPageTable: FloppyTapeFormat.BadSectorListArray;   endOfTape: FloppyTape.SectorNumber;   blockReadStartPage, blockReadEndPage: FloppyTape.SectorNumber;--   endOfDiagnostics: FloppyTape.SectorNumber;   currentBadPageEntry: CARDINAL;   iocb: FloppyDiskFace.OperationPtr;   <<     =========================================================================     Procedures     =========================================================================>>   <<     =========================================================================     This procedure skips over an arbitrary number of contiguous bad pages.     In order for it to work correctly the bad page table must be sorted and     if "pageNumber" points to a bad page then "badPageIndex" must point to     its entry in the bad page table. If the passed in page number is not a     bad page then it will be returned unchanged.     =========================================================================>>   SkipBadPages: PROC[pageNumber: FloppyTape.SectorNumber, badPageIndex: CARDINAL]      RETURNS[newPageNumber: FloppyTape.SectorNumber, newBadPageIndex: CARDINAL] =      BEGIN            newPageNumber ¬ pageNumber;      newBadPageIndex ¬ badPageIndex;            WHILE newBadPageIndex < rootPage.numberOfBadPages AND         newPageNumber = PackBadSectorNumber[	 badPageTable[newBadPageIndex].badSectorLow,	 badPageTable[newBadPageIndex].badSectorHigh]	 DO	 newPageNumber ¬ newPageNumber + 1;	 newBadPageIndex ¬ newBadPageIndex + 1;	 ENDLOOP;	       END;      <<     =========================================================================     This procedure converts a bad page table index into the page number     which it points to.     =========================================================================>>   BadPage: PROC[badPageIndex: CARDINAL]      RETURNS[newPageNumber: FloppyTape.SectorNumber]=      BEGIN            newPageNumber ¬ PackBadSectorNumber[	 badPageTable[badPageIndex].badSectorLow,	 badPageTable[badPageIndex].badSectorHigh];            END;<<     =========================================================================     This procedure duplicates the FloppyChannel.ReadSectors command using     SpecialFloppyChannel.DoDirectIO for increased performance.     =========================================================================>>   ReadSectors: PROCEDURE [handle: FloppyChannel.Handle,      address: FloppyChannel.DiskAddress,       buffer: LONG POINTER, count: CARDINAL ¬ 1,      iocb: FloppyDiskFace.OperationPtr]      RETURNS [status: FloppyDiskFace.Status] =          BEGIN            << -------------------------------------	       Set Up IOCB	       ------------------------------------- >>            iocb.device ¬ SpecialFloppyChannelExtras.GetDeviceHandle[handle];      iocb.function ¬ readSector;             iocb.address ¬ LOOPHOLE[address, FloppyDiskFace.DiskAddress];      iocb.dataPtr ¬ buffer;      iocb.incrementDataPointer ¬ TRUE;      iocb.tries ¬ FloppyDiskFace.SuggestedTries[         SpecialFloppyChannelExtras.GetDeviceHandle[handle]];      iocb.count ¬ count;                  << -------------------------------------	       Do Read Operation	       ------------------------------------- >>                  [status,,] ¬ SpecialFloppyChannel.DoDirectIO[iocb];            END;      <<     =========================================================================     These procedures allocate storage which is in real memory.     =========================================================================>>  AllocIOCB: PROCEDURE [wds: CARDINAL] RETURNS [p: LONG POINTER] =    BEGIN     status: Zone.Status;    IF wds = 0 THEN RETURN[NIL];    [gsp, status] ¬ ResidentHeap.MakeNode[      n: wds, alignment: FloppyDiskFace.operationAlignment];    IF status # okay THEN VRError[allocBug];    RETURN[@Environment.first64K[gsp]];    END;  --AllocIOCB    CreateResidentBuffer: PROCEDURE [size: Space.PageCount]    RETURNS [buffer: Space.Interval]  =    BEGIN    buffer ¬ Space.Allocate[size ! 	  Space.InsufficientSpace => GO TO return;  	  Space.Error => GO TO return]; 		     VM.ScratchMap[	[Environment.PageFromLongPointer[buffer.pointer], buffer.count]];      EXITS      return => RETURN[Space.nullInterval];    END;  --CreateResidentBuffer<<     =========================================================================     These procedures deallocate storage.     =========================================================================>>    DeAllocIOCB: PROCEDURE [p: LONG POINTER] =     BEGIN    status: Zone.Status ¬ ResidentHeap.FreeNode[gsp];    IF status # okay THEN VRError[deAllocBug];  --call debug?    END;  --DeAllocIOCB      DestroyResidentBuffer: PROCEDURE [buffer: Space.Interval] =     BEGIN    VM.Unmap[Environment.PageFromLongPointer[buffer.pointer]];    Space.Deallocate[buffer !	    Space.Error => CONTINUE];	     END;  --DestroyResidentBuffer<<     =========================================================================     Start Of Code     =========================================================================>>               << -------------------------------------	       Set Context	       ------------------------------------- >>	          FloppyDiskFace.DiskChangeClear[   SpecialFloppyChannelExtras.GetDeviceHandle[handle]];   IF NOT FloppyChannel.SetContext[handle,      FloppyTapeFormat.floppyTapeContext] THEN      BEGIN      RETURN[nullChecksum, otherError];      END;             << -------------------------------------	       Allocate Space For Tape Data And IOCB	       ------------------------------------- >>   --iocb ¬ AllocIOCB[FloppyDiskFace.operationBlockLength];   --buffer ¬ CreateResidentBuffer[bufferSize];   -- Use the allocated diagnostics space instead   iocb ¬ DiagFlTapeCmds.IoCPA[0].opPtr;   buffer.pointer ¬ DiagFlTapeCmds.WrBuffArray[0];   buffer.count ¬ bufferSize;	                                << -------------------------------------	       Read Root Page	       ------------------------------------- >>	          [status] ¬ ChannelStatusToFaceStatus[       FloppyChannel.ReadSectors[handle,       FloppyTapeFormat.rootPageDiskAddress, @rootPage, rootPageSize].status];      IF status # goodCompletion THEN      BEGIN      --DeAllocIOCB[iocb];      --DestroyResidentBuffer[buffer];      RETURN[nullChecksum, status];      END;      -- check for valid root page    IF rootPage.numberOfBadPages > FloppyTapeFormat.maxNumberBadSectors THEN      BEGIN      --DeAllocIOCB[iocb];      --DestroyResidentBuffer[buffer];      DiagFlTapeTTY.PutLine[DiagFlTapeMkMenu.mkMenu[canNotRdBadPgTbl]];      DiagFlTapeOpInt.CallService[fruCode: 2827];      RETURN[nullChecksum, status];      END;                  << -------------------------------------	       Read Bad Page Table	       ------------------------------------- >>         [status] ¬ ChannelStatusToFaceStatus[      FloppyChannel.ReadSectors[handle,      badPageTableDiskAddress, @badPageTable, badPageTableSize].status];         IF status # goodCompletion THEN      BEGIN      --DeAllocIOCB[iocb];      --DestroyResidentBuffer[buffer];      RETURN[nullChecksum, status]      END;            << -------------------------------------	       Sort Bad Page Table	       ------------------------------------- >>	          SortBadPageTable[@badPageTable, rootPage.numberOfBadPages];                  << -------------------------------------	       Calculate Last Used Sector On Tape	       ------------------------------------- >>	          endOfTape ¬ rootPage.currentEOT - 1;      FOR badSectorLoopIndex: CARDINAL IN [0..rootPage.numberOfBadPages)      DO      IF badPageTable[badSectorLoopIndex].typeOfBadPage = beforeFileWritten THEN         endOfTape ¬ endOfTape + 1;      ENDLOOP;               << -------------------------------------	       Initialize Loop Variables	       ------------------------------------- >>      blockReadStartPage ¬ blockReadEndPage ¬ 1;   currentBadPageEntry ¬ 0;   checksum ¬ 0;      [blockReadStartPage, currentBadPageEntry] ¬ SkipBadPages[blockReadStartPage,    currentBadPageEntry];               << -------------------------------------	       Calculate Checksum	       ------------------------------------- >>	          WHILE blockReadStartPage <= endOfTape      DO            blockReadEndPage ¬ blockReadStartPage + bufferSize - 1;            IF currentBadPageEntry < rootPage.numberOfBadPages AND	 BadPage[currentBadPageEntry] <= blockReadEndPage THEN	 BEGIN	 blockReadEndPage ¬ BadPage[currentBadPageEntry] - 1;	 END;            IF blockReadEndPage > endOfTape THEN         BEGIN	 blockReadEndPage ¬ endOfTape;	 END;	       [status] ¬ ReadSectors[handle,         SectorToDiskAddress[blockReadStartPage, rootPage.numberOfTracks,	 rootPage.sectorsPerTrack],         buffer.pointer, CARDINAL[blockReadEndPage - blockReadStartPage + 1], iocb];            IF status # goodCompletion THEN         BEGIN	 --DeAllocIOCB[iocb];         --DestroyResidentBuffer[buffer];	 RETURN[nullChecksum, status];	 END;	       checksum ¬ LongChecksum[checksum, 	 (blockReadEndPage - blockReadStartPage + 1) * pageSize, buffer.pointer];            [blockReadStartPage, currentBadPageEntry] ¬ SkipBadPages[         blockReadEndPage + 1, currentBadPageEntry];            ENDLOOP;          --DeAllocIOCB[iocb];   --DestroyResidentBuffer[buffer];         END;   END...DiagFlTapeTestsChecksumImplLOG19-Feb-88 11:53:53 JMA: added check for valid root page. 9-Mar-88 10:04:29 JMA: replaced readError msgs with err codes.
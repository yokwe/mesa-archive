-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. -- -- File: DiagFlTapeGetCmdFileImpl.mesa -- Edited by: JMA 18-Feb-88 16:02:10--   DIRECTORY DiagFlTapeCmdDes	USING	[CmdDescriptArray, Command], DiagFlTapeCmds		USING	[MinStream, MaxStream,				 MinTrack, MaxTrack, MaxTracksPerFormat,				 MinTrackCount,-- MaxTrackCount,--				 MinSector, MaxSector,				 MinSectorCount, MaxSectorCount], DiagFlTapeGetCmdFile	USING	[], DiagFlTapeMkIOCmd	USING	[mkIOCmd], DiagFlTapeTestSelect	USING 	[currentOptDispl], DiagFlTapeTTY		USING	[CharsPerLine, GetYesNo,				 EraseText, PutCR, PutMessage], Inline			USING	[LowHalf, HighHalf], OfflineDiagInterface   USING   [DiagHeap, HelpText, GetAHelpText,			         PutData, GetANumber,			         OptionsRecord, AnOptionLine, GetAnOptionsRecord,			         GetAnOptionLine, OptionItem, GetAnOption],  String		USING    [AppendChar, AppendDecimal, AppendString,  				  MakeString];				 				   DiagFlTapeGetCmdFileImpl: PROGRAM     IMPORTS	DiagFlTapeCmdDes,	DiagFlTapeCmds,	DiagFlTapeMkIOCmd,	DiagFlTapeTTY,	DiagFlTapeTestSelect,	Inline,	OfflineDiagInterface,	String    EXPORTS	DiagFlTapeGetCmdFile  = BEGIN     OPEN	DiagFlTapeMkIOCmd,	Cd: DiagFlTapeCmdDes,	Odi: OfflineDiagInterface;				  -- holds the final command string CommandArrayPtr:	PUBLIC CARDINAL; CommandArray:		PUBLIC ARRAY [0..255] OF CARDINAL¬ ALL[0]; tempStr:		LONG STRING¬ [256];				  StartedLogging:	BOOLEAN; StartedTracing:	BOOLEAN; InLoop:		BOOLEAN;   endOfCommandFile:	BOOLEAN; GotAParameter:		BOOLEAN; cmdPtr:		CARDINAL;  useSingleBuff:		BOOLEAN¬ TRUE;  -- for the option menu display commandsAreOptionNode: LONG POINTER TO Odi.OptionsRecord ¬ NIL; help: LONG POINTER TO Odi.HelpText ¬ NIL; xStr: LONG STRING ¬ NIL;-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Converts an ARRAY OF LONG STRING to HelpText-- From: DiagFlTapeTTYImpl.mesa-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ConvertToHelpText: PROCEDURE [numLines: CARDINAL,  		numberExplanations: BOOLEAN¬ FALSE,  		textStr: LONG DESCRIPTOR FOR ARRAY OF LONG STRING]  RETURNS [help: LONG POINTER TO Odi.HelpText ¬ NIL] =  BEGIN  str:	LONG STRING ¬ NIL;    IF BASE [textStr]= NIL OR numLines= 0 THEN RETURN;  help ¬ Odi.GetAHelpText [numLines];    IF numberExplanations THEN    { -- add the number and spacing    FOR inx:CARDINAL IN [0..numLines) DO      -- create string then append the number and spacing      str ¬ String.MakeString [Odi.DiagHeap, DiagFlTapeTTY.CharsPerLine];      str.length ¬ 0;      String.AppendDecimal [str, inx+1];      String.AppendString [str, " - "L];      String.AppendString [str, textStr[inx]];      help.textBody[inx] ¬ str;    ENDLOOP }      ELSE {  -- no number, just text    FOR inx:CARDINAL IN [0..numLines) DO      help.textBody[inx] ¬ textStr[inx];    ENDLOOP };    END;  -- ConvertToHelpText   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to get the Command File -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetCommandFile: PUBLIC PROCEDURE = BEGIN cmdcnt:		DiagFlTapeCmdDes.Command¬ VAL[1]; --bypass NoOp --explanation for the commands when a question-mark is entered questtext:		ARRAY [0..28] OF LONG STRING¬ ALL[NIL];	 CommandArrayPtr	¬ 0; --points to next entry in the array CommandArray		¬ ALL[0]; endOfCommandFile	¬ FALSE; GotAParameter		¬ FALSE; StartedLogging		¬ FALSE; InLoop			¬ FALSE; StartedTracing		¬ FALSE;  --set up explanation array UNTIL cmdcnt= endOFile DO   questtext[VAL[cmdcnt]-1]¬ Cd.CmdDescriptArray[cmdcnt].explanation;   cmdcnt¬ SUCC[cmdcnt]; ENDLOOP; questtext[VAL[cmdcnt]-1]¬ Cd.CmdDescriptArray[cmdcnt].explanation; --display the commands on the screen DisplayCommandOptions[]; help ¬ ConvertToHelpText[numLines: LENGTH[Cd.CmdDescriptArray]-1,   		numberExplanations: TRUE, textStr: DESCRIPTOR[questtext]]; --Odi.PutMessage[numOfBlankLines: 2]; xStr ¬ String.MakeString [Odi.DiagHeap, 80];  --now get a string of commands and parameters UNTIL endOfCommandFile DO   -- get the command number   <<   cmdPtr ¬ DiagFlTapeTTY.GetNumber[	prompt: mkIOCmd[command],        delNum: TRUE,        acceptNumWithin: TRUE,	minNumber: 1,	maxNumber: LENGTH[Cd.CmdDescriptArray]-1,	numberExplanations: TRUE,        explanation: DESCRIPTOR[questtext]].num;   >>   cmdPtr ¬ Odi.GetAnOption [optionTable: NIL,			optionPrompt: mkIOCmd[command],			optionHelp: help];   GotAParameter¬ FALSE;   DecipherCommand [index: VAL[cmdPtr]]; --now get the parameters ENDLOOP; END; --GetCmdFile -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- display all the commands in the Command File -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   DisplayCommandOptions: PROC[]    = BEGIN cmdArrayLength:	CARDINAL¬ LENGTH[Cd.CmdDescriptArray]; cmdStringLength:	CARDINAL; numberOfLines:		CARDINAL; count:			DiagFlTapeCmdDes.Command; cnt:			CARDINAL; lineCount:		CARDINAL; columns:		CARDINAL; optionsPerLine:	CARDINAL; selectionNumber:	CARDINAL;   -- optItem points to a RECORD containing all the components of a AnOptionLine.     optItem:		LONG POINTER TO Odi.AnOptionLine;  charsPerLine:		CARDINAL ¬ DiagFlTapeTTY.CharsPerLine;  startHere: 		CARDINAL;  leftEdge:		CARDINAL = 3;    --first get the longest command name  cmdStringLength¬ Cd.CmdDescriptArray[endOFile].commandName.length;  count¬ VAL[1]; --to bypass the NoOp command  UNTIL count= endOFile DO    IF Cd.CmdDescriptArray[count].commandName.length > cmdStringLength THEN      cmdStringLength¬ Cd.CmdDescriptArray[count].commandName.length;    count¬ SUCC[count];  ENDLOOP;  cmdStringLength¬ cmdStringLength + 6; -- add the selection number   --calculate the number of columns  columns¬ charsPerLine/cmdStringLength;   cmdStringLength¬ charsPerLine/columns;  --now calculate the number of lines  numberOfLines¬ (cmdArrayLength- 1)/columns;  IF cmdArrayLength- 1 MOD columns > 0 THEN    numberOfLines¬ numberOfLines + 1;    -- set up option table for 25 command options for building a command file  commandsAreOptionNode ¬ Odi.GetAnOptionsRecord [numberOfLines];  commandsAreOptionNode.optionMenuTiTle ¬ mkIOCmd [cmdsAre];     lineCount¬ 0;  UNTIL lineCount>= numberOfLines DO       --the bottom line may not be a full line.    --So calculate and adjust the number of options in this line    optionsPerLine ¬ 0;    FOR cnt IN [0..columns)    DO       IF (cnt*numberOfLines)+lineCount+1 < cmdArrayLength       THEN optionsPerLine ¬ optionsPerLine+1       ELSE EXIT;    ENDLOOP;        --now set up each option line    optItem ¬ Odi.GetAnOptionLine [optionsPerLine: optionsPerLine];    cnt¬ 0;  startHere ¬ leftEdge;    UNTIL cnt>= optionsPerLine DO       selectionNumber¬ (cnt*numberOfLines)+ (lineCount)+ 1;       IF selectionNumber < cmdArrayLength THEN       { 	 optItem.optionsOnALine[cnt].selectionNumberForThisItem ¬ selectionNumber;	 optItem.optionsOnALine[cnt].option ¬	 	Cd.CmdDescriptArray[VAL[selectionNumber]].commandName;	 optItem.optionsOnALine[cnt].helpForThisOption ¬ 	 	Cd.CmdDescriptArray[VAL[selectionNumber]].explanation;	 optItem.optionsOnALine[cnt].position ¬ startHere;	 startHere ¬ startHere+cmdStringLength;	 commandsAreOptionNode.linesOfOptions [lineCount] ¬ optItem;        };       cnt¬ cnt+ 1;     ENDLOOP;     lineCount¬ lineCount + 1;  ENDLOOP; DiagFlTapeTTY.PutCR[]; -- display option menu [] ¬ Odi.GetAnOption [optionTable: commandsAreOptionNode, justDisplayTable: TRUE]; -- save pointer to current option display 			 DiagFlTapeTestSelect.currentOptDispl ¬ commandsAreOptionNode; END; --DisplayCommandOptions   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- puts the seclected command into the command array  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    DecipherCommand: PROCEDURE [index: DiagFlTapeCmdDes.Command]  = BEGIN    -- ~~~~~internal procs~~~~~  UpdateArrayAndDisplay: PROCEDURE [index: DiagFlTapeCmdDes.Command]  = BEGIN  CommandArray [CommandArrayPtr]¬ ORD[index];  CommandArrayPtr¬ CommandArrayPtr+ 1;  DiagFlTapeTTY.EraseText [stringLength: mkIOCmd[command].length];  Odi.PutData [data: Cd.CmdDescriptArray[index].commandName,  	       startWithNewLine: TRUE];  <<  DiagFlTapeTTY.AddString [	string: Cd.CmdDescriptArray[index].commandName,	checkLineLength: TRUE];  >>  END; --UpdateArrayAndDisplay -- ~~~~~~end of internal procs~~~~~~  -- First check for all the error conditions -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   -- check for error logging command errors IF Cd.CmdDescriptArray[index].setLogging AND StartedLogging THEN   { DiagFlTapeTTY.PutMessage [str: mkIOCmd[allreadyLoggingErrs]];     DiagFlTapeTTY.EraseText[stringLength: mkIOCmd[command].length];     RETURN   }; IF Cd.CmdDescriptArray[index].resetLogging AND NOT StartedLogging THEN   { DiagFlTapeTTY.PutMessage [str: mkIOCmd[notLoggingErrs]];     DiagFlTapeTTY.EraseText[stringLength: mkIOCmd[command].length];     RETURN   }; -- check for tracing command errors IF Cd.CmdDescriptArray[index].setTracing AND StartedTracing THEN   { DiagFlTapeTTY.PutMessage [str: mkIOCmd[allreadyTracingCmds]];     DiagFlTapeTTY.EraseText[stringLength: mkIOCmd[command].length];     RETURN   }; IF Cd.CmdDescriptArray[index].resetTracing AND NOT StartedTracing THEN   { DiagFlTapeTTY.PutMessage [str: mkIOCmd[notTracingCmds]];     DiagFlTapeTTY.EraseText[stringLength: mkIOCmd[command].length];     RETURN   };     -- check for looping errors IF Cd.CmdDescriptArray[index].setLooping AND InLoop THEN   { DiagFlTapeTTY.PutMessage [str: mkIOCmd[allreadyInLoop]];     DiagFlTapeTTY.EraseText[stringLength: mkIOCmd[command].length];     RETURN   }; IF Cd.CmdDescriptArray[index].resetLooping AND NOT InLoop THEN   { DiagFlTapeTTY.PutMessage [str: mkIOCmd[notLooping]];     DiagFlTapeTTY.EraseText[stringLength: mkIOCmd[command].length];     RETURN   };     -- check for end of command file errors IF Cd.CmdDescriptArray[index].setRunCmdFile AND InLoop THEN   { DiagFlTapeTTY.PutMessage [str: mkIOCmd[notAllowedInLoop]];     DiagFlTapeTTY.EraseText[stringLength: mkIOCmd[command].length];     RETURN   }; --now set/reset needed booleans -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ IF Cd.CmdDescriptArray[index].setLogging THEN StartedLogging¬ TRUE; IF Cd.CmdDescriptArray[index].resetLogging THEN StartedLogging¬ FALSE; IF Cd.CmdDescriptArray[index].setTracing THEN StartedTracing¬ TRUE; IF Cd.CmdDescriptArray[index].resetTracing THEN StartedTracing¬ FALSE; IF Cd.CmdDescriptArray[index].setLooping THEN InLoop¬ TRUE; IF Cd.CmdDescriptArray[index].resetLooping THEN InLoop¬ FALSE; IF Cd.CmdDescriptArray[index].setRunCmdFile THEN endOfCommandFile¬ TRUE;  -- now update the command array and the display with the commandUpdateArrayAndDisplay [index: index]; -- now get all the required parameters for the entered command -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   IF Cd.CmdDescriptArray[index].needLoopCount	THEN GetLoopCount[]; IF Cd.CmdDescriptArray[index].needDelay	THEN GetDelay[]; IF Cd.CmdDescriptArray[index].needStream	THEN GetStream[];  IF Cd.CmdDescriptArray[index].needTrack	THEN GetTrack[]; IF Cd.CmdDescriptArray[index].needTkCnt	THEN GetTrackCount[]; IF Cd.CmdDescriptArray[index].needSector	THEN GetSector[]; IF Cd.CmdDescriptArray[index].needUse1Buff	THEN GetUse1Buff[]; IF Cd.CmdDescriptArray[index].needSectorCnt	THEN GetSectorCount[]; IF Cd.CmdDescriptArray[index].needData		THEN GetData[]; IF Cd.CmdDescriptArray[index].need0sInRdBuff	THEN GetIf0sInRdBuff[]; IF Cd.CmdDescriptArray[index].needVrfyData	THEN GetVrfyData[];-- IF Cd.CmdDescriptArray[index].needVrfyHdr	THEN GetVrfyHeader[]; IF Cd.CmdDescriptArray[index].needTryCount	THEN GetTryCount[];  --Now straighten out the display by appending '] to the end of the parameters IF GotAParameter THEN   Odi.PutData [data: mkIOCmd[paramEnd]];   --DiagFlTapeTTY.AddString[string: mkIOCmd[paramEnd], checkLineLength: TRUE]; END; --DecipherCommand  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the loop count.  Is the only parameter which requires a long number -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetLoopCount: PROCEDURE	= BEGIN questtext:	ARRAY [0..1] OF LONG STRING¬ [				mkIOCmd[loopCntExpl1],				mkIOCmd[loopCntExpl2]]; num:		LONG CARDINAL; nStr:		LONG STRING; --get the loop count help ¬ ConvertToHelpText [LENGTH[questtext], FALSE, DESCRIPTOR[questtext]]; [num,,,nStr] ¬ Odi.GetANumber [ 	prompt: mkIOCmd[loopCnt],	help: help,	lowLimit: 0,	upperLimit: 1000000,	numberIsLong: TRUE]; Odi.PutData [data: mkIOCmd[loopCnt], numberAfterData: num];		 -- update command array CommandArray [CommandArrayPtr]¬ Inline.HighHalf[num]; CommandArrayPtr¬ CommandArrayPtr+ 1; CommandArray [CommandArrayPtr]¬ Inline.LowHalf[num]; CommandArrayPtr¬ CommandArrayPtr+ 1; GotAParameter¬ TRUE;  END; --GetLoopCount -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the time delay count  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetDelay: PROCEDURE = BEGIN questtext:	ARRAY [0..1] OF LONG STRING¬ [			mkIOCmd[timeIncrementEquals],			mkIOCmd[enter1To10000]]; GetParameter [	prompt:			mkIOCmd[delayCnt],        acceptNumWithin:	TRUE,	minNumber:		1,	maxNumber:		10000,	explanation:		DESCRIPTOR [questtext]]; END; --GetDelay -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the stream number  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetStream: PROCEDURE = BEGIN questtext:	ARRAY [0..1] OF LONG STRING¬ [			mkIOCmd[streamExpl],			mkIOCmd[supptStream]]; GetParameter [	prompt:			mkIOCmd[stream],        acceptNumWithin:	TRUE,	minNumber:		DiagFlTapeCmds.MinStream,	maxNumber:		DiagFlTapeCmds.MaxStream,	explanation:		DESCRIPTOR [questtext]];	 END; --GetStream -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the track number  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetTrack: PROCEDURE = BEGIN questtext:	ARRAY [0..1] OF LONG STRING¬ [				mkIOCmd[trackExpl],				mkIOCmd[supptTrack]]; plsMinHlpTxt:	ARRAY [0..1] OF LONG STRING¬ [				mkIOCmd[trkPlMn1],				mkIOCmd[trkPlMn2]];  GetParameter [	prompt:			mkIOCmd[track],	acceptNumWithin:	TRUE,	minNumber:		DiagFlTapeCmds.MinTrack,	maxNumber:		DiagFlTapeCmds.MaxTrack,	explanation:		DESCRIPTOR [questtext],	getPlusOrMinus:		TRUE,	plusOrMinusExpl:	DESCRIPTOR[plsMinHlpTxt],	maxModifier:		DiagFlTapeCmds.MaxTrack];   END; --GetTrack -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the track count -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetTrackCount: PROCEDURE = BEGIN questtext:	ARRAY [0..1] OF LONG STRING¬ [ 			mkIOCmd[trackCountExpl], 			mkIOCmd[supptTrackCount]];  GetParameter[	prompt:			mkIOCmd[trackCount],	acceptNumWithin:	TRUE,	minNumber:		DiagFlTapeCmds.MinTrackCount,	maxNumber:		DiagFlTapeCmds.MaxTracksPerFormat,	--maxNumber:		DiagFlTapeCmds.MaxTrackCount,	explanation:		DESCRIPTOR[questtext]];	 END; --GetTrackCount -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets sector number  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetSector: PROCEDURE = BEGIN questtext:	ARRAY [0..1] OF LONG STRING¬ [ 			mkIOCmd[sectorExpl], 			mkIOCmd[supptSector]]; plsMinHlpTxt:	ARRAY [0..1] OF LONG STRING¬ [			mkIOCmd[sectPlMn1],			mkIOCmd[sectPlMn2]]; GetParameter[	prompt:			mkIOCmd[sector],	acceptNumWithin:	TRUE,	minNumber:		DiagFlTapeCmds.MinSector,	maxNumber:		DiagFlTapeCmds.MaxSector,	explanation:		DESCRIPTOR[questtext],	getPlusOrMinus:		TRUE,	plusOrMinusExpl:	DESCRIPTOR[plsMinHlpTxt]];	 END; --GetSector -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets if to verify the ddata in the Rx buffer after transmition  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetUse1Buff: PROCEDURE = BEGIN questtext:	ARRAY [0..0] OF LONG STRING¬ [mkIOCmd[use1BuffExpl]];  CheckForCR[];  xStr.length ¬ 0; useSingleBuff¬ DiagFlTapeTTY.GetYesNo[	prompt:  mkIOCmd[use1Buff],	partOfCharCount: TRUE,	defaultYes: TRUE,	explanation: DESCRIPTOR[questtext]]; String.AppendString [xStr, mkIOCmd[use1Buff]]; IF useSingleBuff THEN {     CommandArray [CommandArrayPtr]¬ 1;      String.AppendString [xStr, " yes"L] } ELSE {     CommandArray [CommandArrayPtr]¬ 0;     String.AppendString [xStr, " no"L] }; Odi.PutData [data: xStr];    -- update command array CommandArrayPtr¬ CommandArrayPtr+ 1; GotAParameter¬ TRUE;  END; --GetUse1Buff -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the sector count -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetSectorCount: PROCEDURE = BEGIN questtext:	ARRAY [0..2] OF LONG STRING¬ [ 			mkIOCmd[sectorCountExpl], 			mkIOCmd[supptSectorCount1], 			mkIOCmd[supptSectorCount2]]; maxSecCnt:	CARDINAL;  IF useSingleBuff THEN maxSecCnt¬ DiagFlTapeCmds.MaxSectorCount ELSE   maxSecCnt¬ 128; GetParameter[	prompt:		mkIOCmd[sectorCount],	acceptNumWithin:TRUE,	minNumber:	DiagFlTapeCmds.MinSectorCount,	maxNumber:	maxSecCnt,	explanation:	DESCRIPTOR[questtext]];	 END; --GetSectorCount -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the hexadecimal data  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetData: PROCEDURE = BEGIN plus:		BOOLEAN; str:		LONG STRING¬ [20]; num:		CARDINAL; questtext1:	ARRAY [0..3] OF LONG STRING¬ [			mkIOCmd[constantExpl],			mkIOCmd[incrementingExpl], 			mkIOCmd[randomExpl],			mkIOCmd[diagnosticExpl]];   CheckForCR[];  str.length¬ 0; xStr.length ¬ 0; << [numInStrForm: str, num: num, positive: plus]¬   DiagFlTapeTTY.GetNumber [	prompt:			mkIOCmd[dataType],	displayExplanation:	TRUE,	acceptNumWithin:	TRUE,	minNumber:		1,	maxNumber:		4,	delNum:			TRUE,	explanation:		DESCRIPTOR[questtext1]]; SELECT num FROM   1=> DiagFlTapeTTY.AddString[mkIOCmd[constant]];   2=> DiagFlTapeTTY.AddString[mkIOCmd[incrementing]];   3=> DiagFlTapeTTY.AddString[mkIOCmd[random]];   4=> DiagFlTapeTTY.AddString[mkIOCmd[diagnostic]]; ENDCASE; >>	 help ¬ ConvertToHelpText[LENGTH [questtext1],FALSE, DESCRIPTOR[questtext1]];	 [,num, plus, str] ¬ Odi.GetANumber [		prompt: mkIOCmd[dataType],		help: help,		lowLimit: 1,		upperLimit: 4]; String.AppendString [xStr, mkIOCmd[dataType]]; SELECT num FROM   1=> String.AppendString[xStr, mkIOCmd[constant]];   2=> String.AppendString[xStr, mkIOCmd[incrementing]];   3=> String.AppendString[xStr, mkIOCmd[random]];   4=> String.AppendString[xStr, mkIOCmd[diagnostic]]; ENDCASE; Odi.PutData [data: xStr]; -- update command array CommandArray [CommandArrayPtr]¬ num; CommandArrayPtr¬ CommandArrayPtr+ 1; GotAParameter¬ TRUE;  IF num= 1 THEN { questtext:	ARRAY [0..1] OF LONG STRING¬ [			mkIOCmd[hexDataExpl],			mkIOCmd[supptHexData]];  GetParameter [	prompt:			mkIOCmd[hexData],	minNumber:		0,	maxNumber:		65535,	dataInHex:		TRUE,	explanation:		DESCRIPTOR[questtext]]; };	 END; --GetData -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets if to clear the Rx buffer before transmitting data  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetIf0sInRdBuff: PROCEDURE = BEGIN questtext:	ARRAY [0..0] OF LONG STRING¬ [mkIOCmd[zeroRdBuffExpl]];  xStr.length ¬ 0; CheckForCR[];  String.AppendString[xStr, mkIOCmd[zeroRdBuff]]; IF DiagFlTapeTTY.GetYesNo[	prompt:  mkIOCmd[zeroRdBuff],	partOfCharCount: TRUE,	defaultYes: TRUE,	explanation: DESCRIPTOR[questtext]] THEN {    CommandArray [CommandArrayPtr]¬ 1;    String.AppendString [xStr, "yes"L] } ELSE { CommandArray [CommandArrayPtr]¬ 0;	String.AppendString [xStr, "no"L]}; Odi.PutData [data: xStr];	 -- update command array CommandArrayPtr¬ CommandArrayPtr+ 1; GotAParameter¬ TRUE; END; --GetIf0sInRdBuff -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the format hexadecimal filler byte  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetFillByte: PROCEDURE = BEGIN questtext:	ARRAY [0..1] OF LONG STRING¬ [			mkIOCmd[fillByteExpl],			mkIOCmd[supptFillByte]];   GetParameter [	prompt:			mkIOCmd[fillByte],	acceptNumWithin:	TRUE,	minNumber:		0,	maxNumber:		255,	dataInHex:		TRUE,	explanation:		DESCRIPTOR[questtext]];	  END; --GetFillByte -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets if to verify the ddata in the Rx buffer after transmition  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetVrfyData: PROCEDURE = BEGIN questtext:	ARRAY [0..0] OF LONG STRING¬ [mkIOCmd[vrfyRdBuffExpl]]; questtext1:	ARRAY [0..5] OF LONG STRING¬ [			mkIOCmd[constantExpl],			mkIOCmd[incrementingExpl], 			mkIOCmd[randomExpl],			mkIOCmd[diagnosticExpl],			mkIOCmd[useWrBuffExpl], --random data			mkIOCmd[unknownExpl]]; --diagnostic data str:		LONG STRING¬ [20]; num:		CARDINAL; plus:		BOOLEAN; yes:		BOOLEAN;  CheckForCR[];  xStr.length ¬ 0; String.AppendString [xStr, mkIOCmd[vrfyRdBuff]]; yes¬ DiagFlTapeTTY.GetYesNo[	prompt:  mkIOCmd[vrfyRdBuff],	partOfCharCount: TRUE,	defaultYes: TRUE,	explanation: DESCRIPTOR[questtext]]; IF yes THEN { 	CommandArray [CommandArrayPtr]¬ 1;	String.AppendString [xStr, "yes"L] } ELSE {         CommandArray [CommandArrayPtr]¬ 0;	String.AppendString [xStr, "no"L] }; Odi.PutData [data: xStr];  -- update command array CommandArrayPtr¬ CommandArrayPtr+ 1; GotAParameter¬ TRUE;  IF yes THEN { -- get the type of data to compare against   CheckForCR[];   str.length¬ 0;   xStr.length ¬ 0;   <<   [numInStrForm: str, num: num, positive: plus]¬     DiagFlTapeTTY.GetNumber [	prompt:			mkIOCmd[dataType],	displayExplanation:	TRUE,	acceptNumWithin:	TRUE,	minNumber:		1,	maxNumber:		6,	delNum:			TRUE,	explanation:		DESCRIPTOR[questtext1]];   SELECT num FROM     1=> DiagFlTapeTTY.AddString[mkIOCmd[constant]];     2=> DiagFlTapeTTY.AddString[mkIOCmd[incrementing]];     3=> DiagFlTapeTTY.AddString[mkIOCmd[random]];     4=> DiagFlTapeTTY.AddString[mkIOCmd[diagnostic]];     5=> DiagFlTapeTTY.AddString[mkIOCmd[useWrBuff]];     6=> DiagFlTapeTTY.AddString[mkIOCmd[unknown]];   ENDCASE;   >>  xStr.length ¬ 0;  help ¬ ConvertToHelpText[LENGTH [questtext1],FALSE, DESCRIPTOR[questtext1]];  [,num, plus, str] ¬ Odi.GetANumber [		prompt: mkIOCmd[dataType],		help: help,		lowLimit: 1,		upperLimit: 6];  String.AppendString [xStr, mkIOCmd[dataType]];  SELECT num FROM     1=> String.AppendString[xStr, mkIOCmd[constant]];     2=> String.AppendString[xStr, mkIOCmd[incrementing]];     3=> String.AppendString[xStr, mkIOCmd[random]];     4=> String.AppendString[xStr, mkIOCmd[diagnostic]];     5=> String.AppendString[xStr, mkIOCmd[useWrBuff]];     6=> String.AppendString[xStr, mkIOCmd[unknown]];   ENDCASE;   Odi.PutData [data: xStr];	   -- update command array   CommandArray [CommandArrayPtr]¬ num;   CommandArrayPtr¬ CommandArrayPtr+ 1;   GotAParameter¬ TRUE; };  END; --GetVrfyData -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets if to verify the header after seek operation  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetVrfyHeader: PROCEDURE = BEGIN questtext:	ARRAY [0..0] OF LONG STRING¬ [mkIOCmd[vrfyHeaderExpl]];  xStr.length ¬ 0; CheckForCR[];  String.AppendString [xStr, mkIOCmd[vrfyHeader]]; IF DiagFlTapeTTY.GetYesNo[	prompt:  mkIOCmd[vrfyHeader],	partOfCharCount: TRUE,	defaultYes: TRUE,	explanation: DESCRIPTOR[questtext]] THEN {    CommandArray [CommandArrayPtr]¬ 1;    String.AppendString [xStr, "yes"L] } ELSE { CommandArray [CommandArrayPtr]¬ 0;	String.AppendString [xStr, "no"L]}; Odi.PutData [data: xStr]; 	 -- update command array CommandArrayPtr¬ CommandArrayPtr+ 1; GotAParameter¬ TRUE;  END; --GetVrfyHeader -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets if to clear the Rx buffer before transmitting data  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetZeroRdBuff: PROCEDURE = BEGIN questtext:	ARRAY [0..0] OF LONG STRING¬ [mkIOCmd[zeroRdBuffExpl]];  xStr.length ¬ 0; CheckForCR[];  String.AppendString [xStr, mkIOCmd[zeroRdBuff]]; IF DiagFlTapeTTY.GetYesNo[	prompt:  mkIOCmd[zeroRdBuff],	partOfCharCount: TRUE,	defaultYes: TRUE,	explanation: DESCRIPTOR[questtext]] THEN {    CommandArray [CommandArrayPtr]¬ 1;    String.AppendString [xStr, "yes"L] } ELSE { CommandArray [CommandArrayPtr]¬ 0;	String.AppendString [xStr, "no"L]}; Odi.PutData [data: xStr]; 	 -- update command array CommandArrayPtr¬ CommandArrayPtr+ 1; GotAParameter¬ TRUE; END; --GetZeroRdBuff -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets number of tries to be done  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetTryCount: PROCEDURE = BEGIN questtext:	ARRAY [0..1] OF LONG STRING¬ [			mkIOCmd[tryCountExpl],			mkIOCmd[supptTryCount]];   GetParameter [	prompt:			mkIOCmd[tryCount],	acceptNumWithin:	TRUE,	minNumber:		1,	maxNumber:		64,	explanation:		DESCRIPTOR[questtext]];	  END; --GetTryCount   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets a parameter  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetParameter: PROCEDURE [   prompt:          LONG STRING¬ NIL,   displayExplanation:BOOLEAN¬ FALSE,   dataInHex:       BOOLEAN¬ FALSE,   acceptNumWithin: BOOLEAN¬ FALSE,   minNumber:       LONG CARDINAL¬ 0,   maxNumber:       LONG CARDINAL¬ LAST[CARDINAL],   acceptOnlyValidNums: BOOLEAN¬ FALSE,   validNums:       LONG DESCRIPTOR FOR ARRAY OF CARDINAL¬ DESCRIPTOR [NIL, 0],   explanation:     LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0],   getPlusOrMinus:  BOOLEAN¬ FALSE,   plusOrMinusExpl: LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0],   minModifier:     CARDINAL¬ 0,   maxModifier:     CARDINAL¬ 255]	 =BEGIN str:		LONG STRING¬ [20]; num:		CARDINAL; plus:		BOOLEAN;  CheckForCR[];  str.length¬ 0; xStr.length ¬ 0; << [numInStrForm: str, num: num, positive: plus]¬   DiagFlTapeTTY.GetNumber [	prompt:			prompt,	displayExplanation:	displayExplanation,	numberInHex:		dataInHex,	acceptNumWithin:	acceptNumWithin,	minNumber:		minNumber,	maxNumber:		maxNumber,	acceptOnlyValidNums:	acceptOnlyValidNums,	validNums:		validNums,	explanation:		explanation];  >>  help ¬ ConvertToHelpText[LENGTH [explanation],FALSE, explanation];	  [,num, plus, str] ¬ Odi.GetANumber [		prompt: prompt,		help: help,		lowLimit: minNumber,		upperLimit: maxNumber,		numberIsHexadecimal: dataInHex]; String.AppendString [xStr, prompt]; String.AppendString [xStr, str]; Odi.PutData[data: xStr];		 -- update command array CommandArray [CommandArrayPtr]¬ num; CommandArrayPtr¬ CommandArrayPtr+ 1;     --get the +or- number IF InLoop AND getPlusOrMinus THEN { str.length¬ 0;   xStr.length ¬ 0;   Odi.PutData [data: mkIOCmd[startPlusOrMinus]];   --DiagFlTapeTTY.AddString [mkIOCmd[startPlusOrMinus]];   <<   [numInStrForm: str, positive: plus, num: num]¬ DiagFlTapeTTY.GetNumber [       prompt:		mkIOCmd[plusOrMinus],       signed:		TRUE,       acceptNumWithin:	TRUE,       minNumber:	minModifier,       maxNumber:	maxModifier,       explanation:	plusOrMinusExpl];    >>         help ¬ ConvertToHelpText[LENGTH [plusOrMinusExpl],FALSE, plusOrMinusExpl];  [,num, plus, str] ¬ Odi.GetANumber [		prompt: mkIOCmd[plusOrMinus],		help: help,		lowLimit: minModifier,		upperLimit: maxModifier];   String.AppendString [xStr, mkIOCmd[plusOrMinus]];   IF plus THEN String.AppendChar [xStr, '+]     ELSE String.AppendChar [xStr, '-];   String.AppendString [xStr, str];   Odi.PutData [data: xStr];      Odi.PutData [data: mkIOCmd[endPlusOrMin]];   --DiagFlTapeTTY.AddString[mkIOCmd[endPlusOrMin]];      -- update command array   IF plus THEN CommandArray [CommandArrayPtr]¬ 1 ELSE     CommandArray [CommandArrayPtr]¬ 0;   CommandArrayPtr¬ CommandArrayPtr+ 1;   CommandArray [CommandArrayPtr]¬ num;   CommandArrayPtr¬ CommandArrayPtr+ 1; }; GotAParameter¬ TRUE; END; --GetParameter -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- check if a carriage return is needed -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CheckForCR: PROCEDURE = BEGIN IF NOT GotAParameter THEN RETURN ELSE   Odi.PutData [data: mkIOCmd[paramSeparator]];   <<   DiagFlTapeTTY.AddString[     string: mkIOCmd[paramSeparator],     checkLineLength: TRUE];   >> END; --of CheckForCR  END...   10-Apr-86 15:50:53	PJT: Started creation 18-Jan-88 14:21:43	JMA: replaced DisplayCommandOptions proc with display with 	Dove style option menu display. 18-Feb-88 16:40:05 JMA: made min & max limits LONG CARDINAL TYPE in GetParameter proc. 
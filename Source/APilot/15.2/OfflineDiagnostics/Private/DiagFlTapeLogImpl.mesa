-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. ---- File: DiagFlTapeLogImpl.mesa-- Edited by: JMA 11-Feb-88 13:10:28-- DIRECTORY DiagFlTapeCmds		USING	[IoCPA, IoCP, RdIDBuffArray], DiagFlTapeCmdDes	USING	[Command, CmdDescriptArray], DiagFlTapeLog		USING	[SummLogRecord], DiagFlTapeMkIOCmd	USING	[mkIOCmd], DiagFlTapeMkDispl	USING	[mkDispl], DiagFlTapeMkMenu	USING	[mkMenu], DiagFlTapeMkOpInt	USING	[mkOpInt], DiagFlTapeDisplay	USING	[CardinalToHexString, DumpMemory], DiagFlTapeErrorCheck	USING	[Disaster, HardError, SoftError,				 BadPageInTable, SoftErrInTable,				 InitErrorCheck], DiagFlTapeOpInt	USING	[ProceedOnInput, PassCount,				 Engineering, Switch], DiagFlTapeRunCmdFile	USING	[RunningUserCmdFile], DiagFlTapeTestRec	USING	[SubTestBeingExecuted], DiagFlTapeTestSelect	USING	[currentOptDispl], DiagFlTapeTestControl	USING	[RepeatingCommand], DiagFlTapeTTY		USING	[AddString, AddDecimal,				 PutCR, PutNumber, PutString,				 PutLongNumber, CharsPerLine, CharPosition,				 --GetYesNo, UserAbort,				 PutChar, PutMenu, PutLine, PutSpaces,				 Initialize], Environment		USING	[PageCount, wordsPerPage, Byte], FloppyDiskFace		USING	[DiskAddress, Operation], --FloppyHeadKiku	USING	[IOCB], Inline			USING	[DBITSHIFT, HighHalf, LongCOPY, LowHalf], OfflineDiagInterface	USING   [GetAnOption], Space			USING	[ScratchMap], Time			USING	[Unpacked, Unpack]; DiagFlTapeLogImpl: PROGRAM    IMPORTS	DiagFlTapeCmds,	DiagFlTapeCmdDes,	DiagFlTapeMkIOCmd,	DiagFlTapeMkDispl,	DiagFlTapeMkMenu,	DiagFlTapeMkOpInt,	DiagFlTapeDisplay,	DiagFlTapeErrorCheck,	DiagFlTapeOpInt,	DiagFlTapeRunCmdFile,	DiagFlTapeTestRec,	DiagFlTapeTestSelect,	DiagFlTapeTestControl,	DiagFlTapeTTY,	Inline,	OfflineDiagInterface,	Space,	Time    EXPORTS	DiagFlTapeLog<<    SHARES	FloppyHeadKiku>>   =BEGIN    OPEN	DiagFlTapeMkIOCmd,	DiagFlTapeMkDispl,	DiagFlTapeMkMenu,	DiagFlTapeMkOpInt,	Io: DiagFlTapeCmds,	Odi: OfflineDiagInterface,	Cd: DiagFlTapeCmdDes;	 --public global variable EnableSummaryLog:		PUBLIC BOOLEAN		¬ FALSE;  LogError:			PUBLIC BOOLEAN		¬ FALSE; ErrLogPtr:			PUBLIC LONG POINTER TO ARRAY OF WORD; ErrLogLength:			PUBLIC CARDINAL		¬ 0; ErrEntrySize:			PUBLIC CARDINAL		¬ 64; ErrEntryOffset:		PUBLIC CARDINAL		¬ 0; ErrEntryCount:			PUBLIC LONG CARDINAL	¬ 0; ErrEntriesWrappedAround:	PUBLIC BOOLEAN		¬ FALSE; ErrCountWrappedAround:		PUBLIC BOOLEAN		¬ FALSE;  LogStep:			PUBLIC BOOLEAN		¬ FALSE; StepLogPtr:			PUBLIC LONG POINTER TO ARRAY OF WORD; StepEntrySize:			PUBLIC CARDINAL		¬ 64;  Trace:				PUBLIC BOOLEAN		¬ FALSE; TracePtr:			PUBLIC LONG POINTER TO ARRAY OF WORD; TraceLength:			PUBLIC CARDINAL		¬ 0; TraceEntrySize:		PUBLIC CARDINAL		¬ 64; TraceEntryOffset:		PUBLIC CARDINAL		¬ 0; TraceEntryCount:		PUBLIC LONG CARDINAL	¬ 0; TraceEntriesWrappedAround:	PUBLIC BOOLEAN		¬ FALSE; TraceCountWrappedAround:	PUBLIC BOOLEAN		¬ FALSE;  --local global variable logDisplaySelection:	TYPE = {errorLog, traceTable, stepCommandLog}; displType:		logDisplaySelection; entriesWordOffset:	CARDINAL; entriesWrappedAround:	BOOLEAN; entryCount:		LONG CARDINAL; entrySize:		CARDINAL; logLength:		CARDINAL; logPtr:		LONG POINTER TO ARRAY OF WORD; errLogPageCnt:		CARDINAL¬  16; tempLogPageCnt:	CARDINAL¬   1; tracePageCnt:		CARDINAL¬  16; ptrToEntry: 		LONG POINTER TO ARRAY OF WORD;  string:		LONG STRING¬ [80];  SummLogArray:		PUBLIC ARRAY DiagFlTapeCmdDes.Command[			  retntn..formatTk] OF DiagFlTapeLog.SummLogRecord;   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- clears the error log including the summary log -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ClearLog: PUBLIC PROCEDURE = BEGIN wordptr: CARDINAL¬ 0;  UNTIL wordptr>= ErrLogLength DO   ErrLogPtr­ [wordptr] ¬ 0;   wordptr ¬ wordptr+ 1; ENDLOOP; ErrEntriesWrappedAround ¬ FALSE;  ErrCountWrappedAround ¬ FALSE;  ErrEntryOffset ¬ 0; ErrEntryCount ¬ 0;  --now clear the summary log FOR c: DiagFlTapeCmdDes.Command IN [noOp..formatTk] DO     SummLogArray[c]¬ []; ENDLOOP; DiagFlTapeErrorCheck.InitErrorCheck[];  END; --ClearLog -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- clears the Trace table -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ClearTrace: PUBLIC PROCEDURE = BEGIN wordptr: CARDINAL ¬ 0;  UNTIL wordptr>= TraceLength DO    TracePtr­ [wordptr] ¬ 0;    wordptr ¬ wordptr+ 1; ENDLOOP; TraceEntriesWrappedAround ¬ FALSE;  TraceCountWrappedAround ¬ FALSE;  TraceEntryOffset ¬ 0; TraceEntryCount ¬ 0;  END; --ClearTrace -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the summary log -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~<< DisplaySummaryLog: PUBLIC PROCEDURE = BEGIN --~~~~~~~~start of internal procedures~~~~~~~~ DisplayEntry: PROCEDURE [   allCmds: BOOLEAN¬ FALSE,   command: DiagFlTapeCmdDes.Command¬ noOp --first command--] = BEGIN done: BOOLEAN¬ FALSE;  UNTIL done DO   DiagFlTapeTTY.PutChar[32C];   DiagFlTapeTTY.PutLine[string: mkDispl[sumLogDisplay]];    DiagFlTapeTTY.PutChar[char: '*, charCount: DiagFlTapeTTY.CharsPerLine-1];   DiagFlTapeTTY.PutCR[];     --display the type of command   DiagFlTapeTTY.AddString[string: mkDispl[command]];   DiagFlTapeTTY.PutLine[     string: DiagFlTapeCmdDes.CmdDescriptArray[command].commandName];   --display the total number the command was executed   DiagFlTapeTTY.PutString[string: mkDispl[timesExecuted]];   DiagFlTapeTTY.PutLongNumber[     number: SummLogArray[command].commandsExecuted,     fillSpaceWith: '.];   DiagFlTapeTTY.PutCR[];    --display the status title   DiagFlTapeTTY.PutLine[string: mkDispl[statusCountS]];    --cmdTimedOut   IF SummLogArray[command].cmdTimedOutCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[cmdTimedOut]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].cmdTimedOutCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];    };    --dataCompareErr   IF SummLogArray[command].dataVerifyErrCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[dataCompareErr]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].dataVerifyErrCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   --inProgress   IF SummLogArray[command].inProgressCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[inProgress]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].inProgressCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };  --goodCompletion   IF SummLogArray[command].goodCompletionCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[goodCompletion]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].goodCompletionCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   --diskChange   IF SummLogArray[command].diskChangeCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[diskChange]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].diskChangeCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   --notReady   IF SummLogArray[command].notReadyCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[notReady]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].notReadyCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   --cylinderError   IF SummLogArray[command].cylinderErrorCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[cylinderError]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].cylinderErrorCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   --deletedData   IF SummLogArray[command].deletedDataCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[deletedData]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].deletedDataCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   --recordNotFound   IF SummLogArray[command].recordNotFoundCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[recordNotFound]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].recordNotFoundCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   --headerError   IF SummLogArray[command].headerErrorCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[headerError]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].headerErrorCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   --dataError   IF SummLogArray[command].dataErrorCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[dataError]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].dataErrorCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];     };   --dataLost   IF SummLogArray[command].dataLostCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[dataLost]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].dataLostCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   --writeFault   IF SummLogArray[command].writeFaultCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[writeFault]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].writeFaultCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   --memoryError   IF SummLogArray[command].memoryErrorCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[memoryError]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].memoryErrorCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   --invalidOperation   IF SummLogArray[command].invalidOperationCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[invalidOperation]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].invalidOperationCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   --aborted   IF SummLogArray[command].abortedCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[aborted]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].abortedCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   --otherError   IF SummLogArray[command].otherErrorCount# 0 THEN   { DiagFlTapeTTY.PutString[string: mkDispl[otherError]];     DiagFlTapeTTY.PutLongNumber[       number: SummLogArray[command].otherErrorCount,       fillSpaceWith: '.];     DiagFlTapeTTY.PutCR[];   };   IF NOT allCmds OR (allCmds AND  command= formatTk) THEN   { DiagFlTapeOpInt.ProceedOnInput[];     done¬ TRUE;   } ELSE     IF DiagFlTapeTTY.GetYesNo[       prompt: mkDispl[moreYN],       defaultYes: TRUE] THEN command¬ SUCC[command]; ENDLOOP; --UNTIL done DO  END; --of DisplayEntry --~~~~~~~~end of internal procedures~~~~~~~~ num: CARDINAL; exit: BOOLEAN¬ TRUE; options: ARRAY [0..6] OF LONG STRING¬ [ 	mkMenu[dsplAllExcCmds],	-- 1	mkMenu[dsplNoOp],	-- 2	mkMenu[dsplRdID],	-- 3	mkMenu[dsplRdSector],	-- 4	mkMenu[dsplWrSector],	-- 5	mkMenu[dsplWrDlSector],-- 6	mkMenu[dsplFrmtTrck]];	-- 7 questtext: ARRAY [0..7] OF LONG STRING¬ [	mkMenu[dsplAllExcCmdsExpl],	mkMenu[dsplNoOpExpl],	mkMenu[dsplRdIDExpl],	mkMenu[dsplRdSectorExpl],	mkMenu[dsplWrSectorExpl],	mkMenu[dsplWrDlSectorExpl],	mkMenu[dsplFrmtTrckExpl],	mkMenu[returnsToPriorMenu]]; --check if empty FOR c: DiagFlTapeCmdDes.Command IN [noOp..formatTk] DO     IF SummLogArray[c].commandsExecuted# 0 THEN exit¬ FALSE; ENDLOOP; IF exit THEN { DiagFlTapeTTY.PutChar[32C];   DiagFlTapeTTY.PutCR[];   DiagFlTapeTTY.PutLine[mkDispl[sumLogIsEmpty]];   DiagFlTapeOpInt.ProceedOnInput[];   RETURN; }; UNTIL exit DO   DiagFlTapeTTY.Initialize [];   DiagFlTapeTTY.PutCR [];   num¬ DiagFlTapeTTY.PutMenu[	title: mkMenu[summLogOptionS],	options: DESCRIPTOR [options],	numberExplanations: TRUE,	optionExplanation: DESCRIPTOR [questtext]];	   SELECT num FROM   1 => DisplayEntry[allCmds: TRUE	   ! DiagFlTapeTTY.UserAbort => CONTINUE];    2 => DisplayEntry[	   ! DiagFlTapeTTY.UserAbort => CONTINUE];    3 => DisplayEntry[command: readID	   ! DiagFlTapeTTY.UserAbort => CONTINUE];    4 => DisplayEntry[command: rdSector	   ! DiagFlTapeTTY.UserAbort => CONTINUE];    5 => DisplayEntry[command: wrSector	   ! DiagFlTapeTTY.UserAbort => CONTINUE];    6 => DisplayEntry[command: wrDlSctr	   ! DiagFlTapeTTY.UserAbort => CONTINUE];    7 => DisplayEntry[command: formatTk	   ! DiagFlTapeTTY.UserAbort => CONTINUE];    8 => exit¬ TRUE;   ENDCASE; ENDLOOP; --until exit END;  --DisplaySummaryLog >> -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the error log data -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayErrorLog: PUBLIC PROCEDURE = BEGIN displType		¬errorLog; entriesWordOffset	¬ErrEntryOffset; entriesWrappedAround	¬ErrEntriesWrappedAround; entryCount		¬ErrEntryCount; entrySize		¬ErrEntrySize; logLength		¬ErrLogLength; logPtr			¬ErrLogPtr; DisplayEntries[emptyMsg: mkDispl[errLogIsEmpty]]; END;  --DisplayErrorLog -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the temporary log  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayTempLog: PUBLIC PROCEDURE = BEGIN displType		¬stepCommandLog; entriesWordOffset	¬StepEntrySize; entriesWrappedAround	¬FALSE; entryCount		¬1; entrySize		¬StepEntrySize; logLength		¬256; logPtr			¬StepLogPtr; DisplayEntries[emptyMsg: mkDispl[tempLogEmpty]]; END; --DisplayTempLog -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the trace table  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayTrace: PUBLIC PROCEDURE = BEGIN displType		¬traceTable; entriesWordOffset	¬TraceEntryOffset; entriesWrappedAround	¬TraceEntriesWrappedAround; entryCount		¬TraceEntryCount; entrySize		¬TraceEntrySize; logLength		¬TraceLength; logPtr			¬TracePtr; DisplayEntries[emptyMsg: mkDispl[traceTableEmpty]]; END;  --DisplayTrace -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the trace log  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayEntries: PROCEDURE [emptyMsg: LONG STRING ¬ NIL] = BEGIN -- ~~~~~~~~start of internal procedures~~~~~~~~~ CheckForCR: PROCEDURE = BEGIN IF NOT gotAParameter THEN RETURN ELSE   DiagFlTapeTTY.AddString[     string: mkIOCmd[paramSeparator],     checkLineLength: TRUE]; END; --of CheckForCR -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayEntry: PROCEDURE = BEGIN  lc:		LONG CARDINAL; cmd:		DiagFlTapeCmdDes.Command; myp:		LONG POINTER TO ARRAY OF WORD ¬ ptrToEntry; ioPtr:		LONG POINTER TO Io.IoCP; opPtr:		LONG POINTER TO FloppyDiskFace.Operation; --iOBCPtr:	LONG POINTER TO FloppyHeadKiku.IOCB; --bIDPtr:	LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte; string:	LONG STRING ¬ [8]; time:		Time.Unpacked;  -- clean up display and just show the current option table IF DiagFlTapeTestSelect.currentOptDispl # NIL THEN    []¬ Odi.GetAnOption [optionTable: DiagFlTapeTestSelect.currentOptDispl,    		     optionPrompt: " "L, justDisplayTable: TRUE]; gotAParameter¬ FALSE;  --set the the pointer to the io control block ioPtr¬ LOOPHOLE[myp+4]; opPtr¬ LOOPHOLE[myp+28]; --iOBCPtr¬ LOOPHOLE[myp+28];  --loc [0..1] get entry count or command display DiagFlTapeTTY.Initialize[]; IF displType= stepCommandLog THEN   DiagFlTapeTTY.PutString[mkDispl[commandDipl]] ELSE { lc¬ myp­[1];   lc¬ Inline.DBITSHIFT[lc, 16];   lc¬ lc+ myp­[0];   DiagFlTapeTTY.PutString[mkDispl[entryNumber]];   DiagFlTapeTTY.PutLongNumber[	number: lc,	size: 8,	fillSpaceWith: '.];      --if not command file stuff then output the remaining pass count   IF myp­[2]# 0 THEN   { DiagFlTapeTTY.PutSpaces[       DiagFlTapeTTY.CharsPerLine/2- DiagFlTapeTTY.CharPosition];     DiagFlTapeTTY.PutString[mkDispl[remainPassCnt]];     DiagFlTapeTTY.PutNumber[	number: myp­[2],	size: 5,	fillSpaceWith: '.];          DiagFlTapeTTY.PutCR[count: 1];       --display the time of the entry     DiagFlTapeTTY.PutString[string: mkDispl[time]];     time¬ Time.Unpack[time: LOOPHOLE[ioPtr­.timeCmdStarted]];     DiagFlTapeTTY.PutNumber[number: time.hour, fillSpaceWith: '0];     DiagFlTapeTTY.AddString[string: mkDispl[colon]];     DiagFlTapeTTY.PutNumber[number: time.minute, fillSpaceWith: '0];     DiagFlTapeTTY.AddString[string: mkDispl[colon]];     DiagFlTapeTTY.PutNumber[number: time.second, fillSpaceWith: '0];     --display the subtest number     DiagFlTapeTTY.PutSpaces[       DiagFlTapeTTY.CharsPerLine/2- DiagFlTapeTTY.CharPosition];     DiagFlTapeTTY.PutString[mkDispl[subtestNumber]];     DiagFlTapeTTY.PutNumber[number: ORD[myp­[3]]];   } ELSE   { --display the time of the entry     DiagFlTapeTTY.PutSpaces[       DiagFlTapeTTY.CharsPerLine/2- DiagFlTapeTTY.CharPosition];     DiagFlTapeTTY.PutString[string: mkDispl[time]];     time¬ Time.Unpack[time: LOOPHOLE[ioPtr­.timeCmdStarted]];     DiagFlTapeTTY.PutNumber[number: time.hour, fillSpaceWith: '0];     DiagFlTapeTTY.PutString[string: mkDispl[colon]];     DiagFlTapeTTY.PutNumber[number: time.minute, fillSpaceWith: '0];     DiagFlTapeTTY.PutString[string: mkDispl[colon]];     DiagFlTapeTTY.PutNumber[number: time.second, fillSpaceWith: '0];   }; }; DiagFlTapeTTY.PutCR[count: 2];  --reconstruct the issued command cmd¬ ioPtr­.command; DiagFlTapeTTY.PutLine[mkIOCmd[command]]; DiagFlTapeTTY.AddString[Cd.CmdDescriptArray[cmd].commandName];  IF Cd.CmdDescriptArray[cmd].needParam THEN { --get track   IF Cd.CmdDescriptArray[cmd].needTrack THEN   { DiagFlTapeTTY.AddString[mkIOCmd[track]];     DiagFlTapeTTY.AddDecimal[number: ioPtr­.track];     gotAParameter¬ TRUE;   };   --get trackcount   IF Cd.CmdDescriptArray[cmd].needTkCnt THEN   { CheckForCR[];     DiagFlTapeTTY.AddString[mkIOCmd[trackCount]];     DiagFlTapeTTY.AddDecimal[number: ioPtr­.sectorOrTrackCount];     gotAParameter¬ TRUE;   };   --get sector   IF Cd.CmdDescriptArray[cmd].needSector THEN   { CheckForCR[];     DiagFlTapeTTY.AddString[mkIOCmd[sector]];     DiagFlTapeTTY.AddDecimal[number: ioPtr­.sector];     gotAParameter¬ TRUE;   };   --get a single buffer   IF Cd.CmdDescriptArray[cmd].needUse1Buff THEN   { CheckForCR[];     DiagFlTapeTTY.AddString[mkIOCmd[use1Buff]];     IF opPtr­.incrementDataPointer THEN       DiagFlTapeTTY.AddString[mkOpInt[no]] ELSE         DiagFlTapeTTY.AddString[mkOpInt[yes]];     gotAParameter¬ TRUE;   };   --get sector count   IF Cd.CmdDescriptArray[cmd].needSectorCnt THEN   { CheckForCR[];     DiagFlTapeTTY.AddString[mkIOCmd[sectorCount]];     DiagFlTapeTTY.AddDecimal[number: ioPtr­.sectorOrTrackCount];     gotAParameter¬ TRUE;   };   --get data   IF Cd.CmdDescriptArray[cmd].needData THEN   { CheckForCR[];     DiagFlTapeTTY.AddString[mkIOCmd[dataType]];     SELECT ioPtr.dataType FROM       constant =>         { DiagFlTapeTTY.AddString[mkIOCmd[constant]];           CheckForCR[];           DiagFlTapeTTY.AddString[mkIOCmd[hexData]];           DiagFlTapeDisplay.CardinalToHexString[             number: ioPtr.data,             string: string];           DiagFlTapeTTY.AddString[string: string];         };       incrementing => DiagFlTapeTTY.AddString[mkIOCmd[incrementing]];       random => DiagFlTapeTTY.AddString[mkIOCmd[random]];       diagnostic => DiagFlTapeTTY.AddString[mkIOCmd[diagnostic]];     ENDCASE;     gotAParameter¬ TRUE;   };   --get if to clear receive buffer   IF Cd.CmdDescriptArray[cmd].need0sInRdBuff THEN   { CheckForCR[];     DiagFlTapeTTY.AddString[mkIOCmd[zeroRdBuff]];     IF ioPtr­.need0sInRdBuff THEN       DiagFlTapeTTY.AddString[mkOpInt[yes]] ELSE         DiagFlTapeTTY.AddString[mkOpInt[no]];     gotAParameter¬ TRUE;   };   --get if to verify data   IF Cd.CmdDescriptArray[cmd].needVrfyData THEN   { CheckForCR[];     DiagFlTapeTTY.AddString[mkIOCmd[vrfyRdBuff]];     IF ioPtr­.needVrfyData THEN     { DiagFlTapeTTY.AddString[mkOpInt[yes]];       CheckForCR[];       DiagFlTapeTTY.AddString[mkIOCmd[dataType]];       SELECT ioPtr.dataType FROM         constant =>	 DiagFlTapeTTY.AddString[mkIOCmd[constant]];         incrementing => DiagFlTapeTTY.AddString[mkIOCmd[incrementing]];         random =>	 DiagFlTapeTTY.AddString[mkIOCmd[random]];         diagnostic =>	 DiagFlTapeTTY.AddString[mkIOCmd[diagnostic]];         useWrBuff =>	 DiagFlTapeTTY.AddString[mkIOCmd[useWrBuff]];         unknown =>	 DiagFlTapeTTY.AddString[mkIOCmd[unknown]];       ENDCASE;     } ELSE DiagFlTapeTTY.AddString[mkOpInt[no]];     gotAParameter¬ TRUE;   };   --get try count   IF Cd.CmdDescriptArray[cmd].needTryCount THEN   { CheckForCR[];     DiagFlTapeTTY.AddString[mkIOCmd[tryCount]];     DiagFlTapeTTY.AddDecimal[number: opPtr­.tries];     gotAParameter¬ TRUE;   };   --add the"];" on the screen   IF gotAParameter THEN     DiagFlTapeTTY.AddString[string: mkIOCmd[paramEnd]];    --now display the returned parameters   IF Cd.CmdDescriptArray[cmd].rtrnsParam THEN   { DiagFlTapeTTY.PutCR[count: 1];     DiagFlTapeTTY.PutLine[mkIOCmd[returnedParams]];     --get returned track     IF Cd.CmdDescriptArray[cmd].needTrack THEN     { DiagFlTapeTTY.AddString[mkIOCmd[track]];       DiagFlTapeTTY.AddDecimal[number: opPtr­.address.cylinder];       gotAParameter¬ TRUE;     };     --get remaining trackcount     IF Cd.CmdDescriptArray[cmd].needTkCnt THEN     { CheckForCR[];       DiagFlTapeTTY.AddString[mkIOCmd[remainTrackCount]];       DiagFlTapeTTY.AddDecimal[number: opPtr­.count];       gotAParameter¬ TRUE;     };     --get returned sector     IF Cd.CmdDescriptArray[cmd].needSector THEN     { CheckForCR[];       DiagFlTapeTTY.AddString[mkIOCmd[sector]];       DiagFlTapeTTY.AddDecimal[number: opPtr­.address.sector];       gotAParameter¬ TRUE;     };     --get remaining sector count     IF Cd.CmdDescriptArray[cmd].needSectorCnt THEN     { CheckForCR[];       DiagFlTapeTTY.AddString[mkIOCmd[remainSectorCount]];       DiagFlTapeTTY.AddDecimal[number: opPtr­.count];       gotAParameter¬ TRUE;     };     --get retried count     IF Cd.CmdDescriptArray[cmd].needTryCount THEN     { CheckForCR[];       DiagFlTapeTTY.AddString[mkIOCmd[retriedCount]];       DiagFlTapeTTY.AddDecimal[number: ioPtr­.retriedCount];       gotAParameter¬ TRUE;     };   }; };  --now display the status IF ioPtr­.cmdTimedOut THEN { DiagFlTapeTTY.PutCR[count: 1];   DiagFlTapeTTY.PutLine[mkDispl[cmdTimedOut]] } ELSE   IF Cd.CmdDescriptArray[cmd].rtrnsIOStatus THEN   { DiagFlTapeTTY.PutCR[count: 1];     DiagFlTapeTTY.PutString[mkDispl[returnedStatuS]];     SELECT ioPtr­.rtndStatus FROM       inProgress=> DiagFlTapeTTY.PutLine[mkDispl[inProgress]];       goodCompletion=> DiagFlTapeTTY.PutLine[mkDispl[goodCompletion]];       diskChange=> DiagFlTapeTTY.PutLine[mkDispl[diskChange]];       notReady=> DiagFlTapeTTY.PutLine[mkDispl[notReady]];       cylinderError=> DiagFlTapeTTY.PutLine[mkDispl[cylinderError]];       deletedData=> DiagFlTapeTTY.PutLine[mkDispl[deletedData]];       recordNotFound=> DiagFlTapeTTY.PutLine[mkDispl[recordNotFound]];       headerError=> DiagFlTapeTTY.PutLine[mkDispl[headerError]];       dataError=> DiagFlTapeTTY.PutLine[mkDispl[dataError]];       dataLost=> DiagFlTapeTTY.PutLine[mkDispl[dataLost]];       writeFault=> DiagFlTapeTTY.PutLine[mkDispl[writeFault]];       memoryError=> DiagFlTapeTTY.PutLine[mkDispl[memoryError]];       invalidOperation => DiagFlTapeTTY.PutLine[mkDispl[invalidOperation]];       aborted=> DiagFlTapeTTY.PutLine[mkDispl[aborted]];       otherError=> DiagFlTapeTTY.PutLine[mkDispl[otherError]];     ENDCASE;     --Now check if an error occured and the type of error detected     SELECT ioPtr­.errorType FROM       softReadError=>	 DiagFlTapeTTY.PutLine[mkDispl[softErrDtctd]];       softRdErrInSoftErrTbl=>	 DiagFlTapeTTY.PutLine[mkDispl[softErrInSoftErrTbl]];       softRdErrInBadPageTbl=>	 DiagFlTapeTTY.PutLine[mkDispl[softErrInBadPageTbl]];       hardReadError=>	 DiagFlTapeTTY.PutLine[mkDispl[hardReadErrDtctd]];       hardError=>         { IF ioPtr­.errorCode= tooManySubTestSoftErrs THEN	     DiagFlTapeTTY.PutLine[mkDispl[excsSftErrsInSbTs]] ELSE           IF ioPtr­.errorCode= tooManyPassSoftErrs THEN	     DiagFlTapeTTY.PutLine[mkDispl[excsSftErrsInPss]] ELSE           IF ioPtr­.errorCode= tooManySubTestHardReadErrs THEN	     DiagFlTapeTTY.PutLine[mkDispl[excsHrdRdErrsInSbTs]] ELSE             IF ioPtr­.errorCode= tooManyPassHardReadErrs THEN	       DiagFlTapeTTY.PutLine[mkDispl[excsHrdRdErrsInPss]] ELSE               IF ioPtr­.errorCode= retentionErr THEN	         DiagFlTapeTTY.PutLine[mkDispl[retnsnFailed]] ELSE	           DiagFlTapeTTY.PutLine[mkDispl[hardErrDetctd]];	 };       disaster=> DiagFlTapeTTY.PutLine[mkDispl[hardErrDetctd]];     ENDCASE;     --now check if a retensioning pass was done     IF ioPtr­.retensionPassDone THEN       DiagFlTapeTTY.PutLine[mkDispl[retensionPassDone]];     --now check for write protected tape cartridge     IF ioPtr­.writeProtected THEN       DiagFlTapeTTY.PutLine[mkDispl[writeProtected]];            --now check for a returned sector count error     IF ioPtr­.rtrndSectorCntError THEN       DiagFlTapeTTY.PutLine[mkDispl[rtrndSecCntErrDtctd]];     --now check for a returned track count error     IF ioPtr­.rtrndTrackCntError THEN       DiagFlTapeTTY.PutLine[mkDispl[rtrndTrkCntErrDtctd]];     --now check for a ID data error     IF ioPtr­.iDVerifyError THEN       DiagFlTapeTTY.PutLine[mkDispl[iDCompareErr]];     --now check for data not overwritten     IF ioPtr­.dataNotWrittenError THEN       DiagFlTapeTTY.PutLine[mkDispl[dataNotWritten]];     --now check for a data verify error     IF ioPtr­.dataVerifyError THEN     { DiagFlTapeTTY.PutLine[mkDispl[dataCompareErr]];       --display index to the read buffer       string.length¬ 0;       DiagFlTapeDisplay.CardinalToHexString[         number: ioPtr­.dataErrorIndex,         sizeInDigits: 4,         string: string];       DiagFlTapeTTY.PutString[mkDispl[dataErrorIndex]];       DiagFlTapeTTY.PutLine[string];       --display the expected data       string.length¬ 0;       DiagFlTapeDisplay.CardinalToHexString[	 number: ioPtr­.dataErrorExpected,	 sizeInDigits: 4, 	 string: string];       DiagFlTapeTTY.PutString[mkDispl[dataErrorExptd]];       DiagFlTapeTTY.PutLine[string];       --display the observed data       string.length¬ 0;       DiagFlTapeDisplay.CardinalToHexString[	 number: ioPtr­.dataErrorObserved,	 sizeInDigits: 4, 	 string: string];       DiagFlTapeTTY.PutString[mkDispl[dataErrorObs]];       DiagFlTapeTTY.PutLine[string];     };   };  --if the command was read ID then display the ID data IF cmd= readID THEN { -- TYPE taken from FloppyIOFaceDove.mesa   RecordID : TYPE = RECORD [     address : FloppyDiskFace.DiskAddress,     sectorLength : CARDINAL,    MachineDependentBytes : PACKED ARRAY [1..4] OF Environment.Byte];       buffData: LONG POINTER TO RecordID ¬ LOOPHOLE[myp+60];   DiagFlTapeTTY.PutCR[count: 2];   --display the title   DiagFlTapeTTY.PutLine[mkDispl[iDDisplaY]];   --display the track   DiagFlTapeTTY.PutString[mkDispl[track]];   DiagFlTapeTTY.PutNumber[buffData.address.cylinder];   DiagFlTapeTTY.PutCR[count: 1];   --display the head   DiagFlTapeTTY.PutString[mkDispl[side]];   DiagFlTapeTTY.PutNumber[buffData.address.head];   DiagFlTapeTTY.PutCR[count: 1];   --display the sector address   DiagFlTapeTTY.PutString[mkDispl[sector]];   DiagFlTapeTTY.PutNumber[buffData.address.sector];   DiagFlTapeTTY.PutCR[count: 1];   --display the sector length   DiagFlTapeTTY.PutString[mkDispl[sectorLength]];   DiagFlTapeTTY.PutNumber[buffData.sectorLength*2];   DiagFlTapeTTY.PutLine[mkDispl[twoIs512Bytes]];<< Dove FDC does not make CRCs available     --display crc byte 1   DiagFlTapeTTY.PutString[mkDispl[crcByte1]];   DiagFlTapeTTY.PutNumber[bIDPtr­[4]];   DiagFlTapeTTY.PutCR[count: 1];   --display crc byte 2   DiagFlTapeTTY.PutString[mkDispl[crcByte2]];   DiagFlTapeTTY.PutNumber[bIDPtr­[5]];>> };  DiagFlTapeTTY.PutCR[count: 2]; DiagFlTapeOpInt.ProceedOnInput[]; --Dump the whole IOCB & IOPBlock if switch is set IF DiagFlTapeOpInt.Engineering AND DiagFlTapeOpInt.Switch[91] THEN { title: ARRAY [0..0] OF LONG STRING¬ ["IOCB & IOPBlock dump"];   DiagFlTapeDisplay.DumpMemory[title: DESCRIPTOR[title], ptr: myp, words: 80];   DiagFlTapeTTY.PutCR[count: 1]; }; END; --DisplayEntry -- ~~~~~~~~~end of internal procedures~~~~~~~~~ entryIAmAt: CARDINAL; exit: BOOLEAN; firstEntry: CARDINAL; lastEntry: CARDINAL; maxEntries: CARDINAL; minPtr, maxPtr: LONG POINTER TO ARRAY OF WORD; num: CARDINAL; gotAParameter:	BOOLEAN ¬ FALSE; options: ARRAY [0..4] OF LONG STRING ¬ [      mkDispl[earlierEntry],      mkDispl[laterEntry],      mkDispl[sameEntry],      mkDispl[firstEntry],      mkDispl[lastEntry]]; questtext: ARRAY [0..0] OF LONG STRING ¬ [mkDispl[entryExpl]]; IF NOT entriesWrappedAround AND entriesWordOffset = 0 THEN { DiagFlTapeTTY.PutChar[32C];   DiagFlTapeTTY.PutCR[];   DiagFlTapeTTY.PutLine[emptyMsg];   DiagFlTapeOpInt.ProceedOnInput[];   RETURN; }; ptrToEntry ¬ logPtr; IF entriesWrappedAround THEN maxEntries ¬ (logLength/entrySize)   ELSE maxEntries ¬ (entriesWordOffset/entrySize); IF entriesWordOffset = 0 THEN { --ie wrapped around   lastEntry ¬ entryIAmAt ¬ maxEntries; firstEntry ¬ 1; } ELSE { lastEntry ¬ entryIAmAt ¬ (entriesWordOffset/entrySize);   IF NOT entriesWrappedAround THEN firstEntry ¬ 1     ELSE firstEntry ¬ lastEntry + 1; }; minPtr ¬ ptrToEntry; maxPtr ¬ ptrToEntry + ((maxEntries - 1)*entrySize); --go to and display last entry right away ptrToEntry ¬ minPtr + ((entryIAmAt - 1)*entrySize); DisplayEntry[]; IF displType= stepCommandLog THEN RETURN; exit ¬ FALSE; UNTIL exit DO   DiagFlTapeTTY.Initialize[];   num ¬ DiagFlTapeTTY.PutMenu[     title: DiagFlTapeMkMenu.mkMenu[dsplOptionsTtl], options: DESCRIPTOR[options],     optionExplanation: DESCRIPTOR[questtext]];   SELECT num FROM     1 =>     { IF entryIAmAt = firstEntry THEN       { DiagFlTapeTTY.PutChar[32C];         DiagFlTapeTTY.PutLine[mkDispl[noEarlierEntries]];         DiagFlTapeOpInt.ProceedOnInput[];       } ELSE IF entryIAmAt = 1 THEN       { ptrToEntry ¬ maxPtr; entryIAmAt ¬ maxEntries; DisplayEntry[];       } ELSE       { ptrToEntry ¬ ptrToEntry - entrySize;         entryIAmAt ¬ entryIAmAt - 1;         DisplayEntry[];       };     };     2 =>     { IF entryIAmAt = lastEntry THEN       { DiagFlTapeTTY.PutChar[32C];         DiagFlTapeTTY.PutLine[mkDispl[noLaterEntries]];         DiagFlTapeOpInt.ProceedOnInput[];       } ELSE IF entryIAmAt = maxEntries THEN       { ptrToEntry ¬ minPtr; entryIAmAt ¬ 1; DisplayEntry[];       } ELSE       { ptrToEntry ¬ ptrToEntry + entrySize;         entryIAmAt ¬ entryIAmAt + 1;         DisplayEntry[];       };     };     3 => DisplayEntry[];     4 =>     { entryIAmAt ¬ firstEntry;       ptrToEntry ¬ minPtr + ((entryIAmAt - 1)*entrySize);       DisplayEntry[];     };     5 =>     { entryIAmAt ¬ lastEntry;       ptrToEntry ¬ minPtr + ((entryIAmAt - 1)*entrySize);       DisplayEntry[];     };     6 => exit ¬ TRUE;   ENDCASE; ENDLOOP; END;  --DisplayEntries -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- set log error boolean -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LogErrors: PUBLIC PROCEDURE  = BEGIN LogError¬ TRUE; EnableSummaryLog¬ TRUE; END; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to log 48 words of IO data -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  LogEvent: PUBLIC PROCEDURE [	cmdIdx: CARDINAL¬ 0,	command: DiagFlTapeCmdDes.Command] = BEGIN tempLogLength:			CARDINAL	¬ 256; tempLogOffset:			CARDINAL	¬ 0; tempLogCount:			LONG CARDINAL	¬ 0; tempWrappedAround:		BOOLEAN		¬ FALSE; tempCountWrappedAround:	BOOLEAN		¬ FALSE;   IF LogStep THEN   Log [command:		command,	cmdIdx:			cmdIdx,	pointer:		StepLogPtr,	length:			@tempLogLength,	entrySize:		@StepEntrySize,	offset:			@tempLogOffset,	entryCount:		@tempLogCount,	wrappedAround:		@tempWrappedAround,	countWrappedAround:	@tempCountWrappedAround]; IF LogError AND   (DiagFlTapeErrorCheck.SoftError    OR DiagFlTapeErrorCheck.BadPageInTable    OR DiagFlTapeErrorCheck.SoftErrInTable    OR DiagFlTapeErrorCheck.HardError    OR DiagFlTapeErrorCheck.Disaster) THEN   Log [command:		command,	cmdIdx:			cmdIdx,	pointer:		ErrLogPtr,	length:			@ErrLogLength,	entrySize:		@ErrEntrySize,	offset:			@ErrEntryOffset,	entryCount:		@ErrEntryCount,	wrappedAround:		@ErrEntriesWrappedAround,	countWrappedAround:	@ErrCountWrappedAround];	 IF EnableSummaryLog THEN   LogSummary[	command:		command,	cmdIdx:			cmdIdx]; IF Trace THEN   Log [command:		command,	cmdIdx:			cmdIdx,	pointer:		TracePtr,	length:			@TraceLength,	entrySize:		@TraceEntrySize,	offset:			@TraceEntryOffset,	entryCount:		@TraceEntryCount,	wrappedAround:		@TraceEntriesWrappedAround,	countWrappedAround:	@TraceCountWrappedAround];	  END; --LogEvent  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Log: PROCEDURE[	command:		DiagFlTapeCmdDes.Command,	cmdIdx:			CARDINAL,	pointer:		LONG POINTER TO ARRAY OF WORD,	length:			LONG POINTER TO CARDINAL,	entrySize:		LONG POINTER TO CARDINAL,	offset:			LONG POINTER TO CARDINAL,	entryCount:		LONG POINTER TO LONG CARDINAL,	wrappedAround:		LONG POINTER TO BOOLEAN,	countWrappedAround:	LONG POINTER TO BOOLEAN]	 = BEGIN count:		CARDINAL¬ 0;  --loc [0..1] = entry count entryCount­ ¬ entryCount­+ 1; pointer­ [offset­] ¬ Inline.LowHalf[entryCount­]; offset­ ¬ offset­+ 1; pointer­ [offset­] ¬ Inline.HighHalf[entryCount­]; offset­ ¬ offset­+ 1; --loc [2] IF DiagFlTapeRunCmdFile.RunningUserCmdFile THEN   pointer­ [offset­] ¬ 0 ELSE     pointer­ [offset­] ¬ DiagFlTapeOpInt.PassCount; offset­ ¬ offset­+ 1; --loc [3] IF DiagFlTapeRunCmdFile.RunningUserCmdFile THEN   pointer­ [offset­] ¬ 0 ELSE     pointer­ [offset­] ¬ VAL[DiagFlTapeTestRec.SubTestBeingExecuted]; offset­ ¬ offset­+ 1;  --loc [4..27] Inline.LongCOPY [     from: @Io.IoCPA[cmdIdx],     nwords: 24,     to: pointer+ offset­]; offset­ ¬ offset­+ 24; --loc [28..59] Inline.LongCOPY [     from: Io.IoCPA[cmdIdx].opPtr,     nwords: 32,     to: pointer+ offset­]; offset­ ¬ offset­+ 32; --loc [60..62] IF command= readID THEN   Inline.LongCOPY [     from: Io.RdIDBuffArray[cmdIdx],     nwords: 3,     to: pointer+ offset­]; offset­ ¬ offset­+ 3;  --loc [63] nothing in there offset­ ¬ offset­+ 1; --are we running out of log space? IF length­< offset­+ entrySize­ THEN { offset­ ¬ 0;   wrappedAround­ ¬ TRUE }; IF entryCount­= 37777777777B THEN countWrappedAround­ ¬ TRUE;  END; --Log -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LogSummary: PROCEDURE  [	command: DiagFlTapeCmdDes.Command,	cmdIdx: CARDINAL¬ 0] = BEGIN  IF NOT EnableSummaryLog   OR DiagFlTapeTestControl.RepeatingCommand   OR command NOT IN [retntn..formatTk] THEN RETURN;  --update count of commands executed SummLogArray[command].commandsExecuted¬    SummLogArray[command].commandsExecuted+ 1; --sectors transferred SummLogArray[command].sectorsXferedCount¬    SummLogArray[command].sectorsXferedCount+      Io.IoCPA[cmdIdx].sectorOrTrackCount- Io.IoCPA[cmdIdx].opPtr­.count; IF Io.IoCPA[cmdIdx].rtndStatus# goodCompletion THEN   SummLogArray[command].sectorsXferedCount¬      SummLogArray[command].sectorsXferedCount+ 1;  --now count error types IF Io.IoCPA[cmdIdx].cmdTimedOut THEN   SummLogArray[command].cmdTimedOutCount¬      SummLogArray[command].cmdTimedOutCount+ 1; IF Io.IoCPA[cmdIdx].dataVerifyError THEN   SummLogArray[command].dataVerifyErrCount¬      SummLogArray[command].dataVerifyErrCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= inProgress THEN   SummLogArray[command].inProgressCount¬      SummLogArray[command].inProgressCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= goodCompletion THEN   SummLogArray[command].goodCompletionCount¬      SummLogArray[command].goodCompletionCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= diskChange THEN   SummLogArray[command].diskChangeCount¬      SummLogArray[command].diskChangeCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= notReady THEN   SummLogArray[command].notReadyCount¬      SummLogArray[command].notReadyCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= cylinderError THEN   SummLogArray[command].cylinderErrorCount¬      SummLogArray[command].cylinderErrorCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= deletedData THEN   SummLogArray[command].deletedDataCount¬      SummLogArray[command].deletedDataCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= recordNotFound THEN   SummLogArray[command].recordNotFoundCount¬      SummLogArray[command].recordNotFoundCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= headerError THEN   SummLogArray[command].headerErrorCount¬      SummLogArray[command].headerErrorCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= dataError  THEN   SummLogArray[command].dataErrorCount¬      SummLogArray[command].dataErrorCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= dataLost   THEN   SummLogArray[command].dataLostCount¬      SummLogArray[command].dataLostCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= writeFault THEN   SummLogArray[command].writeFaultCount¬      SummLogArray[command].writeFaultCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= memoryError THEN   SummLogArray[command].memoryErrorCount¬      SummLogArray[command].memoryErrorCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= invalidOperation THEN   SummLogArray[command].invalidOperationCount¬      SummLogArray[command].invalidOperationCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= aborted THEN   SummLogArray[command].abortedCount¬      SummLogArray[command].abortedCount+ 1; IF Io.IoCPA[cmdIdx].rtndStatus= otherError THEN   SummLogArray[command].otherErrorCount¬      SummLogArray[command].otherErrorCount+ 1; END; --LogSummary -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- set log error boolean -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  StopLoggingErrors: PUBLIC PROCEDURE  = BEGIN LogError¬ FALSE; EnableSummaryLog¬ FALSE; END; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- set log error boolean -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  StopTracingCommands: PUBLIC PROCEDURE  = BEGIN Trace¬ FALSE; END; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to trace commands -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ TraceCommands: PUBLIC PROCEDURE = BEGIN Trace¬ TRUE; END; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- main line code -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --create buffer space and set the pointers ptr: LONG POINTER¬ Space.ScratchMap[	count: errLogPageCnt+ tempLogPageCnt+ tracePageCnt];  ErrLogLength¬ errLogPageCnt*Environment.wordsPerPage; TraceLength¬ tracePageCnt*Environment.wordsPerPage;  ErrLogPtr¬ ptr; TracePtr¬ ErrLogPtr+ ErrLogLength; StepLogPtr¬ TracePtr+ TraceLength; END... --of DiagFlTapeLogImpl.mesa Log 5-Feb-88 11:05:28 JMA: commented out unused Kiku-specific reference "iOBCPtr".10-Feb-88 17:07:18 JMA: changed the way this module accessed data for readID errors.  
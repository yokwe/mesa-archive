-- UserTerminalHeadBounty.mesa - Last Edit:--  JPM		21-Aug-90 10:33:54-- Copyright (C) 1989 by Xerox Corporation.  All rights reserved.-- Copyright (C) 1990 by Advanced Workstation Products, Inc., a Xerox company.  All rights reserved.<< The following program was created in 1989 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  BeepFace USING [],  BeepIOFaceBounty USING [BeepFCBType],  BitBlt USING [BBTable],  BountyInputOutput USING [displayPageCount, firstDisplayPage, GetFCBPtr, NotifyIOP],  DeviceCleanup USING [Await, Item, Reason],  DisplayFace USING [Background, Cursor, CursorPtr, GlobalStatePtr, Point],  DisplayFaceExtras USING [],  DisplayIOFaceBounty USING [BorderType, DisplayAddressControl, DisplayControlRegisterType, DisplayFCBType],  Environment USING [BitAddress, LongPointerFromPage, PageCount, PageFromLongPointer, PageNumber, wordsPerPage],  HeadStartChain,  Inline USING [BITAND, LongCOPY],  KeyboardFace USING [DownUp],  KeyboardIOFaceBounty USING [KeyboardFCBType],  MaintPanelIOFaceBounty USING [MaintPanelFCBType],  MouseFace USING [Buttons, Point],  MouseIOFaceBounty USING [MouseFCBType, MousePositionType],  PageMap USING [flagsClean, flagsVacant, RealPageNumber, SetMapFlags],  PSB USING [ConditionVariable, InterruptLevel, PDA, PDABase];UserTerminalHeadBounty: PROGRAM  IMPORTS BountyInputOutput, DeviceCleanup, Environment, Inline,    RemainingHeads: HeadStartChain, PageMap  EXPORTS BeepFace, DisplayFace, DisplayFaceExtras, HeadStartChain, KeyboardFace, MouseFace  SHARES PageMap =  BEGIN  -- FCB pointers  beepFCB: LONG POINTER TO BeepIOFaceBounty.BeepFCBType =    BountyInputOutput.GetFCBPtr[beep];  displayFCB: LONG POINTER TO DisplayIOFaceBounty.DisplayFCBType =      BountyInputOutput.GetFCBPtr[display];  keyboardFCB: LONG POINTER TO KeyboardIOFaceBounty.KeyboardFCBType =    BountyInputOutput.GetFCBPtr[keyboard];  maintPanelFCB: LONG POINTER TO MaintPanelIOFaceBounty.MaintPanelFCBType =    BountyInputOutput.GetFCBPtr[maintPanel];  mouseFCB: LONG POINTER TO MouseIOFaceBounty.MouseFCBType =    BountyInputOutput.GetFCBPtr[mouse];  -- PUBLIC variables  -- DisplayFace  hasBuffer: PUBLIC BOOLEAN ¬ TRUE;  pagesForBitmap: PUBLIC Environment.PageCount ¬    BountyInputOutput.displayPageCount;  width: PUBLIC CARDINAL[0..32767] ¬ SELECT displayFCB.displayType FROM    nineteenInchMonochrome => 1152,    vgaMonochrome => displayFCB.width,    ENDCASE => 0;  height: PUBLIC CARDINAL[0..32767] ¬ SELECT displayFCB.displayType FROM    nineteenInchMonochrome => 861,    vgaMonochrome => displayFCB.height,    ENDCASE => 0;  pixelsPerInch: PUBLIC CARDINAL ¬ SELECT displayFCB.displayType FROM    nineteenInchMonochrome => 80,    vgaMonochrome => displayFCB.pixelsPerInch,    ENDCASE => 80;  refreshRate: PUBLIC CARDINAL ¬ SELECT displayFCB.displayType FROM    nineteenInchMonochrome => 38,    vgaMonochrome => displayFCB.refreshRate,    ENDCASE => 38;  interlaced: PUBLIC BOOLEAN ¬ TRUE;  hasBorder: PUBLIC BOOLEAN ¬ TRUE;  cursorPosition: PUBLIC LONG POINTER TO READONLY DisplayFace.Point ¬ @cursorPos;  globalStateSize: PUBLIC CARDINAL ¬ 0;  scrollXQuantum, scrollYQuantum: PUBLIC CARDINAL ¬ 1;  scrollingInhibitsCursor: PUBLIC BOOLEAN ¬ FALSE;  -- KeyboardFace  keyboard: PUBLIC LONG POINTER TO READONLY PACKED ARRAY OF KeyboardFace.DownUp ¬    LOOPHOLE[@keyboardFCB.keyStates];  -- MouseFace  position: PUBLIC LONG POINTER TO READONLY MouseFace.Point ¬    LOOPHOLE[@mouseFCB.currentMousePosition];  buttons: PUBLIC LONG POINTER TO READONLY MouseFace.Buttons ¬    LOOPHOLE[@keyboardFCB.keyStates];-- PRIVATE variables  bitmapAddress: LONG POINTER ¬ NIL;  cursorPattern: DisplayFace.Cursor ¬ ALL[0];  cursorPos: DisplayFace.Point ¬ [0, 0];  cursorXOffset: NATURAL ¬ SELECT displayFCB.displayType FROM    nineteenInchMonochrome => 280,    ENDCASE => 0;  cursorYOffset: NATURAL ¬ SELECT displayFCB.displayType FROM    nineteenInchMonochrome => 30,    ENDCASE => 0;  dac: LONG POINTER TO DisplayIOFaceBounty.DisplayAddressControl ¬ SELECT displayFCB.displayType FROM    nineteenInchMonochrome => @dummyDAC,    ENDCASE => Environment.LongPointerFromPage[Environment.PageFromLongPointer[displayFCB]];  dummyDAC: DisplayIOFaceBounty.DisplayAddressControl;  savedBorder: DisplayIOFaceBounty.BorderType ¬ [0, 0];  -- PUBLIC PROCs  -- EXPORTed to DisplayFace or DisplayFaceExtras  << Note: the displayFCB points to hardware-backed memory, so Mesa is able to affect the     display directly. That's not the case with other devices; we must request that the IOP     make changes for us.>>  Connect: PUBLIC PROC [bitMap: Environment.PageNumber] =    BEGIN    real: PageMap.RealPageNumber ¬ BountyInputOutput.firstDisplayPage;    FOR virtual: Environment.PageNumber IN [bitMap..bitMap + BountyInputOutput.displayPageCount) DO      addr: LONG POINTER = Environment.LongPointerFromPage[virtual];      PageMap.SetMapFlags[        virtual: virtual, real: real, flags: PageMap.flagsClean];      real ¬ real + 1;      addr­ ¬ 0;      Inline.LongCOPY[from: addr, nwords: Environment.wordsPerPage - 1, to: addr + 1]    ENDLOOP;    bitmapAddress ¬ Environment.LongPointerFromPage[bitMap];    displayFCB.displayControl.displayBitmap ¬ TRUE;    dac.displayControl ¬ dac.displayControl + 1    END;  CreateScrollWindow: PUBLIC PROC [locn: DisplayFace.Point, w: CARDINAL, h: CARDINAL] = {};  DeleteScrollWindow: PUBLIC PROC = {};  Disconnect: PUBLIC PROC =    BEGIN    bitMap: Environment.PageNumber = Environment.PageFromLongPointer[bitmapAddress];    displayFCB.displayControl.displayBitmap ¬ FALSE;    dac.displayControl ¬ dac.displayControl + 1;    IF bitmapAddress # NIL THEN      FOR virtual: Environment.PageNumber IN [bitMap..bitMap + BountyInputOutput.displayPageCount) DO        PageMap.SetMapFlags[          virtual: virtual, real: NULL, flags: PageMap.flagsVacant]      ENDLOOP;    bitmapAddress ¬ NIL    END;  GetBitBltTable: PUBLIC PROC RETURNS [BitBlt.BBTable] = {    RETURN[      [        dst: [word: bitmapAddress, bit: 0], dstBpl: width,        src: [word: bitmapAddress, bit: 0], srcDesc: [srcBpl[width]],        width: width, height: height, flags: []]]};  GetBorderPattern: PUBLIC PROC RETURNS [oddPairs, evenPairs: [0..377B]] = {    RETURN[displayFCB.border.borderPatternHigh, displayFCB.border.borderPatternLow]};  GetCursorPattern: PUBLIC PROC RETURNS [cursorPtr: DisplayFace.CursorPtr] = {    RETURN[@cursorPattern]};  Initialize: PUBLIC PROC [    globalState: DisplayFace.GlobalStatePtr, wakeVF: WORD] =    BEGIN    pda: PSB.PDABase = PSB.PDA;    testBit: WORD ¬ 100000B;    displayFCB.displayControl ¬ [vORc, FALSE, 0, TRUE, 0];    dac.displayControl ¬ dac.displayControl + 1;    cursorPos ¬ [0, 0];    displayFCB.cursor ¬ [FALSE, cursorXOffset, cursorYOffset];    dac.cursorPosition ¬ dac.cursorPosition + 1;    displayFCB.border ¬ savedBorder ¬ [125B, 252B];    cursorPattern ¬ ALL[0];    IF NOT maintPanelFCB.inhibitCursor THEN      BEGIN      displayFCB.cursorPattern ¬ cursorPattern;      dac.cursorPattern ¬ dac.cursorPattern + 1      END;    FOR i: PSB.InterruptLevel IN PSB.InterruptLevel DO      IF Inline.BITAND[wakeVF, testBit] # 0        THEN LOOPHOLE[pda.interrupt[i], PSB.ConditionVariable].timeout ¬ 1;      testBit ¬ testBit / 2    ENDLOOP;    END;  InitializeCleanup: PUBLIC PROC =	-- Display/Tone Generator cleanup Proc --    BEGIN    item: DeviceCleanup.Item;    oldBorder: DisplayIOFaceBounty.BorderType;    oldDisplayControl: DisplayIOFaceBounty.DisplayControlRegisterType;    oldPosition: MouseIOFaceBounty.MousePositionType;    DO      reason: DeviceCleanup.Reason ¬ DeviceCleanup.Await[@item];      SELECT reason FROM        turnOff, kill =>	  BEGIN	  oldDisplayControl ¬ displayFCB.displayControl;	  oldBorder ¬ displayFCB.border;          oldPosition ¬ mouseFCB.currentMousePosition;          displayFCB.displayControl ¬ [vORc, FALSE, 0, TRUE, 0];          dac.displayControl ¬ dac.displayControl + 1;          displayFCB.border ¬ [0, 0];	  beepFCB.frequency ¬ 0 	  END;        turnOn =>	  BEGIN	  displayFCB.cursor.cursorXCoord ¬ cursorPos.x + cursorXOffset;	  displayFCB.cursor.cursorYCoord ¬ cursorPos.y + cursorYOffset;          dac.cursorPosition ¬ dac.cursorPosition + 1;	  displayFCB.border ¬ oldBorder;	  displayFCB.displayControl ¬ oldDisplayControl;          dac.displayControl ¬ dac.displayControl + 1;	  IF NOT maintPanelFCB.inhibitCursor THEN	    BEGIN	    displayFCB.cursorPattern ¬ cursorPattern;	    dac.cursorPattern ¬ dac.cursorPattern + 1	    END;	  mouseFCB.newMousePosition ¬ oldPosition;          BountyInputOutput.NotifyIOP[mouseFCB.changePositionNotify];	  beepFCB.frequency ¬ 0	  END;        disconnect =>	  BEGIN          bitMap: Environment.PageNumber = Environment.PageFromLongPointer[bitmapAddress];	  displayFCB.displayControl.displayBitmap ¬ FALSE;          dac.displayControl ¬ dac.displayControl + 1;          IF bitmapAddress # NIL THEN            FOR virtual: Environment.PageNumber IN [bitMap..bitMap + BountyInputOutput.displayPageCount) DO              PageMap.SetMapFlags[                virtual: virtual, real: NULL, flags: PageMap.flagsVacant]            ENDLOOP;	  END;        ENDCASE    ENDLOOP    END;  Scroll: PUBLIC PROC [    line: Environment.BitAddress, lineCount: CARDINAL, increment: INTEGER] = {};  SetBackground: PUBLIC PROC [b: DisplayFace.Background] =    BEGIN    SELECT b FROM      black => displayFCB.displayControl.mixRule ¬ vBarANDcBar;      white => displayFCB.displayControl.mixRule ¬ vORc;      ENDCASE;    dac.displayControl ¬ dac.displayControl + 1    END;  SetBorderPattern: PUBLIC PROC [oddPairs, evenPairs: [0..377B]] = {    displayFCB.border ¬ [evenPairs, oddPairs]};  SetCursorPattern: PUBLIC PROC [p: DisplayFace.CursorPtr] =    BEGIN    cursorPattern ¬ p­;    IF NOT maintPanelFCB.inhibitCursor THEN      BEGIN      displayFCB.cursorPattern ¬ p­;      dac.cursorPattern ¬ dac.cursorPattern + 1      END;    END;  SetCursorPosition: PUBLIC PROC [cursor: DisplayFace.Point] =    BEGIN    cursorPos ¬ cursor;    displayFCB.cursor.cursorXCoord ¬ cursor.x + cursorXOffset;    displayFCB.cursor.cursorYCoord ¬ cursor.y + cursorYOffset;    dac.cursorPosition ¬ dac.cursorPosition + 1    END;  TurnOn: PUBLIC PROC =    BEGIN    displayFCB.border ¬ savedBorder;    displayFCB.displayControl.displayBitmap ¬ TRUE;    dac.displayControl ¬ dac.displayControl + 1    END;  TurnOff: PUBLIC PROC =    BEGIN    savedBorder ¬ displayFCB.border;    displayFCB.border ¬ [0, 0];    displayFCB.displayControl.displayBitmap ¬ FALSE;    dac.displayControl ¬ dac.displayControl + 1    END;  -- EXPORTed to MouseFace  SetPosition: PUBLIC PROC [p: MouseFace.Point] =    BEGIN    mouseFCB.newMousePosition ¬ [p.x, p.y];    BountyInputOutput.NotifyIOP[mouseFCB.changePositionNotify]    END;  -- EXPORTed to BeepFace  BeepOn: PUBLIC PROC [frequency: CARDINAL] =    BEGIN    beepFCB.frequency ¬ MAX[37, MIN[frequency, 32767]];    BountyInputOutput.NotifyIOP[beepFCB.beepNotifyMask]    END;  BeepOff: PUBLIC PROC = {    beepFCB.frequency ¬ 0}; -- don't need a down-notify since Agent is polling  -- EXPORTed to HeadStartChain  Start: PUBLIC PROC = {    RemainingHeads.Start[]};  END.  -- of UserTerminalHeadBountyLOG26-Jun-89 - JPM - Created. 4-Dec-89 - JPM - Modified cursorXOffset and cursorYOffset values per actual hardware. 9-Jan-90 - JPM - Handle vgaMonochrome display dimensions.18-Jan-90 - JPM - Switch border pattern assignments (high vs. low byte).21-Aug-90 - JPM - Increment dac fields when display values change (for Bounty 2/3).
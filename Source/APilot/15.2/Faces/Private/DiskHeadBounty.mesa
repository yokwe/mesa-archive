-- DiskHeadBounty.mesa - last edit:--  JPM		28-Aug-90 10:00:09-- Copyright (C) 1989 by Xerox Corporation.  All rights reserved.-- Copyright (C) 1990 by Advanced Workstation Products, Inc., a Xerox company. All rights reserved.<< The following program was created in 1989 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  Boot USING [BootFileDescriptorPageHandle, BootFileDescriptorPageSeal, BootFileDescriptorPageVersion, eofDescriptorLink],  BountyInputOutput USING [Dequeue, Enqueue, GetFCBPtr, NotifyIOP, QueueType, UpNotifyMaskType],  Device USING [nullType, Type],  DeviceCleanup USING [Await, Item, Reason],  DiskIOFaceBounty USING [DiskDCBType, DiskFCBType, DiskIOCBPtr, DiskIOCBType, diskLink],  Environment USING [wordsPerPage],  HeadStartChain USING [Start],--PhysicalVolumeFormat USING [rootPageNumber, rootPageSize],  PilotDiskFace USING [DeterminationMode, DiskAddress, FormattingSpec, FormattingUnit, GlobalStatePtr, OperationPtr, Status, Tries],  Zone USING [Alignment];  DiskHeadBounty: PROGRAM   IMPORTS BountyInputOutput, DeviceCleanup, RemainingHeads: HeadStartChain   EXPORTS HeadStartChain, PilotDiskFace =   BEGIN  -- PUBLIC TYPEs  ControllerHandle: PUBLIC TYPE = CARDINAL;  DeviceHandle: PUBLIC TYPE = CARDINAL;  -- constants--duplicateRootPageNumber: CARDINAL = PhysicalVolumeFormat.rootPageNumber + PhysicalVolumeFormat.rootPageSize;  duplicateRootPageNumber: CARDINAL = 5; -- make sure to keep this correct  -- PUBLIC variables  nullControllerHandle: PUBLIC ControllerHandle ¬ LAST[CARDINAL];  nullDeviceHandle: PUBLIC DeviceHandle ¬ LAST[CARDINAL];  operationSize: PUBLIC CARDINAL ¬ SIZE[DiskIOFaceBounty.DiskIOCBType];  operationAlignment: PUBLIC Zone.Alignment ¬ a1; -- any word boundary  -- PRIVATE variables  fcb: LONG POINTER TO DiskIOFaceBounty.DiskFCBType =    BountyInputOutput.GetFCBPtr[disk];  dcbs: LONG DESCRIPTOR FOR ARRAY OF DiskIOFaceBounty.DiskDCBType =    IF fcb = NIL THEN NIL      ELSE IF fcb.newStyleFCB THEN DESCRIPTOR[@fcb.newDCBs, fcb.numberOfDCBs]        ELSE DESCRIPTOR[fcb.dcbs];  cleanupInitialized: BOOLEAN ¬ FALSE;  -- PUBLIC PROCs  DetermineDiskShape: PUBLIC PROC [    device: DeviceHandle, operation: PilotDiskFace.OperationPtr,    mode: PilotDiskFace.DeterminationMode, buffer: LONG POINTER]    RETURNS [nowKnown: BOOLEAN] = {    RETURN[TRUE]}; -- disk shape is always known  GetControllerAttributes: PUBLIC PROC [ControllerHandle]    RETURNS [globalStateSize: CARDINAL] = {    RETURN [0]};  GetDeviceAttributes: PUBLIC PROC [device: DeviceHandle]    RETURNS [cylinders, movingHeads, fixedHeads, sectorsPerTrack: CARDINAL] = {    IF device < dcbs.LENGTH      THEN RETURN[dcbs[device].numberOfCylinders,        dcbs[device].numberOfHeads, 0, dcbs[device].sectorsPerTrack]      ELSE RETURN[0, 0, 0, 0]};  GetDeviceType: PUBLIC PROC [device: DeviceHandle] RETURNS [Device.Type] = {    RETURN[IF device < dcbs.LENGTH      THEN dcbs[device].deviceType      ELSE Device.nullType]};  GetDriveInfo: PUBLIC PROC [device: DeviceHandle]    RETURNS [firstPageOfInitialMicrocode: PilotDiskFace.DiskAddress,      lastPageOfInitialMicrocode: PilotDiskFace.DiskAddress,      firstPilotPage: PilotDiskFace.DiskAddress,      formattingSpec: PilotDiskFace.FormattingSpec,      formattingAlignment: PilotDiskFace.FormattingUnit] = {    RETURN[[0, 0, duplicateRootPageNumber], [0, 0, duplicateRootPageNumber - 1], [0, 1, 0], NIL, arbitrary]};    -- no initial microcode on this disk; no formatting operations needed  GetFormattingUnit: PUBLIC PROC [device: DeviceHandle]    RETURNS [PilotDiskFace.FormattingUnit] = {    RETURN[arbitrary]};  GetNextController: PUBLIC PROC [controller: ControllerHandle]    RETURNS [ControllerHandle] = {    RETURN[IF controller = nullControllerHandle THEN 0      ELSE nullControllerHandle]};  GetNextDevice: PUBLIC PROC [device: DeviceHandle]    RETURNS [DeviceHandle] = {    RETURN[IF device = nullDeviceHandle THEN 0      ELSE IF device + 1 < dcbs.LENGTH THEN device + 1        ELSE nullDeviceHandle]};  InitializeCleanup: PUBLIC PROC [c: ControllerHandle] =    BEGIN    item: DeviceCleanup.Item;    savedUpNotify: BountyInputOutput.UpNotifyMaskType ¬ fcb.upNotify;    savedQueue: BountyInputOutput.QueueType ¬ fcb.queue;    IF cleanupInitialized OR c # 0 THEN RETURN;    cleanupInitialized ¬ TRUE;    DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM	turnOff, kill =>	  BEGIN	  fcb.stopAgent ¬ TRUE;	  BountyInputOutput.NotifyIOP[fcb.downNotify];	  THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;	  savedUpNotify ¬ fcb.upNotify;	  savedQueue ¬ fcb.queue	  END;	turnOn =>	  BEGIN	  fcb.upNotify ¬ savedUpNotify;          fcb.queue.head ¬ savedQueue.head;          fcb.queue.tail ¬ savedQueue.tail;          fcb.queue.active ¬ savedQueue.active;	  fcb.stopAgent ¬ FALSE;	  BountyInputOutput.NotifyIOP[fcb.downNotify]	  END;	ENDCASE    ENDLOOP    END;  InitializeController: PUBLIC PROC [    controller: ControllerHandle, globalState: PilotDiskFace.GlobalStatePtr, mask: WORD,    nakedCondition: LONG POINTER TO CONDITION] =    BEGIN    IF NOT fcb.stopAgent THEN      BEGIN      fcb.stopAgent ¬ TRUE;      BountyInputOutput.NotifyIOP[fcb.downNotify];      THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP      END;    fcb.queue.head ¬ fcb.queue.tail ¬ fcb.queue.active ¬ NIL;    fcb.upNotify ¬ mask;    fcb.stopAgent ¬ FALSE    END;  InitializeTrackBuffer: PUBLIC PROC [    device: DeviceHandle, buffer: LONG POINTER, numberOfBuffers: CARDINAL] = {};  Initiate: PUBLIC PROC [op: PilotDiskFace.OperationPtr] =    BEGIN    iocb: DiskIOFaceBounty.DiskIOCBPtr = LOOPHOLE[op];    device: DeviceHandle = op.device;    iocb.clientHeader ¬ op.clientHeader;    IF op.command IN [makeBootable..getBootLocation] THEN      BEGIN      iocb.dataPtr ¬ op.dataPtr +        (IF op.command = getBootLocation THEN 0 ELSE Environment.wordsPerPage);      iocb.incrementDataPtr ¬ FALSE;      iocb.command ¬ IF op.command = makeBootable THEN write ELSE read;      iocb.pageCount ¬ 1;      op.diskHeader ¬ op.clientHeader      END ELSE      BEGIN      iocb.dataPtr ¬ op.dataPtr;      iocb.incrementDataPtr ¬ op.incrementDataPtr;      iocb.command ¬ op.command;      iocb.pageCount ¬ op.pageCount      END;    iocb.retries ¬ 0;    iocb.nextIOCB ¬ NIL;    IF device >= dcbs.LENGTH THEN      BEGIN      iocb.status ¬ clientError;      RETURN      END;    MapFix[iocb];    iocb.status ¬ inProgress;    IF BountyInputOutput.Enqueue[@fcb.queue, iocb, DiskIOFaceBounty.diskLink]      THEN BountyInputOutput.NotifyIOP[fcb.downNotify];    END;  PagesForTrackBuffering: PUBLIC PROC [device: DeviceHandle]    RETURNS [pagesPerBuffer: CARDINAL, maxNumberOfBuffers: CARDINAL] = {    RETURN [0, 0]}; -- track buffering is not implemented for now  Poll: PUBLIC PROC [c: ControllerHandle] RETURNS [    status: PilotDiskFace.Status, op: PilotDiskFace.OperationPtr, retriedCount: CARDINAL] =    BEGIN    iocb: DiskIOFaceBounty.DiskIOCBPtr ¬ fcb.queue.head;    IF iocb = NIL OR iocb.status = inProgress      THEN RETURN[inProgress, @iocb.operation, 0];    BountyInputOutput.Dequeue[@fcb.queue, iocb, DiskIOFaceBounty.diskLink];    op ¬ @iocb.operation;    op.clientHeader ¬ iocb.clientHeader;    op.dataPtr ¬ iocb.dataPtr;    op.pageCount ¬ iocb.pageCount;    IF iocb.status = goodCompletion AND op.command = makeBootable THEN      BEGIN      bootDescr: Boot.BootFileDescriptorPageHandle ¬ LOOPHOLE[op.dataPtr];      IF bootDescr.header.seal # Boot.BootFileDescriptorPageSeal OR        bootDescr.header.version # Boot.BootFileDescriptorPageVersion        THEN ERROR;      IF bootDescr.header.nextPage # Boot.eofDescriptorLink THEN        BEGIN	op.pageCount ¬ 1;      <<op.clientHeader ¬ bootDescr.header.nextPage; -- get around defs mismatch>>	op.clientHeader ¬ LOOPHOLE[bootDescr.header.nextPage];	Initiate[op];	RETURN[inProgress, NIL, 0]	END;      END;    RETURN[iocb.status, op, iocb.retries]    END;  Recalibrate: PUBLIC PROC [DeviceHandle] = {};  Reset: PUBLIC PROC [c: ControllerHandle] =    BEGIN    fcb.stopAgent ¬ TRUE;    BountyInputOutput.NotifyIOP[fcb.downNotify];    THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;    FOR iocb: DiskIOFaceBounty.DiskIOCBPtr ¬ fcb.queue.head, iocb.nextIOCB      UNTIL iocb = NIL DO      IF iocb.status = inProgress THEN iocb.status ¬ operationReset;    ENDLOOP;    fcb.queue.active ¬ NIL;    fcb.stopAgent ¬ FALSE    END;  Start: PUBLIC --HeadStartChain.-- PROC =    {RemainingHeads.Start[]};  SuggestedTries: PUBLIC PROC [device: DeviceHandle]    RETURNS [tries: PilotDiskFace.Tries] = {    RETURN[IF device < dcbs.LENGTH      THEN dcbs[device].suggestedTries      ELSE 1]};  -- PRIVATE PROCs  MapFix: PROC [iocb: DiskIOFaceBounty.DiskIOCBPtr] =    BEGIN -- touch or dirty each page    pAddr: LONG POINTER ¬ iocb.dataPtr;    pageCount: CARDINAL = IF iocb.incrementDataPtr THEN iocb.pageCount ELSE 1;    SELECT iocb.command FROM      read =>        THROUGH [0..pageCount) DO          pAddr­ ¬ 0;	  pAddr ¬ pAddr + Environment.wordsPerPage	ENDLOOP;      write, verify =>        THROUGH [0..pageCount) DO          d: UNSPECIFIED = pAddr­;	  pAddr ¬ pAddr + Environment.wordsPerPage	ENDLOOP;      ENDCASE    END;  END.LOG 5-Jul-89 - JPM - Created.29-Aug-89 - JPM - Fixed bug in Poll. 4-Oct-89 - JPM - Upgraded to 15.0 (added procs InitializeTrackBuffer and PagesForTrackBuffering and an additional parameter to InitializeController).25-Oct-89 - JPM - Changed Poll to return @iocb.op if status is inProgress (germ needs this). 2-Nov-89 - JPM - Changed GetDriveInfo to return location of duplicateRootPage.10-Nov-89 - JPM - Added "fcb.stopAgent ¬ FALSE" to InitializeController (for germ).16-Nov-89 - JPM - Added queue initialization code to InitializeController (for germ).28-Aug-90 - JPM - Added dcbs (a DESCRIPTOR) in place of fcb.dcbs, to accommodate fcb change.
-- Copyright (C) 1991 by Xerox Corporation, Palo Alto, CA. All rights reserved. -- TapeHeadBounty.mesa	last edited:  1-Nov-91 13:35:14	by CAJDIRECTORY  BountyInputOutput USING [    Dequeue, Enqueue, GetFCBPtr, NotifyIOP, QueueType, UpNotifyMaskType],  Device USING [nullType, Type],  DeviceCleanup USING [Await, Item, Reason],  Environment USING [wordsPerPage],  HeadStartChain USING [Start],  Inline USING [BITAND],  ProcessOperations,  -- implied import  SpecialTapeFace USING [OwnershipStatus],  TapeFace USING [DeviceHandle, OperationPtr, Status],  TapeIOFaceBounty USING [    DeviceBitArray, DeviceState, maxDCBs, TapeDCBType, TapeFCBType, TapeIOCBPtr,    TapeIOCBType, tapeLink],  Zone USING [Alignment];TapeHeadBounty: PROGRAM  IMPORTS BountyInputOutput, DeviceCleanup, Inline,    RemainingHeads: HeadStartChain, ProcessOperations  EXPORTS HeadStartChain, SpecialTapeFace, TapeFace =  BEGIN  -- PUBLIC TYPEs  -- Concrete form of opaque type TapeFace.DeviceHandle:  DeviceHandle: PUBLIC TYPE = CARDINAL;  -- Constants  maxDCBs: CARDINAL = TapeIOFaceBounty.maxDCBs;  alwaysMesaBits: WORD = 7B;  neverMesaBits: WORD = 6B;  noTapeBits: WORD = 0;  presentDedicatedOwnedByMesaMask: WORD = 7B;  sharedCurrentlyMesaBits: WORD = 5B;  sharedCurrentlyOtherBits: WORD = 4B;  -- PUBLIC variables  nullDeviceHandle: PUBLIC DeviceHandle ¬ LAST[CARDINAL];  initialAllocationLength: PUBLIC CARDINAL ¬ 0;  operationAlignment: PUBLIC Zone.Alignment ¬ a2;  operationSize: PUBLIC CARDINAL ¬ SIZE[TapeIOFaceBounty.TapeIOCBType];  -- PRIVATE variables  cancelOutstanding: TapeIOFaceBounty.DeviceBitArray ¬ ALL[FALSE];  cleanupInitialized: BOOLEAN ¬ FALSE;  fcb: LONG POINTER TO TapeIOFaceBounty.TapeFCBType =    BountyInputOutput.GetFCBPtr[tape];  -- INLINE PROCs  BitsFromDeviceState: PROCEDURE [d: TapeIOFaceBounty.DeviceState]    RETURNS [WORD] = INLINE    {RETURN[LOOPHOLE[d]]};  DeviceStateBits: PROCEDURE [d: DeviceHandle, mask: WORD] RETURNS [WORD] = INLINE    {RETURN[Inline.BITAND[fcb.dcbs[d].deviceState, mask]]};  IsMesaTape: PROCEDURE [d: DeviceHandle] RETURNS [BOOLEAN] = INLINE    {RETURN[fcb.dcbs[d].deviceState.ownedByMesa]};  -- PUBLIC PROCs  AwaitCancelClear: PUBLIC PROCEDURE [device: TapeFace.DeviceHandle] =    {WHILE cancelOutstanding[device] DO ENDLOOP};  Cancel: PUBLIC PROCEDURE [device: DeviceHandle] =    BEGIN    fcb.errorStop[device] ¬ TRUE;  -- stop further action below    cancelOutstanding[device] ¬ TRUE;  -- and above    BountyInputOutput.NotifyIOP[fcb.dcbs[device].downNotify];    -- Wait for agent to reset errorStop when it finishes aborting everything    -- currently on the queue.    WHILE fcb.errorStop[device] DO ENDLOOP;    END;  -- Cancel  ClearCancel: PUBLIC PROCEDURE [device: TapeFace.DeviceHandle] =    {cancelOutstanding[device] ¬ FALSE};  GetDeviceAttributes: PUBLIC PROCEDURE [device: DeviceHandle]    RETURNS [deviceType: Device.Type, recommendedBuffersize: LONG CARDINAL,      defaultBlocksize: LONG CARDINAL, minBlocksize: LONG CARDINAL,      variableBlocksize: BOOLEAN, retensionable: BOOLEAN,      autoRewindOnLoad: BOOLEAN, autoRewindOnUnload: BOOLEAN] =    BEGIN    IF CouldBeMesaTape[device] THEN RETURN [      fcb.dcbs[device].deviceType, fcb.dcbs[device].recommendedBuffersize,      fcb.dcbs[device].defaultBlocksize, fcb.dcbs[device].minBlocksize,      fcb.dcbs[device].variableBlocksize, fcb.dcbs[device].retensionable,      fcb.dcbs[device].autoRewindOnLoad, fcb.dcbs[device].autoRewindOnUnload]    ELSE RETURN [Device.nullType, 0, 0, 0, FALSE, FALSE, FALSE, FALSE];    END;  -- GetDeviceAttributes  GetNextDevice: PUBLIC PROCEDURE [previous: DeviceHandle]    RETURNS [next: DeviceHandle] =    BEGIN    FOR next ¬      (IF previous = nullDeviceHandle THEN 0 ELSE previous + 1), next + 1      WHILE next < maxDCBs DO        IF CouldBeMesaTape[next] THEN RETURN;	ENDLOOP;    next ¬ nullDeviceHandle;    END;  -- GetNextDevice  --SpecialTapeFace.--  GetOwnership: PUBLIC PROCEDURE [device: DeviceHandle]    RETURNS [ownershipStatus: SpecialTapeFace.OwnershipStatus] =    BEGIN    alwaysMesaBits: WORD = 7B;    neverMesaBits: WORD = 6B;    presentDedicatedOwnedByMesaMask: WORD = 7B;    sharedCurrentlyMesaBits: WORD = 5B;    sharedCurrentlyOtherBits: WORD = 4B;    ownershipStatus ¬ SELECT      DeviceStateBits[device, presentDedicatedOwnedByMesaMask] FROM        alwaysMesaBits => alwaysMesa,	sharedCurrentlyMesaBits => sharedCurrentlyMesa,	sharedCurrentlyOtherBits => sharedCurrentlyOther,	neverMesaBits => neverMesa,        ENDCASE => nil;    END;  -- GetOwnership  Initialize: PUBLIC PROCEDURE [notify: WORD, initialAllocation: LONG POINTER] =    BEGIN    -- The initialAllocation storage must be resident, of length    -- initialAllocationLength, and of alignment operationAlignment.    -- But actually, initialAllocation is ignored.    waitForThese: TapeIOFaceBounty.DeviceBitArray ¬ ALL[FALSE];    IF NOT fcb.stopAgent THEN      BEGIN      fcb.stopAgent ¬ TRUE;      FOR i: CARDINAL IN [0..maxDCBs) DO        IF IsMesaTape[i] THEN {	  BountyInputOutput.NotifyIOP[fcb.dcbs[i].downNotify];	  waitForThese[i] ¬ TRUE};	ENDLOOP;      THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentsStopped = waitForThese        DO ENDLOOP      END;    FOR i: CARDINAL IN [0..maxDCBs) DO      fcb.dcbs[i].queue.head ¬ fcb.dcbs[i].queue.tail ¬        fcb.dcbs[i].queue.active ¬ NIL;      ENDLOOP;    fcb.upNotify ¬ notify;    fcb.stopAgent ¬ FALSE    END;  -- Initialize  InitializeCleanup: PUBLIC PROCEDURE =    BEGIN    item: DeviceCleanup.Item;    savedUpNotify: BountyInputOutput.UpNotifyMaskType ¬ fcb.upNotify;    savedUpNotifySubmask: TapeIOFaceBounty.DeviceBitArray ¬ fcb.upNotifySubmask;    savedErrorStop: TapeIOFaceBounty.DeviceBitArray ¬ fcb.errorStop;    savedQueue: ARRAY [0..maxDCBs) OF BountyInputOutput.QueueType;    FOR i: CARDINAL IN [0..maxDCBs) DO      savedQueue[i] ¬ fcb.dcbs[i].queue;      ENDLOOP;    IF cleanupInitialized THEN RETURN;    cleanupInitialized ¬ TRUE;    DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM	turnOff, kill =>	  BEGIN	  waitForThese: TapeIOFaceBounty.DeviceBitArray ¬ ALL[FALSE];	  fcb.stopAgent ¬ TRUE;          FOR i: CARDINAL IN [0..maxDCBs) DO            IF IsMesaTape[i] THEN {	      BountyInputOutput.NotifyIOP[fcb.dcbs[i].downNotify];	      waitForThese[i] ¬ TRUE};            ENDLOOP;          THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentsStopped = waitForThese	    DO ENDLOOP;	  savedUpNotify ¬ fcb.upNotify;	  savedUpNotifySubmask ¬ fcb.upNotifySubmask;	  savedErrorStop ¬ fcb.errorStop;          FOR i: CARDINAL IN [0..maxDCBs) DO            savedQueue[i] ¬ fcb.dcbs[i].queue;            ENDLOOP;	  END;	turnOn =>	  BEGIN	  fcb.upNotify ¬ savedUpNotify;	  fcb.upNotifySubmask ¬ fcb.upNotifySubmask;	  fcb.errorStop ¬ savedErrorStop;	  fcb.stopAgent ¬ FALSE;          FOR i: CARDINAL IN [0..maxDCBs) DO            fcb.dcbs[i].queue.head ¬ savedQueue[i].head;            fcb.dcbs[i].queue.tail ¬ savedQueue[i].tail;            fcb.dcbs[i].queue.active ¬ savedQueue[i].active;            IF IsMesaTape[i] THEN	      BountyInputOutput.NotifyIOP[fcb.dcbs[i].downNotify];             ENDLOOP;	  END;	ENDCASE    ENDLOOP    END;  -- InitializeCleanup  Initiate: PUBLIC PROCEDURE [op: TapeFace.OperationPtr]    RETURNS [status: TapeFace.Status] =    BEGIN    dcb: LONG POINTER TO TapeIOFaceBounty.TapeDCBType;    device: DeviceHandle ¬ op.device;    iocb: TapeIOFaceBounty.TapeIOCBPtr = LOOPHOLE[op];    IF device = nullDeviceHandle THEN RETURN[status: iocb.status ¬ failed];    dcb ¬ @fcb.dcbs[device];    IF (fcb.errorStop[op.device] OR cancelOutstanding[op.device]) THEN      RETURN[status: iocb.status ¬ aborted];    SELECT op.command FROM      write, writeFilemark, erase =>	IF dcb.context.writeProtect THEN	  RETURN[status: iocb.status ¬ dataProtect];      > control => RETURN[status: iocb.status ¬ illegalOperation];      ENDCASE => NULL;    iocb.dataPtr ¬ op.dataPtr;    iocb.command ¬ op.command;    iocb.count ¬ op.count;    iocb.incrementDataPtr ¬ op.incrementDataPtr;    MapFix[iocb];    iocb.status ¬ status ¬ inProgress;    IF BountyInputOutput.Enqueue[        @dcb.queue, iocb, TapeIOFaceBounty.tapeLink]      THEN BountyInputOutput.NotifyIOP[dcb.downNotify];    END;  -- Initiate  Poll: PUBLIC PROCEDURE [device: DeviceHandle]    RETURNS [op: TapeFace.OperationPtr, status: TapeFace.Status] =    BEGIN    iocb: TapeIOFaceBounty.TapeIOCBPtr ¬ fcb.dcbs[device].queue.head;    IF iocb = NIL THEN RETURN[NIL, illegalOperation];    IF iocb.status = inProgress THEN RETURN[@iocb.operation, inProgress];    BountyInputOutput.Dequeue[      @fcb.dcbs[device].queue, iocb, TapeIOFaceBounty.tapeLink];    op ¬ @iocb.operation;    op.dataPtr ¬ iocb.dataPtr;    op.count ¬ iocb.count;    SELECT (status ¬ iocb.status) FROM      goodCompletion, BOT, EOF, lengthError => NULL;  -- just status      ENDCASE => Cancel[op.device];  -- errors    END;  -- Poll  Start: PUBLIC --HeadStartChain.-- PROC =    {RemainingHeads.Start[]};  -- Private PROCs  CouldBeMesaTape: PROCEDURE [d: DeviceHandle] RETURNS [BOOLEAN] =    {IF d = nullDeviceHandle OR fcb = NIL THEN RETURN[FALSE]     ELSE {       b: WORD ¬ DeviceStateBits[d, presentDedicatedOwnedByMesaMask];       RETURN[(b # noTapeBits) AND (b # neverMesaBits)]}};  MapFix: PROC [iocb: TapeIOFaceBounty.TapeIOCBPtr] =    BEGIN -- touch or dirty each page    pAddr: LONG POINTER ¬ iocb.dataPtr;    pageCount: CARDINAL = IF iocb.incrementDataPtr THEN      CARDINAL[((iocb.count + 1)/2 + Environment.wordsPerPage - 1)        /Environment.wordsPerPage]      ELSE 1;    SELECT iocb.command FROM      read =>        THROUGH [0..pageCount) DO          pAddr­ ¬ 0;	  pAddr ¬ pAddr + Environment.wordsPerPage	ENDLOOP;      write =>        THROUGH [0..pageCount) DO          d: UNSPECIFIED = pAddr­;	  pAddr ¬ pAddr + Environment.wordsPerPage	ENDLOOP;      ENDCASE    END;  -- MapFix  END...LOG27-Mar-91 16:26:41	CAJ 	Created file. 9-May-91 14:47:07	CAJ 	Mods from channel development.30-May-91 12:53:39	CAJ 	Removed open check in Initiate (agent does it).  Added temporary pinning of code for testing before integration into bootfile.15-Jun-91 18:15:12	CAJ 	Removed temporary stuff for integration into BasicHeads.21-Jun-91 11:06:20	CAJ 	Expanded list of non-cancellees in Poll.16-Sep-91 13:21:02	CAJ 	Removed EOT from non-cancellee list. 1-Nov-91 13:32:27	CAJ 	Added cancelOutstanding mechanism.
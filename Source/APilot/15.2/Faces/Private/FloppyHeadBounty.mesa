-- FloppyHeadBounty.mesa - last edit:--  JPM		19-Jan-90  8:22:00-- Copyright (C) 1989, 1990 by Xerox Corporation.  All rights reserved.<< The following program was created in 1989 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  BountyInputOutput USING [Dequeue, Enqueue, GetFCBPtr, NotifyIOP, QueueType, UpNotifyMaskType],  Device USING [nullType, Type],  DeviceCleanup USING [Await, Item, Reason],  DeviceTypesExtras USING [Floppy, sa455],--DeviceTypesExtras6 USING [microFloppy],  FloppyDiskFace USING [Attributes, Context, DiskAddress, LogStatus, OperationPtr, Status, Tries],  FloppyIOFaceBounty USING [FloppyFCBType, FloppyIOCBPtr, FloppyIOCBType, floppyLink, numberOfDCBs],  HeadStartChain USING [Start],  SpecialFloppyTapeFace USING [Parameters, PhysicalAddress, Statistics],  Zone USING [Alignment];  FloppyHeadBounty: PROGRAM   IMPORTS BountyInputOutput, DeviceCleanup, RemainingHeads: HeadStartChain   EXPORTS FloppyDiskFace, HeadStartChain, SpecialFloppyTapeFace  SHARES Device =   BEGIN  -- PUBLIC TYPE  DeviceHandle: PUBLIC TYPE = CARDINAL;  -- constant (should be in DeviceTypesExtras6)  microFloppy: Device.Type = [LAST[DeviceTypesExtras.Floppy]]; -- 1.44MB, 3 1/2" disks  -- PUBLIC variables  nullDeviceHandle: PUBLIC DeviceHandle ¬ LAST[CARDINAL];  operationBlockLength: PUBLIC CARDINAL ¬ SIZE[FloppyIOFaceBounty.FloppyIOCBType];  operationAlignment: PUBLIC Zone.Alignment ¬ a1; -- any word boundary  initialAllocationLength: PUBLIC CARDINAL ¬ 0;  -- PRIVATE variables  fcb: LONG POINTER TO FloppyIOFaceBounty.FloppyFCBType =    BountyInputOutput.GetFCBPtr[floppy];  deviceContext: ARRAY [0..FloppyIOFaceBounty.numberOfDCBs) OF FloppyDiskFace.Context ¬    ALL[[FALSE, IBM, double, 256]];  cleanupInitialized: BOOLEAN ¬ FALSE;  -- PUBLIC PROCs  DiskChangeClear: PUBLIC PROC [device: DeviceHandle] = {    IF device < FloppyIOFaceBounty.numberOfDCBs      THEN fcb.dcbs[device].diskChanged ¬ FALSE};  GetContext: PUBLIC PROC [device: DeviceHandle]    RETURNS [context: FloppyDiskFace.Context] = {    RETURN[IF device < FloppyIOFaceBounty.numberOfDCBs      THEN deviceContext[device]      ELSE [FALSE, IBM, double, 256]]};  GetDeviceAttributes: PUBLIC PROC [device: DeviceHandle]    RETURNS [attributes: FloppyDiskFace.Attributes] = {    RETURN[IF device < FloppyIOFaceBounty.numberOfDCBs      THEN [        fcb.dcbs[device].deviceType,        fcb.dcbs[device].numberOfCylinders,        fcb.dcbs[device].numberOfHeads,        fcb.dcbs[device].sectorsPerTrack,        0, -- formatLength        fcb.dcbs[device].ready,        fcb.dcbs[device].diskChanged,        fcb.dcbs[device].twoSided,        (fcb.queue.active # NIL) -- same for all devices        ]      ELSE [Device.nullType, 0, 0, 15, 0, FALSE, FALSE, FALSE, FALSE]]};  GetLogStatus: PUBLIC PROC [operationPtr: FloppyDiskFace.OperationPtr]    RETURNS [logStatus: FloppyDiskFace.LogStatus] = {    iocb: FloppyIOFaceBounty.FloppyIOCBPtr = LOOPHOLE[operationPtr];    RETURN[DESCRIPTOR[@iocb.logStatus, 1]]};  GetNextDevice: PUBLIC PROC [previous: DeviceHandle]    RETURNS [next: DeviceHandle] = {    FOR next ¬ (IF previous = nullDeviceHandle THEN 0 ELSE previous + 1),      next + 1 WHILE next < FloppyIOFaceBounty.numberOfDCBs DO      IF fcb.dcbs[next].deviceState.present AND        (fcb.dcbs[next].deviceState.ownedByMesa OR NOT fcb.dcbs[next].deviceState.dedicated)        THEN RETURN[next];    REPEAT      FINISHED => RETURN[nullDeviceHandle]    ENDLOOP};  GetStatistics: PUBLIC PROC RETURNS [stats: SpecialFloppyTapeFace.Statistics] = {    RETURN[[0, 0, 0, FALSE, , 0]]};  GetTapeParameters: PUBLIC PROC [device: DeviceHandle]    RETURNS [parameters: SpecialFloppyTapeFace.Parameters] = {    RETURN[[0, 0]]};  InitializeCleanup: PUBLIC PROC =    BEGIN    item: DeviceCleanup.Item;    savedUpNotify: BountyInputOutput.UpNotifyMaskType ¬ fcb.upNotify;    savedQueue: BountyInputOutput.QueueType ¬ fcb.queue;    IF cleanupInitialized THEN RETURN;    cleanupInitialized ¬ TRUE;    DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM	turnOff, kill =>	  BEGIN	  fcb.stopAgent ¬ TRUE;	  BountyInputOutput.NotifyIOP[fcb.downNotify];	  THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;	  savedUpNotify ¬ fcb.upNotify;	  savedQueue ¬ fcb.queue	  END;	turnOn =>	  BEGIN	  fcb.upNotify ¬ savedUpNotify;          fcb.queue.head ¬ savedQueue.head;          fcb.queue.tail ¬ savedQueue.tail;          fcb.queue.active ¬ savedQueue.active;	  fcb.stopAgent ¬ FALSE;	  BountyInputOutput.NotifyIOP[fcb.downNotify]	  END;	ENDCASE    ENDLOOP    END;  Initialize: PUBLIC PROC [notify: WORD, initialAllocation: LONG POINTER] =    BEGIN    IF NOT fcb.stopAgent THEN      BEGIN      fcb.stopAgent ¬ TRUE;      BountyInputOutput.NotifyIOP[fcb.downNotify];      THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP      END;    fcb.queue.head ¬ fcb.queue.tail ¬ fcb.queue.active ¬ NIL;    fcb.upNotify ¬ notify;    fcb.stopAgent ¬ FALSE    END;  Initiate: PUBLIC PROC [operationPtr: FloppyDiskFace.OperationPtr]    RETURNS [status: FloppyDiskFace.Status] =    BEGIN    iocb: FloppyIOFaceBounty.FloppyIOCBPtr = LOOPHOLE[operationPtr];    device: DeviceHandle = operationPtr.device;    iocb.retries ¬ 0;    iocb.nextIOCB ¬ NIL;    iocb.logStatus ¬ 0;    IF device >= FloppyIOFaceBounty.numberOfDCBs THEN      BEGIN      iocb.status ¬ status ¬ invalidOperation;      RETURN      END;    IF fcb.dcbs[device].diskChanged THEN      BEGIN      iocb.status ¬ status ¬ diskChange;      RETURN      END;    IF (operationPtr.function = writeSector OR operationPtr.function = formatTrack) AND      deviceContext[device].protect THEN      BEGIN      iocb.status ¬ status ¬ writeFault;      RETURN      END;    iocb.density ¬ deviceContext[device].density;    iocb.sectorLength ¬ deviceContext[device].sectorLength;    iocb.sectorsPerTrack ¬ fcb.dcbs[device].sectorsPerTrack;    MapFix[iocb];    iocb.status ¬ status ¬ inProgress;    IF BountyInputOutput.Enqueue[@fcb.queue, iocb, FloppyIOFaceBounty.floppyLink]      THEN BountyInputOutput.NotifyIOP[fcb.downNotify];    END;  LogicalAddressToPhysicalAddress: PUBLIC PROC [logical: FloppyDiskFace.DiskAddress]    RETURNS [physicalAddress: SpecialFloppyTapeFace.PhysicalAddress] = {    RETURN[LOOPHOLE[logical]]};  MaxTracksPerFormatOperation: PUBLIC PROC [device: DeviceHandle]    RETURNS [maxTracks: CARDINAL] = {    RETURN[1]};  Poll: PUBLIC PROC [operation: FloppyDiskFace.OperationPtr] RETURNS [    status: FloppyDiskFace.Status, retriedCount: CARDINAL] =    BEGIN    iocb: FloppyIOFaceBounty.FloppyIOCBPtr = LOOPHOLE[operation];    IF iocb = NIL OR iocb.status = inProgress      THEN RETURN[inProgress, 0];    BountyInputOutput.Dequeue[@fcb.queue, iocb, FloppyIOFaceBounty.floppyLink];    RETURN[iocb.status, iocb.retries]    END;  Reset: PUBLIC PROC [device: DeviceHandle] =    BEGIN    fcb.stopAgent ¬ TRUE;    BountyInputOutput.NotifyIOP[fcb.downNotify];    THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;    fcb.queue.active ¬ NIL;    FOR iocb: FloppyIOFaceBounty.FloppyIOCBPtr ¬ fcb.queue.head, iocb.nextIOCB      UNTIL iocb = NIL DO      IF iocb.status = inProgress THEN        BEGIN	iocbDevice: DeviceHandle = iocb.operation.device;        IF iocbDevice = device THEN	  BEGIN	  iocb.status ¬ aborted;	  BountyInputOutput.Dequeue[@fcb.queue, iocb, FloppyIOFaceBounty.floppyLink]	  END	  ELSE IF fcb.queue.active = NIL THEN fcb.queue.active ¬ iocb;	END;    ENDLOOP;    fcb.stopAgent ¬ FALSE;    BountyInputOutput.NotifyIOP[fcb.downNotify]    END;  Retention: PUBLIC PROC [o: FloppyDiskFace.OperationPtr]    RETURNS [status: FloppyDiskFace.Status] =    BEGIN    iocb: FloppyIOFaceBounty.FloppyIOCBPtr = LOOPHOLE[o];    iocb.retries ¬ 0;    iocb.nextIOCB ¬ NIL;    iocb.logStatus ¬ 0;    iocb.status ¬ status ¬ invalidOperation    END;  SetContext: PUBLIC PROC [device: DeviceHandle, context: FloppyDiskFace.Context]    RETURNS [ok: BOOLEAN] =    BEGIN    ok ¬ (device < FloppyIOFaceBounty.numberOfDCBs AND      context.format = IBM AND      (SELECT context.sectorLength FROM        64, 128, 256 => TRUE,        ENDCASE => FALSE));    IF NOT ok THEN RETURN;    context.density ¬ double; -- the only value OS/2 supports    deviceContext[device] ¬ context;    fcb.dcbs[device].sectorsPerTrack ¬ SELECT fcb.dcbs[device].deviceType FROM      DeviceTypesExtras.sa455 => 9, -- 360KB, 5 1/4" disks      --DeviceTypesExtras6.--microFloppy => 18, -- 1.44MB, 3 1/2" disks      ENDCASE => 15 -- 1.2MB, 5 1/4" disks    END;  Start: PUBLIC --HeadStartChain.-- PROC =    {RemainingHeads.Start[]};  SuggestedTries: PUBLIC PROC [device: DeviceHandle]    RETURNS [tries: FloppyDiskFace.Tries] = {    RETURN[IF device < FloppyIOFaceBounty.numberOfDCBs      THEN fcb.dcbs[device].suggestedTries      ELSE 1]};  -- PRIVATE PROCs  MapFix: PROC [iocb: FloppyIOFaceBounty.FloppyIOCBPtr] =    BEGIN -- touch or dirty each sector    pAddr: LONG POINTER ¬ iocb.operation.dataPtr;    sectorCount: CARDINAL = IF iocb.operation.incrementDataPointer      THEN iocb.operation.count ELSE 1;    SELECT iocb.operation.function FROM      readSector =>        THROUGH [0..sectorCount) DO          pAddr­ ¬ 0;	  pAddr ¬ pAddr + iocb.sectorLength	ENDLOOP;      writeSector =>        THROUGH [0..sectorCount) DO          d: UNSPECIFIED = pAddr­;	  pAddr ¬ pAddr + iocb.sectorLength	ENDLOOP;      ENDCASE    END;  END.LOG30-Jun-89 - JPM - Created. 5-Sep-89 - JPM - Added checking for special conditions in Initiate. 4-Oct-89 - JPM - Added procs for SpecialFloppyTapeFace.10-Nov-89 - JPM - Added "fcb.stopAgent ¬ FALSE" to Initialize (for germ).17-Nov-89 - JPM - Added queue initialization code to Initialize (for germ).19-Jan-90 - JPM - Added test for device type when computing sectors per track.
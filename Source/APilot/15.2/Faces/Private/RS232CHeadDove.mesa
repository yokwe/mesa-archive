-- RS232CHeadDove.mesa-- Created by PE/JA Nov 1984-- Last Edited:-- GRG/RSV	18-Oct-91 16:58:40	:Took out references to NewRS232CFaceExtra, and old routines for Phonenet testing.  -- GRG		20-Aug-90 16:41:59	:Fixed SPAR 219.  Enqueue buffer linkage was screwed up.  Cleaned up compiler warning on GetDeviceStatus.-- BKI		19-Feb-88 14:09:39	:Fixed AR 12830-- BKI		20-Jan-88 18:34:50	:Fixed AR 12607-- BKI		13-Jan-88 15:08:16	:Implemented new NewRS232CFace-- RRP		19-Aug-87 20:08:47  :Cleaned up the clean up code to avoid 938s, including adding a call to SpecialSpace.MakeProcedureResident (note that SpecialSpace.MakeProcedureResident will fail if the procedure is across swapunits boundaries caused by the procedure spanning multiple page groups of the file.  SS AR 9282)-- DMS		13-Nov-85  9:44:59	:Clear flowControl when bitsync mode-- DMS		06-Nov-85 17:00:01	:Allow parameter change when rx queue busy-- JPM		18-Oct-85 13:44:59	:Fixed bug in InitiateSetParameters (must enable parity if # none)-- DMS		10-Oct-85 10:46:22	:Fixed bug in CleanUp routine.  Tx and Rx queues are now aborted.-- DMS		 3-Oct-85 17:02:41	:Fixed bug in SetControlBits-- DMS		20-Sep-85 14:53:13	:added initialization of rsClientType-- DMS		11-Sep-85 10:05:37	:Took out autoEnable-- JPM		22-Aug-85  9:05:14	:Opie redesign conversion-- DMS		19-Apr-85 11:42:37	:completed coding<<	Copyright (C) 1984, 1985, 1986, 1987, 1988, 1991 by Xerox Corporation. All rights reserved.		The following program was created in 1984 but has not been published within the meaning of the copyright law, is furnished under license, and may not be used, copied and/or disclosed except in accordance with the terms of said license.	>><<  This module RS232CHeadDove represents the implementation of the NewRS232CFace definition module.  This head is implemented differently from the Dlion head (RS232CHeadDLion.mesa) due to the architecture difference of the IOP for the two workstations. >>DIRECTORY  DeviceCleanup USING [Await, Item, Reason],  DoveHandlerIDs USING [rs232C],  DoveInputOutput USING [BuildMesaClientCondition, Byte, ByteSwap,         ClientCondition, GetHandlerIORegionPtr, GetIORegionOffset, LockMem,	 LongPointerToOpieAddress, nilOpieAddress, NotifyIOP,	 OpieAddress, OpieAddressToLongPointer,  QueueBlock],  NewRS232CFace USING [Command, CommandStatus, ControlRecord, DeviceStatus,  	 LineNumber, nullLineNumber, OperationPtr, ParameterHandle, ParameterStatus, 	 ParameterRecord, ResetRecord, RS232CClientType, TransferStatus ],  ResidentHeap USING [Alignment, HeapLocation],  RS232CCorrespondents USING [ttyHost],  RS232CEnvironment USING [FlowControl],  RS232CIOFaceDove,  SpecialSpace USING [MakeGlobalFrameResident, MakeEntryVectorResident,         MakeProcedureResident, SpecialError];  RS232CHeadDove: PROGRAM  IMPORTS  DeviceCleanup, DoveInputOutput, SpecialSpace  EXPORTS NewRS232CFace =  BEGIN  OPEN NewRS232CFace;    << PUBLIC TYPE definition. >>  Handle: PUBLIC TYPE = LONG POINTER TO RS232CIOFaceDove.FunctionContextBlock;  << other TYPE definitions. >>    IOCB: TYPE = LONG POINTER TO RS232CIOFaceDove.IOCB;         DeviceStatus: TYPE = NewRS232CFace.DeviceStatus;    RS232CState: TYPE = {OFF, ON};    IOCBQueueState: TYPE =  MACHINE DEPENDENT RECORD [     rxActive: BOOLEAN _ FALSE,      txActive: BOOLEAN _ FALSE];       CleanUpStatus: TYPE = RECORD [     performedOff: 		BOOLEAN _ FALSE,     performedAbortRx:		BOOLEAN _ FALSE,     performedAbortTx:		BOOLEAN _ FALSE,     releasedHandle: 		BOOLEAN _ FALSE,     performedWorldSwapOff:	BOOLEAN _ FALSE,     performedWorldSwapOn:	BOOLEAN _ FALSE];  -- Constants  True: DoveInputOutput.Byte = 0FFH;  False: DoveInputOutput.Byte = 0H;  idle: IOCBQueueState = [FALSE, FALSE];  currentHandle: Handle = DoveInputOutput.GetHandlerIORegionPtr[DoveHandlerIDs.rs232C];   << PUBLIC variables >>  numberOfLines: PUBLIC CARDINAL _ 1;  nilHandle: PUBLIC Handle _ NIL;  operationSize: PUBLIC CARDINAL _ SIZE [RS232CIOFaceDove.IOCB];  operationAlignment: PUBLIC ResidentHeap.Alignment _ a1;  operationLocation: PUBLIC ResidentHeap.HeapLocation _ first64K;  -- PRIVATE Variables    -- defaultParameters:  Note implemented could be read from EEprom and stored in shared memory  currParamRec: NewRS232CFace.ParameterRecord; -- _ defaultParameters;  initializeParms: BOOLEAN _ FALSE; -- this can be taken out if defaultParameters is added  iocbQueueState: IOCBQueueState _ idle;  cleanUpStatus: CleanUpStatus;    -- Parameters for world swapping:  rs232cState: RS232CState _ OFF;  cleanupStarted:	BOOLEAN _ FALSE;  savedClientCondition: DoveInputOutput.ClientCondition;  savedRSWR0ofi8274ChA: RS232CIOFaceDove.WR0ByteType;	  savedRSWR1ofi8274ChA:	RS232CIOFaceDove.WR1ByteType;		  savedRSWR3ofi8274ChA: RS232CIOFaceDove.WR3ByteType;	  savedRSWR4ofi8274ChA: RS232CIOFaceDove.WR4ByteType;		  savedRSWR5ofi8274ChA: RS232CIOFaceDove.WR5ByteType;	  savedRSWR6ofi8274ChA: RS232CIOFaceDove.WR6ByteType;		  savedRSWR7ofi8274ChA:	RS232CIOFaceDove.WR7ByteType;		  savedBaudRate: 	WORD;  savedRSTTYHost:	DoveInputOutput.Byte;  savedRSClientType:    RS232CIOFaceDove.RSClientType;  rsModeSaved: 		RS232CIOFaceDove.RSModeType;  savedRS232FlowControl: RS232CEnvironment.FlowControl;  savedRSFrmTOValue:	WORD;  savedBadRxIntCnts:	CARDINAL;  -- Needed for debug only.    -- Parameters for debugging  rxIOCBSInQueue: CARDINAL _ 0;  txIOCBSInQueue: CARDINAL _ 0;  receiveQEmpty: CARDINAL ¬ 0;    <<******************************************************************>>     << PUBLIC RS232 PROCEDURES>>  << Build deviceStatus from bits in Handle.Status.>>    GetDeviceStatus: PUBLIC PROCEDURE [handle: Handle]    RETURNS [deviceStatus: DeviceStatus] =    BEGIN    iopInputPort: RS232CIOFaceDove.RSIOPSystemInputPortType _      DoveInputOutput.ByteSwap[handle.rsIOPSystemInputPort];          deviceStatus ¬ [breakDetected: FALSE, dataLost: FALSE, ringHeard: FALSE, carrierDetect: FALSE, clearToSend: FALSE, dataSetReady: FALSE, ringIndicator: FALSE];	{	OPEN deviceStatus;	    	 	  	-- latched status bits	breakDetected _ handle.rsLatchedStatus.breakDetected;	dataLost _ handle.rsLatchedStatus.dataLost;	ringHeard _  handle.rsLatchedStatus.ringHeard;	-- unlatched status bits	carrierDetect _ handle.rsReadRegister0.carrierDetect;	clearToSend _ handle.rsReadRegister0.cts;	dataSetReady _ NOT iopInputPort.dataSetReady;	ringIndicator _ NOT iopInputPort.ringIndicator;	};    END;   GetHandle: PUBLIC PROCEDURE [lineNumber: LineNumber, rs232cClient: RS232CClientType _ normalClient]    RETURNS [handle: Handle] =    BEGIN     IF lineNumber # 0 THEN RETURN [NIL];     handle _ currentHandle;     IF handle.rsClientType # rsNoClient THEN RETURN [NIL];     rs232cState _ ON;     handle.rsClientType _ (SELECT rs232cClient FROM     			    noClient	   => rsNoClient,			    normalClient   => rsNormalClient,			    debuggerClient => rsDebuggerClient,			    ENDCASE	   => rsNoClient);    END;         GetNextLine: PUBLIC PROCEDURE [lineNumber: LineNumber]    RETURNS [nextLineNumber: LineNumber] =    BEGIN    nextLineNumber _ (IF lineNumber = NewRS232CFace.nullLineNumber      THEN 0 ELSE NewRS232CFace.nullLineNumber)    END;  Initialize: PUBLIC PROC [notify: WORD] =    BEGIN    handle: Handle _ currentHandle;    rsClientConditionChAPtr: LONG POINTER TO DoveInputOutput.ClientCondition _         @handle.rsClientConditionChA;    -- initialize data structures, head, tail, next pointers    handle.rsQueueTxChA _      [DoveInputOutput.nilOpieAddress, DoveInputOutput.nilOpieAddress, DoveInputOutput.nilOpieAddress];    handle.rsQueueRxChA _      [DoveInputOutput.nilOpieAddress, DoveInputOutput.nilOpieAddress, DoveInputOutput.nilOpieAddress];    iocbQueueState _ idle;    cleanUpStatus _ [FALSE, FALSE, FALSE, FALSE, FALSE, FALSE];    handle.rsClientType _ rsNoClient;    DoveInputOutput.BuildMesaClientCondition [rsClientConditionChAPtr, notify]    END;   InitializeCleanup: PUBLIC PROCEDURE =    {    IF cleanupStarted THEN RETURN;    cleanupStarted _ TRUE;    DO      abortResult: BOOLEAN _ FALSE;      commandStatus: CommandStatus;      item:	   DeviceCleanup.Item;      reason:	   DeviceCleanup.Reason;       workList:	   RS232CIOFaceDove.RSWorkListType;      rsCommandWorkListImage: RS232CIOFaceDove.CMDWorkListType _         DoveInputOutput.ByteSwap[currentHandle.rsCommandWorkList];      reason _ DeviceCleanup.Await[@item];      IF rs232cState = ON THEN        SELECT reason FROM 	  turnOff, kill =>            {	-- Save context	    -- Save FCB Parameters	    savedClientCondition _ currentHandle.rsClientConditionChA;	    savedRSWR0ofi8274ChA _ currentHandle.rsWR0ofi8274ChA;	 	    savedRSWR1ofi8274ChA _ currentHandle.rsWR1ofi8274ChA;		 	    savedRSWR3ofi8274ChA _ currentHandle.rsWR3ofi8274ChA;	 	    savedRSWR4ofi8274ChA _ currentHandle.rsWR4ofi8274ChA;		 	    savedRSWR5ofi8274ChA _ currentHandle.rsWR5ofi8274ChA;	 	    savedRSWR6ofi8274ChA _ currentHandle.rsWR6ofi8274ChA;		 	    savedRSWR7ofi8274ChA _ currentHandle.rsWR7ofi8274ChA; 	    savedBaudRate 	 _ currentHandle.rsBaudRateChA;	    savedRSTTYHost       _ currentHandle.rsTTYHost;	    savedRSClientType    _ currentHandle.rsClientType;	    rsModeSaved		 _ currentHandle.rs232Mode;	    savedRS232FlowControl _ currentHandle.rs232FlowControl;	    savedRSFrmTOValue   _ currentHandle.rsFrameTimeoutValue;	    -- Saving this for debugging.	    savedBadRxIntCnts ¬ DoveInputOutput.ByteSwap[currentHandle.badRxIntCnts];	    -- Abort all IOCB's on the Rx and Tx queues from the Mesa side	    <<Useful for Debuging if AbortReceiveInLine is COMMENTED OUT.>>	    abortResult _ AbortReceiveInLine[currentHandle];	    abortResult _ AbortTransmitInLine[currentHandle];	    -- Tell the Handler to Abort the current Tx and Rx 	    rsCommandWorkListImage.commandInProgress _ TRUE;	    rsCommandWorkListImage.abortRx _ TRUE; -- NON DEBUG value TRUE;	    rsCommandWorkListImage.abortTx _ TRUE;	    currentHandle.rsCommandWorkList _ DoveInputOutput.ByteSwap[rsCommandWorkListImage];	    DoveInputOutput.NotifyIOP [currentHandle.rs232WorkMask];	    commandStatus _ PollCommandInLine[currentHandle];	    WHILE commandStatus = inProgress DO	       commandStatus _ PollCommandInLine[currentHandle];	      ENDLOOP;	    -- Set World swap parameters	    cleanUpStatus.performedWorldSwapOff _ TRUE;	    cleanUpStatus.performedWorldSwapOn _ FALSE;	    };	  turnOn =>	    {	    -- restore FCB parameters	    currentHandle.badRxIntCnts ¬ 0; -- Clearing for Debugging.	    currentHandle.rsClientConditionChA _ savedClientCondition;	    currentHandle.rsWR0ofi8274ChA _ savedRSWR0ofi8274ChA;	    currentHandle.rsWR1ofi8274ChA _ savedRSWR1ofi8274ChA;		 	    currentHandle.rsWR3ofi8274ChA _ savedRSWR3ofi8274ChA;	 	    currentHandle.rsWR4ofi8274ChA _ savedRSWR4ofi8274ChA;		 	    currentHandle.rsWR5ofi8274ChA _ savedRSWR5ofi8274ChA;	 	    currentHandle.rsWR6ofi8274ChA _ savedRSWR6ofi8274ChA;	 	    currentHandle.rsWR7ofi8274ChA _ savedRSWR7ofi8274ChA; 	    currentHandle.rsBaudRateChA   _ savedBaudRate;	    currentHandle.rsTTYHost	  _ savedRSTTYHost;	    currentHandle.rsClientType	  _ savedRSClientType;	    currentHandle.rs232Mode 	  _ rsModeSaved;	    currentHandle.rs232FlowControl _ savedRS232FlowControl;	    currentHandle.rsFrameTimeoutValue _ savedRSFrmTOValue;	    -- Have handler set the chip into pre-swap state	    workList _ [TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, TRUE, 	                TRUE, TRUE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE];	    currentHandle.rsWorkList ¬ DoveInputOutput.ByteSwap[workList];	    rsCommandWorkListImage ¬ [FALSE, FALSE, FALSE, FALSE,				      FALSE, FALSE, FALSE, FALSE, 0];	    currentHandle.rsCommandWorkList ¬	      DoveInputOutput.ByteSwap[rsCommandWorkListImage];	    DoveInputOutput.NotifyIOP [currentHandle.rs232WorkMask];	    -- Set World swap parameters            cleanUpStatus.performedWorldSwapOff _ FALSE;	    cleanUpStatus.performedWorldSwapOn _ TRUE;	   };	 disconnect => NULL;  -- turnOff was already called	 ENDCASE;	ENDLOOP;    };<< This procedure exists only for the purpose of existing right after the clean up proc above and then being made resident, which helps workaround AR9282, which makes SpecialSpace.MakeProcedureResident not always make the entire procedure resident. The ParallelPortHeadDove provides another good example of this, since it, too is a run-time loadable Head. >>  WorkaroundForAR9282: PROCEDURE =    BEGIN    nonEmptyProcedure: BOOLEAN;    nonEmptyProcedure _ TRUE;    END;	-- WorkaroundForAR9282   << ** previously named DoCommand ** >>  InitiateCommand: PUBLIC PROCEDURE [handle: Handle, command: Command]     RETURNS [commandStatus: CommandStatus] =    BEGIN    dummyResult: BOOLEAN;    rsWorkListImage: RS232CIOFaceDove.RSWorkListType _        DoveInputOutput.ByteSwap[handle.rsWorkList];    rsCommandWorkListImage: RS232CIOFaceDove.CMDWorkListType _        DoveInputOutput.ByteSwap[handle.rsCommandWorkList];               IF rsCommandWorkListImage.commandInProgress THEN RETURN [rejected];    -- set command requested    SELECT command FROM        abortReceive    => { dummyResult _ AbortReceive[handle];			     rsCommandWorkListImage.abortRx _ TRUE;			   }; 			             abortTransmit   => { dummyResult _ AbortTransmit[handle];			     rsCommandWorkListImage.abortTx _ TRUE;			   };			             breakOn         => handle.rsWR5ofi8274ChA.sendBreak _ rsWorkListImage.wr5 _ rsWorkListImage.workFori8274 _ TRUE;	        breakOff        => { handle.rsWR5ofi8274ChA.sendBreak _ FALSE; 			     rsWorkListImage.wr5 _ rsWorkListImage.workFori8274 _ TRUE };			             getDeviceStatus => rsCommandWorkListImage.getDeviceStatus _ TRUE;	        off             => { -- Wait for all transfers to finish before turning off the channel.			     IF iocbQueueState.txActive THEN RETURN[rejected]; 			     handle.rsWR3ofi8274ChA.rxEnable _ 			     handle.rsWR5ofi8274ChA.txEnable _			     handle.rsWR1ofi8274ChA.txIntDMAenable _			     handle.rsWR1ofi8274ChA.extInterruptEnable _ FALSE;			     rsWorkListImage.wr1 _       			     rsWorkListImage.wr3 _       			     rsWorkListImage.wr5 _        			     rsWorkListImage.workFori8274 _ TRUE;       			     cleanUpStatus.performedOff _ TRUE;			     handle.rsClientType _ rsNoClient;			     initializeParms ¬ FALSE;			     };			             on              => { handle.rsWR3ofi8274ChA.rxEnable _ 			     handle.rsWR5ofi8274ChA.txEnable _ 			     handle.rsWR1ofi8274ChA.txIntDMAenable _ TRUE;			     handle.rsWR1ofi8274ChA.interruptCondition _ 			       intOnAllRxParityAffectsVector;  			     rsWorkListImage.wr1 _			     rsWorkListImage.wr3 _ 			     rsWorkListImage.wr5 _ 			     rsWorkListImage.workFori8274 _ TRUE };      ENDCASE => RETURN [rejected];        -- transfer workList image if there's work to do      IF rsWorkListImage.workFori8274 THEN       handle.rsWorkList _ DoveInputOutput.ByteSwap[rsWorkListImage];             rsCommandWorkListImage.commandInProgress _ TRUE;    -- set FALSE by handler when command is done    handle.rsCommandWorkList _ DoveInputOutput.ByteSwap[rsCommandWorkListImage];    DoveInputOutput.NotifyIOP [handle.rs232WorkMask];    RETURN [inProgress]    END;    		 << ** previously named Get ** >>     InitiateReceive: PUBLIC PROCEDURE [handle: Handle, operation: OperationPtr]    RETURNS [transferStatus: TransferStatus] =    BEGIN    newIocb: IOCB _ LOOPHOLE [operation, IOCB];    IF newIocb.rsOperation.dataBuffer = NIL OR newIocb.rsOperation.bufferByteLength = 0      THEN RETURN [disaster];    rxIOCBSInQueue _ rxIOCBSInQueue + 1; -- for debugging    newIocb.rsBufferSize _ DoveInputOutput.ByteSwap[newIocb.rsOperation.bufferByteLength];    newIocb.rsBufferPtr _ DoveInputOutput.LongPointerToOpieAddress[newIocb.rsOperation.dataBuffer];    newIocb.rsNextIocbChA _ DoveInputOutput.nilOpieAddress;    newIocb.currentOpStatus _ pollRxOrTx;     newIocb.rsIOCBType _ rsIOCBTypeRx;    newIocb.rsActiveIOCB _ False;    newIocb.rsTransferCountChA _ 0;    Enqueue[@handle.rsQueueRxChA, newIocb, handle];    iocbQueueState.rxActive _ TRUE;     RETURN [inProgress];    END; 	  InitiateResetStatusBits:PUBLIC PROCEDURE [handle: Handle, resetRecord: ResetRecord] RETURNS[CommandStatus] =    BEGIN    OPEN resetRecord;    -- Resets the latched Device Status bits: breakDetected, dataLost, ringHeard.      IF resetBreakDetected THEN handle.rsLatchedStatus.breakDetected _ FALSE;      IF resetDataLost THEN handle.rsLatchedStatus.dataLost _ FALSE;      IF resetRingHeard THEN handle.rsLatchedStatus.ringHeard _ FALSE;    RETURN[completed];    END;      << Sets the Control bits in the ControlRecord: dataTerminalReady & requestToSend >>   InitiateSetControlBits: PUBLIC PROCEDURE [handle: Handle, controlRecord: ControlRecord] RETURNS[CommandStatus] =    BEGIN    OPEN controlRecord;    rsWorkListImage: RS232CIOFaceDove.RSWorkListType _       DoveInputOutput.ByteSwap[handle.rsWorkList];    rsCommandWorkListImage: RS232CIOFaceDove.CMDWorkListType _        DoveInputOutput.ByteSwap[handle.rsCommandWorkList];    commandListImage: RS232CIOFaceDove.CMDWorkListType _       DoveInputOutput.ByteSwap[handle.rsCommandWorkList];        -- program control bits & set flag in handle.rsCommandWorkList     commandListImage.rtsCommand _ TRUE;     commandListImage.dtrCommand _ TRUE;     IF dataTerminalReady THEN         handle.rsWR5ofi8274ChA.dtr _ TRUE     ELSE       handle.rsWR5ofi8274ChA.dtr _ FALSE;     IF requestToSend THEN	handle.rsWR5ofi8274ChA.rts _ TRUE     ELSE        handle.rsWR5ofi8274ChA.rts _ FALSE;     rsWorkListImage.wr5 _   TRUE;     rsWorkListImage.workFori8274 _ TRUE;     handle.rsWorkList _ DoveInputOutput.ByteSwap[rsWorkListImage];     rsCommandWorkListImage.commandInProgress _ TRUE;    -- set FALSE by handler when command is done     handle.rsCommandWorkList _ DoveInputOutput.ByteSwap[commandListImage];     DoveInputOutput.NotifyIOP [handle.rs232WorkMask];     RETURN[inProgress];     END;      InitiateSetParameters: PUBLIC PROCEDURE [handle: Handle, parameters: ParameterHandle]     RETURNS [parameterStatus: ParameterStatus] =    BEGIN    OPEN parameters;    unimplementedBaudRate: WORD = 0;    newBaudRateValue: WORD _ 0;    rsWorkListImage: RS232CIOFaceDove.RSWorkListType _       DoveInputOutput.ByteSwap[handle.rsWorkList];    doNotify: BOOLEAN _ FALSE;        -- If the transmit queue is active wait till it completes before changing settings    IF iocbQueueState.txActive THEN RETURN[rejected];        -- reject request if parameters are being set       IF rsWorkListImage.workFori8274 THEN RETURN[rejected];          << Current RS232CHeadDove does not support ByteSynchronous line type and       associated parameter settings, ie. echoing, syncChar, & syncCount  >>           -- update other record fields    currParamRec.clientType _ clientType;    currParamRec.echo _ echo;    currParamRec.syncChar _ syncChar;    currParamRec.syncCount _ syncCount;              -- if no changes in parameter then return completed    IF initializeParms AND (currParamRec = parameters^) THEN RETURN [completed];        -- UPDATE Parameters    IF	currParamRec.correspondent # correspondent OR NOT initializeParms THEN      {      currParamRec.correspondent _ correspondent;      IF correspondent = RS232CCorrespondents.ttyHost THEN        handle.rsTTYHost _ True      ELSE        handle.rsTTYHost _ False;      };    IF currParamRec.flowControl # flowControl OR NOT initializeParms THEN      {      handle.rs232FlowControl.type _ flowControl.type;      handle.rs232FlowControl.xOn _ DoveInputOutput.ByteSwap[flowControl.xOn];      handle.rs232FlowControl.xOff _ DoveInputOutput.ByteSwap[flowControl.xOff];      currParamRec.flowControl _ flowControl;      };        IF currParamRec.lineType # lineType OR NOT initializeParms THEN      BEGIN      doNotify _ TRUE;      rsWorkListImage.changeMode _ TRUE;      currParamRec.lineType _ lineType;      SELECT lineType FROM         asynchronous  => 		BEGIN 		handle.rs232Mode _ asynch;				-- Set Up Write Register 3 for Asynch		handle.rsWR3ofi8274ChA.enterHuntMode _ FALSE;		handle.rsWR3ofi8274ChA.rxCRCenable _ FALSE;		handle.rsWR3ofi8274ChA.addrSearchMode _ FALSE;		handle.rsWR1ofi8274ChA.extInterruptEnable _ FALSE;		-- Set Up Write Register 4 for SDLC		handle.rsWR4ofi8274ChA.clockRate _ x16clk;		SELECT stopBits FROM	           1 => handle.rsWR4ofi8274ChA.stopBits _ oneStopBit;		   2 => handle.rsWR4ofi8274ChA.stopBits _ twoStopBit;		  ENDCASE => RETURN[unimplemented];		  		 -- Set Up Write Register 5 for SDLC 		 handle.rsWR5ofi8274ChA.txCRCenable _ FALSE;		  		rsWorkListImage.wr1 _		rsWorkListImage.wr3 _		rsWorkListImage.wr4 _		rsWorkListImage.wr5 _ TRUE;	        END;		bitSynchronous =>          	BEGIN		handle.rs232Mode _ synch;		-- Set Up Write Register 1 for SDLC		handle.rsWR1ofi8274ChA.extInterruptEnable _ TRUE;		-- Set Up Write Register 3 for SDLC		handle.rsWR3ofi8274ChA.enterHuntMode _ TRUE;		handle.rsWR3ofi8274ChA.rxCRCenable _ TRUE;		handle.rsWR3ofi8274ChA.addrSearchMode _ FALSE;		handle.rsWR3ofi8274ChA.syncCharLoadInhibit _ FALSE; 				-- Set Up Write Register 4 for SDLC		handle.rsWR4ofi8274ChA.clockRate _ x1clk;	     	handle.rsWR4ofi8274ChA.syncCharControl _ SdlcHdlc;		handle.rsWR4ofi8274ChA.stopBits _ enableSyncModes;				-- Set Up Write Register 5 for SDLC	     	handle.rsWR5ofi8274ChA.modeSDLCOrCRC16 _ SDLC;		handle.rsWR5ofi8274ChA.txCRCenable _ TRUE;				-- Set Up Write Register 7 for SDLC		handle.rsWR7ofi8274ChA.mustBe7EinSDLC _ 07EH;			     	-- set worklist	     	rsWorkListImage.wr1 _ rsWorkListImage.wr3 _ rsWorkListImage.wr4 _		rsWorkListImage.wr5 _ rsWorkListImage.wr7 _ TRUE;				handle.rs232FlowControl.type _ none;		currParamRec.flowControl.type _ none;			  	END;  -- bit syncrhronous linetype  	ENDCASE => RETURN [unimplemented]  -- other linetypes not implemented      END;  -- linetype    IF lineType = asynchronous THEN       {       IF currParamRec.stopBits # stopBits OR NOT initializeParms THEN	  BEGIN	  doNotify _ TRUE;	  currParamRec.stopBits _ stopBits;	  SELECT stopBits FROM	        1 => handle.rsWR4ofi8274ChA.stopBits _ oneStopBit;		2 => handle.rsWR4ofi8274ChA.stopBits _ twoStopBit;		ENDCASE => RETURN[unimplemented];	  rsWorkListImage.wr4 _ TRUE;	  END;	};	       IF currParamRec.parity # parity OR NOT initializeParms THEN	BEGIN	doNotify _ TRUE;	currParamRec.parity _ parity;		   	SELECT parity FROM	           none => handle.rsWR4ofi8274ChA.enableParity _ FALSE;		   even => {handle.rsWR4ofi8274ChA.parityOddOrEven _ parityEven;	                    handle.rsWR4ofi8274ChA.enableParity _ TRUE};		   odd  => {handle.rsWR4ofi8274ChA.parityOddOrEven _ parityOdd;	                    handle.rsWR4ofi8274ChA.enableParity _ TRUE};		   ENDCASE => RETURN[unimplemented];	rsWorkListImage.wr4 _ TRUE;	END;	    IF currParamRec.lineSpeed # lineSpeed OR NOT initializeParms THEN	BEGIN	doNotify _ TRUE;	currParamRec.lineSpeed _ lineSpeed;	newBaudRateValue _ (SELECT lineSpeed FROM	      		bps50 	=> 5000, -- values for the i8254	     		bps75 	=> 3334, --   programmable interval timer	      		bps110 	=> 2272,	       		bps150 	=> 1667,	       		bps300 	=> 833,	       		bps600 	=> 417,	       		bps1200 => 208,	     	      --bps1800 => 138,	     	      --bps2000 => 126,	       		bps2400 => 104,	       		bps3600 => 69,	       		bps4800 => 52,	       		bps7200 => 35,	      		bps9600 => 26,	       		bps19200 => 13,	       		ENDCASE	 => unimplementedBaudRate);	IF newBaudRateValue = unimplementedBaudRate THEN RETURN [unimplemented];	handle.rsBaudRateChA _ DoveInputOutput.ByteSwap[newBaudRateValue];	rsWorkListImage.newBaudRate _ TRUE;	END;		     			    IF currParamRec.charLength # charLength OR NOT initializeParms THEN	BEGIN	doNotify _ TRUE;        currParamRec.charLength _ charLength;		             SELECT charLength FROM      	  	5 => handle.rsWR3ofi8274ChA.rxCharLength _ handle.rsWR5ofi8274ChA.txCharLength _ ch5bits;      	 	6 => handle.rsWR3ofi8274ChA.rxCharLength _ handle.rsWR5ofi8274ChA.txCharLength _ ch6bits;      	  	7 => handle.rsWR3ofi8274ChA.rxCharLength _ handle.rsWR5ofi8274ChA.txCharLength _ ch7bits;      	  	8 => handle.rsWR3ofi8274ChA.rxCharLength _ handle.rsWR5ofi8274ChA.txCharLength _ ch8bits;      	  	ENDCASE => RETURN [unimplemented];         rsWorkListImage.wr3 _ rsWorkListImage.wr5 _ TRUE;         END;	          IF currParamRec.frameTimeout # frameTimeout OR NOT initializeParms THEN       BEGIN       currParamRec.frameTimeout _ frameTimeout;       handle.rsFrameTimeoutValue _ DoveInputOutput.ByteSwap[frameTimeout];       END;	        IF NOT initializeParms THEN initializeParms _ TRUE;    IF NOT doNotify THEN RETURN [completed];    rsWorkListImage.workFori8274 _ TRUE;  -- indicate work for the handler    handle.rsWorkList _ DoveInputOutput.ByteSwap[rsWorkListImage];    DoveInputOutput.NotifyIOP [handle.rs232WorkMask];    RETURN [inProgress];    END;  InitiateTransmit: PUBLIC PROCEDURE [handle: Handle, operation: OperationPtr]    RETURNS [transferStatus: TransferStatus] =    BEGIN    newIocb: IOCB _ LOOPHOLE [operation, IOCB];    rsCommandWorkListImage: RS232CIOFaceDove.CMDWorkListType _        DoveInputOutput.ByteSwap[handle.rsCommandWorkList];    IF newIocb.rsOperation.dataBuffer = NIL OR newIocb.rsOperation.bufferByteLength = 0      THEN RETURN [disaster];    txIOCBSInQueue _ txIOCBSInQueue + 1; -- for debugging    newIocb.rsBufferSize _ DoveInputOutput.ByteSwap[newIocb.rsOperation.bufferByteLength];    newIocb.rsBufferPtr _ DoveInputOutput.LongPointerToOpieAddress[newIocb.rsOperation.dataBuffer];    newIocb.rsNextIocbChA _ DoveInputOutput.nilOpieAddress;    newIocb.currentOpStatus _ pollRxOrTx;    newIocb.rsIOCBType _ rsIOCBTypeTx;    newIocb.rsActiveIOCB _ False;    newIocb.rsTransferCountChA _ 0;    Enqueue[@handle.rsQueueTxChA, newIocb, handle];    rsCommandWorkListImage.newTx _ TRUE;    iocbQueueState.txActive _ TRUE;    handle.rsCommandWorkList _ DoveInputOutput.ByteSwap[rsCommandWorkListImage];    DoveInputOutput.NotifyIOP [handle.rs232WorkMask];    RETURN [inProgress]    END;      IsReviveProcNeeded: PUBLIC PROCEDURE [handle: Handle]    RETURNS [needed: BOOLEAN] =    BEGIN    RETURN[TRUE];    END;      PollCommand: PUBLIC PROCEDURE [handle: Handle]    RETURNS [commandStatus: CommandStatus] =    BEGIN      RETURN[PollCommandInLine[handle]];    END;      << This procedure is INLINE so that clean up can use it.  If it weren't INLINE, we could just pin the procedure, but we still could frame fault when calling it during clean up, which could lead to a 938.>>  PollCommandInLine: PROCEDURE [handle: Handle]    RETURNS [commandStatus: CommandStatus] = INLINE    BEGIN    rsCommandWorkListImage: RS232CIOFaceDove.CMDWorkListType _        DoveInputOutput.ByteSwap[handle.rsCommandWorkList];    RETURN [(IF rsCommandWorkListImage.commandInProgress THEN inProgress ELSE completed)]    END;   PollReceiveOrTransmit: PUBLIC PROCEDURE [handle: Handle, operation: OperationPtr]    RETURNS [bytesTransferred: CARDINAL, transferStatus: TransferStatus] =    BEGIN    iocb: IOCB _ LOOPHOLE [operation, IOCB];       bytesTransferred _ DoveInputOutput.ByteSwap[iocb.rsTransferCountChA];    -- decode status bytes and build transferStatus    transferStatus _ (SELECT iocb.currentOpStatus FROM    	pollRxOrTx   		=> inProgress,        aborted 	   	=> aborted, 	frameTimeout    	=> frameTimeout,	disaster		=> disaster,	dataLost		=> dataLost,	complete		=>  	  IF iocb.rsIOCBType = rsIOCBTypeTx THEN success	  ELSE (SELECT TRUE FROM    	     handle.rsLatchedStatus.dataLost	    => deviceError,              iocb.rsIocbStatusByte1.rxOverrunError  => deviceError, 	     --   				    => disaster,	     iocb.rsIocbStatusByte1.parityError     => parityError,	     iocb.rsIocbStatusByte1.crcFramingError => 	        IF handle.rs232Mode = asynch THEN asyncFramingError		-- If crcFramingError is set but not end of frame then doesn't 		-- mean a CRC error (See Intle Book 1985 page 6-234)	        ELSE IF iocb.rsIocbStatusByte1.endOfFrameSDLCMode 		  THEN checksumError		  ELSE success,	     ENDCASE				    => success), 	ENDCASE				 	    => disaster);	     IF transferStatus # inProgress  THEN -- dequeue IOCB       SELECT iocb.rsIOCBType FROM	  rsIOCBTypeRx => { DequeueIOCB[handle, operation, @handle.rsQueueRxChA];	  		    rxIOCBSInQueue _ rxIOCBSInQueue - 1; -- for debug			  };	  rsIOCBTypeTx => { DequeueIOCB[handle, operation, @handle.rsQueueTxChA];	  		    txIOCBSInQueue _ txIOCBSInQueue - 1; -- for debug			   };		ENDCASE  => NULL;		    END;  PollResetStatusBits: PUBLIC PROC[handle: Handle] RETURNS[NewRS232CFace.CommandStatus] = {RETURN[completed]};    PollSetControlBits: PUBLIC PROC[handle: Handle] RETURNS[NewRS232CFace.CommandStatus] =    BEGIN    RETURN[PollCommandInLine[handle]];    END;  PollSetParameters: PUBLIC PROCEDURE [handle: Handle]    RETURNS [parameterStatus: ParameterStatus] =    BEGIN    workListImage: RS232CIOFaceDove.RSWorkListType _        DoveInputOutput.ByteSwap[handle.rsWorkList];    RETURN [(IF workListImage.workFori8274 THEN inProgress ELSE completed)]    END;  <<If the queue is non empty but the next pointer of queue is empty then  the queue is likely broken.  The logical comparison would be with nilOpieAddress, but the IOP macros do not advance the type when the advance the next pointer!???     The only okay condition would be if all the   iocbs on the queue had a completed status.  That condition is not checked.  >>  QueueIsBad: PUBLIC PROCEDURE [handle: Handle] RETURNS [badQueue: BOOL] =      {                  RETURN[(handle.rsQueueRxChA.queueHead # DoveInputOutput.nilOpieAddress AND      	     (handle.rsQueueRxChA.queueNext.A15toA0 = LOOPHOLE[0] AND	      handle.rsQueueRxChA.queueNext.A23toA16 = 0))]      }; -- End QueueIsBad.        ReleaseHandle: PUBLIC PROCEDURE [handle: Handle]    RETURNS [nilHandle: Handle] =    BEGIN    rsWorkListImage: RS232CIOFaceDove.RSWorkListType _        DoveInputOutput.ByteSwap[handle.rsWorkList];    rsCommandWorkListImage: RS232CIOFaceDove.CMDWorkListType _        DoveInputOutput.ByteSwap[handle.rsCommandWorkList];    dummy: BOOLEAN _ FALSE;         handle.rsClientType _ rsNoClient;    --abort transfers and turn Rx and Tx off, if not already done    IF iocbQueueState # idle THEN       {       IF iocbQueueState.rxActive AND NOT cleanUpStatus.performedAbortRx THEN          IF (dummy _ AbortReceive[handle]) THEN	     rsCommandWorkListImage.abortRx _ TRUE;       IF iocbQueueState.txActive AND NOT cleanUpStatus.performedAbortTx THEN 	  IF (dummy _ AbortTransmit[handle]) THEN	     rsCommandWorkListImage.abortTx _ TRUE;        };    IF NOT cleanUpStatus.performedOff THEN       BEGIN       handle.rsWR3ofi8274ChA.rxEnable _        handle.rsWR5ofi8274ChA.txEnable _        handle.rsWR1ofi8274ChA.txIntDMAenable _       handle.rsWR1ofi8274ChA.extInterruptEnable _ FALSE;       rsWorkListImage.wr3 _       rsWorkListImage.wr5 _        rsWorkListImage.workFori8274 _ TRUE;       handle.rsClientType _ rsNoClient;       cleanUpStatus.performedOff _ TRUE;       END;           rsCommandWorkListImage.resetValues _ TRUE;    rsCommandWorkListImage.commandInProgress _ TRUE;    handle.rsCommandWorkList _ DoveInputOutput.ByteSwap[rsCommandWorkListImage];    DoveInputOutput.NotifyIOP [handle.rs232WorkMask];      IF handle # currentHandle THEN rs232cState _ OFF;    handle _ NIL;    cleanUpStatus.releasedHandle _ TRUE;    RETURN [NIL]    END;  ReviveInputQueue: PUBLIC PROCEDURE [handle: Handle]       RETURNS[revived: BOOL ¬ FALSE, skipped: CARDINAL ¬ 0] =      {      opieAdrs: DoveInputOutput.OpieAddress;      iocb: IOCB;      status: RS232CIOFaceDove.CurrentOpStatusType;      theLockMask: WORD ¬ handle.rs232LockMask;      theInputQueue: LONG POINTER TO DoveInputOutput.QueueBlock ¬ @handle.rsQueueRxChA;            IF theInputQueue = NIL THEN RETURN[FALSE, 0];  -- no queue to revive      -- Find the iocb that queueNext should be pointing to...      FOR iocb _ DoveInputOutput.OpieAddressToLongPointer[theInputQueue.queueHead], DoveInputOutput.OpieAddressToLongPointer[iocb.rsNextIocbChA] WHILE iocb # NIL DO	      status _ iocb.currentOpStatus;	      IF status = pollRxOrTx THEN EXIT;	      skipped _ skipped + 1;	      ENDLOOP;      IF iocb = NIL THEN RETURN[FALSE, skipped];  -- no iocb to point at      opieAdrs _ DoveInputOutput.LongPointerToOpieAddress[iocb];      [] _ DoveInputOutput.LockMem[operation: xchg,address: DoveInputOutput.GetIORegionOffset[@theInputQueue.queueNext]+1,value: Inline.HighHalf[LOOPHOLE[opieAdrs]], mask:  0];      [] _ DoveInputOutput.LockMem[operation: overwriteIfNil,address: DoveInputOutput.GetIORegionOffset[@theInputQueue.queueNext],value: Inline.LowHalf[LOOPHOLE[opieAdrs]],  mask: theLockMask];      revived ¬ TRUE;      }; -- End ReviveInputQueue PROC.         << PRIVATE PROCEDURES >>    AbortReceive: PROCEDURE [handle: Handle] RETURNS[iocbExist: BOOLEAN] =    BEGIN      RETURN[AbortReceiveInLine[handle]];    END;  << This procedure is INLINE so that clean up can use it.  If it weren't INLINE, we could just pin the procedure, but we still could frame fault when calling it during clean up, which could lead to a 938.>>  AbortReceiveInLine: PROCEDURE [handle: Handle] RETURNS[iocbExist: BOOLEAN] = INLINE    BEGIN    abortPtr: IOCB;        iocbExist _ TRUE;    abortPtr _ DoveInputOutput.OpieAddressToLongPointer[handle.rsQueueRxChA.queueHead];    IF abortPtr = NIL THEN iocbExist _ FALSE;          -- traverse the queue and set status = aborted for      -- all IOCB's waiting to be processed.    UNTIL abortPtr = NIL    DO      abortPtr.currentOpStatus _ aborted;      abortPtr _ DoveInputOutput.OpieAddressToLongPointer[abortPtr.rsNextIocbChA];    ENDLOOP;    cleanUpStatus.performedAbortRx _ TRUE;    END;    AbortTransmit: PROCEDURE [handle: Handle] RETURNS[iocbExist: BOOLEAN] =    BEGIN      RETURN[AbortTransmitInLine[handle]];    END;  << This procedure is INLINE so that clean up can use it.  If it weren't INLINE, we could just pin the procedure, but we still could frame fault when calling it during clean up, which could lead to a 938.>>  AbortTransmitInLine: PROCEDURE [handle: Handle]    RETURNS[iocbExist: BOOLEAN] = INLINE    BEGIN    rsWorkListImage: RS232CIOFaceDove.RSWorkListType _ DoveInputOutput.ByteSwap[handle.rsWorkList];    abortPtr: IOCB;        iocbExist _ TRUE;    abortPtr _ DoveInputOutput.OpieAddressToLongPointer[handle.rsQueueTxChA.queueHead];	    IF abortPtr = NIL THEN iocbExist _ FALSE;    -- traverse the queue and set aborted bit & reset inProgress bit     -- of all IOCB's waiting to be processed.    UNTIL abortPtr = NIL    DO       abortPtr.currentOpStatus _ aborted;       abortPtr _ DoveInputOutput.OpieAddressToLongPointer[abortPtr.rsNextIocbChA];    ENDLOOP;        -- if transmitting in SDLC send 13 "1"'s for abort    IF currParamRec.lineType = bitSynchronous THEN       BEGIN       handle.rsWR0ofi8274ChA.SDLCcmd _ sendAbort;       rsWorkListImage.wr0 _ TRUE;       rsWorkListImage.workFori8274 _ TRUE;       handle.rsWorkList _ DoveInputOutput.ByteSwap[rsWorkListImage];       DoveInputOutput.NotifyIOP [handle.rs232WorkMask];       END;           cleanUpStatus.performedAbortTx _ TRUE;    END;   <<If a uncompleted buffer is found while walking the queue then raising a signal of TransmitQueueBad to go to a revive processes might work well.   But this technique would only be used if the linked list was changed to a queue.>>  DequeueIOCB: PUBLIC PROCEDURE [handle:Handle, operation: OperationPtr,      queuePtr: LONG POINTER TO DoveInputOutput.QueueBlock] =     BEGIN    iocb: IOCB _ LOOPHOLE [operation];    leadPtr, trailPtr: IOCB;    opieAdrs: DoveInputOutput.OpieAddress _ DoveInputOutput.LongPointerToOpieAddress[iocb];           IF queuePtr.queueHead = opieAdrs THEN          BEGIN	  queuePtr.queueHead _ iocb.rsNextIocbChA;	  IF opieAdrs = queuePtr.queueTail THEN	    queuePtr.queueTail _ iocb.rsNextIocbChA;	  iocb.rsNextIocbChA _ DoveInputOutput.nilOpieAddress;	  END       ELSE  -- search thru the chain for the specified IOCB          BEGIN	  leadPtr _ trailPtr _ DoveInputOutput.OpieAddressToLongPointer[queuePtr.queueHead];	  UNTIL leadPtr = NIL	    DO	    IF leadPtr = iocb THEN	      { trailPtr.rsNextIocbChA _ leadPtr.rsNextIocbChA;	        leadPtr.rsNextIocbChA _ DoveInputOutput.nilOpieAddress;		IF opieAdrs = queuePtr.queueTail THEN		  queuePtr.queueTail _ DoveInputOutput.LongPointerToOpieAddress[trailPtr];	        EXIT; }	    ELSE	      {	trailPtr _ leadPtr;	        leadPtr _ DoveInputOutput.OpieAddressToLongPointer[leadPtr.rsNextIocbChA] };	    ENDLOOP	    END;          -- IF Queue is now empty clear queue active bit                IF queuePtr.queueHead = DoveInputOutput.nilOpieAddress THEN       	 IF iocb.rsIOCBType = rsIOCBTypeRx THEN	   iocbQueueState.rxActive _ FALSE	 ELSE	   iocbQueueState.txActive _ FALSE;	     END;   <<   The old EnQueue improperly sets the QueueBlock's next pointer.  The pointer always moves forward with each addition to the queue when it should be set only at times the queue is initialized.  After the initial setting, the IOP board controls updating the next pointer.  Fixed for SPAR 219.  Enqueue now properly sets queueNext only when it is nil.  The kludgy test for nil queueNext is due to bad Opie machrs which do not advance the opieaddress type field.  >>    reviveByEnqueue: CARDINAL ¬ 0;  reviveTried: CARDINAL ¬ 0;   Enqueue: PROC [queuePtr: LONG POINTER TO DoveInputOutput.QueueBlock,    newIocb: IOCB, handle: Handle] =     {    revived: BOOL ¬ FALSE;    opieAdrs: DoveInputOutput.OpieAddress _ DoveInputOutput.LongPointerToOpieAddress[newIocb];    IF queuePtr.queueHead = DoveInputOutput.nilOpieAddress THEN    	{        queuePtr.queueHead _ opieAdrs;	[] _ DoveInputOutput.LockMem[	   operation: xchg,	   address: DoveInputOutput.GetIORegionOffset[@queuePtr.queueNext]+1,	   value: Inline.HighHalf[LOOPHOLE[opieAdrs]],	   mask:  0];    	[] _ DoveInputOutput.LockMem [	   operation: overwriteIfNil,	   address: DoveInputOutput.GetIORegionOffset[@queuePtr.queueNext],	   value: Inline.LowHalf[LOOPHOLE[opieAdrs]], 	   mask: handle.rs232LockMask];	}     ELSE{       	 LOOPHOLE[DoveInputOutput.OpieAddressToLongPointer	       [queuePtr.queueTail], IOCB].rsNextIocbChA _ opieAdrs;	 IF (queuePtr.queueNext.A15toA0 = LOOPHOLE[0] AND	    queuePtr.queueNext.A23toA16 = 0) THEN	    {	    [revived] ¬ ReviveInputQueue[handle];	    IF revived THEN	        reviveByEnqueue ¬ reviveByEnqueue + 1;	    reviveTried ¬ reviveTried + 1;	    };	  };     queuePtr.queueTail _ opieAdrs;    };  RS232CHeadInit: PROCEDURE  =    BEGIN  -- could get SpecialSpace.SpecialError[alreadyResident], so catch it.      SpecialSpace.MakeGlobalFrameResident[frame: LOOPHOLE[RS232CHeadDove] !        SpecialSpace.SpecialError => CONTINUE];      SpecialSpace.MakeProcedureResident[proc: LOOPHOLE[InitializeCleanup] !        SpecialSpace.SpecialError => CONTINUE];      SpecialSpace.MakeProcedureResident[proc: LOOPHOLE[WorkaroundForAR9282] !        SpecialSpace.SpecialError => CONTINUE];      SpecialSpace.MakeEntryVectorResident[proc: LOOPHOLE[InitializeCleanup] !        SpecialSpace.SpecialError => CONTINUE];    END;	--RS232CHeadInit  << Mainline code >>  RS232CHeadInit[];       END.  << The following code would be used for changing the current list of IOCB to a queue.--This would be a candidate for adding to the NewRS232CFace but it proably has rather limited use.    UpdateIOCB: PUBLIC PROCEDURE [operation: OperationPtr, newCount: CARDINAL] =    {    iocb: IOCB ¬ LOOPHOLE [operation];        iocb.rsTransferCountChA ¬ DoveInputOutput.ByteSwap[newCount];    };    DequeueHead: PUBLIC PROCEDURE [handle:Handle] =    BEGIN    queuePtr: LONG POINTER TO DoveInputOutput.QueueBlock ¬ @handle.rsQueueRxChA;    iocb: IOCB ¬ DoveInputOutput.OpieAddressToLongPointer[queuePtr.queueHead];        queuePtr.queueHead _ iocb.rsNextIocbChA;    IF iocb = DoveInputOutput.OpieAddressToLongPointer[    queuePtr.queueTail] THEN      queuePtr.queueTail _ iocb.rsNextIocbChA;    iocb.rsNextIocbChA _ DoveInputOutput.nilOpieAddress;     -- IF Queue is now empty clear queue active bit              IF queuePtr.queueHead = DoveInputOutput.nilOpieAddress THEN       iocbQueueState.rxActive _ FALSE;      END;  -- Dequeue procedure   >>
-- ProcessorHeadBounty.mesa - last edit:--  JPM		21-Aug-90 11:08:08-- Copyright (C) 1989 by Xerox Corporation.  All rights reserved.-- Copyright (C) 1990 by Advanced Workstation Products, Inc., a Xerox company. All rights reserved.<< The following program was created in 1989 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  BitBlt USING [AlignedBBTable, BITBLT, BBptr, BBTableSpace],  BountyInputOutput USING [IORegionType, NotifyIOP],  DeviceCleanup USING [Perform],  ESCAlpha USING [aBYTBLTR, aBYTBLT, aDMUL, aSDIV, aSDDIV, aUDDIV],  Environment USING [    bitsPerByte, bytesPerWord, Byte, LongNumber, PageCount, PageNumber, wordsPerPage],  Frame USING [GetReturnFrame, ReadPC, WritePC],  Inline USING [    BITSHIFT, BITXOR, DBITSHIFT, DIVMOD, LongCOPY, LongCOPYReverse,    LongDiv, LongDivMod, LongMult, LowHalf],  KeyboardFace USING [KeyboardType],  Mopcodes USING [zDIS, zDIS2],  PageMap USING [flagsVacant, GetState, State],  PilotMP USING [cPowerOff],  PrincOps USING [ControlLink, ESCTrapTable, LocalFrameHandle, StateVector],  ProcessOperations USING [DisableInterrupts],  ProcessorFace USING [gmtEpoch, GreenwichMeanTime, ProcessorID, SpecialSetMP],  ProcessorFaceExtras USING [CSBanks, MachineType],  ProcessorFaceExtras2 USING [DoveMachineType],  ProcessorIOFaceBounty USING [ProcessorFCBType],  SDDefs USING [SD, sOpcodeTrap];ProcessorHeadBounty: PROGRAM  IMPORTS BitBlt, BountyInputOutput, DeviceCleanup, Frame, Inline, PageMap, ProcessOperations, ProcessorFace  EXPORTS BountyInputOutput, KeyboardFace, ProcessorFace, ProcessorFaceExtras, ProcessorFaceExtras2  SHARES PageMap, ProcessorFace =  BEGIN  -- constants  cvTimeoutMask: WORD = 100000B; -- Dove microcode assumes level 0  ioRegionAfterEnd: CARDINAL = 256;  -- Public items:  -- exported to BountyInputOutput  ioRegionPtr: PUBLIC LONG POINTER TO BountyInputOutput.IORegionType;  firstDisplayPage: PUBLIC CARDINAL;  displayPageCount: PUBLIC CARDINAL;  firstMapPage: PUBLIC CARDINAL;  mapPagesCount: PUBLIC CARDINAL;  ioRegionPage: PUBLIC CARDINAL;  ioRegionPageCount: PUBLIC CARDINAL;  firstRealPage: PUBLIC CARDINAL;  lastRealPage: PUBLIC CARDINAL;  numberRealPages: PUBLIC CARDINAL;  numberVirtualPages: PUBLIC Environment.PageCount;  -- exported to KeyboardFace  keyboardType: PUBLIC KeyboardFace.KeyboardType;  -- exported to ProcessorFace  microsecondsPerHundredPulses: PUBLIC CARDINAL;  millisecondsPerTick: PUBLIC CARDINAL;  mp: PUBLIC CARDINAL;  processorID: PUBLIC ProcessorFace.ProcessorID;  reservedNakedNotifyMask: PUBLIC WORD;  -- Private items:  fcb: LONG POINTER TO ProcessorIOFaceBounty.ProcessorFCBType;  timeToAutoPowerOn: ProcessorFace.GreenwichMeanTime;    InstructionNotImplemented: PRIVATE ERROR = CODE;  --===================  -- Intialization:  --===================  Start: PUBLIC --ProcessorFace.-- PROC =    BEGIN    FindHighestPageInMap: PROC RETURNS [highestPage: CARDINAL ¬ 0] = INLINE {      FOR vp: Environment.PageNumber ¬ 0, vp + 1 UNTIL vp >= numberVirtualPages DO        state: PageMap.State;	rp: Environment.PageNumber;	[state, rp] ¬ PageMap.GetState[vp];	IF state.flags # PageMap.flagsVacant	  THEN highestPage ¬ MAX[highestPage, Inline.LowHalf[rp]];      ENDLOOP};    FindIORegionPtr: PROC = INLINE      BEGIN      testRP: Environment.PageNumber;      ioRegionPage ¬ ioRegionAfterEnd - 1;      ioRegionPtr ¬ LOOPHOLE[LONG[ioRegionPage * Environment.wordsPerPage]];      testRP ¬ PageMap.GetState[ioRegionPage].real;      DO        state: PageMap.State;	rp: Environment.PageNumber;	[state, rp] ¬ PageMap.GetState[ioRegionPage - 1];	IF state.flags = PageMap.flagsVacant THEN EXIT;	testRP ¬ testRP - 1;	IF rp = testRP THEN	  BEGIN	  ioRegionPage ¬ ioRegionPage - 1;	  ioRegionPtr ¬ ioRegionPtr - Environment.wordsPerPage	  END ELSE	  BEGIN	  fcb ¬ ioRegionPtr.fcbPtrs[mesaProcessor];	  IF rp = fcb.displayPageCount THEN ioRegionPage ¬ ioRegionPage - 1;	  EXIT	  END;      ENDLOOP      END;    -- initialize exports    FindIORegionPtr[];    fcb ¬ ioRegionPtr.fcbPtrs[mesaProcessor];    firstDisplayPage ¬ 0;    displayPageCount ¬ fcb.displayPageCount;    firstMapPage ¬ 1024;    mapPagesCount ¬ fcb.vmMapPageCount;    ioRegionPageCount ¬ ioRegionAfterEnd - ioRegionPage;    numberRealPages ¬ fcb.realMemoryPageCount;    numberVirtualPages ¬ Inline.LongMult[mapPagesCount, Environment.wordsPerPage];    firstRealPage ¬ 0;    lastRealPage ¬ FindHighestPageInMap[];    keyboardType ¬ SELECT fcb.keyboardType FROM      pcAT101 => level5,      pcAT102 => eLevel5,      ENDCASE => other;    microsecondsPerHundredPulses ¬ 1560;    millisecondsPerTick ¬ (1000/78); -- display refresh rate    processorID ¬ fcb.processorID;    reservedNakedNotifyMask ¬ cvTimeoutMask;    -- initialize trap vectors    SDDefs.SD[SDDefs.sOpcodeTrap] ¬ LOOPHOLE[UnimplementedTrapHandler];    PrincOps.ESCTrapTable­ ¬      ALL[LOOPHOLE[UnimplementedTrapHandler, PrincOps.ControlLink]];    PrincOps.ESCTrapTable[ESCAlpha.aSDIV] ¬ LOOPHOLE[SDIV];    PrincOps.ESCTrapTable[ESCAlpha.aSDDIV] ¬ LOOPHOLE[SDDIV];    PrincOps.ESCTrapTable[ESCAlpha.aUDDIV] ¬ LOOPHOLE[UDDIV];    PrincOps.ESCTrapTable[ESCAlpha.aDMUL] ¬ LOOPHOLE[DMUL];    -- Note: assume BITBLT is implemented in microcode.    PrincOps.ESCTrapTable[ESCAlpha.aBYTBLT] ¬ LOOPHOLE[BYTBLT];    PrincOps.ESCTrapTable[ESCAlpha.aBYTBLTR] ¬ LOOPHOLE[BYTBLTR]    END;  --Start--  --==============================  -- ProcessorFace Implementation:  --==============================  BootButton: PUBLIC PROC =    BEGIN    ProcessOperations.DisableInterrupts[];    BountyInputOutput.NotifyIOP[fcb.bootNotifyMask];    -- UNTIL rebooted-- DO ENDLOOP    END;  CountCSBanks: PUBLIC PROCEDURE RETURNS [banks: ProcessorFaceExtras.CSBanks] = {    banks ¬ IF fcb.csBanks > 0 THEN fcb.csBanks ELSE 2};         DoveMachineTypeInfo: PUBLIC PROC RETURNS [type: ProcessorFaceExtras2.DoveMachineType] = {    type ¬ diana};  GetGreenwichMeanTime: PUBLIC PROC RETURNS [gmt: ProcessorFace.GreenwichMeanTime] =    {DO      gmt ¬ fcb.gmt;      IF gmt = fcb.gmt THEN RETURN; -- to ensure IOP wasn't changing the value    ENDLOOP};  GetNextAvailableVM: PUBLIC PROC [page: Environment.PageNumber]    RETURNS [firstPage: Environment.PageNumber, count: Environment.PageCount] = {    SELECT page FROM      > ioRegionAfterEnd => RETURN [0, 0];      > 0 => RETURN [ioRegionAfterEnd, numberVirtualPages - ioRegionAfterEnd];      ENDCASE => RETURN [0, ioRegionPage]};  -- = 0  MachineTypeInfo: PUBLIC PROC RETURNS [type: ProcessorFaceExtras.MachineType] = {    type ¬ daybreak};  PowerOff: PUBLIC PROCEDURE =    BEGIN    -- NOTE: This code depends on the greenwich mean time clock running    -- with interrupts disabled and devices turned off.    ProcessOperations.DisableInterrupts [];    DeviceCleanup.Perform[turnOff];    SetMP[PilotMP.cPowerOff];    DO      IF (GetGreenwichMeanTime[] - ProcessorFace.gmtEpoch)        >= (timeToAutoPowerOn - ProcessorFace.gmtEpoch) THEN BootButton[];    ENDLOOP    END;  ResetAutomaticPowerOn: PUBLIC PROC = {    timeToAutoPowerOn ¬ ProcessorFace.gmtEpoch - 1};  SetAutomaticPowerOn: PUBLIC PROC [    gmt: ProcessorFace.GreenwichMeanTime, externalEvent: BOOLEAN] = {    timeToAutoPowerOn ¬ gmt};  -- externalEvent ignored on Bounty  SetGreenwichMeanTime: PUBLIC PROC [gmt: ProcessorFace.GreenwichMeanTime] =    BEGIN    fcb.newGMT ¬ [gmt];    BountyInputOutput.NotifyIOP[fcb.gmtDownNotifyMask]    END;  SetMP: PUBLIC PROC [mpnew: CARDINAL] = {    ProcessorFace.SpecialSetMP[mp ¬ mpnew]};  --===========================================  -- Software implemention of instructions not implemented by microcode  --===========================================  -- The routines below assume that the return link is a frame, and has been started.  UnimplementedTrapHandler: PROC = {    v: RECORD [a: ARRAY [0..3) OF WORD, state: PrincOps.StateVector];    v.state ¬ STATE; ERROR InstructionNotImplemented};  Number: TYPE = Environment.LongNumber;  SDIV: PROC [q, r: INTEGER] RETURNS [INTEGER <<, INTEGER>>] =    BEGIN    -- remainder returned above the stack.    Pop: PROC [INTEGER, INTEGER] RETURNS [INTEGER] = MACHINE CODE {Mopcodes.zDIS};    lf: PrincOps.LocalFrameHandle;    state: PrincOps.StateVector;    negnum, negden: BOOLEAN;    state ¬ STATE;    IF negden ¬ (r < 0) THEN r ¬ -r;    IF negnum ¬ (q < 0) THEN q ¬ -q;    [quotient: q, remainder: r] ¬ Inline.DIVMOD[num: q, den: r];    IF Inline.BITXOR[negnum, negden] # 0 THEN q ¬ -q;    IF negnum THEN r ¬ -r;    lf ¬ Frame.GetReturnFrame[];    Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];    STATE ¬ state;    RETURN Pop[q, r];    END;  -- SDIV--  DMUL:PROC [a, b: Number] RETURNS [product: Number] =    BEGIN    lf: PrincOps.LocalFrameHandle;    state: PrincOps.StateVector;    state ¬ STATE;    product.lc ¬ Inline.LongMult[a.lowbits, b.lowbits];    product.highbits ¬      product.highbits + a.lowbits*b.highbits + a.highbits*b.lowbits;    lf ¬ Frame.GetReturnFrame[];    Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];    STATE ¬ state;    END;  --DMUL--  SDDIV: PROC [num, den: Number] RETURNS [quotient <<, remainder>>: Number] =    BEGIN    -- remainder returned above the stack    Pop2: PROC [Number, Number] RETURNS [Number] = MACHINE CODE {Mopcodes.zDIS2};    remainder: Number;    lf: PrincOps.LocalFrameHandle;    negNum, negDen: BOOLEAN ¬ FALSE;    state: PrincOps.StateVector;    state ¬ STATE;    IF INTEGER[num.highbits] < 0 THEN {negNum ¬ TRUE; num.li ¬ -num.li};    IF INTEGER[den.highbits] < 0 THEN {negDen ¬ TRUE; den.li ¬ -den.li};    [quotient: quotient, remainder: remainder] ¬ DUDivMod[num, den];    IF Inline.BITXOR[negNum,  negDen] # 0 THEN quotient.li ¬ -quotient.li;    IF negNum THEN remainder.li ¬ -remainder.li;    lf ¬ Frame.GetReturnFrame[];    Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];    STATE ¬ state;    RETURN Pop2[quotient, remainder];    END;  --SDDIV--  UDDIV: PROC [num, den: Number]    RETURNS [quotient <<, remainder>>: Number] =    BEGIN    Pop2: PROC [Number, Number] RETURNS [Number] = MACHINE CODE {Mopcodes.zDIS2};    remainder: Number;    lf: PrincOps.LocalFrameHandle;    state: PrincOps.StateVector;    state ¬ STATE;    [quotient: quotient, remainder: remainder] ¬ DUDivMod[num, den];    lf ¬ Frame.GetReturnFrame[];    Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];    STATE ¬ state;    RETURN Pop2[quotient, remainder];    END;  --UDDIV--  DUDivMod: PROC [num, den: Number] RETURNS [quotient, remainder: Number] =    BEGIN    OPEN Inline;    qq: CARDINAL;    count: [0..31);    lTemp: Number;    IF den.highbits = 0 THEN      BEGIN      [quotient.highbits, qq] ¬ LongDivMod[        num: LOOPHOLE[Number[num[lowbits: num.highbits, highbits: 0]]],        den: den.lowbits];      [quotient.lowbits, remainder.lowbits] ¬ LongDivMod[        num: LOOPHOLE[Number[num[lowbits: num.lowbits, highbits: qq]]],        den: den.lowbits];      remainder.highbits ¬ 0;      END    ELSE      BEGIN      count ¬ 0;      quotient.highbits ¬ 0;      lTemp ¬ den;      WHILE lTemp.highbits # 0 DO -- normalize        lTemp.lc ¬ DBITSHIFT[lTemp.lc, -1];        count ¬ count + 1;        ENDLOOP;      IF num.highbits >= lTemp.lowbits THEN {        -- subtract off 2­16*divisor and fix up count        div: Number ¬ Number[num[lowbits: 0, highbits: lTemp.lowbits]];        qq ¬ LongDiv[num.lc - div.lc, lTemp.lowbits]/2 + 100000B;        count ¬ count - 1}      ELSE qq ¬ LongDiv[num.lc, lTemp.lowbits]; -- trial quotient      qq ¬ BITSHIFT[qq, -count];      lTemp.lc ¬ LongMult[den.lowbits, qq]; -- multiply by trial quotient      lTemp.highbits ¬ lTemp.highbits + den.highbits*qq;      UNTIL lTemp.lc <= num.lc DO        -- decrease quotient until product is small enough        lTemp.lc ¬ lTemp.lc - den.lc;        qq ¬ qq - 1;        ENDLOOP;      quotient.lowbits ¬ qq;      remainder.lc ¬ num.lc - lTemp.lc;      END;    END;  --DUDivMod--  BYTBLT: PROC [    destBase: LONG ORDERED POINTER, destIndex, count: CARDINAL,    sourceBase: LONG ORDERED POINTER, sourceIndex: CARDINAL] =    BEGIN    OPEN Environment;    lf: PrincOps.LocalFrameHandle = Frame.GetReturnFrame[];    bba: BitBlt.BBTableSpace;    bbt: BitBlt.BBptr = BitBlt.AlignedBBTable[@bba];    MaxBytesPerScanLine: CARDINAL = 40B;    bytesPerScanLine: CARDINAL ¬ MaxBytesPerScanLine;    bitsPerScanLine: CARDINAL;    lines, tail: CARDINAL;    destBase ¬ destBase + destIndex/2;    destIndex ¬ destIndex MOD 2;    sourceBase ¬ sourceBase + sourceIndex/2;    sourceIndex ¬ sourceIndex MOD 2;      IF destIndex = sourceIndex THEN      BEGIN      -- Can use Inline.LongCOPY      s: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬        LOOPHOLE[sourceBase];      d: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬        LOOPHOLE[destBase];      words: CARDINAL;      moved: CARDINAL ¬ 0;      IF destIndex # 0 THEN        BEGIN        -- Thus destIndex = sourceIndex = 1	d[1] ¬ s[1];	d ¬ d+1;	s ¬ s+1;	moved ¬ 1	END;      words ¬ (count-moved)/2;      Inline.LongCOPY[to: d, from: s, nwords: words];      IF (moved + 2*words) # count THEN  --        d[2*words] ¬ s[2*words];  -- Move the one remaining byte      Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];      RETURN      END;         << Can't use Inline.LongCOPY, because source and destination    are "not aligned", i.e., one starts at a word boundary,    the other in the middle of a word. >>    SELECT destBase FROM      > sourceBase =>        BEGIN        wDiff: LONG CARDINAL = destBase - sourceBase;        IF wDiff <= LAST[CARDINAL]/2 THEN          bytesPerScanLine ¬ CARDINAL[wDiff] * bytesPerWord + destIndex - sourceIndex;	END;      < sourceBase => NULL;      ENDCASE => IF sourceIndex < destIndex THEN bytesPerScanLine ¬ 1;    bytesPerScanLine ¬ MIN[bytesPerScanLine, MaxBytesPerScanLine];    bitsPerScanLine ¬ bytesPerScanLine*bitsPerByte;    [quotient: lines, remainder: tail] ¬      Inline.DIVMOD[num: count, den: bytesPerScanLine];    bbt­ ¬ [      dst: [word: destBase, bit: destIndex*bitsPerByte],      dstBpl: bitsPerScanLine,      src: [word: sourceBase, bit: sourceIndex*bitsPerByte],      srcDesc: [srcBpl[bitsPerScanLine]], width: bitsPerScanLine, height: lines,      flags: [        direction: forward, disjoint: FALSE, disjointItems: FALSE, gray: FALSE,        srcFunc: null, dstFunc: null]];    IF lines # 0 THEN BitBlt.BITBLT[bbt];    IF tail # 0 THEN      BEGIN      count ¬ lines*bytesPerScanLine;      bbt.dst.word ¬ bbt.dst.word + count/2;      bbt.src.word ¬ bbt.src.word + count/2;      IF count MOD 2 = 1 THEN	BEGIN        IF destIndex = 0 THEN bbt.dst.bit ¬ bitsPerByte          ELSE bbt.dst ¬ [word: bbt.dst.word + 1, bit: 0];        IF sourceIndex = 0 THEN bbt.src.bit ¬ bitsPerByte          ELSE bbt.src ¬ [word: bbt.src.word + 1, bit: 0];	END;      bbt.width ¬ bitsPerByte*tail;      bbt.height ¬ 1;      BitBlt.BITBLT[bbt]      END;    Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];    END;  --BYTBLT--  BYTBLTR: PROC [    destBase: LONG ORDERED POINTER, destIndex, count: CARDINAL,    sourceBase: LONG ORDERED POINTER, sourceIndex: CARDINAL] =    BEGIN    OPEN Environment;    lf: PrincOps.LocalFrameHandle ¬ Frame.GetReturnFrame[];    bba: BitBlt.BBTableSpace;    bbt: BitBlt.BBptr = BitBlt.AlignedBBTable[@bba];    MaxBytesPerScanLine: CARDINAL = 40B;    bytesPerScanLine: CARDINAL ¬ MaxBytesPerScanLine;    bitsPerScanLine: CARDINAL;    lines, tail: CARDINAL;    destBase ¬ destBase + destIndex/2;    destIndex ¬ destIndex MOD 2;    sourceBase ¬ sourceBase + sourceIndex/2;    sourceIndex ¬ sourceIndex MOD 2;      IF destIndex = sourceIndex THEN      BEGIN      -- Can use Inline.LongCOPYReverse      s: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬        LOOPHOLE[sourceBase];      d: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬        LOOPHOLE[destBase];      words: CARDINAL;      odd: CARDINAL ¬ count MOD 2;      IF sourceIndex # odd THEN        BEGIN	d[count-odd] ¬ s[count-odd];	count ¬ count - 1	END;      words ¬ count/2;      IF sourceIndex # 0 THEN BEGIN        Inline.LongCOPYReverse[to: d+1, from: s+1, nwords: words];        d[1] ¬ s[1]  -- Move the one remaining byte        END        ELSE Inline.LongCOPYReverse[to: d, from: s, nwords: words];      Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf];      RETURN      END;          SELECT sourceBase FROM      > destBase =>	BEGIN        wDiff: LONG CARDINAL = sourceBase - destBase;        IF wDiff <= LAST[CARDINAL]/2 THEN          bytesPerScanLine ¬ CARDINAL[wDiff] * bytesPerWord + sourceIndex - destIndex;	END;      < destBase => NULL;      ENDCASE => IF destIndex < sourceIndex THEN bytesPerScanLine ¬ 1;    bytesPerScanLine ¬ MIN[bytesPerScanLine, MaxBytesPerScanLine];    bitsPerScanLine ¬ bytesPerScanLine*bitsPerByte;    [quotient: lines, remainder: tail] ¬      Inline.DIVMOD[num: count, den: bytesPerScanLine];    bbt­ ¬ [      dst: [        word: destBase + (count + destIndex - bytesPerScanLine)/2,        bit: ((count + destIndex - bytesPerScanLine) MOD 2)*bitsPerByte],      dstBpl: -INTEGER[bitsPerScanLine],      src: [        word: sourceBase + (count + sourceIndex - bytesPerScanLine)/2,        bit: ((count + sourceIndex - bytesPerScanLine) MOD 2)*bitsPerByte],      srcDesc: [srcBpl[-INTEGER[bitsPerScanLine]]],      width: bitsPerScanLine, height: lines,      flags: [        direction: backward, disjoint: FALSE, disjointItems: FALSE, gray: FALSE,        srcFunc: null, dstFunc: null]];    IF lines # 0 THEN BitBlt.BITBLT[bbt];    IF tail # 0 THEN      BEGIN      bbt.dst ¬ [word: destBase, bit: destIndex*bitsPerByte];      bbt.src ¬ [word: sourceBase, bit: sourceIndex*bitsPerByte];      bbt.width ¬ bitsPerByte*tail;      bbt.height ¬ 1;      BitBlt.BITBLT[bbt]      END;    Frame.WritePC[pc: [Frame.ReadPC[lf] + 2], lf: lf]    END;  --BYTBLTR--  END.LOG27-Jun-89 - JPM - Created from ProcessorHeadDove. 7-Jul-89 - JPM - Removed pcPresent. 8-Nov-89 - JPM - Added FindHighestPageInMap within Start.23-Jan-90 - JPM - Added DoveMachineTypeInfo.21-Aug-90 - JPM - Changes for Bounty 2/3.
-- BountyInputOutput.mesa-- Last Edited by JPM 9-May-91 11:30:52<<	Copyright (C) 1989, 1991 by Xerox Corporation. All rights reserved.	Copyright (C) 1990 by Advanced Workstation Products, Inc., a Xerox company. All rights reserved.	The following program was created in 1989 but has not been published within the meaning of the copyright law, is furnished under license, and may not be used, copied and/or disclosed except in accordance with the terms of said license.>>DIRECTORY  Environment USING [bitsPerWord, Byte, PageCount],  ESCAlpha USING [alpha],  Mopcodes USING [zESC],  ProcessOperations USING [DisableInterrupts, EnableInterrupts];BountyInputOutput: DEFINITIONS  IMPORTS ProcessOperations =  BEGIN  << constants which should be in ESCAlpha >>  aLOCKMEM: ESCAlpha.alpha = 210B;  aNOTIFYIOP: ESCAlpha.alpha = 211B;  << TYPEs corresponding to OS/2 STRUCTs and constants >>  AgentID: TYPE = MACHINE DEPENDENT {    maintPanel(0), mesaProcessor(1), floppy(2), disk(3), keyboard(4), mouse(5), ethernet(6),    beep(7), parallelPort(8), display(9), coProcessor(10), serial(11), tty(12), tape(13),    last(15)};  DownNotifyMaskType: TYPE = PRIVATE MACHINE DEPENDENT RECORD [    bitMask(0:0..7): Environment.Byte,    byteIndex(0:8..15): Environment.Byte];  GenLockType: TYPE = PRIVATE MACHINE DEPENDENT RECORD [    mesaLockMask(0): WORD,    genLockFlag(1): WORD];  genLockFree: WORD = 0;  genLockHeld: WORD = 177777B;  IOCBPtr: TYPE = LONG BASE POINTER; -- actual structure is head-specific  IOCBNext: TYPE = IOCBPtr RELATIVE POINTER TO IOCBPtr; -- offset of IOCB link field  IORegionOffset: TYPE = CARDINAL;  IORegionType: PRIVATE TYPE = MACHINE DEPENDENT RECORD [    lockBits(0): LockWordType,    fcbPtrs(2): ARRAY AgentID OF LONG POINTER];  LockWordType: PRIVATE TYPE = MACHINE DEPENDENT RECORD [    mesaLockBits(0): PACKED ARRAY [0..Environment.bitsPerWord) OF BOOLEAN,    os2LockBits(1): PACKED ARRAY [0..Environment.bitsPerWord) OF BOOLEAN];  NotifyType: TYPE = MACHINE DEPENDENT RECORD [    lockMask(0): WORD,    upNotifyBits(1): WORD,    downNotifyBits(2): PACKED ARRAY [0..numberOfDownNotifyBytes) OF Environment.Byte];  numberOfDownNotifyBytes: CARDINAL = 4;  QueueType: TYPE = MACHINE DEPENDENT RECORD [    head(0): IOCBPtr,    tail(2): IOCBPtr,    active(4): IOCBPtr,    queueLock(6): GenLockType];  UpNotifyMaskType: TYPE = WORD;  << Other TYPEs >>  MemOperation: TYPE = MACHINE DEPENDENT {    add(0), and(1), or(2), xchg(3), overwriteIfNil(4)};  << PUBLIC variables (exported from ProcessorHeadBounty) >>  ioRegionPtr: READONLY LONG POINTER TO IORegionType;  firstDisplayPage: READONLY CARDINAL;	-- display memory  displayPageCount: READONLY CARDINAL;	-- size of display bitmap  firstMapPage: READONLY CARDINAL;	-- real memory reserved for map  mapPagesCount: READONLY CARDINAL;	-- size of VM map  ioRegionPage: READONLY CARDINAL;	-- real memory reserved for IORegion  ioRegionPageCount: READONLY CARDINAL;	-- size of IORegion reserved memory  firstRealPage: READONLY CARDINAL;	-- lowest hardware-accessible page  lastRealPage:  READONLY CARDINAL;	-- highest hardware-accessible page  numberRealPages: READONLY CARDINAL;	-- total of all real memory  numberVirtualPages: READONLY Environment.PageCount;	-- limit of supported VM (256 * mapPagesCount)  << Head initialization of FCB ptr (from IORegion table) >>  GetFCBPtr: PROC [agentID: AgentID] RETURNS [LONG POINTER] = INLINE    {RETURN [ioRegionPtr.fcbPtrs[agentID]]};  << IOP Notification and memory locking procedures >>  GetIORegionOffset: PROC [pointer: LONG POINTER] RETURNS [offset: IORegionOffset] = INLINE    {offset ¬ IORegionOffset[pointer - ioRegionPtr]};  GenLock: PROC [genLock: LONG POINTER TO GenLockType] = INLINE    BEGIN    address: IORegionOffset = GetIORegionOffset[@genLock.genLockFlag];    UNTIL LockMem[xchg, address, genLockHeld, genLock.mesaLockMask] = genLockFree DO    ENDLOOP    END;  GenUnlock: PROC [genLock: LONG POINTER TO GenLockType] = INLINE    BEGIN    address: IORegionOffset = GetIORegionOffset[@genLock.genLockFlag];    [] ¬ LockMem[xchg, address, genLockFree, genLock.mesaLockMask]    END;  LockMem: PROC [operation: MemOperation, address: IORegionOffset, value: UNSPECIFIED, mask: WORD] RETURNS [result: UNSPECIFIED] = MACHINE CODE    {Mopcodes.zESC, aLOCKMEM};  NotifyIOP: PROC [notifyMask: DownNotifyMaskType] = MACHINE CODE    {Mopcodes.zESC, aNOTIFYIOP};  << Queueing mechanism >>  << Enqueue adds a new IOCB to the end of a queue. The queue lock must be acquired     to ensure that the agent is not simultaneously advancing through the queue.     If the agent's active list was NIL, it will be necessary for the head to     down-notify the agent after Enqueue has finished. >>  Enqueue: PROC [queue: LONG POINTER TO QueueType, new: IOCBPtr, link: IOCBNext]    RETURNS [downNotify: BOOLEAN] = INLINE    BEGIN    new[link] ¬ NIL;    ProcessOperations.DisableInterrupts[];    GenLock[@queue.queueLock];    IF queue.head = NIL THEN queue.head ¬ new ELSE queue.tail[link] ¬ new;    queue.tail ¬ new;    IF (downNotify ¬ (queue.active = NIL)) THEN queue.active ¬ new;    GenUnlock[@queue.queueLock];    ProcessOperations.EnableInterrupts[]    END;  << Dequeue removes an old IOCB from a queue. The queue lock need not be acquired,     as long as the agent is finished with this particular IOCB (indicated by its status).     Although IOCBs are processed sequentially, the agent may complete more than one IOCB     before the driver begins to poll; so this routine must be prepared to remove an IOCB     from anywhere in the queue. >>  Dequeue: PROC [queue: LONG POINTER TO QueueType, old: IOCBPtr, link: IOCBNext] = INLINE    BEGIN    prev: IOCBPtr ¬ NIL;    IF queue.head = old THEN queue.head ¬ old[link]      ELSE FOR prev ¬ queue.head, prev[link] WHILE prev # NIL DO        IF prev[link] = old THEN	  BEGIN	  prev[link] ¬ old[link];	  EXIT	  END;        ENDLOOP;    IF queue.tail = old THEN queue.tail ¬ prev;    END;  END.LOG 9-May-89 - JPM - Created from DoveInputOutput.mesa12-May-89 - JPM - Added GenLockType, GenLock, GenUnlock17-May-89 - JPM - Added Enqueue and Dequeue. 7-Jul-89 - JPM - Changed value of genLockHeld.15-Nov-89 - JPM - Changed GenUnlock to use locked operation.21-Aug-90 - JPM - Added types to AgentID. 9-May-91 - JPM - Added type to AgentID.
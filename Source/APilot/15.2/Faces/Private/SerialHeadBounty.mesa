-- SerialHeadBounty.mesa - last edit:--  RSV		28-Feb-92 11:23:53-- Copyright (C) 1990, 1992 by Advanced Workstation Products, Inc., a Xerox company.  All rights reserved.<< The following program was created in 1990 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  BountyInputOutput USING [Dequeue, Enqueue, GetFCBPtr, NotifyIOP, QueueType, UpNotifyMaskType],  DeviceCleanup USING [Await, Item, Reason],  Environment USING [bytesPerWord, LongPointerFromPage, PageFromLongPointer, PageNumber],  Inline USING [BITAND, BITNOT, BITOR],  NewRS232CFace USING [ControlRecord, Command, CommandStatus, DeviceStatus, Handle, LineNumber, nullLineNumber, Operation, OperationPtr, ParameterHandle, ParameterRecord, ParameterStatus, ResetRecord, RS232CClientType, TransferStatus],  ResidentHeap USING [Alignment, HeapLocation],  SerialIOFaceBounty USING [SerialFaceFCBType, SerialIOCBPtr, SerialIOCBType, serialLink];  SerialHeadBounty: PROGRAM   IMPORTS BountyInputOutput, DeviceCleanup, Environment, Inline  EXPORTS NewRS232CFace =   BEGIN  -- PUBLIC TYPE  Handle: PUBLIC TYPE = LONG POINTER;  -- constants  fcb: LONG POINTER TO SerialIOFaceBounty.SerialFaceFCBType =    BountyInputOutput.GetFCBPtr[serial];  bpw: CARDINAL = Environment.bytesPerWord;  nullStatus: NewRS232CFace.DeviceStatus =    [FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE];  latchedStatusMask: NewRS232CFace.DeviceStatus =    [TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE];  -- PUBLIC variables  numberOfLines: PUBLIC CARDINAL ¬ (IF fcb = NIL THEN 0 ELSE 1);  nilHandle: PUBLIC Handle ¬ NIL;  operationSize: PUBLIC CARDINAL ¬ SIZE[SerialIOFaceBounty.SerialIOCBType] +    (IF fcb = NIL THEN 0 ELSE fcb.agentBlockSize);  operationAlignment: PUBLIC ResidentHeap.Alignment ¬ a1;  operationLocation: PUBLIC ResidentHeap.HeapLocation ¬ first64K;  -- PRIVATE variables  currentClient: NewRS232CFace.RS232CClientType ¬ noClient;  latchedStatus: NewRS232CFace.DeviceStatus ¬ nullStatus;  lineOn: BOOLEAN ¬ FALSE;  workListInUse: BOOLEAN ¬ FALSE;  -- PUBLIC PROCs  GetDeviceStatus: PUBLIC PROC [handle: Handle]    RETURNS [deviceStatus: NewRS232CFace.DeviceStatus] = {    IF handle # fcb OR fcb = NIL THEN RETURN[nullStatus] ELSE      BEGIN      deviceStatus ¬ Inline.BITOR[fcb.deviceStatus, latchedStatus];      latchedStatus ¬ Inline.BITAND[deviceStatus, latchedStatusMask]      END};   GetHandle: PUBLIC PROC     [lineNumber: NewRS232CFace.LineNumber, rs232cClient: NewRS232CFace.RS232CClientType]    RETURNS [handle: Handle] = {    IF lineNumber = 0 AND currentClient = noClient AND fcb # NIL THEN      BEGIN      currentClient ¬ rs232cClient;      handle ¬ fcb      END      ELSE handle ¬ NIL};         GetNextLine: PUBLIC PROC [lineNumber: NewRS232CFace.LineNumber]    RETURNS [nextLineNumber: NewRS232CFace.LineNumber] = {    RETURN[IF lineNumber = NewRS232CFace.nullLineNumber AND fcb # NIL      THEN 0 ELSE NewRS232CFace.nullLineNumber]};  Initialize: PUBLIC PROC [notify: WORD] = {    IF fcb # NIL THEN      BEGIN      fcb.upNotify ¬ notify;      fcb.stopAgent ¬ FALSE      END};   InitializeCleanup: PUBLIC PROC =    BEGIN    item: DeviceCleanup.Item;    savedUpNotify: BountyInputOutput.UpNotifyMaskType;    savedReceiveQueue, savedTransmitQueue: BountyInputOutput.QueueType;    savedParameterBlock: NewRS232CFace.ParameterRecord;    IF fcb = NIL THEN RETURN;    savedUpNotify ¬ fcb.upNotify;    savedReceiveQueue ¬ fcb.rxQueue;    savedTransmitQueue ¬ fcb.txQueue;    savedParameterBlock ¬ fcb.parameterBlock;    DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM	turnOff, kill =>	  BEGIN	  IF lineOn THEN	    BEGIN	    fcb.workListStatus ¬ inProgress;	    fcb.workList ¬ [abortReceive: TRUE];	    BountyInputOutput.NotifyIOP[fcb.workListDownNotify];	    THROUGH [0..LAST[CARDINAL]) UNTIL fcb.workListStatus # inProgress DO ENDLOOP;	    fcb.workListStatus ¬ inProgress;	    fcb.workList ¬ [abortTransmit: TRUE];	    BountyInputOutput.NotifyIOP[fcb.workListDownNotify];	    THROUGH [0..LAST[CARDINAL]) UNTIL fcb.workListStatus # inProgress DO ENDLOOP;	    fcb.workListStatus ¬ inProgress;	    fcb.workList ¬ [off: TRUE];	    BountyInputOutput.NotifyIOP[fcb.workListDownNotify];	    THROUGH [0..LAST[CARDINAL]) UNTIL fcb.workListStatus # inProgress DO ENDLOOP;	    lineOn ¬ FALSE	    END;	  fcb.stopAgent ¬ TRUE;	  BountyInputOutput.NotifyIOP[fcb.receiveDownNotify];	  BountyInputOutput.NotifyIOP[fcb.transmitDownNotify];	  BountyInputOutput.NotifyIOP[fcb.workListDownNotify];	  THROUGH [0..LAST[CARDINAL])	    UNTIL (fcb.rxStopped AND fcb.txStopped AND fcb.workListStopped) DO ENDLOOP;          savedUpNotify ¬ fcb.upNotify;          savedReceiveQueue ¬ fcb.rxQueue;          savedTransmitQueue ¬ fcb.txQueue;	  savedParameterBlock ¬ fcb.parameterBlock	  END;	turnOn =>	  BEGIN          fcb.upNotify ¬ savedUpNotify;          fcb.rxQueue.head ¬ savedReceiveQueue.head;          fcb.rxQueue.tail ¬ savedReceiveQueue.tail;          fcb.rxQueue.active ¬ savedReceiveQueue.active;          fcb.txQueue.head ¬ savedTransmitQueue.head;          fcb.txQueue.tail ¬ savedTransmitQueue.tail;          fcb.txQueue.active ¬ savedTransmitQueue.active;	  fcb.parameterBlock ¬ savedParameterBlock;	  fcb.workList ¬ [setParameters: TRUE];	  fcb.stopAgent ¬ FALSE;	  BountyInputOutput.NotifyIOP[fcb.receiveDownNotify];	  BountyInputOutput.NotifyIOP[fcb.transmitDownNotify];	  BountyInputOutput.NotifyIOP[fcb.workListDownNotify]	  END;	ENDCASE    ENDLOOP    END;  InitiateCommand: PUBLIC PROC [handle: Handle, command: NewRS232CFace.Command]     RETURNS [commandStatus: NewRS232CFace.CommandStatus] = {    IF handle # fcb OR fcb = NIL OR workListInUse THEN RETURN[rejected] ELSE      BEGIN      workListInUse ¬ TRUE;      fcb.workListStatus ¬ inProgress;      SELECT command FROM        abortReceive => fcb.workList ¬ [abortReceive: TRUE];        abortTransmit => fcb.workList ¬ [abortTransmit: TRUE];        breakOff => fcb.workList ¬ [breakOff: TRUE];        breakOn => fcb.workList ¬ [breakOn: TRUE];        getDeviceStatus => fcb.workList ¬ [getDeviceStatus: TRUE];        off => {fcb.workList ¬ [off: TRUE]; lineOn ¬ FALSE};        on => {fcb.workList ¬ [on: TRUE]; lineOn ¬ TRUE};	ENDCASE;      BountyInputOutput.NotifyIOP[fcb.workListDownNotify];      RETURN[inProgress]      END};    		  InitiateReceive: PUBLIC PROC [handle: Handle, operation: NewRS232CFace.OperationPtr]    RETURNS [transferStatus: NewRS232CFace.TransferStatus] = {    IF operation = NIL THEN RETURN[disaster] ELSE      BEGIN      iocb: SerialIOFaceBounty.SerialIOCBPtr = LOOPHOLE[operation];      iocb­ ¬ [operation­, 0, FALSE, receive];      IF handle # fcb OR fcb = NIL OR operation.dataBuffer = NIL THEN	BEGIN	iocb.status ¬ disaster;	iocb.dequeued ¬ TRUE;	RETURN[disaster]	END;      IF operation.bufferByteLength = 0 THEN	BEGIN	iocb.status ¬ success;	iocb.dequeued ¬ TRUE;	RETURN[success]	END;      IF BountyInputOutput.Enqueue[@fcb.rxQueue, iocb, SerialIOFaceBounty.serialLink]        THEN BountyInputOutput.NotifyIOP[fcb.receiveDownNotify];      RETURN[inProgress]      END}; 	  InitiateResetStatusBits: PUBLIC PROC    [handle: Handle, resetRecord: NewRS232CFace.ResetRecord]    RETURNS [NewRS232CFace.CommandStatus] = {    IF handle # fcb THEN RETURN[rejected] ELSE      BEGIN      latchedStatus ¬ Inline.BITAND[latchedStatus, Inline.BITNOT[resetRecord]];      RETURN[completed]      END};      InitiateSetControlBits: PUBLIC PROC    [handle: Handle, controlRecord: NewRS232CFace.ControlRecord]    RETURNS[NewRS232CFace.CommandStatus] = {    IF handle # fcb OR fcb = NIL OR workListInUse THEN RETURN[rejected] ELSE      BEGIN      workListInUse ¬ TRUE;      fcb.controlFlags ¬ controlRecord;      fcb.workListStatus ¬ inProgress;      fcb.workList ¬ [setControlBits: TRUE];      BountyInputOutput.NotifyIOP[fcb.workListDownNotify];      RETURN[inProgress]      END};      InitiateSetParameters: PUBLIC PROC    [handle: Handle, parameters: NewRS232CFace.ParameterHandle]     RETURNS [parameterStatus: NewRS232CFace.ParameterStatus] = {    IF handle # fcb OR fcb = NIL OR workListInUse THEN RETURN[rejected] ELSE      BEGIN      workListInUse ¬ TRUE;      fcb.parameterBlock ¬ parameters­;      fcb.workListStatus ¬ inProgress;      fcb.workList ¬ [setParameters: TRUE];      BountyInputOutput.NotifyIOP[fcb.workListDownNotify];      RETURN[inProgress]      END};  InitiateTransmit: PUBLIC PROC [handle: Handle, operation: NewRS232CFace.OperationPtr]    RETURNS [transferStatus: NewRS232CFace.TransferStatus] = {    IF operation = NIL THEN RETURN[disaster] ELSE      BEGIN      iocb: SerialIOFaceBounty.SerialIOCBPtr = LOOPHOLE[operation];      iocb­ ¬ [operation­, 0, FALSE, transmit];      IF handle # fcb OR fcb = NIL OR operation.dataBuffer = NIL THEN	BEGIN	iocb.status ¬ disaster;	iocb.dequeued ¬ TRUE;	RETURN[disaster]	END;      IF operation.bufferByteLength = 0 THEN	BEGIN	iocb.status ¬ success;	iocb.dequeued ¬ TRUE;	RETURN[success]	END;      MapFix[operation.dataBuffer, operation.bufferByteLength, FALSE];      IF BountyInputOutput.Enqueue[@fcb.txQueue, iocb, SerialIOFaceBounty.serialLink]        THEN BountyInputOutput.NotifyIOP[fcb.transmitDownNotify];      RETURN[inProgress]      END};    IsReviveProcNeeded: PUBLIC PROCEDURE [handle: Handle]    RETURNS [needed: BOOLEAN] =    BEGIN    RETURN[FALSE];    END;     PollCommand, PollSetControlBits: PUBLIC PROC [handle: Handle]    RETURNS [commandStatus: NewRS232CFace.CommandStatus] = {    IF handle # fcb OR fcb = NIL THEN RETURN[rejected] ELSE      BEGIN      IF fcb.workListStatus = inProgress THEN RETURN[inProgress];      workListInUse ¬ FALSE;      RETURN[completed]      END};      PollReceiveOrTransmit: PUBLIC PROC    [handle: Handle, operation: NewRS232CFace.OperationPtr]    RETURNS [bytesTransferred: CARDINAL, transferStatus: NewRS232CFace.TransferStatus] =    BEGIN    iocb: SerialIOFaceBounty.SerialIOCBPtr = LOOPHOLE[operation];    IF iocb = NIL OR iocb.status = inProgress THEN RETURN[0, inProgress];    IF NOT iocb.dequeued THEN      BEGIN      IF fcb # NIL THEN SELECT iocb.iocbType FROM        receive =>          BEGIN	  BountyInputOutput.Dequeue[@fcb.rxQueue, iocb, SerialIOFaceBounty.serialLink];	  IF iocb.actualLength > 0	    THEN MapFix[operation.dataBuffer, iocb.actualLength, TRUE];          END;        transmit => BountyInputOutput.Dequeue[@fcb.txQueue, iocb, SerialIOFaceBounty.serialLink];        ENDCASE;      iocb.dequeued ¬ TRUE      END;    RETURN[iocb.actualLength, iocb.status]    END;  PollResetStatusBits: PUBLIC PROC [handle: Handle]    RETURNS [NewRS232CFace.CommandStatus] = {    RETURN[completed]};    PollSetParameters: PUBLIC PROC [handle: Handle]    RETURNS [parameterStatus: NewRS232CFace.ParameterStatus] = {    IF handle # fcb OR fcb = NIL THEN RETURN[rejected] ELSE      BEGIN      IF fcb.workListStatus = inProgress THEN RETURN[inProgress];      workListInUse ¬ FALSE;      RETURN[fcb.workListStatus]      END};  QueueIsBad: PUBLIC PROCEDURE [handle: NewRS232CFace.Handle]     RETURNS [badQueue: BOOLEAN] =    BEGIN    RETURN[FALSE];    END;  ReleaseHandle: PUBLIC PROC [handle: Handle]    RETURNS [nilHandle: Handle] =    BEGIN    IF handle = fcb AND fcb # NIL THEN      BEGIN      IF lineOn THEN        BEGIN	fcb.workListStatus ¬ inProgress;        fcb.workList ¬ [off: TRUE];        BountyInputOutput.NotifyIOP[fcb.workListDownNotify];        lineOn ¬ FALSE	END;      currentClient ¬ noClient      END;    RETURN[NIL]    END;  ReviveInputQueue: PUBLIC PROCEDURE [handle: NewRS232CFace.Handle]     RETURNS[revived: BOOLEAN ¬ FALSE, skipped: CARDINAL ¬ 0] =    BEGIN    END;  -- PRIVATE PROCs  MapFix: PROC [bufferAddress: LONG POINTER, bufferLength: CARDINAL, dirty: BOOLEAN] =    BEGIN -- touch or dirty each page    lastAddress: LONG POINTER = bufferAddress + (bufferLength - 1) / bpw;    firstPage: Environment.PageNumber = Environment.PageFromLongPointer[bufferAddress];    lastPage: Environment.PageNumber = Environment.PageFromLongPointer[lastAddress];    d: UNSPECIFIED;    FOR page: Environment.PageNumber IN [firstPage..lastPage] DO      bufferAddress ¬ Environment.LongPointerFromPage[page];      d ¬ bufferAddress­;      IF dirty THEN bufferAddress­ ¬ d;    ENDLOOP    END;  END.LOG21-Sep-90 - JPM - Created. 1-Oct-90 - JPM - Fixed bug in PollReceiveOrTransmit (don't do MapFix if length is 0). 2-Oct-90 - JPM - Fixed bug in ReleaseHandle (must set currentClient to noClient). 9-Oct-90 - JPM - Changed Initialize and InitializeCleanup to work even when fcb = NIL.31-Oct-90 - JPM - Took out AbortQueue (agent does this now).28-Feb-92 - RSV - Added dummy procedures IsReviveProcNeeded, QueueIsBad and ReviveInputQueue.
-- EthernetHeadBounty.mesa - last edit:--  JPM		14-Nov-89 16:48:36-- Copyright (C) 1989 by Xerox Corporation.  All rights reserved.<< The following program was created in 1989 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  BountyInputOutput USING [Dequeue, Enqueue, GetFCBPtr, NotifyIOP, QueueType, UpNotifyMaskType],  DeviceCleanup USING [Await, Item, Reason],  Environment USING [bytesPerWord, LongPointerFromPage, PageFromLongPointer, PageNumber],  EthernetFace USING [GlobalStatePtr, Status],  EthernetIOFaceBounty USING [EthernetFCBType, EthernetIOCBPtr, EthernetIOCBType, ethernetLink],  HeadStartChain USING [Start],  HostNumbers USING [ProcessorID];  EthernetHeadBounty: PROGRAM   IMPORTS BountyInputOutput, DeviceCleanup, Environment, RemainingHeads: HeadStartChain   EXPORTS EthernetFace, HeadStartChain =   BEGIN  -- PUBLIC TYPEs  ControlBlockRecord: PUBLIC TYPE = EthernetIOFaceBounty.EthernetIOCBType;  DeviceHandle: PUBLIC TYPE = CARDINAL;  -- PRIVATE TYPE  ControlBlock: TYPE = LONG POINTER TO ControlBlockRecord;  -- constants  fcb: LONG POINTER TO EthernetIOFaceBounty.EthernetFCBType =    BountyInputOutput.GetFCBPtr[ethernet];  bpw: CARDINAL = Environment.bytesPerWord;  -- PUBLIC variables  globalStateSize: PUBLIC CARDINAL ¬ 0;  controlBlockSize: PUBLIC CARDINAL ¬    SIZE[EthernetIOFaceBounty.EthernetIOCBType] + fcb.agentBlockSize;  nullDeviceHandle: PUBLIC DeviceHandle ¬ LAST[CARDINAL];  hearSelf: PUBLIC BOOLEAN ¬ fcb.hearSelf;  -- PRIVATE variables  cleanupInitialized: BOOLEAN ¬ FALSE;  -- PUBLIC PROCs  AddCleanup: PUBLIC PROC [device: DeviceHandle] =    BEGIN    item: DeviceCleanup.Item;    savedStopAgent: BOOLEAN ¬ fcb.stopAgent;    savedReceiveUpNotify: BountyInputOutput.UpNotifyMaskType ¬ fcb.receiveUpNotify;    savedTransmitUpNotify: BountyInputOutput.UpNotifyMaskType ¬ fcb.transmitUpNotify;    savedReceiveQueue: BountyInputOutput.QueueType ¬ fcb.receiveQueue;    savedTransmitQueue: BountyInputOutput.QueueType ¬ fcb.transmitQueue;    savedProcessorID: HostNumbers.ProcessorID ¬ fcb.processorID;    IF cleanupInitialized OR device # 0 THEN RETURN;    cleanupInitialized ¬ TRUE;    DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM	turnOff, kill =>	  BEGIN	  IF NOT (savedStopAgent ¬ fcb.stopAgent) THEN	    BEGIN	    fcb.stopAgent ¬ TRUE;	    BountyInputOutput.NotifyIOP[fcb.receiveDownNotify];	    BountyInputOutput.NotifyIOP[fcb.transmitDownNotify]	    END;	  THROUGH [0..LAST[CARDINAL]) UNTIL (fcb.receiveStopped AND fcb.transmitStopped)	    DO ENDLOOP;          savedReceiveUpNotify ¬ fcb.receiveUpNotify;          savedTransmitUpNotify ¬ fcb.transmitUpNotify;          savedReceiveQueue ¬ fcb.receiveQueue;          savedTransmitQueue ¬ fcb.transmitQueue;	  savedProcessorID ¬ fcb.processorID	  END;	turnOn =>	  BEGIN          fcb.receiveUpNotify ¬ savedReceiveUpNotify;          fcb.transmitUpNotify ¬ savedTransmitUpNotify;          fcb.receiveQueue.head ¬ savedReceiveQueue.head;          fcb.receiveQueue.tail ¬ savedReceiveQueue.tail;          fcb.receiveQueue.active ¬ savedReceiveQueue.active;          fcb.transmitQueue.head ¬ savedTransmitQueue.head;          fcb.transmitQueue.tail ¬ savedTransmitQueue.tail;          fcb.transmitQueue.active ¬ savedTransmitQueue.active;	  fcb.processorID ¬ savedProcessorID;	  IF NOT (fcb.stopAgent ¬ savedStopAgent) THEN	    BEGIN	    BountyInputOutput.NotifyIOP[fcb.receiveDownNotify];	    BountyInputOutput.NotifyIOP[fcb.transmitDownNotify]	    END;	  END;	ENDCASE    ENDLOOP    END;  GetNextDevice: PUBLIC PROC [device: DeviceHandle]    RETURNS [DeviceHandle] = {    RETURN[IF device = nullDeviceHandle THEN 0 ELSE nullDeviceHandle]};  GetPacketLength: PUBLIC PROC [cb: ControlBlock] RETURNS [CARDINAL] = {    RETURN[IF cb = NIL THEN 0 ELSE (cb.actualLength + bpw - 1) / bpw]};  GetPacketsMissed: PUBLIC PROC [device: DeviceHandle] RETURNS [CARDINAL] = {    RETURN[IF device = 0 THEN fcb.packetsMissed ELSE 0]};  GetRetries: PUBLIC PROC [cb: ControlBlock] RETURNS [CARDINAL] = {    RETURN[IF cb = NIL THEN 0 ELSE cb.retries]};  GetStatus: PUBLIC PROC [cb: ControlBlock] RETURNS [status: EthernetFace.Status] =    BEGIN    IF cb = NIL OR cb.status = inProgress      THEN RETURN[pending];    IF NOT cb.dequeued THEN      BEGIN      SELECT cb.packetType FROM        receive =>          BEGIN	  BountyInputOutput.Dequeue[@fcb.receiveQueue, cb, EthernetIOFaceBounty.ethernetLink];	  MapFix[cb.bufferAddress, cb.actualLength, TRUE];          END;        transmit => BountyInputOutput.Dequeue[@fcb.transmitQueue, cb, EthernetIOFaceBounty.ethernetLink];        ENDCASE;      cb.dequeued ¬ TRUE      END;    RETURN[(SELECT cb.status FROM      completedOK => ok,      tooManyCollisions => tooManyCollisions,      badCRC => crc,      alignmentError => badAlignmentButOkCrc,      packetTooLong => packetTooLong,      badCRCAndAlignmentError => crcAndBadAlignment,      ENDCASE => otherError)]    END;  QueueInput: PUBLIC PROC [device: DeviceHandle, buffer: LONG POINTER, length: CARDINAL, cb: ControlBlock] =    BEGIN    IF cb = NIL THEN RETURN;    length ¬ length * bpw;    cb­ ¬ [buffer, length, 0, FALSE, receive];    IF device # 0 OR buffer = NIL OR length = 0 THEN      BEGIN      cb.status ¬ completedOK; -- don't have a meaningful error status for this case      cb.dequeued ¬ TRUE;      RETURN      END;    IF BountyInputOutput.Enqueue[@fcb.receiveQueue, cb, EthernetIOFaceBounty.ethernetLink]      THEN BountyInputOutput.NotifyIOP[fcb.receiveDownNotify];    END;  QueueOutput: PUBLIC PROC [device: DeviceHandle, buffer: LONG POINTER, length: CARDINAL, cb: ControlBlock] =    BEGIN    IF cb = NIL THEN RETURN;    length ¬ length * bpw;    cb­ ¬ [buffer, length, 0, FALSE, transmit];    IF device # 0 OR buffer = NIL OR length = 0 THEN      BEGIN      cb.status ¬ completedOK; -- don't have a meaningful error status for this case      cb.dequeued ¬ TRUE;      RETURN      END;    MapFix[buffer, length, FALSE];    IF BountyInputOutput.Enqueue[@fcb.transmitQueue, cb, EthernetIOFaceBounty.ethernetLink]      THEN BountyInputOutput.NotifyIOP[fcb.transmitDownNotify];    END;  RemoveCleanup: PUBLIC PROC [DeviceHandle] = {};  Start: PUBLIC --HeadStartChain.-- PROC =    {RemainingHeads.Start[]};  TurnOff: PUBLIC PROC [device: DeviceHandle] =    BEGIN    IF device # 0 THEN RETURN;    fcb.stopAgent ¬ TRUE;    BountyInputOutput.NotifyIOP[fcb.receiveDownNotify];    BountyInputOutput.NotifyIOP[fcb.transmitDownNotify];    UNTIL (fcb.receiveStopped AND fcb.transmitStopped) DO ENDLOOP    END;  TurnOn: PUBLIC PROC [device: DeviceHandle, host: HostNumbers.ProcessorID, inInterrupt: WORD, outInterrupt: WORD, globalState: EthernetFace.GlobalStatePtr] =    BEGIN    IF device # 0 THEN RETURN;    IF NOT fcb.stopAgent THEN      BEGIN      fcb.stopAgent ¬ TRUE;      BountyInputOutput.NotifyIOP[fcb.receiveDownNotify];      BountyInputOutput.NotifyIOP[fcb.transmitDownNotify];      THROUGH [0..LAST[CARDINAL]) UNTIL (fcb.receiveStopped AND fcb.transmitStopped)        DO ENDLOOP      END;    fcb.receiveQueue.head ¬ fcb.receiveQueue.tail ¬ fcb.receiveQueue.active ¬ NIL;    fcb.transmitQueue.head ¬ fcb.transmitQueue.tail ¬ fcb.transmitQueue.active ¬ NIL;    fcb.processorID ¬ host;    fcb.receiveUpNotify ¬ inInterrupt;    fcb.transmitUpNotify ¬ outInterrupt;    fcb.stopAgent ¬ FALSE;    BountyInputOutput.NotifyIOP[fcb.receiveDownNotify];    BountyInputOutput.NotifyIOP[fcb.transmitDownNotify]    END;  -- PRIVATE PROCs  MapFix: PROC [bufferAddress: LONG POINTER, bufferLength: CARDINAL, dirty: BOOLEAN] =    BEGIN -- touch or dirty each page    lastAddress: LONG POINTER = bufferAddress + (bufferLength - 1) / bpw;    firstPage: Environment.PageNumber = Environment.PageFromLongPointer[bufferAddress];    lastPage: Environment.PageNumber = Environment.PageFromLongPointer[lastAddress];    d: UNSPECIFIED;    FOR page: Environment.PageNumber IN [firstPage..lastPage] DO      bufferAddress ¬ Environment.LongPointerFromPage[page];      d ¬ bufferAddress­;      IF dirty THEN bufferAddress­ ¬ d;    ENDLOOP    END;  END.LOG 5-Jul-89 - JPM - Created. 7-Jul-89 - JPM - Added RemoveCleanup.11-Jul-89 - JPM - Handle packetTooLong status (in GetStatus).14-Jul-89 - JPM - Ensure fcb is initialized before hearSelf.15-Aug-89 - JPM - Use fcb variable to set controlBlockSize.21-Aug-89 - JPM - Fix bugs in handling length of buffers (procs supply word length, but IOCB wants byte length).26-Oct-89 - JPM - Clear queues in TurnOn.10-Nov-89 - JPM - Change TurnOff to wait for agent to stop.14-Nov-89 - JPM - Don't write to the queueLock field of either queue.
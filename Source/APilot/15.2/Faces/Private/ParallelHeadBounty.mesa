-- ParallelHeadBounty.mesa - last edit:--  JPM		23-Jan-90 13:46:14-- Copyright (C) 1989, 1990 by Xerox Corporation.  All rights reserved.<< The following program was created in 1989 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  BiParallelPortFace USING [CommandStatus, DeviceStatus, HardwareStatus, InitializationStatus, nullPortNumber, OperationPtr, Parameters, Port, PortType, Transfer, TransferStatus],  BountyInputOutput USING [Dequeue, Enqueue, GetFCBPtr, NotifyIOP, QueueType, UpNotifyMaskType],  DeviceCleanup USING [Await, Item, Reason],  Environment USING [Base, bitsPerWord, bytesPerWord, first64K, LongPointerFromPage, PageFromLongPointer, PageNumber],  HeadStartChain USING [Start],  ParallelIOFaceBounty USING [ParallelFCBType, ParallelIOCBPtr, ParallelIOCBType, parallelLink],  Zone USING [Alignment];  ParallelHeadBounty: PROGRAM   IMPORTS BountyInputOutput, DeviceCleanup, Environment, RemainingHeads: HeadStartChain   EXPORTS BiParallelPortFace, HeadStartChain =   BEGIN  -- copied TYPEs  CommandStatus: TYPE = BiParallelPortFace.CommandStatus;  Port: TYPE = BiParallelPortFace.Port;  -- constants  fcb: LONG POINTER TO ParallelIOFaceBounty.ParallelFCBType =    BountyInputOutput.GetFCBPtr[parallelPort];  maxNumberOfPorts: CARDINAL = Environment.bitsPerWord; -- more than needed  -- PUBLIC variables  operationSize: PUBLIC CARDINAL ¬ SIZE[ParallelIOFaceBounty.ParallelIOCBType];  operationAlignment: PUBLIC Zone.Alignment ¬ a1; -- any word boundary  operationLocation: PUBLIC Environment.Base ¬ Environment.first64K;  numberOfPorts: PUBLIC CARDINAL ¬ fcb.numberOfPorts;  maxBlockSizeInBytes: PUBLIC CARDINAL ¬ LAST[CARDINAL];  -- PRIVATE variables  cleanupInitialized: BOOLEAN ¬ FALSE;  portInUse: PACKED ARRAY [0..maxNumberOfPorts) OF BOOLEAN ¬ ALL[FALSE];  portWasReset: PACKED ARRAY [0..maxNumberOfPorts) OF BOOLEAN ¬ ALL[FALSE];  deviceWasReset: PACKED ARRAY [0..maxNumberOfPorts) OF BOOLEAN ¬ ALL[FALSE];  portTestData: WORD ¬ 0;  -- PUBLIC PROCs  BiParallelPortExists: PUBLIC PROC [port: Port] RETURNS [BOOLEAN] = {    RETURN[port < fcb.numberOfPorts]};  GetHardwareStatusBits: PUBLIC PROC [port: Port] RETURNS [    commandStatus: CommandStatus, hardwareStatus: BiParallelPortFace.HardwareStatus] = {    RETURN[unimplemented, [port, outputOnly, 0, 0]]};  GetNextAvailablePort: PUBLIC PROC [portType: BiParallelPortFace.PortType]    RETURNS [nextPort: Port] =    BEGIN    IF portType # outputOnly THEN RETURN[BiParallelPortFace.nullPortNumber];    FOR nextPort IN [0..fcb.numberOfPorts) DO      IF NOT portInUse[nextPort] THEN RETURN;    ENDLOOP;    RETURN[BiParallelPortFace.nullPortNumber]    END;  GetStatus: PUBLIC PROC [port: Port] RETURNS [    commandStatus: CommandStatus, deviceStatus: BiParallelPortFace.DeviceStatus] =    BEGIN    IF port >= fcb.numberOfPorts THEN RETURN[invalidParameter, []];    deviceStatus ¬ [      port: port, portType: outputOnly, select: portInUse[port],      portWasReset: portWasReset[port], deviceWasReset: deviceWasReset[port],      statusIsUpToDate: TRUE, testResultIsUpToDate: TRUE];      -- and other fields default    portWasReset[port] ¬ deviceWasReset[port] ¬ FALSE;    RETURN[ready, deviceStatus]    END;  GetTestResult: PUBLIC PROC RETURNS [returnPattern: WORD] = {    -- since we have no H/W loopback, fake the result so client is happy    RETURN[portTestData]};  Initialize: PUBLIC PROC [notify: WORD]    RETURNS [initStatus: BiParallelPortFace.InitializationStatus] =    BEGIN    IF NOT fcb.stopAgent THEN      BEGIN      fcb.stopAgent ¬ TRUE;      BountyInputOutput.NotifyIOP[fcb.downNotify];      THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP      END;    fcb.queue.head ¬ fcb.queue.tail ¬ fcb.queue.active ¬ NIL;    fcb.upNotify ¬ notify;    fcb.stopAgent ¬ FALSE;    RETURN[success]    END;  InitializeCleanup: PUBLIC PROC =    BEGIN    item: DeviceCleanup.Item;    savedUpNotify: BountyInputOutput.UpNotifyMaskType ¬ fcb.upNotify;    savedQueue: BountyInputOutput.QueueType ¬ fcb.queue;    IF cleanupInitialized THEN RETURN;    cleanupInitialized ¬ TRUE;    DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM	turnOff, kill =>	  BEGIN	  fcb.stopAgent ¬ TRUE;	  BountyInputOutput.NotifyIOP[fcb.downNotify];	  THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;	  savedUpNotify ¬ fcb.upNotify;	  savedQueue ¬ fcb.queue	  END;	turnOn =>	  BEGIN	  fcb.upNotify ¬ savedUpNotify;          fcb.queue.head ¬ savedQueue.head;          fcb.queue.tail ¬ savedQueue.tail;          fcb.queue.active ¬ savedQueue.active;	  fcb.stopAgent ¬ FALSE;	  BountyInputOutput.NotifyIOP[fcb.downNotify]	  END;	ENDCASE    ENDLOOP    END;  InitiateDeviceReset: PUBLIC PROC [port: Port]    RETURNS [commandStatus: CommandStatus] =    BEGIN    IF port >= fcb.numberOfPorts THEN RETURN[invalidParameter];    deviceWasReset[port] ¬ TRUE;    RETURN[ready]    END;  InitiatePortReset: PUBLIC PROC [port: Port]    RETURNS [commandStatus: CommandStatus] =    BEGIN    IF port >= fcb.numberOfPorts THEN RETURN[invalidParameter];    fcb.stopAgent ¬ TRUE;    BountyInputOutput.NotifyIOP[fcb.downNotify];    THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;    fcb.queue.active ¬ NIL;    FOR iocb: ParallelIOFaceBounty.ParallelIOCBPtr ¬ fcb.queue.head, iocb.nextIOCB      UNTIL iocb = NIL DO      IF iocb.status = inProgress THEN        IF iocb.port = port THEN	  BEGIN	  iocb.status ¬ aborted;	  BountyInputOutput.Dequeue[@fcb.queue, iocb, ParallelIOFaceBounty.parallelLink]	  END	  ELSE IF fcb.queue.active = NIL THEN fcb.queue.active ¬ iocb;    ENDLOOP;    fcb.stopAgent ¬ FALSE;    BountyInputOutput.NotifyIOP[fcb.downNotify];    portWasReset[port] ¬ TRUE;    RETURN[ready]    END;  InitiateTest: PUBLIC PROC [port: Port, diagnosticTestPattern: WORD]    RETURNS [commandStatus: CommandStatus] =    BEGIN    -- since we have no H/W loopback, fake the result so client is happy    portTestData ¬ diagnosticTestPattern;    RETURN[ready]    END;  InitiateTransfer: PUBLIC PROC [transfer: BiParallelPortFace.Transfer]      RETURNS [commandStatus: CommandStatus] =    BEGIN    iocb: ParallelIOFaceBounty.ParallelIOCBPtr = LOOPHOLE[transfer.operation];    IF transfer.port >= fcb.numberOfPorts OR transfer.transferMode # put OR      transfer.operation = NIL OR transfer.operation.dataBufferPtr = NIL      THEN RETURN[invalidParameter];    iocb.port ¬ transfer.port;    iocb.transferMode ¬ put;    iocb.controlOrData ¬ transfer.controlOrData;    iocb.nextIOCB ¬ NIL;    iocb.status ¬ inProgress;    iocb.bytesTransferred ¬ 0;    MapFix[transfer.operation.dataBufferPtr, transfer.operation.bufferByteLength];    IF BountyInputOutput.Enqueue[@fcb.queue, iocb, ParallelIOFaceBounty.parallelLink]      THEN BountyInputOutput.NotifyIOP[fcb.downNotify];    RETURN[inProgress]    END;  PollTransferStatus: PUBLIC PROC [port: Port, operation: BiParallelPortFace.OperationPtr]    RETURNS [transferStatus: BiParallelPortFace.TransferStatus, bytesTransferred: CARDINAL] =    BEGIN    iocb: ParallelIOFaceBounty.ParallelIOCBPtr = LOOPHOLE[operation];    IF iocb = NIL OR iocb.status = inProgress      THEN RETURN[inProgress, 0];    BountyInputOutput.Dequeue[@fcb.queue, iocb, ParallelIOFaceBounty.parallelLink];    transferStatus ¬ (SELECT iocb.status FROM      completed => success,      aborted => aborted,      ENDCASE => incomplete);    bytesTransferred ¬ iocb.bytesTransferred    END;  SetParameters: PUBLIC PROC [parameters: BiParallelPortFace.Parameters] = {    IF parameters.port < fcb.numberOfPorts      THEN portInUse[parameters.port] ¬ parameters.portInUse};  Start: PUBLIC --HeadStartChain.-- PROC =    {RemainingHeads.Start[]};  TestIfBiParallelPortExists: PUBLIC PROC [port: Port]    RETURNS [commandStatus: CommandStatus] = {    RETURN[ready]};  UpdateStatus: PUBLIC PROC [port: Port]    RETURNS [commandStatus: CommandStatus] = {    RETURN[ready]};  -- PRIVATE PROCs  MapFix: PROC [bufferAddress: LONG POINTER, bufferLength: CARDINAL] =    BEGIN -- touch each page    lastAddress: LONG POINTER = bufferAddress + (bufferLength - 1) / Environment.bytesPerWord;    firstPage: Environment.PageNumber = Environment.PageFromLongPointer[bufferAddress];    lastPage: Environment.PageNumber = Environment.PageFromLongPointer[lastAddress];    d: UNSPECIFIED;    FOR page: Environment.PageNumber IN [firstPage..lastPage] DO      bufferAddress ¬ Environment.LongPointerFromPage[page];      d ¬ bufferAddress­    ENDLOOP    END;  END.LOG 5-Jul-89 - JPM - Created.17-Nov-89 - JPM - Added queue initialization code to Initialize.23-Jan-90 - JPM - Fixed bug in InitiateTransfer (wrong comparison of port indices) and in GetStatus (need to set select = TRUE sometimes).
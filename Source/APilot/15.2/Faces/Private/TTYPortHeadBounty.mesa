-- File: TTYPortHeadBounty.mesa - last edit:-- JPM				29-May-91  9:48:22-- Daying Chen:OSBU North:Xerox 20-May-91 11:03:25-- Copyright (C) 1991 by Xerox Corporation. All rights reserved.DIRECTORY  DeviceCleanup USING [Await, Item, Reason],  BountyInputOutput USING [NotifyIOP, GetFCBPtr, DownNotifyMaskType, UpNotifyMaskType],  HeadStartChain USING [Start],  TTYPortIOFaceBounty,  TTYPortFace USING [DeviceStatus, Parameter, TransferStatus];     TTYPortHeadBounty: PROGRAM  IMPORTS DeviceCleanup, BountyInputOutput, RemainingHeads : HeadStartChain   EXPORTS HeadStartChain, TTYPortFace =  {  -- TTY Type definitions    TTYState: TYPE = {ON, OFF};      fcb: LONG POINTER TO TTYPortIOFaceBounty.TTYFCBType _    BountyInputOutput.GetFCBPtr[tty];       -- Errors  unimplementedParameter: ERROR = CODE;  unimplementedStopBit: ERROR = CODE;  unimplementedBaudRate: ERROR = CODE;   -- Parameters saved during world swapping:  --  savedFcb: TTYPortIOFaceBounty.TTYFCBType;  savedTTYDownNotify: BountyInputOutput.DownNotifyMaskType;  savedTTYUpNotify: BountyInputOutput.UpNotifyMaskType;  savedWorkList: TTYPortIOFaceBounty.TTYWorkListType;  savedParameter: TTYPortIOFaceBounty.TTYParameterType;  savedStatus: TTYPortIOFaceBounty.TTYStatusType;    ttyState: TTYState _ OFF;       << PUBLIC PROCEDURES>>   <<fill the transmit buffer and update the transmit buffer index>>  PutCommand: PUBLIC PROCEDURE [lineNumber: CARDINAL, data: CHARACTER]    RETURNS [stat: TTYPortFace.TransferStatus] =     {    IF lineNumber # 0 OR fcb = NIL THEN RETURN [notReady];    IF FcbTxBufferEmpty[] THEN      {            fcb.txBuffer.data[fcb.txBuffer.headIndex] ¬ data;      fcb.workList.transmit ¬ TRUE;      fcb.txBuffer.headIndex ¬ (fcb.txBuffer.headIndex + 1) MOD fcb.txBuffer.length;      IF (fcb.txBuffer.headIndex = (fcb.txBuffer.agentIndex + 1) MOD fcb.txBuffer.length) THEN        BountyInputOutput.NotifyIOP [fcb.ttyDownNotify];      IF fcb.status.breakDetected THEN stat _ breakDetected      ELSE stat _ success;      }   ELSE      IF fcb.status.breakDetected THEN stat _ breakDetected     ELSE stat _ notReady;    }; -- PutCommand<<get a character from the receive buffer and update the receive buffer index>>  GetCommand: PUBLIC PROCEDURE [lineNumber: CARDINAL]    RETURNS [data: CHARACTER, stat: TTYPortFace.TransferStatus] =    {      IF lineNumber # 0 OR fcb = NIL THEN RETURN [NULL, notReady];      IF fcb.rxBuffer.full THEN          {         data _ fcb.rxBuffer.data;	 fcb.rxBuffer.full _ FALSE;	 stat _ (SELECT TRUE FROM          fcb.status.parityError => parityError,          fcb.status.framingError => asynchFramingError,          fcb.status.breakDetected => breakDetected,	  fcb.status.dataLost => dataLost,         ENDCASE => success);	 -- Clear dataLost flag after reporting it	 IF fcb.status.dataLost THEN	   fcb.status.dataLost _ FALSE;         }      ELSE          stat _ (SELECT TRUE FROM          fcb.status.parityError => parityError,          fcb.status.framingError => asynchFramingError,          fcb.status.breakDetected => breakDetected,         ENDCASE => notReady);     }; -- GetCommand<<This procedure is used to return a number which specifies the TTY channel.  Since only one TTY port is available on the machine the current implementation will always return 1>>  GetLineCount: PUBLIC PROCEDURE RETURNS [lineCount: CARDINAL] =    {    IF fcb = NIL THEN RETURN [0];    RETURN [1]        }; --  GetLineCount         <<This procedure is used to get the data transfer status.  It will map the status from ttyFcb.ttyStatus to the available DeviceStatus>>  GetStatus: PUBLIC PROCEDURE [lineNumber: CARDINAL]    RETURNS [stat: TTYPortFace.DeviceStatus] =    {    IF lineNumber # 0 OR fcb = NIL THEN RETURN [ [FALSE, FALSE, FALSE, FALSE] ];    stat.dataTerminalReady _fcb.status.DTR;    stat.readyToGet _ fcb.rxBuffer.full;    stat.readyToPut _  FcbTxBufferEmpty[];    stat.requestToSend _ fcb.status.RTS;    }; -- GetStatus<< turn off receive & transmit and reset buffer pointers >>    Off: PUBLIC PROCEDURE [lineNumber: CARDINAL] =    {    IF lineNumber # 0 OR fcb = NIL THEN RETURN;    ttyState _ OFF;    fcb.status.dataLost _    fcb.status.breakDetected _    fcb.status.parityError _    fcb.status.framingError _    fcb.status.DTR _    fcb.status.RTS _  FALSE;     fcb.rxBuffer.full _ FALSE;    fcb.txBuffer.headIndex _ fcb.txBuffer.agentIndex _0;    fcb.workList.close _ TRUE;    fcb.workList.workToBeDone _ TRUE;    BountyInputOutput.NotifyIOP [fcb.ttyDownNotify];    }; -- Off  <<enable receive & transmit >>    On: PUBLIC PROCEDURE [lineNumber: CARDINAL, mask: UNSPECIFIED] =    {        IF lineNumber # 0 OR fcb = NIL THEN RETURN;    ttyState _ ON;    fcb.ttyUpNotify _ mask;    fcb.workList.open _ TRUE;    fcb.workList.workToBeDone _ TRUE;    BountyInputOutput.NotifyIOP [fcb.ttyDownNotify];    }; -- On    <<This procedure is used to send a break across the specified TTYPort line>>  SendBreak: PUBLIC PROCEDURE [lineNumber: CARDINAL] =    {    IF lineNumber # 0 OR fcb = NIL THEN RETURN;    fcb.workList.sendBreak _ TRUE;    fcb.workList.workToBeDone _ TRUE;    BountyInputOutput.NotifyIOP [fcb.ttyDownNotify];    }; -- SendBreak      << This procedure is used to set the parameters needed for the communication between mesa processor and TTY terminal.  When this proc is called tty Parameter in fcb will be modified by the TTYHead.  Then the TTYHead will issue a ttyDownNotify to inform the TTYAgent>>    SetParameter: PUBLIC PROCEDURE [lineNumber: CARDINAL, parameter: TTYPortFace.Parameter] =    {    IF lineNumber # 0 OR fcb = NIL THEN RETURN;    WITH parameter SELECT FROM       -- rx & tx set to the same char length       characterLength	=> { fcb.parameter.charLength _ (SELECT characterLength FROM		 	 	   lengthIs5bits => lengthIs5bits,				   lengthIs6bits => lengthIs6bits,       				   lengthIs7bits => lengthIs7bits,				   lengthIs8bits => lengthIs8bits,				   ENDCASE => ERROR unimplementedParameter);			   };			          clearToSend	=> {       				fcb.parameter.CTS _ clearToSend;			   };              dataSetReady	=> {       				fcb.parameter.DSR _ dataSetReady;			   };              lineSpeed	=> { fcb.parameter.lineSpeed _ (SELECT lineSpeed FROM       				   bps50 	=> bps50,					   bps75 	=> bps75,				   bps110 	=> bps110,				   bps150 	=> bps150,				   bps300 	=> bps300,				   bps600 	=> bps600,				   bps1200 	=> bps1200,				   bps1800 	=> bps1800,				   bps2000 	=> bps2000,				   bps2400 	=> bps2400,				   bps3600 	=> bps3600,				   bps4800 	=> bps4800,				   bps7200 	=> bps7200,				   bps9600 	=> bps9600,				   bps19200 	=> bps19200,				   ENDCASE	=> ERROR unimplementedBaudRate);			    };			          parity		=> { fcb.parameter.parity _ (SELECT parity FROM       				   none => none,				   odd 	=> odd,				   even => even,				   ENDCASE => ERROR unimplementedParameter);			   };			          stopBits		=> { fcb.parameter.stopBits _ (SELECT stopBits FROM       				   none 		=> ERROR unimplementedStopBit,       				   one	 		=> one,				   oneAndHalf	 	=> oneAndHalf,				   two	 		=> two,				   ENDCASE		=> ERROR unimplementedParameter);			   };       ENDCASE 		=> RETURN;         fcb.workList.setParam _ TRUE;    fcb.workList.workToBeDone _ TRUE;    BountyInputOutput.NotifyIOP [fcb.ttyDownNotify];    }; -- SetParameter  << PRIVATE PROCs >>    FcbTxBufferEmpty: PROCEDURE[] RETURNS [BOOLEAN] =     {RETURN[(fcb.txBuffer.headIndex + 1) MOD fcb.txBuffer.length # fcb.txBuffer.agentIndex]    }; -- FcbTxBufferEmpty      InitializeCleanup: PROCEDURE =    {    item: DeviceCleanup.Item;    reason: DeviceCleanup.Reason;    i: CARDINAL _ 0;    DO      reason _ DeviceCleanup.Await[@item];      IF ttyState = ON THEN        SELECT reason FROM 	  turnOff, kill =>	    {	    savedTTYDownNotify _ fcb.ttyDownNotify;	    savedTTYUpNotify _ fcb.ttyUpNotify;	    savedWorkList _ fcb.workList;	    savedParameter _ fcb.parameter;	    savedStatus _ fcb.status;            fcb.workList.close _ TRUE;	    fcb.workList.workToBeDone _ TRUE;	    BountyInputOutput.NotifyIOP [fcb.ttyDownNotify];	    };  	  turnOn =>	    {	   fcb.ttyDownNotify _ savedTTYDownNotify;	    fcb.ttyUpNotify _ savedTTYUpNotify;	    fcb.workList _ savedWorkList;	    fcb.parameter _ savedParameter;	    fcb.status _ savedStatus;	    fcb.workList.open _ TRUE;	    fcb.workList.workToBeDone _ TRUE;	    BountyInputOutput.NotifyIOP [fcb.ttyDownNotify];	    };	  disconnect => NULL;  -- turnOff was already called	  ENDCASE;	ENDLOOP;        }; -- InitializeCleanup      << Start Chain >>    Start: PUBLIC PROC = { RemainingHeads.Start[] }; -- Start    << Mainline code >>  IF fcb # NIL THEN InitializeCleanup [];  }...  LOG  2-Oct-90 17:16:44   dchen    	Created file.  5-Nov-90 15:36:32   dchen    	modified rxBuffer to sigle character. 20-May-91 11:03:25   dchen    	added tests for fcb = NIL. 29-May-91  9:48:22	JPM	Don't call InitializeCleanup if fcb = NIL.  	
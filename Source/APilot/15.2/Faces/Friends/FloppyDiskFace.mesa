-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- FloppyDiskFace.mesa (Jan-16-1985 D.DxS  )--  Added deletedData to StatusDIRECTORY  Device USING [Type],  Environment USING [Byte],  Zone USING [Alignment];FloppyDiskFace: DEFINITIONS =  BEGIN  -- Devices  DeviceHandle: TYPE [1];  GetNextDevice: PROC [previous: DeviceHandle] RETURNS [next: DeviceHandle];  --Enumerates all devices for the FloppyDiskFace.  nullDeviceHandle: READONLY DeviceHandle;  --Start and end value for enumeration.  -- Disk context (set by client)  Context: TYPE = MACHINE DEPENDENT RECORD [    protect(0:0..0):       BOOLEAN,                   --Software write protect available to the client.  The actual write protect status is a logical OR of this variable and the physical signal being returned from the drive.    format(0:1..1):        Format,         density(0:2..2):       Density,    sectorLength(0:3..15): SectorLength];  Format: TYPE = MACHINE DEPENDENT {IBM, Troy};       --Client's selection of the format type; either an IBM compatible format (which includes STAR), or the Xerox 850 (Troy) format.  Density: TYPE = MACHINE DEPENDENT {single, double}; --Selection of either FM (single density) or MFM (double density) recording. This is an available selection when formatting a new diskette. When accessng a previously recorded diskette, the client must provide the correct setting. (Note that track00 on IBM format 8" diskettes and all tracks of Troy format diskettes will be single density.)  SectorLength: TYPE = [0..1024);                     --Length in words of the sectors on the current track. The value must come from a valid set determined by the implementation; generally, this set includes {64, 128, 256, 512} for IBM format and {1022} for Troy format.  SetContext: PROC [device: DeviceHandle, context: Context] RETURNS [ok: BOOLEAN];  --Sets context as defined above and returns a BOOLEAN indicating whether the setting was accepted.  GetContext: PROC [device: DeviceHandle] RETURNS [context: Context];  --Returns the current settings of the context.  -- Device attributes (supplied to client)  Attributes: TYPE = MACHINE DEPENDENT RECORD [    type(0):                     Device.Type,      --type of drive (defined in DeviceTypes)    numberOfCylinders(1):        CARDINAL,         --Number of cylinders available for recording on the drive connected to the controller.    numberOfHeads(2:0..7):       Environment.Byte, --Number of read/write heads available for recording on the drive connected to the controller.    maxSectorsPerTrack(2:8..15): Environment.Byte, --Maximum number of sectors per track (based on context setting)    formatLength(3):             CARDINAL,         --Length in words of the buffer that the client must supply in order to format a track.    ready(4:0..0):		 BOOLEAN,          --Whether drive is ready (contains a diskette)    diskChange(4:1..1):		 BOOLEAN,          --Whether drive has gone not ready since last successful operation (use DiskChangeClear to reset)    twoSided(4:2..2):		 BOOLEAN,          --(If ready=TRUE) Whether diskette currently installed has data on both sides    busy(4:3..3):		 BOOLEAN,          --Whether drive is busy (operation in progress)    unused(4:4..15):             [0..7777B) ¬ 0];    GetDeviceAttributes: PROC [device: DeviceHandle] RETURNS [attributes: Attributes];  --Returns attributes as defined above.  -- Formatting (not all devices are capable of formatting multiple tracks)  MaxTracksPerFormatOperation: PROCEDURE [device: DeviceHandle] RETURNS [maxTracks: CARDINAL];  -- largest track count that can be supplied for formatting  -- Operations  -- An operation is required for all IO.    -- if function IN [readSector..writeDeletedSector]) the count is taken to be the number of sectors in the IO operation.  if function=formatTrack, diskAddress.sector is ignored and count is taken to be a track count.  -- (there are some free bits if ever needed.  DO NOT expand past 8 words)  -- Operations must live in the first 64K and must be operationAlignment word  -- aligned.  Clients should allocate storage of operationBlockLength words for Operations,  -- and use the first SIZE[Operation] words for the actual operation.  -- The remaining storage is used by the Head in device dependent fashion.  operationBlockLength:	READONLY CARDINAL;  operationAlignment:	READONLY Zone.Alignment;  OperationPtr: TYPE = LONG POINTER TO Operation;  Operation: TYPE = MACHINE DEPENDENT RECORD [    device(0):                    DeviceHandle,    function(1):                  Function,    address(2):                   DiskAddress,  -- ignored if nop.  Sector is ignored in formatTrack operations.    dataPtr(4):                   LONG POINTER, -- ignored if nop    incrementDataPointer(6:0..0): BOOLEAN,      -- ignored if nop, formatTrack    tries(6:1..15):               Tries,        -- Indication of how hard the Face should retry the operation in the presence of errors.  Increasing values of tries indicates that non-decreasing effort should be expended in retrying the failing operation.  Retries include device specific recovery (recalibrates, ...)    count(7):                     CARDINAL];    -- ignored if nop, readID.  Number of tracks to format if formatTrack (must not exceed MaxTracksPerFormatOperation); number of sectors to transfer otherwise.  Function: TYPE = MACHINE DEPENDENT {    nop,                 --Does not transfer any data but does create an asychronous operation and returns a valid endng status.    readSector,          --Reads one or more sectors from the diskette starting at the specified disk address.    writeSector,         --Writes one or more sectors with a data addres mark starting at the specified disk address.    writeDeletedSector,  --Writes one or more sectors with a deleted data addres mark starting at the specified disk address.    readID,              --Reads first encountered record ID from the specified disk address (the value of sector in the disk address is ignored).    formatTrack};        --format one or more tracks starting at the specified disk cylinder & head  DiskAddress: TYPE = MACHINE DEPENDENT RECORD [    cylinder(0):       CARDINAL,           --must be IN [0..numberOfCylinders)    head(1:0..7):      Environment.Byte,   --must be IN [0..numberOfHeads)    sector(1:8..15):   Environment.Byte];  --must be IN [1..maxSectorsPerTrack]  Tries: TYPE = [1..400B];  SuggestedTries: PROCEDURE [device: DeviceHandle] RETURNS [tries: Tries];  -- suggested number of tries for standard recovery algorithm for that device  Initiate: PROC [operationPtr: OperationPtr] RETURNS [status: Status];  --Used to create asynchronous operations from the Function set.  The status reflects any errors preventing the operation from being performed.    Poll: PROC [operationPtr: OperationPtr] RETURNS [status: Status, retriedCount: CARDINAL];  --Checks status of an asynchronous operation.  Status: TYPE = MACHINE DEPENDENT {    inProgress, -- operation is not yet complete    goodCompletion, -- operation has completed normally    diskChange, -- drive has gone not ready since last successful operation (use DiskChangeClear to reset, then resubmit operation if desired)    notReady, -- drive is not ready    cylinderError, -- can't locate specified cylinder    deletedData, -- The sector contained a deleted data address mark.    recordNotFound, -- can't find record for specified disk address    headerError, -- bad checksum in header    dataError, -- bad checksum in data    dataLost, -- sector contained more data than expected (from context)    writeFault, -- disk is write-protected (hardware or from context)    memoryError, -- dataPtr does not point to valid memory (not resident, too small, write-protected, etc.)    invalidOperation, -- operation does not make sense    aborted, -- Reset has been called    otherError}; -- unexpected software or hardware problem  CompletionStatus: TYPE = Status[goodCompletion..LAST[Status]]; -- operation is complete, can be deallocated or resubmitted  GetLogStatus: PROC [operationPtr: OperationPtr] RETURNS [logStatus: LogStatus];  --Gives more complete status information to be logged in case of error  LogStatus: TYPE = LONG DESCRIPTOR FOR ARRAY OF UNSPECIFIED;  -- Other device procedures    DiskChangeClear: PROC [device: DeviceHandle];  --Clears the disk change status.  Reset: PROC [device: DeviceHandle];  --Stops all processing being done by the Head, causing it to abort all queued operations, and sets the hardware to a startup state.  -- Initialization routines (these should be called once only, and before any other procedures)  Initialize: PROC [notify: WORD, initialAllocation: LONG POINTER];  --Provides information to the device face implementation that will be used internally.  initialAllocationLength: READONLY CARDINAL;  --Length in words of a block of resident memory allocated for internal use by the device face implementation.  This storage should also be operationAlignment word aligned.  If initialAllocationLength is 0, initialAllocation may be NIL.  InitializeCleanup: PROC;  --Initializes procedures used during device startup and shutdown.  END.	-- of FloppyDiskFace27-Jul-84 10:13:54 JPM      Create from SA800Face15-Aug-84 11:45:23 JPM      Modified per Allen AWL       suggestions; added retriedCount to Poll; changed LogStatus to LONG DESCRIPTOR (so can be variable size)
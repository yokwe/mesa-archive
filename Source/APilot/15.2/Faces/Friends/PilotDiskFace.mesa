-- Copyright (C) 1981, 1982, 1983, 1986 and 1987 by Xerox Corporation. All rights reserved. -- Copyright (C) 1988 by Fuji Xerox Co., Ltd. Tokyo, Japan. All rights reserved.-- PilotDiskFace.mesa ( 8-Oct-88 23:20:18 By: MN)-- Problems/bugs-- There is only one operation size for all controllers.  We would have to give --   up the ability for a device to be processed by the head's choice of--   controller in order to potentially save operation space.-- Note that heads contain no protection against concurrent calls from clients.--   It is the client's responsibility to protect the head even when there are--   multiple processes potentially calling it.-- Note that Heads may depend upon order of MACHINE DEPENDENT enumerateds--   within this definition.  They shoud not be messed with lightly.DIRECTORY  Device USING [Type],  Environment USING [Base, wordsPerPage],  Zone USING [Alignment];PilotDiskFace: DEFINITIONS =  BEGIN  -- Controllers  ControllerHandle: TYPE [1];  GetNextController: PROC [ControllerHandle] RETURNS [ControllerHandle];  nullControllerHandle: READONLY ControllerHandle;  -- Devices  DeviceHandle: TYPE [1];  GetNextDevice: PROCEDURE [DeviceHandle] RETURNS [DeviceHandle];  nullDeviceHandle: READONLY DeviceHandle;  -- Device-related Initialization  DeterminationMode: TYPE = {quickReadOnly, longReadOnly, writeEnabled};  DetermineDiskShape: PROCEDURE [    device: DeviceHandle, operation: OperationPtr, mode: DeterminationMode,    buffer: LONG POINTER ¬ NIL] RETURNS [nowKnown: BOOLEAN];  -- "operation" must not be NIL.  -- If buffer is NIL and a buffer was needed, nowKnown = FALSE will be returned.  -- Disk structure  GetDeviceType: PROCEDURE [DeviceHandle] RETURNS [Device.Type];  GetDeviceAttributes: PROCEDURE [DeviceHandle]    RETURNS [cylinders, movingHeads, fixedHeads, sectorsPerTrack: CARDINAL];  -- Before DetermineDiskShape on this device returns TRUE, some or all attributes may return value=unknown.  unknownAttribute: CARDINAL = LAST[CARDINAL];  DiskAddress: TYPE = MACHINE DEPENDENT RECORD [    cylinder(0): CARDINAL, head(1:0..7): [0..256), sector(1:8..15): [0..256)];    -- Page structure  headerSize: CARDINAL [2..2] = SIZE[DiskAddress];  dataSize: CARDINAL [256..256] = Environment.wordsPerPage;    -- Format structure    FormattingSpec: TYPE =    LONG DESCRIPTOR FOR READONLY ARRAY OF Command;    GetDriveInfo: PROCEDURE [DeviceHandle]    RETURNS [      firstPageOfInitialMicrocode: DiskAddress,      lastPageOfInitialMicrocode: DiskAddress,      firstPilotPage: DiskAddress,      formattingSpec: FormattingSpec,      formattingAlignment: FormattingUnit];    << The initial microcode area of the disk spans          firstPageOfInitialMicrocode through lastPageOfInitialMicrocode.	  No Pilot data may go in that area of the disk.  This area is guaranteed	  to be past track zero fo the disk and before firstPilotPage on the disk.	  Thus it restricts a Pilot disk to be:	  	  ----------------------------------------------------------------------	  | Track Zero | Unused | Initial Microcode | Unused | Logical volumes |	  ----------------------------------------------------------------------	  	  where the Unused areas may have zero length.  Note that this model is	  not fully general; the ultimate disk face will fix that.  This  model,	  however, is sufficiently general to handle all known, or anticipated,	  disks.	The first page available for Pilot logical volumes is firstPilotPage.	To format an area of the disk, the operations in formattingSpec must be	  executed, first formattingSpec[0], then formattingSpec[1], ...	  formattingSpec[LENGTH[formattingSpec]].	formattingAlignment specifies the granularity of formatting. arbitrary implies	  that any run of sectors may be formatted.  singleTrack implies that only	  whole tracks, beginning and ending on a track boundary, may be	  formatted.      >>  InitializeTrackBuffer: PROCEDURE [    device: DeviceHandle,    buffer: LONG POINTER, -- first(page aligned, resident) data address of track buffer    numberOfBuffers: CARDINAL];  -- Provides storage and notification mechanism for use on track buffering  --   for the specified device.  -- Should only be called after InitializeController,  --   and should only be called if PagesForTrackBuffering has returned  --   a maxNumberOfBuffers value other than 0.  -- Performing operations  Initiate: PROC [OperationPtr];  -- Note a new disk request, and arrange for eventual execution.  Note that  -- client does not have control over what controller services the operaton.  Poll: PROC [ControllerHandle]    RETURNS [status: Status, op: OperationPtr, retriedCount: CARDINAL];  -- Poll a particular controller.  Polling an idle controller will result in  -- [clientError, NIL] being returned with no other side effects.  Operations  -- will not necessarily come back in order submitted, and an error in a   -- particular operation does not abort the rest.  Status: TYPE = MACHINE DEPENDENT {    inProgress(0), goodCompletion(1), notReady(2), recalibrateError(3),    seekTimeout(4), headerCRCError(5), reserved6(6), dataCRCError(7),    headerNotFound(8), reserved9(9), dataVerifyError(10), overrunError(11),    writeFault(12), memoryError(13), memoryFault(14), clientError(15),    operationReset(16), otherError(17)};  -- reserved6 and reserved9 are provided for backwards compatibility.  -- Operation structure  -- Operations must live in the first 64K and must be operationAlignment  -- aligned and cannot cross page boundries.  -- Clients should allocate storage of operationSize for Operations,  -- and use the first SIZE[Operation] words for the actual operation.  -- The remaining storage is used by the Head in device dependent fashion.  operationSize: READONLY CARDINAL;  operationAlignment: READONLY Zone.Alignment;  OperationPtr: TYPE = LONG POINTER TO Operation;  Operation: TYPE = MACHINE DEPENDENT RECORD [    clientHeader(0): DiskAddress,  -- address of first sector of request    reserved1(2): LONG POINTER ¬ NIL,    -- reserved1 reserves space for backwards compatibility.  MUST BE NIL    dataPtr(4): LONG POINTER,  -- first (page aligned) data address of operation    incrementDataPtr(6:0..0): BOOLEAN,  -- if TRUE, add wordsPerPage to dataPtr    -- after each successful data write    enableTrackBuffer(6:1..1): BOOLEAN ¬ FALSE,    command(6:2..7): Command,  -- six bits for backward compatibility    tries(6:8..15): Tries,      -- Indication of how hard the Face should retry the operation in the presence      -- of errors.  Increasing values of tries indicates that non-decreasing      -- effort should be expended in retrying the failing operation.  Retries      -- include device specific recovery (ECC, recalibrates, ...)    pageCount(7): CARDINAL,  -- sectors remaining for this operation.      deviceStatus(10B): RECORD [a, b: UNSPECIFIED] ¬ NULL,    diskHeader(12B): DiskAddress ¬ NULL,  -- readHeader commands put header here.    device(14B): DeviceHandle];  PagesForTrackBuffering: PROCEDURE [device: DeviceHandle]    RETURNS [pagesPerBuffer: CARDINAL, maxNumberOfBuffers: CARDINAL];  -- Informs client of the interface what support exists for track buffering.  -- maxNumberOfBuffers = 0 is returned if track buffering is not supported.  -- Also returns maxNumberOfBuffers = 0 if the controller was not initialized  -- with all needed information (nakedCondition = NIL).    SuggestedTries: PROCEDURE [device: DeviceHandle] RETURNS [tries: Tries];    -- suggested number of tries for standard recovery algorithm for that device  Tries: TYPE = (0..400B];  Command: TYPE = MACHINE DEPENDENT {noOp(0), read(1), write(2), verify(3),    format(4), readHeader(5), readHeaderAndData(6), makeBootable(7),    makeUnbootable(8), getBootLocation(9), reserved10(10), reserved11(11),    reserved12(12), reserved13(13), reserved14(14), reserved15(15),    reserved16(16), reserved17(17), reserved18(18), reserved19(19)};  -- Use of reserved10 thru reserved19 are available for knowledgeable machine  -- dependent clients (eg. diagnostics) which use them with cooperating heads.  -- The reservedXX values are machine, and possibly device, dependent.  -- Formatting (not all devices are capable of formatting single pages\multiple tracks)  FormattingUnit: TYPE = {arbitrary, singleTrack, wholeDisk};  GetFormattingUnit: PROCEDURE [DeviceHandle] RETURNS [FormattingUnit];  -- Errors and error recovery  Recalibrate: PROCEDURE [DeviceHandle];  -- Force a recalibrate at the beginning of the next operation.  The Head may  -- also supply recalibrates as part of retrying.  Reset: PROCEDURE [ControllerHandle];  -- Restore a controller (as nearly as possible) to the state  -- existing immediately after InitializeController.  Clients may see operations  -- associated with a Reset controller coming back marked as operationReset.  -- Initialization of controllers  -- It is expected that clients using interrupts will have a process for each controller,  -- and should Initialize and InitializeCleanup for each of them.  GetControllerAttributes: PROCEDURE [ControllerHandle]    RETURNS [globalStateSize: CARDINAL];  GlobalStatePtr: TYPE = Environment.Base RELATIVE POINTER;  InitializeController: PROCEDURE [    controller: ControllerHandle, globalState: GlobalStatePtr, mask: WORD,    nakedCondition: LONG POINTER TO CONDITION ¬ NIL];  -- nakedCondition is ignored if the controller does not support track buffering.  -- Also, if nakedCondition = NIL, then track buffering will not be performed.  InitializeCleanup: PROCEDURE [controller: ControllerHandle];  END.....March 17, 1981  6:17 PM	PXM       Create from SA4000Face23-Apr-81  8:53:30	FXH       Revise for first cut at implementation.1-Jun-81 16:17:02	SXY      DeviceHandle: TYPE[1] => PilotDisk.Handle, Label: TYPE[10] => PilotDisk.Label, Poll returns actually retried count, tries: [0..400B) => (0..400B).5-Jun-81 15:23:41	CAJ    Rename Header/Label/DataError to *CRCError, Label/DataCheck to *VerifyError.15-Jun-81 17:47:12	SXY      Added names for return values of Poll, tries: (0..400B) => (0..400B].24-Jul-81 14:44:09	CAJ    Add device related initialization: DetermineDiskShape, DeterminationMode; delete SetDeviceAttributes, defaultAttribute. 6-Oct-82 13:49:35	AWL         Modify to remove dependencies upon Pilot interfaces - this should be independent of the operating system running on top of it.20-Oct-82 10:24:01	AWL         Added SuggestedTries, Tries.24-Nov-82  9:17:58	AWL         Added operationAlignment.17-Jan-83 15:11:16	AWL         Fix typo in SuggestedTries.26-Sep-84  2:47:13	DEG   Action: Added copyright notice and rebuild for 11.1 release.27-May-86 13:02:29	ETN         Eliminate Labels.  Add bootFileOp and special to 10-Jun-86 12:10:19	ETN         Eliminate just added Operation.bootFileOp and Operation.special.   Redo Command as an enumerated.  Fold in PilotDiskFaceExtras.20-Jun-86 10:18:56	DMP         Eliminate all mention of labels.  Make operationAlignment a READONLY constant   exported by the head, rather than defined here.  Correct folding in of   PilotDiskFaceExtras 2-Jul-86 15:57:11	DMP         Change type of Operation.reserved1 from LONG CARDINAL to LONG POINTER 8-Jul-86 13:59:54	DMP         Set default initialization of Operation.reserved1 to NIL23-Apr-87 13:45:56	SPL         Added wholeDisk to FormattingUnit TYPE definition 8-Oct-88 23:20:13	MN   Changed Operation.unused to enableTrackBuffer   Added PagesForTrackBuffering and InitializeTrackBuffer   Added nakedCondition to InitializeController
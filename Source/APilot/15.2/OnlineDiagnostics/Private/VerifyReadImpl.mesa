--VerifyReadImpl.mesa--Last edited on  9-Dec-87 18:02:16 by RK--Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY  Environment		USING [PageFromLongPointer, Base, first64K, Byte],  FloppyDiskFace	USING [DeviceHandle, DiskAddress, Status,  			       DiskChangeClear, operationBlockLength, 			       OperationPtr, operationAlignment, Function],  FloppyChannel		USING [GetHandle],  FloppyTapeExtras	USING [GetNextFloppyTapeDrive, nullDrive],  Inline		USING [LongDivMod, LongMult],  OnlineDiagnosticsExtraExtras USING [LookForAbortProc],  ResidentHeap		USING [MakeNode, FreeNode],  Space			USING [PageCount, Interval, nullInterval, Allocate,  		               Deallocate, InsufficientSpace, Error],  SpecialFloppyChannel  USING [DoDirectIO],  SpecialFloppyChannelExtras  USING [GetDeviceHandle],  VM			USING [Unmap, ScratchMap],  Zone			USING [Status],  VerifyRead		USING [VRResultType, EntryDispType, ErrorLog,   			       VRErrorType, maxErrors, maxTries, BadSectorTable]; VerifyReadImpl: PROGRAM  IMPORTS     FloppyDiskFace,    FloppyChannel,    FloppyTapeExtras,    SpecialFloppyChannel,    SpecialFloppyChannelExtras,    Inline,    Space,    Environment,    VM,    ResidentHeap  EXPORTS    VerifyRead =BEGIN--Globals  wordsPerPage: CARDINAL = 256;  sectorsPerTrack: CARDINAL = 32;  sectorCountForStreaming: CARDINAL = 65;  stream7FirstTrack: CARDINAL = 1470;  stream7ThirdTrack: CARDINAL = 1472;  stream6FirstTrack: CARDINAL = 1225;  stream6ThirdTrack: CARDINAL = 1227;  gsp: Environment.Base RELATIVE POINTER;  result: FloppyDiskFace.Status;  retryCount: CARDINAL;  tapeAddress: FloppyDiskFace.DiskAddress;  failedAddress: FloppyDiskFace.DiskAddress;  pageCount: Space.PageCount;  spaceInterval: Space.Interval;  op: FloppyDiskFace.OperationPtr;  runCount: CARDINAL;  logPtr: LONG POINTER TO VerifyRead.ErrorLog;  bSTablePtr: LONG POINTER TO VerifyRead.BadSectorTable;  ErrorType: TYPE = {soft, hard, hardware};  Error: ERROR[error: ErrorType] = CODE;  maxErrors: CARDINAL = VerifyRead.maxErrors;  maxTries: CARDINAL = VerifyRead.maxTries;  VRError: PUBLIC ERROR[error: VerifyRead.VRErrorType] = CODE;  lookForUserAbort: OnlineDiagnosticsExtraExtras.LookForAbortProc;  --Procedures  VerifyReadOperation: PUBLIC PROCEDURE [    errorLogPtr: LONG POINTER TO VerifyRead.ErrorLog,    badSectorTablePtr: LONG POINTER TO VerifyRead.BadSectorTable,    lookForAbort: OnlineDiagnosticsExtraExtras.LookForAbortProc]    RETURNS[vrResult: VerifyRead.VRResultType] =    BEGIN    --Assume retention done by calling procedure.    --Allocate space and declare variables    logPtr ¬ errorLogPtr;    bSTablePtr ¬ badSectorTablePtr; 	    pageCount ¬ sectorCountForStreaming;    spaceInterval ¬ CreateResidentBuffer[pageCount];    IF spaceInterval = Space.nullInterval THEN VRError[allocBug];    op ¬ AllocIOCB[FloppyDiskFace.operationBlockLength];    op.device ¬ SpecialFloppyChannelExtras.GetDeviceHandle[    		FloppyChannel.GetHandle[		FloppyTapeExtras.GetNextFloppyTapeDrive[		FloppyTapeExtras.nullDrive]]];    tapeAddress ¬ [0,0,1];    lookForUserAbort ¬ lookForAbort;         --Do DiskChangeClear     FloppyDiskFace.DiskChangeClear[op.device];        --Main routine to read sectors on streams 6,7      BEGIN	ENABLE	--if error is encountered, CONTINUE meant to exit END.	  Error => SELECT error FROM	    soft   =>  {vrResult ¬ tooManySoftError;	    	        CONTINUE};	    hard   =>  {vrResult ¬ hardReadError;	    	        CONTINUE};	    hardware =>{vrResult ¬ hardwareError;	    		CONTINUE};	    ENDCASE;      DoOperation[];      vrResult ¬ success;  --this line should not be executed if Error raised.      END;        --Deallocate storage    DeAllocIOCB[op];    DestroyResidentBuffer[spaceInterval];    END;  --VerifyReadOperation      DoOperation: PROCEDURE [] =    BEGIN    --internal procedure    DoIO: PROCEDURE[passOne: BOOLEAN, startTrack: CARDINAL] =       BEGIN            tapeAddress ¬ [startTrack,0,1];      runCount ¬ sectorCountForStreaming;      FOR i:CARDINAL IN [1..61]		--61 = 245 tracks/4 tracks per IO	DO	SetUpOper[count: runCount];	[result, retryCount,] ¬ SpecialFloppyChannel.DoDirectIO[op];	ErrorHandling[];	tapeAddress.cylinder ¬ tapeAddress.cylinder + 4;	tapeAddress.sector ¬ 1;	ENDLOOP;      IF passOne THEN	BEGIN	runCount ¬ sectorsPerTrack; 	--Only one track left	SetUpOper[count: runCount];	[result, retryCount,] ¬ SpecialFloppyChannel.DoDirectIO[op];	ErrorHandling[];	END;      END;  --DoIO    userAbort: BOOLEAN;    ClearLog[];     DoIO[TRUE,  stream7FirstTrack];	--Stream 7 pass 1    IF (userAbort ¬ lookForUserAbort[]) = TRUE THEN  VRError[abort];    DoIO[TRUE,  stream6FirstTrack];	--Stream 6 pass 1    IF (userAbort ¬ lookForUserAbort[]) = TRUE THEN  VRError[abort];    DoIO[FALSE, stream7ThirdTrack];     --Stream 7 pass 2    IF (userAbort ¬ lookForUserAbort[]) = TRUE THEN  VRError[abort];    DoIO[FALSE, stream6ThirdTrack];	--Stream 6 pass 2    END;  --DoOperation          ClearLog: PROCEDURE [] =    BEGIN    logPtr.count ¬ 0;    FOR i:CARDINAL IN [1..maxErrors]      DO      logPtr.entry[i].sector ¬ 0;      logPtr.entry[i].tries ¬ 0;      ENDLOOP;    END;  --ClearLog      ErrorHandling: PROCEDURE [] =    BEGIN    --if no error, do data compare    --if error, does not do data compare for this IOCB    -- if soft error, check bad page table.    --  if bad page, return    --  if not bad page, log and do retries.    --   if retries success, soft error, if fail hard read error    -- for all errors, there is no mechanism to finish    --  reading sectors remaining in the iocb    -- if hardware error, log, and signal hardware return.    failedSector: LONG CARDINAL;    countDone: CARDINAL;    IF result = goodCompletion THEN DoCompare[]    ELSE       BEGIN      countDone ¬ runCount - op.count;      failedSector ¬ TapeAddressToSector[tapeAddress] + countDone;      failedAddress ¬ SectorToTapeAddress[failedSector];      IF result = otherError THEN         BEGIN	Log[FALSE, hardware];	--DoRetention[];	DoRetries[];	END      ELSE	IF result = cylinderError OR	   result = recordNotFound OR	   result = headerError OR	   result = dataError THEN 	  BEGIN	  IF CheckBPTable[failedSector] THEN RETURN;	  Log[FALSE, soft];	  DoRetries[];   	  IF logPtr.count = maxErrors THEN Error[soft]; --too many soft errors	  END	ELSE	  BEGIN          Log[FALSE, hardware];          Error[hardware];	  END;      END;    END;  --ErrorHandling      DoRetries: PROCEDURE [] =    BEGIN    SetUpOper[count: 1];	--count gets 1    op.address ¬ failedAddress;  --SetUpOper uses tapeAddress    --do retries until goodCompletion or maxTries or hard read error    DO      [result, retryCount,] ¬ SpecialFloppyChannel.DoDirectIO[op];      IF result = goodCompletion THEN EXIT      ELSE	IF result = cylinderError OR	   result = recordNotFound OR	   result = headerError OR	   result = dataError 	THEN IF logPtr.entry[logPtr.count].tries = (maxTries - 1)	     THEN {Log[TRUE, hard]; Error[hard]}	     ELSE Log[TRUE, soft]	ELSE	  BEGIN	  Log[TRUE, hardware];	  Error[hardware];	  END;      ENDLOOP;    END;  --DoRetries      Log: PROCEDURE [inRetry: BOOLEAN, disp: VerifyRead.EntryDispType] =    BEGIN    IF NOT inRetry THEN      BEGIN      logPtr.count ¬ logPtr.count + 1;      logPtr.entry[logPtr.count].sector ¬ TapeAddressToSector[failedAddress];      END;    logPtr.entry[logPtr.count].tries ¬ logPtr.entry[logPtr.count].tries + 1;    logPtr.entry[logPtr.count].error[logPtr.entry[logPtr.count].tries] ¬       	result;    logPtr.entry[logPtr.count].entryDisp ¬ disp;    END;  --Log      DoCompare: PROCEDURE [] =    BEGIN    --if no error, returns    --if error, log and signal Error.verify    --The first four words of diagnostic data are Unit, Cylinder, Head, Sector;    -- The remaining bytes are incrementing data.    --internal procedure    CompError: PROCEDURE[] =       BEGIN      bp: LONG CARDINAL;      failedAddress ¬ [cyl, 0, sect];      bp ¬ TapeAddressToSector[failedAddress];      IF CheckBPTable[bp]         THEN RETURN	ELSE 	  BEGIN	  Log[FALSE, verify];	  Error[hardware];	  END;      END; --CompError         halfPage: CARDINAL = 128;    bumpData: CARDINAL = 514;     nextTrack: CARDINAL = 33;    startData: CARDINAL = 2057;    nextWordIndex: CARDINAL;    expectedData: CARDINAL;    byteIndex: CARDINAL ¬ 0;    wordIndex: CARDINAL ¬ 0;    unit: CARDINAL¬ 0;    cyl: CARDINAL¬ 0;    head: CARDINAL¬ 0;    sect: CARDINAL¬ 1;    wordPtr: LONG POINTER TO ARRAY OF WORD;    wordPtr ¬ LOOPHOLE[spaceInterval.pointer];    cyl ¬ tapeAddress.cylinder;    sect ¬ tapeAddress.sector;        FOR i:CARDINAL IN [1..runCount]      DO      IF wordPtr[wordIndex] # unit THEN {CompError[]; RETURN};      wordIndex ¬ wordIndex + 1;      IF wordPtr[wordIndex] # cyl THEN {CompError[]; RETURN};      wordIndex ¬ wordIndex + 1;      IF wordPtr[wordIndex] # head THEN {CompError[]; RETURN};      wordIndex ¬ wordIndex + 1;      IF wordPtr[wordIndex] # sect THEN {CompError[]; RETURN};      wordIndex ¬ wordIndex + 1;      nextWordIndex ¬ i * wordsPerPage; --set wordIndex for next sector      expectedData ¬ startData;      FOR ind:CARDINAL IN [wordIndex..nextWordIndex-halfPage)        DO        IF wordPtr[ind] # expectedData	THEN {CompError[]; RETURN};	expectedData ¬ expectedData + bumpData;        ENDLOOP;      wordIndex ¬ nextWordIndex - halfPage;      expectedData ¬ 1;      FOR ind:CARDINAL IN [wordIndex..nextWordIndex)        DO        IF wordPtr[ind] # expectedData	THEN {CompError[]; RETURN};	expectedData ¬ expectedData + bumpData;        ENDLOOP;      wordIndex ¬ nextWordIndex;      sect ¬ sect + 1;			--incr sect and cyl      IF sect = nextTrack THEN {cyl ¬ cyl + 1; sect ¬ 1};      ENDLOOP;    END;  --DoCompare    CheckBPTable: PROCEDURE [badPage: LONG CARDINAL] RETURNS[BOOLEAN] =    BEGIN    match: BOOLEAN ¬ FALSE;    IF bSTablePtr.count = 0 THEN RETURN[match];    FOR i:CARDINAL IN [1..bSTablePtr.count]      DO      IF badPage = bSTablePtr.entry[i]       THEN {match ¬ TRUE; EXIT};      ENDLOOP;    RETURN[match];    END;  --CheckBPTable      SetUpOper: PROCEDURE [function: FloppyDiskFace.Function ¬ readSector,			incPtr: BOOLEAN ¬ TRUE,			tries: CARDINAL ¬ 1,			count: CARDINAL] =     BEGIN    --op.device ¬ FloppyDiskFace.GetNextDevice[FloppyDiskFace.nullDeviceHandle];    --previous line commented out since op.device set in main procedure(VerifyReadOperation)    op.function ¬ function;    op.address ¬ tapeAddress;	--was SectorToTapeAddress[sector];    op.dataPtr ¬ spaceInterval.pointer;	    op.incrementDataPointer ¬ incPtr;    op.tries ¬ tries;    op.count ¬ count;	     END;    CreateResidentBuffer: PROCEDURE [size: Space.PageCount]    RETURNS [buffer: Space.Interval]  =    BEGIN    buffer ¬ Space.Allocate[size ! 	  Space.InsufficientSpace => GO TO return;  	  Space.Error => GO TO return]; 		     VM.ScratchMap[	[Environment.PageFromLongPointer[buffer.pointer], buffer.count]];      EXITS      return => RETURN[Space.nullInterval];    END;  --CreateResidentBuffer  DestroyResidentBuffer: PROCEDURE [buffer: Space.Interval] =     BEGIN    VM.Unmap[Environment.PageFromLongPointer[buffer.pointer]];    Space.Deallocate[buffer !	    Space.Error => CONTINUE];	     END;  --DestroyResidentBuffer  AllocIOCB: PROCEDURE [wds: CARDINAL] RETURNS [p: LONG POINTER] =    BEGIN     status: Zone.Status;    IF wds = 0 THEN RETURN[NIL];    [gsp, status] ¬ ResidentHeap.MakeNode[      n: wds, alignment: FloppyDiskFace.operationAlignment];    IF status # okay THEN VRError[allocBug];    RETURN[@Environment.first64K[gsp]];    END;  --AllocIOCB    DeAllocIOCB: PROCEDURE [p: LONG POINTER] =     BEGIN    status: Zone.Status ¬ ResidentHeap.FreeNode[gsp];    IF status # okay THEN VRError[deAllocBug];  --call debug?    END;  --DeAllocIOCB      SectorToTapeAddress: PROCEDURE [sector: LONG CARDINAL]    RETURNS[diskAddress: FloppyDiskFace.DiskAddress] =     BEGIN    [diskAddress.cylinder, diskAddress.sector] ¬     	Inline.LongDivMod[sector-1, sectorsPerTrack];	    diskAddress.sector ¬ diskAddress.sector + 1; -- sectors begin at 1     diskAddress.head ¬ 0;    END;   --SectorToTapeAddress      TapeAddressToSector: PROCEDURE [diskAddress: FloppyDiskFace.DiskAddress]    RETURNS[sector: LONG CARDINAL] =     BEGIN    sector ¬ diskAddress.sector +              Inline.LongMult[sectorsPerTrack, diskAddress.cylinder];    END;  --TapeAddressToSector	END...LOG20-Feb-87 10:34:29 by RK, Created file 9-Dec-87 18:02:16 by RK, changed op.device from a default value to real value using SpecialFloppyChannelExtras, FloppyChannel, and  FloppyTapeExtras
-- File: FloppyOnlineDiagnosticsImpl.mesa - last edit:-- Daying Chen:OSBU North:Xerox 29-Aug-91 18:01:32-- File: FloppyOnlineDiagnosticsImpl.mesa-- Last edited on 18-Oct-87 10:42:39 by STC---- Copyright (C) 1984, 1985, 1986, 1991 by Xerox Corporation. All rights reserved.--  --                    --DIRECTORY  DeviceTypes USING [ sa800 ],  DeviceTypesExtras USING [ anyFloppy, sa850, sa455 ],  DeviceTypesExtras3 USING [sa475],  Environment USING [ Byte, wordsPerPage ],  FloppyChannel,  Floppy USING [AlreadyFormatted, Close, Density, Error, Format,     GetAttributes, Open, Sides, VolumeHandle],  Heap USING [ systemZone ],  Inline USING [ HighHalf, LongCOPY ],  OnlineDiagnostics,  OnlineDiagnosticsExtra,  ProcessorFace USING [ mp, SetMP ],  Space USING [ ScratchMap, Unmap ] ;--  SpecialFloppyChannel USING [ DoDirectIO ]FloppyOnlineDiagnosticsImpl : PROGRAMIMPORTS Floppy, FloppyChannel, Heap, Inline, OnlineDiagnosticsExtra, ProcessorFace, SpaceEXPORTS OnlineDiagnostics, OnlineDiagnosticsExtra =BEGIN  OPEN FloppyChannel, OnlineDiagnostics;-- ****************************************************************************--		PRIVATE TYPES for OnlineDiagnostics-- ****************************************************************************  hdZeroErrs: CARDINAL ¬ 0;  hdOneErrs: CARDINAL ¬ 0;    stopOnErrFlag: BOOLEAN ¬ FALSE;  totalAccesses: CARDINAL ¬ 0;    Abort: ERROR = CODE;    BadContext : SIGNAL = CODE ;  BadCylinder0 : SIGNAL = CODE ;  CantFormatTrack : SIGNAL [ address : DiskAddress ] = CODE ;  StopTest : SIGNAL [ msg : FloppyMessage ] = CODE ;  stopOnErrorAndError: SIGNAL = CODE;  ColumnHeadersType : TYPE = ARRAY TestType OF FloppyMessage ;  DataBuffer : TYPE = LONG DESCRIPTOR FOR ARRAY OF WORD ;  DiskTestResults : TYPE = ARRAY DisplayStatusType OF CARDINAL ;  addrLogResults: TYPE = ARRAY [0..25) OF CARDINAL;  addrLogType: TYPE = ARRAY [0..5) OF addrLogResults;  addrLogPtrType: TYPE = LONG POINTER TO addrLogType;  badOpCnt: CARDINAL ¬ 0;  addrLog: addrLogPtrType ¬ Heap.systemZone.NEW[addrLogType ¬ ALL[ALL[0]] ];  addrLogStatus: ARRAY[0..25) OF FloppyMessage ¬ ALL[tLast];  DisplayStatusType : TYPE = { TimesExecuted, GoodCompletion, DiskChange, NotReady, CylinderError, DeletedData, RecordNotFound, HeaderError, DataError, DataLost, WriteFault, OtherError } ;  NoDiskDrive : SIGNAL = CODE ;  NumberOfTestTrys : TYPE = ARRAY TestType OF CARDINAL ;  RecordID : TYPE = RECORD  [    address : DiskAddress,    sectorLength : CARDINAL,    MachineDependentBytes : PACKED ARRAY [1..4] OF Environment.Byte  ] ;  RowHeadersType : TYPE = ARRAY DisplayStatusType OF FloppyMessage ;  SummaryLogType : TYPE = ARRAY TestType OF DiskTestResults ;  SummaryLogPtrType : TYPE = LONG POINTER TO SummaryLogType ;  TestType : TYPE = { readStatus, SeekAndVerify, readSector, writeSectors, writeDeletedSector } ;  UnknownDeviceType : SIGNAL = CODE ;  ReadDataFailed: SIGNAL = CODE;  UnknownSectorLength : CARDINAL = FIRST[CARDINAL] ;    -- ****************************************************************************--		Global Constants and Variables for OnlineDiagnostics-- ****************************************************************************  attributes : Attributes ;  NormalContext : Context = [protect : FALSE, format : IBM, density : double, sectorLength : 256] ;  Track0Context : Context = [protect : FALSE, format : IBM, density : single, sectorLength : 64] ;  Track1Context : Context = [protect : FALSE, format : IBM, density : double, sectorLength : 128] ;  Track0Address : DiskAddress = [0, 0, 1] ;  Track1Address : DiskAddress = [0, 1, 1] ;  CurrentContext : Context ;  CurrentDrive : Drive ¬ nullDrive ;  CurrentHandle : Handle ¬ nullHandle ;  DiagnosticCylinder : CARDINAL ¬ 0 ;		-- = last cylinder on disk  DiagnosticDiskIDSector : SectorCount ¬ 1 ;  DiagnosticDiskIDBuffer : DataBuffer ¬ AllocateDataBuffer[NormalContext.sectorLength] ;    DiagDataBufferT0: DataBuffer ¬ AllocateDataBuffer[Track0Context.sectorLength];  DiagDataBufferT1: DataBuffer ¬ AllocateDataBuffer[Track1Context.sectorLength];  DiagDataBufferCyl: DataBuffer ¬ AllocateDataBuffer[NormalContext.sectorLength];  ExerciseTestTrys : NumberOfTestTrys =  [    5,		-- readStatus    25, 	-- SeekAndVerify    75, 	-- readSector    50, 	-- writeSectors    5		-- writeDeletedSector  ] ;  StandardTestTrys : NumberOfTestTrys =  [    5,		-- readStatus    25, 	-- SeekAndVerify    50, 	-- readSector    0,		-- writeSectors    0		-- writeDeletedSector  ] ;  MainDataBuffer : DataBuffer ¬ AllocateDataBuffer[MaxSectorsToTransfer*NormalContext.sectorLength] ;  TempDataBuffer : DataBuffer ¬ AllocateDataBuffer[MaxSectorsToTransfer*NormalContext.sectorLength] ;  MaxSectorsToTransfer : CARDINAL = 4 ;  FirstCylinder : CARDINAL = 0 ;  FirstHead : HeadCount = 0 ;  FirstSector : SectorCount = 1 ;  LastCylinder : CARDINAL ¬ 0 ;  LastHead : HeadCount ¬ 0 ;  LastSector : SectorCount ¬ 0 ;  OldMPCode : CARDINAL ¬ 0 ;  NumberOfPassesToCleanHeads : CARDINAL = 15 ;  RandomState : LONG CARDINAL ¬ 35 ;	-- do something smarter later  BadDiagnosticCylinder : BOOLEAN ¬ FALSE ;  BadSectorsOnDisk : BOOLEAN ;  BadTracksOnDisk : BOOLEAN ;  NumberOfBadTracks : CARDINAL ¬ 0 ;  NumberOfDataErrors : CARDINAL ¬ 0 ;  NumberOfHardErrors : CARDINAL ¬ 0 ;  NumberOfSoftErrors : CARDINAL ¬ 0 ;  LoggingOn : BOOLEAN ¬ TRUE ;  ErrorLog : ARRAY TestType OF CARDINAL ¬ ALL[0] ;  SummaryLog : SummaryLogPtrType ¬ Heap.systemZone.NEW[ SummaryLogType ¬ ALL[ALL[0]] ] ;  NumberOfValidSectorLengths : CARDINAL = 5 ;  ValidSectorLengths : ARRAY [0..NumberOfValidSectorLengths) OF CARDINAL = [ 64, 128, 256, 512, 1022 ] ;-- ****************************************************************************--		PUBLIC ITEMS EXPORTed to PILOT via OnlineDiagnosticsExtra-- ****************************************************************************abortCurrentTest: PUBLIC SIGNAL = CODE;WriteDiagData : PUBLIC PROCEDURE  [    displayFields :        DisplayFieldsProc,    displayTable :         DisplayTableProc,    displayNumberedTable : DisplayNumberedTableProc,    putMessage :           PutMessageProc,    getConfirmation :      GetConfirmationProc,    getYesOrNo :           GetYesOrNoProc,    getFloppyChoice :      GetFloppyChoiceProc ] =  BEGIN    ENABLE      BEGIN        BadContext =>	  BEGIN	    putMessage[iBadContext] ;	    GOTO UserAction ;	  END ;	BadCylinder0 =>	  BEGIN	    putMessage[iBadTrack0] ;	    GOTO UserAction ;	  END ;	CantFormatTrack =>	  BEGIN	    putMessage[xBadTrack] ;	    GOTO UserAction ;	  END ;	NoDiskDrive =>	  BEGIN	    putMessage[xNoDiskDrivePresent] ;	    GOTO QuitNow ;	  END ;	StopTest =>	  BEGIN	    putMessage[msg] ;	    GOTO QuitNow ;	  END ;	UnknownDeviceType =>	  BEGIN	    putMessage[xUnknownDiskDriveType] ;	    GOTO QuitNow ;	  END ;      END ;          badCaseDataPattern : CARDINAL = 6D6DH ;    address: DiskAddress ¬ Track0Address;    status: Status;    count: CARDINAL;        ClearLog[] ;    ListDrivesAndAskWhichOneTheyWant[getYesOrNo] ;    SetNewContext[NormalContext] ;    putMessage[cLast] ;    IF getYesOrNo[yStillContinue] = no THEN RETURN ;    IF getYesOrNo[yStillSure] = no THEN RETURN ;    OldMPCode ¬ ProcessorFace.mp ;    ProcessorFace.SetMP[3000] ;    InitializePublicVariables[] ;        IF NOT attributes.ready THEN    BEGIN      putMessage[iUnitNotReady] ;      getConfirmation[cEnsureReady] ;    END ;        InitializePublicVariables[] ;        IF attributes.twoSided THEN putMessage[iTwoSided] ELSE putMessage[iOneSided] ;    ClearLog[] ;        IF getYesOrNo[hFirst] = yes THEN {                <<  format the diskette  >>            putMessage[iFormProgress] ;    SetNewContext[Track0Context] ;    [status, count] ¬ FormatTracks[CurrentHandle, Track0Address, 1] ;    ExitOnFatalErrors[status] ;    IF status # goodCompletion THEN SIGNAL CantFormatTrack[Track0Address] ;    IF attributes.twoSided THEN	  BEGIN	    SetNewContext[Track1Context] ;	    [status, count] ¬ FormatTracks[CurrentHandle, Track1Address, 1] ;	    ExitOnFatalErrors[status] ;	    	    IF status # goodCompletion THEN SIGNAL CantFormatTrack[Track1Address] ;	  END ;	      SetNewContext[NormalContext] ;    FOR cyl : CARDINAL IN [1..DiagnosticCylinder] DO      [status, count] ¬ FormatTracks[CurrentHandle, [cyl, 0, 1], 1] ;      ExitOnFatalErrors[status] ;      IF status # goodCompletion THEN SIGNAL CantFormatTrack[[cyl, 0, 1]] ;    ENDLOOP ;    IF attributes.twoSided THEN    BEGIN      FOR cyl : CARDINAL IN [1..DiagnosticCylinder] DO	[status, count] ¬ FormatTracks[CurrentHandle, [cyl, 1, 1], 1] ;	ExitOnFatalErrors[status] ;	IF status # goodCompletion THEN SIGNAL CantFormatTrack[[cyl, 1, 1]] ;      ENDLOOP ;    END ;        };  -- end format        <<  write cylinder 0 diagnostic data    >>        putMessage[tCIEVer] ;        GenerateDiagDataBuffers[badCaseDataPattern];    SetNewContext[Track0Context];    address ¬ Track0Address;   -- write track0            FOR aSector : SectorCount IN [FirstSector..LastSector] DO      address.sector ¬ aSector;      [status,] ¬ WriteSectors[CurrentHandle, address, DiagDataBufferT0.BASE, 1, TRUE];      ExitOnFatalErrors[status];      Log[writeSectors, status, address];    ENDLOOP ;        SetNewContext[Track1Context];    address ¬ Track1Address;   -- write track1              FOR aSector : SectorCount IN [FirstSector..LastSector] DO      address.sector ¬ aSector;      [status,] ¬ WriteSectors[CurrentHandle, address, DiagDataBufferT1.BASE, 1, TRUE];      ExitOnFatalErrors[status];      Log[writeSectors, status, address];    ENDLOOP ;        <<  write second cylinder diagnostic data    >>        SetNewContext[NormalContext];        address.cylinder ¬ 1;    address.head ¬ FirstHead;            FOR aSector : SectorCount IN [FirstSector..LastSector] DO      address.sector ¬ aSector;      [status,] ¬ WriteSectors[CurrentHandle, address, DiagDataBufferCyl.BASE, 1, TRUE];      ExitOnFatalErrors[status];      Log[writeSectors, status, address];    ENDLOOP ;        address.head ¬ LastHead;        FOR aSector : SectorCount IN [FirstSector..LastSector] DO      address.sector ¬ aSector;      [status,] ¬ WriteSectors[CurrentHandle, address, DiagDataBufferCyl.BASE, 1, TRUE];      ExitOnFatalErrors[status];      Log[writeSectors, status, address];    ENDLOOP ;            <<  write last cylinder diagnostic data    >>        SetNewContext[NormalContext];        address.cylinder ¬ DiagnosticCylinder;       address.head ¬ FirstHead;        FOR aSector : SectorCount IN [FirstSector..LastSector] DO      address.sector ¬ aSector;      [status,] ¬ WriteSectors[CurrentHandle, address, DiagDataBufferCyl.BASE, 1, TRUE];      ExitOnFatalErrors[status];      Log[writeSectors, status, address];    ENDLOOP ;        address.head ¬ LastHead;        FOR aSector : SectorCount IN [FirstSector..LastSector] DO      address.sector ¬ aSector;      [status,] ¬ WriteSectors[CurrentHandle, address, DiagDataBufferCyl.BASE, 1, TRUE];      ExitOnFatalErrors[status];      Log[writeSectors, status, address];    ENDLOOP ;        FigureOutAndSetFinalMPCode[] ;        IF badOpCnt # 0 THEN           putMessage[hObser1];      RETURN ;      EXITS     QuitNow =>	BEGIN	  ProcessorFace.SetMP[OldMPCode] ;	  RETURN ;	END ;      UserAction =>        BEGIN	  putMessage[hCRC1];	  putMessage[hCRC2];	  putMessage[hObser2];	  putMessage[hCRCErr];	  putMessage[hLast];	  putMessage[hIllglStat];	  ProcessorFace.SetMP[OldMPCode] ;	  RETURN ;	END ;       END ;     ReadDiagData : PUBLIC PROCEDURE  [    displayFields :        DisplayFieldsProc,    displayTable :         DisplayTableProc,    displayNumberedTable : DisplayNumberedTableProc,    putMessage :           PutMessageProc,    getConfirmation :      GetConfirmationProc,    getYesOrNo :           GetYesOrNoProc,    getFloppyChoice :      GetFloppyChoiceProc ] =  BEGIN    ENABLE      BEGIN        BadContext =>	  BEGIN	    putMessage[xExtraMessage2] ;	    putMessage[iBadContext] ;	    GOTO UserAction;	  END ;	BadCylinder0 =>	  BEGIN	    putMessage[xExtraMessage2];	    putMessage[iBadTrack0] ;	    GOTO UserAction ;	  END ;	CantFormatTrack =>	  BEGIN	    putMessage[xExtraMessage2];	    putMessage[xBadTrack] ;	    GOTO UserAction ;	  END ;	NoDiskDrive =>	  BEGIN	    putMessage[xNoDiskDrivePresent] ;	    GOTO QuitNow ;	  END ;	StopTest =>	  BEGIN	    putMessage[msg] ;	    GOTO QuitNow ;	  END ;	UnknownDeviceType =>	  BEGIN	    putMessage[xUnknownDiskDriveType] ;	    	    GOTO QuitNow ;	  END ;	ReadDataFailed =>	  BEGIN	    putMessage[xExtraMessage2] ;	    putMessage[iFirst] ;	    GOTO QuitNow ;	  END ;      END ;          badCaseDataPattern : CARDINAL = 6D6DH ;    address: DiskAddress ¬ Track0Address;    dataDifferences: CARDINAL ¬ 0;    status: Status;            tempDataBufferT0: DataBuffer ¬ AllocateDataBuffer[Track0Context.sectorLength];    tempDataBufferT1: DataBuffer ¬ AllocateDataBuffer[Track1Context.sectorLength];    tempDataBufferCyl: DataBuffer ¬ AllocateDataBuffer[NormalContext.sectorLength];        ClearLog[] ;        ListDrivesAndAskWhichOneTheyWant[getYesOrNo] ;    SetNewContext[NormalContext] ;    putMessage[tCIERH] ;    putMessage[tCIEWS] ;    IF getYesOrNo[tCIERS] = no THEN       putMessage[tCIEWS] ;          IF getYesOrNo[yStillContinue] = no THEN RETURN ;        OldMPCode ¬ ProcessorFace.mp ;    ProcessorFace.SetMP[3000] ;    InitializePublicVariables[] ;        IF NOT attributes.ready THEN    BEGIN      putMessage[iUnitNotReady] ;      getConfirmation[cEnsureReady] ;    END ;        InitializePublicVariables[] ;             IF attributes.twoSided THEN putMessage[iTwoSided] ELSE putMessage[iOneSided] ;    ClearLog[] ;        GenerateDiagDataBuffers[badCaseDataPattern];                        FOR j: CARDINAL IN [0..15) DO          putMessage[tByteCnt] ;            <<  read first cylinder  >>                   SetNewContext[Track0Context];       address ¬ Track0Address;              FOR aSector : SectorCount IN [FirstSector..LastSector] DO         address.sector ¬ aSector;	 [status,] ¬ ReadSectors[CurrentHandle, address, tempDataBufferT0.BASE, 1, TRUE];	 ExitOnFatalErrors[status];	 Log[readSector, status, address];	 dataDifferences ¬ CompareDataBuffers[tempDataBufferT0, DiagDataBufferT0];	 IF status # goodCompletion AND status # dataLost THEN SIGNAL ReadDataFailed;	 	 IF dataDifferences # 0 THEN {Log[readSector, otherError, address];	                              SIGNAL ReadDataFailed;};	        ENDLOOP;              SetNewContext[Track1Context];       address ¬ Track1Address;              FOR aSector : SectorCount IN [FirstSector..LastSector] DO         address.sector ¬ aSector;	 [status,] ¬ ReadSectors[CurrentHandle, address, tempDataBufferT1.BASE, 1, TRUE];	 ExitOnFatalErrors[status];	 Log[readSector, status, address];	 dataDifferences ¬ CompareDataBuffers[tempDataBufferT1, DiagDataBufferT1];	 IF status # goodCompletion AND status # dataLost THEN SIGNAL ReadDataFailed;	 IF dataDifferences # 0 THEN {Log[readSector, otherError, address];	                              SIGNAL ReadDataFailed;};	        ENDLOOP;              <<  read second cylinder  >>              SetNewContext[NormalContext];           address.cylinder ¬ 1;       address.head ¬ FirstHead;              FOR aSector : SectorCount IN [FirstSector..LastSector] DO         address.sector ¬ aSector;	 [status,] ¬ ReadSectors[CurrentHandle, address, tempDataBufferCyl.BASE, 1, TRUE];	 	 ExitOnFatalErrors[status];	 Log[readSector, status, address];	 dataDifferences ¬ CompareDataBuffers[tempDataBufferCyl, DiagDataBufferCyl];	 IF status # goodCompletion AND status # dataLost THEN SIGNAL ReadDataFailed;	 IF dataDifferences # 0 THEN {Log[readSector, otherError, address];	                              SIGNAL ReadDataFailed;};       ENDLOOP;              address.head ¬ LastHead;              FOR aSector : SectorCount IN [FirstSector..LastSector] DO         address.sector ¬ aSector;	 [status,] ¬ ReadSectors[CurrentHandle, address, tempDataBufferCyl.BASE, 1, TRUE];	 ExitOnFatalErrors[status];	 Log[readSector, status, address];	 dataDifferences ¬ CompareDataBuffers[tempDataBufferCyl, DiagDataBufferCyl];	 IF status # goodCompletion AND status # dataLost THEN SIGNAL ReadDataFailed;	 IF dataDifferences # 0 THEN {Log[readSector, otherError, address];	                              SIGNAL ReadDataFailed;};       ENDLOOP;		       <<  read last cylinder  >>              SetNewContext[NormalContext];           address.cylinder ¬ DiagnosticCylinder;       address.head ¬ FirstHead;              FOR aSector : SectorCount IN [FirstSector..LastSector] DO         address.sector ¬ aSector;	 [status,] ¬ ReadSectors[CurrentHandle, address, tempDataBufferCyl.BASE, 1, TRUE];	 	 ExitOnFatalErrors[status];	 Log[readSector, status, address];	 dataDifferences ¬ CompareDataBuffers[tempDataBufferCyl, DiagDataBufferCyl];	 IF status # goodCompletion AND status # dataLost THEN SIGNAL ReadDataFailed;	 IF dataDifferences # 0 THEN {Log[readSector, otherError, address];	                              SIGNAL ReadDataFailed;};       ENDLOOP;              address.head ¬ LastHead;              FOR aSector : SectorCount IN [FirstSector..LastSector] DO         address.sector ¬ aSector;	 [status,] ¬ ReadSectors[CurrentHandle, address, tempDataBufferCyl.BASE, 1, TRUE];	 ExitOnFatalErrors[status];	 Log[readSector, status, address];	 dataDifferences ¬ CompareDataBuffers[tempDataBufferCyl, DiagDataBufferCyl];	 IF status # goodCompletion AND status # dataLost THEN SIGNAL ReadDataFailed;	 IF dataDifferences # 0 THEN {Log[readSector, otherError, address];	                              SIGNAL ReadDataFailed;};       ENDLOOP;                  ENDLOOP;        putMessage[xExtraMessage5];   --test passed            RETURN ;      EXITS          QuitNow =>	BEGIN	  ProcessorFace.SetMP[OldMPCode] ;	  RETURN ;	END ;      UserAction =>	BEGIN	  putMessage[hCRC1];	  putMessage[hCRC2];	  putMessage[hObser2];	  putMessage[hCRCErr];	  putMessage[hLast];	  putMessage[hIllglStat];	  ProcessorFace.SetMP[OldMPCode] ;	  RETURN ;	END ;       END ;  ContinuousExerciser: PUBLIC PROCEDURE  [    lookForAbort:         OnlineDiagnosticsExtra.lookForAbortProc,    displayFields:        DisplayFieldsProc,    displayTable:         DisplayTableProc,    displayNumberedTable: DisplayNumberedTableProc,    putMessage:           PutMessageProc,    getConfirmation:      GetConfirmationProc,    getYesOrNo:           GetYesOrNoProc,    getFloppyChoice:      GetFloppyChoiceProc ] =      BEGIN    ENABLE      BEGIN        stopOnErrorAndError =>	   BEGIN	    putMessage[hErrDetc] ;	    GOTO AbortNow ;	  END ;        OnlineDiagnosticsExtra.abortCurrentTest =>	  BEGIN	    putMessage[tCIEWDS] ;	    GOTO AbortNow ;	  END ;	BadContext =>	  BEGIN	    putMessage[xExtraMessage2] ;	    putMessage[iBadContext] ;	    GOTO UserAction ;	  END ;	BadCylinder0 =>	  BEGIN	    putMessage[xExtraMessage2] ;	    putMessage[iBadTrack0] ;	    GOTO UserAction ;	  END ;	CantFormatTrack =>	  BEGIN	    putMessage[xExtraMessage2] ;	    putMessage[xBadTrack] ;	    GOTO UserAction ;	  END ;	NoDiskDrive =>	  BEGIN	    putMessage[xNoDiskDrivePresent] ;	    GOTO QuitNow ;	  END ;	StopTest =>	  BEGIN	    putMessage[msg] ;	    GOTO QuitNow ;	  END ;	UnknownDeviceType =>	  BEGIN	    putMessage[xUnknownDiskDriveType] ;	    GOTO QuitNow ;	  END ;      END ;        ClearLog[] ;    ListDrivesAndAskWhichOneTheyWant[getYesOrNo] ;    SetNewContext[NormalContext] ;    putMessage[iExerWarning] ;    IF getYesOrNo[yStillContinue] = no THEN RETURN ;    IF getYesOrNo[yStillSure] = no THEN RETURN ;    OldMPCode ¬ ProcessorFace.mp ;    ProcessorFace.SetMP[3000] ;    InitializePublicVariables[] ;        IF NOT attributes.ready THEN    BEGIN      putMessage[iUnitNotReady] ;      getConfirmation[cEnsureReady] ;    END ;        InitializePublicVariables[] ;        IF attributes.twoSided THEN putMessage[iTwoSided] ELSE putMessage[iOneSided] ;    ClearLog[] ;            IF getYesOrNo[iLast] = yes THEN stopOnErrFlag ¬ TRUE                               ELSE stopOnErrFlag ¬ FALSE;			           putMessage[cExit];        FormatDisk[] ;			       		               DO  -- Loop forever              lookForAbort[];              -- FormatDisk[] ;                -- CheckCylinderZero[] ;                   SetNewContext[NormalContext] ;              FOR test : TestType IN TestType DO          DoDiskTest[test, ExerciseTestTrys[test]] ;       ENDLOOP;              lookForAbort[];              TestDiagnosticCylinder[];	             ENDLOOP;        TestDiagnosticCylinder[];        IF badOpCnt # 0 THEN { putMessage[xExtraMessage2];                           putMessage[xExtraMessage3]; }		          ELSE   putMessage[xExtraMessage5];        FigureOutAndSetFinalMPCode[];              RETURN ;      EXITS            AbortNow =>	BEGIN	  IF badOpCnt # 0 THEN { putMessage[xExtraMessage2];                                 putMessage[xExtraMessage3]; }		          ELSE   putMessage[xExtraMessage5];              ProcessorFace.SetMP[OldMPCode] ;	  RETURN ;	END ;          QuitNow =>	BEGIN	  ProcessorFace.SetMP[OldMPCode] ;	  RETURN ;	END ;      UserAction =>	BEGIN	  putMessage[hCRC1];	  putMessage[hCRC2];	  putMessage[hExpec2];	  putMessage[hCRCErr];	  putMessage[hLast];	  putMessage[hIllglStat];	  ProcessorFace.SetMP[OldMPCode] ;	  RETURN ;	END ;      END ;  GenerateDiagDataBuffers: PROCEDURE[badCaseDataPattern:CARDINAL] = {   FOR i : CARDINAL IN [0..DiagDataBufferT0.LENGTH) DO      DiagDataBufferT0[i] ¬ badCaseDataPattern;  ENDLOOP ;    FOR i : CARDINAL IN [0..DiagDataBufferT1.LENGTH) DO       DiagDataBufferT1[i] ¬ badCaseDataPattern;  ENDLOOP ;      FOR i : CARDINAL IN [0..DiagDataBufferCyl.LENGTH) DO       DiagDataBufferCyl[i] ¬ badCaseDataPattern;  ENDLOOP ;};-- ****************************************************************************--		PUBLIC PROCEDURES EXPORTed to PILOT via OnlineDiagnostics-- ****************************************************************************  FloppyCleanReadWriteHeads : PUBLIC PROCEDURE  [    displayFields :        DisplayFieldsProc,    displayTable :         DisplayTableProc,    displayNumberedTable : DisplayNumberedTableProc,    putMessage :           PutMessageProc,    getConfirmation :      GetConfirmationProc,    getYesOrNo :           GetYesOrNoProc,    getFloppyChoice :      GetFloppyChoiceProc  ]  RETURNS [ floppyReturn : FloppyReturn ¬ noErrorFound ] =  BEGIN    ENABLE      BEGIN	BadContext =>	  BEGIN	    putMessage[iBadContext] ;	    GOTO QuitNow ;	  END ;	NoDiskDrive =>	  BEGIN	    putMessage[xNoDiskDrivePresent] ;	    GOTO QuitNow ;	  END ;	StopTest =>	  BEGIN	    putMessage[msg] ;	    GOTO QuitNow ;	  END ;	UnknownDeviceType =>	  BEGIN	    putMessage[xUnknownDiskDriveType] ;	    GOTO QuitNow ;	  END ;      END ;    status : Status ;    LoggingOn ¬ FALSE ;    ListDrivesAndAskWhichOneTheyWant[getYesOrNo] ;    SetNewContext[NormalContext] ;    getConfirmation[cInsertCleanDisk] ;    InitializePublicVariables[] ;    IF NOT attributes.ready THEN    BEGIN      getConfirmation[cInsDiffCleanDisk] ;      InitializePublicVariables[] ;      IF NOT attributes.ready THEN RETURN [ deviceNotReady ] ;    END ;    putMessage[iCleanProgress] ;    FOR i : CARDINAL IN [1..NumberOfPassesToCleanHeads] DO      status ¬ Seek[CurrentHandle, [FirstCylinder, FirstHead, FirstSector]] ;      status ¬ Seek[CurrentHandle, [LastCylinder, FirstHead, FirstSector]] ;    ENDLOOP ;    putMessage[iCleanDone] ;    getConfirmation[cRemoveCleanDisk] ;    RETURN ;    EXITS      QuitNow => RETURN [ deviceNotReady ] ;  END ;  FloppyCommandFileTest : PUBLIC PROCEDURE  [    density :              SingleDouble,    sides :                SingleDouble,    sectorsPerTrack :      CARDINAL [8..26],    sectorLength :         SectorLength,    errorHandling :        ErrorHandling,    cmdFile :              LONG STRING,    displayFields :        DisplayFieldsProc,    displayTable :         DisplayTableProc,    displayNumberedTable : DisplayNumberedTableProc,    putMessage :           PutMessageProc,    getConfirmation :      GetConfirmationProc,    getYesOrNo :           GetYesOrNoProc,    getFloppyChoice :      GetFloppyChoiceProc ] =  BEGIN  END ;  FloppyDisplayErrorLog : PUBLIC PROCEDURE  [    displayFields :        DisplayFieldsProc,    displayTable :         DisplayTableProc,    displayNumberedTable : DisplayNumberedTableProc,    putMessage :           PutMessageProc,    getConfirmation :      GetConfirmationProc,    getYesOrNo :           GetYesOrNoProc,    getFloppyChoice :      GetFloppyChoiceProc ] =  BEGIN    ColumnHeaders : ARRAY [0..ORD[LAST[TestType]]] OF FloppyMessage ¬	-- just ColumnHeadersType but the compiler doesn't like DESCRIPTOR[ColumnHeaders]    [      hReadStat,	-- readStatus      xSeekVerify,	-- SeekAndVerify      hReadSector,	-- readSector      hWriteSector,	-- writeSectors      hWriteDelSector	-- writeDeletedSector    ] ;    RowHeaders : ARRAY [0..ORD[LAST[DisplayStatusType]]] OF FloppyMessage ¬	-- same as above for DESCRIPTOR[RowHeaders]    [      hTimeExc,		-- TimesExecuted      hGoodComp,	-- GoodCompletion      hDiskChng,	-- DiskChange      xNotReady,	-- NotReady      hSeekErr,		-- CylinderError      hDelSector,	-- DeletedData      xRecordNotFound,	-- RecordNotFound      xHeaderError,	-- HeaderError      xDataError,	-- DataError      xDataLost,	-- DataLost      hWritePro,	-- WriteFault      xOtherError	-- OtherError    ] ;    TempSummaryLog : SummaryLogType ¬ SummaryLog^ ;	-- copy the SummaryLog into MDS    SumLog : ARRAY [0..ORD[LAST[TestType]]] OF DESCRIPTOR FOR ARRAY OF UNSPECIFIED ;                rowHeadersAddrLog: ARRAY [0..25) OF FloppyMessage;    tempAddrLog: addrLogType ¬ addrLog­ ;    passAddrLog: ARRAY [0..5) OF DESCRIPTOR FOR ARRAY OF UNSPECIFIED;    FOR test : TestType IN TestType DO      SumLog[ORD[test]] ¬ DESCRIPTOR[@TempSummaryLog[test], ORD[LAST[DisplayStatusType]]+1] ;    ENDLOOP ;    displayTable[DESCRIPTOR[ColumnHeaders], DESCRIPTOR[RowHeaders], DESCRIPTOR[SumLog], tSummErrLog, cardinal] ;        IF getYesOrNo[yFirst] = yes THEN {        ColumnHeaders ¬     [      xExtraMessage1,	-- operationCode      hTrack,	        -- cylinder      hHead,	        -- head            hSector,	        -- sector      xExtraMessage4	-- context (sectorLength)    ] ;                FOR addrLogIndex:CARDINAL IN [0..5) DO {      passAddrLog[addrLogIndex] ¬ DESCRIPTOR[@tempAddrLog[addrLogIndex], 25]; };    ENDLOOP;        FOR vv:CARDINAL IN [0..25) DO {       rowHeadersAddrLog[vv] ¬ addrLogStatus[vv]; };    ENDLOOP;        displayTable[DESCRIPTOR[ColumnHeaders], DESCRIPTOR[rowHeadersAddrLog], DESCRIPTOR[passAddrLog], tSummErrLog, cardinal];  };             END ;  FloppyExerciser : PUBLIC PROCEDURE  [    displayFields :        DisplayFieldsProc,    displayTable :         DisplayTableProc,    displayNumberedTable : DisplayNumberedTableProc,    putMessage :           PutMessageProc,    getConfirmation :      GetConfirmationProc,    getYesOrNo :           GetYesOrNoProc,    getFloppyChoice :      GetFloppyChoiceProc ] =  BEGIN    ENABLE      BEGIN        BadContext =>	  BEGIN	    putMessage[xExtraMessage2] ;	    putMessage[iBadContext] ;	    GOTO UserAction ;	  END ;	BadCylinder0 =>	  BEGIN	    putMessage[xExtraMessage2] ;	    putMessage[iBadTrack0] ;	    GOTO UserAction ;	  END ;	CantFormatTrack =>	  BEGIN	    putMessage[xExtraMessage2] ;	    putMessage[xBadTrack] ;	    GOTO UserAction ;	  END ;	NoDiskDrive =>	  BEGIN	    putMessage[xNoDiskDrivePresent] ;	    GOTO QuitNow ;	  END ;	StopTest =>	  BEGIN	    putMessage[msg] ;	    GOTO QuitNow ;	  END ;	UnknownDeviceType =>	  BEGIN	    putMessage[xUnknownDiskDriveType] ;	    GOTO QuitNow ;	  END ;      END ;        ListDrivesAndAskWhichOneTheyWant[getYesOrNo] ;    SetNewContext[NormalContext] ;    putMessage[iExerWarning] ;    IF getYesOrNo[yStillContinue] = no THEN RETURN ;    IF getYesOrNo[yStillSure] = no THEN RETURN ;    OldMPCode ¬ ProcessorFace.mp ;    ProcessorFace.SetMP[3000] ;    InitializePublicVariables[] ;        IF NOT attributes.ready THEN    BEGIN      putMessage[iUnitNotReady] ;      getConfirmation[cEnsureReady] ;    END ;        InitializePublicVariables[] ;    IF attributes.twoSided THEN putMessage[iTwoSided] ELSE putMessage[iOneSided] ;    ClearLog[] ;                 FormatDisk[] ;                    CheckCylinderZero[] ;    SetNewContext[NormalContext] ;    FOR test : TestType IN TestType DO          DoDiskTest[test, ExerciseTestTrys[test]] ;    ENDLOOP ;    TestDiagnosticCylinder[] ;    FigureOutAndSetFinalMPCode[];        IF badOpCnt # 0 THEN { putMessage[xExtraMessage2];                           putMessage[xExtraMessage3]; }		    ELSE   putMessage[xExtraMessage5];		        RETURN ;      EXITS          QuitNow =>	BEGIN	  ProcessorFace.SetMP[OldMPCode] ;	  RETURN ;	END ;      UserAction =>	BEGIN	  putMessage[hCRC1];	  putMessage[hCRC2];	  putMessage[hExpec2];	  putMessage[hCRCErr];	  putMessage[hLast];	  putMessage[hIllglStat];	  ProcessorFace.SetMP[OldMPCode] ;	  RETURN ;	END ;        END ;    FloppyFormatDiskette : PUBLIC PROCEDURE  [    displayFields :        DisplayFieldsProc,    displayTable :         DisplayTableProc,    displayNumberedTable : DisplayNumberedTableProc,    putMessage :           PutMessageProc,    getConfirmation :      GetConfirmationProc,    getYesOrNo :           GetYesOrNoProc,    getFloppyChoice :      GetFloppyChoiceProc ] =  BEGIN    ENABLE      BEGIN        Abort =>	  BEGIN	    putMessage[hErrDetc] ;	    GOTO QuitNow ;	  END ;	BadContext =>	  BEGIN	    putMessage[iBadContext] ;	    GOTO QuitNow ;	  END ;	BadCylinder0 =>	  BEGIN	    putMessage[iBadTrack0] ;	    CONTINUE ;	  END ;	CantFormatTrack =>	  BEGIN	    putMessage[xBadTrack] ;	    GOTO QuitNow ;	  END ;	NoDiskDrive =>	  BEGIN	    putMessage[xNoDiskDrivePresent] ;	    GOTO QuitNow ;	  END ;	StopTest =>	  BEGIN	    putMessage[msg] ;	    GOTO QuitNow ;	  END ;	UnknownDeviceType =>	  BEGIN	    putMessage[xUnknownDiskDriveType] ;	    GOTO QuitNow ;	  END ;      END ;    LoggingOn ¬ FALSE ;    ListDrivesAndAskWhichOneTheyWant[getYesOrNo] ;    SetNewContext[NormalContext] ;    putMessage[iFormWarning] ;    IF getYesOrNo[yStillContinue] = no THEN RETURN ;    IF getYesOrNo[yStillSure] = no THEN RETURN ;    InitializePublicVariables[] ;    IF NOT attributes.ready THEN    BEGIN      putMessage[iUnitNotReady] ;      getConfirmation[cEnsureReady] ;    END ;    InitializePublicVariables[] ;        ClearLog[] ;         BEGIN               density: Floppy.Density ¬ default;      sides: Floppy.Sides ¬ default;      label: LONG STRING ¬ NIL;      BEGIN        gotError: BOOLEAN ¬ FALSE;        v: Floppy.VolumeHandle;        v ¬ Floppy.Open[CurrentDrive! Floppy.Error => SELECT error FROM              invalidFormat => GOTO virgin;	      notReady => GOTO notRdy;	      noSuchDrive => GOTO notRdy;	      writeInhibited => {putMessage[hWritePro]; GOTO notRdy; };	                    needsScavenging => {gotError ¬ TRUE; CONTINUE};              ENDCASE => ERROR Abort;];        IF ~gotError THEN {              [] ¬ Floppy.GetAttributes[v, label];              Floppy.Close[v]; };        EXITS notRdy => { putMessage[cNBNotReady];	                  GOTO QuitNow; };	      virgin => NULL;	      END;            label ¬ "UserFloppy"L;            OldMPCode ¬ ProcessorFace.mp ;      ProcessorFace.SetMP[3000] ;                  putMessage[iFormProgress];      Floppy.Format[CurrentDrive, 64, label, density, sides !        Floppy.Error => SELECT error FROM	  notReady => GOTO nRdy;	  noSuchDrive => GOTO nRdy;	  writeInhibited => {putMessage[hWritePro]; GOTO QuitNow; };	  ENDCASE => ERROR Abort;                   Floppy.AlreadyFormatted => RESUME];      putMessage[iFormDone];            FigureOutAndSetFinalMPCode[] ;           END;                 RETURN ;    EXITS      QuitNow =>	BEGIN	  ProcessorFace.SetMP[OldMPCode] ;	  RETURN ;	END ;      nRdy =>	BEGIN	  putMessage[cNBNotReady];	  ProcessorFace.SetMP[OldMPCode] ;	  RETURN ;	END ;  END ;  FloppyStandardTest : PUBLIC PROCEDURE  [    displayFields :        DisplayFieldsProc,    displayTable :         DisplayTableProc,    displayNumberedTable : DisplayNumberedTableProc,    putMessage :           PutMessageProc,    getConfirmation :      GetConfirmationProc,    getYesOrNo :           GetYesOrNoProc,    getFloppyChoice :      GetFloppyChoiceProc  ]  RETURNS [ floppyReturn : FloppyReturn ¬ noErrorFound ] =  BEGIN    ENABLE      BEGIN	BadContext =>	  BEGIN	    putMessage[xExtraMessage2] ;	    putMessage[iBadContext] ;	    GOTO UserAction ;	  END ;	BadCylinder0 =>	  BEGIN	    putMessage[xExtraMessage2] ;	    putMessage[iBadTrack0] ;	    GOTO UserAction ;	  END ;	CantFormatTrack =>	  BEGIN	    putMessage[xExtraMessage2] ;	    putMessage[xBadTrack] ;	    GOTO UserAction ;	  END ;	NoDiskDrive =>	  BEGIN	    putMessage[xNoDiskDrivePresent] ;	    GOTO QuitNow ;	  END ;	StopTest =>	  BEGIN	    putMessage[msg] ;	    GOTO QuitNow ;	  END ;	UnknownDeviceType =>	  BEGIN	    putMessage[xUnknownDiskDriveType] ;	    GOTO QuitNow ;	  END ;      END ;        address: DiskAddress ¬ Track0Address;        ClearLog[] ;    LoggingOn ¬ FALSE ;    ListDrivesAndAskWhichOneTheyWant[getYesOrNo] ;    SetNewContext[NormalContext] ;    putMessage[iInsertDiagDisk] ;    getConfirmation[cOtherDiskErr] ;    InitializePublicVariables[] ;        IF NOT attributes.ready THEN    BEGIN      putMessage[iUnitNotReady] ;      getConfirmation[cEnsureReady] ;    END ;        InitializePublicVariables[] ;    IF attributes.twoSided THEN putMessage[iTwoSided] ELSE putMessage[iOneSided] ;    IF NOT DiagnosticDiskInDrive[] THEN    BEGIN      IF getYesOrNo[yIsItDiagDisk] = no THEN getConfirmation[cInsertDiagDisk] ;    END ;    OldMPCode ¬ ProcessorFace.mp ;    ProcessorFace.SetMP[3000] ;    InitializePublicVariables[] ;    ClearLog[] ;                CheckCylinderZero[] ;        SetNewContext[NormalContext] ;    FOR test : TestType IN [readStatus..readSector] DO      DoDiskTest[test, StandardTestTrys[test]] ;    ENDLOOP ;    TestDiagnosticCylinder[];        IF BadDiagnosticCylinder THEN {       putMessage[yLast];       IF badOpCnt = 0 THEN badOpCnt ¬ 1; };            FigureOutAndSetFinalMPCode[] ;        IF badOpCnt # 0 THEN { putMessage[xExtraMessage2];                           putMessage[xExtraMessage3];			   floppyReturn ¬ floppyFailure; }		    ELSE   putMessage[xExtraMessage5];      RETURN ;  EXITS          QuitNow =>	BEGIN	  ProcessorFace.SetMP[OldMPCode] ;	  floppyReturn ¬ deviceNotReady;	  RETURN ;	END ;      UserAction =>	BEGIN	  putMessage[hCRC1];	  putMessage[hCRC2];	  putMessage[hObser2];	  putMessage[hCRCErr];	  putMessage[hLast];	  putMessage[hIllglStat];	  ProcessorFace.SetMP[OldMPCode] ;	  floppyReturn ¬ floppyFailure;	  RETURN ;	END ;	  END ;-- ****************************************************************************--		these really belong in the floppy channel-- ****************************************************************************  HonestReadID : PROCEDURE [ handle : Handle ] RETURNS [ status : Status, header : RecordID ] =  BEGIN--  reads first header on current track ( = cylinder & head ) unfortunately, we can't fake it  END ;  Recalibrate : PROCEDURE [ handle : Handle ] RETURNS [ status : Status ] =  BEGIN    CurrentContext : Context ¬ GetContext[handle] ;    [] ¬ SetContext[handle, Track0Context] ;    [status, ] ¬ SeekAndReadID[ handle, Track0Address ] ;		-- fake it as best as we can    [] ¬ SetContext[handle, CurrentContext] ;  END ;  Seek : PROCEDURE [ handle : Handle, address : DiskAddress ] RETURNS [ status : Status ] =  BEGIN    [status,] ¬ SeekAndReadID[handle, address] ;			-- fake it as best as we can  END ;-- ****************************************************************************--		Support PROCEDURES for OnlineDiagnosticsImpl-- ****************************************************************************  AllocateDataBuffer : PROCEDURE [ size : CARDINAL ] RETURNS [ db : DataBuffer ] =  BEGIN    db.BASE ¬ Space.ScratchMap[(size+Environment.wordsPerPage-1)/Environment.wordsPerPage] ;    db.LENGTH ¬ size ;  END ;  CheckCylinderZero : PROCEDURE =  BEGIN    IF ReadTestCylinder[0] > 0 THEN    BEGIN      SIGNAL BadCylinder0 ;    END ;  END ;  ClearDataBuffer : PROCEDURE [ db : DataBuffer ] =  BEGIN    FOR i : CARDINAL IN [0..db.LENGTH) DO      db[i] ¬ 0 ;    ENDLOOP ;  END ;  ClearLog : PROCEDURE =  BEGIN    LoggingOn ¬ TRUE ;    BadDiagnosticCylinder ¬ FALSE ;    BadSectorsOnDisk ¬ FALSE ;    BadTracksOnDisk ¬ FALSE ;    NumberOfBadTracks ¬ 0 ;    NumberOfDataErrors ¬ 0 ;    NumberOfHardErrors ¬ 0 ;    NumberOfSoftErrors ¬ 0 ;    hdZeroErrs ¬ 0;    hdOneErrs ¬ 0;    badOpCnt ¬ 0;    totalAccesses ¬ 0;    ErrorLog ¬ ALL[0] ;    SummaryLog^ ¬ ALL[ALL[0]] ;    addrLogStatus ¬ ALL[tLast];    addrLog^ ¬ ALL[ALL[0]];      END ;  CompareDataBuffers : PROCEDURE [ db1, db2 : DataBuffer, NumberOfWordsToCompare : INTEGER ¬ -1 ] RETURNS [ differences : CARDINAL ¬ 0 ] =  BEGIN    IF NumberOfWordsToCompare = -1 THEN NumberOfWordsToCompare ¬ MIN[db1.LENGTH, db2.LENGTH] ;    FOR i : INTEGER IN [0..NumberOfWordsToCompare) DO      IF db1[i] # db2[i] THEN differences ¬ differences + 1 ;    ENDLOOP ;  END ;  ConvertStatusToDisplayStatus : PROCEDURE [ status : Status ] RETURNS [ newStatus : DisplayStatusType ] =  BEGIN    SELECT status FROM      goodCompletion => newStatus ¬ GoodCompletion ;      diskChange => newStatus ¬ DiskChange ;      notReady => newStatus ¬ NotReady ;      cylinderError => newStatus ¬ CylinderError ;      deletedData => newStatus ¬ DeletedData ;      recordNotFound => newStatus ¬ RecordNotFound ;      headerError => newStatus ¬ HeaderError ;      dataError => newStatus ¬ DataError ;      dataLost => newStatus ¬ DataLost ;      writeFault => newStatus ¬ WriteFault ;    ENDCASE => newStatus ¬ OtherError ;  END ;  CopyDataBuffer : PROCEDURE [ buffer1, buffer2 : DataBuffer ] =	-- b1^ ¬ b2  BEGIN    Inline.LongCOPY[buffer2.BASE, MIN[buffer1.LENGTH, buffer2.LENGTH], buffer1.BASE] ;  END ;  DeallocateDataBuffer : PROCEDURE [ db : DataBuffer ] =  BEGIN    [] ¬ Space.Unmap[db.BASE] ;  END ;  DoDiskTest : PROCEDURE [ test : TestType, NumberOfTries : CARDINAL ] =  BEGIN    address : DiskAddress ;    status : Status ;    FOR i : CARDINAL IN [1..NumberOfTries] DO      address ¬ GenerateRandomDiskAddress[] ;            SELECT test FROM	readStatus =>	  BEGIN	    status ¬ Nop[CurrentHandle] ;	  END ;	SeekAndVerify =>	  BEGIN	    status ¬ SeekAndVerify[CurrentHandle, address] ;	    	  END ;	readSector =>	  BEGIN	    [status,] ¬ ReadSectors[CurrentHandle, address, MainDataBuffer.BASE, 1, TRUE] ;	  END ;	writeSectors =>	  BEGIN	    DataErrors : CARDINAL ;	    [status, DataErrors] ¬ WriteAndVerifySector[address] ;	    NumberOfDataErrors ¬ NumberOfDataErrors + DataErrors ;	    IF DataErrors # 0 THEN status ¬ otherError; 	  END ;	writeDeletedSector =>	  BEGIN	    [status,] ¬ WriteDeletedSectors[CurrentHandle, address, MainDataBuffer.BASE, 1, TRUE] ;	  END ;      ENDCASE ;      Log[test, status, address] ;      ExitOnFatalErrors[status] ;    ENDLOOP ;  END ;  DiagnosticDiskInDrive : PROCEDURE RETURNS [ yes : BOOLEAN ] =  BEGIN    status : Status ;    DiagnosticIDSector : DiskAddress ¬ [DiagnosticCylinder, FirstHead, DiagnosticDiskIDSector] ;    SetNewContext[NormalContext] ;    GenerateDiagnosticIDBuffer[DiagnosticDiskIDBuffer] ;    [status,] ¬ ReadSectors[CurrentHandle, DiagnosticIDSector, MainDataBuffer.BASE, 1, TRUE] ;    ExitOnFatalErrors[status];    IF status # goodCompletion THEN RETURN [ FALSE ] ;        yes ¬ CompareDataBuffers[MainDataBuffer, DiagnosticDiskIDBuffer] < 2 ;  END ;  ExitOnFatalErrors : PROCEDURE [ status : Status ] =  BEGIN    SELECT status FROM      goodCompletion =>	BEGIN	END ;      diskChange =>	BEGIN	  SIGNAL StopTest[hDiskChng] ;	END ;      notReady =>	BEGIN	  SIGNAL StopTest[iUnitNotReady] ;	END ;      cylinderError =>	BEGIN	END ;      deletedData =>	BEGIN	END ;      recordNotFound =>	BEGIN	END ;      headerError =>	BEGIN	END ;      dataError =>	BEGIN	END ;      dataLost =>	BEGIN	END ;      writeFault =>	BEGIN	  SIGNAL StopTest[hWritePro] ;	END ;      otherError =>	BEGIN	END ;    ENDCASE  =>	BEGIN	END ;  END ;  FigureOutAndSetFinalMPCode : PROCEDURE =  BEGIN--  analyze log & set mp code    ProcessorFace.SetMP[OldMPCode] ;  END ;  FindAndSetContextForTrack : PROCEDURE [ TrackAddress : DiskAddress ] =  BEGIN    OldContext : Context ¬ GetContext[CurrentHandle] ;    recordID : RecordID ;    status : Status ;    TrackContext : Context ;        << these two initial situations are sufficient assuming this  >>    << routine is called only through CheckCylinderZero           >>        IF TrackAddress = Track0Address THEN BEGIN          IF SetContext[CurrentHandle, Track0Context] THEN {	  [status, recordID] ¬ SeekAndReadID[CurrentHandle, TrackAddress];	  ExitOnFatalErrors[status];	  IF recordID.sectorLength = Track0Context.sectorLength THEN {	      SetNewContext[Track0Context];	      RETURN; }; };    END;	          IF TrackAddress = Track1Address THEN BEGIN          IF SetContext[CurrentHandle, Track1Context] THEN {	  [status, recordID] ¬ SeekAndReadID[CurrentHandle, TrackAddress];	  ExitOnFatalErrors[status];	  IF recordID.sectorLength = Track1Context.sectorLength THEN {	      SetNewContext[Track1Context];	      RETURN; }; };    END;	         TrackContext ¬ OldContext ;    [status, recordID] ¬ SeekAndReadID[CurrentHandle, TrackAddress] ;    ExitOnFatalErrors[status] ;    IF  status = goodCompletion    AND recordID.sectorLength # UnknownSectorLength THEN    BEGIN      TrackContext.sectorLength ¬ recordID.sectorLength ;      IF SetContext[CurrentHandle, TrackContext] THEN      BEGIN        SetNewContext[TrackContext] ;        RETURN ;      END ;    END ;    FOR theFormat : Format IN Format DO      FOR theDensity : Density IN Density DO       FOR theSectorLength : CARDINAL IN [0..NumberOfValidSectorLengths) DO	TrackContext.format ¬ theFormat ;	TrackContext.density ¬ theDensity ;	TrackContext.sectorLength ¬ ValidSectorLengths[theSectorLength];	IF SetContext[CurrentHandle, TrackContext] THEN	BEGIN	  InitializePublicVariables[] ;	  [status, recordID] ¬ SeekAndReadID[CurrentHandle, TrackAddress] ;	  IF status = goodCompletion THEN	  BEGIN	    IF recordID.sectorLength # UnknownSectorLength THEN	    BEGIN	      TrackContext.sectorLength ¬ recordID.sectorLength ;	      IF SetContext[CurrentHandle, TrackContext] THEN	      BEGIN		SetNewContext[TrackContext] ;		RETURN ;	      END ;	    END ELSE BEGIN	      TrackAddress.sector ¬ recordID.address.sector ;	      FOR LengthIndex : CARDINAL IN [0..NumberOfValidSectorLengths) DO		TrackContext.sectorLength ¬ ValidSectorLengths[LengthIndex] ;		IF SetContext[CurrentHandle, TrackContext] THEN		BEGIN		  [status,] ¬ ReadSectors[CurrentHandle, TrackAddress, MainDataBuffer.BASE, 1, TRUE] ;		  IF status = goodCompletion THEN		  BEGIN		    SetNewContext[TrackContext] ;		    RETURN ;		  END ;		END ;	      ENDLOOP ;	    END ;	  END ;	END ;       ENDLOOP;      ENDLOOP ;    ENDLOOP ;      	    SetNewContext[OldContext] ;    SIGNAL BadContext ;      END ;  FormatDisk : PROCEDURE =  BEGIN    count : CARDINAL ;    status : Status ;            InitializePublicVariables[] ;    SELECT attributes.deviceType FROM      DeviceTypesExtras.anyFloppy =>	BEGIN	  SIGNAL UnknownDeviceType ;	END ;      DeviceTypes.sa800,      DeviceTypesExtras.sa455,      DeviceTypesExtras3.sa475,              -- SPL add sa475                          DeviceTypesExtras.sa850 =>	BEGIN	  SetNewContext[Track0Context] ;	  [status, count] ¬ FormatTracks[CurrentHandle, Track0Address, 1] ;	  ExitOnFatalErrors[status] ;	  IF status # goodCompletion THEN SIGNAL CantFormatTrack[Track0Address] ;	  IF attributes.twoSided THEN	  BEGIN	    SetNewContext[Track1Context] ;	    [status, count] ¬ FormatTracks[CurrentHandle, Track1Address, 1] ;	    ExitOnFatalErrors[status] ;	    IF status # goodCompletion THEN SIGNAL CantFormatTrack[Track1Address] ;	  END ;	END ;	    <<  DeviceTypesExtras.sa455 =>	BEGIN	  SetNewContext[NormalContext] ;	  [status, count] ¬ FormatTracks[CurrentHandle, Track0Address, 1] ;	  ExitOnFatalErrors[status] ;	  IF status # goodCompletion THEN SIGNAL CantFormatTrack[Track0Address] ;	  address ¬ Track0Address;	  FOR aSector : SectorCount IN [FirstSector..LastSector] DO             address.sector ¬ aSector ;             [status,] ¬ ReadSectors[CurrentHandle, address, MainDataBuffer.BASE, 1, TRUE] ;	     ExitOnFatalErrors[status] ;             IF status # goodCompletion THEN 	           Log[readSector, status, address];           ENDLOOP ;	  IF attributes.twoSided THEN	  BEGIN	    SetNewContext[NormalContext] ;	    [status, count] ¬ FormatTracks[CurrentHandle, Track1Address, 1] ;	    ExitOnFatalErrors[status] ;	    IF status # goodCompletion THEN SIGNAL CantFormatTrack[Track1Address] ;	    address ¬ Track1Address;	    FOR aSector : SectorCount IN [FirstSector..LastSector] DO               address.sector ¬ aSector ;               [status,] ¬ ReadSectors[CurrentHandle, address, MainDataBuffer.BASE, 1, TRUE] ;	       ExitOnFatalErrors[status] ;               IF status # goodCompletion THEN 	            Log[readSector, status, address];             ENDLOOP ;	  END ;	END ;     >> 		    ENDCASE => SIGNAL UnknownDeviceType ;    SetNewContext[NormalContext] ;    FOR cyl : CARDINAL IN [1..DiagnosticCylinder] DO      [status, count] ¬ FormatTracks[CurrentHandle, [cyl, 0, 1], 1] ;      ExitOnFatalErrors[status] ;      IF status # goodCompletion THEN SIGNAL CantFormatTrack[[cyl, 0, 1]] ;    ENDLOOP ;    IF attributes.twoSided THEN    BEGIN      FOR cyl : CARDINAL IN [1..DiagnosticCylinder] DO	[status, count] ¬ FormatTracks[CurrentHandle, [cyl, 1, 1], 1] ;	ExitOnFatalErrors[status] ;	IF status # goodCompletion THEN SIGNAL CantFormatTrack[[cyl, 1, 1]] ;      ENDLOOP ;    END ;  END ;  GenerateDiagnosticIDBuffer : PROCEDURE [ DiagnosticIDBuffer : DataBuffer ] =  BEGIN    DataPattern : ARRAY [0..8) OF CARDINAL =    [      0,      177777B,      052525B,      125252B,      031463B,      146314B,      000401B,      177376B    ] ;    DiagnosticIDBuffer[0] ¬     SELECT attributes.deviceType FROM      DeviceTypesExtras.anyFloppy => LAST[CARDINAL],      DeviceTypes.sa800,      DeviceTypesExtras.sa850 => 850,      DeviceTypesExtras.sa455 => 455,      DeviceTypesExtras3.sa475 => 475      -- SPL add sa475    ENDCASE => 0 ;    DiagnosticIDBuffer[1] ¬ 1 ;		-- ????    DiagnosticIDBuffer[2] ¬ DiagnosticCylinder ;    DiagnosticIDBuffer[3] ¬ FirstHead ;    FOR i : CARDINAL IN [4..DiagnosticIDBuffer.LENGTH) DO       DiagnosticIDBuffer[i] ¬ DataPattern[i/32]    ENDLOOP ;  END ;  GenerateRandomDataBuffer : PROCEDURE [ db : DataBuffer, dbLength : INTEGER ¬ -1 ] =  BEGIN    IF dbLength = -1 THEN dbLength ¬ db.LENGTH ;    FOR i : INTEGER IN [0..dbLength) DO       db[i] ¬ RandomNumber[] ;    ENDLOOP ;  END ;  GenerateRandomDiskAddress : PROCEDURE RETURNS [ address : DiskAddress ] =  BEGIN    OPEN address ;    cylinder ¬ ( RandomNumber[] MOD LastCylinder ) + 1 ;	-- want cylinder IN [1..DiagnosticCylinder-1]    head ¬ 0 ;    IF attributes.twoSided AND RandomBoolean[] THEN head ¬ 1 ;    sector ¬ ( RandomNumber[] MOD LastSector ) + 1 ;  END ;  GenerateWorstCaseDataBuffer : PROCEDURE [ db : DataBuffer, dbLength : INTEGER ¬ -1 ] =  BEGIN    WorstCaseDataPattern : CARDINAL = 6D6DH ;    IF dbLength = -1 THEN dbLength ¬ db.LENGTH ;    FOR i : INTEGER IN [0..dbLength) DO      db[i] ¬ WorstCaseDataPattern ;    ENDLOOP ;  END ;  InitializePublicVariables : PROCEDURE =  BEGIN      -- will need added code to deatl with 1.2M floppy issues      IF CurrentDrive = nullDrive THEN SIGNAL NoDiskDrive ;    CurrentHandle ¬ GetHandle[CurrentDrive] ;    attributes ¬ GetDeviceAttributes[CurrentHandle] ;    LastCylinder ¬ attributes.numberOfCylinders - 2 ;    LastHead ¬ attributes.numberOfHeads - 1 ;    LastSector ¬ attributes.maxSectorsPerTrack ;    DiagnosticCylinder ¬ attributes.numberOfCylinders - 1 ;    stopOnErrFlag ¬ FALSE; -- STC, 18-Oct-87 10:42:10  END ;  ListDrivesAndAskWhichOneTheyWant : PROCEDURE [ getYesOrNo : GetYesOrNoProc ] =  BEGIN    MaxNumberOfDrives : CARDINAL = 4 ;    NumberOfDrives : CARDINAL ¬ 0 ;    Drives : ARRAY [0..MaxNumberOfDrives) OF Drive ;    DriveMessages : ARRAY [0..MaxNumberOfDrives) OF FloppyMessage = [ xUseDrive0, xUseDrive1, xUseDrive2, xUseDrive3 ] ;    CurrentDrive ¬ nullDrive ;    NumberOfDrives ¬ 0 ;    FOR i : CARDINAL IN [1..MaxNumberOfDrives] DO      CurrentDrive ¬ GetNextDrive[CurrentDrive] ;    IF CurrentDrive = nullDrive THEN EXIT ;      Drives[NumberOfDrives] ¬ CurrentDrive ;      NumberOfDrives ¬ NumberOfDrives + 1 ;    ENDLOOP ;    SELECT NumberOfDrives FROM      0 => SIGNAL NoDiskDrive ;      1 => CurrentDrive ¬ Drives[0] ;    ENDCASE =>      BEGIN	FOR DriveNumber : CARDINAL IN [0..NumberOfDrives) DO	  IF getYesOrNo[DriveMessages[DriveNumber]] = yes THEN	  BEGIN	    CurrentDrive ¬ Drives[DriveNumber] ;	    RETURN ;	  END ;	ENDLOOP ;	SIGNAL NoDiskDrive ;      END ;  END ;  Log : PROCEDURE [ test : TestType, status : Status, logAddr: DiskAddress] =	-- should we pass in the DiskAddress & log bad sectors ?  BEGIN    totalAccesses ¬ totalAccesses + 1;    IF LoggingOn THEN    BEGIN      displayStatus : DisplayStatusType ¬ ConvertStatusToDisplayStatus[status] ;      SummaryLog[test][TimesExecuted] ¬ SummaryLog[test][TimesExecuted] + 1 ;      SummaryLog[test][displayStatus] ¬ SummaryLog[test][displayStatus] + 1 ;      IF status # goodCompletion THEN {                ErrorLog[test] ¬ ErrorLog[test] + 1 ;      -- where is this used??	       	       IF logAddr.head = 0 THEN hdZeroErrs ¬ hdZeroErrs + 1 	                           ELSE hdOneErrs ¬ hdOneErrs + 1;				   	       IF badOpCnt < 24 THEN {	         addrLog[0][badOpCnt] ¬ LOOPHOLE[ORD[test]];	         addrLog[1][badOpCnt] ¬ LOOPHOLE[logAddr.cylinder];		 addrLog[2][badOpCnt] ¬ LOOPHOLE[logAddr.head];	         addrLog[3][badOpCnt] ¬ LOOPHOLE[logAddr.sector];		 addrLog[4][badOpCnt] ¬ totalAccesses;		 SELECT status FROM 		   goodCompletion =>	             addrLogStatus[badOpCnt] ¬ hGoodComp;                   diskChange =>	             addrLogStatus[badOpCnt] ¬ hDiskChng;                   notReady =>	             addrLogStatus[badOpCnt] ¬ xNotReady;                   cylinderError =>	             addrLogStatus[badOpCnt] ¬ hSeekErr;                   deletedData =>	             addrLogStatus[badOpCnt] ¬ hDelSector;                   recordNotFound =>	             addrLogStatus[badOpCnt] ¬ xRecordNotFound;                   headerError =>	             addrLogStatus[badOpCnt] ¬ xHeaderError;                   dataError =>		     addrLogStatus[badOpCnt] ¬ xDataError;	           dataLost =>		     addrLogStatus[badOpCnt] ¬ xDataLost;	           writeFault =>		     addrLogStatus[badOpCnt] ¬ hWritePro;	           otherError =>		     addrLogStatus[badOpCnt] ¬ xOtherError;	           ENDCASE  =>	              BEGIN	              END ;		      		   		  	         badOpCnt ¬ badOpCnt + 1; 		 IF stopOnErrFlag AND (status # goodCompletion) THEN		 	SIGNAL stopOnErrorAndError;}	      << %KL ELSE {	         -- MESSAGE		 SIGNAL NoDiskDrive		 } >>;	       };	           END ;  END ;  RandomBoolean : PROCEDURE RETURNS [ BOOLEAN ] =  BEGIN    RETURN [ RandomNumber[] >= LAST[CARDINAL] ] ;  END ;  RandomNumber : PROCEDURE RETURNS [ CARDINAL ] =	-- from Knuth Vol. 2, first edition, section 3.6  BEGIN    a : LONG CARDINAL = ((LAST[LONG CARDINAL]/797) * 8) + 5 ;    c : LONG CARDINAL = ((LAST[LONG CARDINAL]/47) * 10) + 1 ;    RandomState ¬ ( a * RandomState ) + c ;    RETURN [ Inline.HighHalf[ RandomState ] ] ;  END;  ReadTestCylinder : PROCEDURE [ cylinder : CARDINAL ] RETURNS [ NumberOfBadSectorsOnCylinder : CARDINAL ¬ 0 ] =  BEGIN    address : DiskAddress ;    address ¬ [cylinder, 0, 1] ;    FindAndSetContextForTrack[address] ;    NumberOfBadSectorsOnCylinder ¬ ReadTestTrack[address] ;    IF attributes.twoSided THEN    BEGIN      address ¬ [cylinder, 1, 1] ;      FindAndSetContextForTrack[address] ;      NumberOfBadSectorsOnCylinder ¬ NumberOfBadSectorsOnCylinder + ReadTestTrack[address] ;    END ;  END ;<<  ReadTestSector : PROCEDURE [ address : DiskAddress, NumberOfSectors : CARDINAL ] RETURNS [ status : Status ] =	-- assumes you've called SetNewContext  BEGIN    buffer : DataBuffer ¬ AllocateDataBuffer[GetContext[CurrentHandle].sectorLength * NumberOfSectors] ;    [status,] ¬ ReadSectors[CurrentHandle, address, buffer.BASE, NumberOfSectors, TRUE] ;    DeallocateDataBuffer[buffer] ;  END ;>>  ReadTestTrack : PROCEDURE [ address : DiskAddress ] RETURNS [ NumberOfBadSectorsOnTrack : CARDINAL ¬ 0 ] =	-- assumes you've called SetNewContext  BEGIN    status : Status ;    FOR aSector : SectorCount IN [FirstSector..LastSector] DO      address.sector ¬ aSector ;      [status,] ¬ ReadSectors[CurrentHandle, address, MainDataBuffer.BASE, 1, TRUE] ;      Log[readSector, status, address] ;      ExitOnFatalErrors[status] ;      IF status # goodCompletion THEN NumberOfBadSectorsOnTrack ¬ NumberOfBadSectorsOnTrack + 1 ;    ENDLOOP ;  END ;  SetNewContext : PROCEDURE [ context : Context ] =  BEGIN    IF CurrentDrive = nullDrive THEN SIGNAL NoDiskDrive ;    CurrentHandle ¬ GetHandle[CurrentDrive] ;    IF NOT SetContext[CurrentHandle, context] THEN SIGNAL BadContext ;    CurrentContext ¬ context ;    InitializePublicVariables[] ;  END ;  SeekAndReadID : PROCEDURE [ handle : Handle, address : DiskAddress ] RETURNS [ status : Status, recordID : RecordID ] =  BEGIN<<    status ¬ Seek[handle, address] ;    [status, recordID] ¬ ReadID[handle] ;>>    Buffer : PACKED ARRAY [1..10] OF Environment.Byte ;    cntr: CARDINAL;    rdy: BOOLEAN;    status ¬ ReadID[handle, address, @Buffer] ;       -- fake some ugly internal retry    IF status = notReady THEN {      cntr ¬ 0;      rdy ¬ FALSE;      WHILE cntr < 5 AND rdy # TRUE DO {        status ¬ ReadID[handle, address, @Buffer] ;	IF status = notReady THEN 	   cntr ¬ cntr + 1	ELSE	   rdy ¬ TRUE; };      ENDLOOP; };          ExitOnFatalErrors[status] ;    SELECT attributes.deviceType FROM      DeviceTypesExtras.anyFloppy =>	BEGIN	  SIGNAL UnknownDeviceType ;	END ;      DeviceTypes.sa800,      DeviceTypesExtras.sa850 =>	BEGIN	  recordID.address ¬ [ Buffer[1], Buffer[2], Buffer[3] ] ;	  recordID.sectorLength ¬ 	  SELECT Buffer[4] FROM	    0 =>  64,	    1 => 128,	    2 => 256,	    3 => 512,	  ENDCASE => UnknownSectorLength ;	  recordID.MachineDependentBytes[1] ¬ Buffer[5] ;	  recordID.MachineDependentBytes[2] ¬ Buffer[6] ;	END ;      DeviceTypesExtras3.sa475,                -- SPL add sa475      DeviceTypesExtras.sa455 =>	BEGIN	  ptr : POINTER TO RecordID ¬ LOOPHOLE[@Buffer] ;	  recordID ¬ ptr^ ;	END ;    ENDCASE =>      BEGIN	SIGNAL UnknownDeviceType ;      END ;  END ;  SeekAndVerify : PROCEDURE [ handle : Handle, address : DiskAddress ] RETURNS [ status : Status ] =  BEGIN    recordID : RecordID ;    [status, recordID] ¬ SeekAndReadID[handle, address] ;    ExitOnFatalErrors[status] ;    IF status = goodCompletion THEN    BEGIN      SELECT TRUE FROM	address.cylinder # recordID.address.cylinder => status ¬ cylinderError ;	address.head # recordID.address.head => status ¬ recordNotFound ;      ENDCASE ;    END ;  END ;  TestDiagnosticCylinder: PROCEDURE =  BEGIN    address : DiskAddress ;    DataErrors : CARDINAL ;    status : Status ;    dataDiffs: CARDINAL ¬ 0;    address ¬ [DiagnosticCylinder, FirstHead, FirstSector] ;    SetNewContext[NormalContext] ;        IF WriteTestTrack[address] > 0 THEN      BEGIN	BadDiagnosticCylinder ¬ TRUE ;      END ;          IF attributes.twoSided THEN    BEGIN      address ¬ [DiagnosticCylinder, LastHead, FirstSector] ;      IF WriteTestTrack[address] > 0 THEN      BEGIN	BadDiagnosticCylinder ¬ TRUE ;      END ;    END ;    address ¬ [DiagnosticCylinder, FirstHead, FirstSector] ;    [status, DataErrors] ¬ WriteVerifySectors[address, MaxSectorsToTransfer] ;    Log[writeSectors, status, address] ;    ExitOnFatalErrors[status] ;    NumberOfDataErrors ¬ NumberOfDataErrors + DataErrors ;    IF NumberOfDataErrors > 0 THEN      BEGIN	BadDiagnosticCylinder ¬ TRUE ;      END ;        -- write diag sectors    GenerateDiagnosticIDBuffer[DiagnosticDiskIDBuffer] ;    [status,] ¬ WriteSectors[CurrentHandle, [DiagnosticCylinder, FirstHead, DiagnosticDiskIDSector], DiagnosticDiskIDBuffer.BASE, 1, TRUE] ;    ExitOnFatalErrors[status] ;    IF status # goodCompletion THEN BadDiagnosticCylinder ¬ TRUE ;    IF attributes.twoSided THEN {      [status,] ¬ WriteSectors[CurrentHandle, [DiagnosticCylinder, LastHead, DiagnosticDiskIDSector], DiagnosticDiskIDBuffer.BASE, 1, TRUE] ;      ExitOnFatalErrors[status] ;      IF status # goodCompletion THEN BadDiagnosticCylinder ¬ TRUE ; };  END ;  WriteTestTrack : PROCEDURE [ address : DiskAddress ] RETURNS [ NumberOfBadSectorsOnTrack : CARDINAL ¬ 0 ] =	-- assumes you've called SetNewContext  BEGIN    DataDifferences : CARDINAL ¬ 0 ;    status : Status ;    [status,] ¬ FormatTracks[CurrentHandle, address, 1] ;    ExitOnFatalErrors[status] ;    IF status # goodCompletion THEN SIGNAL CantFormatTrack[address] ;    FOR aSector : SectorCount IN [FirstSector..LastSector] DO      address.sector ¬ aSector ;      [status, DataDifferences] ¬ WriteAndVerifySector[address] ;      Log[writeSectors, status, address] ;      ExitOnFatalErrors[status] ;      IF status # goodCompletion THEN NumberOfBadSectorsOnTrack ¬ NumberOfBadSectorsOnTrack + 1 ;      NumberOfDataErrors ¬ NumberOfDataErrors + DataDifferences ;      [status,] ¬ WriteDeletedSectors[CurrentHandle, address, MainDataBuffer.BASE, 1, TRUE] ;      Log[writeDeletedSector, status, address] ;      ExitOnFatalErrors[status] ;      IF status # goodCompletion THEN NumberOfBadSectorsOnTrack ¬ NumberOfBadSectorsOnTrack + 1 ;    ENDLOOP ;    [status,] ¬ FormatTracks[CurrentHandle, address, 1] ;    ExitOnFatalErrors[status] ;    IF status # goodCompletion THEN SIGNAL CantFormatTrack[address] ;  END ;  WriteAndVerifySector : PROCEDURE [ address : DiskAddress ] RETURNS [ status : Status, DataDifferences : CARDINAL ¬ 0 ] =  BEGIN    GenerateRandomDataBuffer[MainDataBuffer] ;    CopyDataBuffer[TempDataBuffer, MainDataBuffer] ;    [status,] ¬ WriteSectors[CurrentHandle, address, MainDataBuffer.BASE, 1, TRUE] ;    ExitOnFatalErrors[status] ;    IF status # goodCompletion THEN RETURN ;    ClearDataBuffer[MainDataBuffer] ;    [status,] ¬ ReadSectors[CurrentHandle, address, MainDataBuffer.BASE, 1, TRUE] ;    ExitOnFatalErrors[status] ;        DataDifferences ¬ CompareDataBuffers[TempDataBuffer, MainDataBuffer, CurrentContext.sectorLength] ;  END ;  WriteVerifySectors : PROCEDURE [ address : DiskAddress, NumberOfSectors : CARDINAL ] RETURNS [ status : Status, DataDifferences : CARDINAL ¬ 0 ] =	-- assumes you've called SetNewContext  BEGIN    GenerateWorstCaseDataBuffer[MainDataBuffer] ;    CopyDataBuffer[TempDataBuffer, MainDataBuffer] ;    [status,] ¬ WriteSectors[CurrentHandle, address, MainDataBuffer.BASE, NumberOfSectors, TRUE] ;    ExitOnFatalErrors[status] ;    IF status # goodCompletion THEN RETURN ;    ClearDataBuffer[MainDataBuffer] ;    [status,] ¬ ReadSectors[CurrentHandle, address, MainDataBuffer.BASE, NumberOfSectors, TRUE] ;    ExitOnFatalErrors[status] ;    DataDifferences ¬ CompareDataBuffers[TempDataBuffer, MainDataBuffer, NumberOfSectors*CurrentContext.sectorLength] ;  END ;END.LOGEdited on 10-Jan-86 13:46:12 by SPL change floppy formatEdited on 24-Feb-86  9:21:24 by SPL add routines for OnlineDiagnosticsExtraEdited on  3-Mar-86  9:14:24 by SPL fix context find and set routine Edited on  17-Mar-86  9:58:05 by SPL add retry to SeekAndReadIDEdited on  19-Mar-86  8:39:06 by SPL modify FindAndSetContext for two casesEdited on  21-Jan-87 18:05:44 by SPL stopOnErrorAndError for AR # 10158Edited on   9-Feb-87 13:43:32 by SPL add sa475 support for AR # 1024218-Oct-87 10:39:50 by STC, fix bug in SIGNAL stopOnErrorAndErro causing CRASH!29-Aug-91 10:35:19 by dchen, fixed format problem which is that if user select drive 2 it will still access drive 1
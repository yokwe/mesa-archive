-- FloppyTapeOnlineDiagnosticsImpl.mesa-- Last edited on    4-Feb-88 11:53:02 by RK--Copyright (C) 1987 by Xerox Corporation. All rights reserved.DIRECTORY FloppyTape			USING	[Format, AlreadyFormatted, Error,					 Retention, Scavenge, FeedBack,					 FeedBackPtr, MarkSectorBad, 					 GetNextBadSector, ErrorType, Drive,					 maxBytesInName], FloppyTapeExtras		USING	[nullDrive, GetNextFloppyTapeDrive], FloppyDiskFace			USING	[Status], Inline				USING	[LowHalf], VerifyRead			USING	[VRResultType, VerifyReadOperation, 					 EntryDispType, maxErrors, maxTries,					 ErrorLog, BadSectorTable, VRError], OnlineDiagnosticsExtraExtras	USING	[GetTextProc, PutMessageProc,					 PutTextProc, PutTimeStampMessageProc,					 GetConfirmationProc, GetYesOrNoProc,					 LookForAbortProc, PutNumberProc,					 GetNumberProc], String				USING	[Copy],				  Process			USING	[Pause, MsecToTicks, Abort]; FloppyTapeOnlineDiagnosticsImpl: PROGRAM  IMPORTS     FloppyTape,    FloppyTapeExtras,    Inline,    VerifyRead,    String,    Process  EXPORTS    OnlineDiagnosticsExtraExtras =BEGIN  OPEN Odee: OnlineDiagnosticsExtraExtras;--Private types  vrResult: VerifyRead.VRResultType;--Global constants and variables  localDrive: FloppyTape.Drive ¬ FloppyTapeExtras.nullDrive;  maxBadSectorEntries: CARDINAL = 256;  streamsPerTape: CARDINAL = 12;  tracksPerStream: CARDINAL = 245;  sectorsPerTrack: CARDINAL = 32;  sectorsPerStream: CARDINAL = tracksPerStream * sectorsPerTrack;  maxBytesInString: CARDINAL = FloppyTape.maxBytesInName;	--Public procedures  FlTapeFormat: PUBLIC PROCEDURE [    getText:		 Odee.GetTextProc,    putMessage:          Odee.PutMessageProc,    putText:		 Odee.PutTextProc,    putTimeStampMessage: Odee.PutTimeStampMessageProc,    getConfirmation:     Odee.GetConfirmationProc,    getYesOrNo:          Odee.GetYesOrNoProc,    lookForAbort:	 Odee.LookForAbortProc] =       BEGIN      DoFormat: PROCEDURE RETURNS [CARDINAL] =     BEGIN    FloppyTape.Format[localDrive, tapeName, clientWord, feedBackPtr !    FloppyTape.AlreadyFormatted => {       putMessage[alreadyFormat];       putMessage[tapeLabel, TRUE];       putText[labelString];        IF getYesOrNo[wishToContinue] = no          THEN {userTermin ¬ TRUE; CONTINUE};       IF getYesOrNo[stillSure] = no 		--Continue will go to Return[0], I think.         THEN {userTermin ¬ TRUE; CONTINUE};       RESUME};    FloppyTape.Error => {       errorMsg.errorOnFormat ¬ TRUE;       errorMsg.errorType ¬ error;       CONTINUE};    ABORTED => {       errorMsg.abortFormat ¬ TRUE;       CONTINUE}];    RETURN[0];		--Return DoFormat    END;   tapeName: LONG STRING ¬ [maxBytesInString];  clientWord: UNSPECIFIED ¬ 0;  getOut: BOOLEAN ¬ FALSE;  userAbort: BOOLEAN ¬ FALSE;		--Set by hitting stop key  userTermin: BOOLEAN ¬ FALSE;		--Set by "no" response to "wish to continue"  p: PROCESS RETURNS[CARDINAL];  joinP: CARDINAL;  ErrorMsg: TYPE = RECORD [	    abortFormat: BOOLEAN ¬ FALSE,            errorOnFormat: BOOLEAN ¬ FALSE,	    errorType: FloppyTape.ErrorType];  errorMsg: ErrorMsg;  feedBackPtr: FloppyTape.FeedBackPtr;  feedBack: FloppyTape.FeedBack;  oldFeedBack: FloppyTape.FeedBack;  feedBackPtr ¬ @feedBack;	        putMessage[warningFormat];  IF getYesOrNo[wishToContinue] = no THEN RETURN;  IF getYesOrNo[stillSure] = no THEN RETURN;    getConfirmation[readyAndWrEnable];  		--getConfirmation will display the message  		-- to "type any character when done."  getText[enterTapeLabel, tapeName];    p ¬ FORK DoFormat[];			    oldFeedBack ¬ none;    DO      IF oldFeedBack # feedBackPtr­ THEN	BEGIN	oldFeedBack ¬ feedBackPtr­;	SELECT oldFeedBack FROM	  retentionPass  => putTimeStampMessage[retentionTape];	  formatPass     => putTimeStampMessage[formatTape];	  verifyPass     => putTimeStampMessage[verifyFormat];	  ENDCASE;	IF oldFeedBack = none THEN EXIT;	--A change to none means format is done	END;      Process.Pause[Process.MsecToTicks[500]];  --Wait .5 seconds      IF (userAbort ¬ lookForAbort[]) = TRUE         THEN {Process.Abort[p]; EXIT};		--Raises ABORTED       IF userTermin = TRUE THEN EXIT;      IF errorMsg.errorOnFormat = TRUE THEN EXIT; --If Format ended in an error, get out    ENDLOOP;    joinP ¬ JOIN p;				--DoFormat always joins      IF errorMsg.abortFormat = TRUE THEN GOTO abort;  IF errorMsg.errorOnFormat = TRUE    THEN SELECT errorMsg.errorType FROM           badTape => GOTO bTape;           hardwareError => GOTO hError;           notReady => GOTO nRdy;           writeInhibited => GOTO wrInhib;           noSuchDrive => GOTO erDet;           volumeOpen => GOTO volOpen;           ENDCASE => GOTO erDet;  IF userTermin = FALSE THEN   --If TRUE then utility was user terminated.    BEGIN         putTimeStampMessage[successComplete];    putMessage[removeCartridge];    END;    RETURN;    EXITS    bTape =>       BEGIN        putMessage[formatFailed];	putMessage[mediaProblem];	RETURN;      END;    hError =>      BEGIN        putMessage[formatFailed];	putMessage[hardwareProblem];	RETURN;      END;    nRdy =>      BEGIN        putMessage[formatFailed];	putMessage[notReady];	RETURN;      END;    wrInhib =>      BEGIN        putMessage[formatFailed];	putMessage[writeProtect];	RETURN;      END;    volOpen =>      BEGIN        putMessage[formatFailed];	putMessage[driveInUse];		RETURN;      END;    erDet =>			--Other or unknown error has same       BEGIN			-- message as for hardware problem.        putMessage[formatFailed];	putMessage[hardwareProblem];	RETURN;      END;    abort =>      BEGIN        putMessage[testTerminated];	RETURN;      END;        END; --FlTapeFormat    FlTapeRetention: PUBLIC PROCEDURE [    putMessage:          Odee.PutMessageProc,    putTimeStampMessage: Odee.PutTimeStampMessageProc,    getConfirmation:     Odee.GetConfirmationProc] =       BEGIN    getConfirmation[ensureDriveReady];  putTimeStampMessage[retentionTape];    FloppyTape.Retention[localDrive  !	--change to localDrive    FloppyTape.Error => SELECT error FROM      writeInhibited => CONTINUE;   --File system raises an error.      volumeOpen  => GOTO volOpen; --Will file system really ever raise this?      noSuchDrive => GOTO hError;      notReady => GOTO nRdy;      ENDCASE => GOTO hError];    putMessage[successComplete];    RETURN;    EXITS    volOpen =>       BEGIN        putMessage[retentFailed];	putMessage[driveInUse];	RETURN;      END;    nRdy =>      BEGIN        putMessage[retentFailed];	putMessage[notReady];	RETURN;      END;    hError =>      BEGIN        putMessage[retentFailed];	putMessage[hardwareProblem];	RETURN;      END;    END; --FlTapeRetention     FlTapeVerifyRead: PUBLIC PROCEDURE [    putMessage:          Odee.PutMessageProc,    putText:		 Odee.PutTextProc,    putNumber:		 Odee.PutNumberProc,    putTimeStampMessage: Odee.PutTimeStampMessageProc,    getConfirmation:     Odee.GetConfirmationProc,    lookForAbort:	 Odee.LookForAbortProc,    debugSwitch:	 UNSPECIFIED ¬ 0] =       BEGIN  maxErrors: CARDINAL = VerifyRead.maxErrors;  maxTries: CARDINAL = VerifyRead.maxTries;  nullSector: LONG CARDINAL = 0;  stream: CARDINAL;  track: CARDINAL;  sector: CARDINAL;  badSector: LONG CARDINAL;  badSectorTable: VerifyRead.BadSectorTable;  userAbort: BOOLEAN;  dispString: LONG STRING ¬ [maxBytesInString];  errString: LONG STRING ¬ [maxBytesInString];  logPtr: LONG POINTER TO VerifyRead.ErrorLog;  badSectorPtr: LONG POINTER TO VerifyRead.BadSectorTable;  log: VerifyRead.ErrorLog;  logPtr ¬ @log;  badSectorPtr ¬ @badSectorTable;  	   putMessage[insertDiagTape];  getConfirmation[note];      --Get bad sectors  BEGIN    ENABLE	--to catch errors from GetNextBadSector call       FloppyTape.Error => SELECT error FROM        notReady => GOTO nRdy;	volumeOpen => GOTO volOpen;        ENDCASE => GOTO hError;	    putMessage[readTable];    badSector ¬ nullSector;    badSectorTable.count ¬ 0;    UNTIL (badSector ¬ FloppyTape.GetNextBadSector[localDrive, badSector])          = nullSector      DO        badSectorTable.count ¬ badSectorTable.count + 1;        badSectorTable.entry[badSectorTable.count] ¬ badSector;      ENDLOOP;     END;    IF (userAbort ¬ lookForAbort[]) = TRUE      THEN  GOTO abort;    IF debugSwitch # 3 THEN	--to avoid retention pass    BEGIN      ENABLE	--to catch errors from Retention call 	FloppyTape.Error => SELECT error FROM	  notReady => GOTO nRdy;	  volumeOpen => GOTO volOpen;	  ENDCASE =>  GOTO hError;	        putTimeStampMessage[retentionTape];      FloppyTape.Retention[localDrive];    END;      BEGIN    ENABLE	--to catch user abort      VerifyRead.VRError => SELECT error FROM	  abort =>    {putMessage[testTerminated];	  	       CONTINUE};	  ENDCASE =>  REJECT;	--other errors shouldn't occur        IF (userAbort ¬ lookForAbort[]) = TRUE      THEN  GOTO abort;      putTimeStampMessage[verifyRead];    vrResult ¬ VerifyRead.VerifyReadOperation[               logPtr, badSectorPtr, lookForAbort];        SELECT  vrResult FROM      success       => {putMessage[verifyPass];			putMessage[removeCartridge]};      tooManySoftError  => {putMessage[verifyFail];			putMessage[tooManySoft];			putMessage[callSupport]};      hardReadError => {putMessage[verifyFail];			putMessage[hardReadError, TRUE];			putNumber[logPtr.entry[logPtr.count].sector];			putMessage[callSupport]};	          hardwareError => {putMessage[verifyFail];			putMessage[hardwareProblem];			putMessage[callSupport]};	          ENDCASE;  END;        IF debugSwitch = 3 THEN    BEGIN    --print error log    IF logPtr.count = 0 THEN {putText["No errors"L]; RETURN};    FOR i: CARDINAL IN [1..logPtr.count]      DO      [stream, track, sector] ¬ PageToTapeAddress[logPtr.entry[i].sector];      SELECT logPtr.entry[i].entryDisp FROM        VerifyRead.EntryDispType.soft  =>	 	 String.Copy[dispString, "Soft error"L];	VerifyRead.EntryDispType.hard   =>	 	 String.Copy[dispString, "Hard read error"L]; 	VerifyRead.EntryDispType.hardware  =>	 	 String.Copy[dispString, "Hardware error"L];	VerifyRead.EntryDispType.verify  =>	 	 String.Copy[dispString, "Verify error"L];	ENDCASE;      putMessage[sector, TRUE];      putNumber [logPtr.entry[i].sector, 5, TRUE];      putMessage[stream, TRUE];       putNumber [stream, 2, TRUE];			      putMessage[track, TRUE]; 	      putNumber [track, 3, TRUE];			      putMessage[sector, TRUE];      putNumber [sector, 2, FALSE];      putText	[dispString, TRUE];      putText	[", "L, TRUE];      putNumber [logPtr.entry[i].tries, 2, TRUE];      FOR j: CARDINAL IN [1..logPtr.entry[i].tries]        DO	SELECT logPtr.entry[i].error[j] FROM	  inProgress  => String.Copy[errString, "inProgress"L];	  goodCompletion   => String.Copy[errString, "goodCompletion"L]; 	  diskChange  => String.Copy[errString, "diskChange"L];	  notReady  => String.Copy[errString, "notReady"L];	  cylinderError  => String.Copy[errString, "cylinderError"L];	  deletedData  => String.Copy[errString, "deletedData"L];	  recordNotFound  => String.Copy[errString, "recordNotFound"L];	  headerError  => String.Copy[errString, "headerError"L];	  dataError  => String.Copy[errString, "dataError"L];	  dataLost  => String.Copy[errString, "dataLost"L];	  writeFault  => String.Copy[errString, "writeFault"L];	  memoryError  => String.Copy[errString, "memoryError"L];	  invalidOperation  => String.Copy[errString, "invalidOperation"L];	  aborted  => String.Copy[errString, "aborted"L];	  otherError  => String.Copy[errString, "otherError"L];	  ENDCASE;	putText	[errString, TRUE];	putText	[" "L, TRUE];	ENDLOOP;      putText [" "L, FALSE]; --for CR      ENDLOOP;	      END;      RETURN;    EXITS    nRdy =>      BEGIN        putMessage[verifyFail];	putMessage[notReady];	RETURN;      END;    hError =>      BEGIN        putMessage[verifyFail];	putMessage[hardwareProblem];	RETURN;      END;    volOpen =>      BEGIN        putMessage[verifyFail];	putMessage[driveInUse];		RETURN;      END;    abort =>      BEGIN        putMessage[testTerminated];	RETURN;      END;   END;    FlTapeScavenge: PUBLIC PROCEDURE [    putMessage:          Odee.PutMessageProc,    putTimeStampMessage: Odee.PutTimeStampMessageProc,    getConfirmation:     Odee.GetConfirmationProc,    lookForAbort:	 Odee.LookForAbortProc] =       BEGIN    volumeOkay: BOOLEAN;    getConfirmation[readyAndWrEnable];  putTimeStampMessage[scavengeTape];    volumeOkay ¬ FloppyTape.Scavenge[localDrive !    FloppyTape.Error => SELECT error FROM       badTape => GOTO bTape;       hardwareError => GOTO hError;       notReady => GOTO nRdy;       writeInhibited => GOTO wrInhib;       noSuchDrive => GOTO erDet;       volumeOpen => GOTO volOpen;       notFormatted => GOTO nFormat;       ENDCASE => GOTO erDet];     IF volumeOkay = TRUE     THEN putMessage[successRepair]    ELSE {putMessage[unSuccessRepair];	  getConfirmation[removeCartridge]};    RETURN;    EXITS    bTape =>       BEGIN        putMessage[scavengeFailed];	putMessage[mediaProblem];	RETURN;      END;    hError =>      BEGIN        putMessage[scavengeFailed];	putMessage[hardwareProblem];	RETURN;      END;    nRdy =>      BEGIN        putMessage[scavengeFailed];	putMessage[notReady];	RETURN;      END;    wrInhib =>      BEGIN        putMessage[scavengeFailed];	putMessage[writeProtect];	RETURN;      END;    volOpen =>      BEGIN        putMessage[scavengeFailed];	putMessage[driveInUse];	RETURN;      END;    nFormat =>      BEGIN        putMessage[scavengeFailed];	putMessage[notFormat];	RETURN;      END;    erDet =>      BEGIN        putMessage[scavengeFailed];	putMessage[hardwareProblem];	RETURN;      END;     END; --FlTapeScavenge      FlTapeLogBadSector: PUBLIC PROCEDURE [    getNumber:		 Odee.GetNumberProc,    putMessage:          Odee.PutMessageProc,    putTimeStampMessage: Odee.PutTimeStampMessageProc,    getConfirmation:     Odee.GetConfirmationProc,    getYesOrNo:          Odee.GetYesOrNoProc] =       BEGIN    badSector: LONG CARDINAL;    getConfirmation[readyAndWrEnable];  badSector ¬ getNumber[sectorToEnter];  IF getYesOrNo[wishToContinue] = no THEN RETURN;  putMessage[enterToTable];    FloppyTape.MarkSectorBad [localDrive, badSector !    FloppyTape.Error => SELECT error FROM      badTape => GOTO bTape;      notFormatted => GOTO nFormat;      writeInhibited => GOTO wrInhib;      notReady => GOTO nRdy;      volumeOpen => GOTO volOpen;      ENDCASE => GOTO hError];        putMessage[successComplete];    RETURN;    EXITS    bTape =>       BEGIN        putMessage[logSectorFailed];	putMessage[mediaProblem];	RETURN;      END;    nFormat =>      BEGIN        putMessage[logSectorFailed];	putMessage[notFormat];	RETURN;      END;    wrInhib =>      BEGIN        putMessage[logSectorFailed];	putMessage[writeProtect];	RETURN;      END;    nRdy =>      BEGIN        putMessage[logSectorFailed];	putMessage[notReady];	RETURN;      END;    volOpen =>      BEGIN        putMessage[logSectorFailed];	putMessage[driveInUse];		RETURN;      END;    hError =>      BEGIN        putMessage[logSectorFailed];	putMessage[hardwareProblem];	RETURN;      END;     END; --FlTapeLogBadSector      FlTapeDisplayBadSectorTable: PUBLIC PROCEDURE [    putMessage:          Odee.PutMessageProc,    putNumber:		 Odee.PutNumberProc,    putTimeStampMessage: Odee.PutTimeStampMessageProc,    getConfirmation:     Odee.GetConfirmationProc] =       BEGIN  badSector: LONG CARDINAL;  nullSector: LONG CARDINAL = 0;  contents: ARRAY [1..maxBadSectorEntries] OF LONG CARDINAL;  count: CARDINAL;  i: CARDINAL;  stream: CARDINAL;  track: CARDINAL;  sector: CARDINAL;    getConfirmation[ensureDriveReady];  putMessage[readTable];    --routine to get contents of table:  BEGIN    ENABLE	--to catch errors from GetNextBadSector call       FloppyTape.Error => SELECT error FROM        badTape => GOTO bTape;        notFormatted => GOTO nFormat;        writeInhibited => GOTO wrInhib;        notReady => GOTO nRdy;	volumeOpen => GOTO volOpen;        ENDCASE => GOTO hError;    badSector ¬ nullSector;    count ¬ 0;    UNTIL (badSector ¬ FloppyTape.GetNextBadSector[localDrive, badSector])          = nullSector      DO        count ¬ count + 1;        contents[count] ¬ badSector;      ENDLOOP;     END;    --routine to display contents of table:  IF count = 0 THEN GOTO emptyOut;  putMessage[countIs, TRUE];  putNumber[count];  putMessage[badSectorTable];  i ¬ 1;  UNTIL i = count + 1 DO    [stream, track, sector] ¬ PageToTapeAddress[contents[i]];    putMessage[badSector, TRUE];	     putNumber [contents[i], 5, TRUE];			    putMessage[stream, TRUE];	     putNumber [stream, 2, TRUE];				    putMessage[track, TRUE];	 	    putNumber [track, 3, TRUE];				    putMessage[sector, TRUE];		     putNumber [sector, 2, FALSE];					    i ¬ i + 1;    ENDLOOP;    putMessage[successComplete];    RETURN;    EXITS    bTape =>       BEGIN        putMessage[secTableFailed];	putMessage[mediaProblem];	RETURN;      END;    nFormat =>      BEGIN        putMessage[secTableFailed];	putMessage[notFormat];	RETURN;      END;    wrInhib =>      BEGIN        putMessage[secTableFailed];	putMessage[writeProtect];	RETURN;      END;    nRdy =>      BEGIN        putMessage[secTableFailed];	putMessage[notReady];	RETURN;      END;    volOpen =>      BEGIN        putMessage[secTableFailed];	putMessage[driveInUse];		RETURN;      END;    hError =>      BEGIN        putMessage[secTableFailed];	putMessage[hardwareProblem];	RETURN;      END;    emptyOut =>      BEGIN        putMessage[emptyTable];	putMessage[successComplete];	RETURN;      END;    END; --FlTapeDisplayBadSectorTable  --  Private Procedures      PageToTapeAddress: PROCEDURE[badPage: LONG CARDINAL] 	RETURNS[stream: CARDINAL, track: CARDINAL, sector: CARDINAL] =  BEGIN  cnt: CARDINAL ¬ 0;  UNTIL badPage <= sectorsPerStream DO    badPage ¬ badPage - sectorsPerStream;    cnt ¬ cnt + 1;    ENDLOOP;  stream ¬ cnt + 1;		 -- stream count starts at 1  cnt ¬ 0;  UNTIL badPage <= sectorsPerTrack DO    badPage ¬ badPage - sectorsPerTrack;    cnt ¬ cnt + 1;    ENDLOOP;  track ¬ cnt;			 --track count starts at 0  sector ¬ Inline.LowHalf[badPage];  END;		--PageToTapeAddress    --Mainline code, module initialization  --Get drive and put into localDrive  localDrive ¬ FloppyTapeExtras.GetNextFloppyTapeDrive[FloppyTapeExtras.nullDrive];  END...LOG20-Jul-87 12:18:39 by RK, Created file 9-Dec-87 17:03:21 by RK, added mainline code for drive enumeration. 4-Feb-88 11:53:02 by RK, added volOpen/[driveInUse] to log bad sector, display bad sector and verify read procs.
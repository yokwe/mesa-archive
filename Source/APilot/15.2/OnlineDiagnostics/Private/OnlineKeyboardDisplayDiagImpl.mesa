--OnlineKeyboardDisplayDiagImpl.mesa-- Copyright (C) 1980, 1985, 1987 by Xerox Corporation. All rights reserved.--Last Edited by: KXW,   10-Jun-87 17:40:27DIRECTORY  Ascii USING [ControlA, ControlC, ControlZ, CR, DEL, ESC, LF],  KeyboardFace USING [keyboardType],  OnlineDiagnostics,  OnlineDiagnosticMPCodes,  OnlineKeyboardDiscriptions,  ProcessorFace USING [SetMP, mp];  OnlineKeyboardDisplayDiagImpl: PROGRAM  IMPORTS ProcessorFace, OnlineKeyboardDiscriptions, KeyboardFace  EXPORTS OnlineDiagnostics =  BEGIN OPEN OnlineDiagnostics, OnlineKeyboardDiscriptions;    DisplayCodeInPanel: PRIVATE PROC [mpCode: CARDINAL] = INLINE {   ProcessorFace.SetMP[mpCode]};    LSAdjust: PUBLIC PROC [    cancelSignal: SIGNAL,    GetMesaChar:  PROC RETURNS [CHARACTER],    PutCR:        PROC,    PutMessage:   PROC [message: LSMessage, char: CHARACTER _ 0C],    PutMesaChar:  PROC [CHARACTER]] =    BEGIN    mp: CARDINAL = ProcessorFace.mp;    BEGIN  -- extend scope of mp into exits    s:  STRING;    PutString: PROC = {      FOR i: CARDINAL IN [0..s.length) DO PutMesaChar[s[i]] ENDLOOP;      PutMesaChar[Ascii.CR]};        DisplayCodeInPanel[OnlineDiagnosticMPCodes.StartAdjust];    PutMessage[kTermAdj];    PutMessage[kTypeCharFill];    PutMessage[kCTLC];    DO  --put lines of characters on screen--      c: CHARACTER;      c _ GetMesaChar[! cancelSignal => EXIT];      DisplayCodeInPanel[OnlineDiagnosticMPCodes.AdjustOne];      SELECT c FROM	IN [' ..'_], IN ['a..'~] =>	  THROUGH [0..80) DO	    PutMesaChar[c ! cancelSignal => EXIT];	    ENDLOOP;	= Ascii.ControlC => EXIT;	ENDCASE => PutMessage[kCTLC];      ENDLOOP;    PutMessage[kFillScreen];    PutMessage[kCTLC];    DO      c: CHARACTER;      c _ GetMesaChar[! cancelSignal => EXIT];      DisplayCodeInPanel[OnlineDiagnosticMPCodes.AdjustTwo];      SELECT c FROM	IN [' ..'_], IN ['a..'~] => {	  PutCR[];	  --fill first 23 lines of screen completely--	  THROUGH [0..23) DO THROUGH [0..80) DO	    PutMesaChar[c ! cancelSignal => EXIT] ENDLOOP ENDLOOP;	  --fill last line with 79 characters (to prevent automatic CRLF)--	  THROUGH [0..79) DO PutMesaChar[c ! cancelSignal => EXIT] ENDLOOP};        = Ascii.ControlC => EXIT;	ENDCASE => PutMessage[kCTLC];	ENDLOOP;	    PutCR[];    PutMessage[kTypeXHair];    PutMessage[kEndAdj];    IF GetMesaChar[! cancelSignal => GOTO stop] = Ascii.ControlC THEN GOTO stop;    DisplayCodeInPanel[OnlineDiagnosticMPCodes.AdjustThree];        --Make first line of cross-hairs pattern.    THROUGH [0..80) DO PutMesaChar['* ! cancelSignal => GOTO stop] ENDLOOP;    --Make second line; first of those with diagonals.    s _  "** ****                                **                                **** **"L;       -- 01234567890123456789012345678901234567890123456789012345678901234567890123456789"L    PutString[ ! cancelSignal => GOTO stop];    --Erase diagonal lines.    FOR i: CARDINAL IN [ 3.. 7) DO s[i] _ '  ENDLOOP;    FOR i: CARDINAL IN [73..77) DO s[i] _ '  ENDLOOP;    --Fill in diagonals, display lines and erase diagonals.    FOR j: CARDINAL IN [0..3) DO      FOR i: CARDINAL IN [ (7+10*j)..(10+10*j)) DO s[i] _ '* ENDLOOP;      FOR i: CARDINAL IN [(70-10*j)..(73-10*j)) DO s[i] _ '* ENDLOOP;      PutString[ ! cancelSignal => GOTO stop];      FOR i: CARDINAL IN [ (7+10*j)..(10+10*j)) DO s[i] _ '  ENDLOOP;      FOR i: CARDINAL IN [(70-10*j)..(73-10*j)) DO s[i] _ '  ENDLOOP;      FOR i: CARDINAL IN [(10+10*j)..(13+10*j)) DO s[i] _ '* ENDLOOP;      FOR i: CARDINAL IN [(67-10*j)..(70-10*j)) DO s[i] _ '* ENDLOOP;      PutString[ ! cancelSignal => GOTO stop];      FOR i: CARDINAL IN [(10+10*j)..(13+10*j)) DO s[i] _ '  ENDLOOP;      FOR i: CARDINAL IN [(67-10*j)..(70-10*j)) DO s[i] _ '  ENDLOOP;      FOR i: CARDINAL IN [(13+10*j)..(17+10*j)) DO s[i] _ '* ENDLOOP;      FOR i: CARDINAL IN [(63-10*j)..(67-10*j)) DO s[i] _ '* ENDLOOP;      PutString[ ! cancelSignal => GOTO stop];      FOR i: CARDINAL IN [(13+10*j)..(17+10*j)) DO s[i] _ '  ENDLOOP;      FOR i: CARDINAL IN [(63-10*j)..(67-10*j)) DO s[i] _ '  ENDLOOP;      ENDLOOP;	    --Make middle two lines.    THROUGH [0..80) DO PutMesaChar['* ! cancelSignal => GOTO stop] ENDLOOP;    THROUGH [0..80) DO PutMesaChar['* ! cancelSignal => GOTO stop] ENDLOOP;	    --Fill in diagonals, display lines and erase diagonals.    FOR j: CARDINAL DECREASING IN [0..3) DO      FOR i: CARDINAL IN [(13+10*j)..(17+10*j)) DO s[i] _ '* ENDLOOP;      FOR i: CARDINAL IN [(63-10*j)..(67-10*j)) DO s[i] _ '* ENDLOOP;      PutString[ ! cancelSignal => GOTO stop];      FOR i: CARDINAL IN [(13+10*j)..(17+10*j)) DO s[i] _ '  ENDLOOP;      FOR i: CARDINAL IN [(63-10*j)..(67-10*j)) DO s[i] _ '  ENDLOOP;      FOR i: CARDINAL IN [(10+10*j)..(13+10*j)) DO s[i] _ '* ENDLOOP;      FOR i: CARDINAL IN [(67-10*j)..(70-10*j)) DO s[i] _ '* ENDLOOP;      PutString[ ! cancelSignal => GOTO stop];      FOR i: CARDINAL IN [(10+10*j)..(13+10*j)) DO s[i] _ '  ENDLOOP;      FOR i: CARDINAL IN [(67-10*j)..(70-10*j)) DO s[i] _ '  ENDLOOP;      FOR i: CARDINAL IN [ (7+10*j)..(10+10*j)) DO s[i] _ '* ENDLOOP;      FOR i: CARDINAL IN [(70-10*j)..(73-10*j)) DO s[i] _ '* ENDLOOP;      PutString[ ! cancelSignal => GOTO stop];      FOR i: CARDINAL IN [ (7+10*j)..(10+10*j)) DO s[i] _ '  ENDLOOP;      FOR i: CARDINAL IN [(70-10*j)..(73-10*j)) DO s[i] _ '  ENDLOOP;      ENDLOOP;	    --Make next-to-last line; last of those with diagonals.    FOR i: CARDINAL IN [ 3.. 7) DO s[i] _ '* ENDLOOP;    FOR i: CARDINAL IN [73..76) DO s[i] _ '* ENDLOOP;    PutString[ ! cancelSignal => GOTO stop];	    --Make last line (only 79 chars to prevent "more").    THROUGH [0..79) DO PutMesaChar['* ! cancelSignal => GOTO stop] ENDLOOP;    UNTIL GetMesaChar[] = Ascii.ControlC DO ENDLOOP;    GOTO stop;        EXITS stop => {PutCR[]; DisplayCodeInPanel[mp]}    END; END;  --of LSAdjust	  LSTest: PUBLIC PROC [    cancelSignal: SIGNAL,    GetMesaChar:  PROC RETURNS [CHARACTER],    PutMessage:   PROC [message: LSMessage, char: CHARACTER _ 0C]] =    BEGIN    mp: CARDINAL = ProcessorFace.mp;    DisplayCodeInPanel[OnlineDiagnosticMPCodes.StartLSTest];    PutMessage[kTermTest];    PutMessage[kTestKey];    PutMessage[kCTLStop];    RealLSTest[GetMesaChar, PutMessage ! cancelSignal => RESUME];    DisplayCodeInPanel[mp];    END;      RealLSTest: PRIVATE PROC [    GetMesaChar: PROC RETURNS [CHARACTER],    PutMessage:  PROC [message: LSMessage, char: CHARACTER _ 0C]] =    BEGIN OPEN Ascii;    DO      c: CHARACTER;      c _ GetMesaChar[];      --The expression below converts the octal character c into a decimal; e.g.,      -- the letter "A" = 101B gets converted to 101 (decimal).  In addition,      -- the last digit is changed to "8" if it was originally "0."      DisplayCodeInPanel[        OnlineDiagnosticMPCodes.LSTestBase	  + 100 * ((c-0C)  /   64)	  +  10 * (((c-0C) MOD 64)/8)	  + (IF ((c-0C) MOD 8) = 0 THEN 8 ELSE ((c-0C) MOD 8))];      SELECT c FROM	= ControlC 		=> RETURN;	= LF      		=> PutMessage[kLineFeed];	= CR         	        => PutMessage[kReturnKey];	= ESC  --escape-- 	=> PutMessage[kEscape];	= '    --space-- 	=> PutMessage[kSpBar];	= '*   --asterisk-- 	=> PutMessage[kShColon];	= '+   --plus sign-- 	=> PutMessage[kShSemiColon];	= ',   --comma-- 	=> PutMessage[kTypeComma];	= '-   --hyphen-- 	=> PutMessage[kHyphen];	= '.   --period-- 	=> PutMessage[kTypePeriod];	= '/   --virgule-- 	=> PutMessage[kVirgule];	= ':   --colon-- 	=> PutMessage[kLearColon];	= ';   --semicolon-- 	=> PutMessage[kSemiColon];	= '<   --less than-- 	=> PutMessage[kShComma];	= '=   --equal sign-- 	=> PutMessage[kShHyphen]; 	= '>   --greater than-- => PutMessage[kShPeriod]; 	= '?   --question-- 	=> PutMessage[kShVirgule];	= '@   --at sign-- 	=> PutMessage[kAtSign];	= '[   --left bracket-- => PutMessage[kLeftBracket];	= '\\  --back slash-- 	=> PutMessage[kBackSlash];	= ']   --right brack--	=> PutMessage[kRightBracket];	= '^   --caret-- 	=> PutMessage[kCaret];	= '_   --BREAK-- 	=> PutMessage[kBreak];	= 140C --open quote--	=> PutMessage[kShAt]; 	= '{   --left brace-- 	=> PutMessage[kShLeftBracket];	= '|   --vertical bar-- => PutMessage[kShBackSlash];	= '}   --right brace-- 	=> PutMessage[kShRightBracket];	= '~   --tilde-- 	=> PutMessage[kShCaret];	= DEL   --shift-BREAK-- => PutMessage[kShBreak];	IN ['!..')] 		=> {	  PutMessage[kNumeral, c + 20B]; PutMessage[kAndShift]};	IN ['0..'9] => {	  PutMessage[kNumeral, c];       PutMessage[kKey]};	IN [ControlA..ControlZ] => {	  PutMessage[kLetter, c + 100B]; PutMessage[kAndCTL]};	IN ['A..'Z]	        => {	  PutMessage[kLetter,  c];       PutMessage[kAndShift]};	IN ['a..'z] 		=> {	  PutMessage[kLetter,  c - 40B]; PutMessage[kKey]};	ENDCASE => PutMessage[kUnknown];      ENDLOOP;    END;	  LFDisplayTest: PUBLIC PROC [    screenHeight:  CARDINAL[0..32767],    screenWidth:   CARDINAL[0..32767],    SetBackground: PROC [background: Background],    SetBorder:     PROC [oddPairs, evenPairs:  [0..377B]],    GetNextAction: PROC RETURNS [NextAction],    ClearDisplay:  PROC,    BlackenScreen: PROC [x, y, width, height: CARDINAL],    FillScreenWithObject:   PROC [p: LONG POINTER TO ARRAY [0..16) OF WORD]] =    BEGIN    background: Background;    letterH:    ARRAY [0..16) OF WORD = [      0B, 0B, 30014B, 30014B, 30014B, 30014B, 30014B, 37774B, 37774B, 30014B,      30014B, 30014B, 30014B, 30014B, 0B, 0B];    dlosAtSign: ARRAY [0..16) OF WORD = [      0B, 0B, 1700B, 3740B, 7160B, 6360B, 6660B, 6660B, 6760B, 6340B, 7000B,      3700B, 1700B, 0B, 0B, 0B];    myAtSign:   ARRAY [0..16) OF WORD = [      0B, 3760B, 4010B, 10004B, 20004B, 43742B, 42102B, 44102B, 44104B, 44104B,      44310B, 43560B, 40004B, 20030B, 17740B, 0B];    SetBorder[0B, 0B];    DO      DrawHoriz: PROC [y: CARDINAL[0..32767]] = {        xx, wwidth, spaceRemaining: CARDINAL;        paintCan: ARRAY [0..2) OF WORD _ ALL[177777B];        FOR x:CARDINAL _ 0, x+24 WHILE (x+16) <= screenWidth DO	  xx _ x;          BlackenScreen[x: x, y: y, width: 16, height: 2];	  ENDLOOP;	xx _ xx + 16;	IF (spaceRemaining _ screenWidth - xx) > 0 THEN {	  SELECT spaceRemaining FROM	    >=16 => {wwidth_spaceRemaining-8; xx_xx+8;};	    >=10 => {wwidth_spaceRemaining-5; xx_xx+5;};	    ENDCASE => {wwidth_spaceRemaining;};	  BlackenScreen[x: xx, y: y, width: wwidth, height: 2]; };  };      DrawVert: PROC [x: CARDINAL[0..32767]] = {        yy, hheight, spaceRemaining: CARDINAL;        paintCan: ARRAY [0..2) OF WORD _ ALL[177777B];        FOR y:CARDINAL _ 0, y+24 WHILE (y+16) <= screenHeight DO	  yy _ y;          BlackenScreen[x: x, y: y, width: 2, height: 16];	  ENDLOOP;	yy _ yy + 16;	IF (spaceRemaining _ screenHeight - yy) > 0 THEN {	  SELECT spaceRemaining FROM	    >=16 => {hheight_spaceRemaining-8; yy_yy+8;};	    >=10 => {hheight_spaceRemaining-5; yy_yy+5;};	    ENDCASE => {hheight_spaceRemaining;};	  BlackenScreen[x: x, y: yy, width: 2, height: hheight]; };  };      DisplayOnScreenAndWait: PROC [array: ARRAY[0..16) OF WORD]	RETURNS [quit: BOOLEAN]= {        ClearDisplay[];        SetBackground[background _ white];        SetBorder[0B, 0B];	FillScreenWithObject[LONG[@array]];	RETURN[WaitForKey[].quit]};      WaitForKey: PROC RETURNS [quit: BOOLEAN] = {        DO	  SELECT GetNextAction[] FROM            nextPattern   => RETURN[FALSE];	    invertPattern => {	      SetBackground[background _ (IF background=white THEN black ELSE white)];              LOOP}; 	    quit          => RETURN[TRUE];	    ENDCASE;	  ENDLOOP};            PrintCrossHairPattern: PROC =        BEGIN	-- Hair line lengths	shortHairLine: CARDINAL = 12;	longHairLine: CARDINAL = 22;        length, line: CARDINAL;	lineWidth: CARDINAL = 2;        stripe: CARDINAL = 170B;  --********ATTENTION ATTENTION **LOOKS BBAAAADDDDD****        --        -- Starting points for drawing horizontal hair lines (y)        centerVertLine: CARDINAL = screenWidth/2 - lineWidth;         centerVertLineShort: CARDINAL = centerVertLine - 5; -- For short hair line        centerVertLineLong: CARDINAL = centerVertLine - 10; -- For long hair line    	-- Starting points for drawing vertical hair lines (y)        centerHorLine: CARDINAL = screenHeight/2 + 1;        centerHorLineShort: CARDINAL = centerHorLine - 5;  -- Short hair line        centerHorLineLong: CARDINAL = centerHorLine - 10;  -- Long hair line    	-- 1 inch = 2.54 cm	-- 75 pixelsPerInch/2.54 cmPerInch = 29.52 pixelsPerCM        << pixelsPerCM: CARDINAL = 30;   -- Rounded up >>        pixelsPerHalfCM: CARDINAL = 15;  -- Round up        numberOfVerticalBars: CARDINAL = screenWidth/pixelsPerHalfCM;        numberOfHorizontalBars: CARDINAL = screenHeight/pixelsPerHalfCM;                ClearDisplay[];    	-- Draw 4 lines, each 2 pixels wide, around the edges	-- 	-- Top edge         BlackenScreen[x: 0, y: 0, width: screenWidth, height: lineWidth];	-- Bottom edge        BlackenScreen[x: 0, y: screenHeight - lineWidth, width: screenWidth, height: lineWidth];	-- Left edge        BlackenScreen[x: 0, y: 0, width: lineWidth, height: screenHeight];	-- Right edge        BlackenScreen[x: screenWidth - lineWidth, y: 0, width: lineWidth, height: screenHeight];        	-- Draw vertical hair lines about the horizontal center line	-- 	BlackenScreen[x: 0, y: centerHorLine, width: screenWidth, height: lineWidth];        FOR i: CARDINAL IN [0 .. numberOfVerticalBars] DO -- Hair lines          IF i MOD 2 = 0 THEN {  -- Draw a long hair line            length _ longHairLine;             line _ centerHorLineLong }          ELSE {  -- Draw a short hair line            length _ shortHairLine;             line _ centerHorLineShort };          BlackenScreen[x: i*pixelsPerHalfCM,       		       y: line, 		       width: lineWidth, 		       height: length];          ENDLOOP;    	-- Draw horizontal hair lines about vertical line, each separated by .5 cm	BlackenScreen[x: centerVertLine, y: 0, width: lineWidth, height: screenHeight];        FOR i: CARDINAL IN [0 .. numberOfHorizontalBars] DO           IF i MOD 2 = 0 THEN {  -- Draw a long hair line            length _ longHairLine;             line _ centerVertLineLong  -- x-position to start painting -- }          ELSE {  -- Draw a short hair line            length _ shortHairLine;             line _ centerVertLineShort  -- x-position to start painting  -- };            BlackenScreen[x: line, y: i*pixelsPerHalfCM, width: length, height: lineWidth];          ENDLOOP;        END;  -- PrintCrossHairPattern	      ClearDisplay[];      SetBackground[background _ white];      --For all horizontal lines      --Top horizontal line      DrawHoriz[y: 0];      --Second horizontal line      DrawHoriz[y: 24];      --Middle horizontal line      DrawHoriz[y: screenHeight/2 - 1];      --Penultimate horizontal line      DrawHoriz[y: screenHeight - 25];      --Bottom horizontal line      DrawHoriz[y: screenHeight - 2];      --For all vertical lines      --Leftmost vertical line      DrawVert[x:0];      --Second vertical line      DrawVert[x:24];      --Middle vertical line      DrawVert[x: screenWidth/2 - 1];      --Penultimate vertical line      DrawVert[x: screenWidth - 25];      --Rightmost vertical line      DrawVert[x: screenWidth - 2];      IF WaitForKey[].quit THEN RETURN;      --Set up screen for "H" pattern      IF DisplayOnScreenAndWait[letterH].quit THEN RETURN;      --Set up screen for Dallas "@" (at-sign) pattern      IF DisplayOnScreenAndWait[dlosAtSign].quit THEN RETURN;      --Set up screen for my "@" (at-sign) pattern      IF DisplayOnScreenAndWait[myAtSign].quit THEN RETURN;      --Set up screen for vertical-line pattern for checking display memory      --Now paint thin black vertical lines, each aligned with a different bit      ClearDisplay[];      SetBackground[background _ white];      FOR x: CARDINAL _ 15, x+33 WHILE x <= screenWidth/2 DO        BlackenScreen[x: x, y: 0, width: 1, height: screenHeight]	ENDLOOP;      IF WaitForKey[].quit THEN RETURN;            --Set up screen for crosshair pattern on the screen for alignment purposes      ClearDisplay[];      PrintCrossHairPattern;      IF WaitForKey[].quit THEN RETURN;      --Set up screen for plain pattern for checking display memory      --Clear the display      ClearDisplay[]; SetBackground[background _ white];      IF WaitForKey[].quit THEN RETURN;      ENDLOOP;    END;      KeyboardAndMouseTest: PUBLIC PROC [    keyboardType:	  KeyboardType,    screenHeight:         CARDINAL[0..32767],    screenWidth:          CARDINAL[0..32767],    SetBackground:        PROC [background: Background],    SetBorder:            PROC [oddPairs, evenPairs:  [0..377B]],    GetMousePosition:     PROC RETURNS [Coordinate],    SetMousePosition:     PROC [newMousePosition: Coordinate],    SetCursorPattern:     PROC [cursorArray: CursorArray],    SetCursorPosition:    PROC [newCursorPosition: Coordinate],    keyboard:             LONG POINTER,    Beep:                 PROC [duration: CARDINAL],    ClearDisplay:         PROC,    BlackenScreen:        PROC [x, y, width, height: CARDINAL],    InvertScreen:         PROC [x, y, width, height: CARDINAL],    WaitForKeyTransition: PROC] =    BEGIN        mice: ARRAY [0..8) OF CursorArray = [      [  -- both Mouse buttons down (and yellow stuck)      177777B, 177777B, 177777B, 160607B, 160607B, 160607B, 160607B, 160607B,      160607B, 177777B, 177777B, 177777B, 177777B, 177777B, 177777B, 177777B],      [  -- both Mouse buttons down      177777B, 100001B, 100001B, 117171B, 117171B, 117171B, 117171B, 117171B,      117171B, 100001B, 100001B, 100001B, 100001B, 100001B, 100001B, 177777B],      [  -- left Mouse button down (and yellow stuck)      177777B, 177777B, 177777B, 160777B, 160777B, 160777B, 160777B, 160777B,      160777B, 177777B, 177777B, 177777B, 177777B, 177777B, 177777B, 177777B],      [  -- left Mouse button down      177777B, 100001B, 100001B, 117001B, 117001B, 117001B, 117001B, 117001B,      117001B, 100001B, 100001B, 100001B, 100001B, 100001B, 100001B, 177777B],      [  -- right Mouse button down (and yellow stuck)      177777B, 177777B, 177777B, 177607B, 177607B, 177607B, 177607B, 177607B,      177607B, 177777B, 177777B, 177777B, 177777B, 177777B, 177777B, 177777B],      [  -- right Mouse button down      177777B, 100001B, 100001B, 100171B, 100171B, 100171B, 100171B, 100171B,      100171B, 100001B, 100001B, 100001B, 100001B, 100001B, 100001B, 177777B],      [  -- standardMouse (no buttons down and yellow stuck)      177777B, 177777B, 177777B, 177777B, 177777B, 177777B, 177777B, 177777B,      177777B, 177777B, 177777B, 177777B, 177777B, 177777B, 177777B, 177777B],      [  -- standardMouse (no buttons down)      177777B, 100001B, 100001B, 100001B, 100001B, 100001B, 100001B, 100001B,      100001B, 100001B, 100001B, 100001B, 100001B, 100001B, 100001B, 177777B]];    PaintHorizontalsDove: PROC =     BEGIN      horizontalLines: ARRAY [0..26) OF RECORD [x, y, width: CARDINAL] = [      	--Top of ten function keys for 	[x: 5*unit,     	     y: 0, width: 5*unit+oneThirdUnit+2],	[x: 11*unit,     	     y: 0, width: 5*unit+oneThirdUnit+2],	[x: 17*unit+6, 		     y: 0, width: 2*unit+twoThirdsUnit+2],	--bottom of ten function keys for DOVE	[x: 5*unit,     	     y: 1, width: 5*unit+oneThirdUnit+2],	[x: 11*unit,     	     y: 1, width: 5*unit+oneThirdUnit+2],	[x: 17*unit+6,               y: 1, width: 2*unit+twoThirdsUnit+2],	--top of Number keys row	[x: 0,                        y: 2, width:  3*unit+2],	[x: 5*unit,                   y: 2, width: 15*unit+2],	[x: 22*unit,                  y: 2, width:  4*unit+2],	-- numbers bottoms/QWERTY top	[x: 0,                        y: 3, width:  3*unit+2],	[x: 5*unit,                   y: 3, width: 15*unit+2],	[x: 22*unit,                  y: 3, width:  4*unit+2],	--QWERTY bottoms/ASDFGH top	[x: 0,                        y: 4, width:  3*unit+2],	[x: 5*unit,                   y: 4, width: 13*unit+twoThirdsUnit+2],	[x: 22*unit,                  y: 4, width:  4*unit+2],	--ASDFGH bottoms/ZXCVBN top	[x: 0,                        y: 5, width:  3*unit+2],	[x: 5*unit,                   y: 5, width: 15*unit+2],	[x: 23*unit,                  y: 5, width:  3*unit+2],	--ZXCVBN bottoms/space bar top	[x: 0,                        y: 6, width:  3*unit+2],	[x: 5*unit,                   y: 6, width: 15*unit+2],	[x: 22*unit,                  y: 6, width:  4*unit+2],	--space bar bottom for DOVE	[x: 0,                        y: 7, width:  3*unit+2],	[x: 5*unit,                   y: 7, width: unit+oneHalfUnit],	[x: 7*unit + fiveSixthsUnit,  y: 7, width: 9*unit+2],	[x: 18*unit, 		      y: 7, width: 2*unit+2],	[x: 22*unit,                  y: 7, width: 4*unit+2]];        FOR i: CARDINAL IN [0..LENGTH[horizontalLines]) DO        OPEN h: horizontalLines[i];	BlackenScreen[	  x: h.x+100, y: h.y*24 + screenHeight/3,	  width: h.width, height: 2];	ENDLOOP;      END;    PaintHorizontalsDLion: PROC = BEGIN      horizontalLines: ARRAY [0..18) OF RECORD [x, y, width: CARDINAL] = [        --Top of eight function keys	[x: 6*unit + oneHalfUnit,     y: 0, width: 12*unit+2],	--bottom of eight function keys	[x: 6*unit + oneHalfUnit,     y: 1, width: 12*unit+2],	--top of Number keys row	[x: 0,                        y: 2, width:  3*unit+2],	[x: 5*unit,                   y: 2, width: 15*unit+2],	[x: 22*unit,                  y: 2, width:  4*unit+2],	-- numbers bottoms/QWERTY top	[x: 0,                        y: 3, width:  3*unit+2],	[x: 5*unit,                   y: 3, width: 15*unit+2],	[x: 23*unit,                  y: 3, width:  2*unit+2],	--QWERTY bottoms/ASDFGH top	[x: 0,                        y: 4, width:  3*unit+2],	[x: 5*unit,                   y: 4, width: 13*unit+twoThirdsUnit+2],	[x: 22*unit,                  y: 4, width:  4*unit+2],	--ASDFGH bottoms/ZXCVBN top	[x: 0,                        y: 5, width:  3*unit+2],	[x: 5*unit,                   y: 5, width: 15*unit+2],	[x: 23*unit,                  y: 5, width:  2*unit+2],	--ZXCVBN bottoms/space bar top	[x: 0,                        y: 6, width:  3*unit+2],	[x: 5*unit,                   y: 6, width: 15*unit+2],	[x: 22*unit,                  y: 6, width:  4*unit+2],	--space bar bottom	[x: 7*unit + fiveSixthsUnit,  y: 7, width: 9*unit+2]];      FOR i: CARDINAL IN [0..LENGTH[horizontalLines]) DO        OPEN h: horizontalLines[i];	BlackenScreen[	  x: h.x+200, y: h.y*24 + screenHeight/3,	  width: h.width, height: 2];	ENDLOOP;      END;      PaintVerticalsDove: PROC =     BEGIN      -- tall verticals are 5*unit+2 high and start at y=2      tallVerticals: ARRAY [0..9) OF CARDINAL = [        0, 1, 3, 5, 20, 22, 24, 25, 26];      -- verticals are all unit+2 high, 2 wide      -- again, x needs to be relocated by 100      -- y needs mult by 24 and relocation by 1/3 screen height      VerticalRepRecord: TYPE = RECORD [x, y, reps, separation: CARDINAL];      verticals: ARRAY [0..14) OF VerticalRepRecord = [	-- function keys row	[x: 5*unit,		   y: 0, reps:  5, separation: unit+oneThirdUnit],	[x: 11*unit,		   y: 0, reps:  5, separation: unit+oneThirdUnit],	[x: 17*unit+6,		   y: 0, reps:  3, separation: unit+9],		-- rightArrow through '=;	[x: 6*unit,                y: 2, reps: 13, separation: unit],	-- tab right side, qwertyuiop[]<cr>	[x: 6*unit+oneHalfUnit,    y: 3, reps: 13, separation: unit],	-- lock asdfghjkl;'_<cr>	[x: 6*unit+twoThirdsUnit,  y: 4, reps: 13, separation: unit],	-- shift zxcvbnm,./ shift	[x: 7*unit+oneThirdUnit,   y: 5, reps: 11, separation: unit],	-- space bar	[x: 23*unit, 		   y: 2, reps:  1, separation: 0],	[x: 23*unit, 		   y: 3, reps:  1, separation: 0],	[x: 23*unit, 		   y: 4, reps:  1, separation: 0],	[x: 23*unit, 		   y: 5, reps:  1, separation: 0],	[x: 6*unit+oneHalfUnit,    y: 6, reps:  1, separation: 0],	[x: 7*unit+fiveSixthsUnit, y: 6, reps:  2, separation: 9*unit],	[x: 18*unit,   		   y: 6, reps:  1, separation: 0]];      jVerticals: ARRAY [0..5) OF RECORD [x, y: CARDINAL] = [        [x: 6*unit+oneThirdUnit,  y: 5], [x: 18*unit+twoThirdsUnit, y: 5],	[x: 9*unit+oneThirdUnit,  y: 6], [x: 12*unit+oneThirdUnit, y: 6],	[x: 15*unit+oneThirdUnit, y: 6]];        eVerticals: ARRAY [0..1) OF RECORD [x, y: CARDINAL] = [        [x: 6*unit+oneThirdUnit, y: 5]];        FOR i: CARDINAL IN [0..LENGTH[tallVerticals]) DO         BlackenScreen[	  x: tallVerticals[i]*unit+100, y: 2*24 + screenHeight/3,	  height: 5*unit+2, width: 2];	ENDLOOP;	      FOR i: CARDINAL IN [0..LENGTH[verticals]) DO        OPEN v: verticals[i];	FOR j: CARDINAL IN [0..v.reps) DO           BlackenScreen[	    x: v.x + j * v.separation + 100, y: v.y*24 + screenHeight/3,	    height: unit+2, width: 2];	  ENDLOOP;	ENDLOOP;      SELECT KeyboardFace.keyboardType FROM         jLevel5 =>          FOR i: CARDINAL IN [0..LENGTH[jVerticals]) DO             BlackenScreen[	      x: jVerticals[i].x + 100, y: jVerticals[i].y*24 + screenHeight/3,	      height: unit+2, width: 2];	    ENDLOOP;        eLevel5 =>          FOR i: CARDINAL IN [0..LENGTH[eVerticals]) DO             BlackenScreen[	      x: eVerticals[i].x + 100, y: eVerticals[i].y*24 + screenHeight/3,	      height: unit+2, width: 2];	    ENDLOOP;        ENDCASE;      END;          PaintVerticalsDLion: PROC = BEGIN      -- tall verticals are 4*unit+2 high and start at y=2      tallVerticals: ARRAY [0..9) OF CARDINAL = [        0, 1, 3, 5, 20, 22, 23, 25, 26];      -- verticals are all unit+2 high, 2 wide      -- again, x needs to be relocated by 200      -- y needs mult by 24 and relocation by 1/3 screen height      VerticalRepRecord: TYPE = RECORD [x, y, reps, separation: CARDINAL];      verticals: ARRAY [0..6) OF VerticalRepRecord = [	-- function keys row	[x: 6*unit + oneHalfUnit,  y: 0, reps:  9, separation: unit + oneHalfUnit],	-- rightArrow through '=;	[x: 6*unit,                y: 2, reps: 13, separation: unit],	-- tab right side, qwertyuiop[]<cr>	[x: 6*unit+oneHalfUnit,    y: 3, reps: 13, separation: unit],	-- lock asdfghjkl;'_<cr>	[x: 6*unit+twoThirdsUnit,  y: 4, reps: 13, separation: unit],	-- shift zxcvbnm,./ shift	[x: 7*unit+oneThirdUnit,  y: 5, reps: 11, separation: unit],	-- space bar	[x: 7*unit+fiveSixthsUnit, y: 6, reps:  2, separation: 9*unit]];      jVerticals: ARRAY [0..5) OF RECORD [x, y: CARDINAL] = [        [x: 6*unit,               y: 5], [x: 20*unit-(unit+oneThirdUnit), y: 5],	[x: 9*unit+oneThirdUnit,  y: 6], [x: 12*unit+oneThirdUnit,        y: 6],	[x: 15*unit+oneThirdUnit, y: 6]];        eVerticals: ARRAY [0..1) OF RECORD [x, y: CARDINAL] = [        [x: 6*unit+oneThirdUnit, y: 5]];        FOR i: CARDINAL IN [0..LENGTH[tallVerticals]) DO         BlackenScreen[	  x: tallVerticals[i]*unit+200, y: 2*24 + screenHeight/3,	  height: 4*unit+2, width: 2];	ENDLOOP;	      FOR i: CARDINAL IN [0..LENGTH[verticals]) DO        OPEN v: verticals[i];	FOR j: CARDINAL IN [0..v.reps) DO           BlackenScreen[	    x: v.x + j * v.separation + 200, y: v.y*24 + screenHeight/3,	    height: unit+2, width: 2];	  ENDLOOP;	ENDLOOP;      SELECT keyboardType FROM         japanese =>          FOR i: CARDINAL IN [0..LENGTH[jVerticals]) DO             BlackenScreen[	      x: jVerticals[i].x + 200, y: jVerticals[i].y*24 + screenHeight/3,	      height: unit+2, width: 2];	    ENDLOOP;        european =>          FOR i: CARDINAL IN [0..LENGTH[eVerticals]) DO             BlackenScreen[	      x: eVerticals[i].x + 200, y: eVerticals[i].y*24 + screenHeight/3,	      height: unit+2, width: 2];	    ENDLOOP;        ENDCASE;      END;        ClearDisplay[];    SetBackground[white];    SetBorder[0, 0];    IF KeyboardFace.keyboardType >= jLevel5 THEN          {PaintHorizontalsDove[];       PaintVerticalsDove[]; } ELSE              {PaintHorizontalsDLion[];       PaintVerticalsDLion[]; };           BlackenScreen[x: 0, y: 0, height: unit, width: unit];    SetCursorPattern[mice[7]];    SetMousePosition[[screenWidth/2, 0]];    SetCursorPosition[[screenWidth/2, 0]];    Beep[duration: 5000 --5 seconds--];          DO      c: Coordinate _ GetMousePosition[];      keyArrayPtrDove: LONG POINTER TO KeyArrayDove _ keyboard;      keyArrayPtrDLion: LONG POINTER TO KeyArrayDLion _ keyboard +1;      WaitForKeyTransition[];      SetCursorPattern[mice[(keyboard^) MOD 8]];      IF c.x NOT IN [0..screenWidth) OR c.y NOT IN [0..screenHeight) THEN {        c.x _ MIN[screenWidth,  MAX[c.x, 0]];        c.y _ MIN[screenHeight, MAX[c.y, 0]];	SetMousePosition[c]};      SetCursorPosition[c];      IF KeyboardFace.keyboardType >= jLevel5 THEN          BEGIN	  FOR key: KeyNameDove IN KeyNameDove             DO             downUp: DownUp;	     IF copyKeyArrayDove[key]#(downUp _ keyArrayPtrDove[key]) THEN	       BEGIN	       r: KeyboardDescriptorRecord _ recDovePtr[key];	       SELECT KeyboardFace.keyboardType FROM             	jLevel5 =>	      	   IF key=Space THEN		      r _ [x: 12*unit+oneThirdUnit, y: 6*unit, width: 3*unit-2, height: unit-2]	           ELSE IF key=LeftShift  THEN	              r  _ [x: 5*unit, y: 5*unit, width: unit+oneThirdUnit-2, height: unit-2]	           ELSE IF key=RightShift THEN	              r _ [x: 18*unit+twoThirdsUnit, y: 5*unit, width: unit+oneThirdUnit-2, height: unit-2];                eLevel5 =>                   IF      key=LeftShift   THEN	              r _ [x: 5*unit, y: 5*unit, width: unit+oneThirdUnit-2, height: unit-2];	       ENDCASE; 	       InvertScreen[	          x: r.x+102, y: r.y+2+screenHeight/3, width: r.width, height: r.height];	       IF key = NewPara THEN	          InvertScreen[	            x: 102 + 18*unit + twoThirdsUnit, y: (4*unit)+screenHeight/3,		    width: unit + oneThirdUnit - 2, height: unit];	       copyKeyArrayDove[key] _ downUp;	       END;             ENDLOOP;          END	ELSE	  BEGIN	  FOR key: KeyNameDLion IN KeyNameDLion	      DO	      downUp: DownUp;	      IF copyKeyArrayDLion[key]#(downUp _ keyArrayPtrDLion[key]) THEN	        BEGIN	        r: KeyboardDescriptorRecord _ recDLionPtr[key];	        SELECT keyboardType FROM 	          japanese =>	      	     IF      key=Space       THEN		       r _ [x: 10*unit+fiveSixthsUnit, y: 6*unit, width: 3*unit-2, height: unit-2]	             ELSE IF key=LeftShift  THEN	               r  _ [x: 5*unit, y: 5*unit, width: unit+oneThirdUnit-2, height: unit-2]	             ELSE IF key=RightShift THEN	               r _ [x: 17*unit+oneThirdUnit, y: 5*unit, width: unit+oneThirdUnit-2, height: unit-2];	          european =>                     IF      key=LeftShift   THEN	               r _ [x: 5*unit, y: 5*unit, width: unit+oneThirdUnit-2, height: unit-2];	        ENDCASE;	        InvertScreen[	           x: r.x+202, y: r.y+2+screenHeight/3, width: r.width, height: r.height];	        IF key = NewPara THEN	        InvertScreen[	           x: 202 + 18*unit + twoThirdsUnit, y: (4*unit)+screenHeight/3,		   width: unit + oneThirdUnit - 2, height: unit];	        copyKeyArrayDLion[key] _ downUp;	        END;	      ENDLOOP;	  END;      IF c.x IN [0..unit) AND c.y IN [0..unit)        AND (keyboard^/2 MOD 4) # 3 THEN EXIT;      ENDLOOP;    END;      END....  LOG11-Feb-85 16:30:44  RobertsA  Initial creation for Dove online diagnostics.20-Feb-85 14:15:26  RobertsA  Create  OnlineKeyboardDiscriptoionsImpl6-Mar-85 14:04:44  RobertsA  Corrected mappings for Dove Keyboards 10-Jun-87 17:40:49  by: KXW  Corrected RightShift.     
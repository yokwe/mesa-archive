-- Copyright (C) 1986, 1987  by Xerox Corporation. All rights reserved. -- GermOpsImplDove.mesa    28-Apr-87 12:55:27 by CAJ    <<  This module implements Dove-dependent operations needed by    the germ, exported through GermOps. >>DIRECTORY  Boot USING [countGermVM, pageGerm, pRequest],  BootFile USING [Header],  DoveInputOutput USING [    displayPageCount, firstReservedPage, RealPageNumber, reservedPageCount],  Environment USING [PageNumber],  GermOps USING [GetNextPilotVM],  PageMap USING [    flagsClean, flagsVacant, GetState, PageNumber, RealPageNumber,    SetMapFlags, State],  PilotSwitchesExtras USING [useSpecialMemory, useSpecialMemoryIfNoDisplay],  PilotSwitchesExtraExtras USING [saveDisplayPagesIndexA, saveDisplayPagesIndexB],  System USING [defaultSwitches, Switches];GermOpsImplDove: PROGRAM  IMPORTS DoveInputOutput, GermOps, PageMap EXPORTS GermOps  SHARES GermOps, PageMap =  BEGIN  -- PUBLIC procedures  BoundsReservedMemory: PUBLIC --GermOps.-- PROCEDURE    RETURNS [reservedMin, reservedMax: Environment.PageNumber] =    BEGIN    OPEN DIO: DoveInputOutput;    reservedMin ¬ DIO.firstReservedPage;    reservedMax ¬ DIO.firstReservedPage + DIO.reservedPageCount - 1;    END;    ProcessMachineDependentSwitches: PUBLIC -- GermOps -- PROCEDURE [    header: LONG POINTER TO BootFile.Header,    highestMappedPage: Environment.PageNumber]    RETURNS [newHighestMappedPage:Environment.PageNumber] =    BEGIN    newHighestMappedPage ¬ highestMappedPage;  -- assume we do nothing..    IF header.inLoadMode = load THEN      BEGIN      pSwitches: LONG POINTER TO System.Switches ¬ @Boot.pRequest.switches;      IF pSwitches^ = System.defaultSwitches THEN pSwitches ¬        @LOOPHOLE[header.switches, System.Switches];      IF pSwitches[PilotSwitchesExtras.useSpecialMemory] = down      OR (pSwitches[PilotSwitchesExtras.useSpecialMemoryIfNoDisplay] = down	  AND NoDisplay[]) THEN	BEGIN	holdBack: DoveInputOutput.RealPageNumber ¬ SELECT TRUE FROM	  pSwitches[PilotSwitchesExtraExtras.saveDisplayPagesIndexA] = down	    AND pSwitches[PilotSwitchesExtraExtras.saveDisplayPagesIndexB] = down	    => 128,	  pSwitches[PilotSwitchesExtraExtras.saveDisplayPagesIndexB] = down	    => 64,	  pSwitches[PilotSwitchesExtraExtras.saveDisplayPagesIndexA] = down	    => 48,	  ENDCASE => 0;        newHighestMappedPage ¬ AddReservedMemory[highestMappedPage, holdBack];	END;      END;    END;    -- Private procedures    AddReservedMemory: PROCEDURE [highestMappedPage: Environment.PageNumber,    holdBack: DoveInputOutput.RealPageNumber]    RETURNS [newHighestMappedPage: Environment.PageNumber] =    BEGIN    pageDest: Environment.PageNumber;  -- page where we will put next real page.    pageDestIntervalEnd: Environment.PageNumber;    newHighestMappedPage ¬ highestMappedPage;    [pageDest, pageDestIntervalEnd] ¬      GermOps.GetNextPilotVM[Environment.PageNumber.FIRST];    UNTIL pageDestIntervalEnd > highestMappedPage + 1 DO        [pageDest, pageDestIntervalEnd] ¬	  GermOps.GetNextPilotVM[pageDestIntervalEnd];	IF pageDest = pageDestIntervalEnd THEN RETURN; -- no more vm.      ENDLOOP;    pageDest ¬ MAX[pageDest, highestMappedPage + 1];    --ASSERT: pageDest is the first Pilot vm page at or after    -- highestMappedPage + 1.    FOR reservedReal: DoveInputOutput.RealPageNumber IN      [DoveInputOutput.firstReservedPage+holdBack .. DoveInputOutput.firstReservedPage+DoveInputOutput.reservedPageCount) DO      IF PageNotMappedToGerm[reservedReal] THEN        BEGIN  -- donate it:	PageMap.SetMapFlags[	  virtual: pageDest, real: reservedReal, flags: PageMap.flagsClean];	newHighestMappedPage ¬ pageDest;	pageDest ¬ pageDest + 1;	IF pageDest >= pageDestIntervalEnd THEN {	  [pageDest, pageDestIntervalEnd] ¬ GermOps.GetNextPilotVM[pageDest];	  IF pageDest = pageDestIntervalEnd THEN RETURN}; -- no more vm.	END;      ENDLOOP;    END;  --AddReservedMemory--    NoDisplay: PROCEDURE RETURNS [BOOLEAN] = INLINE    {RETURN[(DoveInputOutput.displayPageCount = 0)]};    PageNotMappedToGerm: PROCEDURE [page: PageMap.RealPageNumber]    RETURNS [BOOLEAN] =    BEGIN    vPage: PageMap.PageNumber;    rPage: PageMap.RealPageNumber;    state: PageMap.State;    FOR vPage IN [Boot.pageGerm .. Boot.pageGerm + Boot.countGermVM) DO      [state: state, real: rPage] ¬ PageMap.GetState[vPage];      IF state.flags # PageMap.flagsVacant AND rPage = page THEN RETURN[FALSE];      ENDLOOP;    RETURN[TRUE];    END;    END.LOG27-Nov-84 15:38:42   JoM       Created from GermOpsImplDLion and RealMemoryImplDove.16-Apr-85 13:18:43   JoM       Changed BoundsVanillaMemory to correspond to RealMemoryImplDove.Count. 2-Jan-86 12:42:48   CAJ       Add GermOpsTemporary.processorType, copyright.15-Jan-87 16:27:38   CAJ       Replace BoundsVanillaMemory with its inverse replacement BoundsReservedMemory.16-Jan-87 11:52:35   CAJ       MDS relief changes (LONG pointers).28-Apr-87 12:55:21   CAJ       Remove GermOpsTemporary.processorType. It is now provided by ProcessorFace(Extras).
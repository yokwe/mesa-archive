-- Copyright (C) 1993  by Xerox Corporation. All rights reserved. -- BootChannelStream.mesa   16-Jul-93  9:29:30 by JPM<<  This is a general-case Coprocessor stream driver designed for use with the germ. >>DIRECTORY  Boot USING [Location],  BootChannel USING [    Create, Handle, Operation, Result, transferCleanup, transferWait],  CoProcessorFace USING [    Connection, connectionRecAlignment, connectionRecSize, Get, Initialize,    InitiateConnection, InitiateDisconnection, Poll, Status],  CoProcessorServerIDs USING [bootAgentID],  Device USING [Type],  DeviceTypesExtras11 USING [Stream],  Environment USING [bytesPerPage, first64K, LongPointerFromPage, wordsPerPage],  GermOps USING [GermWorldError],  Inline USING [LowHalf],  PilotMP USING [cGermDeviceError, cGermERROR, cGermShortBootFile],  ResidentHeap USING [FreeNode, MakeNode],  ResidentMemory USING [Allocate, Free],  Stream USING [Block, CompletionCode];BootChannelStream: PROGRAM  IMPORTS    RemainingChannels: BootChannel, CoProcessorFace, Environment, GermOps, Inline, ResidentHeap, ResidentMemory  EXPORTS BootChannel  SHARES Device, GermOps =  BEGIN  bootConnection: CoProcessorFace.Connection;  connectionBuffers: LONG POINTER;  Create: PUBLIC --BootChannel.-- PROCEDURE [    pLocation: LONG POINTER TO Boot.Location, operation: BootChannel.Operation,    buffer: LONG POINTER]    RETURNS [result: BootChannel.Result, handle: BootChannel.Handle] =    BEGIN    -- The buffer arg is not used by this boot channel implementation.    IF pLocation.deviceType IN DeviceTypesExtras11.Stream      THEN RETURN CreateInternal[pLocation, operation]    ELSE        -- not anything I implement.  Pass it on.      RETURN RemainingChannels.Create[pLocation, operation, buffer];    END; --Create--  -- CreateInternal exists so that when memory backing germ-stream code is  -- discarded, create code can be discarded without breaking the BootChannel  -- chain.  CreateInternal: PROCEDURE [    pLocation: LONG POINTER TO Boot.Location, operation: BootChannel.Operation]    RETURNS [result: BootChannel.Result, handle: BootChannel.Handle] =    BEGIN    -- At present, we don't pass errors back to caller via result.    -- This is because it is not thought to be particularly useful.    status: CoProcessorFace.Status;    IF pLocation.deviceOrdinal # 0 OR operation = write THEN      GermOps.GermWorldError[PilotMP.cGermDeviceError];    CoProcessorFace.Initialize[0];    bootConnection ¬ @Environment.first64K[ResidentHeap.MakeNode[      CoProcessorFace.connectionRecSize, CoProcessorFace.connectionRecAlignment].node];    connectionBuffers ¬ ResidentMemory.Allocate[hyperspace, 2];    status ¬ CoProcessorFace.InitiateConnection[      bootConnection, CoProcessorServerIDs.bootAgentID, FALSE,      DESCRIPTOR[connectionBuffers, Environment.bytesPerPage],      DESCRIPTOR[connectionBuffers + Environment.wordsPerPage, Environment.bytesPerPage]];    WHILE status = inProgress DO      status ¬ CoProcessorFace.Poll[bootConnection]    ENDLOOP;    IF status # completed THEN GermOps.GermWorldError[PilotMP.cGermDeviceError];    RETURN[[ok[]], Transfer]    END;  --CreateInternal--  Transfer: BootChannel.Handle  --    --PROC [page, count] RETURNS [result: BootChannel.Result]-- =    BEGIN    -- At present, we don't pass errors back to caller via result.    -- This is because it is not thought to be particularly useful.    status: CoProcessorFace.Status;    SELECT count FROM      = BootChannel.transferCleanup =>          BEGIN	  status ¬ CoProcessorFace.InitiateDisconnection[bootConnection, TRUE];	  WHILE status = inProgress DO	    status ¬ CoProcessorFace.Poll[bootConnection]	  ENDLOOP;	  [] ¬ ResidentHeap.FreeNode[Inline.LowHalf[bootConnection]];	  ResidentMemory.Free[hyperspace, 2, connectionBuffers]	  END;      = BootChannel.transferWait => NULL;      NOT IN CARDINAL => GermOps.GermWorldError[PilotMP.cGermERROR];      ENDCASE =>        BEGIN	block: Stream.Block ¬ [Environment.LongPointerFromPage[page],	  0, Inline.LowHalf[count] * Environment.bytesPerPage];	DO	  bytesTransferred: CARDINAL;	  why: Stream.CompletionCode;	  [bytesTransferred, why, ] ¬ CoProcessorFace.Get[bootConnection, block];	  IF (block.startIndex ¬ block.startIndex + bytesTransferred)	    >= block.stopIndexPlusOne THEN EXIT;	  IF why = endOfStream THEN RETURN[[error[PilotMP.cGermShortBootFile]]];	ENDLOOP	END; --ENDCASE--    RETURN[[ok[]]];    END; --Transfer--         END.LOG16-Jul-93 -- JPM -- Created.
-- Copyright (C) 1982, 1983  by Xerox Corporation. All rights reserved. -- Space.mesa            6-Jul-83 17:52:38 by WDK     DIRECTORY  Environment USING [    LongPointerFromPage, maxPagesInMDS, PageCount,    PageFromLongPointer, PageNumber, PageOffset, wordsPerPage],  File USING [File, nullFile, PageNumber];Space: DEFINITIONS IMPORTS Environment =  BEGIN  -- Basic parameters and types:  wordsPerPage: CARDINAL = Environment.wordsPerPage;  PageNumber: TYPE = Environment.PageNumber;  PageCount: TYPE = Environment.PageCount;  PageOffset: TYPE = Environment.PageOffset;  Interval: TYPE = RECORD [pointer: LONG POINTER, count: Environment.PageCount];  nullInterval: Interval = [pointer: NIL, count: 0];  Access: TYPE = {readWrite, readOnly};  Life: TYPE = {alive, dead};  -- Accessing virtual memory:  Window: TYPE = RECORD [    file: File.File ,    base: File.PageNumber,    count: Environment.PageCount];  Map: PROCEDURE [    window: Window, usage: Usage ¬ unknownUsage, class: Class ¬ file,    access: Access ¬ readWrite, life: Life ¬ alive,    swapUnits: SwapUnitOption ¬ defaultSwapUnitOption]    RETURNS [mapUnit: Interval];  Usage: TYPE = [0..2048);  unknownUsage: Usage = 0;  Class: TYPE = MACHINE DEPENDENT{    unknown(0), code(1), globalFrame(2), localFrame(3), zone(4), file(5), data(6),    spareA(7), spareB(8), pilotResident(31)};  SwapUnitOption: TYPE = RECORD [    body: SELECT swapUnitType: SwapUnitType FROM      unitary => NULL,      uniform => [size: SwapUnitSize ¬ defaultSwapUnitSize],      irregular => [sizes: LONG DESCRIPTOR FOR ARRAY [0..0) OF SwapUnitSize]      ENDCASE];  defaultSwapUnitOption: SwapUnitOption = [uniform[defaultSwapUnitSize]];  SwapUnitType: TYPE = {unitary, uniform, irregular};  SwapUnitSize: TYPE = CARDINAL;  defaultSwapUnitSize: SwapUnitSize = 0;  ScratchMap: PROCEDURE [    count: Environment.PageCount, usage: Usage ¬ unknownUsage]    RETURNS [pointer: LONG POINTER] = INLINE {    RETURN[      Map[        window: [file: File.nullFile, base: NULL, count: count],        usage: usage, class: data, access: readWrite, life: dead]	.mapUnit.pointer]};  Unmap: PROCEDURE [pointer: LONG POINTER, returnWait: ReturnWait ¬ wait]    RETURNS [nil: LONG POINTER];  ReturnWait: TYPE = {return, wait};  -- Explicit reading and writing:  CopyIn: PROCEDURE [pointer: LONG POINTER, window: Window]    RETURNS [countRead: Environment.PageCount];  CopyOut: PROCEDURE [pointer: LONG POINTER, window: Window]    RETURNS [countWritten: Environment.PageCount];  -- Swapping commands:  Activate: PROCEDURE [interval: Interval];  ActivateProc: PROCEDURE [proc: --GENERIC-- PROCEDURE];  Deactivate: PROCEDURE [interval: Interval];  DeactivateProc: PROCEDURE [proc: --GENERIC-- PROCEDURE];  ForceOut: PROCEDURE [interval: Interval];  Kill: PROCEDURE [interval: Interval];  -- Access control:  SetAccess: PROCEDURE [interval: Interval, access: Access];  MakeReadOnly: PROCEDURE [interval: Interval] = INLINE {    SetAccess[interval, readOnly]};  MakeWritable: PROCEDURE [interval: Interval] = INLINE {    SetAccess[interval, readWrite]};  -- Explicit virtual memory allocation and management:  virtualMemory: READONLY Interval;  MDS: PROCEDURE RETURNS [Interval] = INLINE {    RETURN[[LONG[LOOPHOLE[1, POINTER]] - 1, Environment.maxPagesInMDS]]};  Allocate: PROCEDURE [    count: Environment.PageCount, within: Interval ¬ virtualMemory,    base: Environment.PageOffset ¬ defaultBase] RETURNS [interval: Interval];  defaultBase: Environment.PageOffset = LAST[Environment.PageOffset];  Deallocate: PROCEDURE [interval: Interval];  MapAt: PROCEDURE [    at: Interval, window: Window, usage: Usage ¬ unknownUsage,    class: Class ¬ file, access: Access ¬ readWrite, life: Life ¬ alive,    swapUnits: SwapUnitOption ¬ defaultSwapUnitOption]    RETURNS [mapUnit: Interval];  UnmapAt: PROCEDURE [pointer: LONG POINTER, returnWait: ReturnWait ¬ wait]    RETURNS [interval: Interval];  -- Miscellaneous operations:  GetMapUnitAttributes: PROCEDURE [pointer: LONG POINTER]    RETURNS [      interval: Interval, window: Window, usage: Usage, class: Class,      swapUnits: SwapUnitOption];  GetSwapUnitAttributes: PROCEDURE [pointer: LONG POINTER]    RETURNS [interval: Interval, access: Access, life: Life];  LongPointerFromPage: PROCEDURE [page: Environment.PageNumber]    RETURNS [LONG POINTER] = INLINE {    RETURN[Environment.LongPointerFromPage[page]]};  PageFromLongPointer: PROCEDURE [pointer: LONG POINTER]    RETURNS [Environment.PageNumber] = INLINE {    RETURN[Environment.PageFromLongPointer[pointer]]};  PagesFromWords: PROCEDURE [wordCount: LONG CARDINAL]    RETURNS [pageCount: Environment.PageCount] = INLINE {    RETURN[LOOPHOLE[      (wordCount + Environment.wordsPerPage - 1)      /Environment.wordsPerPage]]};  Pointer: PROCEDURE [pointer: LONG POINTER] RETURNS [POINTER];  PointerFromPage: PROCEDURE [page: Environment.PageNumber] RETURNS [POINTER];  -- Signals and errors:  Error: ERROR [type: ErrorType];  ErrorType: TYPE = {    alreadyAllocated, alreadyDeallocated, incompleteSwapUnits, invalidParameters,    invalidProcedure, invalidSwapUnitSize, invalidWindow, stillMapped,    notAllocated, notMapped, noWindow, pointerPastEndOfMemory, readOnly};  InsufficientSpace: ERROR [available: Environment.PageCount];  IOError: ERROR [page: Environment.PageNumber];  END.--LOG17-Mar-82 17:11:48   WDK     	Created file from Space.mesa of 8-Aug-81.12-Aug-82  9:46:08   WDK     	Twiddles.23-Aug-82 11:43:17   AWL      	Mods for long page numbers and counts.30-Aug-82 15:15:56   WDK     	Map gets life arg. 1-Sep-82 11:20:42   WDK     	Add pilotResident class. 6-Oct-82  9:53:33   AWL      	Added Life parameter to MapAt.24-Nov-82 19:45:02   AWL      	Window.file => File.File.31-Mar-83  9:50:11   WDK        Result of Map and MapAt was named wrong. Get Page<=>LongPointer from Environment. 5-Apr-83 16:29:49   WDK        Deleted ClientUsage and PilotUsage.23-Jun-83 16:17:13   JXG        Removed default on count parameter of Window 6-Jul-83 17:52:42   WDK        ActivateProc arg is PROCEDURE, not UNSPECIFIED.
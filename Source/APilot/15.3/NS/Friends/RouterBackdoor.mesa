-- File: RouterBackdoor.mesa-- WIrish-- Copyright (C) 1990 by Xerox Corporation. All rights reserved.---- Not for the casual user.  Allows one to hook into various interesting things-- in FullRoutingTableImpl.DIRECTORY  Router,  System;RouterBackdoor: DEFINITIONS =  BEGIN    NetworkNumber: TYPE = System.NetworkNumber;  nullNetworkNumber: NetworkNumber = System.nullNetworkNumber;  infinity: CARDINAL = Router.infinity;  ChangeReason: TYPE = {new, refresh, shorter, differentRouter, longerByRIP, deadByRIP, deadByTimeout, ignore};    -- new              A net that we've never seen before  -- refresh          standard RIP update with no change (*)  -- shorter          a shorter route has come along  -- differentRouter  chose a new router since we haven't heard from the old one  -- longerByRIP      the route is now longer via the same router  -- deadByRIP        the current router told us that the net is now dead  -- deadByTimeout    the entry became so old that we've marked it dead  -- ignore           used by the router internally (*)  -- * (ChangeProc clients won't see these)    NetworkEntry: TYPE = RECORD [    net: NetworkNumber ¬ nullNetworkNumber,    hops: CARDINAL ¬ 0,            -- current hops to remote net    closest: CARDINAL ¬ infinity,  -- lowest hops seen    age: CARDINAL ¬ 0,             -- in 30 second units (1 = 30 seconds)    changes: CARDINAL ¬ 0,         -- number of times this entry changed    viaNet: NetworkNumber ¬ nullNetworkNumber,    viaHost: System.HostNumber ¬ System.nullHostNumber    ];    NetStatus: TYPE = RECORD [    total: CARDINAL,  -- number of nets currently known    dead: CARDINAL    -- number of nets currently dead (unreachable)    ];      Times: TYPE = RECORD [    nets: System.GreenwichMeanTime,     -- time we started collecting net info    changes: System.GreenwichMeanTime,  -- time the changes were last reset    closest: System.GreenwichMeanTime   -- time closest values were last reset    ];      Table: TYPE = LONG POINTER TO TableInfo;  TableInfo: TYPE = RECORD [    times: Times,    netStatus: NetStatus,  -- total = number of valid entries in the table    base: SEQUENCE n: CARDINAL OF NetworkEntry    ];      ChangeProc: TYPE = PROC [net: NetworkNumber, reason: ChangeReason, new, old: NetworkEntry];      RegisterChangeProc: PROC [proc: ChangeProc];    -- proc will get called with changes, call with NIL to cancel  -- Your proc should be slim and trim since you are using the router's cycles,  -- with the ML being held.  If you need to do a lot of work you should find  -- a way to hand the bulk of the work off to another process.      GetTimes: PROC RETURNS [Times];    -- Get the various times      GetNetStatus: PROC RETURNS [NetStatus];    -- Simply returns the net status      GetNetInfo: PROC [net: NetworkNumber] RETURNS [NetworkEntry];    -- Gets routing table information for net.  -- will raise Router.NoTableEntryForNet if there is no entry for net      GetTable: PROC [z: UNCOUNTED ZONE, proc: ChangeProc ¬ NIL, hint: Table ¬ NIL] RETURNS [snapshot: Table];    -- Returns a "snapshot" of the current routing table in table.  -- If hint # NIL AND hint.n >= the size needed to hold the snapshot then  -- hint will be used and snapshot = hint on return.  Otherwise storage for snapshot  -- is gotten from z and the hint is not used of FREEd.  It is up to the client to FREE  -- storage used by hint or snapshot.  -- Entries in snapshot will be sorted in network number order, lowest first.  -- proc provides a means to atomically obtain a routing table  -- snapshot AND set the ChangeProc at the same time.  If proc = NIL  -- then the current ChangeProc is not affected in any way - you must use  -- RegisterChangeProc[NIL] to set it to NIL.      ZeroChangeCounters: PROC;    -- Zeros all change conters in the current table.  -- Sets the changes time [Times] to now      ResetClosest: PROC;    -- Resets closest for all entries  -- Sets the closest time [Times] to now      END....
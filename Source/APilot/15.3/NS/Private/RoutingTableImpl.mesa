-- File: RoutingTableImpl.mesa - last edit:-- WIrish               9-Mar-93 16:45:49-- AOF                 24-Feb-88 17:52:05-- SMA                 23-May-86  8:56:17---- Copyright (C) 1990, 1992 by Xerox Corporation. All rights reserved. -- Function: The implementation module for the Pilot NS Router's routing table.DIRECTORY  Buffer USING [AccessHandle, Buffer, Device, GetBuffer, ReturnBuffer],  CommFlags USING [doDebug, doStats],  CommPriorities USING [receiver],  Driver USING [Device, GetDeviceChain, Glitch, PutOnGlobalDoneQueue],  Environment USING [bytesPerWord],  Heap USING [systemZone],  Inline USING [BITAND, BITROTATE, BITXOR, LongDiv],  InrTypes USING [ExtendedRoutingInformation, ExtendedRoutingInfoTuple,    RoutingInfoType],  Mopcodes USING [zEXCH],  NSBuffer USING [AccessHandle, Body, Buffer, BufferBody, GetBuffer, ReturnBuffer],  NSConstants USING [routingInformationSocket],  NSTypes,  Process USING [Detach, GetPriority, MsecToTicks, Pause, Priority, SetPriority, Yield],  Protocol1 USING [EncapsulateAndTransmit, GetContext],  Router,  RouterBackdoor USING [ChangeProc, ChangeReason, infinity, NetStatus, NetworkEntry,    NetworkNumber, nullNetworkNumber, Table, TableInfo, Times],  RouterInternal USING [BroadcastThisPacket, SendErrorPacket, XmitStatus],  RoutingTable,  Socket USING [ChannelHandle, Delete, GetBufferPool, PutPacket],  SocketInternal USING [CreateListen, ListenerProcType],  SpecialSystem USING [HostNumber, NetworkNumber, SocketNumber],  Stats USING [StatIncr],  System,  Time USING [Current];RoutingTableImpl: MONITOR  IMPORTS    NSBuffer, Driver, Heap, Inline, Process, Protocol1, Router,    RouterInternal, Socket, SocketInternal, Stats, System, Time  EXPORTS Buffer, RouterBackdoor, RouterInternal, System =  BEGIN  --EXPORTed TYPEs  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  NetworkNumber: PUBLIC <<System>> TYPE = SpecialSystem.NetworkNumber;  HostNumber: PUBLIC <<System>> TYPE = SpecialSystem.HostNumber;  SocketNumber: PUBLIC <<System>> TYPE = SpecialSystem.SocketNumber;  PutOnGlobalDoneQueue: PROC[b: NSBuffer.Buffer] =    LOOPHOLE[Driver.PutOnGlobalDoneQueue];  --just to save n LOOPHOLEs    ChangeReason: TYPE = RouterBackdoor.ChangeReason;  ChangeProc: TYPE = RouterBackdoor.ChangeProc;  Entry: TYPE = LONG POINTER TO TableEntry;  TableEntry: TYPE = RECORD[    net: NetworkNumber ¬ nullNetworkNumber,          -- ultimate destination net    delay: CARDINAL [0..256) ¬ 0,                    -- current hops to remote net    closest: CARDINAL [0..256) ¬ infinity,           -- * lowest delay seen since reset    age: CARDINAL ¬ fresh,                           -- age without new routing info    changes: CARDINAL ¬ 0,                           -- * changes since last reset    context: RoutingTable.NetworkContext ¬ NIL,      -- access to driver    route: HostNumber ¬ nullHostNumber,              -- immediate host along the way    next: Entry ¬ NIL];                              -- to next higher net number     TableSlotsBase: TYPE = LONG POINTER TO TableSlots;  TableSlots: TYPE = RECORD[    SEQUENCE n: CARDINAL OF TableEntry];    Table: TYPE = RECORD[    base: TableSlotsBase ¬ NIL,  -- base of routing table    nEntries: NATURAL ¬ 0,       -- currently in the table    lowest: Entry ¬ NIL,         -- head of ordered list of nets by number    noSteps: CARDINAL ¬ 0,       -- entries hit on first try    totalSteps: CARDINAL ¬ 0,    -- total steps to reach entries in table    mostSteps: CARDINAL ¬ 0,     -- most additional steps to find an entry in the table    me: TableEntry ¬ []];        -- primary net number      -- Data Structure:  -- It's the old prime-number-sized-array-hash-table idea, with dynamic growth.  --  -- To add an entry you hash the key to an index and check for a hit.  --   If there is a collision you walk through the table by a hashed step value  --   looking for an empty slot.  Since the table has a prime number of slots  --   the step-walk is guaranteed to check every possible slot in the table,  --   without checking the same slot twice.  --  -- To find an existing entry in the table you do virtually the same thing as  --   when adding an entry, checking for a match as you go.  If you hit an  --   empty slot you know the value isn't there.    -- The hash table must have a prime number of entries  -- here are some primes to choose from (the table will "grow" as needed)    table: Table ¬ [];  maxPrimeIndex: CARDINAL = 19;  primes: ARRAY [0..maxPrimeIndex] OF CARDINAL = [      11,   29,   53,  101,  251,  503,  751,  1009,  1511,  2003,    2503, 3001, 3511, 4001, 4507, 4999, 7507, 10007, 14983, 20011];      -- primeIndex can start out at any value [0..maxPrimeIndex]  -- The table will always grow if and when needed.  -- In the general case it might be best to start out at 0, but for  -- initialization efficiency reasons you might want to start out at  -- some larger value if you know that there will be a large number  -- of networks.  -- The current CIN is ~1250 networks (3/93); at a 70% highWaterMark a good  -- starting value is 9 (2003 => 1402), this leaves a lot of room for growth too.    primeIndex: CARDINAL ¬ 9;      -- see comment above  highWaterPercentage: CARDINAL [10..100] ¬ 70;  -- used to calculate highWaterMark  highWaterMark: CARDINAL ¬ 0;   -- grow if we hit this many entries  tableSize: CARDINAL ¬ 0;       -- number of slots in the current table  tableFaults: CARDINAL ¬ 0;     -- how many times we faulted  tableNEWs: CARDINAL ¬ 0;       -- how many times we NEWed table storage    fresh: CARDINAL = 0;    -- age of fresh entries   suspect: CARDINAL = 3;  -- age at which we accept longer routes   dead: CARDINAL = 6;     -- age at which we declare it dead     infinity: CARDINAL = Router.infinity;  nullNetworkNumber: System.NetworkNumber = System.nullNetworkNumber;  nullHostNumber: System.HostNumber = System.nullHostNumber;    times: RouterBackdoor.Times;    sweeperProcess: PROCESS;  mask: CARDINAL = 01FH;  -- for masking out the high eleven bits of the incoming                          -- delay, as we (vanilla routing tables) don't use them.			    startEnum: NetworkNumber = nullNetworkNumber;  endEnum, allNets: NetworkNumber = [177777B, 177777B];    initialTransportControl: NSTypes.TransportControl = [    trace: FALSE, filler: 0, hopCount: 0];  -- for sending requests    myHostID: HostNumber;                     -- host ID of this system element.  sweepInterval: CARDINAL = 30;             -- seconds, scan interval through table  localHop: CARDINAL = 0;                   -- delay for attached network(s).  myAccessHandle: NSBuffer.AccessHandle;    -- for obtaining buffers when sending                                            -- via driver.  cH: Socket.ChannelHandle;                 -- routing information socket handle.  receiveBuffers: CARDINAL = 50;            -- # of buffers on RIP socket  fillBuffers: CARDINAL = 20;               -- # of buffers for fill operation    pleaseStop: BOOLEAN;                      -- switch to tell processes to stop.    -- sizes of the Routing Information protocol objects      bytesPerRoutingInfoType: CARDINAL = (2*SIZE[NSTypes.RoutingInfoType]);  bytesPerRoutingInfoTuple: CARDINAL = (2*SIZE[NSTypes.RoutingInfoTuple]);  maxTuplesPerRoutingPacket: CARDINAL =    (NSTypes.maxIDPDataBytes - bytesPerRoutingInfoType) /    bytesPerRoutingInfoTuple;    -- sizes of the extended Routing Information protocol objects    bytesPerExtendedRoutingInfoTuple: CARDINAL =     (2*SIZE[InrTypes.ExtendedRoutingInfoTuple]);  maxTuplesPerExtendedRoutingPacket: CARDINAL =    (NSTypes.maxIDPDataBytes - bytesPerRoutingInfoType) /    bytesPerExtendedRoutingInfoTuple;      -- Routing Table Object  defaultRth: PUBLIC RoutingTable.Handle ¬ @rto;  --so RouterInternal can find us  rto: RoutingTable.Object ¬ [    type: vanillaRouting, start: Start, stop: Stop,    startEnumeration: startEnum, endEnumeration: endEnum,    enumerate: Enumerate, fillTable: FillDummy,    getDelay: GetDelay, transmit: Transmit,    forward: Forward, findNetwork: FindLocalNetID,    addNetwork: AddDriver, removeNetwork: RemoveDriver,    flushCache: FlushCache, stateChanged: ChangedState];  RoutingTableScrambled: ERROR = CODE; --mass confusion, etc  DriverDidntNoteNet: ERROR = CODE;  --buffer came from busted driver  TooManyNets: ERROR = CODE;  -- more nets than the growing table can handle  FlushCache: RoutingTable.FlushCacheProc = {    -- make the interface happy    };  TableFault: INTERNAL PROC = {    -- creates the initial table or grows the current table    oldTable: Table ¬ table;    entry, prev, old: Entry;    hops: CARDINAL;    tableFaults ¬ SUCC[tableFaults];    IF primeIndex >= maxPrimeIndex THEN {      -- can't grow any more (don't know any higher primes!)      IF table.nEntries < tableSize THEN RETURN;  -- there's still room      ERROR TooManyNets[];      };    -- tableSize = 0 means create the initial table    IF tableSize # 0 THEN primeIndex ¬ SUCC[primeIndex];    tableSize ¬ primes[primeIndex];    table ¬ [];  -- initialize all values    table.me ¬ oldTable.me;  -- don't loose this one    highWaterMark ¬ Inline.LongDiv[(LONG[tableSize] * LONG[highWaterPercentage]), 100];    table.base ¬ Heap.systemZone.NEW[TableSlots[tableSize]];    FOR i: CARDINAL IN [0..table.base.n) DO      table.base[i] ¬ [];  -- initialize all entries      ENDLOOP;    -- now copy entries from old table to new    -- copy closer ones first for better hits on most probable nets    hops ¬ 0;    WHILE oldTable.lowest # NIL DO      prev ¬ NIL;      old ¬ oldTable.lowest;      WHILE old # NIL DO        IF old.delay # hops THEN {	  prev ¬ old;	  old ¬ old.next;	  LOOP;  -- add this one later	  };	entry ¬ AddEntry[old.net];     -- sets net and next	entry.delay ¬ old.delay;       -- copy other values	entry.closest ¬ old.closest;	entry.age ¬ old.age;	entry.context ¬ old.context;	entry.route ¬ old.route;	old ¬ old.next;	IF prev = NIL  -- unhook it	  THEN oldTable.lowest ¬ old	  ELSE prev.next ¬ old;	ENDLOOP;      hops ¬ SUCC[hops];  -- move on to the next distance out      ENDLOOP;    tableNEWs ¬ SUCC[tableNEWs];    Heap.systemZone.FREE[@oldTable.base];    enumerateHint ¬ NIL;  -- hints are no longer valid    routeHint ¬ NIL;    };  AddEntry: INTERNAL PROC [net: NetworkNumber] RETURNS [entry: Entry] = {    index, step: CARDINAL;    steps: CARDINAL ¬ 0;    SELECT TRUE FROM      (net = nullNetworkNumber) => RETURN[NIL];      (net = table.me.net) => RETURN[@table.me];      table.nEntries >= highWaterMark => {        TableFault[];           -- grow the table	RETURN[AddEntry[net]];  -- try again	};      table.base = NIL  => RETURN[NIL]; -- no table yet      ENDCASE => {        index ¬ HashToIndex[net];        step ¬ HashToStep[net];	WHILE table.base[index].net # nullNetworkNumber DO	  index ¬ NextIndex[index, step];	  steps ¬ SUCC[steps];	  ENDLOOP;	};    entry ¬ @table.base[index];    entry.net ¬ net;    table.nEntries ¬ SUCC[table.nEntries];    IF steps = 0      THEN table.noSteps ¬ SUCC[table.noSteps]      ELSE {        table.totalSteps ¬ table.totalSteps + steps;	IF steps > table.mostSteps THEN table.mostSteps ¬ steps;        };    -- now link it in, in net number order    {      lowest: Entry ¬ table.lowest;      SELECT TRUE FROM	table.lowest = NIL => table.lowest ¬ entry;	NetAgtNetB[table.lowest.net, net] => {	  entry.next ¬ table.lowest;	  table.lowest ¬ entry;	  };	ENDCASE => {	  this: Entry;	  FOR this ¬ table.lowest, this ¬ this.next WHILE this # NIL DO	    IF this.next = NIL OR NetAgtNetB[this.next.net, net] THEN EXIT;	    ENDLOOP;	  entry.next ¬ this.next;	  this.next ¬ entry;	  };      };    };  --AddEntry  FindEntry: INTERNAL PROC [net: NetworkNumber] RETURNS [entry: Entry] = {    index, step: CARDINAL;    SELECT TRUE FROM      (net = nullNetworkNumber) => RETURN[NIL];  -- won't find it      (net = table.me.net) => RETURN[@table.me];  -- special place (why?)      table.base = NIL  => RETURN[NIL]; -- no table yet      ENDCASE => {	index ¬ HashToIndex[net];	step ¬ HashToStep[net];	WHILE table.base[index].net # net DO	  IF table.base[index].net = nullNetworkNumber THEN RETURN[NIL];	  index ¬ NextIndex[index, step];	  ENDLOOP;	};    entry ¬ @table.base[index];    };  --FindEntry  HashToIndex: PROC [net: NetworkNumber] RETURNS [index: CARDINAL] = INLINE {    RETURN[Inline.BITXOR[net.a, net.b] MOD tableSize];    };  HashToStep: PROC [net: NetworkNumber] RETURNS [step: CARDINAL] = INLINE {    temp: CARDINAL ¬ Inline.BITROTATE[Inline.BITXOR[net.a, net.b], 8] MOD tableSize;    RETURN[IF temp = 0 THEN 1 ELSE temp];  -- never step by 0!    };  NextIndex: PROC [index: CARDINAL, step: CARDINAL] RETURNS [CARDINAL] = INLINE {    RETURN[(index + step) MOD tableSize];    }; AddDriver: PROC [context: RoutingTable.NetworkContext] =    BEGIN    -- If the net number of the new attached network is known, calls    -- AddDriverLocked to tell the routing table about it, else tries    -- to find out net number by probing an INR.    IF context.netNumber = nullNetworkNumber THEN ProbeINRs[]    ELSE AddDriverLocked[context];    END;  --AddDriver  AddDriverInternal: INTERNAL PROC [context: RoutingTable.NetworkContext] =    BEGIN    <<    Tells the routing table about a new attached network.  The driver    must know the network number at this point.  Called by     ExamineResponse and Locked, both of which hold the monitor.    >>    entry: Entry;    SELECT TRUE FROM      (~context.network.alive) => RETURN;      ((entry ¬ FindEntry[context.netNumber]) # NIL) => NULL;      ((entry ¬ AddEntry[context.netNumber]) = NIL) => RETURN;  --null net      ENDCASE;    entry.context ¬ context;  --finish loading the entry    SELECT TRUE FROM      (~CommFlags.doDebug) => NULL;  --nobody cares      (entry.net = nullNetworkNumber) =>        Driver.Glitch[RoutingTableScrambled];      ENDCASE;   END;  --AddDriverInternal     AddDriverLocked: ENTRY PROC [context: RoutingTable.NetworkContext] = {    AddDriverInternal[context];    };  			              CheckRoutingTableEntries: ENTRY PROC = {    -- Age all entries in the table    -- Set the delay to infinity for dead nets    entry: Entry;    oldEntry: TableEntry;    FOR entry ¬ table.lowest, entry ¬ entry.next WHILE entry # NIL DO      IF entry.age < LAST[CARDINAL] THEN entry.age ¬ SUCC[entry.age];      IF entry.delay >= infinity THEN LOOP;  -- already dead      IF entry.age < dead THEN LOOP;         -- not dead yet      oldEntry ¬ entry­;      entry.delay ¬ infinity;                -- kill it off      NotifyOfChange[deadByTimeout, entry, @oldEntry];      Process.Yield[];      ENDLOOP;    };  -- of CheckRoutingTableEntries          ChangedState: PROC[context: RoutingTable.NetworkContext] =    BEGIN    RemoveDriver[context];    AddDriver[context];    END;  --ChangedState  CleanUpRoutingTable: ENTRY PROC = {    Heap.systemZone.FREE[@table.base];    tableSize ¬ 0;    highWaterMark ¬ 0;    table ¬ [];    };    LongSwap: PROC[net: System.NetworkNumber] RETURNS[LONG CARDINAL] =    MACHINE CODE {Mopcodes.zEXCH};      NetAgtNetB: PROC [a, b: System.NetworkNumber] RETURNS [BOOLEAN] = INLINE    {RETURN[LongSwap[a] > LongSwap[b]]};  enumerateHint: Entry ¬ NIL;    Enumerate: ENTRY PROCEDURE [previous: System.NetworkNumber, delay: CARDINAL]    RETURNS [net: System.NetworkNumber ¬ endEnum] = {    entry: Entry;    CheckMe: PROCEDURE [inNet: NetworkNumber] RETURNS [outNet: NetworkNumber] = {      outNet ¬ SELECT TRUE FROM        inNet = startEnum                      => endEnum,	delay > 0                              => inNet,	NOT NetAgtNetB[table.me.net, previous] => inNet,	NetAgtNetB[table.me.net, inNet]        => inNet,	table.me.net = startEnum               => endEnum,	ENDCASE                                => table.me.net;      RETURN[outNet];      };    IF table.lowest = NIL THEN RETURN[CheckMe[endEnum]];    SELECT TRUE FROM      previous = startEnum => entry ¬ table.lowest;      enumerateHint # NIL AND enumerateHint.net = previous => entry ¬ enumerateHint.next;      ENDCASE => {        entry ¬ FindEntry[previous];	IF entry # NIL THEN entry ¬ entry.next;	};    WHILE entry # NIL DO      IF entry.delay = delay THEN EXIT;      entry ¬ entry.next;      ENDLOOP;    IF entry = NIL THEN RETURN[CheckMe[endEnum]];    enumerateHint ¬ entry;    RETURN[CheckMe[entry.net]];    };  --Enumerate  FillDummy: RoutingTable.FillTableProc = {    -- make the interface happy    -- since we always maintain a full table we don't need to do anything here    };  PokeForNetworkNumbers: PROC [net: System.NetworkNumber ¬ allNets] = {    -- for use internally when starting up and/or adding interfaces    b: NSBuffer.Buffer;    body: NSBuffer.Body;    sizeRoutingRequest: NATURAL = Environment.bytesPerWord *      (SIZE[routingInformation NSTypes.BufferBody] +      SIZE[NSTypes.RoutingInfoTuple]);    b ¬ NSBuffer.GetBuffer[myAccessHandle, send, FALSE, sizeRoutingRequest];    IF b # NIL THEN      BEGIN      body ¬ b.ns;      body.packetType ¬ routingInformation;      body.transportControl ¬ initialTransportControl;      body.destination.socket ¬ body.source.socket ¬	NSConstants.routingInformationSocket;      body.pktLength ¬ sizeRoutingRequest;      body.routingType ¬ routingInfoRequest;      body.routingTuple[0] ¬ [net, infinity];      RouterInternal.BroadcastThisPacket[b];      b ¬ NIL;      END    };  -- PokeForNetworkNumbers  FindLocalNetID: ENTRY PROC [destNetNum: System.NetworkNumber]    RETURNS [localNet: System.NetworkNumber] =    BEGIN    e: Entry;    localNet ¬ IF (e ¬ FindEntry[destNetNum]) = NIL      THEN nullNetworkNumber      ELSE IF e.context # NIL THEN e.context.netNumber ELSE nullNetworkNumber;    IF localNet = nullNetworkNumber THEN    --since nullNetworkNumber isn't helpful, find the first    --network with a known network number and use it.      FOR n: Device ¬ Driver.GetDeviceChain[], n.next UNTIL n = NIL DO        c: RoutingTable.NetworkContext ¬ Protocol1.GetContext[n, ns];	SELECT TRUE FROM	  (c = NIL) => NULL;  --not even close	  (~c.network.alive) => NULL;  --no better	  (c.netNumber = nullNetworkNumber) => NULL;  --still bad	  ENDCASE => {localNet ¬ c.netNumber; EXIT};  --reasonable substitute        ENDLOOP;    END;  --FindLocalNetID      Forward: PROC [b: NSBuffer.Buffer] =    BEGIN    IF b.ns.source.host # myHostID THEN      RouterInternal.SendErrorPacket[b, cantGetThere, 0]    ELSE      {b.fo.status ¬ RouterInternal.XmitStatus[noRouteToNetwork];      PutOnGlobalDoneQueue[b]};  --return b to the system buffer pool    IF CommFlags.doStats THEN Stats.StatIncr[statNSNotForwarded];    END;  --Forward  GetDelay: ENTRY PROC [net: NetworkNumber] RETURNS [delay: CARDINAL] = {    -- Gets the delay to specified net.    ENABLE UNWIND => NULL;    entry: Entry;    IF net = nullNetworkNumber THEN RETURN[0];    entry ¬ FindEntry[net];    IF entry = NIL THEN RETURN[infinity];    RETURN[entry.delay];    };  --GetDelay    ZeroChangeCounters: PUBLIC ENTRY PROC = {    ENABLE UNWIND => NULL;    entry: Entry;    entry ¬ table.lowest;    WHILE entry # NIL DO      entry.changes ¬ 0;      entry ¬ entry.next;      ENDLOOP;    times.changes ¬ Time.Current[];    };  -- ZeroChangeCounters  ResetClosest: PUBLIC ENTRY PROC = {    ENABLE UNWIND => NULL;    entry: Entry;    entry ¬ table.lowest;    WHILE entry # NIL DO      entry.closest ¬ entry.delay;      entry ¬ entry.next;      ENDLOOP;    times.closest ¬ Time.Current[];    };  -- ResetClosest  GetTimes: PUBLIC ENTRY PROC RETURNS [RouterBackdoor.Times] = {    RETURN[times];    };  --GetTimes    GetNetStatus: PUBLIC ENTRY PROC RETURNS [RouterBackdoor.NetStatus] = {    total: CARDINAL ¬ 1;  -- count the local network    dead: CARDINAL ¬ 0;    FOR entry: Entry ¬ table.lowest, entry.next WHILE entry # NIL DO      total ¬ total + 1;      IF entry.delay >= infinity THEN dead ¬ dead + 1;      ENDLOOP;    RETURN[[total, dead]];    };  --GetTimes    GetNetInfo: PUBLIC ENTRY PROC [net: NetworkNumber] RETURNS[RouterBackdoor.NetworkEntry] = {    ENABLE UNWIND => NULL;    entry: Entry ¬ FindEntry[net];    IF entry = NIL THEN RETURN WITH ERROR Router.NoTableEntryForNet;    RETURN[[	  net: entry.net,	  hops: entry.delay,	  closest: entry.closest,	  age: entry.age,	  changes: entry.changes,	  viaNet: IF entry.context # NIL	    THEN entry.context.netNumber	    ELSE nullNetworkNumber,	  viaHost: entry.route	  ]];    };  --GetRouteInfo    GetTable: PUBLIC ENTRY PROC [z: UNCOUNTED ZONE, proc: ChangeProc ¬ NIL, hint: RouterBackdoor.Table ¬ NIL] RETURNS [snapshot: RouterBackdoor.Table] = {    ENABLE UNWIND => NULL;    i, dead: CARDINAL ¬ 0;    localStillPending: BOOLEAN ¬ TRUE;    entry: Entry ¬ table.lowest;    entries: CARDINAL ¬ table.nEntries + 1;  -- count the local net too    IF hint # NIL AND hint.n >= entries      THEN snapshot ¬ hint      ELSE snapshot ¬ z.NEW[RouterBackdoor.TableInfo[entries]];    snapshot.netStatus.total ¬ entries;    snapshot.times ¬ times;    WHILE entry # NIL AND i < entries DO      IF localStillPending AND NetAgtNetB[entry.net, table.me.net] THEN {	snapshot.base[i] ¬ [net: table.me.net, hops: 0, closest: 0, age: 0, changes: 0,	  viaNet: nullNetworkNumber, viaHost: nullHostNumber];	localStillPending ¬ FALSE;	i ¬ i + 1;        };      snapshot.base[i] ¬ [        net: entry.net,	hops: entry.delay,	closest: entry.closest,	age: entry.age,	changes: entry.changes,	viaNet: IF entry.context # NIL	  THEN entry.context.netNumber	  ELSE nullNetworkNumber,	viaHost: entry.route        ];      IF entry.delay >= infinity THEN dead ¬ dead + 1;      i ¬ i + 1;      entry ¬ entry.next;      ENDLOOP;    snapshot.netStatus.dead ¬ dead;    IF proc # NIL THEN changeProc ¬ proc;    };  changeProc: ChangeProc ¬ NIL;    RegisterChangeProc: PUBLIC ENTRY PROC [proc: ChangeProc] = {    changeProc ¬ proc;    };          NotifyOfChange: INTERNAL PROC [reason: ChangeReason, newEntry, oldEntry: Entry] = {    IF reason # new AND newEntry.changes < LAST[CARDINAL] THEN      newEntry.changes ¬ SUCC[newEntry.changes];    IF changeProc # NIL THEN changeProc[      net: newEntry.net,      reason: reason,      new: [        net: newEntry.net,        hops: newEntry.delay,	closest: newEntry.closest,	age: newEntry.age,	changes: newEntry.changes,	viaNet: IF newEntry.context # NIL	  THEN newEntry.context.netNumber	  ELSE nullNetworkNumber,	viaHost: newEntry.route],      old: [        net: oldEntry.net,        hops: oldEntry.delay,	closest: oldEntry.closest,	age: oldEntry.age,	changes: oldEntry.changes,	viaNet: IF oldEntry.context # NIL	  THEN oldEntry.context.netNumber	  ELSE nullNetworkNumber,	viaHost: oldEntry.route]	];    };  --NotifyOfChange    ProbeINRs: PROC =    BEGIN    -- Does multiple BroadcastRoutingRequests to find out the network    -- numbers, called at start time.    probeInterval: CARDINAL = 5;    i: CARDINAL;    NullNetNum: ENTRY PROC RETURNS [BOOLEAN] =      BEGIN      --checks if any networks on device chain have null net numbers.      FOR n: Device ¬ Driver.GetDeviceChain[], n.next UNTIL n = NIL DO        c: RoutingTable.NetworkContext ¬ Protocol1.GetContext[n, ns];	SELECT TRUE FROM	  (c = NIL) => LOOP;  --what! a driver that doesn't support us!	  (~c.network.alive) => LOOP;  --he would but he croaked	  (c.netNumber = nullNetworkNumber) => RETURN[TRUE];	  ENDCASE;	ENDLOOP;      RETURN [FALSE];      END;  -- NullNetNum    <<    This could take a long time if we had trouble getting responses.    This may be over-kill for one net that is still unnumbered.    >>    FOR i IN [0..10) UNTIL pleaseStop DO      IF (i MOD probeInterval) = 0 THEN PokeForNetworkNumbers[];      Process.Pause[Process.MsecToTicks[1000]];      IF NOT NullNetNum[] THEN EXIT;      ENDLOOP;    END;  --ProbeINRs          ProcessRoutingInfoPacket: PROC [b: NSBuffer.Buffer] = {    ExamineResponsePacket: ENTRY PROC =      BEGIN      SELECT TRUE FROM	(body.destination.host = myHostID) =>	  IF CommFlags.doStats THEN Stats.StatIncr[statDirectedReceived];	ENDCASE =>	  IF CommFlags.doStats THEN Stats.StatIncr[statGratReceived];      [] ¬ UpdateRoutingTable[b];      NSBuffer.ReturnBuffer[b];      END; -- of ExamineResponsePacket          -- start of procedure    body: NSBuffer.Body = b.ns;     incomingContext: RoutingTable.NetworkContext ¬ b.fo.context;    SELECT TRUE FROM      --interested only in routing protocol packets      (body.packetType # routingInformation) => NULL;            --sender should know himself      (body.source.host = nullHostNumber) => NULL;            --buffer didn't arrive through one of our drivers      (incomingContext = NIL) => IF CommFlags.doDebug THEN        Driver.Glitch[DriverDidntNoteNet];	      --is the network it came in on alive?      (~incomingContext.network.alive) => NULL;            -- answer explicit requests      (body.routingType = routingInfoRequest) AND (body.destination.host = myHostID) => SendReply[b];            -- answer explicit extended requests      (body.routingType = LOOPHOLE[InrTypes.RoutingInfoType[routingInfoExtendedRequest]]) AND (body.destination.host = myHostID) => SendReply[b, TRUE];            --not a request, extended request, or a response - so what is it?      (body.routingType # routingInfoResponse) => NULL;            --can't learn anything new from ourselves      (body.source.host = myHostID) => NULL;            --did this come from our local net?      (body.transportControl.hopCount = 0) => {	IF CommFlags.doStats THEN Stats.StatIncr[statNSGatewayPacketsRecv];        ExamineResponsePacket[];	RETURN; 	};      ENDCASE;          IF CommFlags.doStats THEN Stats.StatIncr[statJunkBroadcastNS];    NSBuffer.ReturnBuffer[b];    };  -- ProcessRoutingInfoPacket      SendReply: PROC [reqB: NSBuffer.Buffer, doExtended: BOOLEAN ¬ FALSE] = {    b: NSBuffer.Buffer;    exReqB: LONG POINTER TO InrTypes.ExtendedRoutingInformation;    exReplyB: LONG POINTER TO InrTypes.ExtendedRoutingInformation;    tuples: CARDINAL;    bytesPerTuple: CARDINAL ¬ bytesPerRoutingInfoTuple;    IF doExtended THEN bytesPerTuple ¬ bytesPerExtendedRoutingInfoTuple;    tuples ¬ reqB.ns.pktLength - NSTypes.bytesPerIDPHeader - bytesPerRoutingInfoType;     tuples ¬ IF doExtended      THEN (tuples / bytesPerExtendedRoutingInfoTuple)      ELSE (tuples / bytesPerRoutingInfoTuple);    exReqB ¬ LOOPHOLE[@reqB.ns.routingType];    IF tuples = 1      AND (IF doExtended        THEN exReqB.routingTuple[0].objectNetID        ELSE reqB.ns.routingTuple[0].objectNetID) = allNets THEN {      Process.Detach[FORK SendTable[reqB.ns.source, doExtended]];      RETURN;      };    b ¬ NSBuffer.GetBuffer[myAccessHandle, send, FALSE, reqB.ns.pktLength];    IF b # NIL THEN {      body: NSBuffer.Body;      body ¬ b.ns;      exReplyB ¬ LOOPHOLE[@body.routingType];      body.packetType ¬ routingInformation;      b.ns.routingType ¬ IF doExtended	THEN LOOPHOLE[InrTypes.RoutingInfoType[routingInfoExtendedResponse]]	ELSE routingInfoResponse;      body.transportControl ¬ initialTransportControl;      body.destination ¬ reqB.ns.source;      body.pktLength ¬ NSTypes.bytesPerIDPHeader + bytesPerRoutingInfoType;      FOR i: CARDINAL IN [0..tuples) DO	net: System.NetworkNumber;	SELECT TRUE FROM	  doExtended => {	    networkEntry: RouterBackdoor.NetworkEntry;	    noEntry: BOOLEAN ¬ FALSE;	    net ¬ exReqB.routingTuple[i].objectNetID;	    networkEntry ¬ GetNetInfo[net !	      Router.NoTableEntryForNet => {noEntry ¬ TRUE; CONTINUE;}];	    exReplyB.routingTuple[i] ¬ SELECT TRUE FROM	      noEntry => [net, infinity, nullNetworkNumber, nullHostNumber],	      ENDCASE => [net, MIN[networkEntry.hops + 1, infinity], networkEntry.viaNet, networkEntry.viaHost];	    };	  ENDCASE => {	    net ¬ reqB.ns.routingTuple[i].objectNetID;	    body.routingTuple[i] ¬ [net, MIN[GetDelay[net] + 1, infinity]];	    };	body.pktLength ¬ body.pktLength + bytesPerTuple;	ENDLOOP;      Socket.PutPacket[cH, b];      };    };      SendTable: PROC [dest: System.NetworkAddress, doExtended: BOOLEAN ¬ FALSE] = {    b: NSBuffer.Buffer ¬ NIL;    tuples: CARDINAL ¬ 0;    net: System.NetworkNumber;    extended: LONG POINTER TO InrTypes.ExtendedRoutingInformation;    maxTuples: CARDINAL ¬ maxTuplesPerRoutingPacket;    bytesPerTuple: CARDINAL ¬ bytesPerRoutingInfoTuple;    IF doExtended THEN maxTuples ¬ maxTuplesPerExtendedRoutingPacket;    IF doExtended THEN bytesPerTuple ¬ bytesPerExtendedRoutingInfoTuple;    FOR hops: CARDINAL IN [0..infinity) DO      net ¬ startEnum;      WHILE (net ¬ Enumerate[net, hops]) # endEnum DO	IF tuples = 0 THEN {	  b ¬ NSBuffer.GetBuffer[myAccessHandle, send];	  IF b # NIL THEN {	    b.ns.packetType ¬ routingInformation;	    b.ns.routingType ¬ IF doExtended	      THEN LOOPHOLE[InrTypes.RoutingInfoType[routingInfoExtendedResponse]]	      ELSE routingInfoResponse;	    b.ns.transportControl ¬ initialTransportControl;	    b.ns.destination ¬ dest;	    b.ns.pktLength ¬ NSTypes.bytesPerIDPHeader + bytesPerRoutingInfoType;	    extended ¬ LOOPHOLE[@b.ns.routingType];	    };	  };	IF tuples < maxTuples THEN {	  IF NOT doExtended	    THEN b.ns.routingTuple[tuples] ¬ [net, MIN[GetDelay[net] + 1, infinity]]	    ELSE {	      networkEntry: RouterBackdoor.NetworkEntry;	      noEntry: BOOLEAN ¬ FALSE;	      networkEntry ¬ GetNetInfo[net !		Router.NoTableEntryForNet => {noEntry ¬ TRUE; CONTINUE;}];	      extended.routingTuple[tuples] ¬ SELECT TRUE FROM		noEntry => [net, infinity, nullNetworkNumber, nullHostNumber],		ENDCASE => [net, MIN[networkEntry.hops + 1, infinity], networkEntry.viaNet, networkEntry.viaHost];	      };	  b.ns.pktLength ¬ b.ns.pktLength + bytesPerTuple;	  tuples ¬ tuples + 1;	  };	IF tuples >= maxTuples THEN {	  Socket.PutPacket[cH, b];	  b ¬ NIL;	  tuples ¬ 0;	  };	ENDLOOP;      ENDLOOP;    IF b # NIL THEN Socket.PutPacket[cH, b];    };      RemoveDriver: ENTRY PROC [context: RoutingTable.NetworkContext] =    BEGIN    <<    This procedure "removes" the specified attached network and all entries    referencing it from the routing table. Multi entries may use this net.    >>    count: NATURAL ¬ 0;    entry: Entry;    IF table.me.context # NIL  --make sure we haven't already done this      AND table.me.context.network = context.network THEN table.me ¬ [];     FOR entry ¬ table.lowest, entry ¬ entry.next WHILE entry # NIL DO      IF entry.context # NIL AND entry.context.network = context.network THEN {        entry.context ¬ NIL;	entry.age ¬ suspect;  -- help us find a new route quicker	};      ENDLOOP;    END;  --RemoveDriver  RoutingTableActivate: ENTRY PROC =    BEGIN    now: System.GreenwichMeanTime ¬ Time.Current[];    times ¬ [now, now, now];    myHostID ¬ Router.FindMyHostID[];    TableFault[];  -- set up the table    END;  --RoutingTableActivate   RoutingTableDeactivate: ENTRY PROC =    BEGIN    pleaseStop ¬ TRUE;    END;  --RoutingTableDeactivate          RoutingTableFork: SocketInternal.ListenerProcType = {    ProcessRoutingInfoPacket[b];    }; -- of RoutingTableFork          Sweeper: PROC = {    ENABLE UNWIND => NULL;    -- process to sweep the table periodically    now: System.Pulses;    interval: System.Pulses =      System.MicrosecondsToPulses[LONG[sweepInterval] * 1000000];    timeOfLastCheck: System.Pulses ¬ System.GetClockPulses[];    UNTIL pleaseStop DO      Process.Pause[Process.MsecToTicks[1000]];      now ¬ System.GetClockPulses[];      IF (now - timeOfLastCheck) > interval THEN {	CheckRoutingTableEntries[];	timeOfLastCheck ¬ now;	};      ENDLOOP;    };  -- Sweeper  Start: PROC =    BEGIN  --This procedure turns the router on.    priority: Process.Priority = Process.GetPriority[];  --save current    pleaseStop ¬ FALSE;    RoutingTableActivate[];    cH ¬ SocketInternal.CreateListen[      socket: NSConstants.routingInformationSocket,      callback: RoutingTableFork, clientData: NIL,       send: 2, receive: receiveBuffers, type: routingInformation];    myAccessHandle ¬ Socket.GetBufferPool[cH];    Process.SetPriority[CommPriorities.receiver];  --let's get some cycles    sweeperProcess ¬ FORK Sweeper[];  -- ages entries    Process.Detach[FORK ProbeINRs[]];  -- find out the network numbers.    Process.SetPriority[priority];  --then back to whatever we started with    END;  --Start  Stop: PROC =    BEGIN    RoutingTableDeactivate[];  -- sets pleaseStop ¬ TRUE    JOIN sweeperProcess;    Socket.Delete[cH];    CleanUpRoutingTable[];    END;  --Stop  routeHint: Entry ¬ NIL;    Transmit: ENTRY PROC [b: NSBuffer.Buffer] =    BEGIN    <<    Called to transmit a packet, this proc searches the routing table    for the destination net.  If found, the proc sends the packet.    If the destination net is null, we simply shove it out    on the first network on the chain.  In case of an abort, the caller owns    the buffer.    >>    ENABLE UNWIND => NULL;    entry: Entry;    nextHost: HostNumber;    body: NSBuffer.Body = b.ns;    FindEntryForTransmit: INTERNAL PROC [net: NetworkNumber] RETURNS [Entry] = INLINE {      IF routeHint # NIL AND routeHint.net = net        THEN RETURN[routeHint]	ELSE RETURN[routeHint ¬ FindEntry[net]];      };    SELECT TRUE FROM      (body.destination.net = nullNetworkNumber) => {	--running on net with no INR (using null net numbers).	device: Device ¬ b.fo.network ¬ Driver.GetDeviceChain[];	SELECT TRUE FROM	  (device = NIL),  --there are no devices on the chain	  (~device.alive),  --the first one isn't alive	  ((b.fo.context ¬ Protocol1.GetContext[device, ns]) = NIL) =>	    --that device doesn't support ns--	    BEGIN	    --no network present, drop the packet	    b.fo.status ¬ RouterInternal.XmitStatus[noRouteToNetwork];	    PutOnGlobalDoneQueue[b];  --give it back to system	    IF CommFlags.doStats THEN Stats.StatIncr[statNSSentNowhere];	    RETURN;  --get out of here	    END;	  ENDCASE;	nextHost ¬ body.destination.host;  --the destination is immedate	};      (entry ¬ FindEntryForTransmit[body.destination.net]) = NIL => {	-- destination net is not reachable. 	b.fo.status ¬ RouterInternal.XmitStatus[noRouteToNetwork];	PutOnGlobalDoneQueue[b];  -- client may get it back	IF CommFlags.doStats THEN Stats.StatIncr[statNSSentNowhere];	RETURN;	};      ((b.fo.context ¬ entry.context) = NIL) => {	-- the driver behind this route has been deleted	-- assertion: this is local network access via table.me	b.fo.status ¬ RouterInternal.XmitStatus[noRouteToNetwork];	PutOnGlobalDoneQueue[b];  --client may get it back	IF CommFlags.doStats THEN Stats.StatIncr[statNSSentNowhere];	RETURN;	};      (entry.delay < infinity) =>	BEGIN	-- entry exists in table already.	b.fo.network ¬ entry.context.network; --mark the network being used	-- outgoing packet to be transmitted over the correct network	nextHost ¬ IF entry.route # nullHostNumber THEN entry.route 	ELSE body.destination.host; -- we are attached to the destination net	END;      ENDCASE =>	BEGIN	--entry exists, but the destination net is not reachable. 	b.fo.status ¬ RouterInternal.XmitStatus[noRouteToNetwork];	PutOnGlobalDoneQueue[b];  --client may get it back	IF CommFlags.doStats THEN Stats.StatIncr[statNSSentNowhere];	RETURN;	END;    b.fo.status ¬ RouterInternal.XmitStatus[goodCompletion];    Protocol1.EncapsulateAndTransmit[LOOPHOLE[b], @nextHost];    END;  -- Transmit  UpdateRoutingTable: INTERNAL PROC [    b: NSBuffer.Buffer,    destNetNum: System.NetworkNumber ¬ nullNetworkNumber]    RETURNS [success: BOOLEAN ¬ FALSE] = {    -- Process RIP response packet.    -- Updates the table with the information in the tuples.    i: CARDINAL;    tuples: CARDINAL;    newDelay: CARDINAL;    entry: Entry ¬ NIL;    body: NSBuffer.Body = b.ns;    tuple: NSTypes.RoutingInfoTuple;    reason: ChangeReason ¬ ignore;    c: RoutingTable.NetworkContext = NARROW[b.fo.context];    IF c.netNumber = nullNetworkNumber THEN  --do we understand life?      c.netNumber ¬ body.source.net;  --copy net number to context    IF table.me.net = nullNetworkNumber THEN      table.me ¬ [net: body.source.net, context: b.fo.context];  --I'm special    tuples ¬ (body.pktLength - NSTypes.bytesPerIDPHeader -      (Environment.bytesPerWord * SIZE[NSTypes.RoutingInfoType])) /      (Environment.bytesPerWord * SIZE[NSTypes.RoutingInfoTuple]);    FOR i IN [0..tuples) DO      tuple ¬ body.routingTuple[i];  -- pick the tuple our for easy access      newDelay ¬ Inline.BITAND[mask, tuple.interrouterDelay];  -- strip high bits.      IF newDelay > infinity THEN newDelay ¬ infinity;      IF tuple.objectNetID = allNets        OR tuple.objectNetID = nullNetworkNumber THEN LOOP;  -- bogus info      entry ¬ FindEntry[tuple.objectNetID];      IF entry = NIL        THEN {	  entry ¬ AddEntry[tuple.objectNetID];	  reason ¬ new;	  }	ELSE reason ¬ SELECT TRUE FROM	  entry.route = body.source.host =>  -- same router	    SELECT newDelay FROM	      = entry.delay => refresh,	      infinity => deadByRIP,	      < entry.delay => shorter,	      > entry.delay => longerByRIP,	      ENDCASE => ERROR,	  newDelay < entry.delay =>  -- different router but shorter	    shorter,	  entry.age >= suspect =>  -- different router but newer info	    IF newDelay = infinity	      THEN (IF entry.delay = infinity THEN ignore ELSE deadByRIP)	      ELSE differentRouter,	  ENDCASE => ignore;  -- other routers with same or longer paths      SELECT reason FROM        refresh => entry.age ¬ fresh;  -- most common so we put it first	ignore => LOOP;	ENDCASE => {	  oldEntry: TableEntry ¬ entry­;	  entry.age ¬ fresh;	  entry.delay ¬ newDelay;	  IF newDelay < entry.closest THEN entry.closest ¬ newDelay;	  entry.route ¬ body.source.host;	  entry.context ¬ b.fo.context;	  NotifyOfChange[reason, entry, @oldEntry];	  };      Process.Yield[];      ENDLOOP;    };  -- UpdateRoutingTable          END.  --RoutingTableImpl module.<<LOG:18-Jul-90 11:00:16	WIrish				Revamped module to run a full routing table:				Threw out all of the bogus route-caching stuff.				Changed internal data-structure to an efficient hash-table.				We now maintain a full routing table and provide				hooks into RouterBackdoor for improved monitoring				and debugging.26-May-92 10:54:08	WIrish				Fixed so that we now support multiple devices properly.20-Nov-92  9:06:35	WIrish				Added SendReply and SendTable.  We now respond to				explicit routing requests for improved debugging				and diagnostics. 9-Mar-93 16:41:25      WIrish  Added more values for larger hash tables. 				Bumped the default index for a larger initial				hash table.>>
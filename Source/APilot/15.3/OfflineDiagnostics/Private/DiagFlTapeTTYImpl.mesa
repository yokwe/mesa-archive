-- Copyright (C) 1982, 1987  by Xerox Corporation. All rights reserved. ---- File: DiagFlTapeTTYImpl.mesa -- Edited by: JMA 23-Feb-88 12:06:49--  DIRECTORY  DiagFlTapeMkMenu     	USING	[mkMenu],  DiagFlTapeMkOpInt	USING	[mkOpInt],  DiagFlTapeOpInt	USING	[--Engineering,--Switch],  DiagFlTapeTestSelect	USING 	[currentOptDispl],  OfflineDiagInterface 	USING 	[LookForAbort, DiagHeap,			     	 HelpText, GetAHelpText, AbortCurrentTest,			      	 PutMessage, HitAnyKeyToContinue, GetAnOption,			      	 GetYesNo, GetANumber,-- PutData,-- OptionsRecord,				 GetAnOptionsRecord, OptionItem, GetAString,				 AnOptionLine, GetAnOptionLine],--  Runtime		USING	[CallDebugger],  String		USING	[AppendChar, AppendString, AppendDecimal,				 AppendLongDecimal, StringToDecimal,				 StringToNumber,-- StringToLongNumber,--				 MakeString],  System		USING   [switches],				   DiagFlTapeTTY		USING	[];  DiagFlTapeTTYImpl: PROGRAM     IMPORTS    	OfflineDiagInterface,	DiagFlTapeMkMenu,	DiagFlTapeMkOpInt,	DiagFlTapeTestSelect,	DiagFlTapeOpInt,	String,	System    EXPORTS	DiagFlTapeTTY	 = BEGIN    OPEN    	Odi: OfflineDiagInterface, 	-- ODI stands for OfflineDiagInterface.	DiagFlTapeMkMenu,		-- for the messages	DiagFlTapeMkOpInt;		-- for the messages	         CharsPerLine:		PUBLIC CARDINAL; --char in a line= usually 80  CRAtCharPosition:	PUBLIC CARDINAL; --char number at which an CR is done  CharPosition:		PUBLIC CARDINAL¬ 0;  UserAbort:		PUBLIC SIGNAL= CODE;  CursorAtStartPosition:PUBLIC BOOLEAN¬ TRUE;    DirtyLines:		CARDINAL¬ 0;  goodTtyHandle:	BOOLEAN¬ FALSE;  inMessageArea:	BOOLEAN¬ FALSE;  LinesDisplayed:	CARDINAL¬ 0;  ScreenLines:		PUBLIC CARDINAL¬ 24;  traceDbug: 		BOOLEAN ¬ FALSE;     -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Converts an ARRAY OF LONG STRING to HelpText  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ConvertToHelpText: PROCEDURE [numLines: CARDINAL,  		numberExplanations: BOOLEAN¬ FALSE,  		textStr: LONG DESCRIPTOR FOR ARRAY OF LONG STRING]  RETURNS [help: LONG POINTER TO Odi.HelpText ¬ NIL] =  BEGIN  str:	LONG STRING ¬ NIL;    IF BASE [textStr]= NIL OR numLines= 0 THEN RETURN;  help ¬ Odi.GetAHelpText [numLines];    IF numberExplanations THEN    { -- add the number and spacing    FOR inx:CARDINAL IN [0..numLines) DO      -- create string then append the number and spacing      str ¬ String.MakeString [Odi.DiagHeap, CharsPerLine];      str.length ¬ 0;      String.AppendDecimal [str, inx+1];      String.AppendString [str, " - "L];      String.AppendString [str, textStr[inx]];      help.textBody[inx] ¬ str;    ENDLOOP }      ELSE {  -- no number, just text    FOR inx:CARDINAL IN [0..numLines) DO      help.textBody[inx] ¬ textStr[inx];    ENDLOOP };    END;  -- ConvertToHelpText           -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Displays the given char on the screen  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    AddChar: PUBLIC PROCEDURE [		char: CHARACTER,		charCount: CARDINAL¬ 1,		checkLineLength: BOOLEAN¬ FALSE]  = BEGIN  str: LONG STRING ¬ [8];    UNTIL charCount = 0 DO    str.length ¬ 0;    SELECT char FROM       15C	=> PutCR [];       10C	=> NULL;  -- BS       ENDCASE  => { String.AppendChar [str, char];       		     AddString [str] };    charCount¬ charCount- 1;  ENDLOOP;   IF traceDbug THEN {    Odi.PutMessage [message: "DFTTTY.AddChar "L];    [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE] }  END; --AddChar	  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- displays the given number on the screen  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    AddDecimal: PUBLIC PROCEDURE [		number: CARDINAL,		signed: BOOLEAN¬ FALSE,		plus:	BOOLEAN¬ FALSE,		checkLineLength: BOOLEAN¬ FALSE]  = BEGIN  lngNum: LONG CARDINAL;  str: LONG STRING¬ [8];    IF signed THEN    IF plus THEN AddString [mkOpInt[plus]] ELSE AddString [mkOpInt[minus]];  lngNum¬ number;  str.length¬ 0;  String.AppendLongDecimal [str, lngNum];  AddString [str];    IF traceDbug THEN {    Odi.PutMessage [message: "DFTTTY.AddDecimal "L];    [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE] }  END; --AddDecimal  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- displays the given number on the screen  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    AddLongDecimal: PUBLIC PROCEDURE [		number:		 LONG CARDINAL,		signed:		 BOOLEAN¬ FALSE,		plus:		 BOOLEAN¬ TRUE,		checkLineLength: BOOLEAN¬ FALSE]  = BEGIN  lngNum: LONG CARDINAL;  str: LONG STRING¬ [8];    IF signed THEN    IF plus THEN AddString [mkOpInt[plus]] ELSE AddString [mkOpInt[minus]];  lngNum¬ number;  str.length¬ 0;  String.AppendLongDecimal [str, lngNum];  AddString [str];    IF traceDbug THEN {    Odi.PutMessage [message: "DFTTTY.AddDecimal "L];    [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE] }  END; --AddDecimal   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Displays the given string and keeps track of its length  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   AddString: PUBLIC PROCEDURE [		string: LONG STRING¬ NIL,		checkLineLength: BOOLEAN¬ FALSE]  = BEGIN  IF string# NIL THEN    { Odi.PutMessage[message: string, startWithNewLine: FALSE, blankSpaces: 0];      CharPosition ¬ 1};  -- set it to non-zero  IF traceDbug    THEN { Odi.PutMessage [message: "DFTTTY.AddString "L];           [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE] };   END; --AddString    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- checks the length of a line on a CRT and does an automatic CR for you  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    CheckLineLength: PUBLIC PROCEDURE  = BEGIN    IF traceDbug THEN {    Odi.PutMessage [message: "DFTTTY.CheckLineLength "L];    [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE] }  END; --CheckLineLength   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- clears all the entered characters not yet accepted by the program -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ClearBackedUpChars: PUBLIC PROCEDURE = BEGIN IF traceDbug THEN {   Odi.PutMessage [message: "DFTTTY.ClearBackedUpChars "L];   [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE] } END; --ClearBackedUpChars--  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- clears the number or prior line count given -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ClearPriorLines: PUBLIC PROCEDURE [lineCount: CARDINAL¬ 1] = BEGIN IF traceDbug THEN  {   Odi.PutMessage [message: "DFTTTY.ClearPriorLines "L];   [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE]} END; --ClearPriorLine   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- echos the given character then displays a '?'  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    EchoPutQuestionMark: PROCEDURE =  BEGIN  Odi.PutMessage[message: mkOpInt[invalidEntry], beep: TRUE];  END; --EchoPutQuestionMark     -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- deletes characters on the CRT of the desired count  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    EraseText: PUBLIC PROCEDURE [		stringLength: CARDINAL¬ 0,		decrCharPosition: BOOLEAN¬ TRUE]  = BEGIN   IF traceDbug THEN {    Odi.PutMessage [message: "DFTTTY. EraseText"L];    [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE]}  END; --EraseText   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets and returns a character from the user -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetChar: PUBLIC PROCEDURE RETURNS [char: CHARACTER] = BEGIN IF traceDbug THEN {   Odi.PutMessage [message: "DFTTTY.GetChar "L];   [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE]};    CheckIfUserAbort[];  END; --GetChar -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the desired long number -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetLongNumber: PUBLIC PROCEDURE [    prompt: 		LONG STRING¬ NIL,    clearBackedUPChars:	BOOLEAN¬ TRUE,		--ignored    acceptNumWithin:	BOOLEAN¬ FALSE,    minNumber:		LONG CARDINAL¬ 0,    maxNumber:		LONG CARDINAL¬ 0,     useOnlyExp:		BOOLEAN¬ FALSE,    explLines:		CARDINAL¬ 0,    explanation: LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0]] RETURNS [longNumber: LONG CARDINAL] =BEGIN  help: LONG POINTER TO Odi.HelpText ¬ NIL;    IF BASE [explanation]# NIL THEN       help ¬ ConvertToHelpText [LENGTH [explanation], FALSE, explanation];  IF traceDbug THEN Odi.PutMessage [message: "DFTTTY.GetLongNumber "L];  longNumber ¬ Odi.GetANumber [prompt: prompt,  		help: help,		lowLimit: minNumber,		upperLimit: maxNumber,		numberIsLong: TRUE].longNumber;  END; --GetLongNumber	       -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- gets the desired number both in string form and in Cardinal  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetNumber: PUBLIC PROCEDURE [    prompt: LONG STRING¬ NIL,    deletePrompt: BOOLEAN¬ FALSE, --delete the prompt message    clearBackedUPChars:	BOOLEAN		¬TRUE,    displayExplanation: BOOLEAN¬ FALSE, --displays the explanations    delNum: BOOLEAN¬ FALSE, --delete the number on the screen    signed: BOOLEAN¬ FALSE, --requires a + or - in front of the number    numberInHex: BOOLEAN¬ FALSE,    acceptNumWithin: BOOLEAN¬ FALSE, --range is specified with minNumber & maxNumber    minNumber: CARDINAL¬ 0, --low number of acceptNumWithin    maxNumber: CARDINAL¬ 0, --high number of acceptNumWithin     acceptOnlyValidNums: BOOLEAN¬ FALSE, --    validNums: LONG DESCRIPTOR FOR ARRAY OF CARDINAL¬ DESCRIPTOR [NIL, 0],    --lines of explanation when a ? is entered    useOnlyExp: BOOLEAN¬ FALSE, --do not output the full array of explanations    explLines: CARDINAL¬ 0, --number of explanation lines to be output    explanation: LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0],    numberExplanations:	BOOLEAN¬ FALSE]  RETURNS [    numInStrForm: LONG STRING¬ "000000000000",    num: CARDINAL,    positive: BOOLEAN¬ TRUE]     =BEGIN help: LONG POINTER TO Odi.HelpText ¬ NIL;   IF explLines# 0 THEN     help ¬ ConvertToHelpText [explLines, FALSE, explanation]; IF traceDbug THEN Odi.PutMessage [message: "DFTTTY.GetNumber "L]; [--longNumber--, num, positive, numInStrForm] ¬ Odi.GetANumber [prompt: prompt, 		help: help,		lowLimit: minNumber,		upperLimit: maxNumber,		numberIsLong: FALSE];  END; --GetNumber -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the desired number both in string form and in Cardinal -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetString: PUBLIC PROCEDURE [   prompt: LONG STRING,   inputString: LONG STRING,   stringLength: CARDINAL,   terminateEntry: CHARACTER¬ 15C,   explanation: LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0]] =     BEGIN help: LONG POINTER TO Odi.HelpText ¬ NIL;  IF stringLength= 0 THEN RETURN; IF BASE [explanation]# NIL THEN     help ¬ ConvertToHelpText [LENGTH [explanation], FALSE, explanation];   inputString.length¬ 0; IF traceDbug THEN Odi.PutMessage [message: "DFTTTY.GetString "L]; String.AppendString [inputString, Odi.GetAString [prompt: prompt, help: help]]; END; --GetNumber		     -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- returns the time in hours, minutes and seconds -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetTime: PUBLIC PROCEDURE [		seconds: LONG CARDINAL,		timeString: LONG STRING --string to be 32 chararacters in length--] = BEGIN count: LONG CARDINAL;		 timeString.length¬ 0; IF seconds>= 3600 THEN {    count¬ seconds/3600;    seconds¬ seconds MOD 3600;    String.AppendLongDecimal [timeString, count];    String.AppendString [timeString, " "L];    IF count= 1     THEN String.AppendString[timeString, mkOpInt[hour]]     ELSE String.AppendString[timeString, mkOpInt[hrs]];    String.AppendString [timeString, " "L]}; IF seconds>= 60 THEN {    count¬ seconds/60;    seconds¬ seconds MOD 60;    String.AppendLongDecimal [timeString, count];    String.AppendString [timeString, " "L];    String.AppendString [timeString, mkOpInt[mins]];    String.AppendString [timeString, " "L]};     IF seconds> 0 THEN {    String.AppendLongDecimal [timeString, seconds];    String.AppendString [timeString, " "L];    String.AppendString [timeString, mkOpInt[secs]]}; END; --GetTime     -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets a yes or no answer and returns a BOOLEAN (TRUE for yes/ FALSE for no) -- a default answer can be selected and it also checks for The BREAK/ControlC -- Key input in which case it signals Exit -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetYesNo: PUBLIC PROCEDURE [   prompt: LONG STRING¬ NIL,   defaultYes: BOOLEAN¬ FALSE,   checkIfAbort: BOOLEAN¬ TRUE,   messageForm: BOOLEAN¬ FALSE,   returnIfNoInput: BOOLEAN¬ FALSE,   keepScreenOn: BOOLEAN¬ FALSE,   explanation: LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0],   partOfCharCount: BOOLEAN¬ FALSE]	RETURNS [yes: BOOLEAN] =  BEGIN  help: LONG POINTER TO Odi.HelpText ¬ NIL;   IF BASE [explanation]# NIL THEN     help ¬ ConvertToHelpText [LENGTH [explanation], FALSE, explanation];    IF defaultYes= TRUE     THEN yes ¬ TRUE	-- then the default response is YES    ELSE yes ¬ FALSE;   -- else the default response is NO  IF traceDbug THEN Odi.PutMessage [message: "DFTTTY.GetYesNo "L];  yes ¬ Odi.GetYesNo [prompt: prompt,  		help: help,		defaultSpecified: TRUE,		default: yes];		  END; --GetYesNo    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    HexStrToNum: PUBLIC PROCEDURE [str: LONG STRING] RETURNS [n: CARDINAL] =  BEGIN  charptr: CARDINAL¬ 1;  count: CARDINAL¬ 0;  char: CHARACTER;  string: LONG STRING¬ "00000000";    UNTIL str.length= 0 DO  str.length¬ str.length- 1;  char¬ str.text [str.length];  SELECT char FROM  IN ['0..'9] => {	string.length¬ 0;	String.AppendChar [string, char];	count¬ String.StringToDecimal [string];	IF charptr= 1 THEN n¬ count;	IF charptr= 2 THEN n¬ n+ count*16;	IF charptr= 3 THEN n¬ n+ count*256;	IF charptr= 4 THEN n¬ n+ count*4096};	'a,'A => {IF charptr= 1 THEN n¬ 10;	IF charptr= 2 THEN n¬ n+ 160;	IF charptr= 3 THEN n¬ n+ 2560;	IF charptr= 4 THEN n¬ n+ 40960};	'b,'B => {IF charptr= 1 THEN n¬ 11;	IF charptr= 2 THEN n¬ n+ 176;	IF charptr= 3 THEN n¬ n+ 2816;	IF charptr= 4 THEN n¬ n+ 45056};	'c,'C => {IF charptr= 1 THEN n¬ 12;	IF charptr= 2 THEN n¬ n+ 192;	IF charptr= 3 THEN n¬ n+ 3072;	IF charptr= 4 THEN n¬ n+ 49152};	'd,'D => {IF charptr= 1 THEN n¬ 13;	IF charptr= 2 THEN n¬ n+ 208;	IF charptr= 3 THEN n¬ n+ 3328;	IF charptr= 4 THEN n¬ n+ 53248};	'e,'E => {IF charptr= 1 THEN n¬ 14;	IF charptr= 2 THEN n¬ n+ 224;	IF charptr= 3 THEN n¬ n+ 3584;	IF charptr= 4 THEN n¬ n+ 57344};	'f,'F => {IF charptr= 1 THEN n¬ 15;	IF charptr= 2 THEN n¬ n+ 240;	IF charptr= 3 THEN n¬ n+ 3840;	IF charptr= 4 THEN n¬ n+ 61440};	ENDCASE;	charptr¬ charptr+ 1;	ENDLOOP;	END; --HexStrToNum		-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	  Initialize: PUBLIC PROCEDURE	[	charactersPerLine:	CARDINAL¬ 80,	returnAtCharPosition:	CARDINAL¬ 50,	linesOnScreen:		CARDINAL¬ 24] =  BEGIN  cnt: CARDINAL¬ 0;	  ScreenLines¬ linesOnScreen;  LinesDisplayed¬ 0;  CharPosition¬ 0;  DirtyLines¬ 0;  CharsPerLine¬ charactersPerLine;  CRAtCharPosition¬ returnAtCharPosition;    IF traceDbug         THEN  Odi.PutMessage [message: "DFTTTY.Initialize "L]    ELSE Odi.PutMessage [clearMessageAreaFirst: TRUE];  END; --Initialize	-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~	 InvalidNum: PROCEDURE	[		messageStr: LONG STRING¬ NIL,		str: LONG STRING,		memsigned: BOOLEAN¬ FALSE]	RETURNS [signed: BOOLEAN¬ FALSE, msigned: BOOLEAN¬ FALSE] = BEGIN IF messageStr# NIL THEN Odi.PutMessage [message: messageStr]   ELSE Odi.PutMessage [message: mkOpInt[invalidEntry]]; IF str # NIL THEN Odi.PutMessage [message: str]; IF memsigned THEN {	msigned¬ FALSE;	signed¬ TRUE}; END; --InvalidNum	 -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- waits for an input character before continuing -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ProceedOnInput: PUBLIC PROCEDURE [    text: LONG STRING¬ NIL,    keepScreenOn: BOOLEAN¬ FALSE] = BEGIN thisPrompt: LONG STRING;  CheckIfUserAbort[];		 IF text# NIL   THEN thisPrompt ¬ text   ELSE thisPrompt ¬ mkOpInt[typeCharToCont];     IF traceDbug THEN Odi.PutMessage [message: "DFTTTY.ProceedOnInput "L]; Odi.HitAnyKeyToContinue [prompt: thisPrompt, beep: FALSE];		 CheckIfUserAbort[];		 END; --ProceedOnInput   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- displays the given count of characters on the screen  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    PutChar: PUBLIC PROCEDURE [		char: CHARACTER,		charCount: CARDINAL¬ 1]  = BEGIN  str: LONG STRING ¬ String.MakeString[Odi.DiagHeap, charCount];    str.length ¬ 0;  IF traceDbug    THEN { Odi.PutMessage [message: "DFTTTY.PutChar "L];           [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont],	  				 beep: FALSE] }	     ELSE SELECT char FROM           07C		=> Odi.PutMessage [message: " "L, beep: TRUE];	-- BEL 	   32C 		=> Odi.PutMessage [message: " "L, clearMessageAreaFirst: TRUE];  --CLEAR	   IN [0C..37C] => Odi.PutMessage [message: "control char here."L];	   ENDCASE 	=> { String.AppendChar [str, char];	   		     Odi.PutMessage [message: str, startWithNewLine: FALSE,			     		     blankSpaces: 0]			   };  	  END; --PutChar    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- displays a carriage return  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    PutCR: PUBLIC PROCEDURE [count: CARDINAL¬ 1]  =  BEGIN  IF count = 0 THEN count¬ 1;  IF CharPosition = 0 THEN count¬ count+1;  IF count > 1 THEN Odi.PutMessage [message: " "L, numOfBlankLines: count-1];  IF traceDbug THEN Odi.PutMessage [message: "DFTTTY.PutCR "L];  CharPosition¬ 0;  END; --PutCR    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- displays the given line on the screen  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    PutLine: PUBLIC PROCEDURE [str: LONG STRING] =  BEGIN  IF CharPosition = 0    THEN Odi.PutMessage [message:str]    ELSE Odi.PutMessage [message:str, startWithNewLine: FALSE, blankSpaces: 0];  CharPosition¬ 0;  IF traceDbug THEN Odi.PutMessage [message: "DFTTTY.PutLine "L];  END; --PutLine   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- aligns and displays the given number  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    PutLongNumber: PUBLIC PROCEDURE [	number: LONG CARDINAL,	size: CARDINAL¬ 7,	fillSpaceWith:	CHARACTER¬ ' ]  = BEGIN  str:		LONG STRING¬ [20];  newLine:	BOOLEAN ¬ (CharPosition = 0);    str.length ¬ 0;  String.AppendLongDecimal [str, number];  Odi.PutMessage [message: str, startWithNewLine: newLine, blankSpaces: 0];  IF traceDbug THEN Odi.PutMessage [message: "DFTTTY.PutLongNumber "L];  CharPosition¬ 1;  -- set to non-zero  END; --PutLongNumber    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- displays the given menu and returns the selection  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PutMenu: PUBLIC PROCEDURE	[   title: LONG STRING¬ NIL,   startSelectionAt: CARDINAL¬ 1,   options: LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0],   optionExplanation:   	LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0],   numberExplanations: BOOLEAN¬ FALSE,   deleteEntry: BOOLEAN¬ TRUE,   addExitSelection: BOOLEAN¬ TRUE]	RETURNS [selection: CARDINAL¬ 0]	  = BEGIN  optTable:	LONG POINTER TO Odi.OptionsRecord;  optItem:	LONG POINTER TO Odi.AnOptionLine;  optHelp:	LONG POINTER TO Odi.HelpText ¬ NIL;  count:	CARDINAL;  sl:		CARDINAL ¬ startSelectionAt;  numOpt:	CARDINAL ¬ LENGTH[options];  leftEdge:	CARDINAL = 3;    CharPosition¬ 1;  --set to non-zero  IF addExitSelection THEN numOpt ¬ numOpt + 1;  optTable ¬ Odi.GetAnOptionsRecord [numOpt];  IF title # NIL THEN optTable.optionMenuTiTle ¬ title;    count ¬ 0;    UNTIL (count= LENGTH[options] OR options[count]= NIL) DO      optItem ¬ Odi.GetAnOptionLine [optionsPerLine: 1];      optItem.optionsOnALine[0] ¬ Odi.OptionItem [    		position: leftEdge,  		selectionNumberForThisItem: sl,		option: options[count],		helpForThisOption: optionExplanation[count]];      optTable.linesOfOptions [count] ¬ optItem;      count ¬ count + 1;      sl ¬ sl + 1;    ENDLOOP;        IF addExitSelection THEN {      optItem ¬ Odi.GetAnOptionLine [optionsPerLine: 1];      optItem.optionsOnALine[0] ¬ Odi.OptionItem [    		position: leftEdge,  		selectionNumberForThisItem: sl,		option: mkOpInt[exit],		helpForThisOption: optionExplanation[count]];      optTable.linesOfOptions [count] ¬ optItem;      };    optHelp ¬ ConvertToHelpText [LENGTH [optionExplanation], numberExplanations, 				optionExplanation];  IF optHelp # NIL THEN optHelp.helpTitle ¬ mkMenu[testSelection];  selection ¬ Odi.GetAnOption [optionTable: optTable, 			<<defaultOption: optTable.numberOfOptionLines,  -- the EXIT entry>>			optionPrompt: mkOpInt[enterCoiceNum],			--optionPrompt: "",			optionHelp: optHelp,			justDisplayTable: FALSE];  -- save pointer to current option display 			  DiagFlTapeTestSelect.currentOptDispl ¬ optTable;  END; --PutMenu     -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --can be used to clean Dirty Lines only if no message is ginen -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   PutMessage: PUBLIC PROCEDURE [   str:		   LONG STRING¬ NIL,   numberMessages: BOOLEAN¬ FALSE,   strArray:	   LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0],   useOnlyExp:	   BOOLEAN¬ FALSE,   expLines:	   CARDINAL¬ 1,   selectMessages: LONG DESCRIPTOR FOR ARRAY OF CARDINAL¬ DESCRIPTOR [NIL, 0],   endMessage:	   LONG STRING¬ NIL]  =BEGIN	    --check for no message/this is just a clean dirty line operation    IF (str = NIL AND BASE [strArray]= NIL) THEN    { IF NOT traceDbug THEN Odi.PutMessage [message: " "L, clearMessageAreaFirst: TRUE];      RETURN };          --output the string message if there is one    IF str # NIL THEN    { Odi.PutMessage [message: str]};        --output the array of messages if there are any    IF BASE [strArray]# NIL THEN    { FOR inx:CARDINAL IN [0..LENGTH [strArray]) DO        Odi.PutMessage [message: strArray [inx]]      ENDLOOP };          IF traceDbug THEN Odi.PutMessage [message: "DFTTTY.PutMessage "L];      END; --PutMessage   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- aligns and displays the given number -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~      PutNumber: PUBLIC PROCEDURE	[	number:		CARDINAL,	size:		CARDINAL¬ 2,	terminateWith:	LONG STRING¬ NIL,	fillSpaceWith:	CHARACTER¬ ' ]  = BEGIN  str:		LONG STRING¬ [20];  lngNum:	LONG CARDINAL;  newLine: BOOLEAN ¬ (CharPosition = 0);        lngNum¬ number;  str.length ¬ 0;  String.AppendLongDecimal [str, lngNum];  IF terminateWith# NIL THEN String.AppendString[str, terminateWith];  Odi.PutMessage [message: str, startWithNewLine: newLine, blankSpaces: 0];  CharPosition¬ 1;  -- set to non-zero  IF traceDbug THEN Odi.PutMessage [message: "DFTTTY.PutNumber"L];    END; --PutNumber  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- displays a questionmark when an illegal character is entered  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    PutQuestionMark: PUBLIC PROCEDURE  = BEGIN  IF traceDbug THEN {    Odi.PutMessage [message: "DFTTTY.PutQuestionMark "L];    [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE]}  END; --PutQuestionMark    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- advances the given number of spaces on the screen  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    PutSpaces: PUBLIC PROCEDURE [spaceCount: CARDINAL]  = BEGIN  str: LONG STRING ¬ String.MakeString [Odi.DiagHeap, spaceCount+5];  IF spaceCount = 0 THEN RETURN;    --gotta' do it this way 'cuz Odi.PutMessage is BUGGY!!  str.length ¬ 0;  FOR inx:CARDINAL IN [0..spaceCount) DO    String.AppendChar[str,40C];  -- append a SPACE  ENDLOOP;    --Odi.PutMessage [startWithNewLine: FALSE, blankSpaces: spaceCount];  Odi.PutMessage [message: str, startWithNewLine: FALSE, blankSpaces: 0];  IF traceDbug THEN {    Odi.PutMessage [message: "DFTTTY.PutSpaces "L];    [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE]}  END; --PutSpaces    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Displays the given string and keeps track of its length  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    PutString: PUBLIC PROCEDURE [string: LONG STRING¬ NIL]  = BEGIN  newLine: BOOLEAN ¬ (CharPosition = 0);    Odi.PutMessage[message: string, startWithNewLine: newLine, blankSpaces: 0];  CharPosition¬ 1;  -- set to non-zero  IF traceDbug THEN {    Odi.PutMessage [message: "DFTTTY.PutString "L];    [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE]}  END; --PutString   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- clears the prior test name and displays the new test name  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    PutSubtest: PUBLIC PROCEDURE [testName: LONG STRING,		checkIfAbort: BOOLEAN¬ TRUE,		initialize: BOOLEAN¬ FALSE,		clearPriorTest: BOOLEAN¬ TRUE]  = BEGIN    -- check if user abort  IF checkIfAbort THEN CheckIfUserAbort [];  IF initialize     THEN Initialize[]     --if clearPriorTest then clear the line     ELSE IF clearPriorTest THEN     		   { IF traceDbug		     THEN { Odi.PutMessage [message: mkOpInt[subtesT]];			  Odi.PutMessage [message: "clearPriorTest"L] }		     ELSE Odi.PutMessage [message: mkOpInt[subtesT],				          clearMessageAreaFirst: TRUE]		    };				     Odi.PutMessage [message: testName];  IF traceDbug THEN Odi.PutMessage [message: "DFTTTY.PutSubtest"L];  CharPosition¬ 0;  CursorAtStartPosition¬ TRUE;    END; --PutSubtest -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- output the time in hours, minutes and seconds -- USE GetTime Proc -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     PutTime: PUBLIC PROCEDURE [seconds: LONG CARDINAL] = BEGIN IF traceDbug THEN {     Odi.PutMessage [message: "DFTTTY.PutTime"L];     [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE] } END; --PutTime  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the desired numbers and returns an array -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetNumbers: PUBLIC PROCEDURE [    prompt: LONG STRING¬ NIL,    acceptNumWithin: BOOLEAN¬ FALSE,    minNumber: CARDINAL¬ 0,    maxNumber: CARDINAL¬ 0,    numberArray: LONG DESCRIPTOR FOR ARRAY OF CARDINAL,    --Note: the array must be cleared with desire value before being passes    explanation: LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0]] = BEGIN  tooManyEntries:	BOOLEAN¬ FALSE; atThroughNum:		BOOLEAN¬ FALSE; ptr:			CARDINAL; fromNum:		CARDINAL; maxNumCnt:		CARDINAL; c:			CARDINAL¬ 0; char:			CHARACTER; count:			CARDINAL¬ 0; done:			BOOLEAN¬ FALSE; messageStr:		STRING¬ [60]; num:			CARDINAL¬ 1; numCharsRead:		CARDINAL ¬ 0; --how many char of subTestStr were read numStr:		LONG STRING¬ [256]; tempNum:		CARDINAL; tempString:		STRING¬ [60]; subTestStr:		LONG STRING¬ [256]; --the string that the user enters. questtext:		ARRAY [0..15) OF LONG STRING¬ ALL [NIL];  help: 			LONG POINTER TO Odi.HelpText ¬ NIL; thisPrompt:		LONG STRING; badEntry:		BOOLEAN; --~~~~~~~~~internal procedure~~~~~~~~~~ StoreNumbers: PROCEDURE = BEGIN   -- set number array  ptr¬ 0;  atThroughNum¬ FALSE;  count¬ 0;  UNTIL count>= numStr.length OR ptr> maxNumCnt DO     tempString.length¬ 0;     UNTIL count>= numStr.length DO        char¬ numStr.text [count];	count¬ count+ 1;        IF char NOT IN ['0..'9] THEN EXIT	ELSE String.AppendChar [tempString, char];     ENDLOOP;     num¬ String.StringToDecimal [tempString];     IF char= '- THEN     { tempNum¬ num;       atThroughNum¬ TRUE;     } ELSE        IF atThroughNum THEN       { atThroughNum¬ FALSE;	 UNTIL tempNum= num+ 1 OR ptr> maxNumCnt DO	   numberArray [ptr]¬ tempNum;	   ptr¬ ptr+ 1;	   tempNum¬ tempNum+ 1;	 ENDLOOP;       } ELSE        { numberArray [ptr]¬ num;	 ptr¬ ptr+ 1;       }; ENDLOOP; IF ptr> maxNumCnt AND count< numStr.length THEN tooManyEntries¬ TRUE;  END; --of StoreNumbers --~~~~~~~~~end of internal procedure~~~~~~~~~~  UNTIL count= LENGTH [explanation] DO    questtext[count]¬ explanation [count];    count¬ count+ 1; ENDLOOP; questtext[count]¬ mkOpInt[selectOptsExpl1]; count¬ count+ 1; questtext[count]¬ mkOpInt[selectOptsExpl2]; count¬ count+ 1; questtext[count]¬ mkOpInt[selectOptsExpl3]; count¬ count+ 1; questtext[count]¬ mkOpInt[selectOptsExpl4]; count¬ count+ 1; questtext[count]¬ mkOpInt[selectOptsExpl5]; count¬ count+ 1;  maxNumCnt¬ LENGTH[numberArray]- 1; -- build help text help ¬ ConvertToHelpText[LENGTH[explanation]+5,FALSE,DESCRIPTOR [questtext]]; IF prompt= NIL THEN thisPrompt ¬ "Enter number: "L ELSE thisPrompt ¬ prompt;  UNTIL done DO   badEntry ¬ FALSE;   numStr.length¬ 0;   tempString.length¬ 0;   subTestStr.length ¬ 0;   atThroughNum ¬ FALSE;   --Read in the entire string of number or "-" or ","   subTestStr ¬ Odi.GetAString[prompt: thisPrompt, help: help];    FOR inx: CARDINAL IN [0..subTestStr.length) DO  -- parse the string     char¬ subTestStr[inx]; --gets the ith char     SELECT char FROM     IN ['0..'9]=>        BEGIN        IF tempString.length>= 8 THEN {			 []¬ InvalidNum[str: tempString];			 EXIT } -- FOR loop        ELSE { String.AppendChar [tempString, char];	       num¬ String.StringToDecimal [tempString];               -- is number within range               IF (num> maxNumber OR num< minNumber) THEN {	       		[]¬ InvalidNum[str: subTestStr];			badEntry ¬ TRUE;			EXIT;  -- FOR loop-- }              };        END;  -- numeric input         ', => --comma        BEGIN	--check for no number        IF tempString.length= 0 THEN {		badEntry ¬ TRUE;		[]¬ InvalidNum[str: subTestStr];		EXIT } -- FOR loop        ELSE 	  {   num¬ String.StringToDecimal [tempString];              --check if this is a to number (in from/to number)--              IF atThroughNum THEN	         { --check if num is smaller than from num	           IF fromNum>= num THEN {		         []¬ InvalidNum[messageStr: mkOpInt[selectOptsExplWarn],                                        str: subTestStr];			 badEntry ¬ TRUE;		         EXIT; --FOR loop-- }	             ELSE  { --this is a good 'to' number                           String.AppendString [numStr, tempString];                           tempString.length¬ 0;                           String.AppendChar [numStr, char];                           atThroughNum¬ FALSE;	                    };  -- good 'to' number	          } -- atThroughNum	       	      ELSE --not a 'from/to' number                { String.AppendString [numStr, tempString];                  tempString.length¬ 0;                  String.AppendChar [numStr, char] };	   };  -- tempString.length# 0	 END;  -- comma input	    '- =>  -- dash/hyphen   	BEGIN        IF (tempString.length= 0 OR atThroughNum) THEN {	  badEntry ¬ FALSE;	  [] ¬ InvalidNum[str: subTestStr];	  EXIT }  -- FOR loop        ELSE          { num¬ String.StringToDecimal [tempString];            fromNum¬ tempNum¬ num;            String.AppendString [numStr, tempString];            tempString.length¬ 0;            String.AppendChar [numStr, char];            atThroughNum¬ TRUE	   };        END;  -- dash input	    ENDCASE => BEGIN      	       badEntry ¬ TRUE;	       [] ¬ InvalidNum[str: subTestStr];	       EXIT;	       END;  -- FOR loop	   ENDLOOP;  -- FOR inx...	    << Line feed, CR is left over from the Horizon code and        should never occur in this ODI-based code    12C,15C=> --line feed, carriage return = end of entries  >>    IF NOT badEntry AND atThroughNum AND tempString.length= 0 THEN {     [] ¬ InvalidNum[str: subTestStr];     badEntry ¬ TRUE };	    IF NOT badEntry AND atThroughNum THEN       --check if num is smaller than from num      IF fromNum>= num 	 THEN { []¬ InvalidNum[messageStr: mkOpInt[selectOptsExplWarn],                                        str: subTestStr];		badEntry ¬ TRUE };		  IF NOT badEntry AND subTestStr.length # 0 THEN      { --good last entry       numStr ¬ subTestStr;       StoreNumbers[];       IF tooManyEntries THEN	    { FOR i: CARDINAL IN [0..LENGTH[numberArray]) DO	        numberArray[i]¬ 0;	      ENDLOOP }       ELSE done¬ TRUE;      }; -- good last entry       ENDLOOP;  -- UNTIL DONE... --Odi.PutData[data: tempString, startWithNewLine: TRUE]; IF traceDbug THEN {   Odi.PutMessage [message: "DFTTTY.GetNumbers"L];   [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE]} END; --GetNumbers  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the desired numbers and returns an array -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SelectOptions: PUBLIC PROCEDURE [    prompt: LONG STRING¬ NIL,    numberArray: LONG DESCRIPTOR FOR ARRAY OF BOOLEAN,    -- numbers accepted are 1 through LENGTH[numberArray]    explanation: LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0]] =    --lines of explanation when a ? is entered BEGIN maxArraySize: CARDINAL = LENGTH[DiagFlTapeOpInt.Switch]; numArray: ARRAY [0..maxArraySize) OF CARDINAL ¬ ALL[0]; GetNumbers[    prompt: prompt,    minNumber: 1,    maxNumber: maxArraySize-1,    numberArray: DESCRIPTOR[numArray],    explanation: explanation];     FOR inx:CARDINAL IN [0..maxArraySize) DO    IF (numArray[inx]#0) AND (numArray[inx] < maxArraySize) THEN        numberArray[numArray[inx]] ¬ TRUE; ENDLOOP;            IF traceDbug THEN {   Odi.PutMessage [message: "DFTTTY.SelectOptions "L];   [] ¬ Odi.HitAnyKeyToContinue [prompt: mkOpInt[typeCharToCont], beep: FALSE] } END; --SelectOptions  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to check for TTY User Abort  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   CheckIfUserAbort: PUBLIC PROCEDURE   = BEGIN  Odi.LookForAbort [  	! Odi.AbortCurrentTest => SIGNAL UserAbort ];  END; --CheckIfUserAbort  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Main line code  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  Initialize [];  -- check if trace debug is requested  traceDbug ¬ (System.switches['t]=down OR System.switches['T]=down)  END... --of DiagFlTapeTTYImpl  LOG28-Oct-87 JMA:	converted for Dove Offline use10-Feb-88 JMA:  added workaround for buggy Odi.PutMessage.  It crashes if you	use it without message = NIL, sometimes.		 		 
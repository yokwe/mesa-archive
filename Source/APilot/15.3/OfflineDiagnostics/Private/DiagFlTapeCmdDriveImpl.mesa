-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. ---- File: DiagFlTapeCmdDriveImpl.mesa-- Edited by: JMA  4-Mar-88 15:14:31-- DIRECTORY DiagFlTapeBuff		USING	[ZeroBuffer, GenDataBuffer, dataType], DiagFlTapeCmdDes	USING	[Command, CmdDescriptArray], DiagFlTapeCmds		USING	[InitCmdStuff, ExecuteCmd, WaitForCompletion,				 IoCPA, IoCPIdx, IDBuffHasData,				 MinSector, MaxSector, MinTrack, MaxTrack,				 SectorsPerTrack, SectorsPerStream,				 SectorsPerTape, TracksPerStream,				 TracksPerTape, StreamsPerTape,				 LastWriteSize, LastReadSize,				 LastReadCmdIdx, LastWriteCmdIdx,				 LastReadIDCmdIdx, DeviceHandle,				 WrBuffArray, RdBuffArray, RdIDBuffArray], DiagFlTapeErrorCheck	USING	[CheckStatus], DiagFlTapeTestControl	USING	[ControlLoopCount, RepeatCmdCnt,				 RepeatCommand, RepeatedCmdSoftErrCnt,				 RepeatingCommand, LastRepeatCommand,				 UseSectorsPerTrack, UseSectorsPerStream,				 UseSectorsPerTape, UseTracksPerStream,				 UseTracksPerTape, UseStreamsPerDrive,				 EndlessLoop,				 IncrSectorToFind1Good1,				 SoftErrorInTable, SoftError,				 StopRepeatCmdIfNoSoftErr], DiagFlTapeTTY		USING	[CheckIfUserAbort, PutLine], DiagFlTapeOpInt	USING	[ProceedOnInput, Engineering, Switch], Environment		USING	[wordsPerPage], Inline			USING	[DBITSHIFT], Process		USING	[Pause], String			USING	[AppendNumber, AppendString], DiagFlTapeCmdDrive	USING	[parameterRecord], Runtime		USING	[CallDebugger];				  DiagFlTapeCmdDriveImpl: PROGRAM     IMPORTS	DiagFlTapeBuff,	DiagFlTapeCmdDes,	DiagFlTapeCmds,	DiagFlTapeErrorCheck,	DiagFlTapeTestControl,	Inline,	Process,	DiagFlTapeTTY,	DiagFlTapeOpInt,	String,	Runtime    EXPORTS	DiagFlTapeCmdDrive = BEGIN   OPEN     DiagFlTapeCmdDes,     Io: DiagFlTapeCmds,     Tc: DiagFlTapeTestControl; -- public stuff LoopCount:		PUBLIC LONG CARDINAL¬ 1; remLoopCnt:		PUBLIC LONG CARDINAL; MaxCmdsInLoop:		PUBLIC CARDINAL¬ 8; IOCommand:		PUBLIC DiagFlTapeCmdDes.Command; Continue:		PUBLIC BOOLEAN¬ FALSE;   parmRecord:		DiagFlTapeCmdDrive.parameterRecord; -- rigid disk, floppy disk or floppy tape command stuff -- to maintain the parameters of 8 IO commands inside of a loop cmdParameters: TYPE=	RECORD [	--diskCommand	commandType:		DiagFlTapeCmdDes.Command¬ noOpertn,	--parameter stuff	parmRec:		DiagFlTapeCmdDrive.parameterRecord,	--data and data buffer stuff	dataType:		DiagFlTapeBuff.dataType¬ random,	data:			CARDINAL¬ 0,	needUse1Buff:		BOOLEAN¬ TRUE,	buffPtr:		LONG POINTER TO ARRAY OF WORD,	need0sInRdBuff:		BOOLEAN¬ FALSE,	needVrfyData:		BOOLEAN¬ FALSE,	--misc stuff	tryCount:		CARDINAL¬ 1,	skipCount:		CARDINAL¬ 0]; parmIdx:		CARDINAL¬ 0; parmArray:		ARRAY[0..8) OF cmdParameters;  -- interanal variables endOfCmdFile:		BOOLEAN¬ FALSE; cmdPtr:		CARDINAL; lstCmdInLoop:		CARDINAL= 8; Cmd0IsSetUp:		BOOLEAN¬ FALSE; Cmd1IsSetUp:		BOOLEAN¬ FALSE; Cmd0Executing:		BOOLEAN¬ FALSE; Cmd1Executing:		BOOLEAN¬ FALSE; cmdsInLoopCnt:		CARDINAL¬ 0; -- looping stuff loop:			BOOLEAN¬ FALSE; firstTimeLoop:		BOOLEAN¬ FALSE; endLoop:		BOOLEAN¬ FALSE; startLoopAt:		CARDINAL; tempStr:		LONG STRING¬ [256]; -- delay count Delay:			CARDINAL;  --cursor control cursorHome:		BOOLEAN¬ TRUE;  -- high speed stuff runSpeed:		TYPE= {waitingForSetUp, slowSpeed, highSpeed}; speed:			runSpeed¬ waitingForSetUp;  -- soft error stuff softErr:		BOOLEAN¬ FALSE; continuePastSoftErr:	BOOLEAN¬ FALSE; remainingSectorCnt:	CARDINAL;  -- parameter update stuff added for speed item1sInItem2: 	LONG CARDINAL¬ Io.SectorsPerTrack; item1sInItem3: 	LONG CARDINAL¬ Io.SectorsPerTrack; --since only one head item1sInItem4: 	LONG CARDINAL¬ Io.SectorsPerTape; item2sInItem3: 	LONG CARDINAL¬ 1; --since only one head item2sInItem4: 	LONG CARDINAL¬ Io.TracksPerTape; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- Selects and executes commands from the Command File -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  ExecuteCommands: PUBLIC PROCEDURE [   commandArray: LONG DESCRIPTOR FOR ARRAY OF CARDINAL¬ DESCRIPTOR [NIL, 0]] = BEGIN -- ~~~~~~~internal procs~~~~~~ GetNumber: PROCEDURE RETURNS [count: CARDINAL] = BEGIN count¬ commandArray[cmdPtr]; cmdPtr¬ cmdPtr+ 1; END; --getNumber -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetParameters: PROCEDURE  = BEGIN   -- ~~~~~~~~~~~internal internal proc~~~~~~~~~~   IsSignPositive: PROCEDURE RETURNS [positive: BOOLEAN¬ TRUE]   = BEGIN   count: CARDINAL;   count¬ commandArray [cmdPtr];   cmdPtr¬ cmdPtr+ 1;   IF count= 0 THEN positive¬ FALSE;   END; --SignIsPositive   -- ~~~~~~~~~~~~end of internal internal proc~~~~~~~~~~~ --check if no parameter needed. Done for speed IF NOT CmdDescriptArray[IOCommand].needParam THEN { IF CmdDescriptArray[IOCommand].isIOCmd THEN     Io.IoCPA[Io.IoCPIdx].command¬ IOCommand;   IF firstTimeLoop      AND IOCommand# endLoop      AND NOT CmdDescriptArray[IOCommand].fastRunning THEN        speed¬ slowSpeed;   RETURN; };  IF NOT loop THEN { --check if inside of a loop and it is not a fast running command   IF firstTimeLoop      AND IOCommand# endLoop      AND NOT CmdDescriptArray[IOCommand].fastRunning THEN        speed¬ slowSpeed ELSE     IF speed= waitingForSetUp        AND CmdDescriptArray[IOCommand].fastRunning THEN          speed¬ highSpeed;   --fisrt do the non IO commands   IF NOT CmdDescriptArray[IOCommand].isIOCmd THEN   { --get loop count if needed     IF CmdDescriptArray[IOCommand].needLoopCount THEN     {  IF Tc.ControlLoopCount THEN       { []¬ GetNumber []; []¬ GetNumber []; --loopcount= long number         SELECT TRUE FROM           Tc.UseSectorsPerTrack=> remLoopCnt¬ Io.SectorsPerTrack;           Tc.UseSectorsPerStream=> remLoopCnt¬ Io.SectorsPerStream;           Tc.UseSectorsPerTape=> remLoopCnt¬ Io.SectorsPerTape;           Tc.UseTracksPerStream=> remLoopCnt¬ Io.TracksPerStream;           Tc.UseTracksPerTape=> remLoopCnt¬ Io.TracksPerTape;           Tc.UseStreamsPerDrive=> remLoopCnt¬ Io.StreamsPerTape;         ENDCASE=> remLoopCnt¬ LoopCount;         RETURN;       } ELSE       { lp: CARDINAL;         remLoopCnt¬ GetNumber[]; --get the most significant part of the number         lp¬ GetNumber[]; --get the least significant part of the number         remLoopCnt¬ Inline.DBITSHIFT[remLoopCnt, 16];         remLoopCnt¬ remLoopCnt+ lp;         IF remLoopCnt= 0 THEN Tc.EndlessLoop¬ TRUE;         RETURN;       };     };     --get delay if needed     IF CmdDescriptArray[IOCommand].needDelay THEN     { Delay¬ GetNumber [];       RETURN;     };   } ELSE      { --set up the device handle     Io.IoCPA[Io.IoCPIdx].opPtr­.device¬ DiagFlTapeCmds.DeviceHandle;     --set up the command type     parmArray[parmIdx].commandType¬ Io.IoCPA[Io.IoCPIdx].command¬ IOCommand;     SELECT IOCommand FROM       noOp=>		Io.IoCPA[Io.IoCPIdx].opPtr­.function¬ nop;       readID=>		Io.IoCPA[Io.IoCPIdx].opPtr­.function¬ readID;       rdSector=>	Io.IoCPA[Io.IoCPIdx].opPtr­.function¬ readSector;       wrSector=>	Io.IoCPA[Io.IoCPIdx].opPtr­.function¬ writeSector;       wrDlSctr=>	Io.IoCPA[Io.IoCPIdx].opPtr­.function¬ writeDeletedSector;       formatTk=>	Io.IoCPA[Io.IoCPIdx].opPtr­.function¬ formatTrack;     ENDCASE;        parmArray[parmIdx].skipCount¬ 0;        --get unit (only one unit so the default of 0 is used)          --get track(same as cylinDer here since there is only one head)     IF CmdDescriptArray[IOCommand].needTrack THEN     { Io.IoCPA[Io.IoCPIdx].track¬         Io.IoCPA[Io.IoCPIdx].opPtr­.address.cylinder¬           parmArray[parmIdx].parmRec.item3¬ GetNumber[];       Io.IoCPA[Io.IoCPIdx].opPtr­.address.head¬ 0;       parmArray[parmIdx].skipCount¬ parmArray[parmIdx].skipCount+ 1;       IF firstTimeLoop THEN       { IF IsSignPositive [] THEN         parmArray[parmIdx].parmRec.item3Incr¬ TRUE ELSE           parmArray[parmIdx].parmRec.item3Incr¬ FALSE;         parmArray[parmIdx].parmRec.item3Change¬ GetNumber [];         parmArray[parmIdx].skipCount¬ parmArray[parmIdx].skipCount+ 2;       };       IF IOCommand= readID THEN       { Io.IDBuffHasData¬ TRUE;         Io.LastReadIDCmdIdx¬ Io.IoCPIdx;       };     } ELSE --store defaults     { Io.IoCPA[Io.IoCPIdx].track¬         Io.IoCPA[Io.IoCPIdx].opPtr­.address.cylinder¬           parmArray[parmIdx].parmRec.item3¬ 0;       IF firstTimeLoop THEN         parmArray[parmIdx].parmRec.item3Change¬ 0;     };          --get Track count if needed     IF CmdDescriptArray[IOCommand].needTkCnt THEN     { Io.IoCPA[Io.IoCPIdx].sectorOrTrackCount¬         Io.IoCPA[Io.IoCPIdx].opPtr­.count¬           parmArray[parmIdx].parmRec.itemsToXfer¬ GetNumber [];       parmArray[parmIdx].parmRec.xferItem1¬ FALSE;       parmArray[parmIdx].parmRec.xferItem2¬ TRUE;       parmArray[parmIdx].skipCount¬ parmArray[parmIdx].skipCount+ 1;     };          --get head (only one head so 0 defaults are used)          --get Sector if needed     IF CmdDescriptArray[IOCommand].needSector THEN     { Io.IoCPA[Io.IoCPIdx].sector¬          Io.IoCPA[Io.IoCPIdx].opPtr­.address.sector¬           parmArray[parmIdx].parmRec.item1¬ GetNumber[];       parmArray[parmIdx].skipCount¬ parmArray[parmIdx].skipCount+ 1;       IF firstTimeLoop THEN       { IF IsSignPositive[] THEN         parmArray[parmIdx].parmRec.item1Incr¬ TRUE ELSE           parmArray[parmIdx].parmRec.item1Incr¬ FALSE;         parmArray[parmIdx].parmRec.item1Change¬ GetNumber [];         parmArray[parmIdx].skipCount¬ parmArray[parmIdx].skipCount+ 2;       };     } ELSE --store defaults     { Io.IoCPA[Io.IoCPIdx].sector¬          Io.IoCPA[Io.IoCPIdx].opPtr­.address.sector¬           parmArray[parmIdx].parmRec.item1¬ 1;       IF firstTimeLoop THEN         parmArray[parmIdx].parmRec.item1Change¬ 0;     };     --get if to use one buffer only     IF IOCommand= readID THEN      { Io.IoCPA[Io.IoCPIdx].opPtr­.incrementDataPointer¬ FALSE;       parmArray[parmIdx].needUse1Buff¬ TRUE;     };     IF CmdDescriptArray[IOCommand].needUse1Buff THEN     { num: CARDINAL¬ GetNumber[];       IF num= 0 THEN       { Io.IoCPA[Io.IoCPIdx].opPtr­.incrementDataPointer¬ TRUE;         parmArray[parmIdx].needUse1Buff¬ FALSE;       } ELSE       { Io.IoCPA[Io.IoCPIdx].opPtr­.incrementDataPointer¬ FALSE;         parmArray[parmIdx].needUse1Buff¬ TRUE;       };       parmArray[parmIdx].skipCount¬ parmArray[parmIdx].skipCount+ 1;     };          --get sector count if needed     IF CmdDescriptArray[IOCommand].needSectorCnt THEN     { Io.IoCPA[Io.IoCPIdx].sectorOrTrackCount¬         Io.IoCPA[Io.IoCPIdx].opPtr­.count¬           parmArray[parmIdx].parmRec.itemsToXfer¬ GetNumber [];       parmArray[parmIdx].parmRec.xferItem1¬ TRUE;       parmArray[parmIdx].parmRec.xferItem2¬ FALSE;       parmArray[parmIdx].skipCount¬ parmArray[parmIdx].skipCount+ 1;       --keep sector count for data buffer display       IF IOCommand= wrSector OR IOCommand= wrDlSctr THEN       { IF Io.IoCPA[Io.IoCPIdx].opPtr­.incrementDataPointer THEN           Io.LastWriteSize¬ Io.IoCPA[Io.IoCPIdx].opPtr­.count ELSE	    Io.LastWriteSize¬ 1;	 Io.LastWriteCmdIdx¬ Io.IoCPIdx;       };       IF IOCommand= rdSector THEN       { IF Io.IoCPA[Io.IoCPIdx].opPtr­.incrementDataPointer THEN           Io.LastReadSize¬ Io.IoCPA[Io.IoCPIdx].opPtr­.count ELSE             Io.LastReadSize¬ 1;	 Io.LastReadCmdIdx¬ Io.IoCPIdx;       };     } ELSE IF NOT CmdDescriptArray[IOCommand].needTkCnt THEN     --store defaults      { Io.IoCPA[Io.IoCPIdx].sectorOrTrackCount¬         Io.IoCPA[Io.IoCPIdx].opPtr­.count¬           parmArray[parmIdx].parmRec.itemsToXfer¬ 1;       parmArray[parmIdx].parmRec.xferItem1¬ TRUE;       parmArray[parmIdx].parmRec.xferItem2¬ FALSE;     };          --get data and generate the write data buffer     IF CmdDescriptArray[IOCommand].needData --write operatation-- THEN     { num: CARDINAL¬ GetNumber[];       Io.IoCPA[Io.IoCPIdx].dataType¬ parmArray[parmIdx].dataType¬ VAL[num];       parmArray[parmIdx].skipCount¬ parmArray[parmIdx].skipCount+ 1;       IF parmArray[parmIdx].dataType= constant THEN       { Io.IoCPA[Io.IoCPIdx].data¬ parmArray[parmIdx].data¬ GetNumber [];         parmArray[parmIdx].skipCount¬ parmArray[parmIdx].skipCount+ 1;       };       DiagFlTapeBuff.GenDataBuffer[	 kindOfData: parmArray[parmIdx].dataType,  	 data: parmArray[parmIdx].data,	 unit: 0,	 cylinder: Io.IoCPA[Io.IoCPIdx].track,	 head: 0,	 sector: Io.IoCPA[Io.IoCPIdx].sector,	 wordCount: IF NOT parmArray[parmIdx].needUse1Buff THEN	   parmArray[parmIdx].parmRec.itemsToXfer*Environment.wordsPerPage	     ELSE Environment.wordsPerPage,	 ptr:  Io.WrBuffArray[Io.IoCPIdx]];     };     --get the data ptrs     IF  CmdDescriptArray[IOCommand].xfersData THEN     { IF IOCommand= wrSector OR IOCommand= wrDlSctr THEN         parmArray[parmIdx].buffPtr¬           Io.IoCPA[Io.IoCPIdx].opPtr­.dataPtr¬ Io.WrBuffArray[Io.IoCPIdx] ELSE         IF IOCommand= rdSector THEN           parmArray[parmIdx].buffPtr¬             Io.IoCPA[Io.IoCPIdx].opPtr­.dataPtr¬	       Io.RdBuffArray[Io.IoCPIdx] ELSE           IF IOCommand= readID THEN             parmArray[parmIdx].buffPtr¬               Io.IoCPA[Io.IoCPIdx].opPtr­.dataPtr¬	         Io.RdIDBuffArray[Io.IoCPIdx];     };     --get if clear out the read buffer first     IF CmdDescriptArray[IOCommand].need0sInRdBuff THEN     { num: CARDINAL¬ GetNumber[];       IF num= 1 THEN       { Io.IoCPA[Io.IoCPIdx].need0sInRdBuff¬           parmArray[parmIdx].need0sInRdBuff¬ TRUE;         DiagFlTapeBuff.ZeroBuffer[	   wordCount: IF NOT parmArray[parmIdx].needUse1Buff THEN	     parmArray[parmIdx].parmRec.itemsToXfer*Environment.wordsPerPage               ELSE Environment.wordsPerPage,	   ptr:  parmArray[parmIdx].buffPtr];       } ELSE Io.IoCPA[Io.IoCPIdx].need0sInRdBuff¬           parmArray[parmIdx].need0sInRdBuff¬ FALSE;       parmArray[parmIdx].skipCount¬ parmArray[parmIdx].skipCount+ 1;     } ELSE --set up defaults or the buffer will be cleared         Io.IoCPA[Io.IoCPIdx].need0sInRdBuff¬           parmArray[parmIdx].need0sInRdBuff¬ FALSE;     --get if to verify data     IF CmdDescriptArray[IOCommand].needVrfyData THEN     { num: CARDINAL¬ GetNumber[];       IF num= 0 THEN       { Io.IoCPA[Io.IoCPIdx].needVrfyData¬	   parmArray[parmIdx].needVrfyData¬ FALSE;         parmArray[parmIdx].skipCount¬ parmArray[parmIdx].skipCount+ 1;       } ELSE       { Io.IoCPA[Io.IoCPIdx].needVrfyData¬	   parmArray[parmIdx].needVrfyData¬ TRUE;         num¬ GetNumber[];         Io.IoCPA[Io.IoCPIdx].dataType¬ parmArray[parmIdx].dataType¬ VAL[num];         parmArray[parmIdx].skipCount¬ parmArray[parmIdx].skipCount+ 2;       };     } ELSE --set up defaults        Io.IoCPA[Io.IoCPIdx].needVrfyData¬	  parmArray[parmIdx].needVrfyData¬ FALSE;          --get try count if needed     IF CmdDescriptArray[IOCommand].needTryCount THEN     { Io.IoCPA[Io.IoCPIdx].tries¬         Io.IoCPA[Io.IoCPIdx].opPtr­.tries¬           parmArray[parmIdx].tryCount¬ GetNumber [];       parmArray[parmIdx].skipCount¬ parmArray[parmIdx].skipCount+ 1;     };     --now clear the errors     Io.IoCPA[Io.IoCPIdx].errorType¬ noError;     Io.IoCPA[Io.IoCPIdx].cmdTimedOut¬ FALSE;     Io.IoCPA[Io.IoCPIdx].rtrndSectorCntError¬ FALSE;     Io.IoCPA[Io.IoCPIdx].rtrndTrackCntError¬ FALSE;     Io.IoCPA[Io.IoCPIdx].dataVerifyError¬ FALSE;     Io.IoCPA[Io.IoCPIdx].dataNotWrittenError¬ FALSE;     Io.IoCPA[Io.IoCPIdx].iDVerifyError¬ FALSE;     Io.IoCPA[Io.IoCPIdx].writeProtected¬ FALSE;     Io.IoCPA[Io.IoCPIdx].retensionPassDone¬ FALSE;     --now update the parameter record pointer     --point to next parameter record     IF firstTimeLoop THEN parmIdx¬ parmIdx+ 1;     RETURN   }; } ELSE --loop is true { --fisrt do the non IO commands   IF NOT CmdDescriptArray[IOCommand].isIOCmd THEN   { IF CmdDescriptArray[IOCommand].needDelay THEN     { Delay¬ GetNumber []; RETURN;     };   } ELSE   { --second do the IO command     Io.IoCPA[Io.IoCPIdx].opPtr­.device¬ DiagFlTapeCmds.DeviceHandle;     IF speed= slowSpeed THEN cmdPtr¬ cmdPtr+ parmArray[parmIdx].skipCount;     Io.IoCPA[Io.IoCPIdx].command¬ IOCommand;     SELECT IOCommand FROM       noOp=>		Io.IoCPA[Io.IoCPIdx].opPtr­.function¬ nop;       readID=>		Io.IoCPA[Io.IoCPIdx].opPtr­.function¬ readID;       rdSector=>	Io.IoCPA[Io.IoCPIdx].opPtr­.function¬ readSector;       wrSector=>	Io.IoCPA[Io.IoCPIdx].opPtr­.function¬ writeSector;       wrDlSctr=>	Io.IoCPA[Io.IoCPIdx].opPtr­.function¬ writeDeletedSector;       formatTk=>	Io.IoCPA[Io.IoCPIdx].opPtr­.function¬ formatTrack;     ENDCASE;     --update unit, cylinder, head, sector     [newItemsToXfer: Io.IoCPA[Io.IoCPIdx].opPtr­.count,      newItem1: Io.IoCPA[Io.IoCPIdx].opPtr­.address.sector,      newItem2: Io.IoCPA[Io.IoCPIdx].opPtr­.address.head,      newItem3: Io.IoCPA[Io.IoCPIdx].opPtr­.address.cylinder,      newItem4: ]¬ UpdateParameters[parmRcPtr: @parmArray[parmIdx].parmRec];      Io.IoCPA[Io.IoCPIdx].track¬ Io.IoCPA[Io.IoCPIdx].opPtr­.address.cylinder;      Io.IoCPA[Io.IoCPIdx].sector¬ Io.IoCPA[Io.IoCPIdx].opPtr­.address.sector;      Io.IoCPA[Io.IoCPIdx].sectorOrTrackCount¬ Io.IoCPA[Io.IoCPIdx].opPtr­.count;           --get if to use one buffer only     Io.IoCPA[Io.IoCPIdx].opPtr­.incrementDataPointer¬       NOT parmArray[parmIdx].needUse1Buff;     --get the data ptrs     IF IOCommand= wrSector OR IOCommand= wrDlSctr THEN       parmArray[parmIdx].buffPtr¬         Io.IoCPA[Io.IoCPIdx].opPtr­.dataPtr¬           Io.WrBuffArray[Io.IoCPIdx] ELSE       IF IOCommand= rdSector THEN         parmArray[parmIdx].buffPtr¬           Io.IoCPA[Io.IoCPIdx].opPtr­.dataPtr¬	     Io.RdBuffArray[Io.IoCPIdx] ELSE         IF IOCommand= readID THEN           parmArray[parmIdx].buffPtr¬	     Io.IoCPA[Io.IoCPIdx].opPtr­.dataPtr¬	       Io.RdIDBuffArray[Io.IoCPIdx];     --generate the write buffer     IF CmdDescriptArray[IOCommand].needData THEN     { DiagFlTapeBuff.GenDataBuffer[	 kindOfData: parmArray[parmIdx].dataType,  	 data: parmArray[parmIdx].data,	 unit: 0,	 cylinder: Io.IoCPA[Io.IoCPIdx].track,	 head: 0,	 sector: Io.IoCPA[Io.IoCPIdx].sector,	 wordCount: IF NOT parmArray[parmIdx].needUse1Buff THEN	   parmArray[parmIdx].parmRec.itemsToXfer*Environment.wordsPerPage	     ELSE Environment.wordsPerPage,	 ptr:  Io.WrBuffArray[Io.IoCPIdx]];       Io.IoCPA[Io.IoCPIdx].data¬ parmArray[parmIdx].data;     };     --clear the read buffer     IF parmArray[parmIdx].need0sInRdBuff THEN       DiagFlTapeBuff.ZeroBuffer[	   wordCount: IF NOT parmArray[parmIdx].needUse1Buff THEN	     parmArray[parmIdx].parmRec.itemsToXfer*Environment.wordsPerPage               ELSE Environment.wordsPerPage,	   ptr:  parmArray[parmIdx].buffPtr];     Io.IoCPA[Io.IoCPIdx].need0sInRdBuff¬ parmArray[parmIdx].need0sInRdBuff;     --set up verify data after completion of IO command     Io.IoCPA[Io.IoCPIdx].needVrfyData¬ parmArray[parmIdx].needVrfyData;     Io.IoCPA[Io.IoCPIdx].dataType¬ parmArray[parmIdx].dataType;     --get try count if needed     Io.IoCPA[Io.IoCPIdx].tries¬       Io.IoCPA[Io.IoCPIdx].opPtr­.tries¬         parmArray[parmIdx].tryCount;     --now clear the errors     Io.IoCPA[Io.IoCPIdx].errorType¬ noError;     Io.IoCPA[Io.IoCPIdx].cmdTimedOut¬ FALSE;     Io.IoCPA[Io.IoCPIdx].rtrndSectorCntError¬ FALSE;     Io.IoCPA[Io.IoCPIdx].rtrndTrackCntError¬ FALSE;     Io.IoCPA[Io.IoCPIdx].dataVerifyError¬ FALSE;     Io.IoCPA[Io.IoCPIdx].dataNotWrittenError¬ FALSE;     Io.IoCPA[Io.IoCPIdx].iDVerifyError¬ FALSE;     Io.IoCPA[Io.IoCPIdx].writeProtected¬ FALSE;     Io.IoCPA[Io.IoCPIdx].retensionPassDone¬ FALSE;     --now update the parameter record pointer     parmIdx¬ parmIdx+ 1;   }; }; END; --GetParameters -- ~~~~~~~~end of internal procs~~~~~~~  --start of ExecuteCommands PROC IF BASE [commandArray]= NIL THEN RETURN; --*** remove in final boot file --display the entered command file IF DiagFlTapeOpInt.Engineering AND DiagFlTapeOpInt.Switch[71] THEN { cnt:	CARDINAL¬ 0;   tempStr.length¬ 0;   String.AppendString[tempStr, "["];   UNTIL cnt= LENGTH[commandArray] OR tempStr.length>= 248 DO     String.AppendNumber[tempStr, commandArray[cnt]];     String.AppendString[tempStr, ","];     cnt¬cnt+1;   ENDLOOP;   tempStr.length¬ tempStr.length- 1; --to get rid of the last comma   String.AppendString[tempStr, "]"];   DiagFlTapeTTY.PutLine[string: tempStr];   DiagFlTapeOpInt.ProceedOnInput[]; }; -- set up the IO command pointers to point to the right stuff  -- if command file is not to be continued IF NOT Continue THEN { -- set up the IO command pointers to point to the right stuff   Io.InitCmdStuff[];   Io.IoCPIdx¬ 0;   --initialize all of the parmArray-s   FOR i: CARDINAL IN[0..lstCmdInLoop) DO     parmArray[i].parmRec¬ [];     parmArray[i].parmRec.minItem1¬ DiagFlTapeCmds.MinSector;     parmArray[i].parmRec.maxItem1¬ DiagFlTapeCmds.MaxSector;     parmArray[i].parmRec.minItem3¬ DiagFlTapeCmds.MinTrack;     parmArray[i].parmRec.maxItem3¬ DiagFlTapeCmds.MaxTrack;   ENDLOOP;   cmdPtr¬ 0;   parmIdx¬ 0;   loop¬ FALSE;   firstTimeLoop¬ FALSE;   Cmd0Executing¬ FALSE;   Cmd1Executing¬ FALSE;   Cmd0IsSetUp¬ FALSE;   Cmd1IsSetUp¬ FALSE;   speed¬ waitingForSetUp;   softErr¬ FALSE;   continuePastSoftErr¬ FALSE; };  Continue¬ FALSE; endOfCmdFile¬ FALSE; UNTIL endOfCmdFile DO   --if the user entered the 'BREAK key   DiagFlTapeTTY.CheckIfUserAbort[];      IF (loop AND endLoop) THEN   { --keep the command count in the loop for fastRunning commands     cmdsInLoopCnt¬ parmIdx;     endLoop¬ FALSE;     parmIdx¬ 0;     IF speed= slowSpeed THEN     { IF NOT Tc.EndlessLoop THEN remLoopCnt¬ remLoopCnt- 1;       IF remLoopCnt> 0 THEN cmdPtr¬ startLoopAt ELSE loop¬ FALSE     };   };      --low speed operations or the first time through the loop   IF NOT loop      OR speed= waitingForSetUp      OR speed= slowSpeed THEN   { -- get the next command     IOCommand¬ VAL[commandArray[cmdPtr]];     cmdPtr¬ cmdPtr+ 1;     -- get all the needed parameters     GetParameters[];     -- now execute the command (IO or otherwise)     CmdDescriptArray[IOCommand].cmdProc;     --check IO status     IF CmdDescriptArray[IOCommand].needsLogging THEN     { DiagFlTapeErrorCheck.CheckStatus[command: IOCommand         !Tc.SoftErrorInTable => 	   { remainingSectorCnt¬ Io.IoCPA[0].opPtr­.count;	     continuePastSoftErr¬ TRUE;	     CONTINUE;	   };	 Tc.SoftError=> 	   { remainingSectorCnt¬ Io.IoCPA[0].opPtr­.count;	     softErr¬ TRUE;	     CONTINUE;	   }];       IF continuePastSoftErr THEN       { ProceedPastSoftErr[0];         continuePastSoftErr¬ FALSE;       };       IF softErr THEN       { IF Tc.RepeatCommand THEN RepeatFailingSector[0];         ProceedPastSoftErr[0];	 softErr¬ FALSE;       };     };   } ELSE  --this is high speed command stuff and loop is set      { --loop count - 1 since one iteration was already done     remLoopCnt¬ remLoopCnt- 1;     UNTIL remLoopCnt= 0 AND NOT Cmd0IsSetUp AND NOT Cmd1IsSetUp DO       --DiagFlTapeTTY.CheckIfUserAbort[];       IF NOT remLoopCnt= 0 AND NOT Cmd0IsSetUp THEN       { Io.IoCPIdx¬ 0;         IOCommand¬ parmArray[parmIdx].commandType;         GetParameters[];         Cmd0IsSetUp¬ TRUE;	 IF parmIdx= cmdsInLoopCnt THEN	 { parmIdx¬ 0;	   IF NOT Tc.EndlessLoop THEN remLoopCnt¬ remLoopCnt- 1;	 };       };       IF NOT remLoopCnt= 0 AND NOT Cmd1IsSetUp THEN       { Io.IoCPIdx¬ 1;         IOCommand¬ parmArray[parmIdx].commandType;         GetParameters[];         Cmd1IsSetUp¬ TRUE;	 IF parmIdx= cmdsInLoopCnt THEN	 { parmIdx¬ 0;	   IF NOT Tc.EndlessLoop THEN remLoopCnt¬ remLoopCnt- 1;	 };       };       -- if no command is in execution       IF NOT Cmd0Executing AND NOT Cmd1Executing AND Cmd0IsSetUp THEN       { Io.ExecuteCmd[0];	 Cmd0Executing¬ TRUE;       };       -- if command 0 is in execution       IF Cmd0Executing THEN       { Io.WaitForCompletion[0];         IF Io.IoCPA[0].rtndStatus= goodCompletion THEN         { IF Cmd1IsSetUp THEN	   { Io.ExecuteCmd[1];             Cmd1Executing¬ TRUE;	   };           IF CmdDescriptArray[Io.IoCPA[0].command].needsLogging THEN           { DiagFlTapeErrorCheck.CheckStatus[	       cmdIdx: 0,	       command: Io.IoCPA[0].command	       --***until goodcompletion but soft error is fixed**               !Tc.SoftErrorInTable => CONTINUE;                Tc.SoftError=> CONTINUE];	   };         } ELSE --there was an error         { IF CmdDescriptArray[Io.IoCPA[0].command].needsLogging THEN           { DiagFlTapeErrorCheck.CheckStatus[	       cmdIdx: 0,	       command: Io.IoCPA[0].command               !Tc.SoftErrorInTable => 	         { remainingSectorCnt¬ Io.IoCPA[0].opPtr­.count;	           continuePastSoftErr¬ TRUE;	           CONTINUE;	         };               Tc.SoftError=> 	         { remainingSectorCnt¬ Io.IoCPA[0].opPtr­.count;	           softErr¬ TRUE;	           CONTINUE;	         }];             IF continuePastSoftErr THEN             { ProceedPastSoftErr[0];               continuePastSoftErr¬ FALSE;             };             IF softErr THEN             { IF Tc.RepeatCommand THEN RepeatFailingSector[0];               ProceedPastSoftErr[0];	       softErr¬ FALSE;             };           };           IF Cmd1IsSetUp THEN	   { Io.ExecuteCmd[1];	     Cmd1Executing¬ TRUE;	   };         }; --end of there was an error         Cmd0IsSetUp¬ FALSE;         Cmd0Executing¬ FALSE;         LOOP; --set up parameters for next command       }; --end of Cmd0Executing       -- if command 1 is in execution       IF Cmd1Executing THEN       { Io.WaitForCompletion[1];         IF Io.IoCPA[1].rtndStatus= goodCompletion THEN         { IF Cmd0IsSetUp THEN	   { Io.ExecuteCmd[0];	     Cmd0Executing¬ TRUE;	   };           IF CmdDescriptArray[Io.IoCPA[1].command].needsLogging THEN             DiagFlTapeErrorCheck.CheckStatus[	       cmdIdx: 1,	       command: Io.IoCPA[1].command	       --***until goodcompletion but soft error is fixed**               !Tc.SoftErrorInTable => CONTINUE;                Tc.SoftError=> CONTINUE];         } ELSE --there was an error         { IF CmdDescriptArray[Io.IoCPA[1].command].needsLogging THEN           { DiagFlTapeErrorCheck.CheckStatus[	       cmdIdx: 1,	       command: Io.IoCPA[1].command	       !Tc.SoftErrorInTable => 	         { remainingSectorCnt¬ Io.IoCPA[1].opPtr­.count;	           continuePastSoftErr¬ TRUE;	           CONTINUE;	         };	       Tc.SoftError=> 	         { remainingSectorCnt¬ Io.IoCPA[1].opPtr­.count;	           softErr¬ TRUE;	           CONTINUE;	         }];             IF continuePastSoftErr THEN             { ProceedPastSoftErr[1];               continuePastSoftErr¬ FALSE;             };             IF softErr THEN             { IF Tc.RepeatCommand THEN RepeatFailingSector[1];               ProceedPastSoftErr[cmdIdx: 1];	       softErr¬ FALSE;             };           };           IF Cmd0IsSetUp THEN	   { Io.ExecuteCmd[0];	     Cmd0Executing¬ TRUE	   };         }; --end of there was an error         Cmd1IsSetUp¬ FALSE;         Cmd1Executing¬ FALSE;         LOOP; --set up parameters for next command       }; --end of Cmd1Executing     ENDLOOP; --of UNTIL remLoopCnt= 0 DO     loop¬ FALSE;     speed¬ waitingForSetUp;   }; ENDLOOP; --UNTIL endOfCmdFile  END; --ExecuteCommands -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- repeats the IO command from past the last error -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ProceedPastSoftErr: PROCEDURE [cmdIdx: CARDINAL¬ 0] = BEGIN parmRec: DiagFlTapeCmdDrive.parameterRecord¬ parmRecord; goodCompletion: BOOLEAN ¬ FALSE;  -- check of the remaining sector count is at least 2 OR IncrSectorToFind1Good1 IF remainingSectorCnt=0 THEN RETURN; --this should not be IF remainingSectorCnt=1 THEN   IF NOT Tc.IncrSectorToFind1Good1 THEN RETURN ELSE     remainingSectorCnt¬ 2;  UNTIL goodCompletion DO   --set up the parameter record   parmRec.item1¬ Io.IoCPA[cmdIdx].opPtr­.address.sector; --failing sector   parmRec.item1Change¬ 1; --to increment the sector by 1   parmRec.item3¬ Io.IoCPA[cmdIdx].opPtr­.address.cylinder; --failing cylinder   IF Tc.IncrSectorToFind1Good1 THEN     parmRec.itemsToXfer¬ 1 ELSE --remaining sector count       parmRec.itemsToXfer¬ remainingSectorCnt- 1; --remaining sector count   --update the parameters   [newItemsToXfer: Io.IoCPA[cmdIdx].opPtr­.count,    newItem1: Io.IoCPA[cmdIdx].opPtr­.address.sector,    newItem2: Io.IoCPA[cmdIdx].opPtr­.address.head,    newItem3: Io.IoCPA[cmdIdx].opPtr­.address.cylinder,    newItem4: ]¬ UpdateParameters[parmRcPtr: @parmRec];   --update the IO control for logging the valid data   Io.IoCPA[cmdIdx].track¬ Io.IoCPA[cmdIdx].opPtr­.address.cylinder;   Io.IoCPA[cmdIdx].sector¬ Io.IoCPA[cmdIdx].opPtr­.address.sector;   Io.IoCPA[cmdIdx].sectorOrTrackCount¬ Io.IoCPA[cmdIdx].opPtr­.count;   --opPtr­.incrementDataPointer should still be OK   --set up opPtr­.dataPtr   IF Io.IoCPA[cmdIdx].command= wrSector      OR Io.IoCPA[cmdIdx].command= wrDlSctr  THEN       Io.IoCPA[cmdIdx].opPtr­.dataPtr¬ Io.WrBuffArray[cmdIdx] ELSE         IF Io.IoCPA[cmdIdx].command= rdSector THEN           Io.IoCPA[cmdIdx].opPtr­.dataPtr¬ Io.RdBuffArray[cmdIdx] ELSE           IF Io.IoCPA[cmdIdx].command= readID THEN             Io.IoCPA[cmdIdx].opPtr­.dataPtr¬ Io.RdIDBuffArray[cmdIdx];   --generate the write buffer   IF CmdDescriptArray[Io.IoCPA[cmdIdx].command].needData THEN     DiagFlTapeBuff.GenDataBuffer[         kindOfData: Io.IoCPA[cmdIdx].dataType,  	 data: Io.IoCPA[cmdIdx].data,	 unit: 0,	 cylinder: Io.IoCPA[cmdIdx].track,	 head: 0,	 sector: Io.IoCPA[cmdIdx].sector,	 wordCount: IF Io.IoCPA[cmdIdx].opPtr­.incrementDataPointer THEN	   Io.IoCPA[cmdIdx].sectorOrTrackCount*Environment.wordsPerPage	     ELSE Environment.wordsPerPage,	 ptr: Io.IoCPA[cmdIdx].opPtr­.dataPtr];   --Io.IoCPA[cmdIdx].need0sInRdBuff should still be Ok   --clear the read buffer   IF Io.IoCPA[cmdIdx].need0sInRdBuff THEN     DiagFlTapeBuff.ZeroBuffer[	 wordCount: IF Io.IoCPA[cmdIdx].opPtr­.incrementDataPointer THEN	   Io.IoCPA[cmdIdx].sectorOrTrackCount*Environment.wordsPerPage             ELSE Environment.wordsPerPage,	 ptr:  Io.IoCPA[cmdIdx].opPtr­.dataPtr];   --Io.IoCPA[cmdIdx].needVrfyData should still be Ok   --Io.IoCPA[cmdIdx].dataType should still be Ok   Io.IoCPA[cmdIdx].opPtr­.tries¬ Io.IoCPA[cmdIdx].tries;   --now clear the errors   Io.IoCPA[cmdIdx].errorType¬ noError;   Io.IoCPA[cmdIdx].cmdTimedOut¬ FALSE;   Io.IoCPA[cmdIdx].rtrndSectorCntError¬ FALSE;   Io.IoCPA[cmdIdx].rtrndTrackCntError¬ FALSE;   Io.IoCPA[cmdIdx].dataVerifyError¬ FALSE;   Io.IoCPA[cmdIdx].dataNotWrittenError¬ FALSE;   Io.IoCPA[cmdIdx].iDVerifyError¬ FALSE;   Io.IoCPA[cmdIdx].writeProtected¬ FALSE;   Io.IoCPA[cmdIdx].retensionPassDone¬ FALSE;      -- execute the IO command   softErr¬ FALSE;   Io.ExecuteCmd[cmdIdx];   Io.WaitForCompletion[cmdIdx];   DiagFlTapeErrorCheck.CheckStatus[       cmdIdx: cmdIdx,       command: Io.IoCPA[cmdIdx].command       !Tc.SoftErrorInTable =>          { remainingSectorCnt¬ Io.IoCPA[cmdIdx].opPtr­.count;           CONTINUE;         };       Tc.SoftError=>          { remainingSectorCnt¬ Io.IoCPA[cmdIdx].opPtr­.count;           softErr¬ TRUE;           CONTINUE;         }];   IF Io.IoCPA[cmdIdx].rtndStatus= goodCompletion     OR (NOT Tc.IncrSectorToFind1Good1 AND remainingSectorCnt <= 1) THEN       goodCompletion¬ TRUE;   IF NOT goodCompletion AND Tc.IncrSectorToFind1Good1 THEN     remainingSectorCnt¬ 2;   IF softErr AND Tc.RepeatCommand THEN   { RepeatFailingSector[cmdIdx];     softErr¬ FALSE;   }; ENDLOOP;     END; --off ProceedPastSoftErr -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- repeats an IO command on a failing sectcor -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RepeatFailingSector: PROCEDURE [cmdIdx: CARDINAL¬ 0] = BEGIN softErrOccurred: BOOLEAN¬ FALSE; repeatCount: CARDINAL¬ Tc.RepeatCmdCnt; cyl: CARDINAL¬ Io.IoCPA[cmdIdx].opPtr­.address.cylinder; sec: CARDINAL¬ Io.IoCPA[cmdIdx].opPtr­.address.sector;  Tc.RepeatingCommand¬ TRUE; --first save the returned parameters Io.IoCPA[cmdIdx].sector¬   Io.IoCPA[cmdIdx].opPtr­.address.sector; Io.IoCPA[cmdIdx].track¬   Io.IoCPA[cmdIdx].opPtr­.address.cylinder; Io.IoCPA[cmdIdx].sectorOrTrackCount¬ 1; IF repeatCount =0 THEN RETURN; UNTIL repeatCount <= 0 DO   --set up the operation pointer   Io.IoCPA[cmdIdx].opPtr­.address.sector¬ Io.IoCPA[cmdIdx].sector;   Io.IoCPA[cmdIdx].opPtr­.address.head¬ 0;   Io.IoCPA[cmdIdx].opPtr­.address.cylinder¬ Io.IoCPA[cmdIdx].track;   Io.IoCPA[cmdIdx].opPtr­.count¬ 1;   --set up opPtr­.dataPtr   IF Io.IoCPA[cmdIdx].command= wrSector      OR Io.IoCPA[cmdIdx].command= wrDlSctr  THEN       Io.IoCPA[cmdIdx].opPtr­.dataPtr¬ Io.WrBuffArray[cmdIdx] ELSE         IF Io.IoCPA[cmdIdx].command= rdSector THEN           Io.IoCPA[cmdIdx].opPtr­.dataPtr¬ Io.RdBuffArray[cmdIdx] ELSE           IF Io.IoCPA[cmdIdx].command= readID THEN             Io.IoCPA[cmdIdx].opPtr­.dataPtr¬ Io.RdIDBuffArray[cmdIdx];   --generate the write buffer   IF CmdDescriptArray[Io.IoCPA[cmdIdx].command].needData THEN     DiagFlTapeBuff.GenDataBuffer[         kindOfData: Io.IoCPA[cmdIdx].dataType,  	 data: Io.IoCPA[cmdIdx].data,	 unit: 0,	 cylinder: Io.IoCPA[cmdIdx].track,	 head: 0,	 sector: Io.IoCPA[cmdIdx].sector,	 wordCount: IF Io.IoCPA[cmdIdx].opPtr­.incrementDataPointer THEN	   Io.IoCPA[cmdIdx].sectorOrTrackCount*Environment.wordsPerPage	     ELSE Environment.wordsPerPage,	 ptr: Io.IoCPA[cmdIdx].opPtr­.dataPtr];   --clear the read buffer   IF Io.IoCPA[cmdIdx].need0sInRdBuff THEN     DiagFlTapeBuff.ZeroBuffer[	 wordCount: IF Io.IoCPA[cmdIdx].opPtr­.incrementDataPointer THEN	   Io.IoCPA[cmdIdx].sectorOrTrackCount*Environment.wordsPerPage             ELSE Environment.wordsPerPage,	 ptr:  Io.IoCPA[cmdIdx].opPtr­.dataPtr];   Io.IoCPA[cmdIdx].opPtr­.tries¬ 1;   --now clear the errors   Io.IoCPA[cmdIdx].errorType¬ noError;   Io.IoCPA[cmdIdx].cmdTimedOut¬ FALSE;   Io.IoCPA[cmdIdx].rtrndSectorCntError¬ FALSE;   Io.IoCPA[cmdIdx].rtrndTrackCntError¬ FALSE;   Io.IoCPA[cmdIdx].dataVerifyError¬ FALSE;   Io.IoCPA[cmdIdx].dataNotWrittenError¬ FALSE;   Io.IoCPA[cmdIdx].iDVerifyError¬ FALSE;   Io.IoCPA[cmdIdx].writeProtected¬ FALSE;   Io.IoCPA[cmdIdx].retensionPassDone¬ FALSE;      -- execute the IO command   softErr¬ FALSE;   IF repeatCount= 1 THEN     Tc.LastRepeatCommand¬ TRUE       ELSE Tc.LastRepeatCommand¬ FALSE;   Io.ExecuteCmd[cmdIdx];   Io.WaitForCompletion[cmdIdx];      softErrOccurred¬ FALSE;   DiagFlTapeErrorCheck.CheckStatus[       cmdIdx: cmdIdx,       command: Io.IoCPA[cmdIdx].command       !Tc.SoftErrorInTable => {softErrOccurred¬ TRUE; CONTINUE};        Tc.SoftError=> {softErrOccurred¬ TRUE; CONTINUE};];   IF Tc.StopRepeatCmdIfNoSoftErr AND NOT softErrOccurred THEN     repeatCount¬ 0 ELSE repeatCount¬ repeatCount- 1; ENDLOOP; Tc.RepeatingCommand¬ FALSE; Tc.RepeatedCmdSoftErrCnt¬ 0; -- set up prior failing address Io.IoCPA[cmdIdx].opPtr­.address.cylinder¬ cyl; Io.IoCPA[cmdIdx].opPtr­.address.head¬ 0; Io.IoCPA[cmdIdx].opPtr­.address.sector¬ sec;  END; --off RepeatFailingSector -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- do nothing procedure -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ NoOp: PUBLIC PROCEDURE = BEGIN  END; --NoOp -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- Start loop procedure -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ StartLoop: PUBLIC PROCEDURE = BEGIN firstTimeLoop¬ TRUE; startLoopAt¬ cmdPtr; END; --StartLoop -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- end loop procedure -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ EndLoop: PUBLIC PROCEDURE = BEGIN endLoop¬ TRUE; loop¬ TRUE; firstTimeLoop¬ FALSE; END; --EndLoop -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to delay a given amount of time before executing the next command -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   TimeDelay: PUBLIC PROCEDURE =BEGIN Process.Pause [Delay]; END; --TimeDelay -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to set end of the command file -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   SetEndOfFile: PUBLIC PROCEDURE =BEGIN endOfCmdFile¬ TRUE;  END; --TimeDelay -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to increment/decrement parameters & returns sector count to transfer. -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ UpdateParameters: PUBLIC PROCEDURE[ 	parmRcPtr: LONG POINTER TO DiagFlTapeCmdDrive.parameterRecord]	RETURNS [newItemsToXfer:		CARDINAL¬ 0,		 newItem1:			CARDINAL¬ 0,		 newItem2:			CARDINAL¬ 0,		 newItem3:			CARDINAL¬ 0,		 newItem4:			CARDINAL¬ 0] =BEGIN count:		CARDINAL; items1:	CARDINAL; items2:	CARDINAL; items3:	CARDINAL; items4:	CARDINAL;   --~~~~~internal PROC~~~~~ IncrItem1: PROCEDURE	 RETURNS [overflow: CARDINAL¬ 0]  =BEGIN  IF NOT parmRcPtr­.item1Freeze THEN {     change: CARDINAL¬ parmRcPtr­.item1Change;     UNTIL change< items1 DO	change¬ change-items1;	overflow¬ overflow+ 1;         ENDLOOP;     IF change+parmRcPtr­.item1> parmRcPtr­.maxItem1 THEN {	parmRcPtr­.item1¬ (change+ parmRcPtr­.item1)- items1;	overflow¬ overflow+ 1} ELSE	parmRcPtr­.item1¬ parmRcPtr­.item1+ change};  END; --~~~~~internal PROC~~~~~  DecrItem1: PROCEDURE	RETURNS [underflow: CARDINAL¬ 0]  =BEGIN  IF NOT parmRcPtr­.item1Freeze THEN {     change: CARDINAL¬ parmRcPtr­.item1Change;        UNTIL change< items1 DO	   change¬ change-items1;	   underflow¬ underflow+ 1;            ENDLOOP;     IF change> (parmRcPtr­.item1- parmRcPtr­.minItem1) THEN {	parmRcPtr­.item1¬ (parmRcPtr­.maxItem1+1+(parmRcPtr­.item1- parmRcPtr­.minItem1))- change;	underflow¬ underflow+ 1} ELSE	parmRcPtr­.item1¬ parmRcPtr­.item1- change};  END; --~~~~~internal PROC~~~~~  IncrItem2: PROCEDURE [addOverflow: CARDINAL¬ 0]	 RETURNS [overflow: CARDINAL¬ 0]  =BEGIN  IF NOT parmRcPtr­.item2Freeze THEN {     change: CARDINAL;     IF addOverflow= 0 THEN	change¬ parmRcPtr­.item2Change ELSE change¬ addOverflow;     UNTIL change< items2 DO	change¬ change-items2;	overflow¬ overflow+ 1;         ENDLOOP;     IF change+parmRcPtr­.item2> parmRcPtr­.maxItem2 THEN {	parmRcPtr­.item2¬ (change+ parmRcPtr­.item2)- items2;	overflow¬ overflow+ 1} ELSE	parmRcPtr­.item2¬ parmRcPtr­.item2+ change};  END; --~~~~~internal PROC~~~~~  DecrItem2: PROCEDURE [addUnderflow: CARDINAL¬ 0]	RETURNS [underflow: CARDINAL¬ 0]  =BEGIN  IF NOT parmRcPtr­.item2Freeze THEN {     change: CARDINAL;     IF addUnderflow= 0 THEN	change¬ parmRcPtr­.item2Change ELSE change¬ addUnderflow;        UNTIL change< items2 DO	   change¬ change-items2;	   underflow¬ underflow+ 1;            ENDLOOP;     IF change> (parmRcPtr­.item2- parmRcPtr­.minItem2) THEN {	parmRcPtr­.item2¬ (parmRcPtr­.maxItem2+1+(parmRcPtr­.item2- parmRcPtr­.minItem2))- change;	underflow¬ underflow+ 1} ELSE	parmRcPtr­.item2¬ parmRcPtr­.item2- change};  END; --~~~~~internal PROC~~~~~  IncrItem3: PROCEDURE [addOverflow: CARDINAL¬ 0]	 RETURNS [overflow: CARDINAL¬ 0]  =BEGIN  IF NOT parmRcPtr­.item3Freeze THEN {     change: CARDINAL;     IF addOverflow= 0 THEN	change¬ parmRcPtr­.item3Change ELSE change¬ addOverflow;     UNTIL change< items3 DO	change¬ change-items3;	overflow¬ overflow+ 1;         ENDLOOP;     IF change+parmRcPtr­.item3> parmRcPtr­.maxItem3 THEN {	parmRcPtr­.item3¬ (change+ parmRcPtr­.item3)- items3;	overflow¬ overflow+ 1} ELSE	parmRcPtr­.item3¬ parmRcPtr­.item3+ change};  END; --~~~~~internal PROC~~~~~  DecrItem3: PROCEDURE [addUnderflow: CARDINAL¬ 0]	RETURNS [underflow: CARDINAL¬ 0]  =BEGIN  IF NOT parmRcPtr­.item3Freeze THEN {     change: CARDINAL;     IF addUnderflow= 0 THEN	change¬ parmRcPtr­.item3Change ELSE change¬ addUnderflow;        UNTIL change< items3 DO	   change¬ change-items3;	   underflow¬ underflow+ 1;            ENDLOOP;     IF change> (parmRcPtr­.item3- parmRcPtr­.minItem3) THEN {	parmRcPtr­.item3¬ (parmRcPtr­.maxItem3+1+(parmRcPtr­.item3- parmRcPtr­.minItem3))- change;	underflow¬ underflow+ 1} ELSE	parmRcPtr­.item3¬ parmRcPtr­.item3- change};  END; --~~~~~internal PROC~~~~~  IncrItem4: PROCEDURE [addOverflow: CARDINAL¬ 0]	 RETURNS [overflow: CARDINAL¬ 0]  =BEGIN  IF NOT parmRcPtr­.item4Freeze THEN {     change: CARDINAL;     IF addOverflow= 0 THEN	change¬ parmRcPtr­.item4Change ELSE change¬ addOverflow;     UNTIL change< items4 DO	change¬ change-items4;	overflow¬ overflow+ 1;         ENDLOOP;     IF change+parmRcPtr­.item4> parmRcPtr­.maxItem4 THEN {	parmRcPtr­.item4¬ (change+ parmRcPtr­.item4)- items4;	overflow¬ overflow+ 1} ELSE	parmRcPtr­.item4¬ parmRcPtr­.item4+ change};  END; --~~~~~internal PROC~~~~~  DecrItem4: PROCEDURE [addUnderflow: CARDINAL¬ 0]	RETURNS [underflow: CARDINAL¬ 0]  =BEGIN  IF NOT parmRcPtr­.item4Freeze THEN {     change: CARDINAL;     IF addUnderflow= 0 THEN	change¬ parmRcPtr­.item4Change ELSE change¬ addUnderflow;        UNTIL change< items4 DO	   change¬ change-items4;	   underflow¬ underflow+ 1;            ENDLOOP;     IF change> (parmRcPtr­.item4- parmRcPtr­.minItem4) THEN {	parmRcPtr­.item4¬ (parmRcPtr­.maxItem4+1+(parmRcPtr­.item4- parmRcPtr­.minItem4))- change;	underflow¬ underflow+ 1} ELSE	parmRcPtr­.item4¬ parmRcPtr­.item4- change};  END; --~~~~~end of internal PROCs~~~~~   items1¬ (parmRcPtr­.maxItem1- parmRcPtr­.minItem1)+ 1; items2¬ (parmRcPtr­.maxItem2- parmRcPtr­.minItem2)+ 1; items3¬ (parmRcPtr­.maxItem3- parmRcPtr­.minItem3)+ 1; items4¬ (parmRcPtr­.maxItem4- parmRcPtr­.minItem4)+ 1; IF NOT parmRcPtr­.item1Freeze AND parmRcPtr­.item1Change> 0 THEN {     IF parmRcPtr­.item1Incr THEN {	count¬ IncrItem1 [];	IF count> 0 THEN count¬ IncrItem2 [addOverflow: count];	IF count> 0 THEN count¬ IncrItem3 [addOverflow: count]; 	IF count> 0 THEN count¬ IncrItem4 [addOverflow: count]} ELSE {	   count¬ DecrItem1 [];	   IF count> 0 THEN count¬ DecrItem2 [addUnderflow: count];	   IF count> 0 THEN count¬ DecrItem3 [addUnderflow: count];	   IF count> 0 THEN count¬ DecrItem4 [addUnderflow: count]}};	     IF NOT parmRcPtr­.item2Freeze AND parmRcPtr­.item2Change> 0 THEN {     IF parmRcPtr­.item2Incr THEN {	count¬ IncrItem2 [];	IF count> 0 THEN count¬ IncrItem3 [addOverflow: count];	IF count> 0 THEN count¬ IncrItem4 [addOverflow: count]} ELSE {	   count¬ DecrItem2 [];	   IF count> 0 THEN count¬ DecrItem3 [addUnderflow: count];	   IF count> 0 THEN count¬ DecrItem4 [addUnderflow: count]}};	     IF NOT parmRcPtr­.item3Freeze AND parmRcPtr­.item3Change> 0 THEN {     IF parmRcPtr­.item3Incr THEN {	count¬ IncrItem3 [];	IF count> 0 THEN count¬ IncrItem4 [addOverflow: count]} ELSE {	   count¬ DecrItem3 [];	   IF count> 0 THEN count¬ DecrItem4 [addUnderflow: count]}};    IF NOT parmRcPtr­.item4Freeze AND parmRcPtr­.item4Change> 0 THEN {     IF parmRcPtr­.item4Incr THEN 	count¬ IncrItem4 [] ELSE 	   count¬ DecrItem4 []};    -- transfer changes  newItem1¬ parmRcPtr­.item1;  newItem2¬ parmRcPtr­.item2;  newItem3¬ parmRcPtr­.item3;  newItem4¬ parmRcPtr­.item4;    IF DiagFlTapeOpInt.Engineering     AND DiagFlTapeOpInt.Switch[79]     AND (parmRcPtr­.itemsToXfer > 32 OR parmRcPtr­.itemsToXfer < 1) THEN       Runtime.CallDebugger["'Items to Xfer problem'"]; SELECT FALSE FROM   parmRcPtr­.xferPassedMaxItem1=> {};   parmRcPtr­.xferPassedMaxItem2 =>      IF parmRcPtr­.xferItem1 THEN     { items1Cnt:	LONG CARDINAL;       items1Cnt¬ (parmRcPtr­.maxItem2-parmRcPtr­.minItem2+1)*(parmRcPtr­.maxItem1-parmRcPtr­.minItem1+1)+         ((parmRcPtr­.item2*(parmRcPtr­.maxItem1-parmRcPtr­.minItem1+ 1))+(parmRcPtr­.item1)+parmRcPtr­.itemsToXfer);       IF items1Cnt> item1sInItem3 THEN       { items1Cnt¬ items1Cnt- item1sInItem3;         newItemsToXfer¬ CARDINAL[items1Cnt];         newItemsToXfer¬ parmRcPtr­.itemsToXfer- newItemsToXfer       } ELSE newItemsToXfer ¬ parmRcPtr­.itemsToXfer;     };   parmRcPtr­.xferPassedMaxItem3 =>     IF parmRcPtr­.xferItem1 THEN     { items1Cnt:	LONG CARDINAL;       items1Cnt¬ parmRcPtr­.item3;       items1Cnt¬ (items1Cnt*(parmRcPtr­.maxItem2-parmRcPtr­.minItem2+1)*(parmRcPtr­.maxItem1-parmRcPtr­.minItem1+1))+         ((parmRcPtr­.item2*(parmRcPtr­.maxItem1-parmRcPtr­.minItem1+ 1))+(parmRcPtr­.item1)+parmRcPtr­.itemsToXfer);       IF items1Cnt> item1sInItem4 THEN       { items1Cnt¬ items1Cnt- item1sInItem4;         newItemsToXfer¬ CARDINAL[items1Cnt];         newItemsToXfer¬ parmRcPtr­.itemsToXfer- newItemsToXfer       } ELSE newItemsToXfer ¬ parmRcPtr­.itemsToXfer;     } ELSE     IF parmRcPtr­.xferItem2 THEN     { items2Cnt:	LONG CARDINAL;       items2Cnt¬ parmRcPtr­.item3;       items2Cnt¬ (items2Cnt*(parmRcPtr­.maxItem2-parmRcPtr­.minItem2+1))+         parmRcPtr­.item2+parmRcPtr­.itemsToXfer;       IF items2Cnt> item2sInItem4 THEN       { items2Cnt¬ items2Cnt- item2sInItem4;         newItemsToXfer¬ CARDINAL[items2Cnt];         newItemsToXfer¬ parmRcPtr­.itemsToXfer- newItemsToXfer       } ELSE newItemsToXfer ¬ parmRcPtr­.itemsToXfer;     }; ENDCASE => newItemsToXfer¬ parmRcPtr­.itemsToXfer; 	   END; --UpdateParameters --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- main line code --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ parmRecord.minItem1¬ DiagFlTapeCmds.MinSector; parmRecord.maxItem1¬ DiagFlTapeCmds.MaxSector; parmRecord.minItem3¬ DiagFlTapeCmds.MinTrack; parmRecord.maxItem3¬ DiagFlTapeCmds.MaxTrack;  END... --of DiagFlTapeCmdDriveImplLOG13-Nov-86  8:51:00 PJT: Created 4-Mar-88 15:13:44 JMA: commented out CheckUserAbort in loop	  	  
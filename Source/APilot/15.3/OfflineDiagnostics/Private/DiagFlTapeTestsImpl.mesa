-- Copyright (C) 1987  by Xerox Corporation.  All rights reserved.---- File: DiagFlTapeTestsImpl.mesa-- Edited by: JMA 14-Mar-88 13:48:08-- DIRECTORY DiagFlTapeCmdDes	USING	[Command, CmdDescriptArray], DiagFlTapeCmds		USING	[LastReadStatus, IoCPA, ReadBuffPtr1,				 SectorsPerTape], DiagFlTapeErrorCheck	USING	[CheckStatus, ECStandard1,				 NumOfSoftErrs, SoftErrBuffPtr,				 SoftErrCntBuffPtr, NumOfHardReadErrs,				 NumOfBadPages, BadPageBuffPtr,				 HardReadErrBuffPtr], DiagFlTapeLog		USING	[SummLogArray], DiagFlTapeMkDispl	USING	[mkDispl], DiagFlTapeMkMenu	USING	[mkMenu], DiagFlTapeMkOpInt	USING	[mkOpInt], DiagFlTapeDisplay	USING	[ErrorTable], DiagFlTapeOpInt	USING	[User, SystemAdmin, TechRep, Manufacturing,				 Engineering, CallService, PassCount,				 GetTestRequirements, DisplayTestParameters], DiagFlTapeRunCmdFile	USING	[RunningUserCmdFile], DiagFlTapeTestControl	USING	[SetUpTestControl, TCChckForErr,				 SoftErrorsInAPass, HardReadErrorsInAPass,				 RateErrorsInAPass, DisplaySummaryOnHardErr], DiagFlTapeTestRec	USING	[RunSubtest, Subtest,				 RunTestArray], DiagFlTapeTestSelect	USING	[Exit], DiagFlTapeTTY		USING	[ClearPriorLines, GetLongNumber,				 PutLine, PutCR, PutString, GetString,				 PutSubtest, Initialize, GetYesNo,				 PutNumber, PutLongNumber,				 PutChar, PutMessage, ProceedOnInput,				 CheckIfUserAbort, UserAbort], DiagFlTapeTests	USING	[],-- SpecialFloppyTapeFace	USING	[Statistics, GetTapeStatistics], FloppyTape		USING	[VolumeName, Error,				-- OpenVolume, CloseVolume,				 Format, Drive, AlreadyFormatted,				 Scavenge, FeedBack, FeedBackPtr,				 MarkSectorBad, nullSectorNumber], FloppyTapeFormat	USING	[RootPage, maxNumberBadSectors], OfflineDiagInterface 	USING 	[AbortCurrentTest, PutMessage], Process		USING	[Yield, Abort, Pause],  Time			USING	[Current]; DiagFlTapeTestsImpl: PROGRAM      IMPORTS	DiagFlTapeCmdDes,	DiagFlTapeCmds,	DiagFlTapeErrorCheck,	DiagFlTapeLog,	DiagFlTapeMkDispl,	DiagFlTapeMkMenu,	DiagFlTapeMkOpInt,	DiagFlTapeDisplay,	DiagFlTapeOpInt,	DiagFlTapeRunCmdFile,	DiagFlTapeTestControl,	DiagFlTapeTestRec,	DiagFlTapeTestSelect,	DiagFlTapeTTY,--	SpecialFloppyTapeFace,	FloppyTape,	OfflineDiagInterface,	Process,	Time     EXPORTS	DiagFlTapeTests = BEGIN     OPEN	DiagFlTapeMkDispl,	DiagFlTapeMkMenu,	DiagFlTapeMkOpInt,	Cd: DiagFlTapeCmdDes,	Io: DiagFlTapeCmds,	Ec: DiagFlTapeErrorCheck,	Odi: OfflineDiagInterface;   writeProtected: BOOLEAN¬ FALSE; testDrive: FloppyTape.Drive ¬ 1;	-- Cartridge Tape Drive -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- Just checks if floppy tape is inside tape drive -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CheckForReady:  PUBLIC PROCEDURE[    strArray: LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0]] = BEGIN-- stats:			SpecialFloppyTapeFace.Statistics;-- now:			LONG CARDINAL; timedOut:		BOOLEAN¬ FALSE; gotTapeChanged:	BOOLEAN¬ FALSE; goodCmpl:		BOOLEAN¬ FALSE; timeOut:		LONG CARDINAL; -- turn on the trace and the error log and initialize controller DiagFlTapeTestRec.RunSubtest[displayTitle: FALSE, subtest: STInitLogTrace]; DiagFlTapeTestRec.RunSubtest[displayTitle: FALSE, subtest: STrstController]; -- check if the drive is write protected. -- Note: this subtest does not go through the status check and therefor log writeProtected	¬ FALSE; timeOut¬ Time.Current[] + 180; DiagFlTapeTestRec.RunSubtest[displayTitle: FALSE, subtest: STNoOpGetStatus]; UNTIL timedOut   OR DiagFlTapeCmds.LastReadStatus= goodCompletion   OR DiagFlTapeCmds.LastReadStatus= writeFault DO     Process.Pause[20];     DiagFlTapeTestRec.RunSubtest[         displayTitle: FALSE, subtest: STNoOpGetStatus];     IF Time.Current[] >= timeOut THEN timedOut ¬ TRUE; ENDLOOP; IF DiagFlTapeCmds.LastReadStatus= writeFault THEN { writeProtected¬ TRUE;   RETURN; }; IF DiagFlTapeCmds.LastReadStatus= recordNotFound THEN { DiagFlTapeCmds.LastReadStatus ¬ diskChange; } ELSE   -- check if the drive is ready.   -- Note: this subtest does not go through the status check and therefor log   DiagFlTapeTestRec.RunSubtest[displayTitle: FALSE, subtest: STreadStatus];  IF DiagFlTapeCmds.LastReadStatus= goodCompletion THEN RETURN; IF DiagFlTapeCmds.LastReadStatus= diskChange     OR DiagFlTapeCmds.LastReadStatus= notReady THEN { -- have user ready the tape drive   DiagFlTapeTTY.PutCR[count: 1];   IF BASE [strArray]= NIL THEN   --output default message   DiagFlTapeTTY.PutLine[string: mkMenu[insertTape]] ELSE   --output provided message   { FOR i: CARDINAL IN [0..LENGTH[strArray]) DO       DiagFlTapeTTY.PutLine[string: strArray[i]];     ENDLOOP;   };   DiagFlTapeTTY.ProceedOnInput[     text: mkMenu[typeCharWhenDone],     keepScreenOn: TRUE];   -- clear disk change and see if the tape is rewinding   DiagFlTapeTestRec.RunSubtest[displayTitle: FALSE, subtest: STrstController];   DiagFlTapeTestRec.RunSubtest[displayTitle: FALSE, subtest: STrstDiskChange];   DiagFlTapeTestRec.RunSubtest[displayTitle: FALSE, subtest: STrdBadPgTable];   --DiagFlTapeTestRec.RunSubtest[displayTitle: FALSE, subtest: STreadStatus];      SELECT DiagFlTapeCmds.LastReadStatus FROM      goodCompletion,		-- good status      recordNotFound => RETURN;	-- the tape may not have been formatted      ENDCASE => {      		   DiagFlTapeTestControl.SetUpTestControl[        		controlData: DiagFlTapeTestControl.TCChckForErr];       		   Ec.CheckStatus[ command: noOp,	   		errorArray: DESCRIPTOR [Ec.ECStandard1]];      		   RETURN;     		 };  };  -- have user ready the tape drive <<   IF DiagFlTapeCmds.LastReadStatus= notReady THEN   { -- tape is rewinding, wait until disk changed comes up again     now¬ Time.Current[];     now¬ now+ 120;     UNTIL timedOut OR gotTapeChanged DO       DiagFlTapeTestRec.RunSubtest[displayTitle: FALSE, subtest: STreadStatus];       IF DiagFlTapeCmds.LastReadStatus= diskChange THEN	 gotTapeChanged¬ TRUE;       IF Time.Current[]> now THEN	 timedOut¬ TRUE;     ENDLOOP; -- timedOut OR gotTapeChanged   };   IF timedOut THEN GOTO Exit;   -- now set and wait for good completion   now¬ Time.Current[];   now¬ now+ 15;   UNTIL goodCmpl OR timedOut DO     DiagFlTapeTestRec.RunSubtest[displayTitle: FALSE, subtest: STrstController];     DiagFlTapeTestRec.RunSubtest[displayTitle: FALSE, subtest: STrstDiskChange];          DiagFlTapeTestRec.RunSubtest[displayTitle: FALSE, subtest: STreadStatus];     IF DiagFlTapeCmds.LastReadStatus= goodCompletion THEN goodCmpl¬ TRUE;     IF DiagFlTapeCmds.LastReadStatus= writeFault THEN     { writeProtected¬ TRUE;       goodCmpl¬ TRUE;     } ELSE writeProtected¬ FALSE;     IF Time.Current[]> now THEN timedOut¬ TRUE;   ENDLOOP; -- goodCmpl OR timedOut   IF timedOut THEN GOTO Exit; } ELSE GOTO Exit; -- some other error has occurred EXITS   Exit=>     { DiagFlTapeTestControl.SetUpTestControl[         controlData: DiagFlTapeTestControl.TCChckForErr];       Ec.CheckStatus[           command: noOp,	   errorArray: DESCRIPTOR [Ec.ECStandard1]];       RETURN;     }; >> END; -- of CheckForReady -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the bad pages from the bad page table -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GrabTheBadPages:  PROCEDURE = BEGIN cnt:		CARDINAL¬ 0; num:		CARDINAL; err:		BOOLEAN¬ FALSE; ptr:		LONG POINTER TO FloppyTapeFormat.RootPage¬			LOOPHOLE[DiagFlTapeCmds.ReadBuffPtr1]; bdPgCnt:	CARDINAL; bdPg:		LONG CARDINAL; bdPgPtr:	LONG POINTER TO ARRAY OF WORD¬ DiagFlTapeCmds.ReadBuffPtr1+ 256; idx:		CARDINAL¬ 0;   --read the bad page table ReadBadPageTable[]; --get the count of bad pages Ec.NumOfBadPages¬ bdPgCnt¬ ptr­.numberOfBadPages;  --check if this looks like a good bad page table IF bdPgCnt> FloppyTapeFormat.maxNumberBadSectors THEN err¬ TRUE; IF err THEN GOTO exit;  cnt¬ 0; UNTIL cnt>=bdPgCnt OR cnt= 512 DO   --get a page   num¬ bdPgPtr­[idx+1];   --check for bum number   IF num>4 OR num IN[1..3] THEN GOTO exit;   IF num= 4 THEN bdPg¬ 65536 ELSE bdPg¬ 0;   num¬ bdPgPtr­[idx];   bdPg¬ bdPg+ num;   --check for bum numbers   IF bdPg= 0 OR bdPg> DiagFlTapeCmds.SectorsPerTape THEN GOTO exit;   --store the page   Ec.BadPageBuffPtr[cnt]¬ bdPg;   idx¬ idx + 2;   cnt ¬ cnt + 1; ENDLOOP;  EXITS   exit=>   { Ec.NumOfBadPages¬ 0;     --DiagFlTapeTTY.PutCR[];     DiagFlTapeTTY.PutLine[mkMenu[canNotRdBadPgTbl]];     DiagFlTapeOpInt.CallService[fruCode: 2827];   }; END; -- of GrabTheBadPages -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- retensions the entire tape -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RetentionTape:  PUBLIC PROCEDURE = BEGIN time:			CARDINAL; totalPassCnt:		CARDINAL; firstPass:		BOOLEAN¬ TRUE;  DiagFlTapeRunCmdFile.RunningUserCmdFile¬ FALSE; DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ FALSE;  --get the pass count DiagFlTapeOpInt.GetTestRequirements[	testTitle:	mkMenu[retentionTapeTitlE],	needPassCount:	TRUE];	 Odi.PutMessage [message: mkMenu[retentionTapeTitlE],  			clearMessageAreaFirst: TRUE]; -- set pass time, pass count time¬ 180; totalPassCnt¬ DiagFlTapeOpInt.PassCount;  --init error cheching and make drive ready --DiagFlTapeTTY.PutCR []; CheckForReady[];  -- run the test  UNTIL DiagFlTapeOpInt.PassCount= 0 DO    --display the test data    DiagFlTapeOpInt.DisplayTestParameters[      testTitle: mkMenu[retentionTapeTitlE],      firstPass: firstPass,      passCountTotal: totalPassCnt,      passCountRemaining: DiagFlTapeOpInt.PassCount,      timePerPass: time];    firstPass¬ FALSE;    --now run the test    RunRetentionTape;        -- exit if no more passes    DiagFlTapeOpInt.PassCount¬ DiagFlTapeOpInt.PassCount- 1;    IF DiagFlTapeOpInt.PassCount=0 THEN    { DiagFlTapeTTY.PutMessage[];      DiagFlTapeTTY.PutSubtest [testName: " "]; --to clear the last subtest      DiagFlTapeTTY.PutCR [count: 1];      DiagFlTapeTTY.PutSubtest [testName: mkMenu[testCompleted]];      DiagFlTapeTTY.PutChar[char: 7C];      DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];    }; ENDLOOP; --DiagFlTapeOpInt.PassCount= 0   END; -- of RetentionTape-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RunRetentionTape: PROCEDURE = BEGIN subtestSelectArray:		ARRAY [0..1] OF DiagFlTapeTestRec.Subtest¬ [	STInitLogTrace,	STretentionTp	]; DiagFlTapeTestRec.RunTestArray [ 	subtestSelectArray: DESCRIPTOR [subtestSelectArray]];	 END; --RunRetentionTape -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- Formats the entire tape -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FormatTape:  PUBLIC PROCEDURE = BEGIN --~~~~~~~~~~~internal procedure~~~~~~~~~~~~ CheckForUserAbort: PROCEDURE = BEGIN DiagFlTapeTTY.CheckIfUserAbort[]; END; --of CheckForUserAbort --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  DoFormat: PROCEDURE =     BEGIN    ENABLE { DiagFlTapeTTY.UserAbort => GOTO punt;	     Odi.AbortCurrentTest => GOTO punt };    FloppyTape.Format[      drive: testDrive,      name: str,      clientWord: clientWord,      feedBack: feedBackPtr      !FloppyTape.AlreadyFormatted =>        { IF firstPass THEN 	  { DiagFlTapeTTY.PutCR[];	    DiagFlTapeTTY.PutLine[mkMenu[alreadyFomatted]];	    DiagFlTapeTTY.PutLine[mkMenu[tapeNameIs]];	    DiagFlTapeTTY.PutLine[labelString];	    IF DiagFlTapeTTY.GetYesNo[	      prompt: mkMenu[wishToContinue],	      keepScreenOn: TRUE] THEN	    { --DiagFlTapeTTY.PutCR[];	      IF DiagFlTapeTTY.GetYesNo[	        prompt: mkMenu[keepOldBdPgTbl],		keepScreenOn: TRUE] THEN	      { GrabTheBadPages[];		keptOldBdPgTbl¬ TRUE;                DiagFlTapeTTY.ClearPriorLines[5];	        RESUME;	      } ELSE	      { DiagFlTapeTTY.ClearPriorLines[5];	        RESUME;	      };	    } ELSE	    { quit¬ TRUE;	      CONTINUE;	    };	  } ELSE RESUME;	};	ABORTED=> {quit¬ TRUE; CONTINUE};	FloppyTape.Error =>	  { SELECT error FROM	      badTape=>	        { DiagFlTapeTTY.PutCR[];	          DiagFlTapeTTY.PutLine[mkMenu[badTape]];	          quit¬ TRUE;		  IF DiagFlTapeOpInt.SystemAdmin OR DiagFlTapeOpInt.User	            THEN DiagFlTapeTTY.PutLine[mkMenu[replaceTape]]		    ELSE DiagFlTapeOpInt.CallService[fruCode: 2833];		  DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];	          CONTINUE;		};	      hardwareError, noSuchDrive, volumeOpen =>	        { DiagFlTapeTTY.PutCR[];	          DiagFlTapeTTY.PutLine[mkMenu[hardwareErr]];	          quit¬ TRUE;		  IF DiagFlTapeOpInt.SystemAdmin OR DiagFlTapeOpInt.User	            THEN DiagFlTapeTTY.PutLine[mkMenu[runConfidenceTst]]		    ELSE DiagFlTapeOpInt.CallService[fruCode: 2831];		  DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];	          CONTINUE;		};	      notReady=>	        { DiagFlTapeTTY.PutCR[];	          DiagFlTapeTTY.PutLine[mkMenu[driveWentNotReady]];	          quit¬ TRUE;		  DiagFlTapeOpInt.CallService[fruCode: 2822];	          CONTINUE;		};	      writeInhibited=>	        { DiagFlTapeTTY.PutCR[];	          DiagFlTapeTTY.PutLine[mkMenu[writeInhibt]];	          quit¬ TRUE;		  DiagFlTapeOpInt.CallService[fruCode: 2822];	          CONTINUE;		};	    ENDCASE=>	        { DiagFlTapeTTY.PutCR[];	          DiagFlTapeTTY.PutLine[mkMenu[hardwareErr]];	          quit¬ TRUE;		  IF DiagFlTapeOpInt.SystemAdmin OR DiagFlTapeOpInt.User	            THEN DiagFlTapeTTY.PutLine[mkMenu[runConfidenceTst]]		    ELSE DiagFlTapeOpInt.CallService[fruCode: 2831];	          CONTINUE;		};	  }]; formatDone¬ TRUE;  EXITS punt => quit ¬ TRUE;  END; --of DoFormat --~~~~~~~~~~~end of internal procedure~~~~~~~~~~~~ oldFeedBack:		FloppyTape.FeedBack ¬ none; formatDone:		BOOLEAN ¬ FALSE; userAborted:		BOOLEAN ¬ FALSE; frmt:			PROCESS; clientWord:		UNSPECIFIED ¬ 0; str:			FloppyTape.VolumeName¬ [100]; time:			CARDINAL; totalPassCnt:		CARDINAL; quit:			BOOLEAN¬ FALSE; firstPass:		BOOLEAN¬ TRUE; keptOldBdPgTbl:	BOOLEAN¬ FALSE; feedBackPtr:		FloppyTape.FeedBackPtr; feedBack:		FloppyTape.FeedBack;  feedBackPtr ¬ @feedBack; DiagFlTapeRunCmdFile.RunningUserCmdFile¬ FALSE; DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ FALSE;  --display warning DiagFlTapeTTY.Initialize []; DiagFlTapeTTY.PutLine[mkMenu[formatTitlE]]; DiagFlTapeTTY.PutCR[]; DiagFlTapeTTY.PutLine[mkMenu[formatDestroys]]; IF NOT DiagFlTapeTTY.GetYesNo[   prompt: mkMenu[wishToContinue],   keepScreenOn: TRUE] THEN RETURN; --DiagFlTapeTTY.PutCR[count: 2]; IF NOT DiagFlTapeTTY.GetYesNo[   prompt: mkMenu[stillSure],   keepScreenOn: TRUE] THEN RETURN; --preset pass count DiagFlTapeOpInt.PassCount¬ 1; --output the title DiagFlTapeOpInt.GetTestRequirements[	testTitle:	mkMenu[formatTitlE]]; -- set pass time time¬ 45*60; totalPassCnt¬ DiagFlTapeOpInt.PassCount;  -- initialize error checking and ready the drive --DiagFlTapeTTY.PutCR []; CheckForReady[]; --if write protected output a message IF writeProtected THEN { DiagFlTapeTTY.PutCR[count: 1];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtPrtctd]];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtEnable]];   DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];   RETURN; }; --get the tape name from the user --DiagFlTapeTTY.PutCR[]; DiagFlTapeTTY.PutLine[mkMenu[enterTapeName]]; str.length¬ 0; DiagFlTapeTTY.GetString[ 	prompt: mkMenu[prompt], 	inputString: str,	stringLength: 100];   -- run the test  UNTIL DiagFlTapeOpInt.PassCount= 0 DO    --display the test data    DiagFlTapeOpInt.DisplayTestParameters[      testTitle: mkMenu[formatTitlE],      firstPass: firstPass,      passCountTotal: totalPassCnt,      passCountRemaining: DiagFlTapeOpInt.PassCount,      timePerPass: time];        frmt ¬ FORK DoFormat[];        --now wait for errors/userAbort/completion    userAborted¬ FALSE;    DO      Process.Yield;      --check if pass type changed      IF oldFeedBack # feedBackPtr­ THEN      { oldFeedBack ¬ feedBackPtr­;	SELECT oldFeedBack FROM	  retentionPass  => DiagFlTapeTTY.PutSubtest[mkMenu[retentioningTp]];	  formatPass     => DiagFlTapeTTY.PutSubtest[mkMenu[formatingTp]];	  verifyPass     => DiagFlTapeTTY.PutSubtest[mkMenu[verifyingFormat]];	ENDCASE;      };      IF NOT userAborted THEN        CheckForUserAbort[        ! DiagFlTapeTTY.UserAbort=> 	    { Process.Abort[frmt];              DiagFlTapeTTY.PutSubtest[                testName: DiagFlTapeMkMenu.mkMenu[breakKeyAck]];              userAborted¬ TRUE;	      CONTINUE;	    }];      IF quit OR formatDone THEN EXIT;    ENDLOOP;      JOIN frmt;   IF quit THEN SIGNAL DiagFlTapeTestSelect.Exit;   firstPass¬ FALSE;   DiagFlTapeOpInt.PassCount¬ DiagFlTapeOpInt.PassCount- 1;   IF DiagFlTapeOpInt.PassCount=0 THEN   { DiagFlTapeTTY.PutMessage[];     DiagFlTapeTTY.PutSubtest [testName: " "]; --to clear the last subtest     DiagFlTapeTTY.PutCR [count: 1];     IF keptOldBdPgTbl AND Ec.NumOfBadPages> 0 THEN     { err: BOOLEAN¬ FALSE;       DiagFlTapeTTY.PutLine[string: mkMenu[loggingOldBdPgTbl]];       FOR i: CARDINAL IN [0..Ec.NumOfBadPages) DO         err¬ MarkPageBad[Ec.BadPageBuffPtr[i]];         IF err THEN RETURN;       ENDLOOP;       DiagFlTapeTTY.PutCR [count: 1];     };     DiagFlTapeTTY.PutSubtest [testName: mkMenu[testCompleted]];     DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];   }; ENDLOOP; --DiagFlTapeOpInt.PassCount= 0   END; -- of FormatTape -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Formats one stream-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LogBadPage:  PUBLIC PROCEDURE = BEGIN num:		LONG CARDINAL; getout:	BOOLEAN¬ FALSE; quit:		BOOLEAN¬ FALSE; questtext:	ARRAY [0..2] OF LONG STRING¬ [			mkMenu[entrFailPageNum],			mkMenu[suppPageNumsAre1],			mkMenu[suppPageNumsAre2]];  DiagFlTapeRunCmdFile.RunningUserCmdFile¬ FALSE; DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ FALSE; --display the title DiagFlTapeOpInt.GetTestRequirements[ 	testTitle: mkMenu[logBadPageTtl]]; --check for ready CheckForReady[]; --if write protected output a message IF writeProtected THEN { DiagFlTapeTTY.PutCR[count: 1];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtPrtctd]];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtEnable]];   DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];   RETURN; };  UNTIL getout OR quit DO   --display the title and menu   DiagFlTapeTTY.Initialize [];   DiagFlTapeTTY.PutCR[];    DiagFlTapeTTY.PutLine[mkMenu[logBadPageTtl]];    --DiagFlTapeTTY.PutCR[];    --get the bad sector number   num¬ DiagFlTapeTTY.GetLongNumber[	prompt: mkMenu[badPageToBeLogd],	acceptNumWithin: TRUE,	minNumber: 33,	maxNumber:94080,	explanation: DESCRIPTOR [questtext]];   DiagFlTapeTTY.PutMessage[]; --to clear prior message   --DiagFlTapeTTY.PutCR [];   --are you sure   IF DiagFlTapeTTY.GetYesNo[     prompt: mkMenu[areYouSure],     keepScreenOn: TRUE] THEN   { --store the bad sector    quit¬ MarkPageBad[num];   };   IF quit THEN RETURN;   --DiagFlTapeTTY.PutCR[];    IF NOT DiagFlTapeTTY.GetYesNo[     prompt: mkMenu[more],     keepScreenOn: TRUE] THEN     getout¬ TRUE; ENDLOOP; IF quit THEN RETURN;  END; --LogBadPage -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- marks the page bad -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MarkPageBad:  PROCEDURE [badSector: LONG CARDINAL] 	RETURNS [problem: BOOLEAN¬ FALSE] = BEGIN     FloppyTape.MarkSectorBad[        drive: testDrive,	sector: badSector	! FloppyTape.Error =>	  { SELECT error FROM	      notReady=>	        { DiagFlTapeTTY.PutCR[];	          DiagFlTapeTTY.PutLine[mkMenu[driveWentNotReady]];		  DiagFlTapeOpInt.CallService[fruCode: 2822];	          problem¬ TRUE;		  CONTINUE;		};	      writeInhibited=>	        { DiagFlTapeTTY.PutCR[];	          DiagFlTapeTTY.PutLine[mkMenu[writeInhibt]];		  DiagFlTapeOpInt.CallService[fruCode: 2822];	          problem¬ TRUE;		  CONTINUE;		};	      badTape=>	        { DiagFlTapeTTY.PutCR[];	          DiagFlTapeTTY.PutLine[mkMenu[badTape]];		  IF DiagFlTapeOpInt.SystemAdmin OR DiagFlTapeOpInt.User	            THEN DiagFlTapeTTY.PutLine[mkMenu[replaceTape]]		    ELSE DiagFlTapeOpInt.CallService[fruCode: 2833];		  DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];	          problem¬ TRUE;		  CONTINUE;		};	      hardwareError=>	        { DiagFlTapeTTY.PutCR[];	          DiagFlTapeTTY.PutLine[mkMenu[hardwareErr]];		  IF DiagFlTapeOpInt.SystemAdmin OR DiagFlTapeOpInt.User	            THEN DiagFlTapeTTY.PutLine[mkMenu[runConfidenceTst]]		    ELSE DiagFlTapeOpInt.CallService[fruCode: 2831];		  DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];	          problem¬ TRUE;		  CONTINUE;		};	      notFormatted=>	        { DiagFlTapeTTY.PutCR[];	          DiagFlTapeTTY.PutLine[mkMenu[notFormatted]];		  DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];	          problem¬ TRUE;		  CONTINUE;		};	      needsScavenging=>	        { DiagFlTapeTTY.PutCR[];	          DiagFlTapeTTY.PutLine[mkMenu[needsScavenging]];		  IF DiagFlTapeOpInt.SystemAdmin OR DiagFlTapeOpInt.User	            THEN DiagFlTapeTTY.PutLine[mkMenu[runScavenger]]		    ELSE DiagFlTapeOpInt.CallService[fruCode: 2832];		  DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];	          problem¬ TRUE;		  CONTINUE;		};	    ENDCASE=>	        { DiagFlTapeTTY.PutCR[];	          DiagFlTapeTTY.PutLine[mkMenu[hardwareErr]];		  IF DiagFlTapeOpInt.SystemAdmin OR DiagFlTapeOpInt.User	            THEN DiagFlTapeTTY.PutLine[mkMenu[runConfidenceTst]]		    ELSE DiagFlTapeOpInt.CallService[fruCode: 2831];		  DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];	          problem¬ TRUE;	          CONTINUE;		};	  }];  END; --MarkPageBad-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Scavenges the first track of the tape-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ScavengeTape:  PUBLIC PROCEDURE = BEGIN volumeOkay:	BOOLEAN¬ FALSE; problem:	BOOLEAN¬ FALSE;   DiagFlTapeRunCmdFile.RunningUserCmdFile¬ FALSE; DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ FALSE;  --output the title DiagFlTapeOpInt.GetTestRequirements[	testTitle:	mkMenu[scavengeTapeTitlE]];	 -- initialize error checking and ready the drive --DiagFlTapeTTY.PutCR []; CheckForReady[];  --if write protected output a message IF writeProtected THEN { DiagFlTapeTTY.PutCR[count: 1];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtPrtctd]];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtEnable]];   DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];   RETURN; }; --output the title DiagFlTapeOpInt.GetTestRequirements[	testTitle:	mkMenu[scavengeTapeTitlE]];	 DiagFlTapeTTY.PutLine[mkMenu[runningScvgr]];    volumeOkay ¬ FloppyTape.Scavenge[drive: testDrive !    FloppyTape.Error => SELECT error FROM       badTape => 	        { DiagFlTapeTTY.PutCR[];		  DiagFlTapeTTY.PutLine[mkMenu[unsuccessRepair]];	          DiagFlTapeTTY.PutLine[mkMenu[badTape]];		  IF DiagFlTapeOpInt.SystemAdmin OR DiagFlTapeOpInt.User	            THEN DiagFlTapeTTY.PutLine[mkMenu[replaceTape]]		    ELSE DiagFlTapeOpInt.CallService[fruCode: 2833];		  DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];		  problem¬ TRUE;		  CONTINUE;		};       hardwareError, noSuchDrive, volumeOpen => 	        { DiagFlTapeTTY.PutCR[];		  DiagFlTapeTTY.PutLine[mkMenu[unsuccessRepair]];	          DiagFlTapeTTY.PutLine[mkMenu[hardwareErr]];		  IF DiagFlTapeOpInt.SystemAdmin OR DiagFlTapeOpInt.User	            THEN DiagFlTapeTTY.PutLine[mkMenu[runConfidenceTst]]		    ELSE DiagFlTapeOpInt.CallService[fruCode: 2831];		  DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];		  problem¬ TRUE;		  CONTINUE;		};       notReady =>	        { DiagFlTapeTTY.PutCR[];		  DiagFlTapeTTY.PutLine[mkMenu[unsuccessRepair]];	          DiagFlTapeTTY.PutLine[mkMenu[driveWentNotReady]];		  DiagFlTapeOpInt.CallService[fruCode: 2822];		  problem¬ TRUE;		  CONTINUE;		};       writeInhibited =>	        { DiagFlTapeTTY.PutCR[];		  DiagFlTapeTTY.PutLine[mkMenu[unsuccessRepair]];	          DiagFlTapeTTY.PutLine[mkMenu[writeInhibt]];		  DiagFlTapeOpInt.CallService[fruCode: 2822];		  problem¬ TRUE;		  CONTINUE;		};       notFormatted =>	        { DiagFlTapeTTY.PutCR[];		  DiagFlTapeTTY.PutLine[mkMenu[unsuccessRepair]];	          DiagFlTapeTTY.PutLine[mkMenu[notFormatted]];		  DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];		  problem¬ TRUE;		  CONTINUE;		};       ENDCASE=>	        { DiagFlTapeTTY.PutCR[];		  DiagFlTapeTTY.PutLine[mkMenu[unsuccessRepair]];	          DiagFlTapeTTY.PutLine[mkMenu[hardwareErr]];		  IF DiagFlTapeOpInt.SystemAdmin OR DiagFlTapeOpInt.User	            THEN DiagFlTapeTTY.PutLine[mkMenu[runConfidenceTst]]		    ELSE DiagFlTapeOpInt.CallService[fruCode: 2831];		  DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];		  problem¬ TRUE;	          CONTINUE;		}];     IF volumeOkay AND NOT problem THEN  { DiagFlTapeTTY.PutCR[];    DiagFlTapeTTY.PutLine[mkMenu[successRepair]];    DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];  };  IF NOT volumeOkay AND NOT problem THEN  { DiagFlTapeTTY.PutCR[];    DiagFlTapeTTY.PutLine[mkMenu[unsuccessRepair]];    DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];  };   END; --ScavengeTape -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- exercises the tape drive using a diagnostic tape -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ConfidenceTest:  PUBLIC PROCEDURE = BEGIN messages:	ARRAY [0..0] OF LONG STRING¬ [			mkMenu[insertDiagTape1]]; notice:	ARRAY [0..1] OF LONG STRING¬ [			mkMenu[insertDiagTape1a],			mkMenu[insertDiagTape2]]; time:		CARDINAL; totalPassCnt:	CARDINAL; quit:		BOOLEAN¬ FALSE; firstPass:	BOOLEAN¬ TRUE;  DiagFlTapeRunCmdFile.RunningUserCmdFile¬ FALSE; DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ FALSE;	 --preset pass count DiagFlTapeOpInt.PassCount¬ 1; --get the pass count DiagFlTapeOpInt.GetTestRequirements[	notice:		DESCRIPTOR[notice],	testTitle:	mkMenu[confidenceTestTtL],	needPassCount:	TRUE]; -- set pass time, pass count totalPassCnt¬ DiagFlTapeOpInt.PassCount;  -- initialize error checking and get the drive ready --DiagFlTapeTTY.PutCR []; CheckForReady[strArray: DESCRIPTOR[messages]]; --if write protected output a message IF writeProtected THEN { DiagFlTapeTTY.PutCR[count: 1];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtPrtctd]];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtEnable]];   DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];   RETURN; };  --grab the bad pages table and store them into an array GrabTheBadPages[];  -- set pass time, pass count time¬ 30*60; totalPassCnt¬ DiagFlTapeOpInt.PassCount;  -- run the test  UNTIL DiagFlTapeOpInt.PassCount= 0 DO    --display the test data    DiagFlTapeOpInt.DisplayTestParameters[      testTitle: mkMenu[confidenceTestTtL],      firstPass: firstPass,      passCountTotal: totalPassCnt,      passCountRemaining: DiagFlTapeOpInt.PassCount,      timePerPass: time];    firstPass¬ FALSE;   --clear the prior soft error count   DiagFlTapeTestControl.SoftErrorsInAPass¬ 0;   DiagFlTapeTestControl.HardReadErrorsInAPass¬ 0;   DiagFlTapeTestControl.RateErrorsInAPass¬ 0;       RunConfidencTest[];       -- exit if no more passes   DiagFlTapeOpInt.PassCount¬ DiagFlTapeOpInt.PassCount- 1;   IF DiagFlTapeOpInt.PassCount=0 THEN   { DiagFlTapeTTY.PutMessage[];     DiagFlTapeTTY.PutSubtest [testName: " "]; --to clear the last subtest     DiagFlTapeTTY.PutCR [count: 1];     DiagFlTapeTTY.PutSubtest [testName: mkOpInt[successFullCompl]];     DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];   }; ENDLOOP; --DiagFlTapeOpInt.PassCount= 0   END; -- of ConfidenceTest-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RunConfidencTest: PROCEDURE = BEGIN subtestSelectArray1:		ARRAY [0..33] OF DiagFlTapeTestRec.Subtest¬ [ 	--Notes: Read ID is not done in the software and therefore is only	--       used in the diagnostics for stream access testing.		--first retention the tape	STretentionTp,			-- (fnshd @ odd strm)	-- check if this is a diagnostic tape	STisDiagTape,			--sec cnt: 1 (fnshd @ evn strm)	-- read streams 6 & 7 to check for reasonable head alignment	STrdVrStrm6A7Tst1,		--sec cnt: 7930 (fnshd @ evn strm)	STrdVrStrm6A7Tst2,		--sec cnt: 7800 (fnshd @ evn strm)	--check if drive accepts all stream pulses before writing on tape	STrdIDStrm12,			--hd cnt: 4 (fnshd @ evn strm)	--format three streams for write tests	STformatStrm4,	STformatStrm5,			-- (fnshd @ evn strm)	--check if the format happened	STrdVrTrk735WithAll1s,		--sec cnt: 1 (fnshd @ evn strm)	--do stream address testing	STrdIDsEvnStrms2to8,		--hd cnt: 24 (fnshd @ evn strm)	STrdIDOdd1To7Strms,		--hd cnt: 12 (fnshd @ odd strm)	--data pattern tests	STwrStrtTrk735With0s,		--hd cnt:  768	STrdVrTrkStrt735With0s,		--sec cnt: 768	STwrStrtTrk759With1s,		--hd cnt:  768	STrdVrTrkStrt759With1s,		--sec cnt: 768	STwrStrtTrk783With5s,		--hd cnt:  768	STrdVrTrkStrt783With5s,		--sec cnt: 768	STwrStrtTrk807WithAs,		--hd cnt:  768	STrdVrTrkStrt807WithAs,		--sec cnt: 768	STwrStrtTrk831With9249,		--hd cnt:  768	STrdVrTrkStrt831With9249,	--sec cnt: 768	STwrStrtTrk855With2492,		--hd cnt:  768	STrdVrTrkStrt855With2492,	--sec cnt: 768	STwrStrtTrk879With4924,		--hd cnt:  768	STrdVrTrkStrt879With4924,	--sec cnt: 768	STwrStrtTrk903With6DB6,		--hd cnt:  768	STrdVrTrkStrt903With6DB6,	--sec cnt: 768--	STwrStrtTrk927WithDB6D,--	STrdVrTrkStrt927WithDB6D,--	STwrStrtTrk951WithB6DB,--	STrdVrTrkStrt951WithB6DB,--	STwrStrtTrk975With1111,--	STrdVrTrkStrt975With1111,	STwrStrtTrk999With2222,		--hd cnt:  768	STrdVrTrkStrt999With2222,	--sec cnt: 768--	STwrStrtTrk1023With4444,--	STrdVrTrkStrt1023With4444,--	STwrStrtTrk1047With8888,--	STrdVrTrkStrt1047With8888,--	STwrStrtTrk1071With7777,--	STrdVrTrkStrt1071With7777,	STwrStrtTrk1095WithEEEE,	--hd cnt:  768	STrdVrTrkStrt1095WithEEEE,	--sec cnt: 768--	STwrStrtTrk1119WithDDDD,--	STrdVrTrkStrt1119WithDDDD,--	STwrStrtTrk1143WithBBBB,--	STrdVrTrkStrt1143WithBBBB,	STwrStrtTrk1167WithDiagDt,	--hd cnt:  1280	STrdVrTrkStrt1167WithDiagDt,	--sec cnt: 1280	STwrTrk735WithDiagDt,		--hd cnt:  32	STrdVrTrk735WithDiagDt		--sec cnt: 32						--Total sectors read: 					--Total headers read: 					--Approx. bits read: 80 million	];	 --Note: by this time we have already read the bad page table DiagFlTapeTestRec.RunTestArray[ 	subtestSelectArray: DESCRIPTOR [subtestSelectArray1]];	     END; -- of RunConfidencTest -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- exercises the tape drive using a scratch tape -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Exerciser:  PUBLIC PROCEDURE = BEGIN time:			CARDINAL; totalPassCnt:		CARDINAL; firstPass:		BOOLEAN¬ TRUE;  DiagFlTapeRunCmdFile.RunningUserCmdFile¬ FALSE; IF DiagFlTapeOpInt.Manufacturing OR DiagFlTapeOpInt.Engineering THEN   DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ TRUE ELSE     DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ FALSE;	 --preset pass count DiagFlTapeOpInt.PassCount¬ 1; --get the pass count DiagFlTapeOpInt.GetTestRequirements[	testTitle:	mkMenu[exerciserTitlE],	needPassCount:	NOT DiagFlTapeOpInt.User			AND NOT DiagFlTapeOpInt.SystemAdmin]; --output a warning on the screen DiagFlTapeTTY.PutCR[count: 1]; DiagFlTapeTTY.PutLine[mkMenu[exerciserDestroys]]; IF NOT DiagFlTapeTTY.GetYesNo[   prompt: mkMenu[stillWishCont],   keepScreenOn: TRUE] THEN RETURN;  -- initialize error checking and get the drive ready --DiagFlTapeTTY.PutCR []; CheckForReady[]; --if write protected output a message IF writeProtected THEN { DiagFlTapeTTY.PutCR[count: 1];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtPrtctd]];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtEnable]];   DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];   RETURN; };  -- set pass time, pass count time¬ 25*60; totalPassCnt¬ DiagFlTapeOpInt.PassCount; -- run the test UNTIL DiagFlTapeOpInt.PassCount= 0 DO   --display the test data   DiagFlTapeOpInt.DisplayTestParameters[      testTitle: mkMenu[exerciserTitlE],      firstPass: firstPass,      passCountTotal: totalPassCnt,      passCountRemaining: DiagFlTapeOpInt.PassCount,      timePerPass: time];  firstPass¬ FALSE;      --clear the prior soft error count   DiagFlTapeTestControl.SoftErrorsInAPass¬ 0;   DiagFlTapeTestControl.HardReadErrorsInAPass¬ 0;   DiagFlTapeTestControl.RateErrorsInAPass¬ 0;       RunExerciser[];       -- exit if no more passes   DiagFlTapeOpInt.PassCount¬ DiagFlTapeOpInt.PassCount- 1;   IF DiagFlTapeOpInt.PassCount=0 THEN   { DiagFlTapeTTY.PutMessage[];     DiagFlTapeTTY.PutSubtest [testName: " "]; --to clear the last subtest     DiagFlTapeTTY.PutCR [count: 1];     DiagFlTapeTTY.PutLine [string: mkOpInt[successFullCompl]];     DiagFlTapeTTY.PutCR [count: 1];     IF NOT DiagFlTapeOpInt.User        AND NOT DiagFlTapeOpInt.SystemAdmin        AND NOT DiagFlTapeOpInt.TechRep THEN     { IF Ec.NumOfSoftErrs= 0 THEN       { DiagFlTapeTTY.PutLine[string: mkMenu[noSoftErrs]];         --DiagFlTapeTTY.PutCR[];         DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];       } ELSE       { DiagFlTapeTTY.PutString[string: mkMenu[softErrsEncnt]];         DiagFlTapeTTY.PutNumber[Ec.NumOfSoftErrs];         DiagFlTapeTTY.PutCR[count: 1];         DiagFlTapeTTY.PutString[string: mkMenu[hardErrsEncnt]];         DiagFlTapeTTY.PutNumber[Ec.NumOfHardReadErrs];         DiagFlTapeTTY.PutCR[count: 1];         IF DiagFlTapeTTY.GetYesNo[           prompt: mkMenu[dsplSoftErrTbl],	   keepScreenOn: TRUE] THEN         { IF Ec.NumOfHardReadErrs> 0 THEN             DiagFlTapeDisplay.ErrorTable[               title: mkDispl[hardRdErrDspL],               errorCount: Ec.NumOfHardReadErrs,	       errorBuff: DESCRIPTOR[Ec.HardReadErrBuffPtr­]];           DiagFlTapeDisplay.ErrorTable[             title: mkDispl[softErrDspL],             errorCount: Ec.NumOfSoftErrs,	     errorBuff: DESCRIPTOR[Ec.SoftErrBuffPtr­],	     errorCountBuff: DESCRIPTOR[Ec.SoftErrCntBuffPtr­]];         } ELSE         { --DiagFlTapeTTY.PutCR[];           DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];         };       };     } ELSE --this is a user or admin or tech rep     { --DiagFlTapeTTY.PutCR[];       DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];     };   }; -- end of DiagFlTapeOpInt.PassCount=0 ENDLOOP; --DiagFlTapeOpInt.PassCount= 0   END; -- of Exerciser-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RunExerciser: PROCEDURE = BEGIN subtestSelectArray:		ARRAY [0..24] OF DiagFlTapeTestRec.Subtest¬ [	STretentionTp,	--format test/track address test	STwrTrk490With0s,		--hd cnt: 32	STformatStrm3,			--hd cnt: 0	STrdVrTrk490ForDtErr,		--sec cnt: 1	STrdIDStrm3,			--hd cnt: 7840	--data test	STwrTrk25With1s,		--hd cnt: 32	STrdVrTrk25WithConstDt,		--sec cnt: 32, hd cnt: 32	STwrTrk50With0s,		--hd cnt: 32	STrdVrTrk50WithConstDt,		--sec cnt: 32	STwrTrk75WithAs,		--hd cnt: 32	STrdVrTrk75WithConstDt,		--sec cnt: 32	STwrTrk100With6s,		--hd cnt: 32	STrdVrTrk100WithConstDt,	--sec cnt: 32	STwrDiaDtAcrossTrks,		--hd cnt: 32	STrdVrDiaDtAcrossTrks,		--sec cnt: 32	STwrDiaDtAcrossStrm,		--hd cnt: 48	STrdVrDiaDtAcrossStrm,		--sec cnt: 32		--stream address test	STwr12TrksEvnStrms,		--hd cnt: 768, track 245+(494)	STwr12TrksOddStrms,		--hd cnt: 768, track 0+(494)	STrd12TrksOddStrms,		--sec cnt: 768	STkillTrk2,			--hd cnt: 128	STrd12TrksEvnStrms,		--sec cnt: 768	STkillTrk245,			--hd cnt: 128		-- write/read/verify test	STwrKnwnDtStrm6Ex,		--hd cnt: 1455	STrdVrKnwnDtStrm6Ex		--sec cnt: 1455					--Total sectors read: 3,184					--Total headers read: 14,543					--Approx. bits read:  20 million	]; DiagFlTapeTestRec.RunTestArray [ 	subtestSelectArray: DESCRIPTOR [subtestSelectArray]];	     END; -- of RunExerciser-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- writes the entire tape with known data-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ WriteKnownData: PUBLIC PROCEDURE = BEGIN time:			CARDINAL; firstPass:		BOOLEAN¬ TRUE; totalPassCnt:		CARDINAL;  DiagFlTapeRunCmdFile.RunningUserCmdFile¬ FALSE; IF DiagFlTapeOpInt.Manufacturing OR DiagFlTapeOpInt.Engineering THEN   DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ TRUE ELSE     DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ FALSE;	 --preset pass count DiagFlTapeOpInt.PassCount¬ 1; --get the pass count DiagFlTapeOpInt.GetTestRequirements[	testTitle:	mkMenu[wrKnwnDtTitlE],	needPassCount:	NOT DiagFlTapeOpInt.User			AND NOT DiagFlTapeOpInt.SystemAdmin			AND NOT DiagFlTapeOpInt.TechRep]; --output a warning on the screen DiagFlTapeTTY.PutCR[count: 1]; DiagFlTapeTTY.PutLine[mkMenu[wrKnwnDtDestroys]]; IF NOT DiagFlTapeTTY.GetYesNo[   prompt: mkMenu[stillWishCont],   keepScreenOn: TRUE] THEN RETURN;  -- initialize error checking and get the drive ready --DiagFlTapeTTY.PutCR []; CheckForReady[];  --if write protected output a message IF writeProtected THEN { DiagFlTapeTTY.PutCR[count: 1];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtPrtctd]];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtEnable]];   DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];   RETURN; };   --grab the bad pages table and store them into an array GrabTheBadPages[]; -- set pass time time¬ 60*90; totalPassCnt¬ DiagFlTapeOpInt.PassCount; -- run the test UNTIL DiagFlTapeOpInt.PassCount= 0 DO    --display the test data    DiagFlTapeOpInt.DisplayTestParameters[      testTitle: mkMenu[wrKnwnDtTitlE],      firstPass: firstPass,      passCountTotal: totalPassCnt,      passCountRemaining: DiagFlTapeOpInt.PassCount,      timePerPass: time];    firstPass¬ FALSE;    --clear the prior soft error count   DiagFlTapeTestControl.SoftErrorsInAPass¬ 0;   DiagFlTapeTestControl.HardReadErrorsInAPass¬ 0;   DiagFlTapeTestControl.RateErrorsInAPass¬ 0;       --now run the test   RunWrKnownData[];       -- exit if no more passes   DiagFlTapeOpInt.PassCount¬ DiagFlTapeOpInt.PassCount- 1;   IF DiagFlTapeOpInt.PassCount=0 THEN   { DiagFlTapeTTY.PutMessage[];     DiagFlTapeTTY.PutSubtest [testName: " "]; --to clear the last subtest     DiagFlTapeTTY.PutCR [count: 1];     DiagFlTapeTTY.PutLine[string: mkMenu[testCompleted]];     DiagFlTapeTTY.PutCR [count: 1];     IF Ec.NumOfSoftErrs= 0 THEN     { DiagFlTapeTTY.PutLine[string: mkMenu[noSoftErrs]];       --DiagFlTapeTTY.PutCR[];       DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];     } ELSE     --there are soft errors     { err: BOOLEAN;       --log bad pages       DiagFlTapeTTY.PutLine[string: mkMenu[loggingBadPages]];       FOR i: CARDINAL IN [0..Ec.NumOfSoftErrs) DO         err¬ MarkPageBad[Ec.SoftErrBuffPtr[i]];         IF err THEN RETURN;       ENDLOOP;       --now display the soft error stuff       DiagFlTapeTTY.PutString[string: mkMenu[softErrsEncnt]];       DiagFlTapeTTY.PutNumber[Ec.NumOfSoftErrs];       DiagFlTapeTTY.PutCR[count: 1];       DiagFlTapeTTY.PutString[string: mkMenu[hardErrsEncnt]];       DiagFlTapeTTY.PutNumber[Ec.NumOfHardReadErrs];       DiagFlTapeTTY.PutCR[count: 1];       IF DiagFlTapeTTY.GetYesNo[         prompt: mkMenu[dsplSoftErrTbl],	 keepScreenOn: TRUE] THEN       { IF Ec.NumOfHardReadErrs> 0 THEN           DiagFlTapeDisplay.ErrorTable[             title: mkDispl[hardRdErrDspL],             errorCount: Ec.NumOfHardReadErrs,	     errorBuff: DESCRIPTOR[Ec.HardReadErrBuffPtr­]];         DiagFlTapeDisplay.ErrorTable[           title: mkDispl[softErrDspL],           errorCount: Ec.NumOfSoftErrs,	   errorBuff: DESCRIPTOR[Ec.SoftErrBuffPtr­],	   errorCountBuff: DESCRIPTOR[Ec.SoftErrCntBuffPtr­]];       } ELSE       { --DiagFlTapeTTY.PutCR[];         DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];       };     };   }; ENDLOOP; --DiagFlTapeOpInt.PassCount= 0  END; -- of WriteKnownData-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RunWrKnownData: PROCEDURE = BEGIN subtestSelectArray:		ARRAY [0..23] OF DiagFlTapeTestRec.Subtest¬ [	STretentionTp,	STwrKnwnDtStrm1,	STretentionTp,	STwrKnwnDtStrm2,	STretentionTp,	STwrKnwnDtStrm3,	STretentionTp,	STwrKnwnDtStrm4,	STretentionTp,	STwrKnwnDtStrm5,	STretentionTp,	STwrKnwnDtStrm6,	STretentionTp,	STwrKnwnDtStrm7,	STretentionTp,	STwrKnwnDtStrm8,	STretentionTp,	STwrKnwnDtStrm9,	STretentionTp,	STwrKnwnDtStrm10,	STretentionTp,	STwrKnwnDtStrm11,	STretentionTp,	STwrKnwnDtStrm12	]; DiagFlTapeTestRec.RunTestArray [ 	subtestSelectArray: DESCRIPTOR [subtestSelectArray]];	  END; --of RunWrKnownData -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- reads the entire tape to look for soft and hard read errors -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SurfaceVerification: PUBLIC PROCEDURE = BEGIN time:			CARDINAL; totalPassCnt:		CARDINAL; firstPass:		BOOLEAN¬ TRUE; quit:			BOOLEAN¬ FALSE; badSector:		LONG CARDINAL¬ FloppyTape.nullSectorNumber;  DiagFlTapeRunCmdFile.RunningUserCmdFile¬ FALSE; DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ FALSE;	 --preset pass count DiagFlTapeOpInt.PassCount¬ 1;  --get the pass count DiagFlTapeOpInt.GetTestRequirements[	testTitle:	mkMenu[surfaceVerTitlE],	needPassCount:	NOT DiagFlTapeOpInt.User			AND NOT DiagFlTapeOpInt.SystemAdmin			AND NOT DiagFlTapeOpInt.TechRep];   -- initialize error checking and get the drive ready --DiagFlTapeTTY.PutCR []; CheckForReady[];  -- set pass time, pass count time¬ 25*60; totalPassCnt¬ DiagFlTapeOpInt.PassCount;   --grab the bad pages table and store them into an array GrabTheBadPages[];  -- run the test UNTIL DiagFlTapeOpInt.PassCount= 0 DO    --display the test data    DiagFlTapeOpInt.DisplayTestParameters[      testTitle: mkMenu[surfaceVerTitlE],      firstPass: firstPass,      passCountTotal: totalPassCnt,      passCountRemaining: DiagFlTapeOpInt.PassCount,      timePerPass: time];    firstPass¬ FALSE;       --now run the test   RunSurfaceVerify[];       -- exit if no more passes   DiagFlTapeOpInt.PassCount¬ DiagFlTapeOpInt.PassCount- 1;   IF DiagFlTapeOpInt.PassCount=0 THEN   { DiagFlTapeTTY.PutMessage[];     DiagFlTapeTTY.PutSubtest [testName: " "]; --to clear the last subtest     DiagFlTapeTTY.PutCR [count: 1];     DiagFlTapeTTY.PutLine [string: mkMenu[testCompleted]];     DiagFlTapeTTY.PutCR [count: 1];     IF Ec.NumOfSoftErrs= 0 THEN     { DiagFlTapeTTY.PutLine[string: mkMenu[noSoftErrs]];       --DiagFlTapeTTY.PutCR[];       DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];     } ELSE     { DiagFlTapeTTY.PutString[string: mkMenu[softErrsEncnt]];       DiagFlTapeTTY.PutNumber[Ec.NumOfSoftErrs];       DiagFlTapeTTY.PutCR[count: 1];       DiagFlTapeTTY.PutString[string: mkMenu[hardErrsEncnt]];       DiagFlTapeTTY.PutNumber[Ec.NumOfHardReadErrs];       DiagFlTapeTTY.PutCR[count: 1];       IF DiagFlTapeTTY.GetYesNo[         prompt: mkMenu[dsplSoftErrTbl],	 keepScreenOn: TRUE] THEN       { IF Ec.NumOfHardReadErrs> 0 THEN           DiagFlTapeDisplay.ErrorTable[             title: mkDispl[hardRdErrDspL],             errorCount: Ec.NumOfHardReadErrs,	     errorBuff: DESCRIPTOR[Ec.HardReadErrBuffPtr­]];         DiagFlTapeDisplay.ErrorTable[           title: mkDispl[softErrDspL],           errorCount: Ec.NumOfSoftErrs,	   errorBuff: DESCRIPTOR[Ec.SoftErrBuffPtr­],	   errorCountBuff: DESCRIPTOR[Ec.SoftErrCntBuffPtr­]];       } ELSE       { --DiagFlTapeTTY.PutCR[];         DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];       };     };   }; ENDLOOP; --DiagFlTapeOpInt.PassCount= 0   END; -- of SurfaceVerification-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RunSurfaceVerify: PROCEDURE = BEGIN subtestSelectArray: ARRAY [0..12] OF DiagFlTapeTestRec.Subtest¬ [	STretentionTp,	STsurfVrStrm1,	STsurfVrStrm2,	STsurfVrStrm3,	STsurfVrStrm4,	STsurfVrStrm5,	STsurfVrStrm6,	STsurfVrStrm7,	STsurfVrStrm8,	STsurfVrStrm9,	STsurfVrStrm10,	STsurfVrStrm11,	STsurfVrStrm12	];	 DiagFlTapeTestRec.RunTestArray [ 	subtestSelectArray: DESCRIPTOR [subtestSelectArray]];  END; --of RunSurfaceVerify -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- reads the entire tape with known data -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ReadKnownData: PUBLIC PROCEDURE = BEGIN time:			CARDINAL; totalPassCnt:		CARDINAL; firstPass:		BOOLEAN¬ TRUE;  DiagFlTapeRunCmdFile.RunningUserCmdFile¬ FALSE; IF DiagFlTapeOpInt.Manufacturing OR DiagFlTapeOpInt.Engineering THEN   DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ TRUE ELSE     DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ FALSE; --get the pass count DiagFlTapeOpInt.GetTestRequirements[		testTitle:		mkMenu[rdKnwnDtTitlE],		needPassCount:		TRUE];  -- initialize error checking and get the drive ready --DiagFlTapeTTY.PutCR []; CheckForReady[]; -- set pass time, pass counttime¬ 60*60; totalPassCnt¬ DiagFlTapeOpInt.PassCount; --grab the bad pages table and store them into an array GrabTheBadPages[];   -- run the test  UNTIL DiagFlTapeOpInt.PassCount= 0 DO    --display the test data    DiagFlTapeOpInt.DisplayTestParameters[      testTitle: mkMenu[rdKnwnDtTitlE],      firstPass: firstPass,      passCountTotal: totalPassCnt,      passCountRemaining: DiagFlTapeOpInt.PassCount,      timePerPass: time];    firstPass¬ FALSE;       --clear the prior soft error count   DiagFlTapeTestControl.SoftErrorsInAPass¬ 0;   DiagFlTapeTestControl.HardReadErrorsInAPass¬ 0;   DiagFlTapeTestControl.RateErrorsInAPass¬ 0;   --now run the test   RunRdKnownData[];       -- exit if no more passes   DiagFlTapeOpInt.PassCount¬ DiagFlTapeOpInt.PassCount- 1;   IF DiagFlTapeOpInt.PassCount=0 THEN   { DiagFlTapeTTY.PutMessage[];     DiagFlTapeTTY.PutSubtest [testName: " "]; --to clear the last subtest     DiagFlTapeTTY.PutCR [count: 1];     DiagFlTapeTTY.PutLine [string: mkMenu[testCompleted]];     DiagFlTapeTTY.PutCR [count: 1];     IF Ec.NumOfSoftErrs= 0 THEN     { DiagFlTapeTTY.PutLine[string: mkMenu[noSoftErrs]];       --DiagFlTapeTTY.PutCR[];       DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];     } ELSE     { DiagFlTapeTTY.PutString[string: mkMenu[softErrsEncnt]];       DiagFlTapeTTY.PutNumber[Ec.NumOfSoftErrs];       DiagFlTapeTTY.PutCR[count: 1];       DiagFlTapeTTY.PutString[string: mkMenu[hardErrsEncnt]];       DiagFlTapeTTY.PutNumber[Ec.NumOfHardReadErrs];       DiagFlTapeTTY.PutCR[count: 1];       IF DiagFlTapeTTY.GetYesNo[         prompt: mkMenu[dsplSoftErrTbl],	 keepScreenOn: TRUE] THEN       { IF Ec.NumOfHardReadErrs> 0 THEN           DiagFlTapeDisplay.ErrorTable[             title: mkDispl[hardRdErrDspL],             errorCount: Ec.NumOfHardReadErrs,	     errorBuff: DESCRIPTOR[Ec.HardReadErrBuffPtr­]];         DiagFlTapeDisplay.ErrorTable[           title: mkDispl[softErrDspL],           errorCount: Ec.NumOfSoftErrs,	   errorBuff: DESCRIPTOR[Ec.SoftErrBuffPtr­],	   errorCountBuff: DESCRIPTOR[Ec.SoftErrCntBuffPtr­]];       } ELSE       { --DiagFlTapeTTY.PutCR[];         DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];       };     };   }; ENDLOOP; --DiagFlTapeOpInt.PassCount= 0    END; -- of ReadKnownData-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RunRdKnownData: PROCEDURE = BEGIN subtestSelectArray:		ARRAY [0..15] OF DiagFlTapeTestRec.Subtest¬ [	STretentionTp,	STrdVrKnwnDtStrm1,	STrdVrKnwnDtStrm2,	STrdVrKnwnDtStrm3,	STretentionTp,	STrdVrKnwnDtStrm4,	STrdVrKnwnDtStrm5,	STrdVrKnwnDtStrm6,	STretentionTp,	STrdVrKnwnDtStrm7,	STrdVrKnwnDtStrm8,	STrdVrKnwnDtStrm9,	STretentionTp,	STrdVrKnwnDtStrm10,	STrdVrKnwnDtStrm11,	STrdVrKnwnDtStrm12	]; DiagFlTapeTestRec.RunTestArray [ 	subtestSelectArray: DESCRIPTOR [subtestSelectArray]];  END; --of RunRdKnownData -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- exercises the tape drive using a scratch tape -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ManufCheckOut:  PUBLIC PROCEDURE = BEGIN time:			CARDINAL; totalPassCnt:		CARDINAL; firstPass:		BOOLEAN¬ TRUE;  DiagFlTapeRunCmdFile.RunningUserCmdFile¬ FALSE; DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ TRUE;	 --preset pass count DiagFlTapeOpInt.PassCount¬ 1; --get the pass count IF DiagFlTapeOpInt.Engineering THEN   DiagFlTapeOpInt.GetTestRequirements[		testTitle:	mkMenu[manufChkOutTitlE],		needPassCount:	TRUE] ELSE     DiagFlTapeOpInt.GetTestRequirements[		testTitle:	mkMenu[manufChkOutTitlE]]; -- initialize error checking and get the drive ready --DiagFlTapeTTY.PutCR []; CheckForReady[]; --if write protected output a message IF writeProtected THEN { DiagFlTapeTTY.PutCR[count: 1];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtPrtctd]];   DiagFlTapeTTY.PutLine[mkMenu[tapeWrtEnable]];   DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];   RETURN; };  -- set pass time, pass count time¬ 25*60; totalPassCnt¬ DiagFlTapeOpInt.PassCount;  -- run the test  UNTIL DiagFlTapeOpInt.PassCount= 0 DO    --display the test data    DiagFlTapeOpInt.DisplayTestParameters[      testTitle: mkMenu[manufChkOutTitlE],      firstPass: firstPass,      passCountTotal: totalPassCnt,      passCountRemaining: DiagFlTapeOpInt.PassCount,      timePerPass: time];    firstPass¬ FALSE;   --clear the prior soft error count   DiagFlTapeTestControl.HardReadErrorsInAPass¬ 0;   DiagFlTapeTestControl.SoftErrorsInAPass¬ 0;   DiagFlTapeTestControl.RateErrorsInAPass¬ 0;       RunManufCheckOut[];       -- exit if no more passes   DiagFlTapeOpInt.PassCount¬ DiagFlTapeOpInt.PassCount- 1;   IF DiagFlTapeOpInt.PassCount=0 THEN   { DiagFlTapeTTY.PutMessage[];     DiagFlTapeTTY.PutSubtest [testName: " "]; --to clear the last subtest     DiagFlTapeTTY.PutCR [count: 1];     DiagFlTapeTTY.PutLine [string: mkOpInt[successFullCompl]];     DiagFlTapeTTY.PutCR [count: 1];     IF Ec.NumOfSoftErrs= 0 THEN     { DiagFlTapeTTY.PutLine[string: mkMenu[noSoftErrs]];       --DiagFlTapeTTY.PutCR[];       DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE];     } ELSE DisplaySummary[];   }; ENDLOOP; --DiagFlTapeOpInt.PassCount= 0   END; -- of ManufCheckOut-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RunManufCheckOut: PROCEDURE = BEGIN subtestSelectArray:		ARRAY [0..24] OF DiagFlTapeTestRec.Subtest¬ [	STretentionTp,	--format test/track address test	STwrTrk490With0s,		--*	STformatStrm3,			--*	STrdVrTrk490ForDtErr,		--*	STrdIDStrm3,			--*	--data test	STwrTrk25With1s,		--*	STrdVrTrk25WithConstDt,		--*	STwrTrk50With0s,		--*	STrdVrTrk50WithConstDt,		--*	STwrTrk75WithAs,		--*	STrdVrTrk75WithConstDt,		--*	STwrTrk100With6s,		--*	STrdVrTrk100WithConstDt,	--*	STwrDiaDtAcrossTrks,		--*	STrdVrDiaDtAcrossTrks,		--*	STwrDiaDtAcrossStrm,		--*	STrdVrDiaDtAcrossStrm,		--*		--stream address test	STwr12TrksEvnStrms,		--*track 245+(494)	STwr12TrksOddStrms,		--*track 2+(494)	STrd12TrksOddStrms,		--*	STkillTrk2,			--*	STrd12TrksEvnStrms,		--*	STkillTrk245,			--*		-- write/read/verify test	STwrKnwnDtStrm6Ex,		--*	STrdVrKnwnDtStrm6Ex		--*	]; DiagFlTapeTestRec.RunTestArray [ 	subtestSelectArray: DESCRIPTOR [subtestSelectArray]];	     END; -- of RunManufCheckOut -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- special display for manufacturing -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayError: PUBLIC PROCEDURE [	cmdIdx: CARDINAL¬ 0, 	command: DiagFlTapeCmdDes.Command] = BEGIN DiagFlTapeTTY.PutMessage[]; --to clear the soft error stuff DiagFlTapeTTY.PutCR[count: 1]; DiagFlTapeTTY.PutLine[mkDispl[hardErrDetctd]]; --now check for my own genertated errors IF Io.IoCPA[cmdIdx].cmdTimedOut THEN   DiagFlTapeTTY.PutLine[mkDispl[cmdTimedOut]] ELSE IF Io.IoCPA[cmdIdx].rtrndSectorCntError THEN   DiagFlTapeTTY.PutLine[mkDispl[rtrndSecCntErrDtctd]] ELSE IF Io.IoCPA[cmdIdx].rtrndTrackCntError THEN   DiagFlTapeTTY.PutLine[mkDispl[rtrndTrkCntErrDtctd]] ELSE IF Io.IoCPA[cmdIdx].dataVerifyError THEN   DiagFlTapeTTY.PutLine[mkDispl[dataCompareErr]] ELSE IF Io.IoCPA[cmdIdx].dataNotWrittenError THEN   DiagFlTapeTTY.PutLine[mkDispl[dataNotWritten]] ELSE IF Io.IoCPA[cmdIdx].iDVerifyError THEN   DiagFlTapeTTY.PutLine[mkDispl[iDCompareErr]] ELSE IF Io.IoCPA[cmdIdx].errorCode= tooManySubTestSoftErrs THEN   DiagFlTapeTTY.PutLine[mkDispl[excsSftErrsInSbTs]] ELSE IF Io.IoCPA[cmdIdx].errorCode= tooManySubTestHardReadErrs THEN   DiagFlTapeTTY.PutLine[mkDispl[excsHrdRdErrsInSbTs]] ELSE IF Io.IoCPA[cmdIdx].errorCode= tooManyPassSoftErrs THEN   DiagFlTapeTTY.PutLine[mkDispl[excsSftErrsInPss]] ELSE IF Io.IoCPA[cmdIdx].errorCode= tooManyPassHardReadErrs THEN   DiagFlTapeTTY.PutLine[mkDispl[excsHrdRdErrsInPss]] ELSE IF Io.IoCPA[cmdIdx].errorCode= retentionErr THEN   DiagFlTapeTTY.PutLine[mkDispl[retnsnFailed]] ELSE   --display the status   IF Cd.CmdDescriptArray[command].rtrnsIOStatus THEN   { DiagFlTapeTTY.PutString[mkDispl[returnedStatuS]];     SELECT Io.IoCPA[cmdIdx].rtndStatus FROM       inProgress=> DiagFlTapeTTY.PutLine[mkDispl[inProgress]];       goodCompletion=> DiagFlTapeTTY.PutLine[mkDispl[goodCompletion]];       diskChange=> DiagFlTapeTTY.PutLine[mkDispl[diskChange]];       notReady=> DiagFlTapeTTY.PutLine[mkDispl[notReady]];       cylinderError=> DiagFlTapeTTY.PutLine[mkDispl[cylinderError]];       deletedData=> DiagFlTapeTTY.PutLine[mkDispl[deletedData]];       recordNotFound=> DiagFlTapeTTY.PutLine[mkDispl[recordNotFound]];       headerError=> DiagFlTapeTTY.PutLine[mkDispl[headerError]];       dataError=> DiagFlTapeTTY.PutLine[mkDispl[dataError]];       dataLost=> DiagFlTapeTTY.PutLine[mkDispl[dataLost]];       writeFault=> DiagFlTapeTTY.PutLine[mkDispl[writeFault]];       memoryError=> DiagFlTapeTTY.PutLine[mkDispl[memoryError]];       invalidOperation => DiagFlTapeTTY.PutLine[mkDispl[invalidOperation]];       aborted=> DiagFlTapeTTY.PutLine[mkDispl[aborted]];       otherError=> DiagFlTapeTTY.PutLine[mkDispl[otherError]];     ENDCASE;   }; DisplaySummary[]; SIGNAL DiagFlTapeTestSelect.Exit;  END; --of DisplayError -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- special display for manufacturing -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplaySummary: PROCEDURE = BEGIN  --display total number of soft errors encountered DiagFlTapeTTY.PutCR[count: 1]; DiagFlTapeTTY.PutString[string: mkMenu[totlSoftErrsEncnt]]; DiagFlTapeTTY.PutNumber[Ec.NumOfSoftErrs]; --display total number of hard read errors encountered DiagFlTapeTTY.PutCR[count: 1]; DiagFlTapeTTY.PutString[string: mkMenu[totlHardRdErrsEncnt]]; DiagFlTapeTTY.PutNumber[Ec.NumOfHardReadErrs]; --display total number of read ID commands IF DiagFlTapeLog.SummLogArray[readID].commandsExecuted>0 THEN { DiagFlTapeTTY.PutCR[count: 1];   DiagFlTapeTTY.PutString[string: mkMenu[totlRdIDCmds]];   DiagFlTapeTTY.PutLongNumber[	number: DiagFlTapeLog.SummLogArray[readID].commandsExecuted,	fillSpaceWith:	'.]; }; --display total number of sectors written IF DiagFlTapeLog.SummLogArray[wrSector].sectorsXferedCount>0 THEN { DiagFlTapeTTY.PutCR[count: 1];   DiagFlTapeTTY.PutString[string: mkMenu[totlSectorsWritten]];   DiagFlTapeTTY.PutLongNumber[	number: DiagFlTapeLog.SummLogArray[wrSector].sectorsXferedCount,	fillSpaceWith:	'.]; }; --display total number of read sector commands IF DiagFlTapeLog.SummLogArray[rdSector].sectorsXferedCount>0 THEN { DiagFlTapeTTY.PutCR[count: 1];   DiagFlTapeTTY.PutString[string: mkMenu[totlSectorsRead]];   DiagFlTapeTTY.PutLongNumber[        number: DiagFlTapeLog.SummLogArray[rdSector].sectorsXferedCount,	fillSpaceWith:	'.]; }; DiagFlTapeTTY.PutCR[count: 1]; IF Ec.NumOfHardReadErrs= 0 AND Ec.NumOfSoftErrs= 0 THEN   DiagFlTapeTTY.ProceedOnInput[keepScreenOn: TRUE] ELSE { IF DiagFlTapeTTY.GetYesNo[     prompt: mkMenu[dsplSoftErrTbl],     keepScreenOn: TRUE] THEN   { IF Ec.NumOfHardReadErrs> 0 THEN       DiagFlTapeDisplay.ErrorTable[             title: mkDispl[hardRdErrDspL],             errorCount: Ec.NumOfHardReadErrs,	     errorBuff: DESCRIPTOR[Ec.HardReadErrBuffPtr­]];       DiagFlTapeDisplay.ErrorTable[           title: mkDispl[softErrDspL],           errorCount: Ec.NumOfSoftErrs,	   errorBuff: DESCRIPTOR[Ec.SoftErrBuffPtr­],	   errorCountBuff: DESCRIPTOR[Ec.SoftErrCntBuffPtr­]];   }; }; END; -- of DisplaySummary -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- read the root page and the bad pages -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ReadBadPageTable: PUBLIC PROCEDURE  = BEGIN DiagFlTapeRunCmdFile.RunningUserCmdFile¬ FALSE; DiagFlTapeTestControl.DisplaySummaryOnHardErr¬ FALSE; CheckForReady[]; DiagFlTapeTestRec.RunSubtest[displayTitle: FALSE, subtest: STrdBadPgTable]; IF DiagFlTapeCmds.LastReadStatus# goodCompletion THEN  { --DiagFlTapeTTY.PutCR[];   DiagFlTapeTTY.PutLine[mkMenu[canNotRdBadPgTbl]];   DiagFlTapeOpInt.CallService[fruCode: 2827]; };  END; -- of ReadBadPageTable -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ END... --of DiagFlTapeTestsImpl   LOG  7-Mar-88 13:31:12 JMA: modified CheckForReady proc.10-Mar-88 13:53:42 JMA: added extra error codes.23-Aug-88  8:08:17 PJT: added NoOp subtest to check for write protect23-Aug-88  8:27:40 PJT: added RateErrorsInAPass¬ 0
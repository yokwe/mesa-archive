-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. ---- File: DiagFlTapeBuffImpl.mesa -- Edited by: JMA 10-Feb-88 16:51:03-- DIRECTORY DiagFlTapeCmds		USING	[MinSector, MaxSector,				 MinHead, MaxHead,				 MinTrack, MaxTrack], Environment		USING	[Byte], FloppyDiskFace		USING	[DiskAddress], Inline			USING	[LowByte, HighByte, LowHalf, BITSHIFT], Time			USING	[Current], DiagFlTapeBuff		USING	[dataType]; DiagFlTapeBuffImpl: PROGRAM    IMPORTS	DiagFlTapeCmds,	Inline,	Time    EXPORTS	DiagFlTapeBuff =BEGIN    OPEN	Io: DiagFlTapeCmds; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- clears a buffer to all 0's  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ZeroBuffer:	PUBLIC PROCEDURE [	wordCount: CARDINAL,	ptr: LONG POINTER TO ARRAY OF WORD¬ NIL]  = BEGIN  IF ptr= NIL THEN RETURN;  FOR wordptr: CARDINAL IN [0..wordCount) DO   ptr­[wordptr]¬ 0; ENDLOOP;  END; --ZeroBuffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to compare read data against the written data -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CompareData: PUBLIC PROCEDURE [	writtenDataPtr:	LONG POINTER TO ARRAY OF WORD¬ NIL,	kindOfData:	DiagFlTapeBuff.dataType¬ constant,	  data:		CARDINAL¬ 0,  --use when kindOfData= constant(not used)	  unit:		CARDINAL¬ 0,  --use when kindOfData= diagnostic	  cylinder:	CARDINAL¬ 0,  --use when kindOfData= diagnostic	  head:		CARDINAL¬ 0,  --use when kindOfData= diagnostic	  sector:	CARDINAL¬ 0,  --use when kindOfData= diagnostic	readDataPtr:	LONG POINTER TO ARRAY OF WORD¬ NIL,	wordCount:	CARDINAL¬ 0]   RETURNS [	dataError:	BOOLEAN¬ FALSE,	wordIndex:	CARDINAL¬0,	expected:	CARDINAL¬0,	observed:	CARDINAL¬0] = BEGIN  IF kindOfData= unknown THEN RETURN; IF kindOfData= constant THEN { expected¬ readDataPtr­[wordIndex];   UNTIL wordIndex>= wordCount OR dataError DO     observed¬ readDataPtr­[wordIndex];     IF observed# expected THEN dataError¬ TRUE ELSE       wordIndex¬ wordIndex+1;   ENDLOOP;   IF dataError THEN RETURN; };  IF kindOfData= useWrBuff THEN { UNTIL wordIndex>= wordCount OR dataError DO     observed¬ readDataPtr­[wordIndex];     expected¬ writtenDataPtr­[wordIndex];     IF observed# expected THEN dataError¬ TRUE ELSE       wordIndex¬ wordIndex+1;   ENDLOOP;   IF dataError THEN RETURN; }; IF kindOfData= incrementing THEN { bPtr: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte¬     LOOPHOLE[readDataPtr];   bIdx: CARDINAL¬ 0;   byte: Environment.Byte¬ 0;   UNTIL wordIndex>= wordCount OR dataError DO     observed¬ readDataPtr­[wordIndex];     IF Inline.HighByte[observed]# byte THEN     { dataError¬ TRUE;     } ELSE --high byte is ok       { byte¬ byte+ 1;         IF Inline.LowByte[observed]# byte THEN         { dataError¬ TRUE;           byte¬ byte- 1; --point to high byte again         } ELSE --low byte is ok           { IF byte= 255 THEN byte¬ 0 ELSE byte¬ byte+ 1;	     wordIndex¬ wordIndex+1;	   };       };   ENDLOOP;   IF dataError THEN   { expected¬ byte;     expected¬ Inline.BITSHIFT[expected, 8];     byte¬ byte+ 1;     expected¬ expected+ byte;     RETURN;   }; }; IF kindOfData= random THEN { wdx: CARDINAL;   r: CARDINAL;   UNTIL wordIndex>= wordCount OR dataError DO     wdx¬ 0;     expected¬ r¬  readDataPtr­[wordIndex];     UNTIL wdx= 256 OR dataError DO       observed¬ readDataPtr­[wordIndex];       IF observed# expected THEN dataError¬ TRUE ELSE       { expected¬ expected+ wdx+ r;         wdx¬ wdx+ 1;	 wordIndex¬ wordIndex+ 1;       };     ENDLOOP;     IF dataError THEN RETURN;   ENDLOOP; }; IF kindOfData= diagnostic THEN { widx: CARDINAL;   bPtr: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte¬     LOOPHOLE[readDataPtr];   bIdx: CARDINAL¬ 0;   byte: Environment.Byte¬ 0;   UNTIL wordIndex>= wordCount OR dataError DO     observed¬ readDataPtr­[wordIndex];     expected¬ unit;     IF observed# expected THEN     { dataError¬ TRUE;       RETURN;     } ELSE wordIndex¬ wordIndex+1;     observed¬ readDataPtr­[wordIndex];     expected¬ cylinder;     IF observed# expected THEN     { dataError¬ TRUE;       RETURN;     } ELSE wordIndex¬ wordIndex+1;     observed¬ readDataPtr­[wordIndex];     expected¬ head;     IF observed# expected THEN     { dataError¬ TRUE;       RETURN;     } ELSE wordIndex¬ wordIndex+1;     observed¬ readDataPtr­[wordIndex];     expected¬ sector;     IF observed# expected THEN     { dataError¬ TRUE;       RETURN;     } ELSE wordIndex¬ wordIndex+1;          widx¬ 4;     byte¬ 8;     UNTIL widx>= 256 OR dataError DO       observed¬ readDataPtr­[wordIndex];       IF Inline.HighByte[observed]# byte THEN       { dataError¬ TRUE;       } ELSE --high byte is ok         { byte¬ byte+ 1;           IF Inline.LowByte[observed]# byte THEN           { dataError¬ TRUE;             byte¬ byte- 1; --point to high byte again           } ELSE --low byte is ok             { IF byte= 255 THEN byte¬ 0 ELSE byte¬ byte+ 1;	       widx¬ widx+1;	       wordIndex¬ wordIndex+1;	     };         };     ENDLOOP;     IF dataError THEN     { expected¬ byte;       expected¬ Inline.BITSHIFT[expected, 8];       byte¬ byte+ 1;       expected¬ expected+ byte;       RETURN;     };     sector¬ sector+ 1;     IF sector> Io.MaxSector THEN     { sector¬ Io.MinSector;       head¬ head+ 1;       IF head> Io.MaxHead THEN       { head¬ Io.MinHead;         cylinder¬ cylinder+ 1;         IF cylinder> Io.MaxTrack THEN         { cylinder¬ Io.MinTrack;           unit¬ unit+ 1;         };       };     };   ENDLOOP };  END; --CompareData -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to compare read data against the written data -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CompareID: PUBLIC PROCEDURE [	ptrToID:	LONG POINTER TO ARRAY OF WORD¬ NIL,	track:		CARDINAL¬ 0]   RETURNS [	idError:	BOOLEAN¬ FALSE,	byteIndex:	CARDINAL¬0] = BEGIN   -- TYPE taken from FloppyIOFaceDove.mesa   RecordID : TYPE = RECORD [    address : FloppyDiskFace.DiskAddress,    sectorLength : CARDINAL,    MachineDependentBytes : PACKED ARRAY [1..4] OF Environment.Byte];     buffData: LONG POINTER TO RecordID ¬ LOOPHOLE[ptrToID];     --check track number IF track # buffData.address.cylinder THEN   {idError¬ TRUE; RETURN };    byteIndex¬ byteIndex+1; --check head number IF buffData.address.head # 0 THEN   {idError¬ TRUE; RETURN };    byteIndex¬ byteIndex+1; --check sector address IF buffData.address.sector NOT IN [1..32] THEN   {idError¬ TRUE; RETURN };      byteIndex¬ byteIndex+1; --check sector size IF  buffData.sectorLength # 256 THEN idError¬ TRUE;   END; --CompareID -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to generate data in a given buffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~GenDataBuffer: PUBLIC PROCEDURE [	data: CARDINAL¬ 0,	kindOfData: DiagFlTapeBuff.dataType¬ constant,	  unit: CARDINAL¬ 0,	  --use when kindOfData= diagnostic	  cylinder: CARDINAL¬ 0,  --use when kindOfData= diagnostic	  head: CARDINAL¬ 0,	  --use when kindOfData= diagnostic	  sector: CARDINAL¬ 0,	  --use when kindOfData= diagnostic	wordCount: CARDINAL,	ptr: LONG POINTER TO ARRAY OF WORD¬ NIL] = BEGIN idx:	CARDINAL¬ 0; --word index bCnt:	CARDINAL¬ wordCount*2; --byte count bIdx:	CARDINAL¬ 0; --byte index bPtr:	LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte¬ LOOPHOLE[ptr]; ones:	CARDINAL¬ 255;  IF ptr= NIL THEN RETURN;  IF kindOfData= diagnostic THEN { cntToGetTo: CARDINAL;   sctrsDn: CARDINAL¬ 0;   UNTIL idx>= wordCount DO     ptr­[idx]¬ unit;     idx¬ idx+ 1;     ptr­[idx]¬ cylinder;     idx¬ idx+ 1;     ptr­[idx]¬ head;     idx¬ idx+ 1;     ptr­[idx]¬ sector;     idx¬ idx+ 253; --point to the next page     bIdx¬ (sctrsDn*512)+ 8; --point to the first data byte     cntToGetTo¬ (sctrsDn+1)*512; --point to the first data byte     UNTIL bIdx= cntToGetTo DO       bPtr­[bIdx]¬ Inline.LowByte[bIdx];       bIdx¬ bIdx+ 1;     ENDLOOP;     -- increments words (takes half the time of doing bytes     sctrsDn¬ sctrsDn+ 1;     sector¬ sector+ 1;     IF sector> Io.MaxSector THEN     { sector¬ Io.MinSector;       head¬ head+ 1;       IF head> Io.MaxHead THEN       { head¬ Io.MinHead;         cylinder¬ cylinder+ 1;         IF cylinder> Io.MaxTrack THEN         { cylinder¬ Io.MinTrack;           unit¬ unit+ 1;         };       };     };   ENDLOOP; --UNTIL idx>= wordCount } ELSE IF kindOfData= constant THEN   { FOR idx IN [0..wordCount) DO       ptr­[idx]¬ data;     ENDLOOP;   } ELSE IF kindOfData= incrementing THEN     { UNTIL bIdx= bCnt DO         bPtr­[bIdx]¬ Inline.LowByte[bIdx];         bIdx¬ bIdx+ 1;       ENDLOOP;     } ELSE IF kindOfData= random THEN       { r, rc: CARDINAL¬ Inline.LowHalf[Time.Current[]];	 cnt: CARDINAL;         IF r= 0 THEN r¬ rc¬ 21845;         UNTIL idx= wordCount DO	   cnt¬ 0;	   r¬ rc;           UNTIL cnt= 256 DO             ptr­[idx]¬ rc;             rc¬  rc+ cnt+ r;             cnt¬ cnt+ 1;             idx¬ idx+ 1;           ENDLOOP;         ENDLOOP;       }; END; --GenDataBuffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  END... --of DiagFlTapeBuffImpl.mesa Log10-Feb-88 15:00:16 JMA: used Dove byte format in CompareID proc.  	 
-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. ---- File: DiagFlTapeMkIOCmdImpl.mesa-- Edited by: JMA 18-Feb-88 16:09:02-- DIRECTORY DiagFlTapeMkIOCmd	USING	[MkIOCmd];   DiagFlTapeMkIOCmdImpl: PROGRAM    EXPORTS	DiagFlTapeMkIOCmd = BEGIN     mkIOCmd: PUBLIC LONG POINTER TO ARRAY DiagFlTapeMkIOCmd.MkIOCmd OF LONG STRING; iOCmdMsgs: ARRAY DiagFlTapeMkIOCmd.MkIOCmd OF LONG STRING¬ [   allreadyInLoop:	"Already in a loop.",   allreadyLoggingErrs:	"Already logging errors.",   allreadyTracingCmds:	"Already tracing commands.",   clearDiskChange:	"ClearTapeChange;",   clearDiskChangeExpl:	"Clears the Tape Changed status bit in the controller.",   clearLog:		"ClearLog;",   clearLogExpl:	"Clears the error and the summary log.",   clearTrace:		"ClearTrace;",   clearTraceExpl:	"Clears the trace table.",   cmdsAre:		"THE COMMANDS ARE:",   command:		"COMMAND: ",   commandExecuted:	"Command executed: ",   commandTimedOut:	"Command timed out.",   constant:		"constant",   constantExpl:	"1= constant data is used.",   dataErrDetected:	"Data error detected.",   dataType:		"data type: ",   delayCnt:		"delay count: ",   density:		"Density: ",   diagnostic:		"diagnostic",   diagnosticExpl:	"4= special diagnostic data is used.",   displayContext:	"DisplayContext;",   displayContextExpl:	"Displays the device environment.",   displayID:		"DisplayID;",   displayIDExpl:	"Displays the last read ID.",   displayLog:		"DisplayLog;",   displayLogExpl:	"Displays the error log.",   displayRdData:	"DisplayReadData;",   displayRdDataExpl:	"Displays the last read data.",   displayStatus:	"DisplayStatus;",   displayStatusExpl:	"Displays the last read status.",   displayTrace:	"DisplayTrace;",   displayTraceExpl:	"Displays the trace table.",   displayWrData:	"DisplayWriteData;",   displayWrDataExpl:	"Displays the last written data;",   double:		"double",   endLoop:		"EndLoop;",   endLoopExpl:		"Defines the end of a loop.",   endOfFile:		"RunCommandFile;",   endOfFileExpl:	"Starts executing the command file.",   endPlusOrMin:	")",   enter1To10000:	"Enter from 1 to 10000.",   enterCmd1rst:	"Enter the command first.",   even:		"even",   fillByte:		"hex data byte: ",   fillByteExpl:	"The hex data byte which will be written.",   format:		"Type of format: "L,   formatTrack:		"FormatTrack[",   formatTrackExpl:	"Formats the given number of tracks.",   hexData:		"hex data: ",   hexDataExpl:		"The data to be contained in the transfer buffer.",   iBM:			"IBM"L,   incrementing:	"incrementing",   incrementingExpl:	"2= incrementing data is used.",   loopCnt:		"loop count: ",   loopCntExpl1:	"The supported loop count is 0 through 1,000,000.",   loopCntExpl2:	"Entering a 0 = loop forever.",   none:		"none",   noOp:		"NoOperation[",   noOpExpl:		"Goes to the controller and returns status.",   notAllowedInLoop:	"Not allowed in a loop.",   notLooping:		"Not in a loop.",   notLoggingErrs:	"Not logging errors.",   notTracingCmds:	"Not tracing commands.",   odd:			"odd",   onlyAllowedInLoop:	"Only allowed in a loop.",   page:		"Page: ",   paramEnd:		"];",   paramSeparator:	", ",   plusOrMinus:		"+ or -: ",   protect:		"Software write protected: "L,   random:		"random",   randomExpl:		"3= random data is used.",   readID:		"ReadID[",   readIDExpl:		"To read one ID at the given track.",   readSector:		"ReadSector[",   readSectorExpl:	"To read one or more sectors of data.",   readStatus:		"ReadRS232Status[",   readStatusExpl:	"Reads RS232C status form the designated port.",   readTrack:		"ReadTrack[",   readTrackExpl:	"Reads the entire track.",   recalibrate:		"Recalibrate[",   recalibrateExpl:	"Moves the tape to track 0.",   remainSectorCount:	"remaining sector count: ",   remainTrackCount:	"remaining track count: ",   resetCont:		"ResetController;",   resetContExpl:	"Resets the floppy controller.",   retention:		"RetensionTape;",   retentionExpl:	"Applies the proper tention to the tape.",   retriedCount:	"times retried: ",   returnedParams:	"RETURNED PARAMETERS: ",   sectLngInWrds:	"Sector length in words: ",   sector:		"sector: ",   sectorExpl:		"The first sector number to be used.",   sectorCount:		"sector count: ",   sectorCountExpl:	"The number sectors to be transferred.",   sectPlMn1:		"Enter the number to be added or subtracted to or from",   sectPlMn2:		"the sector every time the command is executed.",   setStream:		"SetStream[",   setStreamExpl:	"The stream to be selected.",   single:		"single",   softReadErr:		"Soft Read Error:",   softErrDetected:	"Soft Errors Detected.",   startLogging:	"StartLogging;",   startLoggingExpl:	"Log all detected errors.",   startLoop:		"StartLoop[",   startLoopExpl:	"Defines the beginning of a loop.",   startPlusOrMinus:	"(",   startTrace:		"StartTrace;",   startTraceExpl:	"Starts a trace of IO commands executed.",   seek:		"Seek[",   seekExpl:		"Moves the tape to the desired track.",   stopLogging:		"StopLogging;",   stopLoggingExpl:	"Stops logging detected errors.",   stopTrace:		"StopTrace;",   stopTraceExpl:	"Stops tracing IO commands.",   stream:		"stream: ",   streamExpl:		"The stream to be selected.",   supptFillByte:	"The supported hex filler byte is 0 through FF.",   supptHexData:	"The supported hexadecimal data is 2 bytes.",   supptSector:		"The supported sector is 1 through 32",   supptSectorCount1:	"The supported sector count is 1 through 7840 if one 512 byte buffer is used",   supptSectorCount2:	"The supported sector count is 1 through 128 if multi 512 byte buffers are used",   supptStream:		"The supported streams is 1 through 12.",   supptTrack:		"The supported tracks are 0 and track numbers less than 2940 that are integers of 245.",   supptTrackCount:	"The supported track count is 1 through 245.",   supptTryCount:	"The supported try count is 1 through 64.",   testNumber:		"Test Number: ",   timeDelay:		"TimeDelay[",   timeDelayExpl:	"For delay between commands in .05 seconds increments.",   timeIncrementEquals:	"The time increments are in approximately .05 seconds increments.",   timesFailed:		"times failed: ",   timesTried:		"tries: ",   track:		"track: ",   trackExpl:		"The track to be selected.",   trackCount:		"track count: ",   trackCountExpl:	"The number of tracks to be formatted.",   trkPlMn1:		"Enter the number to be added or subtracted to or from",   trkPlMn2:		"the track every time the command is executed.",   troy:		"Troy"L,   tryCount:		"try count: ",   tryCountExpl:	"The number of tries to be done.",   unknown:		"not known",   unknownExpl:		"6= data type is not known.",   unrcvSoftErr:	"Hard Read Error:",   use1Buff:		"use single buffer(y/n): ",   use1BuffExpl:	"Use the same 512 byte buffer to conserve buffer space.",   useWrBuff:		"use write buffer",   useWrBuffExpl:	"5= use the write buffer (last written data).",   vrfyHeader:		"verify track(y/n): ",   vrfyHeaderExpl:	"Check for correct track address?",   vrfyRdBuff:		"verify read data(y/n): ",   vrfyRdBuffExpl:	"Verify the read buffer data against the written data?",   writeSector:		"WriteSector[",   writeSectorExpl:	"To write one or more sectors with data.",   writeDelSector:	"WriteDelSector[",   writeDelSectorExpl:	"To write a sector with a deleted address mark.",   zeroRdBuff:		"clear buffer first(y/n): ",   zeroRdBuffExpl:	"Store 0's into the buffer before receiving data?"    ]; mkIOCmd ¬@iOCmdMsgs;     END....--of DiagFlTapeMkIOCmdImpl.mesaLOG17-Apr-86 10:38:06	PJT	Created.18-Feb-88 16:05:02 JMA: modified text explanation
--Copyright (C) 1987  by Xerox Corporation. All rights reserved. ----File: DiagFlTapeRunCmdFileImpl.mesa-- Last edited by: JMA 11-Feb-88 12:07:35--  DIRECTORY  DiagFlTapeCmdDrive	USING	[LoopCount, ExecuteCommands],  DiagFlTapeDisplay	USING	[Subtests],  DiagFlTapeLog		USING	[LogStep, DisplayTempLog],  DiagFlTapeGetCmdFile	USING	[CommandArray, GetCommandFile],  DiagFlTapeMkMenu	USING	[mkMenu],  DiagFlTapeMkOpInt	USING	[mkOpInt],  DiagFlTapeOpInt	USING	[GetTestRequirements, PassCount,				 ProceedOnInput, Engineering, Switch],  DiagFlTapeTestControl	USING	[ReturningOnHardError, ReturningOnSoftError,				 ReturnAfterCommand, ReturningAfterCommand,				 SetUpTestControl, TCZipControl,				 TCRunCmdFile1, TCRunCmdFile2, TCRunCmdFile3],  DiagFlTapeErrorCheck	USING	[--SoftError, HardError,--InitErrorCheck,				 ECStandard1, PublicStatusCheckArray],  DiagFlTapeTestRec	USING	[Subtest, RunTestArray],  DiagFlTapeTestSelect	USING	[Exit],  DiagFlTapeTTY	USING	[Initialize, GetNumbers, PutMessage,				 PutNumber, PutMenu, PutString, PutSubtest,				 PutCR, PutChar, PutLine, UserAbort],  DiagFlTapeRunCmdFile 	USING	[],  OfflineDiagInterface  USING   [AbortCurrentTest];    DiagFlTapeRunCmdFileImpl:  PROGRAM     IMPORTS	DiagFlTapeCmdDrive,	DiagFlTapeDisplay,	DiagFlTapeLog,	DiagFlTapeGetCmdFile,	DiagFlTapeMkMenu,	DiagFlTapeMkOpInt,	DiagFlTapeOpInt,	DiagFlTapeTestControl,	DiagFlTapeErrorCheck,	DiagFlTapeTestRec,	DiagFlTapeTestSelect,	DiagFlTapeTTY,	Odi: OfflineDiagInterface    EXPORTS	DiagFlTapeRunCmdFile  = BEGIN  OPEN    DiagFlTapeMkMenu,    DiagFlTapeMkOpInt;   error:		BOOLEAN¬ FALSE;  loopWhenError:	BOOLEAN¬ FALSE;  nowInsideFile:	BOOLEAN¬ FALSE;  RunningUserCmdFile:	PUBLIC BOOLEAN¬ FALSE;  ValidCmdFile:		PUBLIC BOOLEAN;  subtestArray:		ARRAY [0..31] OF CARDINAL¬ ALL[0];  subtests:		ARRAY [0..31] OF DiagFlTapeTestRec.Subtest¬ ALL[STNoOp];      -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to build a new command file and run it  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    BuildNewFile: PUBLIC PROCEDURE  = BEGIN    ValidCmdFile¬ FALSE;    GetErrAction [];  DiagFlTapeGetCmdFile.GetCommandFile [];  ValidCmdFile¬ TRUE;  RunCmdFile [];  END; --BuildNewFile    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to run a prior build command file  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~   RunPriorFile: PUBLIC PROCEDURE  = BEGIN   IF ValidCmdFile THEN  { GetErrAction [];    RunCmdFile [] } ELSE    { DiagFlTapeTTY.PutChar [32C];      DiagFlTapeTTY.PutCR [];      DiagFlTapeTTY.PutLine [mkMenu[noCmdFileToRerun]];      DiagFlTapeOpInt.ProceedOnInput [] };    END; --RunPriorFile  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- does all the subtests stuff -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RunSubtests: PUBLIC PROCEDURE = BEGIN num: CARDINAL¬ 0; exit: BOOLEAN¬ FALSE; options: ARRAY [0..2] OF LONG STRING¬ [ 	mkMenu[dsplSubtests],	-- 1	mkMenu[enterSubtests],	-- 2	mkMenu[runSubtests]];	-- 3 questtext: ARRAY [0..3] OF LONG STRING¬ [	mkMenu[dsplSubtestsExpl],	mkMenu[enterSubtestsExpl],	mkMenu[runSubtestsExpl],	mkMenu[returnsToPriorMenu]]; DiagFlTapeCmdDrive.LoopCount¬ 1; UNTIL exit DO   DiagFlTapeTTY.Initialize [];   DiagFlTapeTTY.PutCR [];   num¬ DiagFlTapeTTY.PutMenu[	title: mkMenu[subtestsOptionS],	options: DESCRIPTOR [options],	numberExplanations: TRUE,	optionExplanation: DESCRIPTOR [questtext]];	   subtestArray¬ ALL[0];   SELECT num FROM   1 => DiagFlTapeDisplay.Subtests[ 	   ! DiagFlTapeTTY.UserAbort => CONTINUE;	     DiagFlTapeTestSelect.Exit => CONTINUE;	     Odi.AbortCurrentTest => CONTINUE];    2 => GetSubtests[ --uses subtestArray to enter the subtest numbers	   ! DiagFlTapeTTY.UserAbort => CONTINUE;	     DiagFlTapeTestSelect.Exit => CONTINUE;	     Odi.AbortCurrentTest => CONTINUE];    3 => RunSbtsts[ --uses subtestArray to run the subtest numbers	   ! DiagFlTapeTTY.UserAbort => CONTINUE;	     DiagFlTapeTestSelect.Exit => CONTINUE;	     Odi.AbortCurrentTest => CONTINUE];    4 => SIGNAL DiagFlTapeTestSelect.Exit;   ENDCASE; ENDLOOP; --until exit  END; --RunSubtests -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetSubtests: PROCEDURE  = BEGIN  questtext:	ARRAY [0..1] OF LONG STRING¬ [	mkMenu[enterValidSTNum],	mkMenu[maxEntriesEql32]];  subtestArray¬ ALL[0]; DiagFlTapeTTY.Initialize []; DiagFlTapeTTY.PutCR [count: 2]; --DiagFlTapeTTY.PutLine [string: mkMenu[subtestsToBeRun]]; DiagFlTapeTTY.GetNumbers[    prompt: mkMenu[subtestsToBeRun],    minNumber: 1,    maxNumber: ORD[LAST[DiagFlTapeTestRec.Subtest]],    numberArray: DESCRIPTOR[subtestArray],    explanation: DESCRIPTOR [questtext]];     --convert cardinal array to subtest array FOR i: CARDINAL IN [0..31] DO   subtests[i]¬ VAL[subtestArray[i]]; ENDLOOP; END; --GetSubtests -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RunSbtsts: PROCEDURE  = BEGIN firstPass: BOOLEAN¬ TRUE; subtestToRun: BOOLEAN¬ FALSE; RunningUserCmdFile¬ FALSE;  DiagFlTapeOpInt.GetTestRequirements[		testTitle:		mkMenu[runningSubtests],		needPassCount:		TRUE]; --have subtests been selected FOR i: CARDINAL IN [0..31] DO   IF subtests[i]# STNoOp THEN subtestToRun¬ TRUE; ENDLOOP; IF ~subtestToRun THEN { DiagFlTapeTTY.PutChar[32C];   DiagFlTapeTTY.PutCR[];   DiagFlTapeTTY.PutLine[mkMenu[noSubtestsToRun]];   DiagFlTapeOpInt.ProceedOnInput[];   RETURN; };  --clear the soft error table IF NOT (DiagFlTapeOpInt.Engineering AND DiagFlTapeOpInt.Switch[81]) THEN   DiagFlTapeErrorCheck.InitErrorCheck[];  -- run the test  UNTIL DiagFlTapeOpInt.PassCount= 0 DO    --display the test data    DiagFlTapeTTY.PutChar[32C]; --clears the screen    DiagFlTapeTTY.PutLine [string: mkMenu[runningSubtests]];    DiagFlTapeTTY.PutCR [];    IF firstPass THEN      DiagFlTapeTTY.PutString [mkOpInt[passesToRun]] ELSE        DiagFlTapeTTY.PutString [mkOpInt[passesLeft]];    DiagFlTapeTTY.PutNumber [number: DiagFlTapeOpInt.PassCount, size: 3];    DiagFlTapeTTY.PutCR [];    firstPass¬ FALSE;	        DiagFlTapeTTY.PutCR [count: 2];    DiagFlTapeTTY.PutLine [mkOpInt[subtesT]];    DiagFlTapeTTY.PutCR [];        --now run the test    DiagFlTapeTestRec.RunTestArray[subtestSelectArray: DESCRIPTOR[subtests]];        -- exit if no more passes    DiagFlTapeOpInt.PassCount¬ DiagFlTapeOpInt.PassCount- 1;    IF DiagFlTapeOpInt.PassCount=0 THEN    { DiagFlTapeTTY.PutMessage [];	--clears the soft error displayed      DiagFlTapeTTY.PutCR [count: 2];      DiagFlTapeTTY.PutSubtest [testName: mkOpInt[successFullCompl]];      DiagFlTapeOpInt.ProceedOnInput [];    }; ENDLOOP; --DiagFlTapeOpInt.PassCount= 0 END; --RunSbtsts -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to get what to do with errors -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetErrAction: PROCEDURE  = BEGIN    num: CARDINAL¬ 0;  options:	ARRAY [0..3] OF LONG STRING¬ [ 	mkMenu[ignoreErrs],	-- 1	mkMenu[continueOnErr],	-- 2	mkMenu[stopOnErr],	-- 3	mkMenu[stepCmds]];	-- 5  questtext:	ARRAY [0..4] OF LONG STRING¬ [	mkMenu[ignoreErrsExpl],	mkMenu[continueOnErrsExpl],	mkMenu[stopOnErrExpl],	mkMenu[stepCmdsExpl],	mkMenu[returnsToPriorMenu]];  title:	LONG STRING¬ mkMenu[errACTION];    DiagFlTapeLog.LogStep ¬ FALSE;  loopWhenError¬ FALSE;  DiagFlTapeTTY.Initialize [];  DiagFlTapeTTY.PutCR [];    num¬ DiagFlTapeTTY.PutMenu[		title: title,		options: DESCRIPTOR [options],		numberExplanations: TRUE,		optionExplanation: DESCRIPTOR [questtext]];		  SELECT num FROM  1 => DiagFlTapeTestControl.SetUpTestControl[	    controlData: DiagFlTapeTestControl.TCZipControl];   2 => DiagFlTapeTestControl.SetUpTestControl[	   controlData: DiagFlTapeTestControl.TCRunCmdFile1];  3 =>    { DiagFlTapeTestControl.SetUpTestControl[	   controlData: DiagFlTapeTestControl.TCRunCmdFile2];      DiagFlTapeLog.LogStep¬ TRUE;    };<<  4 =>    { DiagFlTapeTestControl.SetUpTestControl[	   controlData: DiagFlTapeTestControl.TCRunCmdFile2];      loopWhenError¬ TRUE;       IF DiagFlTapeErrorCheck.SoftError OR	DiagFlTapeErrorCheck.HardError	THEN DiagFlTapeTestControl.LoopOnError¬ TRUE;    }; >>  4 =>    { DiagFlTapeTestControl.SetUpTestControl[	   controlData: DiagFlTapeTestControl.TCRunCmdFile3];      DiagFlTapeLog.LogStep ¬ TRUE;    };  5 =>  SIGNAL DiagFlTapeTestSelect.Exit;  ENDCASE;  END; --GetErrAction      -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to run the command file  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    RunCmdFile: PROCEDURE  = BEGIN  RunningUserCmdFile¬ TRUE;    --set up the status to be checked  DiagFlTapeErrorCheck.PublicStatusCheckArray¬    DESCRIPTOR[DiagFlTapeErrorCheck.ECStandard1];  DiagFlTapeCmdDrive.ExecuteCommands [    commandArray: DESCRIPTOR[DiagFlTapeGetCmdFile.CommandArray]    ! DiagFlTapeTestControl.ReturningOnSoftError,      DiagFlTapeTestControl.ReturningOnHardError=>      { IF NOT DiagFlTapeTestControl.ReturnAfterCommand THEN        { DiagFlTapeLog.DisplayTempLog [];          --GetErrAction [];-- RESUME;	} ELSE RESUME;      };      DiagFlTapeTestControl.ReturningAfterCommand=>      { DiagFlTapeLog.DisplayTempLog [];        --GetErrAction [];-- RESUME }];  RunningUserCmdFile¬ FALSE;    END; --RunCmdFile    	  END.... --of DiagFlTapeRunCmdFileImplLOG18-Mar-82  9:02:42 PJT : Created22-Jan-88 10:51:40 JMA : added catcher for AbortCurrentTest signal			
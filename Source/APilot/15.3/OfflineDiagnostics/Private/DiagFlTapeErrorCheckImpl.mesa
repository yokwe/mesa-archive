-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. ---- File: DiagFlTapeErrorCheckImpl.mesa-- Edited by: PJT  9-Aug-88 17:23:52------~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--FAILURE/ERROR CODE DESCRIPTIONS--**********************************--  ----FlTape codes:--************--  2821= Hardware problem:--	Replace: IOP, Tape Drive, harness--  2822= Hardware problem:--	Replace: Tape Drive, harness, IOP--  2823= Too many soft read errors detected--	Posssible dirty drive, Media problem, or hardware problem.--	Replace: Tape Drive, harness, IOP--  2824= Too many hard read errors detected--	Posssible dirty drive, Media problem, or hardware problem.--	Replace: Tape Drive, harness, IOP--  2825= Command timeout--	Replace: Tape Drive, harness, IOP, Mesa Prcocessor, Motherboard--  2826= Retensioning failed--	Replace: Tape Drive, cable, IOP, harness--  2827= Reading the bad page table failed--	Run the exerciser using a scratch tape to verify the hardware.----Other codes:--***********--  2829= Hardware problem:--	Real time clock failure.----Dove-specific codes:--********************--  2831= Media or Hardware problem:--	Run the confidence test to verify the hardware.--  2832= Media or Hardware problem:--	Scavenge the tape.----Software crash code:--*******************--  0915= Software problem:--	Get analyst----~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DIRECTORY DiagFlTapeBuff		USING	[CompareData, CompareID], DiagFlTapeCmdDes	USING	[Command, CmdDescriptArray], DiagFlTapeCmdDrive	USING	[parameterRecord, UpdateParameters], DiagFlTapeCmds		USING	[IoCPA, WrBuffArray, LastWriteCmdIdx,				 RdBuffArray, RdIDBuffArray, MinTrack,				 SectorsPerTrack, MinSector, MaxSector,				 MaxTrack, MaxTracksPerFormat,				 RetentionFromErrCheck], DiagFlTapeDisplay	USING	[SoftError], DiagFlTapeLog		USING	[LogEvent], DiagFlTapeMkIOCmd	USING	[mkIOCmd], DiagFlTapeOpInt	USING	[CallService], DiagFlTapeRunCmdFile	USING	[RunningUserCmdFile], DiagFlTapeTestControl	USING	[CheckForError, CheckPassSoftErrCount,				 MaxPassSoftErrors, IgnoreSoftErrors,				 ContinueOnHardError, ContinueOnSoftError,				 CountSubtestSoftErrors, DisplaySoftErrors,				 ReturnAfterCommand, RepeatingCommand,				 ReturnOnHardError, ReturningOnHardError,				 ReturnOnSoftError, ReturningOnSoftError,				 ReturningAfterCommand, MaxSubtestSoftErrors,				 SoftErrorsInAPass, RepeatedCmdSoftErrCnt,				 LastRepeatCommand, RepeatCmdCnt,				 CheckBadPageTable, CheckSoftErrTable,				 SignalOnSoftErrInTable, SoftErrorInTable,				 SignalOnSoftError, SoftError,				 CheckPassHardReadErrCount,				 MaxPassHardReadErrors, HardReadErrorsInAPass,--				 RateErrorsInAPass,				 CountSubtestHardReadErrors,				 MaxSubtestHardReadErrors,				 DisplaySummaryOnHardErr], DiagFlTapeTests	USING	[DisplayError], DiagFlTapeErrorCheck	USING	[expectedStatus], Environment		USING	[wordsPerPage], Space			USING	[ScratchMap]; DiagFlTapeErrorCheckImpl: PROGRAM   IMPORTS     DiagFlTapeBuff,     DiagFlTapeCmdDes,     DiagFlTapeCmdDrive,     DiagFlTapeCmds,     DiagFlTapeDisplay,     DiagFlTapeLog,     DiagFlTapeMkIOCmd,     DiagFlTapeOpInt,     DiagFlTapeRunCmdFile,     DiagFlTapeTestControl,     DiagFlTapeTests,     Space   EXPORTS     DiagFlTapeErrorCheck = BEGIN   OPEN     DiagFlTapeMkIOCmd,     DiagFlTapeErrorCheck,     Tc: DiagFlTapeTestControl,     Io: DiagFlTapeCmds; Cleanup:		PUBLIC SIGNAL= CODE; SoftError:		PUBLIC BOOLEAN ¬ FALSE; HardError:		PUBLIC BOOLEAN ¬ FALSE; Disaster:		PUBLIC BOOLEAN ¬ FALSE; DataError:		PUBLIC BOOLEAN ¬ FALSE; DataErrorIndex:	PUBLIC CARDINAL; DataErrorExpected:	PUBLIC CARDINAL; DataErrorObserved:	PUBLIC CARDINAL; ErrorCode:		PUBLIC CARDINAL ¬ 0; FruCode:		PUBLIC CARDINAL ¬ 0;  --bad page stuff BadPage:		PUBLIC LONG CARDINAL; BadPageInTable:	PUBLIC BOOLEAN ¬ FALSE; NumOfBadPages:		PUBLIC CARDINAL¬ 0; BadPageBuffPtr:	PUBLIC LONG POINTER TO ARRAY [0..512) OF LONG CARDINAL; --soft error stuff SoftErrInTable:	PUBLIC BOOLEAN ¬ FALSE; NumOfSoftErrs:		PUBLIC CARDINAL¬ 0; SoftErrBuffPtr:	PUBLIC LONG POINTER TO ARRAY [0..512) OF LONG CARDINAL; SoftErrCntBuffPtr:	PUBLIC LONG POINTER TO ARRAY [0..512) OF CARDINAL; --hard read error stuff NumOfHardReadErrs:	PUBLIC CARDINAL; HardReadErrBuffPtr:	PUBLIC LONG POINTER TO ARRAY [0..128) OF LONG CARDINAL; PublicStatusCheckArray:PUBLIC LONG DESCRIPTOR FOR PACKED ARRAY OF expectedStatus; -- error masks arrays ECNull:		PUBLIC PACKED ARRAY [0..1] OF expectedStatus; ECStandard1:		PUBLIC PACKED ARRAY [0..18] OF expectedStatus; ECExpctDtErr:		PUBLIC PACKED ARRAY [0..18] OF expectedStatus; --global variables NeedToCleanup:		BOOLEAN¬ FALSE; maxRetntnCount:	CARDINAL¬ 15; softErrCntForRetntn:	CARDINAL¬ 0; parmRec: 		DiagFlTapeCmdDrive.parameterRecord; -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to verify the given status bits in the given sequence -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CheckStatus: PUBLIC PROCEDURE [	cmdIdx: CARDINAL¬ 0,	command: DiagFlTapeCmdDes.Command,	needToCleanUp: BOOLEAN¬ FALSE,	errorArray: LONG DESCRIPTOR FOR PACKED ARRAY OF          expectedStatus ¬ PublicStatusCheckArray] = BEGIN cnt:			CARDINAL ¬ 0; iddSftErr:		BOOLEAN ¬ FALSE; statusPtr:		expectedStatus; HardError		¬ FALSE; Disaster		¬ FALSE; SoftError		¬ FALSE; BadPageInTable		¬ FALSE; SoftErrInTable		¬ FALSE; DataError		¬ FALSE; ErrorCode		¬ 0; FruCode		¬ 0; Io.IoCPA[cmdIdx].errorType¬ noError;  IF needToCleanUp THEN NeedToCleanup¬ TRUE ELSE NeedToCleanup¬ FALSE; -- log and return if not checking for errors IF NOT Tc.CheckForError OR BASE[errorArray]= NIL THEN { LogAndOrReport[	command: command]; RETURN; }; -- if IO status was returned IF DiagFlTapeCmdDes.CmdDescriptArray[command].rtrnsIOStatus THEN  { UNTIL cnt = LENGTH[errorArray] OR HardError OR SoftError OR iddSftErr DO     statusPtr ¬ errorArray[cnt];     SELECT statusPtr FROM     -- 0     inProgressFalse=> IF Io.IoCPA[cmdIdx].rtndStatus= inProgress THEN       { HardError¬ TRUE;         Io.IoCPA[cmdIdx].errorType¬ hardError;         FruCode¬ 2822;       };     -- 1     inProgressTrue=> IF Io.IoCPA[cmdIdx].rtndStatus# inProgress THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     -- 2     goodCompletionFalse=> IF Io.IoCPA[cmdIdx].rtndStatus= goodCompletion THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     -- 3     goodCompletionTrue=> IF Io.IoCPA[cmdIdx].rtndStatus# goodCompletion THEN      { IF Io.IoCPA[cmdIdx].rtndStatus# deletedData THEN         { HardError¬ TRUE;          Io.IoCPA[cmdIdx].errorType¬ hardError;          FruCode¬ 2822;        };      };     -- 4     diskChangeFalse=> IF Io.IoCPA[cmdIdx].rtndStatus= diskChange THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     -- 5     diskChangeTrue=> IF Io.IoCPA[cmdIdx].rtndStatus# diskChange THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     -- 6     notReadyFalse=> IF Io.IoCPA[cmdIdx].rtndStatus= notReady THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     -- 7     notReadyTrue=> IF Io.IoCPA[cmdIdx].rtndStatus# notReady THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     -- 8     cylinderErrorFalse=> IF Io.IoCPA[cmdIdx].rtndStatus= cylinderError THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     -- 9     cylinderErrorTrue=> IF Io.IoCPA[cmdIdx].rtndStatus# cylinderError THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     --10     deletedDataFalse=> IF Io.IoCPA[cmdIdx].rtndStatus= deletedData THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     --11     deletedDataTrue=> IF Io.IoCPA[cmdIdx].rtndStatus# deletedData THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     --12     recordNotFoundFalse=> IF Io.IoCPA[cmdIdx].rtndStatus= recordNotFound THEN       { iddSftErr¬ TRUE;         SoftError¬ ThisIsARealSoftError[cmdIdx];         IF SoftError THEN	 { Io.IoCPA[cmdIdx].errorType¬ softReadError;	   softErrCntForRetntn ¬ softErrCntForRetntn + 5;	 } ELSE	 { IF SoftErrInTable THEN	     Io.IoCPA[cmdIdx].errorType¬ softRdErrInSoftErrTbl;	   IF BadPageInTable THEN	     Io.IoCPA[cmdIdx].errorType¬ softRdErrInBadPageTbl;	   softErrCntForRetntn¬ softErrCntForRetntn + 5;	 };       };     --13     recordNotFoundTrue=> IF Io.IoCPA[cmdIdx].rtndStatus# recordNotFound THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     --14     headerErrorFalse=> IF Io.IoCPA[cmdIdx].rtndStatus= headerError THEN       { iddSftErr¬ TRUE;         SoftError¬ ThisIsARealSoftError[cmdIdx];         IF SoftError THEN	 { Io.IoCPA[cmdIdx].errorType¬ softReadError;	   softErrCntForRetntn¬ softErrCntForRetntn+1;	 } ELSE	 { IF SoftErrInTable THEN	     Io.IoCPA[cmdIdx].errorType¬ softRdErrInSoftErrTbl;	   IF BadPageInTable THEN	     Io.IoCPA[cmdIdx].errorType¬ softRdErrInBadPageTbl;	   softErrCntForRetntn¬ softErrCntForRetntn+1;	 };       };     --15     headerErrorTrue=> IF Io.IoCPA[cmdIdx].rtndStatus# headerError THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     --16     dataErrorFalse=> IF Io.IoCPA[cmdIdx].rtndStatus= dataError THEN       { iddSftErr¬ TRUE;         SoftError¬ ThisIsARealSoftError[cmdIdx];         IF SoftError THEN	 { Io.IoCPA[cmdIdx].errorType¬ softReadError;	   softErrCntForRetntn¬ softErrCntForRetntn+1;	 } ELSE	 { IF SoftErrInTable THEN	     Io.IoCPA[cmdIdx].errorType¬ softRdErrInSoftErrTbl;	   IF BadPageInTable THEN	     Io.IoCPA[cmdIdx].errorType¬ softRdErrInBadPageTbl;	   softErrCntForRetntn¬ softErrCntForRetntn+1;	 };       };     --17     dataErrorTrue=> IF Io.IoCPA[cmdIdx].rtndStatus# dataError THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     --18     dataLostFalse=> IF Io.IoCPA[cmdIdx].rtndStatus= dataLost THEN       { iddSftErr¬ TRUE;         SoftError¬ ThisIsARealSoftError[cmdIdx];         IF SoftError THEN	 { Io.IoCPA[cmdIdx].errorType¬ softReadError;	   softErrCntForRetntn¬ softErrCntForRetntn+1;	 } ELSE	 { IF SoftErrInTable THEN	     Io.IoCPA[cmdIdx].errorType¬ softRdErrInSoftErrTbl;	   IF BadPageInTable THEN	     Io.IoCPA[cmdIdx].errorType¬ softRdErrInBadPageTbl;	   softErrCntForRetntn¬ softErrCntForRetntn+1;	 };       };     --19    dataLostTrue => IF Io.IoCPA[cmdIdx].rtndStatus# dataLost THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     --20    writeFaultFalse => IF Io.IoCPA[cmdIdx].rtndStatus= writeFault THEN      { IF command= wrSector         OR command= wrDlSctr         OR command= formatTk THEN        { HardError¬ TRUE;          Io.IoCPA[cmdIdx].errorType¬ hardError;          FruCode¬ 2822;        } ELSE Io.IoCPA[cmdIdx].rtndStatus¬ goodCompletion;        Io.IoCPA[cmdIdx].writeProtected¬ TRUE;      };     --21     writeFaultTrue=> IF Io.IoCPA[cmdIdx].rtndStatus# writeFault THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     --22     memoryErrorFalse => IF Io.IoCPA[cmdIdx].rtndStatus= memoryError THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2821;      };     --23     memoryErrorTrue=> IF Io.IoCPA[cmdIdx].rtndStatus# memoryError  THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2821;      };     --24      invalidOperationFalse=>       IF Io.IoCPA[cmdIdx].rtndStatus= invalidOperation THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2821;      };     --25      invalidOperationTrue=>       IF Io.IoCPA[cmdIdx].rtndStatus# invalidOperation  THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2821;      };     --26     abortedFalse=> IF Io.IoCPA[cmdIdx].rtndStatus= aborted THEN      { HardError¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ hardError;        FruCode¬ 2822;      };     --27     abortedTrue=> IF Io.IoCPA[cmdIdx].rtndStatus# aborted THEN       { HardError¬ TRUE;         Io.IoCPA[cmdIdx].errorType¬ hardError;         FruCode¬ 2822;       };     --28     otherErrorFalse=> IF Io.IoCPA[cmdIdx].rtndStatus= otherError THEN         softErrCntForRetntn¬ maxRetntnCount;     --32     cmdTimedOutFalse=> IF Io.IoCPA[cmdIdx].cmdTimedOut THEN      { Disaster¬ TRUE;        Io.IoCPA[cmdIdx].errorType¬ disaster;        FruCode¬ 2825;      };     --34     countLeftErrFalse=>       BEGIN       countErr: BOOLEAN ¬ FALSE;       IF (command= rdSector         OR command= wrSector         OR command= wrDlSctr)	 AND Io.IoCPA[cmdIdx].opPtr­.count# 0 THEN countErr ¬ TRUE;       << Dove floppytape formats MaxTracksPerFormat or 1 stream at a time       so just check if current track address = start track + MaxTracksPerFormat >>       IF command= formatTk AND ( Io.IoCPA[cmdIdx].opPtr­.address.cylinder #           Io.IoCPA[cmdIdx].track+DiagFlTapeCmds.MaxTracksPerFormat)	  THEN countErr ¬ TRUE;       IF countErr THEN         { HardError¬ TRUE;           Io.IoCPA[cmdIdx].errorType¬ disaster;	   IF command= formatTk THEN             Io.IoCPA[cmdIdx].rtrndTrackCntError¬ TRUE ELSE	       Io.IoCPA[cmdIdx].rtrndSectorCntError¬ TRUE;	   FruCode¬ 2828;	  };	END;     --36     dataVerifyErrorFalse=>       IF command= rdSector AND Io.IoCPA[cmdIdx].needVrfyData THEN       { errorIdx: CARDINAL;         sectorsXfd: CARDINAL;         --see if anything was transfered         IF Io.IoCPA[cmdIdx].opPtr­.count<	   Io.IoCPA[cmdIdx].sectorOrTrackCount THEN	 { --now set up the sector number to verify	   IF Io.IoCPA[cmdIdx].opPtr­.incrementDataPointer THEN	     sectorsXfd¬ (Io.IoCPA[cmdIdx].sectorOrTrackCount-	       Io.IoCPA[cmdIdx].opPtr­.count) ELSE sectorsXfd¬ 1;           [dataError: Io.IoCPA[cmdIdx].dataVerifyError,            wordIndex: Io.IoCPA[cmdIdx].dataErrorIndex,	    expected: Io.IoCPA[cmdIdx].dataErrorExpected,	    observed: Io.IoCPA[cmdIdx].dataErrorObserved]¬	      DiagFlTapeBuff.CompareData[	        writtenDataPtr: Io.WrBuffArray[Io.LastWriteCmdIdx],	        kindOfData: Io.IoCPA[cmdIdx].dataType,	        cylinder: Io.IoCPA[cmdIdx].track,	        sector: Io.IoCPA[cmdIdx].sector,	        readDataPtr: Io.RdBuffArray[cmdIdx],	        wordCount: sectorsXfd*Environment.wordsPerPage];	   IF Io.IoCPA[cmdIdx].dataVerifyError THEN 	   { --check if this one is known about	     wrPtr: LONG POINTER TO ARRAY OF WORD¬	       Io.WrBuffArray[Io.LastWriteCmdIdx];	     rdPtr: LONG POINTER TO ARRAY OF WORD¬	       Io.RdBuffArray[cmdIdx];	     page: LONG CARDINAL;	     failSec: CARDINAL¬ Io.IoCPA[cmdIdx].dataErrorIndex/256;	     sector: CARDINAL;	     track: CARDINAL;	     done: BOOLEAN¬ FALSE;	     	     --keep the data error index	     errorIdx¬ Io.IoCPA[cmdIdx].dataErrorIndex;             parmRec¬ [];             parmRec.minItem1¬ DiagFlTapeCmds.MinSector;             parmRec.maxItem1¬ DiagFlTapeCmds.MaxSector;             parmRec.minItem3¬ DiagFlTapeCmds.MinTrack;             parmRec.maxItem3¬ DiagFlTapeCmds.MaxTrack;	     parmRec.item1¬ Io.IoCPA[cmdIdx].sector;	     parmRec.item1Change¬ failSec;	     parmRec.item3¬ Io.IoCPA[cmdIdx].track;	     UNTIL done DO               [newItemsToXfer: ,                newItem1: sector,                newItem2: ,                newItem3: track,                newItem4: ]¬ DiagFlTapeCmdDrive.UpdateParameters[		  parmRcPtr: @parmRec];		--create the bad page number                page¬ track- Io.MinTrack;                page¬ (page* Io.SectorsPerTrack)+ sector;                 -- is the error in the bad page table                IF NOT ( (Tc.CheckSoftErrTable AND SoftErrIsInTable[page])                  OR (Tc.CheckBadPageTable AND BadPageIsInTable[page]) ) THEN	        { HardError¬ TRUE;	          Io.IoCPA[cmdIdx].dataErrorIndex¬ errorIdx;	          Io.IoCPA[cmdIdx].errorType¬ hardError;                  FruCode¬ 2822;		  EXIT;	        };		--the page was in the bad page table, clear the error		Io.IoCPA[cmdIdx].dataVerifyError¬ FALSE;		--keep the error for logging	        IF SoftErrInTable THEN	          Io.IoCPA[cmdIdx].errorType¬ softRdErrInSoftErrTbl;	        IF BadPageInTable THEN	          Io.IoCPA[cmdIdx].errorType¬ softRdErrInBadPageTbl;		--check if the failing sector was the last sector		IF NOT sectorsXfd= failSec+1 THEN		{ --update the parameters for comparing the rest of the data		  sectorsXfd¬ sectorsXfd- (failSec+ 1);	          parmRec.item1¬ sector;	          parmRec.item1Change¬ 1;	          parmRec.item3¬ track;                 [newItemsToXfer: ,                  newItem1: sector,                  newItem2: ,                  newItem3: track,                  newItem4: ]¬ DiagFlTapeCmdDrive.UpdateParameters[		    parmRcPtr: @parmRec];		  wrPtr¬ wrPtr+ ((failSec+ 1)*Environment.wordsPerPage);		  rdPtr¬ rdPtr+ ((failSec+ 1)*Environment.wordsPerPage);                  [dataError: Io.IoCPA[cmdIdx].dataVerifyError,                   wordIndex: Io.IoCPA[cmdIdx].dataErrorIndex,	           expected: Io.IoCPA[cmdIdx].dataErrorExpected,	           observed: Io.IoCPA[cmdIdx].dataErrorObserved]¬	             DiagFlTapeBuff.CompareData[	               writtenDataPtr: wrPtr,	               kindOfData: Io.IoCPA[cmdIdx].dataType,	               cylinder: track,	               sector: sector,	               readDataPtr: rdPtr,	               wordCount: sectorsXfd*Environment.wordsPerPage];	         IF Io.IoCPA[cmdIdx].dataVerifyError THEN 	         { failSec¬	             Io.IoCPA[cmdIdx].dataErrorIndex/Environment.wordsPerPage;	           errorIdx¬ errorIdx/Environment.wordsPerPage;	           errorIdx¬ errorIdx+ 1;	           errorIdx¬ errorIdx*Environment.wordsPerPage;	           errorIdx¬ errorIdx+ Io.IoCPA[cmdIdx].dataErrorIndex;	           parmRec.item1¬ sector;	           parmRec.item1Change¬ failSec;	           parmRec.item3¬ track;	         } ELSE done¬ TRUE;	       } ELSE done¬ TRUE;	     ENDLOOP;           };         };       };            --37     dataVerifyErrorTrue=>       IF command= rdSector AND Io.IoCPA[cmdIdx].needVrfyData THEN         IF Io.IoCPA[cmdIdx].opPtr­.count<	   Io.IoCPA[cmdIdx].sectorOrTrackCount THEN         { sectorsXfd: CARDINAL;	   IF Io.IoCPA[cmdIdx].opPtr­.incrementDataPointer THEN	     sectorsXfd¬ (Io.IoCPA[cmdIdx].sectorOrTrackCount-	       Io.IoCPA[cmdIdx].opPtr­.count) ELSE sectorsXfd¬ 1;           [dataError: Io.IoCPA[cmdIdx].dataVerifyError,            wordIndex: Io.IoCPA[cmdIdx].dataErrorIndex,	    expected: Io.IoCPA[cmdIdx].dataErrorExpected,	    observed: Io.IoCPA[cmdIdx].dataErrorObserved]¬	      DiagFlTapeBuff.CompareData[	        writtenDataPtr: Io.WrBuffArray[Io.LastWriteCmdIdx],	        kindOfData: Io.IoCPA[cmdIdx].dataType,	        cylinder: Io.IoCPA[cmdIdx].track,	        sector: Io.IoCPA[cmdIdx].sector,	        readDataPtr: Io.RdBuffArray[cmdIdx],	        wordCount: sectorsXfd*Environment.wordsPerPage];	   IF NOT Io.IoCPA[cmdIdx].dataVerifyError THEN 	   { HardError¬ TRUE;             Io.IoCPA[cmdIdx].errorType¬ hardError;             Io.IoCPA[cmdIdx].dataNotWrittenError¬ TRUE;	     FruCode¬ 2822;           }ELSE Io.IoCPA[cmdIdx].dataVerifyError¬ FALSE;         };     --38     iDVerifyErrorFalse=>       IF command= readID THEN       { [idError: Io.IoCPA[cmdIdx].iDVerifyError,          byteIndex: Io.IoCPA[cmdIdx].dataErrorIndex]¬	    DiagFlTapeBuff.CompareID[	      ptrToID: Io.RdIDBuffArray[cmdIdx],	      track: Io.IoCPA[cmdIdx].track];	 IF Io.IoCPA[cmdIdx].iDVerifyError THEN	 { HardError¬ TRUE;           Io.IoCPA[cmdIdx].errorType¬ hardError;	   FruCode¬ 2822;         };       };     ENDCASE;     cnt ¬ cnt + 1;   ENDLOOP; };  Io.IoCPA[cmdIdx].fRUCode¬ FruCode; ErrorCode¬ ORD[statusPtr]; Io.IoCPA[cmdIdx].errorCode¬ statusPtr; LogAndOrReport[	cmdIdx: cmdIdx, 	command: command];  END;  --CheckStatus -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- reports the given error -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LogAndOrReport: PROCEDURE [	cmdIdx: CARDINAL¬ 0, 	command: DiagFlTapeCmdDes.Command] = BEGIN st: expectedStatus; IF SoftError AND NOT Tc.RepeatingCommand THEN { --increment the soft error count in a pass   Tc.SoftErrorsInAPass¬ Tc.SoftErrorsInAPass+ 1;   --check for too many soft errors in a subtest   IF Tc.CountSubtestSoftErrors THEN   { Tc.MaxSubtestSoftErrors¬ Tc.MaxSubtestSoftErrors- 1;     IF Tc.MaxSubtestSoftErrors = 0 THEN     { st¬ tooManySubTestSoftErrs;       ErrorCode ¬ORD[st];       SoftError ¬ FALSE; HardError¬ TRUE; FruCode¬ 2823;       Io.IoCPA[cmdIdx].errorCode¬ st;       Io.IoCPA[cmdIdx].errorType¬ hardError;     };   };   --display soft error?   IF Tc.DisplaySoftErrors THEN     DiagFlTapeDisplay.SoftError[	title: mkIOCmd[softReadErr],     	badPage: BadPage]; };  --increment the error count when repeating a soft error IF Tc.RepeatingCommand AND (SoftError OR BadPageInTable OR SoftErrInTable) THEN   Tc.RepeatedCmdSoftErrCnt¬ Tc.RepeatedCmdSoftErrCnt + 1 ELSE     Tc.RepeatedCmdSoftErrCnt¬ 0;       --do end of repeating a soft error stuff IF Tc.RepeatingCommand AND Tc.LastRepeatCommand THEN { --now display the soft error   IF Tc.RepeatCmdCnt> Tc.RepeatedCmdSoftErrCnt     AND Tc.DisplaySoftErrors THEN       DiagFlTapeDisplay.SoftError[	 title: mkIOCmd[softReadErr],         badPage: BadPage,	 timesFailed: Tc.RepeatedCmdSoftErrCnt+ 1];   IF (Tc.RepeatCmdCnt= Tc.RepeatedCmdSoftErrCnt) THEN   { st: expectedStatus¬ hardReadErr;     ErrorCode ¬ ORD[st];     Io.IoCPA[cmdIdx].errorCode¬ st;     Io.IoCPA[cmdIdx].errorType¬ hardReadError;     KeepHardReadErr[badPage: BadPage];     --increment pass hard read error count     Tc.HardReadErrorsInAPass¬ Tc.HardReadErrorsInAPass+ 1;     IF Tc.DisplaySoftErrors THEN       DiagFlTapeDisplay.SoftError[	 title: mkIOCmd[unrcvSoftErr],         badPage: BadPage,	 timesTried: Tc.RepeatCmdCnt+ 1,	 timesFailed: Tc.RepeatedCmdSoftErrCnt+ 1];     IF Tc.CountSubtestHardReadErrors THEN     { Tc.MaxSubtestHardReadErrors¬ Tc.MaxSubtestHardReadErrors- 1;       IF Tc.MaxSubtestHardReadErrors = 0 THEN       { st¬ tooManySubTestHardReadErrs;         ErrorCode ¬ORD[st];         SoftError ¬ FALSE; HardError¬ TRUE; FruCode¬ 2824;         Io.IoCPA[cmdIdx].errorCode¬ st;         Io.IoCPA[cmdIdx].errorType¬ hardError;       };     };   }; }; --check if too many soft read errors in a pass IF NOT HardError   AND Tc.CheckPassSoftErrCount   AND Tc.SoftErrorsInAPass>= Tc.MaxPassSoftErrors THEN { st¬ tooManyPassSoftErrs;   ErrorCode ¬ ORD[st];   SoftError ¬ FALSE; HardError¬ TRUE; FruCode¬ 2823;   Io.IoCPA[cmdIdx].errorCode¬ st;   Io.IoCPA[cmdIdx].errorType¬ hardError; }; --check if too many hard read errors in a pass IF NOT HardError   AND Tc.CheckPassHardReadErrCount   AND Tc.HardReadErrorsInAPass>= Tc.MaxPassHardReadErrors THEN { st: expectedStatus¬ tooManyPassHardReadErrs;   ErrorCode ¬ ORD[st];   SoftError ¬ FALSE; HardError¬ TRUE; FruCode¬ 2824;   Io.IoCPA[cmdIdx].errorCode¬ st;   Io.IoCPA[cmdIdx].errorType¬ hardError; };  --now put all of this into the log or trace table DiagFlTapeLog.LogEvent[ 	cmdIdx: cmdIdx,	command: command]; --now check if retensioning is needed IF NOT HardError AND NOT Disaster AND softErrCntForRetntn >= maxRetntnCount THEN { DiagFlTapeCmds.RetentionFromErrCheck[];   IF Io.IoCPA[2].rtndStatus# goodCompletion THEN   { st¬ retentionErr;     ErrorCode ¬ ORD[st];     SoftError ¬ FALSE; HardError¬ TRUE; FruCode¬ 2826;     Io.IoCPA[2].errorCode¬ st;     Io.IoCPA[2].errorType¬ hardError;   };   softErrCntForRetntn¬ 0;   --now put all of this into the log or trace table   DiagFlTapeLog.LogEvent[ 	cmdIdx: 2,	command: retntn]; }; --now let the caller cleanup on a hard error before calling service IF NOT Disaster   AND HardError   AND NeedToCleanup   AND NOT DiagFlTapeRunCmdFile.RunningUserCmdFile THEN SIGNAL Cleanup; IF Tc.SignalOnSoftErrInTable   AND (BadPageInTable OR SoftErrInTable)   AND NOT HardError THEN     SIGNAL Tc.SoftErrorInTable; IF Tc.SignalOnSoftError    AND NOT BadPageInTable    AND NOT SoftErrInTable    AND SoftError THEN SIGNAL Tc.SoftError; IF Tc.ReturnOnSoftError AND SoftError THEN   SIGNAL Tc.ReturningOnSoftError; IF Tc.ReturnOnHardError AND HardError THEN   SIGNAL Tc.ReturningOnHardError; IF Tc.ReturnAfterCommand THEN   SIGNAL Tc.ReturningAfterCommand; IF NOT Disaster AND HardError AND Tc.ContinueOnHardError THEN RETURN; IF NOT Disaster AND SoftError AND Tc.ContinueOnSoftError THEN RETURN;  -- call service/display error IF NOT DiagFlTapeRunCmdFile.RunningUserCmdFile   AND (Disaster OR HardError) THEN   IF Tc.DisplaySummaryOnHardErr THEN     DiagFlTapeTests.DisplayError[        cmdIdx: cmdIdx, 	command: command] ELSE       DiagFlTapeOpInt.CallService[fruCode: FruCode]; END;  --LogAndOrReport -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- initializes the error checking arrays -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ InitErrorCheck: PUBLIC PROCEDURE [clearSoftErrors: BOOLEAN¬ FALSE] = BEGIN Tc.SoftErrorsInAPass¬ 0; Tc.HardReadErrorsInAPass¬ 0; NumOfSoftErrs¬ 0; NumOfHardReadErrs¬ 0; NumOfBadPages¬ 0; softErrCntForRetntn¬ 0; FOR c: CARDINAL IN [0..512) DO   SoftErrCntBuffPtr­[c]¬ 0; ENDLOOP; END; --InitErrorCheck -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ --   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ThisIsARealSoftError: PROC[cmdIdx: CARDINAL] RETURNS [BOOLEAN¬ FALSE] = BEGIN IF Tc.IgnoreSoftErrors THEN RETURN; BadPage¬ GenBadPageNumber[cmdIdx: cmdIdx]; -- is the error in the bad page table IF Tc.CheckBadPageTable AND BadPageIsInTable[BadPage] THEN RETURN; -- was error already found IF Tc.CheckSoftErrTable AND SoftErrIsInTable[BadPage] THEN RETURN; KeepSoftErr[BadPage]; RETURN[TRUE];  END; --of ThisIsARealSoftError -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- create the bad page number from the returned IO command parameters -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GenBadPageNumber: PROCEDURE [cmdIdx: CARDINAL] 	RETURNS [page: LONG CARDINAL] = BEGIN --note: track here= cylinder & head count=1 and can be ignored page¬ Io.IoCPA[cmdIdx].opPtr­.address.cylinder- Io.MinTrack; page¬ (page* Io.SectorsPerTrack)+   Io.IoCPA[cmdIdx].opPtr­.address.sector- Io.MinSector; page¬ page+ 1; --bad pages start at 1 instead of 0 END;  --off GenBadPageNumber -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- create the bad page number from the returned IO command parameters -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BadPageIsInTable: PROCEDURE [badPage: LONG CARDINAL] RETURNS [BOOLEAN¬ FALSE]= BEGIN c: CARDINAL¬ 0; UNTIL c= NumOfBadPages DO   IF badPage= BadPageBuffPtr­[c] THEN   { BadPageInTable¬ TRUE;     RETURN[TRUE];   };   c¬ c+ 1; ENDLOOP; END;  --off BadPageIsInTable -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- create the bad page number from the returned IO command parameters -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SoftErrIsInTable: PROCEDURE [	badPage: LONG CARDINAL,	countOcurrence: BOOLEAN¬ TRUE]      RETURNS [BOOLEAN¬ FALSE]= BEGIN c: CARDINAL¬ 0; UNTIL c= NumOfSoftErrs OR c =512 DO   IF badPage= SoftErrBuffPtr­[c] THEN   { SoftErrInTable¬ TRUE;     IF countOcurrence THEN  SoftErrCntBuffPtr­[c]¬ SoftErrCntBuffPtr­[c]+ 1;     RETURN[TRUE];   };   c¬ c+ 1; ENDLOOP; END;  --off SoftErrIsInTable -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- create the bad page number from the returned IO command parameters -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ KeepSoftErr: PROCEDURE [badPage: LONG CARDINAL ,countOcurrence: BOOLEAN¬ TRUE] = BEGIN c:	CARDINAL¬ 0; inTbl:	BOOLEAN¬ FALSE; IF NumOfSoftErrs>=512 THEN NumOfSoftErrs¬ NumOfSoftErrs+ 1 ELSE { UNTIL c= NumOfSoftErrs OR c =512 OR inTbl DO     IF badPage= SoftErrBuffPtr­[c] THEN inTbl¬ TRUE ELSE c¬ c+ 1;   ENDLOOP;   IF inTbl THEN     SoftErrCntBuffPtr­[c]¬ SoftErrCntBuffPtr­[c]+ 1 ELSE     { SoftErrBuffPtr­[NumOfSoftErrs]¬ badPage;       SoftErrCntBuffPtr­[NumOfSoftErrs]¬ SoftErrCntBuffPtr­[NumOfSoftErrs]+ 1;       NumOfSoftErrs¬ NumOfSoftErrs+ 1;     }; };    END;  --off KeepSoftErr -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- create the bad page number from the returned IO command parameters -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ KeepHardReadErr: PROCEDURE [badPage: LONG CARDINAL] = BEGIN c:	CARDINAL¬ 0; inTbl:	BOOLEAN¬ FALSE; IF NumOfHardReadErrs>=128 THEN NumOfHardReadErrs¬ NumOfHardReadErrs+ 1 ELSE { UNTIL c= NumOfHardReadErrs OR c =128 OR inTbl DO     IF badPage= HardReadErrBuffPtr­[c] THEN inTbl¬ TRUE ELSE c¬ c+ 1;   ENDLOOP;   IF NOT inTbl THEN     { HardReadErrBuffPtr­[NumOfHardReadErrs]¬ badPage;       NumOfHardReadErrs¬ NumOfHardReadErrs+ 1;     }; };    END;  --off KeepHardReadErr -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- main line Code -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ECNull ¬ [   last,			--  Note: The compiler does not like single    last];			--        entries in an array. ECStandard1¬ [   cmdTimedOutFalse,   diskChangeFalse,   cylinderErrorFalse,   memoryErrorFalse,   abortedFalse,   invalidOperationFalse,   notReadyFalse,   writeFaultFalse,   otherErrorFalse,      recordNotFoundFalse,   headerErrorFalse,   dataErrorFalse,   dataLostFalse,   deletedDataFalse,    inProgressFalse,   goodCompletionTrue,   countLeftErrFalse,   dataVerifyErrorFalse,   iDVerifyErrorFalse   ]; ECExpctDtErr¬ [   cmdTimedOutFalse,   diskChangeFalse,   cylinderErrorFalse,   memoryErrorFalse,   abortedFalse,   invalidOperationFalse,   notReadyFalse,   writeFaultFalse,   otherErrorFalse,      recordNotFoundFalse,   headerErrorFalse,   dataErrorFalse,   dataLostFalse,   deletedDataFalse,    inProgressFalse,   goodCompletionTrue,   countLeftErrFalse,   dataVerifyErrorTrue,   iDVerifyErrorFalse   ]; PublicStatusCheckArray¬ DESCRIPTOR[ECNull];  --create the bad page buffer space and pointer BadPageBuffPtr¬ LOOPHOLE[Space.ScratchMap[count: 4]]; SoftErrBuffPtr¬ LOOPHOLE[Space.ScratchMap[count: 4]]; SoftErrCntBuffPtr¬ Space.ScratchMap[count: 2]; HardReadErrBuffPtr¬ LOOPHOLE[Space.ScratchMap[count: 1]]; END... --of DiagFlTapeErrorCheckImplLOG17-Feb-88 11:38:11 JMA: changed test for count error on format track.10-Mar-88 14:26:32 JMA: added Dove-specific error codes. 9-Aug-88 17:24:12 PJT: Doing retention with record not found.23-Aug-88  8:43:57 PJT: added 3 dataLosts then HardError
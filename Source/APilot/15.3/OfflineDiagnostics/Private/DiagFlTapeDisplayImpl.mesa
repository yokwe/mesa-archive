-- Copyright (C) 1987  by Xerox Corporation. All rights reserved. -- -- File: DiagFlTapeDisplayImpl.mesa-- Edited by: PJT  4-Jan-89 11:12:52--   DIRECTORY  DiagFlTapeTTY	USING	[Initialize, GetYesNo, PutLongNumber,				 PutCR, PutChar, PutLine, PutMessage,				 PutNumber, PutSpaces, PutString,				 CursorAtStartPosition],  DiagFlTapeOpInt	USING	[ProceedOnInput, CallService],  DiagFlTapeCmds	USING	[RdBuffArray, LastReadCmdIdx, LastReadSize,				 WrBuffArray, LastWriteCmdIdx, LastWriteSize,				 RdIDBuffArray, LastReadIDCmdIdx, IDBuffHasData,				 IOCmdContext, LastReadStatus, StatusHasData,				 SectorsPerStream, SectorsPerTrack,				 SectorsPerTape, ReadBuffPtr1],  DiagFlTapeMkMenu	USING	[mkMenu],  DiagFlTapeMkDispl	USING	[mkDispl],  DiagFlTapeMkIOCmd	USING	[mkIOCmd],  DiagFlTapeMkOpInt	USING	[mkOpInt],  DiagFlTapeTestRec	USING	[Subtest, Subtests],  DiagFlTapeDisplay	USING	[],  DiagFlTapeTests	USING	[ReadBadPageTable],  DiagFlTapeTestSelect	USING	[currentOptDispl],  Environment		USING	[wordsPerPage],  FloppyTapeFormat	USING	[RootPage, maxNumberBadSectors],  Inline		USING	[LowHalf],  OfflineDiagInterface	USING   [GetAnOption],  String		USING	[AppendNumber, AppendLongNumber, AppendString];  DiagFlTapeDisplayImpl: PROGRAM    IMPORTS	DiagFlTapeTTY,	DiagFlTapeOpInt,	DiagFlTapeCmds,	DiagFlTapeMkMenu,	DiagFlTapeMkDispl,	DiagFlTapeMkIOCmd,	DiagFlTapeMkOpInt,	DiagFlTapeTestRec,	DiagFlTapeTests,	DiagFlTapeTestSelect,	Inline,	OfflineDiagInterface,	String    EXPORTS    	DiagFlTapeDisplay =  BEGIN    OPEN	DiagFlTapeMkMenu,	DiagFlTapeMkDispl,	DiagFlTapeMkOpInt,	DiagFlTapeMkIOCmd,	Odi: OfflineDiagInterface;  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- to dump any portion of memory  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  DumpMemory: PUBLIC PROCEDURE [    title: LONG DESCRIPTOR FOR ARRAY OF LONG STRING ¬ DESCRIPTOR[NIL, 0],    ptr: LONG POINTER TO ARRAY OF WORD¬ NIL,    words: CARDINAL ¬ 0] =    BEGIN    cnt: CARDINAL;    dataword: CARDINAL;    datawordptr: CARDINAL;    linecount: CARDINAL;    charperline: CARDINAL;    string: STRING ¬ [8];    string1: STRING ¬ [8];    string2: STRING ¬ "HEX COUNT  0     1     2     3     4     5     6     7"L;    --check if the buffer is empty  IF words=0 THEN   { DiagFlTapeTTY.PutChar[32C];    DiagFlTapeTTY.PutLine[mkDispl[buffEmpty]];    DiagFlTapeOpInt.ProceedOnInput[];    RETURN;  };    -- clean up display and just show the current option table  IF DiagFlTapeTestSelect.currentOptDispl # NIL THEN    []¬ Odi.GetAnOption [optionTable: DiagFlTapeTestSelect.currentOptDispl,    		     optionPrompt: " "L, justDisplayTable: TRUE];    --output the title    DiagFlTapeTTY.PutChar[32C];    IF BASE[title] # NIL THEN {      cnt ¬ 0;      UNTIL cnt = LENGTH[title] DO        IF title[cnt] # NIL THEN DiagFlTapeTTY.PutLine[title[cnt]]; cnt ¬ cnt + 1; ENDLOOP};    --output column headings    DiagFlTapeTTY.PutLine[string2];    DiagFlTapeTTY.PutLine[    "******  **********************************************"L];    --output data    datawordptr ¬ 0;    UNTIL datawordptr >= words DO      linecount ¬ 0;--    UNTIL linecount >= 16 DO      UNTIL linecount >= 8 DO        string.length ¬ 0;        String.AppendNumber[string, datawordptr, 16];        SELECT string.length FROM          1 => DiagFlTapeTTY.PutString["000"L];          2 => DiagFlTapeTTY.PutString["00"L];          3 => DiagFlTapeTTY.PutString["0"L];        ENDCASE;        DiagFlTapeTTY.PutString[string];        DiagFlTapeTTY.PutSpaces[4];        charperline ¬ 0;        UNTIL charperline >= 16 DO          dataword ¬ ptr­[datawordptr];          string.length ¬ 0;          string1.length ¬ 0;          String.AppendNumber[string1, dataword, 16];          IF string1.length = 1 THEN String.AppendString[string, "000"L];          IF string1.length = 2 THEN String.AppendString[string, "00"L];          IF string1.length = 3 THEN String.AppendString[string, "0"L];          String.AppendString[string, string1];          FOR i: CARDINAL IN [0..4) DO DiagFlTapeTTY.PutChar[string[i]] ENDLOOP;	  DiagFlTapeTTY.PutSpaces[2];          charperline ¬ charperline + 2;          datawordptr ¬ datawordptr + 1;        ENDLOOP;  --for charperline>= 16        DiagFlTapeTTY.PutCR[];        linecount ¬ linecount + 1;      ENDLOOP;  --for linecount      IF datawordptr >= words THEN {	DiagFlTapeOpInt.ProceedOnInput[];        RETURN};      DiagFlTapeTTY.PutCR[];      IF NOT DiagFlTapeTTY.GetYesNo[      	prompt: mkDispl[moreYN], defaultYes: TRUE] THEN        RETURN      ELSE {        DiagFlTapeTTY.PutChar[32C];        DiagFlTapeTTY.PutLine[string2];        DiagFlTapeTTY.PutCR[]};      ENDLOOP;  --for end of data words  END;  --DumpMemory -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- converts a cardinal to a string -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CardinalToHexString: PUBLIC PROCEDURE [ 		number: CARDINAL,		sizeInDigits: CARDINAL¬ 4, 		string: LONG STRING¬ NIL] = BEGIN strT: STRING ¬ [8];  strT.length ¬ 0; string.length ¬ 0; String.AppendNumber[strT, number, 16]; IF sizeInDigits= 4 THEN { SELECT strT.length FROM     1 => String.AppendString[string, "000"L];     2 => String.AppendString[string, "00"L];     3 => String.AppendString[string, "0"L];   ENDCASE; } ELSE  IF sizeInDigits= 2 THEN { IF strT.length= 1 THEN     String.AppendString[string, "0"L]; }; String.AppendString[string, strT];  END;  --CardinalToHexString -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the receive buffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LastReadID: PUBLIC PROCEDURE = BEGIN title:		ARRAY [0..0] OF LONG STRING¬ [mkDispl[iDBuffDisplaY]];   --check if the buffer is empty  IF NOT DiagFlTapeCmds.IDBuffHasData THEN   { DiagFlTapeTTY.PutChar[32C];    DiagFlTapeTTY.PutLine[mkDispl[iDBuffEmptY]];    DiagFlTapeOpInt.ProceedOnInput[];    RETURN;  }; DumpMemory[   title: DESCRIPTOR[title],   ptr: DiagFlTapeCmds.RdIDBuffArray[DiagFlTapeCmds.LastReadIDCmdIdx],   words: 8]; END; --LastReadID -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the receive buffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ReadData: PUBLIC PROCEDURE = BEGIN title:		ARRAY [0..0] OF LONG STRING¬ [mkDispl[readBuffDisplaY]];      --check if the buffer is empty  IF DiagFlTapeCmds.LastReadSize= 0 THEN   { DiagFlTapeTTY.PutChar[32C];    DiagFlTapeTTY.PutLine[mkDispl[readBuffEmptY]];    DiagFlTapeOpInt.ProceedOnInput[];    RETURN;  }; DumpMemory[   title: DESCRIPTOR[title],   ptr: DiagFlTapeCmds.RdBuffArray[DiagFlTapeCmds.LastReadCmdIdx],   words: DiagFlTapeCmds.LastReadSize*Environment.wordsPerPage]; END; --ReadData -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the transmit buffer -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ WriteData: PUBLIC PROCEDURE = BEGIN title:	ARRAY [0..0] OF LONG STRING¬ [mkDispl[writeBuffDisplaY]];     --check if the buffer is empty  IF DiagFlTapeCmds.LastWriteSize= 0 THEN   { DiagFlTapeTTY.PutChar[32C];    DiagFlTapeTTY.PutLine[mkDispl[writeBuffEmptY]];    DiagFlTapeOpInt.ProceedOnInput[];    RETURN;  }; DumpMemory[   title: DESCRIPTOR[title],   ptr: DiagFlTapeCmds.WrBuffArray[DiagFlTapeCmds.LastWriteCmdIdx],   words: DiagFlTapeCmds.LastWriteSize*Environment.wordsPerPage]; END; --WriteData -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the context -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Context: PUBLIC PROCEDURE = BEGIN --clear the screen and display the title DiagFlTapeTTY.PutChar[32C]; DiagFlTapeTTY.PutLine[mkDispl[contextDisplaY]]; DiagFlTapeTTY.PutCR[];  --display if software protected DiagFlTapeTTY.PutString[mkIOCmd[protect]]; IF DiagFlTapeCmds.IOCmdContext.floppyTapeContext.protect THEN   DiagFlTapeTTY.PutLine[mkDispl[truE]] ELSE     DiagFlTapeTTY.PutLine[mkDispl[falsE]]; --display the format type DiagFlTapeTTY.PutString[mkIOCmd[format]]; --{IBM, Troy} IF DiagFlTapeCmds.IOCmdContext.floppyTapeContext.format= IBM THEN   DiagFlTapeTTY.PutLine[mkIOCmd[iBM]]; IF DiagFlTapeCmds.IOCmdContext.floppyTapeContext.format= Troy THEN   DiagFlTapeTTY.PutLine[mkIOCmd[troy]]; --display the density DiagFlTapeTTY.PutString[mkIOCmd[density]]; --{single, double} IF DiagFlTapeCmds.IOCmdContext.floppyTapeContext.density= single THEN   DiagFlTapeTTY.PutLine[mkIOCmd[single]]; IF DiagFlTapeCmds.IOCmdContext.floppyTapeContext.density= double THEN   DiagFlTapeTTY.PutLine[mkIOCmd[double]]; --display the sector length in words DiagFlTapeTTY.PutString[mkIOCmd[sectLngInWrds]]; --Length in words DiagFlTapeTTY.PutNumber[   DiagFlTapeCmds.IOCmdContext.floppyTapeContext.sectorLength]; DiagFlTapeTTY.PutCR[count: 2]; DiagFlTapeOpInt.ProceedOnInput[]; END; --Context -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the device status -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SoftError: PUBLIC PROCEDURE[	title: LONG STRING¬ NIL,	badPage: LONG CARDINAL,	timesTried: CARDINAL¬ 0,	timesFailed: CARDINAL¬ 0] = BEGIN strs:  ARRAY [0..1] OF LONG STRING; str1: STRING ¬ [80]; stream: CARDINAL; track: CARDINAL; sector: CARDINAL;  IF title# NIL THEN strs[0]¬ title;  [stream: stream, track: track, sector: sector]¬    PageToTapeParams[badPage: badPage]; str1.length¬ 0; String.AppendString[str1, mkIOCmd[page]]; String.AppendLongNumber[str1, badPage]; String.AppendString[str1, mkIOCmd[paramSeparator]]; String.AppendString[str1, mkIOCmd[stream]]; String.AppendNumber[str1, stream]; String.AppendString[str1, mkIOCmd[paramSeparator]]; String.AppendString[str1, mkIOCmd[track]]; String.AppendNumber[str1, track]; String.AppendString[str1, mkIOCmd[paramSeparator]]; String.AppendString[str1, mkIOCmd[sector]]; String.AppendNumber[str1, sector];  IF timesTried# 0 THEN { String.AppendString[str1, mkIOCmd[paramSeparator]];   String.AppendString[str1, mkIOCmd[timesTried]];   String.AppendNumber[str1, timesTried]; }; IF timesFailed# 0 THEN { String.AppendString[str1, mkIOCmd[paramSeparator]];   String.AppendString[str1, mkIOCmd[timesFailed]];   String.AppendNumber[str1, timesFailed]; }; strs[1]¬ str1; DiagFlTapeTTY.PutMessage[strArray: DESCRIPTOR[strs]]; DiagFlTapeTTY.CursorAtStartPosition¬ TRUE;  END; --of SoftError -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the device status -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ErrorTable: PUBLIC PROCEDURE[   title: LONG STRING¬ NIL,   errorCount: CARDINAL,   errorBuff: LONG DESCRIPTOR FOR ARRAY OF LONG CARDINAL¬ DESCRIPTOR[NIL, 0],   errorCountBuff: LONG DESCRIPTOR FOR ARRAY OF CARDINAL¬ DESCRIPTOR[NIL, 0]] = BEGIN sCnt: CARDINAL¬ 0; cnt: CARDINAL¬ 0; stream: CARDINAL; track: CARDINAL; sector: CARDINAL;  IF errorCount= 0 THEN { DiagFlTapeTTY.PutChar[32C]; -- clears screen   DiagFlTapeTTY.PutLine[mkDispl[errTblEmpty]];   DiagFlTapeOpInt.ProceedOnInput[];   RETURN; };  -- the error buffer can only hold 512 entries [0..511] IF errorCount> LENGTH[errorBuff] THEN errorCount¬ LENGTH[errorBuff];  UNTIL sCnt= errorCount DO   -- display title first   DiagFlTapeTTY.PutChar[32C];   IF title# NIL THEN     DiagFlTapeTTY.PutLine[title] ELSE        DiagFlTapeTTY.PutCR[];   cnt ¬ 0;   UNTIL cnt>= 20 OR sCnt>=errorCount DO     -- display one soft error     [stream: stream, track: track, sector: sector]¬        PageToTapeParams[badPage: errorBuff[sCnt]];     -- display the page     DiagFlTapeTTY.PutString[mkIOCmd[page]];     DiagFlTapeTTY.PutLongNumber[number: errorBuff[sCnt], size: 5];     DiagFlTapeTTY.PutString[mkIOCmd[paramSeparator]];     -- display the stream     DiagFlTapeTTY.PutString[mkIOCmd[stream]];     DiagFlTapeTTY.PutNumber[number: stream];     DiagFlTapeTTY.PutString[mkIOCmd[paramSeparator]];     -- display the track     DiagFlTapeTTY.PutString[mkIOCmd[track]];     DiagFlTapeTTY.PutNumber[number: track, size: 3];     DiagFlTapeTTY.PutString[mkIOCmd[paramSeparator]];     -- display the sector     DiagFlTapeTTY.PutString[mkIOCmd[sector]];     DiagFlTapeTTY.PutNumber[number: sector];     -- display the times failed     IF BASE[errorCountBuff]# NIL THEN     { DiagFlTapeTTY.PutString[mkIOCmd[paramSeparator]];       DiagFlTapeTTY.PutString[mkIOCmd[timesFailed]];       DiagFlTapeTTY.PutNumber[number: errorCountBuff[sCnt]];     };     DiagFlTapeTTY.PutCR[];     cnt ¬ cnt + 1;     sCnt ¬ sCnt + 1;   ENDLOOP;   IF sCnt< errorCount THEN     IF NOT DiagFlTapeTTY.GetYesNo[       prompt: mkDispl[moreYN],       defaultYes: TRUE] THEN RETURN; ENDLOOP; DiagFlTapeOpInt.ProceedOnInput[]; END; --of ErrorTable -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the device status -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ BadPageTable: PUBLIC PROCEDURE = BEGIN cnt: CARDINAL¬ 0; num: CARDINAL; stream: CARDINAL; track: CARDINAL; sector: CARDINAL; noMore: BOOLEAN¬ FALSE; ptr: LONG POINTER TO FloppyTapeFormat.RootPage¬	LOOPHOLE[DiagFlTapeCmds.ReadBuffPtr1]; bdPgCnt: CARDINAL; bdPg: LONG CARDINAL; bdPgPtr: LONG POINTER TO ARRAY OF WORD¬ DiagFlTapeCmds.ReadBuffPtr1+ 256; idx: CARDINAL¬ 0; --read the bad page table DiagFlTapeTests.ReadBadPageTable[]; bdPgCnt¬ ptr­.numberOfBadPages;  IF bdPgCnt= 0 THEN { DiagFlTapeTTY.PutChar[32C]; -- clears screen   DiagFlTapeTTY.PutLine[mkDispl[badPageTblEmpty]];   DiagFlTapeOpInt.ProceedOnInput[];   RETURN; };  --check if this looks like a good bad page table IF bdPgCnt> FloppyTapeFormat.maxNumberBadSectors THEN GOTO exit; UNTIL cnt>=bdPgCnt OR cnt= 512 DO   --get a page   num¬ bdPgPtr­[idx+1];   --check for bum number-- IF num>4 OR num IN[1..3] THEN GOTO exit;-- IF num= 4 THEN bdPg¬ 65536 ELSE bdPg¬ 0;-- AR 13631 fix   IF num > 7 THEN GOTO exit;   IF num >= 4 THEN bdPg¬ 65536 ELSE bdPg¬ 0;   num¬ bdPgPtr­[idx];   bdPg¬ bdPg+ num;   --check for bum numbers   IF bdPg= 0 OR bdPg> DiagFlTapeCmds.SectorsPerTape THEN GOTO exit;   idx¬ idx + 2;   cnt¬ cnt+ 1; ENDLOOP;  --now display the bad page table idx¬ 0; UNTIL noMore OR idx>=bdPgCnt*2  DO   -- display title first   DiagFlTapeTTY.PutChar[32C];   DiagFlTapeTTY.PutLine[mkDispl[badPageDspL]];   cnt ¬ 0;   UNTIL cnt>= 20 OR idx=bdPgCnt*2 DO     --get a page     num¬ bdPgPtr­[idx+1];     IF num>3 THEN bdPg¬ 65536 ELSE bdPg¬ 0;     num¬ bdPgPtr­[idx];     bdPg¬ bdPg+ num;     -- display one soft error     [stream: stream, track: track, sector: sector]¬        PageToTapeParams[badPage: bdPg];     -- display the page     DiagFlTapeTTY.PutString[mkIOCmd[page]];     DiagFlTapeTTY.PutLongNumber[number: bdPg, size: 5];     DiagFlTapeTTY.PutString[mkIOCmd[paramSeparator]];     -- display the stream     DiagFlTapeTTY.PutString[mkIOCmd[stream]];     DiagFlTapeTTY.PutNumber[number: stream];     DiagFlTapeTTY.PutString[mkIOCmd[paramSeparator]];     -- display the track     DiagFlTapeTTY.PutString[mkIOCmd[track]];     DiagFlTapeTTY.PutNumber[number: track, size: 3];     DiagFlTapeTTY.PutString[mkIOCmd[paramSeparator]];     -- display the sector     DiagFlTapeTTY.PutString[mkIOCmd[sector]];     DiagFlTapeTTY.PutNumber[number: sector];     DiagFlTapeTTY.PutCR[];      idx¬ idx + 2;     cnt ¬ cnt + 1;   ENDLOOP;   IF idx<bdPgCnt*2 THEN     IF NOT DiagFlTapeTTY.GetYesNo[       prompt: mkDispl[moreYN],       defaultYes: TRUE] THEN noMore¬ TRUE; ENDLOOP; IF NOT noMore THEN DiagFlTapeOpInt.ProceedOnInput[];  EXITS   exit=>   { DiagFlTapeTTY.PutCR[];     DiagFlTapeTTY.PutLine[mkMenu[canNotRdBadPgTbl]];     DiagFlTapeOpInt.CallService[fruCode: 2827];   };    END; --of BadPageTable -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the device status -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PageToTapeParams: PROCEDURE[badPage: LONG CARDINAL] 	RETURNS[stream: CARDINAL, track: CARDINAL, sector: CARDINAL] = BEGIN cnt: CARDINAL ¬ 0;  UNTIL badPage<= DiagFlTapeCmds.SectorsPerStream DO   badPage¬ badPage- DiagFlTapeCmds.SectorsPerStream;   cnt ¬ cnt + 1; ENDLOOP; stream ¬ cnt+ 1; -- stream count starts at 1 cnt ¬ 0; UNTIL badPage<= DiagFlTapeCmds.SectorsPerTrack DO   badPage¬ badPage- DiagFlTapeCmds.SectorsPerTrack;   cnt ¬ cnt + 1; ENDLOOP; track¬ cnt; --track count starts at 0 sector¬ Inline.LowHalf[badPage];  END; --of PageToTapeParams -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the device status -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LastReadStatus: PUBLIC PROCEDURE = BEGIN LogStatus[clearScreen: TRUE]; END; --of LastReadStatus -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the device status -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ LogStatus: PUBLIC PROCEDURE[clearScreen: BOOLEAN¬ FALSE] = BEGIN  IF clearScreen THEN { DiagFlTapeTTY.Initialize[];   DiagFlTapeTTY.PutCR[]; }; IF NOT DiagFlTapeCmds.StatusHasData THEN { DiagFlTapeTTY.PutLine[mkDispl[statusIsEmptY]];   DiagFlTapeTTY.PutCR[count: 1];   DiagFlTapeOpInt.ProceedOnInput[];   RETURN; };  --display title DiagFlTapeTTY.PutLine[mkDispl[returnedStatuS]]; SELECT DiagFlTapeCmds.LastReadStatus FROM   inProgress=> DiagFlTapeTTY.PutLine[mkDispl[inProgress]];   goodCompletion=> DiagFlTapeTTY.PutLine[mkDispl[goodCompletion]];   diskChange=> DiagFlTapeTTY.PutLine[mkDispl[diskChange]];   notReady=> DiagFlTapeTTY.PutLine[mkDispl[notReady]];   cylinderError=> DiagFlTapeTTY.PutLine[mkDispl[cylinderError]];   deletedData=> DiagFlTapeTTY.PutLine[mkDispl[deletedData]];   recordNotFound=> DiagFlTapeTTY.PutLine[mkDispl[recordNotFound]];   headerError=> DiagFlTapeTTY.PutLine[mkDispl[headerError]];   dataError=> DiagFlTapeTTY.PutLine[mkDispl[dataError]];   dataLost=> DiagFlTapeTTY.PutLine[mkDispl[dataLost]];   writeFault=> DiagFlTapeTTY.PutLine[mkDispl[writeFault]];   memoryError=> DiagFlTapeTTY.PutLine[mkDispl[memoryError]];   invalidOperation => DiagFlTapeTTY.PutLine[mkDispl[invalidOperation]];   aborted=> DiagFlTapeTTY.PutLine[mkDispl[aborted]];   otherError=> DiagFlTapeTTY.PutLine[mkDispl[otherError]]; ENDCASE; DiagFlTapeTTY.PutCR[count: 1]; DiagFlTapeOpInt.ProceedOnInput[];  END;  --LogStatus -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- to display the names of the available subtests -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Subtests: PUBLIC PROCEDURE = BEGIN cnt: CARDINAL; sTcnt: CARDINAL ¬ 1; UNTIL sTcnt >= ORD[LAST[DiagFlTapeTestRec.Subtest]] DO   -- display title first   DiagFlTapeTTY.PutChar[32C];   DiagFlTapeTTY.PutLine[mkDispl[availableSubtests]];   cnt ¬ 0;   UNTIL cnt >= 20 OR sTcnt > ORD[LAST[DiagFlTapeTestRec.Subtest]] DO     DiagFlTapeTTY.PutNumber[	number:		sTcnt,	terminateWith:	mkOpInt[entryNumberEnding],	size:		4];     DiagFlTapeTTY.PutLine[       string: DiagFlTapeTestRec.Subtests[VAL[sTcnt]].title];     cnt ¬ cnt + 1;     sTcnt ¬ sTcnt + 1;   ENDLOOP;   IF sTcnt < ORD[LAST[DiagFlTapeTestRec.Subtest]] THEN     IF NOT DiagFlTapeTTY.GetYesNo[       prompt: mkDispl[moreYN],       defaultYes: TRUE] THEN RETURN; ENDLOOP; DiagFlTapeOpInt.ProceedOnInput[]; END;  --Subtests  END...       LOG19-Feb-88 12:19:05 JMA: added data display clearing code. 4-Jan-89 11:12:01 PJT: AR 13631 fix              
-- Copyright (C) 1986, 1987 by Xerox Corporation.  All rights reserved.---- File: DiagFlTapeOpIntImpl.mesa-- Last edited by: JMA 14-Mar-88 13:36:23-- DIRECTORY--  DiagFlTapeCmds	USING	[MaxUnit, Unit], DiagFlTapeMkMenu	USING	[mkMenu], DiagFlTapeMkOpInt	USING	[mkOpInt], DiagFlTapeTestSelect	USING	[Restart], DiagFlTapeTTY		USING	[CheckIfUserAbort, GetTime, GetYesNo,				 Initialize, PutNumber, PutLine, PutCR,				 PutSpaces, PutString, ProceedOnInput], String			USING	[AppendString], DiagFlTapeOpInt	USING	[], OfflineDiagInterface	USING	[ARow, FixedPositionDisplayRecord, 				 GetAFixedPositionDisplayRecord, GetAHelpText,				 GetARow, GetANumber, HelpText, userType,				 PutMessage, PutData, PutTestParameters ];   DiagFlTapeOpIntImpl: PROGRAM     IMPORTS	DiagFlTapeMkMenu,	DiagFlTapeMkOpInt,	DiagFlTapeTestSelect,	DiagFlTapeTTY,	OfflineDiagInterface,	String    EXPORTS	DiagFlTapeOpInt =BEGIN OPEN   DiagFlTapeMkMenu,   DiagFlTapeMkOpInt,   Odi: OfflineDiagInterface;  DeviceError:		PUBLIC ERROR= CODE; User:			PUBLIC BOOLEAN¬ FALSE; SystemAdmin:		PUBLIC BOOLEAN¬ FALSE; TechRep:		PUBLIC BOOLEAN¬ FALSE; TechSpec:		PUBLIC BOOLEAN¬ FALSE; Manufacturing:		PUBLIC BOOLEAN¬ FALSE; Engineering:		PUBLIC BOOLEAN¬ FALSE; PassCount:		PUBLIC CARDINAL¬ 0; Switch:		PUBLIC ARRAY [0..128) OF BOOLEAN¬ ALL [FALSE]; ChannelRunArray:	PUBLIC ARRAY [0..3] OF BOOLEAN¬ ALL [FALSE];  testCharPosition:	CARDINAL¬ 0; MaxChannel:		PUBLIC CARDINAL¬ 3; 	--from DiagFlTapeCmds Channel:		PUBLIC CARDINAL¬ 0;	--from DiagFlTapeCmds -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- clears the user and password -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ClearLogIn: PUBLIC PROCEDURE = BEGIN << User		¬ FALSE; SystemAdmin	¬ FALSE; TechRep	¬ FALSE; TechSpec	¬ FALSE; Manufacturing	¬ FALSE; Engineering	¬ FALSE; Switch		¬ ALL [FALSE]; >> Odi.PutMessage [message: "DFTOptInt.ClearLogIn"L];  END; --ClearLogIn -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- displays MP Code and call for service message if not user or system admin -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  CallService: PUBLIC PROCEDURE [fruCode: CARDINAL¬ 0] =  BEGIN  userAbort: BOOLEAN¬ FALSE;    DiagFlTapeTTY.PutCR [count: 1];  Odi.PutMessage [message: mkOpInt[errorDetected], beep: TRUE];  IF SystemAdmin OR User THEN  { Odi.PutMessage [message: mkOpInt[callService1]];    Odi.PutMessage [message: mkOpInt[callService2]];    Odi.PutMessage [message: mkOpInt[thankYou]];  } ELSE  { Odi.PutMessage [message: mkOpInt[seeMPCode], startWithNewLine: FALSE];  };    --ProcessorFace.SetMP[fruCode];  -- don't use MP code, instead use data section of display.  Odi.PutData [data: mkOpInt[errorCode], numberAfterData: LONG [fruCode],  	       clearHeadingAndData: TRUE, clearDataAreaOnly: TRUE,	       startWithNewLine: TRUE];    UNTIL userAbort DO    DiagFlTapeTTY.CheckIfUserAbort[];  ENDLOOP;    END; --CallService -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- displays MP Code and call for service message if not user or system admin -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ DisplayTestParameters: PUBLIC PROCEDURE [ 	testTitle: LONG STRING, 	firstPass: BOOLEAN¬ TRUE,	passCountTotal: CARDINAL¬ 0,	passCountRemaining: CARDINAL¬ 0,	timePerPass: CARDINAL,	subtestTitle: BOOLEAN¬ TRUE] =	 BEGIN testParmRecordPtr:	LONG POINTER TO Odi.FixedPositionDisplayRecord; paramRow0:		LONG POINTER TO Odi.ARow; paramRow1:		LONG POINTER TO Odi.ARow; str:			STRING¬ [80]; timeStr1:		STRING¬ [32]; timeStr2:		STRING¬ [32]; entryPtr:		CARDINAL¬ 0;  SELECT TRUE FROM --one pass only: put pass count only passCountTotal= 1 AND timePerPass = 0      => {  	testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [1];   	testParmRecordPtr.rows[0] ¬ paramRow0 ¬ Odi.GetARow [1];   	paramRow0.rowItems[0].namePosition¬ 0;   	paramRow0.rowItems[0].name ¬ mkOpInt[passesTotal];  	paramRow0.rowItems[0].stringValue ¬ NIL;   	paramRow0.rowItems[0].valuePosition ¬ 2+ mkOpInt[passesTotal].length;   	paramRow0.rowItems[0].value ¬ passCountTotal	 };	  --one pass only: put pass count and runtime passCountTotal= 1 AND timePerPass > 0      =>	{ testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [2];  	 testParmRecordPtr.rows[0] ¬ paramRow0¬ Odi.GetARow [1];  	 testParmRecordPtr.rows[1] ¬ paramRow1¬ Odi.GetARow [1];  	 DiagFlTapeTTY.GetTime [seconds: timePerPass*passCountTotal, 	  	  			timeString: timeStr1];  	 paramRow0.rowItems[0].namePosition¬ 0; 	 paramRow0.rowItems[0].name ¬ mkOpInt[passesTotal];  	 paramRow0.rowItems[0].stringValue ¬ NIL;  	 paramRow0.rowItems[0].valuePosition ¬ 2+ mkOpInt[passesTotal].length;  	 paramRow0.rowItems[0].value ¬ passCountTotal;  	 paramRow1.rowItems[0].namePosition¬ 0; 	 paramRow1.rowItems[0].name ¬ mkOpInt[runTime]; 	 paramRow1.rowItems[0].stringValue ¬ timeStr1;  	 paramRow1.rowItems[0].valuePosition ¬ 0;  	 paramRow1.rowItems[0].value ¬ 0;	 }; --more than one pass: put pass count only passCountTotal> 1 AND timePerPass = 0      =>	{ testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [1];   	testParmRecordPtr.rows[0] ¬ paramRow0¬ Odi.GetARow [2];   	paramRow0.rowItems[0].namePosition¬ 0;   	paramRow0.rowItems[0].name ¬ mkOpInt[passesTotal];   	paramRow0.rowItems[0].stringValue ¬ NIL;   	paramRow0.rowItems[0].valuePosition ¬ 2+ mkOpInt[passesTotal].length;  	paramRow0.rowItems[0].value ¬ passCountTotal;   	paramRow0.rowItems[1].namePosition ¬ 60;   	paramRow0.rowItems[1].name ¬ mkOpInt[runTimeLeft];  	paramRow0.rowItems[1].stringValue ¬ NIL;   	paramRow0.rowItems[1].valuePosition ¬ 62+ mkOpInt[passesLeft].length;   	paramRow0.rowItems[1].value ¬ passCountRemaining; 	}; --more than one pass: put pass count and runtime passCountTotal> 1 AND timePerPass > 0    =>	{    	testParmRecordPtr¬ Odi.GetAFixedPositionDisplayRecord [2];  	testParmRecordPtr.rows[0] ¬ paramRow0¬ Odi.GetARow [2];   	testParmRecordPtr.rows[1] ¬ paramRow1¬ Odi.GetARow [2];   	paramRow0.rowItems[0].namePosition¬ 0;  	paramRow0.rowItems[0].name ¬ mkOpInt[passesTotal];  	paramRow0.rowItems[0].stringValue ¬ NIL;   	paramRow0.rowItems[0].valuePosition ¬ 2+ mkOpInt[passesTotal].length;  	paramRow0.rowItems[0].value ¬ passCountTotal;  	paramRow0.rowItems[1].namePosition ¬ 60;   	paramRow0.rowItems[1].name ¬ mkOpInt[passesLeft];  	paramRow0.rowItems[1].stringValue ¬ NIL;  	paramRow0.rowItems[1].valuePosition ¬ 62+ mkOpInt[passesLeft].length;  	paramRow0.rowItems[1].value ¬ PassCount;   	DiagFlTapeTTY.GetTime [seconds: timePerPass*passCountTotal, 	  	 			 timeString: timeStr1];  	paramRow1.rowItems[0].namePosition¬ 0;  	paramRow1.rowItems[0].name ¬ mkOpInt[runTime];  	paramRow1.rowItems[0].stringValue ¬ timeStr1;  	paramRow1.rowItems[0].valuePosition ¬ 0;  	paramRow1.rowItems[0].value ¬ 0;  	DiagFlTapeTTY.GetTime [seconds: timePerPass*passCountRemaining, 	    				timeString: timeStr2];  	paramRow1.rowItems[1].namePosition ¬ 60;  	paramRow1.rowItems[1].name ¬ mkOpInt[runTimeLeft];  	paramRow1.rowItems[1].stringValue ¬ timeStr2;  	paramRow1.rowItems[1].valuePosition ¬ 0;  	paramRow1.rowItems[1].value ¬ 0; 	};  ENDCASE;  testParmRecordPtr.displayTitle ¬ testTitle;  Odi.PutTestParameters [parameters: testParmRecordPtr, 			upDateOnly: FALSE];    << It should look like this:   testTitle      Totat pass count:  val		Pass count left:  val   Total run time:  string val		Run time left:  string val>>    -- clear screen and print parameters    Odi.PutTestParameters [testParmRecordPtr, FALSE];  END; --DisplayTestParameters -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the number of passes to be run -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetPassCount: PROCEDURE [		timePerPass: LONG CARDINAL¬ 0,  --in seconds		passExplanation: 		    LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0]]  =BEGIN questtext:		ARRAY [0..5] OF LONG STRING¬ ALL [NIL]; explcount:		CARDINAL¬ 0; queststr:		STRING¬ [79]; str:			STRING¬ [24]; help:			LONG POINTER TO Odi.HelpText ¬ NIL;    -- add the time to pass count explanation  IF timePerPass> 0 THEN  { queststr.length¬ 0;    String.AppendString [queststr, mkOpInt[passesToRun]];    DiagFlTapeTTY.GetTime [timePerPass, str];    String.AppendString [queststr, str];    questtext[explcount]¬ queststr;    explcount¬  explcount+1;  };      IF BASE [passExplanation]# NIL THEN  { count: CARDINAL¬ 0;    UNTIL  explcount= 5 OR count= LENGTH[passExplanation] DO      questtext[explcount]¬ passExplanation[count];      count¬ count+1;      explcount¬ explcount+1;    ENDLOOP;  };  questtext[explcount]¬ mkOpInt[supportedPassCnt];  explcount¬  explcount+1;   -- form a HelpText IF explcount > 0 THEN {    help ¬ Odi.GetAHelpText [explcount];    FOR inx: CARDINAL IN [0..explcount)      DO help.textBody [inx] ¬ questtext[inx]; ENDLOOP    };  PassCount ¬ Odi.GetANumber [prompt: mkOpInt[passesToRun],  		help: help,		lowLimit: 1,		upperLimit: 32000,		defaultNumber: 1].number;		      END; --GetPassCount     -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the correct password from the selected user -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~     GetPassword: PROCEDURE [str: LONG STRING] = BEGIN END; --GetPassword		 -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the unit/s and requirements for the test to be run -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetTestRequirements: PUBLIC PROCEDURE	[	notice: LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0],	testTitle: LONG STRING¬ NIL,	needChannel: BOOLEAN¬ FALSE,	needChannels: BOOLEAN¬ FALSE,	needPassCount: BOOLEAN¬ FALSE,	  timePerPass: LONG CARDINAL¬0,	  passExplanation:	    LONG DESCRIPTOR FOR ARRAY OF LONG STRING¬ DESCRIPTOR [NIL, 0],	needWarning: BOOLEAN¬ FALSE] = BEGIN DiagFlTapeTTY.Initialize[]; IF BASE [notice]# NIL THEN { FOR cnt: CARDINAL IN [0..LENGTH[notice]) DO     DiagFlTapeTTY.PutLine[string: notice[cnt]];   ENDLOOP; }; DiagFlTapeTTY.PutCR []; IF testTitle# NIL THEN   DiagFlTapeTTY.PutLine[string: testTitle]; DiagFlTapeTTY.PutCR []; IF needChannel THEN GetChannel []; IF needChannels THEN GetChannels []; IF needPassCount THEN GetPassCount [	timePerPass: timePerPass,	passExplanation: passExplanation];		 IF needWarning THEN PutWarning []; END; --GetTestRequirements -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the unit number to be run (uses MaxChannel) -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetChannel: PROCEDURE [] =BEGIN GetChannels [includeAllChannels: FALSE]; END; --GetChannel -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- gets the unit number to be run including all present units (uses MaxChannel) -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetChannels: PROCEDURE [includeAllChannels: BOOLEAN¬ TRUE] = BEGIN<< string:	STRING¬ [8]; unit:		CARDINAL¬ 0;   title:		LONG STRING¬ "junk"; questtext:	ARRAY [0..0] OF LONG STRING¬ [		  "junk"]; options:	ARRAY [0..4] OF LONG STRING¬ [ 		  "junk",		  "junk",		  "junk",		  "junk",		  "junk"];		   ChannelRunArray¬ ALL[FALSE];   --only one channel available IF MaxChannel= 0 THEN RETURN;		-- was DiagFlTapeCmds.MaxChannel --if multi channel selection is not desired don't output allChannels IF NOT includeAllChannels THEN options[MaxChannel+1]¬ NIL; -- was DiagFlTapeCmds.MaxChannel	 --display menu and get unit number unit¬ DiagFlTapeTTY.PutMenu[   title: title,   startSelectionAt: 0,   options: DESCRIPTOR [options],   deleteEntry: FALSE,   optionExplanation: DESCRIPTOR [questtext]];  --single unit selected IF unit<= MaxChannel THEN	-- was DiagFlTapeCmds.MaxChannel { Channel¬ unit;		-- was DiagFlTapeCmds.Channel   ChannelRunArray[Channel]¬ TRUE } ELSE --either exit or select multi units   IF NOT includeAllChannels AND unit= MaxChannel+ 1 THEN     SIGNAL DiagFlTapeTestSelect.Exit     ELSE SetChannelRunArray[]; --select multi channels DiagFlTapeTTY.PutCR[];>>  END; --GetChannels			   -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- This procedure: gets the proper user and checks the password,  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  GetUser: PUBLIC PROCEDURE =  BEGIN    -- clear log in  User		¬ FALSE;  SystemAdmin	¬ FALSE;  TechRep	¬ FALSE;  TechSpec	¬ FALSE;  Manufacturing	¬ FALSE;  Engineering	¬ FALSE;  Switch	¬ ALL [FALSE];    SELECT Odi.userType FROM     NormalUser 	=> User ¬ TRUE;     Administrator 	=> SystemAdmin¬ TRUE;     Services 		=> { TechRep ¬ TRUE; TechSpec ¬ TRUE };     Manufacturing 	=> Manufacturing ¬ TRUE;     Programmer 	=> Engineering ¬ TRUE;     ENDCASE 		=> User ¬ TRUE;      END; --GetUser			 -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- waits for an input character before continuing -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ProceedOnInput: PUBLIC PROCEDURE [    text: LONG STRING¬ NIL] = BEGIN			 DiagFlTapeTTY.CheckIfUserAbort[]; DiagFlTapeTTY.ProceedOnInput [text: text];  END; --ProceedOnInput  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- display the diagnostic title  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  PutDiagTitle: PUBLIC PROCEDURE [title: LONG STRING¬ NIL] =  BEGIN  DiagFlTapeTTY.Initialize [];  DiagFlTapeTTY.PutLine [mkMenu[copyrightNotice]];  DiagFlTapeTTY.PutCR [];   IF title# NIL THEN DiagFlTapeTTY.PutLine [title];  DiagFlTapeTTY.PutLine [mkOpInt[aQestMarkExpls]];  DiagFlTapeTTY.PutLine [mkOpInt[aBreakExpls]];  DiagFlTapeTTY.PutCR [];    END; --PutDiagTitle  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- display the pass count and time  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    PutPassCount: PUBLIC PROCEDURE [timePerPass: LONG CARDINAL¬ 0]  = BEGIN  str:			STRING¬ [24];    DiagFlTapeTTY.PutCR [];  DiagFlTapeTTY.PutString [mkOpInt[passes]];  DiagFlTapeTTY. PutNumber[PassCount];  IF timePerPass> 0 THEN  { DiagFlTapeTTY.PutSpaces [5];    DiagFlTapeTTY.PutString [mkOpInt[runTime]];    DiagFlTapeTTY.GetTime [timePerPass* PassCount, str];    DiagFlTapeTTY.PutLine [str];  };  DiagFlTapeTTY.PutCR [];    END; --PutPassCount  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- display the pass count and time  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  PutRemainingPassCount: PUBLIC PROCEDURE [		timePerPass: LONG CARDINAL¬ 0]  = BEGIN  str:			STRING¬ [24];    DiagFlTapeTTY.PutString [mkOpInt[passesLeft]];  DiagFlTapeTTY.PutNumber [PassCount];  DiagFlTapeTTY.PutSpaces [5];  IF timePerPass> 0 THEN  {DiagFlTapeTTY.PutString [mkOpInt[runTimeLeft]];   DiagFlTapeTTY.GetTime [timePerPass* PassCount, str];   DiagFlTapeTTY.PutLine [str]  };  DiagFlTapeTTY.PutCR [];    END; --PutRemainingPassCount  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- output a warning to the operator and request confirmation to continue  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  PutTitle: PUBLIC PROCEDURE	[title: LONG STRING¬ NIL,  				 addChannel: BOOLEAN¬ FALSE]  = BEGIN  DiagFlTapeTTY.Initialize [];  DiagFlTapeTTY.PutString[mkMenu[copyrightNotice]];  IF title# NIL THEN DiagFlTapeTTY.PutString [title];  DiagFlTapeTTY.PutCR [];  DiagFlTapeTTY.PutCR [];    END; --PutTitle -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -- output a warning to the operator and request confirmation to continue -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ PutWarning: PUBLIC PROCEDURE =BEGIN DiagFlTapeTTY.PutCR []; DiagFlTapeTTY.PutLine [mkOpInt[WARNActionDest]];  IF NOT DiagFlTapeTTY.GetYesNo [prompt: mkOpInt[wishToContinueYN]]   THEN SIGNAL DiagFlTapeTestSelect.Restart;  IF NOT DiagFlTapeTTY.GetYesNo [mkOpInt[stillShure]]    THEN SIGNAL DiagFlTapeTestSelect.Restart;  END; --PutWarning    <<  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- sets up the ChannelRunArray  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  SetChannelRunArray: PUBLIC PROCEDURE  = BEGIN  c: CARDINAL¬MaxChannel+ 1;    UNTIL c= 0 DO    c¬c-1;      ChannelRunArray[c]¬ TRUE;      Channel¬ c;  ENDLOOP  END; --SetChannelRunArray>>     --*************** MAIN        END... off DiagFlTapeOpIntImpl    LOG  
-- File: OfflineScannerDiagDove.mesa-- Created 21-Jan-87 15:54:00 JMA-- Last edited 10-Jul-87 12:23:07 JMA ---- Copyright (C) 1985 Xerox Corporation. All rights reserved.--DIRECTORY  DiagDiskTime	       USING [ SetRealTimeClock, RealTimeClockFailure],  DiagDiskMkTime       USING [ DiagDiskMkTimeImpl, mkTime],  IncaDiagDefs	       USING [ Calibrate, EndSession, ErrorArray, ErrorType,  			       FaultArray, GetFaults,			       GetOptions, HardAvail,			       InternalDiag, InitSession, LoopBack, LoopPattern,			       Reset, ResetType, SelfTest, Status, Version],  OfflineDiagInterface USING [ OfflineDiagnosticProc, ResultType,			       PutTestParameters, LookForAbort,			       TestItemsForThisNode, GetATestItemsForThisNode,			       TestItem, GetATestItem, ClientPackage,			       AMenuOfSelections, GetAMenuOfSelections,			       Selections, GetASelectionArray, DiagHeap,			       HelpText, GetAHelpText, AbortCurrentTest,			       FixedPositionDisplayRecord, ARow,			       PutMessage, HitAnyKeyToContinue,			       GetYesNo, GetANumber, PutData,			       GetAFixedPositionDisplayRecord, GetARow],  Process	       USING [ Yield],  Runtime	       USING [ StartFault],  ScannerMsgKeysDove   USING [ scnrMessage, ScnrMessages,  			       scnrErrorMessage, ScnrErrorMessages ],  ScannerMsgKeysImplDove,  String	       USING [AppendDecimal, AppendNumber, MakeString,  			       StringBoundsFault],  OfflineDiagInterfaceExtra USING [];	-- Export it.  OfflineScannerDiagDove: PROGRAM	 IMPORTS OfflineDiagInterface,	 	 DiagDiskMkTime, DiagDiskTime, 		 Process, Runtime, String,		 ScannerMsgKeysDove, IncaDiagDefs,	         Messages: ScannerMsgKeysImplDove		 		 	 EXPORTS OfflineDiagInterfaceExtra =BEGIN OPEN Odi: OfflineDiagInterface, 	 -- ODI stands for OfflineDiagInterface.	   Idd: IncaDiagDefs;	      	 -- Idd stands for IncaDiagDefs.	   <<Icd: IncaCallbackDefs;	 -- Icd stands for IncaCallbackDefs.>>  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- First declare various structures and constants that will be used.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- Private TYPEs      << ** SCANNER ERROR TYPES **     VCI  = Videl Control/Interface     VPP  = Videl Pre-Processor/Scanning     MD   = Motor Driver     FH   = Filter/Histogram     Comp = Compression          This is a list of Inca scanner error--referred to in this impl as "faults"--     broken down by board categories as defined by Inca Diagnostic Strategy Doc. >>     FatalError: TYPE = Idd.ErrorType[noHardware..noSoftware];   IncaScannerError: TYPE = Idd.ErrorType[videoContr..compressBoard];  VCIFaultCode:  TYPE = INTEGER[1..32];  VPPFaultCode:  TYPE = INTEGER[33..95];  MDFaultCode:	 TYPE = INTEGER[96..127];  FHFaultCode:	 TYPE = INTEGER[128..159];  CompFaultCode: TYPE = INTEGER[160..191];    -- For Loopback Tests  LoopbackTable: TYPE = DESCRIPTOR FOR ARRAY OF Idd.LoopPattern;     RepeatTest: TYPE = RECORD [     runTestCount	: LONG CARDINAL ¬ 1,     queryOnErr		: BOOLEAN ¬ TRUE,	-- ask before continue on err detect     testCompletedCount	: LONG CARDINAL ¬ 0,     errStopCount	: LONG CARDINAL ¬ 0  ];    RepetitiveTest: TYPE = PROCEDURE [] RETURNS [condition: Idd.Status];     testLoop: RepeatTest ¬ [];      commandStat: Idd.Status ¬ [ok: FALSE]; -- init record  initStat,  endStat: Idd.Status ¬ [ok: FALSE]; -- init record    -- contains list of faults encountered so far  faultsList: Idd.FaultArray;    shutDown: BOOLEAN ¬ FALSE;		-- shut down scanner test  userWantsToCont: BOOLEAN ¬ TRUE;	-- proceed with testing  userWantsToAbort: BOOLEAN ¬ FALSE;  testInProgress: BOOLEAN ¬ FALSE;  abortWatcherGoHome: BOOLEAN ¬ FALSE;  basicScnrLbDone: BOOLEAN ¬ FALSE;  runningBasicLb: BOOLEAN ¬ FALSE;  diagHasBeenStartedBefore: BOOLEAN ¬ FALSE;    -- scanner build version  scnrVersion: Idd.Version ¬ b0;  leftEdge: CARDINAL = 3;		-- where fixed display starts on the screen    --~~~~~~~~~~~~~~~~~~~~~~~-- Top level menu stuffs--~~~~~~~~~~~~~~~~~~~~~~~  --  -- topLevelMenuNode points to a RECORD, AMenuOfSelections, containing pointers    -- to various elements of the top level menu node.   --  -- Each menu item may be a real test or a submenu. Each submenu is also a  -- AMenuOfSelections.  --    topLevelMenuNode: LONG POINTER TO Odi.AMenuOfSelections;    -- topLevelMenuSelections points to a SEQUENCE containing pointers to all    -- TestItems in the topmenu.  topLevelMenuSelections: LONG POINTER TO Odi.TestItemsForThisNode;     -- Test numbers for the topLevelMenuNode defined for clarity convenience.   -- These correspond to the topLevelMenuSelections indices into which   -- the pointers to TestItems are to be stored. They will be assigned  -- to the selections arrays for each class of user  --    scnrReset: CARDINAL = 0;		-- topLevelMenuSelections.nodeItems [0]  scnrCalibrate: CARDINAL = 1; 		-- topLevelMenuSelections.nodeItems [1]  scnrLoopback: CARDINAL = 2;		-- topLevelMenuSelections.nodeItems [2]  scnrGetOptions: CARDINAL = 3; 	-- topLevelMenuSelections.nodeItems [3]  scnrGetFaults: CARDINAL = 4;		-- topLevelMenuSelections.nodeItems [4]  scnrInternalDiagnostics: CARDINAL = 5;-- topLevelMenuSelections.nodeItems [5]    --~~~~~~~~~~~~~~~~~~~~~~~~~~-- Second level menu stuffs--~~~~~~~~~~~~~~~~~~~~~~~~~~  --  -- second LevelMenuNode is for:  --	reset  --	internal diagnostics  --	loopbackTest    resetLevel2MenuNode: LONG POINTER TO Odi.AMenuOfSelections;  resetLevel2MenuSelections: LONG POINTER TO Odi.TestItemsForThisNode;    --intDiagLevel2MenuNode: LONG POINTER TO Odi.AMenuOfSelections;  --intDiagLevel2MenuSelections: LONG POINTER TO Odi.TestItemsForThisNode;    loopbackLevel2MenuNode: LONG POINTER TO Odi.AMenuOfSelections;  loopbackLevel2MenuSelections: LONG POINTER TO Odi.TestItemsForThisNode;    -- Constants declared for clarity and convenience  soft: CARDINAL = 0;		-- secondLevelMenuSelections.nodeItems [0]  hard: CARDINAL = 1;		-- secondLevelMenuSelections.nodeItems [1]    -- internal diagnostic types  motor: CARDINAL = 0;		-- secondLevelMenuSelections.nodeItems [0]  filter: CARDINAL = 1;		-- secondLevelMenuSelections.nodeItems [1]  compression: CARDINAL = 2;	-- secondLevelMenuSelections.nodeItems [2]    -- loopback test types  basicScnrLb:  CARDINAL = 0;	-- secondLevelMenuSelections.nodeItems [0]  filterOptLb: CARDINAL = 1;	-- secondLevelMenuSelections.nodeItems [1]  compOptLb: CARDINAL = 2;	-- secondLevelMenuSelections.nodeItems [2]    -- do it this way for better flexibility  basicScnrList: ARRAY [0..5) OF Idd.LoopPattern ¬   	[grey, screen, window8, window1, scale];  filterOptList: ARRAY [0..2) OF Idd.LoopPattern ¬  	[enhance, descreen];  compOptList: ARRAY [0..6) OF Idd.LoopPattern ¬  	[compEnc, compRaw, compAdScr, compLine, compHalf, compAdThr];    -- pTestItem points to a RECORD containing all the components of a TestItem.  pTestItem: LONG POINTER TO Odi.TestItem;  -- The following pointers point to SEQUENCES specifying tests for the various-- user classes.  pUserSelections: LONG POINTER TO Odi.Selections;  <<pAdminSelections, pUserSelections: LONG POINTER TO Odi.Selections;  pDangerSelections, pManufacturingSelections: LONG POINTER TO Odi.Selections;>>  -- Pointers to messages, errors, and faults in ScannerMsgKeysImplDove  msgKey: LONG POINTER TO ARRAY ScannerMsgKeysDove.ScnrMessages  	  OF LONG STRING;  errMsgKey: LONG POINTER TO ARRAY ScannerMsgKeysDove.ScnrErrorMessages  	  OF LONG STRING;     numberString: LONG STRING ¬ NIL;  	  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Declarations for convenience--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  nullResult: Odi.ResultType = none;  goodResult: Odi.ResultType = passed;  badResult: Odi.ResultType = failed;  ambiguousResult: Odi.ResultType = ambiguous;    defaultToYes: BOOLEAN = TRUE;  defaultToNo: BOOLEAN = FALSE;  p: PROCESS;--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Common definitions --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Help texts  numOfRepeatHelpTxt,  stopAndAskHelpTxt: LONG POINTER TO Odi.HelpText;  --scnrVersionHelpTxt: LONG POINTER TO Odi.HelpText;-- Positionally-fixed data    repeatTopDisplay: LONG POINTER TO Odi.FixedPositionDisplayRecord;    -- Scratch variables to be re-used thru-out package  lin1, lin2 : LONG POINTER TO Odi.ARow;  item2Pos: CARDINAL;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Common support procedures  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  << proc that waits around for the user to hit the stop key >>CheckForUserAbort: PROC =  BEGIN		   UNTIL abortWatcherGoHome DO		-- run forever!    					-- look for aborts      Odi.LookForAbort [! Odi.AbortCurrentTest => {  		Odi.PutMessage [message:msgKey[abortACK], beep:TRUE];		userWantsToAbort ¬ TRUE;		CONTINUE } ];      Process.Yield [];    ENDLOOP;  END; -- of CheckForUserAbort<< Proc to create a different menu if the an unrecoverable error	is detected at Inca Diag initialization time.  >>CreateAlternateUniverse: PROC =  BEGIN  noChoiceHelpTxt: LONG POINTER TO Odi.HelpText ¬ Odi.GetAHelpText [2];    noChoiceHelpTxt[0] ¬ msgKey [noChoiceHelp];  noChoiceHelpTxt[1] ¬ msgKey [noChoiceHelp1];    topLevelMenuNode ¬ Odi.GetAMenuOfSelections [];  -- a universe without any choices! User can only "Return To Previous Menu"    topLevelMenuSelections ¬ Odi.GetATestItemsForThisNode [0];  pTestItem ¬ Odi.GetATestItem [];  -- all users get the same treatmet  pUserSelections ¬ Odi.GetASelectionArray [0];  topLevelMenuNode.menuTitle ¬ msgKey [disabledScnrTest]; -- Optional.  topLevelMenuNode.menuHelp ¬ noChoiceHelpTxt;  topLevelMenuNode.userSelections ¬ pUserSelections;  topLevelMenuNode.adminSelections ¬ pUserSelections;  topLevelMenuNode.seSelections ¬ pUserSelections;  topLevelMenuNode.manufacturingSelections ¬ pUserSelections;  topLevelMenuNode.programmerSelections ¬ pUserSelections;  topLevelMenuNode.testItemsForThisNode ¬ topLevelMenuSelections;END;<< proc to lock up the machine>>  FreezeMachine: PRIVATE PROCEDURE [] =   BEGIN  unFreeze: BOOLEAN ¬ FALSE;    Odi.PutMessage[message: msgKey[cantContinue], numOfBlankLines: 1];  UNTIL unFreeze DO    -- Intended to be Nothing  ENDLOOP;        END;  -- FreezeMachine<< Proc to allocate and initializes fixed display records >>GetADisplayRecord:  PROCEDURE [numberOfRows, itemsOnARow: CARDINAL]  RETURNS [rp: LONG POINTER TO Odi.FixedPositionDisplayRecord] =  BEGIN    aRow: LONG POINTER TO Odi.ARow;    rp ¬ Odi.GetAFixedPositionDisplayRecord [numberOfRows];        FOR i: CARDINAL IN [0 .. numberOfRows) DO       rp.rows[i] ¬ aRow ¬ Odi.GetARow [itemsOnARow];       FOR j: CARDINAL IN [0 .. itemsOnARow) DO           aRow.rowItems[j].name ¬ NIL;           aRow.rowItems[j].namePosition ¬ leftEdge;	   aRow.rowItems[j].stringValue ¬ NIL;	   aRow.rowItems[j].valuePosition ¬ 0;	   aRow.rowItems[j].value ¬ 0;	   ENDLOOP;  -- Row loop       ENDLOOP;  -- Record loop    END;  -- GetADisplayRecord    << proc to display all errors in a given error list>>  DisplayErrorMsg: PRIVATE PROCEDURE [errList: Idd.ErrorArray] =  BEGIN  inx: CARDINAL ¬ 0;  error: Idd.ErrorType ¬ none;  emptyList: BOOLEAN ¬ TRUE;    -- make sure errlist is not empty  FOR inx IN [0..LENGTH[errList]) DO    IF errList[inx] # none THEN        { emptyList ¬ FALSE; EXIT }  ENDLOOP;    IF emptyList THEN RETURN;  <<THEN {         IF emptyList THEN Odi.PutMessage [message: msgKey[listIsEmpty]];	 RETURN };  >>           Odi.PutMessage [message: msgKey[errsEncountered], beep: TRUE,  			numOfBlankLines: 1];  Odi.PutMessage [message: "", numOfBlankLines: 2];						  FOR inx IN [0..LENGTH[commandStat.fault]) DO       SELECT error ¬ errList[inx] FROM    	none	=> {};	-- do nothing  			   	IN FatalError	=>		BEGIN		Odi.PutMessage [message: msgKey[unrecoverableErr]];		Odi.PutMessage [message: errMsgKey[error]];		Odi.PutMessage [];   		shutDown ¬ TRUE		END;			basicLoopCompare => { Odi.PutMessage [message: errMsgKey[videoContr]];			      Odi.PutMessage [message: "   problem#"];			      Odi.PutMessage [message: msgKey[f1], startWithNewLine: FALSE] };			      	filterLoopCompare => { Odi.PutMessage [message: errMsgKey[filterBoard]];			       Odi.PutMessage [message: "   problem#"];		 	       Odi.PutMessage [message: msgKey[f6], startWithNewLine: FALSE] };			           	noVCICommun  => {  Odi.PutMessage [message: errMsgKey[videoContr]];			   Odi.PutMessage [message: "   problem#"];			   Odi.PutMessage [message: msgKey[f2], startWithNewLine: FALSE] };			       	hungprescan =>  { Odi.PutMessage [message: errMsgKey[filterBoard]];			  Odi.PutMessage [message: "   problem#"];		 	  Odi.PutMessage [message: msgKey[f7], startWithNewLine: FALSE] };		       	hungbasicLoop => {  Odi.PutMessage [message: errMsgKey[videoContr]];			    Odi.PutMessage [message: "   problem#"];			    Odi.PutMessage [message: msgKey[f3], startWithNewLine: FALSE] };			      	hungFilterLoop => {  Odi.PutMessage [message: errMsgKey[filterBoard]];			     Odi.PutMessage [message: "   problem#"];		 	     Odi.PutMessage [message: msgKey[f8], startWithNewLine: FALSE] };      			resetFault => {  Odi.PutMessage [message: msgKey[unIDBoard]];			 Odi.PutMessage [message: "   problem#"];		 	 Odi.PutMessage [message: msgKey[f0], startWithNewLine: FALSE] };			       	rs485comError => {  Odi.PutMessage [message: msgKey[multiBoard]];			    Odi.PutMessage [message: "   problem#"];		 	    Odi.PutMessage [message: msgKey[fb], startWithNewLine: FALSE] };			       	hungReset => {  Odi.PutMessage [message: msgKey[multiBoard]];			Odi.PutMessage [message: "   problem#"];		 	Odi.PutMessage [message: msgKey[fc], startWithNewLine: FALSE] };		       		  	-- print the error msg(s) on the screen   	     	ENDCASE	 =>		BEGIN		Odi.PutMessage [message: errMsgKey[error]];		IF error IN IncaScannerError THEN {		   [ ,faultsList] ¬ Idd.GetFaults[];		   DisplayFaultMsg [faultsList, error, TRUE] };		END;			          ENDLOOP;  -- FOR inx...        END;  -- DisplayErrorMsgOkToPrintFault: PRIVATE PROC [error: Idd.ErrorType, fault: INTEGER]  RETURNS [ok: BOOLEAN] =  BEGIN  ok ¬ FALSE;    SELECT error FROM     videoContr     => ok ¬ fault IN VCIFaultCode;     videoProcess   => ok ¬ fault IN VPPFaultCode;     motorDriver    => ok ¬ fault IN MDFaultCode;     filterBoard    => ok ¬ fault IN FHFaultCode;     compressBoard  => ok ¬ fault IN CompFaultCode;     ENDCASE	    => {};  END;  -- OkToPrintFault			     << proc to display all faults in a given faults list>>  DisplayFaultMsg: PRIVATE PROCEDURE [faultList: Idd.FaultArray,				error: Idd.ErrorType, checkRange: BOOLEAN] =  BEGIN  inx: CARDINAL ¬ 0;  fault: INTEGER ¬ 0;  emptyList: BOOLEAN ¬ TRUE;    -- make sure faultlist is not empty  FOR inx IN [0..LENGTH[faultsList]) DO    IF faultList[inx] # 0 THEN        { emptyList ¬ FALSE; EXIT }  ENDLOOP;    IF emptyList THEN {     Odi.PutMessage [message: msgKey[listIsEmpty]];     RETURN };  	   FOR inx IN [0..LENGTH[faultsList]) DO     SELECT fault ¬ faultList[inx] FROM  	0	=> {};			   -- print fault(s) on the screen	ENDCASE	=> BEGIN		   numberString.length ¬ 0;		   -- convert number to hex string value & catch string fault		   String.AppendNumber [numberString, fault, 16 !		      String.StringBoundsFault => { 		         IF fault < 0 OR fault > 255			   THEN numberString ¬ "XXX"			   ELSE numberString ¬ "ZZZ";			 CONTINUE }];		   		 <<IF checkRange THEN {		      		      IF NOT OkToPrintFault[error, fault] THEN		         Odi.PutMessage [message: "Error code out of range."] };		 >>		   -- print problem board area 		   Odi.PutMessage [message: "   error#"];		   Odi.PutMessage [message: numberString, startWithNewLine: FALSE];		   Odi.PutMessage [message: "H", startWithNewLine: FALSE, blankSpaces: 0]		   END;			         ENDLOOP;  -- FOR inx...  END;  -- DisplayFaultMsg       -- set up repetitive test formatRepeatTestProc: PROC [] =  BEGIN  OPEN testLoop;        -- ask user how many times he/she wants to run the test    [runTestCount,,,] ¬ Odi.GetANumber [prompt: msgKey[numOfRepeat], help: numOfRepeatHelpTxt,    			numberIsLong: TRUE, defaultNumber: 1];		    -- ask user if he/she wants control back if the test should find a problem    queryOnErr ¬ Odi.GetYesNo [prompt: msgKey[stopAndAsk], help: stopAndAskHelpTxt,    			defaultSpecified: TRUE, default: defaultToYes];          -- Set up top display    repeatTopDisplay.displayTitle ¬ msgKey[repeatInfo];    lin1 ¬ repeatTopDisplay.rows[0];    lin2 ¬ repeatTopDisplay.rows[1];        -- position the count title and its value    lin1.rowItems[0].name ¬ msgKey[desiredRepeatCount];    lin1.rowItems[0].valuePosition ¬          leftEdge + msgKey[desiredRepeatCount].length + 2;    lin1.rowItems[0].value ¬ runTestCount;        lin2.rowItems[0].name ¬ msgKey[repetitionsCompleted];        -- calculate the position of the next item (or column)    item2Pos ¬ MAX [lin1.rowItems[0].name.length,  	            lin2.rowItems[0].name.length] + 12 + leftEdge;		        -- position the next item on the next column and its value    lin1.rowItems[1].name ¬ msgKey[returnControl];    lin1.rowItems[1].namePosition ¬ item2Pos;    --lin1.rowItems[1].valuePosition ¬ item2Pos + lin1.rowItems[1].name.length + 2;    --lin1.rowItems[1].value ¬ 0;    -- the value of this variable is a STRING    lin1.rowItems[1].valuePosition ¬ 0;    lin1.rowItems[1].stringValue ¬ SELECT queryOnErr FROM    					TRUE  => msgKey[Yes],					FALSE => msgKey[No],					ENDCASE => msgKey [twilightZone];    lin2.rowItems[0].name ¬ msgKey[repetitionsCompleted];    lin2.rowItems[0].valuePosition ¬         leftEdge + msgKey[repetitionsCompleted].length + 2;    lin2.rowItems[0].value ¬ 0;    lin2.rowItems[1].name ¬ msgKey[errStopSoFar];    lin2.rowItems[1].namePosition ¬ item2Pos;    lin2.rowItems[1].valuePosition ¬ item2Pos + lin2.rowItems[1].name.length + 2;    lin2.rowItems[1].value ¬ 0;    << It should look like this:	repeatInfo	   desiredRepeatCount:  val	returnControl:  Yes/No	   repetitionsCompleted:  val	errStopSoFar:  val>>     -- clear screen and print the title     Odi.PutTestParameters [repeatTopDisplay, FALSE];      END;  -- RepeatTestProc  ResetProc: PROC [resetType: Idd.ResetType]  RETURNS [result: Odi.ResultType] =  BEGIN    testInProgress ¬ TRUE;  Odi.PutMessage [message: msgKey[resetBegin]];  commandStat ¬ Idd.Reset [resetType];    -- check if we had a successful reset  IF NOT commandStat.ok THEN {  	 DisplayErrorMsg [commandStat.fault];	 RETURN [badResult] };	   testInProgress ¬ FALSE;  Odi.PutMessage [message: msgKey[done]];  RETURN [goodResult]   END;  -- ResetProc    LoopbackProc: PROC [test: Idd.LoopPattern]  RETURNS [stat: Idd.Status] =  BEGIN  testInProgress ¬ TRUE;  stat ¬ Idd.LoopBack [test];  testInProgress ¬ FALSE;  RETURN [stat]  END;  -- LoopbackProcRunLoopback: PROC [loopback: LoopbackTable]  RETURNS [Idd.Status] =  BEGIN    numOfTestParts: INTEGER ¬ 0;  localTestResult: Odi.ResultType ¬ ambiguousResult;    --Odi.PutMessage [message: msgKey[loopBackBegin]];    runningBasicLb ¬ (DESCRIPTOR [basicScnrList] = loopback);  numberString.length ¬ 0;  String.AppendDecimal [numberString, loopback.LENGTH !		      String.StringBoundsFault => { numberString ¬ "0";CONTINUE} ];  Odi.PutMessage [message: "in", startWithNewLine: FALSE];		        Odi.PutMessage [message: numberString, startWithNewLine: FALSE];  Odi.PutMessage [message: "parts...", startWithNewLine: FALSE];      		        FOR inx:INTEGER IN [0..loopback.LENGTH)    DO    -- print msg here    numberString.length ¬ 0;        -- format is "...n..."    Odi.PutMessage [message: "..."];    String.AppendDecimal [numberString, inx+1 !		      String.StringBoundsFault => { numberString ¬ "XXX";CONTINUE} ];    Odi.PutMessage [message: numberString, startWithNewLine: FALSE];    Odi.PutMessage [message: "...", startWithNewLine: FALSE];  		          commandStat ¬ LoopbackProc [loopback.BASE[inx]];    IF NOT commandStat.ok THEN EXIT;    ENDLOOP;    Odi.PutMessage [startWithNewLine: TRUE];  --Odi.PutMessage [message: msgKey[done]];  RETURN [commandStat]  END;  -- RunLoopback<< Proc to display contents of the accumulated faults list >>FaultsProc: PRIVATE PROCEDURE []  RETURNS [result: Odi.ResultType] =  BEGIN  inx: CARDINAL ¬ 0;  testResult: Odi.ResultType ¬ nullResult;    result ¬ nullResult;  [commandStat, faultsList] ¬ Idd.GetFaults[];  IF NOT commandStat.ok THEN {   	DisplayErrorMsg [commandStat.fault];	testResult ¬ ambiguousResult };	  -- display contents of the faults list, print header first  Odi.PutMessage [message: msgKey[faultsList], beep: FALSE,  			numOfBlankLines: 1];	  DisplayFaultMsg [faultsList,,TRUE];    RETURN [testResult];  END; -- FaultsProc  -- run a test continuously, if necessary  RunRepetitiveTest: PROC [test: RepetitiveTest, header: LONG STRING]RETURNS [testResult: Odi.ResultType] =BEGIN  OPEN testLoop;  inx: LONG CARDINAL ¬ 0;    testResult ¬ goodResult;  -- set up screen for repetitive test  RepeatTestProc[];    -- Get confirmation before starting  IF NOT Odi.GetYesNo[msgKey[areYouSure],,TRUE,defaultToYes]    THEN {        Odi.PutMessage [msgKey[aborted]];	RETURN [nullResult] };	  testInProgress ¬ TRUE;  errStopCount ¬ testCompletedCount ¬ 0;  Odi.PutMessage [message: header];    -- fork off proc to Check For User Abort		   abortWatcherGoHome ¬ userWantsToAbort ¬ FALSE;  p ¬ FORK CheckForUserAbort[];    FOR inx IN [0..runTestCount) UNTIL userWantsToAbort DO       [commandStat] ¬ test[];     testCompletedCount ¬ testCompletedCount + 1;          -- check if we had a successful test     IF NOT commandStat.ok THEN {     	errStopCount ¬ errStopCount + 1;        testResult ¬ badResult;	  	DisplayErrorMsg [commandStat.fault];        -- stop and ask user for prompt only if user has test in such a mode        -- default answer is "NO (FALSE)"	        IF queryOnErr THEN {           IF NOT Odi.GetYesNo [msgKey[promptForCont],,TRUE,defaultToNo] THEN EXIT;	   queryOnErr ¬ Odi.GetYesNo [prompt: msgKey[stopAndAsk], help: stopAndAskHelpTxt,    			defaultSpecified: TRUE, default: defaultToYes] };	};  -- NOT ok...          -- update screen data fields     lin1.rowItems[1].stringValue ¬ SELECT queryOnErr FROM    					TRUE  => msgKey[Yes],					FALSE => msgKey[No],					ENDCASE => msgKey [twilightZone];     lin2.rowItems[0].value ¬ testCompletedCount;     lin2.rowItems[1].value ¬ errStopCount;				     -- update screen displayed parameters     Odi.PutTestParameters [repeatTopDisplay];  ENDLOOP;      		  abortWatcherGoHome ¬ TRUE;  Process.Yield [];  JOIN p;  		  testInProgress ¬ FALSE;  Odi.PutMessage [message: msgKey[done]];  Odi.HitAnyKeyToContinue[];    RETURN [testResult]  END; -- RunRepetitiveTest--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Procedures menu selections invoke--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~DeviceReset: RepetitiveTest =   BEGIN  RETURN [Idd.Reset[device]];  END; -- DeviceReset  SoftReset: RepetitiveTest =   BEGIN  RETURN [Idd.Reset[soft]];  END; -- SoftResetCalibrate: RepetitiveTest =   BEGIN  RETURN [Idd.Calibrate[]];  END; -- Calibrate  IntDiagMotor: RepetitiveTest =  BEGIN  RETURN [Idd.InternalDiag[motor]]  END; -- IntDiagMotorIntDiagFilter: RepetitiveTest =  BEGIN  RETURN [Idd.InternalDiag[filter]]  END; -- IntDiagFilterIntDiagCompress: RepetitiveTest =  BEGIN  RETURN [Idd.InternalDiag[compress]]  END; -- IntDiagCompressBasicScnrLoopback: RepetitiveTest =  BEGIN  RETURN [RunLoopback [DESCRIPTOR [basicScnrList]]];  END; -- BasicScnrLoopbackFilterOptLoopback: RepetitiveTest =  BEGIN  RETURN [RunLoopback [DESCRIPTOR [filterOptList]]];  END; -- FilterOptLoopback  CompOptLoopback: RepetitiveTest =  BEGIN  RETURN [RunLoopback [DESCRIPTOR [compOptList]]];  END; -- CompOptLoopback     CalibrateProc: Odi.OfflineDiagnosticProc =  BEGIN  RETURN [ RunRepetitiveTest[Calibrate, msgKey[calibBegin]]];  END; -- CalibrateProc GetOptionsProc: Odi.OfflineDiagnosticProc =  BEGIN  optInstalled: Idd.HardAvail ¬ [FALSE, FALSE];  testResult: Odi.ResultType ¬ nullResult;    [commandStat, optInstalled] ¬ Idd.GetOptions [];  -- check if we had a successful GetOptions  IF NOT commandStat.ok THEN {  	DisplayErrorMsg [commandStat.fault];	testResult ¬ ambiguousResult };    Odi.PutMessage [message: msgKey[scnrOptInstalled], numOfBlankLines: 1];  IF (NOT optInstalled.filter) AND (NOT optInstalled.comp) THEN  	Odi.PutMessage [message: msgKey[noOptionsAvail]]  ELSE {  	IF optInstalled.filter THEN		Odi.PutMessage [message: msgKey[filterAvail]]; 	IF optInstalled.comp THEN		Odi.PutMessage [message: msgKey[compressAvail]]	};  RETURN [testResult]  END; -- GetOptionsProc GetFaultsProc: Odi.OfflineDiagnosticProc =  BEGIN  RETURN [FaultsProc[]]    END; -- GetFaultsProcSoftResetProc: Odi.OfflineDiagnosticProc =  BEGIN  RETURN [RunRepetitiveTest[SoftReset, msgKey[resetBegin]]];  END; -- SoftResetProc  HardResetProc: Odi.OfflineDiagnosticProc =  BEGIN  RETURN [ RunRepetitiveTest[DeviceReset, msgKey[resetBegin]]];  END; -- HardResetProc MotorTestProc: Odi.OfflineDiagnosticProc =  BEGIN  RETURN [ RunRepetitiveTest[IntDiagMotor, msgKey[intDiagBegin]]];  END; -- MotorTestProc  FilterTestProc: Odi.OfflineDiagnosticProc =  BEGIN  RETURN [ RunRepetitiveTest[IntDiagFilter, msgKey[intDiagBegin]]];  END; -- FilterTestProcCompressionTestProc: Odi.OfflineDiagnosticProc =  BEGIN  RETURN [ RunRepetitiveTest[IntDiagCompress, msgKey[intDiagBegin]]];  END; -- CompressionTestProc-- L O O P B A C K TESTSBasicScnrLoopBackProc: Odi.OfflineDiagnosticProc =  BEGIN  localTestResult: Odi.ResultType ¬ ambiguousResult;    localTestResult ¬ RunRepetitiveTest[BasicScnrLoopback, msgKey[loopBackBegin]];  basicScnrLbDone ¬ (localTestResult = goodResult);  RETURN [localTestResult]  END; -- BasicScnrLoopBackProc  FilterOptLoopbackProc: Odi.OfflineDiagnosticProc =  BEGIN  localTestResult: Odi.ResultType ¬ ambiguousResult;    -- run basic loopback first  IF NOT basicScnrLbDone THEN     BEGIN     Odi.PutMessage [message: msgKey[runBasicScnrFirst]];     commandStat ¬ RunLoopback [DESCRIPTOR [basicScnrList]];     IF NOT commandStat.ok       THEN { DisplayErrorMsg [commandStat.fault];              RETURN [nullResult] }       ELSE { basicScnrLbDone ¬ TRUE;              Odi.PutMessage [clearMessageAreaFirst: TRUE] }     END;  RETURN [RunRepetitiveTest[FilterOptLoopback, msgKey[loopBackBegin]]];  END; -- FilterOptLoopbackProc  CompOptLoopbackProc: Odi.OfflineDiagnosticProc =  BEGIN  localTestResult: Odi.ResultType ¬ ambiguousResult;    -- run basic loopback first  IF NOT basicScnrLbDone THEN     BEGIN     Odi.PutMessage [message: msgKey[runBasicScnrFirst]];     commandStat ¬ RunLoopback [DESCRIPTOR [basicScnrList]];     IF NOT commandStat.ok       THEN { DisplayErrorMsg [commandStat.fault];              RETURN [nullResult] }       ELSE { basicScnrLbDone ¬ TRUE;     	      Odi.PutMessage [clearMessageAreaFirst: TRUE] }     END;  RETURN [RunRepetitiveTest[CompOptLoopback, msgKey[loopBackBegin]]];  END; -- CompOptLoopbackProc    --******************************************************************************-- Build up all the data structures for this package, which has three menu nodes--******************************************************************************InitializePackage: PROCEDURE =   BEGIN   -- init global variables   basicScnrLbDone ¬ FALSE;   faultsList ¬ ALL[0];   numberString ¬ String.MakeString [Odi.DiagHeap, 20];<<   -- FOR UI-ONLY and TESTING ONLY   -- ask for scanner build version, default answer is Yes.   scnrVersionHelpTxt ¬ Odi.GetAHelpText [1];   scnrVersionHelpTxt[0] ¬ msgKey [scnrVersionHelp];      IF Odi.GetYesNo [prompt: msgKey[scnrVersion], help: scnrVersionHelpTxt,    			defaultSpecified: TRUE, default: defaultToYes]      THEN scnrVersion ¬ p1      ELSE scnrVersion ¬ b0;>>      -- clean up previous session if there was one   IF diagHasBeenStartedBefore THEN       [endStat] ¬ Idd.EndSession [];             -- wake up diagnostic driver and scanner driver   Odi.PutMessage[message: msgKey[initializing]];   initStat ¬ Idd.InitSession [scnrVersion];      -- check if we had a successful init session   IF NOT initStat.ok THEN      BEGIN      shutDown ¬ FALSE;      DisplayErrorMsg [initStat.fault];      IF shutDown THEN {  -- encountered fatal scanner error	  Odi.PutMessage[message: msgKey[cantContinue], numOfBlankLines: 1];	  -- display "Disabled Diag" Menu	  CreateAlternateUniverse [];	  -- quit session	  commandStat ¬ Idd.EndSession [];	  Odi.HitAnyKeyToContinue[msgKey[initError], FALSE];	  RETURN };	        -- encountered non-fatal scanner error, continue anyway      Odi.HitAnyKeyToContinue[msgKey[initError],FALSE]      END;   -- NOT ok       -- remember that we started the session and allocate space    diagHasBeenStartedBefore ¬ TRUE;   -- *************************-- CREATE MENU AND SUB-MENUS-- *************************--~~~~~~~~~~~~~~~~~~~~~~~~~~-- Second level menu stuffs --~~~~~~~~~~~~~~~~~~~~~~~~~~-- Create the test items for this node-- secondLevelMenuSelections ­ holds pointers to all the data structures/item in -- this menu node   << RESET >>  -- 2 selections in reset secondLevelMenuNode  resetLevel2MenuSelections ¬ Odi.GetATestItemsForThisNode [2];  -- soft reset         pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [softReset]; 		 -- Test name     pTestItem.test ¬ SoftResetProc; 			 -- Actual test procedure  pTestItem.itemExplanation ¬ msgKey [softResetHelp];	 -- Online help  resetLevel2MenuSelections.nodeItems [0] ¬ pTestItem;	 -- Store test item    -- hard reset  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [hardReset]; 		 -- Test name     pTestItem.test ¬ HardResetProc; 			 -- Actual test procedure>>  pTestItem.itemExplanation ¬ msgKey [hardResetHelp];	 -- Online help  resetLevel2MenuSelections.nodeItems [1] ¬ pTestItem; 	 -- Store test item  <<  << INTERNAL DIAGNOSTICS >>  -- 3 selections in internal diagnostics secondLevelMenuNode  intDiagLevel2MenuSelections ¬ Odi.GetATestItemsForThisNode [2];    -- motor driver board internal diagnostics  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [motorTest]; 		 -- Test name     pTestItem.test ¬ MotorTestProc; 			 -- Actual test procedure  pTestItem.itemExplanation ¬ msgKey [motorHelp];	 -- Online help  intDiagLevel2MenuSelections.nodeItems [0] ¬ pTestItem; -- Store TestItem.    -- filter board internal diagnostics  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [filterTest]; 		 -- Test name     pTestItem.test ¬ FilterTestProc; 			 -- Actual test procedure  pTestItem.itemExplanation ¬ msgKey [filterHelp];	 -- Online help  intDiagLevel2MenuSelections.nodeItems [1] ¬ pTestItem; -- Store TestItem pointer.  >>    <<  -- compression board internal diagnostics  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [compressionTest]; 	 -- Test name     pTestItem.test ¬ CompressionTestProc; 		 -- Actual test procedure  pTestItem.itemExplanation ¬ msgKey [compressionHelp];	 -- Online help  intDiagLevel2MenuSelections.nodeItems [2] ¬ pTestItem; -- Store TestItem pointer.  >>    << LOOPBACK TESTS >>  -- 2 selections in loopback tests secondLevelMenuNode  loopbackLevel2MenuSelections ¬ Odi.GetATestItemsForThisNode [2];    -- basic Scanner loopback test  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [basicScannerLoopB]; 	 -- Test name     pTestItem.test ¬ BasicScnrLoopBackProc; 		 -- Actual test procedure  pTestItem.itemExplanation ¬ msgKey [loopbackHelp];	 -- Online help  loopbackLevel2MenuSelections.nodeItems [0] ¬ pTestItem;-- Store TestItem pointer.    -- filter Option loopback test  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [filterOptionLoopB]; 	 -- Test name     pTestItem.test ¬ FilterOptLoopbackProc; 		 -- Actual test procedure  pTestItem.itemExplanation ¬ msgKey [loopbackHelp];	 -- Online help  loopbackLevel2MenuSelections.nodeItems [1] ¬ pTestItem;-- Store TestItem pointer.    <<  -- compression Option loopback test  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [compOptionLoopB]; 	 -- Test name     pTestItem.test ¬ CompOptLoopbackProc; 		 -- Actual test procedure  pTestItem.itemExplanation ¬ msgKey [loopbackHelp];	 -- Online help  loopbackLevel2MenuSelections.nodeItems [2] ¬ pTestItem;-- Store TestItem pointer.  >>    <<Assign second level tests for the different classes of users.>>  -- EQUAL access to ALL selections for ALL users: Normal, SA, SE, Mfg, Programmers   -- ALL Users - 2 Selections  pUserSelections ¬ Odi.GetASelectionArray [2];  pUserSelections.selections[0] ¬ soft;  pUserSelections.selections[1] ¬ hard;    resetLevel2MenuNode ¬ Odi.GetAMenuOfSelections [];		-- Node container  resetLevel2MenuNode.menuTitle ¬ msgKey [reset];  resetLevel2MenuNode.menuHelp ¬ NIL;				-- None  resetLevel2MenuNode.userSelections ¬ pUserSelections;  resetLevel2MenuNode.adminSelections ¬ pUserSelections;  resetLevel2MenuNode.seSelections ¬ pUserSelections;  resetLevel2MenuNode.manufacturingSelections ¬ pUserSelections;  resetLevel2MenuNode.programmerSelections ¬ pUserSelections;  resetLevel2MenuNode.testItemsForThisNode ¬ resetLevel2MenuSelections;    <<  -- ALL Users - 3 Selections  pUserSelections ¬ Odi.GetASelectionArray [2];  pUserSelections.selections[0] ¬ motor;  pUserSelections.selections[1] ¬ filter;  --pUserSelections.selections[2] ¬ compression;    intDiagLevel2MenuNode ¬ Odi.GetAMenuOfSelections [];		-- Node container  intDiagLevel2MenuNode.menuTitle ¬ msgKey [internalDiag];  intDiagLevel2MenuNode.menuHelp ¬ NIL;				-- None  intDiagLevel2MenuNode.userSelections ¬ pUserSelections;  intDiagLevel2MenuNode.adminSelections ¬ pUserSelections;  intDiagLevel2MenuNode.seSelections ¬ pUserSelections;  intDiagLevel2MenuNode.manufacturingSelections ¬ pUserSelections;  intDiagLevel2MenuNode.programmerSelections ¬ pUserSelections;  intDiagLevel2MenuNode.testItemsForThisNode ¬ intDiagLevel2MenuSelections;  >>    -- ALL Users - 3 Selections  pUserSelections ¬ Odi.GetASelectionArray [2];  pUserSelections.selections[0] ¬ basicScnrLb;  pUserSelections.selections[1] ¬ filterOptLb;  --pUserSelections.selections[2] ¬ compOptLb;    loopbackLevel2MenuNode ¬ Odi.GetAMenuOfSelections [];		-- Node container  loopbackLevel2MenuNode.menuTitle ¬ msgKey [loopback];  loopbackLevel2MenuNode.menuHelp ¬ NIL;			-- None  loopbackLevel2MenuNode.userSelections ¬ pUserSelections;  loopbackLevel2MenuNode.adminSelections ¬ pUserSelections;  loopbackLevel2MenuNode.seSelections ¬ pUserSelections;  loopbackLevel2MenuNode.manufacturingSelections ¬ pUserSelections;  loopbackLevel2MenuNode.programmerSelections ¬ pUserSelections;  loopbackLevel2MenuNode.testItemsForThisNode ¬ loopbackLevel2MenuSelections;  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Top level menu stuffs - 5 possible selections--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Get a container to hold all items of the top menu node. This is passed to the-- Control Module.  topLevelMenuNode ¬ Odi.GetAMenuOfSelections [];-- There are 5 selections for the top menu; so we need a TestItemsForThisNode -- that can hold 5 pointers to the different TestItems.  topLevelMenuSelections ¬ Odi.GetATestItemsForThisNode [5];  -- For each of the selections, an instance of TestItem is needed.-- We start with Reset.  -- Reset selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [reset]; 			 -- Test name     pTestItem.test ¬ NIL; 				 -- Not a test but a sub-menu  pTestItem.subMenu ¬ resetLevel2MenuNode;		 -- reset sub-menu  pTestItem.itemExplanation ¬ msgKey [resetHelp];	 -- Online help  topLevelMenuSelections.nodeItems [0] ¬ pTestItem;	 -- Store TestItem pointer.  -- Calibrate selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [calibrate]; 		 -- Test name   pTestItem.test ¬ CalibrateProc; 			 -- Actual test procedure  pTestItem.subMenu ¬ NIL;				 -- no sub-menu  pTestItem.itemExplanation ¬ msgKey [calibrateHelp];	 -- Online help  topLevelMenuSelections.nodeItems [1] ¬ pTestItem;	 -- Store TestItem pointer.    -- Loopback Test selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [loopback]; 		 -- Test name     pTestItem.test ¬ NIL; 				 -- Not a test but a sub-menu  pTestItem.subMenu ¬ loopbackLevel2MenuNode;		 -- loopback sub-menu  pTestItem.itemExplanation ¬ msgKey [loopbackTopHelp];	 -- Online help  topLevelMenuSelections.nodeItems [2] ¬ pTestItem;	 -- Store TestItem pointer.  -- Get Options selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [getOptions]; 		 -- Test name     pTestItem.test ¬ GetOptionsProc; 			 -- Actual test procedure  pTestItem.subMenu ¬ NIL;				 -- no sub-menu  pTestItem.itemExplanation ¬ msgKey [getOptHelp];	 -- Online help  topLevelMenuSelections.nodeItems [3] ¬ pTestItem;	 -- Store TestItem pointer.    -- Get Faults selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [getFaults]; 		 -- Test name     pTestItem.test ¬ GetFaultsProc; 			 -- Actual test procedure  pTestItem.subMenu ¬ NIL;				 -- no sub-menu  pTestItem.itemExplanation ¬ msgKey [getFaultsHelp];	 -- Online help  topLevelMenuSelections.nodeItems [4] ¬ pTestItem;	 -- Store TestItem pointer.    <<  -- Internal Diagnostics selection  pTestItem ¬ Odi.GetATestItem []; 			 -- A test container  pTestItem.itemName ¬ msgKey [internalDiag]; 		 -- Test name     pTestItem.test ¬ NIL; 				 -- Not a test but a sub-menu  pTestItem.subMenu ¬ intDiagLevel2MenuNode;		 -- internal diag sub-menu  pTestItem.itemExplanation ¬ msgKey [intDiagHelp];	 -- Online help  topLevelMenuSelections.nodeItems [5] ¬ pTestItem;	 -- Store TestItem pointer.  >>  <<Assign top level selections for the different classes of users.>>  -- EQUAL access to ALL selections for ALL users: Normal, SA, SE, Mfg, Programmers  pUserSelections ¬ Odi.GetASelectionArray [5];  pUserSelections.selections[0] ¬ scnrReset;  pUserSelections.selections[1] ¬ scnrCalibrate;  pUserSelections.selections[2] ¬ scnrLoopback;  pUserSelections.selections[3] ¬ scnrGetOptions;  pUserSelections.selections[4] ¬ scnrGetFaults;  --pUserSelections.selections[5] ¬ scnrInternalDiagnostics;  topLevelMenuNode.menuTitle ¬ msgKey [topLevelMenuTitle]; -- Optional.  topLevelMenuNode.menuHelp ¬ NIL;  topLevelMenuNode.userSelections ¬ pUserSelections;  topLevelMenuNode.adminSelections ¬ pUserSelections;  topLevelMenuNode.seSelections ¬ pUserSelections;  topLevelMenuNode.manufacturingSelections ¬ pUserSelections;  topLevelMenuNode.programmerSelections ¬ pUserSelections;  topLevelMenuNode.testItemsForThisNode ¬ topLevelMenuSelections;-- Prepare help texts herenumOfRepeatHelpTxt ¬ Odi.GetAHelpText [1]; numOfRepeatHelpTxt[0] ¬ msgKey [numOfRepeatHelp];stopAndAskHelpTxt ¬ Odi.GetAHelpText [3];stopAndAskHelpTxt[0] ¬ msgKey [stopAndAskHelp0];stopAndAskHelpTxt[1] ¬ msgKey [stopAndAskHelp1];stopAndAskHelpTxt[2] ¬ msgKey [stopAndAskHelp2];-- Prepare positionally fixed display data  repeatTopDisplay ¬ GetADisplayRecord[2,2];  -- For Calibrate, ...-- Ask user if the disk is a virgin disk or not      END;  -- InitializePackage.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- PUBLIC PROCEDURE exported to the Control Module.--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~RunScannerTests: PUBLIC Odi.ClientPackage =  BEGIN      --~~~~~~~~~~~~~~~~~    -- Main line code.    --~~~~~~~~~~~~~~~~~        START Messages [! Runtime.StartFault => CONTINUE];	 -- Fire up Msg Key System        -- Get pointers to messages first    msgKey ¬ ScannerMsgKeysDove.scnrMessage;     errMsgKey ¬ ScannerMsgKeysDove.scnrErrorMessage;        InitializePackage [];  -- Build up the menu tree and procedural data base        START DiagDiskMkTime.DiagDiskMkTimeImpl [! Runtime.StartFault => CONTINUE];    DiagDiskTime.SetRealTimeClock [displayMsg: TRUE        ! DiagDiskTime.RealTimeClockFailure => {	     Odi.PutData[data: DiagDiskMkTime.mkTime[rTCFailure],	                 clearHeadingAndData: TRUE] }];			     RETURN [topLevelMenuNode];  -- Pass pointer to root node to Control Module    END;  -- Main line code  END...  OfflineScannerDiagDove.mesa    LOG21-Jan-87 15:54:00 JMA	- Creation23-Mar-87 20:47:37 JMA  - updated to match IncaDiagDefs 6-May-87 16:25:18 JMA  - display fault in hex string28-May-87 12:05:12 JMA	- commented out compression and added new error codes29-Jun-87 18:15:30 JMA	- commented out internal diag and added new error codes 6-Jul-87 12:28:14 JMA	- extended Scanner error code ranges
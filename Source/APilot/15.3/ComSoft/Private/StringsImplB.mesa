-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: StringsImplB.Mesa-- last Edited by:-- SXW   ,	13-Jul-81 14:58:32-- JGS,		1-Nov-81 13:06:54-- FXH    ,	October 16, 1980  4:21 PM-- LXR    ,	21-Sep-82 13:59:23-- RXJ     ,	26-Apr-83 15:25:58-- KEK     	20-Jan-86 11:41:16   Misc AR fixes on StringTo*Number.-- RRR          29-Jul-86 16:12:34   Until 13.0 ignore overflow.DIRECTORY  Inline USING [BITAND, DIVMOD, LowHalf, UDDivMod],  String USING [AppendChar, AppendString, StringBoundsFault];StringsImplB: PROGRAM IMPORTS Inline, String EXPORTS String = PUBLIC  BEGIN OPEN String;  Overflow: SIGNAL = CODE;  InvalidNumber: SIGNAL = CODE;  NUL: CHARACTER = 0C;  Space: CHARACTER = ' ;  UpperCase: PROCEDURE [c: CHARACTER] RETURNS [CHARACTER] =    BEGIN IF c IN ['a..'z] THEN c ¬ c + ('A - 'a); RETURN[c] END;  LowerCase: PROCEDURE [c: CHARACTER] RETURNS [CHARACTER] =    BEGIN IF c IN ['A..'Z] THEN c ¬ c + ('a - 'A); RETURN[c] END;  Compare: PROCEDURE [s1, s2: LONG STRING, ignoreCase: BOOLEAN ¬ TRUE]    RETURNS [INTEGER] =    BEGIN    i: CARDINAL;    l1: CARDINAL = s1.length;    l2: CARDINAL = s2.length;    c1, c2: CHARACTER;    FOR i IN [0..MIN[l1, l2]) DO      c1 ¬ s1[i];      c2 ¬ s2[i];      IF ignoreCase THEN BEGIN c1 ¬ UpperCase[c1]; c2 ¬ UpperCase[c2]; END;      SELECT c1 FROM < c2 => RETURN[-1]; > c2 => RETURN[1]; ENDCASE;      ENDLOOP;    RETURN[SELECT l1 FROM < l2 => -1, > l2 => 1, ENDCASE => 0]    END; --Compare--  StringToDecimal: PROCEDURE [s: LONG STRING] RETURNS [INTEGER] = {    RETURN[StringToNumber[s, 10]]};  StringToOctal: PROCEDURE [s: LONG STRING] RETURNS [CARDINAL] = {    RETURN[StringToNumber[s, 8]]};  StringToNumber: PROCEDURE [s: LONG STRING, radix: CARDINAL]    RETURNS [number: UNSPECIFIED ¬ 0] =    BEGIN OPEN Inline;    char: CHARACTER;    cp, startOfNumerics: CARDINAL ¬ 0;    newNumber, exp: CARDINAL ¬ 0;    neg, digitsFound, noExponent: BOOLEAN ¬ FALSE;    getchar: PROCEDURE =      BEGIN char ¬ IF cp >= s.length THEN NUL ELSE s[cp]; cp ¬ cp + 1; END;          IF s = NIL THEN SIGNAL InvalidNumber;    getchar[];        -- Get to first digit.    WHILE char <= Space OR char = '+ DO      IF char = NUL THEN SIGNAL InvalidNumber;      getchar[];      ENDLOOP;    IF char = '- THEN BEGIN neg ¬ TRUE; getchar[] END;        -- Get overriding suffix (if any).    startOfNumerics ¬ cp-1;    WHILE char IN ['0..'9] DO      digitsFound ¬ TRUE;      getchar[];      ENDLOOP;    IF NOT digitsFound THEN SIGNAL InvalidNumber;    SELECT LOOPHOLE[BITAND[char, 137B], CHARACTER] FROM      NUL => noExponent ¬ TRUE;      'B => radix ¬ 8;      'D => radix ¬ 10;      ENDCASE => noExponent ¬ TRUE;    IF NOT radix IN [1..10] THEN SIGNAL InvalidNumber;    cp ¬ startOfNumerics; getchar[];        -- Get mantissa.    WHILE char IN ['0..'9] DO      IF CARDINAL[char-'0] > radix-1 THEN SIGNAL InvalidNumber;      newNumber ¬ number*radix + (char-'0);--      IF newNumber < number THEN SIGNAL Overflow ELSE number ¬ newNumber;      number ¬ newNumber;      getchar[];      ENDLOOP;    -- Get exponent (if any).    IF NOT noExponent THEN      BEGIN      getchar[]; --(skip the radix suffux.)      WHILE char IN ['0..'9] DO exp ¬ exp*10 + (char-'0); getchar[]; ENDLOOP;      THROUGH [1..exp] DO	newNumber ¬ number*radix;--	IF newNumber < number THEN SIGNAL Overflow ELSE number ¬ newNumber;        number ¬ newNumber;	ENDLOOP;      END;    IF char # NUL THEN SIGNAL InvalidNumber;    IF neg THEN RETURN[-number];    END; --StringToNumber--  AppendNumber: PROCEDURE [s: LONG STRING, n: CARDINAL, radix: CARDINAL] =    BEGIN    ps: POINTER TO LONG STRING = @s;    xn: PROCEDURE [n: CARDINAL] =      BEGIN      r: CARDINAL;      [n, r] ¬ Inline.DIVMOD[n, radix];      IF n # 0 THEN xn[n];      IF r > 9 THEN r ¬ r + 'A - '0 - 10;      AppendChar[s, r + '0];      END;    xn[n ! StringBoundsFault => RESUME[ps­ ¬ StringBoundsFault[s]]];    END; --AppendNumber--  AppendDecimal: PROCEDURE [s: LONG STRING, n: INTEGER] =    BEGIN    IF n < 0 THEN      BEGIN      ps: POINTER TO LONG STRING = @s;      IF n = LAST[INTEGER] THEN BEGIN AppendString[s, "-32768"L]; RETURN END;      AppendChar[s, '- ! StringBoundsFault => RESUME[ps­ ¬ StringBoundsFault[s]]];      n ¬ -n      END;    AppendNumber[s, n, 10];    END; --AppendDecimal--  AppendOctal: PROCEDURE [s: LONG STRING, n: UNSPECIFIED] =    BEGIN AppendNumber[s, n, 8]; AppendChar[s, 'B]; END;  AppendLongDecimal: PROCEDURE [s: LONG STRING, n: LONG INTEGER] =    BEGIN    IF n < 0 THEN      BEGIN      ps: POINTER TO LONG STRING = @s;      IF n = LAST[LONG INTEGER] THEN        BEGIN AppendString[s, "-2147483648"L]; RETURN END;      AppendChar[s, '- ! StringBoundsFault => RESUME[ps­ ¬ StringBoundsFault[s]]];      n ¬ -n      END;    AppendLongNumber[s, n, 10];    END; --AppendLongDecimal--  AppendLongNumber: PROCEDURE [    s: LONG STRING, n: LONG UNSPECIFIED, radix: CARDINAL] =    BEGIN    ps: POINTER TO LONG STRING = @s;    xn: PROCEDURE [n: LONG CARDINAL] =      BEGIN      lr: LONG CARDINAL;      r: CARDINAL;      [n, lr] ¬ Inline.UDDivMod[n, radix];      IF n # 0 THEN xn[n];      IF (r ¬ Inline.LowHalf[lr]) > 9 THEN r ¬ r + 'A - '0 - 10;      AppendChar[s, r + '0];      END;    xn[n ! StringBoundsFault => RESUME[ps­ ¬ StringBoundsFault[s]]];    END; --AppendLongNumber--  StringToLongNumber: PROCEDURE [s: LONG STRING, radix: CARDINAL]    RETURNS [number: LONG CARDINAL ¬ 0] =    BEGIN OPEN Inline;    char: CHARACTER;    cp, startOfNumerics: CARDINAL ¬ 0;    newNumber, exp: LONG CARDINAL ¬ 0;    neg, digitsFound, noExponent: BOOLEAN ¬ FALSE;    getchar: PROCEDURE =      BEGIN char ¬ IF cp >= s.length THEN NUL ELSE s[cp]; cp ¬ cp + 1; END;          IF s = NIL THEN SIGNAL InvalidNumber;    getchar[];        -- Get to first digit.    WHILE char <= Space OR char = '+ DO      IF char = NUL THEN SIGNAL InvalidNumber;      getchar[];      ENDLOOP;    IF char = '- THEN BEGIN neg ¬ TRUE; getchar[] END;        -- Get overriding suffix (if any).    startOfNumerics ¬ cp-1;    WHILE char IN ['0..'9] DO      digitsFound ¬ TRUE;      getchar[];      ENDLOOP;    IF NOT digitsFound THEN SIGNAL InvalidNumber;    SELECT LOOPHOLE[BITAND[char, 137B], CHARACTER] FROM      NUL => noExponent ¬ TRUE;      'B => radix ¬ 8;      'D => radix ¬ 10;      ENDCASE => noExponent ¬ TRUE;    IF NOT radix IN [1..10] THEN SIGNAL InvalidNumber;    cp ¬ startOfNumerics; getchar[];        -- Get mantissa.    WHILE char IN ['0..'9] DO      IF CARDINAL[char-'0] > radix-1 THEN SIGNAL InvalidNumber;      newNumber ¬ number*radix + (char-'0);--      IF newNumber < number THEN SIGNAL Overflow ELSE number ¬ newNumber;      number ¬ newNumber;      getchar[];      ENDLOOP;    -- Get exponent (if any).    IF NOT noExponent THEN      BEGIN      getchar[]; --(skip the radix suffux.)      WHILE char IN ['0..'9] DO exp ¬ exp*10 + (char-'0); getchar[]; ENDLOOP;      THROUGH [1..exp] DO	newNumber ¬ number*radix;--	IF newNumber < number THEN SIGNAL Overflow ELSE number ¬ newNumber;        number ¬ newNumber;	ENDLOOP;      END;    IF char # NUL THEN SIGNAL InvalidNumber;    IF neg THEN RETURN[-number];    END; --StringToLongNumber--  END....
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- File: QuickSortImpl.mesa - last edit by:-- PXK    ,	 5-May-83 13:30:35 -- BTL  ,	21-Apr-83 18:49:51 DIRECTORY  QuickSort USING [ClientData, CompareProc, Index, SwapProc];QuickSortImpl: PROGRAM EXPORTS QuickSort =  BEGIN  Index: TYPE = QuickSort.Index;  ClientData: TYPE = QuickSort.ClientData;    CompareProc: TYPE = QuickSort.CompareProc;  SwapProc: TYPE = QuickSort.SwapProc;    Sort: PUBLIC PROC [    min, max: Index, compare: CompareProc, swap: SwapProc, data: ClientData] = {    doMax: BOOLEAN ¬ TRUE;    middle: Index = (max + min) / 2;    i, j: Index;    IF max - min < 8 THEN {  -- with 8 or fewer elements      InsertionSort[min, max, compare, swap, data]; RETURN};        -- put the median of min, max, and middle at min    IF compare[middle, max, data] = bigger THEN swap[middle, max, data];    IF compare[middle, min, data] = bigger THEN swap[middle, min, data];    IF compare[min, max, data] = bigger THEN swap[min, max, data];        i ¬ min;    j ¬ max;    WHILE i < j DO      IF compare[i, j, data] = bigger THEN {swap[i, j, data]; doMax ¬ ~doMax};      IF doMax THEN j ¬ j - 1 ELSE i ¬ i + 1;      ENDLOOP;    Sort[min, i - 1, compare, swap, data];    Sort[i + 1, max, compare, swap, data]};    InsertionSort: PROC [    min, max: Index, compare: CompareProc, swap: SwapProc, data: ClientData] = {    FOR j: Index IN (min..max] DO      -- ASSERT that elements in range [min..j) are now in order      -- the inner loop drags down the jth element to its proper position      FOR i: Index DECREASING IN [min..j) DO        IF compare[i, i+1, data] = bigger THEN swap[i, i+1, data]	ELSE EXIT;  -- the sub range is done	ENDLOOP;      ENDLOOP};    END...  
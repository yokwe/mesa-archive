-- Copyright (C) 1983, 1984, 1985, 1986, 1987  by Xerox Corporation. All rights reserved. -- FloppyImplPublicA.mesa (last edited by: CAJ on:  31-Jan-87 12:03:35)DIRECTORY   Environment USING [PageCount, wordsPerPage],   File USING [File, GetSize, PageCount, PageNumber, Type],   Floppy USING [      BootFilePointer, defaultPageCount, Density, ErrorType, FileHandle, FileID,      nullBootFilePointer, nullFileID, nullIndex, PageCount, PageNumber, Sides,      VolumeHandle],   FloppyExtras3,   FloppyChannel USING [      Error, GetDeviceAttributes, GetHandle, Nop, SetContext, Status],   FloppyFormat USING [      badSpotSector, BadSpotSectors, ConvertPageCount, ConvertPageNumber,      dataContext,      DiskAddressToSector, FileList, FileListEntry, FileListSeal, FileListVersion,      FloppySeal, FloppyVersion, ImplementedFileSize, InitialMicrocodeDiskAddress,      MarkerPage, MarkerSeal, maxBadSectors, minTrackZeroSectors, nullSector,      Sector, SectorNine, TrackZero, trackZeroAddress, TrackZeroSector],   FloppyImplInterface,   Inline USING [HighHalf],   Space USING [      CopyIn, CopyOut, Error, Interval, Kill, nullInterval, PageCount, Unmap],   SpecialFloppy USING [Error],   FloppyExtrasExtras,   SpecialSystem USING [Unimplemented],   System USING [isUtilityPilot];FloppyImplPublicA: MONITOR   LOCKS volumeDesc USING volumeDesc: FloppyImplInterface.VolumeDesc   IMPORTS      File, FloppyChannel, FloppyFormat, FloppyImplInterface, Inline,  Space,      SpecialFloppy, SpecialSystem, System   EXPORTS      Floppy, FloppyExtras3, FloppyImplInterface, FloppyExtrasExtras   SHARES FloppyImplInterface =BEGIN OPEN FloppyImplInterface;	-- PUBLIC ERRORs, SIGNALs and TYPEsAlreadyFormatted: PUBLIC SIGNAL [labelString: LONG STRING] = CODE;DataError: PUBLIC ERROR [   file: Floppy.FileHandle, page: Floppy.PageNumber, vm: LONG POINTER] = CODE;Error: PUBLIC ERROR [error: Floppy.ErrorType] = CODE;VolumeHandle: PUBLIC TYPE = RECORD [deviceIndex: CARDINAL, changeCount: CARDINAL];nullVolumeHandle: PUBLIC VolumeHandle ¬ [LAST[CARDINAL], LAST[CARDINAL]];	-- Local constants	--these are magic numbers that work for the floppy stuffMaxBufferSize: Space.PageCount ¬ IF System.isUtilityPilot THEN 16 ELSE 32;FormatVerifyPasses: CARDINAL ¬ 2;	-- PUBLIC operationsClose: PUBLIC PROCEDURE [volume: VolumeHandle] =   BEGIN   CloseVolumeInternal: ENTRY PROCEDURE [volumeDesc: VolumeDesc] =      BEGIN ENABLE UNWIND => NULL;      CloseVolume[volumeDesc];      END;   []¬ValidateHandle[volume];   CloseVolumeInternal[volumeTable[volume.deviceIndex]];   END;Compact: PUBLIC PROCEDURE [volume: VolumeHandle] =   BEGIN   []¬ValidateHandle[volume];   END;CopyFromPilotFile: PUBLIC PROCEDURE [  pilotFile: File.File, floppyFile: Floppy.FileHandle,  firstPilotPage: File.PageNumber, firstFloppyPage: Floppy.PageNumber,  count: Floppy.PageCount] =   BEGIN   buffer: Space.Interval ¬ Space.nullInterval;   CopyPilotFile: ENTRY PROCEDURE [      volumeDesc: VolumeDesc, pilotFile: File.File,      floppyFile: Floppy.FileHandle, firstPilotPage: File.PageNumber,      firstFloppyPage: Floppy.PageNumber, count: Floppy.PageCount] =      BEGIN      ENABLE         BEGIN         DiskChanged => {CloseVolume[volumeDesc]; GO TO diskChanged};         UNWIND =>	    buffer.pointer ¬	      Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];	 END;      floppyFileAddress: FloppyFormat.Sector;      floppyFileSize: FloppyFormat.ImplementedFileSize;      pilotFileSize: File.PageCount;      filePageNumber: FloppyFormat.ImplementedFileSize;      pageCount: FloppyFormat.ImplementedFileSize;      done: LONG CARDINAL;         -- First validate our arguments      IF ~volumeDesc.open THEN RETURN WITH ERROR Error[volumeNotOpen];      pilotFileSize ¬ File.GetSize[pilotFile];      IF volumeDesc.writeProtected THEN RETURN WITH ERROR Error[writeInhibited];      [address: floppyFileAddress, size: floppyFileSize] ¬         FindFile[volumeDesc, floppyFile.file];      IF floppyFileAddress = FloppyFormat.nullSector THEN         RETURN WITH ERROR Error[fileNotFound];      IF (firstFloppyPage >= floppyFileSize) OR (firstPilotPage >= pilotFileSize)          THEN RETURN WITH ERROR Error[invalidPageNumber];      IF count = Floppy.defaultPageCount THEN         BEGIN	 count ¬ pilotFileSize - firstPilotPage;	 IF count > floppyFileSize - firstFloppyPage	   THEN RETURN WITH ERROR Error [incompatibleSizes];	 END      ELSE         IF (count > pilotFileSize - firstPilotPage)	   OR (count > floppyFileSize - firstFloppyPage) 	   THEN RETURN WITH ERROR Error[incompatibleSizes];      floppyFileAddress ¬        floppyFileAddress + FloppyFormat.ConvertPageNumber[firstFloppyPage];     IF Inline.HighHalf[count] ~= 0       THEN RETURN WITH ERROR Error[insufficientSpace];     pageCount ¬ FloppyFormat.ConvertPageCount[count];         -- Now go off and do our I/O         buffer ¬ CreateBuffer[MIN[count, MaxBufferSize]];      IF buffer.count = 0 THEN ERROR; -- insufficient VM to operate      FOR filePageNumber ¬ 0, filePageNumber+CARDINAL[buffer.count]        WHILE filePageNumber < pageCount DO         Space.Kill[buffer];         [] ¬ Space.CopyIn[buffer.pointer,	   [pilotFile, firstPilotPage+filePageNumber, buffer.count]];         WriteFloppy[           volumeDesc, buffer.pointer, floppyFileAddress+filePageNumber,	   MIN[CARDINAL[buffer.count],	     FloppyFormat.ConvertPageNumber[count-filePageNumber]]	   ! IOError => {done ¬ filePageNumber+countDone; GO TO dataError};	     UNWIND => buffer.pointer ¬ Space.Unmap[buffer.pointer];];	 REPEAT	 dataError => RETURN WITH ERROR DataError[floppyFile, done, NIL];	 FINISHED =>	   buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];         ENDLOOP;      EXITS      diskChanged => RETURN WITH ERROR Error[volumeNotOpen];      END;   volume: VolumeHandle = floppyFile.volume;   []¬ValidateHandle[volume];   CopyPilotFile[volumeTable[volume.deviceIndex], pilotFile, floppyFile,     firstPilotPage, firstFloppyPage, count];   END;CopyToPilotFile: PUBLIC PROCEDURE [  floppyFile: Floppy.FileHandle, pilotFile: File.File,  firstFloppyPage: Floppy.PageNumber, firstPilotPage: File.PageNumber,  count: Floppy.PageCount] =   BEGIN   buffer: Space.Interval ¬ Space.nullInterval;   CopyFloppyFile: ENTRY PROCEDURE [      volumeDesc: VolumeDesc, floppyFile: Floppy.FileHandle,      pilotFile: File.File, firstFloppyPage: Floppy.PageNumber,      firstPilotPage: File.PageNumber, count: Floppy.PageCount] =      BEGIN      ENABLE         BEGIN	 DiskChanged => {CloseVolume[volumeDesc]; GO TO diskChanged};         UNWIND =>	    buffer.pointer ¬	      Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];	 END;      floppyFileAddress: FloppyFormat.Sector;      floppyFileSize: FloppyFormat.ImplementedFileSize;      pilotFileSize: File.PageCount;      filePageNumber: FloppyFormat.ImplementedFileSize;      pageCount: FloppyFormat.ImplementedFileSize;      done: LONG CARDINAL;         -- First validate our arguments      IF ~volumeDesc.open THEN RETURN WITH ERROR Error[volumeNotOpen];       pilotFileSize ¬ File.GetSize[pilotFile];      [address: floppyFileAddress, size: floppyFileSize] ¬         FindFile[volumeDesc, floppyFile.file];      IF floppyFileAddress = FloppyFormat.nullSector THEN         RETURN WITH ERROR Error[fileNotFound];      IF (firstFloppyPage >= floppyFileSize) OR (firstPilotPage >= pilotFileSize)         THEN RETURN WITH ERROR Error[invalidPageNumber];      IF count = Floppy.defaultPageCount THEN         BEGIN	 count ¬ floppyFileSize - firstFloppyPage;         IF count > pilotFileSize - firstPilotPage	   THEN RETURN WITH ERROR Error[incompatibleSizes];         END      ELSE         IF (count > pilotFileSize - firstPilotPage)	   OR (count > floppyFileSize - firstFloppyPage)             THEN RETURN WITH ERROR Error[incompatibleSizes];      floppyFileAddress ¬        floppyFileAddress + FloppyFormat.ConvertPageNumber[firstFloppyPage];      pageCount ¬ FloppyFormat.ConvertPageCount[count];         -- Now go off and do our I/O         buffer ¬ CreateBuffer[MIN[pageCount, MaxBufferSize]];      FOR filePageNumber ¬ 0, filePageNumber+CARDINAL[buffer.count]          WHILE filePageNumber < pageCount DO         pages: CARDINAL = MIN[CARDINAL[buffer.count], pageCount-filePageNumber];         Space.Kill[buffer];	 ReadFloppy[	    volumeDesc, buffer.pointer, floppyFileAddress+filePageNumber, pages !	      IOError => {done ¬ filePageNumber+countDone; GO TO dataError};	      UNWIND => buffer.pointer ¬ Space.Unmap[buffer.pointer]];	 [] ¬ Space.CopyOut[	   buffer.pointer, [pilotFile, firstPilotPage+filePageNumber, pages]];	 REPEAT	 dataError => RETURN WITH ERROR DataError[floppyFile, done, NIL];	 FINISHED => 	  buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];         ENDLOOP;      EXITS      diskChanged => RETURN WITH ERROR Error[volumeNotOpen];      END;  -- CopyFloppyFile   volume: VolumeHandle = floppyFile.volume;   []¬ValidateHandle[volume];   CopyFloppyFile[volumeTable[volume.deviceIndex], floppyFile, pilotFile,     firstFloppyPage, firstPilotPage, count];   END;CreateFile: PUBLIC PROCEDURE [   volume: VolumeHandle, size: Floppy.PageCount, type:File.Type]   RETURNS [file: Floppy.FileHandle] =   BEGIN   volumeDesc: VolumeDesc;      CreateFileEntryInternal: ENTRY PROCEDURE[     volumeDesc: VolumeDesc, size: Floppy.PageCount, type: File.Type,     startSector: FloppyFormat.Sector]     RETURNS[file: Floppy.FileID]=     BEGIN       ENABLE       BEGIN       UNWIND => NULL;       END;     IF ~volumeDesc.open THEN RETURN WITH ERROR Error[volumeNotOpen];     IF volumeDesc.writeProtected THEN RETURN WITH ERROR Error[writeInhibited];     file ¬        CreateFileInternal[	   volumeDesc, size, type, startSector, Floppy.nullFileID].fileID;     END;   file.volume ¬ volume;   volumeDesc ¬ ValidateHandle[volume];   file.file ¬     CreateFileEntryInternal[       volumeDesc, size, type, FloppyFormat.nullSector];   END;CreateInitialMicrocodeFile: PUBLIC PROCEDURE [   volume: VolumeHandle, size: Floppy.PageCount, type: File.Type,   startingPageNumber: Floppy.PageNumber]   RETURNS [file: Floppy.FileHandle] =   BEGIN   volumeDesc: VolumeDesc;        file.volume ¬ volume;  volumeDesc ¬ ValidateHandle[volume];  file.file ¬     CreateInitialMicrocodeInternal[       volumeDesc, size, type, startingPageNumber, Floppy.nullFileID];   END;CreateInitialMicrocodeInternal: PUBLIC ENTRY PROCEDURE[   volumeDesc: VolumeDesc, size: Floppy.PageCount, type: File.Type,   startingPageNumber: Floppy.PageNumber, id: Floppy.FileID]   RETURNS[file: Floppy.FileID]=   BEGIN     ENABLE     BEGIN     UNWIND => NULL;     END;   alignmentSector, startSector: FloppyFormat.Sector; --physical pages for file   IF ~volumeDesc.open THEN RETURN WITH ERROR Error[volumeNotOpen];   IF volumeDesc.writeProtected THEN RETURN WITH ERROR Error[writeInhibited];   IF startingPageNumber >= size THEN RETURN WITH ERROR Error[invalidPageNumber];   alignmentSector ¬   FloppyFormat.DiskAddressToSector[      FloppyFormat.InitialMicrocodeDiskAddress,      volumeDesc.sectorNine.cylinders,      volumeDesc.sectorNine.tracksPerCylinder,      volumeDesc.sectorNine.sectorsPerTrack];   -- line up file so specified page resides at hard-wired location on disk   startSector ¬      alignmentSector - FloppyFormat.ConvertPageNumber[startingPageNumber];   file ¬      CreateFileInternal[volumeDesc, size, type, startSector, id !         SpecialFloppy.Error => GO TO noRoom].fileID;   EXITS   noRoom => RETURN WITH ERROR Error[initialMicrocodeSpaceNotAvailable];   END;    CreateFileInternal: PUBLIC PROCEDURE [    volumeDesc: VolumeDesc, size: Floppy.PageCount, type: File.Type,    startSector: FloppyFormat.Sector, id: Floppy.FileID]     RETURNS[fileID: Floppy.FileID, startPage: FloppyFormat.Sector] =    BEGIN    ENABLE       BEGIN       DiskChanged => {CloseVolume[volumeDesc]; GO TO diskChanged};       IOError => {CloseVolume[volumeDesc]; GO TO needsScavenging;};       END;   -- Check overflow here since we can't easily undo the AllocateFile   IF volumeDesc.fileList.count = volumeDesc.fileList.maxEntries THEN       ERROR Error[fileListFull];   VolumeChanging[volumeDesc];   [startPage, fileID] ¬ AllocateFile[volumeDesc, size, type, startSector, id];   AddFile[     volumeDesc, fileID, FloppyFormat.ConvertPageCount[size], type, startPage];   VolumeStable[volumeDesc]; -- The volume is now stable   EXITS   needsScavenging => ERROR Error[needsScavenging];   diskChanged => ERROR Error[volumeNotOpen];   END;DeleteFile: PUBLIC PROCEDURE [file: Floppy.FileHandle] =   BEGIN   buffer: Space.Interval ¬ Space.nullInterval;   DeleteFileInternal: ENTRY PROCEDURE [     volumeDesc: VolumeDesc, fileID: Floppy.FileID] =      BEGIN      ENABLE         BEGIN	 DiskChanged => {CloseVolume[volumeDesc]; GO TO diskChanged};	 IOError => {CloseVolume[volumeDesc]; GO TO needsScavenging};	 UNWIND => buffer.pointer ¬ Space.Unmap[buffer.pointer]	 END;      zerothMarkerPage: LONG POINTER TO FloppyFormat.MarkerPage;      firstMarkerPage: LONG POINTER TO FloppyFormat.MarkerPage;      secondMarkerPage: LONG POINTER TO FloppyFormat.MarkerPage;      thirdMarkerPage: LONG POINTER TO FloppyFormat.MarkerPage;      zerothMarkerPageAddress: FloppyFormat.Sector ¬ FloppyFormat.nullSector;      firstMarkerPageAddress: FloppyFormat.Sector;      secondMarkerPageAddress: FloppyFormat.Sector;      thirdMarkerPageAddress: FloppyFormat.Sector ¬ FloppyFormat.nullSector;      address: FloppyFormat.Sector;      firstDeletion, lastDeletion: FloppyFormat.Sector;      size: FloppyFormat.ImplementedFileSize;            IF ~volumeDesc.open THEN RETURN WITH ERROR Error[volumeNotOpen];      IF volumeDesc.writeProtected THEN RETURN WITH ERROR Error[writeInhibited];      [address: address, size: size] ¬ FindFile[volumeDesc, fileID];      IF address = FloppyFormat.nullSector THEN         RETURN WITH ERROR Error[fileNotFound];      IF fileID = volumeDesc.sectorNine.fileListID THEN RETURN;         -- It is a no-op to delete the file list            buffer ¬ CreateBuffer[4];      IF buffer.count < 4 THEN ERROR; -- Insufficient VM to operate            zerothMarkerPage ¬ LOOPHOLE[buffer.pointer];      firstMarkerPage ¬ zerothMarkerPage+Environment.wordsPerPage;	      secondMarkerPage ¬ firstMarkerPage+Environment.wordsPerPage;      thirdMarkerPage ¬ secondMarkerPage+Environment.wordsPerPage;      firstMarkerPageAddress ¬ address-1;      secondMarkerPageAddress ¬ address+size;            ReadFloppy[volumeDesc, firstMarkerPage, firstMarkerPageAddress, 1];      IF secondMarkerPageAddress ~=          firstMarkerPageAddress+firstMarkerPage.next.length+1 THEN        BEGIN      	 volumeDesc.open ¬ FALSE;      	 buffer.pointer ¬ Space.Unmap[buffer.pointer];      	 RETURN WITH ERROR Error[needsScavenging];      	 END;            ReadFloppy[volumeDesc, secondMarkerPage, secondMarkerPageAddress, 1];      IF secondMarkerPageAddress-secondMarkerPage.previous.length-1 ~=          firstMarkerPageAddress THEN        BEGIN      	 CloseVolume[volumeDesc];      	 buffer.pointer ¬ Space.Unmap[buffer.pointer];      	 RETURN WITH ERROR Error[needsScavenging];      	 END;            VolumeChanging[volumeDesc];      IF firstMarkerPage.previous.type = free THEN         BEGIN         zerothMarkerPageAddress ¬ firstMarkerPageAddress -	   FloppyFormat.ConvertPageCount[firstMarkerPage.previous.length] -1;         firstDeletion ¬ firstMarkerPageAddress;         ReadFloppy[volumeDesc, zerothMarkerPage, zerothMarkerPageAddress, 1];         IF zerothMarkerPageAddress+zerothMarkerPage.next.length+1 ~=	   firstMarkerPageAddress THEN             BEGIN	     CloseVolume[volumeDesc];	     buffer.pointer ¬ Space.Unmap[buffer.pointer];	     RETURN WITH ERROR Error[needsScavenging];	     END;         END       ELSE         firstDeletion ¬ address;      IF (secondMarkerPage.next.type = free)        AND (secondMarkerPageAddress~=volumeDesc.numPages) THEN         BEGIN         thirdMarkerPageAddress ¬ secondMarkerPageAddress +	   FloppyFormat.ConvertPageCount[secondMarkerPage.next.length]+1;         lastDeletion ¬ secondMarkerPageAddress;         ReadFloppy[volumeDesc, thirdMarkerPage, thirdMarkerPageAddress, 1];         IF thirdMarkerPageAddress-thirdMarkerPage.previous.length-1 ~=	   secondMarkerPageAddress THEN             BEGIN	     CloseVolume[volumeDesc];	     buffer.pointer ¬ Space.Unmap[buffer.pointer];	     RETURN WITH ERROR Error[needsScavenging];	     END;         END       ELSE         lastDeletion ¬ secondMarkerPageAddress -1;      --set marker page fields      IF zerothMarkerPageAddress = FloppyFormat.nullSector THEN         BEGIN         firstMarkerPage.next.body ¬ free[];         IF thirdMarkerPageAddress = FloppyFormat.nullSector THEN             secondMarkerPage.previous.body ¬ free[]         ELSE             BEGIN             firstMarkerPage.next.length ¬	       size + 1 + secondMarkerPage.next.length;             thirdMarkerPage.previous.length ¬ firstMarkerPage.next.length;             END;         END      ELSE         BEGIN         IF thirdMarkerPageAddress = FloppyFormat.nullSector THEN             BEGIN             secondMarkerPage.previous.body ¬ free[];             zerothMarkerPage.next.length ¬	       size + 1 + zerothMarkerPage.next.length;             secondMarkerPage.previous.length ¬ zerothMarkerPage.next.length;             END         ELSE             BEGIN             zerothMarkerPage.next.length ¬ zerothMarkerPage.next.length + 2 	       + size + secondMarkerPage.next.length;             thirdMarkerPage.previous.length ¬ zerothMarkerPage.next.length;             END;         END;      -- write marker pages out to disk      IF zerothMarkerPageAddress = FloppyFormat.nullSector THEN         WriteFloppy[volumeDesc, firstMarkerPage, firstMarkerPageAddress, 1]      ELSE         WriteFloppy[volumeDesc, zerothMarkerPage, zerothMarkerPageAddress, 1];      IF thirdMarkerPageAddress = FloppyFormat.nullSector THEN         WriteFloppy[volumeDesc, secondMarkerPage, secondMarkerPageAddress, 1]      ELSE         WriteFloppy[volumeDesc, thirdMarkerPage, thirdMarkerPageAddress, 1];      FOR i: FloppyFormat.Sector IN [firstDeletion..lastDeletion] DO         volumeDesc.allocationMap[i] ¬ free;      ENDLOOP;      RemoveFile[volumeDesc, fileID];      VolumeStable[volumeDesc];            buffer.pointer ¬ Space.Unmap[buffer.pointer];      EXITS      diskChanged => RETURN WITH ERROR Error[volumeNotOpen];      needsScavenging => RETURN WITH ERROR Error[needsScavenging]      END;   volume: VolumeHandle = file.volume;   []¬ValidateHandle[volume];   DeleteFileInternal[volumeTable[volume.deviceIndex], file.file];   END;   GetAttributes: PUBLIC PROCEDURE [volume: VolumeHandle, labelString: LONG STRING]   RETURNS [     freeSpace: Floppy.PageCount, largestBlock: Floppy.PageCount,     fileList: Floppy.FileHandle, rootFile: Floppy.FileHandle,     density: Floppy.Density[single..double], sides: Floppy.Sides[one..two],      maxFileListEntries: CARDINAL] =   BEGIN   GetAttrributesInternal: ENTRY PROCEDURE [volumeDesc: VolumeDesc] =      BEGIN      startRun: FloppyFormat.Sector;      inRun: BOOLEAN;      firstDataSector: FloppyFormat.Sector = FirstDataSector[volumeDesc];      lastDataSector: FloppyFormat.Sector =        FloppyFormat.ConvertPageCount[volumeDesc.numPages];            IF ~volumeDesc.open THEN RETURN WITH ERROR Error[volumeNotOpen];      inRun ¬ FALSE;      startRun ¬ 0;      largestBlock ¬ 0;      freeSpace ¬ 0;      maxFileListEntries ¬ volumeDesc.fileList.maxEntries;      fileList ¬ [volume, volumeDesc.sectorNine.fileListID];      rootFile ¬ [volume, volumeDesc.sectorNine.rootFile];      density ¬ volumeDesc.density;      sides ¬ volumeDesc.sides;      IF labelString ~= NIL THEN         BEGIN	 IF labelString.maxlength < volumeDesc.sectorNine.labelSize THEN	    RETURN WITH ERROR Error[stringTooShort];	 labelString.length ¬ 0;         FOR i: CARDINAL IN [0..volumeDesc.sectorNine.labelSize) DO	    labelString[labelString.length] ¬ volumeDesc.sectorNine.label[i];	    labelString.length ¬ labelString.length+1;	    ENDLOOP;	 END;      FOR i: FloppyFormat.Sector IN [firstDataSector..lastDataSector) DO         IF volumeDesc.allocationMap[i] = free THEN	    BEGIN	    freeSpace ¬ freeSpace+1;	    IF ~inRun THEN {inRun ¬ TRUE; startRun ¬ i} ELSE NULL;	    END	 ELSE IF inRun	   THEN {inRun ¬ FALSE; largestBlock ¬ MAX[largestBlock, i-startRun]};	 ENDLOOP;      IF inRun        THEN largestBlock ¬ MAX[largestBlock, volumeDesc.numPages-startRun];      END;  -- GetAttributesInternal   []¬ValidateHandle[volume];   GetAttrributesInternal[volumeTable[volume.deviceIndex]];   END;   --This should really be part of GetAttributes   GetDrive: PUBLIC PROC [volumeHandle: VolumeHandle]   -- FloppyExtrasExtras--   RETURNS [drive: CARDINAL]  = {     drive ¬ volumeHandle.deviceIndex;     IF ~ValidDrive[drive] THEN ERROR Error[invalidVolumeHandle] };     GetBootFiles: PUBLIC PROCEDURE [volume: VolumeHandle]   RETURNS [      initialMicrocode, pilotMicrocode, diagnosticMicrocode, germ,         pilotBootFile: Floppy.BootFilePointer] =   BEGIN   GetBootFilesInternal: ENTRY PROCEDURE [     volumeDesc: VolumeDesc, page: FloppyFormat.Sector]      RETURNS [floppyBootFileData: Floppy.BootFilePointer] =      BEGIN      FOR index: CARDINAL IN [0..volumeDesc.fileList.count) DO         IF page IN [volumeDesc.fileList.files[index].location..	   volumeDesc.fileList.files[index].location +	     volumeDesc.fileList.files[index].size)            THEN                BEGIN               floppyBootFileData.file ¬ volumeDesc.fileList.files[index].file;                floppyBootFileData.page ¬	         page - volumeDesc.fileList.files[index].location;               EXIT;               END;      REPEAT      FINISHED => floppyBootFileData ¬ Floppy.nullBootFilePointer;      ENDLOOP;      END;  -- GetBootFilesInternal   volumeDesc: VolumeDesc;   volumeDesc ¬ ValidateHandle[volume];   IF ~volumeDesc.open THEN ERROR Error[volumeNotOpen];   initialMicrocode ¬ GetBootFilesInternal[     volumeDesc, FloppyFormat.DiskAddressToSector[     FloppyFormat.InitialMicrocodeDiskAddress,volumeDesc.sectorNine.cylinders,     volumeDesc.sectorNine.tracksPerCylinder,     volumeDesc.sectorNine.sectorsPerTrack]];   pilotMicrocode ¬     GetBootFilesInternal[volumeDesc, volumeDesc.sectorNine.pilotMicrocode];   diagnosticMicrocode ¬     GetBootFilesInternal[volumeDesc, volumeDesc.sectorNine.diagnosticMicrocode];   germ ¬ GetBootFilesInternal[volumeDesc, volumeDesc.sectorNine.germ];   pilotBootFile ¬     GetBootFilesInternal[volumeDesc, volumeDesc.sectorNine.pilotBootFile];   END;GetBootFilesAlternateUCode: PUBLIC PROCEDURE [volume: Floppy.VolumeHandle]  RETURNS [alternateUCode: Floppy.BootFilePointer] =  BEGIN  volumeDesc: VolumeDesc ¬ ValidateHandle[volume];  IF ~volumeDesc.open THEN ERROR Error[volumeNotOpen];  alternateUCode ¬ GetBootFilesInternal[    volumeDesc, volumeDesc.sectorNine.alternateMicrocode];  END;  -- GetBootFilesAlternateUCodeGetBootFilesInternal: ENTRY PROCEDURE [  volumeDesc: VolumeDesc, page: FloppyFormat.Sector]   RETURNS [floppyBootFileData: Floppy.BootFilePointer] =  BEGIN  FOR index: CARDINAL IN [0..volumeDesc.fileList.count) DO    IF page IN [volumeDesc.fileList.files[index].location..      volumeDesc.fileList.files[index].location +        volumeDesc.fileList.files[index].size)      THEN         BEGIN        floppyBootFileData.file ¬ volumeDesc.fileList.files[index].file;         floppyBootFileData.page ¬	  page - volumeDesc.fileList.files[index].location;        EXIT;        END;    REPEAT    FINISHED => floppyBootFileData ¬ Floppy.nullBootFilePointer;    ENDLOOP;  END;  -- GetBootFilesInternalGetFileAttributes: PUBLIC PROCEDURE [file: Floppy.FileHandle]   RETURNS [size: Floppy.PageCount, type: File.Type] =   BEGIN   GetFileAttributesInternal: ENTRY PROCEDURE [volumeDesc: VolumeDesc] =      BEGIN      IF ~volumeDesc.open THEN RETURN WITH ERROR Error[volumeNotOpen];      FOR i: CARDINAL IN [0..volumeDesc.fileList.count) DO         IF volumeDesc.fileList.files[i].file = file.file THEN	    BEGIN	    size ¬ volumeDesc.fileList.files[i].size;	    type ¬ volumeDesc.fileList.files[i].type;	    RETURN;	    END;	 ENDLOOP;      RETURN WITH ERROR Error[fileNotFound];      END;   volume: VolumeHandle = file.volume;   []¬ValidateHandle[volume];   GetFileAttributesInternal[volumeTable[volume.deviceIndex]];   END;GetNextFile: PUBLIC PROCEDURE [  file: Floppy.FileHandle] RETURNS [nextFile: Floppy.FileHandle] =    BEGIN    GetNextFileInternal: ENTRY PROCEDURE [volumeDesc: VolumeDesc] =      BEGIN      IF ~volumeDesc.open THEN RETURN WITH ERROR Error[volumeNotOpen];      IF file.file = Floppy.nullFileID THEN        --return first file that's not the directory        FOR i: CARDINAL IN [0..volumeDesc.fileList.count) DO          IF volumeDesc.fileList.files[i].file ~=	      volumeDesc.sectorNine.fileListID THEN            BEGIN            nextFile ¬ [file.volume, volumeDesc.fileList.files[i].file];            RETURN;            END;          REPEAT          FINISHED =>            BEGIN            nextFile ¬ [file.volume, Floppy.nullFileID];            RETURN;            END;          ENDLOOP      ELSE --go find such a file        FOR i:CARDINAL IN [0..volumeDesc.fileList.count) DO          IF volumeDesc.fileList.files[i].file = file.file THEN            BEGIN            IF (i = volumeDesc.fileList.count-1)              OR ((i = volumeDesc.fileList.count-2) AND                (volumeDesc.fileList.files[i+1].file =	        volumeDesc.sectorNine.fileListID))                  THEN nextFile ¬ [file.volume, Floppy.nullFileID]            ELSE              nextFile ¬ IF volumeDesc.fileList.files[i+1].file =	        volumeDesc.sectorNine.fileListID                  THEN [file.volume, volumeDesc.fileList.files[i+2].file]                  ELSE [file.volume, volumeDesc.fileList.files[i+1].file];            RETURN;            END;       	 ENDLOOP;      RETURN WITH ERROR Error[fileNotFound];      END;   volume: VolumeHandle = file.volume;   []¬ValidateHandle[volume];   GetNextFileInternal[volumeTable[volume.deviceIndex]];   END;GetNextBadSector: PUBLIC PROCEDURE [volume: VolumeHandle, oldIndex: CARDINAL]   RETURNS [newIndex: CARDINAL, file: Floppy.FileHandle, page: Floppy.PageNumber]=   BEGIN   []¬ValidateHandle[volume];   RETURN[Floppy.nullIndex, [nullVolumeHandle, Floppy.nullFileID], 0];   END;Open: PUBLIC PROCEDURE [  drive: CARDINAL ¬ 0] RETURNS [volume: Floppy.VolumeHandle] =    BEGIN    buffer: Space.Interval ¬ Space.nullInterval;    OpenInternal: ENTRY PROCEDURE [volumeDesc: VolumeDesc]      RETURNS [volume: VolumeHandle] =      BEGIN      ENABLE         BEGIN	 IOError => GO TO needsScavenging;	 UNWIND => 	   buffer.pointer ¬ Space.Unmap[buffer.pointer ! Space.Error => CONTINUE];	 END;      markerPage: LONG POINTER TO FloppyFormat.MarkerPage;      requestedSize: Space.PageCount;      bound: CARDINAL;      lastMoved: CARDINAL;      temp: FloppyFormat.FileListEntry;      trackZero: FloppyFormat.TrackZero;                  IF volumeDesc.open THEN        BEGIN	[] ¬ FloppyChannel.Nop[volumeDesc.handle	  ! FloppyChannel.Error => GO TO close];	EXITS	close => CloseVolume[volumeDesc ! Error => CONTINUE];	END;             IF volumeDesc.open THEN RETURN [[drive, volumeDesc.changeCount]];       requestedSize ¬         WordsToPages[(SIZE[FloppyFormat.TrackZeroSector] *	 FloppyFormat.minTrackZeroSectors)] +          WordsToPages[SIZE[FloppyFormat.MarkerPage]];      buffer ¬ CreateBuffer[requestedSize];      IF requestedSize ~= buffer.count THEN ERROR;	    -- Insufficient VM to operate in      trackZero.BASE ¬ LOOPHOLE[buffer.pointer];      markerPage ¬ LOOPHOLE[         BASE[trackZero] +	 Environment.wordsPerPage *	 (WordsToPages[FloppyFormat.minTrackZeroSectors *	 SIZE[FloppyFormat.TrackZeroSector]])];            volumeDesc.handle ¬ FloppyChannel.GetHandle[drive];        -- Read track zero.  Validate its contents and fill in our local database.            AccessFloppy[         volumeDesc, BASE[trackZero], FloppyFormat.trackZeroAddress,	 FloppyFormat.minTrackZeroSectors, read];      volumeDesc.sectorNine­ ¬ LOOPHOLE[trackZero[9]];      IF volumeDesc.sectorNine.changing THEN          GO TO needsScavenging;      IF volumeDesc.sectorNine.seal ~= FloppyFormat.FloppySeal THEN         GO TO needsScavenging;      IF volumeDesc.sectorNine.version ~= FloppyFormat.FloppyVersion THEN         GO TO needsScavenging;      FOR i: CARDINAL IN [0..FloppyFormat.maxBadSectors) DO         volumeDesc.badPageMap­[i] ¬	   LOOPHOLE[BASE[trackZero]+(FloppyFormat.badSpotSector-1)*	     SIZE[FloppyFormat.TrackZeroSector],	   LONG POINTER TO FloppyFormat.BadSpotSectors]­[i];	 ENDLOOP;      volumeDesc.writeProtected ¬ IsDriveWriteProtected[volumeDesc];            SELECT TRUE FROM        FloppyChannel.SetContext[	  volumeDesc.handle,	  FloppyFormat.dataContext[single]] AND            FloppyChannel.GetDeviceAttributes[volumeDesc.handle]	    .maxSectorsPerTrack = volumeDesc.sectorNine.sectorsPerTrack	   => volumeDesc.density ¬ single;        FloppyChannel.SetContext	  [volumeDesc.handle,	  FloppyFormat.dataContext[double]] AND	    FloppyChannel.GetDeviceAttributes[volumeDesc.handle]	    .maxSectorsPerTrack = volumeDesc.sectorNine.sectorsPerTrack	   => volumeDesc.density ¬ double;	ENDCASE => GO TO needsScavenging;      IF volumeDesc.sectorNine.tracksPerCylinder = 1         THEN volumeDesc.sides ¬ one         ELSE IF volumeDesc.sectorNine.tracksPerCylinder = 2 	   THEN volumeDesc.sides ¬ two           ELSE GO TO needsScavenging;      IF volumeDesc.sectorNine.cylinders = 0 THEN         GO TO needsScavenging;      volumeDesc.numPages ¬         volumeDesc.sectorNine.sectorsPerTrack*	   volumeDesc.sectorNine.tracksPerCylinder*	   volumeDesc.sectorNine.cylinders;            -- Now read and validate the fileList            ReadFloppy[volumeDesc, markerPage, volumeDesc.sectorNine.fileList-1, 1];      IF markerPage.seal ~= FloppyFormat.MarkerSeal THEN         GO TO needsScavenging;      WITH mp: markerPage.next SELECT FROM         free, file =>	    GO TO needsScavenging;	 fileList =>	    BEGIN	    IF mp.file ~= volumeDesc.sectorNine.fileListID THEN	       GO TO needsScavenging;	    IF mp.length ~= volumeDesc.sectorNine.fileListSize THEN	       GO TO needsScavenging;	    IF mp.type ~= FloppyImplInterface.FileListType THEN	       GO TO needsScavenging;	    END;	 ENDCASE => GO TO needsScavenging;      ReadFloppy[         volumeDesc: volumeDesc, buffer: markerPage, count: 1,	 address: volumeDesc.sectorNine.fileList +	   volumeDesc.sectorNine.fileListSize];      IF markerPage.seal ~= FloppyFormat.MarkerSeal THEN GO TO needsScavenging;      WITH mp: markerPage.previous SELECT FROM         free, file => GO TO needsScavenging;	 fileList =>	    BEGIN	    IF mp.file ~= volumeDesc.sectorNine.fileListID	OR	       mp.length ~= volumeDesc.sectorNine.fileListSize	OR	       mp.type ~= FloppyImplInterface.FileListType	    THEN GO TO needsScavenging;	    END;	 ENDCASE => GO TO needsScavenging;             volumeDesc.fileListSpace ¬ CreateBuffer[volumeDesc.sectorNine.fileListSize];      volumeDesc.fileList ¬ volumeDesc.fileListSpace.pointer;      ReadFloppy[         volumeDesc, volumeDesc.fileList, volumeDesc.sectorNine.fileList,	 volumeDesc.sectorNine.fileListSize];      IF volumeDesc.fileList.seal ~= FloppyFormat.FileListSeal		OR         volumeDesc.fileList.version ~= FloppyFormat.FileListVersion	OR	 volumeDesc.fileList.maxEntries = 0				OR	 volumeDesc.fileList.maxEntries < volumeDesc.fileList.count	OR	 volumeDesc.fileList.count = 0					OR	 FindFile[volumeDesc, volumeDesc.sectorNine.fileListID].address =	   FloppyFormat.nullSector      THEN GO TO needsScavenging;            -- Sort the file list if it is not already sorted: this is done to provide      -- backwards compatibility for floppies created using an older version of      -- floppyimpl      bound ¬ volumeDesc.fileList.count;      DO        lastMoved ¬ 0;        FOR i: CARDINAL IN [0..bound-1) DO          IF volumeDesc.fileList.files[i].location >	    volumeDesc.fileList.files[i+1].location THEN              BEGIN              temp ¬ volumeDesc.fileList.files[i];              volumeDesc.fileList.files[i] ¬ volumeDesc.fileList.files[i+1];              volumeDesc.fileList.files[i+1] ¬ temp;              lastMoved ¬ i;              END;          ENDLOOP;        IF lastMoved = 0 THEN EXIT        ELSE bound ¬ lastMoved+1;      ENDLOOP;      InitializeAllocationMap[volumeDesc];            volumeDesc.open ¬ TRUE;      buffer.pointer ¬ Space.Unmap[buffer.pointer];      RETURN [[drive, volumeDesc.changeCount]];      EXITS      needsScavenging =>         BEGIN	 buffer.pointer ¬ Space.Unmap[buffer.pointer];	 RETURN WITH ERROR Error[needsScavenging];	 END;      END;   IF ~ValidDrive[drive] THEN ERROR Error[noSuchDrive];   RETURN[OpenInternal[volumeTable[drive] ! DiskChanged => RETRY]];   END;Read: PUBLIC PROCEDURE [   file: Floppy.FileHandle, first: Floppy.PageNumber, count: Floppy.PageCount,   vm: LONG POINTER] =   BEGIN   done: Floppy.PageCount;   ReadInternal: ENTRY PROCEDURE [volumeDesc: VolumeDesc] =      BEGIN      ENABLE         BEGIN         IOError => {done ¬ countDone; GO TO dataError;};	 DiskChanged => {CloseVolume[volumeDesc]; GO TO diskChanged};	 UNWIND => NULL;	 END;      address: FloppyFormat.Sector;      size: FloppyFormat.ImplementedFileSize;      localFirst: FloppyFormat.ImplementedFileSize;            -- This procedure ASSUMES contiguous allocation of files on the diskette            IF ~volumeDesc.open THEN RETURN WITH ERROR Error[volumeNotOpen];      [address: address, size: size] ¬ FindFile[volumeDesc, file.file];      IF address = FloppyFormat.nullSector        THEN RETURN WITH ERROR Error[fileNotFound];      IF first >= size OR first+count > size        THEN RETURN WITH ERROR Error[endOfFile];      localFirst ¬ FloppyFormat.ConvertPageNumber[first];      ReadFloppy[        volumeDesc, vm, address+localFirst, FloppyFormat.ConvertPageCount[count]];      EXITS      dataError => RETURN WITH ERROR DataError [file, first+done, NIL];      diskChanged => RETURN WITH ERROR Error[volumeNotOpen];      END;   volume: VolumeHandle = file.volume;   []¬ValidateHandle[volume];   ReadInternal[volumeTable[volume.deviceIndex]];   END;ReplaceBadSector: PUBLIC PROCEDURE [  file: Floppy.FileHandle, page: Floppy.PageNumber]   RETURNS [readError: BOOLEAN] =   BEGIN   ERROR SpecialSystem.Unimplemented;   END;SetBootFiles: PUBLIC PROCEDURE [   volume: VolumeHandle, pilotMicrocode,   diagnosticMicrocode, germ, pilotBootFile: Floppy.BootFilePointer] =   BEGIN   SetBootFilesInternal: ENTRY PROCEDURE [volumeDesc: VolumeDesc] =      BEGIN      ENABLE        BEGIN      	 DiskChanged => {CloseVolume[volumeDesc]; GO TO diskChanged};      	 IOError => {CloseVolume[volumeDesc]; GO TO needsScavenging};       UNWIND => NULL;      	 END;      pilotMicrocodeSector, diagnosticMicrocodeSector, germSector,        pilotBootFileSector: FloppyFormat.Sector;      IF ~volumeDesc.open THEN RETURN WITH ERROR Error[volumeNotOpen];      IF volumeDesc.writeProtected THEN RETURN WITH ERROR Error[writeInhibited];      pilotMicrocodeSector ¬ GetBootFileAddress[volumeDesc, pilotMicrocode];      diagnosticMicrocodeSector ¬         GetBootFileAddress[volumeDesc, diagnosticMicrocode];      germSector ¬ GetBootFileAddress[volumeDesc, germ];      pilotBootFileSector ¬ GetBootFileAddress[volumeDesc, pilotBootFile];      volumeDesc.sectorNine.pilotMicrocode ¬ pilotMicrocodeSector;      volumeDesc.sectorNine.diagnosticMicrocode ¬         diagnosticMicrocodeSector;      volumeDesc.sectorNine.germ ¬ germSector;      volumeDesc.sectorNine.pilotBootFile ¬ pilotBootFileSector;      VolumeChanging[volumeDesc];      WriteSectorNine[volumeDesc];      VolumeStable[volumeDesc];      EXITS      diskChanged => RETURN WITH ERROR Error[volumeNotOpen];      needsScavenging => RETURN WITH ERROR Error[needsScavenging];      END;   []¬ValidateHandle[volume];   SetBootFilesInternal[volumeTable[volume.deviceIndex]];   END;SetBootFilesAlternateUCode: PUBLIC PROCEDURE [  volume: VolumeHandle, alternateUCode: Floppy.BootFilePointer] =   BEGIN   SetBootFilesAlternateInternal: ENTRY PROCEDURE [volumeDesc: VolumeDesc] =     BEGIN     ENABLE BEGIN       DiskChanged => {CloseVolume[volumeDesc]; GO TO diskChanged};       IOError => {CloseVolume[volumeDesc]; GO TO needsScavenging};       UNWIND => NULL;       END;      IF ~volumeDesc.open THEN RETURN WITH ERROR Error[volumeNotOpen];      IF volumeDesc.writeProtected THEN RETURN WITH ERROR Error[writeInhibited];      volumeDesc.sectorNine.alternateMicrocode ¬        GetBootFileAddress[volumeDesc, alternateUCode];      VolumeChanging[volumeDesc];      WriteSectorNine[volumeDesc];      VolumeStable[volumeDesc];      EXITS      diskChanged => RETURN WITH ERROR Error[volumeNotOpen];      needsScavenging => RETURN WITH ERROR Error[needsScavenging];      END;   [] ¬ ValidateHandle[volume];   SetBootFilesAlternateInternal[volumeTable[volume.deviceIndex]];   END;SetRootFile: PUBLIC PROCEDURE [file: Floppy.FileHandle] =   BEGIN   SetRootFileInternal: ENTRY PROCEDURE [volumeDesc: VolumeDesc] =      BEGIN      ENABLE         BEGIN	 DiskChanged => {CloseVolume[volumeDesc]; GO TO diskChanged};	 IOError => {CloseVolume[volumeDesc]; GO TO needsScavenging}	 END;      IF ~volumeDesc.open THEN RETURN WITH ERROR Error[volumeNotOpen];      IF volumeDesc.writeProtected THEN RETURN WITH ERROR Error[writeInhibited];      volumeDesc.sectorNine.rootFile ¬ file.file;      WriteSectorNine[volumeDesc];      EXITS      diskChanged => RETURN WITH ERROR Error[volumeNotOpen];      needsScavenging => RETURN WITH ERROR Error[needsScavenging];      END;   volume: VolumeHandle = file.volume;   []¬ValidateHandle[volume];   SetRootFileInternal[volumeTable[volume.deviceIndex]];   END;Write: PUBLIC PROCEDURE [   file: Floppy.FileHandle, first: Floppy.PageNumber, count: Floppy.PageCount,   vm: LONG POINTER] =   BEGIN   done: Floppy.PageCount;   WriteInternal: ENTRY PROCEDURE [volumeDesc: VolumeDesc] =      BEGIN      ENABLE         BEGIN         DiskChanged => {CloseVolume[volumeDesc]; GO TO diskChanged};         IOError => {done ¬ countDone; GO TO dataError;};	 UNWIND => NULL;	 END;      address: FloppyFormat.Sector;      size: FloppyFormat.ImplementedFileSize;      localFirst: FloppyFormat.ImplementedFileSize;            -- This procedure ASSUMES contiguous allocation of files on the diskette            IF ~volumeDesc.open THEN RETURN WITH ERROR Error[volumeNotOpen];      IF volumeDesc.writeProtected THEN RETURN WITH ERROR Error[writeInhibited];      [address: address, size: size] ¬ FindFile[volumeDesc, file.file];      IF address = FloppyFormat.nullSector        THEN RETURN WITH ERROR Error[fileNotFound];      IF first >= size OR first+count > size        THEN RETURN WITH ERROR Error[endOfFile];      localFirst ¬ FloppyFormat.ConvertPageNumber[first];      WriteFloppy[        volumeDesc, vm, address+localFirst, FloppyFormat.ConvertPageCount[count]];      EXITS      dataError => RETURN WITH ERROR DataError [file, first+done, NIL];      diskChanged => RETURN WITH ERROR Error[volumeNotOpen];      END;   volume: VolumeHandle = file.volume;   []¬ValidateHandle[volume];   WriteInternal[volumeTable[volume.deviceIndex]];   END;ValidateHandle: PUBLIC PROCEDURE [volume: VolumeHandle]  RETURNS[volumeDesc: VolumeDesc]=   BEGIN   CheckChangeCount: ENTRY PROCEDURE [volumeDesc: VolumeDesc] =      BEGIN       status: FloppyChannel.Status;      IF volume.changeCount ~= volumeDesc.changeCount        THEN RETURN WITH ERROR Error[invalidVolumeHandle];      [status] ¬ FloppyChannel.Nop[volumeDesc.handle        ! FloppyChannel.Error => {CloseVolume[volumeDesc]; GO TO diskChanged}];      IF status = diskChange THEN        {CloseVolume[volumeDesc]; RETURN WITH ERROR Error[invalidVolumeHandle]};      EXITS      diskChanged => RETURN WITH ERROR Error[invalidVolumeHandle];      END;   IF ~ValidDrive[volume.deviceIndex] THEN ERROR Error[invalidVolumeHandle];   CheckChangeCount[volumeDesc ¬ volumeTable[volume.deviceIndex]];   END;END.LOG28-Mar-83 17:14:44	EKN   	Update to Klamath6-Jun-83 14:40:14	EKN           Fix Klamath conversion bug of usage of Space.MapAt in procedure Open.15-Jun-83 10:07:31	EKN     	Assume that the spaces are unmapped in Open, so the test for mapped spaces deleted.6-Jul-83 23:57:39	RXJ       	No default on Window.count.26-Sep-83 14:33:49	AWL        	DeleteFile only needs a 4 page buffer.10-Nov-83 12:27:00	AWL        	Trim log to Klamath.  Create*: back out of overflowing the file list mroe gracefully.13-Nov-84 15:44:50	CAJ   	Move Scavenge to FloppyImplPublicD. 4-Feb-85 12:10:01	EKN   & EN        Convert over to new FloppyChannel. Added FloppyExtrasExtras.GetDrive.24-Sep-85 14:37:07      ET & JP        Added JP's change to GetAttributes to not run off end of allocation map when determining free pages and largest block. (AR 8092).	Fixed AR 7787. Change in CreateFileInternal to reverse VolumeChanging call and check for maxEntries in CreateInternal, so scavenging is not required, if client tries writing more files than maxEntries.18-Mar-86 12:46:32	CAJ   	Correct double Unmap in catch phrases with UNWINDs; improve readability.31-Jan-87 10:42:09	CAJ   	Added Get/SetBootFilesAlternateUCode.
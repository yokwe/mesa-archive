-- Copyright (C) 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- File: SimpleTTY edit by-- FXH    	 8-Jan-82 16:08:03  -- LXR    	 9-Dec-82 10:56:11  -- RXJ     	 6-Apr-83  8:21:00-- CJS		18-Feb-87 12:46:53 MDS relieved, used systemMDSZone for BBTableSpace.  DIRECTORY  BitBlt USING [AlignedBBTable, BBptr, BBTableSpace, BITBLT],  Environment USING [BitAddress, Block, Byte],  Heap,  Inline USING [BITAND],  Process USING [Detach, EnableAborts, SetPriority],  ProcessPriorities USING [priorityIOHigh],  Runtime USING [GetTableBase, Interrupt],  SpecialSpace USING [    MakeGlobalFrameResident, MakeProcedureResident, SpecialError],  Stream USING [    defaultObject, GetProcedure, Handle, Object, PutProcedure,    SendAttentionProcedure, SetSSTProcedure, WaitAttentionProcedure],  TTY,  TTYConstants USING [aborted, blinkDisplay, normal, notAborted, removeChars],  UserTerminal USING [    BlinkDisplay, Coordinate, GetBitBltTable, keyboard, mouse, screenHeight,    screenWidth, SetCursorPosition, SetMousePosition, SetState, SetBackground,    WaitForScanLine];SimpleTTY: MONITOR  LOCKS m USING m: LONG POINTER TO MONITORLOCK  IMPORTS    BitBlt, Heap, Inline, Process, Runtime, SpecialSpace,    Stream, TTY, UserTerminal  EXPORTS TTY =BEGIN OPEN BitBlt;screenLock:   MONITORLOCK;keyboardLock: MONITORLOCK;-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Common Definitions-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~CHAR: TYPE = CHARACTER;ControlA: CHARACTER = 'A - 100B;BS:       CHARACTER = 10C;TAB:      CHARACTER = 11C;FF:       CHARACTER = 14C;CR:       CHARACTER = 15C;ControlG: CHARACTER = 'G - 100B;ControlR: CHARACTER = 'R - 100B;ControlQ: CHARACTER = 'Q - 100B;ControlV: CHARACTER = 'V - 100B;ControlW: CHARACTER = 'W - 100B;ControlX: CHARACTER = 'X - 100B;ESC:      CHARACTER = 33C;SP:       CHARACTER = ' ;DEL:      CHARACTER = 177C;-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- FONT Definitions and variables-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~font: LONG POINTER TO MACHINE DEPENDENT RECORD [  newStyle(0:0..0): BOOLEAN,  indexed(0:1..1):  BOOLEAN,  fixed(0:2..2):    BOOLEAN,  kerned(0:3..3):   BOOLEAN,  pad(0:4..15):     [0..7777B],  min(1):           CHARACTER,   -- limits of chars in font  max(2):           CHARACTER,   -- limits of chars in font  maxwidth(3):      CARDINAL,  length(4):        CARDINAL,  ascent(5):        CARDINAL,  descent(6):       CARDINAL,  xoffset(7):       CARDINAL,  raster(8):        CARDINAL,  chars(9:0..63):  SELECT OVERLAID * FROM    hasBoundingBox => [      boundingBox(9:0..63): RECORD [        FontBBox, FontBBoy, FontBBdx, FontBBDy: INTEGER],      BBBitmap(13):         ARRAY [0..0) OF WORD],    noBoundingBox => [      bitmap(9):            ARRAY [0..0) OF WORD],    ENDCASE] = GetFont[];bitmap: LONG POINTER = IF font.kerned THEN @font.BBBitmap ELSE @font.bitmap;xInSegment: LONG POINTER TO ARRAY CHARACTER [0C..0C) OF CARDINAL =  bitmap + font.raster*FontHeight[] - (font.min-0C);height: INTEGER[0..LAST[INTEGER]] = FontHeight[];CharWidth: PROC [char: CHARACTER] RETURNS [[0..LAST[INTEGER]]] = INLINE {  IF char ~IN [font.min..font.max] THEN char ¬ font.max+1;  RETURN[xInSegment[char+1] - xInSegment[char]]};  FontHeight: PROC RETURNS [[0..LAST[INTEGER]]] = INLINE {  RETURN[font.ascent+font.descent]};  -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Keyboard Definitions and Constants-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~downUp:   TYPE = {down, up};keycount: CARDINAL = 112;Keyarray: TYPE = PACKED ARRAY [0..keycount) OF downUp;KeyItem: TYPE = RECORD [  Letter: BOOLEAN, ShiftCode: CHAR [0C..177C], NormalCode: CHAR [0C..377C]];-- Keyboard Infoctrl:       CARDINAL =  52;leftShift:  CARDINAL =  57;shiftLock:  CARDINAL =  72;rightShift: CARDINAL =  76;stop:       CARDINAL =  77;-- JLevel-IV infojShift1:    CARDINAL =  47;jShift2:    CARDINAL = 111;jExtraSP:   CARDINAL = 110;NormalKeyCount: TYPE = [16..77];KeyTable: ARRAY NormalKeyCount OF KeyItem = [  -- 	Index [ 0..15] mouse, etc  -- 	Index [16..31]  [FALSE,  45C,  65C],  -- %,5  [FALSE,  44C,  64C],  -- $,4  [FALSE, 176C,  66C],  -- ~,6  [TRUE,  105C, 145C],  -- E  [FALSE,  46C,  67C],  -- &,7  [TRUE,  104C, 144C],  -- D  [TRUE,  125C, 165C],  -- U  [TRUE,  126C, 166C],  -- V  [FALSE,  51C,  60C],  -- ),0  [TRUE,  113C, 153C],  -- K  [FALSE,  30C,  55C],  -- 30C,-  [TRUE,  120C, 160C],  -- P  [FALSE,  77C,  57C],  -- ?,/  [FALSE, 174C, 134C],  -- |,\  [FALSE,  12C,  12C],  -- LF  [FALSE,  27C,  10C],  -- BW, BS  -- 	Index [32..47]  [FALSE,  43C,  63C],  -- #,3  [FALSE, 100C,  62C],  -- @,2  [TRUE,  127C, 167C],  -- W  [TRUE,  121C, 161C],  -- Q  [TRUE,  123C, 163C],  -- S  [TRUE,  101C, 141C],  -- A  [FALSE,  50C,  71C],  -- (,9  [TRUE,  111C, 151C],  -- I  [TRUE,  130C, 170C],  -- X  [TRUE,  117C, 157C],  -- O  [TRUE,  114C, 154C],  -- L  [FALSE,  74C,  54C],  -- <,,  [FALSE,  42C,  47C],  -- ",'  [FALSE, 175C, 135C],  -- },]  [FALSE,   0C,   0C],  -- SPARE2  [FALSE,   0C,   0C],  -- SPARE1 (jShift1)  -- 	Index [48..63]  [FALSE,  41C,  61C],  -- !,1  [FALSE,  33C,  33C],  -- ESCAPE  [FALSE,  11C,  11C],  -- TAB  [TRUE,  106C, 146C],  -- F  [FALSE,    0C,  0C],  -- CONTROL  [TRUE,  103C, 143C],  -- C  [TRUE,  112C, 152C],  -- J  [TRUE,  102C, 142C],  -- B  [TRUE,  132C, 172C],  -- Z  [FALSE,    0C,  0C],  -- LEFT SHIFT  [FALSE,  76C,  56C],  -- >,.  [FALSE,  72C,  73C],  -- :,;  [FALSE,  15C,  15C],  -- CR  [FALSE, 136C, 137C],  -- ­,¬  [FALSE, 177C, 177C],  -- DEL  [FALSE,    0C,  0C],  -- NOT USED (FR5)  -- 	Index [64..79]  [TRUE,  122C, 162C],  -- R  [TRUE,  124C, 164C],  -- T  [TRUE,  107C, 147C],  -- G  [TRUE,  131C, 171C],  -- Y  [TRUE,  110C, 150C],  -- H  [FALSE,  52C,  70C],  -- *,8  [TRUE,  116C, 156C],  -- N  [TRUE,  115C, 155C],  -- M  [FALSE,   0C,   0C],  -- LOCK  [FALSE,  40C,  40C],  -- SPACE  [FALSE, 173C, 133C],  -- {,[  [FALSE,  53C,  75C],  -- +,=  [FALSE,   0C,   0C],  -- RIGHT SHIFT  [FALSE,   0C,   0C]]; -- SPARE3 (stop)--78  [FALSE,  0C,   0C],  ++ not user (FR4)--79  [FALSE,  0C,   0C],  ++ NOT USED (FR5)--110 [FALSE, 40C,  40C],  ++ jExtraSP--111 [FALSE,  0C,   0C],  ++ jShift2-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Simple TTY Procedures-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~useCount:       CARDINAL ¬ 0;simpleStream:   Stream.Object ¬ Stream.defaultObject;mode: Environment.Byte ¬ TTYConstants.normal;modeVal: CARDINAL ¬ 0;inputBlock: LONG POINTER TO Environment.Block ¬ NIL;charCount: CARDINAL ¬ 0; CreateTTYInstance: PUBLIC PROCEDURE [name: LONG STRING, backingStream: Stream.Handle, tty: TTY.Handle]    RETURNS [ttyImpl: Stream.Handle, backing: Stream.Handle] = {  CreateEntry: ENTRY PROC [m: LONG POINTER TO MONITORLOCK] RETURNS [CARDINAL]=    INLINE {RETURN[useCount ¬ useCount+1]};  IF CreateEntry[@keyboardLock]#1 THEN ERROR TTY.OutOfInstances;  RETURN[@simpleStream, NIL]};Delete: PROCEDURE [stream: Stream.Handle] = {  DestroyEntry: ENTRY PROC [m: LONG POINTER TO MONITORLOCK] =    INLINE {useCount ¬ useCount-1};  DestroyEntry[@keyboardLock]};   GetBlock: Stream.GetProcedure = {   c: CHAR = GetChar[];   sst ¬ TTYConstants.normal;   why ¬ normal;   bytesTransferred ¬ 1;   block.blockPointer[block.startIndex] ¬ LOOPHOLE[c]};  PutBlock: Stream.PutProcedure = {   SELECT mode FROM      TTYConstants.normal =>         FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO           PutChar[LOOPHOLE[block.blockPointer[i]]] ENDLOOP;      TTYConstants.removeChars =>        BEGIN	FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO	  modeVal ¬ modeVal*256 + block.blockPointer[i];	  ENDLOOP;	END;      ENDCASE};  WaitAttention: Stream.WaitAttentionProcedure = {    DoIt: ENTRY PROCEDURE [m: LONG POINTER TO MONITORLOCK]       RETURNS [Environment.Byte] =  INLINE {       RETURN[IF stopTyped THEN TTYConstants.aborted               ELSE TTYConstants.notAborted]};    RETURN[DoIt[@keyboardLock]]};  SendAttention: Stream.SendAttentionProcedure = {   DoIt: ENTRY PROCEDURE [m: LONG POINTER TO MONITORLOCK] =  INLINE {     SELECT byte FROM       TTYConstants.aborted => stopTyped ¬ TRUE;       TTYConstants.notAborted =>stopTyped ¬ FALSE;       ENDCASE};   DoIt[@keyboardLock]};  SetSST: Stream.SetSSTProcedure =  {    SELECT mode FROM     TTYConstants.removeChars =>         FOR i: CARDINAL IN [0..modeVal) DO          PutChar[BS]; PutChar[SP]; PutChar[BS]; ENDLOOP;     TTYConstants.blinkDisplay => UserTerminal.BlinkDisplay[];     ENDCASE;    mode ¬ sst;    modeVal ¬ 0};    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Keyboard Implementation-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~stopTyped:           BOOLEAN ¬ FALSE;charactersAvailable: CONDITION;-- EXTERNAL PROCEDURESCtrlChar: PROC [c: CHAR] RETURNS [CHAR] = INLINE {  RETURN[LOOPHOLE[Inline.BITAND[c, 37B]]]};-- ENTRY PROCEDURESProcessKeyboard: PROC =  BEGIN  old, new:       Keyarray;  kp:             LONG POINTER TO Keyarray = LOOPHOLE[UserTerminal.keyboard];  blinkCount:     CARDINAL ¬ 33;  interruptState: downUp   ¬ up;  Process.SetPriority[ProcessPriorities.priorityIOHigh];    -- allows interpret calls from the debugger (using priorityPageFaultIO    -- instead would cause a state vector deadlock if an interpret call    -- took a page fault).  old ¬ kp­;  DO    charsSeen: BOOLEAN ¬ FALSE;    Brdcst:    ENTRY PROC [m: LONG POINTER TO MONITORLOCK] = INLINE {      BROADCAST charactersAvailable};    XmitChar:  PROC [c: CHARACTER] = {      StuffBuffer[c, @keyboardLock]; charsSeen ¬ TRUE};    UserTerminal.WaitForScanLine[0];    new ¬ kp­;    IF new[stop]=down AND (new[rightShift]=down OR new[leftShift]=down) THEN {      IF interruptState=up THEN Runtime.Interrupt[];      interruptState ¬ down; LOOP};    interruptState ¬ up;    TrackCursor[];    IF (blinkCount¬blinkCount-1) = 0 THEN {BlinkCursor[]; blinkCount ¬ 34};    FOR j: CARDINAL IN NormalKeyCount DO      char: CHAR; entry: KeyItem;      IF new[j]=up OR old[j]=down THEN LOOP;      IF j=stop THEN {stopTyped ¬ TRUE; LOOP};      IF (char ¬ (entry ¬ KeyTable[j]).NormalCode)=0C THEN LOOP;      IF new[leftShift] =down OR new[rightShift]=down	 OR new[jShift1]=down OR new[jShift2]   =down         OR (new[shiftLock]=down AND entry.Letter) THEN        char ¬ entry.ShiftCode;      IF new[ctrl]=down THEN        SELECT char FROM          IN ['@..'¬], -- includes '@, 'A..'Z, '[, '\, '], '­	  IN ['a..'}]  -- includes     'a..'z, '{, '|, '}	    => char ¬ CtrlChar[char];	  ENDCASE => LOOP;      XmitChar[char];      ENDLOOP;    IF new[jExtraSP]=down AND old[jExtraSP]=up THEN XmitChar[SP];    IF charsSeen THEN Brdcst[@keyboardLock];    old ¬ new;    ENDLOOP  END;TrackCursor:  PROC = INLINE {  mouse: UserTerminal.Coordinate ¬ UserTerminal.mouse­;  mouse.x ¬ MIN[MAX[0, mouse.x], UserTerminal.screenWidth];  mouse.y ¬ MIN[MAX[0, mouse.y], UserTerminal.screenHeight];  UserTerminal.SetCursorPosition[mouse];  UserTerminal.SetMousePosition[mouse]};-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- Keyboard RingBuffer-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~in, out: CARDINAL ¬ 0;buffer:  PACKED ARRAY [0..50) OF CHAR;GetChar: PROC RETURNS [c: CHAR] = {  P: ENTRY PROC [m: LONG POINTER TO MONITORLOCK] = INLINE {    ENABLE UNWIND => NULL;    WHILE in=out DO WAIT charactersAvailable ENDLOOP;    c ¬ buffer[out];    IF (out¬out+1) = LENGTH[buffer] THEN out ¬ 0};  P[@keyboardLock]};StuffBuffer: ENTRY PROC [c: CHAR, m: LONG POINTER TO MONITORLOCK] = INLINE {  newin: CARDINAL;  IF (newin¬in+1) = LENGTH[buffer] THEN newin ¬ 0;  IF newin#out THEN {buffer[in] ¬ c; in ¬ newin}};-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- DISPLAY-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~unAlignBBTptr: POINTER TO BBTableSpace;bbPtr:   BitBlt.BBptr;charPos, line, nCharPos, nLines: CARDINAL;firstLine, thisLine: Environment.BitAddress;bitsPerTextLine: CARDINAL;  -- = screenWidth*font.heightdoBlink: BOOLEAN ¬ FALSE;-- EXTERNAL DISPLAY PROCEDURESGetBitAddress: PROC [p: LONG POINTER, o: CARDINAL] RETURNS [  Environment.BitAddress] = {RETURN[[p+o/16, 0, o MOD 16]]};-- ENTRY DISPLAY PROCEDURESBlinkCursor: PROC = INLINE {  BlinkCursorEntry: ENTRY PROC [m: LONG POINTER TO MONITORLOCK] = {    blinker: CARDINAL ¬ 60000B;    IF doBlink THEN {      bbPtr.src ¬ [@blinker, 0, 0];      bbPtr.srcDesc ¬ [gray[[0, 0, 0, 0]]];      bbPtr.flags ¬ [gray: TRUE, dstFunc: xor];      BITBLT[bbPtr];      bbPtr.srcDesc ¬ [srcBpl[font.raster*16]];      bbPtr.flags ¬ []}};  IF doBlink THEN BlinkCursorEntry[@screenLock]};ClearScreenEntry: ENTRY PROC [m: LONG POINTER TO MONITORLOCK] = INLINE {ClearScreen[]};PutChar: PROC [c: CHARACTER] = {  PutCharEntry: ENTRY PROC [m: LONG POINTER TO MONITORLOCK] =    INLINE {doBlink ¬ FALSE; ClearThisChar[]; DisplayChar[c]; doBlink ¬ TRUE};  PutCharEntry[@screenLock]};-- INTERNAL DISPLAY PROCEDURESBackup: INTERNAL PROC = {  t: CARDINAL = bbPtr.dst.bit+16-font.maxwidth;  IF charPos=0 THEN RETURN;  charPos ¬ charPos - 1;  bbPtr.dst.word ¬ bbPtr.dst.word + t/16 - 1;  bbPtr.dst.bit ¬ t MOD 16};ClearScreen: INTERNAL PROC = {  zero: CARDINAL ¬ 0;  bbPtr­ ¬ UserTerminal.GetBitBltTable[];  bitsPerTextLine ¬ bbPtr.dstBpl*height;  firstLine ¬ thisLine ¬ GetBitAddress[    bbPtr.dst.word, bbPtr.dst.bit+8+8*bbPtr.dstBpl];  charPos ¬ 0; line ¬ 1;  nCharPos ¬ (bbPtr.width-16)/font.maxwidth;  nLines ¬ (bbPtr.height-16)/height;  bbPtr.src ¬ [@zero, 0, 0];  bbPtr.srcDesc ¬ [gray[[0, 0, 0, 0]]];  bbPtr.flags ¬ [gray: TRUE];  BITBLT[bbPtr];  -- set up standard arguments for character painting  bbPtr.dst ¬ firstLine;  --bbPtr.dstBpl set  --bbPtr.src set when proc called  bbPtr.srcDesc ¬ [srcBpl[font.raster*16]];  bbPtr.height ¬ height;  bbPtr.width ¬ font.maxwidth;  bbPtr.flags ¬ []};ClearThisChar: INTERNAL PROC = {  zero: CARDINAL ¬ 0;  bbPtr.src ¬ [@zero, 0, 0];  bbPtr.srcDesc ¬ [gray[[0, 0, 0, 0]]];  bbPtr.flags ¬ [gray: TRUE];  BITBLT[bbPtr];  bbPtr.srcDesc ¬ [srcBpl[font.raster*16]];  bbPtr.flags ¬ []};DisplayChar: INTERNAL PROC [c: CHARACTER] = {  SELECT c FROM    IN (SP..'~] => {      IF c ~IN [font.min..font.max] THEN c ¬ font.max+1;      bbPtr.src ¬ GetBitAddress[bitmap, xInSegment[c]];      BitBlt.BITBLT[bbPtr]};    SP =>  NULL;    CR =>  {Newline[]; RETURN};    BS =>  {Backup[]; RETURN};    TAB => {UNTIL (charPos MOD 8)=0 DO DisplayChar[SP] ENDLOOP; RETURN};    FF =>  {ClearScreen[]; RETURN};    IN [0C..SP) => {DisplayChar['­]; DisplayChar[c+('A-1C)]; RETURN};    ENDCASE => RETURN;  IF (charPos ¬ charPos+1) >= nCharPos THEN Newline[]  ELSE bbPtr.dst ¬ GetBitAddress[bbPtr.dst.word, bbPtr.dst.bit+font.maxwidth]};        Newline: INTERNAL PROC = {  IF line<nLines THEN {    thisLine ¬ GetBitAddress[thisLine.word, thisLine.bit+bitsPerTextLine];    line ¬ line+1}  ELSE {    zero: CARDINAL ¬ 0;    sBBTable: BBTableSpace;    sbbPtr: BBptr = AlignedBBTable[@sBBTable];    sbbPtr­ ¬ [      dst: firstLine, dstBpl: bbPtr.dstBpl,      src: GetBitAddress[firstLine.word, firstLine.bit+bitsPerTextLine],      srcDesc: [srcBpl[bbPtr.dstBpl]], flags: [direction: forward],      width: nCharPos*font.maxwidth, height: height*(nLines-1)];    BITBLT[sbbPtr];    sbbPtr­ ¬ [      dst: thisLine, src: [@zero, 0, 0],      dstBpl: bbPtr.dstBpl, srcDesc: [gray[[0, 0, 0, 0]]],      width: nCharPos*font.maxwidth, height: height,      flags: [gray: TRUE]];    BITBLT[sbbPtr]};  bbPtr.dst ¬ thisLine;  charPos ¬ 0};GetFont: PROC RETURNS [LONG POINTER] = {  Gacha12Strike: ARRAY [0..1470B) OF WORD = [    --   0-- 120000B,     0B,   176B,    10B,  1464B,    13B,     3B,     0B,    --  10--     61B,     0B,     0B,     0B, 10000B,     0B,  2040B,     0B,    --  20--      0B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --  30--      0B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --  40--      0B,     0B,     0B,     0B,     0B,     0B,     0B,    74B,    --  50--     74B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --  60--      0B,     0B,     0B,     0B,     0B,     0B,     0B,  7010B,    --  70--  70000B,     0B,     0B,    10B, 22012B, 34144B, 14010B,  4020B,    -- 100--   4000B,     0B,     2B, 36010B, 36074B,  6076B, 36176B, 36074B,    -- 110--      0B,  2000B, 20074B, 14020B, 74034B, 74176B, 77034B, 41076B,    -- 120--  17102B, 40306B, 41074B, 76074B, 76074B, 77502B, 40501B, 41101B,    -- 130--  77040B, 20004B,     0B,   100B,     2B,    14B,   100B,  4004B,    -- 140--  40070B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    -- 150--  10010B,  4000B,     0B,     0B,    10B, 22012B, 52244B, 22010B,    -- 160--  10010B, 25000B,     0B,     2B, 41030B, 41102B,  6040B, 41002B,    -- 170--  41102B,     0B,  4000B, 10102B, 22020B, 42042B, 42100B, 40042B,    -- 200--  41010B,  1104B, 40306B, 61102B, 41102B, 41102B,  4102B, 40511B,    -- 210--  41101B,  1040B, 20004B,     0B,   100B,     2B,    22B,   100B,    -- 220--   4004B, 40010B,     0B,     0B,     0B,    20B,     0B,     0B,    -- 230--      0B, 10010B,  4000B,     0B,     0B,    10B, 22024B, 52250B,    -- 240--  22010B, 10010B, 16010B,     0B,     4B, 41050B, 41102B, 12040B,    -- 250--  40002B, 41102B,     0B, 10000B,  4102B, 41050B, 42102B, 41100B,    -- 260--  40102B, 41010B,  1110B, 40252B, 61102B, 41102B, 41102B,  4102B,    -- 270--  21111B, 22042B,  2040B, 10004B,  4000B,   100B,     2B,    20B,    -- 300--    100B,     0B, 40010B,     0B,     0B,     0B,    20B,     0B,    -- 310--      0B,     0B, 10010B,  4000B, 74000B,     0B,    10B, 22076B,    -- 320--  50310B, 14010B, 20004B, 25010B,     0B,     4B, 43010B,  1002B,    -- 330--  12174B, 76004B, 41102B,  4010B, 20000B,  2002B, 47050B, 42100B,    -- 340--  41100B, 40100B, 41010B,  1120B, 40252B, 51102B, 41102B, 41040B,    -- 350--   4102B, 21111B, 22042B,  4040B, 10004B, 16020B, 34134B, 36072B,    -- 360--  36174B, 35134B, 34074B, 42010B,167134B, 36134B, 35054B, 36174B,    -- 370--  41102B,101104B, 41174B, 10010B,  4062B, 74000B,     0B,    10B,    -- 400--     24B, 34010B, 10000B, 20004B,  4010B,   176B,    10B, 45010B,    -- 410--   2034B, 22102B, 41004B, 36102B,  4010B, 40176B,  1004B, 51104B,    -- 420--  76100B, 41174B, 76100B, 77010B,  1160B, 40252B, 51102B, 41102B,    -- 430--  76030B,  4102B, 21052B, 14024B,  4040B,  4004B, 25040B, 42142B,    -- 440--  41106B, 41020B, 43142B,  4004B, 44010B,111142B, 41142B, 43062B,    -- 450--  41020B, 41102B,101104B, 41004B, 10010B,  4132B, 74000B,     0B,    -- 460--     10B,    50B, 12020B, 24400B, 20004B,   177B,     0B,    10B,    -- 470--  51010B,  4002B, 22002B, 41010B, 41102B,     0B, 40000B,  1010B,    -- 500--  51104B, 41100B, 41100B, 40116B, 41010B,  1110B, 40222B, 45102B,    -- 510--  76102B, 44004B,  4102B, 12052B, 14024B, 10040B,  4004B,  4177B,    -- 520--   2102B, 40102B, 41020B, 41102B,  4004B, 50010B,111102B, 41102B,    -- 530--  41040B, 40020B, 41044B,111050B, 21010B, 60010B,  3114B, 74000B,    -- 540--  35400B,    10B,   174B, 12023B, 45000B, 20004B,    10B,     0B,    -- 550--     20B, 61010B, 10002B, 42002B, 41010B, 41076B,     0B, 20176B,    -- 560--   2010B, 46104B, 41100B, 41100B, 40102B, 41010B,  1104B, 40222B,    -- 570--  45102B, 40102B, 42002B,  4102B, 12052B, 22010B, 20040B,  2004B,    -- 600--   4040B, 36102B, 40102B, 77020B, 41102B,  4004B, 70010B,111102B,    -- 610--  41102B, 41040B, 36020B, 41044B,111020B, 22020B, 10010B,  4000B,    -- 620--  74000B,     0B,     0B,    50B, 52025B, 42000B, 20004B,    10B,    -- 630--      0B,    20B, 41010B, 20102B, 77102B, 41020B, 41002B,     0B,    -- 640--  10000B,  4000B, 40376B, 41102B, 41100B, 40102B, 41010B, 41104B,    -- 650--  40222B, 43102B, 40102B, 42102B,  4102B, 12024B, 22010B, 20040B,    -- 660--   2004B,  4020B, 42102B, 40102B, 40020B, 41102B,  4004B, 44010B,    -- 670-- 111102B, 41102B, 41040B,  1020B, 41044B,111050B, 12040B, 10010B,    -- 700--   4000B, 74000B,     0B,    10B,   120B, 52045B, 42000B, 10010B,    -- 710--     10B, 14000B,  4040B, 41010B, 40102B,  2102B, 41020B, 41102B,    -- 720--   4030B,  4000B, 10010B, 21202B, 41042B, 42100B, 40046B, 41010B,    -- 730--  41102B, 40202B, 43102B, 40102B, 41102B,  4102B,  4024B, 41010B,    -- 740--  40040B,  1004B,  4000B, 42142B, 41106B, 41020B, 43102B,  4004B,    -- 750--  42010B,111102B, 41142B, 43040B, 41022B, 43030B,111104B, 14100B,    -- 760--  10010B,  4000B, 74000B,     0B,    10B,   120B, 34046B, 35400B,    -- 770--  10010B,     0B,  4000B,  4040B, 36076B, 77074B,  2074B, 36020B,    --1000--  36074B,  4010B,  2000B, 20010B, 16202B, 76034B, 74176B, 40032B,    --1010--  41076B, 36102B, 77202B, 41074B, 40074B, 41074B,  4074B,  4024B,    --1020--  41010B, 77040B,  1004B,     0B, 35134B, 36072B, 36020B, 35102B,    --1030--   4004B, 41010B,111102B, 36134B, 35040B, 36014B, 35030B, 66104B,    --1040--   4176B, 10010B,  4000B, 74000B,     0B,     0B,     0B, 10000B,    --1050--      0B,  4020B,     0B,  4000B,     0B,     0B,     0B,     0B,    --1060--      0B,     0B,    10B,     0B,     0B,     0B,     0B,     0B,    --1070--      0B,     0B,     0B,     0B,     0B,    20B,     0B,     0B,    --1100--      0B,     0B,    40B,     4B,     0B,     0B,     0B,     0B,    --1110--   1000B,     4B,     0B,     0B,   100B,  1000B,     0B,     0B,    --1120--      0B,  4000B, 10010B,  4000B, 74000B,     0B,     0B,     0B,    --1130--      0B,     0B,  2040B,     0B, 10000B,     0B,     0B,     0B,    --1140--      0B,     0B,     0B,    20B,     0B,     0B,     0B,     0B,    --1150--      0B,     0B,     0B,     0B,     0B,     0B,    16B,     0B,    --1160--      0B,     0B,     0B,    74B,    74B,     0B,     0B,     0B,    --1170--      0B, 41000B,   104B,     0B,     0B,   100B,  1000B,     0B,    --1200--      0B,     0B, 50000B,  7010B, 70000B, 74000B,   377B,     0B,    --1210--      0B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --1220--      0B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --1230--      0B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --1240--      0B,     0B,     0B,     0B,     0B,     0B,     0B,     0B,    --1250--      0B,     0B, 36000B,    70B,     0B,     0B,   100B,  1000B,    --1260--      0B,     0B,     0B, 20000B,     0B,     0B, 74000B,     0B,    --1270--     10B,    10B,    10B,    10B,    10B,    10B,    10B,    10B,    --1300--     10B,    10B,    10B,    10B,    10B,    10B,    10B,    10B,    --1310--     10B,    10B,    10B,    10B,    10B,    10B,    10B,    10B,    --1320--     20B,    20B,    20B,    20B,    20B,    20B,    20B,    20B,    --1330--     30B,    40B,    50B,    60B,    70B,   100B,   110B,   120B,    --1340--    130B,   140B,   150B,   160B,   170B,   200B,   210B,   220B,    --1350--    230B,   240B,   250B,   260B,   270B,   300B,   310B,   320B,    --1360--    330B,   340B,   350B,   360B,   370B,   400B,   410B,   420B,    --1370--    430B,   440B,   450B,   460B,   470B,   500B,   510B,   520B,    --1400--    530B,   540B,   550B,   560B,   570B,   600B,   610B,   620B,    --1410--    630B,   640B,   650B,   660B,   670B,   700B,   710B,   720B,    --1420--    730B,   740B,   750B,   760B,   770B,  1000B,  1010B,  1020B,    --1430--   1020B,  1030B,  1040B,  1050B,  1060B,  1070B,  1100B,  1110B,    --1440--   1120B,  1130B,  1140B,  1150B,  1160B,  1170B,  1200B,  1210B,    --1450--   1220B,  1230B,  1240B,  1250B,  1260B,  1270B,  1300B,  1310B,    --1460--   1320B,  1330B,  1340B,  1350B,  1360B,  1370B,  1400B,  1410B];  p: LONG POINTER TO ARRAY [0..1470B) OF WORD    ¬ Runtime.GetTableBase[LOOPHOLE[SimpleTTY]];  DO    IF p[0] = Gacha12Strike[0] AND p­ = Gacha12Strike THEN RETURN[p];    p ¬ p+1    ENDLOOP};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~  -- non-basic tty features  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- MAINLINE CODE ----~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~FontError: ERROR = CODE;IF ~font.newStyle OR font.indexed OR font.min ~IN [0C..177C]   OR font.max+1 ~IN [0C..177C] THEN ERROR FontError;  unAlignBBTptr ¬ Heap.systemMDSZone.NEW[BitBlt.BBTableSpace];bbPtr ¬ AlignedBBTable[unAlignBBTptr];  simpleStream.get ¬ GetBlock;simpleStream.put ¬ PutBlock;simpleStream.delete ¬ Delete;simpleStream.waitAttention ¬ WaitAttention;simpleStream.sendAttention ¬ SendAttention;simpleStream.setSST ¬ SetSST;Process.EnableAborts[@charactersAvailable];[] ¬ UserTerminal.SetState[on];[] ¬ UserTerminal.SetBackground[white];ClearScreenEntry[@screenLock];SpecialSpace.MakeProcedureResident[ProcessKeyboard  ! SpecialSpace.SpecialError =>    IF error = alreadyResident THEN CONTINUE    ELSE REJECT];SpecialSpace.MakeGlobalFrameResident[SimpleTTY  ! SpecialSpace.SpecialError =>    IF error = alreadyResident THEN CONTINUE    ELSE REJECT];Process.Detach[FORK ProcessKeyboard];END....
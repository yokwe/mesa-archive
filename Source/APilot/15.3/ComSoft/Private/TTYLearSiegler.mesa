-- Copyright (C) 1981, 1982, 1984  by Xerox Corporation. All rights reserved. -- File:  TTYLearSiegler.mesa-- Last Edited:  13-Nov-81 15:18:10   By:  CRF -- Last Edited:  27-Oct-82 12:02:02  By:  LXR     DIRECTORY  Ascii USING [BS, ControlG, CR, LF, SP],  Environment USING [Block],  Process USING [GetPriority, Priority, priorityForeground, SetPriority],  Stream USING [    Byte, defaultObject, DeleteProcedure, GetProcedure, Handle, Object,     PutByteProcedure, SendAttentionProcedure, SetSSTProcedure,     WaitAttentionProcedure],  TTY,  TTYConstants,  TTYPort USING [ChannelHandle, ChannelQuiesced, Create, Delete, Get, Quiesce, Put,    SetParameter, TransferStatus],  TTYPortEnvironment USING [LineSpeed];TTYLearSiegler: MONITOR  IMPORTS Process, Stream, TTY, TTYPort  EXPORTS TTY =BEGIN-- TypesByte: TYPE = Stream.Byte;CharObjectHandle: TYPE = LONG POINTER TO CharObject;CharObject:       TYPE = RECORD [p: CharObjectHandle, c: CHARACTER];ControlG: Byte = LOOPHOLE[Ascii.ControlG];CR: Byte = LOOPHOLE[Ascii.CR];LF: Byte = LOOPHOLE[Ascii.LF];BS: Byte = LOOPHOLE[Ascii.BS];SP: Byte = LOOPHOLE[Ascii.SP];-- this might be expanded to multiple tty's by having several of thes buggers-- and refering to them (somehow) via handle, and having object monitors.myTTY: RECORD [  so: Stream.Object ¬ Stream.defaultObject,  breakDetected:  BOOLEAN ¬ NULL,  breakCount:     INTEGER ¬ NULL,  channel:        TTYPort.ChannelHandle ¬ NIL,  -- also on/off flag  mode: 	  Byte ¬  TTYConstants.normal,  modeVal:        CARDINAL ¬ 0];receiveDeath: CONDITION;controlStop:  CHARACTER = 36C;CreateTTYInstance: PUBLIC ENTRY PROC [  name: LONG STRING, backingStream: Stream.Handle, tty: TTY.Handle]   RETURNS [ttyImpl, backing: Stream.Handle] = {  ENABLE UNWIND => NULL;  IF myTTY.channel # NIL THEN RETURN WITH ERROR TTY.OutOfInstances;  myTTY.channel ¬ TTYPort.Create[0];  myTTY.breakDetected ¬ FALSE; myTTY.breakCount ¬ 0;  TTYPort.SetParameter[myTTY.channel, [dataSetReady[TRUE]]];  TTYPort.SetParameter[myTTY.channel, [clearToSend[TRUE]]];  TTYPort.SetParameter[myTTY.channel, [lineSpeed[bps9600]]];  myTTY.so.get ¬ GetBlock;  myTTY.so.putByte ¬ PutByte;  myTTY.so.delete ¬ Delete;  myTTY.so.waitAttention ¬ WaitAttention;  myTTY.so.sendAttention ¬ SendAttention;  myTTY.so.setSST ¬ SetSST;  RETURN[@myTTY.so, NIL]};Delete: ENTRY Stream.DeleteProcedure = {  channel: TTYPort.ChannelHandle = myTTY.channel;  IF channel=NIL THEN RETURN;  TTYPort.Quiesce[channel];  WHILE myTTY.channel#NIL DO WAIT receiveDeath [] ENDLOOP;  TTYPort.Delete[myTTY.channel]};PutByte: ENTRY Stream.PutByteProcedure = {   SELECT myTTY.mode FROM      TTYConstants.normal => PutByteInternal[byte];      TTYConstants.removeChars => myTTY.modeVal ¬ myTTY.modeVal*256 + byte;      ENDCASE};PutByteInternal: INTERNAL PROC [c: Byte] = {  PutIt: PROCEDURE [c: Stream.Byte] = INLINE {    [] ¬ TTYPort.Put[myTTY.channel, LOOPHOLE[c] !       TTYPort.ChannelQuiesced => CONTINUE]};  IF myTTY.channel = NIL THEN RETURN;  PutIt[c];  SELECT c FROM    CR => PutIt[LF];    BS => {PutIt[SP]; PutIt[BS]};    ENDCASE};WaitAttention: Stream.WaitAttentionProcedure = {  RETURN[IF myTTY.breakDetected THEN TTYConstants.aborted          ELSE TTYConstants.notAborted]};SendAttention: Stream.SendAttentionProcedure = {    SELECT byte FROM       TTYConstants.aborted => {         myTTY.breakCount ¬ myTTY.breakCount + 1;         IF myTTY.breakCount > 0 THEN myTTY.breakDetected ¬ TRUE};       TTYConstants.notAborted => {         IF myTTY.breakCount > 0 THEN myTTY.breakCount ¬ myTTY.breakCount - 1;         IF myTTY.breakCount = 0 THEN myTTY.breakDetected ¬ FALSE};       ENDCASE};SetSST: ENTRY Stream.SetSSTProcedure =  {    SELECT myTTY.mode FROM       TTYConstants.removeChars =>           FOR i: CARDINAL IN [0..myTTY.modeVal) DO            PutByteInternal[BS]; ENDLOOP;	TTYConstants.blinkDisplay => PutByteInternal[ControlG];	ENDCASE;    myTTY.mode ¬ sst;    myTTY.modeVal ¬ 0};    GetBlock: Stream.GetProcedure = {  csmPriority: Process.Priority = Process.priorityForeground;  NotifyNextOfKin: ENTRY PROC = INLINE {myTTY.channel ¬ NIL; NOTIFY receiveDeath};  oldPriority: Process.Priority = Process.GetPriority[];  ProcessChar: ENTRY PROC RETURNS [done: BOOLEAN ¬ FALSE] = INLINE {      IF stat = breakDetected OR ch = controlStop THEN {        myTTY.breakDetected ¬ TRUE; myTTY.breakCount ¬ myTTY.breakCount + 1;        TTYPort.SetParameter[myTTY.channel, [breakDetectedClear[TRUE]]          ! TTYPort.ChannelQuiesced => CONTINUE]}      ELSE {        block.blockPointer[block.startIndex] ¬ LOOPHOLE[ch];	bytesTransferred ¬ 1; why ¬ normal; sst ¬ TTYConstants.normal;	RETURN[TRUE]}};  ch: CHARACTER; stat: TTYPort.TransferStatus;  Process.SetPriority[csmPriority];  bytesTransferred ¬ 0;  DO    [ch, stat] ¬ TTYPort.Get[myTTY.channel ! TTYPort.ChannelQuiesced => EXIT];    IF stat=aborted OR stat=abortedByDelete THEN EXIT;    IF ProcessChar[] THEN RETURN;    ENDLOOP;  Process.SetPriority[oldPriority];  NotifyNextOfKin[]};  --~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-- MAINLINE CODE ----~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~END....LOGJuly 28, 1980  9:25 AM		Mary MXA    	Created.August 15, 1980  1:18 PM	Mary MXA    	Many changes.Time: August 27, 1980  7:01 PM	Mary MXA    	Private errors on Create, BackingStream.Time: September 12, 1980  11:41 PM	SXY   	Added UserAbort and ResetUserAbort.Time: September 19, 1980  3:24 PM	SXY   	Line Speed is set to 9600bps.Time: October 2, 1980  1:32 PM	MXA    	Change tty init; remove Process.October 3, 1980  5:32 PM		SXY   	Added tty.breakDetected, tty.breakCount and	controlStop. UserAbort, ResetUserAbort and Receive are modified to use them.October 7, 1980  4:38 PM		SXY   	Priority of Receive process is raised and	Break detection is done using only tty.breakDetected.February 23, 1981  1:24 PM		RXG   	Fixed bug in input stream processing;	replaced calls to Storage with Heap ops.26-Aug-81 18:54:16	FXH    	Rolled into 8.0c13-Nov-81 15:18:04	CRF	Converted to new TTY interface for 8.0e.
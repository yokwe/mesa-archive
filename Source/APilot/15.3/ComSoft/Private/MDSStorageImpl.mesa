-- Copyright (C) 1981, 1982, 1983, 1984  by Xerox Corporation. All rights reserved. -- MDSStorageImpl.Mesa  Edited by--   SXX	26-Aug-81 10:26:38--   BXX	22-Oct-81 15:15:40--   SXW   	26-Jan-81 18:09:03--   PXK    	Oct 8, 1980 1:37 PM--   FXH    	July 25, 1980  7:06PM--   JGS	19-Aug-81 11:57:13--   LXR    	22-Sep-82 11:30:38--   RXJ     	 6-Jul-83 23:34:39--   RSV        23-Mar-87 11:08:24  Do ownerChecking the mds relieved way.DIRECTORY  Ascii USING [SP, TAB],  Environment USING [wordsPerPage],  File USING [nullFile],  FrameExtras USING [LongGFToGFTHandle],  Heap USING [ExpandMDS, GetAttributesMDS, PruneMDS, systemMDSZone],  Inline USING [LongDiv],  MDSStorage USING [EmptyString, FreeStringNil, StringLength],  PrincOpsExtras2 USING [GFTHandle],  Runtime USING [GetCaller],  Space USING [Allocate, Interval, MapAt, MDS, Pointer, Unmap],  SpecialRuntimeExtras USING [GlobalFrameFromProgram];MDSStorageImpl: PROGRAM  IMPORTS     FrameExtras, Heap, Inline, Runtime, MDSStorage, Space, SpecialRuntimeExtras  EXPORTS MDSStorage =  BEGIN  ownerChecking: BOOLEAN = Heap.GetAttributesMDS[    Heap.systemMDSZone].ownerChecking;  PageSize: CARDINAL = Environment.wordsPerPage;  InvalidNode: PUBLIC ERROR [p: POINTER] = CODE;  ZoneTooSmall: PUBLIC ERROR [p: POINTER] = CODE;  WordType: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF WORD];  PagesForWords: PUBLIC PROCEDURE [nWords: CARDINAL] RETURNS [CARDINAL] =    BEGIN OPEN Environment;    RETURN[Inline.LongDiv[LONG[nWords] + wordsPerPage - 1, wordsPerPage]];    END;  Pages: PUBLIC PROCEDURE [npages: CARDINAL] RETURNS [base: POINTER] =    BEGIN    interval: Space.Interval = Space.Allocate[npages, Space.MDS[]];     RETURN [Space.Pointer[Space.MapAt[      at: interval,  window: [File.nullFile, 0, npages], class: data, life: dead,      swapUnits: IF npages > 7 THEN [uniform[4]] ELSE [unitary[]]].pointer]];    END;  Words: PUBLIC PROCEDURE [nwords: CARDINAL] RETURNS [base: POINTER] = {    RETURN[Pages[(nwords + PageSize - 1)/PageSize]]};  FreePages, FreeWords: PUBLIC PROCEDURE [base: POINTER] = {    [] ¬ Space.Unmap[base]};  -- management of the heap  Node: PUBLIC PROCEDURE [nwords: CARDINAL] RETURNS [p: POINTER] =    BEGIN    p ¬ Heap.systemMDSZone.NEW[WordType[nwords]];    IF ownerChecking THEN (p - 1)­ ¬ GetGF[Runtime.GetCaller[]];    RETURN[p]    END;  Free: PUBLIC PROCEDURE [p: POINTER] = {    IF p # NIL THEN Heap.systemMDSZone.FREE[@p]};  LocalString: PROCEDURE [nchars: CARDINAL] RETURNS [s: STRING] =    {s ¬ Heap.systemMDSZone.NEW[StringBody[nchars]]};  String: PUBLIC PROCEDURE [nchars: CARDINAL] RETURNS [s: STRING] =    BEGIN    s ¬ LocalString[nchars];    IF ownerChecking THEN LOOPHOLE[(s - 1), POINTER]­ ¬ GetGF[Runtime.GetCaller[]];    RETURN    END;  CopyString: PUBLIC PROCEDURE [s: LONG STRING, longer: CARDINAL ¬ 0]    RETURNS [newS: STRING] =    BEGIN    l: CARDINAL = (IF s = NIL THEN 0 ELSE s.length);    IF s = NIL AND longer = 0 THEN RETURN[NIL];    newS ¬ LocalString[l + longer];    FOR i: CARDINAL IN [0..l) DO newS[i] ¬ s[i] ENDLOOP;    newS.length ¬ l;    IF ownerChecking THEN LOOPHOLE[(newS - 1), POINTER]­ ¬ GetGF[Runtime.GetCaller[]];    END;  ExpandString: PUBLIC PROCEDURE [s: POINTER TO STRING, longer: CARDINAL ¬ 0] =    BEGIN    newS: STRING ¬ CopyString[      s­, longer + (IF s­ = NIL THEN 0 ELSE s.maxlength - s.length)];    FreeString[s­];    s­ ¬ newS;    IF ownerChecking THEN LOOPHOLE[(newS - 1), POINTER]­ ¬ GetGF[Runtime.GetCaller[]];    END;  FreeString: PUBLIC PROCEDURE [s: STRING] = LOOPHOLE[Free];  Prune: PUBLIC PROCEDURE RETURNS [BOOLEAN] = {    Heap.PruneMDS[Heap.systemMDSZone]; RETURN[TRUE]};  Expand: PUBLIC PROCEDURE [pages: CARDINAL] = {    Heap.ExpandMDS[Heap.systemMDSZone, pages]};  SetOwner: PROC [node: POINTER, owner: UNSPECIFIED] = INLINE {    p: POINTER = node­; (p - 1)­ ¬ owner};  GetGF: PROC [p: PROGRAM] RETURNS [PrincOpsExtras2.GFTHandle] = INLINE {    RETURN[FrameExtras.LongGFToGFTHandle[      SpecialRuntimeExtras.GlobalFrameFromProgram[p]]]};  AppendChar: PUBLIC PROCEDURE [p: POINTER TO STRING, c: CHARACTER] =    BEGIN    s: STRING ¬ [2];    s[0] ¬ c;    s.length ¬ 1;    IF AppendStringLocal[p, s] AND ownerChecking THEN      SetOwner[p, GetGF[Runtime.GetCaller[]]];    END;  AppendStringLocal: PROC [    to: POINTER TO STRING, from: LONG STRING, extra: CARDINAL ¬ 0]    RETURNS [new: BOOLEAN] =    BEGIN    length: CARDINAL;    i: CARDINAL;    IF MDSStorage.EmptyString[from] OR to = NIL THEN RETURN;    length ¬ from.length + MDSStorage.StringLength[to­];    SELECT TRUE FROM      to­ = NIL => {to­ ¬ String[length]; new ¬ TRUE};      to.maxlength < length => {        temp: STRING ¬ to­;        to­ ¬ CopyString[to­, length - to.length + extra];        FreeString[temp];        new ¬ TRUE};      ENDCASE => new ¬ FALSE;    FOR i IN [0..from.length) DO to[i + to.length] ¬ from[i] ENDLOOP;    to.length ¬ length;    RETURN    END;  AppendExtensionIfNeeded: PUBLIC PROCEDURE [    to: POINTER TO STRING, extension: LONG STRING] RETURNS [done: BOOLEAN] =    BEGIN    i: CARDINAL;    done ¬ FALSE;    IF ~MDSStorage.EmptyString[to­] THEN      BEGIN      FOR i DECREASING IN [1..to.length) DO        SELECT to­[i] FROM          '., Ascii.SP, Ascii.TAB => to.length ¬ to.length - 1;          ENDCASE => EXIT;        ENDLOOP;      FOR i DECREASING IN [0..to.length) DO        IF to­[i] = '. THEN EXIT;        REPEAT          FINISHED =>            BEGIN	    IF extension[0] # '. AND AppendStringLocal[to, "."L, extension.length]	      AND ownerChecking THEN SetOwner[to, GetGF[Runtime.GetCaller[]]];            IF AppendStringLocal[to, extension] AND ownerChecking THEN              SetOwner[to, GetGF[Runtime.GetCaller[]]];            done ¬ TRUE;            END;        ENDLOOP      END;    END;  AppendString: PUBLIC PROCEDURE [    to: POINTER TO STRING, from: LONG STRING, extra: CARDINAL ¬ 0] =    BEGIN    IF AppendStringLocal[to, from, extra] AND ownerChecking THEN      SetOwner[to, GetGF[Runtime.GetCaller[]]];    END;  Replace: PUBLIC PROCEDURE [to: POINTER TO STRING, from: LONG STRING] =    BEGIN    IF to = NIL THEN RETURN[];    IF to­ # NIL THEN to­ ¬ MDSStorage.FreeStringNil[to­];    IF from # NIL THEN to­ ¬ CopyString[from];    IF ownerChecking THEN SetOwner[to, GetGF[Runtime.GetCaller[]]];    RETURN    END;  END.
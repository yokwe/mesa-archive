-- Copyright (C) 1982, 1983, 1984, 1985, 1987  by Xerox Corporation. All rights reserved. -- HeapCheckPack.mesa; last revised by: CJS on 18-Feb-87 12:20:49.--	This is a layer on top of Pilot's Heap interface that does owner checking and provides multiple Zones. -- In development mode:-- Client sees zone handles that are ZoneMgrPack ZoneRep objects.-- Client calls to NEW/FREE and Heap.Make/Free go thru ZoneMgrPack.-- Each node has an extra word (NodeHeader) ahead of it.-- This module keeps a linked list of all zones.-- In release mode: -- Client sees zone handles that are Pilot objects created by HeapImpl.-- Client calls to NEW/FREE go directly to HeapImpl; to Heap.Make/Free, thru ZoneMgrPack.-- NodeHeader records are not used; nodes have client-specified length.-- This module's linked list includes only the predefined zones.-- W A R N I N G .... the routine NodeSize below relies on Pilot's non-public ZoneInternal interface, and on implementation of HeapImpl.DIRECTORY  Environment USING [PageCount],  HeapCheckDefs,  Heap,  Inline USING [LowHalf],  PrincOps USING [GlobalFrameHandle],  Runtime,  Space,  ZoneInternal;HeapCheckPack: MONITOR  IMPORTS pilot: Heap, Inline, Runtime EXPORTS HeapCheckDefs, Heap =  BEGIN  -- - - - - - - - - - - - - - - - - - - -  Errors  - - - - - - - - - - - - - - - - - - -  -- none.  -- - - - - - - - - - - - - - - - - - - -  Public variables  - - - - - - - - - - - - - - - - - - -  systemZone: PUBLIC UNCOUNTED ZONE ¬ NIL;  systemMDSZone: PUBLIC MDSZone ¬ NIL;  -- - - - - - - - - - - - - - - - - - - -  Debugging flags  - - - - - - - - - - - - - - - - - - -  checkingOnFree: BOOLEAN ¬ TRUE;  -- A master switch; if False, all checking on free is turned off.  checkingOnSystemFree: BOOLEAN ¬ FALSE;  -- The setting for the system zones.  defaultCheckingOnFree: BOOLEAN ¬ FALSE;  -- The initial default for newly created zones.  releaseMode: BOOLEAN = FALSE;  -- Don't change this flag after entry to Init.  -- - - - - - - - - - - - - - - - - - - -  Private variables  - - - - - - - - - - - - - - - - - - -  head: UncountedZoneRep ¬ NIL;  -- Linked list of zones.  hsz: CARDINAL = SIZE[NodeHeader];  mdsHead: MDSZoneRep ¬ NIL;  -- Linked list of MDS zones.  mdsProcs: MDSProcs ¬ [MakeMDSNode, FreeMDSNode];  uncProcs: Procs ¬ [MakeNode, FreeNode];  zoneCt: CARDINAL ¬ 0;  -- - - - - - - - - - - - - - - - - - - -  Types  - - - - - - - - - - - - - - - - - - -  Attributes: TYPE = Heap.Attributes;  LptData: TYPE = LONG POINTER TO Data;  LptNodeHeader: TYPE = LONG POINTER TO NodeHeader;  MDSZoneRep: TYPE = POINTER TO MDSZoneObject;  NWords: TYPE = Heap.NWords;  PtNodeHeader: TYPE = POINTER TO NodeHeader;  SwapUnitSize: TYPE = Space.SwapUnitSize;  Tallies: TYPE = {    makeCt, freeCt, maxNdSz, minNdSz, maxNdCt, minNdCt, curNdCt, maxWdCt, minWdCt,    curWdCt};  UncountedZoneRep: TYPE = LONG POINTER TO UncountedZoneObject;  ZoneType: TYPE = {predefined, system, clientDefined};  -- - - - - - - - - - - - - - - - - - - -  Zone Data Structure  - - - - - - - - - - - - - - - - - - -  UncountedZoneObject: TYPE = MACHINE DEPENDENT RECORD [    procs(0): LONG POINTER TO Procs ¬ @uncProcs,    underlying(2): UNCOUNTED ZONE,    next(4): UncountedZoneRep ¬ NIL,    data(6): Data];  Procs: TYPE = MACHINE DEPENDENT RECORD [    Make(0): PROCEDURE [UNCOUNTED ZONE, NWords] RETURNS [LONG POINTER],    Free(2): PROCEDURE [UNCOUNTED ZONE, LONG POINTER]    -- could add other generic Heap operations here    ];  MDSZoneObject: TYPE = MACHINE DEPENDENT RECORD [    procs(0): LONG POINTER TO MDSProcs ¬ @mdsProcs,    underlying(2): MDSZone,    next(3): MDSZoneRep,    data(4): Data];  MDSProcs: TYPE = MACHINE DEPENDENT RECORD [    Make(0): PROCEDURE [MDSZone, NWords] RETURNS [POINTER],    Free(2): PROCEDURE [MDSZone, POINTER]    -- could add other generic (MDS) Heap operations here    ];  Data: TYPE = MACHINE DEPENDENT RECORD [    checkingOnFree(0:0..0): BOOLEAN,    zoneNumber(0:1..15): [0..100000B) ¬ 0,    owner(1): ShortPROGRAM,    uniform(2:0..0): BOOLEAN,    objectSize(2:1..15): NWords,    tallies(3): ARRAY Tallies OF CARDINAL ¬ [      0, 0, 0, LAST[CARDINAL], 0, LAST[CARDINAL], 0, 0, LAST[CARDINAL], 0]];  -- - - - - - - - - - - - - - - - - - - -  Node Data Structure  - - - - - - - - - - - - - - - - - - -  ShortPROGRAM: TYPE = PrincOps.GlobalFrameHandle;    NodeHeader: TYPE = MACHINE DEPENDENT RECORD [    SELECT OVERLAID * FROM    program => [program: ShortPROGRAM],    validProgram => [validBits: [0..40000B), zero: [0..4) ¬ 0],    annotated => [      upperProgram: [0..40000B), reserved: [0..1] ¬ 0, protected: BOOLEAN],    ENDCASE];  -- - - - - - - - - - - - - Public HeapCheckDefs operations  - - - - - - - - - - - - - - - -   UnprotectNode: PUBLIC PROC [node: LONG POINTER, caller: PROGRAM] =    -- This operation removes protection from a node.  After it is called, anybody may free 'node'.  However, UnprotectNode may only be called by the program that allocated 'node'.    BEGIN OPEN h: LOOPHOLE[node - hsz, LptNodeHeader];    owner: NodeHeader ¬ [validProgram[h.validBits]];    IF releaseMode THEN RETURN;    IF checkingOnFree AND caller # Lengthen[owner.program] THEN      Runtime.CallDebugger["Freer isn't owner.  (You may Proceed.)"L];    h.protected ¬ FALSE;    END;  SetCheckingOnFree: PUBLIC ENTRY PROC [    z: UNCOUNTED ZONE, signalviolations: BOOLEAN] RETURNS [previous: BOOLEAN] =    -- Sets the flag that determines whether or not a signal is generated on freeing a protected node when the program doing the freeing is not the owner.    BEGIN OPEN rep: LOOPHOLE[z, UncountedZoneRep];    ENABLE UNWIND => {};    IF releaseMode THEN RETURN[FALSE];    previous ¬ rep.data.checkingOnFree;    rep.data.checkingOnFree ¬ signalviolations;    END;  UnprotectMDSNode: PUBLIC PROC [node: POINTER, caller: PROGRAM] =    -- The MDS counterpart of UnprotectNode.    BEGIN OPEN h: LOOPHOLE[node - hsz, PtNodeHeader];    owner: NodeHeader ¬ [validProgram[h.validBits]];    IF releaseMode THEN RETURN;    IF checkingOnFree AND caller # Lengthen[owner.program] THEN      Runtime.CallDebugger["Freer isn't owner.  (You may Proceed.)"L];    h.protected ¬ FALSE;    END;  SetCheckingOnMDSFree: PUBLIC PROC [z: MDSZone, signalviolations: BOOLEAN]    RETURNS [previous: BOOLEAN] =    -- The MDS counterpart of SetCheckingOnFree.    BEGIN OPEN rep: LOOPHOLE[z, MDSZoneRep];    IF releaseMode THEN RETURN[FALSE];    previous ¬ rep.data.checkingOnFree;    rep.data.checkingOnFree ¬ signalviolations;    END;  -- - - - - - - - - - Private HeapCheckDefs operations  - - - - - - - - - - - - -  SetOwner: PUBLIC PROC [node: LONG POINTER, owner: PROGRAM] =    BEGIN    OPEN      h: LOOPHOLE[node - hsz, LptNodeHeader],      p: LOOPHOLE[Shorten[owner], NodeHeader];    IF ~releaseMode THEN h.upperProgram ¬ p.upperProgram;    END;  SetMDSOwner: PUBLIC PROC [node: POINTER, owner: PROGRAM] =    BEGIN    OPEN      h: LOOPHOLE[node - hsz, PtNodeHeader],      p: LOOPHOLE[Shorten[owner], NodeHeader];    IF ~releaseMode THEN h.upperProgram ¬ p.upperProgram;    END;  GetOwner: PUBLIC PROC [node: LONG POINTER]    RETURNS [owner: PROGRAM, protected: BOOLEAN] =    BEGIN OPEN h: LOOPHOLE[node - hsz, LptNodeHeader];    sp: ShortPROGRAM;    IF releaseMode THEN RETURN[NIL, FALSE];    LOOPHOLE[sp, validProgram NodeHeader] ¬ [      validProgram[validBits: h.validBits]];    RETURN[owner: Lengthen[sp], protected: h.protected];    END;  GetMDSOwner: PUBLIC PROC [node: POINTER]    RETURNS [owner: PROGRAM, protected: BOOLEAN] =    BEGIN OPEN h: LOOPHOLE[node - hsz, PtNodeHeader];    sp: ShortPROGRAM;    IF releaseMode THEN RETURN[NIL, FALSE];    LOOPHOLE[sp, validProgram NodeHeader] ¬ [      validProgram[validBits: h.validBits]];    RETURN[owner: Lengthen[sp], protected: h.protected];    END;  -- - - - - - - Public Heap operations; create/destroy zones - - - - - - -  Create: PUBLIC PROC [    initial: Space.PageCount, maxSize: Space.PageCount ¬ Heap.unlimitedSize,    increment: Space.PageCount ¬ 4, swapUnitSize: SwapUnitSize ¬ Space.defaultSwapUnitSize,    threshold: NWords ¬ pilot.minimumNodeSize,  -- smaller allocation request round up to this size    largeNodeThreshold: NWords ¬ Space.wordsPerPage/2,  -- larger nodes in separate spaces    ownerChecking: BOOLEAN ¬ FALSE, checking: BOOLEAN ¬ FALSE]    RETURNS [UNCOUNTED ZONE] =    BEGIN  -- Don't make 'entry' because NEW calls MakeNode calls BkKeepMake.    overhead: CARDINAL =      IF releaseMode OR largeNodeThreshold > 8*Space.wordsPerPage THEN 0 ELSE hsz;    underlying: UNCOUNTED ZONE ¬ pilot.Create[      initial, maxSize, increment, swapUnitSize, threshold + overhead,      largeNodeThreshold + overhead, FALSE,      IF releaseMode THEN FALSE ELSE checking];    IF releaseMode THEN RETURN[underlying]    ELSE      BEGIN      caller: NodeHeader = GetCaller[];      z: UncountedZoneRep ¬ systemZone.NEW[        UncountedZoneObject ¬ [        , underlying, , [defaultCheckingOnFree, , caller.program, FALSE, 0]]];      Link: ENTRY PROC = {        z.data.zoneNumber ¬ zoneCt ¬ zoneCt + 1; z.next ¬ head; head ¬ z};      Link[];      RETURN[LOOPHOLE[z]]      END;    END;  CreateUniform: PUBLIC PROC [    initial: Space.PageCount, maxSize: Space.PageCount ¬ Heap.unlimitedSize,    increment: Space.PageCount ¬ 4, swapUnitSize: SwapUnitSize ¬ Space.defaultSwapUnitSize,    objectSize: NWords, ownerChecking: BOOLEAN ¬ FALSE, checking: BOOLEAN ¬ FALSE]    RETURNS [UNCOUNTED ZONE] =    BEGIN  -- Don't make 'entry' because NEW calls MakeNode calls BkKeepMake.    overhead: CARDINAL = IF releaseMode THEN 0 ELSE hsz;    underlying: UNCOUNTED ZONE ¬ pilot.CreateUniform[      initial, maxSize, increment, swapUnitSize, objectSize + overhead,      FALSE, IF releaseMode THEN FALSE ELSE checking];    IF releaseMode THEN RETURN[underlying]    ELSE      BEGIN      caller: NodeHeader = GetCaller[];      z: UncountedZoneRep ¬ systemZone.NEW[        UncountedZoneObject ¬ [        , underlying, , [defaultCheckingOnFree, , caller.program, TRUE, objectSize+overhead]]];      Link: ENTRY PROC = {        z.data.zoneNumber ¬ zoneCt ¬ zoneCt + 1; z.next ¬ head; head ¬ z};      Link[];      RETURN[LOOPHOLE[z]]      END;    END;  CreateMDS: PUBLIC PROC [    initial: Space.PageCount, maxSize: Space.PageCount ¬ Heap.unlimitedSize,    increment: Space.PageCount ¬ 1,    swapUnitSize: SwapUnitSize ¬ Space.defaultSwapUnitSize,    threshold: NWords ¬ pilot.minimumNodeSize,    largeNodeThreshold: NWords ¬ Space.wordsPerPage/2,    ownerChecking: BOOLEAN ¬ FALSE, checking: BOOLEAN ¬ FALSE] RETURNS [MDSZone] =    BEGIN  -- Don't make 'entry' because NEW calls MakeMDSNode calls BkKeepMake.    overhead: CARDINAL =      IF releaseMode OR largeNodeThreshold > 8*Space.wordsPerPage THEN 0 ELSE hsz;    underlying: MDSZone ¬ pilot.CreateMDS[      initial, maxSize, increment, swapUnitSize, threshold + overhead,      largeNodeThreshold + overhead, FALSE,      IF releaseMode THEN FALSE ELSE checking];    IF releaseMode THEN RETURN[underlying]    ELSE      BEGIN      caller: NodeHeader = GetCaller[];      z: MDSZoneRep ¬ systemMDSZone.NEW[        MDSZoneObject ¬ [        , underlying, , [defaultCheckingOnFree, , caller.program, FALSE, 0]]];      LinkMDS: ENTRY PROC = {        z.data.zoneNumber ¬ zoneCt ¬ zoneCt + 1; z.next ¬ mdsHead; mdsHead ¬ z};      LinkMDS[];      RETURN[LOOPHOLE[z]]      END;    END;  Delete: PUBLIC PROC [z: UNCOUNTED ZONE, checkEmpty: BOOLEAN ¬ FALSE] =    BEGIN  -- Don't make 'entry' because FREE calls FreeNode calls BkKeepFree.    rep: UncountedZoneRep ¬ LOOPHOLE[z];    UnLink: ENTRY PROC =      BEGIN      ENABLE UNWIND => {};      FOR p: LONG POINTER TO UncountedZoneRep ¬ @head, @p.next DO  -- Remove from linked list.        SELECT p­ FROM          NIL => ERROR pilot.Error[invalidZone];          rep => {p­ ¬ rep.next; EXIT};          ENDCASE;        ENDLOOP;      END;    IF releaseMode THEN {pilot.Delete[z, FALSE]; RETURN};    UnLink[];    pilot.Delete[rep.underlying, checkEmpty];    systemZone.FREE[@rep];    END;  DeleteMDS: PUBLIC PROC [z: MDSZone, checkEmpty: BOOLEAN ¬ FALSE] =    BEGIN  -- Don't make 'entry' because FREE calls FreeNode calls BkKeepFree.    rep: MDSZoneRep ¬ LOOPHOLE[z];    UnLinkMDS: ENTRY PROC =      BEGIN      ENABLE UNWIND => {};      FOR p: LONG POINTER TO MDSZoneRep ¬ @mdsHead, @p.next DO  -- Remove from linked list.        SELECT p­ FROM          NIL => ERROR pilot.Error[invalidZone];          rep => {p­ ¬ rep.next; EXIT};          ENDCASE;        ENDLOOP;      END;    IF releaseMode THEN {pilot.DeleteMDS[z, FALSE]; RETURN};    UnLinkMDS[];    pilot.DeleteMDS[rep.underlying, checkEmpty];    systemMDSZone.FREE[@rep];    END;  -- - - - - - - Public Heap operations; miscellaneous - - - - - - -  GetAttributes: PUBLIC PROC [z: UNCOUNTED ZONE]    RETURNS [      heapPages, maxSize, increment: Environment.PageCount, swapUnitSize: SwapUnitSize,      ownerChecking, checking: BOOLEAN, attributes: Attributes] = {    [heapPages: heapPages, maxSize: maxSize,      increment: increment, swapUnitSize: swapUnitSize,      ownerChecking: ownerChecking, checking: checking,      attributes: attributes] ¬ pilot.GetAttributes[PilotZone[z]]};  GetAttributesMDS: PUBLIC PROC [z: MDSZone]    RETURNS [      heapPages, largeNodePages, maxSize, increment: Environment.PageCount, swapUnitSize: Space.SwapUnitSize,      threshold, largeNodeThreshold: NWords, ownerChecking, checking: BOOLEAN] = {    [heapPages: heapPages, largeNodePages: largeNodePages, increment: increment,      maxSize: maxSize, swapUnitSize: swapUnitSize, threshold: threshold,      largeNodeThreshold: largeNodeThreshold, ownerChecking: ownerChecking,      checking: checking] ¬ pilot.GetAttributesMDS[PilotMDSZone[z]]};  Expand: PUBLIC PROC [z: UNCOUNTED ZONE, pages: Space.PageCount] = {    pilot.Expand[PilotZone[z], pages]};  ExpandMDS: PUBLIC PROC [z: MDSZone, pages: Space.PageCount] = {    pilot.ExpandMDS[PilotMDSZone[z], pages]};  Flush: PUBLIC PROC [z: UNCOUNTED ZONE] = {pilot.Flush[PilotZone[z]]};  FlushMDS: PUBLIC PROC [z: MDSZone] = {pilot.FlushMDS[PilotMDSZone[z]]};  OwnerChecking: PUBLIC PROC [z: UNCOUNTED ZONE] RETURNS [BOOLEAN] = {    RETURN[pilot.OwnerChecking[PilotZone[z]]]};  OwnerCheckingMDS: PUBLIC PROC [z: MDSZone] RETURNS [BOOLEAN] = {    RETURN[pilot.OwnerCheckingMDS[PilotMDSZone[z]]]};  Prune: PUBLIC PROC [z: UNCOUNTED ZONE] = {pilot.Prune[PilotZone[z]]};  PruneMDS: PUBLIC PROC [z: MDSZone] = {pilot.PruneMDS[PilotMDSZone[z]]};  CheckOwner: PUBLIC PROC [p: LONG POINTER, z: UNCOUNTED ZONE] =    BEGIN OPEN h: LOOPHOLE[p - hsz, LptNodeHeader];    IF ~releaseMode AND GetCaller[].validBits # h.validBits THEN      ERROR pilot.Error[invalidOwner];    END;  CheckOwnerMDS: PUBLIC PROC [p: POINTER, z: MDSZone] = {    CheckOwner[p, NIL]};  SetChecking: PUBLIC PROC [z: UNCOUNTED ZONE, checking: BOOLEAN] = {    IF ~releaseMode THEN pilot.SetChecking[PilotZone[z], checking]};  SetCheckingMDS: PUBLIC PROC [z: MDSZone, checking: BOOLEAN] = {    IF ~releaseMode THEN pilot.SetCheckingMDS[PilotMDSZone[z], checking]};  -- - - - - - - Public Heap operations; memory (de)allocation - - - - - - -  MakeNode: PUBLIC PROC [z: UNCOUNTED ZONE ¬ systemZone, n: NWords]    RETURNS [LONG POINTER] =    BEGIN OPEN rep: LOOPHOLE[z, UncountedZoneRep];    IF releaseMode THEN RETURN[pilot.MakeNode[z, n]]    ELSE      BEGIN      node: LONG POINTER = pilot.MakeNode[rep.underlying, n + hsz];      BkKeepMake[node, @rep.data, GetCaller[]];      RETURN[node + hsz];      END;    END;  FreeNode: PUBLIC PROC [z: UNCOUNTED ZONE ¬ systemZone, p: LONG POINTER] =    BEGIN OPEN rep: LOOPHOLE[z, UncountedZoneRep];    IF rep.procs.Free # FreeNode THEN {z.FREE[@p]; RETURN};    IF releaseMode THEN pilot.FreeNode[z, p]    ELSE      BEGIN      IF p = NIL THEN RETURN;  -- Match HeapImpl's behavior      BkKeepFree[p - hsz, @rep.data, GetCaller[]];      pilot.FreeNode[rep.underlying, p - hsz];      END;    END;  MakeMDSNode: PUBLIC PROC [z: MDSZone ¬ systemMDSZone, n: NWords]    RETURNS [POINTER] =    BEGIN OPEN rep: LOOPHOLE[z, MDSZoneRep];    IF releaseMode THEN RETURN[pilot.MakeMDSNode[z, n]]    ELSE      BEGIN      node: POINTER = pilot.MakeMDSNode[rep.underlying, n + hsz];      BkKeepMake[node, @rep.data, GetCaller[]];      RETURN[node + hsz];      END;    END;  FreeMDSNode: PUBLIC PROC [z: MDSZone ¬ systemMDSZone, p: POINTER] =    BEGIN OPEN rep: LOOPHOLE[z, MDSZoneRep];    IF releaseMode THEN pilot.FreeMDSNode[z, p]    ELSE      BEGIN      IF p = NIL THEN RETURN;  -- Match HeapImpl's behavior      BkKeepFree[p - hsz, @rep.data, GetCaller[]];      pilot.FreeMDSNode[rep.underlying, p - hsz];      END;    END;  -- - - - - - - - - - - - - - - Miscellany - - - - - - - - - - - - - - -  Shorten: PROC [prog: PROGRAM] RETURNS [ShortPROGRAM] = INLINE {    RETURN[Inline.LowHalf[LOOPHOLE[prog]]]};  Lengthen: PROC [sprog: ShortPROGRAM] RETURNS [PROGRAM] = INLINE {    RETURN[LOOPHOLE[LONG[sprog]]]};  GetCaller: PROC RETURNS [NodeHeader] = INLINE {    RETURN[[program[Shorten[Runtime.GetCaller[]]]]]};  PilotZone: PROC [z: UNCOUNTED ZONE] RETURNS [UNCOUNTED ZONE] = INLINE    -- Returns the pilot implementation, regardless of mode.    {RETURN[IF releaseMode THEN z ELSE LOOPHOLE[z, UncountedZoneRep].underlying]};  PilotMDSZone: PROC [z: MDSZone] RETURNS [MDSZone] = INLINE    -- Returns the pilot implementation, regardless of mode.    {RETURN[IF releaseMode THEN z ELSE LOOPHOLE[z, MDSZoneRep].underlying]};  BkKeepMake: ENTRY PROC [h: LptNodeHeader, znData: LptData, caller: NodeHeader] =    BEGIN    ENABLE UNWIND => {};    n: NWords = IF znData.uniform THEN znData.objectSize ELSE NodeSize[h];    h­ ¬ [annotated[caller.upperProgram, , TRUE]];    znData.tallies[makeCt] ¬ znData.tallies[makeCt] + 1;    znData.tallies[curNdCt] ¬ znData.tallies[curNdCt] + 1;    znData.tallies[maxNdCt] ¬ MAX[      znData.tallies[maxNdCt], znData.tallies[curNdCt]];    znData.tallies[maxNdSz] ¬ MAX[znData.tallies[maxNdSz], n];    znData.tallies[minNdSz] ¬ MIN[znData.tallies[minNdSz], n];    znData.tallies[curWdCt] ¬ znData.tallies[curWdCt] + n;    znData.tallies[maxWdCt] ¬ MAX[      znData.tallies[maxWdCt], znData.tallies[curWdCt]];    END;  BkKeepFree: ENTRY PROC [h: LptNodeHeader, znData: LptData, caller: NodeHeader] =    BEGIN    ENABLE UNWIND => {};    nodeSize: CARDINAL;    IF h.program = NIL THEN {      IF checkingOnFree THEN        Runtime.CallDebugger["Freeing a node twice.  (You may Proceed.)"L];      RETURN};    IF checkingOnFree AND znData.checkingOnFree AND h.protected      AND caller.validBits # h.validBits THEN      Runtime.CallDebugger["Freer isn't owner.  (You may Proceed.)"L];    h.program ¬ NIL;    znData.tallies[freeCt] ¬ znData.tallies[freeCt] + 1;    znData.tallies[curNdCt] ¬ znData.tallies[curNdCt] - 1;    znData.tallies[minNdCt] ¬ MIN[      znData.tallies[minNdCt], znData.tallies[curNdCt]];    nodeSize ¬ IF znData.uniform THEN znData.objectSize ELSE NodeSize[h];    znData.tallies[curWdCt] ¬ znData.tallies[curWdCt] - nodeSize;    znData.tallies[minWdCt] ¬ MIN[      znData.tallies[minWdCt], znData.tallies[curWdCt]];    END;  NodeSize: PROC [node: LONG POINTER] RETURNS [NWords] = INLINE    -- Returns the word count of the node.    -- W A R N I N G .... relies on Pilot's non-public ZoneInternal, and on implementation of HeapImpl.    {    RETURN[      LOOPHOLE[node - SIZE[inuse ZoneInternal.NodeHeader], LONG POINTER TO        ZoneInternal.NodeHeader].length]};  -- - - - - - - - - - - - - - - Call from the debugger - - - - - - - - - - - - - - -  SetAllChecking: PUBLIC PROC [checking: BOOLEAN] =    BEGIN    FOR z: MDSZoneRep ¬ mdsHead, z.next UNTIL z = NIL DO      pilot.SetCheckingMDS[z.underlying, checking]; ENDLOOP;    FOR z: UncountedZoneRep ¬ head, z.next UNTIL z = NIL DO      pilot.SetChecking[z.underlying, checking]; ENDLOOP;    END;  -- - - - - - - - - - - - - - - Module initialization - - - - - - - - - - - - - - -  Init: PROC =    BEGIN    caller: NodeHeader = GetCaller[];  -- In this case, caller is ZoneMgrPack itself.    IF releaseMode THEN {      systemZone ¬ pilot.systemZone; systemMDSZone ¬ pilot.systemMDSZone}    ELSE      BEGIN  -- The objects are wide so that they have the headers expected by the debugger UserProc.      WideUncountedZoneObject: TYPE = RECORD [        h: NodeHeader, z: UncountedZoneObject];      WideMDSZoneObject: TYPE = RECORD [h: NodeHeader, z: MDSZoneObject];      z: LONG POINTER TO WideUncountedZoneObject ¬ pilot.systemZone.NEW[        WideUncountedZoneObject ¬ [        [program[NIL]], [        , pilot.systemZone, head, [        checkingOnSystemFree, zoneCt ¬ zoneCt + 1, caller.program, FALSE, 0,	[0, 0, 0, LAST[CARDINAL], 0, LAST[CARDINAL], 0, 0, LAST[CARDINAL], 0]]]]];      m: POINTER TO WideMDSZoneObject ¬ pilot.systemMDSZone.NEW[        WideMDSZoneObject ¬ [        [program[NIL]], [        , pilot.systemMDSZone, mdsHead, [        checkingOnSystemFree, zoneCt ¬ zoneCt + 1, caller.program, FALSE, 0,	[0, 0, 0, LAST[CARDINAL], 0, LAST[CARDINAL], 0, 0, LAST[CARDINAL], 0]]]]];      BkKeepMake[@z.h, @z.z.data, caller];      BkKeepMake[@m.h, @m.z.data, caller];      systemZone ¬ LOOPHOLE[head ¬ @z.z];      systemMDSZone ¬ LOOPHOLE[mdsHead ¬ @m.z]      END;    END;  Init[];  END. Log   (date, person: action)May 26, 1981, Jay Israel: Created file.June 9, 1981, Jay Israel: Add statistics.July 24, 1981, Jay Israel: Adjust zone thresholds for node header size in Create(MDS).August 1, 1981, Jay Israel: Make 'Make' and 'Free' procs generic, so they'll work with Pilot's heaps.AXD    	22-Jan-82 12:57:11JGS    	 8-Dec-82 11:19:33LXR    	 8-Dec-82 11:44:31RXJ      7-Jul-83  0:41:44RSV     26-Dec-85 11:54:30  Fixed FreeNode and FreeMDSNode to just return on freeing NIL to match HeapImpl's behavior.  Moved change log to end of file.CJS	18-Feb-87 12:19:23  MDS relieved, twiddled MDSZoneObject.
-- Copyright (C) 1982  by Xerox Corporation. All rights reserved. --  Unformatter.mesa, HGM, 30-Oct-82 17:25:51DIRECTORY  Environment USING [bitsPerWord],  Format USING [NetFormat],  Inline USING [HighHalf, LowHalf],  String USING [AppendChar, EqualString, StringBoundsFault],  System USING [broadcastHostNumber, HostNumber, NetworkAddress, NetworkNumber, SocketNumber],  Unformat USING [];Unformatter: MONITOR  IMPORTS Inline, String  EXPORTS Unformat =  BEGIN  Error: PUBLIC ERROR = CODE;    NetFormat: TYPE = Format.NetFormat;  HostNumber: PUBLIC PROCEDURE [s: LONG STRING, format: NetFormat ¬ octal]    RETURNS [host: System.HostNumber] =    BEGIN    digits: Digits;    radix: CARDINAL;    IF String.EqualString[s, "*"L] THEN RETURN[System.broadcastHostNumber];    radix ¬ StringToDigits[s, @digits, format];    DigitsToNumber[@host, SIZE[System.HostNumber], radix, @digits];    END;      NetworkAddress: PUBLIC PROCEDURE [s: LONG STRING, format: NetFormat ¬ octal]    RETURNS [address: System.NetworkAddress] =    BEGIN    AppendChar: PROCEDURE [s: STRING, c: CHARACTER] =      BEGIN      String.AppendChar[s, c ! String.StringBoundsFault => ERROR Error];      END;    net: STRING = [maxCharsInNetworkNumber];    host: STRING = [maxCharsInHostNumber];    socket: STRING = [maxCharsInSocketNumber];    finger: CARDINAL ¬ 0;    UNTIL finger = s.length DO      c: CHARACTER = s[finger];      finger ¬ finger + 1;      SELECT c FROM        '#, '. => EXIT;	ENDCASE => AppendChar[net, c];      REPEAT FINISHED => ERROR Error;  -- Both delimiters missing      ENDLOOP;    UNTIL finger = s.length DO      c: CHARACTER = s[finger];      finger ¬ finger + 1;      SELECT c FROM        '#, '. => EXIT;	ENDCASE => AppendChar[host, c];      REPEAT FINISHED => ERROR Error;  -- second delimiter missing      ENDLOOP;    UNTIL finger = s.length DO      c: CHARACTER = s[finger];      finger ¬ finger + 1;      AppendChar[socket, c];      ENDLOOP;    address.net ¬ NetworkNumber[net, format];    address.host ¬ HostNumber[host, format];    address.socket ¬ SocketNumber[socket, format];    END;      NetworkNumber: PUBLIC PROCEDURE [s: LONG STRING, format: NetFormat ¬ octal]    RETURNS [networkNumber: System.NetworkNumber] =    BEGIN    digits: Digits;    radix: CARDINAL;    radix ¬ StringToDigits[s, @digits, format];    DigitsToNumber[@networkNumber, SIZE[System.NetworkNumber], radix, @digits];    END;      SocketNumber: PUBLIC PROCEDURE [s: LONG STRING, format: NetFormat ¬ octal]    RETURNS [socketNumber: System.SocketNumber] =    BEGIN    digits: Digits;    radix: CARDINAL;    radix ¬ StringToDigits[s, @digits, format];    DigitsToNumber[@socketNumber, SIZE[System.SocketNumber], radix, @digits];    END;  bitsPerPSCharacter: CARDINAL = 2;  -- I don't want to think about the dashes  bitsPerOctalCharacter: CARDINAL = 3;  bitsPerHexCharacter: CARDINAL = 4;  minBitsPerCharacter: CARDINAL = MIN[bitsPerPSCharacter, bitsPerOctalCharacter, bitsPerHexCharacter];  maxCharsInHostNumber: CARDINAL = SIZE[System.HostNumber]*Environment.bitsPerWord/minBitsPerCharacter+1;  maxCharsInNetworkNumber: CARDINAL = SIZE[System.NetworkNumber]*Environment.bitsPerWord/minBitsPerCharacter+1;  maxCharsInSocketNumber: CARDINAL = SIZE[System.SocketNumber]*Environment.bitsPerWord/minBitsPerCharacter+1;  maxCharsInNetworkAddress: CARDINAL = maxCharsInNetworkNumber+1+maxCharsInHostNumber+1+maxCharsInSocketNumber;  maxDigits: CARDINAL = MAX[maxCharsInHostNumber, maxCharsInNetworkNumber, maxCharsInSocketNumber];  Digits: TYPE = ARRAY [0..maxDigits) OF CARDINAL;  StringToDigits: PROCEDURE [s: LONG STRING, digits: POINTER TO Digits, format: NetFormat]    RETURNS[radix: CARDINAL] =    BEGIN    finger: CARDINAL ¬ maxDigits;    digits­ ¬ ALL[0];    radix ¬ 0;    FOR i: CARDINAL DECREASING IN [0..s.length) DO      c: CHARACTER ¬ s[i];      digit: CARDINAL;      SELECT c FROM        '- =>	  BEGIN	  IF radix # 0 AND radix # 10 THEN ERROR Error;	  radix ¬ 10;	  LOOP;	  END;        'H, 'h =>	  BEGIN	  IF radix # 0 AND radix # 16 THEN ERROR Error;	  radix ¬ 16;	  LOOP;	  END;        IN ['0..'9] => digit ¬ c - '0;        IN ['A..'F] =>	  BEGIN	  IF radix # 0 AND radix # 16 THEN ERROR Error;	  radix ¬ 16;	  digit ¬ c - 'A + 10;	  END;        IN ['a..'f] =>	  BEGIN	  IF radix # 0 AND radix # 16 THEN ERROR Error;	  radix ¬ 16;	  digit ¬ c - 'a + 10;	  END;        ENDCASE => ERROR Error;      IF finger = 0 THEN ERROR Error;      finger ¬ finger - 1;      digits[finger] ¬ digit;      ENDLOOP;    IF radix = 0 THEN      BEGIN      SELECT format FROM        octal => radix ¬ 8;        productSoftware => radix ¬ 10;        hex => radix ¬ 16;        ENDCASE => ERROR;      END;    END;  DigitsToNumber: PROCEDURE [data: LONG POINTER, words, radix: CARDINAL, digits: POINTER TO Digits] =    BEGIN    overflow: CARDINAL;    FOR i: CARDINAL IN [0..words) DO (data + i)­ ¬ 0; ENDLOOP;    FOR k: CARDINAL IN [0..maxDigits) DO      overflow ¬ digits[k];      FOR i: CARDINAL DECREASING IN [0..words) DO        temp: LONG CARDINAL;        temp ¬ LONG[(data + i)­]*radix + overflow;        (data + i)­ ¬ Inline.LowHalf[temp];        overflow ¬ Inline.HighHalf[temp];        ENDLOOP;      ENDLOOP;    IF overflow # 0 THEN ERROR Error;    END;   END. 
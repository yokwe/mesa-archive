-- File: FormatImpl.mesa - last edit:-- kam                  1-Jul-85 12:34:52-- Mark:               Apr 11, 1980 12:37 PM-- Evans:              May 19, 1980 10:28 AM-- JGS:                15-Jul-81 15:32:04-- Karlton:            18-Oct-82 11:20:22-- Smokey:             14-Jul-81 14:42:12-- Forrest:            October 25, 1980  8:32 PM-- Loretta:             1-Nov-82 11:10:19-- SHayes:             28-Sep-81 17:39:13-- HGM:                21-Jan-83 14:24:35-- CXJ:                28-Jan-82 14:17:26-- Copyright (C) 1981, 1982, 1983, 1984, 1985 by Xerox Corporation. All rights reserved. DIRECTORY  Ascii USING [CR, SP],  Environment USING [bitsPerWord, Block],  Format USING [DateFormat, NetFormat, NumberFormat, StringProc],  Inline USING [BITOR, BITSHIFT],  String USING [    AppendChar, AppendLongNumber, AppendNumber, AppendString, SubString],  System USING [    broadcastHostNumber, HostNumber, NetworkAddress, NetworkNumber, SocketNumber],  Time USING [Append, Packed, TimeZoneStandard, Unpack, Unpacked];FormatImpl: MONITOR IMPORTS Inline, String, Time EXPORTS Format =  BEGIN OPEN Format, String;  defaultProc: StringProc ¬ NIL;  defaultClientData: LONG POINTER ¬ NIL;  SetDefaultOutputSink: PUBLIC ENTRY PROCEDURE [    new: StringProc, clientData: LONG POINTER ¬ NIL]    RETURNS [old: StringProc, oldClientData: LONG POINTER] =    BEGIN    old ¬ defaultProc;    oldClientData ¬ defaultClientData;    defaultProc ¬ new;    defaultClientData ¬ clientData;    END;  GetDefaults: ENTRY PROCEDURE RETURNS [StringProc, LONG POINTER] = INLINE {    RETURN[defaultProc, defaultClientData]};  -- Public procedures  Blank, Blanks: PUBLIC PROCEDURE [    proc: StringProc, n: CARDINAL ¬ 1, clientData: LONG POINTER ¬ NIL] = {    s: STRING = [1];    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    s.length ¬ 1;    THROUGH [0..n) DO proc[" "L, clientData] ENDLOOP};  Block: PUBLIC PROCEDURE [    proc: StringProc, block: Environment.Block, clientData: LONG POINTER ¬ NIL] =    {    bp: LONG POINTER TO PACKED ARRAY OF CHARACTER = LOOPHOLE[block.blockPointer];    s: STRING = [1];    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    s.length ¬ 1;    FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO      s[0] ¬ bp[i]; proc[s, clientData] ENDLOOP};  Char: PUBLIC PROCEDURE [    proc: StringProc, char: CHARACTER, clientData: LONG POINTER ¬ NIL] = {    s: STRING = [1];    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    s.length ¬ 1;    s[0] ¬ char;    proc[s, clientData]};  CR: PUBLIC PROCEDURE [proc: StringProc, clientData: LONG POINTER ¬ NIL] = {    Char[proc, Ascii.CR, clientData]};  Date: PUBLIC PROCEDURE [    proc: StringProc, pt: Time.Packed, format: DateFormat ¬ noSeconds,    zone: Time.TimeZoneStandard ¬ ANSI, clientData: LONG POINTER ¬ NIL] =    BEGIN    Proc: StringProc = {String.AppendString[date, s]};    twoDigit: NumberFormat = [zerofill: TRUE, unsigned: TRUE, columns: 2];    date: STRING ¬ [40];    days: ARRAY [0..7) OF STRING = [      "Mon"L, "Tues"L, "Wednes"L, "Thurs"L, "Fri"L, "Satur"L, "Sun"L];    unpacked: Time.Unpacked = Time.Unpack[pt];    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    Time.Append[date, unpacked, TRUE, zone];    date.length ¬ SELECT format FROM      dateOnly => 9,      noSeconds => 15,      dateTime => 18,      full, mailDate => date.length,      ENDCASE => ERROR UnrecognizedFormatOption;    IF format = mailDate THEN -- always use ANSI format -- {      zone: [-12..12] ¬ unpacked.zone.zone;      IF unpacked.zone.direction = west THEN zone ¬ - zone;      IF unpacked.dst THEN zone ¬ zone + 1;      date[2] ¬ Ascii.SP;      date[6] ¬ Ascii.SP;      IF date[10] = Ascii.SP THEN date[10] ¬ '0;      SELECT TRUE FROM        unpacked.zone.zoneMinutes = 0 AND (	  unpacked.zone.zone IN [5..8] OR zone = 0) => NULL        ENDCASE => {          date.length ¬ 19;          String.AppendChar[date, IF zone > 0 THEN '+ ELSE '-];          Number[Proc, ABS[zone], twoDigit];	  Number[Proc, unpacked.zone.zoneMinutes, twoDigit]};      String.AppendString[date, " ("L];      String.AppendString[date, days[unpacked.weekday]];      String.AppendString[date, "day)"L]};    proc[date, clientData]    END;  Line: PUBLIC PROCEDURE [    proc: StringProc, s: LONG STRING, clientData: LONG POINTER ¬ NIL] =    BEGIN    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    proc[s, clientData];    CR[proc, clientData];    END;  LongNumber: PUBLIC PROCEDURE [    proc: StringProc, n: LONG UNSPECIFIED, format: NumberFormat,    clientData: LONG POINTER ¬ NIL] =    BEGIN    s: STRING ¬ [34];    neg: BOOLEAN;    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    IF LOOPHOLE[n, LONG INTEGER] < 0 AND ~format.unsigned THEN {      n ¬ -LOOPHOLE[n, LONG INTEGER]; neg ¬ TRUE}    ELSE neg ¬ FALSE;    AppendLongNumber[s, n, format.base];    FormatNumber[      s: s, format: format, neg: neg, proc: proc, clientData: clientData];    END;  LongOctal: PUBLIC PROCEDURE [    proc: StringProc, n: LONG CARDINAL, clientData: LONG POINTER ¬ NIL] =    BEGIN    s: STRING ¬ [12];    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    AppendLongNumber[s, n, 8];    IF n > 7 THEN AppendChar[s, 'B];    proc[s, clientData];    END;  Number: PUBLIC PROCEDURE [    proc: StringProc, n: UNSPECIFIED, format: NumberFormat,    clientData: LONG POINTER ¬ NIL] =    BEGIN    s: STRING ¬ [18];    neg: BOOLEAN;    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    IF INTEGER[n] < 0 AND ~format.unsigned THEN {n ¬ -INTEGER[n]; neg ¬ TRUE}    ELSE neg ¬ FALSE;    AppendNumber[s, n, format.base];    FormatNumber[      s: s, format: format, neg: neg, proc: proc, clientData: clientData];    END;  Octal: PUBLIC PROCEDURE [    proc: StringProc, n: CARDINAL, clientData: LONG POINTER ¬ NIL] =    BEGIN    s: STRING ¬ [10];    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    AppendNumber[s, n, 8];    IF n > 7 THEN AppendChar[s, 'B];    proc[s, clientData];    END;  LongSubStringItem: PUBLIC PROCEDURE [    proc: StringProc, ss: String.SubString, clientData: LONG POINTER ¬ NIL] =    SubString;  SubString: PUBLIC PROCEDURE [    proc: StringProc, ss: String.SubString, clientData: LONG POINTER ¬ NIL] =    BEGIN    s: STRING ¬ [100];    sPos, ssPos: CARDINAL ¬ 0;    IF ss = NIL OR ss.base = NIL OR ss.base.length = 0 THEN RETURN[];    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    s.length ¬ 0;    FOR ssPos IN [ss.offset..MIN[ss.base.length, ss.offset + ss.length]) DO      IF sPos >= s.maxlength THEN {        IF s.length # 0 THEN proc[s, clientData]; sPos ¬ 0; s.length ¬ 0};      s[sPos] ¬ ss.base[ssPos];      s.length ¬ s.length + 1;      sPos ¬ sPos + 1;      REPEAT FINISHED => IF s.length # 0 THEN proc[s, clientData];      ENDLOOP;    RETURN[];    END;  -- Private procedures  FormatNumber: PROCEDURE [    s: STRING, format: NumberFormat, neg: BOOLEAN, proc: StringProc,    clientData: LONG POINTER ¬ NIL] =    BEGIN    l: CARDINAL;    fill: STRING ¬ (IF format.zerofill THEN "00000000"L ELSE "        "L);    l ¬ s.length + (IF neg THEN 1 ELSE 0);    IF l < format.columns THEN      BEGIN      fillChars: CARDINAL ¬ format.columns - l;      IF neg AND format.zerofill THEN Char[proc, '-, clientData];      THROUGH [0..fillChars/8) DO proc[fill, clientData]; ENDLOOP;      IF (fill.length ¬ fillChars MOD 8) # 0 THEN proc[fill, clientData];      IF neg AND ~format.zerofill THEN Char[proc, '-, clientData];      END    ELSE IF neg THEN Char[proc, '-, clientData];    proc[s, clientData];    END;  -- Network related things  UnrecognizedFormatOption: ERROR = CODE;  bitsPerPSCharacter: CARDINAL = 2;  -- I don't want to think about the dashes  bitsPerOctalCharacter: CARDINAL = 3;  bitsPerHexCharacter: CARDINAL = 4;  minBitsPerCharacter: CARDINAL = MIN[    bitsPerPSCharacter, bitsPerOctalCharacter, bitsPerHexCharacter];  maxCharsInHostNumber: CARDINAL =    SIZE[System.HostNumber]*Environment.bitsPerWord/minBitsPerCharacter + 1;  maxCharsInNetworkNumber: CARDINAL =    SIZE[System.NetworkNumber]*Environment.bitsPerWord/minBitsPerCharacter + 1;  maxCharsInSocketNumber: CARDINAL =    SIZE[System.SocketNumber]*Environment.bitsPerWord/minBitsPerCharacter + 1;  maxCharsInNetworkAddress: CARDINAL =    maxCharsInNetworkNumber + 1 + maxCharsInHostNumber + 1 +      maxCharsInSocketNumber;  maxDigits: CARDINAL = MAX[    maxCharsInHostNumber, maxCharsInNetworkNumber, maxCharsInSocketNumber];  Digits: TYPE = ARRAY [0..maxDigits) OF CARDINAL;  HostNumber: PUBLIC PROCEDURE [    proc: Format.StringProc, hostNumber: System.HostNumber,    format: Format.NetFormat, clientData: LONG POINTER ¬ NIL] =    BEGIN    temp: STRING = [maxCharsInHostNumber];    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    IF hostNumber = System.broadcastHostNumber THEN String.AppendChar[temp, '*]    ELSE AppendField[temp, @hostNumber, SIZE[System.HostNumber], format];    proc[temp, clientData];    END;  NetworkNumber: PUBLIC PROCEDURE [    proc: Format.StringProc, networkNumber: System.NetworkNumber,    format: Format.NetFormat, clientData: LONG POINTER ¬ NIL] =    BEGIN    temp: STRING = [maxCharsInNetworkNumber];    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    AppendField[temp, @networkNumber, SIZE[System.NetworkNumber], format];    proc[temp, clientData];    END;  SocketNumber: PUBLIC PROCEDURE [    proc: Format.StringProc, socketNumber: System.SocketNumber,    format: Format.NetFormat, clientData: LONG POINTER ¬ NIL] =    BEGIN    temp: STRING = [maxCharsInSocketNumber];    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    AppendField[temp, @socketNumber, SIZE[System.SocketNumber], format];    proc[temp, clientData];    END;  NetworkAddress: PUBLIC PROCEDURE [    proc: Format.StringProc, networkAddress: System.NetworkAddress,    format: Format.NetFormat, clientData: LONG POINTER ¬ NIL] =    BEGIN    temp: STRING = [maxCharsInNetworkAddress];    IF proc = NIL THEN [proc, clientData] ¬ GetDefaults[];    AppendField[temp, @networkAddress.net, SIZE[System.NetworkNumber], format];    String.AppendChar[temp, '.];    IF networkAddress.host = System.broadcastHostNumber THEN      String.AppendChar[temp, '*]    ELSE      AppendField[temp, @networkAddress.host, SIZE[System.HostNumber], format];    String.AppendChar[temp, '.];    AppendField[temp, @networkAddress.socket, SIZE[System.SocketNumber], format];    proc[temp, clientData];    END;  AppendField: PROCEDURE [    s: STRING, data: POINTER, words: CARDINAL, format: Format.NetFormat] =    BEGIN    digits: Digits;    base: CARDINAL;    SELECT format FROM      octal => base ¬ 8;      hex => base ¬ 16;      productSoftware => base ¬ 10;      ENDCASE => ERROR UnrecognizedFormatOption;    ConvertToDigits[data, words, base, @digits];    AppendDigits[s, @digits, base = 10];    IF base = 16 THEN String.AppendChar[s, 'H];    END;  AppendDigits: PROCEDURE [    s: STRING, digits: POINTER TO Digits, dashes: BOOLEAN] =    BEGIN    something: BOOLEAN ¬ FALSE;    FOR i: CARDINAL IN [0..maxDigits) DO      v: CARDINAL ¬ digits[i];      IF dashes AND something AND (maxDigits - i) MOD 3 = 0 THEN        String.AppendChar[s, '-];      IF v # 0 AND ~something THEN        BEGIN        IF dashes THEN          BEGIN          SELECT maxDigits - i FROM            1 => String.AppendString[s, "0-00"L];            2 => String.AppendString[s, "0-0"L];            3 => String.AppendString[s, "0-"L];            ENDCASE => NULL;          END;        IF v > 9 THEN String.AppendChar[s, '0];  -- Leading digit for Hex case        something ¬ TRUE;        END;      IF something THEN        BEGIN        c: CHARACTER ¬ IF v > 9 THEN v - 10 + 'A ELSE v + '0;        String.AppendChar[s, c];        END;      ENDLOOP;    IF ~something THEN      BEGIN      IF FALSE AND dashes THEN String.AppendString[s, "0-00"L];      String.AppendChar[s, '0];      END;    END;  ConvertToDigits: PROCEDURE [    field: POINTER, size, base: CARDINAL, digits: POINTER TO Digits] =    BEGIN    digits­ ¬ ALL[0];    THROUGH [0..size*Environment.bitsPerWord) DO      bit: CARDINAL ¬ ShiftFieldLeft[field, size, 1];      FOR i: CARDINAL DECREASING IN [0..maxDigits) DO        digits[i] ¬ digits[i]*2 + bit;        IF digits[i] >= base THEN BEGIN digits[i] ¬ digits[i] - base; bit ¬ 1; END        ELSE bit ¬ 0;        ENDLOOP;      ENDLOOP;    END;  ShiftFieldLeft: PROCEDURE [data: POINTER, words: CARDINAL, shift: INTEGER]    RETURNS [left: CARDINAL] =    BEGIN    right: WORD ¬ 0;    data ¬ data + words;    THROUGH [0..words) DO      data ¬ data - 1;      left ¬ Inline.BITSHIFT[data­, shift - 16];      data­ ¬ Inline.BITOR[Inline.BITSHIFT[data­, shift], right];      right ¬ left;      ENDLOOP;    END;  -- Mainline Code  END.
-- Copyright (C) 1983, 1984  by Xerox Corporation. All rights reserved. -- TTYImpl.mesa edit by--   LXR    	31-Oct-83 16:09:20  --   RXJ     	 7-Jul-83  0:08:39  DIRECTORY  Ascii USING [    BS, ControlA, ControlQ, ControlR, ControlV, ControlW, ControlX, CR, DEL, FF,    SP, TAB],  Environment USING [Block, Byte],  Format,  Heap USING [systemZone],  Inline USING [HighByte, HighHalf, LowByte, LowHalf],  Process USING [Abort, DisableTimeout, EnableAborts],  Runtime USING [IsBound],  Stream USING [    Delete, EndOfStream, GetChar, GetBlock, Handle, PutBlock, PutByte, PutChar,     SetSST, SubSequenceType],  String USING [    AppendChar, AppendLongNumber, AppendNumber, StringToLongNumber,    StringToNumber, SubString],  Time USING [Packed, TimeZoneStandard],  TTY USING [CharStatus, CreateTTYInstance, DateFormat, EchoClass, NumberFormat],  TTYConstants;TTYImpl: MONITOR LOCKS h USING h: Handle  IMPORTS Format, Heap, Inline, Process, Runtime, Stream, String, TTY EXPORTS TTY  =  BEGIN  Handle: PUBLIC TYPE = LONG POINTER TO Object;  Object: TYPE = MONITORED RECORD [    stream: Stream.Handle ¬ NIL,    echo: TTY.EchoClass ¬ plain,    newline: BOOLEAN ¬ TRUE,    inputAborted: BOOLEAN ¬ FALSE,    next: Handle,    buffer: QHead ¬ Init[],    backingStream: Stream.Handle ¬ NIL,    altStream: AltHandle ¬ NIL,    inputProcess: PROCESS ¬ NIL,    inputCondition: CONDITION];  AltHandle: PUBLIC TYPE = LONG POINTER TO AltObject;  AltObject: TYPE = RECORD [s: Stream.Handle, next: AltHandle];  list: Handle ¬ NIL;  z: UNCOUNTED ZONE = Heap.systemZone;  OutOfInstances: PUBLIC ERROR = CODE;  NoDefaultInstance: PUBLIC ERROR = CODE;  aborted: Environment.Byte = TTYConstants.aborted;  notAborted: Environment.Byte = TTYConstants.notAborted;  normal: Stream.SubSequenceType = TTYConstants.normal;  setBackingSize: Stream.SubSequenceType = TTYConstants.setBackingSize;  removeChars: Stream.SubSequenceType = TTYConstants.removeChars;  blinkDisplay: Stream.SubSequenceType = TTYConstants.blinkDisplay;  Create: PUBLIC PROCEDURE [    name: LONG STRING, backingStream, ttyImpl: Stream.Handle ¬ NIL]    RETURNS [h: Handle] = {    h ¬ z.NEW[      Object ¬ [stream: NIL, backingStream: NIL, next: list]];    IF ttyImpl = NIL THEN      SELECT Runtime.IsBound[LOOPHOLE[TTY.CreateTTYInstance]] FROM        TRUE =>          [ttyImpl, backingStream] ¬ TTY.CreateTTYInstance[name, backingStream, h];        FALSE => ERROR NoDefaultInstance;        ENDCASE;    h.backingStream ¬ backingStream;    h.stream ¬ ttyImpl;    list ¬ h;    Process.DisableTimeout[@h.inputCondition];    Process.EnableAborts[@h.inputCondition];    h.inputProcess ¬ FORK ListenForInput[h]};  Destroy: PUBLIC PROCEDURE [h: Handle, deleteBackingFile: BOOLEAN ¬ FALSE] = {    P: ENTRY PROCEDURE [h: Handle] = {      ENABLE UNWIND => NULL;      IF list = h THEN list ¬ h.next      ELSE        FOR l: Handle ¬ list, l.next UNTIL l.next = NIL DO          IF l.next = h THEN {l.next ¬ l.next.next; EXIT}; ENDLOOP;      IF ~IsEmpty[@h.buffer] THEN Empty[@h.buffer]};    Stream.SetSST[h.stream, TTYConstants.deleteBackingFile];    Stream.SetSST[h.stream, normal];    Process.Abort[h.inputProcess];    JOIN h.inputProcess;    P[h];    Stream.Delete[h.stream];    z.FREE[@h]};  ListenForInput: PROCEDURE [h: Handle] =    BEGIN    DoIt: ENTRY PROCEDURE [h: Handle] = {      ENABLE UNWIND => NULL;      wakeUp: BOOLEAN = IsEmpty[@h.buffer];      BlockToQR[block, @h.buffer];      IF wakeUp THEN BROADCAST h.inputCondition};    AbortClient: ENTRY PROCEDURE [h: Handle] = {      h.inputAborted ¬ TRUE; BROADCAST h.inputCondition};    blockSize: CARDINAL = 20;    block: Environment.Block;    storage: PACKED ARRAY [0..blockSize) OF Environment.Byte;    block ¬ [blockPointer: @storage, startIndex: 0, stopIndexPlusOne:];    DO      block.stopIndexPlusOne ¬ blockSize;      [block.stopIndexPlusOne, , ] ¬ Stream.GetBlock[        h.stream, block ! ABORTED => EXIT];      DoIt[h];      ENDLOOP;    AbortClient[h];    END;  GetEcho: PUBLIC ENTRY PROCEDURE [h: Handle] RETURNS [TTY.EchoClass] = {    ENABLE UNWIND => NULL; InternalCheckState[h]; RETURN[h.echo]};  SetEcho: PUBLIC ENTRY PROCEDURE [h: Handle, new: TTY.EchoClass]    RETURNS [old: TTY.EchoClass] = {    ENABLE UNWIND => NULL; InternalCheckState[h]; old ¬ h.echo; h.echo ¬ new};  CharsAvailable: PUBLIC ENTRY PROCEDURE [h: Handle] RETURNS [CARDINAL] = {    ENABLE UNWIND => NULL; InternalCheckState[h]; RETURN[Count[@h.buffer]];    -- note that this count is incorrect if there are alternate input streams --};  GetChar: PUBLIC ENTRY PROCEDURE [h: Handle] RETURNS [c: CHARACTER] = {    ENABLE UNWIND => NULL;    advanceAltStream: BOOLEAN ¬ FALSE;    temp: AltHandle;    WHILE h.altStream # NIL DO       c ¬ Stream.GetChar[h.altStream.s ! Stream.EndOfStream =>         {advanceAltStream ¬ TRUE; CONTINUE}];      IF ~advanceAltStream THEN RETURN[c];      Stream.Delete[h.altStream.s];      temp ¬ h.altStream; h.altStream ¬ h.altStream.next;      z.FREE[@temp];      advanceAltStream ¬ FALSE;      ENDLOOP;     WHILE IsEmpty[@h.buffer] DO      InternalCheckState[h]; WAIT h.inputCondition ENDLOOP;    c ¬ GetF[@h.buffer]};  PopAlternateInputStreams: PUBLIC ENTRY PROCEDURE [h: Handle, howMany: CARDINAL ¬ 1] =    BEGIN    temp: AltHandle;    FOR i: CARDINAL IN [0..howMany) WHILE h.altStream # NIL DO      Stream.Delete[h.altStream.s];      temp ¬ h.altStream; h.altStream ¬ h.altStream.next;      z.FREE[@temp];      ENDLOOP;    END;      PushAlternateInputStream: PUBLIC ENTRY PROCEDURE [h: Handle, stream: Stream.Handle] =    BEGIN    h.altStream ¬ z.NEW[AltObject ¬ [s: stream, next: h.altStream]];    END;  PutBackChar: PUBLIC ENTRY PROCEDURE [h: Handle, c: CHARACTER] = {    ENABLE UNWIND => NULL; InternalCheckState[h]; PutR[@h.buffer, c];    -- note that this does not work if there are alternate input streams --};  ResetUserAbort: PUBLIC ENTRY PROCEDURE [h: Handle] = {    ENABLE UNWIND => NULL;     InternalCheckState[h]; h.stream.sendAttention[h.stream, notAborted]};  UserAbort: PUBLIC ENTRY PROCEDURE [h: Handle] RETURNS [BOOLEAN] = {    ENABLE UNWIND => NULL;    InternalCheckState[h];    RETURN[      SELECT h.stream.waitAttention[h.stream] FROM        aborted => TRUE,        ENDCASE => FALSE]};  SetUserAbort: PUBLIC ENTRY PROCEDURE [h: Handle] = {    ENABLE UNWIND => NULL;     InternalCheckState[h]; h.stream.sendAttention[h.stream, aborted]};  BlinkDisplay: PUBLIC PROCEDURE [h: Handle] = {    CheckState[h];    Stream.SetSST[h.stream, blinkDisplay];    Stream.SetSST[h.stream, normal]};  NewLine: PUBLIC ENTRY PROCEDURE [h: Handle] RETURNS [BOOLEAN] = {    ENABLE UNWIND => NULL; InternalCheckState[h]; RETURN[h.newline]};  PutChar: PUBLIC PROCEDURE [h: Handle, c: CHARACTER] = {    P: ENTRY PROCEDURE [h: Handle] = {      ENABLE UNWIND => NULL; h.newline ¬ c = Ascii.CR};    CheckState[h];    P[h];    Stream.PutChar[h.stream, c]};  PutLongString, PutString, PutText: PUBLIC PROCEDURE [    h: Handle, s: LONG STRING] = {    P: ENTRY PROCEDURE [h: Handle] = {      ENABLE UNWIND => NULL; h.newline ¬ s[s.length - 1] = Ascii.CR};    CheckState[h];    IF s = NIL THEN RETURN;    Stream.PutBlock[h.stream, [LOOPHOLE[@s.text], 0, s.length]];    P[h]};  RemoveCharacter, RemoveCharacters: PUBLIC PROCEDURE [h: Handle, n: CARDINAL] = {    CheckState[h];    Stream.SetSST[h.stream, removeChars];    Stream.PutByte[h.stream, Inline.HighByte[n]];    Stream.PutByte[h.stream, Inline.LowByte[n]];    Stream.SetSST[h.stream, normal]};  -- Backing Files  NoBackingFile: PUBLIC ERROR = CODE;  BackingStream: PUBLIC PROCEDURE [h: Handle] RETURNS [Stream.Handle] = {    CheckState[h]; RETURN[h.backingStream]};  SetBackingSize: PUBLIC PROCEDURE [h: Handle, size: LONG CARDINAL] = {    lowHalf, highHalf: CARDINAL;    CheckState[h];    highHalf ¬ Inline.HighHalf[size];    lowHalf ¬ Inline.LowHalf[size];    Stream.SetSST[h.stream, setBackingSize];    Stream.PutByte[h.stream, Inline.HighByte[highHalf]];    Stream.PutByte[h.stream, Inline.LowByte[highHalf]];    Stream.PutByte[h.stream, Inline.HighByte[lowHalf]];    Stream.PutByte[h.stream, Inline.LowByte[lowHalf]];    Stream.SetSST[h.stream, normal]};  -- Basic input  GetDecimal: PUBLIC PROCEDURE [h: Handle] RETURNS [INTEGER] = {    s: STRING = [10];    CheckState[h];    [] ¬ GetEditedString[h, s, IsAtom];    RETURN[String.StringToNumber[s, 10]]};  GetID: PUBLIC PROCEDURE [h: Handle, s: LONG STRING] = {    CheckState[h]; [] ¬ GetEditedString[h, s, IsAtom]};  GetLine: PUBLIC PROCEDURE [h: Handle, s: LONG STRING] = {    CheckState[h]; [] ¬ GetEditedString[h, s, IsCR]; PutChar[h, Ascii.CR]};  GetPassword: PUBLIC PROCEDURE [h: Handle, s: LONG STRING] = {    old: TTY.EchoClass;    CheckState[h];    old ¬ SetEcho[h, stars];    IF old = none THEN [] ¬ SetEcho[h, none];    [] ¬ GetEditedString[h, s, IsAtom ! UNWIND => [] ¬ SetEcho[h, old]];    [] ¬ SetEcho[h, old]};  GetLongDecimal: PUBLIC PROCEDURE [h: Handle] RETURNS [n: LONG INTEGER] = {    s: STRING ¬ [32];    CheckState[h];    [] ¬ GetEditedString[h, s, IsAtom];    RETURN[String.StringToLongNumber[s, 10]]};  GetLongNumber: PUBLIC PROCEDURE [    h: Handle, default: LONG UNSPECIFIED, radix: CARDINAL, showDefault: BOOLEAN]    RETURNS [n: LONG UNSPECIFIED] = {    s: STRING ¬ [32];    CheckState[h];    IF showDefault THEN {      IF radix = 10 AND LOOPHOLE[default, LONG INTEGER] < 0 THEN {        s[0] ¬ '-; s.length ¬ 1; default ¬ -default};      String.AppendLongNumber[s, default, radix];      IF radix = 8 THEN String.AppendChar[s, 'B]};    [] ¬ GetEditedString[h, s, IsAtom];    RETURN[String.StringToLongNumber[s, radix]]};  GetLongOctal: PUBLIC PROCEDURE [h: Handle] RETURNS [n: LONG UNSPECIFIED] = {    s: STRING ¬ [32];    CheckState[h];    [] ¬ GetEditedString[h, s, IsAtom];    RETURN[String.StringToLongNumber[s, 8]]};  GetNumber: PUBLIC PROCEDURE [    h: Handle, default: UNSPECIFIED, radix: CARDINAL, showDefault: BOOLEAN]    RETURNS [n: UNSPECIFIED] = {    s: STRING ¬ [10];    CheckState[h];    IF showDefault THEN {      IF radix = 10 AND LOOPHOLE[default, INTEGER] < 0 THEN {        default ¬ -default; s[0] ¬ '-; s.length ¬ 1};      String.AppendNumber[s, default, radix];      IF radix = 8 THEN String.AppendChar[s, 'B]};    [] ¬ GetEditedString[h, s, IsAtom];    RETURN[String.StringToNumber[s, radix]]};  GetOctal: PUBLIC PROCEDURE [h: Handle] RETURNS [n: UNSPECIFIED] = {    s: STRING ¬ [10];    CheckState[h];    [] ¬ GetEditedString[h, s, IsAtom];    RETURN[String.StringToNumber[s, 8]]};  GetString: PUBLIC PROCEDURE [    h: Handle, s: LONG STRING,    t: PROCEDURE [c: CHARACTER] RETURNS [status: TTY.CharStatus]] = {    CheckState[h]; PutChar[h, GetEditedString[h, s, t]]};  LineOverflow: PUBLIC SIGNAL [s: LONG STRING] RETURNS [ns: LONG STRING] = CODE;  Rubout: PUBLIC SIGNAL = CODE;  GetEditedString: PUBLIC PROCEDURE [    h: Handle, s: LONG STRING,    t: PROCEDURE [c: CHARACTER] RETURNS [status: TTY.CharStatus]]    RETURNS [c: CHARACTER] = {    WeirdEcho: PROCEDURE [c: CHARACTER] = {      SELECT GetEcho[h] FROM        none => NULL;        plain => PutChar[h, c];        stars => PutChar[h, '*]        ENDCASE};    WeirdErase: PROCEDURE [c: CHARACTER] = {      SELECT GetEcho[h] FROM        none => NULL;        plain =>          RemoveCharacters[            h,            SELECT c FROM              Ascii.CR, Ascii.BS, Ascii.FF => 0,              IN [0C..Ascii.SP) => 2,              IN [Ascii.SP..'~] => 1,              Ascii.TAB => 1,  -- ARGH!!!!!!              ENDCASE => 0];        stars => RemoveCharacter[h, 1]        ENDCASE};    WeirdPutString: PROCEDURE = INLINE {      FOR i: CARDINAL IN [0..s.length) DO WeirdEcho[s[i]] ENDLOOP};    KillString: PROCEDURE = {      FOR i: CARDINAL DECREASING IN [0..s.length) DO WeirdErase[s[i]] ENDLOOP;      s.length ¬ 0};    firstChar: BOOLEAN ¬ TRUE;    CheckState[h];    WeirdPutString[];  -- show whatever default string is passed in, if any    DO      SELECT t[c ¬ GetChar[h]] FROM        stop => RETURN;        ignore => LOOP;        ok =>          SELECT c FROM            Ascii.DEL => SIGNAL Rubout;            Ascii.ControlA, Ascii.BS =>  -- backspace              IF s.length > 0 THEN WeirdErase[s[s.length ¬ s.length - 1]];            Ascii.ControlW, Ascii.ControlQ => {  -- backword              -- text to be backed up is of the form ...<li><v><ti>, the <v> and <ti>              -- are to be removed.              state: {ti, v, li} ¬ ti;              FOR i: CARDINAL DECREASING IN [0..s.length) DO                SELECT s[i] FROM                  IN ['A..'Z], IN ['a..'z], IN ['0..'9] =>                    IF state = ti THEN state ¬ v;                  ENDCASE => IF state = v THEN state ¬ li;                IF state = li THEN GO TO Done;                WeirdErase[s[i]];                REPEAT Done => s.length ¬ i + 1; FINISHED => s.length ¬ 0;                ENDLOOP};            Ascii.ControlX => KillString[];            Ascii.ControlR => {  -- refresh--              IF GetEcho[h] # none THEN {PutChar[h, Ascii.CR]; WeirdPutString[]};              LOOP};            Ascii.ControlV => {  -- dont parse next char              IF firstChar THEN KillString[];              WHILE s.length >= s.maxlength DO s ¬ SIGNAL LineOverflow[s] ENDLOOP;              WeirdEcho[s[s.length] ¬ c ¬ GetChar[h]];              s.length ¬ s.length + 1};            ENDCASE => {              IF firstChar THEN KillString[];              WHILE s.length >= s.maxlength DO s ¬ SIGNAL LineOverflow[s] ENDLOOP;              WeirdEcho[s[s.length] ¬ c];              s.length ¬ s.length + 1};        ENDCASE;      firstChar ¬ FALSE;      ENDLOOP};  IsAtom: PROCEDURE [c: CHARACTER] RETURNS [TTY.CharStatus] = {    RETURN[IF c = Ascii.SP OR c = Ascii.CR THEN stop ELSE ok]};  IsCR: PROCEDURE [c: CHARACTER] RETURNS [TTY.CharStatus] = {    RETURN[IF c = Ascii.CR THEN stop ELSE ok]};  CheckState: ENTRY PROCEDURE [h: Handle] = INLINE {    ENABLE UNWIND => NULL; IF h.inputAborted THEN ERROR ABORTED};  InternalCheckState: PROCEDURE [h: Handle] = INLINE {    IF h.inputAborted THEN ERROR ABORTED};  -- extended output procedures  OutString: PROCEDURE [s: LONG STRING, clientData: Handle] = {    P: ENTRY PROCEDURE [h: Handle] = {      ENABLE UNWIND => NULL; h.newline ¬ s[s.length - 1] = Ascii.CR};    IF s = NIL THEN RETURN;    Stream.PutBlock[clientData.stream, [LOOPHOLE[@s.text], 0, s.length]];    P[clientData]};  PutBlank, PutBlanks: PUBLIC PROCEDURE [h: Handle, n: CARDINAL] = {    CheckState[h]; Format.Blank[OutString, n, h]};  PutBlock: PUBLIC PROCEDURE [h: Handle, block: Environment.Block] = {    CheckState[h]; Format.Block[OutString, block, h]};  PutDate: PUBLIC PROCEDURE [    h: Handle, gmt: Time.Packed, format: TTY.DateFormat,    zone: Time.TimeZoneStandard] = {    CheckState[h]; Format.Date[OutString, gmt, format, zone, h]};  PutDecimal: PUBLIC PROCEDURE [h: Handle, n: INTEGER] = {    CheckState[h]; Format.Decimal[OutString, n, h]};  PutLine: PUBLIC PROCEDURE [h: Handle, s: LONG STRING] = {    CheckState[h]; PutString[h, s]; PutChar[h, Ascii.CR]};  PutLongDecimal: PUBLIC PROCEDURE [h: Handle, n: LONG INTEGER] = {    CheckState[h]; Format.LongDecimal[OutString, n, h]};  PutLongNumber: PUBLIC PROCEDURE [    h: Handle, n: LONG UNSPECIFIED, format: TTY.NumberFormat] = {    CheckState[h]; Format.LongNumber[OutString, n, format, h]};  PutLongOctal: PUBLIC PROCEDURE [h: Handle, n: LONG UNSPECIFIED] = {    CheckState[h]; Format.LongOctal[OutString, n, h]};  PutNumber: PUBLIC PROCEDURE [    h: Handle, n: UNSPECIFIED, format: TTY.NumberFormat] = {    CheckState[h]; Format.Number[OutString, n, format, h]};  PutOctal: PUBLIC PROCEDURE [h: Handle, n: UNSPECIFIED] = {    CheckState[h]; Format.Octal[OutString, n, h]};  PutLongSubString, PutSubString: PUBLIC PROCEDURE [    h: Handle, ss: String.SubString] = {    CheckState[h]; Format.SubString[OutString, ss, h]};  -- Queue implementation  BYTE: PRIVATE TYPE = [0..255];  Q: TYPE = LONG POINTER TO QHead;  QHead: TYPE = RECORD [front, rear: LONG POINTER TO QElement];  NullQHead: QHead = [NIL, NIL];  QElement: PRIVATE TYPE = RECORD [    flink, rlink: LONG POINTER TO QElement ¬ NIL,    front, rear: CARDINAL ¬ 0,    data: PACKED SEQUENCE maxLen: CARDINAL OF BYTE];  pQE: PRIVATE TYPE = LONG POINTER TO QElement;  defaultElementSize: PRIVATE CARDINAL = 20;  EmptyQ: SIGNAL [q: Q] = CODE;  Count: PROCEDURE [q: Q] RETURNS [elements: CARDINAL ¬ 0] =    BEGIN    IF q = NIL THEN RETURN;    FOR qp: pQE ¬ q.front, qp.flink UNTIL qp = NIL DO      elements ¬        elements +          (IF qp.front > qp.rear THEN qp.maxLen - qp.front + qp.rear + 1           ELSE qp.rear - qp.front + 1);      ENDLOOP;    RETURN    END;  IsEmpty: PROCEDURE [q: Q] RETURNS [BOOLEAN] = {    RETURN[q = NIL OR q.front = NIL]};  Empty: PROCEDURE [q: Q] =    BEGIN    UNTIL IsEmpty[q] DO      qf: pQE ¬ q.front;      nqf: pQE = qf.flink;      z.FREE[@qf];      IF nqf = NIL THEN q.rear ¬ NIL ELSE nqf.rlink ¬ NIL;      q.front ¬ nqf;      ENDLOOP;    RETURN    END;  Init: PROCEDURE RETURNS [QHead] = {RETURN[NullQHead]};  GetF: PROCEDURE [q: Q] RETURNS [i: UNSPECIFIED [0..255]] =    BEGIN    qf: pQE;    qff: CARDINAL;    IF q = NIL OR q.front = NIL THEN {SIGNAL EmptyQ[q]; RETURN[0]};    qf ¬ q.front;    i ¬ qf[qff ¬ qf.front];    IF qf.front = qf.rear THEN      BEGIN  -- element empty      nf: pQE = qf.flink;      IF nf = NIL THEN q.rear ¬ NIL ELSE nf.rlink ¬ NIL;      z.FREE[@qf];      q.front ¬ nf;      END    ELSE      BEGIN qff ¬ IF qff = qf.maxLen - 1 THEN 0 ELSE qff + 1; qf.front ¬ qff; END;    RETURN    END;  GetR: PROCEDURE [q: Q] RETURNS [i: UNSPECIFIED [0..255]] =    BEGIN    qr: pQE;    qrr: CARDINAL;    IF q = NIL OR q.rear = NIL THEN {SIGNAL EmptyQ[q]; RETURN[0]};    qr ¬ q.rear;    i ¬ qr[qrr ¬ qr.rear];    IF qr.rear = qr.front THEN      BEGIN  -- element empty      nr: pQE = qr.rlink;      IF nr = NIL THEN q.front ¬ NIL ELSE nr.flink ¬ NIL;      z.FREE[@qr];      q.rear ¬ nr;      END    ELSE      BEGIN qrr ¬ IF qrr = 0 THEN qr.maxLen - 1 ELSE qrr - 1; qr.rear ¬ qrr; END;    RETURN    END;  PutR: PROCEDURE [q: Q, i: UNSPECIFIED [0..255]] =    BEGIN    qr: pQE;    qrr: CARDINAL;    IF q = NIL THEN RETURN;    qr ¬ q.rear;    IF qr = NIL OR FullElement[qr] THEN      BEGIN      nr: pQE ¬ z.NEW[QElement [defaultElementSize]];      nr.rlink ¬ qr;      IF qr = NIL THEN q.front ¬ nr ELSE qr.flink ¬ nr;      q.rear ¬ qr ¬ nr;      qrr ¬ 0;      END    ELSE qrr ¬ IF qr.rear = qr.maxLen - 1 THEN 0 ELSE qr.rear + 1;    qr[qrr] ¬ i;    qr.rear ¬ qrr;    RETURN    END;  BlockToQR: PROCEDURE [block: Environment.Block, q: Q] =    BEGIN    FOR i: CARDINAL IN [block.startIndex..block.stopIndexPlusOne) DO      PutR[q, block.blockPointer[i]] ENDLOOP;    END;  FullElement: PROCEDURE [qe: pQE] RETURNS [BOOLEAN] = {    OPEN qe;    RETURN[      (IF rear < front THEN maxLen + rear - front ELSE rear - front) =        maxLen - 1]};  END....
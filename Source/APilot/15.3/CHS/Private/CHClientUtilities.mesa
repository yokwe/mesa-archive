-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- CHClientUtilities.mesa--last edited by Gealy,  17-Feb-84 13:22:09--last edited by AOF,  17-Dec-84 10:39:49DIRECTORY  Auth USING [    CallError, CallProblem, IdentityHandle, Initiate, nullHostNumber, Terminate],  ByteBlt USING [StartIndexGreaterThanStopIndexPlusOne],  CH USING [Buffer, BufferArea, ConversationHandle, NameRecord, NameStreamProc],  CHSwitches USING [doStubDebug],  Courier USING [Parameters, SerializeParameters, DeserializeParameters, Error],  Environment USING [Block, Byte, bytesPerWord],  Heap USING [Handle, systemZone],  Inline USING [LowHalf],  MemoryStream USING [Create, Destroy, GetIndex, IndexOutOfRange],  NSName USING [SizeOfSerializedData],  NSString USING [nullString, StringFromMesaString],  SharedKeys USING [chsName],  Stream USING [Handle];CHClientUtilities: PROGRAM  IMPORTS    Auth, ByteBlt, Courier, Heap, Inline, MemoryStream, NSName,    NSString, SharedKeys  EXPORTS CH =  BEGIN  doDebug: BOOLEAN = CHSwitches.doStubDebug;    DeserializeFromBlock: PUBLIC PROCEDURE [parms: Courier.Parameters, heap: Heap.Handle, blk: Environment.Block] RETURNS [succeeded: BOOLEAN ¬ TRUE] =    BEGIN    sH: Stream.Handle ¬ MemoryStream.Create[blk];    Courier.DeserializeParameters[parms, sH, heap !      Courier.Error => { succeeded ¬ FALSE; CONTINUE };      MemoryStream.IndexOutOfRange => { succeeded ¬ FALSE; CONTINUE };      ByteBlt.StartIndexGreaterThanStopIndexPlusOne => {succeeded ¬ FALSE; CONTINUE};      UNWIND => MemoryStream.Destroy[sH] ];    MemoryStream.Destroy[sH];    END;  MakeConversationHandle: PUBLIC PROCEDURE [    identity: Auth.IdentityHandle, heap: UNCOUNTED ZONE]    RETURNS [      conversation: CH.ConversationHandle ¬ [NIL, NIL], ok: BOOLEAN ¬ TRUE,      authCallError: Auth.CallProblem ¬ LAST[Auth.CallProblem]] =    BEGIN    conversation ¬ [      Auth.Initiate[identity, SharedKeys.chsName, Auth.nullHostNumber, heap !      Auth.CallError => {ok ¬ FALSE; authCallError ¬ reason; CONTINUE}], NIL];    END;  FreeConversationHandle: PUBLIC PROCEDURE [    conversation: LONG POINTER TO CH.ConversationHandle, heap: UNCOUNTED ZONE] =    BEGIN    Auth.Terminate[@conversation.conversation, heap];    --conversation.conversation ¬ NIL as a side effect of Terminate.    END;  ShowDefaultName: PUBLIC PROCEDURE [theName: CH.NameStreamProc] =    BEGIN    localName: STRING ¬ "MailDrops"L;    domainName: STRING ¬ "System"L;    theNameRecord: CH.NameRecord ¬ [      org: NSString.nullString, domain: NSString.StringFromMesaString[domainName],      local: NSString.StringFromMesaString[localName]];    theName[@theNameRecord];    END;  MakeRhs: PUBLIC PROCEDURE [maxlength: CARDINAL, heap: Heap.Handle]    RETURNS [rhs: CH.Buffer] =    -- Returns a buffer whose maxlength is maxlength; length is zero.    -- User is responsible for the allocated memory.    BEGIN    rhs ¬ heap.NEW[CH .BufferArea[maxlength]];    rhs.length ¬ 0;    rhs.maxlength ¬ maxlength;    END;  FreeRhs: PUBLIC PROCEDURE [rhs: CH.Buffer, heap: Heap.Handle] =    -- This is where the user user gets rid of the Buffers he is responsible for.    BEGIN rhs.length ¬ rhs.maxlength ¬ 0; heap.FREE[@rhs]; END;  SerializeIntoRhs: PUBLIC PROCEDURE [parms: Courier.Parameters, heap: Heap.Handle]    RETURNS [rhs: CH.Buffer] =    -- Returns a buffer whose length and maxlength are set the exact number    -- of words needed to hold the serialized "parameters".  The    -- "parameters" are then serialized into the buffer.  User is responsible    -- for the allocated memory.    BEGIN    sH: Stream.Handle;    byteLength: LONG CARDINAL;    dataWordLength: CARDINAL = NSName.SizeOfSerializedData[parms];    rhs ¬ MakeRhs[maxlength: dataWordLength, heap: heap];    sH ¬ MemoryStream.Create[      [LOOPHOLE[@rhs.data], 0, Environment.bytesPerWord * dataWordLength]];    Courier.SerializeParameters[      parms, sH !      UNWIND => BEGIN MemoryStream.Destroy[sH]; FreeRhs[rhs, heap]; END];    byteLength ¬ MemoryStream.GetIndex[sH];    MemoryStream.Destroy[sH];    rhs.length ¬      (Inline.LowHalf[byteLength] + Environment.bytesPerWord - 1) /        Environment.bytesPerWord;    IF doDebug AND rhs.length # rhs.maxlength THEN ERROR;    END;  ScopedSerializeIntoRhs: PUBLIC PROCEDURE [    parms: Courier.Parameters, callback: PROCEDURE [CH.Buffer]] =    -- Like SerializeIntoRhs, except that the user is called back with the rhs,    -- which is allocated from the system heap.  The rhs is deallocated upon    -- return from callback or via UNWIND.    BEGIN    rhs: CH.Buffer = SerializeIntoRhs[parms, Heap.systemZone];    callback[rhs ! UNWIND => FreeRhs[rhs, Heap.systemZone]];    FreeRhs[rhs, Heap.systemZone];    END;  END..LOG13-Dec-82  9:33:41 - BLyon23-Nov-83 15:51:33 - Gealy - Added MakeConversation and Conversation  3-Jan-84 17:11:43 - Gealy - 8.0d Auth 17-Feb-84 13:22:34 - Gealy - CONTINUE from Auth.CallError in MakeConversationHandle 
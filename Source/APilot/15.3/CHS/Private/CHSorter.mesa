-- File: CHSorter.mesa - last edit:-- AOF                 22-Apr-85  8:17:02-- Last edit, mweeks       18-Apr-85 14:08:42-- Copyright (C) 1983, 1984, 1985  by Xerox Corporation. All rights reserved. DIRECTORY  CH USING [Element, NameRecord, NameStreamProc, zeroMaxLengthNames],  CHSwitches USING [doStubDebug],  Environment USING [wordsPerPage],  Heap USING [Create, Delete, Flush],  IncrementalSortExtras,  IncrementalSort USING [],  NSName USING [CompareNames, Name],  NSString USING [AppendString, nullString, WordsForString],  NSStringExtras USING [EquivalentNames];    CHSorter: MONITOR  IMPORTS CH, Heap, NSName, NSString, NSStringExtras   EXPORTS IncrementalSort, IncrementalSortExtras  =  BEGIN  Handle: PUBLIC TYPE = LONG POINTER TO Object;  Object: TYPE = RECORD [    root: Root,    lastNode: Root,  -- used only if elementsAreAlreadyInOrder    elementsAreAlreadyInOrder: BOOLEAN,    ignoreOrg, ignoreDomain, ignoreLocal: BOOLEAN,    nodeCount: CARDINAL,    heap: UNCOUNTED ZONE,    userOwnsHeap: BOOLEAN,    destroyerCount: CARDINAL];  Root: PUBLIC TYPE = LONG POINTER TO TreeNode;  TreeNode: TYPE = RECORD [    balanceFactor: INTEGER [-1..1],  -- height of right branch minus height of left branch    leftBranch: Root,    rightBranch: Root,    userData: LONG UNSPECIFIED,    name: CH.NameRecord,    namesBodys: SEQUENCE COMPUTED CARDINAL OF WORD];  EachNodeProc: PUBLIC TYPE = PROCEDURE [    currentName: CH.Element, userData: LONG UNSPECIFIED];       doDebug: BOOLEAN = CHSwitches.doStubDebug;  heapChecking: BOOLEAN ¬ FALSE;  balanceTreeProblem: ERROR = CODE;  retainedHeapCount: CARDINAL = 10;  retainedHeap: ARRAY [0..retainedHeapCount) OF UNCOUNTED ZONE;  FindParent: SIGNAL    RETURNS [currentParent: Root, inWhichTree: INTEGER [-1..1] ¬ -1] = CODE;  debugTree: BOOLEAN ¬ FALSE;  GetElementCount: PUBLIC PROCEDURE [h: Handle] RETURNS [count: CARDINAL] =    BEGIN count ¬ h.nodeCount; END;  GetAHeap: ENTRY PROCEDURE RETURNS [h: UNCOUNTED ZONE] =    BEGIN    FOR i: CARDINAL IN [0..retainedHeapCount) DO      IF retainedHeap[i] # NIL THEN        BEGIN h ¬ retainedHeap[i]; retainedHeap[i] ¬ NIL; RETURN; END;      ENDLOOP;    h ¬ Heap.Create[      initial: 4, increment: 20, swapUnitSize: 4,      ownerChecking: doDebug, checking: doDebug AND heapChecking,      largeNodeThreshold: Environment.wordsPerPage];    END;  ReleaseAHeap: ENTRY PROCEDURE [h: LONG POINTER TO Handle] =    BEGIN    theHeap: UNCOUNTED ZONE = h.heap;    h.heap ¬ NIL;    --IF doDebug AND (h.nodeCount # 0 OR h.root # NIL) THEN ERROR;    h­ ¬ NIL;    FOR i: CARDINAL IN [0..retainedHeapCount) DO      IF retainedHeap[i] = NIL THEN        BEGIN        retainedHeap[i] ¬ theHeap;	Heap.Flush[theHeap];  --outstanding node refs left dangling!        RETURN;        END;      ENDLOOP;    Heap.Delete[theHeap];    END;  MakeATwig: ENTRY PROCEDURE [    h: Handle, name: CH.Element, userData: LONG UNSPECIFIED] RETURNS [r: Root] =    BEGIN    currentWordsIndex: CARDINAL ¬ 0;    wordsNeeded: CARDINAL ¬ 0;  -- number of Words needed    IF NOT h.ignoreOrg THEN wordsNeeded ¬ NSString.WordsForString[name.org.length];    IF NOT h.ignoreDomain THEN      wordsNeeded ¬ wordsNeeded + NSString.WordsForString[name.domain.length];    IF NOT h.ignoreLocal THEN      wordsNeeded ¬ wordsNeeded + NSString.WordsForString[name.local.length];    r ¬ h.heap.NEW[TreeNode [wordsNeeded]];    r.balanceFactor ¬ 0;    r.leftBranch ¬ r.rightBranch ¬ NIL;    r.userData ¬ userData;    IF h.ignoreOrg THEN BEGIN r.name.org ¬ NSString.nullString; END    ELSE      BEGIN      r.name.org ¬ [        LOOPHOLE[@r.namesBodys[currentWordsIndex]], 0, name.org.length];      r.name.org ¬ NSString.AppendString[r.name.org, name.org];      currentWordsIndex ¬        currentWordsIndex + NSString.WordsForString[name.org.length];      END;    IF h.ignoreDomain THEN BEGIN r.name.domain ¬ NSString.nullString; END    ELSE      BEGIN      r.name.domain ¬ [        LOOPHOLE[@r.namesBodys[currentWordsIndex]], 0, name.domain.length];      r.name.domain ¬ NSString.AppendString[r.name.domain, name.domain];      currentWordsIndex ¬        currentWordsIndex + NSString.WordsForString[name.domain.length];      END;    IF h.ignoreLocal THEN BEGIN r.name.local ¬ NSString.nullString; END    ELSE      BEGIN      r.name.local ¬ [        LOOPHOLE[@r.namesBodys[currentWordsIndex]], 0, name.local.length];      r.name.local ¬ NSString.AppendString[r.name.local, name.local];      IF doDebug THEN        currentWordsIndex ¬          currentWordsIndex + NSString.WordsForString[name.local.length];      END;    h.nodeCount ¬ h.nodeCount + 1;    IF doDebug AND currentWordsIndex # wordsNeeded THEN ERROR;    END;  DestroyATwig: ENTRY PROCEDURE [h: Handle, r: Root] =    BEGIN    IF doDebug AND h.nodeCount = 0 THEN ERROR;    r.leftBranch ¬ r.rightBranch ¬ NIL;    IF r = h.root THEN h.root ¬ NIL;    h.heap.FREE[@r];    h.nodeCount ¬ h.nodeCount - 1;    END;  MakeSorter: PUBLIC PROCEDURE [    elementsAreAlreadyInOrder: BOOLEAN,    ignoreOrg, ignoreDomain, ignoreLocal: BOOLEAN, z: UNCOUNTED ZONE ¬ NIL]    RETURNS [h: Handle] =    BEGIN    heap: UNCOUNTED ZONE ¬ IF z = NIL THEN GetAHeap[] ELSE z;    h ¬ heap.NEW[Object];    h­ ¬ [      NIL, NIL, elementsAreAlreadyInOrder, ignoreOrg, ignoreDomain, ignoreLocal, 0,      heap, IF z = NIL THEN FALSE ELSE TRUE, 0];    END;    GetHeapParameters:PUBLIC PROCEDURE [ h: Handle]     RETURNS [heap: UNCOUNTED ZONE ¬ NIL, userOwnsHeap:BOOLEAN ¬ FALSE]=    {RETURN[h­.heap ,h­.userOwnsHeap]};      UpOrDown: TYPE = {up, down};  Destroy: PUBLIC PROCEDURE [h: LONG POINTER TO Handle] =    BEGIN    heap: UNCOUNTED ZONE;    BumpDestroyerCount: ENTRY PROCEDURE =       INLINE {h.destroyerCount ¬ h.destroyerCount + 1; };          IF h­ = NIL THEN RETURN;    BumpDestroyerCount[];        IF h.destroyerCount > 1 THEN RETURN;    heap ¬ h.heap;    IF h.userOwnsHeap THEN {      DumpTree[h­, h.root, NullCallBack, TRUE]; heap.FREE[h]; h­ ¬ NIL }    ELSE ReleaseAHeap[h];    END;  NullCallBack: PROCEDURE [CH.Element] = {};    ValidateTree: PROCEDURE [tree: Handle] =    BEGIN        InternalValidate: PROCEDURE [root: Root] RETURNS [maxHeight: CARDINAL] =      BEGIN      currentRoot: Root ¬ root;      leftHeight, rightHeight: INTEGER;      IF root = NIL THEN RETURN[0];      leftHeight ¬ 1 + InternalValidate[root.leftBranch];      rightHeight ¬ 1 + InternalValidate[root.rightBranch];      IF (leftHeight - rightHeight = 1 AND root.balanceFactor = -1) OR         (leftHeight = rightHeight AND root.balanceFactor = 0) OR	 (leftHeight - rightHeight = -1 AND root.balanceFactor = 1)	 THEN RETURN[IF leftHeight>rightHeight THEN leftHeight ELSE rightHeight]	 ELSE ERROR;      END;        IF tree = NIL THEN RETURN;      [] ¬ InternalValidate[tree.root];    END;  DumpElements: PUBLIC PROCEDURE [    h: Handle, eachElement: CH.NameStreamProc ¬ NIL,    userSpecifiedDefaults: NSName.Name ¬ NIL, dumpDataAlso: BOOLEAN ¬ FALSE,    eachElementWithData: EachNodeProc ¬ NIL] =    BEGIN DumpTree[h, h.root, eachElement, FALSE, userSpecifiedDefaults, dumpDataAlso, eachElementWithData]; END;  DumpTree: PROCEDURE [    h: Handle, root: Root, eachElement: CH.NameStreamProc, deleteTheTree: BOOLEAN,    userSpecifiedDefaults: NSName.Name ¬ NIL, dumpDataAlso: BOOLEAN ¬ FALSE,    eachElementWithData: EachNodeProc ¬ NIL] =    BEGIN    anElementRecord: CH.NameRecord ¬      IF userSpecifiedDefaults # NIL THEN userSpecifiedDefaults­      ELSE CH.zeroMaxLengthNames­;    rightBranch: Root ¬ root;    currentRoot: Root;    WHILE rightBranch # NIL DO      currentRoot ¬ rightBranch;      rightBranch ¬ rightBranch.rightBranch;      IF currentRoot.leftBranch # NIL THEN        DumpTree[	  h, currentRoot.leftBranch, eachElement, deleteTheTree,	  userSpecifiedDefaults, dumpDataAlso, eachElementWithData];      IF deleteTheTree THEN DestroyATwig[h, currentRoot]      ELSE        BEGIN        IF NOT h.ignoreOrg THEN anElementRecord.org ¬ currentRoot.name.org;        IF NOT h.ignoreDomain THEN anElementRecord.domain ¬ currentRoot.name.domain;        IF NOT h.ignoreLocal THEN anElementRecord.local ¬ currentRoot.name.local;	IF NOT dumpDataAlso THEN          eachElement[@anElementRecord]	ELSE eachElementWithData[@anElementRecord, currentRoot.userData];        END;      ENDLOOP;    END;  FindElement: PUBLIC PROCEDURE [    h: Handle, name: CH.Element,    ignoreOrg, ignoreDomain, ignoreLocal: BOOLEAN]    RETURNS [e: CH.Element, userData: LONG UNSPECIFIED, node: Root] =    BEGIN    currentElement: Root ¬ h.root;    IF h.elementsAreAlreadyInOrder THEN      WHILE currentElement # NIL AND ~NSStringExtras.EquivalentNames[      name, @currentElement.name, ignoreLocal, ignoreDomain, ignoreOrg] DO        currentElement ¬ currentElement.rightBranch;	ENDLOOP      ELSE WHILE currentElement # NIL DO        SELECT NSName.CompareNames[        name, @currentElement.name, ignoreOrg, ignoreDomain,        ignoreLocal] FROM          equal => EXIT;          less => currentElement ¬ currentElement.leftBranch;          ENDCASE => currentElement ¬ currentElement.rightBranch;        ENDLOOP;    e ¬ IF currentElement = NIL THEN NIL ELSE @currentElement.name;    userData ¬ IF currentElement = NIL THEN LONG[NIL] ELSE currentElement.userData;    node ¬ currentElement;    END;  AddElement: PUBLIC PROCEDURE [    h: Handle, e: CH.Element, userData: LONG UNSPECIFIED ¬ LONG[NIL]]     RETURNS [node: Root] =    BEGIN    twig: Root;    IF h.elementsAreAlreadyInOrder THEN      BEGIN      node ¬ twig ¬ MakeATwig[h, e, userData];      IF h.root = NIL THEN h.root ¬ twig ELSE h.lastNode.rightBranch ¬ twig;      h.lastNode ¬ twig;      END    ELSE node ¬ AddElementToBalancedTree[h, e, userData];    END;  -- see Balanced Trees, section 6.2.3 of Knuth "Sorting and Searching"   -- (Vol 3), page 451 - 464.  AddElementToBalancedTree: PROCEDURE [    h: Handle, s: CH.Element, userData: LONG UNSPECIFIED] RETURNS [    node: Root] =    BEGIN    a: INTEGER [-1..1];  -- used in balancing act    temp, currentRoot, rebalanceRoot, rebalanceFather: Root ¬ NIL;    twig: Root ¬ MakeATwig[h, s, userData];    node ¬ twig;    -- special case - the very first node?    IF h.root = NIL THEN BEGIN h.root ¬ twig; RETURN; END;    currentRoot ¬ rebalanceRoot ¬ h.root;    -- search    DO      SELECT NSName.CompareNames[      @twig.name, @currentRoot.name, h.ignoreOrg, h.ignoreDomain, h.ignoreLocal]      FROM        less =>          BEGIN          temp ¬ currentRoot.leftBranch;          IF temp = NIL THEN BEGIN currentRoot.leftBranch ¬ twig; EXIT; END;          IF temp.balanceFactor # 0 THEN            BEGIN rebalanceFather ¬ currentRoot; rebalanceRoot ¬ temp; END;          currentRoot ¬ temp;          LOOP;          END;        greater =>          BEGIN          temp ¬ currentRoot.rightBranch;          IF temp = NIL THEN BEGIN currentRoot.rightBranch ¬ twig; EXIT; END;          IF temp.balanceFactor # 0 THEN            BEGIN rebalanceFather ¬ currentRoot; rebalanceRoot ¬ temp; END;          currentRoot ¬ temp;          LOOP;          END;        ENDCASE => { --equal-- currentRoot.userData ¬ twig.userData;	                       node ¬ currentRoot;	                       DestroyATwig[h, twig]; RETURN}      ENDLOOP;    -- adjust balance factor.    SELECT NSName.CompareNames[    @twig.name, @rebalanceRoot.name, h.ignoreOrg, h.ignoreDomain, h.ignoreLocal]    FROM      less => {a ¬ -1; temp ¬ currentRoot ¬ rebalanceRoot.leftBranch};      ENDCASE => {a ¬ 1; temp ¬ currentRoot ¬ rebalanceRoot.rightBranch};    UNTIL currentRoot = twig DO      SELECT NSName.CompareNames[      @twig.name, @currentRoot.name, h.ignoreOrg, h.ignoreDomain, h.ignoreLocal]      FROM        less => {          currentRoot.balanceFactor ¬ -1;          currentRoot ¬ currentRoot.leftBranch;          LOOP};        greater => {          currentRoot.balanceFactor ¬ 1;          currentRoot ¬ currentRoot.rightBranch;          LOOP};        ENDCASE => ERROR;      ENDLOOP;    -- balancing act    SELECT rebalanceRoot.balanceFactor FROM      0 =>        BEGIN        -- the tree has grown higher        rebalanceRoot.balanceFactor ¬ a;        RETURN;        END;      -a =>        BEGIN        -- the tree has gotten more balanced        rebalanceRoot.balanceFactor ¬ 0;        RETURN;        END;      ENDCASE => NULL;  -- continues    -- the tree is now out of balance.  temp in now a son of rebalanceRoot.    SELECT temp.balanceFactor FROM      a =>        BEGIN        -- single rotation        currentRoot ¬ temp;        SingleRotate[rebalanceRoot, temp, a];        END;      -a => currentRoot ¬ DoubleRotate[rebalanceRoot, temp, a];      ENDCASE => NULL;    -- Finishing touch    -- currentRoot is pointing at the new rebalanced subtree and    -- rebalanceFather is pointing at the father of the old rebalanced root.    ConnectRebalancedSubtreeToTree[h, rebalanceFather, rebalanceRoot, currentRoot];    END;  SetLink: PROCEDURE [node: Root, leftOrRight: INTEGER [-1..1], link: Root] =    BEGIN    SELECT leftOrRight FROM      -1 => node.leftBranch ¬ link;      1 => node.rightBranch ¬ link;      ENDCASE => ERROR;    END;  GetLink: PROCEDURE [node: Root, leftOrRight: INTEGER [-1..1]]    RETURNS [link: Root] =    BEGIN    SELECT leftOrRight FROM      -1 => RETURN[node.leftBranch];      1 => RETURN[node.rightBranch];      ENDCASE => ERROR;    END;  SingleRotate: PROCEDURE [root, child: Root, whichTree: INTEGER [-1..1]] =    BEGIN    SetLink[root, whichTree, GetLink[child, -whichTree]];    SetLink[child, -whichTree, root];    root.balanceFactor ¬ child.balanceFactor ¬ 0;    END;  DoubleRotate: PROCEDURE [root, child: Root, whichTree: INTEGER [-1..1]]    RETURNS [currentRoot: Root] =    BEGIN    currentRoot ¬ GetLink[child, -whichTree];    SetLink[child, -whichTree, GetLink[currentRoot, whichTree]];    SetLink[currentRoot, whichTree, child];    SetLink[root, whichTree, GetLink[currentRoot, -whichTree]];    SetLink[currentRoot, -whichTree, root];    SELECT currentRoot.balanceFactor FROM      whichTree => {root.balanceFactor ¬ -whichTree; child.balanceFactor ¬ 0};      0 => {root.balanceFactor ¬ child.balanceFactor ¬ 0};      ENDCASE => {root.balanceFactor ¬ 0; child.balanceFactor ¬ whichTree};    currentRoot.balanceFactor ¬ 0;    END;  ConnectRebalancedSubtreeToTree: PROCEDURE [    h: Handle, parent, oldRoot, newRoot: Root] =    BEGIN    IF parent = NIL THEN      BEGIN      IF oldRoot = h.root THEN h.root ¬ newRoot ELSE ERROR balanceTreeProblem;      END    ELSE      BEGIN      IF oldRoot = parent.rightBranch THEN parent.rightBranch ¬ newRoot      ELSE parent.leftBranch ¬ newRoot;      END;    END;  DeleteFromList: PROCEDURE [h: Handle, e: CH.Element] =    -- deletes an element from a linked list of names    BEGIN    searchingPtr, trailingPtr, nodeToFree: Root;    searchingPtr ¬ trailingPtr ¬ h.root;    IF NSStringExtras.EquivalentNames[      e, @searchingPtr.name, h.ignoreLocal, h.ignoreDomain, h.ignoreOrg]      THEN BEGIN        nodeToFree ¬ searchingPtr;        h.root ¬ searchingPtr.rightBranch;	DestroyATwig[h, nodeToFree];	END    ELSE      BEGIN      WHILE (searchingPtr ¬ searchingPtr.rightBranch) # NIL        AND ~NSStringExtras.EquivalentNames[          e, @searchingPtr.name, h.ignoreLocal, h.ignoreDomain, h.ignoreOrg]        DO trailingPtr ¬ trailingPtr.rightBranch; ENDLOOP;      IF searchingPtr # NIL THEN        BEGIN	nodeToFree ¬ searchingPtr;        trailingPtr.rightBranch ¬ searchingPtr.rightBranch;	DestroyATwig[h, nodeToFree];        END;      END;    END;  SwapNodeToDeleteWithLeaf: PROCEDURE [    h: Handle, root, parentOfNodeToDelete, nodeToDelete: Root,    treeOfNodeToDelete: INTEGER [-1..1]] RETURNS [promotedLeaf: Root] =    BEGIN    promotedLeaf ¬ root.leftBranch;    root.leftBranch ¬ promotedLeaf.rightBranch;    IF nodeToDelete # h.root THEN      SetLink[parentOfNodeToDelete, treeOfNodeToDelete, promotedLeaf]    ELSE h.root ¬ promotedLeaf;    promotedLeaf.rightBranch ¬ nodeToDelete.rightBranch;    promotedLeaf.leftBranch ¬ nodeToDelete.leftBranch;    promotedLeaf.balanceFactor ¬ nodeToDelete.balanceFactor;    DestroyATwig[h, nodeToDelete];    END;  DeleteElement: PUBLIC PROCEDURE [h: Handle, e: CH.Element] =    BEGIN    nodeFound, mustFindLeaf, balanced, deletionDone: BOOLEAN ¬ FALSE;    whichSide, treeOfNodeToDelete: INTEGER [-1..1] ¬ -1;    nodeToDelete, parentOfNodeToDelete, promotedLeaf: Root ¬ NIL;    deletionFinished: SIGNAL = CODE;        DeleteInCase1: PROCEDURE [h: Handle, nodeToDelete: Root] =      -- this procedure is called when the node must be deleted from a balanced      -- tree and nodeToBeDeleted.rightBranch is NIL.  In this case, the node can      -- be removed from the tree without further ado.      BEGIN      parent: Root;      inThisTree: INTEGER [-1..1];      [parent, inThisTree] ¬ SIGNAL FindParent;      IF nodeToDelete # h.root THEN        SetLink[parent, inThisTree, nodeToDelete.leftBranch]      ELSE h.root ¬ nodeToDelete.leftBranch;      DestroyATwig[h, nodeToDelete];      END;    DeleteInCase2: PROCEDURE [h: Handle, nodeToDelete: Root]      RETURNS [isBalanced: BOOLEAN ¬ FALSE] =      -- this procedure is called when the node must be deleted from a balanced      -- tree and nodeToBeDeleted.rightBranch.leftBranch is NIL.  In this case,      -- nodeToBeDeleted.rightBranch takes the place of nodeToBeDeleted in the      -- tree (if nodeToBeDeleted has a left subtree, it is attached to       -- nodeToBeDeleted.rightBranch).  After the deletion, the subtree rooted at      -- nodeToBeDeleted.rightBranch may be out of balance, so rebalancing is      -- done.      BEGIN      parent, currentNode: Root;      inThisTree: INTEGER [-1..1];      [parent, inThisTree] ¬ SIGNAL FindParent;      SELECT nodeToDelete FROM        # h.root =>          BEGIN          SetLink[parent, inThisTree, nodeToDelete.rightBranch];          currentNode ¬ GetLink[parent, inThisTree];          IF currentNode # NIL THEN            BEGIN            currentNode.leftBranch ¬ nodeToDelete.leftBranch;            currentNode.balanceFactor ¬ nodeToDelete.balanceFactor;            END;          isBalanced ¬ RebalanceAfterDeletion[h, currentNode, 1];          END;        = h.root =>          BEGIN          nodeToDelete.rightBranch.leftBranch ¬ h.root.leftBranch;          h.root ¬ nodeToDelete.rightBranch;          h.root.balanceFactor ¬ nodeToDelete.balanceFactor;          isBalanced ¬ RebalanceAfterDeletion[h, h.root, inThisTree];          END;        ENDCASE;      DestroyATwig[h, nodeToDelete];      END;        RebalanceAfterDeletion: PROCEDURE [      h: Handle, root: Root, whichTree: INTEGER [-1..1]]      RETURNS [balanced: BOOLEAN ¬ FALSE] =      BEGIN      child, parent, currentRoot: Root ¬ NIL;      IF root = NIL THEN RETURN[balanced ¬ TRUE];      SELECT root.balanceFactor FROM        = whichTree => BEGIN root.balanceFactor ¬ 0; RETURN; END;        = 0 => 	  BEGIN root.balanceFactor ¬ -whichTree; RETURN[balanced ¬ TRUE]; END;      ENDCASE => NULL;      [parent,] ¬ SIGNAL FindParent;      IF parent = nodeToDelete THEN parent ¬ promotedLeaf;      child ¬ IF whichTree = 1 THEN root.leftBranch ELSE root.rightBranch;      IF child = NIL THEN BEGIN root.balanceFactor ¬ 0; RETURN; END;      SELECT child.balanceFactor FROM        -whichTree =>          BEGIN currentRoot ¬ child; SingleRotate[root, child, -whichTree]; END;        whichTree => currentRoot ¬ DoubleRotate[root, child, -whichTree];        0 =>          BEGIN          currentRoot ¬ child;          SingleRotate[root, child, -whichTree];          child ¬ GetLink[currentRoot, whichTree];          child.balanceFactor ¬ IF whichTree = 1 THEN -1 ELSE 1;          currentRoot.balanceFactor ¬ IF whichTree = 1 THEN 1 ELSE -1;          ConnectRebalancedSubtreeToTree[h, parent, root, currentRoot];          RETURN[balanced ¬ TRUE];          END;        ENDCASE;      ConnectRebalancedSubtreeToTree[h, parent, root, currentRoot];      END;    DeleteFromBalancedTree: PROCEDURE [root: Root, e: CH.Element] =      -- this procedure is recursive to keep a path from the root of the tree to      -- the node that is deleted. See Knuth Volume 3, Section 6.2.2 for the      -- deletion algorithm and pages 465-466 for an outline of the rebalancing      -- procedure.      BEGIN      thisTree: INTEGER [-1..1];      freeNode: Root ¬ NIL;      IF root # NIL AND ~nodeFound THEN        SELECT NSName.CompareNames[        e, @root.name, h.ignoreOrg, h.ignoreDomain, h.ignoreLocal] FROM          less =>            BEGIN            thisTree ¬ -1;            DeleteFromBalancedTree[              root.leftBranch, e !              FindParent => RESUME [currentParent ¬ root, inWhichTree ¬ thisTree]];            END;          greater =>            BEGIN            thisTree ¬ 1;            DeleteFromBalancedTree[              root.rightBranch, e !              FindParent => RESUME [currentParent ¬ root, inWhichTree ¬ thisTree]];            END;          ENDCASE => {            nodeFound ¬ TRUE;            nodeToDelete ¬ root;            [parentOfNodeToDelete, treeOfNodeToDelete] ¬ SIGNAL FindParent;            };      IF ~nodeFound THEN RETURN;      IF ~mustFindLeaf AND ~deletionDone THEN        -- there are two cases in which deletion can be done without traveling 	-- to the bottom of the tree.  Both are explored only once, and if 	-- neither applies,mustFindLeaf is set to TRUE.	SELECT TRUE FROM 	  nodeToDelete.rightBranch = NIL => 	    BEGIN	    deletionDone ¬ TRUE;	    DeleteInCase1[h, nodeToDelete];	    END;	  nodeToDelete.rightBranch.leftBranch = NIL => 	    BEGIN	    deletionDone ¬ TRUE;	    IF balanced ¬ DeleteInCase2[h, nodeToDelete] THEN SIGNAL deletionFinished;	    END;	  ENDCASE => 	    BEGIN	    mustFindLeaf ¬ TRUE;            thisTree ¬ 1;            DeleteFromBalancedTree[              nodeToDelete.rightBranch, e !              FindParent => RESUME [currentParent ¬ root, inWhichTree ¬ thisTree]];	    IF balanced ¬ RebalanceAfterDeletion[h, IF root # nodeToDelete THEN root ELSE promotedLeaf, thisTree] THEN SIGNAL deletionFinished;            END      ELSE        BEGIN        IF mustFindLeaf AND ~deletionDone THEN	-- the nodeToDelete has been found, it must be swapped with the smallest        -- node larger than it, and then deleted.          BEGIN          IF root.leftBranch.leftBranch # NIL THEN            BEGIN            thisTree ¬ -1;            DeleteFromBalancedTree[              root.leftBranch, e !              FindParent => RESUME [currentParent ¬ root, inWhichTree ¬ thisTree]];            END	  ELSE thisTree ¬ -1;          -- we are now at the bottom of the tree          IF ~deletionDone THEN promotedLeaf ¬ SwapNodeToDeleteWithLeaf[            h, root, parentOfNodeToDelete, nodeToDelete, treeOfNodeToDelete];          deletionDone ¬ TRUE;          END;	-- rebalance the tree.        IF deletionDone THEN          IF balanced ¬ RebalanceAfterDeletion[h, IF root # nodeToDelete THEN root ELSE promotedLeaf, thisTree] THEN SIGNAL deletionFinished;        END;      END;    BEGIN ENABLE deletionFinished => CONTINUE;    IF h.root = NIL THEN RETURN;    IF h.elementsAreAlreadyInOrder THEN DeleteFromList[h, e]    ELSE      BEGIN      whichSide ¬        SELECT NSName.CompareNames[        e, @h.root.name, h.ignoreOrg, h.ignoreDomain, h.ignoreLocal] FROM          less => -1,          greater => 1,          ENDCASE => IF h.root.rightBranch = NIL THEN -1 ELSE 1;      DeleteFromBalancedTree[        h.root, e !        FindParent => RESUME [currentParent ¬ NIL, inWhichTree ¬ whichSide]];      IF CHSwitches.doStubDebug AND debugTree THEN ValidateTree[h];      END;    END;    END;      ExtractName: PUBLIC PROCEDURE [r: Root] RETURNS [name: NSName.Name] =    BEGIN    IF r = NIL THEN ERROR;    name ¬ @r.name;    END;      ExtractUserData: PUBLIC PROCEDURE [r: Root] RETURNS [    userData: LONG UNSPECIFIED] =    BEGIN    IF r = NIL THEN ERROR;    userData ¬ r.userData;    END;  -- mainline code   -- places retainedHeap: ARRAY [0 .. retainedHeapCount) OF UNCOUNTED ZONE ¬ ALL[NIL];  FOR i: CARDINAL IN [0..retainedHeapCount) DO retainedHeap[i] ¬ NIL; ENDLOOP;  END..  LOG 6-Jan-83 15:55:12, BLyon, created file 8-Apr-83 13:47:50, BLyon,  edited10-Feb-84 17:05:20, read, changed parameter to Destroy to LONG POINTER TO Handle 11-Jun-84 19:07:28, read, AddElement now returns right pointer if element was already there14-Jun-84 22:17:33 - Gealy - Use optimised string ops. 9-Jul-84 14:07:16 - read - Sorter Deletion bug16-Jul-84 19:03:19 - read - resurrected old version with heap caching. 7-Aug-84 21:23:59 - Gealy - Heap.Flush instead of Prune, retainedHeapCount bis 10 instead of 2.    8-Aug-84 14:42:28 - Wobber/Gealy - delete delete nodes if the heap is to be flushed.  18-Apr-85 14:08:55 -  mweeks - Added GetHeapParameters 
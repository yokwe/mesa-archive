-- File: CHNameToAddrMapper.mesa - last edit:-- Racine:OSBU North:Xerox 11-Mar-93 13:08:53-- WIrish              10-Mar-93 12:47:53-- AOF                 10-Jun-87 13:15:10-- Stucke              25-Apr-85 15:03:24-- Copyright (C) 1985, 1987, 1993 by Xerox Corporation. All rights reserved.DIRECTORY  CH USING [    Buffer, BufferArea, BufferTooSmall, ConversationHandle, Element,    LookupGroupProperty, LookupValueProperty, maxDomainNameLength,    maxLocalNameLength, maxOrgNameLength, ReturnCode, Name, NameRecord,    NameStreamProc],  CHAddressCacheFriends USING [], -- exports  CHPIDs USING [nsAddress, members],  CHProtocol USING [    actualHighCh2VersionNumber, actualLowCh2VersionNumber, AlterPreferredVersion,    chSocket, GetAlternateVersion, GetPreferredVersion, IsThereAnAlternateVersion,    maxDistanceToAnyNets, maxDistanceToNearByNets, NameShift,    shiftInName, ShiftTerminates, Version],  CHMUX USING [    FreeResult, GetCourierInfo, GetMUXHeap, MakeCallParameter,    MakeReturnParameter, PEParm, PEResult],  CHStubInternal USING [AddrList, AddrObject, EnumerateYourDomains, PokeTheStub],  CHStubInternalExtras USING [WhatToDoWithAddress],  CHSwitches USING [doStubDebug],  Courier USING [Parameters],  ExpeditedCourier USING [    CallToAddresses, CallToInternetRing, DeserializeFromBlock,    ExpandingRingAction, ResponseProc, RingBound],  Heap USING [Create, Flush, systemZone],  IncrementalSort USING [    AddElement, DeleteElement, Destroy, DumpElements, EachNodeProc, FindElement,    Handle, MakeSorter, nullHandle, Root],  NSAddr USING [    Address, FirstNearerThanSecond, FreeAddress, RhsToAddress,    SelectNearestAddress],  NSName USING [CopyName, FreeName, Name, NameTooSmall],  NSString USING [nullString, String, StringFromMesaString],  NSStringExtras USING [EquivalentStrings],  Process USING [Detach, InitializeCondition, SecondsToTicks, Yield],  Router USING [AssignAddress],  System USING [    AdjustGreenwichMeanTime, GetClockPulses, GetGreenwichMeanTime, gmtEpoch,    GreenwichMeanTime, NetworkAddress, NetworkNumber, nullNetworkAddress,    SecondsSinceEpoch];CHNameToAddrMapper: MONITOR  IMPORTS    CH, CHMUX, CHProtocol, CHStubInternal, ExpeditedCourier, Heap,    IncrementalSort, NSAddr, NSName, NSString, NSStringExtras, Process,    Router, System  EXPORTS CH, CHStubInternal, CHStubInternalExtras, CHAddressCacheFriends =  BEGIN  OrgTree: TYPE = IncrementalSort.Handle;  DomainTree: TYPE = IncrementalSort.Handle;  AddrList: TYPE = LONG POINTER TO AddrObject;  AddrObject: TYPE = RECORD [    next: AddrList,    usable: BOOLEAN,    timestamp: System.GreenwichMeanTime,    addr: System.NetworkAddress];  ElementArray: TYPE = ARRAY [0..maxElementArraySize) OF CH.Element;  -- globals  maxElementArraySize: CARDINAL = 20;  maxServersFromExpandingRing: CARDINAL ¬ 6;  doDebug: BOOLEAN = CHSwitches.doStubDebug;  processingHintCount: CARDINAL ¬ 0;  heapChecking: BOOLEAN ¬ FALSE;  NearbyNetDistance: TYPE = CARDINAL [1..CHProtocol.maxDistanceToNearByNets];  FarAwayNetDistance: TYPE = CARDINAL    [CHProtocol.maxDistanceToNearByNets + 1..CHProtocol.maxDistanceToAnyNets];  myHeap: UNCOUNTED ZONE ¬ NIL;  muxHeap: UNCOUNTED ZONE ¬ CHMUX.GetMUXHeap[];  orgTreeHead: OrgTree ¬ IncrementalSort.nullHandle;  unavailableDomains: IncrementalSort.Handle ¬ IncrementalSort.nullHandle;  closeCH: System.NetworkAddress ¬ System.nullNetworkAddress;  closeDomains: OrgTree ¬ IncrementalSort.nullHandle;  pleaseDoNotReadCloseDomains: BOOLEAN ¬ FALSE;  zombieTime: LONG CARDINAL = 300;  -- in seconds  timeToKill: LONG CARDINAL = 300; -- in seconds  evaluateListWindow: LONG CARDINAL ¬ LONG[60] * LONG[15];  -- 15 minutes  nullAddrObject: AddrObject ¬ [    NIL, FALSE, System.gmtEpoch, System.nullNetworkAddress];  Stop: SIGNAL = CODE;  EqualStrings: PROC [s1, s2: NSString.String] RETURNS [BOOLEAN] = INLINE {    RETURN[NSStringExtras.EquivalentStrings[s1, s2]]};  EnumerateNearbyDomains: PUBLIC PROCEDURE [    conversation: CH.ConversationHandle, eachDomain: CH.NameStreamProc]    RETURNS [rc: CH.ReturnCode ¬ [done, first]] =    -- the list of close domains must be copied to a heap not controlled by this    -- module so that a complete answer is returned even if the cache must be     -- restarted while the user is being called back.    BEGIN    didOne: BOOLEAN ¬ FALSE;    sortHandle: IncrementalSort.Handle ¬ IncrementalSort.MakeSorter[      FALSE, FALSE, FALSE, TRUE];    CopyItUnderLock: ENTRY PROCEDURE =      BEGIN      aCHNameRecord: CH.NameRecord ¬ [        NSString.nullString, NSString.nullString, NSString.nullString];      name: CH.Name = @aCHNameRecord;      EachOrgTree: IncrementalSort.EachNodeProc =        BEGIN        IF EqualStrings[currentName.org, CHProtocol.shiftInName] THEN RETURN;        aCHNameRecord.org ¬ currentName.org;        IncrementalSort.DumpElements[          h: LOOPHOLE[userData], eachElement: EachDomainTree];        END;      EachDomainTree: CH.NameStreamProc =        BEGIN        didOne ¬ TRUE;        aCHNameRecord.domain ¬ currentName.domain;        [] ¬ IncrementalSort.AddElement[sortHandle, name];        END;      IF pleaseDoNotReadCloseDomains THEN RETURN;      IncrementalSort.DumpElements[        h: closeDomains, dumpDataAlso: TRUE, eachElementWithData: EachOrgTree];      END;    MaybeRestartTheCache: ENTRY PROCEDURE =      BEGIN      IF ~pleaseDoNotReadCloseDomains THEN Process.Detach[FORK RestartTheCache[]];      END;    CopyItUnderLock[];    IncrementalSort.DumpElements[      h: sortHandle, eachElement: eachDomain !      UNWIND => IncrementalSort.Destroy[@sortHandle]];    IncrementalSort.Destroy[@sortHandle];    IF NOT didOne THEN BEGIN rc ¬ [allDown, first]; MaybeRestartTheCache[]; END;    END;  GetDefaultServerAddress: INTERNAL PROCEDURE RETURNS [System.NetworkAddress] =    BEGIN    IF closeCH = System.nullNetworkAddress THEN      FindANewCloseCH[];    RETURN[closeCH];    END;   -- GetDefaultServerAddress  FindOrgAddr: PUBLIC ENTRY PROCEDURE [name: CH.Name]    RETURNS [addr: System.NetworkAddress] =    BEGIN addr ¬ FindOrgAddrInternal[name]; END;  FindOrgAddrInternal: INTERNAL PROCEDURE [name: CH.Name]    RETURNS [addr: System.NetworkAddress] =    BEGIN    useDefaultAddr: BOOLEAN ¬ FALSE;    shiftedName: CH.NameRecord;    CHProtocol.NameShift[      source: name, destination: @shiftedName !      CHProtocol.ShiftTerminates => {useDefaultAddr ¬ TRUE; CONTINUE}];    IF useDefaultAddr THEN      BEGIN      addr ¬ GetDefaultServerAddress[];      -- by associating an addr with the "glue" domain we avoid all future      -- CHProtocol.ShiftTerminates errors.       IF addr # System.nullNetworkAddress THEN        AddNewAddr[addr, AddNewDomain[AddNewOrg[orgTreeHead, name], name]];      END    ELSE      BEGIN      IF EqualStrings[shiftedName.org, CHProtocol.shiftInName] AND         EqualStrings[shiftedName.domain, CHProtocol.shiftInName] THEN	 BEGIN	 -- we have an org here without an address.         -- on the assumption that a server that serves a domain of an org also	 -- serves that org, we can look for other domains in the org to get an	 -- address for the org	 downShiftNameRecord: CH.NameRecord ¬ [	  org: name.domain, domain: name.local, local: NSString.nullString];	downShiftName: CH.Name = @downShiftNameRecord;	addr ¬ LookInDomainTree[downShiftName];	IF addr # System.nullNetworkAddress THEN	  BEGIN	  -- put this address in the tree for the org	  AddNewAddr[addr, AddNewDomain[	    AddNewOrg[orgTreeHead, name], name]];	  RETURN[addr];	  END;	END;      addr ¬ FindDomainAddrInternal[@shiftedName]; END;    END;   --  FindOrgAddrInternal  LookInDomainTree: INTERNAL PROCEDURE [name: CH.Name]    RETURNS [addr: System.NetworkAddress ¬ System.nullNetworkAddress] =    BEGIN    domainTreeWanted: IncrementalSort.Handle;    EachDomain: INTERNAL IncrementalSort.EachNodeProc =      BEGIN      addresses: AddrList ¬ FindValidAddr[userData];      IF addresses # NIL THEN        IF NSAddr.FirstNearerThanSecond[addresses.addr, addr] THEN          addr ¬ addresses.addr;      END;        -- If we are looking for an address for the org CHServers then we want to    -- return a null address so the closeCH will be used.  This prevents looking    -- at org addresses and possibly getting an address far away.    IF EqualStrings[name.org, CHProtocol.shiftInName] THEN RETURN;    -- get the domain tree for the org    IF orgTreeHead # IncrementalSort.nullHandle AND      (domainTreeWanted ¬ LOOPHOLE[IncrementalSort.FindElement[orgTreeHead, name,       FALSE, TRUE, TRUE].userData]) # IncrementalSort.nullHandle THEN	IncrementalSort.DumpElements[h: domainTreeWanted, dumpDataAlso: TRUE,	  eachElementWithData: EachDomain];     END;   -- LookInDomainTree  FindDomainAddr: PUBLIC ENTRY PROCEDURE [name: CH.Name]    RETURNS [addr: System.NetworkAddress] =    BEGIN addr ¬ FindDomainAddrInternal[name]; END;  FindDomainAddrInternal: INTERNAL PROCEDURE [name: CH.Name]    RETURNS [addr: System.NetworkAddress] =    BEGIN    addressesForDomain: AddrList ¬ LONG[NIL];    domainTreeWanted: IncrementalSort.Handle;    IF orgTreeHead # IncrementalSort.nullHandle      AND        (domainTreeWanted ¬ LOOPHOLE[IncrementalSort.FindElement[          orgTreeHead, name, FALSE, TRUE, TRUE].userData]) #        IncrementalSort.nullHandle      AND        (addressesForDomain ¬ IncrementalSort.FindElement[          domainTreeWanted, name, TRUE, FALSE, TRUE].userData) # LONG[NIL] THEN      BEGIN      addressesForDomain ¬ FindValidAddr[addressesForDomain];      IF addressesForDomain # NIL THEN RETURN[addr ¬ addressesForDomain.addr];      END;    addr ¬ FindOrgAddrInternal[name];    END;    InWindow: PROCEDURE [ts: System.GreenwichMeanTime] RETURNS [BOOLEAN] = {    nowSec: LONG CARDINAL;    tsSec: LONG CARDINAL;    nowSec ¬ System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]];    tsSec ¬ System.SecondsSinceEpoch[ts];    RETURN[(nowSec > tsSec) AND (nowSec - tsSec) < evaluateListWindow];    };      ReorderAddrListByRandomAndResponseTime: INTERNAL PROCEDURE [addrList: AddrList] = {    -- The basic idea is to move the "best" choice server to the head of the list.    -- We do this by using randomization and response time.    -- This way we don't pick on any one server, thereby distributing the load,    -- yet we still get good response times (possibly better than using the    -- old-fashioned "closest hops" approach).  This also works for transports /    -- environments where hop information is not available.    --    -- We don't necessarily want to deal with the entire list since it    -- could be quite large.  So, we just peel off the first maxElementArraySize,    -- randomize this (sub)list, probe this list, and then put the "fastest"    -- responder at the front of the list...    EachAddress: PROCEDURE [addr: System.NetworkAddress] RETURNS [continue: BOOLEAN] = {      element: AddrList ¬ addrList;      WHILE element # NIL DO	IF element.addr.host = addr.host THEN EXIT;	element ¬ element.next;	ENDLOOP;      IF element # addrList AND element # NIL THEN {        -- We want to move this element to the head of the list	-- BUT we don't have the right pointers to be able to actually	-- return a list with a new head.  So, we cheat and copy	-- the contents around to beat the system...	temp: AddrObject ¬ element^;	element^ ¬ [	  element.next, addrList.usable, addrList.timestamp,	  addrList.addr];	addrList^ ¬ [	  addrList.next, temp.usable, temp.timestamp, temp.addr];	element ¬ addrList;        };      element.usable ¬ TRUE;      element.timestamp ¬ System.GetGreenwichMeanTime[];      continue ¬ FALSE;      };  -- EachAddress    IsLocal: PROCEDURE [net: System.NetworkNumber] RETURNS [BOOLEAN] = {      RETURN[net = Router.AssignAddress[].net];      };    probeArray: ARRAY [0..maxElementArraySize] OF CHStubInternal.AddrObject;    elements: CARDINAL ¬ 0;    nextLocal: CARDINAL;    temp: CHStubInternal.AddrObject;    index: CARDINAL;    probeList: CHStubInternal.AddrList;    inputList: AddrList ¬ addrList;    -- main code starts here...    -- take the first N elements from the head of the list    -- and stick them into an array in random order    -- (converting structures along the way)    WHILE inputList # NIL AND elements < maxElementArraySize DO      IF inputList.usable THEN {	index ¬ Random[0, elements];  -- pick a random place to put this element	IF index < elements THEN {    -- shuffle the elements if needed	  FOR j: CARDINAL IN [index..elements-1] DO	    probeArray[j+1] ¬ probeArray[j];	    ENDLOOP;	  };	probeArray[elements] ¬ [next: NIL, address: inputList.addr];	elements ¬ elements + 1;      };      inputList ¬ inputList.next;      ENDLOOP;    -- move any local addresses to the front of the list    -- (NB they are still randomized)    nextLocal ¬ 0;    FOR index IN [0..elements) DO      IF IsLocal[probeArray[index].address.net] THEN {        temp ¬ probeArray[index];	probeArray[index] ¬ probeArray[nextLocal];	probeArray[nextLocal] ¬ temp;	nextLocal ¬ nextLocal + 1;        };      ENDLOOP;    -- now link the elements in the array together for ProbeServerList    -- NB: the following DECREASING results in the list being in [0..n) order    probeList ¬ NIL;    FOR index DECREASING IN [0..elements) DO      probeArray[index].next ¬ probeList;      probeList ¬ @probeArray[index];      ENDLOOP;    -- probe this randomized list for the "fastest" responder    IF probeList # NIL THEN [] ¬ ProbeServerListInternal[probeList, EachAddress];    };  InvalidateAddr: PUBLIC ENTRY PROCEDURE [addr: System.NetworkAddress] =    {FlushAddr[addr, TRUE]};  FlushAddr: INTERNAL PROCEDURE [    addr: System.NetworkAddress, deleteIt: BOOLEAN ¬ FALSE] =    -- has the side effect of removing unusable addresses.    BEGIN    SearchAddressList: INTERNAL PROCEDURE [list: AddrList] =      BEGIN      prev: AddrList ¬ NIL;      WHILE list # NIL AND list­ # nullAddrObject DO        IF addr.host = list.addr.host THEN          BEGIN          InvalidateAddrNode[list];          IF deleteIt THEN            BEGIN list ¬ GarbageCollect[prev, list, FALSE]; LOOP; END;          END;  -- addresses match        -- now for on-the-fly garbage collecting        IF NOT list.usable THEN          BEGIN          list ¬ GarbageCollect[prev, list, TRUE];          -- since we don't know if GarbageCollect changed our list          -- or not, the following is neccessary to avoid an infinite loop          -- since we will unconditionally LOOP.          IF prev # NIL AND prev.next # list THEN prev ¬ prev.next;          LOOP;          END;        prev ¬ list;        list ¬ list.next;        ENDLOOP;      END;    EachOrg: INTERNAL IncrementalSort.EachNodeProc =      BEGIN      IncrementalSort.DumpElements[        h: LOOPHOLE[userData], dumpDataAlso: TRUE,        eachElementWithData: EachDomain];      END;    EachDomain: INTERNAL IncrementalSort.EachNodeProc =      BEGIN SearchAddressList[LOOPHOLE[userData]]; END;    IncrementalSort.DumpElements[      h: orgTreeHead, dumpDataAlso: TRUE, eachElementWithData: EachOrg];    IF closeCH.host = addr.host THEN      BEGIN closeCH ¬ System.nullNetworkAddress; FindANewCloseCH[]; END;    END;  InvalidateWrongServerAddr: PUBLIC ENTRY PROCEDURE [   name: CH.Name, na: System.NetworkAddress] =    BEGIN    domainTreeWanted: IncrementalSort.Handle;    addressesForDomain: AddrList ¬ LONG[NIL];    addressToInvalidate: AddrList ¬ LONG[NIL];    now: System.GreenwichMeanTime;    halfHour: LONG INTEGER ¬ 30 * 60;   -- invalidate address for 1/2 hour    IF orgTreeHead # IncrementalSort.nullHandle     AND      (domainTreeWanted ¬ LOOPHOLE[IncrementalSort.FindElement[orgTreeHead, name,      FALSE, TRUE, TRUE].userData]) # IncrementalSort.nullHandle     AND      (addressesForDomain ¬ IncrementalSort.FindElement[domainTreeWanted, name,      TRUE, FALSE, TRUE].userData) # LONG[NIL] THEN        BEGIN	addressToInvalidate ¬ FindAddrNode[addressesForDomain, na];	IF addressToInvalidate # NIL THEN	  BEGIN	  addressToInvalidate.usable ¬ FALSE;	  now ¬ System.GetGreenwichMeanTime[];	  addressToInvalidate.timestamp ¬ System.AdjustGreenwichMeanTime[	    now, halfHour];	  END;	END;    END;   -- InvalidateWrongServerAddr  AddNewOrg: INTERNAL PROCEDURE [whichTree: OrgTree, name: CH.Name]    RETURNS [domains: DomainTree] =    BEGIN    shiftNameRecord: CH.NameRecord;    chServers: DomainTree;    CHProtocol.NameShift[      source: name, destination: @shiftNameRecord !      CHProtocol.ShiftTerminates => RESUME ];    IF      (domains ¬ LOOPHOLE[IncrementalSort.FindElement[        whichTree, name, FALSE, TRUE, TRUE].userData]) =      IncrementalSort.nullHandle THEN      BEGIN      domains ¬ IncrementalSort.MakeSorter[FALSE, TRUE, FALSE, TRUE, myHeap];      [] ¬ IncrementalSort.AddElement[whichTree, name, LOOPHOLE[domains]];      chServers ¬ AddNewOrg[whichTree, @shiftNameRecord];      [] ¬ AddNewDomain[chServers, @shiftNameRecord];      END    END;  AddNewDomain: INTERNAL PROCEDURE [h: DomainTree, name: CH.Name]    RETURNS [listHead: AddrList] =    BEGIN    IF      (listHead ¬ IncrementalSort.FindElement[        h, name, TRUE, FALSE, TRUE].userData) = LONG[NIL] THEN      BEGIN      listHead ¬ myHeap.NEW[AddrObject];      listHead­ ¬ nullAddrObject;      [] ¬ IncrementalSort.AddElement[h, name, listHead];      END;    END;  AddNewAddr: INTERNAL PROCEDURE [    na: System.NetworkAddress, list: AddrList, addToHead: BOOLEAN ¬ FALSE] =    BEGIN    prev, n: AddrList ¬ NIL;    IF list­ = nullAddrObject THEN      BEGIN list­ ¬ [NIL, TRUE, System.GetGreenwichMeanTime[], na]; RETURN; END;    n ¬ FindAddrNode[list, na];    IF n # NIL THEN      BEGIN      IF NOT n.usable THEN MaybeValidateInvalidAddrNode[n];      n.addr.net ¬        IF NSAddr.FirstNearerThanSecond[n.addr, na] THEN n.addr.net ELSE na.net;      IF NOT addToHead OR (n = list) THEN RETURN;      END;    n ¬ myHeap.NEW[AddrObject];    IF addToHead OR NSAddr.FirstNearerThanSecond[na, list.addr] THEN      BEGIN      n­ ¬ list­;      list­ ¬ [n, TRUE, System.GetGreenwichMeanTime[], na];      RETURN;      END;    n­ ¬ [NIL, TRUE, System.GetGreenwichMeanTime[], na];    WHILE list # NIL DO      IF NSAddr.FirstNearerThanSecond[na, list.addr] THEN EXIT;      prev ¬ list;      list ¬ list.next;      ENDLOOP;    n.next ¬ list;    prev.next ¬ n;    END;  InvalidateAddrNode: INTERNAL PROCEDURE [addrNode: AddrList] =    BEGIN    IF addrNode = NIL OR NOT addrNode.usable THEN RETURN;    addrNode.usable ¬ FALSE;    addrNode.timestamp ¬ System.GetGreenwichMeanTime[];    END;  MaybeValidateInvalidAddrNode: INTERNAL PROCEDURE [addrNode: AddrList] =    BEGIN    now: LONG CARDINAL = System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]];    timestamp: LONG CARDINAL ¬ System.SecondsSinceEpoch[addrNode.timestamp];    IF timestamp > now THEN RETURN;    IF now - timestamp > zombieTime THEN      addrNode.usable ¬ TRUE;    END;  GarbageCollect: INTERNAL PROCEDURE [    prev, node: AddrList, checkTimestamps: BOOLEAN ¬ FALSE]    RETURNS [newNode: AddrList] =    BEGIN    now: LONG CARDINAL;    temp: AddrList;    IF checkTimestamps THEN      BEGIN      now ¬ System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]];      IF now - System.SecondsSinceEpoch[node.timestamp] <= 2 * zombieTime THEN        RETURN[node.next];      END;    SELECT TRUE FROM      prev = NIL AND (temp ¬ node.next) # NIL =>        BEGIN        node­ ¬ [temp, temp.usable, temp.timestamp, temp.addr];        node.next ¬ temp.next;        temp.next ¬ NIL;        myHeap.FREE[@temp];        RETURN[node];        END;      prev = NIL => BEGIN node­ ¬ nullAddrObject; RETURN[node]; END;      ENDCASE =>        BEGIN        prev.next ¬ node.next;        node.next ¬ NIL;        myHeap.FREE[@node];        newNode ¬ prev.next;        RETURN[newNode];        END;    END;  FindAddrNode: INTERNAL PROCEDURE [    firstAddrNode: AddrList, addr: System.NetworkAddress]    RETURNS [node: AddrList] =    BEGIN    node ¬ firstAddrNode;    WHILE node # NIL DO      IF node.addr.host = addr.host THEN EXIT; node ¬ node.next; ENDLOOP;    END;  FindValidAddr: INTERNAL PROCEDURE [firstAddrNode: AddrList] RETURNS [AddrList] =    BEGIN    -- If the first addr on the list is usable and within window (which means    -- that we've evaluated its "bestness" recently) then simply return it.    -- If the first addr isn't usable then make a new "best" choice and promote    -- it to the head of the list for next time.    -- NB: even though we RETURN an AddrList its value will always be that    -- of firstAddrNode.    IF firstAddrNode # NIL      AND firstAddrNode.usable      AND InWindow[firstAddrNode.timestamp] THEN {        firstAddrNode.timestamp ¬ System.GetGreenwichMeanTime[];        RETURN[firstAddrNode];	};    ReorderAddrListByRandomAndResponseTime[firstAddrNode];    -- be careful of the case where you have a nullAddrObject (basically no list)    IF firstAddrNode # NIL AND (NOT firstAddrNode.usable) THEN firstAddrNode ¬ NIL;    RETURN[firstAddrNode];    END;  NoteBusyServer: PUBLIC ENTRY PROCEDURE [    queryName: CH.Name, addr: System.NetworkAddress]    RETURNS [foundAlternateAddr: BOOLEAN] =    BEGIN    addresses: AddrList;    shiftedName: CH.NameRecord;    orgInCHServers, queryNameDomainTree: DomainTree;    CHProtocol.NameShift[      source: queryName, destination: @shiftedName !      CHProtocol.ShiftTerminates => RESUME ];    FlushAddr[addr];    IF closeCH = System.nullNetworkAddress THEN FindANewCloseCH[];  --not needed    IF      (queryNameDomainTree ¬ LOOPHOLE[IncrementalSort.FindElement[        orgTreeHead, queryName, FALSE, TRUE, TRUE].userData]) #      IncrementalSort.nullHandle      AND        (addresses ¬ IncrementalSort.FindElement[          queryNameDomainTree, queryName, TRUE, FALSE, TRUE].userData) # LONG[NIL]      THEN        BEGIN	foundAlternateAddr ¬ FindValidAddr[addresses] # NIL;	IF foundAlternateAddr THEN RETURN[TRUE];	END;    IF      (orgInCHServers ¬ LOOPHOLE[IncrementalSort.FindElement[        orgTreeHead, @shiftedName, FALSE, TRUE, TRUE].userData]) #      IncrementalSort.nullHandle      AND        (addresses ¬ IncrementalSort.FindElement[          orgInCHServers, @shiftedName, TRUE, FALSE, TRUE].userData) # LONG[NIL]      THEN        BEGIN	foundAlternateAddr ¬ FindValidAddr[addresses] # NIL;	IF foundAlternateAddr THEN RETURN[TRUE];	END;    foundAlternateAddr ¬ closeCH # System.nullNetworkAddress;    END;      AddToUnavailableDomains: PUBLIC ENTRY PROCEDURE [domainName: CH.Name] =    -- the sort tree for unavailable domains has both org and domain names     -- in a single tree (thus wasting some space) because it is assumed that    -- there will not be a large number of domains unavailable at the same time.    BEGIN      IF unavailableDomains # IncrementalSort.nullHandle THEN        [] ¬ IncrementalSort.AddElement[	  unavailableDomains, domainName, System.GetGreenwichMeanTime[]];      -- if a sorter hasn't been made for unavailableDomains, the cache is      -- restarting, and the domain won't be put in it if none of the      -- clearinghouses serving it answer the broadcast for servers.    END;      DeleteFromUnavailableDomains: PROCEDURE [domainName: CH.Name] =    INLINE {      IF unavailableDomains # IncrementalSort.nullHandle THEN        IncrementalSort.DeleteElement[unavailableDomains, domainName] };	  IsDomainAvailable: PUBLIC ENTRY PROCEDURE [domainName: CH.Name] RETURNS     [itIs: BOOLEAN ¬ TRUE] =    BEGIN    deadTime: LONG UNSPECIFIED;    dummyName: CH.Name;    dummyRoot: IncrementalSort.Root;    now: LONG CARDINAL;    IF unavailableDomains = IncrementalSort.nullHandle THEN RETURN;    [dummyName, deadTime, dummyRoot] ¬ IncrementalSort.FindElement[      unavailableDomains, domainName, FALSE, FALSE, TRUE];    IF dummyName = NIL THEN RETURN;    now ¬ System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]];    IF now - System.SecondsSinceEpoch[      LOOPHOLE[deadTime, System.GreenwichMeanTime]] <= timeToKill THEN       RETURN [FALSE]    ELSE DeleteFromUnavailableDomains[domainName];    END;  FindANewCloseCH: INTERNAL PROCEDURE =    BEGIN    EachOrg: INTERNAL IncrementalSort.EachNodeProc =      BEGIN      IncrementalSort.DumpElements[        h: LOOPHOLE[userData], dumpDataAlso: TRUE,        eachElementWithData: EachDomain];      END;    EachDomain: INTERNAL IncrementalSort.EachNodeProc =      BEGIN      addresses: AddrList ¬ FindValidAddr[userData];      IF addresses # NIL THEN        IF NSAddr.FirstNearerThanSecond[addresses.addr, closeCH] THEN          closeCH ¬ addresses.addr;      END;    IncrementalSort.DumpElements[      h: orgTreeHead, dumpDataAlso: TRUE, eachElementWithData: EachOrg];    IF closeCH = System.nullNetworkAddress AND ~pleaseDoNotReadCloseDomains THEN      Process.Detach[FORK RestartTheCache[]];    END;  NoteLocalServer: PUBLIC ENTRY PROCEDURE [    isAlive: BOOLEAN, localEnumerator: PROC [CH.NameStreamProc]] =    BEGIN    domainTreeHandle: DomainTree;    addresses: AddrList;    ALocalDomain: INTERNAL CH.NameStreamProc =      BEGIN      recur: BOOLEAN ¬ TRUE;      orgEntry: CH.NameRecord;  -- make the org look like a domain in the glue      domainTreeHandle ¬ AddNewOrg[orgTreeHead, currentName];      addresses ¬ AddNewDomain[domainTreeHandle, currentName];      AddNewAddr[closeCH, addresses];      -- if not a glue domain then add to "nearby domain"      IF NOT EqualStrings[currentName.org, CHProtocol.shiftInName] THEN        BEGIN        domainTreeHandle ¬ AddNewOrg[closeDomains, currentName];        [] ¬ AddNewDomain[domainTreeHandle, currentName];        END;      -- now do it for the glue, too      CHProtocol.NameShift[        currentName, @orgEntry !        CHProtocol.ShiftTerminates => {recur ¬ FALSE; CONTINUE}];      IF recur THEN ALocalDomain[@orgEntry];      END;    closeCH ¬ Router.AssignAddress[];    IF isAlive THEN BEGIN localEnumerator[ALocalDomain]; END    ELSE BEGIN FlushAddr[closeCH, TRUE]; FindANewCloseCH[]; END;    END;      ProbeServerList: PUBLIC ENTRY PROCEDURE [addrList: CHStubInternal.AddrList, doSomethingWithAddr: CHStubInternalExtras.WhatToDoWithAddress]     RETURNS [gotAnAnswer: BOOLEAN ¬ FALSE] = {    RETURN[ProbeServerListInternal[addrList, doSomethingWithAddr]];    };      ProbeServerListInternal: INTERNAL PROCEDURE [addrList: CHStubInternal.AddrList, doSomethingWithAddr: CHStubInternalExtras.WhatToDoWithAddress]     RETURNS [gotAnAnswer: BOOLEAN ¬ FALSE] =    BEGIN    parm: CHMUX.PEParm ¬ [procedure: chServerAddrProbe];    cp: Courier.Parameters = CHMUX.MakeCallParameter[@parm, TRUE];    programNumber: LONG CARDINAL;    versionNumber: CARDINAL;    procedureNumber: CARDINAL;    version: CHProtocol.Version ¬ CHProtocol.GetPreferredVersion[];        AddRespondingAddr: ExpeditedCourier.ResponseProc =      BEGIN      error: BOOLEAN ¬ FALSE;      addr: System.NetworkAddress;      result: CHMUX.PEResult ¬ [procedure: chServerAddrProbe];      cr: Courier.Parameters = CHMUX.MakeReturnParameter[@result, FALSE, version];      continue ¬ TRUE;      WITH header.body SELECT FROM return => NULL; ENDCASE => RETURN;      IF NOT ExpeditedCourier.DeserializeFromBlock[        cr, muxHeap, serializedResponse] THEN RETURN;      IF result.chServerNSAddr # NIL THEN        addr ¬ NSAddr.SelectNearestAddress[result.chServerNSAddr]      ELSE error ¬ TRUE;      CHMUX.FreeResult[@result];      IF error THEN RETURN;      continue ¬ IF doSomethingWithAddr # NIL THEN doSomethingWithAddr[addr]        ELSE TRUE;      gotAnAnswer ¬ TRUE;      END;          [programNumber, versionNumber, procedureNumber] ¬ CHMUX.GetCourierInfo[      parm.procedure, version];    ExpeditedCourier.CallToAddresses[      programNumber, versionNumber, procedureNumber, cp, CHProtocol.chSocket,      addrList, AddRespondingAddr, ];    IF NOT gotAnAnswer      AND CHProtocol.IsThereAnAlternateVersion[        programNumber, versionNumber, [CHProtocol.actualLowCh2VersionNumber,        CHProtocol.actualHighCh2VersionNumber]] THEN      BEGIN      wrongVersion: CHProtocol.Version = version;      version ¬ CHProtocol.GetAlternateVersion[wrongVersion];      [programNumber, versionNumber, procedureNumber] ¬ CHMUX.GetCourierInfo[        parm.procedure, version];      ExpeditedCourier.CallToAddresses[        programNumber, versionNumber, procedureNumber, cp, CHProtocol.chSocket,        addrList, AddRespondingAddr, ];      IF gotAnAnswer THEN CHProtocol.AlterPreferredVersion[wrongVersion];      END;    END;      Random: PROCEDURE [low: CARDINAL, high: CARDINAL] RETURNS [CARDINAL] = {    -- Returns a random number [low..high]    n: CARDINAL;    n ¬ System.GetClockPulses[];    IF high > low THEN RETURN[low + (n MOD ((high-low)+1))];    RETURN[low];    };  ProcessHint: PUBLIC PROCEDURE [    conversation: CH.ConversationHandle, hint: CH.Name,    currentServer: System.NetworkAddress] RETURNS [ok: BOOLEAN ¬ TRUE] =    BEGIN    FindDomainAndOrg: ENTRY PROCEDURE =      BEGIN      domainTreeHandle: DomainTree;      processingHintCount ¬ processingHintCount + 1;      IF        (domainTreeHandle ¬ LOOPHOLE[IncrementalSort.FindElement[          orgTreeHead, downShiftName, FALSE, TRUE, TRUE].userData]) =        IncrementalSort.nullHandle THEN        domainTreeHandle ¬ AddNewOrg[orgTreeHead, downShiftName];      IF EqualStrings[hint.domain, CHProtocol.shiftInName] THEN        BEGIN        -- only the local part is significant and it has to be an org name        downShiftName.domain ¬ hint.local;        IF          (addresses ¬ IncrementalSort.FindElement[            domainTreeHandle, downShiftName, TRUE, FALSE, TRUE].userData) = LONG[          NIL] THEN addresses ¬ AddNewDomain[domainTreeHandle, downShiftName];        END      ELSE        IF          (addresses ¬ IncrementalSort.FindElement[            domainTreeHandle, downShiftName, TRUE, FALSE, TRUE].userData) = LONG[          NIL] THEN addresses ¬ AddNewDomain[domainTreeHandle, downShiftName];      InvalidateAddrNode[FindAddrNode[addresses, currentServer]];      END;  -- FindDomainAndOrg    addresses: AddrList;    downShiftNameRecord: CH.NameRecord ¬ [      org: hint.domain, domain: hint.local, local: NSString.nullString];    downShiftName: CH.Name = @downShiftNameRecord;    dummyDOrg: STRING = [CH.maxOrgNameLength];    dummyDDomain: STRING = [CH.maxDomainNameLength];    dummyDLocal: STRING = [CH.maxLocalNameLength];    dummyDNameRecord: CH.NameRecord ¬ [      NSString.StringFromMesaString[dummyDOrg], NSString.StringFromMesaString[      dummyDDomain], NSString.StringFromMesaString[dummyDLocal]];    dummyDName: CH.Name = @dummyDNameRecord;    rc: CH.ReturnCode;    GetAddr: ENTRY PROCEDURE RETURNS[addr: System.NetworkAddress] =      BEGIN      <<addr ¬ GetDefaultServerAddress[];>>      RETURN[closeCH];      END;  -- GetAddr    EachString: CH.NameStreamProc = {      -- PROCEDURE [currentName: Element]      newElement: NSName.Name;      members ¬ members + 1;      SELECT TRUE FROM        currentElementArraySize < maxElementArraySize => {	  -- the array isn't full yet so we simply add this element	  newElement ¬ NSName.CopyName[Heap.systemZone, currentName];	  elementArray[currentElementArraySize] ¬ newElement;	  currentElementArraySize ¬ currentElementArraySize + 1;	  };	Random[1, members] <= maxElementArraySize => {	  -- we've decided to keep this new element so we must	  -- swap out an existing one          index: CARDINAL;	  index ¬ Random[0, maxElementArraySize-1];	  IF elementArray[index] # NIL	    THEN NSName.FreeName[Heap.systemZone, elementArray[index]];	  newElement ¬ NSName.CopyName[Heap.systemZone, currentName];	  elementArray[index] ¬ newElement;	  };	ENDCASE;  -- we do nothing with the current element      };          FreeElementArray: PROCEDURE [array: ElementArray, elements: CARDINAL] = {      FOR i: CARDINAL IN [0..elements) DO        IF array[i] # NIL THEN NSName.FreeName[Heap.systemZone, array[i]];        ENDLOOP;      };          ConvertElementArrayToAddressList: PROCEDURE [array: ElementArray, elements: CARDINAL] = {      -- create a linked list of addresses from the array of names      -- NB: The order of the resulting list is randomized so that no      -- one server/address is "picked on".      index: CARDINAL;      FOR i: CARDINAL DECREASING IN [0..elements) DO        index ¬ Random[0, i];        LookupThisName[array[index]];  -- adds element to the head of listHead	IF index < i THEN {  -- shuffle down the elements if it's not the last one	  FOR j: CARDINAL IN [index..i-1] DO	    array[j] ¬ array[j+1];	    ENDLOOP;	  };        ENDLOOP;      };    LookupThisName: PROCEDURE [currentName: CH.Element] = {          myRc: CH.ReturnCode;      rhsArea: CH.BufferArea ¬ [length: 0, maxlength: 0, data: ];      rhs: CH.Buffer ¬ @rhsArea;      addr: System.NetworkAddress;      -- currentName is declared in CH.NameStreamProc      BEGIN      oldAddress: LONG POINTER TO System.NetworkAddress = conversation.address;      addr ¬ GetAddr[];      IF addr = System.nullNetworkAddress THEN        SIGNAL Stop;      conversation.address ¬ @addr;      myRc ¬ CH.LookupValueProperty[        conversation, currentName, CHPIDs.nsAddress, rhs, dummyDName !        CH.BufferTooSmall =>          BEGIN          IF offender # LONG[@rhsArea] THEN muxHeap.FREE[@offender];          rhs ¬ muxHeap.NEW[CH .BufferArea[lengthNeeded]];          rhs.maxlength ¬ lengthNeeded;          RESUME [rhs];          END; UNWIND => conversation.address ¬ oldAddress];      conversation.address ¬ oldAddress;      END;      IF myRc.code = done THEN        BEGIN        nsAddress: NSAddr.Address;        succeeded: BOOLEAN;        [succeeded, nsAddress] ¬ NSAddr.RhsToAddress[rhs];        IF succeeded THEN          BEGIN          newAddr: CHStubInternal.AddrList ¬ muxHeap.NEW[            CHStubInternal.AddrObject];          newAddr.address ¬ NSAddr.SelectNearestAddress[nsAddress];          [] ¬ NSAddr.FreeAddress[nsAddress];          newAddr.next ¬ listHead;          listHead ¬ newAddr;          END;        END;      IF rhs # LONG[@rhsArea] THEN muxHeap.FREE[@rhs];      };  -- LookupThisName    BumpProcessingCountLocked: ENTRY PROCEDURE = INLINE {      processingHintCount ¬ processingHintCount - 1};    Add: ENTRY PROCEDURE [na: System.NetworkAddress, addToHead: BOOLEAN] = INLINE      {AddNewAddr[na, addresses, addToHead]};    CheckOk: ENTRY PROCEDURE RETURNS [BOOLEAN] = INLINE {      RETURN[FindValidAddr[addresses] # NIL]};          AddEachAddress: INTERNAL PROCEDURE [addr: System.NetworkAddress]       RETURNS [continue: BOOLEAN] =      BEGIN      AddNewAddr[addr, addresses];      continue ¬ FindValidAddr[addresses] = NIL;      END;          elementArray: ElementArray ¬ ALL[NIL];    currentElementArraySize: CARDINAL ¬ 0;    members: CARDINAL ¬ 0;    listHead: CHStubInternal.AddrList ¬ NIL;    oldAddress: LONG POINTER TO System.NetworkAddress = conversation.address;        { ENABLE UNWIND => FreeElementArray[elementArray, currentElementArraySize];    FindDomainAndOrg[];    conversation.address ¬ @currentServer;    rc ¬ CH.LookupGroupProperty[      conversation, hint, CHPIDs.members, EachString, dummyDName !      NSName.NameTooSmall => IF NOT doDebug THEN CONTINUE;      UNWIND =>        {BumpProcessingCountLocked[]; conversation.address ¬ oldAddress};      Stop => CONTINUE];    conversation.address ¬ oldAddress;    ConvertElementArrayToAddressList[elementArray, currentElementArraySize];    FreeElementArray[elementArray, currentElementArraySize];    IF listHead # NIL THEN [] ¬ ProbeServerList[listHead, AddEachAddress];    --We used to add all potential addresses to the list if no one responded.    --IF NOT CheckOk[] THEN    --  FOR a: CHStubInternal.AddrList ¬ listHead, a.next UNTIL a = NIL DO    --    Add[a.address, FALSE]; ENDLOOP;    FreeAddrList[listHead];    ok ¬ CheckOk[];    BumpProcessingCountLocked[];    };  -- UNWIND block    END;  RestartTheCache: PUBLIC PROCEDURE =    BEGIN    SyncAndPass: ENTRY PROCEDURE RETURNS [pass: BOOLEAN ¬ FALSE] =      BEGIN      IF pleaseDoNotReadCloseDomains THEN RETURN;  -- some other process is in the RestartTheCache procedure      pass ¬ pleaseDoNotReadCloseDomains ¬ TRUE;      END;  -- SyncAndPass    DestroyCurrentCache: ENTRY PROCEDURE =      BEGIN      aWhile: CONDITION;      Process.InitializeCondition[@aWhile, Process.SecondsToTicks[5]];      WHILE processingHintCount > 0 DO WAIT aWhile; ENDLOOP;      closeDomains ¬ IncrementalSort.nullHandle;      orgTreeHead ¬ IncrementalSort.nullHandle;      unavailableDomains ¬ IncrementalSort.nullHandle;      -- next remake the heap      closeCH ¬ System.nullNetworkAddress;      IF myHeap # NIL THEN Heap.Flush[myHeap]      ELSE myHeap ¬ Heap.Create[        initial: 10, increment: 10, ownerChecking: doDebug,        checking: doDebug AND heapChecking];  -- no swap units      -- now get handles for new trees      orgTreeHead ¬ IncrementalSort.MakeSorter[FALSE, FALSE, TRUE, TRUE, myHeap];      closeDomains ¬ IncrementalSort.MakeSorter[        FALSE, FALSE, TRUE, TRUE, myHeap];      unavailableDomains ¬ IncrementalSort.MakeSorter[        FALSE, FALSE, FALSE, TRUE, myHeap];      END;  -- DestroyCurrentCache    ANewDomain: ENTRY CH.NameStreamProc =      BEGIN      domainTreeHandle: DomainTree ¬ AddNewOrg[orgTreeHead, currentName];      addresses: AddrList ¬ AddNewDomain[domainTreeHandle, currentName];      AddNewAddr[addrItem.address, addresses];      domainTreeHandle ¬ AddNewOrg[closeDomains, currentName];      [] ¬ AddNewDomain[domainTreeHandle, currentName];      END;  -- ANewDomain    GenerateServerAddresses: PROCEDURE RETURNS [l: CHStubInternal.AddrList] =      BEGIN      ringSize: CARDINAL ¬ CHProtocol.maxDistanceToNearByNets;      FOR i: CARDINAL IN [0..2) DO        l ¬ BuildPreferredCHServerAddrList[ringSize, findMostServersInShortTime];        IF l # NIL THEN EXIT;        ringSize ¬ CHProtocol.maxDistanceToAnyNets;        ENDLOOP;      END;    chServerAddrList: CHStubInternal.AddrList ¬ NIL;    addrItem: CHStubInternal.AddrList;    -- first get in sync with unprotected processes, then destroy the address cache    IF NOT SyncAndPass[] THEN RETURN;    DestroyCurrentCache[];    -- now get a list of network addresses of Clearinghouse servers.    -- do this by expanding ring broadcast to a small ring then to a larger one    chServerAddrList ¬ GenerateServerAddresses[];    -- for each address we received, find out which domains that server is serving    -- and add that info to the newly created cache    addrItem ¬ chServerAddrList;    WHILE addrItem # NIL DO      [] ¬ CHStubInternal.EnumerateYourDomains[        addrItem.address, ANewDomain !        NSName.NameTooSmall => IF NOT doDebug THEN CONTINUE];      addrItem ¬ addrItem.next;      ENDLOOP;    FreeAddrList[chServerAddrList];    pleaseDoNotReadCloseDomains ¬ FALSE;  -- this was set to TRUE under MONITOR protection at the beginning of the proc;  we don't really need protection to set it back to FALSE    CHStubInternal.PokeTheStub[];    END;  AddressMappingsInFlux: PUBLIC ENTRY PROCEDURE RETURNS [influx: BOOLEAN] =    BEGIN influx ¬ pleaseDoNotReadCloseDomains; END;  <<Make a list of the servers that speak the old protocol. This is for find remotes.>>  BuildCHServerAddrList: PUBLIC PROCEDURE [    maxRingSize: CARDINAL, action: ExpeditedCourier.ExpandingRingAction]    RETURNS [l: CHStubInternal.AddrList] =    {RETURN[BuildCHServerAddrListInternal[maxRingSize, action, old]]};      <<Make a list of the servers who speak the preferred protocol. Determine what the preferred protocol is.>>  BuildPreferredCHServerAddrList: PROCEDURE [    maxRingSize: CARDINAL, action: ExpeditedCourier.ExpandingRingAction]    RETURNS [l: CHStubInternal.AddrList] =    {RETURN[BuildCHServerAddrListInternal[maxRingSize, action, preferred]]};      BuildCHServerAddrListInternal: PROCEDURE [    maxRingSize: CARDINAL,    action: ExpeditedCourier.ExpandingRingAction, protocol: {old, preferred}]    RETURNS [l: CHStubInternal.AddrList ¬ NIL] =    BEGIN    -- this is a public procedure, so storage for it has to come from a heap    -- that's going to stay around for awhile.    ProbeReceiver: ExpeditedCourier.ResponseProc =      BEGIN      addr: System.NetworkAddress;      result: CHMUX.PEResult ¬ [procedure: chServerAddrProbe];      cr: Courier.Parameters = CHMUX.MakeReturnParameter[@result, FALSE, version];      prev, n, newAddr: CHStubInternal.AddrList;      error: BOOLEAN ¬ FALSE;      continue ¬ TRUE;      WITH header.body SELECT FROM return => NULL; ENDCASE => RETURN;      IF NOT ExpeditedCourier.DeserializeFromBlock[        cr, muxHeap, serializedResponse] THEN RETURN;      IF result.chServerNSAddr # NIL THEN        addr ¬ NSAddr.SelectNearestAddress[result.chServerNSAddr]      ELSE error ¬ TRUE;      CHMUX.FreeResult[@result];      IF error THEN RETURN;      prev ¬ NIL;      n ¬ l;      WHILE n # NIL DO        IF addr.host = n.address.host THEN RETURN; prev ¬ n; n ¬ n.next; ENDLOOP;      newAddr ¬ muxHeap.NEW[CHStubInternal.AddrObject];      newAddr­ ¬ [next: NIL, address: addr];      IF prev = NIL THEN l ¬ newAddr ELSE prev.next ¬ newAddr;      IF NSAddr.FirstNearerThanSecond[addr, closeCH] THEN closeCH ¬ addr;      serversFound ¬ serversFound + 1;      continue ¬ serversFound < maxServersFromExpandingRing;      END;  -- of ProbeReceiver    parm: CHMUX.PEParm ¬ [procedure: chServerAddrProbe];    cp: Courier.Parameters = CHMUX.MakeCallParameter[@parm, TRUE];    programNumber: LONG CARDINAL;    versionNumber: CARDINAL;    procedureNumber: CARDINAL;    ring: ExpeditedCourier.RingBound = [low: 0, high: maxRingSize];    version: CHProtocol.Version ¬       IF protocol = old THEN low ELSE CHProtocol.GetPreferredVersion[];    serversFound: CARDINAL ¬ 0;    [programNumber, versionNumber, procedureNumber] ¬ CHMUX.GetCourierInfo[      parm.procedure, version];    ExpeditedCourier.CallToInternetRing[      programNumber, versionNumber, procedureNumber, cp, ring,      CHProtocol.chSocket, action, ProbeReceiver, ];    IF l # NIL THEN RETURN;    IF protocol = old THEN RETURN;    IF CHProtocol.IsThereAnAlternateVersion[      programNumber, versionNumber, [      CHProtocol.actualLowCh2VersionNumber, CHProtocol.actualHighCh2VersionNumber]]      THEN      BEGIN      wrongVersion: CHProtocol.Version = version;      version ¬ CHProtocol.GetAlternateVersion[wrongVersion];      [programNumber, versionNumber, procedureNumber] ¬ CHMUX.GetCourierInfo[        parm.procedure, version];      ExpeditedCourier.CallToInternetRing[        programNumber, versionNumber, procedureNumber, cp, ring,        CHProtocol.chSocket, action, ProbeReceiver, ];      IF l # NIL THEN CHProtocol.AlterPreferredVersion[wrongVersion];      END;    END;  FreeAddrList: PUBLIC PROCEDURE [l: CHStubInternal.AddrList] =    BEGIN    temp: CHStubInternal.AddrList;    UNTIL l = NIL DO temp ¬ l; l ¬ l.next; muxHeap.FREE[@temp]; ENDLOOP;    END;  -- mainline code  Process.Detach[FORK RestartTheCache[]];  Process.Yield[];  END..LOG 6-Jan-83 15:58:33 - BLyon  5-Oct-83 13:44:36 - BLyon 11-Oct-83 18:03:40 - read   23-Nov-83 16:30:53 - Gealy - Convert to 8.0 CH & Auth  26-Jan-84  0:04:02 - Gealy - Changed ProcessHint and RestartTheCache  for protocol compatibility 10-Feb-84 16:03:19 - read - changed parameter to IncrementalSort.Destroy  18-Mar-84 21:20:51 - Gealy - BuildCHServerAddrList now has two flavors, one for FindRemotes, and the other for RestartTheCache. 20-May-84  0:32:26 - read - exported AuthCacheDefs. 8-Jun-84 16:47:58 - read - mechanism for the stub to remember when a domain is down.14-Jun-84 22:14:21 - Gealy - Use optimised string ops.17-Jun-84 15:49:03 - read - folded CHStubInternalExtras into CHStubInternal30-Aug-84 12:58:15 - Gealy - Removing adresses from cache.11-Apr-85 14:25:28 - Stucke - Probe reciever now uses closest ch addr for closeCH instead of the first addr found.  GetDefaultServerAddress uses FindANewCloseCH when closeCH is null.  It used to grab the first addr in the org/domain trees.  Reworked FindOrgAddrInternal to look in the domain tree for an org for an org address if we don't already have an or address.  Took out all references to passing a true value for addToHead when calling AddNewAddr.  Added InvalidateWrongServerAddr.  ProcessHint looks up addresses in the closeset CHS rather than in the currentServer.25-Apr-85 14:29:21 - Stucke - Monitor lock bug fix. 30-Aug-85 13:23:50 - AOF - Decrement hint count on UNWINDs from ProcessHint.  3-Oct-85 12:07:40 - AOF - Signal out of callback in ProcessHint (TooManyProcesses) 10-Jun-87 13:14:47 - AOF - Tuning heap (AR# 9601)  4-Mar-93 16:25:40 - WIrish & Racine - Worked on hint processing & cache management
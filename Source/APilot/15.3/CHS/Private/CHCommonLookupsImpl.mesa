-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --CHCommonLookupsImpl.mesa--last edited by Gealy,   9-Jul-84  3:51:24DIRECTORY  CH USING [    Buffer, BufferArea, BufferTooSmall, ConversationHandle, DeserializeFromRhs,    FreeRhs, LookupValueProperty, MakeRhs, maxBufferSize, Name, PropertyID,    ReturnCode],  CHCommonLookups USING [],  CHEntries USING [AddressList, DescribeAddressList, DescribePrimary],  CHPIDs USING [nsAddress],  CHSwitches USING [doStubDebug],  Courier USING [Description, Free, Parameters],  Environment USING [PageCount, wordsPerPage],  Heap USING [Create],  NSAddr USING [SelectNearestAddress],  NSName USING [CopyName, DescribeNameRecord, Name, NameRecord, String],  NSString USING [CopyString, nullString, String],  System USING [NetworkAddress, nullNetworkAddress];CHCommonLookupsImpl: MONITOR  IMPORTS CH, CHEntries, Courier, Heap, NSAddr, NSName, NSString  EXPORTS CHCommonLookups =  BEGIN  doDebugging: BOOLEAN = CHSwitches.doStubDebug;  LookupAddress: PUBLIC PROCEDURE [    conversation: CH.ConversationHandle, name: CH.Name]    RETURNS [      rc: CH.ReturnCode,      address: System.NetworkAddress ¬ System.nullNetworkAddress,      succeeded: BOOLEAN ¬ FALSE] =    BEGIN    Cleanup: PROC = {CH.FreeRhs[addrBuffer, privateHeap]};    addrBuffer: CH.Buffer      ¬ CH.MakeRhs[SIZE[System.NetworkAddress]+1, privateHeap];      --assume one address, plus the length field of the Courier array.    addressList: CHEntries.AddressList;    rc ¬ CH.LookupValueProperty[      conversation, name, CHPIDs.nsAddress, addrBuffer, NIL !      CH.BufferTooSmall =>        BEGIN        CH.FreeRhs[addrBuffer, privateHeap];        addrBuffer ¬ CH.MakeRhs[lengthNeeded, privateHeap];        RESUME [addrBuffer];        END; ];    IF rc.code # done THEN {Cleanup[]; RETURN};    succeeded ¬ CH.DeserializeFromRhs[      [@addressList, CHEntries.DescribeAddressList], privateHeap, addrBuffer];    IF NOT succeeded THEN {Cleanup[]; RETURN};    address ¬ NSAddr.SelectNearestAddress[addressList];    Courier.Free[[@addressList, CHEntries.DescribeAddressList], privateHeap];    Cleanup[];    END;  LookupStringProperty: PUBLIC ENTRY PROCEDURE [    conversation: CH.ConversationHandle, name: CH.Name, pid: CH.PropertyID,    heap: UNCOUNTED ZONE]    RETURNS [      rc: CH.ReturnCode, stringProperty: NSString.String ¬ NSString.nullString,      succeeded: BOOLEAN ¬ FALSE] =    BEGIN    s: NSString.String;    rc ¬ CH.LookupValueProperty[conversation, name, pid, buffer, NIL];    IF rc.code # done THEN RETURN;    succeeded ¬ CH.DeserializeFromRhs[      [@s, CHEntries.DescribePrimary], privateHeap, buffer];    IF NOT succeeded THEN RETURN;    --note that storage is allocated and freed twice, and data copied twice.    stringProperty ¬ NSString.CopyString[heap, s];    Courier.Free[[@s, CHEntries.DescribePrimary], privateHeap];    END;  LookupNameProperty: PUBLIC ENTRY PROCEDURE [    conversation: CH.ConversationHandle, name: CH.Name, pid: CH.PropertyID,    heap: UNCOUNTED ZONE]    RETURNS [      rc: CH.ReturnCode, nameProperty: NSName.Name ¬ NIL,      succeeded: BOOLEAN ¬ FALSE] =    BEGIN    tempNameRec: NSName.NameRecord;    rc ¬ CH.LookupValueProperty[conversation, name, pid, buffer, NIL];    IF rc.code # done THEN RETURN;    succeeded ¬ CH.DeserializeFromRhs[      [@tempNameRec, NSName.DescribeNameRecord], privateHeap, buffer];    IF NOT succeeded THEN RETURN;    --note that storage is allocated and freed twice, and data copied twice.    nameProperty ¬ NSName.CopyName[heap, @tempNameRec];    Courier.Free[[@tempNameRec, NSName.DescribeNameRecord], privateHeap];    END;  LookupAnyValueProperty: PUBLIC ENTRY PROCEDURE [    conversation: CH.ConversationHandle, name: CH.Name,    parameters: Courier.Parameters, pid: CH.PropertyID, heap: UNCOUNTED ZONE]    RETURNS [rc: CH.ReturnCode, succeeded: BOOLEAN ¬ FALSE] =    BEGIN    rc ¬ CH.LookupValueProperty[conversation, name, pid, buffer, NIL];    IF rc.code # done THEN RETURN;    succeeded ¬ CH.DeserializeFromRhs[parameters, heap, buffer];    END;  -- Mainline  -- This code is here to create a CH.Buffer, and create a heap for working space.  -- The buffer is allocated once and lives forever.  -- It is protected from concurrency by the monitor lock.  chBufferInWords: CARDINAL =    CH.maxBufferSize  -- BufferArea.data      + SIZE[CH.BufferArea];  -- BufferArea.maxlength, BufferArea.length  spacePages: Environment.PageCount =    1 + 1 +      (chBufferInWords + Environment.wordsPerPage - 1) / Environment.wordsPerPage;  -- Make sure there's a page of slop for owner checking, and about a page for deserialization.  privateHeap: UNCOUNTED ZONE ¬ Heap.Create[    initial: spacePages, maxSize: spacePages, swapUnitSize: 1,    largeNodeThreshold: chBufferInWords + 10, ownerChecking: doDebugging,    checking: doDebugging];  -- Allow slop for owner checking.  buffer: CH.Buffer ¬ CH.MakeRhs[CH.maxBufferSize, privateHeap];  END..  LOG 8-Dec-83 17:28:17 - Gealy  - created from CHLookupClientImpl 3-Jan-84  0:18:53 - Gealy  - improve failure mode handling. 9-Jul-84  3:51:20 - Gealy  - Give LookupAddress its own buffer, so it needn't be monitored.
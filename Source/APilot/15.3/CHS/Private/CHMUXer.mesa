-- File: CHMUXer.mesa - last edit:-- AOF                  7-Jan-87 18:27:57-- read                 15-Jun-84 16:12:23-- Copyright (C) 1984, 1987 by Xerox Corporation. All rights reserved. -- This provides the (de)serialization routing for the CH remote procedure callingDIRECTORY  Auth USING [    AuthenticationProblem, Credentials, DescribeCredentials, DescribeVerifier,    nullCredentials, nullVerifier, Verifier],  CH USING [    Buffer, BufferArea, Code, Name, NameRecord, PropertyID, ParameterGrouping],  CHProtocol USING [    ACLFlavor, actualChAccessControlVersionNumber, actualChsToChsVersionNumber,    actualHighCh2VersionNumber, actualLowCh2VersionNumber, Bool,    ch2ProgramsNumber, chAccessControlProgramsNumber, chsToChsProgramsNumber,    CourierProcedures, CourierProceduresToCardinals, maxProperties, Parms,    ProcsUseErrors, ProcsUseParms, ProcsUseResult, Version,    ResponseValue, Results, Timestamp, TimestampPtr, wrongServer],  CHMUX USING [    Parm, PEParm, PEResult, Result, slopAtEndOfParmRecord,    slopAtEndOfResultRecord],  CHStubInternal USING [AddressMappingsInFlux, RestartTheCache],  CHSwitches USING [doStubDebug],  Courier USING [Description, Free, NoteParameters, Parameters, VersionRange],  Environment USING [wordsPerPage],  Heap USING [Create, Handle],  NSAddr USING [Address, DescribeAddress],  NSDataStream USING [DescribeTicket, Ticket],  NSName USING [DescribeNameRecord],  NSString USING [DescribeString, String, StringFromMesaString],  Process USING [Pause, SecondsToTicks];CHMUXer: MONITOR  IMPORTS    Auth, CHProtocol, CHStubInternal, Courier, Heap, NSAddr, NSDataStream, NSName,    NSString, Process  EXPORTS CHMUX, CHProtocol, CHStubInternal =  BEGIN  --Monitored only for AlterPreferredVersion and GetPreferredVersion    doDebug: BOOLEAN = CHSwitches.doStubDebug;    chAccessControlVersionNumber: PUBLIC CARDINAL ¬    CHProtocol.actualChAccessControlVersionNumber;  chsToChsVersionNumber: PUBLIC CARDINAL ¬ CHProtocol.actualChsToChsVersionNumber;  ch2HighVersionNumber: PUBLIC CARDINAL ¬ CHProtocol.actualHighCh2VersionNumber;  ch2LowVersionNumber: PUBLIC CARDINAL ¬ CHProtocol.actualLowCh2VersionNumber;    preferredVersion: CHProtocol.Version ¬ high;  ch2VersionNumbers: ARRAY CHProtocol.Version OF CARDINAL = [    low: CHProtocol.actualLowCh2VersionNumber,    high: CHProtocol.actualHighCh2VersionNumber];  procsUseParms: PUBLIC CHProtocol.ProcsUseParms;  procsUseResult: PUBLIC CHProtocol.ProcsUseResult;  procsUseError: PUBLIC CHProtocol.ProcsUseErrors;  mesaShiftInName: LONG STRING = "CHServers";  shiftInName: PUBLIC NSString.String ¬ NSString.StringFromMesaString[    mesaShiftInName];  lastShiftedNameObject: CH.NameRecord ¬ [shiftInName, shiftInName, shiftInName];  lastShiftedName: PUBLIC CH.Name ¬ @lastShiftedNameObject;  genericCHSLocalString: LONG STRING = "Clearinghouse";  genericCHSNameRecord: CH.NameRecord ¬ [    org: shiftInName, domain: shiftInName,    local: NSString.StringFromMesaString[genericCHSLocalString]];  genericCHSName: PUBLIC CH.Name ¬ @genericCHSNameRecord;  heapChecking: BOOLEAN ¬ FALSE;  Error: PUBLIC ERROR = CODE;  muxHeap: Heap.Handle ¬ Heap.Create[    initial: 4, increment: 4, swapUnitSize: 1,    largeNodeThreshold: 2 * Environment.wordsPerPage, ownerChecking: doDebug,    checking: doDebug AND heapChecking];  GetMUXHeap: PUBLIC PROCEDURE RETURNS [h: Heap.Handle ¬ muxHeap] = {};  SetTestMode: PUBLIC PROCEDURE [on: BOOLEAN, testModeNumber: CARDINAL[0..100]] =    -- Dangerous to turn this off if there is a lovcal server!!!    BEGIN    IF on THEN      chAccessControlVersionNumber ¬ chsToChsVersionNumber        ¬ ch2HighVersionNumber ¬ ch2LowVersionNumber        ¬ (LAST[CARDINAL] - testModeNumber)    ELSE       BEGIN      chAccessControlVersionNumber        ¬ CHProtocol.actualChAccessControlVersionNumber;      chsToChsVersionNumber ¬ CHProtocol.actualChsToChsVersionNumber;      ch2HighVersionNumber ¬ CHProtocol.actualHighCh2VersionNumber;      ch2LowVersionNumber ¬ CHProtocol.actualLowCh2VersionNumber;      END;    WHILE CHStubInternal.AddressMappingsInFlux[] DO      Process.Pause[Process.SecondsToTicks[4]]; ENDLOOP;    -- there is a race here, but this code is just an optimization anyway.     CHStubInternal.RestartTheCache[];    END;  GetCourierInfo: PUBLIC PROCEDURE [    chProcedure: CHProtocol.CourierProcedures,    version: CHProtocol.Version]    RETURNS [      programNumber: LONG CARDINAL, versionNumber: CARDINAL,      procedureNumber: CARDINAL] =    BEGIN    procedureNumber ¬ CHProtocol.CourierProceduresToCardinals[chProcedure];    SELECT chProcedure FROM      IN [chServerAddrProbe..isMemberClosure] =>        BEGIN        programNumber ¬ CHProtocol.ch2ProgramsNumber;        versionNumber	  ¬ IF version = low THEN ch2LowVersionNumber ELSE ch2HighVersionNumber;        END;      IN [dumpObject..checkObject] =>        BEGIN        programNumber ¬ CHProtocol.chsToChsProgramsNumber;        versionNumber ¬ chsToChsVersionNumber;        END;      IN [retrievePropertyAccessList..getDomainSize] =>        BEGIN        programNumber ¬ CHProtocol.chAccessControlProgramsNumber;        versionNumber ¬ chAccessControlVersionNumber;        END;      ENDCASE => IF doDebug THEN ERROR;    END;  --protocol compatibility procedures.  AlterPreferredVersion: PUBLIC ENTRY PROCEDURE[undesirable: CHProtocol.Version] =    BEGIN    IF preferredVersion = undesirable THEN      preferredVersion ¬ GetAlternateVersion[undesirable];    END;  GetAlternateVersion: PUBLIC PROCEDURE [version: CHProtocol.Version]    RETURNS [CHProtocol.Version] = {    RETURN[IF version = low THEN high ELSE low]};  GetPreferredVersion: PUBLIC ENTRY PROCEDURE    RETURNS [version: CHProtocol.Version] = {    RETURN[preferredVersion]};    GetVersion: PUBLIC PROCEDURE[    programNumber: LONG CARDINAL, versionNumber: CARDINAL]    RETURNS[version: CHProtocol.Version] =    {RETURN[      IF programNumber = CHProtocol.ch2ProgramsNumber        AND versionNumber = CHProtocol.actualLowCh2VersionNumber THEN low      ELSE high]};  --We could be using a test protocol.  IsThereAnAlternateVersion: PUBLIC PROCEDURE [    programNumber: LONG CARDINAL, versionNumber: CARDINAL,    acceptable: Courier.VersionRange] RETURNS [BOOLEAN] =    BEGIN    RETURN[      programNumber = CHProtocol.ch2ProgramsNumber        AND          ((versionNumber = ch2VersionNumbers[low]             AND ch2VersionNumbers[high] IN [acceptable.low..acceptable.high])            OR              (versionNumber = ch2VersionNumbers[high]                AND (ch2VersionNumbers[low] IN		  [acceptable.low..acceptable.high] 		  OR acceptable = [1, 1])))];	        -- acceptable = [1, 1] when talking to a Services 5.0 server		-- Services 5.0 servers also support [2, 2], but Courier only		-- tells us about the older version, and thus this hack.    END;  DescribeAuthResults: Courier.Description =    BEGIN [] ¬ notes.noteSize[SIZE[Auth.AuthenticationProblem]]; END;  DescribeParm: Courier.Description =    BEGIN    DescribeCHPartialName: Courier.Description =      BEGIN      name: CH.Name ¬ notes.noteSize[SIZE[CH.NameRecord]];      SELECT use.nameOrg FROM        TRUE => {notes.noteParameters[@name.org, NSString.DescribeString]; };        ENDCASE => {notes.noteDeadSpace[@name.org, SIZE[NSString.String]]; };      SELECT use.nameDomain FROM        TRUE => {notes.noteParameters[@name.domain, NSString.DescribeString]; };        ENDCASE => {notes.noteDeadSpace[@name.domain, SIZE[NSString.String]]; };      SELECT use.nameLocal FROM        TRUE => {notes.noteParameters[@name.local, NSString.DescribeString]; };        ENDCASE => {notes.noteDeadSpace[@name.local, SIZE[NSString.String]]; };      END;    parms: CHMUX.Parm ¬ notes.noteSize[SIZE[CHMUX.PEParm]];    use: CHProtocol.Parms ¬ procsUseParms[parms.procedure];    -- we always allocate a chName, even if all its string are null    notes.noteDisjointData[@parms.chName, DescribeCHPartialName];    SELECT use.pn FROM      TRUE => {notes.noteLongCardinal[@parms.pn]; };      ENDCASE => {notes.noteDeadSpace[@parms.pn, SIZE[LONG CARDINAL]]; };    SELECT use.aclist FROM      TRUE => { --notes.noteWORD[@parms.aclist];-- };      ENDCASE => {        notes.noteDeadSpace[@parms.aclist, SIZE[CHProtocol.ACLFlavor]]; };    SELECT use.pn2 FROM      TRUE => {notes.noteLongCardinal[@parms.pn2]; };      ENDCASE => {notes.noteDeadSpace[@parms.pn2, SIZE[LONG CARDINAL]]; };    SELECT use.element FROM      TRUE => {        notes.noteDisjointData[@parms.element, NSName.DescribeNameRecord]; };      ENDCASE => {notes.noteDeadSpace[@parms.element, SIZE[CH.Name]]; };    SELECT use.rhs FROM      TRUE => {        DescribeBufferArea: Courier.Description =          BEGIN          rhs: CH.Buffer ¬ notes.noteSize[SIZE[CH.BufferArea] + parms.rhsLength];          notes.noteDeadSpace[@rhs.maxlength, SIZE[CARDINAL]];  -- this never goes out on the wire          notes.noteDeadSpace[@rhs.length, SIZE[CARDINAL]];  -- this has been noted via "rhsLength"          -- the data portion now comes-in-from / goes-out-to the wire.          rhs.length ¬ parms.rhsLength;          rhs.maxlength ¬ MAX[rhs.maxlength, rhs.length];          END;        -- note CARDINAL WORD value  in parm.rhsLength --        notes.noteDisjointData[@parms.rhs, DescribeBufferArea];        };      ENDCASE => {        notes.noteDeadSpace[@parms.rhsLength, SIZE[CARDINAL] + SIZE[CH.Buffer]];        };    SELECT use.sourceOrSink FROM      TRUE => {        notes.noteDisjointData[@parms.sourceOrSink, NSDataStream.DescribeTicket];        };      ENDCASE => {        notes.noteDeadSpace[          @parms.sourceOrSink, SIZE[LONG POINTER TO NSDataStream.Ticket]];        };    SELECT use.gtsAndChecksum FROM      TRUE => {notes.noteDisjointData[@parms.gts, DescribeTimestamp]; };      ENDCASE => {        notes.noteDeadSpace[          @parms.gts, SIZE[CHProtocol.TimestampPtr] + SIZE[CARDINAL]];        };    SELECT use.credAndVer FROM      TRUE => {        notes.noteParameters[@parms.cred, Auth.DescribeCredentials];        notes.noteParameters[@parms.ver, Auth.DescribeVerifier];        };      ENDCASE => {        notes.noteDeadSpace[          @parms.cred, SIZE[Auth.Credentials] + SIZE[Auth.Verifier]]};    notes.noteDeadSpace[      @parms.ver + SIZE[Auth.Verifier], CHMUX.slopAtEndOfParmRecord];  -- skip non-wire stuff    END;  DescribeTimestamp: PUBLIC Courier.Description =    BEGIN    time: CHProtocol.TimestampPtr = notes.noteSize[SIZE[CHProtocol.Timestamp]];    notes.noteLongCardinal[@LOOPHOLE[time.gmt, LONG CARDINAL]];    END;  FreeParm: PUBLIC PROCEDURE [parm: CHMUX.Parm] =    BEGIN    Courier.Free[MakeCallParameter[parm, FALSE], muxHeap];    parm.chName ¬ parm.element ¬ NIL;    parm.ver ¬ Auth.nullVerifier;    parm.cred ¬ Auth.nullCredentials;    parm.rhs ¬ NIL;    parm.sourceOrSink ¬ NIL;    END;  MakeCallParameter: PUBLIC PROCEDURE [parm: CHMUX.Parm, sending: BOOLEAN]    RETURNS [Courier.Parameters] =    BEGIN    IF sending THEN      BEGIN      parm.rhsLength ¬        SELECT procsUseParms[parm.procedure].rhs FROM          TRUE => parm.rhs.length,          ENDCASE => 0;      END;    RETURN[Courier.Parameters[parm, DescribeParm]];    END;  DescribeOldResult: Courier.Description =    BEGIN    results: CHMUX.Result ¬ notes.noteSize[SIZE[CHMUX.PEResult]];    use: CHProtocol.Results ¬      SELECT results.responseValue FROM        successfulReturn => procsUseResult[results.procedure],        ENDCASE => procsUseError[results.responseValue];    SELECT use.code FROM      TRUE => { -- note WORD -- };      ENDCASE => {notes.noteDeadSpace[@results.code, SIZE[CH.Code]]; };    --position of nameFound between code and which causes grief.    SELECT use.nameFound FROM      TRUE => { -- note WORD -- };      ENDCASE => {        notes.noteDeadSpace[@results.nameFound, SIZE[CHProtocol.Bool]]; };    SELECT use.which FROM      TRUE => { -- note WORD -- };      ENDCASE => {        notes.noteDeadSpace[@results.which, SIZE[CH.ParameterGrouping]]; };    SELECT use.authenResults FROM      TRUE => {        notes.noteParameters[@results.authenticationResults, DescribeAuthResults];        };      ENDCASE => {        notes.noteDeadSpace[          @results.authenticationResults, SIZE[Auth.AuthenticationProblem]]};    SELECT use.bool FROM      TRUE => { -- note BOOLEAN WORD -- };      ENDCASE => {notes.noteDeadSpace[@results.bool, SIZE[CHProtocol.Bool]]; };    SELECT use.dn FROM      TRUE => {notes.noteDisjointData[@results.dn, NSName.DescribeNameRecord]; };      ENDCASE => {notes.noteDeadSpace[@results.dn, SIZE[CH.Name]]; };    SELECT use.hint FROM      TRUE => {        notes.noteDisjointData[@results.hint, NSName.DescribeNameRecord];        results.code ¬ CHProtocol.wrongServer;        -- NOTE that we set a code here since the protocol does not deliver it!        };      ENDCASE => {notes.noteDeadSpace[@results.hint, SIZE[CH.Name]]; };    SELECT use.rhs FROM      TRUE => {        DescribeBufferArea: Courier.Description =          BEGIN          rhs: CH.Buffer ¬ notes.noteSize[            SIZE[CH.BufferArea] + results.rhsLength];          notes.noteDeadSpace[@rhs.maxlength, SIZE[CARDINAL]];  -- this never goes out on the wire          notes.noteDeadSpace[@rhs.length, SIZE[CARDINAL]];  -- this has been noted via "rhsLength"          -- the data portion now comes-in-from / goes-out-to the wire.          rhs.length ¬ results.rhsLength;          rhs.maxlength ¬ MAX[rhs.maxlength, rhs.length];          END;        -- note CARDINAL WORD value  in parm.rhsLength --        notes.noteDisjointData[@results.rhs, DescribeBufferArea];        };      ENDCASE => {        notes.noteDeadSpace[@results.rhsLength, SIZE[CARDINAL] + SIZE[CH.Buffer]];        };    SELECT use.properties FROM      TRUE => {        notes.noteArrayDescriptor[          @results.properties, SIZE[CH.PropertyID], CHProtocol.maxProperties];        };      ENDCASE => {        notes.noteDeadSpace[          @results.properties, SIZE[LONG DESCRIPTOR FOR ARRAY OF CH.PropertyID]];        };    SELECT use.chServerNSAddr FROM      TRUE => {        notes.noteParameters[@results.chServerNSAddr, NSAddr.DescribeAddress]; };      ENDCASE => {        notes.noteDeadSpace[@results.chServerNSAddr, SIZE[NSAddr.Address]]; };    notes.noteDeadSpace[      @results.chServerNSAddr + SIZE[NSAddr.Address],      CHMUX.slopAtEndOfResultRecord];  -- skip non-wire stuff    END;  DescribeNewResult: Courier.Description =    BEGIN    results: CHMUX.Result ¬ notes.noteSize[SIZE[CHMUX.PEResult]];    use: CHProtocol.Results ¬      SELECT results.responseValue FROM        successfulReturn => procsUseResult[results.procedure],        ENDCASE => procsUseError[results.responseValue];    SELECT use.code FROM      TRUE => { -- note WORD -- };      ENDCASE => {notes.noteDeadSpace[@results.code, SIZE[CH.Code]]; };    --position of nameFound between code and which causes grief.    SELECT use.nameFound FROM      TRUE => { -- note WORD -- };      ENDCASE => {        notes.noteDeadSpace[@results.nameFound, SIZE[CHProtocol.Bool]]; };    SELECT use.which FROM      TRUE => { -- note WORD -- };      ENDCASE => {        notes.noteDeadSpace[@results.which, SIZE[CH.ParameterGrouping]]; };    SELECT use.authenResults FROM      TRUE => {        notes.noteParameters[@results.authenticationResults, DescribeAuthResults];        };      ENDCASE => {        notes.noteDeadSpace[          @results.authenticationResults, SIZE[Auth.AuthenticationProblem]]};    SELECT use.bool FROM      TRUE => { -- note BOOLEAN WORD -- };      ENDCASE => {notes.noteDeadSpace[@results.bool, SIZE[CHProtocol.Bool]]; };    SELECT use.dn FROM      TRUE => {notes.noteDisjointData[@results.dn, NSName.DescribeNameRecord]; };      ENDCASE => {notes.noteDeadSpace[@results.dn, SIZE[CH.Name]]; };    SELECT use.hint FROM      TRUE => {        notes.noteDisjointData[@results.hint, NSName.DescribeNameRecord];        results.code ¬ CHProtocol.wrongServer;        -- NOTE that we set a code here since the protocol does not deliver it!        };      ENDCASE => {notes.noteDeadSpace[@results.hint, SIZE[CH.Name]]; };    SELECT use.rhs FROM      TRUE => {        DescribeBufferArea: Courier.Description =          BEGIN          rhs: CH.Buffer ¬ notes.noteSize[            SIZE[CH.BufferArea] + results.rhsLength];          notes.noteDeadSpace[@rhs.maxlength, SIZE[CARDINAL]];  -- this never goes out on the wire          notes.noteDeadSpace[@rhs.length, SIZE[CARDINAL]];  -- this has been noted via "rhsLength"          -- the data portion now comes-in-from / goes-out-to the wire.          rhs.length ¬ results.rhsLength;          rhs.maxlength ¬ MAX[rhs.maxlength, rhs.length];          END;        -- note CARDINAL WORD value  in parm.rhsLength --        notes.noteDisjointData[@results.rhs, DescribeBufferArea];        };      ENDCASE => {        notes.noteDeadSpace[@results.rhsLength, SIZE[CARDINAL] + SIZE[CH.Buffer]];        };    SELECT use.properties FROM      TRUE => {        notes.noteArrayDescriptor[          @results.properties, SIZE[CH.PropertyID], CHProtocol.maxProperties];        FOR i: CARDINAL IN [0..LENGTH[results.properties]) DO          notes.noteLongCardinal[@results.properties[i]]; ENDLOOP};      ENDCASE => {        notes.noteDeadSpace[          @results.properties, SIZE[LONG DESCRIPTOR FOR ARRAY OF CH.PropertyID]];        };    SELECT use.chServerNSAddr FROM      TRUE => {        notes.noteParameters[@results.chServerNSAddr, NSAddr.DescribeAddress]; };      ENDCASE => {        notes.noteDeadSpace[@results.chServerNSAddr, SIZE[NSAddr.Address]]; };    notes.noteDeadSpace[      @results.chServerNSAddr + SIZE[NSAddr.Address],      CHMUX.slopAtEndOfResultRecord];  -- skip non-wire stuff    END;  FreeResult: PUBLIC PROCEDURE [result: CHMUX.Result] =    BEGIN    Courier.Free[MakeReturnParameter[result, FALSE, low], muxHeap];    --low, because we know it has the same storage characteristics as high.    result.dn ¬ result.hint ¬ NIL;    result.rhs ¬ NIL;    result.properties ¬ DESCRIPTOR[LONG[NIL], 0];    result.chServerNSAddr ¬ DESCRIPTOR[LONG[NIL], 0];    END;  MakeReturnParameter: PUBLIC PROCEDURE [    result: CHMUX.Result, sending: BOOLEAN, version: CHProtocol.Version]    RETURNS [Courier.Parameters] =    BEGIN    IF sending AND result.responseValue = successfulReturn      AND procsUseResult[result.procedure].rhs THEN      result.rhsLength ¬ result.rhs.length;    RETURN[      IF version = low THEN Courier.Parameters[result, DescribeOldResult]      ELSE Courier.Parameters[result, DescribeNewResult]];    END;  END..  LOG13-Dec-82  9:39:19 - BLyon 29-Dec-82 17:13:27 - Johnsson - Heap changes  5-Oct-83 15:04:35 - BLyon11-Oct-83 19:29:22 - read 30-Sep-83 17:12:08 - Stucke  15-Nov-83 12:20:02 - Gealy - Replaced CH.Result with Auth.AuthenticationProblem for Auth error serialization.  26-Jan-84  0:38:46 - Gealy - Support multiple CH2 protocol versions  13-Feb-84 12:34:42 - Gealy - Let test mode be turned off for stub  29-Apr-84 22:27:08 - read -  changed determination of program and version numbers to include the proc getDomainSize15-Jun-84 16:01:47 - read - hacked IsThereAnAlternateVersion 7-Jan-87 18:27:16 - AOF - Minor tweeks for MDS Relief
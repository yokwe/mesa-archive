-- File: NSAddrImpl.mesa - last edit:-- AOF                 30-Jun-86 11:29:11-- Gealy               13-Apr-84 19:26:56-- Copyright (C) 1984, 1986 by Xerox Corporation. All rights reserved. DIRECTORY  ByteBlt USING [StartIndexGreaterThanStopIndexPlusOne],  CH USING [Buffer, SerializeIntoRhs],  CHMUX USING [GetMUXHeap],  Courier USING [Description, DeserializeParameters, Error, Free],  CHProtocol USING [maxAddresses],  Environment USING [Block],  MemoryStream USING [Create, Destroy, IndexOutOfRange],  NSAddr USING [Address],  NSConstants USING [unknownSocketID],  Process USING [Detach, Pause, SecondsToTicks, Ticks],  Router USING [    endEnumeration, EnumerateRoutingTable, FindDestinationRelativeNetID,    FindMyHostID, GetDelayToNet, infinity, NoTableEntryForNet, startEnumeration],  Stream USING [Handle],  System USING [    HostNumber, NetworkAddress, NetworkNumber, nullNetworkAddress,    nullNetworkNumber, SocketNumber];NSAddrImpl: PROGRAM  IMPORTS ByteBlt, CH, CHMUX, Courier, MemoryStream, Process, Router  EXPORTS NSAddr  =  BEGIN  myAddress: PUBLIC NSAddr.Address;  myAddressBuffer: PUBLIC CH.Buffer;    myHeap: UNCOUNTED ZONE ¬ CHMUX.GetMUXHeap[];  myHost: PUBLIC System.HostNumber ¬ Router.FindMyHostID[];  FirstNearerThanSecond: PUBLIC PROCEDURE [first, second: System.NetworkAddress]    RETURNS [itIs: BOOLEAN] =    BEGIN    delay1, delay2: CARDINAL ¬ Router.infinity;    SELECT TRUE FROM      (first.host = myHost) => RETURN[TRUE];      (second.host = myHost) => RETURN[FALSE];      (first = System.nullNetworkAddress) => RETURN[FALSE];      (second = System.nullNetworkAddress) => RETURN[TRUE];      ENDCASE;    delay1 ¬ Router.GetDelayToNet[first.net !      Router.NoTableEntryForNet => CONTINUE];    delay2 ¬ Router.GetDelayToNet[second.net !      Router.NoTableEntryForNet => CONTINUE];    RETURN[delay1 < delay2];    END;  FreeRhsStorage: PUBLIC PROCEDURE [rhs: CH.Buffer] = {myHeap.FREE[@rhs]};  -- - - - - - - Address impls - - - - - --  --  DescribeAddress: PUBLIC Courier.Description =    BEGIN    address: LONG POINTER TO NSAddr.Address ¬ notes.noteSize[SIZE[NSAddr.Address]];    notes.noteArrayDescriptor[      address, SIZE[System.NetworkAddress], CHProtocol.maxAddresses];    END;  RhsToAddress: PUBLIC PROCEDURE [rhs: CH.Buffer]    RETURNS [succeeded: BOOLEAN ¬ TRUE, address: NSAddr.Address] =    BEGIN    blk: Environment.Block = [LOOPHOLE[@rhs.data], 0, 2 * rhs.length];    sH: Stream.Handle = MemoryStream.Create[blk];    Courier.DeserializeParameters[      [@address, DescribeAddress], sH, myHeap !      MemoryStream.IndexOutOfRange => {succeeded ¬ FALSE; CONTINUE};      Courier.Error => {succeeded ¬ FALSE; CONTINUE};      ByteBlt.StartIndexGreaterThanStopIndexPlusOne => {        succeeded ¬ FALSE; CONTINUE}];    MemoryStream.Destroy[sH];    IF NOT succeeded THEN address ¬ DESCRIPTOR[NIL, 0];    END;  FreeAddress: PUBLIC PROCEDURE [address: NSAddr.Address]    RETURNS [nullAddress: NSAddr.Address] =    BEGIN    nullAddress ¬ DESCRIPTOR[NIL, 0];    Courier.Free[[@address, DescribeAddress], myHeap ! Courier.Error => CONTINUE];    END;  AddressToRhs: PUBLIC PROCEDURE [address: NSAddr.Address]    RETURNS [rhs: CH.Buffer] =    BEGIN rhs ¬ CH.SerializeIntoRhs[[@address, DescribeAddress], myHeap]; END;  SelectNearestAddress: PUBLIC PROCEDURE [address: NSAddr.Address]    RETURNS [na: System.NetworkAddress] =    BEGIN    IF BASE[address] = NIL OR LENGTH[address] = 0 THEN      RETURN[System.nullNetworkAddress];    na ¬ address[0];    FOR i: CARDINAL IN [1..LENGTH[address]) DO      IF FirstNearerThanSecond[address[i], na] THEN na ¬ address[i]; ENDLOOP;    END;  CompareAddresses: PUBLIC PROCEDURE [    a, b: NSAddr.Address, ignoreSockets, ignoreNets: BOOLEAN]    RETURNS [similar: BOOLEAN] =    BEGIN    Compare: PROCEDURE [x, y: NSAddr.Address] RETURNS [similar: BOOLEAN ¬ TRUE] =      BEGIN      FOR i: CARDINAL IN [0..LENGTH[x]) DO        similar ¬ FALSE;        FOR j: CARDINAL IN [0..LENGTH[y]) DO          similar ¬ y[j].host = x[i].host            AND (ignoreSockets OR y[j].socket = x[i].socket)            AND (ignoreNets OR y[j].net = x[i].net);          IF similar THEN EXIT;          ENDLOOP;        IF NOT similar THEN EXIT;        ENDLOOP;      END;    similar ¬ Compare[a, b];    IF similar THEN similar ¬ Compare[b, a];    END;  GetAddress: PUBLIC PROCEDURE RETURNS [address: NSAddr.Address] =    BEGIN    i: CARDINAL ¬ 0;    net: System.NetworkNumber ¬ Router.startEnumeration;    numOfNets: CARDINAL ¬ 0;    sequenceOfNA: TYPE = RECORD [      SEQUENCE COMPUTED CARDINAL OF System.NetworkAddress];    sequencePointer: LONG POINTER TO sequenceOfNA;    WHILE net # Router.endEnumeration DO      IF net # Router.startEnumeration AND net # System.nullNetworkNumber THEN        numOfNets ¬ numOfNets + 1;      net ¬ Router.EnumerateRoutingTable[net, 0];      ENDLOOP;    IF numOfNets = 0 THEN      BEGIN      addr: LONG POINTER TO System.NetworkAddress        ¬ myHeap.NEW[System.NetworkAddress];      address ¬ DESCRIPTOR[addr, 1];      address[0] ¬ [        net: Router.FindDestinationRelativeNetID[System.nullNetworkNumber],	host: myHost, socket: NSConstants.unknownSocketID];      RETURN;      END;    sequencePointer ¬ myHeap.NEW[sequenceOfNA [numOfNets]];    address ¬ DESCRIPTOR[sequencePointer, numOfNets];    net ¬ Router.startEnumeration;    WHILE net # Router.endEnumeration DO      IF net # Router.startEnumeration AND net # System.nullNetworkNumber THEN        BEGIN        IF i >= numOfNets THEN EXIT;        address[i] ¬ [net: net, host: myHost, socket: NSConstants.unknownSocketID];        address ¬ DESCRIPTOR[BASE[address], i ¬ i + 1];        END;      net ¬ Router.EnumerateRoutingTable[net, 0];      ENDLOOP;    END;  --??? suitable for concurrent access? Is concurrent access necessary?  Init: PROCEDURE =    BEGIN    dying: NSAddr.Address;    aWhile: Process.Ticks = Process.SecondsToTicks[5];    WHILE myAddress[0].net = System.nullNetworkNumber DO      Process.Pause[aWhile];      dying ¬ myAddress;      myAddress ¬ GetAddress[];      dying ¬ FreeAddress[dying]; --clients might hold dangling references!      ENDLOOP;    myAddressBuffer ¬ AddressToRhs[myAddress];    END;  myAddress ¬ GetAddress[];  myAddressBuffer ¬ AddressToRhs[myAddress];  IF myAddress[0].net = System.nullNetworkNumber THEN Process.Detach[FORK Init[]];  END..LOG15-Oct-82 16:13:02 - BLyon 18-Oct-83 17:48:58 - read  15-Nov-83 14:47:04 - gealy - Converted to 8.0 NSAddr. Removed references to  NSAddr.NSAddr.   2-Jan-84 23:47:50 - Gealy - Made myHost PUBLIC.  13-Apr-84 19:26:47 - Gealy - number of nets = 0. Init massaged to avoid  client bounds faults.  30-Jun-86 11:05:47 - AOF - Don't Fill table in "FirstNearerThanSecond"  
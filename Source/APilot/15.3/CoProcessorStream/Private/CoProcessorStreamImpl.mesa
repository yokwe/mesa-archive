-- CoProcessorStreamImpl.mesa   Last edited by RSV on 16-Sep-93 14:32:31-- Copyright (C) 1990, 1993 by Xerox Corporation.  All rights reserved.DIRECTORY  CoProcessorFace USING [Connection, ConnectionRec, connectionRecAlignment, connectionRecSize, Get, GetSST, Initialize, InitializeCleanup, InitiateConnection, InitiateDisconnection, Poll, Put, SetSST, Status],  CoProcessorStream,  CoProcessorStreamOps USING [CPSHandle, CPSObject],  Environment USING [Base, bytesPerPage, first64K, PageNumber, wordsPerPage],  Heap USING [Create],  Inline USING [LowHalf],  Process USING [Detach, SecondsToTicks, SetTimeout],  ResidentHeap USING [FreeNode, MakeNode],  Runtime USING [IsBound],  Space USING [Allocate, Deallocate, Interval, nullInterval, PageFromLongPointer],  SpecialRuntime USING [AllocateNakedCondition],  Stream USING [defaultObject, DeleteProcedure, EndOfStream, EndRecord, GetProcedure, GetSSTProcedure, GetTimeoutProcedure, Handle, InvalidOperation, PutProcedure, SetSSTProcedure, SetTimeoutProcedure, SSTChange, TimeOut],  System USING [GetGreenwichMeanTime, SecondsSinceEpoch],  VM USING [ScratchMap, Unmap];CoProcessorStreamImpl: MONITOR  IMPORTS CoProcessorFace, Heap, Inline, Process, ResidentHeap, Runtime, Space, SpecialRuntime, Stream, System, VM  EXPORTS CoProcessorStream =  BEGIN  OPEN CoProcessorStreamOps;    -- TYPEs    ServerID: TYPE = CoProcessorStream.ServerID;    -- Constants  coProcessorExists: BOOLEAN =   	Runtime.IsBound[LOOPHOLE[CoProcessorFace.Initialize]];  useDefaultBufferPages: CARDINAL = CoProcessorStream.useDefaultBufferPages;  -- Globals  zone: UNCOUNTED ZONE ¬ NIL;  rebroadcast, readyForDelete, faceAvailable: CONDITION;  defaultBufferPages: CARDINAL ¬ 4;  -- PUBLIC PROCs  CreateStream: PUBLIC ENTRY PROC [serverID: ServerID, putPages, getPages: CARDINAL]    RETURNS [Stream.Handle] =    BEGIN    ENABLE UNWIND => NULL;    conn: CoProcessorFace.Connection;    bufferInterval: Space.Interval;    cpsStream: CPSHandle;    IF NOT coProcessorExists THEN RETURN[NIL];    [conn, bufferInterval] ¬ EstablishConnection[serverID, putPages, getPages];    IF conn = NIL THEN RETURN[NIL];    cpsStream ¬ zone.NEW[CPSObject ¬ [    	Stream.defaultObject, conn, bufferInterval]];    cpsStream.streamObject.get ¬ CPSGet;    cpsStream.streamObject.put ¬ CPSPut;    cpsStream.streamObject.delete ¬ CPSDelete;    cpsStream.streamObject.getSST ¬ CPSGetSST;    cpsStream.streamObject.setSST ¬ CPSSetSST;    cpsStream.streamObject.getTimeout ¬ CPSGetTimeout;    cpsStream.streamObject.setTimeout ¬ CPSSetTimeout;    RETURN[@cpsStream.streamObject]    END;  AcceptStream: PUBLIC ENTRY PROC [serverID: ServerID, putPages, getPages: CARDINAL]    RETURNS [Stream.Handle] =    BEGIN    ENABLE UNWIND => NULL;    conn: CoProcessorFace.Connection;    bufferInterval: Space.Interval;    cpsStream: CPSHandle;    IF NOT coProcessorExists THEN RETURN[NIL];    [conn, bufferInterval] ¬ EstablishConnection[serverID, putPages, getPages, TRUE];    IF conn = NIL THEN RETURN[NIL];    cpsStream ¬ zone.NEW[CPSObject ¬ [Stream.defaultObject, conn, bufferInterval]];    cpsStream.streamObject.get ¬ CPSGet;    cpsStream.streamObject.put ¬ CPSPut;    cpsStream.streamObject.delete ¬ CPSDelete;    cpsStream.streamObject.getSST ¬ CPSGetSST;    cpsStream.streamObject.setSST ¬ CPSSetSST;    cpsStream.streamObject.getTimeout ¬ CPSGetTimeout;    cpsStream.streamObject.setTimeout ¬ CPSSetTimeout;    RETURN[@cpsStream.streamObject]    END;  -- PRIVATE PROCs  CPSDelete: ENTRY Stream.DeleteProcedure =    BEGIN    ENABLE UNWIND => NULL;    cpsStream: CPSHandle = LOOPHOLE[sH];    IF cpsStream.deleteInProgress THEN RETURN;    cpsStream.deleteInProgress ¬ TRUE;    WHILE cpsStream.putInProgress OR cpsStream.getInProgress DO      BROADCAST rebroadcast;      WAIT readyForDelete    ENDLOOP;    IF cpsStream.connection # NIL      THEN DisestablishConnection[cpsStream.connection, cpsStream.bufferInterval];    zone.FREE[@sH]    END;  CPSGet: ENTRY Stream.GetProcedure =    BEGIN    ENABLE UNWIND => NULL;    cpsStream: CPSHandle = LOOPHOLE[sH];    timeout: LONG CARDINAL ¬ GetSeconds[] + cpsStream.waitTime / 1000 + 1;    IF cpsStream.connection = NIL OR cpsStream.getInProgress OR cpsStream.deleteInProgress      THEN RETURN WITH ERROR Stream.InvalidOperation;    cpsStream.getInProgress ¬ TRUE;    bytesTransferred ¬ 0;    UNTIL cpsStream.deleteInProgress DO      ENABLE UNWIND =>        BEGIN	cpsStream.getInProgress ¬ FALSE;	IF cpsStream.deleteInProgress THEN BROADCAST readyForDelete;	END;      bytesThisTransfer: CARDINAL;      [bytesThisTransfer, why, sst] ¬ CoProcessorFace.Get[cpsStream.connection, block];      bytesTransferred ¬ bytesTransferred + bytesThisTransfer;      block.startIndex ¬ block.startIndex + bytesThisTransfer;      SELECT why FROM        sstChange => IF options.signalSSTChange          THEN SIGNAL Stream.SSTChange[sst, block.startIndex];        endOfStream =>	  BEGIN	  IF options.signalEndOfStream            THEN SIGNAL Stream.EndOfStream[block.startIndex];	  EXIT	  END;        endRecord =>          BEGIN	  IF options.signalEndRecord            THEN SIGNAL Stream.EndRecord[block.startIndex];          IF options.terminateOnEndRecord THEN EXIT;	  END;        ENDCASE;      IF block.startIndex >= block.stopIndexPlusOne THEN EXIT;      IF GetSeconds[] > timeout THEN        BEGIN	IF options.signalTimeout THEN SIGNAL Stream.TimeOut[block.startIndex] ELSE	  BEGIN	  why ¬ timeout;	  EXIT	  END;	timeout ¬ GetSeconds[] + cpsStream.waitTime / 1000 + 1	END;      WAIT rebroadcast    ENDLOOP;    cpsStream.getInProgress ¬ FALSE;    IF cpsStream.deleteInProgress THEN BROADCAST readyForDelete;    END;  CPSGetSST: ENTRY Stream.GetSSTProcedure =    BEGIN    cpsStream: CPSHandle = LOOPHOLE[sH];    sst ¬ (IF cpsStream.connection = NIL THEN 0      ELSE CoProcessorFace.GetSST[cpsStream.connection])    END;  CPSGetTimeout: ENTRY Stream.GetTimeoutProcedure =    BEGIN    cpsStream: CPSHandle = LOOPHOLE[sH];    RETURN[cpsStream.waitTime]    END;  CPSPut: ENTRY Stream.PutProcedure =    BEGIN    ENABLE UNWIND => NULL;    cpsStream: CPSHandle = LOOPHOLE[sH];    timeout: LONG CARDINAL ¬ GetSeconds[] + cpsStream.waitTime / 1000 + 1;    IF cpsStream.connection = NIL OR cpsStream.putInProgress OR cpsStream.deleteInProgress      THEN RETURN WITH ERROR Stream.InvalidOperation;    cpsStream.putInProgress ¬ TRUE;    UNTIL cpsStream.deleteInProgress DO      ENABLE UNWIND =>        BEGIN	cpsStream.putInProgress ¬ FALSE;	IF cpsStream.deleteInProgress THEN BROADCAST readyForDelete;	END;      bytesThisTransfer: CARDINAL ¬        CoProcessorFace.Put[cpsStream.connection, block, endRecord];      block.startIndex ¬ block.startIndex + bytesThisTransfer;      IF block.startIndex >= block.stopIndexPlusOne THEN EXIT;      IF GetSeconds[] > timeout THEN	BEGIN	SIGNAL Stream.TimeOut[block.startIndex];	timeout ¬ GetSeconds[] + cpsStream.waitTime / 1000 + 1	END;      WAIT rebroadcast    ENDLOOP;    cpsStream.putInProgress ¬ FALSE;    IF cpsStream.deleteInProgress THEN BROADCAST readyForDelete;    END;  CPSSetSST: ENTRY Stream.SetSSTProcedure =    BEGIN    ENABLE UNWIND => NULL;    cpsStream: CPSHandle = LOOPHOLE[sH];    timeout: LONG CARDINAL ¬ GetSeconds[] + cpsStream.waitTime / 1000 + 1;    IF cpsStream.connection = NIL OR cpsStream.putInProgress OR cpsStream.deleteInProgress      THEN RETURN WITH ERROR Stream.InvalidOperation;    cpsStream.putInProgress ¬ TRUE;    UNTIL cpsStream.deleteInProgress DO      ENABLE UNWIND =>        BEGIN	cpsStream.putInProgress ¬ FALSE;	IF cpsStream.deleteInProgress THEN BROADCAST readyForDelete;	END;      IF CoProcessorFace.SetSST[cpsStream.connection, sst] # busyTryLater THEN EXIT;      IF GetSeconds[] > timeout THEN	BEGIN	SIGNAL Stream.TimeOut[0];	timeout ¬ GetSeconds[] + cpsStream.waitTime / 1000 + 1	END;      WAIT rebroadcast    ENDLOOP;    cpsStream.putInProgress ¬ FALSE;    IF cpsStream.deleteInProgress THEN BROADCAST readyForDelete;    END;  CPSSetTimeout: ENTRY Stream.SetTimeoutProcedure =    BEGIN    cpsStream: CPSHandle = LOOPHOLE[sH];    cpsStream.waitTime ¬ waitTime    END;  DisestablishConnection: INTERNAL PROC [conn: CoProcessorFace.Connection, bufferInterval: Space.Interval] =    BEGIN    status: CoProcessorFace.Status;    timeout: LONG CARDINAL ¬ GetSeconds[] + 30;    DO      ENABLE ABORTED => LOOP;      status ¬ CoProcessorFace.InitiateDisconnection[conn];      IF status # busyTryLater THEN EXIT;      IF GetSeconds[] > timeout THEN        BEGIN	status ¬ inProgress;	EXIT	END;      WAIT faceAvailable    ENDLOOP;    WHILE status = inProgress DO      ENABLE ABORTED => LOOP;      IF GetSeconds[] > timeout THEN        BEGIN	status ¬ CoProcessorFace.InitiateDisconnection[conn, TRUE];	EXIT	END;      WAIT rebroadcast;      status ¬ CoProcessorFace.Poll[conn]    ENDLOOP;    NOTIFY faceAvailable;    VM.Unmap[Space.PageFromLongPointer[bufferInterval.pointer]];    Space.Deallocate[bufferInterval];    [] ¬ ResidentHeap.FreeNode[Inline.LowHalf[conn]]    END;  EstablishConnection: INTERNAL PROC [id: ServerID, putPages, getPages: CARDINAL, isServer: BOOLEAN ¬ FALSE]    RETURNS [conn: CoProcessorFace.Connection, bufferInterval: Space.Interval] =    BEGIN    node: Environment.Base RELATIVE POINTER TO CoProcessorFace.ConnectionRec;    bufferPage: Environment.PageNumber;    status: CoProcessorFace.Status;    aborted: BOOLEAN ¬ FALSE;    node ¬ ResidentHeap.MakeNode[CoProcessorFace.connectionRecSize,      CoProcessorFace.connectionRecAlignment].node;    conn ¬ @Environment.first64K[node];    IF conn = NIL THEN RETURN[NIL, Space.nullInterval];    IF putPages = useDefaultBufferPages THEN putPages ¬ defaultBufferPages;    IF getPages = useDefaultBufferPages THEN getPages ¬ defaultBufferPages;    bufferInterval ¬ Space.Allocate[putPages + getPages];    bufferPage ¬ Space.PageFromLongPointer[bufferInterval.pointer];    VM.ScratchMap[[bufferPage, bufferInterval.count]];    DO      ENABLE ABORTED => {status ¬ error; EXIT};      status ¬ CoProcessorFace.InitiateConnection[conn, id, isServer,        DESCRIPTOR[bufferInterval.pointer, putPages * Environment.bytesPerPage],        DESCRIPTOR[bufferInterval.pointer + putPages * Environment.wordsPerPage,	  getPages * Environment.bytesPerPage]];      IF status # busyTryLater THEN EXIT;      WAIT faceAvailable    ENDLOOP;    WHILE status = inProgress DO      ENABLE ABORTED => {aborted ¬ TRUE; EXIT};      WAIT rebroadcast;      status ¬ CoProcessorFace.Poll[conn]    ENDLOOP;    IF aborted THEN      BEGIN      DO        ENABLE ABORTED => LOOP;        status ¬ CoProcessorFace.InitiateDisconnection[conn];        IF status # busyTryLater THEN EXIT;        WAIT faceAvailable      ENDLOOP;      WHILE status = inProgress DO        ENABLE ABORTED => LOOP;        WAIT rebroadcast;        status ¬ CoProcessorFace.Poll[conn]      ENDLOOP;      status ¬ error      END;    NOTIFY faceAvailable;    IF status = error THEN      BEGIN      VM.Unmap[bufferPage];      Space.Deallocate[bufferInterval];      bufferInterval ¬ Space.nullInterval;      [] ¬ ResidentHeap.FreeNode[node];      conn ¬ NIL      END;    END;  GetSeconds: PROC RETURNS [LONG CARDINAL] = INLINE {    RETURN[System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]]]};  Init: PROC = {IF coProcessorExists THEN    BEGIN    mask: WORD;    cond: LONG POINTER TO CONDITION;    zone ¬ Heap.Create[4];    [cv: cond, mask: mask] ¬ SpecialRuntime.AllocateNakedCondition[];    CoProcessorFace.Initialize[mask];    CoProcessorFace.InitializeCleanup[];    Process.SetTimeout[@rebroadcast, Process.SecondsToTicks[1]];    Process.Detach[FORK Watcher[cond]]    END};  Watcher: ENTRY PROC [cond: LONG POINTER TO CONDITION] = {    DO      WAIT cond­;      BROADCAST rebroadcast    ENDLOOP};  -- main code  Init[]  END.LOG26-Mar-90 - JPM - Created.10-Apr-90 - JPM - Changed to implement new connection establishment protocol & timeouts.19-Apr-90 - JPM - Fixed timeout return in CPSGet; added full-buffer optimization in CPSPut.16-May-90 - JPM - Fixed bug in CPSGet (need to initialize value of why).23-Apr-93 - JPM - Reworked for new CoProcessorFace. 7-May-93 - JPM - Added CoProcessorStreamExtra procs; added timeout logic in DisestablishConnection.18-Jun-93 - WDK - Made compatible with new CoProcessorStream (CoProcessorStreamExtra now obsolete). 16-Sep-93 - RSV - Added Space.Deallocate's in the appropriate places.
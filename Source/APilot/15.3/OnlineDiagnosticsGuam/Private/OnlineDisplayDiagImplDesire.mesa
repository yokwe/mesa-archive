-- File: OnlineDisplayDiagImplDesire.mesa - last edit:-- Jose G. Espinoza:OSBU North:Xerox 21-May-93 15:12:02-- Copyright (C) 1993 by Xerox Corporation. All rights reserved.--OnlineDisplayDiagImplDesire.mesa-- Copyright (C) 1991 by Fuji Xerox Co., Ltd. All rights reserved.--Last Edited by: SXO,    3-Jul-91 19:34:22DIRECTORY  OnlineDiagnostics;OnlineDisplayDiagImplDesire: PROGRAM  EXPORTS OnlineDiagnostics =  BEGIN OPEN OnlineDiagnostics;  LFDisplayTest: PUBLIC PROC [    screenHeight:  CARDINAL[0..32767],    screenWidth:   CARDINAL[0..32767],    SetBackground: PROC [background: Background],    SetBorder:     PROC [oddPairs, evenPairs:  [0..377B]],    SetBorderColor:PROC [borderColor: Background],    GetNextAction: PROC RETURNS [NextAction],    ClearDisplay:  PROC,    PaintScreen:   PROC [x, y, width, height: CARDINAL],    ColorABox:	   PROC [x, y, width, height: CARDINAL, color: BasicColors],    PutOnScreenAnObject:    PROC [p: LONG POINTER TO ARRAY [0..16) OF WORD, x, y: CARDINAL],    FillScreenWithObject:   PROC [p: LONG POINTER TO ARRAY [0..16) OF WORD]] =    BEGIN    SetBorder[0B, 0B];    DO    background: Background;    array: ARRAY [0..16) OF WORD;    letterH:    ARRAY [0..16) OF WORD = [      00000B, 00000B, 30014B, 30014B, 30014B, 30014B, 30014B, 37774B,      37774B, 30014B, 30014B, 30014B, 30014B, 30014B, 00000B, 00000B];          dlosAtSign: ARRAY [0..16) OF WORD = [      00000B, 00000B, 01700B, 03740B, 07160B, 06360B, 06660B, 06660B,      06760B, 06340B, 07000B, 03700B, 01700B, 00000B, 00000B, 00000B];          myAtSign:   ARRAY [0..16) OF WORD = [      00000B, 03760B, 04010B, 10004B, 20004B, 43742B, 42102B, 44102B,      44104B, 44104B, 44310B, 43560B, 40004B, 20030B, 17740B, 00000B];          letterR: ARRAY [0..16) OF WORD = [      00000B, 00000B, 37400B, 37600B, 30300B, 30300B, 30300B, 37600B,      37400B, 31400B, 30600B, 30600B, 30300B, 30300B, 00000B, 00000B];    letterG: ARRAY [0..16) OF WORD = [      00000B, 00000B, 07700B, 17740B, 34160B, 30060B, 30000B, 30000B,      30760B, 30760B, 30060B, 34160B, 17760B, 07720B, 00000B, 00000B];    letterB: ARRAY [0..16) OF WORD = [      00000B, 00000B, 37700B, 37740B, 30160B, 30160B, 30340B, 37700B,      37700B, 30340B, 30160B, 30160B, 37740B, 37700B, 00000B, 00000B];      DrawHorizBrokenLine: PROC [y: CARDINAL[0..32767]] = {        xx, wwidth, spaceRemaining: CARDINAL;        paintCan: ARRAY [0..2) OF WORD _ ALL[177777B];        FOR x:CARDINAL _ 0, x+24 WHILE (x+16) <= screenWidth DO	  xx _ x;          PaintScreen[x: x, y: y, width: 16, height: 2];	  ENDLOOP;	xx _ xx + 16;	IF (spaceRemaining _ screenWidth - xx) > 0 THEN {	  SELECT spaceRemaining FROM	    >=16 => {wwidth_spaceRemaining-8; xx_xx+8;};	    >=10 => {wwidth_spaceRemaining-5; xx_xx+5;};	    ENDCASE => {wwidth_spaceRemaining;};	  PaintScreen[x: xx, y: y, width: wwidth, height: 2]; };  };      DrawVertBrokenLine: PROC [x: CARDINAL[0..32767]] = {        yy, hheight, spaceRemaining: CARDINAL;        paintCan: ARRAY [0..2) OF WORD _ ALL[177777B];        FOR y:CARDINAL _ 0, y+24 WHILE (y+16) <= screenHeight DO	  yy _ y;          PaintScreen[x: x, y: y, width: 2, height: 16];	  ENDLOOP;	yy _ yy + 16;	IF (spaceRemaining _ screenHeight - yy) > 0 THEN {	  SELECT spaceRemaining FROM	    >=16 => {hheight_spaceRemaining-8; yy_yy+8;};	    >=10 => {hheight_spaceRemaining-5; yy_yy+5;};	    ENDCASE => {hheight_spaceRemaining;};	  PaintScreen[x: x, y: yy, width: 2, height: hheight]; };  };	      DrawVerticalLine: PROC =        BEGIN	lineWidth: CARDINAL = 1;	--line width is 1 pixel.	horGridNumber: CARDINAL = 20;	verGridNumber: CARDINAL = 16;	horSize: CARDINAL = screenWidth;	verSize: CARDINAL = screenHeight;	verLineSpacing: CARDINAL ¬ horSize / horGridNumber;	horLineSpacing: CARDINAL ¬ verSize / verGridNumber;	verLineLength: CARDINAL = horLineSpacing * verGridNumber;	xStart: CARDINAL = (horSize MOD horGridNumber) / 2;	yStart: CARDINAL = (verSize MOD verGridNumber) / 2;	FOR x: CARDINAL ¬ xStart, x + verLineSpacing WHILE x <= horSize - 1 DO	  PaintScreen[x: x, y: yStart, width: lineWidth, height: verLineLength];	ENDLOOP;	END;  -- DrawVerticalLine	      DrawHorizontalLine: PROC =        BEGIN	lineWidth: CARDINAL = 1;	--line width is 1 pixel.	horGridNumber: CARDINAL = 20;	verGridNumber: CARDINAL = 16;	horSize: CARDINAL = screenWidth;	verSize: CARDINAL = screenHeight;	verLineSpacing: CARDINAL ¬ horSize / horGridNumber;	horLineSpacing: CARDINAL ¬ verSize / verGridNumber;	horLineLength: CARDINAL = verLineSpacing * horGridNumber;	xStart: CARDINAL = (horSize MOD horGridNumber) / 2;	yStart: CARDINAL = (verSize MOD verGridNumber) / 2;	FOR y: CARDINAL ¬ yStart, y + horLineSpacing WHILE y <= verSize - 1 DO          PaintScreen [x: xStart, y: y, width: horLineLength, height:lineWidth];        ENDLOOP;	END;  -- DrawHorizontalLine	      PrintCrossHairPattern: PROC =        BEGIN	-- Hair line lengths	shortHairLine: CARDINAL = 16;	longHairLine: CARDINAL = 24;	        length, line: CARDINAL;	lineWidth: CARDINAL = 2;        stripe: CARDINAL = 170B;  --********ATTENTION ATTENTION **LOOKS BBAAAADDDDD****        --        -- Starting points for drawing horizontal hair lines (y)        centerVertLine: CARDINAL = screenWidth/2 - lineWidth;         centerVertLineShort: CARDINAL = centerVertLine - shortHairLine/2; -- For short hair line        centerVertLineLong: CARDINAL = centerVertLine - longHairLine/2; -- For long hair line    	-- Starting points for drawing vertical hair lines (y)        centerHorLine: CARDINAL = screenHeight/2 + 1;        centerHorLineShort: CARDINAL = centerHorLine - shortHairLine/2;  -- Short hair line        centerHorLineLong: CARDINAL = centerHorLine - longHairLine/2;  -- Long hair line		startPoint: CARDINAL;  -- Scratch variable            --dotPitch = 0.31[mm]        << pixelsPerCM: CARDINAL = 32;   -- Rounded up >>        pixelsPerHalfCM: CARDINAL = 16;  -- Round up        numberOfVerticalBars: CARDINAL = screenWidth/pixelsPerHalfCM;        numberOfHorizontalBars: CARDINAL = screenHeight/pixelsPerHalfCM;    	-- Draw 4 lines, each 2 pixels wide, around the edges        PaintScreen[x: 0, y: 0, width: screenWidth, height: lineWidth];		    		-- Top edge        PaintScreen[x: 0, y: screenHeight - lineWidth, width: screenWidth, height: lineWidth];	-- Bottom edge        PaintScreen[x: 0, y: 0, width: lineWidth, height: screenHeight];			-- Left edge        PaintScreen[x: screenWidth - lineWidth, y: 0, width: lineWidth, height: screenHeight];	-- Right edge        	-- Draw vertical hair lines about the horizontal center line	PaintScreen[x: 0, y: centerHorLine-lineWidth/2, width: screenWidth, height: lineWidth];		-- Right half        FOR i: CARDINAL IN [1 .. numberOfVerticalBars/2] DO -- Hair lines          IF i MOD 2 = 0 THEN {  -- Draw a long hair line            length _ longHairLine;             line _ centerHorLineLong }          ELSE {  -- Draw a short hair line            length _ shortHairLine;             line _ centerHorLineShort };	  	  startPoint ¬ centerVertLine + i*pixelsPerHalfCM - lineWidth/2;	  IF startPoint + lineWidth > screenWidth THEN EXIT;          PaintScreen[x: startPoint, y: line, width: lineWidth, height: length];          ENDLOOP;	  	-- Left half	FOR i: CARDINAL IN [1 .. numberOfVerticalBars/2] DO	  IF i MOD 2 = 0 THEN {  -- Draw a long hair line	    length ¬ longHairLine;	    line ¬ centerHorLineLong }	  ELSE {  -- Draw a short hair line	    length ¬ shortHairLine;	    line ¬ centerHorLineShort };	  	  startPoint ¬ i*pixelsPerHalfCM + lineWidth/2;	  IF startPoint > centerVertLine THEN EXIT	  ELSE startPoint ¬ centerVertLine - startPoint;	  PaintScreen[x: startPoint, y: line, width: lineWidth, height: length];	  ENDLOOP;      	-- Draw horizontal hair lines about vertical line, each separated by .5 cm	PaintScreen[x: centerVertLine - lineWidth/2, y: 0, width: lineWidth, height: screenHeight];		-- Top half        FOR i: CARDINAL IN [1 .. numberOfHorizontalBars/2] DO           IF i MOD 2 = 0 THEN {  -- Draw a long hair line            length _ longHairLine;             line _ centerVertLineLong  -- x-position to start painting -- }          ELSE {  -- Draw a short hair line            length _ shortHairLine;             line _ centerVertLineShort  -- x-position to start painting  -- };	    	  startPoint ¬ i*pixelsPerHalfCM + lineWidth/2;	  IF startPoint > centerHorLine THEN EXIT	  ELSE startPoint ¬ centerHorLine - startPoint;	            PaintScreen[x: line, y: startPoint, width: length, height: lineWidth];          ENDLOOP; 	  	-- Bottom half	FOR i: CARDINAL IN [0 .. numberOfHorizontalBars/2] DO	  IF i MOD 2 = 0 THEN {  -- Draw a long hair line	    length ¬ longHairLine;	    line ¬ centerVertLineLong  -- x-position to start painting -- }	  ELSE {  -- Draw a short hair line	    length ¬ shortHairLine;	    line ¬ centerVertLineShort  -- x-position to start painting  -- };	  	  startPoint ¬ i*pixelsPerHalfCM - lineWidth/2 + centerHorLine;	  IF (startPoint + lineWidth) > screenHeight THEN EXIT;	  PaintScreen[x: line, y: startPoint, width: length, height: lineWidth];	  ENDLOOP;       END;  -- PrintCrossHairPattern	      PrintColorBoxes: PROC =        BEGIN	array: ARRAY [0..16) OF WORD;	--Create 3 squares of an equal size.	--Fill them with red, green, and blue accordingly.	ColorABox [x: 225, y: 300, width: 200, height: 200, color: red];	ColorABox [x: 475, y: 300, width: 200, height: 200, color: green];	ColorABox [x: 725, y: 300, width: 200, height: 200, color: blue];		--Label them as R, G, B.	array ¬ letterR;	PutOnScreenAnObject [p: @array, x: 325, y: 550];	array ¬ letterG;        PutOnScreenAnObject [p: @array, x: 575, y: 550];        array ¬ letterB;        PutOnScreenAnObject [p: @array, x: 825, y: 550];        END; -- PrintColorBoxes	            PrintColorBars: PROCEDURE =        BEGIN	barWidth, barHeight: CARDINAL;	barColor: BasicColors;	x: CARDINAL ¬ 0;	barWidth ¬ screenWidth / 16;	barHeight ¬ screenHeight / 2;	FOR barColor IN [white..brown] DO	  ColorABox [x: x, y: 0, width: barWidth, height: barHeight, color: barColor];          x ¬ x + barWidth;	  ENDLOOP;	x ¬ 0;        FOR barColor DECREASING IN [white..brown] DO          ColorABox [x: x, y: barHeight, width: barWidth, height: screenHeight - barHeight, color: barColor];          x ¬ x + barWidth;          ENDLOOP;       END; -- PrintColorBars      WaitForKey: PROC RETURNS [action: NextAction] = {        DO	  SELECT GetNextAction[] FROM            nextPattern   => RETURN[nextPattern];	    reDisplay => {	      background ¬ SELECT background FROM	      					white	=> black,						black	=> red,						red	=> green,						green	=> blue,						ENDCASE	=> white;	      SetBorderColor[background];	      SetBackground[background];              RETURN[reDisplay]}; 	    quit          => RETURN[quit];	    ENDCASE;	  ENDLOOP};      FOR pattern: CARDINAL IN [0..10] DO        ClearDisplay[];        SetBackground[background ¬ white];	SetBorderColor[white];	DO	  SELECT pattern FROM	    0	=>  -- Broken line pattern.		   { --For all horizontal lines		    DrawHorizBrokenLine[y: 0];		--Top horizontal line		    DrawHorizBrokenLine[y: 24];		--Second horizontal line		    DrawHorizBrokenLine[y: screenHeight/2 - 1];--Middle horizontal line		    DrawHorizBrokenLine[y: screenHeight - 25];--Penultimate horizontal line		    DrawHorizBrokenLine[y: screenHeight - 2];	--Bottom horizontal line		      		    --For all vertical lines		    DrawVertBrokenLine[x:0];			--Leftmost vertical line		    DrawVertBrokenLine[x:24];			--Second vertical line		    DrawVertBrokenLine[x: screenWidth/2 - 1];	--Middle vertical line		    DrawVertBrokenLine[x: screenWidth - 25];	--Penultimate vertical line		    DrawVertBrokenLine[x: screenWidth - 2]};	--Rightmost vertical line		      	    1	=>  -- Set up screen for "H" pattern	    	    {array ¬ letterH; FillScreenWithObject[@array]};	    	    2	=>  -- Set up screen for Dallas "@" (at-sign) pattern	    	    {array ¬ dlosAtSign; FillScreenWithObject[@array]};	    	    3	=>  -- Set up screen for my "@" (at-sign) pattern	    	    {array ¬ myAtSign; FillScreenWithObject[@array]};	    	    4	=>  -- Set up screen for vertical-line pattern for checking display memory	            DrawVerticalLine[];	    	    5	=>  -- Set up screen for horizontal-line pattern for checking display memory	    	    DrawHorizontalLine[];	    	    6	=>  --Set up screen for vertical & horizontal-line pattern for checking display memory	    	    {DrawVerticalLine[]; DrawHorizontalLine[]};		    	    7	=>  -- Set up screen for crosshair pattern on the screen for alignment purposes	    	    PrintCrossHairPattern[];	    	    8	=>  -- Displays 3 labeled boxes of red, green, and blue.	    	    PrintColorBoxes[];	    	    9	=>  -- Fills the screen with color bars.	    	    PrintColorBars[];	    	    ENDCASE;  -- Set up screen for plain pattern for checking display memory	    	  SELECT WaitForKey[].action FROM	    nextPattern	=> EXIT;	    reDisplay	=> LOOP;	    ENDCASE	=> RETURN; -- quit 	       	  ENDLOOP;  -- redisplay	ENDLOOP; -- next pattern	          ENDLOOP;          END;  -- LFDisplayTest  END.....    --LOG-- 3-Jul-91 19:36:35	SXO	Created.
-- Copyright (C) 1980, 1981  by Xerox Corporation. All rights reserved. -- DisplayFace.mesa (last edited by: Dennis DXG      on:  26-Sep-84  2:21:427)-- 1) Is SetScanLineWakeup really necessary? Is it implementable on all controllers?-- 2) Is 16 word alignment of globalState area necessary on D0?DIRECTORY   BitBlt USING [BBTable],   Environment USING [BitAddress, Base, PageCount, PageNumber];DisplayFace: DEFINITIONS =BEGIN-- Processor-independent interface to bitmap display.-- There is no provision for multiple displays on a single machine.-- The display has two state variables: mode and background.  The mode has three values:-- on, off, and disconnected; the background has two values: white and black.  When the-- system is booted, state =  disconnected, and background = white.hasBuffer: READONLY BOOLEAN;   -- TRUE => display implementation provides real memory for bitmap;   -- FALSE => client provides real memory for bitmap.pagesForBitmap: READONLY Environment.PageCount;   -- size of virtual memory required to hold full size bitmap; may be larger than implied   -- by size of visible imageConnect: PROCEDURE [bitmap: Environment.PageNumber];    -- Display must be in 'disconnected' mode; connects display to specified bitmap and    -- leaves it in 'off' mode. Bitmap is taken by reference (first page in virtual    -- address space); subsequent changes to bitmap in memory will affect screen image.    -- Bitmap is always full size (i.e. pagesForBitmap pages).  The bitmap does not appear    -- on the screen until the display is turned on (see below).Disconnect: PROCEDURE;   -- Display must be in 'off' mode; places display in 'disconnected' mode.   Turns   -- screen black, and minimizes consumption of resources (e.g. microprocessor time,   -- memory accesses, etc.).  The virtual memory area used for the bitmap may be   -- reused for other purposes while the display is disconnected.  The real memory   -- may be reclaimed by the party providing it (i.e.  if 'buffered' is FALSE, the   -- face client may reclaim the real memory; if 'buffered' is TRUE, the face   -- implementation may reclaim the real memory.)TurnOn: PROCEDURE;   -- Display must be in 'off' mode; places display in 'on' mode, causing bitmap to be   -- displayed on screen.  Bitmap must have real memory mapped to it before this   -- operation is invoked.TurnOff: PROCEDURE;   -- Display must be in 'on' mode; places display in 'off' mode,  causing background   -- color to be displayed on screen. GetBitBltTable: PROCEDURE RETURNS [BitBlt.BBTable];SetBackground: PROCEDURE [background: Background];   Background: TYPE = {white, black};   -- white => normal (black on white) view of bitmap (0=>white, 1=>black);   -- black => inverted (white on black) view of bitmap (0=>black, 1=>white);width, height: READONLY CARDINAL [0..32767];  -- Dimensions of screen in pixelspixelsPerInch: READONLY CARDINAL;  -- Size of a pixelrefreshRate: READONLY CARDINAL;  -- Number of times per second that entire screen is refreshed.interlaced: READONLY BOOLEAN;  -- Is the refresh two-way interlaced?hasBorder: READONLY BOOLEAN; -- Is border pattern implemented?SetBorderPattern: PROCEDURE [oddPairs, evenPairs: [0..377B]];   -- Defines bit pattern shown in visible screen area (if any) outside bitmap.  The bit   -- pattern for an individual scan line is defined by displaying a single byte repeatedly   -- along the entire scan line.  The same pattern is shown on alternating pairs of lines.   -- (Byte for even pairs shown on lines -4, -3, 0, 1, 4, 5, etc.  Byte for odd pairs shown   -- on lines -2, -1, 2, 3, 6, 7, etc.)  SetCursorPattern: PROCEDURE [cusorPtr: CursorPtr];   -- Sets the cursor bitmap to the indicated pattern by value; subsequent changes to the   -- indicated cursor in memory will not affect screen image, hence SetCursorPattern must   -- be called each time the cursor pattern is changed.  SetCursorPosition: PROCEDURE [cursor: Point];   -- Sets the cursor position to the position indicated.  CursorPtr: TYPE = LONG POINTER TO Cursor;Cursor: TYPE = ARRAY [0..16) OF WORD;cursorPosition: READONLY LONG POINTER TO READONLY Point;Point: TYPE = RECORD [x, y: INTEGER];  -- x and y , measured from upper-left corner of screen.-- GeneralglobalStateSize: READONLY CARDINAL;GlobalStatePtr: TYPE = Environment.Base RELATIVE POINTER;InitializeCleanup: PROCEDURE;Initialize: PROCEDURE [globalState: GlobalStatePtr, wakeVF: WORD];   -- This procedure initializes the implementation; 'globalState' is a client supplied   -- block of globalStateSize words, 16-word aligned in first 64K of address space.   -- Lifetime: permanently allocated and passed in on call to Initialize; 'wakeVF' is   -- the wakeup mask for vertical-field interrupts (i.e. refresh of scan lines 0 and 1).-- Smooth ScrollingscrollXQuantum: READONLY CARDINAL;   -- The horizontal bit-position of the scroll window within the bitmap and the width of   -- the scroll window must both be multiples of scrollXQuantum.  A value of 16 indicates   -- that left and right edges are word aligned within the bitmap.scrollYQuantum: READONLY CARDINAL;   -- The vertical bit-position of the scroll window within the bitmap and the height of   -- the scroll window must both be multiples of scrollYQuantum.  scrollingInhibitsCursor: READONLY BOOLEAN;   -- Indicates whether presence of scrolling inhibits display of the cursor.CreateScrollWindow: PROCEDURE [locn:  Point, w:  CARDINAL, h:  CARDINAL];   -- This procedure defines an area in the bitmap that can be scrolled up or down.   -- Only one ScrollWindow may be defined at any one time.  w and locn.x must be multiples   -- of scrollXQuantum. Scroll: PROCEDURE [line:  Environment.BitAddress, lineCount:  CARDINAL, increment: INTEGER];   -- This procedure causes the display to scroll up (increment>0) or down (increment<0) lineCount lines.     -- lineCount must be a multiple of scrollYQuantum.   -- "line" points to the first line that will be added to the top or the bottom of the display   -- increment (a bit increment) is added to line to get the bit address of each successive line after the first.DeleteScrollWindow: PROCEDURE;   -- This procedure deletes the scroll window and fixes up the display.END.LOGTime: February 6, 1980  2:22 PM	By: DXR      Created fileTime: February 7, 1980  6:30 PM	By: RXG      Made width and height be subranges to avoid signed/unsigned problemsTime: July 19, 1980  2:11 PM	By: PXM       Added cursorPosition and (temporarily) mousePositionTime: July 29, 1980  10:00 AM	By: PXM       Added hasBorder; removed SetCursorPosition; split off MouseFaceTime: July 30, 1980  5:43 PM	By: PXM       Added pagesForBitmap, GetBitBltTable; buffered=>hasBufferTime: July 29, 1981  10:56 AM	By: Jim JXF        Add smooth scrolling interface. Add SetCursorPosition.Time: 11-Aug-81 10:02:30	By: AWL         Stripped out bravo formatting.  Added explicit type for scrolling direction   (CreateScrollWindow).Time: October 21, 1981  9:18 AM	By: Jim JXF        Changes to Scroll interface: CreateScrollWindow does not take a direction; Scroll takes an increment.Time: 20-Nov-81 15:13:15	By: Jim JXF        Changes to Scroll interface: CreateScrollWindow takes a BitAddress instead of a LONG POINTER. increment is a bit increment.Time: 26-Sep-84  2:21:38	By: DXG     	Action: Added copyright notice and rebuild for 11.1 release.   
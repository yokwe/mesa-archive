-- File: RasterOpsImpl.mesa-- Last Edit: PKM     5-Sep-86 15:01:55-- 	      MYT    16-Sep-86 17:03:12 merge ChainBLT & BumpBitAddress--	      MYT    17-Sep-86 11:11:11 testing completed-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  BitBlt USING [BBptr, BITBLT, BitBltFlags, BBTableSpace, AlignedBBTable, GrayParm],  Frame USING [GetReturnFrame, ReadPC, WritePC],  PrincOps USING [ESCTrapTable],  ESCAlphaExtras USING [aCOUNTBITSON, aCOUNTBITSOFF, aBLTLINEGRAY, aBUMPBITADDRESS, aCHAINBLT],  Environment USING [ bitsPerByte, bitsPerWord, Byte],  Inline USING [BITAND, BITOR, BITNOT, BITSHIFT, BITXOR, LowByte, LowHalf ],  RasterOps USING[ BitAddress, BLTLineGrayFunc] ;RasterOpsImpl: PROGRAM  IMPORTS BitBlt, Inline, Frame   EXPORTS RasterOps =  BEGIN    OPEN Environment, Inline; -- TYPEs    Nibble: TYPE = CARDINAL[0..16);          PrivateBitAddress: TYPE = MACHINE DEPENDENT RECORD [    word: LONG POINTER TO WORD,    bit : CARDINAL];      bbTableSpace: BitBlt.BBTableSpace;    -- Useful Masks    singleBitOn, singleBitOff, leftSideOn, rightSideOn: ARRAY Nibble OF WORD;        blackWord: WORD ¬ 177777b;	    offWord:WORD = 0;  --All zeros    onWord:WORD = LAST[CARDINAL];  --All ones   -- for CountBits    leadingBitsOn, leadingBitsOff: PUBLIC ARRAY Byte OF [0..bitsPerByte];    LineBBPtr: BitBlt.BBptr; -- setup with height and heightMinusOne=1   -- (srcBpl never used so GrayParm always in place)  MaskFromField: PROC [pos, size: Nibble] RETURNS [WORD] = {    bndsCheck: Nibble ¬ pos+size;    RETURN[IF size=15 THEN blackWord      ELSE BITSHIFT[leftSideOn[size+1], -pos]]};  BitOn: PROC [adr: RasterOps.BitAddress] RETURNS [BOOLEAN] = INLINE {    RETURN[BITAND[adr.word­, singleBitOn[CheapAddressBit[adr]]] # 0]};    CheapAddressBit: PROC [address: RasterOps.BitAddress] RETURNS [Nibble] = INLINE {    RETURN [LOOPHOLE[LOOPHOLE[address, PrivateBitAddress].bit, Nibble]]};   -- (for ChainBlt)      Bit: TYPE = [0..1];   Chain: TYPE = LONG DESCRIPTOR FOR ARRAY OF CARDINAL;        CountBitsOn: PUBLIC PROC [startAddr:RasterOps.BitAddress, limit:CARDINAL, prevCount:CARDINAL ¬ 0 ]    RETURNS [stopAddr:RasterOps.BitAddress, count:CARDINAL ¬ 0] =    BEGIN    -- since this is called as a trap instruction, we got to    -- bump the pc.      Frame.WritePC[      pc: [Frame.ReadPC[Frame.GetReturnFrame[]]+2],      lf: Frame.GetReturnFrame[]];    [stopAddr, count] ¬ SoftwareCountBitsOn[startAddr, limit, prevCount];    RETURN[stopAddr, count];    END;                SoftwareCountBitsOn:PUBLIC PROCEDURE[      addr:RasterOps.BitAddress,limit:CARDINAL, count:CARDINAL ]      RETURNS[stopAddr:RasterOps.BitAddress, resultcount:CARDINAL¬0] =      BEGIN            bytes:LONG POINTER TO PACKED ARRAY OF Byte ¬LOOPHOLE[addr.word];      index: NAT ¬ 0;      templimit:LONG INTEGER;      tempcount:LONG INTEGER ¬ 0;                       adrBit: Nibble ¬ CheapAddressBit[addr];            templimit ¬ limit;                           IF templimit = 0 THEN RETURN[ addr, count];            IF adrBit > 7 THEN {adrBit ¬ adrBit-8; index ¬ 1};          IF adrBit#0 THEN {      	temp: Byte ¬ -- turn on in word all bits before 1st of interest      	LowByte[BITOR[leftSideOn[bitsPerByte+adrBit], bytes[index]]];      	tempcount ¬ leadingBitsOn[temp] - adrBit;      	IF tempcount > templimit THEN tempcount ¬ templimit;            	IF (tempcount+adrBit < bitsPerByte) OR(tempcount = templimit)THEN 	  BEGIN       	  addr.bit ¬ LOOPHOLE[adrBit +Inline.LowHalf[tempcount]];	  resultcount ¬ Inline.LowHalf[count + tempcount];          IF index = 1 THEN 	    BEGIN	   	    IF (addr.bit + 8 =16) THEN	      BEGIN	      addr.bit ¬ 0;	      addr.word ¬ addr.word + 1;	      END	    ELSE addr.bit ¬ addr.bit + 8;	    END;	          RETURN[addr,resultcount];	  END;	  	templimit ¬ templimit - tempcount;	        index ¬ index+1};                  DO -- whole bytes from there on        bitsOnInByte: NAT = leadingBitsOn[bytes[index]];                templimit ¬ templimit - 8;             IF (templimit <= 0) OR (bitsOnInByte < bitsPerByte)  THEN          BEGIN	  templimit ¬ templimit + 8;	  IF bitsOnInByte > templimit THEN	    BEGIN	    tempcount ¬ tempcount +templimit;	    addr.bit ¬ LOOPHOLE[Inline.LowHalf[templimit]];	    END	  ELSE 	    BEGIN	    tempcount ¬ tempcount + bitsOnInByte;	    addr.bit ¬ LOOPHOLE[bitsOnInByte];	    END;	  resultcount ¬ count + Inline.LowHalf[tempcount];	  addr.word ¬ LOOPHOLE[ bytes + index/2 ];	  IF index MOD 2 = 1 THEN	    BEGIN	    	   	    IF (addr.bit + 8 =16) THEN	      BEGIN	      addr.bit ¬ 0;	      addr.word ¬ addr.word + 1;	      END	    ELSE addr.bit ¬ addr.bit + 8;	    END;		  RETURN[addr,resultcount];	  END;	  	tempcount ¬ tempcount + bitsOnInByte;	        index ¬ index+1;        ENDLOOP;      END;           CountBitsOff:PUBLIC PROC [startAddr:RasterOps.BitAddress, limit:CARDINAL, prevCount:CARDINAL ¬ 0 ]    RETURNS [stopAddr:RasterOps.BitAddress, count:CARDINAL] =    BEGIN    -- since this is called as a trap instruction, we got to    -- bump the pc.      Frame.WritePC[      pc: [Frame.ReadPC[Frame.GetReturnFrame[]]+2],      lf: Frame.GetReturnFrame[]];    [stopAddr, count] ¬ SoftwareCountBitsOff[startAddr, limit, prevCount];    END;                                                     SoftwareCountBitsOff:PUBLIC PROCEDURE[      addr:RasterOps.BitAddress, limit:CARDINAL, count:CARDINAL]      RETURNS[ stopAddr:RasterOps.BitAddress, resultcount:CARDINAL] =      BEGIN      bytes:LONG POINTER TO PACKED ARRAY OF Byte ¬ LOOPHOLE[addr.word];      index: NAT ¬ 0;      templimit:LONG INTEGER;      tempcount:LONG INTEGER ¬ 0;            adrBit: Nibble ¬ CheapAddressBit[addr];            templimit ¬ limit;            IF templimit = 0 THEN RETURN[ addr, count];      IF adrBit > 7 THEN {adrBit ¬ adrBit-8; index ¬ 1};          IF adrBit#0 THEN {      	temp: Byte ¬ -- turn off in word all bits before 1st of interest      	BITAND[rightSideOn[bitsPerByte - adrBit], bytes[index]];      	tempcount ¬ leadingBitsOff[temp] - adrBit;      	IF tempcount > templimit THEN tempcount ¬ templimit;            	IF (tempcount+adrBit < bitsPerByte) OR(tempcount = templimit)THEN 	  BEGIN       	  addr.bit ¬ LOOPHOLE[adrBit + Inline.LowHalf[tempcount]];          resultcount ¬ Inline.LowHalf[ count + tempcount]; 	  IF index = 1 THEN 	    BEGIN	       	    IF (addr.bit + 8 =16) THEN	      BEGIN	      addr.bit ¬ 0;	      addr.word ¬ addr.word + 1;	      END	    ELSE addr.bit ¬ addr.bit + 8;  	    END;	            RETURN[addr,resultcount];	  END;	  	templimit ¬ templimit - tempcount;	        index ¬ index+1};                  DO -- whole bytes from there on        bitsOffInByte: NAT = leadingBitsOff[bytes[index]];                templimit ¬ templimit -8 ;             IF (templimit <= 0) OR (bitsOffInByte < bitsPerByte) THEN          BEGIN	  templimit ¬ templimit + 8;	  IF bitsOffInByte>templimit THEN	    BEGIN	    tempcount ¬ tempcount + templimit;	    addr.bit ¬ LOOPHOLE[Inline.LowHalf[templimit]];	    END	  ELSE	    BEGIN	    tempcount ¬ tempcount + bitsOffInByte;	    addr.bit ¬ LOOPHOLE[bitsOffInByte];	    END;  	  resultcount ¬ count + Inline.LowHalf[tempcount];	  	  addr.word ¬ LOOPHOLE[ bytes + index/2 ];	  IF index MOD 2 = 1 THEN	    BEGIN	    	   	    IF (addr.bit + 8 =16) THEN	      BEGIN	      addr.bit ¬ 0;	      addr.word ¬ addr.word + 1;	      END	    ELSE addr.bit ¬ addr.bit + 8;	    END;		  RETURN[addr,resultcount];	  END;	  	tempcount ¬ tempcount + bitsOffInByte;          index ¬ index+1;        ENDLOOP;      END;                      -- Procedures for BumpBitAddress    BumpBitAddress: PUBLIC PROC [addr: RasterOps.BitAddress, offset: INTEGER] RETURNS [RasterOps.BitAddress] =    BEGIN    -- since this is called as a trap instruction, we gotta bump the pc.      Frame.WritePC[        pc: [Frame.ReadPC[Frame.GetReturnFrame[]]+2],        lf: Frame.GetReturnFrame[]];      RETURN SoftwareBumpBitAddress[addr: addr, offset: offset];    END; -- of BumpBitAddress    SoftwareBumpBitAddress: PUBLIC PROC [addr: RasterOps.BitAddress, offset: INTEGER] RETURNS   [RasterOps.BitAddress] =     BEGIN      offset ¬ offset + CheapAddressBit[addr];      IF offset < 0 THEN {        bit: CARDINAL ¬ CARDINAL[-offset] MOD 16;        IF bit # 0 THEN RETURN[LOOPHOLE[PrivateBitAddress[          word: addr.word-(CARDINAL[-offset]/16 + 1),          bit: 16 - bit]]]        ELSE RETURN[LOOPHOLE[PrivateBitAddress[          word: addr.word-(CARDINAL[-offset]/16),	  bit: 0]]]}      ELSE RETURN[LOOPHOLE[PrivateBitAddress[        word: addr.word + LONG[CARDINAL[offset]/16],        bit: BITAND[LowHalf[offset], 15]]]]    END; -- of SoftwareBumpBitAddress             BLTLineGray:PUBLIC PROC [addr:RasterOps.BitAddress, func: RasterOps.BLTLineGrayFunc, count: CARDINAL, grayWord: WORD ] =    BEGIN    -- since this is called as a trap instruction, we got to    -- bump the pc.      Frame.WritePC[      pc: [Frame.ReadPC[Frame.GetReturnFrame[]]+2],      lf: Frame.GetReturnFrame[]];    SoftwareBLTLineGray[addr, func, count, grayWord];    END;           SoftwareBLTLineGray: PUBLIC PROC[ dstAddr: RasterOps.BitAddress,  func:RasterOps.BLTLineGrayFunc, count:CARDINAL, grayWord: WORD] =    BEGIN        dstAdrBit: Nibble;    IF count=0 THEN RETURN;    IF func.srcFunc=null     AND (dstAdrBit ¬ CheapAddressBit[dstAddr])+count<17 THEN {      -- use Field Move      dst: LONG POINTER TO WORD = LOOPHOLE[dstAddr.word];      mask: WORD = MaskFromField[dstAdrBit, count-1];      dst­ ¬ SELECT func.dstFunc FROM	null => BITOR[BITAND[dst­, BITNOT[mask]], BITAND[grayWord, mask]],	or =>  BITOR[dst­, BITAND[grayWord, mask]],	and => BITAND[dst­, BITAND[grayWord, mask]],	ENDCASE => BITXOR[dst­, BITAND[grayWord, mask]]}    ELSE {      LineBBPtr.src ¬ [word: @grayWord, bit: 0];      LineBBPtr.dst ¬ dstAddr;      LineBBPtr.flags¬BitBlt.BitBltFlags[gray:TRUE, srcFunc:func.srcFunc,            dstFunc:func.dstFunc ];      LineBBPtr.width ¬ count;      BitBlt.BITBLT[LineBBPtr]};       END;         -- Procedures for ChainBlt          ChainBLT: PUBLIC PROC [addr: RasterOps.BitAddress, startBit:Bit, chain:Chain] =    BEGIN    -- since this is called as a trap instruction, we gotta bump the pc.      Frame.WritePC[        pc: [Frame.ReadPC[Frame.GetReturnFrame[]]+2],        lf: Frame.GetReturnFrame[]];        SoftwareChainBLT[addr:addr, startBit:startBit, chain:chain];    END; -- of       SoftwareChainBLT: PUBLIC PROC [addr: RasterOps.BitAddress, startBit:Bit, chain:Chain] =        BEGIN      count: CARDINAL ¬ 0;      FOR length: CARDINAL IN [0..chain.LENGTH) DO        count ¬ (LOOPHOLE[chain.BASE,LONG POINTER]+length)­;        IF startBit = 0 THEN SoftwareBLTLineGray[addr, [dstFunc:null,srcFunc:null],count,0]  	ELSE SoftwareBLTLineGray[addr,[dstFunc:null,srcFunc:null],count,0FFFFH];	addr ¬ SoftwareBumpBitAddress[addr, LOOPHOLE[count,INTEGER]];	startBit ¬ BITXOR[startBit,1];	ENDLOOP;    END; -- of SoftwareChainBLT          -- Private Stuff  Init: PROC = BEGIN OPEN Environment, Inline;     lastBit: NAT = bitsPerWord-1;    singleBitOn[lastBit] ¬ 1;    LineBBPtr ¬ BitBlt.AlignedBBTable[@bbTableSpace];    LineBBPtr.height ¬ 1;    LineBBPtr.srcDesc.gray ¬ BitBlt.GrayParm[      yOffset: 0, widthMinusOne: 0, heightMinusOne: 0];    FOR n: NAT DECREASING IN [0..lastBit) DO       singleBitOn[n] ¬ singleBitOn[n + 1] * 2;       ENDLOOP;    FOR n: NAT IN [0..lastBit] DO       singleBitOff[n] ¬  BITNOT[singleBitOn[n]];       leftSideOn[n] ¬  BITSHIFT[177777B, 16-n];       rightSideOn[n] ¬ BITSHIFT[177777B, n-16];       ENDLOOP;    FOR charNo: NAT IN [0..LAST[Byte]] DO       smallPicture: PACKED ARRAY [0..2) OF Byte ¬ [charNo, 0];       FOR bitNo: NAT IN [0..bitsPerByte] DO         IF ~BitOn[[word: @smallPicture, bit: bitNo]] THEN {	   leadingBitsOn[charNo] ¬ bitNo; EXIT};	 ENDLOOP;       smallPicture[1] ¬ 377B; -- for the 9th bit       FOR bitNo: NAT IN [0..bitsPerByte] DO         IF BitOn[[word: @smallPicture, bit: bitNo]] THEN {	   leadingBitsOff[charNo] ¬ bitNo; EXIT};	 ENDLOOP;       ENDLOOP;    END;  --of Init        Init[];     -- Main Line code                     PrincOps.ESCTrapTable[ESCAlphaExtras.aCOUNTBITSON]  ¬ LOOPHOLE[CountBitsOn];   PrincOps.ESCTrapTable[ESCAlphaExtras.aCOUNTBITSOFF] ¬ LOOPHOLE[CountBitsOff];    PrincOps.ESCTrapTable[ESCAlphaExtras.aBUMPBITADDRESS] _ LOOPHOLE[BumpBitAddress];  PrincOps.ESCTrapTable[ESCAlphaExtras.aBLTLINEGRAY] ¬ LOOPHOLE[BLTLineGray];    PrincOps.ESCTrapTable[ESCAlphaExtras.aCHAINBLT] _ LOOPHOLE[ChainBLT];   END.... -- of RasterOpsImpl.mesa        
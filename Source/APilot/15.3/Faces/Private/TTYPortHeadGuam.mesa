-- File: TTYPortHeadGuam.mesa - last edit:-- JPM				 9-Mar-93 12:30:43-- Copyright (C) 1993 by Xerox Corporation. All rights reserved.DIRECTORY  DeviceCleanup USING [Await, Item, Reason],  GuamInputOutput USING [CallAgent, GetFCBPtr, InterruptSelectorType],  HeadStartChain USING [Start],  TTYPortIOFaceGuam,  TTYPortFace USING [DeviceStatus, Parameter, TransferStatus];TTYPortHeadGuam: PROGRAM  IMPORTS DeviceCleanup, GuamInputOutput, RemainingHeads: HeadStartChain  EXPORTS HeadStartChain, TTYPortFace =  BEGIN  -- TTY Type definitions  fcb: LONG POINTER TO TTYPortIOFaceGuam.TTYFCBType ¬    GuamInputOutput.GetFCBPtr[tty];  ttyIsOn: BOOLEAN ¬ FALSE;  -- Errors  unimplementedParameter: ERROR = CODE;  -- Parameters saved during world swapping:  savedTTYInterruptSelector: GuamInputOutput.InterruptSelectorType;  savedLineSpeed: TTYPortIOFaceGuam.LineSpeedType;  savedCharLength: TTYPortIOFaceGuam.CharLengthType;  savedParity: TTYPortIOFaceGuam.ParityType;  savedStopBits: TTYPortIOFaceGuam.StopBitsType;  << PUBLIC PROCEDURES>>  PutCommand: PUBLIC PROCEDURE [lineNumber: CARDINAL, data: CHARACTER]    RETURNS [stat: TTYPortFace.TransferStatus] =    BEGIN    IF lineNumber # 0 OR fcb = NIL OR NOT fcb.readyToTransmit THEN RETURN [notReady];    fcb.data ¬ data;    fcb.command ¬ transmit;    GuamInputOutput.CallAgent[tty];    stat ¬ SELECT fcb.status FROM      success => success,      breakDetected => breakDetected,      dataLost => dataLost,      parityError => parityError,      framingError => asynchFramingError,      ENDCASE => notReady    END; -- PutCommand  GetCommand: PUBLIC PROCEDURE [lineNumber: CARDINAL]    RETURNS [data: CHARACTER, stat: TTYPortFace.TransferStatus] =    BEGIN    IF lineNumber # 0 OR fcb = NIL OR NOT fcb.readyToReceive THEN RETURN [NULL, notReady];    fcb.command ¬ receive;    GuamInputOutput.CallAgent[tty];    data ¬ fcb.data;    stat ¬ SELECT fcb.status FROM      success => success,      breakDetected => breakDetected,      dataLost => dataLost,      parityError => parityError,      framingError => asynchFramingError,      ENDCASE => notReady    END; -- GetCommand  GetLineCount: PUBLIC PROCEDURE RETURNS [lineCount: CARDINAL] =    {RETURN [IF fcb = NIL THEN 0 ELSE 1]}; --  GetLineCount  GetStatus: PUBLIC PROCEDURE [lineNumber: CARDINAL]    RETURNS [stat: TTYPortFace.DeviceStatus] =    BEGIN    IF lineNumber # 0 OR fcb = NIL THEN RETURN [ [FALSE, FALSE, FALSE, FALSE] ];    stat.dataTerminalReady ¬ fcb.DTR;    stat.readyToGet ¬ fcb.readyToReceive;    stat.readyToPut ¬ fcb.readyToTransmit;    stat.requestToSend ¬ fcb.RTS    END; -- GetStatus  Off: PUBLIC PROCEDURE [lineNumber: CARDINAL] =    BEGIN    IF lineNumber # 0 OR fcb = NIL THEN RETURN;    fcb.command ¬ close;    GuamInputOutput.CallAgent[tty];    ttyIsOn ¬ FALSE    END; -- Off  On: PUBLIC PROCEDURE [lineNumber: CARDINAL, mask: UNSPECIFIED] =    BEGIN    IF lineNumber # 0 OR fcb = NIL THEN RETURN;    fcb.ttyInterruptSelector ¬ mask;    fcb.command ¬ open;    GuamInputOutput.CallAgent[tty];    ttyIsOn ¬ TRUE    END; -- On  SendBreak: PUBLIC PROCEDURE [lineNumber: CARDINAL] =    BEGIN    IF lineNumber # 0 OR fcb = NIL THEN RETURN;    fcb.command ¬ sendBreak;    GuamInputOutput.CallAgent[tty]    END; -- SendBreak  SetParameter: PUBLIC PROCEDURE [lineNumber: CARDINAL, parameter: TTYPortFace.Parameter] =    BEGIN    IF lineNumber # 0 OR fcb = NIL THEN RETURN;    WITH parameter SELECT FROM       -- rx & tx set to the same char length       characterLength	=> { fcb.charLength ¬ (SELECT characterLength FROM		 	 	   lengthIs5bits => lengthIs5bits,				   lengthIs6bits => lengthIs6bits,       				   lengthIs7bits => lengthIs7bits,				   lengthIs8bits => lengthIs8bits,				   ENDCASE => ERROR unimplementedParameter) };			       clearToSend	=> { fcb.CTS ¬ clearToSend };       dataSetReady	=> { fcb.DSR ¬ dataSetReady };       lineSpeed	=> { fcb.lineSpeed ¬ (SELECT lineSpeed FROM       				   bps50 	=> bps50,					   bps75 	=> bps75,				   bps110 	=> bps110,				   bps150 	=> bps150,				   bps300 	=> bps300,				   bps600 	=> bps600,				   bps1200 	=> bps1200,				   bps1800 	=> bps1800,				   bps2000 	=> bps2000,				   bps2400 	=> bps2400,				   bps3600 	=> bps3600,				   bps4800 	=> bps4800,				   bps7200 	=> bps7200,				   bps9600 	=> bps9600,				   bps19200 	=> bps19200,				   ENDCASE	=> ERROR unimplementedParameter) };			       parity		=> { fcb.parity ¬ (SELECT parity FROM       				   none => none,				   odd 	=> odd,				   even => even,				   ENDCASE => ERROR unimplementedParameter) };			       stopBits		=> { fcb.stopBits ¬ (SELECT stopBits FROM       				   one	 		=> one,				   oneAndHalf	 	=> oneAndHalf,				   two	 		=> two,				   ENDCASE		=> ERROR unimplementedParameter) };       ENDCASE;    fcb.command ¬ setParams;    GuamInputOutput.CallAgent[tty]    END; -- SetParameter  << PRIVATE PROCs >>  InitializeCleanup: PROCEDURE =    BEGIN    item: DeviceCleanup.Item;    reason: DeviceCleanup.Reason;    i: CARDINAL ¬ 0;    DO      reason ¬ DeviceCleanup.Await[@item];      IF ttyIsOn THEN        SELECT reason FROM	  turnOff, kill =>	    BEGIN	    fcb.command ¬ close;	    GuamInputOutput.CallAgent[tty];	    savedTTYInterruptSelector ¬ fcb.ttyInterruptSelector;	    savedLineSpeed ¬ fcb.lineSpeed;	    savedCharLength ¬ fcb.charLength;	    savedParity ¬ fcb.parity;	    savedStopBits ¬ fcb.stopBits;	    fcb.CTS ¬ fcb.DSR ¬ FALSE	    END;  	  turnOn =>	    BEGIN	    fcb.ttyInterruptSelector ¬ savedTTYInterruptSelector;	    fcb.lineSpeed ¬ savedLineSpeed;	    fcb.charLength ¬ savedCharLength;	    fcb.parity ¬ savedParity;	    fcb.stopBits ¬ savedStopBits;	    fcb.command ¬ open;	    GuamInputOutput.CallAgent[tty]	    END;	  disconnect => NULL;  -- turnOff was already called	  ENDCASE;    ENDLOOP    END; -- InitializeCleanup  << Start Chain >>  Start: PUBLIC PROC = { RemainingHeads.Start[] }; -- Start  << Mainline code >>  IF fcb # NIL THEN InitializeCleanup [];  END.LOG 9-Mar-93 -- JPM -- Created.	
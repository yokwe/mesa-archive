-- SerialHeadGuam.mesa - last edit:--  JPM		 8-Apr-93 11:12:45-- Copyright (C) 1993 by Xerox Corporation.  All rights reserved.<< The following program was created in 1993 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  DeviceCleanup USING [Await, Item, Reason],  Environment USING [bytesPerWord],  GuamInputOutput USING [CallAgent, GetFCBPtr, InterruptSelectorType],  Inline USING [BITAND, BITNOT, BITOR],  NewRS232CFace USING [ControlRecord, Command, CommandStatus, DeviceStatus, Handle, LineNumber, nullLineNumber, Operation, OperationPtr, ParameterHandle, ParameterRecord, ParameterStatus, ResetRecord, RS232CClientType, TransferStatus],  ResidentHeap USING [Alignment, HeapLocation],  SerialIOFaceGuam USING [SerialFaceFCBType, SerialIOCBPtr, SerialIOCBType];  SerialHeadGuam: PROGRAM   IMPORTS DeviceCleanup, GuamInputOutput, Inline  EXPORTS NewRS232CFace =   BEGIN  -- PUBLIC TYPE  Handle: PUBLIC TYPE = LONG POINTER;  -- constants  fcb: LONG POINTER TO SerialIOFaceGuam.SerialFaceFCBType =    GuamInputOutput.GetFCBPtr[serial];  bpw: CARDINAL = Environment.bytesPerWord;  nullStatus: NewRS232CFace.DeviceStatus =    [FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE];  latchedStatusMask: NewRS232CFace.DeviceStatus =    [TRUE, TRUE, TRUE, FALSE, FALSE, FALSE, FALSE];  -- PUBLIC variables  numberOfLines: PUBLIC CARDINAL ¬ (IF fcb = NIL THEN 0 ELSE 1);  nilHandle: PUBLIC Handle ¬ NIL;  operationSize: PUBLIC CARDINAL ¬ SIZE[SerialIOFaceGuam.SerialIOCBType] +    (IF fcb = NIL THEN 0 ELSE fcb.agentBlockSize);  operationAlignment: PUBLIC ResidentHeap.Alignment ¬ a2;  operationLocation: PUBLIC ResidentHeap.HeapLocation ¬ first64K;  -- PRIVATE variables  currentClient: NewRS232CFace.RS232CClientType ¬ noClient;  latchedStatus: NewRS232CFace.DeviceStatus ¬ nullStatus;  lineOn: BOOLEAN ¬ FALSE;  rxIOCBHead: SerialIOFaceGuam.SerialIOCBPtr ¬ NIL;  rxIOCBTail: LONG POINTER TO SerialIOFaceGuam.SerialIOCBPtr ¬ @rxIOCBHead;  txIOCBHead: SerialIOFaceGuam.SerialIOCBPtr ¬ NIL;  txIOCBTail: LONG POINTER TO SerialIOFaceGuam.SerialIOCBPtr ¬ @txIOCBHead;  -- PUBLIC PROCs  GetDeviceStatus: PUBLIC PROC [handle: Handle]    RETURNS [deviceStatus: NewRS232CFace.DeviceStatus] = {    IF handle # fcb OR fcb = NIL THEN RETURN[nullStatus] ELSE      BEGIN      deviceStatus ¬ Inline.BITOR[fcb.deviceStatus, latchedStatus];      latchedStatus ¬ Inline.BITAND[deviceStatus, latchedStatusMask]      END};   GetHandle: PUBLIC PROC     [lineNumber: NewRS232CFace.LineNumber, rs232cClient: NewRS232CFace.RS232CClientType]    RETURNS [handle: Handle] = {    IF lineNumber = 0 AND currentClient = noClient AND fcb # NIL THEN      BEGIN      currentClient ¬ rs232cClient;      handle ¬ fcb      END      ELSE handle ¬ NIL};         GetNextLine: PUBLIC PROC [lineNumber: NewRS232CFace.LineNumber]    RETURNS [nextLineNumber: NewRS232CFace.LineNumber] = {    RETURN[IF lineNumber = NewRS232CFace.nullLineNumber AND fcb # NIL      THEN 0 ELSE NewRS232CFace.nullLineNumber]};  Initialize: PUBLIC PROC [notify: WORD] = {    IF fcb # NIL THEN      BEGIN      fcb.interruptSelector ¬ notify;      fcb.stopAgent ¬ FALSE      END};   InitializeCleanup: PUBLIC PROC =    BEGIN    item: DeviceCleanup.Item;    savedInterruptSelector: GuamInputOutput.InterruptSelectorType;    savedParameterBlock: NewRS232CFace.ParameterRecord;    IF fcb = NIL THEN RETURN;    savedInterruptSelector ¬ fcb.interruptSelector;    savedParameterBlock ¬ fcb.parameterBlock;    DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM	turnOff, kill =>	  BEGIN	  IF lineOn THEN	    BEGIN	    fcb.command ¬ abortReceive;	    GuamInputOutput.CallAgent[serial];	    fcb.command ¬ abortTransmit;	    GuamInputOutput.CallAgent[serial];	    fcb.command ¬ off;	    GuamInputOutput.CallAgent[serial];	    lineOn ¬ FALSE	    END;	  fcb.stopAgent ¬ TRUE;	  GuamInputOutput.CallAgent[serial];	  THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;          savedInterruptSelector ¬ fcb.interruptSelector;	  savedParameterBlock ¬ fcb.parameterBlock	  END;	turnOn =>	  BEGIN	  fcb.txIOCB ¬ fcb.rxIOCB ¬ NIL;          fcb.interruptSelector ¬ savedInterruptSelector;	  fcb.parameterBlock ¬ savedParameterBlock;	  fcb.command ¬ setParameters;	  fcb.stopAgent ¬ FALSE;	  GuamInputOutput.CallAgent[serial]	  END;	ENDCASE    ENDLOOP    END;  InitiateCommand: PUBLIC PROC [handle: Handle, command: NewRS232CFace.Command]     RETURNS [commandStatus: NewRS232CFace.CommandStatus] = {    IF handle # fcb OR fcb = NIL THEN RETURN[rejected] ELSE      BEGIN      fcb.commandStatus ¬ inProgress;      SELECT command FROM        abortReceive => fcb.command ¬ abortReceive;        abortTransmit => fcb.command ¬ abortTransmit;        breakOff => fcb.command ¬ breakOff;        breakOn => fcb.command ¬ breakOn;        getDeviceStatus => fcb.command ¬ getDeviceStatus;        off => {fcb.command ¬ off; lineOn ¬ FALSE};        on => {fcb.command ¬ on; lineOn ¬ TRUE};	ENDCASE;      GuamInputOutput.CallAgent[serial];      RETURN[inProgress]      END};    		  InitiateReceive: PUBLIC PROC [handle: Handle, operation: NewRS232CFace.OperationPtr]    RETURNS [transferStatus: NewRS232CFace.TransferStatus] = {    IF operation = NIL THEN RETURN[disaster] ELSE      BEGIN      iocb: SerialIOFaceGuam.SerialIOCBPtr = LOOPHOLE[operation];      iocb­ ¬ [operation­, FALSE, receive];      IF handle # fcb OR fcb = NIL OR operation.dataBuffer = NIL THEN	BEGIN	iocb.status ¬ disaster;	iocb.dequeued ¬ TRUE;	RETURN[disaster]	END;      IF operation.bufferByteLength = 0 THEN	BEGIN	iocb.status ¬ success;	iocb.dequeued ¬ TRUE;	RETURN[success]	END;      rxIOCBTail­ ¬ iocb;      rxIOCBTail ¬ @iocb.nextIOCB;      fcb.rxIOCB ¬ iocb;      fcb.command ¬ receive;      GuamInputOutput.CallAgent[serial];      RETURN[inProgress]      END}; 	  InitiateResetStatusBits: PUBLIC PROC    [handle: Handle, resetRecord: NewRS232CFace.ResetRecord]    RETURNS [NewRS232CFace.CommandStatus] = {    IF handle # fcb THEN RETURN[rejected] ELSE      BEGIN      latchedStatus ¬ Inline.BITAND[latchedStatus, Inline.BITNOT[resetRecord]];      RETURN[completed]      END};      InitiateSetControlBits: PUBLIC PROC    [handle: Handle, controlRecord: NewRS232CFace.ControlRecord]    RETURNS[NewRS232CFace.CommandStatus] = {    IF handle # fcb OR fcb = NIL THEN RETURN[rejected] ELSE      BEGIN      fcb.controlFlags ¬ controlRecord;      fcb.commandStatus ¬ inProgress;      fcb.command ¬ setControlBits;      GuamInputOutput.CallAgent[serial];      RETURN[inProgress]      END};      InitiateSetParameters: PUBLIC PROC    [handle: Handle, parameters: NewRS232CFace.ParameterHandle]     RETURNS [parameterStatus: NewRS232CFace.ParameterStatus] = {    IF handle # fcb OR fcb = NIL THEN RETURN[rejected] ELSE      BEGIN      fcb.parameterBlock ¬ parameters­;      fcb.commandStatus ¬ inProgress;      fcb.command ¬ setParameters;      GuamInputOutput.CallAgent[serial];      RETURN[inProgress]      END};  InitiateTransmit: PUBLIC PROC [handle: Handle, operation: NewRS232CFace.OperationPtr]    RETURNS [transferStatus: NewRS232CFace.TransferStatus] = {    IF operation = NIL THEN RETURN[disaster] ELSE      BEGIN      iocb: SerialIOFaceGuam.SerialIOCBPtr = LOOPHOLE[operation];      iocb­ ¬ [operation­, FALSE, transmit];      IF handle # fcb OR fcb = NIL OR operation.dataBuffer = NIL THEN	BEGIN	iocb.status ¬ disaster;	iocb.dequeued ¬ TRUE;	RETURN[disaster]	END;      IF operation.bufferByteLength = 0 THEN	BEGIN	iocb.status ¬ success;	iocb.dequeued ¬ TRUE;	RETURN[success]	END;      txIOCBTail­ ¬ iocb;      txIOCBTail ¬ @iocb.nextIOCB;      fcb.txIOCB ¬ iocb;      fcb.command ¬ transmit;      GuamInputOutput.CallAgent[serial];      RETURN[inProgress]      END};    IsReviveProcNeeded: PUBLIC PROCEDURE [handle: Handle]    RETURNS [needed: BOOLEAN] =    BEGIN    RETURN[FALSE];    END;     PollCommand, PollSetControlBits: PUBLIC PROC [handle: Handle]    RETURNS [commandStatus: NewRS232CFace.CommandStatus] = {    RETURN[IF handle # fcb OR fcb = NIL THEN rejected      ELSE IF fcb.commandStatus = inProgress THEN inProgress ELSE completed]};      PollReceiveOrTransmit: PUBLIC PROC    [handle: Handle, operation: NewRS232CFace.OperationPtr]    RETURNS [bytesTransferred: CARDINAL, transferStatus: NewRS232CFace.TransferStatus] =    BEGIN    iocb: SerialIOFaceGuam.SerialIOCBPtr = LOOPHOLE[operation];    IF iocb = NIL OR iocb.status = inProgress THEN RETURN[0, inProgress];    IF NOT iocb.dequeued THEN      BEGIN      SELECT iocb.iocbType FROM        receive =>	  FOR prev: LONG POINTER TO SerialIOFaceGuam.SerialIOCBPtr ¬ @rxIOCBHead,	    @prev­.nextIOCB UNTIL prev­ = NIL DO	    IF prev­ = iocb THEN	      BEGIN	      IF (prev­ ¬ iocb.nextIOCB) = NIL THEN rxIOCBTail ¬ prev;	      EXIT	      END;	  ENDLOOP;        transmit =>	  FOR prev: LONG POINTER TO SerialIOFaceGuam.SerialIOCBPtr ¬ @txIOCBHead,	    @prev­.nextIOCB UNTIL prev­ = NIL DO	    IF prev­ = iocb THEN	      BEGIN	      IF (prev­ ¬ iocb.nextIOCB) = NIL THEN txIOCBTail ¬ prev;	      EXIT	      END;	  ENDLOOP;        ENDCASE;      iocb.dequeued ¬ TRUE      END;    RETURN[iocb.actualLength, iocb.status]    END;  PollResetStatusBits: PUBLIC PROC [handle: Handle]    RETURNS [NewRS232CFace.CommandStatus] = {    RETURN[completed]};    PollSetParameters: PUBLIC PROC [handle: Handle]    RETURNS [parameterStatus: NewRS232CFace.ParameterStatus] = {    RETURN[IF handle # fcb OR fcb = NIL THEN rejected ELSE fcb.commandStatus]};  QueueIsBad: PUBLIC PROCEDURE [handle: NewRS232CFace.Handle]     RETURNS [badQueue: BOOLEAN] =    BEGIN    RETURN[FALSE];    END;  ReleaseHandle: PUBLIC PROC [handle: Handle]    RETURNS [nilHandle: Handle] =    BEGIN    IF handle = fcb AND fcb # NIL THEN      BEGIN      IF lineOn THEN        BEGIN        fcb.command ¬ off;        GuamInputOutput.CallAgent[serial];        lineOn ¬ FALSE	END;      currentClient ¬ noClient      END;    RETURN[NIL]    END;  ReviveInputQueue: PUBLIC PROCEDURE [handle: NewRS232CFace.Handle]     RETURNS[revived: BOOLEAN ¬ FALSE, skipped: CARDINAL ¬ 0] =    BEGIN    END;  END.LOG 8-Apr-93 - JPM - Created.
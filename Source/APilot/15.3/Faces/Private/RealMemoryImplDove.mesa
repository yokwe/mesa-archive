-- Copyright (C) 1985, 1986  by Xerox Corporation. All rights reserved. -- RealMemoryImplDove.mesa  27-Feb-87  9:19:03 by KEKDIRECTORY  Boot USING [countGermVM, pageGerm],  DoveInputOutput USING [    displayPageCount, firstMapPage, firstRealPage, firstReservedPage,    ioRegionPage, ioRegionPageCount, lastRealPage, mapPagesCount, numberRealPages,     pcPresent, RealPageCount, RealPageNumber, ReservedMemoryUse,     reservedPageCount],  Environment USING [    bitsPerWord, LongPointerFromPage, PageCount, PageNumber, wordsPerPage],  Inline USING [DBITAND, DBITNOT, LongCOPY, LowHalf],  PageMap USING [    Flags, flagsClean, flagsVacant, GetState, RealPageNumber, SetMapFlags,    SetMapState, State],  PilotSwitches USING [eatGerm, hang],  PilotSwitchesExtras USING [useSpecialMemory, useSpecialMemoryIfNoDisplay],  PilotSwitchesExtraExtras USING [saveDisplayPagesIndexA, saveDisplayPagesIndexB],  ProcessOperations USING [DisableInterrupts, EnableInterrupts],  ProcessorFaceExtras USING [Version],  RealMemory USING [],  RealMemoryExtras USING [],  SpecialSpace USING [DonateDedicatedRealMemory],  SpecialSystem USING [switches],  System USING [switches];RealMemoryImplDove: MONITOR  IMPORTS    DoveInputOutput, Environment, Inline, PageMap, ProcessOperations,    ProcessorFaceExtras, SpecialSpace, SpecialSystem, System  EXPORTS DoveInputOutput, RealMemory, RealMemoryExtras  SHARES PageMap =  BEGIN  ShortRealPageNumber: TYPE = DoveInputOutput.RealPageNumber;  maxDoveRealPages: CARDINAL = 2048*4;  -- Dove can have up to 2M words  --~~~~~ Variables, etc: ~~~~~~  GermVM: TYPE = Environment.PageNumber[CARDINAL[Boot.pageGerm]..CARDINAL[Boot.pageGerm + Boot.countGermVM]);  ShortenRealPageNumber: PROC [rpn: PageMap.RealPageNumber]    RETURNS [ShortRealPageNumber] =    -- Assumes Dove can not have more than 2**16 real pages.    INLINE {RETURN[LOOPHOLE[Inline.LowHalf[rpn]]]};  --RealMemory.--  allocMap: PUBLIC DESCRIPTOR FOR ARRAY OF WORD _ DESCRIPTOR[allocMapArray];  allocMapArray: ARRAY    [0..(maxDoveRealPages + Environment.bitsPerWord - 1)/Environment.bitsPerWord)    OF WORD;  -- (initial state not important)  currentReservedMemoryUse: DoveInputOutput.ReservedMemoryUse _ notBusy;  realPagesForCode: PACKED ARRAY [0..1024) OF {available, busy};  countFreePagesForCode: CARDINAL;  MemoryConfigurationError: ERROR = CODE;  Bug: ERROR [type: BugType] = CODE;  BugType: TYPE = {allocMapTooSmall, positiveCountButNoPage};  --~~~~~~~~~~~~~~~~ Initialization ~~~~~~~~~~~~~~~~  Initialize: PUBLIC --RealMemory.-- ENTRY PROCEDURE =    BEGIN    OPEN DIO: DoveInputOutput;    state: PageMap.State;    real: PageMap.RealPageNumber;    codeRealPage: ShortRealPageNumber;    realPagesForCode _ ALL[available];    countFreePagesForCode _ DIO.reservedPageCount - DIO.displayPageCount;    -- Look for reserved real pages behind the Germ and mark them unavailable:    -- (They could be there as a result of a previous boot.)    FOR virtual: Environment.PageNumber IN GermVM DO      [state, real] _ PageMap.GetState[virtual];      IF state.flags ~= PageMap.flagsVacant THEN {        codeRealPage _ ShortenRealPageNumber[real];        IF codeRealPage IN [DIO.firstReservedPage .. DIO.firstReservedPage + DIO.reservedPageCount) THEN {          realPagesForCode[codeRealPage - DIO.firstReservedPage] _ busy;          countFreePagesForCode _ PRED[countFreePagesForCode]};        };      ENDLOOP;    IF DisplayMemoryHeldBackFromPilotByGerm[] # DIO.displayPageCount THEN       countFreePagesForCode _ 0;    END;  Count: PUBLIC --RealMemory.-- ENTRY PROCEDURE    RETURNS [      count: Environment.PageCount,      realPageMin, realPageMax: PageMap.RealPageNumber] =    BEGIN    OPEN DIO: DoveInputOutput;    includeDisplayMemory: BOOLEAN =         (DisplayMemoryHeldBackFromPilotByGerm[] # DIO.displayPageCount);    -- initially, we account for all reserved pages which MAY appear in vm sometime.  This includes display bitmap, IORegion, and reserved pages behind Pilot resident code and the Germ.    count _ DIO.numberRealPages - DIO.mapPagesCount;    realPageMin _ DIO.firstRealPage;    IF NOT includeDisplayMemory AND realPageMin = DIO.firstReservedPage      THEN realPageMin _ DIO.firstReservedPage + DIO.displayPageCount;    IF realPageMin = DIO.firstMapPage      THEN realPageMin _ DIO.firstMapPage + DIO.mapPagesCount;    realPageMax _ DIO.lastRealPage;    IF realPageMax >= maxDoveRealPages OR count > maxDoveRealPages      THEN Bug[allocMapTooSmall];    END;  --~~~~~~~~~~~~~~~~ Public Procedures ~~~~~~~~~~~~~~~~  FreeReservedMemory: PUBLIC --RealMemory.-- ENTRY PROCEDURE [    keep: Environment.PageCount, bufferPage: Environment.PageNumber] =    BEGIN    OPEN DIO: DoveInputOutput;    amountOfDisplayReserved: CARDINAL ¬ DisplayMemoryHeldBackFromPilotByGerm[];    lastPageToReserve: ShortRealPageNumber ¬       DIO.firstReservedPage + amountOfDisplayReserved - 1;    IF amountOfDisplayReserved = 0 OR keep > lastPageToReserve THEN RETURN;    FOR real: ShortRealPageNumber IN      [DIO.firstReservedPage + Inline.LowHalf[keep] .. lastPageToReserve] DO      PageMap.SetMapFlags[        virtual: bufferPage, real: real, flags: PageMap.flagsClean];      SpecialSpace.DonateDedicatedRealMemory[page: bufferPage, count: 1];      ENDLOOP;    END;  MoveIntervalToDisplayMemory: PUBLIC --RealMemory.-- ENTRY PROCEDURE [    page: Environment.PageNumber, count: Environment.PageCount,    bufferPage: Environment.PageNumber] =    BEGIN    OPEN DIO: DoveInputOutput;    ate: BOOLEAN _ FALSE;  -- flag to tell if germ gets eaten by this procedure    eatingGerm: BOOLEAN _ (System.switches[PilotSwitches.eatGerm] = down);    pBuffer: LONG POINTER = Environment.LongPointerFromPage[bufferPage];    state: PageMap.State;  -- original flags of client VM page.    clientReal: PageMap.RealPageNumber;  -- original real page of client VM page.    shortClientReal: ShortRealPageNumber;  -- short form of real client VM page.      reservedReal: ShortRealPageNumber;  -- reserved real page to substitute under client VM page.    FOR curPage: Environment.PageNumber IN [page..page + count) DO      [state, clientReal] _ PageMap.GetState[virtual: curPage];      shortClientReal _ ShortenRealPageNumber[clientReal];      IF state.flags ~= PageMap.flagsVacant AND countFreePagesForCode > 0        AND shortClientReal ~IN [DIO.firstReservedPage .. DIO.firstReservedPage + DIO.reservedPageCount)        THEN IF ~(eatingGerm AND (curPage IN GermVM)) THEN          BEGIN          -- Got a source page mapped to an ordinary real page          --   and a reserved real page to swap with it..          FOR reservedReal DECREASING IN [0 .. DIO.reservedPageCount) DO            IF realPagesForCode[reservedReal] = available THEN EXIT;            REPEAT FINISHED => Bug[positiveCountButNoPage];            ENDLOOP;          realPagesForCode[reservedReal] _ busy;          countFreePagesForCode _ PRED[countFreePagesForCode];          reservedReal _ reservedReal + DIO.firstReservedPage;	  -- Prevent other processes from running while we unmap their code(!):          ProcessOperations.DisableInterrupts[];          -- DO NOT PUT BREAKPOINTS IN THIS SECTION BECAUSE WE MAY BE          -- MOMENTARILY UNMAPPING THE BREAKPOINT HANDLER'S CODE!          -- put (writable) reserved page behind client VM page          -- the contents is garbage.          PageMap.SetMapFlags[            virtual: curPage, real: reservedReal, flags: PageMap.flagsClean];          PageMap.SetMapState[  -- put client's real page behind buffer VM page.            virtual: bufferPage, real: clientReal, state: state];          Inline.LongCOPY[  -- copy client data into reserved real page.            from: pBuffer, to: Environment.LongPointerFromPage[curPage],            nwords: Environment.wordsPerPage];          -- Restore client page's readonly and referenced statuses:          PageMap.SetMapState[virtual: curPage, real: reservedReal, state: state];          ProcessOperations.EnableInterrupts[];  -- breakpoints allowed again.          -- SpecialSpace will snarf reserved page out from behind buffer.          SpecialSpace.DonateDedicatedRealMemory[page: bufferPage, count: 1];          END ELSE          BEGIN          ate _ TRUE;          SpecialSpace.DonateDedicatedRealMemory[page: curPage, count: 1]          END        ELSE IF shortClientReal IN [DIO.firstReservedPage .. DIO.firstReservedPage + DIO.reservedPageCount) AND eatingGerm          AND (curPage IN GermVM) AND state.flags ~= PageMap.flagsVacant THEN          BEGIN          PageMap.SetMapFlags[            virtual: curPage, real: NULL, flags: PageMap.flagsVacant];          countFreePagesForCode _ countFreePagesForCode + 1;          realPagesForCode[shortClientReal - DIO.firstReservedPage] _ available;          ate _ TRUE;          END;      ENDLOOP;    IF ate THEN SpecialSystem.switches[PilotSwitches.hang] _ down;    END;    PCBank: PUBLIC --RealMemoryExtras.-- ENTRY PROC RETURNS [    firstPCBankPage: PageMap.RealPageNumber, lastPCBankPagePlusOne: PageMap.RealPageNumber] =    -- Returns the bank of real memory, [firstPCBankPage..lastPCBankPagePlusOne),    -- that is allocated for PC emulation.  For Daybreak this bank is at the high    -- end of real memory.  For Daisy it comes at the next 256 page boundary after    -- the IO Region.  It includes a 128 KB space for the Sufi region (PCE    -- overhead).    BEGIN    PCBankAlignment: CARDINAL = 100H;    PCBankAlignmentMinus1: LONG CARDINAL = PCBankAlignment - 1;    PCBankAlignmentMask: LONG CARDINAL = Inline.DBITNOT[PCBankAlignmentMinus1];    ExpandedMemoryDiffPageDaisy: LONG CARDINAL = 1000H;    ExpandedMemoryDiffPageDaybreak: LONG CARDINAL = 6000B;    SmallPCBankPageCount: CARDINAL = 300H;    LargePCBankPageCount: CARDINAL = 600H;      SELECT ProcessorFaceExtras.Version[].machineType FROM        daisy => BEGIN	  IF ProcessorFaceExtras.Version[].machineType = daisy THEN BEGIN	    --PCBank begins on the first 128KB (100H page) boundary after the IO Region ends.	    firstPCBankPage ¬ Inline.DBITAND[DoveInputOutput.ioRegionPage +	      DoveInputOutput.ioRegionPageCount + PCBankAlignmentMinus1,	      PCBankAlignmentMask];	    --If no pc present then bank is 0 pages long. 	    IF DoveInputOutput.pcPresent = 0 THEN	      lastPCBankPagePlusOne ¬ firstPCBankPage	    --If small memory configuration PCBank is 3 100H page blocks long.	    ELSE IF DoveInputOutput.lastRealPage < ExpandedMemoryDiffPageDaisy THEN	      lastPCBankPagePlusOne ¬ firstPCBankPage + SmallPCBankPageCount	    --If larger memory configuration PCBank is 6 100H page blocks long.	    ELSE lastPCBankPagePlusOne ¬ firstPCBankPage + LargePCBankPageCount; 	  END;	END;	daybreak => BEGIN	  lastPCBankPagePlusOne ¬ DoveInputOutput.lastRealPage + 1;	  IF DoveInputOutput.pcPresent = 0 THEN	    firstPCBankPage ¬ lastPCBankPagePlusOne   -- no space allocated	  ELSE IF DoveInputOutput.lastRealPage < 6000B THEN  -- on 1 MB machine lastRealPage = 5777B	    firstPCBankPage ¬ lastPCBankPagePlusOne - 1400B  -- allow up to 256K PC for user	  ELSE firstPCBankPage ¬ lastPCBankPagePlusOne - 3000B;  -- allow up to 640K for user	END;	ENDCASE => lastPCBankPagePlusOne ¬ firstPCBankPage ¬ 0;    END;  SetReservedMemoryUse: PUBLIC --DoveInputOutput.-- ENTRY PROC [    use: DoveInputOutput.ReservedMemoryUse, pagesNeeded: Environment.PageCount] =    {    realPagesNeeded: DoveInputOutput.RealPageCount = Inline.LowHalf [pagesNeeded];    IF pagesNeeded > LAST [DoveInputOutput.RealPageCount] OR      (SELECT use FROM         notBusy => FALSE,         Raven => currentReservedMemoryUse = Display           OR realPagesNeeded > DoveInputOutput.reservedPageCount,         Display => currentReservedMemoryUse = Raven,         ENDCASE => TRUE) THEN ERROR MemoryConfigurationError;    currentReservedMemoryUse _ use;    countFreePagesForCode _ DoveInputOutput.reservedPageCount - realPagesNeeded};  SpecialResidentCodeHandle: PUBLIC --RealMemory.-- PROCEDURE = {};  -- This procedure's only purpose is to provide a handle on the Heads CODE PACK  -- which contains resident code which may be moved to reserved memory.  --~~~~~~~~~~~~~~~~ Private Procedures ~~~~~~~~~~~~~~~~  DisplayMemoryHeldBackFromPilotByGerm: PROCEDURE RETURNS [CARDINAL] =    BEGIN    SELECT TRUE FROM       (System.switches[PilotSwitchesExtras.useSpecialMemory] = down AND       System.switches[PilotSwitchesExtraExtras.saveDisplayPagesIndexA] = down AND      System.switches[PilotSwitchesExtraExtras.saveDisplayPagesIndexB] = down) =>      	RETURN[128];      (System.switches[PilotSwitchesExtras.useSpecialMemory] = down AND       System.switches[PilotSwitchesExtraExtras.saveDisplayPagesIndexA] = down) =>      	RETURN[48];      (System.switches[PilotSwitchesExtras.useSpecialMemory] = down AND       System.switches[PilotSwitchesExtraExtras.saveDisplayPagesIndexB] = down) =>      	RETURN[64];      (System.switches[PilotSwitchesExtras.useSpecialMemory] = down OR       (System.switches[PilotSwitchesExtras.useSpecialMemoryIfNoDisplay] = down      AND DoveInputOutput.displayPageCount = 0)) =>        RETURN[0];      ENDCASE => RETURN[DoveInputOutput.displayPageCount];    END;  END.  LOG16-Nov-84 -- JPM     -- Created from RealMemoryImplDLion.27-Nov-84 -- JPM     -- Reordered tests in Count.3-Dec-84 -- JPM     -- Eliminated truncation warning in SetReservedMemoryUse 4-Apr-85 -- MLT    -- Added PCBank and initialized for 256KB for PCE14-Apr-85 -- DEG      -- Modified PCBank to scale with memory size to allow for at least a 640Kb PC on a 1Mb machine.15-Apr-85 -- MLT    -- Modified PCBank to reserve pages [4400B..6000B).16-Apr-85 -- MLT    -- Modified PCBank to reserve pages [4000B..5400B). 8-May-85 12:47:40 -- CRF -- Hacked PCBank temporarily to turn off the PC bank if we're running on UtilityPilot.15-Aug-85 10:17:16 -- MLT -- Changed PCBank to check for presence of PCE and size of memory available.29-Aug-85 13:52:58 -- MLT -- Changed PCBank to allocate space at the high end of memory.25-Feb-86 11:01:45 -- CJ/RH -- Change count procedure to NOT subtract the display bank10-Apr-86 17:16:22	ET	Renamed DisplayMemoryGivenToPilotByGerm to DisplayMemoryHeldBackFromPilotByGerm. It now returns a count of reserved display pages, depending on pilot switches, instead of a boolean.  Changed FreeReservedMemory, Initialize, and Count accordingly.23-Jan-87 12:45:37	RDH	Added Daisy allocation to PCBank.27-Feb-87  9:18:16	KEK	bumped limit of realPagesForCode array from 512 to support Daisy display memory = 1024.
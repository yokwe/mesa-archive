-- ParallelHeadGuam.mesa - last edit:--  JPM		20-Apr-93 13:58:55-- Copyright (C) 1993 by Xerox Corporation.  All rights reserved.<< The following program was created in 1993 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  BiParallelPortFace USING [CommandStatus, DeviceStatus, HardwareStatus, InitializationStatus, nullPortNumber, OperationPtr, Parameters, Port, PortType, Transfer, TransferStatus],  DeviceCleanup USING [Await, Item, Reason],  Environment USING [Base, bitsPerWord, first64K],  GuamInputOutput USING [CallAgent, GetFCBPtr, InterruptSelectorType],  HeadStartChain USING [Start],  ParallelIOFaceGuam USING [ParallelFCBType, ParallelIOCBPtr, ParallelIOCBType],  Zone USING [Alignment];  ParallelHeadGuam: PROGRAM   IMPORTS DeviceCleanup, GuamInputOutput, RemainingHeads: HeadStartChain   EXPORTS BiParallelPortFace, HeadStartChain =   BEGIN  -- copied TYPEs  CommandStatus: TYPE = BiParallelPortFace.CommandStatus;  Port: TYPE = BiParallelPortFace.Port;  -- constants  fcb: LONG POINTER TO ParallelIOFaceGuam.ParallelFCBType =    GuamInputOutput.GetFCBPtr[parallel];  maxNumberOfPorts: CARDINAL = Environment.bitsPerWord; -- more than needed  -- PUBLIC variables  operationSize: PUBLIC CARDINAL ¬ SIZE[ParallelIOFaceGuam.ParallelIOCBType];  operationAlignment: PUBLIC Zone.Alignment ¬ a2; -- doubleword boundary  operationLocation: PUBLIC Environment.Base ¬ Environment.first64K;  numberOfPorts: PUBLIC CARDINAL ¬ IF fcb = NIL THEN 0 ELSE fcb.numberOfPorts;  maxBlockSizeInBytes: PUBLIC CARDINAL ¬ LAST[CARDINAL];  -- PRIVATE variables  cleanupInitialized: BOOLEAN ¬ FALSE;  iocbHead: ParallelIOFaceGuam.ParallelIOCBPtr ¬ NIL;  iocbTail: LONG POINTER TO ParallelIOFaceGuam.ParallelIOCBPtr ¬ @iocbHead;  portInUse: PACKED ARRAY [0..maxNumberOfPorts) OF BOOLEAN ¬ ALL[FALSE];  portWasReset: PACKED ARRAY [0..maxNumberOfPorts) OF BOOLEAN ¬ ALL[FALSE];  deviceWasReset: PACKED ARRAY [0..maxNumberOfPorts) OF BOOLEAN ¬ ALL[FALSE];  portTestData: WORD ¬ 0;  -- PUBLIC PROCs  BiParallelPortExists: PUBLIC PROC [port: Port] RETURNS [BOOLEAN] = {    RETURN[IF fcb = NIL THEN FALSE ELSE (port < fcb.numberOfPorts)]};  GetHardwareStatusBits: PUBLIC PROC [port: Port] RETURNS [    commandStatus: CommandStatus, hardwareStatus: BiParallelPortFace.HardwareStatus] = {    RETURN[unimplemented, [port, outputOnly, 0, 0]]};  GetNextAvailablePort: PUBLIC PROC [portType: BiParallelPortFace.PortType]    RETURNS [nextPort: Port] =    BEGIN    IF fcb = NIL OR portType # outputOnly THEN RETURN[BiParallelPortFace.nullPortNumber];    FOR nextPort IN [0..fcb.numberOfPorts) DO      IF NOT portInUse[nextPort] THEN RETURN;    ENDLOOP;    RETURN[BiParallelPortFace.nullPortNumber]    END;  GetStatus: PUBLIC PROC [port: Port] RETURNS [    commandStatus: CommandStatus, deviceStatus: BiParallelPortFace.DeviceStatus] =    BEGIN    IF fcb = NIL OR port >= fcb.numberOfPorts THEN RETURN[invalidParameter, []];    deviceStatus ¬ [      port: port, portType: outputOnly, select: portInUse[port],      portWasReset: portWasReset[port], deviceWasReset: deviceWasReset[port],      statusIsUpToDate: TRUE, testResultIsUpToDate: TRUE];      -- and other fields default    portWasReset[port] ¬ deviceWasReset[port] ¬ FALSE;    RETURN[ready, deviceStatus]    END;  GetTestResult: PUBLIC PROC RETURNS [returnPattern: WORD] = {    -- since we have no H/W loopback, fake the result so client is happy    RETURN[portTestData]};  Initialize: PUBLIC PROC [notify: WORD]    RETURNS [initStatus: BiParallelPortFace.InitializationStatus] =    BEGIN    IF fcb = NIL THEN RETURN[optionHardwareNotDetected];    IF NOT fcb.stopAgent THEN      BEGIN      fcb.stopAgent ¬ TRUE;      GuamInputOutput.CallAgent[parallel];      THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP      END;    iocbHead ¬ NIL;    iocbTail ¬ @iocbHead;    fcb.nextIOCB ¬ NIL;    fcb.interruptSelector ¬ notify;    fcb.stopAgent ¬ FALSE;    RETURN[success]    END;  InitializeCleanup: PUBLIC PROC = {IF fcb # NIL THEN    BEGIN    item: DeviceCleanup.Item;    savedInterruptSelector: GuamInputOutput.InterruptSelectorType ¬ fcb.interruptSelector;    IF cleanupInitialized THEN RETURN;    cleanupInitialized ¬ TRUE;    DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM	turnOff, kill =>	  BEGIN	  fcb.stopAgent ¬ TRUE;	  GuamInputOutput.CallAgent[parallel];	  THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;	  savedInterruptSelector ¬ fcb.interruptSelector	  END;	turnOn =>	  BEGIN	  iocb: ParallelIOFaceGuam.ParallelIOCBPtr;	  FOR iocb ¬ iocbHead, iocb.nextIOCB UNTIL iocb = NIL DO	    IF iocb.status = inProgress THEN EXIT;	  ENDLOOP;	  fcb.nextIOCB ¬ iocb;	  fcb.interruptSelector ¬ savedInterruptSelector;	  fcb.stopAgent ¬ FALSE;	  GuamInputOutput.CallAgent[parallel]	  END;	ENDCASE    ENDLOOP    END};  InitiateDeviceReset: PUBLIC PROC [port: Port]    RETURNS [commandStatus: CommandStatus] =    BEGIN    IF fcb = NIL OR port >= fcb.numberOfPorts THEN RETURN[invalidParameter];    deviceWasReset[port] ¬ TRUE;    RETURN[ready]    END;  InitiatePortReset: PUBLIC PROC [port: Port]    RETURNS [commandStatus: CommandStatus] =    BEGIN    chase: LONG POINTER TO ParallelIOFaceGuam.ParallelIOCBPtr ¬ @iocbHead;    IF fcb = NIL OR port >= fcb.numberOfPorts THEN RETURN[invalidParameter];    fcb.stopAgent ¬ TRUE;    GuamInputOutput.CallAgent[parallel];    THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;    fcb.nextIOCB ¬ NIL;    UNTIL chase­ = NIL DO      iocb: ParallelIOFaceGuam.ParallelIOCBPtr ¬ chase­;      IF iocb.status = inProgress THEN        IF iocb.port = port THEN	  BEGIN	  iocb.status ¬ aborted;	  IF (chase­ ¬ iocb.nextIOCB) = NIL THEN iocbTail ¬ chase;	  LOOP	  END	  ELSE IF fcb.nextIOCB = NIL THEN fcb.nextIOCB ¬ iocb;      chase ¬ @iocb.nextIOCB    ENDLOOP;    fcb.stopAgent ¬ FALSE;    GuamInputOutput.CallAgent[parallel];    portWasReset[port] ¬ TRUE;    RETURN[ready]    END;  InitiateTest: PUBLIC PROC [port: Port, diagnosticTestPattern: WORD]    RETURNS [commandStatus: CommandStatus] =    BEGIN    -- since we have no H/W loopback, fake the result so client is happy    portTestData ¬ diagnosticTestPattern;    RETURN[ready]    END;  InitiateTransfer: PUBLIC PROC [transfer: BiParallelPortFace.Transfer]      RETURNS [commandStatus: CommandStatus] =    BEGIN    iocb: ParallelIOFaceGuam.ParallelIOCBPtr = LOOPHOLE[transfer.operation];    IF fcb = NIL OR transfer.port >= fcb.numberOfPorts OR transfer.transferMode # put OR      transfer.operation = NIL OR transfer.operation.dataBufferPtr = NIL      THEN RETURN[invalidParameter];    iocb.port ¬ transfer.port;    iocb.transferMode ¬ put;    iocb.controlOrData ¬ transfer.controlOrData;    iocb.nextIOCB ¬ NIL;    iocb.status ¬ inProgress;    iocb.bytesTransferred ¬ 0;    iocbTail­ ¬ iocb;    iocbTail ¬ @iocb.nextIOCB;    fcb.nextIOCB ¬ iocb;    GuamInputOutput.CallAgent[parallel];    RETURN[inProgress]    END;  PollTransferStatus: PUBLIC PROC [port: Port, operation: BiParallelPortFace.OperationPtr]    RETURNS [transferStatus: BiParallelPortFace.TransferStatus, bytesTransferred: CARDINAL] =    BEGIN    iocb: ParallelIOFaceGuam.ParallelIOCBPtr = LOOPHOLE[operation];    IF iocb = NIL OR iocb.status = inProgress      THEN RETURN[inProgress, 0];    FOR prev: LONG POINTER TO ParallelIOFaceGuam.ParallelIOCBPtr ¬ @iocbHead,      @prev­.nextIOCB UNTIL prev­ = NIL DO      IF prev­ = iocb THEN        BEGIN	IF (prev­ ¬ iocb.nextIOCB) = NIL THEN iocbTail ¬ prev;	EXIT	END;    ENDLOOP;    transferStatus ¬ (SELECT iocb.status FROM      completed => success,      aborted => aborted,      ENDCASE => incomplete);    bytesTransferred ¬ iocb.bytesTransferred    END;  SetParameters: PUBLIC PROC [parameters: BiParallelPortFace.Parameters] = {    IF fcb # NIL AND parameters.port < fcb.numberOfPorts      THEN portInUse[parameters.port] ¬ parameters.portInUse};  Start: PUBLIC --HeadStartChain.-- PROC =    {RemainingHeads.Start[]};  TestIfBiParallelPortExists: PUBLIC PROC [port: Port]    RETURNS [commandStatus: CommandStatus] = {    RETURN[ready]};  UpdateStatus: PUBLIC PROC [port: Port]    RETURNS [commandStatus: CommandStatus] = {    RETURN[ready]};  END.LOG20-Apr-93 - JPM - Created.
-- CoProcessorHeadGuam.mesa - last edit:--  JPM		 7-May-93 11:53:23-- Copyright (C) 1993 by Xerox Corporation.  All rights reserved.<< The following program was created in 1993 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  CoProcessorFace USING [ServerID, Status],  CoProcessorIOFaceGuam USING [CoProcessorFCBType, CoProcessorIOCBPtr, CoProcessorIOCBType],  DeviceCleanup USING [Await, Item, Reason],  ESCAlpha USING [aBYTBLT],  GuamInputOutput USING [CallAgent, GetFCBPtr, InterruptSelectorType],  HeadStartChain USING [Start],  Mopcodes USING [zESC],  Stream USING [Block, Byte, CompletionCode, SubSequenceType],  Zone USING [Alignment];  CoProcessorHeadGuam: PROGRAM   IMPORTS DeviceCleanup, GuamInputOutput, RemainingHeads: HeadStartChain   EXPORTS CoProcessorFace, HeadStartChain =   BEGIN  OPEN CoProcessorIOFaceGuam;  -- PUBLIC TYPE  ConnectionRec: PUBLIC TYPE = CoProcessorIOCBType;  -- constants  fcb: LONG POINTER TO CoProcessorFCBType = GuamInputOutput.GetFCBPtr[stream];  -- PUBLIC variables  connectionRecSize: PUBLIC CARDINAL ¬ MAX[SIZE[CoProcessorIOCBType],    (IF fcb = NIL THEN 0 ELSE fcb.streamWordSize)];  connectionRecAlignment: PUBLIC Zone.Alignment ¬ a2; -- doubleword boundary  -- PUBLIC PROCs  Get: PUBLIC PROC [connection: CoProcessorIOCBPtr, block: Stream.Block]    RETURNS [bytesTransferred: CARDINAL, why: Stream.CompletionCode,             sst: Stream.SubSequenceType] =    BEGIN    bytesWanted: CARDINAL = block.stopIndexPlusOne - block.startIndex;    IF connection = NIL OR fcb = NIL THEN RETURN[0, endOfStream, 0];    connection.mesaGet.writeLockedByMesa ¬ TRUE;    bytesTransferred ¬ MIN[bytesWanted,      (connection.mesaGet.bytesWritten - connection.mesaGet.bytesRead)];    IF bytesTransferred > 0 THEN      BEGIN      ByteBlt[block.blockPointer, block.startIndex, bytesTransferred,        connection.mesaGet.buffer, connection.mesaGet.bytesRead];      connection.mesaGet.bytesRead ¬ connection.mesaGet.bytesRead + bytesTransferred      END;    why ¬ SELECT TRUE FROM      connection.mesaGet.bytesRead < connection.mesaGet.bytesWritten => normal,      connection.mesaGet.endStream => endOfStream,      connection.mesaGet.endRecord => endRecord,      connection.mesaGet.endSST => sstChange,      ENDCASE => normal;    sst ¬ connection.mesaGet.subSequence;    connection.mesaGet.interruptMesa ¬ bytesTransferred < bytesWanted AND why = normal;    IF connection.mesaGet.bytesRead < connection.mesaGet.bytesWritten      THEN connection.mesaGet.writeLockedByMesa ¬ FALSE ELSE      BEGIN      connection.mesaGet.endRecord ¬ connection.mesaGet.endSST ¬ FALSE;      connection.mesaGet.bytesRead ¬ connection.mesaGet.bytesWritten ¬ 0;      connection.mesaGet.writeLockedByMesa ¬ FALSE;      IF connection.mesaGet.hTask # 0 THEN        BEGIN        fcb.iocbNext ¬ connection;        fcb.headCommand ¬ write;        GuamInputOutput.CallAgent[stream]        END;      END;    END;  GetSST: PUBLIC PROC [connection: CoProcessorIOCBPtr]    RETURNS [Stream.SubSequenceType] = {    RETURN[IF connection = NIL THEN 0 ELSE connection.mesaPut.subSequence]};  Initialize: PUBLIC PROC [notifyMask: WORD] = {IF fcb # NIL THEN    BEGIN    IF NOT fcb.stopAgent THEN      BEGIN      fcb.stopAgent ¬ TRUE;      GuamInputOutput.CallAgent[stream];      THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP      END;    fcb.iocbHead ¬ NIL;    fcb.iocbNext ¬ NIL;    fcb.headCommand ¬ idle;    fcb.filler5 ¬ 0;    fcb.headResult ¬ completed;    fcb.filler7 ¬ 0;    fcb.interruptSelector ¬ notifyMask;    fcb.stopAgent ¬ FALSE;    GuamInputOutput.CallAgent[stream]    END};  InitializeCleanup: PUBLIC PROC = {IF fcb # NIL THEN    BEGIN    item: DeviceCleanup.Item;    savedStopAgent: BOOLEAN ¬ fcb.stopAgent;    savedInterruptSelector: GuamInputOutput.InterruptSelectorType ¬ fcb.interruptSelector;    savedIOCBHead: CoProcessorIOCBPtr ¬ fcb.iocbHead;    DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM	turnOff, kill =>	  BEGIN	  IF NOT (savedStopAgent ¬ fcb.stopAgent) THEN	    BEGIN	    fcb.stopAgent ¬ TRUE;	    GuamInputOutput.CallAgent[stream]	    END;	  THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;          savedInterruptSelector ¬ fcb.interruptSelector;          savedIOCBHead ¬ fcb.iocbHead	  END;	turnOn =>	  BEGIN          fcb.interruptSelector ¬ savedInterruptSelector;          fcb.iocbHead ¬ savedIOCBHead;	  fcb.iocbNext ¬ NIL;	  IF NOT (fcb.stopAgent ¬ savedStopAgent)	    THEN GuamInputOutput.CallAgent[stream];	  END;	ENDCASE    ENDLOOP    END};  InitiateConnection: PUBLIC PROC [    connection: CoProcessorIOCBPtr, serverID: CoProcessorFace.ServerID, isServer: BOOLEAN,    mesaPutBuffer: LONG DESCRIPTOR FOR PACKED ARRAY OF Stream.Byte,    mesaGetBuffer: LONG DESCRIPTOR FOR PACKED ARRAY OF Stream.Byte]    RETURNS [CoProcessorFace.Status] =    BEGIN    IF connection = NIL THEN RETURN[error];    IF fcb = NIL THEN RETURN[completed];    connection­ ¬ [      serverID: serverID, mesaConnectionState: IF isServer THEN accepting ELSE idle,      mesaPut: [buffer: BASE[mesaPutBuffer], bufferSize: LENGTH[mesaPutBuffer]],      mesaGet: [buffer: BASE[mesaGetBuffer], bufferSize: LENGTH[mesaGetBuffer]],      nextIOCB: fcb.iocbHead, mesaIsServer: isServer];    fcb.iocbHead ¬ connection;    IF isServer THEN RETURN[inProgress];    fcb.iocbNext ¬ connection;    fcb.headCommand ¬ connect;    GuamInputOutput.CallAgent[stream];    SELECT fcb.headResult FROM      completed =>        BEGIN	connection.mesaConnectionState ¬ connected;	RETURN[completed]	END;      error =>        BEGIN	fcb.iocbHead ¬ connection.nextIOCB;	connection.mesaConnectionState ¬ deleted;	RETURN[error]	END;      ENDCASE => RETURN[inProgress]    END;  InitiateDisconnection: PUBLIC PROC [connection: CoProcessorIOCBPtr, unilateral: BOOLEAN]    RETURNS [CoProcessorFace.Status] =    BEGIN    IF connection = NIL THEN RETURN[error];    IF fcb = NIL THEN RETURN[completed];    connection.mesaConnectionState ¬ deleted;    IF connection.pcConnectionState # deleted AND NOT unilateral THEN      BEGIN      connection.mesaPut.writeLockedByMesa ¬ TRUE;      connection.mesaPut.endStream ¬ TRUE;      fcb.iocbNext ¬ connection;      IF connection.mesaPut.bytesWritten > connection.mesaPut.bytesRead THEN        BEGIN	connection.mesaPut.interruptMesa ¬ TRUE;	connection.mesaPut.writeLockedByMesa ¬ FALSE;	RETURN[inProgress];        END;      connection.mesaPut.writeLockedByMesa ¬ FALSE;      fcb.headCommand ¬ delete;      GuamInputOutput.CallAgent[stream];      IF connection.pcConnectionState # deleted THEN RETURN[inProgress];      END;    FOR prev: LONG POINTER TO CoProcessorIOCBPtr ¬ @fcb.iocbHead, @prev­.nextIOCB      UNTIL prev­ = NIL DO      IF prev­ = connection THEN	BEGIN	prev­ ¬ connection.nextIOCB;	EXIT	END;    ENDLOOP;    RETURN[completed]    END;  Poll: PUBLIC PROC [connection: CoProcessorIOCBPtr]    RETURNS [CoProcessorFace.Status] =    BEGIN    IF fcb = NIL THEN RETURN[completed];    IF connection.mesaConnectionState # deleted THEN      IF connection.pcConnectionState = idle THEN RETURN[inProgress] ELSE	  BEGIN	  connection.mesaConnectionState ¬ connected;	  RETURN[completed]	  END;    IF connection.pcConnectionState # deleted THEN      BEGIN      IF connection.mesaPut.bytesWritten > connection.mesaPut.bytesRead	THEN RETURN[inProgress];      fcb.headCommand ¬ delete;      GuamInputOutput.CallAgent[stream];      IF connection.pcConnectionState # deleted THEN RETURN[inProgress];      END;    FOR prev: LONG POINTER TO CoProcessorIOCBPtr ¬ @fcb.iocbHead, @prev­.nextIOCB      UNTIL prev­ = NIL DO      IF prev­ = connection THEN	BEGIN	prev­ ¬ connection.nextIOCB;	EXIT	END;    ENDLOOP;    RETURN[completed]    END;  Put: PUBLIC PROC [connection: CoProcessorIOCBPtr, block: Stream.Block, endRecord: BOOLEAN]    RETURNS [bytesTransferred: CARDINAL] =    BEGIN    bytesAvail: CARDINAL = block.stopIndexPlusOne - block.startIndex;    IF connection = NIL OR fcb = NIL OR connection.pcConnectionState = deleted      THEN RETURN[bytesAvail];    connection.mesaPut.writeLockedByMesa ¬ TRUE;    IF connection.mesaPut.endRecord OR connection.mesaPut.endSST THEN      BEGIN      connection.mesaPut.interruptMesa ¬ TRUE;      connection.mesaPut.writeLockedByMesa ¬ FALSE;      RETURN[0]      END;    bytesTransferred ¬ MIN[bytesAvail,      (connection.mesaPut.bufferSize - connection.mesaPut.bytesWritten)];    IF bytesTransferred > 0      THEN ByteBlt[connection.mesaPut.buffer, connection.mesaPut.bytesWritten,        bytesTransferred, block.blockPointer, block.startIndex];    connection.mesaPut.bytesWritten ¬ connection.mesaPut.bytesWritten + bytesTransferred;    connection.mesaPut.endRecord ¬ endRecord AND (bytesTransferred >= bytesAvail);    connection.mesaPut.endSST ¬ FALSE;    connection.mesaPut.interruptMesa ¬ (bytesTransferred < bytesAvail);    connection.mesaPut.writeLockedByMesa ¬ FALSE;    IF connection.mesaPut.hTask # 0 THEN      BEGIN      fcb.iocbNext ¬ connection;      fcb.headCommand ¬ read;      GuamInputOutput.CallAgent[stream]      END;    END;  SetSST: PUBLIC PROC [connection: CoProcessorIOCBPtr, sst: Stream.SubSequenceType]    RETURNS [CoProcessorFace.Status] =    BEGIN    IF connection = NIL THEN RETURN[error];    IF fcb = NIL OR connection.pcConnectionState = deleted OR      connection.mesaPut.subSequence = sst THEN RETURN[completed];    connection.mesaPut.writeLockedByMesa ¬ TRUE;    IF connection.mesaPut.bytesWritten > connection.mesaPut.bytesRead OR      connection.mesaPut.endRecord OR connection.mesaPut.endSST THEN      BEGIN      connection.mesaPut.interruptMesa ¬ TRUE;      connection.mesaPut.writeLockedByMesa ¬ FALSE;      RETURN[busyTryLater]      END;    connection.mesaPut.subSequence ¬ sst;    connection.mesaPut.endSST ¬ TRUE;    connection.mesaPut.writeLockedByMesa ¬ FALSE;    RETURN[completed]    END;  Start: PUBLIC --HeadStartChain.-- PROC =    {RemainingHeads.Start[]};  -- MACHINE CODE PROC to do the BLTing  ByteBlt: PROC [destBase: LONG POINTER, destIndex, count: CARDINAL,                 sourceBase: LONG POINTER, sourceIndex: CARDINAL] = MACHINE CODE {    Mopcodes.zESC, ESCAlpha.aBYTBLT};  END.LOG22-Apr-93 - JPM - Created. 7-May-93 - JPM - Added unilateral to InitiateDisconnection.
-- DiskHeadGuam.mesa - last edit:--  JPM		 8-Mar-93  7:44:16-- Copyright (C) 1993 by Xerox Corporation.  All rights reserved.<< The following program was created in 1993 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  Boot USING [BootFileDescriptorPageHandle, BootFileDescriptorPageSeal, BootFileDescriptorPageVersion, eofDescriptorLink],  Device USING [nullType, Type],  DeviceCleanup USING [Await, Item, Reason],  DiskIOFaceGuam USING [DiskFCBType, DiskIOCBPtr, DiskIOCBType],  Environment USING [wordsPerPage],  GuamInputOutput USING [CallAgent, GetFCBPtr, InterruptSelectorType],  HeadStartChain USING [Start],--PhysicalVolumeFormat USING [rootPageNumber, rootPageSize],  PilotDiskFace USING [DeterminationMode, DiskAddress, FormattingSpec, FormattingUnit, GlobalStatePtr, OperationPtr, Status, Tries],  Zone USING [Alignment];  DiskHeadGuam: PROGRAM   IMPORTS DeviceCleanup, GuamInputOutput, RemainingHeads: HeadStartChain   EXPORTS HeadStartChain, PilotDiskFace =   BEGIN  -- PUBLIC TYPEs  ControllerHandle: PUBLIC TYPE = CARDINAL;  DeviceHandle: PUBLIC TYPE = CARDINAL;  -- constants--duplicateRootPageNumber: CARDINAL = PhysicalVolumeFormat.rootPageNumber + PhysicalVolumeFormat.rootPageSize;  duplicateRootPageNumber: CARDINAL = 5; -- make sure to keep this correct  -- PUBLIC variables  nullControllerHandle: PUBLIC ControllerHandle ¬ LAST[CARDINAL];  nullDeviceHandle: PUBLIC DeviceHandle ¬ LAST[CARDINAL];  operationSize: PUBLIC CARDINAL ¬ SIZE[DiskIOFaceGuam.DiskIOCBType];  operationAlignment: PUBLIC Zone.Alignment ¬ a2; -- doubleword boundary  -- PRIVATE variables  fcb: LONG POINTER TO DiskIOFaceGuam.DiskFCBType = GuamInputOutput.GetFCBPtr[disk];  cleanupInitialized: BOOLEAN ¬ FALSE;  iocbHead: DiskIOFaceGuam.DiskIOCBPtr ¬ NIL;  iocbTail: LONG POINTER TO DiskIOFaceGuam.DiskIOCBPtr ¬ @iocbHead;  rejectedIOCB: DiskIOFaceGuam.DiskIOCBPtr ¬ NIL;  -- PUBLIC PROCs  DetermineDiskShape: PUBLIC PROC [    device: DeviceHandle, operation: PilotDiskFace.OperationPtr,    mode: PilotDiskFace.DeterminationMode, buffer: LONG POINTER]    RETURNS [nowKnown: BOOLEAN] = {    RETURN[TRUE]}; -- disk shape is always known  GetControllerAttributes: PUBLIC PROC [ControllerHandle]    RETURNS [globalStateSize: CARDINAL] = {    RETURN [0]};  GetDeviceAttributes: PUBLIC PROC [device: DeviceHandle]    RETURNS [cylinders, movingHeads, fixedHeads, sectorsPerTrack: CARDINAL] = {    IF device < fcb.numberOfDCBs      THEN RETURN[fcb.dcbs[device].numberOfCylinders,        fcb.dcbs[device].numberOfHeads, 0, fcb.dcbs[device].sectorsPerTrack]      ELSE RETURN[0, 0, 0, 0]};  GetDeviceType: PUBLIC PROC [device: DeviceHandle] RETURNS [Device.Type] = {    RETURN[IF device < fcb.numberOfDCBs      THEN fcb.dcbs[device].deviceType      ELSE Device.nullType]};  GetDriveInfo: PUBLIC PROC [device: DeviceHandle]    RETURNS [firstPageOfInitialMicrocode: PilotDiskFace.DiskAddress,      lastPageOfInitialMicrocode: PilotDiskFace.DiskAddress,      firstPilotPage: PilotDiskFace.DiskAddress,      formattingSpec: PilotDiskFace.FormattingSpec,      formattingAlignment: PilotDiskFace.FormattingUnit] = {    RETURN[[0, 0, duplicateRootPageNumber], [0, 0, duplicateRootPageNumber - 1], [0, 1, 0], NIL, arbitrary]};    -- no initial microcode on this disk; no formatting operations needed  GetFormattingUnit: PUBLIC PROC [device: DeviceHandle]    RETURNS [PilotDiskFace.FormattingUnit] = {    RETURN[arbitrary]};  GetNextController: PUBLIC PROC [controller: ControllerHandle]    RETURNS [ControllerHandle] = {    RETURN[IF controller = nullControllerHandle THEN 0      ELSE nullControllerHandle]};  GetNextDevice: PUBLIC PROC [device: DeviceHandle]    RETURNS [DeviceHandle] = {    RETURN[IF device = nullDeviceHandle THEN 0      ELSE IF device + 1 < fcb.numberOfDCBs THEN device + 1        ELSE nullDeviceHandle]};  InitializeCleanup: PUBLIC PROC [c: ControllerHandle] =    BEGIN    item: DeviceCleanup.Item;    savedInterruptSelector: GuamInputOutput.InterruptSelectorType ¬ fcb.interruptSelector;    IF cleanupInitialized OR c # 0 THEN RETURN;    cleanupInitialized ¬ TRUE;    DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM	turnOff, kill =>	  BEGIN	  fcb.nextIOCB ¬ NIL;	  fcb.stopAgent ¬ TRUE;	  GuamInputOutput.CallAgent[disk];	  THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;	  savedInterruptSelector ¬ fcb.interruptSelector	  END;	turnOn =>	  BEGIN	  iocb: DiskIOFaceGuam.DiskIOCBPtr;	  FOR iocb ¬ iocbHead, iocb.nextIOCB UNTIL iocb = NIL DO	    IF iocb.status = inProgress THEN EXIT;	  ENDLOOP;	  fcb.nextIOCB ¬ iocb;	  fcb.interruptSelector ¬ savedInterruptSelector;	  fcb.stopAgent ¬ FALSE;	  GuamInputOutput.CallAgent[disk]	  END;	ENDCASE    ENDLOOP    END;  InitializeController: PUBLIC PROC [    controller: ControllerHandle, globalState: PilotDiskFace.GlobalStatePtr, mask: WORD,    nakedCondition: LONG POINTER TO CONDITION] =    BEGIN    IF NOT fcb.stopAgent THEN      BEGIN      fcb.stopAgent ¬ TRUE;      GuamInputOutput.CallAgent[disk];      THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP      END;    iocbHead ¬ NIL;    iocbTail ¬ @iocbHead;    rejectedIOCB ¬ NIL;    fcb.interruptSelector ¬ mask;    fcb.stopAgent ¬ FALSE    END;  InitializeTrackBuffer: PUBLIC PROC [    device: DeviceHandle, buffer: LONG POINTER, numberOfBuffers: CARDINAL] = {};  Initiate: PUBLIC PROC [op: PilotDiskFace.OperationPtr] =    BEGIN    iocb: DiskIOFaceGuam.DiskIOCBPtr = LOOPHOLE[op];    iocb.deviceIndex ¬ op.device;    iocb.diskAddress ¬ op.clientHeader;    iocb.dataPtr ¬ op.dataPtr;    iocb.incrementDataPtr ¬ op.incrementDataPtr;    iocb.command ¬ op.command;    iocb.pageCount ¬ op.pageCount;    iocb.agentOperationData ¬ ALL[0];    IF iocb.deviceIndex >= fcb.numberOfDCBs THEN iocb.status ¬ clientError      ELSE SELECT iocb.command FROM        noOp, format => iocb.status ¬ goodCompletion;        read, write, verify => iocb.status ¬ inProgress;        readHeader =>          BEGIN	  op.diskHeader ¬ op.clientHeader;	  iocb.status ¬ goodCompletion	  END;        readHeaderAndData =>          BEGIN	  op.diskHeader ¬ op.clientHeader;	  iocb.command ¬ read;	  iocb.status ¬ inProgress	  END;        makeBootable =>          BEGIN          op.diskHeader ¬ op.clientHeader;          iocb.dataPtr ¬ op.dataPtr + Environment.wordsPerPage;          iocb.incrementDataPtr ¬ FALSE;          iocb.command ¬ write;          iocb.pageCount ¬ 1;	  iocb.status ¬ inProgress          END;        makeUnbootable =>          BEGIN          op.diskHeader ¬ op.clientHeader;          iocb.dataPtr ¬ op.dataPtr + Environment.wordsPerPage;          iocb.incrementDataPtr ¬ FALSE;          iocb.command ¬ read;          iocb.pageCount ¬ 1;	  iocb.status ¬ inProgress          END;        getBootLocation =>          BEGIN          op.diskHeader ¬ op.clientHeader;          iocb.incrementDataPtr ¬ FALSE;          iocb.command ¬ read;          iocb.pageCount ¬ 1;	  iocb.status ¬ inProgress          END;        ENDCASE => iocb.status ¬ clientError;    IF iocb.status = inProgress THEN      BEGIN      iocb.nextIOCB ¬ NIL;      iocbTail­ ¬ iocb;      iocbTail ¬ @iocb.nextIOCB;      fcb.nextIOCB ¬ iocb;      GuamInputOutput.CallAgent[disk]      END ELSE      BEGIN      iocb.nextIOCB ¬ rejectedIOCB;      rejectedIOCB ¬ iocb      END;    END;  PagesForTrackBuffering: PUBLIC PROC [device: DeviceHandle]    RETURNS [pagesPerBuffer: CARDINAL, maxNumberOfBuffers: CARDINAL] = {    RETURN [0, 0]}; -- track buffering is not implemented for now  Poll: PUBLIC PROC [c: ControllerHandle] RETURNS [    status: PilotDiskFace.Status, op: PilotDiskFace.OperationPtr, retriedCount: CARDINAL] =    BEGIN    iocb: DiskIOFaceGuam.DiskIOCBPtr;    IF rejectedIOCB # NIL THEN      BEGIN      iocb ¬ rejectedIOCB;      rejectedIOCB ¬ iocb.nextIOCB      END ELSE      BEGIN      iocb ¬ iocbHead;      IF iocb = NIL OR iocb.status = inProgress        THEN RETURN[inProgress, @iocb.operation, 0];      iocbHead ¬ iocb.nextIOCB;      iocbTail ¬ IF iocbHead = NIL THEN @iocbHead ELSE @iocbHead.nextIOCB      END;    op ¬ @iocb.operation;    op.clientHeader ¬ iocb.diskAddress;    op.dataPtr ¬ iocb.dataPtr;    op.pageCount ¬ iocb.pageCount;    IF iocb.status = goodCompletion AND op.command = makeBootable THEN      BEGIN      bootDescr: Boot.BootFileDescriptorPageHandle ¬ LOOPHOLE[op.dataPtr];      IF bootDescr.header.seal # Boot.BootFileDescriptorPageSeal OR        bootDescr.header.version # Boot.BootFileDescriptorPageVersion        THEN RETURN[clientError, op, 0];      IF bootDescr.header.nextPage # Boot.eofDescriptorLink THEN        BEGIN	op.pageCount ¬ 1;      <<op.clientHeader ¬ bootDescr.header.nextPage; -- get around defs mismatch>>	op.clientHeader ¬ LOOPHOLE[bootDescr.header.nextPage];	Initiate[op];	RETURN[inProgress, NIL, 0]	END;      END;    RETURN[iocb.status, op, 0]    END;  Recalibrate: PUBLIC PROC [DeviceHandle] = {};  Reset: PUBLIC PROC [c: ControllerHandle] =    BEGIN    fcb.nextIOCB ¬ NIL;    fcb.stopAgent ¬ TRUE;    GuamInputOutput.CallAgent[disk];    THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;    FOR iocb: DiskIOFaceGuam.DiskIOCBPtr ¬ iocbHead, iocb.nextIOCB      UNTIL iocb = NIL DO      IF iocb.status = inProgress THEN iocb.status ¬ operationReset;    ENDLOOP;    fcb.stopAgent ¬ FALSE    END;  Start: PUBLIC --HeadStartChain.-- PROC =    {RemainingHeads.Start[]};  SuggestedTries: PUBLIC PROC [device: DeviceHandle]    RETURNS [tries: PilotDiskFace.Tries] = {    RETURN[1]};  END.LOG 8-Mar-93 - JPM - Created.
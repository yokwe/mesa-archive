-- FloppyHeadGuam.mesa - last edit:--  JPM		20-May-93  8:33:34-- Copyright (C) 1993 by Xerox Corporation.  All rights reserved.<< The following program was created in 1993 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  Device USING [nullType, Type],  DeviceCleanup USING [Await, Item, Reason],  DeviceTypesExtras USING [sa455],--DeviceTypesExtras6 USING [microFloppy, microFloppyQuad],  FloppyDiskFace USING [Attributes, Context, DiskAddress, LogStatus, OperationPtr, Status, Tries],  FloppyIOFaceGuam USING [FloppyFCBType, FloppyIOCBPtr, FloppyIOCBType],  GuamInputOutput USING [CallAgent, GetFCBPtr, InterruptSelectorType],  HeadStartChain USING [Start],  SpecialFloppyTapeFace USING [Parameters, PhysicalAddress, Statistics],  Zone USING [Alignment];  FloppyHeadGuam: PROGRAM   IMPORTS DeviceCleanup, GuamInputOutput, RemainingHeads: HeadStartChain   EXPORTS FloppyDiskFace, HeadStartChain, SpecialFloppyTapeFace  SHARES Device =   BEGIN  -- PUBLIC TYPE  DeviceHandle: PUBLIC TYPE = CARDINAL;  -- constant (should be in DeviceTypesExtras6)  microFloppy: Device.Type = [23]; -- 1.44MB, 3 1/2" disks  microFloppyQuad: Device.Type = [22]; -- 2.88MB, 3 1/2" disks  -- PUBLIC variables  nullDeviceHandle: PUBLIC DeviceHandle ¬ LAST[CARDINAL];  operationBlockLength: PUBLIC CARDINAL ¬ SIZE[FloppyIOFaceGuam.FloppyIOCBType];  operationAlignment: PUBLIC Zone.Alignment ¬ a2; -- doubleword boundary  initialAllocationLength: PUBLIC CARDINAL ¬ 0;  -- PRIVATE variables  fcb: LONG POINTER TO FloppyIOFaceGuam.FloppyFCBType =    GuamInputOutput.GetFCBPtr[floppy];  deviceContext: ARRAY [0..4) OF FloppyDiskFace.Context ¬    ALL[[FALSE, IBM, double, 256]];  cleanupInitialized: BOOLEAN ¬ FALSE;  iocbHead: FloppyIOFaceGuam.FloppyIOCBPtr ¬ NIL;  iocbTail: LONG POINTER TO FloppyIOFaceGuam.FloppyIOCBPtr ¬ @iocbHead;  -- PUBLIC PROCs  DiskChangeClear: PUBLIC PROC [device: DeviceHandle] = {    IF fcb # NIL AND device < fcb.numberOfDCBs      THEN fcb.dcbs[device].diskChanged ¬ FALSE};  GetContext: PUBLIC PROC [device: DeviceHandle]    RETURNS [context: FloppyDiskFace.Context] = {    RETURN[IF fcb # NIL AND device < fcb.numberOfDCBs      THEN deviceContext[device]      ELSE [FALSE, IBM, double, 256]]};  GetDeviceAttributes: PUBLIC PROC [device: DeviceHandle]    RETURNS [attributes: FloppyDiskFace.Attributes] = {    RETURN[IF fcb # NIL AND device < fcb.numberOfDCBs      THEN [        fcb.dcbs[device].deviceType,        fcb.dcbs[device].numberOfCylinders,        fcb.dcbs[device].numberOfHeads,        fcb.dcbs[device].sectorsPerTrack,        0, -- formatLength        fcb.dcbs[device].ready,        fcb.dcbs[device].diskChanged,        fcb.dcbs[device].twoSided,        FALSE -- same for all devices        ]      ELSE [Device.nullType, 0, 0, 15, 0, FALSE, FALSE, FALSE, FALSE]]};  GetLogStatus: PUBLIC PROC [operationPtr: FloppyDiskFace.OperationPtr]    RETURNS [logStatus: FloppyDiskFace.LogStatus] = {    iocb: FloppyIOFaceGuam.FloppyIOCBPtr = LOOPHOLE[operationPtr];    RETURN[DESCRIPTOR[@iocb.logStatus, 1]]};  GetNextDevice: PUBLIC PROC [previous: DeviceHandle]    RETURNS [next: DeviceHandle] = {    RETURN[IF fcb = NIL THEN nullDeviceHandle      ELSE IF previous = nullDeviceHandle THEN 0        ELSE IF (previous + 1) < fcb.numberOfDCBs THEN (previous + 1)          ELSE nullDeviceHandle]};  GetStatistics: PUBLIC PROC RETURNS [stats: SpecialFloppyTapeFace.Statistics] = {    RETURN[[0, 0, 0, FALSE, , 0]]};  GetTapeParameters: PUBLIC PROC [device: DeviceHandle]    RETURNS [parameters: SpecialFloppyTapeFace.Parameters] = {    RETURN[[0, 0]]};  InitializeCleanup: PUBLIC PROC = {IF fcb # NIL THEN    BEGIN    item: DeviceCleanup.Item;    savedInterruptSelector: GuamInputOutput.InterruptSelectorType ¬ fcb.interruptSelector;    IF cleanupInitialized THEN RETURN;    cleanupInitialized ¬ TRUE;    DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM	turnOff, kill =>	  BEGIN	  fcb.stopAgent ¬ TRUE;	  GuamInputOutput.CallAgent[floppy];	  THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;	  savedInterruptSelector ¬ fcb.interruptSelector	  END;	turnOn =>	  BEGIN	  iocb: FloppyIOFaceGuam.FloppyIOCBPtr;	  FOR iocb ¬ iocbHead, iocb.nextIOCB UNTIL iocb = NIL DO	    IF iocb.status = inProgress THEN EXIT;	  ENDLOOP;	  fcb.nextIOCB ¬ iocb;	  fcb.interruptSelector ¬ savedInterruptSelector;	  fcb.stopAgent ¬ FALSE;	  GuamInputOutput.CallAgent[floppy]	  END;	ENDCASE    ENDLOOP    END};  Initialize: PUBLIC PROC [notify: WORD, initialAllocation: LONG POINTER] =    BEGIN    IF fcb = NIL THEN RETURN;    IF NOT fcb.stopAgent THEN      BEGIN      fcb.stopAgent ¬ TRUE;      GuamInputOutput.CallAgent[floppy];      THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP      END;    iocbHead ¬ NIL;    iocbTail ¬ @iocbHead;    fcb.nextIOCB ¬ NIL;    fcb.interruptSelector ¬ notify;    fcb.stopAgent ¬ FALSE    END;  Initiate: PUBLIC PROC [operationPtr: FloppyDiskFace.OperationPtr]    RETURNS [status: FloppyDiskFace.Status] =    BEGIN    iocb: FloppyIOFaceGuam.FloppyIOCBPtr = LOOPHOLE[operationPtr];    device: DeviceHandle = operationPtr.device;    iocb.retries ¬ 0;    iocb.nextIOCB ¬ NIL;    iocb.logStatus ¬ 0;    IF fcb = NIL OR device >= fcb.numberOfDCBs THEN      BEGIN      iocb.status ¬ status ¬ invalidOperation;      RETURN      END;    IF fcb.dcbs[device].diskChanged THEN      BEGIN      iocb.status ¬ status ¬ diskChange;      RETURN      END;    IF (operationPtr.function = writeSector OR operationPtr.function = formatTrack) AND      deviceContext[device].protect THEN      BEGIN      iocb.status ¬ status ¬ writeFault;      RETURN      END;    iocb.density ¬ deviceContext[device].density;    iocb.sectorLength ¬ deviceContext[device].sectorLength;    iocb.sectorsPerTrack ¬ fcb.dcbs[device].sectorsPerTrack;    iocb.status ¬ status ¬ inProgress;    iocbTail­ ¬ iocb;    iocbTail ¬ @iocb.nextIOCB;    fcb.nextIOCB ¬ iocb;    GuamInputOutput.CallAgent[floppy];    END;  LogicalAddressToPhysicalAddress: PUBLIC PROC [logical: FloppyDiskFace.DiskAddress]    RETURNS [physicalAddress: SpecialFloppyTapeFace.PhysicalAddress] = {    RETURN[LOOPHOLE[logical]]};  MaxTracksPerFormatOperation: PUBLIC PROC [device: DeviceHandle]    RETURNS [maxTracks: CARDINAL] = {    RETURN[1]};  Poll: PUBLIC PROC [operation: FloppyDiskFace.OperationPtr] RETURNS [    status: FloppyDiskFace.Status, retriedCount: CARDINAL] =    BEGIN    iocb: FloppyIOFaceGuam.FloppyIOCBPtr = LOOPHOLE[operation];    IF iocb = NIL OR iocb.status = inProgress      THEN RETURN[inProgress, 0];    FOR prev: LONG POINTER TO FloppyIOFaceGuam.FloppyIOCBPtr ¬ @iocbHead, @prev­.nextIOCB      UNTIL prev­ = NIL DO      IF prev­ = iocb THEN        BEGIN	IF (prev­ ¬ iocb.nextIOCB) = NIL THEN iocbTail ¬ prev;	EXIT	END;    ENDLOOP;    RETURN[iocb.status, iocb.retries]    END;  Reset: PUBLIC PROC [device: DeviceHandle] =    BEGIN    chase: LONG POINTER TO FloppyIOFaceGuam.FloppyIOCBPtr ¬ @iocbHead;    IF fcb = NIL THEN RETURN;    fcb.stopAgent ¬ TRUE;    GuamInputOutput.CallAgent[floppy];    THROUGH [0..LAST[CARDINAL]) UNTIL fcb.agentStopped DO ENDLOOP;    fcb.nextIOCB ¬ NIL;    UNTIL chase­ = NIL DO      iocb: FloppyIOFaceGuam.FloppyIOCBPtr ¬ chase­;      IF iocb.status = inProgress THEN        BEGIN	iocbDevice: DeviceHandle = iocb.operation.device;        IF iocbDevice = device THEN	  BEGIN	  iocb.status ¬ aborted;	  IF (chase­ ¬ iocb.nextIOCB) = NIL THEN iocbTail ¬ chase;	  LOOP	  END	  ELSE IF fcb.nextIOCB = NIL THEN fcb.nextIOCB ¬ iocb;	END;      chase ¬ @iocb.nextIOCB    ENDLOOP;    fcb.stopAgent ¬ FALSE;    GuamInputOutput.CallAgent[floppy]    END;  Retention: PUBLIC PROC [o: FloppyDiskFace.OperationPtr]    RETURNS [status: FloppyDiskFace.Status] =    BEGIN    iocb: FloppyIOFaceGuam.FloppyIOCBPtr = LOOPHOLE[o];    iocb.retries ¬ 0;    iocb.nextIOCB ¬ NIL;    iocb.logStatus ¬ 0;    iocb.status ¬ status ¬ invalidOperation    END;  SetContext: PUBLIC PROC [device: DeviceHandle, context: FloppyDiskFace.Context]    RETURNS [ok: BOOLEAN] =    BEGIN    ok ¬ (fcb # NIL AND      device < fcb.numberOfDCBs AND      context.format = IBM AND      (SELECT context.sectorLength FROM        64, 128, 256 => TRUE,        ENDCASE => FALSE));    IF NOT ok THEN RETURN;    deviceContext[device] ¬ context;    fcb.dcbs[device].sectorsPerTrack ¬ SELECT fcb.dcbs[device].deviceType FROM      DeviceTypesExtras.sa455 => 9, -- 360KB, 5 1/4" disks      --DeviceTypesExtras6.--microFloppy => 18, -- 1.44MB, 3 1/2" disks      --DeviceTypesExtras6.--microFloppyQuad => 36, -- 2.88MB, 3 1/2" disks      ENDCASE => 15 -- 1.2MB, 5 1/4" disks    END;  Start: PUBLIC --HeadStartChain.-- PROC =    {RemainingHeads.Start[]};  SuggestedTries: PUBLIC PROC [device: DeviceHandle]    RETURNS [tries: FloppyDiskFace.Tries] = {    RETURN[IF fcb # NIL AND device < fcb.numberOfDCBs      THEN fcb.dcbs[device].suggestedTries      ELSE 1]};  END.LOG 8-Mar-93 - JPM - Created.18-Mar-93 - JPM - Check for fcb = NIL.20-May-93 - JPM - Changed SetContext to use correct value for 2.88 MB floppy sectors/track.
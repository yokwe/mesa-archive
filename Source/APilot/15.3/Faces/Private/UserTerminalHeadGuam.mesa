-- UserTerminalHeadGuam.mesa - Last Edit:--  JPM		14-Sep-93 10:42:49-- Copyright (C) 1993 by Xerox Corporation.  All rights reserved.<< The following program was created in 1993 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  BeepFace USING [],  BeepIOFaceGuam USING [BeepFCBType],  BitBlt USING [BBTable],  BitBltX USING [BitBltX],  ColorBlt USING [aCOLORBLT, Address, AlignedCBTable, aWRITEPIXEL, CBptr, CBTableSpace, Color, ColorBlt, ColorBltFlags, DstFunc, PixelType, SrcDesc, SrcFunc],  ColorDisplayFace USING [black, Color, ColorValue, MapPriority, white],  ColorDisplayFaceExtra USING [],  DeviceCleanup USING [Await, Item, Reason],  DisplayFace USING [Background, Cursor, CursorPtr, GlobalStatePtr, Point],  DisplayFaceExtras USING [],  DisplayIOFaceGuam USING [DisplayFCBType, LookupTableEntry],  Environment USING [BitAddress, bitsPerWord, Byte, bytesPerPage, bytesPerWord, LongPointerFromPage, PageCount, PageFromLongPointer, PageNumber, wordsPerPage],  Frame USING [GetReturnFrame, ReadPC, WritePC],  GuamInputOutput USING [CallAgent, GetFCBPtr, MapDisplay],  HeadStartChain,  Inline USING [BITAND, BITSHIFT, BITXOR, DBITAND, LongDivMod, LongMult, LowHalf],  KeyboardFace USING [DownUp, KeyboardType],  KeyboardIOFaceGuam USING [KeyboardFCBType],  MouseFace USING [Buttons, Point],  MouseIOFaceGuam USING [MouseFCBType, MousePositionType],  PageMap USING [flagsVacant, RealPageNumber, SetMapFlags],  PrincOps USING [ESCTrapTable],  PSB USING [ConditionVariable, InterruptLevel, PDA, PDABase];UserTerminalHeadGuam: PROGRAM  IMPORTS BitBltX, ColorBlt, DeviceCleanup, Environment, Frame, GuamInputOutput, Inline,    RemainingHeads: HeadStartChain, PageMap  EXPORTS BeepFace, ColorBlt, ColorDisplayFace, ColorDisplayFaceExtra, DisplayFace,    DisplayFaceExtras, HeadStartChain, KeyboardFace, MouseFace  SHARES PageMap =  BEGIN  -- constant  lteBlack: DisplayIOFaceGuam.LookupTableEntry = [0, 0, 0, 0];  -- FCB pointers  beepFCB: LONG POINTER TO BeepIOFaceGuam.BeepFCBType =    GuamInputOutput.GetFCBPtr[beep];  displayFCB: LONG POINTER TO DisplayIOFaceGuam.DisplayFCBType =      GuamInputOutput.GetFCBPtr[display];  keyboardFCB: LONG POINTER TO KeyboardIOFaceGuam.KeyboardFCBType =    GuamInputOutput.GetFCBPtr[keyboard];  mouseFCB: LONG POINTER TO MouseIOFaceGuam.MouseFCBType =    GuamInputOutput.GetFCBPtr[mouse];  -- PUBLIC variables  -- ColorDisplayFace  numberOfColors: PUBLIC CARDINAL ¬ SELECT displayFCB.displayType FROM    monochrome => 2,    fourBitPlaneColor => 256,    byteColor => 256,    ENDCASE => 0;  bitsPerDisplayPixel: PUBLIC NATURAL ¬ IF displayFCB.displayType # byteColor THEN 1 ELSE 8;  maxIntensity: PUBLIC CARDINAL ¬ 255;  numberOfMaps: PUBLIC CARDINAL ¬ IF displayFCB.displayType # byteColor THEN 0 ELSE 1;  mapGranularityX: PUBLIC NATURAL ¬ 1;  mapGranularityY: PUBLIC NATURAL ¬ 1;  -- DisplayFace  hasBuffer: PUBLIC BOOLEAN ¬ TRUE;  width: PUBLIC CARDINAL[0..32767] ¬ displayFCB.displayWidth;  height: PUBLIC CARDINAL[0..32767] ¬ displayFCB.displayHeight;  pixelsPerInch: PUBLIC CARDINAL ¬ 80; -- may not be right, but who cares  refreshRate: PUBLIC CARDINAL ¬ 38; -- may not be right, but who cares  interlaced: PUBLIC BOOLEAN ¬ FALSE;  hasBorder: PUBLIC BOOLEAN ¬ FALSE;  cursorPosition: PUBLIC LONG POINTER TO READONLY DisplayFace.Point ¬ @cursorPos;  globalStateSize: PUBLIC CARDINAL ¬ 0;  scrollXQuantum, scrollYQuantum: PUBLIC CARDINAL ¬ 1;  scrollingInhibitsCursor: PUBLIC BOOLEAN ¬ FALSE;  pagesForBitmap: PUBLIC Environment.PageCount ¬ CalculateDisplayPages[];   -- KeyboardFace  keyboard: PUBLIC LONG POINTER TO READONLY PACKED ARRAY OF KeyboardFace.DownUp ¬    LOOPHOLE[@keyboardFCB.keyStates];  keyboardType: PUBLIC KeyboardFace.KeyboardType ¬ level5; -- should have something in FCB  -- MouseFace  position: PUBLIC LONG POINTER TO READONLY MouseFace.Point ¬    LOOPHOLE[@mouseFCB.currentMousePosition];  buttons: PUBLIC LONG POINTER TO READONLY MouseFace.Buttons ¬    LOOPHOLE[@keyboardFCB.keyStates];  -- PRIVATE variables  bitmapAddress: LONG POINTER ¬ NIL;  bitmapMapped: BOOLEAN ¬ FALSE;  colorPalette: ARRAY [2..255] OF DisplayIOFaceGuam.LookupTableEntry ¬ ALL[lteBlack];  cursorPattern: DisplayFace.Cursor ¬ ALL[0];  cursorPos: DisplayFace.Point ¬ [0, 0];  cursorXOffset: INTEGER ¬ 0;  cursorYOffset: INTEGER ¬ 0;  displayBackground: DisplayFace.Background ¬ white;  displayWordsPerLine: CARDINAL; -- set as a side-effect of CalculateDisplayPages  displayWords: LONG CARDINAL; -- set as a side-effect of CalculateDisplayPages  pixelsPerWord: CARDINAL ¬ IF displayFCB.displayType # byteColor    THEN Environment.bitsPerWord ELSE Environment.bytesPerWord;  -- INLINE PROCs  CalculateDisplayPages: PROC RETURNS [Environment.PageCount] = INLINE    BEGIN    wordsPerDWord: CARDINAL = 2;    bitsPerDWord: CARDINAL = Environment.bitsPerWord * wordsPerDWord;    SELECT displayFCB.displayType FROM      monochrome =>        BEGIN        displayWordsPerLine ¬ ((width + bitsPerDWord - 1) / bitsPerDWord) * wordsPerDWord;        displayWords ¬ Inline.LongMult[displayWordsPerLine, height]        END;      fourBitPlaneColor =>        BEGIN        displayWordsPerLine ¬ ((width + bitsPerDWord - 1) / bitsPerDWord) * wordsPerDWord;        displayWords ¬ Inline.LongMult[displayWordsPerLine, 4 * height]        END;      byteColor =>        BEGIN        displayWordsPerLine ¬ ((width + Environment.bytesPerPage - 1) / Environment.bytesPerPage) * Environment.wordsPerPage;        displayWords ¬ Inline.LongMult[displayWordsPerLine, height]        END;      ENDCASE =>        BEGIN	displayWordsPerLine ¬ 0;	displayWords ¬ 0	END;    RETURN[(displayWords + Environment.wordsPerPage - 1) / Environment.wordsPerPage]    END;  ConnectInline: PROC [bitMap: Environment.PageNumber] = INLINE    BEGIN    displayPages: CARDINAL = Inline.LowHalf[pagesForBitmap];    blockPages: CARDINAL = IF displayFCB.displayType # byteColor THEN displayPages      ELSE (displayWordsPerLine / Environment.wordsPerPage);    GuamInputOutput.MapDisplay[bitMap + (displayPages - blockPages),			       displayFCB.displayMemoryAddress, displayPages, blockPages];    bitmapMapped ¬ TRUE    END;  DisconnectInline: PROC = INLINE    BEGIN    bitMap: Environment.PageNumber = Environment.PageFromLongPointer[bitmapAddress];    FOR virtual: Environment.PageNumber IN [bitMap..bitMap + pagesForBitmap) DO      PageMap.SetMapFlags[virtual: virtual, real: NULL, flags: PageMap.flagsVacant]    ENDLOOP;    bitmapMapped ¬ FALSE    END;  InDisplayBuffer: PROC [ptr: LONG UNSPECIFIED] RETURNS [BOOLEAN] = INLINE {    RETURN[((ptr - LOOPHOLE[bitmapAddress, LONG CARDINAL]) < displayWords)]};  InvertSrcFunc: PROC [srcFunc: ColorBlt.SrcFunc] RETURNS [ColorBlt.SrcFunc] = INLINE {    RETURN[IF srcFunc = null THEN complement ELSE null]};  NormalizeAddr: PROC [addr: ColorBlt.Address] RETURNS [ColorBlt.Address] = INLINE    BEGIN    addr.word ¬ addr.word + Inline.BITSHIFT[addr.pixel, -4];    addr.pixel ¬ Inline.BITAND[addr.pixel, 0FH];    IF Inline.DBITAND[addr.word, 1] # 0 THEN      BEGIN      addr.word ¬ addr.word - 1;      addr.pixel ¬ addr.pixel + 16      END;    RETURN[addr]    END;  -- PUBLIC PROCs  -- EXPORTed to ColorDisplayFace or ColorDisplayFaceExtra  BitPlanes: PUBLIC PROC RETURNS [NATURAL] =    {RETURN[IF displayFCB.displayType = fourBitPlaneColor THEN 4 ELSE 1]};  GetColorValue: PUBLIC PROC [color: ColorDisplayFace.Color]    RETURNS [value: ColorDisplayFace.ColorValue] = {    IF displayFCB.displayType # fourBitPlaneColor THEN      BEGIN      displayFCB.colorIndex ¬ color;      displayFCB.command ¬ getCLTEntry;      GuamInputOutput.CallAgent[display];      IF displayFCB.status # success THEN RETURN[[0, 0, 0]];      RETURN[[displayFCB.color.red, displayFCB.color.green, displayFCB.color.blue]]      END ELSE      BEGIN -- adjust for fixed-value palette      baseColor: CARDINAL = Inline.BITAND[(color - 1), 0FH]; -- black => 0, white => 15      mixColor: CARDINAL = Inline.BITXOR[(color / 16), baseColor];      displayFCB.colorIndex ¬ baseColor;      displayFCB.command ¬ getCLTEntry;      GuamInputOutput.CallAgent[display];      IF displayFCB.status # success THEN RETURN[[0, 0, 0]];      value ¬ [displayFCB.color.red, displayFCB.color.green, displayFCB.color.blue];      displayFCB.colorIndex ¬ mixColor;      displayFCB.command ¬ getCLTEntry;      GuamInputOutput.CallAgent[display];      IF displayFCB.status # success THEN RETURN[[0, 0, 0]];      value.red ¬ (value.red + displayFCB.color.red + 1) / 2;      value.green ¬ (value.green + displayFCB.color.green + 1) / 2;      value.blue ¬ (value.blue + displayFCB.color.blue + 1) / 2;      END};  GetBorderColorValue: PUBLIC PROC RETURNS [value: ColorDisplayFace.ColorValue] =    {RETURN[[0, 0, 0]]};  GetCursorColorValue: PUBLIC PROC RETURNS [value: ColorDisplayFace.ColorValue] =    {RETURN[[0, 0, 0]]};  GetMapExtent: PUBLIC PROC [mapNumber: NATURAL]    RETURNS [leftX, topY, width, height: NATURAL] = {RETURN[0, 0, 0, 0]};  SetColorValue: PUBLIC PROC [color: ColorDisplayFace.Color, value: ColorDisplayFace.ColorValue]    RETURNS [ok: BOOLEAN] =    BEGIN    IF displayFCB.displayType # byteColor OR color NOT IN [2..255] THEN RETURN[FALSE];    displayFCB.colorIndex ¬ color;    displayFCB.color ¬ [reserved: 0, red: value.red, green: value.green, blue: value.blue];    displayFCB.command ¬ setCLTEntry;    GuamInputOutput.CallAgent[display];    IF (ok ¬ (displayFCB.status = success))      THEN colorPalette[color] ¬ displayFCB.color;    IF color >= 250 THEN -- a special reserved color, so must redisplay the screen      BEGIN      displayFCB.destRectangle ¬ [[0, 0], width, height];      displayFCB.command ¬ updateRectangle;      GuamInputOutput.CallAgent[display]      END;    RETURN    END;  SetBorderColorValue: PUBLIC PROC [value: ColorDisplayFace.ColorValue]    RETURNS [ok: BOOLEAN] = {RETURN[FALSE]};  SetCursorColorValue: PUBLIC PROC [value: ColorDisplayFace.ColorValue]    RETURNS [ok: BOOLEAN] = {RETURN[FALSE]};  SetMapExtent: PUBLIC PROC [mapNumber: NATURAL, leftX, topY, width, height: NATURAL]    RETURNS [ok: BOOLEAN] = {RETURN[FALSE]};  SetMapPriority: PUBLIC PROC [mapNumber: NATURAL, priority: ColorDisplayFace.MapPriority]    RETURNS [ok: BOOLEAN] = {RETURN[FALSE]};  -- EXPORTed to DisplayFace or DisplayFaceExtras  Connect: PUBLIC PROC [bitMap: Environment.PageNumber] =    BEGIN    ConnectInline[bitMap];    bitmapAddress ¬ Environment.LongPointerFromPage[bitMap]    END;  CreateScrollWindow: PUBLIC PROC [locn: DisplayFace.Point, w: CARDINAL, h: CARDINAL] = {};  DeleteScrollWindow: PUBLIC PROC = {};  Disconnect: PUBLIC PROC = {    IF bitmapMapped THEN      BEGIN      DisconnectInline[];      bitmapAddress ¬ NIL      END};  GetBitBltTable: PUBLIC PROC RETURNS [BitBlt.BBTable] =    BEGIN    bpl: CARDINAL = displayWordsPerLine * pixelsPerWord;    RETURN[      [        dst: [word: bitmapAddress, bit: 0], dstBpl: bpl,        src: [word: bitmapAddress, bit: 0], srcDesc: [srcBpl[bpl]],        width: width, height: height, flags: []]]    END;  GetBorderPattern: PUBLIC PROC RETURNS [oddPairs, evenPairs: [0..377B]] = {    RETURN[0, 0]};  GetCursorPattern: PUBLIC PROC RETURNS [cursorPtr: DisplayFace.CursorPtr] = {    RETURN[@cursorPattern]};  Initialize: PUBLIC PROC [    globalState: DisplayFace.GlobalStatePtr, wakeVF: WORD] =    BEGIN    pda: PSB.PDABase = PSB.PDA;    testBit: WORD ¬ 100000B;    cursorPos ¬ [0, 0];    cursorPattern ¬ ALL[0];    FOR i: PSB.InterruptLevel IN PSB.InterruptLevel DO      IF Inline.BITAND[wakeVF, testBit] # 0        THEN LOOPHOLE[pda.interrupt[i], PSB.ConditionVariable].timeout ¬ 1;      testBit ¬ testBit / 2    ENDLOOP;    IF displayFCB.displayType = byteColor THEN      BEGIN      displayFCB.colorIndex ¬ ColorDisplayFace.white;      displayFCB.color ¬ [reserved: 0, red: 255, green: 255, blue: 255];      displayFCB.command ¬ setCLTEntry;      GuamInputOutput.CallAgent[display];      displayFCB.colorIndex ¬ ColorDisplayFace.black;      displayFCB.color ¬ [reserved: 0, red: 0, green: 0, blue: 0];      displayFCB.command ¬ setCLTEntry;      GuamInputOutput.CallAgent[display]      END;    END;  InitializeCleanup: PUBLIC PROC =	-- Display/Tone Generator cleanup Proc --    BEGIN    item: DeviceCleanup.Item;    displayComplemented: BOOLEAN;    oldPosition: MouseIOFaceGuam.MousePositionType;    DO      reason: DeviceCleanup.Reason ¬ DeviceCleanup.Await[@item];      SELECT reason FROM        turnOff, kill =>	  BEGIN	  displayComplemented ¬ displayFCB.complemented;          oldPosition ¬ mouseFCB.currentMousePosition;	  IF beepFCB.frequency # 0 THEN	    BEGIN	    beepFCB.frequency ¬ 0;	    GuamInputOutput.CallAgent[beep]	    END;	  IF bitmapMapped THEN DisconnectInline[];	  END;        turnOn =>	  BEGIN	  IF bitmapAddress # NIL	    THEN ConnectInline[Environment.PageFromLongPointer[bitmapAddress]];	  displayFCB.complemented ¬ displayComplemented;	  displayFCB.command ¬ setBackground;	  GuamInputOutput.CallAgent[display];	  displayFCB.cursorPattern ¬ cursorPattern;	  displayFCB.command ¬ setCursorPattern;	  GuamInputOutput.CallAgent[display];	  IF displayFCB.displayType = byteColor THEN	    BEGIN	    displayFCB.command ¬ setCLTEntry;	    FOR c: CARDINAL IN [2..255] DO	      IF (displayFCB.color ¬ colorPalette[c]) # lteBlack THEN	        BEGIN		displayFCB.colorIndex ¬ c;		GuamInputOutput.CallAgent[display]		END;	    ENDLOOP	    END;	  mouseFCB.cursorOffset ¬ [cursorXOffset, cursorYOffset];	  mouseFCB.newValue ¬ oldPosition;          mouseFCB.command ¬ setPosition;	  GuamInputOutput.CallAgent[mouse];	  beepFCB.frequency ¬ 0	  END;        disconnect => IF bitmapMapped THEN DisconnectInline[];        ENDCASE    ENDLOOP    END;  Scroll: PUBLIC PROC [    line: Environment.BitAddress, lineCount: CARDINAL, increment: INTEGER] = {};  SetBackground: PUBLIC PROC [b: DisplayFace.Background] =    {IF b # displayBackground THEN      BEGIN      displayFCB.complemented ¬ NOT displayFCB.complemented;      displayFCB.command ¬ setBackground;      GuamInputOutput.CallAgent[display];      displayBackground ¬ b      END};  SetBorderPattern: PUBLIC PROC [oddPairs, evenPairs: [0..377B]] = {};  SetCursorPattern: PUBLIC PROC [p: DisplayFace.CursorPtr] =    BEGIN    displayFCB.cursorPattern ¬ cursorPattern ¬ p­;    displayFCB.command ¬ setCursorPattern;    GuamInputOutput.CallAgent[display]    END;  SetCursorPosition: PUBLIC PROC [cursor: DisplayFace.Point] =    BEGIN    cursorPos ¬ cursor;    IF (cursor.x - cursorXOffset) # position.x OR      (cursor.y - cursorYOffset) # position.y THEN      BEGIN      cursorXOffset ¬ cursor.x - position.x;      cursorYOffset ¬ cursor.y - position.y;      mouseFCB.newValue ¬ [cursorXOffset, cursorYOffset];      mouseFCB.command ¬ setCursorPosition;      GuamInputOutput.CallAgent[mouse]      END;    END;  TurnOn: PUBLIC PROC = {};  TurnOff: PUBLIC PROC = {};  -- EXPORTed to MouseFace  SetPosition: PUBLIC PROC [p: MouseFace.Point] =    BEGIN    mouseFCB.newValue ¬ [p.x, p.y];    mouseFCB.command ¬ setPosition;    GuamInputOutput.CallAgent[mouse]    END;  -- EXPORTed to BeepFace  BeepOn: PUBLIC PROC [frequency: CARDINAL] =    BEGIN    beepFCB.frequency ¬ MAX[37, MIN[frequency, 32767]];    GuamInputOutput.CallAgent[beep]    END;  BeepOff: PUBLIC PROC =    BEGIN    beepFCB.frequency ¬ 0;    GuamInputOutput.CallAgent[beep]    END;  -- EXPORTed to ColorBlt  SoftwareColorBlt: PUBLIC PROC [ptr: ColorBlt.CBptr] = {    ColorBlt.ColorBlt[ptr]};  SoftwareWritePixel: PUBLIC PROC [addr: ColorBlt.Address, color: ColorBlt.Color,    dstType: ColorBlt.PixelType, dstFunc: ColorBlt.DstFunc] =    BEGIN    cbt: ColorBlt.CBTableSpace;    cb: ColorBlt.CBptr ¬ ColorBlt.AlignedCBTable[@cbt];    cb­ ¬ [addr, 0, [@color, 0], [pattern[[unpacked: TRUE, yOffset: 0, widthMinusOne: 0, heightMinusOne: 0]]], 1, 1, [srcType: display, dstType: display, pattern: TRUE], [0, 0]];    ColorBlt.ColorBlt[cb]    END;  -- EXPORTed to HeadStartChain  Start: PUBLIC PROC = {    RemainingHeads.Start[]};  -- PRIVATE PROCs (for trap table)  --   since these are called as trap instruction, we gotta  --   bump the pc.  Note that it is minimal stack, which  --   means we don't have to bother dumping state.  COLORBLTMono: PROC [ptr: ColorBlt.CBptr] =    BEGIN    dstAddr, srcAddr: ColorBlt.Address;    dstPpl: INTEGER;    srcDesc: ColorBlt.SrcDesc;    Frame.WritePC[      pc: [(Frame.ReadPC[Frame.GetReturnFrame[]] + 2)],      lf: Frame.GetReturnFrame[]];    IF ptr.height = 0 OR ptr.width = 0 THEN RETURN;    dstAddr ¬ NormalizeAddr[ptr.dst];    srcAddr ¬ IF ptr.flags.pattern THEN ptr.src ELSE NormalizeAddr[ptr.src];    dstPpl ¬ IF ptr.flags.direction = forward THEN ptr.dstPpl ELSE -ptr.dstPpl;    srcDesc ¬ IF ptr.flags.pattern OR ptr.flags.direction = forward      THEN ptr.srcDesc ELSE [srcPpl[-ptr.srcDesc.srcPpl]];    BitBltX.BitBltX[dstAddr, dstPpl, srcAddr, srcDesc, ptr.width, ptr.height, ptr.flags];    IF InDisplayBuffer[dstAddr.word] THEN UpdateDisplay[ptr];    END;  COLORBLT16: PROC [ptr: ColorBlt.CBptr] =    BEGIN    dispIncr: LONG CARDINAL = displayWords / 4;    noColor: CARDINAL = 0FFFFH;    dstAddr, srcAddr: ColorBlt.Address;    dstPpl: INTEGER;    srcDesc: ColorBlt.SrcDesc;    flags: ColorBlt.ColorBltFlags;    color0, color1: CARDINAL;    work: WORD ¬ 0FFFFH;    Frame.WritePC[      pc: [(Frame.ReadPC[Frame.GetReturnFrame[]] + 2)],      lf: Frame.GetReturnFrame[]];    IF ptr.height = 0 OR ptr.width = 0 THEN RETURN;    dstAddr ¬ NormalizeAddr[ptr.dst];    srcAddr ¬ IF ptr.flags.pattern THEN ptr.src ELSE NormalizeAddr[ptr.src];    dstPpl ¬ IF ptr.flags.direction = forward THEN ptr.dstPpl ELSE -ptr.dstPpl;    srcDesc ¬ IF ptr.flags.pattern OR ptr.flags.direction = forward      THEN ptr.srcDesc ELSE [srcPpl[-ptr.srcDesc.srcPpl]];    flags ¬ ptr.flags;    color0 ¬ ptr.colorMapping[0] - 1; -- the "-1" changes 0 and 1 to 15 and 0, respectively    color1 ¬ ptr.colorMapping[1] - 1;    IF flags.pattern AND flags.srcType = display THEN      BEGIN -- assume pattern is single unpacked color      color1 ¬ srcAddr.word­ - 1;      color0 ¬ 0FH; -- white      flags.srcType ¬ bit;      srcAddr ¬ [word: @work, pixel: 0];      srcDesc ¬ [pattern[[yOffset: 0, widthMinusOne: 0, heightMinusOne: 0]]]      END;    IF flags.srcType = bit      THEN IF flags.dstType = bit THEN        BEGIN -- bit to bit: one BitBltX        BitBltX.BitBltX[dstAddr, dstPpl, srcAddr, srcDesc, ptr.width, ptr.height, flags]	END ELSE	BEGIN -- bit to display: a BitBltX for each plane with color decoding        dstInDisp: BOOLEAN = InDisplayBuffer[dstAddr.word];        mask: CARDINAL ¬ 1;	IF NOT dstInDisp THEN dstPpl ¬ 4 * dstPpl;	IF flags.dstFunc = srcXorDst THEN color1 ¬ Inline.BITXOR[color1, color0];	THROUGH [0..4) DO	  planeFlags: ColorBlt.ColorBltFlags ¬ flags;	  planeSrcAddr: ColorBlt.Address ¬ srcAddr;	  planeSrcDesc: ColorBlt.SrcDesc ¬ srcDesc;	  IF Inline.BITAND[color1, mask] # 0	    THEN SELECT flags.dstFunc FROM	      src => IF Inline.BITAND[color0, mask] # 0 THEN	        BEGIN	        planeFlags ¬ [dstType: display, pattern: TRUE];	        planeSrcAddr ¬ [word: @work, pixel: 0];	        planeSrcDesc ¬ [pattern[[yOffset: 0, widthMinusOne: 0, heightMinusOne: 0]]]	        END;	      srcIf0 => planeFlags ¬ [dstType: display, pattern: flags.pattern, srcFunc: InvertSrcFunc[flags.srcFunc], dstFunc: srcIfNot0];	      ENDCASE	    ELSE SELECT flags.dstFunc FROM	      src => IF Inline.BITAND[color0, mask] # 0	        THEN planeFlags.srcFunc ¬ InvertSrcFunc[flags.srcFunc] ELSE	        BEGIN	        planeFlags ¬ [dstType: display, pattern: TRUE, srcFunc: complement];	        planeSrcAddr ¬ [word: @work, pixel: 0];	        planeSrcDesc ¬ [pattern[[yOffset: 0, widthMinusOne: 0, heightMinusOne: 0]]]	        END;	      srcIf0 => planeFlags ¬ [dstType: display, pattern: flags.pattern, srcFunc: InvertSrcFunc[flags.srcFunc], dstFunc: srcIfNot0];	      srcIfNot0 => planeFlags ¬ [dstType: display, pattern: flags.pattern, srcFunc: InvertSrcFunc[flags.srcFunc], dstFunc: srcIf0];	      srcXorDst =>	        BEGIN	        planeFlags ¬ [dstType: display, pattern: TRUE, srcFunc: complement, dstFunc: srcXorDst];	        planeSrcAddr ¬ [word: @work, pixel: 0];	        planeSrcDesc ¬ [pattern[[yOffset: 0, widthMinusOne: 0, heightMinusOne: 0]]]		END;	      ENDCASE;	  BitBltX.BitBltX[dstAddr, dstPpl, planeSrcAddr, planeSrcDesc,	    ptr.width, ptr.height, planeFlags];	  IF dstInDisp THEN dstAddr.word ¬ dstAddr.word + dispIncr	    ELSE dstAddr ¬ NormalizeAddr[[dstAddr.word, dstAddr.pixel + ptr.dstPpl]];	  mask ¬ 2 * mask	ENDLOOP;	IF dstInDisp THEN UpdateDisplay[ptr];	END      ELSE IF flags.dstType = bit THEN        BEGIN -- display to bit: one BitBltX using src plane 0	IF NOT InDisplayBuffer[srcAddr.word] THEN srcDesc.srcPpl ¬ 4 * srcDesc.srcPpl;	BitBltX.BitBltX[dstAddr, dstPpl, srcAddr, srcDesc, ptr.width, ptr.height, flags]	END ELSE	BEGIN -- display to display: a BitBltX for each plane        dstInDisp: BOOLEAN = InDisplayBuffer[dstAddr.word];        srcInDisp: BOOLEAN = InDisplayBuffer[srcAddr.word];	IF NOT dstInDisp THEN dstPpl ¬ 4 * dstPpl;	IF NOT srcInDisp THEN srcDesc.srcPpl ¬ 4 * srcDesc.srcPpl;	THROUGH [0..4) DO	  BitBltX.BitBltX[dstAddr, dstPpl, srcAddr, srcDesc, ptr.width, ptr.height, flags];	  IF dstInDisp THEN dstAddr.word ¬ dstAddr.word + dispIncr	    ELSE dstAddr ¬ NormalizeAddr[[dstAddr.word, dstAddr.pixel + ptr.dstPpl]];	  IF srcInDisp THEN srcAddr.word ¬ srcAddr.word + dispIncr	    ELSE srcAddr ¬ NormalizeAddr[[srcAddr.word, srcAddr.pixel + ptr.srcDesc.srcPpl]];	ENDLOOP;	IF dstInDisp THEN UpdateDisplay[ptr];	END;    END;  COLORBLT256: PROC [ptr: ColorBlt.CBptr] =    BEGIN    work: CARDINAL ¬ 0FFFFH;    dstAddr, srcAddr: ColorBlt.Address;    dstPpl: INTEGER;    srcDesc: ColorBlt.SrcDesc;    flags: ColorBlt.ColorBltFlags;    color0, color1: CARDINAL;    Frame.WritePC[      pc: [(Frame.ReadPC[Frame.GetReturnFrame[]] + 2)],      lf: Frame.GetReturnFrame[]];    IF ptr.height = 0 OR ptr.width = 0 THEN RETURN;    dstAddr ¬ ptr.dst;    srcAddr ¬ ptr.src;    dstPpl ¬ IF ptr.flags.direction = forward THEN ptr.dstPpl ELSE -ptr.dstPpl;    srcDesc ¬ IF ptr.flags.pattern OR ptr.flags.direction = forward      THEN ptr.srcDesc ELSE [srcPpl[-ptr.srcDesc.srcPpl]];    flags ¬ ptr.flags;    color0 ¬ ptr.colorMapping[0];    color1 ¬ ptr.colorMapping[1];    IF flags.pattern AND flags.srcType = display THEN      BEGIN -- assume pattern is single unpacked color      color1 ¬ srcAddr.word­;      color0 ¬ 0; -- white      flags.srcType ¬ bit;      srcAddr ¬ [word: @work, pixel: 0];      srcDesc ¬ [pattern[[yOffset: 0, widthMinusOne: 0, heightMinusOne: 0]]]      END;    IF flags.srcType = bit      THEN IF flags.dstType = bit THEN        BEGIN -- bit to bit: one BitBltX        dstAddr ¬ NormalizeAddr[dstAddr];        IF NOT ptr.flags.pattern THEN srcAddr ¬ NormalizeAddr[srcAddr];        BitBltX.BitBltX[dstAddr, dstPpl, srcAddr, srcDesc, ptr.width, ptr.height, flags]	END ELSE	BEGIN -- bit to display: color encoding for each dst byte	srcFuncWord: CARDINAL = IF flags.srcFunc = null THEN 0 ELSE 0FFFFH;	srcPtr: LONG POINTER TO CARDINAL;	srcWord, srcMask: CARDINAL;	dstPtr: LONG POINTER TO PACKED ARRAY [0..1] OF Environment.Byte;	dstIndex: CARDINAL;	IF flags.dstFunc = srcXorDst THEN color1 ¬ Inline.BITXOR[color1, color0];	dstAddr ¬ [dstAddr.word + (dstAddr.pixel / 2), dstAddr.pixel MOD 2];	srcAddr ¬ [srcAddr.word + (srcAddr.pixel / 16), srcAddr.pixel MOD 16];	THROUGH [0..ptr.height) DO	  dstPtr ¬ dstAddr.word;	  dstIndex ¬ 1 - dstAddr.pixel; -- byte-swap	  srcPtr ¬ srcAddr.word;	  srcWord ¬ Inline.BITXOR[srcPtr­, srcFuncWord];	  srcMask ¬ Inline.BITSHIFT[8000H, -srcAddr.pixel];	  SELECT flags.dstFunc FROM	    src =>	      THROUGH [0..ptr.width) DO	        dstPtr[dstIndex] ¬		  IF Inline.BITAND[srcWord, srcMask] # 0 THEN color1 ELSE color0;		IF dstIndex # 0 THEN dstIndex ¬ 0 ELSE		  BEGIN		  dstIndex ¬ 1;		  dstPtr ¬ dstPtr + 1		  END;		IF (srcMask ¬ Inline.BITSHIFT[srcMask, -1]) = 0 THEN		  BEGIN		  srcMask ¬ 8000H;		  IF NOT flags.pattern		    THEN srcWord ¬ Inline.BITXOR[(srcPtr ¬ srcPtr + 1)­, srcFuncWord];		  END;	      ENDLOOP;	    srcIf0 =>	      THROUGH [0..ptr.width) DO	        IF Inline.BITAND[srcWord, srcMask] = 0 THEN dstPtr[dstIndex] ¬ color0;		IF dstIndex # 0 THEN dstIndex ¬ 0 ELSE		  BEGIN		  dstIndex ¬ 1;		  dstPtr ¬ dstPtr + 1		  END;		IF (srcMask ¬ Inline.BITSHIFT[srcMask, -1]) = 0 THEN		  BEGIN		  srcMask ¬ 8000H;		  IF NOT flags.pattern		    THEN srcWord ¬ Inline.BITXOR[(srcPtr ¬ srcPtr + 1)­, srcFuncWord];		  END;	      ENDLOOP;	    srcIfNot0 =>	      THROUGH [0..ptr.width) DO	        IF Inline.BITAND[srcWord, srcMask] # 0 THEN dstPtr[dstIndex] ¬ color1;		IF dstIndex # 0 THEN dstIndex ¬ 0 ELSE		  BEGIN		  dstIndex ¬ 1;		  dstPtr ¬ dstPtr + 1		  END;		IF (srcMask ¬ Inline.BITSHIFT[srcMask, -1]) = 0 THEN		  BEGIN		  srcMask ¬ 8000H;		  IF NOT flags.pattern		    THEN srcWord ¬ Inline.BITXOR[(srcPtr ¬ srcPtr + 1)­, srcFuncWord];		  END;	      ENDLOOP;	    srcXorDst =>	      THROUGH [0..ptr.width) DO	        IF Inline.BITAND[srcWord, srcMask] # 0		  THEN dstPtr[dstIndex] ¬ Inline.BITXOR[dstPtr[dstIndex], color1];		IF dstIndex # 0 THEN dstIndex ¬ 0 ELSE		  BEGIN		  dstIndex ¬ 1;		  dstPtr ¬ dstPtr + 1		  END;		IF (srcMask ¬ Inline.BITSHIFT[srcMask, -1]) = 0 THEN		  BEGIN		  srcMask ¬ 8000H;		  IF NOT flags.pattern		    THEN srcWord ¬ Inline.BITXOR[(srcPtr ¬ srcPtr + 1)­, srcFuncWord];		  END;	      ENDLOOP;	    ENDCASE;	  dstAddr ¬ [dstAddr.word + ((dstAddr.pixel + dstPpl) / 2),	    (dstAddr.pixel + dstPpl) MOD 2];	  IF flags.pattern	    THEN IF srcDesc.pattern.yOffset < srcDesc.pattern.heightMinusOne THEN	      BEGIN	      srcAddr.word ¬ srcAddr.word + 1;	      srcDesc.pattern.yOffset ¬ srcDesc.pattern.yOffset + 1	      END ELSE	      BEGIN	      srcDesc.pattern.yOffset ¬ 0;	      srcAddr.word ¬ srcAddr.word - srcDesc.pattern.heightMinusOne	      END	    ELSE srcAddr ¬ [srcAddr.word + ((srcAddr.pixel + srcDesc.srcPpl) / 16),	      (srcAddr.pixel + srcDesc.srcPpl) MOD 16];	ENDLOOP;	IF InDisplayBuffer[dstAddr.word] THEN UpdateDisplay[ptr];	END      ELSE IF flags.dstType = bit THEN        BEGIN -- display to bit: color decoding for each src byte	dstPtr: LONG POINTER TO PACKED ARRAY [0..16) OF [0..1];	srcPtr: LONG POINTER TO PACKED ARRAY [0..1] OF Environment.Byte;	dstIndex, srcIndex: CARDINAL;	dstAddr ¬ [dstAddr.word + (dstAddr.pixel / 16), dstAddr.pixel MOD 16];	srcAddr ¬ [srcAddr.word + (srcAddr.pixel / 2), srcAddr.pixel MOD 2];	THROUGH [0..ptr.height) DO	  dstPtr ¬ dstAddr.word;	  dstIndex ¬ dstAddr.pixel;	  srcPtr ¬ srcAddr.word;	  srcIndex ¬ 1 - srcAddr.pixel; -- byte-swap	  SELECT flags.dstFunc FROM	    src =>	      THROUGH [0..ptr.width) DO	        dstPtr[dstIndex] ¬ (IF srcPtr[srcIndex] # 0 THEN 1 ELSE 0);		IF dstIndex < 15 THEN dstIndex ¬ dstIndex + 1 ELSE		  BEGIN		  dstIndex ¬ 0;		  dstPtr ¬ dstPtr + 1		  END;		IF srcIndex # 0 THEN srcIndex ¬ 0 ELSE		  BEGIN		  srcIndex ¬ 1;		  srcPtr ¬ srcPtr + 1		  END;	      ENDLOOP;	    srcIf0 =>	      THROUGH [0..ptr.width) DO	        IF srcPtr[srcIndex] = 0 THEN dstPtr[dstIndex] ¬ 0;		IF dstIndex < 15 THEN dstIndex ¬ dstIndex + 1 ELSE		  BEGIN		  dstIndex ¬ 0;		  dstPtr ¬ dstPtr + 1		  END;		IF srcIndex # 0 THEN srcIndex ¬ 0 ELSE		  BEGIN		  srcIndex ¬ 1;		  srcPtr ¬ srcPtr + 1		  END;	      ENDLOOP;	    srcIfNot0 =>	      THROUGH [0..ptr.width) DO	        IF srcPtr[srcIndex] # 0 THEN dstPtr[dstIndex] ¬ 1;		IF dstIndex < 15 THEN dstIndex ¬ dstIndex + 1 ELSE		  BEGIN		  dstIndex ¬ 0;		  dstPtr ¬ dstPtr + 1		  END;		IF srcIndex # 0 THEN srcIndex ¬ 0 ELSE		  BEGIN		  srcIndex ¬ 1;		  srcPtr ¬ srcPtr + 1		  END;	      ENDLOOP;	    srcXorDst =>	      THROUGH [0..ptr.width) DO	        IF srcPtr[srcIndex] # 0 THEN dstPtr[dstIndex] ¬ 1 - dstPtr[dstIndex];		IF dstIndex < 15 THEN dstIndex ¬ dstIndex + 1 ELSE		  BEGIN		  dstIndex ¬ 0;		  dstPtr ¬ dstPtr + 1		  END;		IF srcIndex # 0 THEN srcIndex ¬ 0 ELSE		  BEGIN		  srcIndex ¬ 1;		  srcPtr ¬ srcPtr + 1		  END;	      ENDLOOP;	    ENDCASE;	  dstAddr ¬ [dstAddr.word + ((dstAddr.pixel + dstPpl) / 16),	    (dstAddr.pixel + dstPpl) MOD 16];	  srcAddr ¬ [srcAddr.word + ((srcAddr.pixel + srcDesc.srcPpl) / 2),	    (srcAddr.pixel + srcDesc.srcPpl) MOD 2]	ENDLOOP	END ELSE	BEGIN -- display to display: a BitBltX of 8 times the width	dstAddr ¬ NormalizeAddr[[dstAddr.word, 8 * dstAddr.pixel]];	srcAddr ¬ NormalizeAddr[[srcAddr.word, 8 * srcAddr.pixel]];	BitBltX.BitBltX[dstAddr, 8 * dstPpl, srcAddr, [srcPpl[8 * srcDesc.srcPpl]],	  8 * ptr.width, ptr.height, flags];	IF InDisplayBuffer[dstAddr.word] THEN UpdateDisplay[ptr];	END;    END;  UpdateDisplay: PROC [ptr: ColorBlt.CBptr] =    BEGIN    wordOffset: LONG CARDINAL = LOOPHOLE[ptr.dst.word, LONG CARDINAL] -      LOOPHOLE[bitmapAddress, LONG CARDINAL];    wordX: CARDINAL;    [displayFCB.destRectangle.origin.y, wordX] ¬      Inline.LongDivMod[wordOffset, displayWordsPerLine];    displayFCB.destRectangle.origin.x ¬ wordX * pixelsPerWord + ptr.dst.pixel;    displayFCB.destRectangle.width ¬ ptr.width;    displayFCB.destRectangle.height ¬ ptr.height;    IF ptr.flags.direction = backward      THEN displayFCB.destRectangle.origin.y ¬ displayFCB.destRectangle.origin.y -        (ptr.height - 1);    displayFCB.command ¬ updateRectangle;    GuamInputOutput.CallAgent[display]    END;  WRITEPIXEL: PROC [addr: ColorBlt.Address, color: ColorBlt.Color,    dstType: ColorBlt.PixelType, dstFunc: ColorBlt.DstFunc] =    BEGIN    Frame.WritePC[      pc: [(Frame.ReadPC[Frame.GetReturnFrame[]] + 2)],      lf: Frame.GetReturnFrame[]];    SoftwareWritePixel[addr, color, dstType, dstFunc]    END;  -- main code  PrincOps.ESCTrapTable[ColorBlt.aCOLORBLT] ¬ SELECT displayFCB.displayType FROM    fourBitPlaneColor => LOOPHOLE[COLORBLT16],    byteColor => LOOPHOLE[COLORBLT256],    ENDCASE => LOOPHOLE[COLORBLTMono];  PrincOps.ESCTrapTable[ColorBlt.aWRITEPIXEL] ¬ LOOPHOLE[WRITEPIXEL]  END.  -- of UserTerminalHeadGuamLOG10-Mar-93 - JPM - Created.23-Apr-93 - JPM - Added ColorBlt implementation.26-Apr-93 - JPM - Fixed bugs in COLORBLT16 (wrong plane increment, dropped dstType).26-Apr-93 - JPM - Fixed another bug in COLORBLT16 (forgot to modify mask).27-Apr-93 - JPM - Fixed another bug in COLORBLT16 (so srcXorDst will work).28-Apr-93 - JPM - Above fix didn't work (needed to set color0 to white for display pattern). 7-May-93 - JPM - Added implementation of COLORBLT256.14-May-93 - JPM - Fixed various bugs (display background handling, COLORBLT256).20-May-93 - JPM - Changed per redefinition of field "newValue" in mouseFCB. 1-Jul-93 - JPM - Added ConnectInline and DisconnectInline, and call them from cleanup proc.23-Aug-93 - JPM - Added bitmapMapped to ensure bitmap is not unmapped twice; put in code to save and restore color palette for byteColor display.14-Sep-93 - JPM - Changed 16-color mode to handle color blends.
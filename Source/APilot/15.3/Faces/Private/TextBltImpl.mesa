-- File: TextBltImpl.mesa - last edit:-- RSV                 24-Aug-93 13:14:50-- JGS                  7-Feb-86  8:57:57-- LXB       .ES       18-Dec-84 16:26:21-- Copyright (C) 1984, 1985, 1986, 1993 by Xerox Corporation. All rights reserved.DIRECTORY  BitBlt,  Frame USING [GetReturnFrame, ReadPC, WritePC],  TextBltFontFormat,  ESCAlpha USING [aTXTBLT],  PrincOps USING [ESCTrapTable],  TextBlt;TextBltImpl: PROGRAM  IMPORTS BitBlt, Frame EXPORTS TextBlt =  BEGIN  Byte: TYPE = CARDINAL[0..255];    Font: PUBLIC TYPE = TextBltFontFormat.FontRecord;  FontHandle: TYPE = TextBltFontFormat.FontHandle;  BitWidth: PROC [font: FontHandle, char: Byte] RETURNS [CARDINAL]  = INLINE {    RETURN[font.spacingWidths[char]]};  Height: PROC [font: FontHandle] RETURNS [CARDINAL]  = INLINE {    RETURN[font.height]};  PrinterWidth: PROC [font: FontHandle, char: Byte] RETURNS [CARDINAL]  = INLINE {    RETURN[font.printerWidths[char]]};  Pad: PROC [font: FontHandle, char: Byte] RETURNS [BOOLEAN]   = INLINE {    RETURN[font.flags[char].pad]};  Stop: PROC [font: FontHandle, char: Byte] RETURNS [BOOLEAN]   = INLINE {    RETURN[font.flags[char].stop]};  TEXTBLT: PROC [    index: CARDINAL, bitPos: CARDINAL, micaPos: CARDINAL, count: INTEGER,    ptr: POINTER TO TextBlt.TextBltArg]    RETURNS [CARDINAL, CARDINAL, CARDINAL, INTEGER, TextBlt.Result] =    BEGIN    -- since this is called as a trap instruction, we gotta    -- bump the pc.  Note that TextBlt is minimal stack, which    -- means we don't have to bother dumping state.    Frame.WritePC[      pc: [Frame.ReadPC[Frame.GetReturnFrame[]]+2],      lf: Frame.GetReturnFrame[]];    RETURN SoftwareTextBlt[      index: index, bitPos: bitPos, micaPos: micaPos, count: count, ptr: ptr];    END;          SoftwareTextBlt: PUBLIC PROCEDURE [    index: CARDINAL, bitPos: CARDINAL, micaPos: CARDINAL, count: INTEGER,    ptr: POINTER TO TextBlt.TextBltArg]    RETURNS [      newIndex: CARDINAL, newBitPos: CARDINAL, newMicaPos: CARDINAL,      newCount: INTEGER, result: TextBlt.Result] =    BEGIN    bbtablespace: BitBlt.BBTableSpace;    bb: BitBlt.BBptr = BitBlt.AlignedBBTable[@bbtablespace];    font: FontHandle   = ptr.font;    printerWidth: CARDINAL;        UNTIL index > ptr.last DO      char: Byte = ptr.text[index];      IF ptr.function = resolve THEN ptr.coord[index] _ bitPos;      IF Stop[font, char] THEN GOTO Quit;      IF (printerWidth _ PrinterWidth[font, char]) = CARDINAL.LAST THEN GOTO NotInFont;      IF micaPos + printerWidth > ptr.margin THEN GOTO Margin;      IF ptr.function = display THEN DisplayChar[ptr, bitPos, char, bb];      bitPos _ bitPos + BitWidth[font, char];      micaPos _ micaPos + printerWidth;      IF Pad[font, char] THEN        BEGIN        count _ count + 1;        IF ptr.function # format THEN          BEGIN          bitPos _ bitPos + ptr.space;          IF count <= 0 THEN bitPos _ bitPos + 1;          END;        END;      index _ index + 1;      REPEAT        Quit => result _ stop;        Margin => result _ margin;        NotInFont => result _ notInFont;        FINISHED => result _ normal;      ENDLOOP;    RETURN[index, bitPos, micaPos, count, result];    END;  -- TextBlt  DisplayChar: PRIVATE PROC [    ptr: POINTER TO TextBlt.TextBltArg, bitPos: INTEGER, char: Byte,    bb: BitBlt.BBptr] =  --INLINE    BEGIN    font: FontHandle = ptr.font;    info: LONG POINTER TO TextBltFontFormat.RasterInfo = @font.rasterInfos[char];    KernLeftWidth: PROC RETURNS [CARDINAL] = INLINE {      RETURN[LOOPHOLE[info.leftKern]]};    KernRightWidth: PROC RETURNS [CARDINAL] = INLINE {      RETURN[LOOPHOLE[info.rightKern]]};    IF (bitPos _ bitPos - KernLeftWidth[]) < 0 THEN      bb.dst _ [        word: ptr.dst + (bitPos - 15)/16, reserved: 0, bit: CARDINAL[bitPos] MOD 16]    ELSE      bb.dst _ [        word: ptr.dst + CARDINAL[bitPos]/16, reserved: 0,        bit: CARDINAL[bitPos] MOD 16];    bb.dstBpl _ INTEGER[ptr.dstBpl];    bb.src _ [word: @font.rasters[info.offset], reserved: 0, bit: 0];    bb.srcDesc.srcBpl _ bb.width _      font.spacingWidths[char] + KernLeftWidth[] + KernRightWidth[];    bb.height _ font.height;    bb.flags _ [      direction: forward, disjoint: TRUE, disjointItems: TRUE, gray: FALSE,      srcFunc: null, dstFunc: or, reserved: 0];    bb.reserved _ 0;    BitBlt.BITBLT[bb];    END;  PrincOps.ESCTrapTable[ESCAlpha.aTXTBLT] _ LOOPHOLE[TEXTBLT];      END....  -- of TextBltImplLOGMarch 24, 1980 10:57 AM - XXG    - Created.May 8, 1980 5:13 PM - XXG    - Fixed space count to be integer.July 30, 1980  10:17 AM - Jim JXF      - Integrate into Pilot.August 6, 1980  6:40 PM - XXG    - Added kerning.  Allow wider than 16 bit chars.August 29, 1980  4:10 PM - JXW  - Reversed parameters, juggled Fonts, added exported type.March 16, 1981  7:15 PM - FXH     - Make current (characters are now compressed, Display checks for right margin).12-Jan-82 14:26:48 - FXH     - Merged in Dave DXM    's changes for new Fonts.mesa17-Oct-84  8:46:12 - JGS     - Reflected new font format and notInFont result. 7-Jan-85 16:56:18 - JGS     - Exported SoftwareTextBlt.24-Aug-93 13:15:01 - RSV     - Changed DisplayChar procedure to truncate a negative number towards minus infinity rather than toward 0.
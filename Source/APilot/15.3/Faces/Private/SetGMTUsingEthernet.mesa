-- File: SetGMTUsingEthernet.mesa - last edit:-- kam                 30-Sep-85 15:45:39-- Copyright (C) 1980, 1981, 1982, 1983, 1984, 1985 by Xerox Corporation. All rights reserved. DIRECTORY  EthernetFace USING [    AddCleanup, ControlBlock, controlBlockSize, DeviceHandle, GetNextDevice,    GetPacketLength, GetStatus, GlobalStatePtr, globalStateSize, nullDeviceHandle,    QueueInput, QueueOutput, RemoveCleanup, TurnOff, TurnOn],  Environment USING [Base, Byte, bytesPerWord, Long],  HostNumbers USING [broadcastHostNumber, HostNumber],  Inline USING [BITOR],  NSConstants USING [timeServerSocket],  PilotMP USING [cTimeNotAvailable],  PilotSwitchesExtraExtraExtras USING [continueBootingIfNoTimeServer],  ProcessorFace USING [    GetGreenwichMeanTime, GreenwichMeanTime, gmtEpoch, ProcessorID, processorID,    SetGreenwichMeanTime, SetMP, mp],  ResidentHeap USING [first64K, MakeNode],  System USING [switches],  TemporarySetGMT USING [TimeZoneDirection],  Zone USING [Status];SetGMTUsingEthernet: PROGRAM  IMPORTS EthernetFace, Inline, ProcessorFace, ResidentHeap, System  EXPORTS TemporarySetGMT  SHARES ProcessorFace =  BEGIN OPEN ProcessorFace;  SetGMT: PUBLIC PROC [    earliestAcceptableTime, latestAcceptableTime: ProcessorFace.GreenwichMeanTime]    RETURNS [      paramsValid: BOOLEAN, zoneDirection: TemporarySetGMT.TimeZoneDirection,      zone: [0..12], zoneMinutes: [0..59], beginDST: [0..366], endDST: [0..366]] =    BEGIN    teMP: CARDINAL = ProcessorFace.mp;    ProcessorFace.SetMP[PilotMP.cTimeNotAvailable];    DO      networkTimeFound: BOOLEAN;      gmt: ProcessorFace.GreenwichMeanTime;      [networkTimeFound, gmt, zoneDirection, zone, zoneMinutes, beginDST, endDST]        ¬ GetNetworkGMT[];      IF networkTimeFound THEN {        ProcessorFace.SetGreenwichMeanTime[gmt];        ProcessorFace.SetMP[teMP];        RETURN[TRUE, zoneDirection, zone, zoneMinutes, beginDST, endDST]};      IF ((gmt ¬ ProcessorFace.GetGreenwichMeanTime[]) # ProcessorFace.gmtEpoch)        AND          ((PFSecondsSinceEpoch[gmt] > PFSecondsSinceEpoch[             earliestAcceptableTime])            OR (earliestAcceptableTime = ProcessorFace.gmtEpoch))        AND          ((PFSecondsSinceEpoch[gmt] <= PFSecondsSinceEpoch[latestAcceptableTime])            OR (latestAcceptableTime = ProcessorFace.gmtEpoch)) THEN {        SetMP[teMP]; RETURN[FALSE, , , , , ]};      IF System.switches[        PilotSwitchesExtraExtraExtras.continueBootingIfNoTimeServer] = down	THEN BEGIN        ProcessorFace.SetGreenwichMeanTime[ProcessorFace.gmtEpoch + 1];	SetMP[teMP];	RETURN[FALSE, , , , , ];	END;      ENDLOOP;    END;  -- D'Lions run off the wall frequency, so their clock needs no fixing up once set  FixupClock: PUBLIC PROCEDURE = {};  Byte: TYPE = Environment.Byte;  -- Following started as a copy of GTime.mesa  -- as edited by Johnsson on July 12, 1979  8:31 AM  NetTime: TYPE = MACHINE DEPENDENT RECORD [    -- this is what comes in a TimeReply Packet    timeHigh(0), timeLow(1): CARDINAL,    direction(2): TemporarySetGMT.TimeZoneDirection,    zone(3): [0..127],    zoneMinutes(4): [0..255],    beginDST(5), endDST(6): CARDINAL,    errorAccurate(7): BOOLEAN,    errorLow(8), errorHigh(9): CARDINAL];  packetTypeOis: CARDINAL = 3000B;  protocolTypeReqRep: CARDINAL = 4;  -- = NSTypes.PacketType[packetExchange]  packetExchangeClient: CARDINAL = 1;  timeRequest: CARDINAL = 1;  timeReply: CARDINAL = 2;  tsProtocolVersion: CARDINAL = 2;  Address: TYPE = MACHINE DEPENDENT RECORD [    net: RECORD [a, b: WORD] ¬ [0, 0],    host: HostNumbers.HostNumber,    socket: WORD];  Encapsulation: TYPE = MACHINE DEPENDENT RECORD [    eDest, eSource: HostNumbers.HostNumber, packetType: CARDINAL];  Header: TYPE = MACHINE DEPENDENT RECORD [    checksum, length: CARDINAL,    transportControl, oisType: Byte,    dest, source: Address,    id1, id2: WORD,    clientType: WORD,    tsVersion, tsPacketType: WORD];  Request: TYPE = MACHINE DEPENDENT RECORD [encap: Encapsulation, head: Header];  Reply: TYPE = MACHINE DEPENDENT RECORD [    encap: Encapsulation, head: Header, data: NetTime];  iocb: EthernetFace.ControlBlock;  DriverNeedsSomeGlobalStorage: PUBLIC ERROR = CODE;  ResidentHeapError: ERROR = CODE;  GetNetworkGMT: PUBLIC PROC    RETURNS [      networkTimeFound: BOOLEAN, timeFromNetwork: ProcessorFace.GreenwichMeanTime,      zoneDirection: TemporarySetGMT.TimeZoneDirection, zone: [0..12],      zoneMinutes: [0..59], beginDST: [0..366], endDST: [0..366]] =    BEGIN OPEN EthernetFace;    minWordsPerEthernetPacket: CARDINAL = (64/2) - 2;    --*** Should move to DriverTypes    ether: DeviceHandle = GetNextDevice[nullDeviceHandle];    global: GlobalStatePtr;  -- Allocate space when needed    inputSize: CARDINAL = MAX[SIZE[Reply], 32] + slop;    slop: CARDINAL = 12;    in: ARRAY [0..inputSize + 3) OF CARDINAL;    out: ARRAY [0..SIZE[Request] + 3) OF CARDINAL;    request: POINTER TO Request = Inline.BITOR[@out, 3];    reply: POINTER TO Reply = Inline.BITOR[@in, 3];    id1: WORD = 1234B;    id2: WORD = 56710B;    socket: WORD = 111213B;    IF ~EthernetExists[] THEN RETURN[FALSE, ProcessorFace.gmtEpoch, , , , , ];    IF globalStateSize # 0 THEN      [global, ] ¬ ResidentHeap.MakeNode[EthernetFace.globalStateSize, a4];    request­ ¬ [      [      eDest: HostNumbers.broadcastHostNumber, eSource: ProcessorFace.processorID,      packetType: packetTypeOis], [      checksum: 177777B, length: Environment.bytesPerWord*SIZE[Header],      transportControl: 0, oisType: protocolTypeReqRep,      dest: [      host: HostNumbers.broadcastHostNumber,      socket: LOOPHOLE[NSConstants.timeServerSocket]],      source: [host: ProcessorFace.processorID, socket: socket], id1: id1,      id2: id2, clientType: packetExchangeClient, tsVersion: tsProtocolVersion,      tsPacketType: timeRequest]];    AddCleanup[ether];    THROUGH [0..3) DO      THROUGH [0..3) DO        TurnOff[ether];        TurnOn[ether, LOOPHOLE[ProcessorFace.processorID], 0, 0, global];        reply.encap.packetType ¬ 0;        QueueOutput[          ether, request, MAX[SIZE[Request], minWordsPerEthernetPacket], iocb];        THROUGH [0..LAST[CARDINAL]/2) DO          IF GetStatus[iocb] # pending THEN            BEGIN            IF GetStatus[iocb] = ok AND GetPacketLength[iocb] >= SIZE[Reply]              AND reply.encap.packetType = packetTypeOis              AND reply.head.dest.host = ProcessorFace.processorID              AND reply.head.dest.socket = socket              AND reply.head.source.socket =                LOOPHOLE[NSConstants.timeServerSocket, WORD]              AND reply.head.id1 = id1 AND reply.head.id2 = id2              AND reply.head.clientType = packetExchangeClient              AND reply.head.tsVersion = tsProtocolVersion              AND reply.head.tsPacketType = timeReply THEN {              nt: POINTER TO NetTime = @reply.data;              LOOPHOLE[timeFromNetwork, Environment.Long] ¬ [                num[lowbits: nt.timeLow, highbits: nt.timeHigh]];              TurnOff[ether];              RemoveCleanup[ether];              RETURN[                TRUE, timeFromNetwork, nt.direction, nt.zone, nt.zoneMinutes,                  nt.beginDST, nt.endDST]};            -- Start (another) read either because the send just            -- finshed or we didn't like the            -- packet that just arrived.            QueueInput[ether, reply, inputSize, iocb];            END;          ENDLOOP;        ENDLOOP;      ENDLOOP;    TurnOff[ether];    RemoveCleanup[ether];    timeFromNetwork ¬ ProcessorFace.gmtEpoch;    RETURN[FALSE, timeFromNetwork, , , , , ]    END;  PFSecondsSinceEpoch: PROCEDURE [gmt: ProcessorFace.GreenwichMeanTime]    RETURNS [LONG CARDINAL] = INLINE {RETURN[gmt - ProcessorFace.gmtEpoch]};  EthernetExists: PROCEDURE RETURNS [BOOLEAN] =    BEGIN OPEN EthernetFace;    RETURN[GetNextDevice[nullDeviceHandle] # nullDeviceHandle];    END;  --  Adjustable clock   --  The Dandelion clock runs off the wall frequency, so is not adjustable  adjustableClockRate: PUBLIC BOOLEAN ¬ FALSE;  SetClockRate: PUBLIC PROCEDURE [internal, external: LONG CARDINAL] = {};  -- Initialization  BEGIN  iocbRelative: Environment.Base RELATIVE POINTER;  status: Zone.Status;  [iocbRelative, status] ¬ ResidentHeap.MakeNode[    EthernetFace.controlBlockSize, a4];  IF status # okay THEN ERROR ResidentHeapError;  iocb ¬ LOOPHOLE[@ResidentHeap.first64K[iocbRelative]];  END;  END....LOGTime: November 10, 1980  6:35 PM	By: FXH            Action: Create from EthernetOne version of August 20, 1980  2:18 PMTime: November 13, 1980  6:47 PM	By: HGM+RKJ        Action: ?Time: November 14, 1980  5:25 PM	By: RXJ             Action: ?Time: January 12, 1981  2:15 PM	By: Forrest+RKJ        Action: ?Time: January 22, 1981  12:40 PM	By: RG            Action: Get iocb storage from resident heap instead of local frame; add LocalTimeParametersTime: February 4, 1981  6:04 PM	By: PXM            Action: SystemExtras => System; use NSConstants.TimeServerSocketTime: February 6, 1981  10:05 AM	By: AWL              Action: Typo: TimeServerSocket => timeServerSocketTime: February 25, 1981  4:30 PM	By: RYL          Action: enforced minimun packet size on ethernet.Time: March 12, 1981  5:34 PM	By: SXY           Action: Bug fix in SetGMT, MP is always set to 937 if time is not set properly.Time: March 19, 1981  2:06 PM	By: SXY           Action: 990 instead of 930 is set at exit from SetGMT.		Time: October 26, 1981  10:53AM BY: XXR           Action: Modified time fetch routines, deleted reference to system, changed GetTime to GetNetworkGMT...	Time: 14-Nov-81  9:40:54 BY: FXH            Action: changed to use HostNumbers....Time:  7-Dec-81 15:18:27	By: KAM             Action: Added SetClockRate, adjustableClockRate.Time:  16-Feb-82 23:15:30	By: KAM             Action: Added FixupClock; ERRORs => RuntimeInternal.Bug; Moved iocb allocation to initialization code.	Time: 17-Feb-82 15:08:07	By: KAM             Action: RuntimeInternal.Bug => ERRORs.	Time: 18-Aug-82 12:11:26	By: KAM             Action: Converted GetNetworkGMT to use NS time protocol.	Time:  6-Apr-83 16:23:28	By: AEF             Action: Change OISCPConstants to NSConstantsTime: 11-Apr-83 14:30:37	By: AEF             Action: Delete TemporarySetGMTExtra referencesTime: 13-Jan-84 16:40:51	By: KAM             Action: GetNetworkGMT was using PacketType[oldTimeServer] rather than PacketType[packetExchange].Time: 26-Sep-84  0:12:03	By: DEG     	Action: Added copyright notice and rebuild for 11.1 release.Time: 19-Aug-85 18:28:20	By: BKI		Action: Initialize and allocate 'global'
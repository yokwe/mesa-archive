-- EthernetHeadGuam.mesa - last edit:--  RSV         18-Aug-93  0:59:16--  JPM		26-Mar-93  7:58:25-- Copyright (C) 1993 by Xerox Corporation.  All rights reserved.<< The following program was created in 1993 but has not been published within the meaning   of the copyright law, is furnished under license, and may not be used, copied and/or   disclosed except in accordance with the terms of said license.>>DIRECTORY  DeviceCleanup USING [Await, Item, Reason],  Environment USING [bytesPerWord],  ESCAlpha USING [aRRWP, aWRWP],  EthernetFace USING [GlobalStatePtr, Status],  EthernetIOFaceGuam USING [EthernetFCBType, EthernetIOCBType],  GuamInputOutput USING [CallAgent, GetFCBPtr, InterruptSelectorType],  HeadStartChain USING [Start],  HostNumbers USING [ProcessorID],  Inline USING [BITOR],  Mopcodes USING [zESC];  EthernetHeadGuam: PROGRAM   IMPORTS DeviceCleanup, GuamInputOutput, RemainingHeads: HeadStartChain, Inline  EXPORTS EthernetFace, HeadStartChain =   BEGIN  -- PUBLIC TYPEs  ControlBlockRecord: PUBLIC TYPE = EthernetIOFaceGuam.EthernetIOCBType;  DeviceHandle: PUBLIC TYPE = CARDINAL;  -- PRIVATE TYPE  ControlBlock: TYPE = LONG POINTER TO ControlBlockRecord;  -- constants  fcb: LONG POINTER TO EthernetIOFaceGuam.EthernetFCBType =    GuamInputOutput.GetFCBPtr[network];  bpw: CARDINAL = Environment.bytesPerWord;  -- PUBLIC variables  globalStateSize: PUBLIC CARDINAL ¬ 0;  controlBlockSize: PUBLIC CARDINAL ¬    SIZE[EthernetIOFaceGuam.EthernetIOCBType] +    (IF fcb = NIL THEN 0 ELSE fcb.agentBlockSize);  nullDeviceHandle: PUBLIC DeviceHandle ¬ LAST[CARDINAL];  hearSelf: PUBLIC BOOLEAN ¬ IF fcb = NIL THEN FALSE ELSE fcb.hearSelf;  -- PRIVATE variables  cleanupInitialized: BOOLEAN ¬ FALSE;  receiveIOCBHead: ControlBlock ¬ NIL;  receiveIOCBTail: LONG POINTER TO ControlBlock ¬ @receiveIOCBHead;  transmitIOCBHead: ControlBlock ¬ NIL;  transmitIOCBTail: LONG POINTER TO ControlBlock ¬ @transmitIOCBHead;  savedOutInterrupt: GuamInputOutput.InterruptSelectorType ¬ 0;  -- PUBLIC PROCs  AddCleanup: PUBLIC PROC [device: DeviceHandle] = {IF fcb # NIL THEN    BEGIN    item: DeviceCleanup.Item;    savedStopAgent: BOOLEAN ¬ fcb.stopAgent;    savedReceiveInterruptSelector: GuamInputOutput.InterruptSelectorType ¬ fcb.receiveInterruptSelector;    savedTransmitInterruptSelector: GuamInputOutput.InterruptSelectorType ¬ fcb.transmitInterruptSelector;    savedProcessorID: HostNumbers.ProcessorID ¬ fcb.processorID;    IF cleanupInitialized OR device # 0 THEN RETURN;    cleanupInitialized ¬ TRUE;    DO      reason: DeviceCleanup.Reason = DeviceCleanup.Await[@item];      SELECT reason FROM	turnOff, kill =>	  BEGIN	  IF NOT (savedStopAgent ¬ fcb.stopAgent) THEN	    BEGIN	    fcb.stopAgent ¬ TRUE;	    GuamInputOutput.CallAgent[network];	    END;	  THROUGH [0..LAST[CARDINAL]) UNTIL (fcb.receiveStopped AND fcb.transmitStopped)	    DO ENDLOOP;          savedReceiveInterruptSelector ¬ fcb.receiveInterruptSelector;          savedTransmitInterruptSelector ¬ fcb.transmitInterruptSelector;	  savedProcessorID ¬ fcb.processorID	  END;	turnOn =>	  BEGIN	  cb: ControlBlock;          fcb.receiveInterruptSelector ¬ savedReceiveInterruptSelector;          fcb.transmitInterruptSelector ¬ savedTransmitInterruptSelector;	  fcb.processorID ¬ savedProcessorID;	  FOR cb ¬ receiveIOCBHead, cb.nextIOCB UNTIL cb = NIL DO	    IF cb.status = inProgress THEN EXIT;	  ENDLOOP;	  fcb.receiveIOCB ¬ cb;	  FOR cb ¬ transmitIOCBHead, cb.nextIOCB UNTIL cb = NIL DO	    IF cb.status = inProgress THEN EXIT;	  ENDLOOP;	  fcb.transmitIOCB ¬ cb;	  IF NOT (fcb.stopAgent ¬ savedStopAgent)	    THEN GuamInputOutput.CallAgent[network];	  END;	ENDCASE    ENDLOOP    END};  GetNextDevice: PUBLIC PROC [device: DeviceHandle]    RETURNS [DeviceHandle] = {    RETURN[IF device = nullDeviceHandle THEN 0 ELSE nullDeviceHandle]};  GetPacketLength: PUBLIC PROC [cb: ControlBlock] RETURNS [CARDINAL] = {    RETURN[IF cb = NIL THEN 0 ELSE (cb.actualLength + bpw - 1) / bpw]};  GetPacketsMissed: PUBLIC PROC [device: DeviceHandle] RETURNS [CARDINAL] = {    RETURN[IF fcb = NIL OR device # 0 THEN 0 ELSE fcb.packetsMissed]};  GetRetries: PUBLIC PROC [cb: ControlBlock] RETURNS [CARDINAL] = {    RETURN[IF cb = NIL THEN 0 ELSE cb.retries]};  GetStatus: PUBLIC PROC [cb: ControlBlock] RETURNS [status: EthernetFace.Status] =    BEGIN    IF cb = NIL OR cb.status = inProgress      THEN RETURN[pending];    IF NOT cb.dequeued THEN      BEGIN      SELECT cb.packetType FROM        receive =>	  FOR prev: LONG POINTER TO ControlBlock ¬ @receiveIOCBHead, @prev­.nextIOCB	    UNTIL prev­ = NIL DO	    IF prev­ = cb THEN	      BEGIN	      IF (prev­ ¬ cb.nextIOCB) = NIL THEN receiveIOCBTail ¬ prev;	      EXIT	      END;	  ENDLOOP;        transmit =>	  FOR prev: LONG POINTER TO ControlBlock ¬ @transmitIOCBHead, @prev­.nextIOCB	    UNTIL prev­ = NIL DO	    IF prev­ = cb THEN	      BEGIN	      IF (prev­ ¬ cb.nextIOCB) = NIL THEN transmitIOCBTail ¬ prev;	      EXIT	      END;	  ENDLOOP;        ENDCASE;      cb.dequeued ¬ TRUE      END;    RETURN[(SELECT cb.status FROM      completedOK => ok,      tooManyCollisions => tooManyCollisions,      badCRC => crc,      alignmentError => badAlignmentButOkCrc,      packetTooLong => packetTooLong,      badCRCAndAlignmentError => crcAndBadAlignment,      ENDCASE => otherError)]    END;  QueueInput: PUBLIC PROC [device: DeviceHandle, buffer: LONG POINTER, length: CARDINAL, cb: ControlBlock] =    BEGIN    IF cb = NIL THEN RETURN;    length ¬ length * bpw;    cb­ ¬ [buffer, length, 0, FALSE, receive];    IF fcb = NIL OR device # 0 OR buffer = NIL OR length = 0 THEN      BEGIN      cb.status ¬ inProgress; -- don't have a meaningful error status for this case      cb.dequeued ¬ TRUE;      RETURN      END;    receiveIOCBTail­ ¬ cb;    receiveIOCBTail ¬ @cb.nextIOCB;    fcb.receiveIOCB ¬ cb;    fcb.transmitIOCB ¬ NIL;    GuamInputOutput.CallAgent[network]    END;  QueueOutput: PUBLIC PROC [device: DeviceHandle, buffer: LONG POINTER, length: CARDINAL, cb: ControlBlock] =    BEGIN    ReadWP: PROC RETURNS [WORD] = MACHINE CODE      {Mopcodes.zESC, ESCAlpha.aRRWP};    WriteWP: PROC [WORD] = MACHINE CODE      {Mopcodes.zESC, ESCAlpha.aWRWP};   IF cb = NIL THEN RETURN;    length ¬ length * bpw;    cb­ ¬ [buffer, length, 0, FALSE, transmit];    IF fcb = NIL OR device # 0 OR buffer = NIL OR length = 0 THEN      BEGIN      cb.status ¬ completedOK; -- don't have a meaningful error status for this case      cb.dequeued ¬ TRUE;      WriteWP[Inline.BITOR[savedOutInterrupt, ReadWP[]]];      RETURN      END;    transmitIOCBTail­ ¬ cb;    transmitIOCBTail ¬ @cb.nextIOCB;    fcb.receiveIOCB ¬ NIL;    fcb.transmitIOCB ¬ cb;    GuamInputOutput.CallAgent[network]    END;  RemoveCleanup: PUBLIC PROC [DeviceHandle] = {};  Start: PUBLIC --HeadStartChain.-- PROC =    {RemainingHeads.Start[]};  TurnOff: PUBLIC PROC [device: DeviceHandle] =    BEGIN    IF fcb = NIL OR device # 0 THEN RETURN;    fcb.stopAgent ¬ TRUE;    GuamInputOutput.CallAgent[network];    THROUGH [0..LAST[CARDINAL]) UNTIL (fcb.receiveStopped AND fcb.transmitStopped)      DO ENDLOOP;    END;  TurnOn: PUBLIC PROC [device: DeviceHandle, host: HostNumbers.ProcessorID, inInterrupt: WORD, outInterrupt: WORD, globalState: EthernetFace.GlobalStatePtr] =    BEGIN    IF fcb = NIL THEN      BEGIN      savedOutInterrupt ¬ outInterrupt;      RETURN      END;    IF device # 0 THEN RETURN;    IF NOT fcb.stopAgent THEN      BEGIN      fcb.stopAgent ¬ TRUE;      GuamInputOutput.CallAgent[network];      THROUGH [0..LAST[CARDINAL]) UNTIL (fcb.receiveStopped AND fcb.transmitStopped)        DO ENDLOOP      END;    receiveIOCBHead ¬ NIL;    receiveIOCBTail ¬ @receiveIOCBHead;    transmitIOCBHead ¬ NIL;    transmitIOCBTail ¬ @transmitIOCBHead;    fcb.receiveIOCB ¬ NIL;    fcb.transmitIOCB ¬ NIL;    fcb.processorID ¬ host;    fcb.receiveInterruptSelector ¬ inInterrupt;    fcb.transmitInterruptSelector ¬ outInterrupt;    fcb.stopAgent ¬ FALSE;    GuamInputOutput.CallAgent[network]    END;  END.LOG 8-Mar-93 - JPM - Created.18-Mar-93 - JPM - Check for fcb = NIL.22-Mar-93 - JPM - Bug fix: check for fcb = NIL in GetPacketsMissed.26-Mar-93 - JPM - For output iocbs, simulate interrupt and return completedOK status if fcb = NIL (so driver doesn't get stuck).18-Aug-93 - RSV - Copied EthernetHeadBounty.TurnOff for avoiding infinite loop, just in case.
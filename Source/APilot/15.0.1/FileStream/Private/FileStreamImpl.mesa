-- Copyright (C) 1983  by Xerox Corporation. All rights reserved. -- FileStreamImpl.mesa, -- edited by AXD    , 18-Jul-83 11:39:53-- edited by LXR    , 19-Dec-83 15:12:52DIRECTORY  ByteBlt: TYPE USING [ByteBlt],  Environment: TYPE USING [Block, Byte, bytesPerPage, PageCount],  File: TYPE USING [File, GetSize, PageCount, PageNumber, SetSize],  FileStream: TYPE USING [],  Heap: TYPE USING [systemZone],  Inline: TYPE USING [LongCOPY],  Space: TYPE USING [    Access, ForceOut, GetMapUnitAttributes, Map, SwapUnitSize, Unmap],  Stream: TYPE USING [    Block, Byte, defaultObject, EndOfStream, GetPositionProcedure,    GetProcedure, Handle, InputOptions, Object, Position, PutProcedure,    SendAttentionProcedure, SetSSTProcedure, ShortBlock, WaitAttentionProcedure],  Volume USING [ReadOnly];  FileStreamImpl: PROGRAM  IMPORTS ByteBlt, File, Heap, Inline, Space, Stream, Volume  EXPORTS FileStream =  BEGIN  bytesPerPage: CARDINAL = Environment.bytesPerPage;  FSObject: TYPE = RECORD [    stream: Stream.Object,    index: CARDINAL ¬ 0,    bufferBytes: CARDINAL ¬ 0,    dataBytesInBuffer: CARDINAL ¬ 0,    firstFilePageInBuffer: File.PageNumber ¬ 0,    filePages: File.PageCount ¬ 0,    length: LONG CARDINAL ¬ 0,    password: CARDINAL ¬ fsPassword,    buffer: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte ¬ NIL,    eofInBuffer: BOOLEAN ¬ FALSE,    lengthChanged: BOOLEAN ¬ FALSE,    file: File.File];  fsPassword: CARDINAL = 102775B;  FSHandle: TYPE = LONG POINTER TO FSObject;  conversionFudge: CARDINAL = LOOPHOLE[@LOOPHOLE[0,POINTER TO FSObject].stream];  ConvertHandle: PROC [h: Stream.Handle] RETURNS [FSHandle] = INLINE {    RETURN[LOOPHOLE[h-conversionFudge]]};  InvalidHandle: PUBLIC ERROR [errorStream: Stream.Handle] = CODE;  InvalidOperation: PUBLIC ERROR [errorStream: Stream.Handle] = CODE;  ValidateHandle: PROC [h: Stream.Handle] RETURNS [FSHandle] = INLINE {    t: FSHandle = ConvertHandle[h];    IF t.password # fsPassword THEN ERROR InvalidHandle[h];    RETURN[t]};  Create: PUBLIC PROC [    file: File.File, options: Stream.InputOptions] RETURNS [Stream.Handle] = {    filePages: File.PageCount = file.GetSize;    fsh: FSHandle = Heap.systemZone.NEW[FSObject ¬ [      stream: [	options: options,        getByte: GetByte,        putByte: PutByte,        getWord: GetWord,        putWord: PutWord,        get: GetBlock,        put: PutBlock,        setSST: SetSSTNop,        sendAttention: SendAttentionNop,        waitAttention: WaitAttentionNop,        delete: Delete,	getPosition: GetPosition,	setPosition: SetPosition,	sendNow: SendNow,	clientData: NIL,	getSST: Stream.defaultObject.getSST,	getTimeout: Stream.defaultObject.getTimeout,	setTimeout: Stream.defaultObject.setTimeout],      filePages: filePages,      length: filePages*Environment.bytesPerPage - 1,      file: file]];    SetupBuffer[fsh, 0];    RETURN[@fsh.stream]};  -- Generic Stream procedures; assume handle ok  GetByte: PROC [sH: Stream.Handle] RETURNS [byte: UNSPECIFIED[0..256)] = {    fsh: FSHandle = ConvertHandle[sH];    WHILE fsh.index = fsh.dataBytesInBuffer DO      IF fsh.eofInBuffer THEN {SIGNAL Stream.EndOfStream[0]; RETURN[0]};      AdvanceBuffer[fsh];      ENDLOOP;    byte ¬ fsh.buffer[fsh.index];    fsh.index ¬ fsh.index + 1};  GetWord: PROC [sH: Stream.Handle] RETURNS [UNSPECIFIED] = {    t: UNSPECIFIED = CARDINAL[GetByte[sH]]*256;    RETURN[t + GetByte[sH]]};  <<GetError: PROC [sH: Stream.Handle] RETURNS [UNSPECIFIED] = {    ERROR InvalidOperation[sH]};>>  PutByte: PROC [sH: Stream.Handle, byte: UNSPECIFIED[0..256)] = {    fsh: FSHandle = ConvertHandle[sH];    WHILE fsh.index = fsh.dataBytesInBuffer DO      IF fsh.dataBytesInBuffer = fsh.bufferBytes THEN AdvanceBuffer[fsh]      ELSE {        fsh.dataBytesInBuffer ¬ fsh.dataBytesInBuffer + 1;        fsh.lengthChanged ¬ TRUE};      ENDLOOP;    fsh.buffer[fsh.index] ¬ byte;    fsh.index ¬ fsh.index + 1};  PutWord: PROC [sH: Stream.Handle, word: UNSPECIFIED] = {    PutByte[sH, CARDINAL[word]/256];    PutByte[sH, CARDINAL[word] MOD 256]};  <<PutError: PROC [sH: Stream.Handle, word: UNSPECIFIED] = {    ERROR InvalidOperation[sH]};>>  GetBlock: Stream.GetProcedure = {    fsh: FSHandle = ConvertHandle[sH];    bufferBlock: Environment.Block;    countRemaining: CARDINAL ¬ block.stopIndexPlusOne-block.startIndex;    countTransferred: CARDINAL;    sst ¬ 0;    bytesTransferred ¬ 0;    why ¬ normal;    WHILE countRemaining # 0 DO      bufferBlock ¬ [        blockPointer: fsh.buffer,        startIndex: fsh.index,        stopIndexPlusOne: fsh.dataBytesInBuffer];      countTransferred ¬ ByteBlt.ByteBlt[from: bufferBlock, to: block];      fsh.index ¬ fsh.index + countTransferred;      bytesTransferred ¬ bytesTransferred + countTransferred;      IF (countRemaining ¬ countRemaining - countTransferred) = 0 THEN EXIT;      IF fsh.eofInBuffer THEN {        IF options.signalEndOfStream THEN          SIGNAL Stream.EndOfStream[block.startIndex+countTransferred];        IF options.signalShortBlock THEN ERROR Stream.ShortBlock;        why ¬ endOfStream;        EXIT};      block.startIndex ¬ block.startIndex + countTransferred;      AdvanceBuffer[fsh];      ENDLOOP};  <<GetBlockError: Stream.GetProcedure = {ERROR InvalidOperation[sH]};>>  PutBlock: Stream.PutProcedure = {    fsh: FSHandle = ConvertHandle[sH];    bufferBlock: Environment.Block;    countRemaining: CARDINAL ¬ block.stopIndexPlusOne-block.startIndex;    countTransferred: CARDINAL;    WHILE countRemaining # 0 DO      bufferBlock ¬ [        blockPointer: fsh.buffer,        startIndex: fsh.index,        stopIndexPlusOne: fsh.dataBytesInBuffer];      IF fsh.eofInBuffer THEN bufferBlock.stopIndexPlusOne ¬ fsh.bufferBytes;      countTransferred ¬ ByteBlt.ByteBlt[from: block, to: bufferBlock];      fsh.index ¬ fsh.index + countTransferred;      IF fsh.eofInBuffer AND fsh.index > fsh.dataBytesInBuffer THEN {	fsh.dataBytesInBuffer ¬ fsh.index; fsh.lengthChanged ¬ TRUE};      IF (countRemaining ¬ countRemaining - countTransferred) = 0 THEN EXIT;      IF fsh.eofInBuffer THEN {        fsh.dataBytesInBuffer ¬ fsh.bufferBytes;        fsh.lengthChanged ¬ TRUE};      block.startIndex ¬ block.startIndex + countTransferred;      AdvanceBuffer[fsh];      ENDLOOP;    IF endRecord THEN Cleanup[fsh]};  <<PutBlockError: Stream.PutProcedure = {ERROR InvalidOperation[sH]};>>  Delete: PROC [sH: Stream.Handle] = {    fsh: FSHandle ¬ ConvertHandle[sH];    index: LONG CARDINAL = GetPosition[sH];    newFilePages: File.PageCount;    EmptyBuffer[fsh];    newFilePages ¬ PagesForBytes[fsh.length];    IF newFilePages < fsh.filePages THEN fsh.file.SetSize[newFilePages];    Zero[fsh, FSObject.SIZE];    Heap.systemZone.FREE[@fsh]};  GetPosition: Stream.GetPositionProcedure = {    fsh: FSHandle = ConvertHandle[sH];    RETURN[fsh.firstFilePageInBuffer*bytesPerPage + fsh.index]};  SetPosition: PROC [sH: Stream.Handle, position: Stream.Position] = {    fsh: FSHandle = ConvertHandle[sH];    bufferPage: File.PageNumber = fsh.firstFilePageInBuffer;    bufferPages: File.PageCount = fsh.bufferBytes/bytesPerPage;    filePage: File.PageNumber;    byte: CARDINAL;    IF (bufferPage*bytesPerPage + fsh.index) = position THEN RETURN;    filePage ¬ position/bytesPerPage;    byte ¬ CARDINAL[position MOD bytesPerPage];    IF filePage NOT IN [bufferPage..bufferPage + bufferPages) THEN {      growFile: BOOLEAN ¬ FALSE;      IF fsh.lengthChanged THEN Cleanup[fsh];      IF position > fsh.length THEN {        fsh.filePages ¬ filePage + growIncrement; growFile ¬ TRUE};      SetupBuffer[fsh,        MAX[filePage, swapUnitSize] - swapUnitSize, growFile]};    fsh.index ¬      CARDINAL[(filePage - fsh.firstFilePageInBuffer)*bytesPerPage + byte];    IF fsh.index > fsh.dataBytesInBuffer THEN {      fsh.dataBytesInBuffer ¬ fsh.index; fsh.lengthChanged ¬ TRUE}};      SendNow: PROC [sH: Stream.Handle, endRecord: BOOLEAN ¬ TRUE] = {    PutBlock[sH, Stream.Block[NIL, 0, 0], TRUE]};    SetSSTNop: Stream.SetSSTProcedure = {};  SendAttentionNop: Stream.SendAttentionProcedure = {};  WaitAttentionNop: Stream.WaitAttentionProcedure = {RETURN[0]};  -- FileStream specific procedures; must validate handle  EndOf: PUBLIC PROC [sH: Stream.Handle] RETURNS [BOOLEAN] = {    fsh: FSHandle = ValidateHandle[sH];    RETURN[fsh.eofInBuffer AND fsh.index = fsh.dataBytesInBuffer]};  GetLength: PUBLIC PROC [sH: Stream.Handle] RETURNS [LONG CARDINAL] = {    fsh: FSHandle = ValidateHandle[sH];    Cleanup[fsh];    RETURN[fsh.length]};  SetLength: PUBLIC PROC [sH: Stream.Handle, fileLength: LONG CARDINAL] = {    fsh: FSHandle = ValidateHandle[sH];    newFilePages: File.PageCount;    growFile: BOOLEAN ¬ FALSE;    bufferPage: File.PageNumber = fsh.firstFilePageInBuffer;    bufferPages: File.PageCount = fsh.bufferBytes/bytesPerPage;    Cleanup[fsh];    newFilePages ¬ (fileLength + bytesPerPage - 1)/bytesPerPage;    IF newFilePages > fsh.filePages THEN {      fsh.filePages ¬ newFilePages; growFile ¬ TRUE};    fsh.length ¬ fileLength;    SetupBuffer[fsh,      IF newFilePages IN [bufferPage..bufferPage+bufferPages)        THEN fsh.firstFilePageInBuffer      ELSE MAX[newFilePages, swapUnitSize] - swapUnitSize, growFile];    fsh.index ¬ fsh.dataBytesInBuffer};  GetFile: PUBLIC PROC [sH: Stream.Handle] RETURNS [File.File] = {    fsh: FSHandle = ValidateHandle[sH]; RETURN[fsh.file]};  -- Utilities  maxBufferPages: File.PageCount = 70;  maxBufferBytes: CARDINAL = CARDINAL[maxBufferPages*Environment.bytesPerPage];  swapUnitSize: Space.SwapUnitSize = 10;  growIncrement: File.PageCount = 10;  Cleanup: PROC [fsh: FSHandle] = {    Space.GetMapUnitAttributes[fsh.buffer].interval.ForceOut;    IF fsh.lengthChanged THEN {      fsh.length ¬ fsh.firstFilePageInBuffer*bytesPerPage + fsh.dataBytesInBuffer;      fsh.lengthChanged ¬ FALSE}};    SetupBuffer: PROC [    fsh: FSHandle, filePage: File.PageNumber, setLength: BOOLEAN ¬ FALSE] = {    filePagesFollowing: File.PageCount;    indexOfStartOfBuffer: LONG CARDINAL;    access: Space.Access ¬ readWrite;    IF fsh.buffer # NIL THEN EmptyBuffer[fsh];    IF setLength THEN fsh.file.SetSize[fsh.filePages];    fsh.buffer ¬ Space.Map[      window: [file: fsh.file, base: filePage, count: maxBufferPages],      access: access, swapUnits: [uniform[swapUnitSize]]         ! Volume.ReadOnly => {access ¬ readOnly; RETRY}].pointer;    filePagesFollowing ¬ fsh.filePages - filePage;    indexOfStartOfBuffer ¬ filePage*bytesPerPage;    IF fsh.eofInBuffer ¬      (fsh.length <= indexOfStartOfBuffer + maxBufferBytes) THEN {      fsh.dataBytesInBuffer ¬ CARDINAL[fsh.length - indexOfStartOfBuffer]}    ELSE fsh.dataBytesInBuffer ¬ maxBufferBytes;    fsh.bufferBytes ¬ CARDINAL[      MIN[filePagesFollowing, maxBufferPages]*bytesPerPage];    fsh.firstFilePageInBuffer ¬ filePage};  EmptyBuffer: PROC [fsh: FSHandle] = {    IF fsh.buffer = NIL THEN RETURN;    Cleanup[fsh];    fsh.buffer ¬ Space.Unmap[fsh.buffer, return];    fsh.index ¬ fsh.bufferBytes ¬ fsh.dataBytesInBuffer ¬ 0};  AdvanceBuffer: PROC [fsh: FSHandle] = {    filePagesInBuffer: File.PageCount = fsh.bufferBytes/bytesPerPage;    nextPage: File.PageNumber = fsh.firstFilePageInBuffer + filePagesInBuffer;    changeSize: BOOLEAN ¬ FALSE;    IF nextPage >= fsh.filePages THEN {      fsh.filePages ¬ fsh.filePages + growIncrement; changeSize ¬ TRUE};    SetupBuffer[fsh,      MAX[nextPage, swapUnitSize] - swapUnitSize, changeSize];    fsh.index ¬ MIN[      CARDINAL[(nextPage - fsh.firstFilePageInBuffer)*bytesPerPage],      fsh.dataBytesInBuffer]};  PagesForBytes: PROC [w: LONG CARDINAL] RETURNS [p: File.PageCount] = INLINE {      RETURN[(w + bytesPerPage - 1)/bytesPerPage]};  Zero: PROC [p: LONG POINTER, n: CARDINAL] = {    IF n = 0 THEN RETURN;    p­ ¬ 0;    Inline.LongCOPY[from: p, to: p + 1, nwords: n - 1]};  END.
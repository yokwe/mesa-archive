--IORegionInconsistency.txt  As we started developing the floppy handler to support floppy tape, we had to add the ability to support accessing multiple tracks in one IOCB.  This was accomplished by adding the middleTrack and lastTrack structures to the IOCB (we also use the firstTrack but it was already there).  Because having the handler determine which track it was on every time it wanted to access a variable in one those structures would have been very time/space consuming, we copied them into the IORegion and accessed them from there.  [When the operation was started the firstTrack variables are copied to the IORegion.  After the first track is finished the middleTrack variables are copied into the IORegion in place of the firstTrack variables.  And finally the lastTrack variables are are copied into the IORegion in place of the middleTrack variables when the middle track transfers are finished.  (Either the number of middle track transfers or the last track transfer may be 0.  See the documentation stored on [Ohio:OSBU North:Xerox]<IO Architecture> for more details.)]  However, this left the new proms unable to run with 12.x bootfiles since those bootfiles believed that the IORegion was smaller (none of those multiple track variables) and allocated another IORegion in that space.  As a result, when the floppy started executing it smashed another handler's IORegion.  Oooooops.  In order to gain backward compatibility the handler was modified to use a smaller IORegion and access to those mutliple track variables is accomplished by using an offset into the IOCB stored in FloppyTrackOffset (in the IORegion).  This offset is loaded into a base register and the variables accessed by doing ES:[DI][BP].mumble.  FloppyTrackOffset is updated at the time equivalent to the copy of the *Track variables in  previous handlers.  Now comes the inconsistency part....  As this was done LATE in the release cycle we did not want to modify the pilot microcode and boot files to believe in the smaller IORegion so they continue to believe in the larger size.  We waste some space but that's no big deal.  The head did not access the majority of those variables so that it does not matter that they no longer exist.  The only variable that it did access is the queueing semaphore.  The queueing semaphore was added to work around a queueing algorithm bug when using multiple IOCBs.  At the present time multiple IOCBs do not originate from the mesa world (floppy tape has only one IOCB and the floppy has only one IOCB).  The closest thing available is trying to do floppy and floppy tape operations at the same time.  However, the floppy channel only allows one operation to go to the head at a time.  All this means that the semaphore is not really needed so that the fact that the head and handler aren't really using the semaphore (since both have different ideas of its location) is ok.
$	DEBUG MOD186; PREBOOT.asm = 5 revisions up from debugrevc.asm;	JAC	 7-Feb-88 11:22:18	:Reduce size of EPROM segment;	RK	 5-Feb-88 13:46:56	:To save bytes, edited out DUMMY VALUES IN REGS FOR DEBUGING;	RK	27-Aug-87 20:46:28	:Changed time stamp;	JPM	22-Jul-85 10:47:13	:Remove UnSupportedInt array, change IOPEInROM alignment to WORD.;	JPM	19-Jul-85 12:02:51	:Opie redesign conversion.;	KEK	14-Jun-85 13:43:00	:moved segment reg init code to PreBoot.;	KEK	 3-Jun-85 17:57:23	:remove interrupt controller init code; call opie init code instead. removed reset-init code; call PreBootF.asm reset code instead. no longer include HardOpie.;	JMM	14-Mar-85 16:37:06	:Removed burdock board dependency.;	VXS	10-Dec-84 18:09:25	:Change output to daybreak map to be byte instead of word.;	VXS	 6-Dec-84 13:18:11	: Change ORGs in EEPRom;	VXS	 5-Dec-84 19:31:18	:Include HardOpie.asm (hardware configuration file);	VXS	 5-Dec-84 19:26:26	:Change ClearResetsMask to allResetBits;	VXS	 5-Dec-84 18:46:35	:write 0AH to Daybreak IOP map register 0;	VXS	 5-Dec-84 18:38:33	:Remove ORGS, create EProm segment;					: add necessary INCLUDE of HardDefs (required by Opie 16);	FXB	 5-Dec-84 17:03:45	:jump to OPIE if NoDebugger;	FXB	18-Sep-84  9:13:56	:fixed UmbilicalRec vector init;	FXB 	11-Sep-84  9:28:25	:use IOPDEFS instead of HARDDEFS;	FXB	 4-Sep-84 15:03:32	:included IOPDEFS.asm and IOPLRAM.asm;	FXB	28-Aug-84 18:56:18  	:Created Rev 0G002, ;i8259MasterMask and i8259SlaveMask are no longer stored in the Interrupt vector ;table; Last Edited by P.PxE /Jbinkley(rev code and date,; Change ClearResets reg to 01FF) 6-Jun-84 16:20:39; Last edited by JBinkley 23-Apr-84 17:53:34; Last edited by Frank FXB    13-Aug-84 15:57:28; Last edited by Vance VXS   for Frank FXB     8-Aug-84 14:50:52;   to replace 256 sequences in the source with Repeat(256d)...; (Included "NMI" Bindweed routines); This program includes the Burdock debugging "Kernel" and the ; initialization routines for the Daisy which reside in ROM. It; also provides a template/memory map for low RAM;	NAME	PREBOOT$	TITLE(Machine initialization and Burdock ROM)$	NOLIST		;Next line includes definitions file$	INCLUDE(UMBDEFS.ASM)	$	INCLUDE(IOPDEFS.ASM)$	INCLUDE(HardOpie.ASM)	;includes HardDefs.ASM$	LIST		;Previous line included definitions file;;;	Revision of HardDefs: %RevisionEXTRN	BreakIntrHandler: FAR, SSIntrHandler: FAR, DebuggerIntrHandler: FAREXTRN	UnSupportedIntrHandler: FARIOPAlive	EQU	0FFhNoDebugger	EQU	0FFHDebuggerRunning	EQU	0;;; Local RAM segment;IOPELocalRam		SEGMENT	AT 0EXTRN   i186SingleStep: FAR, i186NMI: FAR, i186BreakPoint: FAREXTRN	BindweedIntrptVctBase: DWORDEXTRN	i8259MasterIntrptVctBase: DWORDEXTRN	i82586ISPAddress: WORD	IOPELocalRam	ENDS;;;--------------------------------------------;;;;;--------------------------------------------;      C  O  D  E; ;;; IOPEInRom	SEGMENT	WORD PUBLICEXTRN	InitDove: FARPUBLIC	InitDebug		ASSUME	CS:IOPEInROM;		Make no assumptions about DS, ES or SS ; This section of code is branched to by the reset routine.;;InitDebug	LABEL	FAR;;;-------------------------------------------------------------------------;; Set All Interrupt Vectors to Point at UnSupported Interrupt Handler;;InitVectors:	MOV	CX, NumOfInterrupts		;Setup loop counter	XOR	SI, SI				;Zero the index	MOV	AX, IOPELocalRam		;Use the	MOV	DS, AX				;data segment register	ASSUME	DS:IOPELocalRAM						;	MOV	AX, OFFSET UnSupportedIntrHandler	;Set BX,AX to	MOV	BX, SEG UnSupportedIntrHandler	;the CS:IP to be stored						;InitVectorLoop:	MOV	DS:[SI], AX		;Store the IP	MOV	DS:[SI + 2], BX		;Store the CS	ADD	SI, 4			;Vectors are 4 bytes each	LOOP	InitVectorLoop		;Loop until done;;;-------------------------------------------------------------------------	MOV	BX, 400H	MOV	CX, 18HClearBindweedMemory:	MOV	WORD PTR DS:[BX], 0	INC	BX	INC	BX	LOOP	ClearBindweedMemory;TestBurdock:	CLI			;Disable all 80186 interrupts (-NMI);; Setup the interrupt controllers	PUSHF				;Set up stack to look like interrupt	PUSH	CS			; so procedure will return properly.	CALL	InterruptsConfiguration	; Use Opie init code to do this.;;; Setup the Debugger	CALL	SetDebugIntrVectors	;Establish interrupt vector for Debugger	CALL	SetNMIDebugIntrVectors	CALL	SetSingleStepIntrVectors ;Establish Single Step interrupt vector 	CALL	SetBreakIntrVectors	;Establish Break interrupt vector	CALL	EnableDebugger			CALL	InitDebugger		;Reset and initialize the i8255	CMP	AX, NoDebugger	JE	StartOPIE	;;;; We're ready to go	MOV	BX, 0BBBBH		; STORE DUMMY VALUES IN REGS FOR DEBUGING;	MOV	CX, 0CCCCH;	MOV	DX, 0DDDDH;	MOV	SI, 5151H;	MOV	DI, 0D1D1H;	MOV	AX, 0D5D5H;	MOV	DS, AX;	MOV	AX, 0E5E5H;	MOV	ES, AX;	MOV 	AX, 0AAAAH	STI;; ;Start:	JMP	$EXTRN Initialization: NEAREXTRN InterruptsConfiguration: NEAR	StartOPIE: JMP	Initialization		;;-------------------------------------------------------------------------;;-------------------------------------------------------------------; SUBROUTINE : SetDebugIntrVectors;SetDebugIntrVectors:	MOV	AX, OFFSET DebuggerIntrHandler		;Set BX,AX to	MOV	BX, SEG DebuggerIntrHandler	;the CS:IP to be stored	MOV	SI, umbilicalRecInterrupt * 4	MOV	DS:[SI], AX		;Store the new IP	MOV	DS:[SI+2], BX 		;and the new CS	RET;;-------------------------------------------------------------------; SUBROUTINE : SetNMIDebugIntrVectors;SetNMIDebugIntrVectors:	MOV	AX, OFFSET DebuggerIntrHandler		;Set BX,AX to	MOV	BX, SEG DebuggerIntrHandler	;the CS:IP to be stored	MOV	SI, OFFSET i186NMI		;	MOV	DS:[SI], AX		;Store the new IP	MOV	DS:[SI+2], BX 		;and the new CS	RET;;-------------------------------------------------------------------------; SUBROUTINE : SetSingleStepIntrVectors;SetSingleStepIntrVectors:	MOV	AX, OFFSET SSIntrHandler	;Set BX,AX to	MOV	BX, SEG SSIntrHandler	;the CS:IP to be stored	MOV	SI, OFFSET  i186SingleStep		;Interrupt Type #01h	MOV	DS:[SI], AX		;Store the new IP	MOV	DS:[SI+2], BX 		;and the new CS	RET;;-------------------------------------------------------------------------; SUBROUTINE : SetBreakIntrVectors;SetBreakIntrVectors:	MOV	AX, OFFSET BreakIntrHandler	;Set BX,AX to	MOV	BX, SEG BreakIntrHandler	;the CS:IP to be stored	MOV	SI, OFFSET i186BreakPoint		;Interrupt Type #03h	MOV	DS:[SI], AX		;Store the new IP	MOV	DS:[SI+2], BX 		;and the new CS	RET;;-------------------------------------------------------------------------;InitDebugger:	MOV	Al, i8255mode	;set the i8255 to correct mode	OUT	i8255ctl, Al	;	MOV	Al, i8255EnableIntA	;Turn on INTEa	OUT	i8255ctl, Al	;	MOV	Al, i8255EnableIntB	;Turn on INTEb	OUT	i8255ctl, Al	;	IN	Al, i8255portC	;read the status byte to clear the 0FFh;The following loop is used to determine whether or not there is a burdock board attached.		MOV	AL, SetPC4		;This section checks to see	OUT	i8255ctl, AL		;if or not there is a burdock	IN	AL, i8255portC		;box attached to this machine.	AND	AL, MaskPC4		;We write a bit out and read  	JZ	ThereIsNoDebugger	;it, if debugger is attached	MOV	AL, ResetPC4		;we should get the same value	OUT	i8255ctl, AL		;back, otherwise we don't.	IN	AL, i8255portC		;	AND	AL, MaskPC4		;	JNZ	ThereIsNoDebugger	;	;The following time loop is used to determine whether or not there is a debugger to read the IOPAlive byte	MOV	Al, IOPAlive	;Send out an IOP alive status byte	OUT	i8255portA, Al	;	MOV	CX, 0FFH;	; init counter for timeout LOOPTimeOutLoop:	IN	AL, i8255portC		;(portC is the status port!)	TEST	AL, i8255outReady	;has byte been received by debugger	JNZ	ThereIsADebugger	MOV	BX, CX			;save value of counter for outer loop	MOV	CX, 0FFHInnerTimeOutLoop:	LOOP	InnerTimeOutLoop	MOV	CX, BX			;restore value of counter for outer loop	LOOP	TimeOutLoopThereIsNoDebugger:	MOV	AX, NoDebugger	RET	ThereIsADebugger:	MOV	AX, DebuggerRunning		RET			;;;-------------------------------------------------------------------------;EnableDebugger:	MOV	Al, i8259AllInhibited	;Setup Operation command word 1	AND	Al, i8259EnableIR1	;UnMask IR1		OUT	i8259MasterAddr1, Al	;Enable acceptable interrupts	MOV	AL, i8259MasterOCW2	;Operation command word 2		OUT	i8259MasterAddr0, Al	;Set Priority	MOV	AL, i8259MasterOCW3	;Operation command word 3		OUT	i8259MasterAddr0, Al	;Set to Not Special Mask Mode	RETIOPEInROM	ENDS;--------------------------------------------------------------------;	; The date string is used to identify proms. Please keep it updated.EProm	SEGMENT	PUBLIC	ASSUME	CS:EProm	ORG	0h		;64 bytes before the end of EPROM				;You can use up to 32 bytes...;REVCODE	DB ' G0005'	;newly adopted revision code numberDateString	DB  '07-Feb-88 11:25' ;Please keep up to date ;    This code is branched to right after reset...see below;	ORG	010h		;32 bytes before the end of the 16kByte EPROMReset186Plus	LABEL	FAR	MOV	DX, UMCSaddr	;Program upper memory (EPROM) chip select	MOV	AX, UMCSvalue	;	OUT	DX, AX		;	JMP	FAR PTR InitDove	;Go do rest of initialization sequence		 	;; This code resides at 0FFFF0h or FFFF:0;;   After RESET, 186 begins execution w inst at  FFFF:0;     and  UCS' is active only for the upper 1 KBytes of EPROM.;     So, before we go to the real code, we have to make UCS';     active for the whole upper 16 KBytes of EPROM. Unfortunately, we;     also need to put the SCP up here. We jump back 16 bytes to do some;     of the start-up code...;	ORG	020h		;16 bytes before the end of the 16kByte EPROMReset186:	JMP	FAR PTR Reset186Plus	;Go do rest of initialization sequence;;	The next 10 bytes tell alternative bus masters where the ISCP is located.;	The ISCP is used to point at initialization information for the other;	bus masters.;	ORG	026h		;SCP Base AddressSystemConfigPointer	LABEL	FARSCPsysbus	DB	0		;Word wide memory		DB	0,0,0,0,0	;not used yetSCPiscpPtr	DW	i82586ISPAddress		DB	0F0h,0H	;Address 0F000A0h (vector type 28 & 29)       EProm	ENDS	END
$	DEBUG MOD186; JPM	 	22-Jul-85  9:52:28	:Change IOPEInROM alignment to WORD; JPM	 	19-Jul-85  9:59:09	:Opie redesign (move nonstandard functions to software interrupts, adapt to new IOPELocalRAM); KEK	 	14-Jun-85 13:16:58	:incorporated Frank's remoteheads changes: fixed StopPCE (loaded DS w/ IORegion base); KEK	 	 3-Jun-85 18:01:52	:i8259Mas* duplicate defs get replaced with primary i8259Master* defs in Opie's HardDefs. comment out PC stuff. turn off remoteMemory.; FXB	 	 1-May-85 10:51:15	:fixed StopPCE ; FXB		11-Apr-85 13:59:28	:added StopPCE; FXB		22-Feb-85 10:12:26	:added ResetCP; FXB		15-Feb-85  9:23:55	:moved blockAddrA to Bindweed's IO Region; FXB		12-Feb-85 12:49:51 	:added CLI on entry to BreakPoint and Single Step handlers; FXB		 7-Feb-85 16:16:41	:added DebReadHB; FXB		 6-Feb-85 11:24:23	:added Establish Access for PCE for OPIEAddress conversion; FXB		18-Dec-84  5:45:19	:added OPIE address conversion; FXB		18-Dec-84  4:19:58	:load AX with workNotify mask before changing DS to IORegion; FXB		16-Dec-84 16:34:24	:move SEG IORegion to DS before OPIE calls; FXB		13-Dec-84 11:22:25	:fixed RemoteMemory so DS points at IORegion during OPIE calls; FXB		12-Dec-84 17:52:08	:Changes to save boot-time register values; VXS		 5-Dec-84 20:24:19	:Put conditional RemoteMemory in.; VXS		 5-Dec-84 18:52:50	:Changed ORG 400H to ORG OFFSET BurdockSavedRegisters; FXB		 4-Dec-84 10:14:13	:added remoteMemory command; FXB   	30-Nov-84  9:52:39	:OPIE!16 update; FXB   	29-Nov-84 11:23:28	:made Bindweed a NEAR PROC; FXB   	27-Nov-84 10:36:34	:changed code segment name from InitCode to IOPEInROM; FXB   	 6-Nov-84 10:32:46	:added CP commands; FXB   	27-Sep-84 16:30:53	:made Down notify a software interrupt; FXB   	24-Sep-84 14:47:12	:POP DS before DownNotify; FXB   	21-Sep-84 14:56:13	:zero ES on entry to Bindweed; FXB   	18-Sep-84 11:24:27	:reset debugStatus after each reply; FXB   	11-Sep-84 14:30:40	:use IOPDEFS instead of HARDDEFS; FXB   	 4-Sep-84 14:39:00	:included IOPLRAM and IOPDEFS.ASM; FXB   	31-Aug-84 11:28:19	:made changes to use IOPELocalRam; FXB   	30-Aug-84 12:34:39	:fixed resetting of int flag in SingleStep; FXB		21-Aug-84 14:16:18	:Created;	NAME	bwopie$	TITLE(Debugger Kernel)$	NOLIST		;Next line includes definitions file$	INCLUDE(UMBDEFS.ASM)	$	INCLUDE(IOPDEFS.ASM)$	INCLUDE(HARDDEFS.ASM)$	INCLUDE(IOPMACRO.ASM)$	LIST		;Previous line included definitions file;;;IOPELocalRam		SEGMENT	AT 0EXTRN	BindweedIntrptVctType: ABSEXTRN	BurdockSavedRegisters: WORD		;Data Space for BurdockEXTRN	BindweedBuffer: BYTEsavedRegisters		STRUC	savedAX		DW	?	;	savedBX		DW	?	;	savedCX		DW	?	;	savedDX		DW	?	;	savedSP		DW	?	;	savedBP		DW	?	;	savedSI		DW	?	;	savedDI		DW	?	;	savedCS		DW	?	;	savedDS		DW	?	;	savedSS		DW	?	;	savedES		DW	?	;	savedIP		DW	?	;	savedFLAGS	DW	?		debugStatus	DW	?	;status sent to debugger	iopDebugState	DB	?	;current debugging state	IsABreakPoint	DB	?	;set to YES by the debugger 					;if an INT 3 was executed	SingleStepFlags	DW	?	;an extra copy of the Status Word used by 					;the single step handler to save the 							;interrupt flag during a single step	CSOfBreakPoint	DW	?	IPOfBreakPoint	DW	?savedRegisters		ENDSbwIOCommandBuffer	STRUC	count		DW	?	command		DB	?	port		DW	?	ioData		DW	?bwIOCommandBuffer	ENDSbwReplyBuffer		STRUC	bwCount1	DB	?	bwCount2	DB	?	status		DW	?	empty		DB	?	replyData	DB	?bwReplyBuffer		ENDS		bwMemoryCommandBuffer	STRUC	bwMemFiller	DB 	3 DUP (?)		addressSegment	DW	?	addressOffset	DW	?	addressType	DB	?	bwLength	DB	?	data		DB	?bwMemoryCommandBuffer	ENDSiopStatusMask		EQU	3000H	;bit 2 and 3 set to notify 					;i186Burdock and BWDisplayeriopSingleStep		EQU	05HiopHalted		EQU	02HiopBreak		EQU	04H;iopUnsupportedInt	EQU	06HiopUnsupportedInt	EQU	04H	;temporarily until IOPBermuda changesbwMinReply		EQU	3	; the minimum length of a reply	TimeOutConst		EQU	500	;needs adjust, want about 1msYES			EQU	1BreakPointInstr		EQU	0CCHIOPELocalRam		ENDSIOPEInROM	SEGMENT	WORD PUBLICASSUME	CS: IOPEInROMPUBLIC	BreakIntrHandler, SSIntrHandler, DebuggerIntrHandler, UnSupportedIntrHandlerPUBLIC	Bindweed, DisbleInts	;==============================================================================UnSupportedIntrHandler	LABEL 	FAR 	CLI	CALL 	SaveState	ASSUME	DS:IOPELocalRAM	MOV	[BX].iopDebugState, iopUnsupportedInt	JMP 	SHORT TellDebuggerAboutBreak  	;in DebuggerIntrHandler;===============================================================================BreakIntrHandler	LABEL 	FAR 	CLI	CALL 	SaveState	ASSUME	DS:IOPELocalRAM	MOV	[BX].iopDebugState, iopBreak	TellDebuggerAboutBreak:	OR	[BX].debugStatus, iopStatusMask ; set "naked notify" bits	MOV	CX, 0		; Let Debugger know that you hit a breakpoint	CALL	CreateReply	CALL	SendReply	JMP 	SHORT DisbleInts  	;in DebuggerIntrHandler;===============================================================================SSIntrHandler	LABEL 	FAR	CLI 	CALL 	SaveState	ASSUME	DS:IOPELocalRAM	MOV	AX, [BX].SingleStepFlags	AND	AX, MASK i80186IF 	;clear all bits but int flag in old FLAGS	OR	[BX].savedFLAGS, AX		;restore int flag	AND 	[BX].savedFLAGS, NOT MASK i80186TF  	;reset trap flag	CMP	[BX].IsABreakPoint, YES	;is this a break point?	JNE	NotABreakPoint	MOV	[BX].IsABreakPoint, 0	;reset IsABreakPoint	MOV	ES, [BX].CSOfBreakPoint	;ES _ CSOfBreakPoint	MOV	DI, [BX].IPOfBreakPoint ;DI _ IPOfBreakPoint	MOV	ES: BYTE PTR [DI], BreakPointInstr	;put the break instr back	JMP	DebuggerIntrFinish		;RETURNNotABreakPoint:	OR	[BX].debugStatus, iopStatusMask ; set "naked notify" bits	MOV	[BX].iopDebugState, iopSingleStep		MOV	CX, 0	;let debugger know you executed a single step	CALL	CreateReply	CALL	SendReply	JMP 	SHORT DisbleInts  	;in DebuggerIntrHandler;===============================================================================DebuggerIntrHandler	LABEL	FAR	CALL 	SaveState	ASSUME	DS:IOPELocalRAM;Now, disable interrupts til we finish processing the command;DisbleInts:	CLI		;No interrupts til we finish command processing;****************************************************************************;NMI Umbilical Receive;; AL: input byte returned; CX: count; AH: checksum; SI: buffer index; DS: segment of Bindweed Buffer;bufferSeg _ SEG[BindWeedBuffer];;DO;  bufferOffset _ OFFSET[BindWeedBuffer];;  byte _ GetByte[];;  count _ byte;;  checksum _ byte;;  bufferSeg[bufferOffset] _ byte;;  bufferOffset _ bufferOffset + 1;;  byte _ GetByte[];;  IF count # byte THEN BadCount;;  checksum _ checksum + byte;;  bufferSeg[bufferOffset] _ byte;;  bufferOffset _ bufferOffset + 1;;  FOR CX: WORD IN [1..count] DO;    byte _ GetByte[];;    bufferSeg[bufferOffset] _ byte;;    bufferOffset _ bufferOffset + 1;;    checksum _ checksum + byte;;    ENDLOOP;;  IF checksum # 0 THEN BadChecksum;;  Bindweed[];;  SendReply[];;  ENDLOOP;;  ;  IF BadCount OR BadChecksum THEN receive bytes until timeout(~1ms) and send ;ERROR messageNMIKernel:	MOV	SI, OFFSET BindweedBuffer	CALL 	DebGetInByte	MOV 	CL, AL 		; save first count 	MOV 	[SI], AL	INC 	SI	CALL 	DebGetInByte	CMP 	CL, AL		;are counts the same?	JNE 	FlushInput 	;if not, then flush input	MOV 	[SI], AL	INC 	SI	MOV 	CH, 0  		; clear high byte of CXLoadBWBuffer:		CALL	DebGetInByte	MOV	[SI], AL 	;put input byte in buffer	INC	SI  		; update buffer index	LOOP	LoadBWBuffer      	CALL	Bindweed	JC	FlushInput	CALL	SendReply	JMP	NMIKernelFlushInput:	MOV	DX, TimeOutConst	;set timeout counterWaitToReadByte:	IN	AL, i8255portC		;(portC is the status port!)	TEST	AL, i8255inReady		;Check for a byte ready	JNZ	ReadByte	DEC	DX			;decrement timeout counter	JNZ	WaitToReadByte	JMP	NMIKernel		;input has been flushedReadByte:	IN	AL, i8255portB		;read the byte	JMP	FlushInput	;==============================================================================;Subroutine: Bindweed;	 ; BindWeed - processes command in Bindweed buffer and puts reply in same; ;   SELECT command FROM;     WriteBlock;     ReadBlock;     ReadIO;     WriteIO;     ClientDefinedCommand;;     at PrepareReplyBuffer, register CL contains the length of the reply data;;   At entry to BindWeed, DS:[BX] should address the BurdockSavedRegisters;   BindWeed returns with carry flag set if bad checksum or invalid commandBWCommandList	DW	DebWriteMem, DebReadMem, SendAck, DebFinish, 			DebReadIOByte, DebWriteIOByte, DebReadIOWord, DebWriteIOWordBWExtrnCmdList	DW	DebInt0, DebInt1, DebInt2, DebInt3, DebInt4, DebInt5, DebInt6, DebInt7, DebInt8, DebInt9, DebInt10, DebInt11, DebInt12, DebInt13, DebInt14, DebInt15numberOfCommands	EQU	($-BWCommandList)/2;***************************************************BindWeed 	PROC	NEAR 	MOV	SI, OFFSET BindweedBuffer	MOV	CL, [SI]	; get the count	ADD	CL, 2	XOR	CH, CH	MOV	AH, 0VerifyChecksum:	ADD	AH, [SI]	INC	SI	LOOP	VerifyChecksum	CMP	AH, 0	JE	DoBindweedCommandDebUnsupportedCmd:		STC	RETDoBindweedCommand:	MOV	AL, BindweedBuffer.command	CMP	AL, numberOfCommands	JAE	DebUnsupportedCmd	XOR	AH, AH	MOV	SI, AX	SHL	SI, 1	JMP	BWCommandList[SI]PrepareReplyBuffer:	CALL	CreateReply	CLC	RETBindweed	ENDP;===============================================================================;Bindweed Command SubroutinesDebWriteMem:	CALL	DebSetMemBlockDesc	;get block descriptor from bwBuffer	MOV	SI, OFFSET BindweedBuffer.data	;BP _ index of start of dataDebWriteMemLoop:	MOV	AL, [SI]		;get data byte from bindweed buffer	MOV	ES:[DI], AL		;and store it	INC	SI	INC	DI	LOOP	DebWriteMemLoop		;Do this loop CX times...;--	MOV	CL, 0			;no data in reply 	JMP	PrepareReplyBuffer 	DebReadMem:	CALL	DebSetMemBlockDesc	MOV	SI, OFFSET BindweedBuffer.replyData	;	MOV	AH, CL 			;save count for reply bufferDebReadMemLoop:	MOV	AL, ES:[DI]		;get data from memory	MOV	[SI], AL		;put it in the bindweed buffer	INC	SI			;increment memory index	INC	DI			;increment bindweed buffer index	LOOP	DebReadMemLoop		;Do this loop CX times...	MOV	CL, AH 			;set length of reply data	ADD	CL, 1	JMP	PrepareReplyBufferSendAck:	OR	[BX].debugStatus, iopStatusMask ; set "naked notify" bits 	MOV	[BX].iopDebugState, iopHalted		MOV	CL, 0	;Let Debugger know that you have halted	JMP	PrepareReplyBuffer	DebFinish: 	POP	AX 			;POP bindweed return address (NEAR)	MOV	CL, 0	CALL	CreateReply	CALL	SendReply		;send null reply		 				;Send a specific EOI command to the 8259	MOV	AL, i8259MasterDebuggerInEOI	;Write an EOI command for the 		OUT	i8259MasterAddr0, AL		;debugger InterruptDebuggerIntrFinish:;	---------------------restore state--------------	MOV	AX, [BX].savedAX	MOV	CX, [BX].savedCX	MOV	DX, [BX].savedDX	MOV	BP, [BX].savedBP	MOV	SI, [BX].savedSI	MOV	DI, [BX].savedDI	MOV	ES, [BX].savedES	PUSH	[BX].savedFLAGS	PUSH	[BX].savedCS	PUSH	[BX].savedIP	PUSH	[BX].savedDS	MOV	BX, [BX].savedBX	POP	DS	IRET 	;--------------------------------------------DebReadIOByte:	MOV	SI, OFFSET BindweedBuffer	MOV	DX, [SI].port 		; DX _ Port number	IN	AL, DX	MOV	[SI].replyData, AL	;put value in bwBuffer	MOV	CL, 2 			;one byte of data in reply	JMP	PrepareReplyBuffer	DebWriteIOByte:	MOV	SI, OFFSET BindweedBuffer	MOV	DX, [SI].port 		;DX _ Port number	MOV	AL, [SI].replyData	;get value from buffer	OUT	DX, AL	MOV	CL, 0			;no data in reply	JMP	PrepareReplyBufferDebReadIOWord:	MOV	SI, OFFSET BindweedBuffer	MOV	DX, [SI].port 		; DX _ Port number	IN	AX, DX	MOV	WORD PTR [SI].replyData, AX	;put value in bwBuffer	MOV	CL, 3 			;two bytes of data in reply	JMP	PrepareReplyBufferDebWriteIOWord:	MOV	SI, OFFSET BindweedBuffer	MOV	DX, [SI].port ; DX _ Port number	MOV	AX, WORD PTR [SI].replyData ; get value from buffer	OUT	DX, AX	MOV	CL, 0			;no data in reply	JMP	PrepareReplyBuffer;--------------------------------------------DebInt0:	INT	LOW BindweedIntrptVctType+0	JMP	PrepareReplyBufferDebInt1:	INT	LOW BindweedIntrptVctType+1	JMP	PrepareReplyBufferDebInt2:	INT	LOW BindweedIntrptVctType+2	JMP	PrepareReplyBufferDebInt3:	INT	LOW BindweedIntrptVctType+3	JMP	PrepareReplyBufferDebInt4:	INT	LOW BindweedIntrptVctType+4	JMP	PrepareReplyBufferDebInt5:	INT	LOW BindweedIntrptVctType+5	JMP	PrepareReplyBufferDebInt6:	INT	LOW BindweedIntrptVctType+6	JMP	PrepareReplyBufferDebInt7:	INT	LOW BindweedIntrptVctType+7	JMP	PrepareReplyBufferDebInt8:	INT	LOW BindweedIntrptVctType+8	JMP	PrepareReplyBufferDebInt9:	INT	LOW BindweedIntrptVctType+9	JMP	PrepareReplyBufferDebInt10:	INT	LOW BindweedIntrptVctType+10	JMP	PrepareReplyBufferDebInt11:	INT	LOW BindweedIntrptVctType+11	JMP	PrepareReplyBufferDebInt12:	INT	LOW BindweedIntrptVctType+12	JMP	PrepareReplyBufferDebInt13:	INT	LOW BindweedIntrptVctType+13	JMP	PrepareReplyBufferDebInt14:	INT	LOW BindweedIntrptVctType+14	JMP	PrepareReplyBufferDebInt15:	INT	LOW BindweedIntrptVctType+15	JMP	PrepareReplyBuffer;==============================================================================; Debugger subroutines;==============================================================================;Subroutine: SaveStateSaveState:			;to be called only in interrupt routines	PUSH	DS	PUSH	AX	MOV	AX, IOPELocalRAM	MOV	DS, AX	ASSUME	DS:IOPELocalRAM	POP	AX	PUSH	BX	MOV	BX, OFFSET BurdockSavedRegisters	MOV	[BX].savedAX, AX	POP 	[BX].savedBX	;BX on stack 	MOV	[BX].savedCX, CX	MOV	[BX].savedDX, DX	MOV	[BX].savedBP, BP	MOV	[BX].savedSI, SI	MOV	[BX].savedDI, DI	POP 	[BX].savedDS	;DS on stack 	MOV 	[BX].savedES, ES	POP	AX		;POP return address of (NEAR) subroutine - 1 word	POP	[BX].savedIP	;POP IP saved during interrrupt call	POP	[BX].savedCS	;POP CS saved during interrupt call	POP	[BX].savedFLAGS	;POP FLAGS saved during interrupt call	MOV	[BX].savedSP, SP	MOV	[BX].savedSS, SS	JMP	AX		;return to caller;==============================================================================;Subroutine: CreateReplyCreateReply:;	on entry: CL = length of data;	AH checksum;	BX = pointer to BurdockSavedRegisters	MOV	DI, OFFSET BindweedBuffer	ADD	CL, bwMinReply	MOV	[DI].bwCount1, CL	MOV	[DI].bwCount2, CL	MOV	DX, [BX].debugStatus	MOV	[DI].status, DX	MOV	[BX].debugStatus, 0	XOR	AH, AH		; clear checksum	ADD	CL, 1 		;include  2 count bytes - checksum byte	XOR	CH, CH		;clear high byte of loop counterchecksumLoop:	ADD	AH, [DI]	;add buffer byte to checksum	INC	DI		;increment bindweed buffer index	LOOP	checksumLoop	MOV	AL, 0	SUB	AL, AH	MOV	[DI], AL 	;insert checksum				;buffer is now ready to send	RET;===============================================================================;Subroutine: SendReplySendReply:	MOV	DI, OFFSET BindweedBuffer	MOV 	CL, [DI]	;get count	ADD	CL, 2		;include count bytes	XOR	CH, CHSendBWBuffer:	MOV	DL, [DI]	CALL	DebPutOutByte	INC	DI	LOOP	SendBWBuffer	RET	;===============================================================================;Subroutine: DebSetMemBlockDescIOPLogicalAddress	EQU	0DebSetMemBlockDesc:	MOV	SI, OFFSET BindweedBuffer	MOV	AL, [SI].addressType	CMP	AL, IOPLogicalAddress	JNE	ConvertOPIEAddress		MOV	ES, [SI].addressSegment	MOV	DI, [SI].addressOffset	JMP	SetMemBlockLength	ConvertOPIEAddress:		MOV	CX, [SI].addressSegment	;Set the CX to the requested segment	MOV	DX, [SI].addressOffset	;And the DX to the starting offset		%EstablishIOPAccess(generalMapRegister,CX-DX)			SetMemBlockLength:		MOV	CL, [SI].bwLength		;Set CX to the count	XOR	CH, CH	RET;===============================================================================;Subroutine: DebGetInByteDebGetInByte:				;Byte returned in AL	IN	AL, i8255portC		;(portC is the status port!)	TEST	AL, i8255inReady		;Check for a byte ready	JZ	DebGetInByte		;wait until there is one ready					;	IN	AL, i8255portB		;get the byte and place it in memory	RET;===============================================================================;Subroutine: DebPutOutByteDebPutOutByte:	IN	AL, i8255portC		;(portC is the status port!)	TEST	AL, i8255outReady		;Check for "ok to put byte"	JZ	DebPutOutByte		;wait	MOV	AL, Dl			;Get the argument	OUT	i8255portA, AL		;	RET	;===============================================================================IOPEInROM	ENDSEND
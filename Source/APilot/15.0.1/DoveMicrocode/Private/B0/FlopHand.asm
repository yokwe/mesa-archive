$MOD186$PAGELENGTH (72)$PAGEWIDTH (142);;	Copyright (C) 1984, 1985, 1986 by Xerox Corporation. All rights reserved.;;	File = FloppyHandlerDove.asm;	for vax File = FlopHand.asm;	Stored as [Iris]<WMicro>Dove>FloppyHandlerDove.asm;	This Head/Handler was deliberately designed NOT to do parrellel disk operations even though the fdc can do them;	This file assumes the definitions in FloppyIOFaceDove.asm ( on vax = FlopFace.asm );	We are going to setup ES:[DI] = iocb;	We are going to setup ES:[SI] = @iocb^.fdcCommands[iocb^.CurrentFDCCommand];;	Last edit by;	JAC	 8-Aug-88 13:04:01, add a 2 sec pause during a recal;	RK	25-Jul-88 10:44:52, Change pre stream select delay from 2.0 to 2.5 seconds.;	JAC	 1-Mar-88 16:20:04, add code at RemoveBP;	JAC	28-Feb-88 16:55:11, Decrease size of IORegion;	RK	 7-Feb-88 12:19:54, Added a ReadID command to fix the Recalibrate for tape.;	RK	 6-Nov-87 10:39:52, Changed tape time out from 90 to 180 seconds.  OR instead of MOV 20H to DriveStatusHead0 in CheckDriveStatus.;	RK	12-Oct-87 15:14:20, Fixed queueing algorithm bug.  Added FloppyAdvanceMesaIOCB subroutine.;	RK	 6-Oct-87 19:52:33, Fixed bug for drive 1 usage.;	RK	14-Sep-87 11:48:14, Fixed bug in sa475 and wangtek parameters.;	RK	25-Aug-87 16:27:50, Modified Daisy Floppy Handler for Wangtek tape support.;NAME			FlopHand;$NOLIST$INCLUDE		(IOPDefs.asm)$INCLUDE		(IOPMacro.asm)$INCLUDE		(HardDefs.asm)$INCLUDE		(ROMEEP.asm)$INCLUDE		(QueDefs.asm)$INCLUDE		(QueMacro.asm)$INCLUDE		(FlopFace.asm)$LIST$GENONLY;;;;--------------------------------------------------------------------------------;;;%*DEFINE	( InputWord ( WordPort, WordName ) )(	%IF  (%NES (DX,%WordPort)) THEN (MOV	DX, %WordPort)FI					 IN	AX, DX	%IF  (%NES (AX,%WordName)) THEN (MOV	%WordName, AX)FI)%*DEFINE	( OutputWord ( WordPort, WordName ) )(	%IF  (%NES (DX,%WordPort)) THEN (MOV	DX, %WordPort)FI	%IF  (%NES (AX,%WordName)) THEN (MOV	AX, %WordName)FI					 OUT	DX, AX)%*DEFINE	( PushDISI )(			PUSH	DI			PUSH	SI)%*DEFINE	( PopDISI )(			POP	SI			POP	DI);%*DEFINE	( LongDelay )		(			PUSHA			%WaitForSystem			POPA);;;--------------------------------------------------------------------------------;;	Timer/Counter Ports;FloppyCountRegister		EQU	FloppyTimerCountRegFloppyMaxCountA			EQU	FloppyTimerMaxCountRegFloppyMaxCountB			EQU	i186Timer1CountBAddrFloppyCounterControlWord	EQU	FloppyTimerMCWAddr;;FDCtoDMAport			EQU	FDCDMADataReg;;B0Mask				EQU	0011110011111111BEtchOneIOPMask			EQU	0011100000000000BPort80Mask			EQU	B0Mask					; set this mask for your hardwareReleaseDrivesMask		EQU	Port80Mask AND 0001000011110000BMotorOffMask			EQU	Port80Mask AND 0011100011110000BSelectDrivesMask		EQU	Port80Mask AND 0000000011110000BSpeedChangeMask			EQU	0000000000001000BMotorOnMask			EQU	0010000000000000B			; put in for tape Port80MaskMinusDrive		EQU	Port80Mask AND 1111111100001111B	; put in for tape;ResetAndFlushBit		EQU	00000100B;FlushBit			EQU	00000100BSpecifyBit			EQU	00000010BRecalBit			EQU	00000001BGetRFSRData			EQU	80hfdcTapeReadIDCommand		EQU	4AH;;EXTRN FloppyHandlerID : ABSEXTRN DMA0@FloppyInterrupt : ABSEXTRN FloppyControllerInterrupt : ABS;;FloppyIOR	SEGMENT		COMMON		Assume		DS:FloppyIOR;EXTRN	FloppyTask : TaskContextBlockEXTRN	FloppyDMAtask : TaskContextBlockEXTRN	FloppyStopHandler : BYTEEXTRN	FloppyResetFDC : BYTEEXTRN	FloppyHandlerIsStopped : BYTEEXTRN	FloppyFDCHung : BYTEEXTRN	FloppyWaitingForDMAInterrupt : BYTEEXTRN	FloppyFirstDMAInterrupt : BYTEEXTRN	FloppyDriveMotorControlCount : BYTEEXTRN	FloppyTimeoutOccurred : BYTEEXTRN	FloppyBadDMAInterruptCount : BYTEEXTRN	FloppyBadFDCInterruptCount : BYTEEXTRN	FloppyTapeThisIOCB : BYTEEXTRN	FloppyExtraByte : BYTEEXTRN	FloppyFillerByteForFormatting : BYTEEXTRN	FloppyDiagnosticsOn : BYTEEXTRN	FloppyEncodedDeviceTypes : EncodedDeviceTypeEXTRN	FloppyWorkMask : WORDEXTRN	FloppyWorkNotify : ConditionEXTRN	FloppyLockMask : WORDEXTRN	FloppyCurrentIOCB : WORDEXTRN	FloppyDiagnosticQueue : QueueBlockEXTRN	FloppyPilotQueue : QueueBlockEXTRN	Floppy80186Queue : QueueBlockEXTRN	FloppyDCB0 : DeviceContextBlockEXTRN	FloppyDCB1 : DeviceContextBlockEXTRN	FloppyDCB2 : DeviceContextBlockEXTRN	FloppyDCB3 : DeviceContextBlockEXTRN	FloppyNumberOfMiddleDMAtransfers : WORDEXTRN	FloppyCurrentTrack : BYTEEXTRN	FloppyTrackOffset : BYTEEXTRN	FloppyQueueSemaphore : WORD;;;FloppyIOR	ENDS;;FloppySTK	SEGMENT		COMMON		Assume		SS:FloppySTK;EXTRN	FloppyStack : WORDEXTRN	FloppyDMAStack : WORD;;;FloppySTK	ENDS;;;;--------------------------------------------------------------------------------;;;IOPEInRom		SEGMENT	WORD PUBLIC			Assume CS:IOPEInRom;;;;--------------------------------------------------------------------------------;;;PUBLIC			FloppyInit						; for Opie to initialize the Floppy Handler;FloppyInit		PROC	FAR			%InitializeTask	(FloppyHandlerID,OFFSET	FloppyDMAtask, DMAInterruptHandler,OFFSET FloppyDMAStack)			%InitializeTask	(FloppyHandlerID,OFFSET	FloppyTask, MainFloppyTask,OFFSET FloppyStack)			RETFloppyInit		ENDP;;;;--------------------------------------------------------------------------------;--------------------------------------------------------------------------------;;;BadDMAInterrupt		PROC	FARBeginBadDMAInterrupt:	%EstablishHandlerAccess (FloppyHandlerID)			ASSUME ES:FloppyIOR			INC	ES:FloppyBadDMAInterruptCount			ASSUME ES:NOTHING			RETBadDMAInterrupt		ENDP;;;;--------------------------------------------------------------------------------;;;DMAInterruptHandler:			%ThisTaskServices(DMA0@FloppyInterrupt,BadDMAInterrupt)			CALL	StopDMAandCounter			%Enable ( DMA0@FloppyInterrupt )BeginMainDMAloop:	%PushDISI						; save context			%WaitForInterrupt	()				; wait until the DMA yells			%DisableInterruptsTillNextWaitGotDMAInterrupt:	%PopDISI						; restore context			CMP	FloppyWaitingForDMAInterrupt, MesaTRUE		; IF NOT FloppyWaitingForDMAInterrupt			JE	GoodInterrupt					; BEGIN			INC	FloppyBadDMAInterruptCount			;			JMP	SHORT	BeginMainDMAloop			; ENDGoodInterrupt:		XOR	AH, AH			MOV	AL, FloppyTrackOffset      			; want ES:[DI][BP] point to track we are doing			MOV	BP, AXCheckFirstDMAInterrupt:	CMP	FloppyFirstDMAInterrupt, MesaTRUE		; IF FloppyFirstDMAInterrupt THEN			JNE	NotFirstDMAInterrupt				; BEGIN			MOV	FloppyFirstDMAInterrupt, MesaFALSE		;   FloppyFirstDMAInterrupt ¬ FALSE			%EstablishIOPAccess (GeneralMapRegister,FloppyCurrentIOCB)	;   make ES:[DI] point at the Current iocb			LEA	SI, ES:[DI].fdcCommands				;   make ES:[SI] point to iocb^.fdcCommands[1]			MOV	AX, ES:[DI].CurrentFDCCommand			;			DEC	AX						;   make ES:[SI] point to			MOV	BL, SIZE(fdcCommandRecord)			;   the current fdcCommand			MUL	BL						;			ADD	SI, AX						;   SI ¬ SI + ( CurrentFDCCommand - 1 ) * SIZE(fdcCommandRecord)			MOV	AX, ES:[DI][BP].FirstDMAtransferCount			;   AX ¬ iocb^.FirstDMAtransferCount			JMP	SHORT	UpdateDataAddress			; END										; ELSENotFirstDMAInterrupt:	MOV	AX, ES:[DI][BP].MiddleDMAtransferCount		;   AX ¬ iocb^.MiddleDMAtransferCountUpdateDataAddress:	CMP	ES:[DI].IncrementDataPointer, MesaTRUE			JNE	NoDataPointerIncrement			CALL	UpdateAddress					; updates DataAddressNoDataPointerIncrement:			CALL	SetupDMApointers				; uses ES, DI, SI			CMP	FloppyNumberOfMiddleDMAtransfers, 0		; IF NumberOfMiddleDMAtransfers <= 0 THEN			JG	GottaMiddleTransfer				; BEGIN			MOV	FloppyWaitingForDMAInterrupt, MesaFALSE			MOV	AX, ES:[DI][BP].LastDMAtransferCount		;   FloppyDMATransferCount ¬ LastDMAtransferCount			MOV	CX, ES:[DI][BP].LastDMAcontrolWord		;   FloppyDMAControlWord ¬ LastDMAcontrolWord			JMP	SHORT DoTheOuts					; END										; ELSEGottaMiddleTransfer:								; BEGIN			DEC	FloppyNumberOfMiddleDMAtransfers		;   NumberOfMiddleDMAtransfers ¬ NumberOfMiddleDMAtransfers - 1			MOV	AX, ES:[DI][BP].MiddleDMAtransferCount		;   FloppyDMATransferCount ¬ MiddleDMAtransferCount			MOV	CX, ES:[DI][BP].MiddleDMAcontrolWord		;   FloppyDMAControlWord ¬ MiddleDMAcontrolWordDoTheOuts:			%OutputWord ( FloppyDMATransferCount,AX)			%OutputWord ( FloppyDMAControlWord,CX)EndOfMainDMALoop:								; END			JMP	BeginMainDMAloop;;;--------------------------------------------------------------------------------;;BadFDCInterrupt		PROC	FARBeginBadFDCInterrupt:	%EstablishHandlerAccess (FloppyHandlerID)			ASSUME ES:FloppyIOR			INC	ES:FloppyBadFDCInterruptCount			ASSUME ES:NOTHING			RETBadFDCInterrupt		ENDP;;;;--------------------------------------------------------------------------------;;;MainFloppyTask:		%ThisTaskServices (FloppyControllerInterrupt,BadFDCInterrupt)			MOV	FloppyTapeThisIOCB, MesaFALSE			; Clear it			CALL	InitializeFCB			MOV	AL, 0			CALL	AccessDrive			MOV	AH, 0FH			JC	IsADrive0			MOV	AH, 0EHIsADrive0:		CALL	ResetFlushSpecifyRecal			AND	[BX].SpecifyAndRecalFlags, AH			CALL	CheckDriveStatus			%Enable ( floppyControllerInterrupt )MainFloppyTaskLoop:			%WaitForCondition (OFFSET FloppyWorkNotify,1000)	;   wait for FloppyWorkNotify or Timeout			MOV	FloppyTapeThisIOCB, MesaFALSE			; Clear it			CALL	CheckDriveStatus				;   update DCB's in FCBLookForMoreWorkToDo:			CMP	FloppyStopHandler, MesaTRUE			;   IF FloppyStopHandler = TRUE THEN			JNE	HandlerIsRunning				;   BEGIN			MOV	FloppyHandlerIsStopped, MesaTRUE		;     FloppyHandlerIsStopped ¬ TRUE			%ControlRegister(MotorOffMask,0)			;     ReleaseDrives[]			MOV	FloppyDriveMotorControlCount, 0			JMP	SHORT	MainFloppyTaskLoop			;     GOTO MainFloppyTaskLoopHandlerIsRunning:								;   END			MOV	FloppyHandlerIsStopped, MesaFALSE		;   FloppyHandlerIsStopped ¬ FALSE			CMP	FloppyResetFDC, MesaTRUE			;   IF FloppyResetFDC THEN			JNE	SkipReset					;   BEGIN			MOV	AX, 0C00H					;     reset & flush only			CALL	ResetFlushSpecifyRecal			JNC	SkipReset			MOV	FloppyResetFDC, MesaFALSE			;     clear only on successSkipReset:									;   END			XOR	AX, AX			MOV	FloppyCurrentIOCB, AX						CMP	FloppyDiagnosticsOn, MesaTRUE			JNE	EndDiagnosticQueue						%JumpIfMesaIOCBNextNil (FloppyDiagnosticQueue.queueNext,EndDiagnosticQueue)	;IF Diagnostic MESA queueNext # NIL THEN {BeginDiagnosticQueue:	%ConvertAddress (FloppyDiagnosticQueue.queueNext)				; Convert MESA Virtual Address to an Extended Bus Address			CALL	ExecuteOperation							; ExecuteOperation			MOV     BX, OFFSET FloppyDiagnosticQueue.queueNext.OpieAddressLow		; Set ptr to queueNext			CALL	FloppyAdvanceMesaIOCB							; Next ¬ iocb^.NextIOCB			%NotifyClientCondition(ES:[DI].ActualClientCondition)				; notify client operation is done}EndDiagnosticQueue:				CMP	FloppyDiagnosticsOn, MesaTRUE			JNE	ContinueQ			JMP	SHORT End186QueueContinueQ:			%JumpIfMesaIOCBNextNil (FloppyPilotQueue.queueNext,EndMesaQueue)		;IF Floppy MESA queueNext # NIL THEN {BeginMesaQueue:		%ConvertAddress (FloppyPilotQueue.queueNext)					; Convert MESA Virtual Address to an Extended Bus Address			CALL	ExecuteOperation							; ExecuteOperation			MOV     BX, OFFSET FloppyPilotQueue.queueNext.OpieAddressLow			; Set ptr to queueNext			CALL	FloppyAdvanceMesaIOCB							; Next ¬ iocb^.NextIOCB			%NotifyClientCondition(ES:[DI].ActualClientCondition)				; notify client operation is done}			EndMesaQueue:		%JumpIfQueueNextNil (Floppy80186Queue,End186Queue)			;IF PC queueNext # NIL THEN {Begin186Queue:		%ConvertAddress (Floppy80186Queue.queueNext)				; Convert PC Address to an Extended Bus Address			CALL	ExecuteOperation						; ExecuteOperation			%AdvanceQueue (Floppy80186Queue,NextIOCB,mapped)			; Next ¬ iocb^.NextIOCB			%NotifyClientCondition(ES:[DI].ActualClientCondition)			; notify client operation is done}End186Queue:											;END			XOR	AX, AX			CMP	FloppyCurrentIOCB, AX			JE	QueuesAreEmpty			JMP	LookForMoreWorkToDoQueuesAreEmpty:		CMP	FloppyDriveMotorControlCount, AL			;   IF FloppyDriveMotorControlCount <= 0 THEN			JNE	LeaveMotorOn					;   BEGIN			%ControlRegister(MotorOffMask,AX)			;     Turn off MotorOn; deselect drives			JMP	MainFloppyTaskLoop				;   ENDLeaveMotorOn:									;   ELSE {			DEC	FloppyDriveMotorControlCount			%ControlRegister(ReleaseDrivesMask,AX)			;     deselect drives}			JMP	MainFloppyTaskLoop				; ENDLOOP;;;;;--------------------------------------------------------------------------------;;;	we are expecting an Extended Bus Address in CX-DX;	we are going to set;	ES:[DI] ¬ iocb;	ES:[SI] ¬ @iocb^.fdcCommands[iocb^.CurrentFDCCommand];;ExecuteOperation	PROCBeginExecuteOperation:			MOV	AL, MesaFALSE			MOV	FloppyWaitingForDMAInterrupt, AL 		;			MOV	FloppyTimeoutOccurred, AL			MOV	FloppyCurrentIOCB+2, CX				; save Extended Bus Address in FCB for DMAInterrupt task			MOV	FloppyCurrentIOCB, DX				; save Extended Bus Address in FCB for DMAInterrupt task			%EstablishIOPAccess(GeneralMapRegister,CX-DX)		; make ES:[DI] point to the current IOCB			XOR	AX, AX			MOV	ES:[DI].CurrentFDCCommand, AX			; iocb^.CurrentFDCCommand ¬ 0			MOV	ES:[DI].FinalDMACount, AX			; iocb^.FinalDMACount ¬ 0			LEA	SI, ES:[DI].firstTrack			MOV	ES:[SI].TotalBytesActuallyTransfered, AX			MOV	FloppyCurrentTrack, FirstTapeTrack			; in FCB for tape operations			MOV	BP, firstTrackOffset				;to allow access to dma control words etc by ES:[DI][BP].mumble			MOV	FloppyTrackOffset, firstTrackOffset						CMP	ES:[DI].OperationIsQueued, MesaTRUE		; IF NOT iocb^.OperationIsQueued			JNE	ToAJump						; THEN RETURN [ OperationFailed ]			CMP	ES:[DI].OperationState, OperationWaiting	; IF NOT iocb^.OperationState = OperationWaiting THEN			JNE	ToAJump						; THEN RETURN [ OperationFailed ]			MOV	ES:[DI].OperationState, OperationInProgress	; iocb^.OperationState ¬ OperationInProgress			CMP	ES:[DI].PCEResetFDCFlag, MesaTRUE		; IF iocb^.PCEResetFDCFlag THEN			JNE	NoPCEReset					; BEGIN			CALL	ResetTheFDC					;   CF ¬ ResetTheFDC[] ;			JNC	ToAJump						;   IF NOT CF THEN RETURN [ OperationFailed ]			MOV	ES:[DI].PCEResetFDCFlag, MesaFALSE			JMP	CompletedOperation				;   RETURN [ OperationCompleted ]										; ENDToAJump:		JMP	FailedOperationNoPCEReset:		MOV	AL, ES:[DI].PCEStartMotorFlags			CMP	AL, 0			JE	NoPCEStartMotor			CALL	GetDCBPointer					; BX ¬ @FloppyFCB^.FloppyDCB[AX]			MOV	AX, [BX].Port80ControlWord			; AX ¬ FloppyFCB^.FloppyDCB[AX].Port80ControlWord										; For tape, assume PCEStartMotorFlags never set			%ControlRegister(Port80Mask,AX)				; Port80 ¬ FloppyFCB^.FloppyDCB[AX].Port80ControlWord			MOV	FloppyDriveMotorControlCount, 3			; FloppyDriveMotorControlCount ¬ 3			MOV	ES:[DI].PCEStartMotorFlags, 0			JMP	CompletedOperationNoPCEStartMotor:			MOV	AL, ES:[DI].DaDriveNumber			;   AL ¬ iocb^.DaDriveNumber			CALL	AccessDrive					;   [CF, AH, BX] ¬ AccessDrive[DriveNumber : AL]			JNC	FailedOperation					;   IF NOT CF THEN RETURN [ OperationFailed ]									; First determine if there this operation is for the tape drive									; if so, do tape stream selection									; If there is a tape unit at the drive location in AL,									; then put MesaTRUE in FCB.FloppyThisIOCB, else leave MesaFALSE			MOV	FloppyTapeThisIOCB, MesaFALSE		; Reset to false			OR	SI, SI					; SI was set in CheckForTape in AccessDrive and is still valid			JZ	SkipStreamSelectTapeInThisIOCB:		MOV	FloppyTapeThisIOCB, MesaTRUE 		; put in FCB			CALL	StreamSelect				;SkipStreamSelect:	OR	AH, GetRFSRData					; tell proc AH is not complete			CALL	ResetFlushSpecifyRecal			JNC	FailedOperation			CMP	FloppyFDCHung, MesaTRUE				;   IF FloppyFDCHung			JE	FailedOperation					;   THEN RETURN [ OperationFailed ]						LEA	SI, ES:[DI].firstTrack			CALL	MoveIOCBParams				;Move iocb parameters to fcb for first track operation		BiggerMainLoop:		LEA	SI, ES:[DI].fdcCommands				;   make ES:[SI] point to iocb^.fdcCommands[1]MainLoop:		MOV	AX, ES:[DI].CurrentFDCCommand			;   load iocb^.CurrentFDCCommand			CMP	AX, ES:[DI].NumberOfFDCCommands			;   IF iocb^.CurrentFDCCommand >= iocb^.NumberOfFDCCommands			JGE	CompletedOperation				;   THEN GOTO CompletedOperation			INC	ES:[DI].CurrentFDCCommand			;   iocb^.CurrentFDCCommand ¬ iocb^.CurrentFDCCommand + 1			CALL	ExecuteFDCCommand				;   Execute CurrentFDCCommand - SI Points at it			JNC	FailedOperation					;   IF NOT CF THEN GOTO FailedOperation			ADD	SI, SIZE(fdcCommandRecord)			;   make SI point at next fdcCommand			JMP	SHORT	MainLoopFailedOperation:	MOV	ES:[DI].OperationState, OperationFailed		; iocb^.OperationState ¬ OperationFailed			JMP	FinishUpExecuteOp			JmpToComplete:		JMP	NowComplete					; This is done because NowComplete is more than 128 bytes away			CompletedOperation:								; Not complete until multiple tracks for tape handled.			CMP	FloppyTapeThisIOCB, MesaTRUE			; If not tape, then operation is indeed complete			JNE	JmpToComplete			CMP	FloppyCurrentTrack, LastTapeTrack			; If last track operation for tape already done, then entire operation is done.			JE	JmpToComplete						CMP	ES:[DI].NumberOfMiddleTrackTransfers, 0		; Look if middle track transfers already done			JE	LookforLastTrack			CMP	ES:[DI].tapeSelection, tapeOnStreamSelectFormat	; If doing format for tape, do special update			JNE	NextTrack					; Tape Format only uses First and Middle Track of IOCB			UpdateForFormat:	PUSH	BX			MOV	DX, ES:[DI].DataAddress			MOV	CX, ES:[DI].DataAddress+2			%EstablishIOPAccess(GeneralMapRegister,CX-DX)		; Make ES:[DI] point to header data.			XOR	BX, BX			MOV	CX, 32						; Loop count for number of sectors, hard coded!			MOV	AL, ES:[DI+BX]					; Get cylinder byte to update from header data(C, H, R, N)			INC	ALUpdateHeader:		MOV	ES:[DI+BX], AL			ADD	BX, 4			LOOP	UpdateHeader			POP	BX			%EstablishIOPAccess (GeneralMapRegister,FloppyCurrentIOCB)	; Make ES:[DI] point back to the Current iocb			JMP	SHORT NoIncrement				; Back to same code path			LookforLastTrack:	LEA	SI, ES:[DI].lastTrack			CMP	ES:[SI].TotalBytesToTransfer, 0			; If no last track operation, then get out.			JE	JmpToComplete					; A far jump		NextTrack:		MOV	AX, ES:[DI][BP].LastDMAtransferCount		; 			OR	AX, AX						; Test for zero			JNZ	CheckIncPtr			MOV	AX,ES:[DI][BP].FirstDMAtransferCount		; If LastDMA was zero and there is another track, then must update from FirstDMACheckIncPtr:		CMP	ES:[DI].IncrementDataPointer, MesaTRUE		; Update Data Address from LastDMA transfer 			JNE	NoIncrement			CALL	UpdateAddress					; updates DataAddressNoIncrement:									; Update cylinder and sector in fdc commands			MOV	CX, ES:[DI].NumberOfFDCCommands			; Loop for number of fdc commands			LEA	SI, ES:[DI].fdcCommands				; Make ES:[SI] point to iocb^.fdcCommands[1]UpdateFDCCommands:	MOV	AL, ES:[SI].NumberOfCommandBytes			CMP	AL, 6						; 6 is the number of command bytes in a Format command			JE	NoUpdate			MOV	Al, ES:[SI+2].CommandBytes 			; SI+2 gets third command byte, Cylinder ¬ Cylinder + 1			INC	Al			MOV	ES:[SI+2].CommandBytes, Al			MOV	ES:[SI+4].CommandBytes, 1			; SI+4 gets fifth command byte, Sector ¬ 1NoUpdate:		ADD	SI, SIZE(fdcCommandRecord)			;   make SI point at next fdcCommand			LOOP	UpdateFDCCommands			XOR	AX, AX						; Reset CurrentFDCCommands			MOV	ES:[DI].CurrentFDCCommand, AX			; iocb^.CurrentFDCCommand ¬ 0						CMP	ES:[DI].NumberOfMiddleTrackTransfers, AX	; Look for middle track transfers, AX is 0			JG	DoMiddleTracks						LEA	SI, ES:[DI].lastTrack			CMP	ES:[SI].TotalBytesToTransfer, 0			; If no last track operation, then done			JE	NowComplete			MOV	FloppyCurrentTrack, LastTapeTrack		; Doing last track operation.			MOV	BP, lastTrackOffset			MOV	FloppyTrackOffset, lastTrackOffset			CALL	MoveIOCBParams					; Update DMA parameters in FCB for last track operation			JMP	BiggerMainLoopDoMiddleTracks:		DEC	ES:[DI].NumberOfMiddleTrackTransfers		; Decrement			CMP	FloppyCurrentTrack, FirstTapeTrack		; If FirstTapeTrack, then first track already done			JNE	skipMoveMiddle					; If first time thru then need to set up params for middle track operations. 			MOV	FloppyCurrentTrack, MiddleTapeTracks			MOV	BP, middleTrackOffset			MOV	FloppyTrackOffset, middleTrackOffset			LEA	SI, ES:[DI].middleTrack			CALL	MoveIOCBParams					; Update DMA parameters in FCB for middle track operations			JMP	BiggerMainLoopskipMoveMiddle:		LEA	SI, ES:[DI].middleTrack				; Don't need to update all IOCB params, but			MOV	AX, ES:[SI].NumberOfMiddleDMAtransfers		; do need to reset FloppyNumberOfMiddleDMAtransfers			MOV	FloppyNumberOfMiddleDMAtransfers, AX			JMP	BiggerMainLoop				NowComplete:		MOV	ES:[DI].OperationState, OperationCompleted	; iocb^.OperationState ¬  OperationCompleted		FinishUpExecuteOp:	CALL	StopDMAandCounter			MOV	AL, FloppyFDCHung			MOV	ES:[DI].FDCHung, AL				; iocb^.FDCHung ¬ FloppyFCB^.FloppyFDCHung			MOV	AL, FloppyTimeoutOccurred			MOV	ES:[DI].TimeoutOccurred, AL			; iocb^.TimeoutOccurred ¬ FloppyFCB^.FloppyTimeoutOccurred			IN	AL, FDCStatusReg			MOV	ES:[DI].FinalStateOfFDC, AL			; iocb^.FinalStateOfFDC ¬ FDC Main Status Register			EndExecuteOperation:	RETExecuteOperation	ENDP;;;--------------------------------------------------------------------------------;;ExecuteFDCCommand	PROCBeginExecuteFDCCommand:	CALL	StopDMAandCounter			XOR	AL, AL			MOV	ES:[SI].NumberOfCommandBytesWritten, AL		; iocb^.fdcCommands[?].NumberOfCommandBytesWritten ¬ 0			MOV	ES:[SI].NumberOfResultBytesRead, AL		; iocb^.fdcCommands[?].NumberOfResultBytesReturned ¬ 0			MOV	AL, ES:[SI].DataTransferCode			; 			CMP	AL, Read					; IF iocb^.DataTransferCode = Read			JE	GottaSetupDMA					; 			CMP	AL, Write					; OR iocb^.DataTransferCode = Write			JE	GottaSetupDMA					; 			MOV	ES:[SI].DataTransferCode, None			JMP	SHORT	DontSetupDMA				; THEN BEGINGottaSetupDMA:		XOR	AX, AX			%OutputWord ( FloppyCountRegister,AX)				;   FloppyCountRegister ¬ 0			%OutputWord ( FloppyMaxCountB,AX)				;   FloppyMaxCountB ¬ 0			%OutputWord ( FloppyMaxCountA, ES:[DI][BP].TotalBytesToTransfer);  FloppyMaxCountA ¬ iocb^.TotalBytesToTransfer 			%OutputWord ( FloppyCounterControlWord, ES:[DI][BP].CounterControlRegister); FloppyCounterControlWord ¬ iocb^.CounterControlRegister			CALL	SetupDMApointers			%OutputWord ( FloppyDMATransferCount, ES:[DI][BP].FirstDMAtransferCount); FloppyDMATransferCount ¬ FirstDMAtransferCount			%OutputWord ( FloppyDMAControlWord, ES:[DI][BP].FirstDMAcontrolWord); FloppyDMAControlWord ¬ FirstDMAcontrolWordDontSetupDMA:									; END			PUSH	BP			XOR	BP, BP			XOR	CX, CX			ADD	CL, ES:[SI].NumberOfCommandBytes			JZ	FinishedWriteLoop				; top-check loop										; FOR i ¬ [0..iocb.NumberOfCommandBytes) DO BEGINWriteLoop:		MOV	AL, ES:[SI+BP].CommandBytes			;   AL ¬ iocb.CommandBytes[i]			CALL	WriteCommandByteToFDC				;   WriteCommandByteToFDC[AL]			JNC	RemoveBP				;   IF ReturnCode # TRUE THEN get out and RETURN FALSE			INC	ES:[SI].NumberOfCommandBytesWritten		;   iocb.NumberOfCommandBytesWritten++			INC	BP						;   i++			LOOP	WriteLoopFinishedWriteLoop:								; END			POP	BP			CMP	ES:[SI].MustWaitForInterrupt, MesaTRUE		; IF MustWaitForInterrupt THEN			JNE	SkipWaitForInterrupt				; BEGIN			CMP	ES:[SI].DataTransferCode, None			;   IF DataTransferCode # None			JE	NoDMAInterrupt			TEST	ES:[DI][BP].FirstDMAcontrolWord, 0100H		;   AND iocb^.FirstDMAcontrolWord.dmaInterruptWhenDone			JZ	NoDMAInterrupt					;   BEGIN			MOV	FloppyFirstDMAInterrupt, MesaTRUE		;     FloppyFirstDMAInterrupt ¬ TRUE			MOV	FloppyWaitingForDMAInterrupt, MesaTRUE		;     enable DMA interrupt handlerNoDMAInterrupt:									;   END			CALL	DoWaitForInterrupt				;(2/7/88)Put code in a subroutine so it can be called by recalibrate(ReadID) also						JNC	IsGoodInterrupt			MOV	FloppyTimeoutOccurred, MesaTRUECantExecuteFDCCommand:	CLC							; return code ¬ false			RET							; the reason this is here is cause conditional jumps										; can only reach +- 127 bytes, and placing it at the end is too farRemoveBP:		POP	BP			JMP 	CantExecuteFDCCommandIsGoodInterrupt:SkipWaitForInterrupt:								; END			CMP	ES:[SI].DataTransferCode, None			JE	SkipGetCountLeft			LEA	BX, ES:[DI].firstTrack			%InputWord ( FloppyCountRegister, ES:[BX].TotalBytesActuallyTransfered )			%InputWord ( FloppyDMATransferCount, ES:[DI].FinalDMACount )SkipGetCountLeft:			PUSH	BP			XOR	BP, BP			XOR	CX, CX			ADD	CL, ES:[SI].NumberOfResultBytes			JZ	FinishedReadLoopReadLoop:									; FOR i ¬ [1..iocb.NumberOfResultBytesExpected) DO BEGIN			CALL	ReadResultByteFromFDC				;   [CF, AL] ¬ ReadResultByteFromFDC[]			JNC	RemoveBP					;   IF NOT CF THEN RETURN FALSE			MOV	ES:[SI+BP].ResultBytes, AL			;   iocb^.ExpectedResultBytes[i] ¬ AL			INC	ES:[SI].NumberOfResultBytesRead			;   iocb^.NumberOfResultBytesReturned++			INC	BP			LOOP	ReadLoop					; ENDFinishedReadLoop:	POP	BP			XOR	CX, CX			MOV	CL, ES:[SI].fdcCode				; AX ¬ iocb^.fdcCommands[iocb^.CurrentFDCCommand].fdcCode			CMP	CL, 15			JG	NotOK		; Wait's already RET'd		; check for legal value			MOV	AX, CheckItArray				; load CheckItArray			SHL	AX, CL						; Shift appropriate bit into (CF)			SHL	AX, 1						; IF we gotta check this fdc code			JNC	AllOK						; BEGIN			MOV	AL, ES:[SI].ResultBytes				;   load ST0			AND	AL, 11000000B					;   only the two high bits are important			CMP	AL, 0						;   if either high bit is set			JNE	NotOK						;   we have failed			CMP	ES:[SI].DataTransferCode, None			;   IF no data xfer then skip next test			JE	AllOK			CMP	ES:[DI].FinalDMACount, 0			;   if data xfer & FinalDMACount <> 0 then trouble			JNE	NotOK			LEA	BX, ES:[DI].firstTrack			CMP	ES:[BX].TotalBytesActuallyTransfered, 0		;   0 => total success or total failure			JNE	NotOKAllOK:			STC							;   RETURN [ TRUE ]			RET										; ENDNotOK:			CLC							; RETURN [ FALSE ]			RET;CheckItArray	EQU	0111110111001011B;CheckItArray		DB	MesaFALSE		; NullCommand;			DB	MesaTRUE		; FormatTrack;			DB	MesaTRUE		; ReadData;			DB	MesaTRUE		; ReadDeletedData;			DB	MesaTRUE		; ReadID;			DB	MesaTRUE		; ReadTrack;			DB	MesaFALSE		; Recalibrate;			DB	MesaTRUE		; ScanEqual;			DB	MesaTRUE		; ScanHighOrEqual;			DB	MesaTRUE		; ScanLowOrEqual;			DB	MesaFALSE		; Seek;			DB	MesaFALSE		; SenseDriveStatus;			DB	MesaTRUE		; SenseInterruptStatus;			DB	MesaFALSE		; Specify;			DB	MesaTRUE		; WriteData;			DB	MesaTRUE		; WriteDeletedData;ExecuteFDCCommand	ENDP;;;;--------------------------------------------------------------------------------;			support subroutines;--------------------------------------------------------------------------------;;;AccessDrive		PROC						; [CF, AH, BX] ¬ AccessDrive[DriveNumber : AL]			XOR	AH, AH			PUSH	AX					; Save AX			CALL	GetDCBPointer				; BX ¬ GetDCBPointer[AX]			POP	AX			CMP	[BX].DeviceAttributes, NoDiskDrive	; FloppyDCB[AX].DeviceAttributes.type = nullType			JNE	aValidDrive			CLC						; RETURN [ FALSE ]			RETaValidDrive:		PUSH	AX					; Save AX			%ControlRegister(0,AX)				; AX ¬ Port80			MOV	DX, AX					; save Port80 in DX			POP	AX					; Get drive number in AX			PUSH	AX					; Save again			INC	AL			MOV	CX, AX					; Put drive number + 1 in CX			MOV	AX, [BX].Port80ControlWord		; The head has set the right drive select bit			XOR	SI, SI					; Clear SI			CALL	CheckForTape			JNC	WritePort				; Jump if not tape drive 			INC	SI					; Set a flag for tape			%ControlRegister(Port80MaskMinusDrive,AX)	; Drive select lines are unchanged for tape			JMP	SHORT AfterWriteWritePort:		%ControlRegister(Port80Mask,AX)				; Port80 ¬ FloppyDCB[BX].Port80ControlWordAfterWrite:		XOR	DX, AX						; compare old DataRate bit with new			POP	AX			AND	DX, SpeedChangeMask			JE	NoSpeedChange					; did Select250KbDataRate bit change?			MOV	AH, 0FH						; yes, do an RFSR			NoSpeedChange:		OR	SI, SI					; Test flag for tape			JNZ	TheMotorIsOn				; If tape, skip the wait.			CMP	FloppyDriveMotorControlCount, 0			; IF FloppyDriveMotorControlCount <= 0 THEN			JG	TheMotorIsOn					; BEGIN			PUSHA			%WaitForTime ( 500 )					;   wait a half a sec			POPATheMotorIsOn:		MOV	FloppyDriveMotorControlCount, 3			; FloppyDriveMotorControlCount ¬ 3			STC							; RETURN [ TRUE ]			RETAccessDrive		ENDP;;;--------------------------------------------------------------------------------; This routine was made into a subroutine to save bytes.  It was used only in ExecuteFDCCommand, now used in ResetFlushSpecifyRecal also.DoWaitForInterrupt	PROCBeginDoWaitForInterrupt:			%PushDISI						; save context			PUSH	BP			CMP	FloppyTapeThisIOCB, MesaTRUE			JE	LongerTimeout			%WaitForInterrupt	(2)				;   wait till FDC yells			JMP	SHORT AfterInterruptLongerTimeout:		%WaitForInterrupt	(180)				; For tape, allow 180 seconds before a timeoutAfterInterrupt:		MOV	FloppyWaitingForDMAInterrupt, MesaFALSE		;   disable DMA interrupt handler			POP	BP						; restore context			%PopDISI			RETDoWaitForInterrupt	ENDP;;;--------------------------------------------------------------------------------; Tape Drive and Stream Selection; Called only if current IOCB is a tape operation.  The head requests either a simple; drive selection or a drive selection with a stream selection.  If called by ; the Format Tape routine, then an additional format pulse is added to the ; stream selection.; Preserves all registers.;StreamSelect		PROCBeginStreamSelect:	PUSH	BX					; Save registers			PUSH	AX			MOV	BL, ES:[DI].tapeSelection		; tapeSelection = {noSelect, tapeOn, tapeOnStreamSelection, tapeOnStreamSelectFormat}			CMP	BL, noSelect				; if noSelect, return			JE	AllDone					; otherwise, select the drive			CMP	BL, tapeOn				; But, if not tapeOn, then there is a stream select, so do a delay			JE	SelectDrive			PUSHA			MOV	AX, 2600				; Wangtek changed spec from 2.0 to 2.5, so now(7-25-88) put at 2.6			%WaitForTime (AX)				; Wait 2.6 seconds before doing a new stream select			POPASelectDrive:		CLI						; Clear interrupts so strobe select is uninterrupted.			MOV	CL, ES:[DI].DaDriveNumber		; CL ¬ iocb^.DaDriveNumber			MOV	AX, CRDriveSel0 			; CRDriveSel0 EQU 0010H			SHL	AX, CL					; 			%ControlRegister(SelectDrivesMask,AX)		; Select drive 			CMP	BL, tapeOn				; if tapeSelection is tapeOn, then return since drive is selected			JE	AllDone					; otherwise, do stream selection			MOV	BH, ES:[DI].stream			; get desired stream numberToggleMotorOn:		MOV	CX, 20					; loop count of 50us			CALL	DelayAndToggle				; sets and resets MotorOn line					DEC	BH			OR	BH, BH					; Test for zero			JNZ	ToggleMotorOn			CMP	BL, tapeOnStreamSelect			JE	AllDone					; If tapeOnStreamSelect, then return since the stream was selected									; otherwise will continue with a Format pulse.			MOV	CX, 76					; loop count for 160us			CALL	DelayAndToggle			AllDone:		STI						; Restore interrupts			POP	AX					; Restore registers			POP	BX			RETStreamSelect		ENDP			;;--------------------------------------------------------------------------------; FloppyAdvanceMesaIOCB is used to replace AdvanceMesaIOCB which has a queueing bug.;  It is implemented as a subroutine instead of a macro to save prom space.;; BX should contain a ptr to the next iocb address of the queue.;  All other parameters are hardwired, (NextIOCB,FloppyLockMask,mapped,FloppyQueueSemaphore)FloppyAdvanceMesaIOCB	PROC			PUSH	BX				; Save next iocb address Lbl2: 			CLI			MOV	BX, OFFSET FloppyQueueSemaphore			MOV	CX, FloppyLockMask 			%MesaLockedOut	(XCHG, BX, 1, CX)			OR	AX, AX			JZ	Lbl1			%WaitForSystem			JMP	SHORT Lbl2			Lbl1:			POP	BX			MOV	AX, ES:[DI].NextIOCB.OpieAddressLow			MOV	CX, FloppyLockMaskLbl4:			%MesaLockedOut	(MOV,BX,AX,CX)			OR	AX, AX			JNZ	Lbl3			MOV	AX, ES:[DI].NextIOCB.OpieAddressLow			OR	AX, AX			JNZ	Lbl4Lbl3:			MOV	FloppyQueueSemaphore, 0			STI			RETFloppyAdvanceMesaIOCB	ENDP;						;--------------------------------------------------------------------------------; GetDCBPointer is a subroutine converted from a macro to save several bytes of code space.; The drive number is expected in AL and the DCB ptr is returned in BX.GetDCBPointer		PROCBeginGetDCBPointer:	AND	AL, 3H			MOV	BL, SIZE(DeviceContextBlock)			MUL	BL			MOV	BX, OFFSET FloppyDCB0			ADD	BX, AX			RETGetDCBPointer		ENDP		       ;;						;--------------------------------------------------------------------------------;UpdateAddress is a subroutine made to save 4 bytes of code;  AX set before callUpdateAddress		PROCBeginUpdateAddress:	SHR	AX, 1			ADD	ES:[DI].DataAddress, AX				; iocb^.DataAddress ¬ iocb^.DataAddress + AX			ADC	ES:[DI].DataAddress+2, 0			RETUpdateAddress		ENDP;									;--------------------------------------------------------------------------------; CX should hold initial loop count,; The MotorOn line is set after the specified delay then reset after 50usDelayAndToggle		PROCBeginDelayAndToggle:	MOV	AX, MotorOnMaskWaitXus:		LOOP	WaitXus			%ControlRegister(MotorOnMask, AX)		; set MotorOn bit			MOV	CX, 20					; loop count for 50 us			XOR	AX, AX					; AX ¬ 0Wait50us:		LOOP	Wait50us			%ControlRegister(MotorOnMask, AX)		; reset MotorOn bit			RETDelayAndToggle		ENDP			;--------------------------------------------------------------------------------;;  SMASHES AX, CX, DX, BP; Samples 3, then 2, then 1, finally 0.  Uses CL to count down, CL = drivenum + 1; Turns off all drives at the end of the loop;CheckDriveStatus	PROCBeginCheckDriveStatus:	PUSH	BX					; store BX			IN	AL, FDCStatusReg				; check status of FDC			AND	AL, 00001111B					; if any drive seeking,			JNZ	EndCheckDriveStatus				; don't disturb it			MOV	CX, 4			MOV	BP, OFFSET FloppyDCB3CheckDriveStatusLoop:	MOV	AX, CRDriveSel0 SHR 1			;  CRDriveSel0 EQU 0010H			SHL	AX, CL			MOV	DX, CX					;   Save CX			CALL	CheckForTape				; CX holds drive number + 1, result in CF, CX preserved			JC	skipThisCheckDrive			; If tape drive, don't select drive			%ControlRegister(SelectDrivesMask,AX)			MOV	CX, DX					;   Restore CX			MOV	AL, fdcSenseDriveStatusCommand			CALL	WriteCommandByteToFDC			JNC	EndCheckDriveStatus			MOV	AL, CL			DEC	AL					; AL ¬ 4 - CL ?  Looks more like AL ¬ CL - 1			CALL	WriteCommandByteToFDC			JNC	EndCheckDriveStatus			CALL	ReadResultByteFromFDC			JNC	EndCheckDriveStatus			MOV	DS:[BP].DriveStatusHead0, AL			JMP	SHORT NextDCBskipThisCheckDrive:	OR	DS:[BP].DriveStatusHead0, 20H		; Sets the ready bit to 1NextDCB:		SUB	BP, SIZE(DeviceContextBlock)			LOOP	CheckDriveStatusLoopEndCheckDriveStatus:	POP	BX					; Restore BX			%ControlRegister(ReleaseDrivesMask,0)			RETCheckDriveStatus	ENDP;;;;--------------------------------------------------------------------------------;;	This procedure used to determine if there is a tape drive connected at ;	the drive location specified in CL.  CL should contain a number between 1 and 4,;	which corresponds to the drive number + 1.;	IF true, then the Carry Flag is set, otherwise CF is reset.;	AX and CX preserved.  BX trashed.CheckForTape		PROC			PUSH	CX			PUSH	BX			PUSH	AX			MOV	BX, FloppyEncodedDeviceTypes		; Get eeprom contents			XCHG	BH, BL					; Byte swap so the order becomes 0123			MOV	AX, 4					; (4-CL)*4 = number to shift right			SUB	AL, CL			SHL 	AL, 2					; *4			MOV	CL, AL					; CL holds the number calculated for shifting BX			SHR	BX, CL			AND	BL, 0FH					; Look at least significant 4 bits			CMP	BL, wangtek250TapeDrive			JE	SetTrue			CMP	BL, wangtek500TapeDrive			JE	SetTrue						CLC						; Not a tape unit			JMP	SHORT CheckDone			SetTrue:		STC						; Is a tape unitCheckDone:		POP	AX			POP	BX			POP	CX			RETCheckForTape		ENDP;;--------------------------------------------------------------------------------			;;FlushTheFDC		PROC							; takes no args, preserves all regs			PUSH	AX			XOR	CX,CXClearFDCloop:			MOV	AL, 08H			CALL	WriteCommandByteToFDC			JNC	CantClearFDC			CALL	ReadResultByteFromFDC			JNC	CantClearFDC			CMP	AL, 080H					;Empty? Invalid Commad?			JE	ClearedFDC			CALL	ReadResultByteFromFDC				;Read PCN			JNC	CantClearFDC			LOOP	ClearFDCloop					;loop till done or timeoutCantClearFDC:		CLC							; RETURN FALSE			POP	AX			RETClearedFDC:		STC			POP	AX			RETFlushTheFDC		ENDP;;--------------------------------------------------------------------------------;;;InitializeFCB		PROC							; assumes that the FCB has been zeroedBeginInitializeFCB:			MOV	FloppyFillerByteForFormatting, FillerByteForFormatting			%ReadEEProm(eePromFloppy,1)			JNC	GoodEEPROM			MOV	AX, (sa455DiskDrive SHL 12)			; default one sa455 drive hooked to drive zeroGoodEEPROM:		XCHG	AH, AL			MOV	DX, AX						; save device types in DX			MOV	FloppyEncodedDeviceTypes, AX			%GetWorkMaskForCondition(OFFSET FloppyWorkNotify)	; FloppyWorkMask ¬ GetWorkMask			MOV	FloppyWorkMask, AX			%GetLockMask						; LockMask ¬ GetLockMask			MOV	FloppyLockMask, AX			MOV	AX, DX						; reload AX (saves bytes)			SHR	AX, 4						; move drive 0 info to low nybble			AND	AL, 0Fh			CMP	AL, sa455DiskDrive			JE	SetupForSA455			CMP	AL, sa475DiskDrive			JE	SetupForsa475					;no set up needed for tape drives?			CMP	AL, wangtek250TapeDrive			JE	SetupForWangtek250			CMP	AL, wangtek500TapeDrive			JE	SetupForWangtek500			JMP	SHORT	EndInitializeFCBSetupForSA455:		MOV	DX, sa455onDriveZero			MOV	CL, sa455StepRateTimePlusHeadUnloadTime			MOV	CH, sa455HeadLoadTimePlusNotInDMAmode			JMP	SHORT InitDCBsSetupForsa475:		MOV	DX, sa475onDriveZero			MOV	CL, sa475StepRateTimePlusHeadUnloadTime			MOV	CH, sa475HeadLoadTimePlusNotInDMAmode			JMP	SHORT InitDCBs			SetupForWangtek250:	MOV	DX, wangtek250Port80ControlWord			JMP	SHORT MoreWangtekParams			SetupForWangtek500:	MOV	DX, wangtek500Port80ControlWordMoreWangtekParams:	MOV	CL, wangtekStepRateTimePlusHeadUnloadTime			MOV	CH, wangtekHeadLoadTimePlusNotInDMAmodeInitDCBs:		MOV	FloppyDCB0.Port80ControlWord, DX			MOV	WORD PTR FloppyDCB0.StepRateTimePlusHeadUnloadTime, CX			MOV	FloppyDCB0.DeviceAttributes, AX  ; kludge to make booting think something is thereEndInitializeFCB:	RETInitializeFCB		ENDP;;;;--------------------------------------------------------------------------------;;;MoveIOCBParams		PROCBeginMoveIOCBParams:	MOV	AX, ES:[SI].NumberOfMiddleDMAtransfers			MOV	FloppyNumberOfMiddleDMAtransfers, AX			RETMoveIOCBParams		ENDP;;--------------------------------------------------------------------------------;ReadResultByteFromFDC	PROCBeginReadResultByte:	PUSH	CX						; save CX			CMP	FloppyTapeThisIOCB, MesaTRUE			JE	ShortRdDelay			%LongDelay			JMP	SHORT SetCounter			ShortRdDelay:		MOV	CX, 12						; 20-30 us delayWait20us:		LOOP	Wait20us			SetCounter:		MOV 	CX, 040						; max of 40 tries to Read Main Status RegisterReadyToReadLoop:	IN	AL, FDCStatusReg				; Read Main Status Register			CMP	AL, 11000000B					; we only want to look at RequestForMaster and DataInputOutput			JAE	ReadyToRead					; is FDC ready to return a ResultByte ?			LOOP 	ReadyToReadLoop					; loop till done or timeout										; timeoutReadError:		POP	CX						; restore CX			CLC							; return code ¬ false			MOV	FloppyFDCHung, MesaTRUE			RET							; RETURN [ FALSE ]ReadyToRead:		POP	CX						; restore CX			STC							; return code ¬ true			IN	AL, FDCDataReg					; Read byte into AL			RET							; RETURN [ TRUE ]ReadResultByteFromFDC	ENDP;;;;--------------------------------------------------------------------------------;;;RecalibrateDrive	PROC							; takes drive number in ALBeginRecalibrateDrive:	PUSH	AX						; all registers preserved			MOV	AL, fdcRecalibrateCommand			CALL	WriteCommandByteToFDC			POP	AX						; restore AL			JNC	EndRecalibrateDrive			CALL	WriteCommandByteToFDC			JNC	EndRecalibrateDrive			PUSHA			%WaitForInterrupt	(2)				; wait till FDC hollers			POPA			PUSH	AX			JC	RecalTimedOut			MOV	AL, fdcSenseInterruptStatusCommand			CALL	WriteCommandByteToFDC			JNC	RecalExit			CALL	ReadResultByteFromFDC			JNC	RecalExit			MOV	AH, AL			CALL	ReadResultByteFromFDC			JNC	RecalExit			TEST	AH, 11000000B			JNE	RecalFailedRecalSucceeded:		STC			POP	AX			RET							; RETURN [ TRUE ]RecalTimedOut:		MOV	FloppyTimeoutOccurred, MesaTRUERecalFailed:		CLCRecalExit:		POP	AXEndRecalibrateDrive:	RET							; RETURN [ FALSE ]RecalibrateDrive	ENDP;;;;--------------------------------------------------------------------------------;;;ResetFlushSpecifyRecal	PROCResetAndFlushLabel:	TEST	AH, GetRFSRData			JZ	DataInAH			ROR	AH, 2				; preserve AH			OR	AH, ES:[DI].ResetAndFlushFlag			ROL	AH, 1			OR	AH, ES:[DI].SpecifyFlag			ROL	AH, 1			OR	AH, ES:[DI].RecalFlag			OR	AH, [BX].SpecifyAndRecalFlagsDataInAH:		TEST	AH, ResetAndFlushBit			JZ	SpecifyLabel			CALL	ResetTheFDC			JNC	FailedRFSR;			XOR	AH, ResetBit;;FlushLabel:		TEST	AH, FlushBit;			JZ	SpecifyLabel			CALL	FlushTheFDC			JNC	FailedRFSR			XOR	AH, ResetAndFlushBitSpecifyLabel:		TEST	AH, SpecifyBit			JZ	RecalLabel			CALL	SpecifyForDrive			JNC	FailedRFSR			XOR	AH, SpecifyBitRecalLabel:		TEST	AH, RecalBit			; Recal only called when there is an IOCB			JZ	FinishedRFSR			XOR	CX, CX			INC	CX			CMP	FloppyTapeThisIOCB, MesaTRUE			JNE	DoRecal			MOV	CX, 4				; For tape, recalibrate is done 4 timesDoRecal:		CALL	RecalibrateDrive			LOOP	DoRecal				; (2/7/88)Loop first, JNC after 			JNC	FailedRFSR						CMP	FloppyTapeThisIOCB, MesaTRUE			JNE	DontDoReadID			PUSHA					;let's give the tape a little time to start moving.  2 sec should			%WaitForTime(2000)			;be enough even if the drive was repositioning from the last retry.			MOV	AL, fdcTapeReadIDCommand	; (2/7/88)Adding a Read ID after recal to prevent tape			CALL	WriteCommandByteToFDC		; motor from turning off.			POPA			JNC	FailedReadID			CALL	WriteCommandByteToFDC			JNC	FailedReadID			PUSHA			CALL	DoWaitForInterrupt			POPA			MOV	CX, 7DoReadResult:		CALL	ReadResultByteFromFDC		; (2/7/88)Just read 7 byte to clear controller, ignore errors.			JNC	FailedReadID				LOOP	DoReadResult		FailedReadID:							; (2/7/88)A readID fail, doesn't cause RFSR to fail.DontDoReadID:			XOR	AH, RecalBitFinishedRFSR:		STCCompleteRFSR:		PUSHF			TEST	AH, GetRFSRData					; clear bits in memory?			JZ	OuttaHere			AND	[BX].SpecifyAndRecalFlags, AH			AND	ES:[DI].RecalFlag, AH			ROR	AH, 1			AND	ES:[DI].SpecifyFlag, AH			ROR	AH, 1			AND	ES:[DI].ResetAndFlushFlag, AH	; destroys AH iff high bit onOuttaHere:		POPF			RETFailedRFSR:		CLC			JMP	SHORT CompleteRFSRResetFlushSpecifyRecal	ENDP;;;;--------------------------------------------------------------------------------;;;ResetTheFDC		PROCBeginResetTheFDC:	PUSHA							; SaveContext !!!!			%Enable ( floppyControllerInterrupt )			%DisableInterruptsTillNextWait				; make sure we catch the interrupt			CALL	StopDMAandCounter			MOV	AL, 03H			MOV	FloppyDCB0.SpecifyAndRecalFlags, AL			MOV	FloppyDCB1.SpecifyAndRecalFlags, AL			MOV	FloppyDCB2.SpecifyAndRecalFlags, AL			MOV	FloppyDCB3.SpecifyAndRecalFlags, AL			%Reset ( resetFloppyController )			; gently tap chip with sledge hammer			%WaitForInterrupt	(2)				; enable interrupts and catch the FDC yelling			JNC	GotResetInterrupt			MOV	FloppyTimeoutOccurred, MesaTRUE			CLC			POPA			RETGotResetInterrupt:	MOV	FloppyFDCHung, MesaFALSE			; clear FDCHung status			MOV	FloppyTimeoutOccurred, MesaFALSE			STCEndResetTheFDC:		POPA							; RestoreContext !!!!			RETResetTheFDC		ENDP;;;;--------------------------------------------------------------------------------;  Looks at ES:[SI].DataTransferCode for transfer direction; Smashes AX, BX, CX, DX, BP; internal variables:  ;   BX = dma port which gets data address bits 15-0;   BP = dma port which gets FDC address bits 15-0;   AX = actual data address bits 15-0;   CX = actual data address bits 19-16; Notes:;  can't use AX, CX, DX, ES, or DI to hold dma port because they get;    smashed by EstablishIOPAccess;  assumes that dma ports for high addresses = dma ports of low addresses + 2;  assumes that ES:[SI] points to fdcCommands[CurrentFDCCommand]SetupDMApointers	proc	near			push	ES			push	DI			PUSH	BP			mov	AL, ES:[SI].DataTransferCode 			cmp	AL, Write			je	SetupForWriteSetupForRead:			mov	BX, FloppyDMALowDestPtr		; data is dest			mov	BP, FloppyDMALowSourcePtr	; FDC is source			jmp	SHORT SetupRegsSetupForWrite:			mov	BX, FloppyDMALowSourcePtr	; data is source			mov	BP, FloppyDMALowDestPtr		; FDC is destSetupRegs:			%EstablishIOPAccess (floppyDMAMapRegister,ES:[DI].DataAddress)	; set ES:[DI] to access DataAddress			mov	AX, ES			rol	AX, 4		; put data address bits where we want them			mov	CX, AX		; save bits 19-16 in low nybble of CX			and	AX, 0FFF0h	; make AX a paragraph number			add	AX, DI		; AX = bits 15-0 of data address			adc	CL, 0		; inc CX if necessary.  CX = data bits 19-16;;			mov	AX, AX		; data address 15-0			mov	DX, BX		; goes to data port low word			out	DX,AX;			mov	AX, CX		; high address of data			inc	DX			inc	DX		; goes to data port high word  			out	DX,AX;			mov	AX, FDCtoDMAport ; FDC address			mov	DX, BP		; goes to FDC port			out	DX,AX;			xor	AX, AX		; FDC high is 0			inc	DX			inc	DX		; goes to FDC high port			out	DX,AX;			POP	BP			pop	DI			pop	ES			retSetupDMApointers	endp;;;;--------------------------------------------------------------------------------;;;SpecifyForDrive		PROC							; BX points at the DCB			PUSH	AX			MOV	AL, fdcSpecifyCommand			CALL	WriteCommandByteToFDC			JNC	EndSpecifyForDrive			MOV	AL, [BX].StepRateTimePlusHeadUnloadTime			CALL	WriteCommandByteToFDC				; write SRT+HUT to FDC			JNC	EndSpecifyForDrive			MOV	AL, [BX].HeadLoadTimePlusNotInDMAmode			CALL	WriteCommandByteToFDC				; write HLT+NDMA to FDCEndSpecifyForDrive:	POP	AX			RETSpecifyForDrive		ENDP;;;;--------------------------------------------------------------------------------;;;StopDMAandCounter	PROC							; destroys AX & DXBeginStopDMAandCounter: MOV	AL, MesaFALSE			MOV	FloppyWaitingForDMAInterrupt, AL			MOV	FloppyFirstDMAInterrupt, AL			%OutputWord ( FloppyDMAControlWord, StopDMA )		; FloppyDMAControlWord ¬ StopDMA			%OutputWord ( FloppyCounterControlWord, StopCounter )	; FloppyCounterControlWord ¬ StopCounter			XOR	AX, AX			%OutputWord ( FloppyDMATransferCount,AX)		; FloppyDMATransferCount ¬ 0			%OutputWord ( FloppyCountRegister,AX)			; FloppyCountRegister ¬ 0EndStopDMAandCounter:	RETStopDMAandCounter	ENDP;;;--------------------------------------------------------------------------------;;WriteCommandByteToFDC	PROC							; writes AL to FDC, all registers preservedBeginWriteCommandByte:	PUSH	AX						; save AX			PUSH	CX						; save CX			CMP	FloppyTapeThisIOCB, MesaTRUE			JE	ShortWrDelay			%LongDelay						; the FDC will choke if you feed it too fast			JMP	SHORT SetbCounterShortWrDelay:		MOV	CX, 12						; 20-30 us delayWaitb20us:		LOOP	Waitb20us			SetbCounter:		MOV 	CX, 040						; max of 40 tries to Read Main Status RegisterReadyToWriteLoop:	IN	AL, FDCStatusReg				; Read Main Status Register			AND	AL, 11000000B					; we only want to look at RequestForMaster and DataInputOutput			CMP	AL, 10000000B					; wait for data request			JE	ReadyToWrite					; is FDC ready for CommandByte ?			LOOP 	ReadyToWriteLoop				; loop till done or timeoutWriteError:		POP	CX						; restore AX			POP	AX						; restore CX			MOV	FloppyFDCHung, MesaTRUE			CLC			RET							; RETURN [ FALSE ]ReadyToWrite:		POP	CX						; restore AX			POP	AX						; restore CX			%DisableInterruptsTillNextWait				; play it safe			OUT	FDCDataReg, AL					; write byte from AL			STC			RET							; RETURN [ TRUE ]WriteCommandByteToFDC	ENDP;;;;--------------------------------------------------------------------------------;;IOPEInRom		ENDS;;;		end of FloppyHandlerDove			END
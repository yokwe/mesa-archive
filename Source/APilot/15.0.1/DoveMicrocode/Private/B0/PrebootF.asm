$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1985 by Xerox Corporation. All rights reserved.;;Last edited by:; -- JAC/kek	11-Sep-85 15:22:29	;remove mode byte (inited in booting); -- STC	 6-Sep-85 15:53:33	;Remove CleanFloppyHead, KbdHandler.; -- JPM	 5-Aug-85 12:42:27	;Activate EEProm test.; -- JPM	22-Jul-85  9:54:51	;Change IOPEInROM alignment to WORD.; -- JPM	19-Jul-85 11:59:28	;Opie redesign conversion: added prebootSwitches and code (in VerifyEEProm) to set dontTrustEEProm bit.; -- KEK	14-Jun-85 13:44:44	;added segment reg init code from PreBindw.; -- KEK/JMM	 6-Jun-85 10:39:00	;add ETCH 111/122 comment, remove IOPLRAM include and get public Boot variables, replace "data" segment with common IOPLocalRam segment, extrn bootType, set = 0H. delete StartCode segment.; -- KEK	 3-Jun-85 18:09:34	;i8259Mas* defs get replaced by i8259Master defs from Opie's HardDefs.asm.   public label InitDove...etc;; stored as [Iris]<WMicro>Dove>PrebootF.asm    21-May-85 14:07:11;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;Contingencies/Problems:;	186Timer2:;		Needs register tests since instruction timer varried.;	EPROM checksum ;		The checksum to be done in bytes (same as Checksum.mesa);		Last byte - 1 _ Check sum;		Last byte _ Ones complement of Check sum;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;The LED indications are as follows:;	000= Lead test/visible for 1/2 seconds. FRU= IOP;	111= Lead test/visible for 1/2 seconds. FRU= IOP.;	110= EPROM test. FRU= EPROM, IOP.;	101= RAM test. FRU=  IOP;	100= Interrupts and IOP Keyboard logic test. FRU= IOP.;	011= keyboard test. FRU= Keyboard, IOP;	010= EEPROM test. FRU= EEPROM, IOP;	001= HostID-PROM test. FRU= HostID-PROM, IOP;	000= Successful completion;;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~$TITLE		(Preboot Diagnostics)NAME		 PrebootF$NOLIST		$INCLUDE	(IOPDefs.asm)$INCLUDE	(HardDefs.asm)$LIST;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;-- DATA SEGMENT IOPELocalRam	SEGMENT	AT 0;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~EXTRN		prebootSwitches: WORDEXTRN		bootType: BYTEEXTRN		device: WORD, bootRetryCount: WORD;EXTRN		cleanFloppyHeadsPROC: WORDEmptyStack	EQU	0400H;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;;Floppy parametersMotorOnInUse	EQU  3000hSpeed		EQU  0400hDrive		EQU  0010hDataRate	EQU  0008hPreComp		EQU  0002h;EnableKeyboardLoopback	 EQU  4000h		;enable Keyboard LoopbackDiagLEDsTo0	EQU  000h			;front panel leds to 0DiagLEDsTo1	EQU  400h			;front panel leds to 1DiagLEDsTo2	EQU  200h			;front panel leds to 2DiagLEDsTo3	EQU  600h			;front panel leds to 3DiagLEDsTo4	EQU  100h			;front panel leds to 4DiagLEDsTo5	EQU  500h			;front panel leds to 5DiagLEDsTo6	EQU  300h			;front panel leds to 6DiagLEDsTo7	EQU  700h			;front panel leds to 7;ControlReg	EQU  902h		;Control register (page 13)ErrFlag1	EQU  904h		;0= no err, 1= err detectedTimerIntrCnt	EQU  906h		;used to hold 186 timer 2 countTimerCnt	EQU  908h		;used to hold 186 timer 2 count;fdcCylinder	EQU  910h		;Floppy Disk Cylinder for head cleaning;MouseCoorFlg	EQU  920h		;Mouse Coordinate FlagStopModeFlg	EQU  921h		;FunctionKey	EQU  922h		;MouseCoorCnt	EQU  923h		;0= no err, 1= err detectedKeyDwnBuffHasChar EQU  924h		;MouseCoorTimes	EQU  925h		;;DisplayValue	EQU  928h;ErrCallSave	EQU  92Ah		;storing ErrTone Caller's IP;KeyDwnBuff	EQU  940h		;buffer is of 0C0h sizeDataBuff	EQU  1000h		;100h Data buffer for temp storage;dontTrustEEProm	EQU  8000H		;results of EEProm test in prebootSwitches;IOPELocalRam	ENDS;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;--CODE SEGMENTIOPEInROM		SEGMENT	WORD PUBLIC	ASSUME	CS:IOPEInROM, DS:IOPELocalRam			PUBLIC	InitDove;PUBLIC	CleanFloppyHeadsEXTRN	InitDebug: FAREXTRN	ReadEEProm: NEAR						;InitDove	LABEL	FAR						;		MOV  DX, LMCSaddr		;Program lower memory		MOV  AX, LMCSvalue		; (RAM) chip select		OUT  DX, AX			;						;		MOV  DX, MMCSaddr		;Program middle memory		MOV  AX, MMCSvalue		;This is a two step process.		OUT  DX, AX			; First, base address programming.						;		MOV  DX, MPCSaddr		;Then, size of each select.		MOV  AX, MPCSvalue		;		OUT  DX, AX			;						; 		MOV  DX, PACSaddr		;Program peripheral chip select		MOV  AX, PACSvalue		;		OUT  DX, AX			;						;;		MOV  AL, 0AH		;value for ETCH ONE!!!	        MOV  AL, 05H		;value for ETCH 122/B0!!!		MOV  DX, daybreakMapIOAddressIOPBase;		OUT  DX, AL			;So its programmed to something.						;		MOV  DX, i186RelocationRegAddr	;Setup internal interrupt		MOV  AX, i186RelocationRegvalue	;  controller mode bits		OUT  DX, AX			;  Using iRMX mode						;; Segment registers are set up after the following diagnostic code has run.; Refer to GoToBooting, where the tests are completed.;		~~~~~~~~~~~~~~~~;		* 000 LED test *;		~~~~~~~~~~~~~~~~Start:		MOV  AX, 010h			;Enable debugger		OUT  WriteResetReg, AX		;Reset everything else;		MOV  DS:WORD PTR DisplayValue, 0;		MOV  DS:WORD PTR ErrCallSave, 0		MOV  AX, CRNotBlockSysMem	;Enable system memory		OUT  WriteCtlReg, AX		;		MOV  AX, DiagLEDsTo0		; 		OUT  WriteConfigReg, AX		;Output 000 to front panel LEDs		MOV  DI, OFFSET LedTest1s	;		JMP  TmpDsplayDlay		;Delay for visibility;		~~~~~~~~~~~~~~~~;		* 111 LED test *;		~~~~~~~~~~~~~~~~LedTest1s:	MOV  AX, DiagLEDsTo7		; 		OUT  WriteConfigReg, AX		;Output 111 to front panel LEDs		MOV  DI, OFFSET LedTestEnd	;		JMP  TmpDsplayDlay		;Delay for visibility						;;LedTestEnd:	JMP  ROMTCheckSum		;for future useLedTestEnd:	JMP  RamATest			;						;;~~~~~~~~~~~~~Delay for LED visibilityTmpDsplayDlay:	MOV  AX, 06hTmpDsplayDlay1:	MOV  CX, 0FFFFh			;TmpDsplayDlay2:	LOOP TmpDsplayDlay2		;		DEC  AX				;		JNZ TmpDsplayDlay1		;		JMP  DI				;Return						;;		~~~~~~~~~~~~~~~~~~~~~~~~~~;		* 16K ROM Check Sum Test *;		~~~~~~~~~~~~~~~~~~~~~~~~~~;; ****** Temporarily removed ******;;		~~~~~~~~~~~~~~~~~~~~;		* RAM Address Test *;		~~~~~~~~~~~~~~~~~~~~RamATest:	MOV  AX, DiagLEDsTo5		; 		OUT  WriteConfigReg, AX		;Output 101 to front panel LEDs;		MOV  DS:WORD PTR DisplayValue, 01111h						;		XOR  AX, AX			;AX_ 0		MOV  DS, AX			;Set up DS with start of RAM		MOV  SI, 0h			;SI_ starting address						;				MOV  BX, SI			;BX_ SI		MOV  CX, 2000h			;CX_ RAM sizeRamAWriteAddr:	MOV  DS:[SI], BX		;		ADD  BX	,2			;		ADD  SI	,2			;		LOOP RamAWriteAddr		;						;		MOV  SI, 0h			;Compare all Ram locations		MOV  BX, SI			;		MOV  CX, 2000h			;  with their own addressRamACmpAddr:	MOV  AX, DS:[SI]		;		CMP  BX, AX			;		JNE  RamAErr			;		ADD  BX	,2			;		ADD  SI	,2			;		LOOP RamACmpAddr		;		JMP  RAMIATest			;done-go to next test						;RamAErr:	MOV  DI, OFFSET RamAErr1	;		JMP  TmpErrTone			;RamAErr1:	JMP  RamAErr1			;						;;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;		* RAM Inverted Address Test  *;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~RAMIATest:	MOV  SI, 03FFEh			;Write all Ram locations		MOV  BX, 0C000h			;  with their own inverted addr		MOV  CX, 2000h			;ROM sizeRAMIAWriteAddr:	MOV  DS:[SI], BX		;		ADD  BX, 2			;		SUB  SI, 2			;		LOOP RAMIAWriteAddr		;						;		MOV  SI, 3FFEh			;Compare all Ram locations		MOV  BX, 0C000h			;  with their own inverted addr		MOV  CX, 2000h			;ROM sizeRAMIACmpAddr:	MOV  AX, DS:[SI]		;		CMP  BX, AX			;		JNE  RAMIAErr			;		ADD  BX, 2			;		SUB  SI, 2			;		LOOP RAMIACmpAddr		;		JMP  RAMDTest			;						;RAMIAErr:	MOV  DI, OFFSET RAMIAErr1	;		JMP  TmpErrTone			;RAMIAErr1:	JMP  RAMIAErr1			;						;  ;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;		* RAM Data Test:0s,5s,As,Fs *;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~RAMDTest:	XOR  BX, BX			;BX¬ 0, data patternRAMDL:		MOV  SI, 0h			;StartOfRam		MOV  CX, 2000h			;ROM sizeRAMDWriteData:	MOV  DS:[SI], BX		;store data		ADD  SI, 2			;increment pointer		LOOP RAMDWriteData		;						;Compare all Ram locations						;  with proper data 		MOV  SI, 0h			;		MOV  CX, 2000h			;ROM sizeRAMDCmpData:	MOV  AX, DS:[SI]		;		CMP  BX, AX			;		JNE  RAMDErr			;		ADD  SI, 2			;		LOOP RAMDCmpData		;		CMP  BX, 0FFFFh			;		JE   RAMLBTest			;		ADD  BX, 05555h			;set up next data pattern		JMP  RAMDL			;						;RAMDErr:	MOV  DI, OFFSET RAMDErr1	;		JMP  TmpErrTone			;RAMDErr1:	JMP  RAMDErr1			;						;  ;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;		* RAM single low byte addressing test *;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~RAMLBTest:	MOV  SI, 2000h			;		MOV  CX, 100h			;		MOV  BX, 00h			;BX_ 00 data patternRAMSLBWriteData:MOV  DS:[SI], Bl		;store data		ADD  SI, 1			;increment pointer		ADD  Bl, 1			;increment data		LOOP RAMSLBWriteData		;						;Compare Ram data		XOR  AX, AX			;AX_ 0		MOV  SI, 2000h			;		MOV  CX, 100h			;		MOV  BX, 00h			;BX_ 00 data patternRAMSLBCmpData:	MOV  Al, DS:[SI]		;		CMP  Bl, Al			;		JNE  RAMSLBDAErr		;		ADD  SI, 1			;		ADD  BX, 1			;		LOOP RAMSLBCmpData		;		JMP  RAMHBTest			;						;RAMSLBDAErr:	MOV  DI, OFFSET RAMSLBDAErr1	;		JMP  TmpErrTone			;RAMSLBDAErr1:	JMP  RAMSLBDAErr1		;						;  ;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;		* RAM single high byte addressing test *;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~RAMHBTest:	MOV  SI, 2000h			;		MOV  CX, 100h			;		MOV  BX, 00h			;BX_ 00 data patternRAMSHBWriteData:MOV  DS:[SI], Bh		;store data		ADD  SI, 1			;increment pointer		ADD  Bh, 1			;increment data		LOOP RAMSHBWriteData		;						;Compare Ram data		XOR  AX, AX			;AX_ 0		MOV  SI, 2000h			;		MOV  CX, 100h			;		MOV  BX, 00h			;BX_ 00 data patternRAMSHBCmpData:	MOV  Ah, DS:[SI]		;		CMP  Bh, Ah			;		JNE  RAMSHBDAErr		;		ADD  SI, 1			;		ADD  Bh, 1			;		LOOP RAMSHBCmpData		;		JMP  RAMDAATest			;						;RAMSHBDAErr:	MOV  DI, OFFSET RAMSHBDAErr1	;		JMP  TmpErrTone			;RAMSHBDAErr1:	JMP  RAMSHBDAErr1		;						;;		~~~~~~~~~~~~~~~~~~~~~~~~~~~;		* RAM double access addressing test*;		~~~~~~~~~~~~~~~~~~~~~~~~~~~RAMDAATest:	XOR  BX, BX			;BX_ 00h data pattern		MOV  SI, 2001h			;		MOV  CX, 0FFh			;						;				MOV  BX, 0001h			;BX_ 0001h data patternRAMDAAWriteData:MOV  DS:[SI], BX		;store data		ADD  SI, 2			;increment pointer		ADD  BX, 0101h			;		LOOP RAMDAAWriteData		;						;Compare Ram data		MOV  BX, 0001h			;BX_ 0001h data pattern		MOV  SI, 2001h			;		MOV  CX, 0FFh			;RAMDAACmpData:	MOV  AX, DS:[SI]		;		CMP  BX, AX			;		JNE  RAMDAAErr			;		ADD  SI, 2			;		ADD  BX, 0101h			;		LOOP RAMDAACmpData		;		JMP  SetUpStack			;						;RAMDAAErr:	MOV  DI, OFFSET RAMDAAErr1	;		JMP  TmpErrTone			;RAMDAAErr1:	JMP  RAMDAAErr1			;						;;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;		* Set up Stack and Data segment         *;		* for CALL/RET instructions & RAM usage *;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~SetUpStack:	MOV  AX, 9Eh			;Set up Stack		MOV  SS, AX			;   from AE0h to 9E0h		MOV  AX, 100h			;		MOV  SP, AX			; 						;	ASSUME	DS:IOPELocalRam		MOV	prebootSwitches, 0	;no switches to start;		MOV  DS:WORD PTR DisplayValue, 02222h						;;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;		* 8259 Slave and Master Interrupt Test *;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~						;The interrupts are automatically						; disabled with reset(=CLI)InterruptTest:	CALL SetUnxIntrVcs		;Set Interrupt Vertors to						;  interrupt vertor err routine						;;~~~~~~~~~~~~~~~Initialize Slave 8259		MOV  AL, i8259SlaveICW1		;Initialize Slave 8259		OUT  i8259SlaveAddr0, Al	;ICW1 ¬ 11h		MOV  AL, i8259SlaveICW2		;		OUT  i8259SlaveAddr1, Al	;ICW2¬ 30h(=vector address/4)		MOV  AL, i8259SlaveICW3		;		OUT  i8259SlaveAddr1, Al	;ICW3¬ 5h(Intr. line to master)		MOV  AL, i8259SlaveICW4		;			OUT  i8259SlaveAddr1, Al	;ICW4¬ 01h (nested mode & 80186)						;;~~~~~~~~~~~~~~~TEST Slave 8259 Mask register with 0s, 5s, As, Fs		XOR  BX, BX			;BX¬ 00hIntrSlMsk1:	MOV  AX, BX			;		OUT  i8259SlaveAddr1, Al	;Write Slave 8259 Mask register		IN   Al, i8259SlaveAddr1	;Read Slave 8259 Mask register		CMP  AL, Bl			;Compare Data		JNE  IntrSlMskErr		;		CMP  BX, 0FFh			;		JE   IntrSlIR			;OK-go to next test		ADD  BX, 055h			;OCW1(mask register)¬ +55h		JMP  IntrSlMsk1			;IntrSlMskErr:	CALL ErrTone			;IntrSlMskErr1:	JMP  IntrSlMskErr1		;Loop on err						;;~~~~~~~~~~~~~~~TEST Slave 8259 IR register for 0'sIntrSlIR:	XOR  BX, BX			;BX¬ 0, Expected IR register		MOV  AL, 0Ah			;		OUT  i8259SlaveAddr0, Al	;OCW3¬ 00Ah (select IR register)		IN   Al, i8259SlaveAddr0	;Read 8259 IR register		CMP  AL, Bl			;look for not interrupt requests		JE   IntrSlIS			;OK-go to next testIntrSlIRErr:	CALL ErrTone			;IntrSlIRErr1:	JMP  IntrSlIRErr1		;Loop on err						;;~~~~~~~~~~~~~~~TEST Slave 8259 IS register for 0'sIntrSlIS:	MOV  BX, 00h			;Expected IS register		MOV  AL, 0Bh			;		OUT  i8259SlaveAddr0, Al	;OCW3¬ 00Bh (select IS register)		IN   Al, i8259SlaveAddr0	;Read Sleave 8259 IS register		CMP  AL, Bl			;Compare Data		JE   InitMaster8259		;OK-go to next testIntrSlISErr:	CALL ErrTone			;IntrSlISErr1:	JMP  IntrSlISErr1		;Loop on err						;						;;~~~~~~~~~~~~~~~Initialize Master 8259InitMaster8259:MOV  AL, i8259MasterICW1		;Initialize Master 8259		OUT  i8259MasterAddr0, Al	;ICW1 ¬ 11h		MOV  AL, i8259MasterICW2		;		OUT  i8259MasterAddr1, Al	;ICW2¬ 20h(=vector address/4)		MOV  AL, 070h			;(IR4-5-6 has slave on it)		OUT  i8259MasterAddr1, Al	;ICW3¬ F0h		MOV  AL, i8259MasterICW4		;			OUT  i8259MasterAddr1, Al	;ICW4¬ 11h (nested mode & 80186)						;;~~~~~~~~~~~~~~~TEST Master 8259 Mask register with 0s, 5s, As, Fs		XOR  BX, BX			;BX¬ 00hIntrMsMsk1:	MOV  AX, BX			;		OUT  i8259MasterAddr1, Al	;Write Master 8259 Mask register		IN   Al, i8259MasterAddr1	;Read Master 8259 Mask register		CMP  AL, Bl			;Compare Data		JNE  IntrMsMskErr			;OK-go to next test		CMP  BX, 0FFh			;OK-go to next test		JE   IntrMsIR			;		ADD  BX, 055h			;OCW1(mask register)¬ 55h		JMP  IntrMsMsk1			;IntrMsMskErr:	CALL ErrTone			;IntrMsMskErr1:	JMP  IntrMsMskErr1		;Stop on err						;;~~~~~~~~~~~~~~~TEST Msave 8259 IR register for 0'sIntrMsIR:	XOR  BX, BX			;BX¬ 0, Expected IR register		MOV  AL, 0Ah			;		OUT  i8259MasterAddr0, Al	;OCW3¬ 00Ah (select IR register)		IN   Al, i8259MasterAddr0	;Read 8259 IR register		CMP  AL, Bl			;look for not interrupt requests		JE   IntrMsIS			;OK-go to next testIntrMsIRErr:	CALL ErrTone			;IntrMsIRErr1:	JMP  IntrMsIRErr1		;Loop on err						;;~~~~~~~~~~~~~~~TEST Master 8259 IS register for 0'sIntrMsIS:	MOV  BX, 00h			;Expected IS register		MOV  AL, 0Bh			;		OUT  i8259MasterAddr0, Al	;OCW3¬ 00Bh (select IS register)		IN   Al, i8259MasterAddr0	;Read Master 8259 IS register		CMP  AL, Bl			;Compare Data		JE   Timer2T			;OK-go to next testIntrMsISErr:	CALL ErrTone			;IntrMsISErr1:	JMP  IntrMsISErr1		;Stop on err						;						;;~~~~~~~~~~~~~~~Error: unexpected interrupt errorUnexpctdIntr:	JMP  UnexpctdIntr		;Loop here						;;~~~~~~~~~~~~~~~Set vectors to unexpected interrupt routineSetUnxIntrVcs:	MOV  SI, 00h			;Set up all vectors to		MOV  CX, 100h			;  vector err routine		MOV  AX, OFFSET UnexpctdIntr	;		MOV  BX, SEG UnexpctdIntr	;SetUnxIntrVcs1:	MOV  DS:[SI], AX		;		MOV  DS:[SI+2], BX 		;		ADD  SI, 4	 		;		LOOP SetUnxIntrVcs1		;		RET				;						;;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~;		* 8254 Timer2 test (Timer2T) *;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~Timer2T:	MOV  AX, DiagLEDsTo4		; 		OUT  WriteConfigReg, AX		;Output 100 to front panel LEDs;		MOV  DS:WORD PTR DisplayValue, 03333h						;		MOV  Al, 0B6h			;		OUT  i8254Ctlr, Al		;--i8254Ctlr--		MOV  AX, 1Ah			; Baud9600		OUT  i8254Count2, AL		;--i8254Count2--ls byte		MOV  AL, 0		OUT  i8254Count2 ,AL		;ms byte						;		MOV  BX, 036h			;Test: Timer2 out low		MOV  CX, 0FFFFh			;Timer2T1a:	MOV  Al, 0E8h			;		OUT  i8254Ctlr, Al		;  		IN   AL, i8254Count2		;Read Status		CMP  AL, Bl			;		JE   Timer2T2			;		LOOP Timer2T1a			;Timer2T1aErr:	CALL ErrTone			;Timer2T1aErr1:	JMP  Timer2T1aErr1	 	;loop on err						;Timer2T2:	MOV  BX, 0B6h			;Test: Timer2 out high		MOV  CX, 0FFFFh			;Timer2T2a:	MOV  Al, 0E8h			;Read Status		OUT  i8254Ctlr, Al		;  		IN   AL, i8254Count2		;		CMP  AL, Bl			;		JE   Timer2Loop			;		LOOP Timer2T2a			;Timer2T2aErr:	CALL ErrTone			;Timer2T2aErr1:	JMP  Timer2T2aErr1 		;loop on err						;Timer2Loop:	XOR  DI, DI			;DI¬ 0		MOV  CX, 080h			;Read and store CounterTimer2Loop1:	MOV  Al, 0D8h			;		OUT  i8254Ctlr, Al		;  		IN   AL, i8254Count2		;		MOV  DS:BYTE PTR DataBuff[DI], Al;		INC  DI				;		IN   AL, i8254Count2		;		MOV  DS:BYTE PTR DataBuff[DI], Al;		INC  DI				;		LOOP Timer2Loop1			;						;		MOV  DI, 01h			;Test high order bytes for 00h		MOV  CX, 080h			;		XOR  BX, BX			;BX¬ 0, expected high order byteTimer2Loop2:	MOV  Al, DS:BYTE PTR DataBuff[DI];		CMP  Al, Bl			;No-err?			JNE  Timer2Loop2Err 		;yes		ADD  DI, 02h			;no		LOOP Timer2Loop2		;		JMP  Timer2Loop3		;go to next testTimer2Loop2Err:	CALL ErrTone			;Timer2Loop2Err1:JMP  Timer2Loop2Err1		;Stop on err						;Timer2Loop3:	XOR  DI, DI			;DI¬ 0, Test low order bytes		MOV  CX, 080h			;  for max 01Ah		MOV  BX, 01Ah			;BX¬ expected max dataTimer2Loop3a:	MOV  Al, DS:BYTE PTR DataBuff[DI];		CMP  Al, Bl			;No-err?			JG   Timer2Loop3Err 	 	;yes		ADD  DI, 02h			;no		LOOP Timer2Loop3a		;no		JMP  KTAStsTst			;go to next testTimer2Loop3Err:	CALL ErrTone			;Timer2Loop3Err1:JMP  Timer2Loop3Err1		;Stop on error						;						;;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;		* Keyboard UART turn around test (KTAT) *;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~						;Note: timer 2 should still be						; running and interrupts should						; still be disabled.KTAStsTst:;		MOV  DS:WORD PTR DisplayValue, 04444h		CALL UARTTrnArndTst		;Set up UART for turn around test		MOV  AX, 0Ah			;		CALL LongCntrldDelay		;wait for keyboard mouse data		MOV  BX, 85h			;BX¬ expected status		IN   Al, KeyBdUartStatus	;Read UART status			CMP  Al, Bl			;Good Status?		JE   KTAStsTst1			;Yes-Go to KTATrnArndStsKTAStsTstErr1:	CALL ErrTone			;KTAStsTstErr1a:	JMP  KTAStsTstErr1a		;Loop on err						;KTAStsTst1:	CALL UARTTrnArndTst		;Test Reciever Ready		MOV  Al, 01h			;		OUT  KeyBdUartData, Al		;Transmit a character			MOV  CX,01000h			;Long delay after transmitKTASts2Tst2:	LOOP KTASts2Tst2		;		MOV  BX, 87h			;BX_ expected status		IN   Al, KeyBdUartStatus	;Read UART status			CMP  Al, Bl			;Reciever ready?		JE   KTAOvrunTst		;KTAStsTstErr2:	CALL ErrTone			;KTAStsTstErr2a:	JMP  KTAStsTstErr2a		;Loop on err						;KTAOvrunTst:	CALL UARTTrnArndTst		;Test overrun status		MOV  AX, 55h			;output first character_ 01h		OUT  KeyBdUartData,Al		;Transmit a character			MOV  CX,01000h			;delay after transmitKTAOvrunTst2:	LOOP KTAOvrunTst2		;		ADD  Al, 55h			;output second character_ 02h		OUT  KeyBdUartData,Al		;Transmit a character			MOV  CX,01000h			;delay after transmitKTAOvrunTst3:	LOOP KTAOvrunTst3		;		XOR  AX, AX			;Clear AX		MOV  BX, 97h			;BX_ expected status		IN   Al, KeyBdUartStatus	;Read UART status			CMP  Al, Bl			;Reciever ready?		JE   KTATst			;KTAOvrunTstErr:	CALL ErrTone			;KTAOvrunTstErr1:JMP  KTAOvrunTstErr1		;Loop on err						;KTATst:		CALL UARTTrnArndTst		;Set up UART for turn around test		MOV  CX, 0100h			;Do 256 characters trun around		XOR  BX, BX			;BX¬ 0, characterKTATst1:	MOV  AX, BX			;AX¬ output character		OUT  KeyBdUartData,Al		;Transmit a character	KTATst2:	IN   Al, KeyBdUartStatus	;Read UART status			CMP  Al, 87h			;  Wait for reciever ready			JNE  KTATst2			;		IN   Al, KeyBdUartData		;Read character		CMP  Al, Bl			;Compare characters		JE   KTATst3			;Do the next characterKTATst2Err:	CALL ErrTone			;KTATst2Err1:	JMP  KTATst2Err1		;Stop on err						;KTATst3:	INC  BX				;increment character		LOOP KTATst1			;						;  						;  ;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;		* Keyboard UART Turn Around under interrupts (KTAI)*;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~						;Timer should still be setKTAITstEL:;		MOV  DS:WORD PTR DisplayValue, 05555h		CALL KbTAITSetup		;Set up keyb. interrupt requir.						;Check for correct IR reg		MOV  BX, 08h			;BX¬ expected IR reg		XOR  AX, AX			;AX¬ 0, output character		MOV  CX, 0FFFFh			;delay		CLI				;Clear the interrupt flag		OUT  KeyBdUartData,Al		;Transmit a character	KTAITst1:	IN   AL, i8259MasterAddr0	;Read 8259 IR register		AND  AL, 0FBh			;		CMP  AL, Bl			;		JE   KTAITst2			;		LOOP KTAITst1			;  Wait for IR4 setKTAITst1Err:	CALL ErrTone			;KTAITst1Err1:	JMP  KTAITst1Err1		;Loop on err						;KTAITst2:	CALL KbTAITSetup		;Set up keyb. interrupt requir.		MOV  CX, 0100h			;Do 256 characters trun around		XOR  BX, BX			;BX¬ 0, character		STI				;Set enable interrupt flagKTAITst3:	XOR  DX, DX			;DX¬ 0, no interrupt occurred		MOV  AX, BX			;AX¬ output character		OUT  KeyBdUartData, Al		;Transmit a character	KTAITst4:	TEST DX, 01h			;		JZ   KTAITst4			;  If err-Loop on err		INC  BX				;increment character		LOOP KTAITst3			;		MOV  AL, 0FDh                   ;Mask off Keyboard interrupt		OUT  i8259MasterAddr1, Al       ;		JMP  i86TMT			;						;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;~~~~~~~~~~~~~~~Keyboard Interrupt RoutineKTAIntrRtn:	MOV  DX, BX			;DX¬ expected data		XOR  BX, BX			;BX¬ 0, expected mask register		IN   AL, i8259MasterAddr0	;Read 8259 IR register		AND  AL, 0FBh			;mask off burdock out intr		CMP  AL, Bl			;expected IR register		JNE  KTAIntrErr			;						;		MOV  BX, 08h			;		MOV  AL, 00Bh			;Check 8259 IS register(for IS3)		OUT  i8259MasterAddr0, Al	;OCW3¬ 00Bh (select IS register)		IN   AL, i8259MasterAddr0	;Read Sleave 8259 IS register		CMP  AL, Bl			;expected IS register		JNE  KTAIntrErr			;						;		MOV  BX, 087h			;		IN   Al, KeyBdUartStatus	;Check UART status			CMP  Al, Bl			;  Wait for reciever ready			JNE  KTAIntrErr			;Loop here						;		MOV  BX, DX			;		IN   Al, KeyBdUartData		;Read the character		CMP  Al, Bl			;Compare characters		JNE  KTAIntrErr			;Loop here						;		MOV  BX, 085h			;		IN   Al, KeyBdUartStatus	;Check UART status			CMP  Al, Bl			;  Wait for reciever ready			JNE  KTAIntrErr			;Loop on err						;		MOV  AL, 063h			;Reset IS3 (EndOofInterrupt)		OUT  i8259MasterAddr0, Al	;  OCW2¬ 063h 						;		XOR  BX, BX			;BX¬ 0, expected IS reg		IN   AL, i8259MasterAddr0	;  Check IS register		CMP  AL, Bl			;expected IS register		JNE  KTAIntrErr			;						;		MOV  AL, 0Ah			;Set up to read IR register		OUT  i8259MasterAddr0, Al	;  OCW3¬ 00Ah (select IR register)						;		MOV  BX, DX			;BX¬ character		MOV  DX, 01h			;DX¬ got the character		IRET				;Return						;KTAIntrErr:	CALL ErrTone			;KTAIntrErr1:	JMP  KTAIntrErr1			;Loop on error						;;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~KbTAITSetup:	CALL UARTTrnArndTst		;Set up UART for turn around test		MOV  SI, 8Ch			;Set up Keyboar Interrupt		MOV  AX, OFFSET KTAIntrRtn	;  vector at 23h*4		MOV  BX, SEG KTAIntrRtn		;		MOV  DS:[SI], AX		;		MOV  DS:[SI+2], BX 		;		MOV  AL, 0F5h			;Enable Keyboard interrupt		OUT  i8259MasterAddr1, Al	;		MOV  Al, 0C7h			;Master OCW2¬ C7h			OUT  i8259MasterAddr0, Al	;  (highest priority accepted)		MOV  Al, 00Ah			;Master OCW3¬ 0Ah		OUT  i8259MasterAddr0, Al	;  no Special Mask Mode/IRR		RET				;						;;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;		* 186 Timer 2 test (i86T2) *;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~i86TMT:;		MOV  DS:WORD PTR DisplayValue, 06666h		MOV  DS:WORD PTR TimerIntrCnt, 00h;Clear 		MOV  DS:WORD PTR TimerCnt, 00h	;Clear 						;						;Test: 186 mask reg		XOR  BX, BX			;BX¬ 0		MOV  AX, BX			;		MOV  DX, i186IntrMaskRegAddr	;		OUT  DX, AX			;186 Mask reg addr (to 0FF28h)		IN   AX, DX			;186 Mask reg addr (to 0FF28h)		CMP  AX, BX			;		JE   i86TMT1 			;i86TMTErr:	CALL ErrTone			;i86TMTErr1:	JMP  i86TMTErr1			;Stop on err						;i86TMT1:	CALL SetTimer2Vctr		;Establish vector for i186 Timer0						;		MOV  AX, i186IntrVectorRegvalue	;initialize interrupt vector		MOV  DX, i186IntVectorRegAddr	;register		OUT  DX, AX			;						;		MOV  Al, 0BDh			;UnMask IR1 & IR6		OUT  i8259MasterAddr1, Al	;Al now contains the new mask		MOV  Al, 0C7h			;Master OCW2¬ C7h			OUT  i8259MasterAddr0, Al	;  (highest priority accepted)		MOV  Al, 00Ah			;Master OCW3¬ 0Ah			OUT  i8259MasterAddr0, Al	;  no Special Mask Mode/IRR		CLI				;Disable 186 interrupts (-NMI)						;						;Initialize timer 2		MOV  AX, 0			;Set the counter to 0		MOV  DX, i186Timer2CountRegAddr	;		OUT  DX, AX			;(to 0FF60h)		MOV  AX, 2000			;and the set to 2000		MOV  DX, i186Timer2CountAAddr	;		OUT  DX, AX			;(to 0FF62h)		MOV  AX, 0E001h			;Enable, Set to Interrupt		MOV  DX, i186Timer2MCWAddr	;		OUT  DX, AX			;  and Continue(to 0FF66h)		XOR  AX, AX			;AX¬ 0,Un-mask the interrupt at		MOV  DX, i186Timer2IntCtlAddr	;		OUT  DX, AX			;  priority 0 (to 0FF3Ah)						;						;Test: IR for 186 timer 2		MOV  BX, 0020h			;BX¬ expected IR reg		MOV  CX, 0800h			;delay-wait for 186 timer set		MOV  DX, i186IntrRequestAddr	;i86T1:		IN   AX, DX			;Read IR register (from 0FF2Eh)		CMP  AX, BX			;		JE   i86T2 			;  check for prior err		LOOP i86T1			;  Wait for IR seti86T1Err:	CALL ErrTone			;i86T1Err1:	JMP  i86T1Err1			;Stop on err						;						;Test: IR06 for master 8259i86T2:		MOV  BX, 040h			;BX¬ expected IR reg		MOV  CX, 0800h			;delay-wait for 186 timer seti86T2a:		IN   AL, i8259MasterAddr0	;Read 8259 IR register		AND  AL, 0E9h			;		CMP  AL, Bl			;		JE   i86T3 			;  check for prior err		LOOP i86T2a			;  Wait for IR6 seti86T2aErr:	CALL ErrTone			;i86T2aErr1:	JMP  i86T2aErr1			;Stop on err						;i86T3:		STI 				;Enable the interrupts						;		XOR  DX, DX			;DX¬ 0i86T3a:		INC  DS:WORD PTR TimerCnt	;		CMP  DX, 01h			;		JNE  i86T3a 			;wait for intr loop						;		CMP  DS:WORD PTR TimerIntrCnt, 010h;16 interrupts?		JE   i86T3b			;no-wait for next interrupt		XOR  DX, DX			;DX¬ 0		JMP  i86T3a			;no-wait for next interrupt						;i86T3b:		MOV  AX, 0FDh			;Mask IR6		OUT  i8259MasterAddr1, Al	;Al now contains the new mask		JMP  i186TTChk			;Go to timer check						;;~~~~~~~~~~~~~~~~						;BX¬ 0i86T2IntrHndlr:	XOR  BX, BX			;DX¬ 186 IR reg addr		MOV  DX, i186IntrRequestAddr	;		IN   AX, DX			;Read IR register (from 0FF2Eh)		CMP  AX, BX			;Note: BX=0		JE   i86T2IntrH1		;i86T2IntrHndlrErr:CALL ErrTone			;i86T2IntrHndlrErr1:JMP  i86T2IntrHndlrErr1	;Stop on err						;						;Test: 186 timer 2 IS reg seti86T2IntrH1:	MOV  BX, 0020h			;BX¬ expected Is reg		MOV  DX, i186InServiceRegAddr	;		IN   AX, DX			;Read IS register (from 0FF2Ch)		CMP  AX, BX			;		JE   i86T2IntrH2 		;i86T2IntrH1Err:	CALL ErrTone			;i86T2IntrH1Err1:JMP  i86T2IntrH1Err1		;Stop on err						;						;Test: Master 8259 IS reg seti86T2IntrH2:	MOV  AL, 00Bh			;Set Master 8259 to read IS reg		OUT  i8259MasterAddr0, Al	;OCW3¬ 00Bh (select IS register)		MOV  BX, 0040h			;BX¬ expected IS reg		IN   Al, i8259MasterAddr0	;Read 8259 IS register		CMP  Al, Bl			;		JE   i86T2IntrH3 		;i86T2IntrH2Err:	CALL ErrTone			;i86T2IntrH2Err1:JMP  i86T2IntrH2Err1		;yes-loop on err						;i86T2IntrH3:	INC	DS:WORD PTR TimerIntrCnt;increment timer count...						;Test: 186 timer 2 IS reg reset		MOV  AX, i186EOItimer2		;Send an EOI to timer2		MOV  DX, i186EOIRegAddr		;		OUT  DX, AX			;  186 EOI Register (to 0FF22h)		XOR  BX, BX			;BX¬ 0		MOV  DX, i186InServiceRegAddr		;		IN   AX, DX			;Read IS reg (from 0FF2Ch)		CMP  AX, BX			;Check for ISR = 0		JE   i86T2IntrH4		;i86T2IntrH3Err:	CALL ErrTone			;i86T2IntrH3Err1:JMP  i86T2IntrH3Err1		;Stop on err						;						;Test: Master 8259 IS reg reseti86T2IntrH4:	MOV  AL, 066h			;Reset IS4 (EndOofInterrupt)		OUT  i8259MasterAddr0, Al	;  OCW2¬ 066h 		XOR  BX, BX			;BX¬ 0		IN   Al, i8259MasterAddr0	;Read 8259 IS register		CMP  Al, Bl			;Check for ISR = 0		JE   i86T2IntrH5 		;i86T2IntrH4Err:	CALL ErrTone			;i86T2IntrH4Err1:JMP  i86T2IntrH4Err1		;Stop on err						;						;Test: Master IR reg reseti86T2IntrH5:	XOR  BX, BX			;BX¬ 0, expected IR reg		IN   Al, i8259MasterAddr0	;Read IR register		AND  AL, 0E9h			;		CMP  Al, Bl			;		JE   i86T2IntrH6 		;i86T2IntrH5Err:	CALL ErrTone			;i86T2IntrH5Err1:JMP  i86T2IntrH5Err1		;Stop on err						;i86T2IntrH6:	MOV  AX, i186EOItimer2		;Send an EOI to timer0		MOV  DX, i186EOIRegAddr		;		OUT  DX, AX			;  186 EOI Register (to 0FF22h)		MOV  AL, 066h			;Write an EOI command for the 			OUT  i8259MasterAddr0, AL	;  Master 8259		MOV  DX, 01h			;		IRET;~~~~~~~~~~~~~~~~SetTimer2Vctr:	MOV  AX, OFFSET i86T2IntrHndlr	;Set BX,AX to		MOV  BX, SEG i86T2IntrHndlr	;the CS:IP to be stored		MOV  SI, 4*03Dh			;Interrupt Type 038h		MOV  DS:[SI], AX		;Store the new IP		MOV  DS:[SI+2], BX 		;and the new CS		RET						;;~~~~~~~~~~~~~~~This Test is temporarily bypassedi186TTChk:	JMP  KbTest			;		MOV  BX, 0970h			;timer count-1		MOV  AX, DS:WORD PTR TimerCnt	;		CMP  AX, BX			;		JL   i186TTChkErr		;		MOV  BX, 0972h			;timer count+1		CMP  AX, BX			;		JG   i186TTChkErr		;		JMP  KbTest			;i186TTChkErr:	CALL ErrTone			;i186TTChkErr1:	JMP  i186TTChkErr1		;Loop on err						;;		~~~~~~~~~~~~~~~~~~~~~~;		* Keyboard test (KT) *;		~~~~~~~~~~~~~~~~~~~~~~KbTest:		MOV  AX, DiagLEDsTo3		;		OUT  WriteConfigReg, AX		;Output 011 to front panel LEDs						;;		CALL ClrKbBuff			;yes-Clear the keyboard buffer;		CALL GetKbInput			;Get input from the keyboard;		CMP  DS:BYTE PTR FunctionKey, 00h;Yes-Function key entered?;		JE   EEPromTest			;no;		JMP  GoToFunction		;yes						;;		~~~~~~~~~~~~~~~~~~~~~~~~~~;		* EEPROM Check Sum Test *;		~~~~~~~~~~~~~~~~~~~~~~~~~~EEPromTest:	MOV  AX, DiagLEDsTo2		;AX¬ 2		OUT  WriteConfigReg, AX		;Output 010 to front panel LEDs;		MOV  DS:WORD PTR DisplayValue, 07777h						;		CALL ClrKbBuff			;Clear the keyboard buffer & flags		CALL VerifyEEPROM		;						;		CMP  DS:BYTE PTR ErrFlag1, 01h	;Is Err flag set?		JNE  HIDPCheckSum		;no						;		MOV  DS:BYTE PTR StopModeFlg, 01h ;  set Stop mode Flag		MOV  DS:BYTE PTR ErrFlag1, 00h;Clear Err flag;		CALL GetKbInput			;Get input from the keyboard;		JMP  GoToFunction		;						;;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;		* Host ID PROM Check Sum Test *;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~HIDPCheckSumS:	NOPHIDPCheckSum:	MOV  AX, DiagLEDsTo1		;		OUT  WriteConfigReg, AX		;Output 001 to front panel LEDs;		ADD  DS:WORD PTR DisplayValue, 1111h						;  						;		MOV  CX, 05h			;Iteration count		MOV  DX, ReadHostProm		;DX¬ Host ID PROM address byte0		IN   Al, DX			; (from 90h)		MOV  Bl, Al			;		ADD  DX, 02			;DX¬ Host ID PROM address byte4HIDPCheckSum1:	IN   Al, DX			;		XOR  Bl, Al			;		ROL  Bl, 1			;		ADD  DX, 02			;DX¬ Host ID PROM address+ 2		LOOP HIDPCheckSum1		;		IN   Al, DX			;		CMP  Bl, Al			;		JNE  HIDPCheckSumErr		;		NOT  Bl				;		ADD  DX, 02			;DX¬ Host ID PROM address+ 2		IN   Al, DX			;		CMP  Bl, Al			;		JE   GoToBooting		;HIDPCheckSumErr:CALL ErrTone			;HIDPCheckSumErr1:JMP  HIDPCheckSumErr1		;						;						;;		~~~~~~~~~~~~~~~~~~~~~~;		* Initialize the IOP *;		~~~~~~~~~~~~~~~~~~~~~~GoToBooting:						CALL SetUpKeyboard		;Setup the keyboard system		MOV	AX, IOPELocalRam	;Establish Data Segment Register		MOV	DS, AX			;		MOV	SS, AX			;Establish Stack Segment Register		MOV	SP, EmptyStack		;Establish Stack Pointer				MOV  AX, DiagLEDsTo2		; 		TEST DS:BYTE PTR StopModeFlg, 01h		JNZ  ShowLED		MOV  AX, DiagLEDsTo0		; ShowLED:		OUT  WriteConfigReg, AX		;Output 000 to front panel LEDs		MOV  bootType, 0h		MOV  device, 0h	;		MOV  bootRetryCount, 0h;						;;		MOV  AX, OFFSET CleanFloppyHeads;		MOV  BX, SEG CleanFloppyHeads	;;		MOV  cleanFloppyHeadsPROC, AX	;;		MOV  cleanFloppyHeadsPROC+2, BX	;GoToBootingNow:		MOV  AX, prebootSwitches;		ADD  DS:WORD PTR DisplayValue, AX;		MOV  AX, DS:WORD PTR DisplayValue;		OUT  WriteLED, AX		JMP  InitDebug			;						;;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;		* Go to the desired function *;		~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;; ********** Temporarily Removed *********;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ;				SUBROUTINES;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; Clear the keyboard buffer ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;ClrKbBuff:	XOR  DI, DI			;DI¬ 0, Clear the Key down buffer;		MOV  CX, 060h			;  plus flagsClrKbBuff:	MOV  DS:BYTE PTR MouseCoorFlg, 00h ;;		ADD  DI, 02h			;;		LOOP ClrKbBuff1			;		XOR  DI, DI			;DI¬ 0, Clear the Key down buffer		MOV  CX, 0C0h			;ClrKbDBuff1:	MOV  DS:WORD PTR KeyDwnBuff[DI], 00h;		MOV  DS:WORD PTR DataBuff[DI], 00h;		ADD  DI, 02h			;		LOOP ClrKbDBuff1		;		MOV  DS:BYTE PTR KeyDwnBuffHasChar, 00h;		RET				;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Generate an EEPROM Checksum      *; AX¬ Checksum                     *; SI¬ Pointer to EEPROM chechsum*2 *;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;GenEEPChcksum:	XOR  SI, SI			;SI¬ 0		XOR  AX, AX			;AX¬ 0		MOV  CX, 03Eh			;EEPROM size-2GenEEPChcksum1:	MOV  BX, DS:WORD PTR DataBuff[SI];		ADD  AX, BX			;AX¬ 0		JNC  GenEEPChcksum2		;		INC  AX				;AX¬ AX+1GenEEPChcksum2:	ROL  AX, 1			;		ADD  SI, 2			;		LOOP GenEEPChcksum1		;		CMP  AX, 0FFFFh		JNE  GenEEPCSRet		MOV   AX, 0GenEEPCSRet:	RET				;;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Get keyboard input for the operator;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;; ********** Temporarily Removed *********;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Floppy Disk Controller Subroutines;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;; ********** Temporarily Removed *********;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Provides a long delay, AX= delay count;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~LongCntrldDelay:				;AX holds delay countLongDelay1:	MOV  CX, 0FFFFh			;LongDelay2:	LOOP LongDelay2			;		DEC  AX				;		JNZ LongDelay1			;		RET				;						;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Resets the UART then sets up for UART turn around Test;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~SetUpKeyboard:							;		MOV  AL, 0FDh			;Mask off Keyboard interrupt				OUT  i8259MasterAddr1, Al	;						;;		MOV  SI, 8Ch			;set up vector;		MOV  AX, OFFSET KbIntrRtin	;23h*4;		MOV  BX, SEG KbIntrRtin		;;		MOV  DS:[SI], AX		;;		MOV  DS:[SI+2], BX 		;						;		MOV  AX, resetUmbilicalController;		OUT  WriteResetReg, AX	 	;Clears everything exept debug		MOV  CX,0FFh			;SetUpKeyboard1:	LOOP SetUpKeyboard1		;Delay						;;Now remove KeyBoardUart Reset		MOV  AX, resetUmbilicalController+ resetKeyboardUART;		OUT  WriteResetReg, AX	 	;Enable Bermuda/UART		MOV  CX,03h			;SetUpKeyboard2:	LOOP SetUpKeyboard2		;small Delay						;		MOV  Al,4Eh			;Set up UART mode:			OUT  KeyBdUartCtl,Al		;  Async Mode,						;  8bits data,							;  no parity,						;  1 stop bit						;Note: baud rate= 9600		MOV  CX,0FFh			;DelaySetUpKeyboard3:	LOOP SetUpKeyboard3		;						;		MOV  Al,36h			;Set up UART Command:		OUT  KeyBdUartCtl,Al		;  Data Terminal Ready (DTR-bit1)						;  Reciever Enable (RxRDY-bit2)						;  Err Reset (-bit4)						;  Request to Send (RTS-bit5)		MOV  CX,0FFh			;DelaySetUpKeyboard4:	LOOP SetUpKeyboard4		;						;;Now remove KeyBoard Reset		MOV  AX, resetUmbilicalController+ resetKeyboardUART+ resetKeyboardController;		OUT  WriteResetReg, AX	 	;Enable Bermuda/UART/Keyboard		MOV  CX,0FFh			;SetUpKeyboard5:	LOOP SetUpKeyboard5		;Delay						;		RET				;						;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Outputs one long tone ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ErrTone:;		POP  AX;		MOV  DS:WORD PTR ErrCallSave, AX	;save the Caller's IP;		PUSH  AX		CALL SpeakerOn 			;Turn on the speaker		MOV  AX, 0Ah			;		CALL LongCntrldDelay		;delay		CALL SpeakerOff			;		RET				;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;Turn the speaker off;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~SpeakerOff:	MOV  AX, 04003h			;		MOV  DX, i186Timer0MCWAddr	;		OUT  DX, AX			;(0FF56h)		RET				;						;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;Turn the speaker on;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~SpeakerOn:	MOV  AX, CRSpeakerData+CREnableTimer0;Turn on		OUT  WriteCtlReg, AX		;  SpkerData (0C000h)						;		MOV  AX, 0			;Set the counter to 0		MOV  DX, i186Timer0CountRegAddr	;		OUT  DX, AX;(to 0FF50h)		MOV  AX, 017BFh			;		MOV  DX, i186Timer0CountAAddr	;		OUT  DX, AX			;(to 0FF52h)						;		MOV  AX, 017BFh			;		MOV  DX, i186Timer0CountBAddr	;		OUT  DX, AX			;(to 0FF54h)						;		MOV  AX, 0C003h			;Sets: Continous running		MOV  DX, i186Timer0MCWAddr	;		OUT  DX, AX			;      ALT		RET				;      Inhibit'						;      Enable (to 0FF56h)						;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Outputs one long high-frequency tone ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~TmpErrTone:	MOV  ES, AX			;Save AX						;		MOV  AX, 0C000h			;Turn on the speaker		MOV  DX, 080h			;  EnTimer0		OUT  DX, AX			;  SpkerData		MOV  AX, 0			;Set the counter to 0		MOV  DX, 0FF50h			;		OUT  DX, AX			;		MOV  AX, 017BFh			;		MOV  DX, 0FF52h 		;		OUT  DX, AX			;		MOV  AX, 017BFh			;		MOV  DX, 0FF54h 		;		OUT  DX, AX			;		MOV  AX, 0C003h			;Sets: Continous running		MOV  DX, 0FF56h			;      ALT		OUT  DX, AX			;      Inhibit'						;		MOV  CX, 0Ah			;Long delay: warns user to lookTmpErrTone1:	MOV  AX, CX			;  at Maint. panel		MOV  CX, 0FFFFh			;TmpErrTone2:	LOOP TmpErrTone2		;		MOV  CX, AX			;		LOOP TmpErrTone1		;						;		MOV  AX, 04003h			;Turn speaker off		MOV  DX, 0FF56h			;		OUT  DX, AX			;		MOV  AX, ES			;Restore AX		JMP  DI				;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~; Resets the UART then sets up for UART turn around Test;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~UARTTrnArndTst:	MOV  AX, resetUmbilicalController;		OUT  WriteResetReg, AX	 	;Enable Bermuda/KbLoopBack/UART		MOV  CX,0FFh			;		UARTTrnArndTst1:LOOP UARTTrnArndTst1		;Delay		MOV  AX, resetUmbilicalController+EnableKeyboardLoopback+ resetKeyboardUART;		OUT  WriteResetReg, AX	 	;Enable Bermuda/KbLoopBack/UART		MOV  CX,0FFh			;UARTTrnArndTst1a:LOOP UARTTrnArndTst1a		;Delay		MOV  Al,4Eh			;Set up UART mode:			OUT  KeyBdUartCtl,Al		;  Async Mode,						;  8bits data,							;  no parity,						;  1 stop bit						;Note: baud rate= 9600		MOV  CX,0FFh			;DelayUARTTrnArndTst3:LOOP UARTTrnArndTst3		;		MOV  Al,37h			;Set up UART Command:		OUT  KeyBdUartCtl,Al		;  Transmit enable						;  Data Terminal Ready (DTR)						;  Reciever Enable (RxRDY)						;  Err Reset (reset all errs)						;  Request to Send (RTS)		MOV  CX,0FFh			;UARTTrnArndTst4:LOOP UARTTrnArndTst4		;Delay		RET				;						;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;Verifies the checksum of the EEPROM;IF err: Sets ErrFlag1 flag;AX: computed check sum;AX: Observed check sum;~~~~~~~~~~~~~~~~~~~~~~						;VerifyEEPROM:	XOR  BX, BX			;BX_ Addr 0		XOR  SI, SI			;SI_ Addr 0		MOV  CX, 040h			;SI_ Addr 0;		MOV  DS:WORD PTR DisplayValue, 08888hVerifyEEPROM1:	CALL ReadEEProm			;		MOV  DS:WORD PTR DataBuff[SI], AX;Store AX away		INC  BX				;DI_ next EEPROM address		ADD  SI, 2			;SI_ next buffer address		LOOP VerifyEEPROM1 		;						;		CALL GenEEPChcksum		;yes-Generate checksum						;AX=checksum, SI=checksum ptr		MOV  BX, DS:WORD PTR DataBuff[SI];Get checksum		CMP  AX, BX			;Checksum OK?		JNE  VerifyEEPROMErr		;no		ADD  SI, 2			;yes		MOV  BX, DS:WORD PTR DataBuff[SI];Get inverted checksum		NOT  AX				;		CMP  AX, BX			;Checksum OK?		JE   VerifyEEPROM2		;no						;VerifyEEPROMErr:;		MOV  DS:WORD PTR DisplayValue, 08800h		MOV  AX, DiagLEDsTo2		;AX¬ 2		OUT  WriteConfigReg, AX		;Output 010 to front panel LEDs		CALL ErrTone			;		MOV  DS:BYTE PTR ErrFlag1, 01h	;Set Err flag		OR   prebootSwitches, dontTrustEEPromVerifyEEPROM2:	RET				;						;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 						;IOPEInROM		ENDS						;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~END
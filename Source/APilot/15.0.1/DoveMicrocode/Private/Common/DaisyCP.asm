$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1987 by Xerox Corporation. All rights reserved.;-- DaisyCP.asm;-- last edited by:;--  RDH  22-Jan-86 12:06:22 ;Create from parts of DazeBoot.asm. NAME			DaisyCP;--------------------------------------------------------------------------------;$NOLIST;$INCLUDE		(EthHdFce.asm)	$INCLUDE		(HardDefs.asm)	$INCLUDE		(IOPDefs.asm)	$INCLUDE		(IOPMacro.asm)$INCLUDE		(RAMBDefs.asm)	;$INCLUDE		(EthBDefs.asm)	;$INCLUDE		(Handlers.asm)	;to resolve handler IDs;$INCLUDE		(CSBankDf.asm)	;$INCLUDE		(RAMEEP.asm)	$LIST;--------------------------------------------------------------------------------BootStrapIOR		SEGMENT	COMMONEXTRN			firstMicrocodeData: WORD	EXTRN			secondMicrocodeData: WORD	EXTRN			thirdMicrocodeData: WORD	EXTRN			firstMicrocodeInitAddr: WORD	EXTRN			secondMicrocodeInitAddr: WORD	EXTRN			firstMicrocodeStartAddr: WORD	EXTRN			secondMicrocodeStartAddr: WORD	EXTRN			IncSIFarProc: WORD	BootStrapIOR		ENDS;--------------------------------------------------------------------------------IOPEInRAM		SEGMENT		PUBLIC			ASSUME	CS:IOPEInRAM			ASSUME	DS:BootStrapIOR;-------------------------------------------------------------------------------PUBLIC			DaisyCPConditioningPUBLIC			WriteDaisyControlStorePUBLIC			InitDaisyCPPUBLIC			StartDaisyCPEXTRN	LoadAXFromBootBuf: NEAREXTRN	LoadAXFromBootBufLateEntry: NEAREXTRN	LoadCXFromBootBuf: NEAREXTRN	LoadCXFromBootBufLateEntry: NEAR;-------------------------------------------------------------------------------DaisyCPCond	PROC	FARDaisyCPConditioning:	CALL	DaisyCPHalt			CLI			%Reset	(resetMesaProcessor)	;toggle CM reset line			CALL	DaisyCPHalt			STI			RET			DaisyCPCond	ENDP;-------------------------------------------------------------------------------;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	AH = z000 - remaining bit to be tested.			|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type.					|;--------------|								|;-------------------------------------------------------------------------------WriteControlStoreDaisy	PROC	FARWriteDaisyControlStore:	MOV	BP, ES: [BX][SI]		;get bank into hi nib of BP			SHL	BP, 8	;(bank in the bootbuf is in the high byte)			CALL DWORD PTR	IncSIFarProc			;skip lo bank...			CALL	LoadAXFromBootBuf		;get addr into lo nibs of BP			AND	AX, 0FFFH			OR	BP, AX			CALL	LoadCXFromBootBuf		;get count into CXWriteDaisyCS:		PUSH	CX				CALL	WriteCSWord			POP	CX			INC	BP			LOOP	WriteDaisyCS			CALL DWORD PTR	IncSIFarProc			;bump to start of next...			RET								 WriteControlStoreDaisy	ENDP;output data to S-chip shift register.;DI=offset of BindweedBuffer, BX=Control Store AddressWriteCSWord:		CALL	LoadAXFromBootBuf	;get first data word			MOV	firstMicrocodeData, AX			CALL	LoadAXFromBootBuf	;get second data word			MOV	secondMicrocodeData, AX			CALL	LoadAXFromBootBuf	;get third data word			MOV	thirdMicrocodeData, AX			MOV	AX,  CSShift			OUT	SiriusPort, AX		;			MOV	DX, thirdMicrocodeData	;			CALL 	ShiftCSWordOut		;shift in 48 bits of Control Store Data			MOV	DX, secondMicrocodeData	;      			CALL	ShiftCSWordOut		;			MOV	DX, firstMicrocodeData	;       			CALL	ShiftCSWordOut		;			MOV	DX, BP			;shift in CONTROL STORE ADDRESS 			CALL	CSBankOut			CALL	ShiftCSWordOut		;shift in 16 bits of BS and NIA			MOV	AX, CSShift		; disable S Chip output buffers			OUT	SiriusPort, AX				MOV	AX, Ram+NCSShift	; enable Bank Select and Write enables			OUT	SiriusPort, AX		;			;This allows the BS bits to enable the proper bank's Chip Selects 			; and turns on the write enable to the bank.  Initially, nonsense is 			; written.  The idea is to select a bank while keeping the control 			; store chip data outputs disabled.			;Send write data from S Chip with Write enable and bank select still on.  			MOV	AX,  CSDOe+Ram+NCSShift+IOPInt	;Actual writing happens now.			OUT	SiriusPort, AX		;			;Turn off write enables and bank select while leaving output data enabled.			MOV	AX,  CSDOe+IOPInt	;This satisfies RAM hold time.			OUT	SiriusPort, AX		;			MOV	AX,  CSShift		; turn off everything			OUT	SiriusPort, AX		;WriteCSWordDone:	RET;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	AH = z000 - remaining bits to be tested.		|;--------------|	AL = xxxx - remaining bits to be dumped in this case.	|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type.					|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------DaisyInitializeCP		PROC	FARInitDaisyCP:		CALL	LoadAXFromBootBuf	;get first addr to init from			MOV	firstMicrocodeInitAddr, AX			CALL	LoadAXFromBootBuf	;get second addr to init from			MOV	secondMicrocodeInitAddr, AX			CALL	DaisyCPStart			%WaitForInterrupt	(1)	;init routines should take < 1 sec			CALL	DaisyCPHalt			CALL DWORD PTR	IncSIFarProc	;bump to start of next...			RETDaisyInitializeCP		ENDP;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	AH = z000 - remaining bits to be tested.		|;--------------|	AL = xxxx - remaining bits to be dumped in this case.	|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type.					|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------DaisyStartCPBlock	PROC	FAR;Load CP address for Daisy before leaving this procedure.StartDaisyCP:	CALL	LoadAXFromBootBuf		MOV	firstMicrocodeStartAddr, AX		CALL	LoadAXFromBootBuf		MOV	secondMicrocodeStartAddr, AX		CALL 	DWORD PTR IncSIFarProc		RETDaisyStartCPBlock	ENDP							;-------------------------------------------------------------------------------						DaisyCPStart		PROC	NEARDaisyCPStartInternal:	CALL	WriteSiriusStartAddress			CALL	StartSirius			MOV	CL, 0				RETDaisyCPStart		ENDP							;-------------------------------------------------------------------------------						DaisyCPHalt		PROC	NEARDaisyCPHaltInternal:	CALL	StopCP			MOV	CL, BytesInShiftRegister + 1			RETDaisyCPHalt		ENDP							;-------------------------------------------------------------------------------						;stop the SChip.StopCP:			MOV	Ax, NCSShift	;Assert Halt			OUT	SiriusPort, Ax			CALL	Delay		;WAIT 38 cycles       			RET		Delay:	SHL AX,15			RET								;-------------------------------------------------------------------------------						;start up the SChip.StartSirius:		MOV	AX,  NCSShift				OUT	SiriusPort, AX	;allow first uInstr to be fetched			NOP			;wait while uInstr is fetched			MOV	AX,  NCSShift+NHalt	;Deassert Halt			OUT	SiriusPort, AX       			RET							;-------------------------------------------------------------------------------						;shift microinstruction start addresses out to SChip.WriteSiriusStartAddress:MOV	AX,  CSShift			OUT	SiriusPort, AX		;Assert CSShift'			MOV	DL, 0			;get first byte of data (trash ok)			MOV	CX, 3			;loop counter for 16 bit word			CALL	ShiftCSWordOutX		;CSParity/ExtInt/EOPTrap			MOV	DX, secondMicrocodeInitAddr;2nd uinstr to be started			CALL	CSBankOut 			CALL	ShiftCSWordOut		;write address of 2nd uInstr			CALL	ShiftCSWordOut		;shift in 48 bits to fill the      		 	CALL	ShiftCSWordOut		; CSData portion of the shift register			CALL	ShiftCSWordOut		; with garbage data			MOV	DX, firstMicrocodeInitAddr;1st uinstr to be started			CALL	CSBankOut			CALL	ShiftCSWordOut		;write address of 1st uInstr.			RET;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|								|;--------------|	AX = input data left justified.				|;--------------|	CX = count of data to shift.				|;--------------|								|;--------------|--------							|;--------------|								|;--------------|	DX was trashed here.					|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;shift 16 bits contained in DX into the Sirius shift register;Word to be written stored in DX, AL used for IO, CX used as a loop counterShiftCSWordOut:		MOV	CX, 16		; loop counter for 16 bit wordShiftCSWordOutX:	ROL	DX, 12		; rotate LSB of word to bit 12 ShiftCSWordOutLoop:	MOV	AX, SData	;bit 12 mask in low byte     			AND	AX, DX		;mask out bit 12 			OR	AX, SClock+CSDOe				OUT	SiriusPort, AX	;rising edge of clock with CS Parity			XOR	AX, SClock		       			OUT	SiriusPort, AX	; falling edge of clock pulse with data bit			ROR	DX, 1		;shift next data bit to bit 12			LOOP	ShiftCSWordOutLoop		ShiftCSWordOutDone:	RET;shift control store bank number (1,2,4,8) out to S-chip.CSBankOut:		MOV	AX, DX       			AND	AX, 0F000H				AND	DX, 0FFFH			MOV	CX, 1000H       			CMP	AX, CX			JE	CSBankOutDone			MOV	CX, 2000H       			CMP	AX, CX			JE	CSBankOutDone			MOV	CX, 4000H         			CMP	AX, CX			JE	CSBankOutDone			MOV	CX, 8000H       CSBankOutDone:		OR	DX, CX			RETIOPEInRAM		ENDS			END
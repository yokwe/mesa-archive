$MOD186$PAGELENGTH	(72)$PAGEWIDTH	(136);Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;Ethernet boot head;stored as RAMEthBt.asm;created on 12-Sep-84 12:43:12;last edited by:;	RCH		29-Jan-87 15:44:39	;add code to PrepareforLoader for Daisy/Dove boot commonality;	JAC		 6-Jan-86 10:45:37	;add code at WatchForEnd;	RDH		28-Oct-85 12:57:25	;Add code to TransmitFrame to send an error packet to the boot server if the useStreamProtocol is set to shutUp.;	JPM		20-Sep-85  9:38:08	;Do boot buffer allocation.;	BKI		 6-Sep-85 11:53:06	;change some JMP's to SHORT's.;	BKI		 4-Sep-85 16:48:31	;Display MP codes;	JPM		15-Aug-85 13:24:48	;Use SHL 4 when setting iocbType field.;	JPM		 1-Aug-85 14:36:09	;Use GetHandlerAccess macro.;	JPM		31-Jul-85 14:33:32	;Opie redesign conversion.;	JMM		20-Jun-85 14:51:55	;New IOPLRam.asm upgrade.;	JPM		22-May-85  9:35:24	;changed for new IOPLRam;	BKI		10-Apr-85 16:56:58NAME		RAMEthBt$NOLIST$INCLUDE	(IOPDefs.asm)$INCLUDE	(QueDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(QueMacro.asm)$INCLUDE	(HardDefs.asm)$INCLUDE	(RAMBDefs.asm)$INCLUDE	(EthIOFce.asm)$INCLUDE	(EthBDefs.asm)$LISTEXTRN		BootStrapHandlerID: ABSEXTRN		EthernetHandlerID: ABS%*DEFINE	(ByteSwap	(wordToSwap))		(%wordToSwap SHL 8 OR %wordToSwap SHR 8)nsTypeField		EQU	%ByteSwap(0600H)bootServerPacketType	EQU	%ByteSwap(9)sequencedPacketType	EQU	%ByteSwap(5)ErrorPacketType		EQU	%ByteSwap(3)IOPELocalRAM	SEGMENT	AT 0EXTRN		bootType: BYTEEXTRN		bootRetryCount: WORDEXTRN		startOfBootBufferSpace: WORDEXTRN		endOfBootBufferSpace: WORDEXTRN		HandlerInitProcTable: DWORDEXTRN		baseEthernetFileID: WORDIOPELocalRAM	ENDSBootstrapIOR	SEGMENT	COMMON		ASSUME	DS:BootstrapIOREXTRN		bootStrapTask: TaskContextBlockEXTRN		bootBufferEmpty: ConditionEXTRN		bootBufferFull: ConditionEXTRN		bootDeviceIORSpace: RamEtherBootContextEXTRN		bootTask: TaskContextBlockEXTRN		finishedLoaderFileFetch: ConditionEXTRN		getBootFile: ConditionEXTRN		startOfBootBufferPool: WORDBootstrapIOR	ENDSEthernetIOR	SEGMENT	COMMONEXTRN		etherCmdAvail: ConditionEXTRN		etherInQueue: QueueBlock, etherOutQueue: QueueBlockEXTRN		inBufferAvail: ConditionEthernetIOR	ENDSBootStrapSTK	SEGMENT	COMMONEXTRN		BootStack: WORDBootStrapSTK	ENDSIOPEInRam	SEGMENT	PUBLIC		ASSUME	CS:IOPEInRamPUBLIC		RamEntryPointPUBLIC		StartBootTask			;DEBUGPUBLIC		TransmitFrameEXTRN		BootTaskInit: NEAREXTRN		DisplayMPCode: NEAREXTRN		EndOfInitial: NEAR;The boot server sends a sequence of packets constituting the remaining portion;of EtherInitialDove.db.  We immediately go into input mode to receive these;packets.  If we don't receive the next correct packet within ten seconds of;reception of the last packet, then something is very wrong and, if we haven't;exceeded the retry count, we start over from the top (transmit).  During the;allotted ten seconds, any incorrect packets are dropped on the floor.  Note;that we do not check the checksum.  We also do not send error packets.;This is the code that gets put into EtherInitialDove.db;ES:SI points to the buffer containing the first recordRamEntryPoint:					;DEBUG		ASSUME	ES:IOPELocalRAM		MOV	DI, OFFSET bootDeviceIORSpace		XOR	BX, BX;We can move the boot server ID and boot file number in a single loop;because both blocks are the same size (addrSize=bfnSize)		MOV	CX, addrSize/2		;=bfnSize/2CopyServerID:	MOV	AX, ES:[SI][BX]+srcOffset		MOV	WORD PTR [DI][BX].bootServerID, AX		MOV	AX, ES:[SI][BX]+bfnOffset		MOV	WORD PTR [DI][BX].bootFileNumber, AX		INC	BL		INC	BL		LOOP	CopyServerID		MOV	[DI].acknowledgeNumber, %ByteSwap(2)		MOV	AX, endOfBootBufferSpace		SUB	AX, maximumBootBufferSize		MOV	WORD PTR [DI].etherBufferPtr, AX		MOV	WORD PTR [DI].etherBufferPtr+2, ESNextInitialRecord:		CALL	ReceiveFrame		JC	RetryInitialBoot;see if end marker		MOV	CX, WORD PTR ES:[BX]+lengthOffset	;byte count		ROL	CX, 8			;byteswap length		SUB	CX, 30+10		;header + reply overhead		JZ	InitialLoaded		;jump if end marker		ADD	BYTE PTR bootDeviceIORSpace.acknowledgeNumber+1, 1		ADC	BYTE PTR bootDeviceIORSpace.acknowledgeNumber, 0;copy data to it's final resting place		MOV	DI, bootDeviceIORSpace.initialBufPtr		LEA	SI, ES:[BX]+bootDataOffset		ADD	bootDeviceIORSpace.initialBufPtr, CX		INC	CX			;convert to word count		SHR	CX, 1		CLD		REP	MOVS	WORD PTR ES:[DI], ES:[SI]		JMP	NextInitialRecord;error during ether booting -- wait ten seconds and retry againRetryInitialBoot:		DEC	bootDeviceIORSpace.retryCount		JZ	FatalInitialError		%WaitForTime	(tenSeconds)		JMP	bootDeviceIORSpace.romRetryEntry;retry limit exceeded -- unrecoverable errorFatalInitialError:		MOV	AX, mpInitialError		CALL	DisplayMPCodeCommitSuicide:		%Jam	(BootStrapHandlerID,OFFSET bootStrapTask)		%WaitForSystem		; never returns!InitialLoaded:	JMP	StartBootTaskPhysicalAddrFromLogical	PROC	NEAR;Description:	Converts IOP logical address into a 24-bit real address.;Arguments:	CX:	Segment part of IOP logical address;		DX:	Offset part of IOP logical address;Returns:	CL:DX	24-bit real address		PUSH	AX		MOV	AX, CX		ROL	AX, Nibble		MOV	CL, AL		AND	AL, HighNibbleMask		ADD	DX, AX		ADC	CL, 0		AND	CL, LowNibbleMask	;Delete when HW mapping works;		OR	CL, 0F0H		The IOP real address space						;starts at 0F00000H		POP	AX		RETPhysicalAddrFromLogical	ENDPReceiveFrame	PROC	NEAR;Arguments:	see bootDeviceIORSpace;Returns:	C flag:	set => error;		ES:BX:	Pointer to buffer containing received frame;make IOCB into receive IOCB		MOV	DI, OFFSET bootDeviceIORSpace.etherIOCB		MOV	[DI].iocbType, iocbInput SHL 4		MOV	[DI].iocbVariant.bufLength, maximumBootBufferSize;set iocb.bufAddr		MOV	BX, OFFSET bootDeviceIORSpace		MOV	CX, WORD PTR [BX].etherBufferPtr+2		MOV	DX, WORD PTR [BX].etherBufferPtr		CALL	PhysicalAddrFromLogical		MOV	CH, iopLogicalOpieAddress		MOV	[DI].iocbVariant.bufAddr.OpieAddressLow, DX		MOV	[DI].iocbVariant.bufAddr.OpieAddressHigh, CX;initialize no response timer to ten seconds		%GetIntervalTimer		ADD	AX, tenSeconds		MOV	[BX].noResponseTimer, AX;if no response within ten seconds, jump to EtherRcvErrorCheckRcvTimer:	%GetIntervalTimer		SUB	AX, bootDeviceIORSpace.noResponseTimer		JS	NotifyHandlerTimerExpired:;error -- store error informationEtherRcvError:	STC		RET;notify the handlerNotifyHandler:		PUSH	AX		PUSH	ES;enqueue the input IOCB		%EstablishHandlerAccess	(EthernetHandlerID)		ASSUME	ES:EthernetIOR		MOV	etherInQueue.queueNext.OpieAddressLow, OFFSET bootDeviceIORSpace.etherIOCB		MOV	etherInQueue.queueNext.OpieAddressHandlerID, LOW BootStrapHandlerID		MOV	etherInQueue.queueNext.OpieAddressType, IOPIORegionOpieAddress		POP	ES		ASSUME	ES:IOPELocalRAM		%NotifyHandlerCondition	(EthernetHandlerID,OFFSET inBufferAvail)		POP	AX;set timeout on condition variable to time remaining on no response timer		NEG	AX		;change to positive value		%WaitForCondition	(OFFSET bootDeviceIORSpace.etherIOCBDone,AX);check for frame received or timeout		JC	EtherRcvError		;jump if timeout;check to see if the frame was received successfully		TEST	bootDeviceIORSpace.etherIOCB.iocbStatus, MASK iocbOkay		JZ	DropOnFloorCheckPacketValidity:		LES	BX, bootDeviceIORSpace.etherBufferPtr;check or save the boot server ID?CheckBootServerID:		LEA	DI, ES:[BX]+srcOffset		MOV	SI, OFFSET bootDeviceIORSpace.bootServerID		MOV	CX, addrSize/2		;addrSize is a byte countMulticastAddr	RECORD	multicastBit:1, unused:7		PURGE	unused		TEST	BYTE PTR [SI], MASK multicastBit		JNZ	SaveBootServerID;compare the boot server IDCompareBootServerID:		CLD		REPE	CMPSW		JE	CheckDataLinkType;not an acceptable packet -- drop it on the floorDropOnFloor:	JMP	CheckRcvTimer;save the boot server ID for comparison with subsequent packetsSaveBootServerID:		MOV	AX, ES:[DI]		MOV	[SI], AX		INC	DI		INC	DI		INC	SI		INC	SI		LOOP	SaveBootServerIDCheckDataLinkType:;check to see if this is an NS packet		CMP	WORD PTR ES:[BX]+typeFieldOffset, nsTypeField		JNE	DropOnFloor		CMP	bootDeviceIORSpace.useStreamProtocol, true		JE	CheckConnectionID;compare the boot file number to the one for the initial packetCheckBootFileNumber:		LEA	DI, ES:[BX]+bfnOffset		MOV	SI, OFFSET bootDeviceIORSpace.bootFileNumber		MOV	CX, bfnSize/2		;words		CLD		REPE	CMPSW		JNE	DropOnFloor;compare the sequence number to the one expectedCompareSequenceNumber:		MOV	AX, ES:[BX]+simpleSeqNumberOffset		CMP	AX, bootDeviceIORSpace.acknowledgeNumber;ToDo: Perhaps jump to EtherRcvError if observed number > expected number		JNE	DropOnFloor		JMP	SHORT SetRcvSuccessCheckConnectionID:		MOV	AX, ES:[BX]+dstConnectIDOffset		CMP	AX, bootDeviceIORSpace.srcConnectionID		JNE	DropOnFloor;ToDo: Perhaps it is not necessary to check the source connect ID		CMP	bootDeviceIORSpace.compareConnectionID, false		JE	SetRcvSuccess		MOV	AX, ES:[BX]+srcConnectIDOffset		CMP	AX, bootDeviceIORSpace.dstConnectionID		JNE	DropOnFloor;this is an acceptable packetSetRcvSuccess:	CLC		RETReceiveFrame	ENDPCalcChecksum	PROC	NEAR;Arguments:	ES:DI	offset of word-aligned buffer;		CX:	length of buffer (words);Returns:	AX:	word checksumunChecksummed	EQU	0FFFFH		PUSH	DX		XOR	AX, AXSumNextWord:	MOV	DX, ES:[DI]		ROL	DX, 8		;byteswap word;The following sequence is the checksum algorithm		ADD	AX, DX		ADC	AX, 0		ROL	AX, 1		INC	DI		INC	DI		LOOP	SumNextWord		CMP	AX, unChecksummed		JNE	ChecksumExit		XOR	AX, AXChecksumExit:	ROL	AX, 8			;byteswap checksum		POP	DX		RETCalcChecksum	ENDPTransmitFrame	PROC	NEAR;Arguments:	see bootDeviceIORSpace;Returns:	C flag:	set => error		LES	BX, bootDeviceIORSpace.etherBufferPtr		MOV	DI, BX		MOV	AX, 0		MOV	CX, levelTwoOffset		CLD		REP	STOSW;insert destination and source IDs into buffer		MOV	DI, BX		MOV	SI, OFFSET bootDeviceIORSpace.bootServerID		XOR	BX, BX		MOV	CX, addrSize		MOV	DX, ReadHostPromSetDestSource:	MOV	AL, [SI][BX]		MOV	ES:[DI][BX]+dstOffset, AL		MOV	ES:[DI][BX]+dstHostOffset, AL		IN	AL, DX		MOV	ES:[DI][BX]+srcOffset, AL		MOV	ES:[DI][BX]+srcHostOffset, AL		INC	BX		INC	DX		INC	DX		LOOP	SetDestSource		MOV	AX, [SI][BX]		;set destination socket		MOV	BX, DI		MOV	ES:[BX]+dstSocketOffset, AX;set invariant part of packet		MOV	WORD PTR ES:[BX]+typeFieldOffset, nsTypeField;		MOV	WORD PTR ES:[BX]+dstSocketOffset, %ByteSwap(10)		MOV	WORD PTR ES:[BX]+srcSocketOffset, %ByteSwap(40H);set variant (simple vs stream protocol) part of packet		CMP	bootDeviceIORSpace.useStreamProtocol, true		JE	SetSPPPacketCheckForShutUp:		CMP	bootDeviceIORSpace.useStreamProtocol, shutUp		JE	DoShutup	;Send error packet to shut up boot server		MOV	WORD PTR ES:[BX]+lengthOffset, %ByteSwap(40)		MOV	WORD PTR ES:[BX]+packetTypeOffset, bootServerPacketType		MOV	SI, OFFSET bootDeviceIORSpace.etherBootPacketType		MOV	WORD PTR [SI], %ByteSwap(3)	;stream request		MOV	CX, 5		JMP	SHORT SetLevelTwo		DoShutup:		MOV	WORD PTR ES:[BX]+lengthOffset, %ByteSwap(34)		MOV	WORD PTR ES:[BX]+packetTypeOffset, ErrorPacketType		MOV	SI, OFFSET bootDeviceIORSpace.connectionControl		MOV	WORD PTR [SI], %ByteSwap(2)	;unknown socket.  Make boot server close connection		MOV	WORD PTR [SI+2], %ByteSwap(0)	;error parameter. Unused.		MOV	CX, 2			JMP	SHORT SetLevelTwo		SetSPPPacket:	MOV	WORD PTR ES:[BX]+lengthOffset, %ByteSwap(42)		MOV	WORD PTR ES:[BX]+packetTypeOffset, sequencedPacketType		MOV	SI, OFFSET bootDeviceIORSpace.connectionControl		MOV	CX, 6SetLevelTwo:	LEA	DI, ES:[BX]+levelTwoOffset		REP	MOVSW;insert checksum into buffer		LEA	DI, ES:[BX]+lengthOffset		MOV	CX, ES:[DI]		ROL	CX, 8			;byteswap length		SHR	CX, 1			;bytes -> words		DEC	CX			;don't include checksum word		CALL	CalcChecksum		MOV	ES:[BX]+checksumOffset, AX;insert buffer ptr into IOCB		MOV	CX, ES		MOV	DX, BX		CALL	PhysicalAddrFromLogical		MOV	CH, iopLogicalOpieAddress		MOV	DI, OFFSET bootDeviceIORSpace.etherIOCB		MOV	[DI].iocbVariant.bufAddr.OpieAddressHigh, CX		MOV	[DI].iocbVariant.bufAddr.OpieAddressLow, DX		MOV	[DI].iocbVariant.bufLength, frameMinSize		MOV	[DI].iocbType, iocbOutput SHL 4;queue the IOCB		PUSH	ES		%EstablishHandlerAccess	(EthernetHandlerID)		ASSUME	ES:EthernetIOR		MOV	CH, IOPIORegionOpieAddress		MOV	CL, LOW BootStrapHandlerID		MOV	DX, DI		%EnQueue	(etherOutQueue,nextIOCB,preserveES)		%NotifyHandlerCondition	(EthernetHandlerID,OFFSET etherCmdAvail)		%WaitForCondition	(OFFSET bootDeviceIORSpace.etherIOCBDone,noTimeout)		%DeQueue	(etherOutQueue,nextIOCB,preserveES)		POP	ES		ASSUME	ES:IOPELocalRAM;check to see if the frame was transmitted successfully		MOV	DI, OFFSET bootDeviceIORSpace		TEST	[DI].etherIOCB.iocbStatus, MASK iocbOkay		JZ	EtherXmitError;successful transmission;		ADD	BYTE PTR bootDeviceIORSpace.sequenceNumber+1, 1;		ADC	BYTE PTR bootDeviceIORSpace.sequenceNumber, 0		CLC		RETEtherXmitError:	STC		RETTransmitFrame	ENDPEstablishSPPConnection	PROC	NEAR		MOV	bootDeviceIORSpace.useStreamProtocol, false		MOV	bootDeviceIORSpace.dstSocket, %ByteSwap(10)		%GetIntervalTimer	;ToDo: more unique connection ID		MOV	bootDeviceIORSpace.connectionID, AX		MOV	bootDeviceIORSpace.srcConnectionID, AX		CALL	TransmitFrame		MOV	bootDeviceIORSpace.useStreamProtocol, true		MOV	bootDeviceIORSpace.compareConnectionID, false		CALL	ReceiveFrame		JC	ConnectionError		CMP	WORD PTR ES:[BX]+streamSeqNumberOffset, %ByteSwap(0)		JNE	ConnectionError		MOV	AX, ES:[BX]+srcSocketOffset		MOV	bootDeviceIORSpace.dstSocket, AX		MOV	AX, ES:[BX]+srcConnectIDOffset		MOV	bootDeviceIORSpace.dstConnectionID, AX		MOV	bootDeviceIORSpace.compareConnectionID, true;successful connection		CLC		RETConnectionError:		STC		RETEstablishSPPConnection	ENDPbufferOverhead		EQU		6;allocate boot bufferStartBootTask:	MOV	DI, startOfBootBufferSpace		ADD	DI, OFFSET EndOfInitial+bootDataOffset		MOV	startOfBootBufferPool, DI		MOV	ES:[DI].nextBootBuffer, DI		MOV	ES:[DI].bootDataStart, Null		MOV	ES:[DI].bootDataEnd, Null		ADD	DI, maximumBootBufferSize+bufferOverhead		MOV	startOfBootBufferSpace, DI		MOV	AX, mpRunInitial		CALL	DisplayMPCode		%Restart	(BootStrapHandlerID,OFFSET bootTask,BootTaskInit,OFFSET BootStack)		%WaitForCondition	(OFFSET getBootFile,noTimeout)		MOV	BX, OFFSET bootDeviceIORSpace		MOV	[BX].retryCount, 10bfnSuffix	EQU	5diagSuffix	EQU	008HemulatorSuffix	EQU	010H		MOV	AL, emulatorSuffix		CMP	bootType, normal;Boot		JE	SetBootFileSuffix		MOV	AL, diagSuffixSetBootFileSuffix:		OR	[BX].bootFileNumber+bfnSuffix, ALFetchBootFile:		MOV	[BX].retryCount, 10		XOR	AX, AX		MOV	[BX].datastreamType, AL		MOV	[BX].sequenceNumber, AX		;%ByteSwap(0)		MOV	[BX].acknowledgeNumber, AX	;%ByteSwap(0)		MOV	[BX].allocationNumber, %ByteSwap(4)		MOV	DI, startOfBootBufferPool		LEA	AX, ES:[DI].bootData		MOV	WORD PTR [BX].etherBufferPtr, AX		MOV	WORD PTR [BX].etherBufferPtr+2, ES		MOV	WORD PTR [BX].emptyBootBuffer, DI		MOV	WORD PTR [BX].emptyBootBuffer+2, ES		%WaitForTime	(2000)		;ToDo: Why is this necessary?		JMP	SHORT ConnectWithBootServerFatalEmulatorOrLoaderError:		MOV	AX, mpMesaDoveError		CALL	DisplayMPCode		JMP	CommitSuicideRetryRequestFile:;This can be a fairly intelligent error retry routine		DEC	bootDeviceIORSpace.retryCount		JZ	FatalEmulatorOrLoaderError		%WaitForTime	(tenSeconds)ConnectWithBootServer:		CALL	EstablishSPPConnection		JC	RetryRequestFile		LES	DI, bootDeviceIORSpace.emptyBootBufferCheckIfBufferFree:;ES:DI points to next boot buffer		MOV	BX, OFFSET bootDeviceIORSpace		LEA	AX, ES:[DI].bootData		MOV	WORD PTR [BX].etherBufferPtr, AX		MOV	WORD PTR [BX].etherBufferPtr+2, ESIsBufferFree:	MOV	AX, ES:[DI].bootDataStart		CMP	ES:[DI].bootDataEnd, AX		JE	CheckSendAck		%WaitForCondition	(OFFSET bootBufferEmpty,noTimeout)		LES	DI, bootDeviceIORSpace.emptyBootBuffer		TEST	getBootFile.TCBLinkPtr, preNotifyFlag		JNZ	WatchForEnd		JMP	IsBufferFreeCheckSendAck:	CMP	bootDeviceIORSpace.sendAcknowledgement, false		JE	ReceiveRecord		MOV	bootDeviceIORSpace.connectionControl, MASK systemPacket		CALL	TransmitFrameReceiveRecord:	CALL	ReceiveFrame		JC	FatalEmulatorOrLoaderError		MOV	bootDeviceIORSpace.sendAcknowledgement, false		MOV	AL, ES:[BX]+connectionControlOffset		TEST	AL, MASK sendAckControl		JZ	CheckSystemPacket		MOV	bootDeviceIORSpace.sendAcknowledgement, trueCheckSystemPacket:		TEST	AL, MASK systemPacket		JNZ	CheckSendAck		MOV	AX, ES:[BX]+streamSeqNumberOffset		CMP	AX, bootDeviceIORSpace.acknowledgeNumber		JNE	CheckSendAck		CALL	BumpNumbers		JE	FetchBootFileDoneDelimitBootData:bootBufferOverhead	EQU	(SIZE BootBuffer)-maximumBootBufferSize		LES	DI, bootDeviceIORSpace.emptyBootBuffer		MOV	ES:[DI].bootDataStart, bootBufferOverhead+streamBootDataOffset		MOV	AX, WORD PTR ES:[BX]+lengthOffset	;byte count		ROL	AX, 8			;byteswap length		ADD	AX, bootBufferOverhead+encapsulation		DEC	AX			;point to last byte of data		MOV	ES:[DI].bootDataEnd, AX		%NotifyCondition	(OFFSET bootBufferFull)		MOV	DI, ES:[DI].nextBootBuffer		MOV	WORD PTR bootDeviceIORSpace.emptyBootBuffer, DI		JMP	CheckIfBufferFree		BumpNumbers	PROC	NEAR		ADD	BYTE PTR bootDeviceIORSpace.acknowledgeNumber+1, 1		ADC	BYTE PTR bootDeviceIORSpace.acknowledgeNumber, 0		ADD	BYTE PTR bootDeviceIORSpace.allocationNumber+1, 1		ADC	BYTE PTR bootDeviceIORSpace.allocationNumber, 0		CMP	BYTE PTR ES:[BX]+datastreamTypeOffset, closeSST		RETBumpNumbers	ENDP;The bootTask believes that the EOF boot block and the checksum boot block are;in the same boot buffer.  If they are not the next boot buffer is considered to;be part of the germ so in order to keep this from happending once getBootFile;has been notified just ignore the rest of the packets sent, at most this should;be one. 	WatchForEnd:	CALL	ReceiveFrame		JNC	CallBumpNumber		JMP	FatalEmulatorOrLoaderErrorCallBumpNumber: CALL	BumpNumbers		JNE	WatchForEndFetchBootFileDone:		;ToDo: finish NetworkStream.CloseProtocol		MOV	WORD PTR bootDeviceIORSpace.connectionControl, closeReplySST SHL 8		CALL	TransmitFrame		CMP	bootDeviceIORSpace.fadeAfterFetch, 0FFH		JE	AllDonePrepareForLoader:		%WaitForCondition	(OFFSET getBootFile,noTimeout)		MOV	BX, OFFSET bootDeviceIORSpace				IN	AX, machineIDPort			AND	AX, machineIDMask			CMP	AX, Daisy				JNE	LoadContinue		MOV	AX, baseEthernetFileID + 4		SUB 	AX, 0C000H		MOV	baseEthernetFileID + 4, AX		MOV	AL, [BX].bootFileNumber+bfnSuffix		SUB	AL, 0C0H		MOV	[BX].bootFileNumber+bfnSuffix, AL			LoadContinue:	MOV	[BX].fadeAfterFetch, 0FFHloaderSuffix	EQU	008H		OR	[BX].bootFileNumber+bfnSuffix, loaderSuffix		JMP	FetchBootFileAllDone:		%NotifyCondition	(OFFSET finishedLoaderFileFetch)		JMP	CommitSuicideIOPEInRam	ENDS;		PURGE		END
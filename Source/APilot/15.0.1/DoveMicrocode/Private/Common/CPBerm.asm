$MOD186$PAGELENGTH (95)$PAGEWIDTH  (136);Copyright (C) 1984, 1987 by Xerox Corporation. All rights reserved.;-- stored as [BamBam:OSBU North:Xerox]<WMicro>Dove>CPBermuda.asm;-- created on   3-Jan-85 16:29:56; IOP code used by the CP debugger for reading and writing control store and stopping and starting the CP.;-- last edited by:; JAC		27-Jan-87 15:31:39	;add Daisy stuff; RDH		31-Jan-86 12:42:45	;ReRedo SetPortAddress for multibank; RDH		12-Dec-85 13:01:12	;Redo SetPortAddress for multibank; JAC		23-Oct-85 19:04:38	;for reconfigurable Opie; JAC		24-Jun-85 11:25:40	;don't include MoonSys.def; FXB   .PA	27-Feb-85 13:16:39	;don't reset before every start; FXB   .PA	25-Feb-85 15:10:07	;fixed starting; FXB   .PA	22-Feb-85  9:48:39	:implemented ResetCP; FXB   .PA	 6-Feb-85 15:27:59	:fixed up starting and stopping; FXB   .PA	 1-Feb-85 16:22:33	:fixed FAR RET problem in WriteCSWord; FXB   .PA 	 7-Jan-85 13:34:20; FXB   .PA	 7-Jan-85 11:17:34NAME	DayBrkCP$NOLIST$INCLUDE(HardDefs.asm)$INCLUDE(IOPDefs.asm)$INCLUDE(IOPMacro.asm)$LISTEXTRN		CPBermudaHandlerID: ABSCPBermudaSTK		SEGMENT COMMONEXTRN			CPBermudaStack: WORDCPBermudaSTK		ENDSCPBermudaIOR		SEGMENT COMMONEXTRN			CPBermudaTask:	TaskContextBlockCPBermudaIOR		ENDSIOPEInLocalRAM		SEGMENT AT 0EXTRN			BindweedBuffer: BYTEIOPEInLocalRAM		ENDSIOPEInRAM	SEGMENT	WORD PUBLIC 		ASSUME	CS:IOPEInRAM;Daybreak definitions	ReadDaybreakControlStoreVector 	EQU 17*4StartDaybreakVector 		EQU 18*4StopDaybreakVector		EQU 20*4WriteDaybreakControlStoreVector	EQU 21*4ResetDaybreakVector		EQU 24*4	; The following definitions were taken from MoonSys.defDayBreakPort			EQU 0B0hHaltOnBit			EQU 00HReadPNIA			EQU 400HNoBits				EQU 200HCSStartPort			EQU 8000hBankPort			EQU 0E000h;Machine independent definitionsResetPort			EQU 0C0HBytesPerMicroInstruction	EQU 6NoResets			EQU 3FFHResetMesa			EQU 3BFH;Daisy definitions	ReadSiriusControlStoreVector 	EQU 17*4StartSiriusVector 		EQU 18*4StopSiriusVector		EQU 20*4WriteSiriusControlStoreVector	EQU 21*4ResetSiriusVector		EQU 24*4	BytesInShiftRegister		EQU 6;Data from control store is port 080H bit 13 i.e. CSReadPort	EQU	080H 	;bit 13 contains data from Sirius shift registerSiriusPort	EQU	0B0H 	;The port for controlling the Sirius chip;bit 7: RAMWrEnable;bit 6: CSShift';bit 5: CSDOe;bit 4: shift data;bit 3: ShiftClk;bit 2: Halt';bit 1: ResetSChip';bit 0: IOPIntSChipRam		EQU  8000HNCSShift	EQU  4000HCSShift		EQU  0CSDOe		EQU  2000HSData		EQU  1000HSClock		EQU  800HNHalt		EQU  200HIOPInt		EQU  100HCSDataBit	EQU  2000HPUBLIC	CPBermudaInitCPBermudaInit	PROC	FAR	IN	AX, machineIDPort		;machine we are on because	AND	AX, machineIDMask		;VMM, IORegion and display	CMP	AX, Daisy			;are in different places for	JE	DaisyInitialization	%InitializeTask	(CPBermudaHandlerID,OFFSET CPBermudaTask,DayBrkCP,OFFSET CPBermudaStack)		RETDaisyInitialization:	%InitializeTask	(CPBermudaHandlerID,OFFSET CPBermudaTask,InitializeVectors,OFFSET CPBermudaStack)		RETCPBermudaInit	ENDP	DayBrkCP:	XOR	AX, AX	MOV	ES, AX				;make ES point to low RAM	MOV	AX, OFFSET StartDaybreak	;Set BX,AX to	MOV	SI, StartDaybreakVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS	MOV	AX, OFFSET StopDaybreak	;Set BX,AX to	MOV	SI, StopDaybreakVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS	MOV	AX, OFFSET ReadDaybreakControlStore	;Set BX,AX to	MOV	SI, ReadDaybreakControlStoreVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS	MOV	AX, OFFSET WriteDaybreakControlStore 	;Set BX,AX to	MOV	SI, WriteDaybreakControlStoreVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS		MOV	AX, OFFSET ResetDaybreak 	;Set BX,AX to	MOV	SI, ResetDaybreakVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS	%Jam	(CPBermudaHandlerID,OFFSET CPBermudaTask)	%WaitForSystem	RET		InitializeVectors:	XOR	AX, AX	MOV	ES, AX				;make ES point to low RAM	MOV	AX, OFFSET StartSirius		MOV	SI, StartSiriusVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS	MOV	AX, OFFSET StopSirius		MOV	SI, StopSiriusVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS	MOV	AX, OFFSET ReadSiriusControlStore		MOV	SI, ReadSiriusControlStoreVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS	MOV	AX, OFFSET WriteSiriusControlStore 	      	MOV	SI, WriteSiriusControlStoreVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS		MOV	AX, OFFSET ResetSirius 	      	MOV	SI, ResetSiriusVector	MOV	ES:[SI], AX			;Store the new IP	MOV	ES:[SI + 2], CS			;and the new CS		%Jam	(CPBermudaHandlerID,OFFSET CPBermudaTask)	%WaitForSystem	RET	;*****************************************************************************;Daybreak CP debugger Commands:;;on exit CX contains ?;on entry DI contains offset of BindweedBufferReadDaybreakControlStore:	PUSHA	MOV	DI, OFFSET BindweedBuffer	CALL	ReadCSWord		POPA	MOV	CL, BytesInShiftRegister + 1	IRET	  StartDaybreak:	PUSHA	CALL	StartCP		POPA	MOV	CL, 0	IRET	ResetCP:	CALL	StopCp	CALL	Delay	MOV	AX, ResetMesa	OUT	ResetPort, AX	CALL	StartCp	MOV	AX, NoResets	OUT	ResetPort, AX	CALL	StopCP	RET			StopDaybreak:	PUSHA	MOV	DI, OFFSET BindweedBuffer	CALL	StopCp	CALL Delay	;WAIT 38 cycles; Read the PNIA 	MOV	AX, HaltOnBit+ReadPNIA	OUT DayBreakPort,ax	CALL Delay	;WAIT 38 cycles	CALL	ReadCSWord	MOV	AX, HaltOnBit	OUT DayBreakPort,ax		POPA		MOV	CL, BytesInShiftRegister + 1	IRET		WriteDaybreakControlStore:	PUSHA	MOV	DI, OFFSET BindweedBuffer	MOV	BX, [DI].WriteCSAddress	MOV	CL, [DI].WriteCSWords	XOR	CH, CHWriteDaybreakCS:	PUSH	CX		CALL	WriteCSWord	POP	CX	ADD	DI, BytesPerMicroInstruction	INC	BX	;increment the control store address	LOOP	WriteDaybreakCS		POPA	MOV	CL, 0	IRET	ResetDaybreak:		PUSHA	CALL 	ResetCP		POPA	MOV 	CL, 0	IRET						;*******************************************************************************	StopDaybreakReplyBuffer	STRUC	junk	DB 	5 DUP (?)	InCSAddress	DW ?	InCSAddress1	DW ?	InCSData3	DB ?StopDaybreakReplyBuffer	ENDSStartDaybreakWriteBuffer	STRUC	overhead	DB	3 DUP (?)	OutCSAddress	DW	?	OutCSAddress1	DW	?	OutCSData3	DB	?StartDaybreakWriteBuffer	ENDSControlStoreReadReplyBuffer	STRUC	bwOverhead	DB	5 DUP (?)	InCSData0	DW	?	InCSData1	DW	?	InCSData2	DW	?ControlStoreReadReplyBuffer	ENDSControlStoreReadCommandBuffer	STRUC	overhead2	DB	3 DUP (?)	ReadCSAddress	DW		?ControlStoreReadCommandBuffer	ENDS		ControlStoreWriteBuffer 	STRUC	protocol	DB	3 DUP (?)	WriteCSWords	DB	?	WriteCSAddress	DW	?	OutCSData0	DW	?	OutCSData1	DW	?	OutCSData2	DW	?ControlStoreWriteBuffer	ENDS	;*******************************************************************************				StopCp: MOV	Ax, HaltOnBit	;Assert Halt	OUT	DayBreakPort, Ax        Ret      	           	;*******************************************************************************StartCp:MOV	Ax, NoBits	;Deassert Halt	OUT	DayBreakPort, Ax	;which allows first uInstr to be fetched	RET	;********************************************************************************;SUBROUTINE: WriteCSWord;;	DI: offset of BindweedBuffer;	BX: Control Store Address;WriteCSWord:	CALL	SetPortAddress 	MOV	AX, [DI].OutCSData0	;	CALL 	Write2Bytes	MOV	AX, [DI].OutCSData1	        CALL	Write2Bytes			MOV	AX, [DI].OutCSData2	        CALL	Write2Bytes		        RET;******************************************************************************;SUBROUTINE: ReadCSWord;; Read a 48-bit word from control store and store it at the address pointed to by DI;;	;ReadCSWord:	MOV	BX, [DI].ReadCSAddress	CALL	SetPortAddress 	CALL	Read2Bytes	MOV	[DI].InCSData0,AX 	;	CALL	Read2Bytes	MOV	[DI].InCSData1,AX 	;	CALL	Read2Bytes	MOV	[DI].InCSData2,AX 	;        Ret;*******************************************************************************;SUBROUTINE: SetPortAddress;; on entry BX contains control store address, on exit DX contains the correspoding I/O port; The high nibble of BX is interpreted as a bank number in [0..4); Writes bank select port and loads DX with the port address for the ; control store location in BX.; Smashes AX, CX, SI; Return value in DX.BankSelects	DB	00H, 0CH, 0AH, 09HSetPortAddress: 	MOV	si, bx 	; get CSAddress	SHR  	si, 12	; strip off lower address	MOV	al, BankSelects[si]	;Load ax with bank select bits	SetPort: 	MOV 	dx, BankPort	OUT 	dx, al 	MOV	dx, bx ;get CSAddress	AND   	dx, 0FFFH ;strip off bank info	ADD 	dx, CSStartPort 	RET	;********************************************************************************	;*******************************************************************************;SUBROUTINE: Read2BytesRead2Bytes: 	IN	al,  dx		;read Control Store Data 	MOV	ah, al	add dx,1000h	IN	al, dx		;read Control Store Data 	add dx,1000h        Ret	;********************************************************************************			;********************************************************************************;SUBROUTINE: Write2BytesWrite2Bytes: 	MOV	cl, al	MOV	al, ah	OUT	dx, al		;Write Control Store Data 	MOV	al, cl	add dx,1000h	OUT	dx, al		;Write Control Store Data 	add dx,1000h        Ret	;**************************************************************************	;*****************************************************************************;CPBermuda Daisy Commands:;;on exit CX contains ?ResetSirius:	CALL 	ResetSiriusCP		MOV 	CL, 0	IRET	ReadSiriusControlStore:	MOV	DI, OFFSET BindweedBuffer	CALL	ReadSiriusCSWord	MOV	CL, BytesInShiftRegister + 1		IRET	  StartSirius:	MOV	DI, OFFSET BindweedBuffer	CALL	WriteShift	CALL	StartSiriusCP	MOV	CL, 0		IRET		StopSirius:	MOV	DI, OFFSET BindweedBuffer	CALL	StopSiriusCP	CALL	ReadShift	MOV	CL, BytesInShiftRegister + 1	IRET		WriteSiriusControlStore:	PUSH	BX	MOV	DI, OFFSET BindweedBuffer	MOV	BX, [DI].WriteCSAddress	MOV	CL, [DI].WriteCSWords	XOR	CH, CHWriteSiriusCS:	PUSH	CX		CALL	WriteSiriusCSWord	POP	CX	ADD	DI, BytesPerMicroInstruction	INC	BX	LOOP	WriteSiriusCS	POP	BX	MOV	CL, 0	IRET			Delay: 	SHL 	AX, 15       	RET	StopSiriusCP: 	MOV	AX, NCSShift     	;Assert Halt	OUT	SiriusPort, AX	CALL 	Delay			;WAIT 38 cycles        RET		ResetSiriusCP:	MOV	AX, NCSShift     	;Assert Halt 	OUT	SiriusPort, AX	CALL 	Delay			;WAIT 38 cycles	%Reset(resetMesaProcessor)       ;MOV	Ax, ResetMesa            ;Assert Halt and Reset       ;OUT     ResetPort, AX;KDelay:	MOV	CX, 0FFH	get mode reg bits	;KDelay1: LOOP	KDelay1			write mode reg bits       ;MOV	AX, NoResets       ;OUT     ResetPort, AX	MOV	AX, NCSShift    	 ;Assert Halt	OUT	SiriusPort, AX        RET		;***************************************************************************;SUBROUTINE: ReadShift;;on entry: DS = 0 DI = index into low RAM ;DX used to store shift register data;;ReadShift:	MOV	CX, 3	CALL 	ShiftWordInX		;get EOPTrap/ExtInt/CSParity bits	ROR	DX, 5			  	MOV	[DI].InCSData3, DH	CALL 	ShiftWordIn		CALL	BankIn 	MOV	[DI].InCSAddress1, DX	;save BSp2Hold and NIAp2Hold	CALL 	ShiftWordIn		;shift out and discard	CALL 	ShiftWordIn		;48 bits of old CSData from 	CALL 	ShiftWordIn		;the shift register	CALL 	ShiftWordIn		CALL	BankIn 	MOV	[DI].InCSAddress, DX	;Save BS and NIA	MOV	AX,  CSShift		;Deassert control store output enable	OUT	SiriusPort, AX        Ret	;*******************************************************************************	;StopSiriusReplyBuffer	STRUC			Use the Daybreak definition;	junk1		DB 	5 DUP (?);	InCSAddress 	DW ?;	InCSAddress1	 DW ?;	InCSData3	DB ?;StopSiriusReplyBuffer	ENDS;StartSiriusWriteBuffer	STRUC			Use the Daybreak definition;	overhead1	DB	3 DUP (?);	OutCSAddress	DW	?;	OutCSAddress1	DW	?;	OutCSData3	DB	?;StartSiriusWriteBuffer	ENDS;ControlStoreReadReplyBuffer	STRUC		Use the Daybreak definition;	bwOverhead	DB	5 DUP (?);	InCSData0	DW	?;	InCSData1	DW	?;	InCSData2	DW	?;ControlStoreReadReplyBuffer	ENDS;ControlStoreReadCommandBuffer	STRUC		Use the Daybreak definition;	overhead2	DB	3 DUP (?);	ReadCSAddress	DW		?;ControlStoreReadCommandBuffer	ENDS		;ControlStoreWriteBuffer 	STRUC		Use the Daybreak definition;	protocol	DB	3 DUP (?);	WriteCSWords	DB	?;	WriteCSAddress	DW	?;	OutCSData0	DW	?;	OutCSData1	DW	?;	OutCSData2	DW	?;ControlStoreWriteBuffer	ENDS					       	;***************************************************************************;SUBROUTINE: WriteShift;; on entry: DS = 0 DI = index into low RAM indicating last address for data.; Addressing is done using DS as DI's default segment, may need to do use a; different pointer and have DS as the segment register	WriteShift:	MOV	AX,  CSShift	OUT	SiriusPort, AX		;Assert CSShift'	MOV	DL, [DI].OutCSData3	;get first byte of data	MOV	CX, 3		 ; loop counter for 16 bit word	CALL	ShiftWordOutX		;CSParity/ExtInt/EOPTrap        MOV	DX, [DI].OutCSAddress1	;get address of 2nd uinstr to be started	CALL	BankOut 	CALL	ShiftWordOut		;write address of 2nd uInstr to be started	CALL	ShiftWordOut		;shift in 48 bits to fill the        CALL	ShiftWordOut		;CSData portion of the shift register        CALL	ShiftWordOut		; with garbage data	MOV	DX, [DI].OutCSAddress	;shift in address	CALL	BankOut 	CALL	ShiftWordOut		;of first uinstr to be executed        RET	StartSiriusCP:	MOV	AX,  NCSShift		OUT	SiriusPort, AX		;which allows first uInstr to be fetched	NOP				;wait while uInstr is fetched and loaded	MOV	AX,  NCSShift+NHalt	;Deassert Halt	OUT	SiriusPort, AX        RET;******************************************************************************;SUBROUTINE: ReadSiriusCSWord;; Read a 48-bit word from control store and store it at the address pointed to by DI;;	;ReadSiriusCSWord:	MOV	AX,  CSShift	OUT	SiriusPort, AX		;Assert CSShift'	MOV	DX, [DI].ReadCSAddress	;get address of 2nd uinstr to be started	CALL	BankOut 	CALL	ShiftWordOut	;write address of 2nd uInstr to be started	CALL	ShiftWordOut		;shift in 48 bits to fill the 	CALL	ShiftWordOut		;CSData portion of the shift register	CALL	ShiftWordOut		; with garbage data	MOV	DX, [DI].ReadCSAddress	;shift in address	CALL	BankOut 	CALL	ShiftWordOut		;of first uinstr to be executed	MOV	AX,  NCSShift	OUT	SiriusPort, AX		;CS chips send data to Sirius		;raise and lower clock bit to load data into the CSData 	;portion of the shift register	MOV	AX,  NCSShift+SClock	OUT	SiriusPort, AX		;rising edge of clock	MOV	AX,  NCSShift		OUT	SiriusPort, AX		;falling edge of clock		MOV	AX, CSShift		;Turn off bank sel	OUT	SiriusPort, AX					CALL	SShiftWordIn	MOV	[DI].InCSData2, DX 	;	CALL	SShiftWordIn	MOV	[DI].InCSData1, DX 	;	CALL	SShiftWordIn	MOV	[DI].InCSData0, DX 	;		MOV	AX,  CSShift	OUT	SiriusPort, AX        Ret		;********************************************************************************;SUBROUTINE: WriteSiriusCSWord;; cycles: 2981;;	DI: offset of BindweedBuffer;	BX: Control Store Address;WriteSiriusCSWord:	MOV	AX, CSShift	OUT	SiriusPort, AX		;	MOV	DX, [DI].OutCSData2	;        	CALL 	ShiftWordOut		;shift in 48 bits of Control Store Data	MOV	DX, [DI].OutCSData1	;        CALL	ShiftWordOut		;	MOV	DX, [DI].OutCSData0	;        CALL	ShiftWordOut		;	MOV	DX, BX			;shift in CONTROL STORE ADDRESS         CALL	BankOut      	CALL	ShiftWordOut		;shift in 16 bits of BS and NIA		MOV	AX, CSShift		; disable S Chip output buffers	OUT	SiriusPort, AX				MOV	AX, Ram+NCSShift	; enable Bank Select and Write enables	OUT	SiriusPort, AX		;	;This allows the BS bits to enable the proper bank's Chip Selects 	;and turns on the write enable to the bank.  Initially, nonsense is 	;written.  The idea is to select a bank while keeping the control 	;store chip data outputs disabled.		MOV	AX, CSDOe+Ram+NCSShift+IOPInt	; send write data from S Chip with Write enable and bank select still on.  Actual writing happens now.	OUT	SiriusPort, Ax		;	MOV	AX, CSDOe+IOPInt	; turn off write enables and bank select while leaving output data enabled.  This satisfies RAM hold time.	OUT	SiriusPort, AX		;	MOV	AX, CSShift		; turn off everything	OUT	SiriusPort, AX		;        RET;*******************************************************************************;SUBROUTINE: ShiftWordIn;; shift 16 bits from the Sirius shift register and place them in DX;; Register usage:  Word from control store returned in DX, AL used for IO,;			CX used as a loop counter	ShiftWordIn: 	MOV	CX, 16ShiftWordInX: 	MOV	AX, CSDOe	  ;falling edge of clock pulse        OUT	SiriusPort, AX	CLCShiftWordInLoop:	IN	AX, CSReadPort		  ;read Control Store Data 	RCL	AX, 3			  ;Carry _ Control Store Data	RCR	DX, 1			  ;MSB of DX _ Control Store Data        MOV	AX, CSDOe+SClock  ;rising edge of clock pulse	OUT	SiriusPort, AX	MOV	AX, CSDOe	  ;falling edge of clock pulse	OUT	SiriusPort, AX	LOOP	ShiftWordInLoop	Ret;********************************************************************************	;SUBROUTINE: SShiftWordIn  Short Tap;; shift 16 bits from the Sirius shift register and place them in DX;; Register usage:  Word from control store returned in DX, AL used for IO,;			CX used as a loop counter	SShiftWordIn: 	MOV	CX, 16	MOV	AX,  CSDOe+IOPInt	;falling edge of clock pulse	OUT	SiriusPort, AX	CLCSShiftWordInLoop:	IN	AX, CSReadPort		        ;read Control Store Data 	RCL	AX, 3			        ;Carry _ Control Store Data	RCR	DX, 1			        ;MSB of DX _ Control Store Data	MOV	AX,  CSDOe+SClock+IOPInt	;rising edge of clock pulse	OUT	SiriusPort, AX	MOV	AX,  CSDOe+IOPInt	;falling edge of clock pulse	OUT	SiriusPort, AX	LOOP	SShiftWordInLoop	RET			;********************************************************************************;*SUBROUTINE: ShiftWordOut;;shift 16 bits contained in DX into the Sirius shift register;;*;* Register usage: Word to be written stored in DX, AL used for IO,;*			CX used as a loop counter;							ShiftWordOut:	MOV	CX, 16		 ; loop counter for 16 bit wordShiftWordOutX:	ROL	DX, 12		 ; rotate LSB of word to bit 12 ShiftWordOutLoop:	MOV	AX, SData  ;bit 12 mask in low byte     	AND	AX, DX		 ;mask out bit 12 	OR	AX,  SClock+CSDOe		OUT	SiriusPort, AX  ;rising edge of clock with CS Parity	XOR	AX, SClock		       	OUT	SiriusPort, AX	  ; falling edge of clock pulse with data bit	ROR	DX, 1		  ;shift next data bit to bit 12	LOOP	ShiftWordOutLoop		        Ret;************************************************************************** BankOut:	MOV	AX, DX       	AND	AX, 0F000H		AND	DX, 0FFFH	MOV	CX, 1000H       	CMP 	AX, 0	JE 	BankOutRet	MOV	CX, 2000H       	CMP 	AX, 1000H	JE 	BankOutRet	MOV	CX, 4000H         	CMP 	AX, 2000H	JE 	BankOutRet	MOV	CX, 8000H       BankOutRet:	OR	DX, CX	RET	BankIn:	MOV	AX, DX       	AND	AX, 0F000H		AND	DX, 0FFFH	MOV	CX, 0000H       	CMP 	AX, 1000H	JE 	BankInRet	MOV	CX, 1000H       	CMP 	AX, 2000H	JE 	BankInRet	MOV	CX, 2000H         	CMP 	AX, 4000H	JE 	BankInRet	MOV	CX, 3000H 	      BankInRet:	OR	DX, CX	RET		IOPEInRAM	ENDS		END
$DEBUG  MOD186$PAGELENGTH (72)$PAGEWIDTH (136);----------------------;;     PCPrintr.asm     ;;----------------------;; Copyright (C) 1984,1985 by Xerox Corporation. All rights reserved.; Stored as  [Iris]<WMicro>Dove>PCPrintr.asm; Last edited by:; FHB	   9-Feb-87 11:40:01	: commented out TurboPrintTask; FHB	   9-Jan-87 15:58:51	: increase wait in TurboPrintTask; FHB	  22-Dec-86 10:16:25	: Changed Locking in Turbo Print; AGK	  13-Dec-86 16:57:52	: Cleared BIOS buffer counter at boot; FHB	  13-Dec-86 13:40:07	: Fixed Register Smashing in GetLock; FHB	  21-Nov-86 18:19:17	: Turbo Charging and removing color/mono display test; AGK	  28-Aug-86 16:50:04	: deleted testCount1 increment in PrCntrlPort ; FHB	  15-Jul-86 16:34:58	: only allow LPT1 port addresses ; AGK	  15-Apr-86 14:16:13	: Changed putLock from byte to word variable; HNH	  10-Apr-86 10:24:13	: Replaced printerOperation with testCount1; HNH	   9-Apr-86 20:34:23	: Buffer Locking mechanism implementation; HNH	   5-Dec-85 17:49:55	: Modified strobe checking process to be more efficient; HNH	   4-Dec-85 13:39:07	: Changed printerStatusByte,18H when busy and MaxBufferSize to MaxBufferSize-1 for wraparound testing; HNH	   3-Dec-85 19:19:47	: Added Wraparound code to PrStatusPort; HNH	   3-Dec-85 17:41:44	: Added PCE freezing in Status when buffer overflows; HNH	   3-Dec-85 13:20:16	: Changes to PrCntrlPort and PrStatusPort, IOP code is now responsible for setting the status for the BIOS; HNH	  27-Nov-85 15:54:28	: Inserted WaitForTime and PrntDefs.asm; HNH	  26-Nov-85 14:56:19	: Fixed bug in jmp pcePrinterTaskInit , jmp pcePrinterTaskEmul; HNH	  26-Nov-85 11:56:24	: Added MOV AL, printerStatusByte in PrStatusPort; HNH	  5-Nov-85 11:42:13	: Enhanced printer changes; HNH	 14-Aug-85 15:34:50	: Changed code in PrCntrlPort to reflect more accurate hardware emulation as opposed to emulating the BIOS I/O.; JPM	13-Aug-85 15:59:53	: Separate PCE into several handlers.; JPM	12-Aug-85 12:15:35	: Change IOPEInRAM alignment to WORD.; JPM	 9-Aug-85 15:27:49	: Opie redesign conversion.; HNH	 9-Aug-85 15:05:47	: Added runPCE/printerPauseMask to PrCntrlPort part of code, this insures character was sent to printer; HNH	 8-Aug-85 15:16:10	: Edited fixes in the Printer control part of emulation; HNH	24-Jul-85 18:11:06	: Change runPCE true/false setting to printerPauseMask, using XOR and OR.; HNH	18-Jul-85 15:43:57	: Add check for printer Configuration and pcePrinterInit, pcePrinterBoot and pcePrinterExit procedures; HNH	15-Jul-85 11:25:35	: Changed initialization code to dummy proc.; HNH	19-Jun-85 15:45:58	: Creation; This module is the handler that emulates the PC Parallel Printer Adapter (PPA) card	NAME	PCEPrinterEmulator;-------------------------------------------------------------------------$NOLIST$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPDefs.asm)$INCLUDE	(PCEDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(PrntDefs.asm)$LISTEXTRN		PCEPrinterHandlerID: ABSEXTRN		PCEDispatcherHandlerID: ABS;-------------------------------------------------------------------------; Equates; Three possible printer I/O OperationsStatus 	EQU	01HStrobe 	EQU	02H;Init 	EQU	03H;-------------------------------------------------------------------------PCEPrinterIOR		SEGMENT	COMMON; from IORPPrnt.asmEXTRN	pcePrinterTask: taskContextBlockEXTRN	pceTurboPrintTask: taskContextBlockEXTRN	testCount1: BYTE, printerDataByte: BYTE, printerStatusByte: BYTE, putLock: WORDEXTRN	pceSetCntrlportSgnl: BYTE, prtFlag: BYTEEXTRN	pcePrinterIOCondition: Condition, pcePrinterConditionWork: ConditionEXTRN	pcePrinterWorkMask: WORD, prLock: WORDEXTRN	printerBuffer: BYTE, iNPtr: BYTE, count: BYTE , needUnFlag: BYTEEXTRN	pc186OutPtr: WORDPCEPrinterIOR		ENDSPCEDispatcherIOR	SEGMENT	COMMON; from IORPDspt.asmEXTRN	ioTrappedAddress: WORD		; used by dispatcherEXTRN	ioTrappedStatus: WORDEXTRN	ioTrappedData: WORDEXTRN	pceLockMask: WORDEXTRN	pseudoConfigSwitch0: BYTEEXTRN   pseudoConfigSwitch1: BYTEEXTRN	runPCE: BYTEPCEDispatcherIOR	ENDS;-------------------------------------------------------------------------PCEPrinterSTK	SEGMENT	COMMONEXTRN	pcePrinterStack: WORDEXTRN	pceTurboPrintStack: WORDPCEPrinterSTK	ENDS;-------------------------------------------------------------------------PUBLIC	PCEPrinterInitPUBLIC	pcePrinterBootPUBLIC	pcePrinterExit;-------------------------------------------------------------------------IOPEInRam	SEGMENT	WORD PUBLIC		ASSUME	CS:IOPEInRam;-------------------------------------------------------------------------EXTRN	LoadMagic: NEAREXTRN	PCEMesaClientNotify: NEAR;-------------------------------------------------------------------------------;;;			         INITIALIZATION;;;-------------------------------------------------------------------------------; Note: Registers BX and DX contain unneeded information, hence they do; not have to be pushed on to the stack.pc186PrintData OpieAddress <08400H,0CH,PCLogicalOpieAddress>PCEPrinterInit		PROC	FAR	%InitializeTask (PCEPrinterHandlerID,OFFSET pcePrinterTask, pcePrinterTaskInit,OFFSET pcePrinterStack)	; Init task;	InitializeTask (PCEPrinterHandlerID,OFFSET pceTurboPrintTask, pceTurboPrintTaskInit,OFFSET pceTurboPrintStack)	RET	pcePrinterInit		ENDPpcePrinterTaskInit:	ASSUME	DS:PCEPrinterIOR	MOV	pceSetCntrlportSgnl, 0	MOV	testCount1, 0	%GetWorkMaskForCondition (OFFSET pcePrinterConditionWork)	MOV	pcePrinterWorkMask, AX	%Jam (PCEPrinterHandlerID,OFFSET pcePrinterTask)	; ...but don't let it run yet	%WaitForSystem	ASSUME	DS:NOTHINGpceTurboPrintTaskInit:	ASSUME	DS:PCEPrinterIOR	%Jam (PCEPrinterHandlerID,OFFSET pceTurboPrintTask)	%WaitForSystem	ASSUME	DS:NOTHING;-------------------------------------------------------------------------------;;;			            BOOT;;;-------------------------------------------------------------------------------pcePrinterBoot		PROC	NEAR	ASSUME	DS:PCEDispatcherIOR	;called from dispatcher	%EstablishHandlerAccess	(PCEPrinterHandlerID)	ASSUME	ES:PCEPrinterIOR	MOV	prtFlag, 00H 	;Initialize printer flag	MOV	iNPtr, 00H	;Initialize printer Buffer pointer	MOV	count, 00H	;Buffer counter	MOV	prLock, 01H	;Buffer locking flag	MOV	putLock, 00H	;Variable used to swap with locking mechanism; Turbo init	MOV	pc186OutPtr, 0	;BIOS pointer reset	PUSHA			;clear BIOS buffer count	%EstablishIOPAccess (generalMapRegister,pc186PrintData)	MOV	WORD PTR ES:[DI], 0	MOV	WORD PTR ES:[DI+2], 0	;clear BIOS buffer index	POPA		MOV	BL, pseudoConfigSwitch0	TEST	BL, 02H		;Test Byte for PPA configuration, is PPA card?	JNZ	pPPA		ADD	prtFlag, 08H ;No parallel printer addapter(PPA) card available	pPPA:	       ;Parallel printer addapter(PPA) card available	%Restart (PCEPrinterHandlerID,OFFSET pcePrinterTask, pcePrinterTaskEmul,OFFSET pcePrinterStack)   ; now let task run;	Restart (PCEPrinterHandlerID,OFFSET pceTurboPrintTask, pceTurboPrintTaskEmul,OFFSET pceTurboPrintStack)	RET	ASSUME	DS:NOTHING, ES:NOTHING	pcePrinterBoot		ENDP;-------------------------------------------------------------------------------;;;				    EXIT;;;-------------------------------------------------------------------------------pcePrinterExit		PROC	NEAR	%Jam (PCEPrinterHandlerID,OFFSET pcePrinterTask)	; stop the task;	Jam (PCEPrinterHandlerID,OFFSET pceTurboPrintTask)	RET	pcePrinterExit		ENDP;-------------------------------------------------------------------------------;;;		            PRINTER  EMULATION;;;-------------------------------------------------------------------------------pcePrinterTaskEmul:	ASSUME	DS:PCEPrinterIOR	%WaitForCondition	(OFFSET pcePrinterIOCondition,noTimeout)		%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIOR	MOV	BX, ioTrappedAddress; only accept LPT1: 3BCH base if mono display, 378H base if color display;	MOV	DX, BX;	AND	DX, 0FFFCH 		;clear 2 least significant bits;	MOV     AL, ES: pseudoConfigSwitch1 ;	TEST	AL, 10H 		;bit 4 is the display bit;	JZ	Color;Mono:	CMP	DX, 3BCH;	JNE	TriState		;if not valid port then return triState;	JMP	ValidPort;Color:	CMP	DX, 378H;	JNE	TriState		;if not valid port then return triState;ValidPort:		AND	BX, 0003H		;convert last digit to offset, first two bits are irrelevant	SHL	BX, 1			;double for words	MOV	SI, OFFSET printerIOTable    ;get start of table	ADD	BL, prtFlag	ADD	SI, BX			;add offset to start of table	MOV	DX, CS:[SI]	JMP	DX			;jump to correct procedureunsupportedIO:	JMP	pcePrinterTaskEmul	; start of jump table		printerIOTable  LABEL	WORD	;** routines defined in emulator **	DW	PrDataPort	;port 278H,378H,3BCH	DW	PrStatusPort	;  "  279H,379H,3BDH	DW	PrCntrlPort	;  "  27AH,37AH,3BEH	DW	TriState	;  "  27BH,37BH,3BFH; No printer card 	DW	TriState	DW	TriState	DW	TriState       	DW	TriState		;-------------------------------------------------------------------------; The following routines all terminate with a jump to pcePrinterTaskEmul lable,; which sends execution back to the dispatcher while waiting for another printer; I/O condition. ;-------------------------------------------------------------------------; PrDataPort transmits the character from its trapped location to the IORegion; PrDataPort also reads the character from the IORegion for test purposes.PrDataPort:		;Check for IN/OUT operation	TEST	ioTrappedStatus, pIOTrapInOutBit	JNZ	prINOperation1prOUTOperation1:		MOV	BL,BYTE PTR ioTrappedData	MOV	printerDataByte, BL	JMP	pcePrinterTaskEmul	prINOperation1:	MOV	AL, printerDataByte	CALL	LoadMagic	JMP	pcePrinterTaskEmul	;-------------------------------------------------------------------------; TriState indicates that the local or emulated option was not selected.; If no printer is selected, tri-state(FF) is returned to the BIOS.TriState:		;Check for IN/OUT operation	TEST	ioTrappedStatus, pIOTrapInOutBit	JNZ	prINOperation3	prOUTOperation3:		JMP	pcePrinterTaskEmul	;No action return	prINOperation3:	MOV	AL, 0FFH	;No PPA card attached, load tri-state	CALL	LoadMagic	JMP	pcePrinterTaskEmul;-------------------------------------------------------------------------; PrStatusPort reads the current status of the printer while momentarily freezing; the PC186. Insuring no further execution is permitted before the printer returns; the status.PrStatusPort:	;Check for IN/OUT operation	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	prOUTOperation2	prINOperation2: 	MOV	AL, count	;set AL , count(AL=LocalPtr)	CMP	AL, MaxBufferSize	JE	Status_NotGood	;Buffer full, printer busyNoKludgeBuffer:	MOV	printerStatusByte, 098H	;Printer Status set to ready	JMP SHORT  Send_Status	Status_NotGood:	MOV	printerStatusByte, 18H	;Printer Status set to not ready(printer busy)	XOR	runPCE, printerPauseMask	;Stop PCE from timing out	%WaitForTime	(10)			;Wait for printer to get ready(between 0 and 10 mili secs)	OR	runPCE, printerPauseMask	;Start PCE(PC 80186) again	Send_Status:	MOV	AL, printerStatusByte	CALL	LoadMagic	;Place true status in LoadMagic area	prOUTOperation2:	JMP	pcePrinterTaskEmul;-------------------------------------------------------------------------; PrCntrlPort handles the outs(strobe and initialize printer signal) to the control byte of the PPAPrCntrlPort:	;Check for IN/OUT operation	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	prOUTOperation4	JMP	prEXIT3		prOUTOperation4:	MOV	BX, ioTrappedData	AND	BL, 01H	;Only care about least significant bitprCKStrobe:	CMP	BL, 01H			JE	prFIRST1		JMP	SHORT	prSECOND1 ;Out Character to printer(second control signal)	prFIRST1:	MOV	pceSetCntrlportSgnl, 1	JMP	pcePrinterTaskEmul	prSECOND1:	CMP	pceSetCntrlportSgnl, 1	JE	Continue	JMP	prEXIT3	Continue:	MOV	AL, iNPtr		;set AL , iNPtr(AL=LocalPtr)	XOR	AH, AH			;Clear out AH of any left over junk	MOV	BX, OFFSET printerBuffer;PrinterBuffer[base],OFFSET printerBuffer	ADD	BX, AX			;PrinterBuffer[base+LocalPtr]       	MOV	AH, printerDataByte	MOV	[BX], AH		;PrinterBuffer[base+LocalPtr],Char	;******************************************************************************	;	PUSH	AX;	MOV	AL, testCount1;	CMP	AL, 0FFH;	JE	ZeroCount1	;	INC	AL;	JMP 	SHORT CountContinue;ZeroCount1:;	MOV	AL, 0;CountContinue:;	MOV	testCount1, AL;	POP	AX;******************************************************************************	CMP	AL, MaxBufferSize - 1	;iNPtr goes from 0 to 253	JE	ZeroCount2		INC	AL			;LocalPtr , LocalPtr  + 1	JMP 	SHORT GoToGetLockZeroCount2:	MOV	AL, 0GoToGetLock:	MOV	iNPtr, AL		;iNPtr,LocalPtr	CALL	GetLock	INC	count	CALL	ReleaseLockprEXIT3:	MOV	pceSetCntrlportSgnl, 0	JMP	pcePrinterTaskEmul;--------------------------------------------------------pceTurboPrintTaskEmul:;	ES:[DI+BP] points to pc186 buffer;	DS:[BX+SI] points to IORegion buffer;	CX contains pc186 count;	AH contains IORegion count;	BP contains the pc186 out pointer;	SI contains the IORegion in pointer	%WaitForTime(150)	%EstablishIOPAccess (generalMapRegister,pc186PrintData)	MOV	CX, WORD PTR ES:[DI]		CMP	CX, 0			; is there any data in the pc186 buffer?	JE	pceTurboPrintTaskEmul	CMP	count, MaxBufferSize	; is there space in the IORegion buffer?	JE	pceTurboPrintTaskEmul	ADD	DI, 4			; point to start of pc186 buffer	MOV	DL, iNPtr	XOR	DH, DH	MOV	SI, DX			; SI ? iNPtr	MOV	BP, pc186OutPtrturboPrtLoop:	MOV	BX, OFFSET printerBuffer	MOV	AL, BYTE PTR ES:[DI+BP]	; get byte from pc186 buffer	MOV	BYTE PTR [BX+SI], AL	; put byte in IORegion buffer	INC	BP			; BP ? (BP + 1) MOD MaxBufferSize	CMP	BP, MaxBufferSize	JNE	pPrintZero1	MOV	BP, 0pPrintZero1:	INC	SI			; SI ? (SI + 1) MOD MaxBufferSize	CMP	SI, MaxBufferSize	JNE	pPrintZero2	MOV	SI, 0pPrintZero2:	CALL	GetLock	INC	count			; one more byte in IO Region	CALL	ReleaseLock	MOV	CX, WORD PTR ES:[DI-4]	DEC	CX			; one less byte in PC Data Area	MOV	WORD PTR ES:[DI-4], CX	CMP	count, MaxBufferSize	JE	turboPrtLoopExit	; is IO Region buffer full?	CMP	CX, 0			;	JNE	turboPrtLoop	turboPrtLoopExit:		SUB	DI, 4	MOV	WORD PTR ES:[DI], CX		MOV	pc186OutPtr, BP	MOV	DX, SI	MOV	iNPtr, DL		; iNPtr ? DL	JMP	pceTurboPrintTaskEmul;-------------------------------------------------------------------------GetLock:      	CLI				;Disable all IOP Interrupts	MOV	AX, putLock	%MesaLockedOut (XCHG, OFFSET prLock, AX, pceLockMask)	MOV	putLock, AX	CMP	AX, 0	JNE	HaveLock	STI				;Enable all IOP Interrupts	XOR	runPCE, printerPauseMask	;Stop PCE from timing out	%WaitForTime (10)	OR	runPCE, printerPauseMask	;Start PCE(PC 80186) again	JMP	GetLockHaveLock:	RET	;-------------------------------------------------------------------------	ReleaseLock:	MOV	AX, putLock	%MesaLockedOut (XCHG, OFFSET prLock, AX, pceLockMask)	MOV	putLock, AX	STI				;Enable all IOP Interrupts		TEST	needUnFlag, 01H	JZ	LockReleased	MOV	needUnFlag, 0	MOV	AX, PCEPrinterNotifyMask	; Set up up notification	CALL	PCEMesaClientNotify		; Up notify to Mesa functionXLockReleased:	RET	ASSUME	DS:NOTHING, ES:NOTHING;-------------------------------------------------------------------------IOPEInRam	ENDS;********************************************************************************		END
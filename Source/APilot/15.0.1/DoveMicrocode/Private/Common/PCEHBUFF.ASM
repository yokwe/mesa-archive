$DEBUG  MOD186$PAGELENGTH (72)$PAGEWIDTH (136);-----------------------;;      PCEHBuff.asm	;;-----------------------;; Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.; Stored as  [Iris]<WMicro>Dove>PCE-B0>PCEHBuff.asm; Last edited by:; JPM   	13-Aug-85 13:27:34	: Separate PCE into several handlers; JPM   	12-Aug-85 12:17:46	: Change IOPEInRAM alignment to WORD; JPM   	 9-Aug-85 14:32:39	: Opie redesign conversion; AGK   	30-Jul-85 14:21:00	: Added CodeExpanded conditional assembly; AGK   	11-Jun-85 18:59:22	: Added hbActivated to disable HBuffer; AGK   	20-May-85 15:34:51	: Removed PCEMacro.asm; HNH		14-Mar-85 19:52:29	: Changed name of PCEHBuff1.asm to PCEHBuff.asm; HNH		11-Jan-85 13:58:01	: Added ReadMagicByte Proc; HNH		12-Dec-84 15:50:07	: Created ; This module is the handler that emulates the PC Floppy Disk device.NAME	PCEHBuff;-------------------------------------------------------------------------;$NOLIST$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPDefs.asm)$INCLUDE	(PCEDefs.asm)$INCLUDE	(IOPMacro.asm)$LIST;--------------------------------------------------------------------------------PCEDispatcherIOR	SEGMENT	COMMON		ASSUME	DS: PCEDispatcherIOR;EXTRN	ioTrappedData: WORDEXTRN	ioTrappedAddress: WORDEXTRN	ioTrappedStatus: BYTEEXTRN	hbActivated: BYTEEXTRN   hBufferindex: WORD;PCEDispatcherIOR	ENDS;-------------------------------------------------------------------------public	HBufferpublic	initHBuff;-------------------------------------------------------------------------IOPEInRam	SEGMENT	WORD PUBLIC		ASSUME	CS:IOPEInRam;-------------------------------------------------------------------------; Constants area in Handler%IF (%CodeExpanded) THEN (HistoryBufferOA	OpieAddress <0C000H,0EH,PCLogicalOpieAddress>HBuffDepthOA	OpieAddress <0EAA8H,0EH,PCLogicalOpieAddress>MagicByteOA	OpieAddress <0D000H,0FH,PCLogicalOpieAddress>) FI;-------------------------------------------------------------------------; PCE History Buffer procedure: Purpose is to log the number of IO; operations and the type of IO.; The history buffer is a ring buffer,in that,it wraps around to ; the beginning of the buffer once it has reached the end of the buffer.; The history buffer is 16K bytes long.; Registers Affected: BX, CX, DXHBuffer	    PROC	NEAR%IF (%CodeExpanded) THEN (; HBuffDepth and hBufferindex are initialized in IORPdtTw	PIOTrapInBit	EQU	1PIOTrapOutBit	EQU	2; Check if IO History Buffer enabled; hbActivated is reset to 0 since it is in IORegion and it has to be explicitely; changed from this value to enable the IO history buffer logging process	TEST	hbActivated, 0FFH	JZ	NoHBuffer;This routine utilizes the EstablishIOPAccess macro, therefore, the following ;registers are affected and must be retained for the main program: 		push 	AX	push 	ES	push 	DI;Initialize ES:[DI] to point to the base of the History Buffer.		%EstablishIOPAccess (generalMapRegister,HistoryBufferOA)	mov 	AX, hBufferindex	shl	AX,1	;Multiply AX by 2 to get proper index	add	DI, AX	;Load the trapped I/O address,data and status into the appropriate index of the the buffer.	mov	AX, ioTrappedAddress	mov	ES:[DI], AX	add	DI, 2*HBuffDepth	;increments Byte Address to proper					;displacement of history buffer.;Check for IN/OUT operation	test	ioTrappedStatus, pIOTrapInOutBit	jz	pHBOUTOperation		pHBINOperation:		call	ReadMagicByte			mov	AX, ioTrappedData	mov	ES:[DI], AX	add	DI, 2*HBuffDepth      	;Set Type in low byte of Status/Type word for IN operation.	mov	AL, PIOTrapInBit	jmp	EndOfRec	pHBOUTOperation:			mov	AX, ioTrappedData	mov	ES:[DI], AX	add	DI, 2*HBuffDepth      	;Set Type in low byte of Status/Type word for OUT operation.			mov	AL, PIOTrapOutBit      	;Set Status in high byte of Status/Type word.	;Increment buffer index.EndOfRec:	mov	AH, ioTrappedStatus	mov	ES:[DI], AX       	inc	hBufferindexINCBUFF:		;check ioTrapped Address,Data,Status and Type here;If buffer index equals maximum number of records(2730), then initialize buffer index to 0.	mov	AX,HBuffDepth		cmp	AX, hBufferindex	jne	NoWrap	mov	hBufferindex, 0	NoWrap:	pop 	DI	pop 	ES	pop 	AXNoHBuffer:) FI	RETHBuffer	ENDP;-------------------------------------------------------------------------; This procedure initializes the History Buffer Status/Type word to zero.; a zero in the type field indicates an empty record. There is a total of; 2730 possible records. Before returning to the main program, the ; History Buffer index pointer(hBufferindex) is reset to 0.; Registers Affected: AX, BX, CX, DX, ES, DIinitHBuff     PROC 	NEAR%IF (%CodeExpanded) THEN (HBuffDepth	EQU	0AAAH	;Word index displacement; Check if IO History Buffer enabled	TEST	hbActivated, 0FFH	JZ	NoInitHBuff	mov	hBufferindex, 0	;Initialize ES:[DI] to point to the base of the History Buffer.		%EstablishIOPAccess (generalMapRegister,HBuffDepthOA)	;add	DI, 4*HBuffDepth;Set index to base of Status/Type buffer memory				;allocation	mov	cx, HBuffDepth			        mov	BX,DI		;Retain the base value of index pointer	HBContinue:			; Loop to zero out the Status/Type word of 				; each record of the 16KB Buffer.	mov	DI,BX	mov 	AX, hBufferindex	shl	AX,1		;Multiply AX by 2 to get proper index	add	DI, AX;Point to the base of the History Buffer Status/Type word. Initialize Status/Type word to 0.		       	mov	AX, 0	mov	ES:[DI], AX;Increment buffer index.		inc	hBufferindex	loop	HBContinue;Set buffer index to 0 and retun.		mov	hBufferindex, 0NoInitHBuff:) FI	RET	initHBuff	ENDP	;-------------------------------------------------------------------------; Read Magic Byte; Registers affected AX,CX,DX%IF (%CodeExpanded) THEN (ReadMagicByte	PROC	NEAR	PUSH	DI	PUSH	ES			%EstablishIOPAccess (generalMapRegister,MagicByteOA)	MOV	AX, ES:[DI+5]	MOV	ioTrappedData, AX				POP	ES	POP	DI		RETReadMagicByte	ENDP) FI;--------------------------------------------------------------------------------IOPEInRam       ENDS     		END
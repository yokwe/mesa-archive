$DEBUG MOD186;; PERDEML.asm; Created by GPV, 25-Jun-85 17:27:32;; Last edited by:;;-- FHB.PA	10-Dec-86 10:53:07	:Moved to main memory;-- GPV.PA	 3-Dec-85 13:26:47	:Added comments and JMP SHORTS, deleted diskPauseMask;-- AGK.PA	15-Nov-85 12:30:24	:Renamed LoadMagicByte to LoadMagic;-- AGK.PA	29-Aug-85 17:06:12	:Opie redesign conversion;-- GPV.PA	15-Aug-85 10:12:07	:un commented upnotify, added pause masks;-- GPV.PA	13-Aug-85 15:11:50	:PCE regs offset stored at init ;-- GPV.PA	 6-Aug-85 16:36:03	:LoadMagicWord change undone ;-- GPV.PA	 6-Aug-85 15:09:16	:LoadMagicByte changed to LoadMagicWord ;-- GPV.PA	 6-Aug-85 12:23:18	:Init port made 322H;-- GPV.PA	 5-Aug-85 13:29:56	:PUBLIC PCEDiskBoot, PCEDiskExit ;-- GPV.PA	22-Jul-85 16:18:41	:Init/exit rework;-- GPV.PA	27-Jun-85 15:06:16	:Commented out upnotify **--**;-- GPV.PA	27-Jun-85 14:41:25	:Added labels for debugging;-- GPV.PA	26-Jun-85 12:13:29	:Changed to Word registers;;------------------------------------------------------------------------------;	NAME	PERDEML	;------------------------------------------------------------------------------$NOLIST$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPDefs.asm)$INCLUDE	(PCEDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(OpieDefs.asm)$LISTEXTRN	PCEDispatcherHandlerID:	ABSEXTRN	PCEDiskHandlerID:	ABS;--------------------------------------------------------------------------------PCEDiskIOR		SEGMENT		COMMON EXTRN	AXReg:		WORDEXTRN	BXReg:		WORDEXTRN	CXReg:		WORDEXTRN	DXReg:		WORDEXTRN	ESReg:		WORDEXTRN	maxCylinders:	WORDEXTRN	pceDiskWorkMask:	WORDEXTRN	pceRegs:	OpieAddressEXTRN	pceDiskHandlerState:	BYTEEXTRN	pceDiskTask:		TaskContextBlockEXTRN	pceDiskConditionWork:	ConditionEXTRN	pceDiskWaitIO:		ConditionPCEDiskIOR		ENDSPCEDispatcherIOR	SEGMENT		COMMON EXTRN	ioTrappedData:		WORDEXTRN	ioTrappedAddress:	WORDEXTRN	ioTrappedStatus:	WORDEXTRN	runPCE:			BYTEEXTRN	pceDiskBootLabel:	SegmentAndOffsetEXTRN	pceDiskExitLabel:	SegmentAndOffsetEXTRN	pceUpNotifyBits: 	WORDEXTRN   pceLockMask: 		WORDEXTRN   pceClientCondition: 	ClientConditionPCEDispatcherIOR	ENDS;------------------------------------------------------------------------------PCEDiskSTK	SEGMENT		COMMON EXTRN	pceDiskStack:		WORDPCEDiskSTK	ENDS;------------------------------------------------------------------------------PUBLIC	PCEDiskInit;, PCEDiskBoot, PCEDiskExit;------------------------------------------------------------------------------IOPEInRam	SEGMENT	PUBLIC		ASSUME CS: IOPEInRam		;EXTRN	LoadMagic: NEAR;EXTRN	PCEMesaClientNotify: NEAR;------------------------------------------------------------------------------; PCEDiskInitNMICorrectionRoutineOA	OpieAddress <0D000H,0FH,PCLogicalOpieAddress>PCEDiskInit	PROC	FAR	%InitializeTask	(PCEDiskHandlerID,OFFSET pceDiskTask, pceDiskTaskInit, OFFSET pceDiskStack)	RETPCEDiskInit	ENDPpceDiskTaskInit:	ASSUME	DS:PCEDiskIOR	%GetWorkMaskForCondition (OFFSET pceDiskConditionWork)	MOV	pceDiskWorkMask, AX	PUSH	ES	%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIOR	MOV	pceDiskBootLabel.offsetValue, OFFSET pceDiskBootLb	MOV	pceDiskBootLabel.segmentValue, CS	MOV	pceDiskExitLabel.offsetValue, OFFSET pceDiskExitLb	MOV	pceDiskExitLabel.segmentValue, CS	POP	ES	ASSUME	ES:NOTHING	%Jam (PCEDiskHandlerID,OFFSET pceDiskTask)	%WaitForSystem			; (delayed jam)	ASSUME	DS:NOTHING;------------------------------------------------------------------------------; PCEDiskBootPCEDiskBoot	PROC	FARpceDiskBootLb:	%Restart	(PCEDiskHandlerID,OFFSET pceDiskTask, PCEDiskProcess, OFFSET pceDiskStack)	RET	PCEDiskBoot	ENDP;------------------------------------------------------------------------------; PCEDiskExitPCEDiskExit	PROC	FARpceDiskExitLb:	%Jam	(PCEDiskHandlerID,OFFSET pceDiskTask)	RETPCEDiskExit	ENDP;------------------------------------------------------------------------------	ASSUME	DS:PCEDiskIOR;------------------------------------------------------------------------------; PCEDiskProcessPCEDiskProcess:	%WaitForCondition	(OFFSET pceDiskWaitIO,noTimeout) ;; IN/OUT to 320H & 322H; 320H is the command port. An OUT implies the PC program is attempting to perform a rigid disk IO operation; 322H is the Initialization port. An OUT implies the PC is attempting to initialize; An IN implies that the PCE is requesting the size of the ERD.		%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIOR	MOV	BX,ioTrappedAddress	;get the address	AND	BX, pLowNyble	;isolate low nyble	CMP	BL,0	; IO to 320H ?	JE	CmndReceived; Initialization time call; assumes port is 322	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	OUTtoInitPort; In to init port, implies request for max cylindersINtoInitPort:	MOV	AX, maxCylinders;	CALL	LoadMagic;	implementation of LoadMagic from PCDsptch.asm:	PUSH	DI	PUSH	ES	PUSH	AX		; Save input	%EstablishIOPAccess (generalMapRegister,NMICorrectionRoutineOA)	POP	AX		; Recover input	MOV	ES:[DI+4], AX	POP	ES	POP	DI;	JMP	SHORT PCEDiskProcess; implies the ioTrappedData contains the offset (from C8000H) ; where PCE regs are saved. Store the offset in a PCLogical address; So save this in the form of a PCLogical address.; All subsequent disk I/O requests  need this value to access the saved registers OUTtoInitPort:	MOV	pceRegs.OpieAddressType, PCLogicalOpieAddress	MOV	pceRegs.OpieAddressA23toA16, 0CH; high 4 bits of C8000H	MOV	BX,  8000H; low 16 bits of C8000H	ADD	BX, ioTrappedData; add the offset 	JNC	EndDiskIO ; 	INC	pceRegs.OpieAddressA23toA16 ; overflow so inc high bitsEndDiskIO:	MOV	pceRegs.OpieAddressA15toA0, BX ; store the offset	JMP	SHORT PCEDiskProcessCmndReceived:; An out to cmnd port, So -; 1. retrive the stored PC-186 regs; 2. Save in disk FCB; 3. UpNotify to mesa world; 4. Wait for down notify from mesa; 5. Interrupt the PC; 6. LoopBack MoveToFCB:	XOR	runPCE, diskPauseMask; Hold PCE186 until disk operation done	ASSUME	ES:NOTHING	PUSH	ES		; Save ES for later on	%EstablishIOPAccess (generalMapRegister,pceRegs)	MOV	AX, ES:[DI]	MOV	AXReg, AX	MOV	AX, ES:[DI+2]	MOV	BXReg, AX	MOV	AX, ES:[DI+4]	MOV	CXReg, AX	MOV	AX, ES:[DI+6]	MOV	DXReg, AX	MOV	AX, ES:[DI+8]	MOV	ESReg, AX	; Tell mesa about itUpNotify:		MOV	AX, pceRigidDiskNotifyMask; get disk mask;	CALL	PCEMesaClientNotify; do the UpNotify 	PUSH	DS	PUSH	ES	PUSH	AX	%EstablishHandlerAccess	(PCEDispatcherHandlerID)	MOV	AX, ES	MOV	DS, AX	ASSUME	DS:PCEDispatcherIOR	POP	AX	POP	ES	%MesaLockedOut (OR,OFFSET pceUpNotifyBits,AX,pceLockMask)	%NotifyClientCondition	(pceClientCondition)	POP	DS	ASSUME	DS:pceDiskIOR;	%WaitForCondition (OFFSET pceDiskConditionWork,noTimeout);	; save values returned by mesa into PCE mem spaceMoveFromFCB:	%EstablishIOPAccess (generalMapRegister,pceRegs)	MOV	AX, AXReg	MOV	ES:[DI], AX	MOV	AX, BXReg	MOV	ES:[DI+2], AX	MOV	AX, CXReg	MOV	ES:[DI+4], AX	MOV	AX, DXReg	MOV	ES:[DI+6], AX	MOV	AX, ESReg	MOV	ES:[DI+8], AX; int the PC	MOV	DX,pIRQ5 ; corresponds to int 13 of PC-186 (Disk adapter)	OUT	DX,AL; LoopBack	POP	ES	ASSUME	ES:PCEDispatcherIOR	OR	runPCE, diskPauseMask; get PCE going	JMP	PCEDiskProcess	ASSUME	DS:NOTHING, ES:NOTHING	IOPEInRam	ENDS		END
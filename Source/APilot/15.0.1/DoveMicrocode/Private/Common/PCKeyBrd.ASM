$ DEBUG MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);-- PCKeyBrd.asm created  2-Oct-84 11:31:10 by CWM. This code;--	Copyright (C) 1984,1985 by Xerox Corporation. All rights reserved.	;-- The following program was created in 1984 but has not been published within;-- the meaning of the copyright law. It is furnished under license, and may not;-- be used, copied and/or disclosed except in accordance with the terms of said;-- license.;-- Log:;--	23-Nov-86 20:55:47 by CWM.PA  New keyboard down notify;--	16-Oct-86 11:59:25 by AGK.PA  Moved keyboard into main memory;--	21-Nov-85 15:59:01 by CWM.PA  Kleenup;--	15-Nov-85 15:05:27 by CWM.PA  keyboardOverflow rename and 10 ms wait;--	15-Nov-85 12:18:23 by AGK.PA  Renamed LoadMagicByte to LoadMagic;--	 3-Oct-85 18:13:00 by CWM.PA  Inserted WaitForTime between interrupts;--	 3-Oct-85 11:17:17 by CWM.PA  Extra Labels for debugging;--	 2-Oct-85 17:32:35 by CWM.PA  Support for CopyIn > 15 chars;--	23-Aug-85  9:02:48 by JPM.ES  Fixed bug in pceKeyboardDequeueAndSend (need to use segment override on [SI]);--	22-Aug-85 22:24:44 by AGK.PA  Added an ASSUME DS:NOTHING at end of PCEKeyboardEmul;--	21-Aug-85 16:43:10 by JPM.ES  Make init proc FAR;--	13-Aug-85 16:48:55 by JPM.ES  Separate PCE into several handlers;--	12-Aug-85 12:14:46 by JPM.ES  Change IOPEInRAM alignment to WORD;--	 9-Aug-85 15:21:23 by JPM.ES  Opie redesign conversion;--	29-Jul-85  1:06:20 by CWM.PA  dual in;--	17-Jul-85 17:05:26 by CWM.PA  Added new Init/Exit structure;--	26-Apr-85 15:38:39 by CWM.PA  Added KB reset capability;--	15-Apr-85 16:14:20 by AGK.PA	Changed pceKeyboardInit from FAR to NEAR;--	15-Apr-85 15:09:31 by AGK.PA	Removed remote and pcekdpTestTask;--	12-Feb-85 19:08:36 by MLT.PA Fixed bug in pceKeyboardDequeueAndSend;--	 7-Feb-85 11:54:15 by MLT.PA Added Clay's changes to repair problem with the in at port 60;--	22-Jan-85 11:51:59 by MLT.PA Modified for Down Notifies;--	17-Dec-84 18:26:22 by AGK.PA Inserted remote for conditional kdpTestTask initialization;--	 4-Dec-84 17:39:03 by HNH.PA  Inserted HardDefs for OPIE16;--	26-Nov-84 21:00:48 by CWM.PA  Converted code and test buffer to indexes;--	23-Nov-84 15:35:02 by AGK.PA	Inserted kdpTestTask for KDP handlers testing;--     14-Nov-84 19:00:40 by CWM.PA  New PCKeyBrd.asm  ;--      8-Nov-84  8:02:50 by CWM.PA  Handles byte scancodes instead of words;--	24-Oct-84  7:57:54 by CWM.PA  Removed INCLUDE PCEDefs directive.;--      9-Oct-84 11:12:59 by CWM.PA  Re-named identifiers to be consistent ;--					 with changes in PCEdefs.asm;--      9-Oct-84  9:47:02 by CWM.PA  INCLUDE list change;-- 	 2-Oct-84 11:31:10 by CWM.PA  creationNAME	PCKeyBrd;---------------$NOLIST$INCLUDE		(HardDefs.asm)$INCLUDE		(IOPDefs.asm)$INCLUDE		(IOPMacro.asm)$INCLUDE		(PCEDefs.asm)$INCLUDE		(OpieDefs.asm)$LIST; Keyboard defsKBSleeping			EQU	0	KBRunning			EQU	1	firstLocation			EQU	0BIOSEnqueueSuccess		EQU	0EXTRN		PCEKeyboardHandlerID: ABSEXTRN		PCEDispatcherHandlerID: ABS;---------------PCEDispatcherIOR	SEGMENT		COMMON; from IORPDspt.asmEXTRN	keyboardOverflow: BYTEEXTRN	pceKeyboardBootLabel: SegmentAndOffsetEXTRN	pceKeyboardExitLabel: SegmentAndOffsetEXTRN	pceKeyboardResetLabel: SegmentAndOffsetEXTRN	pceKeyboardSendLabel: SegmentAndOffsetPCEDispatcherIOR	ENDS;---------------PCEKeyboardIOR	SEGMENT	COMMONEXTRN	pceKeyboardTask: taskContextBlockEXTRN	pceKeyboardWorkMask: WORD, pceKeyboardHandlerState: WORDEXTRN	KBBufferIN: BYTE, KBBufferOUT: BYTE, KBBuffer: BYTEEXTRN	codePtr: BYTEEXTRN	KBBufferMaxIndex: ABSEXTRN	pceKeyboardConditionClear: Condition, pceKeyboardConditionWork: ConditionPCEKeyboardIOR	ENDS;---------------PCEKeyboardSTK	SEGMENT	COMMONEXTRN	pceKeyboardStack: WORDPCEKeyboardSTK	ENDS;---------------PUBLIC pceKeyboardInit;PUBLIC	pceKeyboardBoot, pceKeyboardExit, pceKeyboardSend, pceKeyboardResetIOPEInRAM	SEGMENT		WORD PUBLIC		Assume		CS:IOPEInRAMEXTRN	LoadMagic: NEAR;-------------------------------------------------------------------------------;;;			         INITIALIZATION;;;-------------------------------------------------------------------------------pceKeyboardInit		PROC	FAR	%InitializeTask (PCEKeyboardHandlerID,OFFSET pceKeyboardTask,pceKeyboardTaskInit,OFFSET pceKeyboardStack)	; Init task	RET	pceKeyboardInit		ENDPpceKeyboardTaskInit:	PUSH	ES	%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIOR	MOV	pceKeyboardBootLabel.offsetValue, OFFSET pceKeyboardBootLb	MOV	pceKeyboardBootLabel.segmentValue, CS	MOV	pceKeyboardExitLabel.offsetValue, OFFSET pceKeyboardExitLb	MOV	pceKeyboardExitLabel.segmentValue, CS	MOV	pceKeyboardResetLabel.offsetValue, OFFSET pceKeyboardResetLb	MOV	pceKeyboardResetLabel.segmentValue, CS	MOV	pceKeyboardSendLabel.offsetValue, OFFSET pceKeyboardSendLb	MOV	pceKeyboardSendLabel.segmentValue, CS	POP	ES	ASSUME	ES:NOTHING	ASSUME	DS:PCEKeyboardIOR;	GetWorkMaskForCondition (OFFSET pceKeyboardConditionWork);	MOV	pceKeyboardWorkMask, AX	%Jam (PCEKeyboardHandlerID,OFFSET pceKeyboardTask)		; ...but don't let it run yet	%WaitForSystem						; (deferred Jam)	ASSUME	DS:NOTHING;-------------------------------------------------------------------------------;;;			            BOOT;;;-------------------------------------------------------------------------------pceKeyboardBoot		PROC	FARpceKeyboardBootLb:	%Restart (PCEKeyboardHandlerID,OFFSET pceKeyboardTask,pceKeyboardEmul,OFFSET pceKeyboardStack)	; now task runs	RET	pceKeyboardBoot		ENDP;-------------------------------------------------------------------------------;;;				    EXIT;;;-------------------------------------------------------------------------------pceKeyboardExit		PROC	FARpceKeyboardExitLb:	%Jam (PCEKeyboardHandlerID,OFFSET pceKeyboardTask)	; stop task	RET	pceKeyboardExit		ENDP;-------------------------------------------------------------------------------;;;		            KEYBOARD  EMULATION;;;-------------------------------------------------------------------------------;; DQ and bumppceKeyboardEmul:	ASSUME	DS:PCEKeyboardIOR	%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIOR	CALL	DWORD PTR pceKeyboardResetLabel	; reset in/out pointers	pceKBWaitForMesa:	MOV 	pceKeyboardHandlerState,KBSleeping	; handler is sleeping	%WaitForCondition	(OFFSET pceKeyboardConditionWork,noTimeout)	MOV	pceKeyboardHandlerState,KBRunning	; handler is runningpceKeyboardInterrupter:	MOV	AL,KBBufferOUT		; Get present OUT index 	CMP	AL,KBBufferIN		; Is it the same as the IN index?	JE	pceKBWaitForMesa	; yes empty buffer, go waitpceKBWrapCheck:	CMP	AL,LOW KBBufferMaxIndex	; Check for wrap	JNE	pceKBNoBufferWrap	; none needed...just increment	MOV	AL,firstLocation	; wrap to FIRST		JMP	SHORT	pceKBContinuepceKBNoBufferWrap:	INC	AL			; Increment KBBufferOut indexpceKBContinue:	MOV	codePtr,AL		; Temp ptr to scan codepceKBInterrupt:	MOV	DX,PIRQ1		; Get interrupt code 	OUT	DX,AL			; Interrupt PC, AL has junkwaitForKBClearCdx:	%WaitForCondition	(OFFSET pceKeyboardConditionClear,noTimeout)	%WaitForTime	(10)	; Allow PC enough time to process input char				; 10 ms minimal or system ie. copy in becomes				; unstablesetUpToCheck:	%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIORcheckBIOSNQ:	CMP	keyboardOverflow, BIOSEnqueueSuccess	JNE	pceKeyboardRetrysuccessBIOSNQ:	MOV	AL,codePtr		; Now bump the pointer	MOV	KBBufferOUT,AL		; Now bump the pointer	JMP	pceKeyboardInterrupter	; do this againpceKeyboardRetry:	MOV	keyboardOverflow, BIOSEnqueueSuccess	; reset flag	%WaitForTime	(50)				; give PC time to finishdoAllOverAgain:	JMP	pceKeyboardInterrupter	; do this again		ASSUME	DS:NOTHING, ES: NOTHING;---------------pceKeyboardReset	PROC	FARpceKeyboardResetLb:	%EstablishHandlerAccess	(PCEKeyboardHandlerID)	ASSUME	ES:PCEKeyboardIOR	MOV	pceKeyboardHandlerState,KBRunning	MOV	codePtr,firstLocation	MOV	KBBufferIN,firstLocation	; init buffer pointers to index 0	MOV	KBBufferOUT,firstLocation	MOV 	pceKeyboardHandlerState,KBSleeping	RET	ASSUME	ES:NOTHING	pceKeyboardReset	ENDP;---------------	pceKeyboardSend		PROC	FARpceKeyboardSendLb:	%EstablishHandlerAccess	(PCEKeyboardHandlerID)	ASSUME	ES:PCEKeyboardIOR; misnomer, only sends...does not dequeue	MOV	AL,codePtr		; Retrieve index of code	MOV	SI,OFFSET KBBuffer	; Get base of KBBuffer	XOR	AH,AH			; Zero upper byte	ADD	SI,AX			; Add index to the base	MOV	AL,ES:[SI]		; Get the scan code to AL	CALL	LoadMagic		; Feed scan code	RET	ASSUME	ES:NOTHINGpceKeyboardSend		ENDP	IOPEInRAM		ENDS			END
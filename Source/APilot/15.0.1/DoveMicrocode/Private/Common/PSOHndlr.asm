$MOD186					;RAM Resident Handler $PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.;;-- stored as [Idun]<WMicro>Dove>PSOHndlr.asm;-- created on 17-Sep-85 11:18:09;;-- Last edited by:;--	KEK		 3-Oct-86 11:27:44	;fixed mod: PSOIntrpRegrVal usage; added disable to InitPSO;--	KEK		22-Aug-86 15:57:39	;modified to multiple options support;--	JMA		11-Apr-86 17:54:10	;change condition for Jam & Restart of DMA Task;--	JMA		 9-Apr-86 19:44:43	;fixed UpdateStatus smashing transfer process;--	JMA		20-Mar-86 18:00:44	:added clear intrp-bit in intrp task;--	JMA		27-Feb-86 10:56:39	:added head's ability to see if LPO is recognized;--	JMA		28-Jan-86 13:05:45	:added software work-around for HW quirk;;;==========================  Printer Scanner Option HANDLER  ==================	NAME	PSOHndlr			;Printer Scanner Option (PSO) Handler	;==========================  INCLUDES  DECLARATIONS  ========================== $NOLIST$INCLUDE		(IOPDefs.asm)	;$INCLUDE		(PSOIOFce.asm)	;PSO IO Face$INCLUDE		(PSOHDFce.asm)	;PSO Hard Face contains HW defs$INCLUDE		(HardDefs.asm)	;$INCLUDE		(IOPMacro.asm)	;$LIST				EXTRN DMA1@ExtraInterrupt :ABS		;Interrupt from DMA1 to signal end of DMA transferEXTRN PSOHandlerID 	  :ABS;==========================  HANDLER  MACROS  ====================================; from the floppy handler%*DEFINE	( InputWord ( WordPort, WordName ) )(			MOV	DX, %WordPort			IN	AX, DX			MOV	%WordName, AX)%*DEFINE	( OutputWord ( WordPort, WordName ) )(			MOV	DX, %WordPort			MOV	AX, %WordName			OUT	DX, AX);==========================  STACK  SEGMENT  ====================================PSOSTK			SEGMENT		COMMON 			Assume SS:PSOSTK			EXTRN  PSOMainStack 		:WORDEXTRN  PSOIntrpStack		:WORD		;for PSO interruptEXTRN  DMA1IntrpStack		:WORD		;for dma1 interruptPSOSTK		 	ENDS;==========================  DATA  SEGMENT  ====================================PSOIOR			SEGMENT		COMMON 			Assume DS:PSOIOR;---- EXTRNs for PSO handler;  PSO FCB	-- contains the Task Context Block and other device related valuesEXTRN	PSOMainTaskTcb		:TaskContextBlockEXTRN	PSOIntrpTaskTcb		:TaskContextBlockEXTRN	DMA1IntrpTaskTcb	:TaskContextBlockEXTRN	PSOClientCondition	:ClientConditionEXTRN	PSOWorkCondition	:ConditionEXTRN	PSOLockMask		:WORDEXTRN	PSOWorkMask		:WORDEXTRN	DMA1CntrlWrdVal		:WORDEXTRN	PSODMATransferCount	:WORDEXTRN	PSODMASourcePtr		:WORDEXTRN	PSOCmdRegrVal		:WORDEXTRN	PSOConfigRegrVal	:WORDEXTRN	PSOIntrpRegrVal		:WORDEXTRN	PSOCommand		:WORDEXTRN	PSOTransferConfig	:WORDEXTRN	PSOPortStatus		:WORDEXTRN	PSOBoardStatus		:WORDEXTRN	PSOCommandStatus	:WORDEXTRN	PSOConfigRegrImage	:WORDEXTRN	PSOCmdRegrImage		:WORDEXTRN	PSOByteIO		:WORDEXTRN	PSOEEPROMImage		:WORDEXTRN	PSOInterrupt		:WORDEXTRN	PSODiagTestPatrn	:WORDEXTRN	PSODiagRetrnLoByte	:BYTEEXTRN	PSODiagRetrnHiByte	:BYTEEXTRN	psoIntrpCnt		:BYTEEXTRN	badPSOIntrpCnt		:BYTEEXTRN	badDMA1IntrpCnt		:BYTEEXTRN	debugByte0		:BYTEEXTRN	debugWord0		:WORDEXTRN	debugWord1		:WORDPSOIOR			 ENDS;==========================  CODE  SEGMENT  ====================================IOPEInRAM       SEGMENT	PUBLIC		;codes reside in RAM                ASSUME  CS:IOPEInRAM		ASSUME	DS:NOTHING		;-------------------------  CONSTANTS  DECLARATIONS  ---------------------------;See PSOHDFCE.ASM - PSO Hard Face;-------------------------  PUBLIC DECLARATION  ---------------------------------PUBLIC		PSOInitPUBLIC		BadPSOIntrp PUBLIC		BadDMA1Intrp        ;========================== PSO HANDLER  =====================================;***********************************;*                                 *;*        PSOHandlerInit           *;*                                 *;***********************************;This section of the handler will initialize the three tasks of the handler;NOTE: This handler assumes that:;	1) its IORegion has been initialized to all '0's;	2) that it will be called only if Opie has determined, through EEPROM, that the;	   Laser Printing Option is available.  PSOCommandStatus will be set to Ready (non-zero) if;	   this handler is startedPSOInit  	PROC    FAR		PUSH	AX		%EstablishHandlerAccess (PSOHandlerID)		;allow access to PSO IORegion segment		POP	AX		ASSUME	ES:PSOIOR				;Use ES as base segment				MOV	PSOEEPROMImage, AX			;save EEPROM Option data		%GetOptionsInterrupt	(DX, 1)			;get interrupt assignment		MOV	PSOInterrupt, BX			;save intrp vector in IORegion		MOV	PSOIntrpRegrVal, AX			;save intrp mask in IORegion		InitTask	LABEL	WORD                %InitializeTask (PSOHandlerID, OFFSET PSOIntrpTaskTcb, PSOIntrpTask, OFFSET PSOIntrpStack)		%InitializeTask (PSOHandlerID, OFFSET DMA1IntrpTaskTcb, DMA1IntrpTask, OFFSET DMA1IntrpStack)                %InitializeTask (PSOHandlerID, OFFSET PSOMainTaskTcb, PSOMainTask, OFFSET PSOMainStack)		RETPSOInit  	ENDP		ASSUME  DS:PSOIOR				;set data segment to PSO IORegion		ASSUME	ES:NOTHING				;;****************************************************************************************;		S U P P O R T	R O U T I N E S						*;****************************************************************************************;**************************************;*                                    *;*      PSO PRINTER INITIALIZATION    *;*                                    *;**************************************; This PROC performs a software controlled board reset, similar to power up conditions.; In doing so, this proc performs the following:;	1) resets  DMA Channel 1;	2) Jam and Restart DMA task if reseting when transfer command is in progress;	3) clears PSO interrupt bit;	4) sets Configuration Regr to an initial value, see PSOHDFCE.ASM for details;	5) sets Command Regr to an initial value, see PSOHDFCE.ASM for details;	6) loads the Interrupt Select Regr with the intrp mask;	7) updates all other status	InitPSO		PROC		%Disable (PSOInterrupt)		%OutputWord (PSOConfigRegr, ResetConfigRegrVal)	;disable board interrupt and dma request				%OutputWord (i186DMA1ControlWord, DMA1ResetCntrlWrd)								;  stop any DMA1 activity, if any								;  just load DMA1 control word								;  with a known harmless value				MOV	AX, PSOCommand				;checking to see if a transfer is in progress		AND	AX, PSOTransferCmd			;Jam and Restart the DMA task only if 			JZ	NoXferInPrgrss				;  a transfer command is being serviced		%Restart (PSOHandlerID, OFFSET DMA1IntrpTaskTcb,DMA1IntrpTask, OFFSET DMA1IntrpStack)		NoXferInPrgrss:	%OutputWord (PSOCommandRegr, ResetCmdRegrVal)	;reset board, clear intrpt, and turn-off PSO board		%OutputWord (PSOIntrpSelectRegr, PSOIntrpRegrVal)	;program interrupt select regr 									; on PSO with intrp mask											%OutputWord (PSOCommandRegr, InitialCmdRegrVal)	;inactivate reset, and load initial command								;load initial PSO configuration & enable board intrpt		MOV	PSOCmdRegrImage, AX			;save the image of PSO board cmd regr				%OutputWord (PSOConfigRegr, InitialConfigRegrVal)		MOV	PSOConfigRegrImage, AX			;save the image of PSO board config regr				%Enable (PSOInterrupt)			;enable PSO intrp channel ONLY into option 8259				%MesaLockedOut(AND, OFFSET PSOCommand, ClrCommandMask, PSOLockMask)								;Clear command pending flag, if set			%InputWord (PSOPortStatusRegr, PSOPortStatus)		%InputWord (PSOStatusRegr, PSOBoardStatus)	;update ALL status		MOV	PSOCommandStatus, Ready			;Set status to ready		RETInitPSO		ENDP;**************************************;*                                    *;*      UPDATE STAT AND UPNOTIFY      *;*                                    *;**************************************; This Proc's functions are:;    1) To read and save current Port and Board Status (update);    2) To clear the command bit of the handlers command word using the mask passed in CX;    3) To perform the Up NotificationUpdateStatAndUpNotify	PROC		%InputWord (PSOPortStatusRegr, PSOPortStatus)		%InputWord (PSOStatusRegr, PSOBoardStatus)	;update ALL status				%MesaLockedOut(AND, OFFSET PSOCommand, CX, PSOLockMask)								;clear command bit using locking		%NotifyClientCondition (PSOClientCondition)		RETUpdateStatAndUpNotify	ENDP						;**************************************;*                                    *;*      UPDATE STATUS NOW 	      *;*                                    *;**************************************; This Proc responds to the on-demand update of the port and board status.; UpdateStatus command bit clearing and up notification is performedUpdateStatusNow	PROC		MOV	CX, ClrUpdateCmdMask		;load clear-command-bit mask		CALL	UpdateStatAndUpNotify		;update and upnotify		RET					;UpdateStatusNow	ENDP;**************************************;*                                    *;*      RESET PSO		      *;*                                    *;**************************************; This Proc performs a software controlled board reset, similar to power up conditions.; For further details see InitPSO Proc; This Proc also performs the Reset command bit clearing and up notification.ResetPSO	PROC		MOV	PSOCommandStatus, InProgress	;Command in Progress		CALL	InitPSO				;perform the actual board reset		MOV	CX, ClrResetCmdMask		;load clear-command-bit mask		CALL	UpdateStatAndUpNotify		;update and upnotify		RET					;ResetPSO	ENDP					;;********************************;*				*;*	SET UP DMA 	 	*;*				*;********************************; This PROC performs the mapping from Virtual to IOP logical Memory.; The source address is then loaded into DMA; Data pointer calculation was taken directly from Floppy handler. SetUpDMA1Ptrs	PROC 		%EstablishIOPAccess (optionDMAMapRegister, PSODMASourcePtr )							;map virtual to IOP logical address							;  and make it accessible to us			MOV	debugWord0, ES			;debug only							MOV	debugWord1, DI			;debug only									MOV	AX, ES				;load base segment value, ready for		SHR	AX, 12				;  effective address calc.  Get high 4 bits		MOV	DX, i186DMA1HighSourcePtr	; load hi 4 bits in sourcr ptr 		OUT	DX, AX 				MOV	AX, ES				;ready to calc. base plus offset		SHL	AX, 4				;  get low 16 bits which will be		OR	AX, DI				;  ORed with the offset to produce		MOV	DX, i186DMA1LowSourcePtr	;  the low 16 bits of the DMA source addrs		OUT	DX, AX 				RETSetUpDMA1Ptrs	ENDP;**************************************;*                                    *;*      PSO TRANSFER		      *;*                                    *;**************************************; This PROC performs the actual block/byte output.; The steps for an output transfer include:;	1) mapping Virtural Memory to IOP logical memory;	2) load control word, source and destination address and transfer count;		of DMA channel 1 for a transfer;	3) load client selected parameters; set up PSO configuration and command regrs;	4) enable PSODMARequest and PSOGo bits		PSOTransfer	PROC		MOV	PSOCommandStatus, InProgress	;Command in ProgressStartDMA1Xfer:	CALL	SetUpDMA1Ptrs			;Assume, DMA Channel#1 is available				%OutputWord (i186DMA1TransferCount, PSODMATransferCount)							;load DMA transfer count								%OutputWord (i186DMA1LowDestPtr, PSODataRegr)		%OutputWord (i186DMA1HighDestPtr, 0)							;load PSO Data Regr as destination IO				%OutputWord (i186DMA1ControlWord, DMA1CntrlWrdVal)							;Program DMA Channel#1 and start it							; okay to start since DMA1 is dest'n sync							; load DMA1 control word									%OutputWord (PSOConfigRegr, PSOConfigRegrVal)							;Enable PSODMAEnable bit, but the PSO board is							; still turned off; no DMA transfer request yet		MOV	PSOConfigRegrImage, AX		;save the image									%OutputWord (PSOCommandRegr, PSOCmdRegrVal)							;Set client parameters necessary for a transfer							;Also, Turn PSO board on and allow DMA request 		MOV	PSOCmdRegrImage, AX		;save the image						RET					;return to main taskPSOTransfer	ENDP		;********************************;*				*;*	PSO Diagnostics 	*;*				*;********************************; This PROC performs a limited on-line diagnostics by doing a loopback on the PSO internal data;	pathPSODiagnostics	PROC		MOV	PSOCommandStatus, InProgress	;Command in Progress		%OutputWord (PSOConfigRegr, PSOConfigRegrVal)							;set Config regr for diagnostic mode		MOV	PSOConfigRegrImage, AX		;save the image							%OutputWord (PSOCommandRegr, PSOCmdRegrVal)							;load PSO Command Regr value		MOV	PSOCmdRegrImage, AX		;save the imageDMA												%OutputWord (PSODataRegr, PSODiagTestPatrn)							;ready to output test pattern							;perform high byte loopback test							;   by doing WORD IO		MOV	CX, DiagDelayCount		;DiagDelayLoop1:	PUSHA					;wait at least 10uS by doing a push/pop,		POPA					;  		LOOP	DiagDelayLoop1			;but play it safe, and wait > 50uSec		MOV	DX, PSOMaintenanceRegr		;load PSO Maintenance Regr addrs		IN	AL, DX		       		;read high byte return value		MOV	PSODiagRetrnHiByte, AL		;save high byte				MOV	DX, PSODataRegr			;load PSO Data Regr addrs		MOV	AX, PSODiagTestPatrn		;ready to output test pattern		OUT	DX, AL				;perform lo byte loopback test byte							;   by doing BYTE IO		MOV	CX, DiagDelayCount		;DiagDelayLoop2:	PUSHA					;wait at least 10uS by doing a push/pop,		POPA					;  		LOOP	DiagDelayLoop2			;but play it safe, and wait > 50uSec		MOV	DX, PSOMaintenanceRegr		;load PSO Maintenance Regr addrs		IN	AL, DX		       		;read high byte return value		MOV	PSODiagRetrnLoByte, AL		;save lo byte return value, form the							;  the word return value									%OutputWord (PSOCommandRegr, InitialCmdRegrVal)		MOV	PSOCmdRegrImage, AX		;disable board and save image														MOV	CX, ClrDiagCmdMask		;load clear-command-bit mask		MOV	PSOCommandStatus, Ready		;ready for the next command		CALL	UpdateStatAndUpNotify		;Update and upnotify						RETPSODiagnostics  ENDP;****************************************************************************************;		T A S K		R O U T I N E S						*;****************************************************************************************;********************************;*				*;*	PSO Interrupt Task	*;*				*;********************************; This task handles the printer fault and PROM error interrupt.; Action taken:;	1) Update Status and Up-Notify;	2) Clear PSO interrupt bit;	3) performs some interactions with the slave option 8259, ackPSOIntrpTask:	%ThisTaskServices (PSOInterrupt, BadPSOIntrp)				%DisableInterruptsTillNextWait		;disable all intrps till ready for PSO intrp				%Enable (PSOInterrupt)			;enable options intrp into options slave 8259		WaitForPSOIntrp:%WaitForInterrupt (noTimeout)		;wait for an interrupt							;note that the interrupt bit is cleared only							;  on a reset command						OnPSOIntrp:	INC	psoIntrpCnt			;count fault/PROM intrps							;poll expansion for intrp acknoledgement							;save port and board status in IORegion then upnotify		%InputWord (PSOPortStatusRegr, PSOPortStatus)		%InputWord (PSOStatusRegr, PSOBoardStatus)		%NotifyClientCondition (PSOClientCondition)				MOV	AX, PSOCmdRegrImage		;get image of current values in Command Regr		AND	AX, ClearIntrpBitMask		;set Clear Intrp Bit to active (lo)		MOV	DX, PSOCommandRegr		;load Command regr. addrs.		OUT	DX, AX				;do the interrupt-bit reset		MOV	AX, PSOCmdRegrImage		;restore Command regr. contents, clr intrp bit		OUT	DX, AX				;  should be inactive				JMP	WaitForPSOIntrp			;Wait for the next PSO intrp						;********************************;*				*;*	 PSO DMA1 Task		*;*				*;********************************; This task waits for the completion of a DMA transfer process and the; full completion of a block or byte transfer.DMA1IntrpTask:	%ThisTaskServices (DMA1@ExtraInterrupt, BadDMA1Intrp)				%DisableInterruptsTillNextWait		%Enable (DMA1@ExtraInterrupt)		;enable DMA1 done interrupt		Wait4DMA1Done:	%WaitForInterrupt (noTimeout)		;Wait for DMA1 transfer to finish, 							;   if started at all...							;Check to see that last data has been strobed out.DMA1Done:	MOV	DX, PSOStatusRegr		;load status regr addrs		IN	AX, DX				;read pso status		TEST	AX, PSOReadyBit			;Check if PSO is ready for the next transfer	        JNZ	TransferDone			;jump if transfer has been completed				MOV	PSOCommandStatus, Incomplete	;Almost done, just waiting for the last byte		%WaitForTime(50)			;Wait awhile and try again... 		JMP	DMA1Done			;check again if last data has been strobe out		TransferDone:	%OutputWord (PSOCommandRegr, InitialCmdRegrVal)		MOV	PSOCmdRegrImage, AX 		;save the image of PSO board config regr							;Set command regr. to init value, turn PSO board off		MOV	CX, ClrTransferCmdMask		;load clear-command-bit mask		MOV	PSOCommandStatus, Ready		;indicate readiness		CALL	UpdateStatAndUpNotify		;update and upnotify								JMP	Wait4DMA1Done			;Wait for the next PSO intrp;***********************************;*                                 *;*        PSO MAin TASK        	   *;*                                 *;***********************************;  This task performs the actual initialization of a lot needed variables for the handler.;  This task also has the all-important duty of fielding the down-notifys and interpreting;  the commands the head has sent.PSOMainTask:	%GetWorkMaskForCondition (OFFSET PSOWorkCondition)							;Get Work Mask		MOV	PSOWorkMask, AX			; and save work mask				%GetLockMask				;Get Lock Mask		MOV	PSOLockMask, AX			;  and save for later use				MOV	psoIntrpCnt, 0			;init intrp counters		MOV 	badPSOIntrpCnt, 0		;		MOV 	badDMA1IntrpCnt, 0				CALL	InitPSO				;Resets and initializes PSO board and							;  regr values							;save port and board status in IORegion;------------------------------------------; WAIT FOR WORK AND EXECUTE COMMANDS HERE -;------------------------------------------PSOWaitForCmd:	%WaitForCondition (OFFSET PSOWorkCondition,noTimeout)							;Command from the client, the Head		MOV 	AX, PSOCommand			;read command from Head		IsItAnUpdate:	TEST	AL, PSOUpdateStatCmd		;Is command Update Status ?		JZ	SHORT IsItAReset		;IF not then go to...		PUSH	AX				;save command for later reference		CALL	UpdateStatusNOW			;update Status NOW							;Also, check for a reset bit command		POP	AX				;bring back command, ignore PSOUpdateStatCmd bit IsItAReset:	TEST	AL, PSOResetCmd			;Is command reset?		JZ	SHORT CheckForReady		;IF not then go to...		CALL	ResetPSO			;ELSE perform reset		JMP	PSOWaitForCmd			;wait for the next down notify		CheckForReady:	CMP	PSOCommandStatus, Ready		;check to see if LPO is ready for transfer or test		JNE	PSOWaitForCmd			;if not ready, then wait for the next command		IsItATransfer:	TEST	AL, PSOTransferCmd		;Is command transfer?		JZ	SHORT IsItADiag			;IF not then go to...		CALL	PSOTransfer			;ELSE perform transfer process		JMP	PSOWaitForCmd			;wait for the next down notify		IsItADiag:	TEST	AL, PSODiagCmd			;Is command diagnostics?		JZ	SHORT NoSuchCmd			;IF not then go to...		CALL	PSODiagnostics			;ELSE perform diagnostics	NoSuchCmd:	JMP	PSOWaitForCmd			;wait for the next down notify		ASSUME  DS: NOTHING;****************************************************************************************;		B A D	I N T E R R U P T	R O U T I N E S				*;****************************************************************************************;********************************;*				*;*	BadPSOIntrp		*;*				*;********************************;  Opie calls this proc if the interrupt task is not ready for the interruptBadPSOIntrp    	PROC	FAR		%EstablishHandlerAccess (PSOHandlerID)	;allow access to PSO IORegion segment		ASSUME	ES:PSOIOR			;Use ES as base segment		INC	badPSOIntrpCnt			;Keeping track of bad intrp		%InputWord (PSOPortStatusRegr, PSOPortStatus)		%InputWord (PSOStatusRegr, PSOBoardStatus)							;save port and board status in IORegion				RET					;WaitForInterrupt still in effectBadPSOIntrp	ENDP		ASSUME	ES:NOTHING;********************************;*				*;*	BadDMA1Intrp		*;*				*;********************************; This PROC shouldn't have to be called at all; SERIOUS problem if called.; Opie calls this proc if the DMA1 interrupt task is not ready for the DMA1 interruptBadDMA1Intrp    PROC	FAR		%EstablishHandlerAccess (PSOHandlerID)	;allow access to PSO IORegion segment		ASSUME	ES:PSOIOR			;Use ES as base segment		INC	badDMA1IntrpCnt			;incr. counter		RETBadDMA1Intrp	ENDP		ASSUME	ES:NOTHING		IOPEInRAM	ENDS;********************************************************************************;		E N D	O F	P S O	H A N D L E R				*;********************************************************************************		END
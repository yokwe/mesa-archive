$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1985 by Xerox Corporation. All rights reserved.;-- stored as [Idun]<WDLion>Dove>AllocSgs.asm;-- created on  13-Sep-85 14:46:02;-- last edited by:;--	JAC	30-Jan-87 12:10:41	:use EndOfSystemStackSeg in stack placement;--	JAC	28-Jan-87 18:32:49	:use EstablishHandlerAccess instead of directly getting addr of BootStrapIOR. redo the edit for RDH;--	RDH	27-Jan-87 17:10:21	:Add twiddle of bootBufferPtr for small initial.;--	JAC	10-Dec-85 11:22:14	:testing for IORegion segments end;--	JPM	13-Sep-85 14:46:02	:Creation from RAMHInit.asmNAME		AllocSegs$NOLIST$INCLUDE	(IOPDefs.asm)$INCLUDE	(OpieDefs.asm)$INCLUDE	(ROMBDefs.asm)$INCLUDE	(IOPMacro.asm)$LIST;********************************************************************************IOPELocalRAM		SEGMENT		AT 0			EXTRN	device: WORDIOPELocalRAM		ENDSBootStrapIOR		SEGMENT		COMMON			EXTRN	bootMemoryPtr: WORD			EXTRN	bootBufferPtr: WORDBootStrapIOR		ENDSIORegion		SEGMENT		COMMON			EXTRN	segmentTable: SegmentEntryIORegion		ENDSEthernetSTK		SEGMENT		COMMON			EXTRN	EndOfEthernetStackSeg: WORDEthernetSTK		ENDSFloppySTK		SEGMENT		COMMON			EXTRN	EndOfFloppyStackSeg: WORDFloppySTK		ENDSEndSTK			SEGMENT		COMMONEndSTK			ENDSSystemSTK		SEGMENT		COMMON			EXTRN   EndOfSystemStackSeg: WORDSystemSTK		ENDS;********************************************************************************IOPEInRAM		SEGMENT		WORD PUBLIC			ASSUME	CS:IOPEInRAM$INCLUDE	(RAMHands.asm)	;file specifying which handlers we link with.PUBLIC	AllocateSegmentsAllocateSegments	PROC	FAR			PUSH	DS			MOV	AX, IORegion			MOV	DS, AX			ASSUME	DS:IORegion			MOV	BX, OFFSET segmentTable$NOGEN;The following macro enumerates those which are expected to be linked.%' Handlers.asm defines a macro called HandlersLinked, which calls the%' %Handler macro for the names of all handlers the author provided.%' Eventually this section might do dynamic allocation of segments;%' for now, let the locator do static allocation.%*DEFINE(Handler(name,id,initProcAction))	(%IF (%EQS (%name,End)) THEN (%name%(IOR)		SEGMENT	COMMON%name%(IOR)		ENDS			%EstablishHandlerAccess	(BootStrapHandlerID)			ASSUME	ES: BootStrapIOR			MOV	bootMemoryPtr, %name%(IOR))ELSE (%name%(HandlerID)	EQU	%id%name%(IOR)		SEGMENT	COMMON%name%(IOR)		ENDS%name%(STK)		SEGMENT	COMMON%name%(STK)		ENDS			MOV	DI, SIZE SegmentEntry * %id			MOV	[BX][DI].ioRegionSegment, %name%(IOR)			MOV	[BX][DI].stackSegment, %name%(STK))FI)OpieIOR			SEGMENT	COMMONOpieIOR			ENDSOpieSTK			SEGMENT	COMMONOpieSTK			ENDS			MOV	[BX].ioRegionSegment, OpieIOR			MOV	[BX].stackSegment, OpieSTK$GENONLY			%HandlersLinked;Now fix up boot device stack segments;Boot device stack segments are located in this order: Disk, Ethernet, Floppy.;However, the stack segment for the boot device currently being used should not be; moved into bootstrap code. This requirement may relocate other stack segments.			MOV	AX, IOPELocalRAM			MOV	ES, AX			ASSUME	ES:IOPELocalRAM;if boot device = disk, stack segs are located correctly			CMP	device, disk			JE	StacksAreOK			MOV	AX, DiskSTK;if boot device = ethernet, reorder to: Ethernet, Disk, Floppy; (floppy stack segment location is preserved)			CMP	device, ethernet			JE	AdjustENetStack;if boot device = floppy, reorder to: Floppy, Ethernet, Disk; (at present the floppy and disk stack segs are the same size, so this ordering;  will preserve ethernet stack segment location)			CMP	device, floppy			JNE	StacksAreOKAdjustFloppyStack:	MOV	DI, SIZE SegmentEntry * floppyHandlerID			MOV	CX, [BX][DI].stackSegment			MOV	[BX][DI].stackSegment, AX			MOV	AX, CX			JMP	SHORT AdjustDiskStackAdjustENetStack:	MOV	DI, SIZE SegmentEntry * ethernetHandlerID			MOV	[BX][DI].stackSegment, AX			MOV	CX, OFFSET EndOfEthernetStackSeg			ADD	CX, 0FH			SHR	CX, 4			ADD	AX, CX			MOV	DI, SIZE SegmentEntry * SystemHandlerID			MOV	[BX][DI].stackSegment, AX			MOV	CX, OFFSET EndOfSystemStackSeg			ADD	CX, 0FH			SHR	CX, 4			ADD	AX, CXAdjustDiskStack:	MOV	DI, SIZE SegmentEntry * diskHandlerID			MOV	[BX][DI].stackSegment, AXStacksAreOK:		;Fix up bootBufferPtr so local ram loadspace will not be			; overwritten by stacks at 200 time.  			;bootBufferPtr ¬ MAX[bootBufferPtr, 16*EndSTK]			%EstablishHandlerAccess	(BootStrapHandlerID)			ASSUME	ES: BootStrapIOR			MOV 	AX, EndSTK			SHL	AX, 4			CMP	bootBufferPtr, AX			JGE	LoadSpaceIsOK			MOV	bootBufferPtr, AX LoadSpaceIsOK:		POP	DS			RETAllocateSegments	ENDPIOPEInRAM		ENDS			END
$DEBUG  MOD186$PAGELENGTH (72)$PAGEWIDTH (136);----------------------;;     PCClock.asm        ;;----------------------;; Copyright (C) 1986 by Xerox Corporation. All rights reserved.; Stored as  [BamBam]<WMicro>Dove>PCClock.asm; Last edited by:; AGK	 9-Oct-86 17:01:47	: Commented out pceClockConditionWork, c_Lock, putClkLock, and LoopCnt. Moved address checking from dispatcher. Added PClockCommonExit.; HNH	23-Sep-86 12:26:27	: Removed all calls to GetLock and ReleaseLock procedures and I also removed the GetLock and ReleaseLock procedures.;				: Removed the variable Word_VAR; HNH	 4-Sep-86 18:47:26	: Added clkTestCount; HNH	 4-Sep-86 18:31:30	: Changed to BYTE and WORD PTR operators for the TimerLow_X and TimerHigh_X functions; HNH	 4-Sep-86 15:49:25	: Changed HIGH and LOW directives to BYTE PTR operator in Year_LSB and Year_MSB; HNH	28-Aug-86 15:39:04	: Added Word_VAR and expanded ClockIOTable; HNH	14-Aug-86 18:48:02	: Creation; This module is the handler that emulates the PC Real Time Clock hardware device.; The Real Time Clock design is modeled after the AST Research Six Pak Plus card.	NAME	PCEClockEmulator;-------------------------------------------------------------------------$NOLIST$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPDefs.asm)$INCLUDE	(PCEDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(OpieDefs.asm)$LISTEXTRN		PCEClockHandlerID: ABSEXTRN		PCEDispatcherHandlerID: ABS;-------------------------------------------------------------------------; EquatesSafeToGetTime 	EQU	01HclkTestCount 	EQU	17080Ah;-------------------------------------------------------------------------PCEClockIOR		SEGMENT	COMMON; from IORPClock.asmEXTRN	pceClockTask: taskContextBlockEXTRN	pceClockIOCondition: Condition;EXTRN	pceClockConditionWork: ConditionEXTRN	RawTimerCount: DWORD, pceClockWorkMask: WORD, YearWord: WORDEXTRN	MonthByte: BYTE, DayByte: BYTE;EXTRN	c_Lock: WORD, putClkLock: WORD, LoopCnt: BYTEEXTRN	Word_VAR: WORDPCEClockIOR		ENDSPCEDispatcherIOR	SEGMENT	COMMON; from IORPDspt.asmEXTRN	ioTrappedAddress: WORD		; used by dispatcherEXTRN	ioTrappedStatus: WORDEXTRN	pceClockBootLabel: SegmentAndOffsetEXTRN	pceClockExitLabel: SegmentAndOffset;EXTRN	ioTrappedData: WORD;EXTRN	runPCE: BYTEPCEDispatcherIOR	ENDS;-------------------------------------------------------------------------PCEClockSTK	SEGMENT	COMMONEXTRN	pceClockStack: WORDPCEClockSTK	ENDS;-------------------------------------------------------------------------PUBLIC	PCEClockInitPUBLIC	pceClockBootPUBLIC	pceClockExitPUBLIC	LoadMagic;-------------------------------------------------------------------------IOPEInRam	SEGMENT	WORD PUBLIC		ASSUME	CS:IOPEInRam;-------------------------------------------------------------------------;EXTRN	LoadMagic: NEAR;-------------------------------------------------------------------------------;;;			         INITIALIZATION;;;-------------------------------------------------------------------------------; Note: Registers BX and DX contain unneeded information, hence they do; not have to be pushed on to the stack.		pceClockInit		PROC	FAR	%InitializeTask (PCEClockHandlerID,OFFSET pceClockTask, pceClockTaskInit,OFFSET pceClockStack)	; Init task	RET	pceClockInit		ENDPpceClockTaskInit:	PUSH	ES	%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIOR	MOV	pceClockBootLabel.offsetValue, OFFSET pceClockBootLb	MOV	pceClockBootLabel.segmentValue, CS	MOV	pceClockExitLabel.offsetValue, OFFSET pceClockExitLb	MOV	pceClockExitLabel.segmentValue, CS	POP	ES	ASSUME	ES:NOTHING	%Jam (PCEClockHandlerID,OFFSET pceClockTask)	; ...but don't let it run yet	%WaitForSystem	ASSUME	DS:NOTHING;-------------------------------------------------------------------------------;;;			            BOOT;;;-------------------------------------------------------------------------------pceClockBoot		PROC	FARpceClockBootLb:;	ASSUME	DS:PCEDispatcherIOR	;called from dispatcher	;EstablishHandlerAccess	(PCEClockHandlerID);	ASSUME	ES:PCEClockIOR;	MOV	LoopCnt, 00H 	;Initialize Clock loop counter;	MOV	putClkLock, 00H	;Initialize swap Variable for locking mechanism;	MOV	c_Lock, 01H	;Initialize Clock locking flag	%Restart (PCEClockHandlerID,OFFSET pceClockTask, pceClockTaskEmul,OFFSET pceClockStack)   ; now let task run	RET	ASSUME	DS:NOTHING, ES:NOTHING	pceClockBoot		ENDP;-------------------------------------------------------------------------------;;;				    EXIT;;;-------------------------------------------------------------------------------pceClockExit		PROC	FARpceClockExitLb:	%Jam (PCEClockHandlerID,OFFSET pceClockTask)	; stop the task	RET	pceClockExit		ENDP;-------------------------------------------------------------------------------;;;		            PRINTER  EMULATION;;;-------------------------------------------------------------------------------pceClockTaskEmul:	ASSUME	DS:PCEClockIOR	%WaitForCondition	(OFFSET pceClockIOCondition,noTimeout)		%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIOR	MOV	BX, ioTrappedAddress						;Check for IN/OUT operation	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	pceClockTaskEmul		;Clock is an out operation, exit program	clkINOperation:	CMP	BX, 02C2H		;skip 2C0H to 2C2H	JBE	pceClockTaskEmul	;	CMP	BX, 02CBH		;skip 2CBH to 2CFH	JAE	pceClockTaskEmul	;	SUB	BX, 02C3H		;convert digit to table offset	SHL	BX, 1			;double for words	MOV	SI, OFFSET ClockIOTable ;get start of table	ADD	SI, BX			;add offset to start of table	MOV	DX, CS:[SI]	JMP	DX			;jump to correct procedure; start of jump table		ClockIOTable  LABEL	WORD	;** routines defined in emulator **	DW	TimerLow_LSB		;port 02C3H	DW	TimerLow_MSB		;  "  02C4H	DW	TimerHigh_LSB		;  "  02C5H	DW	TimerHigh_MSB		;  "  02C6H	DW	Day			;  "  02C7H	DW	Month			;  "  02C8H	DW	Year_LSB		;  "  02C9H	DW	Year_MSB		;  "  02CAH	;-------------------------------------------------------------------------; The following routines all terminate with a jump to pceClockTaskEmul lable,; which sends execution back to the dispatcher while waiting for another Real; Time Clock I/O condition. ;-------------------------------------------------------------------------; TimerLow_LSB reads the Least Significant Byte raw timer count of the low ; word of the 32-bit double word from the IORegion.TimerLow_LSB:;	MOV	AX, 080Ah		;***For test purposes***;	MOV	WORD PTR RawTimerCount, AX	;Low word of raw timer count, DD		MOV	AL, BYTE PTR RawTimerCount	;Get the 1st Byte	JMP	PClockCommonExit ;-------------------------------------------------------------------------; TimerLow_MSB reads the Most Significant Byte raw timer count of the low ; word of the 32-bit double word from the IORegion.TimerLow_MSB:;	MOV	AX, 080Ah		;***For test purposes***;	MOV	WORD PTR RawTimerCount+1, AX	;Low word of raw timer count, DD	MOV	AL, BYTE PTR RawTimerCount+1	;Get the 2nd Byte	JMP	PClockCommonExit		;-------------------------------------------------------------------------; TimerHigh_LSB reads the Least Significant Byte raw timer count of ; the High word of the 32-bit double word from the IORegion.TimerHigh_LSB:;	MOV	AX, 017h		;***For test purposes***;	MOV	WORD PTR RawTimerCount+2, AX	;High word of raw timer count, DD	MOV	AL, BYTE PTR RawTimerCount+2	;Get the 3rd Byte	JMP	PClockCommonExit		;-------------------------------------------------------------------------; TimerHigh_MSB reads the raw timer count of ; the High word of the 32-bit double word from the IORegion.TimerHigh_MSB:;	MOV	AX, 017h		;***For test purposes***;	MOV	WORD PTR RawTimerCount+2, AX	;High word of raw timer count, DD	MOV	AL, BYTE PTR RawTimerCount+3	;Get the 4th BYTE	JMP	PClockCommonExit		;-------------------------------------------------------------------------; Day reads the date count for the DAY of the month(1-31) from the IORegion. Day:	MOV	AL, DayByte;	MOV	AL, 019h		;***For test purposes***25	JMP	PClockCommonExit		;-------------------------------------------------------------------------; Month reads the date count for the MONTH of the year(1-12) from the IORegion.Month:	MOV	AL, MonthByte;	MOV	AL, 08h			;***For test purposes***8	JMP	PClockCommonExit		;-------------------------------------------------------------------------; Year_LSB reads the Least Significant Byte YEAR count between 1980 to 2099 from; the IORegion.Year_LSB:;	MOV	AX, 07C1h		;***For test purposes***1985	MOV	AL, BYTE PTR YearWord	;Access the LOW Byte of YearWord	JMP	PClockCommonExit	;--------------------------------------------------------------------------; Year reads the Most Significant Byte YEAR count between 1980 to 2099 from; the IORegion.Year_MSB:;	MOV	AX, 07C1h		;***For test purposes***1985	MOV	AL, BYTE PTR YearWord + 1 ;Access the HIGH Byte of YearWord	JMP	PClockCommonExit	;----------------------------------------------------------------------------; PClockCommonExitPClockCommonExit:	CALL	LoadMagic	JMP	pceClockTaskEmul;--------------------------------------------------------------------------------; Load Magic; Input byte/word in AL/AX; No call to the history buffer is done here due to binding problems.NMICorrectionRoutineOA	OpieAddress <0D000H,0FH,PCLogicalOpieAddress>LoadMagic	PROC	PUSH	DI	PUSH	ES	PUSH	AX		; Save input	%EstablishIOPAccess (generalMapRegister,NMICorrectionRoutineOA)	POP	AX		; Recover input	MOV	ES:[DI+4], AX	POP	ES	POP	DI		RETLoadMagic	ENDP	ASSUME	DS:NOTHING, ES:NOTHING;-------------------------------------------------------------------------IOPEInRam	ENDS;********************************************************************************		END
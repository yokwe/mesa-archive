$MOD186$PAGELENGTH (47)$PAGEWIDTH (136);fileName: TTYHNDLR.asm;Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.$NOLIST;................................................................;Author:	PiE    PxE  Jr.		Date: 23-Jan-85 15:31:56;................................................................;;Revised by:		       Date			Comment;DMS			18-Sep-85 15:56:21	;got rid of 8 byte buffer;DMS			 9-Sep-85 13:22:46	;Added disable interrupts during reg. writing;DMS   			 29-Jul-85 17:59:05	;added EEProm reading code;JPM   			 31-Jul-85  9:36:56	;Opie redesign conversion;DMS   			  3-Aug-85  9:26:26	;changed tests in TTYRxChar;JPM			 12-Aug-85  9:21:11	:Change IOPEInRAM alignment to WORD.;						;;;................................................................; Important Notes:;	The Macros Enable and Disable will not work with TTY handler;;      PORT # 		READ			   	  WRITE;	;	42H	Ch B(DCE) Rx Data (Printer Port)	Ch B Tx Data;	46H	Ch B(DCE) Status (Printer Port)		Ch B Cmd/Parm;The Interrupt Vector Mode table is set as follows:;	0	Tx Buffer Empty Int (Ch B);	1	Ext/Status Change Int (Ch B);	2	Rx Char. available Int (Ch B);	3	Special Rx condition [Parity,overrun,EndOfFrame] (Ch B);	4	...;	5	...;	6	...;	7	...;		**************************************;			BAUD RATE CLOCKS FOR TTY Port;The programmable interval timer which provides the clock to the MPSC chip is an ;i8254 (input clock =6 Mhz);;     PORT #		READ			   WRITE;	;	22H	Timer Counter 1 (DCE/B)		Timer Counter 1;	26H	--------------			Timer Mode Control;		**************************************;;;  	PORT ADDR			WRITE Only;	80H = 0100H		Select Ch B to provide clock to external device	;	PORT ADDR			READ ONLY;	80H = 0100H		TTY Port Ch B DTR' (active Low);		**************************************;;----------- INCLUDE FILES$NOLIST$INCLUDE		(TTYIOFce.asm)$NOLIST$INCLUDE		(TTYHdFce.asm)$NOLIST$INCLUDE		(IOPMacro.asm)$NOLIST$INCLUDE		(RAMEEP.asm)	$LIST;----------------------------------------------------------------------------NAME		TTYHNDLR;PUBLIC		TTYInitEXTRN		TTYHandlerID: 		ABS EXTRN		TTYTxInterrupt: 	ABS EXTRN		TTYRxInterrupt: 	ABS EXTRN		TTYSpecRxInterrupt:	ABS ;;================================================================================;;	IOREGION SEGMENT;================================================================================TTYIOR		SEGMENT	COMMONEXTRN		ttyFcb: 		TTYFCBRecordEXTRN		ChBInitParms:		ChBInitParmsRecTTYIOR		ENDS;================================================================================;;	STACK SEGMENT;================================================================================TTYSTK		SEGMENT	COMMONEXTRN		TTYTxStack: 		WORDEXTRN		TTYSpecRxStack: 	WORDEXTRN		TTYRxStack: 		WORDTTYSTK		ENDS;================================================================================;;;================================================================================;;	TTY PORT HANDLER CODE SEGMENT;================================================================================IOPEInRAM	SEGMENT	WORD PUBLIC		ASSUME	CS:IOPEInRAM;--------------------------------------------------------------------------------;$EJECT;;--------------------------------------------------------------------------------;										-; 	TTY Initialization Task for OPIE					-;--------------------------------------------------------------------------------TTYInit	 PROC 	FAR	%InitializeTask (TTYHandlerID,OFFSET ttyFcb.TxTcb,TTYTxTask,OFFSET TTYTxStack)	%InitializeTask (TTYHandlerID,OFFSET ttyFcb.specRxTcb,TTYSpecRxTask,OFFSET TTYSpecRxStack)	%InitializeTask (TTYHandlerID,OFFSET ttyFcb.RxTaskChBTcb,TTYRxTask,OFFSET TTYRxStack)	RETTTYInit ENDP	;;................................................................................;										.;	INTERRUPT-DRIVEN Tx/Rx PRINTER PORT COMMAND TASKS			.		ASSUME  DS:TTYIOR;................................................................................;;									        ; TTY Transfer Task to control data flow from the printer		        ;................................................................................;; This task is triggered by a notify from the TTY Mesa Head when there is; work to be done; the setting of parameters and/or transfering a character.; The TTYTx task has a 1 byte buffer to hold character to be transfered.; After a character has been outputted the task waits for a Tx buffer interrupt, ; if none occurs then the bad interrupt status is reported in the FCB. ; The statuses are updated, and the Client is notified that a transfer has completed.; The task then returns to wait for a notify.  Note: no protocol is implemented; at this level since there is no way for the pilot clients to specify the protocol; they want to use.;TTYTxTask:	%ThisTaskServices (TTYTxInterrupt,BadTTYTxInterrupt)	%DisableInterruptsTillNextWait	CALL 	TTYParmInit			;Init fcb parmsTTYTaskLoop: 	%WaitForCondition (OFFSET ttyFcb.ttyWorkCondition,noTimeout)	CALL	CheckTTYWorkList		;Check WorkList	MOV	AX, ttyFcb.ttyStatusWord 	;Get status word	AND	AX, ttyTxBufEmpty		;Char to Transfer? Yes then put a character!	JNZ	TTYTaskLoop			;Else Wait	;TTYTxCharFromBuffer:				;else get character 	MOV	AL, ttyFcb.txBuffer		;	;TTYTxCharOut:	%DisableInterruptsTillNextWait	OUT	i8274DCommBDataAddr, AL		;and send it	%WaitForInterrupt (1)	JNC	TTYTxGotIntrpt			;If bad interrupt then char was trashed	INC	ttyFcb.badTTYTxInt		;increment badTxInterrupt counter	;TTYTxGotIntrpt:	CALL	PutAllRRegStatusInFCB		;Update status	;TTYTxCleanUp:	%MesaLockedOut(OR, OFFSET ttyFcb.ttyStatusWord, ttyTxBufEmpty, ttyFcb.ttyLockMask)	%NotifyClientCondition(ttyFcb.ttyClientCondition)	MOV     AL, serialCmd5			;Reset Tx interrupts	OUT	i8274DCommBCtlrAddr, AL	JMP	TTYTaskLoop	;................................................................................;;................................................................................;									       	.;  TTY RECEIVE TASK TO CONTROL DATA FLOW TO THE PRINTER 			.;................................................................................;; This task is triggered by a Receive interrupt from the 8274.  There is also a; 1 byte buffer for this task.   When the Rx interrupt comes in and the buffer is full; then status = dataLost.  Else a character is shaved of its uneccessary bits (Bit7 if; 7BitRxChar), is stored in the buffer, statuses are updated, and the client is notified.; Note: as in the TTYTx task no protocol is implemented in the TTYRx task.  This is ; because there is no way for the Client to communicated to the task which protocol; it is using.;TTYRxTask: 	%ThisTaskServices (TTYRxInterrupt,BadTTYRxInterrupt)TTYRxTaskLoop:	%WaitForInterrupt (noTimeout)	MOV	AX, ttyFcb.ttyStatusWord	;Save statusWord in register	AND	AX, ttyRxBufFull		;If rxBuffer is not Full 	JZ	TTYRxChar			;Then branch to get a character TTYRxDataLost:	IN	AL, i8274DCommBDataAddr		;receive the character	%MesaLockedOut(OR, OFFSET ttyFcb.ttyStatusWord, ttyDataLost, ttyFcb.ttyLockMask)	JMP	TTYRxTaskLoop			;Go wait for next character	;TTYRxChar:	IN	AL, i8274DCommBDataAddr		;receive the character	;-----------------------------------------------------------------------	; Clear bits which are not part of character	MOV	DL, ttyFcb.wr3			;Clear unsignificant bits	AND	DL, rxCharLength		;depending on CharLength	JZ	TTYRxChar5Bits			;5 bit Character	CMP	DL, i8274Rx6BitChar		;	JE	TTYRxChar6Bits			;	CMP	DL, i8274Rx8BitChar	JE	TTYRxCharInBuf			;If 8 bits leave character as is	AND	AL, rxChar7Bits			;For 7 clear MS bit	JMP	SHORT TTYRxCharInBufTTYRxChar6Bits:	AND	AL, rxChar6Bits			;For 6 clear 2 MS bits	JMP	SHORT TTYRxCharInBufTTYRxChar5Bits:	AND	AL, rxChar5Bits			;For 7 clear 3 MS bits	;-----------------------------------------------------------------------	; Put character in buffer and update countersTTYRxCharInBuf:		MOV	TTyFcb.RxBuffer, AL		;Put character in the Rx buffer	%MesaLockedOut(OR, OFFSET ttyFcb.ttyStatusWord, ttyRxBufFull, ttyFcb.ttyLockMask)	;-----------------------------------------------------------------------	; Update statuses and Notify clientTTYRxNotify:	CALL	PutAllRRegStatusInFCB		;Update status	%NotifyClientCondition (ttyFcb.ttyClientCondition) ;Notify Mesa World	;-----------------------------------------------------------------------	; This was added to clear status bits in RR1 after they have been reported	; to the Head in the FCB status.  If this is not done here then the	; status bits will stay latched even when the condition is no longer	; in existance.  The statuses effected are: parity error, crc/framing error	; and Rx overrun error (which causes the SpecRx interrupt).	MOV	AL, errorResetChB		;reset error latches in RR1	OUT	i8274DCommBCtlrAddr, AL		;to enable other error condition	;-----------------------------------------------------------------------TTYRxTaskEndLoop:	JMP	TTYRxTaskLoop			;Continue;...............................................................................;	;...............................................................................;									       .; TTY SPECIAL RECEIVE CONDITION TASK FOR ERROR HANDLING AND STATUS UPDATE      .;...............................................................................; ; This task is triggered by the 8274 Special Receive interrupt.  It is caused by; a receive overrun error.  As described in the Intel handbook, this error is caused;  when "the receive FIFO has been overloaded by the receiver.  The last character ; in the FIFO is overwritten and flagged with this error.  Once the overwritten character; is read, this error condition is latched untill reset."  When this happens ; status = dataLost.TTYSpecRxTask:	%ThisTaskServices (TTYSpecRxInterrupt,BadTTYSpecRxInterrupt)TTYSpecRxTaskLoop:	%WaitForInterrupt (noTimeout)	CALL	PutAllRRegStatusInFCB	; status = dataLost	%MesaLockedOut(OR, OFFSET ttyFcb.ttyStatusWord, ttyDataLost, ttyFcb.ttyLockMask)	MOV	AL, errorResetChB		;reset error latches in RR1	OUT	i8274DCommBCtlrAddr, AL		;to enable other error conditions	%NotifyClientCondition (ttyFcb.ttyClientCondition) ;Notify Mesa World	JMP	TTYSpecRxTaskLoop		;Continue;...............................................................................;$EJECT;;************************************************************************;									*       ;		 TTY  SUPPORT SUBROUTINES   				* ;			     						*;************************************************************************; ;    Initialization Routines					     	;************************************************************************;									        ; This routine is called only once at the beginning of tty Main task.; Its purpose is to initialize the 8274 chip Channel B, the 8254 clock, ; FCB parameters, and tty handler global parameters. I8274 channelB register intitialization; is read from EEProm and has the following intitial values:;  Write Register1: Status Affects Vector on.  This means "the fixed vector, programmed;   in WR2 (by OPIE) is returned from an interrupt acknowledge sequence... the vector;   returned  from an interrupt acknowledge is variable..".;  Write Register3: 8 bit Rx character, Auto Enable On (CD enables Rx, CTS enables Tx).;  Write Register4: clock/data rate multiplier for Tx and Rx set to ;   clock rate = data rate * 16, 1 stop bit, even parity.;  Write Register5: 8 bit Tx character.; Baud rate is intitialized to 9600bps. 	        TTYParmInit	PROC	NEAR	;Initialize FCB Parameters	;-----------------------------------------------------	; Read EEPROM 	%ReadEEProm(eePromRS232DCEtype,1)	MOV	ttyFcb.eepromImage.ttyDeviceTypeChB, AL	%ReadEEProm(eePromRS232DCEattr,1) 	MOV	ttyFcb.eepromImage.ttyAttributesChB, AL	; Hard Coded initial workList	MOV 	ttyFcb.wr1, i8274VarVect	MOV 	ttyFcb.wr3, i8274Rx8BitChar	MOV	ttyFcb.wr4, i8274x16Clock+i8274StopBits1+i8274EvenParity	MOV	ttyFcb.wr5, i8274Tx8BitChar	MOV	CHBInitParms.errReset, i8274ErrorReset	MOV	CHBInitParms.bwr4 - 1, i8274WriteRegister4	MOV	CHBInitParms.bwr1 - 1, i8274WriteRegister1	MOV	CHBInitParms.bwr3 - 1, i8274WriteRegister3	MOV	CHBInitParms.bwr5 - 1, i8274WriteRegister5	MOV	CHBInitParms.ex1reset, i8274RstIntrCommand	MOV	CHBInitParms.ex2reset, i8274RstIntrCommand	MOV	CHBInitParms.eot, 0	CALL	i8274Binit			;init ChbParms	;-----------------------------------------------------	MOV	ttyFcb.ttyBaudRate, Baud1200	;Set baud rate in FCB	CALL	PtrBaudInit			;init printer baud rate	%GetLockMask	MOV   	ttyFcb.ttyLockMask, AX		;Init FCB lock mask 	%GetWorkMaskForCondition (OFFSET ttyFcb.ttyWorkCondition)	MOV	ttyFcb.ttyWorkMask, AX		;Init FCB work mask	CALL	PutAllRRegStatusInFCB		;Init FCB status 	MOV	ttyFcb.ttyStatusWord, ttyTxBufEmpty	XOR	AX, AX			MOV	ttyFcb.ttyWorkList, 0 	MOV	ttyFcb.badTTYTxInt, AX	MOV	ttyFcb.badTTYRxInt, AX	MOV	ttyFcb.badSpecRxInt, AX	RET TTYParmInit 	ENDP;	******************;; TTY uses output of the i8254. Input clock freq is 4 MHz.For now, we set up ; for 1200 baud Program Timers to generate sq wave  and divide input clock by ; 208 Set rate factor on 8274. So... 4 MHz / 208 / 16 = 1200 baud.; This routine is called whenever the BaudRate needs to be set.PtrBaudInit	PROC	NEAR   		;Timer 1 to provide baud rate for printer	MOV	AL, i8254SelCount1+i8254LSBthenMSB+i8254SqWave+i8254BinaryCount;	OUT	i8254Ctlr,AL		;Write COntrol Word	MOV	AX, ttyFcb.ttyBaudRate	;Set BX to = fcb baud rate	OUT	i8254Count1,AL		;LS byte	MOV	AL, AH	OUT	i8254Count1, AL		;MS byte	RETPtrBaudInit	ENDP;	******************;; This routine is called only once by TTYParmInit and its purpose is to initialize; the 8274 chip channel B with the values in ChBInitParms record. The order of ; initialization is:  Error Reset, Write Register 4, Write Register 1, Write Register 3,; Write Restister 5, ExternalStatusReset, ExternalStatusReset.i8274Binit	PROC	NEAR	CLI	MOV	CL, ttyFcb.wr4		;move the write register values	MOV	ChBInitParms.bwr4, CL	;move the write register values	MOV	CL, ttyFcb.wr1	MOV	ChBInitParms.bwr1, CL	MOV	CL, ttyFcb.wr3	MOV	ChBInitParms.bwr3, CL	MOV	CL, ttyFcb.wr5	MOV	ChBInitParms.bwr5, CL	MOV	DI, OFFSET ChBInitParms	;Point DI to channel B parms in IO region	MOV	DX, i8274DCommBCtlrAddr	;point DX to printer(DCE) port on IOPLoadParam:	MOV	AL, DS:[DI]		; get parm	CMP	AL, 0			; is it a 0	JE	BinitDone		; go do a return if done with ch B init	OUT	DX, AL			; send parm to the MPSC	INC	DI			; point to next parm in the list	JMP	LoadParam		; go get next parmBinitDone:	STI	RET				; return when donei8274Binit	ENDP;************************************************************************;;  	 TTY Handler Work Routines ;************************************************************************; This routine is called by tty Tx task and is called when ever there is work to be; done.  It reads the value of the work-list and sets it to zero, then analyzes the bits; in the work-list finding what work needs to be done.  The type of work that can be done; is changes to the write Registers, or baud rate.  The new value for the write registers; and baud rate are pulled from the FCB.  After work has been done, status is updated in ; the FCB and Cleint is notified.  Note that interrupts are disabled while these settings are changed in case; any tty interrupts are triggered during this period.  Interrupts are re-enabled by doing; a WaitForSystem macro.;CheckTTYWorkList	PROC	NEAR	%MesaLockedOut (XCHG, OFFSET ttyFcb.ttyWorkList, 0, ttyFcb.ttyLockMask)	MOV	CX, AX	AND	AX, workToBeDone		;Work to be done ?	JNZ	TTYWorkToDo	JMP	CheckTTYWorkExit		;No then Exit	TTYWorkToDo:	;Clear Tx and Rx enable bits	MOV	DX, i8274DCommBCtlrAddr		;point DX to printer port on IOP	MOV	BL, FALSE			;BL is work done flag	CLICheckWorkWR4:	MOV	AX, CX	AND	AX, ttyWorkWR4			;Work for WR4?	JZ	CheckWorkWR1			;No branch	MOV	AL, i8274WriteRegister4	OUT	DX, AL	MOV	AL, ttyFcb.WR4			;Write new value 	OUT	DX, AL	MOV	BL, TRUE	CheckWorkWR1:	MOV	AX, CX	AND	AX, ttyWorkWR1			;Work for WR3 ?	JZ	CheckWorkWR3			;No Branch	MOV	AL, i8274WriteRegister1	OUT	DX, AL	MOV	AL, ttyFcb.WR1			;Write new WR3 value 	OUT	DX, AL	MOV	BL, TRUECheckWorkWR3:	MOV	AX, CX	AND	AX, ttyWorkWR3			;Work for WR3 ?	JZ	CheckWorkWR5			;No Branch	MOV	AL, i8274WriteRegister3	OUT	DX, AL	MOV	AL, ttyFcb.WR3			;Write new WR3 value 	OUT	DX, AL	MOV	BL, TRUECheckWorkWR5:	MOV	AX, CX	AND	AX, ttyWorkWR5			;Work for WR5?	JZ	CheckWorkBaudRate		;No branch Controller	MOV	AL, i8274WriteRegister5	OUT	DX, AL	MOV	AL, ttyFcb.WR5			;Write new value 	OUT	DX, AL		MOV	BL, TRUECheckWorkBaudRate:	MOV	AX, CX	AND	AX, ttyWorkBaudRate		;BaudRate changed?	JZ	TTYUpdateStatus			;No Branch	CALL	PtrBaudInit			;???	MOV	BL, TRUE	TTYUpdateStatus:	CMP	BL, TRUE	JNE	CheckTTYWorkExit	CALL	PutAllRRegStatusInFCB	;Only if WorkList changed	%NotifyClientCondition(ttyFcb.ttyClientCondition) 	STICheckTTYWorkExit: 	RETCheckTTYWorkList  ENDP	;	******************; This routine updates FCB statuses including Read Register 0, 1, and 2,; and the IOP port status (80H).;PutAllRRegStatusInFCB PROC NEAR	MOV	DX, i8274DCommBCtlrAddr	CLI	;-- perform 2 reset external status interrupt commands	;-- to get the true readings of CTS and CD bits	;-- since not catching external/status interrupts	MOV	AL, i8274RstIntrCommand	OUT	DX, AL	MOV	AL, i8274RstIntrCommand	OUT	DX, AL	;--------------	MOV	AL, i8274ReadRegister0	OUT	DX, AL			;Point to RR0	IN	AL, DX			;get RR0	MOV	ttyFcb.rr0, AL	MOV	AL, i8274ReadRegister1	OUT	DX, AL			;Point to RR1	IN	AL, DX			;get RR1	MOV	ttyFcb.rr1, AL	IN	AX, ReadInputPort	;Read input port	MOV	ttyFcb.iopSystemInputPort, AH	STI	RETPutAllRRegStatusInFCB	ENDP;************************************************************************;;  	 Bad Interupt Service Routines		ASSUME	DS:NOTHING;************************************************************************; This routine is called when a txBufferEmpty interrupt comes in when the TTYTx task; is not waiting for it.BadTTYTxInterrupt	PROC	FARTTYBadTxInt:	%EstablishHandlerAccess (TTYHandlerID)	ASSUME	ES:TTYIOR	INC	ttyFcb.badTTYTxInt			;increment bad int count	MOV     AL, serialCmd5			;Reset Tx interrupts	OUT	i8274DCommBCtlrAddr, AL	RET					;The waitForInterrupt is still in effectBadTTYTxInterrupt	ENDP	ASSUME	ES:NOTHING;	******************; This routine is called when a rxCharacter interrupt comes in when the TTYRx task; is not waiting for it.BadTTYRxInterrupt	PROC	FARTTYBadRxInt:	%EstablishHandlerAccess (TTYHandlerID)	PUSH	DS	MOV	AX, ES	MOV	DS, AX	ASSUME	DS:TTYIOR	INC	ttyFcb.badTTYRxInt			;increment bad int count	IN      AL, i8274DCommBDataAddr	; status = dataLost	%MesaLockedOut(OR, OFFSET ttyFcb.ttyStatusWord, ttyDataLost, ttyFcb.ttyLockMask)	POP	DS	ASSUME	DS:NOTHING	RET					;The waitForInterrupt is still in effectBadTTYRxInterrupt	ENDP;	******************; This routine is called when a specRx interrupt comes in when the TTYSpecRx; task is not waiting for it.BadTTYSpecRxInterrupt	PROC	FARTTYBadSpecRxInt:	%EstablishHandlerAccess (TTYHandlerID)	PUSH	DS	MOV	AX, ES	MOV	DS, AX	ASSUME	DS:TTYIOR	INC	ttyFcb.badSpecRxInt	;increment bad int count	MOV	AL, i8274ErrorReset		;reset error latches in RR1	OUT	i8274DCommBCtlrAddr, AL		;to enable other error conditions	; status = dataLost	%MesaLockedOut(OR, OFFSET ttyFcb.ttyStatusWord, ttyDataLost, ttyFcb.ttyLockMask)	POP	DS	ASSUME	DS:NOTHING	RET					;The waitForInterrupt is still in effectBadTTYSpecRxInterrupt	ENDP ;************************************************************************IOPEInRAM	ENDS	;================================================================================		END
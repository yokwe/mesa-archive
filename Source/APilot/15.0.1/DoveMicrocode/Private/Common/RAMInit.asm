$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1985 by Xerox Corporation. All rights reserved.;-- stored as [Idun]<WDLion>Dove>RAMInit.asm;-- last edited by:;--	JAC	22-Jan-87 11:51:29	:GermInit moves to memory;--	JAC	12-Jan-87 19:09:22	:use EstablishHandlerAccess instead of getting BootStrapIOR directly;--	kek	 1-Oct-86 16:45:19	:fixed bad constant in ReadOptionHandlerData.;--	kek	20-Aug-86 19:26:52	:changes to support multiple options:;		new IOPE@{GetOptionsInterrupt/{WaitFor/Release}DMAChannel},;		and OptionsInterruptProcessing,;		revised old ReadOptionHandlerData/IOPE@Disable/IOPE@Enable...!;--	RDH	14-Apr-86 11:51:45	:Change to start main memory handlers before ram handlers.;--	KEK	16-Mar-86 15:27:04	:add options handler optional starting.;--	JAC	 6-Jan-86 14:13:17	:make it possible for this code to go in main memory;--	JAC	10-Dec-85 12:42:54	:look for handlers in main memory;--	JPM	18-Sep-85  8:44:29	:Removed hardware init code (now unneeded or in initialization proc).;--	JPM	16-Sep-85 12:39:53	:Changed condition for assembly of master i8259 reinitialization (Opie now sets up for non-vectored i8274).;--	JPM	11-Sep-85  8:59:10	:Implement i8274 non-vectored mode.;--	JPM	12-Aug-85  9:13:17	:Change IOPEInRAM alignment to WORD.;--	JPM	30-Jul-85  8:46:16	:Don't reset mesaProcessor (it messes up the start sequence);--	JPM	29-Jul-85 16:02:09	:Use OpieIORComplete: before OpieIORinRAM offsets;--	JPM	25-Jul-85 15:15:23	:Initialize mesaPageMapSegment, fix bug in  InitializeOpieIOR;--	JPM	24-Jul-85 12:04:23	:Don't zero IORegion (done in MesaVM now);--	JPM	22-Jul-85 11:48:07	:Use HardOpie.asm;--	JPM	 2-Jul-85  8:10:42	:Added to i8274 initialization (put in variable vector mode);--	JPM	27-Jun-85 17:05:35	:Created from IOPInit.asmNAME			RAMInit;--------------------------------------------------------------------------------$NOLIST$INCLUDE		(IOPDefs.asm)$INCLUDE		(HardDefs.asm)$INCLUDE		(OpieDefs.asm)$INCLUDE		(IOPMacro.asm)$LIST$INCLUDE		(OpieMac.asm)$INCLUDE		(RAMEEP.asm);--------------------------------------------------------------------------------EXTRN			BootStrapHandlerID: ABSIOPELocalRAM		SEGMENT	AT 0EXTRN			IORSegmentTableAddress: SegmentAndOffsetEXTRN			IOROpieSegmentAddress: WORDEXTRN			HandlerInitProcTable: SegmentAndOffsetIOPELocalRAM		ENDS;--------------------------------------------------------------------------------BootStrapIOR		SEGMENT	COMMONEXTRN			bootBufferPtr: WORDEXTRN			bootMemoryPtr: WORDBootStrapIOR		ENDS;--------------------------------------------------------------------------------OpieIOR			SEGMENT	COMMONOpieIOR			ENDSOpieIORinRAM		SEGMENT	WORD COMMONEXTRN			options0ICB: InterruptContextBlockEXTRN			TTYTxICB: InterruptContextBlockOpieIORinRAM		ENDSOpieIORComplete		GROUP	OpieIOR, OpieIORinRAM;--------------------------------------------------------------------------------OpieSTK			SEGMENT	COMMONEXTRN			IOPEStack: WORDOpieSTK			ENDS;********************************************************************************IOPEInRAM		SEGMENT		WORD PUBLIC			Assume CS:IOPEInRAMoutsideJump		DW	?outsideJumpCS		DW	?i8259OptionsSlaveIntrptVctType	EQU	72	;also def'd in HardOpie;--------------------------------------------------------------------------------%SET(softwareVectorsPresent,0)%*DEFINE(SystemCall(Name))(%IF(%EQS(%whereDefined,RAM)) THEN (%SET(softwareVectorsPresent,1)			DW	%Name%(SIVType)*4			DW	OFFSET IOPE@%Name)FI)%' End %*DEFINE(SystemCall(Name))beginSoftwareIVTable:$SAVE$GENONLY			%SystemCalls$RESTOREendSoftwareIVTable:sizeOfSoftwareIVTable	EQU	(endSoftwareIVTable-beginSoftwareIVTable)numberOfSoftwareIVsForRAMFunctions	EQU	sizeOfSoftwareIVTable/4;--------------------------------------------------------------------------------PUBLIC RAMInitializationRAMInitialization:			CLI			;Absolutely no interrupts allowed.SetUpDSforIntrptVcts:	MOV	DX, IOPELocalRAM			MOV	DS, DX		;to load interrupt vectors.			ASSUME	DS:IOPELocalRAM; set up stack segment and init pointer			LES	BX, IORSegmentTableAddress			MOV	SS, ES:[BX].stackSegment			MOV	SP, OFFSET IOPEStack%IF(%softwareVectorsPresent) THEN (;load additional software vectors from data tableSoftwareVectors:	MOV	CX, numberOfSoftwareIVsForRAMFunctions			MOV	SI, OFFSET beginSoftwareIVTableInitializeSoftwareVectors:			MOV	DI, CS:[SI]			MOV	AX, CS:[SI]+2			MOV	[DI].offsetValue, AX			MOV	[DI].segmentValue, CS			ADD	SI, 4			LOOP	InitializeSoftwareVectors ;Loop until done) FI			MOV	DS, IOROpieSegmentAddress			ASSUME	DS:OpieIORComplete			MOV	DX, IOPELocalRAM			MOV	ES, DX			ASSUME	ES:IOPELocalRAM;call initialization routinesCallInitRoutines:			PUSH	ES;			CALL	GermInit			POP	ES			CALL	SetUpReimplementedOpieMacros			CALL	SetUpOptionsInterruptProcessing%IF(%i8274NonVectored) THEN (			CALL	SetUpi8274InterruptProcessing) FI; The CPBermuda handler needs to run before the MesaUpDn handler.  ; Since the CPBermuda handler is usually located in Main memory start ; the main memory handlers first.  For the cases where CPBerm and ; MesaUpDn are both in RAM or both in main memory all is well since ; CPBerm has a lower handler id and therefore is started first.; Now call InitializeMemFunctions in MemHInit to start up memory based handlers.			PUSH	ES			%EstablishHandlerAccess(BootStrapHandlerID)			ASSUME 	ES: BootStrapIOR			MOV 	AX, bootMemoryPtr			POP	ES			ASSUME 	ES: NOTHING			MOV	outsideJumpCS, AX			MOV	outsideJump, 0			CALL 	DWORD PTR outsideJump			; Now call InitializeRAMFunctions in RAMHInit to start up RAM based handlers.			PUSH	ES			%EstablishHandlerAccess(BootStrapHandlerID)			ASSUME 	ES: BootStrapIOR			MOV 	AX, bootBufferPtr			SHR	AX, 4		;convert to a paragraph boundary			POP	ES			ASSUME 	ES: NOTHING			MOV	outsideJumpCS, AX			MOV	outsideJump, 0			CALL 	DWORD PTR outsideJump			;Determine which 3 options exist from EEPROM and start up the associated; handlers.			MOV	AX, IOPELocalRAM			MOV	ES, AX			ASSUME	ES:IOPELocalRAM			MOV	BX, eePromOption1			CALL	ReadOptionHandlerData			MOV	BX, eePromOption2			CALL	ReadOptionHandlerData			MOV	BX, eePromOption3			CALL	ReadOptionHandlerData			InitDone:		%ReturnToSystemLoop;-------------------------------------------------------------------------------;Determine if the option exists, from EEPROM, and start up the associated; handler.  (Initialize{RAM,Mem}Functions already put the options handlers'; InitProcs in table; must assume Init'{RAM,Mem}F'n didn't start/call it).;@Entry: BX has EEProm pointer, ES has IOPELocalRAM.;@Call to InitProc: DX has interrupt mask, AX has option-specific data.;@Exit: ES is preserved and the handler has been started if it is present.ReadOptionHandlerData	PROC	NEARReadOptionHandlerDataEntry:			%ReadEEProm(BX, 1)			JC	DontStart		;don't start if bad EEP			MOV	DX, AX			MOV	BX, AX	;BX ¬ offset pointer to InitProc			SHR	BX, 11			JZ	DontStart			ADD	BX, 128-32	;convert EEP data to hdlrID			IMUL	BX, SIZE SegmentEntry	;get index into table	;DX ¬ interrupt mask			AND	DX, 000FFH	;AX ¬ specific data			SHR	AX, 8			AND	AX, 07H	;start up options handler.			PUSH	ES			CALL	DWORD PTR HandlerInitProcTable[BX]			POP	ESDontStart:		RETReadOptionHandlerData	ENDP;--------------------------------------------------------------------------------;Set up new software interrupt vectors for those ROM software interrupts that are; now reimplemented in RAM.  ES points to IOPELocalRAM.SetUpReimplementedOpieMacros:		;overwrite local IOPE@Disable over ROM IOPE@Disable			MOV	DI, DisableSIVType*4	;addr I want to insert at			MOV	ES:[DI].offsetValue, OFFSET IOPE@Disable			MOV	ES:[DI].segmentValue, CS		;overwrite local IOPE@Enable over ROM IOPE@Enable			MOV	DI, EnableSIVType*4	;addr I want to insert at			MOV	ES:[DI].offsetValue, OFFSET IOPE@Enable			MOV	ES:[DI].segmentValue, CS			RET;--------------------------------------------------------------------------------;local pointer to IOPKernl's GenericInterruptProcessing label.			EVENLocalGIP		DD	?;--------------------------------------------------------------------------------;Set up the options interrupt context block so that it handles non-autovectored; interrupt before jumping into the normal GenericInterruptProcessing.  In the; SetUp, a copy of the GenericInterruptProcessing address must be made local.; (the copy, in LocalGIP, is gotten from the ptr previously in option0's ICB...); DS must be pointing to OpieIORComplete.SetUpOptionsInterruptProcessing:		;create a local copy of GenericInterruptProcessing			MOV	DI, OFFSET OpieIORComplete:options0ICB+2			MOV	AX, [DI].segmentValue			MOV	CS:LocalGIP.segmentValue, AX			MOV	AX, [DI].offsetValue			MOV	CS:LocalGIP.offsetValue, AX		;point options ICB to OptionsInterruptProcessing			MOV	DI, OFFSET OpieIORComplete:options0ICB+2			MOV	[DI].segmentValue, CS			MOV	[DI].offsetValue, OFFSET OptionsInterruptProcessing			RETOptionsInterruptProcessing:	;AL gets offset interrupt vector bits (from options base vector)			MOV	AL, i8259Poll			OUT	i8259OptionsSlaveAddr0, AL			IN	AL, i8259OptionsSlaveAddr0	;check that there really was an interrupt			MOV	BL, AL			AND	BL, 80H			JZ	IgnoreOptionsInterrupt	;convert AX into a pointer to the actual ICB			AND	AX, 0007H	;isolate vector offset bits			;???ADD	AL, i8259OptionsSlaveIntrptVctType			MOV	BL, SIZE InterruptContextBlock			IMUL	BL	;modify ICB on stack to be ptr to actual ICB			POP	DI			ADD	DI, AX			PUSH	DI	;before departing, send EOI to options interrupt controller			MOV	AL, i8259EOINonSpecific			MOV	DX, i8259OptionsSlaveAddr0			OUT	DX, AL	;transfer control to normal interrupt processing code in IOPKernl			JMP	DWORD PTR CS:LocalGIP			IgnoreOptionsInterrupt:	ADD	SP, 4		;Skip IC seg & offset			POPA			IRET;-------------------------------------------------------------------------------;Set up RS232 interrupt context block so that it handles non-autovectored; interrupts before jumping into the normal GenericInterruptProcessing.  Note; that RS232 uses the LocalGIP label set up by SetUpOptionsInterruptProcessing.; DS must be pointing to OpieIORComplete.%IF(%i8274NonVectored) THEN (SetUpi8274InterruptProcessing:		;point TTY ICB to i8274InterruptProcessing			MOV	DI, OFFSET OpieIORComplete:TTYTxICB+2			MOV	[DI].segmentValue, CS			MOV	[DI].offsetValue, OFFSET i8274InterruptProcessing			RETi8274InterruptProcessing:	;AL gets offset interrupt vector bits (from RS232 base vector)			MOV	AL, i8274ReadRegister2			OUT	i8274DCommBCtlrAddr, AL			IN	AL, i8274DCommBCtlrAddr	;convert AX into a pointer to the actual ICB			MOV	BL, SIZE InterruptContextBlock			IMUL	BL	;modify ICB on stack to be ptr to actual ICB			POP	DI			ADD	DI, AX			PUSH	DI	;transfer control to normal interrupt processing code in IOPKernl			JMP	DWORD PTR CS:LocalGIP) FI;-------------------------------------------------------------------------------;-- System level services: (Macro call is - "GetOptionsInterrupt()"  );-------------------------------------------------------------------------------;--------------|								|;--------------|	Entry: DX contains mask which has bits set for		|;--------------|		all interrupts used by this option.		|;--------------|		eg, if uses options IR0 and IR4, then mask	|;--------------|		mask is 00001001binary.				|;--------------|	       CX number for which single interrupt the option	|;--------------|		wants info on. eg, "1" will return info on	|;--------------|		highest priority, eg IR0; "2" will return info	|;--------------|		on the IR4 of the example. CX IN [1..7] only.	|;--------------|--------							|;--------------|	Exit: BX has options int vector number in range 72-79	|;--------------|	      AX has mask of the one interrupt asked about.	|;--------------|      (eg for the given example, CX=1 => AX¬00000001 and BX¬72)	|;--------------|	      Only CX is smashed.				|;--------------|								|;-------------------------------------------------------------------------------;the handler can call ThisTaskServices/Enable/Disable with BX;the handler can program it's own on-board interrupt-select regs with AX.IOPE@GetOptionsInterrupt:			MOV	BX, i8259OptionsSlaveIntrptVctType			MOV	AX, 01H			JMP	SHORT ShiftLoopEntryShiftLoop:		SHL	AX, 1			INC	BXShiftLoopEntry:		PUSH	AX			AND	AX, DX			POP	AX			JZ	ShiftLoop			LOOP	ShiftLoop			IRET			;-------------------------------------------------------------------------------;-- System level services: (Macro call is - "WaitForDMAChannel()"  );-------------------------------------------------------------------------------;--------------|	TBD							|;--------------|--------							|;--------------|								|;-------------------------------------------------------------------------------IOPE@WaitForDMAChannel:			IRET			;-------------------------------------------------------------------------------;-- System level services: (Macro call is - "ReleaseDMAChannel()"  );-------------------------------------------------------------------------------;--------------|	TBD							|;--------------|--------							|;--------------|								|;-------------------------------------------------------------------------------IOPE@ReleaseDMAChannel:			IRET			;-------------------------------------------------------------------------------;-- System level services: (Macro call is - "Disable (interruptName)"  );-------------------------------------------------------------------------------;--------------  Assumes:							|;--------------|		BX = interrupt vector number.			|;--------------|--------							|;--------------| Upon exiting the specified interrupt is disabled		|;--------------|								|;-------------------------------------------------------------------------------;Note must run with interrupts off (default since INT turns off IF) because; interrupt level could also disable its own interrupt channel.	IOPE@Disable:			PUSHA			CALL	GetInterruptMask			JZ	IOPE@D@CantBeMasked			NOT	AH			OR	AL, AH			OUT	DX, ALIOPE@D@CantBeMasked:	POPA			IRET;-- System level services: (Macro call is - "Enable (interruptName)"  );-------------------------------------------------------------------------------;--------------  Assumes:							|;--------------|		BX = interrupt vector number.			|;--------------|--------							|;--------------| Upon exiting the specified interrupt is enabled		|;--------------|								|;-------------------------------------------------------------------------------		IOPE@Enable:			PUSHA			CALL	GetInterruptMask			JZ	IOPE@E@CantBeMasked			AND	AL, AH			OUT	DX, ALIOPE@E@CantBeMasked:	POPA			IRET;Routine to get interrupt data in AX, Port in DX.;Returns DX/ interruptMaskPort;	AH/ interruptMask;	AL/ Current Interrupt Mask data;	ZF=1 if it can't be masked, =0 if it can. (so can JZ <not>)GetInterruptMask:	PUSH	DS			PUSH	CX		;save vct addr...			MOV	CX, BX	;BX ¬ ptr to ICB, SI ¬ ptr to interrupt controller			MOV	AX, IOPELocalRAM			MOV	DS, AX			SHL	BX, 2		;BX has an interrupt number.			LDS	BX, DWORD PTR [BX]			MOV	SI, [BX].ICBcontext.interruptController			MOV	DX, [SI].interruptMaskPort	;if interrupt controller is a software interrupt "controller", unmaskable.			CMP	DX, Null			JZ	GetInterruptMaskExit	;if the interrupt controller is real, AH ¬ mask from ICB.			MOV	AH, [BX].ICBcontext.interruptMask			PUSHF	;if the interrupt controller is options slave, AH ¬ mask derived from vector addr			CMP	[SI].interruptMaskPort, i8259OptionsSlaveAddr1			JNE	NotOptionsControllerOptionsController:	SUB	CX, i8259OptionsSlaveIntrptVctType			MOV	AH, 01			SHL	AH, CL			NOT	AHNotOptionsController:	IN	AL, DX			POPFGetInterruptMaskExit:	POP	CX			POP	DS			RETIOPEInRAM		ENDS;********************************************************************************			END
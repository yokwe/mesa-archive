$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;-- Floppy boot head;-- stored as [Iris]<WMicro>Dove>RAMFlpBt.asm;-- last edited by:;--	RK		24-Nov-87 21:42:52	Added firstTrack reference for new flopface.asm(e.g. flppyIOCB.firstTrack.TotalBytesToTransfer) ;--	RDH		31-Jan-87 13:02:53	Twiddle constant for dove commonality, add code to handle 1.2 MB floppy booting. ;--	RCH		28-Jan-87 12:33:55	Add code to SetUpMesaBoot for dove commonality, include HardDefs.asm ;--	JPM		20-Sep-85 10:39:26      Do boot buffer allocation.;--	JPM		19-Sep-85 13:32:25      Fix bug in LoadSectorLoop (misplaced POPA).;--	kek		 4-Sep-85 16:17:47      more mp code, use public mp rtn.;--	JPM		 4-Sep-85  8:17:23	Standardize MP codes, remove display change;--	JPM		 3-Aug-85  7:52:10	New FlopFace;--	JPM		29-Jul-85 11:32:37	Use floppyBootFileAddress;--	JPM		18-Jul-85 14:44:51	Opie redesign conversion;--	JMM		30-Jun-85 16:06:15	Restored termination protocol.;--	JMM		29-Jun-85 18:13:06	Upgraded to new IOPLRAM.asm.;--	JMM		29-Jun-85 17:59:47	Got rid of IOPMcRAM and restored IOPMacro.;--	JPM		13-Jun-85 14:41:45	Jump to opieReentry if problems reading floppy;--	JPM		 7-Jun-85 12:21:19	Add sectorSize to startOfBootBufferSpace (so won't clobber code during overlay booting);--	JPM		 5-Jun-85 14:57:37	Use doneWithDBFile and doneWithGermFile for control flow;--	JPM		31-May-85  9:10:05	Move seekRec and sisRec to first sector (in case we need to recalibrate first read);--	JPM		22-May-85  9:29:47	Remove INCLUDE of IOPLRam.asm, use EXTRNs;--	JPM		30-Apr-85 16:19:47	Remove temp ethernet initialization call:;--						fix first Copy: move seek check inside FloppyRead;--	JPM		26-Mar-85 13:02:55	Convert to new floppy IOCB format & boot file locations;--	JPM		11-Mar-85 15:30:55	Add temp ethernet initialization call;--	JPM		 5-Mar-85 16:45:06	Remove temporary stuff;--	JPM		14-Feb-85  8:57:25	Temp patch to disable ethernet until handler works better;--	JPM		14-Dec-84 10:15:02	Added last byte check for temporary error detection;--	JPM		13-Dec-84  9:10:32	Changed value of CounterControlRegister;--	JPM		10-Dec-84  9:03:00	Added display border setting (so maint panel can be seen),;--						use RAM version of IOPMacro;--	JPM		 8-Dec-84 21:38:30	Fixed IOCB.OperationQueued, added maint panel codes;--	JPM		 4-Dec-84 13:55:31	Fixed bug in calculation of startOfBootBufferSpace;--	JPM		30-Nov-84 13:49:58	Changed references to IOPELocalRAM to EXTRNs; Restart BootTask;--	JPM		21-Nov-84 8:36:04NAME			RAMFlpBt;--------------------------------------------------------------------------------;$NOLIST$INCLUDE		(IOPDefs.asm)$INCLUDE		(RAMBDefs.asm)$INCLUDE		(IOPMacro.asm)$INCLUDE		(QueDefs.asm)$INCLUDE		(FlpBDefs.asm)$INCLUDE		(FlopFace.asm)$INCLUDE		(HardDefs.asm)	$LISTEXTRN			BootStrapHandlerID: ABSEXTRN			FloppyHandlerID: ABSEXTRN			DisplayMPCode: NEAR%*DEFINE		(Copy	(to,from,bytes))			   LOCAL Lbl0			   (	XOR	SI,SI			%Lbl0:	MOV	AL, BYTE PTR %from[SI]				MOV	BYTE PTR %to[SI], AL				INC	SI				CMP	SI, %bytes				JL	%Lbl0				);--------------------------------------------------------------------------------IOPELocalRAM	SEGMENT	AT 0EXTRN		opieReentry: DWORDEXTRN		bootType: BYTEEXTRN		bootRetryCount: WORDEXTRN		floppyBootFileAddress: WORDEXTRN		startOfBootBufferSpace: WORDEXTRN		HandlerInitProcTable: DWORDIOPELocalRAM	ENDS;--------------------------------------------------------------------------------BootStrapIOR		SEGMENT	COMMON			ASSUME	DS:BootStrapIOREXTRN			bootBufferEmpty: ConditionEXTRN			bootBufferFull: ConditionEXTRN			startOfBootBufferPool: WORDEXTRN			bootDeviceIORSpace: FloppyBootAreaEXTRN			bootStrapTask: TaskContextBlockEXTRN			bootTask: TaskContextBlockEXTRN			getBootFile: ConditionEXTRN			finishedLoaderFileFetch: ConditionflppyIOCB		EQU	bootDeviceIORSpace.floppyIOCBflppyIOCBplusOneCmd	EQU	flppyIOCB+SIZE(fdcCommandRecord)flppyIOCBplusTwoCmds	EQU	flppyIOCB+2*SIZE(fdcCommandRecord)floppyWorkspace		EQU	bootDeviceIORSpaceendOfTrackSect		EQU	bootDeviceIORSpace.sectorsPerTrackdataGapLen		EQU	bootDeviceIORSpace.dataGapLengthBootStrapIOR		ENDS;--------------------------------------------------------------------------------FloppyIOR		SEGMENT	COMMONEXTRN			Floppy80186Queue: QueueBlockEXTRN			FloppyWorkNotify: ConditionEXTRN			FloppyDCB0: WORDFloppyIOR		ENDS;--------------------------------------------------------------------------------MaintPanelIOR		SEGMENT	COMMONEXTRN			maintPanelCode: WORDEXTRN			maintPanelChanged: ConditionMaintPanelIOR		ENDS;--------------------------------------------------------------------------------BootStrapSTK		SEGMENT	COMMONEXTRN			BootStack: WORDBootStrapSTK		ENDS;--------------------------------------------------------------------------------IOPEInRam		SEGMENT	PUBLIC			ASSUME	CS:IOPEInRamPUBLIC			RamFlpEntryPointEXTRN			BootTaskInit: NEAREXTRN			EndOfInitial: NEAR; organization:;	(1)	Load rest of FloppyInitial.db (from cyl. 5, head 0, sectors 2-n);	(1.5)	Note what kind of floppy we are and set variables accordingly.;	(2)	Read root page (from cyl. 4, head 0, sector 1);	(3)	Invoke UI to select boot sequence;	(4)	Load each file in turn, one buffer (= one sector) at a time;	(5)	Give up TCB (?)			ORG	0RamFlpEntryPoint:; step 1; set up ES for access to boot variables			MOV	AX, IOPELocalRAM			MOV	ES, AX			ASSUME	ES:IOPELocalRAM; initialize part of workspace and copy IOCB image into work area;  Note: workspace overlays the first 22 bytes of the IOCB (which are not used by the handler)			MOV	CH, initialCodeCylinder			MOV	floppyWorkspace.currentCylinder, CH			%Copy	(flppyIOCB.OperationIsQueued,CS:initialRec,sizeInitialRec)			MOV	BX, startOfBootBufferSpace			ADD	BX, sectorSize			MOV	flppyIOCB.DataAddress.OpieAddressLow, BX			MOV	AX, OFFSET EndOfInitial-1			AND	AX, NOT(sectorSize-1)			MOV	flppyIOCB.firstTrack.TotalBytesToTransfer, AX			MOV	flppyIOCB.firstTrack.FirstDMAtransferCount, AX; change startOfBootBufferSpace to point past end of code			ADD	startOfBootBufferSpace, OFFSET EndOfInitial	; call FloppyReadGetRestOfInitial:	CALL	FloppyRead			JMP	RamFlpCont; put FloppyRead and IOCB initial rec here, so will be in first sectorSize bytes; proc to read from floppyFloppyRead		PROC; first check if on right cylinderCheckForSeek:		CMP	CH, floppyWorkspace.currentCylinder			JE	EnqueueIOCB; need a seek. Copy command record #1 to #3, set up #1 and #2 for seek/sis			MOV	floppyWorkspace.currentCylinder, CH			%Copy	(flppyIOCBplusTwoCmds.fdcCommands,flppyIOCB.fdcCommands,SIZE(fdcCommandRecord))			%Copy	(flppyIOCB.fdcCommands,CS:seekRec,sizeSeekRec)			MOV	flppyIOCB.fdcCommands.NumberOfResultBytes,0			%Copy	(flppyIOCBplusOneCmd.fdcCommands,CS:sisRec,sizeSisRec)			MOV	flppyIOCBplusOneCmd.fdcCommands.NumberOfResultBytes,2			MOV	flppyIOCB.NumberOfFDCCommands, 3; put IOCB onto floppy queueEnqueueIOCB:		MOV	flppyIOCB.OperationState, OperationWaiting			PUSH	ES			%EstablishHandlerAccess	(FloppyHandlerID)			ASSUME	ES:FloppyIOR			MOV	Floppy80186Queue.queueNext.OpieAddressLow, OFFSET flppyIOCB			MOV	Floppy80186Queue.queueNext.OpieAddressHandlerID, LOW BootStrapHandlerID			MOV	Floppy80186Queue.queueNext.OpieAddressType, IOPIORegionOpieAddress			POP	ES			ASSUME	ES:IOPELocalRAM; wake up handler and wait for return notify			%NotifyHandlerCondition	(FloppyHandlerID,OFFSET FloppyWorkNotify)			%WaitForCondition	(OFFSET floppyWorkspace.floppyIOCBDone,noTimeout); check for good completion			CMP	flppyIOCB.OperationState, OperationCompleted			JE	PutBackIfSeek; determine error type:;  (a) CRC error -- retry;  (b) wrong cylinder error -- recalibrate, check for seek, retry;  (c) other errors -- for now, same as (b)			DEC	bootRetryCount			JZ	TooManyRetries			CMP	flppyIOCB.ResultBytes+1, fdcStatusRegister1Type<,,1>			JE	EnqueueIOCB;			TEST	flppyIOCB.ResultBytes+2, fdcStatusRegister2Type<,,,1>;			JZ	ClassCError			MOV	flppyIOCB.RecalFlag, MesaTRUE			MOV	floppyWorkspace.currentCylinder, 0; if IOCB already has a seek, go enqueue it			CMP	flppyIOCB.NumberOfFDCCommands, 3			JE	EnqueueIOCB; restore CH and go check for seek			MOV	CH, flppyIOCB.fdcCommands.CommandBytes+2			JMP	CheckForSeek; good completion: if last IOCB included a seek, copy command record #3 back to #1PutBackIfSeek:		CMP	flppyIOCB.NumberOfFDCCommands, 1			JE	FloppyReadDone			%Copy	(flppyIOCB.fdcCommands,flppyIOCBplusTwoCmds.fdcCommands,SIZE(fdcCommandRecord))			MOV	flppyIOCB.NumberOfFDCCommands, 1FloppyReadDone:		RET	;if too many retries, hang with MP codeTooManyRetries:		MOV	AX, mpInitialError			CALL	DisplayMPCodeDone:			%Jam	(BootStrapHandlerID,OFFSET bootStrapTask)			%WaitForSystem		; never returns!FloppyRead		ENDP; IOCB.OperationIsQueued starts here			EVENinitialRec	DB	MesaTRUE		DB	OperationWaiting		OpieAddress	<0,0,nilOpieAddress>		OpieAddress	<?,0,IOPLogicalOpieAddress>		ClientCondition	<LOW BootStrapHandlerID,0,(OFFSET bootDeviceIORSpace.floppyIOCBDone+nonNilPtr),0>		DB	?		DB	MesaFALSE		DB	MesaFALSE		DB	MesaFALSE		DB	MesaFALSE		DB	MesaFALSE		DB	0		DB	?		DW	?		DW	?		DW	StartCounter		DW	?		DW	StartDMARead		DW	0		DW	5 DUP (?)		DB	MesaFALSE		DB	?		DW	1		DW	?		;fdcCommandRecord starts here		DB	ReadData,Read,?,MesaTRUE,9,?		;Command bytes for Read		DB	fdcReadDataCommand+(double SHL 6)	;cmd		DB	00H		;drive/head		DB	initialCodeCylinder	;cylinder		DB	00H			;head		DB	02H			;sector- we already read 1		DB	02H			;encodedSectorSize		DB	sectorsPerTrack360KB	;endOfTrackSector		DB	dataGapLength360KB	;gapLength		DB	0FFH			;datalength (I think is ignored)		DB	?			;unused		DB	7			;# of result bytessizeInitialRec		EQU	$-initialRec; IOCB data records for copyingseekRec			DB	Seek,None,?,MesaTRUE,3,?,fdcSeekCommandsizeSeekRec		EQU	$-seekRecsisRec			DB	SenseInterruptStatus,None,?,MesaFALSE,1,?,fdcSenseInterruptStatusCommandsizeSisRec		EQU	$-sisRec			ASSUME	ES:IOPELocalRAM;display mp code for executing initial microcodeRamFlpCont:		MOV	AX, mpRunInitial			CALL	DisplayMPCode; set up for one-sector reads from now on			MOV	flppyIOCB.firstTrack.TotalBytesToTransfer, sectorSize			MOV	flppyIOCB.firstTrack.FirstDMAtransferCount, sectorSize; step 1.5			PUSH	ES	;Save extra seg			%EstablishHandlerAccess(FloppyHandlerID)			ASSUME	ES:FloppyIOR			MOV	AX, FloppyDCB0.DeviceAttributes			CMP	AL, sa475DiskDrive	;Is 1.2 MB floppy drive?			JNE	Its360KBDriveIts1p2MBDrive:		MOV	endOfTrackSect, sectorsPerTrack1p2MB			;MOV	dataGapLen, dataGapLength1p2MB			JMP	SHORT DriveVarsOkIts360KBDrive:		MOV	endOfTrackSect, sectorsPerTrack360KB			;MOV	dataGapLen, dataGapLength360KB; step 2DriveVarsOk:		POP	ES			ASSUME	ES:IOPELocalRAM			MOV	SI, startOfBootBufferSpace			MOV	startOfBootBufferPool, SI			MOV	ES:[SI].nextBootBuffer, SI			MOV	ES:[SI].bootDataStart, Null			MOV	ES:[SI].bootDataEnd, Null			ADD	SI, bootDataBegins			MOV	flppyIOCB.DataAddress.OpieAddressLow, SI			MOV	CH, rootPageCylinder			MOV	flppyIOCB.fdcCommands.CommandBytes+2, CH			MOV	flppyIOCB.fdcCommands.CommandBytes+4, 1			MOV	bootRetryCount, 10			PUSH	SIReadRootPage:		CALL	FloppyRead			POP	SI			MOV	AX, SI			ADD	AX, sectorSize			;add sector size			MOV	startOfBootBufferSpace, AX	; and store for booting; step 3 (for now, skip UI and set up for diagnostic or Mesa boot)			CMP	bootType, normal			JE	SetUpMesaBoot; diagnostic boot: load one file from root file 0 for Daybreak, or root file 4 for Daisy SetUpDiagnosticBoot:	IN	AX, machineIDPort				AND	AX, machineIDMask				CMP	AX, Daisy					JNE	ContinueDaybreak			ADD	SI, OffsetToDaisyDiag	;ptr for daisy is after boot file			ContinueDaybreak:	MOV	CH, ES:[SI].DFIDcylinderLow			MOV	CL, ES:[SI].DFIDcountLow			MOV	DH, ES:[SI].DFIDhead			MOV	DL, ES:[SI].DFIDsector			MOV	floppyWorkspace.file1.CylCt, CX			MOV	floppyWorkspace.file1.HdSct, DX			MOV	floppyWorkspace.fileCount, 1						CMP	AX, Daisy		;check for pointer adjustment			JNE	LoadFiles			SUB	SI, OffsetToDaisyDiag	;Return pointer to original value			JMP	LoadFiles			; Mesa boot: load two files from root files 1 (uCode) and 2 (germ), store boot file addressSetUpMesaBoot:		ADD	SI, SIZE(DiskFileID)			MOV	CH, ES:[SI].DFIDcylinderLow			MOV	CL, ES:[SI].DFIDcountLow			MOV	DH, ES:[SI].DFIDhead			MOV	DL, ES:[SI].DFIDsector			MOV	floppyWorkspace.file1.CylCt, CX			MOV	floppyWorkspace.file1.HdSct, DX			ADD	SI, SIZE(DiskFileID)			MOV	CH, ES:[SI].DFIDcylinderLow			MOV	CL, ES:[SI].DFIDcountLow			MOV	DH, ES:[SI].DFIDhead			MOV	DL, ES:[SI].DFIDsector			MOV	floppyWorkspace.file2.CylCt, CX			MOV	floppyWorkspace.file2.HdSct, DX			MOV	floppyWorkspace.fileCount, 2			ADD	SI, SIZE(DiskFileID)			MOV	CX, WORD PTR ES:[SI].DFIDcylinderHigh			MOV	DX, WORD PTR ES:[SI].DFIDhead			MOV	floppyBootFileAddress, CX			MOV	floppyBootFileAddress+2, DX; step 4LoadFiles:		%Restart	(BootStrapHandlerID,OFFSET bootTask,BootTaskInit,OFFSET BootStack)			MOV	WORD PTR TooManyRetries+1, mpMesaDoveError			MOV	SI, OFFSET floppyWorkspace.file1; load one complete fileLoadLoop:		PUSH	SI			%WaitForCondition	(OFFSET getBootFile,noTimeout)			POP	SI			MOV	CX, [SI].CylCt			MOV	DX, [SI].HdSct			MOV	AH, DH			SHL	AH, 2			MOV	DI, startOfBootBufferPool; load one sector into bufferBufferEmpty:		LEA	BX, ES:[DI].bootData			MOV	flppyIOCB.DataAddress.OpieAddressLow, BX			MOV	flppyIOCB.ResetAndFlushFlag, MesaFALSE			MOV	flppyIOCB.fdcCommands.CommandBytes+1, AH			MOV	flppyIOCB.fdcCommands.CommandBytes+2, CH			MOV	flppyIOCB.fdcCommands.CommandBytes+3, DH			MOV	flppyIOCB.fdcCommands.CommandBytes+4, DL			MOV	bootRetryCount, 10			PUSHA; call FloppyReadDoRead:			CALL	FloppyRead; notify boot task that a buffer is readyNotifyBufferFull:	POP	DI			MOV	ES:[DI].bootDataStart, bootDataBegins			MOV	ES:[DI].bootDataEnd, bootDataBegins+sectorSize-1			PUSH	DI			%NotifyCondition	(OFFSET bootBufferFull)			POPA; decrement sector count			DEC	CL			JZ	DoneWithFile; increment sector address and loop			INC	DL			CMP	DL, endOfTrackSect			JLE	WaitForBuffer			MOV	DL, 1			XOR	DH, 01H			XOR	AH, 04H			JNZ	WaitForBuffer			INC	CH; wait till buffer becomes availableWaitForBuffer:		PUSHA			%WaitForCondition	(OFFSET bootBufferEmpty,noTimeout)			POPA			TEST	getBootFile.TCBLinkPtr, preNotifyFlag			JNZ	DoneWithFile			MOV	BX, ES:[DI].bootDataEnd			CMP	BX, ES:[DI].bootDataStart			JE	BufferEmpty			JMP	WaitForBuffer; done with file - decrement file countDoneWithFile:		DEC	floppyWorkspace.fileCount			JZ	DoneWithAllFiles			ADD	SI, SIZE (FileSpec)			JMP	LoadLoopDoneWithAllFiles:	%NotifyCondition	(OFFSET finishedLoaderFileFetch); step 5; idle till task is subsumed			JMP	DoneIOPEInRam		ENDS			END
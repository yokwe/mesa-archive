$ DEBUG MOD186$ PAGELENGTH (72)$ PAGEWIDTH (136);Copyright (C) 1984,1985 by Xerox Corporation. All rights reserved.;; PCDsptch.asm; Created by AGK,  2-Nov-84 10:22:59;; Last edited by:;;-- CWM		18-Feb-87  8:05:19	: Fixes to IN operations/IOCount IN var;-- CWM		25-Jan-87 20:14:09	: PCE Mapping support for Daisy machine	;-- CWM		25-Jan-87 20:14:08	: Reinstall new Keyboard DN mechanism;-- FHB		 9-Dec-86 17:23:20	: Moved ERD to main memory;-- CWM		13-Nov-86  9:53:02	: Put back NMI;-- FHB       	21-Oct-86 17:43:40	: Added Serial stuff;-- AGK		15-Oct-86 10:52:59	: Added mouse in main memory, moved keyboard into main memory and added down notify for mouse.;-- AGK		 9-Oct-86 12:12:24	: Added clock calling labels;-- AGK		 8-Oct-86 11:59:34	: Added RTClock support;-- AGK		28-Aug-86 16:54:30	: Deleted 80186 IO error, NMIBaseAddressOA, and DebuggerIO;-- CWM		16-Apr-86 22:58:37	: Eliminate excessive Byte/Word sets on IN;-- CWM		16-Apr-86 14:00:23	: Eliminate NMI swap.;-- AGK		25-Nov-85 16:15:23	: Renamed pceKeyboardDequeueAndSend to pceKeyboardSend;-- AGK		18-Nov-85 10:52:07	: Removed IN/OUT spec for I/O trapping;-- AGK		15-Nov-85 12:13:28	: Renamed LoadMagicByte to LoadMagic;-- AGK		14-Nov-85 12:24:59	: No NMI for OUT, keyboardOverflow;-- CWM		 3-Oct-85 11:20:21	: Extra Labels for debugging;-- AGK		 3-Oct-85 10:29:50	: Support for CopyIn > 15 chars;-- AGK		 5-Sep-85 11:52:14	: Added support for > 256 KB;-- AGK		29-Aug-85 17:38:41	: Changed LoadMagicByte to handle words;-- AGK		29-Aug-85 17:36:24	: Added ERD Support;-- AGK		22-Aug-85 17:11:17	: Replace call pFloppyIO By Notify pceFloppyWaitIO;-- JPM		13-Aug-85 16:47:28	: Separate PCE into different handlers.;-- JPM		12-Aug-85 12:12:36	: Change IOPEInRAM alignment to WORD.;-- AGK   	 9-Aug-85 16:01:04	: Some code compression;-- JPM   	 9-Aug-85 14:27:16	: Opie redesign conversion;-- AGK   	 2-Aug-85 15:54:36	: Added Printer down notification;-- AGK   	30-Jul-85 16:32:45	: Added Init/Exit for floppy;-- AGK   	22-Jul-85 11:35:11	: Added Printer Support;-- AGK   	17-Jul-85 17:18:42	: Added Init/Exit restructuring;-- AGK   	13-Jul-85 15:15:16	: Commented out debugger in IO trapper;-- AGK   	 9-Jul-85 12:45:33	: Restrutured AllowPCEmulation;-- AGK   	26-Jun-85 11:56:07	: Restrutured PCExxInit calls with RAMOpie;-- AGK   	25-Jun-85 12:53:34	: Upgraded 8255 emulation for B0 machines;-- AGK   	10-Jun-85 18:31:59	: Added DN for pceFloppyConditionWork;-- AGK   	10-Jun-85 18:03:19	: Restructured the Down Notify task;-- AGK   	10-Jun-85 14:56:54	: Added pceKeyboardReset;-- AGK   	20-May-85 15:34:51	: Removed PCEMacro.asm;-- AGK   	17-May-85  1:11:11	: Upgraded PCEMesaClientNotify and added PC debugger IO trap;-- AGK   	23-Apr-85 14:15:57	: Fixed pceMesaProcNotifyBits resetting;-- AGK   	22-Apr-85 22:34:18	: Added runPCE ¬ TRUE in Reset Down Notify;-- AGK   	22-Apr-85 13:18:48	: Moved initHBuff from pceFromPCTaskInit to Reset Down Notify;-- AGK   	17-Apr-85 17:20:37	: Added new down notify for Reset;-- AGK   	16-Apr-85 16:55:25	: Moved PCE bank one block lower in main memory;-- AGK   	15-Apr-85 16:55:22	: Renamed pseudoConfigSwitch's;-- AGK   	15-Apr-85 16:49:03	: Changed extendedBusAddresses in SetPCEMapping;-- AGK   	15-Apr-85 16:11:18	: Changed PCEDispatcherInit from FAR to NEAR;-- AGK   	11-Apr-85 11:02:35	: Set runPCE in Mesa side;-- AGK   	10-Apr-85 21:38:55	: Changed Opie Addresses in SetPCEMapping and removed InitPseudoConfigSW for Daybreak machine;-- AGK   	 4-Apr-85 13:16:26	: Replaced ResetPCE by Reset Opie Macro ;-- AGK   	 1-Apr-85 17:50:35	: Expanded main memory to 256 KB;-- AGK   	29-Mar-85 13:14:52	: Fixed address bug in NMIBaseAddressOA;-- AGK   	28-Mar-85 12:50:45	: Changed PseudoConfig for 128 KB and expanded PCE main memory to 128 KB in SetPCEMapping;-- HNH  	18-Mar-85 11:44:55	: Changed down notify implementation also included changes Mike MLT    made to PCDsptTw.asm;-- HNH  	14-Mar-85 23:54:03	: Changed the file name from PCDsptTw.asm to PCDsptch.asm;-- HNH  	12-Mar-85 14:59:26	: Added MonoDisplayController and ColorDisplayController procedure calls for the Dispaly routine;-- HNH  	11-Mar-85 16:56:33	: The following enhancements have been implemented as part of the Dispatcher since January 1985:;					:EstablishIOPAccess;					:Historybuffer;					:IO Error Handler;					:Non supported IO(LoadTriState);					:Pseudo Configuration Switch Init;-- AGK   	 6-Dec-84 14:37:10	: Included HardDefs.asm for Opie 16;-- AGK   	 2-Dec-84 16:13:25	: Added PCEMesaClientNotify procedure for KDP up notification support.;-- AGK   	24-Nov-84 15:59:19	: Added SetPseudoConfigSwitches skeletal procedure in PCEDispatcherInit;-- AGK   	23-Nov-84 16:08:41	: Added pceFromMesaTask tailored for Keyboard down notification only with polling mode;-- AGK   	21-Nov-84 18:28:45	: Added the three IO controllers emulation;-- AGK   	19-Nov-84 17:45:56	: NMI for IN and OUT support;-- AGK   	18-Nov-84 20:27:16	: Support for Parallel Printer;-- AGK   ,	12-Nov-84 12:50:22	: First skeletal version of the PCE Dispatcher to be run on etch 1 PCE Board;-- AGK   	2-Nov-84 10:22:59	: IO trappper only, no Down Notification, no IO controllers emulation.	NAME	PCDSPTCH;--------------------------------------------------------------------------------$NOLIST$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPDefs.asm)$INCLUDE	(PCEDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(OpieDefs.asm)$INCLUDE	(ROMEEP.asm)$LISTEXTRN	PCEDispatcherHandlerID: ABSEXTRN	PCEKeyboardHandlerID: ABSEXTRN	PCEMouseHandlerID: ABSEXTRN	PCEFloppyHandlerID: ABSEXTRN	PCEPrinterHandlerID: ABSEXTRN	PCEDiskHandlerID: ABSEXTRN	PCEClockHandlerID: ABSEXTRN	PCESerialHandlerID: ABSEXTRN	pcEmulatorInterrupt: ABS;--------------------------------------------------------------------------------PCEDispatcherIOR	SEGMENT	COMMON;; IORPDspt.asm externs;EXTRN	pceFromMesaTask: TaskContextBlockEXTRN	pceFromPCTask: TaskContextBlockEXTRN	pceUpNotifyBits: WORDEXTRN	pceLockMask: WORDEXTRN	pceClientCondition: ClientConditionEXTRN	ioTrappedData: WORDEXTRN	ioTrappedAddress: WORDEXTRN	ioTrappedStatus: BYTEEXTRN	p8255PortA: BYTEEXTRN	p8255PortB: BYTEEXTRN	pseudoConfigSwitch0: BYTEEXTRN	pseudoConfigSwitch1: BYTEEXTRN	pseudoConfigSwitch2: BYTEEXTRN	pNMIVectorBuffer: WORDEXTRN	panelValue: WORDEXTRN	runPCE: BYTEEXTRN	pcIOPTasksActive: BYTEEXTRN	keyboardOverflow: BYTEEXTRN	IOCount: BYTEEXTRN	FtlErr: BYTEEXTRN	conditionPCEWork: ConditionEXTRN	pceMesaWorkMask: WORDEXTRN	pceWorkingDNWord: WORDEXTRN	firstAddress: OpieAddressEXTRN	numberOfPCBlocks: BYTEEXTRN	pceClockBootLabel: SegmentAndOffsetEXTRN	pceClockExitLabel: SegmentAndOffsetEXTRN	pceMouseBootLabel: SegmentAndOffsetEXTRN	pceMouseExitLabel: SegmentAndOffsetEXTRN	pceKeyboardBootLabel: SegmentAndOffsetEXTRN	pceKeyboardExitLabel: SegmentAndOffsetEXTRN	pceKeyboardResetLabel: SegmentAndOffsetEXTRN	pceKeyboardSendLabel: SegmentAndOffsetEXTRN   pceDiskBootLabel:	SegmentAndOffsetEXTRN	pceDiskExitLabel:	SegmentAndOffset;PCEDispatcherIOR	ENDSPCEKeyboardIOR		SEGMENT	COMMON;; Keyboard externs;EXTRN	pceKeyboardConditionClear: ConditionEXTRN	pceKeyboardConditionWork: Condition;;PCEKeyboardIOR		ENDSPCEMouseIOR		SEGMENT	COMMON;; Mouse externs;EXTRN	pceMouseConditionWork: Condition;;PCEMouseIOR		ENDSPCEFloppyIOR		SEGMENT	COMMON;; Floppy externs;EXTRN	pceFloppyWaitIO: Condition;PCEFloppyIOR		ENDSPCEPrinterIOR		SEGMENT	COMMON;; Printer externs;EXTRN	pcePrinterIOCondition: Condition;PCEPrinterIOR		ENDSPCEClockIOR		SEGMENT	COMMON;; Clock externs;EXTRN	pceClockIOCondition: Condition;PCEClockIOR		ENDSPCESerialIOR		SEGMENT	COMMON;; Serial externs;EXTRN	pceSerialIOCondition: ConditionEXTRN	pSerialTxCondition: Condition, pSerialRxCondition: Condition;PCESerialIOR		ENDSPCEDiskIOR		SEGMENT	COMMON;; Disk externs;EXTRN	pceDiskWaitIO: Condition;PCEDiskIOR		ENDS;--------------------------------------------------------------------------------PCEDispatcherSTK	SEGMENT	COMMON;EXTRN	pceFromPCStack: WORDEXTRN	pceFromMesaStack: WORD;PCEDispatcherSTK	ENDS;--------------------------------------------------------------------------------PUBLIC	PCEDispatcherInit, LoadMagic, PCEMesaClientNotify, LoadTriState;PUBLIC	IOErrCtrl;--------------------------------------------------------------------------------IOPEInRAM	SEGMENT	WORD PUBLIC		ASSUME	CS: IOPEInRAM; IO trap variables exported by various PCE devices;EXTRN	pceKeyboardReset: NEAR;EXTRN	pceKeyboardSend: NEAREXTRN	MonoDisplayController: NEAREXTRN	ColorDisplayController: NEAREXTRN	DMAController: NEAREXTRN	DMAPages: NEAREXTRN	HBuffer: NEAREXTRN	initHBuff: NEAR; Boot procs exported by various PCE devicesEXTRN	pceDisplayBoot: NEAREXTRN	pceFloppyBoot: NEAR;EXTRN	pceKeyboardBoot: NEAR;EXTRN	pceMouseBoot: NEAREXTRN	pcePrinterBoot: NEAREXTRN	pceSerialBoot: NEAR;EXTRN	pceDiskBoot: NEAR; -- config procs exported by various pce devices;EXTRN	pceDisplayConfigure: NEAR;EXTRN	pceFloppyConfigure: NEAR;EXTRN	pceKeyboardConfigure: NEAR;EXTRN	pceMouseConfigure: NEAR;EXTRN	pcePrinterConfigure: NEAR;EXTRN	pceSerialConfigure: NEAR;EXTRN	pceDiskConfigure: NEAR; -- Exit procs exported by various pce devicesEXTRN	pceDisplayExit: NEAREXTRN	pceFloppyExit: NEAR;EXTRN	pceKeyboardExit: NEAR;EXTRN	pceMouseExit: NEAREXTRN	pceSerialExit: NEAREXTRN	pcePrinterExit: NEAR;EXTRN	pceDiskExit: NEAR;--------------------------------------------------------------------------------; Constants area in HandlerNMICorrectionRoutineOA	OpieAddress <0D000H,0FH,PCLogicalOpieAddress>NMIBaseAddressOA OpieAddress <0008H,00H,PCLogicalOpieAddress>;--------------------------------------------------------------------------------; The PCEDispatcherInit procedure is used to initialize the dispatcher.;  It is called from RAMHInit.asm.PCEDispatcherInit	PROC	FAR	; initialization	; Executes as a subroutine in the context of the caller.	%Disable	(pcEmulatorInterrupt)       			%InitializeTask (PCEDispatcherHandlerID,OFFSET pceFromPCTask, pceFromPCTaskInit,OFFSET pceFromPCStack)	%InitializeTask	(PCEDispatcherHandlerID,OFFSET pceFromMesaTask, pceFromMesaTaskInit,OFFSET pceFromMesaStack)	RET	PCEDispatcherInit	ENDP;--------------------------------------------------------------------------------; The PCE Down Notify Task is entered at pceFromMesaTaskInit.  It starts by; obtaining a lock mask for the PC Emulator and will then wait to be; down notified.  When this happens, it reads pceWorkingDNWord to determine which; proc(s) to call. (Note: individual device down-notifies have been moved out of; this task, since Opie now has enough work masks for everybody.)	ASSUME	DS:PCEDispatcherIORpceFromMesaTaskInit:; Get lock mask for PC Emulation	%GetLockMask 	MOV	pceLockMask, AX; Set up condition for down notifies	%GetWorkMaskForCondition (OFFSET conditionPCEWork)	MOV	pceMesaWorkMask, AX	pceDispatcherWait:	%WaitForCondition (OFFSET conditionPCEWork,noTimeout)	pceDispatcherDoWork:; Check bits in pceWorkingDNWord (value returned in AX).	%MesaLockedOut (XCHG, OFFSET pceWorkingDNWord, 0, pceLockMask)	; Prepare to scan the down notify bits	MOV	SI, OFFSET pDownNotifyTable	; Point to DN jump tablepDownNotifyScan:	TEST	AL, 0FFH	JZ	pceDispatcherWait	; If so, no more PCE down notification	SHL	AL, 1	JNC	pNoDownNotifyBit	PUSH	AX	CALL	WORD PTR CS:[SI]	POP	AXpNoDownNotifyBit:	ADD	SI, 2			; Point to next entry in jump table	JMP	pDownNotifyScan	; Jump table for PCE dispatcher down notificationpDownNotifyTable	LABEL	WORD	DW	BootNotifier	DW	ConfigureNotifier	DW	ExitNotifier	DW	MouseNotifier	DW	pSerialRxNotifier	DW	pSerialTxNotifier	DW	KeyboardNotifier	DW	pSpareNotifier	ASSUME	DS:NOTHING;--------------------------------------------------------------------------------; The PCE IO Trapper task is entered at pceFromPCTaskInit. It starts by disabling; the PCE map registers, disallowing PCE and resetting the PCE Board.; Then it sets itself to service the pcEmulator interrupt. At that point, the; pcEmulator interrupt is enabled and trapping actions can be performed.	ASSUME	DS:PCEDispatcherIORpceFromPCTaskInit:; Disable the PCE map registers	IN	AX, machineIDPort	AND	AX, machineIDMask	CMP	AX, Daisy	JE	ContInit		CALL	DisablePCEMappingContInit:; Reset the PCE186 processor while disallowing it from running; Let the Mesa world control running PCE	MOV	runPCE, 0	%Reset (resetPCProcessor); Set maintenance panel to ABD0 to indicate the start of PCE IO trapping	CALL	SetPanel	%RegisterPCEStartRoutine (AllowPCEmulation)	%ThisTaskServices (pcEmulatorInterrupt, pceBadInterrupt)	%Enable (pcEmulatorInterrupt)IOTrapperWaitForInterrupt:	%WaitForInterrupt (noTimeout)	CALL	IncrementPanel	; When an IO trap occurs this task will be awakened. It will save the trapped; address at ioTrappedAddress, the trapped status at ioTrappedStatus and the; trapped data at ioTrappedData, all three being in PCEDispatcher FCB. It checks; for an IN operation and if so, will perform NMI vector swapping and word or byte; IN specification. Then, it will perform a SELECT statement based on the trapped; address to vector to the proper PCE device.	; Get trapped address and store it in FCB	MOV	DX, pIOTrapperHi	IN	AL, DX	MOV	AH, AL	MOV	DX, pIOTrapperLo	IN	AL, DX	MOV	ioTrappedAddress, AX	; Get trapped status and store it in FCB	MOV	DX, pIOTrapperStat	IN	AL, DX	MOV	ioTrappedStatus, AL; Get trapped data and store it in FCB	MOV	DX, pIOTrapperDataHi	IN	AL, DX	MOV	AH, AL	MOV	DX, pIOTrapperDataLo	IN	AL, DX	TEST	ioTrappedAddress, pBit0		; Check for odd trapped address	JZ	StoreTrappedData	XCHG	AH, AL		; If so, swap bytes due to hardware trappingStoreTrappedData:	MOV	ioTrappedData, AX	;--------------------------------------------------------------------------------; Check for IN or OUT operation	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	OUTOperationINOperation:; Point to NMI entry in interrupt vector table; CWM do not do this since we do not want to save this NMI vector	%EstablishIOPAccess (generalMapRegister,NMIBaseAddressOA); Save original NMI vector locally	MOV	AX, ES:[DI]	MOV	pNMIVectorBuffer, AX	MOV	AX, ES:[DI+2]	MOV	pNMIVectorBuffer+2, AX; Load NMI correction vector in PCE186 interrupt vector table; CWM do not do this since the correct vector has already been stored by BIOS	MOV	AX, pNMICorrectOffset	MOV	ES:[DI], AX	MOV	AX, pNMICorrectSegment	MOV	ES:[DI+2], AX; Store original NMI vector in PC Logical Space for NMI Correction Routine access; CWM do this establish to point to location where to put Byte or Word info	%EstablishIOPAccess (generalMapRegister,NMICorrectionRoutineOA); CWM do not do this since the BIOS NMI routine will not restore the vector		MOV	AX, pNMIVectorBuffer	MOV	ES:[DI], AX	MOV	AX, pNMIVectorBuffer+2	MOV	ES:[DI+2], AX; Check for Byte or Word INWordByteInCheck:	MOV	AL, ioTrappedStatus	AND	AL, pIOCycleMask	CMP	AL, pIOTrapOddByte	; Check for odd byte	JE	pByteIN	CMP	AL, pIOTrapEvenByte	; Check for even byte	JE	pByteIN			; if not odd nor even byte then wordpWordIN:;	CMP	BYTE PTR pNMIVectorBuffer, 0FFh	; CWM Check word IN's been set	CMP	IOCount, 0FFh		; CWM Check word IN's been set	JE	VectorToPCEDevices	; CWM Yes, no need for action	MOV	AL, 0FFH		; CWM No, set byteOrWordINtestPointA:		JMP	SHORT pLoadByteOrWordINpByteIN:;	CMP	BYTE PTR pNMIVectorBuffer, 0h ; CWM Check if byte IN's been clear	CMP	IOCount, 0h ; CWM Check if byte IN's been clear	JE	VectorToPCEDevices	; CWM Yes, no need for action	XOR	AL, AL			; CWM No, Clear byteOrWordINpLoadByteOrWordIN:;	EstablishIOPAccess (generalMapRegister,NMICorrectionRoutineOA)continueLoad:	MOV	ES:[DI+6], AL;	MOV	BYTE PTR pNMIVectorBuffer, AL	; CWM Record for IOP's knowledge	MOV	IOCount, ALtestPointB:		JMP	SHORT VectorToPCEDevicesOUTOperation:;Call History Buffer just for OUT operation	CALL	HBufferVectorToPCEDevices:; Vector to proper PCE device	MOV	BX, ioTrappedAddress		; load BX with trapped address;	CMP	BX, 0FF00H;	JB	TrapperContinue;	JMP	IOError;TrapperContinue:	CMP	BX, 400H	JAE	ioNonIBM		MOV	SI, OFFSET xtIOAddressMap	; point to start of IOP map	ROR	BX, 4		; Get rid of low order 4 bits of IO address	MOV	CL, BL		; transport to CX for ADD	SHL	CL, 1		; double index since word address	XOR	CH, CH	ADD	SI, CX		; SI points to location containing address of trapped device routine	MOV	DX, CS:[SI]	; DX contains address of trapped device routine	JMP	DX	ioNonIBM:	JMP	IOTrapperWaitForInterrupt	;-----------------------------------------------------------------------DMA8237:	CALL	DMAController	JMP	IOTrapperWaitForInterrupt	;-----------------------------------------------------------------------; This portion of the Dispatcher handles the PIC 8259A emulation (Programmable; Interrupt Controller). An 8259 is present on the PCE Board. The emulation starts; by checking if an IN or an OUT instruction has been executed.; For IN, the dispatcher will perform the IN operation and get the data from the; controller. This data will be stored in magicByte.; For OUT, it will start by doing the actual OUT operation and it will store the; data of OUT in ioTrappedData. Then it will check if EOI has been issued and; the timer interrupt is re-enabled (even if it is not a timer interrupt).PIC8259:; Transform PCE186 IO trapped address to IOP186 IO address	MOV	DX, ioTrappedAddress	SUB	DX, ibmPC8259Addr0	SHL	DX, 1	ADD	DX, p8259Addr0; Check for IN/OUT	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	PIC8259OutPIC8259In:	IN	AL, DX	CALL	LoadMagic		; Store result in magicByte	JMP	SHORT End8259PIC8259Out:; Write trapped data to Corresponding p8259 OUT Port	MOV	AX, ioTrappedData		OUT	DX, AL		; Assuming byte OUT; Check OUT address	TEST	DX, pBit0	; Check if LSBit of address set	JNZ	End8259		; Not 20H case so terminate	Out20H:; Check for OCW2 and EOI by D3 = 0 and D4 = 0	TEST	AL, pBit3 + pBit4  	JNZ	End8259; OCW2 and EOI notificationOCW2:	CMP	AL, p8259EOI	JNE	End8259pEOIOccurence:; Enable timer interrupt hardware	MOV	DX, pEnableTimer	IN	AL, DXEnd8259:	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------; This portion of the Dispatcher handles the PIT 8253-5 emulation (Programmable ; Interval Timer). An 8254 is present on the PCE Board. The emulation starts by; checking if an IN or OUT instruction has been executed.; For IN, the dispatcher will perform the IN operation and get the data from the; controller. This data will be stored in magicByte.; For OUT, the dispatcher will perform the actual OUT operation.PIT8253:; Transform PCE186 IO trapped address to IOP186 IO address	MOV	DX, ioTrappedAddress	SUB	DX, ibmPC8253Count0	SHL	DX, 1	ADD	DX, p8254Count0; Check for IN/OUT	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	PIT8253OutPIT8253In:	IN	AL, DX	CALL	LoadMagic		; Store result in magicByte	JMP	SHORT End8253PIT8253Out:; Write trapped data to Corresponding p8254 OUT Port	MOV	AX, ioTrappedData	OUT	DX, ALEnd8253:	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------; This portion of the Dispatcher handles the PPI 8255 emulation (Programmable; Peripheral Interface). The PCE Board does not contain any 8255 chip. Instead,; two latches will store bits 0 and 1 of Port B that correspond to the timer 2; gate and speaker data respectively. The hardware ports are now present in; the dipstacher FCB. The emulation will check for IN or OUT.; If OUT, the trapped data is stored in proper FCB port. If trappedAddress = 07FH;   then keyboard overflow, hence set keyboardOverflow flag.; If IN, the trapped data is sent back thru LoadMagic.; Special cases:; IN from Port A (keyboard input port): call pceKeyboardSend.; OUT to Port B:;  If Bit 6 is zero call pceKeyboardReset;  If Bit 7 has a high to low transition, notify pceKeyboardConditionClear;  OUT data to speaker IO hardware latches.;PPI8255:	MOV	DI, ioTrappedAddress	SUB	DI, ibmPC8255PortA	ADD	DI, OFFSET p8255PortA	; DX points to software ports in IORPDspt; Check for IN/OUT	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	PPI8255OutPPI8255In:; Check IN at 60H for keyboard scan code input	CMP	ioTrappedAddress, ibmPC8255PortA	JNE	PPI8255InNormal; Let PCE keyboard handler load magicByte	CALL	DWORD PTR pceKeyboardSendLabel	JMP	SHORT End8255PPI8255InNormal:	MOV	AL, [DI]	CALL	LoadMagic		; Store result in magicByte	JMP	SHORT End8255PPI8255Out:; Check for Port B	CMP	ioTrappedAddress, ibmPC8255PortB	JE	p8255PortBCase pOutTo8255:; Check proper range	CMP	ioTrappedAddress, ibmPC8255Control	JBE	p8255OutWritecheckForBIOSKBOvflo:	CMP	ioTrappedAddress, 07FH	; Special address for keyboard overflow	JNE	noKeyboardOverflowflagBIOSKBOvflo:		MOV	keyboardOverflow, 0FFH	; Set overflow flag for keyboard handlernoKeyboardOverflow:	JMP	SHORT End8255p8255OutWrite:; Write trapped data to Corresponding p8255 OUT Port	MOV	AX, ioTrappedData	MOV	[DI], AL	JMP	SHORT End8255	; Port B is left (trapped address must be 61H)p8255PortBCase:; Check if PB6 is low for keyboard reset	TEST	ioTrappedData, pBit6	JNZ	p8255PortBContinue	CALL	DWORD PTR pceKeyboardResetLabel	; If so, call the keyboard emulatorp8255PortBContinue:; Check for high to low transition on PB7; Get initial content of Port B for state transition checking	TEST	p8255PortB, pBit7	JZ	pOutTo8255PortB	; If so, original state of PB7 is low	TEST	ioTrappedData, pBit7	JNZ	pOutTo8255PortB	; If so, PB7 is still high				; Otherwise high to low transition	%NotifyHandlerCondition	(PCEKeyboardHandlerID,OFFSET pceKeyboardConditionClear)	pOutTo8255PortB:; OUT trapped data to speaker latches	MOV	DX, p8255PortBAddr	MOV	AX, ioTrappedData	OUT	DX, AL		; Assuming byte OUT	MOV	p8255PortB, AL	;JMP	SHORT End8255End8255:	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------DMAPageRegs:	CALL	DMAPages	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------NMIMaskReg:	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------;DebuggerIO:;	CMP	ioTrappedAddress, 100H;	JNE	NotPCDebuggerIO;	INT	3		; Call BreakIntrHandler;NotPCDebuggerIO:;	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------PseudoConfigSwitches:	CALL	SelectSwitch	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------AsyncCom2:	CMP	ioTrappedAddress, 2F8H	JB	AsyncCom2Reserved	%NotifyHandlerCondition	(PCESerialHandlerID,OFFSET pceSerialIOCondition)	JMP	IOTrapperWaitForInterruptAsyncCom2Reserved:	JMP	NonSupportedIO;------------------------------------------------------------------------FixedDisk:	%NotifyHandlerCondition	(PCEDiskHandlerID,OFFSET pceDiskWaitIO)	JMP	IOTrapperWaitForInterrupt	;------------------------------------------------------------------------ParallelPrinter:	MOV	BX, ioTrappedAddress	AND	BX, 000FH	; To make code valid for 27X and 37X IO addresses	CMP	BX, 08H	JB	pPrinterUnsupported	CMP	BX, 0AH	JBE	pPrinterSupportedpPrinterUnsupported:	JMP	NonSupportedIOpPrinterSupported:	%NotifyHandlerCondition	(PCEPrinterHandlerID,OFFSET pcePrinterIOCondition)	JMP	IOTrapperWaitForInterrupt	;------------------------------------------------------------------------RTClock:	%NotifyHandlerCondition	(PCEClockHandlerID,OFFSET pceClockIOCondition)	JMP	IOTrapperWaitForInterrupt	;------------------------------------------------------------------------SDLCCom:	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------MonoDisplayAndPrinter:	MOV	BX,ioTrappedAddress		CMP	BX, 3BCH	JB	pDisplayIO	CMP	BX, 3BEH	JBE	pPrinterIO	pDisplayIO:	PUSH	DS	CALL	MonoDisplayController	POP	DS	JMP	IOTrapperWaitForInterrupt		pPrinterIO:	%NotifyHandlerCondition	(PCEPrinterHandlerID,OFFSET pcePrinterIOCondition)	JMP	IOTrapperWaitForInterrupt	;------------------------------------------------------------------------ColorGraphicsDisplay:	PUSH	DS	CALL	ColorDisplayController	POP	DS	JMP	IOTrapperWaitForInterrupt	;------------------------------------------------------------------------FloppyAsyncCom1:	CMP	ioTrappedAddress, 03F8H	JAE	AsyncCom1	%NotifyHandlerCondition	(PCEFloppyHandlerID,OFFSET pceFloppyWaitIO)	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------AsyncCom1:	%NotifyHandlerCondition	(PCESerialHandlerID,OFFSET pceSerialIOCondition)	JMP	IOTrapperWaitForInterrupt	;------------------------------------------------------------------------NonSupportedIO:	;Check for IN/OUT operation	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	OUTOpration	INOpration:	CALL	LoadTriState	OUTOpration:	JMP	IOTrapperWaitForInterrupt	; Just skip IO trapping;------------------------------------------------------------------------; Dispatching table for IO trapped addressesxtIOAddressMap	LABEL	WORD		DW	DMA8237		DW	NonSupportedIO		DW	PIC8259		; 20H - 21H Used		DW	PIC8259		; 20H - 3FH Decoded 		DW	PIT8253		; 40H - 43H Used		DW	PIT8253		; 40H - 5FH Decoded		DW	PPI8255		; 60H - 63H Used		DW	PPI8255		; 60H - 7FH Decoded		DW	DMAPageRegs		DW	NonSupportedIO		DW	NMIMaskReg		DW	5 DUP(NonSupportedIO)	;----------------------------------------	;	DW	DebuggerIO		; 100H - 10FH		DW	15 DUP(NonSupportedIO)	; 100H - 1EFH		DW	PseudoConfigSwitches	; 1F0H - 1F2H	;----------------------------------------		DW	7 DUP(NonSupportedIO)	; 200H - 26FH		DW	ParallelPrinter		; 278H -27AH Parallel Printer		DW	4 DUP(NonSupportedIO)	; 280H -2BFH		DW	RTClock			; 2C0H -2CFH Real Time Clock		DW	2 DUP(NonSupportedIO)	; 2D0H -2EFH		DW	AsyncCom2	; 2F0H - 2F7H Reserved, 2F8H -2FFH Async2	;----------------------------------------		DW	2 DUP(NonSupportedIO)		DW	FixedDisk		DW	4 DUP(NonSupportedIO)		DW	ParallelPrinter		; 378H - 37FH Parallel Printer		DW	SDLCCom		DW	2 DUP(NonSupportedIO)		DW	MonoDisplayAndPrinter		DW	NonSupportedIO		DW	ColorGraphicsDisplay		DW	NonSupportedIO		DW	FloppyAsyncCom1	; 3F0H - 3F7H Floppy, 3F8H - 3FFH Async1		;--------------------------------------------------------------------------------; Vector to proper IO error handling device;IOError:;	SUB	BX, 0FF00H	;	MOV	SI, OFFSET p80186IOControl ; point to start of internal Control Register map;	ROR	BX, 4		; Get rid of low order 4 bits of IO address;	MOV	CL, BL		; transport to CX for ADD;	SHL	CL, 1		; double index since word address;	XOR	CH, CH;	ADD	SI, CX		; SI points to location containing address of trapped device routine;	MOV	DX, CS:[SI]	; DX contains address of trapped device routine;	JMP	DX	;IntControlRegs:;	CALL	IOErrCtrl;	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------;TimerControlRegs:;	CALL	IOErrCtrl;	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------;ChipSelectControlRegs:;	MOV	BX, ioTrappedAddress;	CMP	BX, 0FFA6H	;(0FFA0-0FFA5 un-used);	JB	ioOK;	CMP	BX, 0FFA9H	;(0FFA9-0FFAF un-used);	JAE	ioOK;	CALL	IOErrCtrl;ioOK:;	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------;DMADescriptorsChn0:	;	MOV	BX, ioTrappedAddress;	CMP	BX, 0FFCBH	;(0FFCB-0FFCF un-used);	JAE	ioOK1;	CALL	IOErrCtrl;ioOK1:;	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------;DMADescriptorsChn1:	;	MOV	BX, ioTrappedAddress;	CMP	BX, 0FFDBH	;(0FFDB-0FFDF un-used);	JAE	ioOK2;	CALL	IOErrCtrl;ioOK2:;	JMP	IOTrapperWaitForInterrupt	;------------------------------------------------------------------------;RelocationRegs:	;	MOV	BX, ioTrappedAddress;	CMP	BX, 0FFFEH	;(0FFF0-0FFDD un-used);	JB	ioOK3;	CALL	IOErrCtrl;ioOK3:	;	JMP	IOTrapperWaitForInterrupt	;------------------------------------------------------------------------;Gap:;	JMP	IOTrapperWaitForInterrupt;------------------------------------------------------------------------; Dispatching table for IO error handling addresses;p80186IOControl	LABEL	WORD;		DW	Gap 		       ; 00H - 0FH ;		DW	Gap		       ; 10H - 1FH;		DW	IntControlRegs	       ; 20H - 2FH ;		DW	IntControlRegs         ; 30H - 3FH  ;		DW	Gap		       ; 40H - 4FH;		DW	TimerControlRegs       ; 50H - 5FH ;		DW	TimerControlRegs       ; 60H - 6FH ;		DW	Gap		       ; 70H - 7FH ;		DW	Gap		       ; 80H - 8FH;		DW	Gap		       ; 90H - 9FH;		DW	ChipSelectControlRegs  ; A0H - AFH;		DW	Gap		       ; B0H - BFH;		DW	DMADescriptorsChn0     ; C0H - CFH;		DW	DMADescriptorsChn1     ; D0H - DFH;		DW	Gap		       ; E0H - EFH;		DW	RelocationRegs         ; F0H - FFH;;		ASSUME	DS:NOTHING;--------------------------------------------------------------------------------	ASSUME	DS:PCEDispatcherIOR	;These procs called locally;--------------------------------------------------------------------------------; SetPanel; SetPanel loads the four Maintenance Panel LEDs to ABD0SetPanel	PROC	MOV	AX,0ABD0H	;Start the display at 0ABD0H			MOV	panelValue, AX	OUT	WriteLED, AX	RET	SetPanel	ENDP;--------------------------------------------------------------------------------; IncrementPanel; IncrementPanel gives a visual check that our software is still running.IncrementPanel	PROC	INC	panelValue	MOV	AX, panelValue	OUT	WriteLED, AX	RET	IncrementPanel	ENDP;--------------------------------------------------------------------------------; DisablePCEMapping; Write 0FFH in all PCE map registersDisablePCEMapping	PROC	NEAR		MOV	CX, 8		; CX ¬ number of PCE map registers	MOV	DX, 0E010H	; DX ¬ IO address of first PCE map register	MOV	AL, 0FFHDisablePCEMappingLoop:	OUT	DX, AL	INC	DX	LOOP	DisablePCEMappingLoop	RET		DisablePCEMapping	ENDP;--------------------------------------------------------------------------------; SetPCEMapping; ; numberOfPCBlocks ¬ SW2(AllRAM)/2;; Check from EEPROM if MEB present; Case 1 - No MEB:;   firstAddress ¬ 120000H;; Case 2 - MEB:;   firstAddress ¬ 100000H + (ReadEEPROM)*40000H -0C0000H;;       -- ReadEEPROM = # additional 256 KB blocks; sufiBlockMap ¬ firstAddress;; firstAddress ¬ firstAddress + 20000H;; numberOfUnmappedPCBlocks ¬ numberOfPCBlocks;; pcMapIndex ¬ 0;; WHILE numberOfUnmappedPCBlocks > 0 DO;  {;  (E010 + pcMapIndex) ¬ firstAddress;;  pcMapIndex ¬ pcMapIndex + 1;;  firstAddress ¬ firstAddress + 20000H;;  numberOfUnmappedPCBlocks ¬ numberOfUnmappedPCBlocks - 1;;  }SetPCEMapping	PROCSetPCEMappingLb:	;	CALL	DisablePCEMapping	; Start by resetting the map registers; Read the size of PC main memory from configuration switch 2	MOV	AL, pseudoConfigSwitch2	AND	AL, 0FH		; pc64KChunks ¬ SW2(AllRAM)	SHR	AL, 1		; numberOfPCBlocks ¬ pc64KChunks/2	MOV	numberOfPCBlocks, AL		MOV	firstAddress.OpieAddressType, extendedBusOpieAddress	MOV	firstAddress.OpieAddressA15toA0, 0000H	IN	AX, machineIDPort	AND	AX, machineIDMask	CMP	AX, Daisy	JNE	ProgramPCEMapDaybreakProgramPCEMapDaisy:	MOV	firstAddress.OpieAddressA23toA16, 14H	JMP	SHORT ProgramPCEMapRegistersProgramPCEMapDaybreak:	CALL	DisablePCEMapping	; Check from EEPROM if MEB present	%ReadEEProm(eePromHighMem,1)	; AL now contains # of 256 KB blocks	CMP	AL, 2	JA	pMEBPresent	MOV	firstAddress.OpieAddressA23toA16, 12H	JMP	ProgramPCEMapRegisterspMEBPresent:	SHL	AL, 2	ADD	AL, 4	MOV	firstAddress.OpieAddressA23toA16, AL	ProgramPCEMapRegisters:; Program the Sufi Block map registers	%EstablishIOPAccess	(daybreakMapRegisterNumberBase + 5,firstAddress)	%EstablishIOPAccess	(daybreakMapRegisterNumberBase + 6,firstAddress)	%EstablishIOPAccess	(daybreakMapRegisterNumberBase + 7,firstAddress); Program any remaining map register within E010 to E014	ADD	firstAddress.OpieAddressA23toA16, 2	MOV	CL, numberOfPCBlocks	MOV	CH, 0	MOV	AX, 0ProgramPCEMapRegistersLoop:	PUSH	AX	PUSH	CX	%EstablishIOPAccess	(AX,firstAddress)	POP	CX	POP	AX	INC	AX	ADD	firstAddress.OpieAddressA23toA16, 2	LOOP	ProgramPCEMapRegistersLoop	RET		SetPCEMapping	ENDP;--------------------------------------------------------------------------------; SelectSwitchSelectSwitch	    PROC	NEAR		MOV	AX,ioTrappedAddress	CMP 	AX, switch0	JZ	pseudoConfigSw0			CMP 	AX, switch1	JZ	pseudoConfigSw1			MOV	AL, pseudoConfigSwitch2      	JMP	SHORT SwSelected		pseudoConfigSw0:	MOV	AL, pseudoConfigSwitch0	JMP	SHORT SwSelected		pseudoConfigSw1:	MOV	AL,pseudoConfigSwitch1	SwSelected:	CALL	LoadMagic		RET				SelectSwitch	ENDP;--------------------------------------------------------------------------------; BootNotifierBootNotifier	PROC	NEAR	CALL	initHBuff	MOV	keyboardOverflow, 0	; Initialize keyboard for no overflow	PUSH	DS	CALL	pceDisplayBoot	CALL	pceFloppyBoot	CALL	DWORD PTR pceKeyboardBootLabel	CALL	DWORD PTR pceMouseBootLabel	CALL	DWORD PTR pceClockBootLabel;	CALL	pcePrinterBoot	CALL	pceSerialBoot	CALL	DWORD PTR pceDiskBootLabel	POP	DS	%Reset	(resetPCProcessor); Set maintenance panel to ABD0 to indicate the start of PCE IO trapping	CALL	SetPanel	MOV	runPCE, 0FFH	MOV	pcIOPTasksActive, 0FFH	; Indicate to Agent that PCE tasks active	RET	BootNotifier	ENDP;--------------------------------------------------------------------------------; ConfigureNotifierConfigureNotifier	PROC	NEAR; 	CALL	SetPCEMapping;	PUSH	DS;	CALL	pceDisplayConfigure;	CALL	pceFloppyConfigure;	CALL	pceKeyboardConfigure;	CALL	pceMouseConfigure;	CALL	pcePrinterConfigure;	CALL	pceSerialConfigure;	CALL	pceDiskConfigure;	POP	DS	RET	ConfigureNotifier	ENDP;--------------------------------------------------------------------------------; ExitNotifierExitNotifier	PROC	NEAR	MOV	runPCE, 0H	PUSH	DS	CALL	pceDisplayExit	CALL	pceFloppyExit	CALL	DWORD PTR pceKeyboardExitLabel	CALL	DWORD PTR pceMouseExitLabel	CALL	DWORD PTR pceClockExitLabel;	CALL	pcePrinterExit	CALL	pceSerialExit	CALL	DWORD PTR pceDiskExitLabel	POP	DS	MOV	pcIOPTasksActive, 0	; Indicate to Agent that PCE tasks are inactive	RET	ExitNotifier	ENDP;--------------------------------------------------------------------------------; pSerialRxNotifierpSerialRxNotifier	PROC	NEARpReceiveNotifier:	%NotifyHandlerCondition(PCESerialHandlerID,OFFSET pSerialRxCondition)	RET	pSerialRxNotifier	ENDP;--------------------------------------------------------------------------------;--------------------------------------------------------------------------------; pSerialTxNotifierpSerialTxNotifier	PROC	NEARpTransmitNotifier:	%NotifyHandlerCondition(PCESerialHandlerID,OFFSET pSerialTxCondition)	RET	pSerialTxNotifier	ENDP;--------------------------------------------------------------------------------;--------------------------------------------------------------------------------; MouseNotifierMouseNotifier	PROC	NEAR	%NotifyHandlerCondition	(PCEMouseHandlerID,OFFSET pceMouseConditionWork)	RETMouseNotifier	ENDP;--------------------------------------------------------------------------------;KeyboardNotifierKeyboardNotifier	PROC	NEAR	%NotifyHandlerCondition	(PCEKeyboardHandlerID,OFFSET pceKeyboardConditionWork)	RETKeyboardNotifier	ENDP;--------------------------------------------------------------------------------;--------------------------------------------------------------------------------;pSpareNotifierpSpareNotifier	PROC	NEAR	RETpSpareNotifier	ENDP;--------------------------------------------------------------------------------	ASSUME	DS:NOTHING;-------------------------------------------------------------------------------;pceBadInterruptpceBadInterrupt	PROC	FAR	; Set error status first	%Jam	(PCEDispatcherHandlerID,OFFSET pceFromPCTask)	%Jam	(PCEDispatcherHandlerID,OFFSET pceFromMesaTask)	RET	pceBadInterrupt	ENDP	;--------------------------------------------------------------------------------; AllowPCEmulation will be called thru the RegisterPCEStartRoutine Macro. It ; returns the value of runPCE in AL.AllowPCEmulation:	PUSH	ES	%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIOR	MOV	AL, runPCE	POP	ES	IRET	ASSUME	ES:NOTHING;--------------------------------------------------------------------------------; Load Magic; Input byte/word in AL/AXLoadMagic	PROC	PUSH	DI	PUSH	ES	PUSH	AX		; Save input		%EstablishIOPAccess (generalMapRegister,NMICorrectionRoutineOA)	POP	AX		; Recover inputMagicByte:	MOV	ES:[DI+4], AX	; Call History Buffer for IN operation	CALL	HBuffer		POP	ES	POP	DI		RETLoadMagic	ENDP;--------------------------------------------------------------------------------; Load Tri State; Input word in AX; Store result in magicByteLoadTriState	PROC	PUSH	DI	PUSH	ES	PUSH	AX				%EstablishIOPAccess (generalMapRegister,NMICorrectionRoutineOA)	MOV	AX, 0FFFFH	; Load magic word with tri state value if reading				; non-existing IOMagicWord:	MOV	ES:[DI+4], AX	; Call History Buffer for IN operation	CALL	HBuffer		POP	AX	POP	ES	POP	DI		RETLoadTriState	ENDP;-------------------------------------------------------------------------------; PCEMesaClientNotifyPCEMesaClientNotify	PROC	PUSH	DS	PUSH	ES	PUSH	AX	%EstablishHandlerAccess	(PCEDispatcherHandlerID)	MOV	AX, ES	MOV	DS, AX	ASSUME	DS:PCEDispatcherIOR	POP	AX	POP	ES	%MesaLockedOut (OR,OFFSET pceUpNotifyBits,AX,pceLockMask)	%NotifyClientCondition	(pceClientCondition)	POP	DS	ASSUME	DS:NOTHING	RETPCEMesaClientNotify	ENDP;---------------------------------------------------------------------------------; IO Error Control; Input byte in AL;IOErrCtrl	PROC	NEAR;	PUSH 	AX;	PUSH	ES;	EstablishHandlerAccess	(PCEDispatcherHandlerID);	ASSUME	ES:PCEDispatcherIOR	;	MOV	FtlErr, 00H	; Check for IN/OUT operation;	TEST	ioTrappedStatus, pIOTrapInOutBit;	JZ	OUTOpratn;INOpratn:;	CALL	HBuffer	;OUTOpratn:;	MOV	AL, IOCount;	CMP	AL, 03H;	JAE	FlagErr;	INC	IOCount;	JMP	SHORT EXIT;FlagErr:;	MOV	AL, 01H;	MOV	FtlErr, AL;	CALL	HBuffer;	MOV	FtlErr, 00H;EXIT:;	POP 	AX;	POP	ES;	ASSUME	ES:NOTHING;	RET;IOErrCtrl	ENDP;--------------------------------------------------------------------------------IOPEInRAM	ENDS		;********************************************************************************		END
$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);KeyMo.asm      1-May-84 13:46:28;Copyright (C) 1984 by Xerox Corporation. All rights reserved.;--stored as     KeyMo.asm;--created on     1-May-84 13:47:15;;--created by AxR    ;--last edited by:;--    JPM           22-Jul-85 10:28:27	;Change IOPEInROM alignment to WORD.;--    JPM            8-Jul-85 17:13:15	;Fixed bug in KeyBoardAndMouseInit (forgot to use OFFSET for initial stack ptr).;--    JPM           25-Jun-85 15:58:58	;Opie redesign conversion.;--    AxR            2-May-85 15:28:55	;Cleaned-up and streamed-lined error handling code					;added drop to System priority and Reset Macro use.;--    JMM           19-Apr-85 17:56:31	;Replaced erroneous calls to ErrorCondition.;--    AxR           27-Mar-85 11:00:24	;Changed to use new WaitForInterrupt					;and redid the error reinitialization code;;	NAME	KeyMo$NOLIST$INCLUDE	(IOPDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(HardDefs.asm);;--------------------------------------------------------------------------------;Include files needed for KeyMo handler only$INCLUDE	(KyMoDefs.asm)$LISTEXTRN			keyBoard@MouseInterrupt: ABSEXTRN			KeyBoardAndMouseHandlerID: ABSKeyboardAndMouseIOR	SEGMENT		COMMON			Assume DS:KeyboardAndMouseIOR				EXTRN			KeyboardAndMouseTask: TaskContextBlockEXTRN			HexValue: BYTEEXTRN			ConvertKeyCodeToBit: BYTEEXTRN			FrameErrorCnt: WORDEXTRN			OverRunErrorCnt: WORDEXTRN			ParityErrorCnt: WORDEXTRN			SpuriousIntCnt: WORDEXTRN			WatchDogCnt: WORDEXTRN			BadInterruptCnt: WORDEXTRN			MouseX: BYTEEXTRN			MouseY: BYTEEXTRN			KBbase: BYTEEXTRN			KBIndex: BYTEKeyboardAndMouseIOR	ENDS	KeyboardAndMouseSTK	SEGMENT		COMMON			Assume SS:KeyboardAndMouseSTKEXTRN			KeyMoStack: WORDKeyboardAndMouseSTK	ENDS	IOPEInROM        	SEGMENT WORD PUBLIC	;ROM			Assume	CS:IOPEInROMPUBLIC			KeyBoardAndMouseInit	KeyBoardAndMouseTaskInit:			TEST	ConvertKeyCodeToBit, TRUE			JZ	SetMouseXY			MOV	CX, 18		;The keyboard array (18 Bytes) must be			MOV	BX, 0		;initialized to all keys up (bits = 1)	SetKb:		MOV	DS: KBbase [BX], 0FFH			INC	BX			LOOP	SetKb	SetMouseXY:	XOR	AX, AX			MOV	CX, 4			;The mouse location both X and Y,			MOV	BX, 0			;must be set to zero.	ZeroOut1:	MOV	DS: MouseX [BX], AL			INC	BX			LOOP	ZeroOut1			MOV	CX, 6			;The error count locations must all			MOV	BX, 0			;be set to zero.	ZeroOut2:	MOV	DS: FrameErrorCnt [BX], AX			INC	BX			LOOP	ZeroOut2			MOV	DS: HexValue, AL	;The Keyboard hex value set zero				%ThisTaskServices (keyBoard@MouseInterrupt,kbMouseBadInterrupt)	;					Call   init8254			;	      			Call   init8251A		;The 8251A must be initialized and started at 									;this point. The Baudrate factor, character							;length, number of stop bits, asynchronous							;mode, off parity, etc. must be set.								ErrorReturn:	%DisableInterruptsTillNextWait		 	%Enable (keyBoard@MouseInterrupt)	MoreWork:	%WaitForInterrupt (1)			JC	watchDogTimeoutInterrupt			IN	AL, KeyBdUartStatus			TEST	AL, FrameError+OvRunError+ParError			JNZ	ErrorCondition			TEST	AL, RxReady			JNZ	Continue1			INC	DS: SpuriousIntCnt	;increment the count			JMP	MoreWork				Continue1:	IN	AL, KeyBdUartData	;Initial test is to determine if we have			CMP	AL, 0FFH		;a keyboard character or a 0FFH mouse			JE	MouseCode		;movement value. If mouse movement than							;branch to MouseCode							;IORegion address of keyboard bits			MOV	DS: HexValue, AL	;Store the raw Hex value from the keyboard for							;booting code, because the Mesa World doesn't exist.			TEST	ConvertKeyCodeToBit, TRUE ;Convert code?			JZ	MoreWork		;No, go wait for next			XOR	AH, AH			XOR	BH, BH			TEST	AL, 080H		;If the keyboard key stroke UpDown bit			JNZ	UP			;indicates a key UP condition than							;branch to Up:			MOV	SI, AX			;Save for later			OR	AL, 080H		;Use the key position code to index into the							;KBMask array to get the mask for the bit			MOV	DI, AX			MOV	CL, DS: KBIndex [DI]	;that needs to be altered.							;Use the key position code to index into the			MOV	BL, DS: KBIndex [SI] 	;KBIndex array to get the offset of the byte							;in the IO Region that needs to be altered.			XOR	CL, 0FFH		;Complement the mask			AND	DS: KBbase[BX], CL	;AND it to memory.	      			JMP	MoreWork		;Go wait for next interrupt 	Up:		CMP	AL, 0EDH		;Special condition. Is this a LOCK KEY up and							;ON, therefore no action is necessary			JE	MoreWork		;Go wait for next interrupt			MOV	DI, AX			;Save for later						AND	AL, 07FH		;Use the key position code to index into the			MOV	SI, AX			MOV	CL, DS: KBIndex [DI]	;KBIndex array to get the offset of the byte							;in the IO Region that needs to be altered.							;Use the key position code to index into the							;KBMask array to get the mask for the bit			MOV	BL, DS: KBIndex [SI]	;that needs to be altered.			OR	DS: KBbase[BX], CL		;OR the mask into memory.	      	      			JMP	MoreWork		;Go wait for next interrupt		watchDogTimeoutInterrupt:			INC	DS: WatchDogCnt		;increment the count	      			JMP    EndError			;Go wait for next interrupt							ErrorCondition:	TEST	AL, FrameError			JZ	ErrorCnd1			INC	DS: FrameErrorCnt	;and increment the count	ErrorCnd1:	TEST	AL, OvRunError			JZ	ErrorCnd2			INC	DS: OverRunErrorCnt	;and increment the count	ErrorCnd2:	TEST	AL, ParError			JZ	EndError				INC	DS: ParityErrorCnt	;and increment the count				EndError:	%Disable (keyBoard@MouseInterrupt)			%WaitForSystem						CALL	init8251A			JMP    ErrorReturn			;Go wait for next interrupt	MouseCode:	%WaitForInterrupt (1)		;Waiting for the X movement value			JC	watchDogTimeoutInterrupt			IN	AL, KeyBdUartStatus			TEST	AL, FrameError+OvRunError+ParError			JNZ	ErrorCondition						TEST	AL, RxReady			JNZ	Continue2		;			INC	DS: SpuriousIntCnt	;and increment the count			JMP	MouseCode		;	Continue2:	IN	AL, KeyBdUartData	;Get the X movement value			TEST	AL, 080H		;Test the positive/negative bit and			JNZ	NegX			;branch if negative to NegX;	      			XOR	AH, AH			;Use the magnitude value						CLI			ADD	DS: MouseX+1, AL	;and add to memory			ADC	DS: MouseX, AH		;The bytes are reversed for MESA			STI				JMP    YCoor			;Go wait for Y interrupt							;Use the magnitude value and	NegX:		MOV	CX, 0FF80H		;convert it to a two's complement			SUB	CL, AL			;negative number	      			CLI			ADD	DS: MouseX+1, CL	;and add to memory			ADC	DS: MouseX, CH		;The bytes are reversed for MESA			STI	YCoor:		%WaitForInterrupt (1)		;Waiting for the Y movement value			JC	watchDogTimeoutInterrupt			IN	AL, KeyBdUartStatus			TEST	AL, FrameError+OvRunError+ParError			JNZ	ErrorCondition						TEST	AL, RxReady			JNZ	Continue3		;			INC	DS: SpuriousIntCnt	;and increment the count			JMP	YCoor		;	Continue3:	IN	AL, KeyBdUartData	;Get the Y movement value			TEST	AL, 080H		;Test the positive/negative bit and			JNZ	NegY			;branch if negative to NegY;	      			XOR	AH, AH			;Use the magnitude value						CLI			ADD	DS: MouseY+1, AL	;and add to memory			ADC	DS: MouseY, AH		;The bytes are reversed for MESA			STI			JMP    MoreWork			;Done with mouse movement							;Go wait for next interrupt							;Use the magnitude value and	NegY:		MOV	CX, 0FF80H		;convert it to a two's complement			SUB	CL, AL			;negative number	      			CLI			ADD	DS: MouseY+1, CL	;and add to memory			ADC	DS: MouseY, CH		;The bytes are reversed for MESA			STI			JMP    MoreWork			;Done with mouse movement		kbMouseBadInterrupt  PROC	FAR				INC	DS: BadInterruptCnt	;and increment the count	      	      		CALL	init8251A		;Call the initialize subroutine to Reinitialize							;the 8251A			RET	kbMouseBadInterrupt  ENDP	      	init8251A	PROC	NEAR			%Reset (resetKeyboardHardware)			CALL	Delay			MOV	DX, KeyBdUartCtl	;			MOV	AL, StopBits1+ParityNo+Char8Bits+Factor16X			OUT	DX, AL			;Output the MODE instruction			CALL	Delay			MOV	AL, RTSEnable+ErrorReset+RxEnable+DTREnable	;Command instruction			OUT	DX, AL			;Enable 8251 for receive			RET				;Return to caller	init8251A	ENDP		Delay		PROC	NEAR			MOV	CX,010h			;get mode reg bits		Delay1:		LOOP	Delay1			;write mode reg bits				RET	Delay		ENDP		init8254	PROC	NEAR			MOV	AL, i8254SelCount2+i8254LSBthenMSB+i8254SqWave+i8254BinaryCount			OUT	i8254Ctlr,AL			MOV	AL, 26			;**** Baud9600 *****							;19 = 12MegaHertz.  26 = 16MegaHertz.			OUT	i8254Count2,AL		;ls byte			MOV	AL, 0			OUT	i8254Count2,AL		;ms byte			RET	init8254	ENDP	KeyBoardAndMouseInit	PROC	FAR			%InitializeTask (KeyBoardAndMouseHandlerID,OFFSET KeyboardAndMouseTask,KeyBoardAndMouseTaskInit,OFFSET KeyMoStack)				RET	KeyBoardAndMouseInit	ENDP	IOPEInROM		ENDS			END	;A control Z follows this line
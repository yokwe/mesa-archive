$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1987 by Xerox Corporation. All rights reserved.;-- DybrkCP.asm;-- last edited by:;--  RDH  22-Jan-86 12:06:22 ;Create from parts of RAMBoot.asm. NAME			DybrkCP;--------------------------------------------------------------------------------;$NOLIST;$INCLUDE		(EthHdFce.asm)	$INCLUDE		(HardDefs.asm)	$INCLUDE		(IOPDefs.asm)	$INCLUDE		(IOPMacro.asm)$INCLUDE		(RAMBDefs.asm)	;$INCLUDE		(EthBDefs.asm)	;$INCLUDE		(Handlers.asm)	;to resolve handler IDs;$INCLUDE		(CSBankDf.asm)	;$INCLUDE		(RAMEEP.asm)	$LIST;--------------------------------------------------------------------------------EXTRN			mesaProcessorInterrupt :ABS;--------------------------------------------------------------------------------;from IORRamBt.asm:IOPELocalRAM		SEGMENT	AT 0EXTRN			resetRegData: WORD	IOPELocalRAM		ENDS;--------------------------------------------------------------------------------;from IORRamBt.asm:BootStrapIOR		SEGMENT	COMMONEXTRN			IncSIFarProc: WORD	BootStrapIOR		ENDS;--------------------------------------------------------------------------------IOPEInRAM		SEGMENT		PUBLIC			ASSUME	CS:IOPEInRAM			ASSUME	DS:BootStrapIOR;-------------------------------------------------------------------------------PUBLIC			DybrkCPConditioningPUBLIC			WriteDybrkControlStorePUBLIC			InitDybrkCPEXTRN	LoadAXFromBootBuf: NEAREXTRN	LoadAXFromBootBufLateEntry: NEAREXTRN	LoadCXFromBootBuf: NEAREXTRN	LoadCXFromBootBufLateEntry: NEAREXTRN	CallDumpCSAddrBlock: NEAR;-------------------------------------------------------------------------------;-------------------------------------------------------------------------------DybrkCPCond	PROC	FARDybrkCPConditioning:		MOV	AX, IOPELocalRAM		MOV	ES, AX		ASSUME	ES: IOPELocalRAM		CALL	DaybreakCPHalt		CLI			;to protect reset register		MOV	AX, resetRegData		AND	AX, NOT resetMesaProcessor				OUT	WriteResetReg, AX		CALL	DaybreakCPStart		OR	resetRegData, resetMesaProcessor				MOV	AX, resetRegData		OUT	WriteResetReg, AX		CALL	DaybreakCPHalt		STI			;done with reset register		RET		ASSUME	ES:NOTHING			DybrkCPCond	ENDP;-------------------------------------------------------------------------------WriteDybrkControlStore	PROC	FARWriteCntlStore:		CALL	LoadAXFromBootBufLateEntry				;We first want to set the CS			;bank register then get the CS			;address that this block is to			;be written to.						;DayBreak's control store is an I/O port.			;Put the cs address into DX.			CALL	LoadCXFromBootBuf			MOV	DX, CX					;We want to point to the count 			;of CS words in this block,			;from which we will fetch the			;CS block size counter and 			;save it in DI - we are again out of registers!			CALL	LoadCXFromBootBuf					MOV	DI, CX			;			MOV	BP, DX						MOV	DX, daybreakBankRegister ;First let us set up the CS bank			OUT	DX, AL 			;register.			WriteDaybreakCSBlock:	MOV	DX, BP			;Also need to save initial CS adrs.			OR	DX, daybreakCSPortMask	;			MOV	CX, CSWordByteSize	;A single control store wordWriteDaybreakCSWord:	CALL DWORD PTR	IncSIFarProc		;is made up of six bytes. The			MOV	AL, ES: [BX][SI]	;layout of the control store with			OUT	DX, AL			;respect to the 4K ports is as			ADD	DX, nextCSByte		;follows: 8###H - D###H where			LOOP	WriteDaybreakCSWord	;8###H has the MSB and D###H has			INC	BP			;the LSB. The CS is loaded in six			DEC	DI			;byte data streams. Update CS word count.			JNZ	WriteDaybreakCSBlock	;Loop while not done with CS block.			CALL DWORD PTR	IncSIFarProc						RET			 						WriteDybrkControlStore	ENDP;-------------------------------------------------------------------------------DybrkInitializeCP	PROC	FAR	InitDybrkCP:	PUSHA		%Enable(mesaProcessorInterrupt)	;turn on the interrupt, but		%DisableInterruptsTillNextWait	; don't allow it till we're ready		CALL	DaybreakCPStart		;let CP run		%WaitForInterrupt	(1)	;init routines should take < 1 sec		IN	AX, ClrMesaIntr		;clear Mesa interrupt		%Disable(mesaProcessorInterrupt); and turn it off		%WaitForSystem			;drop to system level		POPA		CALL	DaybreakCPHalt		;stop the CP (so can load more code)InitializeDaybreakCPRet:		JMP	CallDumpCSAddrBlockDybrkInitializeCP		ENDP;-------------------------------------------------------------------------------waitForMesaInterrupt	PROC	NEAR							;Restore registers, thenWaitForMesaInt:		;CALL	DaisyCPHalt		;halt the CP and keep			RET				;processing the boot file.									waitForMesaInterrupt	ENDP;-------------------------------------------------------------------------------BadMesaInterrupt	PROC	NEARBadMesaInt:		RET						BadMesaInterrupt	ENDP;-------------------------------------------------------------------------------DaybreakCPHalt		PROC	NEARDybrkCPHalt:		MOV	AX, 0			OUT	WriteCSReg, AX			SHL	AX, 15	; delay			SHL	AX, 13	;  at least 38 cycles			RET			DaybreakCPHalt		ENDP;-------------------------------------------------------------------------------DaybreakCPStart		PROC	NEARDybrkCPStart:		MOV	AX, 0200H			OUT	WriteCSReg, AX			RET			DaybreakCPStart		ENDP;-------------------------------------------------------------------------------IOPEInRAM		ENDS			END
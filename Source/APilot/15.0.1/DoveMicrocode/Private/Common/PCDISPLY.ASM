$DEBUG MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);-- PCDisply.asm created  1-Nov-84  7:05:26 by Clay Mock <Mock.pa>.;--	Copyright (C) 1984,1985 by Xerox Corporation. All rights reserved.	;-- The following program was created in 1984 but has not been published within;-- the meaning of the copyright law. It is furnished under license, and may not;-- be used, copied and/or disclosed except in accordance with the terms of said;-- license.;-- Log:;--	22-Oct-86 10:32:57 by CWM.PA -- Fast display;--	22-Oct-86 10:32:57 by CWM.PA -- Code compact, garbage feature removed;--	 6-Dec-85 13:18:00 by CWM.PA -- Scan optimize;--	 5-Dec-85 11:52:28 by CWM.PA -- Mono/Color tables II, Cur Read Capab;--	 4-Dec-85 20:26:22 by CWM.PA -- Color module tables I;--	 4-Dec-85 10:37:26 by CWM.PA -- Mono module tables I;--	 4-Dec-85  9:00:55 by CWM.PA -- Mode table moved;--	 3-Dec-85 11:48:41 by CWM.PA -- Some comment fix-ups II, Ind check fix;--	22-Nov-85 11:44:30 by CWM.PA -- Some comment fix-ups;--	15-Nov-85 12:20:14 by AGK.PA -- Renamed LoadMagicByte to LoadMagic;--	 8-Oct-85 10:27:14 by CWM.PA -- Disabled mode redundancy checking;--	27-Sep-85 16:33:30 by CWM.PA -- Re-enabled used disable video;--	 4-Sep-85 20:15:15 by CWM.PA -- Fix Scan Dirty Bit initial IO;--	13-Aug-85 14:28:38 by JPM.ES -- Separate PCE into several handlers;--	12-Aug-85 12:13:55 by JPM.ES -- Change IOPEInRAM alignment to WORD;--	 9-Aug-85 16:20:39 by JPM.ES -- Opie redesign conversion;--	28-Jul-85 18:36:44 by CWM.PA -- Disable unused disable video;--	28-Jul-85 12:01:39 by CWM.PA -- Disable PC's "redundant" mode changes;--	17-Jul-85 17:05:26 by CWM.PA -- Added new Init/Exit structure;--	16-Jul-85  9:43:09 by CWM.PA -- Color display Prventive MaintCWM;--	28-Jun-85 15:07:51 by CWM.PA -- Change for new boot structure;--	27-Jun-85 13:25:12 by CWM.PA -- Color display Prventive Maint;--	 7-Jun-85 16:54:18 by CWM.PA -- Scan DB waits for a slow Mesa ;--	20-May-85 15:34:51 by AGK.PA  Removed PCEMacro.asm;--	17-May-85 18:39:23 by AGK.PA  Renamed pceDisplayUpNotifyMask to pceDisplayNotifyMask and deleted NotifyClientCondition;--	15-Apr-85 16:25:14 by AGK.PA  Changed pceDisplayInit from FAR to NEAR;--     11-Apr-85 12:23:23 by CWM.PA -- Changed for DOS;--	16-Mar-85 16:07:02 by AGK.PA -- Introduced EXTRN pceLockMask;--	19-Feb-85 14:45:58 by CWM.PA -- Display II. Massive revisions.;--	 7-Feb-85 13:03:09 by MLT.pa -- Changed ioTrappedData from BYTE to WORD;--	 7-Feb-85 10:40:06 by MLT.pa -- INCLUDEd IOPMacro.asm;--	29-Jan-85 19:14:41 by MLT.pa -- INCLUDEd PCEDefs.asm;--	28-Jan-85 11:03:58 by MLT.pa -- modified for Up Notifies;--      5-Dec-84 12:43:13 by CWM.PA -- replaced PCEMesaClientNotify for OPIE16;--	 4-Dec-84 18:02:30 by NHH.PA -- Inserted HardDef for OPIE16;--	28-Nov-84 17:20:32 by CWM.PA -- jump tables moved here;--	 2-Nov-84 16:20:14 by CWM.PA -- local storage defined here;-- 	 1-Nov-84  7:05:26 by CWM.PA -- creationNAME	PCDisply;-------------------------------------------------------------------------------$NOLIST$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(PCEDefs.asm)$INCLUDE	(DisplDef.asm)$INCLUDE	(OpieDefs.asm)$LISTEXTRN	PCEDispatcherHandlerID: ABSEXTRN	PCEDisplayHandlerID: ABS;-------------------------------------------------------------------------------PCEDisplayIOR		SEGMENT		COMMON;from IORPDspy.asmEXTRN	pceDisplayTask: taskContextBlockEXTRN	DirtyBitArray: BYTEEXTRN	ErrorCode: WORDEXTRN	ServiceReqBits: WORDEXTRN	ColorByte: BYTEEXTRN	pDisplay: BYTEEXTRN	DisplayMode: BYTEEXTRN	DirtBitsState: BYTEEXTRN	trapBase: WORDEXTRN	MonoStatusPort: BYTEEXTRN	ColorStatusPort: BYTEEXTRN	MonoIndexPort: BYTEEXTRN	ColorIndexPort: BYTEEXTRN	Mono6845Registers: Mono6845RegistersStrucEXTRN	Color6845Registers: Color6845RegistersStrucEXTRN	BytesToLoad: WORDPCEDisplayIOR		ENDSPCEDispatcherIOR	SEGMENT		COMMON; from IORPDspt.asmEXTRN	ioTrappedData: WORDEXTRN	ioTrappedAddress: WORDEXTRN	pseudoConfigSwitch2: BYTEEXTRN	pceClientCondition: ClientConditionEXTRN	ioTrappedStatus: BYTEEXTRN	pceLockMask: WORDPCEDispatcherIOR	ENDSPCEDisplaySTK		SEGMENT		COMMONEXTRN	pceDisplayStack: WORDPCEDisplaySTK		ENDSPUBLIC PCEDisplayInit, pceDisplayBoot, MonoDisplayController, ColorDisplayController, pceDisplayExit ;-------------------------------------------------------------------------------IOPEInRAM		SEGMENT		WORD PUBLIC			ASSUME		CS:IOPEInRAMEXTRN	LoadMagic: NEAREXTRN	PCEMesaClientNotify: NEAR;-------------------------------------------------------------------------------;;;			         INITIALIZATION;;;-------------------------------------------------------------------------------PCEDisplayInit		PROC	FAR	%InitializeTask (PCEDisplayHandlerID,OFFSET pceDisplayTask,pDispDummyLabel,OFFSET pceDisplayStack)	; Init task butpDispDummyLabel:	%Jam (PCEDisplayHandlerID,OFFSET pceDisplayTask)	; ...don't let it run yet	RET	pceDisplayInit		ENDP;-------------------------------------------------------------------------------;;;			            BOOT;;;-------------------------------------------------------------------------------pceDisplayBoot		PROC	NEAR; Get access to display variables	%EstablishHandlerAccess	(PCEDisplayHandlerID)	PUSH	DS	MOV	AX, ES	MOV	DS, AX	ASSUME	DS:PCEDisplayIOR; Service request bytes with bits set to request service...initially 0	MOV	ServiceReqBits,NoneSet		; Service is none requested	MOV	ErrorCode,NoneSet		; Error code initial 0, no errors	MOV	DirtBitsState,MesaReadBits	; Assume Mesa had read bits to allow scan; By now Mesa has told us the configuration in pDisplay, therefore init the scanner base	TEST	pDisplay,MonochromeOrMore	; Have we mono display?	JZ	UseColorTrapBase		; No, use the color trapper base	MOV	trapBase,pDisplayBase		; Yes, use mono base	MOV	BytesToLoad,MonoDBBytesToLoad	; Load 2 bytes for 16 db total	JMP	SHORT finishDisplayConfig	UseColorTrapBase:	MOV	BytesToLoad,ColorDBBytesToLoad  ; Color, do all dirty bits	MOV	trapBase,pDisplayBase2		; Use the color trapper base	finishDisplayConfig:	POP	DS	ASSUME	DS:NOTHING; ScanDirtyBits starts the dirty bit scanning task.	%Restart (PCEDisplayHandlerID,OFFSET pceDisplayTask,ScanDirtyBits,OFFSET pceDisplayStack)	; now let task run	RET	pceDisplayBoot		ENDP; The following loop inputs the PC's display buffer dirty bit data from the display; trapping hardware and up notifies hi level procedures to repaint Dove display.; We first wait for time to avoid making an excessive number of requests to; repaint the Dove display. ; Next, we retrieve this data as a byte in the form Mxxx1234 where M is the MSB; and represents the master dirty bit. Display hardware sets this master dirty; bit if it had set any of the dirty bit data. Though M resides in EVERY byte we; input from the display trapper, it is only necessary to read M of the first ; byte to check if any dirty bits have been set.  So essentially, there is but one; dirty bit in the eyes of software.; The next bits, xxx are don't care bits. Following, the nibble 1234 represents; the first, second, third and fourth dirty bits. Hence, the next byte we input; has the form Mxxx5678 with the lower nibble containing the fifth, sixth etc.; dirty bits, up to the maximum of 64.; Finally we store this dirty bit data in DirtyBitArray. We will pass this data up; to the MesaFunction and to the PCWindow by issuing an Upnotify.  On reading the; first port, we will receive data on the first four dirty bits and the master ; bit. We test to see if the master dirty bit is set. If not, wait again else; check if Mesa is done reading the copy of the dirty bits in the IORegion. If; so, update the IORegion else wait until Mesa is finished.  When Mesa is done,; reread the bits in the first port (because more updates may have occured during; our waiting for Mesa) and OR them into our previous record of this port. Then; continue to read the rest.CursorBaseAddress OpieAddress <08200H,0CH,PCLogicalOpieAddress>	ASSUME	DS:PCEDisplayIORmoreTest	PROC	d0:	%EstablishIOPAccess (generalMapRegister,CursorBaseAddress)z1:	CMP	WORD PTR ES:[DI], 0FFFFhz2:	JE	noCursorChange	cursorDidChange:	z3:	TEST	pDisplay,MonochromeOrMorez4:	JZ	DoColorCursor	DoMonoCursor:z5:	MOV	BX, ES:[DI]z6:	MOV	Mono6845Registers.MR0E, BHz7:	MOV	Mono6845Registers.MR0F, BLz8:	MOV	WORD PTR ES:[DI], 0FFFFhz9:	CALL	MonoCursorAdProcz10:	RET	DoColorCursor:	z11:	MOV	BX, ES:[DI]z12:	MOV	Color6845Registers.CR0E, BHz13:	MOV	Color6845Registers.CR0F, BLz14:	MOV	WORD PTR ES:[DI], 0FFFFhz15:	CALL	ColorCursorAdProc	noCursorChange:z16:	RET	moreTest	ENDP		testCursor:z17:	CALL	moreTest			ScanDirtyBits:					 z18:	%WaitForTime	(25)			; Match approx to refresh ratez19:	MOV	DX,trapBase			; DX points at first trapper portz20:	IN	AL,DX				; Reaz port, store data locallyz21:	TEST	AL,masterDirtySet		; Is the master dirty bit set?z22:	JZ	testCursor			; No, test cursor too	TestMesaReadBits:z23:	CMP	DirtBitsState,MesaReadBits	; Have bits been readz24:	JNZ	StallWrite			; State is high. Not read. Wait.z25:	JMP	SHORT	RecordBits		; Already read, record new bits	StallWrite:	PUSH	AX	PUSH	DX	%WaitForTime	(25)			; Stall. Allow Mesa to read bits	POP	DX	POP	AX	MOV	AH,AL				; Copy previous db's of port 1	IN	AL,DX				; Get any new updates to port 1	OR	AL,AH				; Add previous db's to new ones	JMP	SHORT	TestMesaReadBits	RecordBits:	 	MOV	BX,OFFSET DirtyBitArray 	; Address of our local array	MOV	CX,BytesToLoad			; Counter 2 nibbles each byte	JMP	SHORT	InitialEntry		; First time, byte already in AL	DumpDisplayTrapperLoop:	IN	AL,DX				; Get next byte from the port	InitialEntry:	SHL	AL,4				; Move dirty nibble to hi nibble	MOV	AH,AL				; Store hi nibble in AH	ADD	DX,2				; Point at next even port!		IN	AL,DX				; Read next byte	AND	AL,0FH				; Zero hi nibble to ignore master	OR	AH,AL				; Combine the previous nibble 	MOV	[BX],AH				; Store dirty byte in array	INC	BX				; Bump the local array pointer	ADD	DX,2				; Bump to next even IO port		LOOP	DumpDisplayTrapperLoop		; Until CX counts out	z30:	MOV	DirtBitsState,MesaNotReadBits	; New bits not read	testCursorToo:z31:	%EstablishIOPAccess (generalMapRegister,CursorBaseAddress)z32:	CMP	WORD PTR ES:[DI], 0FFFFhz33:	JE	falseAlarm	YesChange:	z34:	TEST	pDisplay,MonochromeOrMorez35:	JZ	ColorCursorJob	MonoCursorJob:z36:	MOV	BX, ES:[DI]z37:	MOV	Mono6845Registers.MR0E, BHz38:	MOV	Mono6845Registers.MR0F, BLz39:	MOV	WORD PTR ES:[DI], 0FFFFhz40:	JMP	SHORT	noReally		ColorCursorJob:	z41:	MOV	BX, ES:[DI]z42:	MOV	Color6845Registers.CR0E, BHz43:	MOV	Color6845Registers.CR0F, BLz44:	MOV	WORD PTR ES:[DI], 0FFFFhz45:	JMP	SHORT	noReally		falseAlarm:z46:	%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIORz48:	%MesaLockedOut (OR, OFFSET ServiceReqBits, DirtyBitsDirty, pceLockMask)z49:	MOV	AX, pceDisplayNotifyMaskz50:	CALL	PCEMesaClientNotify		z51:	JMP	ScanDirtyBits			; Do againDoubleWhammy	EQU	022H SHL 8	noReally:z52:	%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIORz54:	%MesaLockedOut (OR, OFFSET ServiceReqBits, DoubleWhammy, pceLockMask)z55:	MOV	AX, pceDisplayNotifyMaskz56:	CALL	PCEMesaClientNotify		z57:	JMP	ScanDirtyBits			; Do again		ASSUME	DS:NOTHING, ES:NOTHING;-------------------------------------------------------------------------------;;;				    EXIT;;;-------------------------------------------------------------------------------pceDisplayExit		PROC	NEAR	%Jam (PCEDisplayHandlerID,OFFSET pceDisplayTask)	; stop the task	RET	pceDisplayExit		ENDP;-------------------------------------------------------------------------------;;;		   MONOCHROME DISPLAY ADAPTER EMULATION;;;-------------------------------------------------------------------------------; The Mono Display Controller handles IO to monochrome ports. It first checks to; see if the monochrome adapter is being used. If so, it routes control to; sub-code via the MonoService Jump table. The sub-code emulates the 6845; at the appropriate port. If a color adapter is in place, then the system is; illegally attempting to access monochrome ports. Here, the handler emulates a; non-existant monochrome card!; The caller of this procedure must save regs (including DS); and restore them upon return.MonoDisplayController	PROC	%EstablishHandlerAccess (PCEDisplayHandlerID)	MOV	AX, ES	MOV	DS, AX	ASSUME	DS:PCEDisplayIOR	%EstablishHandlerAccess (PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIOR	MonoDisplayTest:	TEST	pDisplay,MonochromeOrMore	; Have we mono display?	JZ	ForgetIt			; No, handle specially	MOV	SI, OFFSET MonoServicePCIn	; Base of branch table	MonoDisplayIOTest:	TEST	ioTrappedStatus,IOInToPC 	; PC INs 6845 data?	JZ	MonoAddXtraForOutBase		; No increment base	MonoBaseIsOkay:		MOV	AX,ioTrappedAddress		; Get trapped IO address	AND	AX,000FH			; Mask out the higher order bits	SAL	AX,1				; For word offset	ADD	SI,AX				; Add to base for word index	MOV	DX, CS:[SI]			; Stuff addr. in DX	MonoJmpCheckPoint: 	JMP	DX				; Jump to proper code	MonoAddXtraForOutBase:				; This is an OUT IO	ADD	SI,MonoServiceXtra		; Inc base ptr to OUT table	JMP	SHORT	MonoBaseIsOkay		; Continue			; Mono Display Controller Jump Table.  Since the dispatcher routes addresses in; the 3B0-3BF range to the monochrome display controller, we are assured that we; will not get an out of range address that might make us erroneously jump off; the beginning or end of the table.MonoServicePCIn		LABEL	WORD			DW	ForgetIt		; 3B0			DW	ForgetIt		; 3B1			DW	ForgetIt		; 3B2			DW	ForgetIt		; 3B3			DW	ForgetIt 		; 3B4 index gets FF 			DW	Port3B5In		; 3B5 Data port 			DW	ForgetIt		; 3B6			DW	ForgetIt		; 3B7			DW	ForgetIt 		; 3B8 mode IN gets FF			DW	ForgetIt		; 3B9			DW	Port3BAIn		; 3BA status port			DW	ForgetIt		; 3BB			DW	ForgetIt		; 3BC			DW	ForgetIt		; 3BD			DW	ForgetIt		; 3BE			DW	ForgetIt		; 3BF			MonoServiceXtra		EQU	$ - MonoServicePCIn						MonoServicePCOut	LABEL	WORD			DW	ForgetIt		; 3B0			DW	ForgetIt		; 3B1			DW	ForgetIt		; 3B2			DW	ForgetIt		; 3B3			DW	Port3B4Out		; 3B4 index 			DW	Port3B5Out		; 3B5 data 			DW	ForgetIt		; 3B6			DW	ForgetIt		; 3B7			DW	Port3B8Out		; 3B8 mode			DW	ForgetIt		; 3B9			DW	ForgetIt		; 3BA status 			DW	ForgetIt		; 3BB			DW	ForgetIt		; 3BC			DW	ForgetIt		; 3BD						DW	ForgetIt		; 3BE			DW	ForgetIt		; 3BF				;-------------------------------------------------------------------------------; An out to an undocumented or unserviced port is ignored;			ForgetIt:		RET						;-------------------------------------------------------------------------------; This is the monochrome 6845 index port code. The index port accesses the index ; reg which contains the offset for IO to or from the mono 6845 register file. The; index reg is write only and we will service any reads from this port with; the exact garbage data that a real PC returns. We will also check if an index; written is within legal range to index registers 0H to 11H. If not we abort the; write because the index may allow access to other areas of our FCB.	Port3B4Out:	MOV	AX,ioTrappedData		; No, Get the index value. 	CMP	AL,LastReg			; Index too big?	JA	Mono6845IndexError1		; Yes, have an error 	MOV	MonoIndexPort,AL		; Else, Just record index locally	RET					; Finished processingMono6845IndexError1:	MOV	ErrorCode,Mono6845IndexOutOfRange ; Yes, signal index range error	JMP	MonoErrorService		;   Can't proceed on fatal error 						;   Can damage FCB data if write 						;   at illegal index. Just return.						;-------------------------------------------------------------------------------;; This is the monochrome 6845 Data port In code. The Data port contains data to ; read from the 6845 register file. Only the cursor address ports can be read from; while the rest will return 0h garbage as in a real PC.Port3B5In:	CMP	MonoIndexPort,MCurHiPort	JE	MonoRetCurHiInfo	CMP	MonoIndexPort,MCurLoPort	JE	MonoRetCurLoInfo	RET	MonoRetCurHiInfo:	MOV	AL,Mono6845Registers.MR0E	CALL	LoadMagic			; Feed to the PC	RET	MonoRetCurLoInfo:	MOV	AL,Mono6845Registers.MR0F	CALL	LoadMagic			; Feed to the PC	RET		;-------------------------------------------------------------------------------;; This is the monochrome 6845 Data port Out code. The Data port contains data to; write to the 6845 register file. An I/O sent here is further branched to; the correct "register emulator" code, though most are unsupported. Port3B5Out:MonoPrepareAX:	MOV	AL, MonoIndexPort		; Get the index 	XOR	AH, AH				; Mask out the high byteMonoStoreData:	MOV	BX, OFFSET Mono6845Registers	; Get base of register file	ADD	BX, AX	MOV	CX, ioTrappedData	MOV	BYTE PTR [BX], CL		; Store value in Reg fileMonoDataJump:		MOV	SI, OFFSET Port3B5DataBranch 	; Get base of jump table	SAL	AX,1				; For word offset	ADD	SI,AX				; Add to base for word index	MOV	DX, CS:[SI]			; Stuff addr. in DX 	JMP	DX				; Jump to proper code	Port3B5DataBranch	LABEL	WORD			DW	ForgetIt	; MonoHorizontalTotal			DW	ForgetIt	; MonoHorizontalDisplayed			DW	ForgetIt	; MonoHorizontalSyncPosit			DW	ForgetIt	; MonoHorizontalSyncWidth			DW	ForgetIt	; MonoVerticalTotal			DW	ForgetIt	; MonoVerticalTotalAdjust			DW	ForgetIt	; MonoVerticalDisplayed			DW	ForgetIt	; MonoVerticalSyncPosit			DW	ForgetIt	; MonoInterlaceMode			DW	ForgetIt	; MonoMaxScanLineAddr			DW	MonoCursorShpUN	; MonoCursorStart			DW	MonoCursorShpUN ; MonoCursorEnd			DW	MonoPageUN 	; MonoPageHi			DW	MonoPageUN	; MonoPageLow			DW	MonoCursorAdUN 	; MonoCursorAddrHi			DW	MonoCursorAdUN 	; MonoCursorAddrLow			DW	ForgetIt	; MonoLightPenHi			DW	ForgetIt	; MonoLightPenLow						;---------------------------------; Notification Battery:;; Cursor shape notify. Cursor shape can vary from 0-255 allowing different kinds ; of shape and depending on bits 5 and 6, blink rate and invisibility.;; Page start notify.  Note this address takes up 14 bits and is a word offset; from the base of the appropriate display buffer. Theoretically, this offset can; take one of up to 16K values. Legal values are for the monochrome adaptor, 0000; as there is no paging. This is unsupported in mono but left here for uniformity.;; Cursor location notify. Note this address takes up one word and is a word; offset from the base of the appropriate display buffer. Theoretically, this; offset can take one of up to 64K values. Legal values are in range of 0-1999.MonoCursorShpUN:	%MesaLockedOut (OR, OFFSET ServiceReqBits, CursorShapeChange, pceLockMask)						; Flag service and extra to MF	MOV	AX, pceDisplayNotifyMask	CALL	PCEMesaClientNotify	RET					; Finished, return	MonoPageUN:	RET					; UnsupportedMonoCursorAdProc	PROC	MonoCursorAdUN:	%MesaLockedOut (OR, OFFSET ServiceReqBits, CursorLocationChange, pceLockMask)						; Flag service req to MF; it is normal for cursor location to be updated and this is not "extra" work	MOV	AX, pceDisplayNotifyMask	CALL	PCEMesaClientNotify	RET					; Finished, returnMonoCursorAdProc	ENDP	;-------------------------------------------------------------------------------; This is the monochrome Mode control port. There are two legal monochrome modes; which we test for in the code below.  	Port3B8Out:	MOV	AX,ioTrappedData		; No, get the mode set	AND	AL,3FH				; Zero out bits 6 and 7	TEST	AL,MonoHiResMask		; Is mono hi res bit set?	JE	MonoModeControlPortError1	; No, error, must always set	TEST	AL,VideoEnableMask		; Is the video enable bit set?	JE	MonoDisableVideo		; No, handle video disabled	CMP	AL,RegMonoChrome		; Yes, is mono blink requested?	JE	MMReportMode			; Yes, report the value	CMP	AL,MonoChromeNoBlinking		; Mono no blinking requested? 	JNE	MonoModeControlPortError2	; No, a non-supported display mode MMReportMode:	MOV	DisplayMode,AL			; Report the display mode	%MesaLockedOut (OR, OFFSET ServiceReqBits, ModeControlSet, pceLockMask)						; Flag service and extra to MF	MOV	AX, pceDisplayNotifyMask	CALL	PCEMesaClientNotify	RET					; FinishedMonoModeControlPortError1:	MOV	ErrorCode,MonoCtrlHiResBitNotSet ; No, error, must always set	JMP	MonoErrorService		; Warn the error						; Can't proceed. PC would've died.	MonoModeControlPortError2:	MOV	ErrorCode,MonoModeNotSupported	; No, then error, non-supported	JMP	MonoErrorService		;   mode. Stop or proceed with						;   mystery mode.MonoDisableVideo:	%MesaLockedOut (OR, OFFSET ServiceReqBits, DisableVideo, pceLockMask)						; Flag video disable request; not necessary to flag as extra work since reported in the service request byte	MOV	AX, pceDisplayNotifyMask	CALL	PCEMesaClientNotify	RET					; Finished						;-------------------------------------------------------------------------------; This is the mononochrome status port. It basically toggles the horizontal drive; bit to present an illusion of display scanning.Port3BAIn:			CMP	MonoStatusPort,MonoStatusRetrace ; Port indicates retracing? 	JE	MonoStatusFlip			; Yes, set to tracing	MOV	MonoStatusPort,MonoStatusRetrace ; No, set to retracing	JMP	SHORT	MReturnStatus	MonoStatusFlip:	MOV	MonoStatusPort,MonoStatusTrace 	; Get the reset state	MReturnStatus:	 	MOV	AL,MonoStatusPort		; Get the state	CALL	LoadMagic			; Out to status port	RET;-------------------------------------------------------------------------------; The following services errors within the monochrome display adapter.MonoErrorService:		MOV	AX, pceDisplayNotifyMask	CALL	PCEMesaClientNotify	RET	MonoDisplayController	ENDP	ASSUME	DS:NOTHING, ES:NOTHING;-------------------------------------------------------------------------------;-------------------------------------------------------------------------------;;;		      COLOR DISPLAY ADAPTER EMULATION;;;-------------------------------------------------------------------------------; The Color Display Controller handles IO to color ports. It first checks to; see if the color adapter is being used. If so, it routes control to; sub-code via the ColorServiceBranch Jump table. The sub-code emulates the 6845; at the appropriate port. If a color adapter is in place, then the system is; illegally attempting to access mono ports. Here, the handler emulates a; non-existant monochrome card!; The caller of this procedure must save regs (including DS); and restore them upon return.ColorDisplayController	PROC			%EstablishHandlerAccess (PCEDisplayHandlerID)	MOV	AX, ES	MOV	DS, AX	ASSUME	DS:PCEDisplayIOR	%EstablishHandlerAccess (PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIOR	ColorDisplayTest:		TEST	pDisplay,Colorgraphics80Display	; Have we color 80 or 40 display?	JZ	ForgetIt2			; No, handle specially	MOV	SI, OFFSET ColorServicePCIn	; Use value as indexColorDisplayIOTest:	TEST	ioTrappedStatus,IOInToPC 	; PC INs 6845 data?	JZ	ColorAddXtraForOutBase		; No increment base	ColorBaseIsOkay:	MOV	AX,ioTrappedAddress		; Get trapped IO address	AND	AX,000FH			; Mask out the higher order bits	SAL	AX,1				; For word offset	ADD	SI,AX				; Add to base for word index	MOV	DX, CS:[SI]			; Stuff addr. in DX ColorJmpCheckPoint:		JMP	DX				; Jump to proper code	ColorAddXtraForOutBase:				; This is an OUT IO	ADD	SI,ColorServiceXtra		; Inc base ptr to OUT table	JMP	SHORT	ColorBaseIsOkay		; Continue; Color Display Controller Jump Table.  Since the dispatcher routes addresses in; the 3D0-3DF range to the color display controller, we are assured that we; will not get an out of range address that might make us erroneously jump off; the beginning or end of the table.ColorServicePCIn	LABEL	WORD			DW	ForgetIt2		; 3D0			DW	ForgetIt2		; 3D1			DW	ForgetIt2		; 3D2			DW	ForgetIt2		; 3D3			DW	ForgetIt2 		; 3D4 index gets FF 			DW	Port3D5In		; 3D5 data  			DW	ForgetIt2		; 3D6			DW	ForgetIt2		; 3D7			DW	ForgetIt2 		; 3D8 mode IN gets FF			DW	ForgetIt2		; 3D9			DW	Port3DAIn		; 3DA status port			DW	ForgetIt2		; 3DB			DW	ForgetIt2		; 3DC			DW	ForgetIt2		; 3DD			DW	ForgetIt2		; 3DE			DW	ForgetIt2		; 3DF			ColorServiceXtra		EQU	$ - ColorServicePCIn						ColorServicePCOut	LABEL	WORD			DW	ForgetIt2		; 3D0			DW	ForgetIt2		; 3D1			DW	ForgetIt2		; 3D2			DW	ForgetIt2		; 3D3			DW	Port3D4Out		; 3D4 index 			DW	Port3D5Out		; 3D5 data 				DW	ForgetIt2		; 3D6			DW	ForgetIt2		; 3D7			DW	Port3D8Out		; 3D8 mode			DW	Port3D9Out		; 3D9			DW	ForgetIt2		; 3DA status 			DW	ForgetIt2		; 3DB			DW	ForgetIt2		; 3DC			DW	ForgetIt2		; 3DD						DW	ForgetIt2		; 3DE			DW	ForgetIt2		; 3DF						ForgetIt2:	RET				;-------------------------------------------------------------------------------; This is the color 6845 index port code. The index port accesses the index ; reg which contains the offset for IO to or from the color 6845 reg file.The; index reg is write only and we will service any reads from this port with; the exact garbage data that a real PC returns. We will also check if an index; written is within legal range to index registers 0H to 11H. If not we abort the; write because the index may allow access to other areas of our FCB.Port3D4Out:	MOV	AX,ioTrappedData		; No, Get the index value.	CMP	AL,LastReg			; Index too great?	JA	Color6845IndexError1		; Yes, have an error	MOV	ColorIndexPort,AL		; Just record index locally	RET					; Finished processingColor6845IndexError1:	MOV	ErrorCode,Color6845IndexOutOfRange ; Yes, service the error	JMP	ColorErrorService		;   Can't proceed on fatal error 						;   Can damage FCB data if write 						;   at illegal index.						 ;-------------------------------------------------------------------------------;; This is the color 6845 Data port In code. The Data port contains data to ; read from the 6845 register file. Only the cursor address ports can be read from; while the rest will return 0h garbage as in a real PC.Port3D5In:	CMP	ColorIndexPort,CCurHiPort	JE	ColorRetCurHiInfo	CMP	ColorIndexPort,CCurLoPort	JE	ColorRetCurLoInfo	RET	ColorRetCurHiInfo:	MOV	AL,Color6845Registers.CR0E	CALL	LoadMagic			; Feed to the PC	RET	ColorRetCurLoInfo:	MOV	AL,Color6845Registers.CR0F	CALL	LoadMagic			; Feed to the PC	RET									;-------------------------------------------------------------------------------; This is the color 6845 Data port code. The Data port contains data to write; to or read from the 6845 register file. An I/O sent here is further branched to; the correct "register emulator" code.  Read or write capability is based; on the specs given in the Technical Reference. Checking for in or out is kept; at the lower level of each "register handler for flexibility and uniformity.	Port3D5Out:ColorPrepareAX:	MOV	AL, ColorIndexPort		; Get the index 	XOR	AH, AH				; Mask out the high byteColorStoreData:	MOV	BX, OFFSET Color6845Registers	; Get base of register file	ADD	BX, AX	MOV	CX, ioTrappedData	MOV	BYTE PTR [BX], CL		; Store value in Reg fileColorDataJump:		MOV	SI, OFFSET Port3D5DataBranch 	; Get base of jump table	SAL	AX,1				; For word offset	ADD	SI,AX				; Add to base for word index	MOV	DX, CS:[SI]			; Stuff addr. in DX 	JMP	DX				; Jump to proper codePort3D5DataBranch	LABEL	WORD			DW	ForgetIt2 ; ColorHorizontalTotal			DW	ForgetIt2 ; ColorHorizontalDisplayed			DW	ForgetIt2 ; ColorHorizontalSyncPosit			DW	ForgetIt2 ; ColorHorizontalSyncWidth			DW	ForgetIt2 ; ColorVerticalTotal			DW	ForgetIt2 ; ColorVerticalTotalAdjust			DW	ForgetIt2 ; ColorVerticalDisplayed			DW	ForgetIt2 ; ColorVerticalSyncPosit			DW	ForgetIt2 ; ColorInterlaceMode			DW	ForgetIt2 ; ColorMaxScanLineAddr			DW	ColorCursorShpUN ; ColorCursorStart			DW	ColorCursorShpUN ; ColorCursorEnd			DW	ColorPageUN	 ; ColorPageHi			DW	ColorPageUN	 ; ColorPageLow			DW	ColorCursorAdUN	 ; ColorCursorAddrHi			DW	ColorCursorAdUN	 ; ColorCursorAddrLow			DW	ForgetIt2 ; ColorLightPenHi			DW	ForgetIt2 ; ColorLightPenLow;---------------------------------; Notification Battery:;; Cursor shape notify. Cursor shape can vary from 0-255 allowing different kinds ; of shape and depending on bits 5 and 6, blink rate and invisibility.;; Page start notify.  Note this address takes up 14 bits and is a word offset; from the base of the appropriate display buffer. Theoretically, this offset can; take one of up to 16K values. ;; Cursor location notify. Note this address takes up one word and is a word; offset from the base of the appropriate display buffer. Theoretically, this; offset can take one of up to 64K values. Legal values are in range of 0-1999.	ColorCursorShpUN:	%MesaLockedOut (OR, OFFSET ServiceReqBits, CursorShapeChange, pceLockMask)						; Flag service and extra to MF	MOV	AX, pceDisplayNotifyMask	CALL	PCEMesaClientNotify	RET					; Finished, returnColorPageUN:	%MesaLockedOut (OR, OFFSET ServiceReqBits, PageChange, pceLockMask)						; Flag service req to MF; it is normal for visual page to be updated and this is not "extra" work	MOV	AX, pceDisplayNotifyMask	CALL	PCEMesaClientNotify	RET					; Finished, returnColorCursorAdProc	PROCColorCursorAdUN:	%MesaLockedOut (OR, OFFSET ServiceReqBits, CursorLocationChange, pceLockMask)						; Flag service req to MF; it is normal for cursor location to be updated and this is not "extra" work	MOV	AX, pceDisplayNotifyMask	CALL	PCEMesaClientNotify	RET					; Finished, returnColorCursorAdProc	ENDP;-------------------------------------------------------------------------------; This is the color Mode control port.   	Port3D8Out:	MOV	AX,ioTrappedData		; Get the mode set	AND	AL,3FH				; Zero out bits 6 and 7	TEST	AL,VideoEnableMask		; Is video enable bit set?	JE	ColorDisableVideo		; Yes, disable video, else...	;	CMP	AL,DisplayMode			; Is same as last copy?;	JE	Port3D8Exit			; Yes, else...		PUSH	AX				; Save mode	MOV	AX,CS				; Set up ES reg.	MOV	ES,AX	POP	AX	MOV	DI,OFFSET DisplayModeTable	; Get base of display modes table	MOV	CX,DisplayModeTableLength	; Load table lengthAgain:	REPNE	SCASB				; Compare element with mode	JE	CReportMode			; Match found, jump to MatchColorModeControlPortError1:	MOV	ErrorCode,ColorModeNotSupported	; No, then error, non-supported	JMP	ColorErrorService		;   mode. CReportMode:	MOV	DisplayMode,AL			; Report the display mode	%MesaLockedOut (OR, OFFSET ServiceReqBits, ModeControlSet, pceLockMask)						; Flag service and extra to MF	MOV	AX, pceDisplayNotifyMask	CALL	PCEMesaClientNotifyPort3D8Exit:	RET					; Finished	ColorDisableVideo:	%MesaLockedOut (OR, OFFSET ServiceReqBits, DisableVideo, pceLockMask)			; Flag video disable request not necessary to flag as			; extra work since is reported in service request byte	MOV	AX, pceDisplayNotifyMask	CALL	PCEMesaClientNotify	RET					; Finished	DisplayModeTable		LABEL	BYTE; most used modesText80x25Color			DB	29HGraphMedResColor		DB	2AHGraphMedResColorAlt		DB	0AHGraphHiRes			DB	1EHGraphHiResAlt			DB	3EHText40x25Color			DB	28H; moderately used modesText80x25BW			DB	2DHText40x25BW			DB	2CHGraphMedResBW			DB	2EHGraphMedResBWAlt		DB	0EH; seldom used modesText80x25BWNoBlinking		DB	0DHText80x25ColorNoBlinking	DB	09HText40x25BWNoBlinking		DB	0CHText40x25ColorNoBlinking	DB	08HDisplayModeTableLength		EQU	$ - DisplayModeTable	;-------------------------------------------------------------------------------; This is the color color control port. 		Port3D9Out:	MOV	AX,ioTrappedData		; Get the data	MOV	ColorByte,AL			; Store in the MF Colorbyte	%MesaLockedOut (OR, OFFSET ServiceReqBits, ColorChange, pceLockMask)						; Flag service and extra to MF	MOV	AX, pceDisplayNotifyMask	CALL	PCEMesaClientNotify	RET;-------------------------------------------------------------------------------; This is the color status port. It basically toggles the horizontal drive; and refresh bits to present an illusion of display scanning to the PC BIOS.	Port3DAIn:			CMP	ColorStatusPort,ColorStatusRetrace ; Port indicates retracing?	JE	ColorStatusFlip			; Yes, set to tracing	MOV	ColorStatusPort,ColorStatusRetrace ; No, set to retracing	JMP	SHORT	CReturnStatus		ColorStatusFlip:	MOV	ColorStatusPort,ColorStatusTrace ; Get the reset stateCReturnStatus:	MOV	AL,ColorStatusPort		; Get the set state	CALL	LoadMagic			; Out to status port 	ColorStatusPortOut:	RET	;-------------------------------------------------------------------------------	ColorErrorService:	MOV	AX, pceDisplayNotifyMask	CALL	PCEMesaClientNotify	RET	ColorDisplayController	ENDP	ASSUME	DS:NOTHING, ES:NOTHING;-------------------------------------------------------------------------------IOPEInRAM		ENDS			END
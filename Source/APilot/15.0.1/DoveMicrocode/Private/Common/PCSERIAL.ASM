$DEBUG  MOD186$PAGELENGTH (72)$PAGEWIDTH (136);----------------------;;     PCSerial.asm     ;;----------------------;; Copyright (C) 1986 by Xerox Corporation. All rights reserved.; -- Stored as  [BamBam]<WMicro>Dove>PCE-B0>PCSerial.asm; -- Last edited by: ; AGK	 3-Aug-86 15:38:43	: Creation; FHB	 6-Aug-86 13:57:57	: pseudo-code refinements; FHB	20-Aug-86 16:58:27	: first implementation of pseudo-code; FHB	27-Aug-86 10:41:12	: fixed double restarting of Rx/Tx Tasks; FHB	27-Aug-86 10:55:04	: fixed msb divisor code; FHB	27-Aug-86 13:29:20	: changed JUMP to enqueue/dequeue code to CALL; FHB	27-Aug-86 14:42:37	: changed LoadMagic EXTRN from FAR to NEAR; FHB	27-Aug-86 16:49:38	: fixed MCR OUT and IER OUT, shifting in IIR; FHB	28-Aug-86 11:19:52	: fixed IER OUT again; FHB	28-Aug-86 17:23:20	: made pceSerialEmuState a WORD value; FHB	 2-Sep-86 13:44:25	: fixed resetting of pceSerialEmuState; FHB	 3-Sep-86 13:00:35	: fixed reading of baud rate divisor latches; FHB	 4-Sep-86 15:28:19	: added up notify for parameter setting; FHB	 5-Sep-86 18:22:19	: fixed testing of CTS and DSR in enqueue; FHB	 8-Sep-86 11:46:01	: fixed Notify pSerRxBuffEmpty; FHB	10-Sep-86 16:06:46	: added pSerDNflag; FHB	11-Sep-86 16:05:01	: fixed setting of runPCE; FHB	19-Sep-86 14:31:55	: added pRxBufferCount; FHB	23-Sep-86 15:09:21	: fixed reading of MCR (read used to do write); FHB	 3-Oct-86 16:06:09	: moved INTPCE in ReceiveDequeue; FHB	 6-Oct-86  9:22:03	: added pPublicLCR; FHB	 7-Oct-86 12:04:02	: turn off PCE when setting params and baud rate; FHB	10-Oct-86  9:54:26	: added thre int on enable for Relay; FHB	13-Oct-86 12:50:56	: removed Receive work condition; FHB	20-Oct-86 16:43:25	: RELAY GOLD TEST WITH pceSerialRxIntTask; FHB	23-Oct-86  9:25:48	: added config code with pSerBaseAddressHigh ; FHB	29-Dec-86 16:46:14	: always int when thre int enabled; FHB	 9-Jan-87 15:57:27	: increase interval between receive interrupts; FHB	19-Jan-87 11:05:45	: use pseudoConfigSwitch0; FHB	15-Feb-87 13:44:38	: pOpenSerChannel - restart if received data; FHB	17-Apr-87  9:47:45	: return from Receive DQ if not DataAvailable	NAME	PCESerialEmulator;-------------------------------------------------------------------------$NOLIST$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPDefs.asm)$INCLUDE	(PCEDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(SrilDefs.asm)$LISTEXTRN		PCESerialHandlerID: ABSEXTRN		PCEDispatcherHandlerID: ABS;-------------------------------------------------------------------------PCESerialIOR		SEGMENT	COMMON; from IORPSril.asmEXTRN	pceSerialReceiveTask: taskContextBlockEXTRN	pceSerialTransmitTask: taskContextBlockEXTRN	pceSerialIOTask: taskContextBlockEXTRN	pRBR: BYTE, pTHR: BYTE, pIER: BYTE, pIIR: BYTE, pLCR: BYTE, pMCR: BYTE, pLSR: BYTE, pMSR: BYTE, pDLLSB: BYTE, pDLMSB: BYTEEXTRN	pceSerialIOCondition: Condition, pSerRxBuffEmpty: Condition, pSerSendBuffer: ConditionEXTRN	pDeltaModemStatus: BYTE, pSerSetBreak: BYTE, pSerIntsPending: BYTE, pDivisorStatus: BYTE, pAsyncIRQ: WORD, pLineStatusInt: BYTEEXTRN	pTxBuffer: BYTE, pTxBufferIndex: WORD, pRxBuffer: BYTE, pRxBufferIndex: WORD, pRxBufferCount: WORDEXTRN	pceSerialEmuState: WORD, pSerDNflag: WORDEXTRN	pJammedRxTx: BYTEEXTRN	pSerialTxCondition: Condition, pSerialRxCondition: ConditionEXTRN	pOldDLLSB: BYTE, pOldDLMSB: BYTEEXTRN	pXmitIntOnEnable: BYTEEXTRN	pPrevTxBufferIndex: WORDEXTRN	pSerDoRxInt: Condition, pceSerialRxIntTask: TaskContextBlockEXTRN	pSerBaseAddressHigh: BYTEPCESerialIOR		ENDSPCEDispatcherIOR	SEGMENT	COMMON; from IORPDspt.asmEXTRN	ioTrappedAddress: WORDEXTRN	ioTrappedStatus: WORDEXTRN	ioTrappedData: WORDEXTRN	PCEMesaClientNotify: NEAREXTRN	LoadMagic: NEAREXTRN	runPCE: BYTEEXTRN	pseudoConfigSwitch0: BYTEPCEDispatcherIOR	ENDS;-------------------------------------------------------------------------PCESerialSTK	SEGMENT	COMMONEXTRN	pceSerialReceiveStack: WORDEXTRN	pceSerialTransmitStack: WORDEXTRN	pceSerialIOStack: WORDEXTRN	pceSerialRxIntStack: WORDPCESerialSTK	ENDS;-------------------------------------------------------------------------PUBLIC	PCESerialInitPUBLIC	PCESerialBootPUBLIC	PCESerialExit;-------------------------------------------------------------------------IOPEInRam	SEGMENT	WORD PUBLIC		ASSUME	CS:IOPEInRam;-------------------------------------------------------------------------------;;;			         INITIALIZATION;;;-------------------------------------------------------------------------------		PCESerialInit		PROC	FAR	%InitializeTask (PCESerialHandlerID,OFFSET pceSerialReceiveTask,pceSerialReceiveTaskInit,OFFSET pceSerialReceiveStack)	%InitializeTask (PCESerialHandlerID,OFFSET pceSerialTransmitTask, pceSerialTransmitTaskInit,OFFSET pceSerialTransmitStack)	%InitializeTask (PCESerialHandlerID,OFFSET pceSerialIOTask, pceSerialIOTaskInit,OFFSET pceSerialIOStack)	%InitializeTask (PCESerialHandlerID,OFFSET pceSerialRxIntTask, pceSerialRxIntTaskInit,OFFSET pceSerialRxIntStack)	RET	pceSerialInit		ENDPpceSerialReceiveTaskInit:	ASSUME	DS:PCESerialIOR	%Jam (PCESerialHandlerID,OFFSET pceSerialReceiveTask)	; ...but don't let it run yet	%WaitForSystem	ASSUME	DS:NOTHINGpceSerialTransmitTaskInit:	ASSUME	DS:PCESerialIOR	%Jam (PCESerialHandlerID,OFFSET pceSerialTransmitTask)	; ...but don't let it run yet	%WaitForSystem	ASSUME	DS:NOTHINGpceSerialIOTaskInit:	ASSUME	DS:PCESerialIOR	%Jam (PCESerialHandlerID,OFFSET pceSerialIOTask)	; ...but don't let it run yet	%WaitForSystem	ASSUME	DS:NOTHING	pceSerialRxIntTaskInit:	ASSUME	DS:PCESerialIOR	%Jam (PCESerialHandlerID,OFFSET pceSerialRxIntTask)	; ...but don't let it run yet	%WaitForSystem	ASSUME	DS:NOTHING;-------------------------------------------------------------------------------;;;			            BOOT;;;-------------------------------------------------------------------------------PCESerialBoot		PROC	NEAR	ASSUME	DS:PCEDispatcherIOR	;called from dispatcher	%EstablishHandlerAccess	(PCESerialHandlerID)	ASSUME	ES:PCESerialIOR	MOV	BL, pseudoConfigSwitch0	TEST	BL, 40H	JZ	noRS232C	%Restart (PCESerialHandlerID,OFFSET pceSerialReceiveTask, 		pceSerialReceiveTaskEmul,OFFSET pceSerialReceiveStack)	; now let task run	%Restart (PCESerialHandlerID,OFFSET pceSerialTransmitTask,			pceSerialTransmitTaskEmul,OFFSET pceSerialTransmitStack)	; now let task run	%Restart (PCESerialHandlerID,OFFSET pceSerialRxIntTask, pceSerialRxIntTaskEmul,OFFSET pceSerialRxIntStack)	MOV	pJammedRxTx, FALSE	MOV	pIER, 0	MOV	pIIR, 1	MOV	pLCR, 0	MOV	pMCR, 0	MOV	pLSR, 60H	MOV	pMSR, 0noRS232C:	%Restart (PCESerialHandlerID,OFFSET pceSerialIOTask, 		pceSerialIOTaskEmul,OFFSET pceSerialIOStack)   ; now let task run	RET	ASSUME	DS:NOTHING, ES:NOTHING	PCESerialBoot		ENDP;-------------------------------------------------------------------------------;;;			    EXIT;;;-------------------------------------------------------------------------------pceSerialExit		PROC	NEAR	; Stop the tasks	%Jam (PCESerialHandlerID,OFFSET pceSerialReceiveTask)	%Jam (PCESerialHandlerID,OFFSET pceSerialTransmitTask)	%Jam (PCESerialHandlerID,OFFSET pceSerialIOTask)	%Jam (PCESerialHandlerID,OFFSET pceSerialRxIntTask)	RET	pceSerialExit		ENDP;-------------------------------------------------------------------------------;;;		            SERIAL  EMULATION;;;-------------------------------------------------------------------------------;-- Serial ReceivepceSerialReceiveTaskEmul:	; LSR.dataReady ? FALSE	; DO	;   WaitForDownNotify indicating received data available	;   LSR.dataReady ? TRUE	;   IF modem status changed THEN INTPCE -- modem status interrupt	;   INTPCE --data available interrupt 	;   IF NOT MCR.dtr THEN LOOP;  -- flush input queue	;   WaitForCondition(pSerRxBuffEmpty,noTimeout )	;   LSR.dataReady ? FALSE	;   UpNotify Receive Mesa Function -- ready for another buffer	;   ENDLOOP		ASSUME	DS:PCESerialIOR	MOV	pDeltaModemStatus, FALSE	MOV	pLineStatusInt, FALSEpSerialReceiveLoop:	MOV	pRxBufferIndex, 0	; reset buffer index	AND	pLSR, NOT 1		;dataReady ? FALSEpSerWaitReceive:	%WaitForCondition(OFFSET pSerialRxCondition,noTimeout)	CMP	pDeltaModemStatus, TRUE	;delta Modem Status set by Mesa	JNE	pSerLineStatus	;set up registers and call INTPCE for modem status interrupt	MOV	BX, 0108H	CALL	INTPCEpSerLineStatus:	CMP	pLineStatusInt, TRUE	; pLineStatusInt set by Mesa	JNE	pSerRxInt	; set up registers and call INTPCE for line status interrupt	MOV	BX, 0804H	CALL	INTPCE	pSerRxInt:	CMP	pRxBufferCount, 0 	; if the buffer is intially empty	JE	pSerRxRequest	   	; then do notify	TEST	pMCR, 1			; is data terminal ready?	; SHOULD we ignore buffer if DTR = FALSE???	JZ	dtrFALSE		; if not then go to dtrFALSETEST1:	OR	pLSR, 1			; dataReady ? TRUE	;set up registers and CALL INTPCE for data available interrupt	MOV	BX, 0401H	CALL	INTPCE	%WaitForCondition(OFFSET pSerRxBuffEmpty,noTimeout)pSerRxRequest:	OR	pceSerialEmuState, pSerialRxRequest	MOV	AX, pceSerialNotifyMask	CALL	PCEMesaClientNotify	; up notify	JMP	pSerialReceiveLoopdtrFALSE:	JMP	SHORT TEST1		ReceiveRegisterDequeue:	; reset IIR.receivedDataAvailable	; IF MCR.loopback THEN  read last byte written to transmit register	;   AND interrupt if receive data available enabled ELSE	; Dequeue byte from received buffer into pRBR and interrupt	; Call LoadMagic	; NotifyCondition(OFFSET pSerRxBuffEmpty)		AND	pSerIntsPending, NOT 4	; reset received data available interrupt	TEST	pMCR, 10H		; in loopBack Mode?	JNZ	pDoLoopRx		; if so, jump to loopback code	TEST	pLSR, 01	JZ	pSerDQExit		; return if not DataAvailable	MOV	BX, pRxBufferIndex	XOR	BH, BH			; just to avoid memory smashing	MOV	AL, BYTE PTR pRxBuffer[BX]	; get byte from receive buffer	CALL	LoadMagic	INC	pRxBufferIndex		; decrement receive buffer index	MOV	AX, pRxBufferIndex 	CMP	AX, pRxBufferCount	; is receive buffer empty	JE	pSerRxNotify		; if so, notify the receive task	; set up registers for data available interrupt	AND	AX, 3	CMP	AX, 3	JNE	pSerRxIntNow	; only wait for int on odd bytes	%NotifyCondition(OFFSET pSerDoRxInt)	; RELAY GOLD TEST 	RETpSerRxIntNow:	MOV	BX, 0401H	CALL	INTPCE	RETpSerRxNotify:	%NotifyCondition(OFFSET pSerRxBuffEmpty)	; notify the receive task	RETpDoLoopRx:	MOV	AL, pTxBuffer	CALL	LoadMagic	;set up registers and call INTPCE for thre interrupt	MOV	BX, 0202H	CALL	INTPCEpSerDQExit:	RET;-------------------------------------------------------------------------------;-- Serial TransmitpceSerialTransmitTaskEmul:	; transmitterHoldingRegisterEmpty ? tsre ? TRUE	;  -- PCE is turned off when thre should be FALSE	; msr.cts ? msr.dsr ? FALSE	; WaitForDownNotify(ConnectionOpen,noTimeout)   	; msr.cts ? msr.dsr ? TRUE	; DO	;   WaitForCondition(pSerSendBuffer, 30)	;   -- wake up every 30ms (timeout may need tweaking)	;   IF transmit buffer is empty THEN LOOP	;   -- Mesa can look at SendBreak boolean in Emulator IO Region	;   UpNotify Mesa Function to transmit buffer	;   runPCE ? FALSE	;   WaitForDownNotify indicating transmit buffer available	;   runPCE ? TRUE	;   if transmit interrupt enabled then OUT pcAscyncTxINT	;   -- for int to be enabled one of MCR.OUT # must be low	;   ENDLOOP;		MOV	pTxBufferIndex, 0	;reset buffer index	MOV	pSerSetBreak, FALSE	;reset setBreak	OR	pLSR, 060H		;thre ? tsre ? TRUE;	AND	pMSR, NOT 30H		;cts ? dsr ? FALSE	MOV	pMSR, 0			;reset all status bits	%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES: PCEDispatcherIOR	;  this down notification indicates that the RS232C Channel is open	;  we use the same down notify bit for Transmit done	;  and RS232C Connection opened.pSerWaitChanOpen:	%WaitForCondition(OFFSET pSerialTxCondition,noTimeout)	CMP	pSerDNflag, pSerialOpenFlag	JNE	pSerWaitChanOpen	MOV	pSerDNFlag, pSerialNullFlag	OR	runPCE, serialPauseMask	;restart PCE	OR	pMSR, 30H		;cts ? dsr ? TRUEpSerialTransmitLoop:	%WaitForCondition(OFFSET pSerSendBuffer, 200) 	CMP	pSerSetBreak, TRUE 		;test for SetBreak	; setbreak variable only cleared by Mesa	JE	pRequestSerialTx	; if sendBreak then notify mesa	CMP	pTxBufferIndex, 0	; any bytes to send?	JE	pSerialTransmitLoop	; buffer empty => loop	pRequestSerialTx:	OR	pceSerialEmuState, pSerialTxRequest	MOV	AX, pceSerialNotifyMask	CALL	PCEMesaClientNotify	AND	runPCE, NOT serialPauseMask	;stop PCE	;  wait for Mesa to copy transmit buffer, not to actually send it	;  could enqueue several buffers for transmission at one timepSerWaitTxBufferAvail:	%WaitForCondition(OFFSET pSerialTxCondition,noTimeout)	CMP	pSerDNflag, pSerialTxBufferFlag	JNE	pSerWaitTxBufferAvail	MOV	pSerDNFlag, pSerialNullFlag	OR	runPCE, serialPauseMask	;restart PCE	MOV	pTxBufferIndex, 0	;reset buffer index	JMP	pSerialTransmitLoop	TransmitRegisterEnqueue:	; reset IIR.TransmitterHoldingRegisterEmpty	; IF MCR.rts AND MSR.cts THEN Enqueue Tx buffer with trapped data and int	; IF MCR.loopBack THEN put byte in pRBR and interrupt if enabled	; IF Tx buffer is full THEN NotifyCondition()		AND	pSerIntsPending, NOT 2		; reset thre int	TEST	pMCR, 10H			; are we in loopback mode?	JNZ	pDoLoopTx			; if so, jump to loopback code;	TEST	pMCR, 02H			; is request to send enabled?;	JZ	pSerTxExit			; if not, exit;	TEST	pMSR, 10H			; is the modem ready (cts)?;	JZ	pSerTxExit			; if not, exit	MOV	AX, ioTrappedData		; get byte to send	MOV	BX,  pTxBufferIndex		;  BX ? pTxBufferIndex	XOR	BH, BH				; clear BH	MOV	pTxBuffer[BX], AL	; put it in the send buffer	INC	pTxBufferIndex			; increment the buffer index	; set up buffers for thre interrupt	MOV	BX, 0202H	CALL	INTPCE	CMP	pTxBufferIndex, pSerBufferSize	; is the buffer full?	JE	pSerSendBuff			; if so, jump to transmit request	RETpSerSendBuff:	%NotifyCondition(OFFSET pSerSendBuffer)	; ask mesa to send buffer	RETpDoLoopTx:	MOV	AX, ioTrappedData		; get byte to loopback	MOV	pTxBuffer, AL			; put it at base of buffer	; set up registers and call INTPCE for data available	MOV	BX, 0401H	CALL	INTPCEpSerTxExit:	RET;-------------------------------------------------------------------------------;-- Serial I/O TrappingpceSerialIOTaskEmul:	ASSUME	DS:PCESerialIOR, ES: PCEDispatcherIOR	%WaitForCondition	(OFFSET pceSerialIOCondition,noTimeout)		%EstablishHandlerAccess	(PCEDispatcherHandlerID)		MOV	BL, pseudoConfigSwitch0	; tristate if RS232C is off	TEST	BL, 40H	JZ	pSerialTristate		MOV	BX, ioTrappedAddress	CMP	BH, pSerBaseAddressHigh ; is this IO address configured?	JE	pValidSerialAddress	JMP	pSerialTristatepValidSerialAddress:	AND	BX, 0007H		; get the least 3 bits	SHL	BX, 1			; double for words	MOV	SI, OFFSET pSerialIOTable    ;get start of table	ADD	SI, BX			;add offset to start of table	MOV	DX, CS:[SI]	JMP	DX			;jump to correct procedure; Start of serial jump table		pSerialIOTable  LABEL	WORD	DW	pLDivisorOrRxOrTxBuffer	; 3F8H - R/W - RO - WO	DW	pMDivisorOrIER		; 3F9H - R/W - R/W	DW	pInterruptIdentRegister	; 3FAH - RO	DW	pLineControlRegister	; 3FBH - R/W	DW	pModemControlRegister	; 3FCH - R/W	DW	pLineStatusRegister	; 3FDH - RO	DW	pModemStatusRegister	; 3FEH - RO	DW	pSerialTristate		; 3FFH;-------------------------------------------------------------------------; pSerialTristatepSerialTristate:		;Check for IN/OUT operation	TEST	ioTrappedStatus, pIOTrapInOutBit	JNZ	pSerialTristateIN	pSerialTristateOUT:		JMP	pceSerialIOTaskEmul	;No action return	pSerialTristateIN:	MOV	AL, 0FFH	; load tri-state data since no hardware	CALL	LoadMagic	JMP	pceSerialIOTaskEmul	;-------------------------------------------------------------------------; pLDivisorOrRxOrTxBuffer; Test if divisor latch is enabled.; If so, store trapped data into pDLLSB;;      reset baud rate if pDLMSB has already been updated; If not, check for IN or OUT.; If IN, then call ReceiveRegisterDequeue, else call TransmitRegisterEnqueuepLDivisorOrRxOrTxBuffer:	TEST	pLCR, 80H			; write to divisor latch?	JNZ	pDivisorLow			; if so, jump	TEST	ioTrappedStatus, pIOTrapInOutBit	; Input or output	JZ	pJmpSerEnqueue			; do an OUT	CALL	ReceiveRegisterDequeue		; do an IN	JMP	pceSerialIOTaskEmulpJmpSerEnqueue:	CALL	TransmitRegisterEnqueue	JMP	pceSerialIOTaskEmulpDivisorLow:	TEST	ioTrappedStatus, pIOTrapInOutBit	; Input or output	JZ	pSetDivisorLow				; go do OUT	MOV	AL, pDLLSB	CALL	LoadMagic	JMP	pceSerialIOTaskEmulpSetDivisorLow:	MOV	AX, ioTrappedData	MOV	pDLLSB, AL			; set low byte of divisor	TEST	pDivisorStatus, highDivisorSet	; has the high byte been set?	JNZ	pOpenChannel1			; yes = both bytes of divisor set	OR	pDivisorStatus, lowDivisorSet	JMP	pceSerialIOTaskEmulpOpenChannel1:	CALL	pOpenSerChannel	JMP	pceSerialIOTaskEmul	;-------------------------------------------------------------------------; pMDivisorOrIER; Test if divisor latch is enabled.; If so, store trapped data into pDLMSB; reset baud rate (CALL OpenPCSerial) if pDLLSB has already been updated; If not, check for IN or OUT.; If IN, then read pIER; call LoadMagic; If OUT, then store trapped data into pIER; set interrupt enable flags in IORPSril to be used in receive, transmit, and status change emulationspMDivisorOrIER:	; Perform above operations	TEST	pLCR, 80H		; write to divisor latch?	JNZ	pDivisorHigh		; if so, jump	TEST	ioTrappedStatus, pIOTrapInOutBit	; Input or Output	JZ	pOutToIER		; do an OUT	MOV	AL, pIER		; do an IN	CALL	LoadMagic	JMP	pceSerialIOTaskEmulpOutToIER:	MOV	AX, ioTrappedData	MOV	pIER, AL	;  the following lines of code allow delaying the thre interrupt	;  until it is enabled.  This is required for the Relay package	TEST	AL, 2			;is thre enabled?	JZ	pIERExit;	CMP	pXmitIntOnEnable, TRUE	;do we have an open int request?;	JNE	pIERExit	MOV	BX, 0202H		;do thre interrupt	CALL	INTPCE;	MOV	pXmitIntOnEnable, FALSE	JMP	pceSerialIOTaskEmulpDivisorHigh:	TEST	ioTrappedStatus, pIOTrapInOutBit	; Input or output	JZ	pSetDivisorHigh				; go do OUT	MOV	AL, pDLMSB	CALL	LoadMagic	JMP	pceSerialIOTaskEmulpSetDivisorHigh:	MOV	AX, ioTrappedData	MOV	pDLMSB, AL			; set high byte of divisor	TEST	pDivisorStatus, lowDivisorSet	; has the low byte been set?	JNZ	pOpenChannel			; yes = both bytes of divisor set	OR	pDivisorStatus, highDivisorSet	 	JMP	pceSerialIOTaskEmulpOpenChannel:	CALL	pOpenSerChannelpIERExit:	JMP	pceSerialIOTaskEmul	;-------------------------------------------------------------------------;		Interrupt Enable Register;	-------------------------------; bit | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |		 		IIR priority code;	-------------------------------;	|   |	|   |	|   |	|   |;	|   |	|   |	|   |	|   +--> Data Available			4;	|   |	|   |	|   |	+------> Tx Holding Register Empty	2;	|   |	|   |	|   +----------> Receive Line Status		6;	|   |	|   |	+--------------> Modem Status			0;	|   |	|   +------------------> = 0;	|   |	+----------------------> = 0;	|   +--------------------------> = 0;	+------------------------------> = 0;;	bits sets in pSerIntsPending correspond to ints with priority = 4 - bit;; pInterruptIdentRegister; Check for IN or OUT.; If IN, then (read pIIR); call LoadMagic;  IIR ? priority code for highest pending int indicated in pSerIntsPending;	IN resets IIR.transmitterHoldingRegisterEmpty if that was cause of int ;	how do we know whether thre was cause of int?;	assume that was cause if pIIR currently shows thre;pInterruptIdentRegister:	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	pIIRExit		; OUT is a nop	;  emulate IN	MOV	BL, pSerIntsPending	SHL	BL, 4			; move low nibble to high nibble	MOV	AL, 6			; reset priority counter	MOV	CX, 4			;set loop counter - 4 possible int sourcespIIRPriorityLoop:	SHL	BL, 1			; shift msb into carry bit	JC	pSetIIR	SUB	AL, 2			; decrement priority counter	LOOP	pIIRPriorityLoop	MOV	AL, 1			; no interrupts pendingpSetIIR:	MOV	pIIR, AL	CALL	LoadMagic	CMP	pIIR, 2			; was thre the source of the interrupt?	JNE	pIIRExit		; exit if not	AND	pSerIntsPending, NOT 2	; reset thre interruptpIIRExit:	JMP	pceSerialIOTaskEmul;-------------------------------------------------------------------------; pLineControlRegister; Check for IN or OUT.; If IN, then read pLCR; call LoadMagic; If OUT, then store trapped data in pLCR; "interpret" pLCR  (only setBreak requires action - implement by setting "SendBreak" flag and Notifying "pSerSendBuffer" for transmit handler to send all of buffer and ask mesa to RS232C.SendBreak ); IF OUT and not dlab then do up notify if data format changed.pLineControlRegister:	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	pLCROut			; goto write LCR	MOV	AL, pLCR	CALL	LoadMagic		; do IN	JMP	pceSerialIOTaskEmulpLCROut:	MOV	AX, ioTrappedData	MOV	pLCR, AL	TEST	AL, 0C0H		; is setBreak or DLAB TRUE?	JZ	pSetParams	; IF not then set data format parameters	TEST	AL, 40H			; test for set Break	JZ	pLCRExit	MOV	pSerSetBreak, TRUE	; setBreak ? TRUE, for Mesa to read	%NotifyCondition(OFFSET pSerSendBuffer)pLCRExit:		JMP	pceSerialIOTaskEmulpSetParams:	OR	pceSerialEmuState, pSerialSetParams ; up notify to set parameters	MOV	AX, pceSerialNotifyMask	CALL	PCEMesaClientNotify	AND	runPCE, NOT serialPauseMask	;stop PCEpWaitParamsSet:	%WaitForCondition(OFFSET pSerialTxCondition,noTimeout)	CMP	pSerDNflag, pSerialParamFlag	JNE	pWaitParamsSet	MOV	pSerDNFlag, pSerialNullFlag	OR	runPCE, serialPauseMask	;restart PCE		JMP	pceSerialIOTaskEmul;-------------------------------------------------------------------------; pModemControlRegister; Check for IN or OUT.; If IN, then read pMCR; call LoadMagic; If OUT, then store trapped data in pMCR; "interpret" pMCR  (loopback and OUTs are only implemented functions); jam the send and receive tasks on entering loopback modepModemControlRegister:	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	pMCROut			; goto write MCR	MOV	AL, pMCR	CALL	LoadMagic	JMP	SHORT pMCRExitpMCROut:	MOV	AX, ioTrappedData	MOV	pMCR, AL	TEST	AL, 10H	JNZ	pMCRLoopBack	JMP	SHORT pMCRExitpMCRLoopBack:		CMP	pJammedRxTx, TRUE	JE	pMCRExit	%Jam (PCESerialHandlerID,OFFSET pceSerialReceiveTask)	%Jam (PCESerialHandlerID,OFFSET pceSerialTransmitTask)	MOV	pJammedRxTx, TRUEpMCRExit:	JMP	pceSerialIOTaskEmul;-------------------------------------------------------------------------; pLineStatusRegister; Check for IN or OUT.; If IN, then "interpret" state of emulator, set and read pLSR; call LoadMagic; 	IF IN, reset IIR.ReceiverLineStatuspLineStatusRegister:	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	pLSRExit		; OUT is a nop	AND	pSerIntsPending, NOT 8H	; reset IIR.ReceiverLineStatus	MOV	AL, pLSR	CALL	LoadMagicpLSRExit:	JMP	pceSerialIOTaskEmul;-------------------------------------------------------------------------; pModemStatusRegister; Check for IN or OUT.; If IN, then "interpret" state of emulator, set and read pMSR; call LoadMagic;    IN resets bits 0..3 to zero;	IN resets IIR.ModemStatus; If IN and MCR.loopBack THEN cts ? mcr.dtr, dsr ? mcr.rts, ri ? mcr.OUT 1, ;  rlsd ? mcr.OUT 2pModemStatusRegister:	TEST	ioTrappedStatus, pIOTrapInOutBit	JZ	pMSRExit		; OUT is a nop	AND	pSerIntsPending, NOT 1	; reset IIR.ModemStatus	TEST	pMCR, 10H		; are we in loopback mode?	JZ	pNotLoopBack	; implment loopback	MOV	AL, pMCR	AND	AL, 0FH			; mask low nibble of MCR	SHL	AL, 4			; move low nibble to high nibble	AND	pMSR, 0FH		; mask low nibble of MSR	OR	pMSR, AL		; high nibble of MSR ? low nibble of MCRpNotLoopBack:	MOV	AL, pMSR	CALL	LoadMagic	AND	pMSR, NOT 0FH		; reset low 4 bits (delta modem status)pMSRExit:	JMP	pceSerialIOTaskEmul;--------------------------------------------;INTPCE	- interrupts PCE if the designated int is enabled;;	register usage;	BH: mask for pSerInstPending ;		Receiver Line Status:		8;		Received Data Available:	4;		Tx holding Register Empty:	2;		Modem Status:			1;	BL: mask for interrupt enable bit, only enable bit set;		Data Available:			1;		Tx Holding Register Empty:	2;		Receive Line Status:		4;		Modem Status			8;; int enabled if one of OUT1 and OUT2 is low and IER bit is highINTPCE:	TEST	pMCR, 4		; is OUT 1 low?	JZ	OUTLow		; if so, go see if int enabled	TEST	pMCR, 8		; is OUT 2 low?	JZ	OUTLow		; is so, go see if int enabled	RET			; RETURN IF neither OUT is lowOUTLow:	TEST	pIER, BL	; is specified int enabled?	JNZ	DoInt		; if so then interrupt the PC;	CMP	BL, 2		; if not, then is thre interrupt desired;	JE	pOpenXmitInt			RET;pOpenXmitInt:;	MOV	pXmitIntOnEnable, TRUE	; do thre interrupt when enabled;	RET			DoInt:		MOV	DX, pAsyncIRQ	; get interrupt address (primary or secondary)	OUT	DX, AL		; the value of AL doesn't matter	; set interrupt id byte to be interpreted when IIR is read	OR	pSerIntsPending, BH	RET					;--------------------------------------------------------------------------; only reset the reopen the channel if the baud rate has changed or ; the send and receive tasks are jammed do to loopback mode;pOpenSerChannel	PROC	NEAR	CMP	pJammedRxTx, TRUE	JE	pRestartSerial	MOV	AX, WORD PTR pDLLSB		CMP	AX, WORD PTR pOldDLLSB ; has the baud rate divisor changed?	JNE	pRestartSerial	TEST	pLSR, 01H	;is there data in the receive buffer?	JNZ	pRestartSerial  ;if so then reset the whole system.	RETpRestartSerial:	MOV	WORD PTR pOldDLLSB, AX	%Jam (PCESerialHandlerID,OFFSET pceSerialReceiveTask)	%Jam (PCESerialHandlerID,OFFSET pceSerialTransmitTask)	%Restart (PCESerialHandlerID,OFFSET pceSerialReceiveTask, pceSerialReceiveTaskEmul,OFFSET pceSerialReceiveStack)   ; now let task run	%Restart (PCESerialHandlerID,OFFSET pceSerialTransmitTask, pceSerialTransmitTaskEmul,OFFSET pceSerialTransmitStack)   ; now let task run	MOV	pJammedRxTx, FALSE	;UpNotify(OpenRS232CConnection)	MOV	pceSerialEmuState, pSerialOpenRequest	MOV	AX, pceSerialNotifyMask	CALL	PCEMesaClientNotify	MOV	pDivisorStatus, 0	;reset baud rate divisor status	AND	runPCE, NOT serialPauseMask	;stop PCE	RETpOpenSerChannel	ENDPpceSerialRxIntTaskEmul:	%WaitForCondition(OFFSET pSerDoRxInt,noTimeout)	AND	pLSR, NOT 1		;dataReady ? FALSE	%WaitForTime(20)	OR	pLSR, 1			;dataReady ? TRUE	MOV	BX, 0401H	CALL	INTPCE	JMP	pceSerialRxIntTaskEmul	;-------------------------------------------------------------------------	ASSUME	DS:NOTHING, ES:NOTHING;-------------------------------------------------------------------------IOPEInRam	ENDS;********************************************************************************		END
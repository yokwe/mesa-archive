$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);-- stored as MesaVM.asm;-- created on  19-Jul-84 13:20:18;-- last edited by:;--	TXM	29-Aug-88 14:23:27	:change algorithm of SearchLowMemory.;--	TXM	26-Aug-88 14:49:44	:change display memory mask of systemMemDesc.;--	KEK	30-Apr-87 13:24:48	:zero out WHOLE IOR in case of not debugging with a FatIOR to support a prom image (bug!).;--	KEK	22-Apr-87 11:32:26	:add use of VMMDefs.dovePROMSize to support expanded IOR during debugging.;--	kek	14-Apr-87 15:31:38	:add Daybreak-only MDS relief.  For Daisy this is still non-MDS-relieved!;--	RDH	17-Feb-87 15:06:57	:Use masks from vmmdefs to correctly prevent display memory from being cleared.;--	JAC	23-Jan-87 12:34:45	:initialize aChipCount for Daybreaks;--	KEK	26-Sep-86 13:55:42	:another bug in AS conversion (off-by-one);--	kek	23-Jun-86 16:48:47	;add ASCheckPage for multi AChip support.;--	kek	27-May-86 13:18:20	;add mem zeroing stuff for parity initing.;--	kek	12-May-86 12:52:08	;add new Daisy stuff;--	JPM	20-Aug-85 12:46:45	;Fix bugs in Search*Memory.;--	JPM	12-Aug-85 14:31:53	;Search for memory limits if EEProm bad.;--	JPM	 5-Aug-85 14:05:18	;EEProm changes.;--	JPM	29-Jul-85 11:22:59	;Opie redesign conversion.;--	JMM	20-Jun-85 10:16:05	;Upgrades.;--	JMM	 4-Apr-85 15:33:07	;Upgrades.;--	JMM	20-Feb-85 10:24:19	;First release.NAME			MesaVM;--------------------------------------------------------------------------------;$NOLIST$INCLUDE		(HardDefs.asm)$INCLUDE		(IOPDefs.asm)$INCLUDE		(ROMEEP.asm)$INCLUDE		(RAMEEP.asm)$INCLUDE		(IOPMacro.asm)$INCLUDE		(VMMDefs.asm)$LIST;--------------------------------------------------------------------------------;********************************************************************************;--------------------------------------------------------------------------------IOPELocalRAM		SEGMENT	AT 0EXTRN			VMMFirstPage: WORD, VMMSizeInPages: WORDEXTRN			firstRealPageInVM: WORD, lastRealPageInVM: WORDEXTRN			countRealPagesInVM: WORDEXTRN			firstDisplayBankPage: WORD, countDisplayBankPages: WORDEXTRN			IOROpieSegmentAddress: WORDEXTRN			aChipCount: BYTEEXTRN			prebootSwitches: WORDneedFatIOR		EQU	4000HIOPELocalRAM		ENDS;--------------------------------------------------------------------------------BootStrapIOR		SEGMENT		COMMONEXTRN			loaderVirtualMemoryLocation  :DWORD ;from IORRAMBt.asmBootStrapIOR		ENDS;--------------------------------------------------------------------------------OpieIOR			SEGMENT		COMMONEXTRN			mesaPageMapOffset: WORDEXTRN			mesaPageMapSegment: WORDOpieIOR			ENDS;--------------------------------------------------------------------------------DisplayIOR			SEGMENT		COMMONEXTRN			bitMapOrg: WORDDisplayIOR			ENDS;--------------------------------------------------------------------------------;********************************************************************************IOPEInRAM		SEGMENT		PUBLICPUBLIC			MesaVM 		;jmm:84-11-27:debug only.			Assume CS:IOPEInRAM			Assume DS:BootStrapIOR;--------------------------------------------------------------------------------;Local Constants:;----------------;Register equates:currentRealPage		EQU	BXIndexToCurrentVirtualPage EQU	DIcurrentVirtualPage	EQU	SIrequest			EQU	SIsavedContents		EQU	SIpagesPerBank		EQU	BP;Local Variables:;----------------systemMemDesc		DW	0		;From EEPROMexpansionMemDesc	DW	0		;From EEPROMsizeOfVMM		DW	0		;Calculated from EEPROM entrylocationOfVMM		DW	0		;depends on machine type & mem sizesizeOfIORegion		DW	0		;fixed (for now)locationOfIORegion	DW	0		;depends on machine typesizeOfIORegionCopy	DW	0		;these are needed for formattinglocationOfIORegionCopy	DW	0		; the virtual IORegionsizeOfDisplayMemory	DW	0		;From EEPROMlocationOfDisplayMemory	DW	0		;depends on machine typefirstRealPage		DW	-1		;found during VMM loadlastRealPage		DW	0		;found during VMM loadcountRealPages		DW	0		;found during VMM loadsizeOfPageInBytes	DW	pageSizeInBytessizeOfPageInWords	DW	pageSizeInWordslocalPrebootSwitches	DW	0;--------------------------------------------------------------------------------;-- Virtual Memory Initialization:;--------------  Assume the following upon entry into this procedure:;--------------;--------------|  Information:	Pilot uses the virtual memory map (VMM) to 	|;--------------|  figure out how much memory it has got. We therefore need to 	|;--------------|  enter all the memory available for Pilot's use into the VMM. 	|;--------------|  Note that this would therefore preclude display memory and of	|;--------------|  course the memory occupied by the VMM itself. i.e. All memory	|;--------------|  is mapped except display memory and the virtual memory map.	|;--------------|  Display memory ends up being mapped by "UserTerminalHeadDove"	|;--------------|								|;--------------|  Further so that the IOP does not have to go through the VMM 	|;--------------|  to access real (this was not even physically possible with  	|;--------------|  the DLion) memory the IORegion (IOPage in DLion) is at a 	|;--------------|  well known location in real memory and also in a well known 	|;--------------|  location in virtual memory.					|;--------------|  								|;--------------|								|;--------------|								|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|								|;--------------|	mesaVMMMapRegister = beginning of 128KbBank containing 	|;--------------|			     the VMM.				|;--------------|	loaderVirtualMemoryLocation = 24-bit Opie address of  	|;--------------|			type "mesaLogicalPageOpieAddress" 	|;--------------|			where the Germ is to be loaded.		|;--------------|								|;--------------------------------------------------------------------------------MesaVM			PROC	FAREnterMesaVM:			%ReadEEProm(eePromLowMem,1)			JNC	StoreLowMemDesc			;if can't trust EEPROM,			CALL	SearchLowMemory			; try to figure it outStoreLowMemDesc:	MOV	CS: systemMemDesc, AX			%ReadEEProm(eePromHighMem,1)			JNC	MakeHighMemDesc			;if can't trust EEPROM,			CALL	SearchHighMemory		; try to figure it outMakeHighMemDesc:	MOV	CX, 16				;each count in AX			SUB	CX, AX				;becomes one bit			MOV	AX, 0FFFFH			;in mem desc word			JS	StoreHighMemDesc		;(up to 16)			SHR	AX, CLStoreHighMemDesc:	MOV	CS: expansionMemDesc, AX			MOV	AX, IOPELocalRAM			MOV	ES, AX			ASSUME	ES:IOPELocalRAM			%ReadEEProm(eePromMemSize,1)		;jmm:84-12-26:MakeWordForVMMPageCount			JNC	CalcSizeOfVMM			;if can't trust EEPROM,			MOV	AL, 1				;use 22 bit VMCalcSizeOfVMM:		AND	AL, 3				;get encoded VM size			MOV	CL, AL				;prepare to shift			MOV	AX, 32				;calculate number			SHL	AX, CL				;of VMM pages			MOV	CS: sizeOfVMM, AX		;and store			MOV	VMMSizeInPages, AX			MOV	AX, prebootSwitches			MOV	CS: localPrebootSwitches, AX;-----------------------InitializeVMMSetUpVariables:			TEST	CS: localPrebootSwitches, needFatIOR			JNZ	fattenIOR	skinnyIOR:	MOV	CS: sizeOfIORegion, doveSlimIORegionSize			MOV	CS: sizeOfIORegionCopy, doveSlimIORegionSize			JMP	doneWithIOR	fattenIOR:	MOV	CS: sizeOfIORegion, doveFatIORegionSize			MOV	CS: sizeOfIORegionCopy, doveFatIORegionSize	doneWithIOR:								;We need to know what			IN	AX, machineIDPort		;machine we are on because			AND	AX, machineIDMask		;VMM, IORegion and display			CMP	AX, Daisy			;are in different places for			JE	DaisyInitialization		;different configurations.			JMP	DaybreakInitializationDaisyInitialization:	CMP	CS: expansionMemDesc, 0			JNZ	FatDaisyVariablesSlimDaisyVariables:	MOV	CS: locationOfVMM, slimDaisyVMMBasePage			MOV	VMMFirstPage, slimDaisyVMMBasePage			MOV	CS: locationOfIORegion, slimDaisyIORegionBasePage			MOV	CS: locationOfIORegionCopy, slimDaisyIORegionBasePage			MOV	CS: locationOfDisplayMemory, slimDaisyDisplayBasePage			MOV	firstDisplayBankPage, slimDaisyDisplayBasePage			MOV	CS: sizeOfDisplayMemory, slimDaisyDisplayMemSize			MOV	countDisplayBankPages, slimDaisyDisplayMemSize			AND	CS: systemMemDesc, slimDaisyDisplayDescMask	;don't put display mem in VM			;the AChip was originally programmed assuming a bitMapOrg of zero,			; as would be the case for fatDaisy.  Since it is slimDaisy,			; it must be reprogrammed.			;Note that I am NOT copying the bitMap contents to the new bitMapOrg.			; As a consequence, the bitmap will display trash after this executes.			PUSH	ES			MOV	AX, DisplayIOR	;display IOR bitMapOrg.			MOV	ES, AX			ASSUME	ES: DisplayIOR			MOV	ES: bitMapOrg, 768			POP	ES			ASSUME	ES: IOPELocalRAM			MOV	DX, 08C0H	;AChip.BaseP bitMapOrg.			MOV	AX, 0C000H			OUT	DX, AX			MOV	aChipCount, 1			;set actual aChipCount.			MOV	DX, slimDaisyDisplayBasePage	;(for later display bitmap zeroing)			MOV	BP, slimDaisyDisplayEndPage			JMP	FindDaisyDisplaySizeFatDaisyVariables:	MOV	CS: locationOfVMM, fatDaisyVMMBasePage			MOV	VMMFirstPage, fatDaisyVMMBasePage			MOV	CS: locationOfIORegion, fatDaisyIORegionBasePage			MOV	CS: locationOfIORegionCopy, fatDaisyIORegionBasePage			MOV	CS: locationOfDisplayMemory, fatDaisyDisplayBasePage			MOV	firstDisplayBankPage, fatDaisyDisplayBasePage			MOV	countDisplayBankPages, fatDaisyDisplayMemSize			MOV	CS: sizeOfDisplayMemory, fatDaisyDisplayMemSize			AND	CS: systemMemDesc, fatDaisyDisplayDescMask	;don't put display mem in VM			;the AChip was originally programmed assuming a one-ASID situation.  Since			; there is more than one AID, it they must be reprogrammed for more			; than one ASID.			MOV	DX, 082EH	;AID0 ¬ ASID1			MOV	AX, 0001H			OUT	DX, AX			INC	DH		;AID1 ¬ ASID0			DEC	AX			OUT	DX, AX			INC	DH		;AID2 ¬ ASID2			MOV	AX, 0002H			OUT	DX, AX			INC	DH		;AID3 ¬ ASID3			MOV	AX, 0003H			OUT	DX, AX			MOV	DX, fatDaisyDisplayBasePage	;(for later display bitmap zeroing)			MOV	BP, fatDaisyDisplayEndPage			MOV	AX, CS: expansionMemDesc	;calculate actual aChipCount.			MOV	aChipCount, 2	; 2 chips!			SHR	AX, 4			JZ	FindDaisyDisplaySize			INC	aChipCount	; 3 chips!			SHR	AX, 4			JZ	FindDaisyDisplaySize			INC	aChipCount	; 4 chips!FindDaisyDisplaySize:	IN	AL, DaisyDisplayTypePort			AND	AL, DaisyDisplayTypeMask			CMP	AL, DaisynineteenInch			JMP	SHORT DisplaySizeFoundDaybreakInitialization:	MOV	CS: locationOfVMM, fatDaybreakVMMBasePage			MOV	VMMFirstPage, fatDaybreakVMMBasePage			MOV	CS: locationOfIORegion, fatDaybreakIORegionBasePage			MOV	CS: locationOfIORegionCopy, fatDaybreakIORegionBasePage			MOV	CS: locationOfDisplayMemory, fatDaybreakDisplayBasePage			MOV	aChipCount, 0			;daybreak has no a chips			MOV	firstDisplayBankPage, fatDaybreakDisplayBasePage;			TEST	CS: systemMemDesc, 0FCH		;commented out for Duke			AND	BYTE PTR CS: systemMemDesc, 0FCH   ;don't put display mem in VM			JNZ	FatDaybreakVariables			MOV	CS: sizeOfDisplayMemory, slimDaybreakDisplayMemSize			MOV	countDisplayBankPages, slimDaybreakDisplayMemSize			JMP	SHORT FindDaybreakDisplaySizeFatDaybreakVariables:	MOV	CS: sizeOfDisplayMemory, fatDaybreakDisplayMemSize			MOV	countDisplayBankPages, fatDaybreakDisplayMemSizeFindDaybreakDisplaySize:MOV	DX, DisplayTypePort			IN	AL, DX			MOV	DX, fatDaybreakDisplayBasePage;(for later display bitmap zeroing)			MOV	BP, fatDaybreakDisplayEndPage			TEST	AL, DisplayTypeMask;-----------------------; zero memory from end of display bitmap to end of display memory bank.; enter here with start of display bitmap in DX, and the zero flag set if 19".; oh, also BP needs to be pointing to the last page of the display memory.DisplaySizeFound:	JZ	fatDisplay	slimDisplay:	ADD	DX, pagesFor15InchDisplay			JMP	InitDisplayMemory	fatDisplay:	ADD	DX, pagesFor19InchDisplayInitDisplayMemory:	MOV	AX, DX			CALL	ZeroPage			INC	DX			CMP	DX, BP			JB	InitDisplayMemory						;-----------------------MemorySizeFound:	TEST	CS: localPrebootSwitches, needFatIOR			JNZ	setUpFatIOR	setUpSmallIOR:	MOV	BX, (doveSlimIORegionSize SHL 8)	;word count			JMP	IORSetUp	setUpFatIOR:	;MOV	BX, ((doveFatIORegionSize-dovePROMSize) SHL 8)			MOV	BX, ((doveFatIORegionSize-dukePROMCodeSize) SHL 8); dovePROMSize is subtracted from the IORegionSize above so that any; debugging prom image present is not erased, in the setUpFatIOR case.; In the setUpSmallIOR case, of course, there is no prom image present since it is; not a debugging session by definition...!IORSetUp:		MOV	DX, CS: locationOfIORegion			MOV	CX, (extendedBusPageOpieAddress SHL 8)			%EstablishIOPAccess(IORegionMapRegister,CX-DX)			ASSUME	ES:NOTHINGZeroIOR:		MOV	CX, BX			;the size of IOR to be  0'ed...			XOR	AX, AX			CLD			REP	STOSW			MOV	DX, CS: locationOfVMM			MOV	CX, (extendedBusPageOpieAddress SHL 8)			%EstablishIOPAccess(mesaVMMapRegister,CX-DX)			ASSUME	ES:NOTHING;-----------------------			PUSH	ES			PUSH	DI			MOV	CX, CS: sizeOfVMMStampAllPagesVacant:	MOV	DX, pageSizeInWordsStampAllPgsThisPg:	MOV	WORD PTR ES: [IndexToCurrentVirtualPage], (pageVacantMask SHL 8)			INC	IndexToCurrentVirtualPage			INC	IndexToCurrentVirtualPage			JNZ	StayInThis64KbBank			MOV	AX, ES			ADD	AX, crossover64KbBank			MOV	ES, AXStayInThis64KbBank:	DEC	DX			JNZ	StampAllPgsThisPg			LOOP	StampAllPagesVacant			POP	DI			POP	ES;-----------------------			PUSH	ES			PUSH	DI			MOV	currentVirtualPage, 0MapSystemPages:		MOV	currentRealPage, 0			MOV	DX, CS: systemMemDesc			MOV	pagesPerBank, numberOfPagesIn64KbBankCheckIfDone:		CMP	DX, 0			JNE	CheckIfThisBankPresent			JMP	IsVMSetUpDone				;no more unitsCheckIfThisBankPresent:	MOV	CX, pagesPerBank			;number of pages in a bank			RCR	DX, 1			JC	PageMappingLoop				;found a bank			ADD	currentRealPage, CX			;skip over this bank			JMP	CheckIfDonePageMappingLoop:	CMP	currentRealPage, CS: locationOfVMM			JNE	IsItDisplayMemRealPage			CMP	CX, CS: sizeOfVMM			JGE	SkipVMM			ADD	CS: locationOfVMM, CX			SUB	CS: sizeOfVMM, CXSkipPartOfArea:		ADD	currentRealPage, CX			JMP	CheckIfDoneSkipVMM:		ADD	currentRealPage, CS: sizeOfVMM			SUB	CX, CS: sizeOfVMMShouldWeContinue:	JNZ	PageMappingLoop			JMP	CheckIfDoneIsItDisplayMemRealPage:	CMP	currentRealPage, CS: locationOfDisplayMemory			JNE	IsItIORegionRealPage			CMP	CX, CS: sizeOfDisplayMemory			JGE	SkipDisplay			ADD	CS: locationOfDisplayMemory, CX			SUB	CS: sizeOfDisplayMemory, CX			JMP	SkipPartOfAreaSkipDisplay:		ADD	currentRealPage, CS: sizeOfDisplayMemory			SUB	CX, CS: sizeOfDisplayMemory			JMP	ShouldWeContinueIsItIORegionRealPage:	CMP	currentRealPage, CS: locationOfIORegion			JNE	IsItIORegionVirtualPage			CMP	CX, CS: sizeOfIORegion			JGE	SkipIORegion			ADD	CS: locationOfIORegion, CX			SUB	CS: sizeOfIORegion, CX			JMP	SkipPartOfAreaSkipIORegion:		ADD	currentRealPage, CS: sizeOfIORegion			SUB	CX, CS: sizeOfIORegion			JMP	ShouldWeContinue;this is here to shorten the backward jumpsGoToNextPage:		INC	currentVirtualPage			INC	currentRealPage			INC	countRealPages			LOOP	PageMappingLoop			JMP	CheckIfDoneIsItIORegionVirtualPage:			TEST	CS: localPrebootSwitches, needFatIOR			JNZ	needFatIORVM	needSlimIORVM:	CMP	currentVirtualPage, slimIORegionFirstVirtualPage			JMP	doneIORVM	needFatIORVM:	CMP	currentVirtualPage, fatIORegionFirstVirtualPage	doneIORVM:	JNE	KeepMapping			PUSH	currentRealPage			PUSH	CX			MOV	CX, CS: sizeOfIORegionCopy			MOV	currentRealPage, CS:locationOfIORegionCopyMapIORegion:		MOV	AX, currentRealPage			OR	AX, (pagePresentMask SHL 8)	;the map and a (2) 3 bit mask.			CALL	ASCheckPage			MOV	ES: [IndexToCurrentVirtualPage], AX ;() for large memory machines.			INC	IndexToCurrentVirtualPage	;Point to the next virtual			INC	IndexToCurrentVirtualPage	;page and also to the next			INC	currentRealPage			;real page.			INC	currentVirtualPage			INC	CS: countRealPages			LOOP	MapIORegion			POP	CX			POP	currentRealPage			;We had saved this page.KeepMapping:		MOV	AX, currentRealPage		;into the VMM and mask them			CALL	ZeroPage			OR	AX, (pagePresentMask SHL 8)	;the map and a (2) 3 bit mask.			CALL	ASCheckPage			MOV	ES: [IndexToCurrentVirtualPage], AX ;() for large memory machines.			INC	IndexToCurrentVirtualPage	;Byte swap was for mesa!			INC	IndexToCurrentVirtualPage	;Point to the next virtual			JNZ	StayInCurrent64KbBank		;page and also to the next			MOV	AX, ES				;real page. Don't forget to			ADD	AX, crossover64KbBank		;test for end of real memory.			MOV	ES, AXStayInCurrent64KbBank:			MOV	CS: lastRealPage, currentRealPage			CMP	CS: firstRealPage, -1			JNE	GoToNextPage			MOV	CS: firstRealPage, currentRealPage			JMP	GoToNextPageIsVMSetUpDone:		CMP	pagesPerBank, numberOfPagesIn256KbBank			JE	VMSetUpDone			MOV	currentRealPage, numberOfPagesInOneMb			MOV	DX, CS: expansionMemDesc			MOV	pagesPerBank, numberOfPagesIn256KbBank			JMP	CheckIfDone;-----------------------VMSetUpDone:		MOV	AX, IOPELocalRAM			MOV	ES, AX			ASSUME	ES:IOPELocalRAM			MOV	AX, CS: firstRealPage			MOV	firstRealPageInVM, AX			MOV	AX, CS: lastRealPage			MOV	lastRealPageInVM, AX			MOV	AX, CS: countRealPages			MOV	countRealPagesInVM, AX			IN	AX, machineIDPort		;the following MDS-relief			AND	AX, machineIDMask		; stuff is for Daybreak only.			CMP	AX, Daisy			JE	InitializeDaisyGermVMInitializeDaybreakGermVM:			;(For MDS relief, we first load a one-page GFT into			;the page before the germ. GermInit will move it later.)			MOV	WORD PTR loaderVirtualMemoryLocation[0], loaderVirtualPage			JMP	VMSetUpDoneContinuedInitializeDaisyGermVM:			MOV	WORD PTR loaderVirtualMemoryLocation[0], germVirtualPageVMSetUpDoneContinued:			MOV	WORD PTR loaderVirtualMemoryLocation[2], (mesaLogicalPageOpieAddress SHL 8)								;A virtual address								;has the page value appearing in								;the low sixteen bits of the								;address. Here we forward the								;Germ's virtual address.			MOV	ES, IOROpieSegmentAddress			ASSUME	ES:OpieIOR			POP	mesaPageMapOffset			POP	mesaPageMapSegment			RETMesaVM			ENDP			ASSUME	ES:NOTHING;--------------------------------------------------------------------------------;This zeros out the page of real memory pointed to by AX.;This proc is used to initialize all non-special memory; (non-display-bitmap/non-VMM/non-IOR).  This is needed to make sure all memory that; will be used by Pilot later on has been pre-touched, to ensure that the parity; bit of all non-special memory is inited to show no parity errors.  IE, this code; prevents parity errors on these pages if they are ever read-accessed before they; are written.ZeroPage:		PUSHA			PUSH	ES			MOV	DX, AX			MOV	CX, (extendedBusPageOpieAddress SHL 8)			%EstablishIOPAccess(generalMapRegister,CX-DX)			MOV	CX, pageSizeInWords			XOR	AX, AX			CLD			REP	STOSW			POP	ES			POPA			RET;--------------------------------------------------------------------------------;This adapts the page number in AX about to be mapped to the Daisy A-S; interface **if applicable**.;IF the machine is a Daisy, AND the machine has more than one AChip,; AND the page address is within the first two megabytes of real memory,; THEN the rules of the Achip-Schip interface apply.;If applicable, then if the page address is in the first meg then add 1M to it; else if the page is in the second meg of address space then subtract 1M from it.;This accomodation to the AS interface is necessary to make the pages mapped; in the VMM match the backwards Schip point of view.  The reverse of these reversals; is done in IOPLMap.ConvertAddress in Opie when it reads pages from the VMM.ASCheckPage:		PUSH	ES			PUSH	AX			XOR	AX, AX			MOV	ES, AX			ASSUME	ES:IOPELocalRAM			POP	AX			CMP	ES:aChipCount, 1	;(0=>Daybreak)			JBE	ASCheckPageDone		;it's a multichip Daisy!			;add 1Mb if real addr in first meg.ASTestFirstMeg:		CMP	AX, 7FFH  	;1Meg in pages			JA	ASTestSecondMeg			ADD	AX, 800H			JMP	ASCheckPageDone			;sub 1Mb if real addr in second meg.ASTestSecondMeg:	CMP	AX, 1000H	 ;3Meg in pages			JAE	ASCheckPageDone			SUB	AX, 800HASCheckPageDone:	POP	ES			ASSUME	ES:NOTHING			RET											;--------------------------------------------------------------------------------SearchLowMemory		PROC	NEAR; Figure out what banks are present in the first 1MB; Algorithm:;	Look at first and last page of each bank (128 pages/bank);	See if memory will return value stored;	Check banks 0 - 15;	Return good bank mask in AX			MOV	currentRealPage, numberOfPagesInOneMbStoreLowBank:		SUB	currentRealPage, numberOfPagesIn64KbBank			MOV	DX, currentRealPage			MOV	CX, (extendedBusPageOpieAddress SHL 8)			%EstablishIOPAccess(generalMapRegister,CX-DX)			MOV	AX, currentRealPage			MOV	WORD PTR ES:[DI], AX			MOV	DX, currentRealPage			ADD	DX, numberOfPagesIn64KbBank-1			MOV	CX, (extendedBusPageOpieAddress SHL 8)			%EstablishIOPAccess(generalMapRegister,CX-DX)			MOV	AX, currentRealPage			XOR	AX, 0FFFFH			MOV	WORD PTR ES:[DI], AX			CMP	currentRealPage, 0			JNE	StoreLowBank			MOV	currentRealPage, numberOfPagesInOneMbCheckLowBank:		SHL	SI, 1			SUB	currentRealPage, numberOfPagesIn64KbBank			MOV	DX, currentRealPage			MOV	CX, (extendedBusPageOpieAddress SHL 8)			%EstablishIOPAccess(generalMapRegister,CX-DX)			MOV	AX, currentRealPage			CMP	WORD PTR ES:[DI], AX			JNE	LowBankNotPresent			MOV	DX, currentRealPage			ADD	DX, numberOfPagesIn64KbBank-1			MOV	CX, (extendedBusPageOpieAddress SHL 8)			%EstablishIOPAccess(generalMapRegister,CX-DX)			MOV	AX, currentRealPage			XOR	AX, 0FFFFH			CMP	WORD PTR ES:[DI], AX			JNE	LowBankNotPresentLowBankPresent:		OR	SI, 1LowBankNotPresent:	CMP	currentRealPage, 0			JNE	CheckLowBank			MOV	AX, SI			RETSearchLowMemory		ENDP;-----------------------SearchHighMemory	PROC	NEAR; Figure out what banks are present after the first 1MB; Algorithm:;	Look at first and last page of each bank (512 pages/bank);	See if memory will return value stored;	Stop at first failure or address = 4MB, whichever comes first;	Return bank count in AX			MOV	currentRealPage, numberOfPagesInOneMb			MOV	SI, 0CheckThisHighBank:	MOV	DX, currentRealPage			MOV	CX, (extendedBusPageOpieAddress SHL 8)			%EstablishIOPAccess(generalMapRegister,CX-DX)			MOV	WORD PTR ES:[DI], 0			CMP	WORD PTR ES:[DI], 0			JNE	HighBankNotPresent			MOV	WORD PTR ES:[DI], 0FFFFH			CMP	WORD PTR ES:[DI], 0FFFFH			JNE	HighBankNotPresent			MOV	DX, currentRealPage			ADD	DX, numberOfPagesIn256KbBank-1			MOV	CX, (extendedBusPageOpieAddress SHL 8)			%EstablishIOPAccess(generalMapRegister,CX-DX)			MOV	WORD PTR ES:[DI], 0			CMP	WORD PTR ES:[DI], 0			JNE	HighBankNotPresent			MOV	WORD PTR ES:[DI], 0FFFFH			CMP	WORD PTR ES:[DI], 0FFFFH			JNE	HighBankNotPresent			INC	SI			ADD	currentRealPage, numberOfPagesIn256KbBank			CMP	currentRealPage, hardwareMaxRealPage			JB	CheckThisHighBankHighBankNotPresent:	MOV	AX, SI			RETSearchHighMemory	ENDP;-----------------------IOPEInRAM		ENDS;********************************************************************************			END
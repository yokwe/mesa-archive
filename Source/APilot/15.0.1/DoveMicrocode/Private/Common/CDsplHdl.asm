$MOD186$PAGELENGTH(72)$PAGEWIDTH (136);-------------------------------------------------------------;This code implements part of the display handler.;;Copyright (C) 1986 by Xerox Corporation. All rights reserved.;-- stored as TBD.;-- created on  17-Dec-85 11:15:44;-- This version uses Opie 21;;-- last edited by:;--	MxS	 8-Mar-89 19:00:00	:this code may not execute on Pilot15.0(BootROM size exceeded);--	JAC	27-Jan-87 15:07:07	:shut it up if its a Daisy;--	RRP	26-Feb-86 15:37:56	:Added INCLUDE for RAMEEP, fixed copyright.;--	MW	 6-Jan-86 10:09:07	:Added code to handle case of bad EEProm version.NAME		cmosDisplay;$NOLIST$INCLUDE (IOPDefs.asm)$INCLUDE (HardDefs.asm)$INCLUDE (IOPMacro.asm)$INCLUDE (ROMEEP.asm)$INCLUDE (RAMEEP.asm)$LIST$INCLUDE (DsplDefs.asm)EXTRN  cmosDisplayHandlerID: ABSEXTRN  displayInterrupt: ABSEXTRN  DisplayHandlerID: ABS;DisplayIOR	SEGMENT 	COMMONEXTRN  cursorXCoord :WORDEXTRN  cursorYCoord :WORDEXTRN  borderLow :BYTEEXTRN  borderHigh :BYTEEXTRN  xCoordOffset :WORDEXTRN  yCoordOffset :WORDEXTRN  cursorPositionProc :WORDEXTRN  borderPatternProc :WORDEXTRN  numberBitsPerLine: WORDDisplayIOR	ENDS;IOPEInRAM	SEGMENT	WORD	PUBLIC		ASSUME	CS: IOPEInRAMPUBLIC		cmosDisplayInitcmosDisplayInit	PROC	FAR		JMP	cmosRet		IN	AX, machineIDPort		;If this is a Daisy no need to run		AND	AX, machineIDMask		CMP	AX, Daisy		JE	cmosRet		%ReadEEProm(eePromHardwareBuild,01)	;Read contents of word 13 into AL.		JC	cmosRet				;If carry bit is set --bad version, return.		AND	AL, 00000011B			;Mask out AL bits except b0 and b1.		TEST	AL, 00000010B			;If bit1 is set, then version B2		JZ	cmosRet				;If bit0 is set, version B1 or B0,return.				%Disable (displayInterrupt)			%EstablishHandlerAccess 	(DisplayHandlerID)		MOV	AX, CS		SHL	AX, 4		ADD	AX, OFFSET NewDbreakCursorProc	;In case of Version B2 , put new addresses		ADD	AX, 4000H		MOV	ES:cursorPositionProc, AX	;for new procedures in IO region.		MOV	AX, CS		SHL	AX, 4		ADD	AX, OFFSET NewDbreakBorderProc		ADD	AX, 4000H		MOV	ES:borderPatternProc, AX		%Enable	(displayInterrupt)cmosRet:	RETcmosDisplayInit	ENDP						NewDbreakCursorProc  PROC   NEAR		;Procedure for Daybreak cursor 						;position		ASSUME	DS:DisplayIOR		CALL	NewCursorPositionLimits		CALL	NewXCoordProc	;This leaves the cursor word position in AL and the 								;bit offset in BL		MOV	DX, CursorWordPortDayBreak  ;DX pnts @ CursorWordPortDayBreak		OUT	DX, AL			;Output cursor x word locn.		INC	DX			;DX pnts @ CursorOffsetPortDayBreak		MOV	AX, BX			;Get bit offset into AX		OUT	DX, AL			;Output cursor x bit offset		MOV	BX, cursorYCoord	;Get y coord		ADD	BX, yCoordOffset	;Add necessary offset		MOV	DX, DisplayTypePort    	;Is this cmos hardware or gate array		IN	AL, DX			;If bit1 is 0 it is CMOS		TEST	AL, 00000010B		;test for CMOS or Gate array		JZ	CMOSGateArray:	MOV	AX, BX     		;Bring y coordinate back into AX		MOV	DX, CursorLinePortLowDayBreak ;load DX with the low port for cursor y position		AND	AX, 0000000000111111B	;Clear the High byte of this register		OUT	DX, AL		INC	DX			;Point to the high port for cursor y position		MOV	AX, BX			;Bring the y coordinate back into AX		SAR	AX, 6		OUT	DX, AL		JMP	CursorExitCMOS:		MOV	AX, BX			;Bring y coordinate back into AX		MOV	DX, CursorLinePortLowDayBreak;		AND	AX, 0000000011111111B		OUT	DX, AL		INC	DX		MOV	AX, BX		SAR	AX, 8		OUT	DX, ALCursorExit:	RET			NewDbreakCursorProc  ENDP		ASSUME	DS:NOTHING	NewDbreakBorderProc	PROC   NEAR		;Procedure for Daybreak border 								;pattern		ASSUME	DS:DisplayIOR		MOV	SI, OFFSET borderLow	;SI points @ source values (borderLow)		MOV	CX, 2			;Output two border pattern bytes		MOV	DX, DisplayTypePort	;Determine whether gate aray or cmos		IN	AL, DX			; If bit1 of bL is 0 it is CMOS ddc		TEST	AL, 00000010B		;Test for CMOS or Gate Array		JZ	CMOSBorder		;GABorder:	MOV	DX, BorderPatternLowDayBreak ; If Ga Border Low registerGABorderOut:	MOV	AL, [SI]		;Will have to contain the border low pattern		OUT	DX, AL		INC	DX			;& borderhigh reg.border high pattern		INC	SI		LOOP	GABorderOut		JMP	BorderEndCMOSBorder:	MOV	DX, BorderPatternHighDayBreak ;If CMOS HW:CMOSBorderOut:	MOV	AL, [SI]		OUT	DX, AL			;then border pattern is switched		DEC	DX			;		INC	SI			;Point to next pattern		LOOP	CMOSBorderOut		;BorderEnd:	RETNewDbreakBorderProc	ENDP		ASSUME	DS:NOTHING		NewCursorPositionLimits	PROC	NEAR	;This proc checks to make sure the x coord is within 15 pixels of the border		ASSUME	DS:DisplayIOR		MOV	SI, OFFSET cursorXCoord	;SI points @ x coord		MOV	DI, OFFSET numberBitsPerLine	;DI points @ display width		MOV	CX, 2			;Twice thru loop;Twice:		CMP	[SI], 0FFF1H		;Check cursor position within top and left border bits;						:   0FFF1H = -15 in 2's complement form		JGE	TopLeftOK		;If O.K., go on		MOV	[SI], 0FFF1H		;If too far, reset back to -15TopLeftOK:	MOV	AX, [DI]		;Get max value in AX		CMP	[SI], AX		;Check cursor position within bottom and right border bits		JLE	BottomRightOK		;If O.K., go on		MOV	[SI], AX		;If too far, reset backBottomRightOK:	ADD	DI, 2			;DI points @ display height		ADD	SI, 2			;SI points @ y coord		LOOP	Twice 		RETNewCursorPositionLimits	ENDP		ASSUME	DS:NOTHING		NewXCoordProc		PROC	NEAR		;This proc converts x coord from pixels to a word ;This leaves the cursor word position in AL and the bit offset in BL		ASSUME	DS:DisplayIOR		MOV	AX, cursorXCoord	;Get x coord in AX		ADD	AX, xCoordOffset	;Add necessary offset		MOV	BX, AX			;Save x coord + offset		SAR	AX, 4			;Get word locn in AL		AND	BX, 0000000000001111B	;Get word offset in BL		RETNewXCoordProc	ENDP		ASSUME	DS:NOTHING							IOPEInRAM	ENDS;************		END
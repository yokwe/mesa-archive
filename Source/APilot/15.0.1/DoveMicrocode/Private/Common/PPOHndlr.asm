$MOD186			 $PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1985, 1986 by Xerox Corporation. All rights reserved.;;-- stored as [BamBam:Osbu North]<WMicro>Dove>PPOHndlr.asm;-- created on  3-Jul-86 15:09:58;;-- Last edited by:;	JMA		 17-Dec-87 11:18:32	:fixed WaitForTime comments;--	JMA		 29-Jun-87 14:05:40	:removed timeout in AttnDriven Proc;--	JMA		  6-Jan-87 10:36:30	:;;;==========================  Parallel Port Option HANDLER  ==================	NAME	PPOHndlr		;Parallel Port Option (PPO) and					;  Laser Printing Option (LPO) Handler	;==========================  INCLUDE  DECLARATIONS  ========================== $NOLIST$INCLUDE		(IOPDefs.asm)	;$INCLUDE		(HardDefs.asm)	;$INCLUDE		(IOPMacro.asm)	;$INCLUDE		(QueDefs.asm)	;$INCLUDE		(PPOIOFce.asm)	;PPO IO Face $INCLUDE		(PPOHdFce.asm)	;Contains PPO constants$INCLUDE		(QueMacro.asm)	;$LIST				EXTRN DMA1@ExtraInterrupt :ABS		;Intrp from DMA Channel 1 to signal end of DMA transferEXTRN PPOHandlerID 	  :ABS		;;			* WARNING! * WARNING! * WARNING!;;ASSEMBLER INVOCATION LINE MUST INCLUDE "MACRO(50)" TO SUCCESSFULLY ASSEMBLE THIS SOURCE FILE!;==========================  PPO  HANDLER  MACROS  ===============================%*DEFINE	( InputWord ( WordPort, WordName ) )(			MOV	DX, %WordPort			IN	AX, DX			MOV	%WordName, AX)%*DEFINE	( OutputWord ( WordPort, WordName ) )(			MOV	DX, %WordPort			MOV	AX, %WordName			OUT	DX, AX);==========================  STACK  SEGMENT  ====================================PPOSTK			SEGMENT	COMMON			ASSUME SS:PPOSTK			EXTRN  PPOMainStack 		:WORD		;EXTRN  PPOIntrpStack		:WORD		;for PPO interruptEXTRN  PPOInServiceStack	:WORD		;for the port taskPPOSTK	 		ENDS;==========================  DATA  SEGMENT  ====================================PPOIOR			SEGMENT	COMMON			ASSUME DS:PPOIOR;---- EXTRNs for PPO handler;  PPO FCB	-- contains the Task Context Block and other device related valuesEXTRN	PPOFCB			:WORDEXTRN   PPOMainTaskTcb		:TaskContextBlockEXTRN   PPOIntrpTaskTcb		:TaskContextBlockEXTRN	PPOInServiceTaskTcb	:TaskContextBlockEXTRN   PPOClientCondition	:ClientConditionEXTRN   PPOWorkFromClientCond	:ConditionEXTRN   PPOInServiceWorkCond	:ConditionEXTRN   PPOAttnCond		:ConditionEXTRN   PPOEndOfScanCond	:ConditionEXTRN   PPOWorkFromClientMask	:WORDEXTRN 	PPOLockMask		:WORDEXTRN 	PPOIntrpMask		:WORDEXTRN 	PPOInterrupt		:WORDEXTRN 	PPOIntrpSelectRegrVal	:WORDEXTRN   PPOEEPROMInfo		:WORDEXTRN	PPOSpareWord		:WORDEXTRN 	PPODiagTestPatrn	:WORDEXTRN	PPODiagRetrnPatrn	:WORDEXTRN 	PPODiagRetrnLoByte	:BYTEEXTRN 	PPODiagRetrnHiByte	:BYTEEXTRN   CurrentDCBPtr		:WORDEXTRN   PPODCBPtr		:WORDEXTRN   PPOBoardStatus		:WORDEXTRN   PPOHandlerStatus	:WORDEXTRN   PPOCnfgRegrImage	:WORDEXTRN   PPOCmdRegrImage		:WORDEXTRN   Port0DCB		:PPODCB	EXTRN	Port0CommandList	:WORDEXTRN 	Port0TransferQue	:QueueBlockEXTRN 	Port0CnfgRegrVal	:WORDEXTRN 	Port0CmdRegrVal		:WORDEXTRN 	Port0Status		:WORDEXTRN   port0DCBLocation	:WORDEXTRN   port0IntrpCnt		:BYTEEXTRN   Port0RqstQueCleanup	:BYTEEXTRN   Port0SpareByte0		:BYTEEXTRN   Port0SpareByte1		:BYTEEXTRN   Port1DCB		:PPODCBEXTRN	Port1CommandList	:WORDEXTRN 	Port1TransferQue	:QueueBlockEXTRN 	Port1CnfgRegrVal	:WORDEXTRN 	Port1CmdRegrVal		:WORDEXTRN 	Port1Status		:WORDEXTRN   Port1DCBLocation	:WORDEXTRN   Port1IntrpCnt		:BYTEEXTRN   Port1RqstQueCleanup	:BYTEEXTRN   Port1SpareByte0		:BYTEEXTRN   Port1SpareByte1		:BYTEEXTRN 	PPODebug		:WORDEXTRN	badPPOIntrpCnt		:BYTEEXTRN	badPPODMA1IntrpCnt	:BYTEEXTRN 	ppoDebugByte0		:BYTEEXTRN 	ppoDebugByte1		:BYTEEXTRN 	ppoDebugWord0		:WORDPPOIOR			ENDS;==========================  CODE  SEGMENT  ====================================IOPEInRAM       SEGMENT	PUBLIC			;codes reside in RAM                ASSUME  CS:IOPEInRAM		ASSUME	DS:NOTHING		;-------------------------  CONSTANTS  DECLARATIONS  ---------------------------;See PPOHDFCE.ASM and PPOIOFCE.ASM;-------------------------  PUBLIC DECLARATION  ---------------------------------PUBLIC		PPOInitPUBLIC		BadPPOIntrpPUBLIC		BadPPODMA1Intrp;-------------------------  LOCAL  VARIABLES  ---------------------------localAttnDetect 	DW	FALSE	;Attention detectedlocalEndOfScanDetect	DW	FALSE	;End Of Scan line detected;========================== PPO HANDLER  =====================================;*******************************************************************************;*                                 *;*        PPOHandlerInit           *;*                                 *;***********************************;This section of the handler will initialize the three tasks of the handler;NOTE: This handler assumes that:;	1) its IORegion has been initialized to all '0's;	2) that it will be called only if Opie has determined, through EEPROM, that the;	   Laser Printing Option or Parallel Port Option has been recognized.PPOInit  	PROC    FAR		PUSH	AX		%EstablishHandlerAccess (PPOHandlerID)			;allow access to PPO IORegion segment		ASSUME	ES:PPOIOR					;Use ES as base segment		POP	AX			MOV	PPOEEPROMInfo, AX				;save option-specific data		MOV	PPOIntrpMask, DX				;save option intrp mask				%GetOptionsInterrupt (PPOIntrpMask, 1)			;get interrupt line assigment		MOV	PPOInterrupt, BX				;save interrupt vector assignment		MOV	PPOIntrpSelectRegrVal, AX			;save intrp select regr value		                %InitializeTask (PPOHandlerID, OFFSET PPOMainTaskTcb, PPOMainTask, OFFSET PPOMainStack)                %InitializeTask (PPOHandlerID, OFFSET PPOIntrpTaskTcb, PPOIntrpTask, OFFSET PPOIntrpStack)		%InitializeTask (PPOHandlerID, OFFSET PPOInServiceTaskTcb, PPOInServiceTask, OFFSET PPOInServiceStack)		RETPPOInit  	ENDP		ASSUME  DS:PPOIOR					;set data segment to PPO IORegion		ASSUME	ES:NOTHING					;;****************************************************************************************;		S U P P O R T	R O U T I N E S						*;****************************************************************************************;**************************************;*                                    *;*      UPDATE STAT AND UPNOTIFY      *;*                                    *;**************************************; This Proc's functions are:;    1) To read and save current Port and Board Status (update);    2) To clear the command bit of the handlers command word using the mask passed in CX;    3) To perform the Up Notification;;BX - contains DCB offset AND also points to commandList word of the DCB;CX - contains mask to be usedUpdateStatAndUpNotify	PROC		MOV	BX, CurrentDCBPtr				;get current DCB ptr									;also points to commandList WORD		%OutputWord (PPOConfigRegr, [BX].CnfgRegrVal)		;make sure we're reading from the 		MOV	PPOCnfgRegrImage, AX				;current port;  also save the image		%InputWord (PPOPortStatusRegr, [BX].PortStatus)		%InputWord (PPOStatusRegr, PPOBoardStatus)		;update ALL status				%MesaLockedOut(AND,BX,CX,PPOLockMask)			;clear command bit using locking		%NotifyClientCondition (PPOClientCondition)		RETUpdateStatAndUpNotify	ENDP						;********************************;*				*;* CALCULATE BYTES TRANSFERRED  *;*				*;********************************;  This proc calculates the number of successful bytes transferred, as seen by the DMA channel;  ES:[DI] - contains pointer to IOCB		CalcBytesXfered	PROC		MOV	DX, i186DMA1TransferCount		;		IN	AX, DX					;load # of bytes/words remaining								;  to be transferred by DMA1		MOV	CX, ES:[DI].dma1TransferCnt		;load # of bytes/words suppose to xfer		SUB	CX, AX					; # of data transferred = CX-AX				TEST	ES:[DI].dma1CntrlWrdVal, DMAByteXfer	;		JZ	InBytes					;check if it was a byte transfer		SHL	CX, 1					;converted to bytes if not alreadyInBytes:	ADD	ES:[DI].bytesTransferred, CX		;save # of bytes xferred		RET		CalcBytesXfered	ENDP;**************************************;*                                    *;*  PPO CONTROLLER AND DEVICE RESET   *;*                                    *;**************************************; This PROC performs controller and device reset.; In doing so, this proc performs the following:;	1) IF a tranfer is in progress (also means PPO has control of the DMA1 channel) :;		- Stop DMA channel 1;		- turn off LPO/PPO board;		- set current IOCB to "aborted";		- record total bytes transferred;		- Jam/Restart transfer task;	2) performs controller reset;	3) performs device reset, if needed;	4) sets Command Regr and Config Regr to default values;	5) updates all other status;	6) performs an up-nofication	PPOReset	PROC		MOV	BX, CurrentDCBPtr				;load current DCB pointer		OR	PPOHandlerStatus, PPOResetCmd			;indicate service of reset request		MOV	AX, PPOCmdRegrImage		AND	AX, NOT	OptionOnBit				;disable option board		MOV	DX, PPOCommandRegr		OUT	DX, AX		MOV	PPOCmdRegrImage, AX								TEST	PPOHandlerStatus, PPOTransferCmd		;checking to see if a transfer is in progress		JZ	NoXferInPrgrss					;Stop DMA only if needed, also									;  Jam and Restart the transfer task only if											;  a transfer command is being serviced		%OutputWord (i186DMA1ControlWord, DMA1DefaultCntrlWrd)	;stop any DMA1 activity, if any									;  just load DMA1 control word									;  with a default value				%EstablishIOPAccess (generalMapRegister, [BX].TransferQue.queueNext)									;make IOCB accessible 		CALL	CalcBytesXfered					;calc bytes transferred		JamRestartTask:	PUSH	ES		PUSHA		%Restart (PPOHandlerID, OFFSET PPOInServiceTaskTcb, PPOInServiceTask, OFFSET PPOInServiceStack)		POPA							;JamRestart, task was still transferring		POP	ES		RestartBypass:  MOV	ES:[DI].opStatus, iocbAborted			;set IOCB status to aborted		MOV	[BX].RqstQueCleanup, TRUE			;request head to cleanup the transfer queue		%'ReleaseDMAChannel					;release DMA Channel1NoXferInPrgrss:	PUSH	BX		%Disable (PPOInterrupt)					;Disable option while we reset board		POP	BX						;  This is the SW fix for a LPO HW									;  problem: reset causes an intrp!		%OutputWord (PPOConfigRegr, [BX].CnfgRegrVal)		;set cnfg value 		MOV	PPOCnfgRegrImage, AX				;save the image									AND	AX, DisableDMABitMask AND DisableIntrpBitMask	;disable interrupt and DMA request on PPO		OUT	DX, AX						; DX = PPOConfigRegr		MOV	PPOCnfgRegrImage, AX				;save image				%OutputWord (PPOCommandRegr, [BX].CmdRegrVal)		;reset board using given CmdRegrVal		MOV	PPOCmdRegrImage, AX				;save image		PUSHA							;allow reset signal to propagate properly		POPA							;  using SW delay		%OutputWord (PPOCommandRegr, DefaultCmdRegrVal)		;		MOV	PPOCmdRegrImage, AX		%OutputWord (PPOConfigRegr, [BX].CnfgRegrVal)		;set cnfg value 		MOV	PPOCnfgRegrImage, AX				;save the image				%OutputWord (PPOIntrpSelectRegr, PPOIntrpSelectRegrVal)	;reset clears Intrp Select Regr in LPO,									;  so reload regr value		%Enable (PPOInterrupt)					;enable option and continue...				MOV	CX, ClrAllCmdMask				;Clear ALL commands pending									;load clear-all mask		CALL	UpdateStatAndUpNotify				;update and upnotify		AND	PPOHandlerStatus, IdleStateMask 		;Set status reset-serviced 		RETPPOReset	ENDP;**************************************;*                                    *;*      UPDATE STATUS NOW 	      *;*                                    *;**************************************; This Proc responds to the on-demand update of the port and board status.; UpdateStatus command bit clearing and up notification is performedUpdateStatusNow	PROC		OR	PPOHandlerStatus, PPOUpdateStatCmd		;Set status update-begin-serviced;		IN	AL, 80H;		TEST	AL, machineIDMask2;		JNZ	NotReadPg;		MOV	DX, PPOIntrpSelectRegr;		IN	AX, DX;		MOV	PPOSpareWord, AXNotReadPg:	MOV	CX, ClrUpdateCmdMask				;load clear-command-bit mask		CALL	UpdateStatAndUpNotify				;update and upnotify		AND	PPOHandlerStatus, NOT PPOUpdateStatCmd		;Set status update-serviced		RET							;UpdateStatusNow	ENDP;**************************************;*                                    *;*      SET UP DMA1 PTR		      *;*                                    *;**************************************; This section performs the mapping from Virtual to IOP logical Memory.; The memory and IO addreses are then loaded into the DMA.; ES:[DI]  points to the IOCB SetUpDMA1Ptr	PROC		PUSH	ES						;save pointer to IOCB		PUSH	DI						%EstablishIOPAccess (optionDMAMapRegister, ES:[DI].dma1MemSrcOrDst)									;map virtual to IOP logical address									;  and make it accessible to us										MOV	AX, ES						;load base segment value, ready for		SHR	AX, 12						;  effective address calc.  Get high 4 bits		MOV	SI, AX						;save for debug						MOV	AX, ES						;ready to calc. base plus offset		SHL	AX, 4						;  get low 16 bits which will be		OR	AX, DI						;  ORed with the offset to produce		MOV	BP, AX						;save for debug				TEST	PPOCnfgRegrImage, InBit				;Check if Dest is Mem or IO using Out'/In bit		JZ	DestIO						;If dest is NOT memory, then it MUST be IO			DestMem:	%OutputWord (i186DMA1LowDestPtr, BP)			;Source IS IO		%OutputWord (i186DMA1HighDestPtr, SI)			;		%OutputWord (i186DMA1LowSourcePtr, PPODataRegr)		;		%OutputWord (i186DMA1HighSourcePtr, 0)			;load PPO Data Regr as source IO		JMP	SHORT ExitSetup			DestIO:		%OutputWord (i186DMA1LowSourcePtr, BP)			;Source is Memory		%OutputWord (i186DMA1HighSourcePtr, SI)			;		%OutputWord (i186DMA1LowDestPtr, PPODataRegr)		;load PPO Data Regr as destination IO		%OutputWord (i186DMA1HighDestPtr, 0)			;		ExitSetup:	POP	DI						;restore pointe to IOCB		POP	ES		MOV	ES:[DI].iocbSpareWord0, SI			;save buffer location		MOV	ES:[DI].iocbSpareWord1, BP			;   for debug				RETSetUpDMA1Ptr	ENDP;********************************;*				*;*    Set And Output		*;*				*;********************************;This procedure will program the DMA channel and activate it to output data.;ES:[DI] points to the IOCB;;NOTE: It is possible that an activated ScanLineSync signal will turn off the PPO board when;      it is in Port 1, printer setting. This is a hardware bug.  ScanLineSync should have been ;      qualified with Out'/In or Printer'/Scanner signal instead of P0'/P1 signal. SetAndOutput	PROC		%OutputWord (i186DMA1TransferCount, ES:[DI].dma1TransferCnt)		%OutputWord (PPOCommandRegr, ES:[DI].iocbCmdRegrVal)	;option board ON		MOV	PPOCmdRegrImage, AX				;save the image		%OutputWord (i186DMA1ControlWord, ES:[DI].dma1CntrlWrdVal) ;activate DMA1				PUSH	ES		PUSH	DISetNRunWait:	MOV	DX, i186DMA1TransferCount		;check if xfer has been completed		IN	AX, DX					;no need to WAIT if transfer is		CMP	AX, 0					; done already		JE	ChkDMARqstBit				; continue on				%WaitForInterrupt (2)				;Wait for DMA1 transfer to finish								;  give it some time out value		JNC	ChkDMARqstBit				;IF NOT timed-out (carry clr) THEN								;TIMED-OUT at this pointTimedOutHere:	%InputWord (PPOStatusRegr, PPOBoardStatus)	;read board status		TEST	AX, SMMaskBits				;check to see if board is off, because		JNZ	SetNRunWait				; ScanLineSync can turn off board on								; port 1 output (SW WORKAROUND)								;so... turn board on again.		MOV	DX, PPOCommandRegr			;active EOS disables the board		MOV	AX, PPOCmdRegrImage			;automatically if P1 port is selected		AND	AX, NOT OptionOnBit			;		OUT	DX, AX					;		MOV	AX, PPOCmdRegrImage			;		OUT	DX, AX					;					JMP	SetNRunWait				;		ChkDMARqstBit:	%InputWord (PPOStatusRegr, PPOBoardStatus)	;AX contains board status								;this section makes sure we can								;  safely turn off the board w/o								;  destroying LAST valid data		TEST	AX, PPODMARequestBit			;check for another DMA Request		JNZ	OKToTurnOff				; request again means ok to turn off		%WaitForTime (1)				; wait a short time		JMP	ChkDMARqstBit				;shouldn't have to loop too many timesOKToTurnOff:	MOV	DX, PPOCommandRegr			;turn board off		MOV	AX, PPOCmdRegrImage						AND	AX, NOT OptionOnBit		OUT	DX, AX		MOV	PPOCmdRegrImage, AX;		AND	AX, 0FFFEH				;;;;;;		OUT	DX, AX;		PUSHA;		POPA;		MOV	AX, PPOCmdRegrImage;		OUT	DX, AX					;;;;;				POP	DI		POP	ES		CALL 	CalcBytesXfered				;calc bytes transferred		RETSetAndOutput	ENDP;********************************;*				*;*    Set And Input 		*;*				*;********************************;This procedure will program the DMA channel and activate it to input data.;It handles time-outs in order to check for the ScanLineSync signal on a DATA transfer IN;ES:[DI] points to the IOCBSetAndInput	PROC		PUSH	ES		PUSHA		%OutputWord (i186DMA1TransferCount, ES:[DI].dma1TransferCnt)		%OutputWord (PPOCommandRegr, ES:[DI].iocbCmdRegrVal)	;option board ON		MOV	PPOCmdRegrImage, AX				;save the image		%OutputWord (i186DMA1ControlWord, ES:[DI].dma1CntrlWrdVal) ;activate DMA1		WaitForDoneIn:	%WaitForCondition (OFFSET PPOEndOfScanCond,2)	;Wait for EOS or 2S								;		JNC	ChkForEOS				;set carry bit means timed-outChkDataDone:	MOV	DX, i186DMA1TransferCount		;check if xfer has been completed		IN	AX, DX					;		CMP	AX, 0					; done already		JE	RealOff					; data leftover, continue on		JMP	WaitForDoneIn				;								ChkForEOS:	CMP	localEndOfScanDetect, TRUE		;check if EOS was indeed detected		JNE	WaitForDoneIn				;if detected then board is OFFRealOff:	MOV	DX, PPOCommandRegr			;turn board off		MOV	AX, PPOCmdRegrImage						AND	AX, NOT OptionOnBit		OUT	DX, AX		MOV	PPOCmdRegrImage, AX				POPA			POP	ES		CALL 	CalcBytesXfered				;calc bytes transferred		RET	SetAndInput	ENDP;********************************;*				*;*    STROBE IN ONE BYTE	*;*				*;********************************;; This proc strobes into the PPO Data register one and only one byte of data; ES:[DI] points to the IOCBStrobeInOneByte PROC		%InputWord (PPOStatusRegr, PPOBoardStatus)		;		TEST	AX, DataRegrEmptyBit				;If not empty then...		JZ	XitStrobeInOne					;...byte is in already				%OutputWord (PPOCommandRegr, ES:[DI].iocbCmdRegrVal)	;turn the board on		MOV	PPOCmdRegrImage, AXChkDMARqst:	%InputWord (PPOStatusRegr, PPOBoardStatus)		;		TEST	AX, DataRegrEmptyBit				;		JZ	ByteInAlready					;				PUSH	ES						;		PUSH	DI						;WaitForTime mugs CX & DI regr		PUSH	CX						;		%WaitForTime (1)					;IF not ready, wait about 10mS		POP	CX		POP	DI		POP	ES		JMP	ChkDMARqst					;check IF ready this time		ByteInAlready:	%OutputWord (PPOCommandRegr, DefaultCmdRegrVal)		;Turn off the board		MOV	PPOCmdRegrImage, AX		XitStrobeInOne:	RETStrobeInOneByte ENDP		;********************************;*				*;*    INPUT ONE BYTE		*;*				*;********************************; This PROC fetches one byte of data from the Data register; It uses a DMA byte transfer.;;ES:[DI] points to the IOCBInputOneByte	PROC		%InputWord (PPOStatusRegr, PPOBoardStatus)	;		TEST	AX, DataRegrEmptyBit			;If empty then...		JNZ	XitInputOne				;...not byte to read		%OutputWord (i186DMA1TransferCount, 1)		;set for a 1 byte or word transfer		%OutputWord (i186DMA1ControlWord, ES:[DI].dma1CntrlWrdVal);set DMA control word 		OneByteWait:	MOV	DX, i186DMA1TransferCount		;one byte DMA transfer		IN	AX, 0					;should be very, very quick;		CMP	AX, 0					;shouldn't have to WAIT		JZ	NoWait					;at all, normally		PUSH	ES					;		PUSH	DI		PUSH	CX					;WaitForTime mugs CX & DI regr		%WaitForTime (1)				;wait about 10mS before checking again		POP	CX		POP	DI		POP	ES		JC	OneByteWait				;keep waiting if TIMED-OUT (carry set)								;  dest memory will be increment by DMA1NoWait:		INC	ES:[DI].bytesTransferred		;keep count of successful transfersXitInputOne:	RET		InputOneByte	ENDP;********************************;*				*;* Attention  Driven  Transfer	*;*				*;********************************; This proc is used to retrieve control/status data from the scanner.  This transfer is attention-driven; It waits for the attention flag to be activated before it transfers the next available data.;ES:[DI] points to the IOCBAttnDrivenXfer	PROC		MOV	CX, ES:[DI].transferDataSize		;load number of bytes to fetch		ChkAttnRdy:	MOV	BX, CurrentDCBPtr			;point to the current DCB in control		%InputWord (PPOPortStatusRegr, [BX].PortStatus)	;update ALL status and save in IORegion		TEST	AX, Attention				;AX = port status		JZ	PayAttn					;Attn bit = active low		PUSH	ES					;sit here a wait for attention		PUSH	DI		PUSH	CX					;WaitForTime mugs CX & DI regr		%WaitForTime (1)				;wait for time, about 10mS		POP	CX		POP	DI		POP	ES		JMP	ChkAttnRdy				;check for attention againPayAttn:	MOV	localAttnDetect, FALSE			;clear flag first		CALL	StrobeInOneByte				;strobe into data regr one byte of data		CALL	InputOneByte				;input one byte using DMA		LOOP	ChkAttnRdy				;loop until request is complete		RETAttnDrivenXfer	ENDP;**************************************;*                                    *;*      PPO TRANSFER		      *;*                                    *;**************************************; This PROC performs the actual block/byte output.; The steps for an output transfer include:;	1) mapping Virtual Memory to IOP logical memory;	2) load control word, source and destination address and transfer count;		of DMA channel 1 for a transfer;	3) load client selected parameters; set up PPO configuration and command regrs;	4) enable PPODMARequest and PPOGo bits;	5) perform special input data transfer: N-1 transfer + 1 byte transfer;;NOTE: It is assumed that the i186 DMA has advanced the memory pointer already.;		Remapping and reassignment of source and destination addresses are not;		necessary because buffers are page aligned.;;ES:[DI] - points to the current IOCB being serviced		PPOTransfer	PROC		MOV	BX, CurrentDCBPtr			;check for a valid QNext		%EstablishIOPAccess (generalMapRegister, [BX].TransferQue.queueNext)								;make IOCB accessible if QNext not NIL		MOV	ppoDebugWord0, ES			;DEBUG		MOV	WORD PTR ppoDebugByte0, DI		;DEBUG		CMP	ES:[DI].opStatus, iocbPending		;make sure this is the right IOCB		JE	BeginTransfer				;yup, this is it alrightGoBypass:	JMP	XferBypass				;nope, skip it;---------------			BeginTransfer:	%'WaitForDMAChannel				;wait for DMA channel1 to become available				OR	PPOHandlerStatus, PPOTransferCmd	;set transfer cmd in progress		%OutputWord (PPOConfigRegr, ES:[DI].iocbCnfgRegrVal)								;load config regr								;Enable PPODMAEnable bit, but the								;  PPO board is still turned off								;  no DMA transfer request yet		MOV	PPOCnfgRegrImage, AX			; save image		CALL	SetUpDMA1Ptr				;setup and map data buffer for transfer		MOV	ES:[DI].opStatus, iocbInProgress	;set iocb status		TEST	PPOCnfgRegrImage, InBit			;is this a data input or output?		JZ	DirectionIsOut				;		JMP	DirectionIsIn		DirectionIsOut:	MOV	CX, ES:[DI].dma1TransferCnt		;CX is the rest count		MOV	AX, ES:[DI].dma1CntrlWrdVal		TEST	AX, 1		JZ	DataIsByte		MOV	BP, 256		CMP	CX, BP		JNG	OnePageOut				;If greater , then printer		JMP	MultPageOutDataIsByte:	MOV	BP, 512		CMP	CX, BP		JNG	OnePageOut		MOV	ES:[DI].opStatus, iocbAborted		JMP	EndTransfer;!!!!! Following Code is WORD MODE ONLY!!!!!MultPageOut:	TEST	ES:[DI].dma1MemSrcOrDst.OpieAddressA15toA0, 0FFH	;Page boundary? at page start		JNZ	Notboundary		CMP	CX, BP					;Is Last page in Buffer Page Boundary?		JNL	pageBoundary		MOV	ES:[DI].dma1TransferCnt, CX		;Last page count		JMP	OnePageOutpageBoundary:	MOV	ES:[DI].dma1TransferCnt, BP		JMP	OnePageOutNotboundary:	MOV	AX, ES:[DI].dma1MemSrcOrDst.OpieAddressA15toA0		AND	AX, 0FFH		MOV	BX, BP		SUB	BX, AX;;;		TEST	ES:[DI].dma1CntrlWrdVal, 1;;;		JNZ	Notboundary1;;;		SHL	BX, 1Notboundary1:	MOV	ES:[DI].dma1TransferCnt, BXOnePageOut:	PUSH	CX		PUSH	BP		CALL	SetAndOutput				;simple straight-forward DMA output		POP	BP		POP	CX		SUB	CX, ES:[DI].dma1TransferCnt		CMP	CX, 0		JE	TransferDone		MOV	AX, ES:[DI].dma1TransferCnt;;;		SHL	AX, 1					;Here is Byte Count;;;		TEST	ES:[DI].dma1MemSrcOrDst.OpieAddressType, 20H	;word or page opieaddress mask;;;	        JZ	ByteAddress;;;		SHR	AX, 1ByteAddress:	ADD	ES:[DI].dma1MemSrcOrDst.OpieAddressA15toA0, AX		ADC	ES:[DI].dma1MemSrcOrDst.OpieAddressA23toA16, 0;		AND	ES:[DI].dma1MemSrcOrDst.OpieAddressA15toA0, 0FF00H	;Page boundary		PUSH	CX		PUSH	BP		CALL	SetUpDMA1Ptr		POP	BP		POP	CX		JMP	MultPageOut							DirectionIsIn:	MOV	DX, PPODataRegr		IN	AX, DX					;clear data from Data regr, if any				TEST	PPOCnfgRegrImage, ControlBit		;check if input data is of type "control"			JZ	InputData				;		CALL	AttnDrivenXfer				;use special interrupt driver transfer if control		JMP	SHORT TransferDone							InputData:	MOV	localEndOfScanDetect, FALSE		;clear EOS flag		CALL	SetAndInput				;Input data using DMA		CMP	localEndOfScanDetect, TRUE		;was an EOS detected during		JE	GotEOS					;    this IOCB transfer? If yes...		ScnrSpecXfer:	CALL	StrobeInOneByte				;strobe in 1 byte into the data regr		CMP	localEndOfScanDetect, TRUE		;was an EOS detected during strobe-in?		JNE	ScnrSpecXfer2				;JUMP and input last byte if not EOSGotEOS:		MOV	localEndOfScanDetect, FALSE		;clear EOS flag		MOV	ES:[DI].opStatus, iocbEndOfScanLine	;set correct status		MOV	DX, i186DMA1ControlWord			;DMA1 could still be on		MOV	AX, ES:[DI].dma1CntrlWrdVal		;		AND	AX, StopDMABitMask			;stop any DMA1 activity		OUT	DX, AX		JMP	SHORT XferDMARlease			;		ScnrSpecXfer2:	CALL	InputOneByte				;2) 1 byte transfer of last byte		TransferDone:	CMP	ES:[DI].opStatus, iocbInProgress	;make sure this is the right IOCB		JNE	XferDMARlease		MOV	ES:[DI].opStatus, iocbSuccess		;set IOCB to successful transfer		XferDMARlease:	%'ReleaseDMAChannel				;release DMA Channel1;---------------XferBypass:	MOV	BX, CurrentDCBPtr			;load current DCB in control		CMP	BX, OFFSET Port0DCB			;gotta' do this since Advance won't let		JNE	AdvPort1DCB				;   me use a pointer to the TransferQue		AdvPort0DCB:	%AdvanceMesaIOCB (Port0TransferQue.queueNext, nextIOCB, PPOLockMask, mapped)		JMP	SHORT EndTransfer		AdvPort1DCB:	%AdvanceMesaIOCB (Port1TransferQue.queueNext, nextIOCB, PPOLockMask, mapped)EndTransfer:	AND	PPOHandlerStatus, NOT PPOTransferCmd	;clear transfer cmd from handler status		MOV	CX, ClrNoCmdMask			;other transfers MAY STILL BE pending		CALL	UpdateStatAndUpNotify			;...just update and upnotify		RET			PPOTransfer	ENDP		;********************************;*				*;*	PPO Diagnostics 	*;*				*;********************************; This PROC performs PPO Data Regr Loopback test and a LPO Maintenance Regr Loopback test:;   IF option = PPO, a simple write-then-read of the Data Regr, loopback test for the PPO board;   IF option = LPO, a two stage LPO board loopback test: test high byte, then test low bytePPODiagnostics	PROC		OR	PPOHandlerStatus, PPODiagCmd		;Command in Progress		%OutputWord (PPOCommandRegr, DefaultCmdRegrVal)	;turn Option Off		MOV	PPOCmdRegrImage, AX			;save the image		TEST	PPOHandlerStatus, BoardIsPPO		;Determine board type installed		JZ	TestLPO					;		TestPPO:	%OutputWord (PPOConfigRegr, PPODiagCnfgVal0)	;1st, PPO in Maint-Scan-Out mode		MOV	AX, PPODiagCnfgVal			;2nd, PPO in Maint-Scan-In mode		OUT	DX, AX					;a little song and dance to satisfy HW reqr		MOV	PPOCnfgRegrImage, AX			;save image				%OutputWord (PPODataRegr, PPODiagTestPatrn)	;output test pattern		%OutputWord (PPOCommandRegr, DefaultCmdRegrVal OR OptionOnBit);turn Option On		MOV	PPOCmdRegrImage, AX			;save the image				%WaitForTime (10)				;wait at least 50uS, 10mS is good enough		%OutputWord (PPOCommandRegr, DefaultCmdRegrVal)	;turn Option Off		MOV	PPOCmdRegrImage, AX			;save the image		%InputWord (PPODataRegr, PPODiagRetrnPatrn)	;read result		JMP	DiagDone		TestLPO:	%OutputWord (PPOConfigRegr, LPODiagCnfgVal)	;load config value, set Config regr for diag		MOV	PPOCnfgRegrImage, AX			;save image				%OutputWord (PPOCommandRegr, DefaultCmdRegrVal OR OptionOnBit);turn Option On		MOV	PPOCmdRegrImage, AX			;save the image		%OutputWord (PPODataRegr, PPODiagTestPatrn)	;ready to output test pattern								;perform high byte loopback test								;   by doing WORD IO		%WaitForTime (10)				;wait at least 50uS, 10mS is good enough		MOV	DX, PPOMaintenanceRegr			;load PPO Maintenance Regr addrs		IN	AL, DX		MOV	BYTE PTR PPODiagRetrnPatrn+1, AL	;save hi byte		SecondStageDiag:MOV	DX, PPODataRegr				;load PPO Data Regr addrs		MOV	AX, PPODiagTestPatrn			;ready to output test pattern		OUT	DX, AL					;perform lo byte loopback test byte								;   by doing BYTE IO		%WaitForTime (10)				;wait at least 50uS, 10mS is good enough		MOV	DX, PPOMaintenanceRegr			;load PPO Maintenance Regr addrs		IN	AL, DX		       			;read high byte return value		MOV	BYTE PTR PPODiagRetrnPatrn, AL		;save lo byte return value									%OutputWord (PPOCommandRegr, DefaultCmdRegrVal)		MOV	PPOCmdRegrImage, AX			;disable board and save image			DiagDone:	MOV	CX, ClrDiagCmdMask			;load clear-command-bit mask		MOV	PPOCnfgRegrImage, AX			;save image		CALL	UpdateStatAndUpNotify			;Update and upnotify		AND	PPOHandlerStatus, NOT PPODiagCmd	;clear handler status bit						RETPPODiagnostics  ENDP;***********************************;*                                 *;*     OPTION BOARD STATUS         *;*                                 *;***********************************;This proc checks:;	1) which option board is suppose to be installed by reading EEPROM value;	2) if option board supposedly PPO, check if it is installed else assume LPO is installed;	3) and updates Handler Status accordingly OptBoardStat	PROC		CMP	PPOEEPROMInfo, 01			;Identify option board installed	        JNE	OptInstalled				;assume board is installed if LPO		OR	PPOHandlerStatus, BoardIsPPO		;  else, test to make sure PPO								;  is installed if indeed PPO		%InputWord (PPOStatusRegr, PPOBoardStatus)	;update board status								;AX = port status, DX = PPOStatusRegr		MOV	CX, 05H					;Check if PPO board is installed	ChkIfPPOInst:	IN	AX, DX					;check repeatedly		TEST	AX, PPOAlwaysOneBit			;MUST be ONE  		JZ	OptTestExit				;premature exit means PPO board not installed		TEST	AX, PPOAlwaysZeroBit			;MUST be ZERO		JNZ	OptTestExit				;premature exit means PPO board not installed		PUSHA						;some delay		POPA		LOOP	ChkIfPPOInst				;		OptInstalled:	OR	PPOHandlerStatus, PPOBoardInstalled	;set handler status bitOptTestExit:	RETOptBoardStat	ENDP;****************************************************************************************;		T A S K		R O U T I N E S						*;****************************************************************************************;;********************************************************************************;*				*;*	PPO Interrupt Task	*;*				*;********************************; This task handles ALL interrupts associated with ParallelPort Option board.; Action taken:;	1) Identify source of interrupt;	2) Update Status and Up-Notify;	3) Clear LPO/PPO interrupt bitPPOIntrpTask:	%ThisTaskServices (PPOInterrupt, BadPPOIntrp)		%OutputWord (PPOIntrpSelectRegr, PPOIntrpSelectRegrVal)								;load PPO Select Regr		MOV	port0IntrpCnt, 0			;init intrp counters		MOV	port1IntrpCnt, 0			;		MOV 	badPPOIntrpCnt, 0			;		MOV	localAttnDetect, FALSE			;... and intrp detect		MOV	localEndOfScanDetect, FALSE		; flags		MOV	PPOSpareWord, 0		MOV	Port0SpareByte0, 0;		MOV	Port0SpareByte1, 00FH;		MOV	DX, machineIDPort;		IN	AX, DX;		TEST	AX, machineIDMask2			;Dahlia or Daybreak2 ?;		JNZ	GetReadyToWait		MOV	Port0SpareByte1, 0FFH;		MOV	PPOSpareWord, 0F0F0HGetReadyToWait:	%DisableInterruptsTillNextWait			;disable all intrps till ready		%Enable (PPOInterrupt)				;enable options intrp into slave i8259		WaitForPPOIntrp:%WaitForInterrupt (noTimeout)			;wait for an interrupt						OnPPOIntrp:     MOV	BX, CurrentDCBPtr			;point to the current DCB in control		INC	[BX].IntrpCnt				;count intrps		%InputWord (PPOStatusRegr, PPOBoardStatus)		%InputWord (PPOPortStatusRegr, [BX].PortStatus)	;update ALL status and save in IORegion								;AX = port status		TEST	PPOCnfgRegrImage, ScanModeBit		;Check which device was being serviced		JZ	IntrpHandCont				;If printter then just update & upnotify		IsThisAttn:	TEST	AX, Attention				;check Attn line, active low		JNZ	IsThisEOS				;something else caused the interrupt, maybe..MaybeAttn:	MOV	localAttnDetect, TRUE			;set flag TRUE if Attention detected		;%NotifyCondition (OFFSET PPOAttnCond)		;notify waiting task		IsThisEOS:	TEST	PPOCmdRegrImage, OptionOnBit		;check if option board is ON ACCORDING to cmd regr		JZ	IntrpHandCont				;IF not ON then not EOS, else verify if board is 		TEST	PPOBoardStatus, SMMaskBits		;  REALLY on using board status		JNZ	IntrpHandCont				;IF OFF, then autoOFF was enforced and EOS		MaybeEOS:	MOV	localEndOfScanDetect, TRUE    		;set local EOS-detected flag		%NotifyCondition (OFFSET PPOEndOfScanCond)	;notify waiting taskIntrpHandCont:	;IN	AL, 80H		;TEST	AL, machineIDMask2		;JNZ	HardInt					;Machine is Daybreak		;TEST	[BX].PortStatus, FaultBit		;JZ	WaitForMesa2;WaitForMesa1:	TEST	[BX].DCBSpareByte1, 0FFH		;Fault happened		;JNZ	WaitForMesa1		MOV	AX, [BX].PortStatus		AND	AX, 0002H				;If Power on Reset, PowerOff		JZ	HardInt		MOV	AX, [BX].PortStatus		AND	AX, 0080H				;Printer(0) or Scanner(1) ?		JNZ	HardInt					;Scanner		;MOV	DX, PPOCommandRegr		;IN	AL, DX		;MOV	[BX].DCBSpareByte1, AL		;JMP	HardInt		;TEST	Port0SpareByte1, 0FFH		MOV	Al, Port0SpareByte1		CMP	Al, 0FFH		JE	HardInt					;Banshee		MOV	CX, 0FFFFHWaitForMesa2:	CMP	Al, 055H		JNE	WaitForMesa3		LOOP	WaitForMesa2		JMP	HardIntWaitForMesa3:	MOV	DX, PPOCommandRegr		IN	AL, DX		MOV	Port0SpareByte0, AL		MOV	Port0SpareByte1, 055HHardInt:	%NotifyClientCondition (PPOClientCondition)	;upnotifyClrIntrpHere:	%Disable (PPOInterrupt)				;		MOV	AX, PPOCmdRegrImage			;get image of current values in Command Regr		AND	AX, NOT NotClearIntrpBit		;set Clear Intrp Bit to active (lo)		MOV	DX, PPOCommandRegr			;load Command regr. addrs.		OUT	DX, AX					;do the interrupt-bit reset		MOV	AX, PPOCmdRegrImage			;restore Command regr. contents, clr intrp bit		OUT	DX, AX					;  should be inactive				JMP	GetReadyToWait				;read for next PPO intrp with intrp still disabled;********************************************************************************;*				*;*    PPO In Service  Task	*;*				*;********************************; this procs functions are:;	- to perform transfer operations as long as there are IOCBs in the transfer queues;	- to allow for alternating port operations-- not just transfers-- if both ports ;		 have operations (reset, transfer, and update) pending;	- test for valid IOCB pointers; PPOInServiceTask:		%ThisTaskServices (DMA1@ExtraInterrupt, BadPPODMA1Intrp)		%Enable (DMA1@ExtraInterrupt)				;enable DMA1 done interrupt		NoWorkToDo:	AND	PPOHandlerStatus, IdleStateMask			;set status to IDLE			WaitForXferWork:%WaitForCondition (OFFSET PPOInServiceWorkCond,noTimeout)									;Wait for some work to doNewWorkToDo:	MOV	BX, CurrentDCBPtr		TEST	[BX].CommandList, (CmdPending OR PPOAllCmds)	;check again to make sure there is work		JNZ	WorkToDo					;word to do, service current DCB		JMP	TaskContinue					;Nope, there IS NO work to do...check									;     the other port just in caseWorkToDo:	OR	PPOHandlerStatus, (HandlerBusy OR PPOBoardBusy)	;indicate that handler and board are busy		ContInServTask:	%OutputWord (PPOConfigRegr, [BX].CnfgRegrVal)		;continue service		MOV	PPOCnfgRegrImage, AX				;save image		%InputWord (PPOPortStatusRegr, [BX].PortStatus)		;update ALL status and save in IORegion		%InputWord (PPOStatusRegr, PPOBoardStatus)		MOV	AX, [BX].CommandList				;get commandListDoReset:	TEST	AX, PPOResetCmd					;Is command reset?		JZ	DoTransfer					;IF not then go to...		CALL	PPOReset					;ELSE perform reset		JMP	SHORT AllowSystem				;check for cmds pending, not likely!DoTransfer:	TEST	AX, PPOTransferCmd				;Is command transfer?		JZ	DoUpdate					;IF not then go to...				%JumpIfMesaIOCBNextNil ([BX].TransferQue.queueNext, ClearXferCmd)GoTransfer:	CALL	PPOTransfer 					;Work for Transfer Task									;PROC doesn't return until		JMP	SHORT DoUpdate					;  one transfer command has concludedClearXferCmd:	MOV	CX, ClrTransferCmdMask				;clear transfer cmd bit in the cmd list		CALL	UpdateStatAndUpNotify				;update and upnotify		DoUpdate:	MOV	BX, CurrentDCBPtr				;load current DCB in control		TEST	[BX].CommandList, PPOUpdateStatCmd		;Is command Update Status ?		JZ	IsItADiag		CALL	UpdateStatusNow					;update Status NOW		IsItADiag:	MOV	BX, CurrentDCBPtr				;load current DCB in control		TEST	[BX].CommandList, PPODiagCmd			;Is command diagnostics?		JZ	AllowSystem					;If not diagnostics then...jump		CALL	PPODiagnostics					;Call diagnostic routine					AllowSystem:	%WaitForSystem						;let other system tasks runTaskContinue:	CMP	CurrentDCBPtr, OFFSET Port0DCB			;Is P0 currently in service		JE	ChkP1DCB					;Yes, so now give the P1 a chance to run		ChkP0DCB:	MOV	BX, OFFSET Port0DCB				;checking command pending and all commands		TEST	[BX].CommandList, (CmdPending OR PPOAllCmds)	;in P0 commandList		JNZ	PortSwitch					;pend cmnd(s) detected, proceed w/ switch		JMP	SHORT PPOInService				;no commands pending here, check current DCB		ChkP1DCB:	MOV	BX, OFFSET Port1DCB				;checking command pending and all commands		TEST	[BX].CommandList, (CmdPending OR PPOAllCmds)	;in P1 commandList		JNZ	PortSwitch					;pend cmnd(s) detected, proceed w/ switch		PPOInService:	MOV	BX, CurrentDCBPtr				;load current DCB in control		TEST	[BX].CommandList, (CmdPending OR PPOAllCmds)	;Is there work to do		JNZ	MoreWorkToDo					;Yes, go back and do more work...				JMP	NoWorkToDo					;No, wait for new work to doPortSwitch:	MOV	CurrentDCBPtr, BX				;yes, command pending, switch current DCB ptrMoreWorkToDo:	JMP	WorkToDo					;Service the request(s);***********************************************************************************;*                                 *;*        PPO MAIN TASK        	   *;*                                 *;***********************************;  This task performs :;	- the actual initialization of necessary variables for the handler.;  	- the all-important duty of fielding the down-notifys and interpreting; 		 the commands the head has sent.;	- activates the in-service task if there is a transfer operation;	- calls the loopback test, if the head allowed such an operationPPOMainTask:	%GetWorkMaskForCondition (OFFSET PPOWorkFromClientCond)									;Get WorkFromClient Mask		MOV	PPOWorkFromClientMask, AX			;   and save work mask		CMP	AX, 0						;make sure we have valid work mask		JNZ	OKToCont   					;  zero means error		OR	PPOHandlerStatus, HandlerError			;set handler status to indicate ERROR									;SHOULD WE JAM ALL TASKS?OKToCont:	MOV	PPOInServiceWorkCond, 0				;inter-task conditions, ok to be zero		MOV	PPOAttnCond, 0					;		MOV	PPOEndOfScanCond, 0				;		%GetLockMask						;Get Lock Mask		MOV	PPOLockMask, AX					;  and save for later use				%OutputWord (PPOCommandRegr, ResetCmdRegrVal)		;reset board, clr intrpt, & turn-off PPO board		%OutputWord (PPOCommandRegr, DefaultCmdRegrVal)		;load default command regr value		MOV	PPOCmdRegrImage, AX				;save image				%OutputWord (PPOConfigRegr, DefaultConfigRegrVal OR Port1ModeBit)		%InputWord (PPOPortStatusRegr, Port1DCB.PortStatus)	;init port status of Port 1		MOV	port1DCBLocation, OFFSET Port1DCB		;for the head to pass back on a cmd request				%OutputWord (PPOConfigRegr, DefaultConfigRegrVal)	;load default PPO configuration value		MOV	PPOCnfgRegrImage, AX				;save image		%InputWord (PPOPortStatusRegr, Port0DCB.PortStatus)	;update port status of Port 0		%InputWord (PPOStatusRegr, PPOBoardStatus)		;update board status				MOV	BX, OFFSET Port0DCB				;load initial DCB pointer		MOV	CurrentDCBPtr, BX				;make it the default DCB ptr		MOV	port0DCBLocation, BX				;for the head to pass back on a cmd request		MOV	PPODCBPtr, BX					;make it default in case of errant down-notify		CALL	OptBoardStat					;identify and check option board status		SetToReady:	OR	PPOHandlerStatus, HandlerInitialized		;set Handler Stat to handler initialized		AND	PPOHandlerStatus, IdleStateMask			;set status to IDLE				;------------------------------------------; WAIT FOR WORK AND EXECUTE COMMANDS HERE -;------------------------------------------PPOWaitForCmd:	%WaitForCondition (OFFSET PPOWorkFromClientCond,noTimeout)									;Command from the client, the HeadGotDCBPtr:	TEST	PPOHandlerStatus, HandlerBusy			;check if handler is busy		JNZ	PPOHandlerBusy					;not busy, service it at this time									;PPOHandlerIdle:	MOV	BX, PPODCBPtr					;fetch requesting DCB's pointer		MOV	CurrentDCBPtr, BX				;make this the current DCB		WakeInServiceTask:		%NotifyCondition (OFFSET PPOInServiceWorkCond)		;Work for In-Service Task		JMP	PPOWaitForCmd					;wait for the next down notifyPPOHandlerBusy:	MOV	BX, CurrentDCBPtr				;set current DCB ptrIsItAReset:	TEST	[BX].CommandList, PPOResetCmd			;Is command reset?		JZ	IsItAnUpdate					;IF not then go to...		CALL	PPOReset					;ELSE perform reset		JMP	SHORT WakeInServiceTask				;IsItAnUpdate:	TEST	[BX].CommandList, PPOUpdateStatCmd		;Is command Update Status ?		JZ	WakeInServiceTask				;wait for the next down notify		CALL	UpdateStatusNow					;update Status NOW		JMP	WakeInServiceTask				;wait for the next down notify				ASSUME  DS: NOTHING;****************************************************************************************;		B A D	I N T E R R U P T	R O U T I N E S				*;****************************************************************************************;********************************;*				*;*	BadPPOIntrp		*;*				*;********************************;  Opie calls this proc if the interrupt task is not ready for the interrupt;  WaitForInterrupt is STILL in effectBadPPOIntrp    	PROC	FAR		%EstablishHandlerAccess (PPOHandlerID)			;allow access to PPO IORegion segment		ASSUME	ES:PPOIOR					;Use ES as base segment		INC	badPPOIntrpCnt					;Keeping track of bad intrp		%InputWord (PPOStatusRegr, PPOBoardStatus)		;		RET							;WaitForInterrupt still in effectBadPPOIntrp	ENDP		ASSUME	ES:NOTHING;********************************;*				*;*	BadPPODMA1Intrp		*;*				*;********************************; Opie calls this proc if the DMA1 interrupt task is not ready for the DMA1 interrupt;  WaitForInterrupt is STILL in effectBadPPODMA1Intrp PROC	FAR		%EstablishHandlerAccess (PPOHandlerID)	;allow access to PSO IORegion segment		ASSUME	ES:PPOIOR			;Use ES as base segment		INC	badPPODMA1IntrpCnt		;incr. counter		RETBadPPODMA1Intrp	ENDP		ASSUME	ES:NOTHING		IOPEInRAM	ENDS;********************************************************************************;		E N D	O F	P P O	H A N D L E R				*;********************************************************************************		END
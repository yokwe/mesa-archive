$ DEBUG MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);-- PCMouse.asm created 26-Jul-86 12:20:55 by CWM.;--	Copyright (C) 1986 by Xerox Corporation. All rights reserved.	;-- The following program was created in 1986 but has not been published within;-- the meaning of the copyright law. It is furnished under license, and may not;-- be used, copied and/or disclosed except in accordance with the terms of said;-- license.;-- Log:;-- 	26-Jul-86 12:21:05 by CWM  creation;-- 	26-Sep-86  3:16:34 by CWM  Moved to Main Mem;-- 	12-Oct-86 14:59:44 by CWM  New mouse DN processNAME	PCMouse;---------------$NOLIST$INCLUDE		(HardDefs.asm)$INCLUDE		(IOPDefs.asm)$INCLUDE		(IOPMacro.asm)$INCLUDE		(PCEDefs.asm)$INCLUDE		(OpieDefs.asm)$LISTEXTRN		PCEMouseHandlerID: ABSEXTRN		PCEDispatcherHandlerID: ABS;---------------PCEMouseIOR	SEGMENT	COMMONEXTRN	pceMouseTask: taskContextBlockEXTRN	pceMouseWorkMask: WORDEXTRN	mouse: BYTE, jumper: BYTE, xDisplacement: BYTE, yDisplacement: BYTEEXTRN	mouseKey: BYTE, mouseDummy: BYTEEXTRN	mseDBbyte1: BYTE, mseDBbyte2: BYTEEXTRN	pceMouseConditionWork: ConditionEXTRN	intSelected: WORDPCEMouseIOR	ENDSPCEDispatcherIOR	SEGMENT	COMMONEXTRN	pceMouseBootLabel: SegmentAndOffsetEXTRN	pceMouseExitLabel: SegmentAndOffsetPCEDispatcherIOR	ENDS;---------------PCEMouseSTK	SEGMENT	COMMONEXTRN	pceMouseStack: WORDPCEMouseSTK	ENDS;---------------PUBLIC pceMouseInit, pceMouseBoot, pceMouseExitIOPEInRAM	SEGMENT		WORD PUBLIC		Assume		CS:IOPEInRAM;-------------------------------------------------------------------------------;;;			         INITIALIZATION;;;-------------------------------------------------------------------------------pceMouseInit		PROC	FAR	%InitializeTask (PCEMouseHandlerID,OFFSET pceMouseTask,pceMouseTaskInit,OFFSET pceMouseStack) ; Init task	RET	pceMouseInit		ENDPpceMouseTaskInit:	PUSH	ES	%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIOR	MOV	pceMouseBootLabel.offsetValue, OFFSET pceMouseBootLb	MOV	pceMouseBootLabel.segmentValue, CS	MOV	pceMouseExitLabel.offsetValue, OFFSET pceMouseExitLb	MOV	pceMouseExitLabel.segmentValue, CS	POP	ES	ASSUME	ES:NOTHING	ASSUME	DS:PCEMouseIOR	;GetWorkMaskForCondition (OFFSET pceMouseConditionWork)	;MOV	pceMouseWorkMask, AX	%Jam (PCEMouseHandlerID,OFFSET pceMouseTask)		; ...but don't let it run yet	%WaitForSystem						; (deferred Jam)	ASSUME	DS:NOTHING;-------------------------------------------------------------------------------;;;			            BOOT;;;-------------------------------------------------------------------------------pceMouseBoot		PROC	FARpceMouseBootLb:	%Restart (PCEMouseHandlerID,OFFSET pceMouseTask,pceMouseEmul,OFFSET pceMouseStack) ; now task runs	RET	pceMouseBoot		ENDP;-------------------------------------------------------------------------------;;;				    EXIT;;;-------------------------------------------------------------------------------pceMouseExit		PROC	FARpceMouseExitLb:	%Jam (PCEMouseHandlerID,OFFSET pceMouseTask)	; stop task	RET	pceMouseExit		ENDP;-------------------------------------------------------------------------------;;;		            MOUSE  EMULATION;;;-------------------------------------------------------------------------------;MouseBaseAddress OpieAddress <0D040H,0FH,PCLogicalOpieAddress>pceMouseEmul:	ASSUME	DS:PCEMouseIOR	; Store configuration parameters in BIOS/IOP communication area		%EstablishIOPAccess (generalMapRegister,MouseBaseAddress)m1:	MOV	AL, mouse		; Take mouse selectionm2:	MOV	ES:[DI], AX		; Store mouse selection in BIOSm3:	MOV	AL, jumper		; Take jumper selectionm4:	MOV	ES:[DI+1], AX		; Store jumper selection in BIOS; Initialize interrupt to use for mousem5:	SHL	AX,1			; Multiply jumper selection by 2m6:	ADD	AX,pInterruptBase	; Add to base interruptm7:	MOV	intSelected, AX		; Use this as interrupt controller input	pceMouseWaitForMesa:m8:	%WaitForCondition	(OFFSET pceMouseConditionWork,noTimeout)					; Wait for down notificationpceMouseInterrupter:m9:	%EstablishIOPAccess (generalMapRegister,MouseBaseAddress)		m11:	MOV	AL, xDisplacement	; Take xDisplacementm111:	MOV	AH, yDisplacement	; Take yDisplacementm12:	MOV	ES:[DI+2], AX		; Store Displacements in BIOS;m13:	MOV	AL, yDisplacement	; Take yDisplacement ;m14:	MOV	ES:[DI+3], AX		; Store yDisplacement in BIOSm15:	MOV	AL, mouseKey		; Take mouseKeym16:	MOV	BYTE PTR ES:[DI+4], AL	; Store mouseKey in BIOSm17:	MOV	AL, mseDBbyte2		; Take dirtyBits m18:	MOV	BYTE PTR ES:[DI+5], AL	; Store dirtyBits in BIOS	m19:	MOV	DX,intSelected		; Get interrupt code m20:	OUT	DX,AL			; Interrupt PC, AL has junkm21:	JMP	pceMouseWaitForMesa	; Wait for more down notification	IOPEInRAM		ENDS			END
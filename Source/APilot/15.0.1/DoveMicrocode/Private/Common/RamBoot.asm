$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1984, 1985, 1986 by Xerox Corporation. All rights reserved.;-- stored as RAMBoot.asm;-- created on  19-Jul-84 13:20:18;-- last edited by:;--	RDH		19-Jan-87 10:12:01	;Remove CP specific stuff to iop init block. 	;Added EXTRNs: WriteCSProc CPStartOrInitProc IncSIFarProc. 	;Added init of IncSIFarProc IncSIFarProc+2. Added IncSIFar. 	;Changed call to DumpCSBlock in Checksum to 2 calls to IncrementSI	;At ReadOffset+2 change CALL LoadCXFromBootBuf to CALL LoadAXFromBootBuf; MOV CX, AX	;Commented out all of LoadCXFromBootBuf.;--	JPM		29-Jul-86 15:57:30	;Activate InitializeCP code (uncomment code, add calls to Start/StopCP, enable/clear/disable interrupt).;--	RDH		22-Jan-86 12:06:22	;Adjust code for cs config of "any-type", and fix buglet in InitializeIOP. ;--	RDH		17-Jan-86 12:06:08	;Create and use procs 	; LoadCXFromBootBuf and LoadAXFromBootBuf to save space.  	; Comment out useless code for doing Daybreak cp inits and starts. 	; Alter IncrementSI, ProcessEmulatorFile, and ProcessMultipleDBsFile	; to use new proc ReloadBuffer created from part of ProcessEmulatorFile.;--	RDH		14-Jan-86 15:25:14	;Add code for handling fb's for various control store configurations, and add labels near beginning of all proc's for debugging ease.;--	RDH		13-Jan-86 13:39:34	;Change AX to AL in setting control store bank register for 8K.;--	RDH		 9-Jan-86 11:45:38	;Add stuff for handling fb files for bank configs not on the machine.;--	JAC		 6-Jan-86 10:00:59	;comment out rest of Daisy stuff because the addns to initial kill ether booting diagnostics;--	JAC		10-Dec-85 11:04:03	;add checking in WriteIOPMemory, StartIOP and InitializeIOP for main memory;--	RDH		28-Oct-85 12:33:27	;Add code to fix etherbooting of diagnostics by sending an error packet when EOF block is found and it is an ethernet diagnostic boot.  Commented out some Daisy code to make room.;--	JPM		20-Sep-85  9:29:24	;Move boot buffer allocation to device-specific code.;--	bki		 6-Sep-85 11:52:40	;change some JMP's to SHORT's.;--	kek		 4-Sep-85 14:58:06	;mp codes;--	JPM		 6-Aug-85 16:25:43	;Remove extra POP in ProcessLoaderFile.;--	JPM		 1-Aug-85 15:04:33	;Fix bug in OutOfLoadSpace.;--	JPM		18-Jul-85 15:17:48	;Opie redesign conversion.;--	JMM		20-Jun-85 14:55:53	;New IOPLRAM.asm upgrade.;--	JMM		17-Jun-85 12:25:18	;Deleted doneWithDBFile and doneWithGermFile and restored previous protocol.;--	JPM		 6-Jun-85  8:19:41	;Switch to word offset in multiple db files; share buffer loading code.;--	JPM		 5-Jun-85 15:48:02	;Fix byte-swap bug in MultipleDBs; use doneWithDBFile and doneWithGermFile for control flow.;--	JPM		30-May-85 15:01:34	;Fixed bug in StartIOP.;--	JPM		22-May-85 10:11:58	;Revised for overlay booting.;--	JMM		12-Apr-85 18:44:28	;Debugging additions.;--	JMM		31-Jan-85 11:43:32	;Diagnostics handling.;--	JMM		15-Jan-85 16:41:11	;First release.NAME			RAMBoot;--------------------------------------------------------------------------------;$NOLIST$INCLUDE		(EthHdFce.asm)	$INCLUDE		(HardDefs.asm)	$INCLUDE		(IOPDefs.asm)	$INCLUDE		(IOPMacro.asm)$INCLUDE		(RAMBDefs.asm)	$INCLUDE		(EthBDefs.asm)	$INCLUDE		(Handlers.asm)	;to resolve handler IDs;$INCLUDE		(CSBankDf.asm)	;$INCLUDE		(RAMEEP.asm)	$LIST;--------------------------------------------------------------------------------%*DEFINE	(ByteSwap	(wordToSwap))		(%wordToSwap SHL 8 OR %wordToSwap SHR 8)%*DEFINE(Handler(name,id,initProcAction))	(PUBLIC			%name%(HandlerID)%name%(HandlerID)	EQU	%id)			%HandlersLinkedEXTRN			mesaProcessorInterrupt :ABS;---------------;******************************************************************;---------------IOPELocalRAM		SEGMENT	AT 0;from IOPLRAM.asm:;------------------EXTRN			bootOverlayReentry: WORDEXTRN			bootType: BYTEEXTRN			device: WORDEXTRN			skipUserInterface: BYTEEXTRN			bootOverlayRequest: WORDEXTRN			startOfBootBufferSpace: WORDEXTRN			endOfBootBufferSpace: WORDEXTRN			resetRegData: WORDIOPELocalRAM		ENDS;---------------;******************************************************************;---------------;Imported Variables:;from IORMaint.asm:;------------------MaintPanelIOR		SEGMENT	COMMONEXTRN			maintPanelCode: WORDEXTRN			maintPanelChanged: ConditionMaintPanelIOR		ENDS;from IORRAMBt.asm:;------------------BootStrapIOR		SEGMENT	COMMONEXTRN			bootTask: TaskContextBlock	EXTRN			bootBufferPtr :WORD			EXTRN			bootBufferEmpty  :Condition, bootBufferFull :Condition EXTRN			finishedLoaderFileFetch :Condition, getBootFile :Condition		EXTRN			bootFileChoice :WORD		EXTRN			currentBootBuffer :WORD		;EXTRN			currentBlockSequence :WORD		EXTRN			jumpTable :BootJumpTable		EXTRN			startOfBootBufferPool :WORD		EXTRN			loaderVirtualMemoryLocation :DWORD		EXTRN			BootDeviceIORSpace :RamEtherBootContext	EXTRN			bootMemoryPtr: WORD	EXTRN			WriteCSProc: WORD	EXTRN			CPStartOrInitProc: WORD	EXTRN			IncSIFarProc: WORD	BootStrapIOR		ENDS;--------------------------------------------------------------------------------;********************************************************************************IOPEInRAM		SEGMENT		PUBLIC			ASSUME	CS:IOPEInRAM			ASSUME	DS:BootStrapIOR;			;--------------------------------------------------------------------------------PUBLIC			EndOfInitialPUBLIC			BootTaskInitPUBLIC			DisplayMPCode;Needed for etherbooting diagnostics.  This will cause a link time warning, ;Unresolved External when building diskboot.lnk and flpyboot.lnk.EXTRN			TransmitFrame:		 NEAR	bootBufferSize		DW	SIZE BootBuffer;--------------------------------------------------------------------------------;Dove Boot Blocks:;;;BootFile => BootBlock | BootBlock . BootFile;BootBlock => Type . Address . DataLength . Data;Type => CP . Command | IOP . Command | Checksum | MultipleFiles | EOF;Command => Operation . MachineType . MemorySection . BankConfiguration . Bit . Byte;Operation => Initialize | Start | writeData;CP => 1;IOP => 0;Initialize => 00;Start => 01;writeData => 10;MachineType => Daisy | DayBreak;Daisy => 0;DayBreak => 1;MemorySection => LocalRam | MainMemory;LocalRam => 0;MainMemory => 1;BankConfiguration => fourK | eightK | twelveK | sixteenK;fourK => 00;eightK => 01;twelveK => 10;sixteenK => 11;Checksum => 1110 . 0000 . 0000 . 0000;MultipleFiles => 1111 . 1111 . DBFileCount . FileOffset;FileOffset => FileOffset . FileOffset | FileOffset;Address => DoveCPAddress | DoveIOPAddress;DoveCPAddress => CPAddress | BankValue . CPAddress | CPAddress . CPNextAddress;BankValue => DaybreakBankValue | DaisyBankValue;DaybreakBankValue => DaybreakBank0 | DaybreakBank1 | DaybreakBank2 | DaybreakBank3;DaisyBankValue => DaisyBank0 | DaisyBank1 | DaisyBank2 | DaisyBank3;CPNextAddress => CPAddress;CPAddress => m = {0,1,2, . . .2^16-1};DoveIOPAddress => AddressSegment . AddressOffset;DataLength => j = {0,1,2, . . .2^16-1};DBFileCount => k = {1,2, . . .254};FileOffset => i = {0,1,2, . . .2^16-1};DaybreakBank0 => NullByte . 0000 . 0000;DaybreakBank1 => NullByte . 0011 . 0000;DaybreakBank2 => NullByte . 0101 . 0000;DaybreakBank3 => NullByte . 1001 . 0000;DaisyBank0 => 0001 . 0000 . NullByte;DaisyBank1 => 0010 . 0000 . NullByte;DaisyBank2 => 0100 . 0000 . NullByte;DaisyBank3 => 1000 . 0000 . NullByte;Data => CPData | IOPData;CPData => (Word . Word . Word)*;IOPData => Byte*;AddressSegment => n = {0,1,2, . . .2^16-1};AddressOffset => n = {0,1,2, . . .2^16-1};EOF => 1111 . 1111 . 1111 . 1111;Word => Byte . Byte;Byte => Nibble . Nibble;NullByte => 0000 . 0000;Nibble => (0+1)(0+1)(0+1)(0+1);Bit => (0+1);;;;	Hex	Binary;;	0x	0000.xxxx	IOP Daisy Initialize;	1x	0001.xxxx	IOP Daybreak Initialize;	2x	0010.xxxx	IOP Daisy Start;	3x	0011.xxxx	IOP Daybreak Start;	4x	0100.xxxx	IOP Daisy Write;	5x	0101.xxxx	IOP Daybreak Write;	6x	0110.xxxx	IOP Daisy Unknown;	7x	0111.xxxx	IOP Daybreak Unknown;	8x	1000.xxxx	CP  Daisy Initialize;	9x	1001.xxxx	CP  Daybreak Initialize;	Ax	1010.xxxx	CP  Daisy Start;	Bx	1011.xxxx	CP  Daybreak Start;	Cx	1100.xxxx	CP  Daisy Write;	Dx	1101.xxxx	CP  Daybreak Write;	Ex	1110.xxxx	Checksum;	Fx	1111.xxxx	EOF or MultipleDB's;	;-- ;-- Boot task initialization:;--------------  This task communicates with the device specific task to load in;--------------  the Mesa emulator file and RAM based opie and to also prepare the:;--------------  virtual memory map, Germ variables and load the Germ.;--------------|								|;--------------|	  startOfBootBufferSpace = This is supplied by Opie and	|;--------------|	  points to the beginning of a huge buffer that lies 	|;--------------|	  right after STACK space but 	right before local RAM	|;--------------|	  IORegion. *Initial updates it so that it points just	|;--------------|	  beyond *Initial. Boot then adjusts it so that there is|;--------------|	  loadable space between *Initial and the beginning of	|;--------------|	  buffer. It is up to Boot task to divide this buffer	|;--------------|	  into a pool of buffers to be used in conjuction 	|;--------------|	  with RAM*Bt.asm to load files. Any Opie files must be |;--------------|	  loaded last since we start loading RAM based Opie in 	|;--------------|	  low RAM going upwards.				|;--------------|	   							|;--------------|	  							|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------BootTaskInit		PROC	NEARBeginBootTask:		%'ThisTaskServices (mesaProcessorInterrupt,BadMesaInterrupt)			;This will be done in the CP specific code that is loaded from			; the last IOP Init block before the cp oriented blocks.					;Recall that any boot block of the type CP-					;Initialize causes the CP to be started which					;in turn is expected to issue an interrupt when 					;it is done initializing the CP. This interrupt 					;servicing will be taken over by Mesa processor					;task when RAM based opie starts. In fact on 					;loading CP code, CP is not started even though 					;its start address is progrmmed into it, rather 					;it is left to Mesa processor task to start CP 					;since by then all of Opie should be ready.			MOV	AX, IOPELocalRAM	;We will occassionally refer to variables			MOV	ES, AX			;in IOP low memory (which will cover all of			ASSUME	ES:IOPELocalRAM		;boot buffer and load space).			MOV	AX, startOfBootBufferPool ;Pick up buffer(s) supplied			MOV	currentBootBuffer, AX	;by device-specific code.			MOV	AX, startOfBootBufferSpace ;Also get boot area address,			ADD	AX, LowNibbleMask	;adjust it so that it is 			AND	AX, NOT(LowNibbleMask)	;at a "paragraph" boundary and then							;save it for loading IOP code			MOV	bootBufferPtr, AX	;into later.			MOV	jumpTable.startRAMOpie, OFFSET NoRAMOpieEntryPoint			MOV	jumpTable.startRAMOpieCS, CS	;Just in case we never get a								;RAMOpie entry IOPStart block.			MOV	IncSIFarProc, OFFSET IncSIFar	;Initialize point for CP			MOV	IncSIFarProc+2, CS		; specific code to call 							; to get IncrementSI.									%NotifyCondition (OFFSET getBootFile)			;display mp code for fetching MesaDove			MOV	AX, mpFetchMesaDove			CALL	DisplayMPCode									;IN	AX, machineIDPort	;The Mesa processor should be halted			;AND	AX, machineIDMask	;before we do anything to it.			;CMP	AX, Daisy		;before we do anything to it.			;JNE	DaybreakCPConditioning			;DaisyCPConditioning:	CALL	DaisyCPHalt			;JMP	SHORT ProcessEmulatorFile;DaybreakCPConditioning:	CALL	DaybreakCPHalt;			CLI					;to protect reset register;			MOV	AX, resetRegData;			AND	AX, NOT resetMesaProcessor		;			OUT	WriteResetReg, AX;			CALL	DaybreakCPStart									;			OR	resetRegData, resetMesaProcessor		;			MOV	AX, resetRegData;			OUT	WriteResetReg, AX;			CALL	DaybreakCPHalt;			STI					;done with reset register						;Put the number of extra control store banks in the 			; variable, csBankConfiguration.;			CALL	GetCSBankConfig																								JMP	SHORT ProcessEmulatorFile										BootTaskInit		ENDP;-- ;-- ;-- Boot file processing:;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	currentBootBuffer = pointer to current boot buffer. 	|;--------------|	At this point, boot block type is as follows:		|;--------------|		'zxxx' where 'x' is a don't care bit and	|;--------------|		'z' is the bit we are testing for. Except	|;--------------|		initially we do test all of 'zxxx' for EOF	|;--------------|		or MultipleDBfile.				|;--------------|								|;--------------|								|;--------------|	BX = currentBootBuffer					|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|	AH = xxx0 - remaining bits to be tested.		|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI = BootBlock.Type					|;--------------|								|;-------------------------------------------------------------------------------ProcessEmulatorFile	PROC	NEAR			CALL	WaitForFullBuffer			StartSequence:		CALL	LoadAXFromBootBufLateEntry	;Get the boot block type indicator CouldBeCPorIOPType:	SHL	AH, oneBit						JC	ItsaCPBlockType				MOV	jumpTable.processBootBlock, OFFSET ProcessIOPBlock					JMP	 SHORT BootBlockIdentified		ItsaCPBlockType:	MOV	jumpTable.processBootBlock, OFFSET ProcessCPBlock							BootBlockIdentified:	CALL	WORD PTR jumpTable.processBootBlock			CMP	SI, ES: [BX].bootDataEnd 			JLE	StartSequence			CALL	PrepareToFetchBuffer			JMP	StartSequence		 			ProcessEmulatorFile	ENDP;-- ;-- ;-- ReloadBuffer:;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------ReloadBuffer	PROC	NEARWaitForFullBuffer:	PUSHA			%WaitForCondition (OFFSET bootBufferFull,noTimeout)			POPAFetchTheNextBuffer:	MOV	BX, currentBootBuffer		;Every time we get a new buffer 			MOV	SI, ES: [BX].bootDataStart	;we have to first check that it			CMP	SI, ES: [BX].bootDataEnd	;is really full before we start			JE	WaitForFullBuffer		;processing it.			RET			PrepareToFetchBuffer:	MOV	BX, ES: [BX].nextBootBuffer	;Update the pointer to the			MOV	currentBootBuffer, BX		;next buffer to process, then do			PUSH	BX				;the obligatory rest.			%NotifyCondition (OFFSET bootBufferEmpty) 			POP	BX			JMP	FetchTheNextBuffer						ReloadBuffer	ENDP;-- ;-- ;-- IOP Boot block early interpretation:;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	AH = zzx0 - remaining bits to be tested.		|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;-------------------------------------------------------------------------------ProcessIOPBlock		PROC	NEARDoIOPBlock:		SHL	AH, oneBit		;This could be a Start, Initialize			JC	IOPWriteORUnknown	;Checksum or Write block for IOP.			ItsStartORInitialize:	SHL	AH, oneBit		;Sure, but which one is it?			JC	ItsStart		;Go process an IOP Start block!			JMP	InitializeIOP		;Go process an IOP Initialize block!ItsStart:		JMP	StartIOP			IOPWriteORUnknown:	SHL	AH, oneBit		;If it is a checksum block go to			JC	ItsUnknown		;the checksum routine otherwise			JMP	SHORT WriteIOPMemory		;go write IOP memory.ItsUnknown:		JMP	UnknownBlock						;Notice that we never bothered checking BootBlock.Type(Daisy|Daybreak) because for the;IOP, the two worlds are identical!						ProcessIOPBlock		ENDP;-- ;-- ;-- ;-- CP Boot block early interpretation:;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	AH = zzx0 - remaining bits to be tested.		|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|	AH = x000 - remaining bit to be tested.			|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------ProcessCPBlock		PROC	NEAR			DoCPBlock:		ROL	AH, oneBit		;Save this bit for use							; later in CheckBankConfig.							;This could be a Start, Initialize			JC	CPWriteORChecksum	;or Write block for CP.			StartORInitialize:				CALL DWORD PTR CPStartOrInitProc			RET	;Return into ProcessEmulatorFile			;Code for starting the CP should have been loaded and			; started from the last IOP init block which will have			; initialized CPStartORInitialize.			;SHL	AH, oneBit		;Sure, but which one is it?			;JC	ItsStartCP		;Go process a CP Start block!			;JMP	InitializeCP		;Go process a CP Initialize block!;ItsStartCP:		JMP	StartCP			CPWriteORChecksum:	SHL	AH, oneBit		;If it is an unknown block go to			JC	ItsChecksum		;the unknown block routine otherwise			CALL 	DWORD PTR WriteCSProc			RET		;Return into ProcessEmulatorFile			;Code for loading the CP should have been loaded and			; started from the last IOP init block which will have			; initialized CPStartORInitialize.			;JMP	WriteControlStore	;go write CP control store.ItsChecksum:		JMP	Checksum						ProcessCPBlock		ENDP;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type.					|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------WriteIOPMemory		PROC	NEARWriteIOPMem:		SHL	AX, oneBit		;Ignore Daisy or Daybreak bit			SHL	AX, oneBit		;Should this be stored in main memory?			JNC	WriteInLRAMWriteInMemory:		MOV	DI, bootMemoryPtr			SHL	DI, Nibble			JMP	ReadOffsetWriteInLRAM:		MOV	DI, bootBufferPtrReadOffset:		CALL	LoadAXFromBootBuf	;The next word in the 			ADD	DI, AX			; boot block is the							; address to be written to.							;Boot clients should offset their							;code from zero! jmm:84-12-11:later				CALL	LoadAXFromBootBuf			MOV	CX, AX					;And now we want to get the data			;count to use in emptying this			;boot block, then point to the data itself.			CALL	IncrementSI								UnloadBootBlock:	MOV	AL, ES: [BX][SI] 	;As we empty the block,			MOV	BYTE PTR ES: [DI], AL	;we have to keep testing to make sure			CALL	IncrementSI		;that we have not reached the end of the 			INC	DI			;boot buffer.			LOOP	UnloadBootBlock					RET									WriteIOPMemory		ENDP;-- ;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------InitializeIOP		PROC	NEARInitIOP:		SHL	AX, oneBit		;Ignore Daisy or Daybreak bit			SHL	AX, oneBit		;should this be started in main memory?			JNC	LRAMInitMemoryInit:		MOV	AX, bootMemoryPtr	;Set up CS for main memory							;This had better not happen until							;AllocSgs has run since it is responsible							;for setting up bootMemoryPtr			JMP	JumpTableInitLRAMInit:		MOV	AX, bootBufferPtr 	;Set up CS for boot code in local RAM			SHR	AX, Nibble		;to point to start of boot bufferJumpTableInit:		MOV	jumpTable.iopEntryCS, AX ;and store into jump table.			CALL	LoadAXFromBootBuf				;The next word in the Boot			;block is the address to go to			;and which should return to us			;upon completion.			MOV	jumpTable.iopEntry, AX	;Notice that we are giving			PUSHA				;boot clients the ability			PUSH	ES			;to specify only the offset	EnterInitIOP:		CALL	DWORD PTR jumpTable.iopEntry ;to their entry point.			POP	ES			POPA							CALL	IncrementSI							RET										InitializeIOP		ENDP;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;-------------------------------------------------------------------------------StartIOP		PROC	NEARStartTheIOP:		SHL	AX, oneBit		;Ignore Daisy or Daybreak bit			SHL	AX, oneBit		;should this be started in main memory?			JNC	LRAMStartMemoryStart:		MOV	AX, bootMemoryPtr	;Set up CS for main memory			JMP	JumpTableStoreLRAMStart:		MOV	AX, bootBufferPtr 	;Set up CS for boot code in local RAM			SHR	AX, Nibble		;to point to start of boot bufferJumpTableStore:		MOV	jumpTable.startRAMOpieCS, AX ;and store into jump table.			CALL	LoadAXFromBootBuf				; The address we get here and save			;is the entry point of RAMOpie.			;Prior to this we had saved the			;address of a "No Opie entry point"			MOV	jumpTable.startRAMOpie, AX ; error routine. Again notice							;that we are giving boot clients							;the ability to specify only 			CALL	IncrementSI		;the offset to their entry point.			RETStartIOP		ENDP;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	AH = z000 - remaining bit to be tested.			|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type.					|;--------------|								|;-------------------------------------------------------------------------------;ALL OF WriteControlStore IS COMMENTED OUT.;WriteControlStore	PROC	NEAR;WriteCntlStore:		CALL	CheckBankConfig		;Make sure its the right fb.			;CALL	IncrementSI		;We want to point to the			;SHL	AX, oneBit		;address part of the buffer.			;JC	WriteDaybreakControlStore ;But first see if the block			 				;is for Daisy or Daybreak.;WriteDaisyControlStore:			;IN	AX, machineIDPort	;Find out if this is a Daisy 			;AND	AX, machineIDMask	;or a Daybreak and act accordingly.			;CMP	AX, Daisy		;or a Daybreak and act accordingly.			;JE	WriteDaisysCS			;JMP	DumpCSBlock;WriteDaisysCS:					;MOV	AH, ES: [BX][SI]	;Get the low byte of the 			;CALL	IncrementSI		;address, fetch the high byte,			;MOV	AL, ES: [BX][SI]	;then save in BP. Recall shift			;MOV	BP, AX			;order for the Sirius chip access.			;CALL	IncrementSI		;After which, we want to fetch			;MOV	CH, ES: [BX][SI]	;the CS block length and we will			;CALL	IncrementSI		;use the BP register as a counter			;MOV	CL, ES: [BX][SI]	;since we are out of registers.;LetsGetACSWord:		;PUSH	CX	;jmm-84-10-24!!!!!!!stack trouble!!!!!!			;MOV	CX, CSsizeWordCount;LoopForCSWord:		;CALL	IncrementSI		;Get the control store word to			;MOV	AH, ES: [BX][SI]	;be written and pop it onto stack 			;CALL	IncrementSI		;so as to restore it to its correct			;MOV	AL, ES: [BX][SI]	;order when writing it later.			;PUSH	AX			;LOOP	LoopForCSWord						;MOV	CX, CSsizeWordCount			;MOV	AL, loadShiftRegister	;Get CS ready to write a word!			;OUT	CPoutputPort, AL;WriteDaisyCSWord:	;POP	AX			;Send the 48-bit control store			;PUSH	CX			;word to the shift register of 			;MOV	CX, dataWordBitCount	;Sirius chip.			;CALL	ShiftDataToCS			;POP	CX			;LOOP	WriteDaisyCSWord						;MOV	AX, BP			;Finally get the saved address			;CALL	ShiftDataToCS		;of the word to write.			;MOV	AL, (notLoadShiftRegister OR writeCS OR interruptCP)			;OUT	CPoutputPort, AL			;MOV	AL, grabData			;OUT	CPoutputPort, AL			;MOV	AL, (loadShiftRegister OR notWriteCS)			;OUT	CPoutputPort, AL			;MOV	AL, notGrabData 			;OUT	CPoutputPort, AL			;INC	BP			;Update to next address						;POP	CX			;LOOP	LetsGetACSWord						;CALL	IncrementSI						;RET;WriteDaybreakControlStore:			;IN	AX, machineIDPort	;Find out if this is a Daisy 			;AND	AX, machineIDMask	;or a Daybreak machine and			;CMP	AX, Daybreak		;dump block if it is for 			;JE	WriteDaybreakCS			;JMP	DumpCSBlock		;Daisy.;WriteDaybreakCS:	CALL	LoadAXFromBootBufLateEntry				;We first want to set the CS			;bank register then get the CS			;address that this block is to			;be written to.						;DayBreak's control store is an I/O port.			;Put the cs address into DX.			;CALL	LoadCXFromBootBuf			;MOV	DX, CX					;We want to point to the count 			;of CS words in this block,			;from which we will fetch the			;CS block size counter and 			;save it in DI - we are again out of registers!			;CALL	LoadCXFromBootBuf					;MOV	DI, CX			;			;MOV	BP, DX						;MOV	DX, daybreakBankRegister ;First let us set up the CS bank			;OUT	DX, AL 			;register.			;WriteDaybreakCSBlock:	MOV	DX, BP			;Also need to save initial CS adrs.			;OR	DX, daybreakCSPortMask	;			;MOV	CX, CSWordByteSize	;A single control store word;WriteDaybreakCSWord:	CALL	IncrementSI		;is made up of six bytes. The			;MOV	AL, ES: [BX][SI]	;layout of the control store with			;OUT	DX, AL			;respect to the 4K ports is as			;ADD	DX, nextCSByte		;follows: 8###H - D###H where			;LOOP	WriteDaybreakCSWord	;8###H has the MSB and D###H has			;INC	BP			;the LSB. The CS is loaded in six			;DEC	DI			;byte data streams. Update CS word count.			;JNZ	WriteDaybreakCSBlock	;Loop while not done with CS block.			;CALL	IncrementSI						;RET			 						;WriteControlStore	ENDP;-- 			;-- ;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	AH = z000 - remaining bits to be tested.		|;--------------|	AL = xxxx - remaining bits to be dumped in this case.	|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type.					|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;ALL OF InitializeCP IS COMMENTED OUT.;InitializeCP		PROC	NEAR;InitCP:			CALL	CheckBankConfig		;Make sure its the right fb.			;CALL	IncrementSI		;We want to point to the							;address part of the buffer.			;SHL	AX, oneBit		;But first see if the block			;JC	InitializeDaybreakCP	;is Daisy or Daybreak.			;InitializeDaisyCP:			;IN	AX, machineIDPort	;Find out if this is a Daisy 			;AND	AX, machineIDMask	;or a Daybreak and act accordingly.			;CMP	AX, Daisy			;JE	WriteDaisyCPAddress			;JMP	DumpCSBlock;WriteDaisyCPAddress:					;Load CP address for Daisy before							;starting the CP.			;JMP	SHORT StartDaisyCPANDWait;InitializeDaybreakCP:			;MOV	CX, 5			;5 bytes to end of boot block.			;CALL	DumpCSBlock		;skip over address (not used)			;IN	AX, machineIDPort	;Find out if this is a Daisy 			;AND	AX, machineIDMask	;or a Daybreak and act accordingly.			;CMP	AX, Daybreak			;JNE	InitializeDaybreakCPRet;StartDaybreakCPANDWait:				;PUSHA			;%'Enable(mesaProcessorInterrupt)	;turn on the interrupt, but			;%'DisableInterruptsTillNextWait	; don't allow it till we're ready			;CALL	DaybreakCPStart		;let CP run			;%'WaitForInterrupt	(1)	;init routines should take < 1 sec			;IN	AX, ClrMesaIntr		;clear Mesa interrupt			;%'Disable(mesaProcessorInterrupt); and turn it off			;%'WaitForSystem			;drop to system level			;POPA			;CALL	DaybreakCPHalt		;stop the CP (so can load more code);InitializeDaybreakCPRet:			;RET;InitializeCP		ENDP;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	AH = z000 - remaining bits to be tested.		|;--------------|	AL = xxxx - remaining bits to be dumped in this case.	|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type.					|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;ALL OF StartCP IS COMMENTED OUT.;StartCP			PROC	NEAR;StartTheCP:		CALL	CheckBankConfig		;Make sure its the right fb.							;We want to point to the			;CALL	IncrementSI		;address part of the buffer.			;SHL	AX, oneBit		;But first see if the block			;JC	StartDaybreakCP	;is Daisy or Daybreak.;StartDaisyCP:			;IN	AX, machineIDPort	;Find out if this is a Daisy 			;AND	AX, machineIDMask	;or a Daybreak and act accordingly.			;CMP	AX, Daisy			;JE	DoDaisyStart			;JMP	DumpCSBlock;DoDaisyStart:						;Load CP address for Daisy before							;leaving this procedure.			;CALL	IncrementSI														;RET											;StartDaybreakCP:	;Daybreak cannot currently use a start address, so dump its			;Start Block right here!			;MOV	CX, 5		;5 bytes to end of boot block			;JMP SHORT DumpCSBlock	;Note that a call to IncrementSI						;was commented out above giving us						;5 instead of the 4 below.						;IN	AX, machineIDPort	;Find out if this is a Daisy 			;AND	AX, machineIDMask	;or a Daybreak and act accordingly.			;CMP	AX, Daybreak			;JNE	DumpCSBlock						;CALL	IncrementSI		;jmm:1984-11-08:For now dump adrs.			;CALL	IncrementSI		;jmm:1984-11-08:For now dump adrs.			;CALL	IncrementSI		;jmm:1984-11-08:For now dump adrs.									;CALL	IncrementSI								;RET									;StartCP			ENDP;-- 			;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;waitForMesaInterrupt	PROC	NEAR							;Restore registers, then;WaitForMesaInt:		;CALL	DaisyCPHalt		;halt the CP and keep			RET				;processing the boot file.									;waitForMesaInterrupt	ENDP;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;BadMesaInterrupt	PROC	NEAR;BadMesaInt:		RET						;BadMesaInterrupt	ENDP;-- 						;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	AH = x000 - remaining bit to be tested.			|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------Checksum		PROC	NEARChecksumBegin:		SHL	AH, oneBit		;This could be a Start, Initialize			JNC	DoChecksum		;or Write block for CP.			JMP	EOForMultipleDBs	;We might be done with this file.DoChecksum:								;MOV	CX, 2			;JMP SHORT DumpCSBlock			CALL	IncrementSI		;jmm:1984-11-06 :For now we will			CALL	IncrementSI		;jmm:1984-11-06 :just dump the							;jmm:1984-11-06 :checksum type and							;jmm:1984-11-06 :the checksum.			RET						Checksum		ENDP;-- 			;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;DaisyCPHalt		PROC	NEAR;DsyCPHalt:		RET						;DaisyCPHalt		ENDP;DaybreakCPHalt		PROC	NEAR;DybrkCPHalt:		MOV	AX, 0			;OUT	WriteCSReg, AX			;SHL	AX, 15	; delay			;SHL	AX, 13	;  at least 38 cycles			;RET			;DaybreakCPHalt		ENDP;DaybreakCPStart		PROC	NEAR;DybrkCPStart:		MOV	AX, 0200H			;OUT	WriteCSReg, AX			;RET			;DaybreakCPStart		ENDP;-- ;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|								|;--------------|	AL = BootBlock.Type.lowByte.				|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------EOForMultipleDBs	PROC	NEAREOForMultDBs:		CMP	AH, ((EOF AND highNibbleMask) OR 4)	;The 4 is there because back at DoCPBlock we Rotated AH instead of shifting it.  			JNE	UnknownBlock			CMP	AL, EOF			JNE	MultipleDBs			;If this is diagnostics and ether booting 			; send a shut up message to boot server.			MOV	AL, ES:bootType			CMP	AL, diagnostic			JNE	GoToLoader			MOV	AX, device			CMP	AX, ethernet			JNE	GoToLoader			MOV	BootDeviceIORSpace.useStreamProtocol, shutUp				;TransmitFrame will send error packet.			CALL	TransmitFrame		;in RAMEthBt.  TransmitFrame will							; cause an unresoved							;  external warning when 							;   building Disk and Floppy							;    initials.GoToLoader:		JMP	ProcessLoaderFile				MultipleDBs:		JMP	ProcessMultipleDBsFile						RET									EOForMultipleDBs	ENDP;-- 			;-- ;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------IncrementSI		PROC	NEARIncSI:			INC	SI			CMP	SI, ES: [BX].bootDataEnd			JLE	BufferNotYetEmpty						MOV	ES: [BX].bootDataStart, Null						MOV	ES: [BX].bootDataEnd, Null						CALL	PrepareToFetchBuffer			;POP	jumpTable.processBootBlock			;MOV	currentBlockSequence, OFFSET BootBlockIdentified			BufferNotYetEmpty:	RET						IncrementSI		ENDP;-------------------------------------------------------------------------------; ;IncSIFar is what CP specific code will use to call IncrementSI.  The address ; will be loaded into the IO Region prior to beginning to interpret blocks.  IncSIFar		PROC	FARCallLocal:	CALL	IncrementSI		RET		IncSIFar	ENDP;-- ;-- ;-- ;-- DumpCSBlock: Call IncrementSI CX times and return.  Some procedures Jmp ;--  here and use this return as their own in order to dump the rest of the ;--  block.  Others Call it to move past uninteresting data in the boot block.;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	CX = Count of bytes to dump.				|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI = Offset within buffer				|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI = CX bytes further through stream.			|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;DumpCSBlock	PROC	NEAR			;DumpBlock:	CALL	IncrementSI		;Bump SI with checking for end of		;LOOP	DumpBlock		;boot buffer until CX runs down.		;RET									;DumpCSBlock	ENDP;-- ;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------UnknownBlock		PROC	NEARUnkBlock:		PUSH	bootingError			PUSH	unKnownBootBlock			%Jam	(BootStrapHandlerID,OFFSET bootTask)			%WaitForSystem				;never returns!									UnknownBlock		ENDP;-- 			;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------NoRAMOpieEntryPoint	PROC	NEARNoStart:		PUSH	bootingError			PUSH	noRAMStartAddress			%Jam	(BootStrapHandlerID,OFFSET bootTask)			%WaitForSystem				;never returns!									NoRAMOpieEntryPoint	ENDP;-- 			;-- ;-- ;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|								|;--------------|	AX = input data left justified.				|;--------------|	CX = count of data to shift.				|;--------------|								|;--------------|--------							|;--------------|								|;--------------|	DX was trashed here.					|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;ShiftDataToCS		PROC	NEAR;ShiftDataToCS:		MOV	DX, AX		;We want to rotate the data so that			;ROL	DX, Nibble	;we can shift it out a bit at time 						;from the 5-th bit which is the LSB.;DataShiftLoop:		MOV	AX, ((CSInputBitMask SHL 8) OR CSToggleBit) ;We have			;AND	AH, DL		;the data into control store one bit			;OR	AL, AH		;at a time. So we shift the appropriate			;OUT	CPoutputPort, AL ;bit to bit five in DX which corresponds			;MOV	AL, notCSToggleBit ;to the correct bit for the output 			;OR	AL, AH		;port and then do the appropriate 			;OUT	CPoutputPort, AL ;toggling to get the bit accepted.			;ROR	DX, oneBit	;Get the next bit ready.			;LOOP	DataShiftLoop	;We will loop until all the bits						;are sent!			RET									 							;ShiftDataToCS		ENDP;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI^ = BootBlock.Address					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;WriteSiriusStartAddress	PROC	NEAR						;MOV	CX, CSaddressLoopCount;GetCPStartAddress:	CALL	IncrementSI					;MOV	AH, ES: [BX][SI]	 			;CALL	IncrementSI					;MOV	AL, ES: [BX][SI]			;PUSH	AX			;LOOP	GetCPStartAddress								;MOV	AL, loadShiftRegister			;OUT	CPoutputPort, AL			;MOV	AX, parityInterruptTrapFlags			;MOV	CX, CPflagsBitCount			;CALL	ShiftDataToCS			;MOV	CX, dataWordBitCount			;POP	AX			;CALL	ShiftDataToCS			;MOV	CX, dataWordBitCount*CSsizeWordCount			;CALL	ShiftDataToCS		;Data here is garbage.			;POP	AX			;CALL	ShiftDataToCS			;MOV	AL, notLoadShiftRegister			;OUT	CPoutputPort, AL						;RET						;WriteSiriusStartAddress	ENDP;-- 			;-- Boot section #;--------------  This procedure gets called after the virtual memory map has;--------------  been initialized, map registers set. Its task is to load the ;--------------  Loader in the specified virtual memory location then we are;--------------  ready to give up booting ghost!;-------------- ;-------------- ;--------------|	loaderVMLocBase = loaders base location in virtual 	|;--------------|	  memory a 32-bit word containing virtual memory jmm????|;--------------|	  address should have been set up at VMM initialization.|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------ProcessLoaderFile	PROC	NEARDoLoaderFile:		POP	AX				;Clean the stack.			MOV	ES: [BX].bootDataStart, Null	;We are done loading the			 			MOV	ES: [BX].bootDataEnd, Null	;emulator so release buffer.			MOV	BX, startOfBootBufferPool	;This is a new file so start			MOV	currentBootBuffer, BX		;processing buffers anew.			CMP	bootType, normal		;If it is a diagnostics boot			JE	GoGetTheLoaderFile		;we are done, otherwise we 			JMP	BootFadeOut			;should go get the loader file.						;Outstanding issue - termination of communcation here when doing			;ethernet diagnostics booting.			GoGetTheLoaderFile:	%NotifyCondition (OFFSET getBootFile)			%NotifyCondition (OFFSET bootBufferEmpty)			;display mp code for fetching MesaDove			MOV	AX, mpFetchMesaDove			CALL	DisplayMPCode			ThereMightBeSomeMore:	%WaitForCondition (OFFSET bootBufferFull,loaderTimeout)			JNC	MoreLoader			;if not timed out			%WaitForCondition (OFFSET finishedLoaderFileFetch,loaderTimeout)			JC	ThereMightBeSomeMore		;if timed out			JMP	BootFadeOut			MoreLoader:		MOV	BX, currentBootBuffer		;Every time we get a new buffer 			MOV	SI, ES: [BX].bootDataStart	;we have to first check that it			CMP	SI, ES: [BX].bootDataEnd	;is really empty before we start			JE	ThereMightBeSomeMore		;processing it.			PUSH	ES									%EstablishIOPAccess	(generalMapRegister,loaderVirtualMemoryLocation)			INC	WORD PTR loaderVirtualMemoryLocation			MOV	DX, ES			POP	ES			PUSH	DS			MOV	DS, DX			ASSUME	DS:NOTHING			MOV	CX, ES: [BX].bootDataEnd	;We will load a page of the germ at			SUB	CX, ES: [BX].bootDataStart	;a time.			INC	CX							ADD	SI, BX			WriteAPageOfLoader:	MOV	AL, ES: [SI]			MOV	DS: [DI], AL			INC	DI			INC	SI			LOOP	WriteAPageOfLoader			POP	DS			ASSUME	DS:BootStrapIOR			MOV	BX, currentBootBuffer		 			MOV	ES: [BX].bootDataStart, Null				MOV	ES: [BX].bootDataEnd, Null				MOV	BX, ES: [BX].nextBootBuffer				MOV	currentBootBuffer, BX			%NotifyCondition (OFFSET bootBufferEmpty)			JMP	MoreLoader											ProcessLoaderFile	ENDP;-- 						;-- 			;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------BootFadeOut		PROC	NEARBootDone:		MOV	AX, mpRunMesaDove			CALL	DisplayMPCodeStartRam:		JMP	DWORD PTR jumpTable.startRAMOpie ;Boot task should be jammed by 							;the RAMOpie task that is being loaded.						BootFadeOut		ENDP;-- 						;-- Boot section #;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|								|;--------------|	AL = BootBlock.Type.lowByte.				|;--------------|	BX = pointer to the buffer to process.			|;--------------|	SI = BootBlock.Type					|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------ProcessMultipleDBsFile	PROC	NEARDoMultipleDBsFile:	POP	AX				;Clean the stack.			CMP	skipUserInterface, normal ;Is this first time?			JNE	MoveReentryPointToJumpTable ;If not, parms are set			MOV	bootOverlayRequest, 1	;else default to 1			JMP	SHORT LoadOverlayNumberMoveReentryPointToJumpTable:			MOV	DI, bootOverlayReentry	;Monitor has set up a			MOV	jumpTable.startRAMOpie, DI ;reentry point for			MOV	DI, bootOverlayReentry+2 ;overlay booting to use,			MOV	jumpTable.startRAMOpieCS, DI ;so move it to jump tableLoadOverlayNumber:	MOV	DI, bootOverlayRequest			%MultiplyByTwo (DI) 			MOV	SI, ES: [BX].bootDataStart ;We may now fetch the offset of			ADD	DI, SI			;the diagnostics boot file desired.			MOV	AH, ES: [BX][DI]	;We want the n-th *.db file in this boot			MOV	AL, ES: [BX][DI]+1	;file so let's get its offset.			MOV	DI, AX			XOR	DL, DL			;table has word offset --			SHL	DI, 1			;change to byte offset			RCL	DL, 1			;with overflow in DL.IsOurDBInThisBuffer:	MOV	AX, ES: [BX].bootDataEnd			SUB	AX, SI			;Get the size of the buffer and check			INC	AX			MOV	CX, AX			;to see if this is the buffer that the			CMP	DL, 0			JNE	TryNextBuffer			SUB	AX, DI			;desired db file is in. If it is we want			JNC	TheWantedDBIsHere	;to go keep processing it as normal.			TryNextBuffer:		SUB	DI, CX			SBB	DL, 0			MOV	ES: [BX].bootDataStart, Null						MOV	ES: [BX].bootDataEnd, Null			CALL	PrepareToFetchBuffer			JMP	IsOurDBInThisBufferTheWantedDBIsHere:	ADD	SI, DI			;We now have the offset of the file we			JMP	StartSequence		;have been looking for.												ProcessMultipleDBsFile	ENDP;-- ;  Space could be saved by using the version of this proc that lives in ROM.;;DisplayMPCode -- Call this to put a number into the curser as an MP code.;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;--------------|								|;--------------|	AX = mp code to be displayed				|;--------------|								|;--------------|--------							|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------DisplayMPCode	PROCRamDispMPCode:	PUSH	ES		PUSHA		PUSH	AX		%EstablishHandlerAccess	(MaintPanelHandlerID)		POP	AX		ASSUME	ES:MaintPanelIOR		MOV	maintPanelCode, AX		%NotifyHandlerCondition	(MaintPanelHandlerID,OFFSET maintPanelChanged)		%WaitForSystem		POPA		POP	ES		ASSUME	ES:IOPELocalRAM		RETDisplayMPCode	ENDP;-- ;-- ;-- ;-- Determination of control store configuration:;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	No assumptions						|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------|								|;--------------| Upon return:							|;--------------|	csBankConfiguration is set as follows:			|;--------------|	  four K control store		=>  1			|;--------------|	  eight K control store		=>  2			|;--------------|	AX smashed						|;--------------|	BX smashed						|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;csBankConfiguration	DB	0		;This will go into IORegion.;GetCSBankConfig	PROC	NEAR			;Figure out how much control store we have.			;This code could be moved into an IOP initial to save 			; Local ram space.;GetCSBankCfg:		%'ReadEEProm(eePromMemSize, 1)	;AX  virt mem,,eeprom.			;JNC	GoodEEProm		;Check eeprom validity.;fourKEEPromFormat	EQU	10H			;MOV	AX, fourKEEPromFormat	;Default is 1 bank.;GoodEEProm:		AND	AL, 0F0H		;Get rid of VM size.			;MOV	CS: csBankConfiguration, AL	;Save it for later.			;RET			;GetCSBankConfig		ENDP;-------------------------------------------------------------------------------;-- ;-- ;-- ;-- LoadAXFromBootBuf --.;--;This procedure just loads AX from the boot buffer byte at a time calling the; procedure IncrementSI to move the pointer along.  This assures that the end; of the boot buffer will be detected and handled correctly.;;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	ES:[BX][SI]  	byte before the first we want		|;--------------|--------							|;--------------|								|;--------------| Upon return:							|;--------------|	ES:[BX][SI] 	2 bytes further in the stream.		|;--------------|	AX loaded from ES:[BX][SI]				|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------LoadAXFromBootBuf		PROC		NEAR			CALL	IncrementSI		;LoadAXFromBootBufLateEntry:			MOV	AH, ES: [BX][SI]	;			CALL	IncrementSI		;			MOV	AL, ES: [BX][SI]	;			RET		LoadAXFromBootBuf		ENDP;-------------------------------------------------------------------------------;-- ;-- ;-- ;-- LoadCXFromBootBuf --.;--;This procedure just loads CX from the boot buffer byte at a time calling the; procedure IncrementSI to move the pointer along.  This assures that the end; of the boot buffer will be detected and handled correctly.;;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|	ES:[BX][SI]  	byte before the first we want		|;--------------|--------							|;--------------|								|;--------------| Upon return:							|;--------------|	ES:[BX][SI] 	2 bytes further in the stream.		|;--------------|	CX loaded from ES:[BX][SI]				|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;LoadCXFromBootBuf		PROC		NEAR			;CALL	IncrementSI		;;LoadCXFromBootBufLateEntry:			;MOV	CH, ES: [BX][SI]	;			;CALL	IncrementSI		;			;MOV	CL, ES: [BX][SI]	;			;RET		;LoadCXFromBootBuf		ENDP;-------------------------------------------------------------------------------		EVENEndOfInitial	EQU	$			IOPEInRAM		ENDS			;********************************************************************************									END
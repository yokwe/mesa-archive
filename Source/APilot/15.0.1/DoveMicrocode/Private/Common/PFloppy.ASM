$DEBUG MOD186$PAGELENGTH (72)$PAGEWIDTH (136); Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;; PFloppy.asm; Created by GPV, 12-Dec-84;; Last edited by:;-- VGP	 22-Nov-85  9:59:29	: Added comments deleted PUSHA;-- AGK	 15-Nov-85 12:27:44	: Renamed LoadMagicByte to LoadMagic;-- VGP	  9-Oct-85 11:03:17	: Use Hi Lo Kludge for now;-- VGP	  8-Oct-85 13:19:17	: Use DX as temp reg for addr. checking;-- VGP	  4-Oct-85 17:28:57	: Un-commented Address range checking;-- VGP	 18-Sep-85  9:09:05	: Inserted pDMAOverRun label & JZ;-- VGP	 16-Sep-85 17:24:52	: Attempt DMA overrun retry;-- JPM	 23-Aug-85 13:13:02	: Save/restore AX in QandDQIOCB (hurts reset, at least);-- JPM	 22-Aug-85 17:07:27	: Delete PFloppyIO, move its functions into task loop;-- JPM	 22-Aug-85 14:56:34	: Fix bug in InitIOCB, set some IOCB fields in QandDQIOCB;-- JPM	 13-Aug-85 16:57:41	: Separate PCE into several handlers;-- GPV	 12-Aug-85 13:05:38	: uses new IOCB with PCEResetFDCFlag & PCEStartMotorFlags etc;-- JPM	 12-Aug-85 12:16:28	: Change IOPEInRAM alignment to WORD;-- JPM	  9-Aug-85 16:04:42	: Opie redesign conversion;-- GPV	  2-Aug-85 10:56:29	: CLC in SetupAddr;-- GPV	 31-Jul-85 11:36:52	: In SetupAddr compare with pceDMAReadCommand;-- GPV	 25-Jul-85 18:07:49	: Verify command updates;-- GPV	 24-Jul-85 16:12:31	: using new scheme to twiggle runPCE;-- GPV	 23-Jul-85 11:41:08	: Changed pause duration from 5 to 0.5 sec;-- GPV	 22-Jul-85 13:34:09	: Added PCEFloppyBoot & PCEFloppyExit procs;-- GPV	 16-Jul-85 14:30:17	: Faked ResultByte2 for FDCHung, runPCE¬0 for Virtual floppy;-- GPV	 12-Jul-85 16:07:37	: Check for OperationCompleted to detect timeout's;-- GPV	 11-Jul-85 22:07:49	: Introduced runPCE twiggling;-- GPV	 11-Jul-85 19:02:06	: BUG Fixes, No multiple Ints to PC, WriteOP fixed,;-- GPV	 10-Jul-85 17:05:31	: Introduced debugging code;-- GPV	  1-Jul-85 16:54:36	: Re-commented out address checking;-- GPV	 24-Jun-85 15:02:09	: Changed name to PFloppy.asm;-- GPV	 21-Jun-85 18:03:26	: using new FloppyPCEReset & FloppyPCEStartMotor;-- GPV	 14-Jun-85 13:14:50	: introduced a check for FDCHung;-- GPV	 29-May-85 15:04:43	: changed pFDCDriveNumberPresent so that SenseIntStatus command is faked to have drive # specified;-- GPV	 22-May-85 10:05:34	: deleted PCEMacro.asm inclusion;-- GPV	 17-May-85 10:27:14	: update upnotify to reflect dispatcher changes;-- GPV	 16-May-85 11:52:23	: Incorporate up notification of VFD's;-- AGK	 23-Apr-85 11:51:39	: Put external floppy procs in IOPEInRom;-- AGK	 15-Apr-85 16:28:04	: Changed PCEFloppyInit from FAR to NEAR;-- GPV	 8-Apr-85 11:30:28	: Updated to incorporate Opie19 related changes in FlopFace.asm;-- GPV	 1-Apr-85 16:50:13	: Inc dma data xfer word by 1;-- GPV	16-Mar-85 11:48:03	: New version tested against BIOS;-- AGK	 7-Feb-85 21:30:53	: Renamed MainLoop to pceFloppyTaskInit;-- GPV	12-Dec-84		: Creation	NAME	PFloppyEmulator	;------------------------------------------------------------------------------$NOLIST$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPDefs.asm);INCLUDE	(PFlpDefs.asm)$INCLUDE	(FlopFace.asm)$INCLUDE	(QueDefs.asm)$INCLUDE	(QueMacro.asm)$INCLUDE	(PCEDefs.asm)$INCLUDE	(IOPMacro.asm)$LISTEXTRN	PCEFloppyHandlerID:	ABSEXTRN	PCEDispatcherHandlerID:	ABSEXTRN	PCEDMAHandlerID:	ABSEXTRN	FloppyHandlerID:	ABS;------------------------------------------------------------------------------;	Tables and other constants;; States of the handlerpFlopInit	EQU	0	;pFlopCmndRcvd	EQU	1	;pFlopParmsRcvd	EQU	2	;pFlopIOCBEnqued	EQU	3	;pFlopUpNotified	EQU	4	;pFlopSendResults	EQU	5	;; FDC related datapAddrDOR	EQU	3F2H	; Digital Output RegisterpFDCMainStatReg	EQU	3F4H	; Main Status Reg of the FDCpFDCDataReg	EQU	3F5H	; Data register of the TCDpFDCNotReady	EQU	000H	; RQM=0, DIO=0pFDCRecvMode	EQU	80H	; RQM=1, DIO=0pFDCSendMode	EQU	0C0H	; RQM=1, DIO=1pFDCBusy	EQU	010H	; Bit 5pDORDriveSelect	EQU	00000011B	; Bits 0&1pDORSetResetBit	EQU	00000100B	; Bit 2pDORIntPC	EQU	00001000B	; Bit 3pDORMotorOnBits	EQU	11110000B	;pRMQBit		EQU	10000000B	;pFlopLow5Bits	EQU	00011111B	;pFDCRMQResetMask	EQU	01111111B	; To reset RMQ bit of MSR;pFDCIntCode	EQU	11000000B; High bits ON for ST0 checkpFDCAbnormalTermination	EQU	01000000B; high bits = 01 for this errorpFDCOverRunError	EQU	00010000B;  Bit 4 for a DMA overrun problempFDCCRCError	EQU	01100000B;  bit 5 implies CRC error, set bit 6 for IOP debugging benifit; Command codes pFDCReadData	EQU	6H	;pFDCReadDeleData	EQU	0CH	;pFDCWriteData	EQU	5H	;pFDCWriteDelData	EQU	9H	;pFDCReadTrack	EQU	2H	;pFDCReadId	EQU	0AH	;pFDCFormatTrack	EQU	0DH	;pFDCScanEqual	EQU	11H	;pFDCScanLoEq	EQU	19H	;pFDCScanHiEq	EQU	1DH	;pFDCRecalib	EQU	7H	;pFDCSenseInt	EQU	8H	;pFDCSpecify	EQU	3H	;pFDCSenseDrive	EQU	4H	;pFDCSeek	EQU	0FH	;; Number of parameters for each of the above commandspFDCReadDataSz		EQU	8	;pFDCReadDeleDataSz	EQU	8	;pFDCWriteDataSz		EQU	8	;pFDCWriteDelDataSz	EQU	8	;pFDCReadTrackSz		EQU	8	;pFDCReadIdSz		EQU	1	;pFDCFormatTrackSz	EQU	5	;pFDCScanEqualSz		EQU	8	;pFDCScanLoEqSz		EQU	8	;pFDCScanHiEqSz		EQU	8	;pFDCRecalibSz		EQU	1	;pFDCSenseIntSz		EQU	0	;pFDCSpecifySz		EQU	2	;pFDCSenseDriveSz	EQU	1	;pFDCSeekSz		EQU	2	;; Number of results returned by FDC for each of the above commandspFDCReadDataResult	EQU	7	;pFDCReadDeleDataResult	EQU	7	;pFDCWriteDataResult	EQU	7	;pFDCWriteDelDataResult	EQU	7	;pFDCReadTrackResult	EQU	7	;pFDCReadIdResult	EQU	7	;pFDCFormatTrackResult	EQU	7	;pFDCScanEqualResult	EQU	7	;pFDCScanLoEqResult	EQU	7	;pFDCScanHiEqResult	EQU	7	;pFDCRecalibResult	EQU	0	;pFDCSenseIntResult	EQU	2	;pFDCSpecifyResult	EQU	0	;pFDCSenseDriveResult	EQU	1	;pFDCSeekResult		EQU	0	;HighBit			EQU	10000000B; MSB is on; Error values to be reported used for debugging onlyNoError		EQU	0IllegalCommand	EQU	1IllegalAddr	EQU	2;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; The equates below are used for setting up the various; FDC-command dependent parameters of the IOCB.; There is a one to one correspondence between the bits; in these equates and the list of commands in pFDCCommandList.; Bit 0 (LSB) corresponds to the first command in pFDCCommandList; bit 1 to the second command...bit 15 to last command.; eg. bit 0 of pFDCIntExpected is 1 to indicate; that the first command in pFDCCommandList (fdcSeekCommand); will generate an interrupt.pFDCIntExpected	EQU	111111101001111B; 1 implies int expectedpFDCDriveNumberPresent	EQU	111111111101111B; 1 implies 2nd parameter contains drive number; The IOCB's datatransfer codes are;  0 - no data transfer;  1 - read operation;  2 - write operation; The 2 equates below are used to set up the dataxfer code; IF bit in pFDCDataXferCode1 is 0 implies no data xfer; IF bit in pFDCDataXferCode1 is 1 implies read/write; IF bit in pFDCDataXferCode2 is 1 implies writepFDCDataXferCode1	EQU	110001000001110B; 1 implies Data tranfer is expected for these commandspFDCDataXferCode2	EQU	100000000001100B; 1 implies write commandStartDMAVerify		EQU	08266H; same as StartDMARead, but autoincrement is turned offpceDMAModeReg		EQU	11-8 ; since port 11 of PC corresponds to pceDMAControl[0]pceDMACommandBits	EQU	0CH  ; 00001100DummyPCEAddr		EQU	0443H  ; unused PC Data area of BIOS.pceDMAReadCommand	EQU	00000100B; see DMA mode reg. cmnd bits ;--------------------------------------------------------------------------------PCEFloppyIOR		SEGMENT		COMMONEXTRN	pceFloppyTask:		TaskContextBlockEXTRN	pceFloppyWorkMask:	WORDEXTRN	pceFloppyConditionWork:	ConditionEXTRN	pceFloppyWaitIO:	ConditionEXTRN	pceFloppyHandlerDone:	ConditionEXTRN	pceFloppyEmulatorState:	BYTEEXTRN	pceFloppyEmulatorParamCount:	BYTEEXTRN	pceFlopIndex:		BYTEEXTRN	pceDriveNumberSpecified: BYTEEXTRN	pDOR:			BYTEEXTRN	pFDCMSR:		BYTEEXTRN	pceHasRealDrive:	BYTEEXTRN	pFlopLogicalDrive:	BYTEEXTRN	pFDCRealDrive:		BYTEEXTRN	pDORRealDrive:		BYTEEXTRN	pceFloppyIOCB:		IOCBEXTRN	pFlopError:		BYTEEXTRN	pFlopMemorySizeHi:	WORDEXTRN	pFlopMemorySizeLo:	WORDEXTRN	pFlopDriveNumber:	BYTEPCEFloppyIOR		ENDSPCEDispatcherIOR	SEGMENT		COMMON EXTRN	ioTrappedData:		WORDEXTRN	ioTrappedAddress:	WORDEXTRN	ioTrappedStatus:	WORDEXTRN	runPCE:			BYTEPCEDispatcherIOR	ENDSPCEDMAIOR		SEGMENT		COMMONEXTRN	pceDMA80:		BYTEEXTRN	pceDMAData:		BYTEEXTRN	pceDMAControl:		BYTEPCEDMAIOR		ENDS;------------------------------------------------------------------------------FloppyIOR	SEGMENT		COMMON EXTRN	Floppy80186Queue:	QueueBlockEXTRN	FloppyWorkNotify:	ConditionFloppyIOR	ENDS;------------------------------------------------------------------------------PCEFloppySTK	SEGMENT		COMMON EXTRN	pceFloppyStack:		WORDPCEFloppySTK	ENDS;------------------------------------------------------------------------------PUBLIC	PCEFloppyInit, PCEFloppyBoot, PCEFloppyExit;------------------------------------------------------------------------------IOPEInRam	SEGMENT	WORD PUBLIC		ASSUME CS: IOPEInRam		EXTRN	LoadMagic: NEAREXTRN	PCEMesaClientNotify: NEAR;------------------------------------------------------------------------------;  PCEFloppyInitPCEFloppyInit PROC	FAR	%InitializeTask	(PCEFloppyHandlerID,OFFSET pceFloppyTask, pceFloppyTaskInit,OFFSET pceFloppyStack)	; Init task	RETPCEFloppyInit	ENDPpceFloppyTaskInit:	ASSUME	DS:PCEFloppyIOR	%GetWorkMaskForCondition (OFFSET pceFloppyConditionWork)	MOV	pceFloppyWorkMask, AX	%Jam (PCEFloppyHandlerID,OFFSET pceFloppyTask)	; but don't let it run yet	%WaitForSystem			; (delayed jam)	ASSUME	DS:NOTHING;------------------------------------------------------------------------------;  PCEFloppyBootPCEFloppyBoot PROC	NEAR	PUSH	DS	%EstablishHandlerAccess	(PCEFloppyHandlerID)	MOV	AX, ES	MOV	DS, AX	ASSUME	DS:PCEFloppyIOR	CALL	InitIOCB	CALL	ResetIOCB	CALL	InitializeHandler	POP	DS	ASSUME	DS:NOTHING	%Restart	(PCEFloppyHandlerID,OFFSET pceFloppyTask, pceFloppyTaskEmul,OFFSET pceFloppyStack)	RETPCEFloppyBoot	ENDP;------------------------------------------------------------------------------;  PCEFloppyExitPCEFloppyExit PROC	NEARPCEFloppyExitLb:	%EstablishHandlerAccess	(PCEFloppyHandlerID)	ASSUME	ES:PCEFloppyIOR	CMP	pceFloppyEmulatorState, pFlopIOCBEnqued ; IO in Progress?	JNE	OkayToJam	; No! so go ahead and jam the task	%WaitForTime (500)	; 0.5 seconds	JMP	SHORT PCEFloppyExitLb ; check again if IO has completed.	OkayToJam:	%Jam	(PCEFloppyHandlerID,OFFSET pceFloppyTask)	RET	ASSUME	ES:NOTHINGPCEFloppyExit	ENDP;------------------------------------------------------------------------------	ASSUME	DS:PCEFloppyIOR		;following procs called locally;------------------------------------------------------------------------------; InitializeHandler; Init Floppy Emulator State to state S0, DOR = 00H, MSR = 80H, PCE has real drive; Registers Affected: AXInitializeHandler	PROC	NEAR	InitializeHandlerLb:	MOV	pceFloppyEmulatorState,pFlopInit	; Initial state is S0	MOV	pFDCMSR, pFDCRecvMode		; FDC is ready to receive cmnds	MOV	pceFlopIndex,0	; 	MOV	pFlopError, NoError;	MOV	pceHasRealDrive,MesaTRUE	RET	InitializeHandler	ENDP ;------------------------------------------------------------------------------; SetupMSR; Set up MSR to reflect state of the FDC; Start with RQM = 0 and DIO = 0; If seek command then set DnB in MSR (n = A,..,D); If data transfer occurs set CB in MSR; Registers Affected: AL, BX, CLSetupMSR PROC	NEARSetupMSRLb:		 	MOV	BL,pFDCNotReady		; Reset RQM and DIO bits; set up other bits of MSR to reflect state of the FDC	CMP	pceFloppyIOCB.fdcCommands.CommandBytes, fdcSeekCommand	JNE	NotSeekMode ;		  ; set up the seek bit in MSR that corresponds to drive number	MOV	CL, pFlopDriveNumber ; 	MOV	BH,1	;	SHL	BH,CL	; appropriate bit gets 1	OR	BL,BH	; update BL	JMP	SHORT	SetupMSREnd; NotSeekMode:; Set up FDC busy bit	CMP	pceFloppyIOCB.fdcCommands.DataTransferCode,0	JZ	SetupMSREnd ; FDC busy bit is set iff data xfer occurs 	OR	BL, pFDCBusySetupMSREnd:  	MOV	pFDCMSR, BL	RETSetupMSR	ENDP ;------------------------------------------------------------------------------; SetupAddr  - Sets up address for the data Xfer; The PCE-186 programs the DMA with the address and byte; count for the data transfer. This routine converts the; address into a Opie address of type PCLogical and sets; up the transfer count in the IOCB. This routine also sets-up; FirstDMAcontrolWord to reflect Read/Write/Verify operation.   ; Registers Affected: AX, BX, CXSetupAddr	PROC	NEARSetupAddrLb:	PUSH	ES	CMP	pceFloppyIOCB.fdcCommands.DataTransferCode,None	JZ	SetupAddrEnd ; no data xfer so skip address setup;Get access to DMA words	%EstablishHandlerAccess	(PCEDMAHandlerID)	ASSUME	ES:PCEDMAIOR; 1) Get the high 4 bits of the PC address from pceDMA80[pceDMAFloppyPage]; 2) Get the low 16 bits of the address and byte count from the DMA FCB;Load CX with high 4 bits of the 20 bit PCE addressContSetupAddr:	XOR	CX,CX	; A word is used even though only 4 bits are significant	MOV	CL,pceDMA80[pceDMAFloppyPage] ; get high 4 bits of address;Load AX with the low 16 bits of address and BX with the byte count	MOV	AX, WORD PTR pceDMAData[pceDMAFloppyAddr]; get lo 16 bits of address	MOV	BX, WORD PTR pceDMAData[pceDMAFloppyByteCount]; get byte count of the xfer; Make sure the address cum byte count are legal.; Legal implies - ;  1) During the data xfer the address should not cross 64K boundary and;  2) the address plus the byte count should not exceed the;      memory allocated for a given PCE session	MOV	DX,AX	; use DX as a temp reg for doing range checking	ADD	DX,BX	; to yield max memory location accessible	JNC	NoOverFlow	JMP	SHORT	AddrTooLarge; IO shouldn't cross 64K boundaryNoOverFlow:	CMP	CX, pFlopMemorySizeHi ;;	CMP	CX, pFlopMemorySizeLo ; Kludge should actally be pFlopMemorySizeHi	JB	AddrOk	JA	AddrTooLarge		  ; The high bits are equal so see if low bits are okay	CMP	DX, pFlopMemorySizeLo ;;	CMP	DX, pFlopMemorySizeHi ; Kludge should actally be pFlopMemorySizeLo	JA	AddrTooLarge AddrOk:; the address is okay so set up the IOCB	MOV	pceFloppyIOCB.DataAddress.OpieAddressA15toA0,AX	MOV	pceFloppyIOCB.DataAddress.OpieAddressA23toA16,CL		  	INC	BX	; for a 512 byte xfer the PC programs its DMA to 511			; but our DMA chip requires 512 	MOV	pceFloppyIOCB.TotalBytesToTransfer,BX	MOV	pceFloppyIOCB.FirstDMAtransferCount,BX	MOV	pceFloppyIOCB.CounterControlRegister, StartCounter;-----------------------------------------------------------------------; Check if it is a verify operation; The DMA chip on the PC can be programmed to do a verify ; but the 6085 DMA chip does not support this.; The equivalent effect is acheived by programming our; DMA to not autoincrement the destination address.; This causes all the data from the floppy to be xfered; to one location in memory, which approximates what the; PC's DMA does.;; 1) Read the mode register in the DMAFCB; 2) If is a verify operation then set up FirstDMAcontrolWord to do a verify (ie. read without autoincrement) and set-up a dummy address; 3) For Reads and Writes set up FirstDMAcontrolWord appropriately 	MOV	AL, pceDMAControl[pceDMAModeReg];  get the mode reg	AND	AL, pceDMACommandBits; isolate the DMA command bits	CMP	AL, pceDMAReadCommand	JL	VerifyOperation	JG	WriteOperation;-----------------------------------------------------------------------ReadOperation:	MOV	pceFloppyIOCB.FirstDMAcontrolWord , StartDMARead	JMP	SHORT	SetupAddrEndVerifyOperation:; 80186 DMA controller has no verify, so fake it by doing a read,; but without autoincrement so we don't clobber memory	MOV	pceFloppyIOCB.FirstDMAcontrolWord, StartDMAVerify	MOV	pceFloppyIOCB.DataAddress.OpieAddressA23toA16, 0	MOV	pceFloppyIOCB.DataAddress.OpieAddressA15toA0, DummyPCEAddr	JMP	SHORT	SetupAddrEndWriteOperation:	MOV	pceFloppyIOCB.FirstDMAcontrolWord , StartDMAWrite	JMP	SHORT	SetupAddrEndAddrTooLarge:	MOV	pFlopError, IllegalAddr	STC	;to indicate error	POP	ES	RETSetupAddrEnd:	CLC	POP	ES	RET	ASSUME	ES:NOTHINGSetupAddr	ENDP ;------------------------------------------------------------------------------; InitIOCB; Initializes ClientCondition, OpieAddresses and other fields of pceFloppyIOCB; Registers Affected: NoneInitIOCB PROC	NEARInitIOCBLb:	; Tailor fields to PCE specfic needs	MOV	pceFloppyIOCB.ActualClientCondition.handlerID, LOW PCEFloppyHandlerID;	MOV	pceFloppyIOCB.ActualClientCondition.conditionPtr, OFFSET pceFloppyHandlerDone + nonNilPtr;	MOV	pceFloppyIOCB.ActualClientCondition.clientMask, 0;	MOV	pceFloppyIOCB.NextIOCB.OpieAddressType, nilOpieAddress; Only one IOCB at a time from PCE	MOV	pceFloppyIOCB.DataAddress.OpieAddressType, PCLogicalOpieAddress	MOV	pceFloppyIOCB.NumberOfMiddleDMAtransfers,0 ; No page boundary check needed in PCE address space		MOV	pceFloppyIOCB.NumberOfFDCCommands, 1; Since PCE always sends only one command	MOV	pceFloppyIOCB.SpecifyBeforeProcessing, MesaFALSE; PCE does explicit resetting	MOV	pceFloppyIOCB.ResetFDCBeforeProcessing, MesaFALSE; PCE does explicit resetting		MOV	pceFloppyIOCB.RecalibrateBeforeProcessing, MesaFALSE; PCE does explicit recalibs; set up a few global IOCB variables	MOV	pceFloppyIOCB.FDCHung,MesaFALSE; 	MOV	pceFloppyIOCB.fdcCommands.CommandBytes[2], 0; -- make sure any residual drive # is clobbered at FDC reset.	RETInitIOCB	ENDP ;------------------------------------------------------------------------------; ResetIOCB; Reset some fields of the IOCB	; Registers Affected: AXResetIOCB PROC	NEARResetIOCBLb:	MOV	pceFloppyIOCB.OperationIsQueued, MesaFALSE	MOV	pceFloppyIOCB.OperationState,OperationWaiting	MOV	pceFloppyIOCB.fdcCommands.DataTransferCode,0	MOV	pceFloppyIOCB.fdcCommands.MustWaitForInterrupt,MesaFALSE	MOV	pceDriveNumberSpecified,MesaFALSE	RETResetIOCB	ENDP ;------------------------------------------------------------------------------; QandDQIOCB; 1) enqueue the IOCB; 2) Notify the floppy handler that the IOCB has been queued; 3) Wait till the IOCB is processed; 4) DeQueue the IOCB	QandDQIOCB PROC	NEARQandDQIOCBLb:	PUSH	ES	PUSH	AX	%EstablishHandlerAccess	(FloppyHandlerID)	ASSUME	ES:FloppyIOR	MOV	pceFloppyIOCB.OperationIsQueued, MesaTRUE	;tell floppy handler it's enqueued	MOV	pceFloppyIOCB.OperationState,OperationWaiting	; and waiting	MOV	DX, OFFSET pceFloppyIOCB ; Set up CX:DX to the opie address	MOV	CL, LOW PCEFloppyHandlerID ; that points to the IOCB	MOV	CH, IOPIORegionOpieAddress;	%EnQueue	(Floppy80186Queue,NextIOCB,preserveES)	;	%NotifyHandlerCondition	(FloppyHandlerID,OFFSET FloppyWorkNotify)	; get the handler going	%WaitForCondition	(OFFSET pceFloppyHandlerDone,noTimeout); wait for handler to complete	%DeQueue	(Floppy80186Queue,NextIOCB,preserveES) ;	POP	AX	POP	ES	RET	ASSUME	ES:NOTHINGQandDQIOCB	ENDP ; ;------------------------------------------------------------------------------; CheckErrors; Check for sucessful FDC operation; If FDCHung or Timeout then fake a CRC error; If a DMA overrun occurs set the CF; Clear CF for all other errors; ; Registers Affected: ALCheckErrors PROC	NEARCheckErrorsLb:	CMP	pceFloppyIOCB.OperationState, OperationCompleted ; any failure?	JE	GoodCompletion	CMP	pceFloppyIOCB.FDCHung, MesaTRUE ; -- check for a prob. with hanlder/controller	JNE	MaybeTimeOut	; may be a timeout pb.FDCHungLb:	JMP	SHORT BadCompletionMaybeTimeOut:	CMP	pceFloppyIOCB.TimeoutOccurred,  MesaTRUE ;	JNE	BadCompletionTimeoutOccurredLb:	NOPBadCompletion:; some problem, so set the high bits of ST0 to abnormal termination; This should force the PC program to do a retry	AND	pceFloppyIOCB.fdcCommands.ResultBytes, NOT pFDCIntCode; zap out error bits of ST0	OR	pceFloppyIOCB.fdcCommands.ResultBytes, pFDCAbnormalTermination;	OR	pceFloppyIOCB.fdcCommands.ResultBytes[1], pFDCCRCError; -- fake a CRC error	JMP	SHORT CheckErrorsEnd	GoodCompletion:; implies No FDC failure, but could have encountered data xfer errors	CMP	pceFloppyIOCB.fdcCommands.NumberOfResultBytesRead, 0	JZ	CheckErrorsEnd; FDC has given us some result bytes so check for DMA overrun	MOV	AL, pceFloppyIOCB.fdcCommands.ResultBytes	AND	AL, pFDCIntCode	CMP	AL, pFDCAbnormalTermination	JNZ	CheckErrorsEnd; FDC command failed. See if it is DMA over prob	TEST	pceFloppyIOCB.fdcCommands.ResultBytes[1], pFDCOverRunError	JZ	CheckErrorsEndpDMAOverRun:	STC	RETCheckErrorsEnd:	CLC	RETCheckErrors 	ENDP;;------------------------------------------------------------------------------; NotifyPCE ; FDC has returned the results; If result bytes returned then;   (1) Change state to SendResults;   (2) RQM=1, DIO=1 in MSR;   else reset handler and IOCB; Interrupt PCE; Registers Affected: AX, DXNotifyPCE PROC	NEARNotifyPCELb:	CMP	pceFloppyIOCB.fdcCommands.NumberOfResultBytesRead,0	JZ	NoResultPhase; Result bytes have to be shipped to the PC	MOV	pceFloppyEmulatorState, pFlopSendResults ; set up new state	MOV	pFDCMSR, pFDCSendMode; indicate FDC ready to send result bytes	OR	pFDCMSR, 10H ; This bit is reset when all result bytes are read	MOV	pceFlopIndex,0	; the index is used when an IN DR occcurs	CALL	IntPCE	JMP	SHORT	NotifyPCEEndNoResultPhase:	CALL	IntPCE	CALL	InitializeHandler	CALL	ResetIOCBNotifyPCEEnd:	RETNotifyPCE	ENDP	; end of NotifyPCE macro  ;------------------------------------------------------------------------------; IntPCE ; Interrupt the PCE; IF ;  1) the DOR's interrupt enable bit is set AND;  2) the MustWaitForInterrupt in the IOCB is set;  THEN interrupt the PCE-186; ELSE;  dont interrupt the PCE-186IntPCE	PROC	NEARIntPCELb:	TEST	pDOR,pDORIntPC ; is int enable bit of DOR set?	JZ	DontIntPCE ; NO, so don't int the PCE!	CMP	pceFloppyIOCB.fdcCommands.MustWaitForInterrupt,MesaTRUE ; does the FDC generate an interrupt for this command?	JNE	DontIntPCE ; NO, so don't int the PCE!	MOV	DX,pIRQ6 ; pIRQ6 corresponds to int 6 (Diskette adapter)	OUT	DX,AL ; The value (AL) is immaterial!DontIntPCE:	RETIntPCE	ENDP ; end of IntPCE procedure ;------------------------------------------------------------------------------	ASSUME	ES:PCEDispatcherIOR	;this proc called with ES access;------------------------------------------------------------------------------; DOREmulator; Carry the Enable/Reset Bit in DOR to RQM in MSR; If Reset and Real Drive and not AlreadyReset and S0 then;   {Reset the real FDC;;    Initialize handler;;    Init IOCB;;    Interrupt PCE;;   };   else start motor if different drive selected.; Note: need to add a check for an IN at DOR for error tracking purposes; Registers Affected: AX, DXDOREmulator PROC	NEARDOREmulatorLb:; Get the OUT data 	MOV	AL, BYTE PTR ioTrappedData; 	MOV	AH,AL		; Make a copy; is it a SET or RESET?	AND	AL,pDORSetResetBit ; isolate set/reset bit	CMP	AL,0	; 0 implies RESET	JNZ	SetCmnd ; Jump for SET operation; attempt to RESET the FDC;	TEST	pDOR,pDORSetResetBit; was it already reset?;	JZ	NoResetReqd	; already RESET so skip	MOV	pFDCMSR, pFDCNotReady	; FDC is not ready when reset	CMP	pceHasRealDrive,MesaTRUE ;reset is done iff the pc has	JNE	SkipMotorStart	; access to the physical floppy drive; A reset is requested	CMP	pceFloppyEmulatorState,pFlopInit	JZ	OkayToReset	; Nothing enqued	;JAM(mumble) ; **-** how to deque the IOCB?OkayToReset:	MOV	pceFloppyIOCB.PCEResetFDCFlag, MesaTRUE	XOR	runPCE, floppyPauseMask ; stop the PC till request is done	CALL	QandDQIOCB ; get floppy handler to do the reset	OR	runPCE, floppyPauseMask ; resume the PC	CALL	InitializeHandler	CALL	InitIOCB ; Just in case IOCB got messed up	JMP	SHORT	SkipMotorStartSetCmnd:; Interrupt the PCE	TEST	pDOR, pDORSetResetBit	; check if already set	JNZ	NoIntReqd	; skip interrupting the PC-186	MOV	pFDCMSR, pFDCRecvMode	; set MSR to active	MOV	AL, AH		; restore AL	TEST	AL,pDORIntPC ; is int enable bit of DOR set?	JZ	NoIntReqd ; NO, so don't int the PCE!	MOV	DX,pIRQ6 ; pIRQ6 corresponds to int 6 (Diskette adapter)	OUT	DX,AL ; The value (AL) is immaterial!NoIntReqd:NoResetReqd:;Test if motor is turned on	MOV	AL,AH		; restore AL	AND	AL,pDORDriveSelect ; isolate bits that specify the drive #	CMP	AL,pFlopLogicalDrive ; Is the real drive being activated?	JNE	SkipMotorStart; build the bits to set up PCEStartMotorFlags	MOV	AL, pFDCRealDrive; get the drive number of the real drive	OR	AL, HighBit	; set MSB	MOV	pceFloppyIOCB.PCEStartMotorFlags, AL;	XOR	runPCE, floppyPauseMask ; stop the PC till request is done	CALL	QandDQIOCB ;get floppy handler to start the motor	OR	runPCE, floppyPauseMask ; resume the PC	SkipMotorStart: 	MOV	pDOR,AH		; store in the new value	RETDOREmulator	ENDP	ASSUME	ES:NOTHING;------------------------------------------------------------------------------; MSREmulator; Sends the current copy of MSR to PCE; Note: need to add a check for an OUT at MSR for error tracking purposes; Registers Affected: ALMSREmulator PROC	NEARMSREmulatorLb:	MOV	AL, pFDCMSR	CALL	LoadMagic;	RETMSREmulator	ENDP;------------------------------------------------------------------------------; pceFloppyTask; Handle IN/OUT;; InToDR: Sends the current contents of DR to PCE if result bytes still remaining; OutToDR: If 1st command byte then;    (1) Change state from S0 to S1;    (2) Identify the command;    (3) Set up elements in the fdcCommandRecord: NumberOfCommandBytes,;	NumberOfResultBytes, MustWaitForInterrupt, DataXfer, WriteMode;;  If all ParamRcvd then;    (1) Change state from S1 to S2;    (2) SetupMSR;    (3) SetupAddr;  If AccessRealDrive then;    (1) Enqueue IOCB;    (2) Notify Floppy handler;    (3) Wait for condition: pceFloppyHandlerDone;    (4) Dequeue IOCB;  NotifyPCE;  Wait for PCE Floppy IOpceFloppyTaskEmul:;	%WaitForCondition	(OFFSET pceFloppyWaitIO,noTimeout) ;;		%EstablishHandlerAccess	(PCEDispatcherHandlerID)	ASSUME	ES:PCEDispatcherIOR	MOV	BX,ioTrappedAddress	;get the address	AND	BX, pLowNyble	;isolate low nyble	CMP	BL,2	; IO to 3F2 ?	JNE	DataRegisterORMSR	; IO to DOR 	CALL	DOREmulator	JMP	SHORT	pceFloppyTaskEmul	DataRegisterORMSR:	CMP	BL,4	; IO to 3F4 ?	JNE	DataRegisterORError	; IO to MSR 	CALL	MSREmulator	JMP	SHORT	pceFloppyTaskEmul	DataRegisterORError:	CMP	BL,5	; IO to 3F5 ?	JE	DataRegisterErrorenousIOAddr:	MOV	pFlopError, IllegalAddr	JMP	SHORT	pceFloppyTaskEmul	; DataRegisterDataRegister:; Check for IN/OUT	TEST	ioTrappedStatus, pIOTrapInOutBit	;	JZ	OutToDRInToDR:; IN to Data Register (3F5H)	XOR	BH,BH	; 	MOV	BL, pceFlopIndex ; get result array index 	MOV	AL, pceFloppyIOCB.fdcCommands.ResultBytes[BX]	CALL	LoadMagic;	INC	BL	MOV	pceFlopIndex, BL ; 	CMP	pceFloppyIOCB.fdcCommands.NumberOfResultBytesRead,BL	JG	pceFloppyTaskEmul	; Not done as yet; Result Phase over	CALL	InitializeHandler	CALL	ResetIOCB	JMP	SHORT	pceFloppyTaskEmul; end InToDROutToDR:; OUT to Data Register (3F5H)	CMP	pceFloppyEmulatorState,pFlopInit ; Command byte received?	JNE	ParamRcvd ; Jmp if not; Identify the command	MOV	pceFloppyEmulatorState,pFlopCmndRcvd	MOV	AL,BYTE PTR ioTrappedData;	AND	AL,pFlopLow5Bits	; isolate "commmand specifying" bits	PUSH	ES	MOV	BX,CS	; get the code segment value	MOV	ES,BX	; set ES=CS	ASSUME	ES:NOTHING	MOV	DI, OFFSET pFDCCommandList ; Set ES:DI to base of command table	MOV	CX,pFDCMaxCommands	; set length of tableREPNE	SCASB				; look for a match	POP	ES	ASSUME	ES:PCEDispatcherIOR	JZ	CommandFound	MOV	pFlopError,IllegalCommand	JMP	ErrorRtn		; illegal command issued	CommandFound:; Set up elements in the fdcCommandRecord; Set up NumberOfCommandBytes in the fdcCommandRecord	MOV	DI,pFDCMaxCommands	;Compute index of match	SUB	DI,CX		; 	DEC	DI		; -1 since its zero offset	MOV	AH, CS:pFDCParamsExpected[DI]	INC	AH	; +1 since handler expects commands+params	MOV     pceFloppyIOCB.fdcCommands.NumberOfCommandBytes,AH ; Set up  in the fdcCommandRecord	MOV	AH, CS:pFDCResultsExpected[DI]	MOV     pceFloppyIOCB.fdcCommands.NumberOfResultBytes,AH; Set up other elements in the fdcCommandRecord	MOV	CX,DI	; get the index; but only lo-byte is significant	MOV	BX,1	; Set up mask such that the bit position corresponds to	SHL	BX,CL	; the index of command identified	; Set up MustWaitForInterrupt in the fdcCommandRecord	TEST	BX,pFDCIntExpected ; Will the FDC cause an interrupt?	JZ	IntNotExpected	MOV	pceFloppyIOCB.fdcCommands.MustWaitForInterrupt,MesaTRUEIntNotExpected:; Set up DataTransferCode in the fdcCommandRecord	TEST	BX,pFDCDataXferCode1 ; Will there be a data transfer?	JZ	NoDataXfer	; 0 implies no data xferDataXfer:	MOV	pceFloppyIOCB.fdcCommands.DataTransferCode,1	TEST	BX,pFDCDataXferCode2 ; Is it a write?	JZ	NotWriteMode	; No its a read	INC	pceFloppyIOCB.fdcCommands.DataTransferCodeNoDataXfer:NotWriteMode:; Set Boolean to tell if the command has drive number specified	TEST	BX,pFDCDriveNumberPresent ; Will the FDC cause an interrupt?	JZ	DriveNumberNotExpected	MOV	pceDriveNumberSpecified,MesaTRUEDriveNumberNotExpected:;set up other stuffParamRcvd:; Move received data into CommandBytes array in the fdcCommands record	XOR	BX,BX	MOV	BL, pceFlopIndex	MOV	AL, BYTE PTR ioTrappedData	MOV	pceFloppyIOCB.fdcCommands.CommandBytes[BX],AL	INC	BL	CMP	pceFloppyIOCB.fdcCommands.NumberOfCommandBytes,BL	JLE	AllParamsRcvd	MOV	pceFlopIndex,BL	JMP	pceFloppyTaskEmulAllParamsRcvd:; all needed data received, so go about queing the IOCB	MOV	pceFlopIndex,0	;reset the index for the next iteration	MOV	pceFloppyEmulatorState, pFlopParmsRcvd	; change the state	CALL	SetupAddr ; set up the address for data xfer	JNC	AddrSetupOk	JMP	ErrorRtn;  set up other stuff in the IOCBAddrSetupOk:	CALL	SetupMSR ; set up the FDCMSR based on command information	XOR	runPCE, floppyPauseMask; Hold PCE186 until floppy operation done	CMP	pceHasRealDrive,MesaTRUE ;	JE	RequestForPhysical	JMP	SHORT	AccessVirtualDriveRequestForPhysical:;Maybe request for the physical floppy drive	CMP	pceDriveNumberSpecified,MesaTRUE; If drive number is not specified 	JNE	EnqueIOCB ; then it is a global FDC command so send it to real FDC	;------------------------------------------------------; The PCE-186 cannot tell the difference between the physical and emulated drive; so it is the task of the emulator to distinguish between these two cases.; At boot time pFlopLogicalDrive gets set to correspond to the drive that the user wants to be his physical drive. ; If the drive being accessed is the one specified by pFlopLogicalDrive then it is a request for physical; else it is a request for the emulated drive; If indeed the request is for the physical drive then the emulator has to do some more jugglery.; On the 6085 the FDC can access upto 4 drives, but physical floppy drive is always attached as drive # 0 (pFDCRealDrive). ; the emulator must account for this fact to allow the PC to access the physical drive. This is accomplished by setting the drive number to pFDCRealDrive.; eg. If the user configures with the physical drive as drive B, THEN pFlopLogicalDrive is set to 1.; When the PC requests to access drive B, the emulator detects this (drive number specified = pFlopLogicalDrive) as a request for the physical drive.; The drive number specified is then changed to pFDCRealDrive (since there is no drive # 1 on our FDC); The request can now be handed over to the floppy handler for processing. ;------------------------------------------------------	MOV	AH, pceFloppyIOCB.fdcCommands.CommandBytes[1] ; get the command byte that contains drive number	AND	AH, 00000011B; isolate the drive number	MOV	pFlopDriveNumber, AH; store it	MOV	AL,pFlopLogicalDrive ; get the logical drive that is mapped to real 	CMP	AL,AH ; Is this request to the physical drive?	JE	AccessRealDrive ; Yes 	JMP	SHORT	AccessVirtualDrive; NoAccessRealDrive:	MOV	AL, pceFloppyIOCB.fdcCommands.CommandBytes[1] ; get the command byte that contains drive number	AND	AL, 11111100B; Mask out the logical drive number	MOV	AH, pFDCRealDrive ; get the physical drive # 	OR	AL, AH ; OR in the physical drive #	MOV	pceFloppyIOCB.fdcCommands.CommandBytes[1], AL 	MOV	pceFloppyIOCB.DaDriveNumber, AH; set physical drive # ; enqueue the IOCBEnqueIOCB:	MOV	pceFloppyEmulatorState, pFlopIOCBEnqued		CALL	QandDQIOCB ;get floppy handler to do the operation	CALL	CheckErrors	JC	EnqueIOCB	JMP	SHORT IOCBProcessedAccessVirtualDrive:	MOV	pceFloppyEmulatorState, pFlopUpNotified	MOV	AX, pceFloppyNotifyMask ; get floppy mask	CALL	PCEMesaClientNotify; do the UpNotify	%WaitForCondition (OFFSET pceFloppyConditionWork,noTimeout);IOCBProcessed:	CALL	NotifyPCE	OR	runPCE, floppyPauseMask	JMP	pceFloppyTaskEmul	ErrorRtn:;error routine	MOV	AL, pFlopError	MOV	pFlopError, NoError	JMP	pceFloppyTaskEmul	HLT		; Deep trouble if this gets executed	ASSUME	DS:NOTHING, ES:NOTHING;------------------------------------------------------------------------------;	Tables and other constants;pFDCCommandList		DB	fdcSeekCommand, fdcReadDataCommand,&		fdcWriteDataCommand, fdcFormatTrackCommand,&		fdcSpecifyCommand, fdcSenseInterruptStatusCommand,&		fdcRecalibrateCommand, fdcSenseDriveStatusCommand,&		fdcReadIDCommand, fdcReadTrackCommand, fdcScanEqualCommand,&		fdcScanLowOrEqualCommand, fdcScanHighOrEqualCommand,&		fdcReadDeletedDataCommand, fdcWriteDeletedDataCommand; Bit patterns of the FDC commandspFDCMaxCommands	EQU	$ - pFDCCommandList; Size of above tablepFDCParamsExpected	DB	pFDCSeekSz, pFDCReadDataSz, pFDCWriteDataSz,&		pFDCFormatTrackSz, pFDCSpecifySz, pFDCSenseIntSz,&		pFDCRecalibSz, pFDCSenseDriveSz, pFDCReadIdSz,&		pFDCReadTrackSz, pFDCScanEqualSz, pFDCScanLoEqSz,&		pFDCScanHiEqSz, pFDCReadDeleDataSz, pFDCWriteDelDataSz ; Table giving the corresponding number of param bytes needed for the above FDC commnadspFDCResultsExpected	DB	pFDCSeekResult, pFDCReadDataResult,&		pFDCWriteDataResult, pFDCFormatTrackResult, pFDCSpecifyResult,&		pFDCSenseIntResult, pFDCRecalibResult, pFDCSenseDriveResult,&		pFDCReadIdResult, pFDCReadTrackResult, pFDCScanEqualResult,&		pFDCScanLoEqResult, pFDCScanHiEqResult,&		pFDCReadDeleDataResult, pFDCWriteDelDataResult ; Table giving the corresponding number of result bytes expected for the above FDC commnads;------------------------------------------------------------------------------IOPEInRam	ENDS		END
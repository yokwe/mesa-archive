$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1985 by Xerox Corporation. All rights reserved.;-- stored as [Iris]<WMicro>Dove>MoveSegs.asm;-- last edited by:;--	RDH	27-Jan-87 11:32:00	:Use ending label in BootStrapIOR;--	JAC	14-Jan-87 15:31:44	:move BootStrapIOR too;--	JPM	30-Sep-85 10:53:44	:Added OldSegAddrs to fix bug in MoveIOR;--	JPM	20-Sep-85 16:06:53	:CreatedNAME			MoveSegs;--------------------------------------------------------------------------------$NOLIST$INCLUDE		(IOPDefs.asm)$INCLUDE		(HardDefs.asm)$INCLUDE		(OpieDefs.asm)$INCLUDE		(IOPMacro.asm)$INCLUDE		(ROMBDefs.asm)$INCLUDE		(QueDefs.asm)$INCLUDE		(QueMacro.asm)$INCLUDE		(OpieMac.asm)$INCLUDE		(Handlers.asm)$INCLUDE		(ROMEEP.asm)$INCLUDE		(DskIOFce.def)$LIST;Generate Handler IDs$SAVE$GENONLY%*DEFINE(Handler(name,id,initProcAction))	(%name%(HandlerID)	EQU	%id)			%HandlersLinked$RESTORE;--------------------------------------------------------------------------------IOPELocalRAM		SEGMENT	AT 0EXTRN			i8259MasterIntrptVctBase: SegmentAndOffsetEXTRN			softwareIntrptVctBase: SegmentAndOffsetEXTRN			device: WORDEXTRN			IORSegmentTableAddress: SegmentAndOffsetEXTRN			IOROpieSegmentAddress: WORDIOPELocalRAM		ENDS;--------------------------------------------------------------------------------IORegion		SEGMENT		COMMONEXTRN			segmentTable: SegmentEntryIORegion		ENDS;--------------------------------------------------------------------------------OpieIOR			SEGMENT	COMMONEXTRN			SegmentTableAddress: SegmentAndOffsetEXTRN			workNotifierBits: WORDOpieIOR			ENDS;--------------------------------------------------------------------------------EthernetIOR		SEGMENT	COMMONEXTRN			etherInQueue: QueueBlockEXTRN			etherOutQueue: QueueBlockEXTRN			rbdCount: BYTEEthernetIOR		ENDS;--------------------------------------------------------------------------------BootstrapIOR		SEGMENT	COMMONEXTRN			bootDeviceIORSpace: EtherBootContextEXTRN			EndRAMBootstrapIOR: FARBootstrapIOR		ENDSDiskIOR			SEGMENT	COMMONEXTRN			diskFCB: DiskFCBRecordDiskIOR			ENDSFloppyIOR		SEGMENT	COMMONEXTRN			Floppy80186Queue: QueueBlockFloppyIOR		ENDS;********************************************************************************IOPEInRAM		SEGMENT		WORD PUBLIC			Assume CS:IOPEInRAMPUBLIC	MoveSegmentsMoveSegments		PROC	FAR			PUSH	DS			MOV	AX, IOPELocalRAM			MOV	ES, AX			ASSUME	ES:IOPELocalRAM;assume for now that all stacks are in the right place;copy IOR locations into local table (for use in determining IOR sizes)			LDS	BX, IORSegmentTableAddress			XOR	SI, SI			MOV	DI, SI			MOV	CX, 15D		;max number of ROM handlersCopyIORLocLoop:		MOV	AX, [BX][SI].ioRegionSegment			MOV	CS:OldSegAddrs[DI], AX			ADD	SI, SIZE SegmentEntry			ADD	DI, 2			LOOP	CopyIORLocLoop;copy IOR and stack locations for bootstrap (not set up in new table)			;MOV	SI, BootstrapHandlerID * SIZE SegmentEntry			;MOV	DX, [BX][SI].ioRegionSegment			;MOV	CX, [BX][SI].stackSegment			;MOV	AX, IORegion			;MOV	DS, AX			;MOV	BX, OFFSET segmentTable			;MOV	[BX][SI].ioRegionSegment, DX			;MOV	[BX][SI].stackSegment, CX;move IORs for maint panel, keyboard/mouse, display, and beep, one at a time; (locations must be in ascending order); beep commented out because not started yet			MOV	SI, MaintPanelHandlerID * SIZE SegmentEntry			CALL	MoveIOR			MOV	SI, KeyboardAndMouseHandlerID * SIZE SegmentEntry			CALL	MoveIOR			MOV	SI, DisplayHandlerID * SIZE SegmentEntry			CALL	MoveIOR;			MOV	SI, BeepHandlerID * SIZE SegmentEntry;			CALL	MoveIOR;now more booting's IOR into main memory.  first must make sure that no pointer to the IOR is cached in an IOCB by making sure the queue is nil			MoveBootStrap:		CMP	device, disk			JNE	CheckEthernet	CheckDiskQueues:	CLI				LDS	BX, IORSegmentTableAddress			ADD	BX, DiskHandlerID * SIZE SegmentEntry			MOV	DS, [BX].ioRegionSegment			ASSUME	DS:DiskIOR;the disk handler doesn't use the queue definitions provided by opie so this is the compare;for empty used by the disk handler.  check only rd0 since that is what booting uses and we ;don't have multiple drives yet.			CMP	diskFCB.rd0.diskIOPNextHigh, NILOpieAddressHigh			JZ	QueuesEmpty			POP	DS			%WaitForSystem			PUSH	DS			JMP	SHORT CheckDiskQueues			CheckEthernet:		CMP	device, ethernet			JNE	CheckFloppy			CheckEtherQue:		CLI			LDS	BX, IORSegmentTableAddress			ADD	BX, EthernetHandlerID * SIZE SegmentEntry			MOV	DS, [BX].ioRegionSegment			ASSUME	DS:EthernetIOR			%JumpIfQueueNextNil	(etherInQueue,CheckEtherOutQue)			JMP	SHORT WaitForEthernetCheckEtherOutQue:	%JumpIfQueueNextNil	(etherOutQueue,QueuesEmpty)WaitForEthernet:	POP	DS			%WaitForSystem			PUSH	DS			JMP	CheckEtherQue			CheckFloppy:		CMP 	device, floppy			JNE	IsDiskBootCheckFloppyQueues:	CLI			LDS	BX, IORSegmentTableAddress			ADD	BX, FloppyHandlerID * SIZE SegmentEntry			MOV	DS, [BX].ioRegionSegment			ASSUME	DS:FloppyIOR			%JumpIfQueueNextNil(Floppy80186Queue, QueuesEmpty)			POP	DS			%WaitForSystem			PUSH	DS			JMP	SHORT CheckFloppyQueues;no pointers are cached. now copy the IOR			QueuesEmpty:		MOV	AX, IORegion			MOV	DS, AX			ASSUME	DS:IORegion			MOV	ES, segmentTable[BootStrapHandlerID * SIZE SegmentEntry].ioRegionSegment			POP	DS			XOR	SI, SI			MOV	DI, SI			MOV	CX, OFFSET EndRAMBootstrapIOR		;last thing in IOR			SHR	CX, 1			CLD			REP	MOVSW	;ES:[DI], DS:[SI]			PUSH	ES					;push new IOR;update the entry in the old table so that the new IOR will now be used.			MOV	AX, IOPELocalRAM			MOV	ES, AX			ASSUME	ES:IOPELocalRAM			MOV	SI, BootStrapHandlerID * SIZE SegmentEntry			POP	AX			PUSH	AX			CALL	UpdateTable;move IOR for boot deviceIsDiskBoot:		CMP	device, disk			JNE	IsEthernetBoot			MOV	SI, DiskHandlerID * SIZE SegmentEntry			CALL	MoveIOR				JMP	SHORT MoveOpieIsEthernetBoot:		CMP	device, ethernet			JNE	IsFloppyBoot			POP	DS			CALL	MoveEthernetIOR		;special processing needed			PUSH	DS			JMP	SHORT MoveOpieIsFloppyBoot:		CMP	device, floppy			JNE	MoveOpie			MOV	SI, FloppyHandlerID * SIZE SegmentEntry			CALL	MoveIORMoveOpie:		CLI		;Opie moves must be done atomically;pick up old and new Opie IOR locations and change IOROpieSegmentAddress			MOV	AX, IORegion			MOV	DS, AX			ASSUME	DS:IORegion			MOV	BX, segmentTable[OpieHandlerID].ioRegionSegment			MOV	AX, IOROpieSegmentAddress			MOV	IOROpieSegmentAddress, BX;now scan the vector table replacing old with new			MOV	DI, OFFSET i8259MasterIntrptVctBase			MOV	CX, OFFSET softwareIntrptVctBase			SUB	CX, DI			SHR	CX, 2ScanIntrptVctReplace:	CMP	ES:[DI].segmentValue, AX			JNE	ScanIntrptVctReplCont			MOV	ES:[DI].segmentValue, BXScanIntrptVctReplCont:	ADD	DI, SIZE SegmentAndOffset			LOOP	ScanIntrptVctReplace 	;Loop until done;next, do IOR move			MOV	DS, AX			ASSUME	DS:NOTHING			PUSH	ES			MOV	ES, BX			ASSUME	ES:OpieIOR			XOR	SI, SI			MOV	DI, SI			MOV	CX, OFFSET workNotifierBits+2	;last thing in IOR			SHR	CX, 1			CLD		REP	MOVSW	;ES:[DI], DS:[SI];finally, change IORegion pointers to point to new location			MOV	BX, IORegion			MOV	AX, OFFSET segmentTable			MOV	SegmentTableAddress.segmentValue, BX			MOV	SegmentTableAddress.offsetValue, AX			POP	ES			ASSUME	ES:IOPELocalRAM			MOV	IORSegmentTableAddress.segmentValue, BX			MOV	IORSegmentTableAddress.offsetValue, AX			STI			POP	DS			RETMoveSegments		ENDP;--------------------------------------------------------------------------------;segment move procs			ASSUME	ES:IOPELocalRAMMoveIOR			PROC	NEAR;first find current location and size of IOR			LDS	BX, IORSegmentTableAddress			MOV	DX, [BX][SI].ioRegionSegment			MOV	DI, 0			MOV	CX, 15D		;max number of ROM handlers			MOV	AX, DS;in this loop, skip disk and floppy because they're overlaid by ethernetFindIORSizeLoop:	CMP	DI, DiskHandlerID * 2			JE	FindIORSizeCont			CMP	DI, FloppyHandlerID * 2			JE	FindIORSizeCont			CMP	CS:OldSegAddrs[DI], DX			JLE	FindIORSizeCont			CMP	CS:OldSegAddrs[DI], AX			JGE	FindIORSizeCont			MOV	AX, CS:OldSegAddrs[DI]FindIORSizeCont:	ADD	DI, 2			LOOP	FindIORSizeLoop			SUB	AX, DX			SHL	AX, 3		;make word count			MOV	CX, AX;now get new location and do move (with interrupts disabled)			MOV	AX, IORegion			MOV	DS, AX			MOV	BX, OFFSET segmentTable			PUSH	ES			MOV	ES, [BX][SI].ioRegionSegment			ASSUME	ES:NOTHING			MOV	DS, DX			PUSH	SI			XOR	SI, SI			MOV	DI, SI			CLI			CLD		REP	MOVSW	;ES:[DI], DS:[SI];finally, put new location into current segment table and enable interrupts			MOV	AX, ES			POP	SI			POP	ES			ASSUME	ES:IOPELocalRAMUpdateTable:		LDS	BX, IORSegmentTableAddress			MOV	[BX][SI].ioRegionSegment, AX			STI			RETMoveIOR			ENDPMoveEthernetIOR		PROC	NEAR;first, make sure E-net isn't busyCheckEtherQueues:	PUSH	DS			LDS	BX, IORSegmentTableAddress			ADD	BX, EthernetHandlerID * SIZE SegmentEntry			MOV	DS, [BX].ioRegionSegment			ASSUME	DS:EthernetIOR			CLICheckEtherInQueue:	%JumpIfQueueNextNil	(etherInQueue,CheckEtherOutQueue)			JMP	SHORT WaitForEtherQueuesCheckEtherOutQueue:	%JumpIfQueueNextNil	(etherOutQueue,EtherQueuesEmpty)WaitForEtherQueues:	POP	DS			%WaitForSystem			JMP	CheckEtherQueues;now shut off i82586EtherQueuesEmpty:	%Reset	(resetEthernetController);move the ethernet IOR			MOV	SI, EthernetHandlerID * SIZE SegmentEntry			CALL	MoveIOR;set rbdCount to maximum value (since IOR is now full size)			MOV	DS, AX			MOV	rbdCount, 8;restart ethernet			POP	DS			ASSUME	DS:BootstrapIOR			MOV	DI, OFFSET bootDeviceIORSpace.etherIOCB			MOV	BX, OFFSET bootDeviceIORSpace.etherIOCBDone			MOV	AL, BootstrapHandlerID			MOV	AH, 2	;disable braodcast packets			%EtherInitialize			RET			ASSUME	DS:NOTHINGMoveEthernetIOR		ENDP;segment address table			EVENOldSegAddrs		DW	15 DUP (0)IOPEInRAM		ENDS;********************************************************************************			END
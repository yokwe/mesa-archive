$MOD186$PAGELENGTH (95)$PAGEWIDTH  (136);Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;-- stored as [Iris]<WMicro>Dove>RAMDskBt.asm;-- created on  30-Nov-84 13:44:00;-- last edited by:;--	JPM		11-May-87 10:26:33      Add new MP codes for self-describing disk errors.;--	JPM		 8-May-87 12:45:13      Add delay for non-self-describing disks (so MP code is visible); reduce code size in StuffNewDiskParms proc.;--	JPM		 7-May-87 10:00:49      Add code for self-describing disks (read sector and change disk parms).;--	JPM		 8-Jan-87 12:49:28      Fix bug in DiskReadError (needed to set BX before jump to InitIOCB).;--	JPM		20-Sep-85 10:39:40      Do boot buffer allocation.;--	kek		 4-Sep-85 16:03:18	more mp codes, use public mp code rtn.;--	JPM		 4-Sep-85  8:16:12	Standardize MP codes, remove display change;--	JPM		 3-Aug-85 10:38:34	Change EEPDefs.asm to ROMEEP.asm;--	JPM		22-Jul-85 12:37:34	Opie redesign conversion;--	JPM		15-Jul-85  8:53:30	;Set diskFCB.diskStartHandlerForIOP to FALSE after finished booting.;--	JPM		12-Jul-85 12:03:29	;Fixed bug in CalcNextAddr (inadequate check for double-zero).;--	JMM		 9-Jul-85 17:22:59	;Upgraded to new Disk handler.;--	JMM		26-Jun-85 21:12:43	;Restored old EOF protocol and IOPMacro.;--	JMM		26-Jun-85 16:40:07	;Moved include files here. Also IOPLRAM.;--	JPM		17-Jun-85 12:19:59NAME			RAMDskBt;--------------------------------------------------------------------------------;$NOLIST$INCLUDE		(HardDefs.asm)		;$INCLUDE		(IOPDefs.asm)		;$INCLUDE		(RAMBDefs.asm)		;$INCLUDE		(ROMEEP.asm)		;$INCLUDE		(DskIOFce.def)		;$INCLUDE		(DskBDefs.asm)$INCLUDE		(IOPMacro.asm)$LISTEXTRN			BootStrapHandlerID: ABSEXTRN			DiskHandlerID: ABSEXTRN			DisplayMPCode: NEAR%*DEFINE		(Zero	(start,end))			   LOCAL Lbl0			   (	MOV	SI, OFFSET %start			%Lbl0:	MOV	BYTE PTR [SI], 0				INC	SI				CMP	SI, OFFSET %end				JL	%Lbl0				);--------------------------------------------------------------------------------IOPELocalRAM	SEGMENT	AT 0EXTRN		opieReentry: DWORDEXTRN		bootType: BYTEEXTRN		bootRetryCount: WORDEXTRN		startOfBootBufferSpace: WORDEXTRN		HandlerInitProcTable: DWORDIOPELocalRAM	ENDS;--------------------------------------------------------------------------------BootStrapIOR		SEGMENT	COMMON			ASSUME	DS:BootStrapIOREXTRN			bootBufferEmpty: ConditionEXTRN			bootBufferFull: ConditionEXTRN			startOfBootBufferPool: WORDEXTRN			bootDeviceIORSpace: DiskBootAreaEXTRN			bootStrapTask: TaskContextBlockEXTRN			bootTask: TaskContextBlockEXTRN			getBootFile: ConditionEXTRN			finishedLoaderFileFetch: ConditiondskIOCB			EQU	bootDeviceIORSpace.diskBootIOCBdiskWorkspace		EQU	bootDeviceIORSpaceBootStrapIOR		ENDS;--------------------------------------------------------------------------------DiskIOR			SEGMENT	COMMONEXTRN			diskFCB: DiskFCBRecordDiskIOR			ENDS;--------------------------------------------------------------------------------MaintPanelIOR		SEGMENT	COMMONEXTRN			maintPanelCode: WORDEXTRN			maintPanelChanged: ConditionMaintPanelIOR		ENDS;--------------------------------------------------------------------------------BootStrapSTK		SEGMENT	COMMONEXTRN			BootStack: WORDBootStrapSTK		ENDS;--------------------------------------------------------------------------------IOPEInRam		SEGMENT	PUBLIC			ASSUME	CS:IOPEInRamPUBLIC			RAMDiskEntryPointEXTRN			BootTaskInit: NEAREXTRN			EndOfInitial: NEAR; Order of actions:;	(1)	Load rest of DiskInitialDove.db (from cyl. 0, head 1, sectors 1-n,;		or as directed by label fields);	(2)	Read disk shape page (from cyl. 0, head 0, sector 15);	(3)	Read root page (from cyl. 0, head 0, sector 0);	(4)	Invoke UI to select boot sequence;	(5)	Load each file in turn, one buffer (= one sector) at a time;	(6)	Idle this boot task forever			;-- Disk RAM Boot:;--------------  This module reads in the rest of DiskInitialDove.db into	;--------------  IOP local RAM. It then proceeds to get the emulator file;--------------  MesaDove.db and the germ Dove.germ in conjunction with the;--------------  generic boot code.;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------| Upon exiting this module the following will be true:		|;--------------|								|;--------------|								|;--------------|	bootStrapTask will be waiting forever on the		|;--------------|	condition variable "idledBootTasks".			|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------			ORG	0RAMDiskEntryPoint:; step 1; set up ClientCondition in disk FCB			%EstablishHandlerAccess	(DiskHandlerID)			ASSUME	ES:DiskIOR			MOV	diskFCB.rd0.diskIOPClientCondition.handlerID, LOW BootStrapHandlerID			MOV	diskFCB.rd0.diskIOPClientCondition.conditionPtr, OFFSET diskWorkspace.diskIOCBDone+nonNilPtr			MOV	diskFCB.rd0.diskIOPClientCondition.clientMask, 0; set up disk IOCB (disk characteristics and data address)			MOV	BX, OFFSET dskIOCB.diskOperationBlock			MOV	AL, diskFCB.rd0.diskSectorsPerTrack			MOV	[BX].diskSecPerTrack, AL			MOV	AL, diskFCB.rd0.diskHeadsPerCylinder			MOV	[BX].diskHdsPerCyl, AL			MOV	AX, diskFCB.rd0.diskCylindersPerDrive			MOV	[BX].cylPerDrive, AX			MOV	AX, diskFCB.rd0.diskReducedWriteCurrentCylinder			MOV	[BX].diskReducedWriteCyl, AX			MOV	AX, diskFCB.rd0.diskPreCompensationCylinder			MOV	[BX].diskPreCompCyl, AX; set up ES for access to boot variables			MOV	AX, IOPELocalRAM			MOV	ES, AX			ASSUME	ES:IOPELocalRAM			MOV	dskIOCB.diskDataPtrHigh, (IOPLogicalOpieAddress SHL 8)			MOV	BX, startOfBootBufferSpace			MOV	dskIOCB.diskDataPtrLow, BX; change startOfBootBufferSpace to point past end of code			ADD	startOfBootBufferSpace, OFFSET EndOfInitial	; call DiskReadGetRestOfInitial:	ADD	dskIOCB.diskDataPtrLow, sectorSize			CALL	DiskRead			JNC	GetRestOfInitial			JMP	RamDiskCont; put DiskRead here, so will be in first sectorSize bytes; proc to read from diskDiskRead		PROC	NEAR			ASSUME	ES:IOPELocalRAM; calculate next disk address from DOB (prev. address and label)CalcNextAddr:		MOV	BX, OFFSET dskIOCB.diskOperationBlock			MOV	AX, WORD PTR [BX].diskLabel.diskDontCare			MOV	CX, WORD PTR [BX].diskLabel.diskDontCare+2; if both words are 0, increment old address			MOV	DX, AX			OR	DX, CX			JZ	IncrPrevAddress; if both words are FFFF, end-of file has been reached;  otherwise, the words contain the next disk address			CMP	AX, 0FFFFH			JNE	UseAddressInAXCX			CMP	CX, 0FFFFH			JNE	UseAddressInAXCX; end-of-file: set carry and return			STC			RET; secondary entry point for new file -- disk address in AX:CXDiskReadNewFile:	MOV	BX, OFFSET dskIOCB.diskOperationBlock; AX:CX contains next sector address: store into DOBUseAddressInAXCX:	MOV	WORD PTR [BX].diskHeader, AX			MOV	WORD PTR [BX].diskHeader+2, CX			JMP	SHORT InitIOCB; label contains nil: increment previous addressIncrPrevAddress:	MOV	CX, WORD PTR [BX].diskHeader+2			INC	CL			CMP	CL, [BX].diskSecPerTrack			JL	StoreNewAddress			XOR	CL, CL			INC	CH			CMP	CH, [BX].diskHdsPerCyl			JL	StoreNewAddress			XOR	CH, CH			INC	[BX].diskHeader.diskCylinderStoreNewAddress:	MOV	WORD PTR [BX].diskHeader+2, CX; initialize other IOCB fieldsInitIOCB:		MOV	AL, read			MOV	[BX].diskOperation, ReadDiskLabelAndDataInitIOCBCont:		%Zero	(dskIOCB.diskDataInfoRec, dskIOCB.diskOperationBlock)			MOV	dskIOCB.diskDataXferDirection, AL			MOV	dskIOCB.diskPageCount, 1			MOV	[BX].diskMinusSectorCount, -1			MOV	[BX].diskHeaderError, 0			MOV	[BX].diskLabelError, 0			MOV	[BX].diskDataError, 0			MOV	[BX].diskLastError, 0; put IOCB onto disk queueEnqueueIOCB:		PUSH	ES			%EstablishHandlerAccess	(DiskHandlerID)			ASSUME	ES:DiskIOR			MOV	CH, IOPIORegionOpieAddress			MOV	CL, LOW BootStrapHandlerID			MOV	diskFCB.rd0.diskIOPNextLow, OFFSET dskIOCB			MOV	diskFCB.rd0.diskIOPNextHigh, CX			MOV	diskFCB.diskStartHandlerForIOP, 0FFFFH		;jmm: Change to TRUE later.			POP	ES			ASSUME	ES:IOPELocalRAM; wake up handler and wait for return notify			%NotifyHandlerCondition	(DiskHandlerID,OFFSET diskFCB.diskConditionWork)			%WaitForCondition	(OFFSET diskWorkspace.diskIOCBDone,noTimeout); check for good completion			TEST	dskIOCB.diskError, 0FFH			JNZ	DiskReadErrorDiskReadDone:		CLC			RET; determine error type (eventually -- just retry for now):;  (a) CRC error -- retry;  (b) wrong cylinder error -- recalibrate, retry;  (c) other errors -- ?DiskReadError:		DEC	bootRetryCount			JZ	TooManyRetries			MOV	BX, OFFSET dskIOCB.diskOperationBlock			JMP	InitIOCB;if too many retries, hang with MP codeTooManyRetries:		MOV	AX, mpInitialErrorCallDispMP:		CALL	DisplayMPCodeDone:			%Jam	(BootStrapHandlerID,OFFSET bootStrapTask)			%WaitForSystem		; never returns!DiskRead		ENDP;display mp code for executing initial microcode			ASSUME	ES:IOPELocalRAMRamDiskCont:		MOV	AX, mpRunInitial			CALL	DisplayMPCode; step 2			MOV	BX, OFFSET dskIOCB.diskOperationBlock			MOV	AX, diskShapeCylinder			MOV	CX, diskShapeHeadAndSector			MOV	SI, startOfBootBufferSpace			ADD	SI, bootDataBegins+sectorSize-1			AND	SI, NOT (sectorSize-1)			MOV	dskIOCB.diskDataPtrLow, SI			PUSH	SI			SUB	SI, bootDataBegins			MOV	startOfBootBufferPool, SI			MOV	ES:[SI].nextBootBuffer, SI			MOV	ES:[SI].bootDataStart, Null			MOV	ES:[SI].bootDataEnd, Null			MOV	bootRetryCount, 10			MOV	WORD PTR TooManyRetries+1, mpSDDReadErrorReadDiskShape:		CALL	DiskReadNewFile			POP	SI			PUSH	SI; verify seal, version, and checksum			CMP	ES:[SI].DSseal, diskShapeSeal			JE	DiskShapeSealOKDiskShapeSealError:	MOV	AX, mpSDDSealError			CALL	DisplayMPCode; seal mismatch may be due to old formatting; look at checksum words; if they don't match, continue booting with EEPROM disk parms			MOV	AX, ES:[SI].DSchecksum			NOT	AX			CMP	AX, ES:[SI].DSinvertedChecksum			JE	Done; pause before booting so code is visible			%WaitForTime (2000)	; two seconds			JMP	SHORT RamDiskStep3; other error conditionsDiskShapeCksmError:	MOV	AX, mpSDDCksmError			JMP	CallDispMPDiskShapeVrsnError:	MOV	AX, mpSDDVrsnError			JMP	CallDispMPDiskShapeSealOK:	MOV	AX, ES:[SI].DSchecksum			NOT	AX			CMP	AX, ES:[SI].DSinvertedChecksum			JNE	DiskShapeCksmError			CALL	CalcChecksum			CMP	AX, ES:[SI].DSchecksum			JNE	DiskShapeCksmError			CMP	ES:[SI].DSversion, diskShapeVersion			JNE	DiskShapeVrsnError; disk shape is OK -- use parms for booting			CALL	StuffNewDiskParms; step 3RamDiskStep3:		MOV	BX, OFFSET dskIOCB.diskOperationBlock			MOV	AX, rootPageCylinder			MOV	CX, rootPageHeadAndSector			MOV	WORD PTR TooManyRetries+1, mpMesaDoveErrorReadRootPage:		CALL	DiskReadNewFile			POP	SI			MOV	AX, SI			ADD	AX, sectorSize			;add sector size			MOV	startOfBootBufferSpace, AX	; and store for booting			ADD	SI, rootPageHeaderSize	; set up for 1st file ID; step 4 (for now, skip UI and set up for diagnostic or Mesa boot)			CMP	bootType, normal			JE	SetUpMesaBoot; diagnostic boot: load one file from root file 0SetUpDiagnosticBoot:	MOV	CH, ES:[SI].DFIDcylinderHigh			MOV	CL, ES:[SI].DFIDcylinderLow			MOV	DH, ES:[SI].DFIDhead			MOV	DL, ES:[SI].DFIDsector			MOV	diskWorkspace.file1.Cyl, CX			MOV	diskWorkspace.file1.HdSct, DX			MOV	diskWorkspace.fileCount, 1			JMP	SHORT LoadFiles; Mesa boot: load two files from root files 1 (uCode) and 2 (germ)SetUpMesaBoot:		ADD	SI, SIZE(DiskRootFileID)			MOV	CH, ES:[SI].DFIDcylinderHigh			MOV	CL, ES:[SI].DFIDcylinderLow			MOV	DH, ES:[SI].DFIDhead			MOV	DL, ES:[SI].DFIDsector			MOV	diskWorkspace.file1.Cyl, CX			MOV	diskWorkspace.file1.HdSct, DX			ADD	SI, SIZE(DiskRootFileID)			MOV	CH, ES:[SI].DFIDcylinderHigh			MOV	CL, ES:[SI].DFIDcylinderLow			MOV	DH, ES:[SI].DFIDhead			MOV	DL, ES:[SI].DFIDsector			MOV	diskWorkspace.file2.Cyl, CX			MOV	diskWorkspace.file2.HdSct, DX			MOV	diskWorkspace.fileCount, 2; step 5LoadFiles:		%Restart	(BootStrapHandlerID,OFFSET bootTask,BootTaskInit,OFFSET BootStack)			MOV	SI, OFFSET diskWorkspace.file1; load one complete fileLoadLoop:		PUSH	SI			%WaitForCondition	(OFFSET getBootFile,noTimeout)			POP	SI			MOV	AX, [SI].Cyl			MOV	CX, [SI].HdSct			MOV	DI, startOfBootBufferPool			MOV	bootRetryCount, 10			PUSH	SI			PUSH	DI; read first sector of new file into (page-aligned) buffer			CALL	DiskReadNewFile; notify boot task that a buffer is readyNotifyBufferFull:	POP	DI			MOV	ES:[DI].bootDataStart, bootDataBegins			MOV	ES:[DI].bootDataEnd, bootDataBegins+sectorSize-1			%NotifyCondition	(OFFSET bootBufferFull); wait till buffer becomes availableWaitForBuffer:		PUSH	DI			%WaitForCondition	(OFFSET bootBufferEmpty,noTimeout)			POP	DI			TEST	getBootFile.TCBLinkPtr, preNotifyFlag			JNZ	DoneWithFile			MOV	BX, ES:[DI].bootDataEnd			CMP	BX, ES:[DI].bootDataStart			JNE	WaitForBuffer			MOV	bootRetryCount, 10; read next sector into local buffer			PUSH	DI			CALL	DiskRead			JNC	NotifyBufferFull			POP	DI; done with file - decrement file countDoneWithFile:		POP	SI			DEC	diskWorkspace.fileCount			JZ	DoneWithAllFiles			ADD	SI, SIZE (FileSpec)			JMP	LoadLoopDoneWithAllFiles:	%EstablishHandlerAccess	(DiskHandlerID)			ASSUME	ES:DiskIOR			MOV	diskFCB.diskStartHandlerForIOP, FALSE			%NotifyCondition	(OFFSET finishedLoaderFileFetch); step 6; idle till task is subsumed			JMP	Done; utility procs			ASSUME	ES:NOTHINGCalcChecksum		PROC	NEAR;Arguments:		ES:SI	offset of word-aligned buffer;Returns:		AX:	word checksum;Uses (without saving):	CX, DXunChecksummed		EQU	0FFFFHchecksumExtent		EQU	254		; size of page, in words, minus checksums;set up for loop			PUSH	SI			MOV	CX, checksumExtent			XOR	AX, AXSumNextWord:		MOV	DX, ES:[SI]			XCHG	DH, DL		;byteswap word;The following sequence is the checksum algorithm			ADD	AX, DX			ADC	AX, 0			ROL	AX, 1;advance to next word			INC	SI			INC	SI			LOOP	SumNextWord;normalize result			CMP	AX, unChecksummed			JNE	ChecksumExit			XOR	AX, AXChecksumExit:		XCHG	AH, AL		;byteswap checksum			POP	SI			RETCalcChecksum		ENDPStuffNewDiskParms	PROC	NEAR;Arguments:		ES:SI	offset of disk shape page descriptor;Uses (without saving):	AX, BX; note that all word values in disk shape must be byte-swapped			PUSH	ES;fix IOCB first, saving values in stack			MOV	BX, OFFSET dskIOCB.diskOperationBlock			MOV	AL, ES:[SI].DSsectorsPerTrack			MOV	[BX].diskSecPerTrack, AL			MOV	AH, ES:[SI].DSheadsPerCylinder			MOV	[BX].diskHdsPerCyl, AH			PUSH	AX			MOV	AX, ES:[SI].DScylinderCount			XCHG	AH, AL	;byte-swap			MOV	[BX].cylPerDrive, AX			PUSH	AX			MOV	AX, ES:[SI].DSreducedWriteCyl			XCHG	AH, AL	;byte-swap			MOV	[BX].diskReducedWriteCyl, AX			PUSH	AX			MOV	AX, ES:[SI].DSpreCompCyl			XCHG	AH, AL	;byte-swap			MOV	[BX].diskPreCompCyl, AX			PUSH	AX; now change values in disk FCB			%EstablishHandlerAccess	(DiskHandlerID)			ASSUME	ES:DiskIOR			POP	diskFCB.rd0.diskPreCompensationCylinder			POP	diskFCB.rd0.diskReducedWriteCurrentCylinder			POP	diskFCB.rd0.diskCylindersPerDrive			POP	AX			MOV	diskFCB.rd0.diskHeadsPerCylinder, AH			MOV	diskFCB.rd0.diskSectorsPerTrack, AL			POP	ES			ASSUME	ES:NOTHING			RETStuffNewDiskParms	ENDPIOPEInRam		ENDS			END
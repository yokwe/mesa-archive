$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;-- stored as [Idun]<WDLion>Dove>IOPKernl.asm;-- created on  27-Feb-84 11:22:42;-- last edited by:;--	JAC	30-Jan-87 16:34:10	:remove SystemStack from the OpieSTK segment;--	RDH	22-Dec-86 11:30:33	:Change locking algorithm to have a long pause before reading MesaHasLock.;--	KEK	17-Apr-86 11:39:31	:use Daisy WriteMap usage.  Restore regs before calling troubleIPCS.  Save regs across Wait* calls.;--	BKI	31-Aug-85 19:09:54	:fix "carry bit return" bug in WaitForCondition and WaitForInterrupt.;--	JPM	 9-Aug-85  8:16:54	:fix bug in use of ICTaskWaiting (no "MASK" in two places).;--	JPM	 3-Aug-85  7:27:35	:added eePromVersion to EXTRNs.;--	KEK	31-Jul-85 14:25:18	:new error-checking ReadEEProm impl.;--	JPM	22-Jul-85 10:10:13	:Change IOPEInROM alignment to WORD.;--	JPM	10-Jul-85 15:45:07	:Fix AllowPC comment, put test for non-nil ptr in IOPE@NotifyClientCondition, fix bug in FromSystemState.;--	KEK	 9-Jul-85 12:56:01	:move the allowPC command into SystemLoop (accompanies a change in PCDsptch.asm);--	JPM	 8-Jul-85 13:36:22	:Fix bugs (in GenericInterruptProcessing and IOPE@ThisTaskServices).;--	JPM	 6-Jul-85 12:19:23	:Change calling sequence for FixUpTimerQueue (in RemoveQueueEntry).;--	JPM	26-Jun-85  7:58:48	:Increment timeout value in WaitForInterrupt (to ensure at least that many seconds).;--	JPM	25-Jun-85 12:27:53	:Remove EEPDefs (constants now in HardDefs).;--	JPM	24-Jun-85 12:07:44	:Reworked for correctness.;--	JPM	20-Jun-85 16:56:11	:Opie redesign.;--	KEK	18-Jun-85 16:30:26	:use the real ReadEEProm routine.;--	KEK	15-May-85 15:14:40	:add detection of spurious IR7's in GenericInterruptProcessing.;--	KEK	13-May-85 15:22:35	:remove implicit Enable from ThisTaskServices, since Enable doesn't work for 8274.;--	KEK	 9-May-85  9:55:36	:make GetLockMask assignments wraparound.;--	KEK	 8-Apr-85 19:24:20	:special case the 8274 -- use redefined meaning of "mySpecialIntrpPendingCmd".;--	KEK	 8-Apr-85 19:22:19	:CLI across Entire EOI sequence (not just masterEOI part). add POPs at error exit of ReadEEP. replace unServiced with an IRET.  Make all SPSS ops diddle SS first.;--	KEK	14-Mar-85 12:39:52	:changed printing directives. removed PUSH waitForIntState in WaitForInterrupt.;--	KEK	 2-Mar-85 18:56:23	:null-out currentTCBPtr if queue is empty; use new TCB field returnSPSS.;--	KEK	27-Feb-85 16:19:54	:WaitForInt timeout returns to caller!;		remove reference to DI in GetIntrMask.  save TCB register across call to troubleIPCS.;--	KEK	21-Feb-85 16:02:12	:remove Restart's STI/CLI lazy kludge.;--	VXS 	28-Nov-84 15:40:48	:save SI from getting smashed in RemoveQueueEntry.;--	VXS 	27-Nov-84 16:41:31	:Fix bug in RemoveQueueEntry for system queue.;--	VXS 	27-Nov-84 11:18:44	:Clear IF after setting for PUSHF in Restart. Make SetTaskToRun have a normal return so can save;						;registers in Restart (wasn't saving them);--	VXS 	26-Nov-84 17:40:03	:Fix jump condition reversed in Jam;--	VXS 	20-Nov-84 17:40:39	:Add INCLUDEs of OpieDefs and HardOpie;--	VXS 	20-Nov-84 15:15:30	:Change .queue to .taskQueue to avoid naming conflict.;--	VXS 	15-Nov-84 13:53:38	:Implement ControlRegister macro;--	VXS 	15-Nov-84 10:56:05	:Complete the implementation of Jam.;--	VXS 	15-Nov-84 10:48:43	:Fix bug in Jam - SI being used instead of BX.;--	VXS 	14-Nov-84 18:24:00	:Install John's changes into GetLockMask and ReadEEProm;--	VXS 	14-Nov-84 13:04:24	:Re-do Queues to use structure names, and for each entry to record the head so can be removed no matter where it is in the queue.;--	JPM	13-Nov-84 17:48:01	:changed ReadEEProm to read bytes (original date of change 12-Oct-84 16:20:59, merged by VXS);--	VXS 	12-Nov-84 19:33:47	:don't smash SI in initializetask;--	VXS 	 8-Nov-84 15:47:23	:Make InitializeTask crash if called after we tell booting where free space is.;--	VXS 	 7-Nov-84 12:59:11	:Change logic at system loop to maintain last interesting state instead of waitForSystem state, optimize code.;--	VXS 	 5-Nov-84 22:38:20	:Fix bug in new WaitForCondition return stuff.;--	VXS 	 5-Nov-84 18:22:42	:Disable allocation of stacks in IORegion so can assemble in PC IORegion.;--	VXS 	 5-Nov-84 18:05:18	:add RegisterPCEStartRoutine, CallPCEStartRoutine;--	VXS 	 1-Nov-84 12:59:57	:Fix bug in WaitForCondition where AL doesn't get setup with proper value on return.;--	VXS 	16-Oct-84 19:27:55	:Fix bug in clearanddismiss interrupt which prevented EOI to master on 8259 slave.;--	VXS 	15-Oct-84 18:30:03	:Fix bug in restart where flags for task would be set with IF=0, and where STD didn't happen in SetTaskToRun;--	VXS 	15-Oct-84 13:03:27	:added PUBLIC of IOPE@Restart;--	VXS 	12-Oct-84 18:18:48	:Add new Restart macro, Jam macro.;--	VXS 	11-Oct-84 16:37:19	:Fix bug that somehow mysteriously got into IOPE@WaitForInterrupt;--	VXS 	11-Oct-84 10:13:20	:Fix the allowRDC stuff at systemloop to do an allowRDC+HoldIOP when idle.;--	VXS 	10-Oct-84 18:40:04	:Add IOPE@Reset implementation.;--	VXS 	 8-Oct-84 10:40:55	:put missing SetupTaskMapRegister at ExitEOI;--	VXS 	 4-Oct-84 18:01:34	:Put AllowRDC and AllowPC into system idle loop.;--	VXS 	 4-Oct-84 10:49:25	:remove IOPE@EstablishAccess;--	VXS 	 1-Oct-84 19:13:32	:modified temporary code in IOPEEstablishAccess to use CX and DX.;--	VXS 	28-Sep-84 15:03:28	:remove PUBLIC of IOPE@ConvertAddress;--	VXS 	26-Sep-84 13:04:03	:Fixed bug where watchdog could go off after interrupt came in and no new WaitForInterrupt happened.;--	VXS 	24-Sep-84 12:41:23	:Fixed bug where indefinite interrupts on a channel caused stack overflow because IF was on after master EOI.;--	VXS 	17-Sep-84 18:22:05	:changed interface to IOPE@ClientNotify so that Offset is in AX. (DI no longer used for calling);						Also added UnexpectedInterrupt value instead of zeroing AX for unexpected interrupts;--	VXS 	 6-Sep-84 14:30:06	:changed BadNews macro to Crash macro, taking reason as argument.;--	VXS 	 6-Sep-84 14:07:49	:Fixed bug in NotifyClientCondition, changed to using segment overrides;--						 instead of saving and restoring DS (fewer bytes used this way);--	VXS 	 5-Sep-84 18:39:20	:Added fake IOPE@BindweedIntr.;--	VXS 	 5-Sep-84 18:05:26	:Made ClientConditions bypass notify mask if pointer is zero.;--	VXS 	 4-Sep-84 19:09:15	:Changed EstablishIOPAddress To EstablishAccess;--	VXS 	 4-Sep-84 14:00:23	:Put IOPE@ClientNotify in;--	VXS 	30-Aug-84 13:31:46	:Make enable and disable specific interrupt routines check for sub-interrupts.;						: Squeeze code while doing this by creating GetInterruptMask routine.;--	VXS 	28-Aug-84 15:19:08	:Fix bug in Sub-Interrupts (must do specific compare against sub interrupt port);--	VXS 	27-Aug-84 16:27:31	:Sub-Interrupt Implementation. Also compact interrupt interpreter with a macro.;--	VXS 	23-Aug-84 13:29:16	:Fix bug in Getmemory - compare against size in wrong place;--	VXS 	20-Aug-84 18:24:32	:Fix bug in multiple notifies of condition variable;--	VXS 	14-Aug-84 19:28:06	:Add per task stacks;--	VXS 	14-Aug-84 12:40:50	:save a little code by jumping to enable specific interrupt.;--	VXS 	 8-Aug-84 15:46:22	:tempEEPromImage is now a segment.;--	VXS 	 7-Aug-84 19:46:58	:moved definition of tempEEPromImageSeg to IOPLRam.asm;--	VXS 	25-Jul-84 12:27:23	:Include listings of IOPDefs and EEPDefs;--	JPM 	20-Jul-84 16:59:36	:Implemented several macros;--	VXS 	17-Jul-84 19:06:28	:changed unserviced routine not to use;								 normal ICB stuff, just JMP $ for now.;--	VXS 	16-Jul-84 19:22:00	:Added missing INCLUDE of EEPDefs.asm;--	VXS 	16-Jul-84 15:43:18	:Added EXTRNs that used to be in IOImport;								 IOImport no longer exists, take out INCLUDE;--	VXS 	 5-Jul-84 19:01:55	:changed Paritycheck to Parity for consistency;--	VXS 	 5-Jul-84 16:12:52	:Saved code at EOImaster by using byte form;--	JPM	 3-Jul-84 15:03:34	:added IOPE@ReadEEProm;--	JMM 	27-Jun-84 15:13:57	:Opie Version 1 release;--	JMM	26-Jun-84 16:02:05;	;Added stack error hang!;--	VXS/ETN	24-Jun-84 15:54:11;	;Took out erroneous change of task state;								;to preNotifyState at PreNotify:;--	JMM     22-Jun-84  7:24:42	;CreationNAME			IOPKernl;--------------------------------------------------------------------------------$NOLIST$INCLUDE		(IOPDefs.asm)$INCLUDE		(HardOpie.asm)$INCLUDE		(OpieDefs.asm)$INCLUDE		(IOPMacro.asm)$LIST;--------------------------------------------------------------------------------;********************************************************************************EXTRN			SystemHandlerID: ABSIOPELocalRAM		SEGMENT	AT 0;EXTRNs from IOPELocalRAM segmentEXTRN			prebootSwitches: WORDEXTRN			controlRegData: WORDEXTRN			resetRegData: WORDEXTRN			eePromVersion: WORDEXTRN			IORSegmentTableAddress: SegmentAndOffsetEXTRN			IOROpieSegmentAddress: WORDEXTRN			softwareIntrptVctBase: DWORD; software interrupt vector addressCallPCEStartRoutineSIV	EQU	softwareIntrptVctBase + 4 * (CallPCEStartRoutineSIVType - softwareIntrptVctType)IOPELocalRAM		ENDS;********************************************************************************IORegion		SEGMENT	COMMON;EXTRNs from the IORegion:EXTRN			mesaHasLock: WORD, iopRequestsLock: WORDIORegion		ENDS;********************************************************************************OpieIOR			SEGMENT	COMMON;EXTRNs from Opie's IORegion:EXTRN			SegmentTableAddress: SegmentAndOffsetEXTRN			lockMaskCount: BYTEEXTRN			currentTaskTCBPtr: WORDEXTRN			systemQueue: IOPEQueue, timerQueue: IOPEQueueEXTRN			workMaskCount: BYTEEXTRN			workMaskLimit: BYTEEXTRN			workMaskConditionPtrs: WorkMaskConditionPtrEXTRN			intervalTimer: WORDEXTRN			generalMapRegisterImage: WORDOpieIOR			ENDS;********************************************************************************OpieSTK			SEGMENT	COMMON;EXTRNs from Opie's Stack Segment:EXTRN			IOPEStack: WORDOpieSTK			ENDSSystemSTK		SEGMENT		COMMONEXTRN			SystemStack: WORDSystemSTK		ENDS;********************************************************************************IOPEInROM		SEGMENT	WORD PUBLIC			ASSUME	CS:IOPEInROM			ASSUME	DS:NOTHING, ES:NOTHING;External procedures:EXTRN			InsertInTimerQueue: NEAREXTRN			FixUpTimerQueue: NEAREXTRN			WriteMap: NEAR;;--------------------------------------------------------------------------------;;Software interrupt entry points:PUBLIC			IOPE@CallPCEStartRoutinePUBLIC			IOPE@ControlRegister;			IOPE@ConvertAddress in IOPLMap.asmPUBLIC			IOPE@DisablePUBLIC			IOPE@EnablePUBLIC			IOPE@EstablishHandlerAccess;			IOPE@EstablishIOPAccess in IOPLMap.asmPUBLIC			IOPE@GetIntervalTimerPUBLIC			IOPE@GetLockMaskPUBLIC			IOPE@GetWorkMaskPUBLIC			IOPE@InitializeTaskPUBLIC			IOPE@JamPUBLIC			IOPE@MesaLockedOutPUBLIC			IOPE@NotifyClientConditionPUBLIC			IOPE@NotifyConditionPUBLIC			IOPE@NotifyHandlerConditionPUBLIC			IOPE@ReadEEPromPUBLIC			IOPE@RegisterPCEStartRoutinePUBLIC			IOPE@ResetPUBLIC			IOPE@RestartPUBLIC			IOPE@ThisTaskServicesPUBLIC			IOPE@WaitForConditionPUBLIC			IOPE@WaitForInterruptPUBLIC			IOPE@WaitForSystemPUBLIC			IOPE@WaitForTime;Miscellaneous entry points:PUBLIC			SystemLoopPUBLIC			ReadEEPromPUBLIC			InsertInSystemQueuePUBLIC			RemoveFromQueuePUBLIC			GenericInterruptProcessing, ReadMasterISR, ReadSlaveISRPUBLIC			UnServiced;-------------------------------------------------------------------------------;-- System level services;-------------------------------------------------------------------------------;--------------  Assume parameter locations upon entry into;--------------  GenericInterruptProcessing procedure are as follows:;--------------   stack contains: segment/offset of InterruptContext,;--------------|		  registers saved via PUSHA,			|;--------------|		  return address & flags			|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|  old stack contains: TCB offset, ES, DS,			|;--------------|  		      registers saved via PUSHA,		|;--------------|  		      return address & flags			|;--------------|  new stack, ES, DS for interrupt servicing task		|;--------------|								|;-------------------------------------------------------------------------------;IR7 interrupts check for a famous Intel-8259-generated Spurious IR7 (s'IR7).;	If it's a master s'IR7, then master ISR is zero.;	If it's a slave s'IR7, then slave ISR is zero.ReadMasterISR:		IN	AL, i8259MasterInServiceRegAddr			CMP	AL, 0			;Is masterISR = 0?			JNE	GenericInterruptProcessingSpuriousIR7:		ADD	SP, 4			;Skip IC seg & offset			POPA			IRETReadSlaveISR:		IN	AL, i8259SlaveInServiceRegAddr			CMP	AL, 0			;Is slaveISR = 0?			JE	SpuriousIR7			;It was a real (non-spurious) interrupt!;Save the rest of the interrupted task's context (regs saved previously with PUSHA)GenericInterruptProcessing:			MOV	AX, DS			;put DS in temp reg			POP	DI			;get InterruptContext and			POP	DS			;  Opie's IORegion segment			ASSUME	DS:OpieIOR			PUSH	AX			;save old DS and			PUSH	ES			; ES values			TEST	[DI].interruptStatus, MASK ICTaskWaiting			JZ	UnexpectedInterrupt			PUSH	currentTaskTCBPtr	;save current TCB			PUSH	generalMapRegisterImage	; and general map reg data			MOV	[DI].interruptStatus, MASK ICActive			MOV	AL, [DI].interruptHandlerID	;Get handler ID for interrupting task in AX			CBW			MOV	SI, [DI].interruptTCBLinkPtr	;Get TCB address for interrupting task in SI			MOV	currentTaskTCBPtr, SI			LES	BX, SegmentTableAddress			SHL	AX, 2			ADD	BX, AX			MOV	DX, DS			;save OpieIOR segment			MOV	DS, ES:[BX].ioRegionSegment			ASSUME	DS:NOTHING			MOV	[SI].returnSPSS.segmentValue, SS	;store return addrs in returnSPSS			MOV	[SI].returnSPSS.offsetValue, SP			MOV	SS, ES:[BX].stackSegment			MOV	SP, [SI].taskSP			MOV	[SI].taskState, prevStatewaitForInterrupt+interruptState			MOV	ES, DX			;load ES with OpieIOR segment temporarily			ASSUME	ES:OpieIOR;restore general map reg data for this task (previously pushed onto stack)			POP	AX			MOV	generalMapRegisterImage, AX			MOV	DX, generalMapRegister			CALL	WriteMapRunTaskAtInterruptLevel:				;Label for easy debugging.			POP	ES			ASSUME	ES:NOTHING			IRET				;return to the task.			ASSUME	DS:OpieIORUnexpectedInterrupt:	OR	[DI].interruptStatus, MASK ICUnexpected			MOV	AX, SS			MOV	DX, SP			LES	BX, SegmentTableAddress			MOV	SS, ES:[BX].stackSegment			MOV	SP, OFFSET IOPEStackCallTroubleProc:	PUSHA			CALL	DWORD PTR [DI].troubleIPCS			POPA			MOV	SS, AX			MOV	SP, DX			AND	[DI].interruptStatus, NOT MASK ICUnexpected			JMP	ClearAndDismissInterrupt			ASSUME	DS:NOTHING;Here, so as not to waste instruction space, is where we point to for the CallPCEStartRoutine INT instruction, which; PCE later fills in itself.IOPE@CallPCEStartRoutine:		;Vector that points here replaced by RegisterPCEStartRoutineUnServiced:			IRET;-- System level services: (Macro call is - "ControlRegister (Mask,Value)"  );-------------------------------------------------------------------------------;--------------|								|;--------------|	Entry:	CX contains Mask				|;--------------|	 AX contains Value (in which only the bits selected by	|;--------------|	  the mask are valid; others should remian unchanged)	|;--------------|--------							|;--------------|	Exit: All registers preserved except AX & CX		|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------IOPE@ControlRegister:			PUSH	DS			PUSH	AX			MOV	AX, IOPELocalRAM			MOV	DS, AX			ASSUME	DS:IOPELocalRAM			POP	AX			AND	AX, CX			NOT	CX			AND	CX, controlRegData			OR	AX, CX			OUT	WriteCtlReg, AX			MOV	controlRegData, AX			POP	DS			ASSUME	DS:NOTHING			IRET;-- System level services: (Macro call is - "Disable (interruptName)"  );-------------------------------------------------------------------------------;--------------  Assumes:;--------------|		BX = interrupt vector number.			|;--------------|								|;--------------|--------							|;--------------| Upon exiting the specified interrupt is disabled		|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;Note must run with interrupts off (default since INT turns off IF) because; interrupt level could also disable its own interrupt channel.	IOPE@Disable:			PUSHA			CALL	GetInterruptMask			JZ	IOPE@D@CantBeMasked			NOT	AH			OR	AL, AH			OUT	DX, ALIOPE@D@CantBeMasked:	POPA			IRET;Routine to get interrupt data in AX, Port in DX.;Called by IOPE@Disable, IOPE@Enable;;Returns DX/ interruptMaskPort;	AH/ interruptMask;	AL/ Current Interrupt Mask data;;Must run with interrupts off, in case interrupt level code changes interrupt mask. (;Returns so that ZF=1 if it can't be masked, =0 if it can. (so can JZ <not>)GetInterruptMask:	PUSH	DS			MOV	AX, IOPELocalRAM			MOV	DS, AX			SHL	BX, 2			LDS	BX, DWORD PTR [BX]			MOV	SI, [BX].ICBcontext.interruptController			MOV	DX, [SI].interruptMaskPort			CMP	DX, Null	;If can't be masked,			JZ	GotInterruptMask			MOV	AH, [BX].ICBcontext.interruptMask			IN	AL, DXGotInterruptMask:	POP	DS			RET;-- System level services: (Macro call is - "Enable (interruptName)"  );-------------------------------------------------------------------------------;--------------  Assumes:;--------------|		BX = interrupt vector number.			|;--------------|								|;--------------|								|;--------------|--------							|;--------------| Upon exiting the specified interrupt is enabled		|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;Note must run with interrupts off (default since INT turns off IF) because; interrupt level could also disable its own interrupt channel.		IOPE@Enable:			PUSHA			CALL	GetInterruptMask			JZ	IOPE@E@CantBeMasked			AND	AL, AH			OUT	DX, ALIOPE@E@CantBeMasked:	POPA			IRET;-- System level services: (Macro call is - "EstablishHandlerAccess (handlerID)");-------------------------------------------------------------------------------;--------------  Assumes:;--------------|		AX = handler ID.				|;--------------|--------							|;--------------| Upon exiting:							|;--------------|  		ES = IORegion segment value for handler.	|;--------------|		AX destroyed.					|;-------------------------------------------------------------------------------IOPE@EstablishHandlerAccess:			PUSH	BX			%LoadHandlerSegment	(ES,BX)			POP	BX			IRET;-- System level services: (Macro call is - "GetIntervalTimer"  );-------------------------------------------------------------------------------;--------------  Assumes:;--------------|		No inputs.					|;--------------|--------							|;--------------| Upon exiting:							|;--------------|  		AX = current value of the interval timer.	|;--------------|								|;-------------------------------------------------------------------------------	IOPE@GetIntervalTimer:			PUSH	DS			%LoadOpieSegment	(DS,AX)			ASSUME	DS:OpieIOR			MOV	AX, intervalTimer	; load interval timer			POP	DS			ASSUME	DS:NOTHING			IRET;-- System level services: (Macro call is - "GetLockMask"  );-------------------------------------------------------------------------------;--------------  Assumes:;--------------|		No inputs. This simply accesses an allocator.	|;--------------|--------							|;--------------| Upon exiting:							|;--------------|  		AX = the next lock mask value.			|;--------------|								|;-------------------------------------------------------------------------------	IOPE@GetLockMask:			PUSH	CX			; save old value of CX			PUSH	DS			%LoadOpieSegment	(DS,AX)			ASSUME	DS:OpieIOR			MOV	CL, lockMaskCount	; load mask count			INC	CL			; increment mask count			MOV	lockMaskCount, CL	;  and store			MOV	AX, 1	; generate word mask from CL			ROR	AX, CL	;  by rotating 1 into AX			POP	DS			ASSUME	DS:NOTHING			POP	CX	; restore CX			IRET;-- System level services: (Macro call is - "GetWorkMaskForCondition	(conditionPtr)"  );-------------------------------------------------------------------------------;--------------  Assumes:;--------------|		BX = conditionPtr.				|;--------------|								|;--------------|--------							|;--------------| Upon exiting:							|;--------------|  		AX = work mask value (byte offset and mask).	|;--------------|  		BX is destroyed.				|;--------------|								|;-------------------------------------------------------------------------------	IOPE@GetWorkMask:			PUSH	ES			PUSH	CX	; save old value of CX			CMP	BX, MASK workMaskConditionOffset			JG	WorkMaskErr			%LoadOpieSegment	(ES,CX)			ASSUME	ES:OpieIOR			MOV	CL, workMaskCount	; load mask count			CMP	CL, workMaskLimit	;  if all masks used,			JGE	WorkMaskErr		;   jump to error handler			MOV	AX, BX			MOV	BX, currentTaskTCBPtr			MOV	BL, [BX].taskHandlerID			SHL	BL, 1			OR	AH, BL			MOV	BX, CX			SHL	BX, 1			MOV	workMaskConditionPtrs[BX], AX			MOV	AH, CL			SHR	AH, 3			INC	CL			; increment mask count			MOV	workMaskCount, CL	;  and store			MOV	AL, 1	; generate byte mask from CL			ROR	AL, CL	;  by rotating 1 into ALWorkMaskDone:		POP	CX	; restore CX			POP	ES			ASSUME	ES:NOTHING			IRETWorkMaskErr:		XOR	AX, AX			JMP	WorkMaskDone;-- System level services: (Macro call is - "InitializeTask (handlerID, taskPtr, initLoc, initialStackPtr)"  );-------------------------------------------------------------------------------;--------------  Assumes:;--------------;--------------|		AX = handler ID					|;--------------|		SI = TCB offset for the new task.		|;--------------|		CX:DX = IP:CS for new task.			|;--------------|		DI = stack pointer for the new task.		|;--------------|								|;--------------|		Called in another tasks context, either from	|;--------------|		initialization or from the watchdog timer's	|;--------------|		context						|;--------------|								|;--------------|		Must run with interrupts off (INT does that)    |;--------------|--------							|;--------------| Upon exiting:							|;--------------|								|;--------------|  	AX, SI, CX, DX, DI = Trashed.				|;--------------|  	    							|;--------------|  		   						|;--------------|								|;-------------------------------------------------------------------------------;IOPE@InitializeTask:			PUSH	DS			PUSH	ES			PUSH	BX			PUSH	SI			%LoadHandlerAndOpieSegments	(SI,BX)			POP	SI			SHR	AX, 2			MOV	[SI].taskHandlerID, AL			MOV	[SI].taskICPtr, Null			MOV	[SI].taskState, unInitializedState	;for the record			CALL	SetTaskToRun			POP	BX			POP	ES			POP	DS			IRET				;return to caller.;-- System level services: (Macro call is - "Jam	(handlerID, taskPtr)"  );-------------------------------------------------------------------------------;--------------  Assumes:;--------------|		AX = handler ID for task to jam			|;--------------|		SI = TCB for task to jam			|;--------------|--------							|;--------------| Upon exiting:							|;--------------|								|;--------------|  								|;--------------|  								|;-------------------------------------------------------------------------------	IOPE@Jam:		PUSH	DS			PUSH	ES			PUSH	DI			%LoadHandlerAndOpieSegments	(DI,)			ASSUME	ES:OpieIOR			TEST	[SI].taskState, runningStateMask			JZ	JamWaitingTask			OR	[SI].taskState, jamStateMask			JMP	JamCompletedJamWaitingTask:		CALL	RemoveQueueEntry	;take off queue if he's on one.			MOV	AL, [SI].taskState			SHL	AL, Nibble			OR	AL, jammedState			MOV	[SI].taskState, AL			CMP	AL, prevStatewaitForInterrupt+jammedState			JNE	JamTestWaitCond			MOV	DI, [SI].taskICPtr			AND	ES:[DI].interruptStatus, NOT (MASK ICTimed OR MASK ICTaskWaiting)			JMP	SHORT JamCompletedJamTestWaitCond:	CMP	AL, prevStatewaitForCondition+jammedState			JNE	JamCompleted			MOV	DI, [SI].taskCondition			MOV	[DI].TCBLinkPtr, NullJamCompleted:		POP	DI			POP	ES			ASSUME	ES:NOTHING			POP	DS			IRET;-- System level services: (Macro call is - "MesaLockedOut	(operation,;-------------- 			  dataPtr, dataRegOrVal, lockMask)"  );-------------------------------------------------------------------------------;--------------  Assumes:;--------------|	AX = dataValue						|;--------------|	BX = dataPtr						|;--------------|	CX = lockPtr						|;--------------|	DX = operation (0 = ADD, 1 = AND, 2 = OR, 3 = XCHG,	|;--------------|			4 = MOV)				|;--------------|--------							|;--------------| Upon exiting:							|;--------------|	AX = result of operation				|;-------------------------------------------------------------------------------	IOPE@MesaLockedOut:			PUSH	ES			PUSH	AX			MOV	AX, IOPELocalRAM			MOV	ES, AX			MOV	ES, ES:IORSegmentTableAddress.segmentValue			ASSUME	ES:IORegion			POP	AX			SHL	DX, 2			; compute instruction offset for operation			ADD	DX, OFFSET LockedOp	;  and add to operation start			OR	iopRequestsLock, CX	; request lock for IOP;			JMP	SHORT MesaLockedOut1	; give time for mesa to see request;MesaLockedOut1:	JMP	SHORT MesaLockedOut2	;  (jumps safer than no-ops for timing)			PauseCount	EQU	50			PUSH	CX			MOV	CX, PauseCountDelayLoop:		LOOP 	DelayLoop	;17 cycles per jump 'back'			POP	CX			;Pause =  50 * 17 * 125 nS = 106250 nS ~ 100 uS				;We believe a pause of up to 1 mS is not damaging 			; to performance.			MesaLockedOut2:		TEST	CX, mesaHasLock	; see if mesa already has lock			JNZ	MesaLockedOut2	;  if so, loop			JMP	DX	; use indirect jump to select operationLockedOp:		; each set of instructions (except the last) must take exactly 4 bytes to encode;LockedADD			ADD	[BX], AX	; IOP has lock, so ADD is atomic			JMP	SHORT MesaLockedOut3;LockedAND			AND	[BX], AX	; IOP has lock, so AND is atomic			JMP	SHORT MesaLockedOut3;LockedOR			OR	[BX], AX	; IOP has lock, so OR is atomic			JMP	SHORT MesaLockedOut3;LockedXCHG			XCHG	[BX], AX	; IOP has lock, so XCHG is atomic			JMP	SHORT MesaLockedOut3;LockedMOV			MOV	[BX], AX	; IOP has lock, so MOV is atomic (wrt Mesa);MesaLockedOut3:		XOR	iopRequestsLock, CX	; release lock			POP	ES			ASSUME	ES:NOTHING			IRET;-- System level services: (Macro call is - "NotifyClientCondition	(address of clientConditionPtr)"  );-------------------------------------------------------------------------------;--------------  Assume parameter locations upon entry into;--------------  NotifyClientCondition procedureare as follows:;--------------;--------------|		AL = Handler ID for client variables.		|;--------------|		AH = Offset to client mask from condition.	|;--------------|		BX = Pointer to condition.			|;--------------|		CX = Client mask.				|;--------------|								|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|								|;--------------|  								|;--------------|  								|;--------------|  								|;--------------|								|;-------------------------------------------------------------------------------IOPE@NotifyClientCondition:			TEST	BX, nonNilPtr			JZ	CancelThisClientNotify			AND	BH, NOT HIGH nonNilPtr			PUSH	DS			PUSH	SI			PUSH	AX			CBW			%LoadHandlerSegment	(DS,SI)			POP	AX			JCXZ	CommonNotifyCode			PUSH	BX			MOV	AL, AH			CBW			ADD	BX, AX			OR	[BX], CX			POP	BX			JMP	SHORT CommonNotifyCodeCancelThisClientNotify:	IRET;-- System level services: (Macro call is - "NotifyCondition	(conditionPtr)"  );-------------------------------------------------------------------------------;--------------  Assume parameter locations upon entry into Notify procedure;--------------  are as follows:;--------------;--------------|		BX = Pointer to the condition variable.		|;--------------|								|;--------------|		Interrupts off (INT ensures that)		|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|								|;--------------|  								|;--------------|  								|;--------------|  								|;--------------|								|;-------------------------------------------------------------------------------IOPE@NotifyCondition:			PUSH	DS			PUSH	SI			JMP	SHORT CommonNotifyCode;-- System level services: (Macro call is - "NotifyHandlerCondition (handlerID, conditionPtr)"  );-------------------------------------------------------------------------------;--------------  Assume parameter locations upon entry into Notify procedure;--------------  are as follows:;--------------;--------------|		AX = Handler ID for the condition variable.	|;--------------|		BX = Pointer to the condition variable.		|;--------------|								|;--------------|		Interrupts off (INT ensures that)		|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|								|;--------------|  								|;--------------|  								|;--------------|  								|;--------------|								|;-------------------------------------------------------------------------------IOPE@NotifyHandlerCondition:			PUSH	DS			PUSH	SI			%LoadHandlerSegment	(DS,SI);   At this point, DS:[BX] points to the condition.CommonNotifyCode:			TEST	[BX].TCBLinkPtr, nonNilPtr			JNZ	NotifyTaskInCV;Either it's null or prenotified.			MOV	[BX].TCBLinkPtr, preNotifyFlag			JMP	SHORT NotifyTaskInCVDoneNotifyTaskInCV:		MOV	SI, [BX].TCBLinkPtr			AND	SI, NOT nonNilPtr			MOV	[BX].TCBLinkPtr, Null	;Null is flag that nothing is there.;  At this point, DS:[SI] points to a taskContextBlock.;    If necessary, remove the TCB from IOPETimer queue.			PUSH	ES			%LoadOpieSegment	(ES,BX)			ASSUME	ES:OpieIOR			PUSH	DI			PUSH	AX			CALL	RemoveQueueEntry;  Move the TCB to the System queue.			CALL	InsertInSystemQueue			POP	AX			POP	DI			POP	ES			ASSUME	ES:NOTHINGNotifyTaskInCVDone:	POP	SI			POP	DS			IRET;-- System level services: (Macro call is - "ReadEEProm (eePromAddress, eePromVersion)"  );-------------------------------------------------------------------------------;--------------  Assumes:;--------------|		AX = earliest acceptable version.		|;--------------|		BX = address (segment, byte or word, index).	|;--------------|								|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|		AX = value of indexed byte/word in EEProm.	|;--------------|  		BX = address.					|;--------------|  		CF set if checksum error or version mismatch.	|;--------------|  								|;-------------------------------------------------------------------------------	IOPE@ReadEEProm:			PUSH	DS			PUSH	BP			MOV	BP, IOPELocalRAM			MOV	DS, BP			ASSUME	DS:IOPELocalRAM			MOV	BP, SP			TEST	prebootSwitches, dontTrustEEPROM			JNZ	ReadEEPromSuspect			PUSH	BX			SHR	BX, 12			CMP	AX, eePromVersion[BX]			POP	BX			JG	ReadEEPromSuspectReadEEPromOK:		AND	WORD PTR SS:[BP]+eePromStackFlagOffset, NOT MASK i80186CF			JMP	SHORT ReadEEPromGetDataReadEEPromSuspect:	OR	WORD PTR SS:[BP]+eePromStackFlagOffset, MASK i80186CFReadEEPromGetData:	POP	BP			PUSH	BX			MOV	BH, 0			CMP	BX, bytesInEEProm ; is index within limits?			JGE	ReadEEPromBadIndex			SHR	BX, 1		; convert byte-offset to word-offset			CALL	ReadEEProm	; call proc			POP	BX			TEST	BH, HIGH wordEEPromOffset ; is entire word wanted?			JNZ	ReadEEPromDone	;  if so, we've got it; Need to use only one of the bytes, right-justified within the word			TEST	BL, 1		; odd or even? (even = low byte)			JZ	ReadEEPromZeroHighByte			MOV	AL, AH		; odd = high byte (move to low)ReadEEPromZeroHighByte:	XOR	AH, AHReadEEPromDone:		POP	DS			ASSUME	DS:NOTHING			IRET; Index too large, return 0ReadEEPromBadIndex:	XOR	AX, AX			POP	BX			POP	DS			IRETReadEEProm:;	at entry, BX = EEProm word address (0-63);	at exit, AX = EEProm data (16 bits)			PUSH	BX			PUSH	CX			OR	BL, EEPCmdRead			MOV	AX, EEPEnable			OUT	WriteConfigReg, AX			XOR	AX, EEPClk			OUT	WriteConfigReg, AX			XOR	AX, EEPClk			OUT	WriteConfigReg, AX			OR	AX, EEPWriteDataMask			MOV	CX, 9SendCommandLoop:	OUT	WriteConfigReg, AX			XOR	AX, EEPClk			OUT	WriteConfigReg, AX			XOR	AX, EEPClk			OUT	WriteConfigReg, AX			SHL	BL, 1			JC	SCData1SCData0:		AND	AX, NOT EEPWriteDataMask			JMP	SHORT SCEndLoopSCData1:		OR	AX, EEPWriteDataMaskSCEndLoop:		LOOP	SendCommandLoop			XOR	BX, BX			MOV	CX, 16ReadEEPromLoop:		MOV	AX, EEPEnable+EEPClk			OUT	WriteConfigReg, AX			XOR	AX, EEPClk			OUT	WriteConfigReg, AX			IN	AX, ReadInputPort			TEST	AX, EEPReadDataMask			JZ	ReadEEPShiftData			STCReadEEPShiftData:	RCL	BX, 1			LOOP	ReadEEPromLoop			MOV	AX, EEPEnable+EEPClk			OUT	WriteConfigReg, AX			XOR	AX, EEPEnable			OUT	WriteConfigReg, AX			MOV	AX, 0			OUT	WriteConfigReg, AX			MOV	AX, BX			POP	CX			POP	BXReadEEPromEnd:		RET;-- System level services: (Macro call is - "RegisterPCEStartRoutine		(location)"  );-------------------------------------------------------------------------------;--------------|	Entry: CX-DX contains IP:CS of INT routine to be	|;--------------|		called when Opie is about to surrender the bus	|;--------------|								|;--------------|--------							|;--------------|	Exit: All registers preserved 				|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------IOPE@RegisterPCEStartRoutine:			PUSH	DS			PUSH	AX			;save it			MOV	AX, IOPELocalRAM			MOV	DS, AX			ASSUME	DS:IOPELocalRAM			MOV	CallPCEStartRoutineSIV.offsetValue, CX			MOV	CallPCEStartRoutineSIV.segmentValue, DX			POP	AX			POP	DS			ASSUME	DS:NOTHING			IRET				;return.;-- System level services: (Macro call is - "Reset		(deviceResetMask)"  );-------------------------------------------------------------------------------;--------------  Assumes: Task's Handler owns device it is resetting.		|;--------------  	AX/ bit or bits involved in reset.			|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|	AX destroyed						|;--------------|								|;-------------------------------------------------------------------------------IOPE@Reset:			PUSH	DS			PUSH	CX			MOV	CX, IOPELocalRAM			MOV	DS, CX			ASSUME	DS:IOPELocalRAM			MOV	CX, AX			NOT	AX			AND	AX, resetRegData			OUT	WriteResetReg, AX			OR	AX, CX;delay, to ensure the signal goes low for the longest time any of the devices needs it			MOV	CX, maximumResetDelayCount			LOOP	$			OUT	WriteResetReg, AX			MOV	resetRegData, AX			POP	CX			POP	DS			ASSUME	DS:NOTHING			IRET;-- System level services: (Macro call is - "Restart (handlerID, taskPtr, initLoc, initialStackPtr)"  );-------------------------------------------------------------------------------;--------------  Assumes:;--------------;--------------|		AX = handler ID					|;--------------|		SI = TCB offset for the task.			|;--------------|		CX:DX = IP:CS for restarting task.		|;--------------|		DI = stack pointer for the task.		|;--------------|								|;--------------|		Usually called in another task's context	|;--------------|								|;--------------|		Must run with interrupts off (INT does that)    |;--------------|--------							|;--------------| Upon exiting:							|;--------------|								|;--------------|  	AX, SI, CX, DX, DI = Trashed.				|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------IOPE@Restart:		PUSH	DS			PUSH	ES			PUSH	BX			PUSH	SI			%LoadHandlerAndOpieSegments	(SI,BX)			ASSUME	ES:OpieIOR			POP	SI			TEST	[SI].taskState, runningStateMask			JZ	RestartWaitingTask			MOV	[SI].taskQueue.offsetValue, CX			MOV	[SI].taskQueue.segmentValue, DX			MOV	[SI].timerValue, DI			OR	[SI].taskState, restartStateMask			JMP	SHORT RestartCompletedRestartWaitingTask:	PUSH	DI			CALL	RemoveQueueEntry			POP	DI			CALL	SetTaskToRun			CMP	[SI].taskState, prevStatewaitForInterrupt+waitForSystemState			JNE	RestartTestWaitCond			MOV	BX, [SI].taskICPtr			AND	ES:[BX].interruptStatus, NOT (MASK ICTimed OR MASK ICTaskWaiting)			JMP	SHORT RestartCompletedRestartTestWaitCond:	CMP	[SI].taskState, prevStatewaitForCondition+waitForSystemState			JNE	RestartCompleted			MOV	BX, [SI].taskCondition			MOV	[BX].TCBLinkPtr, NullRestartCompleted:	POP	BX			POP	ES			ASSUME	ES:NOTHING			POP	DS			IRET				;return to caller.;-- System level services: (Macro call is - "ThisTaskServices 	(ICBPtr, badInterruptPROCLoc)"  );-------------------------------------------------------------------------------;--------------  Assume parameter locations upon entry into ThisTaskServices;--------------  procedure are as follows:;--------------;--------------|		BX = interrupt vector number.			|;--------------|	     CX:DX = IP:CS for bad interrupt PROC entry.	|;--------------|								|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|  		Task requesting service will continue.		|;--------------|  		   						|;--------------|								|;-------------------------------------------------------------------------------	IOPE@ThisTaskServices:			PUSH	ES			PUSH	AX			MOV	AX, IOPELocalRAM			MOV	ES, AX			SHL	BX, 2			LES	BX, DWORD PTR ES:[BX]			ASSUME	ES:OpieIOR			ADD	BX, ICBcodeBytes			PUSH	DI			MOV	DI, currentTaskTCBPtr; at this point ES:[BX] points to IC, and DS:[DI] points to TCB.			MOV	AL, [DI].taskHandlerID			MOV	ES:[BX].interruptHandlerID, AL			MOV	ES:[BX].interruptTCBLinkPtr, DI			MOV	ES:[BX].troubleIPCS.offsetValue, CX			MOV	ES:[BX].troubleIPCS.segmentValue, DX			MOV	[DI].taskICPtr, BX			POP	DI			POP	AX			POP	ES			ASSUME	ES:NOTHING			IRET;-- System level services: (Macro call is - "WaitForCondition	(conditionPtr,;-------------- 			   timeoutInterval)"  );-------------------------------------------------------------------------------;--------------  Assumes:;--------------;--------------|		BX = IORegion offset for the condition variable.|;--------------|		AX = Timeout interval however 0 => don't timeout|;--------------|								|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|								|;--------------|  								|;--------------|  								|;--------------|  								|;--------------|								|;-------------------------------------------------------------------------------	IOPE@WaitForCondition:			PUSH	ES;The following two lines of code fix the "carry bit return" bug			MOV	BP, SP			AND	WORD PTR SS:[BP]+stackFlagOffset, NOT MASK i80186CF			%LoadOpieSegment	(ES,CX)			ASSUME	ES:OpieIOR			MOV	SI, currentTaskTCBPtr			TEST	[SI].taskState, (jamStateMask OR restartStateMask)			JZ	CheckForPreNotify			JMP	ConvertWaitToJamOrRestartCheckForPreNotify:	CMP	[BX].TCBLinkPtr, preNotifyFlag			JE	PreNotify			TEST	[BX].TCBLinkPtr, nonNilPtr			JNZ	ConditionAlreadyInUse;Going to go onto CV.			MOV	[BX].TCBLinkPtr, SI			OR	[BX].TCBLinkPtr, nonNilPtr			MOV	[SI].taskCondition, BX			TEST	AX, AX			JZ	StayTheCourse			CALL	InsertInTimerQueueStayTheCourse:		MOV	AL, waitForConditionState			JMP	ShiftInNewStatePreNotify:		MOV	[BX].TCBLinkPtr, NullBypassCondition:	CALL	InsertInSystemQueue			JMP	FromInterruptORSystemStateConditionAlreadyInUse:	TEST	AX, AX			JZ	BypassCondition			JMP	DoWaitForTime			ASSUME	ES:NOTHING;-- System level services: (Macro call is - "WaitForInterrupt (timeoutInterval)"  );-------------------------------------------------------------------------------;--------------  Assume parameter locations upon entry into WaitForInterrupt;--------------  procedure are as follows:;--------------;--------------|		AX = timeout value in seconds (0 if not timed).	|;--------------|								|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|  								|;--------------|  								|;-------------------------------------------------------------------------------		IOPE@WaitForInterrupt:			PUSH	ES;The following two lines of code fix the "carry bit return" bug			MOV	BP, SP			AND	WORD PTR SS:[BP]+stackFlagOffset, NOT MASK i80186CF			%LoadOpieSegment	(ES,CX)			ASSUME	ES:OpieIOR			MOV	SI, currentTaskTCBPtr			TEST	[SI].taskState, (jamStateMask OR restartStateMask)			JNZ	ConvertWaitToJamOrRestart			MOV	BX, [SI].taskICPtr			CMP	BX, Null			JE	ConvertWaitToJamOrRestart			TEST	AX, AX			JZ	StoreInterruptStatus			INC	AX			MOV	ES:[BX].interruptTimerValue, AX			MOV	AL, MASK ICTimedStoreInterruptStatus:	OR	AL, MASK ICTaskWaiting			OR	ES:[BX].interruptStatus, AL			MOV	AL, waitForInterruptState			JMP	ShiftInNewState			ASSUME	ES:NOTHING;-- System level System:  (Macro call is - "WaitForSystem"  );-------------------------------------------------------------------------------;--------------  Assume parameter locations upon entry into System procedure;--------------  are as follows:;--------------;--------------|								|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------IOPE@WaitForSystem:			PUSH	ES			%LoadOpieSegment	(ES,CX)			ASSUME	ES:OpieIOR			MOV	SI, currentTaskTCBPtr			TEST	[SI].taskState, (jamStateMask OR restartStateMask)			JNZ	ConvertWaitToJamOrRestart			CALL	InsertInSystemQueue			JMP	FromInterruptORSystemState			ASSUME	ES:NOTHING;-- System level services: (Macro call is - "WaitForTime (interval)"  );-------------------------------------------------------------------------------;--------------  Assume parameter locations upon entry into WaitForInterrupt;--------------  procedure are as follows:;--------------;--------------|		AX = time interval in milliseconds.		|;--------------|								|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|  								|;--------------|  								|;-------------------------------------------------------------------------------		IOPE@WaitForTime:			PUSH	ES			%LoadOpieSegment	(ES,CX)			ASSUME	ES:OpieIOR			MOV	SI, currentTaskTCBPtr			TEST	[SI].taskState, (jamStateMask OR restartStateMask)			JNZ	ConvertWaitToJamOrRestartDoWaitForTime:		CALL	InsertInTimerQueue			MOV	AL, waitForTimeState			JMP	ShiftInNewState			ASSUME	ES:NOTHING;-------------------------------------------------------------------------------;Support routines for System services;-------------------------------------------------------------------------------ConvertWaitToJamOrRestart:; DS:[SI] contains task; ES points to Opie's IORegion			ASSUME	ES:OpieIOR			MOV	AL, [SI].taskState			TEST	AL, restartStateMask	;if both, do restart --			JNZ	ConvertWaitToRestart	;if neither, do jam (from WaitForInterrupt)			AND	AL, NOT jamStateMask			SHL	AL, Nibble			OR	AL, jammedState			MOV	[SI].taskState, AL			JMP	FromJamOrRestartConvertWaitToRestart:	MOV	CX, [SI].taskQueue.offsetValue			MOV	DX, [SI].taskQueue.segmentValue			MOV	DI, [SI].timerValue			MOV	BX, SS			PUSH	SP			;to ensure stack depth of at least 5 words			CALL	SetTaskToRun			JMP	FromJamOrRestart			ASSUME	ES:NOTHING;-------------------------------------------------------------------------------SetTaskToRun:; DS:[SI] points to task; ES points to Opie's IORegion; CX:DX contain IP:CS for task when next run; BX contains stack segment; DI contains stack offset			ASSUME	ES:OpieIOR			PUSH	DS			MOV	DS, BX			SUB	DI, 10			;where first			MOV	WORD PTR [DI]+0, (nilMapData SHL 8) OR nilMapData ;Store initial map data			MOV	WORD PTR [DI]+2, IOPELocalRAM	;Store initial ES			MOV	WORD PTR [DI]+4, CX		;Store initial IP			MOV	WORD PTR [DI]+6, DX		;store initial CS			MOV	WORD PTR [DI]+8, MASK i80186IF	;store initial flags (interrupts enabled)			POP	DS			MOV	[SI].taskSP, DI		;save offset;			JMP	InsertInSystemQueue	:falls through;-------------------------------------------------------------------------------InsertInSystemQueue:; DS:[SI] points to task; ES points to Opie's IORegion; BX can be trashed			ASSUME	ES:OpieIOR			SHL	[SI].taskState, Nibble	;stamp it with previous			OR	[SI].taskState, waitForSystemState ;and current state.			MOV	[SI].taskQueue.IOPEQueueType, systemQueueType			MOV	[SI].taskQueue.nextHandlerID, nilHandlerID			MOV	AH, [SI].taskHandlerID			MOV	AL, systemQueue.handlerIDforTail			MOV	DI, systemQueue.linkPtrforTail			MOV	systemQueue.handlerIDforTail, AH			MOV	systemQueue.linkPtrforTail, SI			CMP	AL, nilHandlerID			JNE	LinkTheSystemQueueTCBs			MOV	systemQueue.handlerIDforHead, AH			MOV	systemQueue.linkPtrforHead, SI			RETLinkTheSystemQueueTCBs:	PUSH	DS			PUSH	AX			CBW			%LoadHandlerSegment	(DS,BX)			POP	AX			MOV	[DI].taskQueue.nextHandlerID, AH			MOV	[DI].taskQueue.nextTCBLinkPtr, SI			POP	DS			RET			ASSUME	ES:NOTHING;-------------------------------------------------------------------------------RemoveQueueEntry:; DS:[SI] points to task; ES points to Opie's IORegion; AX, DI can be trashed			ASSUME	ES:OpieIOR			CMP	[SI].taskQueue.IOPEQueueType, timerQueueType			JE	RemoveTimerQueueEntry			CMP	[SI].taskQueue.IOPEQueueType, systemQueueType			JE	RemoveSystemQueueEntry			RETRemoveTimerQueueEntry:	MOV	DI, OFFSET timerQueue			JMP	SHORT RemoveFromQueueRemoveSystemQueueEntry:	MOV	DI, OFFSET systemQueueRemoveFromQueue:; DS:[SI] points to task; ES:[DI] points to IOPEQueue (within Opie's IORegion); AX can be trashed			ASSUME	ES:OpieIOR			PUSH	CX			MOV	CL, [SI].taskHandlerID			CMP	ES:[DI].linkPtrforHead, SI			JNE	SetUpForQueueSearch			CMP	ES:[DI].handlerIDforHead, CL			JNE	SetUpForQueueSearch			CMP	[SI].taskQueue.IOPEQueueType, timerQueueType			JNE	RemoveFromHead			STC			CALL	FixUpTimerQueueRemoveFromHead:		MOV	AX, [SI].taskQueue.nextTCBLinkPtr			MOV	ES:[DI].linkPtrforHead, AX			MOV	AL, [SI].taskQueue.nextHandlerID			MOV	ES:[DI].handlerIDforHead, AL			CMP	AL, nilHandlerID			JNE	RemoveFromQPopCX			MOV	ES:[DI].handlerIDforTail, AL			JMP	SHORT RemoveFromQPopCXSetUpForQueueSearch:	PUSH	BX			PUSH	DI			PUSH	ES			PUSH	DS			LDS	BX, SegmentTableAddress			MOV	AL, ES:[DI].handlerIDforHead			MOV	DI, ES:[DI].linkPtrforHead			ASSUME	ES:NOTHINGFindEntryInQueue:	CMP	AL, nilHandlerID			JE	EndOfQueue			CBW			SHL	AX, 2			ADD	AX, BX			XCHG	AX, BX			MOV	ES, [BX].ioRegionSegment			MOV	BX, AX			CMP	ES:[DI].nextTCBLinkPtr, SI			JNE	GetNextEntryInQueue			CMP	ES:[DI].nextHandlerID, CL			JE	FoundEntryInQueueGetNextEntryInQueue:	MOV	AL, ES:[DI].nextHandlerID			MOV	DI, ES:[DI].nextTCBLinkPtr			JMP	FindEntryInQueueEndOfQueue:		POP	DS			POP	ESRemoveFromQPopDI:	POP	DI			JMP	SHORT RemoveFromQPopBXFoundEntryInQueue:	POP	DS			CMP	[SI].taskQueue.IOPEQueueType, timerQueueType			JNE	RemoveFromPrevEntry			CALL	FixUpTimerQueueRemoveFromPrevEntry:	MOV	AX, [SI].nextTCBLinkPtr			MOV	ES:[DI].nextTCBLinkPtr, AX			MOV	AL, [SI].nextHandlerID			MOV	ES:[DI].nextHandlerID, AL			MOV	CL, ES:[DI].taskHandlerID			POP	ES			ASSUME	ES:OpieIOR			CMP	AL, nilHandlerID			JNE	RemoveFromQPopDI			MOV	BX, DI			POP	DI			MOV	ES:[DI].handlerIDforTail, CL			MOV	ES:[DI].linkPtrforTail, BXRemoveFromQPopBX:	POP	BXRemoveFromQPopCX:	POP	CXRemoveFromQCompleted:	MOV	[SI].taskQueue.IOPEQueueType, Null			RET			ASSUME	ES:NOTHING;-------------------------------------------------------------------------------SystemLoop:; ES points to Opie's IORegion; SS:[SP] is at SystemStack			ASSUME	ES:OpieIOR			CLI				;Must turn off interrupts to dequeue task			CMP	systemQueue.handlerIDforHead, nilHandlerID	;Test for empty queue.			JE	SystemIdle		;If so, idle the system.			MOV	AL, systemQueue.handlerIDforHead			CBW			MOV	SI, systemQueue.linkPtrforHead			LDS	BX, SegmentTableAddress			SHL	AX, 2			ADD	BX, AX			MOV	DX, [BX].stackSegment			MOV	DS, [BX].ioRegionSegment			MOV	AX, [SI].taskQueue.nextTCBLinkPtr			MOV	systemQueue.linkPtrforHead, AX			MOV	AL, [SI].taskQueue.nextHandlerID			MOV	systemQueue.handlerIDforHead, AL			CMP	AL, nilHandlerID			JNE	PrepareToRunTaskAtSystemLevel			MOV	systemQueue.handlerIDforTail, ALPrepareToRunTaskAtSystemLevel:			MOV	currentTaskTCBPtr, SI	; make this the new current task.			MOV	SS, DX			MOV	SP, [SI].taskSP;Change state, leaving the last interesting task state in the high nibble.			XOR	[SI].taskState, (waitForSystemState XOR systemState)			MOV	[SI].taskQueue.IOPEQueueType, Null			POP	AX			MOV	generalMapRegisterImage, AX			MOV	DX, generalMapRegister			CALL	WriteMapRunTaskAtSystemLevel:					;Label for easy debugging.			POP	ES			ASSUME	ES:NOTHING			IRET				;Start running the task.			ASSUME	ES:OpieIORSystemIdle:		STI				;Let interrupt events happen			MOV	currentTaskTCBPtr, NullTCBPtr	;clear current TCBPtrSurrenderBus:		MOV	AL, 0			;clear AX for the runPCE CMP...			%CallPCEStartRoutine		;Call PC Emulation if it is there.;PCEStartRoutine puts runPCE into AL.  If runPCE is 0FFH then there are PC;commands to run, and the PCE should be allowed.  Else, do not allowPC.			CMP	AL, 0FFH			JNE	DoNotSetAllowPCE			IN	AX, (ArbCmdBase OR AllowRDCmdOffset OR AllowPCCmdOffset)			NOP				;Just for fun			JMP	SystemLoopDoNotSetAllowPCE:	IN	AX, (ArbCmdBase OR AllowRDCmdOffset)			NOP				; Just for fun			JMP	SystemLoop			ASSUME	ES:NOTHING;--------------------------------------------------------------------------------ShiftInNewState:; DS:[SI] contains task; ES points to Opie's IORegion; AL contains new state			SHL	[SI].taskState, Nibble			OR	[SI].taskState, ALFromInterruptORSystemState:; DS:[SI] contains task; ES points to Opie's IORegion			ASSUME	ES:OpieIOR			MOV	BP, SP			MOV	WORD PTR [BP]+stackFlagOffset, MASK i80186IF			PUSH	generalMapRegisterImage			MOV	[SI].taskSP, SPFromJamOrRestart:	TEST	[SI].taskState, (interruptStateMask SHL Nibble)			JNZ	FromInterruptStateFromSystemState:	LDS	BX, SegmentTableAddress			MOV	SI, SystemHandlerID			SHL	SI, 2			MOV	SS, [BX + SI].stackSegment			MOV	SP, OFFSET SystemStack			JMP	SystemLoopFromInterruptState:	MOV	SS, [SI].returnSPSS.segmentValue			MOV	SP, [SI].returnSPSS.offsetValue			MOV	DI, [SI].taskICPtr			MOV	AX, ES			MOV	DS, AX			ASSUME	DS:OpieIOR			AND	[DI].interruptStatus, NOT MASK ICActive			POP	AX			MOV	generalMapRegisterImage, AX			MOV	DX, generalMapRegister			CALL	WriteMap			POP	currentTaskTCBPtr;			JMP	ClearAndDismissInterrupt;Here after calling trouble routine for unexpected interrupts;Interrupts are not allowed while EOI's are being figured out.;The interrupt can be identified as from a slave device if it has a;  non-zero mySlaveEOIport field in it's ICB.;Note that the 8259 master and the 186 and the 8274 get a nonspecific EOI;  but the 8259 slave gets a specific EOI (?? /kek).ClearAndDismissInterrupt:			ASSUME	DS:OpieIOR, ES:NOTHING			MOV	BX, [DI].interruptController			MOV	DX, [BX].interruptSlaveEOIPort			CMP	DX, Null		;was it from a slave device?			JE	EOItoMaster		;No: issue masterEOI only and exit.			CMP	DX, subInterruptPort	;Was it a software subirp?			JE	ExitEOI			;Yes: there are no h/w EOI's to issue.			MOV	AL, [DI].interruptSlaveEOIcmd	;It's a slave (186/8259Slv/8274) irp:       			OUT	DX, AL			; issue an EOI to the slaveEOIPort.;Now have to see if any other interrupts were in progress on this slave interrupt controller.;On the 8259 and the 186 chips, another slave interrupt of this type is seen pending in; the IRR if the bit corresponding to interruptMask is set.;On the 8274 chip, all of the slave interrupts pending are or'ed into a single irp-pending bit in RR0 --; there is no IRR mask for this chip!  Thus all interrupts have the same interruptMask.;So, the appropriate bit is checked to see if the slave has another interrupt of this same type pending.; If none, go ahead and send an EOI to the master.; If something, must *skip* EOI to master, to prevent lower priority interrupts on the master.			MOV	AH, [DI].interruptMask;Get irp pending mask			MOV	DX, [BX].interruptPendingPort ;Get irp-pendingport			IN	AL, DX			;Get current IRR from slave			TEST	AL, AH			;Is this slave pending again?			JNZ	ExitEOI			;Yes: exit w/o issuing MasterEOIEOItoMaster:		MOV	AX, i8259EOINonSpecific		;Always same for master.			OUT	Masteri8259EOIport, AX;Here is where an interrupted task's context is restored, now that all necessary EOIs have been sent.ExitEOI:		POP	ES			;restore			POP	DS			; all			ASSUME	DS:NOTHING		;  registers			POPA				;   and			IRET				;    return;-------------------------------------------------------------------------------IOPEInROM		ENDS;********************************************************************************			END
$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;-- stored as [Iris]<WMicro>Dove>IOPLMap.asm;-- created on  26-Sep-84 13:16:15;-- last edited by:;--	KEK	26-Sep-86 13:55:42	:another bug in AS conversion (off-by-one);--	KEK	24-Jun-86 14:09:17	:bug in ASInterface code -- page addr instead of word addr...;--	KEK	 5-Jun-86 18:51:40	:add stack stuff to WriteMap to fix overflowing.;--	KEK	17-Apr-86 11:51:44	:Add Daisy WriteMap impl, and Daisy VMMap interface;--	JPM	22-Jul-85 10:12:46	:Change IOPEInROM alignment to WORD;--	JPM	24-Jun-85 12:58:40	:Removed code for general map reg test (will handle like other regs);--	JPM	21-Jun-85 17:37:02	:Reworked for efficiency;--	JPM	20-May-85 14:49:45	:Use macros LoadHandlerSegment, LoadOpieSegment, and CallIRETproc;--	JPM	16-May-85 16:45:24	:Opie redesign;--	KEK	25-Apr-85 17:10:55	:fix off-by-one error in ConvertFormatToByte;--	KEK	 3-Mar-85 15:05:45	:changed printing directives.;--	VXS 	 3-Dec-84 17:53:59	:Fixed bug introduced by revised idea of Daybreak map reg format, didn't right justify map reg number at MOV DI, AX before IOPMapDirect.;--	VXS 	27-Nov-84 17:11:33	:Ignore hi 8 bits of IORegion and EnvBase relative addresses.;--	VXS 	20-Nov-84 17:48:37	:add INCLUDEs of OpieDefs and HardDefs, change type of IOPEFCB to be IOPEFunctionContextBlock;--	VXS 	16-Nov-84 11:47:55	:Fix MapExtendedBusAddress to account for Daybreak using bits 1-5 instead of 0-4.;--	VXS 	15-Nov-84 11:04:41	:Don't smash AX in ConvertAddress;--	VXS 	 5-Nov-84 16:12:07	:Finish establishaccess implementation by interpreting mapped;					: extended bus addresses for IOP and PC.;--	VXS 	11-Oct-84 11:36:39	:change so that convertaddress uses an IORegion pointer to find page map.;--	VXS 	 1-Oct-84 18:38:02	:Put IRET in front to make ConvertAddress a no-op for the version 14 release;--	VXS 	26-Sep-84 13:16:19	:CreationNAME			IOPLMap;--------------------------------------------------------------------------------$NOLIST$INCLUDE		(IOPDefs.asm)$INCLUDE		(OpieDefs.asm)$INCLUDE		(HardDefs.asm)$LIST;--------------------------------------------------------------------------------IOPELocalRam		SEGMENT	AT 0;EXTRNs from IOPELocalRam segmentEXTRN			aChipCount: BYTEEXTRN			machineCritter: BYTEEXTRN			IORSegmentTableAddress: SegmentAndOffsetEXTRN			IOROpieSegmentAddress: WORDIOPELocalRam		ENDS;--------------------------------------------------------------------------------OpieIOR			SEGMENT	COMMONEXTRN			mesaPageMapOffset: WORD, mesaPageMapSegment: WORDEXTRN			currentTaskTCBPtr: WORDEXTRN			mapRegisterImages: BYTEOpieIOR			ENDS;--------------------------------------------------------------------------------OpieSTK			SEGMENT	COMMON;EXTRNs from Opie's Stack Segment:EXTRN			WriteMapStack: WORDOpieSTK			ENDS;--------------------------------------------------------------------------------IOPEInROM		SEGMENT	WORD PUBLIC			ASSUME	CS:IOPEInROM;The following defintions are NOT public information, and are defined here solely; as an implementation convenience;  (They must, however, agree with the public definitions in IOPDefs)OALogicalAddressBits	EQU	11000000B	;Logical Address Space SelectorOAExtendedBus		EQU	00000000B	  ;Extended BusOAIOPLogical		EQU	01000000B	  ;IOP logicalOAPCLogical		EQU	10000000B	  ;PC processor logicalOAmesaLogical		EQU	11000000B	  ;Mesa processor logical  OAFormatBits		EQU	00110000B	;The format bitsOANilFormat		EQU	00000000B	  ;Nil is a formatOAByteFormat		EQU	00010000B	  ;Byte addressOAWordFormat		EQU	00100000B	  ;Word addressOAPageFormat		EQU	00110000B	  ;Page addressOABaseSpecBits		EQU	00001111B	;Address space relative base definitionsOANoBase		EQU	00000000B	  ;start of logical address space (no base);For IOP:OAIORegionBase		EQU	00000001B	  ;handler's IORegion relative;For Mesa:OAmesaEnvBase		EQU	00000001B	  ;Mesa's Environment relative  %SET(mesaEnvBaseRelocationPage,0)		;This is the start of the Mesa Environment Base,    						; otherwise known as "first64K"					 ;Assumptions (for this implementation):;OANoBase must be defined to be 0;OANilFormat must be defined to be 0;OAExtendedBus must be defined to be 0;Definition of the bits in CL that are used in Extended Bus Addresses for real memoryvalidIOPHighBits	EQU	00001111B		;20-bit addressing allowedvalidPCHighBits		EQU	00001111B		;20-bit addressing allowedvalidExtBusHighBits	EQU	00111111B		;22-bit addressing allowedmapRegExtendedBusMask	EQU	00111110BmapRegRightJustify	EQU	1	;the following used after right justifying mapRegExtendedBusMaskmapRegSelectMask	EQU	00001111BmapRegUnusedMask	EQU	11000000B;[End of private definitions];--------------------------------------------------------------------;Format of the Mesa Page map, as seen by IOP with word accesses.MesaVirtualMapBits	EQU	1110000000000000B	;MaskMesaVirtualMapVacant	EQU	0110000000000000B	;value for vacantMesaVirtualMapAddress	EQU	0001111111111111B	;Address;--------------------------------------------------------------------;Public declarations.PUBLIC	IOPE@ConvertAddressPUBLIC	IOPE@EstablishIOPAccessPUBLIC	WriteMap;--------------------------------------------------------------------;-- System level services: (Macro call is - "ConvertAddress"  );-------------------------------------------------------------------------------;--------------|  Assumes:							|;--------------|		CX,DX = an OpieAddress.				|;--------------|								|;--------------| Upon exiting:							|;--------------|		CX,DX = an Opie Extended Bus Address.		|;--------------|		AX    = preserved				|;-------------------------------------------------------------------------------;Here with CH/Opie address type,;	CL/High 8 bits of Opie Address (if applicable);	DX/Low 16 bits of Opie Address;Order of conversion:;	1) Check for special case (extendedBusOpieAddress) -- skip;	2) If relocated, clear high 8 bits (saving contents for IOPLogical step 4);	3) If not byte format, convert (from word or page);	for IOPLogical type:;		4) If relocated, add relocation base;		5) Convert to extendedBus type by changing high nibble;	for PCLogical type:;		4) Convert to extendedBus type by changing high nibble;	for mesaLogical type:;		4) Get logical page number;		5) If relocated, add relocation page;		6) Look up extendedBus page in VM table;		7) Convert to extendedBus type by combining page and byte offset  	IOPE@ConvertAddress:	CMP	CH, extendedBusOpieAddress						;see if it's extended Bus already			JNE	SaveConvertRegisters			IRET	;return if so.SaveConvertRegisters:	PUSH	AX		;save this so don't smash anything.			PUSH	BX		;save this too.			MOV	BX, CX		;transfer high address to BX,			MOV	CH, 0		; then change CX into number			TEST	BH, OABaseSpecBits			JZ	ConvertFormatToByte			MOV	CL, 0ConvertFormatToByte:	MOV	AL, BH			AND	AL, OAFormatBits			JZ	BadAddressReturnNil			CMP	AL, OAByteFormat			JE	IsByteFormat			CMP	AL, OAWordFormat			JE	IsWordFormatIsPageFormat:		MOV	CL, DH	;logical SHL 8 (will need 9 total)			MOV	DH, DL			MOV	DL, 0IsWordFormat:		SHL	DX, 1	;shift left one, high bit to carry			RCL	CX, 1	;shift over, put old DX high bit into low bit.IsByteFormat:		MOV	AL, BH		;get type bits			AND	AL, OALogicalAddressBits						;Get just the logical address field.			JZ	CheckExtendedBusOverflow			CheckIOPLogical:	CMP	AL, OAIOPLogical			JNE	CheckPCLogical			TEST	BH, OABaseSpecBits			JZ	IOPLogicalAddressOK			MOV	AL, BL			MOV	AH, 0			PUSH	DS			%LoadHandlerSegment	(DS,BX)			MOV	AX, DS			POP	DS			ROL	AX, 4			MOV	BX, AX			AND	BX, 000FH			AND	AX, 0FFF0H			ADD	DX, AX			ADC	CX, BXIOPLogicalAddressOK:	CMP	CX, validIOPHighBits						;has conversion overflowed?			JG	BadAddressReturnNil			OR	CL, 0F0H	;IOP uses F as high order selector			JMP	SHORT ConvertDoneCheckPCLogical:		CMP	AL, OAPCLogical			JNE	MustBeMesaLogical			CMP	CX, validPCHighBits						;has conversion overflowed?			JG	BadAddressReturnNil			OR	CL, 0E0H	;PC uses E as high order selector			JMP	SHORT ConvertDoneCheckExtendedBusOverflow:			CMP	CX, validExtBusHighBits						;has conversion overflowed?			JNG	ConvertDoneBadAddressReturnNil:			XOR	CX, CX			XOR	DX, DX			JMP	SHORT RestoreConvertRegsMustBeMesaLogical:	PUSH	DS		;save DS			%LoadOpieSegment	(DS,AX)			ASSUME	DS:OpieIOR			MOV	AL, DH			AND	AL, 0FEH			MOV	AH, CL%IF(%mesaEnvBaseRelocationPage NE 0) THEN (			TEST	BH, OABaseSpecBits			JZ	GetMesaPageMapEntry			ADD	AX, (%mesaEnvBaseRelocationPage SHL 1)			ADC	CH, (%mesaEnvBaseRelocationPage SHR 15)GetMesaPageMapEntry:	)FI			MOV	BX, mesaPageMapOffset	;stored by IOPInit			ADD	BX, AX		;assume no overflow			MOV	AX, mesaPageMapSegment	;stored by IOPInit			CMP	AX, Null			JE	BadAddressReturnNil	;no Mesa yet			OR	CH, CH				JZ	MesaPageMapNoCarry			ADD	AH, HIGH 1000H	;add into segment part if byte address overflows 64KMesaPageMapNoCarry:	MOV	DS, AX			ASSUME	DS: NOTHING			MOV	BX, [BX]	;get Mesa page map entry.			MOV	AH, BH		;get copy			AND	AH, HIGH MesaVirtualMapBits						;get just the status bits			CMP	AH, HIGH MesaVirtualMapVacant							;See if its illegal			JE	BadAddressReturnNil			AND	BH, HIGH MesaVirtualMapAddress			SHL	BX, 1			MOV	AX, IOPELocalRam			MOV	DS, AX			ASSUME	DS:IOPELocalRam			CMP	DS:aChipCount, 1 ;(0=>Daybreak)			JBE	DaisyMesaPageMapDone			;multiple Achips => fuss w/ AS interface:DaisyMesaPageMap:	;add 1Mb if real addr in first meg.TestFirstMeg:		CMP	BX, (07FFH SHL 1) ;1Meg in pages			JA	TestSecondMeg			ADD	BX, (0800H SHL 1)			JMP	DaisyMesaPageMapDone			;sub 1Mb if real addr in second meg.TestSecondMeg:		CMP	BX, (01000H SHL 1) ;2Meg in pages			JAE	DaisyMesaPageMapDone			SUB	BX, (0800H SHL 1)DaisyMesaPageMapDone:	POP	DS			ASSUME	DS:NOTHING			MOV	CL, BH		;high order part of page address goes into CL			AND	DH, 1			OR	DH, BL		;low order part goes into DHConvertDone:		MOV	CH, extendedBusOpieAddress						;The new typeRestoreConvertRegs:	POP	BX		;restore values of BX			POP	AX		;and AX.ConvertReturn:			IRET			;return. New type in CX-DX.;------------------------------------------------;-- System level services: (Macro call is - "EstablishAccess"  );-------------------------------------------------------------------------------;--------------|  Assumes:							|;--------------|		CX,DX = an OpieAddress.				|;--------------|		AX    = an IOPMap number (0 thru 7).		|;--------------|--------							|;--------------| Upon exiting:							|;--------------|		CX,DX = an OpieRealAddress.			|;--------------|		ES    = points to a segment beginning at the	|;--------------|			16B containing the specified address	|;--------------|		DI    = byte offset of address within that 16B	|;-------------------------------------------------------------------------------;Routine IOPE@EstablishAccess;Function: Make the Opie address in CX-DX accessible through map slot whose number; is in AL.; Sets up ES:DI to point to requested location, so that DI has the minimum value possible;  for maximum addressability.;The map slots on both types of machines map 128Kbyte sections of IOPlogical or PClogical; address space. This corresponds to 17 bits out of a possible 22 for extended bus addresses.; Therefore, must extract the high order 5 bits from the EBA, and replace them with 3 bits; of the map number.;We want this to be as fast as possible, at the expense of code space if necessary, because interrupt level; for the internal DMA must call this to remap a new section for continued I/O in some cases.IOPE@EstablishIOPAccess:			PUSH	BX			MOV	BX, AX			CMP	CH, extendedBusOpieAddress						;see if its extended Bus already						; (extra code to make this faster, since						; interrupt level calls this)			JE	EstAccEBA	;Jump if already extended bus address			%CallIRETproc	(IOPE@ConvertAddress)			CMP	CH, nilOpieAddress			JNE	EstAccEBA			MOV	AL, nilMapData	;In case it's general map register			JMP	SHORT NotEorFEstAccEBA:					;Must start off with extended bus			%LoadOpieSegment	(ES,AX);Get the high order 5 bits of the 22 bit EBA into AL into 0-4 for Daybreak hardware.; Either these will go into the map register, or if the address has E or F in the high nibble,; specify the map register to read to get the high order 5 bits.			MOV	AL, CL		;save high part of address			AND	AL, mapRegExtendedBusMask			SHR	AL, mapRegRightJustify			TEST	CL, mapRegUnusedMask						;See if he's specifying E or F (treat C and D cases as same)			JZ	NotEorF		;go if normal extended bus address;Caller has specified a mapped Extended Bus Address.; Must replace bits 23-17 (high order 7 bits) with the five bits (21-17) from the map; register selected (map number is taken directly from 20-17)			MOV	DI, AX		;get into indexing place			AND	DI, mapRegSelectMask						;get just the relevant data; If its IOP map register 0 or 7, in which case we don't program map registers, but; instead return ES:DI pointing to actual IOP logical address within map register 0 or 7,; because these are the only areas where the IOP can select local RAM or EPROM.			CMP	DI, daybreakMapRegisterNumberIOPBase+0			JNE	NotIOPMapReg0IOPMapDirect:		MOV	BX, DI		;get reg number in BX			JMP	SHORT MapDirect	;Go setup ES:DI and return.			NotIOPMapReg0:		CMP	DI, daybreakMapRegisterNumberIOPBase+7			JE	IOPMapDirect			MOV	AL, ES:mapRegisterImages[DI]	;get 5 bits of map reg contents			NotEorF:;Compute the I/O address of the map slot being requested (in AX); And program the map			XCHG	BX, DX		;Get copy of low order 16 bits for later use			CALL	WriteMap			XCHG	DX, BX		;get low bits back into DX, IO Address into BX			MOV	ES:mapRegisterImages[BX], AL						;save for benefit of users of mapped Extended Bus addresses.;Setup ES:[DI] to point to the requested location; If entering at MapDirect, CL,DX must contain the low order 17 bits,; and AH contains the high order 3 bits (map register number) of the 20 bit address.; (the 04H bit in AH, which is 0 or 1 for PC or IOP, will be ignored);Build value which goes into ES in DX.MapDirect:			MOV	DI, DX		;get low bits into DI			AND	DI, (1 SHL Nibble)-1	;just low order 4 bits for maximum forward addressability			AND	DL, 0F0H			OR	BX, DX			OR	DX, DI			TEST	CL, (NOT mapRegExtendedBusMask) AND (NOT mapRegUnusedMask)						;(faster than shifting by far)			JZ	MEBAFirst64K	;jump if			STC			;switch to next 64KMEBAFirst64K:			RCR	BX, Nibble	;get reg in hi 3 bits of BX, and 4th bit into carry (hide it)			MOV	ES, BX		;goes into ES			POP	BX			IRET			;return with good values in ES and DI.			;-------------------------------------------------------------------------------------;-- Kernel level services: (proc call is - "WriteMap"  );-------------------------------------------------------------------------------;--------------|  Assumes:							|;--------------|		DX = a map register number IN [0..16).		|;--------------|		AL = data to write to that map register.	|;--------------|--------							|;--------------| Upon exiting:							|;--------------|								|;--------------|		mapReg DX will contain data AL.			|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;Routine WriteMap;Function: program the specified map register with the specified data.  For; Daybreak, this will be five-bit data to one of 16 registers.  For Daisy, this will be a 2-bit A-chip number and three-bit data and one of eight registers.;We want this to be as fast as possible, at the expense of code space; if necessary, because interrupt level for the internal DMA must call; this to remap a new section for continued I/O in some cases.;Algorithm: (let DX provide mapReg and AL provide mapRegData.);	If DAYBREAK then;	  BEGIN;	  baseAddress ¬ daybreakMapIOAddressBase + mapReg.;	  output mapRegData to baseAddress.;	  END;	If DAISY then;	  BEGIN;	  -- call the bits in mapRegData bits (msb)X-X-X-4-3-2-1-0(lsb).;	  thisChip ¬ bits 4 and 3 of mapRegData;;	  dataMask ¬ bits 2, 1, and 0 of mapRegData OR 08H (enable bit);;	  IF (mapReg < 8) THEN SHL dataMask by 4;;	  -- compute baseAddress and nybMask.;	  nybMask = IF (mapReg < 8) THEN 0FH ELSE 0F0H;;	  baseAddress = (mapReg MOD 8) + daisyMapIOAddressBase;;	  -- clear the enable bit in every A-chip, set thisChip's enable bit:;	  FOR chipNumber IN [0,1,2,3] DO;	    read data in from baseAddress+(0100H*chipNumber);;	    data ¬ data AND nybMask;;	    IF chipNumber=thisChip THEN;	      {data ¬ data OR dataMask};;	    output data to baseAddress+(0100H*chipNumber);;	    ENDLOOP;;	  END;;there is code at the beginning of this proc (and the end) that was added to; correct a stack overflow bug.  The stack overflow bug was caused by the; PUSH/POP's done in this proc.  The bug fix not chosen -- to just increase; the minimum stack size and rebuild all the handler stacks -- would have; overflowed the local RAM in which the stacks live.  This bug fix chosen -- to; switch to a specially created Opie-WriteMap stack within the proc -- has no; impact at all on handler stacks.  Stack operations are avoided until after; the WriteMap stack is in commision.;define a memory location so can directly load SS:OpieSTKPointer		DW	OpieSTKWriteMap	PROC			;start the WriteMap function finally			;CMP	machineCritter, Daisy			;JNZ	DaybreakWriteMap			;generate a scratch reg to stash dest-SSDaisyWriteMap:		MOV	AH, DL			;save DL			MOV	DX, SS			;temply save SS			;get the Opie stack segment into commision			MOV	SS, CS:OpieSTKPointer			;save away dest-SS:SP in bottom of WriteMapStack			MOV	SS:WriteMapStack, DX	;*really save SS*			MOV	SS:WriteMapStack-2, SP	;*save SP*			;restore scratch reg			MOV	DL, AH			XOR	DH, DH			XOR	AH, AH			;get the Opie stack pointer into commision			MOV	SP, OFFSET WriteMapStack-2						PUSHA			;thisChip BX  ¬ bits 4,3 of mapRegData			;thisChip ¬ thisChip plus 8, to match DH's of [8,9,A,B].			MOV	BX, AX			SHR	BX, 0003H			AND	BX, 0003H			ADD	BX, 8			;dataMask BP ¬ bits 2,1,0 of mapRegData OR 08H (enable)			;IF (mapReg < 8) THEN SHL dataMask by 4			;nybMask DI ¬ IF (mapReg<8) THEN 0FH ELSE 0F0H			MOV	BP, AX			AND	BP, 0007H			OR	BP, 0008H			MOV	DI, 00F0H			CMP	DX, 8			JAE	IsDaisyIOP	IsDaisyPC:	SHL	BP, 4			MOV	DI, 000Fh	IsDaisyIOP:	;baseAddr DX ¬ (mapReg MOD 8)+daisyMapIOAddressBase			AND	DX, 0007H			ADD	DX, daisyMapIOAddressBase			;BEGIN FOR chipAddr IN [8,9,A,B] DO read/modify/write.	NextChip:	IN	AL, DX	;  IN from baseAddr+(0100H*chipNumber)			AND	AX, DI	;  data ¬ data AND nybMask			CMP	DH, BL	;  IF chipNumber=thisChip THEN			JNE	OutToChip			OR	AX, BP	;	    {data ¬ data OR dataMask};	OutToChip:	OUT	DX, AL	;  OUT baseAddr+(0100H*chipNumber), data;			INC	DH	;END nextChip			CMP	DH, 0BH			JBE	NextChip			POPA						;restore dest-SS:SP			MOV	SP, SS:WriteMapStack-2			MOV	SS, SS:WriteMapStack			;JMP	WriteMapDone			DaybreakWriteMap:	;ADD	DX, daybreakMapIOAddressBase			;OUT	DX, AL			;SUB	DX, daybreakMapIOAddressBase;restore!			WriteMapDone:		RETWriteMap		ENDPIOPEInROM		ENDS			;********************************************************************************									END
$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);--------------------------------------------------------------------------------;; This code implements the display handler.;;Copyright (C) 1984, 1985, 1986, 1987 by Xerox Corporation. All rights reserved.;-- stored as [Idun]<WDLion>Dove>DsplHdlr.asm;-- created on  27-Feb-84 11:15:44;-- This version uses Opie 21;;-- last edited by:;--	KXT	24-Feb-87 16:48:29	;Fixed bug in Display Alignment Adjusting.;--	KXT	10-Dec-86 14:28:36	;Fixed bug about Cursor position.;--	KXT	30-Oct-86 10:40:19	;Fixed bug in Display Alignment Adjusting. ;-- 	MXT	28-Aug-86 11:37:57	;Changed DaisyCursorPattern proc to invert cursor.;-- 	MXT	23-May-86 11:28:15	;Fixed bug in DaisyCursorPattern PROC(bad caliculation of Cursor height).;-- 	MXT	30-Apr-86 21:36:48	;Added labels;--	MXT	22-Apr-86 15:36:19	:Commented out DayBreak stuffs.;--	MXT	 7-Apr-86 11:14:25	:Changed to support both Daisy and DayBreak.;--	JGS	13-Sep-85 14:18:47	:15/19 inch bit inverted (CRTSize).;--	JPM	12-Sep-85  7:58:41	:Change defaults for border & mix rule.;--	JPM	 9-Sep-85  9:41:54	:Fix bug in bad-interrupt proc (forgot to POP DS).;--	JPM	28-Aug-85 16:33:54	:Change bad-interrupt proc to get handler access, made Daybreak/Daisy procs NEAR.NAME			Display			;Changed name to Display;--------------------------------------------------------------------------------$NOLIST$INCLUDE	(IOPDefs.asm)	;This should always be INCLUDEd first$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(ROMEEP.asm)$LIST; INCLUDED IOPDefs.asm, HardDefs.asm, IOPMacro.asm, and ROMEEP.asm;--------------------------------------------------------------------------------;;Include files needed for display handler$INCLUDE   (DsplDefs.asm);;----------------------------------------------------------------------------------EXTRN displayInterrupt :ABSEXTRN DisplayHandlerID :ABS;;DisplayIOR		SEGMENT		COMMON ;EXTRNs for display handlerEXTRN displayTask :TaskContextBlock;;EXTRNs contained in display handler FCBEXTRN  displayLock :WORD	;¬ %GetLockMaskEXTRN  chngdInfo :WORD		;¬ cursorPatternChngdEXTRN  vertRetraceEvent :BYTEEXTRN  cursorXCoord :WORD	;¬ 0EXTRN  cursorYCoord :WORD	;¬ 0EXTRN  borderLow :BYTE		;¬ 0EXTRN  borderHigh :BYTE		;¬ 0EXTRN  cursorPattern :BYTE	;¬ ALL[0] (32 bytes)EXTRN  displCntl :BYTE		;¬ 0E4HEXTRN  mixRule :BYTE		;¬ 0EHEXTRN  numberBitsPerLine :WORD	;¬ 832/1152EXTRN  numberDisplayLines :WORD	;¬ 633/861EXTRN  configInfo :BYTE		;¬ 0EXTRN  colorParams: WORD	;¬ 0EXTRN  xCoordOffset :WORD	;¬ 208/304EXTRN  yCoordOffset :WORD	;¬ 32EXTRN  pixels :BYTE		;¬ 80EXTRN  refresh :BYTE		;¬ 38;EXTRN  bitMapOrg :WORDEXTRN  numberQuadWords :WORD	;¬ 13/18;EXTRN  displayIntrCnts :WORD  ;¬ 0  !!!! Added for debug !!!!!EXTRN  displayWdtCnts  :BYTE  ;¬ 0  !!!! Added for debug !!!!!;EXTRN  CursorUser :BYTE;EXTRN  HBorder0Base :WORD	;HBorder0 base value.  used by adjusting display alignment.EXTRN  VBorder0Base :WORD	;VBorder0 base value.  used by adjusting display alignment.;;Variables containing addresses of Daisy/Daybreak proceduresEXTRN  displayHWInitProc :WORDEXTRN  cursorPositionProc :WORDEXTRN  cursorPatternProc :WORDEXTRN  borderPatternProc :WORDEXTRN  backgndProc :WORDEXTRN  commandProc :WORD;DisplayIOR		 ENDS;;-----------------------------------------------------------------------------------------;			DisplaySTK		SEGMENT		COMMON 			Assume SS:DisplaySTKEXTRN  DisplayStack :WORDDisplaySTK		 ENDS;;-----------------------------------------------------------------------------------------IOPEInROM		SEGMENT	WORD PUBLIC			Assume	CS:IOPEInROM;;;-----------------------------------------------------------------------------------------;;ROM-based task entry points:; PUBLIC		DisplayInit;;-----------------------------------------------------------------------------------------;;All the entry points below have to be in ROM so there is no need;to save the CS!;;******************************************************************************************;*******************************;*                             *;*        DisplayInit          *;*                             *;*******************************;DisplayInit	PROC	FAR		%InitializeTask		(DisplayHandlerID,OFFSET displayTask, DisplayTaskInit,OFFSET DisplayStack)			RETDisplayInit	ENDP;;*******************************************************************************************;***********************************;*                                 *;*        DisplayTaskInit          *;*                                 *;***********************************;;Task initialization is the same for all clients(Boot, Boot diagnostics, Pre-boot, and the Mesa head.);DisplayTaskInit:		ASSUME	DS:DisplayIOR	EXTRN		DisplayInitialize: NEAR		;DisplayInitialize is a PUBLIC routine						;to initialize the display controller 						;and is provided by Opie.		%ThisTaskServices (displayInterrupt,badDisplayIntr);;INITIALIZE DATA STRUCTURES;Initialize the display Function Context Block;;Initialize the head/handler synchronization first;		%GetLockMask			;GetLockMask returns the lock in AXLockInit:	MOV	displayLock, AX		;Initialize lock mask returned in macro;;At first, determine the hardware type. ;If hardware is Daisy, the initialization of Display controller has been done in Booting code.;If hardware is DayBreak, handler should initialize it.;DETERMINE DAISY / DAYBREAK DIFFERENCES;DyBrk		IN	AX, machineIDPort  	;0020H=Daisy, 0060H=Daybreak;DyBrk		AND	AX, machineIDMask		;Mask out machine type bits;DyBrk		AND	AX, 01000000B		;Mask out bit 2;DyBrk		JZ	ShortJumpToDaisy		;If 0, go to DaisyWorkstation via short jump 1st;DyBrk		JMP	SHORT DaybreakWorkstation	;If 1, go to DaybreakWorkstation;DyBrkShortJumpToDaisy: ;DyBrk		JMP	DaisyWorkstation	;If DAISY workstation, go to DaisyWorkstation;DyBrk;;   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   - ;IF DAYBREAK workstation THEN;BEGIN;DyBrkDaybreakWorkstation:;DyBrk;	It is assumed that the IORDisp was initialized in IOPInit code.;DyBrk;	The display init code only need to initialize internal jump table.;DyBrk;;DyBrk; Set up "jump" table addresses;DyBrkstartsAt0:	MOV	AX, OFFSET DaybreakHWInit		;Set up addr for HW initialization;DyBrk		MOV	displayHWInitProc, AX;DyBrk;	;DyBrk		MOV	BX, OFFSET cursorPositionProc	;Set up addr for Cursor Positioning proc;DyBrk		MOV	AX, OFFSET DaybreakCursorPosition	;Set up addr for Cursor Positioning proc;DyBrk		MOV	[BX], AX;DyBrk;;DyBrk		MOV	AX, OFFSET DaybreakCursorPattern	;Set up addr for Cursor Pattern proc;DyBrk		MOV	[BX+2], AX;DyBrk;;DyBrk		MOV	AX, OFFSET DaybreakBorderPattern	;Set up addr for Border Pattern proc;DyBrk		MOV	[BX+4], AX;DyBrk;;DyBrk		MOV	AX, OFFSET DaybreakBackgndCommand	;Set addr - procs that set backgnd & cmnds;DyBrk		MOV	[BX+6], AX			;Save addr for background procedure;DyBrk		MOV	[BX+8], AX			;Save addr for command procedure;DyBrk;;DyBrk;;DyBrk		JMP	initHardware;END IF DAYBREAK workstation;;  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -;;IF DAISY workstation THEN ;BEGIN;NOTE: The A chip initialization is expected to be done in PreBoot code ; so that only the IOR variables are initialized in here.DaisyWorkstation:;configInfo is setup by IOPInit.asm;; Set up "jump" table addressesstartsAt0Daisy:	MOV	AX, OFFSET DaisyHWInit		;Set up addr for HW initialization		MOV	displayHWInitProc, AX;			MOV	BX, OFFSET cursorPositionProc	;Set up addr for Cursor Positioning proc		MOV	AX, OFFSET DaisyCursorPosition	;Set up addr for Cursor Positioning proc		MOV	[BX], AX;		MOV	AX, OFFSET DaisyCursorPattern	;Set up addr for Cursor Pattern proc		MOV	[BX+2], AX;		MOV	AX, OFFSET DaisyBorderPattern	;Set up addr for Border Pattern proc		MOV	[BX+4], AX;		MOV	AX, OFFSET DaisyBackgndCommand	;Set addr - procs that set backgnd & cmnds		MOV	[BX+6], AX			;Save addr for background procedure		MOV	[BX+8], AX			;Save addr for command procedure;;;		JMP	initHardware;END IF Daisy workstation;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;initHardware:	CALL   displayHWInitProc	;Initialize display HW;;;Wait for vertical retrace interruptstartDisplay:	%DisableInterruptsTillNextWait	;Insure that no intrs happen until we are ready;DyBrk		TEST	configInfo, 80H		;check Daisy/Daybreak;DyBrk		JNZ	StartDaisyDisplay	;Jump to Daisy procedure.;DyBrk;DyBrkStartDayBreakDisplay:;DyBrk		MOV	DX, DisplCntlRegDayBreak	;DX points @ display cntl reg;DyBrk		OR	displCntl, 00000010B	;Set bit1 to start display;DyBrk		MOV	AL, displCntl		;Get command;DyBrkOutputCommand:	OUT	DX, AL			;Output command and start display;DyBrk		JMP	enabDisplayIntr		;;;Shoud the display handler start the Daisy display?;Can I expect the display already starting by IOPInit?;StartDaisyDisplay:		MOV	DX, HBorder1		;		IN	AX, DX			;load current value.		AND	AH, 00001111B	;Mask Vborder1 value		OR	AH, 01100000B	;pic/Border' = 0		OUT	DX, AX		;;;enabDisplayIntr: %Enable (displayInterrupt)	;Enable interrupts before waiting for onewaitForRetraceIntr:		%WaitForInterrupt (1)		;Wait for vertical retrace intr or WDT		JC	displayTimedOut		;Look for watch dog timeout;;;***********************************************************************************************;************************************************;*                                              *;*     VERTICAL RETRACE INTERRUPT               *;*                                              *;************************************************;displayVertRetraceEntr:		INC	displayIntrCnts		;!!!! Increment the number of intr. counts;;Get the "changed" flags and reset them atomically;Pointer to chngdInfo is passed to MesaLockedOut.  The changed flags are returned in AX.		%MesaLockedOut(XCHG, OFFSET chngdInfo, 0, displayLock)		CMP	AX, 0			;Look for no changes		JZ	Exit			;If no changes, exit;;Set up pointers for checking for changesChanges:	MOV	DI, AX			;DI holds changed flags;;;Look for changes in cursor position		RCL	DI, 1			;Check cursor position flag change		JNC	CheckCursor		;If no change, continuecursorPosChng:	PUSH	DI			;Save DI		CALL	cursorPositionProc		POP	DI			;Restore DI;;;Look for changes in cursor patternCheckCursor:	CMP	CursorUser, MPCursor	;See if MP handler is updating cursor;						:pattern.  If CursorUser=MPCursor,;						:the zero flag gets set, but we still need;						:to rotate the flag word.		RCL	DI, 1			;Check cursor pattern flag change;						:the RCL does NOT affect the zero flag		JZ	CheckBorder		;If CursorUser=MPCursor, continue		JNC	CheckBorder		;If no change in cursor pattern, continuecursorPatChng:	CALL	CursorPatternProc	;Otherwise, Output new cursor pattern;;;Look for changes in border patternCheckBorder:	RCL	DI, 1			;Check border pattern flag change		JNC	CheckBackgnd		;If no change, continueborderPatChng:	CALL	borderPatternProc;;;Look for changes in backgroundCheckBackgnd:	RCL	DI, 1			;Check background flag change		JNC	CheckCmmds		;If no change, continuebackgroundChng:	CALL	backgndProc;;;Look for changes in command to display control registerCheckCmmds:	RCL	DI, 1			;Check display cntl reg flag		JNC	CheckAlignment;if no change, check alignment.		CALL	commandProc;CheckAlignment:	RCL	DI, 1		;check display alignment flag		JNC	Exit		;if no change, exit;;DyBrk		TEST	configInfo, 80H	;check if hardware is Daisy;DyBrk		JZ	Exit			;Daybreak don't support display alignment function.		CALL	AdjustDisplayAlignment;Exit:	        %NotifyClientCondition(vertRetraceEvent)  ;Let Mesa know that we got intr;;Clear Interrupt Latch		IN	AX, ClrRetraceIntr	 	 ;Reset Vertical Retrace interrupt latch ;RetraceExit:	JMP	waitForRetraceIntr	;WaitForInterrupt;;;***************************************************************************************************;******************************************;*                                        *;*   Watch Dog Time Out Routine           *;*                                        *;******************************************;;Control is passed to the code here if the watch dog times outdisplayTimedOut:		CALL	displayHWInitProc	;Reinitialize the hardware		JMP	waitForRetraceIntr	;WaitForInterrupt;		ASSUME	DS:NOTHING;;Control is passed to the code here if we got a bad interruptbadDisplayIntr	PROC	FARBadIniterruptEntry:		PUSH	DS		%EstablishHandlerAccess	(DisplayHandlerID)		MOV	AX, ES		MOV	DS, AX		ASSUME	DS:DisplayIORdisplayWDT:	INC	displayWdtCnts		;!!!! Increment the number of intr. countsreInit:		CALL	displayHWInitProc	;Re-initialize the hardware		POP	DSDisplayTimedOutRet:		RET				;The waitForInterrupt is still in effectbadDisplayIntr	ENDP		ASSUME	DS:NOTHING;;***************************************************************************************************;******************************************;*                                        *;*   Daisy/Daybreak Procedures            *;*                                        *;******************************************;;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;HARDWARE INITIALIZATION PROCEDURES;DyBrkDaybreakHWInit	PROC	NEAR;DyBrk		ASSUME	DS:DisplayIOR;DyBrk;;DyBrk;DISABLE VIDEO TO DISPLAY;DyBrk		MOV	DX, DisplCntlRegDayBreak	;DX points @ display control register;DyBrk		MOV	AX, 0			;Get a 0 in AX;DyBrk		OUT	DX, AL			;Output a 0 to disable video & turn display off;DyBrk;;DyBrk;;DyBrk; DO SOFTWARE RESET (This insures that the interlaced field will come up right, ;DyBrk; 			even after power was on);DyBrkResetDisplay:	MOV	DX, DisplaySoftReset;DyBrk		IN	AL, DX;DyBrk;;DyBrk; INITIALIZE DISPLAY CONTROLLER REGISTERS;DyBrk;DyBrk; Initialize Cursor Position;DyBrk InitCursor:	CALL	cursorPositionProc	;Outputs default cur. posit'n (in FCB);DyBrk;;DyBrk;;DyBrk; Initialize DMC;DyBrk InitDMC:	MOV	AX, numberQuadWords	;Get quadWordsPerLine in AX       ;DyBrk		MOV	DX, DMCWordsPerLineDayBreak;DyBrk		OUT	DX, AL			;Output number quad words per line;DyBrk;;DyBrk		MOV	AX, bitMapOrg       ;DyBrk		INC	DX;DyBrk		OUT	DX, AL			;Output low byte display mem. starting addr;DyBrk		MOV	AL, AH       ;DyBrk		INC	DX;DyBrk		OUT	DX, AL			;Output high byte display mem. starting addr;DyBrk;;DyBrk; Initialize DDC;DyBrk;;DyBrk; Initialize border pattern;DyBrk InitBorder:	CALL	borderPatternProc	;Outputs default border pattern (in FCB);DyBrk;;DyBrk;;DyBrk; Initialize cursor pattern;DyBrk		CALL	CursorPatternProc	;Call proc to initialize cursor pattern;DyBrk;;DyBrk;;DyBrk; Do NOT need to initialize System/Memory status registers;DyBrk;;DyBrk		RET;DyBrkDaybreakHWInit	ENDP;DyBrk		ASSUME	DS:NOTHING;DyBrk;;;;;HARDWARE INITIALIZATION PROCEDURES FOR DAISYDaisyHWInit	PROC	NEAR		ASSUME	DS:DisplayIOR;;; DO SOFTWARE RESET (This insures that the interlaced field will come up right, ; 			even after power was on)InitAChip:	CALL  DisplayInitialize		;Exported by OPIE.;; Initialize Cursor PositionInitCursorDaisy: 		CALL  cursorPositionProc	;Outputs default cur. posit'n (in FCB);; Initialize border patternInitBorderDaisy: 		CALL	borderPatternProc	;Outputs default border pattern (in FCB);;; Initialize cursor pattern		CALL	CursorPatternProc	;Call proc to initialize cursor pattern;; Get the original values of HBorder0 and VBorder0.		MOV	DX, HBorder0		IN	AX, DX		MOV	HBorder0Base, AX		MOV	DX, VBorder0		IN	AX, DX		MOV	VBorder0Base, AX;; Initialize display alignment		CALL	AdjustDisplayAlignment	;Call proc to initialize display alignment.;FinishDaisyHWInit:		RETDaisyHWInit	ENDP		ASSUME	DS:NOTHING;;;;CURSOR POSITION PROCEDURES;DyBrkDaybreakCursorPosition  PROC   NEAR		;Procedure for Daybreak cursor position;DyBrk		ASSUME	DS:DisplayIOR;DyBrk		CALL	CheckCursorPositionLimits;DyBrk		CALL	ConvertXCoordProc	;This leaves the cursor word position in AL and the bit offset in BL;DyBrk		MOV	DX, CursorWordPortDayBreak  ;DX pnts @ CursorWordPortDayBreak;DyBrk		OUT	DX, AL			;Output cursor x word locn.;DyBrk		INC	DX			;DX pnts @ CursorOffsetPortDayBreak;DyBrk		MOV	AX, BX			;Get bit offset into AX;DyBrk		OUT	DX, AL			;Output cursor x bit offset;DyBrk;;DyBrk		INC	DX			;DX pnts @ CursorLinePortLowDayBreak;DyBrk		MOV	AX, cursorYCoord	;Get y coord;DyBrk		ADD	AX, yCoordOffset	;Add necessary offset;DyBrk		MOV	BX, AX			;Save y coord;DyBrk		AND	AX, 0000000000111111B	;Get 6 least sign. bits;DyBrk		OUT	DX, AL			;Output 6 least sig. to Y low;DyBrk;;DyBrk		INC	DX			;DX pnts @ CursorLinePortHighDayBreak;DyBrk		MOV	AX, BX			;Get y coord + offset;DyBrk		SAR	AX, 6			;Get 4 most sign. bits;DyBrk		OUT	DX, AL			;Output 4 least sig. to Y high;DyBrk;;DyBrk	        RET;DyBrkDaybreakCursorPosition  ENDP;DyBrk		ASSUME	DS:NOTHING;DyBrk;;;;CURSOR POSITION PROCEDURESDaisyCursorPosition	PROC	NEAR		ASSUME	DS:DisplayIOR;VerifyPosition:	CALL	CheckCursorPositionLimitsChangeXCoord:	CALL	ConvertXCoordProc	;This leaves the converted cursor position in AX;;following codes output the cursor position info to the hardware.;first write X coord to the HCursor register.		MOV	DX, HCursor		;DX pnts HCursor		OUT	DX, AX			;Output cursor x word locn.;ChangeYCoord:	MOV	AX, cursorYCoord	;Get y coord		ADD	AX, yCoordOffset	;Add necessary offset		AND	AX, 0000111111111111B	;Mask Y coord.		MOV	BH, displCntl		;Get current mixrule.		AND	BH, 0F0H		;Mask mixRule.		OR 	AH, BH			;ORed in the mixRule into VCursor				MOV	DX, VCursor		;DH is still set up.		OUT	DX, AX			;Output the data.;FinishCursorPosDaisy:	        RETDaisyCursorPosition  ENDP		ASSUME	DS:NOTHING;;;CheckCursorPositionLimits	PROC	NEAR	;This proc checks to make sure the x coord is within 15 pixels of the border		ASSUME	DS:DisplayIORGetXCoord:		MOV	SI, OFFSET cursorXCoord	;SI points @ x coord		MOV	DI, OFFSET numberBitsPerLine	;DI points @ display width		MOV	CX, 2			;Twice thru loop;Twice:		CMP	[SI], 0FFF1H		;Check cursor position within top and left border bits;						:   0FFF1H = -15 in 2's complement form		JGE	TopLeftOK		;If O.K., go on		MOV	[SI], 0FFF1H		;If too far, reset back to -15TopLeftOK:	MOV	AX, [DI]		;Get max value in AX		CMP	[SI], AX		;Check cursor position within bottom and right border bits		JLE	BottomRightOK		;If O.K., go on		MOV	[SI], AX		;If too far, reset backBottomRightOK:	INC	DI		INC	DI			;DI points @ display height		INC	SI		INC	SI			;SI points @ y coord		LOOP	Twice CursorPosChecked:		RETCheckCursorPositionLimits	ENDP		ASSUME	DS:NOTHING;;ConvertXCoordProc	PROC	NEAR		;This proc converts x coord from pixels to a word and an offset;This leaves the cursor word position in AL and the bit offset in BL		ASSUME	DS:DisplayIORBeginConversion:		MOV	AX, cursorXCoord	;Get x coord in AX		ADD	AX, xCoordOffset	;Add necessary offset		MOV	BX, AX			;Save x coord + offset		SAR	AX, 4			;Get word locn in AX		AND	BX, 0000000000001111B	;Get bit offset in BL;the word location is in AX and bit offset is in BL;A chip's HCursor has following format:;b15..b14 = Cursor Nibble Offset (0-3 nibble offset from a gine HCursor origin);b13..b12 = Cursor Rotate (0-3 bit offset from a given HCursor origin);b11..b00 = cursor word location in display.		SAL	BX, 12			;shift offset value to the MSNibble, b7..b4 of BH		OR	AH, BH			;add offsetXCoordConverted:		RETConvertXCoordProc	ENDP		ASSUME	DS:NOTHING;;  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -;;CURSOR PATTERN PROCEDURES;DyBrkDaybreakCursorPattern	PROC   NEAR		;Procedure for Daybreak cursor patttern;DyBrk		ASSUME	DS:DisplayIOR;DyBrk		MOV	DX, cursorBufferPortsDayBreak  ;DX pts @ starting addr of cursor buffer;DyBrk		MOV	SI, 0			;SI indexes source word in cursorPattern;DyBrkDaybreakMap:	MOV	AL, cursorPattern[SI]	;Get value to output in AL;DyBrk		OUT	DX, AL			;Output value to port;DyBrk		INC	DX			;DX pnts to next cursorPattern locn port;DyBrk		INC	SI			;SI pnts to next value;DyBrk		CMP	SI, NumBitMapBytes	;See if all new values have been outputed;DyBrk		JL	DaybreakMap;DyBrk		RET;DyBrkDaybreakCursorPattern	ENDP;DyBrk		ASSUME	DS:NOTHING;DyBrk;;;;CURSOR PATTERN PROCEDURESDaisyCursorPattern PROC NEAR		ASSUME	DS:DisplayIORBeginPatternChangeDaisy:		MOV	DX, CursorBufferReg  ;DX pts @ starting addr of cursor buffer		MOV	CX, NumBitMapBytes		SAR	CX, 1			;Cursor register is 16 bits wide.		MOV	BX, OFFSET cursorPattern		CursorOutputDaisy:		MOV	AX, [BX]		;load first word.		;XOR	AX, 0FFFFH		;invert bits		OUT	DX, AX		INC	DX		INC	DX		INC	BX		INC	BX		LOOP	CursorOutputDaisy;Temp/		MOV	SI, 0			;SI indexes source word in cursorPattern;Temp/DaisyMap:	MOV	AL, cursorPattern[SI]	;Get value to output in AL;Temp/		MOV	AH, cursorPattern[SI + 1];;Temp/		XOR	AX, 0FFFFH		;invert bits (Added for AFab2A or Later).;Temp/		OUT	DX, AX			;Output value to port;Temp/		INC	DX			;DX pnts to next ;Temp/		INC	DX			;cursorPattern locn port;Temp/		INC	SI			;SI pnts to ;Temp/		INC	SI			;next word value;Temp/		CMP	SI, NumBitMapBytes	;See if all new values have been outputed;Temp/		JL	DaisyMapCursorPatUpdatedDaisy:		RETDaisyCursorPattern	ENDP		ASSUME	DS:NOTHING;;;;BORDER PATTERN PROCEDURES;DyBrkDaybreakBorderPattern	PROC   NEAR		;Procedure for Daybreak border pattern;DyBrk		ASSUME	DS:DisplayIOR;DyBrk		MOV	DX, BorderPatternLowDayBreak  ;DX points @ BorderPatternLowDayBreak;DyBrk		MOV	SI, OFFSET borderLow	;SI points @ source values (borderLow);DyBrk		MOV	CX, 2			;Output two border pattern bytes;DyBrkBorderOutDaybreak:;DyBrk		MOV	AL, [SI]		;Get value to output in AL;DyBrk		OUT	DX, AL			;Output border pattern;DyBrk		INC	DX			;DX points to next border pattern port;DyBrk		INC	SI			;SI points to next value;DyBrk		LOOP	BorderOutDaybreak	;Output values til CX = 0;DyBrk		RET;DyBrkDaybreakBorderPattern	ENDP;DyBrk		ASSUME	DS:NOTHING;DyBrk;;;;BORDER PATTERN PROCEDURES;Mesa will write border pattern as a pair of two BYTEs.;A chip's border pattern registers (Border0 and Border1) are 16 bit wide.;;borderLow is oddPairs and borderHigh is evenPairs;Border1 is a register for even pairs and Border0 is a register for oddPairs.;borderLow => Border0, borderHigh => Border1DaisyBorderPattern	PROC   NEAR		;Procedure for Daisy border pattern		ASSUME	DS:DisplayIORDaisyBorderEntry:		MOV	DX, Border1	;DX points  		MOV	SI, OFFSET borderLow	;SI points @ source values (borderLow)		MOV	CX, 2			;Output two border pattern bytesBorderOutDaisy: MOV	AL, [SI]		;Get value to output in AL		MOV 	AH, AL			;AX holds the border pattern in 16 bits wide format.		OUT	DX, AX			;Output border pattern		INC	DX			;DX needed to be incremented double.		INC	DX			;so that DX points to next border pattern port		INC	SI			;SI points to next border value		LOOP	BorderOutDaisy	;Output values til CX = 0BorderUpdatedDaisy:		RETDaisyBorderPattern	ENDP		ASSUME	DS:NOTHING;;;;PROCEDURES FOR SETTING BACKGROUND AND OUTPUTTING COMMANDS;DyBrkDaybreakBackgndCommand	PROC   NEAR		;Procedure for Daybreak backgrnd & cmnds;DyBrk		ASSUME	DS:DisplayIOR;DyBrk		MOV	DX, DisplCntlRegDayBreak	;DX points @ DisplCntlRegDayBreak;DyBrk		MOV	AL, displCntl		;Get new info for display control register;DyBrk		OUT	DX, AL			;Output to display control register;DyBrk		RET;DyBrkDaybreakBackgndCommand  ENDP;DyBrk		ASSUME	DS:NOTHING;;;;PROCEDURES FOR SETTING BACKGROUND AND OUTPUTTING COMMANDS;The bit assignment of the diplCntl in IOR is for the display controller of Daybreak so I ;should translate it.;;This procedure will change video vs cursor mix rule, PICyBord' bits.;DaisyBackgndCommand	PROC   NEAR		;Procedure for Daisy backgrnd & cmnds		ASSUME	DS:DisplayIOR;;Change mix rule;BeginBckGrdCmdDaisy:		MOV	DX, VCursor	;		IN 	AX, DX		;read current value of mix rule and VCursor.		AND	AX, MSNibbleMask;Mask mixRule.		MOV	BH, displCntl	;Get new mixRule for display control register		MOV	BL, BH		;save value.		AND	BH, 0F0H	;Mask mixRule		OR 	AH, BH		;ORed mixRule into VCursorOutputNewMixRule:		OUT	DX, AX		;Output to display control register		;Change picture/border bitPictureBorder:	MOV	BH, 01100000B	;ColorMode' and DCTest' should be 1		TEST	BL, pictureBorderCheckMask;;					:Check if display bitmap.		JNZ	CheckVideoDisable;					:IF bit is set, skip to next cmd bit.;ELSE, display border only.		OR	BH, borderOnlyMask;					:set bit 4 of BH register. ;					:nPICyBDR ¬ 1;;;Then check if video enableCheckVideoDisable:		TEST	BL, videoDisableCheckMask		JNZ	OutputNewData	;video is enabled.				OR	BH, videoDisableMask;OutputNewData:		MOV	DX, HBorder1	;DH is still setup		IN 	AX, DX		;read current value.		AND 	AX, MSNibbleMask; mask HBorder1 value.		OR	AH, BH		;		OUT	DX, AX		;		;restore border pattern, just in case nPICyBDR smashed it.;***************** TEMP ************************		CALL borderPatternProc	;to update border pattern registers in AChip0.;***************** TEMP ************************FinishBckGrndDaisy:		RETDaisyBackgndCommand  ENDP		ASSUME	DS:NOTHING;;AdjustDisplayAlignment	PROC	NEAR		ASSUME	DS: DisplayIOR		ReadXAlign:		%ReadEEProm(eePromXAlign,01)	;read X align into AL (AH = 0)		JC	ReadYAlign	;if EEPROM is bogus, skip to YAlign;The format of XAlign data is followes:;	bit 7: Direction bit, 0 => Right, 1 => Left;	bit6..2: Word offset of x alignment;	bit1..0: Nibble offset of x alignmentXAlignOK:	PUSH	AX		;Save value		MOV	BX, AX		;		SHR	BX, 2		;shift right 2bits. Discard nibble offsets at this time.		TEST	AL, 80H		;Check direction bit		JZ	UpdateHRegs;direction is left so that convert word value to 2's complementLeftShift:	AND	BL, 0DFH	;Turn off direction bit		NEG	BX		;Get 2's complement.UpdateHRegs:		ADD	BX, HBorder0Base		AND	BX, 0FFFH	;get a new HBorder0 word offset		MOV	DX, HBorder0		IN	AX, DX		;get a previous HBorder0 value		AND	AX, 0FFFH	;get a previous HBorder0 word offset		SUB	BX, AX		;get a difference 		MOV	DX, HBorder1		MOV	CX, 4		;HBorder1, HBorder0, HBlank0, HBlank1  will be updated.SetXAlignLoop:		IN	AX, DX		;read current value.		ADD	AX, BX		;add new word offset.		OUT	DX, AX		;output new data.NextHReg:	INC	DX		INC	DX		;point to next register.		LOOP	SetXAlignLoopAdjustXCoordWordOffset:		SAL	BX, 4		;get bit offset		ADD	xCoordOffset, BX;;Comment out until nibble alignment works		;UpdateNibbleOffset:		POP	BX		;get EEPROM data from Stack.;		ROR	BX, 2		;rotate 2 bits so that nibble offset will be in right place;		AND	BH, 0C0H	;mask other bits.;		MOV	DX, HBorder0	;point to HBorder0;		IN	AX, DX		;read current value.;		AND	AH, 3FH		;clear previous offset;		OR	AH, BH		;set new nibble offset;		OUT	DX, AX		;output new data.AdjustXCoordNibbleOffset:;Above code is not implemented until nibble alignment works.		ReadYAlign:	%ReadEEProm(eePromYAlign,01)		JC	EndOfAdjust	;If EEPROM is invalid, skip and finish.;Y align value is simple offset value from the standard parameter.;It is assumed that EEPROM value was already converted to 2's complement;to move screen upwards.YAlignOk:	MOV	BX, AX		;save value;YAlign value is ok so that first check the direction bit.		TEST	BL, 80H;		JZ	YAlignDataConverted;direction bit is 1 so that convert the offset to negative value.		AND	BL, 7FH		;reset direction bit.		NEG	BX		;get 2's complementYAlignDataConverted:;Temp/		TEST	AX, 1		;Test new value is odd.;Temp/		JZ	SetYAlignment	;;Temp/;;Temp/;In here, the border pattern values should be swapped to keep Pilot Display face definition.;Temp/;borderLow => Border1, borderHigh => Border0;Temp/		MOV	DX, Border1	;DX points to Border1 register;Temp/		MOV	SI, OFFSET borderLow	;SI points @ source values (borderLow);Temp/		MOV	CX, 2		;Output two border pattern bytes;Temp/BorderSwap: MOV	AL, [SI]	;Get value to output in AL;Temp/		MOV 	AH, AL		;AX holds the border pattern in 16 bits wide format.;Temp/		OUT	DX, AX		;Output border pattern;Temp/		INC	DX		;DX needed to be incremented double.;Temp/		INC	DX		;DX points to Border0 register;Temp/		INC	SI		;SI points to next border value;Temp/		LOOP	BorderSwap	;Output values til CX = 0		SetYAlignment:		SAL	BX, 2		;vertical alignment is increment/decrement by power of 4.				ADD	BX, VBorder0Base		AND	BX, 0FFFH	;get a new VBorder0		MOV	DX, VBorder0		IN	AX, DX		AND	AX, 0FFFH	;get a previous VBorder0		SUB	BX, AX		;get a difference				MOV	CX, 4		;change VBorder1, VBorder0, VBlank1, VBlank0		MOV	DX, VBorder1SetYAlignLoop:		IN	AX, DX		;read current value.		ADD	AX, BX		;add new offset.		OUT	DX, AX		;output new data.		INC	DX		INC	DX		;		LOOP	SetYAlignLoop	;AdjustYCoordOffset:		ADD	yCoordOffset, BX		EndOfAdjust:	RETAdjustDisplayAlignment	ENDP		ASSUME	DS: NOTHING;;;IOPEInROM	ENDS;********************************************************************************			END
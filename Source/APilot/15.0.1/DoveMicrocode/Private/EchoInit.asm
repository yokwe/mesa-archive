$MOD186$PAGELENGTH	(95)$PAGEWIDTH	(136);Copyright (C) 1984 by Xerox Corporation. All rights reserved.;Ethernet tester initialization;stored as [Idun]<WMicro>Dove>EchoInit.asm;created on 17-Sep-84 19:03:56;last edited by:;	KEK	25-Jul-86 10:26:27	upgrade to reconfig opie;	BKI	 4-Aug-85 23:12:16	Rewrite and optimize for code space;	BKI	26-Jun-85 19:49:24	Change FIFO limit from 008h to 00Bh;					for B0 machines (slower clock speed);	BKI	17-Sep-84 19:03:56NAME		EchoInitPUBLIC		EtherInitialize$NOLIST$INCLUDE	(IOPDefs.asm)$INCLUDE	(QueDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(HardDefs.asm)$INCLUDE	(EthIOFce.asm)$LISTEXTRN		BootStrapHandlerID: ABSEXTRN		EthernetHandlerID: ABSBootstrapIOR	SEGMENT	COMMONEXTRN		etherTstCmd: Condition, etherTstIOCB: IOCBBootstrapIOR	ENDSEthernetIOR	SEGMENT	COMMONEXTRN		etherCmdAvail: Condition, etherOutQueue: QueueBlockEthernetIOR	ENDSIOPEInROM	SEGMENT	PUBLIC		ASSUME	CS:IOPEInROM		ASSUME	DS:BootstrapIORconfigureParms	DB	11			;configure byte count		DB	00BH			;fifo limit (008H for B2)		DB	080H			;bad frame, etc		DB	02EH			;loopback, etc		DB	000H			;backoff parms		DB	96			;interframe spacing		DB	000H			;slot time		DB	0F1H			;retry number		DB	000H			;promiscuous, etc		DB	000H			;carrier sense, collision detect		DB	64			;min frame lengthconfigureParmsSize	EQU	$-configureParmsExecuteCommand	PROC	NEARExecuteCommandEntry:		PUSH	ES		%EstablishHandlerAccess	(EthernetHandlerID)		ASSUME	ES:EthernetIOR		MOV	etherOutQueue.queueNext.OpieAddressLow, BX		MOV	etherOutQueue.queueNext.OpieAddressType, IOPIORegionOpieAddress		PUSH	BX		%NotifyHandlerCondition	(EthernetHandlerID,OFFSET etherCmdAvail)		%WaitForCondition	(OFFSET etherTstCmd,noTimeout)		POP	BX		TEST	[BX].iocbStatus, MASK iocbOkay		POP	ES		ASSUME	ES:NOTHING		RETExecuteCommand	ENDPInitEtherIOCB	PROC	NEARInitEtherIOCBEntry:		XOR	AL, AL		;set up AL for string op		MOV	CX, SIZE IOCB	;set up CX for string op		MOV	DI, DS		MOV	ES, DI		;set up ES:DI to point to etherTstIOCB		MOV	DI, BX		;  in BootStrapIOR for string op		CLD		REP	STOSB		MOV	[BX].iocbCondition.handlerID, LOW BootStrapHandlerID		MOV	[BX].iocbCondition.conditionPtr, (OFFSET etherTstCmd)		OR	[BX].iocbCondition.conditionPtr, nonNilPtr		MOV	[BX].iocbCondition.clientMask, 0		MOV	[BX].iocbType, AH		RETInitEtherIOCB	ENDPEtherInitialize	PROC	NEAR		;DS contains BootStrapIOR		;(and this proc smashes DS into ES, then restores it.)		PUSH	ES		MOV	BX, OFFSET etherTstIOCBSetUpReset:	MOV	AH, iocbReset SHL 4		CALL	InitEtherIOCB		CALL	ExecuteCommand		JZ	EtherInitErrorSetUpConfigure:	MOV	AH, (iocbCommand SHL 4)+acConfigure		CALL	InitEtherIOCB		MOV	SI, OFFSET configureParms		LEA	DI, [BX].iocbVariant		MOV	CX, configureParmsSize		CLD		REP	MOVS	BYTE PTR ES:[DI], CS:[SI]		CALL	ExecuteCommand		JZ	EtherInitErrorSetUpIndAddr:	MOV	AH, (iocbCommand SHL 4)+acIndAddr		CALL	InitEtherIOCB;set ind addr in IOCB		XOR	DI, DI		MOV	CX, addrSize		MOV	DX, ReadHostPromSetHostProm:	IN	AL, DX		MOV	[BX].iocbVariant.cmdParms.indAddr[DI], AL		INC	DI		ADD	DX, 2		LOOP	SetHostProm		CALL	ExecuteCommand		JZ	EtherInitErrorReceiveFrames:	MOV	AH, iocbStartRU SHL 4		CALL	InitEtherIOCB		CALL	ExecuteCommand		JZ	EtherInitError				POP	ES		RETEtherInitError:	JMP	$EtherInitialize	ENDPIOPEInROM	ENDS;		PURGE		END
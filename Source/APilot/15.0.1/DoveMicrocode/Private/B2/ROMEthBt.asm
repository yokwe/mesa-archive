$MOD186$PAGELENGTH	(72)$PAGEWIDTH	(136);Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;-- stored as [Iris]<WMicro>Dove>ROMEthBt.asm;-- created on  19-Jul-84 13:20:18;-- last edited by:;	kek	 4-Sep-85 17:31:53	;mp codes;	JPM	15-Aug-85 15:08:46	;Use SHL 4 when setting iocbType field.;--	JPM	15-Aug-85 10:39:27	;Set AH for EtherInitialize.;--	JPM	14-Aug-85 10:05:03	;Set rbdCount for ethernet and DL for EtherInitialize.;--	JPM	 1-Aug-85 12:44:42	;Fix bug in RequestBootFile.;--	JPM	24-Jul-85 10:08:00	;Remove ethernetInLocalRAM.;--	JPM	22-Jul-85 15:59:21	;Change IOPEInROM alignment to WORD, fix bug.;--	JPM	16-Jul-85  8:06:47	;Opie redesign conversion.;--	JMM	21-Jun-85 15:01:39	;Removed e'net initialization (Really!).;--	JMM	19-Jun-85 16:33:51	;Added alternate ethernet boot support.;--	JMM	15-Apr-85 16:30:10	;Removed e'net initialization.;--	JMM	 4-Apr-85 17:01:03	;Removed IOPLRAM.asm.;--	JMM	17-Dec-84 15:45:20	;Paragraph align buffer.;--	JMM	 4-Dec-84 17:51:20	;Upgrade for Opie 16 compatibility.;--	BKI	28-Nov-84 19:30:07	;Convert to new EthIOFce.;--	JMM	14-Nov-84 11:33:34	;Merged with Ethernet							;chip initialization.;--	BKI	19-Jul-84 13:25:50NAME		ROMEthBt$NOLIST$INCLUDE	(IOPDefs.asm)$INCLUDE	(QueDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(QueMacro.asm)$INCLUDE	(HardDefs.asm)$INCLUDE	(ROMBDefs.asm)$INCLUDE	(EthIOFce.asm)$LIST%*DEFINE	(ByteSwap	(wordToSwap))		(%wordToSwap SHL 8 OR %wordToSwap SHR 8);--------------------------------------------------------------------------------EXTRN			BootStrapHandlerID: ABSEXTRN			EthernetHandlerID: ABSEXTRN			DisplayMPCode: NEAR;---------------;******************************************************************;---------------IOPELocalRAM	SEGMENT	AT 0;from IOPLRAM.asm:;------------------EXTRN		opieReentry: DWORDEXTRN		bootType: BYTEEXTRN		baseEthernetFileID: WORDEXTRN		startOfBootBufferSpace: WORDEXTRN		endOfBootBufferSpace: WORDEXTRN		HandlerInitProcTable: DWORDIOPELocalRAM	ENDS;---------------;******************************************************************;---------------;from IORROMBt.asm:;------------------BootStrapIOR	SEGMENT	COMMONEXTRN		bootStrapTask: TaskContextBlockEXTRN		bootDeviceIORSpace: EtherBootContextEXTRN		jumpTable: BootJumpTableBootStrapIOR	ENDS;from IOREther.asm:;------------------EthernetIOR	SEGMENT	COMMONEXTRN		etherCmdAvail: ConditionEXTRN		etherInQueue: QueueBlockEXTRN		etherOutQueue: QueueBlockEXTRN		inBufferAvail: ConditionEXTRN		rbdCount: BYTEEthernetIOR	ENDS;from STKEther.asm:;------------------EthernetSTK	SEGMENT	COMMONEXTRN		EndOfEthernetStackSeg: WORD		EthernetSTK	ENDS;---------------;******************************************************************;---------------IOPEInROM	SEGMENT	WORD PUBLIC		ASSUME CS:IOPEInROM		ASSUME DS:BootStrapIORPUBLIC		EthernetBootStrap;from ROMBoot.asm:;------------------EXTRN		EtherInitialize: NEAR;For reading in a record of EtherInitialDove.db:;-----------------------------------------------nsTypeField	EQU	%ByteSwap(0600H)bootReqPacket	LABEL	WORD		DW	0FFFFH, 0FFFFH, 0FFFFH	;broadcast packet		DW	setAtRunTime, setAtRunTime, setAtRunTime						;source host ID		DW	nsTypeField     	;Ethernet NS packet type		DW	setAtRunTime		;checksum		DW	%ByteSwap(38)		;Internet packet length		DW	%ByteSwap(9)		;bootServer packet type		DW	00000H, 00000H		;dest net: 0=>local		DW	0FFFFH, 0FFFFH, 0FFFFH	;broadcast packet		DW	%ByteSwap(10)		;Boot server socket.		DW	00000H, 00000H		;source net: 0=>local		DW	setAtRunTime, setAtRunTime, setAtRunTime						;source host ID		DW	%ByteSwap(40H)		;source socket (?)		DW	%ByteSwap(1)		;boot protocol: simple req;		DW	%ByteSwap(00000H)	;boot file number.-- Now passed;		DW	%ByteSwap(0AA00H)	;up through "baseEthernetFileID";		DW	%ByteSwap(00800H)	;by ROMBoot.asmbootReqPktSize	EQU	($-bootReqPacket)/2;-- Ethernet BootStrap:;--------------  Assume only bootFailure variable reset upon entry and that the;--------------  user has selected to boot from the Ethernet either by default;--------------  or by selection:;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------;There is a good chance other clients will use this princOps checksum generator.CalcChecksum	PROC	NEAR;Arguments:	ES:DI	offset of word-aligned buffer;		CX:	length of buffer (words);Returns:	AX:	word checksumunChecksummed	EQU	0FFFFH		PUSH	DX		XOR	AX, AXSumNextWord:	MOV	DX, ES:[DI]		ROL	DX, 8		;byteswap word;The following sequence is the checksum algorithm		ADD	AX, DX		ADC	AX, 0		ROL	AX, 1		ADD	DI, 2		LOOP	SumNextWord		CMP	AX, unChecksummed		JNE	ChecksumExit		XOR	AX, AXChecksumExit:	ROL	AX, 8			;byteswap checksum		POP	DX		RETCalcChecksum	ENDPEthernetBootStrap:;The Ethernet request packet information is in ROM but the Ethernet handler;expects it to be in the data buffer pointed to by the IOCB.  In our case the;buffer is actually the location to load *InitialDove.db.  We now have to prepare;an IOCB for the Ethernet handler.;If an error occurs while retrieving any part of EtherInitialDove.db, we must;start over from scratch (transmit the broadcast packet).  Hence, we must not;change the variable startOfBootBufferSpace until the entire file has been loaded.;Note that RamEthBt must be able to reenter this code if an error occurs so it can;retransmit the broadcast packet.;ToDo: Jam CS:IP of EtherBootError into reentry variable.		MOV	AX, IOPELocalRAM		MOV	ES, AX		ASSUME	ES:IOPELocalRAM		%CallHandlerInitProc	(EthernetHandlerID)		%WaitForSystem				;Give ethernet a chance to initialize		MOV	AX, EthernetIOR		MOV	ES, AX		ASSUME	ES:EthernetIOR		MOV	rbdCount, 4			;Reduce number of buffers		MOV	DI, OFFSET bootDeviceIORSpace.etherIOCB		MOV	BX, OFFSET bootDeviceIORSpace.etherIOCBDone		MOV	AL, LOW BootStrapHandlerID		MOV	AH, 2	;disable broadcast packets		PUSHF		PUSH	CS		CALL	EtherInitialize;set invariant part of IOCB		MOV	DI, OFFSET bootDeviceIORSpace		MOV	[DI].etherIOCB.nextIOCB.OpieAddressType, nilOpieAddress		MOV	[DI].etherIOCB.iocbCondition.handlerID, LOW BootStrapHandlerID		MOV	[DI].etherIOCB.iocbCondition.conditionPtr, OFFSET bootDeviceIORSpace.etherIOCBDone+nonNilPtr		MOV	[DI].etherIOCB.iocbCondition.clientMask, 0		MOV	[DI].retryCount, 10		MOV	WORD PTR [DI].romRetryEntry, OFFSET RequestBootFile		MOV	WORD PTR [DI].romRetryEntry+2, CS;ToDo: make sure BX is even (word-aligned);ToDo: consider setting BX such that BX+bootDataOffset is paragraph aligned;so that IP = 0.RequestBootFile:		MOV	CX, IOPELocalRAM		MOV	ES, CX		ASSUME	ES:IOPELocalRAM		MOV	DI, EthernetSTK			;The first record of		SHL	DI, Nibble			;EtherInitialDove.db goes		ADD	DI, OFFSET EndOfEthernetStackSeg ;after the ethernet stack segment.		ADD	DI, bootDataOffset		;Recall that booting uses		ADD	DI, LowNibbleMask		;IOP local RAM for all its		AND	DI, NOT(LowNibbleMask)		;work and that we have to load		SUB	DI, bootDataOffset		;code at a paragraph boundary		MOV	startOfBootBufferSpace, DI	;in order for it to work as		MOV	bootDeviceIORSpace.initialBufPtr, DI		MOV	BX, DI		MOV	CH, iopLogicalOpieAddress		MOV	CL, 0		MOV	bootDeviceIORSpace.etherIOCB.iocbVariant.bufAddr.OpieAddressLow, DI		MOV	bootDeviceIORSpace.etherIOCB.iocbVariant.bufAddr.OpieAddressHigh, CX		MOV	CX, EthernetIOR			;Limit the size		SHL	CX, Nibble			;of the boot		MOV	endOfBootBufferSpace, CX	;area.;Move ROM request packet into the transmit buffer		MOV	SI, OFFSET bootReqPacket		MOV	CX, bootReqPktSize		CLDCopyPacket:	MOVS	WORD PTR ES:[DI], CS:[SI]		LOOP	CopyPacket		MOV	CX, 3		MOV	SI, OFFSET baseEthernetFileID		CLDStuffFileID:	MOVS	WORD PTR ES:[DI], ES:[SI]		LOOP	StuffFileID;set request packet items which are "setAtRunTime"		XOR	DI, DI		MOV	CX, addrSize		MOV	DX, ReadHostPromSecondSetHostProm:		IN	AL, DX		MOV	ES:[BX][DI]+srcOffset, AL		MOV	ES:[BX][DI]+srcHostOffset, AL		INC	DI		ADD	DX, 2		LOOP	SecondSetHostProm		MOV	DI, BX		ADD	DI, lengthOffset		MOV	CX, ES:[DI]		ROL	CX, 8			;byteswap length		SHR	CX, 1			;bytes -> words		DEC	CX			;don't include checksum word		CALL	CalcChecksum		MOV	ES:[BX]+checksumOffset, AX;set variant part of IOCB		MOV	DI, OFFSET bootDeviceIORSpace.etherIOCB		MOV	[DI].iocbType, iocbOutput SHL 4		MOV	[DI].iocbVariant.bufLength, frameMinSize;queue the IOCB		PUSH	ES		MOV	AX, EthernetIOR		MOV	ES, AX		ASSUME	ES:EthernetIOR		MOV	DX, DI		MOV	CH, IOPIORegionOpieAddress		MOV	CL, LOW BootStrapHandlerID		;display mp code that initial microcode is about to be fetched		PUSH	AX		MOV	AX, mpFetchInitial		CALL	DisplayMPCode			;this does a wait for system		POP	AX		%EnQueue	(etherOutQueue,nextIOCB,preserveES)		%NotifyHandlerCondition	(EthernetHandlerID,OFFSET etherCmdAvail)		%WaitForCondition	(OFFSET bootDeviceIORSpace.etherIOCBDone,noTimeout)		%DeQueue	(etherOutQueue,nextIOCB,preserveES)		POP	ES		ASSUME	ES:IOPELocalRAM		TEST	bootDeviceIORSpace.etherIOCB.iocbStatus, MASK iocbOkay		JNZ	SetInputIOCB		JMP	EtherBootErrorSetInputIOCB:	MOV	bootDeviceIORSpace.etherIOCB.iocbType, iocbInput SHL 4		MOV	bootDeviceIORSpace.etherIOCB.iocbVariant.bufLength, maximumBootBufferSize;initialize no response timer to ten seconds		%GetIntervalTimer		ADD	AX, tenSeconds		;ten seconds		MOV	bootDeviceIORSpace.noResponseTimer, AX;if no response within ten seconds, jump to BootRcvErrorCheckRcvTimer:	%GetIntervalTimer		SUB	AX, bootDeviceIORSpace.noResponseTimer		JS	NotifyHandler	;negative = timer not yet expired TimerExpired:	JMP	EtherBootError;notify the handlerNotifyHandler:		PUSH	ES;enqueue the input IOCB		MOV	CX, EthernetIOR		MOV	ES, CX		ASSUME	ES:EthernetIOR		MOV	etherInQueue.queueNext.OpieAddressLow, OFFSET bootDeviceIORSpace.etherIOCB		MOV	etherInQueue.queueNext.OpieAddressHandlerID, LOW BootStrapHandlerID		MOV	etherInQueue.queueNext.OpieAddressType, IOPIORegionOpieAddress		POP	ES		ASSUME	ES:IOPELocalRAM		PUSH	AX		%NotifyHandlerCondition	(EthernetHandlerID,OFFSET inBufferAvail)		POP	AX;set timeout on condition variable to time remaining on no response timer		NEG	AX		;change to positive value		%WaitForCondition	(OFFSET bootDeviceIORSpace.etherIOCBDone,AX);check for frame received or timeout		JC	EtherBootError		;jump if timeout;check to see if the frame was received successfully		TEST	bootDeviceIORSpace.etherIOCB.iocbStatus, MASK iocbOkay		JZ	CheckRcvTimer;ToDo: should we compare the destination addr to our host addr?;ES:BX _ address of buffer		MOV	BX, startOfBootBufferSpace;check to see if this is an NS packet		CMP	WORD PTR ES:[BX]+typeFieldOffset, nsTypeField		JNE	DropOnFloor;compare the boot file number to the one for the initial packet		MOV	SI, OFFSET baseEthernetFileID		LEA	DI, ES:[BX]+bfnOffset		MOV	CX, bfnSize/2		;words		CLDCompareBootNo:	CMPS	WORD PTR ES:[SI], ES:[DI]		JNE	DropOnFloor		LOOP	CompareBootNo;check the sequence number and increment if okay		CMP	ES:[BX]+seqNumberOffset, %ByteSwap(1)		JNE	DropOnFloor;this is the expected packet -- jump into it at the proper entry point;At the jump, ES:SI must point to the buffer containing the first record		MOV	SI, BX		MOV	AX, ES:[BX]+lengthOffset		ROL	AX, 8			;byteswap length		ADD	AX, encapsulation		ADD	bootDeviceIORSpace.initialBufPtr, AX		ADD	BX, bootDataOffset		SHR	BX, Nibble		MOV	jumpTable.iopEntry, Null		MOV	jumpTable.iopEntryCS, BX		JMP	DWORD PTR jumpTable.iopEntry;not the expected packet -- drop it on the floorDropOnFloor:	JMP	CheckRcvTimer;error during ether booting -- wait ten seconds and retry againEtherBootError:	DEC	bootDeviceIORSpace.retryCount		JZ	FatalError		%WaitForTime	(tenSeconds)		JMP	RequestBootFile;retry limit exceeded -- unrecoverable errorFatalError:	MOV	AX, mpInitialError		CALL	DisplayMPCode		%Jam	(BootStrapHandlerID,OFFSET bootStrapTask)		%WaitForSystem		; never returns!IOPEInROM	ENDS		END
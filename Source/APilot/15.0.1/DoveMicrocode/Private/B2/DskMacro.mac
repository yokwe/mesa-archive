;{Stored as [Iris]<WMicro>Dove>DskMacro.mac;;  This section is to be removed before being released to anyone outside of Xerox.;  Any information about changes that is of general interest should be entered; as a comment after the copyright notice.;  Author:;	DEG;  Current owner:;	BKI;  Modification history:;	DEG		14-Oct-84 17:38:59	:created;	DEG		25-Oct-84 22:25:00	:edited;	DEG		 7-Dec-84 15:41:45	:edited;	DEG		 8-Jan-85 17:02:25	:edited;	DEG		 9-Jan-85 15:33:15	:changed name to DskMacro.mac from DskMacro.asm;	DEG		11-Jan-85 21:31:00	:when resetting disk there is no need to save command goToIdleLoop.;	DEG		20-Jan-85 19:38:04	:create CancelPreNotify.;	DEG		 2-Feb-85 17:28:32	:Remove CancelPreNotify and create SaveRegisters, RestoreRegisters, ContinueAtSystemLevel, TestForDiskDMAReset macros.;	DEG		20-Feb-85 16:36:37	:Create the macro;  AddByteOffsetToOpieAddress.  Note: this macro only works for byte and word ; addresses.  If a nil Opie address or a page opie address is passed in the wrong; thing will happen.;	DEG		21-Feb-85 14:37:10	:Create; KludgeEnableWatchDogging macro.;	DEG		21-Feb-85 18:53:32	:Fix; KludgeEnableWatchDogging macro.;	DEG		23-Feb-85 14:48:36	:Add Queue ; advancing macros.;	DEG		23-Feb-85 17:52:31	:Add macro for ; setting the disk retry count.;	DEG		23-Feb-85 20:09:39	:Second try at ; getting macro for disk retry count correct. ;	DEG		24-Feb-85 12:30:43	:Remove  ; WaitForSystem macro call from JamAndRestart. ;	DEG		25-Feb-85 13:55:57	:change timeout  ;	DEG		 3-Mar-85  0:24:11	:change Locked ; XCHG to Locked MOV and created the macro PostValueToLEDs. ;	DEG		 4-Mar-85 14:46:56	:fixed the ; SetDiskRetryCount so that the diskOperation is looked at. ;	DEG		 5-Mar-85 11:58:10	:Worry about the ; complementing of the DOB for setting the retry count. ;	DEG		 8-Mar-85  2:07:05	:Fix the Mesa ; queue advancing. ;	DEG		 5-Apr-85 14:00:47	:Make changes; as suggested during the handler code review of 1 April 1985. ;	JPM		16-Jul-85  8:57:49	:Opie redesign conversion;};--------------------------------------------------------------------------------;  This section is the definition of the Macros used by the rigid disk system.WordOrPageOpieAddressMask	EQU	20H	;00100000B%*DEFINE(AddByteOffsetToOpieAddress(byteOffset)) LOCAL ByteAddress (	%IF(%NES(%byteOffset,AX)) THEN (	MOV	AX, %byteOffset) FI	TEST	CH, WordOrPageOpieAddressMask	JZ	%ByteAddress	SHR	AX, 1%ByteAddress:	ADD	DX, AX	ADC	CL, 0		%'propogate the carry to the upper nybble.	)%*DEFINE(AdvanceIOPDiskQueue)(	PUSHF		;save the state of the interrupt enable flag.	CLI	MOV	AX, ES:[DI].diskNextLow	MOV	[BX].diskIOPNextLow, AX	MOV	AX, ES:[DI].diskNextHigh	MOV	[BX].diskIOPNextHigh, AX	POPF		;restore the state of the interrupt enable flag.	)%*DEFINE(AdvanceMesaDiskQueue) LOCAL LockedOp ExitOp (	PUSHA	ADD	BX, OFFSET diskMesaNext%LockedOp:	%MesaLockedOut(MOV,BX,ES:[DI].diskNextLow,diskFCB.diskLockMask)	OR	AX, AX	JNZ	%ExitOp	CMP	ES:[DI].diskNextLow, NILPtr	JNZ	%LockedOp%ExitOp:	POPA	)	%*DEFINE(ResetDisk)(	%Disable	(diskControllerInterrupt)	%Reset	(resetDiskController)	MOV	AL, goToIdleLoop	MOV	DX, DiskControllerCommandRegister	OUT	DX, AL	)%*DEFINE(ResetDiskDMA)(	%Disable	(diskDMAInterrupt)	%Reset	(resetDiskDMAController)	PUSH	DX	MOV	DX, DiskWrite2942CR2_CR0	MOV	AX, diskDMAMode	OUT	DX, AX	POP	DX	)%*DEFINE(RestoreRegisters)(	POP	ES	POPA	)%*DEFINE(PostValueToLEDs(value)) LOCAL Lbl0 (	%IF(%NES(%value,AX)) THEN (	MOV	AX, %value ) FI	TEST	ES:[DI].diskDataInfoRec, MASK diskUseLEDs	JZ	%Lbl0	OUT	90h, AX%Lbl0:	)	%*DEFINE(SaveDiskCommand(command))(      %IF(%NES(%command,AL)) THEN (	MOV	AL, %command ) FI	MOV	diskFCB.diskCommandRegister, AL	)%*DEFINE(SaveDiskStatus(status))(      %IF(%NES(%status,AL)) THEN (	MOV	AL, %status ) FI	MOV	diskFCB.diskStatusRegister, AL	)	%*DEFINE(SaveRegisters)(	PUSHA	PUSH	ES	)%*DEFINE(StartDiskDMA)(%'   Note: It does not matter what the contents of the AX register is.%' An OUT triggers the rigid disk DMA into action.	MOV	DX, DiskStartDMA	%DisableInterruptsTillNextWait	OUT	DX, AX			%'Start the Disk DMA.	)%*DEFINE(SetDiskRetryCount) LOCAL Lbl0 Lbl1 Lbl2 Lbl3 (%'divide by 128 since we should get ~200 pages/second%'bump by two so there is a minimum of one timeout and time for a seek.	PUSH	AX	TEST	ES:[DI].diskDataInfoRec, MASK complementDOB	JZ	%Lbl2	CMP	ES:[DI].diskOperationBlock.diskOperation, NOT RecalibrateDisk	JMP	SHORT %Lbl3%Lbl2:	CMP	ES:[DI].diskOperationBlock.diskOperation, RecalibrateDisk%Lbl3:	JNE	%Lbl0	MOV	AL, 20H		; allow time for a recalibrate to take place.	JMP	SHORT %Lbl1	%Lbl0:	MOV	AX, ES:[DI].diskPageCount	SHR	AX, 7		ADD	AX, 2		;one for a minimum and one for seek time, etc.	CMP	AH, 0	JZ	%Lbl1	XOR	AL, AL		;set count to zero for the maximum timeout	%Lbl1:	MOV	diskFCB.diskTaskRetryCount, AL	POP	AX	)%*DEFINE(TestForDiskDMAReset)(	MOV	DX, DiskDMAStatus	IN	AL, DX	AND	AL, DiskDMAStatusMask	CMP	AL, DiskDMAIsInResetState	)%*DEFINE(ContinueAtSystemLevel)(	%SaveRegisters	%WaitForSystem	%RestoreRegisters	)
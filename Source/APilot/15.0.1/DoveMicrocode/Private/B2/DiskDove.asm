$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);{Stored as [Iris]<WMicro>Dove>DiskDove.asm;;  This section is to be removed before being released to anyone outside of Xerox.;  Any information about changes that is of general interest should be entered; as a comment after the copyright notice.;  Author:;	DEG;  Current owner:;	BKI;  Modification history:;	DEG		23-Jul-84 16:10:24	:created from; Ev ETN  's original pseudo coding found in the I/O Software Architecture; document.;	DEG		12-Sep-84 19:51:58	:initial cut;	DEG		30-Sep-84 16:37:46	:Documentation and; pre-first run cleanup.;	DEG		 1-Oct-84 16:32:40	:Redefine Reset until I have correct masks.;	DEG		 1-Oct-84 18:28:32	:Correct OFFSET mumbles.;	DEG		 2-Oct-84 13:41:19	:add debugging stuff;	DEG		 2-Oct-84 19:34:58	:fix bug with segment register usage (EstablishIOPAccess);	DEG		 5-Oct-84 14:34:09	:fix bug having to do with DMA transfers.;	DEG		 8-Oct-84 15:45:24	:re-work client switching.;	DEG		 9-Oct-84  1:05:13	:seperate debugging stuff.;	DEG		11-Oct-84  2:50:34	:Use the real EstablishIOPAccess.;	DEG		13-Oct-84 19:14:48	:Use the real; Reset.  Make more robust.;	DEG		14-Oct-84  0:14:01	:Real Reset not yet working.;	DEG		14-Oct-84 23:59:52	:seperated out ; disk macros into DskMacro.asm.  Also fix problem with wild jump.;	DEG		15-Oct-84 21:30:14	:fix bug with; not saving registers across waits. ;	DEG		16-Oct-84 14:40:30	:WaitForSystem; between each IOCB.;	DEG		18-Oct-84  0:02:36	:Restart added.;	DEG		18-Oct-84 10:32:01	:Work on fine tuning.;	DEG		22-Oct-84 14:29:47	:Work on fine tuning.;	DEG		26-Oct-84  2:58:28	:edited;	DEG		10-Dec-84  1:56:37	:edited for Opie 17;	DEG		17-Dec-84  1:05:03	:edited to add ; capability to allow the client to turn on/off the complementing feature.;	DEG		20-Dec-84  9:36:20	:hopefully fix DMA FIFO not empty problem. ;	DEG		 8-Jan-85 15:03:24	:added the procedure ResetDiskDMAHardware and assembled with the new version of the disk macros. ;	DEG		 9-Jan-85 15:32:19	:update to reflect name changes in the include names. ;	DEG		12-Jan-85  0:10:32	:add label for debugging ease.; and reworked ResetDiskDMAHardware. ;	DEG		13-Jan-85  0:49:24	:add synchronization for resetting DMA task.;	DEG		13-Jan-85  2:30:55	:Put in some tests to isolate suspected DMA problems.;	DEG		14-Jan-85  2:39:05	:Add HNH   for EEPROM data.;	DEG		14-Jan-85 23:04:01	:edited.;	DEG		15-Jan-85 23:21:04	:removed naming contention problem.;	DEG		16-Jan-85 13:17:38	:add hook for testing with etch 2 board.;	DEG		18-Jan-85 23:54:46	:edited.;	DEG		22-Jan-85  6:14:09	:provide synchronization between tasks when restarting DMA task.;	DEG		 2-Feb-85 17:33:42	:use the new disk macro ContinueAtSystemLevel in numerous places where WaitForSystemLevel was used.;  This has the added code to save and restore the general purpose registers and the ES register.;  Ths fixes a problem with ES not being saved when necessary.;	DEG		 3-Feb-85 22:07:09	:save and restore ; ES around the WaitForCondition macro calls.;	DEG		 4-Feb-85  5:39:06	:Add code to ; handle request to stop on completion of operation.  If client requests a stop do ; not update the queue. ;	DEG		 6-Feb-85  6:33:50	:Remove bogus ; code having to do with timing out on Formats and Recalibrate commands. ;	DEG		11-Feb-85 16:18:27	:Add kludgery to; JamDiskTasks to allow the client to recover from errors more readily. ;	DEG		14-Feb-85  5:10:00	:Replace kludgery; with a proper solution and fixit so that DiskTaskRestartSelf also goes through; the MarkMajorDiskErrorCompletion code. ;	DEG		20-Feb-85 16:39:02	:Use the newly; created AddByteOffsetToOpieAddress macro to properly handle both word and byte; Opie addresses.;	DEG		21-Feb-85 14:43:44	:Save and restore ; ES in the DiskDMATask.  Also use newly created KludgeEnableWatchDogging macro; to get around problem with watchdogging in Opie until Opie 18/19?;	DEG		21-Feb-85 18:55:19	:Modify for fix  ; in KludgeEnableWatchDogging macro;	DEG		22-Feb-85 20:24:34	:Remove the; WaitForSystem call from the JamDiskTasks and fix the 0938 hang.;	DEG		23-Feb-85 14:37:55	:Cleanup code and ; fix minor bugs.;	DEG		23-Feb-85 19:33:00	:Add variable ; timeout feature. ;	DEG		24-Feb-85 17:09:53	:Fix error  ; in DoCommand where it was possible to reset the DMA FIFO before finishing a ; good sector transfer.. ;	DEG		24-Feb-85 19:25:01	:Fix error  ; in OPIE by saving and restoring SI from the trouble proc. ;	DEG		25-Feb-85 11:46:03	:Comment out  ; code in trouble proc because OPIE is broken. ;	DEG		25-Feb-85 18:01:31	:reset certain;  booleans when test has been completed.;	DEG		25-Feb-85 18:49:49	:use EEPDefs;  for the EEPROM reads.;	DEG		27-Feb-85 19:28:30	:correct problem ;  with temp kludge.;	DEG		28-Feb-85 12:10:23	:fix problem with; improperly incrementing addresses that may be byte addresses.;	DEG		 2-Mar-85 23:18:19	:Add code to ; display numbers in LEDs.;	DEG		 4-Mar-85  2:36:15	:Keep track of ; the present cylinder.;	DEG		 8-Mar-85  0:56:31	:Narrow the ; window of vunerability between when the IOP marks an operation complete and; it either stops or continues with the next IOCB and the Mesa world begins; processing the IOCB.;	DEG		27-Mar-85  2:36:20	:fix the; condition of two conditional jumps as spotted by Brian BKI   .  Also INCLUDE; Disk.def instead of DskIOFce.def.;	DEG		 4-Apr-85 11:59:23	:Undo the second ; conditional jump change.;	DEG		 4-Apr-85 17:02:43	:Make changes ; suggested by the code review of 1 April 1985.;	DEG		 6-Apr-85  1:52:48	:Make more ; changes as suggested by the code review of 1 April 1985.;	DEG		 8-Apr-85 11:28:04	:Make more ; changes as suggested by the code review of 1 April 1985.;	BKI		 9-Apr-85 14:59:21	:Convert to Opie 19A (watchdog timeout in context).  Unexpected interrupts increment a counter and return.;	DEG		16-Apr-85 11:24:49	:rework synchronization.;	BKI		 9-May-85 15:05:02	:remove diskHandlerStoppedFor*;	BKI		10-May-85 20:32:30	:rework major error handling;	BKI		13-May-85 17:44:07	:fix bug in dma/ctlr task synch;	BKI		14-May-85 14:48:52	:Modify DMA task to check for controller error type and dma error type instead of disk error.;	BKI		15-May-85 16:23:57	:more dma/ctlr task synch;	BKI		 7-Jun-85 19:37:56	:B0 version;	JPM		16-Jul-85  9:18:58	:Opie redesign conversion;	BKI		16-Jul-85 11:04:47	:serialize xfer of DOB;	JPM		22-Jul-85 14:10:03	:Change IOPEInROM alignment to WORD, fixed bug introduced by NotifyCondition now using CX;	BKI		 1-Aug-85 15:11:59	:eeprom validity support;}; Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.; The following program was created in 1984 but has not been published within the; meaning of the copyright law, is furnished under license, and may not be used,; copied and/or disclosed except in accordance with the terms of said license.;--------------------------------------------------------------------------------	NAME	DiskTask $INCLUDE(Disk.def)$NOLIST$INCLUDE(IOPMacro.asm)$INCLUDE(DskMacro.mac)$LIST;--------------------------------------------------------------------------------;   This module ([Iris]<WMicro>Dove>DiskDove.asm) is the IOP code which handles ; the rigid disk sub-system.  It is a Handler as described by the I/O Software; Architecture document.;;   The rigid disk handler is composed of two tasks.  An IOP task could be thought; of as an equivalent of a Mesa PROCESS.  The first of the two tasks implemented; by this handler is essentially the disk system task (DiskTask).  The second; task is for control of the disk DMA (DiskDMATask).EXTRN DiskHandlerID:ABSEXTRN diskControllerInterrupt:ABSEXTRN diskDMAInterrupt:ABSDiskIOR		SEGMENT	COMMONEXTRN diskFCB:DiskFCBRecordDiskIOR		ENDSDiskSTK		SEGMENT	COMMONEXTRN DiskStack:WORDEXTRN DiskDMAStack:WORDDiskSTK		ENDSPUBLIC	DiskInitPUBLIC	DiskBadInterruptPUBLIC	DiskDMABadInterruptIOPEInROM 	SEGMENT	WORD PUBLIC	ASSUME CS: IOPEInROM	; *******************************************************************************;   This section provides the FAR PROCedures which are called by OPIE.; *******************************************************************************;   In the event that we receive an illegal or unexpected interrupt from the ; rigid disk controller (the 8x305 processor) the PROCedure DiskBadInterrupt will; be called.DiskBadInterrupt	PROC	FARUnexpectedDiskInterrupt:;   Note: Unexpected interrupts are not associated with IOCBs.  Hence, there is; no obvious way of reporting unexpected interrupts to the handler client.; The most attractive solution is to count the number of unexpected interrupts; and then put this count into the next IOCB we service.; WE NEED TO FIND A PLACE TO RESET THIS COUNTER WHEN IT GETS PLACED IN THE IOCB.	%EstablishHandlerAccess	(DiskHandlerID)	ASSUME	ES:DiskIOR	INC	diskFCB.unexpectedDiskInterruptCount	RET	ASSUME	ES:NOTHINGDiskBadInterrupt	ENDP;   In the event that we receive an illegal or unexpected interrupt from the ; rigid disk DMA controller the PROCedure DiskDMABadInterrupt will be called.DiskDMABadInterrupt	PROC	FARUnexpectedDiskDMAInterrupt:;   Note: Unexpected interrupts are not associated with IOCBs.  Hence, there is; no obvious way of reporting unexpected interrupts to the handler client.; The most attractive solution is to count the number of unexpected interrupts; and then put this count into the next IOCB we service.; WE NEED TO FIND A PLACE TO RESET THIS COUNTER WHEN IT GETS PLACED IN THE IOCB.	%EstablishHandlerAccess	(DiskHandlerID)	ASSUME	ES:DiskIOR	INC	diskFCB.unexpectedDiskDMAInterruptCount	RET	ASSUME	ES:NOTHINGDiskDMABadInterrupt	ENDP; -------------------------------------------------------------------------------;   DiskInit is the PROCedure that gets called to (re-)initialize the IOP software; for the disk.  The disk IOP software will then (re-)initialize the hardware to ; its initial state.;;   Since the DiskInit PROCedure will be used for re-initialization as well as for; initialization purposes we specifically disable the the interrupts for the disk; DMA and the disk controller hardware.;;   Initialization of the tasks is done by using the system (Opie) provided macro; InitializeTask.DiskInit	PROC	FAR	;initializationDiskInitEntry:	%Disable		(diskDMAInterrupt)	%Disable		(diskControllerInterrupt)	%InitializeTask		(DiskHandlerID,OFFSET diskFCB.diskDMATask,DiskDMATaskInit,OFFSET DiskDMAStack)	%InitializeTask		(DiskHandlerID,OFFSET diskFCB.diskTask,DiskTaskInit,OFFSET DiskStack)	RETDiskInit	ENDP; *******************************************************************************		ASSUME	DS:DiskIOR	;for all following code; *******************************************************************************;   This section provides the local (NEAR) PROCedures which provide common disk; subroutines used internally by the disk handler.; *******************************************************************************;   DoDiskCommand;     PURPOSE;	  The purpose of the DoDiskCommand is to issue a disk command to the disk;	controller.  This procedure also sets the handler operation field (;	diskCommand) to the current operation being requested to the disk controller;	and the direction of the data flow.  It notifies the disk DMA task that;	there is work to be done.  It issues the command to the disk controller to;	carry out the operation and waits for completion of the command.  At;	command completion a check is made to check to see if the operation was a;	success or not.  If the operation was not successful the fact is so ;	indicated in the appropriate status fields in the IOCB and is reported;	to the caller through the carry flag.;     ENTRY STATE;	AL  contains the direction of the data flow (eg. memoryToFIFO);	AH  contains the type of operation (eg. xferDOBToController);	BX  points to the drive in use. ;     EXIT STATE ;	Flags are affected.;	All other register values unchanged.;	The carry flag is set if an error has been detected otherwise it is cleared.;     RE-ENTRANCY;	  DoDiskCommand is not re-entrant due to the presence of the OUT instructions.;BEGIN DEBUG CODEDiskBadNews:	JMP	$;END DEBUG CODEDoDiskCommand		PROC	NEARDoDiskCommandEntry:	PUSH	AX	PUSH	DX	PUSH	BX	DiskSetRetryCount:	%'SetDiskRetryCount	DoDiskCommandStart:;BEGIN DEBUG CODE	PUSH	AX	MOV	DX, DiskControllerStatusRegister	IN	AL, DX	CMP	AH, AL	JE	DiskBadNews	CMP	diskFCB.diskConditionDMADone, 0	JNE	DiskBadNews	MOV	DX, DiskDMAStatus	IN	AL, DX	TEST	AL, MASK diskDMAErrorBit	JNZ	DiskBadNews	TEST	AL, MASK diskDMAFIFOEmptyBar	JNZ	DiskBadNews	POP	AX;END DEBUG CODE	MOV	WORD PTR ES:[DI].controllerErrorType, 0	MOV	[BX].diskCommand, AH	CMP	AL, noDataXfer	JE	StartDiskController	MOV	DX, DiskDMADirectionSetDiskDMADirection:	OUT	DX, AL		;Set the direction of the disk DMA transfer.;	MOV	[BX].diskSpare0, AL	;eventually, change to dmaDirection	CMP	AH, xferDOBFromController	JE	StartDiskController	CMP	AH, xferDOBToController	JE	NotifyDMAWork	%NotifyCondition	(OFFSET diskFCB.diskConditionDMAWork)	%ContinueAtSystemLevel;   The next section of code through WaitForInterrupt is the code used to issue; the command which causes the rigid disk controller to do its job.StartDiskController:	PUSH	AX	%SaveDiskCommand(AH)	MOV	DX, DiskControllerCommandRegister	%SaveRegistersIssueDiskCommand:	%DisableInterruptsTillNextWait	OUT	DX, AL	%WaitForInterrupt	(5)	;time out after 5 seconds; Determine if the interrupt timed out.  If it did, reset the disk controller.	%RestoreRegisters		;doesn't affect the carry flag	JC	HandleControllerTimeoutDiskInterruptReceived:;   Upon being interrupted the code checks to see if the disk controller has; reported any errors.	MOV	DX, DiskControllerStatusRegister	IN	AL, DXDiskStatusFetched:	%SaveDiskStatus(AL)	TEST	AL, statusRegisterErrorBit	JZ	SynchronizeDMATask	MOV	ES:[DI].controllerErrorType, diskControllerErrorSynchronizeDMATask:	POP	AX	;get command and transfer direction back into AX.	CMP	AL, noDataXfer	JE	SetDiskError	CMP	AH, xferDOBToController	JE	CheckFIFOEmpty	CMP	AH, xferDOBFromController	JNE	WaitDMADone	CMP	ES:[DI].controllerErrorType, 0	JNE	SetDiskErrorNotifyDMAWork:	%NotifyCondition	(OFFSET diskFCB.diskConditionDMAWork)WaitDMADone:	%SaveRegisters	%WaitForCondition	(OFFSET diskFCB.diskConditionDMADone,1000)	%RestoreRegisters	JNC	CheckDMAStatus	MOV	ES:[DI].dmaErrorType, diskInterruptTimeoutCheckDMAStatus:	CMP	ES:[DI].dmaErrorType, 0	JNE	ResetDiskDMAHardware	CMP	AH, xferDOBToController	JE	StartDiskControllerCheckFIFOEmpty:	MOV	DX, DiskDMAStatus	IN	AL, DX	MOV	diskFCB.diskDMAStatusRegister, AL	TEST	AL, MASK diskDMAFIFOEmptyBar	JNZ	HandleDMAErrorSetDiskError:	CMP	WORD PTR ES:[DI].controllerErrorType, 0	CLC	JE	DiskDoCommandExit	MOV	ES:[DI].diskError, True	STCDiskDoCommandExit:	POP	BX	POP	DX	POP	AX	RETHandleControllerTimeout:	%ResetDisk	%Enable	(diskControllerInterrupt)	MOV	ES:[DI].controllerErrorType, diskInterruptTimeout	JMP	SynchronizeDMATaskHandleDMAError:	MOV	ES:[DI].dmaErrorType, fifoNotEmptyResetDiskDMAHardware:	%ResetDiskDMA	CMP	ES:[DI].dmaErrorType, diskInterruptTimeout	JNE	DMATaskIsSynchronized	%SaveRegisters	%Restart	(DiskHandlerID,OFFSET diskFCB.diskDMATask,DiskDMAWaitForWork,OFFSET DiskDMAStack);To make sure diskConditionDMADone isn't pre-notified	%WaitForCondition	(OFFSET diskFCB.diskConditionDMADone,1)	%RestoreRegistersDMATaskIsSynchronized:	%Enable	(diskDMAInterrupt)	JMP	SetDiskErrorDoDiskCommand		ENDP; -------------------------------------------------------------------------------;   DoDiskDMA;     PURPOSE;         DoDiskDMA is a PROCedure which allows the code that is necessary;	for initiating a rigid disk DMA operation in a single location.  The;	process of initiating a disk DMA operation is not as straight-foward;	as one might desire.  Therefore, it is all the more important that the;	major section of this code is in a single location.;     ENTRY STATE;	CX & DX  contain the mesa virtual address of the data to be placed in the;	         the FIFO or the address to where the data from the FIFO will be;		 transferred.;	AX	 negative word size of the transfer MODULO 256 words (1 page, ;		 512 bytes).;     EXIT STATE;	Flags are affected.;	All other register values unchanged.;     RE-ENTRANCY;	DoDiskDMA is not re-entrant due to the presence of IN instructions.DoDiskDMA		PROC	NEARDoDiskDMAEntry:	%SaveRegisters		PUSH	AX		%ConvertAddress	(CX-DX)diskCVA:	MOV	AX, DX	MOV	DX, DiskDMAAddressWordOffset	OUT	DX, AX		MOV	AL, AH	MOV	AH, CL		MOV	DX, DiskDMAAddressPageSetDiskDMAPageAddress:	OUT	DX, AX		POP	AX	MOV	DX, DiskWriteDMAWordCountSetDiskDMAWordCount:	OUT	DX, AX		%StartDiskDMA		PUSH	DI	%WaitForInterrupt	()	;no timeout	POP	DIDiskDMAIntReceived:	MOV	DX, DiskDMAStatus	IN	AL, DX	AND	AL, (MASK diskDMAEndOfXferBar OR MASK diskDMARunStateMachBar OR MASK diskDMAErrorBit)	JZ	EndDiskDMAXfer	MOV	ES:[DI].dmaErrorType, diskDMAErrorEndDiskDMAXfer:		%RestoreRegisters      	RETDoDiskDMA		ENDP; *******************************************************************************; *******************************************************************************;	This next section provides jump tables used later in the code.; *******************************************************************************	;   DiskSetDrive is a jump table used to setup for the given time.DiskSetDrive	DW	SetDiskRD0Mesa		DW	SetDiskRD0IOP		DW	SetDiskRD1Mesa		DW	SetDiskRD1IOP;   DiskNotifyClient is a jump table used to point to the correct code to notify ; the appropriate client.DiskNotifyClient	DW	DiskNotifyMesaClient			DW	DiskNotifyIOPClientDiskUpdateNext		DW	DiskUpdateMesaNext			DW	DiskUpdateIOPNext; *******************************************************************************;	The DiskTask mainline code follows..; *******************************************************************************;   The disk task is entered at DiskTaskInit where some initialization is ; performed.  The initialization is a series of steps.  The first step is to; invoke the system (Opie) macro Reset to reset the disk sub-system hardware.; the second step is to initialize the task data by invoking the system (Opie); macro ThisTaskServices.  The third step is to establish the mechanism for; linking the clients (Mesa, booting, etc.) with the disk handler in terms of; doing down notifies (ie. notifies to the disk handler).  This step is done by; setting up the work mask by invoking the system (Opie) macro GetWorkMaskForCondition; and placing the obtained work mask in the FCB.  The next series of actions is; to set the operation queues for both drives and both clients to NIL.  The final; action of initialization is to set the handler's state to normalDiskHandlerState and then; enable the interrupt from the disk controller by invoking the system (Opie) ; macro Enable.  After completing the initialization, the IOP continues into the; disk's system loop at DiskWaitForWork.DiskTaskInit:	%ThisTaskServices	(diskControllerInterrupt,DiskBadInterrupt)		MOV	diskFCB.diskHandlerState, initialStartDiskDMATask	%GetWorkMaskForCondition	(OFFSET diskFCB.diskConditionWork)	MOV	diskFCB.diskWorkMask, AX	;The work mask for down notifications.		%GetLockMask	MOV	diskFCB.diskLockMask, AX		MOV	AX, NILPtr		; Go on the assumption that NILOpieAddr(x)					;has value equal to NILPtr.		MOV	diskFCB.rd0.diskMesaNext, AX		;diskMesaNext ¬ NILPtr	MOV	diskFCB.rd1.diskMesaNext, AX		;diskMesaNext ¬ NILPtr		MOV	diskFCB.rd0.diskIOPNextHigh, AX		;diskIOPNextHigh ¬ NILOpieAddrHigh	MOV	diskFCB.rd0.diskIOPNextLow, AX		;diskIOPNextLow ¬ NILOpieAddrLow	MOV	diskFCB.rd1.diskIOPNextHigh, AX		;diskIOPNextHigh ¬ NILOpieAddrHigh	MOV	diskFCB.rd1.diskIOPNextLow, AX		;diskIOPNextLow ¬ NILOpieAddrLow	MOV	diskFCB.diskHandlerState, normalDiskHandlerStateReadDiskEEPROMValues:	%ReadEEProm(eePromRigidType,1)	JNC	SetDiskDriveType	MOV	AL, 0SetDiskDriveType:	MOV	diskFCB.rd0.diskDriveType, AL	MOV	diskFCB.rd1.diskDriveType, AL	%ReadEEProm(eePromRigidSctPerTrk,1)	JNC	SetDiskSectorsPerTrack	MOV	AL, 16SetDiskSectorsPerTrack:	MOV	diskFCB.rd0.diskSectorsPerTrack, AL	MOV	diskFCB.rd1.diskSectorsPerTrack, AL	%ReadEEProm(eePromRigidHdPerCyl,1)	JNC	SetDiskHeadsPerCylinder	MOV	AL, 4SetDiskHeadsPerCylinder:	MOV	diskFCB.rd0.diskHeadsPerCylinder, AL		MOV	diskFCB.rd1.diskHeadsPerCylinder, AL	%ReadEEProm(eePromRigidCylCt,1)	JNC	SetDiskCylindersPerDrive	MOV	AX, 305SetDiskCylindersPerDrive:	MOV	diskFCB.rd0.diskCylindersPerDrive, AX	MOV	diskFCB.rd1.diskCylindersPerDrive, AX	%ReadEEProm(eePromRigidRWC,1)	JNC	SetDiskRWC	MOV	AX, 0FFFFhSetDiskRWC:	MOV	diskFCB.rd0.diskReducedWriteCurrentCylinder, AX	MOV	diskFCB.rd1.diskReducedWriteCurrentCylinder, AX	%ReadEEProm(eePromRigidPCC,1)	JNC	SetDiskPCC	MOV	AX, 128SetDiskPCC:	MOV	diskFCB.rd0.diskPreCompensationCylinder, AX	MOV	diskFCB.rd1.diskPreCompensationCylinder, AX		MOV	AX, FALSE	MOV	diskFCB.diskMesaCleanupRequest, AX	MOV	diskFCB.diskIOPCleanupRequest, AX	MOV	diskFCB.diskHandlerStoppedForMesa, AX	MOV	diskFCB.diskHandlerStoppedForIOP, AX			%ResetDisk	%Enable	(diskControllerInterrupt);   Note: we do not expect interrupts until the handler has started I/O operations; in response to notification.	MOV	AX, lastDriveClient OR (numPossibleDiskClients SHL 8)	MOV	diskFCB.diskCurrentClient, AL	MOV	diskFCB.diskLastDriveMask, AL		MOV	diskFCB.diskNumPossibleClients, AH	MOV	diskFCB.diskClientsToTest, AH;   The disk task is essentially an endless loop which cycles between queues of ; work.  DiskWaitForWork is the entry point into the loop when everything is ; in a quiescent state (ie. everything has just been initialized or when there is; no work to do).  Upon reaching this point in the code the variables used to ; maintain state about what client to handle next are set to their initial values.; The code then goes to sleep until it is notified that it has something to do.;   The BOOLEAN variable diskHandlerStopped is used to indicate whether or not the; disk handler is currently running (FALSE) or is waiting for work (TRUE).;   The ENUMERATED variable diskCurrentClient can take on one of eight values: ; {drive0MesaClient, drive0IOPClient, drive1MesaClient, drive1IOPClient,;  drive2MesaClient, drive2IOPClient, drive3MesaClient, drive3IOPClient}; In the present system the enumeration only uses the first two values since there; is only one drive in the system.; The enumeration is treated as a circular definition, ie. the SUCCessor of drive3IOPClient; is drive0MesaClient and the PREDecessor of drive0MesaClient is drive3IOPClient.; diskCurrentClient is initially set to drive1IOPClient since it is incremented ; then tested for a client.  The purpose of diskClientsToTest (which is a ; CARDINAL with the sub-range [0..numDiskClients] is to enumerate all the clients; to check if there is outstanding work to be done.  When there is no longer any; work to do the task falls to sleep waiting on the condition diskFCB.diskConditionWork.;  The next time the disk task has work to do it will begin enumerating starting; with a check to see if the Mesa client on Drive 0 (RD0) has work to do.;   The Mesa code approximating the disk task is:;;   InitializeDiskTask[];;   diskCurrentClient ¬ lastDriveClient;;   DO;     diskHandlerStopped ¬ TRUE;;     WAIT diskConditionWaitForWork;;     DO;	diskClientsToTest ¬ numDiskClients;;       UNTIL diskClientsToTest = 0 DO;	  diskCurrentClient ¬ SUCC[diskCurrentClient];;         IF WorkToDo[diskCurrentClient] THEN EXIT;;         REPEAT;	    FINISHED => GOTO waitForWork;  << This GOTO exits to the outermost DO ; since we are finished with the WHILE and there was no work to do. >>;       ENDLOOP;;       DoWork[diskCurrentClient];;	EXITS;	  waitForWork => diskCurrentClient ¬ drive1IOPClient;  ;     ENDLOOP;;   ENDLOOP;;DiskWaitForWork:	%WaitForCondition	(OFFSET diskFCB.diskConditionWork,noTimeout)	;   Upon waking the code will check to see if a Cleanup Request is being made.  ; If a clean up request is being made continue to loop until request is no longer; being made.DiskCheckForMesaCleanupRequest:	MOV	diskFCB.diskHandlerStoppedForMesaCleanup, FALSE	CMP	diskFCB.diskMesaCleanupRequest, FALSE	JE	DiskCheckForIOPCleanupRequestDiskSetHandlerStoppedForMesaCleanup:	MOV	diskFCB.diskHandlerStoppedForMesaCleanup, TRUE	JMP	SHORT DiskWaitForWorkDiskCheckForIOPCleanupRequest:	MOV	diskFCB.diskHandlerStoppedForIOPCleanup, FALSE	CMP	diskFCB.diskIOPCleanupRequest, FALSE	JE	DiskCheckForMesaRunningDiskSetHandlerStoppedForIOPCleanup:	MOV	diskFCB.diskHandlerStoppedForIOPCleanup, TRUE	JMP	SHORT DiskWaitForWorkDiskCheckForMesaRunning:;	CMP	diskFCB.diskHandlerStoppedForMesa, FALSE;	JE	DiskCheckForIOPRunning	CMP	diskFCB.diskStartHandlerForMesa, TRUE	JE	DiskCheckForWorkToDo;	MOV	AX, FALSE;	MOV	diskFCB.diskStartHandlerForMesa, AX;	MOV	diskFCB.diskHandlerStoppedForMesa, AXDiskCheckForIOPRunning:;	CMP	diskFCB.diskHandlerStoppedForIOP, FALSE;	JE	DiskCheckForWorkToDo	CMP	diskFCB.diskStartHandlerForIOP, TRUE	JNE	DiskWaitForWork;	MOV	AX, FALSE;	MOV	diskFCB.diskStartHandlerForIOP, AX;	MOV	diskFCB.diskHandlerStoppedForIOP, AXDiskCheckForWorkToDo:;   When the disk handler is awaken and there is no pending request for it to stop; the handler then has to choose from which queue it will execute its next command.; The decision upon which queue to select the next command is driven by the state; of the variables diskCurrentClient and diskClientsToTest (described above).;;   The code has been optomized in favor of the Mesa client.DiskAnyWork:	XOR	CH, CH	MOV	CL, diskFCB.diskClientsToTest	XOR	AH, AH	MOV	AL, diskFCB.diskCurrentClient	MOV	DL, diskFCB.diskLastDriveMaskDiskFindClient:	ADD	AL, wordSize	AND	AL, DL	MOV	BP, AX	JMP	DiskSetDrive[BP]SetDiskRD1IOP:	MOV	BX, OFFSET diskFCB.rd1	JMP	DiskTestWorkIOPClientSetDiskRD1Mesa:	MOV	BX, OFFSET diskFCB.rd1	JMP	DiskTestWorkMesaClientSetDiskRD0IOP:	MOV	BX, OFFSET diskFCB.rd0;   The test has indicated that it is the IOP client's turn to run.  Therefore, ; the code has fallen through to DiskTestWorkIOPClient.  DiskTestWorkIOPClient; does a check to see if there is any work to do.  If there is no IOP client work ; the code branches to DiskContinueCheck, otherwise it falls through to DiskIOPWork.  DiskTestWorkIOPClient:;	CMP	[BX].diskIOPNextLow, NILOpieAddressLow;	JNE	DiskIOPWork	CMP	[BX].diskIOPNextHigh, NILOpieAddressHigh	JNE	DiskIOPWork	LOOP	DiskFindClient	JMP	SHORT DiskNoWork;   The disk handler has determined that there is work to do for the IOP client; so now it sets up the pointer to the IOCB and transfers control to the code; that will carry out the indicated task.DiskIOPWork:	MOV	BP, diskIOPClient	MOV	CX, [BX].diskIOPNextHigh	MOV	DX, [BX].diskIOPNextLow	JMP	SHORT DiskDoIOCBSetDiskRD0Mesa:	MOV	BX, OFFSET diskFCB.rd0	;   At DiskTestWorkMesaClient the disk handler knows that it should check for work; on the Mesa client's queue.  If there is no work to do transfer is passed to; DiskContinueCheck.  Otherwise, control falls through to DiskMesaWork.DiskTestWorkMesaClient:	CMP	[BX].diskMesaNext, NILPtr	JNE	DiskMesaWork	LOOP	DiskFindClient;   None of the clients had any work to do; therefore, the code will set up to; be biased to begin searching with drive0MesaClient (SUCC[drive1IOPClient]) the; next time diskFCB.diskConditionWork is notified.DiskNoWork:	MOV	diskFCB.diskCurrentClient, lastDriveClient	JMP	SHORT DiskWaitForWork		;   The disk handler has determined that there is work to do for the Mesa client; so now it sets up the pointer to the IOCB and falls through to the code that; will carry out the indicated task.DiskMesaWork:	MOV	BP, diskMesaClient	MOV	CX, mesaShortPtrOpieAddressType	MOV	DX, [BX].diskMesaNext	;   At DiskDoIOCB the situation is that there is some work to do and the handler; has commited to doing the operation for the chosen client.  At this point in the; code, the CX and DX registers contain the OpieAddress for the IOCB to be acted; upon.   The code then sets up access to the memory which contains the IOCB.DiskDoIOCB:	MOV	diskFCB.diskCurrentClient, AL	MOV	diskFCB.diskCurrentDrivePtr, BX	MOV	[BX].diskCurrentIOCBHigh, CX	MOV	[BX].diskCurrentIOCBLow, DX		%EstablishIOPAccess	(diskMapRegister,CX-DX)DiskIOCBAccessEstablished:		MOV	ES:[DI].diskInProgress, TRUE	; indicate that the operation is now in progress.		;   Set up to indicate no error has occurred.	MOV	AX, FALSE	MOV	ES:[DI].diskError, AL	MOV	ES:[DI].diskOperationBlockError, AL;   Read the DiskControllerStatusRegister and check to make sure that the; rigid disk controller is in the idle state.	MOV	DX, DiskControllerStatusRegister	IN	AL, DXInitialDiskStatusFetched:	%SaveDiskStatus(AL)	CMP	AL, inIdleLoop	JE	DiskContinue0	MOV	ES:[DI].controllerErrorType, controllerNotInIdleLoop	MOV	ES:[DI].diskError, True	PUSH	BX	%ResetDisk	%Enable	(diskControllerInterrupt)	POP	BX	JMP	DiskErrorUpdate	;   DiskContinue0 gets reached when the Disk controller is in the idle state and the; disk handler has an IOCB to act upon.  If the client is trying to recover from; a jammed state or if the diagnostic wants status information the BOOLEAN; diskOnlyDOBFromController will be set to TRUE.  If this BOOLEAN is TRUE the ; disk handler will only fetch the disk operation block (DOB) from the controller.DiskContinue0:	CMP	ES:[DI].diskOnlyDOBFromController, FALSE	JNE	DiskDOBFromController	;   At DiskDOBToController the disk handler has commited to transferring the DOB; from main memory to the disk controller through the FIFO.  The disk handler ; first leaves the status that it is doing a transfer of the DOB to the disk; controller.  It then sets up the DMA operation as a memoryToFIFO operation.DiskDOBToController:;   Prepare to transfer DOB to the disk controller.	MOV	AH, xferDOBToController	MOV	AL, memoryToFIFO		CALL	DoDiskCommandDiskDOBSentToRDC:	JNC	DiskExecuteDOB	; If no error occured proceed to execute operation.	;   If an error has occured while transferring the DOB to the controller, we; immediately notify the client.  Note that we do not try to transfer the DOB; back from the controller.	MOV	ES:[DI].diskOperationBlockError, TRUE	JMP	SHORT SendDiskControllerToIdleMode;   At DiskExecuteDOB the next phase of the operation is to be carried out.  To; this point the DOB has been transfered to the disk controller successfully.  Now; the operation needs to be carried out.  At this point the handler indicates that; it is going to execute the operation.  It then notifies the disk DMA task that; there is work to be done.  Then a check is made to find out which way the data; flow is for the current operation.  If the operation is a read operation a quick; change must be done on the direction of the disk FIFO (note: no change need be ; made on a write operation since the direction is already memoryToFIFO).DiskExecuteDOB:	;   Prepare to transfer DOB to the disk controller.	MOV	AH, executeDOB	TEST	ES:[DI].diskDataInfoRec, MASK diskHalt	JZ	DiskNoHalt	OR	AH, MASK crStopBitDiskNoHalt:	TEST	ES:[DI].diskDataInfoRec, MASK diagDiskCmd	JZ	DiskNotDiagCmd	OR	AH, MASK crDiagModeDiskNotDiagCmd:	MOV	AL, noDataXfer	CMP	ES:[DI].diskDataXferDirection, noDataOp	JE	DoDiskOperation		MOV	AL, fifoToMemory	CMP	ES:[DI].diskDataXferDirection, read	JE	DoDiskOperation	MOV	AL, memoryToFIFO	CMP	ES:[DI].diskDataXferDirection, write	JE	DoDiskOperationDoDiskOperation:	CALL	DoDiskCommand	MOV	DX, WORD PTR ES:[DI].controllerErrorType;   DiskDOBFromController is the entry point in the code for fetching the DOB; from the controller into main memory.  At this point the disk handler is; entering the final phase of the operation.  In this phase the disk handler; fetches the disk operation block (DOB) from the disk controller.  The DOB is; where the status information is contained.DiskDOBFromController:;   At this point in the code the handler knows for sure that the disk DMA task ; should be responsive.  Therefore, the disk handler can proceed with transfering; the DOB from the controller to memory.  To do this the code first updates the; handler operation state information.	MOV	AH, xferDOBFromController	MOV	AL, fifoToMemory		CALL	DoDiskCommandDiskDOBFetchedFromRDC:	JNC	DOBFetched	MOV	ES:[DI].diskOperationBlockError, TRUE	JMP	SendDiskControllerToIdleModeDOBFetched:	MOV	WORD PTR ES:[DI].controllerErrorType, DXSendDiskControllerToIdleMode:	%SaveDiskCommand(goToIdleLoop)	MOV	DX, DiskControllerCommandRegister	OUT	DX, ALSetDiskErrorIfOnlyDOBFetched:	CMP	ES:[DI].diskOnlyDOBFromController, FALSE	JE	RDCGoesToIdleWhileHandlerPreparesForNextOperation	MOV	ES:[DI].diskOnlyDOBFromController, FALSE	MOV	ES:[DI].diskError, TRUE	RDCGoesToIdleWhileHandlerPreparesForNextOperation:	CMP	ES:[DI].diskError, TRUE	JE	DiskErrorUpdate	CMP	ES:[DI].diskStopHandlerOnCompletion, TRUE	JE	DiskErrorUpdate	MOV	AX, TRUE	JMP	DiskUpdateNext[BP]DiskErrorUpdate:	MOV	AL, diskFCB.diskCurrentClient	SUB	AL, wordSize	AND	AL, diskFCB.diskLastDriveMask	MOV	diskFCB.diskCurrentClient, AL	MOV	AX, FALSE	JMP	DiskUpdateNext[BP]DiskUpdateIOPNext:	MOV	diskFCB.diskStartHandlerForIOP, AX	CMP	AX, FALSE	JE	SetForDiskWaitForWork	%AdvanceIOPDiskQueue	JMP	SHORT SetForDiskYieldDiskUpdateMesaNext:	MOV	diskFCB.diskStartHandlerForMesa, AX	CMP	AX, FALSE	JE	SetForDiskWaitForWork	%AdvanceMesaDiskQueueSetForDiskYield:	MOV	CX, OFFSET DiskYield	JMP	SHORT DiskIOFinishedSetForDiskWaitForWork:	MOV	CX, OFFSET DiskWaitForWorkDiskIOFinished:	MOV	ES:[DI].diskInProgress, FALSE	PUSH	CX			;Push return address onto stack	JMP	DiskNotifyClient[BP]	;This will cause the appropriate client to be notified.DiskNotifyIOPClient:	%NotifyClientCondition	([BX].diskIOPClientCondition)	JMP	SHORT DiskFinishNotifyDiskNotifyMesaClient:	%NotifyClientCondition	([BX].diskMesaClientCondition)	DiskFinishNotify:	MOV	ES:[DI].diskComplete, TRUE	;It is okay to do this assignment ; diskComplete after we appearantly notified the client since the notification; does not happen until we do a Wait.;	POP	CX			:These two instructions would mirror;	JMP	CX			: the above code, but can be replaced by	RET	DiskYield:	%ContinueAtSystemLevel	JMP	DiskCheckForMesaCleanupRequest;; *******************************************************************************;	The DiskDMATask mainline code follows..; *******************************************************************************DiskDMATaskInit:;   Note: The disk DMA interrupt will not be watchdogged, since watchdogging; is done at a higher level by the disk system task.	%ThisTaskServices	(diskDMAInterrupt,DiskDMABadInterrupt)	%ResetDiskDMA	%'Reset the rigid disk DMA sub-system.	%Enable		(diskDMAInterrupt)DiskDMAWaitForWork:	%WaitForCondition	(OFFSET diskFCB.diskConditionDMAWork,noTimeout)DiskDMAHasWorkToDo:	MOV	BX, diskFCB.diskCurrentDrivePtr	;Set BX up to point to the IOCB.	%EstablishIOPAccess	(diskMapRegister,[BX].diskCurrentIOCBLow);   After getting everything setup to point to the correct information we will ; check to see if we are dealing with a data transfer or a DOB transfer.  We; need not worry about the direction of the transfer with respect to the FIFO ; since the DiskTask deals with that particular issue.DiskDMAAccessToIOCBEstablished:;	MOV	AL, [BX].diskSpare0;	MOV	DX, DiskDMADirection;	OUT	DX, AL	MOV	AL, [BX].diskCommand	AND	AL, MASK crCmd	CMP	AL, executeDOB	JE	DiskDMADataXfer;   At DiskDMADOBXfer we know that we are dealing with a transfer of the DOB.; Therefore, we calculate the address of the DOB and place the results in the; CX and DX registers.  AX then gets the twos complement of the size of the DOB.; The DMA operation is then requested.DiskDMADOBXfer:	MOV	CX, [BX].diskCurrentIOCBHigh	MOV	DX, [BX].diskCurrentIOCBLow;  We now add the 16-bit offset of the diskOperationBlock to the 24-bit OPIE; address in CX-DX.	%AddByteOffsetToOpieAddress(OFFSET diskOperationBlock)		MOV	AX, minusDOBSize	CALL	DoDiskDMA;   DiskDMADone is the point in the code where we will notify the DiskTask that; the requested DMA has completed its operation.DiskDMADone:	%NotifyCondition	(OFFSET diskFCB.diskConditionDMADone)	JMP	DiskDMAWaitForWorkDiskDMAFinishedPage:	%PostValueToLEDs(ES:[DI].diskPageCount)	DEC	ES:[DI].diskPageCount	;   At DiskDMADataXfer we know that we have data to transfer.  The transfer is; done on a page by page basis.  If either an error occurs or we have completed; the transfer we will notify the DiskTask and wait for another DMA request.DiskDMADataXfer:	CMP	ES:[DI].dmaErrorType, 0	JNE	DiskDMADone	CMP	ES:[DI].diskPageCount, 0	JE	DiskDMADone	MOV	CX, ES:[DI].diskDataPtrHigh	MOV	DX, ES:[DI].diskDataPtrLow		XOR	AX, AX		;A zero for the word count indicates a transfer of; 256 words or 512 bytes.  The word count is the twos complement byte count MOD 512	CALL	DoDiskDMA; After transferring a page of data we bump the pointer to point to the next page; of data.DiskDMAPageOperationHasCompleted:	TEST	ES:[DI].diskDataInfoRec, MASK incrementDataPtr	JZ	DiskDMAFinishedPage	MOV	CX, ES:[DI].diskDataPtrHigh	MOV	DX, ES:[DI].diskDataPtrLow	%AddByteOffsetToOpieAddress(diskPageSizeInBytes)	MOV	ES:[DI].diskDataPtrHigh, CX	MOV	ES:[DI].diskDataPtrLow, DX	JMP	DiskDMAFinishedPage	IOPEInROM	ENDS;********************************************************************************			END
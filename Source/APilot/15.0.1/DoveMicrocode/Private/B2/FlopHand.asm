$MOD186$PAGELENGTH (72)$PAGEWIDTH (142);;	Copyright (C) 1984, 1985, 1986 by Xerox Corporation. All rights reserved.;;	File = FlopHand.asm;	Stored as [Iris]<WMicro>Dove>FlopHand.asm;	This Head/Handler was deliberately designed NOT to do parrellel disk operations even though the fdc can do them;	This file assumes the definitions in FlopFace.asm;	We are going to setup ES:[DI] = iocb;	We are going to setup ES:[SI] = @iocb^.fdcCommands[iocb^.CurrentFDCCommand];;NAME			FloppyHandlerDove;$INCLUDE		(IOPDefs.asm)$INCLUDE		(IOPMacro.asm)$INCLUDE		(HardDefs.asm)$INCLUDE		(ROMEEP.asm)$INCLUDE		(QueDefs.asm)$INCLUDE		(QueMacro.asm)$INCLUDE		(FlopFace.asm);;;;--------------------------------------------------------------------------------;;;%*DEFINE	( InputWord ( WordPort, WordName ) )(			MOV	DX, %WordPort			IN	AX, DX			MOV	%WordName, AX)%*DEFINE	( OutputWord ( WordPort, WordName ) )(			MOV	DX, %WordPort			MOV	AX, %WordName			OUT	DX, AX)%*DEFINE	( PushDISI )(			PUSH	DI			PUSH	SI)%*DEFINE	( PopDISI )(			POP	SI			POP	DI);;;;--------------------------------------------------------------------------------;;	Timer/Counter Ports;FloppyCountRegister		EQU	FloppyTimerCountRegFloppyMaxCountA			EQU	FloppyTimerMaxCountRegFloppyMaxCountB			EQU	i186Timer1CountBAddrFloppyCounterControlWord	EQU	FloppyTimerMCWAddr;;FDCtoDMAport			EQU	FDCDMADataReg;;B0Mask				EQU	0011110011111111BEtchOneIOPMask			EQU	0011100000000000BPort80Mask			EQU	B0Mask					; set this mask for your hardwareReleaseDrivesMask		EQU	Port80Mask AND 0011100011110000BSelectDrivesMask		EQU	Port80Mask AND 0000000011110000B;;EXTRN FloppyHandlerID : ABSEXTRN DMA0@FloppyInterrupt : ABSEXTRN FloppyControllerInterrupt : ABS;;FloppyIOR	SEGMENT		COMMON		Assume		DS:FloppyIOR;EXTRN	FloppyTask : TaskContextBlockEXTRN	FloppyDMAtask : TaskContextBlockEXTRN	FloppyStopHandler : BYTEEXTRN	FloppyResetFDC : BYTEEXTRN	FloppyHandlerIsStopped : BYTEEXTRN	FloppyFDCHung : BYTEEXTRN	FloppyWaitingForDMAInterrupt : BYTEEXTRN	FloppyFirstDMAInterrupt : BYTEEXTRN	FloppyDriveMotorControlCount : BYTEEXTRN	FloppyTimeoutOccurred : BYTEEXTRN	FloppyBadDMAInterruptCount : BYTEEXTRN	FloppyBadFDCInterruptCount : BYTEEXTRN	FloppyExtraWord : WORDEXTRN	FloppyFillerByteForFormatting : BYTEEXTRN	FloppyDiagnosticsOn : BYTEEXTRN	FloppyEncodedDeviceTypes : EncodedDeviceTypeEXTRN	FloppyWorkMask : WORDEXTRN	FloppyWorkNotify : ConditionEXTRN	FloppyLockMask : WORDEXTRN	FloppyCurrentIOCB : WORDEXTRN	FloppyDiagnosticQueue : QueueBlockEXTRN	FloppyPilotQueue : QueueBlockEXTRN	Floppy80186Queue : QueueBlockEXTRN	FloppyDCB0 : DeviceContextBlockEXTRN	FloppyDCB1 : DeviceContextBlockEXTRN	FloppyDCB2 : DeviceContextBlockEXTRN	FloppyDCB3 : DeviceContextBlock;;;FloppyIOR	ENDS;;FloppySTK	SEGMENT		COMMON		Assume		SS:FloppySTK;EXTRN	FloppyStack : WORDEXTRN	FloppyDMAStack : WORD;;;FloppySTK	ENDS;;;;--------------------------------------------------------------------------------;;;IOPEInRom		SEGMENT	WORD PUBLIC			Assume CS:IOPEInRom;;;;--------------------------------------------------------------------------------;;;PUBLIC			FloppyInit						; for Opie to initialize the Floppy Handler;FloppyInit		PROC	FAR			%InitializeTask	(FloppyHandlerID,OFFSET	FloppyDMAtask, DMAInterruptHandler,OFFSET FloppyDMAStack)			%InitializeTask	(FloppyHandlerID,OFFSET	FloppyTask, MainFloppyTask,OFFSET FloppyStack)			RETFloppyInit		ENDP;;;;--------------------------------------------------------------------------------;--------------------------------------------------------------------------------;;;BadDMAInterrupt		PROC	FARBeginBadDMAInterrupt:	%EstablishHandlerAccess (FloppyHandlerID)			ASSUME ES:FloppyIOR			INC	ES:FloppyBadDMAInterruptCount			ASSUME ES:NOTHING			RETBadDMAInterrupt		ENDP;;;;--------------------------------------------------------------------------------;;;DMAInterruptHandler:			%ThisTaskServices(DMA0@FloppyInterrupt,BadDMAInterrupt)			CALL	StopDMAandCounterBeginMainDMAloop:	%PushDISI						; save context			%Enable ( DMA0@FloppyInterrupt )			%WaitForInterrupt	()				; wait until the DMA yells			%DisableInterruptsTillNextWaitGotDMAInterrupt:	%PopDISI						; restore context			CMP	FloppyWaitingForDMAInterrupt, MesaTRUE		; IF NOT FloppyWaitingForDMAInterrupt			JE	GoodInterrupt					; BEGIN			INC	FloppyBadDMAInterruptCount			;			JMP	SHORT	BeginMainDMAloop			; ENDGoodInterrupt:		CMP	FloppyFirstDMAInterrupt, MesaTRUE		; IF FloppyFirstDMAInterrupt THEN			JNE	NotFirstDMAInterrupt				; BEGIN			MOV	FloppyFirstDMAInterrupt, MesaFALSE		;   FloppyFirstDMAInterrupt _ FALSE			%EstablishIOPAccess (GeneralMapRegister,FloppyCurrentIOCB)	;   make ES:[DI] point at the Current iocb			LEA	SI, ES:[DI].fdcCommands				;   make ES:[SI] point to iocb^.fdcCommands[1]			MOV	AX, ES:[DI].CurrentFDCCommand			;			DEC	AX						;   make ES:[SI] point to			MOV	BX, SIZE(fdcCommandRecord)			;   the current fdcCommand			MUL	BX						;			ADD	SI, AX						;   SI _ SI + ( CurrentFDCCommand - 1 ) * SIZE(fdcCommandRecord)			MOV	AX, ES:[DI].FirstDMAtransferCount		;   AX _ iocb^.FirstDMAtransferCount			JMP	SHORT	UpdateDataAddress			; END										; ELSENotFirstDMAInterrupt:								; BEGIN			MOV	AX, ES:[DI].MiddleDMAtransferCount		;   AX _ iocb^.MiddleDMAtransferCountUpdateDataAddress:								; END			CMP	ES:[DI].IncrementDataPointer, MesaTRUE			JNE	NoCarryOnAdd			CMP	ES:[DI].DataAddress.OpieAddressType, mesaLogicalWordOpieAddress			JNE	NotWordAddress			SHR	AX, 1NotWordAddress:		ADD	ES:[DI].DataAddress, AX				; iocb^.DataAddress _ iocb^.DataAddress + AX			JNC	NoCarryOnAdd			INC	ES:[DI].DataAddress+2NoCarryOnAdd:			CALL	SetupDMApointers				; uses ES, DI, SI			CMP	ES:[DI].NumberOfMiddleDMAtransfers, 0				; IF NumberOfMiddleDMAtransfers <= 0 THEN			JG	GottaMiddleTransfer						; BEGIN			MOV	FloppyWaitingForDMAInterrupt, MesaFALSE			%OutputWord ( FloppyDMATransferCount, ES:[DI].LastDMAtransferCount )	;   FloppyDMATransferCount _ LastDMAtransferCount			%OutputWord ( FloppyDMAControlWord, ES:[DI].LastDMAcontrolWord )	;   FloppyDMAControlWord _ LastDMAcontrolWord			JMP	SHORT	EndOfMainDMALoop					; END												; ELSEGottaMiddleTransfer:										; BEGIN			DEC	ES:[DI].NumberOfMiddleDMAtransfers				;   NumberOfMiddleDMAtransfers _ NumberOfMiddleDMAtransfers - 1			%OutputWord ( FloppyDMATransferCount, ES:[DI].MiddleDMAtransferCount )	;   FloppyDMATransferCount _ MiddleDMAtransferCount			%OutputWord ( FloppyDMAControlWord, ES:[DI].MiddleDMAcontrolWord )	;   FloppyDMAControlWord _ MiddleDMAcontrolWordEndOfMainDMALoop:										; END			JMP	BeginMainDMAloop;;;;--------------------------------------------------------------------------------;--------------------------------------------------------------------------------;;;BadFDCInterrupt		PROC	FARBeginBadFDCInterrupt:	%EstablishHandlerAccess (FloppyHandlerID)			ASSUME ES:FloppyIOR			INC	FloppyBadFDCInterruptCount			ASSUME ES:NOTHING			RETBadFDCInterrupt		ENDP;;;;--------------------------------------------------------------------------------;;;MainFloppyTask:		%ThisTaskServices (FloppyControllerInterrupt,BadFDCInterrupt)			CALL	InitializeFCB			CALL	ReleaseDrives					; play it safe			CALL	ResetTheFDC			CALL	CheckDriveStatusMainFloppyTaskLoop:								; BEGINLOOP			%Enable ( floppyControllerInterrupt )			%WaitForCondition (OFFSET FloppyWorkNotify,1000)	;   wait for FloppyWorkNotify or TimeoutLookForMoreWorkToDo:	CALL	CheckDriveStatus				;   update DCB's in FCB			CMP	FloppyStopHandler, MesaTRUE			;   IF FloppyStopHandler = TRUE THEN			JNE	HandlerIsRunning				;   BEGIN			MOV	FloppyHandlerIsStopped, MesaTRUE		;     FloppyHandlerIsStopped _ TRUE			CALL	ReleaseDrives					;     ReleaseDrives[]			JMP	SHORT	MainFloppyTaskLoop			;     GOTO MainFloppyTaskLoopHandlerIsRunning:								;   END			MOV	FloppyHandlerIsStopped, MesaFALSE		;   FloppyHandlerIsStopped _ FALSE			CMP	FloppyResetFDC, MesaTRUE			;   IF FloppyResetFDC THEN			JNE	SkipReset					;   BEGIN			CALL	ResetTheFDC					;     ResetTheFDC[]			JNC	SkipReset					;     IF reset was sucessful THEN			MOV	FloppyResetFDC, MesaFALSE			;     FloppyResetFDC _ FALSESkipReset:									;   END			CMP	FloppyDiagnosticsOn, MesaTRUE			JNE	EndDiagnosticQueue			%JumpIfMesaIOCBNextNil (FloppyDiagnosticQueue.queueNext,EndDiagnosticQueue)	;   IF MESA queueNext # NIL THENBeginDiagnosticQueue:									;   BEGIN			%ConvertAddress (FloppyDiagnosticQueue.queueNext)		;     Convert MESA Virtual Address to an Extended Bus Address			CALL	ExecuteOperation					;     ExecuteOperation			%AdvanceMesaIOCB (FloppyDiagnosticQueue.queueNext,NextIOCB,FloppyLockMask,mapped)											;     Next _ iocb^.NextIOCB			%NotifyClientCondition(ES:[DI].ActualClientCondition)		;     notify client operation is doneEndDiagnosticQueue:									;   END			CMP	FloppyDiagnosticsOn, MesaTRUE			JE	End186Queue			%JumpIfMesaIOCBNextNil (FloppyPilotQueue.queueNext,EndMesaQueue)	;   IF MESA queueNext # NIL THENBeginMesaQueue:										;   BEGIN			%ConvertAddress (FloppyPilotQueue.queueNext)			;     Convert MESA Virtual Address to an Extended Bus Address			CALL	ExecuteOperation					;     ExecuteOperation			%AdvanceMesaIOCB (FloppyPilotQueue.queueNext,NextIOCB,FloppyLockMask,mapped)											;     Next _ iocb^.NextIOCB			%NotifyClientCondition(ES:[DI].ActualClientCondition)		;     notify client operation is doneEndMesaQueue:										;   END			%JumpIfQueueNextNil (Floppy80186Queue,End186Queue)		;   IF PC queueNext # NIL THENBegin186Queue:										;   BEGIN			%ConvertAddress (Floppy80186Queue.queueNext)			;     Convert PC Address to an Extended Bus Address			CALL	ExecuteOperation					;     ExecuteOperation			%AdvanceQueue (Floppy80186Queue,NextIOCB,mapped)		;     Next _ iocb^.NextIOCB			%NotifyClientCondition(ES:[DI].ActualClientCondition)		;     notify client operation is doneEnd186Queue:										;   END			CMP	FloppyDriveMotorControlCount, 0			;   IF FloppyDriveMotorControlCount <= 0 THEN			JNE	LeaveMotorOn					;   BEGIN			CALL	ReleaseDrives					;     ReleaseDrives[]			JMP	SHORT	TurnedMotorOff				;   END										;   ELSELeaveMotorOn:									;   BEGIN			DEC	FloppyDriveMotorControlCount			;     FloppyDriveMotorControlCount _ FloppyDriveMotorControlCount - 1TurnedMotorOff:									;   END			CALL	CheckDriveStatus				;   update DCB's in FCB			JMP	MainFloppyTaskLoop				; ENDLOOP;;;;--------------------------------------------------------------------------------;;;	we are expecting an Extended Bus Address in CX-DX;	we are going to set;	ES:[DI] _ iocb;	ES:[SI] _ @iocb^.fdcCommands[iocb^.CurrentFDCCommand];;ExecuteOperation	PROCBeginExecuteOperation:			MOV	FloppyWaitingForDMAInterrupt, MesaFALSE		;			MOV	FloppyTimeoutOccurred, MesaFALSE			MOV	FloppyCurrentIOCB+2, CX				; save Extended Bus Address in FCB for DMAInterrupt task			MOV	FloppyCurrentIOCB, DX				; save Extended Bus Address in FCB for DMAInterrupt task			%EstablishIOPAccess(GeneralMapRegister,CX-DX)		; make ES:[DI] point to the current IOCB			MOV	ES:[DI].CurrentFDCCommand, 0			; iocb^.CurrentFDCCommand _ 0			MOV	ES:[DI].FinalDMACount, 0			; iocb^.FinalDMACount _ 0			CMP	ES:[DI].OperationIsQueued, MesaTRUE		; IF NOT iocb^.OperationIsQueued			JNE	FailedOperation					; THEN RETURN [ OperationFailed ]			CMP	ES:[DI].OperationState, OperationWaiting	; IF NOT iocb^.OperationState = OperationWaiting THEN			JNE	FailedOperation					; THEN RETURN [ OperationFailed ]			MOV	ES:[DI].OperationState, OperationInProgress	; iocb^.OperationState _ OperationInProgress			CMP	ES:[DI].PCEResetFDCFlag, MesaTRUE		; IF iocb^.PCEResetFDCFlag THEN			JNE	NoPCEReset					; BEGIN			CALL	PCEResetTheFDC					;   CF _ PCEResetTheFDC[] ;			JNC	FailedOperation					;   IF NOT CF THEN RETURN [ OperationFailed ]			JMP	SHORT	CompletedOperation			;   RETURN [ OperationCompleted ]NoPCEReset:									; END			MOV	AL, ES:[DI].PCEStartMotorFlags			CMP	AL, 0			JE	NoPCEStartMotor			CALL	PCEStartMotor			JMP	SHORT	CompletedOperationNoPCEStartMotor:			CMP	ES:[DI].ResetFDCBeforeProcessing, MesaTRUE	;   IF ResetFDCBeforeProcessing THEN			JNE	DontResetFDC					;   BEGIN			CALL	ResetTheFDC					;     CF _ ResetTheFDC[]			JNC	FailedOperation					;     IF NOT CF THEN RETURN [ OperationFailed ]			MOV	ES:[DI].ResetFDCBeforeProcessing, MesaFALSE	;     iocb^.ResetFDCBeforeProcessing _ FALSEDontResetFDC:									;   END			CMP	FloppyFDCHung, MesaTRUE				;   IF FloppyFDCHung			JE	FailedOperation					;   THEN RETURN [ OperationFailed ]			MOV	AH, ES:[DI].SpecifyBeforeProcessing			MOV	AL, ES:[DI].DaDriveNumber			;   AL _ iocb^.DaDriveNumber			CALL	AccessDrive					;   CF _ AccessDrive[SpecifyBeforeProcessing : AH, DriveNumber : AL]			JNC	FailedOperation					;   IF NOT CF THEN RETURN [ OperationFailed ]			CMP	ES:[DI].RecalibrateBeforeProcessing, MesaTRUE	;   IF RecalibrateBeforeProcessing THEN			JNE	DontRecalibrate			CALL	RecalibrateDrive				; CF _ RecalibrateDrive[AL]			JNC	FailedOperation					; IF NOT CF THEN RETURN [ OperationFailed]			MOV	ES:[DI].RecalibrateBeforeProcessing, MesaFALSEDontRecalibrate:			LEA	SI, ES:[DI].fdcCommands				;   make ES:[SI] point to iocb^.fdcCommands[1]MainLoop:		MOV	AX, ES:[DI].CurrentFDCCommand			;   load iocb^.CurrentFDCCommand			CMP	AX, ES:[DI].NumberOfFDCCommands			;   IF iocb^.CurrentFDCCommand >= iocb^.NumberOfFDCCommands			JGE	CompletedOperation				;   THEN GOTO CompletedOperation			INC	ES:[DI].CurrentFDCCommand			;   iocb^.CurrentFDCCommand _ iocb^.CurrentFDCCommand + 1			CALL	ExecuteFDCCommand				;   Execute CurrentFDCCommand - SI Points at it			JNC	FailedOperation					;   IF NOT CF THEN GOTO FailedOperation			ADD	SI, SIZE(fdcCommandRecord)			;   make SI point at next fdcCommand			JMP	SHORT	MainLoopFailedOperation:	MOV	ES:[DI].OperationState, OperationFailed		; iocb^.OperationState _ OperationFailed			JMP	SHORT	FinishUpExecuteOpCompletedOperation:	MOV	ES:[DI].OperationState, OperationCompleted	; iocb^.OperationState _  OperationCompletedFinishUpExecuteOp:	CALL	StopDMAandCounter			MOV	AL, FloppyFDCHung			MOV	ES:[DI].FDCHung, AL				; iocb^.FDCHung _ FloppyFCB^.FloppyFDCHung			MOV	AL, FloppyTimeoutOccurred			MOV	ES:[DI].TimeoutOccurred, AL			; iocb^.TimeoutOccurred _ FloppyFCB^.FloppyTimeoutOccurred			IN	AL, FDCStatusReg			MOV	ES:[DI].FinalStateOfFDC, AL			; iocb^.FinalStateOfFDC _ FDC Main Status RegisterEndExecuteOperation:	RETExecuteOperation	ENDP;;;;--------------------------------------------------------------------------------;;;ExecuteFDCCommand	PROCBeginExecuteFDCCommand:	CALL	StopDMAandCounter			MOV	ES:[SI].NumberOfCommandBytesWritten, 0		; iocb^.fdcCommands[?].NumberOfCommandBytesWritten _ 0			MOV	ES:[SI].NumberOfResultBytesRead, 0		; iocb^.fdcCommands[?].NumberOfResultBytesReturned _ 0			MOV	AL, ES:[SI].DataTransferCode			; 			CMP	AL, Read					; IF iocb^.DataTransferCode = Read			JE	GottaSetupDMA					; 			CMP	AL, Write					; OR iocb^.DataTransferCode = Write			JE	GottaSetupDMA					; 			MOV	ES:[SI].DataTransferCode, None			JMP	SHORT	DontSetupDMA				; THEN BEGINGottaSetupDMA:		%OutputWord ( FloppyCountRegister, 0 )			;   FloppyCountRegister _ 0			%OutputWord ( FloppyMaxCountA, ES:[DI].TotalBytesToTransfer );  FloppyMaxCountA _ iocb^.TotalBytesToTransfer			%OutputWord ( FloppyMaxCountB, 0 )			;   FloppyMaxCountB _ 0			%OutputWord ( FloppyCounterControlWord, ES:[DI].CounterControlRegister )	; FloppyCounterControlWord _ iocb^.CounterControlRegister			CALL	SetupDMApointers			%OutputWord ( FloppyDMATransferCount, ES:[DI].FirstDMAtransferCount )	; FloppyDMATransferCount _ FirstDMAtransferCount			%OutputWord ( FloppyDMAControlWord, ES:[DI].FirstDMAcontrolWord )	; FloppyDMAControlWord _ FirstDMAcontrolWordDontSetupDMA:									; END			MOV	BX, 1			MOV	DH, 0			MOV	DL, ES:[SI].NumberOfCommandBytesWriteLoop:		CMP	BX, DX						; FOR i _ 1 TO iocb^.NumberOfCommandBytes DO			JG	FinishedWriteLoop				; BEGIN			MOV	AL, ES:[SI+BX-1].CommandBytes			;   AL _ CommandBytes[i]			CALL	WriteCommandByteToFDC				;   WriteCommandByteToFDC[AL]			JNC	CantExecuteFDCCommand				;   IF ReturnCode # TRUE THEN get out and RETURN FALSE			INC	ES:[SI].NumberOfCommandBytesWritten		;   iocb^.NumberOfCommandBytesWritten++			INC	BX						;   i _ i + 1			JMP	SHORT	WriteLoopFinishedWriteLoop:								; END			%PushDISI						; save context			CMP	ES:[SI].MustWaitForInterrupt, MesaTRUE		; IF MustWaitForInterrupt THEN			JNE	SkipWaitForInterrupt				; BEGIN			CMP	ES:[SI].DataTransferCode, None			;   IF DataTransferCode # None			JE	NoDMAInterrupt			TEST	ES:[DI].FirstDMAcontrolWord, 0100H		;   AND iocb^.FirstDMAcontrolWord.dmaInterruptWhenDone			JZ	NoDMAInterrupt					;   BEGIN			MOV	FloppyFirstDMAInterrupt, MesaTRUE		;     FloppyFirstDMAInterrupt _ TRUE			MOV	FloppyWaitingForDMAInterrupt, MesaTRUE		;     enable DMA interrupt handlerNoDMAInterrupt:									;   END			%WaitForInterrupt	(10)				;   wait till FDC yells			MOV	FloppyWaitingForDMAInterrupt, MesaFALSE		;   disable DMA interrupt handler			JNC	IsGoodInterrupt			MOV	FloppyTimeoutOccurred, MesaTRUE			%PopDISICantExecuteFDCCommand:	CLC							; return code _ false			RET							; the reason this is here is cause conditional jumps										; can only reach +- 127 bytes, and placing it at the end is too farIsGoodInterrupt:SkipWaitForInterrupt:								; END			%PopDISI						; restore context			CMP	ES:[SI].DataTransferCode, None			JE	SkipGetCountLeft			%InputWord ( FloppyCountRegister, ES:[DI].TotalBytesActuallyTransfered )			%InputWord ( FloppyDMATransferCount, ES:[DI].FinalDMACount )SkipGetCountLeft:			MOV	BX, 1			MOV	DH, 0			MOV	DL, ES:[SI].NumberOfResultBytesReadLoop:		CMP	BX, DX						; FOR i _ 1 TO iocb^.NumberOfResultBytesExpected DO			JG	FinishedReadLoop				; BEGIN			CALL	ReadResultByteFromFDC				;   [CF, AL] _ ReadResultByteFromFDC[]			JNC	CantExecuteFDCCommand				;   IF NOT CF THEN RETURN FALSE			MOV	ES:[SI+BX-1].ResultBytes, AL			;   iocb^.ExpectedResultBytes[i] _ AL			INC	ES:[SI].NumberOfResultBytesRead			;   iocb^.NumberOfResultBytesReturned++			INC	BX			JMP	SHORT	ReadLoop				; ENDFinishedReadLoop:	CALL	fdcCommandCompletedOK				; find return codeEndExecuteFDCCommand:	RETExecuteFDCCommand	ENDP;;;;--------------------------------------------------------------------------------;			support subroutines;--------------------------------------------------------------------------------;;;AccessDrive		PROC							; CF _ AccessDrive[SpecifyBeforeProcessing : AH, DriveNumber : AL]			PUSH	BX						; all registers preserved			CALL	GetDCBPointer					; BX _ GetDCBPointer[AX]			CMP	[BX].DeviceAttributes, 0			; FloppyDCB[AX].DeviceAttributes.type = nullType			JNE	aValidDrive			POP	BX			CLC							; RETURN [ FALSE ]			RETaValidDrive:		PUSH	AX			CMP	AH, MesaTRUE			JNE	WritePort80			MOV	AH, [BX].StepRateTimePlusHeadUnloadTime			MOV	AL, [BX].HeadLoadTimePlusNotInDMAmode			CALL	DoSpecifyCommand			JC	WritePort80			POP	AX			POP	BX			RET							; RETURN [ FALSE ]WritePort80:		MOV	AX, [BX].Port80ControlWord			; AX _ FloppyDCB[AX].Port80ControlWord			PUSH	CX			%ControlRegister(Port80Mask,AX)		; Port80 _ AX			POP	CX			POP	AX			POP	BX			CMP	FloppyDriveMotorControlCount, 0			; IF FloppyDriveMotorControlCount <= 0 THEN			JG	TheMotorIsOn					; BEGIN			PUSHA			%WaitForTime ( 500 )					;   wait a half a sec			POPATheMotorIsOn:									; END			MOV	FloppyDriveMotorControlCount, 3			; FloppyDriveMotorControlCount _ 3			STC							; RETURN [ TRUE ]			RETAccessDrive		ENDP;;;;--------------------------------------------------------------------------------;;;CheckDriveStatus	PROCBeginCheckDriveStatus:	IN	AL, FDCStatusReg				; check status of FDC			AND	AL, 00001111B					; if any drive seeking,			JNZ	EndCheckDriveStatus				; don't disturb it			MOV	AL, 0			CALL	SelectDrive			CALL	DoSenseDriveStatus			JNC	EndCheckDriveStatus			MOV	FloppyDCB0.DriveStatusHead0, AL			MOV	AL, 1			CALL	SelectDrive			CALL	DoSenseDriveStatus			JNC	EndCheckDriveStatus			MOV	FloppyDCB1.DriveStatusHead0, AL			MOV	AL, 2			CALL	SelectDrive			CALL	DoSenseDriveStatus			JNC	EndCheckDriveStatus			MOV	FloppyDCB2.DriveStatusHead0, AL			MOV	AL, 3			CALL	SelectDrive			CALL	DoSenseDriveStatus			JNC	EndCheckDriveStatus			MOV	FloppyDCB3.DriveStatusHead0, ALEndCheckDriveStatus:	RETCheckDriveStatus	ENDP;;;;--------------------------------------------------------------------------------;;;ClearAllFDCstatus	PROC							; takes no args, destroys AX & CX			XOR	CX,CXClearFDCloop:			MOV	AL, 08H			CALL	WriteCommandByteToFDC			JNC	CantClearFDC			CALL	ReadResultByteFromFDC			JNC	CantClearFDC			CMP	AL, 080H					;Empty? Invalid Commad?			JE	ClearedFDC			CALL	ReadResultByteFromFDC				;Read PCN			JNC	CantClearFDC			LOOP	ClearFDCloop					;loop till done or timeoutCantClearFDC:		CLC							; RETURN FALSE			JMP	SHORT	EndClearAllFDCstatusClearedFDC:		STCEndClearAllFDCstatus:	RETClearAllFDCstatus	ENDP;;;;--------------------------------------------------------------------------------;;;DoRecalibrateCommand	PROC							; takes DriveNumber in AL			PUSH	AX						; all registers preserved			MOV	AL, fdcRecalibrateCommand			CALL	WriteCommandByteToFDC			POP	AX			JNC	EndDoRecalibrate			CALL	WriteCommandByteToFDCEndDoRecalibrate:	RETDoRecalibrateCommand	ENDP;;;;--------------------------------------------------------------------------------;;;DoSenseDriveStatus	PROC							; takes Head and DriveNumber in AL			MOV	AH, AL			MOV	AL, fdcSenseDriveStatusCommand			CALL	WriteCommandByteToFDC			JNC	EndDoSenseDrive			MOV	AL, AH			CALL	WriteCommandByteToFDC			JNC	EndDoSenseDrive			CALL	ReadResultByteFromFDCEndDoSenseDrive:	RET							; returns ST3 in ALDoSenseDriveStatus	ENDP;;;;--------------------------------------------------------------------------------;;;DoSenseInterruptStatusCommand	PROC						; AH _ ST0, AL _ PCN				MOV	AL, fdcSenseInterruptStatusCommand				CALL	WriteCommandByteToFDC				JNC	EndSenseInterrupt				CALL	ReadResultByteFromFDC				JNC	EndSenseInterrupt				MOV	AH, AL				CALL	ReadResultByteFromFDCEndSenseInterrupt:		RET						; returns a boolean tooDoSenseInterruptStatusCommand	ENDP;;;;--------------------------------------------------------------------------------;;;DoSpecifyCommand	PROC							; SRT+HUT in AH & HLT+NDMA in AL, all registers preserved			PUSH	AX			MOV	AL, fdcSpecifyCommand			CALL	WriteCommandByteToFDC			POP	AX			JNC	EndDoSpecify			XCHG	AH, AL			CALL	WriteCommandByteToFDC				; write SRT+HUT to FDC			XCHG	AH, AL			JNC	EndDoSpecify			CALL	WriteCommandByteToFDC				; write HLT+NDMA to FDCEndDoSpecify:		RETDoSpecifyCommand	ENDP							; returns boolean;;;;--------------------------------------------------------------------------------;;;CheckItArray		DB	MesaFALSE		; NullCommand			DB	MesaTRUE		; FormatTrack			DB	MesaTRUE		; ReadData			DB	MesaTRUE		; ReadDeletedData			DB	MesaTRUE		; ReadID			DB	MesaTRUE		; ReadTrack			DB	MesaFALSE		; Recalibrate			DB	MesaTRUE		; ScanEqual			DB	MesaTRUE		; ScanHighOrEqual			DB	MesaTRUE		; ScanLowOrEqual			DB	MesaFALSE		; Seek			DB	MesaFALSE		; SenseDriveStatus			DB	MesaTRUE		; SenseInterruptStatus			DB	MesaFALSE		; Specify			DB	MesaTRUE		; WriteData			DB	MesaTRUE		; WriteDeletedDatafdcCommandCompletedOK	PROC							; destroys AX & BX RETURNS [ BOOLEAN ]			MOV	AL, ES:[SI].fdcCode				; AL _ iocb^.fdcCommands[iocb^.CurrentFDCCommand].fdcCode			MOV	AH, 0			CMP	AX, 15			JG	NotOK						; check for legal value			LEA	BX, CheckItArray				; load address of CheckItArray			ADD	BX, AX						; compute index into CheckItArray			MOV	AL, CS:[BX]					; load value from CheckItArray			CMP	AL, MesaTRUE					; IF we gotta check this fdc code			JNE	AllOK						; BEGIN			MOV	AL, ES:[SI].ResultBytes				;   load ST0			AND	AL, 11000000B					;   only the two high bits are important			CMP	AL, 0						;   if either high bit is set			JNE	NotOK						;   we have failed			CMP	ES:[SI].DataTransferCode, None			;   IF no data xfer then skip next test			JE	AllOK			CMP	ES:[DI].FinalDMACount, 0			;   if data xfer & FinalDMACount <> 0 then trouble			JNE	NotOKAllOK:			STC							;   RETURN [ TRUE ]			RET										; ENDNotOK:			CLC							; RETURN [ FALSE ]			RETfdcCommandCompletedOK	ENDP;;;;--------------------------------------------------------------------------------;;;GetDCBPointer		PROC							; DriveNumber in AX			PUSH	AX			AND	AX, 3H			MOV	BX, SIZE(DeviceContextBlock)			PUSH DX			MUL	BX			POP	DX			LEA	BX, FloppyDCB0			ADD	BX, AX			POP	AX			RETGetDCBPointer		ENDP							; BX _ @FloppyFCB^.FloppyDCB[AX];;;;--------------------------------------------------------------------------------;;;GetEncodedDriveType	PROC							; takes DriveNumber in AX			PUSH	CX			AND	AX, 3H						; force DriveNumber into [0..3]			SHL	AL, 2						; AX _ 4 * AX			MOV	CL, 12			SUB	CL, AL						; rotate count = 12 - ( 4 * AX )			MOV	AX, FloppyEncodedDeviceTypes			XCHG	AH, AL						; byte swap back for handler			ROR	AX, CL						; rotate nibble to low nibble position			AND	AX, 0FH						; mask off high three nibbles			POP	CX			RETGetEncodedDriveType	ENDP							; returns EncodedDriveType in AX;;;;--------------------------------------------------------------------------------;;;GetPort80ControlWord	PROC							; drive number in AX			PUSH	BX						; pointer comes back in BX			CALL	GetDCBPointer					; BX _ @FloppyDCB[AX]			MOV	AX, [BX].Port80ControlWord			; AX _ FloppyDCB[AX].Port80ControlWord			POP	BX						; restore BX			RETGetPort80ControlWord	ENDP							; returns ControlWord in AX;;;;--------------------------------------------------------------------------------;;;InitializeFCB		PROCBeginInitializeFCB:	MOV	FloppyStopHandler, MesaFALSE			; FloppyStopHandler _ FALSE			MOV	FloppyResetFDC, MesaFALSE			; FloppyResetFDC _ FALSE			MOV	FloppyHandlerIsStopped,	MesaFALSE		; FloppyHandlerIsStopped _ FALSE			MOV	FloppyFDCHung, MesaFALSE			MOV	FloppyWaitingForDMAInterrupt, MesaFALSE			MOV	FloppyFirstDMAInterrupt, MesaFALSE		; FloppyFirstDMAInterrupt _ FALSE			MOV	FloppyDriveMotorControlCount, 0			MOV	FloppyTimeoutOccurred, MesaFALSE			MOV	FloppyBadDMAInterruptCount, 0			MOV	FloppyBadFDCInterruptCount, 0			MOV	FloppyExtraWord, 0			MOV	FloppyFillerByteForFormatting, FillerByteForFormatting			MOV	FloppyDiagnosticsOn, MesaFALSE			%ReadEEProm(eePromFloppy,1)			JNC	GoodEEPROM			MOV	AX, (sa455DiskDrive SHL 12)			; default one sa455 drive hooked to drive zeroGoodEEPROM:			XCHG	AH, AL			MOV	FloppyEncodedDeviceTypes, AX			MOV	FloppyWorkNotify, 0			%GetWorkMaskForCondition(OFFSET FloppyWorkNotify)	; FloppyWorkMask _ GetWorkMask			MOV	FloppyWorkMask, AX			%GetLockMask						; LockMask _ GetLockMask			MOV	FloppyLockMask, AX			MOV	FloppyCurrentIOCB, 0			MOV	FloppyCurrentIOCB+2, 0			LEA	BX, FloppyDiagnosticQueue			CALL	InitQueueBlock			LEA	BX, FloppyPilotQueue			CALL	InitQueueBlock			LEA	BX, Floppy80186Queue			CALL	InitQueueBlock			MOV	AX, 0			MOV	FloppyDCB0.DeviceAttributes, AX			; FloppyFCB^.FloppyDCB[0].DeviceAttributes.type _ Device.nullType			MOV	FloppyDCB0.Port80ControlWord, sa455onDriveZero			MOV	FloppyDCB0.StepRateTimePlusHeadUnloadTime, sa455StepRateTimePlusHeadUnloadTime			MOV	FloppyDCB0.HeadLoadTimePlusNotInDMAmode, sa455HeadLoadTimePlusNotInDMAmode			MOV	FloppyDCB1.DeviceAttributes, AX			MOV	FloppyDCB2.DeviceAttributes, AX			MOV	FloppyDCB3.DeviceAttributes, AX			CALL	GetEncodedDriveType				; AX _ GetEncodedDriveType[AX]			CMP	AX, sa455DiskDrive			JNE	EndInitializeFCB			MOV	FloppyDCB0.DeviceAttributes, AXEndInitializeFCB:	RETInitializeFCB		ENDP;;;;--------------------------------------------------------------------------------;;;InitQueueBlock		PROC			MOV	AX, 0			MOV	[BX+0], AX			MOV	[BX+2], AX			MOV	[BX+4], AX			MOV	[BX+6], AX			MOV	[BX+8], AX			MOV	[BX+10], AX			RETInitQueueBlock		ENDP;;;;--------------------------------------------------------------------------------;;;LongDelay		PROCBeginLongDelay:		PUSHA			%WaitForSystem			POPAEndLongDelay:		RETLongDelay		ENDP;;;;--------------------------------------------------------------------------------;;;PCEResetTheFDC		PROC							; assumes that ES:[DI] points to an iocb			PUSHA			CALL	StopDMAandCounter			%DisableInterruptsTillNextWait			%Reset ( resetFloppyController )			%WaitForInterrupt	(10)			JNC	GotMyInterrupt			POPA			MOV	FloppyTimeoutOccurred, MesaTRUE			CLC			RET							; RETURN [ FALSE ]GotMyInterrupt:		POPA			MOV	FloppyFDCHung, MesaFALSE			MOV	ES:[DI].PCEResetFDCFlag, MesaFALSE			STC			RET							; RETURN [ TRUE ]PCEResetTheFDC		ENDP;;;;--------------------------------------------------------------------------------;;;PCEStartMotor		PROC							; takes drive number in AX			CALL	GetPort80ControlWord				; AX _ FloppyFCB^.FloppyDCB[AX].Port80ControlWord			PUSH	CX			%ControlRegister(Port80Mask,AX)		; Port80 _ AX			POP	CX			MOV	FloppyDriveMotorControlCount, 3			; FloppyDriveMotorControlCount _ 3			MOV	ES:[DI].PCEStartMotorFlags, 0			RETPCEStartMotor		ENDP;;;;--------------------------------------------------------------------------------;;;ReadResultByteFromFDC	PROCBeginReadResultByte:	CALL	LongDelay			PUSH	CX						; save CX  ( and delay a little more )			MOV 	CX, 040						; max of 40 tries to Read Main Status RegisterReadyToReadLoop:	IN	AL, FDCStatusReg				; Read Main Status Register			AND	AL, 11000000B					; we only want to look at RequestForMaster and DataInputOutput			CMP	AL, 11000000B					; wait for data request			JE	ReadyToRead					; is FDC ready to return a ResultByte ?			LOOP 	ReadyToReadLoop					; loop till done or timeout										; timeoutReadError:		POP	CX						; restore CX			CLC							; return code _ false			MOV	FloppyFDCHung, MesaTRUE			RET							; RETURN [ FALSE ]ReadyToRead:		POP	CX						; restore CX			STC							; return code _ true			IN	AL, FDCDataReg					; Read byte into AL			RET							; RETURN [ TRUE ]ReadResultByteFromFDC	ENDP;;;;--------------------------------------------------------------------------------;;;RecalibrateDrive	PROC							; takes drive number in AXBeginRecalibrateDrive:	CALL	DoRecalibrateCommand			JNC	EndRecalibrateDrive			PUSHA			%WaitForInterrupt	(10)				; wait till FDC hollers			JNC	WasGoodInterrupt			POPA			MOV	FloppyTimeoutOccurred, MesaTRUE			CLC			RET							; RETURN [ FALSE ]WasGoodInterrupt:	POPA			PUSH	AX			CALL	DoSenseInterruptStatusCommand			JC	AnalyseStatus			POP	AX			RET							; RETURN [ FALSE ]AnalyseStatus:		AND	AH, 11000000B			CMP	AH, 0			JE	GoodStatus			POP	AX			CLC			RET							; RETURN [ FALSE ]GoodStatus:		POP	AX			STCEndRecalibrateDrive:	RET							; RETURN [ TRUE ]RecalibrateDrive	ENDP;;;;--------------------------------------------------------------------------------;;;ReleaseDrives		PROC							; ends access to all drives			PUSH	AX			PUSH	CX			%ControlRegister(ReleaseDrivesMask,0)			; turn off Floppy Drive Motor			MOV	FloppyDriveMotorControlCount, 0			; FloppyDriveMotorControlCount _ 0			POP	CX			POP	AX			RETReleaseDrives		ENDP							; all registers preserved;;;;--------------------------------------------------------------------------------;;;ResetTheFDC		PROCBeginResetTheFDC:	PUSHA							; SaveContext !!!!			%Enable ( floppyControllerInterrupt )			%DisableInterruptsTillNextWait				; make sure we catch the interrupt			CALL	StopDMAandCounter			%Reset ( resetFloppyController )			; gently tap chip with sledge hammer			%WaitForInterrupt	(10)				; enable interrupts and catch the FDC yelling			JNC	GotResetInterrupt			MOV	FloppyTimeoutOccurred, MesaTRUE			JMP	SHORT	ResetFailureGotResetInterrupt:	MOV	FloppyFDCHung, MesaFALSE			; clear FDCHung status			MOV	FloppyTimeoutOccurred, MesaFALSE			CALL	ClearAllFDCstatus				; give FDC chip an enema			JNC	ResetFailure			MOV	BX, 0			MOV	DX, MaxNumberOfDiskDrivesRecalLoop:		INC	BX			CMP	BX, DX			JG	FinishedRecalLoop				; BEGIN			MOV	AL, BL			DEC	AL			MOV	AH, MesaTRUE			CALL	AccessDrive					; CF _ AccessDrive[SpecifyBeforeProcessing = AH, DriveNumber = AL]			JNC	RecalLoop					; oops - no such drive, skip to next drive			CALL	RecalibrateDrive			JMP	SHORT	RecalLoopFinishedRecalLoop:								; END			STC			JMP	SHORT	EndResetTheFDCResetFailure:		CLCEndResetTheFDC:		POPA							; RestoreContext !!!!			RETResetTheFDC		ENDP;;;;--------------------------------------------------------------------------------;;;DriveBitsControlArray	DW	CRDriveSel0			DW	CRDriveSel1			DW	CRDriveSel2			DW	CRDriveSel3;SelectDrive		PROC							; takes DriveNumber in AX, all regs preserved			PUSH	CX			PUSH	BX			PUSH	AX			MOV	BX, AX			AND	BX, 3H						; BX _ AX MOD 4 ( => BX IN [0..3] )			SAL	BX, 1						; BX _ 2 * BX			MOV	AX, CS:DriveBitsControlArray[BX]		; AX _ DriveBitsControlArray[DriveNumber]			%ControlRegister(SelectDrivesMask,AX)			; turn on the specified DriveNumber			POP	AX			POP	BX			POP	CX			RETSelectDrive		ENDP;;;;--------------------------------------------------------------------------------;;;SetupDMApointers	PROC							; iocb = ES:[DI]BeginSetupDMA:		PUSH	ES						; destroys AX, BX, CX, & DX			%PushDISI			%EstablishIOPAccess (floppyDMAMapRegister,ES:[DI].DataAddress)	; set ES:[DI] to access DataAddress			MOV	AX, ES			SHR	AX, 12			MOV	DX, FloppyDMAHighSourcePtr			OUT	DX, AX 			MOV	DX, FloppyDMAHighDestPtr			OUT	DX, AX 			MOV	AX, ES			SHL	AX, 4			OR	AX, DI			MOV	DX, FloppyDMALowSourcePtr			OUT	DX, AX 			MOV	DX, FloppyDMALowDestPtr			OUT	DX, AX 			%PopDISI			POP	ES			MOV	AL, ES:[SI].DataTransferCode			; 			CMP	AL, Read					; SELECT DataTransferCode FROM			JE	SetupForRead					;   Read => SetupForRead[] ;			CMP	AL, Write					;   Write => SetupForWrite[] ;			JE	SetupForWrite					; ENDCASE => DataTransferCode _ None ;			MOV	ES:[SI].DataTransferCode, None			;InvalidDataXferCode:	JMP	SHORT	EndSetupDMA SetupForRead:		%OutputWord ( FloppyDMALowSourcePtr, FDCtoDMAport )	; FloppyDMALowSourcePtr _ FDCtoDMAport			%OutputWord ( FloppyDMAHighSourcePtr, 0 )		; FloppyDMAHighSourcePtr _ 0			JMP	SHORT	EndSetupDMASetupForWrite:		%OutputWord ( FloppyDMALowDestPtr, FDCtoDMAport )	; FloppyDMALowDestPtr _ FDCtoDMAport			%OutputWord ( FloppyDMAHighDestPtr, 0 )			; FloppyDMAHighDestPtr _ 0EndSetupDMA:		RETSetupDMApointers	ENDP;;;;--------------------------------------------------------------------------------;;;StopDMAandCounter	PROC							; destroys AX & DXBeginStopDMAandCounter: MOV	FloppyWaitingForDMAInterrupt, MesaFALSE			MOV	FloppyFirstDMAInterrupt, MesaFALSE			%OutputWord ( FloppyDMAControlWord, StopDMA )		; FloppyDMAControlWord _ StopDMA			%OutputWord ( FloppyCounterControlWord, StopCounter )	; FloppyCounterControlWord _ StopCounter			%OutputWord ( FloppyDMATransferCount, 0 )		; FloppyDMATransferCount _ 0			%OutputWord ( FloppyCountRegister, 0 )			; FloppyCountRegister _ 0EndStopDMAandCounter:	RETStopDMAandCounter	ENDP;;;;--------------------------------------------------------------------------------;;;WriteCommandByteToFDC	PROC							; writes AL to FDC, all registers preservedBeginWriteCommandByte:	CALL	LongDelay					; the FDC will choke if you feed it too fast			PUSH	AX						; save AX			PUSH	CX						; save CX			MOV 	CX, 040						; max of 40 tries to Read Main Status RegisterReadyToWriteLoop:	IN	AL, FDCStatusReg				; Read Main Status Register			AND	AL, 11000000B					; we only want to look at RequestForMaster and DataInputOutput			CMP	AL, 10000000B					; wait for data request			JE	ReadyToWrite					; is FDC ready for CommandByte ?			LOOP 	ReadyToWriteLoop				; loop till done or timeoutWriteError:		POP	CX						; restore AX			POP	AX						; restore CX			MOV	FloppyFDCHung, MesaTRUE			CLC			RET							; RETURN [ FALSE ]ReadyToWrite:		POP	CX						; restore AX			POP	AX						; restore CX			%DisableInterruptsTillNextWait				; play it safe			OUT	FDCDataReg, AL					; write byte from AL			STC			RET							; RETURN [ TRUE ]WriteCommandByteToFDC	ENDP;;;;--------------------------------------------------------------------------------;;;IOPEInRom		ENDS;;;;		end of FloppyHandlerDove;;			END
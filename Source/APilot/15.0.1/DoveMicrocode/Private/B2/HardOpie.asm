;Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;-- stored as [Igor]<WMicro>Dove>HardOpie.asm;-- created on  20-Nov-84 17:04:39;-- This file is intended to contain Opie Hardware dependent system constants. ;-- Any device specific constants should be in the definitions file for that device.;-- last edited by:;--	kek    		11-Aug-86 15:40:05	:chgs for multiple options support;--	JAC    		24-Jan-86 10:51:11	:add expansion interrupt;--	JPM    .es	 6-Jul-85 10:56:57	:Move i80186Flags to HardDefs, change millisecondResolution;--	JPM    .es	 1-Jul-85  9:28:56	:Add i8274IrpPendingBit;--	JPM    .es	28-Jun-85 13:17:21	:Restore RAM-needed interrupts and controllers, separating them from ROM-needed ones;--	JPM    		27-Jun-85 17:36:23	:Add umbilicalRecEnable, add enableMask to x macro (in Devices).;--	JPM    		25-Jun-85 11:16:22	:Fix i80186SlaveIntrptOn constant.;--	JPM    		23-May-85 10:58:31	:Add i80186Flags.;--	KEK		13-May-85 19:55:34	:add ETCH TWO milliSecondRes to 6.5MHz ETCH-TWO-IOP clock (used to be 2000D for 8MHz clk). add ETCH TWO pceEmulator interrupt values in Devices.;--	JPM    		13-May-85 15:44:13	:Pare to interrupts needed in ROM, and use new structure.;--	KEK		27-Mar-85 19:53:38	:wrong pendport for 8274... change meaning of specialPendingCmd to mean this is a special interrupt controller mask (use it instead of MyInterruptMask when sending an EOI.;--	KEK		16-Mar-85 15:44:17	:add another ETCH ONE/TWO comment for i80186SlaveIntrptOn.;--	KEK		26-Feb-85 21:34:34	:Add RS232 support.;--	VXS  .pa	20-Nov-84 17:44:34	:Remove deviceResetPort, should now use def from HardDefs.asm;--	VXS  .pa	20-Nov-84 17:05:42	:Creation$NOGEN;List HardDefs.asm here.$INCLUDE		(HardDefs.asm);-------------------------------------------------------------------------;i186 Timer Definitions (Secondary);This set of definitions constitutes Opie's allocation of the internal timers; to the various Opie clients (handlers). This should be the only place that needs; to be modified if we want to change which timer is allocated to which client.;Floppy gets timer 0;IOPE gets timer 2IOPETimerMCWAddr	EQU	i186Timer2MCWAddr	;Timer 2 is used by IOPE.IOPETimerMaxCountReg	EQU	i186Timer2CountAAddr	;Timer 2 is used by IOPE.IOPETimerCountReg	EQU	i186Timer2CountRegAddr	;Timer 2 is used by IOPE.IOPETimerIntCntrlReg	EQU	i186Timer2IntCtlAddr	;Timer 2 is used by IOPE.timerResolution		EQU	20000	;--ETCH ONE AND ETCH THREE!;timerResolution	EQU	16250	;--ETCH TWO!millisecondsPerTick	EQU	10secondResolution	EQU	1000/millisecondsPerTick;Timer requests:ContinousRunWithInterrupts EQU	1110000000010001B;--------------------------------------------------------------------------------;-------------------------; 80186 Interrupt Source types;Current interrupt vector types - note: IP:CS location is Type#*4.%*DEFINE(IntrptType(n))(%n)SoftwareInterruptType		EQU	%IntrptType(96)beginSoftWareIntrptType 	EQU	SoftwareInterruptTypeIntDivErr	EQU	%IntrptType(0)	;Address 00h Divide ErrorIntSnglStp	EQU	%IntrptType(1)	;Address 04h Single stepIntNMI		EQU	%IntrptType(2)	;Address 08h non maskable interruptIntBkpt		EQU	%IntrptType(3)	;Address 0Ch breakpointIntOV		EQU	%IntrptType(4)	;Address 10h interrupt on overflowIntBounds	EQU	%IntrptType(5)	;Address 14h bounds checkIntBadOp	EQU	%IntrptType(6)	;Address 18h unimplimented opcodeIntESCOp	EQU	%IntrptType(7)	;Address 1Ch escape instruction;--------------------------------------------------------------------------------;IOPE interrupt constants:i8259MasterIntrptMaskPort 	EQU	i8259MasterAddr1i8259SlaveIntrptMaskPort 	EQU	i8259SlaveAddr1i8259OptionsSlaveIntrptMaskPort	EQU	i8259OptionsSlaveAddr1;Slave interrupt channels on the master are {3/4}{ETCH1/ETCH2}=RS232, 5=internal devices, 6=186 internal timer, 7{ETCH1}=expansion interrupt controller.;i80186SlaveIntrptOn		EQU	NOT ((NOT i8259EnableIR3) OR (NOT i8259EnableIR5) OR (NOT i8259EnableIR6) OR (NOT i8259EnableIR7))	;--ETCH ONE!i80186SlaveIntrptOn		EQU	NOT ((NOT i8259EnableIR4) OR (NOT i8259EnableIR5) OR (NOT i8259EnableIR6))	;--ETCH TWO!i80186SlaveIntrptOFF		EQU 	NOT i80186SlaveIntrptOni80186AllInhibited		EQU	11111111B	;for shutting off.Masteri8259EOIPort		EQU	i8259MasterAddr0Slavei8259EOIPort		EQU	i8259SlaveAddr0Slavei80186EOIPort		EQU	i186EOIRegAddrMasteri8259MaskPort		EQU	i8259MasterAddr1Slavei8259MaskPort		EQU	i8259SlaveAddr1Slavei80186MaskPort		EQU	i186IntrMaskRegAddr;---------------------------;Here are macros that define the hardware device interrupt structure.;macro that defines all the interrupt controllers in the system.;The Controller macro is called with these parameters:;%'	%Controller(name,intType,slaveEOIPort,PendPort,MaskPort);where	"name" = name of the chip we are defining,;	"intType" = the number of the first vector in the group of eight vectors assigned each interrupt controller chip (should coincide with HardDefs.*ICW2 equates),;	"slaveEOIPort" = the address of the port to which this chip's EOI's must be sent.  A ZERO here flags this chip as the master interrupt controller.;	"PendPort" = the port on the slave where we can look at what slave int is pending.;	"MaskPort" = the port to know/change specific interrupt enable state.subInterruptPort	EQU	8000H	;Sign bit on as flag for ClearAndDismissInterrupts that its a subinterrupt.%*DEFINE(InterruptControllers)(	%*DEFINE(whereDefined)(ROM)	%Controller(i8259Master,32,Null,Null,i8259MasterAddr1)	%Controller(i8259Slave,48,i8259SlaveAddr0, i8259SlaveInServiceRegAddr,i8259SlaveAddr1)	%Controller(i80186Slave,56,i186EOIRegAddr, i186InServiceRegAddr,i186IntrMaskRegAddr)	%Controller(subInterrupts,80,subInterruptPort,Null,Null)	%*DEFINE(whereDefined)(RAM)	%Controller(i8259OptionsSlave,72,i8259SlaveAddr0, i8259SlaveInServiceRegAddr,i8259OptionsSlaveAddr1)	%Controller(i8274Slave,64,i8274EOIPort, i8274DCommACtlrAddr,i8274DCommACtlrAddr));end macro InterruptControllers%*DEFINE(Controller(name,intType,slaveEOIPort,PendPort,MaskPort))($SAVE$GENONLY%name%(IntrptVctType)	EQU	%intType$RESTORE);end Controller macro definition;Generate Vector Type symbols for each interrupt controller:;(i.e. i8259MasterIntrptVctType)	%InterruptControllers;Make softwareIntrptVctType available to IOPMacro without having to include; HardOpie.asm.softwareIntrptVctType	EQU	96%*DEFINE(softwareIntrptVctType)(Defined)	;tell IOPMacro this is already defined.;The Devices macro defines the hardware interrupt configuration that Opie and handlers need.;The -x- macro inside this Devices macro is called with these parameters:;%'	%x(Name,ControlName,Channel,SlaveEOIcommand,enableMask);where	"Name" = the name of the device interrupt.;	"ControlName" = that interrupt controller from which the interrupt is generated.;	"Channel" = the interrupt priority on its particular controller;	"SlaveEOIcommand" = The bits that must be written to the controller's slaveEOIPort to cause an EOI. (Devices on the master 8259 use Null here.);	"enableMask" = The mask that must be AND'ed to the controller's maskPort; to enable the interrupt.  A special case arises for the i8259OptionsSlave; optionsX interrupts, in which this mask must be the mask the EOI's the; i8259OptionsSlave's signal into the i8259Slave chip -- IR6, that is.i8274IrpPendingBit	EQU	02H	;should be in HardDefs?%*DEFINE(Devices)(	%*DEFINE(whereDefined)(ROM)	%x(parity,i8259Master,0,Null,i8259EnableIR0)	%x(umbilicalRec,i8259Master,1,Null,i8259EnableIR1)	%x(umbilicalSend,i8259Master,2,Null,i8259EnableIR2)%'	%x(keyBoard@Mouse,i8259Master,4,Null,i8259EnableIR4)	;-- FOR ETCH ONE!!!	%x(keyBoard@Mouse,i8259Master,3,Null,i8259EnableIR3)	;-- FOR ETCH TWO!!!	%x(display,i8259Slave,0,i8259EOINonSpecific,i8259EnableIR0)	%x(ethernet,i8259Slave,1,i8259EOINonSpecific,i8259EnableIR1)	%x(ethernetSubInt1,subInterrupts,0,Null,Null)	%x(diskDMA,i8259Slave,2,i8259EOINonSpecific,i8259EnableIR2)	%x(diskController,i8259Slave,3,i8259EOINonSpecific,i8259EnableIR3)	%x(floppyController,i8259Slave,4,i8259EOINonSpecific,i8259EnableIR4)	%x(mesaProcessor,i8259Slave,5,i8259EOINonSpecific,i8259EnableIR5)	%x(DMA0@Floppy,i80186Slave,i186IntrChannelforDMA0, i186IntrChannelforDMA0,i186IntrMaskforDMA0)	%x(IOPETimer,i80186Slave,i186IntrChannelforTimer2, i186IntrChannelforTimer2,i186IntrMaskforTimer2)	%*DEFINE(whereDefined)(RAM)%'	%x(pcEmulator,i8259Slave,6,i8259EOINonSpecific,i8259EnableIR6)	;-- FOR ETCH ONE!!!	%x(pcEmulator,i8259Master,7,Null,i8259EnableIR7)	;-- FOR ETCH TWO!!!	%x(TTYTx,i8274Slave,0,i8274EOICommand,i8274IrpPendingBit)	%x(TTYExtStat,i8274Slave,1,i8274EOICommand,i8274IrpPendingBit)	%x(TTYRx,i8274Slave,2,i8274EOICommand,i8274IrpPendingBit)	%x(TTYSpecRx,i8274Slave,3,i8274EOICommand,i8274IrpPendingBit)	%x(RS232Tx,i8274Slave,4,i8274EOICommand,i8274IrpPendingBit)	%x(RS232ExtStat,i8274Slave,5,i8274EOICommand,i8274IrpPendingBit)	%x(RS232Rx,i8274Slave,6,i8274EOICommand,i8274IrpPendingBit)	%x(RS232SpecRx,i8274Slave,7,i8274EOICommand,i8274IrpPendingBit)		%x(DMA1@Extra,i80186Slave,i186IntrChannelforDMA1, i186IntrChannelforDMA1,i186IntrMaskforDMA1)	%x(options0,i8259OptionsSlave,0,i8259EOINonSpecific,i8259EnableIR6)	%x(options1,i8259OptionsSlave,1,i8259EOINonSpecific,i8259EnableIR6)	%x(options2,i8259OptionsSlave,2,i8259EOINonSpecific,i8259EnableIR6)	%x(options3,i8259OptionsSlave,3,i8259EOINonSpecific,i8259EnableIR6)	%x(options4,i8259OptionsSlave,4,i8259EOINonSpecific,i8259EnableIR6)	%x(options5,i8259OptionsSlave,5,i8259EOINonSpecific,i8259EnableIR6)	%x(options6,i8259OptionsSlave,6,i8259EOINonSpecific,i8259EnableIR6)	%x(options7,i8259OptionsSlave,7,i8259EOINonSpecific,i8259EnableIR6));end Devices Macro definition;Define class of symbols for each device of the form:;	<device>Interrupt%*DEFINE(x(name,controlname,channel,slaveEOIcommand,enableMask))(PUBLIC	%name%(Interrupt)%name%(Interrupt)	EQU	%controlname%(IntrptVctType)+%channel)$SAVE$GENONLY	%Devices$RESTORE;Special equate to make it easy for IOPInit to enable umbilical receiveumbilicalRecEnable	EQU	i8259EnableIR1	;assumes channel 1 of master 8259;See IOPData.asm, RAMData.asm for interrupt control block and interrupt; vector generation.
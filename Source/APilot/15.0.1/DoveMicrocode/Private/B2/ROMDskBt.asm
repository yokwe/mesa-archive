$MOD186$PAGELENGTH	(72)$PAGEWIDTH	(136);Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;-- stored as [Iris]<WMicro>Dove>ROMDskBt.asm;-- created on  30-Nov-84 13:44:00;-- last edited by:;--	kek			 4-Sep-85 17:36:42	;mp codes;--	JPM			 3-Aug-85 10:35:55	;Change EEPDefs.asm to ROMEEP.asm.;--	JPM			25-Jul-85 12:56:27	;Fix bug in DoDiskOperation (shouldn't use ES).;--	JPM			22-Jul-85 13:57:39	;Change IOPEInROM alignment to WORD, fix bugs.;--	JPM			18-Jul-85  8:30:17	;Opie redesign conversion.;--	JMM			 9-Jul-85 20:17:58	;Upgraded to new Disk handler.;--	JMM			19-Jun-85 17:10:06	;Upgraded to new IOPLRAM.asm;--	JPM			17-Jun-85  9:07:30	;Align bootloaded code on page boundary (for disk DMA);--	JMM			 4-Apr-85 20:23:06	;Misc. edit.;--	DEG			19-Jan-85 21:06:55	;First release.;--	JMM			30-Nov-84 13:44:00	;First release.NAME		ROMDskBt;--------------------------------------------------------------------------------;$NOLIST$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(ROMBDefs.asm)$INCLUDE	(ROMEEP.asm)$INCLUDE	(DskIOFce.def)$LIST;--------------------------------------------------------------------------------EXTRN			BootStrapHandlerID: ABSEXTRN			DiskHandlerID: ABSEXTRN			DisplayMPCode: NEAR;--------------------------------------------------------------------------------;DiskAddress		STRUC	;Copied from [Iris]<WMicro>Dove>DskHdFce.def;diskCylinder	DW	?;diskSector	DB	?;diskHead	DB	?;DiskAddress		ENDS;---------------;******************************************************************;---------------IOPELocalRAM	SEGMENT	AT 0EXTRN		opieReentry: DWORDEXTRN		bootType: BYTEEXTRN		bootRetryCount: WORDEXTRN		startOfBootBufferSpace: WORDEXTRN		endOfBootBufferSpace: WORDEXTRN		HandlerInitProcTable: DWORDIOPELocalRAM	ENDS;---------------;******************************************************************;---------------;from IORROMBt.asm:;------------------BootStrapIOR	SEGMENT	COMMONEXTRN		bootStrapTask: TaskContextBlockEXTRN		bootDeviceIORSpace: DiskBootContextEXTRN		jumpTable: BootJumpTableBootStrapIOR	ENDS;from IORdisk.asm:;------------------DiskIOR		SEGMENT	COMMONEXTRN		diskFCB: DiskFCBRecordDiskIOR		ENDS;from STKDisk.asm:;------------------DiskSTK		SEGMENT	COMMONEXTRN		EndOfDiskStackSeg: WORD		DiskSTK		ENDS;---------------;******************************************************************;---------------IOPEInROM	SEGMENT	WORD PUBLIC		ASSUME	CS:IOPEInROM		ASSUME	DS:BootStrapIOR;from ROMBoot.asm:;------------------PUBLIC		DiskBootStrap;;--------------------------------------------------------------------------------;;-- Disk BootStrap:;--------------  This module reads in the first page of DiskInitialDove.db into;--------------  IOP local RAM and jumps to it. That is all it does other than;--------------  handling errors encounterd during the attempt to read in the;--------------  page.;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------| Upon exiting this module the following will be true:		|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------DiskBootStrap		PROCStartDiskBoot:		MOV	AX, IOPELocalRAM			MOV	ES, AX			ASSUME	ES:IOPELocalRAM			%CallHandlerInitProc	(DiskHandlerID)			%WaitForSystem				;Give disk a chance to initialize			MOV	WORD PTR bootDeviceIORSpace.diskIOCBDone, Null	; Initialize condition;   The first thing that gets done is the IOCB less the Disk Operation Block (DOB) portion is zeroed out.			MOV	DI, OFFSET bootDeviceIORSpace.diskBootIOCB			MOV	CX, (SIZE DiskIOCBRecord - SIZE DiskDOB) / 2			XOR	AX, AXZeroIOCBLoop:		MOV	WORD PTR [DI], AX			ADD	DI, 2			LOOP	ZeroIOCBLoop;   The next thing to do is to copy the image of the initial DOB to the real; space for the DOB in the IOCB.			PUSH	ES			MOV	AX, DS			MOV	ES, AX			ASSUME	ES:NOTHING			MOV	SI, OFFSET DiskInitialDOB			MOV	DI, OFFSET bootDeviceIORSpace.diskBootIOCB.diskOperationBlock			PUSH	DI				;Save the offset to the DOB on the stack for now.			MOV	CX, (SIZE DiskDOB / 2)CopyLoop:		MOVS	WORD PTR ES:[DI], CS:[SI]	;passed on to the handler.			LOOP	CopyLoop			;can't use REP MOVS w/seg override: might get interrupted			POP	DI				;Fetch the offset to the DOB from the stack.;   The next series of steps page aligns the buffer to be used to read in the first record from the disk.			POP	ES				;Booting uses IOP local RAM			ASSUME	ES:IOPELocalRAM			;for all its work.			MOV	DX, DiskSTK			;The first record of			SHL	DX, Nibble			;DiskInitialDove.db goes			ADD	DX, OFFSET EndOfDiskStackSeg	;after the disk stack segment.			ADD	DX, pageSizeInBytes-1		;The location to jump to			AND	DX, NOT(pageSizeInBytes-1)	;must be at a page			MOV	startOfBootBufferSpace, DX	;boundary.			MOV	bootDeviceIORSpace.diskBootIOCB.diskDataPtrLow, DX			MOV	CH, IOPLogicalOpieAddress			MOV	CL, 0			MOV	bootDeviceIORSpace.diskBootIOCB.diskDataPtrHigh, CX			SHR	DX, Nibble			;Calculate the CS value of 			MOV	jumpTable.iopEntry, nullOffset	;the loaded code's			MOV	jumpTable.iopEntryCS, DX	;entry point.			MOV	DX, DiskIOR			;Limit the size			SHL	DX, Nibble			;of the boot			MOV	endOfBootBufferSpace, DX	;area.;the next instructions set up the disk handler's IOP client condition; to point to the first word of boot IOR space (overlays first word of IOCB)			PUSH	ES			MOV	AX, DiskIOR			MOV	ES, AX			ASSUME	ES:DiskIOR			MOV	diskFCB.rd0.diskIOPClientCondition.handlerID, LOW BootStrapHandlerID			MOV	diskFCB.rd0.diskIOPClientCondition.conditionPtr, OFFSET bootDeviceIORSpace.diskIOCBDone+nonNilPtr			MOV	diskFCB.rd0.diskIOPClientCondition.clientMask, 0			POP	ES			ASSUME	ES:IOPELocalRAMResetDiskHeads:			MOV	bootDeviceIORSpace.diskBootIOCB.diskPageCount, 1			MOV	[DI].diskOperation, RecalibrateDisk			MOV	bootDeviceIORSpace.diskBootIOCB.diskDataXferDirection, noDataOp			; display mp code that initial is ready to start fetching			PUSH	AX			MOV	AX, mpFetchInitial			CALL	DisplayMPCode			POP	AX						CALL	DoDiskOperation			JNC	DiskReadLabelAndData			DEC	bootRetryCount			JZ	FatalDiskBootError			JMP	ResetDiskHeadsDiskReadLabelAndData:			MOV	bootDeviceIORSpace.diskBootIOCB.diskPageCount, 1			MOV	[DI].diskOperation, ReadDiskLabelAndData			MOV	bootDeviceIORSpace.diskBootIOCB.diskDataXferDirection, read			CALL	DoDiskOperation			JNC	GoToRAM			DEC	bootRetryCount			JZ	FatalDiskBootError			JMP	DiskReadLabelAndDataGoToRAM:		JMP	DWORD PTR jumpTable.iopEntryFatalDiskBootError:	MOV	AX, mpInitialError			CALL	DisplayMPCode			%Jam	(BootStrapHandlerID,OFFSET bootStrapTask)			%WaitForSystem		; never returns!DiskBootStrap		ENDP;--------------------------------------------------------------------------------;-- Disk Operations:;--------------  This procedure after some initialization notifies the disk;--------------  handler to perform the required operation.;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|								|;--------------|								|;--------------|	CARRY flag is set on error and reset on success		|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------DoDiskOperation		PROC	NEARDoDiskOperationEntry:;   The next block of code (re-)initializes some fields within the IOCB.			MOV	AL, FALSE			MOV	bootDeviceIORSpace.diskBootIOCB.diskInProgress, AL			MOV	bootDeviceIORSpace.diskBootIOCB.diskComplete, AL			MOV	bootDeviceIORSpace.diskBootIOCB.diskOperationBlockError, AL			MOV	bootDeviceIORSpace.diskBootIOCB.controllerErrorType, AL			MOV	bootDeviceIORSpace.diskBootIOCB.dmaErrorType, AL			MOV	bootDeviceIORSpace.diskBootIOCB.diskError, AL			XOR	AX, AX			MOV	[DI].diskHeaderError, AX			MOV	[DI].diskLabelError, AX			MOV	[DI].diskDataError, AX			MOV	[DI].diskLastError, AX			MOV	[DI].diskMinusSectorCount, -1;   These next few lines of code setup the address of the Input/Output Context Block (IOCB) that is to be used to read the; initial record from the DoveDiskInitial.db file.  First CX:DX will be setup with the segment and offset to the space for; the IOCB.  Next the address is back converted to an OPIE IOP logical address.  And finally the address is enqueued for the; rigid disk handler.			MOV	DX, OFFSET bootDeviceIORSpace.diskBootIOCB			MOV	CH, IOPIORegionOpieAddress			MOV	CL, LOW BootStrapHandlerID			PUSH	ES			MOV	AX, DiskIOR			MOV	ES, AX			ASSUME	ES:DiskIOR			MOV	diskFCB.rd0.diskIOPNextHigh, CX			MOV	diskFCB.rd0.diskIOPNextLow, DX			MOV	diskFCB.diskStartHandlerForIOP, TRUE			POP	ES			ASSUME	ES:IOPELocalRAM			PUSH	DI;   Everything is now setup to carry out the disk operation.  The rigid disk; handler is notified that it has work to do and then this disk booting task falls; asleep waiting for the disk code to complete.			%NotifyHandlerCondition	(DiskHandlerID,OFFSET diskFCB.diskConditionWork)			%WaitForCondition	(OFFSET bootDeviceIORSpace,noTimeout);   Upon completion check to see if there has been an error or not.  If an error; occured or if the handler is not in its normal state then go through the error; exit path which attempts to get the handler back to a valid state.OperationComplete:			POP	DI			TEST	bootDeviceIORSpace.diskBootIOCB.diskError, TRUE			JNZ	ErrorDoDiskOperationExit			CLC			RETErrorDoDiskOperationExit:			STC			RETDoDiskOperation		ENDP;--------------------------------------------------------------------------------;--------------------------------------------------------------------------------;Disk EPROM Boot Data:;   As far as the IOP is concerned the constants in this region are byte-swapped.; Any word quantity assigned must be byte-swapped.;   The fields should be accessed through (diskIOCB).diskOperationBlock.(mumble); where (mumble) is a field within the DiskDOB STRUCture in DskHdFce.def .DiskInitialDOB:			;Actually this is of type DiskDOB (DiskOperationBlock)		DD	0	;the first four bytes are for the ECC syndrome		DW	-1	;the two complement of the number of sectors in transfer		DB	16	;number of sectors per track.		DB	0		DB	4	;heads per cylinder		DB	0		DB	32h	;132h = 306d  number of cylinders per drive plus one		DB	1		DB	0	;sectors are numbered 0-15		;Above five byte values should be gotten from EEPROM but since we are		;only reading one record it does not matter unless the RAM code uses		;the values passed here. - jmm :85-07-08.		DB	0		DW	-1	;cylinder where reduced write begins (-1 if not used)		DB	80h	;0080h = 128   cylinder where precompensation begins		DB	0		DB	0FFH	;write end count = 0FFH		DB	0		DW	0	;header error field		DW	0	;label error field		DW	0	;data error field		DW	0	;last error field		DW	-1	;current cylinder		DB	1	;1 = CRC, 0 = ECC		DB	0		DiskAddress	<0,0,1>		;Location of DiskInitialDove.db		DW	0		DW	0		DB	0	;DiskCtlrStatusRec		DB	0	;DiskDriveStatusRec		DB	0	;restore operation		DB	0		DW	0	;tracks to format count 2's complement		DB	(SIZE DiskLabelImage) DUP (0)	;end of DOB image/templateIOPEInROM		ENDS;********************************************************************************			END
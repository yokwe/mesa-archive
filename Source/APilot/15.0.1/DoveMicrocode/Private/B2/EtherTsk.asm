$MOD186$PAGELENGTH	(72)$PAGEWIDTH	(136);Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;Ethernet handler;stored as [Idun]<WMicro>Dove>IOP2-DCM2-MPB2>EtherTsk.asm;created on  5-Jul-84 16:48:55;last edited by:;	MS	 8-Mar-89 14:47:02	Fix for enqueue problem;	BKI	25-Mar-86 11:48:20	Fix for receiving odd-length packets;	BKI	 5-Feb-86 17:53:04	Process all iocbs on output queue per;					down notify.;	BKI	 6-Sep-85 16:30:00	Support B2;	BKI	 2-Sep-85 22:40:16	Include WaitForSystem calls;	BKI	29-Aug-85 12:02:26	Fix rbFilled=0 and rbdEndList=1 bugs;	BKI	19-Aug-85 13:03:20	Surround StartRU call with Disable/Enable;	JPM	15-Aug-85 10:17:38	Fix bug in StartRU, caused by prev. chg;	JPM	14-Aug-85  9:37:55	Make StartRU non-PUBLIC (so don't need;					EstablishHandlerAccess);	BKI	12-Aug-85 15:02:57	Undo workaround. Doesn't seem to work.;					Remove performance monitor code.;	BKI	11-Aug-85 16:58:02	Use variable descriptor and buffer;					attributes. Add iocbType: {iocbReset,;					iocbStartRU}.;	BKI	 4-Aug-85 21:47:47	Set rbLength to 290 instead of 296 as a;					workaround to RU deadlock bug.;	JPM	22-Jul-85  9:59:14	Change IOPEInROM alignment to WORD;	JPM	16-Jul-85 10:27:24	Opie redesign conversion;	BKI	28-Jun-85 19:46:42	Add iocbType: iocbReset;	BKI	28-Jun-85 11:30:09	Pass software lock to AdvanceMesaIOCB;	BKI	26-Jun-85 18:51:55	Use variable descriptor and buffer;					attributes;	JPM	31-May-85  9:04:22	back out ResetI586 changes, unprogram;					map reg 7;	JPM	28-May-85  9:58:00	temp move ResetI586 to its own segment;					(so can relocate it in local RAM during;					testing);	KEK	22-May-85 17:03:16	add B0-ONLY change of BlockSysMem usage;	KEK	11-Apr-85 10:14:38	increase stackSize to default.;	KEK	29-Mar-85 12:33:10	added interruptTimeout stuff, new BadEthernetInt proc.;	BKI	14-Jan-85 17:03:59	Stable system versionNAME		EtherTskPUBLIC		EthernetInit$NOLIST$INCLUDE	(IOPDefs.asm)$INCLUDE	(QueDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(QueMacro.asm)$INCLUDE	(HardDefs.asm)$INCLUDE	(EthIOFce.asm)$LISTEXTRN		EthernetHandlerID: ABSEXTRN		ethernetInterrupt: ABSEXTRN		ethernetSubInt1Interrupt: ABSEthernetIOR	SEGMENT	COMMONEXTRN		iopEtherOutQueSemaphore: WORDEXTRN		mesaEtherOutQueSemaphore: WORDEXTRN		iopEtherInQueSemaphore: WORDEXTRN		mesaEtherInQueSemaphore: WORDEXTRN		beginFBL: WORDEXTRN		bufferCopyTask: TaskContextBlockEXTRN		bufferCopyWork: Condition, cb: CommandBlockEXTRN		clientBufLength: WORD, clientBufPtr: OpieAddressEXTRN		clientStatus: WORD, descriptorArea: WORD, endFBL: WORDEXTRN		endRDL: WORDEXTRN		etherCmdAvail: Condition, etherCNATask: TaskContextBlockEXTRN		etherInQueue: QueueBlock, etherInQueueForBindweed: QueueBlockEXTRN		etherInWorkMask: WORD, etherLockMask: WORDEXTRN		ethernetTask: TaskContextBlock, etherOutQueue: QueueBlockEXTRN		etherOutWorkMask: WORD, i586Dump: WORD, inBufferAvail: ConditionEXTRN		mesaClientStateRequest: WORD, mesaInClientState: WORDEXTRN		mesaInQueue: QueueBlock, mesaOutClientState: WORDEXTRN		mesaOutQueue: QueueBlockEXTRN		rbdCount: BYTE, rbdToProcess: WORD, rbLength: WORDEXTRN		rfdCount: BYTE, scb: I586SCB, tbdCount: BYTE;DEBUGEXTRN		debugInfo: WORDEthernetIOR	ENDSEthernetSTK	SEGMENT	COMMONEXTRN		EthernetStack: WORD, EtherCNAStack: WORD, BufferCopyStack: WORDEthernetSTK	ENDS;IOPELocalRam	SEGMENT AT 0EXTRN		i82586ISPAddress: I586ISCPIOPELocalRam	ENDSIOPEInROM	SEGMENT	WORD PUBLIC		ASSUME	CS:IOPEInROMwordOpieAddress	EQU	020H; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;;										;;	HANDLER MACROS								;;										;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;%*DEFINE	(ClearRFD(RFDPtr))(		AND	BYTE PTR [%RFDPtr].rfdStatus+1, NOT HIGH (MASK rfdDone + MASK rfdBusy + MASK rfdOkay)		MOV	[%RFDPtr].rbdPtr, rbdPtrNil)%*DEFINE	(WaitForSCBReady)		LOCAL	Lbl(%Lbl:		CMP	scb.scbCommand, 0		JNE	%Lbl)Ether0:						;for debugging only; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;;										;;	HANDLER ERROR ROUTINE							;;										;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;;										;;	HANDLER INITIALIZATION ROUTINE						;;										;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;EthernetInit	PROC	FAR		%InitializeTask (EthernetHandlerID,OFFSET bufferCopyTask,BufferCopyTaskInit,OFFSET BufferCopyStack)		%InitializeTask	(EthernetHandlerID,OFFSET etherCNATask,CNATaskInit,OFFSET EtherCNAStack)		%InitializeTask	(EthernetHandlerID,OFFSET ethernetTask,EthernetTaskInit,OFFSET EthernetStack)		RETEthernetInit	ENDP; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;;										;;	HANDLER TASK INITIALIZATION ROUTINE					;;										;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;EthernetTaskInit:		ASSUME	DS:EthernetIOR		%ThisTaskServices (ethernetInterrupt,BadEthernetInt)		%GetLockMask		MOV	etherLockMask, AX		MOV	tbdCount, 2		MOV	rfdCount, 6		MOV	rbdCount, 8		MOV	rbLength, 296		%DisableInterruptsTillNextWait		%Enable	(ethernetInterrupt); * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;;										;;	PRIMARY INTERRUPT ROUTINE						;;										;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;scbStatHigh	EQU	BYTE PTR scb.scbStatus+1scbStatLow	EQU	BYTE PTR scb.scbStatusscbCmdHigh	EQU	BYTE PTR scb.scbCommand+1scbCmdLow	EQU	BYTE PTR scb.scbCommandWaitForI586:	%WaitForInterrupt	()		%WaitForSCBReady		MOV	AH, scbStatHigh		IN	AL, ClrENetIntr		;isolate interrupt reasons		AND	AH, HIGH (MASK intCX + MASK intFR + MASK intCNA + MASK intRNR)		MOV	scbCmdHigh, AH		;acknowledge interruptsCheckFR:	TEST	AH, HIGH MASK intFR		JZ	CheckCNA		INC	BYTE PTR debugInfo+1	;DEBUG: rcv counter		%NotifyCondition	(OFFSET bufferCopyWork)CheckCNA:	TEST	AH, HIGH MASK intCNA		JZ	CheckRNR		%SubInterrupt	(ethernetSubInt1Interrupt)CheckRNR:	TEST	AH, HIGH MASK intRNR		JZ	CheckCXCheckCX:	TEST	AH, HIGH MASK intCX		JZ	IntCheckDoneIntCheckDone:	OUT	ENetAttn, AL		JMP	WaitForI586; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;;										;;	SUB INTERRUPT (RECEIVE NOT READY) ROUTINE					;;										;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;;										;;	SUB INTERRUPT (FRAME RECEIVE) ROUTINE					;;										;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;;										;;	BUFFER COPY TASK ROUTINE						;;										;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;BufferCopyTaskInit:		ASSUME	DS:EthernetIOR		%GetWorkMaskForCondition	(OFFSET inBufferAvail)		MOV	etherInWorkMask, AXWaitForCopyWork:MOV	iopEtherInQueSemaphore, 0			%WaitForCondition	(OFFSET bufferCopyWork,noTimeout)CheckNextRFD:	MOV	SI, endRDL		MOV	BX, [SI].rfdLink		MOV	AX, [BX].rfdStatus		TEST	AH, HIGH MASK rfdDone		JZ	WaitForCopyWork		MOV	clientStatus, AX		PUSH	AX		INC	BYTE PTR debugInfo	;DEBUG: rcv counter		MOV	AX, debugInfo		;DEBUG: rcv counter		OUT	WriteLED, AX		;DEBUG: rcv counter		POP	AX		MOV	DX, [BX].rbdPtr		;save pointer to RBD		MOV	rbdToProcess, DXReturnRFD:	%ClearRFD	(BX)		PUSH	BX		%Disable	(ethernetInterrupt)		POP	BX		OR	[BX].rfdControl, MASK rfdEndList	;set endList flag		MOV	endRDL, BX		AND	[SI].rfdControl, NOT (MASK rfdEndList)	;clr endList flag		TEST	scbStatLow, LOW MASK ruNoRsrcs		JZ	LocateClientBuffer		CALL	StartRULocateClientBuffer:		%Enable	(ethernetInterrupt)		TEST	AH, HIGH MASK rfdOkay	;check rfd status okay bit		JZ	CheckMesaIOPInQueues	;jump if frame errorsocketOffset	EQU	30		CMP	WORD PTR [SI+socketOffset], bindweedSocket		JNE	CheckMesaIOPInQueuesCheckBindweedInQueue:		%JumpIfQueueNextNil	(etherInQueueForBindweed, DropBndwdFrame)		MOV	DX, etherInQueueForBindweed.queueNext.OpieAddressLow		MOV	CX, etherInQueueForBindweed.queueNext.OpieAddressHigh		CALL	ProcessInIOCB		%AdvanceQueue	(etherInQueueForBindweed,nextIOCB,mapped)		JMP	FrameDoneDropBndwdFrame:;Drop frame on the floor, otherwise we may lose important Mesa/IOP frames.		MOV	BX, rbdToProcessReturnBndwdRBD:	MOV	AH, BYTE PTR [BX].rbdStatus+1		CALL	ReturnRBDtoFBL		TEST	AH, HIGH MASK endOfFrame		JZ	ReturnBndwdRBD1		JMP	FrameDroppedReturnBndwdRBD1:		MOV	BX, [BX].rbdNext		JMP	ReturnBndwdRBDCheckMesaIOPInQueues:		MOV	AX, mesaClientStateRequest		MOV	mesaInClientState, AX		OR	AX, AX		JZ	CheckIOPInQueueCheckMesaInQueue:		%JumpIfMesaIOCBNextNil	(mesaInQueue.queueNext, CheckIOPInQueue)		MOV	DX, mesaInQueue.queueNext.OpieAddressLow		MOV	CH, mesaEnvBaseWord		CALL	ProcessInIOCB		;*******Semaphore		CLIInCheck:	%MesaLockedOut       	(MOV, OFFSET iopEtherInQueSemaphore, 1, etherLockMask)		TEST	mesaEtherInQueSemaphore, 1		JZ	InOK		%MesaLockedOut       	(MOV, OFFSET iopEtherInQueSemaphore, 0, etherLockMask)		JMP	InCheck	InOK:		%AdvanceMesaIOCB	(mesaInQueue.queueNext,nextIOCB,etherLockMask,mapped)		MOV	iopEtherInQueSemaphore, 0		STI		JMP	FrameDoneCheckIOPInQueue:		%JumpIfQueueNextNil	(etherInQueue, WaitForBuffer)		MOV	DX, etherInQueue.queueNext.OpieAddressLow		MOV	CX, etherInQueue.queueNext.OpieAddressHigh		CALL	ProcessInIOCB		%AdvanceQueue	(etherInQueue,nextIOCB,mapped)FrameDone:	OR	ES:[DI].iocbStatus, MASK iocbDone		%NotifyClientCondition	(ES:[DI].iocbCondition)FrameDropped:	%WaitForSystem		JMP	CheckNextRFDWaitForBuffer:	;INC	WORD PTR debugInfo+4		;JMP	DropBndwdFrame		%WaitForCondition	(OFFSET inBufferAvail,noTimeout)		JMP	CheckMesaIOPInQueuesProcessInIOCB	PROC	NEAR;CX:DX: Opie address of IOCB		PUSH	CX		PUSH	DX		%EstablishIOPAccess	(generalMapRegister,CX-DX)		MOV	ES:[DI].iocbStatus, MASK iocbHandled		MOV	AX, clientStatus		MOV	ES:[DI].i586Status, AX		MOV	BYTE PTR clientStatus+1, IOCBStat<>		MOV	AX, ES:[DI].iocbVariant.bufLength		MOV	clientBufLength, AX		MOV	AX, ES:[DI].iocbVariant.bufAddr.OpieAddressLow		MOV	clientBufPtr.OpieAddressLow, AX		MOV	AX, ES:[DI].iocbVariant.bufAddr.OpieAddressHigh		MOV	clientBufPtr.OpieAddressHigh, AX		MOV	BX, rbdToProcess	;get RBD ptr		CMP	BX, rbdPtrNil		JE	FinishInIOCBProcessRBD:	MOV	AX, [BX].rbdStatus		TEST	AH, HIGH MASK rbFilled		JZ	ReturnRBD		AND	AH, NOT HIGH (MASK endOfFrame + MASK rbFilled)	;AX _ actual count		CMP	AX, clientBufLength		JLE	BufferSpaceOK		OR	BYTE PTR clientStatus+1, MASK frameTooLong		MOV	AX, clientBufLength	;frame size > buffer sizeBufferSpaceOK:	SUB	clientBufLength, AX		MOV	DX, [BX].rbAddress		MOV	CL, [BX].rbAddrH		CALL	IOROffsetFromPhysical		MOV	SI, DX			;DS:SI set up for CopyBuffer		MOV	DX, clientBufPtr.OpieAddressLow		MOV	CX, clientBufPtr.OpieAddressHigh		PUSH	BX			;save the RBD ptr		MOV	BX, AX		TEST	CH, wordOpieAddress		JZ	UpdateBufPtr		SHR	AX, 1UpdateBufPtr:	ADD	clientBufPtr.OpieAddressLow, AX		ADC	clientBufPtr.OpieAddressA23toA16, 0		CALL	CopyBuffer		POP	BXReturnRBD:	MOV	AH, BYTE PTR [BX].rbdStatus+1		MOV	AL, BYTE PTR [BX].rbdControl+1		CALL	ReturnRBDtoFBL		TEST	AH, HIGH MASK endOfFrame		JNZ	FinishInIOCB		TEST	AH, HIGH MASK rbFilled		JZ	FinishInIOCB		TEST	AL, HIGH MASK rbdEndList		JNZ	FinishInIOCB		MOV	BX, [BX].rbdNext		JMP	ProcessRBDFinishInIOCB:	POP	DX		POP	CX		%EstablishIOPAccess	(generalMapRegister,CX-DX)		MOV	AX, ES:[DI].iocbVariant.bufLength		SUB	AX, clientBufLength		MOV	ES:[DI].iocbVariant.inputCount, AX		MOV	AH, BYTE PTR clientStatus+1		TEST	AH, MASK frameTooLong		JNZ	SetRcvStatus		TEST	BYTE PTR ES:[DI].i586Status+1, HIGH MASK rfdOkay		JZ	SetRcvStatus		OR	AH, MASK iocbOkaySetRcvStatus:	MOV	ES:[DI].iocbStatus, AH		RETProcessInIOCB	ENDPReturnRBDtoFBL	PROC	NEAR;Arguments:	BX:	Offset of RBD to return		;clear rbd		AND	BYTE PTR [BX].rbdStatus+1, NOT HIGH (MASK endOfFrame + MASK rbFilled)		PUSH	BX		%Disable	(ethernetInterrupt)		POP	BX		;set endList flag		OR	BYTE PTR [BX].rbdControl+1, HIGH MASK rbdEndList		MOV	SI, endFBL		;clr endList flag		AND	BYTE PTR [SI].rbdControl+1, NOT HIGH (MASK rbdEndList)		MOV	endFBL, BX		TEST	scbStatLow, LOW MASK ruNoRsrcs		JZ	ReEnableIntr		CALL	StartRUReEnableIntr:	PUSH	BX		%Enable	(ethernetInterrupt)		POP	BX		RETReturnRBDtoFBL	ENDP; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;;										;;	SUB INTERRUPT (COMMAND NOT ACTIVE) ROUTINE				;;										;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;CNATaskInit:		ASSUME	DS:EthernetIOR		%ThisTaskServices	(ethernetSubInt1Interrupt,BadEthernetInt)		%GetWorkMaskForCondition	(OFFSET etherCmdAvail)		MOV	etherOutWorkMask, AXWaitForCommand:	MOV	iopEtherOutQueSemaphore, 0		%WaitForCondition	(OFFSET etherCmdAvail,noTimeout)CheckMesaIOPOutQueues:		MOV	AX, mesaClientStateRequest		MOV	mesaOutClientState, AX		OR	AX, AX		JZ	CheckIOPOutQueueCheckMesaOutQueue:		%JumpIfMesaIOCBNextNil	(mesaOutQueue.queueNext, CheckIOPOutQueue)		MOV	DX, mesaOutQueue.queueNext.OpieAddressLow		MOV	CH, mesaEnvBaseWord		CALL	ProcessOutIOCB		;*******Semaphore			CLIOutCheck:	%MesaLockedOut       	(MOV, OFFSET iopEtherOutQueSemaphore, 1, etherLockMask)		TEST	mesaEtherOutQueSemaphore, 1		JZ	OutOK		%MesaLockedOut       	(MOV, OFFSET iopEtherOutQueSemaphore, 0, etherLockMask)		JMP	OutCheck		OutOK:		%AdvanceMesaIOCB	(mesaOutQueue.queueNext,nextIOCB,etherLockMask,mapped)		MOV	iopEtherOutQueSemaphore, 0		STI				OR	ES:[DI].iocbStatus, MASK iocbDone		%NotifyClientCondition	(ES:[DI].iocbCondition)		%JumpIfQueueNextNil	(etherOutQueue, CheckMesaIOPOutQueues)CheckIOPOutQueue:		;%'JumpIfQueueNextNil	(etherOutQueue, WaitForCommand);Zettai TORUNA !!!!!!! This comment line is required due to Intel's 186 Assembler's problem : Handling commented out MACRO.;		CMP	etherOutQueue.queueNext.OpieAddressType, nilOpieAddress		JNZ	CheckIOPOutQueue1		JMP	WaitForCommandCheckIOPOutQueue1:		MOV	DX, etherOutQueue.queueNext.OpieAddressLow		MOV	CX, etherOutQueue.queueNext.OpieAddressHigh		CALL	ProcessOutIOCB		%AdvanceQueue	(etherOutQueue,nextIOCB,mapped)		OR	ES:[DI].iocbStatus, MASK iocbDone		%NotifyClientCondition	(ES:[DI].iocbCondition)		JMP	CheckMesaIOPOutQueuesProcessOutIOCB	PROC	NEARbytesPerPage	EQU	512cbStatHigh	EQU	BYTE PTR cb.cbStatus+1		PUSH	CX		;need to reestablish map if dump status		PUSH	DX		%EstablishIOPAccess	(generalMapRegister,CX-DX)		MOV	ES:[DI].iocbStatus, MASK iocbHandled		MOV	AL, ES:[DI].iocbType		SHR	AL, 4		CMP	AL, iocbOutput		JE	ProcessXmitIOCB		CMP	AL, iocbCommand		JE	ProcessCmdIOCB		MOV	BX, OFFSET ProcessResetIOCB		CMP	AL, iocbReset		JE	ProcessNonCUIOCB		MOV	BX, OFFSET ProcessStartRUIOCBProcessNonCUIOCB:		CALL	BX		JMP	ProcessOutIOCBExitProcessCmdIOCB:	MOV	AL, ES:[DI].iocbType		MOV	cb.cbCommand, AL		MOV	CX, cbParmsSize/2		XOR	BX, BXMoveIOCBCmd:	MOV	AX, WORD PTR ES:[DI][BX].iocbVariant.cmdParms		MOV	WORD PTR cb.cbParms[BX], AX		ADD	BX, 2		LOOP	MoveIOCBCmd		CMP	cb.cbCommand, acDumpStatus		JNE	StartCU		MOV	cb.cbParms.dumpBuffer, OFFSET i586Dump		JMP	StartCUProcessXmitIOCB:tbdCtlHigh	EQU	BYTE PTR [SI].tbdControl+1		MOV	cb.cbCommand, CBCmd<acTransmit>		MOV	SI, OFFSET descriptorArea		MOV	cb.cbParms.tbdPtr, SI;Set up transmit buffer descriptors		MOV	DX, ES:[DI].iocbVariant.bufAddr.OpieAddressLow		MOV	CX, ES:[DI].iocbVariant.bufAddr.OpieAddressHigh		MOV	BX, ES:[DI].iocbVariant.bufLength;If Mesa VM address, then buffer is not contiguous in real memory		TEST	CH, wordOpieAddress		JZ	SetUpLastTBD	;jump if not virtual bufferXmitVirtualBfr:	MOV	AL, DL		NOT	AL		XOR	AH, AH		INC	AX		SHL	AX, 1		;AX: number of bytes to next page boundarySetUpNextTBD:	CMP	AX, BX		;Last page of buffer?		JLE	InitializeTBDSetUpLastTBD:	MOV	AX, BX		;Last page, so set up countInitializeTBD:	MOV	[SI].tbdControl, AX		PUSH	CX		PUSH	DX		%ConvertAddress	(CX-DX)		MOV	[SI].tbAddress, DX		MOV	[SI].tbAddrH, CL		POP	DX		POP	CX		SUB	BX, AX		JZ	TerminateTDL		XOR	DL, DL		;point to next part of Mesa VM buffer		ADD	DH, 1		ADC	CL, 0		MOV	AX, bytesPerPage;AX: number of bytes to next page boundary		ADD	SI, SIZE TransmitBufferDesc		JMP	SetUpNextTBDTerminateTDL:	OR	tbdCtlHigh, HIGH MASK tbdEndListStartCU:	AND	cbStatHigh, NOT HIGH (MASK cbDone + MASK cbBusy)		%DisableInterruptsTillNextWait		%WaitForSCBReady		MOV	scbCmdHigh, HIGH SCBCmd<,,,,,ccStart>		OUT	ENetAttn, AL		PUSH	DI		%WaitForInterrupt	(1)	;time out after one second		PUSHF		%WaitForSystem		POPF		POP	DI		MOV	CX, cb.cbStatus		MOV	ES:[DI].i586Status, CX		JNC	CheckCBOkay		OR	ES:[DI].iocbStatus, MASK cnaTimeout		JMP	SHORT CheckForTDRCheckCBOkay:	TEST	CH, HIGH MASK cbOkay		JZ	CheckForTDR		OR	ES:[DI].iocbStatus, MASK iocbOkayCheckForTDR:	CMP	cb.cbCommand, CBCmd<acTDR>		JNE	CheckForDump		MOV	AX, cb.cbParms.tdrResults		MOV	WORD PTR ES:[DI].iocbVariant.cmdParms.tdrResults, AXCheckForDump:	CMP	cb.cbCommand, CBCmd<acDumpStatus>		JE	WriteDumpBufferProcessOutIOCBExit:		ADD	SP, 4		RETWriteDumpBuffer:;ToDo: should do a WaitForSystem here		MOV	SI, cb.cbParms.dumpBuffer		MOV	BX, SIZE I586DumpBuffer		MOV	DX, ES:[DI].iocbVariant.cmdParms.dumpBuffer.OpieAddressLow		MOV	CX, ES:[DI].iocbVariant.cmdParms.dumpBuffer.OpieAddressHigh		CALL	CopyBufferMapIOCBExit:	POP	DX		POP	CX		%EstablishIOPAccess	(generalMapRegister,CX-DX)		RETProcessOutIOCB	ENDPProcessResetIOCB	PROC	NEAR		PUSH	ES		PUSH	DI		%Restart	(EthernetHandlerID,OFFSET bufferCopyTask,WaitForCopyWork,OFFSET BufferCopyStack)		CALL	SetUpISCP		CALL	ResetI586		CALL	SetUpCBL		PUSH	AX		CALL	SetUpRFA		POP	AX		CALL	SetUpSCB		;point to CBL and RFA		%ControlRegister	(CRNotBlockSysMem,NOT CRNotBlockSysMem)	;for B2		%DisableInterruptsTillNextWait		OUT	ENetAttn, AL		%WaitForInterrupt	(1)	;time out after one second		PUSHF		%ControlRegister	(CRNotBlockSysMem,CRNotBlockSysMem)	;for B2		%WaitForSystem		POPF		POP	DI		JNC	CheckISCPBusy		POP	ES		OR	ES:[DI].iocbStatus, MASK cnaTimeout		JMP	SHORT ProcessResetIOCBExitCheckISCPBusy:	MOV	BX, IOPELocalRAM		MOV	ES, BX		ASSUME	ES:IOPELocalRAM		TEST	i82586ISPAddress.iscpBusy, 1		POP	ES		ASSUME	ES:NOTHING		JNZ	ProcessResetIOCBExit		OR	ES:[DI].iocbStatus, MASK iocbOkayProcessResetIOCBExit:		RETProcessResetIOCB	ENDPProcessStartRUIOCB	PROC	NEAR		%Disable	(ethernetInterrupt)		CALL	StartRU		%Enable	(ethernetInterrupt)		OR	ES:[DI].iocbStatus, MASK iocbOkay		RETProcessStartRUIOCB	ENDP		ASSUME	DS:NOTHING; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;;										;;	SUB INTERRUPT (COMMAND COMPLETED) ROUTINE					;;										;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;;										;;	INTERRUPT EXCEPTION ROUTINES						;;										;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;BadEthernetInt	PROC	FAR;		INC	unexpectedInterruptCount		RETBadEthernetInt	ENDP; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;;										;;	SUPPORT PROCEDURES							;;										;; * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *	;CopyBuffer	PROC	NEAR;Description:	Copies a contiguous IORegion word-aligned buffer to either a;		buffer in the IOP logical or Mesa VM address space.;Arguments:	DS:SI:	Address of IORegion source buffer;		CX:DX:	Address of destination buffer;		BX:	Length of IORegion buffer (in bytes)wordsPerPage	EQU	bytesPerPage/2		PUSH	AX;find next page boundary		INC	BX	;round up (not down) to even number of bytes		SHR	BX, 1		MOV	AX, DX		;AX: number of words to next page boundary;CX:DX _ If Mesa VM address, then word address else byte address		TEST	CH, wordOpieAddress		JNZ	WordsToNextPage		SHR	AX, 1		;Make IOP byte address into word addressWordsToNextPage:		NOT	AL		XOR	AH, AH		INC	AXCopyPage:	CMP	AX, BX		;Last page of buffer?		JLE	MapVMBuffer		MOV	AX, BX		;Last page, so set up countMapVMBuffer:	PUSH	CX		PUSH	DX		PUSH	AX		%EstablishIOPAccess	(generalMapRegister,CX-DX)		POP	AX		MOV	CX, AX		;set up count for repeat move string		CLD		REP	MOVSW		POP	DX		POP	CX		SUB	BX, AX		JZ	BufferCopyDone		XOR	DL, DL		;point to next page of destination buffer;CX:DX _ If Mesa VM address, then word address else byte address		TEST	CH, wordOpieAddress		JNZ	NextDestPage		OR	DH, 1		;tricky way of adding 2 and clearing LSbNextDestPage:	ADD	DH, 1		ADC	CL, 0		MOV	AX, wordsPerPage;AX: number of words to next page boundary;ToDo: Insert WaitForSystem to obey 100us rule.  Need to save registers.		JMP	CopyPageBufferCopyDone:	POP	AX		RETCopyBuffer	ENDPInitSCB		PROC	NEAR; This procedure is for B2 support.  The i82586 cannot initialize the SCB due to BlockSysMem.		MOV	AX, DS		MOV	ES, AX		MOV	DI, OFFSET scb		MOV	CX, (SIZE I586SCB)/2		XOR	AX, AX		CLD		REP	STOSW		ASSUME	DS:EthernetIOR		MOV	scbStatHigh, HIGH (MASK ackCX + MASK ackCNA)		RETInitSCB		ENDPIOROffsetFromPhysical	PROC	NEAR;Description:	Converts 24-bit real address into an IORegion relative address.;Arguments:	CL:DX	24-bit real address;Returns:	DX:	IORegion offset		PUSH	AX		MOV	AX, DS		SHL	AX, Nibble		SUB	DX, AX		POP	AX		RETIOROffsetFromPhysical	ENDPResetI586	PROC	NEAR		IN	AL, ClrENetIntr	; clear pending interrupt		%Reset	(resetEthernetController)		CALL	InitSCB		MOV	AL, 0FFH		MOV	DX, daybreakMapIOAddressIOPBase+7		OUT	DX, AL		RETResetI586	ENDPSetUpCBL	PROC	NEAR;This procedure only sets the invariant fields of the command block and;transmit buffer descriptors.  ProcessIOCB must fill in the rest.;Returns:	AX:	Pointer to descriptorArea for RFDs		ASSUME	DS:EthernetIOR		MOV	cb.cbControl, CBCtl<1>	;set control flags		MOV	cb.cbLink, 0		;not necessary		XOR	CH, CH		MOV	CL, tbdCount		MOV	AX, OFFSET descriptorAreanextTBD:	MOV	BX, AX		ADD	AX, SIZE TransmitBufferDesc		MOV	[BX].tbdNext, AX		LOOP	nextTBD		MOV	[BX].tbdNext, 0		;not necessary		RET		ASSUME	DS:NOTHINGSetUpCBL	ENDPSetUpISCP	PROC	NEAR		MOV	AX, IOPELocalRAM	;iscp should really be in IORegion		MOV	ES, AX		ASSUME	ES:IOPELocalRAM		MOV	i82586ISPAddress.iscpBusy, 1		MOV	i82586ISPAddress.scbOffset, OFFSET scb		MOV	CH, IOPIORegionOpieAddress		MOV	CL, LOW EthernetHandlerID		XOR	DX, DX			;DX _ OFFSET 0		%ConvertAddress	(CX-DX)		MOV	i82586ISPAddress.scbBase, DX		MOV	i82586ISPAddress.scbBaseH, CL		RETSetUpISCP	ENDPSetUpRFA	PROC	NEAR;This procedure must set up the RFA so that we can immediately start receiving frames.;Arguments:	AX:	Pointer to descriptorArea for RFDs;set up RDL (receive descriptor list)		ASSUME	DS:EthernetIOR		XOR	CH, CH		MOV	CL, rfdCount		PUSH	AXnextRFD:	MOV	BX, AX			;BX: current RFD		%ClearRFD	(BX)		AND	[BX].rfdControl, RFDCtl<,,1>	;set control flags		ADD	AX, SIZE ReceiveFrameDesc	;AX: next RFD		MOV	[BX].rfdLink, AX		LOOP	nextRFD		POP	[BX].rfdLink			;make circular		OR	[BX].rfdControl, MASK rfdEndList	;set endList flag		MOV	endRDL, BX		MOV	BX, [BX].rfdLink		MOV	[BX].rbdPtr, AX		;connect rfd to FBL;set up FBL (free buffer list)		PUSH	AX		XOR	CH, CH		MOV	CL, rbdCount		IMUL	DX, CX, SIZE ReceiveBufferDesc		ADD	DX, AX			;DX: RB for the current RBD		MOV	SI, rbLengthnextRBD:	MOV	BX, AX			;BX: current RBD		AND	BYTE PTR [BX].rbdStatus+1, NOT HIGH (MASK endOfFrame + MASK rbFilled)		ADD	AX, SIZE ReceiveBufferDesc		MOV	[BX].rbdNext, AX		PUSH	CX		PUSH	DX		MOV	CH, IOPIORegionOpieAddress		MOV	CL, LOW EthernetHandlerID		%ConvertAddress	(CX-DX)		MOV	[BX].rbAddress, DX		MOV	[BX].rbAddrH, CL		POP	DX		POP	CX		MOV	[BX].rbdControl, SI						;also clears the endList flag		ADD	DX, SI		LOOP	nextRBD		POP	[BX].rbdNext			;make circular		;set endList flag		OR	BYTE PTR [BX].rbdControl+1, HIGH MASK rbdEndList		MOV	endFBL, BX		RET		ASSUME	DS:NOTHINGSetUpRFA	ENDPSetUpSCB	PROC	NEAR;Arguments:	AX:	Pointer to descriptorArea for RFDs		ASSUME	DS:EthernetIOR		MOV	scb.cmdBlockList, OFFSET cb		MOV	scb.rcvFrameArea, AX		RET		ASSUME	DS:NOTHINGSetUpSCB	ENDPStartRU		PROC	NEAR;This procedure must be called with Ethernet interrupts disabled;ToDo: May be able to assume that RU is in not-ready state;ToDo: May only need to disable ENet ints during start control command;This procedure consists of two parts: (1) finding the pointer to the FFL;(Free Frame List) and putting it in the SCB, and (2) starting the receive unit;if there are enough descriptors in the FFL.  If we need to locate the FFL,;beginFBL will be 0.		ASSUME	DS:EthernetIOR		TEST	scbStatLow, LOW MASK ruReady		JZ	StartNeeded		JMP	StartRUExitStartNeeded:	PUSH	BX		PUSH	CX		PUSH	SI		CMP	beginFBL, 0		JNE	CheckFFL		MOV	BX, endRDLbeginRDLSearch:	MOV	BX, [BX].rfdLink		TEST	BYTE PTR [BX].rfdStatus+1, HIGH MASK rfdDone		JZ	beginRDLFound		CMP	BX, endRDL		;examined all rfds?		JNE	beginRDLSearch		MOV	BX, [BX].rfdLink	;point to next rfd to be freedbeginRDLFound:	MOV	scb.rcvFrameArea, BX		MOV	SI, endFBLbeginFBLSearch:	MOV	SI, [SI].rbdNext		TEST	BYTE PTR [SI].rbdStatus+1, HIGH MASK rbFilled		JZ	beginFBLFound		CMP	SI, endFBL		;examined all rbds?		JNE	beginFBLSearch		MOV	SI, [SI].rbdNext	;point to next rbd to be freedbeginFBLFound:	MOV	beginFBL, SICheckFFL:	MOV	BX, scb.rcvFrameArea		MOV	SI, beginFBL		MOV	CX, 2CheckRFDFree:	TEST	BYTE PTR [BX].rfdStatus+1, HIGH MASK rfdDone		JNZ	StartRULater		MOV	BX, [BX].rfdLink		LOOP	CheckRFDFree		MOV	CX, 2CheckRBDFree:	TEST	BYTE PTR [SI].rbdStatus+1, HIGH MASK rbFilled		JNZ	StartRULater		MOV	SI, [SI].rbdNext		LOOP	CheckRBDFreeStartRUNow:	MOV	BX, scb.rcvFrameArea		MOV	SI, beginFBL		MOV	[BX].rbdPtr, SI		%WaitForSCBReady		MOV	scbCmdLow, LOW SCBCmd<,,,,,,,ccStart>		OUT	ENetAttn, AL		MOV	beginFBL, 0StartRULater:	POP	SI		POP	CX		POP	BXStartRUExit:	RET		ASSUME	DS:NOTHINGStartRU		ENDPIOPEInROM	ENDS;		PURGE		END
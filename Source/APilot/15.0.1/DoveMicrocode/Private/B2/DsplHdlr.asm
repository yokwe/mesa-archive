$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);;--------------------------------------------------------------------------------;; This code implements the display handler.;;Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;-- stored as [Idun]<WDLion>Dove>DsplHdlr.asm;-- created on  27-Feb-84 11:15:44;-- This version uses Opie 21;;-- last edited by:;--	MxS	 8-Mar-89 22:19:57	:changed to procedure of CMOSDisplay handler ;--	JGS	13-Sep-85 14:18:47	:15/19 inch bit inverted (CRTSize).;--	JPM	12-Sep-85  7:58:41	:Change defaults for border & mix rule.;--	JPM	 9-Sep-85  9:41:54	:Fix bug in bad-interrupt proc (forgot to POP DS).;--	JPM	28-Aug-85 16:33:54	:Change bad-interrupt proc to get handler access, made Daybreak/Daisy procs NEAR.NAME			Display			;Changed name to Display;--------------------------------------------------------------------------------$NOLIST$INCLUDE	(IOPDefs.asm)	;This should always be INCLUDEd first$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(ROMEEP.asm)$LIST; INCLUDED IOPDefs.asm, HardDefs.asm, IOPMacro.asm, and ROMEEP.asm;--------------------------------------------------------------------------------;;Include files needed for display handler$INCLUDE   (DsplDefs.asm);;----------------------------------------------------------------------------------EXTRN displayInterrupt :ABSEXTRN DisplayHandlerID :ABS;;DisplayIOR		SEGMENT		COMMON ;EXTRNs for display handlerEXTRN displayTask :TaskContextBlock;;EXTRNs contained in display handler FCBEXTRN  displayLock :WORDEXTRN  chngdInfo :WORDEXTRN  vertRetraceEvent :BYTEEXTRN  cursorXCoord :WORDEXTRN  cursorYCoord :WORDEXTRN  borderLow :BYTEEXTRN  borderHigh :BYTEEXTRN  cursorPattern :BYTEEXTRN  displCntl :BYTEEXTRN  mixRule :BYTEEXTRN  numberBitsPerLine :WORDEXTRN  numberDisplayLines :WORDEXTRN  configInfo :BYTEEXTRN  colorParams: WORDEXTRN  xCoordOffset :WORDEXTRN  yCoordOffset :WORDEXTRN  pixels :BYTEEXTRN  refresh :BYTE;EXTRN  bitMapOrg :WORDEXTRN  numberQuadWords :WORD;EXTRN  displayIntrCnts :WORD  ;  !!!! Added for debug !!!!!EXTRN  displayWdtCnts  :BYTE  ;  !!!! Added for debug !!!!!;EXTRN  CursorUser :BYTE;;Variables containing addresses of Daisy/Daybreak proceduresEXTRN  displayHWInitProc :WORDEXTRN  cursorPositionProc :WORDEXTRN  cursorPatternProc :WORDEXTRN  borderPatternProc :WORDEXTRN  backgndProc :WORDEXTRN  commandProc :WORD;DisplayIOR		 ENDS;;-----------------------------------------------------------------------------------------;			DisplaySTK		SEGMENT		COMMON 			Assume SS:DisplaySTKEXTRN  DisplayStack :WORDDisplaySTK		 ENDS;;-----------------------------------------------------------------------------------------IOPEInROM		SEGMENT	WORD PUBLIC			Assume	CS:IOPEInROM;;;-----------------------------------------------------------------------------------------;;ROM-based task entry points:; PUBLIC		DisplayInit;;-----------------------------------------------------------------------------------------;;All the entry points below have to be in ROM so there is no need;to save the CS!;;******************************************************************************************;*******************************;*                             *;*        DisplayInit          *;*                             *;*******************************;DisplayInit	PROC	FAR		%InitializeTask		(DisplayHandlerID,OFFSET displayTask, DisplayTaskInit,OFFSET DisplayStack)			RETDisplayInit	ENDP;;*******************************************************************************************;***********************************;*                                 *;*        DisplayTaskInit          *;*                                 *;***********************************;;Task initialization is the same for all clients(Boot, Boot diagnostics, Pre-boot, and the Mesa head.);DisplayTaskInit:		ASSUME	DS:DisplayIOR				%ThisTaskServices (displayInterrupt,badDisplayIntr);;INITIALIZE DATA STRUCTURES;Initialize the display Function Context Block;;Initialize the head/handler synchronization first;		%GetLockMask			;GetLockMask returns the lock in AXLockInit:	MOV    displayLock, AX		;Initialize lock mask returned in macro;		MOV    chngdInfo, cursorPatternChngd	;Write cursor pattern first time;;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!; Initialize counts added for debug		MOV    displayIntrCnts, 0	;Initialize counts to 0		MOV    displayWdtCnts, 0	;Initialize counts to 0;!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!;;Assume non-color CRT		MOV	colorParams, 0		;Initialize to non-color;Initialize configuration information		MOV	configInfo, 0		MOV	bitMapOrg, 0		;Assume display memory starts at 0;;Set up default values for the data to output to hardware		MOV    cursorXCoord, 0H		;Init. cursor to top left of the screen		MOV    cursorYCoord, 0H		;;		MOV    borderLow, 0H		;Initialize default border pattern		MOV    borderHigh, 0H		;This pattern is speckled;		MOV    DI, 0			;DI points @ cursor pattern wordMapInit:	MOV    cursorPattern[DI], 0H	;Fill cursor pattern with ones		INC    DI			;Point to next byte		CMP    DI, NumBitMapBytes	;If DI not reached NumBitMapBytes		JL     MapInit			;Cont. filling with ones;CommandInit:	MOV    displCntl, 0E4H		;Init. command to display command reg (DayBreak);						:Set border across screen so cursor can be seen;							:b7-b4 = default cursor/data mix = E;							:b3 = Pic/bdr' = Border = 0;							:b2 = not used = 1;							:b1 = video disabled = 0;							:b0 = interlaced = 0;		MOV    mixRule, 0EH		;Init. cursor/data mix rule (Daisy);		MOV    CursorUser, DisplayCursor ;Initialize cursor user to display;;--------------------------------------------------------------------------------------------;;DETERMINE HARDWARE UNIQUE PARAMETERS;;Determine CRT size and configurationCRTSize:	MOV   DX, DisplayTypePort	;DX points at DisplayTypePort			IN    AL, DX			;Read IO port to get CRT size		TEST  AL, DisplayTypeMask	;See CRT size bit		JZ    NineteenInch		;If bit 0 = 0, then 19" display;;; Otherwise, it's a 15" black and white CRT -- this is also the default case;;DefaultDisplay: MOV   numberDisplayLines, 633		;Save the number of display lines		MOV   numberBitsPerLine, 832		;Active picture bits per line (52 * 16)		MOV   numberQuadWords, 13		;Save number of quad words/line (52 / 4);		MOV   xCoordOffset, 208	 ;Offset for cursor position x-coordinate;					 :(pixels -- 13 words * 16 bits);					 : compensate for hsync and border;		JMP   CommonInit	;Go to common initialization;END 15" CRT;;  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -;NineteenInch:	MOV   numberDisplayLines, 861		;Save the number of display lines		MOV   numberBitsPerLine, 1152		;Active picture bits per line (72 * 16)		MOV   numberQuadWords, 18		;Save number of quad words/line (72 / 4);;		MOV   xCoordOffset, 304  	;Offset for cursor position x-coord;						: (pixels=19 words * 16 bits);;END 19" CRT;  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -CommonInit:		MOV   yCoordOffset, 32	;Offset for cursor position y-coord;		MOV   pixels, 80	;Number of pixels per inch		MOV   refresh, 38	;Refresh rate;;;;; sometime determine interlaced/non-interlaced from hardware  **** How to is TBD ;;---------------------------------------------------------------------------------------------;;DETERMINE DAISY / DAYBREAK DIFFERENCES; (commented out until B2 version);		IN    AX, machineIDPort  	;0020H=Daisy, 0060H=Daybreak;		AND   AX, machineIDMask		;Mask out machine type bits;		AND   AX, 01000000B		;Mask out bit 2;		JZ    ShortJumpToDaisy		;If 0, go to DaisyWorkstation via short jump 1st;		JMP   SHORT DaybreakWorkstation	;If 1, go to DaybreakWorkstation;ShortJumpToDaisy: JMP   DaisyWorkstation	;If DAISY workstation, go to DaisyWorkstation;;   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   -   - ;;IF DAYBREAK workstation THEN;BEGIN;				:Leave b7 of configInfo reset to indicate DaybreakDaybreakWorkstation:		MOV   CX, 0			;Clear CX		%ReadEEProm(eePromLowMem,01)	;This macro returns value read in AX;						:Each bit set represents a 64K byte chunk;						:of memory present		JC  setBitMapAddr		;If EEPROM is bogus, carry is set.  So assume bitmap start at 0.FindBitMap:	RCR   AX, 1			;Check least sign bit		JC    setBitMapAddr		;If bit set, then display memory starts at;						:corresponding bit set		INC   CX			;Increment count of times shifted		JMP   FindBitMapsetBitMapAddr:	SAL   CX, 11			;Mov count to most sig. nibble		MOV   bitMapOrg, CX		;Least significant 5 bits are 0, so real;						:address is xxxx0H;				MOV   AX, OFFSET DaybreakHWInit		;Set up addr for HW initialization		MOV   displayHWInitProc, AX;			MOV   BX, OFFSET cursorPositionProc	;Set up addr for Cursor Positioning proc		MOV   AX, OFFSET NewDbreakCursorProc	;Set up addr for Cursor Positioning proc		MOV   [BX], AX;		MOV   AX, OFFSET DaybreakCursorPattern	;Set up addr for Cursor Pattern proc		MOV   [BX+2], AX;		MOV   AX, OFFSET NewDbreakBorderProc	;Set up addr for Border Pattern proc		MOV   [BX+4], AX;		MOV   AX, OFFSET DaybreakBackgndCommand	;Set addr - procs that set backgnd & cmnds		MOV   [BX+6], AX			;Save addr for background procedure		MOV   [BX+8], AX			;Save addr for command procedure				JMP    initHardware; Set up "jump" table addresses;;;**startsAt0:	MOV   AX, OFFSET DaybreakHWInit		;Set up addr for HW initialization;;;**		MOV   displayHWInitProc, AX;	;;;**		MOV   BX, OFFSET cursorPositionProc	;Set up addr for Cursor Positioning proc;;;**		MOV   AX, OFFSET DaybreakCursorPosition	;Set up addr for Cursor Positioning proc;;;**		MOV   [BX], AX;;;;**		MOV   AX, OFFSET DaybreakCursorPattern	;Set up addr for Cursor Pattern proc;;;**		MOV   [BX+2], AX;;;;**		MOV   AX, OFFSET DaybreakBorderPattern	;Set up addr for Border Pattern proc;;;**		MOV   [BX+4], AX;;;;**		MOV   AX, OFFSET DaybreakBackgndCommand	;Set addr - procs that set backgnd & cmnds;;;**		MOV   [BX+6], AX			;Save addr for background procedure;;;**		MOV   [BX+8], AX			;Save addr for command procedure;;;;;**		JMP    initHardware;END IF DAYBREAK workstation;;  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -;;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;initHardware:	CALL   displayHWInitProc	;Initialize display HW;;Wait for vertical retrace interrupt;***** This is Daybreak unique, it will need changed later *****startDisplay:	%DisableInterruptsTillNextWait	;Insure that no intrs happen until we are ready		MOV    DX, DisplCntlRegDayBreak	;DX points @ display cntl reg		OR     displCntl, 00000010B	;Set bit1 to start display		MOV    AL, displCntl		;Get commandOutputCommand:	OUT    DX, AL			;Output command and start display;;enabDisplayIntr: %Enable (displayInterrupt)	;Enable interrupts before waiting for onewaitForRetraceIntr:  %WaitForInterrupt (1)		;Wait for vertical retrace intr or WDT		     JC     displayTimedOut		;Look for watch dog timeout;;;***********************************************************************************************;************************************************;*                                              *;*     VERTICAL RETRACE INTERRUPT               *;*                                              *;************************************************;displayVertRetraceEntr:		INC    displayIntrCnts		;!!!! Increment the number of intr. counts;;Get the "changed" flags and reset them atomically;Pointer to chngdInfo is passed to MesaLockedOut.  The changed flags are returned in AX.		%MesaLockedOut(XCHG, OFFSET chngdInfo, 0, displayLock)		CMP    AX, 0			;Look for no changes		JZ     Exit			;If no changes, exit;;Set up pointers for checking for changesChanges:	MOV    DI, AX			;DI holds changed flags;;;Look for changes in cursor position		RCL    DI, 1			;Check cursor position flag change		JNC    CheckCursor		;If no change, continuecursorPosChng:	PUSH   DI			;Save DI		CALL   cursorPositionProc		POP    DI			;Restore DI;;;Look for changes in cursor patternCheckCursor:	CMP    CursorUser, MPCursor	;See if MP handler is updating cursor;						:pattern.  If CursorUser=MPCursor,;						:the zero flag gets set, but we still need;						:to rotate the flag word.		RCL    DI, 1			;Check cursor pattern flag change;						:the RCL does NOT affect the zero flag		JZ     CheckBorder		;If CursorUser=MPCursor, continue		JNC    CheckBorder		;If no change in cursor pattern, continuecursorPatChng:	CALL   CursorPatternProc	;Otherwise, Output new cursor pattern;;;Look for changes in border patternCheckBorder:	RCL    DI, 1			;Check border pattern flag change		JNC    CheckBackgnd		;If no change, continueborderPatChng:	CALL   borderPatternProc;;;Look for changes in backgroundCheckBackgnd:	RCL    DI, 1			;Check background flag change		JNC    CheckCmmds		;If no change, continuebackgroundChng:	CALL   backgndProc;;;Look for changes in command to display control registerCheckCmmds:	RCL    DI, 1			;Check display cntl reg flag		JNC    Exit			;If no change, exit		CALL   commandProc;Exit:	        %NotifyClientCondition(vertRetraceEvent)  ;Let Mesa know that we got intr;;Clear Interrupt Latch		IN   AX, ClrRetraceIntr	 	 ;Reset Vertical Retrace interrupt latch ;RetraceExit:	JMP    waitForRetraceIntr	;WaitForInterrupt;;;***************************************************************************************************;******************************************;*                                        *;*   Watch Dog Time Out Routine           *;*                                        *;******************************************;;Control is passed to the code here if the watch dog times outdisplayTimedOut:	CALL displayHWInitProc	;Reinitialize the hardware			JMP waitForRetraceIntr	;WaitForInterrupt;		ASSUME	DS:NOTHING;;Control is passed to the code here if we got a bad interruptbadDisplayIntr	PROC	FAR		PUSH	DS		%EstablishHandlerAccess	(DisplayHandlerID)		MOV	AX, ES		MOV	DS, AX		ASSUME	DS:DisplayIORdisplayWDT:	INC    displayWdtCnts		;!!!! Increment the number of intr. countsreInit:		CALL   displayHWInitProc	;Re-initialize the hardware		POP	DS		RET				;The waitForInterrupt is still in effectbadDisplayIntr	ENDP		ASSUME	DS:NOTHING;;***************************************************************************************************;******************************************;*                                        *;*   Daisy/Daybreak Procedures            *;*                                        *;******************************************;;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - ;HARDWARE INITIALIZATION PROCEDURESDaybreakHWInit	PROC   NEAR		ASSUME	DS:DisplayIOR;;DISABLE VIDEO TO DISPLAY		MOV    DX, DisplCntlRegDayBreak	;DX points @ display control register		MOV    AX, 0			;Get a 0 in AX		OUT    DX, AL			;Output a 0 to disable video & turn display off;;; DO SOFTWARE RESET (This insures that the interlaced field will come up right, ; 			even after power was on)ResetDisplay:	MOV  DX, DisplaySoftReset		IN   AL, DX;; INITIALIZE DISPLAY CONTROLLER REGISTERS; Initialize Cursor Position InitCursor:	CALL  cursorPositionProc	;Outputs default cur. posit'n (in FCB);;; Initialize DMC InitDMC:	MOV   AX, numberQuadWords	;Get quadWordsPerLine in AX       		MOV   DX, DMCWordsPerLineDayBreak		OUT   DX, AL			;Output number quad words per line;		MOV   AX, bitMapOrg       		INC   DX		OUT   DX, AL			;Output low byte display mem. starting addr		MOV   AL, AH       		INC   DX		OUT   DX, AL			;Output high byte display mem. starting addr;; Initialize DDC;; Initialize border pattern InitBorder:	CALL   borderPatternProc	;Outputs default border pattern (in FCB);;; Initialize cursor pattern		CALL   CursorPatternProc	;Call proc to initialize cursor pattern;;; Do NOT need to initialize System/Memory status registers;		RETDaybreakHWInit	ENDP		ASSUME	DS:NOTHING;;;CURSOR POSITION PROCEDURESDaybreakCursorPosition  PROC   NEAR		;Procedure for Daybreak cursor position		ASSUME	DS:DisplayIOR		CALL	CheckCursorPositionLimits		CALL	ConvertXCoordProc	;This leaves the cursor word position in AL and the bit offset in BL		MOV	DX, CursorWordPortDayBreak  ;DX pnts @ CursorWordPortDayBreak		OUT	DX, AL			;Output cursor x word locn.		INC	DX			;DX pnts @ CursorOffsetPortDayBreak		MOV	AX, BX			;Get bit offset into AX		OUT	DX, AL			;Output cursor x bit offset;		INC	DX			;DX pnts @ CursorLinePortLowDayBreak		MOV	AX, cursorYCoord	;Get y coord		ADD	AX, yCoordOffset	;Add necessary offset		MOV	BX, AX			;Save y coord		AND	AX, 0000000000111111B	;Get 6 least sign. bits		OUT	DX, AL			;Output 6 least sig. to Y low;		INC	DX			;DX pnts @ CursorLinePortHighDayBreak		MOV	AX, BX			;Get y coord + offset		SAR	AX, 6			;Get 4 most sign. bits		OUT	DX, AL			;Output 4 least sig. to Y high;	        RETDaybreakCursorPosition  ENDP		ASSUME	DS:NOTHING;;;CheckCursorPositionLimits	PROC	NEAR	;This proc checks to make sure the x coord is within 15 pixels of the border		ASSUME	DS:DisplayIOR		MOV	SI, OFFSET cursorXCoord	;SI points @ x coord		MOV	DI, OFFSET numberBitsPerLine	;DI points @ display width		MOV	CX, 2			;Twice thru loop;Twice:		CMP	[SI], 0FFF1H		;Check cursor position within top and left border bits;						:   0FFF1H = -15 in 2's complement form		JGE	TopLeftOK		;If O.K., go on		MOV	[SI], 0FFF1H		;If too far, reset back to -15TopLeftOK:	MOV	AX, [DI]		;Get max value in AX		CMP	[SI], AX		;Check cursor position within bottom and right border bits		JLE	BottomRightOK		;If O.K., go on		MOV	[SI], AX		;If too far, reset backBottomRightOK:	ADD	DI, 2			;DI points @ display height		ADD	SI, 2			;SI points @ y coord		LOOP	Twice 		RETCheckCursorPositionLimits	ENDP		ASSUME	DS:NOTHING;;ConvertXCoordProc	PROC	NEAR		;This proc converts x coord from pixels to a word and an offset;This leaves the cursor word position in AL and the bit offset in BL		ASSUME	DS:DisplayIOR		MOV	AX, cursorXCoord	;Get x coord in AX		ADD	AX, xCoordOffset	;Add necessary offset		MOV	BX, AX			;Save x coord + offset		SAR	AX, 4			;Get word locn in AL		AND	BX, 0000000000001111B	;Get word offset in BL		RETConvertXCoordProc	ENDP		ASSUME	DS:NOTHING;;  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -;;CURSOR PATTERN PROCEDURESDaybreakCursorPattern	PROC   NEAR		;Procedure for Daybreak cursor patttern		ASSUME	DS:DisplayIOR		MOV	DX, cursorBufferPortsDayBreak  ;DX pts @ starting addr of cursor buffer		MOV	SI, 0			;SI indexes source word in cursorPatternDaybreakMap:	MOV	AL, cursorPattern[SI]	;Get value to output in AL		OUT	DX, AL			;Output value to port		INC	DX			;DX pnts to next cursorPattern locn port		INC	SI			;SI pnts to next value		CMP	SI, NumBitMapBytes	;See if all new values have been outputed		JL	DaybreakMap		RETDaybreakCursorPattern	ENDP		ASSUME	DS:NOTHING;;;;BORDER PATTERN PROCEDURESDaybreakBorderPattern	PROC   NEAR		;Procedure for Daybreak border pattern		ASSUME	DS:DisplayIOR		MOV	DX, BorderPatternLowDayBreak  ;DX points @ BorderPatternLowDayBreak		MOV	SI, OFFSET borderLow	;SI points @ source values (borderLow)		MOV	CX, 2			;Output two border pattern bytesBorderOutDaybreak: MOV	AL, [SI]		;Get value to output in AL		OUT	DX, AL			;Output border pattern		INC	DX			;DX points to next border pattern port		INC	SI			;SI points to next value		LOOP	BorderOutDaybreak	;Output values til CX = 0		RETDaybreakBorderPattern	ENDP		ASSUME	DS:NOTHING;;;;PROCEDURES FOR SETTING BACKGROUND AND OUTPUTTING COMMANDSDaybreakBackgndCommand	PROC   NEAR		;Procedure for Daybreak backgrnd & cmnds		ASSUME	DS:DisplayIOR		MOV	DX, DisplCntlRegDayBreak	;DX points @ DisplCntlRegDayBreak		MOV	AL, displCntl		;Get new info for display control register		OUT	DX, AL			;Output to display control register		RETDaybreakBackgndCommand  ENDP		ASSUME	DS:NOTHING								NewDbreakCursorProc  PROC   NEAR		;Procedure for Daybreak cursor 						;position		ASSUME	DS:DisplayIOR		CALL	NewCursorPositionLimits		CALL	NewXCoordProc	;This leaves the cursor word position in AL and the 								;bit offset in BL		MOV	DX, CursorWordPortDayBreak  ;DX pnts @ CursorWordPortDayBreak		OUT	DX, AL			;Output cursor x word locn.		INC	DX			;DX pnts @ CursorOffsetPortDayBreak		MOV	AX, BX			;Get bit offset into AX		OUT	DX, AL			;Output cursor x bit offset		MOV	BX, cursorYCoord	;Get y coord		ADD	BX, yCoordOffset	;Add necessary offset		MOV	DX, DisplayTypePort    	;Is this cmos hardware or gate array		IN	AL, DX			;If bit1 is 0 it is CMOS		TEST	AL, 00000010B		;test for CMOS or Gate array		JZ	CMOSGateArray:	MOV	AX, BX     		;Bring y coordinate back into AX		MOV	DX, CursorLinePortLowDayBreak ;load DX with the low port for cursor y position		AND	AX, 0000000000111111B	;Clear the High byte of this register		OUT	DX, AL		INC	DX			;Point to the high port for cursor y position		MOV	AX, BX			;Bring the y coordinate back into AX		SAR	AX, 6		OUT	DX, AL		JMP	CursorExitCMOS:		MOV	AX, BX			;Bring y coordinate back into AX		MOV	DX, CursorLinePortLowDayBreak;		AND	AX, 0000000011111111B		OUT	DX, AL		INC	DX		MOV	AX, BX		SAR	AX, 8		OUT	DX, ALCursorExit:	RET			NewDbreakCursorProc  ENDP		ASSUME	DS:NOTHING	NewDbreakBorderProc	PROC   NEAR		;Procedure for Daybreak border 								;pattern		ASSUME	DS:DisplayIOR		MOV	SI, OFFSET borderLow	;SI points @ source values (borderLow)		MOV	CX, 2			;Output two border pattern bytes		MOV	DX, DisplayTypePort	;Determine whether gate aray or cmos		IN	AL, DX			; If bit1 of bL is 0 it is CMOS ddc		TEST	AL, 00000010B		;Test for CMOS or Gate Array		JZ	CMOSBorder		;GABorder:	MOV	DX, BorderPatternLowDayBreak ; If Ga Border Low registerGABorderOut:	MOV	AL, [SI]		;Will have to contain the border low pattern		OUT	DX, AL		INC	DX			;& borderhigh reg.border high pattern		INC	SI		LOOP	GABorderOut		JMP	BorderEndCMOSBorder:	MOV	DX, BorderPatternHighDayBreak ;If CMOS HW:CMOSBorderOut:	MOV	AL, [SI]		OUT	DX, AL			;then border pattern is switched		DEC	DX			;		INC	SI			;Point to next pattern		LOOP	CMOSBorderOut		;BorderEnd:	RETNewDbreakBorderProc	ENDP		ASSUME	DS:NOTHING		NewCursorPositionLimits	PROC	NEAR	;This proc checks to make sure the x coord is within 15 pixels of the border		ASSUME	DS:DisplayIOR		MOV	SI, OFFSET cursorXCoord	;SI points @ x coord		MOV	DI, OFFSET numberBitsPerLine	;DI points @ display width		MOV	CX, 2			;Twice thru loop;Twice1:		CMP	[SI], 0FFF1H		;Check cursor position within top and left border bits;						:   0FFF1H = -15 in 2's complement form		JGE	TopLeftOK1		;If O.K., go on		MOV	[SI], 0FFF1H		;If too far, reset back to -15TopLeftOK1:	MOV	AX, [DI]		;Get max value in AX		CMP	[SI], AX		;Check cursor position within bottom and right border bits		JLE	BottomRightOK1		;If O.K., go on		MOV	[SI], AX		;If too far, reset backBottomRightOK1:ADD	DI, 2			;DI points @ display height		ADD	SI, 2			;SI points @ y coord		LOOP	Twice1 		RETNewCursorPositionLimits	ENDP		ASSUME	DS:NOTHING		NewXCoordProc		PROC	NEAR		;This proc converts x coord from pixels to a word ;This leaves the cursor word position in AL and the bit offset in BL		ASSUME	DS:DisplayIOR		MOV	AX, cursorXCoord	;Get x coord in AX		ADD	AX, xCoordOffset	;Add necessary offset		MOV	BX, AX			;Save x coord + offset		SAR	AX, 4			;Get word locn in AL		AND	BX, 0000000000001111B	;Get word offset in BL		RETNewXCoordProc	ENDP		ASSUME	DS:NOTHING							;;;IOPEInROM	ENDS;********************************************************************************			END
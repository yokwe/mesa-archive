$MOD186$PAGELENGTH	(72)$PAGEWIDTH	(136);Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;-- stored as [Iris]<WMicro>Dove>ROMFlpBt.asm;-- created on  19-Jul-84 13:20:18;-- last edited by:;--	kek	28-Mar-87 15:05:18	;1p2MB floppy booting support near FatalError. use ResetAndFlushFlag instead of ResetFDCBeforeProcessing;--	kek	 4-Sep-85 17:24:54	;mp codes;--	JPM	15-Aug-85  9:54:57	;Add missing PUSH ES at DoBoot.;--	JPM	 3-Aug-85  7:51:23	;New FlopFace.;--	JPM	22-Jul-85 10:33:37	;Change IOPEInROM alignment to WORD.;--	JPM	16-Jul-85  8:03:40	;Opie redesign conversion.;--	JMM	20-Jun-85  9:36:30	;Upgraded to new IOPLRAM.;--	JPM	30-Apr-85 15:16:51	;fixed IOCB data.;--	JMM	 4-Apr-85 20:23:21	;Opie 19.;--	JMM	25-Feb-85 15:26:55	;Removed IOPLRAM.asm;--	JMM	13-Dec-84 15:14:16	;Correction from from Herb Lopez-Aguado.;					(Remove floppy clock board dependency).;--	JMM	 9-Dec-84 19:56:27	;Corrections from ED.;--	JMM	30-Nov-84 15:39:45	;Misc. edits.;--	JMM	25-Nov-84 16:03:37	;Added fix from El Segundo.;--	JPM	 3-Nov-84 12:17:24	add debug code to set boot buffer space; remove FlopFace from INCLUDEs;--	JPM	30-Oct-84 12:28:41	initialize condition, change IOCB address type to IOPIORegionOpieAddress;--	JPM	26-Oct-84 17:20:51	added IOCB image;--	JMM	24-Oct-84 16:14:02NAME		ROMFlpBt;--------------------------------------------------------------------------------;$NOLIST$INCLUDE	(IOPDefs.asm)$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(QueDefs.asm)$INCLUDE	(ROMBDefs.asm)$INCLUDE	(FlopFace.asm)$INCLUDE	(ROMEEP.asm)$LIST;--------------------------------------------------------------------------------EXTRN			BootStrapHandlerID: ABSEXTRN			FloppyHandlerID: ABSEXTRN			DisplayMPCode: NEAR;---------------;******************************************************************;---------------IOPELocalRAM	SEGMENT	AT 0EXTRN		opieReentry: DWORDEXTRN		bootType: BYTEEXTRN		bootRetryCount: WORDEXTRN		startOfBootBufferSpace: WORDEXTRN		endOfBootBufferSpace: WORDEXTRN		HandlerInitProcTable: DWORDIOPELocalRAM	ENDS;---------------;******************************************************************;---------------;from IORROMBt.asm:;------------------BootStrapIOR	SEGMENT	COMMONEXTRN		bootStrapTask: TaskContextBlockEXTRN		bootDeviceIORSpace: FloppyBootContextEXTRN		jumpTable: BootJumpTable		BootStrapIOR	ENDS;from IORflop.asm:;------------------FloppyIOR	SEGMENT	COMMONEXTRN		FloppyWorkNotify: CONDITIONEXTRN		Floppy80186Queue: QueueBlockEXTRN		FloppyEncodedDeviceTypes : EncodedDeviceTypeEXTRN		FloppyDCB0: WORDFloppyIOR	ENDS;from STKflop.asm:;------------------FloppySTK	SEGMENT	COMMONEXTRN		EndOfFloppyStackSeg: WORD		FloppySTK	ENDS;---------------;******************************************************************;---------------IOPEInROM	SEGMENT	WORD PUBLIC		ASSUME	CS:IOPEInROM		ASSUME	DS:BootStrapIORPUBLIC		FloppyBootStrap;			;--------------------------------------------------------------------------------;--------------------------------------------------------------------------------;-- Floppy BootStrap:;--------------  Assume parameter locations upon entry into this procedure	;--------------  are as follows:;-------------- ;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------FloppyBootStrap		PROCStartFloppyBoot:	MOV	AX, IOPELocalRAM			MOV	ES, AX			ASSUME	ES:IOPELocalRAM			%CallHandlerInitProc	(FloppyHandlerID)			%WaitForSystem				;Give floppy a chance to initialize			MOV	WORD PTR bootDeviceIORSpace.floppyIOCBDone, Null	; Initialize condition			PUSH	ES			MOV	AX, DS							MOV	ES, AX				;Here we are getting			ASSUME	ES:NOTHING			MOV	CX, sizeFloppyInitialIOCB	;ready to transfer the ROM			MOV	SI, OFFSET FloppyInitialIOCB	;image of the IOCB to IORegion			MOV	DI, OFFSET bootDeviceIORSpace.floppyIOCB ;which is then to beCopyLoop:		MOVS	BYTE PTR ES:[DI], CS:[SI]	;passed on to the handler.			LOOP	CopyLoop			;(can't use REP MOVS w/seg override: might get interrupted)			POP	ES				;Booting uses IOP local RAM			ASSUME	ES:IOPELocalRAM			;for all its work.			MOV	DX, FloppySTK			;The first record of			SHL	DX, Nibble			;FloppyInitialDove.db goes			ADD	DX, OFFSET EndOfFloppyStackSeg	;after the floppy stack segment.			ADD	DX, LowNibbleMask		;The location to jump to			AND	DX, NOT(LowNibbleMask)		;must be at a "paragraph"			MOV	startOfBootBufferSpace, DX	;boundary.			MOV	bootDeviceIORSpace.floppyIOCB.DataAddress.OpieAddressLow, DX			SHR	DX, Nibble			;Calculate the CS value of 			MOV	jumpTable.iopEntry, nullOffset	;the loaded code's			MOV	jumpTable.iopEntryCS, DX	;entry point.			MOV	DX, FloppyIOR			;Limit the size			SHL	DX, Nibble			;of the boot			MOV	endOfBootBufferSpace, DX	;area.			MOV	bootRetryCount, 10DoBoot:			PUSH	ES			MOV	DX, FloppyIOR			MOV	ES, DX			ASSUME	ES:FloppyIOR			MOV	Floppy80186Queue.queueNext.OpieAddressLow, OFFSET bootDeviceIORSpace.floppyIOCB			MOV	Floppy80186Queue.queueNext.OpieAddressHandlerID, LOW BootStrapHandlerID			MOV	Floppy80186Queue.queueNext.OpieAddressType, IOPIORegionOpieAddress			POP	ES			ASSUME	ES:IOPELocalRAM						;display mp code that says initial is about to start fetching			PUSH	AX			MOV	AX, mpFetchInitial			CALL	DisplayMPCode			;this does a wait for system			POP	AX			%NotifyHandlerCondition	(FloppyHandlerID, OFFSET FloppyWorkNotify)			%WaitForCondition	(OFFSET bootDeviceIORSpace.floppyIOCBDone,noTimeout)			;Test to make sure that floppy was successful, then jump to HoldItjmm!			CMP	bootDeviceIORSpace.floppyIOCB.OperationState, OperationCompleted			JE	HoldItjmm; not a good boot. Decrement the retry counter, reset the FDC, and try again.			DEC	bootRetryCount			JZ	FatalErrorOnTheWayToDoBoot:	MOV	bootDeviceIORSpace.floppyIOCB.ResetAndFlushFlag, MesaTRUE			MOV	bootDeviceIORSpace.floppyIOCB.OperationState, OperationWaiting			JMP	DoBoot		HoldItjmm:		JMP	DWORD PTR jumpTable.iopEntry;if too many retries, hang with MP code or try with different device type;The theory of this failure recovery code is this:;	If the EEProm was good here, then the boot failed despite the correct;	 device type, and an unrecoverable failure is generated.;	If the EEProm was bad and the boot failed with the default sa455, then the;	 assumption is that the default was incorrect.  The error is recovered from;	 by trying the boot again with the nondefault sa475.;	If the EEProm was bad and the boot failed with the nondefault sa475, then an;	 unrecoverable failure is generated.FatalError:		%ReadEEProm(eePromFloppy,1)			JNC	HonestFatalError;the EEProm was untrustworthy so we'll retry the alt device type (if we haven't already).			PUSH	ES			%EstablishHandlerAccess(FloppyHandlerID)			ASSUME	ES:FloppyIOR			MOV	AX, FloppyDCB0.DeviceAttributes			CMP	AL, sa475DiskDrive	;(1st time thru, was an sa455)			JE	HonestFatalError	;(2ed time thru, was an sa475)RetryWithOtherDevice:	MOV	FloppyDCB0.Port80ControlWord, sa475onDriveZero			MOV	FloppyDCB0.StepRateTimePlusHeadUnloadTime, sa475StepRateTimePlusHeadUnloadTime			MOV	FloppyDCB0.HeadLoadTimePlusNotInDMAmode, sa475HeadLoadTimePlusNotInDMAmode			MOV	FloppyDCB0.DeviceAttributes, sa475DiskDrive			MOV	FloppyEncodedDeviceTypes, (sa475DiskDrive SHL 4)			POP	ES			ASSUME	ES:IOPELocalRAM			JMP	SHORT OnTheWayToDoBoot			;retry floppy booting with new device type.;the EEProm was trustworthy or it also failed with the alt floppy device type.HonestFatalError:	MOV	AX, mpInitialError			CALL	DisplayMPCode			%Jam	(BootStrapHandlerID,OFFSET bootStrapTask)			%WaitForSystem		; never returns!FloppyBootStrap		ENDP;********************************************************************************;EPROM Boot Data:;Floppy BootStrap Data:FloppyIOCBData		DB	MesaTRUE	;OperationIsQueued			DB	OperationWaiting	; OperationState=OperationWaitingInQueue			OpieAddress	<0,0,nilOpieAddress>	;NextIOCB=NIL			OpieAddress	<setAtRunTime,0,IOPLogicalOpieAddress>	;DataAddress			ClientCondition	<LOW BootStrapHandlerID,0,(OFFSET bootDeviceIORSpace.floppyIOCBDone+nonNilPtr),0>			DB	setAtRunTime	; FinalStateOfFDC			DB	MesaFALSE	; SpecifyBeforeProcessing=FALSE			DB	MesaFALSE	; PCEResetFDCFlag=FALSE			DB	MesaFALSE	; PCEStartMotorFlags=FALSE			DB	MesaFALSE	; ResetFDCBeforeProcessing=FALSE			DB	MesaFALSE	; RecalibrateBeforeProcessing=FALSE			DB	0	; DaDriveNumber=0 (assume boot from drive 0)			DB	setAtRunTime	; FDCHung set by handler			DW	pageSizeInBytes	; TotalBytesToTransfer			DW	setAtRunTime	; TotalBytesActuallyTransfered set by handler			DW	StartCounter	; CounterControlRegister=std value			DW	pageSizeInBytes	; FirstDMAtransferCount			DW	StartDMARead	; FirstDMAcontrolWord=std value			DW	0	; NumberOfMiddleDMAtransfers=0 (do all in one shot)			DW	dontCare	; MiddleDMAtransferCount not used			DW	dontCare	; MiddleDMAcontrolWord not used			DW	dontCare	; LastDMAtransferCount not used			DW	dontCare	; LastDMAcontrolWord not used			DW	setAtRunTime	; FinalDMACount set by handler			DB	MesaFALSE	; IncrementDataPointer=FALSE			DB	setAtRunTime	; TimeoutOccurred set by handler			DW	3	; NumberOfFDCCommands=3 (Seek, Sense Interrupt Status, Read Data)			DW	setAtRunTime	; CurrentFDCCommand set by handler			; Seek command			DB	Seek	; fdcCode=Seek			DB	None	; DataTransferCode=None			DB	dontCare	; anExtraByte not used			DB	MesaTRUE	; MustWaitForInterrupt=TRUE			DB	3	; NumberOfCommandBytes=3			DB	setAtRunTime	; NumberOfCommandBytesWritten set by handler			DB	fdcSeekCommand	; CommandBytes[1]: command code for Seek			DB	00H	; CommandBytes[2]: drive 0, head 0			DB	05H	; CommandBytes[3]: cylinder 5			DB	7 DUP (dontCare)	; CommandBytes[4..10]: unused			DB	0	; NumberOfResultBytes=0			DB	setAtRunTime	; NumberOfResultBytesRead set by handler			DB	8 DUP (setAtRunTime)	; ResultBytes[1..8] set by handler			; Sense Interrupt Status command			DB	SenseInterruptStatus	; fdcCode=Sense Interrupt Status			DB	None	; DataTransferCode=None			DB	dontCare	; anExtraByte not used			DB	MesaFALSE	; MustWaitForInterrupt=FALSE			DB	1	; NumberOfCommandBytes=1			DB	setAtRunTime	; NumberOfCommandBytesWritten set by handler			DB	fdcSenseInterruptStatusCommand	; CommandBytes[1]: command code for Sense Interrupt Status			DB	9 DUP (dontCare)	; CommandBytes[2..10]: unused			DB	2	; NumberOfResultBytes=2			DB	setAtRunTime	; NumberOfResultBytesRead set by handler			DB	8 DUP (setAtRunTime)	; ResultBytes[1..8] set by handler			; Read Data command			DB	ReadData	; fdcCode=ReadData			DB	Read	; DataTransferCode=Read			DB	dontCare	; anExtraByte not used			DB	MesaTRUE	; MustWaitForInterrupt=TRUE			DB	9	; NumberOfCommandBytes=9			DB	setAtRunTime	; NumberOfCommandBytesWritten set by handler			DB	fdcReadDataCommand+(double SHL 6)	; CommandBytes[1]: command code for Read Data (double density)			DB	00H	; CommandBytes[2]: drive 0, head 0			DB	05H	; CommandBytes[3]: cylinder 5 (in label)			DB	00H	; CommandBytes[4]: head 0 (in label)			DB	01H	; CommandBytes[5]: sector 1 (in label)			DB	02H	; CommandBytes[6]: number of bytes per sector=512 (encoded)			DB	09H	; CommandBytes[7]: end-of-track sector=9			DB	2AH	; CommandBytes[8]: gap length=40 bytes			DB	0FFH	; CommandBytes[9]: data length (defaulted when bytes/sector > 0)			DB	dontCare	; CommandBytes[10]: unused			DB	7	; NumberOfResultBytes=7;			DB	setAtRunTime	; NumberOfResultBytesRead set by handler;			DB	8 DUP (setAtRunTime)	; ResultBytes[1..8] set by handlerUnusedPartOfFloppyIOCB	EQU	OperationIsQueued-operationFloppyInitialIOCB	EQU	FloppyIOCBData-UnusedPartOfFloppyIOCB	; first 22 bytes not used by handlersizeFloppyInitialIOCB	EQU	$-FloppyInitialIOCBIOPEInROM		ENDS;********************************************************************************			END
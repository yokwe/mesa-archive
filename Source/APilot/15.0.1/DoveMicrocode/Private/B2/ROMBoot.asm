$MOD186$PAGELENGTH	(72)$PAGEWIDTH	(136);Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;-- stored as [Iris]<WMicro>Dove>ROMBoot.asm;-- created on  19-Jul-84 13:20:18;-- last edited by:;--	JAC	    30-Jul-87 11:52:04		;change enet number to Daybreak;--	JAC	    15-Jan-87 10:46:00		;fix alt enet booting. fix short or long alag bug;--	KEK	    12-May-86 12:44:21		;change e'net address to 25200004300B. (Daybreak is 25200004000B). Also, OR into baseEthernetFileID.;--	CWM	    30-Apr-86 22:37:17		;ReInstall diagnostic icon;--						;1671 bytes/241 bytes saved;--	CWM	    25-Apr-86 19:58:10		;Cut out icon top/bottom calcs;--						;1633 bytes/279 bytes saved;--	CWM	    25-Apr-86 12:17:25		;Cut out diagnostic icon for Karey;--						;1649 bytes/263 bytes saved;--	CWM	    23-Apr-86  1:41:16		;Integ BumpES and InvertICON calls;--						;1687 bytes/225 bytes saved;--	CWM	    22-Apr-86 23:29:29		;Function key and kleenup EQU's;--						;T4Key fixes ;--						;1695 bytes/217 bytes saved;--	CWM	    21-Apr-86 23:42:53		;New ICON buttons ;--						;1726 bytes/186 bytes saved;--	CWM	    20-Apr-86 22:03:52		;Fix EQU/DB+DW, AR shifts, MUL;--						;DIV, Remove useless XOR's;--						;1887 bytes/25 bytes saved;--;------------------------------1912 BYTES-------------------------------;--;--	RDH	    17-Sep-85 12:06:15		;Make timeouts disabled on return to UI after diagnostic boot selected by user.  Make booting mp codes a little prettier by sending the cursor to 2,2 instead of 0,0 and expanding the mp panel background box by 2.;--	JAC	    16-Sep-85 22:16:37		;Fix handling of no default boot device;--	RDH	    16-Sep-85 16:49:45		;Fix error in ES handling when EEProm is bad and there is a timeout.  Fix handling of no default boot device.  Add code to disable timeouts after running diagnostics.;--	RDH	    14-Sep-85  9:47:30		;Fix bug in 35 second timeout.;--	RDH	    13-Sep-85 18:11:39		;Improve cursor readability.;--	RDH	    13-Sep-85 13:34:06		;Fix up LED's for case where EEProm is bad.;--	RDH	    13-Sep-85 11:20:22		;Add DEC AL to default booting code to fix off by one error.;--	RDH	    12-Sep-85 13:59:34		;Comment out mouse code.  Comment out floppy cleaning and arrow cursor icons.  Adjust for smaller icon data structure.  Move IconSelected code below DeviceKnown code to save on JMP's.;--	JAC/RDH	    12-Sep-85 11:35:11		;Add setting of FinishMode./Add timeouts and watching for STOP key.;--	RDH	    11-Sep-85 13:42:26		;Fix bug in space saving. Note that INC does not set or clear the Carry flag.;--	RDH	    10-Sep-85 20:06:28		;Save space by adding SHORT's, changing ADD reg, 2 to INC reg x2, changed some loops to byte operations.  Moved procedures to the end to save a few jumps over them.;--	JAC	    10-Sep-85 14:05:55		;test for short or long diags						;shorten SelectionLoop;--	JAC	     6-Sep-85 11:39:19		;fix border pattern						;display lines aren't a multiple of 4						;add waiting for function key 9;--	JAC	     5-Sep-85 20:11:15		;fix black line at bottom of display						;unknown device hangs instead of returning to Selection;--	JAC	     5-Sep-85 11:09:37		;fix mp codes and arrow cursor again						;check for function keys 9 and 10 in loop						;remove floppy head cleaning temporarily;--	JAC	     4-Sep-85 22:48:39		;clear LEDs;--	kek	     4-Sep-85 19:29:07		;mp codes.;--	JAC	     4-Sep-85 17:15:56		;put in function key 9 checks at beginning						;check prebootSwitches before reading EEPROM						;put cursor at upper left corner while booting;--	JAC	     3-Sep-85 21:01:59		;fix code at NextDevice;--	JAC	     3-Sep-85 18:09:34		;first cut at reading EEPROM for available devices;--	JAC	     2-Sep-85 17:51:17		;fixed arrow cursor and line at icon border						;fix unknown device and FloppyHeadClean;--	JAC	     2-Sep-85 17:00:04		;fix up starting user interface and diagnostics;--	JAC	     2-Sep-85 16:00:21		;set flag for display instead of calling proc ;--	JAC	     1-Sep-85 14:38:24		;fix floppy icon; alt eth boot is now function key 3						;change definition of T9Key and T10Key;--	JAC	    31-Aug-85 14:32:41		;pop the stack after ChainUpICONDataStructure loop;--	JAC	    29-Aug-85 14:50:07		;Fix icon booting proc;--	JAC	    27-Aug-85 17:28:35		;Zero bootDeviceIORSpace since ICONs munged it. ;--	RDH	    23-Aug-85 18:08:59		;Fix bug above icon and SI smashed by InvertIcon bugs. ;--	RDH	    23-Aug-85  8:29:27		;Fix 2 matching bugs in background painting. ;--	RDH	    22-Aug-85 16:14:24		;Fix half icon inverted, and mouse click offset problems. ;--	RDH	    22-Aug-85 13:29:10		;Fix bugs in mouse tracking, icon inversion, and keyboard watching. ;--	RDH	    22-Aug-85 10:56:05		;Add mouse tracking, selection, and selection inversion. ;--	RDH	    20-Aug-85  9:50:54		;Fix munge of DS after calling display handler procs. ;--	RDH	    17-Aug-85 16:36:50		;Delete error commenting out DisableInterruptsUntilNextWait. ;--	RDH	    17-Aug-85 16:36:50		;fix up cursor stuff.  Add zillions of WaitForSystem's.  Comment out %'DisableInterruptsUntilNextWait. ;--	RDH	    17-Aug-85 14:47:02		;Changed AH to AL near ButtonInnerLoop.  Add use of SetCursorPattern.  Set up DS for display handler procs. ;--	RDH	    17-Aug-85 13:23:34		;Saved ES at NoUnderflow. Restored ES at EnableDisplay. ;--	RDH	    17-Aug-85 11:45:58		;Added DisableInterruptsUntilNextWait. ;--	RDH	    16-Aug-85 20:42:11		;Add set up of BX for ChainUpICONDataStructure. Fix byteswap problem in SetICONbutton.  Remove skip over UI. ;--	RDH	    16-Aug-85 15:42:13		;Add WaitForSystem after before PaintScreenDeskTopGrey.  Fix error in loop control on WholeDisplayLoop.;--	RDH	    16-Aug-85  8:32:56		;Fold in JPM.s changes: ";Change reg for new parm to AH" and "Add parm to EtherInitialize".;--	RDH	    14-Aug-85 16:15:07		;Fold in changes for UI.;--	BKI	    11-Aug-85 19:30:28		;Convert to new EthIOFce;--	JPM	    22-Jul-85 15:19:49		;Change IOPEInROM alignment to WORD, set up clientCondition in EtherInitialize IOCBs.;--	JPM	    15-Jul-85 17:20:38		;Opie redesign conversion.;--	JMM	    26-Jun-85 14:44:07		;Fixed alternate etherbooting support.;--	BKI	    21-Jun-85 13:12:45		;Fixed alternate etherbooting support.;--	JMM	    19-Jun-85 17:17:56		;Added alternate etherbooting support.;--	JMM/BKI	    19-Jun-85 15:14:42		;Changed ethernet fifo limit because of slowed clock.;--	JPM	     24-May-85 14:58:06		;Overlay boot changes.;--	JMM	     15-Apr-85 16:50:14		;Initialize ethernet if present.;--	JMM	     25-Feb-85 15:30:45		;Removed IOPLRAM.asm.;--	JMM	      7-Dec-84 12:02:48		;First release.NAME		ROMBoot;--------------------------------------------------------------------------------;$NOLIST$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPDefs.asm)$INCLUDE	(QueDefs.asm)$INCLUDE	(QueMacro.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(ROMBDefs.asm)$INCLUDE	(EthIOFce.asm)$INCLUDE	(DsplDefs.asm)$INCLUDE	(ROMEEP.asm)$INCLUDE	(RAMEEP.asm)$LIST;--------------------------------------------------------------------------------EXTRN		BootStrapHandlerID: ABSEXTRN		DisplayHandlerID: ABSEXTRN		EthernetHandlerID: ABSEXTRN		KeyBoardAndMouseHandlerID: ABSEXTRN		MaintPanelHandlerID: ABS;---------------;******************************************************************;---------------IOPELocalRAM	SEGMENT	AT 0;from IOPLRAM.asm:;------------------EXTRN		HandlerInitProcTable: DWORDEXTRN		prebootSwitches: WORDEXTRN		bootType: BYTEEXTRN		diagType: BYTEEXTRN		finishMode: BYTEEXTRN		skipUserInterface: BYTEEXTRN		device: WORD	;VMMDefs.asmEXTRN		baseEthernetFileID: WORD;EXTRN		cleanFloppyHeadsPROC: WORDEXTRN		timeoutEnable: BYTEIOPELocalRAM	ENDS;---------------;******************************************************************;---------------;Imported Variables:;from IORROMBt.asm:;------------------BootStrapIOR	SEGMENT	COMMONEXTRN		bootTask: TaskContextBlock	;EXTRN		bootStrapTask: TaskContextBlock	;;EXTRN		jumpTable: BootJumpTable	;EXTRN		bootDeviceICON: ICONDataStructure ;EXTRN		displaySegment: WORD		;EXTRN		displayOffset: WORD		;;EXTRN		currentCursor: cursorPosition	;EXTRN		bootDeviceIORSpace: EtherBootContext ;EXTRN		ICONsBottomEdge: WORD ;EXTRN		ICONsTopEdge: WORD ;EXTRN		displayWidthInBytes: WORD ;;EXTRN		EndBootstrapIOR: FAREXTRN		OverlayLength: ABSEXTRN		displayStartOffset: WORDEXTRN		displayStartSegment: WORDEXTRN		bigTimeOut: BYTEEXTRN		littleTimeOut: WORDEXTRN		allowTimeout: BYTEBootStrapIOR	ENDS;from IORDisp.asm:;-----------------DisplayIOR	SEGMENT	COMMONEXTRN		numberBitsPerLine: WORD		;These two words contain the sizeEXTRN		numberDisplayLines: WORD	;of the display in bits.EXTRN		bitMapOrg: WORD			;This = 0 for Daybreak						;or "n" Achip Daisy;						;40000 for Daisy with one AChip.EXTRN		cursorXCoord: WORD		;After putting cursor position hereEXTRN		cursorYCoord: WORD		;set a bit in chngdInfo.EXTRN		borderHigh: BYTEEXTRN		borderLow: BYTEEXTRN		displCntl: BYTE			;Bit-3 <- 0 means display border.									;Bit-3 <- 1 means display picture.EXTRN		chngdInfo: WORD EXTRN		cursorPattern: BYTE		;place the display handler looks 						;for cursor bit map.  It is not 						;a BYTE but rather 32 bytes.DisplayIOR	ENDS;from IOREther.asm:;------------------EthernetIOR	SEGMENT	COMMONEXTRN		etherCmdAvail: ConditionEXTRN		etherOutQueue: QueueBlockEthernetIOR	ENDS;from IORKeyMo.asm:;------------------KeyBoardAndMouseIOR	SEGMENT	COMMONEXTRN		HexValue: BYTE			;ASCII value of key down.;EXTRN		MouseX: WORD, MouseY: WORD	;Delta motion change of mouse.KeyBoardAndMouseIOR	ENDS;from IORMaint.asm:;------------------MaintPanelIOR		SEGMENT	COMMONEXTRN			maintPanelCode: WORDEXTRN			maintPanelChanged: ConditionMaintPanelIOR		ENDS;--------------------------------------------------------------------------------BootStrapSTK	SEGMENT	COMMONEXTRN		BootStack: WORD			;initial stack for boot task.EXTRN		BootStrapStack: WORD		;initial stack for bootstrap task.BootStrapSTK	ENDS;---------------;******************************************************************;---------------IOPEInROM	SEGMENT	WORD PUBLIC 		ASSUME	CS:IOPEInROMPUBLIC		BootStrapInit, EtherInitialize, DisplayMPCodeEXTRN		DiskBootStrap: NEAR		;ROMDskBt.asmEXTRN		EthernetBootStrap: NEAR		;ROMEthBt.asmEXTRN		FloppyBootStrap: NEAR		;ROMFlpBt.asm;;--------------------------------------------------------------------------------;For initializing ethernet chips:;--------------------------------configureParms	DB	11			;configure byte count		DB	00BH			;fifo limit (008H for B2)		DB	080H			;bad frame, etc		DB	02EH			;loopback, etc		DB	000H			;backoff parms		DB	96			;interframe spacing		DB	000H			;slot time		DB	0F1H			;retry number		DB	000H			;promiscuous, etc		DB	000H			;carrier sense, collision detect		DB	64			;min frame lengthconfigureParmsSize	EQU	$-configureParms		EVENethernetBootFilePrefix	DW	%ByteSwap(00000H)	;Daisy boot file number			DW	%ByteSwap(0AA00H)			DW	%ByteSwap(00800H);---------------------------------------------------------------------------;Boot Keyboard knowledge:softKeyWidth		EQU		64	;in bitsnarrowGap		EQU		8	;in bits the gap between two softkeys 						;in the same group.wideGap			EQU		56	;in bits the gap between two groups of softkeys.;softKeyWidthInWords	EQU		softKeyWidth/16;bit offsets of the softkeys relative to the left side of the first softkey.f1SoftKeyOffset		EQU		0	f2SoftKeyOffset		EQU		f1SoftKeyOffset + softKeyWidth + narrowGap	f3SoftKeyOffset		EQU		f2SoftKeyOffset + softKeyWidth + narrowGap	f4SoftKeyOffset		EQU		f3SoftKeyOffset + softKeyWidth + narrowGap	f5SoftKeyOffset		EQU		f4SoftKeyOffset + softKeyWidth + wideGap	f6SoftKeyOffset		EQU		f5SoftKeyOffset + softKeyWidth + narrowGap	f7SoftKeyOffset		EQU		f6SoftKeyOffset + softKeyWidth + narrowGap	f8SoftKeyOffset		EQU		f7SoftKeyOffset + softKeyWidth + narrowGap	f9SoftKeyOffset		EQU		f8SoftKeyOffset + softKeyWidth + wideGap	f10SoftKeyOffset	EQU		f9SoftKeyOffset + softKeyWidth + narrowGap	totalWidthICONS		EQU		f10SoftKeyOffset + softKeyWidth		bootDeviceCode	DB	disk,floppy,ethernet,rs232C;sizeOfPageInBytes	DW	pageSizeInBytes;bitsPerWord		DW	wordBitSize;bitsPerByte		DW	8linesFromBottom		DW	distanceFromBottom;wordsPerLine		DW	16;bytesPerLine		DW	8STOPkey		EQU	01010100BKeyBoardBootSelect	EQU	$diagBootKeyBaseValue	EQU	01100110BbootKeyBaseValue	EQU	01100010BnumberKeyBaseValue	EQU	10000100BleftMouseButton		EQU	00000001BrightMouseButton	EQU	00000010BT1key		EQU	01100011BT9key		EQU	01101011BT4key		EQU	01100110Bdiagnostics	EQU	4		;T1key		DB	01100011B		;Disk boot.;T2key		DB	01100100B		;Floppy boot.;T3key		DB	01100101B		;Ethernet boot.;T4key		DB	01100110B		;.;diagnostics	EQU	$ - T1key;T5key		DB	01100111B		;Disk diag boot.;T6key		DB	01101000B		;Floppy diag boot.;T7key		DB	01101001B		;Ethernet diag boot.;T8key		DB	01101010B		;.;T9key		DB	01101011B		;Not used.;T10key		DB	01101100B		;Floppy head clean.;--------------------------------------------------------------------------------iconRelativeXcoordinates	DW	f1SoftKeyOffset				DW	f2SoftKeyOffset				DW	f3SoftKeyOffset				DW	f4SoftKeyOffset				DW	f5SoftKeyOffset				DW	f6SoftKeyOffset				DW	f7SoftKeyOffset				DW	f8SoftKeyOffset				DW	f9SoftKeyOffset				DW	f10SoftKeyOffset;--------------------------------------------------------------------------------;Boot Display:;-------------;1's show as white. 0's as black.desktopGray	EQU	1011101110111011B	;Two full length lines of						;each of this then shift right 						;twice for two more lines. Repeat						;over display for desktop gray.;---------------;------------------------------------;diskBootICON	DW	1111111111111111B 		DW	1110000000000111B 		DW	1100000000000011B 		DW	1100111111110011B 		DW	1100111111110011B 		DW	1100111111110011B 		DW	1100111111110011B 		DW	1100111111110011B 		DW	1100111111110011B 		DW	1100000000000011B 		DW	1110000000000111B 		DW	1111100000011111B 		DW	1100000000000011B 		DW	1001111111111001B 		DW	0000000000000000B 		DW	0000000000000000BsizeOfICON	EQU	$ - diskBootICON		;------------------;ethernetBootICON DW	1000001100000111B 		DW	1000001100000111B 		DW	1001001100100111B 		DW	1001001100100111B 		DW	1000001100000111B 		DW	1000001100000111B 		DW	1110111111011111B 		DW	0000000000000000B 		DW	0000000000000000B 		DW	1111101111110111B 		DW	1110000011000001B 		DW	1110000011000001B 		DW	1110010011001001B 		DW	1110010011001001B 		DW	1110000011000001B 		DW	1110000011000001B;------------------;floppyBootICON	DW	1111111111111111B 		DW	0000000000000011B 		DW	0000000000000011B 		DW	0000000000000011B 		DW	0000000000000011B 		DW	0000000000000011B 		DW	0000001100000011B 		DW	0111011110000011B 		DW	0000001100000011B 		DW	0000000000000011B 		DW	0000000000000011B 		DW	0000000000000011B 		DW	0000000000000011B 		DW	0000000000000011B 		DW	0000000000000011B 		DW	1111111111111111B;------------------;;floppyHdCleanICON DW	1111111111111111B ;		DW	1111111111011111B;		DW	1101011110001111B;		DW	1010110000000001B;		DW	0101010000000000B;		DW	1010111110001110B;		DW	1101011100000111B;		DW	1111111011111011B;		DW	1111111011111011B;		DW	1111111011111011B;		DW	1111111011111011B;		DW	1111111011111011B;		DW	1111111011111011B;		DW	1111111011111011B;		DW	1111111000000011B;		DW	1111111111111111B		 ;------------------availableICONs	DW	diskBootICON,floppyBootICON,ethernetBootICON;------------------;arrowCursor	DW	0000000001111111B ;		DW	0000000011111111B ;		DW	0000111111111111B ;		DW	0000001111111111B ;		DW	0010001111111111B ;		DW	0011000111111111B ;		DW	0011100011111111B ;		DW	0111110001111111B ;		DW	0111111000111111B ;		DW	1111111100011111B ;		DW	1111111110001111B ;		DW	1111111111000111B ;		DW	1111111111100011B ;		DW	1111111111110001B ;		DW	1111111111111000B ;		DW	1111111111111110B;------------------;arrowCursor	DW	0111111111111111B ;		DW	0011111111111111B ;		DW	0001111111111111B ;		DW	0000111111111111B ;		DW	0000011111111111B ;		DW	0000001111111111B ;		DW	0000000111111111B ;		DW	0000111111111111B ;		DW	0010011111111111B ;		DW	0110011111111111B ;		DW	1111001111111111B ;		DW	1111001111111111B ;		DW	1111100111111111B ;		DW	1111100111111111B ;		DW	1111110011111111B ;		DW	1111110011111111B;------------------diagnosticsICON	DW	1110000011111111B 		DW	1111001001111111B		DW	1111100101111111B		DW	0111110101111111B		DW	0011100101111111B		DW	0001001101111111B		DW	0100011100111111B		DW	0011111110111111B		DW	1000000011011111B		DW	1111111001001111B		DW	1111111100100111B		DW	1111111110110011B		DW	1111111111011001B		DW	1111111111001100B		DW	1111111111100001B		DW	1111111111110011B ;------------------;iconBorder	DW	1000000000000000B, 0000000000000000B, 0000000000000000B, 0000000000000010B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111001B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111111000B ;		DW	0111111111111111B, 1111111111111111B, 1111111111111111B, 1111111111110000B ;		DW	0000000000000000B, 0000000000000000B, 0000000000000000B, 0000000000000000B ;		DW	1000000000000000B, 0000000000000000B, 0000000000000000B, 0000000000000001B ;		DW	1100000000000000B, 0000000000000000B, 0000000000000000B, 0000000000000010B		 ;------------------;;--------------------------------------------------------------------------------;EPROM Boot Data:bootDeviceProc	DW	unKnownDevice, DiskBootStrap, FloppyBootStrap		DW	AltEthernetBoot, unKnownDevice, DiskDiag 		DW	FloppyDiag, EtherDiag, unKnownDevice 		DW	unKnownDevice, unKnownDevice		bootDevicesMask		EQU	01E0HbootDevicesToLow 	EQU	5floppyAndEthernet 	EQU	6dontTrustEEProm		EQU	8000HshortDiag		EQU	0longDiag		EQU	1DiagLEDsTo2		EQU	200H		;off-on-off  This should match def in Preboot.;--------------------------------------------------------------------------------;-- Initial entry:;-------------- Initialize the task bootTask, Jam it, and initialize ;-------------- bootStrapTask to start with the user interface. ;-------------- bootTask is the boot device independent task.  It sets up ;--------------|buffers for bootStrapTask to fill.  It then interprets those;--------------|buffers, running initial code, loading control store with;--------------|microcode, loading ram handlers, etc.  bootStrapTask is the ;--------------|device specific task.  It knows something about the boot;--------------|devices.  It fills the buffers with data from the boot device.;--------------|Communication between these two tasks is accomplished by the;--------------|conditions getBootFile, bootBufferFull, bootBufferEmpty, and;--------------|finishedLoaderFileFetch.;--------------|--------							|;-------------------------------------------------------------------------------BootStrapInit		PROC	FAR 			%InitializeTask	(BootStrapHandlerID,OFFSET bootTask,JamBootTask,OFFSET BootStack)JamBootTask:		%Jam	(BootStrapHandlerID,OFFSET bootTask)	;to be restarted by						;device specific code.						;to be resolved later.			%InitializeTask	(BootStrapHandlerID,OFFSET bootStrapTask,UserInterface,OFFSET BootStrapStack) 			RETBootStrapInit		ENDP   ;-- User Interface:;Put up the icons.  Wait for a key stroke or a mouse click selecting what;type of boot to do.;-------------------------------------------------------------------------------UserInterface	PROC	FAR		ASSUME	DS:BootStrapIOR 		MOV	AX, IOPELocalRAM	;load low RAM address		MOV	ES, AX			;  into ES		ASSUME	ES:IOPELocalRAM		CMP	skipUserInterface, normal		JE	StartUserInterface		JMP	BootDeviceSelection	;if doing diagnostics just continueStartUserInterface:		%CallHandlerInitProc	(KeyBoardAndMouseHandlerID)		%WaitForSystem				PUSH	ES		MOV	diagType, shortDiag		CMP	prebootSwitches, dontTrustEEProm	;did preboot indicate checksum is bad?		JNE	CheckFunctionKey9	;no, go see if user wants to ignore anyway			MOV	AX, KeyBoardAndMouseIOR	;yes, can't proceed until user hits function key 9		MOV	ES, AX		ASSUME  ES: KeyBoardAndMouseIOR		MOV	AX, DiagLEDsTo2		;Set LED's to give indication 		OUT	WriteConfigReg, AX	; that EEProm is bad.WaitForF9:	MOV	AL, HexValue		CMP	AL, T9key		JE	ClearLEDs		%WaitForSystem		JMP	SHORT WaitForF9ClearLEDs:	MOV	AX, 0			;turn off leds that preboot left on to indicate		OUT	WriteConfigReg, AX	;that checksum was badSetPrebootSwitches:		MOV	HexValue, 0		;just in case.....		POP	ES		ASSUME	ES:IOPELocalRAM		MOV	prebootSwitches, dontTrustEEProm		JMP 	SHORT InitDisplay		PauseForF9:	PUSH	BX		%WaitForSystem		JMP	SHORT TryAgain	CheckFunctionKey9:		%GetIntervalTimer		;returns value in AX		ADD	AX, 2000		;wait for ~2 seconds		PUSH	AX		%EstablishHandlerAccess(KeyBoardAndMouseHandlerID)		ASSUME  ES: KeyBoardAndMouseIORTryAgain:			MOV	AL, HexValue		POP	BX		CMP	AL, T9key		;does user want to ignore EEPROM?		JE	SetPrebootSwitches 	;yes, indicate that		CALL	HasTimeElapsed		;hasn't said so yet; see if our waiting time is up		JL	PauseForF9				ProceedWithUserInterface:		POP	ES		ASSUME	ES:IOPELocalRAMInitDisplay:		%CallHandlerInitProc    (MaintPanelHandlerID)		%CallHandlerInitProc	(DisplayHandlerID)		%WaitForSystem		;Let display and keyboard handlers run.PaintScreenDeskTopGrey:		MOV	AX, DisplayIOR		MOV	ES, AX		ASSUME	ES:DisplayIORSetUpDisplayMemoryAccess:		MOV	CX, bitMapOrg		MOV	DX, CX				;The first thing we want to do is paint		SHR	CX, byteLength			;the whole display desktop grey. So first			SHL	DX, byteLength			;get the display memory mapping from			MOV	CH, extendedBusOpieAddress 	;Opie.			PUSH	ES		%EstablishIOPAccess(generalMapRegister,CX-DX)GotAccess:	MOV	DisplaySegment, ES	;ES:DI points to beginning of 		MOV	DisplayOffset, DI	;display memory.		MOV	displayStartSegment, ES	;Save pointer for later use in		MOV	displayStartOffset, DI	; making booting MP codes legible.		POP	ES			;Get ES back to DisplayIOR.		MOV	BX, DI		MOV	AX, numberBitsPerLine	;We are going to write out the pattern a word 		SHR	AX, 4			;at a time per each two lines. We therefore		PUSH	AX			;need to know how may words per line this		MOV	SI, AX			;display has. This information is made		SHL	SI, 1			;available to us by the Display handler.						;The desktop grey pattern is made up of 						;lines of an alternating pattern where each		MOV	DI, numberDisplayLines	;pattern takes up two lines at a time. So		SHR	DI, 2			;since we will fill up four lines at a time 		MOV	displayWidthInBytes, SI	;we need to know how many sets of four full						;display lines the current machine has.						MOV	CX, DisplaySegment	;Set ES up to point into display.		MOV	ES, CX			;Use segment override for display.WholeDisplayLoop:		PUSHA				;Save state and let someone else have a chance.		%WaitForSystem		POPA				MOV	AX, desktopGray	;get background pattern for even lines		POP	CX		PUSH	CX		CALL	DoLine			;paint even lines of background pattern		ROR	AX, 2			;get background pattern for odd lines		POP	CX		PUSH	CX		CALL	DoLine			;paint odd lines of background pattern		DEC	DI			;are we done yet?		JNZ	WholeDisplayLoop		DonePainting:	;we need to special case the last line because the number of display lines is not		;an even multiple of 4.  this is true for both 17 and 19 inch displays		MOV	AX, desktopGray	;get background pattern for even lines		POP	CX		PUSH	CX		CALL	FillLineAllLinesPainted:		MOV	AX, ES			;Save possibly incremented ES into		MOV	DisplaySegment, AX	;DisplaySegment		MOV	AX, DisplayIOR		MOV 	ES, AX			;Now use ES to access displayIOR.		ASSUME	ES:DisplayIOR		POP	AX		 	;now figure out how to position the ICONs.		MOV	CX, AX		SHL	AX, 1			;AX gets bytes per line		MUL	CS: linesFromBottom	;The ICONs will be a given distance from the		SUB	BX, AX			;the bottom of the screen regardless of the		JNC	NoUnderflow		;size of the screen. Some display memories 		MOV	DX, DisplaySegment	;are larger than can be represented by 16 bits.		SUB	DX, crossover64KbBank	;Move DisplaySegment back a segment		MOV	DisplaySegment, DXNoUnderflow:	 		;Calculate bit offset in display line to first icon.		MOV	AX, numberBitsPerLine	;Keep icons centered		SUB	AX, totalWidthICONS	;If there is ever a display narrower than		SHR	AX,1			;the icons, look out.		PUSH	AX			;Save bit offset of first ICON on stack.		;SAR	AX, 3			;Convert bit offset to bytes		;ADD	BX, AX			;BX points to corner of first ICON		MOV	displayOffset, BX	;Save the base value of the beginning of the icon area.		;displayOffset is now a pointer to the upper lefthand corner of the first icon.InitializeICONs:SetUpICONs:	;Set up the icon's data structure.		MOV	CX, numberOfSoftKeys		;The first thing we want to do is to		MOV	DX, OFFSET bootDeviceICON	;set up the ICON data 		MOV	BX, DX				;structures such		MOV	DI, Null			;that the ICONs are positioned appropriately							;on the screen. i.e. towards the bottom;		MOV	AX, numberDisplayLines		;of the screen and centered. At the same;		SUB	AX, distanceFromBottom		;time we want to link the ICON data;		MOV	ICONsTopEdge, AX		;structures so that we can manipulate the ;		ADD	AX, ICONInnerDepth		;user interface bitmap a bit more easily.;		MOV	ICONsBottomEdge, AX				XOR	SI, SI		POP	AX				;We had saved first ICON bit offset here.		PUSH 	AX				;Keep it available.		ChainUpICONDataStructure:		PUSHA			;Save state and let someone else have a chance.		%WaitForSystem		POPA		ADD	AX, iconRelativeXcoordinates[SI]	;Get bit offset for this icon.				ADD	DX, SIZE bootDeviceICON		;Each ICON's data structure will point to		MOV	[BX].ICONLeftImagePtr, Null	;both the next ICON on the right and on the 			MOV	[BX].ICONRightImagePtr, Null	;left. For any side without an ICON, the			;MOV	[BX].leftBoundary, AX		;pointer there is NULL (=0). 			;MOV	[BX].rightBoundary, AX					;ADD	[BX].rightBoundary, softKeyWidth			MOV	[BX].bootingProcedure, OFFSET unKnownDevice	;This is not used!!!!!			MOV	[BX].nextICON, DX		MOV	[BX].invertedICON, notInverted					MOV	[BX].previousICON, DI			;		XOR	DX, DX		SHR	AX, 3			ADD	AX, displayOffset		;Make AX pointer to corner of icon		MOV	[BX].ICONOffset, AX		;Prepare for next iteration					POP	AX				;AX gets first ICON bit offset.		PUSH	AX				;Keep it on the stack.		MOV	DX, [BX].nextICON					MOV	DI, BX		MOV	BX, DX		INC	SI		INC	SI		LOOP	ChainUpICONDataStructure		POP	AX				;Return stack to normal		MOV	[DI].nextICON, Null		;Make last pointer null.				GetAvailableDevices:		MOV	AX, IOPELocalRAM		MOV	ES, AX		ASSUME 	ES: IOPELocalRAM		CMP	prebootSwitches, dontTrustEEProm		JNE	GetDevicesFromEEProm		MOV	AX, floppyAndEthernet		JMP	SHORT InitPointersGetDevicesFromEEProm:		%ReadEEProm(eePromBooting,1)		AND	AX, bootDevicesMask	;just get available devices		SAR	AX, bootDevicesToLow	;put in least significant byte		;ReadEEPROM(AvailableDevices)	;jmm:85-03-27		;MOV	AX,07			;Disk, floppy and ethernet available.		InitPointers:		MOV	CX, numberOfICONs		MOV	BX, OFFSET availableICONs		;BX points to array of pointers								;to icon bitmaps.		MOV	SI, OFFSET bootDeviceProc+2		;SI points into array of boot procs.		MOV	DI, OFFSET bootDeviceCode		;DI points to array of device codes.		MOV	BP, OFFSET bootDeviceICON		;BP points to first icon data structure.offsetToDiag		EQU		(SIZE bootDeviceICON)*4	offsetToBootDiag	EQU		8	;offset in bootDeviceProc to get from device to device diag 						;4 devices *2 words each		Initialize:	PUSHA	  			;Save state and let someone else have a chance.		%WaitForSystem		POPA		ROR	AX,1		JNC	NextDevice					;Skip unavailable devices.		MOV	DX, CS: [BX]					;DX points to icon bitmap		MOV	DS: [BP].ICONLeftImagePtr, DX			;Set up bitmap pointers		MOV	DS: [BP][offsetToDiag].ICONLeftImagePtr, DX		MOV	DS: [BP][offsetToDiag].ICONRightImagePtr, OFFSET diagnosticsICON		MOV	DX, CS: [DI]					;DX holds device code.		MOV	DS: [BP].bootDevice, DL				;Set boot device.			MOV	DS: [BP][offsetToDiag].bootDevice, DL		;Set boot device for diagnostic button				MOV	DS: [BP].typeOfBoot, normal			;Set type of boot		MOV	DS: [BP][offsetToDiag].typeOfBoot, diagnostic			MOV	DX, CS: [SI]					;DX points to boot proc		MOV	DS: [BP].bootingProcedure, DX			;Set boot proc		MOV	DX, CS: [SI+offsetToBootDiag]		MOV	DS: [BP][offsetToDiag].bootingProcedure, DX	;Set diagnostic boot procNextDevice:	INC	BX						;Point to next available 		INC	BX						;icon		INC	DI						;Next boot device		INC	SI						;Next boot device proc		INC	SI		MOV	BP, DS: [BP].nextICON				;Prepare endloop.		LOOP	Initialize SetUpICONSinDisplayMemory:		;Dump the ICON images into display memory.		MOV	BX, DisplaySegment		MOV	ES, BX				;Make ES point into display memory.		MOV	BX, OFFSET bootDeviceICON	;Point to first icon data structure.		SetUpAllICONS:	PUSHA				;Save state and let someone else have a chance.		%WaitForSystem		POPA		CALL	SetICONbutton			;Paint in button.		CMP	[BX].ICONLeftImagePtr, 0		JE	GetTheNextICON		CALL	SetUpDeviceSymbol		CALL	SetUPDeviceDiagSymbolGetTheNextICON:	MOV	BX, [BX].nextICON		OR	BX, BX				;This will be zero if the ICON we		JNZ	SetUpAllICONS			;just finished was the last one.				 EnableDisplay:	MOV	AX, DisplayIOR			;Allow access to Display's IO region.		MOV	ES, AX		ASSUME	ES: DisplayIOR;ES must be pointing into DisplayIOR when this code is executed.	;SetCursorPattern:;		XOR	SI, SI	;		XOR	DI, DI;		MOV	CX, 16			;CursorFillIn:	MOV	AX, arrowCursor[SI]	;The cursor pattern location is also provided;		MOV	cursorPattern[DI], AH	;by the Display handler and is a 32 byte array.;		MOV	cursorPattern[DI+1], AL	;;		INC	SI			;We should not initialize the cursor until;		INC	SI			;after we have initialized the display pattern.;		INC	DI;		INC	DI;		LOOP	CursorFillIn 				MOV	displCntl, hideCursorDisplayOn		MOV	borderLow, 0BBH		MOV	borderHigh, 0EEH		;The display handler procs called through commandProc and 		;cursorPatternProc think that DS contains displayIOR.		OR	chngdInfo, commandChngd		OR	chngdInfo, cursorPatternChngd		OR	chngdInfo, borderPatternChngdSelection:	;Timer stuff.		MOV	bigTimeOut, timeoutInterval	;Put number of seconds to wait in timeout counter.				MOV	AX, IOPELocalRAM		;Make ES point into		MOV	ES, AX				;data area for		ASSUME	ES: IOPELocalRAM		;timeoutEnable.				MOV 	finishMode, backToUI		;Set flag for diagnostics to know							; to go back through the user interface							; A default diagnostics boot will							; have finishMode set to bootSystem.		MOV	AL, timeoutEnable		;Get timeoutEnable flag.		MOV	allowTimeout, AL		;Save flag in own ioregion.		SetShortTimer:	%GetIntervalTimer			;Put timeOfDay in AX.		ADD	AX, oneSecond			;AX has short termination time in milliseconds		MOV	littleTimeOut, AX		;Save short timeout.SelectionLoop:	%WaitForSystem				;Let something happen. ;		XOR	AX, AX				;;		MOV	SI, OFFSET KeyBoardBootSelect	;		MOV	DL, T1key		MOV	AX, KeyBoardAndMouseIOR		;Set up ES for access		MOV	ES, AX				; to keyboard values.		ASSUME	ES:KeyBoardAndMouseIOR		MOV	AL, HexValue			;		MOV	CX, 10				;WhatDevice:	CMP	AL, DL				;check for normal boot 		JE	DeviceKnown			; 		INC	DL				; 		LOOP	WhatDevice				;CheckMouse:	CMP	AL, leftMouseButton		;Check mouse buttons;		JE	Click;		CMP	AL, rightMouseButton;		JE	Click;		PUSH	AX				;Save AX for stop key checking.  This will come out with the mouse tracking code.;TrackMouse:	CALL	GetMouseCoords			;Get current mouse position.;		PUSH	DS				;Save DS.;		MOV	CX, DisplayIOR			;Set DS to DisplayIOR;		MOV 	DS, CX				;;		MOV	DS: cursorXCoord, AX		;Tell display handler where cursor is.;		MOV	DS: cursorYCoord, BX;		OR	DS: chngdInfo, cursorPositionChngd  ;Have display handler set cursor position.;		POP	DS				;Restore DS to BootStrapIOR>;		POP	AX				;Get the value of HexValue back into  AL..  This should come out with the mouse tracking ode. 		;Check for stop key and timeout.		CMP	AL, STOPkey 			;Check for stop key.		JE	StopKeyPushed			;Go clear the timeoutEnabled flag.		TEST	allowTimeout, timeOutEnab	;Check timeoutEnabled flag.		JZ	TimeOutDisabled			;Go fix stack and do loop again.		MOV	BX, littleTimeOut		;Get timeout time into BX.		CALL	HasTimeElapsed			;Returns compare of current-time-of-day, BX (BX is timeout time) 		JL	SelectionLoop			;If second over check bigTimeOut otherwise wait some more.		DEC	bigTimeOut			;Decrement number of seconds left.		JNZ	SetShortTimer			;If nonzero go back and restart short timer.		TimedOut:	;Check EEProm for default boot device and default mode.		;This implementation assumes that if the eeprom is bad the default default		; is to wait indefinitely for user input.		MOV	AX, IOPELocalRAM		MOV	ES, AX		ASSUME	ES:IOPELocalRAM		MOV	finishMode, bootSystem		;Tell diagnostics not to return to UI 				%ReadEEProm(eePromBooting, 1)		JNC	HaveDefaultDevice		;See if eeprom is ok.BadEeprom:	;PUSH	AX				;Put filler on stack.TimeOutDisabled:StopKeyPushed:	MOV	allowTimeout, timeOutDisab 	;Clear timeout enabled flag.		JMP	SHORT SelectionLoop		;Wait for action.HaveDefaultDevice:		AND	AX, 0FH				;Mask out all but default device bits.		JZ	TimeOutDisabled			;if no default boot devices in EEPROM then disable timeouts		PUSH	AX				;Save AL to make into index for bootdeviceProc		%ReadEEProm(eePromMisc, 1)		;Do diags by default?		JC	BadEeprom			;See if eeprom is ok.		TEST	AL, 1				;Test the def diags bit.		POP	AX				;POP does not affect flags.		JZ	NoDefDiags		ADD	AL, diagnostics			;Change index to indicate the analagous diag boot.NoDefDiags:	DEC	AL				;There is no zero icon data structure.  The index must be shifted by 1.		JMP	SHORT GetIconDataStrucPtr	;Go use AL to get the right icon data structure and boot therefrom.						;FoundKeyMatch:	POP	BX				;Clear timeoutEnable and;		POP	BX				; timeout time from stack.;		JMP	DeviceKnown			;Click:		;A mouse button has been pushed.  See if cursor is over icon.;		%'EstablishHandlerAccess(KeyBoardAndMouseHandlerID);		ASSUME ES: KeyBoardAndMouseIOR;		CALL	GetMouseCoords			;Get current mouse position.;		CMP	BX, ICONsBottomEdge		;See if cursor is below icons.;		JG	NotOverIcon;		CMP	BX, ICONsTopEdge		;See if cursor is above icons.;		JL	NotOverIcon;CheckXPos:;		MOV	CX, numberOfSoftKeys		;Check the icon data structures for the xoocrdinate.;		MOV	DI, OFFSET bootDeviceICON	;DI points to first icon datat structure.;CheckXPosLoop:	CMP	AX, DS:[DI].rightBoundary	;See if cursor is right of the icon.;		JG	NotThisOne;		CMP	AX, DS:[DI].leftBoundary	;See if cursor is left of the icon.;		JGE	IconSelected			;NotThisOne:	ADD	DI, SIZE ICONDataStructure	;Point to next one.;		LOOP	CheckXPosLoop		;NotOverIcon:	MOV	HexValue, 0			;Don't see another click until there is one.		;		JMP	TrackMouse			;Move the cursor and wait again.DeviceKnown:	;Invert the icon corresponding to the key pressed.		;PUSH	AX				;Save key value.		ASSUME	ES: KeyBoardAndMouseIOR		;why does the assembler get confused here?		MOV	HexValue, 0		SUB	AL, T1Key			;Get key offset.		CMP	AL, diagnostics			;Before we join with the default code		JL	GetIconDataStrucPtr		; check for a diagnostic boot and		MOV	allowTimeOut, timeOutDisab	; disable timeouts for after diagnostics run.GetIconDataStrucPtr:					;Default booting enters here.		MOV	BL, SIZE ICONDataStructure	;Convert key value to pointer to icon data structure.		MUL	BL				;Make AX index the array of icon data structures.		MOV	DI, OFFSET bootDeviceICON	;Set up base of array		ADD	DI, AX				;DI points to correct icon  data structure.		;PUSH	SI		;CALL	InvertICON			;Invert that icon!		;POP	SI		;POP	AX				;Restore key value.		;JMP	IconSelected		IconSelected:	;DI points to ICONDataStructure to be inverted.;After this proc the icon is inverted and AX, CX, SI, BX are smashed.InvertICON:		NOT	DS:[DI].invertedICON		;Toggle inverted flag.		PUSH	ES		MOV	AX, DS:displaySegment		MOV	ES, AX			MOV	CX, ICONInnerDepth		;Prepare line counter.		MOV	SI, DS:[DI].ICONOffset		;ES:SI points to corner of icon.InvertOuterLoop:		XOR	BX, BX				;Prepare byte counter.InvertInnerLoop:		NOT	BYTE PTR ES:[SI][BX]		;invert a byte.		INC	BX		CMP	BX, softKeyWidth/8		;bytes across softkey.		JNE	InvertInnerLoop		ADD	SI, DS: displayWidthInBytes		LOOP	InvertOuterLoop		POP	ES		;Paint a square of the upper left hand corner of display memory white		; to provide a pretty background for the maintenance panel.  It must be		; a little bit bigger than the 16x16 cursor to provide good legibility.		MOV	SI, displayStartOffset		;Get pointer to the beginning		MOV	AX, displayStartSegment		; of the display bank.		MOV	ES, AX		ASSUME	ES:NOTHING			;Assembler doesn't know about display bank.		MOV	AX, 0FFFFH			;Load big paint brush with white paint.		MOV	BL, maintPanelBkGrdRightPad	;Load little brush with a little paint.		MOV	CX, maintPanelBkGrdHeight	;Mark out height of area to paint.PaintSquare:	MOV	ES:[SI], AX			;A stroke with the big brush.		OR	ES:[SI+2], BL			;A dainty stroke with the little brush.		ADD	SI, displayWidthInBytes		;Move scaffolding down to the next line.		LOOP	PaintSquare			;Are we done yet??				MOV	CX, DisplayIOR			;Return cursor to upper left corner of screen		MOV 	ES, CX		ASSUME	ES: DisplayIOR		MOV	cursorXCoord, mpcodeCursorXPos		MOV	cursorYCoord, mpcodeCursorYPos		MOV	displCntl, niceMPDisplayOn		OR	chngdInfo, cursorPositionChngd		OR	chngdInfo, backgroundChngd		;quick slip in a slimy mp code!		MOV	AX, mpStartBooting		CALL	DisplayMPCode			;this does a wait for system		MOV	BX, IOPELocalRAM		;Set up access to local ram segment.		MOV	ES, BX		ASSUME	ES:IOPELocalRAM		MOV	AL, DS:[DI].bootDevice		;Set boot device variable.		CBW					;Make it a word		MOV	device, AX			;				MOV	AL, allowTimeout		;Save the state of timeouts		MOV	timeOutEnable, AL		; for after diagnostics run,							; if they do.				CMP	DS:[DI].typeOfBoot, normal	;See if its a diagnostic bot.		JE	ItsNormal		MOV	bootType, diagnostic		;It's diagnostic boot.		JMP	SHORT CallBootProcItsNormal:	MOV	bootType, normal		;It's normal boot.CallBootProc:	MOV	AX, [DI].bootingProcedure	;clearing ioregion will smash this ZeroBootDeviceIORSpace:		MOV	BX, OFFSET(bootDeviceIORSpace)	;clear ioregion for device specific code		MOV 	CX, OverlayLength		;get number of bytes to be cleared		XOR	SI, SIZeroLoop:	MOV	BYTE PTR [BX + SI], 0		INC  	SI		LOOP 	ZeroLoop		JMP	AX				;Boot.				;Set parameters in low memory and start booting. 		;MOV	BX, IOPELocalRAM		;MOV	ES, BX		;ASSUME	ES:IOPELocalRAM		;CMP	AL, CS: [SI]			;check for diag boot 		;JE	NonDiagBoot			; 		;SUB	AX, diagBootKeyBaseValue		;MOV	bootType, diagnostic		;		;JMP	GoBoot;NonDiagBoot:	SUB	AX, bootKeyBaseValue		;MOV	bootType, normal		;;GoBoot:		MOV	device, AX		;		;CALL 	ZeroBootDeviceIORSpace	;device specific code assumes this is zero and icons munged itMouseInterpreter:KeyBoardInterpreter:DisplayInterface:BootDeviceSelection:		ASSUME  ES:IOPELocalRAM		MOV	SI, device		SHL	SI, 1		JMP	WORD PTR CS: bootDeviceProc[SI]				DiskDiag:	CALL 	ShortOrLongDiag		JMP	DiskBootStrap		FloppyDiag:	CALL 	ShortOrLongDiag		JMP	FloppyBootStrap		EtherDiag:	CALL 	ShortOrLongDiag			;Note this assumes AltEthernetBoot is directly belowAltEthernetBoot:		CMP	skipUserInterface, normal	;see note at EtherDiag		JNE	StartEthernetBoot		%WaitForTime	(3000)			;Give user time to select		MOV	AX, KeyBoardAndMouseIOR		MOV	ES, AX		ASSUME	ES:KeyBoardAndMouseIOR		MOV	AL, HexValue			;an alternate boot. 		SUB	AL, numberKeyBaseValue		;Choices are 1 thru 7.		CMP	AL, 01				;		JL	DefaultAltBoot			;		CMP	AL, 07		JLE	SelectedAltBootDefaultAltBoot:	MOV	AL, 0				;alternate suffixSelectedAltBoot:		MOV	BX, IOPELocalRAM		MOV	ES, BX		ASSUME	ES:IOPELocalRAM		;JMP	SHORT ProceedEthernetBoot;EthernetBoot:	XOR	AL, AL				;primary suffixProceedEthernetBoot:		MOV	CX, 6				;		MOV	DI, OFFSET baseEthernetFileID	;		MOV	SI, OFFSET ethernetBootFilePrefix		CLDStoreEthernetFileID:		MOVS	BYTE PTR ES:[DI], CS:[SI]	;		LOOP	StoreEthernetFileID		OR	ES:[DI - 1], AL	;set suffix  (by OR'ing, not MOV'ing!).StartEthernetBoot:			JMP	EthernetBootStrap		ShortOrLongDiag	PROC	NEAR		PUSH	ES		%GetIntervalTimer		ADD	AX, 1000			;wait for ~ 1 second		PUSH	AX		MOV	CX, device				;push pointer to IOPELocalRam		ADD	CL, T4key			;determine if same key was pressed again toWaitForLong:	%EstablishHandlerAccess(KeyBoardAndMouseHandlerID)		ASSUME ES: KeyBoardAndMouseIOR 		CMP	HexValue, CL		POP	BX		POP	ES		ASSUME ES: IOPELocalRam		JE	SetLongDiag		CALL	HasTimeElapsed		JGE	ShortOrLongRet		PUSH	ES		PUSH	BX		JMP	SHORT WaitForLongSetLongDiag:	MOV	diagType, longDiagShortOrLongRet:	RETShortOrLongDiag	ENDP		;PARAMETERS: 	BX has been set with the value that the interval timer should read when ;time has elapsed.;SMASHES:	AX;RETURNS	ends with a compare so flags are set accordingly HasTimeElapsed	PROC	NEAR		%GetIntervalTimer		CMP	AX, BX		RETHasTimeElapsed	ENDPFloppyHeadClean: 		;quick slip in another slimy mp code!		;MOV	AX, mpFloppyCleaning		;CALL	DisplayMPCode		;CALL	DWORD PTR cleanFloppyHeadsPROC		unKnownDevice:			MOV	AX, mpDeviceUnknown		CALL	DisplayMPCodeStayHere:	JMP	SHORT StayHere		;this really should do a Jam			UserInterface	ENDP		ASSUME	DS:NOTHING, ES:NOTHING;--------BitsToDisplayPROCs	PROC	NEAR		ASSUME	DS:BootStrapIOR		topAndBottomEdgePat	EQU	0hleftEdgePatByteSw	EQU	0FF7FhrightEdgePatByteSw	EQU	0F8FFhcenterPat		EQU	0FFFFhlinesInCenterPat	EQU	20byteButt		EQU	4; entry, BX has icon index;ES to display memSetICONbutton:	MOV	SI, [BX].ICONOffset		CALL	PaintTopBottomEdges		MOV	CX, linesInCenterPatPaintCenterPat:				PUSH	SI		MOV	ES:[SI], leftEdgePatByteSw		MOV	ES:[SI+2], centerPat		MOV	ES:[SI+4], centerPat		MOV	ES:[SI+6], rightEdgePatByteSw		POP	SI		ADD	SI, displayWidthInBytes		LOOP	PaintCenterPat		CALL	PaintTopBottomEdges		CALL	PaintTopBottomEdges		CALL	PaintTopBottomEdges		RET;entry SI point where painting to begin. exit SI points to byte below it in icon pix	;ES to display mem	PaintTopBottomEdges:		MOV	CX, byteButt			PUSH	SIPaintTopBottomLoop:				MOV	WORD PTR ES:[SI], topAndBottomEdgePat		INC	SI		INC	SI		LOOP	PaintTopBottomLoop		POP	SI		ADD	SI, displayWidthInBytes		RET			;--------SetUpDeviceSymbol:		MOV	DI, [BX].ICONLeftImagePtr	;If there is a symbol for this ICON		OR	DI, DI				;button, this value should be non-zero		JZ	LetsGetOut			;i.e. it will point to the symbol.		MOV	AX, displayWidthInBytes;		XOR	DX, DX		MOV	SI, vertIconOffsetInButton	;Icon starts a few lines below top of button.		MUL	SI				;		MOV	SI, [BX].ICONOffset		ADD	SI, AX		ADD	SI, leftIconOffsetInButton	;Icon starts a few bytes inside of the edge of the button. 		MOV	CX, 16MoveDeviceSymbol:		MOV	AX, CS: [DI]		MOV	ES: [SI], AH		MOV	ES: [SI+1], AL		INC	DI		INC	DI		ADD	SI, displayWidthInBytes		LOOP	MoveDeviceSymbolLetsGetOut:	RET		;--------SetUPDeviceDiagSymbol:		MOV	DI, [BX].ICONRightImagePtr	;If there is a symbol for this ICON		OR	DI, DI				;button, this value should be non-zero		JZ	GetOut				;i.e. it will point to the symbol.		MOV	AX, displayWidthInBytes;		XOR	DX, DX		MOV	SI, vertIconOffsetInButton		MUL	SI		MOV	SI, [BX].ICONOffset		ADD	SI, AX		ADD	SI, rightIconOffsetInButton	;Icon starts a few bytes inside of the edge of the button. 		MOV	CX, 16MoveDiagSymbol:		MOV	AX, CS: [DI]		MOV	ES: [SI], AH		MOV	ES: [SI+1], AL		INC	DI		INC	DI		ADD	SI, displayWidthInBytes		LOOP	MoveDiagSymbolGetOut:		RET	BitsToDisplayPROCs	ENDP;--------;Background pattern painting procsDoLine		PROC	NEAR		PUSH	CX			;leave loop counter on stack		CALL	FillLine		;paint one line		POP	CX		;ADD	BX, SI		;JNC	FinishSecondLine		;CALL	BumpES			;watch out for crossing 64kb boundaryFinishSecondLine:		CALL	FillLine		;paint the second line		;ADD	BX, SI			;point to the next line		;JNC	DoLineDone		;CALL	BumpES			;watch out for crossing 64kb boundaryDoLineDone:	RETDoLine		ENDPFillLine	PROC	NEAR	PaintLine:	MOV	ES:[BX], AX		;paint a word		INC	BX			;point to the next word		INC	BX		JNZ	LoopFillLine;Move ES into the next block of 64kbBumpES:		PUSH	AX			;Save pattern		MOV	AX, ES			;Change segment register to point		ADD	AX, crossover64KbBank	;into next 64K		MOV	ES, AX		POP	AX			;Recover patternLoopFillLine:	LOOP	PaintLine		RETFillLine	ENDP;--------;GetMouseCoords		PROC		NEAR;ES points into KB's IORegion.;Returns mouseX and mouseY byteswapped in AX and BX;		ASSUME	ES: KeyBoardAndMouseIOR;GetMouseX:	MOV	AX, mouseX;		XCHG	AH, AL;		MOV	BX, mouseY;		XCHG	BH, BL;		RET			;GetMouseCoords		ENDP;--------		ASSUME	DS:NOTHING, ES:NOTHING;-- Ethernet chip initialization:;--------------  Assume parameter locations upon entry into System procedure;--------------  are as follows:;-------------- ;--------------|	DS:[DI] points to an Ethernet IOCB			|;--------------|	DS:[BX] points to a condition variable			|;--------------|	AL contains handler ID for calling task			|;--------------|	AH contains broadcast disable & other framing parameters|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|								|;--------------|								|;--------------|								|;--------------|								|;-------------------------------------------------------------------------------EtherInitialize	PROC	NEAR		PUSH	ESSetUpReset:	MOV	DH, iocbReset SHL 4		CALL	InitEtherIOCB		CALL	ExecuteCommand		JZ	i82586InitErrorSetUpConfigure:	MOV	DH, (iocbCommand SHL 4)+acConfigure		CALL	InitEtherIOCB		MOV	SI, OFFSET configureParms		PUSH	DI		LEA	DI, [DI].iocbVariant	;ES already set by InitEtherIOCB		MOV	CX, configureParmsSize		CLDSetUpConfigureLoop:		MOVS	BYTE PTR ES:[DI], BYTE PTR CS:[SI]		LOOP	SetUpConfigureLoop		POP	DI		MOV	ES:[DI].iocbVariant[8], AH		CALL	ExecuteCommand		JZ	i82586InitErrorSetUpIndAddr:	MOV	DH, (iocbCommand SHL 4)+acIndAddr		CALL	InitEtherIOCB		PUSH	BX		XOR	BX, BX		MOV	CX, addrSize		MOV	DX, ReadHostProm		PUSH	AXFirstSetHostProm:		IN	AL, DX		MOV	[DI].iocbVariant.cmdParms.indAddr[BX], AL		INC	BX		INC	DX		INC	DX		LOOP	FirstSetHostProm		POP	AX		POP	BX		CALL	ExecuteCommand		JZ	i82586InitErrorReceiveFrames:	MOV	DH, iocbStartRU SHL 4		CALL	InitEtherIOCB		CALL	ExecuteCommand		;for startRU, always returns iocbOkay=TRUEi82586InitError:		POP	ES 		IRETEtherInitialize	ENDP;-------------------ExecuteCommand	PROC	NEAR		MOV	[DI].iocbCondition.handlerID, AL		MOV	[DI].iocbCondition.conditionPtr, BX		OR	[DI].iocbCondition.conditionPtr, nonNilPtr		MOV	CH, IOPIORegionOpieAddress		MOV	CL, AL		PUSH	AX		%EstablishHandlerAccess	(EthernetHandlerID)		ASSUME	ES:EthernetIOR		MOV	etherOutQueue.queueNext.OpieAddressLow, DI		MOV	etherOutQueue.queueNext.OpieAddressHigh, CX		PUSH	DI		PUSH	BX		%NotifyHandlerCondition	(EthernetHandlerID,OFFSET etherCmdAvail)		POP	BX		PUSH	BX		%WaitForCondition	(BX,noTimeout)		POP	BX		POP	DI		POP	AX		TEST	[DI].iocbStatus, MASK iocbOkay		RETExecuteCommand	ENDPInitEtherIOCB	PROC	NEAR		PUSH	AX		XOR	AL, AL		MOV	CX, DS		MOV	ES, CX		MOV	CX, SIZE IOCB		PUSH	DI		CLD		REP	STOSB		POP	DI		MOV	[DI].iocbType, DH		POP	AX		RETInitEtherIOCB	ENDP		ASSUME	ES:NOTHING;--; Call this to put a number into the curser as an MP code.; On Entry, AX contains number to be displayed.DisplayMPCode	PROC		PUSH	ES		PUSHA		PUSH	AX			;EstablishHandlerAccess smashes this register		%EstablishHandlerAccess	(MaintPanelHandlerID)		POP	AX		ASSUME	ES:MaintPanelIOR		MOV	maintPanelCode, AX		%NotifyHandlerCondition	(MaintPanelHandlerID,OFFSET maintPanelChanged)		%WaitForSystem		POPA		POP	ES		RETDisplayMPCode	ENDPIOPEInROM		ENDS;********************************************************************************			END
$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;-- stored as [Idun]<WDLion>Dove>IOPTimer.asm;-- created on  19-Mar-84 10:19:36;-- last edited by:;--	BKI	 2-Sep-85 20:26:29	:Fix FixUpTimerQueue bug (zero timerValue if last entry);--	JPM	25-Jul-85 17:31:55	:Fix bug (wrong segment value if two tasks time out at once);--	JPM	22-Jul-85 10:27:05	:Change IOPEInROM alignment to WORD;--	JPM	10-Jul-85 16:29:31	:Add code to ensure last queue entry has timerValue = 0, fixed dequeueing (must set new head before call to InsertInSystemQueue);--	JPM	 6-Jul-85 13:36:29	:Opie redesign;--	KEK	 8-Apr-85 19:20:46	:change jmp to EndWhileGT to be unsigned (effectively doubling maximum time interval allowed).;--	KEK	 3-Mar-85 15:02:27	:changed printing directives;--	VXS 	20-Nov-84 18:34:59	:Add include of HardOpie and OpieDefs;--	VXS 	14-Nov-84 20:07:01	:Install code to support multiple waiters on condition variables.;--	VXS 	 7-Nov-84 13:05:04	:change timerBadIntr to do Jam and Restart instead of calling timerInit.;--	VXS 	 1-Nov-84 13:40:38	:Change InsertInTimerQueue to be normal routine, and not fall thru to FromInterruptORSystemState;					: so that WaitForCondition can call it. ;--	VXS 	10-Oct-84 18:58:16	:Turn off interrupts while doubleword time of day gets incremented;--	VXS 	16-Jul-84 15:21:03	:Add EXTRNs for timer IORegion stuff;					IOImport no longer exists, take out INCLUDE;--	JMM 	27-Jun-84 15:12:25	:Opie Version 1 release;--	JMM	27-Jun-84  0:02:49 	:fixed CV timeouts..;--	ETN	25-Jun-84 14:59:10 	:removed DeQueue refs.;--	JMM/BKI	20-Jun-84 23:47:08;--	JMM    	19-Jun-84 18:32:41NAME			IOPTimer;--------------------------------------------------------------------------------
$NOLIST$INCLUDE		(IOPDefs.asm)$INCLUDE		(HardOpie.asm)$INCLUDE		(OpieDefs.asm)$INCLUDE		(IOPMacro.asm)$LIST;--------------------------------------------------------------------------------
OpieIOR			SEGMENT		COMMON EXTRN			SegmentTableAddress: SegmentAndOffsetEXTRN			timerQueue: IOPEQueueEXTRN			secondsCounter: WORD, intervalTimer: WORDEXTRN			timeOfDay: TimeOfDayFormatEXTRN			ticksTillNextTimeout: WORDOpieIOR			ENDS;********************************************************************************IOPEInROM		SEGMENT	WORD PUBLIC			ASSUME	CS:IOPEInROM			;--------------------------------------------------------------------------------;LOCAL CONSTANTS:								;--------------------------------------------------------------------------------PUBLIC			TimerTaskInit, InsertInTimerQueue, FixUpTimerQueueEXTRN			InsertInSystemQueue: NEAR;--------------------------------------------------------------------------------			;-- IOPETimerHandler:;--------------  Timer2 runs as the IOP System timer with a resolution of ten	;--------------  milliseconds.TimerTaskInit:			ASSUME	DS:OpieIOR			MOV	DX, IOPETimerMaxCountReg   ;Make IOPE timer interrupt			MOV	AX, timerResolution  ;every ten milliseconds			OUT	DX, AX			MOV	DX, IOPETimerMCWAddr			MOV	AX, ContinousRunWithInterrupts			OUT	DX, AX			MOV	secondsCounter, secondResolution	;Initialize secondsCounter			MOV	intervalTimer, 0	;Initialize intervalTimer			%ThisTaskServices	(IOPETimerInterrupt,timerBadIntr)			%DisableInterruptsTillNextWait			%Enable	(IOPETimerInterrupt)						;Turn on timer interrupt channel.			WaitingForTickTock:	%WaitForInterrupt	(noTimeout)			ADD	intervalTimer, millisecondsPerTick	;wraparound millisecond counter			DEC	secondsCounter		;Decr every millisecond			JNZ	CheckTimerQueue		;the seconds counter until			MOV	secondsCounter, secondResolution	;hit zero.			CLI				;Turn off interrupts so devices don't see inconsistent time of day.			ADD	timeOfDay.lowWord, 1	;bump the 32-bit TimeOfDay counter			ADC	timeOfDay.highWord, 0	;by one.CheckTimerQueue:			CLI				;Interrupt level can mess with timer queue			CMP	timerQueue.handlerIDforHead, nilHandlerID	;Look at timer queue			JE	WaitingForTickTock	;if empty, loop 			DEC	ticksTillNextTimeout			JNZ	WaitingForTickTock	;if no timeout yet, loop;timeout has occurred, must remove entry from queue			MOV	AX, DS			;copy Opie's IOR address			MOV	ES, AX			; into ES (for InsertInSystemQueue)			ASSUME	DS:NOTHING			ASSUME	ES:OpieIORRemoveHeadFromTimerQ:	MOV	SI, timerQueue.linkPtrforHead			MOV	AL, timerQueue.handlerIDforHead			MOV	AH, 0			SHL	AX, 2			LDS	BX, SegmentTableAddress			ADD	BX, AX			MOV	BP, DS:[BX].stackSegment	;save for later			MOV	DS, DS:[BX].ioRegionSegment;DS:[SI] now points to first TCB on queue			MOV	CX, [SI].timerValue		;save for later			MOV	AL, [SI].taskQueue.nextHandlerID ; update			MOV	timerQueue.handlerIDforHead, AL	; timer queue head			MOV	AX, [SI].taskQueue.nextTCBLinkPtr ; to point to			MOV	timerQueue.linkPtrforHead, AX	; next task			CALL	InsertInSystemQueue	;put task on system queue;was this task waiting for a condition?			CMP	[SI].taskState, prevStatewaitForCondition+waitForSystemState			JNE	CheckNewTimerHead			MOV	BX, [SI].taskCondition			MOV	[BX].TCBLinkPtr, Null	;disconnect condition;set task's CF to indicate timeout			MOV	BX, [SI].taskSP			PUSH	DS			MOV	DS, BP			;get access to task's stack			OR	WORD PTR DS:[BX]+waitStackFlagOffset, MASK i80186CF	;set timeout flag			POP	DSCheckNewTimerHead:	CMP	timerQueue.handlerIDforHead, nilHandlerID			JE	UpdateTicksTillNext			JCXZ	RemoveHeadFromTimerQ	;another task timed outUpdateTicksTillNext:	MOV	BX, ES			MOV	DS, BX			ASSUME	DS:OpieIOR			MOV	ticksTillNextTimeout, CX	;  timeout countTimeGoesOn:		JMP	WaitingForTickTock			ASSUME	DS:NOTHING			ASSUME	ES:NOTHINGtimerBadIntr		PROC	FAR			RET	;shouldn't get bad interrupt, since task is always waitingtimerBadIntr		ENDP			;-- InsertInTimerQueue:;--------------| The following parameters are assumed upon entry.		|;--------------|		DS:[SI] = Task to be added.			|;--------------|		ES points to Opie's IORegion			|;--------------|		AX = timer value in milliseconds		|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|		Task inserted in timer queue at right spot 	|;--------------|		AX and BX trashed, other registers preserved	|;--------------|								|;-------------------------------------------------------------------------------InsertInTimerQueue:			ASSUME	ES:OpieIOR			PUSH	DX			PUSH	CX			XOR	DX, DX			MOV	BX, millisecondsPerTick			DIV	BX			CMP	DX, 0			JE	CheckQueueHead			INC	AX			;round upCheckQueueHead:		INC	AX			;extra increment to ensure enough ticks			MOV	CL, [SI].taskHandlerID			MOV	DL, timerQueue.handlerIDforHead			MOV	BX, timerQueue.linkPtrforHead			CMP	DL, nilHandlerID			JE	InsertTaskEmptyQueue			SUB	AX, ticksTillNextTimeout			JBE	InsertTaskAtTimerHead			PUSH	DS			PUSH	DIRunThroughTimerQueue:	MOV	DI, BX			MOV	DH, 0			SHL	DX, 2			LDS	BX, SegmentTableAddress			ADD	BX, DX			MOV	DS, DS:[BX].ioRegionSegment			MOV	DL, DS:[DI].taskQueue.nextHandlerID			MOV	BX, DS:[DI].taskQueue.nextTCBLinkPtr			SUB	AX, DS:[DI].timerValue			JBE	InsertTaskAfterThis			CMP	DL, nilHandlerID			JNE	RunThroughTimerQueue			MOV	DS:[DI].timerValue, AX			XOR	AX, AXInsertTaskAfterThis:	MOV	DS:[DI].taskQueue.nextHandlerID, CL			MOV	DS:[DI].taskQueue.nextTCBLinkPtr, SI			ADD	DS:[DI].timerValue, AX			POP	DI			POP	DS			JMP	SHORT InsertTaskTimerEndInsertTaskEmptyQueue:	MOV	ticksTillNextTimeout, AX			XOR	AX, AXInsertTaskAtTimerHead:	MOV	timerQueue.handlerIDforHead, CL			MOV	timerQueue.linkPtrforHead, SI			ADD	ticksTillNextTimeout, AXInsertTaskTimerEnd:	MOV	[SI].taskQueue.IOPEQueueType, timerQueueType			MOV	[SI].taskQueue.nextHandlerID, DL			MOV	[SI].taskQueue.nextTCBLinkPtr, BX			NEG	AX			MOV	[SI].timerValue, AX			POP	CX			POP	DX			RET			ASSUME	ES:NOTHING;-- FixUpTimerQueue:;--------------| The following parameters are assumed upon entry.		|;--------------|		DS:[SI] = Task to be removed.			|;--------------|		If CF = 1, ES = Opie's IOR (task is head)	|;--------------|		  else ES:[DI] = Previous task			|;--------------|--------							|;--------------| Upon exiting this procedure the following will be true:	|;--------------|		IF CF = 1, ticksTillNextTimeout updated 	|;--------------|		  else previous task's timerValue updated	|;--------------|		AX trashed, other registers preserved		|;--------------|								|;-------------------------------------------------------------------------------FixUpTimerQueue:			MOV	AX, [SI].timerValue			JC	FixUpFirstEntry			CMP	[SI].nextHandlerID, nilHandlerID			JE	FixUpLastEntry			ADD	ES:[DI].timerValue, AX			RETFixUpLastEntry:		MOV	ES:[DI].timerValue, 0			RETFixUpFirstEntry:	ADD	ES:ticksTillNextTimeout, AX			RETIOPEInROM		ENDS			;********************************************************************************									END
$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;-- stored as [Iris]<WMicro>Dove>IOPLMap.asm;-- created on  26-Sep-84 13:16:15;-- last edited by:;--	JPM	22-Jul-85 10:12:46	:Change IOPEInROM alignment to WORD;--	JPM	24-Jun-85 12:58:40	:Removed code for general map reg test (will handle like other regs);--	JPM	21-Jun-85 17:37:02	:Reworked for efficiency;--	JPM	20-May-85 14:49:45	:Use macros LoadHandlerSegment, LoadOpieSegment, and CallIRETproc;--	JPM	16-May-85 16:45:24	:Opie redesign;--	KEK	25-Apr-85 17:10:55	:fix off-by-one error in ConvertFormatToByte;--	KEK	 3-Mar-85 15:05:45	:changed printing directives.;--	VXS 	 3-Dec-84 17:53:59	:Fixed bug introduced by revised idea of Daybreak map reg format, didn't right justify map reg number at MOV DI, AX before IOPMapDirect.;--	VXS 	27-Nov-84 17:11:33	:Ignore hi 8 bits of IORegion and EnvBase relative addresses.;--	VXS 	20-Nov-84 17:48:37	:add INCLUDEs of OpieDefs and HardDefs, change type of IOPEFCB to be IOPEFunctionContextBlock;--	VXS 	16-Nov-84 11:47:55	:Fix MapExtendedBusAddress to account for Daybreak using bits 1-5 instead of 0-4.;--	VXS 	15-Nov-84 11:04:41	:Don't smash AX in ConvertAddress;--	VXS 	 5-Nov-84 16:12:07	:Finish establishaccess implementation by interpreting mapped;					: extended bus addresses for IOP and PC.;--	VXS 	11-Oct-84 11:36:39	:change so that convertaddress uses an IORegion pointer to find page map.;--	VXS 	 1-Oct-84 18:38:02	:Put IRET in front to make ConvertAddress a no-op for the version 14 release;--	VXS 	26-Sep-84 13:16:19	:CreationNAME			IOPLMap;--------------------------------------------------------------------------------$NOLIST$INCLUDE		(IOPDefs.asm)$INCLUDE		(OpieDefs.asm)$INCLUDE		(HardDefs.asm)$LIST;--------------------------------------------------------------------------------IOPELocalRam		SEGMENT	AT 0;EXTRNs from IOPELocalRam segmentEXTRN			IORSegmentTableAddress: SegmentAndOffsetEXTRN			IOROpieSegmentAddress: WORDIOPELocalRam		ENDS;--------------------------------------------------------------------------------OpieIOR			SEGMENT	COMMONEXTRN			mesaPageMapOffset: WORD, mesaPageMapSegment: WORDEXTRN			currentTaskTCBPtr: WORDEXTRN			mapRegisterImages: BYTEOpieIOR			ENDS;--------------------------------------------------------------------------------IOPEInROM		SEGMENT	WORD PUBLIC			ASSUME	CS:IOPEInROM;The following defintions are NOT public information, and are defined here solely; as an implementation convenience;  (They must, however, agree with the public definitions in IOPDefs)OALogicalAddressBits	EQU	11000000B	;Logical Address Space SelectorOAExtendedBus		EQU	00000000B	  ;Extended BusOAIOPLogical		EQU	01000000B	  ;IOP logicalOAPCLogical		EQU	10000000B	  ;PC processor logicalOAmesaLogical		EQU	11000000B	  ;Mesa processor logical  OAFormatBits		EQU	00110000B	;The format bitsOANilFormat		EQU	00000000B	  ;Nil is a formatOAByteFormat		EQU	00010000B	  ;Byte addressOAWordFormat		EQU	00100000B	  ;Word addressOAPageFormat		EQU	00110000B	  ;Page addressOABaseSpecBits		EQU	00001111B	;Address space relative base definitionsOANoBase		EQU	00000000B	  ;start of logical address space (no base);For IOP:OAIORegionBase		EQU	00000001B	  ;handler's IORegion relative;For Mesa:OAmesaEnvBase		EQU	00000001B	  ;Mesa's Environment relative  %SET(mesaEnvBaseRelocationPage,0)		;This is the start of the Mesa Environment Base,    						; otherwise known as "first64K"					 ;Assumptions (for this implementation):;OANoBase must be defined to be 0;OANilFormat must be defined to be 0;OAExtendedBus must be defined to be 0;Definition of the bits in CL that are used in Extended Bus Addresses for real memoryvalidIOPHighBits	EQU	00001111B		;20-bit addressing allowedvalidPCHighBits		EQU	00001111B		;20-bit addressing allowedvalidExtBusHighBits	EQU	00111111B		;22-bit addressing allowedmapRegExtendedBusMask	EQU	00111110BmapRegRightJustify	EQU	1	;the following used after right justifying mapRegExtendedBusMaskmapRegSelectMask	EQU	00001111BmapRegUnusedMask	EQU	11000000B;[End of private definitions];--------------------------------------------------------------------;Format of the Mesa Page map, as seen by IOP with word accesses.MesaVirtualMapBits	EQU	1110000000000000B	;MaskMesaVirtualMapVacant	EQU	0110000000000000B	;value for vacantMesaVirtualMapAddress	EQU	0001111111111111B	;Address;--------------------------------------------------------------------;--------------------------------------------------------------------;-- System level services: (Macro call is - "ConvertAddress"  );-------------------------------------------------------------------------------;--------------|  Assumes:							|;--------------|		CX,DX = an OpieAddress.				|;--------------|								|;--------------| Upon exiting:							|;--------------|		CX,DX = an Opie Extended Bus Address.		|;--------------|		AX    = preserved				|;-------------------------------------------------------------------------------;Here with CH/Opie address type,;	CL/High 8 bits of Opie Address (if applicable);	DX/Low 16 bits of Opie Address;Order of conversion:;	1) Check for special case (extendedBusOpieAddress) -- skip;	2) If relocated, clear high 8 bits (saving contents for IOPLogical step 4);	3) If not byte format, convert (from word or page);	for IOPLogical type:;		4) If relocated, add relocation base;		5) Convert to extendedBus type by changing high nibble;	for PCLogical type:;		4) Convert to extendedBus type by changing high nibble;	for mesaLogical type:;		4) Get logical page number;		5) If relocated, add relocation page;		6) Look up extendedBus page in VM table;		7) Convert to extendedBus type by combining page and byte offsetPUBLIC	IOPE@ConvertAddress  	IOPE@ConvertAddress:	CMP	CH, extendedBusOpieAddress						;see if it's extended Bus already			JNE	SaveConvertRegisters			IRET	;return if so.SaveConvertRegisters:	PUSH	AX		;save this so don't smash anything.			PUSH	BX		;save this too.			MOV	BX, CX		;transfer high address to BX,			MOV	CH, 0		; then change CX into number			TEST	BH, OABaseSpecBits			JZ	ConvertFormatToByte			MOV	CL, 0ConvertFormatToByte:	MOV	AL, BH			AND	AL, OAFormatBits			JZ	BadAddressReturnNil			CMP	AL, OAByteFormat			JE	IsByteFormat			CMP	AL, OAWordFormat			JE	IsWordFormatIsPageFormat:		MOV	CL, DH	;logical SHL 8 (will need 9 total)			MOV	DH, DL			MOV	DL, 0IsWordFormat:		SHL	DX, 1	;shift left one, high bit to carry			RCL	CX, 1	;shift over, put old DX high bit into low bit.IsByteFormat:		MOV	AL, BH		;get type bits			AND	AL, OALogicalAddressBits						;Get just the logical address field.			JZ	CheckExtendedBusOverflow			CheckIOPLogical:	CMP	AL, OAIOPLogical			JNE	CheckPCLogical			TEST	BH, OABaseSpecBits			JZ	IOPLogicalAddressOK			MOV	AL, BL			MOV	AH, 0			PUSH	DS			%LoadHandlerSegment	(DS,BX)			MOV	AX, DS			POP	DS			ROL	AX, 4			MOV	BX, AX			AND	BX, 000FH			AND	AX, 0FFF0H			ADD	DX, AX			ADC	CX, BXIOPLogicalAddressOK:	CMP	CX, validIOPHighBits						;has conversion overflowed?			JG	BadAddressReturnNil			OR	CL, 0F0H	;IOP uses F as high order selector			JMP	SHORT ConvertDoneCheckPCLogical:		CMP	AL, OAPCLogical			JNE	MustBeMesaLogical			CMP	CX, validPCHighBits						;has conversion overflowed?			JG	BadAddressReturnNil			OR	CL, 0E0H	;PC uses E as high order selector			JMP	SHORT ConvertDoneCheckExtendedBusOverflow:			CMP	CX, validExtBusHighBits						;has conversion overflowed?			JNG	ConvertDoneBadAddressReturnNil:			XOR	CX, CX			XOR	DX, DX			JMP	SHORT RestoreConvertRegsMustBeMesaLogical:	PUSH	DS		;save DS			%LoadOpieSegment	(DS,AX)			ASSUME	DS:OpieIOR			MOV	AL, DH			AND	AL, 0FEH			MOV	AH, CL%IF(%mesaEnvBaseRelocationPage NE 0) THEN (			TEST	BH, OABaseSpecBits			JZ	GetMesaPageMapEntry			ADD	AX, (%mesaEnvBaseRelocationPage SHL 1)			ADC	CH, (%mesaEnvBaseRelocationPage SHR 15)GetMesaPageMapEntry:	)FI			MOV	BX, mesaPageMapOffset	;stored by IOPInit			ADD	BX, AX		;assume no overflow			MOV	AX, mesaPageMapSegment	;stored by IOPInit			CMP	AX, Null			JE	BadAddressReturnNil	;no Mesa yet			OR	CH, CH				JZ	MesaPageMapNoCarry			ADD	AH, HIGH 1000H	;add into segment part if byte address overflows 64KMesaPageMapNoCarry:	MOV	DS, AX			ASSUME	DS:NOTHING			MOV	BX, [BX]	;get Mesa page map entry.			POP	DS			MOV	AH, BH		;get copy			AND	AH, HIGH MesaVirtualMapBits						;get just the status bits			CMP	AH, HIGH MesaVirtualMapVacant							;See if its illegal			JE	BadAddressReturnNil			AND	BH, HIGH MesaVirtualMapAddress			SHL	BX, 1			MOV	CL, BH		;high order part of page address goes into CL			AND	DH, 1			OR	DH, BL		;low order part goes into DHConvertDone:		MOV	CH, extendedBusOpieAddress						;The new typeRestoreConvertRegs:	POP	BX		;restore values of BX			POP	AX		;and AX.ConvertReturn:			IRET			;return. New type in CX-DX.;------------------------------------------------;-- System level services: (Macro call is - "EstablishAccess"  );-------------------------------------------------------------------------------;--------------|  Assumes:							|;--------------|		CX,DX = an OpieAddress.				|;--------------|		AX    = an IOPMap number (0 thru 7).		|;--------------|--------							|;--------------| Upon exiting:							|;--------------|		CX,DX = an OpieRealAddress.			|;--------------|		ES    = points to a segment beginning at the	|;--------------|			16B containing the specified address	|;--------------|		DI    = byte offset of address within that 16B	|;-------------------------------------------------------------------------------;Routine IOPE@EstablishAccess;Function: Make the Opie address in CX-DX accessible through map slot whose number; is in AL.; Sets up ES:DI to point to requested location, so that DI has the minimum value possible;  for maximum addressability.;The map slots on both types of machines map 128Kbyte sections of IOPlogical or PClogical; address space. This corresponds to 17 bits out of a possible 22 for extended bus addresses.; Therefore, must extract the high order 5 bits from the EBA, and replace them with 3 bits; of the map number.;We want this to be as fast as possible, at the expense of code space if necessary, because interrupt level; for the internal DMA must call this to remap a new section for continued I/O in some cases.PUBLIC IOPE@EstablishIOPAccessIOPE@EstablishIOPAccess:			PUSH	BX			MOV	BX, AX			CMP	CH, extendedBusOpieAddress						;see if its extended Bus already						; (extra code to make this faster, since						; interrupt level calls this)			JE	EstAccEBA	;Jump if already extended bus address			%CallIRETproc	(IOPE@ConvertAddress)			CMP	CH, nilOpieAddress			JNE	EstAccEBA			MOV	AL, nilMapData	;In case it's general map register			JMP	SHORT NotEorFEstAccEBA:					;Must start off with extended bus			%LoadOpieSegment	(ES,AX);Get the high order 5 bits of the 22 bit EBA into AL into 0-4 for Daybreak hardware.; Either these will go into the map register, or if the address has E or F in the high nibble,; specify the map register to read to get the high order 5 bits.			MOV	AL, CL		;save high part of address			AND	AL, mapRegExtendedBusMask			SHR	AL, mapRegRightJustify			TEST	CL, mapRegUnusedMask						;See if he's specifying E or F (treat C and D cases as same)			JZ	NotEorF		;go if normal extended bus address;Caller has specified a mapped Extended Bus Address.; Must replace bits 23-17 (high order 7 bits) with the five bits (21-17) from the map; register selected (map number is taken directly from 20-17)			MOV	DI, AX		;get into indexing place			AND	DI, mapRegSelectMask						;get just the relevant data; If its IOP map register 0 or 7, in which case we don't program map registers, but; instead return ES:DI pointing to actual IOP logical address within map register 0 or 7,; because these are the only areas where the IOP can select local RAM or EPROM.			CMP	DI, daybreakMapRegisterNumberIOPBase+0			JNE	NotIOPMapReg0IOPMapDirect:		MOV	BX, DI		;get reg number in BX			JMP	SHORT MapDirect	;Go setup ES:DI and return.			NotIOPMapReg0:		CMP	DI, daybreakMapRegisterNumberIOPBase+7			JE	IOPMapDirect			MOV	AL, ES:mapRegisterImages[DI]	;get 5 bits of map reg contents			NotEorF:;Compute the I/O address of the map slot being requested (in AX); And program the map			XCHG	BX, DX		;Get copy of low order 16 bits for later use			%WriteMap	(DX)			XCHG	DX, BX		;get low bits back into DX, IO Address into BX			MOV	ES:mapRegisterImages[BX], AL						;save for benefit of users of mapped Extended Bus addresses.;Setup ES:[DI] to point to the requested location; If entering at MapDirect, CL,DX must contain the low order 17 bits,; and AH contains the high order 3 bits (map register number) of the 20 bit address.; (the 04H bit in AH, which is 0 or 1 for PC or IOP, will be ignored);Build value which goes into ES in DX.MapDirect:			MOV	DI, DX		;get low bits into DI			AND	DI, (1 SHL Nibble)-1	;just low order 4 bits for maximum forward addressability			AND	DL, 0F0H			OR	BX, DX			OR	DX, DI			TEST	CL, (NOT mapRegExtendedBusMask) AND (NOT mapRegUnusedMask)						;(faster than shifting by far)			JZ	MEBAFirst64K	;jump if			STC			;switch to next 64KMEBAFirst64K:			RCR	BX, Nibble	;get reg in hi 3 bits of BX, and 4th bit into carry (hide it)			MOV	ES, BX		;goes into ES			POP	BX			IRET			;return with good values in ES and DI.			;-------------------------------------------------------------------------------------IOPEInROM		ENDS			;********************************************************************************									END
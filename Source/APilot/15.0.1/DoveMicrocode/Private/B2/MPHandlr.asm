$MOD186$PAGELENGTH (72)$PAGEWIDTH  (136);Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved.;;-- stored as [Idun]<WMicro>Dove>MPHandlr.asm;-- created on  19-Jul-84 11:20:33 -- Based on FakeTask.asm;;-- last edited by:;--	ANK		 1-Aug-85 10:04:55	:Remove EEPDefs.;--	JPM		22-Jul-85 10:29:23	:Change IOPEInROM alignment to WORD.;--	JPM		16-Jul-85  8:37:22	:Fix initials.;--	JPM		10-Jul-85  7:51:09	:Fix bug (forgot to locate CursorUser in display's IOR and establish access to it).;--	JPM		25-Jun-85 17:26:53	:Opie redesign conversion.;--	ANK		12-Mar-85 14:37:38	:Reassembled for Opie 19.;--	ANK		12-Feb-85 10:58:31	:Edited for 2nd IOP etch 2.  Changed machine type (daisy or;						: daybreak) per latest def.;--	ANK		30-Jan-85 14:03:53	:Made maintPanelProc a double word.;						:Upgraded for use with etch 2 hardware.;--	ANK		1-Dec-84 15:53:11	:Reassembled with Opie 16, and renamed file;						:Also merged the file MPCodes.asm into this one;--	ANK		1-Nov-84 15:17:49	:Incoroporated code to output maintainence;						:panel code to port (for the Tech Rep's LED;						:display).  Also, display MP code til Mesa changes.;						:Included temp fix for down notifies w/ O;--	ANK		25-Oct-84 11:12:27	:Fixed bug with Display Handler comm.;						:Included temp fix for down notifies w/ Opie15;--	ANK		23-Oct-84 14:05:46	:Updated for Opie v15.;						: Changed for debug !!!;--	ANK		9-Aug-84 14:16:10	:Added labels to make easier to debug,;						: also changed the file MPCodes.asm;--	ANK		19-Jul-84 19:58:18	:created;	NAME	MPHandlr;;---------------------------------------------------------------------------------------------;$NOLIST$INCLUDE	(IOPDefs.asm)	;This should always be INCLUDEd first$INCLUDE	(HardDefs.asm)$INCLUDE	(IOPMacro.asm);$LIST;---------------------------------------------------------------------------------------------; INCLUDED IOPDefs.asm, HardDefs.asm, IOPMacro.asm, and EEPDefs.asm;MPCursor	EQU	0FFH	;Value of CursorUser when MP handler is setting the cursor patternDisplayCursor	EQU	0	;Value of CursorUser when display handler is setting the cursor;				:patternMPTimeOut	EQU	5000	;Value (in milliseconds) of Timeout after notifyMPLEDs		EQU	090H	;Port address of LEDs to display maintainence panel codes.;;----------------------------------------------------------------------------------------------;EXTRN			MaintPanelHandlerID: ABSEXTRN			DisplayHandlerID: ABSMaintPanelIOR		SEGMENT		COMMON 			ASSUME	DS:MaintPanelIOR;EXTRNs for maintainence panel handlerEXTRN maintPanelTask:TaskContextBlock	;****  Added *******;;EXTRNs contained in maintainence panel FCBEXTRN maintPanelMask :WORD		;Mask for implementing down notifyEXTRN maintPanelChanged :Condition	;Down notify conditionEXTRN maintPanelCode : WORD		;Maintainence panel code is store hereEXTRN maintPanelProc :DWORD		;Holds addr of Daisy/Daybreak maintainence panel procEXTRN maintPanelTemp :WORD		;Holds remaining digits to be displayedEXTRN decimalDigit :WORD		;Holds decimal rep of maintainence panel codeEXTRN shiftAmount :BYTE			;Holds amount to shift MaintPanelIOR		ENDSDisplayIOR		SEGMENT		COMMON;EXTRNs for display handler/maintainence panel handler comm.EXTRN CursorUser :BYTE	;CursorUser variable indicates whether the display or MP handler has;			:control over the cursor pattern -- declared in display handler FCBDisplayIOR		ENDS;--------------------------------------------------------------------------------------------;MaintPanelSTK		SEGMENT		COMMON 			Assume SS:MaintPanelSTKEXTRN MPStack:WORDMaintPanelSTK		 ENDS;;--------------------------------------------------------------------------------------------;IOPEInROM		SEGMENT	WORD PUBLIC	;ROM			ASSUME	CS:IOPEInROM;;-------------------------------------------------------------------------------------------;;ROM based task entry points:;PUBLIC			MaintPanelInit		;;--------------------------------------------------------------------------------------------;All the entry points below have to be in ROM so there is no need;to save the CS!;;******************************************************************************************;*******************************;*                             *;*        MPHandlerInit        *;*                             *;*******************************;MaintPanelInit	PROC	FAR		%InitializeTask	(MaintPanelHandlerID,OFFSET maintPanelTask, MPTaskInit,OFFSET MPStack)			RETMaintPanelInit	ENDP;;*******************************************************************************************;***********************************;*                                 *;*        MPTaskInit               *;*                                 *;***********************************;	MPTaskInit:	%GetWorkMaskForCondition(OFFSET maintPanelChanged)	;Get down notify mask		MOV  maintPanelMask, AX					;Save mask returned in FCB		MOV   BX, OFFSET maintPanelProc				;BX points at maintPanelProc;;									:Determine if Daisy or Daybreak		IN     AX, machineIDPort  				;0020H=Daisy, 0060H=Daybreak				AND    AX, machineIDMask				;Mask out machine type bits		AND    AX, 01000000B					;Mask out Daybreak bit		JZ     DaisyMPCodes					;If 0, go to Daisy MP set up;DaybrekMPCodes:	MOV  AX, OFFSET DayBreakMP				;Set up proc for Daybreak		MOV  [BX], AX		JMP  SaveCS						;Continue;DaisyMPCodes:	MOV  AX, OFFSET DaisyMP					;Set up proc for Daisy		MOV  [BX], AX;SaveCS:		ADD   BX, 2		MOV   [BX], CS						;Save CS as part of the ;									:  maintPanelProc addressWaitForMPCode:	%WaitForCondition(OFFSET maintPanelChanged,MPTimeOut)	;Wait for down notify or time out;;---------------------------------------------------------------------------------------------------;;		*****	GOT DOWN NOTIFY	****;DbgGotCond:	JC   MPTimedOut				;If timed out go to MPTimedOut;							:Otherwise, a new code to displayDbgGotCode:	%EstablishHandlerAccess	(displayHandlerID) ;get segment address		ASSUME	ES:DisplayIOR			; of DisplayIOR in ES		MOV  AX, maintPanelCode			;Get code to be displayed in AX		MOV  CursorUser, MPCursor		;Set CursorUser to MPCursor to let display;							:handler know that the MP handler is using;							:cursor pattern		MOV  decimalDigit, 0			;initialize decimal digit to 0		MOV  shiftAmount, 0			;initialize decimal digit to 0;		CALL maintPanelProc			;Call proc to determine digit to be displayed;							:and display it in cursor pattern		MOV   AX, decimalDigit			;Get decimal representation of MP code in AX		OUT   MPLEDs, AX			;Output MP code to Tech Rep's display		JMP  WaitForMPCode			;Wait for new code to display		ASSUME	ES:NOTHING;-----------------------------------------------------------------------------------------------------;MPTimedOut:	%EstablishHandlerAccess	(displayHandlerID) ;get segment address		ASSUME	ES:DisplayIOR			; of DisplayIOR in ES		MOV  CursorUser, DisplayCursor		;Set CursorUser to DisplayCursor to let display		JMP  WaitForMPCode			;Wait for new code to display		ASSUME	ES:NOTHING;-------------------------------------------------------------------------------------------------------;;;;;*****************************************************************************************************;;These procedures takes a 4-digit decimal number (represented in hex,; and passed in AX), and displays it in the cursor pattern.;The largest digit passed should be 9999 -- These procedures do not error check;  this.  This procedure uses the AX, BX, CX, DX, BP, SI, and DI registers;;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -  DayBreakMP	PROC	FAR		MOV  DI, 0			;Init DI to 0;						:-- DI tracks number of digits displayed;GetDigitDay:	CALL SetPtrToPattern		;Set BX to point at cursor pattern;						:representation of code		MOV  BP, DI			;BP pnts @ table of output port addrs		ROL  BP, 1			;Multiply BP by 2		MOV  DX, CS:LocnDayBreak[BP]	;DX pnts at appropriate cursor pattern port		MOV  SI, 0			;SI is index in table containing cursor pattern		MOV  CX, NumberOfDigitBytes	;CX tracks the number of bytes outputedOutputDayBreak:	MOV  AL, CS:[BX][SI]		;Get byte to output in  AL		CMP  DI, 2			;If DI < 2,		JL   NoOffsetDay		;then these are top digits		ROL  AL, 3			;So don't offset themNoOffsetDay:	OUT  DX, AL			;Output digit into cursor pattern		ADD  DX, 2			;Point DX to next port		INC  SI				;Point SI to next table value		LOOP OutputDayBreak		;Keep outputting til done with table size bytes		MOV  AX, maintPanelTemp		;Get rest of digits to be displayed in AX		INC  DI				;Increment DI for next digit		CMP  DI, NumberOfDigits		;If DI < number of digits to be displayed		JL   GetDigitDay		;Then get next digit and display it		RETDayBreakMP	ENDP;;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;DaisyMP		PROC	FAR		MOV  DI, 0			;Init DI to 0;						:-- DI tracks number of digits displayed;GetDigitDaisy:	CALL SetPtrToPattern		;Set BX to pnt at cursor pattern;						:representation of code of 1st digit		MOV  BP, BX			;Save pointer returned in BP		MOV  AX, maintPanelTemp		;Get rest of digits to be displayed in AX		CALL SetPtrToPattern		;Set BX to pnt at cursor pattern rep of next digit		MOV  DX, CS:LocnDaisy[DI]	;DX pnts @ appropriate cursor pattern port		MOV  SI, 0			;SI is index into table containing cursor pattern		MOV  CX, NumberOfDigitBytes	;CX tracks the number of bytes outputedOutputDaisy:	MOV  AH, CS:[BX][SI]		;Get most sig. byte to output in  AH		MOV  AL, CS:[BP][SI]		;Get least sig. byte to output in  AL		CMP  DI, 2			;If DI < 2,		JL   NoOffsetDaisy		;then these are top digits		ROL  AX, 3			;So don't offset themNoOffsetDaisy:	OUT  DX, AX			;Output two digits into  cursor patttern		INC  DX				;Point DX to next port		INC  SI				;Point SI to next table value		LOOP OutputDaisy		;Keep outputting til done with table size bytes		MOV  AX, maintPanelTemp		;Get rest of digits to be displayed in AX		ADD  DI, 2			;Increment DI for next digit		CMP  DI, NumberOfDigits		;If DI < number of digits to be displayed		JL   GetDigitDaisy		;Then get next digit and display it		RET;DaisyMP		ENDP;;-----------------------------------------------------------------------------------------;;PROCEDURE FOR SETTING POINTER TO TABLE FOR DIGIT OF THE MAINTAINENCE PANEL CODE;;SetPtrToPattern assumes that the remaining digits to be encoded are in AX.;  This procedure sets BX pointing at the table holding the cursor pattern representation of the;  least significant digit contained in AX.  The remaining digits passed are saved in temp.SetPtrToPattern	PROC	NEAR		MOV  DX, 0			;Clear MS word of dividend		MOV  BX, 0AH			;Get word divisor in BX		DIV  BX				;Get quotient in AX, and;						:remainder (least sig. digit) in DX		MOV  maintPanelTemp, AX		;Save quotient in maintPanelTemp		MOV  AX, DX			;Get digit to display in AX;		MOV  BX, OFFSET zeroMP		;Set BX to pnt @ repr. for 0 -- the 1st table		SAL  AX, 3			;Mult. AX by 8		ADD  BX, AX			;By adding # of bytes nec.,;						:BX will be pnting @ correct table;		MOV   CL, shiftAmount		;Get shift amount in CL		SAL   DX, CL			;Get digit in appropriate position		ADD   decimalDigit, DX		;Store updated decimal digit		ADD   shiftAmount, 4		;Increment shiftAmount for next digitDone:		RETSetPtrToPattern	ENDP;;------------------------------------------------------------------------------------------;;Set up tables containing the I/O port addrs of cursor pattern for both Daisy and Daybreak;;Daybreak I/O port addresses;   The Daybreak Locn table contains the starting addr for each digit of the cursor pattern.;   The least significant digit is displayed first.;LocnDayBreak	DW	0ED11H		DW	0ED10H		DW	0ED01H		DW	0ED00H;;Daisy I/O port addresses;   The Daisy Locn table contains the starting addr for 2 digits of the cursor pattern.;   The two least significant digits are displayed first.;LocnDaisy	DW	0FF08H	;********  TBD  ********		DW	0FF00H	;********  TBD  ********;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -;;Set up tables containing the cursor pattern values for representing each digit.; Here, only 5 pixels are used for width (and the 3 most sig. pixels padded with 0s),; and 7 pixels for height (with the 8th pixel as a 0);zeroMP	DB	00001110B	DB	00010001B	DB	00010001B	DB	00010001B	DB	00010001B	DB	00010001B	DB	00001110B	DB	00000000B;one	DB	00000100B	DB	00001100B	DB	00010100B	DB	00000100B	DB	00000100B	DB	00000100B	DB	00011111B	DB	00000000B;two	DB	00001110B	DB	00010001B	DB	00000010B	DB	00000100B	DB	00001000B	DB	00010000B	DB	00011111B	DB	00000000B;three	DB	00001110B	DB	00010001B	DB	00000001B	DB	00000110B	DB	00000001B	DB	00010001B	DB	00001110B	DB	00000000B;four	DB	00010010B	DB	00010010B	DB	00010010B	DB	00011111B	DB	00000010B	DB	00000010B	DB	00000010B	DB	00000000B;five	DB	00011111B	DB	00010000B	DB	00010000B	DB	00001110B	DB	00000001B	DB	00010001B	DB	00001110B	DB	00000000B;six	DB	00001110B	DB	00010001B	DB	00010000B	DB	00011110B	DB	00010001B	DB	00010001B	DB	00001110B	DB	00000000B;seven	DB	00011111B	DB	00000001B	DB	00000010B	DB	00000100B	DB	00001000B	DB	00001000B	DB	00001000B	DB	00000000B;eight	DB	00001110B	DB	00010001B	DB	00010001B	DB	00001110B	DB	00010001B	DB	00010001B	DB	00001110B	DB	00000000B;nine	DB	00001110B	DB	00010001B	DB	00010001B	DB	00001111B	DB	00000001B	DB	00010001B	DB	00001110B	DB	00000000B;;NumberOfDigitBytes	EQU	08H	;Number of bytes in each digit tableNumberOfDigits		EQU	04H	;Number of digits to be displayed;;;IOPEInROM	ENDS;********************************************************************************		END
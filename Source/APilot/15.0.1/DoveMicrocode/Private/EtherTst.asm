$MOD186$PAGELENGTH	(95)$PAGEWIDTH	(136);Copyright (C) 1984 by Xerox Corporation. All rights reserved.;Ethernet handler tester;stored as [Idun]<WMicro>Dove>EtherTst.asm;created on  2-Aug-84 14:56:56;last edited by:;	kek	25-Jul-86  9:23:57	convert to reconfigurable opie (finally);	BKI	23-Jul-85 17:37:26	Multiple iocbs;	BKI	 2-Aug-84 14:56:56	CreationNAME		EtherTstPUBLIC		BeepInit, KeyBoardAndMouseInit, DisplayInit, DiskInit, FloppyInitPUBLIC		BootStrapInit, maintPanelInit$NOLIST$INCLUDE	(IOPDefs.asm)$INCLUDE	(QueDefs.asm)$INCLUDE	(IOPMacro.asm)$INCLUDE	(QueMacro.asm)$INCLUDE	(HardDefs.asm)$INCLUDE	(EthIOFce.asm)$LIST;----------------------------------------------------------------------------;Macro defs and absolute extrns.%*DEFINE	(ByteSwap	(wordToSwap))		(%wordToSwap SHL 8 OR %wordToSwap SHR 8)%*Define (CallHandlerInitProc	(handlerID))	(		MOV	DI, %handlerID		SHL	DI, 2		PUSH	DS		PUSH	ES		CALL	DWORD PTR HandlerInitProcTable[DI]		POP	ES		POP	DS)EXTRN		BootStrapHandlerID: ABSEXTRN		EthernetHandlerID: ABS;----------------------------------------------------------------------------		IOPELocalRAM	SEGMENT	AT 0EXTRN		HandlerInitProcTable: DWORDIOPELocalRAM	ENDS;----------------------------------------------------------------------------		BootstrapIOR	SEGMENT	COMMONEXTRN		etherTstTask: TaskContextBlock, xmitDoneTask: TaskContextBlockEXTRN		etherTstIOCB: IOCB, testRcvBufSize: ABSEXTRN		etherTstXmit: Condition, etherTstInput: ConditionEXTRN		myIndAddr: BYTE, rcvI586Status: WORDEXTRN		xmitBufferLength: WORD, etherTstIOCBCount: BYTEBootstrapIOR	ENDS;----------------------------------------------------------------------------EthernetIOR	SEGMENT	COMMONEXTRN		etherOutQueue: QueueBlock, etherInQueue: QueueBlockEXTRN		etherCmdAvail: Condition, inBufferAvail: ConditionEthernetIOR	ENDS;----------------------------------------------------------------------------BootstrapSTK	SEGMENT	COMMONEXTRN		XmitTestStack: WORD, EtherTestStack: WORDBootstrapSTK	ENDS;----------------------------------------------------------------------------IOPEInROM	SEGMENT	PUBLIC		ASSUME	CS:IOPEInROM		ASSUME	DS:BootstrapIOREXTRN		EtherInitialize: NEARTest0:						;for debugging onlyTestError:	JMP	$BeepInit	PROC	FAR		RETBeepInit	ENDPDiskInit	PROC	FAR		RETDiskInit	ENDPDisplayInit	PROC	FAR		RETDisplayInit	ENDPFloppyInit	PROC	FAR		RETFloppyInit	ENDPKeyBoardAndMouseInit	PROC	FAR		RETKeyBoardAndMouseInit	ENDPmaintPanelInit	PROC	FAR		RETmaintPanelInit	ENDPBootStrapInit	PROC	FAR		%InitializeTask	(BootStrapHandlerID,OFFSET xmitDoneTask,XmitDoneTaskInit,OFFSET XmitTestStack)		%InitializeTask	(BootStrapHandlerID,OFFSET etherTstTask,EtherTstTaskInit,OFFSET EtherTestStack)		RETBootStrapInit	ENDPtypeFieldOffset	EQU	12nsTypeField	EQU	%ByteSwap(0600H)lengthOffset	EQU	16xprtCtlOffset	EQU	18packetTypeOffset	EQU	19echoPacketType	EQU	2errorPacketType	EQU	3operationOffset	EQU	44echoRequest	EQU	%ByteSwap(1)echoResponse	EQU	%ByteSwap(2)errorNumOffset	EQU	44rsrcErrorNum	EQU	%ByteSwap(3)errorParmOffset	EQU	46EtherTstTaskInit:		MOV	AX, IOPELocalRAM		MOV	ES, AX		ASSUME	ES:IOPELocalRAM		%CallHandlerInitProc	(EthernetHandlerID)		%WaitForSystem		;Give ethernet a chance to initialize		MOV	etherTstIOCBCount, 4;set up myIndAddr		XOR	BX, BX		MOV	CX, addrSize		MOV	DX, ReadHostPromStoreHostID:	IN	AL, DX		MOV	myIndAddr[BX], AL		INC	BX		ADD	DX, 2		LOOP	StoreHostID		CALL	EtherInitialize		MOV	CL, etherTstIOCBCount		XOR	CH, CH		MOV	SI, OFFSET etherTstIOCB		;MOV	AX, OFFSET etherTstBuffer		MOV	AX, 3000h			;testClientIOR too smallInitializeIOCB:	MOV	[SI].nextIOCB.OpieAddressType, nilOpieAddress		MOV	[SI].iocbCondition.handlerID, LOW BootStrapHandlerID		MOV	[SI].iocbCondition.conditionPtr, (OFFSET etherTstInput)		OR	[SI].iocbCondition.conditionPtr, nonNilPtr		MOV	[SI].iocbCondition.clientMask, 0		MOV	[SI].iocbType, iocbInput SHL 4		;MOV	[SI].iocbVariant.bufAddr.OpieAddressHigh, IOPIORegionOpieAddress SHL 8		MOV	[SI].iocbVariant.bufAddr.OpieAddressHigh, IOPLogicalOpieAddress SHL 8	;testClientIOR too small		MOV	[SI].iocbVariant.bufAddr.OpieAddressLow, AX		MOV	[SI].iocbVariant.bufLength, testRcvBufSize		PUSHA		MOV	CX, IOPIORegionOpieAddress SHL 8		MOV	DX, SI		CALL	QueueIn		POPA		ADD	SI, SIZE IOCB		ADD	AX, testRcvBufSize		LOOP	InitializeIOCB		%NotifyHandlerCondition	(EthernetHandlerID,OFFSET inBufferAvail)WaitForPacket:		%WaitForCondition	(OFFSET etherTstInput,noTimeout)CheckInQueue:		PUSH	ES		%EstablishHandlerAccess	(EthernetHandlerID)		MOV	CX, ES:etherInQueue.queueHead.OpieAddressHigh		MOV	DX, ES:etherInQueue.queueHead.OpieAddressLow		POP	ES		OR	CH, CH		JZ	WaitForPacket		;jump if queue empty		PUSH	CX		PUSH	DX		%EstablishIOPAccess	(generalMapRegister,CX-DX)		TEST	ES:[DI].iocbStatus, MASK iocbDone		JNZ	CheckInPacket		POP	DX			;not done yet		POP	CX		JMP	WaitForPacketCheckInPacket:		PUSH	ES		%EstablishHandlerAccess	(EthernetHandlerID)		%DeQueue	(ES:etherInQueue,nextIOCB,preserveES)		POP	ES		MOV	DS:[SI].nextIOCB.OpieAddressType, nilOpieAddress		MOV	AX, ES:[DI].iocbVariant.inputCount		MOV	xmitBufferLength, AX		MOV	AX, ES:[DI].i586Status		MOV	rcvI586Status, AX		TEST	ES:[DI].iocbStatus, MASK iocbOkay		MOV	ES:[DI].iocbStatus, 0		JNZ	CheckForEchoPacket		TEST	AH, HIGH MASK noRsrcErr		JNZ	CheckForEchoPacketDontEcho:	POP	DX		POP	CX		PUSH	ES		%EstablishHandlerAccess	(EthernetHandlerID)		ASSUME	ES:EthernetIOR		CALL	QueueIn		%NotifyHandlerCondition	(EthernetHandlerID,OFFSET inBufferAvail)		POP	ES		ASSUME	ES:NOTHING		JMP	CheckInQueueCheckForEchoPacket:		%EstablishIOPAccess	(generalMapRegister,WORD PTR ES:[DI].iocbVariant.bufAddr)		CMP	WORD PTR ES:[DI]+typeFieldOffset, nsTypeField		JNE	DontEcho		CMP	BYTE PTR ES:[DI]+packetTypeOffset, echoPacketType		JNE	DontEcho		CMP	WORD PTR ES:[DI]+operationOffset, echoRequest		JNE	DontEchoRespondEcho:	CALL	AddressPacket		MOV	WORD PTR ES:[DI]+operationOffset, echoResponse		TEST	rcvI586Status+1, HIGH MASK noRsrcErr		JZ	SetPacketSetErrorPacket:		MOV	WORD PTR ES:[DI]+lengthOffset, %ByteSwap(34)		MOV	BYTE PTR ES:[DI]+packetTypeOffset, errorPacketType		MOV	WORD PTR ES:[DI]+errorNumOffset, rsrcErrorNum		MOV	WORD PTR ES:[DI]+errorParmOffset, 0		MOV	xmitBufferLength, 60	;minimum frame lengthSetPacket:		MOV	BYTE PTR ES:[DI]+xprtCtlOffset, 0checksumOffset	EQU	14		CMP	WORD PTR ES:[DI]+checksumOffset, %ByteSwap(unChecksummed)		JE	TransmitFrame		PUSH	DI		ADD	DI, lengthOffset		MOV	CX, ES:[DI]		ROL	CX, 8			;byteswap length		SHR	CX, 1			;bytes -> words		DEC	CX			;don't include checksum word		CALL	CalcChecksum		POP	DI		MOV	WORD PTR ES:[DI]+checksumOffset, AXTransmitFrame:	MOV	BP, SP		;access top of stack without popping		%EstablishIOPAccess	(generalMapRegister,SS:[BP])		POP	DX		POP	CX		MOV	ES:[DI].iocbCondition.handlerID, LOW BootStrapHandlerID		MOV	ES:[DI].iocbCondition.conditionPtr, (OFFSET etherTstXmit)		OR	ES:[DI].iocbCondition.conditionPtr, nonNilPtr		MOV	ES:[DI].iocbCondition.clientMask, 0		MOV	ES:[DI].iocbType, iocbOutput SHL 4		MOV	AX, xmitBufferLength		MOV	ES:[DI].iocbVariant.bufLength, AX		PUSH	ES		%EstablishHandlerAccess	(EthernetHandlerID)		CALL	QueueOut		POP	ES		JMP	CheckInQueueXmitDoneTaskInit:WaitForXmitDone:		%WaitForCondition	(OFFSET etherTstXmit,noTimeout)CheckOutQueue:		PUSH	ES		%EstablishHandlerAccess	(EthernetHandlerID)		MOV	CX, ES:etherOutQueue.queueHead.OpieAddressHigh		MOV	DX, ES:etherOutQueue.queueHead.OpieAddressLow		POP	ES		OR	CH, CH		JZ	WaitForXmitDone		;jump if queue empty		PUSH	CX		PUSH	DX		%EstablishIOPAccess	(generalMapRegister,CX-DX)		TEST	ES:[DI].iocbStatus, MASK iocbDone		JNZ	CheckOutPacket		POP	DX			;not done yet		POP	CX		JMP	WaitForXmitDoneCheckOutPacket:		PUSH	ES		%EstablishHandlerAccess	(EthernetHandlerID)		%DeQueue	(ES:etherOutQueue,nextIOCB,preserveES)		POP	ES		MOV	ES:[DI].nextIOCB.OpieAddressType, nilOpieAddress		POP	DX		POP	CX		TEST	ES:[DI].iocbStatus, MASK iocbOkay		MOV	ES:[DI].iocbStatus, 0		JNZ	RecycleIOCBToOutQueue		PUSH	ES		%EstablishHandlerAccess	(EthernetHandlerID)		CALL	QueueOut		POP	ES		JMP	CheckOutQueueRecycleIOCBToOutQueue:		MOV	ES:[DI].iocbCondition.handlerID, LOW BootStrapHandlerID		MOV	ES:[DI].iocbCondition.conditionPtr, (OFFSET etherTstInput)		OR	ES:[DI].iocbCondition.conditionPtr, nonNilPtr 		MOV	ES:[DI].iocbCondition.clientMask, 0		MOV	ES:[DI].iocbType, iocbInput SHL 4		MOV	ES:[DI].iocbVariant.bufLength, testRcvBufSize		PUSH	ES		%EstablishHandlerAccess	(EthernetHandlerID)		ASSUME	ES:EthernetIOR		CALL	QueueIn		%NotifyHandlerCondition	(EthernetHandlerID,OFFSET inBufferAvail)		POP	ES		ASSUME	ES:NOTHING		JMP	CheckOutQueueAddressPacket	PROC	NEARdestOffset	EQU	0srcOffset	EQU	6destAddrOffset	EQU	20srcAddrOffset	EQU	32srcHostOffset	EQU	36		PUSHA		MOV	BX, DI		LEA	SI, ES:[BX]+srcOffset		LEA	DI, ES:[BX]+destOffset		MOV	CX, addrSize/2		;addrSize is a byte count		CLD		REP	MOVS WORD PTR ES:[DI], ES:[SI]		LEA	SI, ES:[BX]+srcAddrOffset		LEA	DI, ES:[BX]+destAddrOffset		MOV	CX, (addrSize/2)+3	;addrSize is a byte count		REP	MOVS WORD PTR ES:[DI], ES:[SI]		MOV	SI, OFFSET myIndAddr		LEA	DI, ES:[BX]+srcOffset		MOV	CX, addrSize/2		;addrSize is a byte count		REP	MOVS WORD PTR ES:[DI], DS:[SI]		MOV	SI, OFFSET myIndAddr		LEA	DI, ES:[BX]+srcHostOffset		MOV	CX, addrSize/2		;addrSize is a byte count		REP	MOVS WORD PTR ES:[DI], DS:[SI]		POPA		RETAddressPacket	ENDPCalcChecksum	PROC	NEAR;Arguments:	ES:DI	offset of word-aligned buffer;		CX:	length of buffer (words);Returns:	AX:	word checksumunChecksummed	EQU	0FFFFH		PUSH	DX		XOR	AX, AXSumNextWord:	MOV	DX, ES:[DI]		ROL	DX, 8		;byteswap word;The following sequence is the checksum algorithm		ADD	AX, DX		ADC	AX, 0		ROL	AX, 1		ADD	DI, 2		LOOP	SumNextWord		CMP	AX, unChecksummed		JNE	ChecksumExit		XOR	AX, AXChecksumExit:	ROL	AX, 8			;byteswap checksum		POP	DX		RETCalcChecksum	ENDP		ASSUME	ES:EthernetIORQueueIn		PROC NEARQueueInEntry:	%EnQueue	(ES:etherInQueue,nextIOCB,preserveES)		RETQueueIn		ENDPQueueOut	PROC NEARQueueOutEntry:	%EnQueue	(ES:etherOutQueue,nextIOCB,preserveES)		%NotifyHandlerCondition	(EthernetHandlerID,OFFSET etherCmdAvail)		RETQueueOut	ENDPIOPEInROM	ENDS;		PURGE		END
$	DEBUG MOD186;moonrise.asm;;last edited by TXM		21-Sep-88 14:54:38;;The Boot Diagnostics monitor lives here.;Boot diagnostics normally start running with the StartB routine (for;Bermuda testing) or the StartO routine (when called from OPIE).  This;file contains the monitor control code to start and control tests and;editing.;	NAME	Monitor$	TITLE(Boot Monitor)$	NOLIST		;Next line includes Daisy.def	$	INCLUDE(MoonSys.def)$	INCLUDE(MOONLINK.def)$	LIST		;Previous line included Daisy.defMonitorCode	SEGMENT  COMMON	ASSUME	CS:MonitorCode, SS:MonitorCode, DS:MonitorCode	PUBLIC StartO	PUBLIC StartB	PUBLIC Start	ORG 	MonitorCodeLoc;-----------------------------------------------------------------Start:   jmp StartB         jmp DoRunTimeWork         jmp EnableInt	 jmp Message 	 jmp PutNextKey	 jmp OffWrCtlReg 	 jmp OnWrCtlReg	 jmp OffWrRstCtlReg 	 jmp OnWrRstCtlReg	 jmp SetTCBPointer	 jmp GetNextKey	 jmp ReadEEProm;----------------------------------------------------------------- StartB:			;initial entry point                CLI		MOV	AX, StackLoc/16		MOV	SS, AX		MOV	sp, IOPStackSize                CALL	Initilize		mov [DI].LoopControl,NoLoop                or [DI].FileControl,BurdockFile		TEST [SI].ConfigInfo,CpFiles		jz StartB1		CALL ExtWriteBranches		CALL ExtDownLoaderStartB1:        Call ConfIt 		jmp CheckIFConfNeededStartO:;Entry point from OPIE; Establish segment registers                CLI		MOV	AX, StackLoc/16		MOV	SS, AX		MOV	sp, IOPStackSize                CALL	Initilize 		MOV AL,0		TEST [DI].FileControl,MonitorFile 		jnz SetIntialFileStream 		CheckIFConfNeeded:		CALL ExtResetCp		CALL ExtDisplayCode		call DisplayTestNumber ;Display Current Test Numbe		cmp [SI].FileType ,FileType2		jne PreProcessing 		jmp GetNextFile		PreProcessing:  CALL ExtPreProcess  		TEST [DI].TestControl,AlagInProcess		jnz MonitorStart                 jmp WaitForInput;Set AlagInProcess and turn off MonitorFile;Read the EEProm Point to daisy or Daybreak and long or short		SetIntialFileStream:Call OutStruc		MOV ah,ES:[BX].DiagType		mov BYTE PTR [DI][ExtBootConf],ah		shl ah,1SetIntialFileStream1:or [DI].TestControl,AlagInProcess		or [DI].JumpControl,AnilizeIt		mov dl,ShortPtr		add ah,dl		IN AL ,InputPort	        TEST al,DayBreakType	        jnz SetIntialFileStream2 ;****jz if daisy*****		mov ah,OtherMonitorPtrSetIntialFileStream2:mov [DI].FilePointer,ah                     jmp SetFileBuffers        				MonitorStart:   CALL	ClearCpLoaded		mov AL,[SI].TestNS		mov [SI].TestN,al ;Set current test to test startRunTest:	CALL ExtStopDisplay                CALL DoRunTimeWork;See if there is work to do		CALL SetTCBPointer ;Set to test control block		mov BX,[SI].TCBPointer		TEST BYTE PTR [BX][1],SkipTestBit ;Get Second byte of tcblock		jnz GetNextTest ;See if we want to skip this test		mov [DI].MesaFault,NoMesaFault                mov [DI].IOPFault,NoIOPFault                call DisplayTestNumber ;Display Current Test Number		Call ExtTestCode ;Test will Stop Cp load CS and Start Cp				TestDone:	CALL	RestoreReg 		CALL DoRunTimeWork ;See if there is work to do		TEST [DI].TestControl,SkipToNextTest                jnz   SkipTest ;Skip This Test		CALL  ExtPostProcess		call DisplayTestNumber ;Display Current Test NumberDisplayFault:	mov al,[di].MesaFault		mov ah,[di].IOPFault                cmp ax,NoIOPFault + NoMesaFault 		je NoFaults		TEST [di].ErrorControl,NoError                jnz NoFaults		cmp ah,NoIOPFault		jz CheckMesaError		TEST [di].ErrorControl,NoIOPError                jz DisplayTheFaultCheckMesaError:	cmp al,NoMesaFault		jz NoFaults		TEST [di].ErrorControl,NoMesaError                jnz NoFaultsDisplayTheFault:mov cl, 07h                CALL PutOneByte		CALL DisplayHexWord			CALL DisplayLoop		CkContinue:     CALL DoRunTimeWork ;See if there is work to do		TEST [DI].ErrorControl,ContinueAfterError                jz   TestDone ;Stay in loop until Skip/Stop/ContinueAfterErrorNoFaults:	TEST [DI].LoopControl,LoopOnTest                jnz   StartAgain ;See if we want to loop on this testGetNextTest:	mov al, [SI].TestN		cmp al,[SI].TestNE		je  MonitorReStart		inc [SI].TestN		TEST  [DI].FileControl,NoClearTestControl		jnz  StartAgain		CALL	ClearCpLoadedStartAgain:	jmp     RunTestSkipTest:	xor [DI].TestControl,SkipToNextTest                jmp GetNextTest	MonitorReStart: TEST [DI].LoopControl,LoopOnTestStream                jz   MonitorReStart1 ;See if we want to loop on this test stream		jmp MonitorStartMonitorReStart1:TEST [DI].FileControl,BurdockFile                jz GetNextFile		jmp WaitForInput												;{Sub-Rourines----------------------------------------------------------}OutStruc:       mov Bx,0		mov ES,Bx		mov bx,BootStruc		ret		CkLoopOnFile:	Test [DI].LoopControl,LoopOnFileStream	        jnz SetFileBuffers 		Test [DI].TestControl,AlagInProcess		jnz SetMesaFilePtr		jmp WaitForInputSetMesaFilePtr: mov [DI].FilePointer,MesaFilePtrSetFileBuffers:	mov bx, 0                mov bl,[DI].FilePointer 		add bx, ExtMFSCBlock                mov ax, WORD PTR [BX]		mov bx, ExtMFSCBlock                mov WORD PTR [BX] [2],ax		mov  al,[DI].FileS		mov  [DI].FileN,al		jmp GetNextFile1		     GetNextFile:	mov al, [DI].FileN		cmp al,[DI].FileE		je  CkLoopOnFile		inc [DI].FileN		GetNextFile1:	TEST [DI].FileControl,MonitorFile 		jz GetNextFile2		xor [DI].FileControl,MonitorFile		jmp GetNextFile3						GetNextFile2:   cmp [SI].FileType ,FileType2		je GetNextFile3		CALL ExtWriteBranchesGetNextFile3:   CALL	ClearCpLoaded	        Call ConfIt 		GetNextFile4:	Call Initilize		mov bx,0		mov bl,[DI].FileN		add bx,ExtFileNumber		mov ax,0		mov al,BYTE PTR [BX]		Call OutStruc		MOV ES:[BX].BootOverlayRequest,ax		MOV ax,ES:[BX].OpieReentrySeg		PUSH AX		MOV ax,ES:[BX].OpieReentry		PUSH AX		MOV ES:[BX].BootOverlayReentry,OFFSET StartO		MOV ES:[BX].BootOverlayReentrySeg,CS		mov ES:[BX].BootType,DiagnosticType		mov ES:[BX].SkipUserInterface,SkipBootUI		cmp ES:[BX].BootOverlayRequest,0		jne GetNextFileRet		MOV ES:[BX].BootType,NormalType		cmp ES:[BX].FinishMode,BootIcons		jg WaitForInput		jnz GetNextFileRet		MOV ES:[BX].SkipUserInterface,RunBootUIGetNextFileRet:		MOV AL,5	;set up IO Region map register for OPIE		mov dx,Map0IOP		out dx,al		CLIInterSegRet0	PROC	FAR                RetInterSegRet0 	ENDP		WaitForInput:   CALL	DisplayWaitNumber WaitForInput1:	CALL	DoRunTimeWork		mov dl,[di].CurrentInputByte		cmp dl,KI		jne NotReStartTest		jmp MonitorStartNotReStartTest:	cmp dl,KS		je SelectTestStream		cmp dl,KT		je SetTheTestStream		cmp dl,KJ		jne NotJumpToTest		TEST [DI].FileControl,BurdockFile		jnz JumpToTest1		jmp StartOJumpToTest1:	jmp StartBNotJumpToTest:	cmp dl,KF		je DoFileBoot		jmp WaitForInput		SelectTestStream: MOV [DI].AccuWord,0	         jmp TestSelectSetTheTestStream:Call BlinkIndex                 mov ax,WORD PTR  [SI][2] ;Move  to ax TestNS/TestNE		 MOV [DI].AccuWord,ax	         CALL PutDataByte                 CALL GetAccuWord 	         MOV ax,[DI].AccuWord	         mov WORD PTR  [SI][2],ax ;Move ax to TestNS/TestNE		 mov [SI].TestN,ah ; Set up Test to run		 CALL SetTCBPointer ;Set to test control block		 jmp WaitForInput		 		 		DoFileBoot:Call PutEditDoFileBoot1:Call BlinkIndex         CALL GetNextKey ;Pop Next Byte from Input Buffer	 mov dl,[di].CurrentInputByte         cmp dl,KA		;Mesa Code (back to icons) boot	 jne NoDoveKA	 mov bl,MesaFilePtr	 jmp NewFilePointer NoDoveKA: cmp dl,KB		;Boot and run ALAG	 jne NoDoveKB	 mov bl,MonitorFilePtr		 jmp NewFilePointer NoDoveKB: cmp dl,KR		;RS232	 jne NoDoveKR 	 mov bl,Rs232FilePtr	 jmp NewFilePointerNoDoveKR:cmp dl,KC		;Control Store	 jne NoDoveKC		 mov bl,CSFilePtr	 jmp NewFilePointerNoDoveKC:cmp dl,KE		;Ethernet	 jne NoDoveKE 	 mov bl,EithernetFilePtr	 jmp NewFilePointerNoDoveKE:cmp dl,KD		;Rigid Disk	 jne NoDoveKD 	 mov bl,DiskFilePtr	 jmp NewFilePointerNoDoveKD:cmp dl,KF		;Floppy	 jne NoDoveKF 	 mov bl,FloppyFilePtr	 jmp NewFilePointerNoDoveKF:cmp dl,KU		;PCE	 jne NoDoveKU 	 mov bl,PCEFilePtr	 jmp NewFilePointerNoDoveKU:cmp dl,KM		;Memory (IOP vs. S)	 jne NoDoveKM	 mov bl,MemoryFilePtr		 jmp NewFilePointerNoDoveKM: cmp dl,KS		;System Combo	 jne NoDoveKS	 mov bl,SystemFilePtr		 jmp NewFilePointerNoDoveKS: cmp dl,KP		;CP	 jne NoDoveKP		 mov bl,CPFilePtr	jmp NewFilePointer	 NoDoveKP: cmp dl,KJ		;Printer	 jne NoDoveKO		 mov bl,PSFilePtr	jmp NewFilePointer NoDoveKO: cmp dl,KO		;Parallel Port Option (Dash II)	 jne NoDove		 mov bl,PPFilePtr	jmp NewFilePointer NoDove:	jmp DoFileBoot1	NewFilePointer:mov [DI].FilePointer,bl	       jmp SetFileBuffers		Initilize:	CLI                CALL	RestoreReg 		mov     WORD PTR [DI][WrRstCtlRegMask],NoResets		mov     WORD PTR [DI][WrCtlRegMask],EnableMem		Call StopAll		STI		Ret		StopAll:	MOV     [di].EnableIntC1C2,DisableAllInt ;Stop all Interrupts 		MOV	[di].EnableIntDmaRs232,DisableAllInt  		MOV	[di].EnableIntExp,DisableAllInt			CALL	EnableInt		MOV	AX, EnableMem		        Call    OffWrCtlReg	        MOV	AX, ResetAll ;resets everything		CALL    OffWrRstCtlReg				CALL	SetInterruptVectors  ;Point All Interrupts To Error		CALL	InitilizeIntCont ; Initlize all Controlers		CALL	InitilizeKBUart ; Initlize Keyboard and set Vector	        MOV	[di].EnableIntC1C2,InitialIntEnable		MOV  dx,DVIntLatch  ; Display	        IN AX,DX    	    	mov	al,ChanelReset                 out	ChanlaCommand,al                 out	ChanlbCommand,al				;TEST al,DayBreakType	       ; jz StopAll1             ;****temp for daisy	        MOV	DX,i186Timer1MCWAddr	;write control reg		MOV	AX, FloppyDMATC		;Floppy 		OUT	DX, AX			;to turn TC offStopAll1:	IN	Ax, EtherNetIntLatch     ;Clears the interrupt flipflop	        in	ax,DayBreakPort		;A In Reset Mesa Int Latch 		;in	ax,SiriusPort		;A In Reset Mesa Int Lacth		CALL	EnableInt		Ret			RestoreReg:	MOV	AX, CS		MOV	DS, AX		MOV	DI, ExtMCBlock ;Index to Monitor Control Block		MOV	SI, ExtMFCBlockLoc ;Index to Monitor File Control Block		Ret	SetTCBPointer:  mov al, [SI].TestSizeConf                and ax,SizeMask ;This is in words		shl ax,1		mov BL,[SI].TestN                mul BL  ;Ax = to TestN X Size		mov bx,ExtTCBlock		add AX, Bx		mov  [SI].TCBPointer,ax ;Ax = to TestN X Size + Start Of TCB		Ret		ClearCpLoaded:	and [DI].TestControl,ClearLoaderMask                RetTestSelect:	Call PutDataByte                Call BlinkIndex                CALL GetAccuWord                cmp [DI].AccuWord,15		jg  TestSelectTestSelectOk:	MOV BX,[DI].AccuWord                shl bx,1                add BX,ExtStartingTestNum                mov ax, WORD PTR [SI][BX] ;Get Selection		mov WORD PTR  [SI][2],ax ;Move it to TestNS/TestNE		CALL ExtPreProcess		jmp MonitorStart 				Message:        PUSHA                push ax                CALL	RestoreReg 		pop ax		mov cl, 07h                CALL PutOneByte		CALL DisplayHexWord			POPA                Ret				;Pop a Byte from input buffer and put it in CurrentInputByte	GetNextKey:	CLI                MOV ax,0		MOV [DI].CurrentInputByte,0                MOV bx,ExtMKCBlock        	MOV al,[bx].OutputPointerGetNextKey1:    cmp [bx].InputPointer,al                je  GetNextKeyRet		cmp [bx].PointerToBufEnd,al                jne  IncOutPointer		MOV al,[bx].PointerToBufStart                jmp GetNextKey1IncOutPointer:	inc alGetByte:	MOV [bx].OutputPointer,al                add bx,ExtInputByte		add bx,ax		MOV al,BYTE PTR [BX]                MOV [DI].CurrentInputByte,alGetNextKeyRet:	STI                Ret 		;Keyboard interrupt vector points Here; Must save all reg ;push incoming byte into input bufferPutNextKey:	 CLI                 PUSHA                 MOV ax,0		 MOV bx,ExtMKCBlock		 MOV  AL, nonSpecificEOI	;Write an EOI command for the 			 OUT  i8259MasterAddr0, AL	;  Master 8259		 IN	AL, KbdUart		 TEST	AL, i8251RxReady		 JNZ	PutNextKey1		 STI			         JMP	PutNextKeyRet				PutNextKey1:	 IN	AL, KbdUartData		 STI		 MOV [bx].MouseByte,al	         cmp [bx].MouseCount,0		 jz CheckIfMouseByte		 dec [bx].MouseCount		 jmp PutNextKeyRet		 CheckIfMouseByte:cmp [bx].MouseByte,KMouse		 jne CheckForStop		 MOV [bx].MouseCount,2		 jmp PutNextKeyRet		 CheckForStop:    cmp [bx].MouseByte,KSTOP		 jne CheckForOverRun		 MOV al,[bx].PointerToBufStart                 MOV [bx].InputPointer,al                 MOV [bx].OutputPointer,al		 jmp DoStop		 		 CheckForOverRun: MOV al,[bx].InputPointerCheckForOverRun1:inc al                 cmp [bx].OutputPointer,al		 je PutNextKeyRet		 dec al		 cmp [bx].PointerToBufEnd,al		 jne IncInPointer		 MOV al,[bx].PointerToBufStart		 jmp CheckForOverRun1IncInPointer:    inc alPutByte:         MOV [bx].InputPointer,al                 MOV cl,[bx].MouseByte		 add bx,ExtInputByte		 add bx,ax		 MOV BYTE PTR [BX],clPutNextKeyRet:   POPA                 IRetPutOneByte:    PUSHA    ;cl has byte               mov ah,clPutOneLoop:    mov cx,10PutOneLoopO:   push cx               mov cx,0PutOneLoopI:   IN  AL, KbdUart	       TEST AL, i8251TxEmpty 	       Jnz SendByte	       LOOP PutOneLoopI	       pop cx               LOOP PutOneLoopOPutOneBytesRet:POPA               RetSendByte:      pop cx               mov al,ah               OUT KbdUartData,al	       jmp PutOneBytesRet		 		DoRunTimeWork: ;See if there is work to do                PUSHA                CALL	RestoreReg 		CALL GetNextKey ;Pop Next Byte from Input Buffer		mov dl,[di].CurrentInputByte                cmp dl,KSTN		jne NotSetSkip		or [DI].TestControl,SkipToNextTestNotSetSkip:	cmp dl,KL		jne NotSetLoopOnTest		xor [DI].LoopControl,LoopOnTestNotSetLoopOnTest:cmp dl,KN		jne NotSetLoopOnTestStream		xor [DI].LoopControl,LoopOnTestStreamNotSetLoopOnTestStream:	cmp dl,KY		jne NotSetLoopOnFileStream		xor [DI].LoopControl,LoopOnFileStreamNotSetLoopOnFileStream:cmp dl,KO		jne NotSetExitOnError		xor [DI].ErrorControl,ContinueAfterErrorNotSetExitOnError:cmp dl,KQ		jne NotSetRunMemAnalysis		or [DI].JumpControl,AnilizeIt		Call ExtClearLog		jmp DoRunTimeWorkRetNotSetRunMemAnalysis:cmp dl,KR		je ShowFRUList		cmp dl,KM		jne CKEdit		mov bx ,ExtcursorWordLocn+2		MOV     DX, 0ECCCH	        IN    AL, DX  ;Input command FOR display SIZE		TEST AL,2	        JZ DisplayCmos	        TEST AL,1	        JNZ Display15		xor WORD PTR [BX],0DADH		JMP DisplayComDisplay15:	xor WORD PTR [BX],0A09H		JMP DisplayComDisplayCmos:	TEST AL,1	        JNZ Display15Cmos		xor WORD PTR [BX],0390H		JMP DisplayComDisplay15Cmos:	xor WORD PTR [BX],0289HDisplayCom:	CALL ExtDisplayCode		jmp DoRunTimeWorkRetCKEdit:		cmp dl,KE		je DoEdit		cmp dl,KZ	        jne DoRunTimeWorkRet	        CALL DoTelescopeDoRunTimeWorkRet:POPA                 Ret		EditRet:call DisplayTestNumber 	jmp DoRunTimeWorkRet        				ShowFRUList:  CALL ExtFRUList	      jmp DoRunTimeWorkRetDoStop:         CLI                MOV	AX, StackLoc/16		MOV	SS, AX		MOV	sp, IOPStackSize                CALL	RestoreReg 		or [DI].LoopControl,LoopOnFileStream		xor [DI].LoopControl,LoopOnFileStream		or [DI].TestControl,AlagInProcess		xor [DI].TestControl,AlagInProcess		mov al, [DI].FileN		mov [DI].FileS,al		mov [DI].FileE,al		Test [DI].JumpControl,TelescopeSet	        Jz DoStop1	        Call ExtUnTelescopeCpDoStop1:	mov [DI].JumpControl,Nojump		Call StopAll	        STI                jmp WaitForInput            		DoEdit:  Call PutEditDoEdit1: Call BlinkIndex         CALL GetNextKey ;Pop Next Byte from Input Buffer         mov [di].EditControl,WordEdit	 mov dl,[di].CurrentInputByte         cmp dl,K0	 jne NotK0DoTCBEdit:  CALL SetTCBPointer ;Set to test control block	    mov bx,[si].TCBPointer	    mov [di].DataPointer,bx            mov al,[SI].TestSizeConf	    and ax,SizeMask ;This is in words	    mov [DI].InRange,ax	    Call ShowIndex	    jmp EditRet	  NotK0:   cmp dl,K1	 jne NotK1	DoMCBEdit:  mov [di].DataPointer,ExtMCBlock            mov [DI].InRange,MCBlockSize/2	    Call ShowIndex	    jmp EditRet NotK1:   cmp dl,K2	 jne NotK2 DoMFCBEdit: mov [di].DataPointer,ExtMFCBlockLoc            mov [DI].InRange,MFCBlockSize/2	    Call ShowIndex	    jmp EditRet	 	 NotK2:   cmp dl,K3	 jne NotK3	DoMFSCBEdit:mov [di].DataPointer,ExtMFSCBlock            mov [DI].InRange,MFSCBlockSize/2	    Call ShowIndex	    jmp EditRet NotK3:   cmp dl,K4	 jne NotK4 DoSRamEdit: MOV ax,CS	    MOV [DI].AccuWord,AX	    CALL PutLocByte            CALL GetAccuWord 	    MOV  ax,[DI].AccuWord	    mov  ES,AX	    or [di].EditControl,ByteEdit+SRamEdit            mov [di].DataPointer,0            mov [DI].InRange,03FFFH	    Call ShowIndex	    jmp EditRet	 NotK4:   cmp dl,K5	 jne NotK5 DoDRamEdit: MOV [DI].AccuWord,0	    MOV ax,0	    CALL PutLocByte            CALL GetAccuWord 	    MOV  ax,[DI].AccuWord	    mov dx,Map2IOP ;*******Modify for Daisy*******	    OUT dx,al	    or [di].EditControl,DRamEdit            mov [di].DataPointer,0            Call ShowIndex	    jmp EditRet	 	 NotK5:   cmp dl,K6	 jne NotK6	DoCSEdit:   CALL ExtStopCp             Mov  ax,[di].OutCSAddress	    MOV [DI].AccuWord,ax	    CALL PutLocByte            CALL GetAccuWord 	    CALL SaveCSStart 	    MOV ax,[DI].AccuWord	    Mov  [di].OutCSAddress,ax	    Mov  [di].OutCSAddress1,ax	    CALL ExtReadCSWord	    CALL InToOutD	    mov [di].DataPointer,ExtMCBlock            MOV [DI].ControlBlockIndex,13H		    mov [DI].InRange,MCBlockSize/2	    Call ShowIndex	    CALL ExtWriteCSWord	    CALL RestoreCSStart 	    jmp EditRet NotK6:   cmp dl,K7	 jne NotK7 DoBPortEdit:or [di].EditControl,ByteEditDoPortEdit: Call PortEdit         jmp EditRet	 NotK7:   cmp dl,K8	 jne NotK8 	 jmp DoPortEditNotK8:   cmp dl,K9	 jne NotK9 DoGetCSAddress: CALL ShowCSAddress	 jmp EditRet	 NotK9:   cmp dl,KP	 jne NotKP DoEEPromEdit:or [di].EditControl,EEPromEdit         mov [di].DataPointer,0         mov [DI].InRange,040H	 Call ShowIndex	 jmp EditRet	 NotKP:   cmp dl,KC	 jne NotKC DoConfEdit:  mov ax,WORD PTR [DI][ExtMemConf] ;Move MemConf to ax	     MOV [DI].AccuWord,ax	     CALL PutDataByte             CALL GetAccuWord 	     MOV ax,[DI].AccuWord	     mov WORD PTR [DI][ExtMemConf],ax ;Move ax to MemConf	     mov ax,WORD PTR [DI][ExtMemConf1] ;Move MemConf to ax	     MOV [DI].AccuWord,ax	     CALL PutDataByte             CALL GetAccuWord 	     MOV ax,[DI].AccuWord	     mov WORD PTR [DI][ExtMemConf1],ax ;Move ax to MemConf	     jmp EditRet	 NotKC:   cmp dl,KL	 jne NotKL 	 Call ExtParityDataLog	 jmp EditRetNotKl:   cmp dl,KA	 jne NotKA 	 Call ExtParityAddressLog	 jmp EditRetNotKA:   jmp DoEdit1	               DoTelescope:mov al, [SI].FileType 	    cmp al ,FileType4	    Jle DoTelescopeRet	    cmp al ,FileType12	    Jg DoTelescopeRet	    cmp al ,FileType10	    Je DoTelescopeRet            Test [DI].JumpControl,TelescopeSet	    Jz DoTelescope1	    Call ExtUnTelescopeCp	    mov [DI].JumpControl,Nojump	    retDoTelescope1:mov [DI].JumpControl,TelescopeIt            mov al,[DI].JumpFile	    mov ah,[DI].JumpTest            mov [DI].AccuWord,ax	    CALL PutDataByte 	    CALL GetAccuWord	    mov AX,[DI].AccuWord	    mov [DI].JumpTest,Ah	    mov [DI].JumpFile,AL	    cmp ah,0	    jnz DoTelescope2	    mov[DI].JumpControl,TelescopeADoTelescope2:mov[DI].LoopControl,LoopOnTest	    mov[DI].ErrorControl,ContinueAfterErrorDoTelescopeRet:ret	    PortEdit:   Call BlinkIndex            MOV ax,[DI].ControlBlockIndex	    MOV [DI].AccuWord,ax	    CALL PutIOByte            CALL GetAccuWord 	    CALL StopOrSpExit	    MOV dx,[DI].AccuWord	    MOV [DI].ControlBlockIndex,dx	    mov ax,0	    TEST [DI].EditControl,ByteEdit	    jz WordInPort	    in al,dx	    jmp CommonPortWordInPort: in ax,dxCommonPort: MOV [DI].AccuWord,ax	    CALL PutDataByte            CALL GetAccuWord 	    CALL StopOrSpExit	    MOV dx,[DI].ControlBlockIndex	    MOV ax,[DI].AccuWord	    TEST [DI].EditControl,ByteEdit	    jz WordOutPort	    out dx,al	    jmp PortEditWordOutPort:out dx,ax	    jmp PortEdit	      	     ShowCSAddress:Call BlinkIndex             CALL ExtStopCp	     CALL SaveCSStart	     CALL ExtReadShift	     CALL InToOut	     ;in ax,InputPort	     ;TEST al,DayBreakType	     ;jnz ShowCSAddress1	    ; CALL ExtWriteShiftShowCSAddress1:CALL ExtStartCp             CALL RestoreCSStart	     Mov ax,[di].InCSAddress	     MOV [DI].AccuWord,ax	     CALL PutLocByte             CALL GetAccuWord	     CALL StopOrSpExit	     jmp ShowCSAddress	     	     	     SaveCSStart:pop dx	    Mov  ax,[di].OutCSAddress	    push ax	    Mov  ax,[di].OutCSAddress1	    push ax	    push dx	    ret	    	       RestoreCSStart:pop dx	    Pop ax	    Mov  [di].OutCSAddress1,ax	    Pop ax	    Mov  [di].OutCSAddress,ax	    push dx	    ret	    	     InToOut:     Mov ax,[di].InCSAddress	     Mov  [di].OutCSAddress,ax	     Mov ax,[di].InCSAddress1	     Mov  [di].OutCSAddress1,axInToOutD:    Mov ax,[di].InCSData0	     Mov  [di].OutCSData0,ax	     Mov ax,[di].InCSData1	     Mov  [di].OutCSData1,ax	     Mov ax,[di].InCSData2	     Mov  [di].OutCSData2,ax	     Mov al,[di].InCSData3	     Mov  [di].OutCSData3,al	     Ret     ShowIndex:  Call BlinkIndex            Call IndexRange            MOV ax,[DI].ControlBlockIndex	    MOV [DI].AccuWord,ax	    CALL PutLocByte            CALL GetAccuWord 	    MOV ax,[DI].AccuWord	    MOV [DI].ControlBlockIndex,ax	    Call IndexRange	    CALL StopOrSpExitShowData:   CALL DataPtr            TEST [DI].EditControl,EEPromEdit	    jnz PromData	    TEST [DI].EditControl,DRamEdit	    jnz DWordData	    TEST [DI].EditControl,ByteEdit	    jz WordData	    mov ax,0	    mov al,BYTE PTR ES:[bx]	    MOV [DI].AccuWord,ax	    CALL PutDataByte            CALL GetAccuWord 	    CALL DataPtr	    MOV ax,[DI].AccuWord	    mov BYTE PTR ES:[bx],al	    	    jmp ShowDataCommonDWordData:  mov ax,WORD PTR ES:[bx]	    xchg al,ah	    MOV [DI].AccuWord,ax	    CALL PutDataByte            CALL GetAccuWord 	    CALL DataPtr	    MOV ax,[DI].AccuWord	    xchg al,ah	    mov WORD PTR ES:[bx],ax	    jmp ShowDataCommonWordData:   mov ax,WORD PTR [bx]	    MOV [DI].AccuWord,ax	    CALL PutDataByte            CALL GetAccuWord 	    CALL DataPtr	    MOV ax,[DI].AccuWord	    mov WORD PTR [bx],ax	    jmp ShowDataCommonPromData:  ; CALL EWEnableEEProm 	    mov bx,[DI].ControlBlockIndex	    CALL ReadEEProm 	    MOV [DI].AccuWord,ax	    CALL PutDataByte            CALL GetAccuWord 	   ; mov bx,[DI].ControlBlockIndex	    ;CALL EraseEEProm	   ; mov bx,[DI].ControlBlockIndex	   ; MOV ax,[DI].AccuWord	   ; CALL WriteEEProm 	   ; CALL EWDisableEEProm 	    ;jmp ShowDataCommonShowDataCommon:CALL StopOrSpExit	    inc [DI].ControlBlockIndex	    jmp ShowIndexBlinkIndex: mov cx,1FFH  ;18H            mov ax,0BlinkLoop:  CALL ExtCursorPattern	    out LEDPort,ax	    ADD ax ,01111H	    LOOP BlinkLoop	    RETIndexRange: mov ax,[DI].InRange	    cmp ax,[DI].ControlBlockIndex	    jg IndexRangeRet	    TEST [DI].EditControl,DRamEdit	    jnz IndexRangeRet	    MOV	[DI].ControlBlockIndex,0            TEST [DI].EditControl,SRamEdit	    jz IndexRangeRet	    pop ax ;Pop one Near Call From StackIndexRangeRet: RetDataPtr:    MOV bx,[DI].ControlBlockIndex	    TEST [DI].EditControl,ByteEdit	    jnz ByteIndex	    MOV	AX,4000H  ;This is equal to map reg 2	    MOV	ES, AX	    shl bx,1	    jnc ByteIndex	    TEST [DI].EditControl,DRamEdit	    jz  ByteIndex	    MOV	ax, ES	    OR ax ,1000H	    MOV	ES, AXByteIndex:  add bx,[di].DataPointer	    ret			;First display accuword	; GetNext Input byte	;If hex rotate accu by 4 and merge new hex and Re-Display	;If Space or CR Return to Caller	;Else Call Special DoRunTimeworkGetAccuWord:  MOV  ax,[DI].AccuWord	      CALL PutSavedByteGetAccuWord1: CALL GetNextKey ;Pop Next Byte from Input Buffer	      cmp [di].CurrentInputByte,KCR	      je GetAccuWordRet	      CALL StopOrSpExit	      CALL KeyToHex		      cmp dl,0FFH	      je GetAccuWord1      NewHex:       MOV ax,[DI].AccuWord	      shl ax,4	      or al,dl	      MOV [DI].AccuWord,ax	      jmp GetAccuWordGetAccuWordRet: Ret	      	      StopOrSpExit: cmp [di].CurrentInputByte,KSP	      je SpExitRet	      RetSpExitRet:    call DisplayTestNumber 	      pop ax ;Pop one Near Call From Stack	      Ret	      			      	            KeyToHex:     mov dl,0FH              mov dh,[di].CurrentInputByte              cmp dh,KF	      je KeyToHexRet	      mov dl,0EH              cmp dh,KE	      je KeyToHexRet	      mov dl,0DH              cmp dh,KD	      je KeyToHexRet	      mov dl,0CH              cmp dh,KC	      je KeyToHexRet	      mov dl,0BH              cmp dh,KB	      je KeyToHexRet	      mov dl,0AH              cmp dh,KA	      je KeyToHexRet	      mov dl,09H              cmp dh,K9	      je KeyToHexRet	      mov dl,08H              cmp dh,K8	      je KeyToHexRet	      mov dl,07H              cmp dh,K7	      je KeyToHexRet	      mov dl,06H              cmp dh,K6	      je KeyToHexRet	      mov dl,05H              cmp dh,K5	      je KeyToHexRet	      mov dl,04H              cmp dh,K4	      je KeyToHexRet	      mov dl,03H              cmp dh,K3	      je KeyToHexRet	      mov dl,02H              cmp dh,K2	      je KeyToHexRet	      mov dl,01H              cmp dh,K1	      je KeyToHexRet	      mov dl,0	      cmp dh,K0	      je KeyToHexRet	      mov dl,0FFHKeyToHexRet:  Ret	      	      ConfIt:		MOV	BX, 11		CALL	ReadEEProm		MOV	DX, 0FF1H		CMP	AL, 0FFH		JNE	ConfIt1		; skip if Daybreak or Dahlia		MOV	DL, 0FFHConfIt1:	MOV	BX, 12		CALL	ReadEEProm		MOV	BX, 0		MOV	AH, 0		SHR	AL, 1		JZ	ConfIt4		DEC	AX		JZ	ConfIt4		DEC	AX		JZ	ConfIt3		MOV	CX, AXConfIt2:	SHL	BX, 4		OR	BL, 0FH		LOOP	ConfIt2ConfIt3:	MOV	DH, 0FFHConfIt4:	MOV	WORD PTR [DI][ExtMemConf], DX		MOV	WORD PTR [DI][ExtMemConf1], BXConfItRet:	RETInitilizeIntCont:	    MOV	AL, i8259MasICW1	;Set up Master 8259 operation	    OUT	i8259MasterAddr0, Al	;	    MOV	AL, i8259MasICW2	;	    OUT	i8259MasterAddr1, Al	    MOV	AL, i8259MasICW3	;	    OUT	i8259MasterAddr1, Al	    MOV	AL, i8259MasICW4		    OUT	i8259MasterAddr1, Al	    MOV	AL, i8259AllInhibited	;All interrupts are inhibited	    OUT	i8259MasterAddr1, Al	;until we turn them on later;	    MOV	AL, i8259SlvICW1	;Set up Slave 8259	    OUT	i8259SlaveAddr0, Al	;	    MOV	AL, i8259SlvICW2	;	    OUT	i8259SlaveAddr1, Al	    MOV	AL, i8259SlvICW3	;	    OUT	i8259SlaveAddr1, Al	    MOV	AL, i8259SlvICW4		    OUT	i8259SlaveAddr1, Al	    MOV	AL, i8259AllInhibited	;All interrupts are inhibited	    OUT	i8259SlaveAddr1, Al	;until we turn them on later;	    MOV	AL, i8259OptionsSlaveICW1	;Set up Options slave 8259	    OUT	i8259OptionsSlaveAddr0, Al	;	    MOV	AL, i8259OptionsSlaveICW2	;	    OUT	i8259OptionsSlaveAddr1, Al;	    MOV	AL, i8259OptionsSlaveICW3	;;	    OUT	i8259OptionsSlaveAddr1, Al	    MOV	AL, i8259OptionsSlaveICW4		    OUT	i8259OptionsSlaveAddr1, Al	    MOV	AL, i8259AllInhibited		;All interrupts are inhibited	    OUT	i8259OptionsSlaveAddr1, Al	;until we turn them on later	    Ret		;--Enable interrupts master 8259 and slave 8259EnableInt:      PUSHA                CALL	RestoreReg 	        MOV	Ax, [di].EnableIntC1C2	   ;		OUT  i8259SlaveAddr1, Al	;  (All interrupts inhibited)	        XCHG al,ah 		OUT  i8259MasterAddr1, Al	;  (All interrupts inhibited)		;--Enable interrupts 80186 dma/timers and 8274 rs232EnableInt1:     MOV	Ax, [di].EnableIntDmaRs232	   ;		MOV  Cl, Ah			;Save Ah		XOR  Ah, Ah			;Ah_ 0		MOV  DX, 0FF28h			;DX_ 186 Mask reg addr		OUT  DX, AX			;		;--Enable interrupts expansion 8259EnableInt2:     MOV	Ax, [di].EnableIntExp	   ;		OUT  i8259OptionsSlaveAddr1, Al	;  (All interrupts inhibited)                POPA                Ret		DisplayWaitNumber:mov al,WaitNumber                 jmp DisplayComNumber		 DisplayTestNumber:mov al,[si].TestNDisplayComNumber: mov cl,6                 CALL PutOneByte                 mov ah,[si].FileNumberBias		 CALL DisplayHexWord                 CALL DisplayLoop		 RetDisplayHexWord:  CALL ExtCursorPattern		 out LEDPort,axPutThreeByte:    mov cl,ah                 CALL PutOneByte                 mov cl,alPutThreeByte1:   CALL PutOneByte	         mov cl,1BH                 CALL PutOneByte                 RetSaveByte:	 MOV bx,ExtMKCBlock+ExtInputByte		 MOV BYTE PTR [BX],cl		 Ret		 PutSavedByte:	 CALL ExtCursorPattern		 out LEDPort,ax		 MOV bx,ExtMKCBlock+ExtInputByte		 MOV cl,BYTE PTR [BX]		 cmp cl,0AH		 je PutDataByte		 cmp cl,09H		 je PutIOByte		 jmp PutLocByte		 PutDataByte:	 mov cl,0AHPutDataByte1:    Call SaveBytePutDataByte2:    CALL PutOneByte		 jmp PutThreeByte		 PutIOByte:	 mov cl,09H                 jmp PutDataByte1		 PutLocByte:	 mov cl,08H                 Call SaveByte                 CALL PutOneByte		 mov cl,0                 jmp PutDataByte2		 PutEdit:         mov cl,0FFH                 CALL PutOneByte                 mov cl,'E'                 CALL PutOneByte		 mov cl,'d'                 CALL PutOneByte	         mov cl,'i'PutEdit1:        CALL PutOneByte	         mov cl,'t'                 jmp PutThreeByte1		 		 ;PutBoot:         mov cl,0FFH                ; CALL PutOneByte                ; mov cl,'B'                ; CALL PutOneByte		; mov cl,'o'                 ;CALL PutOneByte	        ; mov cl,'o'                ; jmp PutEdit1		 		 		 				 		 DisplayLoop:    mov cx,200DisplayLoopO:   push cx                mov cx,1000DisplayLoopI:   mov ax,0FFFFH		LOOP DisplayLoopI		pop cx                LOOP DisplayLoopO	        ret				; Read EEProm;	at entry, BX = EEProm word address (0-63);	at exit, AX = EEProm data (16 bits)ReadEEProm:		OR	BL, EEPCmdRead			CALL	SendCommand			XOR	BX, BX			MOV	CX, 16ReadLoop:		MOV	AX, EEPEnable+EEPClk			OUT	WriteConfigReg, AX			XOR	AX, EEPClk			OUT	WriteConfigReg, AX			IN	AX, InputPort			TEST	AX, EEPReadDataMask			JZ	ReadShiftData			STCReadShiftData:		RCL	BX, 1			LOOP	ReadLoop			MOV	AX, EEPEnable+EEPClk			OUT	WriteConfigReg, AX			XOR	AX, EEPEnable			OUT	WriteConfigReg, AX			MOV	AX, 0			OUT	WriteConfigReg, AX			MOV	AX, BXReadEnd:		RET; Write EEProm (Erase or Reset must preceed call);	at entry, BX = EEProm word address (0-63), AX = EEProm data (16 bits);WriteEEProm:		PUSH	AX                       ; OR	BL, EEPCmdWrite			;CALL	SendCommand			;POP	BX			;MOV	CX, 16;WriteLoop:		SHL	BX, 1			;JC	WriteData1;WriteData0:		AND	AX, NOT EEPWriteDataMask			;JMP	SHORT WriteData;WriteData1:		OR	AX, EEPWriteDataMask;WriteData:		OUT	WriteConfigReg, AX			;XOR	AX, EEPClk			;OUT	WriteConfigReg, AX			;XOR	AX, EEPClk			;OUT	WriteConfigReg, AX			;LOOP	WriteLoop			;MOV	AX, 0			;OUT	WriteConfigReg, AX			;XOR	AX, EEPEnable			;OUT	WriteConfigReg, AX;WriteLoop2:		IN	AX, InputPort			;TEST	AX, EEPStatusReady			;JZ	WriteLoop2			;MOV	AX, 0			;OUT	WriteConfigReg, AX;WriteEnd:		RET; Erase EEProm (word set to FFFF);	at entry, BX = EEProm word address (0-63);EraseEEProm:		OR	BL, EEPCmdErase			;CALL	SendCommand			;MOV	AX, 0			;OUT	WriteConfigReg, AX			;XOR	AX, EEPEnable			;OUT	WriteConfigReg, AX;EraseLoop:		IN	AX, InputPort			;TEST	AX, EEPStatusReady			;JZ	EraseLoop			;MOV	AX, 0			;OUT	WriteConfigReg, AX;EraseEnd:		RET; Erase/Write Enable EEProm;	no parameters;EWEnableEEProm:		MOV	BL, EEPCmdEWEnable			;CALL	SendCommand			;MOV	AX, 0			;OUT	WriteConfigReg, AX;EWEnableEnd:		RET; Erase/Write Disable EEProm;	no parameters;EWDisableEEProm:	MOV	BL, EEPCmdEWDisable			;CALL	SendCommand			;MOV	AX, 0			;OUT	WriteConfigReg, AX;EWDisableEnd:		RET;--------------------------------------------------------------------------------; Send command to EEProm;	command in BL; AX and CX trashedSendCommand:		MOV	AX, EEPEnable			OUT	WriteConfigReg, AX			XOR	AX, EEPClk			OUT	WriteConfigReg, AX			XOR	AX, EEPClk			OUT	WriteConfigReg, AX			OR	AX, EEPWriteDataMask			MOV	CX, 9SCLoop:			OUT	WriteConfigReg, AX			XOR	AX, EEPClk			OUT	WriteConfigReg, AX			XOR	AX, EEPClk			OUT	WriteConfigReg, AX			SHL	BL, 1			JC	SCData1SCData0:		AND	AX, NOT EEPWriteDataMask			JMP	SHORT SCEndLoopSCData1:		OR	AX, EEPWriteDataMaskSCEndLoop:		LOOP	SCLoopSCEnd:			RETUnExpectedInt: CLI               PUSHA	       CALL	RestoreReg 	       inc  [di].UnExpectedInts	       or  [di].IOPFault,UnExpectedInterrupt		       MOV  AL, nonSpecificEOI		;Write an EOI command for the 		       OUT  i8259MasterAddr0, AL		;  Master 8259UnExpectedIntRet:POPA		 STI				;Enable interrupts		 IRetSetInterruptVectors:MOV AX,0                MOV  DS,AX			MOV  AX, OFFSET UnExpectedInt			MOV  dx, CS;Set86InterruptLoop:MOV  WORD PTR [bx], AX		MOV  BX, ExtInterruptV1			MOV  [bx].ParityV, AX				MOV  [bx].ParityVS, dX				MOV  cX, IntVectorSize-3		add bx,12    ;Skip Over Burdock Input Int VectorsSetInterruptLoop:MOV  WORD PTR [bx], AX				add bx,2			MOV  WORD PTR [bx], dX				add bx,2		LOOP SetInterruptLoop		MOV  AX,CS		MOV  DS,AX		Ret		InitilizeKBUart:MOV AX,0                MOV  DS,AX			MOV  BX, ExtInterruptV1			MOV  AX, OFFSET PutNextKey			MOV  [bx].KeyBoardV, AX				MOV  ax,CS				MOV  [bx].KeyBoardVS, AX				MOV  AX,CS		MOV  DS,AX							init8254:	MOV	AL, i8254SelCount2+i8254LSBthenMSB+i8254SqWave+i8254BinaryCount		OUT	i8254Ctlr,AL		MOV	AX, 26			;**** Baud9600 *****		OUT	i8254Count2,AL		;ls byte		MOV	AL, 0		OUT	i8254Count2,AL		;ms byte               ; IN AL ,InputPort			       ; TEST al,DayBreakType	       ; jnz init8251A               ; MOV	DX, i186Timer1CountAAddr ;For Daisy Temp Keyboard 		;MOV	AX, 13		;OUT	DX, AX		;MOV	DX, i186Timer1MCWAddr		;MOV	AX, 0C001H		;OUT	DX, AX		;MOV	AX, AllowTmrTC		;Call    OnWrCtlReg		init8251A:      MOV	AX, EnableMem		Call    OnWrCtlReg		mov ax,NoResets		CALL    OnWrRstCtlReg				MOV	DX, KbdUart	;		MOV	AL, i8251StopBits1+i8251ParityNo+i8251Char8Bits+i8251Factor16X		OUT	DX, AL			;Output the MODE instruction		CALL	KDelay		MOV	AL,i8251RTSEnable+i8251ErrorReset+i8251RxEnable+i8251DTREnable+i8251TxEnable  		OUT	DX, AL			;Enable 8251 for receive		RET			KDelay:	        MOV	CX,0ffh			;get mode reg bits	KDelay1:	LOOP	KDelay1			;write mode reg bits				RET						OffWrCtlReg:    or  WORD PTR [DI][WrCtlRegMask],ax	    	xor  WORD PTR [DI][WrCtlRegMask],axComWrCtlReg:	mov ax,WORD PTR [DI][WrCtlRegMask]		mov dx,WrCtlReg		out dx,ax                Ret		OnWrCtlReg:     or  WORD PTR [DI][WrCtlRegMask],ax		jmp ComWrCtlRegOffWrRstCtlReg: or WORD PTR [DI][WrRstCtlRegMask],ax		xor WORD PTR [DI][WrRstCtlRegMask],ax		mov ax,WORD PTR [DI][WrRstCtlRegMask]		mov dx,WrRstCtlReg		out dx,ax		CALL	KDelay                Ret			    	OnWrRstCtlReg:  or WORD PTR [DI][WrRstCtlRegMask],ax		mov ax,WORD PTR [DI][WrRstCtlRegMask]		mov dx,WrRstCtlReg		out dx,ax                Ret		       	MonitorCode	ENDS	END 
{File name:  MoonMR.mc}{author: Usamah Khulusi}{This test Stores and Checks Main Memory as directed by a Send Memory Test Control Block (SMTCB) located at RMTCBloc as defined in MoonMemRun.dfn.  This SMCTB is loaded by the software such that a store/check of 256 memory patterns  are performed. Faults will cause the software to loop on locations identified by the # of faults found. This test assumes the Mesa Processor hardware and the SMTCB words of memory are funtional.}Reserve[0001,001E];{ For moonBus}Reserve[0020,002E];{ For moonBus}Reserve[0030,003E];{ For moonBus}Reserve[0040,005F];{ For moonBus}Reserve[0060,00FF];{ moonsun1}Reserve[0110,0180];{ moonsun1}Reserve[0181,01FF];{ moonsun2}Reserve[0210,03CF];{ moonsun2}Reserve[03D0,03FF];{ moonsun3}Reserve[0401,04D2];{ moonsun3}Reserve[04D4,04FF];{ moonsun3}Reserve[0400];	   { moonsun4}Reserve[0500,05FF];{ moonsun4}Reserve[0600,060F];{ moonsun4}Reserve[0700,070F];{ moonsun4}Reserve[0800,08D2];{ moonsun4}Reserve[08D4,08FF];{ moonsun4}Reserve[0610,06D2];{ moonsun5}Reserve[06D4,06FF];{ moonsun5}Reserve[04D3];	{moontime }Reserve[06D3];	{moontime }Reserve[0710,07FF];{ moontime}Reserve[0AD3,0AD4];{ moontime}{Reserve[0900,09FF];{ MoonMr}}Reserve[0A00,0AD2];{ For OTHER TEST}Reserve[0AD5,0FEF];{ For OTHER TEST}Reserve[0100,0106];{ For OTHER TEST}Reserve[0108,010F];{ For OTHER TEST}Reserve[0200,0206];{ For OTHER TEST}Reserve[0208,020F];{ For OTHER TEST}Reserve[0FF0,0FF6];{ For OTHER TEST}Reserve[0FF8,0FFE];{ For OTHER TEST}SetTask[0]; StartAddress[TERROR1];TERROR1:R1 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[0];        DataSP _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[1F];        DataTP _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[3F];        R1 _ R1 or DataSP,ClrIE,	c*, at[2F];        R1 _ R1 or DataTP,	c*, at[107];	        Xbus _ R1 LRot0, XwdDisp,	c*;	DISP2[TrapType],	c*;TrapType:GOTO[Trap],	c*, at[0,4,TrapType];	SetIE,GOTO[START],c*, at[1,4,TrapType];	GOTO[Trap],	c*, at[2,4,TrapType];	GOTO[Trap],	c*, at[3,4,TrapType];Trap:	 GOTO[Trap],	c*;START:	XC2npcDisp, c2;	BRANCH[BadCy, GoodCy, 0D],	c3;BadCy:	Noop,	c*, at[0D,10,GoodCy];	Noop,	c*;	GOTO[START]	c*;	GoodCy:	ClrLOCK,		c1, at[0F,10,BadCy]; {let IOP do whatever}	TrapState _ 4,		c2;	GOTO[InitValues],	c3, at[207];{------------------------------------}{This routine initialize a Send Memory Control Block (SMCTB) into allocated registers}InitValues:	{initialize the SMCTB into my Regs}       R3 _ 2,   c1;       R3 _ R3 LRot8,  c2;       Passes _ R3 ,   c3;   {load # of passes to run}       R3 _ 0,  c1;       PageWordS _ R3,  c2;    {load PageWordS (Start)}       BankS _ R3,   c3;                BankE _ R3,  c1;    {load PageWordE (End)}       DataSP _ R3,    c2; {load Starting Data Type}       DataTP _ R3,  c3;    {load Starting Data Type}              R3 _ 0F,   c1;              PageWordE _ R3,   c2;  {load BankEnd}       GOTO[RunTest],     c3;              {------------------------------------}{This routine reads the test control reg. after initializing all the registers needed for a given test. This test control reg. controls the test kind to be performed during a test run.}RunTest:Noop,		c1;	L0 _ 0,			c2;	GOTO[PhaseSetUp], c3; {initialize all reg. used for test and return}		Noop,	c1, at [0,10,PhaseSetUpRet];	Noop,    c2;         GOTO[Store],        c3; {Store }	      RunTest1: Noop,	c1;	  L0 _ 1,			c2;	  GOTO[PhaseSetUp],	c3;		  Noop,	c1, at [1,10,PhaseSetUpRet];	  Noop ,	c2;          GOTO[Check],	c3; {Check only}DecPassCount: R4 _ Passes,	 c1;              R4 _ R4 - 1,ZeroBr,c2; {test if we should stop running}	      IncDataSP:    Passes _ R4,BRANCH[$,Done], c3; {Done if no more passes}	      R4  _ DataSP LRot8,	c1; 	      R4 _ R4+1 ,		c2; 	      R4 _ R4 and 0FF,		c3; 	      R4 _ R4 LRot8,		c1;	      DataSP_ DataSP+1,		c2; 	      DataSP_ DataSP and 0FF,	c3; 	      	      DataSP _ R4 or DataSP,	c1; {put back as next pattern}IncDataTP:    R4 _ DataTP,		c2;	      R4 _ R4 + 1,		c3;	      	      [] _ R4 xor 5, ZeroBr,	c1; {have we reached the last type?}	      BRANCH[IncOK,Gets0Again],	c2; {DataTP+1<5,Reset DataTP} IncOK:	      DataTP _ R4, GOTO[RunTest],	c3;Gets0Again:   DataTP _ 0, GOTO[RunTest], c3;	Done:   Noop,c1;	EndOfTest: GOTO[EndOfTest],c*, at[0FF7];{Test has ended!}{-----------------------------------------}{Set-up the starting and ending addresses to be tested.}{Initialize address reg., R0, to the starting address.}PhaseSetUp:     R0 _ PageWordS, c1;  {Set-up ,PageWord, address reg. R0}	R4 _ BankS,			c2; {set-up starting Bank}	rhR0 _ R4 LRot0,          c3;  {copy Bank}			R1 _ PageWordE,    c1; {set-up Last PageWord to be accessed}	R4 _ BankE,      c2;{set-up Last Bank to be accessed}	rhR1 _ R4 LRot0,   c3;	       	Noop,    c1;       	DataO _ 0, L0Disp,	c2; {clear observed data reg.}	DISP4 [PhaseSetUpRet]		c3;	{-----------------------------------------}{This routine Stores a pattern into  all memory locations.}{The pattern stored into memory is given by the byte ,"starting data type", of}{SMTCB word # 8.}{The byte , "Test Control", of SMTCB word # 8 determines the test}{to be performed on the memory.}{Word # 9 of SMTCB, Data/Error Control, controls the test flow}{after completion or error} Store:  Xbus _ DataTP LRot0, XDisp,    c1;  {Dispatch to store data type}      DataE _ DataSP, DISP4[SType],    c2;   {data pattern}      SType:    {Branch on StartingDataType on Store routine entry}      DataModifier _ 0, GOTO[Store3],   c3,  at[0, 10, SType];      DataE _ R0, GOTO[Store2],    c3,  at[1, 10, SType];      DataModifier _ DataE, GOTO[Store3],  c3, at[2, 10, SType];      DataModifier _ 0, GOTO[Store3],  c3, at[3, 10, SType];      DataModifier _ 0, GOTO[Store1],  c3, at[4, 10, SType];{Store ~Bank/Bank}      Store1:   {compute the next pattern to be stored into next loc.}      Xbus _ DataTP LRot0, XDisp,   c1;      R3 _ R0, DISP4[SType1],  c2;      SType1:   {Modify pattern on entry and continue}      Noop, GOTO[Store3],   c3,  at[0, 10, SType1];{Store Block Patterns}      DataE _ R3, GOTO[Store2],   c3,  at[1, 10, SType1];      DataE _ DataE + DataModifier, GOTO[Store3],  c3,  at[2, 10, SType1];      DataE _ DataE xor DataModifier, c3,at[3, 10, SType1];            Q _ 0,    c1;      DataE _ DataE xor ~Q,    c2;      GOTO[Store3],  c3;      Q _ rhR0,   c3,  at[4, 10, SType1]; {load ~Bank/Bank}            DataE _ Q ,  c1;      R3 _ DataE xor 0FF,  c2;      R3 _ R3 LRot8,   c3;              DataE _ DataE or R3,    c1;      Noop,    c2;      GOTO[Store3],  c3;      Store2:   {store PageWord into Address}      MAR _ [rhR1, R1 + 0],   c1;      MDR _ R1,   c2;      Noop,   c3;      Store3:  {Store Block Patterns}      MAR _ [rhR0, R0 + 0],    c1;      MDR _ DataE,  c2;      R1 _ R1 - 1,  c3;{R1 is decremented down from PageWordE}             Noop,    c1;      [] _ R0 xor PageWordE, ZeroBr,    c2;{Is it PageWordE?}      R0 _ R0 + 1, BRANCH[Store1, SLAddrMatch],    c3;{If not, store in next location}      SLAddrMatch:   {Done with Store, GoTo run the next test}      Noop,  c1;      Noop,   c2;      GOTO[RunTest1],   c3;      {--------------------------------------}{This routine checks for correct pattern in memory}Check:   Xbus _ DataTP LRot0, XDisp,    c1;       DataE _ DataSP, DISP4[CType],   c2;       CType: DataModifier _ 0, GOTO[Check2],   c3, at[0, 10, CType]; {Block pattern}       DataE _ R0, GOTO[Check2],  c3, at[1, 10, CType]; {PageWord pattern}       DataModifier _ DataE, GOTO[Check2],  c3, at[2, 10, CType]; {pattern increments}       DataModifier _ 0, GOTO[Check2],  c3, at[3, 10, CType]; {pattern increments}       DataModifier _ 0, GOTO[Check1],  c3, at[4, 10, CType]; {~Bank/Bank}       Check1: Xbus _ DataTP LRot0, XDisp,  c1;       R3 _ R0, DISP4[CType1],  c2;       CType1:  Noop, GOTO[Check2],  c3, at[0, 10, CType1];       DataE _ R3, GOTO[Check2],  c3, at[1, 10, CType1];       DataE _ DataE + DataModifier, GOTO[Check2], c3, at[2, 10, CType1];       DataE _ DataE xor DataModifier, c3, at[3, 10, CType1];       Q _ 0,     c1;       DataE _ ~DataE xor Q,    c2;       GOTO[Check2],    c3;       Q _ rhR0,  c3, at[4, 10, CType1];                    DataE _ Q ,    c1;       R3 _ DataE xor 0FF,  c2;       R3 _ R3 LRot8,     c3;              DataE _ DataE or R3,    c1;       Noop,    c2;       GOTO[Check2],  c3;       Check2: MAR _ [rhR0, R0 + 0],   c1;        Q _ DataE,   c2;        DataO _ MD,   c3;       Check2Entry:   Noop,   c1;       DataO _ DataO xor Q, ZeroBr,   c2;       BRANCH[CheckError, $],  c3;              Noop,    c1;       [] _ R0 xor PageWordE, ZeroBr,    c2;       R0 _ R0 + 1,BRANCH[Check1, DecPassCount],  c3;              {determine if errors and location of the first error bit}       CheckError:  {check First Nibble for error}         DataO _ DataO LRot0,XDisp,  c1;         DISP4[1stNibbleDisp],   c2;	          GOTO[2ndNibble],    c3,	at[0, 10, 1stNibbleDisp]; {first nibble OK}         [] _ DataO xor 1,ZeroBr,c3,	at[1, 10, 1stNibbleDisp];          BRANCH[Bit0Mul, $],c*;  {errors in Bits 0(LSB), x}Bit0Err: GOTO[Bit0Err],    c*;	{bit 0 (LSB) error}Bit0Mul: GOTO[MulError],   c*;         [] _ DataO xor 2,ZeroBr,c3,	at[2, 10, 1stNibbleDisp];          BRANCH[Bit1Mul,$],c*;  {errors in Bits 1(LSB), x}Bit1Err: GOTO[Bit1Err],   c*;   {bit 0 (LSB) error}Bit1Mul: GOTO[MulError],  c*;         GOTO[MulError],  c*, 	 	at[3, 10, 1stNibbleDisp];{errors in Bits 1, 2, x}         [] _ DataO xor 4,ZeroBr,c3,at[4, 10, 1stNibbleDisp];          BRANCH[Bit2Mul, $],c*;  {errors in Bits 1(LSB), x}Bit2Err: GOTO[Bit2Err],   c*;   {bit 0 (LSB) error}Bit2Mul: GOTO[MulError],  c*;         GOTO[MulError],  c*,  		at[5, 10, 1stNibbleDisp];{errors in Bits 0, 2, x}         GOTO[MulError],  c*,		at[6, 10, 1stNibbleDisp];{errors in Bits 1, 2, x}         GOTO[MulError],  c*, 		at[7, 10, 1stNibbleDisp];{errors in Bits 0, 1, 2, x}         [] _ DataO xor 8,ZeroBr,c3,	at[8, 10, 1stNibbleDisp];          BRANCH[Bit3Mul,$],c*;  {errors in Bits 1(LSB), x}Bit3Err: GOTO[Bit3Err],    c*;   {bit 0 (LSB) error}Bit3Mul: GOTO[MulError],  c*;         GOTO[MulError],  c*,  		at[9, 10, 1stNibbleDisp];{errors in Bits 0, 3, x}         GOTO[MulError],  c*, 		at[0A, 10, 1stNibbleDisp];{errors in Bits 1, 3, x}         GOTO[MulError],  c*,  		at[0B, 10, 1stNibbleDisp];{errors in Bits 0, 1, 3, x}         GOTO[MulError],  c*,  		at[0C, 10, 1stNibbleDisp];{errors in Bits 2 , 3, x}         GOTO[MulError],  c*,  		at[0D, 10, 1stNibbleDisp];{errors in Bits 0, 2 , 3, x}         GOTO[MulError],  c*,  		at[0E, 10, 1stNibbleDisp];{errors in Bits 1, 2 , 3, x}         GOTO[MulError],  c*,  		at[0F, 10, 1stNibbleDisp];{errors in Bits 0, 1, 2 , 3, x}	 2ndNibble:  {check second Nibble for error}         DataO _ DataO LRot4,XDisp, c1;         DISP4[2ndNibbleDisp],   c2;	          GOTO[3dNibble],    c3,		at[0, 10, 2ndNibbleDisp]; {first nibble OK}         [] _ DataO xor 1,ZeroBr,c3,	at[1, 10, 2ndNibbleDisp];          BRANCH[Bit4Mul, $],c*;  {errors in Bits 0(LSB), x}Bit4Err: GOTO[Bit4Err],   c*;	{bit 0 (LSB) error}Bit4Mul: GOTO[MulError],  c*;         [] _ DataO xor 2,ZeroBr,c3,	at[2, 10, 2ndNibbleDisp];          BRANCH[Bit5Mul,$],c*;  {errors in Bits 1(LSB), x}Bit5Err: GOTO[Bit5Err],   c*;   {bit 0 (LSB) error}Bit5Mul: GOTO[MulError],  c*;          GOTO[MulError],  c*,  		at[3, 10, 2ndNibbleDisp];{errors in Bits 1, 2, x}         [] _ DataO xor 4,ZeroBr,c3,	at[4, 10, 2ndNibbleDisp];          BRANCH[Bit6Mul,$],c*;  {errors in Bits 1(LSB), x}Bit6Err: GOTO[Bit6Err],   c*;   {bit 0 (LSB) error}Bit6Mul: GOTO[MulError],  c*;          GOTO[MulError],  c*,  		at[5, 10, 2ndNibbleDisp];{errors in Bits 0, 2, x}         GOTO[MulError],  c*,		at[6, 10, 2ndNibbleDisp];{errors in Bits 1, 2, x}         GOTO[MulError],  c*, 		at[7, 10, 2ndNibbleDisp];{errors in Bits 0, 1, 2, x}         [] _ DataO xor 8,ZeroBr,    c3,   at[8, 10, 2ndNibbleDisp];          BRANCH[Bit7Mul, $],     c*;  {errors in Bits 1(LSB), x}Bit7Err: GOTO[Bit7Err],   c*;   {bit 0 (LSB) error}Bit7Mul: GOTO[MulError],  c*;          GOTO[MulError],  c*,  		at[9, 10, 2ndNibbleDisp];{errors in Bits 0, 3, x}         GOTO[MulError],  c*, 		at[0A, 10, 2ndNibbleDisp];{errors in Bits 1, 3, x}         GOTO[MulError],  c*,  		at[0B, 10, 2ndNibbleDisp];{errors in Bits 0, 1, 3, x}         GOTO[MulError],  c*,  		at[0C, 10, 2ndNibbleDisp];{errors in Bits 2 , 3, x}         GOTO[MulError],  c*,  		at[0D, 10, 2ndNibbleDisp];{errors in Bits 0, 2 , 3, x}         GOTO[MulError],  c*,  		at[0E, 10, 2ndNibbleDisp];{errors in Bits 1, 2 , 3, x}         GOTO[MulError],  c*,  		at[0F, 10, 2ndNibbleDisp];{errors in Bits 0, 1, 2 , 3, x}	 3dNibble:  {check third Nibble for error}         DataO _ DataO LRot4,XDisp,c1;         DISP4[3dNibbleDisp],   c2;	          GOTO[4thNibble],    c3,	at[0, 10, 3dNibbleDisp]; {first nibble OK}         [] _ DataO xor 1,ZeroBr,c3,	at[1, 10, 3dNibbleDisp];          BRANCH[Bit8Mul, $],c*;  {errors in Bits 0(LSB), x}Bit8Err: GOTO[Bit8Err],c*;	{bit 0 (LSB) error}Bit8Mul: GOTO[MulError],   c*;         [] _ DataO xor 2,ZeroBr,c3,	at[2, 10, 3dNibbleDisp];          BRANCH[Bit9Mul,$], c*;  {errors in Bits 1(LSB), x}Bit9Err: GOTO[Bit9Err],   c*;   {bit 0 (LSB) error}Bit9Mul: GOTO[MulError],  c*;          GOTO[MulError],  c*,  		at[3, 10, 3dNibbleDisp];{errors in Bits 1, 2, x}         [] _ DataO xor 4,ZeroBr,c3,	at[4, 10, 3dNibbleDisp];          BRANCH[Bit10Mul, $],c*;  {errors in Bits 1(LSB), x}Bit10Err:GOTO[Bit10Err],  c*;   {bit 0 (LSB) error}Bit10Mul:GOTO[MulError],  c*;          GOTO[MulError],  c*,  		at[5, 10, 3dNibbleDisp];{errors in Bits 0, 2, x}         GOTO[MulError],  c*,		at[6, 10, 3dNibbleDisp];{errors in Bits 1, 2, x}         GOTO[MulError],  c*, 		at[7, 10, 3dNibbleDisp];{errors in Bits 0, 1, 2, x}         [] _ DataO xor 8,ZeroBr,    c3,   at[8, 10, 3dNibbleDisp];          BRANCH[Bit11Mul, $],     c*;  {errors in Bits 1(LSB), x}Bit11Err:GOTO[Bit11Err],  c*;   {bit 0 (LSB) error}Bit11Mul:GOTO[MulError],  c*;          GOTO[MulError],  c*,  		at[9, 10, 3dNibbleDisp];{errors in Bits 0, 3, x}         GOTO[MulError],  c*, 		at[0A, 10, 3dNibbleDisp];{errors in Bits 1, 3, x}         GOTO[MulError],  c*,  		at[0B, 10, 3dNibbleDisp];{errors in Bits 0, 1, 3, x}         GOTO[MulError],  c*,  		at[0C, 10, 3dNibbleDisp];{errors in Bits 2 , 3, x}         GOTO[MulError],  c*,  		at[0D, 10, 3dNibbleDisp];{errors in Bits 0, 2 , 3, x}         GOTO[MulError],  c*,  		at[0E, 10, 3dNibbleDisp];{errors in Bits 1, 2 , 3, x}         GOTO[MulError],  c*,  		at[0F, 10, 3dNibbleDisp];{errors in Bits 0, 1, 2 , 3, x}	 4thNibble:  {check fourth Nibble for error}         DataO _ DataO LRot4,XDisp,c1;         DISP4[4thNibbleDisp],   c2;	 MesaError:GOTO[MesaError],c*,		at[0, 10, 4thNibbleDisp]; {first nibble OK}Bit12Err: GOTO[Bit12Err], c*,		at[1, 10, 4thNibbleDisp]; Bit13Err: GOTO[Bit13Err], c*,		at[2, 10, 4thNibbleDisp];          GOTO[MulError],  c*,  		at[3, 10, 4thNibbleDisp];{errors in Bits 1, 2, x}Bit14Err: GOTO[Bit14Err], c*,		at[4, 10, 4thNibbleDisp];          GOTO[MulError],  c*,  		at[5, 10, 4thNibbleDisp];{errors in Bits 0, 2, x}         GOTO[MulError],  c*,		at[6, 10, 4thNibbleDisp];{errors in Bits 1, 2, x}         GOTO[MulError],  c*, 		at[7, 10, 4thNibbleDisp];{errors in Bits 0, 1, 2, x}Bit15Err:GOTO[Bit15Err],  c*,  		at[8, 10, 4thNibbleDisp];          GOTO[MulError],  c*,  		at[9, 10, 4thNibbleDisp];{errors in Bits 0, 3, x}         GOTO[MulError],  c*, 		at[0A, 10, 4thNibbleDisp];{errors in Bits 1, 3, x}         GOTO[MulError],  c*,  		at[0B, 10, 4thNibbleDisp];{errors in Bits 0, 1, 3, x}         GOTO[MulError],  c*,  		at[0C, 10, 4thNibbleDisp];{errors in Bits 2 , 3, x}         GOTO[MulError],  c*,  		at[0D, 10, 4thNibbleDisp];{errors in Bits 0, 2 , 3, x}         GOTO[MulError],  c*,  		at[0E, 10, 4thNibbleDisp];{errors in Bits 1, 2 , 3, x}         GOTO[MulError],  c*,  		at[0F, 10, 4thNibbleDisp];{errors in Bits 0, 1, 2 , 3, x}	 MulError:GOTO[MulError],c*;LoaderCheck:	ClrMPIntIOP,GOTO[LoaderCheck],c*, at[0FFF];
$	DEBUG MOD186;MoonMul2.asm;;last edited by TXM		21-Sep-87 10:19:31;;second half of multiple test	NAME	MoonMemoryTest$	TITLE(Memory Test)$	NOLIST		;Next line includes Daisy.def	$	INCLUDE(MoonSys.def)$	INCLUDE(MOONLINK.def)$	INCLUDE(MoonMul.def)$	LIST		;Previous line included Daisy.def;--------------------------------------------MonitorCode	SEGMENT COMMON	ASSUME	CS:MonitorCode, SS:MonitorCode, DS:MonitorCode, ES:MonitorCode;--------------------------------------------;PUBLIC symbols needed by MoonMul1.asmPUBLIC	ExecDonePUBLIC	ExecStartPUBLIC	ExecPreProcessPUBLIC	ExecFRUListPUBLIC	LoadMapRegPUBLIC	ECheckPassPUBLIC	RsRxESPUBLIC	RsTxESPUBLIC	EIntrCountPUBLIC	ENetRst;--------------------------------------------;External Symbols from MoonMul2.asm;External proceduresEXTRN	E0Stack: NEAREXTRN	E1Stack: NEAREXTRN	E2Stack: NEAREXTRN	E3Stack: NEAREXTRN	E4Stack: NEAREXTRN	E5Stack: NEAREXTRN	E6Stack: NEAREXTRN	E0StackRet: NEAREXTRN	E1StackRet: NEAREXTRN	E2StackRet: NEAREXTRN	E3StackRet: NEAREXTRN	E4StackRet: NEAREXTRN	E5StackRet: NEAREXTRN	E6StackRet: NEAREXTRN	ESaveEs: NEAREXTRN	ESetReg: NEAREXTRN	ExcMemTime: NEAREXTRN	NewMap: NEAR;External LabelsEXTRN	DisplayInt: NEAREXTRN	EthIntrHandler: NEAREXTRN	ExcKeyWake: NEAREXTRN	ExecLoop: NEAREXTRN	i8272IrqHandler: NEAREXTRN	MemParityInt: NEAREXTRN	MesaPInt: NEAREXTRN	ResetChip: NEAREXTRN	RS232CommInt: NEAR;External VariablesEXTRN	BackOff: BYTEEXTRN	ByteCnt: BYTEEXTRN	CBLOffset: WORDEXTRN	CmdBuf1: WORDEXTRN	CmdBuf4: WORDEXTRN	CollCarr: BYTEEXTRN	ConfigCmd: WORDEXTRN	CRCPromis: BYTEEXTRN	ECRetryCount: BYTEEXTRN	ExitPointer: WORDEXTRN	FifoLim: BYTEEXTRN	IntFrameSp: BYTEEXTRN	LoopbkAT: BYTEEXTRN	MinFrameLen: WORDEXTRN	ParityCount: WORDEXTRN	RetrySlot: WORDEXTRN	RFAOffset: WORDEXTRN	RBD12: WORDEXTRN	RBD42: WORDEXTRN	RFD1: WORDEXTRN	RFD4: WORDEXTRN	SaveBadF: BYTEEXTRN	SaveRet: WORDEXTRN	SCBComm: WORDEXTRN	SCBStat: WORDEXTRN	SetupIACmd: WORDEXTRN	TBD12: WORDEXTRN	TBD42: WORDEXTRN	TstCtl: BYTEEXTRN	TstType: BYTE;External ConstantsEXTRN	SCBOffset: ABSEXTRN	SCBBaseHigh: ABS	     ORG TestCodeLoc2;-----------------------------------------------------------------ExecDone:	CALL  ExecStop		TEST [bx].EErrorControl,EStopOnError	    	jz  ExecExit		jmp ExecStart		ECheckPass:	CALL  ExecStop		dec [bx].ECurrentPassCount		jz ExecDone		cmp  [di].IOPFault,NoIOPFault	    	jnz ExecDone		cmp  [di].MesaFault,NoIOPFault	    	jnz ExecDone		jmp ExecStart1	ExecExit:	Ret;-----------------------------------------------------------------ExecStart:  	Mov bx,[si].TCBPointer ;Get Index to TCB	   	mov al,[bx].EPassCount	        mov [bx].ECurrentPassCount,alExecStart1:	CALL ExecInitTCB	        TEST [bx].EDeviceControl,E1Task		jz  NoE1Start		CALL  E1StackNoE1Start:	TEST [bx].EDeviceControl,E0Task		jz  NoE0Start            	CALL  E0Stack		inc [bx].E0IntCountNoE0Start:	TEST [bx].EDeviceControl,E2Task		jz  NoE2Start            	CALL  E2Stack		inc [bx].E2IntCountNoE2Start:	TEST [bx].EDeviceControl,E3Task		jz  NoE3Start            	CALL  E3Stack		inc [bx].E3IntCountNoE3Start:	TEST [bx].EDeviceControl,E4Task		jz  NoE4Start            	CALL  E4Stack		inc [bx].E4IntCountNoE4Start:	TEST [bx].EDeviceControl,E5Task		jz  NoE5Start            	CALL  E5Stack		inc [bx].E5IntCountNoE5Start:	TEST [bx].EDeviceControl,E6Task		jz  NoE6Start            	CALL  E6StackNoE6Start:	CALL SetKVectors		mov  cx,8000		jmp ExecLoop		;-----------------------------------------------------------------ExecInitTCB: CALL LoadMapReg             mov dx,Map0IOP	;Code Loc	     in al,dx  	     mov cl,al	     mov ax,1	     shl ax,cl	     or WORD PTR [DI][ExtMemConf],ax ;Move ax to MemConf           	     xor WORD PTR [DI][ExtMemConf],ax ;Move ax to MemConf             mov [bx].EPageParity,0	     mov [bx].EPageParity,0	     mov [bx].EActiveDevices,0	     mov [bx].EDevicesNeedService,0	     mov [bx].E0IntCount,0	     mov [bx].E1IntCount,0	     mov [bx].E2IntCount,0	     mov [bx].E3IntCount,0	     mov [bx].E4IntCount,0	     mov [bx].E5IntCount,0	     mov [bx].E6IntCount,0	     MOV  AX,[bx].EIntWaitTime	     MOV  [bx].E1IntWaitTime,AX	     MOV  [bx].E2IntWaitTime,AX	     MOV  [bx].E3IntWaitTime,AX	     MOV  [bx].E4IntWaitTime,AX	     MOV  [bx].E5IntWaitTime,AX	     MOV  [bx].E6IntWaitTime,AX	     Call ExcMemTime	     	     MOV  AX,sp             MOV  [bx].ESYSPSP,AL	     	     MOV  AX, E0StackLoc/16	     MOV  SS, AX	     MOV  Ax, IOPStackSize/2	     MOV sp, AX	     MOV  AX, OFFSET MemStart	     PUSH ax	     PUSHA             CALL ESaveEs	     MOV  AX,sp             MOV  [bx].E0SP,AL	     	     MOV  AX, E1StackLoc/16	     MOV  SS, AX	     MOV  Ax, IOPStackSize/2	     MOV sp, AX	     MOV  AX, OFFSET EtherStart	     PUSH ax	     PUSHA             CALL ESaveEs	     MOV  AX,sp             MOV  [bx].E1SP,AL	     	     MOV  AX, E2StackLoc/16	     MOV  SS, AX	     MOV  Ax, IOPStackSize/2	     MOV sp, AX	     MOV  AX, OFFSET RS232Start	     PUSH ax	     PUSHA             CALL ESaveEs	     MOV  AX,sp             MOV  [bx].E2SP,AL	     	     MOV  AX, E3StackLoc/16	     MOV  SS, AX	     MOV  Ax, IOPStackSize/2	     MOV sp, AX	     MOV  AX, OFFSET FDCStart	     PUSH ax	     PUSHA             CALL ESaveEs	     MOV  AX,sp             MOV  [bx].E3SP,AL	     	     MOV  AX, E4StackLoc/16	     MOV  SS, AX	     MOV  Ax, IOPStackSize/2	     MOV sp, AX	     MOV  AX, OFFSET PCEStart	     PUSH ax	     PUSHA             CALL ESaveEs	     MOV  AX,sp             MOV  [bx].E4SP,AL	     	     MOV  AX, E5StackLoc/16	     MOV  SS, AX	     MOV  Ax, IOPStackSize/2	     MOV sp, AX	     MOV  AX, OFFSET RDCStart	     PUSH ax	     PUSHA             CALL ESaveEs	     MOV  AX,sp             MOV  [bx].E5SP,AL	     	     MOV  AX, E6StackLoc/16	     MOV  SS, AX	     MOV  Ax, IOPStackSize/2	     MOV sp, AX	     MOV  AX, OFFSET DisplayVTest	     PUSH ax	     PUSHA             CALL ESaveEs	     MOV  AX,sp             MOV  [bx].E6SP,AL	     	     	     MOV  AL,[bx].EDeviceControl	     MOV  [bx].EActiveDevices,AL	     MOV AX, StackLoc/16	     MOV  SS, AX	     MOV  AH, 0	     MOV AL, [bx].ESYSPSP	     MOV sp, AX             ret;-----------------------------------------------------------------LoadMapReg:  mov al,0	     mov dx,Map2IOP	;MailBox	     OUT dx,al             MOV  Al,[bx].EBank	     mov dx,Map1IOP	 	     OUT dx,al	     CALL NextBank             mov dx,Map3IOP	 	     OUT dx,al             CALL NextBank             mov dx,Map4IOP		     OUT dx,al	     CALL NextBank             mov dx,Map5IOP	 	     OUT dx,al             CALL NextBank             mov dx,Map6IOP	 	     OUT dx,al             Ret;-----------------------------------------------------------------NextBank:   Test [bx].EErrorControl,ENoIncBanks	    jnz NewBank	    mov ah,[bx].EBank	    cmp ah,[bx].EEndBank	    je HighMatch	    inc ah	    inc [bx].EBank NewBank:    mov cx,0	    mov cl,[bx].EBank	    mov ax,1	    Test [bx].EBank,10H	    jnz UpperBank	    Test cl,0FH	    jz ShiftBankBit1ShiftBankBit:shl ax,1	    loop ShiftBankBitShiftBankBit1:and ax,WORD PTR [DI][ExtMemConf]ShiftBankBitRet:jz NextBank            MOV  Al,[bx].EBank	    ret	 UpperBank:  and cl,0FH	    jz UpperBank1UShiftBankBit:shl ax,1	    loop UShiftBankBitUpperBank1: and ax,WORD PTR [DI][ExtMemConf1]	    JMP ShiftBankBitRet	HighMatch:  mov [bx].EBank,0	    jmp NewBank	            ;-----------------------------------------------------------------ExecStop:	CLI ;this should temp disable interrupts.                 mov  [di].EnableIntC1C2,InitialIntEnable 	        CALL ExtEnableInt	        STI ;Re-Enable the Interrupts		RETExecPreProcess:   		MOV 	BX,21			;read EEPROM floppy word		CALL 	ExtReadEEProm		MOV	Cl, 4			;juggle floppy EEPROM info		SHR	Ah, cl		cmp 	ah,4			;check drive type		je	ExecPreProcessRet	   	mov 	dl,0		MOV	CX, 8 UpdateTCB:	  	mov 	[SI].TestN,dl 		PUSHA            	CALL 	ExtSetTCBPointer        	POPA	    	CALL	ESetReg ;Get Index to TCB		add	bx,FTCBLoc    ;Get Index to TCB	    	mov 	[bx].fdcDriveType, Ah		test 	[bx].fdcTstCtl, FormatCyc		jnz     UpdateTCB1 		mov 	[bx].fdcESector, 15UpdateTCB1:	INC	Dl		LOOP	UpdateTCBExecPreProcessRet:		RetExecFRUList:mov ax, ExecList0 	   Test [di].MesaFault,E3Task	   jz TryE5Task	   or ax, ExecList1 TryE5Task: Test [di].MesaFault,E5Task	   jz TryE1Task	   or ax,ExecList2 TryE1Task: Test [di].MesaFault,E1Task	   jz DoneTrying	   or ax, ExecList3	   DoneTrying:CALL ExtMessageExecFRUList1:CALL ExtDoRunTimeWork	   cmp [di].CurrentInputByte,KSP	   jne ExecFRUList1	   Ret ExecList0 DW  00000HExecList1 DW  00A00HExecList2 DW  00090HExecList3 DW  00006H;-----------------------------------------------------------------SetKVectors:CLI ;this should temp disable interrupts.             push bx	    MOV AX,0            MOV  DS,AX	    MOV  BX, ExtInterruptV1		    MOV  AX, OFFSET ExcKeyWake		    MOV  [bx].KeyBoardV, AX	    MOV  AX,CS	    MOV  DS,AX	    pop bx	    STI ;Re-Enable the Interrupts	    Ret;-----------------------------------------------------------------		    SetMVectors:CLI ;this should temp disable interrupts.             push bx	    MOV AX,0            MOV  DS,AX	    MOV  BX, ExtInterruptV1		    MOV  AX, OFFSET MemParityInt	    MOV  [bx].ParityV, AX	    MOV  BX, ExtInterruptV2		    MOV  AX, OFFSET MesaPInt	    MOV  [bx].MesaV, AX	    MOV  AX,CS	    MOV  DS,AX	    AND  [di].EnableIntC1C2,ParityIntEnAble             AND  [di].EnableIntC1C2,MesaIntEnAble	    MOV ParityCount,0 	    CALL  ExtResetMesaInt            CALL ExtReadMemStatus    	    CALL ExtReadMemStatus    	    CALL ExtReadMemStatus    	    CALL ExtEnableIntSetMVectorRet:pop bx	     STI ;Re-Enable the Interrupts	     Ret;-----------------------------------------------------------------	SetDVVectors: CLI ;this should temp disable interrupts.             PUSHA	    MOV AX,0            MOV  DS,AX	    MOV  BX, ExtInterruptV2		    MOV  AX, OFFSET DisplayInt	    MOV  [bx].DEventV, AX	    MOV  AX,CS	    MOV  DS,AX	    AND  [di].EnableIntC1C2,DisplayIntEnAble 	    MOV  dx,DVIntLatch	    IN AX,DX	    CALL ExtEnableIntSetDVVectorRet:POPA	     STI ;Re-Enable the Interrupts	     Ret	     ;------------------8274 interupt vector setup-------------------------------I8274VectorSetUp: 		CLI		pusha		MOV AX,0                MOV  DS,AX		MOV  BX, ExtInterruptV1			MOV  AX, OFFSET MemParityInt	;		MOV  [bx].ParityV, AX		MOV  AX, OFFSET RS232CommInt	;		MOV  [bx].Rs232CV, AX		MOV  AX,CS		MOV  DS,AX		mov	al,ChanelReset                 out	ChanlaCommand,al                 out	ChanlbCommand,al	        and	[di].EnableIntC1C2,Rs232IntEnable		call	ExtEnableInt			;now enable interupts		popa		STI		Ret;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ;	Initialize Interrupt vectorsSetFlpVectors:	CLI				;mask all irqs		PUSH	BX			;Save TCB pointer		MOV AX,0                MOV  DS,AX		MOV	BX, ExtInterruptV2	;		MOV	AX, OFFSET i8272IrqHandler ;Set BX,AX to		MOV	[BX].FloppyV, AX 	;and the new IP		MOV  AX,CS		MOV  DS,AX		AND	[di].EnableIntC1C2, FloppyIntEnable ;Enable Floppy Int		MOV	DX,i186Timer1MCWAddr	;write control reg		MOV	AX, FloppyDMATC		;Floppy 		OUT	DX, AX			;to turn TC off		CALL	ExtEnableInt	;Enable all Int in Monitor Control		POP	BX			;POP TCB pointer		STI				;Re-enable interrupts		Ret;-------------------------------------------------------------------------; SUBROUTINE : Seti586IntVectors;Seti586IntVectors:	CLI	PUSH	BX			;Save TCB pointer	MOV AX,0        MOV  DS,AX	MOV	BX, ExtInterruptV2	;	MOV	AX, OFFSET EthIntrHandler ;	MOV	[BX].EthernetV, AX	;	MOV  AX,CS        MOV  DS,AXENetIntOn:	AND	[di].EnableIntC1C2, ENetIntEnable ;Enable ENet Int	IN	Ax, EtherNetIntLatch                ;Clears the interrupt flipflop	CALL	ExtEnableInt		;Enable all Int in Monitor Control	POP	BX			;POP TCB pointer	STI	RET	;-----------this is the test for the expected interupts--------------------intel8274init6:    mov	        al,ChanelReset     out		ChanlaCommand,al     mov		al,ErrorReset    out		ChanlaCommand,al    %rs232command(ChanlaCommand,4,OneAndHalfStopBit+X16Clock)                   %rs232command(ChanlaCommand,1,RxInteruptAll+VarVector+TxIntEnable)    %rs232command(ChanlaCommand,2,Mode8086+RxPriority)          %rs232command(ChanlaCommand,3,Rxenable+RxEightBitChar+AutoEnable)       %rs232command(ChanlaCommand,5,TxEnable+EnableRts+EnableDtr+TxEightBitChar)	    ;--------------   Transmit section second    B  ---------------------------    mov	        al,ChanelReset     out		ChanlbCommand,al     mov		al,ErrorReset    out		ChanlbCommand,al    %rs232command(ChanlbCommand,4,OneAndHalfStopBit+X16Clock)    %rs232command(ChanlbCommand,1,RxInteruptAll+VarVector+TxIntEnable)     %rs232command(ChanlbCommand,2,0)     %rs232command(ChanlbCommand,3,Rxenable+RxEightBitChar+AutoEnable)     %rs232command(ChanlbCommand,5,TxEnable+EnableRts+EnableDtr+TxEightBitChar)          RETintel8274init7:    mov	        al,ChanelReset     out		ChanlaCommand,al     mov		al,ErrorReset    out		ChanlaCommand,al    %rs232command(ChanlaCommand,4,SDLCFlagMode)                   %rs232command(ChanlaCommand,1,RxInteruptAll+VarVector+TxIntEnable)    %rs232command(ChanlaCommand,2,Mode8086+RxPriority)          %rs232command(ChanlaCommand,3,Rxenable+AddressSrch+RxEightBitChar+AutoEnable+Hunt+RxCRCEnable)    %rs232command(ChanlaCommand,5,TxEnable+EnableRts+EnableDtr+TxEightBitChar+TxCRCEnable) %rs232command(ChanlaCommand,6,[bx].RsDataA) %rs232command(ChanlaCommand,7,SDLCFlag) %rs232command(ChanlaCommand,0,RstCrcCheck+ResetExt) %rs232command(ChanlaCommand,0,RstCrcGenerator+ResetExt)%rs232command(ChanlaCommand,0,ErrorReset)	    ;--------------   Transmit section second    B  ---------------------------    mov	        al,ChanelReset     out		ChanlbCommand,al     mov		al,ErrorReset    out		ChanlbCommand,al    %rs232command(ChanlbCommand,4,SDLCFlagMode)    %rs232command(ChanlbCommand,1,RxInteruptAll+VarVector+TxIntEnable)     %rs232command(ChanlbCommand,2,0)     %rs232command(ChanlbCommand,3,Rxenable+AddressSrch+RxEightBitChar+AutoEnable+Hunt+RxCRCEnable)    %rs232command(ChanlbCommand,5,TxEnable+EnableRts+EnableDtr+TxEightBitChar+TxCRCEnable) %rs232command(ChanlbCommand,6,[bx].RsDataB) %rs232command(ChanlbCommand,7,SDLCFlag) %rs232command(ChanlbCommand,0,RstCrcCheck+ResetExt) %rs232command(ChanlbCommand,0,RstCrcGenerator+ResetExt)%rs232command(ChanlbCommand,0,ErrorReset)          RET;------------------timer init----------------------------------------------- intel8254Init: 	   	;for dte port		 	    %timer(i8254selcount0,i8254count0)		    	;for dce port		    %timer(i8254selcount1,i8254count1)   	             ret ;-----------------------------------------------------------------		     	     MemStart:   add bx,MemTCBLoc    ;Get Index to TCB            CALL SetMVectors	    CALL TCBSetUp	    CALL ExtStopDisplay	    TEST  [bx].MDisplayControl,MDisplayOn	    jz NoDisplay   	    CALL ExtStartDisplayNoDisplay:  CALL ExtNewStartM	    CALL ESetReg	    add bx,MemTCBLoc ;Get Index to TCB	    CALL StopStoping              CALL SetSmtcb	    CALL E0StackRet	    	    CALL ExtInterruptCp	    CALL E0StackRet	    ;-----------------------------------------------------------------		     MemEndAction: CALL ExtInterruptCp	      CALL WaitForRmtcb ;this will post error if cp times out	      TEST  [di].IOPFault,IOTimeOutError	      jnz MemEndAction1	      CALL GetRmtcbMemEndAction1:CALL GetCSAddress	      CALL ESetReg	      xor [bx].EActiveDevices,E0Task MemEndAction2:CALL E0StackRet	      JMP MemEndAction2;-----------------------------------------------------------------	SetSmtcb:    MOV	AX,4000H  ;This is equal to map reg 2	     MOV	ES, AX	     mov al,[bx].MInterFaceControl	     and al,0FH 	     mov ES:SInterFaceControl,al 	     mov al,[bx].MPassCount	     mov ES:SPassCount,al 	     mov al,[bx].MStartBank	     mov ES:SStartBank,al 	     mov al,[bx].MStartPage	     mov ES:SStartPage,al 	     mov al,[bx].MEndBank	     mov ES:SEndBank,al 	     mov al,[bx].MEndPage	     mov ES:SEndPage,al 	     mov al,[bx].MStartWord	     mov ES:SStartWord,al 	     mov al,[bx].MEndWord	     mov ES:SEndWord,al 	     mov al,[bx].MStartMapBank	     mov ES:SStartMapBank,al 	     mov al,[bx].MStartMapPage	     mov ES:SStartMapPage,al 	     mov al,[bx].MEndMapBank	     mov ES:SEndMapBank,al 	     mov al,[bx].MEndMapPage	     mov ES:SEndMapPage,al 	     	     mov ax,[bx].MStartData	     xchg al,ah	     mov ES:SStartData,ax 	     	     mov al,[bx].MStartDataType	     mov ES:SStartDataType,al 	     mov al,[bx].MTestControl	     mov ES:STestControl,al 	     mov al,[bx].MDataControl	     mov ES:SDataControl,al 	     mov al,[bx].MMesaErrorControl	     mov ES:SMesaErrorControl,al 	     	     mov ax,[bx].MDelayTime	     xchg al,ah	     mov ES:SDelayTime,ax 	     	     cmp [bx].MTestControl,MMapStoreAndCheck	     jle SendMemConf	     mov ax,0	     mov dx,WORD PTR [DI][ExtMemConf]	     Call CountBanks	     mov dx,WORD PTR [DI][ExtMemConf1]	     Call CountBanks	     jmp SendBankCount	     SendMemConf: mov ax,WORD PTR [DI][ExtMemConf]SendBankCount:xchg al,ah	     mov ES:SMemSize,ax 	     	     mov ax,WORD PTR [DI][ExtMemConf1]	     xchg al,ah	     mov ES:SMemSize1,ax 	     mov ax,SMCTBPattern	     mov ES:SSMTCBPattern,ax 	     RetGetRmtcb:   MOV	AX,4000H  ;This is equal to map reg 4	    MOV	ES, AX	    cmp ES:RRMTCBPattern,RMCTBPattern	    je GetRmtcbok	    or [di].IOPFault,IOTimeOutError	    retGetRmtcbok: mov al,ES:REndMesaBank 	    mov [bx].MEndMesaBank,al	    mov al,ES:REndMesaPage 	    mov [bx].MEndMesaPage,al	    mov al,ES:REndMesaDataType 	    mov [bx].MEndMesaDataType,al	    mov al,ES:REndMesaWord 	    mov [bx].MEndMesaWord,al	    mov ax,ES:RMesaStartPassData 	    xchg al,ah	    mov [bx].MMesaStartPassData,ax	    mov ax,ES:RMesaExpectedData 	    xchg al,ah	    mov [bx].MMesaExpectedData,ax	    mov ax,ES:RMesaObservedData 	    xchg al,ah	    mov [bx].MMesaObservedData,ax	    mov al,ES:RMesaFault 	    or [bx].MMesaFault,al	    jz  GetRmtcbok1	    or [di].MesaFault,E0TaskGetRmtcbok1:mov ax,6655H	    mov ES:RRMTCBPattern,2222H	    Ret	    TCBSetUp:   MOV	AX,4000H  ;This is equal to map reg 2	    MOV	ES, AX	    mov ES:SSMTCBPattern,0	    mov [bx].MMesaFault,0	    Ret	    CountBanks:  mov cx,16CountBanksLoop:shl dx,1	     jnc CountBanks1	     inc axCountBanks1: LOOP CountBanksLoop	     ret	    StopStoping:TEST  [bx].MInterFaceControl,MNoStopStartMesa	    jz StopStopingRet	    or [di].TestControl,NoStopStartMesaStopStopingRet:RetGetCSAddress:CALL ExtReadShift	     CALL ExtStartCp	     Mov ax,[di].InCSAddress	     CALL ESetReg ;Get Index to TCB	     add bx,MemTCBLoc ;Get Index to TCB	     Mov [bx].MCSAddress,axGetCSAddressRet: RetWaitForRmtcb:   CLI                or [di].IOPFault,IOTimeOutError                xor [di].IOPFault,IOTimeOutError		STI                MOV	AX,4000H  ;This is equal to map reg 2	        MOV	ES, AX		PUSHA	        mov cx,10WaitThisTimeI:  CALL ESetReg                inc [bx].E0IntCount                CALL E0StackRet   ;This is a req for a time loop		cmp ES:RRMTCBPattern,RMCTBPattern		je WaitForRmtcbRet                LOOP WaitThisTimeI		or [di].IOPFault,IOTimeOutErrorWaitForRmtcbRet:POPA		Ret;-----------------------------------------------------------------	    DisplayVTest:IN AL ,InputPort	    TEST al,DayBreakType	    jz DisplayVTestRet 	    add bx,DVTCBLoc    ;Get Index to TCB	    Mov [bx].DVIntCount,DVNoCount	    Mov [bx].DVSpare0,DVNoCount	    CALL SetDVVectors	    	    DisplayVLoop:CALL E6StackRet	    CALL ESetReg ;Get Index to TCB	    TEST [bx].EActiveDevices,AnyActive	    jnz  DisplayVLoop	    		DisplayEnd: TEST [di].MesaFault,AnyDevice	    jnz  DisplayVTest1	    TEST [di].IOPFault,AnyDevice	    jnz  DisplayVTest1	    add bx,DVTCBLoc    ;Get Index to TCB	    TEST [bx].DVErrorControl,DVCheckCount	    jz  DisplayVTest1	    Mov ax,[bx].DVIntCount	    Mov [bx].DVObservedIntCount,ax	    cmp ax,DVNoCount	    jnz CheckDV17	    mov dl,DVNointerrups	    jmp DisplayVErrorCheckDV17:  cmp ax,[bx].DV17IntCountH	    jg CheckDV19	    cmp ax,[bx].DV17IntCountL	    jg DisplayVTest1	    mov dl,DVIntTooLow	    jmp DisplayVErrorCheckDV19:  cmp ax,[bx].DV19IntCountH	    jle CheckDV19L	    mov dl,DVIntTooHigh	    jmp DisplayVErrorCheckDV19L: cmp ax,[bx].DV19IntCountL	    jg DisplayVTest1	    mov dl,DVIntInBetween	    DisplayVError: or [bx].DVFault,dl 	       or [di].MesaFault,E6Task	    DisplayVTest1:CLI ;this should temp disable interrupts.             or  [di].EnableIntC1C2,DisplayIntDisable 	    CALL ExtEnableInt	    STI ;Re-Enable the Interrupts	    DisplayVTestRet:CALL ESetReg ;Get Index to TCB	        xor [bx].EActiveDevices,E6TaskDisplayVTestRet1:CALL E6StackRet 	        JMP DisplayVTestRet1				;---------------------------------------------------------------------RsRxES		DW 0RsTxES		DW 0 ;first initialize the timers on the iop board ;now initialize the rs232 dte and dce portsRS232Start:     Call    NewMap                mov   cl,5		shl  ah,cl                mov   RsTxES,ax		MOV	ES, AX	        Mov	bx,DataTxAWriteBuff		Mov	Al, BYTE PTR ES:[BX]		push ax		CALL ESetReg ;Get Index to TCB		add bx,RSTCBLoc    ;Get Index to TCB		pop  ax		Mov     [bx].RsDataA,al		Mov     [bx].RsDataB,al                mov	aX,SelChAIntclk+EnDCEclk		Call    ExtOffWrCtlReg		mov	aX,EnDCEclk 		cmp     [bx].RsTest,6		jne     RS232Start1		mov	aX,SelChAIntclk+EnDCEclkRS232Start1:	Call    ExtOnWrCtlReg		;Enable rs232 tx and rx clock	        call	intel8254Init		call	I8274VectorSetUp	;set up rs232 vectors  		Call    CommSetUp		cmp     [bx].RsTest,7		je     RS232Start2		call	intel8274init6		CALL E2StackRet		jmp     RS232LoopRS232Start2:	call	intel8274init7		CALL E2StackRet		RS232Loop:   	CALL ESetReg ;Get Index to TCB	        Call    NewMap                mov   cl,5		shl  ah,cl                mov   RsRxES,ax		Call    NewMap                mov   cl,5		shl  ah,cl                mov   RsTxES,ax		MOV	ES, AX	        add bx,RSTCBLoc    ;Get Index to TCB	        Call    CommSetUp		Call    SendPacketsRS232Loop1:	CALL ESetReg ;Get Index to TCB	        TEST [bx].EActiveDevices,E0Task		jnz  RS232Loop		terminate:	Call    StopALL	        CALL ESetReg ;Get Index to TCB	        xor [bx].EActiveDevices,E2Taskterminate1:     CALL E2StackRet 	        JMP terminate1						CommSetUp:      mov	[bx].RsFault,0		Mov	Ax,DataTxAWriteBuff		Mov	[bx].RsTxABufP,ax		Mov	Ax,DataTxBWriteBuff		Mov	[bx].RsTxBBufP,ax		Mov	Ax,DataRxAReadBuff		Mov	[bx].RsRxABufP,ax		Mov	Ax,DataRxBReadBuff		Mov	[bx].RsRxBBufP,ax		Mov	[bx].RsCTxACount,0		Mov	[bx].RsCTxBCount,0		Mov	[bx].RsCRxACount,0		Mov	[bx].RsCRxBCount,0		                Ret				SendPackets:	                ;set active 		CMP    [bx].RsACount,0		JE      CkBCount		INC     [bx].RsTxABufP                Mov     AX,[bx].RsACount		Mov	[bx].RsCRxBCount,Ax		dec     ax		Mov	[bx].RsCTxACount,Ax		Mov     Al,[bx].RsDataA		OUT	Chanladata,AL		Mov	Al,RstTxEomLatch ;reset Tx latch		OUT	chanlacommand,alCkBCount:	cmp   [bx].RsBCount, 0		JE      AllActive		INC     [bx].RsTxBBufP		Mov     AX,[bx].RsBCount		Mov	[bx].RsCRxACount,Ax		dec     ax		Mov	[bx].RsCTxBCount,Ax		Mov     Al,[bx].RsDataB		OUT	Chanlbdata,AL		Mov	Al,RstTxEomLatch ;reset Tx latch		OUT	chanlbcommand,alAllActive:      CALL E2StackRet                RET		StopALL:	cli		mov	        al,ChanelReset                 out		ChanlaCommand,al                 out		ChanlbCommand,al                 or	[di].EnableIntC1C2,Rs232IntDisable		call	ExtEnableInt		;now disable interupts		sti		Ret		 				;--------------------------------------------TrackNum	DB ?;	FDC UCB FieldUCB		DW Comm1		;Comm1		DB 0			;Op codeComm2		DB 0			;Hd + Unit NumberComm3		DB 0			;CComm4		DB 0			;HComm5		DB 0			;RComm6		DB 0			;NComm7		DB 0			;EOTComm8		DB 0			;GPLComm9		DB 0			;DTL;	FDC Result FieldResult		DW fdcstatusST0		;fdcstatusST0	DB 0			;Holds ST0.fdcstatusST1	DB 0			;Holds ST1.fdcstatusST2	DB 0			;Holds ST2.fdcstatusC	DB 0			;Cylinder number (also PCN)fdcstatusH	DB 0			;Head numberfdcstatusR	DB 0			;Sector numberfdcstatusN	DB 0			;Sector length;fdcMaxSector	DB 0H			;Maximum sector numberfdcRWGapLength	DB 0H			;Holds the Read/Write gap length.CfdcTstCtl		DB 0			;FDC control reg bit imageFMapOut		DB 0FMapIn		DB 0		FDCStart:	Call    NewMap                shl  ah,1		mov   FMapOut,ah                mov   cl,4		shl  ah,cl                MOV	ES, ax		Call    NewMap                shl  ah,1                mov   FMapIn,ah		add bx,FTCBLoc    ;Get Index to TCB		MOV	[bx].fdcFault, 0			MOV	[bx].fdcRetries, 0			CMP	[bx].fdcDriveType,6	;Check for 360 KB drive type		JNE	Drive360KB		MOV	Al, 15			;Else 1 MB drive		MOV	fdcMaxSector, al		MOV	Al, 1BH		MOV	fdcRWGapLength, Al		JMP	FDCTstBrDrive360KB:	MOV	Al, 9		MOV	fdcMaxSector, Al		MOV	Al, 2AH		MOV	fdcRWGapLength, AlFDCTstBr:	TEST	[bx].fdcDataAndErrCtl,FDDnotConnected		JZ	Notst0		mov     CfdcTstCtl,0		Call     FDDnotConnectedTst		jmp     Notst01			;Notst0:	        CALL	SetFlpVectors		CALL E3StackRetNotst01:	TEST	[bx].fdcTstCtl, RecalKind ;Recalibrate test		JZ	Notst20			;		mov     CfdcTstCtl,RecalKind		CALL	RecalTstNotst20:	TEST	[bx].fdcTstCtl, FormatCyc ;Format test		JZ	Notst1					mov     CfdcTstCtl,FormatCyc		CALL	FormatTstNotst1:	        TEST	[bx].fdcTstCtl, ReadID ;ReadID test		JZ	Notst2			;		mov     CfdcTstCtl,ReadID		CALL	ReadIDTst		;Notst2:  	TEST	[bx].fdcTstCtl, WriteSector ;WritePat test		JZ	Notst4			mov     CfdcTstCtl,WriteSector		CALL	WriteSectorTstNotst4:	        TEST	[bx].fdcTstCtl, ReadSector ;ReadPat test		JZ	Notst8			mov     CfdcTstCtl,ReadSector		CALL	ReadSectorTst	Notst8:	       TEST	[bx].fdcTstCtl, WrtDelSector ;WriteDelSector test		JZ	Notst10			mov     CfdcTstCtl,WrtDelSector		CALL	WrtDlSectorTst		Notst10:	TEST	[bx].fdcTstCtl, RdDelSector ;WriteReadDelSector test		JZ	FlpNoerrorRet					mov     CfdcTstCtl,RdDelSector		CALL	RdDlSectorTstFlpNoerrorRet:    CALL ESetReg ;Get Index to TCB	       TEST [bx].EActiveDevices,E0Task	       jz  FlpNoerrorRet1	       inc [bx].E3IntCount     	       jmp  FDCStartFlpNoerrorRet1:   xor [bx].EActiveDevices,E3TaskFlpNoerrorRet2: CALL E3StackRet	       JMP FlpNoerrorRet2;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;			*  FDD Not Connected Test...  *;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;FDDMotorOn = 02000H;FDDInUse   = 01000H;             ------;	      03000H	For etch 1;Speed	    =   400H	low speed , add for etch2 only****** ;Drive	    =    10H    Drive Select 1, add for etch2 only******;Data Rate  =     8H    5 1/4", add for etch2 only******;DrivePreComp=    2H	PreComp 0, add for etch2 only******;             ------;	      0341AH	For etch 2 only******FDDnotConnectedTst:		MOV	AX,RstFDCtlr		;turn on FDC reset		CALL    ExtOffWrRstCtlReg	;		MOV	Al, [bx].fdcDriveType		CMP	Al, 4		JNZ	SetContReg12MB		MOV	AX, FDDMoterOn+FDDInUse+FDDSpeed+FDDDriveRate+FDDDrive+FDDPreCom	        JMP	ContRegEndSetContReg12MB:		MOV	AX, FDDMoterOn+FDDInUse+FDDDrive+FDDPreCom;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ContRegEnd:		Call    ExtOnWrCtlReg				CALL	SetFlpVectors		CALL	E3StackRet	;		MOV	AX, RstFDCtlr		CALL    ExtOnWrRstCtlReg		CALL	E3StackRet	;		CALL	GetInterruptStatus	;Clear FDC stack;Initialize Fdc	send a Sense Interrupt Status command which will clear the int;latch and then Specify and recalibrate			;InitializeFdc:		CALL	NoInterruptStatus; verify termination of cmd executionFDCSpeRec:	CALL	Specify			;Set up controller parameters                RET		;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ;;			~~~~~~~~~~~~~~~~~~~~~~~~~~;			*  RECALIBRATE TEST...   *;			~~~~~~~~~~~~~~~~~~~~~~~~~~;RecalTst:       Call    SetCurrentAddressRecalUnit:      CALL	Recalibrate		Call    CheckUnit		pop ax		TEST ax,MoreUnits		jnz RecalUnit		RET		;			~~~~~~~~~~~~~~~~~~~~~~~~;			*       READ ID...     *;			~~~~~~~~~~~~~~~~~~~~~~~~;;Use the Cylinder and Head presently set up;; First seek to the desired cylinderReadIDTst:	Call    SetCurrentAddressReadIDSeek:     CALL	Seek			;Do the seekReadIDHead:	CALL	ReadIDExec;	        Check for error		CALL	CheckStatus		CALL	NoInterruptStatus	;Check for proper cmd termination		Call    GetNextAddress		pop ax		TEST ax,MoreCylinders+MoreUnits		jnz ReadIDSeek		TEST ax,MoreHeads		jnz ReadIDHead		RET		; ;;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;			*     WRITE A DELETED SECTOR...   *;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;WrtDlSectorTst: Call    SetCurrentAddressWrtDlSeek:      CALL	Seek			;Do the seekWrtDlHead:	CALL	WriteOneDeletedSector	;Write a sector		CALL	CheckStatus		;go check return codes		CALL	NoInterruptStatus	;Check for proper cmd termination		Call    GetNextAddress		pop ax		TEST ax,MoreCylinders+MoreUnits		jnz WrtDlSeek		TEST ax,MoreHeads		jnz WrtDlHead		RET						RdDlSectorTst:  Call    SetCurrentAddressRdDlSeek:       CALL	Seek			;Do the seekRdDlHead:	CALL	ReadOneDeletedSector	;Read a sector		CALL	CheckStatus		;go check return codes		CALL	NoInterruptStatus	;Check for proper cmd termination		MOV	Al, fdcstatusST2	;Check for error		TEST	Al, 40H			;Check CM flag=1		JZ	RDelCnt3		;Status Error, get out		JMP	Error7			;RDelCnt3:	Call    GetNextAddress		pop ax		TEST ax,MoreCylinders+MoreUnits		jnz RdDlSeek		TEST ax,MoreHeads		jnz RdDlHead		RET		;--------------------;Error7:		MOV	al, 07h	;CMFlagResetOnSkipReadDel, error log		JMP	FdcError		;;;--------------------				;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;			*     WRITE/READ A TRACK...   *;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~WriteSectorTst: Call    SetCurrentAddressWriteSectorSeek:CALL	Seek			;Do the seekWriteSectorHead:CALL	WriteOneSector	;Write a sector		CALL	CheckStatus		;go check return codes		CALL	NoInterruptStatus	;Check for proper cmd termination		Call    GetNextAddress		pop ax		TEST ax,MoreCylinders+MoreUnits		jnz WriteSectorSeek		TEST ax,MoreHeads		jnz WriteSectorHead		RET						ReadSectorTst:  Call    SetCurrentAddressReadSectorSeek: CALL	Seek			;Do the seekReadSectorHead:	CALL	ReadOneSector	;Read a sector		CALL	CheckStatus		;go check return codes		CALL	NoInterruptStatus	;Check for proper cmd termination		Call    GetNextAddress		pop ax		TEST ax,MoreCylinders+MoreUnits		jnz ReadSectorSeek		TEST ax,MoreHeads		jnz ReadSectorHead		RET		; ;;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;			*     FORMAT DISK...   *;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;; First seek to the desired cylinderFormatTst:	Call    SetCurrentAddressFormatSeek:     CALL	Seek			;Do the seekFormatHead:	CALL	GenFormatData	                CALL	FormatOneCyc		CALL	CheckStatus		CALL	NoInterruptStatus	;Check for proper cmd termination		Call    GetNextAddress		pop ax		TEST ax,MoreCylinders+MoreUnits		jnz FormatSeek		TEST ax,MoreHeads		jnz FormatHead		RET		;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ;				SUBROUTINES;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetInterruptStatus:				;Sense interrupt Status Command		MOV	CX,5			;GetIrqStat:					MOV	Al, 08h			;load sense interrupt status command		CALL	FDCLoad			;Wait for Ready & Output cmd		CALL	FDCUnload		;Wait for Ready & Input cmd		CMP	Al, 080h		;Empty? Invalid Commad?		JE	GetInterruptStatusDone	;		MOV	fdcstatusST0,Al		;store ST0 Status		CALL	FDCUnload		;Read PCN		MOV	fdcstatusC,Al		;store PCN		Loop	GetIrqStat		;loop till done or timeout		JMP	Error4GetInterruptStatusDone:		RET;---------------------Error4:		MOV	al, 4h	;FDC Stack error log		JMP	FdcError		;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ NoInterruptStatus:				;Sense interrupt Status Command		MOV	Al, 08h			;load sense interrupt status command		CALL	FDCLoad			;Wait for Ready & Output cmd		CALL	FDCUnload		;Wait for Ready & Input cmd		CMP	Al, 080h		;Empty? Invalid Commad?		JE	NoInterruptStatusDone	;		MOV	fdcstatusST0,Al		;Clear FDC stack		CALL	FDCUnload		;Read PCN		MOV	fdcstatusC,Al		;store PCN		JMP	Error4NoInterruptStatusDone:		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FDCLoad:	CALL	RdyForOUT		;Wait for FDC to be ready		OUT	FDCDataReg, Al		;write byte from Al		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FDCUnload:	CALL	RdyForIN		;Wait for FDC to be ready		IN	Al, FDCDataReg		;Read byte into Al		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RdyForOUT:	PUSHA 		MOV 	CX, 028H		;RdyForOUTWait:	LOOP 	RdyForOUTWait			mov   cx,2 RdyForOUTloop:	IN	Al, FDCStatusReg	;Read Main Status		AND	Al, 0C0h		;Request from master to send data		CMP	Al, 080h		;wait for data request		JE	RdyForOUTDone		;ret if FDC ready		Call ESetReg	        inc [bx].E3IntCount     	        CALL E3StackRet		LOOP 	RdyForOUTloop		;loop till done or timeout		POPA		JMP 	Error5			;timeoutRdyForOUTDone:	POPA			RET		;CPU wants to send a command to FDC. Program timed out since;FDC never requested for masterError5:			MOV 	al, 05h	;Log HERE		JMP	FdcError		;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RdyForIN:	PUSHA 		MOV 	CX, 028H		RdyForINWait:	LOOP 	RdyForINWait				mov   cx,2RdyForINloop:	IN	Al, FDCStatusReg	;Read Main Status		AND	Al, 0C0h		CMP	Al, 0C0h		;wait for data request		JE	RdyForINDone		;ret if FDC ready		Call ESetReg	        inc [bx].E3IntCount     	        CALL E3StackRet		LOOP 	RdyForINloop		;loop till done or timeout		POPA		JMP 	Error8			;timeoutRdyForINDone:	POPA		RET		;CPU wants to read status from FDC. Program timed out since;FDC never acknoledged master requestError8:  	MOV	al, 08h	;FDC not sending Status, error log		JMP	FdcError		;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Specify:		MOV	Al, fdcSpecify		; specify Op code		CALL	FDCLoad		MOV	Al, StepRate+HUT	; SRT @6mS (neg) + HUT @16mS		CALL 	FDCLoad		MOV	Al, DmaMode+HLTime	; DMA mode+ HLTime @ 20mS		CALL	FDCLoad		CALL	NoInterruptStatus		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Recalibrate:		MOV	Al, 0Fh			;step out first by doing a seek		CALL	FDCLoad			;Output Head and Drive number		MOV	Al, 0			;		CALL	FDCLoad			;Output Hd & Unit number		MOV	Al, 1			;		CALL	FDCLoad			;Output cylinder number		CALL	E3StackRet		MOV	Al, 08h		;load sense interrupt status command		CALL	FDCLoad			;Wait for Ready & Output cmd		CALL	FDCUnload		;Wait for Ready & Input status		CALL	FDCUnload		;Read PCN		CALL	NoInterruptStatus	;Check for proper cmd termination		MOV	Al, fdcRecal		;Recal Op code		CALL	FDCLoad		MOV	Al, 00h			;		CALL	FDCLoad			;00= Drive Number0		CALL	E3StackRet		MOV	Al, [bx].fdcDriveType		CMP	Al, 4H		JZ	RecalCont		MOV	Al, fdcRecal		;Recal Op code		CALL	FDCLoad		MOV	Al, 00h			;		CALL	FDCLoad			;00= Drive Number0		CALL	E3StackRetRecalCont:		MOV	Al, 08h			;load sense interrupt status command		CALL	FDCLoad			;Wait for Ready & Output cmd		CALL	FDCUnload		;Wait for Ready & Input status		AND	Al, 0FCh		;		CMP	Al, 020h		;a Recalibrate was completed		JNE	Error6			;		CALL	FDCUnload		;Read PCN		CMP	Al, 0			;store PCN		JNE	Error6			;		CALL	NoInterruptStatus	;Check for proper cmd termination		CALL	SenseDriveStatus	;		TEST	Al, 10h		;check for status of Track 0 signal		JZ	Error6			;Track 0 should be 1		CALL	NoInterruptStatus	;Check for proper cmd termination		RETError6:		MOV	al, 06h	;Recalibrate error log		JMP	FdcError		;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Seek:		PUSH	AX		MOV	Al, 0Fh		CALL	FDCLoad			;Output Head and Drive number		MOV	Al, 0			;		CALL	FDCLoad			;Output Hd & Unit number		MOV	Al, [bx].fdcCCylinder ;		CALL	FDCLoad			;Output cylinder number		CALL	E3StackRet		MOV	Al, 08h		;load sense interrupt status command		CALL	FDCLoad			;Wait for Ready & Output cmd		CALL	FDCUnload		;Wait for Ready & Input Status		AND	Al, 0FCh		;		CMP	Al, 020h		;a seek was completed		JNE	Error1			;		CALL	FDCUnload		;Read PCN		CMP	Al, [bx].fdcCCylinder ;Cmp PCN		JNE	Error1			;		CALL	NoInterruptStatus	;Check for proper cmd termination		CALL	SenseDriveStatus	;		POP	AXSeekTestOk:	RET;~~~~~~~~Error1:  	MOV	Al, 01h			;Seek Error Log		JMP	FdcError;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ReadIDExec:		MOV	Al, ReadIDCmd				OR	Al, 40H			;add the density		CALL	FDCLoad			;"ReadID" command		MOV	Al, [bx].fdcCHead	;		CALL	FDCLoad			;00= Head0, Drive0;		READ ALL THE STATUS...		MOV	CX,7			;status byte count		CALL	FDCResult		;Read result field		RET				;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SenseDriveStatus:		MOV	Al, 04h			;load sense drive status command		CALL	FDCLoad			;Wait for Ready & Output cmd		MOV	Al, 0			;		CALL	FDCLoad			;Output Hd & Unit number		CALL	FDCUnload		;Wait for Ready & Input Status		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~SetCurrentAddress:MOV	Al, [bx].fdcSUnit	;		MOV	[bx].fdcCUnit, Al		;		MOV	Al, [bx].fdcSCylinder ;		MOV	[bx].fdcCCylinder, Al		;		MOV	Al, [bx].fdcSHead	;		MOV	[bx].fdcCHead, Al		;		MOV	Al, [bx].fdcSSector	;		MOV	[bx].fdcCSector, Al		;		MOV	Al, [bx].fdcSData	;		MOV	[bx].fdcCData, Al		;		Ret;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CheckStatus:		MOV	Al, fdcstatusST0	;Check for error		TEST	Al, 0C0H		;		JNZ	IOError			;Status Error, get outTestSt1:		MOV	Al, fdcstatusST1	;Check for error		TEST	Al, 0FFH		;		JNZ	IOError			;Status Error, get outTestSt2:		MOV	Al, fdcstatusST2	;Check for error		TEST	Al, 12H			;		JNZ	IOError			;Status Error, get out		TestSt3:        cmp     CfdcTstCtl,FormatCyc		JE	GoodIO		MOV	Al, fdcstatusC		;Check for error		CMP	Al, [bx].fdcCCylinder ;		JE	TestSt4			;		MOV	Al, fdcMaxSector		CMP	[bx].fdcESector,Al		JE	TestSt4			;		JMP	Error2			;Status Error, get outTestSt4:        		MOV	Al, fdcstatusH		;Check for error		CMP	Al, [bx].fdcCHead			;		JNE	Error2			;Status Error, get outTestSt5:		MOV	Al, fdcstatusN		;Check for error		CMP	Al, [bx].fdcSectorLength ;		JE	GoodIO			;return if ret codes are good	IOError:	CMP	CfdcTstCtl,ReadSector		je      Error2				;Status Error		CMP	CfdcTstCtl,RdDelSector		je      Error2		MOV	Al,[bx].fdcRetries		;go check rap sheet		INC	Al			; bump counter		CMP	AL,6			;is this the 3rd offense ?		JNZ	TstCnt3			; give up after third attempt		JMP	Error2TstCnt3:	MOV	[bx].fdcRetries,Al	;store new count		POP	AX			;get return address		SUB	AX,9			;point ret address for retry		CMP	CfdcTstCtl,FormatCyc		jne     NewRet		SUB	AX,3NewRet:		PUSH	AX			;put ret address back on stack		CALL	Recalibrate		;do a recalibrate		RET				;go do seek & retryGoodIO:		MOV	[bx].fdcRetries,0		;clear error count		RET		       		;life goes onError2:		MOV	al, 2h	;Write/ReadStatus, Error Log		JMP	FdcError		;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 		GetNextAddress:	MOV	Al, [bx].fdcCHead	;		CMP	Al, [bx].fdcEHead	;		JE	CheckCyclinder		INC [bx].fdcCHead		MOV	AX, MoreHeads	;		JMP Done				CheckCyclinder:	MOV	Al, [bx].fdcSHead	;		MOV	[bx].fdcCHead,al	;		MOV	Al, [bx].fdcCCylinder	;		CMP	Al, [bx].fdcECylinder	;		JE	CheckUnit		INC [bx].fdcCCylinder		MOV	AX, MoreCylinders	;		JMP Done		CheckUnit:	MOV	Al, [bx].fdcSCylinder	;		MOV	[bx].fdcCCylinder,al	;		MOV	Al, [bx].fdcCUnit	;		CMP	Al, [bx].fdcEUnit	;		JE	AllDone		INC [bx].fdcCUnit		MOV	AX, MoreUnits	;		JMP Done AllDone:	MOV	AX, 0 Done:		pop dx 		push ax		push dx 		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FDCResult:	PUSH	BX			;save TCB pointer		PUSH	CX		CALL	E3StackRet		POP	CX		MOV	BX,Result		;point to result fieldFDCResultLoop:		CALL	FDCUnload		;Wait for FDC to be ready		MOV	BYTE PTR [BX],Al	;put byte in result field		INC	BX			;inc pointer		LOOP	FDCResultLoop		;loop till done		POP	BX			;retrieve TCB pointer		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FDCGo:		MOV	BX,UCB			;point to control blockFDCGoLoop:		MOV	Al, BYTE PTR [BX]	;get command byte		CALL	FDCLoad			;Wait for FDC to be ready		INC	BX			;in pointer		LOOP	FDCGoLoop		;loop till done		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ;	 AX = Byte count ;	 BX = Destination Buffer SetUpDMAIn:		PUSH	AX			;save byte count		PUSH	AX			;save byte count		MOV	DX, i186DMA0LSPAddr	;Point to Lower Source Reg		MOV	AX, FDCDataReg+4	;Point to Lower Source Reg		OUT	DX, AX			;write Lower Source 		INC	DX			;Point to Upper Source Reg		INC	DX			;		XOR	AX, AX			;clear AX		OUT	DX, AX			;write Upper Source		MOV	AX,BX			;Lower Dest Reg		INC	DX			;Point to Lower Dest Reg		INC	DX			;		OUT	DX, AX			;write Lower Dest 		XOR	AX, AX		mov	Al, FMapIn					INC	DX			;Point to Upper Dest Reg		INC	DX			;		OUT	DX, AX			;write Upper Dest		POP	AX			;get byte count		INC	DX			;Point to TC reg		INC	DX			;		OUT	DX, AX			;write Terminal Count		INC	DX			;Point to control reg		INC	DX			;		MOV	AX, 0A266h		;set parms		OUT	DX, AX			;write control reg;	now set up timer 1 to gen TC for FDC 		JMP	SetupTimer;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; AX = Byte count ; BX = Source Buffer SetUpDMAOut:		PUSH	AX			;save byte count		PUSH	AX			;save byte count		MOV	AX,BX			;Lower Source		MOV	DX, i186DMA0LSPAddr	;Point to Lower Source Reg		OUT	DX, AX			;write Lower Source 		INC	DX			;Point to Upper Source Reg		INC	DX		XOR	AX, AX			;		mov	Al, FMapOut		;write Upper Source		OUT	DX, AX			;write Upper Source		INC	DX			;Point to Lower Dest Reg		INC	DX			;		MOV	AX, FDCDataReg+4	;write Lower Dest 		OUT	DX, AX			;write Lower Dest 		XOR	AX, AX			;clear AX		INC	DX			;Point to Upper Dest Reg		INC	DX			;		OUT	DX, AX			;write Upper Dest		POP	AX			;get byte count		INC	DX			;Point to TC reg		INC	DX			;		OUT	DX, AX			;write Terminal Count		INC	DX			;Point to control reg		INC	DX			;		MOV	AX, 016A6h		;set parms		OUT	DX, AX			;write control reg;	now set up timer 1 to gen TC for FDC SetupTimer:		MOV	DX, i186Timer1CountAAddr ;Point to Max Count A		POP	AX			;get byte count		OUT	DX, AX			;write byte Count		ADD	DX, 2			;Point to control reg		OUT	DX, AX			;write byte Count		ADD	DX, 2			;Point to control reg		MOV	AX, 0C007h		;set parms		OUT	DX, AX			;write control reg		XOR	AX,AX		SUB	DX,6		OUT	DX,AX		MOV	AX, AllowTmrTC	;set entmr1TC		Call    ExtOnWrCtlReg		;write control reg		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ReadOneDeletedSector:		MOV	Al, 0CH			;			jmp   ReadOneSectorPlus;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ReadOneSector:			MOV	Al, fdcReadCmd		;read commandReadOneSectorPlus:				;special read hook			PUSH	CX		OR	Al, 40H			;add the density		OR	Al, [bx].fdcSkipDeletedData ;add skip deleted sector		MOV	Comm1, Al 		;		jmp CommonTransfer		;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 				CommonTransfer:	MOV	Al, [bx].fdcCHead	;Output head and unit number		SAL	Al,2			;adjust Al		OR	Al, [bx].fdcCUnit	;add the Unit number			MOV	Comm2, Al 		;		MOV	Al, [bx].fdcCCylinder	;Output Cylinder number		MOV	Comm3, Al 		;		MOV	Al, [bx].fdcCHead	;Output Head number again		MOV	Comm4, Al 		;		MOV	Al, [bx].fdcCSector	;Output Sector number		MOV	Comm5, Al 		;		MOV	Al, [bx].fdcSectorLength ;Output Sector length		MOV	Comm6, Al                 XOR	DX, DX			;		CMP	Al, 00H			;None standard byte count		JNE	CntNotEqual128		;		MOV	Cl, 80H	;		JMP	CntDone		;CntNotEqual128:CMP	Al, 01H			;Set up for 256 byte transfer		JNE	CntNotEqual256		;		MOV	DX, 0100H		;		JMP	CntDone		;CntNotEqual256:CMP	Al, 02H			;Set up for 512 byte transfer		JNE	CntNotEqual512	;		MOV	DX, 0200H		;		JMP	CntDone		;CntNotEqual512: MOV	DX, 0400H		CntDone:        MOV	Al, fdcMaxSector	;Output Last Sector number		MOV	Comm7, Al 		;		MOV	Al, fdcRWGapLength	;Output Gap between sectors		MOV	Comm8, Al 		;		MOV	Al, 80H	                ;Output Data transfered if N=0		MOV	Comm9, Al 		;DoCntTimesSec:	MOV	Al, [bx].fdcCSector	;Output Sector number		MOV	CX, DX	CheckCnt:	CMP     AL,[bx].fdcESector		je      CntOk		ADD     CX,DX		INC     AL		JMP     CheckCntCntOk:		MOV	AX,CX			;get byte count		PUSH	BX		CMP     CfdcTstCtl,WriteSector		je      DoOut		CMP     CfdcTstCtl,WrtDelSector		je      DoOut		MOV	BX,fdcDataBuff		;pointer to data buffer		CALL	SetUpDMAIn		;set up DMA for inbound data		jmp     CommonEndDoOut:	        MOV	BX,fdcDataBuff		;pointer to data buffer		CALL	SetUpDMAOut	;set up DMA for outbound dataCommonEnd:	MOV	CX,9			;command byte count		CALL	FDCGo			;start FDC		POP	BX			;;		READ ALL THE STATUS...		MOV	CX,7			;status byte count		CALL	FDCResult		;Read result field		POP	CX		RET ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ WriteOneDeletedSector:		MOV	Al, 09h			;			jmp   WriteOneSectorPlus;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ WriteOneSector:		MOV	Al, 05h			;Output Write CommandWriteOneSectorPlus:		PUSH	CX		PUSH	AX		CALL	SenseDriveStatus	;		TEST	Al, 40h			;check for Write protection signal		JZ	WrtOneS1		;No write protection, continue		JMP	Error9			;WrtOneS1:       POP	AX		OR	Al, 40H			;add the density		MOV	Comm1,Al	;move command byte to control block		jmp CommonTransfer;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Error9:		mov	al, 09h	;Floppy disk write protected, error log		JMP	FdcError		;		;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FormatOneCyc:   CALL	SenseDriveStatus	;		TEST	Al, 40h		;check for Write protection signal		JZ	FtOneS1		;No write protection, continue		JMP	Error9			;FtOneS1:	MOV	Al, 4Dh		;Output Format Command		MOV	Comm1,Al	;move command byte to control block		MOV	Al, [bx].fdcCHead ;Output head and unit number		SAL	Al,2			;adjust Al		OR	Al, [bx].fdcCUnit	;add the Unit number			MOV	Comm2,Al	;move command byte to control block		MOV	Al, [bx].fdcSectorLength ;Output Sector length			MOV	Comm3,Al	;move command byte to control block		MOV	Al, fdcMaxSector ;09H= IBM Output Sector Count		MOV	Comm4,Al	;move command byte to control block		MOV	Al, 050H		;50H= IBM Output gap length		MOV	Comm5,Al	;move command byte to control block		MOV	Al, 0F6H		;Output Data filler byte		MOV	Comm6,Al	;move command byte to control block;	Set up for DMA transfers count		XOR	CX, CX			;		MOV	Cl, fdcMaxSector	;		SAL	CX,2			MOV	AX,CX			;get byte count		PUSH	BX			;save TCB pointer		MOV	BX,fdcDataBuff		;pointer to data buffer		CALL	SetUpDMAOut		;set up DMA for outbound data		MOV	CX,6			;command byte count		CALL	FDCGo			;start FDC		POP	BX			;return TCB pointer;		READ ALL THE STATUS...		MOV	CX,7			;status byte count		CALL	FDCResult		;Read result field		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GenFormatData:		PUSH	BX		MOV	dl, [bx].fdcCCylinder	;Output the cylinder number		MOV	dh, [bx].fdcCHead	;Output the Head number		MOV	cl, fdcMinSector		MOV	ch, [bx].fdcSectorLength ;		MOV	BX, fdcDataBuff		;FormatDataLoop:	MOV	ES:[BX], dl 		;		INC	BX			;		MOV	ES:[BX], dh 		;		INC	BX			;		MOV	ES:[BX], cl 		;		INC	BX			;		MOV	ES:[BX], ch 		;		INC	BX			;		CMP	Cl, fdcMaxSector	;		JE	TestDRQ4TC		;		INC	Cl			;Increment the sector number		JMP	FormatDataLoop		;TestDRQ4TC:	POP	BX			;		RET ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FdcError:	CALL ESetReg ;Get Index to TCB	        add bx,FTCBLoc    ;Get Index to TCB                mov	[bx].fdcFault, Al	;		or	[di].MesaFault, E3Task	;		MOV	Al, fdcstatusST0	;		MOV	[bx].fdcST0, Al		;		MOV	Al, fdcstatusST1	;		MOV	[bx].fdcST1, Al		;		MOV	Al, fdcstatusST2	;		MOV	[bx].fdcST2, Al		CALL ESetReg ;Get Index to TCB	        xor [bx].EActiveDevices,E3TaskFdcError1:	CALL E3StackRet                JMP FdcError1						;----------------------------------------------------------------------;Daisy Host NumberHostNumWd1	DW	0	;Host Number Word 1HostNumWd2	DW	0ABCDH	;Host Number Word 2HostNumWd3	DW	2	;Host Number Word 3;Broadcasting Host NumberTargHostNumWd1	DW	0FFFFH	;Target Host Number Word 1TargHostNumWd2	DW	0FFFFH	;Target Host Number Word 2TargHostNumWd3	DW	0FFFFH	;Target Host Number Word 3;Test OptionsEIntrCount	DB	?	;ENet Interrupt countENetRst		DB	?NTestSize	DW	?	;in bytesOddByteNum	DW	?WXPointer	DW	?NXPointer	DW	?CkPointer	DW	?PRPointer	DW	?StopSeqNum	DW	?LoopBackType	DW	0	;1:Controller(Int), 2:Interface(Ext), 3:Wire(Ext) BytesLoopbk	DW	?;Packet HeaderPktHeader	DW	16 DUP (?)		EMapOut		DW 0EMapIn		DW 0						;--------------------------------------------;      C  O  D  EEtherStart:	Call    NewMap        shl  ah,1	or  ah,0F0H	XCHG AH,AL	mov   EMapOut,ax        Call    NewMap        shl  ah,1        or  ah,0F0H	XCHG AH,AL	mov   EMapIn,ax	add bx,ETCBLoc 	;Get Index to Test Control Block	MOV	Al, [bx].ENetTstCtl;	MOV	TstCtl, Al			MOV	Al, [bx].ENetTstType		MOV	TstType, Al			MOV	Ax, [bx].ENetPacketSize		MOV	BytesLoopbk, Ax	CALL	Seti586IntVectors ;Establish interrupt vector for Ethernet	CALL	SetUpISCP	;Setup ISCPEnetTstStart:	CALL ESetReg ;Get Index to TCB	add bx,ETCBLoc 	;Get Index to Test Control Block	MOV	[bx].ENetFault, 0	;Clear fault 	MOV	[bx].ENetIntCount, 0	;Clear the Interrupt count	MOV	EIntrCount, 0		;	MOV	ENetRst, 0			INC	EIntrCount	mov ECRetryCount,1	CALL	ResetChip	;Reset Chip and cause it to read ISCP	CALL	ResetChip1	CALL	SetUpDefaults	;Setup default options	CALL	SetUpCBLs	;Setup CBL, RFA, TBD, FBL	Call InterrupCheckIntCountOK1:	CALL	BasicCheck	;verify chip's basic functions	EthNoerrorRet: CALL ESetReg ;Get Index to TCB	       TEST [bx].EActiveDevices,E0Task	       jz  EthNoerrorRet1	       Call    NewMap		shl  ah,1		or  ah,0F0H		XCHG AH,AL		mov   EMapOut,ax     	  	Call    NewMap    	  	shl  ah,1    	  	or  ah,0F0H		XCHG AH,AL		mov   EMapIn,ax		add bx,ETCBLoc 	;Get Index to Test Control Block    	       jmp  IntCountOK1EthNoerrorRet1: xor [bx].EActiveDevices,E1TaskEthNoerrorRet2: CALL E1StackRet	       JMP EthNoerrorRet2;-------------------------------------------------------------------InterrupCheck:TEST EIntrCount, 0	;check if proper number of interrupts	      JNZ   InterrupErr	      ret	InterrupErr:  MOV	Al, 01H				;Something is wrong	      JMP	ENetError;-------------------------------------------------------------------;  SUBROUTINE :  SetUpISCPSetUpISCP:	CLI	MOV AX,0        MOV  DS,AX	MOV	BX, ISCPBase	;	MOV	AX, InitChip	;	MOV	[BX], AX	;set busy flag in ISCP	MOV	BX, ISCPBase+2	;	MOV	AX, SCBOffset	;set SCBOffset in ISCP	MOV	[BX], AX		MOV	BX, ISCPBase+4	;	MOV	AX, CS		MOV  cl,4	shl ax,cl	MOV	[BX], AX	;set SCBBase in ISCP	MOV	BX, ISCPBase+6	;	MOV	AX, SCBBaseHigh	;	MOV	[BX], AX	;set SCBBase in ISCP	MOV  AX,CS	MOV  DS,AX	STI	RET	;-------------------------------------------------------------------;  SUBROUTINE :  SetUpDefaultsSetUpDefaults:		MOV	NTestSize, 32H	MOV	OddByteNum, 16	;was working with 8	MOV	WXPointer, OFFSET CmdBuf1	MOV	NXPointer, OFFSET CmdBuf1	MOV	CkPointer, OFFSET CmdBuf1	MOV	PRPointer, OFFSET RFD1	MOV	StopSeqNum, 0	;0: Don't Stop; Stop on NonZero value	CALL	SetupHeader	RET;-------------------------------------------------------------------;  SUBROUTINE :  SetUpCBLsSetUpCBLs:		CALL	SetupXmit	CALL	SetupRcv	RET		;End of SetupEcho;-------------------------------------------------------------------SetupXmit:	MOV	CmdBuf1 + 4, OFFSET CmdBuf1	;	MOV	CmdBuf1 + 6, OFFSET TBD12		;	MOV	BX, TargHostNumWd1	;Dest Add	MOV	CmdBuf1 + 8, BX		;Dest Add	MOV	CmdBuf4 + 8, BX		;Dest Add	MOV	BX, TargHostNumWd2	;	MOV	CmdBuf1 + 0AH, BX	;	MOV	CmdBuf4 + 0AH, BX	;SetTarg:	MOV	BX, TargHostNumWd3	;	MOV	CmdBuf1 + 0CH, BX	;	MOV	CmdBuf4 + 0CH, BX	;	MOV	CmdBuf1 + 0EH, 06H	;Packet TypeLink3to4:	MOV	CmdBuf4 + 4, OFFSET CmdBuf4	;	MOV	CmdBuf4 + 6, OFFSET TBD42	;	MOV	CmdBuf4 + 0EH, 06H	;Packet TypeTBD1Size:	MOV	BX, NTestSize		;	SUB	BX, OddByteNum		;	OR	BX, 8000H		;TBD2Size:		MOV 	TBD12, BX		;	MOV	TBD42, BX		;	MOV	TBD12 + 6, 0F0H		;forced top four bits to 0FH	MOV	TBD12 + 4, OFFSET XmitBuf12	MOV AX,EMapOut		;	MOV	TBD42 + 6, AX		;forced top four bits to 0FH	MOV	TBD42 + 4, OFFSET XmitBuf42	;use 24 bits address	RET				;End of SetupXmitSetupRcv:	MOV	RFD1, 0			;reset status bits	MOV	RFD1 + 2, 0		;reset control bits	MOV	RFD4, 0			;reset status bits	MOV	RFD4 + 2, 0		;reset control bits	MOV	RFD1 + 4, OFFSET RFD1	;link to RFD2	MOV	RFD4 + 4, OFFSET RFD4	;link to RFD1	MOV	RFD1 + 6, OFFSET RBD12	;	MOV	RFD4 + 6, OFFSET RBD42	;InitCnt:	MOV	RBD12, 0		;reset actual count	MOV	RBD42, 0		;reset actual countLinkNext:	MOV	RBD12 + 2, OFFSET RBD12	;link to next RBD	MOV	RBD42 + 2, OFFSET RBD42	;link to next RBDShortAdd:	MOV	RBD12 + 6, 0F0H		;forced top four bits to 0FH	MOV AX,EMapIn		;	MOV	RBD42 + 6, AX		;forced top four bits to 0FHRBAdd:		MOV	RBD12 + 4, OFFSET RB12	;use 24 bits address	MOV	RBD42 + 4, OFFSET RB42	;use 24 bits addressRBDTwos:	MOV	BX, RecBufSize		;	SUB	BX, OddByteNum		;	MOV	RBD12 + 8, BX		;	MOV	RBD42 + 8, BX		;	RET				;End of SetupRcv ;-------------------------------------------------------------------;  SUBROUTINE :  SetupHeaderSetupHeader:		MOV	PktHeader, 0FFFFH	;CheckSum	MOV	PktHeader + 2, 8201H	;Length	MOV	PktHeader + 4, 0200H	;Echo	MOV	PktHeader + 6, 0	;NetNum	MOV	PktHeader + 8, 0	;NetNum	MOV	BX, TargHostNumWd1	;DestAdd	MOV	PktHeader + 0AH, BX	;DestAdd	MOV	BX, TargHostNumWd2	;DestAdd	MOV	PktHeader + 0CH, BX	;DestAdd	MOV	BX, TargHostNumWd3	;DestAdd	MOV	PktHeader + 0EH, BX	;DestAdd	MOV	PktHeader + 10H, 200H	;SocketNumSourceNet:		MOV	PktHeader + 12H, 0	;NetNum	MOV	PktHeader + 14H, 0	;NetNum	MOV	BX, HostNumWd1		;SourceAdd	MOV	PktHeader + 16H, BX	;SourceAdd	MOV	BX, HostNumWd2		;SourceAdd	MOV	PktHeader + 18H, BX	;SourceAdd	MOV	BX, HostNumWd3		;SourceAdd	MOV	PktHeader + 1AH, BX	;SourceAdd	MOV	PktHeader + 1CH, 800H	;SocketNum	MOV	PktHeader + 1EH, 100H	;EchoReq	RET				;;-------------------------------------------------------------------;  SUBROUTINE :  ResetChip1 ResetChip1:	CALL    E1StackRet	CLI	MOV AX,0        MOV  DS,AX        MOV	BX, ISCPBase	CMP	WORD PTR[BX], 0	JNZ	ResetHalt 	MOV  AX,CS	MOV  DS,AX	STIResetOK:	MOV	SCBStat, 0		;reset status bits	MOV	SCBComm, AckCXCNA	;acknowledge the RU-interrupt Nop	OUT	ENetAttn, AX		;ENet Channel Attention	RET	ResetHalt:MOV  AX,CS	MOV  DS,AX	STI	MOV  AX,CS	MOV  DS,AX	MOV	Al, 3		;no reset error code	jmp	ENetError ;-------------------------------------------------------------------;  SUBROUTINE :  BasicCheck BasicCheck:MOV	ExitPointer, SP		;Store TOP of Stack For retrys	CMP	TstType, 00H		;IA Setup	JLE	Tst0			;	JMP	NxtTst1	Tst0:	MOV	Al, [bx].ENetRetryCount	mov ECRetryCount,al	mov SaveRet,OFFSET Tst0ETst0E:  		CALL	StartChip		;	Call InterrupCheck	CMP	TstCtl, 0		;perform one test only?	JNE	NxtTst1			;	RETNxtTst1:		CMP	TstType, 01H		;Configure Cmd, Dump Cmd	JLE	Tst1			;	JMP	NxtTst2	Tst1:	MOV	Al, [bx].ENetRetryCount	mov ECRetryCount,al	mov SaveRet,OFFSET Tst1E	Tst1E: 		CALL	ClearDumpBuf	CALL	ExDump	CALL	VerifyDump	Call InterrupCheck	CMP	TstCtl, 0		;perform one test only?	JNE	NxtTst2			;	RETNxtTst2:	CMP	TstType, 02H		;Transmit with Receive	JLE	Tst2			;	JMP	NxtTst3	Tst2:	MOV	Al, [bx].ENetRetryCount	mov ECRetryCount,al	mov SaveRet,OFFSET Tst2E		Tst2E:		CALL	SetupLBuf	CALL	LoopBackCont		;indicate loopback from controller	CALL	CheckXmit	CALL	CheckReciever	CMP	TstCtl, 0		;perform one test only?	JNE	NxtTst3			;	RETNxtTst3:	CMP	TstType, 03H		;Transmit without Receive	JLE	Tst3		JMP	NxtTst4	Tst3:	MOV	Al, [bx].ENetRetryCount	mov ECRetryCount,al	mov SaveRet,OFFSET Tst3E		Tst3E:		CALL	SetupLBuf	MOV	CmdBuf4 + 8, 0F0F0H	;des address 1	MOV	CmdBuf4 + 0AH, 0F0F0H	;des address 2	MOV	CmdBuf4 + 0BH, 0F0F0H	;des address 3	CALL	LoopBackCont		;indicate loopback from controller	CALL	CheckXmit	CMP	TstCtl, 0		;perform one test only?	JNE	NxtTst5			;	RET	NxtTst4:	CMP	TstType, 04H		;Transmit with Receive	JLE	Tst4			;	JMP	NxtTst5	Tst4:	MOV	Al, [bx].ENetRetryCount	mov ECRetryCount,al	mov SaveRet,OFFSET Tst4E	Tst4E:	CALL	SetupLBuf	CALL	LoopBackIntf		;indicate loopback from Interface	CALL	CheckXmit	CALL	CheckReciever	CMP	TstCtl, 0		;perform one test only?	JNE	NxtTst5			;	RETNxtTst5:	CMP	TstType, 05H		;Transmit without Receive	JLE	Tst5		JMP	NxtTst6	Tst5:			MOV	Al, [bx].ENetRetryCount	mov ECRetryCount,al	mov SaveRet,OFFSET Tst5ETst5E:	CALL	SetupLBuf	MOV	CmdBuf4 + 8, 0F0F0H	;des address 1	MOV	CmdBuf4 + 0AH, 0F0F0H	;des address 2	MOV	CmdBuf4 + 0BH, 0F0F0H	;des address 3	CALL	LoopBackIntf		;indicate loopback from Interface	CALL	CheckXmit	CMP	TstCtl, 0		;perform one test only?	JNE	NxtTst6			;	RETNxtTst6:	CMP	TstType, 06H		;Transmit with Receive	JLE	Tst6			;	JMP	NxtTst7	Tst6:	MOV	Al, [bx].ENetRetryCount	mov ECRetryCount,al	mov SaveRet,OFFSET Tst6ETst6E:	CALL	SetupLBuf	CALL	LoopBackWire		;	CALL	CheckXmit	CALL	CheckReciever	CMP	TstCtl, 0		;perform one test only?	JNE	NxtTst7			;	RETNxtTst7:	CMP	TstType, 07H		;Transmit without Receive	JLE	Tst7		JMP	NxtTst8Tst7:		MOV	Al, [bx].ENetRetryCount	mov ECRetryCount,al	mov SaveRet,OFFSET Tst7ETst7E:  CALL	SetupLBuf	MOV	CmdBuf4 + 8, 0F0F0H	;des address 1	MOV	CmdBuf4 + 0AH, 0F0F0H	;des address 2	MOV	CmdBuf4 + 0BH, 0F0F0H	;des address 3	CALL	LoopBackWire	CALL	CheckXmit	CMP	TstCtl, 0		;perform one test only?	JNE	NxtTst8			;	RET	NxtTst8:		MOV	Al, [bx].ENetRetryCount	mov ECRetryCount,al	mov SaveRet,OFFSET NxtTst8E	NxtTst8E:CALL	DiagnoseTst		;Diagnose test	Call InterrupCheck	RET;-------------------------------------------------------------------;  SUBROUTINE :  ClearDumpBuf ClearDumpBuf:	PUSH	SI 	MOV	CX, 060H		;Setup loop counter, 96 words	XOR	SI, SI			;Zero the index	MOV	BX, 09ABCH		;anything unusalClrDBuf:	MOV	RB12[SI], BX		;	ADD	SI, 2			;	LOOP	ClrDBuf			;	Call ESetReg        inc [bx].E1IntCount     	CALL E1StackRet	add bx,ETCBLoc 	;Get Index to Test Control Block	POP	SI	RET;-------------------------------------------------------------------;  SUBROUTINE :  ExDump ExDump:; For reason unknown, chip will not execute dump command, so added a config before it	MOV	AX, 0			;no interrupt	MOV	ConfigCmd, AX		;reset status	MOV	AL, CmdConfig		;form Cmd	MOV	ConfigCmd + 2, AX	;	MOV	ConfigCmd + 4, OFFSET CmdBuf4	;chain the commands	MOV	ByteCnt, 4		;only modifying LoopbkAT; added for testing, will decide later if to remove the above; for unknown reason must use Interrupt bit to get CU completion bit	MOV	AH, ELIntr		;EndList, Interrupt	MOV	AL, CmdDump		;form Cmd	MOV	CmdBuf4 + 2, AX		;	MOV	AX, 0			;no interrupt	MOV	CmdBuf4, AX		;reset status	MOV	CmdBuf4 + 4, AX		;no Cmd chainning	MOV	CmdBuf4 + 6, OFFSET RB12 	;pointed to Dump Buffer	MOV	SCBComm, StartCU	;StartCU, clear the Reset bit	MOV	RFAOffset, OFFSET RFD1	;dump requires RFD	MOV	CBLOffset, OFFSET ConfigCmd	;link to a Cmd	CALL	ExCmd	RET;-------------------------------------------------------------------;  SUBROUTINE :  ExCmd ExCmd:	INC	EIntrCount	;	OUT	ENetAttn, AX	;ENet Channel Attention	CALL E1StackRet		CkStatus:	MOV	AX, SCBStat	;get status word	AND	AX, 0A000H	;look at CU completion bit	CMP	AX, 0A000H	JE	CmdExed		;CU has executed OK	MOV	Al, 4		; CU Error	jmp	ENetError		CmdExed:	MOV	SCBStat, 0	;reset status bits	MOV	AX, AckCXCNA	;	OR	AX, AckFR	MOV	SCBComm, AX	;acknowledge the CU and  RU interrupt Nop	OUT	ENetAttn, AX	;ENet Channel Attention	RET ;-------------------------------------------------------------------;  SUBROUTINE :  VerifyDump VerifyDump:	MOV	BX, RB12	Test    BX, 0FH		;check if 586 write into this location	JZ	DumpStarted	JMP	DumpHaltDumpStarted:	MOV	AX, BX	AND	AX, 0F00H	;get FIFO limit	MOV	DX, 0	MOV	DH, FifoLim	SUB	AX, DX	JZ	FIFOGood	JMP	DumpHaltFIFOGood:	MOV	BX, RB12 + 2	MOV	AL, SaveBadF	MOV	AH, LoopbkAT	XOR	AX, BX	JZ	LpBkATGood	JMP	DumpHaltLpBkATGood:	MOV	BX, RB12 + 4	MOV	AL, BackOff	MOV	AH, IntFrameSp	XOR	AX, BX	JZ	IntrFrameGood	JMP	DumpHaltIntrFrameGood:	MOV	AX, RB12 + 6	XOR	AX, RetrySlot	JZ	RetrySlotGood	JMP	DumpHaltRetrySlotGood:	MOV	BX, RB12 + 8	MOV	AL, CRCPromis	MOV	AH, CollCarr	XOR	AX, BX	JZ	CollCRCGood	JMP	DumpHaltCollCRCGood:	MOV	AX, RB12 + 0AH	XOR	AX, MinFrameLen	JZ	IAddr1Good	JMP	DumpHaltIAddr1Good:	MOV	AX, RB12 + 0CH	AND	AX, 0FFF7H	XOR	AX, 0FFF7H	;IA  Least Significant Word	JZ	IAddr2Good	JMP	DumpHaltIAddr2Good:	MOV	AX, RB12 + 0EH	XOR	AX, 0FFFFH	;IA  middle Word	JZ	IAddr3Good	JMP	DumpHaltIAddr3Good:	MOV	AX, RB12 + 010H	XOR	AX, 0FFFFH	;IA  Most Significant Word	JZ	MinFrameGood	JMP	DumpHaltMinFrameGood:	RETDumpHalt:	MOV	Al, 05H		;Dump verify test error code	jmp	ENetError	;-------------------------------------------------------------------;  SUBROUTINE :  LoopBackCont LoopBackCont: 	MOV	LoopBackType, 1		;indicate loopback from controller	OR	LoopbkAT, 40H	;set Internal LoopBack, funny no AT-loc bit	CALL	LoopBack	RET;-------------------------------------------------------------------;  SUBROUTINE :  LoopBackIntf LoopBackIntf: 	MOV	LoopBackType, 2		;indicate loopback from Interface			MOV	AX, ENetLpBk		;	CALL	ExtOnWrRstCtlReg	;loopback from 501 chip		MOV	Al, 0BFH		;Save bad frames	MOV	SaveBadF, Al		;Save bad frames	MOV	Al, 3FH			;	AND	LoopbkAT, Al		;	OR	LoopbkAT, 80H	;set External LoopBack, funny no AT-loc bit	CALL	LoopBack		MOV	AX, ENetLpBk		;	CALL	ExtOffWrRstCtlReg	;back to normal	MOV	Al, 03FH		;Don't Save bad frames	MOV	SaveBadF, Al		;Save bad frames	RET;-------------------------------------------------------------------;  SUBROUTINE :  LoopBackWire LoopBackWire: 	MOV	LoopBackType, 3		;indicate loopback from Wire	MOV	Al, 0BFH		;Save bad frames	MOV	SaveBadF, Al		;Save bad frames	MOV	Al, 3FH			;	AND	LoopbkAT, Al		;	OR	LoopbkAT, 80H	;set External LoopBack, funny no AT-loc bit	CALL	LoopBack	MOV	Al, 03FH		;Don't Save bad frames	MOV	SaveBadF, Al		;Save bad frames	RET;-------------------------------------------------------------------;  SUBROUTINE :  LoopBack LoopBack: ; starting Receiving Unit; for unknown reason must use Interrupt bit to get CU completion bit	MOV	ByteCnt, 4		;only modifying LoopbkAT	MOV	RFD4, 0			;reset status bits	MOV	RFD4 + 2, 0		;reset control bits	MOV	RFD4 + 4, OFFSET RFD4	;link to other will not do anything	MOV	RFD4 + 6, OFFSET RBD42	;loopback receiving buffer	MOV AX,EMapIn	MOV	RBD42 + 6, AX		;top 4 bits address all one's	MOV	RBD42 + 4, OFFSET RB42	;use 24 bits address	MOV	AX, BytesLoopbk	MOV	RBD42 + 8, AX		;RB42 can hold 256 bytes	MOV	SCBComm, StartRU	;Start RU	MOV	RFAOffset, OFFSET RFD4	;	OUT	ENetAttn, AX		;ENet Channel Attention	Waiting:PUSHA 	CALL ESetReg ;Get Index to TCB	inc [bx].E1IntCount	CALL E1StackRet	POPA	MOV	AX, SCBStat		;get status word	AND	AX, 040H		;look at RU ready bit	CMP	AX, 040H		JE	ExLoopBack		;RU is ready	JMP	Waiting			;;; so it is configured to do LoopBack; for unknown reason must use Interrupt bit to get CU completion bitExLoopBack:	MOV	AH, 0			;No Interrupt	MOV	AL, CmdConfig		;form Config Cmd	MOV	ConfigCmd + 2, AX	;	MOV	ConfigCmd + 4, OFFSET CmdBuf4	;next Command is Xmit	MOV	AH, ELIntr		;EndList, Interrupt	MOV	AL, CmdXmit		;form Xmit Cmd	MOV	CmdBuf4 + 2, AX		;	MOV	CmdBuf4 + 4, 0FFFFH	;no Cmd chainning	MOV	AX, BytesLoopbk		;get the number of bytes to be loopbacked	OR	AX, 8000H	        ;indicate last buffer	MOV	TBD42, AX		;	MOV AX,EMapOut	MOV	TBD42 + 6, AX		;forced top four bits to 0FH	MOV	TBD42 + 4, OFFSET XmitBuf42	;use 24 bits address	MOV	SCBComm, StartCU	;Start CU, clear the Reset bit	MOV	CBLOffset, OFFSET ConfigCmd	;link to a Cmd	CALL	ExCmd	Call InterrupCheck	RET;-------------------------------------------------------------------CheckXmit:	MOV	Ax, TBD42	xor     ax,BytesLoopbk		cmp     ax,08000H	je      CheckXmitRet			MOV	Al, 8	;xmit  error code	jmp	ENetErrorCheckXmitRet:	RET;-------------------------------------------------------------------CheckReciever:	MOV	Ax, RBD42	xor     ax,BytesLoopbk		cmp     ax,0C000H	je      CheckRecieverRet			MOV	Al, 9	;xmit  error code	jmp	ENetErrorCheckRecieverRet:	RET;-------------------------------------------------------------------;  SUBROUTINE :  StartChip StartChip: 	MOV	AX, 0			;no interrupt	MOV	SetupIACmd, AX		;reset status	MOV	AH, ELIntr		;EndList, Interrupt	MOV	AL, CmdAddSetup		;form Cmd	MOV	SetupIACmd + 2, AX	;	MOV	SetupIACmd + 4, 0	;no Cmd chainning	MOV	SetupIACmd + 6, 0FFFFH;Individual Address	MOV	SetupIACmd + 8, 0FFFFH	;	MOV	SetupIACmd + 0AH, 0FFFFH ;	MOV	SCBComm, StartCU	;StartCU, clear the Reset bit	MOV	RFAOffset, OFFSET RFD1	;dump requires RFD	MOV	CBLOffset, OFFSET SetupIACmd ;link to a Cmd	CALL	ExCmdFinishStartChip:	RET;-------------------------------------------------------------------;  SUBROUTINE :  SetupLBuf ; started with 0, +1 per byteSetupLBuf:		MOV	CmdBuf4 + 6, OFFSET TBD42	;	MOV	TBD42 + 2, 0FFFH	;no next TBD	MOV	TBD42 + 4, OFFSET XmitBuf42	MOV AX,EMapOut	;	MOV	TBD42 + 6, AX		;forced top 4 bits all one's	MOV	AX, 0FFFFH	MOV	CmdBuf4 + 8, AX		;broadcasting	MOV	CmdBuf4 + 0AH, AX	;	MOV	CmdBuf4 + 0CH, AX	;	RET;-------------------------------------------------------------------;  SUBROUTINE :  DiagnoseTst DiagnoseTst: 	MOV	AX, 0			;no interrupt	MOV	CmdBuf4, AX		;reset status	MOV	AH, ELIntr		;EndList, Interrupt	MOV	AL, CmdDiag		;form Cmd	MOV	CmdBuf4 + 2, AX		;	MOV	CmdBuf4 + 4, 0		;no Cmd chainning	MOV	SCBComm, StartCU	;StartCU, clear the Reset bit	MOV	RFAOffset, OFFSET RFD1	;	MOV	CBLOffset, OFFSET CmdBuf4	;link to a Cmd	CALL	ExCmd	RET;------------------------------------------------------------ENetError:CALL ESetReg ;Get Index to TCB	  mov cl,al	  MOV	SCBStat, 0	;reset status bits	  MOV	AX, AckCXCNA	;	  OR	AX, AckFR	  MOV	SCBComm, AX	;acknowledge the CU and  RU interrupt Nop	  OUT	ENetAttn, AX	;ENet Channel Attention	  dec ECRetryCount	  jz ENetErrorRet	  MOV	SP, ExitPointer		;Restore stack pointer	  mov ax,SaveRet	  push ax	  ret	  ENetErrorRet:xor [bx].EActiveDevices,E1Task	  add bx,ETCBLoc    ;Get Index to TCB          OR	[bx].ENetFault, Al	;	  or	[di].MesaFault,E1Task	;ENetErrorRet1:CALL E1StackRet          JMP ENetErrorRet1	  	PCEStart:CALL E4StackRet         JMP PCEStart	RDCStart:CALL E5StackRet         JMP RDCStart	 DataTxAWriteBuff	DW StartTxAData	DataRxBReadBuff		DW StartRxBData	DataTxBWriteBuff	DW StartTxBData	DataRxAReadBuff		DW StartRxAData	fdcDataBuff	DW StartFData	 ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 		ORG TestCodeLoc3XmitBuf12	DW	 200H DUP (?)		ORG TestCodeLoc3+200HRB12		DW	 200H DUP (?)				ORG TestCodeLoc3+200H+200H		StartTxAData	DB 1000H DUP (?)   ;TxA write data buffer		ORG TestCodeLoc3+200H+200HStartRxBData	DB 1000H DUP (?)   ;RxB Read data buffer		ORG TestCodeLoc3+200H+200HStartTxBData	DB 1000H DUP (?)   ;TxB write data buffer		ORG TestCodeLoc3+200H+200HStartRxAData	DB 1000H DUP (?)   ;RxA Read data buffer		ORG TestCodeLoc3+1000H+200H+200HXmitBuf42	DW	 400H DUP (?)		ORG TestCodeLoc3+1000H+200H+200HRB42		DW	 400H DUP (?)		ORG TestCodeLoc3+1000H+200H+200H+400HStartFData	DB 400H*15 DUP (?)  ;Floppy Disk write data buffer (=1024 Bytes max/Sector)      MonitorCode	ENDS	END 
{File name:  moonmemsun.mc}{This test Stores and Checks Main Memory as directed by a Send Memory Test Control Block (sended by the IOP) located at RMTCBloc as defined in MOONMEMSUN.DF.  This test returns results by placing a Receive Memory Test Control Block again at this location and signalling the IOP that results are available.  This test assumes the Mesa Processor hardware and the SMTCB words of memory are funtional.}{****  AFTER AN IOP INTERRUPT AND GETTING AN SMTCB WITH THE RECOGNITION PATTERN 8EE8, WE SMASH (ZERO) THE RECOGNITION PATTERN AND RUN THE TEST UNTIL:* DONE - send Interrupt to IOP and Wait for IOP Interrupt.* AN ERROR AND ERROR CONTROL = STOP ON ERROR - same as DONE.* AN IOP INTERRUPT AND THE SMTCB RECOGNITION PATTERN IS STILL SMASHED - set RMTCB (including our recognition pattern) and Wait for IOP Interrupt.IF THE IOP IS RUNNING A CONCURRENT MEMORY TEST WE MAY NOT STOP.  AT THE END OF A PHASE IN SUCH A CASE WE DO EITHER:* IF THE SMTCB RECOGNITION PATTERN HAS NOT RE-APPEARED - rerun the same test.* IF THE SMTCB PATTERN IS DETECTED - set RMTCB and do the next phase if any.  ****}SetTask[0]; StartAddress[TERROR1];TERROR1:R1 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[0];        DataSP _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[1F];        DataTP _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[3F];        R1 _ R1 or DataSP,ClrIE,	c*, at[2F];        R1 _ R1 or DataTP,	c*, at[100];	        Xbus _ R1 LRot0, XwdDisp,	c*;	DISP2[TrapType],	c*;TrapType:GOTO[Trap],	c*, at[0,4,TrapType];	SetIE,GOTO[START],c*, at[1,4,TrapType];	GOTO[Trap],	c*, at[2,4,TrapType];	GOTO[Trap],	c*, at[3,4,TrapType];Trap:	  GOTO[Trap],   c*;START:	XC2npcDisp, c2;	BRANCH[BadCy, GoodCy, 0D],	c3;BadCy:	Noop,	c*, at[0D,10,GoodCy];	Noop,	c*;	GOTO[START]	c*;	GoodCy:	ClrLOCK,		c1, at[0F,10,BadCy]; {let IOP do whatever}	TrapState _ 4,		c2;	Interface _ 0,		c3; {ClrLOCK}	ClrMPIntIOP,			c1; {/// other init ???}	Noop,			c2; 	GOTO[WaitForInt],	c3, at[200];{-------------------------}WaitForInt:  {Wait for IOP interrupt to check for SMTCB}	Xbus _ IntStat, XDisp,		c1;	DISP4 [IntIn,0D],		c2;IntIn:	GOTO [WaitForInt],		c3, at [0D,10,IntIn];	ClrIntErr,CANCELBR[CheckForSmctb,0F],c3, at [0F,10,IntIn];{----------------------------------------}SendIntIOP:	SetMPIntIOP,			c1;	ClrMPIntIOP,			c2;	GOTO [WaitForInt]		c3; {Wait for IOP to give directions}{-----------------------------------------}{The SMCTB recognition pattern is 8EE8 Hex.}{The SMCTB recognition pattern is the last word in a Send Memory}{Control Block (SMCTB) to be written by the IOP and destroyed by the}{CP after reading it.}CheckForSmctb:	R3 _ SMTCBp1,		c1; {Setup recognition constant}	R3 _ R3 LRot8,			c2;	R3 _ R3 or SMTCBp2,		c3;	R0 _ MTCBlocm,			c1; {Setup address to read from}	R0 _ R0 LRot8,			c2;	R0 _ R0 or MTCBlocl,		c3; 	rhR0 _ MTCBloch,		c1;	Noop,				c2;	TrapState _ 10,		  	c3;	MAR _ [rhR0,  R0+0],		c1;	Noop,				c2;	R4 _ MD,			c3;	Noop,				c1;	[] _ R4 xor R3,ZeroBr,		c2; {0 if R4 = R3}	BRANCH [sendRMCTB, RecSmctb],	c3;	{-----------------------------------------------------------------------------}{This routine is executed if there is a RMCTB to return.}{This routine sends a Status Report to the IOP}{The RMCTB block is located in the same bank}sendRMCTB:  R3 _ LBankPage,   c1;{copy last Page used}        TrapState _ 8,   c2; {may have to be changed}	R1 _ R0,     c3; {copy address reg}        		MAR _ R0 _ [rhR0, R0 + 1],   c1; {LastBankUsed/LastPageUsed}	MDR _ R3,   CANCELBR[$, 2], LOOPHOLE[wok],   c2;	R2 _ LWord,    c3; {copy last word used}		R3 _ LDataTP,   c1;   {Last Data Type Used This Pass}	R3 _ R3 LRot8,			c2;	R3 _ R2 or R3,		c3; 		MAR _ R0 _ [rhR0, R0 + 1],   c1; {EndingDataTypeUsed/LastWordUsed}	MDR _ R3,   CANCELBR[$, 2], LOOPHOLE[wok],   c2;	R3 _  LDataSP,   c3;		MAR _ R0 _ [rhR0, R0 + 1],   c1; {DataPatternThisPass}	MDR _ R3,   CANCELBR[$, 2], LOOPHOLE[wok],   c2;	R3 _  LDataE,   c3;		MAR _ R0 _ [rhR0, R0 + 1],    c1;  {ExpectedData}	MDR _ R3,   CANCELBR[$, 2], LOOPHOLE[wok],   c2;	R3 _ LDataO,    c3;		MAR _ R0 _ [rhR0, R0 + 1],   c1; {ObservedData}	MDR _ R3,   CANCELBR[$, 2], LOOPHOLE[wok],   c2;	Q _  Fault ,   c3;		MAR _ R0 _ [rhR0, R0 + 1],   c1; {Fault}	MDR _ Q,   CANCELBR[$, 2], LOOPHOLE[wok],   c2;	Noop,   c3;		R3 _ RMTCBp1,			c1; {Setup recognition constant}	R3 _ R3 LRot8,			c2;	R3 _ R3 or RMTCBp2,		c3;	MAR _ [rhR0, R1 + 0],   c1; {Write RMCTB pattern}	MDR _ R3,   CANCELBR[$, 2], LOOPHOLE[wok],   c2;	GOTO[WaitForInt],  c3;{------------------------------------}{This routine copies a new Send Memory Control Block (SMCTB)}{into allocated registers}RecSmctb:				{move the SMCTB into my Regs}       R1 _ R0,  c1;          TrapState _ 10,   c2;       Noop,    c3;              MAR _ R0 _ [rhR0, R0 + 1],    c1;   {Interface/Passes}       DataO _ 0, CANCELBR[$,2], LOOPHOLE[wok],   c2; {clear observed-data reg.}       DR _ MD,   c3;              RF _ DR and 0FF,   c1;       Passes _ RF,   c2;   {load # of passes to run}       RF _ DR LRot8,    c3;              MAR _ R0 _ [rhR0, R0 + 1],    c1;   {BankStart/PageStart}       RF _ RF and 0FF, CANCELBR[$, 2], LOOPHOLE[wok],  c2;         DR _ MD,   c3;              Interface _ RF,   c1;      {load Interface}       RF _ DR and 0FF,  c2;       PageWordS _ RF LRot8,  c3;    {load PageStart into PageWordS (Start)}              RF _ DR LRot8,    c1;           RF _ RF and 0FF,    c2;       BankS _ RF,   c3;{load BankStart}                    MAR _ R0 _ [rhR0, R0 + 1],    c1;    {BankEnd/PageEnd}       Noop, CANCELBR[$, 2], LOOPHOLE[wok],    c2;       DR _ MD,   c3;                     RF _ DR and 0FF,  c1;           PageWordE _ RF LRot8,   c2;       RF _ DR LRot8,  c3;   {load PageEnd into PageWordE (End)}                  MAR _ R0 _ [rhR0, R0 + 1],    c1;  {WordStart/WordEnd}       RF _ RF and 0FF, CANCELBR[$, 2], LOOPHOLE[wok],  c2;           DR _ MD,   c3;              BankE _ RF,   c1;  {load BankEnd}       RF _ DR and 0FF,   c2;       PageWordE _ PageWordE or RF,  c3;  {load WordEnd into PageWordE (End)}              MAR _ R0 _ [rhR0, R0 + 1],    c1;   {MapBankStart/MapPageStart}       RF _ DR LRot8, CANCELBR[$, 2], LOOPHOLE[wok],   c2;        DR _ MD,   c3;              RF _ RF and 0FF,  c1;         PageWordS _ PageWordS or RF,   c2;{load WordStart into PageWordS (start)}       RF _ DR and 0FF,  c3;              RF _ RF LRot8,  c1;         MPageWordS _ RF,   c2;{load MapPage/Word Start}       RF _ DR LRot8,  c3;          RF _ RF and 0FF,  c1;         MBankS _ RF,   c2;{load Map Bank Start}       Noop,  c3;                            MAR _ R0 _ [rhR0, R0 + 1],    c1;  {MapBankEnd/MapPageEnd}       Noop, CANCELBR[$, 2], LOOPHOLE[wok],   c2;       DR _ MD,   c3;                     RF _ DR ,  c1;       RF _ RF LRot8,  c2;         MPageBankE _ RF,   c3;{load MapPage/Bank End}                            MAR _ R0 _ [rhR0, R0 + 1],    c1;  {StartingDataPattern}       Noop, CANCELBR[$, 2], LOOPHOLE[wok], c2;             DR _ MD,   c3;              MAR _ R0 _ [rhR0, R0 + 1],    c1;  {Starting Data Type/Test Control}       DataS _ DR,  CANCELBR[$, 2], LOOPHOLE[wok],  c2;{load Starting Data Pattern}       DR _ MD,   c3;              RF _ DR and 0FF,   c1;       TstCtrl _ RF,    c2;    {load TestControl}       RF _ DR LRot8,   c3;              RF _ RF and 0FF,   c1;       Noop,    c2;    {load StartingDataType}       Noop,   c3;             MAR _ R0 _ [rhR0, R0 + 1],   c1;  {Data Control/Mesa Processor Error Control}       DataT _ RF, CANCELBR[$, 2], LOOPHOLE[wok], c2;  {load StartingDataType}       DR _ MD,   c3;              MAR _ R0 _ [rhR0, R0 + 1],   c1;  {Delay Time Between Store & Read}       DatErrCtl _ DR, CANCELBR[$, 2], LOOPHOLE[wok] ,  c2; {load DataControl/MesaProcessorErrorControl}       DR _ MD,   c3;                            MAR _ R0 _ [rhR0, R0 + 1],   c1;  {MemSize}       Delay _ DR, CANCELBR[$, 2], LOOPHOLE[wok] ,  c2;{load Delay Time Between Store and Read}        DR _ MD,   c3;                     MAR _ R0 _ [rhR0, R0 + 1],   c1;  {MemSize1}       MemorySize _ DR, CANCELBR[$, 2], LOOPHOLE[wok] ,  c2;{load MemSize}        DR _ MD,   c3;              MemorySize1 _ DR,   c1;  {load Memsize1}       TrapState _ 8,  c2;       L3_2,     c3;       MAR _ [rhR0, R1 + 0], c1;  {Zap the SMTCB pattern}       MDR _ DataS,  c2;       DataSP _ DataS,GOTO [LogState],  c3;              Fault _ 0, c1, at [2,10,LogStateRet];       DataTP _ DataT, c2;       GOTO[RunTest],  c3;{------------------------------------}{This routine reads the test control reg. after initializing}{all the registers needed for a given test.}{This test control reg. controls the test kind to be performed}{during a test run.}RunTest:	Noop,		c1,  at[0, 10, InterFaceLockRet];	L0 _ 0,			c2;	GOTO[PhaseSetUp], c3; {initialize all reg. used for test and return}	Xbus _ TstCtrl, XDisp,	c1, at [0,10,PhaseSetUpRet];	DISP4[RunTestDisp],    c2; {one of these following tests to be performed next}RunTestDisp:  GOTO[Store],        c3,at[0,10,RunTestDisp]; {Store only}	      GOTO[RunTest1],    c3,at[1,10,RunTestDisp]; {Check only}	      GOTO[Store],        c3,at[2,10,RunTestDisp]; {Store and Check}	      GOTO[MapStore],     c3,at[3,10,RunTestDisp]; {Map Store only}	      GOTO[RunTest1],    c3,at[4,10,RunTestDisp]; {Map Check only}	      GOTO[MapStore],     c3,at[5,10,RunTestDisp]; {MapStore and MapCheck}	      GOTO[MemSizeStore], c3,at[6,10,RunTestDisp]; {Memory Size Store only}	      GOTO[RunTest1],    c3,at[7,10,RunTestDisp]; {Memory Size Check}	      GOTO[MemSizeStore], c3,at[8,10,RunTestDisp]; {Memory Size Store & Check}	      GOTO[BadTest],   c3,at[9,10,RunTestDisp];  {not used at this time}	      GOTO[BadTest],   c3,at[0A,10,RunTestDisp]; {not used at this time}	      GOTO[BadTest],   c3,at[0B,10,RunTestDisp]; {not used at this time}	      GOTO[BadTest],   c3,at[0C,10,RunTestDisp]; {not used at this time}	      GOTO[BadTest],   c3,at[0D,10,RunTestDisp]; {not used at this time}	      GOTO[BadTest],   c3,at[0E,10,RunTestDisp]; {not used at this time}	      GOTO[BadTest],   c3,at[0F,10,RunTestDisp]; {not used at this time}{---------------------------------}RunTest1:	Noop,		c1;	L0 _ 0,			c2;	GOTO [InterFaceCheck],	c3;			RunTest1X:	Noop,		c1, at [0,10,InterfaceOKret];	R3 _ Delay,		c2;DelayL:	[] _ R3 , ZeroBr,		c3;	BRANCH [$, DelDun],	c1;	R3 _ R3 - 1, GOTO[DelayL],	c2;DelDun:	L0 _ 1,			c2;	Noop,	c3;		Noop,			c1, at [1,10,InterFaceLockRet];	Noop,			c2;	GOTO[PhaseSetUp],	c3;		Xbus _ TstCtrl, XDisp,	c1, at [1,10,PhaseSetUpRet];	DISP4[RunTest1Disp] ,	c2;	RunTest1Disp: GOTO[RunTest2],	c3, at[0,10,RunTest1Disp]; {Store only}	      GOTO[Check],	c3, at[1,10,RunTest1Disp]; {Check only}	      GOTO[Check],	c3, at[2,10,RunTest1Disp]; {Store and Check}	      GOTO[RunTest2],	c3, at[3,10,RunTest1Disp]; {Map Store only}	      GOTO[MapCheck],	c3, at[4,10,RunTest1Disp]; {Map Check only}	      GOTO[MapCheck],	c3, at[5,10,RunTest1Disp]; {MapStore and MapCheck}	      GOTO[RunTest2],	c3, at[6,10,RunTest1Disp]; {MemorySize Store only}	      GOTO[MemSizeCheck], c3, at[7,10,RunTest1Disp]; {MemorySize Check only}	      GOTO[MemSizeCheck], c3, at[8,10,RunTest1Disp]; {MemorySize Store and Check}{ We want to go to next PHASE but if the "InterFace is locked" (if there is an IOP interrupt) we will go to CheckForSmctb}RunTest2:	Noop,		c1;	L0 _ 1,			c2;	GOTO [InterFaceCheck],	c3;      DecPassCount: R3_DatErrCtl,		c1, at[1,10,InterfaceOKret];              [] _ R3 and 2, ZeroBr,	c2; {test if we should stop running}	      R4 _ Passes, BRANCH[$,PassDown], c3; {If we shouldn't, dont stop on error,dec pass count}NoStop:    {run test again}              Noop,		c1;	      Noop,		c2;	      GOTO[RunTest]	c3;	      PassDown:     Q _ R4 - 1,		c1;	      Passes _ Q or 0, ZeroBr, 	c2;	       { See if we want to modify the data for next pass}	IncDataSP:    R3 _ R3 LRot8,BRANCH[$,Done], c3; {Done if no more passes}		{switch DatErr ctl bytes in R1}	      R4  _ DataSP LRot8,	c1; {mask low pattern byte}	      R4 _ R4+1 ,		c2; {R4 pattern bytes swapped}	      [] _ R3 and 1, ZeroBr,	c3; {Test Inc Pattern bit }	      BRANCH [$, IncDataTP],	c1;	      R4 _ R4 and 0FF,		c2; {mask high byte swapped low}	      R4 _ R4 LRot8,		c3; {inc byte}	      	      DataSP_ DataSP+1, 	c1; {inc other byte and swap up}	      DataSP_ DataSP and 0FF,	c2; {swap back up}	      DataSP _ R4 or DataSP,	c3; {put back as next pattern}	      Noop,			c1;	      { See if we want to modify the data type for next pass}	      IncDataTP:    [] _ R3 and 2, ZeroBr,	c2; {Test Inc Data Type bit}	      BRANCH[$,NextPass],	c3;	      R4 _ DataTP,		c1;	      R4 _ R4 + 1,		c2;	      Noop,			c3;	      	      [] _ R4 xor 5, ZeroBr,	c1; {have we reached the last type?}	      BRANCH[IncOK,Gets0Again],	c2; {DataTP+1<5,Reset DataTP} IncOK:	      DataTP _ R4, GOTO[RunTest],	c3;Gets0Again:   DataTP _ 0, GOTO[RunTest], c3;NextPass:  Noop,   c1;        Noop,    c2;	GOTO [RunTest],   c3;Done:	L3_0,c1;	Noop,c2;	GOTO [LogState],c3;	Noop,		c1, at [0,10,LogStateRet];	Noop,		c2;	GOTO[SendIntIOP],c3;{-------------------------------}FaultCheck:R4 _ DatErrCtl,		c1;	[] _ Fault, ZeroBr,		c2;	BRANCH [$,GoOnFault],c3;         R4 _ R4 and 1, ZeroBr,		c1; {get Data and Error Control}	L0Disp,BRANCH [GoOnFault1,$],		c2; {mask off go on error flag}	CANCELBR[$,0F]		c3; {get existing fault flags}		Noop,		c1;	L0 _ 2,		c2;	GOTO [InterFaceCheck],c3;		Noop,		c1, at [2,10,InterfaceOKret];	Noop,		c2;	GOTO[SendIntIOP],c3;		Noop,		c1, at [2,10,InterFaceLockRet];	Noop,		c2;	GOTO[WaitForInt],		c3;				GoOnFault:Noop,			c1;	  L0Disp,				c2;GoOnFault1:DISP4 [FaultCheckRet],		c3;{------------------------------------------}InterFaceCheck: {}        Xbus _ IntStat, XDisp,	,c1;	DISP4[NoInt2,0D]	,c2;NoInt2:	GOTO[InterFaceCheck1],   c3, at[0D,10,NoInt2];	ClrIntErr, CANCELBR[CheckForSmctb,0F],	c3, at[0F,10,NoInt2];	InterFaceCheck1: Q _ Interface,			c1;	Ybus _ Q and 1,ZeroBr,		c2; {test Run Mesa Processor and IOP flag}	BRANCH[$,RunAlone],		c3;	R3 _ SMTCBp1,			c1; {Setup recognition constant}	R3 _ R3 LRot8,			c2;	R3 _ R3 or SMTCBp2,		c3;	R2 _ MTCBlocm,			c1; {Setup address to read from}	R2 _ R2 LRot8,			c2;	R2 _ R2 or MTCBlocl,		c3; 	rhR2 _ MTCBloch,		c1;	Noop,				c2;	TrapState _ 10,		  	c3;	MAR _ [rhR2,  R2+0],		c1;	Noop,				c2;	R4 _ MD,			c3;	Noop,				c1;	[] _ R4 xor R3,ZeroBr,		c2; {0 if R4 = R3}	BRANCH [InterFaceLock,$],	c3;	R4 _ RMTCBp1,			c1;	R4 _ R4 LRot8,			c2;	R4 _ R4 or RMTCBp2,		c3;		MAR _ [rhR2, R2+0],		c1;	MDR _ R4,			c2; {as per Kats's Daisy code}	Noop,				c3;RunAlone:	Noop,			c1;	L0Disp,				c2;	DISP4[InterfaceOKret],		c3;	InterFaceLock:	Noop,			c1;	L0Disp,				c2;	DISP4[InterFaceLockRet],		c3;{-----------------------------------------}{Set-up the starting and ending addresses to be tested.}{Initialize address reg., R0, to the starting address.}PhaseSetUp:     R0 _ PageWordS, c1;  {Set-up ,PageWord, address reg. R0}	R4 _ BankS,			c2; {set-up starting Bank}	rhR0 _ R4 LRot0,          c3;  {copy Bank}		{equiv of _ MPageBankS, map store&check not needed for Monday}		MAPA_R4 LRot0,    c1; 	R1 _ PageWordE,      c2;{set-up Last PageWord to be accessed}	R4 _ BankS,   c3;{set-up Last Bank to be accessed}	       	rhR1 _ R4 LRot0,    c1;       	DataO _ 0, L0Disp,	c2; {clear observed data reg.}	DISP4 [PhaseSetUpRet]		c3;	{-----------------------------------------}LogStateMap:    R4 _ BankS,	c1;		R4_ R4 LRot8,	c2;		Q _ rhR0, 	c3;				R4_ R4 or Q,	c1;		LBankPage_ R4 ,	c2;		R4_ R0 LRot8, 	c3;    	        R4_ R4 and 0FF,	c1;		Noop,	        c2;		GOTO[LogStateM],c3;LogState:      	Q _ rhR0,	c1;		R4 _ Q ,	c2;		R4_ R4 LRot8, 	c3;    	        Q_R4,	c1;		R4_ R0 LRot8,	c2;		R4_ R4 and 0FF,	c3;                R4_ R4 or Q,	c1;		LBankPage_ R4,	c2;		R4_ R0 and 0FF,	c3;LogStateM:	LWord _ R4,		c1;		LDataSP_DataSP,	c2;		LDataTP _  DataTP,	c3;                LDataO_DataO,		c1;		L3Disp,			c2;                LDataE_DataE,DISP4[LogStateRet]	c3;{-----------------------------------------}{This routine Stores a pattern into  all memory locations.}{The pattern stored into memory is given by the byte ,"starting data type", of}{SMTCB word # 8.}{The byte , "Test Control", of SMTCB word # 8 determines the test}{to be performed on the memory.}{Word # 9 of SMTCB, Data/Error Control, controls the test flow}{after completion or error} Store:  TrapState _ 20,   c1;      Noop,   c2;      Noop,   c3;            Xbus _ DataTP LRot0, XDisp,    c1;  {Dispatch to store data type}      DataE _ DataSP, DISP4[SType],    c2;   {data pattern}      SType:    {Branch on StartingDataType on Store routine entry}      DataModifier _ 0, GOTO[Store3],   c3,  at[0, 10, SType];{Store Block Patterns}      DataE _ R0, GOTO[Store2],    c3,  at[1, 10, SType];{Store PageWord into address}      DataModifier _ DataE, GOTO[Store3],  c3, at[2, 10, SType];{Store Data Pattern n}      DataModifier _ 0, GOTO[Store3],  c3, at[3, 10, SType];{Store Data Pattern n}      DataModifier _ 0, GOTO[Store1],  c3, at[4, 10, SType];{Store ~Bank/Bank}      Store1:   {compute the next pattern to be stored into next loc.}      Xbus _ DataTP LRot0, XDisp,   c1;      R3 _ R0, DISP4[SType1],  c2;      SType1:   {Modify pattern on entry and continue}      Noop, GOTO[Store3],   c3,  at[0, 10, SType1];{Store Block Patterns}      DataE _ R3, GOTO[Store2],   c3,  at[1, 10, SType1];{Store PageWord into address}      DataE _ DataE + DataModifier, GOTO[Store3],  c3,  at[2, 10, SType1];{Store Data Pattern n}      DataE _ DataE xor DataModifier,  c3,  at[3, 10, SType1];{Store Data Pattern n}      Q _ 0,    c1;      DataE _ DataE xor ~Q,    c2;      GOTO[Store3],  c3;            Q _ rhR0,   c3,  at[4, 10, SType1]; {load ~Bank/Bank}      DataE _ Q ,  c1;      R3 _ DataE xor 0FF,  c2;      R3 _ R3 LRot8,   c3;              DataE _ DataE or R3,    c1;      Noop,    c2;      GOTO[Store3],  c3;      Store2:   {store PageWord into Address}      MAR _ [rhR1, R1 + 0],   c1;      MDR _ R1,   c2;      Noop,   c3;      Store3:  {Store Block Patterns}      MAR _ [rhR0, R0 + 0],    c1;      MDR _ DataE,  c2;      R1 _ R1 - 1,  c3;{R1 is decremented down from PageWordE}             Noop,    c1;      [] _ R0 xor PageWordE, ZeroBr,    c2;{Is it PageWordE?}      R0 _ R0 + 1, BRANCH[Store1, SLAddrMatch],    c3;{If not, store in next location}      SLAddrMatch: Noop,   c1;      Noop,   c2;      Noop,  c3;       Noop,  c1, at[0,10,BadBankRet];      Noop,  c2;      Noop,   c3;            R1 _ PageWordE,   c1;      Q _ rhR0,     c2;      Noop,     c3;      R4 _ Q + 1,   c1;      [] _ Q xor BankE, ZeroBr,   c2;{Is it last Bank to be tested ?}      DataModifier  _ R4 + DataModifier + 1, BRANCH[$, SUAddrMatch],    c3;{If no, go to next Bank and continue test}            CheckForInt:Xbus _ IntStat, XDisp,	,c1;	   rhR0 _ R4 LRot0, DISP4[NoInt,0D]	,c2;NoInt:	R0 _ PageWordS, GOTO[StoreBankCheck],   c3, at[0D,10,NoInt];	ClrIntErr, CANCELBR[CheckForSmctb,0F],	c3, at[0F,10,NoInt];	StoreBankCheck:	RF_1,   c1;                L0_0,   c2;                GOTO[BankCheck],     c3;		                Q _ rhR0,   	c1, at[0,10,GoodBankRet];	        rhR1 _ Q LRot0,   c2;                GOTO[Store1],   c3;                                      SUAddrMatch:  {Done with Store, GoTo run the next test}      Noop,  c1;      Noop,   c2;      Noop,     c3;            Noop,   c1, at[0,10,LastBankRet];      Noop,  c2;      GOTO[RunTest1],     c3;      {--------------------------------------}{This routine checks for correct pattern in memory}Check:   TrapState _ 40,   c1;       Noop,   c2;       Noop,    c3;              Xbus _ DataTP LRot0, XDisp,    c1;       DataE _ DataSP, DISP4[CType],   c2;       CType: DataModifier _ 0, GOTO[Check2],   c3, at[0, 10, CType]; {Block pattern}       DataE _ R0, GOTO[Check2],  c3, at[1, 10, CType]; {PageWord pattern}       DataModifier _ DataE, GOTO[Check2],  c3, at[2, 10, CType]; {pattern increments}       DataModifier _ 0, GOTO[Check2],  c3, at[3, 10, CType]; {pattern increments}       DataModifier _ 0, GOTO[Check1],  c3, at[4, 10, CType]; {~Bank/Bank}       Check1: Xbus _ DataTP LRot0, XDisp,  c1;       R3 _ R0, DISP4[CType1],  c2;       CType1:  Noop, GOTO[Check2],  c3, at[0, 10, CType1];       DataE _ R3, GOTO[Check2],  c3, at[1, 10, CType1];       DataE _ DataE + DataModifier, GOTO[Check2], c3, at[2, 10, CType1];       DataE _ DataE xor DataModifier, c3, at[3, 10, CType1];       Q _ 0,     c1;       DataE _ ~DataE xor Q,    c2;       GOTO[Check2],    c3;       Q _ rhR0,  c3, at[4, 10, CType1];                    DataE _ Q ,    c1;       R3 _ DataE xor 0FF,  c2;       R3 _ R3 LRot8,     c3;              DataE _ DataE or R3,    c1;       Noop,    c2;       GOTO[Check2],  c3;       Check2: MAR _ [rhR0, R0 + 0],   c1;        Q _ DataE,   c2;        DataO _ MD,   c3;       Check2Entry:   Noop,   c1;       [] _ DataO xor Q, ZeroBr,   c2;       BRANCH[CheckError, $],  c3;              Noop,    c1;       [] _ R0 xor PageWordE, ZeroBr,    c2;       R0 _ R0 + 1,BRANCH[Check1, CLAddrMatch],  c3;       CLAddrMatch: Noop,   c1;       Noop,   c2;       Noop,  c3;              R1 _ PageWordE,  c1, at[1,10,BadBankRet];       Q _ rhR0,    c2;       Noop,  c3;       R4 _ Q + 1,   c1;       [] _ Q xor BankE, ZeroBr,  c2;       DataModifier  _ R4 + DataModifier + 1, BRANCH[$, CUAddrMatch],  c3;              CheckForInt1:Xbus _ IntStat, XDisp,	,c1;	   rhR0 _ R4 LRot0, DISP4[NoInt1,0D]	,c2;NoInt1:	R0 _ PageWordS, GOTO[CheckBankCheck],   c3, at[0D,10,NoInt1];	ClrIntErr, CANCELBR[CheckForSmctb,0F],	c3, at[0F,10,NoInt1];	CheckBankCheck:	RF_1,   c1;                L0_1,   c2;                GOTO[BankCheck],     c3;		                Noop,   c1, at[1,10,GoodBankRet];	        Noop,   c2;                GOTO[Check1],   c3;	        CheckError:  L3 _ 1,   c1;       R4 _ Fault,    c2;       R4 _ R4 or 1,    c3;              Noop,   c1;       Fault _ R4,   c2;       GOTO[LogState],  c3;       Q _ DataE,     c1, at[1, 10, LogStateRet];       DataO _ Q,   c2;       Noop,    c3;              R4 _ DatErrCtl,    c1;       [] _ R4 and 1, ZeroBr, c2;       BRANCH[Check2Entry, $],  c3;       Noop,   c1;       Noop,   c2;       Noop,  c3;       CUAddrMatch: Noop,  c1;       Noop,   c2;       Noop,     c3;             Noop,   c1, at[1,10,LastBankRet];       Noop,  c2;       Noop,     c3;             L0 _ 0,  c1;       Noop,    c2;       GOTO[FaultCheck],   c3;              Noop,   c1, at[0, 10, FaultCheckRet];       Noop,    c2;       GOTO[RunTest2],     c3;              {---------------------------------}{ Map data store routine}MapStore:   R0 _ MPageWordS,	c1;            R4 _ MBankS,      c2;	    rhR0 _ R4 LRot0,   c3;	    	    TrapState_ 20,     c1;	    R4 _ R4 LRot8,    c2;	    R3 _ R0 LRot8,    c3;	                Xbus _ DataTP LRot0, XDisp,  c1;	    DataE_DataSP, DISP4[MSType],  c2;MSType:    DataModifier_0, GOTO[MStore2], c3,  at[0,10,MSType];           R3 _ R3 and 0FF,	c3, at[1,10,MSType];	   R3 _ R3 or R4 ,	c1;	   DataE_ R3,    c2;	   GOTO[MStore2],	c3;	              DataModifier_DataE, GOTO[MStore2],  c3, at[2,10,MSType];           DataModifier_0, GOTO[MStore2],  c3,  at[3,10,MSType];           DataModifier_0, GOTO[MStore1],  c3,  at[4,10,MSType];           MStore1:              Xbus _ DataTP LRot0, XDisp,  c1;           Q _ rhR0, DISP4[MSType1],  c2;MSType1:   Noop, GOTO[MStore2],  c3,  at[0,10,MSType1];           R4 _ Q ,	c3, at[1,10,MSType1];	   R4 _ R4 LRot8, 	c1;	   R3 _ R0 LRot8,    c2;	   R3 _ R3 and 0FF,	c3;	   	   R3 _ R3 or R4 ,	c1;	   DataE_ R3,    c2;           GOTO[MStore2],  c3;	              DataE_ DataE + DataModifier, GOTO[MStore2], c3, at[2,10,MSType1];	              DataE_ DataE xor DataModifier, c3,  at[3,10,MSType1];	   Q _ 0,    c1;           DataE _ DataE xor ~Q,    c2;           GOTO[MStore2],  c3;           DataE _ BankS,	c3, at[4,10,MSType1];           R3 _ DataE xor 0FF,  c1;           R3 _ R3 LRot8,  c2;           DataE _ DataE or R3,GOTO[MStore2],   c3;            MStore2:              Map _ [rhR0, R0 + 0],    c1;	   MDR_DataE, 	c2;           Q _ rhR0,	c3;	   	   R4 _ Q, c1;	   R3_ R0 and ~0FF,	c2;{R3 = PageBank}	   R3_ R3 or R4,	c3;	   	   RF _ MPageBankE,   c1;	   [] _ R3 xor RF, ZeroBr, c2;           Q _0FF, BRANCH[MapSInc,MSAddrMatch],   c3; MapSInc:   R0 _ R0 +Q+1,ZeroBr,  c1;	   BRANCH[NoMapSCarry,MapSCarry],  c2;	   NoMapSCarry: GOTO[MStore1],   c3;MapSCarry: Q _ rhR0,   c3;	   R4 _ Q+1,    c1;	   rhR0 _ R4 LRot0,   c2;	   GOTO[MStore1],  c3;	   MSAddrMatch:Xbus _ IntStat, XDisp,	,c1;	    DISP4[MSInt01,0D]	,c2;   MSInt01:    GOTO[RunTest1],   c3, at[0D,10,MSInt01];	    ClrIntErr,GOTO[CheckForSmctb],  c3, at[0F,10,MSInt01];{Map data check routine}MapCheck:   R0 _ MPageWordS,	c1;            R4 _ MBankS,      c2;	    rhR0 _ R4 LRot0,   c3;	    	    TrapState_ 40,     c1;	    R4 _ R4 LRot8,    c2;	    R3 _ R0 LRot8,    c3;	                Xbus _ DataTP LRot0, XDisp,  c1;	    DataE_DataSP, DISP4[MCType],  c2;MCType:     DataModifier_0, GOTO[MCheck2],  c3, at[0,10,MCType];            R3 _ R3 and 0FF,	c3, at[1,10,MCType];	    R3 _ R3 or R4 ,	c1;	    DataE_ R3,    c2;	    GOTO[MCheck2],	c3;            DataModifier_DataE, GOTO[MCheck2], c3, at[2,10,MCType];;            DataModifier_0, GOTO[MCheck2],  c3, at[3,10,MCType];            DataModifier_0, GOTO[MCheck1], c3,  at[4,10,MCType];           MCheck1:    Xbus _ DataTP LRot0, XDisp,  c1;             Q _ rhR0,DISP4[MCType1],  c2;MCType1:    Noop, GOTO[MCheck2], c3, at[0,10,MCType1];            R4 _ Q,  c3, at[1,10,MCType1];            R4 _ R4 LRot8, 	c1;	    R3 _ R0 LRot8,    c2;	    R3 _ R3 and 0FF,	c3;	   	    R3 _ R3 or R4 ,	c1;	    DataE_ R3,    c2;            GOTO[MCheck2],  c3;	    DataE_ DataE + DataModifier, GOTO[MCheck2], c3,  at[2,10,MCType1];            DataE _ DataE xor DataModifier, c3, at[3, 10, MCType1];            Q _ 0,     c1;            DataE _ DataE xor ~Q,    c2;            GOTO[MCheck2],    c3;            DataE _ BankS,	c3, at[4,10,MCType1];            R3 _ DataE xor 0FF,  c1;            R3 _ R3 LRot8,  c2;            DataE _ DataE or R3,GOTO[MCheck2],  c3;	              MCheck2:     Map _ [rhR0, R0 + 0],	c1;	     Q_DataE, 	c2;             DataO_MD,	c3;MCheck2Entry: RF _ MPageBankE,  c1;             [] _ DataO xor Q, ZeroBr,   c2;             BRANCH[MCheckError, $],  c3;             Q_rhR0,	c1;	     R4 _ Q,	c2;	     R3_ R0 and ~0FF,	c3;	     R3_ R3 or R4, c1;             [] _ R3 xor RF,ZeroBr,  c2;             Q_0FF, BRANCH[MapCInc,MCAddrMatch],  c3; MapCInc:     R0 _ R0 + Q+1,ZeroBr,  c1;	     BRANCH[NoMapCCarry,MapCCarry],  c2;	     NoMapCCarry:   GOTO[MCheck1],   c3;MapCCarry:   Q _ rhR0,   c3;	     R4 _ Q+1,    c1;	     rhR0 _ R4 LRot0,   c2;	     GOTO[MCheck1],  c3;MCheckError: L3_3,   c1;             R4 _ Fault,    c2;             R4 _ R4 or 2,    c3;                    Noop,   c1;             Fault _ R4,   c2;             GOTO[LogStateMap],  c3;	     Q _ DataE,     c1, at[3, 10, LogStateRet];             DataO _ Q,   c2;             Noop,    c3;                    R4 _ DatErrCtl,    c1;             [] _ R4 and 1, ZeroBr, c2;             BRANCH[MCheck2Entry, $],  c3;             Noop,   c1;             Noop,   c2;             Noop,  c3;       MCAddrMatch: L0_1,  c1;             Noop,    c2;             GOTO[FaultCheck],   c3;             Xbus _ IntStat, XDisp,		c1,at[1,10,FaultCheckRet];	     DISP4 [MCInt01,0D],		c2;	     MCInt01:     GOTO [RunTest2],		c3, at [0D,10,MCInt01];	     ClrIntErr,GOTO[CheckForSmctb],c3, at [0F,10,MCInt01];         {---------------------------------}{Memory Size data store routine}MemSizeStore:   R4 _ 3F,   c1;       rhR0 _ R4 LRot0,   c2;       TrapState _ 80,   c3;              Noop,   c1;MSizeType:Q _ rhR0,   c2;       DataE _ Q,   c3;              R3 _ DataE xor 0FF,    c1;       R3 _ R3 LRot8,     c2;       DataE _ DataE or R3,   c3;        MemSizeStore1:MAR _ [rhR0, R0 + 0],    c1;       MDR _ DataE,  c2;       Noop,  c3;              MSizeTrapEntry:Noop,  c1;       Q _ rhR0, ZeroBr,   c2;       R4 _ Q-1,BRANCH[$, MSizeAddrMatch],   c3;              rhR0_R4 LRot0,GOTO[MSizeType],   c1;       MSizeAddrMatch:   Xbus _ IntStat, XDisp,	,c1;	    DISP4[MSizeInt01,0D]	,c2;   MSizeInt01: GOTO[RunTest1],   c3, at[0D,10,MSizeInt01];	    ClrIntErr,GOTO[CheckForSmctb],  c3, at[0F,10,MSizeInt01];{---------------------------------}{Memory data check routine}MemSizeCheck:    R4 _ 3F,   c1;       rhR0 _ R4 LRot0,   c2;       TrapState _ 84,   c3;              DataO _ 0,   c1;MSizeCType: Q _ rhR0,   c2;       DataE _ Q,   c3;              R3 _ DataE xor 0FF,    c1;       R3 _ R3 LRot8,     c2;       DataE _ DataE or R3,   c3;       MemSizeCheck1:MAR _ [rhR0, R0+0],   c1;       Q _ DataE, CANCELBR[$, 2], LOOPHOLE[wok],    c2;       R3 _ MD,   c3;              [] _ R3 xor Q, ZeroBr,    c1;       BRANCH[MSizeCheckEntry, SaveMemsize],   c2;       SaveMemsize:   DataO_DataO+1,   c3;              Noop,    c1;       Noop,   c2;MSizeCheckEntry:   Q _ rhR0,  ZeroBr,   c3;       R4 _ Q-1,BRANCH[$, MSizeCAddrMatch],   c1;       Noop,   c2;       Noop ,   c3;              rhR0_R4 LRot0,GOTO[MSizeCType],   c1;              MSizeCAddrMatch: DataE_MemorySize,   c2;       L3_4,GOTO[LogState],    c3;              Q_DataE,   c1,  at[4, 10, LogStateRet];       [] _ DataO xor Q,ZeroBr,    c2;       BRANCH[SizeError,SizeGood],   c3;       SizeError:R4 _ Fault,	c1;	R4 _ R4 or 8,		c2;	Fault _ R4, 	c3;          SizeGood:  Noop,    c1;           L0 _ 2,    c2;           GOTO[FaultCheck],    c3;	                 Xbus _ IntStat, XDisp,   c1,   at[2, 10, FaultCheckRet];       	    DISP4[MSizeCInt01,0D]	,c2;   MSizeCInt01: GOTO[RunTest2],   c3, at[0D,10,MSizeCInt01];	     ClrIntErr,GOTO[CheckForSmctb],  c3, at[0F,10,MSizeCInt01];{---------------------------------}BadTest:	R4 _ Fault,	c1;	R4 _ R4 or 4,		c2;	Fault _ R4, GOTO[SendIntIOP],	c3;{---------------------------------}BankCheck: Q_R4 and 20,			c1;	   [] _ Q , ZeroBr,	        c2;           Q_R4,BRANCH[LastBank, $],	c3;	   	   Q_R4 and 0F,		c1;	   [] _ Q , ZeroBr,	        c2;           BRANCH[ShiftBankBit, $],	c3;	   	   Noop,			c1;	   Noop,			c2;           GOTO[GotBankBit],		c3;	   	   ShiftBankBit: RF_LShift1 RF,		c1;	   Q_Q-1,ZeroBr,		c2;           BRANCH[$, GotBankBit],c3;	   	   Noop,			c1;	   Noop,			c2;           GOTO[ShiftBankBit],		c3;	   GotBankBit:Q_R4 and 10,			c1;	   [] _ Q , ZeroBr,	        c2;           Q_MemorySize1,BRANCH[$, LowerBank],	c3;	   GOTO[UpperBank],			c1;	   	   LowerBank: Q_MemorySize,		c1;UpperBank: []_RF and Q,ZeroBr,		c2;           BRANCH[$, BadBank],          c3;	   	   	   Noop,			c1;	   L0Disp,			c2;           DISP4 [GoodBankRet],		c3;	   BadBank:   Noop,			c1;	   L0Disp,			c2;           DISP4 [BadBankRet],		c3;	   LastBank:  Noop,			c1;	   L0Disp,			c2;           DISP4 [LastBankRet],		c3;	   LoaderCheck:	ClrMPIntIOP,GOTO[LoaderCheck],c*, at[0FFF];
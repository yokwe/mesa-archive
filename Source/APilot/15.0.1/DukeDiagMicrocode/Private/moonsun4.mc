{File name:  <Workstation>mc>Sunlight-O.mc}Reserve[0001,001E];{ For moonBus}Reserve[0020,002E];{ For moonBus}Reserve[0030,003E];{ For moonBus}Reserve[0040,005F];{ For moonBus}Reserve[0060,00FF];{ moonsun1}Reserve[0110,0180];{ moonsun1}Reserve[0181,01FF];{ moonsun2}Reserve[0210,03CF];{ moonsun2}Reserve[03D0,03FF];{ moonsun3}Reserve[0401,04D2];{ moonsun3}Reserve[04D4,04FF];{ moonsun3}{Reserve[0400];	   { moonsun4}Reserve[0500,05FF];{ moonsun4}Reserve[0600,060F];{ moonsun4}Reserve[0700,070F];{ moonsun4}Reserve[0800,08D2];{ moonsun4}Reserve[08D4,08FF];{ moonsun4}}Reserve[0610,06D2];{ moonsun5}Reserve[06D4,06FF];{ moonsun5}Reserve[04D3];	{moontime }Reserve[06D3];	{moontime }Reserve[0710,07FF];{ moontime}Reserve[0AD3,0AD4];{ moontime}Reserve[0900,09FF];{ MoonMr}Reserve[0A00,0AD2];{ For OTHER TEST}Reserve[0AD5,0FEF];{ For OTHER TEST}Reserve[0100,0103];{ For OTHER TEST}Reserve[0105,010F];{ For OTHER TEST}Reserve[0200,0203];{ For OTHER TEST}Reserve[0205,020F];{ For OTHER TEST}Reserve[0FF0,0FF3];{ For OTHER TEST}Reserve[0FF5,0FFE];{ For OTHER TEST}SetTask[0]; StartAddress[TERROR1];TERROR1:R1 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[0];        R6 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[1F];        R8 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[3F];        R1 _ R1 or R6,ClrIE,	c*, at[2F];        R1 _ R1 or R8,	c*, at[104];	        Xbus _ R1 LRot0, XwdDisp,	c*;	DISP2[TrapType],	c*;TrapType:GOTO[Trap],	c*, at[0,4,TrapType];	SetIE,GOTO[START],c*, at[1,4,TrapType];	GOTO[Trap],	c*, at[2,4,TrapType];	GOTO[Trap],	c*, at[3,4,TrapType];Trap:	  GOTO[Trap],   c*;START:	XC2npcDisp, c2;	BRANCH[BadCy, GoodCy, 0D],	c3;BadCy:	Noop,	c*, at[0D,10,GoodCy];	Noop,	c*;	GOTO[START]	c*;	GoodCy:	Noop ,	c1, at[0F,10,BadCy];	Noop,	c2;	GOTO[ibTests]	c3, at[204];		{4.0  IB tests}	Set[Full, 2]; Set[Word,3]; Set[Byte,1]; Set[Empty,0];{IBPtr_0 should set ibPtr to Word.}ibTests:	TestCnt _ TestCnt + 1 ,CANCELBR[$,0F] 	,c1, at[51E];	IBPtr_0	,c2;	R1 _ ~ErrnIBnStkp	,c3;	R1 _ R1 LRot12	,c1;	R1 _ R1 and 3	,c2;	R2 _ R1 xor Word, ZeroBr	,c3;	BRANCH[IBPtr0Bad, $]	,c1;	Noop,				c2;	GOTO[IBPtr0Good],		c3;{IBPtr_1 should set ibPtr to Byte.}IBPtr0Good:	Noop,				c1, at[534];	IBPtr_1	,c2;	R1 _ ~ErrnIBnStkp	,c3;	R1 _ R1 LRot12	,c1;	R1 _ R1 and 3	,c2;	R2 _ R1 xor Byte, ZeroBr	,c3;	BRANCH[IBPtr1Bad, $]	,c1;	Noop,				c2;	GOTO[IBPtr1Good],		c3;{Load IB with 2 bytes (0ABCD) & read each of them (twice) via IBPtr_n}IBPtr1Good:	Noop,		c1, at[53C];	R1 _ 0AB	,c2;	R1 _ R1 LRot8	,c3;	R1 _ R1 or 0CD  {R1 _ 0ABCD}	,c1;	IB _ R1 LRot0	,c2;	IBPtr _ 0  {ibFront_0AB}	,c3;	R2 _ 0AB	,c1;	Xbus _ 54 {precharge X}	,c2;	R3 _ ibNA xor R2, ZeroBr	,c3;	R3 _ ibNA xor R2, ZeroBr, BRANCH[IBLeftaBad, IBLeftaGood]	,c1;IBLeftaGood:	BRANCH[IBLeftbBad, IBLeftbGood]	,c2;IBLeftbGood:	Noop,			c3;	{refill and check other byte}TestIB2nd:	R1 _ 0AB	,c1, at[553];	R1 _ R1 LRot8	,c2;	R1 _ R1 or 0CD  {R1 _ 0ABCD}	,c3;	R2 _ 0CD,		c1;	Noop,			c2;	Noop,			c3;	IB _ R1 LRot0	,c1;	IBPtr _ 1 {ibFront_0CD}	,c2;	Xbus _ 32 {precharge X}	,c3;	R3 _ ibNA xor R2, ZeroBr	,c1;	R3 _ ibNA xor R2, ZeroBr, BRANCH[IBRaBad, IBRaGood]	,c2;IBRaGood:	BRANCH[IBRbBad, IBRbGood]	,c3;{Try ibLow & ibHigh}IBRbGood:	R2 _ 0C,			c1, at[529];	R1 _ 032, {comp of lower byte}	c2;	R1 _ R1 LRot8,			c3;	R1 _ R1 or 0CD,			c1;	IB _ R1 LRot0,			c2;	IBPtr _ 1 {ibFront _ IB[0]}	c3;	Xbus _ 3 {precharge X}	,c1;	R4 _ ibHigh xor R2, ZeroBr	,c2;	BRANCH[IBHighBad, IBHighGood]	,c3;IBHighGood:	R2 _ 0D,			c1, at[52B];	R1 _ 032, {comp of lower byte}	c2;	R1 _ R1 LRot8,			c3;	R1 _ R1 or 0CD,			c1;	IB _ R1 LRot0,			c2;	IBPtr _ 1 {ibFront _ IB[0]}	c3;	Xbus _ 2 {precharge X}	,c1;	R4 _ ibLow xor R2, ZeroBr	,c2;	BRANCH[IBLowBad, IBLowGood]	,c3;{PageCross should cancel IBDisp and AlwaysIBDisp.  ibPtr should still be Byte}IBLowGood:	Noop,		c1, at[52D];	rhR0 _ 0	,c2;	R0 _ 0FF	,c3;	MAR _ [rhR0, R0+0]	,c1;	MDR_R0	,c2;	R0_0 	,c3;	MAR _ [rhR0, R0-1]	,c1;	IBDisp, CANCELBR[$,2]	,c2;	Noop 	,c3;	MAR _ [rhR0, R0-1]	,c1;	AlwaysIBDisp, CANCELBR[$,2]	,c2;	R2 _ ~ErrnIBnStkp	,c3;	R2 _ R2 LRot12	,c1;	R2 _ R2 and 3	,c2;	R3 _ R2 xor Byte, ZeroBr	,c3;	BRANCH[IBPtr1xBad, $]	,c1;	Noop,			c2;	GOTO[IBPtr1xGood],	c3;{Try a Not-Empty refill trap (loc 500) via IBPtr_0. R4 must be 5 at loc 500}IBPtr1xGood:	Noop,		c1, at[57E];	IBPtr _ 0	,c2;	R4 _ 5	,c3;	ClrIntErr  {clear a possible MInt}	,c1;	IBDisp  {should trap}	,c2;	GOTO[IBNullTable]	,c3;NETrap:	R3 _ R4 xor 5, ZeroBr	,c1, at[500];	BRANCH[NETrapBad, $]	,c2;	GOTO[NETrapGood],	c3;{Load IB with 4 bytes (0ABCD 5432), execute 3 _ib's and an IBDisp which should do an Empty refill trap (loc 400).  R4 must be a 4 at loc 400)}NETrapGood:	R1 _ 0AB	,c1, at[585];	R1 _ R1 LRot8	,c2;	R1 _ R1 or 0CD  {R1 _ 0ABCD}	,c3;	IB _ R1 LRot0  {IB _ 0ABCD}	,c1;	IBPtr_0, R1 _ ~R1  {R1 _ 5432}	,c2;	R4 _ 4				,c3;	R2 _ 0AB	,c1;	Noop,		c2;	Noop,		c3;	Xbus _ 54 {precharge X}	,c1;	R3 _ ib xor R2, ZeroBr	,c2;	IB _ R1 LRot0, BRANCH[IBaBad, IBaGood]	,c3;IBaGood:	R2 _ 0CD	,c1;	R3 _ ib xor R2, ZeroBr	,c2;	BRANCH[IBbBad, IBbGood]	,c3;IBbGood:	R2 _ 54		,c1;	R3 _ ib xor R2, ZeroBr	,c2;	BRANCH[IBcBad, IBcGood]	,c3;IBcGood:	R2 _ 32		,c1;	R3 _ ib xor R2, ZeroBr  {buffer empty now}	,c2;	BRANCH[IBdBad, IBdGood]	,c3;IBdGood:	ClrIntErr  {clear a possible MInt}	,c1;	IBDisp  {should trap}	,c2;	GOTO[IBNullTable]	,c3;ETrap:	R3 _ R4 xor 4, ZeroBr	,c1, at[400];	BRANCH[ETrapBad, ETrapGood]	,c2;{Try an MInt trap (on an empty buffer)}ETrapGood:	MesaIntRq	,c3;	R4 _ 6  {buffer is still empty}	,c1;	IBDisp  {should trap}	,c2;	GOTO[IBNullTable]	,c3;NEMIntTrap:	GOTO[EMTrapBad]	,c1, at[700];EMIntTrap:	R3 _ R4 xor 6, ZeroBr	,c1, at[600];	BRANCH[EMTrapBad, $]	,c2;	ClrIntErr,			c3;{Try an AlwaysIBDisp to 8AA (with MInt ON)}EMTrapG:	MesaIntRq,		c1, at[5A0];	R2 _ 0AA,		c2;	IB _ R2 LRot0	,c3;	R4 _ R4+0, IBPtr _ 1	,c1;	AlwaysIBDisp	,c2;	R4 _ 0,ClrIntErr, GOTO[IBTable0F]	,c3;IBDispaG:	Noop,			c2;	Noop,			c3;	{Try an IBDisp to 85A}IBDispto85A:	R2 _ 22			,c1, at[5A8];	Noop,			c2;	R2 _ R2 LRot8,ClrIntErr,c3;	R2 _ R2 or 5A	,c1;	IB _ R2 LRot0  {IB_2255}	,c2;	R2 _ R2 or 77	,c3;	IBPtr _ 0	,c1;	Xbus _ ib	,c2;	IB _ ~R2 LRot0  {IB_DD88}	,c3;	R4 _ 0+0	,c1;	IBDisp		,c2;	GOTO[IBTable0F]	,c3;IBDispbG:	Noop,		c2;	Noop,		c3;	{Try an AlwaysIBDisp to 8FA}AlwaysIBDispto8FA:	R2 _ 0FA	,c1, at[5B7];	IB _ R2 LRot0	,c2;	R4 _ R4+0, IBPtr _ 1	,c3;	Noop,			c1;	AlwaysIBDisp	,c2;	R4 _ 0, GOTO[IBTableF0]	,c3;IBDispcG:	Noop,			c2;	Noop,			c3;	{Try an AlwaysIBDisp to 8F5}AlwaysIBDispto8F5:	Noop,			c1, at[5BF];	R2 _ 0F5	,c2;	IB _ R2 LRot8	,c3;	R4 _ R4+0, IBPtr _ 0	,c1;	AlwaysIBDisp	,c2;	R4 _ 0, GOTO[IBTableF0]	,c3;IBNullTable:	Noop, GOTO[IBTrapBad]	,c1, at[800];IBTable0F:	GOTO[IBDispabBad]	,c1, at[80F];	GOTO[IBDispabBad]	,c1, at[81A];	GOTO[IBDispabBad]	,c1, at[82A];	GOTO[IBDispabBad]	,c1, at[83A];	GOTO[IBDispabBad]	,c1, at[84A];	GOTO[IBDispbG]	,c1, at[85A];	GOTO[IBDispabBad]	,c1, at[86A];	GOTO[IBDispabBad]	,c1, at[87A];	GOTO[IBDispabBad]	,c1, at[88A];	GOTO[IBDispabBad]	,c1, at[89A];	GOTO[IBDispaG]	,c1, at[8AA];	GOTO[IBDispabBad]	,c1, at[8BA];	GOTO[IBDispabBad]	,c1, at[8CA];	GOTO[IBDispabBad]	,c1, at[8DA];	GOTO[IBDispabBad]	,c1, at[8EA];IBTableF0:	GOTO[IBDispcdBad]	,c1, at[8F0];	GOTO[IBDispcdBad]	,c1, at[8F1];	GOTO[IBDispcdBad]	,c1, at[8F2];	GOTO[IBDispcdBad]	,c1, at[8F3];	GOTO[IBDispcdBad]	,c1, at[8F4];CheckMAR:	GOTO[MemTest]	,c1, at[8F5];	GOTO[IBDispcdBad]	,c1, at[8F6];	GOTO[IBDispcdBad]	,c1, at[8F7];	GOTO[IBDispcdBad]	,c1, at[8F8];	GOTO[IBDispcdBad]	,c1, at[8F9];	GOTO[IBDispcG]	,c1, at[8FA];	GOTO[IBDispcdBad]	,c1, at[8FB];	GOTO[IBDispcdBad]	,c1, at[8FC];	GOTO[IBDispcdBad]	,c1, at[8FD];	GOTO[IBDispcdBad]	,c1, at[8FE];	GOTO[IBDispcdBad]	,c1, at[8FF];MemTest:	Noop,			c2;	R0 _ 20,		c3;{Simple MAR operation}	CONF  _ R0	,c1; {Why for I don't know}	R0 _ 5	,c2;	rhR0 _ 0	,c3;	MAR _ [rhR0, R0+0]	,c1;	MDR _ 0	,c2;		Noop	,c3;	MAR _ [rhR0, R0+0]	,c1;	Noop	,c2;	R1 _ MD	,c3;	[] _ R1, ZeroBr	,c1;	BRANCH[SimMARBad, $]	,c2;	Noop	,c3;{Does page cross cancel write?}PgCrossCnclWr:	R1 _ 6,			c1, at[5D4];	rhR0 _ 0,		c2;	R0 _ 5,			c3;	MAR _ [rhR0, R0+0]	,c1;	MDR _ 0	,c2;		Noop	,c3;	MAR_[rhR0, R1+0FF]	,c1;	MDR _ 0F, CANCELBR[$, 2], LOOPHOLE[wok],c2;	Noop	,c3;	MAR _ [rhR0, R0+0]	,c1;	Noop	,c2;	R1 _ MD	,c3;	[] _ R1, ZeroBr	,c1;	BRANCH[MDRCanBad, $]	,c2;	ClrIntErr,CANCELBR[$,0F],c3;InterFace:ClrMPIntIOP		,c1, at[54F];	Xbus _ IntStat, XDisp,	,c2;		{cycle 2}	DISP4[NoInt,0D]		,c3;NoInt:	GOTO[WaitForInt],	c1, at[0D,10,NoInt];	GOTO[NoIntBad],		c1, at[0F,10,NoInt];	WaitForInt:	Noop,			c2;	Noop,			c3;{}	Noop,			c1;	SetMPIntIOP,c2;	ClrMPIntIOP,c3;	WaitLoop:Xbus _ IntStat, XDisp	,c1;		{cycle 1, waiting}	DISP4[WaitOnInt,0D]	,c2;WaitOnInt:GOTO[WaitLoop],	c3, at[0D,10,WaitOnInt];	  ClrIntErr,CANCELBR[$,0F],c3, at[0F,10,WaitOnInt];	  InterFace1:Xbus _ IntStat, XDisp,	c1;	{cycle 1}	   DISP4[NoInt1,0D]	,c2;NoInt1:	ClrMPIntIOP,GOTO[WaitForInt1],	c3, at[0D,10,NoInt1];	GOTO[NoIntBad1],	c3, at[0F,10,NoInt1];	WaitForInt1:SetMPIntIOP,c1;	   ClrMPIntIOP,c2;WaitLoop1: Xbus _ IntStat, XDisp,	,c3;	{cycle 3, waiting}	 DISP4[WaitOnInt1,0D]	,c1;WaitOnInt1:GOTO[WaitLoop1],	c2, at[0D,10,WaitOnInt1];	   ClrIntErr,CANCELBR[$,0F],	c2, at[0F,10,WaitOnInt1];	   GOTO[InterFace2],		c3;	InterFace2:	Noop,			c1;	Noop,			c2;	Xbus _ IntStat, XDisp,	,c3;		{cycle 3}	DISP4[NoInt2,0D]	,c1;NoInt2:	GOTO[NOERROR],   	c2, at[0D,10,NoInt2];	GOTO[NoIntBad2],	c2, at[0F,10,NoInt2];		{Bad ib breaks}IBPtr0Bad: RE _ 83, GOTO[IBPtr0Bad],	c*;IBPtr1Bad: RE _ 84, GOTO[IBPtr1Bad],	c*;IBLeftaBad: RE _ 85, CANCELBR[IBLeftaBad1],	c*;IBLeftaBad1: RE _ 85, GOTO[IBLeftaBad1],	c*;IBLeftbBad: RE _ 86, GOTO[IBLeftbBad],	c*;IBRaBad: RE _ 87, CANCELBR[IBRaBad1],	c*;IBRaBad1: RE _ 87, GOTO[IBRaBad1],	c*;IBRbBad: RE _ 88, GOTO[IBRbBad],	c*;IBHighBad: RE _ 89, GOTO[IBHighBad],	c*;IBLowBad: RE _ 8A, GOTO[IBLowBad],	c*;IBPtr1xBad: RE _ 8B, GOTO[IBPtr1xBad],	c*;NETrapBad: RE _ 8C, GOTO[NETrapBad],	c*;IBaBad: RE _ 8D, GOTO[IBaBad],	c*;IBbBad: RE _ 8E, GOTO[IBbBad],	c*;IBcBad: RE _ 8F, GOTO[IBcBad],	c*;IBdBad: RE _ 90, GOTO[IBdBad],	c*;ETrapBad: RE _ 91, GOTO[ETrapBad],	c*;EMTrapBad: RE _ 92, GOTO[EMTrapBad],	c*;IBEmptyBad: RE _ 93, GOTO[IBEmptyBad],	c*;IBDispaBad: RE _ 94, GOTO[IBDispaBad],	c*;IBDispbBad: RE _ 95, GOTO[IBDispbBad],	c*;IBDispcBad: RE _ 96, GOTO[IBDispcBad],	c*;IBDispdBad: RE _ 97, GOTO[IBDispdBad],	c*;IBDispabBad: RE _ 98, GOTO[IBDispabBad],	c*;IBDispcdBad: RE _ 99, GOTO[IBDispcdBad],	c*;IBTrapBad: RE _ 9A, GOTO[IBTrapBad],	c*;{Simple mem tests.}SimMARBad:	ClrMPIntIOP, GOTO[SimMARBad],	c*;MDRCanBad:	ClrMPIntIOP, GOTO[MDRCanBad],	c*;NoIntBad:	ClrMPIntIOP, GOTO[NoIntBad],	c*;NoIntBad1:	ClrMPIntIOP, GOTO[NoIntBad1],	c*;NoIntBad2:	ClrMPIntIOP, GOTO[NoIntBad1],	c*;NOERROR:	ClrMPIntIOP,GOTO[NOERROR],c*, at[0FF4];LoaderCheck:	ClrMPIntIOP,GOTO[LoaderCheck],c*, at[0FFF];
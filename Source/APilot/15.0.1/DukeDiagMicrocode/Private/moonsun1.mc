{File name:  <Workstation>mc>Sunlight-O.mc}Reserve[0001,001E];{ For moonBus}Reserve[0020,002E];{ For moonBus}Reserve[0030,003E];{ For moonBus}Reserve[0040,005F];{ For moonBus}{Reserve[0060,00FF];{ moonsun1}Reserve[0110,0180];{ moonsun1}}Reserve[0181,01FF];{ moonsun2}Reserve[0210,03CF];{ moonsun2}Reserve[03D0,03FF];{ moonsun3}Reserve[0401,04D2];{ moonsun3}Reserve[04D4,04FF];{ moonsun3}Reserve[0400];	   { moonsun4}Reserve[0500,05FF];{ moonsun4}Reserve[0600,060F];{ moonsun4}Reserve[0700,070F];{ moonsun4}Reserve[0800,08D2];{ moonsun4}Reserve[08D4,08FF];{ moonsun4}Reserve[0610,06D2];{ moonsun5}Reserve[06D4,06FF];{ moonsun5}Reserve[04D3];	{moontime }Reserve[06D3];	{moontime }Reserve[0710,07FF];{ moontime}Reserve[0AD3,0AD4];{ moontime}Reserve[0900,09FF];{ MoonMr}Reserve[0A00,0AD2];{ For OTHER TEST}Reserve[0AD5,0FEF];{ For OTHER TEST}Reserve[0100];{ For OTHER TEST}Reserve[0102,010F];{ For OTHER TEST}Reserve[0202,020F];{ For OTHER TEST}Reserve[0200];{ For OTHER TEST}Reserve[0FF0];{ For OTHER TEST}Reserve[0FF2,0FFE];{ For OTHER TEST}SetTask[0]; StartAddress[TERROR1];TERROR1:R1 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[0];        R6 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[1F];        R8 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[3F];        R1 _ R1 or R6,ClrIE,	c*, at[2F];        R1 _ R1 or R8,	c*, at[101];	        Xbus _ R1 LRot0, XwdDisp,	c*;	DISP2[TrapType],	c*;TrapType:GOTO[Trap],	c*, at[0,4,TrapType];	SetIE,GOTO[START],c*, at[1,4,TrapType];	GOTO[Trap],	c*, at[2,4,TrapType];	GOTO[Trap],	c*, at[3,4,TrapType];Trap:	  GOTO[Trap],   c*;START:	XC2npcDisp, c2;	BRANCH[BadCy, GoodCy, 0D],	c3;BadCy:	Noop,	c*, at[0D,10,GoodCy];	Noop,	c*;	GOTO[START]	c*;	GoodCy:	Noop ,	c1, at[0F,10,BadCy];	Noop,	c2;	GOTO[Go],	c3, at[201];{0.  Branch Tests}{Can we do a Cycle2 branch?  Is Cycle2 stuck 0?}Go:	Noop,		c1, at[07C];	XC2npcDisp,	c2;	BRANCH[C2NotGood0x, C2Good0x, 0D],	c3;C2Br:	GOTO[BranchBad],	c1, at[0,10];	GOTO[BranchBad],	c1, at[1,10,C2Br];	GOTO[BranchBad],	c1, at[2,10,C2Br];	GOTO[BranchBad],	c1, at[3,10,C2Br];	GOTO[BranchBad],	c1, at[4,10,C2Br];	GOTO[BranchBad],	c1, at[5,10,C2Br];	GOTO[BranchBad],	c1, at[6,10,C2Br];	GOTO[BranchBad],	c1, at[7,10,C2Br];	GOTO[BranchBad],	c1, at[8,10,C2Br];	GOTO[BranchBad],	c1, at[9,10,C2Br];	GOTO[BranchBad],	c1, at[0A,10,C2Br];	GOTO[BranchBad],	c1, at[0B,10,C2Br];	GOTO[BranchBad],	c1, at[0C,10,C2Br];C2NotGood0x:	GOTO[C2Bad0],	c1, at[0D,10,C2Br];	GOTO[BranchBad],	c1, at[0E,10,C2Br];{Is Cycle2 stuck 1?}C2Good0x:	Noop,		c1, at[0F,10,C2Br];	Noop,			c2;	XC2npcDisp,		c3;	XC2npcDisp,BRANCH[$, C2Bad3, 0D],	c1;	BRANCH[$, C2Bad1, 0D],	c2;	Noop,			c3;{Can we do a NegBr?  Is F.0 stuck 0?  Secondary test of aF=7 in bit 0.}NegTest:	Noop,			c1, at[0BC];	[] _ ~R0 xor R0, NegBr,	c2; {~anything xor anything = FFFF} 	BRANCH[NegBad0, $],	c3;{Is F.0 stuck 1?}F0Test:	Noop,					c1, at[0C5];	[] _ 0 {doesn't use X bus}, NegBr,	c2;	BRANCH[$, NegBad1],			c3;{Can we do a ZeroBr?  Is FZero stuck 0?}ZeroBrTest:	Noop,			c1, at[070];	[] _ 0, ZeroBr,		c2;	BRANCH[ZeroBad0, $],	c3;{Is FZero stuck 1?}NotNegTest:	Noop,				c1, at[121];	[] _ ~R0 xor R0, ZeroBr,	c2;	BRANCH[$, ZeroBad1],		c3;{Can we do a NZeroBr?  Is FNonZero stuck 0?}NZeroTest1:	Noop,				c1, at[074];	[] _ ~R0 xor R0, NZeroBr,	c2;	BRANCH[NZeroBad0, $],		c3;	{Is FNonZero stuck 1?}NZeroTest0:	Noop,			c1, at[0CB];	[] _ 0, NZeroBr,	c2;	BRANCH[$, NZeroBad1],	c3;	{Can we do an OvBr?  Is Ovr stuck 0? Secondary test of RShift1.}Ovrflow:	R0 _ RShift1 (~R0 xor R0),  {R0 _ 7FFF}	c1, at[0B8];	R0 _ R0 + R0, PgCrOvDisp,		c2;	R2 _ 0, BRANCH[OvBad0, OvGood0, 2],	c3;{Is Ovr stuck 1?}OvGood0:	R0 _ 0,				c1, at[073];	R2 _ R0 + 0, PgCrOvDisp,		c2;	ClrIntErr, BRANCH[OvGood1, OvBad1, 2],	c3;{Can we do a MesaIntBr?  Is MesaInt stuck 0? Secondary test of ClrIntErr & MesaIntRq.}OvGood1:	MesaIntRq,			c1, at[076];	MesaIntBr,			c2;	BRANCH[MIBad0, MIGood0],	c3;{Is MesaInt stuck 1?}MIGood0:	Noop,				c1, at[0CD];	MesaIntRq,			c2;	MesaIntRq,			c3;	ClrIntErr,	c1;	MesaIntBr,	c2;	BRANCH[MIGood1, MIBad1],	c3,;{R0 register test.  Can we write R0 with 0's?}MIGood1:	R0 _ 0				,c1, at[110];	[] _ R0, ZeroBr			,c2;	BRANCH[R0ZeroBad, R0ZeroGd]	,c3;{Can we write R0 with 1's?}R0ZeroGd:	R0 _ ~R0 xor R0,		c1, at[0CF];	R2 _ ~R0, ZeroBr,		c2;	BRANCH[R0OneBad, QTest],	c3;{Q register test.  Can we write Q with 0's?}QTest:	Q _ 0				,c1, at[113];	[] _ Q, ZeroBr			,c2;	BRANCH[QZeroBad, QZeroGd]	,c3;{Can we write Q with 1's?}QZeroGd:	Q _ ~R0 xor R0		,c1, at[0E1];	[] _ ~Q, ZeroBr		,c2;	BRANCH[QOneBad, QOneGd]	,c3;{Can we do a NibCarryBr?  Is NibCarry stuck 0?}QOneGd:	R0 _ 0,						c1, at[115];	[] _ -R0 {doens't use x bus}, NibCarryBr,	c2;	BRANCH[NibCBad0, NibCGood0],			c3;{Is NibCarry stuck 1?}NibCGood0:	R0 _ 0,			c1, at[0E3];	[] _ R0 + 0, NibCarryBr,	c2;	BRANCH[NibCGood1, NibCBad1],	c3;{Can we do a PgCarryBr? Is PageCarry stuck 0? (add test)}NibCGood1:	R0 _ ~R0 xor R0,	c1, at[116];	[] _ R0 + 1, PgCarryBr,		c2;	BRANCH[PgCyBad0, PgCyGood0],	c3;{Is PageCarry stuck 1? (add test)}PgCyGood0:	R0 _ 0,			c1, at[0E5];	[] _ R0 + 0, PgCarryBr,		c2;	BRANCH[PgCyGood1, PgCyBad1],	c3;{Can we do a PgCrossBr?  Is PageCross stuck 0? (subtract test) Does aF.2 flip result?}PgCyGood1:	R0 _ 0,			c1, at[118];	[] _ R0 - 1, PgCrOvDisp,	c2;	BRANCH[PgCBad0a, PgCGood0a, 1],	c3;{Is PageCross stuck 1? (subtract test)}PgCGood0a:	R0 _ 1,			c1, at[067];	[] _ R0 - 1, PgCrOvDisp,	c2;	BRANCH[PgCGood1a, PgCBad1a, 1],	c3;{Is PageCross stuck 0? (add test)}PgCGood1a:	R0 _ ~R0 xor R0,	c1, at[079];	[] _ R0 + 1, PgCrOvDisp,	c2;	BRANCH[PgCBad0b, PgCGood0b, 1],	c3;{Is PageCross stuck 1? (add test)}PgCGood0b:	R0 _ 0,			c1, at[06B];	[] _ R0 + 0, PgCrOvDisp,	c2;	BRANCH[PgCGood1b, PgCBad1b, 1],	c3;{Can we do a CarryBr?  Is Carry stuck 0?}PgCGood1b:	R0 _ ~R0 xor R0,	c1, at[0B1];	[] _ R0 + 1, CarryBr,		c2;	BRANCH[CarryBad0, CarryGood0],	c3;{Is Carry stuck 1?}CarryGood0:	R0 _ 0,			c1, at[0E7];	[] _ R0 + 0, CarryBr,		c2;	BRANCH[CarryGood1, CarryBad1],	c3;{Can we do a XRefBr?  Is X.11 stuck 0? Secondary test of constant on X.11}CarryGood1:	Xbus _ 0 {precharge X},		c1, at[11A];	Xbus _ (~R0 xor R0) LRot0, XRefBr,	c2;	BRANCH[XRefBad0, XRefGood0],		c3;{Is X.11 stuck 1?}XRefGood0:	Xbus _ (~R0 xor R0) LRot0,{precharge X}	c1, at[0E9];	Xbus _ 0, XRefBr,			c2;	BRANCH[XRefGood1, XRefBad1],	c3;{Can we do a XDisp?  Is X[12-15] stuck 0? Can we put a nibble onto X bus?}{R0,R1 needed across next two tests}XRefGood1:	R0 _ 0, Xbus _ 0 {precharge X},	c1, at[11C];	Xbus _ 0F, XDisp,			c2;	R1 _ R0, ZeroBr, DISP4[XDispT0],	c3;XDispT0:	CANCELBR[XDispBad0],	c1, at[0,10];	CANCELBR[XDispBad0],	c1, at[1,10,XDispT0];	CANCELBR[XDispBad0],	c1, at[2,10,XDispT0];	CANCELBR[XDispBad0],	c1, at[3,10,XDispT0];	CANCELBR[XDispBad0],	c1, at[4,10,XDispT0];	CANCELBR[XDispBad0],	c1, at[5,10,XDispT0];	CANCELBR[XDispBad0],	c1, at[6,10,XDispT0];	CANCELBR[XDispBad0],	c1, at[7,10,XDispT0];	CANCELBR[XDispBad0],	c1, at[8,10,XDispT0];	CANCELBR[XDispBad0],	c1, at[9,10,XDispT0];	CANCELBR[XDispBad0],	c1, at[0A,10,XDispT0];	CANCELBR[XDispBad0],	c1, at[0B,10,XDispT0];	CANCELBR[XDispBad0],	c1, at[0C,10,XDispT0];	CANCELBR[XDispBad0],	c1, at[0D,10,XDispT0];	CANCELBR[XDispBad0],	c1, at[0E,10,XDispT0];{Is X[12-15] stuck 1?}XDispGood0:	Xbus _ 0F {precharge X},  BRANCH[XwdDisp0, $],	c1, at[0F,10,XDispT0];{$}	Xbus _ 0,  XDisp,	c2;	R1 _ R1 + 1, DISP4[XDispT1],	c3;{Is X[9,10] stuck 1?}XwdDisp0:	Xbus _ 0,  XwdDisp,	c2;	R1 _ R1 + 10, DISP4[XDispT1, 0C],	c3;XDispT1:	GOTO[XDispGood1],	c1, at[0,10];	GOTO[XDispBad1],	c1, at[1,10,XDispT1];	GOTO[XDispBad1],	c1, at[2,10,XDispT1];	GOTO[XDispBad1],	c1, at[3,10,XDispT1];	GOTO[XDispBad1],	c1, at[4,10,XDispT1];	GOTO[XDispBad1],	c1, at[5,10,XDispT1];	GOTO[XDispBad1],	c1, at[6,10,XDispT1];	GOTO[XDispBad1],	c1, at[7,10,XDispT1];	GOTO[XDispBad1],	c1, at[8,10,XDispT1];	GOTO[XDispBad1],	c1, at[9,10,XDispT1];	GOTO[XDispBad1],	c1, at[0A,10,XDispT1];	GOTO[XDispBad1],	c1, at[0B,10,XDispT1];	GOTO[XDispGood1],	c1, at[0C,10,XDispT1];	GOTO[XDispBad1],	c1, at[0D,10,XDispT1];	GOTO[XDispBad1],	c1, at[0E,10,XDispT1];	GOTO[XDispBad1],	c1, at[0F,10,XDispT1];{Can we do a XwdDisp?  Is X[9,10] stuck 0?}XDispGood1:	[] _ R0, ZeroBr, {come through here twice}	c2;	R0 _ ~R0 xor R0, BRANCH[XwdGood1, $],	c3;	Xbus _ 0 {precharge X},			c1;	Xbus _ R0 LRot0, XwdDisp,		c2;	[] _ R0, ZeroBr, DISP4[XDispT0, 0C],	c3;{Can we do a YDisp?  Is Y[12-15] stuck 0? Secondary test of nibble}XwdGood1:	Ybus _ 0,		c1, at[11E];	Ybus _ 0F, YDisp,	c2;	DISP4[YDispT0],		c3;YDispT0:	GOTO[YDispBad0],	c1, at[0,10,YDispT0];	GOTO[YDispBad0],	c1, at[1,10,YDispT0];	GOTO[YDispBad0],	c1, at[2,10,YDispT0];	GOTO[YDispBad0],	c1, at[3,10,YDispT0];	GOTO[YDispBad0],	c1, at[4,10,YDispT0];	GOTO[YDispBad0],	c1, at[5,10,YDispT0];	GOTO[YDispBad0],	c1, at[6,10,YDispT0];	GOTO[YDispBad0],	c1, at[7,10,YDispT0];	GOTO[YDispBad0],	c1, at[8,10,YDispT0];	GOTO[YDispBad0],	c1, at[9,10,YDispT0];	GOTO[YDispBad0],	c1, at[0A,10,YDispT0];	GOTO[YDispBad0],	c1, at[0B,10,YDispT0];	GOTO[YDispBad0],	c1, at[0C,10,YDispT0];	GOTO[YDispBad0],	c1, at[0D,10,YDispT0];	GOTO[YDispBad0],	c1, at[0E,10,YDispT0];{Is X[12-15] stuck 1?}YDispGood0:	Ybus _ 0F {precharge Y},	c1, at[0F,10,YDispT0];	Ybus _ 0, YDisp,			c2;	DISP4[YDispT1],				c3;YDispT1:	Xbus _ 0 {precharge X}, GOTO[YDispGood1],	c1, at[0,10,YDispT1];	GOTO[YDispBad1],	c1, at[1,10,YDispT1];	GOTO[YDispBad1],	c1, at[2,10,YDispT1];	GOTO[YDispBad1],	c1, at[3,10,YDispT1];	GOTO[YDispBad1],	c1, at[4,10,YDispT1];	GOTO[YDispBad1],	c1, at[5,10,YDispT1];	GOTO[YDispBad1],	c1, at[6,10,YDispT1];	GOTO[YDispBad1],	c1, at[7,10,YDispT1];	GOTO[YDispBad1],	c1, at[8,10,YDispT1];	GOTO[YDispBad1],	c1, at[9,10,YDispT1];	GOTO[YDispBad1],	c1, at[0A,10,YDispT1];	GOTO[YDispBad1],	c1, at[0B,10,YDispT1];	GOTO[YDispBad1],	c1, at[0C,10,YDispT1];	GOTO[YDispBad1],	c1, at[0D,10,YDispT1];	GOTO[YDispBad1],	c1, at[0E,10,YDispT1];	GOTO[YDispBad1],	c1, at[0F,10,YDispT1];YDispGood1:	Noop,			c2;	Xbus _ (R0 xor R0) LRot12, c3; {use up c2,c3 til next case}{Can we do a XLDisp?  Is X.8 stuck 0? Secondary test of constant on X.8}TestXLDisp:	Noop,					c1, at[15D];	Xbus _ (~R0 xor R0) LRot0, XLDisp,	c2;	BRANCH[X8Bad0, $, 1],			c3;{Is X.8 stuck 1?}X8Test1:	Xbus _ (~R0 xor R0) LRot0 {precharge X},	c1, at[0C3];	Xbus _ 0, XLDisp,				c2;	R0 _ ~R0 xor R0, BRANCH[X8Good1, X8Bad1,1],	c3;{Can we do a XHDisp?  Is X.0 stuck 0? Secondary test of LRot0}X8Good1:	Xbus _ 0 {precharge X},		c1, at[0B5];	Xbus _ (~R0 xor R0) LRot0, XHDisp,	c2;	BRANCH[X0Bad0, X0Good0,2],		c3;{Is X.0 stuck 1?}X0Good0:Xbus _ (~R0 xor R0) LRot0 {precharge X},	c1, at[0C7];	Xbus _ 0, XHDisp,				c2;	R0 _ ~R0 xor R0, BRANCH[NOERROR1, X0Bad1,2],	c3;BranchBad:	RErr _ 1, GOTO[BranchBad],	c*;C2Bad0:	RErr _ 2, GOTO[C2Bad0],	c*;C2Bad1:	RErr _ 3, GOTO[C2Bad1],	c*;C2Bad3:	RErr _ 3, CANCELBR[C2BadIn3],	c*;C2BadIn3:	GOTO[C2BadIn3],	c*;NegBad0:	RErr _ 4, GOTO[NegBad0],	c*;NegBad1:	RErr _ 5, GOTO[NegBad1],	c*;ZeroBad0:	RErr _ 6, GOTO[ZeroBad0],	c*;ZeroBad1:	RErr _ 7, GOTO[ZeroBad1],	c*;NZeroBad0:	RErr _ 8, GOTO[NZeroBad0],	c*;NZeroBad1:	RErr _ 9, GOTO[NZeroBad1],	c*;OvBad0:		RErr _ 0A, GOTO[OvBad0],	c*;OvBad1:		RErr _ 0B, GOTO[OvBad1],	c*;MIBad0:		RErr _ 0C, GOTO[MIBad0],	c*;MIBad1:		RErr _ 0D, GOTO[MIBad1],	c*;R0ZeroBad:	RErr _ 0E, GOTO[R0ZeroBad]	,c*;R0OneBad:	RErr _ 0F, GOTO[R0OneBad]	,c*;QZeroBad:	RErr _ 10, GOTO[QZeroBad]	,c*;QOneBad:	RErr _ 11, GOTO[QOneBad]	,c*;NibCBad0:	RErr _ 12, GOTO[NibCBad0],	c*;NibCBad1:	RErr _ 13, GOTO[NibCBad1],	c*;PgCyBad0:	RErr _ 14, GOTO[PgCyBad0],	c*;PgCyBad1:	RErr _ 15, GOTO[PgCyBad1],	c*;PgCBad0a:	RErr _ 16, GOTO[PgCBad0a],	c*;PgCBad1a:	RErr _ 17, GOTO[PgCBad1a],	c*;PgCBad0b:	RErr _ 18, GOTO[PgCBad0b],	c*;PgCBad1b:	RErr _ 19, GOTO[PgCBad1b],	c*;CarryBad0:	RErr _ 1A, GOTO[CarryBad0],	c*;CarryBad1:	RErr _ 1B, GOTO[CarryBad1],	c*;XRefBad0:	RErr _ 1C, GOTO[XRefBad0],	c*;XRefBad1:	RErr _ 1D, GOTO[XRefBad1],	c*;XDispBad0:	RErr _ 1E, GOTO[XDispBad0],	c*;XDispBad1:	RErr _ 1F, GOTO[XDispBad1],	c*;YDispBad0:	RErr _ 20, GOTO[YDispBad0],	c*;YDispBad1:	RErr _ 21, GOTO[YDispBad1],	c*;X8Bad0:	RErr _ 22, GOTO[X8Bad0],	c*;X8Bad1:	RErr _ 23, GOTO[X8Bad1],	c*;X0Bad0:	RErr _ 24, GOTO[X0Bad0],	c*;X0Bad1:	RErr _ 25, GOTO[X0Bad1],	c*;NOERROR1:	GOTO[NOERROR],	                           	c*;NOERROR:	ClrMPIntIOP,GOTO[NOERROR],      c*, at[0FF1];LoaderCheck:	ClrMPIntIOP,GOTO[LoaderCheck],c*, at[0FFF];
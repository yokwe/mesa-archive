{File name:  <Workstation>mc>Sunlight-O.mc}Reserve[0001,001E];{ For moonBus}Reserve[0020,002E];{ For moonBus}Reserve[0030,003E];{ For moonBus}Reserve[0040,005F];{ For moonBus}Reserve[0060,00FF];{ moonsun1}Reserve[0110,0180];{ moonsun1}Reserve[0181,01FF];{ moonsun2}Reserve[0210,03CF];{ moonsun2}{Reserve[03D0,03FF];{ moonsun3}Reserve[0401,04D2];{ moonsun3}Reserve[04D4,04FF];{ moonsun3}}Reserve[0400];	   { moonsun4}Reserve[0500,05FF];{ moonsun4}Reserve[0600,060F];{ moonsun4}Reserve[0700,070F];{ moonsun4}Reserve[0800,08D2];{ moonsun4}Reserve[08D4,08FF];{ moonsun4}Reserve[0610,06D2];{ moonsun5}Reserve[06D4,06FF];{ moonsun5}Reserve[04D3];	{moontime }Reserve[06D3];	{moontime }Reserve[0710,07FF];{ moontime}Reserve[0AD3,0AD4];{ moontime}Reserve[0900,09FF];{ MoonMr}Reserve[0A00,0AD2];{ For OTHER TEST}Reserve[0AD5,0FEF];{ For OTHER TEST}Reserve[0100,0102];{ For OTHER TEST}Reserve[0104,010F];{ For OTHER TEST}Reserve[0200,0202];{ For OTHER TEST}Reserve[0204,020F];{ For OTHER TEST}Reserve[0FF0,0FF2];{ For OTHER TEST}Reserve[0FF4,0FFE];{ For OTHER TEST}SetTask[0]; StartAddress[TERROR1];TERROR1:R1 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[0];        R6 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[1F];        R8 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[3F];        R1 _ R1 or R6,ClrIE,	c*, at[2F];        R1 _ R1 or R8,	c*, at[103];	        Xbus _ R1 LRot0, XwdDisp,	c*;	DISP2[TrapType],	c*;TrapType:GOTO[Trap],	c*, at[0,4,TrapType];	SetIE,GOTO[START],c*, at[1,4,TrapType];	GOTO[Trap],	c*, at[2,4,TrapType];	GOTO[Trap],	c*, at[3,4,TrapType];Trap:	  GOTO[Trap],   c*;START:	XC2npcDisp, c2;	BRANCH[BadCy, GoodCy, 0D],	c3;BadCy:	Noop,	c*, at[0D,10,GoodCy];	Noop,	c*;	GOTO[START]	c*;	GoodCy:	Noop ,	c1, at[0F,10,BadCy];	Noop,	c2;	GOTO[RrhTest]	c3, at[203];{3b.	R & RH register test.}{Write each R & RH register with its address (R0=0) and complement of address (R0=0FFFF).  "Q xor R0" is the R register address, i.e. Q holds both the address & address complement.}RrhTest:	R0 _ 0		,c1, at[45A];	uSaveTestCnt _ TestCnt	,c2;WriteRAddr1:	Q _ R0 {Q_0 or 0FFFF}	,c3;WriteRAddr:	[] _ Q xor R0, YDisp	,c1;	DISP4[WrRAddr]	,c2;WrRAddr:	R0 _ Q, rhR0 _ Q LRot0, GOTO[WrRAddrL]	,c3, at[0,10,WrRAddr];	R1 _ Q, rhR1 _ Q LRot0, GOTO[WrRAddrL]	,c3, at[1,10,WrRAddr];	R2 _ Q, rhR2 _ Q LRot0, GOTO[WrRAddrL]	,c3, at[2,10,WrRAddr];	R3 _ Q, rhR3 _ Q LRot0, GOTO[WrRAddrL]	,c3, at[3,10,WrRAddr];	R4 _ Q, rhR4 _ Q LRot0, GOTO[WrRAddrL]	,c3, at[4,10,WrRAddr];	R5 _ Q, rhR5 _ Q LRot0, GOTO[WrRAddrL]	,c3, at[5,10,WrRAddr];	R6 _ Q, rhR6 _ Q LRot0, GOTO[WrRAddrL]	,c3, at[6,10,WrRAddr];	R7 _ Q, rhR7 _ Q LRot0, GOTO[WrRAddrL]	,c3, at[7,10,WrRAddr];	R8 _ Q, rhR8 _ Q LRot0, GOTO[WrRAddrL]	,c3, at[8,10,WrRAddr];	R9 _ Q, rhR9 _ Q LRot0, GOTO[WrRAddrL]	,c3, at[9,10,WrRAddr];	RA _ Q, rhRA _ Q LRot0, GOTO[WrRAddrL]	,c3, at[0A,10,WrRAddr];	RB _ Q, rhRB _ Q LRot0, GOTO[WrRAddrL]	,c3, at[0B,10,WrRAddr];	RC _ Q, rhRC _ Q LRot0, GOTO[WrRAddrL]	,c3, at[0C,10,WrRAddr];	RD _ Q, rhRD _ Q LRot0, GOTO[WrRAddrL]	,c3, at[0D,10,WrRAddr];	RE _ Q, rhRE _ Q LRot0, GOTO[WrRAddrL]	,c3, at[0E,10,WrRAddr];	RF _ Q, rhRF _ Q LRot0, GOTO[WrRAddrL]	,c3, at[0F,10,WrRAddr];WrRAddrL:	Q _ Q xor R0	,c1;	Q _ Q + 1, NibCarryBr	,c2;	Q _ Q xor R0, BRANCH[WriteRAddr, ReadRAddr1]	,c3;{Verify the above write.  Each R reg should contain its address or ~address}ReadRAddr1:	Q _ R0 {Q_0 or 0FFFF}, GOTO[ReadRAddrx]	,c1;ReadRAddr2:	[] _ Q xor R0, YDisp, GOTO[ReadRAddrx]	,c1;ReadRAddrx:	DISP4[RdRAddr]	,c2;RdRAddr:	[] _ R0 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0,10,RdRAddr];	[] _ R1 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[1,10,RdRAddr];	[] _ R2 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[2,10,RdRAddr];	[] _ R3 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[3,10,RdRAddr];	[] _ R4 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[4,10,RdRAddr];	[] _ R5 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[5,10,RdRAddr];	[] _ R6 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[6,10,RdRAddr];	[] _ R7 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[7,10,RdRAddr];	[] _ R8 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[8,10,RdRAddr];	[] _ R9 xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[9,10,RdRAddr];	[] _ RA xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0A,10,RdRAddr];	[] _ RB xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0B,10,RdRAddr];	[] _ RC xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0C,10,RdRAddr];	[] _ RD xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0D,10,RdRAddr];	[] _ RE xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0E,10,RdRAddr];	[] _ RF xor Q, ZeroBr, GOTO[RdRAddrL]	,c3, at[0F,10,RdRAddr];{Verify the above write.  Each RH reg should contain its address or ~address}RdRAddrL:	[] _ Q xor R0, YDisp, BRANCH[RBad, RGood]	,c1;RGood:	Q _ Q and 0FF, DISP4[RdRHAddr]	,c2;RdRHAddr:	[] _ rhR0 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0,10,RdRHAddr];	[] _ rhR1 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[1,10,RdRHAddr];	[] _ rhR2 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[2,10,RdRHAddr];	[] _ rhR3 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[3,10,RdRHAddr];	[] _ rhR4 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[4,10,RdRHAddr];	[] _ rhR5 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[5,10,RdRHAddr];	[] _ rhR6 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[6,10,RdRHAddr];	[] _ rhR7 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[7,10,RdRHAddr];	[] _ rhR8 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[8,10,RdRHAddr];	[] _ rhR9 xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[9,10,RdRHAddr];	[] _ rhRA xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0A,10,RdRHAddr];	[] _ rhRB xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0B,10,RdRHAddr];	[] _ rhRC xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0C,10,RdRHAddr];	[] _ rhRD xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0D,10,RdRHAddr];	[] _ rhRE xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0E,10,RdRHAddr];	[] _ rhRF xor Q, ZeroBr, GOTO[RdRHAddrL]	,c3, at[0F,10,RdRHAddr];RdRHAddrL:	R0 _ R0 and ~0FF, BRANCH[RHBad, RHGood]	,c1;RHGood:	Q _ Q or R0 {restore Q to 0 or 0FFFF}	,c2;	R0 _ (R0 LRot8) or R0 {restore R0 to 0 or 0FFFF}	,c3;	Q _ Q xor R0	,c1;	Q _ Q + 1, NibCarryBr	,c2;	Q _ Q xor R0, BRANCH[ReadRAddr2, $]	,c3;	[] _ R0, ZeroBr	,c1;	R0 _ ~R0 {R0_0FFFF}, BRANCH[LinkTest, WriteRAddr1]	,c2;{3c.	Link Register tests. Write each link with address (Q=0) & ~address (Q=0FFFF). R1 holds data from link register, R0 is the address.}{Write Links with their address}LinkTest:	L0 _ 0, TestCnt _ uSaveTestCnt	,c3, at[402];	L1 _ 1, TestCnt _ TestCnt + 1 {TestCnt=8}	,c1;	L2 _ 2	,c2;	L3 _ 3	,c3;	L4 _ 4	,c1;	L5 _ 5	,c2;	L6 _ 6	,c3;	L7 _ 7, Q _ 0	,c1;	R0 _ 0, GOTO[RdLAddr]	,c2;{Verify the above write.  Each Link reg should contain its address or complement address}ReadLAddr:	[] _ R0, YDisp	,c1;	DISP3[RdLAddr]	,c2;RdLAddr:	L0Disp, GOTO[RdLAddrL]	,c3, at[0,10,RdLAddr];	L1Disp, GOTO[RdLAddrL]	,c3, at[1,10,RdLAddr];	L2Disp, GOTO[RdLAddrL]	,c3, at[2,10,RdLAddr];	L3Disp, GOTO[RdLAddrL]	,c3, at[3,10,RdLAddr];	L4Disp, GOTO[RdLAddrL]	,c3, at[4,10,RdLAddr];	L5Disp, GOTO[RdLAddrL]	,c3, at[5,10,RdLAddr];	L6Disp, GOTO[RdLAddrL]	,c3, at[6,10,RdLAddr];	L7Disp, GOTO[RdLAddrL]	,c3, at[7,10,RdLAddr];RdLAddrL:	DISP4[LinkValue]	,c1;LinkValue:	R1 _  0 , GOTO[LinkValueL]	,c2, at[0,10,LinkValue];	R1 _  1 , GOTO[LinkValueL]	,c2, at[1,10,LinkValue];	R1 _  2 , GOTO[LinkValueL]	,c2, at[2,10,LinkValue];	R1 _  3 , GOTO[LinkValueL]	,c2, at[3,10,LinkValue];	R1 _  4 , GOTO[LinkValueL]	,c2, at[4,10,LinkValue];	R1 _  5 , GOTO[LinkValueL]	,c2, at[5,10,LinkValue];	R1 _  6 , GOTO[LinkValueL]	,c2, at[6,10,LinkValue];	R1 _  7 , GOTO[LinkValueL]	,c2, at[7,10,LinkValue];	R1 _  8 , GOTO[LinkValueL]	,c2, at[8,10,LinkValue];	R1 _  9 , GOTO[LinkValueL]	,c2, at[9,10,LinkValue];	R1 _ 0A , GOTO[LinkValueL]	,c2, at[0A,10,LinkValue];	R1 _ 0B , GOTO[LinkValueL]	,c2, at[0B,10,LinkValue];	R1 _ 0C , GOTO[LinkValueL]	,c2, at[0C,10,LinkValue];	R1 _ 0D , GOTO[LinkValueL]	,c2, at[0D,10,LinkValue];	R1 _ 0E , GOTO[LinkValueL]	,c2, at[0E,10,LinkValue];	R1 _ 0F , GOTO[LinkValueL]	,c2, at[0F,10,LinkValue];LinkValueL:	R1 _ R1 xor Q	,c3;	R1 _ R1 and 0F	,c1;	Noop	,c2;	[] _ R0 xor R1, ZeroBr	,c3;	BRANCH[LinkBad, LinkGood]	,c1;LinkGood:	[] _ R0 xor 7, ZeroBr	,c2;	R0 _ R0 + 1, BRANCH[ReadLAddr, $]	,c3;	Noop	,c1;	[] _ Q, ZeroBr	,c2;	BRANCH[UTest, WrLCAddr]	,c3;{WriteLinks with ~address.}WrLCAddr:	Q _ ~Q {Q_0FFFF}	,c1;	L0 _ 0F	,c2;	L1 _ 0E	,c3;	L2 _ 0D	,c1;	L3 _ 0C	,c2;	L4 _ 0B	,c3;	L5 _ 0A	,c1;	L6 _ 9	,c2;	L7 _ 8, R0 _ 0, GOTO[ReadLAddr]	,c3;{3d.	SU regs test}{Simple U reg tests.  Can we write UA5 with 0's?}UTest:	UA5 _ 0, CANCELBR[$, 0F]	,c1, at[42A];	[] _ UA5, ZeroBr	,c2;	TestCnt _ TestCnt + 1 {TestCnt=9}, BRANCH[UA5ZeroBad, UA5ZeroGd]	,c3;{Can we write UA5 with 1's?}UA5ZeroGd:	UA5 _ ~RA xor RA	,c1, at[3D5];	[] _ ~UA5, ZeroBr	,c2;	BRANCH[UA5OneBad, UA5OneGd]	,c3;{Can we write U5A with 0's?}UA5OneGd:	U5A _ 0, CANCELBR[$, 0F]	,c1, at[42D];	[] _ U5A, ZeroBr	,c2;	Q _ 0, BRANCH[U5AZeroBad, U5AZeroGd]	,c3;{Can we write U5A with 1's?}U5AZeroGd:	U5A _ ~R5 xor R5	,c1, at[3D7];	[] _ ~U5A, ZeroBr	,c2;	BRANCH[U5AOneBad, U5AOneGd]	,c3;{Can we address U5A via AltUaddr?}U5AOneGd:	R0 _ 0A,		c1, at[42F];	U5A _~R5 xor R5,	c2;	Noop,			c3;	[] _ R0, AltUaddr	,c1;	[] _ ~U5, ZeroBr	,c2;	Q _ 0, BRANCH[U5OneBad, WriteUAddr2]	,c3;{Complete U reg test. Write all U regs with their addresses (Q=0) and with the inverse of their address (Q=0FFFF). R0 holds U addr.}WriteUAddrS:	Q _ 0,				c1, at[4A5];		Q _ 0,				c2;		Q _ 0,				c3;WriteUAddr2:	R0 _ 0, GOTO[WriteUAddrx] {Q=0}	,c1;WriteUAddr1:	R0 _ 0, GOTO[WriteUAddrx]	,c1;WriteUAddr:	Xbus _ R0 LRot12, XDisp	,c1;WriteUAddrx:	R0 _ R0 xor Q, Ybus _ R0, AltUaddr, DISP4[WrUAddr]	,c2;WrUAddr:	U0 _ R0, GOTO[WrUAddrL]	,c3, at[0,10,WrUAddr];	U1 _ R0, GOTO[WrUAddrL]	,c3, at[1,10,WrUAddr];	U2 _ R0, GOTO[WrUAddrL]	,c3, at[2,10,WrUAddr];	U3 _ R0, GOTO[WrUAddrL]	,c3, at[3,10,WrUAddr];	U4 _ R0, GOTO[WrUAddrL]	,c3, at[4,10,WrUAddr];	U5 _ R0, GOTO[WrUAddrL]	,c3, at[5,10,WrUAddr];	U6 _ R0, GOTO[WrUAddrL]	,c3, at[6,10,WrUAddr];	U7 _ R0, GOTO[WrUAddrL]	,c3, at[7,10,WrUAddr];	U8 _ R0, GOTO[WrUAddrL]	,c3, at[8,10,WrUAddr];	U9 _ R0, GOTO[WrUAddrL]	,c3, at[9,10,WrUAddr];	UA _ R0, GOTO[WrUAddrL]	,c3, at[0A,10,WrUAddr];	UB _ R0, GOTO[WrUAddrL]	,c3, at[0B,10,WrUAddr];	UC _ R0, GOTO[WrUAddrL]	,c3, at[0C,10,WrUAddr];	UD _ R0, GOTO[WrUAddrL]	,c3, at[0D,10,WrUAddr];	UE _ R0, GOTO[WrUAddrL]	,c3, at[0E,10,WrUAddr];	UF _ R0, GOTO[WrUAddrL]	,c3, at[0F,10,WrUAddr];WrUAddrL:	R0 _ R0 xor Q	,c1;	R0 _ R0 + 1, PgCarryBr	,c2;	BRANCH[WriteUAddr, ReadUAddr1]	,c3;{Verify the above write.  Each U reg should contain its address or complement address}ReadUAddr2:	CANCELBR[ReadUAddr]	,c3;ReadUAddr1:	R0 _ 0, GOTO[ReadUAddrx]	,c1;ReadUAddr:	Xbus _ R0 LRot12, XDisp	,c1;ReadUAddrx:	[] _ R0, AltUaddr, DISP4[RdUAddr]	,c2;RdUAddr:	R1 _ U0 , GOTO[RdUAddrL]	,c3, at[0,10,RdUAddr];	R1 _ U1 , GOTO[RdUAddrL]	,c3, at[1,10,RdUAddr];	R1 _ U2 , GOTO[RdUAddrL]	,c3, at[2,10,RdUAddr];	R1 _ U3 , GOTO[RdUAddrL]	,c3, at[3,10,RdUAddr];	R1 _ U4 , GOTO[RdUAddrL]	,c3, at[4,10,RdUAddr];	R1 _ U5 , GOTO[RdUAddrL]	,c3, at[5,10,RdUAddr];	R1 _ U6 , GOTO[RdUAddrL]	,c3, at[6,10,RdUAddr];	R1 _ U7 , GOTO[RdUAddrL]	,c3, at[7,10,RdUAddr];	R1 _ U8 , GOTO[RdUAddrL]	,c3, at[8,10,RdUAddr];	R1 _ U9 , GOTO[RdUAddrL]	,c3, at[9,10,RdUAddr];	R1 _ UA , GOTO[RdUAddrL]	,c3, at[0A,10,RdUAddr];	R1 _ UB , GOTO[RdUAddrL]	,c3, at[0B,10,RdUAddr];	R1 _ UC , GOTO[RdUAddrL]	,c3, at[0C,10,RdUAddr];	R1 _ UD , GOTO[RdUAddrL]	,c3, at[0D,10,RdUAddr];	R1 _ UE , GOTO[RdUAddrL]	,c3, at[0E,10,RdUAddr];	R1 _ UF , GOTO[RdUAddrL]	,c3, at[0F,10,RdUAddr];RdUAddrL:	R1 _ R1 xor Q	,c1;	[] _ R1 xor R0, ZeroBr	,c2;	BRANCH[UBad, UGood]	,c3;UGood:	R0 _ R0 + 1, PgCarryBr	,c1;	[] _ Q, ZeroBr, BRANCH[ReadUAddr2, $]	,c2;	Q _ ~Q, BRANCH[STKtst, WriteUAddr1]	,c3;{check stackP addressing.  Read low 16 U registers via stackP}STKtst:	R0 _ 0,			c1, at[480];	Ybus _ R0, YDisp,	c2;ReWriteL:	DISP4[ReWrite],		c3;ReWrite:	U00 _ R0, GOTO[ReLoop],	c1,at[00,10,ReWrite];	U01 _ R0, GOTO[ReLoop],	c1,at[01,10,ReWrite];	U02 _ R0, GOTO[ReLoop],	c1,at[02,10,ReWrite];	U03 _ R0, GOTO[ReLoop],	c1,at[03,10,ReWrite];	U04 _ R0, GOTO[ReLoop],	c1,at[04,10,ReWrite];	U05 _ R0, GOTO[ReLoop],	c1,at[05,10,ReWrite];	U06 _ R0, GOTO[ReLoop],	c1,at[06,10,ReWrite];	U07 _ R0, GOTO[ReLoop],	c1,at[07,10,ReWrite];	U08 _ R0, GOTO[ReLoop],	c1,at[08,10,ReWrite];	U09 _ R0, GOTO[ReLoop],	c1,at[09,10,ReWrite];	U0A _ R0, GOTO[ReLoop],	c1,at[0A,10,ReWrite];	U0B _ R0, GOTO[ReLoop],	c1,at[0B,10,ReWrite];	U0C _ R0, GOTO[ReLoop],	c1,at[0C,10,ReWrite];	U0D _ R0, GOTO[ReLoop],	c1,at[0D,10,ReWrite];	U0E _ R0, GOTO[ReLoop],	c1,at[0E,10,ReWrite];	U0F _ R0, GOTO[UnLoop],	c1,at[0F,10,ReWrite];ReLoop:	Ybus _ R0 _ R0 +1 , YDisp, GOTO[ReWriteL],	c2;UnLoop:	R0 _ stackP _ 0	,c2;STKLp:	Xbus _ 0 {precharge X}	,c3;	Q _ STK xor R0, NZeroBr	,c1;	R0 _ R0 + 1, NibCarryBr, BRANCH[$, STKAddrBad]	,c2;	BRANCH[$, NOERROR1]	,c3;	push,		c1;	GOTO[STKLp],	c2;{R0 contains the U reg address, R1 contains the data from the U reg (or compl of data if Q=0FFF}UBad:	RErr _ 75, GOTO[UBad]	,c*;U5OneBad:	RErr _ 76, GOTO[U5OneBad]	,c*;UA5ZeroBad:	RErr _ 77, GOTO[UA5ZeroBad]	,c*;UA5OneBad:	RErr _ 78, GOTO[UA5OneBad]	,c*;U5AOneBad:	RErr _ 79, GOTO[U5AOneBad]	,c*;U5AZeroBad:	RErr _ 7A, GOTO[U5AZeroBad]	,c*;STKAddrBad:	RErr _ 0B0, CANCELBR[STKAddrBad1]	,c*;STKAddrBad1:	RErr _ 0B0, GOTO[STKAddrBad1]	,c*;{Q holds the R register address (or ~Q if R0=0FFFF).}RBad:	RErr _ 7B, CANCELBR[RBad1, 0F]	,c*;RBad1:	RErr _ 7B, GOTO[RBad1]	,c*;{Q holds the RH register address (or ~Q if R0=0FFFF).}RHBad:	RErr _ 7C, GOTO[RHBad]	,c*;{R0 is the link address.  R1 holds the contents of the Link reg.}LinkBad:	RErr _ 7D, GOTO[LinkBad]	,c*;NOERROR1:	GOTO[NOERROR],	                           	c*;NOERROR:	ClrMPIntIOP,GOTO[NOERROR],   	c*, at[0FF3];LoaderCheck:	ClrMPIntIOP,GOTO[LoaderCheck],c*, at[0FFF];
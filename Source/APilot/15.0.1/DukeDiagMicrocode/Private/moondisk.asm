$	DEBUG MOD186;MoonDisk.asm -- Test RDC, FIFO and DMA to main memory	NAME	FIFODiskTest$	NOLIST ;Next lines includes Moonsys.def and Moonlink.def	$	INCLUDE(Moonsys.def)$	INCLUDE(Moonlink.def)$	LIST		;Previous lines included Moonsys.def and Moonlink.def;	ASSUME	CS:MonitorCode, SS:MonitorCode, DS:MonitorCode;;	FIFOtest Equates;FixDOB		EQU	TestCodeLoc2	;need even page (200H) boundaryFixSecBuf	EQU	FixDOB + 200H	;need even page boundaryEnFIFODisk	EQU	0DFF3HWrite2942CR	EQU	0200h	;port for Control Reg writeRead2942CR	EQU	0202h	;port to read Control RegRead2942WC	EQU	0204h	;port to read Word CounterRead2942AC	EQU	0206h	;port to read Address CounterDmaAddr23to9	EQU	0208h	;write upper addr bits, init 2942 countersDmaAddr8to1	EQU	020Ah	;write Address CounterDmaWordCount	EQU	020Ch	;write Word Counter (user 2's comp (mode 3))DmaStatus	EQU	0210h	;write DMA command (direction), read StatusRDCCtrlStatus	EQU	0214h	;write command, read statusPresetFIFOIn17	EQU	0212h	;bit 17 set during xfer into FIFOStartDma	EQU	0216h	;It matters not what is writtenAllowRDCCmd	EQU	00F4hResetStatus	EQU	020BBHEmptyStatus	EQU	0E8FFHToFIFO		EQU	00001HFIFOIn		EQU	0FFFEHDiskNoMemParity	EQU	80HDiskNoStop	EQU	1;Control CommandGoIdle		EQU	0GetDOB		EQU	1DoCmd		EQU	2RetDOB		EQU	3;Control StutusComplete	EQU	40H;Disk CommandRestore		EQU	0Format		EQU	1ReadDt		EQU	2WriteDt		EQU	3WriteLbDt	EQU	4ReadLb		EQU	5ReadLbDt	EQU	6VerifyDt	EQU	7;; Faults;WriteReadCRerr	EQU	 1BadDmaStatus	EQU	 2BadAddrCount	EQU	 4BadWordCount	EQU	 8OvrWrtErr	EQU	10HDiskIdlErr	EQU	20HDiskCtlErr	EQU	21HDiskDrvErr	EQU	22HHdrErr		EQU	23HLblErr		EQU	24HDatErr		EQU	25HLstErr		EQU	2FH	;shouldn't get.  one of three above insteadRestoreErr	EQU	30HFormatErr	EQU	31HRdDtaErr	EQU	32HWrDtaErr	EQU	33HWrLbDtErr	EQU	34HRdLblErr	EQU	35HRdLbDtErr	EQU	36HVerDtaErr	EQU	37HDiskCmdErr	EQU	3FH	;general purpose err (see ObservedData)CmdCmpletErr	EQU	40HRetDOBInErr	EQU	41HFIFONotHeld	EQU	42HRDCNotHeld	EQU	43HTooManyBadTrk	EQU	44HNoGoodTracks	EQU	45HNoXpctdVrErr	EQU	46HPassErrLogged	EQU	80HDataError	EQU	 100H	;IOPFault*100HNoexpctdInt	EQU	2000HUnexpctdInt	EQU	4000H;; Errors logged per pass for PassCtl bits 5,4 = 11B;LgWrLbDtErr	EQU	 1HLgWrDtErr	EQU	 2HLgRdLbErr	EQU	 4HLgRdLbDtErr	EQU	 8HLgRdDtErr	EQU	10HLgVrErr		EQU	20H;;	Test Control Block;FIFODiskTCB	STRUCDiskErrCtl	DB ?SkipTest	DB ?PageParity	DB 0BankParity	DB 0Passes		DB ?	;7EH maxCurrentPass	DB ?DmaArea		DB ?	;3LSB picks area for Xfer (FIFO/Dma test)	;0 = 007400 (starting BYTE address)	;/// want 4400	;1 = 008400				;/// want 4800	;2 = 008800				;/// want 5000	;3 = 008C00				;/// want 6000	;4 = 00C000	;5 = 010000	;6 = 014000	;7 = 01BC00PassCtl		DB ?	; flags to control each pass	;Bits numbered 7(MSB),6,5...0(LSB)	;01H = 0 = Do FIFO/Dma test	(Bit 0)	;    = 1 = Do disk test		(Bit 0)	;02H = add AddLen to WordLen after each pass (FIFO/Dma test)	;    = 1 = lag RDC,  = 0 = lag IOP (disk test)	;04H = increment DmaArea after each pass (FIFO/Dma test)	;    = do Restore-Recalibrate before each disk operation 	;	subloop (disk test)	;08H = do Get/Return command block after pass (FIFO/Dma test)	;	;//// above yet to be implemented	;    = do Format on tracks used before each pass and build a Bad Track	;       table.  Good tracks are used for Bits 5,4 = 01, 10, 11 below.	;	(disk test)  	;	;Bits 5,4: (disk test)	;    = 00 = check that Verify detects a label or data error on	;	     at least one sector on all tracks specified.	;    = 01 = do Write operations (Write Label and Data, Write Data).	;    = 10 = do Read and Verify operations.	;    = 11 = do all Write, Read, and Verify operations, log 1st error in	;	    each subloop (Write Label and Data, Write Data, Read Label,		;	    Read Label and Data, Read Data, Verify) and report	;	    errors if any at end of each pass.  **OVERRIDES DiskErrCtl 	;	    to stop on error or start new pass on error**	;	;40H = do double sector operations if possible (disk test)	;//// to be implemented	 ;   = use NumbSecs (presently "Reserved	DB ?" in TCB) for number 	 ;	of sectors to read or write.  Minimum 1, Maximum 3. (disk test) 	;80H = use Header data for Data data (disk test)	StartData	DW ?AddData		DW ?WordLen		DB ?	; 0 = 256 words/Xfer (FIFO/Dma test)AddLen		DB ?	; e.g.: WordLen=250, AddLen=10 then next Xfer length			;        is (250+10) mod 256 = 4 words (FIFO/Dma test)			; e.g.: if CurCyl=0,CurHead=0,CurSec=0,SecPTrk=10H			;	 and AddLen=12H, then next sector(s) tested at			;	 Cyl=0,Head=1,Sec=2FIFOInat	DW ?	; starting address of current Xfer in from FIFO			;  (add 10000 if DmaArea > 4 and FIFO/Dma test)ExpectedData	DW ?ObservedData	DW ?Errat		DW ?	; address of last error			;  (add 10000 if DmaArea > 4 and FIFO/Dma test)Mask8bitReg	DB ?	; 1 bits are those testedExpectedVal	DB ?ObservedVal	DB ?	; corresponding 0 Mask bits are don't caresAllows		DB ?	; cleared each pass, incremented each time arbitor			;  was commanded to AllowRDCCmdTestFaults	DW ?	; Flags defined aboveErrCount	DW ?	; # of data errors during test.Reserved	DB ?	; remainder of TCB used only by **(disk test)**LogSubErrs	DB ?	; Bits 7(MSB), 6, 5, ...0 for PassCtl bits 5,4 = 11B			; 01 = Read Label Error			; 02 = Read Label and Data Error			; 04 = Read Data Error			; 08 = Verify Error			; 10 = Write Label and Data Error			; 20 = Write Data ErrorAddSec		DW ?StartCy		DW ?StartHd		DB ?StartSec	DB ?EndCy		DW ?EndHd		DB ?EndSec		DB ?CurCy		DW ?CurHd		DB ?CurSec		DB ?EndTCBFIFODiskTCB		ENDSMonitorCode	SEGMENT COMMON		ORG	TestCodeLoc	JMP StartOfTest	jmp DiskPreProcess	jmp DiskFRUList	jmp DiskDummy	jmp DiskDummy	jmp DiskDummy	jmp DiskDummy		ORG	DiskTestCodeLoc;; "Data segment" ;Areas		DW	 7400H	;///		DW	 8400H	;///		DW	 8800H	;///		DW	 8C00H	;///		DW	0C000H		DW	 0000H		DW	 4000H		DW	0BC00HMemArea		DW	?Blk1		DW	?Blk2		DW	?ByteLen		DW	?WCIn2sComp	DW	?Remaining	DW	?	PassFaults	DW	0DmaIntrCount	DW	0RDCIntrCount	DW	0DmaStatusStored		DW	0DmaStatusWaiting	DW	0ExpectdCyl	DW	0ExpectdHd	DB	0ExpectdSec	DB	0ExpectdFPLo	DW	0ExpectdFPHi	DW	0NxtCyl		DW	0NxtHd		DB	0NxtSec		DB	0RetryCount	DB	0NoGoodTrack	DB	?SubErr		DB	0SavePassCtl	DB	0SaveStartData	DW	0SaveAddData	DW	0TableIndex	DW	0Trydex		DW	0Lessdex		DW	0Plus1		DB	0Minus1		DB	0;--------------------------------DiskDummy:    Ret StartOfTest:; Set up RDCdma Interrupt task, initialize for test	MOV	BX,[SI].TCBPointer	; Get TCB pointer	MOV	[BX].CurrentPass, 1	; Start off on 1st pass	MOV	[BX].TestFaults, 0	; No problems yet	MOV	PassFaults, 0		;for debug restart	MOV	[BX].ErrCount, 0	; No data errors yet	MOV	DX, Map1IOP	MOV	AX, 0	OUT	DX, AL	; set Map reg 1 to 00h	MOV	AX, 2000H	MOV	ES, AX	CALL	SetDmaIntVectors	; Establish RDCdma interrupt vector 					;  also resets DMA which should clear					;  the status error bit	MOV	DX, RDCCtrlStatus	MOV	AL, 0	OUT	DX, AL		;tell controller to go idle	   	CALL	ResetDmaRDCInts		MOV	AX, CyPD	;worst case wait for no restore from prev. testOutWait:	MOV	CX, 1000HInWait:	LOOP	InWait	DEC	AX	JNZ	OutWait	CMP	PassFaults, 0		; Did reset DMA clear error bit	JE	CkCR	JMP	ErrExit		; All passes done if 1st reset fails;DTestDone:		RET	;to MonitorCkCR:; Test Write/Read of 2942 Control Register	MOV	DX, Write2942CR	MOV	AX, 8		;CR bits 2-0 = 100	OUT	DX, AX	MOV	DX, Read2942CR	IN	AX, DX	AND	AX, 0EH	CMP	AL, 8	JE	SetMode3	OR	[BX].TestFaults, WriteReadCRerr	;set error	MOV	[BX].Mask8bitReg, 0EH	MOV	[BX].ExpectedVal, 08H	MOV	[BX].ObservedVal, AL	JMP	TerrExit		;no faults in CR toleratedSetMode3:	MOV	DX, Write2942CR	MOV	AX, 6		;CR bits 2-0 = 011	OUT	DX, AX	MOV	DX, Read2942CR	IN	AX, DX	AND	AX, 0EH	CMP	AL, 6	JE	CRSet	OR	[BX].TestFaults, WriteReadCRerr	MOV	[BX].Mask8bitReg, 0EH	MOV	[BX].ExpectedVal, 06H	MOV	[BX].ObservedVal, AL	JMP	TerrExitCRSet:	TEST	[BX].PassCtl, 1	JZ	Pass	CALL	InitParm	MOV	[BX].LogSubErrs, 0;----------Pass: ;----;----------	MOV	AL, [BX].CurrentPass	CMP	AL, [BX].Passes	JLE	OneMorePass	JMP	DTestDoneOneMorePass:	MOV	DmaIntrCount,0	MOV	RDCIntrCount,0	TEST	[BX].PassCtl, 1	JNZ	DoRDC	JMP	OnlyFifoDoRDC:	MOV	Passfaults, 0	MOV	SubErr, 0	MOV	[BX].Allows, 0	;clear count of allow commands	MOV	DX, RDCCtrlStatus	IN	AL, DX	CMP	AL, 0		;controller not in idle state	JE	Noreset	CALL	ResetDmaRDCInts	JZ	resetokPassout:	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	PassRDC	JMP	ErrExitPassRDC:	JMP	EndPassPassim:	;log error is in SubErr	MOV	AL, [BX].PassCtl	AND	AL, 30H	;logging 1st errors?	CMP	AL, 30H	JE	RetCaller	POP	AX	;up one level	JMP	PassoutRetCaller:	MOV	AL, SubErr	OR	[BX].LogSubErrs, AL	CALL	ResetOnly	;we can only try our best	RETresetok:	CALL	IdleCtler	JZ	IdleOK	JMP	PassoutIdleOK:	CALL	RestorePerOp	;allow heads to come back for this pass	JZ	ResetIdlRestOK	JMP	PassoutResetIdlRestOK:Noreset:	TEST	[BX].PassCtl, 8 ;do we format from Start to End for each pass?	JZ	Formed	TEST	[BX].PassCtl, 4		;Restore flag	JZ	NoRestore	CALL	RestorePerOp	JZ	Restored	JMP	PassoutNoRestore:Restored:	CALL	ExtDoRunTimeWork	CALL	GoFormat	JZ	Formed	JMP	PassoutFormed:	CALL	ExtDoRunTimeWork	MOV	AX, CyPD	SHL	AX, 4	PUSH	BX	MOV	BX, OFFSET BadTrackTbl	MOV	CX, 32		;max number of bad tracks allowed		Tabloop:	MOV	[BX], AX	;Clear table entry (invalid cylinder)	INC	BX	INC	BX	LOOP	Tabloop	MOV	TableIndex, 0 	;initialize the index to the last bad track	POP	BX	TEST	[BX].PassCtl, 8	;formatting tracks used?	JNZ	BuildBad	JMP	TableDone	;leave all tracks OK if we don't formatBuildBad: ;Track Table	MOV	AL, [BX].PassCtl	MOV	SavePassCtl, AL	MOV	AX, [BX].StartData	MOV	SaveStartData, AX	MOV	AX, [BX].AddData	MOV	SaveAddData, AX	MOV	AX, 0001H	MOV	[BX].StartData, AX	MOV	AX, 0202H	MOV	[BX].AddData, AX	MOV	AL, SavePassCtl	AND	AL, 0BFH	;mask out double sectors	MOV	[BX].PassCtl, AL	CALL	CopyStartHdrTrackLoop:	MOV	Sec, 0	MOV	[BX].CurSec, 0VSecLoop:	CALL	ExtDoRunTimeWork	MOV	RetryCount, 1	;mark 1 retry for this sec	CALL	CalcCurFP	CALL	CopyCurToExpectd	CALL	CalcExpFPVRetry:	CALL	FillSecBuf	CALL	VerSec	JZ	SecOK	CMP	PassFaults, HdrErr	JE	IsItRealBad	CMP	PassFaults, LblErr	JE	IsItRealBad	CMP	PassFaults, DatErr	JE	IsItRealBad	CMP	PassFaults, LstErr	JE	IsItRealBadUnsave:	MOV	AL, SavePassCtl	MOV	[BX].PassCtl, ALLessUn:	MOV	AX, SaveStartData	MOV	[BX].StartData, AX	MOV	AX, SaveAddData	MOV	[BX].AddData, AX	JMP	Passout		;some other error than bad mediaSecOK:	MOV	DX, 1	;verify next sector	CALL	CalcNxtHdr	JNZ	Tabled	CALL	PutNxtToCurHdr	JMP	VSecLoopIsItRealBad:	MOV	PassFaults, 0	;we expect occasional soft disk errors	CMP	RetryCount, 0	JE	EntrBadTrk	DEC	RetryCount	MOV	DX, RDCCtrlStatus	MOV	AL, GoIdle	OUT	DX, AL	JMP	VRetry		;FIFO should at least be empty againEntrBadTrk:	CMP	TableIndex, 32	JL	NewBadOK	MOV	PassFaults, 0	;clear H/L/D error	OR	PassFaults, TooManyBadTrk	JMP	UnsaveNewBadOK:	MOV	DI, TableIndex	ADD	DI, DI	;make word index	MOV	AL, Head	AND	AL, 0FH	;assumes 15 or less heads per cylinder, and			;4095 or les cylinders per drive	MOV	DX, Cyl	SHL	DX, 4	OR	DL, AL	PUSH	BX	MOV	BX, OFFSET BadTrackTbl	MOV	[BX + DI], DX	POP	BX	INC	TableIndex	MOV	DH, 0	MOV	DL, SecPTrk	CALL	CalcNxtHdr	JNZ	Tabled	CALL	PutNxtToCurHdr	JMP	TrackLoopTabled:	MOV	PassFaults, 0	;in case any were left over thru SecOK	MOV	AL, SavePassCtl	MOV	[BX].PassCtl, AL	MOV	AX, SaveStartData	MOV	[BX].StartData, AX	MOV	AX, SaveAddData	MOV	[BX].AddData, AXTableDone:	MOV	AL, [BX].PassCtl	AND	AL, 30H		;bits 5,4 = 00?	JZ	VerAll	JMP	DoGoodVerAll:	MOV	AX, [BX].StartData	MOV	SaveStartData, AX	MOV	AX, [BX].AddData	MOV	SaveAddData, AX	MOV	AX, 0001H	MOV	[BX].StartData, AX	MOV	AX, 0202H	MOV	[BX].AddData, AX	;using format data for worst case	CALL	CopyStartHdr	MOV	SecNT, 0FFFFH		;single sector, -(1)	TEST	[BX].PassCtl, 40H	;double sectors?	JZ	OneMoreTrack	MOV	SecNT, 0FFFEH OneMoreTrack:	MOV	PassFaults, 0	;expecting an error on at least one sector	MOV	[BX].CurSec, 0	;start on first sector of track	MOV	Sec, 0VBadSecLoop:	CALL	ExtDoRunTimeWork	MOV	RetryCount, 1	CALL	CalcCurFP	CALL	CopyCurToExpectd	CALL	CalcExpFPRetryForErr:	CALL	FillSecBuf	CALL	VerSec	JZ	NoErrYet	CMP	PassFaults, HdrErr	JNE	CkLblDtaErrs	JMP	LessUn		;should never get header errorsCkLblDtaErrs:	CMP	PassFaults, LblErr	JE	BadSecOnTrk	CMP	PassFaults, DatErr	JE	BadSecOnTrk	CMP	PassFaults, LstErr	JE	BadSecOnTrk	JMP	LessUn		;some other error than bad mediaNoErrYet:	CMP	RetryCount, 0	JE	TryFurther	DEC	RetryCount	MOV	AL, GoIdle	MOV	DX, RDCCtrlStatus	OUT	DX, AL	JMP	RetryForErrTryFurther:	MOV	AL, SecPTrk	DEC	AL	TEST	[BX].PassCtl, 40H	;double sectors?	JZ	SingVerBad	DEC	AL	;set for last double sectorSingVerBad:	MOV	AH, Sec	CMP	AH, AL	;are we on the last sector(s) with no error yet?	JNE	LookFurtherBadBad:	MOV	PassFaults, NoXpctdVrErr	JMP	LessUnLookFurther:	MOV	DX, 1	;verify next sector	CALL	CalcNxtHdr	JNZ	BadBad	;last trk/sec and no error. shouldn't happen.	CALL	PutNxtToCurHdr	JMP	VBadSecLoopBadSecOnTrk:	MOV	DH, 0	MOV	DL, SecPTrk	;try next track	CALL	CalcNxtHdr	JNZ	VerErrDone	;beyond spec'd last track	CALL	PutNxtToCurHdr	JMP	OneMoreTrackVerErrDone:	MOV	PassFaults, 0	MOV	AX, SaveStartData	MOV	[BX].StartData, AX	MOV	AX, SaveAddData	MOV	[BX].AddData, AX	JMP	EndPassDoGood:	TEST	[BX].PassCtl, 10H ;Writes enabled?	JNZ	Writes	JMP	WrittenWrites:	TEST	[BX].PassCtl, 4		;Restore flag	JZ	WrLbDtfromlast	CALL	RestorePerOp	JZ	RestforWrLbDt	JMP	Passout	WrLbDtfromlast:		;RDC verifies headers onlyRestforWrLbDt:	MOV	DiskCmd, WriteLbDt	CALL	GoWriteData	JZ	StartWrDtLoop	MOV	SubErr, LgWrLbDtErr	CALL	PassimStartWrDtLoop:	CMP	NoGoodTrack, 0	JE	WriteMore	MOV	PassFaults, NoGoodTracks	JMP	PassoutWriteMore:	TEST	[BX].PassCtl, 4		;Restore flag	JZ	WrDtfromlast	CALL	RestorePerOp	JZ	RestforWrDt	JMP	Passout	WrDtfromlast:		;RDC verifies headers,labels RestforWrDt:	MOV	DiskCmd, WriteDt	CALL	GoWriteData	JZ	Written	MOV	SubErr, LgWrDtErr	CALL	PassimWritten:	TEST	[BX].PassCtl, 20H ;Reads and Verify enabled?	JNZ	Reads	JMP	EndPass	Reads:	TEST	[BX].PassCtl, 4		;Restore flag	JZ	RdLblfromlast	CALL	RestorePerOp	JZ	RestforRdLbl	JMP	Passout	RdLblfromlast:RestforRdLbl:	;read every AddSec label from start to end (single sector op)		;RDC verifies headers only	MOV	NoGoodTrack, 0FFH   ;set no good tracks found yet	MOV	DiskCmd, ReadLb     ;set operation for Read Label subloop	CALL	CopyStartHdr	Test	[BX].SkipTest, 40H	JNZ	SetSecNT	CALL	FindNxtGoodHdr	JZ	SetSecNT	JMP	StartRdLbDtLoop		;should never happenSetSecNT:	MOV	NoGoodTrack, 000H   ;at least one sector on a good track 	MOV	SecNT, 0FFFFHRdLblLoop:	CALL	ExtDoRunTimeWork	MOV	RetryCount, 1	CALL	CalcCurFP	CALL	CopyCurToExpectd	CALL	CalcExpFPRLRetry:	CALL	CompLabel	CALL	ShipDOB	PUSHF	CALL	CompLabel	POPF	JZ	ExRdLbl	JMP	Passout	;no error logging except in executing operationErrRdLbls:	MOV	SubErr, LgRdLbErr	CALL	Passim	;returns if logging first errors	JMP	StartRdLbDtLoopExRdLbl:	CALL	RDCFetchCmd	;routine goes on to execute command	JZ	RdLblBeginOK	JMP	Passout	;no error logging if GetDOB error or bad FIFO statusRdLblBeginOK:	MOV	AX, [BX].AddSec	SHR	AX, 1			;adjust seek time to wait time 	MOV	DX, 0	MOV	CH, 0	MOV	CL, SecPTrk	DIV	CX	ADD	AX, 5		;min wait	MOV	DL, DoCmd+Complete	;waiting for command complete	CALL	WaitRDC	CMP	PassFaults, CmdCmpletErr	JE	AnyRetry	CMP	PassFaults, 0	JE	RdLblSt	JMP	ErrRdLblsAnyRetry:	CMP	RetryCount, 0	JE	RdLblSt	DEC	RetryCount	MOV	AL, GoIdle	MOV	DX, RDCCtrlStatus	OUT	DX, AL	Test	[BX].SkipTest, 40H	Jz	JRLR	Test	[BX].SkipTest, 20H	Jz	JRLR	MOV	PassFaults, 0	JMP	EndPassJRLR:	JMP	RLRetry	;FIFO not involvedRdLblSt:	MOV	PassFaults, 0	CALL	GetDiskSt	JZ	CkLblSt	JMP	Passout	;no logging if can't get DOB backCkLblSt:	CALL	CkStatus	JNZ	ErrRdLbls	MOV	DX, [BX].AddSec	CALL	CalcNxtHdr	JNZ	StartRdLbDtLoop	;next sector beyond end	CALL	PutNxtToCurHdr	Test	[BX].SkipTest, 40H	JNZ	PassBTCk	CALL	FindNxtGoodHdr	JNZ	StartRdLbDtLoop	;no more good tracks on diskPassBTCk:	JMP	RdLblLoopStartRdLbDtLoop:	;RDC verifies header only	Test	[BX].SkipTest, 40H	Jz	CarryOn	JMP	EndPassCarryOn:	CMP	NoGoodTrack, 0	JE	ReadMore	MOV	PassFaults, NoGoodTracks	JMP	PassoutReadMore:	TEST	[BX].PassCtl, 4		;Restore flag	JZ	RdLbDtfromlast	CALL	RestorePerOp	JZ	RestforRdLbDt	JMP	PassoutRdLbDtfromlast:RestforRdLbDt:	MOV	DiskCmd, ReadLbDt	CALL	GoReadData		JZ	StartRdDtLoop	;FIFO/GetDOB/RetDOB errors checked in Read Label				; subloop.  If logging first errors, show any				; errors from GoReadData as a Read Label and				; Data operation error.	MOV	SubErr, LgRdLbDtErr	CALL	Passim	;returns if logging first errors	StartRdDtLoop:		;RDC verifies header,labels	TEST	[BX].PassCtl, 4		;Restore flag	JZ	RdDtafromlast	CALL	RestorePerOp	JZ	RestforRdDta	JMP	Passout	RdDtafromlast:RestforRdDta:	MOV	DiskCmd, ReadDt	CALL	GoReadData	JZ	StartVerifyDtLoop	MOV	SubErr, LgRdDtErr	CALL	Passim	;returns if logging first errorsStartVerifyDtLoop:	;RDC verifies header,label,data	TEST	[BX].PassCtl, 4		;Restore flag	JZ	Verfromlast	CALL	RestorePerOp	JZ	RestforVer	JMP	Passout	Verfromlast:RestforVer:	CALL	CopyStartHdr	CALL	FindNxtGoodHdr	JNZ	CleanEndingVerLoop:	CALL	ExtDoRunTimeWork	MOV	RetryCount, 1	TEST	[BX].PassCtl, 40H	;double sectors?	JZ	SingVer	MOV	DX, 1		;add 1 for 2nd sector	CALL	CalcNxtHdr	;is next sector beyond spec'd end	JZ	IsTrkGood	JMP	EndPassIsTrkGood:	CALL	CopyNxtToExpectd	CALL	IsNxtGoodTrk	JZ	FillNGo	CALL	FindNxtGoodHdr	JNZ	CleanEnding	;next and all remaining tracks on disk bad	JMP	NextVerSecSingVer:	CALL	CopyCurToExpectdFillNGo:	CALL	CalcCurFP	CALL	CalcExpFPVVVRetry:	CALL	FillSecBuf	CALL	VerSec	JZ	NextVerSec	CMP	RetryCount, 0	JE	VLogOrEnd	DEC	RetryCount	MOV	AL, GoIdle	MOV	DX, RDCCtrlStatus	OUT	DX, AL	MOV	DmaIntrCount, 0	;clear FIFO needed before retry 	CALL	EmptyFIFO	;for some VerSec failures	JMP	VVVRetryVLogOrEnd:	MOV	SubErr, LgVrErr	CALL	PassimCleanEnding:	JMP	EndPassNextVerSec:	MOV	DX, [BX].AddSec	CALL	CalcNxtHdr	JNZ	CleanEnding	;next sector beyond end	CALL	PutNxtToCurHdr	CALL	FindNxtGoodHdr	JNZ	CleanEnding	;no more good tracks to verify	JMP	VerLoopOnlyFifo:	MOV	AX, OvrWrtErr + DataError ; faults that don't need reset	NOT	AX			; make mask	AND	AX, PassFaults	JZ	ClrLast		;otherwise reset DMA	MOV	PassFaults, 0	CALL	ResetDmaRDCInts	JZ	ClrLast	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	GoOn	JMP	ErrExitGoOn:	JMP	EndPassClrLast:	MOV	PassFaults, 0	MOV	[BX].Allows, 0	;clear count of allow commands;	MOV	AH, 0	MOV	AL, [BX].DmaArea	AND	AL, 7	MOV	DX, 3000H	;assume ES bit 12 needed set for AA.16	CMP	AL, 4	JG	SetES	MOV	DX,2000HSetES:	MOV	ES, DX	SHL	AL, 1	;word index into Areas	ADD	AX, OFFSET Areas	PUSH	BX	MOV	BX, AX	MOV	AX, [BX]	;ASSUMing DS=CS	MOV	MemArea, AX	POP	BX	CALL	FillArea;program and check 2942 for Xfer to FIFO	MOV	DX, DmaStatus	;when OUT, this is cmnd port to set direction	MOV	AX, ToFIFO	;Xfer to FIFO	OUT	DX, AX	MOV	CX, 0A8BBH	;direction bit should be set	CALL	Ck8bitReg	JZ	OK1	OR	PassFaults, BadDmaStatus	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	NotOk1	JMP	ErrExitNotOk1:	JMP	EndPassOK1:	MOV	DX, DmaAddr8to1	MOV	AX, Blk1	AND	AX, 01FEH	;get lower bits of starting address	OUT	DX, AX	PUSH	AX	;save this for read compare	MOV	DX, DmaAddr23to9	MOV	AX, Blk1	SHR	AX, 8	MOV	Blk2, AX	;save for later	OUT	DX, AX	;Set upper address bits and copy Address Register to			; Address Counter (Wrd Reg to WC but we reprogram it); Now read Address Counter.  Upper bits in ALS374's not available	POP	CX	;bits 8to1	MOV	DX, Read2942AC	IN	AX, DX	AND	AX, 01FEH	;ignore other bits from FIFOData bus	CMP	AX, CX	JE	ACok	OR	Passfaults, BadAddrCount	CALL	Fill8bitResults	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	NotACok	JMP	ErrExitNotACok:	JMP	EndPassACok:	MOV	DX, DmaWordCount	MOV	AX, WCIn2sComp	OUT	DX, AX	;In mode 3, word count reg and Word Counter both			;get loaded by this command	MOV	CX, AX	;copy for fill subroutine	NOT	AX	; read back should change AX = CX again	MOV	DX, Read2942WC	IN	AX, DX	AND	AX, 01FEH	CMP	AX, CX	JE	WCok	OR	PassFaults, BadWordCount	CALL	Fill8bitResults	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	NotWCok	JMP	ErrExitNotWCok:	JMP	EndPassWCok:;Now ready to start 1st Xfer to FIFO. We set FIFOIn17 for all cases. This bit;should show up in the status when we Xfer back in.;If we are making transfers to the FIFO of more than 256 words (two Xfers of;more than 128 words) then this bit should be reset on the 1st Xfer in.;This bit should be set for the 2nd Xfer or if there is only one Xfer in.	MOV	DX, PresetFIFOIn17	OUT	DX, AX	;Doesn't matter what is in AX	CALL	StartRoutine	JZ	FirstOutok	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	NotFirstOutok	JMP	ErrExitNotFirstOutok:	JMP	EndPassFirstOutok:;;We could (possibly) have gotten Dma status showing EndOfXfer'=0 in the; StartRoutine or (more likely) in DmaIntrHandler.  Check that DmaStatusStored; or DmaStatusWaiting has this bit off.  Check that DmaStatusStored has; the direction bit set, no FIFOout17, Not full, Not Empty, Not Out of Bounds,; and no Error bit.	MOV	AX, DmaStatusWaiting	AND	AX, DmaStatusStored	AND	AL, 04H	;EndOfXfer bit	JZ	EndXok	OR	PassFaults, BadDmaStatus	MOV	[BX].Mask8bitReg, 04H	MOV	[BX].ExpectedVal, 00H	MOV	[BX].ObservedVal, LOW DmaStatusStored	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	NotEndXok	JMP	ErrExitNotEndXok:	JMP	EndPassEndXok:	MOV	AX, DmaStatusStored	MOV	AH, AL		;copy in case we report	MOV	CX, 0B8B9H	;expect/mask FIFOOut17 different depending on				;  WordLen	AND	AL,CL		;mask bits we care about	XOR	AL,CH		;should get zero	JNZ	End1NearErr	JMP	End1okEnd1NearErr:	OR	PassFaults, BadDmaStatus	MOV	[BX].Mask8bitReg, CL	MOV	[BX].ExpectedVal, CH	MOV	CX, DmaStatusStored	MOV	[BX].ObservedVal, CL	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	NotEnd1ok	JMP	ErrExitNotEnd1ok:	JMP	EndPass;===========================================================	ORG	TestCodeLoc2End1ok:;;Now read the Address Counter and Word Counter.  They should both be zero in;all cases (any WordLen).;	MOV	CL, 0	;for possible subroutine call	MOV	DX, Read2942AC	IN	AX, DX	AND	AX, 01FEH	CMP	AX, 0	JE	AC1ok	OR	PassFaults, BadAddrCount	CALL	FillFed8	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	NotAC1ok	JMP	ErrExitNotAC1ok:	JMP	EndPassAC1ok:	MOV	DX, Read2942WC	IN	AX, DX	AND	AX, 01FEH	CMP	AX, 0	JE	WC1ok	OR	PassFaults, BadWordCount	CALL	FillFed8	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	NotWC1ok	JMP	ErrExitNotWC1ok:	JMP	EndPassWC1ok:;;In setting the upper address bits for the next Xfer to FIFO, we will re-initialize the Address and Word Counters.  We need to change the Address;Register to zero first.  Re-initializing the Word Counter to the Word Count Register is what we want (no reprogramming).;	MOV	DX, DmaAddr8to1	MOV	AX, 0	OUT	DX, AX	MOV	AX, 82H		;8200H sh'd 8 bits left	MOV	DX, DmaAddr23to9	OUT	DX, AX;Check WC did re-init to WCIn2sComp	MOV	DX, Read2942WC	MOV	CX, WCIn2sComp	IN	AX, DX	AND	AX, 01FEH	CMP	AX, CX	JE	reWCok	OR	PassFaults, BadWordCount	CALL	Fill8bitResults	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	NotreWCok	JMP	ErrExitNotreWCok:	JMP	EndPassreWCok:; 2nd Xfer to FIFO	CALL	StartRoutine	JZ	To2ok	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	NotTo2ok	JMP	ErrExitNotTo2ok:	JMP	EndPassTo2ok:;The only significant difference between the 1st Xfer to FIFO and the 2nd is the final value of the Address Counter.  It should be = WordLen.;For the special case of WordLen = 0 (256)words, the FIFO should also now be full.	MOV	DX, Read2942AC	IN	AX, DX	AND	AX, 01FEH	MOV	CH, 0	MOV	CL, [BX].WordLen	CMP	CL, 0 ;special case	JE	MaXfer	SHL	CX, 1MaXfer:	CMP	CX, AX	JE	CkFIFOFull	OR	PassFaults, BadAddrCount	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	Not2ndACok	JMP	ErrExitNot2ndACok:	JMP	EndPassCkFIFOFull:	CMP	[BX].WordLen, 0	;special case when we fill the FIFO full	JNE	XFERIN;DmaStatusStored or DmaStatusWaiting should have FIFOFull'=0 and FIFOOB'=0	MOV	AX, DmaStatusStored	AND	AX, DmaStatusWaiting	AND	AX, 28H	;FIFOFull' and FIFOOB' bits	JZ	XFERIN	OR	PassFaults, BadDmaStatus	MOV	[BX].Mask8bitReg, 28H	MOV	[BX].ExpectedVal, 00H	MOV	[BX].ObservedVal, LOW DmaStatusStored	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	NotFullok	JMP	ErrExitNotFullok:	JMP	EndPass;XFERIN:;First we change the direction bit	MOV	DX, DmaStatus	MOV	AX, FIFOIn	OUT	DX, AX;set the address to Xfer in	MOV	DX, DmaAddr8to1	MOV	AX, 00H	OUT	DX, AX;set the Word Count Register to the 2's comp (min (256 words, 2*WordLen))	MOV	AH, 0	MOV	AL, [BX].WordLen	CMP	AX, 0	JE	TwoBiggies 	SHL	AX, 1	  ;make byte length, align for bits 8-1	SHL	AX, 1	  ;mult by two for the two xfer's out	CMP	AX, 200H  ;256 words	JLE	OneXfr	  ;it will only take one Xfer in to			  ; get everything back  	MOV	DX, 200H	SUB	AX, DXLeftodo:	MOV	Remaining, AX	MOV	AX, 0	;1st Xfer will be 256 words	JMP	SetXinWC1TwoBiggies:	MOV	AX, 200H	JMP	Leftodo	OneXfr:	MOV	Remaining, 0	MOV	DX, 0	SUB	DX, AX	MOV	AX, DX	;2s compSetXinWC1:	MOV	DX, DmaWordCount	OUT	DX, AX	;bits 15-9 & 0 should be ignored;now set Addr23to9 and initialize counters	MOV	DX, DmaAddr23to9	MOV	AX, MemArea	SHR	AX, 8	MOV	CL, [BX].DmaArea	AND	CL, 7	CMP	CL, 5	JL	NoAA16	ADD	AX, 100H	;17th bit set onNoAA16:	MOV	Blk2, AX	OUT	DX, AX	CALL	StartRoutine	JZ	FirstIn	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	Not1stInok	JMP	ErrExitNot1stInok:	JMP	EndPassFirstIn:	MOV	DX, DmaStatus;If we Xferred more than 256 words (two Xfers of more than 128 words each) then check Dma Status for:;direction = 0, FIFOOut17=0, FIFOFull'=1, FIFOEmpty'=1,;Out of Bounds'=1, 			  Error=0	MOV	CX, 038B9H	;special case	MOV	AH, 0	MOV	AL, [BX].WordLen	CMP	AX, 0	JE	NotEmptied	;special case	CMP	AX, 80H		;128 words	JLE	CkLastNotEmptied:	CALL	Ck8bitReg	JZ	GetRemaining	OR	PassFaults, BadDmaStatus	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	NotUnemptiedok	JMP	ErrExitNotUnemptiedok:	JMP	EndPassGetRemaining:; We have to reprogram only the Word Count Register and Word Counter	MOV	DX, DmaWordCount	MOV	AX, 0	SUB	AX, Remaining	OUT	DX, AX	MOV	DX, DmaAddr23to9	MOV	AX, Blk2	ADD	AX, 2	;last xfer in at next 256-word block beyond MemArea	OUT	DX, AX	; set upper address and init counters	CALL	StartRoutine	JZ	CkLast	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	Not2ndInok	JMP	ErrExitNot2ndInok:	JMP	EndPassCkLast:;Check status for:;direction = 0, FIFOOut17=1, FIFOFull'=1, FIFOEmpty'=0,;Out of Bounds'=0, 			  Error=0	MOV	DX, DmaStatus	MOV	CX, 060F9H	CALL	Ck8bitReg	JZ	CkData	OR	PassFaults, BadDmaStatus	TEST	[BX].DiskErrCtl, DiskNoStop	JNZ	Notlastatusok	JMP	ErrExitNotlastatusok:	JMP	EndPassCkData:	CALL	CheckArea	JZ	EndPass	TEST	[BX].DiskErrCtl, DiskNoStop	JZ	ErrExitEndPass:	MOV	AL, [BX].PassCtl	AND	AL, 31H		;disk test, logging errors	CMP	AL, 31H	JNE	NormalPass	CMP	PassFaults, 0	JNE	NormalPass	;more basic errors supersede	CMP	[BX].LogSubErrs, 0	JE	NormalPass	;no errors logged	MOV	PassFaults, PassErrLoggedNormalPass:	MOV	AX, PassFaults	MOV	[BX].TestFaults, AX	MOV	BP, ExtMCBlock	MOV	DS:[BP].MesaFault, AL	OR	DS:[BP].IOPFault, AH	CALL	ExtDoRunTimeWork	MOV	AL, [BX].PassCtl	INC	[BX].CurrentPass	TEST	AL, 02H	;Add AddLen to WordLen	JZ	CkDmaInc	MOV	DL, [BX].AddLen	ADD	[BX].WordLen, DLCkDmaInc:	TEST	AL, 04H 	;Inc DmaArea selector?	JZ	DoNextPass	INC	[BX].DmaAreaDoNextPass:	JMP	Pass;ErrExit:	MOV	AX, PassFaults	MOV	[BX].TestFaults, AXTerrExit:	MOV	BP, ExtMCBlock	MOV	AX, [BX].TestFaults	MOV	DS:[BP].MesaFault, AL	OR	DS:[BP].IOPFault, AH	RET	;to Monitor;;---------------------------------------------------------; Subroutines;---------------------------------------------------------;InitParm:	MOV	AX, [BX].StartCy	MOV	[BX].CurCy, AX	MOV	Cyl, AX	MOV	AL, [BX].StartHd	MOV	[BX].CurHd, AL	MOV	Head, AL	MOV	AL, [BX].StartSec	MOV	[BX].CurSec, AL	MOV	Sec, AL	MOV	AX,[BX].StartData	;use comp of Start Data and dec	NOT	AX			;for File ID	MOV	DX,[BX].AddData	PUSH	BX	MOV	BX, OFFSET FID0	MOV	CX, 5Labloop:	MOV	[BX], AX		;Format or WriteLabel worry	SUB	AX, DX			;about FP Hi and Lo	ADD	BX, 2	LOOP	Labloop	POP	BX	RET;;---------------------------------------------------------;GoFormat:	MOV	DiskCmd, Format	CALL	CopyStartHdr	MOV	AX, [BX].EndCy		;Calc # of Tracks to format	MOV	ExpectdCyl, AX		;After formatting we should be on the					 ;ending cylinder	SUB	AX, [BX].StartCy	MOV	DH, 0	MOV	DL, HeadPCy	MUL	DX			;should always produce a word quantity					; ie DX gets 0	MOV	DL, [BX].EndHd	MOV	ExpectdHd, DL		;should end on ending head	ADD	AX, DX	MOV	DL, [BX].StartHd	SUB	AX, DX	INC	AX			;difference accounted, now add endpoint	NEG	AX			;RDC wants it in 2's comp	MOV	CompNoTrk, AX	MOV	AX, [BX].StartCy	;Calc Starting FP Hi and Lo	MOV	DL, HeadPCy	MUL	DX			;DX should get 0	MOV	DL, [BX].StartHd	ADD	AX, DX	MOV	DL, SecPTrk	MOV	ExpectdSec, DL	DEC	ExpectdSec		;should end on last sector on track	MUL	DX			;DX may be non-zero	SHL	DX, 9			;place where LO overflows to HI	MOV	FPLo, AX	MOV	FPHi, DX	CALL	CalcExpFP	CALL	ShipDOB		;dma DOB to FIFO, wait for Dma done	JZ	ExFormat	RETExFormat:	CALL	RDCFetchCmd	;tell RDC to fetch and start execution  	JZ	Formwait	RETFormwait:	;should have no Dma interrupts;///assume fastest wait loop takes approx. 40 clocks at 6.5MHz or ~6 us/loop.;It is said that controller formatting of 1224 tracks on a 10MB drive;takes less than but about 4 min.  240 sec/1224 tracks ~= 200,000 us/track.;(200,000us/trk)/(6us/loop) = 33,333 loops/track or ~32K loops/track.;Assume wait routine waits a caller-specified number of outer loops with an;inner loop looping CX from FFFFH to 0 (64K inner loops).  Therefore we call the;wait routine to loop the outer loop -CompNoTrk number of times/2.	MOV	AX, CompNoTrk	NEG	AX			;negate back to positive number	SHR	AX, 1	;two tracks formatted per outer loop	MOV	DL, DoCmd+Complete	;waiting for command complete	CALL	WaitRDC	CMP	PassFaults, 0	JE	GetFormStat	RETGetFormStat:	CALL	GetDiskSt	JZ	CkFormStat	RETCkFormStat:	CALL	CkStatus	JZ	CkNoDma	RETCkNoDma:	CMP	DmaIntrCount, 0		;should have no Dma int in running RDC	JE	RetFormOK	OR	PassFaults, UnexpctdIntRetFormOK:	RET;;---------------------------------------------------------;GoWriteData:	MOV	NoGoodTrack, 0FFH	;set no good tracks found yet	CALL	CopyStartHdr	CALL	FindNxtGoodHdr	JNZ	WritingDone	MOV	SecNT, 0FFFFH		;single sector, -(1)	TEST	[BX].PassCtl, 40H	;double sectors?	JZ	WriteLoop	MOV	SecNT, 0FFFEH		;-(2), get 2 sectorsWriteLoop:	CALL	ExtDoRunTimeWork	MOV	RetryCount, 1	TEST	[BX].PassCtl, 40H	JZ	SingWrite	MOV	DX, 1		;add 1 for 2nd sector	CALL	CalcNxtHdr	;is next sector beyond spec'd end	JZ	IsTrkOKWritingDone:	AND	AL, 0		;set no error	RETSingWrite:	CALL	CopyCurToExpectd	JMP	ShipWriteIsTrkOK:	CALL	CopyNxtToExpectd	CALL	IsNxtGoodTrk	JZ	ShipWrite	CALL	FindNxtGoodHdr	JNZ	WritingDone	;next and all remaining tracks on disk bad	JMP	NxtWritePageShipWrite:	MOV	NoGoodTrack, 000H ;at least one sector on a good track found	CALL	CalcCurFP	CALL	CalcExpFPWRetry:	CALL	FillSecBuf	CALL	ShipDOB	JZ	ExWrite	RETExWrite:	CALL	RDCFetchCmd	;return after RDC to fetches DOB	JZ	WrLagLead	RETWrLagLead:	TEST	[BX].PassCtl, 02H	;Lag RDC?	JNZ	LagRDCWr	CALL	SayGo	;can't wait too long, but we should be able to			; ship 1 or 2 sectors of data before "N revolutions"			;//// or even three since RDC is going	MOV	DX, DmaStatus	MOV	AX, ToFIFO	OUT	DX, AX	CALL	XferSecs	JZ	CkWrdone	RETCkWrdone:	MOV	AX, [BX].AddSec	SHR	AX, 1			;adjust seek time to wait time 	MOV	DX, 0	MOV	CH, 0	MOV	CL, SecPTrk	DIV	CX	ADD	AX, 5		;min Wait	MOV	DL, DoCmd+Complete	CALL	WaitRDC		;RDC should complete				;for one or two sectors ////	CMP	PassFaults, CmdCmpletErr	JNE	IsLeadWrOK	CMP	RetryCount, 0	JE	GetWrSt	DEC	RetryCount	MOV	AL, GoIdle	MOV	DX, RDCCtrlStatus	OUT	DX, AL	JMP	WRetry	;FIFO should be empty on CmdCmpletErrIsLeadWrOK:	CMP	PassFaults, 0	;no error in Writing?	JE	GetWrSt	RETLagRDCWr:	MOV	DX, DmaStatus	MOV	AX, ToFIFO	OUT	DX, AX	CALL	XferSecs	;1 or 2 secs should fit in FIFO				;//// but not all of three	JZ	CkWrFull	RETCkWrFull:	TEST	[BX].PassCtl, 40H	;if 2 secs out, check FIFOFull'=0	JZ	StartWrLate	MOV	DX, DmaStatus	MOV	CX, 090BDH	CALL	Ck8bitReg	JZ	StartWrLate	OR	PassFaults, BadDmaStatus	RETStartWrLate:	CALL	SayGo	MOV	AX, [BX].AddSec	SHR	AX, 1			;adjust seek time to wait time 	MOV	DX, 0	MOV	CH, 0	MOV	CL, SecPTrk	DIV	CX	ADD	AX, 5	MOV	DL, DoCmd+Complete	CALL	WaitRDC	CMP	PassFaults, CmdCmpletErr	JNE	IsLagWrOK	CMP	RetryCount, 0	JE	GetWrSt	DEC	RetryCount	MOV	AL, GoIdle	MOV	DX, RDCCtrlStatus	OUT	DX, AL	JMP	WRetry	;FIFO should have been emptied to get hereIsLagWrOK:	CMP	PassFaults, 0	JE	GetWrSt	RETGetWrSt:	MOV	PassFaults, 0	;May have got here with CmdCmpletErr	CALL	GetDiskSt	JZ	CheckWrSt	RETCheckWrSt: 	CALL	CkStatus	JZ	NxtWritePage	RETNxtWritePage:	MOV	DX, [BX].AddSec	CALL	CalcNxtHdr	JNZ	RetWriteOK	;next sector beyond end	CALL	PutNxtToCurHdr	CALL	FindNxtGoodHdr	JNZ	RetWriteOK	;no more good tracks to write	JMP	WriteLoopRetWriteOK:	AND	AL, 0		;set no error	RET;;---------------------------------------------------------;GoReadData:	CALL	CopyStartHdr	CALL	FindNxtGoodHdr	JNZ	ReadingDone	MOV	SecNT, 0FFFFH		;single sector, -(1)	TEST	[BX].PassCtl, 40H	;double sectors?	JZ	ReadLoop	MOV	SecNT, 0FFFEH		;-(2), get 2 sectorsReadLoop:	CALL	ExtDoRunTimeWork	MOV	RetryCount, 1	TEST	[BX].PassCtl, 40H	JZ	SingRead	MOV	DX, 1		;add 1 for 2nd sector	CALL	CalcNxtHdr	;is next sector beyond spec'd end	JZ	IsTrackOKReadingDone:	AND	AL, 0		;set no error	RETSingRead:	CALL	CopyCurToExpectd	JMP	ShipReadIsTrackOK:	CALL	CopyNxtToExpectd	CALL	IsNxtGoodTrk	JZ	ShipRead	CALL	FindNxtGoodHdr	JNZ	ReadingDone	;next and all remaining tracks on disk bad	JMP	NxtReadPageShipRead:	CALL	CalcCurFP	CALL	CalcExpFPRRetry:	CALL	PrefillSecBuf	CALL	ShipDOB	JZ	FetchRead	RET	;return error to callerFetchRead:	CALL	RDCFetchCmd	;routine either goes on to exec cmd (no RDC lag)				; or returns after good fetch (lag RDC)	JZ	FetchOK	RETFetchOK:	TEST	[BX].PassCtl, 02H	;Lag RDC?	JNZ	StartFIFORead;allow wait for RDC to get there	MOV	AX, [BX].AddSec	SHR	AX, 1			;adjust seek time to wait time 	MOV	DX, 0	MOV	CH, 0	MOV	CL, SecPTrk	DIV	CX	ADD	AX, 5		;min wait time	MOV	DL, DoCmd+Complete	CALL	WaitRDC;we expect RDC to complete or not depending on whether we are reading one or two;sectors //// or three sectors.  First check if operation completed ok	CMP	PassFaults, CmdCmpletErr	JNE	IsLeadRdOK	CMP	RetryCount, 0	JNE	ReadAgain	JMP	GetRdStReadAgain:	DEC	RetryCount	MOV	AL, GoIdle	MOV	DX, RDCCtrlStatus	OUT	DX, AL	CALL	EmptyFIFO	;RDC has filled FIFO	JMP	RRetryIsLeadRdOK:	CMP	PassFaults, 0	;no error in Reading?	JE	OneOrTwo	RETOneOrTwo:	TEST	[BX].PassCtl, 40H	;double sectors?	JNZ	XpctFull	JMP	StartFIFORead	;RDC has completed one sector readXpctFull:	MOV	DX, DmaStatus	;RDC has completed two sector read				; FIFO should be full	MOV	CX, 018BBH	CALL	Ck8bitReg	JZ	StartFIFORead	OR	PassFaults, BadDmaStatus	RET;//// part of code for three secs;////	MOV	PassFaults, 0	;clear expected timeout;////	OR	PassFaults, RDCNotHeld;////	JMP	StartFIFORead	StartFIFORead:	CALL	XferSecs	PUSHF			;save result of running Dma	TEST	[BX].PassCtl, 02H	;Lagging RDC?	JNZ	LaggingRDCRd;lagging IOP, XferSecs should have completed (RDC started before Dma);  if one or two xfers made	TEST	[BX].PassCtl, 40H	;double sectors?	JZ	PopCkRdDta	CMP	SecNT, 0FFFEH		;two sectors	JNE	RDCyetPopCkRdDta:	POPF	JZ	CkReadDta	RETRDCyet:			;/// triple sectors	POPF	MOV	AX, 1	;shouldn't affect flags	JZ	LeastWait	RETLaggingRDCRd:	POPF	;XferSecs should not have completed (need to run State Machine)	JNZ	StartRDCRd	OR	PassFaults, FIFONotHeld	RETStartRDCRd:	MOV	PassFaults, 0	;clear expected timeout	CALL	SayGo		;start RDC	MOV	AX, [BX].AddSec	SHR	AX, 1			;adjust seek time to wait time 	MOV	DX, 0	MOV	CH, 0	MOV	CL, SecPTrk	DIV	CX	ADD	AX, 5		;waiting, command should completeLeastWait:	MOV	DL, DoCmd+Complete	CALL	WaitRDC	CMP	PassFaults, CmdCmpletErr	JNE	IsLagRdOK	CMP	RetryCount, 0	JE	DumpFIFOnGetRdSt	DEC	RetryCount	MOV	AL, GoIdle	MOV	DX, RDCCtrlStatus	OUT	DX, AL	JMP	RRetry		;FIFO should be emptyDumpFIFOnGetRdSt:	CALL	EmptyFIFO	MOV	DmaIntrCount, 0	JMP	GetRdStIsLagRdOK:	CMP	PassFaults, 0	;should get interrupt now	JE	WaitRdOK		RETWaitRdOK:	CALL	WaitDmaIntAfterRDCInt	JZ	CkTwoIn	RETCkTwoIn:	TEST	[BX].PassCtl, 40H	;double sectors?	JZ	CkReadDta	MOV	AX, FixSecBuf + 512	SHR	AX, 8	MOV	DX, DmaAddr23to9	OUT	DX, AX	CALL	StartRoutine		;get second sector	JZ	CkReadDta	RET	CkReadDta:	CALL	CkDta	JZ	GetRdSt	RETGetRdSt:	MOV	PassFaults, 0	;May have got here with CmdCmpletErr	CALL	GetDiskSt	JZ	CheckRdSt	RETCheckRdSt:	CALL	CkStatus	JZ	NxtReadPage	RETNxtReadPage:	MOV	DX, [BX].AddSec	CALL	CalcNxtHdr	JNZ	RETendOK	;next sector beyond end	CALL	PutNxtToCurHdr	CALL	FindNxtGoodHdr	JNZ	RETendOK	;no more good tracks to read	JMP	ReadLoopRETendOK:	AND	AL, 0		;set no error	RET;;---------------------------------------------------------;VerSec:	MOV	DiskCmd, VerifyDt	TEST	[BX].PassCtl, 40H	;double sectors?	JZ	VerOneSec	MOV	SecNT, 0FFFEH		;-(2), get 2 sectors	JMP	ShipVerDobVerOneSec:	MOV	SecNT, 0FFFFH		;single sector, -(1)ShipVerDob:	CALL	ShipDOB	JZ	ExVer	RETExVer:	CALL	RDCFetchCmd		;return after telling RDC to fetch DOB	JZ	VerLagLead	RETVerLagLead:	TEST	[BX].PassCtl, 02H	;Lag RDC?	JNZ	LagRDCVer	CALL	SayGo	;can't wait too long, but we should be able to			; ship 1 or 2 sectors of data before "N revolutions"	MOV	DX, DmaStatus	MOV	AX, ToFIFO	OUT	DX, AX	CALL	XferSecs	JZ	CkRDCdone	RETCkRDCdone:	MOV	AX, [BX].AddSec	SHR	AX, 1			;adjust seek time to wait time 	MOV	DX, 0	MOV	CH, 0	MOV	CL, SecPTrk	DIV	CX	ADD	AX, 5		;min wait	MOV	DL, DoCmd+Complete	CALL	WaitRDC	;RDC should complete [with possible H/L/D error]	CMP	PassFaults, CmdCmpletErr	JE	GetVerSt	CMP	PassFaults, 0	;no error in verifying	JE	GetVerSt	RETLagRDCVer:	MOV	DX, DmaStatus	MOV	AX, ToFIFO	OUT	DX, AX	CALL	XferSecs	;1 or 2 secs should fit in FIFO	JZ	CkFull	RETCkFull:	TEST	[BX].PassCtl, 40H	;if 2 secs out, check FIFOFull'=0	JZ	StartRDCLate	MOV	DX, DmaStatus	MOV	CX, 090BDH	CALL	Ck8bitReg	JZ	StartRDCLate	OR	PassFaults, BadDmaStatus	RETStartRDCLate:	CALL	SayGo	MOV	AX, [BX].AddSec	SHR	AX, 1			;adjust seek time to wait time 	MOV	DX, 0	MOV	CH, 0	MOV	CL, SecPTrk	DIV	CX	ADD	AX, 5	MOV	DL, DoCmd+Complete	CALL	WaitRDC	CMP	PassFaults, CmdCmpletErr	JE	GetVerSt	CMP	PassFaults, 0	JE	GetVerSt	RETGetVerSt:	MOV	PassFaults, 0	;May have got here with CmdCmpletErr	CALL	GetDiskSt	JZ	CheckVrSt	RETCheckVrSt: 	CALL	CkStatus	RET;;---------------------------------------------------------;CopyStartHdr:	MOV	AX, [BX].StartCy   ;copy starting to current and DOBout header	MOV	[BX].CurCy, AX	MOV	Cyl, AX	MOV	AL, [BX].StartHd	MOV	[BX].CurHd, AL	MOV	Head, AL	MOV	AL, [BX].StartSec	MOV	[BX].CurSec, AL	MOV	Sec, AL	RET;;---------------------------------------------------------;CopyNxtToExpectd:	MOV	AX, NxtCyl	MOV	ExpectdCyl,AX	MOV	AL, NxtHd	MOV	ExpectdHd, AL	MOV	AL, NxtSec	MOV	ExpectdSec, AL	RET;;---------------------------------------------------------;CopyCurToExpectd:	MOV	AX, [BX].CurCy	MOV	ExpectdCyl,AX	MOV	AL, [BX].CurHd	MOV	ExpectdHd, AL	MOV	AL, [BX].CurSec	MOV	ExpectdSec, AL	RET;;---------------------------------------------------------;PutNxtToCurHdr:	MOV	AX, NxtCyl	MOV	[BX].CurCy, AX	MOV	Cyl, AX	MOV	AL, NxtHd	MOV	[BX].CurHd, AL	MOV	Head, AL	MOV	AL, NxtSec	MOV	[BX].CurSec, AL	MOV	Sec, AL	RET;;---------------------------------------------------------;CalcCurFP:	;from Current Cyl/Hd/Sec	MOV	DH, 0	MOV	AX, [BX].CurCy	MOV	DL, HeadPCy	MUL	DX			;DX should get 0	MOV	DL, [BX].CurHd	ADD	AX, DX	MOV	DL, SecPTrk	MUL	DX			;DX may be non-zero	SHL	DX, 9			;place where Lo overflows in Hi	MOV	CH, 0	MOV	CL, [BX].CurSec	ADD	AX, CX	JNC	FPHiOK	ADD	DX, 200HFPHiOK:	MOV	FPLo, AX	MOV	FPHi, DX	RET;;---------------------------------------------------------;CalcExpFP:	;from Expectd Cyl/Hd/Sec	MOV	AX, ExpectdCyl	MOV	DH, 0	MOV	DL, HeadPCy	MUL	DX			;DX should get 0	MOV	DL, ExpectdHd	ADD	AX, DX	MOV	DL, SecPTrk	MUL	DX			;DX may be non-zero	SHL	DX, 9			;place where Lo overflows in Hi	MOV	CH, 0	MOV	CL, ExpectdSec	ADD	AX, CX	JNC	NoFPHiadd	ADD	DX, 200HNoFPHiadd:	MOV	ExpectdFPLo, AX	MOV	ExpectdFPHi, DX	RET;;---------------------------------------------------------;CalcNxtHdr:	;from Cur Cyl/Hd/Sec using increment in DX	MOV	AH, 0	MOV	AL, [BX].CurSec	ADD	AX, DX	JC	DXone	MOV	DX, 0	JMP	GetSecPTrkDXone:	MOV	DX, 1GetSecPTrk:	MOV	CH, 0	MOV	CL, SecPTrk	DIV	CX		;AX quotient (add to head count)				; DX modulo remainder (new sec on [new] track)	MOV	NxtSec, DL	ADD	AL, [BX].CurHd	JNC	NoInc	INC	AHNoInc:	MOV	CL, HeadPCy	MOV	DX, 0	DIV	CX		;AX quo (add to cyl)				; DX mod (new head on [new] cyl)	MOV	NxtHd, DL	ADD	AX, [BX].CurCy	MOV	NxtCyl, AX	CMP	AX, [BX].EndCy	JL	NxtOK	JG	Beyond	MOV	AL, NxtHd	CMP	AL, [BX].EndHd	JL	NxtOK	JG	Beyond	MOV	AL, NxtSec	CMP	AL, [BX].EndSec	JLE	NxtOKBeyond:	OR	AL, 0FFH		;Tell caller beyond end (reset ZF)	RETNxtOK:	AND	AL, 0H	RET;;---------------------------------------------------------;FindNxtGoodHdr:	CMP	TableIndex, 2	JG	BiSearchTwoBadOrLess:	MOV	DX, [BX].CurCy	MOV	AL, [BX].CurHd	AND	AL, 0FH	SHL	DX, 4	OR	DL, AL	PUSH	BX	MOV	BX, OFFSET BadTrackTbl	CMP	DX, [BX]	JE	aNew	CMP	DX, [BX + 2]	;2nd entry (may be invalid but thats ok)	JE	aNew	POP	BX	JMP	RetCHok		;Cyl&Hd is not bad and not invalidaNew:	CMP	DX, [BX + 4]	;3rd entry garanteed invalid	JL	TryAnother	POP	BX	JMP	RetNoMo		;Cyl&Hd is beyond endTryAnother:	POP	BX	CALL	IncTrk	JZ	TwoBadOrLess	JMP	RetNoMoBiSearch:	MOV	AX, TableIndex	SHR	AX, 1	MOV	Trydex, AX	;gets TableIndex/2	MOV	Lessdex, AX	MOV	Plus1, 0	MOV	Minus1, 0ReSearch:	MOV	CX, Lessdex	INC	CX	SHR	CX, 1	MOV	Lessdex, CX	;gets (Lessdex + 1)/2	MOV	DX, [BX].CurCy	MOV	AL, [BX].CurHd	AND	AL, 0FH	SHL	DX, 4	OR	DL, AL	PUSH	BX	MOV	BX, OFFSET BadTrackTbl	MOV	DI, Trydex	ADD	DI, DI	CMP	DX, [BX + DI]	;compare to element in ordered table	POP	BX	JG	Incdex	JL	Decdex;Bad track, try another	CALL	IncTrk	JZ	BiSearch	JMP	RetNoMoIncdex:	CMP	CX, 1		;is Lessdex down to 1	JNE	IncHigher	CMP	Minus1, 1	;did we just dec by one in last pass?	JNE	SetPlus1	JMP	RetCHok		;didn't find Cyl&Hd in tableSetPlus1:	MOV	Plus1, 1IncHigher:	ADD	Trydex, CX	MOV	CX, TableIndex	CMP	CX, Trydex	JG	Research	;TableIndex > next try, still in table	JMP	RetCHok		;couldn't find Cyl&Hd in bad track tableDecdex:	CMP	CX, 1		;is Lessdex down to 1	JNE	DecLower	CMP	Plus1, 1	;did we just inc by one in last pass?	JNE	SetMinus1	JMP	RetCHok		;didn't find Cyl&Hd in tableSetMinus1:	MOV	Minus1, 1DecLower:	SUB	Trydex, CX	JNS	Research	;Trydex 0 or greater, still in table	JMP	RetCHok		;Cyl&Hd less than any bad trackIncTrk:	MOV	DH, 0	MOV	DL, SecPTrk	;try next track same sector	CALL	CalcNxtHdr	JNZ	Beyondisk	CALL	PutNxtToCurHdrRetCHok:	;I know its a no-no but its so neat	AND	AL, 0	;return OK to caller	RETBeyondisk:RetNoMo:	OR	AL, 0FFH	RET;;---------------------------------------------------------;IsNxtGoodTrk:	MOV	DX, [BX].CurCy	MOV	AH, [BX].CurHd	CMP	DX, ExpectdCyl	JNE	Checkit	CMP	AH, ExpectdHd	JNE	Checkit	RET	;expected on same Cyl&Hd as beginning sectorCheckit:	MOV	DX, ExpectdCyl	MOV	AL, ExpectdHd	AND	AL, 0FH	SHL	DX, 4	OR	DL, AL	MOV	DI, TableIndex	PUSH	BX	MOV	BX, OFFSET BadTrackTblDesparate:	ADD	DI, DI	CMP	DX, [BX + DI]	JE	Pop2badRet	SHR	DI, 1	CMP	DI, 0	JNE	DecDi	JMP	PopRetDecDi:	DEC	DI	JMP	DesparatePop2badRet:	OR	AL, 0FFH	;tell caller 2nd track is badPopRet:	POP	BX	RET;;---------------------------------------------------------;CompLabel:	PUSH	BX	MOV	BX, OFFSET FID0	MOV	CX, 7CompLoop:	MOV	AX, [BX]	NOT	AX	MOV	[BX], AX	INC	BX	INC	BX	LOOP	CompLoop	POP	BX	RET 	;;---------------------------------------------------------;IdleCtler:;Check that the Controller will GoIdle from its present state.	MOV	DX, RDCCtrlStatus	MOV	AL, GoIdle	OUT	DX, AL	MOV	CX, 0FFH	;/// small wait loopIdleWhile:	IN	AL, DX	CMP	AL, 0	JE	RDCIdle	LOOP	IdleWhile	MOV	[BX].ExpectedVal, 0	MOV	[BX].Mask8bitReg, 0FFH	MOV	[BX].ObservedVal,AL	OR	PassFaults, DiskIdlErr	;leave ZF=0RDCIdle:	RET;;---------------------------------------------------------;ShipDOB:	MOV	DX, DmaStatus	MOV	AX, ToFIFO	OUT	DX, AX; Copy DOB up to Xfer area	MOV	CX, ((OFFSET DOBoutEnd) - (OFFSET DOBout))/2 ;make word count	MOV	DI, FixDOB	MOV	SI, OFFSET DOBoutDOBUpLoop:	MOV	AX, [SI]	MOV	ES:[DI], AX	ADD	SI, 2	ADD	DI, 2	LOOP	DOBUpLoop	MOV	DX, DmaAddr8to1	MOV	AX, 0	;copied DOB starts on 200H boundary	OUT	DX, AX	MOV	DX, DmaWordCount	MOV	AX, (OFFSET DOBout) - (OFFSET DOBoutEnd)	;negative value	OUT	DX, AX	MOV	DX, DmaAddr23to9	MOV	AX, FixDOB	SHR	AX, 8	OUT	DX, AX	CALL	StartRoutine	RET		;return ZF from StartRoutine;;---------------------------------------------------------;RDCFetchCmd:	MOV	AL, GetDOB	MOV	DX, RDCCtrlStatus	OUT	DX, AL	MOV	AX, 10		;wait count for all GetDOB commands to RDC	MOV	DL, GetDOB+Complete	CALL	WaitRDC	JZ	CkOpDir	RETCkOpDir:	;first make sure FIFO has been Emptied by RDC getting DOB 	MOV	DX, DmaStatus	IN	AX, DX	MOV	DX, EmptyStatus	MOV	AH, AL	AND	AH, DL	CMP	AH, DH	JE	ThenWhat	MOV	[BX].ExpectedVal, DH	MOV	[BX].ObservedVal, AL	MOV	[BX].Mask8bitReg, DL	OR	PassFaults, BadDmaStatus	RETThenWhat:	MOV	AL, DiskCmd	CMP	AL, Restore	JE	SayGo	CMP	AL, Format	JE	SayGo	CMP	AL, ReadLb	JE	SayGo	CMP	AL, ReadDt	JE	TurnFIFO	CMP	AL, ReadLbDt	JE	TurnFIFO	JMP	LetGo	;let writer or verifier worry about FIFO's and RDC's 			;next move	TurnFIFO:	MOV	AX, FIFOIn	MOV	DX, DmaStatus	OUT	DX, AX		;set direction	TEST	[BX].PassCtl, 02h	;LagRDC?	JZ	SayGo	;not lagging RDC so start it offLetGo:	AND	AL, 0	RETSayGo:	MOV	AL, DoCmd	MOV	DX, RDCCtrlStatus	OUT	DX, AL	AND	AH, 00H		;tell him ok but let the caller worry about				;how long to wait for each DOB operation	RET;;---------------------------------------------------------;GetDiskSt:	;first set DOBin Xfer area to all ones (non-zero error fields)	MOV	CX, ((OFFSET LastIn) - (OFFSET DOBin))/2	;# of words	MOV	DX, -1	MOV	DI, FixDOBPreFill:	MOV	ES:[DI], DX	ADD	DI, 2	LOOP	PreFill	CALL	EmptyFIFO	MOV	AL, RetDOB	;Tell RDC to return the DOB	MOV	DX, RDCCtrlStatus	OUT	DX, AL	MOV	AX, 1		;minimum wait time for RDC to get DOB	MOV	DL, RetDOB+Complete	CALL	WaitRDC	JZ	Bringin	RETBringin:	MOV	AL, GoIdle	;Tell RDC go idle 'til we want him again	MOV	DX, RDCCtrlStatus	OUT	DX, AL	MOV	DX, DmaStatus	MOV	AX, FIFOIn	;Set Direction from RDC to FIFO 	OUT	DX, AX	MOV	DX, DmaAddr8to1	MOV	AX, 0	;Xfer DOB in on 200H boundary	OUT	DX, AX	MOV	DX, DmaWordCount	MOV	AX, (OFFSET DOBin) - (OFFSET LastIn)	;negative value	OUT	DX, AX	MOV	DX, DmaAddr23to9	MOV	AX, FixDOB	SHR	AX, 8	OUT	DX, AX	CALL	StartRoutine	JNZ	NoDOBin;Now copy the DOB back down to DOBin	MOV	CX, ((OFFSET LastIn) - (OFFSET DOBin))/2 ;make word count	MOV	DI, OFFSET DOBin	MOV	SI, FixDOBDOBDownLoop:	MOV	AX, ES:[SI]	MOV	[DI], AX	ADD	SI, 2	ADD	DI, 2	LOOP	DOBDownLoop	AND	AL, 0	;set ZF, OKNoDOBin:	RET;;---------------------------------------------------------;EmptyFIFO:	;Reset Dma	MOV	AX, ResetDmaFifo	CALL    MyExtOffWrRstCtlReg	MOV	AX, ResetDmaFifo	CALL	MyExtOnWrRstCtlReg	RET   ;;---------------------------------------------------------;RestorePerOp:	MOV	DiskCmd, Restore	CALL	ShipDOB	JZ	ExRestore	RETExRestore:	CALL	RDCFetchCmd	JZ	WaitForRest	RETWaitForRest:	MOV	AX, CyPD	MOV	DX, 0	MOV	CH, 0	MOV	CL, HeadPCy	MUL	CX	SHR	AX, 1			;adjust seek time to wait time 	ADD	AX, 4	MOV	DL, DoCmd+Complete	;waiting for command complete	CALL	WaitRDC	JZ	GetRestoreSt	RETGetRestoreSt:	CALL	GetDiskSt	JZ	CheckRestored	RETCheckRestored:	CALL	CkStatus	RET	;return ZF from CkStatus to caller;;---------------------------------------------------------;These routines assumes DS = CS.;PrefillSecBuf:	MOV	SI, 0FFFFH	;complement expected data in buffer(s)	JMP	FillroutineFillSecBuf:	MOV	SI, 0Fillroutine:	MOV	DI, FixSecBuf	TEST	[BX].PassCtl, 80H	;use Hdr data?	JNZ	FillHdr	MOV	CX, 256		 	;number of words in a sector	MOV	AX, [BX].StartData	MOV	DX, [BX].AddData	CALL	FLOOP1	TEST	[BX].PassCtl, 40H	;double sectors?	JNZ	fillmore	RETfillmore:	MOV	AX, [BX].StartData	MOV	CX, 256	CALL	FLOOP1 	RETFillHdr:	MOV	CX, 128			;number of double words in a sector	MOV	AX, Cyl	MOV	DH, Head	MOV	DL, Sec	XOR	AX, SI	XOR	DX, SI	CALL	FLOOP2	TEST	[BX].PassCtl, 40H	;double sectors?	JNZ	fillmorther	RETfillmorther:	MOV	DX, 1	CALL	CalcNxtHdr	MOV	CX, 128	MOV	AX, NxtCyl	MOV	DH, NxtHd	MOV	DL, NxtSec	XOR	AX, SI	XOR	DX, SI	CALL	FLOOP2	RETFLOOP1:	XOR	AX, SI	MOV	ES:[DI], AX	XOR	AX, SI	INC	DI	INC	DI	ADD	AX, DX	CMP	CX, 129	;next AX needs small adjust	JNE	Blurp	SUB	AX, 0100HBlurp:	LOOP	FLOOP1	RETFLOOP2:	MOV	ES:[DI], AX	INC	DI	INC	DI	MOV	ES:[DI], DX	INC	DI	INC	DI	LOOP	FLOOP2	RET;;---------------------------------------------------------;XferSecs:	MOV	DX, DmaAddr8to1	MOV	AX, 0		;buffers on page boundaries	OUT	DX, AX	MOV	DX, DmaWordCount	OUT	DX, AX		;full page transfer(s)	MOV	AX, FixSecBuf	SHR	AX, 8	MOV	DX, DmaAddr23to9	OUT	DX, AX	CALL	StartRoutine	JNZ	RetNoGo		;if one didn't go, then 2 or 3 won't either	PUSHF	TEST	[BX].PassCtl, 40H	;double sectors?	JNZ	OneMoreSec	POPF	RET			;single sector xferred okOneMoreSec:	POPF	MOV	AX, FixSecBuf + 512	SHR	AX, 8	MOV	DX, DmaAddr23to9	OUT	DX, AX	CALL	StartRoutineRetNoGo:	RET ;;---------------------------------------------------------;CkDta:	MOV	DI, FixSecBuf	TEST	[BX].PassCtl, 80H	;using Hdr data?	JNZ	CkHdrData	MOV	CX, 256		 	;number of words in a sector	MOV	AX, [BX].StartData	MOV	DX, [BX].AddDatackdl1:	MOV	SI, ES:[DI]	CMP	SI, AX	JNE	RepDtaErr	ADD	AX, DX	INC	DI	INC	DI	CMP	CX, 129	;next AX needs small [Pre]FillSecBuff's adjust	JNE	Blip	SUB	AX, 0100HBlip:	LOOP	ckdl1	TEST	[BX].PassCtl, 40H	;double sectors?	JZ	RepDtaOK	MOV	CX, 256	MOV	AX, [BX].StartDatackdl2:	MOV	SI, ES:[DI]	CMP	SI, AX	JNE	RepDtaErr	ADD	AX, DX	INC	DI	INC	DI	CMP	CX, 129	JNE	Blup	SUB	AX, 0100HBlup:	LOOP	ckdl2	JMP	RepDtaOKCkHdrData:	MOV	AX, Cyl	MOV	DH, Head	MOV	DL, Sec	CALL	ckhddata	JNZ	RepDtaErr	TEST	[BX].PassCtl, 40H	;double sectors?	JZ	RepDtaOK	MOV	DX, 1	CALL	CalcNxtHdr	MOV	AX, NxtCyl	MOV	DH, NxtHd	MOV	DL, NxtSec	CALL	ckhddata	JNZ	RepDtaErrRepDtaOK:	AND	AL, 0	RET	RepDtaErr:	MOV	[BX].ExpectedData, AX	MOV	[BX].ObservedData, SI	MOV	[BX].Errat, DI	INC	[BX].ErrCount	OR	PassFaults, DataError	RET	ckhddata:	MOV	CX, 128ckhdtaloop:	MOV	SI, ES:[DI]	CMP	SI, AX	JNE	RetDtaErr	;ZF=0	XCHG	AX, DX	INC	DI	INC	DI	MOV	SI, ES:[DI]	CMP	SI, AX	JNE	RetDtaErr	XCHG	AX, DX	INC	DI	INC	DI	LOOP	ckhdtaloop	AND	AL, 0RetDtaErr:	RET;;---------------------------------------------------------;CkStatus:	TEST	[BX].SkipTest, 20H	Jz	CkStatus1CkStaExit:jmp     RetStOK	CkStatus1:        TEST	[BX].SkipTest, 40H	JZ	NormCk	CMP	 HdrErTin,0	je       CkStaExit	MOV	DL, HdrErr	jmp	StuffStuff	NormCk:	MOV	DX, LstErr	MOV	AL, LstErTin	CMP	AL, 0	JE	CkDOBFields	CMP	AL, HdrErTin	JNE	CkLblErT	MOV	DL, HdrErr	JMP	StuffStuffCkLblErT:	CMP	AL, LblErTin	JNE	CkDtaErT	MOV	DL, LblErr	JMP	StuffStuffCkDtaErT:	CMP	AL, DtaErTin	JNE	StuffStuff	MOV	DL, DatErrStuffStuff:	MOV	[BX].ExpectedVal, 0	MOV	[BX].Mask8bitReg, 0FFH	MOV	[BX].ObservedVal, AL	OR	PassFaults, DX	RETCkDOBFields:	;first check op independent fields	MOV	AL, SecPTrkin	;check config parameters copied ok	MOV	AH, HeadPCyin	MOV	DL, SecPTrk	MOV	DH, HeadPCy	CMP	AX, DX	JNE	RetDobErr	MOV	AX, CyPDin	MOV	DX, CyPD	CMP	AX, DX	JNE	RetDobErr	MOV	AX, WriCYin	MOV	DX, WriCY	CMP	AX, DX	JNE	RetDobErr	MOV	AX, PcCYin	MOV	DX, PcCY	CMP	AX, DX	JNE	RetDobErr	MOV	CL, 5	PUSH	BX	MOV	BX, OFFSET FID0inFIDloop:	MOV	AX, [BX]	SUB	BX, (OFFSET DOBin) - (OFFSET DOBout)	MOV	DX, [BX]	ADD	BX, (OFFSET DOBin) - (OFFSET DOBout) + 2	CMP	AX, DX	JNE	PopRetDobErr	LOOP	FIDloop	JMP	PerOpPopRetDobErr:	POP	BXRetDobErr:	MOV	[BX].ObservedData, AX	MOV	[BX].ExpectedData, DX	OR	PassFaults, RetDOBInErr	RETPerOp:	POP	BX	MOV	AH, 0	MOV	DH, 0	MOV	AL, DiskCmdin	MOV	DL, DiskCmd	CMP	AL, DL	JE	PerOpDrvCntlSt	MOV	[BX].ObservedData, AX	MOV	[BX].ExpectedData, DX	OR	PassFaults, DiskCmdErr	RETPerOpDrvCntlSt:	MOV	AH, 0	;AL still has DiskCmdin	AND	AL, 7	;just to make sure though	MOV	CX, AX	ADD	AX, AX	ADD	AX, CX	;mult by 3 byte jmp intsrucs.	MOV	CX, OFFSET OpJumps	ADD	CX, AX	JMP	CXOpJumps:	JMP	CkRestoreOp	;0	JMP	CkFormatOp	;1	JMP	CkRdDtaOp	;2	JMP	CkWrDataOp	;3	JMP	CkWrLblDtaOp	;4	JMP	CkRdLblOp	;5	JMP	CkRdLblDtaOp	;6	JMP	CkVerDtaOp	;7RprtCtlErr:	MOV	[BX].ObservedVal, AL	MOV	[BX].ExpectedVal, DL	MOV	[BX].Mask8bitReg, DH	OR	PassFaults, DiskCtlErr	RETRprtDrvErr:	MOV	[BX].ObservedVal, AL	MOV	[BX].ExpectedVal, DL	MOV	[BX].Mask8bitReg, DH	OR	PassFaults, DiskDrvErr	RETFaultOut:	MOV	[BX].ObservedData, AX	MOV	[BX].ExpectedData, DX	OR	PassFaults, CX	RETCkRestoreOp:	MOV	CX, RestoreErr	MOV	AX, 0		;should be on track 0	MOV	DX, CurCyin	CMP	AX, DX	JNE	FaultOut	MOV	AL, DrvStin	MOV	DX, 0C400H	MOV	AH, AL	AND	AH, DH	CMP	AH, DL	JNE	RprtCtlErr	RET		;last compare will return ZF=1 (status ok)CkFormatOp:	MOV	AL, CntlStin	MOV	DX, 09D08H	MOV	AH, AL	AND	AH, DH	CMP	AH, DL	JE	CkFormDrvSt	JMP	RprtCtlErrCkFormDrvSt:	MOV	AL, DrvStin	MOV	DX, 0DB0AH	MOV	AH, AL	AND	AH, DH	CMP	AH, DL	JE	FormStOK	JMP	RprtDrvErr FormStOK:	MOV	CX, FormatErr	;any other errors are format failures	MOV	AX, CompNoTrkin	MOV	DX, 0	CMP	AX, DX	JE	CkMore	JMP	FaultOut	;not all tracks were formattedCkMore:	JMP	CkExpHdrFPCkRdLblDtaOp:CkRdDtaOp:	MOV	AL, CntlStin	MOV	DX, 09808H	MOV	AH, AL	AND	AH, DH	CMP	AH, DL	JE	CkDrvSt	JMP	RprtCtlErrCkDrvSt:CkWrDataOp:CkWrLblDtaOp:	MOV	AL, DrvStin	MOV	DX, 0C000H	MOV	AH, AL	AND	AH, DH	CMP	AH, DL	JE	DrvStOK	JMP	RprtDrvErr DrvStOK:	MOV	CX, RdLbDtErr	CMP	DiskCmdin, ReadLbDt	JE	CkExpHdrFP	MOV	CX, RdDtaErr	CMP	DiskCmdin, ReadDt	JE	CkExpHdrFP	MOV	CX, WrDtaErr	CMP	DiskCmdin, WriteDt	JE	CkExpHdrFP	MOV	CX, WrLbDtErr	JMP	CkExpHdrFP	CkRdLblOp:	MOV	AL, CntlStin	MOV	DX, 09D08H	MOV	AH, AL	AND	AH, DH	CMP	AH, DL	JE	CkRdLblDrvSt	JMP	RprtCtlErrCkRdLblDrvSt:	MOV	AL, DrvStin	MOV	DX, 0C302H	MOV	AH, AL	AND	AH, DH	CMP	AH, DL	JE	CkRestRdLbl	JMP	RprtDrvErrCkRestRdLbl:	MOV	CX, RdLblErr	JMP	CkExpHdrFP	CkVerDtaOp:	MOV	AL, CntlStin	MOV	DX, 0A020H	MOV	AH, AL	AND	AH, DH	CMP	AH, DL	JE	CkVerDrvSt	JMP	RprtCtlErrCkVerDrvSt:	MOV	AL, DrvStin	MOV	DX, 0C000H	MOV	AH, AL	AND	AH, DH	CMP	AH, DL	JE	CkRestVer	JMP	RprtDrvErrCkRestVer:	MOV	CX, VerDtaErrCkExpHdrFP:	;The Current cylinder and Cylin in the Header image should		; match that determined before the disk operation was started.	MOV	DX, ExpectdCyl	MOV	AX, CurCyin	CMP	AX, DX	JE	CurCyOk	JMP	FaultOutCurCyOk:	MOV	AX, Cylin	CMP	AX, DX	JE	CkHdSecFP	JMP	FaultOutCkHdSecFP:	;The Head/Sector and File Page numbers should match	MOV	AH, Headin	MOV	AL, Secin	MOV	DH, ExpectdHd	MOV	DL, ExpectdSec	CMP	AX, DX	JE	CkFPLo	JMP	FaultOutCkFPLo:	MOV	AX, FPLoin	MOV	DX, ExpectdFPLo	CMP	AX, DX	JE	CkFPHi	JMP	FaultOutCkFPHi:	MOV	AX, FPHiin	MOV	DX, ExpectdFPHi	CMP	AX, DX	JE	RetStOK	JMP	FaultOutRetStOK:	AND	AL, 00H		;Tell caller OK	RET;;---------------------------------------------------------;Ck8bitReg: ;CH = test value, CL = Mask	MOV	[BX].Mask8bitReg, CL	MOV	[BX].ExpectedVal, CH	IN	AX, DX	AND	AX, 0FFH	MOV	[BX].ObservedVal,AL	AND	AL, CL	XOR	AL, CH	RET;;---------------------------------------------------------;Fill8bitResults:	SHR	CX,1	;put 8MSB in ExpectedVal byteFillFed8:	MOV	[BX].ExpectedVal, CL	SHR	AX,1	MOV	[BX].ObservedVal, AL	MOV	[BX].Mask8bitReg, 0FFH	RET;;---------------------------------------------------------;ResetOnly:	MOV	AX, ResetDmaFifo+ResetRDC	CALL    MyExtOffWrRstCtlReg	MOV	AX, ResetDmaFifo+ResetRDC	CALL	MyExtOnWrRstCtlReg	MOV	PassFaults, 0	RET;---------------------------------------------------------MyExtOffWrRstCtlReg:	PUSHA	MOV	DI, ExtMCBlock	CALL    ExtOffWrRstCtlReg	POPA	RET	MyExtOnWrRstCtlReg:	PUSHA	MOV	DI, ExtMCBlock	CALL    ExtOnWrRstCtlReg	POPA	RET;---------------------------------------------------------;ResetDmaRDCInts:	MOV	AX, ResetDmaFifo+ResetRDC	CALL    MyExtOffWrRstCtlReg	MOV	AX, ResetDmaFifo+ResetRDC	CALL	MyExtOnWrRstCtlReg;	mov   ax,32;WaitForReset:mov cx,0;WaitForReset1:loop  WaitForReset1;        dec   ax;	jnz   WaitForReset	MOV	DX, DmaStatus	MOV	CX, ResetStatus	CALL	CK8bitReg	JZ	CheckCRis3	OR	PassFaults, BadDmaStatus	RETCheckCRis3:	MOV	DX, Read2942CR	IN	AX, DX	AND	AX, 0EH	CMP	AL, 6	JE	RETok	MOV	[BX].Mask8bitReg, 0EH	MOV	[BX].ExpectedVal, 06H	MOV	[BX].ObservedVal, AL	OR	[BX].TestFaults, WriteReadCRerrRETok:	RET;;---------------------------------------------------------;StartRoutine:	CMP	DmaIntrCount, 0	;on entry there should be no previous ints	JNE	UnexpInt	INC	[BX].Allows	MOV	DX, StartDma	OUT	DX, AX	;doesn't matter what's in AX	MOV	DX, AllowRDCCmd		;Allow RDCCmd'	IN	AX, DX		; tell Arbitor okWaitDmaIntAfterRDCInt:	MOV	CX, 01FFH	;/// iterations we wait for any intsWaitIntsLoop:	CMP	DmaIntrCount, 1	JE	Gotit	JG	UnexpInt;If we are re-running at this point we need to re-allow dma.	INC	[BX].Allows	MOV	DX, AllowRDCCmd		;Allow RDCCmd'	IN	AX, DX		; tell Arbitor ok againWaitMore:	LOOP WaitIntsLoop			;/// Wait loop;If we reached here we have timed out	OR	PassFaults, NoexpctdInt ;also makes Zero Flag false for caller	RETUnexpInt:	OR	PassFaults, UnexpctdInt	RETGotit:	CMP	CX, 2	JNE	WaitMore	;give it a chance to send too many ints	MOV	DX, DmaStatus	IN	AX, DX	MOV	DmaStatusWaiting, AX  ;save EndOfXfer' at this point	DEC	DmaIntrCount	TEST	PassFaults, BadDmaStatus	;test Bad bit from int routine	RET				; and leave Zero Flag set for no error;;--------------------------------------------------------------------;WaitRDC:	;outer loop count in AX, expected status in DL	MOV	[BX].ExpectedVal, 0	MOV	[BX].ObservedVal, 0	;clear in case we waited before for no	MOV	[BX].Mask8bitReg, 0	; interrupt	CMP	RDCIntrCount, 2	;at most one interrupt should have occurred	JGE	UnexpIntOuterwrdc:	MOV	CX, 0FFFFHInnerwrdc:	MOV	DI, RDCIntrCount	;9	CMP	DI, 1		       ;10	JE	GotRDCInt		;4	JG	UnexpRDCInt		;4	LOOP	Innerwrdc	;///   +15=42 clocks	DEC	AX	CMP	AX, 0	JNE	Outerwrdc	Test	[BX].SkipTest, 40H	Jz	SayIntErr	Test	[BX].SkipTest, 20H	Jz	SayIntErr	Jmp	GotRDCInt	;sort of a lie hereSayIntErr:	OR	PassFaults, NoexpctdInt	RETUnexpRDCInt:	OR	PassFaults, UnexpctdInt	RETGotRDCInt:		;check status says we completed the cmd with no err	DEC	RDCIntrCount	MOV	AH, DL	MOV	DX, RDCCtrlStatus	IN	AL, DX	CMP	AL, AH	JE	WokRet	CMP	AL, DoCmd+Complete+80H	;error bit	JNE	CmdError	MOV	PassFaults, CmdCmpletErr ;leave indication of error though	AND	AH, 0	; let caller call CkStatus to find error type	RETCmdError:		MOV	[BX].ExpectedVal, AH	MOV	[BX].ObservedVal, AL	MOV	[BX].Mask8bitReg, 0FFH	OR	PassFaults, CmdCmpletErrWokRet:	TEST	[BX].PassCtl, 2		;lagging RDC?	JZ	WaitRet	INC	[BX].Allows	MOV	DX, AllowRDCCmd	IN	AX, DX	AND	AL, 0WaitRet:	RET;;--------------------------------------------------------------------;MemParityInt:ClI					;disable interrupts	    PUSHA	    MOV	DI, ExtMCBlock ;Index to Monitor Control Block	    MOV	SI, ExtMFCBlock ;Index to Monitor File Control Block	    Mov bx,[si].TCBPointer ;Get Index to TCB	    TEST [bx].DiskErrCtl,DiskNoMemParity	    jnz MemParityIntRet 	    or [di].IOPFault,MemoryParityErrorMemParityIntRet:MOV  AL, nonSpecificEOI			;Reset IS0	    OUT  i8259MasterAddr0, Al		;  OCW2_ 061h 	    cmp ParityCount,00FFH	    JE MemParityRet            CALL ExtReadMemStatus	    inc  ParityCount    MemParityRet:POPA            STI					;Reanable the interrupts	    IRet ParityCount Dw 0 	    	;; ---------------------------------------------------------;SetDmaIntVectors:	CLI	;stop interrupt requests for just a bit	PUSH	BX	MOV	AX, 0	MOV	DS, AX	MOV	BX, ExtInterruptV1		MOV	AX, OFFSET MemParityInt	;	MOV	[bx].ParityV, AX	MOV	BX, ExtInterruptV2	MOV	AX, OFFSET DmaIntrHandler	MOV	[BX].RDCDmaV, AX 	MOV	AX, OFFSET RDCIntrHandler	MOV	[BX].RDCContrV, AX	MOV	AX, CS	MOV	DS, AX	AND	[di].EnableIntC1C2,ParityIntEnAble         AND	[DI].EnableIntC1C2, EnFIFODisk	MOV ParityCount,0	CALL ExtReadMemStatus    	CALL ExtReadMemStatus    	CALL ExtReadMemStatus 	CALL	ExtEnableInt	POP	BX	STI	RET;; ---------------------------------------------------------;DmaIntrHandler: 	ClI			;disable interrupts	   	PUSHA	   	MOV	SI, ExtMFCBlock ;Index to Monitor File Control Block	   	Mov	bx,[si].TCBPointer  ;Get Index to TCB	   	INC	DmaIntrCount		MOV  AL, nonSpecificEOI		;Reset IS5	   	OUT  i8259SlaveAddr0, Al	;  OCW2_ 061h 	 	MOV  AL, 00Bh		;Set up to read IS register	 	OUT  i8259SlaveAddr0, Al	;OCW3_ 00Bh	 	IN   AL, i8259SlaveAddr0	;Read Slave 8259 IS register	 	CMP  AL, 0			;Check if another interrupt is	  	JNE  ClearDmaInt		;  in service	   	MOV  AL, nonSpecificEOI	;Write an EOI command for the 		  	OUT  i8259MasterAddr0, AL	;  Master 8259ClearDmaInt:	MOV	DX, DmaStatus	;DmaStatus Register		IN	AL, DX		;"poll" the Dma Status register		MOV	DmaStatusStored, AX		TEST	AX, 01h			;Mask to bit 0, Error 		JZ	DmaIntrRt		OR	PassFaults,BadDmaStatus		MOV	[BX].ExpectedVal, 0		MOV	[BX].ObservedVal, AL		MOV	[BX].Mask8bitReg, 1DmaIntrRt:	POPA          	STI	;Reanable the interrupts	 	IRet	;;--------------------------------------------------------------------;RDCIntrHandler:	ClI	PUSHA	MOV	SI, ExtMFCBlock ;Index to Monitor File Control Block	Mov	bx,[si].TCBPointer  ;Get Index to TCB	INC	RDCIntrCount	MOV	AL, nonSpecificEOI		;Reset IS5	OUT	i8259SlaveAddr0, Al	;  OCW2_ 061h 	MOV	AL, 00Bh		;Set up to read IS register	OUT	i8259SlaveAddr0, Al	;OCW3_ 00Bh	IN	AL, i8259SlaveAddr0	;Read Slave 8259 IS register	CMP	AL, 0			;Check if another interrupt is	JNE	ClearRDCInt		;  in service	MOV	AL, nonSpecificEOI	;Write an EOI command for the 		OUT	i8259MasterAddr0, AL	;  Master 8259ClearRDCInt:	POPA	STI	IRet	;;--------------------------------------------------------------------;FillArea:	PUSH	BX	MOV	AH, 0	MOV	AL, [BX].WordLen	MOV	DX, 0	SUB	DX, AX		;word length in 2's complement	SHL	DX, 1		;line up to addr bits 8-1	AND	DX,01FEH	;Mask upper bits	MOV	WCIn2sComp, DX	MOV	DX, MemArea	MOV	[BX].FIFOInat, DX ;place where Xfer in will start	MOV	DX, 8200H	;place where 2nd Xfer out will start	SHL	AX, 1	;change word length to byte length	CMP	AX, 0	;is this the special case where 0=256 words?	JNE	NoFix	MOV	AX, 200HNoFix:	MOV	ByteLen, AX	SUB	DX, AX	;back off by 1st xfer byte length	MOV	Blk1, DX	;place where Xfer out will start;;Now fill xfer out area starting as 0000:Blk1 for two xfer lengths with test data and preset xfer in area at ES:MemArea with complement data.;	MOV	AX, [BX].AddData	MOV	DX, [BX].StartData	PUSH	DX		;save a copy	PUSH	ES		;save and restore for ES:MemArea	MOV	CX, 2000H	MOV	ES, CX	MOV	CX, ByteLen	;# of words in 2 xfers	MOV	BX, Blk1	;place where xfer to FIFO will startWPLoop:	MOV	ES:[BX], DX	ADD	BX, 2	ADD	DX, AX	LOOP	WPLOOP	POP	ES	POP	DX	NOT	DX		;complement xfer in data area	MOV	CX, Bytelen	MOV	BX, MemAreaPreLoop:	MOV	ES:[BX], DX	ADD	BX, 2	ADD	DX, AX	LOOP	PreLoop	POP	BX	RET;;--------------------------------------------------------------------;CheckArea:	MOV	SI, [BX].ErrCount	PUSH	SI	;save count before this compare	PUSH	ES	MOV	DI, 2000H	MOV	ES, DI;First check no overwrite in xfer to FIFO area	MOV	AX, [BX].AddData	MOV	DX, [BX].StartData	MOV	CX, ByteLen	MOV	DI, Blk1OvrWLoop:	MOV	SI, ES:[DI]	CMP	SI, DX	JE	Ok2	INC	[BX].ErrCount	MOV	[BX].Errat, DI	MOV	[BX].ExpectedData, DX	MOV	[BX].ObservedData, SI	OR	PassFaults, OvrWrtErr	TEST	[BX].DiskErrCtl, DiskNoStop	JE	CkRETOk2:	ADD	DX, AX	ADD	DI, 2	LOOP	OvrWLoop;Now check data transferred in is ok	POP	ES	;restore ES	PUSH	ES	;to satisfy CkRET	MOV	DX, [BX].StartData	MOV	CX, ByteLen	MOV	DI, MemAreaCkLoop:	MOV	SI, ES:[DI]	CMP	SI, DX	JE	Ok3	INC	[BX].ErrCount	MOV	[BX].Errat, DI	MOV	[BX].ExpectedData, DX	MOV	[BX].ObservedData, SI	OR	PassFaults, DataError 	TEST	[BX].DiskErrCtl, DiskNoStop	JE	CkRETOk3:	ADD	DX, AX	ADD	DI, 2	LOOP	CkLoopCkRET:	POP	ES	POP	SI	CMP	SI, [BX].ErrCount  ;set Zero Flag if no errors this pass.	RET	DiskPreProcess:	PUSH	DI	MOV	BX, 6	PUSHA	CALL	ExtReadEEProm	MOV	MyTemp, AX	POPA	MOV	AX, MyTemp	MOV	SecPTrk, AL	MOV	HeadPCy, AH	MOV	BX, 7	PUSHA	CALL	ExtReadEEProm	MOV	MyTemp, AX	POPA	MOV	AX, MyTemp	MOV	CyPD, AX	MOV	BX, 8	PUSHA	CALL	ExtReadEEProm	MOV	MyTemp, AX	POPA	MOV	AX, MyTemp	MOV	WriCY, AX	MOV	BX, 9	PUSHA	CALL	ExtReadEEProm	MOV	MyTemp, AX	MOV	BX, 23	CALL	ExtReadEEProm	MOV	MyTemp1, AX	POPA	MOV	AX, MyTemp	MOV	PcCy, AX	MOV	BX, ExtTCBlockloc	;Get Base to 0th TCB	MOV	DI, SIZE FIFODiskTCB	;size of a TCB, index 1nd TCB	ADD	DI, DI			;index 2rd	MOV	AX, CyPD	SUB	AX, 1	;last cylinder	MOV	[BX + DI].StartCy, AX	ADD	DI, SIZE FIFODiskTCB	;3th TCB	MOV	[BX + DI].StartCy, AX	MOV	[BX + DI].EndCy, AX	;still 3th	ADD	DI, SIZE FIFODiskTCB	;4th TCB	MOV	[BX + DI].EndCy, AX	ADD	DI, SIZE FIFODiskTCB	;5th TCB	ADD	DI, SIZE FIFODiskTCB	;6th TCB	MOV	[BX + DI].EndCy, AX	MOV	[BX + DI].StartCy, AX	mov     ax,MyTemp1	ADD	DI, SIZE FIFODiskTCB	;7th TCB	MOV	[BX + DI].EndCy, AX	MOV	[BX + DI].StartCy, AX	SUB	DI, SIZE FIFODiskTCB	;6th TCB	SUB	DI, SIZE FIFODiskTCB	;5th TCB	SUB	DI, SIZE FIFODiskTCB	;4th TCB	SUB	DI, SIZE FIFODiskTCB	;3th TCB	SUB	DI, SIZE FIFODiskTCB	;2th TCB	MOV	AX, CyPD	dec     ax	MOV	[BX + DI].EndCy, AX	MOV	AH, HeadPCy	MOV	AL, SecPTrk	DEC	AH	DEC	AL	MOV	[BX + DI].EndHd, AH	;2rd	MOV	[BX + DI].EndSec, AL	ADD	DI, SIZE FIFODiskTCB	MOV	[BX + DI].EndHd, AH	;3th	MOV	[BX + DI].EndSec, AL	ADD	DI, SIZE FIFODiskTCB	MOV	[BX + DI].EndHd, AH	;4th	MOV	[BX + DI].EndSec, AL	ADD	DI, SIZE FIFODiskTCB	MOV	[BX + DI].EndHd, AH	;5th	MOV	[BX + DI].EndSec, AL	ADD	DI, SIZE FIFODiskTCB	MOV	[BX + DI].EndHd, AH	;6th	MOV	[BX + DI].EndSec, AL	;SUB	DI, SIZE FIFODiskTCB	;5th	;SUB	DI, SIZE FIFODiskTCB	;4th	;SUB	DI, SIZE FIFODiskTCB	;3th	;CMP	HeadPCy, 8	;Micropolis or Q540?	;JNE	nxtype	;MOV	[BX + DI].AddSec, 9	;MOV	[BX + DI].StartSec, 1	POP	DI	Ret;nxtype:	;CMP	HeadPCy, 5	;Tandon TM703?	;JNE	nextype	;MOV	[BX + DI].StartSec, 2	;POP	DI	;Ret;nextype:	;CMP	HeadPCy, 2	;ST - 213?	;JNE	nxTyp	;MOV	[BX + DI].StartSec, 3	;POP	DI	;Ret;nxTyp:	;CMP	HeadPCy, 6	;Q520?	;JE	setss	;POP	DI	;Ret;setss:	;MOV	[BX + DI].AddSec, 5	;POP	DI	;RetMyTemp	DW	0MyTemp1 DW	0DiskFRUList:mov Bx,0 	   mov BL, [SI].TestN	   SHL Bx,1	   mov ax, WORD PTR DiskList0 [bx]	   CALL ExtMessageDiskFRUList1:CALL ExtDoRunTimeWork	   cmp [di].CurrentInputByte,KSP	   jne DiskFRUList1	   Ret DiskList0 DW  0092FHDiskList1 DW  0902FHDiskList2 DW  0902FHDiskList3 DW  0902FHDiskList4 DW  0902FHDiskList5 DW  0902FHDiskList6 DW  0902FHDiskList7 DW  0902FHDiskList8 DW  0902FHDiskList9 DW  0902FHDiskListA DW  0902FHDiskListB DW  0902FHDiskListC DW  0902FHDiskListD DW  0902FHDiskListE DW  0902FHDiskListF DW  0902FHDiskList10 DW  0902FH	;;-----------------------;BadTrackTbl:	;12MSB (Cylinder), 4LSB (Head)BadT	DW	32 DUP (?) ;;-----------------------;DOBout:DtaECC		DB	0		DB	0		DB	0		DB	0SecNT		DW	0FFFFHSecPTrk		DB	10H		DB	0HeadPCy		DB	2		DB	0CyPD		DW	00132HFstSec		DB	0		DB	0WriCY		DW	0FFFFHPcCy		DW	00080HWEndC		DB	0FFH		DB	0HdrErT		DB	0		DB	0LblErT		DB	0		DB	0DtaErT		DB	0		DB	0LstErT		DB	0		DB	0CurCyout	DW	0FFFFHECCFlg		DB	1		DB	0Cyl		DW	0Sec		DB	0Head		DB	0Resv1l		DB	0Resv1h		DB	0Resv2l		DB	0Resv2h		DB	0CntlSt		DB	0DrvSt		DB	0DiskCmd		DB	0		DB	0CompNoTrk	DW	0FID0		DW	0FID1		DW	0FID2		DW	0FID3		DW	0FID4		DW	0FPLo		DW	0HFPHi		DW	0HFType		DW	0BootCLLo	DW	0BootCLHi	DW	0DOBoutEnd:DOBin:DtaECCin	DB	0		DB	0		DB	0		DB	0SecNTin		DW	0SecPTrkin	DB	0		DB	0HeadPCyin	DB	0		DB	0CyPDin		DW	0FstSecin	DB	0		DB	0WriCYin		DW	0PcCyin		DW	0WEndCin		DB	0		DB	0HdrErTin	DB	0		DB	0LblErTin	DB	0		DB	0DtaErTin	DB	0		DB	0LstErTin	DB	0		DB	0CurCyin		DW	0ECCFlgin	DB	0		DB	0Cylin		DW	0Secin		DB	0Headin		DB	0Resv1lin	DB	0Resv1hin	DB	0Resv2lin	DB	0Resv2hin	DB	0CntlStin	DB	0DrvStin		DB	0DiskCmdin	DB	0		DB	0CompNoTrkin	DW	0FID0in		DW	0FID1in		DW	0FID2in		DW	0FID3in		DW	0FID4in		DW	0FPLoin		DW	0FPHiin		DW	0FTypein		DW	0BootCLLoin	DW	0BootCLHiin	DW	0Lastin:;MonitorCode	ENDS;;;--------------------------------------------------------------------	END
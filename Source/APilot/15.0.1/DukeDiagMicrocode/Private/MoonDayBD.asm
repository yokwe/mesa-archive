$	DEBUG MOD186; MoonDayBD.asm; last edited by HEM		21-Jul-86 19:14:58;;General routines for display control and memory access are;kept in this file; 	NAME DisplayB	$	TITLE(DisplayB)$	NOLIST		;Next line includes defs$	INCLUDE(MoonSys.def)$	INCLUDE(MOONLINK.def);-----------------------------------------------------------------;DAYBREAK ADDRESSES;VertStoreDayBreak             EQU   0E800H;	Starting locn of vertical control storeHorzStoreDayBreak             EQU   0EC00H;	Starting locn of horizontal control store;DisplCntlRegDayBreak          EQU   0EC80H;	Data display control registerBorderPatternLowDayBreak      EQU   0EC81H;	Border pattern low byteBorderPatternHighDayBreak     EQU   0EC82H;	Border pattern high byte;CursorWordPortDayBreak        EQU   0EC83H;	Word number of cursor positionCursorOffsetPortDayBreak      EQU   0EC84H;	Word offset of cursor positionCursorLinePortLowDayBreak     EQU   0EC85H;	Line number of cursor position (Low byte)CursorLinePortHighDayBreak    EQU   0EC86H;	Line number of cursor position (High byte);DMCWordsPerLineDayBreak       EQU   0EC88H;	DMC register that contains number of words per lineDMCDisplStrtAddrLowDayBreak   EQU   0EC89H;	DMC register that holds low byte of display mem. strt addr.DMCDisplStrtAddrHighDayBreak  EQU   0EC8AH;	DMC register that holds high byte of display mem. strt addr.DisplayTypePort	EQU	0ECCCH		;read this to get display size data;DisplMemStatReg0    EQU   0ED20H       SysMemStatReg1      EQU   0ED21HSysMemStatReg2      EQU   0ED22HSysMemStatReg3      EQU   0ED23HSysMemStatReg4      EQU   0ED24HSysMemStatReg5      EQU   0ED25HCursorBufferPortsDayBreak     EQU   0ED00H;	Cursor buffer starting locn.VideoResetPort		      EQU   0ED60H;	Software reset port of the Display;NumBitMapBytes                EQU           32;    Number of words in bit mapNumHorzBytes                  EQU          0AH;    Number of values in horizontal control storeNumVertBytes                  EQU          09H;    Number of values in vertical control storeDisplMemStrtLow               EQU           00;    Low byte of display memory starting addressDisplMemStrtHigh              EQU           00;    High byte of display memory starting address;MaxCursorOffset		      EQU	15	;HorzActiveWords		      EQU	56	;4 borders words + 52 bit wordsMaxLine		      	      EQU	41	;Total# pixels / 16 ;-----------------------------------------------------------------;displayStructure is a structure that contains related DCM information;displayStructure is a mirror image of the Struc record declared.;displayStructure     STRUC  map             DB	80H, 00H		;UpArrow cursor 		  DB	0C0H,  00H			  DB	0E0H, 00H	  	  DB	0F0H, 00H 		  DB	0F8H, 00H		  DB	0FCH, 00H		  DB	0FEH, 00H		  DB	0F0H, 00H		  DB	0D8H, 00H		  DB	98H, 00H		  DB	0CH, 00H 		  DB	0CH, 00H		  DB	06H, 00H		  DB	06H, 00H		  DB	03H, 00H		  DB	03H, 00H      ;Cursor bit mapdisplayStructure  ENDS;-----------------------------------------------------------------$	LIST		;Previous line included Daisy.def;--------------------------------------------MonitorCode	SEGMENT COMMON	ASSUME	CS:MonitorCode, SS:MonitorCode, DS:MonitorCode         ORG 	ExtDisplayLoc	;-----------------------------------------------------------------         jmp DisplayStart	 jmp StartDisplay	 jmp StopDisplay	 jmp CursorPattern	 jmp ReadMemStatus ;-----------------------------------------------------------------cursorWordLocn  DB    25H          ; Cursor position word coordcursorOffset    DB    8          ; Cursor position bit offsetcursorYLow      DB    50H          ; Y-coord. of cursor position (low byte)cursorYHigh     DB    0          ; Y-coord. of cursor position (high byte)quadWordsPerLine           DB  13horzCounts                 DW  OFFSET horCounts15    verCounts                  DW  OFFSET verCounts15        ;Set up location for the structuredisplayStruc             displayStructure        <>;-----------------------------------------------------------------;Set up the tables for the horizontal and vertical control stores .;;horControlStore is an array that contains the values that will be put into the horizontal control store.;horControlStore     DB        03H;    HSync, HBlank                    DB        08H;    HSync, HBlank, VertClk #2                    DB        00H;    Border                     DB        04H;    Picture                    DB        0CH;    Picture, VertClk #3                    DB        04H;    Picture                    DB        00H;    Border                    DB        02H;    HBlank                    DB        0AH;    HBlank, VertClk#1		    DB        02H;    HBlank;;Each horCounts is a parallel array to the horControlStore array.;It contains the number of times (in Decimal) each value in horControlStore will be used.;Since the numbers here depend on CRT size, there is one array for each CRT size.;horCounts15         DB        10;     Number of HSync, HBlank words                    DB        01;     Number of HSync, HBlank, VertClk #2 words                    DB        01;     Number of Border words                    DB        32;     Number of Picture words                    DB        01;     Number of Picture, VertClk #3 words                    DB        19;     Number of Picture words                    DB        02;     Number of Border words                    DB        01;     Number of HBlank words                     DB        01;     Number of HBlank, VertClk#1 words		    DB        02;     Number of HBlank words;;;verControlStore contains the values that will be put into the vertical control store.verControlStore     DB	      02H;			    DB        00H;    Top Border                    DB        04H;    Bip Map (4 bytes are needed to hold the counts for 19")                    DB        04H;    Bit Map                    DB        04H;    Bit Map		    DB        04H;    Bit Map                    DB        00H;    Bottom Border		    DB        03H;    VSync, VBlank                    DB        0BH;    VSync, VBlank, EOF;Each verCounts is a parallel array to the verControlStore array.;It contains the number of times each value in verControlStore will be used.;Since the numbers here depend on CRT size, there is one array for each CRT size.;verCounts15         DB 02 ;		    DB 30 ;Top Border  -- 16 even field, 16 odd field                    DB 255 ;Bip Map    -- 317 even field, 316 odd field                    DB 255 ;Bit Map   -- These four bit map bytes add to 633                    DB 60 ;Bit Map		    DB 63 ;Bit Map                    DB 33 ;Bottom Border      -- 16 even field, 16 odd field		    DB 37 ;VSync, VBlank      -- 19 even field, 19 odd field                    DB 02 ;VSync, VBlank, EOF -- 1 even field, 1 odd field		    ;CursorSpeed		DW	2000	;set delay for cursor movement;IncrVertDist:	   DW	10H	;16 pixels = 1 vertical line;CurrentCursorLine: DW	0C0H	;must start with this value because of HW design;---------------------------------------------------------------DisplayStart:PUSHA	     MOV     DX, VideoResetPort	;disable video	     IN    AL, DX  ;Input command to Reset display	     Call DisplayDelay             MOV    AL, 0             OUT    DX, AL		     MOV    BX, 13	     Call   ExtReadEEProm	     cmp    al,1 	     je     DisplayStart1             MOV    DX, DisplayTypePort	     IN     AL, DX  ;Input command FOR display SIZE	     TEST   AL,2	     JNZ DisplayCom	     and  cursorYLow,0BFHDisplayCom:  TEST   AL,1	     JNZ Display15	     MOV    cursorWordLocn,36H	     MOV    quadWordsPerLine,12HDisplay15:   jmp    DisplayStart2				DisplayStart1:	     ;INITIALIZE DAYBREAK REGISTERS; INITIALIZE HORIZONTAL CONTROL STORE             MOV    CH, 0                       ;Initialize high byte of CX to 0	     MOV    BX, HorzCounts              ;BX points @ count array             MOV    DI, 0                       ;DI points @ element in array             MOV    DX, HorzStoreDayBreak ;DX points @ horz.cntl store output portStartHorz:   MOV    AL, horControlStore[DI]     ;Get value to output             MOV    CL, [BX][DI]                ;Get counts in CLHorzOut:     OUT    DX, AL                      ;Output byte             INC    DX                          ;Point to next location             LOOP   HorzOut                     ;Output same byte til CX=0             INC    DI                          ;Point @ next item in array             CMP    DI, NumHorzBytes            ;Is DI=Number items in array?             JL     StartHorz            ;If done, go do vertical cntl store	     ; INITIALIZE VERTICAL CONTROL STOREVertInit:    MOV    BX, verCounts               ;BX points @ count array             MOV    DI, 0                       ;DI points @ element in array             MOV    DX, VertStoreDayBreak ;DX points @ vert.cntl store output port	     StartVert:   MOV    AL, verControlStore[DI]     ;Get value to output             MOV    CL, [BX][DI]                ;Get counts in CLVerOut:      OUT    DX, AL                      ;Output byte             INC    DX                          ;Point to next location             LOOP   VerOut                      ;Output same byte til CX=0             INC    DI                          ;Point @ next item in array             CMP    DI, NumVertBytes            ;Is DI=Number items in array?             JL     StartVert                   ;If done, return	     DisplayStart2:CALL   DaybreakCursorPosition; Initialize DMC  	     MOV    AL, DisplMemStrtLow                    INC    DX             OUT    DX, AL       ;Output low byte displ. mem. starting addr.             MOV    AL, DisplMemStrtHigh                    INC    DX             OUT    DX, AL   ;Output high byte displ. mem. starting addr.	     ; Initialize DDC; Initialize border pattern;b7-b4 = default cursor/data mix = E;b3 = Pic/bdr' = Pic = 1;b2 = not used = 0;b1 = video disable = 0;b0 = interlaced = 0	     CALL	DaybreakBorderPattern	;set border pattern	    ;CALL	DaybreakBackgndCommand	;set backgroundStopDisp:	     MOV    AL, 0                    MOV    DX, DMCWordsPerLineDayBreak             OUT    DX, AL                      ;Output number words per line	     MOV    DX, DisplayTypePort		;Determine whether gate array or CMOS DDC	     IN     AL, DX			;If bit1 is 0, it is CMOS DDC	     TEST   AL, 00000010B	     JZ     CmosDDC             MOV    AL, 5EH			;Get command	     JMP    SHORT StartDispCmosDDC:	     MOV    AL, 5CH			;Get commandStartDisp:	     MOV    DX, DisplCntlRegDayBreak   ;DX points @ display cntl reg             OUT    DX, AL                     ;Output command and start display	     POPA	     RetStopDisplay:	     PUSHA             MOV    BX, OFFSET displayStruc    ;BX points at display structure             jmp StopDisp	      ; START THE DISPLAYStartDisplay:	     PUSHA	     MOV    BX, OFFSET displayStruc    ;BX points at display structure             MOV    AL, quadWordsPerLine                    MOV    DX, DMCWordsPerLineDayBreak             OUT    DX, AL                      ;Output number words per line             MOV    AL, 6EH         ;Get command             jmp StartDisp	     					; ;VerticalSync:		PUSHA                       ; MOV    DX, DisplCntlRegDayBreak                       ; mov cx,0;VerticalNotHigh:	in al,dx			;TEST AL,2			;JZ   VerticalHigh			;LOOP  VerticalNotHigh;VerticalHigh:		mov cx,0;VerticalNotLow:	        in al,dx			;TEST AL,2			;Jnz   VerticalLow			;LOOP  VerticalNotLow;VerticalLow:    	POPA                       ; Ret			 		;*************************;CURSOR POSITION PROCEDURE ;*************************DaybreakCursorPosition: PUSHA                        MOV    DX, CursorWordPortDayBreak                         MOV    BX, ExtcursorWordLocn			MOV    CX, 4  ;Output 4 valuesCursorOut:              MOV    AL, BYTE PTR [BX]    ;Get value to output in AL                        OUT    DX, AL          ;Output new cursor position value                        INC    DX       ;DX points to next cursor location port			INC    BX      ;BX points to next value			LOOP   CursorOut     ;Output values til CX = 0			POPA		        RET;************************;CURSOR PATTERN PROCEDURE;************************;ax contains digits to displayCursorPattern:          PUSHA                       ; Call VerticalSync			mov cx,4PatLoop:		MOV    si, OFFSET displayStruc.map  ;si points at display structure			cmp cx,2			jg Checkodd			add si,16Checkodd:		test cx,1			jz NotOdd			inc siNotOdd:                 rol ax,4			mov bx, ax			and bx,000FH			ROL  bX, 3			add  bX, OFFSET zeroMP			push cx			                        mov cx,8InterPatLoop:		mov dl,[bx]                        cmp si,OFFSET displayStruc.map+15			jle upper			ROL  dL, 1upper:                  mov [si],dl			add si,2			add bx,1		        loop InterPatLoop			pop cx			loop PatLoop												MOV    BX, OFFSET displayStruc    ;BX points at display structure			MOV    DX, CursorBufferPortsDayBreak			MOV    SI, 0  ;SI indexes source word in map			MOV    CX, NumBitMapBytes  ;Load loop countDaybreakMap:            MOV    AL, [BX].map[SI]    ;Get value to output in AL                        xor    al,0FFH                        OUT    DX, AL      ;Output value to port                        INC    DX ;DX points to next cursor bit map location port			INC    SI     ;SI points to next value			LOOP   DaybreakMap ;Loop until cursor map covered			POPA              		Ret;*************************;BORDER PATTERN PROCEDURES;*************************DaybreakBorderPattern: PUSHA                       MOV    DX, BorderPatternLowDayBreakBorderOutDaybreak:     MOV    AL, 0FFH                       OUT    DX, AL ;Output border pattern                       INC    DX ;DX points to next border pattern port		       OUT    DX, AL ;Output border pattern		       POPA		       RETDisplayDelay:		MOV	CL, 0FFHDisplayLoop:	        loop	DisplayLoop			RET			ReadMemStatus:          PUSHA			MOV SI, ExtMFCBlock ;Index to Monitor File Control Block		        Mov bx,[si].TCBPointer;Get Index to TCB			add bx,2	                Mov dx,DisplMemStatReg0	     	                Call GetStatus			OUT dx,al			POPA                        RetGetStatus:              IN al,dx                        Mov ah,al	                        inc dx                        IN al,dx			TEST al,80H		        jz LogStatus			cmp dx,SysMemStatReg5			je GetStatusRet			inc dx			jmp GetStatusLogStatus:		xchg al,ah                        mov WORD PTR [bx],axGetStatusRet:		Ret	    	    		;******************************;SET BACKGROUND/OUTPUT COMMANDS;******************************DaybreakBackgndCommand: PUSHA                        MOV    DX, DisplCntlRegDayBreak                        MOV    AL, 6EH                          OUT    DX, AL      ;Output to display control register			POPA		        RET			;Set up tables containing the cursor pattern values for representing each digit.; Here, only 5 pixels are used for width (and the 3 most sig. pixels padded with 0s),; and 7 pixels for height (with the 8th pixel as a 0);zeroMP	DB	00011100B	DB	00100010B	DB	00100010B	DB	00100010B	DB	00100010B	DB	00100010B	DB	00011100B	DB	00000000B;one	DB	00001000B	DB	00011000B	DB	00101000B	DB	00001000B	DB	00001000B	DB	00001000B	DB	00111110B	DB	00000000B;two	DB	00011100B	DB	00100010B	DB	00000100B	DB	00001000B	DB	00010000B	DB	00100000B	DB	00111110B	DB	00000000B;three	DB	00011100B	DB	00100010B	DB	00000010B	DB	00001100B	DB	00000010B	DB	00100010B	DB	00011100B	DB	00000000B;four	DB	00100100B	DB	00100100B	DB	00100100B	DB	00111110B	DB	00000100B	DB	00000100B	DB	00000100B	DB	00000000B;five	DB	00111110B	DB	00100000B	DB	00100000B	DB	00011100B	DB	00000010B	DB	00100010B	DB	00011100B	DB	00000000B;six	DB	00011100B	DB	00100010B	DB	00100000B	DB	00111100B	DB	00100010B	DB	00100010B	DB	00011100B	DB	00000000B;seven	DB	00111110B	DB	00000010B	DB	00000100B	DB	00001000B	DB	00010000B	DB	00010000B	DB	00010000B	DB	00000000B;eight	DB	00011100B	DB	00100010B	DB	00100010B	DB	00011100B	DB	00100010B	DB	00100010B	DB	00011100B	DB	00000000B;nine	DB	00011100B	DB	00100010B	DB	00100010B	DB	00011110B	DB	00000010B	DB	00100010B	DB	00011100B	DB	00000000B	;able	DB	00001000B	DB	00010100B	DB	00100010B	DB	00111110B	DB	00100010B	DB	00100010B	DB	00100010B	DB	00000000B	baker	DB	00111000B	DB	00100010B	DB	00100010B	DB	00111100B	DB	00100010B	DB	00100010B        DB	00111000B	DB	00000000B	charle	DB	00011100B	DB	00100010B	DB	00100000B	DB	00100000B	DB	00100000B	DB	00100010B        DB	00011100B	DB	00000000B	dog	DB	00111000B	DB	00100100B	DB	00100010B	DB	00100010B	DB	00100010B	DB	00100100B        DB	00111000B	DB	00000000B	easy	DB	00111110B	DB	00100000B	DB	00100000B	DB	00111110B	DB	00100000B	DB	00100000B        DB	00111110B	DB	00000000B	fox	DB	00111110B	DB	00100000B	DB	00100000B	DB	00111110B	DB	00100000B	DB	00100000B        DB	00100000B	DB	00000000B	       MonitorCode	ENDS	END 
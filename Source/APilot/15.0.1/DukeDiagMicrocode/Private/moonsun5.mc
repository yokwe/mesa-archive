{File name:  <Workstation>mc>Sunlight-O.mc}Reserve[0001,001E];{ For moonBus}Reserve[0020,002E];{ For moonBus}Reserve[0030,003E];{ For moonBus}Reserve[0040,005F];{ For moonBus}Reserve[0060,00FF];{ moonsun1}Reserve[0110,0180];{ moonsun1}Reserve[0181,01FF];{ moonsun2}Reserve[0210,03CF];{ moonsun2}Reserve[03D0,03FF];{ moonsun3}Reserve[0401,04D2];{ moonsun3}Reserve[04D4,04FF];{ moonsun3}Reserve[0400];	   { moonsun4}Reserve[0500,05FF];{ moonsun4}Reserve[0600,060F];{ moonsun4}Reserve[0700,070F];{ moonsun4}Reserve[0800,08D2];{ moonsun4}Reserve[08D4,08FF];{ moonsun4}{Reserve[0610,06D2];{ moonsun5}Reserve[06D4,06FF];{ moonsun5}}Reserve[04D3];	{moontime }Reserve[06D3];	{moontime }Reserve[0710,07FF];{ moontime}Reserve[0AD3,0AD4];{ moontime}Reserve[0900,09FF];{ MoonMr}Reserve[0A00,0AD2];{ For OTHER TEST}Reserve[0AD5,0FEF];{ For OTHER TEST}Reserve[0100,0104];{ For OTHER TEST}Reserve[0106,010F];{ For OTHER TEST}Reserve[0200,0204];{ For OTHER TEST}Reserve[0206,020F];{ For OTHER TEST}Reserve[0FF0,0FF4];{ For OTHER TEST}Reserve[0FF6,0FFE];{ For OTHER TEST}Set[StkOVF, 0F];SetTask[0]; StartAddress[TERROR1];TERROR1:R1 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[0];        R6 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[1F];        R8 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[3F];        R1 _ R1 or R6,ClrIE,	c*, at[2F];        R1 _ R1 or R8,	c*, at[105];START:	XC2npcDisp, c2;	BRANCH[BadCy, GoodCy, 0D],	c3;BadCy:	Noop,	c*, at[0D,10,GoodCy];	Noop,	c*;	GOTO[START]	c*;	GoodCy:	SetIE ,	c1, at[0F,10,BadCy];	Xbus _ R1 LRot0, XwdDisp,	c2;	DISP2[TrapType],	c3;   	{5. Microcode trap tests}	{Should never get CS Parity Err}TrapType:	GOTO[CSPar],	c1, at[0,4,TrapType];	GOTO[TrapTest],	c1, at[1,4,TrapType];	GOTO[NotCSPar],	c1, at[2,4,TrapType];	GOTO[NotCSPar],	c1, at[3,4,TrapType];NotCSPar:	R7 _ UA5,	c2;	R7 _ R7 xor 0E2,	c3;{Which Trap Test are we doing?}	[] _ R7, NZeroBr,	c1;	[] _ R0 xor 0, ZeroBr, BRANCH[$, BadTrapB],	c2;	BRANCH[$, StkSimUF],	c3;		Noop,	c1;	        [] _ R0 xor 1, ZeroBr,	c2;         BRANCH[$, StkSim2UF],	c3;		Noop,	c1;		[] _ R0 xor 2, ZeroBr,	c2;	BRANCH[$, Stk2UF],	c3;		Noop,	c1;	 	[] _ R0 xor 3, ZeroBr,	c2;	BRANCH[$, StkOF],	c3;		Noop,	c1;	 	[] _ R0 xor 4, ZeroBr,	c2;	BRANCH[$, StkOFp]	c3;		Noop,	c1;	 	[] _ R0 xor 5, ZeroBr,	c2; 	BRANCH[$, StkEReg],	c3;		Noop,	c1;	 	[] _ R0 xor 8, ZeroBr,	c2; 	BRANCH[$, IBTestc1],	c3;		Noop,	c1;	 	[] _ R0 xor 9,,ZeroBr,	c2; 	BRANCH[$, IBTestc2],	c3;		Noop,	c1;	        [] _ R0 xor 0A, ZeroBr,	c2;  	BRANCH[BadTrapA, IBEReg],c3;{Set UA5 to E2 to indicate legit trap through 0}TrapTest:	Noop,	c2;	Noop,	c3;	R0 _ 0E2,	c1;	UA5 _ R0,	c2;	Noop,	c3, at[205];{Stack Pointer overflow & underflow tests}StkUF:	R0 _ 0, stackP _ 0,	c1, at[667];	pop, GOTO[WaitTrapc3],	c2, at[0F,10];StkSimUF:	stackP _ 0, 	c1, at[633];	R0 _ 1, fXpop, push, GOTO[WaitTrapc3],	c2;StkSim2UF:	stackP _ 1,	c1, at[621];	R0 _ 2,	c2;	fXpop, fZpop, push, GOTO[WaitTrapc1],	c3;Stk2UF:	stackP _ 1, ,	c1, at[635];	R0 _ 3,	c2;	fXpop, fZpop, GOTO[WaitTrapc1],	c3;StkOF:	stackP _ StkOVF, 	c1, at[623];	R0 _ 4, push, GOTO[WaitTrapc3],	c2;StkOFp:	stackP _ StkOVF,	c1, at[637];	R0 _ 5,	c2;	push, fZpop, GOTO[WaitTrapc1],	c3;{Does Error register really say stackP error?}StkEReg:	Noop,				c1, at[625];	Xbus _ R1 LRot0, XwdDisp,	c2;	DISP2[StkEE],	c3;StkEE:	GOTO[ErrRStkp], 	c1, at[0,4,StkEE];	GOTO[ReOFpForErr],	c1, at[1,4,StkEE];	GOTO[PreIBTestc1],	{EKErr=2 on stackP err}	c1, at[2,4,StkEE];	GOTO[ErrRStkp],		c1, at[3,4,StkEE];ReOFpForErr:	Noop,		c2;	GOTO[StkOFp]	c3; {May be re-booted for telescope case}PreIBTestc1:	R0 _ 8,		c2;	Noop,		c3;{IBEmpty error NOT in c1}IBTestc1: Noop,		c1, at[671];	Noop,		c2;	IBPtr_1	c3;	        Xbus _ ib,  {IB empty now}	c1;	R0_9,				c2;	Xbus _ ib, GOTO[WaitTrapc1],	c3;{IBEmpty error in c1.  Should cancel mem write.}IBTestc2:	rhR2 _ 0,			c1, at[639];	R2 _ 0,				c2;	IBPtr _ 1,			c3;	MAR _ [rhR2, R2+0], Xbus _ ib,	c1;	MDR _ 0,			c2;	R0 _ 0A,			c3;	MAR _ [rhR2, R2+0], Xbus _ ib,	c1;	MDR _ 0FF, GOTO[FastTrapc3],	c2;{Does Error register really say IBEmpty error?}IBEReg:	Noop,	c1;	Xbus _ R1 LRot0, XwdDisp,	c2;	DISP2[IBEE],	c3;IBEE:	GOTO[ErrRibEm],	c1, at[0,4,IBEE];	GOTO[ErrRibEm],	c1, at[1,4,IBEE];	GOTO[ErrRibEm],	c1, at[2,4,IBEE];{reset Trap-test indicators}	Noop, {EKErr=3 on IBEmpty err}	c1, at[3,4,IBEE];	UA5 _ 0,	c2;	R0 _ 0E,	c3;{was mem write canceled? Loc 1 should be 0}	MAR _ [rhR2, R2+0],	c1;	Noop,	c2;	R3 _ MD,	c3;	[] _ R3, ZeroBr,	c1;	BRANCH[IBEMemW, $],	c2;	GOTO[CritTime],		c3;{Wait a click for ErrorProm to decode error}WaitTrapc2:	Noop,	c2;WaitTrapc3:	Noop,	c3;WaitTrapc1:	Noop,	c1;		Noop,	c2;FastTrapc3:	Noop,	c3;		GOTO[DidntTrap],  {trap should happen by now}	c1;{6.  Test those X bus operations which have large (>134 nS) cycle times}{[]_U or R, ZeroBr}CritTime:	U5A _ 0			,c1, at[68A];	UA5 _ ~RA xor RA	,c2;	[] _ U5A xor 0, ZeroBr	,c3;{[]_U or R, NegBr}	BRANCH[UZeroBrBad, $]	,c1;	Noop,			c2;	GOTO[UNeg],		c3;UNeg:	U5A _ 0			,c1, at[68F];	UA5 _ ~RA xor RA	,c2;	Ybus _ U5A		,c3;	[] _ UA5 xor 0, NegBr	,c1;	BRANCH[UNegBrBad, $]	,c2;	GOTO[UStkp],		c3;UStkp:	UA5 _ ~RA xor RA,	c1, at[694];	stackP _ 0		,c2;	stackP _ UA5 xor 0	,c3;{stackP _ U or R}	R0 _ ErrnIBnStkp	,c1;	R0 _ R0 and 0F	,c2;	[] _ R0, ZeroBr	,c3;	BRANCH[UstkpBad, $]	,c1;	Noop,			c2;	GOTO[URot],		c3;URot:	Noop,	c1, at[69C];	R0 _ 0F	,c2;	U5A _ R0	,c3;{R _ Rot1 U}	R1 _ LRot1 U5A	,c1;	UA5 _ R1	,c2;	R2 _ RRot1 UA5	,c3;	[] _ R2 xor 0F, ZeroBr	,c1;	BRANCH[URot1Bad, $]	,c2;	GOTO[UPage],		c3;UPage:		R0 _ 2		,c1, at[6A4];{R _ U + R, PgCarryBr, LOOPHOLE[byte]}	UA5 _ R0	,c2;	RA _ 0FE	,c3;	Xbus _ U5A	,c1;	[] _ RA + UA5, PgCarryBr, LOOPHOLE[byteTiming]	,c2;	BRANCH[UByPgCyBad, $],	c3;	MemNib:	rhR0 _ 0, 	,c1, at[62D];	R0 _ 5	,c2;	Noop,	c3;	MAR _ [rhR0, R0+0]	,c1;	MDR _ 0FD	,c2;	Noop	,c3;	MAR _ [rhR0, R0+0]	,c1;	R1 _ 4	,c2;	R2 _ MD + R1, LOOPHOLE[niblTiming]	,c3;	R2 _ R2 and 0F	,c1;	R2 _ R2 xor 1, ZeroBr	,c2;	BRANCH[MNibByBad, $]	,c3;{"Freeze" test: check U reg access and D-input to F=0 output. Loop 256 times.}Freeze:	rhR0 _ 0,		c1, at[653];	R4 _ 0,			c2;	Noop,			c3;	R0 _ 0	,c1;	RD _ 0AA	,c2;	RD _ (RD LRot8) or RD	,c3;	MAR _ [rhR0, R0+0]	,c1;	MDR _ RD   {MDR_0AAAA}	,c2;	RD _ uD0 _  ~RD  {rd_5555}	,c3;UFZeroT:	MAR _ [rhR0, R0+0], IBPtr_1	,c1;	Noop	,c2;	IB _ MD  {MD=0AAAA}	,c3;	Ybus _ RD xor uD0, NZeroBr	,c1;	R4 _ R4 + 1, PgCarryBr, BRANCH[$, UFZeroBad]	,c2;	BRANCH[UFZeroT, $]	,c3;{R _ RH + R, PgCarryBr, LOOPHOLE[Byte]}rhPage:	rhR0 _ 0FC		,c1, at[62F];	R0 _ 5			,c2;	Xbus _ rhRF		,c3;	R0 _ rhR0 + R0, PgCarryBr, LOOPHOLE[byteTiming]	,c1;	R0 _ R0 and 0FF, BRANCH[RHByPgBad, $]	,c2;	[] _ R0 xor 1, ZeroBr	,c3;{[] _ R + Byte, CarryBr}	BRANCH[RHByArBad, $]	,c1;ByCarry:	R0 _ R0 xor ~R0	,c2;	R1 _ R0 + 0F, CarryBr	,c3;	BRANCH[ByCyBrBad, $]	,c1;	GOTO[NOERROR1]	,c2;{Bad breakpoints}{trap test which failed is in R0.  If R0 is not in [0..x] & UA5 does not equal 0E2, control reached Loc 0 not during the trap test.}BadTrapA:	RE _0, GOTO[BadTrapA],	c*;BadTrapB:	RE _0, CANCELBR[BadTrapB1],	c*;BadTrapB1:	RE _0, GOTO[BadTrapB1],	c*;DidntTrap:	RE _0, GOTO[DidntTrap],	c*;ErrRStkp:	RE _0, GOTO[ErrRStkp],	c*;ErrRVirt:	RE _0, GOTO[ErrRVirt],	c*;ErrRMem:	RE _0, GOTO[ErrRMem],	c*;ErrRibEm:	RE _0, GOTO[ErrRibEm],	c*;IBEMemW:	RE _0, GOTO[IBEMemW],	c*;CSPar:   	RE _0, GOTO[CSPar],	c*;{Bad Timing Test Breaks}UZeroBrBad:	RE _0, GOTO[UZeroBrBad]	,c*;UNegBrBad:	RE _0, GOTO[UNegBrBad]	,c*;UstkpBad:	RE _0, GOTO[UstkpBad]	,c*;URot1Bad:	RE _0, GOTO[URot1Bad]	,c*;UByPgCyBad:	RE _0, GOTO[UByPgCyBad]	,c*;MNibByBad:	RE _0, GOTO[MNibByBad]	,c*;RHByPgBad:	RE _0, GOTO[RHByPgBad]	,c*;RHByArBad:	RE _0, GOTO[RHByArBad]	,c*;ByCyBrBad:	RE _0, GOTO[ByCyBrBad]	,c*;UFZeroBad:	RE _0, CANCELBR[UFZeroBad1]	,c*;UFZeroBad1:	RE _0, GOTO[UFZeroBad1]	,c*;NOERROR1:	RE _0, GOTO[NOERROR],	                           	c*;NOERROR:	ClrMPIntIOP,GOTO[NOERROR],         	c*, at[0FF5];LoaderCheck:	ClrMPIntIOP,GOTO[LoaderCheck],c*, at[0FFF];
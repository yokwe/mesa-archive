{Test 8254 timer/counter chip on MPB.  Assumes other logic is functional}Reserve[0001,001E];{ For moonBus}Reserve[0020,002E];{ For moonBus}Reserve[0030,003E];{ For moonBus}Reserve[0040,005F];{ For moonBus}Reserve[0060,00FF];{ moonsun1}Reserve[0110,0180];{ moonsun1}Reserve[0181,01FF];{ moonsun2}Reserve[0210,03CF];{ moonsun2}Reserve[03D0,03FF];{ moonsun3}Reserve[0401,04D2];{ moonsun3}Reserve[04D4,04FF];{ moonsun3}Reserve[0400];	   { moonsun4}Reserve[0500,05FF];{ moonsun4}Reserve[0600,060F];{ moonsun4}Reserve[0700,070F];{ moonsun4}Reserve[0800,08D2];{ moonsun4}Reserve[08D4,08FF];{ moonsun4}Reserve[0610,06D2];{ moonsun5}Reserve[06D4,06FF];{ moonsun5}{Reserve[04D3];	{moontime }Reserve[06D3];	{moontime }Reserve[0710,07FF];{ moontime}Reserve[0AD3,0AD4];{ moontime}}Reserve[0900,09FF];{ MoonMr}Reserve[0A00,0AD2];{ For OTHER TEST}Reserve[0AD5,0FEF];{ For OTHER TEST}Reserve[0100,0105];{ For OTHER TEST}Reserve[0107,010F];{ For OTHER TEST}Reserve[0200,0205];{ For OTHER TEST}Reserve[0207,020F];{ For OTHER TEST}Reserve[0FF0,0FF5];{ For OTHER TEST}Reserve[0FF7,0FFE];{ For OTHER TEST}RegDef[TimerAddr,RH,1];RegDef[TCR,RH,2];RegDef[TCRAddr,RH,2];RegDef[CntrSel,R,7];RegDef[InCount,R,9];RegDef[TimeSet,R,0B];RegDef[TimeCnt,R,0C];RegDef[PreSet,R,0D];SetTask[0]; StartAddress[TERROR1];TERROR1:R1 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[0];        R6 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[1F];        R8 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[3F];        R1 _ R1 or R6,ClrIE,	c*, at[2F];        R1 _ R1 or R8,	c*, at[106];	        Xbus _ R1 LRot0, XwdDisp,	c*;	DISP2[TrapType],	c*;TrapType:GOTO[Trap],	c*, at[0,4,TrapType];	SetIE,GOTO[START],c*, at[1,4,TrapType];	GOTO[Trap],	c*, at[2,4,TrapType];	GOTO[Trap],	c*, at[3,4,TrapType];Trap:	  GOTO[Trap],   c*;START:	XC2npcDisp, c2;	BRANCH[BadCy, GoodCy, 0D],	c3;BadCy:	Noop,	c*, at[0D,10,GoodCy];	Noop,	c*;	GOTO[START]	c*;	GoodCy:	Noop ,	c1, at[0F,10,BadCy];	Noop,	c2;	GOTO[Go],	c3, at[206];{In the following tests, timer 0 is initialized to mode 2 and checked for R/W.}Go:	ClrIntErr, L0 _ 0, {First return code value}		c1, at[73B];	TCRAddr _ 43, {Timer Control Register Address, keep for further use} 		GOTO[ClearGatesC3],				c2;	{Set TimerAddr to address Timer 0}	TimerAddr _ 40,				c1, at[0,10,ClearGatesRet];	RA _ 2, {Delay count to be used after writing to Timer 0}		{(2 - 1)*15750ns + 375ns = 16.125us.  Delay}		{enough for Timer1Clk to set count into Timer 0 } c2;	R0 _ 0, {first data - all zeros}			c3;	CntrSel _ 34, {Select Counter 0, Mode 2}		c1;	Noop,							c2;   		R1 _ R0, GOTO[SetTimer],				c3;	Noop,					c1, at[0,10,SetTimerRet];	Noop,							c2;	GOTO[Delay],						c3;	RA _ 2, {Restore 16us delay count}	c1, at[0,10,DelayRet];	Noop,							c2;	GOTO[ReadTimer],					c3;{ Check any bits stuck at 1 }	R3 _ R3 + 0, ZeroBr,			c1, at[0,10,ReadTimerRet];	BRANCH[T0ZeroBad, $],				c2;	GOTO[T0ZeroGood],					c3;T0ZeroGood:	CntrSel _ 34,						c1, at[75A];	TCRAddr _ 43,						c2;	TimerAddr _ 40,						c3;		R0 _ 0FF,  {Prepare to test all 1's}			c1;	R1 _ 0FF, L0 _ 1,					c2;	GOTO[SetTimer],						c3;	Noop,					c1, at[1,10,SetTimerRet];	Noop,							c2;	GOTO[Delay],						c3;		RA _ 2, {Restore 16us delay count}	c1, at[1,10,DelayRet];	Noop,							c2;	GOTO[ReadTimer],					c3;	Noop,					c1, at[1,10,ReadTimerRet];	R4 _ ~R3, ZeroBr,					c2;	BRANCH[T0OnesBad, T0OnesGood],				c3;	{ real time clock test of all three timers.  Count Timer 0 from F000 to 0FFF or 0FFE, Timer 1 from 8000 to 0001 to 8000 to 1FFF or 1FFE, Timer2 from 0080 to 007F}T0OnesGood:{ Timer 0 initialize count to F000 }	R0 _ 00,						c1, at[72D];	R1 _ 0F0, L0 _ 2,					c2;	TCRAddr _ 43,						c3;	CntrSel _ 34,						c1;	TimerAddr _ 40,						c2;	GOTO[SetTimer],						c3;{ Timer 1 initialize count to 8000 }	TimerAddr _ 41,				c1,at[2,10,SetTimerRet];	R1 _ 80, L0 _ 3,					c2;	CntrSel _ 74, {Counter 1,,RW both bytes,,mode2}		c3;	Noop,							c1;	Noop,							c2;	GOTO[SetTimer],						c3;{ Timer 2 initialize count to 0080 }	CntrSel _ 0B4, { counter 2, mode 2 }	c1, at[3,10,SetTimerRet];	TimerAddr _ 42,						c2;	Noop,							c3;	R0 _ 80, L0 _ 4,					c1;	R1 _ 0,							c2;	GOTO[SetTimer],						c3;	R6 _ 0FF, {used later}			c1, at[4,10,SetTimerRet];	rhR0 _ 4C, {Address/command to set T0 Gate, used after delay} c2;	RA _ 2,GOTO[Delay], {Wait for values to be set in counters}	c3;		R9 _ 0E3, {F000-0FFF=E001}		c1, at[4,10,DelayRet];		  {E001hex*16us=E390hex*15.75us(Delay routine constant)}		  {to E390 add 1 count for initial delay routine subtraction}		  {to E391 add 1 count for asynch between program and clock}	R9 _ R9 LRot8,						c2;	RA _ 092,						c3;	RA _ R9 or RA, {Preset long delay count}		c1;	Noop,							c2;	Noop,							c3;{ enable T0 gate to release clock }	IO _ [rhR0, R0 + 0],					c1;	MDR _ 0,						c2;	rhR0 _ 54, {Address/command to set T1-T2 Gate}		c3;{ enable T1-2 gate to release clock }	IO _ [rhR0, R0 + 0], L0 _ 3 {again}			c1;	MDR _ 0, 						c2;	GOTO[Delay], {RA was preset to E392}			c3;{ latch the counts for all three timers (gates still enabled)}	IO _ [TCRAddr, R0 + 0],			c1, at[3,10,DelayRet];	MDR _ 0DE, {Read Back Command, counts only, all three counters}	c2;{ read the counts and compare to expected }{ read timer zero }	TimerAddr _ 40,	GOTO[ReadTimer],				c3;	R5 _ 00F,				c1, at[3,10,ReadTimerRet];	R5 _ R5 LRot8,						c2;	R6 _ R5 or R6, L0 _ 2, {0FFF (or 0FFE)}			c3;	R6 _ R3 xor R6, ZeroBr,					c1;	R6 _ R6 - 1, ZeroBr, BRANCH[$, T0OK],			c2;	BRANCH[T0Bad, T0Gd],					c3;{ read timer one }T0OK:	CANCELBR[T0Gd, 1],					c3;T0Gd:	TimerAddr _ 41,						c1;	R5 _ 1F,						c2;	R6 _ 0FF, GOTO[ReadTimer],				c3;	R5 _ R5 LRot8,				c1, at[2,10,ReadTimerRet];	R6 _ R5 or R6, L0 _ 4, {0FFF or 1F00 = 1FFF}		c2;	R6 _ R3 xor R6, ZeroBr,					c3;	R6 _ R6 - 1, ZeroBr, BRANCH[$, T1OK]			c1;	BRANCH[T1Bad, T1Gd],					c2;{ read timer two }T1OK:	CANCELBR[T1Gd, 1],						c2;T1Gd:	TimerAddr _ 42, GOTO[ReadTimer],			c3;	R4 _ 7F,				c1, at[4,10,ReadTimerRet];	R9 _ 10, {used below}					c2;	R4 _ R3 xor R4,	ZeroBr,					c3;	BRANCH[T2Bad, T2Good],					c1;T2Good:	SetIE, {Enable interrupts, expecting one from Timer 0}	c2;	Noop,							c3;{If everything has gone OK so far we have executed about 45 micros since the long delay (or about 5.625 us).  We should get an interrupt in about another 65,498 us. We will delay 4158*15.75us = 103Ehex*15.75us = 65,488us which should leave enough time to check no timer interrupt has occurred.  We will wait 3 more Delay units and check that this time the interrupt is there.}  	R9 _ R9 LRot8, L0 _ 2,					c1;	RA _ 3E,						c2;	RA _ R9 or RA, GOTO[Delay],			c3;	Noop,					c1, at[2,10,DelayRet];	IBPtr _ 1, {set IB to byte}				c2;	Ybus _ ib,						c3;	Noop,							c1;	IBDisp, { Trap to see no timer interrupt yet} 		c2;	GOTO[OpTable],					c3;{ Return here if trap and no interrupt }Good1:	TCRAddr _ 0, {leave state for interrupt routine to see everything is OK 			so far}					c1;	RA _ 4, L0 _ 5,					c2;	GOTO[Delay], {Delay 3 units}			c3;	Noop,					c1, at[5,10,DelayRet];	IBPtr _ 1, {Reprime for IBDisp}				c2;	Ybus _ ib,						c3;	Noop,							c1;	IBDisp, { Trap to see timer interrupt there now} 	c2;	GOTO[OpTable],					c3;{Non error interrupt processing }NoInt:	Noop,						c1, at[4D3];	Ybus _ TCRAddr, NZeroBr,				c2;	BRANCH[IntTrapErr, Good1],				c3;Int:	R1 _ IntStat,					c1, at[6D3];	R1 _ R1 and 07,						c2;	Xbus _ R1 LRot0,XDisp,					c3;	DISP4[IntType],						c1;	GOTO[IntErr],					c2, at[0,10,IntType];Process:	GOTO[NotIntErr],				c2, at[1,10,IntType];IOP:	GOTO[BadInt],					c2, at[2,10,IntType];	GOTO[IntErr],					c2, at[3,10,IntType];MInt:	GOTO[BadInt],					c2, at[4,10,IntType];	GOTO[IntErr],					c2, at[5,10,IntType];	GOTO[IntErr],					c2, at[6,10,IntType];	GOTO[IntErr],					c2, at[7,10,IntType];	GOTO[IntErr],					c2, at[8,10,IntType];	GOTO[IntErr],					c2, at[9,10,IntType];	GOTO[IntErr],					c2, at[0A,10,IntType];	GOTO[IntErr],					c2, at[0B,10,IntType];	GOTO[IntErr],					c2, at[0C,10,IntType];	GOTO[IntErr],					c2, at[0D,10,IntType];	GOTO[IntErr],					c2, at[0E,10,IntType];	GOTO[IntErr],					c2, at[0F,10,IntType];NotIntErr:	ClrIE,							c3;	L0 _ 1,							c1;	GOTO[ClearGatesC3],					c2;{Check that TCRAddr was cleared before this interrupt}	Ybus _ TCRAddr,	ZeroBr,			c1, at[1,10,ClearGatesRet];	BRANCH[IntErr,NOERROR1],					c2;{Routine to delay ((RA - 1)*15750ns) + 375ns for RA <> 1}DelayMore:	CANCELBR[Innerloop, 0F], InCount _ 29, {29hex=41,41*375=15375}	c3;Innerloop:	InCount _ InCount - 1, ZeroBr,			c1;	BRANCH[$, DelayN],				c2;	GOTO[Innerloop],				c3;	DelayN:	Noop,						c3;Delay:	RA _ RA - 1, ZeroBr,				c1;	L0Disp, BRANCH[DelayMore, DelayDone],		c2;DelayDone:	DISP4[DelayRet],				c3;{Routine to set the timer addressed by TimerAddr to the values in R0 (LSB) and R1 (MSB)}SetTimer:	IO _ [TCRAddr, R0 + 0], {address Control Register}	c1;	MDR _ CntrSel,{Control Register data - Counter number,,Read/Write 		   control,,mode}			c2;	Noop,						c3;	IO _ [TimerAddr, R0 + 0],			c1;	MDR _ R0,					c2;	Noop,						c3;	IO _ [TimerAddr, R0 + 0]			c1;	MDR _ R1, L0Disp,				c2;	DISP4[SetTimerRet],				c3;{Routine to read timer addressed by TimerAddr into R3 }ReadTimer:	IO _ [TimerAddr, R0 + 0],			c1;	Noop,						c2;	R3 _ MD, {LSByte}				c3;	IO _ [TimerAddr, R0 + 0],			c1;	R3 _ R3 and 0FF, {mask off upper garbage byte}, c2;	R4 _ MD,					c3;	R4 _ R4 and 0FF,LRot8,					c1;	R4 _ R4 LRot8, L0Disp,			c2;	R3 _ R4 or R3, DISP4[ReadTimerRet]	c3;{Routine to disable T0 and T1-T2 Gates}ClearGatesC3:	rhR0 _ 48, {Clear T0 Gate address/command}		c3;	IO _ [rhR0, R0 + 0],					c1;	MDR _ 0,	{ clear T0 Gate }			c2;	rhR0 _ 50, {Clear T1-T2 Gates address/command}		c3;	IO _ [rhR0, R0 + 0],					c1;	MDR _ 0, L0Disp, { clear T1-T2 Gates }			c2;	DISP2[ClearGatesRet],					c3;{Every IBDisp should cause a trap, so the OpTable should never be reached.  The following two "ops" could catch trap failures}OpTable:	GOTO[OpTable],			c*, at[0AD3];OpTable1:	GOTO[OpTable1],			c*, at[0AD4];{Bad breakpoints}T0ZeroBad:	GOTO[T0ZeroBad],			c*;T0OnesBad:	GOTO[T0OnesBad],			c*;T0Bad:		GOTO[T0Bad],				c*;T1Bad:		GOTO[T1Bad],				c*;T2Bad:		GOTO[T2Bad],				c*;IntTrapErr:	GOTO[IntTrapErr],			c*;IntErr:		GOTO[IntErr],				c*;BadInt:		GOTO[BadInt],				c*;NOERROR1:	GOTO[NOERROR],      c*;NOERROR:	ClrMPIntIOP,GOTO[NOERROR],      c*, at[0FF6];LoaderCheck:	ClrMPIntIOP,GOTO[LoaderCheck],c*, at[0FFF];{END}
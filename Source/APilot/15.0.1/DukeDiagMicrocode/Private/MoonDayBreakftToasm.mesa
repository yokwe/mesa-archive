-- MoonDayBreakftToasm.mesa-- Edited by:-- Neshati     28-Jun-84 14:10:04DIRECTORY  Ascii USING [CR, SP],  Exec USING [AddCommand,ExecProc,EndOfCommandLine,GetTTY,GetChar, Handle, OutputProc, ReleaseTTY],  Format USING [StringProc],  Heap USING [Create, Delete],  MStream USING [Error, EndOf, Handle, ReadOnly, ReadWrite, WriteOnly],  Stream USING [Delete, EndOfStream, GetChar, PutChar, SetPosition],  String USING [AppendChar, AppendNumber, AppendString, CopyToNewString, EquivalentString, MakeString, StringBoundsFault, UpperCase],  TTY USING [Handle, PutLine, PutString];MoonDayBreakftToasm: PROGRAM    IMPORTS Exec, Heap, MStream, Stream, String, TTY =  BEGIN-- File handles    inFileHandle: MStream.Handle _ NIL; -- input file handle    outFileHandle: MStream.Handle _ NIL; -- output file handle    tempFileHandle: MStream.Handle _ NIL; -- temporary file handle    ioToggle: BOOLEAN _ TRUE; -- get input from input file/temporary file-- Get data from either inputfile or tempfile based on ioToggleGetData: PROCEDURE RETURNS [ch: CHARACTER] =  BEGIN    RETURN [ch _ Stream.GetChar [IF ioToggle THEN inFileHandle ELSE tempFileHandle]]  END; -- GetData-- Put data to either outputfile or tempfile based on ioTogglePutData: PROCEDURE [ch: CHARACTER] =  BEGIN    Stream.PutChar [IF ioToggle THEN tempFileHandle ELSE outFileHandle, ch]  END; -- PutData-- Put string to a filePutString: PROCEDURE [str: LONG STRING] =   BEGIN    FOR i: CARDINAL IN [0..str.length) DO PutData [str [i]] ENDLOOP  END; -- PutString-- Convert string to upper caseUpperString: PROCEDURE [s: LONG STRING] =  BEGIN    FOR i: CARDINAL IN [0..s.length) DO s [i] _ String.UpperCase [s [i]] ENDLOOP  END; -- UpperString-- Skip data upto CRSkipToCR: PROCEDURE =   BEGIN    DO       IF GetData [! Stream.EndOfStream => GOTO done] = Ascii.CR THEN RETURN;      REPEAT      done => NULL     ENDLOOP  END; -- SkipToCR  -- Skip data upto SPSkipToSP: PROCEDURE =   BEGIN    DO      IF GetData [! Stream.EndOfStream => GOTO done] = Ascii.SP THEN RETURN;      REPEAT      done => NULL     ENDLOOP  END; -- SkipToSP  -- Copy data upto SP and append '0 to the byte as MSBCopyUptoSP: PROCEDURE =  BEGIN    Numeric: TYPE = CHARACTER ['0..'9];    Hex: TYPE = CHARACTER ['A..'F];    ch: CHARACTER;    doAppend: BOOLEAN _ TRUE;    DO      ch _ GetData [! Stream.EndOfStream => GOTO done];      IF ch = Ascii.SP         THEN RETURN        ELSE BEGIN          IF doAppend AND (ch IN Hex OR ch IN Numeric) THEN PutData ['0];          doAppend _ FALSE        END;      PutData [ch];      REPEAT      done => NULL    ENDLOOP  END; -- CopyUptoSP-- Get data upto (but not including) SP and place them in a temporary stringGetUptoSP: PROCEDURE [tStr: LONG STRING] =  BEGIN    ch: CHARACTER;    tStr.length _ 0;    DO      ch _ GetData [! Stream.EndOfStream => GOTO done];      IF ch = Ascii.SP THEN EXIT;      String.AppendChar [tStr, ch !String.StringBoundsFault => RETRY];      REPEAT      done => NULL    ENDLOOP  END; -- GetUptoSP-- Read the input file and process dataInputFile: PROCEDURE [tempString: LONG STRING,                      dwString: LONG STRING, 		      ffffString: LONG STRING, 		      hString: LONG STRING,		      hCRString: LONG STRING] RETURNS [lines: CARDINAL] =  BEGIN    maxLines: CARDINAL _ 4096; -- maximum lines in input file    doneFFFF: BOOLEAN _ FALSE;    lines _ 0;  -- Discard first 2 lines of input file    Stream.SetPosition [tempFileHandle, 0];    SkipToCR [];    SkipToCR [];-- Read through input file line by line    WHILE (NOT MStream.EndOf [inFileHandle]) AND (NOT lines = maxLines) DO      GetUptoSP [tempString];      PutString [dwString]; -- write ' DW '      -- Look for 'FFFF' and discard first four digits if not 'FFFF'      IF String.EquivalentString [ffffString, tempString] AND NOT doneFFFF        THEN doneFFFF _ TRUE	ELSE BEGIN          THROUGH [0..3) DO             CopyUptoSP []; -- write 3 words 	    PutString [hString]  -- write '0xxxxH,'          ENDLOOP;	  lines _ lines + 1	END;      CopyUptoSP []; -- write last word      PutString [hCRString]; -- write '0xxxxH<CR>'      SkipToCR [] -- skip rest of input line    ENDLOOP;    RETURN [lines]  END; -- InputFile-- Write the processed data to the output fileOutputFile: PROCEDURE [dwString: LONG STRING,                       countString: LONG STRING,		       lines: CARDINAL] =  BEGIN    ch: CHARACTER;    byteCount: CARDINAL;    PutString [dwString];-- Write byte count    byteCount _ ((lines * 4) + 2) * 2;    {      ENABLE String.StringBoundsFault => RETRY;      String.AppendNumber [countString, byteCount, 10];      String.AppendChar [countString, Ascii.CR]    };    PutString [countString];    Stream.SetPosition [tempFileHandle, 0];    -- Copy data from temprary file into output file    WHILE (NOT MStream.EndOf [tempFileHandle]) DO      PutData [ch _ GetData [! Stream.EndOfStream => GOTO done]];      REPEAT      done => NULL    ENDLOOP  END; -- OutputFile-- Main gets called whenever executive command is issuedMain: Exec.ExecProc =  BEGIN    ch: CHARACTER;    lineCount: CARDINAL _ 0; -- current line in input file    ttyHandle: TTY.Handle _ Exec.GetTTY [h]; -- used for TTY interface    z: UNCOUNTED ZONE _ Heap.Create [initial: 1]; -- private heap           -- Make strings    tempStr: LONG STRING _ String.MakeString [z, 6]; -- used to search for FFFF    ffffStr: LONG STRING _ String.MakeString [z, 4]; -- see next paragraph    dwStr: LONG STRING _ String.MakeString [z, 4]; -- see next paragraph    hStr: LONG STRING _ String.MakeString [z, 3]; -- see next paragraph    hCRStr: LONG STRING _ String.MakeString [z, 2]; -- see next paragraph    countStr: LONG STRING _ String.MakeString [z, 5]; -- holds byte count    fileName: LONG STRING _ String.MakeString [z, 40];    inFileName: LONG STRING _ String.MakeString [z, 40];    outFileName: LONG STRING _ String.MakeString [z, 40];    tempFileName: LONG STRING _ String.MakeString [z, 40];    fileHeader: LONG STRING _ String.MakeString [z, 161];    fileTrailer: LONG STRING _ String.MakeString [z, 22];       BEGIN-- Constant string values    {      ENABLE String.StringBoundsFault => RETRY;      String.AppendString [ffffStr, "FFFF"];      String.AppendString [dwStr, " DW "];      String.AppendString [hStr, "H, "];      String.AppendString [hCRStr, "H\n"];      String.AppendString [fileTrailer, "MonitorCode ENDS\n END\n"]    };-- Loop ends only when user enters <CR>-- Initialize strings      tempStr.length _ 0;      countStr.length _ 0;      fileName.length _ 0;      inFileName.length _ 0;      outFileName.length _ 0;      tempFileName.length _ 0;      fileHeader.length _ 0;-- Get file name      UNTIL Exec.EndOfCommandLine[h] OR fileName.length = fileName.maxlength DO      ch _ Exec.GetChar[h];      IF ch # Ascii.SP AND ch # Ascii.CR THEN String.AppendChar[fileName, ch];      ENDLOOP;      TTY.PutLine [ttyHandle, tempStr]; -- write blank line      inFileName _ String.CopyToNewString [fileName, z, 3];      outFileName _ String.CopyToNewString [fileName, z, 4];      tempFileName _ String.CopyToNewString [fileName, z, 5]; -- Append ".ft" to input file, ".asm" to output file and ".asm$" to temporary file      {        ENABLE String.StringBoundsFault => RETRY;	String.AppendString [inFileName, ".ft"];	TTY.PutLine [ttyHandle,inFileName]; -- write blank line        String.AppendString [outFileName, ".asm"];        String.AppendString [tempFileName, ".asm$"]      };-- If invalid input file name then exit else get input file handle      inFileHandle _ MStream.ReadOnly [inFileName, []         ! MStream.Error => SELECT code FROM          invalidOperation => { TTY.PutLine [ttyHandle, "*** invalid operation ***"]; GOTO abort };          fileTooLong => { TTY.PutLine [ttyHandle, "*** file too long ***"]; GOTO abort };          fileNotAvailable => { TTY.PutLine [ttyHandle, "*** file not available ***"]; GOTO abort }          ENDCASE => { TTY.PutLine [ttyHandle, "*** file error ***"]; GOTO exit }];    -- If duplicate output file name then rewrite else get output file handle          outFileHandle _ MStream.WriteOnly [outFileName, [], text        ! MStream.Error => SELECT code FROM          invalidOperation => { TTY.PutLine [ttyHandle, "*** invalid operation ***"]; GOTO abort };          fileTooLong => { TTY.PutLine [ttyHandle, "*** file too long ***"]; GOTO abort};          fileNotAvailable => { TTY.PutLine [ttyHandle, "*** file not available ***"]; GOTO abort }          ENDCASE => {TTY.PutLine [ttyHandle, "*** file error ***"]; GOTO exit }];-- Open temporary file with no extension and use it for intermediate storage          tempFileHandle _ MStream.ReadWrite [tempFileName, [], text        ! MStream.Error => SELECT code FROM       invalidOperation =>{ TTY.PutLine [ttyHandle, "*** invalid operation ***"]; GOTO abort};          fileTooLong => { TTY.PutLine [ttyHandle, "*** file too long ***"];GOTO abort };          fileNotAvailable => { TTY.PutLine [ttyHandle, "*** file not available ***"]; GOTO abort }          ENDCASE => {TTY.PutLine [ttyHandle, "*** file error ***"]; GOTO exit }];-- Process input file      ioToggle _ TRUE;      TTY.PutString [ttyHandle, "reading input (.ft) file ... "];      lineCount _ InputFile [tempStr, dwStr, ffffStr, hStr, hCRStr];      TTY.PutLine [ttyHandle, "done"];-- Setup header and trailer for output file      UpperString [fileName];      {        ENABLE String.StringBoundsFault => RETRY;        String.AppendString [fileHeader, "NAME "];        String.AppendString [fileHeader, fileName];        String.AppendString [fileHeader, "\n$NOLIST\n$INCLUDE(MOONLINK.def)\n$LIST\nMonitorCode SEGMENT COMMON\n ORG Ext"];        String.AppendString [fileHeader, fileName];        String.AppendChar [fileHeader, Ascii.CR]      };    -- Process output file      ioToggle _ FALSE;      TTY.PutString [ttyHandle, "writing output (.asm) file ... "];      PutString [fileHeader]; -- write file header to output file      OutputFile [dwStr, countStr, lineCount];      PutString [fileTrailer]; -- write file trailer to output file      TTY.PutLine [ttyHandle, "done"];  -- Delete file handles              Stream.Delete [inFileHandle];      Stream.Delete [outFileHandle];      Stream.Delete [tempFileHandle];         EXITS	      abort => NULL;      exit => NULL;    END;                  Exec.ReleaseTTY [ttyHandle]; -- release tty handle -- Delete private heap and free strings      Heap.Delete [z];      z _ NIL;             END; -- Main-- Display help when user requests it from the executiveHelp: Exec.ExecProc =  BEGIN    DisplayHelp: Format.StringProc _ Exec.OutputProc [h];    DisplayHelp ["This is a program that converts assembler source files (extension .ft)"L];    DisplayHelp ["into assembler source files (extension .asm) for DayBreak"L];    DisplayHelp ["The only argument this command takes is the name of file to be converted"L];    DisplayHelp ["Extension .ft is assumed for the input file and extension .asm will be"L];    DisplayHelp ["appended for the output file.  Both files will have the same name."L];    DisplayHelp ["To run this program, simply type 'MoonDayBreakftToasm.~ FileName' in the executive"L]  END; -- Help-- Register "MoonDayBreakftToasm" with the excutive and execute MainInit: PROCEDURE = { Exec.AddCommand ["MoonDayBreakftToasm.~"L, Main, Help] }; -- Init-- Mainline code    Init [];      END..
{File name:  <Workstation>mc>Sunlight-O.mc}Reserve[0001,001E];{ For moonBus}Reserve[0020,002E];{ For moonBus}Reserve[0030,003E];{ For moonBus}Reserve[0040,005F];{ For moonBus}Reserve[0060,00FF];{ moonsun1}Reserve[0110,0180];{ moonsun1}{Reserve[0181,01FF];{ moonsun2}Reserve[0210,03CF];{ moonsun2}}Reserve[03D0,03FF];{ moonsun3}Reserve[0401,04D2];{ moonsun3}Reserve[04D4,04FF];{ moonsun3}Reserve[0400];	   { moonsun4}Reserve[0500,05FF];{ moonsun4}Reserve[0600,060F];{ moonsun4}Reserve[0700,070F];{ moonsun4}Reserve[0800,08D2];{ moonsun4}Reserve[08D4,08FF];{ moonsun4}Reserve[0610,06D2];{ moonsun5}Reserve[06D4,06FF];{ moonsun5}Reserve[04D3];	{moontime }Reserve[06D3];	{moontime }Reserve[0710,07FF];{ moontime}Reserve[0AD3,0AD4];{ moontime}Reserve[0900,09FF];{ MoonMr}Reserve[0A00,0AD2];{ For OTHER TEST}Reserve[0AD5,0FEF];{ For OTHER TEST}Reserve[0100,0101];{ For OTHER TEST}Reserve[0103,010F];{ For OTHER TEST}Reserve[0200,0201];{ For OTHER TEST}Reserve[0203,020F];{ For OTHER TEST}Reserve[0FF0,0FF1];{ For OTHER TEST}Reserve[0FF3,0FFE];{ For OTHER TEST}SetTask[0]; StartAddress[TERROR1];TERROR1:R1 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[0];        R6 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[1F];        R8 _ RRot1 ErrnIBnStkp, ClrIntErr,CANCELBR[$,0F],   c*, at[3F];        R1 _ R1 or R6,ClrIE,	c*, at[2F];        R1 _ R1 or R8,	c*, at[102];	        Xbus _ R1 LRot0, XwdDisp,	c*;	DISP2[TrapType],	c*;TrapType:GOTO[Trap],	c*, at[0,4,TrapType];	SetIE,GOTO[START],	c*, at[1,4,TrapType];	GOTO[Trap],	c*, at[2,4,TrapType];	GOTO[Trap],	c*, at[3,4,TrapType];Trap:	  GOTO[Trap],   c*;START:	XC2npcDisp, c2;	BRANCH[BadCy, GoodCy, 0D],	c3;BadCy:	Noop,	c*, at[0D,10,GoodCy];	Noop,	c*;	GOTO[START]	c*;	GoodCy:	Noop ,	c1, at[0F,10,BadCy];	Noop,	c2;	GOTO[Go],	c3, at[202];{1.  LRotn test & bus tests.}{These tests check for stuck at faults on either the X or Y bus; the A bypass or F bus; or the LRotn cycler.  A fault on either the X,Y, F or A bus will be caught by LRot0Bad0 or LRot0Bad1.}{Is LRot0 stuck 0?}Go:	R0 _ 0,					c1, at[272];        R0 _ ~R0, {Fbus_ 1's}			c2;		{R0 _ ~R0 already checked in moonsun1}        R1 _ R0 LRot0, {Ybus_Apass_ 1's, Xbus_ Rot 1's} c3;	R0 _ R1 xor R0, ZeroBr, {Fbus_ 0's} 	c1;	BRANCH[LRot0Bad1, $],			c2;	Noop,					c3;{Is LRot0 stuck 1?}TLRot0notOnes:	R0 _ 0,					c1, at[27C];	R1 _ R0 LRot0, {Ybus_Apass_ 0's, Xbus_ Rot 0's} c2;	R0 _ R1 or R0, {should _ 0's} ZeroBr,	c3;	BRANCH[LRot0Bad0, $],			c1;	Noop,					c2;	Noop,					c3;{Is RRot1 stuck 0?}TRRot1notZeros:	R0 _ 0,					c1, at[284];	R0 _ ~R0, {1's}				c2;	R1 _ R0 RRot1,  {should _ 1's}		c3;	R0 _ R1 xor R0, {_ 0's} ZeroBr,		c1;	BRANCH[RRot0Bad1, $],			c2;	Noop,					c3;{Is RRot1 stuck 1?}TRRot1notOnes:	R0 _ 0,					c1, at[28A];	R1 _ R0 RRot1,  {should _ 0's}		c2;	R0 _ R1 or R0, ZeroBr,			c3;	BRANCH[RRot0Bad0, $],			c1;	Noop,					c2;	Noop,					c3;{Is cycleY ok?}TcycYok:	R0 _ 0,					c1, at[293];	R0 _ ~R0, {1's}				c2;	R1 _ R0 LRot1, pCall1,			c3;	[] _ R0 xor R1, ZeroBr,			c1;	BRANCH[LRot0YBad, $],			c2;	Noop,					c3;{Is LRot4 stuck 0?}TLRot4notZeros:	R0 _ 0,					c1, at[297];        R0 _ ~R0,				c2;        R1 _ R0 LRot4,				c3;	R0 _ R1 xor R0, ZeroBr,		 	c1;	BRANCH[LRot4Bad1, $],			c2;	Noop,					c3;{Is LRot4 stuck 1?}TLRot4notOnes:	R0 _ 0,					c1, at[29C];	R1 _ R0 LRot4,				c2;	R0 _ R1 or R0, {should _ 0's} ZeroBr,	c3;	BRANCH[LRot4Bad0, $],			c1;	Noop,					c2;	Noop,					c3;{Is LRot8 stuck 0?}TLRot8notZeros:	R0 _ 0,					c1, at[2A1];        R0 _ ~R0,				c2;        R1 _ R0 LRot8,				c3;	R0 _ R1 xor R0, ZeroBr,		 	c1;	BRANCH[LRot8Bad1, $],			c2;	Noop,					c3;{Is LRot8 stuck 1?}LRot8notOnes:	R0 _ 0,					c1, at[2A6];	R1 _ R0 LRot8,				c2;	R0 _ R1 or R0, {should _ 0's} ZeroBr,	c3;	BRANCH[LRot8Bad0, $],			c1;	Noop,					c2;	Noop,					c3;	{Is LRot12 stuck 0?}LRot12ntZeros:	R0 _ 0,					c1, at[2AB];        R0 _ ~R0,				c2;        R1 _ R0 LRot12,				c3;	R0 _ R1 xor R0, ZeroBr,		 	c1;	BRANCH[LRot12Bad1, $],			c2;	Noop,					c3;	{Is LRot12 stuck 1?}LRot12ntOnes:	R0 _ 0,					c1, at[2B0];	R1 _ R0 LRot12,				c2;	R0 _ R1 or R0, {should _ 0's} ZeroBr,	c3;	BRANCH[LRot12Bad0, $],			c1;	Noop,					c2;	Noop,					c3;{2a.  constant on X bus.}{Check whether Nibble and byte can place all their bits onto the X bus.}{Check that 0 thru F can be placed onto X bus.  This primarily tests the S241 which places a Nibble onto Xbus.  Instruction at NibTable actually tests internal zero.}NibTest:	Noop,		c1, at[2B5];	R0 _ 0, YDisp,	c2;NibGood:	R1 _ R0 + 1, NibCarryBr, DISP4[NibTable],	c3;NibTable:	R2 _ 0 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[0, 10, NibTable];	R2 _ 1 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[1, 10, NibTable];	R2 _ 2 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[2, 10, NibTable];	R2 _ 3 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[3, 10, NibTable];	R2 _ 4 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[4, 10, NibTable];	R2 _ 5 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[5, 10, NibTable];	R2 _ 6 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[6, 10, NibTable];	R2 _ 7 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[7, 10, NibTable];	R2 _ 8 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[8, 10, NibTable];	R2 _ 9 xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[9, 10, NibTable];	R2 _ 0A xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[0A, 10, NibTable];	R2 _ 0B xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[0B, 10, NibTable];	R2 _ 0C xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[0C, 10, NibTable];	R2 _ 0D xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[0D, 10, NibTable];	R2 _ 0E xor R0, ZeroBr, BRANCH[NibLoop, NibFail], c1, at[0E, 10, NibTable];	R2 _ 0F xor R0, ZeroBr, BRANCH[NibTestFail, PreByteTest], c1, at[0F, 10, NibTable];NibLoop:	R0 _ R1, YDisp, BRANCH[NibBad, NibGood],	c2;NibFail:	CANCELBR[NibBug],	c2;NibTestFail:	CANCELBR[NibBug],	c2;NibBug:		GOTO[NibBad],	c3;{Check that 0 thru F0 (incr. by 10) can be placed onto X bus.  This primarily tests the S257 which places bits 0-3 of constant onto X bus.}PreByteTest:	BRANCH[Nib0FBad,$],	c2;		Noop,	c3;ByteTest:	R3 _ 0,					c1, at[1DB];ByteCont:	R3 _ R3 + 1, YDisp,			c2;		R2 _ R3 LRot4, DISP4[ByteTable],	c3;ByteTable:	R2 _ 0, GOTO[ByteLast],     c1, at[0, 10, ByteTable];	R0 _ 10, GOTO[ByteLoop],      c1, at[1, 10, ByteTable];	R0 _ 20, GOTO[ByteLoop],      c1, at[2, 10, ByteTable];	R0 _ 30, GOTO[ByteLoop],      c1, at[3, 10, ByteTable];	R0 _ 40, GOTO[ByteLoop],      c1, at[4, 10, ByteTable];	R0 _ 50, GOTO[ByteLoop],      c1, at[5, 10, ByteTable];	R0 _ 60, GOTO[ByteLoop],      c1, at[6, 10, ByteTable];	R0 _ 70, GOTO[ByteLoop],      c1, at[7, 10, ByteTable];	R0 _ 80, GOTO[ByteLoop],      c1, at[8, 10, ByteTable];	R0 _ 90, GOTO[ByteLoop],      c1, at[9, 10, ByteTable];	R0 _ 0A0, GOTO[ByteLoop],     c1, at[0A, 10, ByteTable];	R0 _ 0B0, GOTO[ByteLoop],     c1, at[0B, 10, ByteTable];	R0 _ 0C0, GOTO[ByteLoop],     c1, at[0C, 10, ByteTable];	R0 _ 0D0, GOTO[ByteLoop],     c1, at[0D, 10, ByteTable];	R0 _ 0E0, GOTO[ByteLoop],     c1, at[0E, 10, ByteTable];	R0 _ 0F0, GOTO[ByteLoop],     c1, at[0F, 10, ByteTable];ByteLoop:	R2 _ R0 xor R2, ZeroBr,	c2;		BRANCH[ByteBad, ByteGood],	c3;ByteGood: 	GOTO[ByteCont],	c1;ByteLast:	R2 _ 0 xor R2, ZeroBr,	c2;		BRANCH[ByteBug, LogicTest],	c3;{2.b	Logic tests.  Check that logical operations work with no stuck results.}{or}{Can we do "0 or 0"?}LogicTest:	R0 _ 0,						c1, at[1C7];	R1 _ 0,						c2;	R1 _ ~R1 xor R1, {_ 1's xor 0's, preload 1's}	c3;	R0 _ R0 or R0, ZeroBr,				c1;	R1 _ R1, BRANCH[S0or0Bad, $],			c2;	Noop,						c3;{Can we do "0 or 1"?}ZeroOr1:	R0 _ 0,						c1, at[2BF];	R1 _ ~R0,					c2;	R2 _ ~R1, {preload 0's}				c3;	R0 _ R0 or R1, {R0 _ 0's or 1's}		c1;	R0 _ ~R0, ZeroBr, 				c2;			R0 _ ~R0, BRANCH[S0or1Bad, S0or1Good],		c3;{Can we do "1 or 0"?}S0or1Good:	R0 _ 0,						c1, at[1C9];	R1 _ ~R0,					c2;	R2 _ ~R1, {preload 0's}				c3;	R0 _ R1 or R0, {R0 _ 1's or 0's}		c1;	R0 _ ~R0, ZeroBr,				c2;			R0 _ ~R0, BRANCH[S1or0Bad, S1or0Good],		c3;{Can we do "1 or 1"?}S1or0Good:	R0 _ 0,						c1, at[1F3];	R0 _ ~R0,					c2;	R1 _ R0,					c3;	R2 _ 0,						c1;	R0 _ R0 or R1,					c2;	R0 _ ~R0, ZeroBr,				c3;	R0 _ ~R0, BRANCH[S1or1Bad, $],			c1;	Noop,						c2;	Noop,						c3;{and}{Can we do "0 and 0"?}ZeroAnd1:	R0 _ 0,						c1, at[2D1];	R0 _ R0 and R0, ZeroBr,				c2;	R1 _ ~R1 xor R1, BRANCH[S0and0Bad, S0and0Good],	c3;{Can we do "0 and 1"?}S0and0Good:	R0 _ 0,						c1, at[1F5];	R1 _ ~R0,					c2;	R0 _ R0 and R1, ZeroBr,				c3;	R1 _ R1, BRANCH[S0and1Bad, $],			c1;	Noop,						c2;	Noop,						c3;{Can we do "1 and 0"?}OneAnd0:	R0 _ 0,						c1, at[2D8];	R1 _ ~R0,					c2;	R0 _ R1 and R0, ZeroBr,				c3;	R1 _ R1, BRANCH[S1and0Bad, $],			c1;	Noop,						c2;	Noop,						c3;{Can we do "1 and 1"?}OneAnd1:	R0 _ 0,						c1, at[2DD];	R0 _ ~R0,					c2;	R1 _ R0,					c3;	R2 _ ~R0,					c1;	R0 _ R0 and R1,					c2;	R0 _ ~R0, ZeroBr,				c3;	R0 _ ~R0, BRANCH[S1and1Bad, $],			c1;	Noop,						c2;	Noop,						c3;{~R and S}{Can we do "~0 and 1"?}Not0and1:	R0 _ 0,					c1, at[2E5];	R1 _ ~R0,				c2;	R1 _ ~R0 and R1, {should _ 1's}		c3;	R1 _ ~R1, 	{should _ 0's} ZeroBr,	c1;	BRANCH[N0and1Bad, $],			c2;	Noop,					c3;{Can we do "~1 and 1"?}Not1and1:	R0 _ 0,							c1, at[2EA];	R0 _ ~R0, {2901 does ~(internal 0) xor R0 to comp S input B=R0} c2;	R0 _ ~R0 and R0, {2901: ~(R_A) and (S_B)}, ZeroBr,	c3;	  {R0 was 1's, ~1 and 1 = 0} 	BRANCH[N1and1Bad, $],			c1;	Noop,					c2;	Noop,					c3;{xor}{Can we do "0 xor 1"?}ZeroXor1:	R0 _ 0,					c1, at[2EF];	R1 _ ~R0,				c2;	R0 _ R0 xor R1,				c3;	R0 _ ~R0, ZeroBr,			c1;	BRANCH[S0xor1Bad, $],			c2;	Noop,					c3;{Can we do "1 xor 0"?}OneXor0:	R1 _ 0,					c1, at[2F4];	R0 _ ~R1,				c2;	R0 _ R0 xor R1,				c3;	R0 _ ~R0, ZeroBr,			c1;	BRANCH[S1xor0Bad, $],			c2;	Noop,					c3;{xnor}{Can we do "~0 xor 0"?}Not0xor0:	R0 _ 0,					c1, at[2F9];	R0 _ ~R0 xor R0,			c2;	R1 _ ~R0, ZeroBr,			c3;	BRANCH[N0xor0Bad, $],			c1;	Noop,					c2;	Noop,					c3;{Can we do "~1 xor 1"?}Not1xor1:	R0 _ 0,					c1, at[2FE];	R0 _ ~R0,				c2;	R0 _ ~R0 xor R0,			c3;	R1 _ ~R0, ZeroBr,			c1;	BRANCH[N1xor1Bad, $],			c2;	Noop,					c3;{2.c	Shift/cycle tests.}{The single bit shifting hardware is tested in two steps: (1) internal/intra 2901 shifting and (2) external shift ends.  (1) is tested by right/left shifting a solitary 1/0 through an R resister (and Q).  (2) is tested by trying 0/1 ShiftEnds for each of the 4 types of long/short/shifting/cyclying.  A third test compares the results of LRotn with 4n single bit shifts.}{(1):  Shift a solitary 1 right throught R0, and then back left again from where it started.}ShiftR1:	R0 _ RShift1 0, SE_1,  {R0_8000'x}	c1, at[303];	R1 _ 15'd,				c2;ShiftR1Loop:	R0 _ RShift1 R0, SE_0,		c3;	R1 _ R1 - 1, ZeroBr,			c1;	BRANCH[ShiftR1Loop, ShiftR1Done],	c2;{R0 should be 1.}ShiftR1Done:	Noop,					c3;	Noop,					c1;	R2 _ R0 xor 1, ZeroBr,			c2;	BRANCH[ShiftR1Bad, ShiftR1Good],	c3;{Now start shifting Solitary 1 back to the left.}ShiftR1Good:	R1 _ 15'd,				c1, at[1E7];	R0 _ LShift1 0, SE _ 1,			c2; {set R0=0001}ShiftL1Loop:	R0 _ LShift1 R0, SE_0,		c3;	R1 _ R1 - 1, ZeroBr,			c1;	BRANCH[ShiftL1Loop, ShiftL1Done],	c2;{R0 should be 8000'x now.}ShiftL1Done:	Noop,					c3;	R2 _ RShift1 0, SE_1,			c1;	R2 _ R0 xor R2, ZeroBr,			c2;	BRANCH[ShiftL1Bad, ShiftL1Good],	c3;{Now shift a solitary 0 right/left through R0.}ShiftL1Good:	R0 _ RShift1 (~R0 xor R0), SE_0,  {R0_7FFF'x}	c1, at[1E9];	R1 _ 15'd,	c2;ShiftR0Loop:	R0 _ RShift1 R0, SE_1,	c3;	R1 _ R1 - 1, ZeroBr,	c1;	BRANCH[ShiftR0Loop, ShiftR0Done],	c2;{R0 should be FFFE'x.}ShiftR0Done:	Noop,					c3;	Noop,					c1;	R2 _ ~1 xor R0, ZeroBr,			c2;	BRANCH[ShiftR0Bad, ShiftR0Good],	c3;{Now start shifting Solitary 0 back to the left.}ShiftR0Good:	R1 _ 15'd,				c1, at[1EB];	R0 _ LShift1 (~R0 xor R0), SE _ 0,	c2; {set R0=FFFE}ShiftL0Loop:	R0 _ LShift1 R0, SE_1,	c3;	R1 _ R1 - 1, ZeroBr,	c1;	rhR2 _ 0FF, BRANCH[ShiftL0Loop, ShiftL0Done],	c2;{R0 should be 7FFF'x now.}ShiftL0Done:	Noop,					c3;	R2 _ RShift1 (~R2 xor R2), SE_0,	c1;	R2 _ R0 xor R2, ZeroBr,			c2;	BRANCH[ShiftL0Bad, ShiftL0Good],	c3;{Double Shifts, cycleX}ShiftL0Good:{DRShift1 SE=0,R=FFFE,Q=0}	R2 _ RShift1 (~R2 xor R2), SE _ 0,		c1, at[1ED];	     {R2=7FFF=expected R5 value after DRShift}	R3 _ ~R2, {R3=8000=expected Q value after DRShift}	c2;	R4 _ -2, {R4=FFFE, starting pattern}		c3;	Q _ 0, {starting pattern}			c1;	R5 _ DRShift1 R4, SE _ 0, {Q has 0}		c2;	[] _ R5 xor R2, ZeroBr,				c3;	[] _ R3 xor Q, ZeroBr, BRANCH[DRSftBad0, $],	c1;	BRANCH[DRSftBadQ1, $],				c2;	Noop,						c3;{DRShift1 SE=1,R=1,Q=FFFF}DRShiftS1R1Q1:	R5 _ 1,	{starting pattern},			c1, at[322];	Q _ ~R2 xor R2, {Q=FFFF, starting pattern}	c2;	R3 _ RShift1 (0), SE _ 1,			c3;	     {R3=8000=expected R5 value after shift}	R2 _ RShift1 (~R2 xor R2), SE _ 0,		c1;	     {R2=7FFF=expected Q value after shift}	R5 _ DRShift1 R5, SE _ 1,			c2;	[] _ R5 xor R3, ZeroBr,				c3;	[] _ R2 xor Q, ZeroBr, BRANCH[DRSftBad1, $],	c1;	BRANCH[DRSftBadQ0, $],				c2;	Noop,						c3;{DLShift1 R=0,Q=8000,SE=1}DLShiftS1R0Q1msb:	R5 _ RShift1 (0), SE _ 1, {8000}		c1, at[329];	Q _ R5, {8000}					c2;	R5 _ 0,						c3;	R5 _ DLShift1 R5, SE _ 1,			c1;	[] _ R5 xor 1, {R5 should be 0001} ZeroBr,	c2;	[] _ Q,	{Q should be 0000} ZeroBr, BRANCH[DLSftBad0, $], c3;	BRANCH[DLSftBadQ0, $],				c1;	Noop,						c2;	Noop,						c3;{DLShift1 R=FFFF,Q=7FFF,SE=0}DLShiftS0R0Q0msb:	R5 _ ~R5 xor R5,				c1, at[330];	R2 _ RShift1 (~R2 xor R2), SE _ 0,		c2; 	Q _ R2,						c3;	R4 _ -2, {FFFE, expected R5}			c1;	R5 _ DLShift1 R5, SE _ 0,			c2;	[] _ R5 xor R4, ZeroBr,				c3;	[] _ ~Q, ZeroBr, BRANCH[DLSftBad1, $],		c1;	BRANCH[DLSftBadQ1, $],				c2;	GOTO[DALSR0Q1SE1],				c3;{DALShift1 R=0,Q=FFFF,SE=1}DALSR0Q1SE1:	Noop,						c1, at[337];	R0 _ 0,						c2;	Q _ ~R0,					c3;	R4 _ -2, {FFFE, expected Q}			c1;	R5 _ DALShift1 R0, SE _ 1,			c2;	[] _ R4 xor Q, ZeroBr,				c3;	[] _ R5 xor 1, ZeroBr, BRANCH[ShQ0, $],		c1;	BRANCH[Sh1, $],					c2;	GOTO[DALSR1Q0SE0],				c3;{DALShift1 R=FFFF,Q=0,SE=0}DALSR1Q0SE0:	R5 _ ~R5 xor R5,				c1, at[33E];	Q _ 0,						c2;	R4 _ -2,					c3;	R5 _ DALShift1 R5, SE _ 0,			c1;	[] _ R5 xor R4, ZeroBr,				c2;	[] _ Q xor 1, ZeroBr, BRANCH[Sh0, $],	c3;	BRANCH[ShQ1, $],				c1;	Noop,						c2;	GOTO[DARSR0QxSE1],				c3;{DARShift1 SE=1,R=0,Q=xx}DARSR0QxSE1:	R5 _ 0,						c1, at[345];	R3 _ RShift1 (0), SE _ 1, {8000}		c2;	R5 _ DARShift1 (R5 - R5), 			c3;	[] _ R5 xor R3, ZeroBr,				c1;	BRANCH[RSh1, $],				c2;	GOTO[DARSR1QxSE0],				c3;{DARShift1 SE=0,R=FFFF,Q=xx}DARSR1QxSE0:	R5 _ ~R5 xor R5,				c1, at[34A];	R2 _ RShift1 (~R2 xor R2), SE_0,  {7FFF}	c2;	R5 _ DARShift1 (R5 + 0),			c3;	R5 _ R5 xor R2, ZeroBr,				c1;	BRANCH[RSh0, $],				c2;	GOTO[CycleY],					c3;{cycleY}CycleY:	Q _ 0,						c1, at[34F];	R4 _ -2, {FFFE}					c2;	R2 _R2 _ RShift1 (~R2 xor R2), SE _ 0, {7FFF}	c3;	R5 _ DRShift1 R4, SE _ 0, pCall1 {force cycleY},	c1;	[] _ R5 xor R2, ZeroBr,				c2;	BRANCH[DRZSftBad0, $]				c3;{2.d	LRotn/cycle tests.}{This test places a 1 or 0 in every bit position and then LRotn's (n=0,4,8,12) it and compares the result with the same value shifted via LRot1's.R0 = 0, 4, 8, 0C for LRot0, LRot4, LRot8, LRot12	R1 = 1, 2, 4, ..., 8000 and then FFFE, FFFD, ...., 7FFFR2 = LRotn'd value of R0R3 = LRot1'd value of R0.  {R2 should always equal R3}R4 = temp}LRotnTest:	R1 _ 1, {start with ..001}		c1, at[235];NextPh:		R0 _ 0,					c2;NextRot:	Noop,					c3;	R4 _ R0, YDisp	,c1;	R3 _ R1, DISP4[LRotn]	,c2;LRotn:	R2 _ R1 LRot0, GOTO[L1Rot]	,c3, at[0,10,LRotn];	R2 _ R1 LRot4, GOTO[L1Rot]	,c3, at[4,10,LRotn];	R2 _ R1 LRot8, GOTO[L1Rot]	,c3, at[8,10,LRotn];	R2 _ R1 LRot12, GOTO[L1Rot]	,c3, at[0C,10,LRotn];L1Rot:	R4 _ R4 - 1, NegBr	,c1;	BRANCH[$, LRotComp]	,c2;	R3 _ R3 LRot1, GOTO[L1Rot]	,c3;LRotComp:	Q _ R2 {LRotn} xor R3 {LRot1}, NZeroBr	,c3;	R0 _ R0 + 4, NibCarryBr, BRANCH[$, BadLRot]	,c1;	R0 _ R0 and 0F, BRANCH[NextRot, $]	,c2;	R1 _ R1 LRot1	,c3; 	R4 _ R1 and 7	,c1;	[] _ R4 xor 1, NZeroBr  {have we returned to start:  ..001 or ..110?}	,c2;	[] _ R4 xor 6, NZeroBr, BRANCH[$, LRotP2]	,c3;	R1 _ ~R1, CANCELBR[NextPh]	,c1;LRotP2:	BRANCH[$, Ph2Cont]	,c1;	Noop	,c2; 	GOTO[ArithTest]	,c3;Ph2Cont:	GOTO[NextRot]	,c2; {2.e	Arithmetic, intra-carry tests, Cin_pc16}{Test sum of 1010+1100 in each nibble of ALU and look for carry into next stage.  Cin=0}ArithTest:	R0 _ 0A,			c1, at[35D];	R1 _ 0C,			c2;	Q _ R0 + R1,	{Q = 0016}	c3;	R2 _ 16	,c1;	[] _ Q xor R2, ZeroBr	,c2;	BRANCH[Sum12Bad, Sum12Good]	,c3;Sum12Good:	R0 _ 0A0 {R0 = 00A0}	,c1, at[243];	R1 _ 0C0 {R1 = 00C0}	,c2;	Q _ R0 + R1 {Q = 0160}	,c3;	R2 _ LShift1(0B0), SE _ 0 {0160}	,c1;	[] _ Q xor R2, ZeroBr		,c2;	BRANCH[Sum8Bad, Sum8Good]	,c3;Sum8Good:	R0 _ 0A				,c1, at[23D];	R0 _ R0 LRot8 {R0 = 0A00}	,c2;	R1 _ 0C				,c3;	R1 _ R1 LRot8 {R1 = 0C00}	,c1;	Q _ R0 + R1 {Q = 1600}		,c2;	R2 _ 16				,c3;	R2 _ R2 LRot8 {1600}		,c1;	[] _ Q xor R2, ZeroBr		,c2;	BRANCH[Sum4Bad, Sum4Good]	,c3; Sum4Good:	R0 _ 0A				,c1, at[245];	R1 _ 0C				,c2;	R2 _ 6				,c3;	R0 _ R0 LRot12 {R0 = A000}	,c1;	R1 _ R1 LRot12 {R1 = C000}	,c2;	Q _ R0 + R1, CarryBr {Q = 6000}	,c3;	R2 _ R2 LRot12, BRANCH[Sum0CyBd, Sum0CyGd]	,c1;Sum0CyGd:	[] _ Q xor R2, ZeroBr	,c2;	BRANCH[Sum0Bad, Sum0Good]	,c3;{Test subtraction of 0011 - 1001 in each nibble of ALU and look for carry into next stage.  Cin=1}Sum0Good:	R0 _ 3			,c1, at[247];	R1 _ 9			,c2;	Q _ R0 - R1 {Q _ -6}	,c3;	Noop	,c1;	[] _ Q xor ~5, ZeroBr	,c2;	BRANCH[Sub12Bad, Sub12Good]	,c3;Sub12Good:	R0 _ 30			,c1, at[251];	R1 _ 90			,c2;	Q _ R0 - R1 {Q _ FFA0}	,c3;	R2 _ ~5F	,c1;	[] _ Q xor R2, ZeroBr	,c2;	BRANCH[Sub8Bad, Sub8Good]	,c3;Sub8Good:	R0 _ 3				,c1, at[249];	R0 _ R0 LRot8 {R0 = 0300}	,c2;	R1 _ 9				,c3;	R1 _ R1 LRot8 {R1 = 0900}	,c1;	Q _ R0 - R1 {Q _ FA00}		,c2;	R2 _ 0FA			,c3;		R2 _ R2 LRot8 	,c1;	[] _ Q xor R2, ZeroBr	,c2;	BRANCH[Sub4Bad, Sub4Good]	,c3;Sub4Good:	R0 _ 3				,c1, at[253];	R0 _ R0 LRot12 {R0 = 3000}	,c2;	R1 _ 9				,c3;	R1 _ R1 LRot12 {R1=9000}	,c1;	Q _ R0 - R1 {Q _ A000}		,c2;	R2 _ 0A				,c3;	R2 _ R2 LRot12 	,c1;	R3 _ Q xor R2, ZeroBr	,c2;	BRANCH[Sub0Bad, Sub0Good]	,c3;{Test complete carry propagation first with Cin=1, then Cin=0.}Sub0Good:	R3 _ 0					,c1, at[24B];	R1 _ R3 - 1 {R1_FFFF, Cin=0}		,c2;	R2 _ R1 + 1 {R2_0, Cin=1}, ZeroBr	,c3;	BRANCH[ArithBad, $]	,c1;	Noop,			c2;	Noop,			c3;{Try Cin=pc16, XC2npcDisp.  First set pc16=1.}CinDisp:	Noop,					c1, at[395];	XC2npcDisp				,c2;	R0 _ 0, BRANCH[NoFlip, Flip, 0E]	,c3;NoFlip:	GOTO[TestCinpc16]	,c1;Flip:	Cin _ pc16, GOTO[TestCinpc16]	,c1;TestCinpc16:	R1 _ R0 + PC16 {pc16=1}, Xbus_rhR1 {force fXCin_pc16}	,c2;	R2 _ R1 xor 1, ZeroBr			,c3;	BRANCH[Testpc16off, $]	,c1;	Noop,			c2;	Noop,			c3;PC16OneGd:	Noop			,c1, at[24D];	XC2npcDisp				,c2;	R0 _ 0, BRANCH[Flipit,pc16off, 0E]	,c3;pc16off:	GOTO[Testpc16off]	,c1;Flipit:		Cin _ pc16, GOTO[Testpc16off]	,c1;Testpc16off:	R2 _ R0 + PC16 {pc16=0}, ZeroBr, pCall0 {force fZCin_pc16}	,c2;	BRANCH[PC16ZBad, $]	,c3;{2.f	stackP tests.}StkpTest:	R1 _ 1,					c1, at[23B];	stackP _ R1 _ 0F,			c2;	R2 _ ErrnIBnStkp and R1, ZeroBr,	c3;	stackP _ R2, BRANCH[StckP1Bad, $],	c1;	Noop,					c2;{Try all versions of push & pop}	[] _ ~ErrnIBnStkp and R1, ZeroBr, {stkP=0}	c3;	push {fXpush}, Xbus _ 5, XRefBr, BRANCH[Stack0Bad, $],	c1;	push {fYpush}, rhR1 _ R1 LRot0, CANCELBR[$],	c2;	push {fZpush}, pCall1, MesaIntBr, {stkP = 3}	c3;	R3 _ ~ErrnIBnStkp and R1, CANCELBR[$]	c1;	[] _ R3 xor 3, ZeroBr,	c2;	BRANCH[StackPsBad, $],	c3;	fXpop,	c1;	fZpop,	c2;	push, pop,	c3;	R3 _ ~ErrnIBnStkp and R1,	c1;	[] _ R3 xor 1, ZeroBr,	c2;	BRANCH[StackPoBad, MAReffect],	c3;{2.g	MAR_" effects  (See memory test for MDR_ cancelled.  See ibTest for IBDisp canceled.}{Check for branch in INIA.10. High half function "0 or B".}MAReffect:	Noop,				c1, at[265];	R0 _ ~R0 xor R0 {R0_0FFFF}	,c2;	rhR1 _ 0, R1 _ 0	,c3;{Before MAR: R0=FFFF, R1=0.  After MAR: R1=0}	MAR _ R1 _ [rhR1, R0+1]	,c1;	BRANCH[MarPgCr1Bd, MarPgCr1Gd, 1]	,c2;MarPgCr1Gd:	Noop 	,c3;	Noop	,c1;	[] _ R1, ZeroBr  {no carry into high half?}	,c2;	R0 _ 0, BRANCH[MarHigh0Bd, MarHigh0Gd]	,c3;{Before MAR: R0=0, R1=0.  After MAR: R1=FF}MarHigh0Gd:	MAR _ R1 _ [rhR1, R0-1]	,c1;	BRANCH[MarPgCr0Bd, MarPgCr0Gd, 1]	,c2;MarPgCr0Gd:	Noop 	,c3;      R2 _ 0FF	,c1;      [] _ R1 xor R2, ZeroBr  {no carry into high half?}	,c2;      TestCnt _ TestCnt + 1 {TestCnt=7}, BRANCH[MarHigh1Bd, NOERROR1]	,c3;LRot0Bad1:	RErr _ 26, GOTO[LRot0Bad1],	c*;LRot0Bad0:	RErr _ 27, GOTO[LRot0Bad0],	c*;RRot0Bad1:	RErr _ 28, GOTO[RRot0Bad1],	c*;RRot0Bad0:	RErr _ 29, GOTO[RRot0Bad0],	c*;LRot0YBad:	RErr _ 2A, GOTO[LRot0YBad],	c*;LRot4Bad0:	RErr _ 2B, GOTO[LRot4Bad0],	c*;LRot4Bad1:	RErr _ 2C, GOTO[LRot4Bad1],	c*;LRot8Bad0:	RErr _ 2D, GOTO[LRot8Bad0],	c*;LRot8Bad1:	RErr _ 2E, GOTO[LRot8Bad1],	c*;LRot12Bad0:	RErr _ 2F, GOTO[LRot12Bad0],	c*;LRot12Bad1:	RErr _ 30, GOTO[LRot12Bad1],	c*;{R0 contains the intented value, x}NibBad:	RErr _ 31, CANCELBR[NibBad1], 	c*;NibBad1:	RErr _ 31, GOTO[NibBad1], 	c*;ByteBad:	RErr _ 32, CANCELBR[ByteBad1], 	c*;ByteBad1:	RErr _ 32, GOTO[ByteBad1], 	c*;ByteBug:	RErr _ 33, GOTO[ByteBug],	c*;S0or0Bad:	RErr _ 34, GOTO[S0or0Bad],	c*;S0or1Bad:	RErr _ 35, GOTO[S0or1Bad],	c*;S1or0Bad:	RErr _ 36, GOTO[S1or0Bad],	c*;S1or1Bad:	RErr _ 37, GOTO[S1or1Bad],	c*;S0and0Bad:	RErr _ 38, GOTO[S0and0Bad],	c*;S0and1Bad:	RErr _ 39, GOTO[S0and1Bad],	c*;S1and0Bad:	RErr _ 3A, GOTO[S1and0Bad],	c*;S1and1Bad:	RErr _ 3B, GOTO[S1and1Bad],	c*;N0and1Bad:	RErr _ 3D, GOTO[N0and1Bad],	c*;N1and1Bad:	RErr _ 3F, GOTO[N1and1Bad],	c*;S0xor1Bad:	RErr _ 41, GOTO[S0xor1Bad],	c*;S1xor0Bad:	RErr _ 42, GOTO[S1xor0Bad],	c*;N0xor0Bad:	RErr _ 44, GOTO[N0xor0Bad],	c*;N1xor1Bad:	RErr _ 47, GOTO[N1xor1Bad],	c*;Sum12Bad:	RErr _ 48, GOTO[Sum12Bad]	,c*;Sum8Bad:	RErr _ 49, GOTO[Sum8Bad]	,c*;Sum4Bad:	RErr _ 4A, GOTO[Sum4Bad]	,c*;Sum0Bad:	RErr _ 4B, GOTO[Sum0Bad]	,c*;Sum0CyBd:	RErr _ 4C, GOTO[Sum0CyBd]	,c*;Sub12Bad:	RErr _ 4D, GOTO[Sub8Bad]	,c*;Sub8Bad:	RErr _ 4E, GOTO[Sub8Bad]	,c*;Sub4Bad:	RErr _ 4F, GOTO[Sub4Bad]	,c*;Sub0Bad:	RErr _ 50, GOTO[Sub0Bad]	,c*;ArithBad:	RErr _ 51, GOTO[ArithBad]	,c*;PC16OneBad:	RErr _ 52, GOTO[PC16OneBad]	,c*;PC16ZBad:	RErr _ 53, GOTO[PC16ZBad]	,c*;MarPgCr1Bd:	RErr _ 54, GOTO[MarPgCr1Bd]	,c*;MarHigh0Bd:	RErr _ 55, GOTO[MarHigh0Bd]	,c*;MarPgCr0Bd:	RErr _ 56, GOTO[MarPgCr0Bd]	,c*;MarHigh1Bd:	RErr _ 57, GOTO[MarHigh1Bd]	,c*;ShiftR1Bad:	RErr _ 58, GOTO[ShiftR1Bad],	c*;ShiftL1Bad:	RErr _ 59, GOTO[ShiftL1Bad],	c*;ShiftR0Bad:	RErr _ 5A, GOTO[ShiftR0Bad],	c*;ShiftL0Bad:	RErr _ 5B, GOTO[ShiftL0Bad],	c*;StckP1Bad:	RErr _ 5C, CANCELBR[StckP1Bad1],	c*;Stack0Bad:	RErr _ 5D, CANCELBR[Stack0Bad1],	c*;StackPsBad:	RErr _ 5E, CANCELBR[StackPsBad1],	c*;StackPoBad:	RErr _ 5F, CANCELBR[StackPoBad1],	c*;DRSftBad0:	RErr _ 60, CANCELBR[DRSftBad01],	c*;DRSftBadQ1: RErr _ 61, CANCELBR[DRSftBadQ11],	c*;DRSftBad1:	RErr _ 62, CANCELBR[DRSftBad11],	c*;DRSftBadQ0: RErr _ 63, CANCELBR[DRSftBadQ01],	c*;DLSftBad0:	RErr _ 64, CANCELBR[DLSftBad01],	c*;DLSftBadQ1: RErr _ 65, CANCELBR[DLSftBadQ11],	c*;DLSftBad1:	RErr _ 66, CANCELBR[DLSftBad11],	c*;DLSftBadQ0: RErr _ 67, CANCELBR[DLSftBadQ01],	c*;ShQ0: RErr _ 68, CANCELBR[ShQ0L],	c*;Sh1: RErr _ 69, CANCELBR[Sh1L],	c*;Sh0: RErr _ 70, CANCELBR[Sh0L],	c*;ShQ1: RErr _ 71, CANCELBR[ShQ1L],	c*;RSh0:	RErr _ 72, GOTO[RSh0L],	c*;RSh1: RErr _ 73, GOTO[RSh1L],	c*;DRZSftBad0:	RErr _ 74, CANCELBR[DRZSftBad01],	c*;BadLRot:	RErr _ 0AF, CANCELBR[BadLRot1]	,c*;StckP1Bad1:	RErr _ 5C, GOTO[StckP1Bad1],	c*;Stack0Bad1:	RErr _ 5D, GOTO[Stack0Bad1],	c*;StackPsBad1:	RErr _ 5E, GOTO[StackPsBad1],	c*;StackPoBad1:	RErr _ 5F, GOTO[StackPoBad1],	c*;DRSftBad01:	RErr _ 60, GOTO[DRSftBad01],	c*;DRSftBadQ11: RErr _ 61, GOTO[DRSftBadQ11],	c*;DRSftBad11:	RErr _ 62, GOTO[DRSftBad11],	c*;DRSftBadQ01: RErr _ 63, GOTO[DRSftBadQ01],	c*;DLSftBad01:	RErr _ 64, GOTO[DLSftBad01],	c*;DLSftBadQ11: RErr _ 65, GOTO[DLSftBadQ11],	c*;DLSftBad11:	RErr _ 66, GOTO[DLSftBad11],	c*;DLSftBadQ01: RErr _ 67, GOTO[DLSftBadQ01],	c*;ShQ0L: RErr _ 68, GOTO[ShQ0L],	c*;Sh1L: RErr _ 69, GOTO[Sh1L],	c*;Sh0L: RErr _ 70, GOTO[Sh0L],	c*;ShQ1L: RErr _ 71, GOTO[ShQ1L],	c*;RSh0L:	RErr _ 72, GOTO[RSh0L],	c*;RSh1L: RErr _ 73, GOTO[RSh1L],	c*;DRZSftBad01:	RErr _ 74, GOTO[DRZSftBad01],	c*;BadLRot1:	RErr _ 0AF, GOTO[BadLRot1]	,c*;Nib0FBad:	RErr _ 0AF, GOTO[Nib0FBad]	,c*;NOERROR1:	GOTO[NOERROR],	                           	c*;NOERROR:	ClrMPIntIOP,GOTO[NOERROR],   	c*, at[0FF2];LoaderCheck:	ClrMPIntIOP,GOTO[LoaderCheck],c*, at[0FFF];
$	DEBUG MOD186;MoonFlp.asm;last edited by TXM		29-Sep-87 13:23:11;; i8272A.asm; Last Edited by U. Khulusi   8-4-85 ; Code only supports one 5 1/4" drive at this time; Drive size is read off the EEPROM and can be either a 1.2MB or 360KB; This code was copied in parts and modified from i8272C.asm written by; P. Timm, J. Binkley and H. Lopez for engineering diagnostics purposes; and was last edited by H. Lopez on 11 - Oct - 84.;;$	TITLE (Test diagnostics code for Floppy Disk Controller i8272A);	NAME	i8272A$	NOLIST		;include moonsys.def and moonlink.def$	INCLUDE(MoonSys.def)$	INCLUDE(MoonLink.def);;;;;*******************************************************;  ;	;			; Interrupt  Controller -- Master i8259A;; [Programming information on Page 2-120 of ; the Intel '84 Microsystem Components Handbook];  Other 80186 Internal Control registers addresses;FDC test KindRecalKind	EQU 01H			;ReadID		EQU 02H			;WriteSector	EQU 04H			;ReadSector	EQU 08H			;WrtDelSector	EQU 10H			;RdDelSector	EQU 20H			;FormatCyc	EQU 40HMoreHeads	EQU 01H			;MoreCylinders	EQU 02H			;MoreUnits	EQU 04H			;;FDC commandsfdcReadCmd	EQU 06H			;Read Command.ReadATrackCmd	EQU 02H			;Read a Track Command.ReadIDCmd	EQU 0AH			;Read ID Command.fdcSpecify	EQU 03H			;Holds the Specify Command.fdcRecal	EQU 07H			;Holds the Recalibrate Command.;;FDC parametersStepRate	EQU 0D0H		;Holds the Step Rate @ 6mS.					;(use 0B0H for 10mS)HUT		EQU 01H			;Holds the Head Unload Time @16mS.DmaMode	 	EQU 00H			;Holds the to DMA or not to DMA = 0HLTime		EQU 0AH			;HLTime = 20 mSfdcMinCylinder	EQU 00H			;Minimum cylinder numberfdcMinHead	EQU 00H			;Minimum head numberfdcMaxHead	EQU 04H			;Maximum head numberfdcMinSector	EQU 01H			;Minimum sector numberFloppyIntEnable EQU 0DFEFH		;FloppyInterruptEnable;;FDC test parametersfdcNoStop	EQU 01H			;Don't stop for ErrorfdcIncDataByte	EQU 02H			;Inc daya each bytefdcNoheader	EQU 04H			;No header in datafdcIncDataSec	EQU 08H			;Inc data each secfdcDiagPat	EQU 10H			;Dianostic Pattern each secFDDnotConnected	EQU 40HfdcNoMemParity	EQU 80H			;Don't Log Parity Errors;;*******************************************************;  	FDCTCBlock	STRUC			;FDC Test Control Block Structure StartfdcDataAndErrCtl	DB 00H			;Error Control					;Bits 0= 0= Stop on Error					;0= 1= Don't stop but restart					;1= 0= Block Patterns					;1= 1= Inc Data each Byte					;2= 0= Header In Data					;2= 1= No Header In Data					;3= 0= Don't Inc Data on Every Sec					;3= 1= Inc Data on Every Sec					;40H= FDD no Connectiont test					;7= 1= Don't log parity errors					fdcTstCtl	DB 00H			;Holds the test to be performed					;01H= Recalibrate					;02H= Read ID					;04H= Write A Track					;08H= Read A Track                                        ;010H= Write A Deleted Sector					;020H= Read A Deleted Sector					;040H= Format a CycfdcPageParity  DB  0fdcBankParity DB  0					fdcSHead	DB 00H			;Holds the Starting Head number.fdcSUnit	DB 00H			;Holds the Starting Unit number.					;00H= Unit 0				        ;01H= Unit 1				        ;02H= Unit 2				        ;03H= Unit 3					fdcSSector	DB 01H			;Holds the Starting Sector number.fdcSCylinder	DB 00H			;Holds the Starting Cylinder number.fdcEHead	DB 00H			;Holds the Ending Head number.fdcEUnit	DB 00H			;Holds the Ending Unit number.					;00H= Unit 0				        ;01H= Unit 1				        ;02H= Unit 2				        ;03H= Unit 3					fdcESector	DB 01H			;Holds the Ending Sector number.fdcECylinder	DB 00H			;Holds the Ending Cylinder number.fdcCHead	DB 00H			;Holds the Current Head number.fdcCUnit	DB 00H			;Holds the Current Unit number.					;00H= Unit 0				        ;01H= Unit 1				        ;02H= Unit 2				        ;03H= Unit 3					fdcCSector	DB 01H			;Holds the Current Sector number.fdcCCylinder	DB 00H			;Holds the Current Cylinder number.fdcSData	DB 01H			;Holds the Starting Data PatternfdcCData	DB 00H			;Holds the Current Data PatternfdcDriveType	DB 00H			;Holds the drive Type.				        ;04H= sa455 (360KB)				        ;06H= sa475 (1.2MB)fdcSectorLength DB 02H			;Holds the Sector Length.				        ;00= (Sector Length=128)				        ;01= (Sector Length=256)				        ;02= (Sector Length=512)= IBM				        ;03= (Sector Length=1024)fdcPass		DB 01H			;Number of passes to be runfdcLastPass	DB 0			;Last Pass before Stop					fdcSkipDeletedData DB 00H		;To ignore Deleted Data (SK).				        ;00H= Do not ignore deleted Data				        ;20H= Ignore Deleted Data;;Returned information from diagnostics program;fdcST0		DB 0			;Status register 0	fdcST1		DB 0			;Status register 1fdcST2		DB 0			;Status register 2fdcRetries	DB 0			;Number of Read/Write missesfdcFault	DB 0			;Holds the Faults type					;1h= NoSeekStatus					;2h= WriteReadStatusCheck					;3h= ReadDataCheck					;4h= FDCStackFault					;5h= CpuNoDataRespond					;6h= Recalibrate					;7h= CMFlagResetOnSkipReadDel					;8h= FDCNoStatusResp					;9h= WriteProtected					;0Ah= ExessInterrupt					;0BH= NoInterruptFDCTCBlock	ENDS			;FDC Test Control Block Structure End;;;$	LIST	;previous line include MoonSys.def and MoonLink.def;;;-------------------------------------------------------------------------MonitorCode	SEGMENT	COMMON		ASSUME	CS:MonitorCode, SS: MonitorCode, DS: MonitorCode                ORG 	TestCodeLoc		JMP	FDCStart		jmp FDCPreProcess		jmp FDCFRUList		jmp FDCDummy		jmp FDCDummy		jmp FDCDummy		jmp FDCDummy		                ORG     FlpTestCodeLoc;-------------------------------------------------------------------------;;TrackNum	DB ?;;	FDC UCB FieldUCB		DW Comm1		;Comm1		DB 0			;Op codeComm2		DB 0			;Hd + Unit NumberComm3		DB 0			;CComm4		DB 0			;HComm5		DB 0			;RComm6		DB 0			;NComm7		DB 0			;EOTComm8		DB 0			;GPLComm9		DB 0			;DTL;	FDC Result FieldResult		DW fdcstatusST0		;fdcstatusST0	DB 0			;Holds ST0.fdcstatusST1	DB 0			;Holds ST1.fdcstatusST2	DB 0			;Holds ST2.fdcstatusC	DB 0			;Cylinder number (also PCN)fdcstatusH	DB 0			;Head numberfdcstatusR	DB 0			;Sector numberfdcstatusN	DB 0			;Sector length;fdcMaxSector	DB 0H			;Maximum sector numberfdcRWGapLength	DB 0H			;Holds the Read/Write gap length.FIntCount	DB 0			;FDC interrupt occurredLEDStatus	DW 0			;status display infoExitPointer	DW 0			;Pointer to Stack TOP for exitCfdcTstCtl		DB 0			;FDC control reg bit image;--------------------------------------------;$	LIST	;previous line include MoonSys.def and MoonLink.defFDCDummy:    RetFDCStart:	MOV	BX,[SI].TCBPointer	;Get Index to Test Control Block		MOV 	AX,0		MOV 	ES,AX;			~~~~~~~~~~~~~~~~~~~~~~~~~~~;			*     INITIALIZE FDC...   *;			~~~~~~~~~~~~~~~~~~~~~~~~~~~;;Initialize parameters from Control Block;		Call    SetCurrentAddress;;check if control block data is valid;		MOV	[bx].fdcFault, 0	;clear error		CMP	[bx].fdcSHead, 01H	;set for greater than Head 1?		JG	FdcStartRet		;Faulty testValidCont1:	CMP	[bx].fdcSkipDeletedData, 20H	;		JZ	FloppyTestStart		;		CMP	[bx].fdcSkipDeletedData, 0H	;		JNZ	FdcStartRet		;Faulty test		jmp	FloppyTestStart		;jump FdcStartRet:					;		OR	[di].IOPFault, FileErrorCode ; Skip test		RET				FloppyTestStart:;Mark the top of the stack for test exit on error		MOV	ExitPointer, SP		;Store TOP of Stack point to exit		cmp	[bx].fdcDriveType,6	;Check for 360 KB drive type		Jne	Drive360KB		MOV	Al, 15			;Else 1 MB drive		MOV	fdcMaxSector, al		MOV	Al, 1BH		MOV	fdcRWGapLength, Al		JMP	FDCTstBrDrive360KB:	MOV	Al, 9		MOV	fdcMaxSector, Al		MOV	Al, 2AH		MOV	fdcRWGapLength, AlFDCTstBr:	TEST	[bx].fdcDataAndErrCtl,FDDnotConnected		JZ	Notst0		mov     CfdcTstCtl,0		Call     FDDnotConnectedTst			;Notst0:	        CALL	SetFlpVectors		TEST	[bx].fdcTstCtl, RecalKind ;Recalibrate test		JZ	Notst20			;		mov     CfdcTstCtl,RecalKind		CALL	RecalTstNotst20:	TEST	[bx].fdcTstCtl, FormatCyc ;Format test		JZ	Notst1					mov     CfdcTstCtl,FormatCyc		CALL	FormatTstNotst1:	        TEST	[bx].fdcTstCtl, ReadID ;ReadID test		JZ	Notst2			;		mov     CfdcTstCtl,ReadID		CALL	ReadIDTst		;Notst2:  	TEST	[bx].fdcTstCtl, WriteSector ;WritePat test		JZ	Notst4			mov     CfdcTstCtl,WriteSector		CALL	WriteSectorTstNotst4:	        TEST	[bx].fdcTstCtl, ReadSector ;ReadPat test		JZ	Notst8			mov     CfdcTstCtl,ReadSector		CALL	ReadSectorTst	Notst8:	       TEST	[bx].fdcTstCtl, WrtDelSector ;WriteDelSector test		JZ	Notst10			mov     CfdcTstCtl,WrtDelSector		CALL	WrtDlSectorTst		Notst10:	TEST	[bx].fdcTstCtl, RdDelSector ;WriteReadDelSector test		JZ	NoerrorRet					mov     CfdcTstCtl,RdDelSector		CALL	RdDlSectorTstNoerrorRet:     RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;			*  FDD Not Connected Test...  *;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;FDDMotorOn = 02000H;FDDInUse   = 01000H;             ------;	      03000H	For etch 1;Speed	    =   400H	low speed , add for etch2 only****** ;Drive	    =    10H    Drive Select 1, add for etch2 only******;Data Rate  =     8H    5 1/4", add for etch2 only******;DrivePreComp=    2H	PreComp 0, add for etch2 only******;             ------;	      0341AH	For etch 2 only******FDDnotConnectedTst:		MOV	AX,RstFDCtlr		;turn on FDC reset		CALL    ExtOffWrRstCtlReg	;		MOV	Al, [bx].fdcDriveType		CMP	Al, 4		JNZ	SetContReg12MB		MOV	AX, FDDMoterOn+FDDInUse+FDDSpeed+FDDDriveRate+FDDDrive+FDDPreCom	        JMP	ContRegEndSetContReg12MB:		MOV	AX, FDDMoterOn+FDDInUse+FDDDrive+FDDPreCom;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ContRegEnd:		Call    ExtOnWrCtlReg				CALL	SetFlpVectors		MOV	CX, 0FFFFH		;Do delayResetDelay:	LOOP	ResetDelay			MOV	AX, RstFDCtlr		CALL    ExtOnWrRstCtlReg	;		MOV	CX, 010H		;Do long delay		CALL	WaitForInterrupt	;		CALL	GetInterruptStatus	;Clear FDC stack;Initialize Fdc	send a Sense Interrupt Status command which will clear the int;latch and then Specify and recalibrate			;InitializeFdc:		CALL	NoInterruptStatus; verify termination of cmd execution		CALL	Specify			;Set up controller parameters                dec	[bx].fdcLastPass		jnz	FDDnotConnectedTst	;loop till fdcLastPass = 0		RET		;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ;;			~~~~~~~~~~~~~~~~~~~~~~~~~~;			*  RECALIBRATE TEST...   *;			~~~~~~~~~~~~~~~~~~~~~~~~~~;RecalTst:       Call    SetCurrentAddressRecalUnit:      CALL	Recalibrate		CALL	ExtDoRunTimeWork	;allow keyboard control		Call    CheckUnit		pop ax		TEST ax,MoreUnits		jnz RecalUnit		dec	[bx].fdcLastPass		jnz	RecalTst		;loop till fdcLastPass = 0		RET		              ;  ORG 	TestCodeLoc1				;			~~~~~~~~~~~~~~~~~~~~~~~~;			*       READ ID...     *;			~~~~~~~~~~~~~~~~~~~~~~~~;;Use the Cylinder and Head presently set up;; First seek to the desired cylinderReadIDTst:	Call    SetCurrentAddressReadIDSeek:     CALL	Seek			;Do the seekReadIDHead:	CALL	ReadIDExec;	        Check for error		CALL	CheckStatus		CALL	NoInterruptStatus	;Check for proper cmd termination		CALL	ExtDoRunTimeWork	;allow keyboard control		Call    GetNextAddress		pop ax		TEST ax,MoreCylinders+MoreUnits		jnz ReadIDSeek		TEST ax,MoreHeads		jnz ReadIDHead		dec	[bx].fdcLastPass		jnz	ReadIDTst		;loop till fdcLastPass = 0		RET		; ;;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;			*     WRITE A DELETED SECTOR...   *;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;WrtDlSectorTst: Call    SetCurrentAddress                CALL	ClearBuff		;WrtDlSeek:      CALL	Seek			;Do the seekWrtDlHead:	CALL	ExtDoRunTimeWork	;allow keyboard control		CALL	GenWrDataBuff		;Generate random write-buffer data	        CALL	WriteOneDeletedSector	;Write a sector		CALL	CheckStatus		;go check return codes		CALL	NoInterruptStatus	;Check for proper cmd termination		Call    GetNextAddress		pop ax		TEST ax,MoreCylinders+MoreUnits		jnz WrtDlSeek		TEST ax,MoreHeads		jnz WrtDlHead		dec	[bx].fdcLastPass		jnz	WrtDlSectorTst		;loop till fdcLastPass = 0		RET						RdDlSectorTst:  Call    SetCurrentAddressRdDlSeek:       CALL	Seek			;Do the seekRdDlHead:	CALL	ExtDoRunTimeWork	;allow keyboard control		CALL	ClearBuff	                CALL	ReadOneDeletedSector	;Read a sector		CALL	CheckStatus		;go check return codes		CALL	NoInterruptStatus	;Check for proper cmd termination		MOV	Al, fdcstatusST2	;Check for error		TEST	Al, 40H			;Check CM flag=1		JZ	RDelCnt3		;Status Error, get out		JMP	Error7			;RDelCnt3:	CALL	CmprDataBuff		;Compare the actual data		Call    GetNextAddress		pop ax		TEST ax,MoreCylinders+MoreUnits		jnz RdDlSeek		TEST ax,MoreHeads		jnz RdDlHead		dec	[bx].fdcLastPass		jnz	WrtDlSectorTst		;loop till fdcLastPass = 0		RET		;--------------------;Error7:		MOV	al, 07h	;CMFlagResetOnSkipReadDel, error log		JMP	FdcError		;;;--------------------				;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;			*     WRITE/READ A TRACK...   *;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~WriteSectorTst: Call    SetCurrentAddress                CALL	ClearBuff		;WriteSectorSeek:CALL	Seek			;Do the seekWriteSectorHead:CALL	ExtDoRunTimeWork	;allow keyboard control		CALL	GenWrDataBuff		;Generate random write-buffer data	        CALL	WriteOneSector	;Write a sector		CALL	CheckStatus		;go check return codes		CALL	NoInterruptStatus	;Check for proper cmd termination		Call    GetNextAddress		pop ax		TEST ax,MoreCylinders+MoreUnits		jnz WriteSectorSeek		TEST ax,MoreHeads		jnz WriteSectorHead		dec	[bx].fdcLastPass		jnz	WriteSectorTst		;loop till fdcLastPass = 0		RET						ReadSectorTst:  Call    SetCurrentAddressReadSectorSeek: CALL	Seek			;Do the seekReadSectorHead:	CALL	ExtDoRunTimeWork	;allow keyboard control		CALL	ClearBuff	                CALL	ReadOneSector	;Read a sector		CALL	CheckStatus		;go check return codes		CALL	NoInterruptStatus	;Check for proper cmd termination		CALL	CmprDataBuff		;Compare the actual data		Call    GetNextAddress		pop ax		TEST ax,MoreCylinders+MoreUnits		jnz ReadSectorSeek		TEST ax,MoreHeads		jnz ReadSectorHead		dec	[bx].fdcLastPass		jnz	ReadSectorTst		;loop till fdcLastPass = 0		RET		; ;;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;			*     FORMAT DISK...   *;			~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~;; First seek to the desired cylinderFormatTst:	Call    SetCurrentAddressFormatSeek:     CALL	Seek			;Do the seekFormatHead:	CALL	GenFormatData                CALL	ExtDoRunTimeWork	                CALL	FormatOneCyc		CALL	CheckStatus		CALL	NoInterruptStatus	;Check for proper cmd termination		CALL	ExtDoRunTimeWork	;allow keyboard control		Call    GetNextAddress		pop ax		TEST ax,MoreCylinders+MoreUnits		jnz FormatSeek		TEST ax,MoreHeads		jnz FormatHead		dec	[bx].fdcLastPass		jnz	FormatTst		;loop till fdcLastPass = 0		RET		;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ;				SUBROUTINES;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; LongDelay:	MOV	DX, CX			;CX holds the long delay count		MOV	CX, 0FFFFHWait2:		LOOP	Wait2		MOV	CX, DX		LOOP	LongDelay		RET;;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GetInterruptStatus:				;Sense interrupt Status Command		MOV	CX,5			;GetIrqStat:					MOV	Al, 08h			;load sense interrupt status command		CALL	FDCLoad			;Wait for Ready & Output cmd		CALL	FDCUnload		;Wait for Ready & Input cmd		CMP	Al, 080h		;Empty? Invalid Commad?		JE	GetInterruptStatusDone	;		MOV	fdcstatusST0,Al		;store ST0 Status		CALL	FDCUnload		;Read PCN		MOV	fdcstatusC,Al		;store PCN		Loop	GetIrqStat		;loop till done or timeout		JMP	Error4GetInterruptStatusDone:		RET		Error4:		MOV	al, 4h	;FDC Stack error log		JMP	FdcError		;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ NoInterruptStatus:				;Sense interrupt Status Command		MOV	Al, 08h			;load sense interrupt status command		CALL	FDCLoad			;Wait for Ready & Output cmd		CALL	FDCUnload		;Wait for Ready & Input cmd		CMP	Al, 080h		;Empty? Invalid Commad?		JE	NoInterruptStatusDone	;		MOV	fdcstatusST0,Al		;Clear FDC stack		CALL	FDCUnload		;Read PCN		MOV	fdcstatusC,Al		;store PCN		JMP	Error4NoInterruptStatusDone:		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FDCLoad:	CALL	RdyForOUT		;Wait for FDC to be ready		OUT	FDCDataReg, Al		;write byte from Al		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FDCUnload:	CALL	RdyForIN		;Wait for FDC to be ready		IN	Al, FDCDataReg		;Read byte into Al		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RdyForOUT:	PUSH 	CX			;Wait a little while		PUSH 	AX			;Wait a little while		MOV 	CX, 028H		;RdyForOUTWait:	LOOP 	RdyForOUTWait		;		XOR	CX,CX			;clear timeout counterRdyForOUTloop:	IN	Al, FDCStatusReg	;Read Main Status		AND	Al, 0C0h		;Request from master to send data		CMP	Al, 080h		;wait for data request		JE	RdyForOUTDone		;ret if FDC ready		LOOP 	RdyForOUTloop		;loop till done or timeout		JMP 	Error5			;timeoutRdyForOUTDone:	POP	AX			;restore AX		POP	CX			;restore CX		RETError5:			MOV 	al, 05h	;Log HERE		JMP	FdcError		;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ RdyForIN:	PUSH 	CX			;Wait a little while		PUSH 	AX			;Wait a little while		MOV 	CX, 028H		;RdyForINWait:	LOOP 	RdyForINWait		;		XOR	CX,CX			;clear timeout counterRdyForINloop:	IN	Al, FDCStatusReg	;Read Main Status		AND	Al, 0C0h		CMP	Al, 0C0h		;wait for data request		JE	RdyForINDone		;ret if FDC ready		LOOP 	RdyForINloop		;loop till done or timeout		JMP 	Error8			;timeoutRdyForINDone:	POP	AX			;restore CX		POP	CX			;restore CX		RETError8:  	MOV	al, 08h	;FDC not sending Status, error log		JMP	FdcError		;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Specify:		MOV	Al, fdcSpecify		; specify Op code		CALL	FDCLoad		MOV	Al, StepRate+HUT	; SRT @6mS (neg) + HUT @16mS		CALL 	FDCLoad		MOV	Al, DmaMode+HLTime	; DMA mode+ HLTime @ 20mS		CALL	FDCLoad		CALL	NoInterruptStatus		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Recalibrate:		MOV	Al, 0Fh			;step out first by doing a seek		CALL	FDCLoad			;Output Head and Drive number		MOV	Al, 0			;		CALL	FDCLoad			;Output Hd & Unit number		MOV	Al, 1			;		CALL	FDCLoad			;Output cylinder number		MOV	CX, 010H		;Do long delay		CALL	WaitForInterrupt		MOV	Al, 08h		;load sense interrupt status command		CALL	FDCLoad			;Wait for Ready & Output cmd		CALL	FDCUnload		;Wait for Ready & Input status		CALL	FDCUnload		;Read PCN		CALL	NoInterruptStatus	;Check for proper cmd termination		MOV	Al, fdcRecal		;Recal Op code		CALL	FDCLoad		MOV	Al, 00h			;		CALL	FDCLoad			;00= Drive Number0		MOV	CX, 010H		;Do long delay		CALL	WaitForInterrupt		MOV	Al, [bx].fdcDriveType		CMP	Al, 4H		JZ	RecalCont		MOV	Al, fdcRecal		;Recal Op code		CALL	FDCLoad		MOV	Al, 00h			;		CALL	FDCLoad			;00= Drive Number0		MOV	CX, 010H		;Do long delay		CALL	WaitForInterruptRecalCont:		MOV	Al, 08h			;load sense interrupt status command		CALL	FDCLoad			;Wait for Ready & Output cmd		CALL	FDCUnload		;Wait for Ready & Input status		AND	Al, 0FCh		;		CMP	Al, 020h		;a Recalibrate was completed		JNE	Error6			;		CALL	FDCUnload		;Read PCN		CMP	Al, 0			;store PCN		JNE	Error6			;		CALL	NoInterruptStatus	;Check for proper cmd termination		CALL	SenseDriveStatus	;		TEST	Al, 10h			;check for status of Track 0 signal		JZ	Error6			;Track 0 should be 1		CALL	NoInterruptStatus	;Check for proper cmd termination				RETError6:		MOV	al, 06h	;Recalibrate error log		JMP	FdcError		;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Seek:		PUSH	AX		MOV	Al, 0Fh		CALL	FDCLoad			;Output Head and Drive number		MOV	Al, 0			;		CALL	FDCLoad			;Output Hd & Unit number		MOV	Al, [bx].fdcCCylinder ;		CALL	FDCLoad			;Output cylinder number		MOV	CX, 010H		;Do long delay		CALL	WaitForInterrupt		MOV	Al, 08h		;load sense interrupt status command		CALL	FDCLoad			;Wait for Ready & Output cmd		CALL	FDCUnload		;Wait for Ready & Input Status		AND	Al, 0FCh		;		CMP	Al, 020h		;a seek was completed		JNE	Error1			;		CALL	FDCUnload		;Read PCN		CMP	Al, [bx].fdcCCylinder ;Cmp PCN		JNE	Error1			;		CALL	NoInterruptStatus	;Check for proper cmd termination		CALL	SenseDriveStatus	;		POP	AXSeekTestOk:	RETError1:  	MOV	Al, 01h			;Seek Error Log		JMP	FdcError;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ReadIDExec:		MOV	Al, ReadIDCmd				OR	Al, 40H			;add the density		CALL	FDCLoad			;"ReadID" command		MOV	Al, [bx].fdcCHead	;		CALL	FDCLoad			;00= Head0, Drive0;		READ ALL THE STATUS...		MOV	CX,7			;status byte count		CALL	FDCResult		;Read result field		RET				;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ SenseDriveStatus:		MOV	Al, 04h			;load sense drive status command		CALL	FDCLoad			;Wait for Ready & Output cmd		MOV	Al, 0			;		CALL	FDCLoad			;Output Hd & Unit number		CALL	FDCUnload		;Wait for Ready & Input Status		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~SetCurrentAddress:MOV	Al, [bx].fdcSUnit	;		MOV	[bx].fdcCUnit, Al		;		MOV	Al, [bx].fdcSCylinder ;		MOV	[bx].fdcCCylinder, Al		;		MOV	Al, [bx].fdcSHead	;		MOV	[bx].fdcCHead, Al		;		MOV	Al, [bx].fdcSSector	;		MOV	[bx].fdcCSector, Al		;		MOV	Al, [bx].fdcSData	;		MOV	[bx].fdcCData, Al		;		MOV	FIntCount, 1		;		MOV	[bx].fdcFault, 0	;copy present test performed		MOV	Al, [bx].fdcPass	;		MOV	[bx].fdcLastPass, Al	;copy present Pass performed	        MOV	[bx].fdcRetries,0	;clear error count		Ret;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ CheckStatus:		MOV	Al, fdcstatusST0	;Check for error		TEST	Al, 0C0H		;		JNZ	IOError			;Status Error, get outTestSt1:		MOV	Al, fdcstatusST1	;Check for error		TEST	Al, 0FFH		;		JNZ	IOError			;Status Error, get outTestSt2:		MOV	Al, fdcstatusST2	;Check for error		TEST	Al, 12H			;		JNZ	IOError			;Status Error, get out		TestSt3:        cmp     CfdcTstCtl,FormatCyc		JE	GoodIO		MOV	Al, fdcstatusC		;Check for error		CMP	Al, [bx].fdcCCylinder ;		JE	TestSt4TestSt3Cont: 	MOV	Al, fdcMaxSector		CMP	[bx].fdcESector,Al		JE	TestSt4			;		JMP	Error2			;Status Error, get outTestSt4:        		MOV	Al, fdcstatusH		;Check for error		CMP	Al, [bx].fdcCHead			;		JNE	Error2			;Status Error, get outTestSt5:		MOV	Al, fdcstatusN		;Check for error		CMP	Al, [bx].fdcSectorLength ;		JE	GoodIO			;return if ret codes are good	;IOError:					;Status Error		MOV	Al,[bx].fdcRetries		;go check rap sheet		INC	Al			; bump counter		CMP	AL,6			;is this the 3rd offense ?		JNZ	TstCnt3			; give up after third attempt		JMP	Error2TstCnt3:	MOV	[bx].fdcRetries,Al	;store new count		POP	AX			;get return address		SUB	AX,9			;point ret address for retry		CMP	CfdcTstCtl,ReadID		je     NewRet		SUB	AX,6			;point ret address for retryNewRet:		PUSH	AX			;put ret address back on stack		CALL	Recalibrate		;do a recalibrate		RET				;go do seek & retryGoodIO:		MOV	[bx].fdcRetries,0	;clear error count		RET		       		;life goes onError2:		MOV	al, 2h	;Write/ReadStatus, Error Log		JMP	FdcError		;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 		GetNextAddress:	MOV	Al, [bx].fdcCHead	;		CMP	Al, [bx].fdcEHead	;		JE	CheckCylinder		INC 	[bx].fdcCHead		MOV	AX, MoreHeads	;		JMP 	Done				CheckCylinder:	MOV	Al, [bx].fdcSHead	;		MOV	[bx].fdcCHead,al	;		MOV	Al, [bx].fdcCCylinder	;		CMP	Al, [bx].fdcECylinder	;		JE	CheckUnit		INC 	[bx].fdcCCylinder		MOV	AX, MoreCylinders	;		JMP 	Done		CheckUnit:	MOV	Al, [bx].fdcSCylinder	;		MOV	[bx].fdcCCylinder,al	;		MOV	Al, [bx].fdcCUnit	;		CMP	Al, [bx].fdcEUnit	;		JE	AllDone		INC 	[bx].fdcCUnit		MOV	AX, MoreUnits	;		JMP 	Done AllDone:	MOV	AX, 0 Done:		pop 	dx 		push 	ax		push 	dx 		RET;--------------------------------------------------;  To compare the read data buffer against the written data bufferCmprDataBuff:	MOV	Cl, [bx].fdcCUnit	;add the Unit number			MOV	ch, [bx].fdcCCylinder		;	Sector		MOV	dl, [bx].fdcCHead	;		MOV	dh, [bx].fdcCSector	;		MOV	AH, [bx].fdcDataAndErrCtl                and     ah,fdcIncDataByte		shr     ah,1                MOV	Al, [bx].fdcCData	;		test    [bx].fdcDataAndErrCtl,fdcNoheader		jnz      CmprNoLableCmprLable:       		MOV	BX, fdcDataBuff		;		CmprNextSec:	CMP	cl, BYTE PTR ES:[BX]		;		JE	TstCnt4			;		jmp	Error3			;Log HERETstCnt4:	INC	BX			;		CMP	ch,BYTE PTR ES:[BX]		;		JE	TstCnt5			;		jmp	Error3			;Log HERETstCnt5:	INC	BX			;		CMP	dl, BYTE PTR ES:[BX]		;		JE	TstCnt6			;		jmp	Error3			;Log HERETstCnt6:	INC	BX			;		CMP	dh, BYTE PTR ES:[BX]		;		JE	TstCnt7			;		jmp	Error3			;Log HERETstCnt7:	INC	BX			;                MOV	CX, 1FCH		;		CmprDataByte:   CMP	Al, BYTE PTR ES:[BX]	; test data		JE	TstCnt9			;		jmp	Error3			;Log HERETstCnt9:	INC	BX			;		ADD	Al, ah			; generate next data byte		LOOP	CmprDataByte		;		PUSH	BX		MOV	BX,[SI].TCBPointer	;Get Index to Test Control Block                test    [bx].fdcDataAndErrCtl,fdcIncDataSec		jz      CmprNext		inc     [bx].fdcCDataCmprNext:       cmp     dh,[bx].fdcESector  		je      CmprDone 		inc     dh		MOV	Al, [bx].fdcCData	;		POP     BX		jmp     CmprNextSecCmprDone:	pop	BX		MOV	BX,[SI].TCBPointer	;Get Index to Test Control Block		RET		CmprNoLable:    mov     al, [bx].fdcDataAndErrCtl		MOV	BX, fdcDataBuff		;                test    al,fdcDiagPat		jnz      CmprDiag1CmprNextSec1:	MOV	CX, 200H		;CmprDataByte1:  CMP	Al, BYTE PTR ES:[BX]	; test data		JE	TstCntA			;		jmp	Error3			;Log HERETstCntA:	INC	BX			;		ADD	Al, ah			; generate next data byte		LOOP	CmprDataByte1		;		PUSH	BX		MOV	BX,[SI].TCBPointer	;Get Index to Test Control Block                test    [bx].fdcDataAndErrCtl,fdcIncDataSec		jz      CmprNext1		inc     [bx].fdcCDataCmprNext1:      cmp     dh,[bx].fdcESector  		je      CmprDone 		inc     dh		MOV	Al, [bx].fdcCData	;		POP     BX		jmp     CmprNextSec1		CmprDiag1:	MOV	CX, 10H		;CmprDiagByte1:  MOV	ax, 00000H	;		call CmprDiag		MOV	ax, 0FFFFH	;		call CmprDiag		MOV	ax, 05555H	;		call CmprDiag		MOV	ax, 0AAAAH	;		call CmprDiag		MOV	ax, 03333H	;		call CmprDiag		MOV	ax, 0CCCCH	;		call CmprDiag		MOV	ax, 00101H	;		call CmprDiag		MOV	ax, 0FEFEH	;		call CmprDiag         	LOOP	CmprDiagByte1		;				PUSH	BX		MOV	BX,[SI].TCBPointer	;Get Index to Test Control Block                cmp     dh,[bx].fdcESector  		je      CmprDiagDone 		inc     dh		POP     BX		jmp     CmprDiag1		CmprDiagDone:	pop	BX		MOV	BX,[SI].TCBPointer	;Get Index to Test Control Block		RET	CmprDiag:       xor	ah,BYTE PTR ES:[BX] 	;		INC	BX		xor	al,BYTE PTR ES:[BX] 		INC	BX		cmp     ax,0		jnz    CmprDiagErr		ret			CmprDiagErr:	jmp	Error3;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Error3:		MOV	al, 03h	;Write/read data Test failed, error log		JMP	FdcError		;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ClearBuff:	PUSH	BX			;		MOV	BX, fdcDataBuff		;		MOV	CX, 200H		;		MOV	Al,0			;ClearDataByte:		MOV	BYTE PTR ES:[BX], Al		;		INC	BX			;		LOOP	ClearDataByte		;		POP	BX			;		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GenWrDataBuff:	cmp	[bx].fdcRetries,0                je      NotARetry		ret		NotARetry:	MOV	Cl, [bx].fdcCUnit	;add the Unit number			MOV	ch, [bx].fdcCCylinder		;	Sector		MOV	dl, [bx].fdcCHead	;		MOV	dh, [bx].fdcCSector	;                MOV	AH, [bx].fdcDataAndErrCtl                and     ah,fdcIncDataByte		shr     ah,1                MOV	Al, [bx].fdcCData	;		test    [bx].fdcDataAndErrCtl,fdcNoheader		jnz      GenNoLableGenLable:       MOV	BX, fdcDataBuffGenNextSec:	MOV	BYTE PTR ES:[BX], cl		;	Cylinder,		INC	BX			;	Head,		MOV	BYTE PTR ES:[BX], ch		;		INC	BX			;		MOV	BYTE PTR ES:[BX], dl		;		INC	BX			;		MOV	BYTE PTR ES:[BX], dh		;		INC	BX			;		MOV	CX, 1FCH				GenWrDataByte:  MOV	BYTE PTR ES:[BX], Al		;		INC	BX		ADD	Al, ah			;		LOOP	GenWrDataByte		;		PUSH	BX		MOV	BX,[SI].TCBPointer	;Get Index to Test Control Block                test    [bx].fdcDataAndErrCtl,fdcIncDataSec		jz      GenNext		inc     [bx].fdcCDataGenNext:        cmp     dh,[bx].fdcESector  		je      GENDone 		inc     dh	        MOV	Al, [bx].fdcCData	;		POP     BX		jmp     GenNextSecGENDone:	pop	BX		MOV	BX,[SI].TCBPointer	;Get Index to Test Control Block		RET		GenNoLable:     mov     al, [bx].fdcDataAndErrCtl		MOV	BX, fdcDataBuff                test    al,fdcDiagPat		jnz      GenDiag1		GenNextSec1:	MOV	CX, 200HGenWrDataByte1: MOV	BYTE PTR ES:[BX], Al		;		INC	BX		ADD	Al, ah			;		LOOP	GenWrDataByte1		;		PUSH	BX		MOV	BX,[SI].TCBPointer	;Get Index to Test Control Block                test    [bx].fdcDataAndErrCtl,fdcIncDataSec		jz      GenNext1		inc     [bx].fdcCDataGenNext1:       cmp     dh,[bx].fdcESector  		je      GENDone 		inc     dh		MOV	Al, [bx].fdcCData	;		POP     BX		jmp     GenNextSec1		GenDiag1:	MOV	CX, 10HGenDiagBytes:   MOV	ax, 00000H	;		call    PutDiag		MOV	ax, 0FFFFH	;		call    PutDiag		MOV	ax, 05555H	;		call    PutDiag		MOV	ax, 0AAAAH	;		call    PutDiag		MOV	ax, 03333H	;		call    PutDiag		MOV	ax, 0CCCCH	;		call    PutDiag		MOV	ax, 00101H	;		call    PutDiag		MOV	ax, 0FEFEH	;		call    PutDiag		LOOP	GenDiagBytes		;		PUSH	BX		MOV	BX,[SI].TCBPointer	;Get Index to Test Control Block                cmp     dh,[bx].fdcESector  		je      GENDDone 		inc     dh		POP     BX		jmp     GenDiag1		GENDDone:	pop	BX		MOV	BX,[SI].TCBPointer	;Get Index to Test Control Block		RET		PutDiag:        MOV	BYTE PTR ES:[BX], ah	;		INC	BX		MOV	BYTE PTR ES:[BX], al		INC	BX		ret		;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FDCResult:	PUSH	BX			;save TCB pointer		PUSH	CX		MOV	CX, 010H		;Do long delay		CALL	WaitForInterrupt		POP	CX		MOV	BX,Result		;point to result fieldFDCResultLoop:		CALL	FDCUnload		;Wait for FDC to be ready		MOV	BYTE PTR [BX],Al	;put byte in result field		INC	BX			;inc pointer		LOOP	FDCResultLoop		;loop till done		POP	BX			;retrieve TCB pointer		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FDCGo:		MOV	BX,UCB			;point to control blockFDCGoLoop:		MOV	Al, BYTE PTR [BX]		;get command byte		CALL	FDCLoad			;Wait for FDC to be ready		INC	BX			;in pointer		LOOP	FDCGoLoop		;loop till done		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ;	 AX = Byte count ;	 BX = Destination Buffer SetUpDMAIn:		PUSH	AX			;save byte count		PUSH	AX			;save byte count		MOV	DX, i186DMA0LSPAddr	;Point to Lower Source Reg		MOV	AX, FDCDataReg+4	;Point to Lower Source Reg		OUT	DX, AX			;write Lower Source 		INC	DX			;Point to Upper Source Reg		INC	DX			;		XOR	AX, AX			;clear AX		OUT	DX, AX			;write Upper Source		MOV	AX,BX			;save byte count		INC	DX			;Point to Lower Dest Reg		INC	DX			;		OUT	DX, AX			;write Lower Dest 		XOR	AX, AX			;clear AX		INC	DX			;Point to Upper Dest Reg		INC	DX			;		OUT	DX, AX			;write Upper Dest		POP	AX			;get byte count		INC	DX			;Point to TC reg		INC	DX			;		OUT	DX, AX			;write Terminal Count		INC	DX			;Point to control reg		INC	DX			;		MOV	AX, 0A266h		;set parms		OUT	DX, AX			;write control reg;	now set up timer 1 to gen TC for FDC 		JMP	SetupTimer;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ; AX = Byte count ; BX = Source Buffer SetUpDMAOut:		PUSH	AX			;save byte count		PUSH	AX			;save byte count		MOV	AX,BX			;save byte count		MOV	DX, i186DMA0LSPAddr	;Point to Lower Source Reg		OUT	DX, AX			;write Lower Source 		INC	DX			;Point to Upper Source Reg		INC	DX			;		XOR	AX, AX			;write Upper Source		OUT	DX, AX			;write Upper Source		INC	DX			;Point to Lower Dest Reg		INC	DX			;		MOV	AX, FDCDataReg+4	;write Lower Dest 		OUT	DX, AX			;write Lower Dest 		XOR	AX, AX			;clear AX		INC	DX			;Point to Upper Dest Reg		INC	DX			;		OUT	DX, AX			;write Upper Dest		POP	AX			;get byte count		INC	DX			;Point to TC reg		INC	DX			;		OUT	DX, AX			;write Terminal Count		INC	DX			;Point to control reg		INC	DX			;		MOV	AX, 016A6h		;set parms		OUT	DX, AX			;write control reg;	now set up timer 1 to gen TC for FDC SetupTimer:		MOV	DX, i186Timer1CountAAddr ;Point to Max Count A		POP	AX			;get byte count		OUT	DX, AX			;write byte Count		ADD	DX, 2			;Point to control reg		OUT	DX, AX			;write byte Count		ADD	DX, 2			;Point to control reg		MOV	AX, 0C007h		;set parms		OUT	DX, AX			;write control reg		XOR	AX,AX		SUB	DX,6		OUT	DX,AX		MOV	AX, AllowTmrTC	;set entmr1TC		Call    ExtOnWrCtlReg		;write control reg		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ReadOneDeletedSector:		MOV	Al, 0CH			;			jmp   ReadOneSectorPlus;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ReadOneSector:			MOV	Al, fdcReadCmd		;read commandReadOneSectorPlus:				;special read hook			PUSH	CX		OR	Al, 40H			;add the density		OR	Al, [bx].fdcSkipDeletedData ;add skip deleted sector		MOV	Comm1, Al 		;		jmp CommonTransfer		;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 				CommonTransfer:	MOV	Al, [bx].fdcCHead	;Output head and unit number		SAL	Al,2			;adjust Al		OR	Al, [bx].fdcCUnit	;add the Unit number			MOV	Comm2, Al 		;		MOV	Al, [bx].fdcCCylinder	;Output Cylinder number		MOV	Comm3, Al 		;		MOV	Al, [bx].fdcCHead	;Output Head number again		MOV	Comm4, Al 		;		MOV	Al, [bx].fdcCSector	;Output Sector number		MOV	Comm5, Al 		;		MOV	Al, [bx].fdcSectorLength ;Output Sector length		MOV	Comm6, Al                 XOR	DX, DX			;		CMP	Al, 00H			;None standard byte count		JNE	CntNotEqual128		;		MOV	Cl, 80H	;		JMP	CntDone		;CntNotEqual128:CMP	Al, 01H			;Set up for 256 byte transfer		JNE	CntNotEqual256		;		MOV	DX, 0100H		;		JMP	CntDone		;CntNotEqual256:CMP	Al, 02H			;Set up for 512 byte transfer		JNE	CntNotEqual512	;		MOV	DX, 0200H		;		JMP	CntDone		;CntNotEqual512: MOV	DX, 0400H		CntDone:        		MOV	Al, fdcMaxSector	;Output Last Sector number		MOV	Comm7, Al 		MOV	Al, fdcRWGapLength	;Output Gap between sectorsRWGapLoad:	MOV	Comm8, Al 		;		MOV	Al, 80H	                ;Output Data transfered if N=0		MOV	Comm9, Al 		;DoCntTimesSec:	MOV	Al, [bx].fdcCSector	;Output Sector number		MOV	CX, DX	CheckCnt:	CMP     AL,fdcMaxSector		je      CntOk		ADD     CX,DX		INC     AL		JMP     CheckCntCntOk:		MOV	AX,CX			;get byte count		PUSH	BX		CMP     CfdcTstCtl, WriteSector		je      DoOut		CMP     CfdcTstCtl, WrtDelSector		je      DoOut		MOV	BX,fdcDataBuff		;pointer to data buffer		CALL	SetUpDMAIn		;set up DMA for inbound data		jmp     CommonEndDoOut:	        MOV	BX,fdcDataBuff		;pointer to data buffer		CALL	SetUpDMAOut		;set up DMA for outbound dataCommonEnd:	MOV	CX,9			;command byte count		CALL	FDCGo			;start FDC		POP	BX			;;		READ ALL THE STATUS...		MOV	CX,7			;status byte count		CALL	FDCResult		;Read result field		POP	CX		RET ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ WriteOneDeletedSector:		MOV	Al, 09h			;			jmp   	WriteOneSectorPlus;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ WriteOneSector:		MOV	Al, 05h			;Output Write CommandWriteOneSectorPlus:		PUSH	CX		PUSH	AX		CALL	SenseDriveStatus	;		TEST	Al, 40h			;check for Write protection signal		JZ	WrtOneS1		;No write protection, continue		JMP	Error9			;WrtOneS1:       POP	AX		OR	Al, 40H			;add the density		MOV	Comm1,Al		;move command byte to control block		jmp 	CommonTransfer;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Error9:		mov	al, 09h	;Floppy disk write protected, error log		JMP	FdcError		;		;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FormatOneCyc:   CALL	SenseDriveStatus	;		TEST	Al, 40h		;check for Write protection signal		JZ	FtOneS1		;No write protection, continue		JMP	Error9			;FtOneS1:	MOV	Al, 4Dh		;Output Format Command		MOV	Comm1,Al	;move command byte to control block		MOV	Al, [bx].fdcCHead ;Output head and unit number		SAL	Al,2			;adjust Al		OR	Al, [bx].fdcCUnit	;add the Unit number			MOV	Comm2,Al	;move command byte to control block		MOV	Al, [bx].fdcSectorLength ;Output Sector length			MOV	Comm3,Al	;move command byte to control block		MOV	Al, fdcMaxSector ;09H= IBM Output Sector Count		MOV	Comm4,Al	;move command byte to control block		MOV	Al, 050H		;50H= IBM Output gap length		MOV	Comm5,Al	;move command byte to control block		MOV	Al, 0F6H		;Output Data filler byte		MOV	Comm6,Al	;move command byte to control block;	Set up for DMA transfers count		XOR	CX, CX			;		MOV	Cl, fdcMaxSector	;		SAL	CX,2			MOV	AX,CX			;get byte count		PUSH	BX			;save TCB pointer		MOV	BX,fdcDataBuff		;pointer to data buffer		CALL	SetUpDMAOut		;set up DMA for outbound data		MOV	CX,6			;command byte count		CALL	FDCGo			;start FDC		POP	BX			;return TCB pointer;		READ ALL THE STATUS...		MOV	CX,7			;status byte count		CALL	FDCResult		;Read result field		RET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ GenFormatData:		PUSH	BX		MOV	dl, [bx].fdcCCylinder	;Output the cylinder number		MOV	dh, [bx].fdcCHead	;Output the Head number		MOV	cl, fdcMinSector		MOV	ch, [bx].fdcSectorLength ;		MOV	BX, fdcDataBuff		;FormatDataLoop:	MOV	ES:[BX], dl 		;		INC	BX			;		MOV	ES:[BX], dh 		;		INC	BX			;		MOV	ES:[BX], cl 		;		INC	BX			;		MOV	ES:[BX], ch 		;		INC	BX			;		CMP	Cl, fdcMaxSector	;		JE	TestDRQ4TC		;		INC	Cl			;Increment the sector number		JMP	FormatDataLoop		;TestDRQ4TC:	POP	BX			;		RET ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ i8272IrqHandler:		CLI				;disable interrupts		PUSHA		MOV	SI, ExtMFCBlock  ;Index to Monitor File Control Block		MOV 	BX, [SI].TCBPointer	;Get Index to TCB		MOV	AL, nonSpecificEOI	;Write an EOI command to the 							;Slave i8259, resets IS5		OUT	i8259SlaveAddr0, AL	;Clear Slave Controller		MOV	Al, 00BH		;OCW3 _ 00BH		OUT  	i8259SlaveAddr0, Al	;OCW3_ 00Bh		IN	Al, i8259SlaveAddr0	;Read Slave 8259 IS register		CMP	Al, 0		;Check if another interrupt is in service		JNZ	i8272IrqHandlerRet	;				MOV	AL, nonSpecificEOI	;Write an EOI command to the 			OUT	i8259MasterAddr0, AL 	;master i8259i8272IrqHandlerRet:		MOV	DX,i186Timer1MCWAddr	;write control reg		MOV	AX, FloppyDMATC		;set parms 		OUT	DX, AX			;to turn TC off		DEC	FIntCountIntCont:	POPA		STI				;Reenable the interrupts		IRET;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~WaitForInterrupt:		MOV	DX, CX			;CX holds the long delay count		MOV	CX, 0FFFFHWait3:		CMP	FIntCount,0		;INterrupt?		JE	IntOK		LOOP	Wait3		MOV	CX, DX		LOOP	WaitForInterrupt		CMP	FIntCount, 0		JL	ErrorA		JMP	ErrorBIntOK:		INC	FIntCount		;		RET		ErrorB:	        MOV	al, 0Bh	;No Interrupt error log		JMP	FdcError		;ErrorA:	        MOV	al, 0Ah	;Exess Interrupt error log		JMP	FdcError		;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ ;	Initialize Interrupt vectorsSetFlpVectors:	CLI				;mask all irqs		PUSH	BX			;Save TCB pointer		MOV AX,0                MOV  DS,AX		MOV  BX, ExtInterruptV1			MOV  AX, OFFSET MemParityInt			MOV  [bx].ParityV, AX		MOV	BX, ExtInterruptV2	;		MOV	AX, OFFSET i8272IrqHandler ;Set BX,AX to		MOV	[BX].FloppyV, AX 	;and the new IP		MOV  AX,CS		MOV  DS,AX		AND  [di].EnableIntC1C2,ParityIntEnAble         	AND	[di].EnableIntC1C2, FloppyIntEnable ;Enable Floppy Int		MOV ParityCount,0		CALL ExtReadMemStatus    	        CALL ExtReadMemStatus    	        CALL ExtReadMemStatus 		MOV	DX,i186Timer1MCWAddr	;write control reg		MOV	AX, FloppyDMATC		;set parms 		OUT	DX, AX			;to turn TC off	        CALL	ExtEnableInt		;Enable all Int in Monitor Control		POP	BX			;POP TCB pointer		STI				;Re-enable interrupts		Ret;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ MemParityInt:ClI					;disable interrupts	    PUSHA	    MOV	DI, ExtMCBlock ;Index to Monitor Control Block	    MOV	SI, ExtMFCBlock ;Index to Monitor File Control Block	    Mov bx,[si].TCBPointer ;Get Index to TCB	    TEST [bx].fdcDataAndErrCtl,fdcNoMemParity	    jnz MemParityIntRet 	    or [di].IOPFault,MemoryParityErrorMemParityIntRet:MOV  AL, nonSpecificEOI			;Reset IS0	    OUT  i8259MasterAddr0, Al		;  OCW2_ 061h 	    cmp ParityCount,00FFH	    JE MemParityRet            CALL ExtReadMemStatus	    inc  ParityCount    MemParityRet:POPA            STI					;Reanable the interrupts	    IRet ParityCount Dw 0	    ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ FdcError:	MOV	BX,[SI].TCBPointer                mov	[bx].fdcFault, Al	;		mov	[di].MesaFault, Al	;		MOV	SP, ExitPointer		;Restore stack pointer		MOV	Al, fdcstatusST0	;		MOV	[bx].fdcST0, Al		;		MOV	Al, fdcstatusST1	;		MOV	[bx].fdcST1, Al		;		MOV	Al, fdcstatusST2	;		MOV	[bx].fdcST2, Al		TEST	[bx].fdcDataAndErrCtl,fdcNoStop;		JnZ	ReStart		RET               ReStart:        jmp 	FDCStartFDCPreProcess:   		MOV 	BX,21			;read EEPROM floppy word		CALL 	ExtReadEEProm		CMP	AX,0			;check if no floppy configured		JNZ	FDCDoTCB		MOV	BX,[SI].TCBPointer	;set up FCB and TCB to skip tests		MOV	AL,[SI].TestNS		MOV	[SI].TestN,al		MOV	[SI].TestNE,al		OR	BYTE PTR [BX][1],SkipTestBit		RETFDCDoTCB:		MOV	Cl, 4			;juggle floppy EEPROM info		SHR	Ah, cl	   	mov 	dl,0		MOV	CX, 17 UpdateTCB:	  	mov 	[SI].TestN,dl 		PUSHA            	CALL 	ExtSetTCBPointer        	POPA	    	Mov 	bx,[si].TCBPointer	;Get Index to TCB	    	mov 	[bx].fdcDriveType, Ah		cmp 	ah,4			;check drive type		je     UpdateTCB2		test 	[bx].fdcTstCtl, FormatCyc		jnz     UpdateTCB1 		mov 	[bx].fdcESector, 15UpdateTCB1:	cmp     dl,6		jle     UpdateTCB2		mov 	[bx].fdcECylinder, 79		cmp     dl,11		jle     UpdateTCB2		mov 	[bx].fdcSCylinder, 79UpdateTCB2:	INC	Dl		LOOP	UpdateTCB		RetFDCFRUList: 	mov 	Bx,0 	  	mov 	BL, [SI].TestN	  	SHL 	Bx,1	  	mov 	ax, WORD PTR FDCList0 [bx]	  	CALL 	ExtMessageFDCFRUList1:	CALL	ExtDoRunTimeWork	   	cmp 	[di].CurrentInputByte,KSP	   	jne 	FDCFRUList1	   	Ret FDCList0 DW  0FA0EHFDCList1 DW  0A0FEHFDCList2 DW  0A02FHFDCList3 DW  0A0F2HFDCList4 DW  0A02FHFDCList5 DW  00A2FHFDCList6 DW  00A2FHFDCList7 DW  0FA0EHFDCList8 DW  0A0FEHFDCList9 DW  00A2FHFDCListA DW  0A0F2HFDCListB DW  0A0F2H					fdcDataBuff	DW StartData				ORG TestCodeLoc2		StartData	DB 400H*15 DUP (?)   ;Floppy Disk write data buffer (=1024 Bytes max/Sector)MonitorCode	ENDSEND
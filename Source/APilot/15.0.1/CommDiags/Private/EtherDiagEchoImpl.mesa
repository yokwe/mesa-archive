-- File: EtherDiagEchoImpl.mesa - last edit:-- AOF                  5-Jan-87 14:30:32-- BKI                 28-Oct-87 20:00:21-- SMA                  5-Feb-85 11:09:58-- Copyright (C) 1984, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  CommDiags USING [],  CommOnlineDiagnostics USING [    Detail, EchoDiagHandle, EchoDiagObject, EchoParams, EchoResults,    EtherErrorReason, EtherStatsInfo, EventReporter, Histogram, StatsIndices,    WordsInPacket],  EchoServer USING [GetCounters],  EthernetDriverFriends USING [EtherStatsInfo, GetEthernetStats],  Heap USING [systemZone],  NSBuffer USING [Buffer],  NSConstants USING [echoerSocket],  NSTypes USING [maxDataBytesPerEcho, wordsPerEchoHeader, wordsPerIDPHeader],  Process USING [    Abort, MsecToTicks, Pause, priorityNormal, SetPriority, TicksToMsec, Yield],  Router USING [GetDelayToNet, NetworkNonExistent, NoTableEntryForNet],  RouterInternal USING [FlushCacheEntry],  Socket USING [    AssignNetworkAddress, ChannelHandle, Create, Delete, GetPacket,    GetSendBuffer, GetStatus, NetworkAddress, nullChannelHandle, PutPacket,    ReturnBuffer, SetDestination, SetPacketWords, SetWaitTime, SocketStatus,    TimeOut],  System USING [    GetClockPulses, GetGreenwichMeanTime, GreenwichMeanTime,    MicrosecondsToPulses, NetworkAddress, NetworkNumber, nullSocketNumber,    PulsesToMicroseconds, SecondsSinceEpoch];EtherDiagEchoImpl: PROGRAM  IMPORTS EchoServer, EthernetDriverFriends, Heap, Process, Router,    RouterInternal, Socket, System  EXPORTS CommDiags =  BEGIN  Packet: TYPE = LONG POINTER TO ARRAY [0..0) OF WORD;  zone: UNCOUNTED ZONE = Heap.systemZone;  Seal: TYPE = MACHINE DEPENDENT{unsealed(0), handleSeal(123007B)};   EtherDiagError: PUBLIC ERROR [    reason: CommOnlineDiagnostics.EtherErrorReason] = CODE;      HistArray: TYPE = ARRAY [0.. HistSize) OF CommOnlineDiagnostics.Detail;  -- pulse is equivalent to two ticks.  twoTicks: LONG CARDINAL ¬ System.MicrosecondsToPulses[    LONG[Process.TicksToMsec[2]]*LONG[1000]];    EchoDiagHandle: PUBLIC TYPE = LONG POINTER TO EchoDiagObject;  EchoDiagObject: PUBLIC TYPE = RECORD [    cH: Socket.ChannelHandle ¬ Socket.nullChannelHandle,    echoer: PROCESS ¬ NIL,  -- the echoing process.    -- the receiving process that gets forked if client specifies    -- waitForResponse = FALSE.    echoReceiver: PROCESS ¬ NIL,    echoResults: LONG POINTER TO CommOnlineDiagnostics.EchoResults,    echoStarted: PUBLIC BOOLEAN ¬ FALSE,    endTime: LONG CARDINAL,  -- end of test (microsecs).    hist: PUBLIC CommOnlineDiagnostics.Histogram,    lastSend: LONG CARDINAL ¬ 0,  -- Last time a packet was sent (microsecs).    lastRec: LONG CARDINAL ¬ 0,   -- Last time a packet was received (microsecs)    pleaseStop: BOOLEAN ¬ FALSE,    respTime: LONG CARDINAL,  -- total response time during echo test.    startTime: LONG CARDINAL,  -- beginning of echo test (microsecs).    timeOfLastPollSSE: LONG CARDINAL,    target: System.NetworkAddress,  -- The echo server.    seqNum: CARDINAL ¬ 0,    statsInfoOld: StatsInfo,    seal: Seal ¬ unsealed];               -- EthernetStats types and variables.  EtherStats: TYPE = MACHINE DEPENDENT RECORD     [stats: CommOnlineDiagnostics.EtherStatsInfo];  StatsInfo: TYPE = LONG POINTER TO EtherStats;  statsInfoOld: PUBLIC StatsInfo;  HistSize: CARDINAL = 26;       -- length of our histogram.    Initialize: PROC [h: EchoDiagHandle, minSize: CARDINAL]    RETURNS [dataLen: CARDINAL] = {    -- initializes the variables used in statistics gathering    localAddr: System.NetworkAddress;    waitTime: CARDINAL;    h.timeOfLastPollSSE ¬ System.SecondsSinceEpoch[      System.GetGreenwichMeanTime[]];    h.respTime ¬ 0;    FOR ind: CommOnlineDiagnostics.StatsIndices IN [echoServerPkts..spare] DO       h.statsInfoOld.stats[ind] ¬ 0; ENDLOOP;    h.echoResults.totalTime ¬ h.echoResults.totalAttempts ¬ 0;    h.echoResults.successes ¬ h.echoResults.timeouts ¬ h.echoResults.late ¬ 0;    h.echoResults.late ¬ h.echoResults.unexpected ¬ h.echoResults.bad ¬ 0;    h.echoResults.avgDelayInMsecs ¬ h.echoResults.spare ¬ 0;    IF minSize < 2 THEN dataLen ¬ 0    ELSE dataLen ¬ minSize/2;  -- In words.        h.hist[0] ¬ [5, 0]; -- 5 msec or less    h.hist[1] ¬ [6, 0]; -- 5+ to 6 msec    h.hist[2] ¬ [7, 0]; -- 6+ to 7 msec    h.hist[3] ¬ [8, 0]; -- 7+ to 8 msec    h.hist[4] ¬ [9, 0]; -- 8+ to 9 msec    h.hist[5] ¬ [10, 0]; -- 9+ to 10 msec    h.hist[6] ¬ [15, 0]; -- 10+ to 15 msec    h.hist[7] ¬ [20, 0]; -- 15+ to 20 msec    h.hist[8] ¬ [25, 0]; -- 20+ to 25 msec    h.hist[9] ¬ [30, 0]; -- 25+ to 30 msec    h.hist[10] ¬ [35, 0]; -- 30+ to 35 msec    h.hist[11] ¬ [40, 0]; -- 35+ to 40 msec    h.hist[12] ¬ [45, 0]; -- 40+ to 45 msec    h.hist[13] ¬ [50, 0]; -- 45+ to 50 msec    h.hist[14] ¬ [60, 0]; -- 50+ to 60 msec    h.hist[15] ¬ [80, 0]; -- 60+ to 80 msec    h.hist[16] ¬ [100, 0]; -- 80+ to 100 msec    h.hist[17] ¬ [150, 0]; -- 100+ to 150 msec    h.hist[18] ¬ [200, 0]; -- 150+ to 200 msec    h.hist[19] ¬ [250, 0]; -- 200+ to 250 msec    h.hist[20] ¬ [300, 0]; -- 250+ to 300 msec    h.hist[21] ¬ [400, 0]; -- 300+ to 400 msec    h.hist[22] ¬ [500, 0]; -- 400+ to 500 msec    h.hist[23] ¬ [600, 0]; -- 500+ to 600 msec    h.hist[24] ¬ [1000, 0]; -- 600+ to 1 sec    h.hist[25] ¬ [2000, 0]; -- more than 1 sec    localAddr ¬ Socket.AssignNetworkAddress[];  -- set up the echoer socket    h.cH ¬ Socket.Create[localAddr.socket, 1, 5];    h.target.socket ¬ NSConstants.echoerSocket;    waitTime ¬ 4000*Router.GetDelayToNet[h.target.net !      Router.NoTableEntryForNet =>      {waitTime ¬ 1500;      CONTINUE}] + 1500;    Socket.SetWaitTime[h.cH, waitTime];    };  -- of Initialize  GetEthernetStats: PUBLIC PROC [    physicalOrder: CARDINAL              ¬ 1  -- i.e. 1st one --]    RETURNS [CommOnlineDiagnostics.EtherStatsInfo,       System.GreenwichMeanTime] =    BEGIN    stats: CommOnlineDiagnostics.EtherStatsInfo;    time: System.GreenwichMeanTime;    statsNew: EthernetDriverFriends.EtherStatsInfo;    -- gather EtherStats    statsNew ¬ EthernetDriverFriends.GetEthernetStats[physicalOrder      ! Router.NetworkNonExistent => GOTO noNet];    [stats[echoServerPkts], stats[EchoServerBytes]] ¬       EchoServer.GetCounters[];    [time] ¬ System.GetGreenwichMeanTime[];    stats[packetsRecv]          ¬ statsNew.packetsRecv;    stats[wordsRecv]            ¬ statsNew.wordsRecv;    stats[packetsMissed]        ¬ statsNew.packetsMissed;    stats[badRecvStatus]        ¬ statsNew.badRecvStatus;    stats[okButDribble]         ¬ statsNew.okButDribble;    stats[badCrc] 	        ¬ statsNew.badCrc;    stats[badAlignmentButOkCrc] ¬ statsNew.badAlignmentButOkCrc;    stats[crcAndBadAlignment]   ¬ statsNew.crcAndBadAlignment;    stats[packetTooLong]        ¬ statsNew.packetTooLong;    stats[overrun] 	        ¬ statsNew.overrun;    stats[idleInput] 	        ¬ statsNew.idleInput;    stats[packetsSent] 	        ¬ statsNew.packetsSent;    stats[wordsSent] 	        ¬ statsNew.wordsSent;    stats[badSendStatus]        ¬ statsNew.badSendStatus;    stats[tooManyCollisions]    ¬ statsNew.tooManyCollisions;    stats[lateCollisions]       ¬ statsNew.lateCollisions;    stats[underrun]	        ¬ statsNew.underrun;    stats[stuckOutput] 	        ¬ statsNew.stuckOutput;    stats[coll0]                ¬ statsNew.loadTable[0];    stats[coll1]                ¬ statsNew.loadTable[1];    stats[coll2]                ¬ statsNew.loadTable[2];    stats[coll3]                ¬ statsNew.loadTable[3];    stats[coll4]                ¬ statsNew.loadTable[4];    stats[coll5]                ¬ statsNew.loadTable[5];    stats[coll6]                ¬ statsNew.loadTable[6];    stats[coll7]                ¬ statsNew.loadTable[7];    stats[coll8]                ¬ statsNew.loadTable[8];    stats[coll9]                ¬ statsNew.loadTable[9];    stats[coll10]                ¬ statsNew.loadTable[10];    stats[coll11]                ¬ statsNew.loadTable[11];    stats[coll12]                ¬ statsNew.loadTable[12];    stats[coll13]                ¬ statsNew.loadTable[13];    stats[coll14]                ¬ statsNew.loadTable[14];    stats[coll15]                ¬ statsNew.loadTable[15];    stats[spare] 	        ¬ 0;    RETURN[stats, time];    EXITS noNet => ERROR EtherDiagError[noMoreNets];    END;  FreeHist: PUBLIC PROC [hist: CommOnlineDiagnostics.Histogram] =    BEGIN    zone.FREE[@hist.BASE];    END;   PreparePacket: PROC [h: EchoDiagHandle, dataLen, iterations: CARDINAL,    echoParms: CommOnlineDiagnostics.EchoParams, pktBody: Packet]    RETURNS [number: CARDINAL, pack: Packet] =    BEGIN    -- prepares echo packets before they're sent out. Sets packet length, fills in    -- the contents (via a call on FillPacket), and idles for the proper wait time    sufficientPause: BOOLEAN;    IF (echoParms.maxPacketSizeInBytes # echoParms.minPacketSizeInBytes) THEN      pktBody ¬ FillPacket[        dataLen, iterations, pktBody, echoParms.constant, echoParms.wordContents]  -- fill in packet contents    ELSE      pktBody ¬ FillPacket[        echoParms.minPacketSizeInBytes/2, iterations, pktBody, echoParms.constant,        echoParms.wordContents];    sufficientPause ¬ FALSE;    Wait[h, echoParms.minMsecsBetweenPackets];    number ¬ dataLen + 1;    pack ¬ pktBody;    END;  -- of PreparePacket  ReceiveResponse: PROC [    h: EchoDiagHandle, echoParm: CommOnlineDiagnostics.EchoParams,    iterations: CARDINAL, dataLen: CARDINAL,    eventReporter: CommOnlineDiagnostics.EventReporter,    net: System.NetworkNumber]    RETURNS [responded: BOOLEAN ¬ TRUE] =    BEGIN    -- called by Send Packet whenever waitForResponse = TRUE. Basic function is to    -- receive the echo response. Will also check packet contents via call on    -- CheckPacket    buf: NSBuffer.Buffer ¬ NIL;    pktBody: Packet ¬ NIL;    buf ¬ Socket.GetPacket[      h.cH !      Socket.TimeOut =>        BEGIN	-- increment number of timeouts.        h.echoResults.timeouts ¬ h.echoResults.timeouts + 1;  	IF eventReporter # NIL THEN eventReporter[timeout, LOOPHOLE[h]];        responded ¬ FALSE;	-- if we have not received responses for a while, maybe the route has        -- gone away - try flushing the cache so we solicit new info.	IF (h.echoResults.timeouts MOD 5) > 0 THEN          RouterInternal.FlushCacheEntry[net];        CONTINUE;        END; UNWIND => BEGIN responded ¬ FALSE; REJECT; END];    IF responded OR buf # NIL THEN      BEGIN  -- got a response      h.lastRec ¬ System.PulsesToMicroseconds[System.GetClockPulses[]];      pktBody ¬ @buf.ns.echoWords;      CheckPacket[        h, buf, pktBody, dataLen, echoParm, iterations, eventReporter];      END;    IF (buf # NIL) THEN Socket.ReturnBuffer[buf];  -- give the buffer back    END;  -- of ReceiveResponse  CheckPacket: PROCEDURE [    h: EchoDiagHandle, echoBuf: NSBuffer.Buffer, pakBody: Packet,    dataLen: CARDINAL, echoParm: CommOnlineDiagnostics.EchoParams,    repetitions: CARDINAL, eventReporter: CommOnlineDiagnostics.EventReporter] =    BEGIN    -- checks to see if the contents of an echo response are valid, i.e. are they    -- what they're supposed to be?    MatchData: PROC RETURNS[BOOLEAN] =      BEGIN      ones: WORD = 177777B;      zeroes: WORD = 0B;      MatchBytes: PROCEDURE [twoBytes: WORD, pack: Packet, max: CARDINAL]	RETURNS [good: BOOLEAN ¬ TRUE] =	BEGIN	-- compares two bytes to each other to see if they are the same	FOR i: CARDINAL IN [1..max - 1) DO	  IF pack[i] # twoBytes THEN BEGIN good ¬ FALSE; EXIT; END; ENDLOOP;	END;  -- of MatchBytes      SELECT echoParm.wordContents FROM	all0s, dontCare =>	  RETURN[MatchBytes[zeroes, pakBody, dataLen]];	all1s =>	  RETURN[MatchBytes[ones, pakBody, dataLen]];	incrWords =>	  FOR i: CARDINAL IN [1..dataLen - 1) DO	    IF pakBody[i] # pakBody[i - 1] + 1 THEN RETURN[FALSE];	    ENDLOOP;	allConstant =>	  RETURN[MatchBytes[echoParm.constant, pakBody, dataLen]];	ENDCASE;      RETURN[TRUE];      END;  -- of MatchData    SELECT TRUE FROM      echoBuf.ns.echoType # echoResponse =>  -- not an echo response?        h.echoResults.bad ¬ h.echoResults.bad + 1;      echoParm.checkContents AND dataLen > 1 AND NOT MatchData[] =>        BEGIN	h.echoResults.bad ¬ h.echoResults.bad + 1;	IF eventReporter # NIL THEN eventReporter[badDataGoodCRC, LOOPHOLE[h]];	END;      echoParm.waitForResponse AND pakBody[0] IN [0..repetitions - 1] =>        BEGIN	-- packet's sequence number matches that of one of the echo requests, so	-- packet must be a late response	h.echoResults.late ¬ h.echoResults.late + 1;	IF eventReporter # NIL THEN eventReporter[late, LOOPHOLE[h]];	END;      ENDCASE;    END;  -- of CheckPacket  Echo: PROCEDURE [    h: EchoDiagHandle, echoArgs: CommOnlineDiagnostics.EchoParams,    dataLen: CARDINAL, eventReporter: CommOnlineDiagnostics.EventReporter ¬ NIL] =    BEGIN    -- sends out and receives echo packets (via subroutine calls) until    -- termination conditions are met    BEGIN ENABLE ABORTED => GOTO quit;    done: BOOLEAN ¬ FALSE;    repetitions: CARDINAL ¬ 0;        Process.SetPriority[Process.priorityNormal];        EmptyBuffer[h, eventReporter];  -- clear out any junk packets    -- residing in buffer    h.echoResults.late ¬ 0;    [h.statsInfoOld.stats, ] ¬ GetEthernetStats[1];          WHILE ~(done ¬ TimeCheck[h, echoArgs.safetyTOInMsecs]) AND ~h.pleaseStop DO        IF echoArgs.totalCount > 0 THEN          IF repetitions < echoArgs.totalCount THEN	    [repetitions, dataLen] ¬ SendPacket[               h, repetitions, echoArgs, dataLen, eventReporter]	  ELSE  -- if we have sent total count, idle until timeout or aborted.	    Process.Pause[Process.MsecToTicks[2]]	ELSE  -- special case; if totalCount = 0, echo infinite number of packets	      -- until timeout or aborted.	  [repetitions, dataLen] ¬ SendPacket[            h, repetitions, echoArgs, dataLen, eventReporter];	ENDLOOP;        -- If we end by reaching the end of our time or total count, AND we have    -- waitForResponse = FALSE, get rid of the echo receiver process.    IF h.echoReceiver # NIL THEN      BEGIN      Process.Abort[h.echoReceiver];      JOIN h.echoReceiver;      h.echoReceiver ¬ NIL;      END;    END;    EXITS quit => NULL;    END;  -- of Echo  EchoReceiver: PROCEDURE [    h: EchoDiagHandle, echoParm: CommOnlineDiagnostics.EchoParams,    eventReporter: CommOnlineDiagnostics.EventReporter] =    BEGIN  -- FORKed to receive echo responses when waitForResponse = FALSE.    b: NSBuffer.Buffer ¬ NIL;    BEGIN ENABLE ABORTED =>       BEGIN      IF b # NIL THEN Socket.ReturnBuffer[b];      GOTO exit;      END;  -- Aborted.          packBod: Packet;    dataLen: CARDINAL;  -- length in words of the data.    Process.SetPriority[Process.priorityNormal];    DO  -- until aborted.      b ¬ Socket.GetPacket[        h.cH !        Socket.TimeOut =>          BEGIN          h.echoResults.timeouts ¬ h.echoResults.timeouts + 1;	  IF eventReporter # NIL THEN eventReporter[timeout, LOOPHOLE[h]];	  UpdateStats[h, FALSE, eventReporter];          LOOP;          END];      dataLen ¬ b.ns.pktLength/2 - NSTypes.wordsPerEchoHeader -        NSTypes.wordsPerIDPHeader;      -- got a response, adjust the stats      h.lastRec ¬ System.PulsesToMicroseconds[System.GetClockPulses[]];      packBod ¬ @b.ns.echoWords;      CheckPacket[h, b, packBod, dataLen, echoParm, h.seqNum, eventReporter];      Socket.ReturnBuffer[b];  -- return the buffer      b ¬ NIL;      UpdateStats[h, TRUE, eventReporter];      ENDLOOP;    END;  -- enabled clause.    EXITS exit => NULL;    END;  -- of EchoReceiver  EmptyBuffer: PROCEDURE [h: EchoDiagHandle,    eventReporter: CommOnlineDiagnostics.EventReporter] =    BEGIN    -- flushes the buffer queue    old: LONG CARDINAL ¬ 0;    status: Socket.SocketStatus;    trashBuf: NSBuffer.Buffer;    status ¬ Socket.GetStatus[h.cH];  -- get the socket's status    IF status.incompleteGets > 0  -- stuff on buffer queue      THEN      BEGIN      old ¬ h.echoResults.unexpected;      -- these packets weren't expected      h.echoResults.unexpected ¬ h.echoResults.unexpected + status.incompleteGets;      IF (eventReporter # NIL) AND (old < h.echoResults.unexpected) THEN        eventReporter[unexpected, LOOPHOLE[h]];      UNTIL status.incompleteGets = 0 DO  -- flush the queue out        trashBuf ¬ Socket.GetPacket[h.cH ! Socket.TimeOut => EXIT];  -- LOOP?        Socket.ReturnBuffer[trashBuf];        status ¬ Socket.GetStatus[h.cH];        ENDLOOP;      END;    END;  -- of EmptyBuffer  FillPacket: PROCEDURE [    dataLen: CARDINAL, sequence: CARDINAL, pktBody: Packet, constant: CARDINAL,    contents: CommOnlineDiagnostics.WordsInPacket] RETURNS [pack: Packet] =    BEGIN    -- fills up the body of the echo request packet. contents are as desired    oneWord: WORD = 177777B;    zeroWord: WORD = 0B;    pktBody[0] ¬ sequence;    IF dataLen > 1 THEN      FOR index: CARDINAL IN [1..dataLen) DO  -- - 1?        SELECT contents FROM          all0s, dontCare => pktBody[index] ¬ zeroWord;  -- N.B. dontCare's get 0's          all1s => pktBody[index] ¬ oneWord;          incrWords => pktBody[index] ¬ pktBody[index - 1] + 1;          allConstant => pktBody[index] ¬ constant;          ENDCASE;        ENDLOOP;    pack ¬ pktBody;    END;  -- of FillPacket  GetEchoCounters: PUBLIC PROCEDURE        RETURNS [packets, bytes: LONG CARDINAL, time: System.GreenwichMeanTime] =    BEGIN    [packets, bytes] ¬ EchoServer.GetCounters[];    [time] ¬ System.GetGreenwichMeanTime[];    END; -- of GetEchoCounters  GetEchoResults: PUBLIC PROC [    dH: CommOnlineDiagnostics.EchoDiagHandle, stopIt: BOOLEAN]    RETURNS [CommOnlineDiagnostics.EchoResults,    CommOnlineDiagnostics.Histogram] =    BEGIN      h: EchoDiagHandle ¬ LOOPHOLE[dH];      totalsSinceStart: CommOnlineDiagnostics.EchoResults;      statsInfoNew: CommOnlineDiagnostics.EtherStatsInfo;      SELECT TRUE FROM        h.seal # handleSeal => ERROR EtherDiagError[invalidHandle];        ~h.echoStarted => ERROR EtherDiagError[echoUserNotThere];	ENDCASE;            [statsInfoNew,] ¬ GetEthernetStats[1];      h.echoResults.okButDribble ¬ statsInfoNew[okButDribble] -          h.statsInfoOld.stats[okButDribble];      h.echoResults.badAlignmentButOkCrc ¬ statsInfoNew[badAlignmentButOkCrc] -          h.statsInfoOld.stats[badAlignmentButOkCrc];      h.echoResults.packetTooLong ¬ statsInfoNew[packetTooLong] -          h.statsInfoOld.stats[packetTooLong];      h.echoResults.overrun ¬ statsInfoNew[overrun] -          h.statsInfoOld.stats[overrun];      h.echoResults.idleInput ¬ statsInfoNew[idleInput] -          h.statsInfoOld.stats[idleInput];      h.echoResults.tooManyCollisions ¬ statsInfoNew[tooManyCollisions] -          h.statsInfoOld.stats[tooManyCollisions];      h.echoResults.lateCollisions ¬ statsInfoNew[lateCollisions] -          h.statsInfoOld.stats[lateCollisions];      h.echoResults.underrun ¬ statsInfoNew[underrun] -          h.statsInfoOld.stats[underrun];      h.echoResults.stuckOutput ¬ statsInfoNew[stuckOutput] -          h.statsInfoOld.stats[stuckOutput];      h.echoResults.spare ¬ statsInfoNew[spare] -          h.statsInfoOld.stats[spare];            h.endTime ¬ System.PulsesToMicroseconds[System.GetClockPulses[]];      totalsSinceStart.totalTime ¬ h.echoResults.totalTime ¬        (h.endTime - h.startTime)/LONG[1000];      totalsSinceStart.totalAttempts ¬ h.echoResults.totalAttempts;      totalsSinceStart.successes ¬ h.echoResults.successes;      totalsSinceStart.timeouts ¬ h.echoResults.timeouts;      totalsSinceStart.late ¬ h.echoResults.late;      totalsSinceStart.unexpected ¬ h.echoResults.unexpected;      totalsSinceStart.bad ¬ h.echoResults.bad;      IF h.echoResults.successes > 0 THEN        totalsSinceStart.avgDelayInMsecs ¬ h.echoResults.avgDelayInMsecs ¬          h.respTime/LONG[1000]/h.echoResults.successes      ELSE totalsSinceStart.avgDelayInMsecs ¬ 0;      totalsSinceStart.okButDribble ¬ h.echoResults.okButDribble;      totalsSinceStart.badAlignmentButOkCrc ¬ h.echoResults.badAlignmentButOkCrc;      totalsSinceStart.packetTooLong ¬ h.echoResults.packetTooLong;      totalsSinceStart.overrun ¬ h.echoResults.overrun;      totalsSinceStart.idleInput ¬ h.echoResults.idleInput;      totalsSinceStart.tooManyCollisions ¬ h.echoResults.tooManyCollisions;      totalsSinceStart.lateCollisions ¬ h.echoResults.lateCollisions;      totalsSinceStart.underrun ¬ h.echoResults.underrun;      totalsSinceStart.stuckOutput ¬ h.echoResults.stuckOutput;      totalsSinceStart.spare ¬ h.echoResults.spare;      h.timeOfLastPollSSE ¬ System.SecondsSinceEpoch[        System.GetGreenwichMeanTime[]];      -- reset the time of last poll      IF stopIt THEN        BEGIN	--echoReceiver may be invalid since it only gets started if client	-- specified waitForResponse = FALSE;	h.seal ¬ unsealed;	IF h.echoReceiver # NIL THEN	  BEGIN	  Process.Abort[h.echoReceiver];	  JOIN h.echoReceiver;	  h.echoReceiver ¬ NIL;	  END;	IF h.echoer # NIL THEN	  BEGIN	  Process.Abort[h.echoer];	  h.pleaseStop ¬ TRUE;	  JOIN h.echoer;	  h.echoer ¬ NIL;	  END;	h.pleaseStop ¬ FALSE;	h.echoStarted ¬ FALSE;  -- frees resources	Socket.Delete[h.cH];	h.cH ¬ Socket.nullChannelHandle;	zone.FREE[@h.statsInfoOld];	zone.FREE[@h.echoResults];	END;      RETURN[totalsSinceStart, h.hist];    END;  -- of GetEchoResults  SendPacket: PROCEDURE [    h: EchoDiagHandle, iterations: CARDINAL,    echoParm: CommOnlineDiagnostics.EchoParams,    dataLen: CARDINAL, eventReporter: CommOnlineDiagnostics.EventReporter ¬ NIL]    RETURNS [number, newCycle: CARDINAL] =    BEGIN    buffer: NSBuffer.Buffer ¬ NIL;    net: System.NetworkNumber;    pktBody: Packet;    response: BOOLEAN ¬ TRUE;    BEGIN    ENABLE UNWIND => IF buffer # NIL THEN Socket.ReturnBuffer[buffer];    iterations ¬ iterations + 1;    h.seqNum ¬ iterations;    SELECT TRUE FROM      echoParm.maxPacketSizeInBytes = echoParm.minPacketSizeInBytes =>        BEGIN  -- constant length.	dataLen ¬ echoParm.maxPacketSizeInBytes/2;	END;      dataLen > echoParm.maxPacketSizeInBytes/2 =>         BEGIN  -- hit max length; back to min.        dataLen ¬ echoParm.minPacketSizeInBytes/2;        IF eventReporter # NIL THEN eventReporter[sizeChange, LOOPHOLE[h]];	END;      ENDCASE;    buffer ¬ Socket.GetSendBuffer[h.cH];  -- set up the echoing facilities    Socket.SetDestination[buffer, h.target];    Socket.SetPacketWords[buffer, dataLen + NSTypes.wordsPerEchoHeader];    buffer.ns.packetType ¬ echo;    buffer.ns.echoType ¬ echoRequest;    pktBody ¬ @buffer.ns.echoWords;    net ¬ buffer.ns.destination.net;    [dataLen, pktBody] ¬ PreparePacket[      h, dataLen, iterations, echoParm, pktBody];    Socket.PutPacket[h.cH, buffer];    buffer ¬ NIL;    h.lastSend ¬ System.PulsesToMicroseconds[System.GetClockPulses[]];    -- If we are NOT waiting for responses, <EchoReceiver> has been forked to    -- collect them;  if we are waiting, get the response here.    IF echoParm.waitForResponse THEN      BEGIN      response ¬ ReceiveResponse[        h, echoParm, iterations, dataLen, eventReporter, net];      UpdateStats[h, response, eventReporter];      END;    newCycle ¬ dataLen;    response ¬ TRUE;    number ¬ iterations;    END;    END;  -- of SendPacket  StartEchoUser: PUBLIC PROC [     targetSystemElement: System.NetworkAddress,       echoParams: CommOnlineDiagnostics.EchoParams,    eventReporter: CommOnlineDiagnostics.EventReporter ¬ NIL]    RETURNS [dH: CommOnlineDiagnostics.EchoDiagHandle] =    BEGIN    dataLen: CARDINAL;    h: EchoDiagHandle ¬ zone.NEW[EchoDiagObject];    h.seal ¬ handleSeal;    h.echoStarted ¬ TRUE;    h.startTime ¬ System.PulsesToMicroseconds[System.GetClockPulses[]];    h.hist ¬ DESCRIPTOR[zone.NEW[HistArray], HistSize];    h.target ¬ targetSystemElement;    h.target.socket ¬ System.nullSocketNumber;    h.echoResults ¬ zone.NEW[CommOnlineDiagnostics.EchoResults];    h.statsInfoOld ¬ zone.NEW[EtherStats];    IF echoParams.maxPacketSizeInBytes > NSTypes.maxDataBytesPerEcho THEN      echoParams.maxPacketSizeInBytes ¬ NSTypes.maxDataBytesPerEcho;    dataLen ¬ Initialize[h, echoParams.minPacketSizeInBytes];    h.echoer ¬ FORK Echo[h, echoParams, dataLen,      eventReporter];    IF ~echoParams.waitForResponse THEN      h.echoReceiver ¬ FORK EchoReceiver[h, echoParams,        eventReporter];    RETURN[LOOPHOLE[h]];    END;  -- of StartEchoUser  TimeCheck: PROCEDURE [h: EchoDiagHandle, timeOutMilliSec: LONG CARDINAL]    RETURNS [timedOut: BOOLEAN] = {    -- used to see if program execution should be automatically aborted    -- timedOut ¬ [currentTime] - [timeOfLastPoll] > [safetyTimeLength]    timedOut ¬      System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]] -        h.timeOfLastPollSSE > (timeOutMilliSec/1000);    };  -- of TimeCheck          UpdateStats: PROC [h: EchoDiagHandle, response: BOOLEAN,    eventReporter: CommOnlineDiagnostics.EventReporter] =    BEGIN  -- Called after receiving an echo response, updates the statistics.    old: LONG CARDINAL ¬ 0;    IF response      THEN           BEGIN	   h.respTime ¬	     h.respTime + (h.lastRec - h.lastSend);	   SELECT (((h.lastRec - h.lastSend)/1000) + 1) FROM	     < 6 => h.hist[0].count ¬ h.hist[0].count + 1;	     < 7 => h.hist[1].count ¬ h.hist[1].count + 1;	     < 8 => h.hist[2].count ¬ h.hist[2].count + 1;	     < 9 => h.hist[3].count ¬ h.hist[3].count + 1;	     < 10 => h.hist[4].count ¬ h.hist[4].count + 1;	     < 11 => h.hist[5].count ¬ h.hist[5].count + 1;	     < 16 => h.hist[6].count ¬ h.hist[6].count + 1;	     < 21 => h.hist[7].count ¬ h.hist[7].count + 1;	     < 26 => h.hist[8].count ¬ h.hist[8].count + 1;	     < 31 => h.hist[9].count ¬ h.hist[9].count + 1;	     < 36 => h.hist[10].count ¬ h.hist[10].count + 1;	     < 41 => h.hist[11].count ¬ h.hist[11].count + 1;	     < 46 => h.hist[12].count ¬ h.hist[12].count + 1;	     < 51 => h.hist[13].count ¬ h.hist[13].count + 1;	     < 61 => h.hist[14].count ¬ h.hist[14].count + 1;	     < 81 => h.hist[15].count ¬ h.hist[15].count + 1;	     < 101 => h.hist[16].count ¬ h.hist[16].count + 1;	     < 151 => h.hist[17].count ¬ h.hist[17].count + 1;	     < 201 => h.hist[18].count ¬ h.hist[18].count + 1;	     < 251 => h.hist[19].count ¬ h.hist[19].count + 1;	     < 301 => h.hist[20].count ¬ h.hist[20].count + 1;	     < 401 => h.hist[21].count ¬ h.hist[21].count + 1;	     < 501 => h.hist[22].count ¬ h.hist[22].count + 1;	     < 601 => h.hist[23].count ¬ h.hist[23].count + 1;	     < 1001 => h.hist[24].count ¬ h.hist[24].count + 1;	     ENDCASE => h.hist[25].count ¬ h.hist[25].count + 1;	     END;    h.echoResults.totalAttempts ¬ h.echoResults.totalAttempts + 1;    old ¬ h.echoResults.successes;    h.echoResults.successes ¬      h.echoResults.totalAttempts - h.echoResults.bad - h.echoResults.timeouts -        h.echoResults.late;    IF (eventReporter # NIL) AND (old < h.echoResults.successes) THEN      eventReporter[success, LOOPHOLE[h]];    END;  -- UpdateStats  Wait: PROCEDURE [h: EchoDiagHandle, minWaitMsecs: CARDINAL] =    BEGIN  -- idle if sufficient time since last packet has not elapsed.    now, delta, minWait: LONG CARDINAL; -- In microsecs.    minWait ¬ LONG[minWaitMsecs]*1000;    DO      now ¬ System.PulsesToMicroseconds[System.GetClockPulses[]];      delta ¬ now - h.lastSend;      SELECT TRUE FROM        (h.lastSend = 0) => EXIT;     -- starting condition.        (delta > minWait) => EXIT;  -- already waited too long.        (minWait - delta > twoTicks) => Process.Pause[1];  -- longer wait.        ENDCASE => Process.Yield[];  -- short time to wait (<100 msecs).      ENDLOOP;    END;  -- Wait  END.....	-- EchoImplLOGTime: 12-Oct-83  8:35:45 By: S. Tom Chang  Action: Klamath changes.Time: 14-Oct-83 10:25:57 By: S. Tom Chang  Action: replacing StatsRecord by EchoResults.Time:  4-Nov-83 16:22:39 By: S. Tom Chang  Action: New CommOnlineDiagnosticsTime:  8-Nov-83 11:21:48 By: SMA  Action: Catch Router.NoTableEntryForNet. 9-Nov-83 16:23:02  SMA  JOIN echoer instead of Detach, fixed garbaged h.hist after multiple StartEchoUser attempts.20-Nov-83 11:56:28  SMA  Echoing when not waiting for response, fix Wait. 6-Dec-83 10:34:02  SMA  Call eventReporter when timeout. 8-Dec-83 10:58:18  SMA  Check receive packets when not waiting for response.    4-Jan-84 14:50:26  SMA  Call eventReporter when badDataGoodCRC31-Jan-84 11:52:00  SMA  Call eventReporter only when non-NIL. 3-May-84 12:01:39  SMA  Do not call report success along with late.28-Jan-85 11:50:40  SMA  Multiple echo users. 5-Jan-87 13:26:48  AOF  update to Pilot 13.0 buffers.28-Oct-87 20:00:21  BKI  Fixed AR 12168.
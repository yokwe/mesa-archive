-- File: DiagClient.mesa - last edit:-- AOF                  5-Jan-87 14:26:51-- BKI                  5-Nov-87 17:54:39-- SMA                 28-Jan-85 11:37:39-- Copyright (C) 1984, 1987 by Xerox Corporation. All rights reserved. -- The client side of the remote online diagnostics.DIRECTORY  CommOnlineDiagnostics USING [    CommError, CommErrorCode, CountType, DialupOutcome, EchoDiagHandle,    EchoParams, EchoResults, EtherDiagError, EtherErrorReason, EtherStatsInfo,    EventReporter, Histogram, ModemChange, RS232CDiagError, RS232CDiagHandle,    RS232CErrorReason, RS232CParams, SetDiagnosticLine, WriteMsg],  Courier USING [    Arguments, Call, Create, Delete, Dispatcher, ExportRemoteProgram,    Free, Handle, LocalSystemElement, NoSuchProcedureNumber, nullParameters,    Parameters, Results, UnexportRemoteProgram],  DiagInternal USING [    CourierCallProc, DescribeBoolean, DescribeCardinal, DescribeDialup,    DescribeDialupOutcome, DescribeEchoCounters, DescribeEchoHandle,    DescribeEchoResults, DescribeEchoResultsParams, DescribeEtherStatsResults,    DescribeEventRepParams, DescribeLoopbackHandle, DescribeModemChangeParams,    DescribeRS232CParams, DescribeRS232CResults, DescribeRS232CResultsParams,    DescribeSetLineParams, DescribeStartEchoParams, DescribeWriteMsgParams,    diagCallBackPgm, diagPgmNumber, DialupParams, dialupProc,    EchoCounterResults, echoCountersProc, EchoResults, EchoResultsParams,    EchoStartParams, etherStatsProc, EtherStatsResults, eventReporterNum,    EventRepParams, getEchoResultsProc, getRS232CResultsProc, MakeCall,    modemChangeNum, ModemChangeParams, rs232cLoopbackProc, RS232CResultsParams,    RS232CTestParams, setDiagLineNum, SetLineParams, startEchoProc, version,    versions, WriteMsgParams, writeRS232CMsgNum],  Dialup USING [DialerType, Number],  Heap USING [systemZone],  System USING [GreenwichMeanTime, NetworkAddress, nullNetworkAddress];    DiagClient: MONITOR  IMPORTS CommOnlineDiagnostics, Courier, DiagInternal, Heap  EXPORTS CommOnlineDiagnostics =  BEGIN    z: UNCOUNTED ZONE = Heap.systemZone;  CommError: PUBLIC ERROR [reason: CommOnlineDiagnostics.CommErrorCode] = CODE;  RS232CDiagError: PUBLIC ERROR [    reason: CommOnlineDiagnostics.RS232CErrorReason] = CODE;  EtherDiagError: PUBLIC ERROR [    reason: CommOnlineDiagnostics.EtherErrorReason] = CODE;           EchoCBEntry: TYPE = LONG POINTER TO EchoCBObj;  EchoCBObj: TYPE = RECORD [    next: EchoCBEntry ¬ NIL,    ep: CommOnlineDiagnostics.EventReporter,    dH: CommOnlineDiagnostics.EchoDiagHandle];      RSCBEntry: TYPE = LONG POINTER TO RSCBObj;  RSCBObj: TYPE = RECORD [    next: RSCBEntry ¬ NIL,    sl: CommOnlineDiagnostics.SetDiagnosticLine,    wm: CommOnlineDiagnostics.WriteMsg,    mc: CommOnlineDiagnostics.ModemChange,    dH: CommOnlineDiagnostics.RS232CDiagHandle];      echoProcs: EchoCBEntry ¬ NIL;  --linked list of echo callbacks.  rs232cProcs: RSCBEntry ¬ NIL;  --linked list of rs232c callbacks.  useCount: INTEGER ¬ 0;  --number of clients    AddEchoCallback: PROC [    proc: CommOnlineDiagnostics.EventReporter,    dH: CommOnlineDiagnostics.EchoDiagHandle] =    BEGIN  --adds echo entry to list of callbacks and handles.    new: EchoCBEntry;    FOR e: EchoCBEntry ¬ echoProcs, e.next UNTIL e = NIL DO      IF e.dH = dH THEN RETURN;  --already exists.      ENDLOOP;    new ¬ z.NEW[EchoCBObj ¬ [echoProcs, proc, dH]];    echoProcs ¬ new;    END;  --AddEchoCallback          AddRS232CCallbacks: PROC [    setLineProc: CommOnlineDiagnostics.SetDiagnosticLine,    writeMsgProc: CommOnlineDiagnostics.WriteMsg,    modemProc: CommOnlineDiagnostics.ModemChange,    dH: CommOnlineDiagnostics.RS232CDiagHandle] =    BEGIN  --adds rs232c entry to list of callbacks and handles.    new: RSCBEntry;    FOR e: RSCBEntry ¬ rs232cProcs, e.next UNTIL e = NIL DO      IF e.dH = dH THEN RETURN;  --already exists.      ENDLOOP;    new ¬ z.NEW[      RSCBObj ¬ [rs232cProcs, setLineProc, writeMsgProc, modemProc, dH]];    rs232cProcs ¬ new;    END;  --AddRS232CCallbacks           CallbackDispatcher: Courier.Dispatcher =    BEGIN  -- The dispatcher for ALL of the communications diagnostics callbacks.    SELECT procedureNumber FROM      -- Ethernet echo      DiagInternal.eventReporterNum => EventReporter[cH, arguments, results];      -- RS232CLoopback      DiagInternal.setDiagLineNum => SetDiagLine[cH, arguments, results];      DiagInternal.writeRS232CMsgNum => RS232CWrite[cH, arguments, results];      DiagInternal.modemChangeNum => SignalModemChange[cH, arguments, results];      ENDCASE => ERROR Courier.NoSuchProcedureNumber;    END;  -- CallbackDispatcher              DialupTest: PUBLIC ENTRY PROC [    rs232ClineNumber: CARDINAL,    phoneNumber: LONG POINTER TO Dialup.Number,    dialerType: Dialup.DialerType,    host: System.NetworkAddress]    RETURNS [outcome: CommOnlineDiagnostics.DialupOutcome] =    BEGIN ENABLE UNWIND => NULL;    cH: Courier.Handle ¬ NIL;    dialArgs: DiagInternal.DialupParams ¬ [      rs232ClineNumber, phoneNumber, dialerType];    args: Courier.Parameters ¬ [@dialArgs, DiagInternal.DescribeDialup];    results: Courier.Parameters ¬ [      @outcome, DiagInternal.DescribeDialupOutcome];        -- Clean up and let error propogate to the client.      BEGIN ENABLE CommOnlineDiagnostics.CommError =>      IF cH # NIL THEN {Courier.Delete[cH]; cH ¬ NIL};        CallProc: DiagInternal.CourierCallProc =      BEGIN      [] ¬ Courier.Call[cH, DiagInternal.dialupProc, args, results];      END;  -- CallProc       -- Start of proc    IF host = System.nullNetworkAddress THEN      host ¬ Courier.LocalSystemElement[];    cH ¬ Courier.Create[host, DiagInternal.diagPgmNumber, DiagInternal.version,      z, transactional];    DiagInternal.MakeCall[CallProc, cH];    Courier.Delete[cH];    cH ¬ NIL;    Courier.Free[results, z];  -- Free any space courier may have used.    END;  -- enabled clause.    END;  -- DialupTest          EventReporter: PROC [cH: Courier.Handle, arguments: Courier.Arguments,    results: Courier.Results] =    BEGIN  -- Calls the client's local printFeedback proc.    eventParams: DiagInternal.EventRepParams;    ep: CommOnlineDiagnostics.EventReporter;    arguments[[@eventParams, DiagInternal.DescribeEventRepParams]];    IF (ep ¬ GetEchoCallback[eventParams.dH, FALSE]) = NIL THEN      BEGIN      WaitUntilCallbackExported[];      ep ¬ GetEchoCallback[eventParams.dH, FALSE];      END;    [] ¬ ep[eventParams.event, eventParams.dH];    [] ¬ results[Courier.nullParameters];    END;  -- EventReporter          ExportCallback: <<INTERNAL>> PROC =    BEGIN  -- Exports CallbackDispatcher if not already exported    IF (useCount ¬ useCount + 1) = 1 THEN      Courier.ExportRemoteProgram[DiagInternal.diagCallBackPgm,        DiagInternal.versions, CallbackDispatcher, NIL, z, transactional];    END;  -- ExportCallback          UnexportCallback: <<INTERNAL>> PROC =    BEGIN  -- Exports CallbackDispatcher if not already exported    IF (useCount ¬ useCount - 1) = 0 THEN      Courier.UnexportRemoteProgram[        DiagInternal.diagCallBackPgm, DiagInternal.versions];    END;  -- UnexportCallback          GetEchoCallback: PROC [    dH: CommOnlineDiagnostics.EchoDiagHandle, remove: BOOLEAN ¬ FALSE]    RETURNS [ep: CommOnlineDiagnostics.EventReporter ¬ NIL] =    BEGIN  --returns the callback procs for the specified diagnostic.    prev, e: EchoCBEntry ¬ NIL;    FOR e ¬ echoProcs, e.next UNTIL e = NIL DO      IF e.dH = dH THEN	BEGIN	ep ¬ e.ep;	IF remove THEN	  BEGIN	  IF prev = NIL THEN echoProcs ¬ e.next	  ELSE prev.next ¬ e.next;	  z.FREE[@e];	  END;	EXIT;	END;      prev ¬ e;      ENDLOOP;    END;  --GetEchoCallbacks          GetRS232CCallbacks: PROC [    dH: CommOnlineDiagnostics.RS232CDiagHandle, remove: BOOLEAN ¬ FALSE]    RETURNS [sl: CommOnlineDiagnostics.SetDiagnosticLine¬ NIL,    wm: CommOnlineDiagnostics.WriteMsg ¬ NIL,    mc: CommOnlineDiagnostics.ModemChange ¬ NIL] =    BEGIN  --returns the callback procs for the specified diagnostic.    prev, e: RSCBEntry ¬ NIL;    FOR e ¬ rs232cProcs, e.next UNTIL e = NIL DO      IF e.dH = dH THEN	BEGIN	sl ¬ e.sl;	wm ¬ e.wm;	mc ¬ e.mc;	IF remove THEN	  BEGIN	  IF prev = NIL THEN rs232cProcs ¬ e.next	  ELSE prev.next ¬ e.next;	  z.FREE[@e];	  END;	EXIT;	END;      prev ¬ e;      ENDLOOP;    END;  --GetRS232CCallbacks        GetEchoCounters: PUBLIC ENTRY PROC [host: System.NetworkAddress]    RETURNS [packets, bytes: LONG CARDINAL,    time: System.GreenwichMeanTime] =     BEGIN ENABLE UNWIND => NULL;     cH: Courier.Handle ¬ NIL;     -- no arguments     counters: DiagInternal.EchoCounterResults;  -- the results.     args: Courier.Parameters ¬ Courier.nullParameters;     results: Courier.Parameters ¬ [@counters, DiagInternal.DescribeEchoCounters];          -- Clean up and let error proprogate to the client.     BEGIN ENABLE CommOnlineDiagnostics.CommError,       CommOnlineDiagnostics.EtherDiagError =>         IF cH # NIL THEN {Courier.Delete[cH]; cH ¬ NIL};          CallProc: DiagInternal.CourierCallProc =      BEGIN      [] ¬ Courier.Call[cH, DiagInternal.echoCountersProc, args, results];      END;  -- CallProc           IF host = System.nullNetworkAddress THEN       host ¬ Courier.LocalSystemElement[];     cH ¬ Courier.Create[host, DiagInternal.diagPgmNumber, DiagInternal.version,       z, transactional];     DiagInternal.MakeCall[CallProc, cH];     Courier.Delete[cH];     cH ¬ NIL;     Courier.Free[results, z];     END;  -- enabled clause.     RETURN[counters.pkts, counters.bytes, counters.time];     END;  -- GetEchoCounters          GetEchoResults: PUBLIC ENTRY PROC [    dH: CommOnlineDiagnostics.EchoDiagHandle, stopIt: BOOLEAN,    host: System.NetworkAddress]    RETURNS [totalsSinceStart: CommOnlineDiagnostics.EchoResults,    hist: CommOnlineDiagnostics.Histogram] =    BEGIN ENABLE UNWIND => NULL;    cH: Courier.Handle ¬ NIL;    echoArgs: DiagInternal.EchoResultsParams ¬ [stopIt, dH];    echoResults: DiagInternal.EchoResults;    args: Courier.Parameters ¬ [      @echoArgs, DiagInternal.DescribeEchoResultsParams];    results: Courier.Parameters ¬ [      @echoResults, DiagInternal.DescribeEchoResults];          -- Clean up and let error proprogate to the client.     BEGIN     ENABLE  -- Both errors are fatal, so clean up the call back program also.      CommOnlineDiagnostics.CommError,      CommOnlineDiagnostics.EtherDiagError =>        BEGIN        IF cH # NIL THEN {Courier.Delete[cH]; cH ¬ NIL};	IF GetEchoCallback[dH, FALSE] # NIL THEN             {[] ¬ GetEchoCallback[dH, TRUE];	      UnexportCallback[]};        END;	    CallProc: DiagInternal.CourierCallProc =      BEGIN      [] ¬ Courier.Call[cH, DiagInternal.getEchoResultsProc, args, results];      END;  -- CallProc        IF host = System.nullNetworkAddress THEN      host ¬ Courier.LocalSystemElement[];    cH ¬ Courier.Create[host, DiagInternal.diagPgmNumber, DiagInternal.version,      z, transactional];      DiagInternal.MakeCall[CallProc, cH];    Courier.Delete[cH];    cH ¬ NIL;    -- NIL courier's ptr to the histogram so it doesn't get freed,    -- pass real one to client.    hist ¬ echoResults.hist;    echoResults.hist ¬ DESCRIPTOR[NIL, 0];    Courier.Free[results, z];    IF stopIt AND GetEchoCallback[dH, FALSE] # NIL THEN      BEGIN      [] ¬ GetEchoCallback[dH, TRUE];      UnexportCallback[];      END;    END;  -- enabled clause.    RETURN[echoResults.totals, hist];    END;  -- GetEchoResults        FreeHistogram: PUBLIC ENTRY PROC [hist: CommOnlineDiagnostics.Histogram] =    BEGIN    p: LONG POINTER ¬ BASE[hist];    z.FREE[@p];    END;  -- FreeHistogram          StartEchoUser: PUBLIC ENTRY PROC [    targetSystemElement: System.NetworkAddress,    echoParams: CommOnlineDiagnostics.EchoParams,    eventReporter: CommOnlineDiagnostics.EventReporter,    host: System.NetworkAddress]     RETURNS [dH: CommOnlineDiagnostics.EchoDiagHandle] =    BEGIN ENABLE UNWIND => NULL;    cH: Courier.Handle ¬ NIL;    echoArgs: DiagInternal.EchoStartParams;    exportPgm: BOOLEAN = (eventReporter # NIL);    args: Courier.Parameters ¬ [@echoArgs, DiagInternal.DescribeStartEchoParams];    results: Courier.Parameters ¬ [@dH, DiagInternal.DescribeEchoHandle];    BEGIN  -- Clean up, and let error proprograte to the client.    ENABLE      CommOnlineDiagnostics.CommError =>        IF cH # NIL THEN {Courier.Delete[cH]; cH ¬ NIL};          CallProc: DiagInternal.CourierCallProc =      BEGIN      [] ¬ Courier.Call[cH, DiagInternal.startEchoProc, args, results];      END;  -- CallProc               echoArgs ¬ [targetSystemElement, (eventReporter # NIL), echoParams];    IF host = System.nullNetworkAddress THEN      host ¬ Courier.LocalSystemElement[];    cH ¬ Courier.Create[host, DiagInternal.diagPgmNumber, DiagInternal.version,      z, transactional];    IF exportPgm THEN ExportCallback[];    DiagInternal.MakeCall[CallProc, cH !      UNWIND => IF exportPgm THEN UnexportCallback[]];    IF exportPgm THEN AddEchoCallback[eventReporter, dH];    Courier.Delete[cH];    cH ¬ NIL;    END;  -- enabled clause.    END;  -- StartEchoUser          GetEthernetStats: PUBLIC ENTRY PROC [    physicalOrder: CARDINAL, host: System.NetworkAddress]    RETURNS [info: CommOnlineDiagnostics.EtherStatsInfo,    time: System.GreenwichMeanTime] =    BEGIN ENABLE UNWIND => NULL;    cH: Courier.Handle ¬ NIL;    statResults: DiagInternal.EtherStatsResults;    args: Courier.Parameters ¬ [@physicalOrder, DiagInternal.DescribeCardinal];    results: Courier.Parameters ¬ [      @statResults, DiagInternal.DescribeEtherStatsResults];        -- Clean up and let error proprogate to the client.      BEGIN ENABLE CommOnlineDiagnostics.CommError,                 CommOnlineDiagnostics.EtherDiagError =>                   IF cH # NIL THEN {Courier.Delete[cH]; cH ¬ NIL};          CallProc: DiagInternal.CourierCallProc =      BEGIN      [] ¬ Courier.Call[cH, DiagInternal.etherStatsProc, args, results];      END;  -- CallProc         IF host = System.nullNetworkAddress THEN      host ¬ Courier.LocalSystemElement[];    cH ¬ Courier.Create[host, DiagInternal.diagPgmNumber, DiagInternal.version,      z, transactional];      DiagInternal.MakeCall[CallProc, cH];    Courier.Delete[cH];    cH ¬ NIL;    Courier.Free[results, z];  -- Free any storage Courier may have allocated.    END;  -- enabled clause.    RETURN[statResults.stats, statResults.time];    END;  -- GetEthernetStats             StartRS232CTest: PUBLIC ENTRY PROC [    rs232cParams: CommOnlineDiagnostics.RS232CParams,    setDiagnosticLine: CommOnlineDiagnostics.SetDiagnosticLine,    writeMsg: CommOnlineDiagnostics.WriteMsg,    modemChange: CommOnlineDiagnostics.ModemChange,    host: System.NetworkAddress]    RETURNS [dH: CommOnlineDiagnostics.RS232CDiagHandle] =    BEGIN ENABLE UNWIND => NULL;    exportPgm: BOOLEAN = (setDiagnosticLine # NIL) OR (writeMsg # NIL) OR      (modemChange # NIL);    cH: Courier.Handle;    rs232cArgs: DiagInternal.RS232CTestParams;    args: Courier.Parameters ¬ [@rs232cArgs, DiagInternal.DescribeRS232CParams];    results: Courier.Parameters ¬ [@dH, DiagInternal.DescribeLoopbackHandle];        BEGIN  -- Clean up and let error proprogate to the client.    ENABLE      CommOnlineDiagnostics.CommError =>        IF cH # NIL THEN {Courier.Delete[cH]; cH ¬ NIL};             CallProc: DiagInternal.CourierCallProc =      BEGIN      [] ¬ Courier.Call[cH, DiagInternal.rs232cLoopbackProc, args, results];      END;  -- CallProc         rs232cArgs ¬ [(setDiagnosticLine # NIL), (modemChange # NIL),      (writeMsg # NIL), rs232cParams];    IF host = System.nullNetworkAddress THEN      host ¬ Courier.LocalSystemElement[];    cH ¬ Courier.Create[host, DiagInternal.diagPgmNumber, DiagInternal.version,      z, transactional];    IF exportPgm THEN ExportCallback[];    DiagInternal.MakeCall[CallProc, cH !      UNWIND => IF exportPgm THEN UnexportCallback[]];    IF exportPgm THEN      AddRS232CCallbacks[setDiagnosticLine, writeMsg, modemChange, dH];    Courier.Delete[cH];    cH ¬ NIL;    END;  -- enabled clause.    END;  -- RS232CLoopback          GetRS232CResults: PUBLIC ENTRY PROC [    dH: CommOnlineDiagnostics.RS232CDiagHandle, stopIt: BOOLEAN,    host: System.NetworkAddress]    RETURNS[counters: CommOnlineDiagnostics.CountType] =    BEGIN ENABLE UNWIND => NULL;    cH: Courier.Handle;        rs232cResultsArgs: DiagInternal.RS232CResultsParams;    args: Courier.Parameters ¬ [      @rs232cResultsArgs, DiagInternal.DescribeRS232CResultsParams];    results: Courier.Parameters ¬ [@counters, DiagInternal.DescribeRS232CResults];        -- Clean up and let error proprogate to the client.    BEGIN     ENABLE  -- Both errors are fatal, so clean up the call back program also.      CommOnlineDiagnostics.CommError,      CommOnlineDiagnostics.RS232CDiagError =>        BEGIN	sl: CommOnlineDiagnostics.SetDiagnosticLine;	wm: CommOnlineDiagnostics.WriteMsg;	mc: CommOnlineDiagnostics.ModemChange;        IF cH # NIL THEN {Courier.Delete[cH]; cH ¬ NIL};	[sl, wm, mc] ¬ GetRS232CCallbacks[dH, FALSE];	SELECT TRUE FROM	  sl # NIL, wm # NIL, mc # NIL =>            {[] ¬ GetRS232CCallbacks[dH, TRUE];	     UnexportCallback[]};	  ENDCASE;	END;    	    CallProc: DiagInternal.CourierCallProc =      BEGIN      [] ¬ Courier.Call[cH, DiagInternal.getRS232CResultsProc, args, results];      END;  -- CallProc        rs232cResultsArgs ¬ [dH, stopIt];    IF host = System.nullNetworkAddress THEN      host ¬ Courier.LocalSystemElement[];    cH ¬ Courier.Create[host, DiagInternal.diagPgmNumber, DiagInternal.version,      z, transactional];    DiagInternal.MakeCall[CallProc, cH];    Courier.Delete[cH];    cH ¬ NIL;    Courier.Free[results, z];    IF stopIt THEN      BEGIN      sl: CommOnlineDiagnostics.SetDiagnosticLine;      wm: CommOnlineDiagnostics.WriteMsg;      mc: CommOnlineDiagnostics.ModemChange;      [sl, wm, mc] ¬ GetRS232CCallbacks[dH, FALSE];      SELECT TRUE FROM	sl # NIL, wm # NIL, mc # NIL =>	  {[] ¬ GetRS232CCallbacks[dH, TRUE];	   UnexportCallback[]};	ENDCASE;      END;     END;  -- enabled clause.    RETURN[counters];    END;  -- GetRS232CResults          RS232CWrite: PROC [cH: Courier.Handle, arguments: Courier.Arguments,    results: Courier.Results] =    BEGIN  -- Calls the client's local WriteMessage proc.    writeMsgParams: DiagInternal.WriteMsgParams;  -- the argument    wm: CommOnlineDiagnostics.WriteMsg;    arguments[[@writeMsgParams, DiagInternal.DescribeWriteMsgParams]];    IF (wm ¬ GetRS232CCallbacks[writeMsgParams.dH, FALSE].wm) = NIL THEN      BEGIN      WaitUntilCallbackExported[];      wm ¬ GetRS232CCallbacks[writeMsgParams.dH, FALSE].wm;      END;    IF wm # NIL THEN wm[writeMsgParams.msg, writeMsgParams.dH];    [] ¬ results[Courier.nullParameters];    END;  -- RS232CWrite      SetDiagLine: PROC [cH: Courier.Handle, arguments: Courier.Arguments,    results: Courier.Results] =    BEGIN  -- Calls the client's local setDiagnosticLine proc.    lineSet: BOOLEAN;    sl: CommOnlineDiagnostics.SetDiagnosticLine;    setLineParams: DiagInternal.SetLineParams;    arguments[[@setLineParams, DiagInternal.DescribeSetLineParams]];    IF (sl ¬ GetRS232CCallbacks[setLineParams.dH, FALSE].sl) = NIL THEN      BEGIN      WaitUntilCallbackExported[];      sl ¬ GetRS232CCallbacks[setLineParams.dH, FALSE].sl;      END;     lineSet ¬ IF sl # NIL THEN sl[setLineParams.lineNumber, setLineParams.dH]    ELSE FALSE;    [] ¬ results[[@lineSet, DiagInternal.DescribeBoolean]];    END;  -- SetDiagLine        SignalModemChange: PROC [cH: Courier.Handle, arguments: Courier.Arguments,    results: Courier.Results] =    BEGIN  -- Calls the client's local SignalModemChange proc.    modemChangeParams: DiagInternal.ModemChangeParams;    mc: CommOnlineDiagnostics.ModemChange;    arguments[[@modemChangeParams, DiagInternal.DescribeModemChangeParams]];    IF (mc ¬ GetRS232CCallbacks[modemChangeParams.dH, FALSE].mc) = NIL THEN      BEGIN      WaitUntilCallbackExported[];      mc ¬ GetRS232CCallbacks[modemChangeParams.dH, FALSE].mc;      END;    IF mc # NIL THEN      mc[modemChangeParams.modemSignal,      modemChangeParams.state, modemChangeParams.dH];    [] ¬ results[Courier.nullParameters];    END;  -- SignalModemChange        WaitUntilCallbackExported: ENTRY PROC = {};    -- The client's process might not have called Add*Callback yet.     END.  LOG12-Jul-83 12:14:39  SMA  Created file.25-Oct-83 14:20:00  SMA  Use new interfaces.14-Feb-84 16:31:11  SMA  Delete the courier connection after GetRS232CResults.28-Jan-85 11:37:44  SMA  Changes for multiport board. 5-Jan-87 14:26:39  AOF  Filling out USING lists. 5-Nov-87 17:54:39  BKI  Fixed ARs 8339 and 8739.
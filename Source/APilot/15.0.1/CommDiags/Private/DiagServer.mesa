-- File: DiagServer.mesa - last edit:-- AOF                  5-Jan-87 14:29:05-- BKI                 10-Nov-87 10:55:05-- SMA                  1-Feb-85 12:31:45-- Copyright (C) 1984, 1985, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  CommDiags USING [    DialupTest, EtherDiagError, FreeHist, GetEchoCounters, GetEchoResults,    GetEthernetStats, GetRS232CResults, RS232CDiagError, StartEchoUser,    StartRS232CTest],  CommOnlineDiagnostics USING [    CommError, CountType, DialupOutcome, EchoDiagHandle, EchoResults,    EtherErrorReason, EtherStatsInfo, EventReporter, Histogram, ModemChange,    RS232CDiagHandle, RS232CErrorReason, SetDiagnosticLine, WriteMsg],  Courier USING [    Arguments, Call, Create, Delete, Dispatcher, Error, ExportRemoteProgram,    Free, Handle, NoSuchProcedureNumber, nullParameters, Parameters, Results,    SignalRemoteError, UnexportRemoteProgram],  DiagInternal USING [    CourierCallProc, DescribeBoolean, DescribeCardinal, DescribeDialup,    DescribeDialupOutcome, DescribeEchoCounters, DescribeEchoHandle,    DescribeEchoResults, DescribeEchoResultsParams, DescribeEtherStatsResults,    DescribeEventRepParams, DescribeLoopbackHandle, DescribeModemChangeParams,    DescribeRS232CParams, DescribeRS232CResults, DescribeRS232CResultsParams,    DescribeSetLineParams, DescribeStartEchoParams, DescribeWriteMsgParams,    diagCallBackPgm, diagPgmNumber, DialupParams, dialupProc, EchoCounterResults,    echoCountersProc, EchoResults, EchoResultsParams, EchoStartParams,    etherDiagErr, etherStatsProc, EtherStatsResults, eventReporterNum,    EventRepParams, getEchoResultsProc, getRS232CResultsProc, MakeCall,    modemChangeNum, ModemChangeParams, rs232cDiagErr, rs232cLoopbackProc,    RS232CResultsParams, RS232CTestParams, setDiagLineNum, SetLineParams,    startEchoProc, version, versions, WriteMsgParams, writeRS232CMsgNum],  Heap USING [systemZone],  Process USING [Yield],  System USING [NetworkAddress];      DiagServer: MONITOR  IMPORTS Courier, DiagInternal, Heap, CommDiags, CommOnlineDiagnostics, Process  EXPORTS CommOnlineDiagnostics =  BEGIN  -- The server side for remote online diagnostics  z: UNCOUNTED ZONE = Heap.systemZone;      EchoCBEntry: TYPE = LONG POINTER TO EchoCBObj;  EchoCBObj: TYPE = RECORD [    next: EchoCBEntry ¬ NIL,    ch: Courier.Handle ¬ NIL,    dH: CommOnlineDiagnostics.EchoDiagHandle ¬ NIL];      RSCBEntry:  TYPE = LONG POINTER TO RSCBObj;  RSCBObj: TYPE = RECORD [    next: RSCBEntry ¬ NIL,    ch: Courier.Handle ¬ NIL,    dH: CommOnlineDiagnostics.RS232CDiagHandle ¬ NIL];  echoProcs: EchoCBEntry ¬ NIL;  --linked list of Courier handles for callbacks.  rs232cProcs: RSCBEntry ¬ NIL;  --linked list of Courier handles for callbacks.    AddEchoHandle: PROC [    remote: System.NetworkAddress, dH: CommOnlineDiagnostics.EchoDiagHandle] =    BEGIN  --creates call back handle and adds it to the front of list.    new, e: EchoCBEntry ¬ NIL;    cH: Courier.Handle ¬ Courier.Create[remote, DiagInternal.diagCallBackPgm,      DiagInternal.version, z, transactional];    FOR e ¬ echoProcs, e.next UNTIL e = NIL DO      IF e.dH = dH THEN RETURN;  --already exists.      ENDLOOP;    new ¬ z.NEW[EchoCBObj ¬ [echoProcs, cH, dH]];    echoProcs ¬ new;    END;  --AddEchoHandle          AddRS232CHandle: PROC [    remote: System.NetworkAddress, dH: CommOnlineDiagnostics.RS232CDiagHandle] =    BEGIN  --creates call back handle and adds it to the front of list.    new, e: RSCBEntry ¬ NIL;    cH: Courier.Handle ¬ Courier.Create[remote, DiagInternal.diagCallBackPgm,      DiagInternal.version, z, transactional];    FOR e ¬ rs232cProcs, e.next UNTIL e = NIL DO      IF e.dH = dH THEN RETURN;  --already exists.      ENDLOOP;    new ¬ z.NEW[RSCBObj ¬ [rs232cProcs, cH, dH]];    rs232cProcs ¬ new;    END;  --AddRS232CHandle      Cleanup: PROC [h: Courier.Handle] =    BEGIN  -- Cleans up the callbacks.    IF h # NIL THEN      DO	Courier.Delete[h!	  Courier.Error => -- tried to delete while call in progress	    {Process.Yield[]; LOOP}];	EXIT;	ENDLOOP;    END;  -- Cleanup         Dispatcher: Courier.Dispatcher =    BEGIN    SELECT procedureNumber FROM      DiagInternal.dialupProc =>        DialupTest[cH, arguments, results];      DiagInternal.etherStatsProc =>        GetEthernetStats[cH, arguments, results];      DiagInternal.echoCountersProc =>        GetEchoCounters[cH, arguments, results];      DiagInternal.startEchoProc =>        StartEchoUser[cH, arguments, results];      DiagInternal.getEchoResultsProc =>        GetEchoResults[cH, arguments, results];      DiagInternal.rs232cLoopbackProc =>        StartRS232CTest[cH, arguments, results];      DiagInternal.getRS232CResultsProc =>        GetRS232CResults[cH, arguments, results];      ENDCASE => ERROR Courier.NoSuchProcedureNumber;    END;  -- Dispatcher          GetEchoHandle: PROC [    dH: CommOnlineDiagnostics.EchoDiagHandle, remove: BOOLEAN ¬ FALSE]    RETURNS [cH: Courier.Handle] =    BEGIN  --returns the callback handle for the specified diagnostic.    prev, e: EchoCBEntry ¬ NIL;    cH ¬ NIL;    FOR e ¬ echoProcs, e.next UNTIL e = NIL DO      IF e.dH = dH THEN	BEGIN	cH ¬ e.ch;	IF remove THEN	  BEGIN	  IF prev = NIL THEN echoProcs ¬ e.next	  ELSE prev.next ¬ e.next;	  z.FREE[@e];	  END;	EXIT;	END;      prev ¬ e;      ENDLOOP;    END;  --GetEchoHandle          GetRS232CHandle: PROC [    dH: CommOnlineDiagnostics.RS232CDiagHandle, remove: BOOLEAN ¬ FALSE]    RETURNS [cH: Courier.Handle] =    BEGIN  --returns the callback handle for the specified diagnostic.    prev, e: RSCBEntry ¬ NIL;    cH ¬ NIL;    FOR e ¬ rs232cProcs, e.next UNTIL e = NIL DO      IF e.dH = dH THEN	BEGIN	cH ¬ e.ch;	IF remove THEN	  BEGIN	  IF prev = NIL THEN rs232cProcs ¬ e.next	  ELSE prev.next ¬ e.next;	  z.FREE[@e];	  END;	EXIT;	END;      prev ¬ e;      ENDLOOP;    END;  --GetRS232CHandle          GetEchoCounters: ENTRY PROC [cH: Courier.Handle, arguments: Courier.Arguments,    results: Courier.Results] =    BEGIN ENABLE UNWIND => NULL;    eResults: DiagInternal.EchoCounterResults;    arguments[Courier.nullParameters];  -- no arguments    [eResults.pkts, eResults.bytes, eResults.time] ¬       CommDiags.GetEchoCounters[];    [] ¬ results[[@eResults, DiagInternal.DescribeEchoCounters]];    END;  -- GetEchoCounters             GetEchoResults: ENTRY PROC [cH: Courier.Handle, arguments: Courier.Arguments,    results: Courier.Results] =    BEGIN ENABLE UNWIND => NULL;    errReason: CommOnlineDiagnostics.EtherErrorReason;    params: DiagInternal.EchoResultsParams;    echoResults: DiagInternal.EchoResults;    BEGIN    arguments[[@params, DiagInternal.DescribeEchoResultsParams]];    [echoResults.totals, echoResults.hist] ¬       CommDiags.GetEchoResults[params.handle, params.stop !          UNWIND =>	    Cleanup[GetEchoHandle[params.handle, TRUE]];          CommDiags.EtherDiagError =>	    {errReason ¬ reason;	    GOTO error}];    IF params.stop THEN Cleanup[GetEchoHandle[params.handle, TRUE]];    [] ¬ results[[@echoResults, DiagInternal.DescribeEchoResults]];    -- Free the space allocated by the actual diagnostic implementation.    IF params.stop THEN CommDiags.FreeHist[echoResults.hist];    EXITS error =>      BEGIN  -- Clean up the callback handle.      Cleanup[GetEchoHandle[params.handle, TRUE]];      Courier.SignalRemoteError[        DiagInternal.etherDiagErr, [@errReason, DiagInternal.DescribeCardinal]]      END;    END;    END;  -- GetEchoResults         GetRS232CResults: ENTRY PROC [cH: Courier.Handle, arguments: Courier.Arguments,   results: Courier.Results] =   BEGIN ENABLE UNWIND => NULL;   errReason: CommOnlineDiagnostics.RS232CErrorReason;   params: DiagInternal.RS232CResultsParams;   counters: CommOnlineDiagnostics.CountType;   BEGIN   arguments[[@params, DiagInternal.DescribeRS232CResultsParams]];   [counters] ¬ CommDiags.GetRS232CResults[     LOOPHOLE[params.dH], params.stopIt !       UNWIND =>         {Cleanup[GetRS232CHandle[params.dH, TRUE]]};       CommDiags.RS232CDiagError =>         {errReason ¬ reason;	 GOTO error}];   IF params.stopIt THEN     Cleanup[GetRS232CHandle[params.dH, TRUE]];       [] ¬ results[[@counters, DiagInternal.DescribeRS232CResults]];    EXITS error =>      BEGIN  -- Clean up the callback handle.      Cleanup[GetRS232CHandle[params.dH, TRUE]];      Courier.SignalRemoteError[DiagInternal.rs232cDiagErr,        [@errReason, DiagInternal.DescribeCardinal]];      END;    END;    END;  -- GetRS232CResults        GetEthernetStats: ENTRY PROC [cH: Courier.Handle, arguments: Courier.Arguments,    results: Courier.Results] =    BEGIN ENABLE UNWIND => NULL;    errReason: CommOnlineDiagnostics.EtherErrorReason;    physicalOrder: CARDINAL;    statResults: DiagInternal.EtherStatsResults;    BEGIN    arguments[[@physicalOrder, DiagInternal.DescribeCardinal]];    [statResults.stats, statResults.time] ¬       CommDiags.GetEthernetStats[physicalOrder !        CommDiags.EtherDiagError =>	  {errReason ¬ reason;	  GOTO error}];    [] ¬ results[[@statResults, DiagInternal.DescribeEtherStatsResults]];    EXITS error => Courier.SignalRemoteError[DiagInternal.etherDiagErr,      [@errReason, DiagInternal.DescribeCardinal]];    END;    END;  -- GetEthernetStats          DialupTest: ENTRY PROC [cH: Courier.Handle, arguments: Courier.Arguments,    results: Courier.Results] =    BEGIN ENABLE UNWIND => NULL;    errReason: CommOnlineDiagnostics.RS232CErrorReason;    dialArgs: DiagInternal.DialupParams;    outcome: CommOnlineDiagnostics.DialupOutcome;       BEGIN    arguments[[@dialArgs, DiagInternal.DescribeDialup]];    outcome ¬ CommDiags.DialupTest[      dialArgs.line, dialArgs.phoneNum, dialArgs.dialerType !      CommDiags.RS232CDiagError =>  --Happens only when testing CIU.        {errReason ¬ reason;	GOTO error}];    [] ¬ results[[@outcome, DiagInternal.DescribeDialupOutcome]];    EXITS error =>      Courier.SignalRemoteError[DiagInternal.rs232cDiagErr,        [@errReason, DiagInternal.DescribeCardinal]];    END;    END;  -- DialupTest          RemoteEventReporter: CommOnlineDiagnostics.EventReporter =      BEGIN  -- Calls the remote <eventReporter> proc on behalf of      -- <StartEchoUser>.      ENABLE UNWIND => NULL;      eventParams: DiagInternal.EventRepParams ¬ [event, dH];      args: Courier.Parameters ¬ [        @eventParams, DiagInternal.DescribeEventRepParams];      results: Courier.Parameters ¬ Courier.nullParameters;      cbh: Courier.Handle ¬ GetEchoHandle[dH];            EventCallBack: DiagInternal.CourierCallProc =      BEGIN      [] ¬ Courier.Call[        cbh, DiagInternal.eventReporterNum, args, results];      END;  -- EventCallBack            DiagInternal.MakeCall[EventCallBack, cbh !          CommOnlineDiagnostics.CommError => GOTO endCall];      Courier.Free[results, z];  -- Free any storage Courier may have allocated.      EXITS endCall => NULL;      END;  -- RemoteEventReporter              StartEchoUser: ENTRY PROC [cH: Courier.Handle, arguments: Courier.Arguments,    results: Courier.Results] =    BEGIN ENABLE UNWIND => NULL;    handle: CommOnlineDiagnostics.EchoDiagHandle;    errReason: CommOnlineDiagnostics.EtherErrorReason;    BEGIN    eventRep: CommOnlineDiagnostics.EventReporter ¬ NIL;    echoStartArgs: DiagInternal.EchoStartParams;    arguments[[@echoStartArgs, DiagInternal.DescribeStartEchoParams]];        IF echoStartArgs.callback THEN eventRep ¬ RemoteEventReporter;    handle ¬ CommDiags.StartEchoUser[      echoStartArgs.target, echoStartArgs.parms, eventRep !        CommDiags.EtherDiagError => -- Too many echo users.	  {errReason ¬ reason;	  GOTO error}];    -- Check if remote client wants an event reporter; create it only it does not    -- already exist.    IF echoStartArgs.callback THEN AddEchoHandle[cH.remote, handle];    [] ¬ results[[@handle, DiagInternal.DescribeEchoHandle]];    EXITS error =>      Courier.SignalRemoteError[DiagInternal.etherDiagErr,        [@errReason, DiagInternal.DescribeCardinal]];    END;    END;  -- StartEchoUser            RemoteSetLine: CommOnlineDiagnostics.SetDiagnosticLine =      BEGIN  -- Calls the remote <setDiagnosticLine> proc on behalf of      -- <StartRS232CTest>.      ENABLE UNWIND => NULL;      setLineParams: DiagInternal.SetLineParams ¬ [lineNumber, dH];      args: Courier.Parameters ¬ [        @setLineParams, DiagInternal.DescribeSetLineParams];      results: Courier.Parameters ¬ [@lineSet, DiagInternal.DescribeBoolean];      cbh: Courier.Handle ¬ GetRS232CHandle[dH];            SetLineCallBack: DiagInternal.CourierCallProc =        BEGIN        [] ¬ Courier.Call[	  cbh, DiagInternal.setDiagLineNum, args, results];        END;  -- SetLineCallBack            DiagInternal.MakeCall[SetLineCallBack, cbh !          CommOnlineDiagnostics.CommError => GOTO endCall];      Courier.Free[results, z];  -- Free any storage Courier may have allocated.      EXITS endCall => lineSet ¬ FALSE;      END;  -- RemoteSetLine          RemoteWriteMsg: CommOnlineDiagnostics.WriteMsg =      BEGIN  -- Calls the remote <WriteMessage> proc on behalf of      -- <StartRS232CTest>.      ENABLE UNWIND => NULL;      writeMsgParams: DiagInternal.WriteMsgParams ¬ [msg, dH];      args: Courier.Parameters ¬ [        @writeMsgParams, DiagInternal.DescribeWriteMsgParams];      results: Courier.Parameters ¬ Courier.nullParameters;      cbh: Courier.Handle ¬ GetRS232CHandle[dH];            WriteMsgCallBack: DiagInternal.CourierCallProc =        BEGIN        [] ¬ Courier.Call[	  cbh, DiagInternal.writeRS232CMsgNum, args, results];        END;  -- WriteMsgCallBack	      DiagInternal.MakeCall[WriteMsgCallBack, cbh !          CommOnlineDiagnostics.CommError => GOTO endCall];      Courier.Free[results, z];  -- Free any storage Courier may have allocated.      EXITS endCall => NULL;      END;  -- RemoteWriteMsg               RemoteModemChange: CommOnlineDiagnostics.ModemChange =     BEGIN  -- Calls the remote <ModemChange> proc on behalf of      -- <StartRS232CTest>.     ENABLE UNWIND => NULL;     modemChangeParams: DiagInternal.ModemChangeParams ¬       [modemSignal, state, dH];     args: Courier.Parameters ¬ [       @modemChangeParams, DiagInternal.DescribeModemChangeParams];     results: Courier.Parameters ¬ Courier.nullParameters;     cbh: Courier.Handle ¬ GetRS232CHandle[dH];          ModemChangeCallBack: DiagInternal.CourierCallProc =       BEGIN       [] ¬ Courier.Call[         cbh, DiagInternal.modemChangeNum, args, results];       END;  -- ModemChangeCallBack            DiagInternal.MakeCall[ModemChangeCallBack, cbh !         CommOnlineDiagnostics.CommError => GOTO endCall];     Courier.Free[results, z];  -- Free any storage Courier may have allocated.     EXITS endCall => NULL;     END;  -- RemoteModemChange            StartRS232CTest: ENTRY PROC [cH: Courier.Handle, arguments: Courier.Arguments,    results: Courier.Results] =    BEGIN ENABLE UNWIND => NULL;    handle: CommOnlineDiagnostics.RS232CDiagHandle;    errReason: CommOnlineDiagnostics.RS232CErrorReason;    createHandle: BOOLEAN ¬ FALSE;    rs232cArgs: DiagInternal.RS232CTestParams;    sl: CommOnlineDiagnostics.SetDiagnosticLine ¬ NIL;    wm: CommOnlineDiagnostics.WriteMsg ¬ NIL;    mc: CommOnlineDiagnostics.ModemChange ¬ NIL;    BEGIN    arguments[[@rs232cArgs, DiagInternal.DescribeRS232CParams]];    -- Check if remote client wants an event reporter; create it only it does not    -- already exist.    IF rs232cArgs.callSetLine THEN sl ¬ RemoteSetLine;    IF rs232cArgs.callWrite THEN wm ¬ RemoteWriteMsg;    IF rs232cArgs.callModemChange THEN mc ¬ RemoteModemChange;    handle ¬ CommDiags.StartRS232CTest[      rs232cArgs.params, sl, wm, mc !        CommDiags.RS232CDiagError =>          {errReason ¬ reason;	  GOTO error}];    SELECT TRUE FROM       rs232cArgs.callSetLine,      rs232cArgs.callModemChange,      rs232cArgs.callWrite => AddRS232CHandle[cH.remote, handle];      ENDCASE;    [] ¬ results[[@handle, DiagInternal.DescribeLoopbackHandle]];    EXITS error =>      Courier.SignalRemoteError[DiagInternal.rs232cDiagErr,        [@errReason, DiagInternal.DescribeCardinal]];    END;    END;  -- StartRS232CTest      ServerOn: PUBLIC PROC =    BEGIN    Courier.ExportRemoteProgram[DiagInternal.diagPgmNumber, DiagInternal.versions,      Dispatcher, "CommOnlineDiags"L, z, transactional];    END;  -- ServerOn          ServerOff: PUBLIC PROC =    BEGIN    Courier.UnexportRemoteProgram[DiagInternal.diagPgmNumber,      DiagInternal.versions];    END;  -- ServerOff        END.  LOG 6-Jul-83 10:42:28 SMA  Created file.   17-Oct-83 12:11:41 SMA  Uses new diagnostics interfaces.22-Nov-83 16:03:43 SMA  Don't delete callback handle while call in progress.        4-Dec-83 17:41:14 SMA  Pass host number of caller in echo and RS232C tests. 8-Dec-83 12:40:05 SMA  Leave callback intact after failed call.25-Jan-85 11:55:53 SMA  Changes for multiport board. 5-Jan-87 14:28:57 AOF  Filling out USING lists.29-Oct-87 12:48:11 BKI  Fixed AR 8673.10-Nov-87 10:55:05 BKI  Fixed AR 8673 again (scope of ENABLE was too small).
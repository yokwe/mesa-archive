-- File: RS232CDiagnosticImpl.mesa - last edit:-- AOF                  5-Jan-87 14:32:21-- BKI                 11-Nov-87 11:24:21-- SMA                  5-Sep-85 12:49:00-- Copyright (C) 1984, 1985, 1987 by Xerox Corporation. All rights reserved.  DIRECTORY  CommDiags USING [],  CommOnlineDiagnostics USING [    CountType, DialupOutcome, ModemChange, PatternType, RS232CDiagHandle,    RS232CDiagObject, RS232CErrorReason, RS232CParams, SetDiagnosticLine,    WriteMsg],  Dialup USING [AbortCall, Dial, DialerType, Number, Outcome],  Environment USING [Block, Byte, bytesPerWord],  File USING [File, nullFile],  Heap USING [systemZone],  Inline USING [BITAND],  Process USING [Abort, Detach, Pause, SecondsToTicks],  RS232C USING [    ChannelHandle, ChannelInUse, ChannelSuspended, CharLength, CommParamObject,    CompletionHandle, Create, Delete, DeviceStatus, Get, GetStatus,    InvalidLineNumber, InvalidParameter, LatchBitClearMask, LineSpeed,    NoRS232CHardware, PhysicalRecord, Put, SetParameter, Suspend, SyncChar,    SyncCount, TransferStatus, TransferWait, UnimplementedFeature],  RS232CCorrespondents USING [    cmcII, ibm2770Host, ibm3270Host, ibm6670, ibm6670Host, nsSystemElement,    siemens9750, system6, ttyHost, xerox850, xerox860],  RS232CFace USING [Handle, Off, On],  Space USING [Interval, Map, nullInterval, Unmap, wordsPerPage],  String USING [InvalidNumber, StringToDecimal],  System USING [    GetClockPulses, GetGreenwichMeanTime, PulsesToMicroseconds,    SecondsSinceEpoch];RS232CDiagnosticImpl: MONITOR  IMPORTS    Dialup, Heap, Inline, Process, RS232C, RS232CFace, Space,    String, System  EXPORTS CommDiags =  BEGIN  --The implementation for pilot RS232C loopback diagnostic and dialer diagnostic.    Seal: TYPE = MACHINE DEPENDENT {unsealed(0), handleSeal(123010B)};    asyncFrameTO: CARDINAL = 500;  -- Buffer size for async test.  maxSendBuffers: CARDINAL = 6;  maxReceiveBuffers: CARDINAL = 7;  testHeaderLength: CARDINAL = 10;  testSendTrailerLength: CARDINAL = 1;  testReceiveTrailerLength: CARDINAL = 3;  zone: UNCOUNTED ZONE = Heap.systemZone;  RS232CDiagHandle: PUBLIC TYPE = LONG POINTER TO RS232CDiagObject;  RS232CDiagObject: PUBLIC TYPE = RECORD [    loopTest, watcher: PROCESS,    send, receive: PROCESS RETURNS[CARDINAL],    packetsSent, packetsReceived: CARDINAL,    watcherActive: BOOLEAN,    cH: RS232C.ChannelHandle,    sh: Space.Interval,    lineSpeed: RS232C.LineSpeed,    wordsPerSendReceiveBuffer: CARDINAL,    useEbcdic: BOOLEAN,    printErr: BOOLEAN,    receiveSeqNum, seqNumber, lastGoodSeq: CARDINAL,    pleaseStop: BOOLEAN,    pattern: CommOnlineDiagnostics.PatternType,    startData: CARDINAL,  -- place in block where actual data begins.    countType: CommOnlineDiagnostics.CountType,    timeOfLastPollSSE, timeOfLastSent, timeOfLastRecv: LONG CARDINAL,    signalStat: RS232C.DeviceStatus,    commParamObject: RS232C.CommParamObject,    seal: Seal ¬ unsealed];    RS232CDiagError: PUBLIC ERROR [reason:    CommOnlineDiagnostics.RS232CErrorReason] = CODE;      IncrementSeqNum: PROC [current: CARDINAL] RETURNS [next: CARDINAL] =    BEGIN -- return next sequence number    next ¬ current + 1;    IF next > 9999 THEN next ¬ 1000; -- sequence numbers must be 4 digits exactly    END; -- IncrementSeqNum     DialupTest: PUBLIC PROC [    rs232ClineNumber: CARDINAL,    phoneNumber: LONG POINTER TO Dialup.Number,    dialerType: Dialup.DialerType ¬ RS366]    RETURNS [outcome: CommOnlineDiagnostics.DialupOutcome] =    BEGIN        DialWatcher: PROC =       BEGIN ENABLE ABORTED => GOTO exit;      FOR j: CARDINAL IN [0..60) DO -- wait for 1 minute         Process.Pause[Process.SecondsToTicks[1]];	 ENDLOOP;      Dialup.AbortCall[rs232ClineNumber];      EXITS exit => NULL;      END; -- DialWatcher         reason: CommOnlineDiagnostics.RS232CErrorReason;     status:  Dialup.Outcome ¬ aborted;    h: RS232C.ChannelHandle;  --Used only with the CIU.    defaultParams: RS232C.CommParamObject ¬ [      duplex: full, lineType: asynchronous, lineSpeed: bps1200,      accessDetail: dialConn[dialMode: manual, dialerNumber: 0, retryCount: 3]];    created: BOOLEAN ¬ FALSE;    fh: RS232CFace.Handle;    watcher: PROCESS ¬ NIL;        IF dialerType # RS366 THEN ERROR RS232CDiagError[unimplementedFeature];            BEGIN ENABLE  --For the Create and SetParameter used with the CIU.      BEGIN      RS232C.UnimplementedFeature =>	{reason ¬ unimplementedFeature; GOTO error};      RS232C.InvalidParameter =>	{reason ¬ invalidParameter; GOTO error};      RS232C.NoRS232CHardware =>	{reason ¬ noHardware;	GOTO error};      RS232C.InvalidLineNumber =>	{reason ¬ noSuchLine;	GOTO error};      RS232C.ChannelInUse =>	{reason ¬ channelInUse;	GOTO error};      END;  -- catch series           IF rs232ClineNumber >= 100B THEN      BEGIN  --CIU has to have the channel created and DTR up before dialing.      h ¬ RS232C.Create[        rs232ClineNumber, @defaultParams, preemptAlways, preemptNever];      created ¬ TRUE;      RS232C.SetParameter[h, [dataTerminalReady[TRUE]]];      END    ELSE fh ¬ RS232CFace.On[rs232ClineNumber];  --Create does this in CIU case.    watcher ¬ FORK DialWatcher[];    status ¬ Dialup.Dial[      rs232ClineNumber, phoneNumber, 1, RS366];      Process.Abort[watcher];    JOIN watcher;    outcome ¬ LOOPHOLE[status];    IF rs232ClineNumber >= 100B THEN RS232C.Delete[h]  --CIU only.    ELSE RS232CFace.Off[fh];  --Delete does this in CIU case.    EXITS error =>      BEGIN      IF created THEN RS232C.Delete[h];      ERROR RS232CDiagError[reason];      END;    END;  --enabled clause    END; -- DialupTest      StartRS232CTest: PUBLIC PROC [    rs232cParams: CommOnlineDiagnostics.RS232CParams,    setDiagnosticLine: CommOnlineDiagnostics.SetDiagnosticLine ¬ NIL,    writeMsg: CommOnlineDiagnostics.WriteMsg ¬ NIL,    modemChange: CommOnlineDiagnostics.ModemChange ¬ NIL]    RETURNS [dH: CommOnlineDiagnostics.RS232CDiagHandle ¬ NIL] =    BEGIN    reason: CommOnlineDiagnostics.RS232CErrorReason;    h: RS232CDiagHandle;    -- Initialization.    IF rs232cParams.safetyTOInMsecs < 5000 THEN RETURN;    h ¬ zone.NEW[RS232CDiagObject];    h.seal ¬ handleSeal;    h.loopTest ¬ h.watcher ¬ NIL;    h.send ¬ h.receive ¬ NIL;    h.packetsSent ¬ h.packetsReceived ¬ 0;    h.watcherActive ¬ TRUE;    h.sh ¬ Space.nullInterval;    h.lineSpeed ¬ rs232cParams.lineSpeed;    h.wordsPerSendReceiveBuffer ¬ Words[testHeaderLength] +      Words[rs232cParams.dataLengths.high] + Words[MAX[testSendTrailerLength,      testReceiveTrailerLength]];    h.useEbcdic ¬ TRUE;    h.printErr ¬ TRUE;    h.receiveSeqNum ¬ h.seqNumber ¬ h.lastGoodSeq ¬ 1000;    h.pleaseStop ¬ FALSE;    h.pattern ¬ rs232cParams.pattern;    IF rs232cParams.lineType = asynchronous THEN      {h.startData ¬ 0; rs232cParams.dataLengths.high ¬ 500}    ELSE h.startData ¬ 4;    h.countType ¬ [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];    h.timeOfLastPollSSE ¬ h.timeOfLastSent ¬ h.timeOfLastRecv ¬      System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]];    h.signalStat ¬ [      FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE, FALSE];        IF rs232cParams.dataLengths.low < 4 THEN rs232cParams.dataLengths.low ¬ 4;    IF rs232cParams.dataLengths.high < 4 THEN rs232cParams.dataLengths.high ¬ 4;    -- if a bitsynch test is requested then the char length should definately be 8 (despite what the client may tell us)    -- and the parity should probably (assume definately for Minaret) be "none"    IF rs232cParams.lineType=bitSynchronous THEN      BEGIN      rs232cParams.charLength ¬ RS232C.CharLength[8];      rs232cParams.parity ¬ none;      END;    h.commParamObject.lineType ¬ rs232cParams.lineType;    h.commParamObject.lineSpeed ¬ rs232cParams.lineSpeed;    BEGIN ENABLE      BEGIN      RS232C.NoRS232CHardware =>	{reason ¬ noHardware;	GOTO error};      RS232C.InvalidLineNumber =>	{reason ¬ noSuchLine;	GOTO error};      RS232C.ChannelInUse =>	{reason ¬ channelInUse;	GOTO error};      END;  -- catch series                   h.cH ¬ RS232C.Create[      rs232cParams.lineNumber, @h.commParamObject, preemptAlways,      preemptNever];            h.loopTest ¬ FORK LoopTest[h, rs232cParams, setDiagnosticLine, writeMsg,      modemChange];    RETURN [LOOPHOLE[h]];    EXITS error => ERROR RS232CDiagError[reason];    END;  -- enabled clause     END; -- RS232CLoopback          Watcher: PROC [    dH: RS232CDiagHandle,    rs232cParams: CommOnlineDiagnostics.RS232CParams,    writeMessage: CommOnlineDiagnostics.WriteMsg] =      BEGIN      -- haveStopped: BOOLEAN ¬ FALSE;      DO	IF (TimeCheck[dH, rs232cParams.safetyTOInMsecs]) THEN	  BEGIN	  StopRS232CTest[dH, FALSE, FALSE];	  EXIT;	  END;        IF ((System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]] -	  dH.timeOfLastSent) > 30) AND (~dH.pleaseStop) THEN	    BEGIN	    dH.timeOfLastSent ¬	      System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]];	    END;	Process.Pause[Process.SecondsToTicks[1]];	IF dH.pleaseStop THEN EXIT;	ENDLOOP;      END; -- Watcher  LoopTest: PROC [    dH: RS232CDiagHandle,    rs232cParams: CommOnlineDiagnostics.RS232CParams,    setDiagnosticLine: CommOnlineDiagnostics.SetDiagnosticLine ¬ NIL,    writeMessage: CommOnlineDiagnostics.WriteMsg ¬ NIL,    modemChange: CommOnlineDiagnostics.ModemChange ¬ NIL] =    BEGIN    receiveStarted:   BOOLEAN ¬ FALSE;    syncCount: RS232C.SyncCount ¬ 2;    syncChar: RS232C.SyncChar ¬ 62B;    frameTimeout: CARDINAL ¬ 0;    reason: CommOnlineDiagnostics.RS232CErrorReason;                  BEGIN ENABLE      BEGIN      RS232C.UnimplementedFeature =>        {reason ¬ unimplementedFeature;        GOTO error};      RS232C.InvalidParameter =>        {reason ¬ invalidParameter;        GOTO error};      END;  -- catch series.            -- Set the parameters not available to the user (those dependent on the     --   correspondent).     SELECT rs232cParams.correspondent FROM       RS232CCorrespondents.xerox860, RS232CCorrespondents.xerox850,       RS232CCorrespondents.nsSystemElement =>         BEGIN	 dH.useEbcdic ¬ FALSE;	 syncChar ¬ 26B;   -- irrelevent for nsSystemElement	 syncCount ¬ 2;    --       "            "	 frameTimeout ¬ 0;	 END;       RS232CCorrespondents.system6, RS232CCorrespondents.cmcII,       RS232CCorrespondents.ibm3270Host, RS232CCorrespondents.ibm2770Host,       RS232CCorrespondents.ibm6670Host, RS232CCorrespondents.ibm6670 =>         BEGIN	 dH.useEbcdic ¬ TRUE;	 syncChar ¬ 62B;	 syncCount ¬ 2;	 frameTimeout ¬ 0;	 END;       RS232CCorrespondents.siemens9750 =>         BEGIN	 dH.useEbcdic ¬ FALSE;	 syncChar ¬ 26B;	 syncCount ¬ 2;	 frameTimeout ¬ 0;	 END;       RS232CCorrespondents.ttyHost =>         BEGIN	 dH.useEbcdic ¬ FALSE;	 frameTimeout ¬ 300;	 END;       ENDCASE;    IF rs232cParams.lineType = asynchronous THEN      BEGIN  -- For CIU asynchronous test.      IF setDiagnosticLine # NIL THEN         [] ¬ setDiagnosticLine[rs232cParams.lineNumber, LOOPHOLE[dH]];      RS232C.SetParameter[dH.cH, [stopBits[1 -- stopBits --]]];      RS232C.SetParameter[dH.cH, [frameTimeout[asyncFrameTO]]];      END    ELSE       RS232C.SetParameter[dH.cH, [frameTimeout[frameTimeout]]];          RS232C.SetParameter[dH.cH, [correspondent[rs232cParams.correspondent]]];    RS232C.SetParameter[dH.cH, [dataTerminalReady[TRUE]]];    RS232C.SetParameter[dH.cH, [charLength[rs232cParams.charLength]]];    RS232C.SetParameter[dH.cH, [lineSpeed[rs232cParams.lineSpeed]]];    RS232C.SetParameter[dH.cH, [parity[rs232cParams.parity]]];    IF rs232cParams.lineType = byteSynchronous THEN {      RS232C.SetParameter[dH.cH, [syncCount[syncCount]]];      RS232C.SetParameter[dH.cH, [syncChar[syncChar]]]};    RS232C.SetParameter[dH.cH, [requestToSend[TRUE]]];    RS232C.SetParameter[dH.cH, [clockSource[rs232cParams.clockSource]]];        IF modemChange # NIL THEN ShowSig[dH, TRUE, modemChange];            FOR interim: CARDINAL IN [0..30) DO      Process.Pause[Process.SecondsToTicks[1]];--this waits for DSR to come back      IF RS232C.GetStatus[dH.cH !        RS232C.ChannelSuspended => GOTO stopped].stat.dataSetReady          OR (~rs232cParams.waitForDSR AND interim >= 3) THEN EXIT;      REPEAT FINISHED => {        IF modemChange # NIL THEN ShowSig[dH, TRUE, modemChange]; 	GOTO noDSR};      ENDLOOP;    IF modemChange # NIL THEN ShowSig[dH, TRUE, modemChange];    dH.sh ¬ Space.Map[[File.nullFile, 0,      (dH.wordsPerSendReceiveBuffer * (maxSendBuffers + maxReceiveBuffers)        + Space.wordsPerPage-1) / Space.wordsPerPage]];      BEGIN ENABLE UNWIND =>        IF dH.sh # Space.nullInterval THEN	  {[] ¬ Space.Unmap[dH.sh.pointer]; dH.sh ¬ Space.nullInterval};      dH.receive ¬ FORK Receiver[dH, rs232cParams, dH.sh.pointer, writeMessage];      Process.Pause[Process.SecondsToTicks[2]];      dH.send ¬ FORK Sender[        dH, dH.sh.pointer + (dH.wordsPerSendReceiveBuffer * maxReceiveBuffers),        rs232cParams, writeMessage, modemChange];      Process.Detach[dH.watcher ¬ FORK Watcher[dH, rs232cParams, writeMessage]];      END; -- ENABLE UNWIND    EXITS      noDSR =>           {IF modemChange # NIL THEN ShowSig[dH, TRUE, modemChange];	    StopRS232CTest[dH, FALSE, TRUE]};      error => ERROR RS232CDiagError[reason];      stopped => StopRS232CTest[dH, FALSE, TRUE];    END;  -- enabled clause.    END; -- LoopTest      ReasonableNumberOfSecondsToWait: PROC [lineSpeed: RS232C.LineSpeed] RETURNS [CARDINAL] = {    xlate: PACKED ARRAY RS232C.LineSpeed OF [0..256) = [    -- speed + 10%        bps50: 60+6,   bps75: 40+4,  bps110: 30+3, bps134p5: 23+3,       bps150: 20+2,  bps300: 10+1,  bps600:  5+1,  bps1200:  3+1,      bps2400:  2+1, bps3600:    1, bps4800:    1,  bps7200:    1,      bps9600:    1, bps19200:   1, bps28800:   1,  bps38400:   1,      bps48000:   1, bps56000:   1, bps57600:   1];    IF lineSpeed NOT IN RS232C.LineSpeed THEN RETURN[5];    RETURN[xlate[lineSpeed]]};  Words: PROC [bytes: CARDINAL] RETURNS [words: CARDINAL] = INLINE {    words ¬ bytes/Environment.bytesPerWord;    IF (bytes MOD Environment.bytesPerWord) # 0 THEN      words ¬ words + 1};    displaySendMP: BOOLEAN = TRUE;  ShowSig: PROC [    dH: RS232CDiagHandle, always: BOOLEAN,    modemChange: CommOnlineDiagnostics.ModemChange] =    BEGIN ENABLE RS232C.ChannelSuspended => GOTO suspended;    stat: RS232C.DeviceStatus ¬ RS232C.GetStatus[dH.cH];    IF (always OR (stat.dataSetReady # dH.signalStat.dataSetReady)) THEN       modemChange[dataSetReady, stat.dataSetReady, LOOPHOLE[dH]];    IF (always OR (stat.clearToSend # dH.signalStat.clearToSend)) THEN       modemChange[clearToSend, stat.clearToSend, LOOPHOLE[dH]];    IF (always OR (stat.carrierDetect # dH.signalStat.carrierDetect)) THEN       modemChange[carrierDetect, stat.carrierDetect, LOOPHOLE[dH]];    IF (always OR (stat.ringIndicator # dH.signalStat.ringIndicator)) THEN       modemChange[ringIndicator, stat.ringIndicator, LOOPHOLE[dH]];    IF (always OR (stat.ringHeard # dH.signalStat.ringHeard)) THEN       modemChange[ringHeard, stat.ringHeard, LOOPHOLE[dH]];    dH.signalStat ¬ stat;    EXITS suspended => NULL;    END; -- ShowSig  Sender: PROC [    dH: RS232CDiagHandle,    sendBufferSpace: LONG POINTER,    rs232cParams: CommOnlineDiagnostics.RS232CParams,    writeMessage: CommOnlineDiagnostics.WriteMsg,    modemChange: CommOnlineDiagnostics.ModemChange]    RETURNS [packetsSent: CARDINAL] =    BEGIN    sendBufferState: ARRAY [0..maxSendBuffers) OF RECORD [      busy: BOOLEAN, compH: RS232C.CompletionHandle,      phys: RS232C.PhysicalRecord, status: RS232C.TransferStatus];    index:     CARDINAL ¬ 0;    totalCount: CARDINAL ¬ 0;    seqNumber: CARDINAL ¬ 1000;    testBodyLength: CARDINAL ¬ 0;    dMask: Environment.Byte ¬ 255; -- for masking out all but data bits in async.        SendOneFrame: PROC [testBodyLength: CARDINAL] =      BEGIN      h: Environment.Block = sendBufferState[index].phys.header;      b: Environment.Block = sendBufferState[index].phys.body;      t: Environment.Block = sendBufferState[index].phys.trailer;      asciiHeader:  PACKED ARRAY [0..14] OF Environment.Byte = [        2--STX--, 60B, 60B, 60B, 60B, 61B, 62B,        63B, 64B, 65B, 66B, 67B, 70B, 71B--9--, 60B];      ebcdicHeader: PACKED ARRAY [0..14] OF Environment.Byte = [        2--STX-- , 360B, 360B, 360B, 360B, 361B, 362B,        363B, 364B, 365B, 366B, 367B, 370B, 371B --9--, 360B];     --  useEbcdic:       BOOLEAN  = FALSE;      ebcdic0:         CARDINAL = 360B;      ebcdicV:         CARDINAL = 345B;            IF rs232cParams.lineType # asynchronous THEN        BEGIN	-- display five signals	b.blockPointer[b.startIndex+0] ¬ ((seqNumber/1000) MOD 10 + '0) - 0C;	b.blockPointer[b.startIndex+1] ¬ ((seqNumber/ 100) MOD 10 + '0) - 0C;	b.blockPointer[b.startIndex+2] ¬ ((seqNumber / 10) MOD 10 + '0) - 0C;	b.blockPointer[b.startIndex+3] ¬ ((seqNumber)      MOD 10 + '0) - 0C;	IF (seqNumber ¬ seqNumber + 1) = 10000 THEN seqNumber ¬ 1000;	IF dH.useEbcdic THEN	  BEGIN	  FOR i: CARDINAL IN [0..testHeaderLength) DO	    h.blockPointer[h.startIndex+i] ¬ ebcdicHeader[i]	    ENDLOOP;	  FOR i: CARDINAL IN [0..4) DO  -- sequence number	    b.blockPointer[b.startIndex+i] ¬ b.blockPointer[b.startIndex+i]	      + ebcdic0 - ('0 - 0C)	    ENDLOOP;	  END	ELSE 	  BEGIN	  FOR i: CARDINAL IN [0..testHeaderLength) DO	    h.blockPointer[h.startIndex+i] ¬ asciiHeader[i]	    ENDLOOP;	  END;	t.blockPointer[t.startIndex + 0] ¬ 3B;	  --ETX (same for both ASCII and EBCDIC)	END  -- lineType # async.      ELSE -- lineType = async	BEGIN	testBodyLength ¬ asyncFrameTO;        dMask ¬ SELECT rs232cParams.charLength FROM          8 => 255,	  7 => 127,	  6 => 63,	  ENDCASE => 31;        IF rs232cParams.pattern = byteIncr THEN	   {b.blockPointer[b.startIndex+0] ¬ 0; dH.startData ¬ 1};	END;           -- Fill in the data.         SELECT rs232cParams.pattern FROM       zero => FOR i: CARDINAL IN [dH.startData..testBodyLength) DO	  b.blockPointer[b.startIndex+i] ¬ 0 ENDLOOP;       ones => FOR i: CARDINAL IN [dH.startData..testBodyLength) DO	  b.blockPointer[b.startIndex+i] ¬ Inline.BITAND[377B, dMask] ENDLOOP;       oneZeroes => FOR i: CARDINAL IN [dH.startData..testBodyLength) DO	  b.blockPointer[b.startIndex+i] ¬ Inline.BITAND[252B, dMask] ENDLOOP;       constant => FOR i: CARDINAL IN [dH.startData..testBodyLength) DO	  b.blockPointer[b.startIndex+i] ¬ Inline.BITAND[rs232cParams.constant,	          dMask] ENDLOOP;       ENDCASE => {FOR i: CARDINAL IN [dH.startData..testBodyLength)	  DO	    SELECT (b.blockPointer[b.startIndex+i-1]) FROM --avoid some char	       2B => b.blockPointer[b.startIndex+i] ¬ 4B; -- ETX	       4B => b.blockPointer[b.startIndex+i] ¬ 6B; -- AsciiENQ	       17B => b.blockPointer[b.startIndex+i] ¬ 24B; -- DLE,FlowControls	       26B => b.blockPointer[b.startIndex+i] ¬ 30B; -- AsciiETB	       36B => b.blockPointer[b.startIndex+i] ¬ 40B; -- ITB	       45B => b.blockPointer[b.startIndex+i] ¬ 47B; -- EbcdicETB	       54B => b.blockPointer[b.startIndex+i] ¬ 56B; -- EbcdicENQ	       61B => b.blockPointer[b.startIndex+i] ¬ 63B; -- EbcdicSyn	       202B => b.blockPointer[b.startIndex+i] ¬ 204B; -- AltoETX	       ENDCASE => b.blockPointer[b.startIndex+i] ¬		   Inline.BITAND[(b.blockPointer[b.startIndex+i-1] + 1), dMask];	  ENDLOOP};      sendBufferState[index].phys.body.stopIndexPlusOne ¬	sendBufferState[index].phys.body.startIndex + testBodyLength;      sendBufferState[index].compH ¬ RS232C.Put[        dH.cH, @sendBufferState[index].phys];      IF modemChange # NIL THEN ShowSig[dH, FALSE, modemChange];      sendBufferState[index].busy ¬ TRUE;      packetsSent ¬ packetsSent + 1;      END; -- SendOneFrame     WaitSendComplete: PROC =       BEGIN       bytes: CARDINAL;       [bytes, sendBufferState[index].status] ¬ RS232C.TransferWait[         dH.cH, sendBufferState[index].compH];       sendBufferState[index].busy ¬ FALSE;       dH.timeOfLastSent ¬ System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]];             -- update states, always       SELECT sendBufferState[index].status FROM	  success =>	    BEGIN	    IF rs232cParams.lineType = asynchronous THEN	      dH.countType.sendOk ¬ dH.countType.sendOk + bytes	    ELSE dH.countType.sendOk ¬ dH.countType.sendOk + 1;	    dH.countType.bytesSent ¬ dH.countType.bytesSent + bytes;	    END;	  --  This is how the outstanding frames end during shutdown.	  ENDCASE => --  This is how the outstanding frames end during shutdown.	    IF ~dH.pleaseStop THEN	      BEGIN	      dH.countType.sendErrors ¬ dH.countType.sendErrors + 1;	      IF writeMessage # NIL THEN	        writeMessage[sendError, LOOPHOLE[dH]];	      END;        END;   -- WaitSendComplete          testCnt: CARDINAL ¬ 0;    IF rs232cParams.lineType = asynchronous THEN      testBodyLength ¬ asyncFrameTO    ELSE testBodyLength ¬ rs232cParams.dataLengths.high;        FOR i: CARDINAL IN [0..maxSendBuffers) DO      p: LONG POINTER = sendBufferSpace + i*dH.wordsPerSendReceiveBuffer;      IF rs232cParams.lineType = asynchronous THEN        sendBufferState[i] ¬ [  	  busy: FALSE, compH: NULL, status: NULL,	  phys: [  -- no header or trailer for asynchronous, so fudge it.	    header:  [p,  0, 0],	    body:    [p, 0, testBodyLength],	    trailer: [p, testBodyLength, testBodyLength]]]      ELSE        sendBufferState[i] ¬ [          busy: FALSE, compH: NULL, status: NULL,	  phys: [	    header:  [p,  0, testHeaderLength],            body:    [p, testHeaderLength, testHeaderLength+testBodyLength],            trailer: [p, testHeaderLength+testBodyLength,	            testHeaderLength+testBodyLength+testSendTrailerLength]]];      ENDLOOP;    packetsSent ¬ 0; index ¬ 0;    totalCount ¬ rs232cParams.testCount;        BEGIN ENABLE RS232C.ChannelSuspended =>   GOTO quitSend;    UNTIL dH.pleaseStop DO      IF totalCount > 0 THEN  -- If totalCount = 0, run forever.        IF testCnt >= totalCount THEN EXIT;      IF sendBufferState[index].busy THEN        WaitSendComplete[];      SendOneFrame[testBodyLength];      -- If totalCount = 0, run forever.      IF totalCount > 0 THEN testCnt ¬ testCnt + 1;      SELECT TRUE FROM        rs232cParams.lineType = asynchronous =>	  NULL;  -- no concept of framing for asynchronous line.	rs232cParams.dataLengths.high = rs232cParams.dataLengths.low =>	  NULL;  -- constant testBodyLength.	testBodyLength < rs232cParams.dataLengths.low =>          testBodyLength ¬ rs232cParams.dataLengths.high;	ENDCASE => testBodyLength ¬ testBodyLength - 1;     ENDLOOP;      GOTO quitSend;    EXITS      quitSend =>        BEGIN-- ****** add some MPcode display to indicate the test is running ******        THROUGH [0..maxSendBuffers] DO          IF sendBufferState[index].busy THEN             WaitSendComplete[ ! RS232C.ChannelSuspended => CONTINUE];          IF (index ¬ index+1) = maxSendBuffers THEN index ¬ 0;          ENDLOOP;	END; -- quitSend     END; -- BEGIN ENABLE    END; -- Sender	  Receiver: PROC [    dH: RS232CDiagHandle,    rs232cParams: CommOnlineDiagnostics.RS232CParams,    receiveSpace: LONG POINTER,    writeMessage: CommOnlineDiagnostics.WriteMsg]     RETURNS [recieveGoodFrames: CARDINAL] =    BEGIN    recieveFrames: CARDINAL ¬ 0;    index: CARDINAL;    dMask: Environment.Byte ¬ 255; -- for masking out all but data bits in async.    receiveBufferState: ARRAY [0..maxReceiveBuffers) OF RECORD [      busy: BOOLEAN, compH: RS232C.CompletionHandle,      phys: RS232C.PhysicalRecord];    testBodyLength: CARDINAL;    QueueBufferForReceive: PROC =      BEGIN      receiveBufferState[index].compH ¬        RS232C.Get[dH.cH,@receiveBufferState[index].phys];      receiveBufferState[index].busy ¬ TRUE      END;  --QueueBufferForReceive  	        WaitReceiveComplete: PROC [testBodyLength: CARDINAL] =      BEGIN      bytes: CARDINAL;      status: RS232C.TransferStatus;      dataOk: BOOLEAN ¬ FALSE;          [bytes, status] ¬ RS232C.TransferWait[        dH.cH, receiveBufferState[index].compH];      receiveBufferState[index].busy ¬ FALSE;      dH.timeOfLastRecv ¬ System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]];                      SELECT status FROM        success =>	  {SELECT rs232cParams.lineType FROM	    asynchronous =>	      dH.countType.bytesRec ¬ dH.countType.bytesRec + bytes;	    ENDCASE =>  -- bitsynchronous, bytesynchronous have checksum stripped.	      dH.countType.bytesRec ¬ dH.countType.bytesRec + bytes - 2;	   dataOk ¬ CheckData[index, bytes];	  };	deviceError =>	  BEGIN          mask: RS232C.LatchBitClearMask;          deviceStatus: RS232C.DeviceStatus = RS232C.GetStatus[dH.cH];          IF deviceStatus.breakDetected THEN 	    dH.countType.breakDetected ¬ dH.countType.breakDetected + 1;          IF deviceStatus.dataLost THEN {	    dH.countType.dataLost ¬ dH.countType.dataLost + 1;	    };	  -- reset latches          mask ¬ [	    statusAborted: FALSE, dataLost: TRUE, breakDetected: TRUE,	    clearToSend: FALSE, dataSetReady: FALSE, carrierDetect: FALSE,	    ringHeard: FALSE, ringIndicator: FALSE, deviceError: FALSE];          RS232C.SetParameter[dH.cH, [latchBitClear[mask]]];	  END;  --deviceError        dataLost =>	  BEGIN          mask: RS232C.LatchBitClearMask;          writeError: BOOLEAN = FALSE;	  dH.countType.dataLost ¬ dH.countType.dataLost + 1;	  -- reset dataLost latch          mask ¬ [	    statusAborted: FALSE, dataLost: TRUE, breakDetected: FALSE,	    clearToSend: FALSE, dataSetReady: FALSE, carrierDetect: FALSE,	    ringHeard: FALSE, ringIndicator: FALSE, deviceError: FALSE];            RS232C.SetParameter[dH.cH, [latchBitClear[mask]]];	  END;        checksumError =>	  dH.countType.checkSum ¬ dH.countType.checkSum + 1;        parityError =>	  dH.countType.parity ¬ dH.countType.parity + 1;        invalidChar =>	  dH.countType.invalidChar ¬ dH.countType.invalidChar + 1;        invalidFrame =>	  dH.countType.invalidFrame ¬ dH.countType.invalidFrame + 1;        asynchFramingError =>	  dH.countType.asynchFrame ¬ dH.countType.asynchFrame + 1;	frameTimeout =>	  {IF ~dH.pleaseStop THEN	    dH.countType.frameTimeout ¬ dH.countType.frameTimeout + 1;	  IF rs232cParams.lineType = asynchronous THEN	    dataOk ¬ CheckData[index, bytes]};	disaster =>	  dH.countType.deviceError ¬ dH.countType.deviceError + 1;	ENDCASE;      IF ~dataOk THEN        {dH.countType.recErrors ¬ dH.countType.recErrors + 1;	IF writeMessage # NIL AND ~dH.pleaseStop THEN	  writeMessage[recError, LOOPHOLE[dH]]}      ELSE IF writeMessage # NIL THEN writeMessage[looped, LOOPHOLE[dH]];      END;  -- WaitReceiveComplete    ByteArrayToString: PROCEDURE [    byteArray: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte,    string: LONG STRING,    startIndex, stopIndex: CARDINAL] =    -- puts a string into byteArray starting at startIndex      BEGIN      stringIndex: CARDINAL ¬ 0;      stopIndex ¬ startIndex + MIN[string.maxlength, (stopIndex - startIndex)];      string.length ¬ stopIndex - startIndex + 1;      FOR i: CARDINAL IN [startIndex..stopIndex] DO        string[stringIndex] ¬ LOOPHOLE[byteArray­[i], CHARACTER];        stringIndex ¬ stringIndex + 1;        ENDLOOP;      END;  -- ByteArrayToString   CheckData: PROC [index: CARDINAL, bytes: CARDINAL] RETURNS [dataOk: BOOLEAN] =      -- check if in sequence and also the contents      BEGIN      -- locals      sequenceString: LONG STRING = [10];      seqNum: CARDINAL;      byteErr: CARDINAL ¬ 0;      seqErr: BOOLEAN ¬ FALSE;      dl: CARDINAL ¬ 0;  -- actual length of data.      b: Environment.Block = receiveBufferState[index].phys.body;            dataOk ¬ TRUE;      dl ¬ IF rs232cParams.lineType = asynchronous THEN bytes           ELSE bytes - testHeaderLength - testReceiveTrailerLength;      -- sequence numbers are not useful for asynchronous line type.      IF rs232cParams.lineType # asynchronous THEN        BEGIN        -- get sequence number        ByteArrayToString[          receiveBufferState[index].phys.body.blockPointer, sequenceString,	  receiveBufferState[index].phys.body.startIndex,          receiveBufferState[index].phys.body.startIndex + 3];         -- Convert EBCDIC sequence number to ASCII (if necessary)	IF dH.useEbcdic THEN          FOR i: CARDINAL IN [0..3] DO	    sequenceString[i] ¬	      LOOPHOLE[LOOPHOLE[sequenceString[i], Environment.Byte] - 300B,	      CHARACTER];	    ENDLOOP;        seqNum ¬ String.StringToDecimal[sequenceString ! String.InvalidNumber =>	    BEGIN	    dH.countType.badSeq ¬ dH.countType.badSeq + 1;	    dataOk ¬ FALSE;	    dH.receiveSeqNum ¬ IncrementSeqNum[dH.receiveSeqNum];	    GOTO returnPlace;	    END];        -- compare with expected value        IF seqNum # dH.receiveSeqNum THEN          BEGIN	  dH.countType.missing ¬ dH.countType.missing + 1;	  dataOk ¬ FALSE;	  dH.receiveSeqNum ¬ IncrementSeqNum[seqNum];	  GOTO returnPlace;	   END;        END  -- # asynchronous.      ELSE dH.startData ¬ 1;  -- lineType = asynchronous	        -- check the contents.        SELECT rs232cParams.pattern FROM	   zero => FOR i: CARDINAL IN [dH.startData..dl) DO	      IF Inline.BITAND[b.blockPointer[b.startIndex+i], dMask] # 0 THEN	        byteErr ¬ byteErr + 1 ENDLOOP;	   ones => FOR i: CARDINAL IN [dH.startData..dl) DO	      IF Inline.BITAND[b.blockPointer[b.startIndex+i], dMask] #	         Inline.BITAND[377B, dMask] THEN byteErr ¬ byteErr + 1 ENDLOOP;	   oneZeroes => FOR i: CARDINAL IN [dH.startData..dl) DO	      IF Inline.BITAND[b.blockPointer[b.startIndex+i], dMask] # 	         Inline.BITAND[252B, dMask] THEN byteErr ¬ byteErr + 1 ENDLOOP;	   constant => FOR i: CARDINAL IN [dH.startData..dl) DO	      IF Inline.BITAND[b.blockPointer[b.startIndex+i], dMask] # 	         Inline.BITAND[rs232cParams.constant, dMask]		THEN byteErr ¬ byteErr + 1 ENDLOOP;	   ENDCASE => FOR i: CARDINAL IN [dH.startData..dl) DO	      IF Inline.BITAND[b.blockPointer[b.startIndex+i], dMask] #	        (Inline.BITAND[(b.blockPointer[b.startIndex+i-1] + 1), dMask])		THEN	      {SELECT (Inline.BITAND[b.blockPointer[b.startIndex+i], dMask]) FROM		4B => IF Inline.BITAND[		  b.blockPointer[b.startIndex+i-1], dMask] = 2B THEN LOOP;		6B => IF Inline.BITAND[		  b.blockPointer[b.startIndex+i-1], dMask] = 4B THEN LOOP;		24B => IF Inline.BITAND[		  b.blockPointer[b.startIndex+i-1], dMask] = 17B THEN LOOP;		30B => IF Inline.BITAND[		  b.blockPointer[b.startIndex+i-1], dMask] = 26B THEN LOOP;		Inline.BITAND[40B, dMask] => IF Inline.BITAND[		  b.blockPointer[b.startIndex+i-1], dMask] = 36B THEN LOOP;		47B => IF Inline.BITAND[		  b.blockPointer[b.startIndex+i-1], dMask] = 45B THEN LOOP;		56B => IF Inline.BITAND[		  b.blockPointer[b.startIndex+i-1], dMask] = 54B THEN LOOP;		63B => IF Inline.BITAND[		  b.blockPointer[b.startIndex+i-1], dMask] = 61B THEN LOOP;		204B => IF Inline.BITAND[		  b.blockPointer[b.startIndex+i-1], dMask] = 202B THEN LOOP;		ENDCASE => byteErr ¬ byteErr + 1;};	      ENDLOOP;	            IF rs232cParams.lineType # asynchronous THEN        BEGIN	-- resynchronize by assuming next sequence number received should follow        -- this one.	IF (byteErr = 0) THEN dH.lastGoodSeq ¬ dH.receiveSeqNum;        dH.receiveSeqNum ¬ IncrementSeqNum[dH.receiveSeqNum];        IF byteErr = 0 THEN dH.countType.recOk ¬ dH.countType.recOk + 1        END      ELSE dH.countType.recOk ¬ dH.countType.recOk + bytes - byteErr;      IF byteErr # 0 THEN dataOk ¬ FALSE;      EXITS returnPlace => {index ¬ index; RETURN};      END; -- CheckData        -- Start of procedure.      IF rs232cParams.lineType = asynchronous THEN      BEGIN      testBodyLength ¬ asyncFrameTO;      dMask ¬ SELECT rs232cParams.charLength FROM        8 => 255,	7 => 127,	6 => 63,	ENDCASE => 31;      END    ELSE testBodyLength ¬ rs232cParams.dataLengths.high;    FOR i: CARDINAL IN [0..maxReceiveBuffers) DO      p: LONG POINTER = receiveSpace + i*dH.wordsPerSendReceiveBuffer;      IF rs232cParams.lineType = asynchronous THEN        receiveBufferState[i] ¬ [  	  busy: FALSE, compH: NULL,	  phys: [  -- no header or trailer for asynchronous, so fudge it.	    header:  [p,  0, 0],	    body:    [p, 0, testBodyLength],	    trailer: [p, testBodyLength, testBodyLength]]]      ELSE        receiveBufferState[i] ¬ [          busy: FALSE, compH: NULL,	  phys: [            header:  [p, 0, testHeaderLength],            body:    [p, testHeaderLength, testHeaderLength+testBodyLength],            trailer: [p, testHeaderLength+testBodyLength,	            testHeaderLength+testBodyLength+testReceiveTrailerLength]]]      ENDLOOP;    dH.countType.recOk ¬ 0;    dH.receiveSeqNum ¬ 1000;    BEGIN ENABLE RS232C.ChannelSuspended => GOTO quitReceive;    FOR index IN [0..maxReceiveBuffers) DO      QueueBufferForReceive[] ENDLOOP;    index ¬ 0;    DO      IF receiveBufferState[index].busy THEN        WaitReceiveComplete[testBodyLength];      QueueBufferForReceive[];      IF (index ¬ index+1) = maxReceiveBuffers THEN index ¬ 0;      SELECT TRUE FROM        rs232cParams.lineType = asynchronous =>	  NULL;  -- no concept of framing for asynchronous line.	rs232cParams.dataLengths.high = rs232cParams.dataLengths.low =>	  NULL;  -- constant testBodyLength.	testBodyLength < rs232cParams.dataLengths.low =>          testBodyLength ¬ rs232cParams.dataLengths.high;	ENDCASE => testBodyLength ¬ testBodyLength - 1;      ENDLOOP;    EXITS      quitReceive =>        BEGIN         THROUGH [0..maxReceiveBuffers] DO          IF receiveBufferState[index].busy THEN	    WaitReceiveComplete[testBodyLength	       ! RS232C.ChannelSuspended => CONTINUE];          IF (index ¬ index+1) = maxReceiveBuffers THEN index ¬ 0;          ENDLOOP;        END -- quitReceive;    END; -- BEGIN ENABLE    END; -- Receiver       GetRS232CResults: PUBLIC PROC [dH: CommOnlineDiagnostics.RS232CDiagHandle,     stopIt: BOOLEAN] RETURNS[counters: CommOnlineDiagnostics.CountType] =    BEGIN    h: RS232CDiagHandle ¬ LOOPHOLE[dH];    IF h.seal # handleSeal THEN ERROR RS232CDiagError[invalidHandle];    h.timeOfLastPollSSE ¬       System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]];    IF stopIt THEN      BEGIN      h.seal ¬ unsealed;      StopRS232CTest[h, TRUE, FALSE];      END;  -- if stopIt    counters ¬ h.countType;    END; -- GetRS232CResults    StopRS232CTest: PROC[h: RS232CDiagHandle, wait: BOOLEAN, detachLoopTest: BOOLEAN] =    BEGIN    ProcessingStopRequest: ENTRY PROC RETURNS[bool: BOOLEAN] =      BEGIN      bool ¬ h.pleaseStop;      h.pleaseStop ¬ TRUE;      END;    IF NOT ProcessingStopRequest[] THEN      BEGIN      -- give receiver a chance to catch up      THROUGH [0..ReasonableNumberOfSecondsToWait[h.lineSpeed])          WHILE h.packetsReceived # h.packetsSent DO        Process.Pause[Process.SecondsToTicks[1]];        ENDLOOP;      RS232C.Suspend[h.cH, all];      Process.Pause[Process.SecondsToTicks[2]];      IF h.send # NIL THEN        {h.packetsSent ¬ JOIN h.send; h.send ¬ NIL};      IF h.receive # NIL THEN        {h.packetsReceived ¬ JOIN h.receive; h.receive ¬ NIL};      IF h.sh # Space.nullInterval THEN        {[] ¬ Space.Unmap[h.sh.pointer];        h.sh ¬ Space.nullInterval};      IF h.loopTest # NIL THEN        BEGIN        IF detachLoopTest THEN Process.Detach[h.loopTest]        ELSE JOIN h.loopTest;	h.loopTest ¬ NIL;	END;      RS232C.Delete[h.cH];      END    ELSE      IF wait THEN        UNTIL h.send = NIL AND h.receive = NIL DO	  Process.Pause[Process.SecondsToTicks[1]];	  ENDLOOP;    END;  -- StopRS232CTest  TimeCheck: PROCEDURE [dH: RS232CDiagHandle, timeOutMilliSec: LONG CARDINAL]    RETURNS [timedOut: BOOLEAN] = {    -- used to see if program execution should be automatically aborted    -- timedOut ¬ [currentTime] - [timeOfLastPoll] > [safetyTimeLength]    t: LONG CARDINAL ¬ System.SecondsSinceEpoch[System.GetGreenwichMeanTime[]];    IF ((t - dH.timeOfLastPollSSE) > (timeOutMilliSec/1000)) THEN timedOut ¬ TRUE    ELSE timedOut ¬ FALSE;    };  -- of TimeCheck      Wait: PROCEDURE [echoTrans: LONG CARDINAL, minWait: CARDINAL]    RETURNS [longEnough: BOOLEAN ¬ FALSE] = {    -- idle if sufficient time since last packet has not elapsed    currentTime: LONG CARDINAL;    currentTime ¬ System.PulsesToMicroseconds[System.GetClockPulses[]];    currentTime ¬ (currentTime/1000) - (echoTrans/1000);    IF currentTime >= minWait THEN longEnough ¬ TRUE;    };  -- of Wait  END...  LOG  21-Jun-83  9:44:20  SMA  Converted to Klamath.28-Sep-83  9:21:36  STC  Klamath changes   6-Dec-83 14:57:01  STC  New Defs CommOnlineDiagnostics 9-Dec-83 16:01:29  STC  showSig Only if changed 19-Jan-84 14:27:19  STC  work around for waitForDSR  8-Feb-84  9:35:33  STC  update ShowSig, small asyncFrameTO 16-Feb-84 14:18:27  SMA  no bogus header for async.22-Feb-84 10:51:11  STC  avoid FlowControl 21B, 23B24-Feb-84 13:28:08  STC  fix bug in startData of Async 2-Mar-84 11:29:06  STC  force Async dataLengths = 50014-Jun-84 15:15:18  SMA  Changed Dialer test for CIU (create channel, raise DTR), don't abort input before letting it catch up at end of test.Get  SMA  Changes for multi port testing. 5-Sep-85 12:50:29  SMA  Don't delete the channel more than once. 5-Jan-87 14:32:06  AOF  Fill out USING lists. 6-Nov-87 18:31:02  BKI  Fixed AR 8672.11-Nov-87 11:24:21  BKI  Fixed test-termination code.
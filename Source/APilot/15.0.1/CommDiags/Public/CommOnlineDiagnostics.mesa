-- Copyright (C) 1984, 1985 by Xerox Corporation. All rights reserved. -- CommOnlineDiagnostics.mesa - last edited by SMA   1-Feb-85  7:37:05DIRECTORY  Dialup USING [DialerType, Number],  RS232C USING [CharLength, ClockSource, Correspondent, LineSpeed, LineType,    Parity],  System USING [GreenwichMeanTime, NetworkAddress, nullNetworkAddress];CommOnlineDiagnostics: DEFINITIONS =  BEGIN  -- The interface for the communications online diagnostics.    ServerOn: PROC;  ServerOff: PROC;    CommError: ERROR[reason: CommErrorCode];  CommErrorCode: TYPE = MACHINE DEPENDENT {    transmissionMediumProblem,    noAnswerOrBusy,    noRouteToSystemElement,    transportTimeout,    remoteSystemElementNotResponding,    noCourierAtRemoteSite,    tooManyConnections,    invalidMessage,    noSuchDiagnostic,    returnTimedOut,    callerAborted,    unknownErrorInRemoteProcedure,    streamNotYours,    truncatedTransfer,    parameterInconsistency,    invalidArguments,    protocolMismatch,    duplicateProgramExport,    noSuchProgramExport,    invalidHandle,    noError};    -- Ethernet stats and echo diagnostics      EtherDiagError: ERROR [reason: EtherErrorReason];  EtherErrorReason: TYPE = MACHINE DEPENDENT {    echoUserNotThere,    noMoreNets,    invalidHandle};    EchoDiagHandle: TYPE = LONG POINTER TO EchoDiagObject;    EchoDiagObject: TYPE;      GetEthernetStats: PROC [    physicalOrder: CARDINAL ¬ 1,    host: System.NetworkAddress ¬ System.nullNetworkAddress]    RETURNS [info: EtherStatsInfo, time: System.GreenwichMeanTime];          GetEchoCounters: PROC [host: System.NetworkAddress ¬ System.nullNetworkAddress]    RETURNS [packets, bytes: LONG CARDINAL, time: System.GreenwichMeanTime];			     EtherStatsInfo: TYPE = ARRAY StatsIndices OF LONG CARDINAL;  StatsIndices: TYPE = {echoServerPkts, EchoServerBytes, packetsRecv, wordsRecv,    packetsMissed, badRecvStatus, okButDribble, badCrc, badAlignmentButOkCrc,    crcAndBadAlignment, packetTooLong, overrun, idleInput, packetsSent,    wordsSent, badSendStatus, tooManyCollisions, lateCollisions, underrun,    stuckOutput, coll0, coll1, coll2, coll3, coll4, coll5, coll6, coll7, coll8,    coll9, coll10, coll11, coll12, coll13, coll14, coll15, spare};      StartEchoUser: PROC [    targetSystemElement: System.NetworkAddress,    echoParams: EchoParams,    eventReporter: EventReporter ¬ NIL,    host: System.NetworkAddress ¬ System.nullNetworkAddress]    RETURNS [dH: EchoDiagHandle];                GetEchoResults: PROC [    dH: EchoDiagHandle,    stopIt: BOOLEAN,    host: System.NetworkAddress ¬ System.nullNetworkAddress]    RETURNS [totalsSinceStart: EchoResults,    hist: Histogram];      FreeHistogram: PROC [hist: Histogram];    EventReporter:  TYPE = PROC [event: EchoEvent, dH: EchoDiagHandle];  EchoEvent: TYPE = MACHINE DEPENDENT {    success, late, timeout, badDataGoodCRC, sizeChange, unexpected};        EchoParams: TYPE = MACHINE DEPENDENT RECORD [    totalCount(0):             CARDINAL      ¬ LAST[CARDINAL],    safetyTOInMsecs(1):        LONG CARDINAL ¬ 60000,     minPacketSizeInBytes(3):   CARDINAL      ¬ 2,    maxPacketSizeInBytes(4):   CARDINAL      ¬ 512,    wordContents(5):           WordsInPacket ¬ incrWords,    constant(6):               CARDINAL      ¬ 125252B,    waitForResponse(7):        BOOLEAN       ¬ TRUE,    minMsecsBetweenPackets(8): CARDINAL      ¬ 0,    checkContents(9):          BOOLEAN       ¬ TRUE,    showMpCode(10):            BOOLEAN       ¬ FALSE];      EchoResults: TYPE = MACHINE DEPENDENT RECORD [    totalTime, totalAttempts, successes, timeouts, late, unexpected, bad,    avgDelayInMsecs: LONG CARDINAL,    -- stats    okButDribble, badAlignmentButOkCrc, packetTooLong, overrun, idleInput,    tooManyCollisions, lateCollisions, underrun, stuckOutput,    spare: LONG CARDINAL];       Histogram: TYPE = LONG DESCRIPTOR FOR ARRAY CARDINAL OF Detail;  Detail: TYPE = MACHINE DEPENDENT RECORD[msec, count: CARDINAL];      WordsInPacket:  TYPE = MACHINE DEPENDENT {    all0s, all1s, incrWords, allConstant, dontCare};             -- RS232C and dialer diagnostics    RS232CDiagHandle: TYPE = LONG POINTER TO RS232CDiagObject;  RS232CDiagObject: TYPE;    RS232CDiagError: ERROR [reason: RS232CErrorReason];  RS232CErrorReason: TYPE = MACHINE DEPENDENT {    aborted, noHardware, noSuchLine, channelInUse,     unimplementedFeature, invalidParameter, invalidHandle};      StartRS232CTest: PROC [    rs232cParams: RS232CParams,    setDiagnosticLine: SetDiagnosticLine ¬ NIL,    writeMsg: WriteMsg ¬ NIL,    modemChange: ModemChange ¬ NIL,    host: System.NetworkAddress ¬ System.nullNetworkAddress]    RETURNS [dH: RS232CDiagHandle];       GetRS232CResults: PROC [    dH: RS232CDiagHandle,    stopIt: BOOLEAN,    host: System.NetworkAddress ¬ System.nullNetworkAddress]    RETURNS[counters: CountType];         CountType: TYPE = MACHINE DEPENDENT RECORD [sendOk, bytesSent, recOk,    bytesRec, deviceError, dataLost, checkSum, parity, invalidChar,    invalidFrame, asynchFrame, breakDetected, frameTimeout, badSeq, missing,    sendErrors, recErrors: LONG CARDINAL];      LengthRange: TYPE = MACHINE DEPENDENT RECORD [low(0), high(1): [0..maxData)];  maxData: CARDINAL = 1000;    ModemChange: TYPE = PROC [    modemSignal: ModemSignal, state: BOOLEAN, dH: RS232CDiagHandle];      ModemSignal: TYPE = MACHINE DEPENDENT {    dataSetReady, clearToSend, carrierDetect, ringIndicator, ringHeard};      PatternType: TYPE = MACHINE DEPENDENT {    zero, ones, oneZeroes, constant, byteIncr};    RS232CParams: TYPE = MACHINE DEPENDENT RECORD [    testCount(0): CARDINAL ¬ LAST[CARDINAL],    safetyTOInMsecs(1): LONG CARDINAL ¬ 60000,    lineSpeed(3): RS232C.LineSpeed,    correspondent(4): RS232C.Correspondent,    lineType(5): RS232C.LineType,    lineNumber(6): CARDINAL,    parity(7): RS232C.Parity,    charLength(8): RS232C.CharLength,    pattern(9): PatternType,    constant(10): CARDINAL ¬ 0,    dataLengths(11): LengthRange,    clockSource(13): RS232C.ClockSource,    waitForDSR(14): BOOLEAN ¬ TRUE];    RS232CTestMessage: TYPE = MACHINE DEPENDENT {looped, sendError, recError};     SetDiagnosticLine: TYPE = PROC [lineNumber: CARDINAL, dH: RS232CDiagHandle]    RETURNS [lineSet: BOOLEAN];      WriteMsg: TYPE = PROC [msg: RS232CTestMessage, dH: RS232CDiagHandle];            DialupTest: PROC [    rs232ClineNumber: CARDINAL,    phoneNumber: LONG POINTER TO Dialup.Number,    dialerType: Dialup.DialerType,    host: System.NetworkAddress ¬ System.nullNetworkAddress]    RETURNS [outcome: DialupOutcome];      DialupOutcome: TYPE = MACHINE DEPENDENT {    success, failure, aborted, formatError,    transmissionError, dataLineOccupied, dialerNotPresent, dialingTimeout,    transferTimeout, otherError, noHardware, noSuchLine,    channelInUse, unimplementedFeature, invalidParamater};  END...
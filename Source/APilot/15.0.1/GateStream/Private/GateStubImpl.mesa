-- File: GateStubImpl.mesa - last edit:-- AOF                 18-Jul-87 11:13:22-- Copyright (C) 1985, 1987 by Xerox Corporation. All rights reserved. DIRECTORY  Auth USING [    CheckOutCredsAndNextVerifier, ConversationHandle, Credentials,    nullCredentials, nullVerifier, Verifier],  Buffer USING [],  CFDStream USING [    Byte, CompletionCode, Handle, InputOptions, Object, PhysicalRecordHandle,    SubSequenceType],  Courier USING [    Call, Create, Delete, Error, Free, Handle, LocalSystemElement,    ReleaseDataStream, RemoteErrorSignalled, VersionMismatch],  CourierInternal USING [AugmentedStream],  Driver USING [Device, nilDevice],  Environment USING [Block],  GateOpsExtras USING [],  GateStream USING [    CallBackType, cleanup, CompletionProcedure, ErrorReason, ForeignDevice,    none, Resource, SessionParameterHandle, TransferID, TransportObject,    WaitTime],  GateStreamCourierInternal USING [    Argument, ArgumentDescription, Close, CloseReply, CreateArgument,    CurrentVersion, GAP, OldVersion, Procedure, ResultDescription,    serviceNotFound, unimplemented],  GateStreamInstance USING [instanceObject],  GateStubInternal USING [    GetStreamProcedure, NewStreamInstance, ProcedureHandle, StreamInstanceHandle],  Heap USING [systemZone],  NetworkStream USING [closeSST, infiniteWaitTime, SetWaitTime],  NSTypes USING [maxIDPBytesPerPacket, bytesPerIDPHeader, bytesPerSppHeader],  PacketStream USING [Handle],  Protocol1 USING [Family, GetFamilyUnit, SetMaximumBufferSize],  Runtime USING [GlobalFrame],  SppOps USING [DisableChecksums, PacketStreamFromByteStream, SetWindow],  Stream USING [    Block, Byte, CompletionCode, defaultInputOptions, EndOfStream, GetBlock,    GetChar, Handle, InputOptions, PutBlock, SendAttention, SendNow,    SetInputOptions, SetSST, SSTChange, SubSequenceType, TimeOut,    WaitForAttention],  System USING [NetworkAddress, nullNetworkAddress];GateStubImpl: PROGRAM  IMPORTS    Auth, Courier, GateStreamCourierInternal, GateStubInternal, Heap,     NetworkStream, Protocol1, Runtime, SppOps, Stream  EXPORTS Buffer, GateOpsExtras, GateStream, GateStubInternal  SHARES GateStreamInstance =  BEGIN      TryCourier: PUBLIC ERROR = CODE;  Device: PUBLIC <<Buffer>> TYPE = Driver.Device;  Error: PUBLIC ERROR [reason: GateStream.ErrorReason] = CODE;     RemoteHandle: TYPE = LONG POINTER TO RemoteObject;  RemoteObject: TYPE = RECORD [    cfdObject: CFDStream.Object,    networkStream: Stream.Handle,    service: Courier.Handle,    oldVersion: BOOLEAN,    closeStarted: BOOLEAN,    attentionEnd: BOOLEAN];    disp: GateStubInternal.ProcedureHandle ¬ NIL;  alwaysUseCourier: BOOLEAN ¬ FALSE;  -- Generally set TRUE only for debugging  ErrorConversion: ARRAY CARDINAL [GateStreamCourierInternal.unimplemented..    GateStreamCourierInternal.serviceNotFound]    OF GateStream.ErrorReason = [    unimplemented, noCommunicationHardware, illegalTransport,    mediumConnectFailed, badAddressFormat, noDialingHardware,    dialingHardwareProblem, transmissionMediumUnavailable, inconsistentParams,    tooManyGateStreams, bugInGAPCode, gapNotExported, gapCommunicationError,    controllerAlreadyExists, controllerDoesNotExist, deviceAddressInUse,    deviceAddressInvalid, serviceTooBusy,     userNotAuthenticated, userNotAuthorized, serviceNotFound];  -- Procedures    RegisterDispatcher: PUBLIC PROC[handle: GateStubInternal.ProcedureHandle] =    {disp ¬ handle};  AdjustStream: PUBLIC <<GateOpsExtras>> PROC[sH: Stream.Handle,    frame: NATURAL[64..1500] ¬ NSTypes.maxIDPBytesPerPacket,    checksums: BOOLEAN ¬ TRUE, allocation: NATURAL[1..13] ¬ 5] =    BEGIN    IF allocation > 5 THEN SppOps.SetWindow[PRED[allocation]];    IF sH # NIL THEN      BEGIN      psH: PacketStream.Handle = PacketStreamFromGateStream[sH];      family: Protocol1.Family = Protocol1.GetFamilyUnit[ns];      IF ~checksums THEN SppOps.DisableChecksums[psH];      Protocol1.SetMaximumBufferSize[Driver.nilDevice, family, frame];      psH.setSenderSizeLimit[        frame - NSTypes.bytesPerSppHeader - NSTypes.bytesPerIDPHeader];      END;    END;  --AdjustStream  PacketStreamFromGateStream: PROC[sH: Stream.Handle]    RETURNS[PacketStream.Handle] =    BEGIN    gf: LONG POINTER TO FRAME[GateStreamInstance] = LOOPHOLE[      Runtime.GlobalFrame[LOOPHOLE[sH.get]]];    ih: GateStubInternal.StreamInstanceHandle = @gf.instanceObject;    rh: RemoteHandle = LOOPHOLE[ih.cfdStream];  --pointer to structure    cs: Stream.Handle = rh.networkStream;  --this is really Courier's bulk stream    ns: Stream.Handle = TransportFromFilter[cs];  --NetworkStream behind Courier    RETURN[SppOps.PacketStreamFromByteStream[ns]];  --and the packet stream    END;  --PacketStreamFromGateStream  TransportFromFilter: PROC[sH: Stream.Handle] RETURNS[Stream.Handle] = INLINE    {RETURN[LOOPHOLE[@LOOPHOLE[sH, CourierInternal.AugmentedStream].context,      LONG POINTER TO Stream.Handle]­]};  Create: PUBLIC PROCEDURE [    service: System.NetworkAddress,    sessionParameterHandle: GateStream.SessionParameterHandle,    transportList: LONG DESCRIPTOR FOR ARRAY OF GateStream.TransportObject,    createTimeout: GateStream.WaitTime,    conversation: Auth.ConversationHandle] RETURNS [stream: Stream.Handle] =    BEGIN    cfdStream: CFDStream.Handle;    credentials: Auth.Credentials;    verifier: Auth.Verifier;    IF conversation = NIL THEN      BEGIN      credentials ¬ Auth.nullCredentials;      verifier ¬ Auth.nullVerifier;      END    ELSE      [credentials, verifier] ¬ Auth.CheckOutCredsAndNextVerifier[conversation];    cfdStream ¬ GreeterCreate[service,       sessionParameterHandle, transportList,       createTimeout, credentials, verifier, ReturnStream];    RETURN[LOOPHOLE[GateStubInternal.NewStreamInstance[cfdStream,       sessionParameterHandle.foreignDevice]]];    END;   GreeterCreate: PUBLIC PROCEDURE [systemElement: System.NetworkAddress,    sessionParameterHandle: GateStream.SessionParameterHandle,    transport: LONG DESCRIPTOR FOR ARRAY OF GateStream.TransportObject,    createTimeout: GateStream.WaitTime,    credentials: Auth.Credentials,    verifier: Auth.Verifier,     getStream: GateStubInternal.GetStreamProcedure] RETURNS [    cfdStream: CFDStream.Handle] =    BEGIN    argument: GateStreamCourierInternal.CreateArgument;    sH: Stream.Handle;    handle: Courier.Handle;    networkStream: Stream.Handle;    oldVersion: BOOLEAN ¬ FALSE;    remote: RemoteHandle;    IF LocalSystemElement[systemElement] THEN      BEGIN      cfdStream ¬ disp.create[systemElement,        sessionParameterHandle, transport, createTimeout, 	GateStreamCourierInternal.CurrentVersion, credentials, verifier,        getStream ! TryCourier => GOTO tryCourier];      RETURN;      EXITS        tryCourier => systemElement ¬ Courier.LocalSystemElement[];       END;    argument ¬ [      sessionParameterHandle, transport, createTimeout, credentials, verifier];    handle ¬ CreateHandle[systemElement];    networkStream ¬ CallRemoteProcedure[handle, FALSE, create,      @argument, @cfdStream ! Courier.VersionMismatch =>         BEGIN oldVersion ¬ TRUE; CONTINUE END];    IF oldVersion THEN  -- Try old version of GAP      BEGIN      argument: create GateStreamCourierInternal.Argument ¬ [        create[sessionParameterHandle, transport, createTimeout]];      FOR i: CARDINAL IN [0..LENGTH[transport]) DO  -- Service transport illegal        IF transport[i].transportType = service THEN ERROR Error[unimplemented];	-- New to old TTY compatibility is handled in the deserialization routines        ENDLOOP;      handle ¬ CreateOldHandle[systemElement];      networkStream ¬ CallRemoteProcedure[handle, TRUE, create,         @argument, @cfdStream !	  Courier.VersionMismatch => ERROR Error[gapNotExported]];      END;    remote ¬ Heap.systemZone.NEW[RemoteObject ¬ [      cfdObject: [Stream.defaultInputOptions, Get, Put, SetSST,        SendAttn, WaitAttn, Delete],        networkStream: networkStream,        service: handle,        oldVersion: oldVersion,        closeStarted: FALSE,        attentionEnd: FALSE]];    FreeParameters[create, @cfdStream, oldVersion];    cfdStream ¬ LOOPHOLE[remote];    Stream.SetInputOptions[networkStream,      [TRUE, FALSE, FALSE, FALSE, FALSE, FALSE]];    NetworkStream.SetWaitTime[networkStream, NetworkStream.infiniteWaitTime];    SetSST[cfdStream, GateStream.none];    IF (sH ¬ getStream[]) # NIL THEN       IF disp = NIL THEN ERROR Error[unimplemented]       ELSE disp.connectTwoStreams[cfdStream, sH];     END;  Reserve: PUBLIC PROCEDURE [    transport: GateStream.TransportObject,    completionProcedure: GateStream.CompletionProcedure,    callBackType: GateStream.CallBackType,        conversation: Auth.ConversationHandle] RETURNS [    resource: GateStream.Resource] =    BEGIN    credentials: Auth.Credentials;    verifier: Auth.Verifier;    IF conversation = NIL THEN      BEGIN      credentials ¬ Auth.nullCredentials;      verifier ¬ Auth.nullVerifier;      END    ELSE      [credentials, verifier] ¬ Auth.CheckOutCredsAndNextVerifier[conversation];    IF disp # NIL THEN RETURN[disp.reserve[      transport, completionProcedure, callBackType, credentials,      verifier]]    ELSE ERROR Error[unimplemented];    END;  AbortReserve: PUBLIC PROCEDURE [resource: GateStream.Resource] =    BEGIN     IF disp # NIL THEN disp.abortReserve[resource]    ELSE ERROR Error[unimplemented];    END;  Transfer: PUBLIC PROCEDURE [stream: Stream.Handle]    RETURNS [transfer: GateStream.TransferID] =    BEGIN ERROR Error[unimplemented]; END;  Obtain: PUBLIC PROCEDURE [service: System.NetworkAddress,    transfer: GateStream.TransferID] RETURNS [stream: Stream.Handle] =    BEGIN ERROR Error[unimplemented]; END;  UseMediumForOISCP: PUBLIC PROCEDURE [transport: GateStream.TransportObject] =    BEGIN    IF disp # NIL THEN disp.useMediumForOISCP[transport]    ELSE ERROR Error[unimplemented];    END;    LocalSystemElement: PROCEDURE [service: System.NetworkAddress]    RETURNS [BOOLEAN] =    BEGIN    -- This procedure selects whether or not Courier should be used    -- for a GateStream procedure call.    -- Following declaration is a Mesa bug workaround    local: System.NetworkAddress ¬ Courier.LocalSystemElement[];     SELECT TRUE FROM      disp = NIL => RETURN[FALSE];  -- No GateDispatcher..always use Courier      service = System.nullNetworkAddress => RETURN[TRUE];  -- local..no Courier      alwaysUseCourier => RETURN [FALSE];  -- boolean says always use Courier      local.host = service.host => RETURN[TRUE];  -- our address, no Courier      ENDCASE => RETURN[FALSE];  -- anything else...use Courier    END;    ReturnStream: GateStubInternal.GetStreamProcedure = BEGIN RETURN [NIL] END;  -- Call Remote procedure and FreeParameters    CreateHandle: PROCEDURE [service: System.NetworkAddress] RETURNS [    handle: Courier.Handle] =    BEGIN    RETURN[Courier.Create[      remote: service,      programNumber: GateStreamCourierInternal.GAP,      versionNumber: GateStreamCourierInternal.CurrentVersion,      zone: Heap.systemZone,      classOfService: transactional]];    END;    CreateOldHandle: PROCEDURE [service: System.NetworkAddress] RETURNS [    handle: Courier.Handle] =    BEGIN    RETURN[Courier.Create[      remote: service,      programNumber: GateStreamCourierInternal.GAP,      versionNumber: GateStreamCourierInternal.OldVersion,      zone: Heap.systemZone,      classOfService: transactional]];    END;    CallRemoteProcedure: PROCEDURE [    handle: Courier.Handle, oldVersion: BOOLEAN,    procedureNumber: GateStreamCourierInternal.Procedure,    argument, result: LONG POINTER] RETURNS [    stream: Stream.Handle] =    BEGIN ENABLE UNWIND => Courier.Delete[handle];    stream ¬ Courier.Call[      cH: handle,      procedureNumber: LOOPHOLE[procedureNumber],      arguments: [argument,        GateStreamCourierInternal.ArgumentDescription[	  procedureNumber, oldVersion]],      results: [result,         GateStreamCourierInternal.ResultDescription[procedureNumber,	  oldVersion]],      requestDataStream: TRUE !        Courier.RemoteErrorSignalled =>          BEGIN	  [] ¬ arguments[];	  ERROR Error[ErrorConversion[errorNumber]];	  END;	Courier.Error => 	  BEGIN	  error: GateStream.ErrorReason ¬ SELECT errorCode FROM            tooManyConnections => tooManyGateStreams,            noSuchProgramNumber, noCourierAtRemoteSite => gapNotExported,	    noRouteToSystemElement => noRouteToGAPService,	    transmissionMediumHardwareProblem => 	      networkTransmissionMediumHardwareProblem,	    transmissionMediumNotReady =>	      networkTransmissionMediumNotReady,	    transmissionMediumUnavailable => networkTransmissionMediumUnavailable,	     noAnswerOrBusy => networkNoAnswerOrBusy,	    remoteSystemElementNotResponding => gapServiceNotResponding,	    transportTimeout => gapCommunicationError,	    protocolMismatch => courierProtocolMismatch,            -- noSuchProcedureNumber, callerAborted,	    -- unknownErrorInRemoteProcedure,	    -- streamNotYours, parameterInconsistency, invalidArguments,	    -- invalidHandle, noError, returnTimedOut, 	    -- invalidMessage, truncatedTransfer, 	    -- duplicateProgramExport, noSuchProgramExport =>  bugInGAPCode,	    ENDCASE => bugInGAPCode;          ERROR Error[error];  -- Error	  END;	Courier.VersionMismatch => IF procedureNumber # create THEN 	  ERROR Error[gapVersionMismatch]];    END;        FreeParameters: PROCEDURE [procedureNumber: GateStreamCourierInternal.Procedure,    result: LONG POINTER, oldVersion: BOOLEAN] =    BEGIN    Courier.Free[[@result,       GateStreamCourierInternal.ResultDescription[procedureNumber, oldVersion]],      Heap.systemZone];    END;  -- Stub Stream procedures                Get: PROCEDURE [    sH: CFDStream.Handle, physicalRecordHandle: CFDStream.PhysicalRecordHandle,    options: CFDStream.InputOptions] RETURNS [bytesTransferred: CARDINAL,     why: CFDStream.CompletionCode, sst: CFDStream.SubSequenceType] =    BEGIN OPEN remote: LOOPHOLE[sH, RemoteHandle];    IF remote.closeStarted THEN RETURN [0, endOfStream, GateStream.none];    [bytesTransferred, why, sst] ¬ Stream.GetBlock[remote.networkStream,       physicalRecordHandle.body !          Courier.Error => GOTO suspended];    IF why = attention THEN      BEGIN      [] ¬ Stream.GetChar[remote.networkStream !         Stream.EndOfStream, Stream.TimeOut, Stream.SSTChange => CONTINUE];      why ¬ normal;      END;    SELECT sst FROM      GateStream.cleanup =>        RETURN [bytesTransferred, endOfStream, GateStream.none];      NetworkStream.closeSST =>         BEGIN        remote.closeStarted ¬ TRUE;        RETURN [bytesTransferred, endOfStream, GateStream.none];        END;      ENDCASE;    EXITS       suspended => RETURN [0, endOfStream, GateStream.none];    END;      Put: PROCEDURE [    sH: CFDStream.Handle, physicalRecordHandle: CFDStream.PhysicalRecordHandle,    endPhysicalRecord: BOOLEAN] =    BEGIN OPEN remote: LOOPHOLE[sH, RemoteHandle];    ENABLE        BEGIN	Courier.Error => GOTO return;	Stream.TimeOut => RESUME;	END;    Stream.PutBlock[remote.networkStream, physicalRecordHandle.body, FALSE];    IF endPhysicalRecord THEN Stream.SendNow[remote.networkStream];    EXITS return => NULL;    END;  WaitAttn: PROCEDURE [sH: CFDStream.Handle] RETURNS [byte: CFDStream.Byte] =    BEGIN OPEN remote: LOOPHOLE[sH, RemoteHandle];    ENABLE Stream.TimeOut => RESUME;    byte ¬ Stream.WaitForAttention[remote.networkStream !      Courier.Error =>	BEGIN remote.attentionEnd ¬ TRUE; ERROR ABORTED END];    IF byte = GateStream.cleanup THEN       BEGIN      remote.attentionEnd ¬ TRUE;      ERROR ABORTED;      END;    END;  SendAttn: PROCEDURE [sH: CFDStream.Handle, byte: CFDStream.Byte] =    BEGIN OPEN remote: LOOPHOLE[sH, RemoteHandle];    ENABLE      BEGIN      Courier.Error => GOTO return;      Stream.TimeOut => RESUME;      END;    Stream.SendAttention[remote.networkStream, byte];    EXITS return => NULL;    END;  SetSST: PROCEDURE [sH: CFDStream.Handle, sst: Stream.SubSequenceType] =    BEGIN OPEN remote: LOOPHOLE[sH, RemoteHandle];    ENABLE      BEGIN      Courier.Error => GOTO return;      Stream.TimeOut => RESUME;      END;    Stream.SetSST[remote.networkStream, sst];    EXITS return => NULL;    END;    PurgeAttention: PROCEDURE [sH: CFDStream.Handle] =    BEGIN OPEN remote: LOOPHOLE[sH, RemoteHandle];    UNTIL remote.attentionEnd DO [] ¬ WaitAttn[sH !       ABORTED, Stream.TimeOut => EXIT] ENDLOOP;    END;  Delete: PROCEDURE [sH: CFDStream.Handle] =    BEGIN OPEN remote: LOOPHOLE[sH, RemoteHandle];    process: PROCESS;    NetworkStream.SetWaitTime[remote.networkStream,       NetworkStream.infiniteWaitTime];   -- milliseconds    process ¬ FORK PurgeAttention[sH];    SendAttn[sH, GateStream.cleanup];    IF remote.oldVersion THEN       BEGIN      SetSST[sH, GateStream.cleanup];      SetSST[sH, GateStream.none];      END;    IF remote.closeStarted       THEN  [] ¬ GateStreamCourierInternal.CloseReply[remote.networkStream !         Courier.Error => CONTINUE]      ELSE  [] ¬ GateStreamCourierInternal.Close[remote.networkStream !        Courier.Error => CONTINUE];    JOIN process;    Courier.ReleaseDataStream[remote.service];    Courier.Delete[remote.service];    Heap.systemZone.FREE[@sH];    END;  -- Main code...starts everything    END.  LOGTime:			 By: 			Action: Rubicon release.Time:  4-Jun-81 17:20:45 By: Danielson		Action: Pescadero changes.Time: 15-Jul-81 16:58:04 By: Danielson		Action: AR7806.Time:  5-Aug-81 18:29:28 By: Danielson		Removed RS232CManager.Time: 27-Aug-81 11:08:29 By: Danielson		Changes required for callback						 procedures.Time: 14-Oct-81 18:18:11 By: Danielson		Remove SetWait time from here.Time:  1-Feb-82 17:06:37 By: Danielson		New configs.Time:  4-Mar-82 13:09:11 By: Danielson		Local/remote calling.Time: 14-Jun-83 11:47:21 By: Danielson		Re-org to make stub separate.Time: 19-Jul-83 16:01:24 By: Danielson		Simplify stream filter.Time: 22-Jul-83 15:14:26 By: Danielson		Backward compatable code.Time: 30-Sep-83 17:10:45 By: Danielson		Klamath/Authentication.Time:  9-Dec-83 16:02:05 By: Danielson		New Auth + more Courier errors.Time:  5-Mar-84 17:17:03 By: Danielson		Timeouts on Delete.Time: 20-Mar-84 11:29:46 By: Danielson		Strip attentions.Time: 14-May-84 16:38:01 By: Danielson		Force SST to none at start.Time: 26-Jun-84 14:25:56 By: Danielson		Close and CloseReply fork Getter. 7-Jan-85 17:18:48  SMA  Catch Courier.Error instead of ConnectionSuspended20-Feb-85 11:52:53  AOF  Delete Courier object when releasing stream21-Jan-87  9:52:11  AOF  Modifiying Spp traits behind gate stream
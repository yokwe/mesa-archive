-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- File: GateStreamCourier.mesa - last edit by SMA  7-Jan-85 17:34:47-- Danielson.PA        26-Jun-84 14:36:42-- thatcher.PA         21-Feb-84 13:33:20DIRECTORY  Auth USING [DescribeCredentials, DescribeVerifier],  Courier USING [Description, Error],  Dialup USING [RetryCount],  Environment USING [Block],  GateStream USING [ForeignDevice, Line, ReserveType,    SessionParameterObject, Transport, TransportObject],  GateStreamExtras USING [ForeignDevice, SessionParameterObject],  GateStreamCourierInternal USING [Argument, CreateArgument, Procedure, Result],  NetworkStream USING [closeSST, CloseStatus, closeReplySST],  NSName USING [DescribeNameRecord, Name],  NSString USING [DescribeString],  RS232C USING [CommParamObject, NetAccess, DialMode],  Stream USING [Byte, CompletionCode, defaultInputOptions, Handle,    SubSequenceType, TimeOut];GateStreamCourier: MONITOR   IMPORTS Auth, Courier, NSName, NSString , Stream  EXPORTS GateStreamCourierInternal =  BEGIN    closeEvent: CONDITION;  argumentDescription: ARRAY GateStreamCourierInternal.Procedure OF    Courier.Description = [    NIL , IAmStillHereArgument, OldCreateArgument, DeleteArgument,    NIL, NIL, NIL, NIL, NIL];  resultDescription: ARRAY GateStreamCourierInternal.Procedure OF    Courier.Description = [    NIL, NIL, CreateResult, NIL,    NIL, NIL, NIL, NIL, NIL];      newArgumentDescription: ARRAY GateStreamCourierInternal.Procedure OF    Courier.Description = [    NIL , IAmStillHereArgument, CreateArgument, DeleteArgument,    NIL, NIL, NIL, NIL, NIL];   newResultDescription: ARRAY GateStreamCourierInternal.Procedure OF    Courier.Description = [    NIL, NIL, CreateResult, NIL,    NIL, NIL, NIL, NIL, NIL];       ArgumentDescription: PUBLIC PROCEDURE [    procedure: GateStreamCourierInternal.Procedure,    oldVersion: BOOLEAN] RETURNS [Courier.Description] =    BEGIN    IF oldVersion THEN RETURN[argumentDescription[procedure]]    ELSE RETURN [newArgumentDescription[procedure]];     END;  ResultDescription: PUBLIC PROCEDURE [    procedure: GateStreamCourierInternal.Procedure,    oldVersion: BOOLEAN] RETURNS [Courier.Description] =    BEGIN    IF oldVersion THEN RETURN[resultDescription[procedure]]    ELSE RETURN [newResultDescription[procedure]];    END;  -- GAP protocol descriptions    IAmStillHereArgument: Courier.Description =     BEGIN    [] ¬ notes.noteSize[SIZE[iAmStillHere GateStreamCourierInternal.Argument]];    END;    OldCreateArgument: Courier.Description =    BEGIN    i: CARDINAL;    argument: LONG POINTER TO create GateStreamCourierInternal.Argument =      notes.noteSize[SIZE[create GateStreamCourierInternal.Argument]];    notes.noteDisjointData[      @argument.sessionParameters, OldSessionParameterObjectDescription];    notes.noteArrayDescriptor[@argument.transportList,      SIZE[GateStream.TransportObject], 32];    FOR i IN [0..LENGTH[argument.transportList]) DO      notes.noteParameters[        @argument.transportList[i], OldTransportObjectDescription];      ENDLOOP;    END;  OldCreateResult: Courier.Description =    BEGIN    [] ¬ notes.noteSize[SIZE[create GateStreamCourierInternal.Result]];    END;    CreateArgument: Courier.Description =    BEGIN    i: CARDINAL;    argument: LONG POINTER TO GateStreamCourierInternal.CreateArgument =      notes.noteSize[SIZE[GateStreamCourierInternal.CreateArgument]];    notes.noteDisjointData[      @argument.sessionParameters, SessionParameterObjectDescription];    notes.noteArrayDescriptor[@argument.transportList,      SIZE[GateStream.TransportObject], 32];    FOR i IN [0..LENGTH[argument.transportList]) DO      notes.noteParameters[        @argument.transportList[i], TransportObjectDescription];      ENDLOOP;    notes.noteParameters[@argument.credentials,  Auth.DescribeCredentials];    notes.noteParameters[@argument.verifier,  Auth.DescribeVerifier];    END;  CreateResult: Courier.Description =    BEGIN    [] ¬ notes.noteSize[SIZE[create GateStreamCourierInternal.Result]];    END;  DeleteArgument: Courier.Description =    BEGIN    [] ¬ notes.noteSize[SIZE[delete GateStreamCourierInternal.Argument]];    END;  -- Misc description procedures  CommParamObjectDescription: Courier.Description =    BEGIN    commParamSizes: ARRAY INTEGER       [0..LOOPHOLE[LAST[RS232C.NetAccess]]] OF CARDINAL ¬ [        SIZE[directConn RS232C.CommParamObject],	SIZE[dialConn RS232C.CommParamObject]];    commParams: LONG POINTER TO RS232C.CommParamObject ¬      notes.noteSize[SIZE[RS232C.CommParamObject]];    notes.noteChoice[commParams, SIZE[RS232C.CommParamObject],      DESCRIPTOR[commParamSizes], @commParams­.accessDetail];    END;  OldCommParamObjectDescription: Courier.Description =    BEGIN    commParamSizes: ARRAY INTEGER       [0..LOOPHOLE[LAST[RS232C.NetAccess]]] OF CARDINAL ¬ [        SIZE[RS232C.NetAccess], SIZE[RS232C.NetAccess] +       SIZE[RS232C.DialMode] + SIZE[CARDINAL] +      SIZE[Dialup.RetryCount]];    commParams: LONG POINTER TO RS232C.CommParamObject ¬      notes.noteSize[SIZE[RS232C.CommParamObject]];    notes.noteChoice[@commParams­.accessDetail, SIZE[RS232C.NetAccess] +      SIZE[RS232C.DialMode] + SIZE[CARDINAL] + SIZE[Dialup.RetryCount],      DESCRIPTOR[commParamSizes], @commParams­.accessDetail];    END;    -- This is the session parameter object description routine for the old  -- version of GAP.  It is complicated by the fact that it tries to map   -- the non-implemented tty and ttyHost variants into the oldTty and oldTtyHost  -- variants.  It does this by checking to see if it is using   OldSessionParameterObjectDescription: Courier.Description =    BEGIN    sessionParameterObjectSizes: ARRAY INTEGER      [0..ORD[LAST[GateStreamExtras.ForeignDevice]]] OF CARDINAL ¬ [        SIZE[xerox800 GateStream.SessionParameterObject],        SIZE[xerox850 GateStream.SessionParameterObject],	SIZE[xerox860 GateStream.SessionParameterObject], 	SIZE[system6 GateStream.SessionParameterObject],        SIZE[cmcII GateStream.SessionParameterObject],         SIZE[ibm2770 GateStream.SessionParameterObject], 	SIZE[ibm2770Host GateStream.SessionParameterObject],	SIZE[ibm6670 GateStream.SessionParameterObject],        SIZE[ibm6670Host GateStream.SessionParameterObject],        SIZE[ibm3270 GateStream.SessionParameterObject],        SIZE[ibm3270Host GateStream.SessionParameterObject],        SIZE[oldTtyHost GateStreamExtras.SessionParameterObject],        SIZE[oldTty GateStreamExtras.SessionParameterObject],        SIZE[other GateStream.SessionParameterObject],        SIZE[unknown GateStream.SessionParameterObject],        SIZE[ibm2780 GateStream.SessionParameterObject],        SIZE[ibm2780Host GateStream.SessionParameterObject],	SIZE[ibm3780 GateStream.SessionParameterObject],	SIZE[ibm3780Host GateStream.SessionParameterObject],	SIZE[siemens9750 GateStream.SessionParameterObject],	SIZE[siemens9750Host GateStream.SessionParameterObject],	SIZE[ttyHost GateStreamExtras.SessionParameterObject],        SIZE[tty GateStreamExtras.SessionParameterObject]];    sessionParams: LONG POINTER TO GateStreamExtras.SessionParameterObject ¬      notes.noteSize[SIZE[GateStreamExtras.SessionParameterObject]];    --Ok, check for the special case.   We must be fetching (user sending to    -- a server) and we must be trying to send either tty or ttyHost variant    -- of SessionParameterObject    IF notes.operation = fetch AND       (sessionParams.foreignDevice = ttyHost OR         sessionParams.foreignDevice = tty) THEN        BEGIN	tempParams: GateStreamExtras.SessionParameterObject;	-- Make a copy of the variant, changing the foreign device type to be	-- one supported by the old version of the server	WITH sessionParams­ SELECT FROM	  tty => tempParams ¬ [	    oldTty[charLength, parity, stopBits, frameTimeout]];	  ttyHost => tempParams ¬ [	    oldTtyHost[charLength, parity, stopBits, frameTimeout]]; 	  ENDCASE;	-- Skip over the original variant space so Courier won't get confused	notes.noteDeadSpace[sessionParams, 	  SIZE[GateStreamExtras.SessionParameterObject]];	-- Now send the old version.  Since nothing in either the oldTtyHost or 	-- oldTty variant needs noting, this is easy...we just note the size of	-- the descriminated variant and it goes out correctly.	notes.noteSpace[@tempParams, IF tempParams.foreignDevice = oldTty	  THEN SIZE[oldTty GateStreamExtras.SessionParameterObject] 	  ELSE SIZE[oldTtyHost GateStreamExtras.SessionParameterObject]];	END    ELSE      notes.noteChoice[sessionParams,        SIZE[GateStreamExtras.SessionParameterObject],         DESCRIPTOR[sessionParameterObjectSizes], @sessionParams­.variantPart];    END;  SessionParameterObjectDescription: Courier.Description =    BEGIN    sessionParameterObjectSizes: ARRAY INTEGER      [0..ORD[LAST[GateStreamExtras.ForeignDevice]]] OF CARDINAL ¬ [        SIZE[xerox800 GateStream.SessionParameterObject],        SIZE[xerox850 GateStream.SessionParameterObject],	SIZE[xerox860 GateStream.SessionParameterObject], 	SIZE[system6 GateStream.SessionParameterObject],        SIZE[cmcII GateStream.SessionParameterObject],         SIZE[ibm2770 GateStream.SessionParameterObject], 	SIZE[ibm2770Host GateStream.SessionParameterObject],	SIZE[ibm6670 GateStream.SessionParameterObject],        SIZE[ibm6670Host GateStream.SessionParameterObject],        SIZE[ibm3270 GateStream.SessionParameterObject],        SIZE[ibm3270Host GateStream.SessionParameterObject],        SIZE[oldTtyHost GateStreamExtras.SessionParameterObject],        SIZE[oldTty GateStreamExtras.SessionParameterObject],        SIZE[other GateStream.SessionParameterObject],        SIZE[unknown GateStream.SessionParameterObject],        SIZE[ibm2780 GateStream.SessionParameterObject],        SIZE[ibm2780Host GateStream.SessionParameterObject],	SIZE[ibm3780 GateStream.SessionParameterObject],	SIZE[ibm3780Host GateStream.SessionParameterObject],	SIZE[siemens9750 GateStream.SessionParameterObject],	SIZE[siemens9750Host GateStream.SessionParameterObject],	SIZE[ttyHost GateStreamExtras.SessionParameterObject],        SIZE[tty GateStreamExtras.SessionParameterObject]];    sessionParams: LONG POINTER TO GateStreamExtras.SessionParameterObject ¬      notes.noteSize[SIZE[GateStreamExtras.SessionParameterObject]];    notes.noteChoice[sessionParams, SIZE[GateStreamExtras.SessionParameterObject],       DESCRIPTOR[sessionParameterObjectSizes], @sessionParams­.variantPart];    END;  TransportObjectDescription: Courier.Description =    BEGIN    transportObjectSizes: ARRAY INTEGER       [0..ORD[LAST[GateStream.Transport]]] OF CARDINAL ¬ [        SIZE[rs232c GateStream.TransportObject],	SIZE[bsc GateStream.TransportObject],        SIZE[teletype GateStream.TransportObject],         SIZE[polledBSCController GateStream.TransportObject],         SIZE[polledBSCTerminal GateStream.TransportObject],         SIZE[sdlcController GateStream.TransportObject],         SIZE[sdlcTerminal GateStream.TransportObject],         SIZE[service GateStream.TransportObject],        SIZE[ttyPort GateStream.TransportObject],	SIZE[polledBSCPrinter GateStream.TransportObject],	SIZE[sdlcPrinter GateStream.TransportObject]];    transport: LONG POINTER TO GateStream.TransportObject ¬      notes.noteSize[SIZE[GateStream.TransportObject]];    notes.noteChoice[transport, SIZE[GateStream.TransportObject],      DESCRIPTOR[transportObjectSizes], @transport­.transport];    WITH transport­ SELECT FROM      rs232c =>        BEGIN        notes.noteDisjointData[@commParams, CommParamObjectDescription];        notes.noteString[@phoneNumber];	notes.noteParameters[@line, LineDescription];        END;      bsc =>        BEGIN        notes.noteString[@localTerminalID];        notes.noteString[@localSecurityID];        END;      polledBSCController =>        BEGIN        notes.noteString[@hostControllerName];        notes.noteString[@alternateControllerName];	notes.noteArrayDescriptor[@accessControl, SIZE[NSName.Name], 32];	FOR index: CARDINAL IN [0..LENGTH[accessControl]) DO	  notes.noteParameters[@accessControl[index], NSName.DescribeNameRecord];	  ENDLOOP;	notes.noteParameters[@controllerName, NSName.DescribeNameRecord];	notes.noteParameters[@controllerPassword, NSString.DescribeString];	END;      sdlcController =>        BEGIN        notes.noteString[@hostControllerName];         notes.noteString[@alternateControllerName];	notes.noteArrayDescriptor[@accessControl, SIZE[NSName.Name], 32];	FOR index: CARDINAL IN [0..LENGTH[accessControl]) DO	  notes.noteParameters[@accessControl[index], NSName.DescribeNameRecord];	  ENDLOOP;	notes.noteParameters[@controllerName, NSName.DescribeNameRecord];	notes.noteParameters[@controllerPassword, NSString.DescribeString];	END;       polledBSCTerminal, sdlcTerminal, polledBSCPrinter, sdlcPrinter =>        notes.noteString[@hostControllerName];      service => notes.noteLongCardinal[@id];      ttyPort =>        notes.noteString[@name];      ENDCASE;    END;    OldTransportObjectDescription: Courier.Description =    BEGIN    transportObjectSizes: ARRAY INTEGER       [0..ORD[LAST[GateStream.Transport]]] OF CARDINAL ¬ [        SIZE[rs232c GateStream.TransportObject],	SIZE[bsc GateStream.TransportObject],        SIZE[teletype GateStream.TransportObject],         SIZE[polledBSCController GateStream.TransportObject],         SIZE[polledBSCTerminal GateStream.TransportObject],         SIZE[sdlcController GateStream.TransportObject],         SIZE[sdlcTerminal GateStream.TransportObject],         SIZE[service GateStream.TransportObject],        SIZE[ttyPort GateStream.TransportObject],	SIZE[polledBSCPrinter GateStream.TransportObject],	SIZE[sdlcPrinter GateStream.TransportObject]];    transport: LONG POINTER TO GateStream.TransportObject ¬      notes.noteSize[SIZE[GateStream.TransportObject]];    notes.noteChoice[transport, SIZE[GateStream.TransportObject],      DESCRIPTOR[transportObjectSizes], @transport­.transport];    WITH transport­ SELECT FROM      rs232c =>        BEGIN        notes.noteDisjointData[@commParams, OldCommParamObjectDescription];        notes.noteString[@phoneNumber];	notes.noteParameters[@line, LineDescription];        END;      bsc =>        BEGIN        notes.noteString[@localTerminalID];        notes.noteString[@localSecurityID];        END;      polledBSCController =>        BEGIN        notes.noteString[@hostControllerName];        notes.noteString[@alternateControllerName];	END;      sdlcController =>        BEGIN        notes.noteString[@hostControllerName];         notes.noteString[@alternateControllerName];	END;       polledBSCTerminal, sdlcTerminal, polledBSCPrinter, sdlcPrinter =>        notes.noteString[@hostControllerName];      service => notes.noteLongCardinal[@id];      ttyPort =>        notes.noteString[@name];      ENDCASE;    END;    LineDescription: Courier.Description =    BEGIN    lineSizes: ARRAY INTEGER [0..ORD[LAST[GateStream.ReserveType]]]      OF CARDINAL ¬ [        SIZE[alreadyReserved GateStream.Line],	SIZE[reserveNeeded GateStream.Line]];    line: LONG POINTER TO GateStream.Line ¬       notes.noteSize[SIZE[GateStream.Line]];    notes.noteChoice[line, SIZE[GateStream.Line],       DESCRIPTOR[lineSizes], @line­.line];    END;      -- Close and CloseReply    Close: PUBLIC PROCEDURE [sH: Stream.Handle] RETURNS [    status: NetworkStream.CloseStatus] =    BEGIN RETURN[CloseOrCloseReply[sH, TRUE]]; END;    CloseReply: PUBLIC PROCEDURE [sH: Stream.Handle] RETURNS [    status: NetworkStream.CloseStatus] =    BEGIN RETURN[CloseOrCloseReply[sH, FALSE]]; END;  CloseOrCloseReply: PUBLIC PROC[sH: Stream.Handle, close: BOOLEAN]    RETURNS [status: NetworkStream.CloseStatus] =    BEGIN        process: PROCESS;    closeOrCloseReplyReceived: BOOLEAN ¬ FALSE;        Flusher: PROCEDURE =      BEGIN      -- Flush the stream looking for close or closeReply      -- End when closeReply seen or stream error.      sst: Stream.SubSequenceType;      compCode: Stream.CompletionCode;      data: PACKED ARRAY [0..2) OF Stream.Byte;      block: Environment.Block ¬ [@data, 0, LENGTH[data]];      DO ENABLE Stream.TimeOut, Courier.Error =>         GOTO streamDead;      [, compCode, sst] ¬ sH.get[sH, block, Stream.defaultInputOptions];      IF compCode = sstChange THEN	SELECT sst FROM	  NetworkStream.closeReplySST, NetworkStream.closeSST =>	    BEGIN	    Notify[good];	    IF sst = NetworkStream.closeReplySST THEN EXIT;	    END;	  ENDCASE;        REPEAT	  streamDead => Notify[noReply];	ENDLOOP;      END;        Notify: ENTRY PROCEDURE [newStatus: NetworkStream.CloseStatus]= INLINE      BEGIN      status ¬ newStatus;      closeOrCloseReplyReceived ¬ TRUE;      BROADCAST closeEvent;      END;        Wait: ENTRY PROCEDURE = INLINE      BEGIN      UNTIL closeOrCloseReplyReceived DO WAIT closeEvent ENDLOOP;      END;    status ¬ good;    process ¬ FORK Flusher[];    -- If doing a close, send the closeSST and wait for close    -- or close reply back.    IF close THEN      BEGIN ENABLE Stream.TimeOut, Courier.Error =>        {status ¬ noReply; CONTINUE};      sH.setSST[sH, NetworkStream.closeSST];      sH.sendNow[sH, FALSE];      Wait[];      END;    -- Send close reply.      BEGIN ENABLE Stream.TimeOut, Courier.Error =>        {status ¬ noReply; CONTINUE};      sH.setSST[sH, NetworkStream.closeReplySST];      sH.sendNow[sH, FALSE];      END;    -- Join flusher.  The flusher returns when a closeReply is received or    -- the stream times out or terminates.    JOIN process;    END; --CloseOrCloseReply   END. LOG 4-Jun-81 15:29:58  Danielson   New types using variant (choice) records. 7-Jul-81 15:30:28  Danielson   Fix conversion to GateStream.Transport. 5-Aug-81 18:24:07  Danielson   Remove RS232CManager.15-Sep-81 11:38:35  Danielson   1) New Reset call 				2) Copy LineReservation.29-Oct-81 16:54:38  Danielson   Fix 3270 variants for TransportObj17-Dec-81 16:20:20  Danielson   Make some strings long 8-Jan-82 13:27:05  Danielson   Conversion to new Courier18-Feb-82 15:45:53  Danielson   Fix length for variant records in Transport 				Object and CommParamHandle18-Mar-82 18:36:25  Danielson   New IAmStillHere parms 8-Jul-83 15:33:44  Danielson   Added ibm2780 and ibm2780Host30-Sep-83 17:09:54  Danielson   Authentication/Klamath 1-Nov-83 10:09:52  Danielson   Deserialize Credentials and Verifiers correctly 9-Dec-83 16:21:42  Danielson   New Auth21-Feb-84 13:25:23  Thatcher	GateStreamExtras for flow control 12-Mar-84 15:06:50  Danielson	Allow use talking to old version of server to				 specify ttyHost or tty which are mapped into				 oldTtyHost and oldTty by the session parameter				 object deserialization routine. 12-Mar-84 15:06:50  Danielson	Fix Close and CloseReply to fork receiver. 7-Jan-85 17:35:05  SMA  Catch Courier.Error instead of ConnectionSuspended.
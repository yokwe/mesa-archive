-- Copyright (C) 1984, 1985  by Xerox Corporation. All rights reserved. -- File: GateStreamInstance.mesa - last edit:-- Danielson.PA        20-Jun-84  9:50:44DIRECTORY  CFDStream USING [    Delete, Handle, PhysicalRecord, SendAttention, SetSST, WaitForAttention,    PutBlock, GetBlock],  GateStream USING [ForeignDevice,    none, abortMark, audibleSignal, abortGetTransaction, abortPutTransaction,    interrupt, cleanup],  GateStubInternal USING [StreamInstanceHandle, StreamInstanceObject],  Process USING [CancelAbort, GetCurrent, InitializeCondition, MsecToTicks],  Runtime USING [SelfDestruct],  Stream USING [EndOfStream,    Handle, Object, SubSequenceType, Block, Byte, InputOptions, CompletionCode,    TimeOut, LongBlock, Milliseconds, SetTimeoutProcedure,     ShortBlock, SSTChange, defaultObject];GateStreamInstance: MONITOR  IMPORTS CFDStream, Process, Runtime, Stream  EXPORTS GateStubInternal =  BEGIN  -- various definitions  JoinReturnStatus: TYPE = {    normal, transportDown};  -- timeout object  TimeoutObject: TYPE = RECORD [    timeLeft: LONG CARDINAL, timeout: CONDITION,    complete: BOOLEAN];  -- writeable data  deviceType: GateStream.ForeignDevice;  -- instanceControl  inUse: BOOLEAN ¬ FALSE;  newed: BOOLEAN ¬ FALSE;  -- object and neighbor related data  instanceObject: GateStubInternal.StreamInstanceObject;  oldSendSst: Stream.SubSequenceType ¬ GateStream.none;  oldReceiveSST: Stream.SubSequenceType ¬ GateStream.none;  -- timeout support (for gets, and puts)  timerTicks: CARDINAL ¬ Process.MsecToTicks[timerResolutionInMilliSecs];  streamTimeout: Stream.Milliseconds ¬ LAST[LONG CARDINAL];  timerResolutionInMilliSecs: CARDINAL = 2000;  --milliseconds    initialize: PROCEDURE [    cfd: CFDStream.Handle, device: GateStream.ForeignDevice, new: BOOLEAN]    RETURNS [instance: GateStubInternal.StreamInstanceHandle] ¬       Initialize;  -- Instance object procedures   SetWaitTime: Stream.SetTimeoutProcedure =    -- Revise the timeout (old timers will not be fixed)     BEGIN streamTimeout ¬ waitTime; END;  -- Stream Object Procedures  Delete: PROCEDURE [sH: Stream.Handle] =    -- Delete foreign device stream and make this instance disappear    BEGIN    Process.CancelAbort[Process.GetCurrent[]];    CFDStream.Delete[instanceObject.cfdStream];    FreeInstance[];    IF newed THEN Runtime.SelfDestruct[];    END;  SetSST: PROCEDURE [sH: Stream.Handle, sst: Stream.SubSequenceType] =    -- Set Subsequence Type, send attention if necessary    -- this guy serves both out-of-band and stream marking functions    -- when Pilot Streams get attention data, we will only propogate    -- marks here    BEGIN    -- IF sst = oldSendSst THEN RETURN;    -- SELECT oldSendSst ¬ sst FROM      -- GateStream.none, GateStream.abortGetTransaction,        -- GateStream.abortPutTransaction, GateStream.endOfTransparentData,        -- GateStream.transparentDataFollows, GateStream.endOfTransaction,        -- GateStream.disconnect, GateStream.yourTurnToSend =>        -- BEGIN        -- screen controls that are not applicable        -- IF sst = GateStream.abortGetTransaction THEN        -- SELECT deviceType FROM        -- xerox800, xerox850, xerox860 =>        -- ERROR DeviceOperationAborted[invalidControl];        -- ENDCASE;        -- END;      -- ENDCASE;    CFDStream.SetSST[instanceObject.cfdStream, sst];    END;  Get: PROCEDURE [    sH: Stream.Handle, block: Stream.Block, options: Stream.InputOptions]    RETURNS [      bytesTransferred: CARDINAL, why: Stream.CompletionCode,      sst: Stream.SubSequenceType] =    -- implements GetBlock and GetByte    BEGIN    -- locals    getProcess: PROCESS      RETURNS [        CARDINAL, Stream.CompletionCode, Stream.SubSequenceType,        JoinReturnStatus];    status: JoinReturnStatus;    originalStartIndex: CARDINAL = block.startIndex;    partialBytes: CARDINAL;    DO      -- fork the real Get and wait on a timer      IF streamTimeout # LAST[LONG CARDINAL] THEN        BEGIN        timeout: TimeoutObject;	timeout.complete ¬ FALSE;        timeout.timeLeft ¬ streamTimeout;	Process.InitializeCondition[@timeout.timeout, timerTicks];        getProcess ¬ FORK ForkedDoGet[block, @timeout];        DO          ENABLE            UNWIND => -- client did not RESUME timeout signal	      BEGIN	      -- send an AbortGetTransaction generic control, join get process and               -- then wait until mark is received              CFDStream.SendAttention[                instanceObject.cfdStream, GateStream.abortGetTransaction !		  ABORTED => CONTINUE];              [,,sst,status] ¬ JOIN getProcess;              UNTIL sst = GateStream.abortMark OR status # normal DO	        [,,sst, status] ¬ DoGet[block ! ABORTED => EXIT];		ENDLOOP;              END;          IF WaitTransferComplete[@timeout] THEN EXIT          ELSE SIGNAL Stream.TimeOut[block.startIndex];  --Timeout occurred          timeout.timeLeft ¬ streamTimeout;  -- client did RESUME	  ENDLOOP;        [partialBytes, why, sst, status] ¬ JOIN getProcess;        END  -- normal completion of timed operation      ELSE [partialBytes, why, sst, status] ¬ DoGet[block];      -- update block pointers      block.startIndex ¬ block.startIndex + partialBytes;      -- Handle end of stream      IF why = endOfStream THEN        IF options.signalEndOfStream THEN	  SIGNAL Stream.EndOfStream[block.startIndex]	ELSE EXIT;      -- Handle sst changes      IF why = sstChange THEN        IF options.signalSSTChange THEN          SIGNAL Stream.SSTChange[sst, block.startIndex]        ELSE EXIT;      -- Handle block filling up      IF block.startIndex = block.stopIndexPlusOne THEN        BEGIN        IF why # endRecord THEN          IF options.signalShortBlock THEN ERROR Stream.ShortBlock          ELSE why ¬ normal        ELSE          IF options.terminateOnEndRecord THEN why ¬ endRecord          ELSE why ¬ normal;        EXIT;        END;      -- End physicalRecord and partially full      IF why = endRecord THEN        BEGIN        IF options.terminateOnEndRecord THEN EXIT;        IF options.signalLongBlock THEN          SIGNAL Stream.LongBlock[block.startIndex];        END;      ENDLOOP;    -- Validate SST (this code could be removed)    --SELECT sst FROM        --GateStream.none, GateStream.cleanup,         --GateStream.endOfTransaction, GateStream.yourTurnToSend, 	--GateStream.disconnect, GateStream.transparentDataFollows,         --GateStream.endOfTransparentData, GateStream.abortMark,        --GateStream.parityError, GateStream.garbledReceiveData,	--GateStream.chain3270, GateStream.unchained3270,	--GateStream.readModified3270, GateStream.status3270,	--GateStream.testRequest3270 => NULL;      --ENDCASE => ERROR;    bytesTransferred ¬ block.startIndex - originalStartIndex;    END;  Put: PROCEDURE [    sH: Stream.Handle, block: Stream.Block, endRecord: BOOLEAN] =    -- implements PutBlock and PutByte    BEGIN    -- locals    putProcess: PROCESS RETURNS [JoinReturnStatus];    status: JoinReturnStatus;    -- fork the real Put and wait on a timer    IF streamTimeout # LAST[LONG CARDINAL] THEN      BEGIN      timeout: TimeoutObject;      timeout.complete ¬ FALSE;      timeout.timeLeft ¬ streamTimeout;      Process.InitializeCondition[@timeout.timeout, timerTicks];      putProcess ¬ FORK ForkedDoPut[block, endRecord, @timeout];      DO        ENABLE          UNWIND => -- client did not resume timeout signal	    -- Send abortPutTransaction and JOIN putProcess	    BEGIN	    CFDStream.SendAttention[              instanceObject.cfdStream, GateStream.abortPutTransaction !	        ABORTED => CONTINUE];              [] ¬ JOIN putProcess;              CFDStream.SetSST[instanceObject.cfdStream,	        GateStream.abortPutTransaction ! ABORTED => CONTINUE];	     END;        IF WaitTransferComplete[@timeout] THEN EXIT        ELSE SIGNAL Stream.TimeOut[nextIndex: 0];  -- Timeout occurred        timeout.timeLeft ¬ streamTimeout;  -- client did RESUME        ENDLOOP;      status ¬ JOIN putProcess;  -- normal completion of timed operation      END    ELSE status ¬ DoPut[block, endRecord];  -- NIL timeout means no timeout    END;  SendAttention: PROCEDURE [sH: Stream.Handle, byte: Stream.Byte] =    -- send attention if in legal state    BEGIN OPEN GateStream;    SELECT byte FROM      interrupt,       audibleSignal,       abortGetTransaction,       abortPutTransaction,       cleanup => NULL;      -- abortGetTransaction =>      -- SELECT deviceType FROM      -- xerox800, xerox850, xerox860 =>      -- ERROR DeviceOperationAborted[invalidControl];  not applicable      -- ENDCASE => NULL;      ENDCASE -- resume, areYouThere, iAmHere -- => RETURN;    CFDStream.SendAttention[      instanceObject.cfdStream, byte];    END;  WaitAttention: PROCEDURE [sH: Stream.Handle] RETURNS [byte: Stream.Byte] =    -- receive attention; may be from downstream    BEGIN OPEN GateStream;    byte ¬ CFDStream.WaitForAttention[instanceObject.cfdStream];    --SELECT byte FROM      --IN [none..abortPutTransaction], -- -- out-of-band      --IN [cleanup..excessiveRetransmissions],-- -- global status --      --configurationMismatch3270, hostPolling3270, hostNotPolling3270	   --=> NULL;      --ENDCASE => ERROR;    END;  -- Stream Operation Support Procedures    ForkedDoPut: PROCEDURE [        block: Stream.Block, endPhysicalRecord: BOOLEAN,    timeout: POINTER TO TimeoutObject] RETURNS [status: JoinReturnStatus] =    -- this procedure is the one used when the DoPut is FORKED.  It just    -- catches the various signals that can be raised by the DoPut routine    -- so they won't be UNCAUGHT SIGNALS    BEGIN    status ¬ transportDown;    status ¬ DoPut[block, endPhysicalRecord ! ABORTED => CONTINUE];    NotifyTransferComplete[timeout];    END;      DoPut: PROCEDURE [    block: Stream.Block, endPhysicalRecord: BOOLEAN] RETURNS [    status: JoinReturnStatus] =    -- this procedure or process does the real work of the Put    -- translate to CFDStream calls and record outstanding operations    BEGIN    -- locals    frameObject: CFDStream.PhysicalRecord ¬ [      header: [NIL, 0, 0], body: block, trailer: [NIL, 0, 0]];    status ¬ normal;    -- send the frame    CFDStream.PutBlock[        instanceObject.cfdStream, @frameObject, endPhysicalRecord];    -- notify that Put is done, if necessary mark spot in     END;    ForkedDoGet: PROCEDURE [block: Stream.Block, timeout: POINTER TO TimeoutObject]    RETURNS [      bytesTransferred: CARDINAL, why: Stream.CompletionCode,      sst: Stream.SubSequenceType, status: JoinReturnStatus] =    -- Does a DoGet, but catches some signals    BEGIN    bytesTransferred ¬ 0;    why ¬ endOfStream;    sst ¬ GateStream.none;    status ¬ transportDown;    [bytesTransferred, why, sst, status] ¬ DoGet[block !      ABORTED, Stream.EndOfStream => CONTINUE];    NotifyTransferComplete[timeout];    END;  DoGet: PROCEDURE [block: Stream.Block]    RETURNS [      bytesTransferred: CARDINAL, why: Stream.CompletionCode,      sst: Stream.SubSequenceType, status: JoinReturnStatus] =    -- does the work of the Get; may be a procedure or a process    BEGIN    -- locals    frameObject: CFDStream.PhysicalRecord ¬ [      header: [NIL, 0, 0], body: block, trailer: [NIL, 0, 0]];    status ¬ normal;    -- receive the frame    [bytesTransferred, why, sst] ¬ CFDStream.GetBlock[        instanceObject.cfdStream, @frameObject];    END;  WaitTransferComplete: ENTRY PROCEDURE [timeout: POINTER TO TimeoutObject]    RETURNS [normalCompletion: BOOLEAN] =    -- used to timeout Gets and Puts    -- also returns if Get or Put returns successfully    BEGIN    WHILE timeout.timeLeft > 0 AND ~timeout.complete DO      WAIT timeout.timeout;  -- waits for timerResolutionInSecs      IF timeout.timeLeft <= timerResolutionInMilliSecs THEN EXIT;       timeout.timeLeft ¬ timeout.timeLeft -timerResolutionInMilliSecs;      ENDLOOP;    RETURN[timeout.complete];    END;  NotifyTransferComplete: ENTRY PROCEDURE [timeout: POINTER TO TimeoutObject] =    -- notify the condition and set get done id    BEGIN    IF timeout # NIL THEN      BEGIN      timeout.complete ¬ TRUE;      NOTIFY timeout.timeout;      END;    END;  -- Instance Control  NewStreamInstance: PUBLIC PROCEDURE [    cfd: CFDStream.Handle, device: GateStream.ForeignDevice]    RETURNS [instance: GateStubInternal.StreamInstanceHandle] =    BEGIN    IF ~GetNewInstance[] THEN RETURN[Initialize[cfd, device, FALSE]]    ELSE      BEGIN      frame: LONG POINTER TO FRAME[GateStreamInstance] ¬ NEW GateStreamInstance;      START frame;      RETURN[frame.initialize[cfd, device, TRUE]];      END;    END;  GetNewInstance: ENTRY PROCEDURE RETURNS [new: BOOLEAN] =    BEGIN  -- always called from original instance --    new ¬ inUse;    inUse ¬ TRUE;    END;  FreeInstance: ENTRY PROCEDURE[] = BEGIN inUse ¬ FALSE; END;  Initialize: PROCEDURE [    cfd: CFDStream.Handle, device: GateStream.ForeignDevice, new: BOOLEAN]    RETURNS [instance: GateStubInternal.StreamInstanceHandle] =    BEGIN    deviceType ¬ device;    newed ¬ new;    instanceObject.streamObject ¬ Stream.defaultObject;    instanceObject.streamObject.get ¬ Get;    instanceObject.streamObject.put ¬ Put;    instanceObject.streamObject.setSST ¬ SetSST;    instanceObject.streamObject.sendAttention ¬ SendAttention;    instanceObject.streamObject.waitAttention ¬ WaitAttention;    instanceObject.streamObject.delete ¬ Delete;    instanceObject.streamObject.setTimeout ¬ SetWaitTime;    instanceObject.cfdStream ¬ cfd;    instance ¬ @instanceObject;  -- instance handle    END;  END.LOG13-Apr-81 16:27:26  BRD  Fix code to follow stream conventions better.13-Apr-81 15:23:00  SAB  Added the two new SSTs; endOfTransparentData                          and transparentDataFollows to SetSST and Get PROCs.24-Apr-81 14:50:38  BRD  Combined April 13 changes by Bishop with my changes. 3-Jun-81 18:21:00  BRD  Misc cleanup when during conversion to GAP. 9-Dec-81 16:47:43  DDM  Added two 3270 SSTs unchained3270 and readModified327017-Dec-81 15:58:49  BRD  Trinity changes30-Apr-82 16:46:09  DDM  WaitAttention support of 3270 Attentions: extraSSTValue1                          (hostPolling) and extraSSTValue2 (hostNotPolling)12-May-82 14:28:07  DDM  WaitAttention support of configurationMismatch3270 6-Oct-82 15:33:33  MZA  extraSSTs renamed to host(Not)Polling3270;                         changed WaitAttn range cleanup..excessiveRetransmissions;			 SendAttention support of interrupt sst14-Jun-83 13:38:03  BRD  Re-organize stub19-Jul-83 17:16:30  BRD  End of stream processing 5-Oct-83 11:46:07  BRD  Klamath conversion 5-Mar-84 17:16:39  BRD  Cancel pending aborts on entry to Delete12-Mar-84 15:20:53  BRD  Catch signals when FORKing DoGet and DoPut20-Jun-84  9:38:18  BRD  Handle aborting of timing out events correctly.  			  The catch code for ABORTED was by passing the			  signalling of the transfer as complete.
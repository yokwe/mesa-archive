-- File: RS232CSubDriver.mesa - last edit:-- AOF                 15-Oct-87 19:51:11-- BKI                 11-Jan-88 14:57:29-- JPM                 18-Oct-85 13:49:17-- Copyright (C) 1984, 1985, 1987, 1988 by Xerox Corporation. All rights reserved.<<This MONITOR is a machine-independent implementation of nominally driver-likefunctions which are underneath the current RS-232-C Face. It is hoped that thesefunctions may eventually be incorporated into the RS-232-C driver, and that allmachine-dependent heads would then implement a new interface (herein referred toas NewRS232CFace).>>DIRECTORY  ByteBlt USING [ByteBlt],  Environment USING [Block, Byte, wordsPerPage],  Heap USING [Create, Delete],  NewRS232CFace USING [    Command, CommandStatus, CompletedTransferStatus, DeviceStatus,    GetDeviceStatus, GetHandle, GetNextLine, Handle, Initialize,    InitializeCleanup, InitiateCommand, InitiateReceive,    InitiateResetStatusBits, InitiateSetControlBits, InitiateSetParameters,    InitiateTransmit, nilHandle, Operation, OperationPtr, operationAlignment,    operationLocation, operationSize, ParameterRecord, ParameterStatus,    PollCommand, PollReceiveOrTransmit, PollResetStatusBits,    PollSetControlBits, PollSetParameters, ReleaseHandle, TransferStatus],  Process USING [    Abort, EnableAborts, InitializeCondition, MsecToTicks,    Pause, Priority, SecondsToTicks, SetPriority],  ProcessPriorities USING [priorityRS232C],  ResidentHeap USING [first64K, FreeNode, MakeNode],  RS232CCorrespondents USING [illegal],  RS232CEnvironment USING [    AutoRecognitionOutcome, PhysicalRecord, PhysicalRecordHandle],  RS232CFace USING [    AbortType, DeviceStatus, Handle, Object, ParamHandle, ParameterOutcome,    TransferStatus],  SpecialHeap USING [MakeResident, MakeSwappable],  SpecialRuntime USING [AllocateNakedCondition, DeallocateNakedCondition],  Zone USING [Base, Status];RS232CSubDriver: MONITOR LOCKS root  IMPORTS    ByteBlt, Heap, NewRS232CFace, Process, ResidentHeap,    SpecialHeap, SpecialRuntime  EXPORTS RS232CFace, RS232CEnvironment =  BEGIN  root: PUBLIC MONITORLOCK;  -- PUBLIC TYPE for RS232CEnvironment  CompletionHandle: PUBLIC TYPE = LONG POINTER TO CompletionRecord;  CompletionRecord: TYPE = RECORD  [ operation: Zone.Base RELATIVE POINTER TO NewRS232CFace.Operation,    direction: {receive, transmit},    status: NewRS232CFace.TransferStatus,    physicalRecord: RS232CEnvironment.PhysicalRecord,    buffer: PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte ];  -- TYPE for allocating line-specific objects  LineHandle: TYPE = LONG POINTER TO LineObject;  LineObject: TYPE = RECORD  [ object: RS232CFace.Object ¬ [      abort: LocalAbort,      autoRecognitionWait: LocalAutoRecognitionWait,      get: LocalGet,      getStatus: LocalGetStatus,      off: LocalOff,      put: LocalPut,      resetLine: LocalResetLine,      sendBreak: LocalSendBreak,      setParameters: LocalSetParameters,      statusWait: LocalStatusWait,      transferWait: LocalTransferWait,      transmitNow: LocalTransferWait      ],    nakedWakeUpPtr: LONG POINTER TO CONDITION ¬ NIL,    nakedProcess: PROCESS ¬ NIL,    handle: NewRS232CFace.Handle,    bufferZone: UNCOUNTED ZONE,    transfersPending: CARDINAL ¬ 0,    paramsSupplied: BOOLEAN ¬ FALSE,    params: NewRS232CFace.ParameterRecord ¬ NULL ];  -- global variables  upNotify: CONDITION;  zone: UNCOUNTED ZONE;  statusNotify: CONDITION;  eventCompleted: CONDITION;  waitingForStatus: CARDINAL ¬ 0;  abortStatusWait: BOOLEAN ¬ FALSE;  -- PUBLIC PROCEDUREs  GetNextLine: PUBLIC PROC [line: CARDINAL] RETURNS [nextLine: CARDINAL] =    {RETURN [NewRS232CFace.GetNextLine [line] ]};  On: PUBLIC ENTRY PROC[lineNumber: CARDINAL] RETURNS[line: RS232CFace.Handle] =    BEGIN    ENABLE UNWIND => NULL;  --I doubt this is worth while    nakedMask: WORD;    lineHandle: LineHandle;    handle: NewRS232CFace.Handle;    handle ¬ NewRS232CFace.GetHandle [lineNumber,      <<(IF DebuggerSwap.canSwap THEN>> normalClient <<ELSE debuggerClient)>>];    IF handle = NewRS232CFace.nilHandle THEN RETURN [NIL];    zone ¬ Heap.Create [      initial: 2, increment: 2,      largeNodeThreshold: (Environment.wordsPerPage * 2)];    SpecialHeap.MakeResident [zone];    lineHandle ¬ zone.NEW [LineObject ¬ [handle: handle, bufferZone: zone] ];    [cv: lineHandle.nakedWakeUpPtr, mask: nakedMask] ¬      SpecialRuntime.AllocateNakedCondition [];    Process.InitializeCondition[      lineHandle.nakedWakeUpPtr, Process.SecondsToTicks [60]];    NewRS232CFace.Initialize [nakedMask];    lineHandle.nakedProcess ¬ FORK NakedWakeUpHere[lineHandle];    line ¬ @lineHandle.object    END;  -- PRIVATE PROCEDUREs (in instance of RS232CFace.Object)  LocalAbort: ENTRY PROC [line: RS232CFace.Handle, type: RS232CFace.AbortType] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    IF line = NIL THEN RETURN;    SELECT type FROM      input => SendCommand [lineHandle.handle, abortReceive];      output => SendCommand [lineHandle.handle, abortTransmit];      other =>        BEGIN	abortStatusWait ¬ TRUE;	BROADCAST statusNotify	END;       ENDCASE    END;  LocalAutoRecognitionWait: PROC [line: RS232CFace.Handle]    RETURNS [outcome: RS232CEnvironment.AutoRecognitionOutcome] =    BEGIN    RETURN [RS232CCorrespondents.illegal] -- unimplemented    END;  LocalGet: ENTRY PROC [    line: RS232CFace.Handle, rec: RS232CEnvironment.PhysicalRecordHandle]    RETURNS [completionHandle: CompletionHandle] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    dataLength: CARDINAL;    operationPtr: NewRS232CFace.OperationPtr;    IF line = NIL OR rec = NIL THEN RETURN [NIL];    dataLength ¬ rec.header.stopIndexPlusOne - rec.header.startIndex +      rec.body.stopIndexPlusOne - rec.body.startIndex +      rec.trailer.stopIndexPlusOne - rec.trailer.startIndex;    completionHandle ¬ lineHandle.bufferZone.NEW [CompletionRecord[dataLength] ];    lineHandle.transfersPending ¬ lineHandle.transfersPending + 1;    DO  -- until EXIT      localStatus: Zone.Status;      [completionHandle.operation, localStatus] ¬ ResidentHeap.MakeNode [        NewRS232CFace.operationSize, NewRS232CFace.operationAlignment,        NewRS232CFace.operationLocation];      IF localStatus = okay THEN EXIT;      WAIT eventCompleted; --wait for someone to release resident heap space    ENDLOOP;    operationPtr ¬ @ResidentHeap.first64K[completionHandle.operation];    operationPtr­ ¬ [      dataBuffer: @completionHandle.buffer, bufferByteLength: dataLength];    completionHandle.direction ¬ receive;    completionHandle.physicalRecord ¬ rec­;    completionHandle.status ¬ NewRS232CFace.InitiateReceive [      lineHandle.handle, operationPtr]    END;  LocalGetStatus: ENTRY PROC [line: RS232CFace.Handle]    RETURNS [stat: RS232CFace.DeviceStatus] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    stat ¬ (IF line = NIL THEN      [breakDetected: FALSE, carrierDetect: FALSE, clearToSend: FALSE,      dataLost: FALSE, dataSetReady: FALSE, ringHeard: FALSE,      ringIndicator: FALSE, deviceError: TRUE]      ELSE GetStatusInternal [lineHandle.handle])    END;  LocalOff: ENTRY PROC [line: RS232CFace.Handle] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    nakedProcessCopy: PROCESS = lineHandle.nakedProcess;    IF line = NIL THEN RETURN;    IF lineHandle.transfersPending > 0 THEN      BEGIN      SendCommand [lineHandle.handle, abortReceive];      SendCommand [lineHandle.handle, abortTransmit]      END;    SendCommand [lineHandle.handle, off];    UNTIL lineHandle.transfersPending = 0 DO      WAIT eventCompleted; ENDLOOP;  --that one's not abortable (yet)    UNTIL lineHandle.nakedProcess = NIL DO      Process.EnableAborts[lineHandle.nakedWakeUpPtr];      Process.Abort[nakedProcessCopy];      WAIT eventCompleted;  --give him a chance to bail out      REPEAT FINISHED => JOIN nakedProcessCopy;      ENDLOOP;    lineHandle.handle ¬ NewRS232CFace.ReleaseHandle [lineHandle.handle];    SpecialRuntime.DeallocateNakedCondition[lineHandle.nakedWakeUpPtr];    SpecialHeap.MakeSwappable [lineHandle.bufferZone];    Heap.Delete [lineHandle.bufferZone]    END;  LocalPut: ENTRY PROC [    line: RS232CFace.Handle, rec: RS232CEnvironment.PhysicalRecordHandle]    RETURNS [completionHandle: CompletionHandle] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    dataLength: CARDINAL;    operationPtr: NewRS232CFace.OperationPtr;    IF line = NIL OR rec = NIL THEN RETURN [NIL];    dataLength ¬ rec.header.stopIndexPlusOne - rec.header.startIndex +      rec.body.stopIndexPlusOne - rec.body.startIndex +      rec.trailer.stopIndexPlusOne - rec.trailer.startIndex;    completionHandle ¬ lineHandle.bufferZone.NEW [CompletionRecord[dataLength] ];    lineHandle.transfersPending ¬ lineHandle.transfersPending + 1;    IF dataLength > 0 THEN -- copy data to data block      BEGIN      block: Environment.Block ¬ Environment.Block[        LOOPHOLE [@completionHandle.buffer], 0, dataLength];      block.startIndex ¬ ByteBlt.ByteBlt [to: block, from: rec.header];      block.startIndex ¬ block.startIndex + ByteBlt.ByteBlt [         to: block, from: rec.body];      [] ¬ ByteBlt.ByteBlt [to: block, from: rec.trailer]      END;    DO  -- until EXIT      localStatus: Zone.Status;      [completionHandle.operation, localStatus] ¬ ResidentHeap.MakeNode [        NewRS232CFace.operationSize, NewRS232CFace.operationAlignment,        NewRS232CFace.operationLocation];      IF localStatus = okay THEN EXIT;      WAIT eventCompleted; --wait for someone to release resident heap space    ENDLOOP;    operationPtr ¬ @ResidentHeap.first64K[completionHandle.operation];    operationPtr­ ¬ [      dataBuffer: @completionHandle.buffer, bufferByteLength: dataLength];    completionHandle.direction ¬ transmit;    completionHandle.physicalRecord ¬ rec­;    completionHandle.status ¬ NewRS232CFace.InitiateTransmit [      lineHandle.handle, operationPtr]    END;  LocalResetLine: ENTRY PROC [    line: RS232CFace.Handle, paramHandle: RS232CFace.ParamHandle]    RETURNS [outcome: RS232CFace.ParameterOutcome] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    IF line = NIL OR paramHandle = NIL THEN RETURN [unimplemented];    IF lineHandle.transfersPending > 0 THEN      BEGIN      SendCommand [lineHandle.handle, abortReceive];      SendCommand [lineHandle.handle, abortTransmit]      END;    IF lineHandle.paramsSupplied THEN       BEGIN      SendCommand [lineHandle.handle, off];      lineHandle.paramsSupplied ¬ FALSE      END;    SetControlBits[lineHandle.handle, paramHandle];<<  NewRS232CFace.SetControlBits [      lineHandle.handle, [dataTerminalReady: paramHandle.dataTerminalReady,      requestToSend: paramHandle.requestToSend] ];>>    IF paramHandle.resetBreakDetected      OR paramHandle.resetDataLost      OR paramHandle.resetRingHeard THEN      ResetStatusBits[lineHandle.handle, paramHandle];<<    NewRS232CFace.ResetStatusBits [        lineHandle.handle, [resetBreakDetected: paramHandle.resetBreakDetected,        resetDataLost: paramHandle.resetDataLost,        resetRingHeard: paramHandle.resetRingHeard] ];>>    lineHandle.params ¬ [      charLength: paramHandle.charLength,      clientType: unknown,      correspondent: paramHandle.correspondent,      echo: paramHandle.echo,      flowControl: paramHandle.flowControl,      frameTimeout: paramHandle.frameTimeout,      lineSpeed: paramHandle.lineSpeed,      lineType: paramHandle.lineType,      parity: paramHandle.parity,      stopBits: paramHandle.stopBits,      syncChar: paramHandle.syncChar,      syncCount: paramHandle.syncCount ];    outcome ¬ SetParameters [@lineHandle];    IF outcome = success THEN SendCommand [lineHandle.handle, on];    END;  LocalSendBreak: ENTRY PROC [line: RS232CFace.Handle] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    IF line = NIL THEN RETURN;    SendCommand [lineHandle.handle, breakOn];    Process.Pause [Process.MsecToTicks [250] ];    -- must be at least 190; 250 is safe    SendCommand [lineHandle.handle, breakOff]    END;  LocalSetParameters: ENTRY PROC [    line: RS232CFace.Handle, paramHandle: RS232CFace.ParamHandle]    RETURNS [outcome: RS232CFace.ParameterOutcome] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    workParams: NewRS232CFace.ParameterRecord;    IF line = NIL OR paramHandle = NIL THEN RETURN [unimplemented];    SetControlBits[lineHandle.handle, paramHandle];<<  NewRS232CFace.SetControlBits [      lineHandle.handle, [dataTerminalReady: paramHandle.dataTerminalReady,      requestToSend: paramHandle.requestToSend] ];>>    IF paramHandle.resetBreakDetected      OR paramHandle.resetDataLost OR paramHandle.resetRingHeard THEN      ResetStatusBits[lineHandle.handle, paramHandle];<<    NewRS232CFace.ResetStatusBits [        lineHandle.handle, [resetBreakDetected: paramHandle.resetBreakDetected,        resetDataLost: paramHandle.resetDataLost,        resetRingHeard: paramHandle.resetRingHeard] ];>>    workParams ¬ [      charLength: paramHandle.charLength,      clientType: unknown,      correspondent: paramHandle.correspondent,      echo: paramHandle.echo,      flowControl: paramHandle.flowControl,      frameTimeout: paramHandle.frameTimeout,      lineSpeed: paramHandle.lineSpeed,      lineType: paramHandle.lineType,      parity: paramHandle.parity,      stopBits: paramHandle.stopBits,      syncChar: paramHandle.syncChar,      syncCount: paramHandle.syncCount ];    IF lineHandle.paramsSupplied AND workParams = lineHandle.params THEN      outcome ¬ success    ELSE      BEGIN      IF lineHandle.paramsSupplied THEN SendCommand [lineHandle.handle, off];      lineHandle.params ¬ workParams;      outcome ¬ SetParameters [@lineHandle]      END;    IF outcome = success THEN SendCommand [lineHandle.handle, on];    END;  LocalStatusWait: ENTRY PROC [    line: RS232CFace.Handle, stat: RS232CFace.DeviceStatus]    RETURNS [newstat: RS232CFace.DeviceStatus] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    ENABLE UNWIND => NULL;    IF line = NIL THEN RETURN [stat];    newstat ¬ GetStatusInternal [lineHandle.handle];    waitingForStatus ¬ waitingForStatus + 1;    UNTIL newstat # stat OR abortStatusWait DO      ENABLE UNWIND => IF (waitingForStatus ¬ waitingForStatus - 1) = 0 THEN        abortStatusWait ¬ FALSE;  --ABORTED      WAIT statusNotify;      newstat ¬ GetStatusInternal [lineHandle.handle]    ENDLOOP;    IF (waitingForStatus ¬ waitingForStatus - 1) = 0 THEN      abortStatusWait ¬ FALSE;    END;  LocalTransferWait: ENTRY PROC [    line: RS232CFace.Handle, event: CompletionHandle]    RETURNS [byteCount: CARDINAL, status: RS232CFace.TransferStatus] =    BEGIN    OPEN lineHandle: LOOPHOLE [line, LineHandle];    statusMap: ARRAY NewRS232CFace.CompletedTransferStatus OF      RS232CFace.TransferStatus = [        success, aborted, asynchFramingError, checksumError, dataLost,        deviceError, disaster, frameTimeout, invalidChar, invalidFrame,        parityError];    IF line = NIL OR event = NIL THEN RETURN [0, disaster];    IF event.status IN NewRS232CFace.CompletedTransferStatus THEN      byteCount ¬ 0    ELSE      BEGIN      operationPtr: NewRS232CFace.OperationPtr = @ResidentHeap.first64K[event.operation];      DO        ENABLE UNWIND => NULL; --can only be aborted        [byteCount, event.status] ¬ NewRS232CFace.PollReceiveOrTransmit [lineHandle.handle, operationPtr];	IF event.status IN NewRS232CFace.CompletedTransferStatus THEN EXIT;        WAIT upNotify;      ENDLOOP      END;    -- copy data to user's data buffer if receive    IF event.direction = receive AND byteCount > 0 THEN      BEGIN      block: Environment.Block ¬ Environment.Block[        LOOPHOLE [@event.buffer], 0, byteCount];      block.startIndex ¬ ByteBlt.ByteBlt [        to: event.physicalRecord.header, from: block];      block.startIndex ¬ block.startIndex + ByteBlt.ByteBlt [        to: event.physicalRecord.body, from: block];      [] ¬ ByteBlt.ByteBlt [to: event.physicalRecord.trailer, from: block]      END;    status ¬ statusMap[event.status];      [] ¬ ResidentHeap.FreeNode [event.operation];      lineHandle.bufferZone.FREE [@event];      lineHandle.transfersPending ¬ lineHandle.transfersPending - 1;    NOTIFY eventCompleted    END;  -- other PRIVATE PROCEDUREs  GetStatusInternal: INTERNAL PROC [    handle: NewRS232CFace.Handle]    RETURNS [stat: RS232CFace.DeviceStatus] = INLINE    BEGIN    devStat: NewRS232CFace.DeviceStatus;    SendCommand [handle, getDeviceStatus];    devStat ¬ NewRS232CFace.GetDeviceStatus [handle];    stat ¬ [      breakDetected: devStat.breakDetected,      carrierDetect: devStat.carrierDetect,      clearToSend: devStat.clearToSend,      dataLost: devStat.dataLost,      dataSetReady: devStat.dataSetReady,      ringHeard: devStat.ringHeard,      ringIndicator: devStat.ringIndicator,      deviceError: FALSE]    END;  Init: PROC =    BEGIN    Process.InitializeCondition [@eventCompleted, Process.MsecToTicks [50]];    Process.InitializeCondition [@statusNotify, Process.MsecToTicks [50]];    NewRS232CFace.InitializeCleanup [];    Process.EnableAborts [@statusNotify];    Process.EnableAborts [@upNotify];    END;  NakedWakeUpHere: ENTRY PROC [lineHandle: LineHandle] =    BEGIN    Process.SetPriority [ProcessPriorities.priorityRS232C];    --UNTIL ABORTED-- DO      ENABLE ABORTED => EXIT;      WAIT lineHandle.nakedWakeUpPtr;      BROADCAST upNotify;      IF waitingForStatus > 0 THEN BROADCAST statusNotify;      ENDLOOP;    NOTIFY eventCompleted;  --tell whoever aborted us we exited    lineHandle.nakedProcess ¬ NIL;  --and set his loop invariant    END;    ResetStatusBits: INTERNAL PROC[handle: NewRS232CFace.Handle, paramHandle: RS232CFace.ParamHandle] =    BEGIN    commandStatus: NewRS232CFace.CommandStatus ¬ rejected;    DO      commandStatus ¬ (IF commandStatus = rejected        THEN NewRS232CFace.InitiateResetStatusBits[	  handle, [resetBreakDetected: paramHandle.resetBreakDetected,	  resetDataLost: paramHandle.resetDataLost,	  resetRingHeard: paramHandle.resetRingHeard] ]	ELSE NewRS232CFace.PollResetStatusBits [handle]);      IF commandStatus = completed THEN EXIT;      WAIT upNotify;      ENDLOOP;    END;  SendCommand: INTERNAL PROC [    handle: NewRS232CFace.Handle, command: NewRS232CFace.Command] =    BEGIN    commandStatus: NewRS232CFace.CommandStatus;    commandStatus ¬ NewRS232CFace.InitiateCommand [handle, command];    UNTIL commandStatus = completed DO      WAIT upNotify;      commandStatus ¬ (IF commandStatus = rejected        THEN NewRS232CFace.InitiateCommand [handle, command]	ELSE NewRS232CFace.PollCommand [handle])    ENDLOOP    END;    SetControlBits: INTERNAL PROC[handle: NewRS232CFace.Handle, paramHandle: RS232CFace.ParamHandle] =    BEGIN    commandStatus: NewRS232CFace.CommandStatus ¬ rejected;    DO      commandStatus ¬ (IF commandStatus = rejected        THEN NewRS232CFace.InitiateSetControlBits[	  handle, [dataTerminalReady: paramHandle.dataTerminalReady,	  requestToSend: paramHandle.requestToSend] ]	ELSE NewRS232CFace.PollSetControlBits [handle]);      IF commandStatus = completed THEN EXIT;      WAIT upNotify;      ENDLOOP;    END;  SetParameters: INTERNAL PROC [    lineHandle: LineHandle] RETURNS [outcome: RS232CFace.ParameterOutcome] =    BEGIN    parameterStatus: NewRS232CFace.ParameterStatus;    parameterStatus ¬ NewRS232CFace.InitiateSetParameters [lineHandle.handle, @lineHandle.params];    UNTIL parameterStatus = completed OR parameterStatus = unimplemented DO      WAIT upNotify;      parameterStatus ¬ (IF parameterStatus = rejected        THEN NewRS232CFace.InitiateSetParameters [lineHandle.handle, @lineHandle.params]	ELSE NewRS232CFace.PollSetParameters [lineHandle.handle])    ENDLOOP;    outcome ¬ (IF (lineHandle.paramsSupplied ¬ (parameterStatus = completed))      THEN success ELSE unimplemented)    END;  -- main code  Init []  END. -- RS232CSubDriverLOG7-Sep-84 -- JPM -- Created (mostly from RS232CHeadDLion).3-Oct-85 -- AOF -- Added EnableAborts and UNWINDs (?)18-Oct-85 -- JPM -- Put fast timeout on statusNotify condition (because some bits don't cause a naked notify)14-Oct-87 -- AOF -- Hummmmmm16-Oct-87 -- BKI -- Init{zone creation} -> On.21-Oct-87 -- BKI -- Comment-out DebuggerSwap.  No one uses this information. 9-Nov-87 -- BKI -- Added DeallocateNakedCondition to LocalOff.11-Jan-88 -- BKI -- Fixed ARs 12511 and 12575.
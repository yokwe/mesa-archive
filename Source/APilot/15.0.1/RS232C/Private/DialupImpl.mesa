-- File: DialupImpl.mesa - last edit:-- BKI                 12-Apr-88 12:07:19-- JAV                  9-Jul-87 17:05:32-- Copyright (C) 1978, 1979, 1980, 1981, 1982, 1983, 1984, 1985, 1986, 1987, 1988 by Xerox Corporation. All rights reserved. DIRECTORY  Ascii USING [CR, LF],  Dialup USING [DialerType, Outcome, Number, pause, RetryCount],  DialupExtras USING [DialerType],  Environment USING [Block, Byte],  Heap USING [Create, CreateUniform, Delete],  Inline USING [BITAND],  Process USING [Abort, Detach, EnableAborts, GetCurrent, MsecToTicks, Pause, SetTimeout],  RS232C USING [ChannelHandle, ChannelSuspended, CompletionHandle, DeviceStatus, Get, GetStatus, LineType, OperationClass, PhysicalRecordHandle, Put, Restart, SetLineType, SetParameter, StatusWait, Suspend, TransferStatus, TransferWait, TransmitNow, UnimplementedFeature],  RS232CEnvironment USING [CompletionHandle, PhysicalRecord],  RS232CFace USING [ParameterRecord],  RS232CPrivate USING [FindChannel, GetParameters, SetParameters],  RS366Face USING [GetDialerCount, GetStatus, SetStatus, GetStatusBits, SetStatusBits],  String USING [AppendChar, Equivalent];DialupImpl: MONITOR IMPORTS Heap, Inline, Process, RS232C, RS232CPrivate, RS366Face, StringEXPORTS Dialup, DialupExtras =  BEGIN  -- various definitions  timer, oneTick: CONDITION;  abortRequested: PACKED ARRAY [0..15] OF BOOLEAN ¬ ALL[FALSE];  -- procedures (listed alphabetically)    zone: UNCOUNTED ZONE ¬ Heap.Create[1];    CommandResponce: TYPE = {ok, connect, connect600, connect1200, connect2400, noCarrier, busy, error, noDialtone, noAnswer, deadPhone, abort, formatError, timeout};    CompletionHandleChain: TYPE = RECORD [    completionHandle: RS232C.CompletionHandle,    block: Environment.Block ¬ [NIL, 0, 0],    rec: RS232CEnvironment.PhysicalRecord ¬ [[NIL, 0, 0], [NIL, 0, 0], [NIL, 0, 0]],    next: LONG POINTER TO CompletionHandleChain    ];      Block: TYPE = PACKED ARRAY INTEGER[0..20) OF Environment.Byte;  AbortCall: PUBLIC ENTRY PROCEDURE [dialerNumber: CARDINAL] =    BEGIN abortRequested[dialerNumber] ¬ TRUE; END;      DialExtra: PUBLIC PROCEDURE [dialerNumber: CARDINAL, number: LONG POINTER TO Dialup.Number,  retries: Dialup.RetryCount, dialerType: DialupExtras.DialerType] RETURNS [Dialup.Outcome] =    BEGIN      BEGIN ENABLE UNWIND => NULL;            SELECT dialerType FROM        RS366 => RETURN[DialRS366[dialerNumber, number, retries, dialerType]];	smartmodem => RETURN[DialHayes[dialerNumber, number, retries, dialerType]];	Ventel => RETURN[DialVentel[dialerNumber, number, retries, dialerType]];	RacalVadic => RETURN[DialRacalVadic[dialerNumber, number, retries, dialerType]];	V25bis => RETURN[DialV25bis[dialerNumber, number, retries, dialerType]];      ENDCASE => RETURN[failure];      END;    END;    Dial: PUBLIC PROCEDURE [    dialerNumber: CARDINAL, number: LONG POINTER TO Dialup.Number,    retries: Dialup.RetryCount, dialerType: Dialup.DialerType ¬ RS366]    RETURNS [outcome: Dialup.Outcome] =    BEGIN      BEGIN ENABLE UNWIND => NULL;            SELECT dialerType FROM        RS366 => 	  RETURN[DialRS366[dialerNumber, number, retries, LOOPHOLE[dialerType]]];	smartmodem => 	  RETURN[DialHayes[dialerNumber, number, retries, LOOPHOLE[dialerType]]];	Ventel => 	  RETURN[DialVentel[dialerNumber, number, retries, LOOPHOLE[dialerType]]];      ENDCASE => RETURN[failure];      END;    END;  DialRS366: ENTRY PROCEDURE [    dialerNumber: CARDINAL, number: LONG POINTER TO Dialup.Number,    retries: Dialup.RetryCount, dialerType: DialupExtras.DialerType ¬ RS366]    RETURNS [outcome: Dialup.Outcome] =    BEGIN      BEGIN ENABLE UNWIND => NULL;    WaitFor: INTERNAL PROC[milliseconds: CARDINAL] = INLINE      BEGIN      Process.SetTimeout[@timer, Process.MsecToTicks[milliseconds]];      WAIT timer;  --then wait for clock to interrupt      END;  --WaitFor    numIndex: CARDINAL;  -- the index into the phone number.    setStatusBits: RS366Face.SetStatusBits;    getStatusBits: RS366Face.GetStatusBits;    abortRequested[dialerNumber] ¬ FALSE;    -- Validate parameters --    IF RS366Face.GetDialerCount[] <= dialerNumber THEN RETURN[dialerNotPresent];    IF number.n > 31 THEN RETURN[formatError];    -- Make certain that the dialer has power --    IF ~RS366Face.GetStatus[dialerNumber].powerIndication THEN      RETURN[dialerNotPresent];    BEGIN    THROUGH [0..retries] DO      -- Dial the phone number retries-1 times      setStatusBits ¬ ResetDialer[dialerNumber];      IF (RS366Face.GetStatus[dialerNumber]).dataLineOccupied THEN        RETURN[dataLineOccupied];      setStatusBits.callRequest ¬ TRUE;      RS366Face.SetStatus[dialerNumber, setStatusBits];      BEGIN      FOR numIndex IN [0..number.n) DO        THROUGH [0..200) DO          -- 10 second timeout          getStatusBits ¬ RS366Face.GetStatus[dialerNumber];          IF getStatusBits.presentNextDigit THEN EXIT;          IF getStatusBits.abandonCallAndRetry THEN GO TO retry;          IF abortRequested[dialerNumber] THEN GO TO abortDialing;          WAIT oneTick;          REPEAT FINISHED => GOTO dialingTimeout;          ENDLOOP;	  	-- Now set the digit.  (or execute software pause)	IF number[numIndex] = Dialup.pause THEN {WaitFor[6000]; LOOP};        setStatusBits.digit ¬ number[numIndex];	          RS366Face.SetStatus[dialerNumber, setStatusBits];        setStatusBits.digitPresent ¬ TRUE;        RS366Face.SetStatus[dialerNumber, setStatusBits];        THROUGH [0..200) DO          -- 10 second timeout          getStatusBits ¬ RS366Face.GetStatus[dialerNumber];          IF ~getStatusBits.presentNextDigit THEN EXIT;          IF getStatusBits.abandonCallAndRetry THEN GO TO retry;          IF abortRequested[dialerNumber] THEN GO TO abortDialing;          WAIT oneTick;          REPEAT FINISHED => GOTO dialingTimeout;          ENDLOOP;        setStatusBits.digitPresent ¬ FALSE;        RS366Face.SetStatus[dialerNumber, setStatusBits];        ENDLOOP;  -- go on to next digit      -- Wait until dialer has transferred control of communication line to the data set.      THROUGH [0..2000) DO        --100 second timeout        getStatusBits ¬ RS366Face.GetStatus[dialerNumber];        IF getStatusBits.callOriginationStatus THEN EXIT;        IF getStatusBits.abandonCallAndRetry THEN GO TO retry;        IF abortRequested[dialerNumber] THEN GOTO abortDialing;        WAIT oneTick;        REPEAT FINISHED => GOTO transferTimeout;        ENDLOOP;      -- Modem now in control...idle dialer --      setStatusBits ¬ [FALSE, FALSE, 0];      RS366Face.SetStatus[dialerNumber, setStatusBits];      RETURN[success];      EXITS retry => NULL;      END;      ENDLOOP;    outcome ¬ failure;    EXITS      abortDialing => outcome ¬ aborted;      dialingTimeout => outcome ¬ dialingTimeout;      transferTimeout => outcome ¬ transferTimeout;    END;    [] ¬ ResetDialer[dialerNumber];    RETURN;    END;  END;  GetDialerCount: PUBLIC PROCEDURE RETURNS [numberOfDialers: CARDINAL] =    BEGIN RETURN[RS366Face.GetDialerCount[]]; END;  ResetDialer: PRIVATE INTERNAL PROCEDURE [dialerNumber: CARDINAL]    RETURNS [setStatusBits: RS366Face.SetStatusBits] =    BEGIN  -- Resets setStatusBits and hangs up phone --    setStatusBits ¬ [callRequest: FALSE, digitPresent: FALSE, digit: 0];    RS366Face.SetStatus[dialerNumber, setStatusBits];    THROUGH [0..200) DO      -- 10 second timeout for phone to be hung up --      IF ~(RS366Face.GetStatus[dialerNumber]).dataLineOccupied THEN RETURN;      WAIT oneTick;      ENDLOOP;    END;          WaitFor: ENTRY PROCEDURE [milliseconds: CARDINAL] =    BEGIN      BEGIN ENABLE UNWIND => NULL;	Process.SetTimeout[@timer, Process.MsecToTicks[milliseconds]];	WAIT timer;      END;    END;      DialHayes:  PROCEDURE [    dialerNumber: CARDINAL, number: LONG POINTER TO Dialup.Number,    retries: Dialup.RetryCount, dialerType: DialupExtras.DialerType ¬ smartmodem]    RETURNS [outcome: Dialup.Outcome] =    BEGIN ENABLE {      UNWIND => NULL;      RS232C.UnimplementedFeature => GOTO error};      status: CommandResponce ¬ ok;      handle: RS232C.ChannelHandle ¬ RS232CPrivate.FindChannel[dialerNumber];      deviceStatus: RS232C.DeviceStatus;      parameterRecord: RS232CFace.ParameterRecord;      IF handle = LOOPHOLE[LONG[NIL]] THEN RETURN[failure];      Process.Pause[Process.MsecToTicks[500]];      parameterRecord ¬ RS232CPrivate.GetParameters[handle];      deviceStatus ¬ RS232C.GetStatus[handle];      IF ~deviceStatus.clearToSend THEN RETURN[dialerNotPresent];      RS232C.SetLineType[handle, asynchronous];      RS232C.SetParameter[handle, [frameTimeout[parameterRecord.frameTimeout]]];      RS232C.SetParameter[handle, [dataTerminalReady[FALSE]]];	-- reset line diconnect modem                        RS232C.SetParameter[handle, [charLength[parameterRecord.charLength]]];      RS232C.SetParameter[handle, [clockSource[parameterRecord.clockSource]]];      RS232C.SetParameter[handle, [correspondent[parameterRecord.correspondent]]];      RS232C.SetParameter[handle, [encodeData[parameterRecord.encodeData]]];      RS232C.SetParameter[handle, [lineSpeed[        IF parameterRecord.lineType = bitSynchronous THEN bps2400 ELSE parameterRecord.lineSpeed]]];      RS232C.SetParameter[handle, [maxAsyncTimeout[parameterRecord.maxAsyncTimeout]]];      RS232C.SetParameter[handle, [parity[parameterRecord.parity]]];      RS232C.SetParameter[handle, [requestToSend[parameterRecord.requestToSend]]];      RS232C.SetParameter[handle, [stopBits[parameterRecord.stopBits]]];      Process.Pause[Process.MsecToTicks[1500]];      RS232C.SetParameter[handle, [dataTerminalReady[TRUE]]];      Process.Pause[Process.MsecToTicks[1500]];      InitializeCleanup[];      BEGIN      ENABLE UNWIND => DoCleanup[handle];      IF parameterRecord.lineType = bitSynchronous THEN {        status ¬ SetModemUpForSync[handle];	IF status # ok THEN {DoCleanup[handle]; RETURN[failure]}};      THROUGH [0..retries] DO	status ¬ ResetHayesDialer[handle];	IF status = error OR status = timeout THEN LOOP;	status ¬ DialNumber[handle, number];	SELECT status FROM	  connect, connect600, connect1200, connect2400, ok => {outcome ¬ success; EXIT};	  noCarrier, error, noDialtone, noAnswer => outcome ¬ failure;	  timeout => outcome ¬ dialingTimeout;	  busy => outcome ¬ dataLineOccupied;	ENDCASE;      ENDLOOP;      parameterRecord.dataTerminalReady ¬ TRUE;      RS232CPrivate.SetParameters[handle, parameterRecord];      DoCleanup[handle];      END; --ENABLE UNWIND    EXITS      error => RETURN[failure];    END;      GetResponce: PROCEDURE [handle: RS232C.ChannelHandle, completionHandle: RS232C.CompletionHandle, rec: RS232CEnvironment.PhysicalRecord]     RETURNS [commandResponce: CommandResponce ¬ ok] =   BEGIN  CRSeen, CRLFSeen, commandSeen:  BOOLEAN ¬ FALSE;  commandString: LONG STRING ¬ [40];  byteCount: CARDINAL ¬ 0;  status: RS232C.TransferStatus ¬ success;  timeouts: CARDINAL ¬ 0;  transferFinished: BOOLEAN ¬ FALSE;  transferProcess: PROCESS ¬ NIL;  getHandleHead, getHandleTail: LONG POINTER TO CompletionHandleChain ¬ NIL;  BEGIN ENABLE UNWIND => IF transferProcess # NIL THEN {Process.Abort[transferProcess]; JOIN transferProcess};      CreateCompletionHandle: PROCEDURE [doGet: BOOLEAN ¬ TRUE, completionHandle: RS232C.CompletionHandle] =    BEGIN    p: LONG POINTER TO CompletionHandleChain;    p ¬ zone.NEW[CompletionHandleChain];    p.next ¬ NIL;    IF doGet THEN {      p.block.blockPointer ¬ LOOPHOLE[zone.NEW[Block]];      p.block.startIndex ¬ 0;      p.block.stopIndexPlusOne ¬ 20;      p.rec.body ¬ p.block;      p.completionHandle ¬ Get[handle, @p.rec]}    ELSE {      p.rec ¬ rec;      p.completionHandle ¬ completionHandle};    IF getHandleHead = NIL THEN         getHandleHead ¬ getHandleTail ¬ p    ELSE {        getHandleTail.next ¬ p;	getHandleTail ¬ p};    END;        FreeCompletionHandle: PROCEDURE =    BEGIN    tempHandle: LONG POINTER TO CompletionHandleChain ¬ getHandleHead;      getHandleHead ¬ getHandleHead.next;      zone.FREE[@tempHandle.block.blockPointer];      zone.FREE[@tempHandle];    END;            TransferWaitInternal: PROCEDURE =    BEGIN ENABLE ABORTED => CONTINUE;      CreateCompletionHandle[TRUE, ];      [byteCount, status] ¬ TransferWait[handle, getHandleHead.completionHandle];      transferFinished ¬ TRUE;    END;        CreateCompletionHandle[FALSE, completionHandle];    DO      transferProcess ¬ FORK TransferWaitInternal[];      UNTIL transferFinished DO        WaitFor[125]; 				-- 1/8 of a second	timeouts ¬ timeouts + 1;	IF timeouts > (60 * 8 + 1) THEN {	-- modem waits for carrier for 60 secs.	  Process.Abort[transferProcess];	  JOIN transferProcess;	  transferProcess ¬ NIL;	  RETURN[timeout]};      ENDLOOP;      Process.Abort[transferProcess];      JOIN transferProcess;      transferProcess ¬ NIL;      transferFinished ¬ FALSE;      SELECT status FROM        success => timeouts ¬ 0;	checksumError, parityError, asynchFramingError => NULL;			-- to take care of invalid characters on connect	frameTimeout => NULL;	-- for synch case      ENDCASE => RETURN[error];      FOR i: CARDINAL IN [0..byteCount) DO	SELECT LOOPHOLE[Inline.BITAND[getHandleHead.rec.body.blockPointer[i], 177B], CHARACTER] FROM	  Ascii.CR => IF commandSeen THEN EXIT ELSE CRSeen ¬ TRUE;	  Ascii.LF => IF CRSeen THEN IF commandSeen THEN EXIT ELSE CRLFSeen ¬ TRUE; 	ENDCASE => 	  IF CRLFSeen OR commandSeen THEN {	    String.AppendChar[commandString, LOOPHOLE[Inline.BITAND[getHandleHead.rec.body.blockPointer[i], 177B]]];	    CRSeen ¬ CRLFSeen ¬ FALSE;	    commandSeen ¬ TRUE};      ENDLOOP;      IF commandSeen THEN {FreeCompletionHandle[]; EXIT};      CreateCompletionHandle[TRUE, ];      FreeCompletionHandle[];      byteCount ¬ 0;    ENDLOOP;    Process.Detach[FORK RS232C.Suspend[handle, input]];    WHILE getHandleHead # NIL DO      [byteCount, status] ¬ TransferWait[handle, getHandleHead.completionHandle ! RS232C.ChannelSuspended => CONTINUE];      FreeCompletionHandle[];    ENDLOOP;    RS232C.Restart[handle, input];    SELECT TRUE FROM      String.Equivalent[commandString, "OK"L] => RETURN[ok];      String.Equivalent[commandString, "CONNECT"L] => RETURN[connect];      String.Equivalent[commandString, "NO CARRIER"L] => RETURN[noCarrier];      String.Equivalent[commandString, "CONNECT 0600"L] => RETURN[connect600];      String.Equivalent[commandString, "CONNECT 1200"L] => RETURN[connect1200];      String.Equivalent[commandString, "CONNECT 2400"L] => RETURN[connect2400];      String.Equivalent[commandString, "BUSY"L] => RETURN[busy];      String.Equivalent[commandString, "ERROR"L] => RETURN[error];      String.Equivalent[commandString, "NO DIALTONE"L] => RETURN[noDialtone];      String.Equivalent[commandString, "NO ANSWER"L] => RETURN[noAnswer];      String.Equivalent[commandString, "0"L] => RETURN[ok];      String.Equivalent[commandString, "1"L] => RETURN[connect];      String.Equivalent[commandString, "3"L] => RETURN[noCarrier];      String.Equivalent[commandString, "4"L] => RETURN[error];      String.Equivalent[commandString, "5"L] => RETURN[connect1200];      String.Equivalent[commandString, "6"L] => RETURN[noDialtone];      String.Equivalent[commandString, "7"L] => RETURN[busy];      String.Equivalent[commandString, "8"L] => RETURN[noAnswer];      String.Equivalent[commandString, "9"L] => RETURN[connect600];      String.Equivalent[commandString, "10"L] => RETURN[connect2400];    ENDCASE => RETURN[error];    END;  -- ABORTED  END;    SetModemUpForSync: PROCEDURE [handle: RS232C.ChannelHandle] RETURNS [status: CommandResponce ¬ ok] =    BEGIN      syncCommand: PACKED ARRAY INTEGER[0..6) OF Environment.Byte ¬ [101B, 124B, 046B, 115B, 061B, 015B];	-- "AT&M1\n"  sync hayes mode 1      rec: RS232CEnvironment.PhysicalRecord ¬ [header: [NIL, 0, 0], body: [@syncCommand, 0, 6], trailer: [NIL, 0, 0]];      words: PACKED ARRAY INTEGER[0..20) OF Environment.Byte ¬ ALL[0];      getRec: RS232CEnvironment.PhysicalRecord ¬ [header: [NIL, 0, 0], body: [@words, 0, 20], trailer: [NIL, 0, 0]];      getCompletionHandle, completionHandle: RS232C.CompletionHandle;      transferStatus: RS232C.TransferStatus;      responce: CommandResponce ¬ ok;      getCompletionHandle ¬ Get[handle, @getRec];	-- issue get for responce      completionHandle ¬ Put[handle, @rec];      [ , transferStatus] ¬ TransmitNow[handle, completionHandle];      responce ¬ GetResponce[handle, getCompletionHandle, getRec];      SELECT responce FROM	ok => RETURN[ok];	error => RETURN[error];      ENDCASE => RETURN[error];    END;    ResetHayesDialer: PROCEDURE [handle: RS232C.ChannelHandle] RETURNS [status: CommandResponce ¬ ok] =    BEGIN      resetCommand: PACKED ARRAY INTEGER[0..5) OF Environment.Byte ¬ [101B, 124B, 121B, 132B, 015B];	-- "ATQZ\n"      factoryReset: PACKED ARRAY INTEGER[0..5) OF Environment.Byte ¬ [101B, 124B, 046B, 106B, 015B];	-- "AT&F\n"      dtrCommond: PACKED ARRAY INTEGER[0..9) OF Environment.Byte ¬ [101B, 124B, 046B, 104B, 50, 046B, 103B, 061B, 015B];	-- "AT&D2&C1\n" sets up DTR on-off transition      getCompletionHandle, completionHandle: RS232C.CompletionHandle;      transferStatus: RS232C.TransferStatus;      rec: RS232CEnvironment.PhysicalRecord ¬ [header: [NIL, 0, 0], body: [@resetCommand, 0, 5], trailer: [NIL, 0, 0]];      words: PACKED ARRAY INTEGER[0..20) OF Environment.Byte ¬ ALL[0];      getRec: RS232CEnvironment.PhysicalRecord ¬ [header: [NIL, 0, 0], body: [@words, 0, 20], trailer: [NIL, 0, 0]];      responce: CommandResponce ¬ ok;	getCompletionHandle ¬ Get[handle, @getRec];	-- issue get for responce	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	responce ¬ GetResponce[handle, getCompletionHandle, getRec];	SELECT responce FROM	  error => RETURN[error];	  timeout => RETURN[timeout];	ENDCASE;	rec.body ¬ [@factoryReset, 0, 5];	getCompletionHandle ¬ Get[handle, @getRec];	-- issue get for responce	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	responce ¬ GetResponce[handle, getCompletionHandle, getRec];	rec.body ¬ [@dtrCommond, 0, 9];	getCompletionHandle ¬ Get[handle, @getRec];	-- issue get for responce	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	responce ¬ GetResponce[handle, getCompletionHandle, getRec];	IF status # ok THEN RETURN[error];	RETURN[ok];    END;      DialNumber: PROCEDURE [handle: RS232C.ChannelHandle, number: LONG POINTER TO Dialup.Number] RETURNS [status: CommandResponce ¬ ok] =     BEGIN      setEscapeCodeCommand: PACKED ARRAY INTEGER[0..9) OF Environment.Byte ¬ [101B, 124B, 123B, 62B, 75B, 62B, 65B, 65B, 015B];	-- "ATS2=255" set escape code to 255      dialCommand: PACKED ARRAY INTEGER[0..3) OF Environment.Byte ¬ [101B, 124B, 104B];	-- "ATD"      crlf: PACKED ARRAY INTEGER[0..2) OF Environment.Byte ¬ [015B, 012B];		-- "CRLF"      char: PACKED ARRAY INTEGER[0..1) OF Environment.Byte ¬ ALL[0];      rec: RS232CEnvironment.PhysicalRecord ¬ [header: [NIL, 0, 0], body: [@setEscapeCodeCommand, 0, 9], trailer: [NIL, 0, 0]];      getCompletionHandle, completionHandle: RS232C.CompletionHandle;      transferStatus: RS232C.TransferStatus;      words: PACKED ARRAY INTEGER[0..20) OF Environment.Byte ¬ ALL[0];      getRec: RS232CEnvironment.PhysicalRecord ¬ [header: [NIL, 0, 0], body: [@words, 0, 20], trailer: [NIL, 0, 0]];              getCompletionHandle ¬ Get[handle, @getRec];	-- issue get for responce	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	SELECT transferStatus FROM	  success => NULL;	ENDCASE => RETURN[error];	status ¬ GetResponce[handle, getCompletionHandle, getRec];	IF status ~IN[ok..connect2400] THEN RETURN;	rec.body ¬ [@dialCommand, 0, 3];        getCompletionHandle ¬ Get[handle, @getRec];	-- issue get for responce	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	rec.body ¬ [LOOPHOLE[number + SIZE[Dialup.Number[0]]], 0, number.n];	-- add one to skip sequence length	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	rec.body ¬ [@crlf, 0, 2];	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	SELECT transferStatus FROM	  success => NULL;	ENDCASE => RETURN[error];	status ¬ GetResponce[handle, getCompletionHandle, getRec];    END;    DialVentel: PROCEDURE [    dialerNumber: CARDINAL, number: LONG POINTER TO Dialup.Number,    retries: Dialup.RetryCount, dialerType: DialupExtras.DialerType ¬ Ventel]    RETURNS [outcome: Dialup.Outcome] =    BEGIN    handle: RS232C.ChannelHandle ¬ RS232CPrivate.FindChannel[dialerNumber];    deviceStatus: RS232C.DeviceStatus;    ventel: PACKED ARRAY INTEGER[0..6) OF Environment.Byte ¬ [126B, 105B, 116B, 124B, 105B, 114B];    ventelSyn: PACKED ARRAY INTEGER[0..2) OF Environment.Byte ¬ [015B, 015B];	-- "CR"    dialingSeqStart: PACKED ARRAY INTEGER[0..2) OF Environment.Byte ¬ [113B, 113B]; -- "K"    dialingSeqEnd: PACKED ARRAY INTEGER[0..2) OF Environment.Byte ¬ [015B, 015B];	-- "CR"    char: PACKED ARRAY INTEGER[0..1) OF Environment.Byte ¬ ALL[0];    rec: RS232CEnvironment.PhysicalRecord ¬ [header: [NIL, 0, 0], body: [@ventelSyn, 0, 1], trailer: [NIL, 0, 0]];    getCompletionHandle, completionHandle: RS232C.CompletionHandle;    transferStatus: RS232C.TransferStatus;    words: PACKED ARRAY INTEGER[0..60) OF Environment.Byte ¬ ALL[0];    getRec: RS232CEnvironment.PhysicalRecord ¬ [header: [NIL, 0, 0], body: [@words, 0, 60], trailer: [NIL, 0, 0]];    status: CommandResponce ¬ ok;    seconds: CARDINAL ¬ 0;    watcher: PROCESS ¬ NIL;    BEGIN ENABLE UNWIND =>      IF watcher # NIL THEN {Process.Abort[watcher]; JOIN watcher};      Watcher: ENTRY PROCEDURE [process: PROCESS, secondsToWait: CARDINAL] =      BEGIN	BEGIN ENABLE ABORTED => GOTO Return;	timer: CONDITION;	  Process.EnableAborts[@timer];	  Process.SetTimeout[@timer, Process.MsecToTicks[1000]];	  WHILE seconds < secondsToWait DO	    WAIT timer;	    seconds ¬ seconds + 1;	  ENDLOOP;	  RS232C.Suspend[handle, input];	  RS232C.Restart[handle, input];	END;      EXITS        Return => RETURN;      END;          IF handle = LOOPHOLE[LONG[NIL]] THEN RETURN[failure];      Process.Pause[Process.MsecToTicks[500]];      deviceStatus ¬ RS232C.GetStatus[handle];      IF ~deviceStatus.clearToSend THEN RETURN[dialerNotPresent];      RS232C.SetParameter[handle, [frameTimeout[30]]];      InitializeCleanup[];      BEGIN      ENABLE UNWIND => DoCleanup[handle];      THROUGH [0..retries] DO        rec.body ¬ [@ventelSyn, 0, 1];	RS232C.SetParameter[handle, [dataTerminalReady[FALSE]]];	-- reset line diconnect modem	Process.Pause[Process.MsecToTicks[1500]];	RS232C.SetParameter[handle, [dataTerminalReady[TRUE]]];	getCompletionHandle ¬ Get[handle, @getRec];	-- issue get for responce	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	Process.Pause[Process.MsecToTicks[500]];	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	SELECT transferStatus FROM	  success, parityError => NULL;	ENDCASE => {outcome ¬ failure; EXIT};	Process.Pause[Process.MsecToTicks[3000]];		-- wait 3 seconds to let modem reset	rec.body ¬ [@char, 0, 1];	FOR i:CARDINAL IN [0..6) DO	  rec.body.blockPointer[0] ¬ ventel[i];	  completionHandle ¬ Put[handle, @rec];	  [ , transferStatus] ¬ TransmitNow[handle, completionHandle];	  Process.Pause[Process.MsecToTicks[100]];	ENDLOOP;	Process.Pause[Process.MsecToTicks[1000]];	rec.body ¬ [@dialingSeqStart, 0, 1];	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	Process.Pause[Process.MsecToTicks[200]];		-- allow modem to process commands	FOR i:CARDINAL IN [0..number.n) DO	  rec.body ¬ [LOOPHOLE[number + SIZE[Dialup.Number[0]]], i, i+1];	  completionHandle ¬ Put[handle, @rec];	  [ , transferStatus] ¬ TransmitNow[handle, completionHandle];	  Process.Pause[Process.MsecToTicks[60]];	  ENDLOOP;	rec.body ¬ [@dialingSeqEnd, 0, 1];	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	SELECT transferStatus FROM	  success, parityError => NULL;	ENDCASE => {outcome ¬ failure; EXIT};	Process.Pause[Process.MsecToTicks[50]];	watcher ¬ FORK Watcher[Process.GetCurrent[], 3];	[ , transferStatus] ¬ TransferWait[handle, getCompletionHandle];	Process.Abort[watcher];	JOIN watcher;	watcher ¬ NIL;	seconds ¬ 0;	SELECT transferStatus FROM	  success, parityError, dataLost => NULL;	  aborted => {outcome ¬ dialingTimeout; EXIT};	ENDCASE => {outcome ¬ failure; EXIT};	getCompletionHandle ¬ Get[handle, @getRec];	-- issue get for responce	watcher ¬ FORK Watcher[Process.GetCurrent[], 45];     	status ¬ GetVentelDialerResponce[handle, getCompletionHandle, getRec];	Process.Abort[watcher];	JOIN watcher;	watcher ¬ NIL;	seconds ¬ 0;	SELECT status FROM	  IN[ok..connect2400] => outcome ¬ success;	  deadPhone => outcome ¬ dialerNotPresent;	  busy, noAnswer => outcome ¬ failure;	  timeout => outcome ¬ dialingTimeout;	ENDCASE => LOOP;	EXIT;      REPEAT FINISHED => outcome ¬ failure;       ENDLOOP;      DoCleanup[handle];      END; --ENABLE UNWIND    END;  END;      GetVentelDialerResponce: PROCEDURE     [handle: RS232C.ChannelHandle, completionHandle: RS232C.CompletionHandle, rec: RS232CEnvironment.PhysicalRecord]     RETURNS [commandResponce: CommandResponce ¬ ok] =   BEGIN  commandString: LONG STRING ¬ [256];  end: BOOLEAN ¬ FALSE;  byteCount: CARDINAL ¬ 0;  status: RS232C.TransferStatus ¬ success;  getHandleHead, getHandleTail: LONG POINTER TO CompletionHandleChain ¬ NIL;      CreateCompletionHandle: PROCEDURE [doGet: BOOLEAN ¬ TRUE, completionHandle: RS232C.CompletionHandle] =    BEGIN    p: LONG POINTER TO CompletionHandleChain;    p ¬ zone.NEW[CompletionHandleChain];    p.next ¬ NIL;    IF doGet THEN {      p.block.blockPointer ¬ LOOPHOLE[zone.NEW[Block]];      p.block.startIndex ¬ 0;      p.block.stopIndexPlusOne ¬ 20;      p.rec.body ¬ p.block;      p.completionHandle ¬ Get[handle, @p.rec]}    ELSE {      p.rec ¬ rec;      p.completionHandle ¬ completionHandle};    IF getHandleHead = NIL THEN         getHandleHead ¬ getHandleTail ¬ p    ELSE {        getHandleTail.next ¬ p;	getHandleTail ¬ p};    END;        FreeCompletionHandle: PROCEDURE =    BEGIN    tempHandle: LONG POINTER TO CompletionHandleChain ¬ getHandleHead;      getHandleHead ¬ getHandleHead.next;      zone.FREE[@tempHandle.block.blockPointer];      zone.FREE[@tempHandle];    END;      Index: PROCEDURE [s, t: LONG STRING ¬ NIL, startingAt: CARDINAL ¬ 0]     RETURNS[starts:INTEGER ¬ -1] = {       j,k: CARDINAL;       IF s=NIL OR t=NIL OR s.length=0 OR t.length=0 THEN RETURN[-1];       IF (startingAt > s.length - 1) THEN RETURN[-1];       FOR base: CARDINAL IN [startingAt..(s.length-1)) DO        j ¬ base; k ¬ 0;	WHILE (s[j] = t[k]) DO	  IF (k=(t.length-1)) THEN RETURN[base];	  IF (j=(s.length-1)) THEN EXIT;	  j¬j+1;	  k¬k+1;        ENDLOOP;       ENDLOOP;};        -- Index         CreateCompletionHandle[FALSE, completionHandle];    DO      WHILE ~end DO      CreateCompletionHandle[TRUE, ];      [byteCount, status] ¬ TransferWait[handle, getHandleHead.completionHandle];      SELECT status FROM	success => NULL;	checksumError, parityError, asynchFramingError, dataLost => NULL;			-- to take care of invalid characters on connect	aborted => {commandResponce ¬ timeout; GOTO error};      ENDCASE => {commandResponce ¬ error; GOTO error};      FOR i: CARDINAL IN [getHandleHead.rec.body.startIndex..getHandleHead.rec.body.startIndex+byteCount) DO	SELECT LOOPHOLE[Inline.BITAND[getHandleHead.rec.body.blockPointer[i], 177B], INTEGER] FROM	  44B, 41B => end ¬ TRUE;	ENDCASE;	String.AppendChar[commandString, LOOPHOLE[Inline.BITAND[getHandleHead.rec.body.blockPointer[i], 177B]]];      ENDLOOP;      FreeCompletionHandle[];    ENDLOOP;    IF Index[commandString, "ONLINE"L] > -1 THEN {commandResponce ¬ connect; EXIT};    IF Index[commandString, "DEAD PHONE"L] > -1 THEN {commandResponce ¬ deadPhone; EXIT};    IF Index[commandString, "BUSY"L] > -1 THEN {commandResponce ¬ busy; EXIT};    IF Index[commandString, "NO ANSWER"L] > -1 THEN {commandResponce ¬ noAnswer; EXIT};    end ¬ FALSE;    commandString.length ¬ 0;    commandResponce ¬ error;  REPEAT    error => FreeCompletionHandle[];  ENDLOOP;  Process.Detach[FORK RS232C.Suspend[handle, input]];  WHILE getHandleHead # NIL DO    [byteCount, status] ¬ TransferWait[handle, getHandleHead.completionHandle ! RS232C.ChannelSuspended => CONTINUE];    FreeCompletionHandle[];  ENDLOOP;  RS232C.Restart[handle, input];  END;        DialRacalVadic: PROCEDURE [    dialerNumber: CARDINAL, number: LONG POINTER TO Dialup.Number,    retries: Dialup.RetryCount, dialerType: DialupExtras.DialerType ¬ RacalVadic]    RETURNS [outcome: Dialup.Outcome] =    BEGIN    handle: RS232C.ChannelHandle ¬ RS232CPrivate.FindChannel[dialerNumber];    deviceStatus: RS232C.DeviceStatus;    dialingSeqStart: PACKED ARRAY INTEGER[0..2) OF Environment.Byte ¬ [02B, 02B]; -- "­B"    dialingSeqEnd: PACKED ARRAY INTEGER[0..2) OF Environment.Byte ¬ [017B, 03B];	-- "­O, ­C"    rec: RS232CEnvironment.PhysicalRecord ¬ [header: [NIL, 0, 0], body: [@dialingSeqStart, 0, 1], trailer: [NIL, 0, 0]];    getCompletionHandle, completionHandle: RS232C.CompletionHandle;    transferStatus: RS232C.TransferStatus;    words: PACKED ARRAY INTEGER[0..5) OF Environment.Byte ¬ ALL[0];    getRec: RS232CEnvironment.PhysicalRecord ¬ [header: [NIL, 0, 0], body: [@words, 0, 5], trailer: [NIL, 0, 0]];    status: CommandResponce ¬ ok;    seconds: CARDINAL ¬ 0;    watcher: PROCESS ¬ NIL;    BEGIN ENABLE UNWIND =>      IF watcher # NIL THEN {Process.Abort[watcher]; JOIN watcher};            Watcher: ENTRY PROCEDURE [process: PROCESS] =      BEGIN	BEGIN ENABLE ABORTED => GOTO Return;	timer: CONDITION;	  Process.EnableAborts[@timer];	  Process.SetTimeout[@timer, Process.MsecToTicks[1000]];	  WHILE seconds < 46 DO	    WAIT timer;	    seconds ¬ seconds + 1;	  ENDLOOP;	  RS232C.Suspend[handle, input];	  RS232C.Restart[handle, input];	END;      EXITS        Return => RETURN;      END;          IF handle = LOOPHOLE[LONG[NIL]] THEN RETURN[failure];      RS232C.SetParameter[handle, [requestToSend[TRUE]]];      Process.Pause[Process.MsecToTicks[500]];      deviceStatus ¬ RS232C.GetStatus[handle];      IF ~deviceStatus.clearToSend THEN RETURN[dialerNotPresent];      RS232C.SetParameter[handle, [frameTimeout[30]]];      InitializeCleanup[];      BEGIN      ENABLE UNWIND => DoCleanup[handle];      THROUGH [0..retries] DO	RS232C.SetParameter[handle, [dataTerminalReady[FALSE]]];	-- reset line diconnect modem	Process.Pause[Process.MsecToTicks[50]];	RS232C.SetParameter[handle, [dataTerminalReady[TRUE]]];	getCompletionHandle ¬ Get[handle, @getRec];	-- issue get for responce	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	SELECT transferStatus FROM	  success => NULL;	ENDCASE => {outcome ¬ failure; EXIT};	rec.body ¬ [LOOPHOLE[number + SIZE[Dialup.Number[0]]], 0, number.n];	-- add one to skip sequence length	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	rec.body ¬ [@dialingSeqEnd, 0, 2];	completionHandle ¬ Put[handle, @rec];	[ , transferStatus] ¬ TransmitNow[handle, completionHandle];	SELECT transferStatus FROM	  success => NULL;	ENDCASE => {outcome ¬ failure; EXIT};	watcher ¬ FORK Watcher[Process.GetCurrent[]];	status ¬ GetRacalVadicDialerResponce[handle, getCompletionHandle, getRec];	Process.Abort[watcher];	JOIN watcher;	watcher ¬ NIL;	seconds ¬ 0;	rec.body ¬ [@dialingSeqStart, 0, 1];	SELECT status FROM	  IN[ok..connect2400] => {outcome ¬ success; EXIT};	  busy => {outcome ¬ dataLineOccupied; LOOP};	  abort => {outcome ¬ aborted; LOOP};	  formatError => {outcome ¬ formatError; LOOP};	ENDCASE => {outcome ¬ failure; LOOP};      ENDLOOP;      DoCleanup[handle];      END; --ENABLE UNWIND    END;  END;  GetRacalVadicDialerResponce: PROCEDURE     [handle: RS232C.ChannelHandle, completionHandle: RS232C.CompletionHandle, rec: RS232CEnvironment.PhysicalRecord]     RETURNS [commandResponce: CommandResponce ¬ ok] =   BEGIN  commandString: LONG STRING ¬ [256];  end: BOOLEAN ¬ FALSE;  byteCount: CARDINAL ¬ 0;  status: RS232C.TransferStatus ¬ success;  stat: RS232C.DeviceStatus;  getHandleHead, getHandleTail: LONG POINTER TO CompletionHandleChain ¬ NIL;      CreateCompletionHandle: PROCEDURE [doGet: BOOLEAN ¬ TRUE, completionHandle: RS232C.CompletionHandle] =    BEGIN    p: LONG POINTER TO CompletionHandleChain;    p ¬ zone.NEW[CompletionHandleChain];    p.next ¬ NIL;    IF doGet THEN {      p.block.blockPointer ¬ LOOPHOLE[zone.NEW[Block]];      p.block.startIndex ¬ 0;      p.block.stopIndexPlusOne ¬ 20;      p.rec.body ¬ p.block;      p.completionHandle ¬ Get[handle, @p.rec]}    ELSE {      p.rec ¬ rec;      p.completionHandle ¬ completionHandle};    IF getHandleHead = NIL THEN         getHandleHead ¬ getHandleTail ¬ p    ELSE {        getHandleTail.next ¬ p;	getHandleTail ¬ p};    END;        FreeCompletionHandle: PROCEDURE =    BEGIN    tempHandle: LONG POINTER TO CompletionHandleChain ¬ getHandleHead;      getHandleHead ¬ getHandleHead.next;      zone.FREE[@tempHandle.block.blockPointer];      zone.FREE[@tempHandle];    END;      BEGIN    CreateCompletionHandle[FALSE, completionHandle];        WHILE ~end DO      CreateCompletionHandle[TRUE, ];      [byteCount, status] ¬ TransferWait[handle, getHandleHead.completionHandle];      SELECT status FROM        success => NULL;	checksumError, parityError, asynchFramingError => NULL;			-- to take care of invalid characters on connect	aborted => {commandResponce ¬ timeout; GOTO error};      ENDCASE => {commandResponce ¬ error; GOTO error};      FOR i: CARDINAL IN [getHandleHead.rec.body.startIndex..getHandleHead.rec.body.startIndex+byteCount) DO        IF Inline.BITAND[getHandleHead.rec.body.blockPointer[i], 177B] IN [101B..107B) OR 	  Inline.BITAND[getHandleHead.rec.body.blockPointer[i], 177B] = 15B THEN {	    end ¬ TRUE; 	  IF rec.body.blockPointer[i] # 15B THEN String.AppendChar[commandString, LOOPHOLE[Inline.BITAND[getHandleHead.rec.body.blockPointer[i], 177B]]];	  EXIT}	ELSE	  String.AppendChar[commandString, LOOPHOLE[Inline.BITAND[getHandleHead.rec.body.blockPointer[i], 177B]]];      ENDLOOP;      FreeCompletionHandle[];    ENDLOOP;    SELECT TRUE FROM      String.Equivalent[commandString, "A"L] => {        IF RS232CPrivate.GetParameters[handle].lineSpeed = bps1200 THEN {	  stat ¬ RS232C.GetStatus[handle];	  DO		-- So modem can drop CD and try Bell 212	    IF stat.carrierDetect = FALSE THEN EXIT;	    stat ¬ RS232C.StatusWait[handle, stat];	  ENDLOOP};	RETURN[connect]};      String.Equivalent[commandString, "B"L] => RETURN[abort];      String.Equivalent[commandString, "D"L] => RETURN[formatError];      String.Equivalent[commandString, "E"L] => RETURN[error];      String.Equivalent[commandString, "F"L] => RETURN[error];      String.Equivalent[commandString, "G"L] => RETURN[busy];    ENDCASE => RETURN[error];  EXITS    error => FreeCompletionHandle[];  END;  Process.Detach[FORK RS232C.Suspend[handle, input]];  WHILE getHandleHead # NIL DO    [byteCount, status] ¬ TransferWait[handle, getHandleHead.completionHandle ! RS232C.ChannelSuspended => CONTINUE];    FreeCompletionHandle[];  ENDLOOP;  RS232C.Restart[handle, input];  END;    DialV25bis: PROCEDURE [    dialerNumber: CARDINAL, number: LONG POINTER TO Dialup.Number,    retries: Dialup.RetryCount, dialerType: DialupExtras.DialerType ¬ V25bis]    RETURNS [outcome: Dialup.Outcome] =        BEGIN    handle: RS232C.ChannelHandle ¬ RS232CPrivate.FindChannel[dialerNumber];    dialMessage: PACKED ARRAY INTEGER[0..3) OF Environment.Byte ¬ [103B, 122B, 116B];	-- "CRN"    crlf: PACKED ARRAY INTEGER[0..2) OF Environment.Byte ¬ [015B, 012B];			-- "CRLF"    rec: RS232CEnvironment.PhysicalRecord ¬ [header: [NIL, 0, 0], body: [@dialMessage, 0, 3], trailer: [NIL, 0, 0]];    getCompletionHandle, completionHandle: RS232C.CompletionHandle;    transferStatus: RS232C.TransferStatus;    words: PACKED ARRAY INTEGER[0..20) OF Environment.Byte ¬ ALL[0];    getRec: RS232CEnvironment.PhysicalRecord ¬ [header: [NIL, 0, 0], body: [@words, 0, 20], trailer: [NIL, 0, 0]];    status: CommandResponce ¬ ok;    seconds: CARDINAL ¬ 0;    watcher: PROCESS ¬ NIL;    BEGIN ENABLE UNWIND =>      IF watcher # NIL THEN {Process.Abort[watcher]; JOIN watcher};            Watcher: ENTRY PROCEDURE [process: PROCESS] =      BEGIN	BEGIN ENABLE ABORTED => GOTO Return;	timer: CONDITION;	  Process.EnableAborts[@timer];	  Process.SetTimeout[@timer, Process.MsecToTicks[1000]];	  WHILE seconds < 80 DO	    WAIT timer;	    seconds ¬ seconds + 1;	  ENDLOOP;	  RS232C.Suspend[handle, input];	  RS232C.Restart[handle, input];	END;      EXITS        Return => RETURN;      END;            -- the retries field is not used for V.25bis dialing since the return indication gives the retry interval of a least one minute the client should implement his own retry scheme the retry interval should be passed back to the client.          IF handle = LOOPHOLE[LONG[NIL]] THEN RETURN[failure];      RS232C.SetParameter[handle, [frameTimeout[30]]];      RS232C.SetParameter[handle, [dataTerminalReady[FALSE]]];      Process.Pause[Process.MsecToTicks[1500]];      RS232C.SetParameter[handle, [dataTerminalReady[TRUE]]];      InitializeCleanup[];      BEGIN      ENABLE UNWIND => DoCleanup[handle];      getCompletionHandle ¬ Get[handle, @getRec];	-- issue get for responce      rec.body ¬ [@dialMessage, 0, 3];      completionHandle ¬ Put[handle, @rec];      [ , transferStatus] ¬ TransmitNow[handle, completionHandle];      SELECT transferStatus FROM	success => NULL;      ENDCASE => {DoCleanup[handle]; RETURN[failure]};      rec.body ¬ [LOOPHOLE[number + SIZE[Dialup.Number[0]]], 0, number.n];	-- add one to skip sequence length      completionHandle ¬ Put[handle, @rec];      [ , transferStatus] ¬ TransmitNow[handle, completionHandle];      rec.body ¬ [@crlf, 0, 2];      completionHandle ¬ Put[handle, @rec];      [ , transferStatus] ¬ TransmitNow[handle, completionHandle];      SELECT transferStatus FROM	success => NULL;      ENDCASE => {DoCleanup[handle]; RETURN[failure]};      watcher ¬ FORK Watcher[Process.GetCurrent[]];      status ¬ GetV25bisDialerResponce[handle, getCompletionHandle, getRec];      Process.Abort[watcher];      JOIN watcher;      watcher ¬ NIL;      seconds ¬ 0;      outcome ¬ SELECT status FROM	IN[ok..connect2400] => success,	busy => dataLineOccupied,	abort => aborted,	formatError => formatError,	timeout => dialingTimeout,      ENDCASE => failure;      DoCleanup[handle];      END; --ENABLE UNWIND    END;  END;    GetV25bisDialerResponce: PROCEDURE     [handle: RS232C.ChannelHandle, completionHandle: RS232C.CompletionHandle, rec: RS232CEnvironment.PhysicalRecord]     RETURNS [commandResponce: CommandResponce ¬ ok] =  BEGIN  commandString: LONG STRING ¬ [256];  parameterString: LONG STRING ¬ [256];  end, aborted: BOOLEAN ¬ FALSE;  byteCount, bytesReceived: CARDINAL ¬ 0;  status: RS232C.TransferStatus ¬ success;  transferProcess: PROCESS ¬ NIL;  lineStatus: RS232C.DeviceStatus;  BEGIN ENABLE UNWIND =>     IF transferProcess # NIL THEN {      Process.Abort[transferProcess]; JOIN transferProcess};      TransferWaitInternal: PROCEDURE [process: PROCESS] =    BEGIN ENABLE ABORTED => CONTINUE;      [byteCount, status] ¬ TransferWait[handle, completionHandle];      IF ~end THEN Process.Abort[process];    END;          WHILE ~end DO      transferProcess ¬ FORK TransferWaitInternal[Process.GetCurrent[]];      DO BEGIN ENABLE {        RS232C.ChannelSuspended => EXIT; 	ABORTED => {aborted ¬ TRUE; EXIT}};	  lineStatus ¬ RS232C.StatusWait[handle, RS232C.GetStatus[handle]];	  IF lineStatus.clearToSend = FALSE OR lineStatus.dataSetReady = TRUE	    THEN {end ¬ TRUE; EXIT};	END;      ENDLOOP;      Process.Abort[transferProcess];      JOIN transferProcess;      transferProcess ¬ NIL;      IF end THEN RETURN[ok];      IF aborted THEN --ERROR ABORTED-- RETURN[timeout];      SELECT status FROM        success => NULL;	checksumError, parityError, asynchFramingError => NULL;			-- to take care of invalid characters on connect        aborted => RETURN[timeout];      ENDCASE => RETURN[error];      FOR i: CARDINAL IN [rec.body.startIndex..rec.body.startIndex+byteCount) DO        IF Inline.BITAND[rec.body.blockPointer[i], 177B] = 15B THEN {end ¬ TRUE; EXIT};	IF bytesReceived > 2 THEN String.AppendChar[parameterString, LOOPHOLE[Inline.BITAND[rec.body.blockPointer[i], 177B]]]	ELSE String.AppendChar[commandString, LOOPHOLE[Inline.BITAND[rec.body.blockPointer[i], 177B]]];	bytesReceived ¬ bytesReceived + 1;      ENDLOOP;      IF ~end THEN completionHandle ¬ Get[handle, @rec];    ENDLOOP;    SELECT TRUE FROM      String.Equivalent[commandString, "CFI"L] =>         SELECT TRUE FROM	  String.Equivalent[parameterString, "ET"L] => RETURN[error];	  String.Equivalent[parameterString, "NS"L] => RETURN[error];	  String.Equivalent[parameterString, "CB"L] => RETURN[busy];	  String.Equivalent[parameterString, "RT"L] => RETURN[noAnswer];	  String.Equivalent[parameterString, "AB"L] => RETURN[abort];	  String.Equivalent[parameterString, "NT"L] => RETURN[noDialtone];	  String.Equivalent[parameterString, "FC"L] => RETURN[error];	ENDCASE => RETURN[error];      String.Equivalent[commandString, "DLC"L] => RETURN[timeout];      String.Equivalent[commandString, "INC"L] => RETURN[error];      String.Equivalent[commandString, "VAL"L] => RETURN[connect];      String.Equivalent[commandString, "INV"L] => RETURN[error];    ENDCASE => RETURN[error];    END; 	-- ENABLE  END;    --"CLEANUP" PROCEDURES--    OperationClass: TYPE = RS232C.OperationClass[input..output];  OperationHandle: TYPE = LONG POINTER TO OperationObject;  OperationList: TYPE = RECORD[    inUse: OperationHandle,    free: OperationHandle];  OperationObject: TYPE = RECORD[    next: OperationHandle,    cH: RS232C.CompletionHandle];    opList: ARRAY OperationClass OF OperationList;  opZone: UNCOUNTED ZONE;    Get: PROC[channel: RS232C.ChannelHandle, rec: RS232C.PhysicalRecordHandle] RETURNS[cH: RS232C.CompletionHandle] =    BEGIN    cH ¬ RS232C.Get[channel, rec];    AddOperation[cH, input];    END;    Put: PROC[channel: RS232C.ChannelHandle, rec: RS232C.PhysicalRecordHandle] RETURNS[cH: RS232C.CompletionHandle] =    BEGIN    cH ¬ RS232C.Put[channel, rec];    AddOperation[cH, output];    END;    TransferWait: PROC[channel: RS232C.ChannelHandle, event: RS232C.CompletionHandle] RETURNS[byteCount: CARDINAL, status: RS232C.TransferStatus] =    BEGIN    [byteCount, status] ¬ RS232C.TransferWait[channel, event];    RemoveOperation[event, input];    END;    TransmitNow: PROC[channel: RS232C.ChannelHandle, event: RS232C.CompletionHandle] RETURNS[byteCount: CARDINAL, status: RS232C.TransferStatus] =    BEGIN    [byteCount, status] ¬ RS232C.TransmitNow[channel, event];    RemoveOperation[event, output];    END;    AddOperation: ENTRY PROC[cH: RS232C.CompletionHandle, class: OperationClass] =    BEGIN    list: LONG POINTER TO OperationList = @opList[class];    op: OperationHandle;    IF list.free # NIL THEN {op ¬ list.free; list.free ¬ op.next}    ELSE op ¬ opZone.NEW[OperationObject];    op­ ¬ [list.inUse, cH];    list.inUse ¬ op;    END;    DoCleanup: PROC[handle: RS232C.ChannelHandle] =    BEGIN    FOR class: OperationClass IN OperationClass DO      p: PROCESS;      p ¬ FORK RS232C.Suspend[handle, class];      FOR op: OperationHandle ¬ opList[class].inUse, op.next UNTIL op = NIL DO        [] ¬ RS232C.TransferWait[handle, op.cH];        ENDLOOP;      JOIN p;      RS232C.Restart[handle, class];      ENDLOOP;    Heap.Delete[z: opZone, checkEmpty: FALSE];    END;    InitializeCleanup: PROC =    BEGIN    opList ¬ ALL[[NIL, NIL]];    opZone ¬ Heap.CreateUniform[      initial: 1, increment: 1, objectSize: SIZE[OperationObject]];    END;    RemoveOperation: ENTRY PROC[cH: RS232C.CompletionHandle, class: OperationClass] =    BEGIN    list: LONG POINTER TO OperationList = @opList[class];    op: OperationHandle;    prev: OperationHandle ¬ NIL;    FOR op ¬ list.inUse, op.next UNTIL op = NIL DO      IF op.cH = cH THEN        BEGIN	IF prev = NIL THEN list.inUse ¬ op.next	ELSE prev.next ¬ op.next;	EXIT;	END      ELSE prev ¬ op;      REPEAT FINISHED => RETURN --not found--;      ENDLOOP;    --return to free list--    op.next ¬ list.free;    list.free ¬ op;    END;  Process.EnableAborts[@timer];  Process.SetTimeout[@oneTick, 1];  END.LOGTime: October 18, 1978  8:47 AM	By: VXS	Action: Created fileTime: May 30, 1980  3:00 PM	By: VXS	Action: Remove all pre-Amargosa log entries, and change abortRequested to an array to allow support of multiple dialers.Time: July 10, 1980  10:55 AM	By: BRD	Action: Modified to support use RS366Face interface.Time: January 20, 1981  3:51 PM	By: BRD	Action: Added GetDialerCount procedure to allow client to determine number of dialers.Time: 27-Sep-83 14:20:53  By: SMA  Action: Made dialer multinational. Added <pause>;  now takes actual values in the bytes of the number to dial. (AR 4405)Time: 25-Jan-85 14:28:16  By: SMA  Action:  Added dialerType.Time: 23-Oct-85 10:03:19  By: JAV  Action:  Added Hayes smartmodem supportTime:  4-Nov-86 14:22:52  By: JAV  Action:  Added Ventel and Racal Vadic supportTime: 11-Mar-87 17:03:43  By: JAV  Action:  Added V.25bis support, fixed multiport Get problem23-Mar-88 10:27:40  BKI  Fixed ARs 12114 and 12959. 6-Apr-88 17:38:34  BKI  Fixed ARs 12998 and 13026.11-Apr-88 19:49:00  BKI  Fixed ARs 13027 and 13046.12-Apr-88 12:07:19  BKI  Fixed AR 12981.
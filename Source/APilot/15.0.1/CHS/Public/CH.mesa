-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. --CH.mesa--last edited by Gealy,    2-Jan-84 23:14:23DIRECTORY  Auth USING [CallProblem, ConversationHandle, IdentityHandle],  Courier USING [Parameters],  Environment USING [Block, bytesPerWord],  NSName USING [Domain, Local, maxDomainLength, maxLocalLength, maxOrgLength,    Organization, Name, separator, NameRecord, wildCard],  System USING [NetworkAddress];CH: DEFINITIONS =  BEGIN    -- Constants that are used by the clearinghouse and that the user should be  -- aware of..  wildCard: CHARACTER = NSName.wildCard;  separator: CHARACTER = NSName.separator;  maxOrgNameLength: CARDINAL = NSName.maxOrgLength;  maxDomainNameLength: CARDINAL = NSName.maxDomainLength;  maxLocalNameLength: CARDINAL = NSName.maxLocalLength;    OrgName: TYPE = NSName.Organization;      -- not more than maxOrgLength bytes long  DomainName: TYPE = NSName.Domain;     -- not more than maxDomainLength bytes long  LocalName: TYPE = NSName.Local; -- not more than maxLocalLength bytes long    Element: TYPE = LONG POINTER TO ThreePartName;  ThreePartName: TYPE = NSName.NameRecord;      -- wildcard characters ARE allowed in ThreePartNames.    NameRecord: TYPE = NSName.NameRecord;      -- NO wildcard characters are allowed in NameRecords.  Name: TYPE = NSName.Name;    Pattern: TYPE = LONG POINTER TO NamePattern;  NamePattern: TYPE = ThreePartName;  -- the least significant (usually the  -- localName field) portion of this record may have wildcard characters;  the  -- other portions may not.    zeroMaxLengthNames: READONLY Name;      -- a valid pointer to a NameRecord whose subfields are zero bytes long.    PropertyID: TYPE = LONG CARDINAL;  notUsable: PropertyID = LAST[PropertyID];  unspecified: PropertyID = 0;    ConversationHandle: TYPE = RECORD[    conversation: Auth.ConversationHandle,    address: LONG POINTER TO System.NetworkAddress ¬ NIL];    -- ConversationHandles may NOT be shared by more than one process.    -- Notes on the address parameter:      -- This parameter  enables a query to be directed at a particular    -- clearinghouse server.  It is intended to be used to monitor clearinghouse    -- performance and to detect inconsistencies in replicated databases.  Most    -- clients will use the default value for this parameter.       -- The clearinghouse database uses a three level naming hierarchy.  -- The three subfields localName, domainName, and  -- orgName have maximum length restrictions of maxLocalNameLength,  -- maxDomainNameLength, and maxOrgNameLength, respectively.  -- The orgName subfield is the most significant subfield; the localName  -- subfield is the least. The clearinghouse supports wildcard characters, '*   -- in the least significant subfield when doing clearinghouse database querying  -- (Lookups or Enumerations).  The least significant subfield is usually the  -- localName subfield.  In EnumerateOrganizations and EnumerateDomains, the  -- least significant subfields are the orgName and domainName, respectively.  -- Wildcards are not allowed in any of the subfields when doing any  -- clearinghouse database modification operations (add, delete, or change).    -- More on Patterns:  -- "*" is the most obvious (and most inefficient) pattern; it matches   -- everything.  "A*" matches everything starting with an 'A,  -- ignoring case.  "*e***rt*y*o*" could match "Robert B. Lyon".  -- Warnings:  -- 1) When a pattern is used in a Lookup operation, the "most convenient"   -- match is used.  This is NOT the first one alphabetically; it may not be the  -- same one when the identical operation is repeated.  -- 2) If no match is found, then the same pattern is applied to the aliases;  -- if a match is found, the alias is dereferenced and the Lookup is  -- repeated with the distinguished name.  -- Note that many operations return "distingName" which tell the user  -- which object in the database the operation was performed on (this is  -- most useful in the case of patterns and/or aliases).    -- More on aliases:  --  A distinguished name in a domain may have aliases in other domains.  So  -- "Bob:OSBU South:Xerox" may be an alias for   -- "Robert B. Lyon:OSBU North:Versatec".    -- NOTE: Most operations on the clearinghouse database operate on a  -- Name - PropertyID pair.  ALL operations on the clearinghouse database return  -- at least a ReturnCode.    ReturnCode: TYPE = MACHINE DEPENDENT RECORD [    code: Code,    which: ParameterGrouping ];      -- ReturnCode.which applies if the operation did not complete successfully    -- and there are two parameters of the same type that could have caused the    -- problem (e.g. IsMember).     ParameterGrouping: TYPE = MACHINE DEPENDENT {    first(1),  -- the return code concerns the first group of parameters.    second(2),  -- the return code concerns the second group of parameters.    (LAST[CARDINAL])  };    Code: TYPE = MACHINE DEPENDENT {    -- result of an CH operation.    done(0),  -- operation succeeded    notAllowed(1),  -- operation prevented by access controls    rejectedTooBusy(2),  -- server is too busy to service this request    allDown(3),  -- remote CHServer was down and it was needed for this operation    (4),  -- user will never see this code (operationRejectedUseCourier)    badProtocol(5), -- protocol violation (e.g. Name too big in stream operation)    illegalPropertyID(10),  -- the specified PropertyID violates the protocol    illegalOrgName(11),  -- org name has illegal length or illegal characters    illegalDomainName(12), -- domain name has illegal length or characters    illegalLocalName(13), -- local name has illegal length or illegal characters    noSuchOrg(14),  -- the specified organization does not exist    noSuchDomain(15),  -- the specified domain does not exist in the organization    noSuchLocal(16),  -- the specified local does not exist in the domain    propertyIDNotFound(20), -- the name exists, but the PropertyID does not    wrongPropertyType(21),       -- you wanted a Group, but it was a Value, or vice versa    noChange(30),  -- the specified operation would not change the database    outOfDate(31),  -- operation ignored - more recent info was in the database    overflowOfName(32),       -- the specified name has too much data associated with it    overflowOfDataBase(33), -- the database has run out of room    (50),  -- user will never see this code (wrongServer)        -- authentication problems    credentialsInvalid(60),    (61),  -- user should never see this code (verifierInvalid)    (62),  -- user should never see this code (verifierExpired)    (63),  -- someone used the verifier before the CHStub could           --user should never see this code (verifierReused)    (64),  -- user should never see this code (credentialsExpired)    credentialsTooWeak(65),        wasUpNowDown(70),        -- the remote service disappeared while streaming data. The user has an      -- incomplete answer to his query.     (LAST[CARDINAL])  };   -- About some common parameters:  -- 'distingName' is filled in by the routines - it is the exact, distinguished  -- name found in the clearinghouse database.  If 'distingName' is too small  -- then NameTooSmall is signaled (see below) - the user can always avoid this  -- by making 'distingName' fields the maximum lengths.  -- NOTE: The client may pass NIL as the 'distingName' parameter;  in this case  -- no attempt will be made to fill in the 'distingName'.    -- Queries, additions, deletions, and changes require one of the following:  -- a) a buffer area to put/get data into/from; buffers are used in  -- conjunction with Value type operations (if the buffer area is too small  -- CH will signal BufferTooSmall), or  -- b) a callback procedure, NameStreamProc through which the user is given  -- a name to inspect.     maxBufferSize: CARDINAL = 500;       -- 500 words    Buffer: TYPE = LONG POINTER TO BufferArea;  BufferArea: TYPE = MACHINE DEPENDENT RECORD [    maxlength(0): CARDINAL [0 .. maxBufferSize], -- user sets it, CH inspects it.    length(1): CARDINAL [0 .. maxBufferSize],        -- CH sets length on queries; users set it for additions, and changes.    data(2): SEQUENCE COMPUTED CARDINAL OF WORD ];      BufferTooSmall: SIGNAL [offender: Buffer, lengthNeeded: CARDINAL] --in words    RETURNS [newBuffer: Buffer];        NameStreamProc: TYPE = PROCEDURE [currentName: Element];    -- The CH stub owns currentName & its storage.  Clients may     -- inspect, but they should not munge it.  Upon return, currentName is no    -- longer a valid pointer.  Most of the work for enumerations is done before    -- the client is called back, but if a client really wants to stop the    -- enumeration, a SIGNAL can be raised in this callback and caught in the    -- client's code.      -- Operations which read the database:      LookupDistinguishedName: PROCEDURE [conversation: ConversationHandle,    name: Pattern, distingName: Name]    RETURNS [rc: ReturnCode];     -- User supplies name and the clearinghouse fills in distingName.    LookupValueProperty: PROCEDURE [conversation: ConversationHandle,     name: Pattern, pn: PropertyID, buffer: Buffer, distingName: Name]    RETURNS [rc: ReturnCode];  -- buffer and distingName are filled in.    LookupGroupProperty: PROCEDURE [conversation: ConversationHandle,     name: Pattern, pn: PropertyID, eachElement: NameStreamProc,     distingName: Name]    RETURNS [rc: ReturnCode];     -- distingName is filled in.  Each element in the group is presented to the    -- user via eachElement.  The results are SORTED in the order defined by    -- NSString, ignoring case, where the orgName subfield of a name is the most    -- significant subfield and the localName subfield is the least. All three    -- subfields have meaning and are always set before calling the user.    IsMember: PROCEDURE [conversation: ConversationHandle, element: Element,    name: Pattern, pn: PropertyID, distingName: Name]    RETURNS [rc: ReturnCode, isMember: BOOLEAN];    -- isMember is FALSE if anything goes wrong.    -- element may have wildcard characters in any of its fields, but is     -- interpreted verbatim.  Each member of the group is treated as a pattern;    -- isMember is TRUE if a pattern matches the element.    -- As usual, distingName is filled in.    IsMemberClosure: PROCEDURE [conversation: ConversationHandle,     element: Element, name: Pattern, pn: PropertyID, distingName: Name,     pn2: PropertyID ¬ unspecified]    RETURNS [rc: ReturnCode, isMember: BOOLEAN];    -- if pn2 is left defaulted to unspecified, then the implementation    -- sets pn2 ¬ pn.  element and group members have the same conditions    -- as those in IsMember. As usual, distingName is filled in.      Properties: TYPE = LONG DESCRIPTOR FOR ARRAY OF PropertyID;    GetProperties: PROCEDURE [conversation: ConversationHandle,    name: Pattern, distingName: Name, heap: UNCOUNTED ZONE]    RETURNS [rc: ReturnCode, properties: Properties];    -- As usual, distingName is filled in.      FreeProperties: PROCEDURE [properties: LONG POINTER TO Properties,    heap: UNCOUNTED ZONE];    -- Frees properties and sets BASE[properties­] to NIL.      -- Operations which enumerate things.  -- NOTES on enumerations:  -- The result of enumerations are SORTED in the order defined by NSString,  -- ignoring case, where the orgName subfield of a name is the most significant  -- subfield and the localName subfield is the least.  -- Warnings:  -- 1) Any enumeration operation takes a callback routine.  That routine is  -- called for each name in the enumeration.  The client may inspect (or copy)  -- this name; but s/he may not munge it;  the name is no longer valid when the  -- user returns from the callback routine.  -- 2) In EnumerateOrganizations, EnumerateDomains, Enumerate, and  -- EnumerateAliases, only the currentName subfields orgName, domainName,   -- localName, and localName, respectively, have meaning and are set before  -- calling the user.  The subfields that are not used are initialized to the  -- corresponding subfields of the pattern  parameter that is passed to the  -- enumeration operation (these subfields are just copies of the strings that  -- the client owns).       EnumerateOrganizations: PROCEDURE [conversation: ConversationHandle,    orgPattern: Pattern, eachOrg: NameStreamProc]    RETURNS [rc: ReturnCode];    -- Any organization name that matches orgPattern is enumerated.    -- Only the orgName field of the record is filled in for each Name     -- acquired through the callback procedure, eachOrg.     EnumerateDomains: PROCEDURE [conversation: ConversationHandle,    name: Pattern, eachDomain: NameStreamProc]    RETURNS [rc: ReturnCode];    -- name.orgName may not have wildcard characters.  All domains in    -- name.orgName that match the pattern given in name.domainName    -- are enumerated.  Only the domainName field of the record is filled in for     -- each Name acquired through the callback procedure, eachDomain.    Enumerate: PROCEDURE [conversation: ConversationHandle, name: Pattern,    pn: PropertyID, eachName: NameStreamProc]    RETURNS [rc: ReturnCode];    -- Only the LocalName field of the record is filled in for each Name     -- acquired through the callback procedure, eachName.    EnumerateAliases: PROCEDURE [conversation: ConversationHandle,     name: Pattern, eachAlias: NameStreamProc]    RETURNS [rc: ReturnCode];    -- Only the LocalName field of the record is filled in for each alias     -- acquired through the callback procedure, eachAlias.    LookupAliasesOfName: PROCEDURE [conversation: ConversationHandle,     name: Pattern, eachAlias: NameStreamProc, distingName: Name]    RETURNS [rc: ReturnCode];     -- distingName is filled in.  Each alias in the CH that points to distingName    -- is streamed to the user via eachAlias.  The results are SORTED in the    -- order defined by NSString, ignoring case, where the orgName subfield of a    -- name is the most significant subfield and the localName subfield is the    -- least. All three subfields have meaning and are always set before calling    -- the user.    EnumerateNearbyDomains:  PROCEDURE [conversation: ConversationHandle,    eachDomain: NameStreamProc]    RETURNS [rc: ReturnCode];    -- Both the DomainName and OrgName fields are filled-in and presented to the    -- user via eachDomain.  Each domain name is the name of a domain which this    -- machine considers to be nearby.  The results are SORTED in the order    -- defined by NSString, ignoring case, where the orgName subfield of a name    -- is the most significant.    -- ****************************************************************************    -- All operations below this point are for administration of the database.     -- Operations which modify the database.  -- NOTES:  In order to add a value property, the name must already be in the  -- database.  Similarly, in order to change a property, the name and property  -- must already exist.    AddDistinguishedName: PROCEDURE [conversation: ConversationHandle,     name: Name, distingName: Name] RETURNS [rc: ReturnCode];      -- distingName is filled in.    DeleteDistinguishedName: PROCEDURE [conversation: ConversationHandle,    name: Name, distingName: Name] RETURNS [rc: ReturnCode];      -- distingName is filled in.  All properties and aliases associated     -- with the name are also deleted.    AddAlias: PROCEDURE [conversation: ConversationHandle,    name, newAliasName, distingName: Name]    RETURNS [rc: ReturnCode]; -- distingName is filled in. There is nothing    -- special about aliases and their relation to "user" entries.  Anything    -- (like fileservers or printservers) may have aliases.    DeleteAlias: PROCEDURE [conversation: ConversationHandle,     aliasName, distingName: Name]    RETURNS [rc: ReturnCode];  -- distingName is filled in.    AddValueProperty: PROCEDURE [conversation: ConversationHandle, name: Name,    pn: PropertyID, rhs: Buffer, distingName: Name]    RETURNS [rc: ReturnCode];  -- distingName is filled in.    ChangeValueProperty: PROCEDURE [conversation: ConversationHandle,     name: Name, pn: PropertyID, newRhs: Buffer, distingName:Name]    RETURNS [rc: ReturnCode];  -- distingName is filled in.    EnumerateNewGroupElements: TYPE = PROCEDURE [eachName: NameStreamProc];    AddGroupProperty: PROCEDURE [conversation: ConversationHandle, name: Name,    pn: PropertyID, elementEnumerator: EnumerateNewGroupElements ¬ NIL,    distingName: Name]    RETURNS [rc: ReturnCode];  -- distingName is filled in.    -- The CH stub code calls back to the user via elementEnumerator, passing    -- a procedure that the client can call to add each new element to the new    -- group. Each new element may have wildcard characters in any of its fields.    -- The new elements are copied in verbatim.    DeleteProperty: PROCEDURE [conversation: ConversationHandle,    name: Name, pn: PropertyID, distingName: Name]    RETURNS [rc: ReturnCode];  -- distingName is filled in.    AddGroupMember: PROCEDURE [conversation: ConversationHandle,    element: Element, name: Name, pn: PropertyID, distingName: Name]    RETURNS [rc: ReturnCode];  -- distingName is filled in.    -- The element (which may have wildcards in any of its fields) is added to    -- the group verbatim.     DeleteGroupMember: PROCEDURE [conversation: ConversationHandle,    element: Element, name: Name, pn: PropertyID, distingName: Name]    RETURNS [rc: ReturnCode];      -- distingName is filled in. The element may have wildcard characters in any    -- of its fields.    AddSelf: PROCEDURE [conversation: ConversationHandle, name: Name,    pn: PropertyID, distingName: Name]    RETURNS [rc: ReturnCode];      -- distingName is filled in.  Adds the name that initiated the conversation    -- with the clearinghouse to the group Name.    DeleteSelf: PROCEDURE [conversation: ConversationHandle, name: Name,    pn: PropertyID, distingName: Name]    RETURNS [rc: ReturnCode];       -- distingName is filled in.  Deletes the name that initiated the    -- conversation with the clearinghouse from the group Name.    -- ****************************************************************************      -- Utilities  -- The utilities assume that the user has valid data.  -- The user must catch any signals (from Heap, NSString, and Courier) that  -- occur if he insists on passing lousy data or full heaps.    MakeConversationHandle: PROCEDURE[identity: Auth.IdentityHandle,     heap: UNCOUNTED ZONE] RETURNS [conversation: ConversationHandle, ok: BOOLEAN,     authCallError: Auth.CallProblem];    -- Most calls to the clearinghouse need a ConversationHandle.  This    -- procedure creates a ConversationHandle that allows a client to talk to the    -- clearinghouse service.  ok is FALSE if there was a problem calling the    -- authentication service.  When ok is FALSE, authCallError tells what the    -- problem was.      FreeConversationHandle: PROCEDURE [    conversation: LONG POINTER TO ConversationHandle, heap: UNCOUNTED ZONE];    -- conversation­ is NIL after this completes.    MakeRhs: PROCEDURE[maxlength: CARDINAL[0..maxBufferSize], heap: UNCOUNTED ZONE]    RETURNS [rhs: Buffer];    -- Returns a buffer whose maxlength is maxlength; length is zero.    -- User is responsible for the allocated memory.    DeserializeFromBlock: PROCEDURE [parms: Courier.Parameters,     heap: UNCOUNTED ZONE, blk: Environment.Block] RETURNS [succeeded: BOOLEAN];    -- Given a block, this routine tries to deserialize the block according to     -- parms.  If succeeded is TRUE, then the user is responsible for any storage    -- that may have been allocated by the Deserialization.    DeserializeFromRhs: PROCEDURE [parms: Courier.Parameters,     heap: UNCOUNTED ZONE, rhs: Buffer] RETURNS [succeeded: BOOLEAN] =     INLINE {  succeeded ¬ DeserializeFromBlock[parms, heap,       [LOOPHOLE[@rhs.data], 0, Environment.bytesPerWord*rhs.length]] };    SerializeIntoRhs: PROCEDURE [parms: Courier.Parameters,     heap: UNCOUNTED ZONE] RETURNS [rhs: Buffer];    -- Returns a buffer whose length and maxlength are set to the exact number    -- of words needed to hold the serialized "parameters".  The    -- "parameters" are then serialized into the buffer.  User is responsible    -- for the allocated memory. (This procedure calls WordsForSerializedData.)    ScopedSerializeIntoRhs: PROCEDURE [parms: Courier.Parameters,     callback: PROCEDURE [rhs: Buffer]];    -- The user is called back with a buffer (allocated from the system heap)    -- whose length and maxlength are set to the exact number of words needed to    -- hold the serialized "parameters".  The "parameters" are then serialized    -- into the buffer. The rhs is deallocated upon return from callback or via    -- UNWIND.    FreeRhs: PROCEDURE [rhs: Buffer, heap: UNCOUNTED ZONE];    -- This is where the user gets rid of the Buffers he is responsible for.    END..  LOG 1-Oct-82 16:48:17 - BLyon - Created.11-Apr-83 16:14:38 - SMA - Changes for NS (Klamath).  10-Nov-83  9:35:36 - Read - changes for authentication. 2-Jan-84 23:14:27 - Gealy - Minor changes.   
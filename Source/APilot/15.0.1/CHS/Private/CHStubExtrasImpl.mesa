-- Copyright (C) 1985  by Xerox Corporation. All rights reserved. -- CHStubExtrasImpl.mesa-- last edited by mweeks, 15-Apr-85 15:43:10<<This module implements changes to streamline the CHAntiEntropy  protocol. Like the definitions file the changes should be   distributed among several files>>DIRECTORY  Auth USING [    Credentials, Verifier, DescribeCredentials, DescribeVerifier,    AuthenticationProblem],  CH USING [    Code, ParameterGrouping, PropertyID, Buffer, BufferArea, DeserializeFromBlock,    Name, NameRecord],  CHMUX USING [    slopAtEndOfParmRecord, slopAtEndOfResultRecord, GetCourierInfo,    MakeCallParameter, MakeReturnParameter, Parm, PEParm, PEResult, Result],  CHProtocol USING [    ACLFlavor, maxProperties, wrongServer, Bool, CardinalsToCourierProcedures,    chsToChsProgramsNumber, chsToChsVersionNumber, CourierProcedures,    CourierProceduresToCardinals, DescribeTimestamp, Parms, procsUseParms,    TimestampPtr, procsUseResult, procsUseError, Results, Timestamp, Version],  CHStreams USING [BeginRead, EndRead],  CHStubExtras USING [    ChecksumAndGts, enumerateChecksumAndGts, NameChecksumAndGts,    ChecksumAndGtsPtr],  Courier USING [Description, Error, Parameters, Free],  Environment USING [Byte, bytesPerWord, Block],  IncrementalSort USING [    AddElement, Destroy, Handle, MakeSorter],  IncrementalSortExtras USING [GetHeapParameters],  NSAddr USING [Address, DescribeAddress],  NSDataStream USING [DescribeTicket, Ticket],  NSName USING [String, DescribeNameRecord],  NSString USING [DescribeString, String],  Stream USING [GetBlock, GetWord, Handle];CHStubExtrasImpl: PROGRAM  IMPORTS    Auth, CH, CHMUX, CHProtocol, CHStreams, Courier, IncrementalSort,    IncrementalSortExtras, NSString, NSName, NSDataStream, NSAddr, Stream  EXPORTS CHStubExtras =  BEGIN  <<**********************************************************************************>>  << The next 4 procedures are to avoid array out bounds for CHProtocol.procUseParms   and CHProtocol.procUseResult >>  CourierProceduresToCardinals: PUBLIC PROCEDURE [cp: CHProtocol.CourierProcedures]    RETURNS [CARDINAL] =    BEGIN    SELECT cp FROM      CHStubExtras.enumerateChecksumAndGts => RETURN[43];      ENDCASE => RETURN[CHProtocol.CourierProceduresToCardinals[cp]];    END;  CardinalsToCourierProcedures: PUBLIC PROCEDURE [c: CARDINAL]    RETURNS [p: CHProtocol.CourierProcedures] =    BEGIN    SELECT c FROM      ORD[CHStubExtras.enumerateChecksumAndGts] =>        RETURN[CHStubExtras.enumerateChecksumAndGts];      ENDCASE => RETURN[CHProtocol.CardinalsToCourierProcedures[c]];    END;  ProcsUseParms: PUBLIC PROCEDURE [p: CHProtocol.CourierProcedures]    RETURNS [parms: CHProtocol.Parms] =    BEGIN    IF (p = CHStubExtras.enumerateChecksumAndGts) THEN      parms ¬ [nameOrg: TRUE, nameDomain: TRUE, sourceOrSink: TRUE]    ELSE parms ¬ CHProtocol.procsUseParms[p];    END;  ProcsUseResult: PUBLIC PROCEDURE [p: CHProtocol.CourierProcedures]    RETURNS [results: CHProtocol.Results] =    BEGIN    IF (p = CHStubExtras.enumerateChecksumAndGts) THEN      results ¬ [streamsLocals: TRUE]    ELSE results ¬ CHProtocol.procsUseResult[p];    END;  <<**********************************************************************************>>  << The next 5 procedures will go away when CHProtocol and CHMUXer can change. The    purpose of these procs is to avoid array out of bounds when CHMUXer indexes   CHProtocol.procUseParms or CHProtocol.procUseResult by CHStubExtras.enumerateChecksumAndGts   . >>  MakeCallParameter: PUBLIC PROCEDURE [parm: CHMUX.Parm, sending: BOOLEAN]    RETURNS [Courier.Parameters] =    BEGIN    IF parm.procedure = CHStubExtras.enumerateChecksumAndGts THEN      RETURN[Courier.Parameters[parm, DescribeParm]]    ELSE RETURN[CHMUX.MakeCallParameter[parm, sending]];    END;  --MakeCallParameter  MakeReturnParameter: PUBLIC PROCEDURE [    result: CHMUX.Result, sending: BOOLEAN, version: CHProtocol.Version]    RETURNS [Courier.Parameters] =    BEGIN    IF result.procedure = CHStubExtras.enumerateChecksumAndGts THEN      RETURN[Courier.Parameters[result, DescribeNewResult]]    ELSE RETURN[CHMUX.MakeReturnParameter[result, sending, version]];    END;  --MakeReturnParameter  GetCourierInfo: PUBLIC PROCEDURE [    chProcedure: CHProtocol.CourierProcedures, version: CHProtocol.Version]    RETURNS [      programNumber: LONG CARDINAL, versionNumber: CARDINAL,      procedureNumber: CARDINAL] =    BEGIN    IF chProcedure = CHStubExtras.enumerateChecksumAndGts THEN      BEGIN      procedureNumber ¬ ORD[CHStubExtras.enumerateChecksumAndGts];      programNumber ¬ CHProtocol.chsToChsProgramsNumber;      versionNumber ¬ CHProtocol.chsToChsVersionNumber;      END    ELSE      [programNumber, versionNumber, procedureNumber] ¬ CHMUX.GetCourierInfo[        chProcedure, version];    END;  DescribeParm: Courier.Description =    BEGIN    DescribeCHPartialName: Courier.Description =      BEGIN      name: CH.Name ¬ notes.noteSize[SIZE[CH.NameRecord]];      SELECT use.nameOrg FROM        TRUE => {notes.noteParameters[@name.org, NSString.DescribeString]; };        ENDCASE => {notes.noteDeadSpace[@name.org, SIZE[NSString.String]]; };      SELECT use.nameDomain FROM        TRUE => {notes.noteParameters[@name.domain, NSString.DescribeString]; };        ENDCASE => {notes.noteDeadSpace[@name.domain, SIZE[NSString.String]]; };      SELECT use.nameLocal FROM        TRUE => {notes.noteParameters[@name.local, NSString.DescribeString]; };        ENDCASE => {notes.noteDeadSpace[@name.local, SIZE[NSString.String]]; };      END;    parms: CHMUX.Parm ¬ notes.noteSize[SIZE[CHMUX.PEParm]];    use: CHProtocol.Parms ¬ ProcsUseParms[parms.procedure];    -- we always allocate a chName, even if all its string are null    notes.noteDisjointData[@parms.chName, DescribeCHPartialName];    SELECT use.pn FROM      TRUE => {notes.noteLongCardinal[@parms.pn]; };      ENDCASE => {notes.noteDeadSpace[@parms.pn, SIZE[LONG CARDINAL]]; };    SELECT use.aclist FROM      TRUE => { --notes.noteWORD[@parms.aclist];-- };      ENDCASE => {        notes.noteDeadSpace[@parms.aclist, SIZE[CHProtocol.ACLFlavor]]; };    SELECT use.pn2 FROM      TRUE => {notes.noteLongCardinal[@parms.pn2]; };      ENDCASE => {notes.noteDeadSpace[@parms.pn2, SIZE[LONG CARDINAL]]; };    SELECT use.element FROM      TRUE => {        notes.noteDisjointData[@parms.element, NSName.DescribeNameRecord]; };      ENDCASE => {notes.noteDeadSpace[@parms.element, SIZE[CH.Name]]; };    SELECT use.rhs FROM      TRUE => {        DescribeBufferArea: Courier.Description =          BEGIN          rhs: CH.Buffer ¬ notes.noteSize[SIZE[CH.BufferArea] + parms.rhsLength];          notes.noteDeadSpace[@rhs.maxlength, SIZE[CARDINAL]];  -- this never goes out on the wire          notes.noteDeadSpace[@rhs.length, SIZE[CARDINAL]];  -- this has been noted via "rhsLength"          -- the data portion now comes-in-from / goes-out-to the wire.          rhs.length ¬ parms.rhsLength;          rhs.maxlength ¬ MAX[rhs.maxlength, rhs.length];          END;        -- note CARDINAL WORD value  in parm.rhsLength --        notes.noteDisjointData[@parms.rhs, DescribeBufferArea];        };      ENDCASE => {        notes.noteDeadSpace[@parms.rhsLength, SIZE[CARDINAL] + SIZE[CH.Buffer]]; };    SELECT use.sourceOrSink FROM      TRUE => {        notes.noteDisjointData[@parms.sourceOrSink, NSDataStream.DescribeTicket];        };      ENDCASE => {        notes.noteDeadSpace[          @parms.sourceOrSink, SIZE[LONG POINTER TO NSDataStream.Ticket]];        };    SELECT use.gtsAndChecksum FROM      TRUE => {notes.noteDisjointData[@parms.gts, CHProtocol.DescribeTimestamp]; };      ENDCASE => {        notes.noteDeadSpace[          @parms.gts, SIZE[CHProtocol.TimestampPtr] + SIZE[CARDINAL]];        };    SELECT use.credAndVer FROM      TRUE => {        notes.noteParameters[@parms.cred, Auth.DescribeCredentials];        notes.noteParameters[@parms.ver, Auth.DescribeVerifier];        };      ENDCASE => {        notes.noteDeadSpace[          @parms.cred, SIZE[Auth.Credentials] + SIZE[Auth.Verifier]]};    notes.noteDeadSpace[      @parms.ver + SIZE[Auth.Verifier], CHMUX.slopAtEndOfParmRecord];  -- skip non-wire stuff    END;  --DescribeParm  DescribeAuthResults: Courier.Description =    BEGIN [] ¬ notes.noteSize[SIZE[Auth.AuthenticationProblem]]; END;  DescribeNewResult: Courier.Description =    BEGIN    results: CHMUX.Result ¬ notes.noteSize[SIZE[CHMUX.PEResult]];    use: CHProtocol.Results ¬      SELECT results.responseValue FROM        successfulReturn => ProcsUseResult[results.procedure],        ENDCASE => CHProtocol.procsUseError[results.responseValue];    SELECT use.code FROM      TRUE => { -- note WORD -- };      ENDCASE => {notes.noteDeadSpace[@results.code, SIZE[CH.Code]]; };    --position of nameFound between code and which causes grief.    SELECT use.nameFound FROM      TRUE => { -- note WORD -- };      ENDCASE => {        notes.noteDeadSpace[@results.nameFound, SIZE[CHProtocol.Bool]]; };    SELECT use.which FROM      TRUE => { -- note WORD -- };      ENDCASE => {        notes.noteDeadSpace[@results.which, SIZE[CH.ParameterGrouping]]; };    SELECT use.authenResults FROM      TRUE => {        notes.noteParameters[@results.authenticationResults, DescribeAuthResults];        };      ENDCASE => {        notes.noteDeadSpace[          @results.authenticationResults, SIZE[Auth.AuthenticationProblem]]};    SELECT use.bool FROM      TRUE => { -- note BOOLEAN WORD -- };      ENDCASE => {notes.noteDeadSpace[@results.bool, SIZE[CHProtocol.Bool]]; };    SELECT use.dn FROM      TRUE => {notes.noteDisjointData[@results.dn, NSName.DescribeNameRecord]; };      ENDCASE => {notes.noteDeadSpace[@results.dn, SIZE[CH.Name]]; };    SELECT use.hint FROM      TRUE => {        notes.noteDisjointData[@results.hint, NSName.DescribeNameRecord];        results.code ¬ CHProtocol.wrongServer;        -- NOTE that we set a code here since the protocol does not deliver it!        };      ENDCASE => {notes.noteDeadSpace[@results.hint, SIZE[CH.Name]]; };    SELECT use.rhs FROM      TRUE => {        DescribeBufferArea: Courier.Description =          BEGIN          rhs: CH.Buffer ¬ notes.noteSize[SIZE[CH.BufferArea] + results.rhsLength];          notes.noteDeadSpace[@rhs.maxlength, SIZE[CARDINAL]];  -- this never goes out on the wire          notes.noteDeadSpace[@rhs.length, SIZE[CARDINAL]];  -- this has been noted via "rhsLength"          -- the data portion now comes-in-from / goes-out-to the wire.          rhs.length ¬ results.rhsLength;          rhs.maxlength ¬ MAX[rhs.maxlength, rhs.length];          END;        -- note CARDINAL WORD value  in parm.rhsLength --        notes.noteDisjointData[@results.rhs, DescribeBufferArea];        };      ENDCASE => {        notes.noteDeadSpace[@results.rhsLength, SIZE[CARDINAL] + SIZE[CH.Buffer]];        };    SELECT use.properties FROM      TRUE => {        notes.noteArrayDescriptor[          @results.properties, SIZE[CH.PropertyID], CHProtocol.maxProperties];        FOR i: CARDINAL IN [0..LENGTH[results.properties]) DO          notes.noteLongCardinal[@results.properties[i]]; ENDLOOP};      ENDCASE => {        notes.noteDeadSpace[          @results.properties, SIZE[LONG DESCRIPTOR FOR ARRAY OF CH.PropertyID]];        };    SELECT use.chServerNSAddr FROM      TRUE => {        notes.noteParameters[@results.chServerNSAddr, NSAddr.DescribeAddress]; };      ENDCASE => {        notes.noteDeadSpace[@results.chServerNSAddr, SIZE[NSAddr.Address]]; };    notes.noteDeadSpace[      @results.chServerNSAddr + SIZE[NSAddr.Address],      CHMUX.slopAtEndOfResultRecord];  -- skip non-wire stuff    END;  DescribeNameChecksumAndGts: PUBLIC Courier.Description =    BEGIN    p: LONG POINTER TO CHStubExtras.NameChecksumAndGts ¬ notes.noteSize[      SIZE[CHStubExtras.NameChecksumAndGts]];    notes.noteDisjointData[@p.name, DescribeCHPartialName];    notes.noteParameters[@p.gTs, CHProtocol.DescribeTimestamp];    END;  --DescribeNameChecksumAndGts  DescribeChecksumAndGts: PUBLIC Courier.Description =    BEGIN    p: LONG POINTER TO CHStubExtras.NameChecksumAndGts ¬ notes.noteSize[      SIZE[CHStubExtras.ChecksumAndGts]];    notes.noteParameters[@p.gTs, CHProtocol.DescribeTimestamp];    END;  DescribeCHPartialName: PUBLIC Courier.Description =    BEGIN    use: CHProtocol.Results ¬ ProcsUseResult[CHStubExtras.enumerateChecksumAndGts];    name: CH.Name ¬ notes.noteSize[SIZE[CH.NameRecord]];    SELECT use.streamsOrgs FROM      TRUE => {notes.noteParameters[@name.org, NSString.DescribeString]; };      ENDCASE => {notes.noteDeadSpace[@name.org, SIZE[NSString.String]]; };    SELECT use.streamsDomains FROM      TRUE => {notes.noteParameters[@name.domain, NSString.DescribeString]; };      ENDCASE => {notes.noteDeadSpace[@name.domain, SIZE[NSString.String]]; };    SELECT use.streamsLocals FROM      TRUE => {notes.noteParameters[@name.local, NSString.DescribeString]; };      ENDCASE => {notes.noteDeadSpace[@name.local, SIZE[NSString.String]]; };    END;  endOfStreamNotice: CHProtocol.Bool = [value: TRUE];  notEndOfStreamNotice: CHProtocol.Bool = [value: FALSE];  <<**********************************************************************************>>  -- goes into CHStreamer  ActiveReadChecksumsAndGts: PUBLIC PROCEDURE [    sH: Stream.Handle, ignoreOrg, ignoreDomain, ignoreLocal: BOOLEAN,    pleaseSort: BOOLEAN] RETURNS [h: IncrementalSort.Handle] =    BEGIN    state: CHProtocol.Bool;    heap: UNCOUNTED ZONE ¬ NIL;        GetChecksumsAndGts: PROCEDURE =      BEGIN      nameAndData: CHStubExtras.NameChecksumAndGts;      nameAndDataPtr: LONG POINTER TO CHStubExtras.NameChecksumAndGts ¬        @nameAndData;      checkSumAndGtsPtr: CHStubExtras.ChecksumAndGtsPtr ¬ NIL;      blockWordLength: CARDINAL ¬ Stream.GetWord[sH];      s: TYPE = RECORD [PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte];      block: Environment.Block ¬ [        LOOPHOLE[heap.NEW[s [Environment.bytesPerWord * blockWordLength]]], 0,        Environment.bytesPerWord * blockWordLength];      FreeIt: PROCEDURE =        BEGIN        Courier.Free[[nameAndDataPtr, DescribeNameChecksumAndGts], heap];        heap.FREE[@block.blockPointer];        END;      {      ENABLE UNWIND => FreeIt[];      IF blockWordLength = 0 THEN {FreeIt[]; RETURN};      [] ¬ Stream.GetBlock[sH, block];      IF CH.DeserializeFromBlock[        [nameAndDataPtr, DescribeNameChecksumAndGts], heap, block] THEN        BEGIN        checkSumAndGtsPtr ¬ heap.NEW[CHStubExtras.ChecksumAndGts];        checkSumAndGtsPtr­ ¬ [nameAndDataPtr.checksum, nameAndDataPtr.gTs];        [] ¬ IncrementalSort.AddElement[	  h, nameAndDataPtr.name, checkSumAndGtsPtr];        END;      FreeIt[];      };      END;  --GetChecksumsAndGts        h ¬ IncrementalSort.MakeSorter[      NOT pleaseSort, ignoreOrg, ignoreDomain, ignoreLocal];    [heap] ¬ IncrementalSortExtras.GetHeapParameters[h];    IF CHStreams.BeginRead[sH] THEN RETURN;    {    ENABLE      UNWIND => IncrementalSort.Destroy[@h];    DO      state ¬ LOOPHOLE[Stream.GetWord[sH]];      SELECT state FROM        notEndOfStreamNotice, endOfStreamNotice => GetChecksumsAndGts[];        ENDCASE => ERROR Courier.Error[parameterInconsistency];      IF state = endOfStreamNotice THEN EXIT;      ENDLOOP;    CHStreams.EndRead[sH];  --the implementation of this does not make much sense    };  -- enable unwind    END;  --ActiveReadChecksumsAndGts  END.   LOG 25-Feb-85 17:21:43 - mweeks - created15-Apr-85 15:43:20 - mweeks - put LocalEnumerateChecksumAndGts in to CHReader   
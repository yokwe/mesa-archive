-- Copyright (C) 1983, 1984, 1985  by Xerox Corporation. All rights reserved. -- StubImpl.mesa-- Last edited by Stucke,  15-Apr-85 17:51:45DIRECTORY  Auth USING [    AuthenticationProblem, CheckOutCredentials, CheckOutNextVerifier,    ConversationHandle, Credentials, nullCredentials, nullVerifier, Refresh,    Verifier],  ByteBlt USING [StartIndexGreaterThanStopIndexPlusOne],  CH USING [    Buffer, Code, ConversationHandle, DeserializeFromRhs, Element, FreeRhs,    MakeRhs, maxBufferSize, maxDomainNameLength, maxLocalNameLength,    maxOrgNameLength, Name, NameRecord, NameStreamProc, PropertyID, ReturnCode],  CHMUX USING [    FreeResult, GetMUXHeap, GetCourierInfo, MakeCallParameter, MakeReturnParameter,    Parm, PEParm, PEResult, Result],  CHProtocol USING [    AlterPreferredVersion, CardinalToResponseValue, chSocket, CourierProcedures,    GetPreferredVersion, IsThereAnAlternateVersion, lastShiftedName,    operationRejectedUseCourier, Parm, Result, Results, shiftInName,    thisTryWasDown, TimestampPtr, Version, wrongServer],  CHStreams USING [ActiveReadNames, ActiveWriteNames, ReadBlocks],  CHStubExtras USING [    ChecksumAndGtsPtr, ActiveReadChecksumsAndGts, ChecksumAndGts,    DescribeNameChecksumAndGts, EachNameAndChecksumProc, enumerateChecksumAndGts,    GetCourierInfo, MakeCallParameter, MakeReturnParameter, NameChecksumAndGts,    ProcsUseParms, ProcsUseResult],  CHStubInternal USING [    AddrObject, AddToUnavailableDomains, Dispatcher, FindDomainAddr, FindOrgAddr,    InvalidateAddr, IsDomainAvailable, NoteBusyServer, NoteCHServer,    NoteLocalServer, ProcessHint],  CHStubInternalExtras USING [InvalidateWrongServerAddr, ProbeServerList],  CHSwitches USING [doStubDebug],  Courier USING [    ErrorCode, Free, Call, Create, Delete, Description, DeserializeParameters,    Error, Handle, Parameters, RemoteErrorSignalled, VersionMismatch],  ExpeditedCourier USING [Call, ResponseProc],  IncrementalSort USING [Destroy, DumpElements, EachNodeProc, Handle, nullHandle],  Inline USING [LongCOPY],  MemoryStream USING [Create, Destroy, IndexOutOfRange],  NSAddr USING [myHost],  NSDataStream USING [    Abort, Aborted, AnnounceStream, CancelTicket, Error, Handle, OperateOnSink,    OperateOnSource, Register, SetStreamTimeout, Sink, SinkStream, SourceStream,    Ticket],  NSName USING [Name, NameRecord, NameTooSmall, String, wildCardCharacter],  NSString USING [    AppendString, nullString, ScanForCharacter, String, StringFromMesaString,    WellFormed],  NSStringExtras USING [EquivalentNames, EquivalentStrings],  Process USING [MsecToTicks, Pause],  Runtime USING [IsBound],  Stream USING [Delete, Handle],  System USING [NetworkAddress, nullHostNumber];StubImpl: MONITOR  IMPORTS    Auth, ByteBlt, CH, CHProtocol, CHStubInternal, CHStubInternalExtras,    CHStubExtras, CHMUX, CHStreams, Courier, ExpeditedCourier, IncrementalSort,    Inline, MemoryStream, NSAddr, NSDataStream, NSName, NSString, NSStringExtras,    Process, Runtime, Stream  EXPORTS CH, CHProtocol, CHStubInternal, CHStubExtras, CHStubInternalExtras =  BEGIN  mayExpedite: BOOLEAN ¬ TRUE;  --used for turning off expedited calls  doDebug: BOOLEAN = CHSwitches.doStubDebug;  thisTryWasDown: CH.Code = CHProtocol.thisTryWasDown;  exchangeResortedToCourier, resortedToCourierDidNotWork: LONG CARDINAL ¬ 0;  localServer: CHStubInternal.Dispatcher ¬ NIL;  courierTimeout: CARDINAL = 300;  -- seconds  courierInconsistancyCount: CARDINAL ¬ 0;  verifierInvalidCount: CARDINAL ¬ 0;  verifierExpiredCount: CARDINAL ¬ 0;  verifierReusedCount: CARDINAL ¬ 0;  credentialsExpiredCount: CARDINAL ¬ 0;  wrongServerLoopCount: CARDINAL ¬ 0;  verifierInvalid: CH.Code = VAL[61];  verifierExpired: CH.Code = VAL[62];  verifierReused: CH.Code = VAL[63];  credentialsExpired: CH.Code = VAL[64];  BufferTooSmall: PUBLIC SIGNAL [offender: CH.Buffer, lengthNeeded: CARDINAL]    RETURNS [newBuffer: CH.Buffer] = CODE;  AuthenticationProblem: PUBLIC ERROR [why: Auth.AuthenticationProblem] = CODE;  muxHeap: UNCOUNTED ZONE ¬ CHMUX.GetMUXHeap[];  doProtocolValidationViaPXP: BOOLEAN ¬ FALSE;  -- for debugging purposes only  zeroMaxLengthNamesRecord: CH.NameRecord;  zeroMaxLengthNames: PUBLIC CH.Name ¬ @zeroMaxLengthNamesRecord;  CopyNames: PUBLIC PROCEDURE [    to, from: CH.Name, copyOrg, copyDomain, copyLocal: BOOLEAN ¬ TRUE] =    BEGIN    localFrom: CH.NameRecord = from­;    orgLen: CARDINAL = localFrom.org.length;    domainLen: CARDINAL = localFrom.domain.length;    localLen: CARDINAL = localFrom.local.length;    IF to = from THEN RETURN;    WHILE to # NIL      AND        (to.org.maxlength < orgLen OR to.domain.maxlength < domainLen          OR to.local.maxlength < localLen) DO      to ¬ SIGNAL NSName.NameTooSmall[to, orgLen, domainLen, localLen]; ENDLOOP;    IF to = NIL THEN RETURN;    IF copyOrg THEN      BEGIN      to.org.length ¬ 0;      to.org ¬ NSString.AppendString[to.org, localFrom.org];      END;    IF copyDomain THEN      BEGIN      to.domain.length ¬ 0;      to.domain ¬ NSString.AppendString[to.domain, localFrom.domain];      END;    IF copyLocal THEN      BEGIN      to.local.length ¬ 0;      to.local ¬ NSString.AppendString[to.local, localFrom.local];      END;    END;  CheckString: PUBLIC PROCEDURE [    s: NSString.String, maxLength: CARDINAL, wildcardOK: BOOLEAN]    RETURNS [ok: BOOLEAN] =    BEGIN    ok ¬ s.length <= maxLength AND NSString.WellFormed[s]      AND        (wildcardOK          OR NSString.ScanForCharacter[NSName.wildCardCharacter, s] = LAST[            CARDINAL]);    END;  CheckName: PUBLIC PROCEDURE [    name: CH.Name, wildOrgOK, wildDomainOK, wildLocalOK: BOOLEAN]    RETURNS [code: CH.Code ¬ illegalOrgName] =    -- given a three part CH name, this procedure verifies that     -- a) each subfield is the right length    -- b) each subfield is a valid NSString.String, and     -- c) that wildcards do not exist if not allowed.    BEGIN    IF NOT CheckString[name.org, CH.maxOrgNameLength, wildOrgOK] THEN RETURN;    IF NOT CheckString[name.domain, CH.maxDomainNameLength, wildDomainOK] THEN      RETURN[code ¬ illegalDomainName];    IF CheckString[name.local, CH.maxLocalNameLength, wildLocalOK] THEN code ¬ done    ELSE code ¬ illegalLocalName;    END;  ShiftTerminates: PUBLIC SIGNAL = CODE;  NameShift: PUBLIC PROCEDURE [source, destination: CH.Name] =    BEGIN    terminated: BOOLEAN = NSStringExtras.EquivalentNames[      source, CHProtocol.lastShiftedName];    destination.local ¬ source.domain;    destination.domain ¬ source.org;    destination.org ¬ CHProtocol.shiftInName;    IF terminated THEN SIGNAL ShiftTerminates;    END;-- NoteCHServer is implemented in the bootfile version of the stub if it exists.  <<NoteCHServer: PUBLIC ENTRY PROCEDURE [    notice: CHStubInternal.Dispatcher, localEnumerator: PROC [CH.NameStreamProc]] =    BEGIN    localServer ¬ notice;    CHStubInternal.NoteLocalServer[notice # NIL, localEnumerator];    END;>>  RegisterServer: PUBLIC ENTRY PROCEDURE [    notice: CHStubInternal.Dispatcher, localEnumerator: PROC [CH.NameStreamProc]] =    BEGIN    -- This enables a new stub to be loaded on top of a bootfile stub.    -- It calls into the bootfile stub, if it exists, forcing it to call its own    -- version of NoteLocalServer to keep the local domains consistent.    IF Runtime.IsBound[LOOPHOLE[CHStubInternal.NoteCHServer]] THEN      CHStubInternal.NoteCHServer[notice, localEnumerator];    localServer ¬ notice;    CHStubInternal.NoteLocalServer[notice # NIL, localEnumerator];    END;  ProcessResults: PROCEDURE [    conversation: CH.ConversationHandle, originalName: CH.Name,    na: System.NetworkAddress, rc: CH.ReturnCode, hint: CH.Name,    procedure: CHProtocol.CourierProcedures]    RETURNS [tryAgain: BOOLEAN, newRc: CH.ReturnCode] =    BEGIN    newRc ¬ rc;    SELECT rc.code FROM      CHProtocol.wrongServer =>        BEGIN        tryAgain ¬ CHStubInternal.ProcessHint[conversation, hint, na];        IF ~tryAgain THEN          BEGIN          newRc.code ¬ allDown;          SELECT procedure FROM            isMemberClosure, isInPropertyAccessList, isInDomainAccessList,              isInOrgAccessList =>              BEGIN              addressObject: CHStubInternal.AddrObject ¬ [NIL, na];              IF CHStubInternalExtras.ProbeServerList[@addressObject, NIL] THEN                RETURN;              END;            ENDCASE => NULL;          CHStubInternal.AddToUnavailableDomains[originalName];          END;        END;      rejectedTooBusy =>        SELECT procedure FROM          isMemberClosure, isInPropertyAccessList, isInDomainAccessList,            isInOrgAccessList => tryAgain ¬ FALSE;          ENDCASE => {tryAgain ¬ CHStubInternal.NoteBusyServer[originalName, na]};      thisTryWasDown =>        BEGIN        newRc ¬ [allDown, first];        --??? tryAgain ¬ CHStubInternal.NoteBusyServer[originalName, na];        CHStubInternal.InvalidateAddr[na];        tryAgain ¬ TRUE;        END;      ENDCASE => tryAgain ¬ FALSE;    END;  StubDispatcher: PUBLIC CHStubInternal.Dispatcher =    BEGIN    dummyOrg: STRING = [CH.maxOrgNameLength];    dummyDomain: STRING = [CH.maxDomainNameLength];    dummyLocal: STRING = [CH.maxLocalNameLength];    dummyNameRecord: CH.NameRecord ¬ [      NSString.StringFromMesaString[dummyOrg], NSString.StringFromMesaString[      dummyDomain], NSString.StringFromMesaString[dummyLocal]];    hint: CH.Name = @dummyNameRecord;    proc: CHProtocol.CourierProcedures ¬ p.procedure;    tryAgain: BOOLEAN ¬ TRUE;    na: System.NetworkAddress;    callTransportControl: PROCEDURE [      System.NetworkAddress, CHMUX.Parm, CHMUX.Result,      IncrementalSort.EachNodeProc];    verifierInvalidC: CARDINAL ¬ 0;    verifierExpiredC: CARDINAL ¬ 0;    verifierReusedC: CARDINAL ¬ 0;    credentialsExpiredC: CARDINAL ¬ 0;    wrongServerC: CARDINAL ¬ 0;    EqualStrings: PROC [s1, s2: NSString.String] RETURNS [BOOLEAN] = INLINE {      RETURN[NSStringExtras.EquivalentStrings[s1, s2]]};    callTransportControl ¬      SELECT TRUE FROM        mayExpedite AND CHStubExtras.ProcsUseParms[proc].maybeExpedited =>          PacketExchangeControl,        ENDCASE => CourierControl;    r.hint ¬ hint;    IF r.dn = NIL THEN r.dn ¬ hint;  -- we stuff distinguished names here if the user does not want them.    WHILE tryAgain DO      IF FindAddress[p, @na] THEN        DO          [p.cred, p.ver] ¬ GetCredentialsAndVerifier[            p.procedure, p.conversation, @na];          SELECT TRUE FROM            localServer # NIL              AND (na.host = System.nullHostNumber OR na.host = NSAddr.myHost) =>              localServer[p, r];            na.host = System.nullHostNumber =>              [r.code, r.which] ¬ CH.ReturnCode[allDown, first];            ENDCASE => callTransportControl[na, p, r, NIL];          SELECT r.code FROM            verifierInvalid =>              BEGIN              verifierInvalidCount ¬ verifierInvalidCount + 1;              IF verifierInvalidC > 0 THEN EXIT;              verifierInvalidC ¬ verifierInvalidC + 1;              END;            verifierExpired =>              BEGIN              verifierExpiredCount ¬ verifierExpiredCount + 1;              IF verifierExpiredC > 0 THEN EXIT;              verifierExpiredC ¬ verifierExpiredC + 1;              END;            verifierReused =>              BEGIN              verifierReusedCount ¬ verifierReusedCount + 1;              IF verifierReusedC > 0 THEN EXIT;              verifierReusedC ¬ verifierReusedC + 1;              END;            credentialsExpired =>              BEGIN              credentialsExpiredCount ¬ credentialsExpiredCount + 1;              IF credentialsExpiredC > 0 THEN EXIT              ELSE Auth.Refresh[p.conversation.conversation];              credentialsExpiredC ¬ credentialsExpiredC + 1;              END;	    CHProtocol.wrongServer =>	      BEGIN	      -- it should take only 2 process hints to find the correct server	      -- for a call.  any more than that may indicate that the stub is	      -- looping on a bad address in the cache for a domain.	      IF wrongServerC >= 2 THEN	        BEGIN		wrongServerLoopCount ¬ wrongServerLoopCount + 1;		IF EqualStrings[hint.org, CHProtocol.shiftInName]		  AND		  EqualStrings[hint.domain, CHProtocol.shiftInName]		  THEN 		    BEGIN		    CHStubInternalExtras.InvalidateWrongServerAddr[p.chName, na];		    wrongServerC ¬ 1;		    END;		END;	      wrongServerC ¬ wrongServerC + 1;	      EXIT;	      END;            ENDCASE => EXIT;          ENDLOOP      ELSE r.code ¬ allDown;      IF r.code = CHProtocol.operationRejectedUseCourier        AND callTransportControl = PacketExchangeControl THEN        BEGIN callTransportControl ¬ CourierControl; LOOP; END;      [tryAgain, [r.code, r.which]] ¬ ProcessResults[        p.conversation, p.chName, na, [r.code, r.which], hint, p.procedure];      ENDLOOP;    END;  --NEVER make a verifier with System.nullHostNumber.  GetCredentialsAndVerifier: PROC [    p: CHProtocol.CourierProcedures, c: CH.ConversationHandle,    na: LONG POINTER TO System.NetworkAddress]    RETURNS [Auth.Credentials, Auth.Verifier] = INLINE    BEGIN    IF p = enumerateYourDomains THEN      RETURN[Auth.nullCredentials, Auth.nullVerifier]    ELSE      RETURN[        Auth.CheckOutCredentials[c.conversation], Auth.CheckOutNextVerifier[          c.conversation,          IF na.host # System.nullHostNumber THEN na.host ELSE NSAddr.myHost]];    END;  FindAddress: PROC [p: CHProtocol.Parm, na: POINTER TO System.NetworkAddress]    RETURNS [avail: BOOLEAN] =    BEGIN    SELECT p.procedure FROM      retrieveOrgAccessList, addMemberToOrgAccessList,        deleteMemberFromOrgAccessList, isInOrgAccessList =>        BEGIN        na­ ¬ CHStubInternal.FindDomainAddr[CHProtocol.lastShiftedName];        avail ¬ TRUE;        END;      enumerateDomains, retrieveDomainAccessList, addMemberToDomainAccessList,        deleteMemberFromDomainAccessList, isInDomainAccessList =>        BEGIN        shiftedDomain: NSName.NameRecord ¬ [          org: CHProtocol.shiftInName, domain: p.chName.org,          local: NSString.nullString];        na­ ¬ CHStubInternal.FindOrgAddr[p.chName];        avail ¬ CHStubInternal.IsDomainAvailable[@shiftedDomain];        END;      ENDCASE =>        BEGIN        na­ ¬ CHStubInternal.FindDomainAddr[p.chName];        avail ¬ CHStubInternal.IsDomainAvailable[p.chName];        END;    END;  AllocateProperties: PROCEDURE [count: CARDINAL, heap: UNCOUNTED ZONE]    RETURNS [LONG DESCRIPTOR FOR ARRAY OF CH.PropertyID] =    BEGIN    sequenceRecord: TYPE = RECORD [SEQUENCE COMPUTED CARDINAL OF CH.PropertyID];    RETURN[DESCRIPTOR[heap.NEW[sequenceRecord [count]], count]];    END;  MoveLocalToUserArea: PROCEDURE [    localResult: CHMUX.Result, p: CHMUX.Parm, r: CHMUX.Result] =    BEGIN    ENABLE UNWIND => CHMUX.FreeResult[localResult];    [r.code, r.which] ¬      SELECT localResult.responseValue FROM        identifierRejected => CH.ReturnCode[          VAL[          ORD[CH.Code[credentialsInvalid]] + ORD[            localResult.authenticationResults]], localResult.which],        ENDCASE => CH.ReturnCode[localResult.code, localResult.which];    r.responseValue ¬ localResult.responseValue;    r.authenticationResults ¬ localResult.authenticationResults;    r.bool ¬ localResult.bool;    IF localResult.dn # NIL THEN CopyNames[to: r.dn, from: localResult.dn];    IF localResult.hint # NIL THEN CopyNames[to: r.hint, from: localResult.hint];    IF r.rhs # NIL AND r.code = done THEN      BEGIN      len: CARDINAL = localResult.rhs.length;      WHILE r.rhs.maxlength < len DO        r.rhs ¬ SIGNAL BufferTooSmall[r.rhs, len]; ENDLOOP;      Inline.LongCOPY[        from: @localResult.rhs.data, nwords: r.rhs.length ¬ len, to: @r.rhs.data];      END;    IF localResult.properties # DESCRIPTOR[LONG[NIL], 0] AND r.code = done THEN      BEGIN      len: CARDINAL ¬ LENGTH[localResult.properties];      r.properties ¬ AllocateProperties[len, p.heap];      len ¬ MIN[len, LENGTH[r.properties]];      Inline.LongCOPY[        from: BASE[localResult.properties], nwords: len * SIZE[CH.PropertyID],        to: BASE[r.properties]];      r.properties ¬ DESCRIPTOR[BASE[r.properties], len];      END;    CHMUX.FreeResult[localResult];    END;  transportTimeouts, dataStreamAbortsOnRead, dataStreamAbortsOnWrite: LONG    CARDINAL ¬ 0;  CourierControl: PROCEDURE [    addr: System.NetworkAddress, p: CHMUX.Parm, r: CHMUX.Result,    eachNameAndChecksum: IncrementalSort.EachNodeProc ¬ NIL] =    BEGIN    procedure: CHProtocol.CourierProcedures = p.procedure;    programNumber: LONG CARDINAL;    versionNumber: CARDINAL;    procedureNumber: CARDINAL;    error, tooMany, courierProblem, remoteErrorSignalled: BOOLEAN ¬ FALSE;    h: IncrementalSort.Handle ¬ IncrementalSort.nullHandle;    use: CHProtocol.Results = CHStubExtras.ProcsUseResult[procedure];    localResult: CHMUX.PEResult ¬ [procedure: procedure];    cH: Courier.Handle;    cp: Courier.Parameters = CHStubExtras.MakeCallParameter[p, TRUE];    cr: Courier.Parameters;    version: CHProtocol.Version;    vmr: BOOLEAN ¬ FALSE;  --versionMismatchRecovery    courierError: Courier.ErrorCode;    DoCourierCall: PROCEDURE [ticketPtr: LONG POINTER TO NSDataStream.Ticket] =      BEGIN      announceStr: PROCEDURE [cH: Courier.Handle] ¬        IF ticketPtr = NIL THEN NIL ELSE NSDataStream.AnnounceStream;      p.sourceOrSink ¬ ticketPtr;      IF doDebug AND doProtocolValidationViaPXP THEN        BEGIN        PacketExchangeControl[addr, p, r];        -- by setting break points elsewhere we can see the exact data        -- that goes out on the stream.        END;      [] ¬ Courier.Call[        cH, procedureNumber, cp, cr, CourierTimeout[p], FALSE, announceStr !        Courier.RemoteErrorSignalled =>          BEGIN          errorInDeserializingArguments: BOOLEAN ¬ FALSE;          -- this is nothing more than a return value in disguise!!          localResult.responseValue ¬ CHProtocol.CardinalToResponseValue[            errorNumber];          IF doDebug            AND localResult.responseValue NOT IN              [operationalError..identifierRejected] THEN ERROR;          arguments[            cr !            Courier.Error => {              CHStubInternal.InvalidateAddr[addr];              r.code ¬ thisTryWasDown;              error ¬ TRUE;              IF doDebug THEN ERROR;              errorInDeserializingArguments ¬ TRUE;              CONTINUE;              }];          IF NOT errorInDeserializingArguments THEN remoteErrorSignalled ¬ TRUE;          CONTINUE;          END;        Courier.VersionMismatch =>          BEGIN          IF CHProtocol.IsThereAnAlternateVersion[            programNumber, versionNumber, versionRange] THEN {            error ¬ vmr ¬ TRUE; CONTINUE};          CHStubInternal.InvalidateAddr[addr];          r.code ¬ thisTryWasDown;          error ¬ TRUE;          CONTINUE;          END;        Courier.Error =>          BEGIN          [r.code, r.which] ¬ CH.ReturnCode[allDown, first];          SELECT errorCode FROM            returnTimedOut, tooManyConnections => r.code ¬ rejectedTooBusy;            parameterInconsistency =>              BEGIN              courierInconsistancyCount ¬ courierInconsistancyCount + 1;              IF doDebug THEN ERROR;              END;            noAnswerOrBusy, noRouteToSystemElement, transportTimeout,              remoteSystemElementNotResponding, noCourierAtRemoteSite,              noSuchProcedureNumber, noSuchProgramNumber, protocolMismatch =>              BEGIN              courierError ¬ errorCode;              CHStubInternal.InvalidateAddr[addr];              r.code ¬ thisTryWasDown;              IF errorCode = transportTimeout THEN                transportTimeouts ¬ transportTimeouts + 1;              END;            invalidHandle => IF doDebug THEN ERROR;            ENDCASE => NULL;          error ¬ TRUE;          CONTINUE;          END];      END;    CourierTimeout: PROCEDURE [p: CHProtocol.Parm]      RETURNS [timeout: LONG CARDINAL] = INLINE      BEGIN      timeout ¬        SELECT p.procedure FROM          isMemberClosure, isInPropertyAccessList, isInDomainAccessList,            isInOrgAccessList => LAST[LONG CARDINAL],          ENDCASE => courierTimeout;      END;    UseSourceRemotely: PROCEDURE [theSource: NSDataStream.SourceStream] =      BEGIN      ticket: NSDataStream.Ticket ¬ NSDataStream.Register[        theSource, addr, cH, TRUE];      DoCourierCall[@ticket];      NSDataStream.CancelTicket[ticket, cH];      END;    UseSinkRemotely: PROCEDURE [theSink: NSDataStream.SinkStream] =      BEGIN      ticket: NSDataStream.Ticket ¬ NSDataStream.Register[theSink, addr, cH, TRUE];      DoCourierCall[@ticket];      NSDataStream.CancelTicket[ticket, cH];      END;    SourceReaderProcedure: PROCEDURE [theSource: NSDataStream.SourceStream] =      BEGIN      Doit: PROCEDURE =        BEGIN        NSDataStream.SetStreamTimeout[theSource, 75];  -- 75 seconds.        SELECT procedure FROM          dumpObject, newDumpObject =>            CHStreams.ReadBlocks[theSource, p.blkStreamProc];          CHStubExtras.enumerateChecksumAndGts =>            h ¬ CHStubExtras.ActiveReadChecksumsAndGts[              theSource, ~use.streamsOrgs, ~use.streamsDomains, ~use.streamsLocals,              FALSE];          ENDCASE =>            h ¬ CHStreams.ActiveReadNames[              theSource, ~use.streamsOrgs, ~use.streamsDomains, ~use.streamsLocals,              FALSE];        END;  --Doit      Doit[        !        NSDataStream.Aborted =>          BEGIN          dataStreamAbortsOnRead ¬ dataStreamAbortsOnRead + 1;          IF NOT error THEN {r.code ¬ wasUpNowDown; error ¬ TRUE};          -- if error, then rc was set in another process doing the courier call          CONTINUE;          END;        UNWIND => {NSDataStream.Abort[theSource]; Stream.Delete[theSource]}];      Stream.Delete[theSource ! NSDataStream.Aborted => CONTINUE];      END;    SinkWriterProcedure: PROCEDURE [theSink: NSDataStream.SinkStream] =      BEGIN      CHStreams.ActiveWriteNames[        theSink, p.newElementEnumerator, ~use.streamsOrgs, ~use.streamsDomains,        ~use.streamsLocals !        NSDataStream.Aborted =>          BEGIN          dataStreamAbortsOnWrite ¬ dataStreamAbortsOnWrite + 1;          IF NOT error THEN {r.code ¬ wasUpNowDown; error ¬ TRUE};          -- if error, then rc was set in another process doing the courier call          CONTINUE;          END; UNWIND => {NSDataStream.Abort[theSink]; Stream.Delete[theSink]}];      Stream.Delete[theSink ! NSDataStream.Aborted => CONTINUE];      END;      -- mainline code of CourierControl    r.bool ¬ [0, FALSE];    DO  --until no version mismatch      version ¬ CHProtocol.GetPreferredVersion[];      cr ¬ CHStubExtras.MakeReturnParameter[@localResult, FALSE, version];      [programNumber, versionNumber, procedureNumber] ¬        CHStubExtras.GetCourierInfo[procedure, version];      cH ¬ Courier.Create[        addr, programNumber, versionNumber, muxHeap, transactional];      BEGIN      ENABLE        BEGIN        NSDataStream.Error =>          IF errorCode = tooManyLocalConnections THEN {tooMany ¬ TRUE; CONTINUE};        Courier.Error => {courierProblem ¬ TRUE; CONTINUE};        UNWIND => Courier.Delete[cH];        END;      SELECT TRUE FROM        procedure = addGroup =>          NSDataStream.OperateOnSource[            source: [proc[SinkWriterProcedure]], operation: UseSourceRemotely];        CHStubExtras.ProcsUseParms[procedure].sourceOrSink =>          NSDataStream.OperateOnSink[            sink: [proc[SourceReaderProcedure]], operation: UseSinkRemotely];        ENDCASE => DoCourierCall[NIL];      IF NOT vmr THEN {Courier.Delete[cH]; EXIT};      CHProtocol.AlterPreferredVersion[version];      error ¬ vmr ¬ FALSE;      END;      Courier.Delete[cH];      ENDLOOP;    IF h # IncrementalSort.nullHandle THEN      BEGIN      ENABLE        UNWIND =>	  {IncrementalSort.Destroy[@h]; CHMUX.FreeResult[@localResult]};      IF procedure = CHStubExtras.enumerateChecksumAndGts THEN        IncrementalSort.DumpElements[          h: h, eachElement: NIL, userSpecifiedDefaults: p.chName,          dumpDataAlso: TRUE, eachElementWithData: eachNameAndChecksum]      ELSE        IncrementalSort.DumpElements[          h: h, eachElement: p.userNameStreamProc,userSpecifiedDefaults: p.chName];      IncrementalSort.Destroy[@h];      END;    IF (error OR tooMany OR courierProblem) AND NOT remoteErrorSignalled THEN      BEGIN      CHMUX.FreeResult[@localResult];      [r.code, r.which] ¬        SELECT TRUE FROM          tooMany => CH.ReturnCode[allDown, first],          courierProblem => CH.ReturnCode[badProtocol, first],          ENDCASE => CH.ReturnCode[r.code, r.which];      RETURN;      END;    MoveLocalToUserArea[@localResult, p, r];  -- this releases localResult storage    END;  PacketExchangeControl: PROCEDURE [    addr: System.NetworkAddress, p: CHMUX.Parm, r: CHMUX.Result,    proc: CHStubExtras.EachNameAndChecksumProc ¬ NIL] =    BEGIN    procedure: CHProtocol.CourierProcedures = p.procedure;    programNumber: LONG CARDINAL;    versionNumber: CARDINAL;    procedureNumber: CARDINAL;    localResult: CHMUX.PEResult ¬ [procedure: p.procedure];    cp: Courier.Parameters = CHMUX.MakeCallParameter[p, TRUE];    cr: Courier.Parameters;    noResponse: BOOLEAN ¬ TRUE;    version: CHProtocol.Version ¬ CHProtocol.GetPreferredVersion[];    ReceiveResults: ExpeditedCourier.ResponseProc =      -- tH, header, serializedResponse      BEGIN      sH: Stream.Handle;      noResponse ¬ continue ¬ FALSE;      WITH header.body SELECT FROM        return => localResult.responseValue ¬ successfulReturn;        abort =>          BEGIN          localResult.responseValue ¬ CHProtocol.CardinalToResponseValue[abort];          IF NOT            (localResult.responseValue IN [operationalError..identifierRejected])            THEN noResponse ¬ TRUE;          END;        ENDCASE => noResponse ¬ TRUE;      IF noResponse THEN RETURN;      sH ¬ MemoryStream.Create[serializedResponse];      cr ¬ CHMUX.MakeReturnParameter[@localResult, FALSE, version];      Courier.DeserializeParameters[        cr, sH, muxHeap !        UNWIND => BEGIN MemoryStream.Destroy[sH]; IF doDebug THEN ERROR; END];      MemoryStream.Destroy[sH];      END;    -- mainline code of PacketExchangeControl    addr.socket ¬ CHProtocol.chSocket;    r.bool ¬ [0, FALSE];    [programNumber, versionNumber, procedureNumber] ¬ CHMUX.GetCourierInfo[      procedure, version];    ExpeditedCourier.Call[      programNumber, versionNumber, procedureNumber, cp, addr, ReceiveResults !      Courier.Error =>        IF NOT doDebug THEN {          r.code ¬ CHProtocol.operationRejectedUseCourier;          noResponse ¬ FALSE;          CONTINUE};      MemoryStream.IndexOutOfRange, ByteBlt.StartIndexGreaterThanStopIndexPlusOne        => {        r.code ¬ CHProtocol.operationRejectedUseCourier;        noResponse ¬ FALSE;        CONTINUE}];    SELECT TRUE FROM      r.code = CHProtocol.operationRejectedUseCourier => NULL;      noResponse =>        BEGIN        exchangeResortedToCourier ¬ exchangeResortedToCourier + 1;        p.ver ¬ Auth.CheckOutNextVerifier[          p.conversation.conversation,          IF addr.host # System.nullHostNumber THEN addr.host ELSE NSAddr.myHost];        CourierControl[addr, p, r];        SELECT r.code FROM          allDown, rejectedTooBusy, badProtocol, wasUpNowDown =>            resortedToCourierDidNotWork ¬ resortedToCourierDidNotWork + 1;          ENDCASE => NULL;        END;      ENDCASE => MoveLocalToUserArea[@localResult, p, r];    END;  EnumerateYourDomains: PUBLIC PROCEDURE [    server: System.NetworkAddress, eachName: CH.NameStreamProc]    RETURNS [rc: CH.ReturnCode] =    BEGIN    parm: CHMUX.PEParm ¬ [      procedure: enumerateYourDomains, userNameStreamProc: eachName];    result: CHMUX.PEResult ¬ [procedure: enumerateYourDomains];    CommonDirectedCaller[@server, @parm, @result];    RETURN[[result.code, result.which]];    END;  EnumerateChecksumAndGts: PUBLIC PROCEDURE [    conversation: CH.ConversationHandle, domainName: CH.Name,    eachChecksumAndGts: CHStubExtras.EachNameAndChecksumProc]    RETURNS [rc: CH.ReturnCode] =    BEGIN    << This has to be here for the local case - CHServerDispatcher expects       a blkStreamProc to be passed in >>    LocalChecksumAndGts: PROCEDURE [p: LONG POINTER, len: CARDINAL] =      BEGIN      remoteData: CHStubExtras.NameChecksumAndGts;      clientData: CHStubExtras.ChecksumAndGts;      rhs: CH.Buffer ¬ CH.MakeRhs[CH.maxBufferSize, muxHeap];      FreeIt: PROCEDURE =        BEGIN        Courier.Free[          [@remoteData, CHStubExtras.DescribeNameChecksumAndGts], muxHeap];        CH.FreeRhs[rhs, muxHeap];        END;      {      ENABLE UNWIND => FreeIt[];      rhs.maxlength ¬ rhs.length ¬ len;      Inline.LongCOPY[p, len, LOOPHOLE[@rhs.data]];      IF CH.DeserializeFromRhs[        [@remoteData, CHStubExtras.DescribeNameChecksumAndGts], muxHeap, rhs] THEN        BEGIN        clientData.checksum ¬ remoteData.checksum;        clientData.gTs ¬ remoteData.gTs;        eachChecksumAndGts[remoteData.name, @clientData];        END;      FreeIt[];      };      END;    RemoteChecksumAndGts: IncrementalSort.EachNodeProc =      BEGIN      remotePtr: CHStubExtras.ChecksumAndGtsPtr ¬ userData;      eachChecksumAndGts[currentName, remotePtr ];      END;    parm: CHMUX.PEParm ¬ [      procedure: CHStubExtras.enumerateChecksumAndGts, chName: domainName,      conversation: conversation];    result: CHMUX.PEResult ¬ [procedure: CHStubExtras.enumerateChecksumAndGts];    IF conversation.address.host = NSAddr.myHost THEN      parm.blkStreamProc ¬ LocalChecksumAndGts;    CommonDirectedCaller[      conversation.address, @parm, @result, RemoteChecksumAndGts];    rc ¬ [result.code, result.which];    END;  GetDomainSize: PUBLIC PROCEDURE [    conversation: CH.ConversationHandle, domainName: CH.Name]    RETURNS [rc: CH.ReturnCode, size: LONG CARDINAL] =    BEGIN    succeeded: BOOLEAN ¬ TRUE;    parm: CHMUX.PEParm ¬ [      chName: domainName, procedure: getDomainSize, conversation: conversation];    SizeDescribe: Courier.Description =      BEGIN      sizePointer: LONG POINTER TO LONG CARDINAL ¬ notes.noteSize[        SIZE[LONG CARDINAL]];      notes.noteLongCardinal[sizePointer];      END;    sizeBuffer: CH.Buffer ¬ CH.MakeRhs[4, muxHeap];    result: CHMUX.PEResult ¬ [procedure: getDomainSize, rhs: sizeBuffer];    CommonDispatcher[      conversation.address, @parm, @result !      UNWIND => CH.FreeRhs[sizeBuffer, muxHeap]];    succeeded ¬ CH.DeserializeFromRhs[[@size, SizeDescribe], muxHeap, result.rhs];    IF NOT succeeded THEN size ¬ 0;    CH.FreeRhs[sizeBuffer, muxHeap];    rc ¬ [result.code, result.which];    END;  WhoAreYou: PUBLIC PROCEDURE [    conversation: CH.ConversationHandle, rhs: CH.Buffer, distingName: CH.Name]    RETURNS [rc: CH.ReturnCode] =    BEGIN    parm: CHMUX.PEParm ¬ [procedure: whatIsYourName, conversation: conversation];    result: CHMUX.PEResult ¬ [      procedure: whatIsYourName, dn: distingName, rhs: rhs];    CommonDirectedCaller[conversation.address, @parm, @result];    RETURN[[result.code, result.which]];    END;  RemoteIHaveYourName: PUBLIC PROCEDURE [    conversation: CH.ConversationHandle, serverName: CH.Name] =    BEGIN    parm: CHMUX.PEParm ¬ [      procedure: iHaveYourName, chName: serverName, conversation: conversation];    result: CHMUX.PEResult ¬ [procedure: iHaveYourName];    CommonDirectedCaller[conversation.address, @parm, @result];    END;  RemoteNewDumpObject: PUBLIC PROCEDURE [    conversation: CH.ConversationHandle, objectName: CH.Name,    myServerName: CH.Name, eachBlock: PROCEDURE [LONG POINTER, CARDINAL],    distingName: CH.Name] RETURNS [rc: CH.ReturnCode] =    BEGIN    parm: CHMUX.PEParm ¬ [      procedure: newDumpObject, chName: objectName, blkStreamProc: eachBlock,      element: myServerName, conversation: conversation];    result: CHMUX.PEResult ¬ [procedure: newDumpObject, dn: distingName];    CommonDirectedCaller[conversation.address, @parm, @result];    RETURN[[result.code, result.which]];    END;  CompareObject: PUBLIC PROCEDURE [    conversation: CH.ConversationHandle, objectName: CH.Name,    myServerName: CH.Name, myChecksum: CARDINAL, myGts: CHProtocol.TimestampPtr]    RETURNS [rc: CH.ReturnCode, theObjectShouldBeSnarfed: BOOLEAN] =    BEGIN    parm: CHMUX.PEParm ¬ [      procedure: checkObject, chName: objectName, element: myServerName,      gts: myGts, checksum: myChecksum, conversation: conversation];    result: CHMUX.PEResult ¬ [procedure: checkObject];    CommonDirectedCaller[conversation.address, @parm, @result];    rc ¬ [result.code, result.which];    theObjectShouldBeSnarfed ¬ result.bool.value;    END;  CommonDispatcher: PUBLIC PROCEDURE [    server: LONG POINTER TO System.NetworkAddress, p: CHProtocol.Parm,    r: CHProtocol.Result] =    BEGIN    IF server = NIL OR server.host = System.nullHostNumber THEN      StubDispatcher[p: p, r: r]    ELSE CommonDirectedCaller[server: server, p: p, r: r];    END;  CommonDirectedCaller: PRIVATE PROCEDURE [    server: LONG POINTER TO System.NetworkAddress, p: CHProtocol.Parm,    r: CHProtocol.Result,    nameAndChecksumProc: IncrementalSort.EachNodeProc ¬ NIL] =    BEGIN    dummyOrg: STRING = [CH.maxOrgNameLength];    dummyDomain: STRING = [CH.maxDomainNameLength];    dummyLocal: STRING = [CH.maxLocalNameLength];    dummyNameRecord: CH.NameRecord ¬ [      NSString.StringFromMesaString[dummyOrg], NSString.StringFromMesaString[      dummyDomain], NSString.StringFromMesaString[dummyLocal]];    hint: CH.Name = @dummyNameRecord;    verifierInvalidC: CARDINAL ¬ 0;    verifierExpiredC: CARDINAL ¬ 0;    verifierReusedC: CARDINAL ¬ 0;    credentialsExpiredC: CARDINAL ¬ 0;    IF doDebug AND p.procedure # r.procedure THEN ERROR;    r.hint ¬ hint;    IF r.dn = NIL THEN r.dn ¬ hint;    DO      [p.cred, p.ver] ¬ GetCredentialsAndVerifier[        p.procedure, p.conversation, server];      IF server.host = NSAddr.myHost AND localServer # NIL THEN localServer[p, r]      ELSE CourierControl[server­, p, r, nameAndChecksumProc];      SELECT r.code FROM        verifierInvalid =>          BEGIN          verifierInvalidCount ¬ verifierInvalidCount + 1;          IF verifierInvalidC > 0 THEN EXIT;          verifierInvalidC ¬ verifierInvalidC + 1;          END;        verifierExpired =>          BEGIN          verifierExpiredCount ¬ verifierExpiredCount + 1;          IF verifierExpiredC > 0 THEN EXIT;          verifierExpiredC ¬ verifierExpiredC + 1;          END;        verifierReused =>          BEGIN          verifierReusedCount ¬ verifierReusedCount + 1;          IF verifierReusedC > 0 THEN EXIT;          verifierReusedC ¬ verifierReusedC + 1;          END;        credentialsExpired =>          BEGIN          credentialsExpiredCount ¬ credentialsExpiredCount + 1;          IF credentialsExpiredC > 0 THEN EXIT          ELSE Auth.Refresh[p.conversation.conversation];          credentialsExpiredC ¬ credentialsExpiredC + 1;          END;        ENDCASE => EXIT;      ENDLOOP;    END;  PokeTheStub: PUBLIC PROCEDURE =    BEGIN    Process.Pause[Process.MsecToTicks[100]];    <<Now, about this pause. The old impl took 96 msec longer than the current one without the pause. Without the pause, queries shortly after the stub has been started fail with rc allDown. Adding the pause caused the problem to go away. Apparently, the delay is just enough so that the first recipient may (usually) respond before FindDomainAddr is called.>>    [] ¬ CHStubInternal.FindDomainAddr[zeroMaxLengthNames];    END;  END..LOG 5-Jan-83 17:48:56 - BLyon 5-Oct-83 12:03:36 - BLyon11-Oct-83 19:18:03 - Read  1-Dec-83 18:42:59 - Gealy - Convert to 8.0 CH and Auth. 17-Jan-84 19:26:05 - Gealy - Reimplemented PokeTheStub.  8-Feb-84  1:31:48 - Gealy - Support multiple CH2 protocol versions.10-Feb-84 16:06:24 - read - changed parameter to IncrementalSort.Destroy  1-Mar-84  1:52:01 - Gealy - supply address to CheckOutNextVerifier 11-Apr-84 13:28:21 - Gealy - use local server if nullAddress.  Account for remote error identifierRejected.28-Apr-84 22:19:37 - read - added GetDomainSize15-May-84 21:50:53 - Gealy - never brew verifiers with nullAddress17-May-84 23:27:54 - read - fixed noteSize problem with GetDomainSize20-May-84 22:15:20 - read - fixed verifierReused problem when PacketExchange fails 7-Jun-84 11:50:38 - read - added calls to AddToUnavailableDomains and DomainIsAvailable12-Jun-84 16:16:02 - read - stub tries again on Courier.Error[transportTimeout] and transportTimeout and NSDataStream.Aborted are counted.13-Jun-84 22:52:15 - read - fixed leak of a Courier.Handle14-Jun-84 22:12:57 - Gealy - Use optimised string ops.17-Jun-84 15:47:58 - read - folded CHStubInternalExtras into CHStubInternal19-Jun-84  0:48:28 - read - when allDown is returned on any form of IsMemberClosure, the domain is not added to the cache of unavailable domains.19-Jun-84 11:56:06 - read - increased courierTimeout for isMemberClosure ops.19-Jun-84 19:24:54 - read - added remoteErrorSignalled to CourierControl and added call to ProbeDomain in ProcessResults. 9-Jul-84 21:26:01 - read - increased courier timeout for all procedures 4-Aug-84 15:18:11 - read - tryAgain ¬ FALSE if rc is rejectedTooBusy on any IsMemberClosure30-Aug-84 13:15:53 - Gealy - Invalidate address if thisTryWasDown. Get proper  address if access control procedure. Infinite Courier.Call timeout if  IsMemberClosure op.11-Mar-85  8:45:07  - Mweeks - Added routines to allow changes in the server  to server protocol(EnumerateChecksumAndGts) without changing CHMUX or CHProtocol 2-Apr-85  9:18:47 - Mweeks - folded in Gillies hack to use a old and new stub  at the same time 8-Apr-85 15:59:13 - Stucke - StubDispatcher now looks for wrongServer return code to try to prevent stub looping.15-Apr-85 17:40:58 - Stucke - Added RegisterServer proc which is a clone of NoteCHServer, almost.  This enables us to load a new stub on top of an existing stub, ie. in the bootfile.
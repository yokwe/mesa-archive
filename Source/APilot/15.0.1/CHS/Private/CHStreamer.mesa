-- Copyright (C) 1984  by Xerox Corporation. All rights reserved. -- CHStreamer.mesa -- last edit by read,  10-Feb-84 16:07:55DIRECTORY  CH USING [EnumerateNewGroupElements, Name, NameRecord, NameStreamProc],  CHMUX USING [GetMUXHeap],  CHProtocol USING [Bool],  CHStreams USING [],  Courier USING [Description, DeserializeParameters, Error, Free, SerializeParameters],  Environment USING [Byte, bytesPerWord],  IncrementalSort USING [AddElement, Destroy, Handle, MakeSorter],  NSString USING [DescribeString, nullString],  Stream USING [CompletionCode, GetBlock, GetWord, Handle, PutBlock, PutWord, SendNow];CHStreamer: PROGRAM  IMPORTS CHMUX, Courier, IncrementalSort, NSString, Stream   EXPORTS CHStreams=  BEGIN    endOfStreamNotice: CHProtocol.Bool = [value: TRUE];  notEndOfStreamNotice: CHProtocol.Bool = [value: FALSE];  heap: UNCOUNTED ZONE ¬ CHMUX.GetMUXHeap[];    BeginRead: PUBLIC PROCEDURE [sH: Stream.Handle] RETURNS [finished: BOOLEAN ¬ FALSE] =    BEGIN    END;    ReadBlocks: PUBLIC PROCEDURE [sH: Stream.Handle, eachBlk: PROCEDURE [p: LONG POINTER, len: CARDINAL]] =    BEGIN    state: CHProtocol.Bool;        GetABlock: PROCEDURE =      BEGIN      blockWordLength: CARDINAL ¬ Stream.GetWord[sH];      p: LONG POINTER TO PACKED ARRAY [0..0) OF Environment.Byte;      s: TYPE = RECORD[PACKED SEQUENCE COMPUTED CARDINAL OF Environment.Byte];      IF blockWordLength=0 THEN RETURN;      p ¬ LOOPHOLE[heap.NEW[s[Environment.bytesPerWord*blockWordLength]]];      [] ¬ Stream.GetBlock[sH, [p, 0, Environment.bytesPerWord*blockWordLength]];      eachBlk[p, blockWordLength !        UNWIND => heap.FREE[@p] ];      heap.FREE[@p];      END;        DO      state ¬ LOOPHOLE[Stream.GetWord[sH]];      SELECT state FROM	notEndOfStreamNotice, endOfStreamNotice => GetABlock[];	ENDCASE => ERROR Courier.Error[parameterInconsistency];      IF state=endOfStreamNotice THEN EXIT;      ENDLOOP;    EndRead[sH];    END;    ReadCHName: PUBLIC PROCEDURE [sH: Stream.Handle, target: CH.Name, ignoreOrg, ignoreDomain, ignoreLocal: BOOLEAN] =    BEGIN    IF ignoreOrg      THEN target.org ¬ NSString.nullString      ELSE Courier.DeserializeParameters[[@target.org, NSString.DescribeString], sH, heap];    IF ignoreDomain       THEN target.domain ¬ NSString.nullString      ELSE Courier.DeserializeParameters[[@target.domain, NSString.DescribeString], sH, heap];    IF ignoreLocal      THEN target.local ¬ NSString.nullString      ELSE Courier.DeserializeParameters[[@target.local, NSString.DescribeString], sH, heap];    END;    FreeName: PUBLIC PROCEDURE [name: CH.Name] =    BEGIN    Courier.Free[[@name.org, NSString.DescribeString], heap];    Courier.Free[[@name.domain, NSString.DescribeString], heap];    Courier.Free[[@name.local, NSString.DescribeString], heap];    name.org ¬ name.domain ¬ name.local ¬ NSString.nullString;    END;    ActiveReadNames: PUBLIC PROCEDURE [sH: Stream.Handle, ignoreOrg, ignoreDomain, ignoreLocal: BOOLEAN, pleaseSort: BOOLEAN] RETURNS [h: IncrementalSort.Handle]=    BEGIN    state: CHProtocol.Bool;    localNameRecord: CH.NameRecord;    localName: CH.Name = @localNameRecord;        GetASequnceOfNames: PROCEDURE =      BEGIN      nameSequenceLength: CARDINAL ¬ Stream.GetWord[sH];      FOR i: CARDINAL IN [0 .. nameSequenceLength) DO        ReadCHName[sH, localName, ignoreOrg, ignoreDomain, ignoreLocal];	[] ¬ IncrementalSort.AddElement[h, localName];	FreeName[localName];        ENDLOOP;      END;          h ¬ IncrementalSort.MakeSorter[NOT pleaseSort, ignoreOrg, ignoreDomain, ignoreLocal];    IF BeginRead[sH] THEN RETURN;    {  ENABLE UNWIND => { IncrementalSort.Destroy[@h] };    DO      state ¬ LOOPHOLE[Stream.GetWord[sH]];      SELECT state FROM	notEndOfStreamNotice, endOfStreamNotice => GetASequnceOfNames[];	ENDCASE => ERROR Courier.Error[parameterInconsistency];      IF state=endOfStreamNotice THEN EXIT;      ENDLOOP;    EndRead[sH];    };  -- enable unwind    END;    EndRead: PUBLIC PROCEDURE [sH: Stream.Handle] =    BEGIN    END;    BeginWrite: PUBLIC PROCEDURE [sH: Stream.Handle] =    BEGIN    END;    WriteBlock: PUBLIC PROCEDURE [sH: Stream.Handle, p: LONG POINTER, wordLength: CARDINAL] =    BEGIN    Stream.PutWord[sH, LOOPHOLE[notEndOfStreamNotice]];    Stream.PutWord[sH, wordLength];    Stream.PutBlock[sH, [LOOPHOLE[p], 0, Environment.bytesPerWord*wordLength]];    END;    WriteCHName: PUBLIC PROCEDURE [sH: Stream.Handle, name: CH.Name, ignoreOrg, ignoreDomain, ignoreLocal: BOOLEAN] =    BEGIN    sequenceOfOne: CARDINAL = 1;    Stream.PutWord[sH, LOOPHOLE[notEndOfStreamNotice]];    Stream.PutWord[sH, sequenceOfOne];    IF NOT ignoreOrg THEN Courier.SerializeParameters[[@name.org, NSString.DescribeString], sH];    IF NOT ignoreDomain THEN Courier.SerializeParameters[[@name.domain, NSString.DescribeString], sH];    IF NOT ignoreLocal THEN Courier.SerializeParameters[[@name.local, NSString.DescribeString], sH];    END;     ActiveWriteNames: PUBLIC PROCEDURE [sH: Stream.Handle, elementEnumerator: CH.EnumerateNewGroupElements, ignoreOrg, ignoreDomain, ignoreLocal: BOOLEAN] =    BEGIN        EachName: CH.NameStreamProc =      BEGIN      WriteCHName[sH, currentName, ignoreOrg, ignoreDomain, ignoreLocal];      END;          BeginWrite[sH];    elementEnumerator[EachName];    EndWrite[sH, FALSE];    END;    EndWrite: PUBLIC PROCEDURE [sH: Stream.Handle, aborted: BOOLEAN] =    BEGIN    zeroSequence: CARDINAL = 0;    Stream.PutWord[sH, LOOPHOLE[endOfStreamNotice]];    Stream.PutWord[sH, zeroSequence];    Stream.SendNow[sH, FALSE];    END;    END..   LOG13-Dec-82  9:44:34, BLyon, created file 10-Feb-84 16:08:12, read, changed parameter to IncrementalSort.Destroy 
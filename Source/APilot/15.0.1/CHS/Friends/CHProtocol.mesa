-- Copyright (C) 1981, 1984  by Xerox Corporation. All rights reserved. -- CHProtocol.mesa-- Last edited by read,  17-Jun-84 15:38:11-- Last edited by AOF,  14-Dec-84 10:42:04-- This interface describes how the Stub and Server communicate to each other-- via Courier, PacketExchange, and direct MESA calling.DIRECTORY  Auth USING [    AuthenticationProblem, Credentials, nullCredentials, nullVerifier, Verifier],  CH USING [    Buffer, Code, ConversationHandle, EnumerateNewGroupElements, Name,    NameStreamProc, ReturnCode, notUsable, ParameterGrouping, Properties,    PropertyID],  CHPIDs USING [all],  Courier USING [Description, VersionRange],  MoreCH USING [ACLFlavor],  NSAddr USING [Address],  NSDataStream USING [Ticket],  NSString USING [String],  NSConstants USING [newClearinghouseSocket],  PacketExchange USING [ExchangeClientType],  System USING [GreenwichMeanTime, HostNumber, SocketNumber];CHProtocol: DEFINITIONS =  BEGIN  shiftInName: NSString.String;  lastShiftedName: CH.Name;  genericCHSName: CH.Name;  genericCHSPassword: NSString.String;  NameShift: PROCEDURE [source, destination: CH.Name];  -- Can SIGNAL ShiftTerminates.  -- destination has has pointers to some fields of source and a pointer to shiftInName (therefore, do not modify or free).  ShiftTerminates: SIGNAL;  -- resumable;  destination is identical to source when this is resumed.  --Return Codes that are turned into errors  operationRejectedUseCourier: CH.Code = LOOPHOLE[4];  wrongServer: CH.Code = LOOPHOLE[50];  identifierRejected: CH.Code = LOOPHOLE[60];  thisTryWasDown: CH.Code = LOOPHOLE[80];  maxDistanceToNearByNets: CARDINAL = 3;  -- nets up to 3 hops away are "nearby"  maxDistanceToAnyNets: CARDINAL = 6;  -- expanding ring broadcast will never try for any net over 6 hops away.  maxProperties: CARDINAL = 250;  -- the maximum number of user visible properties that a name may have.  maxAddresses: CARDINAL = 40;  PropertyType: TYPE = {Value, Group};  -- for rhs's.  TimestampPtr: TYPE = LONG POINTER TO Timestamp;  Timestamp: TYPE = MACHINE DEPENDENT RECORD [    gmt: System.GreenwichMeanTime, host: System.HostNumber];  WireReturnCode: TYPE = CH.ReturnCode;  DescribeTimestamp: Courier.Description;  -- Courier network protocol constants  ch2ProgramsNumber: LONG CARDINAL = 2;  ch2HighVersionNumber: CARDINAL;  ch2LowVersionNumber: CARDINAL;  actualHighCh2VersionNumber: CARDINAL = 3;  actualLowCh2VersionNumber: CARDINAL = 2;  chAccessControlProgramsNumber: LONG CARDINAL = 127;  chAccessControlVersionNumber: CARDINAL;  actualChAccessControlVersionNumber: CARDINAL = 1;  chsToChsProgramsNumber: LONG CARDINAL = 16;  chsToChsVersionNumber: CARDINAL;  actualChsToChsVersionNumber: CARDINAL = 1;  --protocol compatibility procedures.    Version: TYPE = {low, high};    <<low = Services 5.0, 6.0, 7.0; high = Services 8.0 and beyond.  High version fixes the GetPropeties problem.>>    AlterPreferredVersion: PROCEDURE[undesirable: Version];  <<Call this when someone determines that we should use the other protocol. undesirableVersion is needed so that concurrent processes do not inadvertently alter the version twice. It would be unusual to call this if IsThereAnAlternateVersion returned FALSE.>>      GetAlternateVersion: PROCEDURE[version: Version] RETURNS[Version];  GetPreferredVersion: PROCEDURE RETURNS[version: Version];  GetVersion: PROCEDURE[programNumber: LONG CARDINAL, versionNumber: CARDINAL]    RETURNS[version: Version];  IsThereAnAlternateVersion: PROCEDURE[    programNumber: LONG CARDINAL, versionNumber: CARDINAL,    acceptable: Courier.VersionRange]    RETURNS[BOOLEAN];  --Are there other versions of this protocol that the stub will support?  -- this record is the first piece of data in a Packet Exchange Block  -- this is followed by serialized data  ResponseValue: TYPE = MACHINE DEPENDENT{    successfulReturn(0), operationalError(1), namingError(2), propertyError(3),    updateError(4), wrongServer(5), identifierRejected(6)};  CardinalToResponseValue: PROCEDURE [c: CARDINAL] RETURNS [r: ResponseValue] =    INLINE    BEGIN    r ¬      SELECT c FROM        0 => successfulReturn,        1 => operationalError,        2 => namingError,        3 => propertyError,        4 => updateError,        5 => wrongServer,        6 => identifierRejected,        ENDCASE => successfulReturn;    END;  -- Procedure numbers  CourierProceduresToCardinals: PROCEDURE [cp: CourierProcedures]    RETURNS [CARDINAL] = INLINE {RETURN[LOOPHOLE[cp, CARDINAL]]};  CardinalsToCourierProcedures: PROCEDURE [c: CARDINAL]    RETURNS [p: CourierProcedures] = INLINE {p ¬ LOOPHOLE[c, CourierProcedures]};  CourierProcedures: TYPE = MACHINE DEPENDENT{    chServerAddrProbe(0), enumerateYourDomains(1), addName(2), deleteName(3),    lookupDistinguishedName(4), enumerateOrganizations(5), enumerateDomains(6),    enumerate(7), enumerateAliases(8), enumerateAliasesOfAName(9), addAlias(10),    deleteAlias(11), addGroup(12), addValue(13), deleteProperty(14),    enumerateProperties(15), lookupValue(16), changeValue(17), lookupGroup(18),    addMember(19), addSelf(20), deleteMember(21), deleteSelf(22),    isMemberClosure(23),    -- server to server procedures    dumpObject(24), enumerateObjects(25), whatIsYourName(26), iHaveYourName(27),    newDumpObject(28), checkObject(29),    -- access control procedures    retrievePropertyAccessList(30), addMemberToPropertyAccessList(31),    deleteMemberFromPropertyAccessList(32), isInPropertyAccessList(33),    retrieveDomainAccessList(34), addMemberToDomainAccessList(35),    deleteMemberFromDomainAccessList(36), isInDomainAccessList(37),    retrieveOrgAccessList(38), addMemberToOrgAccessList(39),    deleteMemberFromOrgAccessList(40), isInOrgAccessList(41),    getDomainSize(42)};  ACLFlavor: TYPE = MoreCH.ACLFlavor;  -- Packet Exchanger  chSocket: System.SocketNumber = NSConstants.newClearinghouseSocket;  chPacketType: PacketExchange.ExchangeClientType = clearinghouseService;  Bool: TYPE = MACHINE DEPENDENT RECORD [    filler: [0..77777B] ¬ 0, value: BOOLEAN ¬ FALSE];  -- Linkage between stub and server that run on the same machine  Parm: TYPE = LONG POINTER TO PEParm;  PEParm: TYPE = MACHINE DEPENDENT RECORD [  -- any Courier Proc or Packet Exchanger supplies these parameters    chName: CH.Name ¬ NIL,    pn: CH.PropertyID ¬ CHPIDs.all,    aclist: ACLFlavor ¬ value,    pn2: CH.PropertyID ¬ CH.notUsable,    element: CH.Name ¬ NIL,    rhsLength: CARDINAL ¬ 0,    rhs: CH.Buffer ¬ NIL,    sourceOrSink: LONG POINTER TO NSDataStream.Ticket ¬ NIL,    gts: TimestampPtr ¬ NIL,    checksum: CARDINAL ¬ 0,    cred: Auth.Credentials ¬ Auth.nullCredentials,    ver: Auth.Verifier ¬ Auth.nullVerifier,    -- the following fields never get out on the wire    filler1: [0..1777B] ¬ 0,    procedure: CourierProcedures ¬ chServerAddrProbe,    heap: UNCOUNTED ZONE ¬ NIL,    conversation: CH.ConversationHandle ¬ [NIL, NIL],    userNameStreamProc: CH.NameStreamProc ¬ NIL,    newElementEnumerator: CH.EnumerateNewGroupElements ¬ NIL,    blkStreamProc: PROCEDURE [LONG POINTER, CARDINAL] ¬ NIL];  -- we need to compute the size of the fields that never go out on the wire  -- so Courier Description routines can skip over these fields.  dummyP: PRIVATE POINTER TO PEParm = NIL;  slopAtEndOfParmRecord: CARDINAL =    SIZE[PEParm] - LOOPHOLE[@dummyP.ver + SIZE[Auth.Verifier], CARDINAL];  Result: TYPE = LONG POINTER TO PEResult;  PEResult: TYPE = MACHINE DEPENDENT RECORD [  -- any Courier Proc or Packet Exchanger receives these results    code: CH.Code ¬ done,    nameFound: Bool,    which: CH.ParameterGrouping ¬ first,    authenticationResults: Auth.AuthenticationProblem ¬ LAST[      Auth.AuthenticationProblem],    bool: Bool,    dn: CH.Name ¬ NIL,  -- distinguished name    hint: CH.Name ¬ NIL,    rhsLength: CARDINAL ¬ 0,    rhs: CH.Buffer ¬ NIL,    properties: CH.Properties ¬ DESCRIPTOR[LONG[NIL], 0],    chServerNSAddr: NSAddr.Address ¬ DESCRIPTOR[LONG[NIL], 0],    -- the following fields never go out on the wire    filler1: [0..1777B] ¬ 0,    procedure: CourierProcedures ¬ chServerAddrProbe,    filler2: [0..17777B] ¬ 0,    responseValue: ResponseValue ¬ successfulReturn];  -- we need to compute the size of the fields that never go out on the wire  -- so Courier Description routines can skip over these fields.  dummyR: PRIVATE POINTER TO PEResult = NIL;  slopAtEndOfResultRecord: CARDINAL =    SIZE[PEResult] - LOOPHOLE[@dummyR.chServerNSAddr + SIZE[NSAddr.Address],      CARDINAL];  Parms: TYPE = MACHINE DEPENDENT RECORD [    nameOrg, nameDomain, nameLocal, pn, aclist, pn2, element, rhs, sourceOrSink,      gtsAndChecksum: BOOLEAN ¬ FALSE,    credAndVer: BOOLEAN ¬ TRUE,    maybeExpedited: BOOLEAN ¬ FALSE,    filler: [0..17B] ¬ 0];  Results: TYPE = MACHINE DEPENDENT RECORD [    code, nameFound, which, authenResults, bool, dn, hint, rhs, properties,      chServerNSAddr, streamsOrgs, streamsDomains, streamsLocals: BOOLEAN ¬ FALSE,    filler: [0..7B] ¬ 0];  ProcsUseParms: TYPE = ARRAY CourierProcedures OF Parms ¬ [    chServerAddrProbe: [credAndVer: FALSE, maybeExpedited: TRUE],    enumerateYourDomains: [sourceOrSink: TRUE],    addName: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE],    deleteName: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE],    lookupDistinguishedName: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, maybeExpedited: TRUE],    enumerateOrganizations: [nameOrg: TRUE, sourceOrSink: TRUE],    enumerateDomains: [nameOrg: TRUE, nameDomain: TRUE, sourceOrSink: TRUE],    enumerate: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE,    sourceOrSink: TRUE],    enumerateAliases: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, sourceOrSink: TRUE],    enumerateAliasesOfAName: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, sourceOrSink: TRUE],    addAlias: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, element: TRUE],    deleteAlias: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE],    addGroup: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE,    sourceOrSink: TRUE],    addValue: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE, rhs: TRUE],    deleteProperty: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE],    enumerateProperties: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, maybeExpedited: TRUE],    lookupValue: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE,    maybeExpedited: TRUE],    changeValue: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE, rhs: TRUE],    lookupGroup: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE,    sourceOrSink: TRUE],    addMember: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE, element: TRUE],    addSelf: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE],    deleteMember: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE, element: TRUE],    deleteSelf: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE],    isMemberClosure: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE, pn2: TRUE,    element: TRUE],    dumpObject: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, sourceOrSink: TRUE],    enumerateObjects: [nameOrg: TRUE, nameDomain: TRUE, sourceOrSink: TRUE],    whatIsYourName: [maybeExpedited: TRUE],    iHaveYourName: [nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE],    newDumpObject: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, element: TRUE,    sourceOrSink: TRUE],    checkObject: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, element: TRUE,    gtsAndChecksum: TRUE],    retrievePropertyAccessList: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE, aclist: TRUE,    sourceOrSink: TRUE],    addMemberToPropertyAccessList: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE, aclist: TRUE,    element: TRUE],    deleteMemberFromPropertyAccessList: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE, aclist: TRUE,    element: TRUE],    isInPropertyAccessList: [    nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE, pn: TRUE, aclist: TRUE,    pn2: TRUE, element: TRUE],    retrieveDomainAccessList: [    nameOrg: TRUE, nameDomain: TRUE, aclist: TRUE, sourceOrSink: TRUE],    addMemberToDomainAccessList: [    nameOrg: TRUE, nameDomain: TRUE, aclist: TRUE, element: TRUE],    deleteMemberFromDomainAccessList: [    nameOrg: TRUE, nameDomain: TRUE, aclist: TRUE, element: TRUE],    isInDomainAccessList: [    nameOrg: TRUE, nameDomain: TRUE, aclist: TRUE, pn2: TRUE, element: TRUE],    retrieveOrgAccessList: [nameOrg: TRUE, aclist: TRUE, sourceOrSink: TRUE],    addMemberToOrgAccessList: [nameOrg: TRUE, aclist: TRUE, element: TRUE],    deleteMemberFromOrgAccessList: [nameOrg: TRUE, aclist: TRUE, element: TRUE],    isInOrgAccessList: [nameOrg: TRUE, aclist: TRUE, pn2: TRUE, element: TRUE],    getDomainSize: [nameOrg: TRUE, nameDomain: TRUE, nameLocal: TRUE]];  ProcsUseResult: TYPE = ARRAY CourierProcedures OF Results ¬ [    chServerAddrProbe: [chServerNSAddr: TRUE],    enumerateYourDomains: [streamsOrgs: TRUE, streamsDomains: TRUE], addName: [],    deleteName: [], lookupDistinguishedName: [dn: TRUE],    enumerateOrganizations: [streamsOrgs: TRUE],    enumerateDomains: [streamsDomains: TRUE], enumerate: [streamsLocals: TRUE],    enumerateAliases: [streamsLocals: TRUE],    enumerateAliasesOfAName: [    dn: TRUE, streamsOrgs: TRUE, streamsDomains: TRUE, streamsLocals: TRUE],    addAlias: [dn: TRUE], deleteAlias: [dn: TRUE],    addGroup: [    dn: TRUE, streamsOrgs: TRUE, streamsDomains: TRUE, streamsLocals: TRUE],    addValue: [dn: TRUE], deleteProperty: [dn: TRUE],    enumerateProperties: [dn: TRUE, properties: TRUE],    lookupValue: [dn: TRUE, rhs: TRUE], changeValue: [dn: TRUE],    lookupGroup: [    dn: TRUE, streamsOrgs: TRUE, streamsDomains: TRUE, streamsLocals: TRUE],    addMember: [dn: TRUE], addSelf: [dn: TRUE], deleteMember: [dn: TRUE],    deleteSelf: [dn: TRUE], isMemberClosure: [bool: TRUE, dn: TRUE],    dumpObject: [], enumerateObjects: [streamsLocals: TRUE],    whatIsYourName: [dn: TRUE, rhs: TRUE], iHaveYourName: [], newDumpObject: [],    checkObject: [bool: TRUE],    retrievePropertyAccessList: [    dn: TRUE, streamsOrgs: TRUE, streamsDomains: TRUE, streamsLocals: TRUE],    addMemberToPropertyAccessList: [dn: TRUE],    deleteMemberFromPropertyAccessList: [dn: TRUE],    isInPropertyAccessList: [bool: TRUE, dn: TRUE],    retrieveDomainAccessList: [    dn: TRUE, streamsOrgs: TRUE, streamsDomains: TRUE, streamsLocals: TRUE],    addMemberToDomainAccessList: [], deleteMemberFromDomainAccessList: [],    isInDomainAccessList: [bool: TRUE],    retrieveOrgAccessList: [    streamsOrgs: TRUE, streamsDomains: TRUE, streamsLocals: TRUE],    addMemberToOrgAccessList: [], deleteMemberFromOrgAccessList: [],    isInOrgAccessList: [bool: TRUE],    getDomainSize: [rhs: TRUE]];  ProcsUseErrors: TYPE = ARRAY ResponseValue OF Results ¬ [    successfulReturn: [],  -- covered by procsUseResult    operationalError: [code: TRUE], namingError: [code: TRUE, which: TRUE],    propertyError: [code: TRUE, dn: TRUE],    updateError: [code: TRUE, nameFound: TRUE, which: TRUE, dn: TRUE],    wrongServer: [hint: TRUE], identifierRejected: [authenResults: TRUE]];  procsUseParms: READONLY ProcsUseParms;  procsUseResult: READONLY ProcsUseResult;  procsUseError: READONLY ProcsUseErrors;  END..LOG28-Sep-82 10:02:46 - BLyon 1-Sep-83 18:40:36 - BLyon30-Sep-83 16:04:13 - Stucke11-Oct-83 13:38:38 - Read23-Nov-83 15:27:33 - Gealy - Convert to 8.0 CH and Auth.25-Jan-84 23:28:19 - Gealy - Add protocol compatibility support.  Removed GetCourierInfo (duplicate in CHMux)28-Apr-84 22:23:20 - read - added getDomainSize17-Jun-84 15:38:23 - read - unexpedited operations that modify the database14-Dec-84 10:42:14 - AOF - NSTypes replaced with PacketExchange
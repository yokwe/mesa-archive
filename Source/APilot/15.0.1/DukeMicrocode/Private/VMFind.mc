{ File Name:   VMFind.mc  Author:      TxH  Description: Find proc in VMDataUtilities is implemented in microcodes.                Mesa code 277B is assigned.    Last Edited:  TxH  14-Sep-88 14:03:40  fixed pRun-calculation from index; added Copyright notice;  Last Edited:  TxH  18-Aug-88  9:36:40  fixed a bug in CalcHiIndex.c1.xx  Last Edited:  TxH  14-Aug-88 18:49:52  Created} { Copyright (C) 1988 by Fuji Xerox Co., Ltd.  All rights reserved. } {*******************************************************************  [1. Proc]       Find: PROCEDURE [page, rBase, pRunTop]                        RETURNS  [found: BOOLEAN, pRun: PRun]; [2. Stack]      (Entry)                    (Exit)                 TOS ...  pRunTop                                STK ...  rBase-Hi	                  rBase-Lo	                   page-Hi       TOS ...  pRun		           page-Lo       STK ...  found(IF TRUE THEN 1 ELSE 0)			    [3. Registers]                   		  			   << R-Reg >>	  0 :                     TOS,              rDividendHi,     rPRunTop,         rIndex		  1 :                                                                          rIndexHi    rIntvlEndPageHi   rIntvlCountHi		  2 :                                                                          rIndexLo    rIntvlEndPageLo   rIntvlCountLo		  3 : --L--    rBaseLo(*)		  4 : --G--    rBaseHi(*)		  5 : --PC--   rPageHi(*)		  6 :                                                        rTrue                          rIntvlPageHi		  7 : --r100-- rPageLo(*)		  9 :                                        rCounter,       rRunMru, rPRunXX		  B :                     rVirtualL(rh..)    rRunSize,                                     (rIntvlEndPageHi   rIntvlCountHi) 		  C :                     rAddrLo  (rh..)                                                  		  E :                     temp                                                              rIntvlPageLo 		  		    << U-Reg >>   0EC : uRunMru                 7F : Ur0100Save	  [4. Constants]  pRunFirst = 14'd		L0.0 = 0		 indexRunFirst = 1		L0.2 = 2		 TRUE = 1			L0.4 = 4		 FALSE = 0		 RunSize = 14'd		       *******************************************************************} {*******************************************************************		Main-Line *******************************************************************}   @VMFIND:	Ur0100Save ¬ r0100,				c1, opcode[277'b];		ULsave ¬ L,					c2;		UGsave ¬ G,					c3;		PC ¬ PC + PC16,					c1;		UPCsave ¬ PC,					c2;		rBaseHi ¬ STK, pop, L0 ¬ L0.0,			c3;		rBaseLo ¬ STK, pop,				c1;		rPageHi ¬ STK, pop,				c2;		rRunMru ¬ uRunMru,				c3;		{** Note that the stack pointer points to where "found" should be pushed.}					{*****************************************************************		   IF pRunMru > pRunTop THEN pRunMru ¬ pRunFirst;          CheckSameAsLast: see [GetInterval].       Return to at[L0.0, 8, GIntvl].    *****************************************************************}Adjst.RunMru:	[] ¬ rPRunTop{=TOS=pRunTop} - rRunMru, NegBr,		c1;		rPageLo ¬ STK, BRANCH[CheckSameAsLast, $],		c2;		rRunMru ¬ pRunFirst,					c3;		uRunMru ¬ rRunMru, CALL[GetInterval.c2],		c1;					{*****************************************************************	  IF page IN     [rBase[pRunMru].interval.page..      rBase[pRunMru].interval.page + rBase[pRunMru].interval.count) THEN ...			     rIntvlPageXX & rIntvlEndPageXX are set up.     GetInterval pushed FALSE on STK      ***********************************************  [intvl] <= [page] < [intvlE]  :   true:  SameAsLastTime: S                                     fasle:  CalcHiIndex.xx: C    Check [intvl] <= [page]         Lo.B 1.  (pageHi  > intvlHi) then (check Hi.B) else   $  =  BRANCH[$, (check Hi.B)]             2.  (pageHi  = intvlHi) then       $      else   C  =  BRANCH[CalcHiIndex.xx, $]             3.  (pageLo >= intvlLo) then       $      else   C  =  BRANCH[$, CalcHiIndex.xx]	  Check [page]  < [int-E]         Hi.B 1.  (pageHi  < intHi-E) then       S      else   $  =  BRANCH[$, SameAsLastTime]             2.  (pageHi  = intHi-E) then       $      else   C  =  BRANCH[CalcHiIndex.xx, $]             3.  (pageLo  < intLo-E) then       S      else   C 	        =(pageLo >= intLo-E) then       C      else   S  =  BRANCH[SameAsLastTime, C]	     *****************************************************************}			ChkSame.Chk:	[] ¬ rIntvlPageHi - rPageHi, NegBr,					c1, at[L0.0, 8, GIntvl];Chk.S.Lo.1:	[] ¬ rIntvlPageHi - rPageHi, ZeroBr, BRANCH[$, Chk.S.lh],		c2;Chk.S.Lo.2:	[] ¬ rPageLo - rIntvlPageLo, CarryBr, BRANCH[CalcHiIndex.c1, $],	c3;Chk.S.Lo.3:	[] ¬ rPageHi - rIntvlEndPageHi, NegBr, BRANCH[CalcHiIndex.c2, $],	c1;Chk.S.Hi.1:	[] ¬ rPageHi - rIntvlEndPageHi, ZeroBr, BRANCH[$, SameAsLastTime.c3],	c2;Chk.S.Hi.2:	[] ¬ rPageLo - rIntvlEndPageLo, CarryBr, BRANCH[CalcHiIndex.c1.ex, $],	c3;Chk.S.Hi.3:	{Noop} BRANCH[SameAsLastTime.c2, CalcHiIndex.c2.ex],			c1;				Chk.S.lh:	CANCELBR[$, 1],								c3;Chk.S.Lo.3.ex:	[] ¬ rPageHi - rIntvlEndPageHi, NegBr, GOTO[Chk.S.Hi.1],		c1;														{*****************************************************************    indexRunLow ¬ indexRunFirst;    indexRunHigh ¬ (pRunTop - FIRST[PRun])/SIZE[Run];    	use the divide routine implemented in Stack.mc.	divisor = RunSize  = rRunSize	dividend = pRunTop = TOS = rPRunTop	16bits/4bits => 13 bits => 16bits		PRun: TYPE = RunBase RELATIVE ORDERED POINTER [0..LAST[CARDINAL]] TO Run;     *****************************************************************}CalcHiIndex.c1:		{Noop} CANCELBR[CalcHiI.c1.c2, 1],		c1;CalcHiIndex.c1.ex:	{Noop} CANCELBR[CalcHiI.c1.c2, 1],		c1;CalcHiI.c1.c2:		rPRunTop ¬ rPRunTop LRot4, GOTO[CalcHiI.c3, 1],	c2;CalcHiIndex.c2:		rPRunTop ¬ rPRunTop LRot4, CANCELBR[CalcHiI.c3, 1],	c2;CalcHiIndex.c2.ex:	rPRunTop ¬ rPRunTop LRot4, CANCELBR[CalcHiI.c3, 1],	c2;CalcHiI.c3:	Q ¬ rPRunTop or 0F,				c3;		rDividendHi ¬ rPRunTop and 0F,			c1;		rCounter ¬ 13'd,				c2;		rRunSize ¬ RunSize,				c3;		VMF.DivLoop:	[] ¬ rDividendHi - rRunSize, CarryBr, BRANCH[VMF.QuotUnk, VMF.QuotIs1],			c1;VMF.QuotUnk:	rCounter ¬ rCounter - 1, ZeroBr, BRANCH[VMF.Quot0, VMF.Quot1],				c2;VMF.QuotIs1:	rCounter ¬ rCounter - 1, ZeroBr,CANCELBR[VMF.Quot1, 1],					c2;VMF.Quot0:	rDividendHi ¬ DLShift1 rDividendHi, SE¬0{=~1}, NegBr, BRANCH[VMF.DivLoop, VMF.DivEnd],			c3;VMF.Quot1:	rDividendHi ¬ DLShift1 (rDividendHi - rRunSize), SE¬1{=~0}, NegBr, BRANCH[VMF.DivLoop, VMF.DivEnd],	c3;{** Now Q = indexRunHigh =  (pRunTop - FIRST[PRun])/SIZE[Run];}VMF.DivEnd:	rIndexHi ¬ ~Q, CANCELBR[$, 1],		c1;		rIndexLo ¬ indexRunFirst,		c2;			{** max rIndexHi = FFFF/E = 1249'H}									{*****************************************************************  DO       indexRun ¬ (indexRunLow + indexRunHigh)/2;     pageComp ¬ rBase[0+indexRun*SIZE[Run]].interval.page;     ... *****************************************************************}  {** rIndex <= 1249'H, that is (indexRunLow + indexRunHigh) does not cause carry.}   			VMF.Search.Loop:	rIndex ¬ rIndexHi, CANCELBR[$, 1],			c3;			rIndex ¬ rIndex + rIndexLo, L0 ¬ L0.2,			c1;			rIndex ¬ RShift1 rIndex, SE ¬ 0,			c2;			rPRunXX ¬ rIndex LRot4,					c3;			temp ¬ LShift1 rIndex,					c1;			rVirtualL ¬ rPRunXX and ~0F,				c2;			rVirtualL ¬ rVirtualL - temp, CALL[GetIntervalPage],	c3;			{** GetIntervalPage pushed TRUE on STK !}{** GetIntervalPage does not destroy rIndexHi nor rIndexLo. !!}			 {*****************************************************************   IF (pageComp ¬ rBase[FIRST[PRun] + indexRun*SIZE[Run]].interval.page) > page        THEN indexRunHigh ¬ indexRun - 1        ELSE IF page > pageComp THEN indexRunLow ¬ indexRun + 1 ELSE GO TO Exact;	   pageComp = [rIntvlPageHi, rIntvlPageLo];   page > intvl   :  (     Srch.A        ) : indexRunLow ¬ indexRun + 1;  GOTO[Srch.If.3];   page = intvl   :  (Srch.B = Exit.Exact)   page < intvl   :  (     Srch.C        ) : indexRunHigh ¬ indexRun - 1; GOTO[Srch.If.3];	  Check 1. (pageHi <= intvlHi) then      $      else   Srch.A  =  BRANCH[Srch.A, $]        2. (pageHi  = intvlHi) then      $      else   Srch.C  =  BRANCH[Srch.C, $]	3. (pageLo <= intvlLo) then      $      else   Srch.A  =  BRANCH[Srch.A, $]        2. (pageLo  = intvlLo) then    Srch.B   else   Srch.C  =  BRANCH[Srch.C, Srch.B]	 *****************************************************************}	Srch.L.PgComp:	[] ¬ rIntvlPageHi - rPageHi, CarryBr,	 				c1, at[L0.2, 8, GIntvlPg];		[] ¬ rIntvlPageHi - rPageHi, ZeroBr, BRANCH[Srch.A.c3, $],		c2;		[] ¬ rIntvlPageLo - rPageLo, CarryBr, BRANCH[Srch.C.c1, $],		c3;		[] ¬ rIntvlPageLo - rPageLo, ZeroBr, BRANCH[Srch.A.c2, $],		c1;		rPRunXX ¬ rIndex LRot4, XDisp, BRANCH[Srch.C.c3, Exit.Exact{=Srch.B}],	c2;Srch.A.c2:	rIndexLo ¬ rIndex + 1, CANCELBR[Srch.If.3.c3, 1],		c2;Srch.A.c3:	rIndexLo ¬ rIndex + 1, CANCELBR[Srch.If.3.c1, 0F],		c3;Srch.C.c1:	rIndexHi ¬ rIndex - 1, CANCELBR[Srch.If.3.c2, 1],		c1;Srch.C.c3:	rIndexHi ¬ rIndex - 1, CANCELBR[Srch.If.3.c1, 0F],		c3;		{*****************************************************************		    IF indexRunHigh < indexRunLow THEN GO TO NotExact;    ENDLOOP;  --DO UNTIL search terminates--     *****************************************************************}       Srch.If.3.c2:									c2;			Srch.If.3.c3:									c3;Srch.If.3.c1:		[] ¬ rIndexHi - rIndexLo, CarryBr,			c1;Srch.L.ENDLOOP:		STK ¬ FALSE, BRANCH[Exit.NotExact, VMF.Search.Loop],	c2;					{*****************************************************************                    Exit *****************************************************************}{*****************************************************************  Exact =>      [1]  pRun ¬ FIRST[PRun] + indexRun*SIZE[Run];         found ¬ TRUE; *****************************************************************}     {** already TRUE pushed onto stack}Exit.Exact:		TOS ¬ LShift1 rIndex, BRANCH[VMF.MulTbl.B.0, VMF.MulTbl.B.1, 0E],	c3;		VMF.MulTbl.B.0:Exact.Exit:		TOS ¬ rPRunXX - TOS,  GOTO[VMF.Exit.Exit.c2],	c1;VMF.MulTbl.B.1:		rPRunXX ¬ rPRunXX and ~0F,			c1;									c2;			GOTO[Exact.Exit],				c3;{*****************************************************************   NotExact =>       [2]   indexRunLow = indexRunFirst:           pRun ¬ pRunFirst;           found ¬ FALSE			            [3]  indexRunLow # indexRunFirst:           pRun ¬ FIRST[PRun] + indexRunHigh*SIZE[Run];	     [4]   page  < rBase[pRun].interval.page + rBase[pRun].interval.count          [5]   TRUE: => found ¬ TRUE     [6]   FALSE => pRun ¬ pRun + SIZE[Run];	            found ¬ FALSE;       *****************************************************************}{** FALSE is pushed on stack already}{**[2]**}Exit.NotExact:	[] ¬ rIndexLo - indexRunFirst, ZeroBr,					c3;		TOS ¬ pRunFirst, L0 ¬ L0.4, BRANCH[NE.If.Else, VMF.Exit.Exit.c2],	c1; 											{**[3]**}	NE.If.Else:	rPRunXX ¬ rIndexHi LRot4,				c2;		temp ¬ LShift1 rIndexHi,				c3;VMF.MulTbl.C:	rPRunXX ¬ rPRunXX and ~0F, 				c1;		rPRunXX ¬ rPRunXX - temp, CALL[GetInterval],		c2;			{** GetInterval pushed FALSE on STK !}	{**[4]**} {***************************************************************** ... page < rBase[pRun].interval.page + rBase[pRun].interval.count THEN        (page < int-E ?)  :  then NE.Else.True  else  NE.Els.Els.xx	  Check 1. (pageHi <= intHi-E) then   $  else false        2. (pageHi  = intHi-E) then   $  else true        3. (pageLo  < intLo-E) then true else false	  =(pageLo => intLo-E) then false else true *****************************************************************}		NE.Else.Comp:	[] ¬ rIntvlEndPageHi - rPageHi,	CarryBr, 				c1, at[L0.4, 8, GIntvl];		[] ¬ rIntvlEndPageHi - rPageHi, ZeroBr, BRANCH[NE.Els.Els.c3, $],	c2;		[] ¬ rPageLo - rIntvlEndPageLo, CarryBr, BRANCH[NE.Else.True.c1, $],	c3;		TOS ¬ rPRunXX + RunSize, BRANCH[NE.Else.True.c2, NE.Els.Els.c2],	c1;{**[5]**}		NE.Else.True.c1:	CANCELBR[$, 1],					c1;			TOS ¬ rPRunXX, GOTO[NE.Else.True],		c2;NE.Else.True.c2:	TOS ¬ rPRunXX, GOTO[NE.Else.True], 		c2;NE.Else.True:		Q ¬ TRUE,					c3;			STK ¬ Q{=TRUE}, GOTO[VMF.Exit.Exit.c2],		c1;{**[6]**}NE.Els.Els.c3:	TOS ¬ rPRunXX + RunSize, CANCELBR[VMF.Exit.Exit.c1, 1],	c3;{*****************************************************************  SameAsLastTime =>      [7]  pRun ¬ pRunMru;         found ¬ TRUE; *****************************************************************}		SameAsLastTime.c2:								c2;SameAsLastTime.c3:	TOS ¬ rRunMru{=rPRunXX}, CANCELBR[$, 1], 		c3;True.Exit.SAL:		Q ¬ TRUE,		 				c1;			STK ¬ Q{=TRUE}, GOTO[VMF.E.E.com],		 	c2;{*****************************************************************       Exit.END: pRunMru ¬ pRun; *****************************************************************}VMF.Exit.Exit.c3:							c3;VMF.Exit.Exit.c1:							c1;NE.Els.Els.c2:		uRunMru ¬ TOS, GOTO[VMF.E.E.com],		c2;VMF.Exit.Exit.c2:	uRunMru ¬ TOS, GOTO[VMF.E.E.com],		c2;VMF.E.E.com:		PC ¬ UPCsave,                         {rPageHi}	c3;			r0100 ¬ Ur0100Save		      {rTrue} 	c1;MF.Exit.Exit:		G ¬ UGsave, IBDisp,                   {rBaseHi}	c2;			L ¬ ULsave, DISPNI[OpTable],          {rBaseLo}	c3;						{*****************************************************************   GetInterval / GetIntervalPage *****************************************************************  [Cycle]       c3-c3  [Entry]       rPRunXX: pRun value	       L0     : return index		  [Exit]	       L0 = 2    : <GetIntervalPage> -- at[L0.x, 8, GIntvlPg]                           returns the only run.interval.page			   pushes TRUE onto STK			   	       L0 = 0, 4 : <GetInterval>     -- at[L0.x, 8, GIntvl]                           returns the run.interval.page			   and (run.interval.page + .count)			   pushes FALSE onto STK			   	       rIntvlPageLo    (rTrue)	       rIntvlPageHi	       rIntvlEndPageLo	       rIntvlEndPageHi	        [Caller]      L0.0 : Adjst.RunMru     [return to]  ChkSame.Chk               L0.2 : VMF.Search.Loop  [return to]  Srch.L.PgComp	       L0.4 : NE.If.Else       [return to]  NE.Else.Comp			      		  [Regs used]   rVirtualL               rhVirtualH	       rAddrLo	       rhAddrHi	       Q	       L2	       *****************************************************************}GetInterval.c2:									c2;GetInterval:CheckSameAsLast:	rVirtualL  ¬ rPRunXX,					c3;GetIntervalPage:GetInterval.XX.c1:	rVirtualL  ¬ rVirtualL + rBaseLo, CarryBr, 		c1;G.Intvl.c2:		Q ¬  rBaseHi + 1, BRANCH[MapRun.c3, GI.IncHi.c3],	c2;MapRun.c3:		rhVirtualH ¬  rBaseHi LRot0, CALL[MapRun.c1],		c3;	GI.IncHi.c3:		rhVirtualH ¬  Q LRot0, CALL[MapRun.c1],			c3;	     MapRun.c1:	Map ¬ Q ¬ [rhVirtualH, rVirtualL], GOTO[MapRun.c2],	c1;MapRun.c2:	rTrue ¬ TRUE,						c2;		rAddrLo ¬ rhAddrHi ¬ MD,				c3;{** Accessing words of a run.interval not sequentially may cause needless page crossings.}		GI.R.pageLo:	MAR ¬ Q ¬ [rhAddrHi, Q + 0],	c1;		STK ¬ rTrue,			c2;		rIntvlPageLo ¬ MD,		c3;						GI.R.pageHi:	MAR ¬ Q ¬ [rhAddrHi, Q + 1], L2 ¬ 0,					c1;GI.R.pageHi.c2:	[] ¬ rVirtualL + 1, CarryBr, L0Disp, BRANCH[$, GI.Cross.PHi, 1],	c2;		rIntvlPageHi ¬ MD, DISP3[GIntvlPg],					c3;		GI.R.countLo:	MAR ¬ Q ¬ [rhAddrHi, Q + 1], L2 ¬ 2, GOTO[GI.R.cntLo.c2],	c1, at[L0.0, 8, GIntvlPg];		MAR ¬ Q ¬ [rhAddrHi, Q + 1], L2 ¬ 2, GOTO[GI.R.cntLo.c2],	c1, at[L0.4, 8, GIntvlPg];		GI.R.cntLo.c2:	[] ¬ rVirtualL + 2, CarryBr, BRANCH[$, GI.Cross.CLo, 1],	c2;		rIntvlCountLo ¬ MD, CANCELBR[GI.R.countHi, 7],			c3;							GI.R.countHi:	MAR ¬ Q ¬ [rhAddrHi, Q + 1], L2 ¬ 4, 				c1;		[] ¬ rVirtualL + 3, CarryBr, BRANCH[$, GI.Cross.CHi, 1],	c2;		rIntvlCountHi ¬ MD, CANCELBR[GI.EndPg, 7],			c3;		    GI.EndPg:	rIntvlEndPageLo ¬ rIntvlPageLo + rIntvlCountLo, CarryBr,	c1;		STK ¬ FALSE, L0Disp, BRANCH[GI.EndPg.0, GI.EndPg.1],		c2;			GI.EndPg.0:	rIntvlEndPageHi ¬ rIntvlPageHi + rIntvlCountHi, DISP3[GIntvl],		c3;GI.EndPg.1:	rIntvlEndPageHi ¬ rIntvlPageHi + rIntvlCountHi + 1, DISP3[GIntvl],	c3;						{** for crossing page boundary}GI.Cross.PHi:	rVirtualL ¬ rVirtualL + 1, BRANCH[MapRun.Extra.c1, GI.rm.IncHi, 0E], 	c3;GI.Cross.CLo:	rVirtualL ¬ rVirtualL + 2, BRANCH[MapRun.Extra.c1, GI.rm.IncHi, 0E], 	c3;GI.Cross.CHi:	rVirtualL ¬ rVirtualL + 3, BRANCH[MapRun.Extra.c1, GI.rm.IncHi, 0E], 	c3;GI.rm.IncHi:	Q ¬  rhVirtualH + 1, LOOPHOLE[byteTiming], 	c1;		rhVirtualH ¬  Q LRot0,				c2;		CALL[MapRun.Extra.c1],				c3;MapRun.Extra.c1:		Map ¬ Q ¬ [rhVirtualH, rVirtualL],		c1;								c2;		rAddrLo ¬ rhAddrHi ¬ MD,			c3;GI.ReMap.Ret:	MAR ¬ Q ¬ [rhAddrHi, rVirtualL + 0], L2Disp,	c1;         	L0Disp, DISP3[GI.ReMap.Wh],			c2;				rIntvlPageHi ¬ MD, DISP3[GIntvlPg],		c3, at[0, 8, GI.ReMap.Wh];		rIntvlCountLo ¬ MD, CANCELBR[GI.R.countHi, 7],	c3, at[2, 8, GI.ReMap.Wh];		rIntvlCountHi ¬ MD, CANCELBR[GI.EndPg, 7],	c3, at[4, 8, GI.ReMap.Wh];									{ ******************************** END ******************************** }
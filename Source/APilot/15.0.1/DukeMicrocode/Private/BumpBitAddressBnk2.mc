{ File Name: BumpBitAddressBnk2.mc optimization version  Description: Shifts a bit address by an integer number of bits.  Author: MYT  Created: July 21, 1986  Edited:  Sep. 18, 1986  	   Oct. 07, 1986Last Edited:SxO/TxH, 13-Sep-88 10:54:07 moved to bank2; changed the file name;     *** This is a optimization version for BumpBitAddress , it will save about 7 clicks operation from the original version.	  		}{ Copyright (C) 1986 by XEROX corporation. All rights reserved.}@BumpBitAddress:at [0A,10,ESCAn]{**************************************************************************************** 			POP Parameters from stack			 ****************************************************************************************} {	Get offset, bit number, word virtual address form stack to registers	 }			offset ¬ TOS,L4 ¬ L4.BumpBitAddress,	        c1;{ L4 is used for micro caller }	bitnum ¬ STK,pop,				c2;	rwrdaddh ¬ STK,pop, 				c3;	rwrdaddl ¬ STK,fXpop,fZpop,push,		c1;	offset ¬ offset + bitnum,NegBr,GOTO[BBAMainEntry],	c2;{**************************************************************************************** 			Processing both positive and negative offset cases			 ****************************************************************************************}	BBASubEntry:	{ for microcaller - TrapzInit, TrapzSubs, ChainBlt: 8 cycles total}	offset ¬ offset + bitnum, 			c*;BBAMainEntry:	bitnum ¬ offset and 0F,BRANCH [$,neg],		c*;{ generate result bit number }	rtmpadd ¬ offset and ~0F,GOTO[either],		c*;{ abs(offset) <= bitnum }neg:	rtmpadd ¬ offset or 0F,				c*;{ abs(offset) > bitnum }either:	rtmpadd ¬ rtmpadd LRot12,XHDisp,		c*;{ generate result address value}	rwrdaddl ¬ rwrdaddl + rtmpadd,CarryBr,BRANCH[testCpos,testCneg,2],      c*;	{ check carry for positive or negative case }testCpos:	BRANCH[PushBackp2,$],				c*;	rwrdaddh ¬ rwrdaddh + 1,L4Disp,GOTO[PushBackc3],	c*;PushBackp2:	L4Disp,GOTO[PushBackc3],			c*;testCneg:	BRANCH[$,PushBackn2],				c*;	rwrdaddh ¬ rwrdaddh - 1,L4Disp,GOTO[PushBackc3],	c*;PushBackn2:	L4Disp,						c*;PushBackc3:	DISP4[BumpBitAddressRet],			c*;{**************************************************************************************** 				Push Parameters back to stack			 ****************************************************************************************}{	Push results - bit number, word address back to stack 				 }	STK ¬ rwrdaddl, push,				c1, at[L4.BumpBitAddress,10,BumpBitAddressRet];	STK ¬ rwrdaddh,  				c2;	TOS ¬ bitnum, GOTOABS[Bank2NxtInstc1],{GOTOABS[Bank1NxtInstc1],}  c3;
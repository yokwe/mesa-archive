{VFpt.dfnCreated:	 8-Oct-87 15:25:13,	JPM (from Daybreak.dfn)Last edited:	13-Nov-87 13:05:08,	JPM,	comment out register definitions for now (still in Daybreak.dfn)}{	Copyright (C) 1987 by Xerox Corporation.  All rights reserved. }{{R AND RH REGISTER DEFINITIONS}RegDef[divisorHigh,	R,	2]; {Fpt-div: TT}RegDef[divCount,	R,	3]; {Fpt-div: L - must be saved and restored}RegDef[divResult,	R,	4]; {Fpt-div: G - must be saved and restored}RegDef[divisorLow,	R,	6]; {Fpt-div: Rx}{U REGISTER BLOCK 1 -- EMULATOR}RegDef[uHighHalf1,	U,	17]; {Fpt: rA = T}RegDef[uLowHalf1,	U,	19]; {Fpt: rA = T}RegDef[uHighHalf2,	U,	1B]; {Fpt: rA = T}RegDef[uHighRem,	U,	1B]; {Fpt: rA = T}RegDef[uLowHalf2,	U,	1C]; {Fpt: rA = T}RegDef[uLowRem,		U,	1C]; {Fpt: rA = T}RegDef[uExp1,		U,	1D]; {Fpt: Fpt: rA = T}RegDef[uExp2,		U,	1F]; {Fpt: rA = T}RegDef[uHighTempRoot,	U,	1F]; {Fpt: rA = T}{U REGISTER BLOCK 2 -- EMULATOR}RegDef[uStickyBit,	U,	25]; {Fpt: rA = TT}RegDef[uSign1,		U, 	27]; {Fpt: rA = TT}RegDef[uSign2,		U,	2A]; {Fpt: rA = TT}{U REGISTER BLOCK 3 -- EMULATOR}RegDef[uDivCount,	U,	31]; {Fpt: divCount = L}RegDef[uSqrtCount,	U,	31]; {Fpt: divCount = L}{U REGISTER BLOCK 4 -- EMULATOR}RegDef[uDivResult,	U,	42]; {Fpt: divResult = G}RegDef[uLowTempRoot,	U,	42]; {Fpt}{U REGISTER BLOCK 6 -- EMULATOR}RegDef[uib,		U,	63]; {Fpt: rA = Rx}}{---------------------------------------------------------}{**	Floating point definitions.  }{	return points for unpack routines}Set[L0.mult1,		00];Set[L0.mult2,		01];Set[L0.mult3,		02];Set[L0.mult4,		03];Set[L0.mult5,		04];Set[L0.add1,		05];Set[L0.sub1,		06];Set[L0.comp1,		07];Set[L0.round1,		08];Set[L0.round4,		09];Set[L0.round5,		0A];Set[L0.FScale1,		0B];Set[L0.unpacklop,	0C];Set[L0.sqrt1,		0D];{return points for denorm routine, DeNormRets, NOTICE: The allocation is only 3 bits wide on the returns, i.e.,          foo, cx, at[L0.mumble,8,DeNormRets]; }Set[L0.add2,		01];Set[L0.rePack1,		02];Set[L0.div1,		03];Set[L0.round2,		04];{Set[L0.add1,		05]; same as above unpack ret, but occupies space in the DeNormRets}Set[L0.round3,		06];Set[L0.denormop,	07];{return points for rounding routine, RoundRets NOTICE: The allocation is only 3 bits wide, see DeNormRets above. }Set[L0.rePack2, 	01]; {must be 1 mod 2}{Set[L0.round2, 	04];  must be same as the above DeNorm ret, but occupy space in the round rets}{floating point trap args}Set[L1.FpT2,		0];Set[L1.FpT1, 		1];Set[L1.FpT1.5,		2];{divide loop return points}Set[L0.div2,		1];Set[L0.div3,		2];{ return points for FixF routine for unpack opcode }Set [L0.FixF0,		0];Set [L0.FixF1,		1];Set[L0.VMFRtn0,		0];Set[L0.VMFRtn1,		1];Set[L0.VMFRtn2,		2];Set[L0.VMFRtn3,		3];Set[L0.VMFRtn4,		4];Set[L1.SaveLFix,	0F]; { NOTE: see mesa.df ! }	{ End }
{Daybreak.dfnLast Revised:	15-Sep-87 17:15:13,	JAC   , uGFI was a floating pt registerLast Revised:	31-Dec-86 12:02:42,	AHL/JPM, MDS relief changesLast Revised:	19-Dec-86 13:45:08,	JPM,	add more image processing definitionsLast Revised:	18-Dec-86 10:40:20,	JPM,	add more image processing definitionsLast Revised:	14-Nov-86 10:11:27,	JPM,	add uIdleCount* for performance studyLast Revised:	26-Oct-86 11:44:20,	CRF,	replaced uRect* & uChar* by uLO*Last Revised:	 9-Oct-86 13:11:38,	JPM,	remove unused reg defsLast Revised:	 6-Oct-86 12:14:49,	JPM,	move Floyd and GrayBlt temp U-regs to bank ELast Revised:	12-Aug-86  9:18:24,	JPM,	fix bug (RH reg incorrectly defined as R reg)Last Revised:	11-Aug-86  8:48:54,	JPM,	add more image processing definitionsLast Revised:	 8-Aug-86 16:54:25,	JPM,	add image processing definitionsLast Revised:	 7-Aug-86 16:55:27,	SCJ,	removed uFactoruCode, FPTEnabled is sufficient to indicate whether or not Floating point uCode is present Removed uTimesWplDisp, which is used only by special Versatec OpcodesLast Revised:	14-May-86  9:57:07,	SCJ,	merged EIS Daybreak.dfn with the existing Daybreak.dfn to build a MesaDove with floating point microcodeLast Revised:	 7-Mar-86 12:29:23,	GPV,	add * to designate sacred registersLast Revised:	18-Dec-85 19:26:25,	KxI,	add CompressAssist.mc definitions. and trim source code layout.Last Revised:	29-Oct-85 17:56:40,	RDH,	add BandBLT definitionsLast Revised:	19-Jul-85 17:52:32,	JAC,	add kernel definitionsLast Revised:	 3-Jul-85 11:00:53,	JPM,	move non-register defs to Mesa.dfnLast Revised:	 7-Feb-85  8:57:57,	JPM,	add new U regs for IORegionLast Revised:	29-Jan-85  9:49:38,	JPM,	add U block defsLast Revised:	10-Jan-85 10:59:41,	JPM,	change kernel locationsLast Revised:	 8-Jan-85 15:48:31,	JPM,	incorporate new TextBlt U-register defsCreated:	10-Oct-84 12:11:47,	JPM}{	Copyright (C) 1984, 1985, 1986 by Xerox Corporation.  All rights reserved. }{R AND RH REGISTER DEFINITIONSSince there are no task specific registers in the machine, task identifiers are not bound to the register numbers with which they are shown.Q is reserved for the Emulator Task.Also, the stackP, STK, ib, and pc16 registers are reserved for the Emulator task.}{REGISTERS 0 - 9, B, C, E: EMULATOR}RegDef[TOS,		R,	0]; {* Top Of Stack}RegDef[Hold,		R,	0]; {BBLoops}RegDef[Rbb0,		R,	0]; {BitBlt and TextBlt and BandBLT and TrapezoidBLT}RegDef[VS,		R,	0]; {BitBlt}RegDef[Mask2,		R,	0]; {BitBlt}RegDef[rYheight,	R,	0]; {BandBLT}RegDef[rCC,		R,	0]; {BandBLT}RegDef[Grayword,	R,	0]; {BLTLineGray}RegDef[length,		R,	0]; {ChainBlt}RegDef[Count,		R,	0]; {CountBits}RegDef[width,		R,	0]; {FlipX}RegDef[rTT2,		R,	0]; {Floyd: temp R register}RegDef[rCount,		R,	0]; {GrayBlt, Scale}RegDef[rMargin,		R,	0]; {LineBreak}RegDef[rReason,		R,	0]; {LineBreak}RegDef[wplDst,		R,	0]; {Rotate}RegDef[rhMDS,		RH,	0]; {** VA of 64K aligned MDS}RegDef[rhVS,		RH,	0]; {BitBlt uses fact that rhVS = rhMDS}RegDef[T,		R,	1]; {temporary}RegDef[Save,		R,	1]; {BitBlt}RegDef[VD,		R,	1]; {BitBlt, ComMapSub}RegDef[Rbb1,		R,	1]; {BitBlt and TextBlt and BandBLT and TrapezoidBLT}RegDef[Mask1,		R,	1]; {BitBlt}RegDef[rScratch,	R,	1]; {BandBLT}RegDef[rXDisp,		R,	1]; {BandBLT}RegDef[rXwidth,		R,	1]; {BandBLT}RegDef[GCount,		R,	1]; {BLTLineGray}RegDef[tempC,		R,	1]; {BLTLineGray: the Count register is free sometimes to be used as a temp register tempC for other operations}RegDef[offset,		R,	1]; {BumpBitAddress}RegDef[rdstlow,		R,	1]; {ChainBlt}RegDef[rWordA,		R,	1]; {CompressAssist.mc @NextMatchAndDiff}RegDef[rDestVA,		R,	1]; {CompressAssist.mc @CLR}RegDef[Limit,		R,	1]; {CountBits}RegDef[rtemp,		R,	1]; {FlipX}RegDef[rError,		R,	1]; {Floyd: new error for current pixel value }RegDef[PIX,		R,	1]; {Floyd: current pixel pair }RegDef[rSumLow,		R,	1]; {GrayBlt}RegDef[rThreshold,	R,	1]; {GrayBlt}RegDef[rGrTRC,		R,	1]; {GrayBlt}RegDef[rSrcWord,	R,	1]; {Halftone: working source pixels(2)}RegDef[rMicaLength,	R,	1]; {LineBreak}RegDef[wplSrc,		R,	1]; {Rotate}RegDef[rPPW,		R,	1]; {Scale}RegDef[rhT,		RH,	1]; {temporary}RegDef[rhVD,		RH,	1]; {BitBlt, ComMapSub}RegDef[rhFunction,	RH,	1]; {BLTLineGray}RegDef[rhdsthigh,	RH,	1]; {ChainBlt}RegDef[rhDestVA,	RH,	1]; {CompressAssist.mc @CLR}RegDef[rhGrTRC,		RH,	1]; {GrayBlt}RegDef[TT,		R,	2]; {temporary}RegDef[divisorHigh,	R,	2]; {Fpt-div: TT}RegDef[Src,		R,	2]; {BitBlt}RegDef[Rbb2,		R,	2]; {BitBlt and TextBlt Rbb2 must equal TT to share MaskTbl}RegDef[Temp,		R,	2]; {BitBlt}RegDef[TempDelta,	R,	2]; {BitBlt}RegDef[rYloc,		R,	2]; {BandBLT paired with u1FFF}RegDef[rLOwriteP,	R,	2]; {BandBLT paired with u1FFF}RegDef[DstBit,		R,	2]; {BLTLineGray}RegDef[rwrdaddh,	R,	2]; {BumpBitAddress}RegDef[rWordB,		R,	2]; {CompressAssist.mc @NextMatchAndDiff}RegDef[bitWidth,	R,	2]; {ComMapSub}RegDef[byteWidth,	R,	2]; {ComMapSub}RegDef[wordWidth,	R,	2]; {ComMapSub}RegDef[rrightreal,	R,	2]; {FlipX}RegDef[rSrcReal,	R,	2]; {Floyd, GrayBlt, Scale}RegDef[rScanLineLength,	R,	2]; {Halftone}RegDef[rNewHToffset,	R,	2]; {Halftone}RegDef[rHalfToneElement,R,	2]; {Halftone: current Halftone element}RegDef[rTextReal,	R,	2]; {LineBreak}RegDef[rSylCount,	R,	2]; {LineBreak}RegDef[dstWidth,	R,	2]; {TrapezoidBlt dst width, bits}RegDef[rhTT,		RH,	2]; {temporary}RegDef[rhType,		RH,	2]; {BitBlt and TextBlt and BandBLT and TrapezoidBLT}RegDef[rhLOwriteP,	RH,	2]; {BandBLT}RegDef[rhrightreal,	RH,	2]; {FlipX}RegDef[rhSrcReal,	RH,	2]; {Floyd, GrayBlt, Scale}RegDef[rhTextReal,	RH,	2]; {LineBreak}RegDef[L,		R,	3]; {* real local frame pointer.lowWord}RegDef[divCount,	R,	3]; {Fpt-div: L - must be saved and restored}RegDef[Dst,		R,	3]; {BitBlt}RegDef[TempBpl,		R,	3]; {BitBlt}RegDef[Rbb3,		R,	3]; {BitBlt and TextBlt and BandBLT}RegDef[rLOwriteV,	R,	3]; {BandBLT}RegDef[rUindex,		R,	3]; {BandBLT}RegDef[rLoop,		R,	3]; {BandBLT}RegDef[rFont,		R,	3]; {BandBLT}RegDef[rSrcLow,		R,	3]; {Floyd: real source address low 16 bits}RegDef[rHTAddrLo,	R,	3]; {Halftone: current Halftone lo addr}RegDef[rMinSpMLength,	R,	3]; {LineBreak: must be saved and restored}RegDef[rSylType,	R,	3]; {LineBreak: must be saved and restored}RegDef[rSylBitLength,	R,	3]; {LineBreak: must be saved and restored}RegDef[rhL,		RH,	3]; {* real local frame (RA, extended by rhL=real rhMDS)}RegDef[rhWho,		RH,	3]; {BitBlt}RegDef[rhLOwriteV,	RH,	3]; {BandBLT}RegDef[rhSrcHi,		RH,	3]; {Floyd: real source address high 5 bits}RegDef[rhHTAddrHi,	RH,	3]; {Halftone: current Halftone hi addr}RegDef[G,		R,	4]; {* real global frame pointer.lowWord}RegDef[divResult,	R,	4]; {Fpt-div: G - must be saved and restored}RegDef[SrcA,		R,	4]; {BitBlt}RegDef[Rbb4,		R,	4]; {BitBlt and TextBlt and BandBLT}RegDef[rNlines,		R,	4]; {BandBLT}RegDef[rReadP,		R,	4]; {BandBLT}RegDef[rDstLow,		R,	4]; {Floyd: real destination address low 16 bits}RegDef[rSrcPixel,	R,	4]; {Halftone: current source pixel}RegDef[rMinSpPLength,	R,	4]; {LineBreak: must be saved and restored}RegDef[rFit,		R,	4]; {LineBreak: must be saved and restored}RegDef[rSylByteCount,	R,	4]; {LineBreak: must be saved and restored}RegDef[rhG,		RH,	4]; {* global frame (RA, extended by rhG=real rhMDS)}RegDef[rhSrcA,		RH,	4]; {BitBlt}RegDef[rhReadP,		RH,	4]; {BandBLT}RegDef[rhDstHi,		RH,	4]; {Floyd: real destination address high 5 bits}RegDef[PC,		R,	5]; {* word address of real next Instruction pointer}  RegDef[DstA,		R,	5]; {BitBlt}RegDef[rReadV,		R,	5]; {BandBLT}RegDef[rDest,		R,	5]; {BandBLT}RegDef[rJunk,		R,	5]; {BandBLT--paired with uCurrentLevelCmd, but only to do u ¬ r xor ~r}RegDef[rErrLow,		R,	5]; {Floyd: real error address low 16 bits}RegDef[rWhiteSpaceIncr,	R,	5]; {LineBreak: must be saved and restored}RegDef[rMinWidth,	R,	5]; {LineBreak: must be saved and restored}RegDef[rhPC,		RH,	5]; {* word address of real next Instruction pointer}RegDef[rhDstA,		RH,	5]; {BitBlt}RegDef[rhReadV,		RH,	5]; {BandBLT}RegDef[rhDest,		RH,	5]; {BandBLT}RegDef[rhErrHi,		RH,	5]; {Floyd: real error address hi 5 bits}RegDef[Rx,		R,	6];RegDef[divisorLow,	R,	6]; {Fpt-div: Rx}RegDef[Lcount,		R,	6]; {BitBlt}RegDef[TempB,		R,	6]; {BitBlt}RegDef[rRealDest,	R,	6]; {BLTLineGray}RegDef[rCurRefWordRA,	R,	6]; {CompressAssist.mc @NextMatchAndDiff}RegDef[rDestRA,		R,	6]; {CompressAssist.mc @CLR}RegDef[SrcBit,		R,	6]; {CountBits}RegDef[rleftreal,	R,	6]; {FlipX}RegDef[rTT,		R,	6]; {Floyd: temp R register} RegDef[rDstReal,	R,	6]; {Floyd, GrayBlt, Scale}RegDef[rHTOffset,	R,	6]; {Halftone: current Halftone offset}RegDef[rArgReal,	R,	6]; {LineBreak}RegDef[rCacheObj,	R,	6]; {LineBreak}RegDef[RtbChar,		R,	6]; {TextBlt Character pointed to by TextLo,Hi[Index]}RegDef[srcBitOffset,	R,	6]; {TrapezoidBlt gray brick bit offset}RegDef[TzbUpdVar,	R,	6]; {TrapezoidBlt update loop variables reg.}RegDef[rhRx,		RH,	6]; {temporary}RegDef[rhRet,		RH,	6]; {BitBlt}RegDef[rhRealDest,	RH,	6]; {BLTLineGray}RegDef[rhCurRefWordRA,	RH,	6]; {CompressAssist.mc @NextMatchAndDiff}RegDef[rhDestRA,	RH,	6]; {CompressAssist.mc @CLR}RegDef[rhleftreal,	RH,	6]; {FlipX}RegDef[rhDstReal,	RH,	6]; {Floyd, GrayBlt, Scale}RegDef[rhArgReal,	RH,	6]; {LineBreak}RegDef[rhCacheObj,	RH,	6]; {LineBreak}RegDef[r0100,		R,	7]; {** constant for jump/refill code, also used by BandBlt.}RegDef[rOldErrorLow,	R,	7]; {Floyd: previous pixel location in real error buffer}RegDef[rGr00FF,		R,	7]; {GrayBlt: must restore to 0100 at int/fault/exit}RegDef[rCtMinusIx,	R,	7]; {LineBreak: must restore to 0100 at exit}RegDef[rhOldErrorHi,	RH,	7]; {Floyd: previous pixel location in real error buffer}RegDef[rIORgn,		R,	8]; {** Memory locking}RegDef[rhIORgn,		RH,	8]; {** Memory locking}RegDef[rTemp,		R,	9]; {BandBLT, GrayBlt, Scale}RegDef[bitnum,		R,	9]; {BumpBitAddress}RegDef[DBit,       	R,	9]; {ComMapSub}RegDef[DByte,       	R,	9]; {ComMapSub}RegDef[rCurRefWordVA,	R,	9]; {CompressAssist.mc}RegDef[rDupStartVA.lowByte,R,	9]; {CompressAssist.mc}RegDef[rEvenOdd,	R,	9]; {CompressAssist.mc}RegDef[rwork,		R,	9]; {FlipX}RegDef[rTT3,		R,	9]; {Floyd: temp R register}RegDef[rDstOrgWord,	R,	9]; {Halftone: current original dest word}RegDef[rBitLength,	R,	9]; {LineBreak}RegDef[rDstVirt,	R,	9]; {Rotate}RegDef[Tzbtmp,		R,	9]; {TrapezoidBlt temporary}RegDef[rhTemp,		RH,	9]; {BandBLT, GrayBlt, Scale}RegDef[rhCurRefWordVA,	RH,	9]; {CompressAssist.mc}RegDef[rhLBHyphenPL,	RH,	9]; {LineBreak}RegDef[rtmpadd,		R,	0B]; {BumpBitAddress}RegDef[rchainbasel,	R,	0B]; {ChainBlt}RegDef[Regb,       	R,	0B]; {ComMapSub}RegDef[rTopOfNextPg.Low,R,	0B]; {CompressAssist.mc}RegDef[rByteMask,	R,	0B]; {CompressAssist.mc}RegDef[rData,		R,	0B]; {CompressAssist.mc}RegDef[rcheck,		R,	0B]; {FlipX}RegDef[rTT4,		R,	0B]; {Floyd: temp R register} RegDef[rVirtualL,	R,	0B]; {FlipX, Floyd, GrayBlt, LineBreak, Scale}RegDef[rGrSrcTemp,	R,	0B]; {GrayBlt}RegDef[rDstPixel,	R,	0B]; {Halftone: current dest pixel}RegDef[rByteCount,	R,	0B]; {LineBreak}RegDef[rSrcVirt,	R,	0B]; {Rotate}RegDef[dstBitAdjust,	R,	0B]; {TrapezoidBlt dst bit adjustment}RegDef[TzbAnother,	R,	0B]; {TrapezoidBlt working register}RegDef[rhchainbaseh,	RH,	0B]; {ChainBlt}RegDef[rhVirtualH,	RH,	0B]; {FlipX, Floyd, GrayBlt, LineBreak, Scale}RegDef[rhGrSrcTemp,	RH,	0B]; {GrayBlt}RegDef[rhSrcVirt,	RH,	0B]; {Rotate}RegDef[SourceData,	R,	0C]; {BLTLineGray}RegDef[rtmpbit,		R,	0C]; {BumpBitAddress}RegDef[writebit,	R,	0C]; {ChainBlt}RegDef[BARealALo,	R,	0C]; {ComMapSub}RegDef[rTopOfCurrentPg.Low,R,	0C]; {CompressAssist.mc}RegDef[rByte,		R,	0C]; {CompressAssist.mc}RegDef[Data,		R,	0C]; {CountBits, Scale}RegDef[rcount,		R,	0C]; {FlipX}RegDef[rGrFF00,		R,	0C]; {GrayBlt}RegDef[rAddrLo,		R,	0C]; {Halftone: current real lo addr}RegDef[rSpCount,	R,	0C]; {LineBreak: paired with rhSuffixChar}RegDef[wordCount,	R,	0C]; {Rotate: linked with rhDstVirt for fast map loop}RegDef[BARealAHi,	RH,	0C]; {ComMapSub}RegDef[rhGrDispCond,	RH,	0C]; {GrayBlt}RegDef[rhAddrHi,	RH,	0C]; {Halftone: current real hi addr}RegDef[rhSuffixChar,	RH,	0C]; {LineBreak: paired with rSpCount}RegDef[rhDstVirt,	RH,	0C]; {Rotate: linked with wordCount for fast map loop}RegDef[Rio,		R,	0E];RegDef[temp,	        R,      0E]; {BLTLineGray}RegDef[rwrdaddl,	R,	0E]; {BumpBitAddress}RegDef[rchaintemp,	R,      0E]; {ChainBlt}RegDef[rworkR,		R,	0E]; {FlipX}RegDef[rThisCell,	R,	0E]; {Floyd: R Register of UThisCell}RegDef[rSumHigh,	R,	0E]; {GrayBlt}RegDef[rDstWord,	R,	0E]; {GrayBlt}RegDef[rMaskN,		R,	0E]; {GrayBlt}RegDef[rDstBitCount,	R,	0E]; {Halftone: current dst bit offset}RegDef[rWhiteSpace,	R,	0E]; {LineBreak}RegDef[bitCount,	R,	0E]; {Rotate}RegDef[srcData,		R,	0E]; {Rotate}RegDef[rPixelCount,	R,	0E]; {Scale}RegDef[srcWrdOffset,	R,	0E]; {TrapezoidBlt source word offset in bits}RegDef[rhRio,		RH,	0E];RegDef[rHE,	        RH,     0E]; {BLTLineGray}RegDef[rhDstWord,	RH,	0E]; {GrayBlt}RegDef[rhLBFlags,	RH,	0E]; {LineBreak}{REGISTER A: Kernel}RegDef[rMailBox,	R,	0A]; {**}RegDef[rHMailBox,	RH,	0A]; {**}{REGISTER D: Interrupt processing}RegDef[rInt,		R,	0D]; {**}RegDef[rhInt,		RH,	0D];{REGISTER F: Kernel}RegDef[rK,		R,	0F]; {**}RegDef[RHrK,		RH,	0F]; {**}{U REGISTER DEFINITIONSRegisters indicated by ** contain Emulator state and must not be modified.}{U REGISTER BLOCK 0 -- EMULATOR STACK}RegDef[uyBlk0,		UY,	0]; {BandBLT AltUaddr addressing}RegDef[uyStack,		UY,	0]; {GrayBltSubs AltUaddr addressing}RegDef[uBlock0,		U,	0]: {**}RegDef[uStack1,		U,	1]; {**}RegDef[uStack2,		U,	2]; {**}RegDef[UBitBltArg,	U,	2]; {BitBlt}RegDef[Urleft,		U,	2]; {FlipX}RegDef[uArgVL,		U,	2]; {Floyd: arg. pointer into virtual space (low 16 bits)}RegDef[uCount,		U,	2]; {Floyd: number of input pixels}RegDef[uGrDstLow,	U,	2]; {GrayBlt}RegDef[uGrSumLow,	U,	2]; {GrayBlt}RegDef[uHTsrcLo,	U,	2]; {Halftone: source pointer lo}RegDef[uSBTGDstVALow,	U,	2]; {Scale}RegDef[UDtzVALo,	U,	2]; {TrapezoidBlt lower Dst VAddr}RegDef[UTrapezBltArgLo,	U,	2]; {TrapezoidBlt argument pointer lo}RegDef[uStack3,		U,	3]; {**}RegDef[UHeight,		U,	3]; {BitBlt}RegDef[Urhleft,		U,	3]; {FlipX}RegDef[uArgVH,		U,	3]; {Floyd: arg. pointer into virtual space (high 8 bits)}RegDef[uThreshAndMax,	U,	3]; {Floyd: threshold and max value}RegDef[uGrDstHigh,	U,	3]; {GrayBlt}RegDef[uGrSumHigh,	U,	3]; {GrayBlt}RegDef[uHTsrcHi,	U,	3]; {Halftone: source pointer hi}RegDef[uSBTGDstVAHigh,	U,	3]; {Scale}RegDef[UdstBpl,		U,	3]; {TrapezoidBlt dst bits per line}RegDef[UTrapezBltArgHi,	U,	3]; {TrapezoidBlt argument pointer hi}RegDef[uStack4,		U,	4]; {**}RegDef[UDstVALo,	U,	4]; {BitBlt}RegDef[Uwidth,		U,	4]; {FlipX}RegDef[uSaveINWrd,	U,	4]; {Floyd: save input word containing 2 pixels}RegDef[uGrDstBit,	U,	4]; {GrayBlt}RegDef[uGrDstByte,	U,	4]; {GrayBlt}RegDef[uHTsrcByteOffset,U,	4]; {Halftone: source byte offset}RegDef[uSBTGDstByte,	U,	4]; {Scale}RegDef[UStzVALo,	U,	4]; {TrapezoidBlt lower Src VAddr}RegDef[uStack5,		U,	5]; {**}RegDef[UDstBit,		U,	5]; {BitBlt}RegDef[uInPtrVH,	U,	5]; {Floyd: ptr. to input gray scale data in virtual space (high 8 bits) }RegDef[uGrDstBPL,	U,	5]; {GrayBlt}RegDef[uHTscanLineLength,U,	5]; {Halftone: scan line length}RegDef[uSBTGSrcVALow,	U,	5]; {Scale}RegDef[UrhTzbVSD,	U,	5]; {TrapezoidBlt higher Src and Dst VAddr}RegDef[uStack6,		U,	6]; {**}RegDef[USrcVALo,	U,	6]; {BitBlt}RegDef[uInPtrVL,	U,	6]; {Floyd: ptr. to input gray scale data in virtual space (low 16 bits) }RegDef[uGrSrcLow,	U,	6]; {GrayBlt}RegDef[uHTlineLo,	U,	6]; {Halftone: cell line pointer lo}RegDef[uSBTGSrcVAHigh,	U,	6]; {Scale}RegDef[UXMinValFrac,	U,	6]; {TrapezoidBlt interpolator}Set[xMinValFrac, 6];		    {for BandBLT AltUaddr addressing}RegDef[uStack7,		U,	7]; {**}RegDef[USrcBit,		U,	7]; {BitBlt}RegDef[uOutPtrVH,	U,	7]; {Floyd: pointer to output bit data in virtual space (high 8 bits) }RegDef[uGrSrcHigh,	U,	7]; {GrayBlt}RegDef[uHTlineHi,	U,	7]; {Halftone: cell line pointer hi}RegDef[uSBTGSrcBit,	U,	7]; {Scale}RegDef[UXMinValInt,	U,	7]; {TrapezoidBlt interpolator}Set[xMinValInt, 7];		    {for BandBLT AltUaddr addressing}RegDef[uStack8,		U,	8]; {**}RegDef[UGray,		U,	8]; {BitBlt -- shares with USrcBpl}RegDef[USrcBpl,		U,	8]; {BitBlt -- shares with UGray}RegDef[uOutPtrVL,	U,	8]; {Floyd: pointer to output bit data in virtual space (low 16 bits)}RegDef[uGrSrcByte,	U,	8]; {GrayBlt}RegDef[uHTlineLength,	U,	8]; {Halftone: cell line length}RegDef[uSBTGSrcBPL,	U,	8]; {Scale}RegDef[UXMindValFrac,	U,	8]; {TrapezoidBlt interpolator}RegDef[uStack9,		U,	9]; {**}RegDef[UDstBpl,		U,	9]; {BitBlt}RegDef[uErrorPtrVH,	U,	9]; {Floyd: pointer to error data in virtual space (high 8 bits)}RegDef[uGrSrcBPL,	U,	9]; {GrayBlt}RegDef[uHTlineOffset,	U,	9]; {Halftone: offset into cell line}RegDef[uSBTGPixelCount,	U,	9]; {Scale}RegDef[UXMindValInt,	U,	9]; {TrapezoidBlt interpolator}RegDef[uStackA,		U,	0A]; {**}RegDef[UrhVS,		U,	0A]; {BitBlt}RegDef[uErrorPtrVL,	U,	0A]; {Floyd: pointer to error data in virtual space (low 16 bits)}RegDef[uGrWidth,	U,	0A]; {GrayBlt}RegDef[uHTdstLo,	U,	0A]; {Halftone: dest. pointer lo}RegDef[uSBTGScale,	U,	0A]; {Scale}RegDef[UXMaxValFrac,	U,	0A]; {TrapezoidBlt interpolator}RegDef[uStackB,		U,	0B]; {**}RegDef[UrhVD,		U,	0B]; {BitBlt}RegDef[uBit,		U,	0B]; {Floyd: Bit-address of output pixel (only used on PF returns)}RegDef[uGrHeight,	U,	0B]; {GrayBlt}RegDef[uHTdstHi,	U,	0B]; {Halftone: dest. pointer hi}RegDef[uSBTGLineCount,	U,	0B]; {Scale: fZ = ¬RH}RegDef[UXMaxValInt,	U,	0B]; {TrapezoidBlt interpolator}RegDef[uStackC,		U,	0C]; {**}RegDef[UFlags,		U,	0C]; {BitBlt}RegDef[uFWDError,	U,	0C]; {Floyd: forward error}RegDef[uGrFlags,	U,	0C]; {GrayBlt}RegDef[uGrThreshold,	U,	0C]; {GrayBlt}RegDef[uHTdstBitOffset,	U,	0C]; {Halftone: dest. bit offset}RegDef[uSBTGSrcBitWidth,U,	0C]; {Scale}RegDef[UXMaxdValFrac,	U,	0C]; {TrapezoidBlt interpolator}RegDef[uStackD,		U,	0D]; {**}RegDef[UWidth,		U,	0D]; {BitBlt}RegDef[uRTError,	U,	0D]; {Floyd: right error}RegDef[uGrTRCLow,	U,	0D]; {GrayBlt}RegDef[uGrDstWord,	U,	0D]; {GrayBlt}RegDef[uHTinvertReq,	U,	0D]; {Halftone: invert dest. boolean}RegDef[UXMaxdValInt,	U,	0D]; {TrapezoidBlt interpolator}Set[xMaxdValInt, 0D];		     {for BandBLT AltUaddr addressing}Set[xMaxdValIntPlus1, Add[xMaxdValInt,1]]; {for BandBLT AltUaddr addressing}RegDef[uStackE,		U,	0E]; {**}RegDef[uMIDError,	U,	0E]; {Floyd: middle error}RegDef[uGrTRCHigh,	U,	0E]; {GrayBlt}RegDef[UTzbFlags,	U,	0E]; {TrapezoidBlt flags}RegDef[uStackF,		U,	0F]; {**}RegDef[uSTKMisc,	U,	0F]; {Floyd: Misc. values for interrupt/fault handling}RegDef[UTzbHeight,	U,	0F]; {TrapezoidBlt object height, rA = Rbb0 = 0}{U REGISTER BLOCK 1 -- EMULATOR}RegDef[uHeaderBlock,	UY,	1]:RegDef[uBlock1,		U,	10]:RegDef[uWP,		U,	10]; {** wakeups pending, rA = T}RegDef[UvC,		U,	11]; {** rA = T low half of code (VA, extended by UvChigh)}RegDef[UBrkByte,	U,	12]; {**}RegDef[uPPMask,		U,	13]; {** rA = T, constant = E000}RegDef[uWW,		U,	14];RegDef[UtbWidth,	U,	14]; {TextBlt temporary}RegDef[u3FFF,		U,	15]; {** constant, rA = T}RegDef[uPMask,		U,	16]; {** rA = T; constant = 1FF8}RegDef[UXferType,	U,	17]; {type of Xfer in progress}RegDef[UtbRgFlags,	U,	17]; {TextBlt Used to save RgFlags[Char], rA = T}RegDef[uHighHalf1,	U,	17]; {Fpt: rA = T}RegDef[uWDC,		U,	18]; {** wakeup disable counter}RegDef[uFrame,		U,	19]; {rA = T}RegDef[UGsave,		U,	19];RegDef[uLowHalf1,	U,	19]; {Fpt: rA = T}RegDef[uDestLo,		U,	1A]; {rA = T; destination link of Xfer in progress}RegDef[UtbCount,	U,	1A]; {TextBlt Count parameter, rA = T fZ = ErrnIBnStkp}RegDef[uPsbLink,	U,	1B]; {rA = T, fZ = ¬RH}RegDef[UvLPhigh,	U,	1B];RegDef[uHighHalf2,	U,	1B]; {Fpt: rA = T}RegDef[uHighRem,	U,	1B]; {Fpt: rA = T}RegDef[uT,		U,	1C]; {rA = T}RegDef[uLowHalf2,	U,	1C]; {Fpt: rA = T}RegDef[uLowRem,		U,	1C]; {Fpt: rA = T}RegDef[uTemp,		U,	1D]; {rA = T, fZ = ¬ib}RegDef[UtbArgPtr,	U,	1D]; {TextBlt ArgPtr parameter from Stack, rA = T, }RegDef[uExp1,		U,	1D]; {Fpt: Fpt: rA = T}RegDef[uGFI,		U,	1E]; {**rA = T; global frame index}RegDef[uExp2,		U,	1F]; {Fpt: rA = T}RegDef[uHighTempRoot,	U,	1F]; {Fpt: rA = T}RegDef[uDestHighSave,	U,	1F]; {Block}{U REGISTER BLOCK 2 -- EMULATOR}RegDef[uBlock2,		U,	20]:RegDef[UvGhigh,		U,	20]; {** rA = TT, high part of global frame  (VA)}RegDef[UvG,		U,	21]; {** rA = TT, global frame address  (VA)}RegDef[UvChigh,		U,	22]; {** rA = TT, high address bits of code segment (VA)}RegDef[UvMDS,		U,	23]; {** rA = TT; MDS pointer (VA)}RegDef[uSourceHighSaveTemp,U,	24];	{Block}RegDef[uTT,		U,	24]; {rA = TT; Temp}{	The following must match corresponding definition in StartMesa.  }RegDef[uStickyReg,	U,	24]; {Fpt: part of processor state, 	[0] is non zero if fpt micro code should trap on inexact result, and 	[15] is non zero if there has been a non trapped inexact result}RegDef[UtbIndex,	U,	25]; {TextBlt Index parameter from Stack, rA = TT}RegDef[uStickyBit,	U,	25]; {Fpt: rA = TT}RegDef[uFaultParm0,	U,	26]; {** rA = TT; fault parameter}RegDef[uTTemp,		U,	27]; {rA = TT}RegDef[uSourceHighSave,	U,	27]; {rA = TT = 2. }RegDef[uSign1,		U, 	27]; {Fpt: rA = TT}RegDef[uPCCross,	U,	28]; {**}RegDef[uTrapParm0,	U,	29]; {**}RegDef[uTicks,		U,	2A]; RegDef[uDestHi,		U,	2A];RegDef[UtbMicaPos,	U,	2A]; {TextBlt parameter, rA = TT, fZ = ErrnIBnStkp}RegDef[uSign2,		U,	2A]; {Fpt: rA = TT}RegDef[UvL,		U,	2B]; {** rA = TT, fZ = ¬RH; local frame address  (VA)}RegDef[Ufsi,		U,	2C]; {rA = TT; temp used in Xfer}RegDef[UvPCpage,	U,	2D]; {** rA = TT, fZ = ¬ib; (PC page address)}RegDef[uSourceLo,	U,	2E]; {rA = TT}RegDef[u7FF,		U,	2F]; {** constant}{U REGISTER BLOCK 3 -- EMULATOR}RegDef[uBlock3,		U,	30];RegDef[uLastInkLOwritten,U,	30]; {** BandBLT -- rA = rLoop}RegDef[uDivCount,	U,	31]; {Fpt: divCount = L}RegDef[uSqrtCount,	U,	31]; {Fpt: divCount = L}RegDef[UQSave,		U,	31]; {BitBlt temp}	RegDef[uStackPSave,	U,	31]; {used by Block rA = L = 3}  RegDef[uPTC,		U,	32]; {** Process Tick Count}RegDef[uStkDepth,	U,	33]; {temp in Process, Xfer}RegDef[UWidthM1,	U,	34]; {BitBlt temp}RegDef[Umask1,		U,	35]; {BitBlt temp}	RegDef[u1FFF,		U,	36]; {** constant}RegDef[uFaultParm1,	U,	37]; {fault parameter}RegDef[Umask2,		U,	37]; {BitBlt temp}	RegDef[UmaskL,		U,	38]; {BitBlt temp}	RegDef[uPSB,		U,	39]; {** Current PSB}RegDef[ULsave,		U,	3A]; {rA = L = 3. fZ = ErrnIBnStkp = A}RegDef[UrL,		U,	3B]; {rA = L, fZ = ¬RH}RegDef[UrhLsave,	U,	3B]; {bank 3, 'B' = ¬ rh }		RegDef[UrLHi,		U,	3C];RegDef[UtbFlags,	U,	3D]; {** TextBlt constant = 6400}RegDef[uCrSaveStkp,	U,	3E]; {**}RegDef[uTickCount,	U,	3F]; {** process tick interval}{U REGISTER BLOCK 4 -- EMULATOR}RegDef[uBlock4,		U,	40]:RegDef[uCrSaveTOS,	U,	40]; {**}RegDef[uCrSavePC,	U,	41]; {**}RegDef[UvQ1Hi,		U,	42];RegDef[UXsave,		U,	42]; {BitBlt temp}RegDef[uDivResult,	U,	42]; {Fpt: divResult = G}RegDef[uLowTempRoot,	U,	42]; {Fpt}RegDef[UvQ1,		U,	43];RegDef[UVSsave,		U,	43]; {BitBlt temp}RegDef[UvQ2Hi,		U,	44];RegDef[USrcVALoSav,	U,	44]; {BitBlt temp}RegDef[UvQ2,		U,	45]; {rA = G}RegDef[UtbNewMicaPos,	U,	45]; {TextBlt temp}RegDef[UvQTempHi,	U,	46];RegDef[UvQTemp,		U,	47];RegDef[uIntLevel,	U,	48]; {rA = G; used in interrupts}RegDef[UrhMDSsave,	U,	49];RegDef[UtbBitPos,	U,	4A]; {TextBlt BitPos parameter, rA = G, fZ = ErrnIBnStkp}RegDef[UrG,		U,	4B]; {rA = G, fZ = ¬RH}RegDef[UrhGsave,	U,	4B]; {rA = G, fZ = ¬RH}RegDef[UrGHi,		U,	4C];RegDef[uTrapParm1,	U,	4D]; {Xfer trap parameter}RegDef[UtbMicaWidth,	U,	4D]; {TextBlt Used to save MicaWidth[Char]}RegDef[uTrapParm2,	U,	4E]; {Xfer trap parameter}RegDef[uCurrentInkwell,	U,	4F]; {** BandBLT}{U REGISTER BLOCK 5 -- EMULATOR}RegDef[UtbFontData,	UY,	5]; {TextBlt tbFetchFontDataLoop}RegDef[uBlock5,		U,	50];RegDef[UtbHeight,	U,	50]; {TextBlt FontBody 10}RegDef[UtbRasterLo,	U,	51]; {TextBlt FontBody 0}RegDef[UtbRasterHi,	U,	52]; {TextBlt FontBody 1}RegDef[UtbSpacingWidthLo,U,	53]; {TextBlt FontBody 2}RegDef[UtbSpacingWidthHi,U,	54]; {TextBlt FontBody 3}RegDef[UtbPrinterWidthLo,U,	55]; {TextBlt FontBody 4}RegDef[UtbPrinterWidthHi,U,	56]; {TextBlt FontBody 5}RegDef[UtbFlagsLo,	U,	57]; {TextBlt FontBody 6}RegDef[UtbFlagsHi,	U,	58]; {TextBlt FontBody 7}RegDef[UtbRasterInfoLo,	U,	59]; {TextBlt FontRecord 8}RegDef[UtbRasterInfoHi,	U,	5A]; {TextBlt FontRecord 9}RegDef[UrPC,		U,	5B]; {rA = PC, fZ = ¬RH}RegDef[UrhPCsave,	U,	5B]; {rA = PC, fZ = ¬RH}RegDef[UrPCHi,		U,	5C];RegDef[UDstVALoSav,	U,	5C]; {BitBlt temp}RegDef[UreturnPC,	U,	5D]; {rA = PC, fZ = ¬ib}RegDef[UWidthW,		U,	5D]; {BitBlt temp}RegDef[uPCValid,	U,	5E]; {** rA = PC; flag for faults}RegDef[uXTS,		U,	5F]; {** Xfer Trap Status}{U REGISTER BLOCK 6 -- EMULATOR}RegDef[tbParmBlock,	UY,	6]; {TextBlt tbFetchArgLoop}{All but 61 and 62 are destroyed by TextBlt tbFetchArg}RegDef[uBlock6,		U,	60];RegDef[ULcntsav,	U,	60]; {BitBlt temp rA = Lcount}RegDef[uLBTextRealLo,	U,	60]; {LineBreak}RegDef[uRx,		U,	60]; {Xfer temp rA = Rx}RegDef[u8000,		U,	61]; {** rA = Rx; constant = 8000}RegDef[uPMask2,		U,	62]; {** rA = Rx; constant = 1FF8}RegDef[uib,		U,	63]; {Fpt: rA = Rx}RegDef[uLBArgRealLo,	U,	63]; {LineBreak}RegDef[UtbFunction,	U,	63]; {Function parameter from TextBltArg, must be 63}RegDef[uXferType,	U,	63]; {Type of Xfer, rA = Rx}RegDef[uLBArgRealHi,	U,	64]; {LineBreak}RegDef[UtbLast,		U,	64]; {Last parameter from TextBltArg, must be 64}RegDef[uLBTextCount,	U,	65]; {LineBreak}RegDef[UtbTextLo,	U,	65]; {TextLo parameter from TextBltArg, must be 65}RegDef[uSourceLowSave,	U,	66]; {used by Block rA = Rx = 6}RegDef[uLBCacheLo,	U,	66]; {LineBreak}RegDef[UtbTextHi,	U,	66]; {TextHi parameter from TextBltArg, must be 66}RegDef[uRetC,		U,	66]; {Xfer Temp, rA = Rx}RegDef[uLBCacheHi,	U,	67]; {LineBreak}RegDef[UtbFontLo,	U,	67]; {FontLo parameter from TextBltArg, must be 67}RegDef[uRetPChi,	U,	67]; {Xfer Temp, rA = Rx}RegDef[uLBFont,		U,	68]; {LineBreak}RegDef[UtbFontHi,	U,	68]; {FontHi parameter from TextBltArg, must be 68}RegDef[uLBPendSyl,	U,	69]; {LineBreak}RegDef[UtbDstLo,	U,	69]; {DestLo parameter from TextBltArg, must be 69}RegDef[uSourceOffset,	U,	6A]; {used by Block rA = Rx = 6.  }RegDef[uLBPCtMinusIx,	U,	6A]; {LineBreak}RegDef[UtbDstHi,	U,	6A]; {DestHi parameter from TextBltArg, must be 6A}RegDef[uDestLowSave,	U,	6B]; {Block}RegDef[uLBPMicaLength,	U,	6B]; {LineBreak}RegDef[UtbDstBpl,	U,	6B]; {DestBpl parameter from TextBltArg, must be 6B}RegDef[uLBPBitLength,	U,	6C]; {LineBreak}RegDef[UtbMargin,	U,	6C]; {Margin parameter from TextBltArg, must be 6C}RegDef[uLBPSpCount,	U,	6D]; {LineBreak}RegDef[UtbSpace,	U,	6D]; {TextBlt Space parameter from TextBltArg, must be 6D}RegDef[uLBPByteCount,	U,	6E]; {LineBreak}RegDef[UtbCoordLo,	U,	6E]; {CoordLo parameter from TextBltArg, must be 6E}RegDef[uLBPWhiteSpace,	U,	6F]; {LineBreak}RegDef[UtbCoordHigh,	U,	6F]; {CoordHigh parameter from TextBltArg, must be 6F}{U REGISTER BLOCK 7 -- EMULATOR}RegDef[uBlock7,		U,	70];RegDef[uLO0,		U,	70]; {** BandBLT}RegDef[uOtherInkCmd,	U,	71]; {** BandBLT}RegDef[uOtherVirtPage,	U,	72]; {** BandBLT}RegDef[uInkHigh,	U,	73]; {** BandBLT}RegDef[uInkLow,		U,	74]; {** BandBLT}RegDef[uSaveLOwritePLow,U,	75]; {** BandBLT}RegDef[uSaveList,	U,	76]; {** BandBLT}RegDef[uCurrentLevelCmd,U,	77]; {** BandBLT}RegDef[uOtherListHigh,	U,	78]; {** BandBLT}RegDef[uSaveReadPHigh,	U,	79]; {** BandBLT}RegDef[uCurrentFlags,	U,	7A]; {** BandBLT}RegDef[uSaveReadPLow,	U,	7B]; {** BandBLT}RegDef[uSaveLOwritePHigh,U,	7C]; {** BandBLT}RegDef[uSaveVirtPage,	U,	7D]; {** BandBLT}RegDef[uFPTHigh,	U,	7E]; {** BandBLT}RegDef[uRasterHigh,	U,	7F]; {BandBLT}{U REGISTER BLOCK 8}RegDef[uBlock8,		U,	80]; RegDef[uIORgnHigh,	U,	80]; {** high IORegion real addr, rA = rIORgn}RegDef[uMaintPanel,	U,	81]; {** low address of IORegion maint panel code}RegDef[uMesaProc,	U,	82]; {** low address of IORegion mesa proc. area}RegDef[uVirtPage,	U,	83]; {BandBLT}{RegDef[uFactoruCode,	U,	83];}{a word of bits which can be used to enable/disable microcode instructions. 0 => disabled.  1 => enabled.}RegDef[uRasterLow,	U,	84]; {BandBLT}{RegDef[uTimesWplDisp,	U,	84];}{a value IN [0..16) used to branch off to a specialized routine to calculate the number of words of memory needed for backing the indicated number of display lines.  0 => arbitrary so TRAP to Mesa to handle, 1 => 15" monochrome, 2 => 19" monochrome.}	RegDef[uBitmapMemHigh,	U,	8B]; {** BandBLT}RegDef[uOtherInkwell,	U,	8C]; {** BandBLT}RegDef[uFPTLow,		U,	8D]; {** BandBLT}RegDef[uOtherListLow,	U,	8E]; {** BandBLT}RegDef[uOtherFlags,	U,	8F]; {** BandBLT}{U REGISTER BLOCK 9}RegDef[uyBlk,		UY,	9]; {BandBLT}RegDef[uBlock9,		U,	90];RegDef[uLastLevelLOwritten,U,	90]; {** BandBLT}RegDef[uBitmapMemLow,	U,	91]; {** BandBLT}RegDef[uRetPage,	U,	92]; {** BandBLT}RegDef[uRetWord,	U,	93]; {** BandBLT}RegDef[uLO1,		U,	94]; {** BandBLT, rA = rTemp = 9}RegDef[uLO2,		U,	95]; {** BandBLT, rA = rTemp = 9}RegDef[uOtherLevelCmd,	U,	96]; {** BandBLT }RegDef[uCurrentInkCmd,	U,	97]; {** BandBLT}RegDef[uLOreadV,	U,	98]; {BandBLT Arg0}RegDef[uBLreadLow,	U,	99]; {BandBLT Arg1}RegDef[uBLreadHigh,	U,	9A]; {BandBLT Arg2}RegDef[uLOwriteV,	U,	9B]; {** BandBLT Arg3}RegDef[uBandBufLow,	U,	9C]; {** BandBLT Arg4}RegDef[uBandBufHigh,	U,	9D]; {** BandBLT Arg5, rA = rTemp = 9}RegDef[uFPTPage,	U,	9E]; {BandBLT Arg6}RegDef[uBitmapMemPage,	U,	9F];	{BandBLT Arg7}{U REGISTER BLOCK A -- KERNEL}RegDef[uBlockA,		U,	0A0];RegDef[UKDispBits,	U,	0AE];RegDef[UKCycleBreakID,	U,	0AF];RegDef[UKSaveDisp,	U,	0AE]; {**}RegDef[UBreakID,	U,	0AF]; {**}{U REGISTER BLOCK B}RegDef[uBlockB,		U,	0B0];RegDef[uIdleCountLow,	U,	0B1]; {** count of times through IdleLoop, low half}RegDef[uIdleCountHigh,	U,	0B2]; {** count of times through IdleLoop, high half}RegDef[uSBTGDstTempLow,	U,	0BC]; {Scale}RegDef[uSBTGDstTempHigh,U,	0BD]; {Scale}RegDef[uSBTGSrcTempLow,	U,	0BE]; {Scale: rA = rVirtualL}RegDef[uSBTGSrcTempHigh,U,	0BF]; {Scale}{U REGISTER BLOCK C -- EMULATOR}RegDef[uBlockC,		U,	0C0];RegDef[uHTlineRealLo,	U,	0C0]; {Halftone: HT line Real Addr lo}RegDef[UtmpHi,		U,	0C0]: {TrapezoidBlt save Source hi virt addr}RegDef[uHTlineRealHi,	U,	0C1]; {Halftone: HT line Real Addr hi}RegDef[UtmpLo,		U,	0C1]: {TrapezoidBlt save Source lo virt addr}RegDef[uHTdstRealLo,	U,	0C2]; {Halftone: Dst Real Addr lo}RegDef[uHTdstRealHi,	U,	0C3]; {Halftone: Dst Real Addr hi}RegDef[uHTsrcRealHi,	U,	0C5]; {Halftone: Src Real Addr hi}RegDef[uHTsrcRealLo,	U,	0CB]; {Halftone: Src Real Addr lo}RegDef[uSBTGHold,	U,	0CB]; {Scale: rA = BARealALo, fZ = ¬RH}{U REGISTER BLOCK D}RegDef[uBlockD,		U,	0D0];{U REGISTER BLOCK E -- EMULATOR}RegDef[uyBlockE,	UY,	0E]; {Rotate: rA = srcData}RegDef[uBlockE,		U,	0E0];RegDef[uPolarity,	U,	0E0]; {Floyd: invert output flag -- rA = rThisCell = 0E}RegDef[uGrCurrSrcLow,	U,	0E0]; {GrayBlt}RegDef[uHTmaskN,	U,	0E0]; {Halftone: pixel mask}RegDef[uByte,		U,	0E1]; {Floyd: Byte-address of input pixel}RegDef[uGrCurrSrcHigh,	U,	0E1]; {GrayBlt}RegDef[uRtnReason,	U,	0E2]; {Floyd: reason for saving state and return type}RegDef[uGrCurrDstLow,	U,	0E2]; {GrayBlt}RegDef[uThreshold,	U,	0E3]; {Floyd: work threshold}RegDef[uGrCurrDstHigh,	U,	0E3]; {GrayBlt}RegDef[uMaxValue,	U,	0E4]; {Floyd: work max value}RegDef[uGrSaveCarry,	U,	0E4]; {GrayBlt}RegDef[uPFlags,		U,	0EB]; {Emulator -- fZ = ¬RH; flags for process}RegDef[uBlockEF,	U,	0EF]; {Rotate: rA = srcData}{U REGISTER BLOCK F -- EMULATOR}RegDef[uBlockF,		U,	0F0];RegDef[UPCsave,		U,	0F0]; {Emulator}RegDef[UrefillType,	U,	0F1]; {BitBlt}RegDef[USavelength,	U,	0F4]; {ChainBlt}RegDef[UdstWidth,	U,	0F4]: {TrapezoidBlt temp storage}RegDef[USavecount,	U,	0F5]; {ChainBlt}RegDef[UyOffset,	U,	0F5]: {TrapezoidBlt yOffset storage }RegDef[USavedstbit,	U,	0F6]; {ChainBlt}RegDef[USavechainbasel,	U,	0F7]; {ChainBlt}RegDef[Urightreal,	U,	0F7]; {FlipX}RegDef[Utmpdstbit,	U,	0F7]: {TrapezoidBlt tmp dst bit offset}RegDef[USavewritebit,	U,	0F8]; {ChainBlt}RegDef[Urhrightreal,	U,	0F8]; {FlipX}RegDef[UtzDstBit,	U,	0F8]: {TrapezoidBlt dst bit offset}RegDef[USavedstlow,	U,	0F9]; {ChainBlt}RegDef[Urright,		U,	0F9]; {FlipX}RegDef[UtzSrcBit,	U,	0F9]: {TrapezoidBlt src bit offset}RegDef[USavechainbaseh,	U,	0FA]; {ChainBlt}RegDef[Urhright,	U,	0FA]; {FlipX}RegDef[USavedsthigh,	U,	0FB]; {ChainBlt}RegDef[Uworkrleft,	U,	0FB]; {FlipX}RegDef[Uworkrhleft,	U,	0FC]; {FlipX}RegDef[UWrkrhVD,	U,	0FC]: {TrapezoidBlt temp higher Dst VAddr}RegDef[USavecheck,	U,	0FD]; {FlipX}RegDef[Urleftreal,	U,	0FE]; {FlipX}RegDef[UWrkrhVS,	U,	0FE]: {TrapezoidBlt temp higher Src VAddr}RegDef[Urhleftreal,	U,	0FF]; {FlipX}	{ End }
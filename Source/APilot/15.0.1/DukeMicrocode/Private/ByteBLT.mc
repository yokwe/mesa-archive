{File name: ByteBLT.mc Description: Mesa Byte Block Transfer op-code Author: SXO Created: Jun 15, 1988 Last edited by SXO: 6-Jul-88 18:47:18: Adds comments. Last edited by TXM: 13-Jul-88 13:15:39: moved to bank2 Last edited by SXO: 22-Aug-88 15:09:11 debug  Last edited by TxH: 13-Sep-88 10:44:50 moved the register-defs into DukeExtras.dfn; added Copyright notice.} {Copyright (C) 1988 by Fuji Xerox Co., Ltd.  All rights reserved.}{RegDef[rSR,			R,	09];RegDef[rSTrans,			R,	09];RegDef[rhSR,			RH,	09];RegDef[rWTransferred,		R,	0B];RegDef[rDstData,		R,	0B];RegDef[rDTrans,		R,	3];{*L}RegDef[rWCount,			R,	0C];RegDef[rBCount,			R,	0C];RegDef[rSrcData,		R,	0E];RegDef[rSrcHighTemp,		R,	0E];RegDef[rDstOffset,		R,	0E];RegDef[rSrcV,			R,	0E];RegDef[uStkPSave,		U,	0E5];RegDef[uCountSave,		U,	0C6];{must be Cx because rWCount(R-0C) is saved}RegDef[uCntSave,		U,	0C7];{number of bytes to transfer}}Set[L0.more1, 0];Set[L0.1word, 1];Set[L0.1byte, 2];Set[L1.SrcMap,	 0];Set[L1.DstWMap,	 7];Set[L1.NoPgCr,	 1];Set[L1.PgCr,	 3];Set[L2.cs0,	 0];Set[L2.cs1,	 1];Set[L2.cs2,	 2];Set[L2.cs3,	 3];Set[L2.cs4,	 4];Set[L2.cs5,	 5];Set[L2.cs6,	 6];Set[L2.cs7,	 7];Set[L0.0000,	 0];Set[L0.0001,	 1];Set[L0.0011,	 3];Set[L0.0100,	 4];Set[L0.0110,	 6];{This module handles Byte Boundary Block Transfer instruction. This instruction moves bytes from the source to the destination in the forward direction(from low to high addresses). Transfer in the backward direction(Byte Block Transfer Reversed) is not impremented in this module. For this instruction, L2 is used to distinguish transfer types as follows. 					L2    Dest    Source  Count   Dest    Source  Trans		      Offset  Offset  (byte)  EndAddr EndAddr Types	case0	0	0	1	0	0	1	B	case1	1	0	1	1	1	0	B	case2	2	0	0	0	0	0	A	case3	3	0	0	1	1	1	A	case4	4	1	0	1	0	1	B	case5	5	1	0	0	1	0	B	case6	6	1	1	1	0	0	A	case7	7	1	1	0	1	1	A							  0..Even, 1..Odd		Transfer Type A			Destination			      Source	     --------------------		--------------------	     	 X    :     Y		¬	    X    :    Y	     --------------------		--------------------	     	Transfer Type B			Destination				Source						--------------------							 :    X	     --------------------		--------------------	     	 X    :     Y		¬	    Y    :    	     --------------------		--------------------       }{******************************************************************************************	BYTBLT  Byte Block Transfer	  	TOS = sourceOffset	   	STK = sourceHigh	   	STK-1 = sourceLow	   	STK-2 = count		STK-3 = destOffset	   	STK-4 = destHigh		STK-5 = destLow******************************************************************************************} 			{	TT, rhTT	: source virtual address high	Rx		: source virtual address low		rhT		: dest virtual address high	T		: dest virtual address low		rhSR		: source real address high		rSR		: source real address low	(R, 9)	rhRx		: dest virtual address high	Rx		: dest virtual address low		TOS		: source offset	rWCount		: count				(R, 0C)	rWTransferred	: words transferred		(R, 0B)	rSrcData	: source data			(R, 0E)}		@BYTBLT:	L ¬ ~ErrnIBnStkp, ULsave ¬ L, 			c1, at[addrByteBLT];		TT ¬ rhTT ¬ STK{srcHi}, pop{srcLow}, 		c2;		Rx ¬ STK{srcLow}, pop{count},  			c3;		Src.Odd:	rWCount ¬ STK{count}, ZeroBr, pop{destOffset}, 	c1;PopSrcOff.BY:	rDstOffset ¬ STK{destOffset}, pop{destHi}, BRANCH[$, IniCnt0.BY],c2;		rhT ¬ STK{destHi}, pop{destLow}, 		c3;				T ¬ STK{destLow}, pop{next}, 			c1;		PC ¬ PC - 1{for restart},			c2;StkPsave.BY:	uStackPSave ¬ L, 				c3;OffsetChk.BY:	Ybus ¬ rDstOffset{dstOffset}, YDisp, rDstOffset ¬ rDstOffset RShift1, SE ¬ 0,	c1;		Ybus ¬ TOS{srcOffset}, YDisp, TOS ¬ TOS RShift1, SE ¬ 0, BRANCH[DstStart.Even, DstStart.Odd, 0E],c2;DstStart.Even: 	Ybus ¬ uCntSave ¬ rWCount{count}, YDisp, BRANCH[Case.2, Case.0, 0E],c3;DstStart.Odd:	Ybus ¬ uCntSave ¬ rWCount{count}, YDisp, BRANCH[Case.4, Case.6, 0E],c3;		{				DstOffset	SrcOffset			Case.0 > (case0, case1)	    0		   1				Case.2 > (case2, case3)	    0		   0			Case.4 > (case4, case5)	    1		   0		 	Case.6 > (case6, case7)	    1		   1										0..Even, 1..Odd } Case.0:		rWCount ¬ rWCount RShift1, SE ¬ 0, BRANCH[Trans.cs0, Trans.cs1, 0E],c1;Case.2:		rWCount ¬ rWCount RShift1, SE ¬ 0, BRANCH[Trans.cs2, Trans.cs3, 0E],c1;Case.4:		rWCount ¬ rWCount RShift1, SE ¬ 0, BRANCH[Trans.cs5, Trans.cs4, 0E],c1;Case.6:		rWCount ¬ rWCount RShift1, SE ¬ 0, BRANCH[Trans.cs7, Trans.cs6, 0E],c1;{case0}Trans.cs0:	L2 ¬ L2.cs0,						c2;		GOTO[Check1W.BY], 					c3;{case1}Trans.cs1:	[] ¬ rWCount, ZeroBr,  L2 ¬ L2.cs1, 			c2;		BRANCH[Check1W.BY, CntIs1by.BY], 			c3;{case2}Trans.cs2:	L2 ¬ L2.cs2,						c2;		GOTO[Check1W.BY], 					c3;{case3}	Trans.cs3:	[] ¬ rWCount, ZeroBr,  L2 ¬ L2.cs3,			c2;		BRANCH[Check1W.BY, CntIs1by.BY], 			c3;{case4}	Trans.cs4:	[] ¬ rWCount, ZeroBr,  L2 ¬ L2.cs4,			c2;		BRANCH[Check1W.BY, CntIs1by.BY], 			c3;{case5}		Trans.cs5:	L2 ¬ L2.cs5,						c2;		rWCount ¬ rWCount - 1, ZeroBr, GOTO[Check1W.BY], 	c3;{case6}	Trans.cs6:	[] ¬ rWCount, ZeroBr,  L2 ¬ L2.cs6,			c2;		BRANCH[Check1W.BY, CntIs1by.BY], 			c3;{case7}	Trans.cs7:	L2 ¬ L2.cs7,						c2;		rWCount ¬ rWCount - 1, ZeroBr, GOTO[Check1W.BY], 	c3;		Check1W.BY:	L0 ¬ L0.more1, BRANCH[$, CntIs1W.BY],			c1;		L ¬ 0FF, GOTO[SrcLow.BY],{L0 = L0.more1} 		c2;		{Come here if Initial Count = 2(byte) in case5, case7}	CntIs1W.BY:	L ¬ 0FF, GOTO[SrcLow.BY],{L0 = L0.1word}		c2;						{Come here if Initial Count = 1(byte) in case1, case3, case4, case6.}CntIs1by.BY:	L0 ¬ L0.1byte,   					c1;		L ¬ 0FF, GOTO[SrcLow.BY],{L0 = L0.1byte}		c2;									SrcLow.BY:	Rx ¬ Rx{srcLow} + TOS{srcOffset(W)}, CarryBr, 		c3;InitSrcCarry.BY:BRANCH[NoSrcCarry.BY, SrcCarry.BY],			c1;SrcCarry.BY:	TT ¬ TT + 1,						c2;		rhTT ¬ TT LRot0, GOTO[InitSrcCarry.BY],			c3;		NoSrcCarry.BY:	T ¬ T{dstLow} + rDstOffset, CarryBr,			c2;InitDstCarry.BY:L2Disp, BRANCH[AddrChk.BY, DstCarry.BY],		c3;		DstCarry.BY:	Q ¬ rhT + 1, LOOPHOLE[byteTiming], CANCELBR[$, 0F],	c1;		rhT ¬ Q LRot0, GOTO[InitDstCarry.BY],			c2;{Kokodeha Transfer ga ripple ni narukadouka no check wo okonatteiru. Check ha case0, case1, case4, case5 no baainomi okonatte ori, sonota no baaini tsuiteha okonatte inai}AddrChk.BY:	Q ¬ rhT{dstHi},DISP4[CheckAddr, 9],			c1;		[] ¬ T - Rx - 1, ZeroBr, GOTO[HiAddrChk.BY],	c2, at[9,10,CheckAddr];		[] ¬ T - Rx, ZeroBr, GOTO[HiAddrChk.BY],	c2, at[0D,10,CheckAddr];		L5 ¬ 0E, GOTO[NotChkAddr],			c2, at[0B,10,CheckAddr];		L5 ¬ 0E, GOTO[NotChkAddr],			c2, at[0F,10,CheckAddr];NotChkAddr:	GOTO[SrcMap.BY],				c3;				HiAddrChk.BY:	[] ¬ Q - TT, ZeroBr, L5 ¬ 0E, BRANCH[SrcMap.BY, LowEq.BY],	c3;LowEq.BY:	L5 ¬ 0E, BRANCH[HiNotEq.BY, HiEq.BY],				c1;HiNotEq.BY:	GOTO[NotChkAddr],			c2;HiEq.BY:	GOTO[NotChkAddr],			c2;{****************************************************************************				Mapping ****************************************************************************}SrcMap.BY:	Map ¬ Q ¬ [rhTT, Rx], CANCELBR[$, 0F], 		c1;SrcHiSave.BY:	uSourceHighSaveTemp ¬ TT, rSrcV ¬ Q, L1 ¬ L1.SrcMap,	c2;		rSR ¬ rhSR ¬ MD, XRefBr, uSourceLowSave ¬ Rx,	c3;at[L1.SrcMap,10,RLMF.BY]		DstMap.BY:	Map ¬ [rhT, T], BRANCH[SetSrcRef.BY, SrcMapOk.BY, 0E], c1;SrcMapOk.BY:	Q ¬ rhT, L1 ¬ L1.DstWMap,			c2; DstWr.BY:	rhRx ¬ Rx ¬ MD, XWtOKDisp, GOTO[DstWrChk],	c3;at[L1.DstWMap,10,WLMF.BY]DstWrChk:	rhTT ¬ Q LRot0, BRANCH[WrNotOk.BY, WrOk.BY,0D],	c1;WrOk.BY:	TT ¬ uSourceHighSaveTemp, GOTO[PreTrans.BY],	c2;{Come here if source map must be fixed for referenced. Q = virtual sourceLow. rhTT = virtual sourceHi. Set Rx to map data.}SetSrcRef.BY:	Rx ¬ rSR, CANCELBR[RLMapFix.BY, 0F],		c2;{Come here if dest map must be fixed for dirty. Rx = map data. rhTT = virtual destHi. Set Q to virtual destLow.}WrNotOk.BY:	Q ¬ T, CALL[WLMapFix.BY],			c2;	       	       {****************************************************************************				Pre - Transfer ****************************************************************************}PreTrans.BY:	L ¬ 0FF, 					c3;			MAR ¬ rSR ¬ [rhSR, rSrcV + 0], L0Disp,  	c1;		CntSave.BY:	uCountSave ¬ rWCount, L2Disp, BRANCH[$, Do1byteTrans,0D], c2;		rSrcData ¬ MD, DISP4[ModSrcData, 9],		c3;		at[9, 10, ModSrcData]{right..0}{case0, case1}				rSrcData ¬ rSrcData LRot8, GOTO[InitSrcRd.BY],		c1;		at[0D, 10, ModSrcData]{0..left}{case4, case5}				rSrcData ¬ rSrcData LRot8, GOTO[InitDstRd.BY],	c1;		 at[0F, 10, ModSrcData]{0..right}{case6, case7}				rSrcData ¬ rSrcData and L, GOTO[InitDstRd.BY],	c1; at[0B, 10, ModSrcData]{case2, case3} FirstDst.BY:	MAR ¬ Rx ¬ [rhRx, T + 0], GOTO[WrDst.A],	c1;{case0, case1}InitSrcRd.BY:	rSrcData{current} ¬ rSrcData and ~L, L5Disp,	c2;PreSet.BY:	TOS ¬ rSrcData, BRANCH[RdNeSrc.CS0, Copy.CS0,0E],c3;RdNeSrc.CS0:	MAR ¬ rSR ¬ [rhSR, rSR + 1],			c1;		BRANCH[$, IniSrcPgCr.CS0, 1],			c2;		rSrcData ¬ MD,					c3;				rSrcData ¬ rSrcData LRot8,			c1;		Q ¬ rSrcData and L{00FF},			c2;		rSrcData ¬ rSrcData and ~L{FF00},		c3;				MAR ¬ Rx ¬ [rhRx, T + 0], GOTO[WrDst.B],	c1;		{Come here if a difference between Destination Address and Source Address is one in case0, case1. In this case, a source value is propagated throughout a block of storage.}		Copy.CS0:	TOS ¬ rSrcData LRot8, GOTO[ByteCopy.CS0],	c1;ByteCopy.CS0:	rSrcData ¬ TOS or rSrcData, BRANCH[PreTrans.CS0, Trans.CS4, 0B],c2;PreTrans.CS0:	GOTO[PreByteTr.CS0],				c3;Trans.CS4:	GOTO[DuplLoop.BY],				c3;		PreByteTr.CS0:	MAR ¬ Rx ¬ [rhRx, T + 0],			c1;		MDR ¬ rSrcData,					c2;		rWCount ¬ rWCount - 1, ZeroBr, GOTO[DuplLoop.BY],c3;		 IniSrcPgCr.CS0:	Noop,						c3;		MAR ¬ Rx ¬ [rhRx, T + 0], GOTO[JudgePlus.BY],	c1;		{case4, case5, case6, case7}InitDstRd.BY:	Q{next} ¬ rSrcData and ~L,			c2;		rSrcData{current} ¬ rSrcData and L,		c3;					ReadDst.BY:	MAR ¬ Rx ¬ [rhRx, T + 0], 			c1;		rDstData ¬ ~L{FF00},				c2;				rDstData ¬ MD and rDstData{FF00},		c3;				MAR ¬ Rx ¬ [rhRx, T + 0], L5Disp,		c1;		MDR ¬ rSrcData or rDstData, L0Disp, BRANCH[$, Copy.CS4, 0E], c2;		rSrcData ¬ Q, BRANCH[$, CountIs1W.cs5.7, 0E], c3;				MAR ¬ rSR ¬ [rhSR, rSR + 1], MesaIntBr, GOTO[ChkSrc.BY],	c1;{Come here if Initial Count = 2(byte) in case5, case7}CountIs1W.cs5.7:MAR ¬ Rx ¬ [rhRx, Rx + 1], GOTO[IniRdDst.cs5.7],c1;IniRdDst.cs5.7:	L2Disp, BRANCH[$, IniDstPgCr.cs5.7, 1],c2;		rDstData ¬ MD and L{00FF}, BRANCH[IniWrDst.cs5, IniRdSrc.cs7, 0D],c3;		IniWrDst.cs5:	MAR ¬ [rhRx, Rx + 0], GOTO[DestWrite.BY{in Last Transfer}],c1;				IniRdSrc.cs7:	MAR ¬ [rhSR, rSR + 1],				c1;		Q ¬ ~L{FF00}, BRANCH[$, IniSrcPgCr.cs7, 1],	c2;		rSrcData ¬ MD and Q, GOTO[IniWrDst.cs5],	c3;		{Come here if Destination Address equal with Source Address in case4, case5. In this case, a source value is propagated throughout a block of storage.}Copy.CS4:	rSrcData ¬ rSrcData LRot8, BRANCH[$, CntIs1WandC, 0E],c3;		TOS ¬ rSrcData LRot8, L2Disp, GOTO[ByteCopy.CS0],{0..7 = 8..15 bit} c1;		{Come here if initial count = 2(byte), DestAddress = SrcAddress in case5}		CntIs1WandC:	MAR ¬ Rx ¬ [rhRx, Rx + 1], GOTO[IniRdDst.cs5.7],c1;		IniDstPgCr.cs5.7:CANCELBR[Update.dst, 0F],			c3;IniSrcPgCr.cs7:	CANCELBR[Update.src, 0F],			c3;{****************************************************************************			Loop Body for Ripple mode 		A first source byte is duplicated throughout the destination block.			****************************************************************************}{Come here if a difference between Destination Address and Source Address is  one and count is greater than 2-bytes in case0, case1 or if Destination Address equal with Source Address and count is greater than 2-bytes in case4, case5. rSrcData.left and rSrcData.right have been stored from a first source byte, so rSrcData.left = rSrcData.right} DuplLoop.BY:	MAR ¬ Rx ¬ [rhRx, Rx + 1], MesaIntBr, BRANCH[$, ExtDupl.BY],c1;		MDR ¬ rSrcData, DISP2[Dupl.BY],			c2;		rWCount ¬ rWCount - 1, ZeroBr, GOTO[DuplLoop.BY], c3, at[0,4,Dupl.BY];				CANCELBR[Update.dst, 0F],{dest page cross}	c3, at[2,4,Dupl.BY];		CANCELBR[Update.dst, 0F],{interrupt}		c3, at[1,4,Dupl.BY];		CANCELBR[Update.dst, 0F],{dstPgCross and Interrupt}	c3, at[3,4,Dupl.BY];		ExtDupl.BY:	rSrcData ¬ rSrcData and ~L{FF00}, L1 ¬ L1.NoPgCr, BRANCH[NoDupPgCrs.BY, DupPgCrs.BY, 1],c2;NoDupPgCrs.BY:	L2Disp, GOTO[DupCkLstByt],{L1.NoPgCr=1}		c3;DupPgCrs.BY:	L2Disp, GOTO[DupCkLstByt],{L1.PgCr=3}		c3;DupCkLstByt:	MAR ¬ [rhRx, Rx + 0], L1Disp, BRANCH[CountIs0.BY, LstOneByt.BY, 0E],  c1;		{rSrcData ¬ rSrcData and ~L{FF00}, CANCELBR[$,3],c2;		L2Disp, GOTO[ChkLstByt.BY],     		c3;}{****************************************************************************				Loop Body ****************************************************************************}{Come here if Transfer Type is B.}WrDst.B:	MDR ¬ Q or TOS, BRANCH[NoDstWrCrs.BY, DstWrCrs.BY, 1],c2;{Come here if Transfer Type is A.}WrDst.A:	MDR ¬ rSrcData, BRANCH[NoDstWrCrs.BY, DstWrCrs.BY, 1],c2; NoDstWrCrs.BY:	rWCount ¬ rWCount - 1, ZeroBr,GOTO[ReadSrc.BY],	c3;				ReadSrc.BY:	MAR ¬ rSR ¬ [rhSR, rSR + 1], MesaIntBr, BRANCH[ChkSrc.BY, ExtLoop.BY], c1;ChkSrc.BY:	TOS ¬ rSrcData, L2Disp, DISP2[SrcChk.BY],	c2;		rSrcData ¬ MD{source}, L2Disp, BRANCH[SetDat.BY, WNextDst.BY, 0D], c3, at[0, 10, SrcChk.BY];		L2Disp, CANCELBR[Judge.BY, 0F],	c3, at[2, 10, SrcChk.BY];		L2Disp, CANCELBR[Judge.BY, 0F],	c3, at[1, 10, SrcChk.BY];		L2Disp, CANCELBR[Judge.BY, 0F],	c3, at[3, 10, SrcChk.BY];WNextDst.BY:	MAR ¬  Rx ¬ [rhRx, Rx + 1], BRANCH[WrDst.B, WrDst.A, 0D], c1;SetDat.BY:	rSrcData ¬ rSrcData LRot8, CANCELBR[$, 0F],		c1;		Q ¬ rSrcData and L{00FF},		c2;		rSrcData ¬ rSrcData and ~L{FF00}, L2Disp, GOTO[WNextDst.BY],c3;DstWrCrs.BY:	CANCELBR[Update.dst, 0F],		c3;ExtLoop.BY:	L1 ¬ L1.NoPgCr, BRANCH[NoSrcPgCrs.BY, SrcPgCrs.BY, 1],	c2;NoSrcPgCrs.BY:	L2Disp, GOTO[ChkLstByt.BY],{L1.NoPgCr=1}		c3;SrcPgCrs.BY:	L2Disp, GOTO[ChkLstByt.BY],{L1.PgCr=3}		c3;		{****************************************************************************				Last Transfer ****************************************************************************}{If types of transfer are case1 or case3 or case5 or case7,we must move a  remaining byte, because destination ends at in the middle of word. If in case1 or case5, a remaining source data has already been read into  the rSrcData in Loop Body, but if in case3 and case7, a  remaining source  data has not yet been read.}    ChkLstByt.BY:	MAR ¬ Rx ¬ [rhRx, Rx + 1], BRANCH[CountIs0.BY, LstOneByt.BY, 0E],  c1;{Come here if case1, case3, case5, case7}LstOneByt.BY:	L2Disp, BRANCH[NoDstRdPgCrs, DstRdPgCrs, 0D],	c2;NoDstRdPgCrs:	rDstData ¬ MD and L{00FF}, L1Disp, BRANCH[DstWr.cs1.5, SrcRd.cs3.7, 0D],c3;DstWr.cs1.5:	MAR ¬ Rx ¬ [rhRx, Rx + 0], CANCELBR[$,0F],  	c1;DestWrite.BY:	MDR ¬ rDstData or rSrcData,			c2;		GOTO[TrnsDone.BY],				c3;SrcRd.cs3.7:	MAR ¬ [rhSR, rSR + 0], BRANCH[NoPgCr.ls, PgCr.ls, 0D],	c1;NoPgCr.ls:	Q ¬ ~ L{FF00},		c2;		rSrcData ¬ MD and Q, GOTO[DstWr.cs1.5],	c3;DstRdPgCrs:	CANCELBR[Update.dst, 0F],		c3;{Come here if source page cross occur in loop body(case3, case7)}PgCr.ls:	Noop,				c2;		CANCELBR[Update.src, 0F],	c3;		{****************************************************************************			1 Byte Transfer ****************************************************************************}{Come here if count = 1(byte)}Do1byteTrans:	rSrcData ¬ MD, DISP4[SetSrcD.1by, 9],	c3;{come here if DstOffset=Even, SrcOffset=Odd}		Trans1B.0.0:	rSrcData ¬ rSrcData LRot8, GOTO[SetD.cs1],	c1, at[9,10,SetSrcD.1by];{come here if DstOffset=Even, SrcOffset=Even}		Trans1B.0.1:	rSrcData ¬ rSrcData and ~L, GOTO[DstR.1by],	c1, at[0B,10,SetSrcD.1by];{come here if DstOffset=Odd, SrcOffset=Even}		Trans1B.1.0:	rSrcData ¬ rSrcData LRot8, GOTO[SetD.cs2],	c1, at[0D,10,SetSrcD.1by];{come here if DstOffset=Odd, SrcOffset=Odd}		Trans1B.1.1:	rSrcData ¬ rSrcData and L, GOTO[DstR.1by],	c1, at[0F,10,SetSrcD.1by];		SetD.cs1:	rSrcData ¬ rSrcData and ~L, GOTO[DstRPlus1.1by],	c2;SetD.cs2:	rSrcData ¬ rSrcData and L, GOTO[DstRPlus1.1by],	c2;DstR.1by:	Noop,		c2;DstRPlus1.1by:	Noop,		c3;		SrcEve.1by:	MAR ¬ Rx ¬ [rhRx, T + 0], L2Disp,		c1;		Q ¬ ~L{FF00}, BRANCH[DstEve.1by, DstOdd.1by,0B],c2;DstEve.1by:	rDstData ¬ MD and L{00FF},GOTO[DstWr.cs1.5{in Last Transfer}],	c3;DstOdd.1by:	rDstData ¬ MD and Q{FF00},GOTO[DstWr.cs1.5{in Last Transfer}],	c3;{****************************************************************************				Transfer Done  ****************************************************************************}IniCnt0.BY:	pop{destLow}, 					c3;		Bank ¬ bank0, pop{next},			c1;{L has not yet been modified}		NextMop.BY:	TOS ¬ STK, pop, IBDisp, GOTOBANK0[DISPNIonly],	c2;TrnsDone.BY:	Noop,						c1;CountIs0.BY:	L ¬ ULsave, CANCELBR[$,3],			c2;UpdatePC.BY:	PC ¬ PC + 1, 					c3;		Bank ¬ bank0, GOTO[NextMop.BY],			c1;		{TOS ¬ STK, pop, GOTO[IBDispOnly],		c1;}{****************************************************************************		Update Source and Destination Address ****************************************************************************}{Come here if we got a source or dest page cross or an interrupt request. 	TT = uSourceHighSaveTemp  source virtual address high	uSourceLowSave = source virtual address low	rhT = 		dest virtual address high	T = 		dest virtual address low	rDTrans =	distance between current dest and next dest virtual address	rSTrans =	distance between current source and next source virtual address	uStackPSave =	stack pointer at beginning of operation.} 	Update.BY:	Rx ¬ uSourceLowSave, 				c1;				T{destLow} ¬ T + rDTrans, CarryBr,		c2;TestDst.BY:	rhTT ¬ TT LRot0, BRANCH[NoDstCarry.BY, DestCarry.BY],	c3;		DestCarry.BY:	Q ¬ rhT {destHi} + 1, LOOPHOLE[byteTiming],	c1;		rhT ¬ Q LRot0, GOTO[TestDst.BY], {delay 1 cycle}c2;		NoDstCarry.BY:	Rx {srcLow} ¬ Rx {srcLow} + rSTrans, CarryBr,	c1;TestSrcCary.BY:	L ¬ ~ErrnIBnStkp, BRANCH[GetInitCnt.BY, SrcCary.BY],c2;SrcCary.BY:	TT ¬ TT {sourceHigh} + 1, CANCELBR[$,0F], 	c3;		rhTT ¬ TT LRot0, GOTO[TestSrcCary.BY],{delay 1 cycle}	c1;		{At this point, rWCount = number of bytes transferred}		GetInitCnt.BY:	Q ¬ uCntSave{initial count(bytes)}, 		c3;		rWCount ¬ Q - rWCount, GOTO[UpdateStk.BY],	c1;{At this point, rWCount = number of bytes not transferred(remaining)}									{****************************************************************************			Update Stack ****************************************************************************}{If we must interrupt, we must save the state in the stack. Current State:	TT, rhTT	source virtual address high	Rx		source virtual address low	rhT		dest virtual address high	T		dest virtual address low	TOS		source offset	rDstOffset	dest offset}UpdateStk.BY:	Q ¬ rhT {destHi}, push {destLow}, 		c2;		STK ¬ T {destLow}, push{destHigh}, 		c3;						STK ¬ Q {destHigh}, push,{destOffset},		c1;		STK ¬ rDstOffset, push,{count},			c2;		STK ¬ rWCount {count}, push{sourceLow},		c3;				STK ¬ Rx,{sourceLow} push{sourceHi},		c1;		STK ¬ TT{sourceHi}, push,{sourceOffset},	c2;		STK ¬ TOS{srcOffset}, MesaIntBr,		c3;				stackP ¬ uStackPSave, BRANCH[$, Int.BY],	c1;		stackP ¬ L, 					c2;		GOTO[OffsetChk.BY],				c3;		 Int.BY:		L ¬ ULsave,{ GOTO[BlockInt],}			c2;		Bank ¬ bank0,					c3;		GOTOBANK0[BLTsIntRet],				c1;							{****************************************************************************			Read Map Fix(copies of commonsubs)****************************************************************************}RLMapFix.BY:	Xbus ¬ Rx LRot0,XwdDisp, L3 ¬ L3.rhTT.Q,		c3;RLMapx.BY:	Map ¬ [rhTT,Q], DISP2[RMapa.BY],			c1;				MDR ¬ Rx or map.referenced, L1Disp, GOTO[RLMapb.BY],	c2, at[0,10,RMapa.BY];		MDR ¬ Rx or map.referenced, L1Disp, GOTO[RLMapb.BY],	c2, at[1,10,RMapa.BY];		MDR ¬ Rx or map.referenced, L1Disp, GOTO[RLMapb.BY],	c2, at[2,10,RMapa.BY];IBEmptyTrap.BY:	T ¬ qPageFault, L1Disp, GOTO[RLTrap.BY],		c2, at[3,10,RMapa.BY];RLMapb.BY:	Xbus ¬ 1, XDisp, RET[RLMF.BY],				c3;RLTrap.BY:	push, RET[RTrap.BY],					c3;{****************************************************************************			Write Map Fix(copies of commonsubs) ****************************************************************************}WLMapFix.BY:	Xbus ¬ Rx LRot0, XwdDisp, L3 ¬ L3.rhTT.Q,			c3;		Map ¬ [rhTT,Q], DISP2[WLMapa.BY],			c1;				MDR ¬ Rx or map.rd, L1Disp, GOTO[WLMapb.BY], LOOPHOLE[wok],	c2, at[0,4,WLMapa.BY];		T ¬ qWriteProtect, L1Disp, GOTO[WLTrap.BY],			c2, at[1,4,WLMapa.BY];		MDR ¬ Rx or map.rd, L1Disp, GOTO[WLMapb.BY], LOOPHOLE[wok],	c2, at[2,4,WLMapa.BY];		T ¬ qPageFault, L1Disp, GOTO[WLTrap.BY],			c2, at[3,4,WLMapa.BY];WLMapb.BY:	Xbus ¬ 2, XDisp, RET[WLMF.BY],					c3;WLTrap.BY:	push, RET[WTrap.BY],						c3;{****************************************************************************				Trap Return ****************************************************************************}{Return here from RLMapFix.BY in case of trap on source}at[L1.SrcMap,10,RTrap.BY]		stackP ¬ uStackPSave, GOTO[RestReg.BY],		c1;		{Return here from WLMapFix.BY in case of trap on dest.}		 				at[L1.DstWMap,10,WTrap.BY]		stackP ¬ uStackPSave,				c1;{StackP has been restored from uStackPSave. Restore L register. Q = virtual address low. rhTT = virtual address high. Restore TOS so HiTT can save it again} RestReg.BY:	uFaultParm0 ¬ Q,				c2;		L ¬ ULsave, push,				c3;		TOS ¬ STK,{ GOTO[HiTT{in commonsubs}],}		c1;		Bank ¬ bank0,					c2;		GOTOBANK0[BLTsFltRet],				c3;{****************************************************************************			Type is A or B ?****************************************************************************}{Come here if source page cross or interrupt have occured in Loop Body or Pre-Trans. If transfer type is Type B, we must write destination with source data which has already been read into the TOS. If transfer type is Type A, we do nothing in here and go to Update.src quickly.} Judge.BY:	MAR ¬  Rx ¬ [rhRx, Rx + 1], BRANCH[$, Type.A, 0D],	c1;JudgePlus.BY:	BRANCH[NoDstRdPgCr.ju, DstRdPgCr.ju, 1],		c2;NoDstRdPgCr.ju:	rDstData ¬ MD and L{00FF},				c3;		MAR ¬ [rhRx, Rx + 0],					c1;		MDR ¬ rDstData or TOS, L2Disp, 				c2;		CANCELBR[Update.src, 0F], 				c3;		{Transfer type is Type A, we do nothing}		Type.A:		CANCELBR[$, 0F],					c2;		GOTO[Update.src],					c3;				{Come here if destination page cross occur on condition that source page cross or interrupt have already occured.}DstRdPgCr.ju:	CANCELBR[Update.dst, 0F],				c3;		 {****************************************************************************			Preparation for update *****************************************************************************}{If PageCross or Interrupt occur at anywhere in this module, control always comes in this routine before Update.BY. Because we must update arguments for updating stack. L0 is used to calculate number of bytes transferred.  	TOS:		next source offset	rDstOffset:	next dest offset	rSTrans:	distance between current source and next source virtual address(word)	rDTrans:	distance between current dest and next dest virtual address(word)	rWCount:	number of words remained in Loop Body or Loop Body for ripple. 	   <<Destination Page Cross or Interrupt(in Ripple loop)>>			L0	Next	Next	Number of 	rDTrans	rSTrans		 		Dest   	Src	Bytes 			Offset	Offset	Transed	  case0,1   	1	1	0	W*2+1		W	W+1  case2,3	0	0	0	W*2		W	W  case4,5	3	1	0	W*2+2		W+1	W+1  case6,7	3	0	0	W*2+1		W+1	W+1  <<Source Page Cross or Interrupt(Loop Body)>> 		L0	Next	Next	Number of	rDTrans	rSTrans				Dst   	Src	Bytes			Offset	Offset	Transed	  case0,1	4	1	0	W*2+1		W	W+1  case2,3	0	0	0	W*2		W	W  case4,5	6	1	0	W*2+2		W+1	W+1  case6,7	3	0	0	W*2+1		W+1	W+1    		* W = number of words transferred "in Loop Body or Ripple Loop Body".}	   Update.src:	rWTransferred ¬ uCountSave{word}, 		c1;		rWTransferred ¬ rWTransferred - rWCount, L2Disp,c2;		rWCount ¬ rWTransferred LShift1, SE ¬ 1,DISP4[PreUpdate.src, 9],c3;				at[9,10,PreUpdate.src]{case0, case1}		L0 ¬ L0.0001,					c1;		rDstOffset ¬ 1,	L0Disp, GOTO[SetSrcOffset],	c2;				at[0B,10,PreUpdate.src]{case2, case3}				rWCount ¬ rWCount -1, L0 ¬ L0.0000,		c1;		rDstOffset ¬ 0, L0Disp, GOTO[SetSrcOffset],	c2;at[0D,10,PreUpdate.src]{case4, case5}		rWCount ¬ rWCount + 1, L0 ¬ L0.0011,		c1;		rDstOffset ¬ 1,	L0Disp, GOTO[SetSrcOffset],	c2;				at[0F,10,PreUpdate.src]{case4, case5}		L0 ¬ L0.0011,					c1;		rDstOffset ¬ 0,	L0Disp, GOTO[SetSrcOffset],	c2;		Update.dst:	rWTransferred ¬ uCountSave{word}, 		c1;		rWTransferred ¬ rWTransferred - rWCount, L2Disp,c2;		rWCount ¬ rWTransferred LShift1, SE ¬ 1,DISP4[PreUpdate.dst, 9],c3;				at[9,10,PreUpdate.dst]{case0, case1}		rWCount ¬ rWCount - 1, L0 ¬ L0.0100,		c1;		rDstOffset ¬ 0,	L0Disp, GOTO[SetSrcOffset],	c2;		at[0B,10,PreUpdate.dst]{case2, case3}		rWCount ¬ rWCount - 1, L0 ¬ L0.0000, 		c1;				rDstOffset ¬ 0,	L0Disp, GOTO[SetSrcOffset],	c2;at[0D,10,PreUpdate.dst]{case4, case5}		L0 ¬ L0.0110,					c1;		rDstOffset ¬ 0,	L0Disp, GOTO[SetSrcOffset],	c2;		at[0F,10,PreUpdate.dst]{case6, case7}		L0 ¬ L0.0011,					c1;		rDstOffset ¬ 0,	L0Disp, GOTO[SetSrcOffset],	c2;SetSrcOffset:	L0Disp, BRANCH[NextSrcOff.Ev, NextSrcOff.Od, 0B],c3;NextSrcOff.Ev:	TOS{srcOffset} ¬ 0, L0Disp, BRANCH[DstUpWordEqT, DstUpWordNotEqT, 0D],c1;NextSrcOff.Od:	TOS{srcOffset} ¬ 1, L0Disp, BRANCH[DstUpWordEqT, DstUpWordNotEqT, 0D],c1;DstUpWordEqT:	rDTrans ¬ rWTransferred, BRANCH[SrcUpWordEqT, SrcUpWordNotEqT, 0E],c2;DstUpWordNotEqT:rDTrans ¬ rWTransferred + 1, BRANCH[SrcUpWordEqT, SrcUpWordNotEqT, 0E],c2;SrcUpWordEqT:	rSTrans ¬ rWTransferred, GOTO[Update.BY],	c3;SrcUpWordNotEqT:rSTrans ¬ rWTransferred + 1, GOTO[Update.BY],	c3;
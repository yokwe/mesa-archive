-- File: DiagEtherLogAndTraceImpl.mesa - last edit:-- MXT                 26-Jun-85 15:18:31-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  DiagEtherIOCB,  DiagEtherLogAndTrace,  EthernetFace,  Inline;DiagEtherLogAndTraceImpl: PROGRAM   IMPORTS DiagEtherIOCB, EthernetFace, Inline  EXPORTS DiagEtherLogAndTrace =  BEGIN OPEN DiagEtherLogAndTrace;    -- ================  -- PUBLIC VARIABLES  -- ================  logError:			PUBLIC BOOLEAN _ FALSE;  errLogPtr:			PUBLIC LONG POINTER TO ARRAY OF WORD;  errLogLength:			PUBLIC CARDINAL _ 0;  errLogEntrySize:		PUBLIC CARDINAL _ 25;  errEntryOffset:		PUBLIC CARDINAL _ 0;  errLogEntryCount:		PUBLIC CARDINAL _ 0;  errEntriesWrappedAround:	PUBLIC BOOLEAN _ FALSE;  errCountWrappedAround:		PUBLIC BOOLEAN _ FALSE;    logStep:			PUBLIC BOOLEAN _ FALSE;  stepLogPtr:			PUBLIC LONG POINTER TO ARRAY OF WORD;  StepEntrySize:			PUBLIC CARDINAL _ 25;    trace:			PUBLIC BOOLEAN _ FALSE;  tracePtr:			PUBLIC LONG POINTER TO ARRAY OF WORD;  traceLength:			PUBLIC CARDINAL _ 0;  traceEntrySize:		PUBLIC CARDINAL _ 25;  traceEntryOffset:		PUBLIC CARDINAL _ 0;  traceEntryCount:		PUBLIC CARDINAL _ 0;  traceEntriesWrappedAround:	PUBLIC BOOLEAN _ FALSE;  traceCountWrappedAround:	PUBLIC BOOLEAN _ FALSE;    -- ================  -- GLOBAL VARIABLES  -- ================  -- =================  -- PUBLIC PUBLIC PROCEDUREs  -- =================  -- ~~~~~~~~~~~~~~~~~~~  -- Log file management   -- ~~~~~~~~~~~~~~~~~~~  ClearLogging: PUBLIC PROCEDURE = {    wordptr: CARDINAL;        wordptr _ 0;    UNTIL wordptr >= errLogLength DO      errLogPtr^ [wordptr] _ 0;      wordptr _ wordptr + 1;    ENDLOOP;    errEntriesWrappedAround _ FALSE;     errCountWrappedAround _ FALSE;     errEntryOffset _ 0;    errLogEntryCount _ 0;    }; -- of ClearLogging.      StartLogging: PUBLIC PROCEDURE = {    logError_ TRUE;    }; -- of StartLogging.  StopLogging: PUBLIC PROCEDURE = {    logError_ FALSE;     }; -- of StopLogging.  -- ~~~~~~~~~~~~~~~~~~~~~  -- Trace file management   -- ~~~~~~~~~~~~~~~~~~~~~  ClearTrace: PUBLIC PROCEDURE = {    wordptr: CARDINAL _ 0;     UNTIL wordptr>= traceLength DO      tracePtr^ [wordptr] _ 0;      wordptr _ wordptr+ 1;    ENDLOOP;    traceEntriesWrappedAround _ FALSE;     traceCountWrappedAround _ FALSE;     traceEntryOffset _ 0;    traceEntryCount _ 0;    }; -- of ClearTrace.  StartTrace: PUBLIC PROCEDURE = {    trace_ TRUE;     }; -- of StartTrace.    StopTrace: PUBLIC PROCEDURE = {    trace_ FALSE;    };  -- ~~~~~~  -- Others  -- ~~~~~~    LogEvent: PUBLIC PROCEDURE[err: BOOLEAN _ FALSE, diagDataError: BOOLEAN _ FALSE] = {      tempLogLength: CARDINAL ¬ 256;      tempLogOffset: CARDINAL ¬ 0;      tempLogCount: CARDINAL ¬ 0;      tempWrappedAround: BOOLEAN ¬ FALSE;      tempCountWrappedAround: BOOLEAN ¬ FALSE;            IF logStep THEN         Log[          pointer: stepLogPtr, 	  length: @tempLogLength,	  entrySize: @StepEntrySize,	  offset: @tempLogOffset,	  entryCount: @tempLogCount,	  wrappedAround: @tempWrappedAround,	  countWrappedAround: @tempCountWrappedAround];            IF logError AND err THEN        Log[          pointer: errLogPtr, 	  length: @errLogLength,	  entrySize: @errLogEntrySize,	  offset: @errEntryOffset,	  entryCount: @errLogEntryCount,	  wrappedAround: @errEntriesWrappedAround,	  countWrappedAround: @errCountWrappedAround];      IF trace THEN        Log[          pointer: tracePtr, 	  length: @traceLength,	  entrySize: @traceEntrySize,	  offset: @traceEntryOffset,	  entryCount: @traceEntryCount,	  wrappedAround: @traceEntriesWrappedAround,	  countWrappedAround: @traceCountWrappedAround];      }; -- of LogEvent.  -- =================  -- Private PROCEDURE  -- =================  Log: PROCEDURE [pointer: LONG POINTER TO ARRAY OF WORD, length: LONG POINTER TO CARDINAL, entrySize: POINTER TO CARDINAL,     offset: POINTER TO CARDINAL, entryCount: POINTER TO CARDINAL, wrappedAround: POINTER TO BOOLEAN, countWrappedAround: POINTER TO BOOLEAN] = {    count: CARDINAL ¬ 0;    --    pointer ==> ===============================--	          |  				|--	 +        ========== currentIOCB ========--	          |				|--    offset  ==> ===============================--	          | SUCC[entryCount^]		|--	          ===============================--	          |	errCode			|--	          ===============================--	          |	retryTimes		|--	          ===============================--	          | cmdTimeOut: BOOLEAN		|--	          ===============================    -- copy currentIOCB to pointer + offset.    Inline.LongCOPY[      from: DiagEtherIOCB.currentIOCB,      nwords: EthernetFace.controlBlockSize,      to: pointer + offset­];    offset­ ¬ offset­ + EthernetFace.controlBlockSize;        -- save EthernetFace.controlBlockSize;    pointer^ [offset^] _ EthernetFace.controlBlockSize;    offset^ _ offset^+ 1;    -- entry number    entryCount^ _ entryCount^+ 1;    pointer^ [offset^] _ entryCount^;    offset^ _ offset^+ 1;    --    IF length^< offset^+ entrySize^ THEN      { offset^ _ 0;      wrappedAround^ _ TRUE      };    IF entryCount^= 177777B THEN countWrappedAround^ _ TRUE;    --     }; -- of Log          END...LOGTime			By	Action11-Feb-85 10:48:26	MXT	Created.12-Mar-85 17:49:20	MXT	Added Log.
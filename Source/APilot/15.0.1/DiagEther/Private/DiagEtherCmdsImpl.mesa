-- File: DiagEtherCmdsImpl.mesa - last edit:-- KXW                 27-Apr-87 15:07:52-- Copyright (C) 1985, 1986, 1987 by Xerox Corporation. All rights reserved.DIRECTORY  DiagEtherBasicTest USING [CmdOf856Failed, numberOfPackets, TestNotAcceptable],  DiagEtherCmdDrive USING [ExecuteCmd],  DiagEtherCmds,  DiagEtherErrorCheck USING [expectedStatus, PublicErrorCheckArray],  DiagEtherIOCmdMsgs USING [ioCmdMsgs],  DiagEtherMenuMsgs	USING [menuMsgs],  DiagEtherPromptMsgs	USING [prompts],  --DiagEtherTestCmds USING [StopIntLoopBack],  DiagEtherTestControl USING [diag82586, EndlessLoop, SetUpTestControl, TCStandard8, TestControlRecord],  DiagEtherTestParameters USING [commTurnaround, diag82586, diagnoseCheckArray, diagserialInterface,     inputCheckArray, tdrTest, test82586SerialInterface, xverTurnaround],  DiagEtherTests USING [Switch],  EthernetIOFaceDove USING [IOCB],  OfflineDiagInterface USING [AbortCurrentTest, GetAHelpText, GetANumber, GetYesNo,     HelpText, HitAnyKeyToContinue, OfflineDiagnosticProc, PutMessage, ResultType],  String USING [AppendString, Copy];  DiagEtherCmdsImpl: PROGRAM IMPORTS     DiagEtherBasicTest, DiagEtherCmdDrive, DiagEtherIOCmdMsgs, DiagEtherMenuMsgs, DiagEtherPromptMsgs,    DiagEtherErrorCheck, DiagEtherTestControl, DiagEtherTests,    OfflineDiagInterface, DiagEtherTestParameters,    String--, DiagEtherIOCB  EXPORTS DiagEtherCmds =  BEGIN     OPEN       DiagEtherIOCmdMsgs,      DiagEtherMenuMsgs,      DiagEtherPromptMsgs,      --IOCB: DiagEtherIOCB,       IOFace: EthernetIOFaceDove,       --HardFace: EthernetHardFaceDove,       TestParams: DiagEtherTestParameters,      ODI: OfflineDiagInterface;  -- =================  -- TYPE definitions  -- =================  IOCBPtr: TYPE = LONG POINTER TO IOFace.IOCB;    testDataArray: PUBLIC ARRAY DiagEtherCmds.TestDataType OF CARDINAL ¬ [0, 177777B, 125252B, 52525B, 31463B, 146314B, 0];  currentIOCB: IOCBPtr _ NIL;  nextIOCB: IOCBPtr _ NIL;    pleaseStop: BOOLEAN ¬ FALSE; -- TRUE when user hit STOP key.  -- ====================================================  -- Communication test PUBLIC PROCEDURES  -- ====================================================   -- Communication test will be done by customer(s). This will test all around of the Ethernet Hardware between IOP and Coax Cable.    Diag82586: PUBLIC ODI.OfflineDiagnosticProc = {    -- This PROC will test 82586 itself using Diagnose command.    -- IOCB will send Diagnose command to 82586 and catch his status.    -- 586's diagnose will run in two phases.    -- Phase 1. Test Counters    -- Phase 2. Test Trigger logics.    ODI.PutMessage[message: " "L, clearMessageAreaFirst: TRUE];    result ¬ Diag82586Internal[TRUE];    SELECT result FROM      passed => ODI.PutMessage[message: ioCmdMsgs[noProblem], startWithNewLine: TRUE];      failed => {ODI.PutMessage[message: menuMsgs[i82586Diagnose], startWithNewLine: TRUE];        ODI.PutMessage[message: prompts[failed]]};      ENDCASE;    RETURN[result]};      Diag82586Internal: PROC[getPassCount: BOOLEAN _ TRUE] RETURNS[ODI.ResultType] =    BEGIN    SetUpTestParameters[      testParams: DESCRIPTOR[TestParams.diag82586],      testCntlData: DiagEtherTestControl.diag82586,       errorCheck: DESCRIPTOR[TestParams.diagnoseCheckArray],      getPassCount: getPassCount];        ODI.PutMessage[message: ioCmdMsgs[diagnose82586], startWithNewLine: TRUE];        DiagEtherCmdDrive.ExecuteCmd[      cmdArray: DESCRIPTOR[TestParams.diag82586]      ! DiagEtherBasicTest.TestNotAcceptable => GOTO exit;        DiagEtherBasicTest.CmdOf856Failed => GOTO cmdFailed];    RETURN[passed];    -- When success is FALSE, additional test should be done?        EXITS      exit => RETURN[none];      cmdFailed => RETURN[failed];    END;  LoopBack82586Internal: PUBLIC ODI.OfflineDiagnosticProc = {    -- This test will use internalloopback which is built in the 82586.        result _ InternalLoopBackTest[TRUE];    ODI.HitAnyKeyToContinue[beep: FALSE];    RETURN[none]};      InternalLoopBackTest: PROC[getPassCount: BOOLEAN] RETURNS[result: ODI.ResultType] = {    ENABLE UNWIND => GOTO exit;        SetUpTestParameters[      testParams: DESCRIPTOR[TestParams.test82586SerialInterface],      testCntlData: DiagEtherTestControl.diag82586,       errorCheck: DESCRIPTOR[TestParams.inputCheckArray],      getPassCount: getPassCount];        ODI.PutMessage[message: ioCmdMsgs[diagnose82586], startWithNewLine: TRUE];        result ¬ LoopBackInternal[DESCRIPTOR[TestParams.test82586SerialInterface] !      ODI.AbortCurrentTest => IF getPassCount THEN CONTINUE ELSE REJECT];          EXITS exit => NULL;    };  LoopBack8023Internal: PUBLIC ODI.OfflineDiagnosticProc = {    connect: BOOLEAN ¬ FALSE;    str: LONG STRING  ¬ [256];    str.length ¬ 0;    String.Copy[to: str, from: ioCmdMsgs[turnAroundPlugQuestion1]];    String.AppendString[to: str, from: ioCmdMsgs[commTurnAroundPlug]];    String.AppendString[to: str, from: ioCmdMsgs[turnAroundPlugQuestion2]];    connect ¬ ODI.GetYesNo[prompt: str];    IF ~connect THEN {      ODI.PutMessage[message: ioCmdMsgs[noCommTurnArndPlug]];      ODI.PutMessage[message: ioCmdMsgs[commTurnArndTestAborted]];      RETURN[failed]};    result ¬ ExternalLoopbackTest[TRUE];    RETURN[none]};      ExternalLoopbackTest: PROC[getPassCount: BOOLEAN _ TRUE] RETURNS[result: ODI.ResultType] = {    SetUpTestParameters[      testParams: DESCRIPTOR[TestParams.diagserialInterface],      testCntlData: DiagEtherTestControl.TCStandard8,       errorCheck: DESCRIPTOR[TestParams.inputCheckArray],      getPassCount: getPassCount];    ODI.PutMessage[message: ioCmdMsgs[testPLLSerialInterface], startWithNewLine: TRUE];    result ¬ LoopBackInternal[DESCRIPTOR[TestParams.diagserialInterface] !      ODI.AbortCurrentTest => CONTINUE];    ODI.HitAnyKeyToContinue[beep: FALSE];    IF result = passed THEN ODI.PutMessage[message: ioCmdMsgs[noProblem], startWithNewLine: TRUE];    RETURN[result];    };  TDRTest: PUBLIC ODI.OfflineDiagnosticProc = {    RETURN[TDRTestInternal[TRUE]]};      TDRTestInternal: PROC[getPassCount: BOOLEAN _ TRUE] RETURNS[result: ODI.ResultType] = {    SetUpTestParameters[      testParams: DESCRIPTOR[TestParams.tdrTest],      testCntlData: DiagEtherTestControl.diag82586,       errorCheck: DESCRIPTOR[TestParams.diagnoseCheckArray],      getPassCount: getPassCount];    DiagEtherCmdDrive.ExecuteCmd[      cmdArray: DESCRIPTOR[TestParams.tdrTest]      ! DiagEtherBasicTest.TestNotAcceptable => GOTO exit;        DiagEtherBasicTest.CmdOf856Failed => GOTO cmdFailed];    RETURN[passed];        EXITS      exit => RETURN[none];      cmdFailed => RETURN[failed];    };      CommTurnaroundTest: PUBLIC ODI.OfflineDiagnosticProc = {    connect: BOOLEAN ¬ FALSE;    str: LONG STRING  ¬ [256];    str.length ¬ 0;    String.Copy[to: str, from: ioCmdMsgs[turnAroundPlugQuestion1]];    String.AppendString[to: str, from: ioCmdMsgs[commTurnAroundPlug]];    String.AppendString[to: str, from: ioCmdMsgs[turnAroundPlugQuestion2]];    connect ¬ ODI.GetYesNo[prompt: str];    IF ~connect THEN {      ODI.PutMessage[message: ioCmdMsgs[noCommTurnArndPlug]];      ODI.PutMessage[message: ioCmdMsgs[commTurnArndTestAborted]];      RETURN[failed]};        -- Turnaround plug was connected.    SetUpTestParameters[      testParams: DESCRIPTOR[TestParams.commTurnaround],      testCntlData: DiagEtherTestControl.TCStandard8,       errorCheck: DESCRIPTOR[TestParams.inputCheckArray]];        ODI.PutMessage[message: "Test Ethernet DataLink LSI..."L, startWithNewLine: TRUE];        result ¬ LoopBackInternal[DESCRIPTOR[TestParams.commTurnaround] !      ODI.AbortCurrentTest => CONTINUE];    ODI.HitAnyKeyToContinue[beep: FALSE];    --IF result = passed THEN ODI.PutMessage[message: ioCmdMsgs[noProblem], startWithNewLine: TRUE];    RETURN[none];    };      XverTurnaroundTest: PUBLIC ODI.OfflineDiagnosticProc = {    connect: BOOLEAN ¬ FALSE;    str: LONG STRING  ¬ [256];    str.length ¬ 0;    String.Copy[to: str, from: ioCmdMsgs[turnAroundPlugQuestion1]];    String.AppendString[to: str, from: ioCmdMsgs[xverTurnAroundPlug]];    String.AppendString[to: str, from: ioCmdMsgs[turnAroundPlugQuestion2]];    connect ¬ ODI.GetYesNo[prompt: str];    IF ~connect THEN {      ODI.PutMessage[message: ioCmdMsgs[noXverTurnArndPlug]];      ODI.PutMessage[message: ioCmdMsgs[xverTurnArndTestAborted]];      RETURN[failed]};    -- Turnaround plug was connected.    SetUpTestParameters[      testParams: DESCRIPTOR[TestParams.xverTurnaround],      testCntlData: DiagEtherTestControl.TCStandard8,       errorCheck: DESCRIPTOR[TestParams.inputCheckArray]];    ODI.PutMessage[message: "Transceiver Turnaround Test started."L, startWithNewLine: TRUE];    result ¬ LoopBackInternal[DESCRIPTOR[TestParams.xverTurnaround] !      ODI.AbortCurrentTest => CONTINUE];    ODI.HitAnyKeyToContinue[beep: FALSE];    IF result = passed THEN ODI.PutMessage[message: "No problem was found."L, startWithNewLine: TRUE];    RETURN[none];    };      InterfaceTest: PUBLIC ODI.OfflineDiagnosticProc = {    passes: CARDINAL _ GetPassCount[];    aborted: BOOLEAN ¬ FALSE;        IF passes = 0 THEN passes _ LAST[CARDINAL];        WHILE passes # 0 DO            result ¬ Diag82586Internal[FALSE];      IF result#passed THEN {	ODI.PutMessage[message: ioCmdMsgs[interfaceTestFailed], startWithNewLine: TRUE];	ODI.PutMessage[message: menuMsgs[i82586Diagnose], startWithNewLine: FALSE]; 	RETURN[result]}      ELSE ODI.PutMessage[message: prompts[ok], startWithNewLine: FALSE];      result ¬ InternalLoopBackTest[FALSE !        ODI.AbortCurrentTest => {	  passes ¬ 1; CONTINUE}];      IF result=failed THEN {	ODI.PutMessage[message: ioCmdMsgs[interfaceTestFailed], startWithNewLine: TRUE];	ODI.PutMessage[message: menuMsgs[i82586Loopback], startWithNewLine: FALSE]; 	RETURN[result]}      ELSE ODI.PutMessage[message: prompts[ok], startWithNewLine: FALSE];      -- commented out TDR test untile the bug is fixed.      «result ¬ TDRTestInternal[FALSE];      IF result#passed THEN {	ODI.PutMessage[message: ioCmdMsgs[interfaceTestFailed], startWithNewLine: TRUE];	ODI.PutMessage[message: menuMsgs[tDRTest], startWithNewLine: FALSE]; 	RETURN[result]};»      passes _ passes - 1;      ENDLOOP;      ODI.PutMessage[message: ioCmdMsgs[interfaceTestCompleted], startWithNewLine: TRUE];          ODI.HitAnyKeyToContinue[beep: FALSE];      RETURN[IF NOT aborted THEN passed ELSE none];    };--=================================-- PRIVATE PROCEDREs--=================================    LoopBackInternal: PROCEDURE[cmdArray: LONG DESCRIPTOR FOR ARRAY OF CARDINAL] RETURNS[result: ODI.ResultType] = {    ENABLE UNWIND => GOTO exit;        dataType: DiagEtherCmds.TestDataType ¬ b000000;    userWantStop: BOOLEAN ¬ FALSE;    testDone: BOOLEAN ¬ FALSE;    DiagEtherTests.Switch[127] ¬ TRUE;    IF cmdArray[1] >= 1 THEN {      DiagEtherBasicTest.numberOfPackets ¬ cmdArray[1] * 100;      cmdArray[1] ¬ 1}    ELSE DiagEtherBasicTest.numberOfPackets ¬ LAST[LONG CARDINAL];      -- Do actual test.      DiagEtherCmdDrive.ExecuteCmd[	cmdArray	! DiagEtherBasicTest.TestNotAcceptable => {DiagEtherTests.Switch[127] ¬ FALSE; GOTO exit};	  DiagEtherBasicTest.CmdOf856Failed => {DiagEtherTests.Switch[127] ¬ FALSE; GOTO cmdFailed};	  ODI.AbortCurrentTest => {	    DiagEtherTests.Switch[127] ¬ FALSE; REJECT}];      dataType ¬ SUCC[dataType];        DiagEtherTests.Switch[127] ¬ FALSE;        RETURN[passed];        EXITS      exit => RETURN[none];      cmdFailed => RETURN[failed];    --    };  SetTransmitDataPattern: PUBLIC PROC[data: CARDINAL] = {testDataArray[other] ¬ data};      -- ==================  -- PRIVATE PROCEDURES  -- ==================      SetUpTestParameters: PROCEDURE[    testParams: LONG DESCRIPTOR FOR ARRAY OF CARDINAL,    testCntlData: DiagEtherTestControl.TestControlRecord,    errorCheck: LONG DESCRIPTOR FOR PACKED ARRAY OF DiagEtherErrorCheck.expectedStatus,    getPassCount: BOOLEAN _ TRUE] = {        IF getPassCount THEN testParams[1] ¬ GetPassCount[];    DiagEtherErrorCheck.PublicErrorCheckArray ¬ errorCheck;    DiagEtherTestControl.SetUpTestControl[testCntlData];    IF testParams[1] = 0 THEN DiagEtherTestControl.EndlessLoop ¬ TRUE;    };  GetPassCount: PROCEDURE RETURNS[count: CARDINAL ¬ 0] = {    helpTextPtr: LONG POINTER TO ODI.HelpText;    helpTextPtr ¬ ODI.GetAHelpText[1];    helpTextPtr.textBody[0] ¬ prompts[passCountHelp];        [number: count] ¬ ODI.GetANumber[      prompt: prompts[passCount],      help: helpTextPtr,      lowLimit: 0,      defaultNumber: 1];     };      -- ===============-- Main Line Code.-- ===============  Initialize: PROCEDURE = {    -- This procedure will initialize all of the private variables.    --IF currentIOCB=NIL THEN currentIOCB _ IOCB.AllocateIOCB[];    --IF nextIOCB=NIL THEN nextIOCB _ IOCB.AllocateIOCB[];    };  Initialize[];    END...Log10-Feb-85  9:58:15: MXT	Created15-Apr-85 15:08:39: MXT	Added GetPassCount.15-May-85 18:47:02: MXT Added catch phrase for DiagEtherBasicTest.CmdOf856Failed13-Jun-85 17:43:39	MXT	Added SetTransmitDataPattern.27-Apr-87 15:07:49	KXW	Fixed AR10465(Ethernet External Loopback test ignores "Enter pass count").
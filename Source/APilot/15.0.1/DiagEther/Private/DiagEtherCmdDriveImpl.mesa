-- File: DiagEtherCmdDriveImpl.mesa - last edit:-- MXT                  9-Dec-85 14:46:10-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  DiagEtherBasicTest,  DiagEtherBasicTestExtras,  DiagEtherCmdDes,  DiagEtherCmdDrive,  DiagEtherErrorCheck,  DiagEtherErrorMsgs,  DiagEtherTestControl,  DiagEtherTests,  EthernetHardFaceDove USING [multicastIDLimit],  HostNumbers USING [HostNumber],  Inline USING [HighByte, LongMult, LowByte],  OfflineDiagInterface USING [DiagHeap, LookForAbort, PutMessage, userType],  Process USING [Pause];  DiagEtherCmdDriveImpl: PROGRAM   IMPORTS DiagEtherBasicTest, DiagEtherBasicTestExtras, DiagEtherCmdDes, DiagEtherErrorCheck, DiagEtherErrorMsgs, DiagEtherTestControl, DiagEtherTests,    Inline, OfflineDiagInterface, Process  EXPORTS DiagEtherCmdDrive =  BEGIN OPEN     DiagEtherCmdDrive,    HardFace: EthernetHardFaceDove,    ODI: OfflineDiagInterface;  -- ================-- PUBLIC VARIABLEs-- ================  cmdDescriptionArray: PUBLIC LONG DESCRIPTOR FOR ARRAY OF DiagEtherCmdDes.CmdRecord _ DiagEtherCmdDes.CmdDescriptArray;  paramArrayL1:	PUBLIC ARRAY [0..3] OF DiagEtherCmdDrive.ParamRecord;  configParams: PUBLIC LONG POINTER TO ConfigureParametersRec ¬ NIL;  command: PUBLIC CARDINAL;  continue: PUBLIC BOOLEAN _ FALSE;  minTryCount: PUBLIC CARDINAL;  maxTryCount: PUBLIC CARDINAL;  minUnit: PUBLIC CARDINAL;  maxUnit: PUBLIC CARDINAL;  paramPtrL1: PUBLIC CARDINAL _ 0;  tryCount: PUBLIC CARDINAL _ 1;  unit: PUBLIC CARDINAL _ 0;  useSameDataBuff: PUBLIC CARDINAL;-- ================-- GLOBAL VARIABLEs-- ================  cmdPtr: CARDINAL;  delay: CARDINAL;  endLoop: BOOLEAN_ FALSE;  firstTimeLoop: BOOLEAN_ FALSE;  loop: BOOLEAN _ FALSE;  loopCount: CARDINAL;  endOfCmdFile:	BOOLEAN_ FALSE;  startLoopAt: CARDINAL;  -- =================-- PUBLIC PROCEDUREs-- =================  ExecuteCmd: PUBLIC PROCEDURE[cmdArray: LONG DESCRIPTOR FOR ARRAY OF CARDINAL _ DESCRIPTOR[NIL,0]] = {    ENABLE DiagEtherBasicTest.TestNotAcceptable => {      ODI.PutMessage[DiagEtherErrorMsgs.errors[doveOnly]];      REJECT};          -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    -- Nested PROCEDUREs    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    GetNumber: PROCEDURE RETURNS[count: CARDINAL] = {      count _ cmdArray[cmdPtr];      cmdPtr _ cmdPtr+ 1 ;      }; -- of GetNumber.    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    GetConfigParamPtr: PROCEDURE RETURNS[ptr: LONG POINTER TO ConfigureParametersRec] = {      n: CARDINAL ¬ GetNumber[];      ptr ¬ LOOPHOLE[Inline.LongMult[n, LAST[CARDINAL]]];      ptr ¬ ptr + n;      ptr ¬ ptr + LOOPHOLE[GetNumber[]];      }; -- of GetConfigParamPtr.    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    GetHostNumber: PROCEDURE RETURNS[id: HostNumbers.HostNumber] = {      num: CARDINAL;      num _ GetNumber[];      id.a _ Inline.HighByte[num];      id.b _ Inline.LowByte[num];            num _ GetNumber[];      id.c _ Inline.HighByte[num];      id.d _ Inline.LowByte[num];      num _ GetNumber[];      id.e _ Inline.HighByte[num];      id.f _ Inline.LowByte[num];      }; -- of GetHostNumber.    -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~    Getparameters: PROCEDURE = {      IF NOT loop THEN {        IF cmdDescriptionArray[command].needLoopCount THEN {	  loopCount _ GetNumber []; RETURN};	IF cmdDescriptionArray[command].needDelay THEN {	  delay _ GetNumber []; RETURN};	IF NOT cmdDescriptionArray[command].getParamsCmd THEN RETURN;		IF cmdDescriptionArray[command].needDestinationID THEN {	  paramArrayL1[paramPtrL1].hostNumber _ GetHostNumber[];	  };	  	IF cmdDescriptionArray[command].needByteCount THEN {	  paramArrayL1[paramPtrL1].byteCount _ GetNumber[];};	  	IF cmdDescriptionArray[command].needMulticastID THEN {	  FOR i: CARDINAL IN [0..HardFace.multicastIDLimit) DO	    paramArrayL1[paramPtrL1].multicastIDs[i] _ GetHostNumber[];	    ENDLOOP;	  };	  	IF cmdDescriptionArray[command].needConfigureParams THEN {paramArrayL1[paramPtrL1].configureParams ¬ GetConfigParamPtr[]};      IF cmdDescriptionArray[command].needUseSameDataBuff THEN {        paramArrayL1[paramPtrL1].useSameDataBuffMem _ useSameDataBuff _ GetNumber [];--        paramArrayL1[paramPtrL1].skipCount _ paramArrayL1[paramPtrL1].skipCount + 1;	};      IF cmdDescriptionArray[command].needTryCount THEN {	paramArrayL1[paramPtrL1].tryCountMem _ tryCount _ GetNumber[];--	paramArrayL1[paramPtrL1].skipCount _ paramArrayL1[paramPtrL1].skipCount + 1;        };      	IF cmdDescriptionArray[command].needData THEN {	  paramArrayL1[paramPtrL1].xmitData _ GetNumber[];--	  paramArrayL1[paramPtrL1].skipCount_ paramArrayL1[paramPtrL1].skipCount + 1;	  };		IF cmdDescriptionArray[command].needFrameLength THEN {	  paramArrayL1[paramPtrL1].xmitByteLength _ GetNumber[];};	IF firstTimeLoop THEN paramPtrL1 _ paramPtrL1+ 1;	RETURN      };	             IF loop THEN {       IF cmdDescriptionArray[command].needDelay THEN {         delay_ GetNumber []; RETURN};       IF NOT cmdDescriptionArray[command].getParamsCmd THEN RETURN;       	IF cmdDescriptionArray[command].needDestinationID THEN {	  paramArrayL1[paramPtrL1].hostNumber _ GetHostNumber[];	  };	  	IF cmdDescriptionArray[command].needByteCount THEN {	  paramArrayL1[paramPtrL1].byteCount _ GetNumber[];};	  	IF cmdDescriptionArray[command].needMulticastID THEN {	  FOR i: CARDINAL IN [0..HardFace.multicastIDLimit) DO	    paramArrayL1[paramPtrL1].multicastIDs[i] _ GetHostNumber[];	    ENDLOOP;	  };	  	IF cmdDescriptionArray[command].needConfigureParams THEN {paramArrayL1[paramPtrL1].configureParams ¬ GetConfigParamPtr[]};      IF cmdDescriptionArray[command].needUseSameDataBuff THEN {        paramArrayL1[paramPtrL1].useSameDataBuffMem _ useSameDataBuff _ GetNumber [];--        paramArrayL1[paramPtrL1].skipCount _ paramArrayL1[paramPtrL1].skipCount + 1;	};      IF cmdDescriptionArray[command].needTryCount THEN {	paramArrayL1[paramPtrL1].tryCountMem _ tryCount _ GetNumber[];--	paramArrayL1[paramPtrL1].skipCount _ paramArrayL1[paramPtrL1].skipCount + 1;        };      	IF cmdDescriptionArray[command].needData THEN {	  paramArrayL1[paramPtrL1].xmitData _ GetNumber[];--	  paramArrayL1[paramPtrL1].skipCount_ paramArrayL1[paramPtrL1].skipCount + 1;	  };		IF cmdDescriptionArray[command].needFrameLength THEN {	  paramArrayL1[paramPtrL1].xmitByteLength _ GetNumber[];};       paramPtrL1_ paramPtrL1 + 1;       };     }; -- of Getparameters    -- ~~~~~~~~~~~~~~~~~~~~~~~    -- Main Body of ExecuteCmd    -- ~~~~~~~~~~~~~~~~~~~~~~~    DiagEtherBasicTestExtras.ResetDeviceHandle[];    DiagEtherBasicTestExtras.DeactivateEthernetDriver[];    endOfCmdFile _ FALSE;    IF BASE[cmdArray]=NIL THEN RETURN;    ODI.PutMessage[clearMessageAreaFirst: TRUE];    -- if command file is not to be continued    IF NOT continue THEN {      cmdPtr _ 0;      paramPtrL1 _ 0;      loop _ FALSE;      firstTimeLoop _ FALSE;      };    continue _ FALSE;    endOfCmdFile _ FALSE;       UNTIL endOfCmdFile DO      IF (loop AND endLoop) THEN {        paramPtrL1 _ 0;	endLoop _ FALSE;	IF NOT DiagEtherTestControl.EndlessLoop THEN loopCount _ loopCount - 1;	IF loopCount> 0 THEN cmdPtr _ startLoopAt 	ELSE loop _ FALSE        };         --backup to prior command      IF DiagEtherTestControl.LoopOnError OR DiagEtherTestControl.RepeatCommand THEN {    --backup to prior command       IF paramPtrL1> 0 --i.e.in loop--THEN paramPtrL1 _ paramPtrL1- 1;       cmdPtr _ cmdPtr - paramArrayL1[paramPtrL1].skipCount + 1;       command _ cmdArray[cmdPtr];       };    --loop on error can only be exited with stop key    IF DiagEtherTestControl.LoopOnError THEN {      done: BOOLEAN_ FALSE;      UNTIL done DO        cmdDescriptionArray[command].cmdProc; --parameters are still set up      ENDLOOP;      };        IF DiagEtherTestControl.RepeatCommand THEN {      cnt: CARDINAL _ DiagEtherTestControl.RepeatCommandCount;      UNTIL cnt= 0 DO        cmdDescriptionArray[command].cmdProc; --parameters are still set up        DiagEtherErrorCheck.CheckStatus[];        cnt _ cnt- 1;        ENDLOOP;      }    ELSE {      -- get the next command      command _ cmdArray[cmdPtr];      cmdPtr _ cmdPtr+ 1;          -- get all the needed parameters      Getparameters[];          -- now execute the command (IO or otherwise)      IF ODI.userType = Programmer AND DiagEtherTests.Switch[8] THEN ODI.PutMessage[cmdDescriptionArray[command].commandName];      cmdDescriptionArray[command].cmdProc;      IF cmdDescriptionArray[command].checkIOStatus THEN DiagEtherErrorCheck.CheckStatus[];      IF DiagEtherTestControl.ReturnAfterCommand THEN        SIGNAL DiagEtherTestControl.ReturningAfterCommand;      };        ODI.LookForAbort[];    ENDLOOP;  }; -- of ExecuteCmd    Initialize: PUBLIC PROCEDURE = {    configParams ¬ ODI.DiagHeap.NEW[ConfigureParametersRec ¬ []];    };  StartLoop: PUBLIC PROCEDURE = {    firstTimeLoop_ TRUE;    startLoopAt_ cmdPtr;    }; -- of StartLoop.  EndLoop: PUBLIC PROCEDURE = {    endLoop_ TRUE;    loop_ TRUE;    firstTimeLoop_ FALSE;    }; --EndLoop  TimeDelay: PUBLIC PROCEDURE = {    Process.Pause [delay];    }; --TimeDelay  SetEndOfFile: PUBLIC PROCEDURE = {    endOfCmdFile_ TRUE;    }; --TimeDelay  END...LOG	time		by	action15-Feb-85 18:34:53	MXT	Created.25-Feb-85 15:10:52	MXT	Imported CmdRecord from DiagEtherCmdDes instead of DiagEtherCommCmd.22-Mar-85 11:34:57	MXT	Added Initialize.15-May-85 18:45:46	MXT	Removed DriverTypes21-May-85 12:04:52	MXT	Added ENABLE clause in ExecuteCmd.21-Jun-85 14:43:24	MXT	Removed unused codes.
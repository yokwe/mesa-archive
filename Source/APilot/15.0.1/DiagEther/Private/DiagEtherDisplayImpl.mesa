-- File: DiagEtherDisplayImpl.mesa - last edit:-- MXT                 13-Oct-85 19:15:21-- Copyright (C) 1985 by Xerox Corporation. All rights reserved.DIRECTORY  DiagEtherCmds,  DiagEtherDisplay,  DiagEtherIOCB,  DiagEtherIOCmdMsgs,  DiagEtherLogAndTrace,  DiagEtherPromptMsgs,  DiagEtherRunCmdFile,  EthernetFace,  EthernetHardFaceDove USING [dumpLength, DumpStatusBlock, Status],  EthernetIOFaceDove USING [IOCB, IOCBStatus],  Format,  Inline,  OfflineDiagInterface USING [AnOptionLine, DiagHeap, GetAHelpText, GetAnOption, GetAnOptionLine, GetAnOptionsRecord, GetYesNo,     FixedPositionDisplayRecord, GetAFixedPositionDisplayRecord, GetARow, DisplayFixedPositionData,    HelpText, HitAnyKeyToContinue, OptionsRecord, PutData, PutMessage, ResultType],  OfflineDiagTTYDove USING [rightEdge],  String USING [AppendNumber, AppendString];DiagEtherDisplayImpl: PROGRAM  IMPORTS    DiagEtherIOCB, DiagEtherIOCmdMsgs, DiagEtherLogAndTrace,    DiagEtherPromptMsgs, DiagEtherRunCmdFile, Format,    Inline, OfflineDiagInterface, OfflineDiagTTYDove, String  EXPORTS DiagEtherDisplay =  BEGIN  OPEN DiagEtherDisplay, DiagEtherIOCmdMsgs,    HardFace: EthernetHardFaceDove, IOFace: EthernetIOFaceDove,    DiagEtherPromptMsgs, ODI: OfflineDiagInterface;  logDisplaySelection: TYPE = {errorLog, traceTable, stepCommandLog};  ptrToEntry: LONG POINTER TO IOFace.IOCB _ NIL;  -- =================  -- PUBLIC PROCEDUREs  -- =================  DisplayLog: PUBLIC PROCEDURE = {result: ODI.ResultType; result _ ErrorLog[]; };  -- of DisplayLog  DisplayTrace: PUBLIC PROCEDURE = {result: ODI.ResultType; result _ Trace[]; };  -- of DisplayTrace.  DisplayStatus: PUBLIC PROCEDURE = {    cb: LONG POINTER TO IOFace.IOCB _ LOOPHOLE[DiagEtherIOCB.currentIOCB];    iocbStatus: IOFace.IOCBStatus _ cb.status;    status: HardFace.Status _ cb.i586Status;    str: LONG STRING ¬ [256];    spaces: LONG STRING = "     ";  -- 5 spaces.    clearDataArea: BOOLEAN ¬ ~DiagEtherRunCmdFile.runningUserCmdFile;    -- ~~~~~~~~~~~~~~    -- Display format    -- ~~~~~~~~~~~~~~    -- Command: commandName    -- ~~~~~~~~~~~~~~    --   Done:    Yes/No		Handled: Yes/No		Okay:  Yes/No    --   FrameTooLong: Yes/No	Is Dequeued:  Yes/No    -- ~~~~~~~~~~~~~~    --   Completion: Yes/No	Busy:	Yes/No		Okay:	Yes/No    --       -- for receiveFrame    --  crcErr: Yes/No	alnErr: Yes/No		rscErr: Yes/No	    --  ovrnErr: Yes/No	frameTooShort: Yes/No	noEOFFlag: Yes/No    --      -- for individualAddr, configure, multicastAddr    --  aborted: Yes/No    --      -- for transmit    --  aborted: Yes/No	noCRS:	Yes/No	lossOfCTS: Yes/No    --  underrun: Yes/No	deferred: Yes/No	sqeTest:Yes/No    --  tooManyCollisions: Yes/No	collisions: Yes/No    --      -- for diagnose    --  fail: Yes/No    -- ~~~~~~~~~~~~~~    str.length ¬ 0;    String.AppendString[to: str, from: prompts[command]];    String.AppendString[      to: str,      from:      WITH c: cb SELECT FROM        command =>          SELECT c.action FROM            nop => prompts[nop],            timeDomainRfl => prompts[timeDomainRfl],            dumpStatus => prompts[dumpStatus],            individualAddr => prompts[individualAddr],            configure => prompts[configure],            multicastAddr => prompts[multicastAddr],            transmit => prompts[transmit],            ENDCASE => prompts[diagnose],        ENDCASE => prompts[receiveFrame]];    ODI.PutData[      data: str, numOfBlankLines: 1, clearHeadingAndData: clearDataArea,      startWithNewLine: TRUE];    str.length ¬ 0;    String.AppendString[to: str, from: prompts[done]];    String.AppendString[      to: str, from: IF iocbStatus.done THEN prompts[yes] ELSE prompts[no]];    String.AppendString[to: str, from: spaces];    String.AppendString[to: str, from: prompts[handled]];    String.AppendString[      to: str, from: IF iocbStatus.handled THEN prompts[yes] ELSE prompts[no]];    String.AppendString[to: str, from: spaces];    String.AppendString[to: str, from: prompts[okay]];    String.AppendString[      to: str, from: IF iocbStatus.okay THEN prompts[yes] ELSE prompts[no]];    ODI.PutData[data: str, startWithNewLine: TRUE];    -- FrameTooLong: Y/N	Is Dequeued: Y/N    str.length ¬ 0;    String.AppendString[to: str, from: prompts[frmaeTooLong]];    String.AppendString[      to: str,      from: IF iocbStatus.frameTooLong THEN prompts[yes] ELSE prompts[no]];    String.AppendString[to: str, from: spaces];    String.AppendString[to: str, from: prompts[isDequeued]];    String.AppendString[      to: str, from: IF iocbStatus.isDequeued THEN prompts[yes] ELSE prompts[no]];    ODI.PutData[data: str, startWithNewLine: TRUE];    -- ~~~~~~~~~~~~~~~    -- IOCB.i586Status    -- ~~~~~~~~~~~~~~~    -- Completion: Yes/No	Busy: Y/N	Okay: Y/N    str.length ¬ 0;    String.AppendString[to: str, from: prompts[completion]];    String.AppendString[      to: str, from: IF status.completion THEN prompts[yes] ELSE prompts[no]];    String.AppendString[to: str, from: spaces];    String.AppendString[to: str, from: prompts[busy]];    String.AppendString[      to: str, from: IF status.busy THEN prompts[yes] ELSE prompts[no]];    String.AppendString[to: str, from: spaces];    String.AppendString[to: str, from: prompts[okayLSI]];    String.AppendString[      to: str, from: IF status.okay THEN prompts[yes] ELSE prompts[no]];    ODI.PutData[data: str, startWithNewLine: TRUE];    -- Variant part    WITH c: cb SELECT FROM      command =>        SELECT c.action FROM          transmit => {            OPEN s: LOOPHOLE[cb.status, HardFace.Status.command.transmit];            -- aborted: Y/N	noCRS: Y/N	lossOfCTS: Y/N            str.length ¬ 0;            String.AppendString[to: str, from: prompts[aborted]];            String.AppendString[              to: str, from: IF s.aborted THEN prompts[yes] ELSE prompts[no]];            String.AppendString[to: str, from: spaces];            String.AppendString[to: str, from: prompts[noCRS]];            String.AppendString[              to: str, from: IF s.noCRS THEN prompts[yes] ELSE prompts[no]];            String.AppendString[to: str, from: spaces];            String.AppendString[to: str, from: prompts[lossOfCTS]];            String.AppendString[              to: str, from: IF s.lossOfCTS THEN prompts[yes] ELSE prompts[no]];            ODI.PutData[data: str, startWithNewLine: TRUE];            -- underrun: Y/N	deferred: Y/N	sqeTest: Y/N            str.length ¬ 0;            String.AppendString[to: str, from: prompts[underrun]];            String.AppendString[              to: str, from: IF s.underrun THEN prompts[yes] ELSE prompts[no]];            String.AppendString[to: str, from: spaces];            String.AppendString[to: str, from: prompts[deferred]];            String.AppendString[              to: str, from: IF s.deferred THEN prompts[yes] ELSE prompts[no]];            String.AppendString[to: str, from: spaces];            String.AppendString[to: str, from: prompts[sqeTest]];            String.AppendString[              to: str, from: IF s.sqeTest THEN prompts[yes] ELSE prompts[no]];            ODI.PutData[data: str, startWithNewLine: TRUE];            -- tooManyCollisions: Y/N	collisions: Y/N            str.length ¬ 0;            String.AppendString[to: str, from: prompts[tooManyCollisions]];            String.AppendString[              to: str,              from: IF s.tooManyCollisions THEN prompts[yes] ELSE prompts[no]];            String.AppendString[to: str, from: spaces];            String.AppendString[to: str, from: prompts[collisions]];            String.AppendNumber[s: str, n: s.collisions, radix: 10];            ODI.PutData[data: str, startWithNewLine: TRUE];            };          diagnose => {            OPEN s: LOOPHOLE[cb.status, HardFace.Status.command.diagnose];            -- fail: Y/N            str.length ¬ 0;            String.AppendString[to: str, from: prompts[fail]];            String.AppendString[              to: str, from: IF s.fail THEN prompts[yes] ELSE prompts[no]];            ODI.PutData[data: str, startWithNewLine: TRUE];            };          individualAddr => {            OPEN s: LOOPHOLE[cb.status, HardFace.Status.command.individualAddr];            -- aborted: Y/N            str.length ¬ 0;            String.AppendString[to: str, from: prompts[aborted]];            String.AppendString[              to: str, from: IF s.aborted THEN prompts[yes] ELSE prompts[no]];            ODI.PutData[data: str, startWithNewLine: TRUE];            };          configure => {            OPEN s: LOOPHOLE[cb.status, HardFace.Status.command.configure];            -- aborted: Y/N            str.length ¬ 0;            String.AppendString[to: str, from: prompts[aborted]];            String.AppendString[              to: str, from: IF s.aborted THEN prompts[yes] ELSE prompts[no]];            ODI.PutData[data: str, startWithNewLine: TRUE];            };          multicastAddr => {            OPEN s: LOOPHOLE[cb.status, HardFace.Status.command.multicastAddr];            -- aborted: Y/N            str.length ¬ 0;            String.AppendString[to: str, from: prompts[aborted]];            String.AppendString[              to: str, from: IF s.aborted THEN prompts[yes] ELSE prompts[no]];            ODI.PutData[data: str, startWithNewLine: TRUE];            };          ENDCASE;      ENDCASE -- receiveFrame -- => {        OPEN s: LOOPHOLE[cb.status, HardFace.Status.receiveFrame];        -- crcErr: Y/N		alnErr: Y/N	rscErr: Y/N        str.length ¬ 0;        String.AppendString[to: str, from: prompts[crcErr]];        String.AppendString[          to: str, from: IF s.crcErr THEN prompts[yes] ELSE prompts[no]];        String.AppendString[to: str, from: spaces];        String.AppendString[to: str, from: prompts[alnErr]];        String.AppendString[          to: str, from: IF s.alnErr THEN prompts[yes] ELSE prompts[no]];        String.AppendString[to: str, from: spaces];        String.AppendString[to: str, from: prompts[rscErr]];        String.AppendString[          to: str, from: IF s.rscErr THEN prompts[yes] ELSE prompts[no]];        ODI.PutData[data: str, startWithNewLine: TRUE];        -- ovrnErr: Y/N	frameTooShort: Y/N	noEOFFlag: Y/N        str.length ¬ 0;        String.AppendString[to: str, from: prompts[ovrnErr]];        String.AppendString[          to: str, from: IF s.ovrnErr THEN prompts[yes] ELSE prompts[no]];        String.AppendString[to: str, from: spaces];        String.AppendString[to: str, from: prompts[frameTooShort]];        String.AppendString[          to: str, from: IF s.frameTooShort THEN prompts[yes] ELSE prompts[no]];        String.AppendString[to: str, from: spaces];        String.AppendString[to: str, from: prompts[noEOFFlag]];        String.AppendString[          to: str, from: IF s.noEOFFlag THEN prompts[yes] ELSE prompts[no]];        ODI.PutData[data: str, startWithNewLine: TRUE];        };    };  -- of DisplayStatus.  DisplayStatusBuffer: PUBLIC PROCEDURE [    buffer: LONG POINTER TO HardFace.DumpStatusBlock] =     BEGIN    IF ODI.GetYesNo[prompts[configOnly], , TRUE, TRUE] THEN      DisplayConfigParams[buffer] ELSE DisplayRaw170Bytes[buffer];    END;      DisplayConfigParams: PROC[buffer: LONG POINTER TO HardFace.DumpStatusBlock] = {    cmdIOCB: LONG POINTER TO IOFace.IOCB = LOOPHOLE[DiagEtherIOCB.currentIOCB];    configByte: CARDINAL = 12;    selectOffset: CARDINAL = 7;    firstValue: CARDINAL _ 0;    secondValue: CARDINAL;    thirdValue: CARDINAL;    cParams: LONG POINTER TO ODI.FixedPositionDisplayRecord _ NIL;          secondValue _ OfflineDiagTTYDove.rightEdge/3;    thirdValue _ secondValue * 2;        cmdIOCB.op ¬ command[      action: configure,      select: [configure[        byteCount: 2]]];    Inline.LongCOPY[from: buffer, nwords: configByte/2,       to: cmdIOCB + selectOffset];    WITH cb: cmdIOCB SELECT FROM      command =>         WITH c: cb.select SELECT cb.action FROM	  configure => {	    cParams _ ODI.GetAFixedPositionDisplayRecord[10];	    cParams.displayTitle _ "Configure Parameters";	    	    FOR i: CARDINAL IN [0..10) DO	      cParams.rows[i] _ ODI.GetARow[3];	      ENDLOOP;	      	    cParams.rows[0].rowItems[0] _ [	      namePosition: firstValue, name: "ByteCount ="L, stringValue: " ", 	      valuePosition: firstValue + 13, value: c.byteCount];	    cParams.rows[0].rowItems[1] _ [	      namePosition: secondValue, name: prompts[fifoLimit], stringValue: " ", 	      valuePosition: secondValue + prompts[fifoLimit].length + 2, 	      value: c.fifoLimit];	    cParams.rows[0].rowItems[2] _ [	      namePosition: thirdValue, name: prompts[saveBadFrames], 	      stringValue: IF c.saveBadFrames THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	      	    cParams.rows[1].rowItems[0] _ [	      namePosition: firstValue, name: prompts[syncReady], 	      stringValue: IF c.syncReady THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	    cParams.rows[1].rowItems[1] _ [	      namePosition: secondValue, name: prompts[externalLoopback], 	      stringValue: IF c.externalLoopback THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	    cParams.rows[1].rowItems[2] _ [	      namePosition: thirdValue, name: prompts[internalLoopback], 	      stringValue: IF c.internalLoopback THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	      	    cParams.rows[2].rowItems[0] _ [	      namePosition: firstValue, name: prompts[preambleLength], 	      stringValue: SELECT c.preambleLength FROM			two => prompts[two], four => prompts[four], eight => prompts[eight], sixteen => prompts[sixteen],			ENDCASE => prompts[unknown], 	      valuePosition: 0, value: 0];	    cParams.rows[2].rowItems[1] _ [	      namePosition: secondValue, name: prompts[addrTypeLoc], 	      stringValue: SELECT c.addrTypeLoc FROM			desc => prompts[descriptor], buffer => prompts[buffer], ENDCASE => prompts[unknown], 	      valuePosition: 0, value: 0];	    cParams.rows[2].rowItems[2] _ [	      namePosition: thirdValue, name: prompts[addrLength], 	      stringValue: " "L, 	      valuePosition: thirdValue + prompts[addrLength].length + 2, 	      value: c.addrLength];	  	    cParams.rows[3].rowItems[0] _ [	      namePosition: firstValue, name: prompts[expBackoffMethod], 	      stringValue: SELECT c.expBackoffMethod FROM			ethernet => prompts[ethernet], alternate => prompts[alternate], ENDCASE => prompts[unknown], 	      valuePosition: 0, value: 0];	    cParams.rows[3].rowItems[1] _ [	      namePosition: secondValue, name: prompts[accContRes], 	      stringValue: " "L, 	      valuePosition: secondValue + prompts[accContRes].length + 2, 	      value: c.accContRes];	    cParams.rows[3].rowItems[2] _ [	      namePosition: thirdValue, name: prompts[linearPriority], 	      stringValue: " "L, 	      valuePosition: thirdValue + prompts[linearPriority].length + 2, 	      value: c.linearPriority];	  	    cParams.rows[4].rowItems[0] _ [	      namePosition: firstValue, name: prompts[interframeSpacing], 	      stringValue: " "L, 	      valuePosition: firstValue + prompts[interframeSpacing].length + 2, 	      value: c.interframeSpacing];	    cParams.rows[4].rowItems[1] _ [	      namePosition: secondValue, name: prompts[retryNumber], 	      stringValue: " "L, 	      valuePosition: secondValue + prompts[retryNumber].length + 2, 	      value: c.retryNumber];	    cParams.rows[4].rowItems[2] _ [	      namePosition: thirdValue, name: prompts[slotTime], 	      stringValue: " "L, 	      valuePosition: thirdValue + prompts[slotTime].length + 2, 	      value: c.slotTimeLow + c.slotTimeHigh * 256];	  	    cParams.rows[5].rowItems[0] _ [	      namePosition: firstValue, name: prompts[padding], 	      stringValue: IF c.padding THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	    cParams.rows[5].rowItems[1] _ [	      namePosition: secondValue, name: prompts[bitstuffing], 	      stringValue: IF c.bitstuffing THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	    cParams.rows[5].rowItems[2] _ [	      namePosition: thirdValue, name: " ", 	      stringValue: NIL, 	      valuePosition: 0, value: 0];	  	    cParams.rows[6].rowItems[0] _ [	      namePosition: firstValue, name: prompts[CRC16], 	      stringValue: IF c.CRC16 THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	    cParams.rows[6].rowItems[1] _ [	      namePosition: secondValue, name: prompts[noCRCInsertion], 	      stringValue: IF c.noCRCInsertion THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	    cParams.rows[6].rowItems[2] _ [	      namePosition: thirdValue, name: prompts[txNoCRS], 	      stringValue: IF c.txNoCRS THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	  	    cParams.rows[7].rowItems[0] _ [	      namePosition: firstValue, name: prompts[NRZEncoding], 	      stringValue: IF c.NRZEncoding THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	    cParams.rows[7].rowItems[1] _ [	      namePosition: secondValue, name: prompts[broadcastDisable], 	      stringValue: IF c.broadcastDisable THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	    cParams.rows[7].rowItems[2] _ [	      namePosition: thirdValue, name: prompts[promiscuousMode], 	      stringValue: IF c.promiscuousMode THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	  	    cParams.rows[8].rowItems[0] _ [	      namePosition: firstValue, name: prompts[internalCDT], 	      stringValue: IF c.internalCDT THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	    cParams.rows[8].rowItems[1] _ [	      namePosition: secondValue, name: prompts[CDTFilter], 	      stringValue: " "L, 	      valuePosition: secondValue + prompts[CDTFilter].length + 2, 	      value: c.CDTFilter];	    cParams.rows[8].rowItems[2] _ [	      namePosition: thirdValue, name: " ", 	      stringValue: NIL, 	      valuePosition: 0, value: 0];	  	    cParams.rows[9].rowItems[0] _ [	      namePosition: firstValue, name: prompts[internalCRS], 	      stringValue: IF c.promiscuousMode THEN prompts[yes] ELSE prompts[no], 	      valuePosition: 0, value: 0];	    cParams.rows[9].rowItems[1] _ [	      namePosition: secondValue, name: prompts[CRSFilter], 	      stringValue: " "L, 	      valuePosition: secondValue + prompts[CRSFilter].length + 2, 	      value: c.CRSFilter];	    cParams.rows[9].rowItems[2] _ [	      namePosition: thirdValue, name: prompts[minFrameLength], 	      stringValue: " "L, 	      valuePosition: thirdValue + prompts[minFrameLength].length + 2, 	      value: c.minFrameLength];	    };	    	  ENDCASE;	ENDCASE;		IF cParams # NIL THEN {	  ODI.DisplayFixedPositionData[cParams, TRUE, FALSE];	  ODI.DiagHeap.FREE[@cParams]};      };  DisplayRaw170Bytes: PROC[buffer: LONG POINTER TO HardFace.DumpStatusBlock] = {    -- This procedure will display the 170 bytes status buffer contents.     S: Format.StringProc = {String.AppendString[to: str, from: s]};    byteFormat: Format.NumberFormat = [base: 16, zerofill: TRUE, columns: 2];    ok: BOOLEAN _ FALSE;    firstData: BOOLEAN ¬ FALSE;    dumpBytes: CARDINAL = HardFace.dumpLength;    numberOfDisplayBytes: CARDINAL = 1;    numberOfCharInBytes: CARDINAL = 2;    intervals: CARDINAL = 2;    chrsPerItem, itemsPerLine, lastItemsPerLine, numberOfLines: CARDINAL;    str: LONG STRING ¬ [20];    index: CARDINAL;    chrsPerItem ¬ numberOfDisplayBytes * numberOfCharInBytes + intervals;    itemsPerLine ¬ OfflineDiagTTYDove.rightEdge / chrsPerItem;    numberOfLines ¬ dumpBytes / itemsPerLine;    lastItemsPerLine ¬ dumpBytes MOD itemsPerLine;    IF lastItemsPerLine # 0 THEN numberOfLines ¬ numberOfLines + 1    ELSE -- lastItemsPerLine=0 -- lastItemsPerLine ¬ itemsPerLine;    --ODI.PutData[dataAreaHeading: "170 bytes of data"];    firstData ¬ TRUE;    index ¬ 0;    FOR i: CARDINAL IN [0..numberOfLines) DO      l: CARDINAL ¬        IF i # numberOfLines - 1 THEN itemsPerLine ELSE lastItemsPerLine;      firstData ¬ TRUE;      FOR j: CARDINAL IN [0..l) DO        str.length ¬ 0;        Format.Number[          proc: S, n: buffer[index],          format: byteFormat];        ODI.PutData[          data: str, startWithNewLine: firstData, blankSpaces: intervals];        firstData ¬ FALSE;        index ¬ index + 1;        ENDLOOP;      ENDLOOP;    };          ErrorLog: PUBLIC PROCEDURE RETURNS [result: ODI.ResultType] = {    DisplayLogInternal[      emptyMsg: ioCmdMsgs[errLogIsEmpty], logToBeDisplayed: errorLog,      entriesWordOffset: DiagEtherLogAndTrace.errEntryOffset,      entriesWrappedAround: DiagEtherLogAndTrace.errEntriesWrappedAround,      entryCount: DiagEtherLogAndTrace.errLogEntryCount,      entrySize: DiagEtherLogAndTrace.errLogEntrySize,      logLength: DiagEtherLogAndTrace.errLogLength,      logPtr: DiagEtherLogAndTrace.errLogPtr];    result _ none;    };  --ErrorLog  TempLog: PUBLIC PROCEDURE = {    DisplayLogInternal[      emptyMsg: NIL, logToBeDisplayed: stepCommandLog,      entriesWordOffset: DiagEtherLogAndTrace.StepEntrySize,      entriesWrappedAround: FALSE, entryCount: 1,      entrySize: DiagEtherLogAndTrace.StepEntrySize, logLength: 256,      logPtr: DiagEtherLogAndTrace.stepLogPtr];    };  -- of TempLog.  Trace: PUBLIC PROCEDURE RETURNS [result: ODI.ResultType] = {    DisplayLogInternal[      emptyMsg: ioCmdMsgs[traceTableEmpty], logToBeDisplayed: traceTable,      entriesWordOffset: DiagEtherLogAndTrace.traceEntryOffset,      entriesWrappedAround: DiagEtherLogAndTrace.traceEntriesWrappedAround,      entryCount: DiagEtherLogAndTrace.traceEntryCount,      entrySize: DiagEtherLogAndTrace.traceEntrySize,      logLength: DiagEtherLogAndTrace.traceLength,      logPtr: DiagEtherLogAndTrace.tracePtr];    result _ none;    };  --Trace  -- ==================  -- Private PROCEDUREs  -- ==================  DisplayLogInternal: PROCEDURE [    emptyMsg: STRING _ NIL, logToBeDisplayed: logDisplaySelection,    entriesWordOffset: CARDINAL, entriesWrappedAround: BOOLEAN,    entryCount: CARDINAL, entrySize: CARDINAL, logLength: CARDINAL,    logPtr: LONG POINTER TO ARRAY OF WORD] = {    -- ++++++++++++++++++    -- Nested PROCEDURE    -- ++++++++++++++++++    DisplayEntry: PROCEDURE = {      string: STRING _ [8];      --      a: CARDINAL;      --b: CARDINAL;      c: CARDINAL;      myp: LONG POINTER TO ARRAY OF WORD _ LOOPHOLE[ptrToEntry];      specialCmd: BOOLEAN _ FALSE;      t: BOOLEAN;      --get entry number or command display      IF logToBeDisplayed = stepCommandLog THEN        ODI.PutMessage[message: ioCmdMsgs[command], clearMessageAreaFirst: TRUE]      ELSE {        c _ myp^[SIZE[IOFace.IOCB] + 1];        ODI.PutMessage[          message: ioCmdMsgs[entryNumber], clearMessageAreaFirst: TRUE];        string.length _ 0;        String.AppendNumber[string, c, 10];        ODI.PutMessage[message: string];        };      -- Display command name      ODI.PutMessage[message: ioCmdMsgs[commandExecuted], startWithNewLine: TRUE];      WITH cb: ptrToEntry SELECT FROM        input => ODI.PutMessage[message: prompts[receiveFrame]];        output => ODI.PutMessage[message: prompts[transmit]];        command => {          SELECT cb.action FROM            nop => ODI.PutMessage[message: prompts[nop]];            timeDomainRfl => ODI.PutMessage[message: prompts[timeDomainRfl]];            dumpStatus => ODI.PutMessage[message: prompts[dumpStatus]];            individualAddr => ODI.PutMessage[message: prompts[individualAddr]];            configure => ODI.PutMessage[message: prompts[configure]];            multicastAddr => ODI.PutMessage[message: prompts[multicastAddr]];            transmit => ODI.PutMessage[message: prompts[transmit]];            diagnose => ODI.PutMessage[message: prompts[diagnose]];            ENDCASE;          };        ENDCASE;      --get given parameters      ODI.PutMessage[        message: ioCmdMsgs[givenParams],        startWithNewLine: TRUE];      DisplayStatus[];      t ¬ FALSE;      --UNTIL t DO t ¬ ODI.GetYesNo[prompt: prompts[proceeding]]; ENDLOOP;      ODI.HitAnyKeyToContinue[beep: FALSE];            };  -- of DisplayEntry.    -- +++++++++++++++++++++++    -- End of Nested PROCEDURE    -- +++++++++++++++++++++++    entryIAmAt: CARDINAL;    exit: BOOLEAN;    firstEntry: CARDINAL;    lastEntry: CARDINAL;    maxEntries: CARDINAL;    maxPtr: LONG POINTER TO IOFace.IOCB;    minPtr: LONG POINTER TO IOFace.IOCB;    num: CARDINAL;    helpTextPtr: LONG POINTER TO ODI.HelpText;    cmdRcrdPtr: LONG POINTER TO ODI.OptionsRecord;    opLPtr: LONG POINTER TO ODI.AnOptionLine;    IF NOT entriesWrappedAround AND entriesWordOffset = 0 THEN {      ODI.PutMessage[message: emptyMsg, beep: TRUE, clearMessageAreaFirst: TRUE];      RETURN};    cmdRcrdPtr _ ODI.GetAnOptionsRecord[numberOfLines: 6];    opLPtr _ ODI.GetAnOptionLine[optionsPerLine: 1];    cmdRcrdPtr.linesOfOptions[0] _ opLPtr;    opLPtr.optionsOnALine[0].position _ 5;    opLPtr.optionsOnALine[0].selectionNumberForThisItem _ 1;    opLPtr.optionsOnALine[0].option _ ioCmdMsgs[earlierEntry];    opLPtr.optionsOnALine[0].helpForThisOption _ ioCmdMsgs[      earlierEntryExpl];    opLPtr _ ODI.GetAnOptionLine[optionsPerLine: 1];    cmdRcrdPtr.linesOfOptions[1] _ opLPtr;    opLPtr.optionsOnALine[0].position _ 5;    opLPtr.optionsOnALine[0].selectionNumberForThisItem _ 2;    opLPtr.optionsOnALine[0].option _ ioCmdMsgs[laterEntry];    opLPtr.optionsOnALine[0].helpForThisOption _ ioCmdMsgs[laterEntryExpl];    opLPtr _ ODI.GetAnOptionLine[optionsPerLine: 1];    cmdRcrdPtr.linesOfOptions[2] _ opLPtr;    opLPtr.optionsOnALine[0].position _ 5;    opLPtr.optionsOnALine[0].selectionNumberForThisItem _ 3;    opLPtr.optionsOnALine[0].option _ ioCmdMsgs[sameEntry];    opLPtr.optionsOnALine[0].helpForThisOption _ ioCmdMsgs[sameEntryExpl];    opLPtr _ ODI.GetAnOptionLine[optionsPerLine: 1];    cmdRcrdPtr.linesOfOptions[3] _ opLPtr;    opLPtr.optionsOnALine[0].position _ 5;    opLPtr.optionsOnALine[0].selectionNumberForThisItem _ 4;    opLPtr.optionsOnALine[0].option _ ioCmdMsgs[firstEntry];    opLPtr.optionsOnALine[0].helpForThisOption _ ioCmdMsgs[firstEntryExpl];    opLPtr _ ODI.GetAnOptionLine[optionsPerLine: 1];    cmdRcrdPtr.linesOfOptions[4] _ opLPtr;    opLPtr.optionsOnALine[0].position _ 5;    opLPtr.optionsOnALine[0].selectionNumberForThisItem _ 5;    opLPtr.optionsOnALine[0].option _ ioCmdMsgs[lastEntry];    opLPtr.optionsOnALine[0].helpForThisOption _ ioCmdMsgs[lastEntryExpl];    opLPtr _ ODI.GetAnOptionLine[optionsPerLine: 1];    cmdRcrdPtr.linesOfOptions[5] _ opLPtr;    opLPtr.optionsOnALine[0].position _ 5;    opLPtr.optionsOnALine[0].selectionNumberForThisItem _ 6;    opLPtr.optionsOnALine[0].option _ ioCmdMsgs[exit];    opLPtr.optionsOnALine[0].helpForThisOption _ ioCmdMsgs[exitExpl];    helpTextPtr _ ODI.GetAHelpText[numberOfLines: 1];    helpTextPtr.textBody[0] _ ioCmdMsgs[enterCoiceInQuestion];    num _ ODI.GetAnOption[      optionTable: cmdRcrdPtr, optionPrompt: ioCmdMsgs[enterChoiceNum],      optionHelp: helpTextPtr];    ptrToEntry _ LOOPHOLE[logPtr];    IF entriesWrappedAround THEN maxEntries _ (logLength / entrySize)    ELSE maxEntries _ (entriesWordOffset / entrySize);    IF entriesWordOffset = 0 THEN {      --ie wrapped around      lastEntry _ entryIAmAt _ maxEntries; firstEntry _ 1; }    ELSE {      lastEntry _ entryIAmAt _ (entriesWordOffset / entrySize);      IF NOT entriesWrappedAround THEN firstEntry _ 1      ELSE firstEntry _ lastEntry + 1;      };    minPtr _ ptrToEntry;    maxPtr _ ptrToEntry + ((maxEntries - 1) * entrySize);    -- go to and display last entry    ptrToEntry _ minPtr + LOOPHOLE[((entryIAmAt - 1) * entrySize)];    DisplayEntry[];    IF logToBeDisplayed = stepCommandLog THEN RETURN;    exit _ FALSE;    UNTIL exit DO      num _ ODI.GetAnOption[        optionTable: cmdRcrdPtr, optionPrompt: ioCmdMsgs[enterChoiceNum],        optionHelp: helpTextPtr];      SELECT num FROM        1 => {          IF entryIAmAt = firstEntry THEN            ODI.PutData[data: ioCmdMsgs[noEarlierEntries]]          ELSE            IF entryIAmAt = 1 THEN {              ptrToEntry _ maxPtr; entryIAmAt _ maxEntries; DisplayEntry[]}            ELSE {              ptrToEntry _ ptrToEntry - entrySize;              entryIAmAt _ entryIAmAt - 1;              DisplayEntry[]}};        2 => {          IF entryIAmAt = lastEntry THEN            ODI.PutData[data: ioCmdMsgs[noLaterEntries]]          ELSE            IF entryIAmAt = maxEntries THEN {              ptrToEntry _ minPtr; entryIAmAt _ 1; DisplayEntry[]}            ELSE {              ptrToEntry _ ptrToEntry + entrySize;              entryIAmAt _ entryIAmAt + 1;              DisplayEntry[]}};        3 => DisplayEntry[];        4 => {          entryIAmAt _ firstEntry;          ptrToEntry _ minPtr + ((entryIAmAt - 1) * entrySize);          DisplayEntry[]};        5 => {          entryIAmAt _ lastEntry;          ptrToEntry _ minPtr + ((entryIAmAt - 1) * entrySize);          DisplayEntry[]};        6 => RETURN;        ENDCASE;      ENDLOOP;    };  -- of DisplayLogInternal.  --GetContollerStatus: PROCEDURE RETURNS[HardFace.Status] = {};      END...  LOG10-Feb-85 12:03:12	MXT	Created.22-Mar-85 12:22:06	MXT	Reduced codes.20-May-85 18:15:22	MXT	Removed unused codes.